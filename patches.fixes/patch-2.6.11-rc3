From: olh@suse.de
Subject: patch-2.6.11-rc3

diff -purN linux-2.6.11-rc2-bk10/CREDITS linux-2.6.11-rc3/CREDITS
--- linux-2.6.11-rc2-bk10/CREDITS	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/CREDITS	2005-02-03 02:56:22.000000000 +0100
@@ -3165,6 +3165,14 @@ S: Department of Zoology, University of 
 S: Seattle, WA  98195-1800
 S: USA
 
+N: Eugene Surovegin
+E: ebs@ebshome.net
+W: http://kernel.ebshome.net/
+P: 1024D/AE5467F1 FF22 39F1 6728 89F6 6E6C  2365 7602 F33D AE54 67F1
+D: Embedded PowerPC 4xx: I2C, PIC and random hacks/fixes
+S: Sunnyvale, California 94085
+S: USA
+
 N: Corey Thomas
 E: corey@world.std.com
 W: http://world.std.com/~corey/index.html
diff -purN linux-2.6.11-rc2-bk10/Documentation/devices.txt linux-2.6.11-rc3/Documentation/devices.txt
--- linux-2.6.11-rc2-bk10/Documentation/devices.txt	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/Documentation/devices.txt	2005-02-03 02:57:16.000000000 +0100
@@ -1,9 +1,9 @@
 
-		       LINUX ALLOCATED DEVICES
+		    LINUX ALLOCATED DEVICES (2.6+ version)
 
 	     Maintained by Torben Mathiasen <device@lanana.org>
 
-		      Last revised: 04 August 2004
+		      Last revised: 25 January 2005
 
 This list is the Linux Device List, the official registry of allocated
 device numbers and /dev directory nodes for the Linux operating
@@ -24,7 +24,8 @@ platform only.	Allocations marked (68k/A
 the Atari platform only.
 
 The symbol {2.6} means the allocation is obsolete and scheduled for
-removal once kernel version 2.6 (or equivalent) is released.
+removal once kernel version 2.6 (or equivalent) is released. Some of these
+allocations have already been removed.
 
 This document is in the public domain.	The author requests, however,
 that semantically altered versions are not distributed without
@@ -41,13 +42,6 @@ reply.
 
 	  **** DEVICE DRIVERS AUTHORS PLEASE READ THIS ****
 
-THE DEVICE REGISTRY IS OFFICIALLY FROZEN FOR LINUS TORVALDS' KERNEL
-TREE.  At Linus' request, no more allocations will be made official
-for Linus' kernel tree; the 3 June 2001 version of this list is the
-official final version of this registry.  At Alan Cox' request,
-however, the registry will continue to be maintained for the -ac
-series of kernels, and registrations will be accepted.
-
 To have a major number allocated, or a minor number in situations
 where that applies (e.g. busmice), please contact me with the
 appropriate device information.	 Also, if you have additional
@@ -436,6 +430,8 @@ Your cooperation is appreciated.
 		226 = /dev/systrace	Systrace device
 		227 = /dev/mcelog	X86_64 Machine Check Exception driver
 		228 = /dev/hpet		HPET driver
+		229 = /dev/fuse		Fuse (virtual filesystem in user-space)
+		230 = /dev/midishare	MidiShare driver
 		240-254			Reserved for local use
 		255			Reserved for MISC_DYNAMIC_MINOR
 
@@ -1176,7 +1172,7 @@ Your cooperation is appreciated.
 
 		Requested by: andy@scramdisklinux.org
 
- 65 char	Sundance "plink" Transputer boards
+ 65 char	Sundance "plink" Transputer boards (obsolete, unused)
 		  0 = /dev/plink0	First plink device
 		  1 = /dev/plink1	Second plink device
 		  2 = /dev/plink2	Third plink device
@@ -1526,12 +1522,12 @@ Your cooperation is appreciated.
 		disks (see major number 3) except that the limit on
 		partitions is 15.
 
- 83 char	Teletext/videotext interfaces {2.6}
-		  0 = /dev/vtx		Teletext decoder
-		 16 = /dev/vttuner	TV tuner on teletext interface
-
-		Devices for the driver contained in the VideoteXt package.
-		More information on http://home.pages.de/~videotext/
+ 83 char	Matrox mga_vid video driver
+ 		 0 = /dev/mga_vid0	1st video card
+		 1 = /dev/mga_vid1	2nd video card
+		 2 = /dev/mga_vid2	3rd video card
+		  ...
+	        15 = /dev/mga_vid15	16th video card
 
  83 block	I2O hard disk
 		  0 = /dev/i2o/hdaw	49th I2O hard disk, whole disk
@@ -1701,11 +1697,6 @@ Your cooperation is appreciated.
 		  3 = /dev/ipauth	Authentication control device/log file
 		    ...		
 
- 95 block	IBM S/390 VM/ESA minidisk
-		  0 = /dev/msd0		First VM/ESA minidisk
-		  1 = /dev/msd1		Second VM/ESA minidisk
-		    ...
-
  96 char	Parallel port ATAPI tape devices
 		  0 = /dev/pt0		First parallel port ATAPI tape
 		  1 = /dev/pt1		Second parallel port ATAPI tape
@@ -1742,10 +1733,14 @@ Your cooperation is appreciated.
 		See http://stm.lbl.gov/comedi or http://www.llp.fu-berlin.de/.
 
  98 block	User-mode virtual block device
-		  0 = /dev/ubd0		First user-mode block device
-		  1 = /dev/ubd1		Second user-mode block device
+		  0 = /dev/ubda		First user-mode block device
+		 16 = /dev/udbb		Second user-mode block device
 		    ...
 
+		Partitions are handled in the same way as for IDE
+		disks (see major number 3) except that the limit on
+		partitions is 15.
+
 		This device is used by the user-mode virtual kernel port.
 
  99 char	Raw parallel ports
@@ -2109,6 +2104,7 @@ Your cooperation is appreciated.
 		disks (see major number 3) except that the limit on
 		partitions is 15.
 
+130 char 	(Misc devices)
 
 130 block       SCSI disk devices (160-175)
                   0 = /dev/sdfe         161st SCSI disk whole disk
@@ -2546,7 +2542,12 @@ Your cooperation is appreciated.
 		  0 = /dev/usb/lp0	First USB printer
 		    ...
 		 15 = /dev/usb/lp15	16th USB printer
-		 32 = /dev/usb/mdc800	MDC800 USB camera
+		 16 = /dev/usb/mouse0	First USB mouse
+		    ...
+		 31 = /dev/usb/mouse15	16th USB mouse
+		 32 = /dev/usb/ez0	First USB firmware loader
+		    ...
+		 47 = /dev/usb/ez15	16th USB firmware loader
 		 48 = /dev/usb/scanner0	First USB scanner
 		    ...
 		 63 = /dev/usb/scanner15 16th USB scanner
@@ -2554,23 +2555,11 @@ Your cooperation is appreciated.
 		 65 = /dev/usb/usblcd	USBLCD Interface (info@usblcd.de)
 		 66 = /dev/usb/cpad0	Synaptics cPad (mouse/LCD)
 
-		 96 = /dev/usb/hiddev0	1st USB HID device
-		    ...
-		111 = /dev/usb/hiddev15	16th USB HID device
-		112 = /dev/usb/auer0	1st auerswald ISDN device
-		    ...
-		127 = /dev/usb/auer15	16th auerswald ISDN device
-		128 = /dev/usb/brlvgr0	First Braille Voyager device
-		    ...
-		131 = /dev/usb/brlvgr3	Fourth Braille Voyager device
-		132 = /dev/usb/idmouse	ID Mouse (fingerprint scanner) device
-		144 = /dev/usb/lcd	USB LCD device
-		160 = /dev/usb/legousbtower0	1st USB Legotower device
-		    ...
-		175 = /dev/usb/legousbtower15	16th USB Legotower device
-		240 = /dev/usb/dabusb0	First daubusb device
-		    ...
-		243 = /dev/usb/dabusb3	Fourth dabusb device
+180 block	USB block devices
+		0 = /dev/uba		First USB block device
+		8 = /dev/ubb		Second USB block device
+		16 = /dev/ubc		Thrid USB block device
+		...
 
 181 char	Conrad Electronic parallel port radio clocks
 		  0 = /dev/pcfclock0	First Conrad radio clock
@@ -2761,8 +2750,10 @@ Your cooperation is appreciated.
 		 45 = /dev/ttyMM1		Marvell MPSC - port 1
 		 46 = /dev/ttyCPM0		PPC CPM (SCC or SMC) - port 0
 		    ...
-		 49 = /dev/ttyCPM5		PPC CPM (SCC or SMC) - port 5
-
+		 47 = /dev/ttyCPM5		PPC CPM (SCC or SMC) - port 5
+		 50 = /dev/ttyIOC40		Altix serial card
+		    ...
+		 81 = /dev/ttyIOC431		Altix serial card
 
 205 char	Low-density serial ports (alternate device)
 		  0 = /dev/culu0		Callout device for ttyLU0
@@ -2788,12 +2779,16 @@ Your cooperation is appreciated.
 		    ...
 		 39 = /dev/cudb7		Callout device for ttyDB7
 		 40 = /dev/cusg0		Callout device for ttySG0
-		 41 = /dev/ttySMX0		Callout device for ttySMX0
-		 42 = /dev/ttySMX1		Callout device for ttySMX1
-		 43 = /dev/ttySMX2		Callout device for ttySMX2
+		 41 = /dev/ttycusmx0		Callout device for ttySMX0
+		 42 = /dev/ttycusmx1		Callout device for ttySMX1
+		 43 = /dev/ttycusmx2		Callout device for ttySMX2
 		 46 = /dev/cucpm0		Callout device for ttyCPM0
 		    ...
 		 49 = /dev/cucpm5		Callout device for ttyCPM5
+		 50 = /dev/cuioc40		Callout device for ttyIOC40
+		    ...
+		 81 = /dev/cuioc431		Callout device for ttyIOC431
+
 
 206 char	OnStream SC-x0 tape devices
 		  0 = /dev/osst0		First OnStream SCSI tape, mode 0
@@ -3007,7 +3002,12 @@ Your cooperation is appreciated.
 		ioctl()'s can be used to rewind the tape regardless of
 		the device used to access it.
 
-231-239		UNASSIGNED
+231 char	InfiniBand MAD
+		0 = /dev/infiniband/umad0
+		1 = /dev/infiniband/umad1
+		 ...
+
+232-239		UNASSIGNED
 
 240-254 char	LOCAL/EXPERIMENTAL USE
 240-254 block	LOCAL/EXPERIMENTAL USE
diff -purN linux-2.6.11-rc2-bk10/MAINTAINERS linux-2.6.11-rc3/MAINTAINERS
--- linux-2.6.11-rc2-bk10/MAINTAINERS	2005-02-03 10:03:08.689548689 +0100
+++ linux-2.6.11-rc3/MAINTAINERS	2005-02-03 02:56:10.000000000 +0100
@@ -1828,6 +1828,12 @@ M:	nico@cam.org
 L:	linux-arm-kernel@lists.arm.linux.org.uk
 S:	Maintained
 
+QLOGIC QLA2XXX FC-SCSI DRIVER
+P:	Andrew Vasquez
+M:	andrew.vasquez@qlogic.com
+L:	linux-scsi@vger.kernel.org
+S:	Supported
+
 QNX4 FILESYSTEM
 P:	Anders Larsen
 M:	al@alarsen.net
diff -purN linux-2.6.11-rc2-bk10/Makefile linux-2.6.11-rc3/Makefile
--- linux-2.6.11-rc2-bk10/Makefile	2005-02-03 10:03:08.692548222 +0100
+++ linux-2.6.11-rc3/Makefile	2005-02-03 02:56:11.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc2-bk10
+EXTRAVERSION =-rc3
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc2-bk10/arch/arm/boot/compressed/head-xscale.S linux-2.6.11-rc3/arch/arm/boot/compressed/head-xscale.S
--- linux-2.6.11-rc2-bk10/arch/arm/boot/compressed/head-xscale.S	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/boot/compressed/head-xscale.S	2005-02-03 02:55:23.000000000 +0100
@@ -42,3 +42,8 @@ __XScale_start:
 		mov	r7, #MACH_TYPE_COTULLA_IDP
 #endif
 
+#ifdef  CONFIG_MACH_GTWX5715
+               mov     r7, #(MACH_TYPE_GTWX5715 & 0xff)
+               orr     r7, r7, #(MACH_TYPE_GTWX5715 & 0xff00)
+#endif
+
diff -purN linux-2.6.11-rc2-bk10/arch/arm/configs/omap_h2_1610_defconfig linux-2.6.11-rc3/arch/arm/configs/omap_h2_1610_defconfig
--- linux-2.6.11-rc2-bk10/arch/arm/configs/omap_h2_1610_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/configs/omap_h2_1610_defconfig	2005-02-03 02:57:04.000000000 +0100
@@ -0,0 +1,935 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc2
+# Tue Feb  1 14:01:46 2005
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+CONFIG_ARCH_OMAP=y
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_H720X is not set
+
+#
+# TI OMAP Implementations
+#
+
+#
+# OMAP Core Type
+#
+# CONFIG_ARCH_OMAP730 is not set
+# CONFIG_ARCH_OMAP1510 is not set
+CONFIG_ARCH_OMAP16XX=y
+CONFIG_ARCH_OMAP_OTG=y
+
+#
+# OMAP Board Type
+#
+# CONFIG_MACH_OMAP_INNOVATOR is not set
+CONFIG_MACH_OMAP_H2=y
+# CONFIG_MACH_OMAP_H3 is not set
+# CONFIG_MACH_OMAP_H4 is not set
+# CONFIG_MACH_OMAP_OSK is not set
+# CONFIG_MACH_OMAP_GENERIC is not set
+
+#
+# OMAP Feature Selections
+#
+CONFIG_OMAP_MUX=y
+# CONFIG_OMAP_MUX_DEBUG is not set
+CONFIG_OMAP_MUX_WARNINGS=y
+CONFIG_OMAP_LL_DEBUG_UART1=y
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+# CONFIG_OMAP_LL_DEBUG_UART3 is not set
+CONFIG_OMAP_ARM_192MHZ=y
+# CONFIG_OMAP_ARM_168MHZ is not set
+# CONFIG_OMAP_ARM_120MHZ is not set
+# CONFIG_OMAP_ARM_60MHZ is not set
+# CONFIG_OMAP_ARM_30MHZ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# General setup
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_XIP_KERNEL is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# At least one math emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+CONFIG_DEBUG_DRIVER=y
+CONFIG_PM=y
+CONFIG_PREEMPT=y
+# CONFIG_APM is not set
+# CONFIG_ARTHUR is not set
+CONFIG_CMDLINE="mem=32M console=ttyS0,115200n8 root=0801 ro init=/bin/sh"
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+CONFIG_MTD_DEBUG=y
+CONFIG_MTD_DEBUG_VERBOSE=3
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_EDB7312 is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPPOE is not set
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+# CONFIG_SLIP_SMART is not set
+# CONFIG_SLIP_MODE_SLIP6 is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+# CONFIG_BLK_DEV_SD is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=y
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+CONFIG_ISP1301_OMAP=y
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+# CONFIG_VFAT_FS is not set
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=2
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_FS_NOR_ECC is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+
+#
+# Misc devices
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_SA1100 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_OMAP=y
+CONFIG_USB_OMAP=y
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=y
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_WAITQ is not set
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/asm-offsets.c linux-2.6.11-rc3/arch/arm/kernel/asm-offsets.c
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/asm-offsets.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/asm-offsets.c	2005-02-03 02:55:08.000000000 +0100
@@ -59,6 +59,7 @@ int main(void)
   DEFINE(TI_CPU_DOMAIN,		offsetof(struct thread_info, cpu_domain));
   DEFINE(TI_CPU_SAVE,		offsetof(struct thread_info, cpu_context));
   DEFINE(TI_USED_CP,		offsetof(struct thread_info, used_cp));
+  DEFINE(TI_TP_VALUE,		offsetof(struct thread_info, tp_value));
   DEFINE(TI_FPSTATE,		offsetof(struct thread_info, fpstate));
   DEFINE(TI_VFPSTATE,		offsetof(struct thread_info, vfpstate));
   DEFINE(TI_IWMMXT_STATE,	(offsetof(struct thread_info, fpstate)+4)&~7);
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/calls.S linux-2.6.11-rc3/arch/arm/kernel/calls.S
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/calls.S	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/calls.S	2005-02-03 02:57:04.000000000 +0100
@@ -270,7 +270,7 @@ __syscall_start:
 	 	.long	sys_remap_file_pages
 		.long	sys_ni_syscall	/* sys_set_thread_area */
 /* 255 */	.long	sys_ni_syscall	/* sys_get_thread_area */
- 		.long	sys_ni_syscall	/* sys_set_tid_address */
+ 		.long	sys_set_tid_address
 		.long	sys_timer_create
 		.long	sys_timer_settime
 		.long	sys_timer_gettime
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/entry-armv.S linux-2.6.11-rc3/arch/arm/kernel/entry-armv.S
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/entry-armv.S	2005-02-03 10:03:08.707545888 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/entry-armv.S	2005-02-03 02:55:35.000000000 +0100
@@ -34,27 +34,27 @@
 	.endm
 
 __pabt_invalid:
-		inv_entry abt, BAD_PREFETCH
-		b	1f
+	inv_entry abt, BAD_PREFETCH
+	b	1f
 
 __dabt_invalid:
-		inv_entry abt, BAD_DATA
-		b	1f
+	inv_entry abt, BAD_DATA
+	b	1f
 
 __irq_invalid:
-		inv_entry irq, BAD_IRQ
-		b	1f
+	inv_entry irq, BAD_IRQ
+	b	1f
 
 __und_invalid:
-		inv_entry und, BAD_UNDEFINSTR
+	inv_entry und, BAD_UNDEFINSTR
 
-1:		zero_fp
-		ldmia	r4, {r5 - r7}			@ Get XXX pc, cpsr, old_r0
-		add	r4, sp, #S_PC
-		stmia	r4, {r5 - r7}			@ Save XXX pc, cpsr, old_r0
-		mov	r0, sp
-		and	r2, r6, #31			@ int mode
-		b	bad_mode
+1:	zero_fp
+	ldmia	r4, {r5 - r7}			@ Get XXX pc, cpsr, old_r0
+	add	r4, sp, #S_PC
+	stmia	r4, {r5 - r7}			@ Save XXX pc, cpsr, old_r0
+	mov	r0, sp
+	and	r2, r6, #31			@ int mode
+	b	bad_mode
 
 /*
  * SVC mode handlers
@@ -67,125 +67,196 @@ __und_invalid:
 	ldmia	r2, {r2 - r4}			@ get pc, cpsr
 	add	r5, sp, #S_SP
 	mov	r1, lr
-	stmia	r5, {r0 - r4}			@ save sp_SVC, lr_SVC, pc, cpsr, old_ro
+
+	@
+	@ We are now ready to fill in the remaining blanks on the stack:
+	@
+	@  r0 - sp_svc
+	@  r1 - lr_svc
+	@  r2 - lr_<exception>, already fixed up for correct return/restart
+	@  r3 - spsr_<exception>
+	@  r4 - orig_r0 (see pt_regs definition in ptrace.h)
+	@
+	stmia	r5, {r0 - r4}
 	.endm
 
-		.align	5
+	.align	5
 __dabt_svc:
-		svc_entry abt
-		mrs	r9, cpsr			@ Enable interrupts if they were
-		tst	r3, #PSR_I_BIT
-		biceq	r9, r9, #PSR_I_BIT		@ previously
-/*
- * This routine must not corrupt r9
- */
+	svc_entry abt
+
+	@
+	@ get ready to re-enable interrupts if appropriate
+	@
+	mrs	r9, cpsr
+	tst	r3, #PSR_I_BIT
+	biceq	r9, r9, #PSR_I_BIT
+
+	@
+	@ Call the processor-specific abort handler:
+	@
+	@  r2 - aborted context pc
+	@  r3 - aborted context cpsr
+	@
+	@ The abort handler must return the aborted address in r0, and
+	@ the fault status register in r1.  r9 must be preserved.
+	@
 #ifdef MULTI_ABORT
-		ldr	r4, .LCprocfns			@ pass r2, r3 to
-		mov	lr, pc				@ processor code
-		ldr	pc, [r4]			@ call processor specific code
+	ldr	r4, .LCprocfns
+	mov	lr, pc
+	ldr	pc, [r4]
 #else
-		bl	CPU_ABORT_HANDLER
+	bl	CPU_ABORT_HANDLER
 #endif
-		msr	cpsr_c, r9
-		mov	r2, sp
-		bl	do_DataAbort
-		disable_irq r0
-		ldr	r0, [sp, #S_PSR]
-		msr	spsr_cxsf, r0
-		ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
 
-		.align	5
+	@
+	@ set desired IRQ state, then call main handler
+	@
+	msr	cpsr_c, r9
+	mov	r2, sp
+	bl	do_DataAbort
+
+	@
+	@ IRQs off again before pulling preserved data off the stack
+	@
+	disable_irq r0
+
+	@
+	@ restore SPSR and restart the instruction
+	@
+	ldr	r0, [sp, #S_PSR]
+	msr	spsr_cxsf, r0
+	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+
+	.align	5
 __irq_svc:
-		svc_entry irq
+	svc_entry irq
 #ifdef CONFIG_PREEMPT
-		get_thread_info r8
-		ldr	r9, [r8, #TI_PREEMPT]		@ get preempt count
-		add	r7, r9, #1			@ increment it
-		str	r7, [r8, #TI_PREEMPT]
-#endif
-1:		get_irqnr_and_base r0, r6, r5, lr
-		movne	r1, sp
-		@
-		@ routine called with r0 = irq number, r1 = struct pt_regs *
-		@
-		adrsvc	ne, lr, 1b
-		bne	asm_do_IRQ
+	get_thread_info r8
+	ldr	r9, [r8, #TI_PREEMPT]		@ get preempt count
+	add	r7, r9, #1			@ increment it
+	str	r7, [r8, #TI_PREEMPT]
+#endif
+1:	get_irqnr_and_base r0, r6, r5, lr
+	movne	r1, sp
+	@
+	@ routine called with r0 = irq number, r1 = struct pt_regs *
+	@
+	adrne	lr, 1b
+	bne	asm_do_IRQ
 #ifdef CONFIG_PREEMPT
-		ldr	r0, [r8, #TI_FLAGS]		@ get flags
-		tst	r0, #_TIF_NEED_RESCHED
-		blne	svc_preempt
+	ldr	r0, [r8, #TI_FLAGS]		@ get flags
+	tst	r0, #_TIF_NEED_RESCHED
+	blne	svc_preempt
 preempt_return:
-		ldr	r0, [r8, #TI_PREEMPT]		@ read preempt value
-		teq	r0, r7
-		str	r9, [r8, #TI_PREEMPT]		@ restore preempt count
-		strne	r0, [r0, -r0]			@ bug()
-#endif
-		ldr	r0, [sp, #S_PSR]		@ irqs are already disabled
-		msr	spsr_cxsf, r0
-		ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+	ldr	r0, [r8, #TI_PREEMPT]		@ read preempt value
+	teq	r0, r7
+	str	r9, [r8, #TI_PREEMPT]		@ restore preempt count
+	strne	r0, [r0, -r0]			@ bug()
+#endif
+	ldr	r0, [sp, #S_PSR]		@ irqs are already disabled
+	msr	spsr_cxsf, r0
+	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
 
-		.ltorg
+	.ltorg
 
 #ifdef CONFIG_PREEMPT
-svc_preempt:	teq	r9, #0				@ was preempt count = 0
-		ldreq	r6, .LCirq_stat
-		movne	pc, lr				@ no
-		ldr	r0, [r6, #4]			@ local_irq_count
-		ldr	r1, [r6, #8]			@ local_bh_count
-		adds	r0, r0, r1
-		movne	pc, lr
-		mov	r7, #PREEMPT_ACTIVE
-		str	r7, [r8, #TI_PREEMPT]		@ set PREEMPT_ACTIVE
-1:		enable_irq r2				@ enable IRQs
-		bl	schedule
-		disable_irq r0				@ disable IRQs
-		ldr	r0, [r8, #TI_FLAGS]		@ get new tasks TI_FLAGS
-		tst	r0, #_TIF_NEED_RESCHED
-		beq	preempt_return			@ go again
-		b	1b
+svc_preempt:
+	teq	r9, #0				@ was preempt count = 0
+	ldreq	r6, .LCirq_stat
+	movne	pc, lr				@ no
+	ldr	r0, [r6, #4]			@ local_irq_count
+	ldr	r1, [r6, #8]			@ local_bh_count
+	adds	r0, r0, r1
+	movne	pc, lr
+	mov	r7, #0				@ preempt_schedule_irq
+	str	r7, [r8, #TI_PREEMPT]		@ expects preempt_count == 0
+1:	bl	preempt_schedule_irq		@ irq en/disable is done inside
+	ldr	r0, [r8, #TI_FLAGS]		@ get new tasks TI_FLAGS
+	tst	r0, #_TIF_NEED_RESCHED
+	beq	preempt_return			@ go again
+	b	1b
 #endif
 
-		.align	5
+	.align	5
 __und_svc:
-		svc_entry und
+	svc_entry und
+
+	@
+	@ call emulation code, which returns using r9 if it has emulated
+	@ the instruction, or the more conventional lr if we are to treat
+	@ this as a real undefined instruction
+	@
+	@  r0 - instruction
+	@
+	ldr	r0, [r2, #-4]
+	adr	r9, 1f
+	bl	call_fpe
 
-		ldr	r0, [r2, #-4]			@ r0 = instruction
-		adrsvc	al, r9, 1f			@ r9 = normal FP return
-		bl	call_fpe			@ lr = undefined instr return
+	mov	r0, sp				@ struct pt_regs *regs
+	bl	do_undefinstr
 
-		mov	r0, sp				@ struct pt_regs *regs
-		bl	do_undefinstr
+	@
+	@ IRQs off again before pulling preserved data off the stack
+	@
+1:	disable_irq r0
 
-1:		disable_irq r0
-		ldr	lr, [sp, #S_PSR]		@ Get SVC cpsr
-		msr	spsr_cxsf, lr
-		ldmia	sp, {r0 - pc}^			@ Restore SVC registers
+	@
+	@ restore SPSR and restart the instruction
+	@
+	ldr	lr, [sp, #S_PSR]		@ Get SVC cpsr
+	msr	spsr_cxsf, lr
+	ldmia	sp, {r0 - pc}^			@ Restore SVC registers
 
-		.align	5
+	.align	5
 __pabt_svc:
-		svc_entry abt
-		mrs	r9, cpsr			@ Enable interrupts if they were
-		tst	r3, #PSR_I_BIT
-		biceq	r9, r9, #PSR_I_BIT		@ previously
-		msr	cpsr_c, r9
-		mov	r0, r2				@ address (pc)
-		mov	r1, sp				@ regs
-		bl	do_PrefetchAbort		@ call abort handler
-		disable_irq r0
-		ldr	r0, [sp, #S_PSR]
-		msr	spsr_cxsf, r0
-		ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
-
-		.align	5
-.LCirq:		.word	__temp_irq
-.LCund:		.word	__temp_und
-.LCabt:		.word	__temp_abt
+	svc_entry abt
+
+	@
+	@ re-enable interrupts if appropriate
+	@
+	mrs	r9, cpsr
+	tst	r3, #PSR_I_BIT
+	biceq	r9, r9, #PSR_I_BIT
+	msr	cpsr_c, r9
+
+	@
+	@ set args, then call main handler
+	@
+	@  r0 - address of faulting instruction
+	@  r1 - pointer to registers on stack
+	@
+	mov	r0, r2				@ address (pc)
+	mov	r1, sp				@ regs
+	bl	do_PrefetchAbort		@ call abort handler
+
+	@
+	@ IRQs off again before pulling preserved data off the stack
+	@
+	disable_irq r0
+
+	@
+	@ restore SPSR and restart the instruction
+	@
+	ldr	r0, [sp, #S_PSR]
+	msr	spsr_cxsf, r0
+	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+
+	.align	5
+.LCirq:
+	.word	__temp_irq
+.LCund:
+	.word	__temp_und
+.LCabt:
+	.word	__temp_abt
 #ifdef MULTI_ABORT
-.LCprocfns:	.word	processor
+.LCprocfns:
+	.word	processor
 #endif
-.LCfp:		.word	fp_enter
+.LCfp:
+	.word	fp_enter
 #ifdef CONFIG_PREEMPT
-.LCirq_stat:	.word	irq_stat
+.LCirq_stat:
+	.word	irq_stat
 #endif
 
 /*
@@ -197,80 +268,115 @@ __pabt_svc:
 	ldr	r7, .LC\sym
 	add	r5, sp, #S_PC
 	ldmia	r7, {r2 - r4}			@ Get USR pc, cpsr
-	stmia	r5, {r2 - r4}			@ Save USR pc, cpsr, old_r0
+
+	@
+	@ We are now ready to fill in the remaining blanks on the stack:
+	@
+	@  r2 - lr_<exception>, already fixed up for correct return/restart
+	@  r3 - spsr_<exception>
+	@  r4 - orig_r0 (see pt_regs definition in ptrace.h)
+	@
+	@ Also, separately save sp_usr and lr_usr
+	@
+	stmia	r5, {r2 - r4}
 	stmdb	r5, {sp, lr}^
 	.endm
 
-		.align	5
+	.align	5
 __dabt_usr:
-		usr_entry abt
-		alignment_trap r7, r0, __temp_abt
-		zero_fp
+	usr_entry abt
+	alignment_trap r7, r0, __temp_abt
+	zero_fp
+
+	@
+	@ Call the processor-specific abort handler:
+	@
+	@  r2 - aborted context pc
+	@  r3 - aborted context cpsr
+	@
+	@ The abort handler must return the aborted address in r0, and
+	@ the fault status register in r1.
+	@
 #ifdef MULTI_ABORT
-		ldr	r4, .LCprocfns			@ pass r2, r3 to
-		mov	lr, pc				@ processor code
-		ldr	pc, [r4]			@ call processor specific code
+	ldr	r4, .LCprocfns
+	mov	lr, pc
+	ldr	pc, [r4]
 #else
-		bl	CPU_ABORT_HANDLER
+	bl	CPU_ABORT_HANDLER
 #endif
-		enable_irq r2				@ Enable interrupts
-		mov	r2, sp
-		adrsvc	al, lr, ret_from_exception
-		b	do_DataAbort
 
-		.align	5
+	@
+	@ IRQs on, then call the main handler
+	@
+	enable_irq r2
+	mov	r2, sp
+	adr	lr, ret_from_exception
+	b	do_DataAbort
+
+	.align	5
 __irq_usr:
-		usr_entry irq
-		alignment_trap r7, r0, __temp_irq
-		zero_fp
+	usr_entry irq
+	alignment_trap r7, r0, __temp_irq
+	zero_fp
 #ifdef CONFIG_PREEMPT
-		get_thread_info r8
-		ldr	r9, [r8, #TI_PREEMPT]		@ get preempt count
-		add	r7, r9, #1			@ increment it
-		str	r7, [r8, #TI_PREEMPT]
-#endif
-1:		get_irqnr_and_base r0, r6, r5, lr
-		movne	r1, sp
-		adrsvc	ne, lr, 1b
-		@
-		@ routine called with r0 = irq number, r1 = struct pt_regs *
-		@
-		bne	asm_do_IRQ
+	get_thread_info r8
+	ldr	r9, [r8, #TI_PREEMPT]		@ get preempt count
+	add	r7, r9, #1			@ increment it
+	str	r7, [r8, #TI_PREEMPT]
+#endif
+1:	get_irqnr_and_base r0, r6, r5, lr
+	movne	r1, sp
+	adrne	lr, 1b
+	@
+	@ routine called with r0 = irq number, r1 = struct pt_regs *
+	@
+	bne	asm_do_IRQ
 #ifdef CONFIG_PREEMPT
-		ldr	r0, [r8, #TI_PREEMPT]
-		teq	r0, r7
-		str	r9, [r8, #TI_PREEMPT]
-		strne	r0, [r0, -r0]
-		mov	tsk, r8
+	ldr	r0, [r8, #TI_PREEMPT]
+	teq	r0, r7
+	str	r9, [r8, #TI_PREEMPT]
+	strne	r0, [r0, -r0]
+	mov	tsk, r8
 #else
-		get_thread_info tsk
+	get_thread_info tsk
 #endif
-		mov	why, #0
-		b	ret_to_user
+	mov	why, #0
+	b	ret_to_user
 
-		.ltorg
+	.ltorg
 
-		.align	5
+	.align	5
 __und_usr:
-		usr_entry und
-		alignment_trap r7, r0, __temp_und
-		zero_fp
-		tst	r3, #PSR_T_BIT			@ Thumb mode?
-		bne	fpundefinstr			@ ignore FP
-		sub	r4, r2, #4
-1:		ldrt	r0, [r4]			@ r0  = instruction
-		adrsvc	al, r9, ret_from_exception	@ r9  = normal FP return
-		adrsvc	al, lr, fpundefinstr		@ lr  = undefined instr return
+	usr_entry und
+	alignment_trap r7, r0, __temp_und
+	zero_fp
+	tst	r3, #PSR_T_BIT			@ Thumb mode?
+	bne	fpundefinstr			@ ignore FP
+	sub	r4, r2, #4
+
+	@
+	@ fall through to the emulation code, which returns using r9 if
+	@ it has emulated the instruction, or the more conventional lr
+	@ if we are to treat this as a real undefined instruction
+	@
+	@  r0 - instruction
+	@
+1:	ldrt	r0, [r4]
+	adr	r9, ret_from_exception
+	adr	lr, fpundefinstr
+	@
+	@ fallthrough to call_fpe
+	@
 
 /*
  * The out of line fixup for the ldrt above.
  */
-		.section .fixup, "ax"
-2:		mov	pc, r9
-		.previous
-		.section __ex_table,"a"
-		.long	1b, 2b
-		.previous
+	.section .fixup, "ax"
+2:	mov	pc, r9
+	.previous
+	.section __ex_table,"a"
+	.long	1b, 2b
+	.previous
 
 /*
  * r0 = instruction.
@@ -289,53 +395,54 @@ __und_usr:
  *  r10 - this threads thread_info structure.
  */
 call_fpe:
-		tst	r0, #0x08000000			@ only CDP/CPRT/LDC/STC have bit 27
+	tst	r0, #0x08000000			@ only CDP/CPRT/LDC/STC have bit 27
 #if defined(CONFIG_CPU_ARM610) || defined(CONFIG_CPU_ARM710)
-		and	r8, r0, #0x0f000000		@ mask out op-code bits
-		teqne	r8, #0x0f000000			@ SWI (ARM6/7 bug)?
+	and	r8, r0, #0x0f000000		@ mask out op-code bits
+	teqne	r8, #0x0f000000			@ SWI (ARM6/7 bug)?
 #endif
-		moveq	pc, lr
-		get_thread_info r10			@ get current thread
-		and	r8, r0, #0x00000f00		@ mask out CP number
-		mov	r7, #1
-		add	r6, r10, #TI_USED_CP
-		strb	r7, [r6, r8, lsr #8]		@ set appropriate used_cp[]
+	moveq	pc, lr
+	get_thread_info r10			@ get current thread
+	and	r8, r0, #0x00000f00		@ mask out CP number
+	mov	r7, #1
+	add	r6, r10, #TI_USED_CP
+	strb	r7, [r6, r8, lsr #8]		@ set appropriate used_cp[]
 #ifdef CONFIG_IWMMXT
-		@ Test if we need to give access to iWMMXt coprocessors
-		ldr	r5, [r10, #TI_FLAGS]
-		rsbs	r7, r8, #(1 << 8)		@ CP 0 or 1 only
-		movcss	r7, r5, lsr #(TIF_USING_IWMMXT + 1)
-		bcs	iwmmxt_task_enable
-#endif
-		enable_irq r7
-		add	pc, pc, r8, lsr #6
-		mov	r0, r0
-
-		mov	pc, lr				@ CP#0
-		b	do_fpe				@ CP#1 (FPE)
-		b	do_fpe				@ CP#2 (FPE)
-		mov	pc, lr				@ CP#3
-		mov	pc, lr				@ CP#4
-		mov	pc, lr				@ CP#5
-		mov	pc, lr				@ CP#6
-		mov	pc, lr				@ CP#7
-		mov	pc, lr				@ CP#8
-		mov	pc, lr				@ CP#9
+	@ Test if we need to give access to iWMMXt coprocessors
+	ldr	r5, [r10, #TI_FLAGS]
+	rsbs	r7, r8, #(1 << 8)		@ CP 0 or 1 only
+	movcss	r7, r5, lsr #(TIF_USING_IWMMXT + 1)
+	bcs	iwmmxt_task_enable
+#endif
+	enable_irq r7
+	add	pc, pc, r8, lsr #6
+	mov	r0, r0
+
+	mov	pc, lr				@ CP#0
+	b	do_fpe				@ CP#1 (FPE)
+	b	do_fpe				@ CP#2 (FPE)
+	mov	pc, lr				@ CP#3
+	mov	pc, lr				@ CP#4
+	mov	pc, lr				@ CP#5
+	mov	pc, lr				@ CP#6
+	mov	pc, lr				@ CP#7
+	mov	pc, lr				@ CP#8
+	mov	pc, lr				@ CP#9
 #ifdef CONFIG_VFP
-		b	do_vfp				@ CP#10 (VFP)
-		b	do_vfp				@ CP#11 (VFP)
+	b	do_vfp				@ CP#10 (VFP)
+	b	do_vfp				@ CP#11 (VFP)
 #else
-		mov	pc, lr				@ CP#10 (VFP)
-		mov	pc, lr				@ CP#11 (VFP)
+	mov	pc, lr				@ CP#10 (VFP)
+	mov	pc, lr				@ CP#11 (VFP)
 #endif
-		mov	pc, lr				@ CP#12
-		mov	pc, lr				@ CP#13
-		mov	pc, lr				@ CP#14 (Debug)
-		mov	pc, lr				@ CP#15 (Control)
-
-do_fpe:		ldr	r4, .LCfp
-		add	r10, r10, #TI_FPSTATE		@ r10 = workspace
-		ldr	pc, [r4]			@ Call FP module USR entry point
+	mov	pc, lr				@ CP#12
+	mov	pc, lr				@ CP#13
+	mov	pc, lr				@ CP#14 (Debug)
+	mov	pc, lr				@ CP#15 (Control)
+
+do_fpe:
+	ldr	r4, .LCfp
+	add	r10, r10, #TI_FPSTATE		@ r10 = workspace
+	ldr	pc, [r4]			@ Call FP module USR entry point
 
 /*
  * The FP module is called with these registers set:
@@ -346,32 +453,33 @@ do_fpe:		ldr	r4, .LCfp
  *  lr  = unrecognised FP instruction return address
  */
 
-		.data
+	.data
 ENTRY(fp_enter)
-		.word	fpundefinstr
-		.text
+	.word	fpundefinstr
+	.text
 
-fpundefinstr:	mov	r0, sp
-		adrsvc	al, lr, ret_from_exception
-		b	do_undefinstr
+fpundefinstr:
+	mov	r0, sp
+	adr	lr, ret_from_exception
+	b	do_undefinstr
 
-		.align	5
+	.align	5
 __pabt_usr:
-		usr_entry abt
-		alignment_trap r7, r0, __temp_abt
-		zero_fp
-		enable_irq r0				@ Enable interrupts
-		mov	r0, r5				@ address (pc)
-		mov	r1, sp				@ regs
-		bl	do_PrefetchAbort		@ call abort handler
-		/* fall through */
+	usr_entry abt
+	alignment_trap r7, r0, __temp_abt
+	zero_fp
+	enable_irq r0				@ Enable interrupts
+	mov	r0, r2				@ address (pc)
+	mov	r1, sp				@ regs
+	bl	do_PrefetchAbort		@ call abort handler
+	/* fall through */
 /*
  * This is the return code to user mode for abort handlers
  */
 ENTRY(ret_from_exception)
-		get_thread_info tsk
-		mov	why, #0
-		b	ret_to_user
+	get_thread_info tsk
+	mov	why, #0
+	b	ret_to_user
 
 /*
  * Register switch for ARMv3 and ARMv4 processors
@@ -379,31 +487,34 @@ ENTRY(ret_from_exception)
  * previous and next are guaranteed not to be the same.
  */
 ENTRY(__switch_to)
-		add	ip, r1, #TI_CPU_SAVE
-		ldr	r3, [r2, #TI_CPU_DOMAIN]!
-		stmia	ip!, {r4 - sl, fp, sp, lr}	@ Store most regs on stack
+	add	ip, r1, #TI_CPU_SAVE
+	ldr	r3, [r2, #TI_TP_VALUE]
+	stmia	ip!, {r4 - sl, fp, sp, lr}	@ Store most regs on stack
+	ldr	r6, [r2, #TI_CPU_DOMAIN]!
 #if defined(CONFIG_CPU_XSCALE) && !defined(CONFIG_IWMMXT)
-		mra	r4, r5, acc0
-		stmia   ip, {r4, r5}
+	mra	r4, r5, acc0
+	stmia   ip, {r4, r5}
 #endif
-		mcr	p15, 0, r3, c3, c0, 0		@ Set domain register
+	mov	r4, #0xffff0fff
+	str	r3, [r4, #-3]			@ Set TLS ptr
+	mcr	p15, 0, r6, c3, c0, 0		@ Set domain register
 #ifdef CONFIG_VFP
-		@ Always disable VFP so we can lazily save/restore the old
-		@ state. This occurs in the context of the previous thread.
-		VFPFMRX	r4, FPEXC
-		bic	r4, r4, #FPEXC_ENABLE
-		VFPFMXR	FPEXC, r4
+	@ Always disable VFP so we can lazily save/restore the old
+	@ state. This occurs in the context of the previous thread.
+	VFPFMRX	r4, FPEXC
+	bic	r4, r4, #FPEXC_ENABLE
+	VFPFMXR	FPEXC, r4
 #endif
 #if defined(CONFIG_IWMMXT)
-		bl	iwmmxt_task_switch
+	bl	iwmmxt_task_switch
 #elif defined(CONFIG_CPU_XSCALE)
-		add	r4, r2, #40			@ cpu_context_save->extra
-		ldmib	r4, {r4, r5}
-		mar	acc0, r4, r5
+	add	r4, r2, #40			@ cpu_context_save->extra
+	ldmib	r4, {r4, r5}
+	mar	acc0, r4, r5
 #endif
-		ldmib	r2, {r4 - sl, fp, sp, pc}	@ Load all regs saved previously
+	ldmib	r2, {r4 - sl, fp, sp, pc}	@ Load all regs saved previously
 
-		__INIT
+	__INIT
 /*
  * Vector stubs.
  *
@@ -541,8 +652,9 @@ __stubs_start:
  * other mode than FIQ...  Ok you can switch to another mode, but you can't
  * get out of that mode without clobbering one register.
  */
-vector_fiq:	disable_fiq
-		subs	pc, lr, #4
+vector_fiq:
+	disable_fiq
+	subs	pc, lr, #4
 
 /*=============================================================================
  * Address exception handler
@@ -552,70 +664,78 @@ vector_fiq:	disable_fiq
  */
 
 vector_addrexcptn:
-		b	vector_addrexcptn
+	b	vector_addrexcptn
 
 /*
  * We group all the following data together to optimise
  * for CPUs with separate I & D caches.
  */
-		.align	5
+	.align	5
 
-.LCvswi:	.word	vector_swi
+.LCvswi:
+	.word	vector_swi
 
-.LCsirq:	.word	__temp_irq
-.LCsund:	.word	__temp_und
-.LCsabt:	.word	__temp_abt
+.LCsirq:
+	.word	__temp_irq
+.LCsund:
+	.word	__temp_und
+.LCsabt:
+	.word	__temp_abt
 
 __stubs_end:
 
-		.equ	__real_stubs_start, .LCvectors + 0x200
+	.equ	__real_stubs_start, .LCvectors + 0x200
 
-.LCvectors:	swi	SYS_ERROR0
-		b	__real_stubs_start + (vector_und - __stubs_start)
-		ldr	pc, __real_stubs_start + (.LCvswi - __stubs_start)
-		b	__real_stubs_start + (vector_pabt - __stubs_start)
-		b	__real_stubs_start + (vector_dabt - __stubs_start)
-		b	__real_stubs_start + (vector_addrexcptn - __stubs_start)
-		b	__real_stubs_start + (vector_irq - __stubs_start)
-		b	__real_stubs_start + (vector_fiq - __stubs_start)
+.LCvectors:
+	swi	SYS_ERROR0
+	b	__real_stubs_start + (vector_und - __stubs_start)
+	ldr	pc, __real_stubs_start + (.LCvswi - __stubs_start)
+	b	__real_stubs_start + (vector_pabt - __stubs_start)
+	b	__real_stubs_start + (vector_dabt - __stubs_start)
+	b	__real_stubs_start + (vector_addrexcptn - __stubs_start)
+	b	__real_stubs_start + (vector_irq - __stubs_start)
+	b	__real_stubs_start + (vector_fiq - __stubs_start)
 
 ENTRY(__trap_init)
-		stmfd	sp!, {r4 - r6, lr}
+	stmfd	sp!, {r4 - r6, lr}
 
-		mov	r0, #0xff000000
-		orr	r0, r0, #0x00ff0000		@ high vectors position
-		adr	r1, .LCvectors			@ set up the vectors
-		ldmia	r1, {r1, r2, r3, r4, r5, r6, ip, lr}
-		stmia	r0, {r1, r2, r3, r4, r5, r6, ip, lr}
-
-		add	r2, r0, #0x200
-		adr	r0, __stubs_start		@ copy stubs to 0x200
-		adr	r1, __stubs_end
-1:		ldr	r3, [r0], #4
-		str	r3, [r2], #4
-		cmp	r0, r1
-		blt	1b
-		LOADREGS(fd, sp!, {r4 - r6, pc})
+	mov	r0, #0xff000000
+	orr	r0, r0, #0x00ff0000		@ high vectors position
+	adr	r1, .LCvectors			@ set up the vectors
+	ldmia	r1, {r1, r2, r3, r4, r5, r6, ip, lr}
+	stmia	r0, {r1, r2, r3, r4, r5, r6, ip, lr}
+
+	add	r2, r0, #0x200
+	adr	r0, __stubs_start		@ copy stubs to 0x200
+	adr	r1, __stubs_end
+1:	ldr	r3, [r0], #4
+	str	r3, [r2], #4
+	cmp	r0, r1
+	blt	1b
+	LOADREGS(fd, sp!, {r4 - r6, pc})
 
-		.data
+	.data
 
 /*
  * Do not reorder these, and do not insert extra data between...
  */
 
-__temp_irq:	.word	0				@ saved lr_irq
-		.word	0				@ saved spsr_irq
-		.word	-1				@ old_r0
-__temp_und:	.word	0				@ Saved lr_und
-		.word	0				@ Saved spsr_und
-		.word	-1				@ old_r0
-__temp_abt:	.word	0				@ Saved lr_abt
-		.word	0				@ Saved spsr_abt
-		.word	-1				@ old_r0
+__temp_irq:
+	.word	0				@ saved lr_irq
+	.word	0				@ saved spsr_irq
+	.word	-1				@ old_r0
+__temp_und:
+	.word	0				@ Saved lr_und
+	.word	0				@ Saved spsr_und
+	.word	-1				@ old_r0
+__temp_abt:
+	.word	0				@ Saved lr_abt
+	.word	0				@ Saved spsr_abt
+	.word	-1				@ old_r0
 
-		.globl	cr_alignment
-		.globl	cr_no_alignment
+	.globl	cr_alignment
+	.globl	cr_no_alignment
 cr_alignment:
-		.space	4
+	.space	4
 cr_no_alignment:
-		.space	4
+	.space	4
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/entry-common.S linux-2.6.11-rc3/arch/arm/kernel/entry-common.S
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/entry-common.S	2005-01-22 02:46:46.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/entry-common.S	2005-02-03 02:54:39.000000000 +0100
@@ -137,7 +137,7 @@ ENTRY(vector_swi)
 	tst	ip, #_TIF_SYSCALL_TRACE		@ are we tracing syscalls?
 	bne	__sys_trace
 
-	adrsvc	al, lr, ret_fast_syscall	@ return address
+	adr	lr, ret_fast_syscall		@ return address
 	cmp	scno, #NR_syscalls		@ check upper syscall limit
 	ldrcc	pc, [tbl, scno, lsl #2]		@ call sys_* routine
 
@@ -157,7 +157,7 @@ __sys_trace:
 	mov	r0, #0				@ trace entry [IP = 0]
 	bl	syscall_trace
 
-	adrsvc	al, lr, __sys_trace_return	@ return address
+	adr	lr, __sys_trace_return		@ return address
 	add	r1, sp, #S_R0 + S_OFF		@ pointer to regs
 	cmp	scno, #NR_syscalls		@ check upper syscall limit
 	ldmccia	r1, {r0 - r3}			@ have to reload r0 - r3
@@ -212,7 +212,8 @@ sys_execve_wrapper:
 		b	sys_execve
 
 sys_clone_wapper:
-		add	r2, sp, #S_OFF
+		add	ip, sp, #S_OFF
+		str	ip, [sp, #4]
 		b	sys_clone
 
 sys_sigsuspend_wrapper:
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/entry-header.S linux-2.6.11-rc3/arch/arm/kernel/entry-header.S
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/entry-header.S	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/entry-header.S	2005-02-03 02:55:50.000000000 +0100
@@ -141,13 +141,6 @@
 	mov	\rd, \rd, lsl #13
 	.endm
 
-/*
- * Like adr, but force SVC mode (if required)
- */
-	.macro	adrsvc, cond, reg, label
-	adr\cond	\reg, \label
-	.endm
-
 	.macro	alignment_trap, rbase, rtemp, sym
 #ifdef CONFIG_ALIGNMENT_TRAP
 #define OFF_CR_ALIGNMENT(x)	cr_alignment - x
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/process.c linux-2.6.11-rc3/arch/arm/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/process.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/process.c	2005-02-03 02:56:48.000000000 +0100
@@ -352,6 +352,9 @@ copy_thread(int nr, unsigned long clone_
 	thread->cpu_context.sp = (unsigned long)childregs;
 	thread->cpu_context.pc = (unsigned long)ret_from_fork;
 
+	if (clone_flags & CLONE_SETTLS)
+		thread->tp_value = regs->ARM_r3;
+
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/ptrace.c linux-2.6.11-rc3/arch/arm/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/ptrace.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/ptrace.c	2005-02-03 02:55:07.000000000 +0100
@@ -719,6 +719,11 @@ static int do_ptrace(int request, struct
 			ret = ptrace_setfpregs(child, (void __user *)data);
 			break;
 
+		case PTRACE_GET_THREAD_AREA:
+			ret = put_user(child->thread_info->tp_value,
+				       (unsigned long __user *) data);
+			break;
+
 		default:
 			ret = ptrace_request(child, request, addr, data);
 			break;
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/sys_arm.c linux-2.6.11-rc3/arch/arm/kernel/sys_arm.c
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/sys_arm.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/sys_arm.c	2005-02-03 02:55:15.000000000 +0100
@@ -241,18 +241,14 @@ asmlinkage int sys_fork(struct pt_regs *
 /* Clone a task - this clones the calling program thread.
  * This is called indirectly via a small wrapper
  */
-asmlinkage int sys_clone(unsigned long clone_flags, unsigned long newsp, struct pt_regs *regs)
+asmlinkage int sys_clone(unsigned long clone_flags, unsigned long newsp,
+			 int *parent_tidptr, int tls_val, int *child_tidptr,
+			 struct pt_regs *regs)
 {
-	/*
-	 * We don't support SETTID / CLEARTID
-	 */
-	if (clone_flags & (CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID))
-		return -EINVAL;
-
 	if (!newsp)
 		newsp = regs->ARM_sp;
 
-	return do_fork(clone_flags, newsp, regs, 0, NULL, NULL);
+	return do_fork(clone_flags, newsp, regs, 0, parent_tidptr, child_tidptr);
 }
 
 asmlinkage int sys_vfork(struct pt_regs *regs)
diff -purN linux-2.6.11-rc2-bk10/arch/arm/kernel/traps.c linux-2.6.11-rc3/arch/arm/kernel/traps.c
--- linux-2.6.11-rc2-bk10/arch/arm/kernel/traps.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/kernel/traps.c	2005-02-03 02:55:50.000000000 +0100
@@ -393,6 +393,7 @@ do_cache_op(unsigned long start, unsigne
 #define NR(x) ((__ARM_NR_##x) - __ARM_NR_BASE)
 asmlinkage int arm_syscall(int no, struct pt_regs *regs)
 {
+	struct thread_info *thread = current_thread_info();
 	siginfo_t info;
 
 	if ((no >> 16) != 0x9f)
@@ -445,6 +446,17 @@ asmlinkage int arm_syscall(int no, struc
 		regs->ARM_cpsr |= MODE32_BIT;
 		return regs->ARM_r0;
 
+	case NR(set_tls):
+		thread->tp_value = regs->ARM_r0;
+		/*
+		 * Our user accessible TLS ptr is located at 0xffff0ffc.
+		 * On SMP read access to this address must raise a fault
+		 * and be emulated from the data abort handler.
+		 * m
+		 */
+		*((unsigned long *)0xffff0ffc) = thread->tp_value;
+		return 0;
+
 	default:
 		/* Calls 9f00xx..9f07ff are defined to return -ENOSYS
 		   if not implemented, rather than raising SIGILL.  This
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iop321-pci.c linux-2.6.11-rc3/arch/arm/mach-iop3xx/iop321-pci.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iop321-pci.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-iop3xx/iop321-pci.c	2005-02-03 02:56:33.000000000 +0100
@@ -198,22 +198,23 @@ struct pci_bus *iop321_scan_bus(int nr, 
 void iop321_init(void)
 {
 	DBG("PCI:  Intel 80321 PCI init code.\n");
-	DBG("\tATU: IOP321_ATUCMD=0x%04x\n", *IOP321_ATUCMD);
-	DBG("\tATU: IOP321_OMWTVR0=0x%04x, IOP321_OIOWTVR=0x%04x\n",
+	DBG("ATU: IOP321_ATUCMD=0x%04x\n", *IOP321_ATUCMD);
+	DBG("ATU: IOP321_OMWTVR0=0x%04x, IOP321_OIOWTVR=0x%04x\n",
 			*IOP321_OMWTVR0,
 			*IOP321_OIOWTVR);
-	DBG("\tATU: IOP321_ATUCR=0x%08x\n", *IOP321_ATUCR);
-	DBG("\tATU: IOP321_IABAR0=0x%08x IOP321_IALR0=0x%08x IOP321_IATVR0=%08x\n", *IOP321_IABAR0, *IOP321_IALR0, *IOP321_IATVR0);
-	DBG("\tATU: IOP321_ERBAR=0x%08x IOP321_ERLR=0x%08x IOP321_ERTVR=%08x\n", *IOP321_ERBAR, *IOP321_ERLR, *IOP321_ERTVR);
-	DBG("\tATU: IOP321_IABAR2=0x%08x IOP321_IALR2=0x%08x IOP321_IATVR2=%08x\n", *IOP321_IABAR2, *IOP321_IALR2, *IOP321_IATVR2);
-	DBG("\tATU: IOP321_IABAR3=0x%08x IOP321_IALR3=0x%08x IOP321_IATVR3=%08x\n", *IOP321_IABAR3, *IOP321_IALR3, *IOP321_IATVR3);
+	DBG("ATU: IOP321_ATUCR=0x%08x\n", *IOP321_ATUCR);
+	DBG("ATU: IOP321_IABAR0=0x%08x IOP321_IALR0=0x%08x IOP321_IATVR0=%08x\n",
+			*IOP321_IABAR0, *IOP321_IALR0, *IOP321_IATVR0);
+	DBG("ATU: IOP321_OMWTVR0=0x%08x\n", *IOP321_OMWTVR0);
+	DBG("ATU: IOP321_IABAR1=0x%08x IOP321_IALR1=0x%08x\n",
+			*IOP321_IABAR1, *IOP321_IALR1);
+	DBG("ATU: IOP321_ERBAR=0x%08x IOP321_ERLR=0x%08x IOP321_ERTVR=%08x\n",
+			*IOP321_ERBAR, *IOP321_ERLR, *IOP321_ERTVR);
+	DBG("ATU: IOP321_IABAR2=0x%08x IOP321_IALR2=0x%08x IOP321_IATVR2=%08x\n",
+			*IOP321_IABAR2, *IOP321_IALR2, *IOP321_IATVR2);
+	DBG("ATU: IOP321_IABAR3=0x%08x IOP321_IALR3=0x%08x IOP321_IATVR3=%08x\n",
+			*IOP321_IABAR3, *IOP321_IALR3, *IOP321_IATVR3);
 
-#if 0
-	hook_fault_code(4, iop321_pci_abort, SIGBUS, "external abort on linefetch");
-	hook_fault_code(6, iop321_pci_abort, SIGBUS, "external abort on linefetch");
-	hook_fault_code(8, iop321_pci_abort, SIGBUS, "external abort on non-linefetch");
-	hook_fault_code(10, iop321_pci_abort, SIGBUS, "external abort on non-linefetch");
-#endif
 	hook_fault_code(16+6, iop321_pci_abort, SIGBUS, "imprecise external abort");
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq31244-pci.c linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq31244-pci.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq31244-pci.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq31244-pci.c	2005-02-03 02:56:49.000000000 +0100
@@ -78,13 +78,13 @@ static int iq31244_setup(int nr, struct 
 
 	memset(res, 0, sizeof(struct resource) * 2);
 
-	res[0].start = IOP321_PCI_LOWER_IO_BA + IOP321_PCI_IO_OFFSET;
-	res[0].end   = IOP321_PCI_UPPER_IO_BA + IOP321_PCI_IO_OFFSET;
+	res[0].start = IOP321_PCI_LOWER_IO_VA;
+	res[0].end   = IOP321_PCI_UPPER_IO_VA;
 	res[0].name  = "IQ31244 PCI I/O Space";
 	res[0].flags = IORESOURCE_IO;
 
-	res[1].start = IOP321_PCI_LOWER_MEM_BA + IOP321_PCI_MEM_OFFSET;
-	res[1].end   = IOP321_PCI_UPPER_MEM_BA + IOP321_PCI_MEM_OFFSET;
+	res[1].start = IOP321_PCI_LOWER_MEM_PA;
+	res[1].end   = IOP321_PCI_UPPER_MEM_PA;
 	res[1].name  = "IQ31244 PCI Memory Space";
 	res[1].flags = IORESOURCE_MEM;
 
@@ -98,9 +98,6 @@ static int iq31244_setup(int nr, struct 
 	sys->resource[1] = &res[1];
 	sys->resource[2] = NULL;
 
-	iop3xx_pcibios_min_io = IOP321_PCI_LOWER_IO_VA;
-	iop3xx_pcibios_min_mem = IOP321_PCI_LOWER_MEM_VA;
-
 	return 1;
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq80321-pci.c linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq80321-pci.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq80321-pci.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq80321-pci.c	2005-02-03 02:56:53.000000000 +0100
@@ -72,13 +72,13 @@ static int iq80321_setup(int nr, struct 
 
 	memset(res, 0, sizeof(struct resource) * 2);
 
-	res[0].start = IOP321_PCI_LOWER_IO_BA + IOP321_PCI_IO_OFFSET;
-	res[0].end   = IOP321_PCI_UPPER_IO_BA + IOP321_PCI_IO_OFFSET;
+	res[0].start = IOP321_PCI_LOWER_IO_VA;
+	res[0].end   = IOP321_PCI_UPPER_IO_VA;
 	res[0].name  = "IQ80321 PCI I/O Space";
 	res[0].flags = IORESOURCE_IO;
 
-	res[1].start = IOP321_PCI_LOWER_MEM_BA + IOP321_PCI_MEM_OFFSET;
-	res[1].end   = IOP321_PCI_UPPER_MEM_BA + IOP321_PCI_MEM_OFFSET;
+	res[1].start = IOP321_PCI_LOWER_MEM_PA;
+	res[1].end   = IOP321_PCI_UPPER_MEM_PA;
 	res[1].name  = "IQ80321 PCI Memory Space";
 	res[1].flags = IORESOURCE_MEM;
 
@@ -92,9 +92,6 @@ static int iq80321_setup(int nr, struct 
 	sys->resource[1] = &res[1];
 	sys->resource[2] = NULL;
 
-	iop3xx_pcibios_min_io = IOP321_PCI_LOWER_IO_VA;
-	iop3xx_pcibios_min_mem = IOP321_PCI_LOWER_MEM_VA;
-
 	return 1;
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq80331-pci.c linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq80331-pci.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq80331-pci.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq80331-pci.c	2005-02-03 02:57:04.000000000 +0100
@@ -68,13 +68,13 @@ static int iq80331_setup(int nr, struct 
 
 	memset(res, 0, sizeof(struct resource) * 2);
 
-	res[0].start = IOP331_PCI_LOWER_IO_BA + IOP331_PCI_IO_OFFSET;
-	res[0].end   = IOP331_PCI_UPPER_IO_BA + IOP331_PCI_IO_OFFSET;
+	res[0].start = IOP331_PCI_LOWER_IO_VA;
+	res[0].end   = IOP331_PCI_UPPER_IO_VA;
 	res[0].name  = "IQ80331 PCI I/O Space";
 	res[0].flags = IORESOURCE_IO;
 
-	res[1].start = IOP331_PCI_LOWER_MEM_BA + IOP331_PCI_MEM_OFFSET;
-	res[1].end   = IOP331_PCI_UPPER_MEM_BA + IOP331_PCI_MEM_OFFSET;
+	res[1].start = IOP331_PCI_LOWER_MEM_PA;
+	res[1].end   = IOP331_PCI_UPPER_MEM_PA;
 	res[1].name  = "IQ80331 PCI Memory Space";
 	res[1].flags = IORESOURCE_MEM;
 
@@ -88,9 +88,6 @@ static int iq80331_setup(int nr, struct 
 	sys->resource[1] = &res[1];
 	sys->resource[2] = NULL;
 
-	iop3xx_pcibios_min_io = IOP331_PCI_LOWER_IO_VA;
-	iop3xx_pcibios_min_mem = IOP331_PCI_LOWER_MEM_VA;
-
 	return 1;
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq80332-pci.c linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq80332-pci.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-iop3xx/iq80332-pci.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-iop3xx/iq80332-pci.c	2005-02-03 02:55:36.000000000 +0100
@@ -74,13 +74,13 @@ static int iq80332_setup(int nr, struct 
 
 	memset(res, 0, sizeof(struct resource) * 2);
 
-	res[0].start = IOP331_PCI_LOWER_IO_BA + IOP331_PCI_IO_OFFSET;
-	res[0].end   = IOP331_PCI_UPPER_IO_BA + IOP331_PCI_IO_OFFSET;
+	res[0].start = IOP331_PCI_LOWER_IO_VA;
+	res[0].end   = IOP331_PCI_UPPER_IO_VA;
 	res[0].name  = "IQ80332 PCI I/O Space";
 	res[0].flags = IORESOURCE_IO;
 
-	res[1].start = IOP331_PCI_LOWER_MEM_BA + IOP331_PCI_MEM_OFFSET;
-	res[1].end   = IOP331_PCI_UPPER_MEM_BA + IOP331_PCI_MEM_OFFSET;
+	res[1].start = IOP331_PCI_LOWER_MEM_PA;
+	res[1].end   = IOP331_PCI_UPPER_MEM_PA;
 	res[1].name  = "IQ80332 PCI Memory Space";
 	res[1].flags = IORESOURCE_MEM;
 
@@ -94,9 +94,6 @@ static int iq80332_setup(int nr, struct 
 	sys->resource[1] = &res[1];
 	sys->resource[2] = NULL;
 
-	iop3xx_pcibios_min_io = IOP331_PCI_LOWER_IO_VA;
-	iop3xx_pcibios_min_mem = IOP331_PCI_LOWER_MEM_VA;
-
 	return 1;
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/Kconfig linux-2.6.11-rc3/arch/arm/mach-ixp4xx/Kconfig
--- linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/Kconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-ixp4xx/Kconfig	2005-02-03 02:55:15.000000000 +0100
@@ -77,6 +77,24 @@ config CPU_IXP46X
 	depends on MACH_IXDP465
 	default y
 
+config MACH_GTWX5715
+	bool "Gemtek WX5715 (Linksys WRV54G)"
+	depends on ARCH_IXP4XX
+	help
+		This board is currently inside the Linksys WRV54G Gateways.
+
+		IXP425 - 266mhz
+		32mb SDRAM
+		8mb Flash
+		miniPCI slot 0 does not have a card connector soldered to the board
+		miniPCI slot 1 has an ISL3880 802.11g card (Prism54)
+		npe0 is connected to a Kendin KS8995M Switch (4 ports)
+		npe1 is the "wan" port
+		"Console" UART is available on J11 as console
+		"High Speed" UART is n/c (as far as I can tell)
+		20 Pin ARM/Xscale JTAG interface on J2
+
+
 comment "IXP4xx Options"
 
 config IXP4XX_INDIRECT_PCI
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/Makefile linux-2.6.11-rc3/arch/arm/mach-ixp4xx/Makefile
--- linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/Makefile	2005-01-22 02:47:16.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-ixp4xx/Makefile	2005-02-03 02:55:14.000000000 +0100
@@ -8,4 +8,5 @@ obj-$(CONFIG_ARCH_IXDP4XX)	+= ixdp425-pc
 obj-$(CONFIG_MACH_IXDPG425)	+= ixdpg425-pci.o coyote-setup.o
 obj-$(CONFIG_ARCH_ADI_COYOTE)	+= coyote-pci.o coyote-setup.o
 obj-$(CONFIG_ARCH_PRPMC1100)	+= prpmc1100-pci.o prpmc1100-setup.o
+obj-$(CONFIG_MACH_GTWX5715)	+= gtwx5715-pci.o gtwx5715-setup.o
 
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/gtwx5715-pci.c linux-2.6.11-rc3/arch/arm/mach-ixp4xx/gtwx5715-pci.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/gtwx5715-pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-ixp4xx/gtwx5715-pci.c	2005-02-03 02:55:52.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+ * arch/arm/mach-ixp4xx/gtwx5715-pci.c
+ *
+ * Gemtek GTWX5715 (Linksys WRV54G) board setup
+ *
+ * Copyright (C) 2004 George T. Joseph
+ * Derived from Coyote
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/arch/gtwx5715.h>
+#include <asm/mach/pci.h>
+
+extern void ixp4xx_pci_preinit(void);
+extern int ixp4xx_setup(int nr, struct pci_sys_data *sys);
+extern struct pci_bus *ixp4xx_scan_bus(int nr, struct pci_sys_data *sys);
+
+        /*
+        * The exact GPIO pins and IRQs are defined in arch-ixp4xx/gtwx5715.h
+        * Slot 0 isn't actually populated with a card connector but
+        * we initialize it anyway in case a future version has the
+        * slot populated or someone with good soldering skills has
+        * some free time.
+        */
+
+
+static void gtwx5715_init_gpio(u8 pin, u32 style)
+{
+	gpio_line_config(pin, style | IXP4XX_GPIO_ACTIVE_LOW);
+
+	if (style & IXP4XX_GPIO_IN) gpio_line_isr_clear(pin);
+}
+
+void __init gtwx5715_pci_preinit(void)
+{
+	gtwx5715_init_gpio(GTWX5715_PCI_SLOT0_INTA_GPIO,	IXP4XX_GPIO_IN);
+	gtwx5715_init_gpio(GTWX5715_PCI_SLOT1_INTA_GPIO,	IXP4XX_GPIO_IN);
+
+	ixp4xx_pci_preinit();
+}
+
+
+static int __init gtwx5715_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int rc;
+	static int gtwx5715_irqmap
+			[GTWX5715_PCI_SLOT_COUNT]
+			[GTWX5715_PCI_INT_PIN_COUNT] = {
+	{GTWX5715_PCI_SLOT0_INTA_IRQ, GTWX5715_PCI_SLOT0_INTB_IRQ},
+	{GTWX5715_PCI_SLOT1_INTA_IRQ, GTWX5715_PCI_SLOT1_INTB_IRQ},
+};
+
+	if (slot >= GTWX5715_PCI_SLOT_COUNT ||
+			pin >= GTWX5715_PCI_INT_PIN_COUNT) rc = -1;
+	else
+		rc = gtwx5715_irqmap[slot][pin-1];
+
+	printk("%s: Mapped slot %d pin %d to IRQ %d\n", __FUNCTION__,slot, pin, rc);
+	return(rc);
+}
+
+struct hw_pci gtwx5715_pci __initdata = {
+	.nr_controllers = 1,
+	.preinit =        gtwx5715_pci_preinit,
+	.swizzle =        pci_std_swizzle,
+	.setup =          ixp4xx_setup,
+	.scan =           ixp4xx_scan_bus,
+	.map_irq =        gtwx5715_map_irq,
+};
+
+int __init gtwx5715_pci_init(void)
+{
+	if (machine_is_gtwx5715())
+	{
+		pci_common_init(&gtwx5715_pci);
+	}
+
+	return 0;
+}
+
+subsys_initcall(gtwx5715_pci_init);
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/gtwx5715-setup.c linux-2.6.11-rc3/arch/arm/mach-ixp4xx/gtwx5715-setup.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-ixp4xx/gtwx5715-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-ixp4xx/gtwx5715-setup.c	2005-02-03 02:57:16.000000000 +0100
@@ -0,0 +1,153 @@
+/*
+ * arch/arm/mach-ixp4xx/gtwx5715-setup.c
+ *
+ * Gemtek GTWX5715 (Linksys WRV54G) board settup
+ *
+ * Copyright (C) 2004 George T. Joseph
+ * Derived from Coyote
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_8250.h>
+
+#include <asm/types.h>
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/arch/gtwx5715.h>
+
+/*
+ * Xscale UART registers are 32 bits wide with only the least
+ * significant 8 bits having any meaning.  From a configuration
+ * perspective, this means 2 things...
+ *
+ *   Setting .regshift = 2 so that the standard 16550 registers
+ *   line up on every 4th byte.
+ *
+ *   Shifting the register start virtual address +3 bytes when
+ *   compiled big-endian.  Since register writes are done on a
+ *   single byte basis, if the shift isn't done the driver will
+ *   write the value into the most significant byte of the register,
+ *   which is ignored, instead of the least significant.
+ */
+
+#ifdef	__ARMEB__
+#define	REG_OFFSET	3
+#else
+#define	REG_OFFSET	0
+#endif
+
+/*
+ * Only the second or "console" uart is connected on the gtwx5715.
+ */
+
+static struct resource gtwx5715_uart_resources[] = {
+	{
+		.start	= IXP4XX_UART2_BASE_PHYS,
+		.end	= IXP4XX_UART2_BASE_PHYS + 0x0fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_IXP4XX_UART2,
+		.end	= IRQ_IXP4XX_UART2,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{ },
+};
+
+
+static struct plat_serial8250_port gtwx5715_uart_platform_data[] = {
+	{
+	.mapbase	= IXP4XX_UART2_BASE_PHYS,
+	.membase	= (char *)IXP4XX_UART2_BASE_VIRT + REG_OFFSET,
+	.irq		= IRQ_IXP4XX_UART2,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.iotype		= UPIO_MEM,
+	.regshift	= 2,
+	.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{ },
+};
+
+static struct platform_device gtwx5715_uart_device = {
+	.name		= "serial8250",
+	.id		= 0,
+	.dev			= {
+		.platform_data	= gtwx5715_uart_platform_data,
+	},
+	.num_resources	= 2,
+	.resource	= gtwx5715_uart_resources,
+};
+
+
+void __init gtwx5715_map_io(void)
+{
+	ixp4xx_map_io();
+}
+
+static struct flash_platform_data gtwx5715_flash_data = {
+	.map_name	= "cfi_probe",
+	.width		= 2,
+};
+
+static struct resource gtwx5715_flash_resource = {
+	.start		= GTWX5715_FLASH_BASE,
+	.end		= GTWX5715_FLASH_BASE + GTWX5715_FLASH_SIZE,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device gtwx5715_flash = {
+	.name		= "IXP4XX-Flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &gtwx5715_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &gtwx5715_flash_resource,
+};
+
+static struct platform_device *gtwx5715_devices[] __initdata = {
+	&gtwx5715_uart_device,
+	&gtwx5715_flash,
+};
+
+static void __init gtwx5715_init(void)
+{
+	platform_add_devices(gtwx5715_devices, ARRAY_SIZE(gtwx5715_devices));
+}
+
+
+MACHINE_START(GTWX5715, "Gemtek GTWX5715 (Linksys WRV54G)")
+        MAINTAINER("George Joseph")
+        BOOT_MEM(PHYS_OFFSET, IXP4XX_UART2_BASE_PHYS,
+                IXP4XX_UART2_BASE_VIRT)
+        MAPIO(gtwx5715_map_io)
+        INITIRQ(ixp4xx_init_irq)
+		  .timer		= &ixp4xx_timer,
+        BOOT_PARAMS(0x0100)
+        INIT_MACHINE(gtwx5715_init)
+MACHINE_END
+
+
diff -purN linux-2.6.11-rc2-bk10/arch/arm/mach-pxa/corgi.c linux-2.6.11-rc3/arch/arm/mach-pxa/corgi.c
--- linux-2.6.11-rc2-bk10/arch/arm/mach-pxa/corgi.c	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm/mach-pxa/corgi.c	2005-02-03 02:54:39.000000000 +0100
@@ -77,8 +77,6 @@ static struct platform_device corgiscoop
  * also use scoop functions and this makes the power up/down order
  * work correctly.
  */
-extern void corgi_ssp_lcdtg_send (u8 adrs, u8 data);
-
 static struct platform_device corgissp_device = {
 	.name		= "corgi-ssp",
 	.dev		= {
@@ -118,6 +116,18 @@ static struct platform_device corgifb_de
 
 
 /*
+ * Corgi Backlight Device
+ */
+static struct platform_device corgibl_device = {
+	.name		= "corgi-bl",
+	.dev		= {
+ 		.parent = &corgifb_device.dev,
+	},
+	.id		= -1,
+};
+
+
+/*
  * MMC/SD Device
  *
  * The card detect interrupt isn't debounced so we delay it by HZ/4
@@ -150,6 +160,10 @@ static int corgi_mci_init(struct device 
 	pxa_gpio_mode(CORGI_GPIO_nSD_DETECT | GPIO_IN);
 	pxa_gpio_mode(CORGI_GPIO_SD_PWR | GPIO_OUT);
 
+	init_timer(&mmc_detect.detect_timer);
+	mmc_detect.detect_timer.function = mmc_detect_callback;
+	mmc_detect.detect_timer.data = (unsigned long) &mmc_detect;
+
 	err = request_irq(CORGI_IRQ_GPIO_nSD_DETECT, corgi_mmc_detect_int, SA_INTERRUPT,
 			     "MMC card detect", data);
 	if (err) {
@@ -157,10 +171,6 @@ static int corgi_mci_init(struct device 
 		return -1;
 	}
 
-	init_timer(&mmc_detect.detect_timer);
-	mmc_detect.detect_timer.function = mmc_detect_callback;
-	mmc_detect.detect_timer.data = (unsigned long) &mmc_detect;
-
 	set_irq_type(CORGI_IRQ_GPIO_nSD_DETECT, IRQT_BOTHEDGE);
 
 	return 0;
@@ -218,6 +228,7 @@ static struct platform_device *devices[]
 	&corgiscoop_device,
 	&corgissp_device,
 	&corgifb_device,
+	&corgibl_device,
 };
 
 static struct sharpsl_flash_param_info sharpsl_flash_param;
diff -purN linux-2.6.11-rc2-bk10/arch/arm26/kernel/asm-offsets.c linux-2.6.11-rc3/arch/arm26/kernel/asm-offsets.c
--- linux-2.6.11-rc2-bk10/arch/arm26/kernel/asm-offsets.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm26/kernel/asm-offsets.c	2005-02-03 02:55:15.000000000 +0100
@@ -42,7 +42,6 @@
 
 int main(void)
 {
-  DEFINE(TSK_USED_MATH,		offsetof(struct task_struct, used_math));
   DEFINE(TSK_ACTIVE_MM,		offsetof(struct task_struct, active_mm));
   BLANK();
   DEFINE(VMA_VM_MM,		offsetof(struct vm_area_struct, vm_mm));
diff -purN linux-2.6.11-rc2-bk10/arch/arm26/kernel/process.c linux-2.6.11-rc3/arch/arm26/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/arm26/kernel/process.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm26/kernel/process.c	2005-02-03 02:56:48.000000000 +0100
@@ -271,7 +271,7 @@ void flush_thread(void)
 	memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
 	memset(&thread->fpstate, 0, sizeof(union fp_state));
 
-	current->used_math = 0;
+	clear_used_math();
 }
 
 void release_thread(struct task_struct *dead_task)
@@ -305,7 +305,7 @@ copy_thread(int nr, unsigned long clone_
 int dump_fpu (struct pt_regs *regs, struct user_fp *fp)
 {
 	struct thread_info *thread = current_thread_info();
-	int used_math = current->used_math;
+	int used_math = !!used_math();
 
 	if (used_math)
 		memcpy(fp, &thread->fpstate.soft, sizeof (*fp));
diff -purN linux-2.6.11-rc2-bk10/arch/arm26/kernel/ptrace.c linux-2.6.11-rc3/arch/arm26/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/arm26/kernel/ptrace.c	2005-01-22 02:48:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/arm26/kernel/ptrace.c	2005-02-03 02:55:52.000000000 +0100
@@ -540,7 +540,7 @@ static int ptrace_getfpregs(struct task_
  */
 static int ptrace_setfpregs(struct task_struct *tsk, void *ufp)
 {
-	tsk->used_math = 1;
+	set_stopped_child_used_math(tsk);
 	return copy_from_user(&tsk->thread_info->fpstate, ufp,
 			      sizeof(struct user_fp)) ? -EFAULT : 0;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/apic.c linux-2.6.11-rc3/arch/i386/kernel/apic.c
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/apic.c	2005-02-03 10:03:08.723543399 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/apic.c	2005-02-03 02:57:04.000000000 +0100
@@ -518,8 +518,7 @@ void __init setup_local_APIC (void)
  * disable it down before re-entering the BIOS on shutdown.
  * Otherwise the BIOS may get confused and not power-off.
  */
-void
-lapic_shutdown()
+void lapic_shutdown(void)
 {
 	if (!cpu_has_apic || !enabled_via_apicbase)
 		return;
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/cpu/common.c linux-2.6.11-rc3/arch/i386/kernel/cpu/common.c
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/cpu/common.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/cpu/common.c	2005-02-03 02:54:59.000000000 +0100
@@ -629,6 +629,6 @@ void __init cpu_init (void)
 	 * Force FPU initialization:
 	 */
 	current_thread_info()->status = 0;
-	current->used_math = 0;
+	clear_used_math();
 	mxcsr_feature_mask_init();
 }
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/entry.S linux-2.6.11-rc3/arch/i386/kernel/entry.S
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/entry.S	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/entry.S	2005-02-03 02:55:23.000000000 +0100
@@ -176,6 +176,7 @@ ENTRY(resume_userspace)
 
 #ifdef CONFIG_PREEMPT
 ENTRY(resume_kernel)
+	cli
 	cmpl $0,TI_preempt_count(%ebp)	# non-zero preempt_count ?
 	jnz restore_all
 need_resched:
@@ -184,10 +185,7 @@ need_resched:
 	jz restore_all
 	testl $IF_MASK,EFLAGS(%esp)     # interrupts off (exception path) ?
 	jz restore_all
-	sti
-	call preempt_schedule
-	cli
-	movl $0,TI_preempt_count(%ebp)
+	call preempt_schedule_irq
 	jmp need_resched
 #endif
 
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/i387.c linux-2.6.11-rc3/arch/i386/kernel/i387.c
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/i387.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/i387.c	2005-02-03 02:57:04.000000000 +0100
@@ -60,7 +60,8 @@ void init_fpu(struct task_struct *tsk)
 		tsk->thread.i387.fsave.twd = 0xffffffffu;
 		tsk->thread.i387.fsave.fos = 0xffff0000u;
 	}
-	tsk->used_math = 1;
+	/* only the device not available exception or ptrace can call init_fpu */
+	set_stopped_child_used_math(tsk);
 }
 
 /*
@@ -331,13 +332,13 @@ static int save_i387_fxsave( struct _fps
 
 int save_i387( struct _fpstate __user *buf )
 {
-	if ( !current->used_math )
+	if ( !used_math() )
 		return 0;
 
 	/* This will cause a "finit" to be triggered by the next
 	 * attempted FPU operation by the 'current' process.
 	 */
-	current->used_math = 0;
+	clear_used_math();
 
 	if ( HAVE_HWFP ) {
 		if ( cpu_has_fxsr ) {
@@ -383,7 +384,7 @@ int restore_i387( struct _fpstate __user
 	} else {
 		err = restore_i387_soft( &current->thread.i387.soft, buf );
 	}
-	current->used_math = 1;
+	set_used_math();
 	return err;
 }
 
@@ -507,7 +508,7 @@ int dump_fpu( struct pt_regs *regs, stru
 	int fpvalid;
 	struct task_struct *tsk = current;
 
-	fpvalid = tsk->used_math;
+	fpvalid = !!used_math();
 	if ( fpvalid ) {
 		unlazy_fpu( tsk );
 		if ( cpu_has_fxsr ) {
@@ -522,7 +523,7 @@ int dump_fpu( struct pt_regs *regs, stru
 
 int dump_task_fpu(struct task_struct *tsk, struct user_i387_struct *fpu)
 {
-	int fpvalid = tsk->used_math;
+	int fpvalid = !!tsk_used_math(tsk);
 
 	if (fpvalid) {
 		if (tsk == current)
@@ -537,7 +538,7 @@ int dump_task_fpu(struct task_struct *ts
 
 int dump_task_extended_fpu(struct task_struct *tsk, struct user_fxsr_struct *fpu)
 {
-	int fpvalid = tsk->used_math && cpu_has_fxsr;
+	int fpvalid = tsk_used_math(tsk) && cpu_has_fxsr;
 
 	if (fpvalid) {
 		if (tsk == current)
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/process.c linux-2.6.11-rc3/arch/i386/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/process.c	2005-01-22 02:46:37.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/process.c	2005-02-03 02:54:35.000000000 +0100
@@ -351,7 +351,7 @@ void flush_thread(void)
 	 * Forget coprocessor state..
 	 */
 	clear_fpu(tsk);
-	tsk->used_math = 0;
+	clear_used_math();
 }
 
 void release_thread(struct task_struct *dead_task)
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/ptrace.c linux-2.6.11-rc3/arch/i386/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/ptrace.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/ptrace.c	2005-02-03 02:55:23.000000000 +0100
@@ -592,7 +592,7 @@ asmlinkage int sys_ptrace(long request, 
 			break;
 		}
 		ret = 0;
-		if (!child->used_math)
+		if (!tsk_used_math(child))
 			init_fpu(child);
 		get_fpregs((struct user_i387_struct __user *)data, child);
 		break;
@@ -604,7 +604,7 @@ asmlinkage int sys_ptrace(long request, 
 			ret = -EIO;
 			break;
 		}
-		child->used_math = 1;
+		set_stopped_child_used_math(child);
 		set_fpregs(child, (struct user_i387_struct __user *)data);
 		ret = 0;
 		break;
@@ -616,7 +616,7 @@ asmlinkage int sys_ptrace(long request, 
 			ret = -EIO;
 			break;
 		}
-		if (!child->used_math)
+		if (!tsk_used_math(child))
 			init_fpu(child);
 		ret = get_fpxregs((struct user_fxsr_struct __user *)data, child);
 		break;
@@ -628,7 +628,7 @@ asmlinkage int sys_ptrace(long request, 
 			ret = -EIO;
 			break;
 		}
-		child->used_math = 1;
+		set_stopped_child_used_math(child);
 		ret = set_fpxregs(child, (struct user_fxsr_struct __user *)data);
 		break;
 	}
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/signal.c linux-2.6.11-rc3/arch/i386/kernel/signal.c
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/signal.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/signal.c	2005-02-03 02:55:50.000000000 +0100
@@ -192,9 +192,9 @@ restore_sigcontext(struct pt_regs *regs,
 			err |= restore_i387(buf);
 		} else {
 			struct task_struct *me = current;
-			if (me->used_math) {
+			if (used_math()) {
 				clear_fpu(me);
-				me->used_math = 0;
+				clear_used_math();
 			}
 		}
 	}
diff -purN linux-2.6.11-rc2-bk10/arch/i386/kernel/traps.c linux-2.6.11-rc3/arch/i386/kernel/traps.c
--- linux-2.6.11-rc2-bk10/arch/i386/kernel/traps.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/kernel/traps.c	2005-02-03 02:55:15.000000000 +0100
@@ -911,7 +911,7 @@ asmlinkage void math_state_restore(struc
 	struct task_struct *tsk = thread->task;
 
 	clts();		/* Allow maths ops (or we recurse) */
-	if (!tsk->used_math)
+	if (!tsk_used_math(tsk))
 		init_fpu(tsk);
 	restore_fpu(tsk);
 	thread->status |= TS_USEDFPU;	/* So we fnsave on switch_to() */
diff -purN linux-2.6.11-rc2-bk10/arch/i386/math-emu/fpu_entry.c linux-2.6.11-rc3/arch/i386/math-emu/fpu_entry.c
--- linux-2.6.11-rc2-bk10/arch/i386/math-emu/fpu_entry.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/math-emu/fpu_entry.c	2005-02-03 02:56:35.000000000 +0100
@@ -155,10 +155,10 @@ asmlinkage void math_emulate(long arg)
   RE_ENTRANT_CHECK_ON;
 #endif /* RE_ENTRANT_CHECKING */
 
-  if (!current->used_math)
+  if (!used_math())
     {
       finit();
-      current->used_math = 1;
+      set_used_math();
     }
 
   SETUP_DATA_AREA(arg);
diff -purN linux-2.6.11-rc2-bk10/arch/i386/oprofile/nmi_int.c linux-2.6.11-rc3/arch/i386/oprofile/nmi_int.c
--- linux-2.6.11-rc2-bk10/arch/i386/oprofile/nmi_int.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/i386/oprofile/nmi_int.c	2005-02-03 02:56:48.000000000 +0100
@@ -304,7 +304,7 @@ static int __init p4_init(char ** cpu_ty
 {
 	__u8 cpu_model = boot_cpu_data.x86_model;
 
-	if (cpu_model > 3)
+	if (cpu_model > 4)
 		return 0;
 
 #ifndef CONFIG_SMP
diff -purN linux-2.6.11-rc2-bk10/arch/ia64/ia32/elfcore32.h linux-2.6.11-rc3/arch/ia64/ia32/elfcore32.h
--- linux-2.6.11-rc2-bk10/arch/ia64/ia32/elfcore32.h	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/ia64/ia32/elfcore32.h	2005-02-03 02:55:52.000000000 +0100
@@ -106,7 +106,7 @@ elf_core_copy_task_fpregs(struct task_st
 	struct ia32_user_i387_struct *fpstate = (void*)fpu;
 	mm_segment_t old_fs;
 
-	if (!tsk->used_math)
+	if (!tsk_used_math(tsk))
 		return 0;
 	
 	old_fs = get_fs();
@@ -124,7 +124,7 @@ elf_core_copy_task_xfpregs(struct task_s
 	struct ia32_user_fxsr_struct *fpxstate = (void*) xfpu;
 	mm_segment_t old_fs;
 
-	if (!tsk->used_math)
+	if (!tsk_used_math(tsk))
 		return 0;
 
 	old_fs = get_fs();
diff -purN linux-2.6.11-rc2-bk10/arch/m32r/kernel/ptrace.c linux-2.6.11-rc3/arch/m32r/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/m32r/kernel/ptrace.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/m32r/kernel/ptrace.c	2005-02-03 02:56:48.000000000 +0100
@@ -130,7 +130,7 @@ static int ptrace_read_user(struct task_
 #ifndef NO_FPU
 		else if (off >= (long)(&dummy->fpu >> 2) &&
 			 off < (long)(&dummy->u_fpvalid >> 2)) {
-			if (!tsk->used_math) {
+			if (!tsk_used_math(tsk)) {
 				if (off == (long)(&dummy->fpu.fpscr >> 2))
 					tmp = FPSCR_INIT;
 				else
@@ -139,7 +139,7 @@ static int ptrace_read_user(struct task_
 				tmp = ((long *)(&tsk->thread.fpu >> 2))
 					[off - (long)&dummy->fpu];
 		} else if (off == (long)(&dummy->u_fpvalid >> 2))
-			tmp = tsk->used_math;
+			tmp = !!tsk_used_math(tsk);
 #endif /* not NO_FPU */
 		else
 			tmp = 0;
@@ -187,12 +187,12 @@ static int ptrace_write_user(struct task
 #ifndef NO_FPU
 		else if (off >= (long)(&dummy->fpu >> 2) &&
 			 off < (long)(&dummy->u_fpvalid >> 2)) {
-			tsk->used_math = 1;
+			set_stopped_child_used_math(tsk);
 			((long *)&tsk->thread.fpu)
 				[off - (long)&dummy->fpu] = data;
 			ret = 0;
 		} else if (off == (long)(&dummy->u_fpvalid >> 2)) {
-			tsk->used_math = data ? 1 : 0;
+			conditional_stopped_child_used_math(data, tsk);
 			ret = 0;
 		}
 #endif /* not NO_FPU */
diff -purN linux-2.6.11-rc2-bk10/arch/m32r/kernel/setup.c linux-2.6.11-rc3/arch/m32r/kernel/setup.c
--- linux-2.6.11-rc2-bk10/arch/m32r/kernel/setup.c	2005-01-22 02:48:12.000000000 +0100
+++ linux-2.6.11-rc3/arch/m32r/kernel/setup.c	2005-02-03 02:55:52.000000000 +0100
@@ -391,7 +391,7 @@ void __init cpu_init (void)
 
 	/* Force FPU initialization */
 	current_thread_info()->status = 0;
-	current->used_math = 0;
+	clear_used_math();
 
 #ifdef CONFIG_MMU
 	/* Set up MMU */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/Kconfig linux-2.6.11-rc3/arch/mips/Kconfig
--- linux-2.6.11-rc2-bk10/arch/mips/Kconfig	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/Kconfig	2005-02-03 02:55:52.000000000 +0100
@@ -29,6 +29,10 @@ menu "Machine selection"
 
 config MACH_JAZZ
 	bool "Support for the Jazz family of machines"
+	select ARC
+	select ARC32
+	select GENERIC_ISA_DMA
+	select I8259
 	select ISA
 	help
 	 This a family of machines based on the MIPS R4030 chipset which was
@@ -69,6 +73,21 @@ config OLIVETTI_M700
 config MACH_VR41XX
 	bool "Support for NEC VR41XX-based machines"
 
+config NEC_CMBVR4133
+	bool "Support for NEC CMB-VR4133"
+	depends on MACH_VR41XX
+	select CPU_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select PCI_VR41XX
+
+config ROCKHOPPER
+	bool "Support for Rockhopper baseboard"
+	depends on NEC_CMBVR4133
+	select I8259
+	select HAVE_STD_PC_SERIAL_PORT
+
 config CASIO_E55
 	bool "Support for CASIO CASSIOPEIA E-10/15/55/65"
 	depends on MACH_VR41XX
@@ -103,6 +122,10 @@ config TANBAC_TB0229
 	  The TANBAC TB0229 (VR4131DIMM) is a MIPS-based platform manufactured by TANBAC.
 	  Please refer to <http://www.tanbac.co.jp/> about VR4131DIMM.
 
+config TANBAC_TB0219
+	bool "Added TANBAC TB0219 Base board support"
+	depends on TANBAC_TB0229
+
 config VICTOR_MPC30X
 	bool "Support for Victor MP-C303/304"
 	select DMA_NONCOHERENT
@@ -145,10 +168,12 @@ config MIPS_COBALT
 	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select I8259
 	select IRQ_CPU
 
 config MACH_DECSTATION
 	bool "Support for DECstations"
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select IRQ_CPU
 	depends on MIPS32 || EXPERIMENTAL
@@ -172,6 +197,7 @@ config MIPS_EV64120
 	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select MIPS_GT64120
 	help
 	  This is an evaluation board based on the Galileo GT-64120
 	  single-chip system controller that contains a MIPS R5000 compatible
@@ -213,6 +239,7 @@ config LASAT
 	bool "Support for LASAT Networks platforms"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select MIPS_GT64120
 	select R5000_CPU_SCACHE
 
 config PICVUE
@@ -253,8 +280,10 @@ config IT8172_REVC
 
 config MIPS_ATLAS
 	bool "Support for MIPS Atlas board"
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select MIPS_GT64120
 	select SWAP_IO_SPACE
 	help
 	  This enables support for the QED R5231-based MIPS Atlas evaluation
@@ -262,9 +291,13 @@ config MIPS_ATLAS
 
 config MIPS_MALTA
 	bool "Support for MIPS Malta board"
+	select BOOT_ELF32
 	select HAVE_STD_PC_SERIAL_PORT
 	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA
 	select HW_HAS_PCI
+	select I8259
+	select MIPS_GT64120
 	select SWAP_IO_SPACE
 	help
 	  This enables support for the VR5000-based MIPS Malta evaluation
@@ -282,6 +315,7 @@ config MOMENCO_OCELOT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
+	select MIPS_GT64120
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
 	help
@@ -316,6 +350,7 @@ config MOMENCO_OCELOT_C
 
 config MOMENCO_OCELOT_3
 	bool "Support for Momentum Ocelot-3 board"
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
@@ -330,6 +365,7 @@ config MOMENCO_OCELOT_3
 
 config MOMENCO_JAGUAR_ATX
 	bool "Support for Momentum Jaguar board"
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
@@ -356,6 +392,7 @@ config PMC_YOSEMITE
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
+	select IRQ_CPU_RM9K
 	select SWAP_IO_SPACE
 	help
 	  Yosemite is an evaluation board for the RM9000x2 processor
@@ -372,6 +409,7 @@ config DDB5074
 	select HAVE_STD_PC_SERIAL_PORT
 	select HW_HAS_PCI
 	select IRQ_CPU
+	select I8259
 	select ISA
 	help
 	  This enables support for the VR5000-based NEC DDB Vrc-5074
@@ -383,6 +421,7 @@ config DDB5476
 	select HAVE_STD_PC_SERIAL_PORT
 	select HW_HAS_PCI
 	select IRQ_CPU
+	select I8259
 	select ISA
 	help
 	  This enables support for the R5432-based NEC DDB Vrc-5476
@@ -396,6 +435,7 @@ config DDB5477
 	bool "Support for NEC DDB Vrc-5477"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select I8259
 	select IRQ_CPU
 	help
 	  This enables support for the R5432-based NEC DDB Vrc-5477,
@@ -428,6 +468,8 @@ config SGI_IP22
 config SGI_IP27
 	bool "Support for SGI IP27 (Origin200/2000)"
 	depends on MIPS64
+	select ARC
+	select ARC64
 	select DMA_IP27
 	select HW_HAS_PCI
 	select PCI_DOMAINS
@@ -494,6 +536,11 @@ config REPLICATE_EXHANDLERS
 config SGI_IP32
 	bool "Support for SGI IP32 (O2) (EXPERIMENTAL)"
 	depends on MIPS64 && EXPERIMENTAL
+	select ARC
+	select ARC32
+	select BOOT_ELF32
+	select OWN_DMA
+	select DMA_IP32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select R5000_CPU_SCACHE
@@ -508,31 +555,31 @@ config SOC_AU1X00
 choice
 	prompt "Au1X00 SOC Type"
 	depends on SOC_AU1X00
-        help
-           Say Y here to enable support for one of three AMD/Alchemy
-           SOCs. For additional documentation see www.amd.com.
+	help
+	  Say Y here to enable support for one of three AMD/Alchemy
+	  SOCs. For additional documentation see www.amd.com.
 
 config SOC_AU1000
-        bool "SOC_AU1000"
+	bool "SOC_AU1000"
 config SOC_AU1100
-        bool "SOC_AU1100"
+	bool "SOC_AU1100"
 config SOC_AU1500
-        bool "SOC_AU1500"
+	bool "SOC_AU1500"
 config SOC_AU1550
-        bool "SOC_AU1550"
+	bool "SOC_AU1550"
 
 endchoice
 
 choice
-        prompt "AMD/Alchemy Au1x00 board support"
-        depends on SOC_AU1X00
+	prompt "AMD/Alchemy Au1x00 board support"
+	depends on SOC_AU1X00
 	help
 	  These are evaluation boards built by AMD/Alchemy to
 	  showcase their Au1X00 Internet Edge Processors. The SOC design
 	  is based on the MIPS32 architecture running at 266/400/500MHz
-          with many integrated peripherals. Further information can be
-          found at their website, <http://www.amd.com/>. Say Y here if you
-          wish to build a kernel for this platform.
+	  with many integrated peripherals. Further information can be
+	  found at their website, <http://www.amd.com/>. Say Y here if you
+	  wish to build a kernel for this platform.
 
 config MIPS_PB1000
 	bool "PB1000 board"
@@ -604,6 +651,7 @@ config MIPS_XXS1500
 config MIPS_MTX1
 	bool "4G Systems MTX-1 board"
 	depends on SOC_AU1500
+	select HW_HAS_PCI
 	select DMA_NONCOHERENT
 
 endchoice
@@ -611,6 +659,7 @@ endchoice
 config SIBYTE_SB1xxx_SOC
 	bool "Support for Broadcom BCM1xxx SOCs (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
+	select BOOT_ELF32
 	select DMA_COHERENT
 	select SWAP_IO_SPACE
 
@@ -721,6 +770,7 @@ choice
 config CPU_SB1_PASS_1
 	bool "1250 Pass1"
 	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
 
 config CPU_SB1_PASS_2_1250
 	bool "1250 An"
@@ -732,12 +782,14 @@ config CPU_SB1_PASS_2_1250
 config CPU_SB1_PASS_2_2
 	bool "1250 Bn"
 	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
 	help
 	  Also called BCM1250 Pass 2.2
 
 config CPU_SB1_PASS_4
 	bool "1250 Cn"
 	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
 	help
 	  Also called BCM1250 Pass 3
 
@@ -749,6 +801,7 @@ config CPU_SB1_PASS_2_112x
 config CPU_SB1_PASS_3
 	bool "112x An"
 	depends on SIBYTE_BCM112X
+	select CPU_HAS_PREFETCH
 
 endchoice
 
@@ -819,9 +872,14 @@ config SIBYTE_TBPROF
 
 config SNI_RM200_PCI
 	bool "Support for SNI RM200 PCI"
+	select ARC
+	select ARC32
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA
 	select HAVE_STD_PC_SERIAL_PORT
 	select HW_HAS_PCI
+	select I8259
 	select ISA
 	help
 	  The SNI RM200 PCI was a MIPS-based platform manufactured by Siemens
@@ -833,6 +891,7 @@ config TOSHIBA_RBTX4927
 	bool "Support for Toshiba TBTX49[23]7 board"
 	depends on MIPS32
 	select DMA_NONCOHERENT
+	select HAS_TXX9_SERIAL
 	select HW_HAS_PCI
 	select I8259
 	select ISA
@@ -955,6 +1014,7 @@ config MIPS_GT64120
 config MIPS_TX3927
 	bool
 	depends on TOSHIBA_JMR3927
+	select HAS_TXX9_SERIAL
 	default y
 
 config PCI_MARVELL
diff -purN linux-2.6.11-rc2-bk10/arch/mips/Makefile linux-2.6.11-rc3/arch/mips/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/Makefile	2005-01-22 02:46:46.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/Makefile	2005-02-03 02:54:39.000000000 +0100
@@ -482,6 +482,12 @@ core-$(CONFIG_MACH_VR41XX)	+= arch/mips/
 cflags-$(CONFIG_MACH_VR41XX)	+= -Iinclude/asm-mips/mach-vr41xx
 
 #
+# NEC VR4133
+#
+core-$(CONFIG_NEC_CMBVR4133)	+= arch/mips/vr41xx/nec-cmbvr4133/
+load-$(CONFIG_NEC_CMBVR4133)	+= 0xffffffff80100000
+
+#
 # ZAO Networks Capcella (VR4131)
 #
 core-$(CONFIG_ZAO_CAPCELLA)	+= arch/mips/vr41xx/zao-capcella/
@@ -673,6 +679,8 @@ libs-$(CONFIG_MIPS64)	+= arch/mips/lib-6
 
 core-y			+= arch/mips/kernel/ arch/mips/mm/ arch/mips/math-emu/
 
+drivers-$(CONFIG_OPROFILE)	+= arch/mips/oprofile/
+
 ifdef CONFIG_LASAT
 rom.bin rom.sw: vmlinux
 	$(call descend,arch/mips/lasat/image,$@)
@@ -744,36 +752,16 @@ define filechk_gen-asm-offset.h
 	 echo "#endif /* _ASM_OFFSET_H */" )
 endef
 
-define filechk_gen-asm-reg.h
-	(set -e; \
-	 echo "#ifndef _ASM_REG_H"; \
-	 echo "#define _ASM_REG_H"; \
-	 echo "/*"; \
-	 echo " * DO NOT MODIFY."; \
-	 echo " *"; \
-	 echo " * This file was generated by arch/$(ARCH)/Makefile"; \
-	 echo " *"; \
-	 echo " */"; \
-	 echo ""; \
-	 sed -ne "/^@@@/s///p"; \
-	 echo "#endif /* _ASM_REG_H */" )
-endef
-
-prepare: include/asm-$(ARCH)/offset.h \
-	 include/asm-$(ARCH)/reg.h
+prepare: include/asm-$(ARCH)/offset.h
 
 arch/$(ARCH)/kernel/offset.s: include/asm include/linux/version.h \
 				   include/config/MARKER
 
 include/asm-$(ARCH)/offset.h: arch/$(ARCH)/kernel/offset.s
 	$(call filechk,gen-asm-offset.h)
-include/asm-$(ARCH)/reg.h: arch/$(ARCH)/kernel/reg.s
-	$(call filechk,gen-asm-reg.h)
 
 CLEAN_FILES += include/asm-$(ARCH)/offset.h.tmp \
 	       include/asm-$(ARCH)/offset.h \
-	       include/asm-$(ARCH)/reg.h.tmp \
-	       include/asm-$(ARCH)/reg.h \
 	       vmlinux.32 \
 	       vmlinux.64 \
 	       vmlinux.ecoff
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/au1xxx_irqmap.c linux-2.6.11-rc3/arch/mips/au1000/common/au1xxx_irqmap.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/au1xxx_irqmap.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/au1xxx_irqmap.c	2005-02-03 02:55:22.000000000 +0100
@@ -25,6 +25,7 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
+#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/irq.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/cputable.c linux-2.6.11-rc3/arch/mips/au1000/common/cputable.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/cputable.c	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/cputable.c	2005-02-03 02:55:07.000000000 +0100
@@ -11,8 +11,6 @@
  *  as published by the Free Software Foundation; either version
  *  2 of the License, or (at your option) any later version.
  */
-
-#include <linux/config.h>
 #include <linux/string.h>
 #include <linux/sched.h>
 #include <linux/threads.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/dbdma.c linux-2.6.11-rc3/arch/mips/au1000/common/dbdma.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/dbdma.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/dbdma.c	2005-02-03 02:55:23.000000000 +0100
@@ -29,7 +29,7 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
-
+#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
@@ -55,7 +55,7 @@
  * functions.  The drivers allocate the data buffers and assign them
  * to the descriptors.
  */
-static spinlock_t au1xxx_dbdma_spin_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(au1xxx_dbdma_spin_lock);
 
 /* I couldn't find a macro that did this......
 */
@@ -370,7 +370,7 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 	 * and if we try that first we are likely to not waste larger
 	 * slabs of memory.
 	 */
-	desc_base = kmalloc(entries * sizeof(au1x_ddma_desc_t), GFP_KERNEL);
+	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t), GFP_KERNEL);
 	if (desc_base == 0)
 		return 0;
 
@@ -381,7 +381,7 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 		kfree((const void *)desc_base);
 		i = entries * sizeof(au1x_ddma_desc_t);
 		i += (sizeof(au1x_ddma_desc_t) - 1);
-		if ((desc_base = kmalloc(i, GFP_KERNEL)) == 0)
+		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL)) == 0)
 			return 0;
 
 		desc_base = ALIGN_ADDR(desc_base, sizeof(au1x_ddma_desc_t));
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/dma.c linux-2.6.11-rc3/arch/mips/au1000/common/dma.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/dma.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/dma.c	2005-02-03 02:56:48.000000000 +0100
@@ -7,6 +7,7 @@
  * Copyright 2000 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
  *         	stevel@mvista.com or source@mvista.com
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -29,7 +30,7 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
-
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -61,7 +62,7 @@
  */
 
 
-spinlock_t au1000_dma_spin_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(au1000_dma_spin_lock);
 
 struct dma_chan au1000_dma_table[NUM_AU1000_DMA_CHANNELS] = {
       {.dev_id = -1,},
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/irq.c linux-2.6.11-rc3/arch/mips/au1000/common/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/irq.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/irq.c	2005-02-03 02:55:36.000000000 +0100
@@ -86,7 +86,7 @@ void	(*board_init_irq)(void);
 extern void counter0_irq(int irq, void *dev_id, struct pt_regs *regs);
 #endif
 
-static spinlock_t irq_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(irq_lock);
 
 
 static unsigned int startup_irq(unsigned int irq_nr)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/pci.c linux-2.6.11-rc3/arch/mips/au1000/common/pci.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/pci.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/pci.c	2005-02-03 02:56:35.000000000 +0100
@@ -78,10 +78,13 @@ static int __init au1x_pci_setup(void)
 
 #ifdef CONFIG_DMA_NONCOHERENT
 	/* 
-	 *  Set the NC bit in controller for pre-AC silicon
+         *  Set the NC bit in controller for Au1500 pre-AC silicon
 	 */
-	au_writel( 1<<16 | au_readl(Au1500_PCI_CFG), Au1500_PCI_CFG);
-	printk("Non-coherent PCI accesses enabled\n");
+	u32 prid = read_c0_prid();
+	if ( (prid & 0xFF000000) == 0x01000000 && prid < 0x01030202) {
+	       au_writel( 1<<16 | au_readl(Au1500_PCI_CFG), Au1500_PCI_CFG);
+	       printk("Non-coherent PCI accesses enabled\n");
+	}
 #endif
 
 	set_io_port_base(virt_io_addr);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/platform.c linux-2.6.11-rc3/arch/mips/au1000/common/platform.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/platform.c	2005-01-22 02:46:46.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/platform.c	2005-02-03 02:54:39.000000000 +0100
@@ -7,7 +7,6 @@
  * License version 2.  This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  */
-#include <linux/config.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/power.c linux-2.6.11-rc3/arch/mips/au1000/common/power.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/power.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/power.c	2005-02-03 02:56:48.000000000 +0100
@@ -66,7 +66,7 @@ extern void local_enable_irq(unsigned in
 #define	ACPI_SLEEP 21
 
 
-static spinlock_t pm_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(pm_lock);
 
 /* We need to save/restore a bunch of core registers that are
  * either volatile or reset to some state across a processor sleep.
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/sleeper.S linux-2.6.11-rc3/arch/mips/au1000/common/sleeper.S
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/sleeper.S	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/sleeper.S	2005-02-03 02:56:48.000000000 +0100
@@ -9,7 +9,6 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-#include <linux/config.h>
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
 #include <asm/addrspace.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/common/time.c linux-2.6.11-rc3/arch/mips/au1000/common/time.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/common/time.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/common/time.c	2005-02-03 02:55:36.000000000 +0100
@@ -69,7 +69,7 @@ extern void startup_match20_interrupt(vo
 static unsigned long last_pc0, last_match20;
 #endif
 
-static spinlock_t time_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(time_lock);
 
 static inline void ack_r4ktimer(unsigned long newval)
 {
@@ -304,8 +304,7 @@ unsigned long cal_r4koff(void)
 
 /* This is for machines which generate the exact clock. */
 #define USECS_PER_JIFFY (1000000/HZ)
-#define USECS_PER_JIFFY_FRAC (0x100000000*1000000/HZ&0xffffffff)
-
+#define USECS_PER_JIFFY_FRAC (0x100000000LL*1000000/HZ&0xffffffff)
 
 static unsigned long
 div64_32(unsigned long v1, unsigned long v2, unsigned long v3)
@@ -407,10 +406,6 @@ void au1xxx_timer_setup(struct irqaction
 	r4k_cur = (read_c0_count() + r4k_offset);
 	write_c0_compare(r4k_cur);
 
-	/* no RTC on the pb1000 */
-	xtime.tv_sec = 0;
-	//xtime.tv_usec = 0;
-
 #ifdef CONFIG_PM
 	/*
 	 * setup counter 0, since it keeps ticking after a
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/csb250/board_setup.c linux-2.6.11-rc3/arch/mips/au1000/csb250/board_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/csb250/board_setup.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/csb250/board_setup.c	2005-02-03 02:56:10.000000000 +0100
@@ -45,16 +45,6 @@
 #include <asm/au1000.h>
 #include <asm/csb250.h>
 
-#ifdef CONFIG_USB_OHCI
-// Enable the workaround for the OHCI DoneHead
-// register corruption problem.
-#define CONFIG_AU1000_OHCI_FIX
-#endif
-
-#ifdef CONFIG_RTC
-extern struct rtc_ops csb250_rtc_ops;
-#endif
-
 extern int (*board_pci_idsel)(unsigned int devsel, int assert);
 int	csb250_pci_idsel(unsigned int devsel, int assert);
 
@@ -203,7 +193,6 @@ void __init board_setup(void)
 	au_writel(au_readl(SYS_POWERCTRL) | (0x3 << 5), SYS_POWERCTRL);
 
 #ifdef CONFIG_RTC
-	rtc_ops = &csb250_rtc_ops;
 	// Enable the RTC if not already enabled
 	if (!(au_readl(0xac000028) & 0x20)) {
 		printk("enabling clock ...\n");
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/db1x00/mirage_ts.c linux-2.6.11-rc3/arch/mips/au1000/db1x00/mirage_ts.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/db1x00/mirage_ts.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/db1x00/mirage_ts.c	2005-02-03 02:56:11.000000000 +0100
@@ -42,6 +42,7 @@
 #include <linux/proc_fs.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/wait.h>
 
 #include <asm/segment.h>
 #include <asm/irq.h>
@@ -147,10 +148,7 @@ static int ts_thread(void *id)
 	ts = wm97xx_ts_get_handle(0);
 
 	/* proceed only after everybody is ready */
-	while ( ! wm97xx_ts_ready(ts) ) {
-		/* give a little time for initializations to complete */
-		interruptible_sleep_on_timeout(&pendown_wait, HZ / 4);
-	}
+	wait_event_timeout(pendown_wait, wm97xx_ts_ready(ts), HZ/4);
 
 	/* board-specific calibration */
 	wm97xx_ts_set_cal(ts,
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/hydrogen3/board_setup.c linux-2.6.11-rc3/arch/mips/au1000/hydrogen3/board_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/hydrogen3/board_setup.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/hydrogen3/board_setup.c	2005-02-03 02:55:51.000000000 +0100
@@ -45,8 +45,6 @@
 #include <asm/pgtable.h>
 #include <asm/au1000.h>
 
-extern struct rtc_ops no_rtc_ops;
-
 void board_reset (void)
 {
 }
@@ -55,8 +53,6 @@ void __init board_setup(void)
 {
 	u32 pin_func;
 
-	rtc_ops = &no_rtc_ops;
-
 #ifdef CONFIG_AU1X00_USB_DEVICE
 	// 2nd USB port is USB device
 	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8000);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/mtx-1/board_setup.c linux-2.6.11-rc3/arch/mips/au1000/mtx-1/board_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/mtx-1/board_setup.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/mtx-1/board_setup.c	2005-02-03 02:55:07.000000000 +0100
@@ -34,24 +34,24 @@
 #include <linux/ioport.h>
 #include <linux/mm.h>
 #include <linux/console.h>
-#include <linux/mc146818rtc.h>
 #include <linux/delay.h>
 
 #include <asm/cpu.h>
 #include <asm/bootinfo.h>
 #include <asm/irq.h>
-#include <asm/keyboard.h>
 #include <asm/mipsregs.h>
 #include <asm/reboot.h>
 #include <asm/pgtable.h>
-#include <asm/au1000.h>
+#include <asm/mach-au1x00/au1000.h>
 
-extern struct rtc_ops no_rtc_ops;
+void board_reset (void)
+{
+	/* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
+	au_writel(0x00000000, 0xAE00001C);
+}
 
 void __init board_setup(void)
 {
-	rtc_ops = &no_rtc_ops;
-
 #if defined (CONFIG_USB_OHCI) || defined (CONFIG_AU1X00_USB_DEVICE)
 #ifdef CONFIG_AU1X00_USB_DEVICE
 	// 2nd USB port is USB device
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/mtx-1/init.c linux-2.6.11-rc3/arch/mips/au1000/mtx-1/init.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/mtx-1/init.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/mtx-1/init.c	2005-02-03 02:55:15.000000000 +0100
@@ -28,17 +28,15 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/sched.h>
 #include <linux/bootmem.h>
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
-#include <linux/config.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
 
 int prom_argc;
 char **prom_argv, **prom_envp;
@@ -50,25 +48,24 @@ const char *get_system_type(void)
 	return "MTX-1";
 }
 
-int __init prom_init(int argc, char **argv, char **envp, int *prom_vec)
+void __init prom_init(void)
 {
 	unsigned char *memsize_str;
 	unsigned long memsize;
 
-	prom_argc = argc;
-	prom_argv = argv;
-	prom_envp = envp;
+	prom_argc = fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
 
 	mips_machgroup = MACH_GROUP_ALCHEMY;
 	mips_machtype = MACH_MTX1;	/* set the platform # */
+
 	prom_init_cmdline();
 
 	memsize_str = prom_getenv("memsize");
-	if (!memsize_str) {
+	if (!memsize_str)
 		memsize = 0x04000000;
-	} else {
+	else
 		memsize = simple_strtol(memsize_str, NULL, 0);
-	}
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
-	return 0;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/mtx-1/irqmap.c linux-2.6.11-rc3/arch/mips/au1000/mtx-1/irqmap.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/mtx-1/irqmap.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/mtx-1/irqmap.c	2005-02-03 02:55:14.000000000 +0100
@@ -45,12 +45,14 @@
 #include <asm/io.h>
 #include <asm/mipsregs.h>
 #include <asm/system.h>
-#include <asm/au1000.h>
+#include <asm/mach-au1x00/au1000.h>
 
-/* Need to define this.
-*/
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ 0. 0. 0}
+       { AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
+       { AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
+       { AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
+       { AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
+       { AU1500_GPIO_205, INTC_INT_LOW_LEVEL, 0 },
 };
 
-int au1xxx_nr_irqs = 0;
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1000/board_setup.c linux-2.6.11-rc3/arch/mips/au1000/pb1000/board_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1000/board_setup.c	2005-01-22 02:47:16.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/pb1000/board_setup.c	2005-02-03 02:55:14.000000000 +0100
@@ -37,16 +37,8 @@
 #include <asm/mipsregs.h>
 #include <asm/reboot.h>
 #include <asm/pgtable.h>
-#include <asm/au1000.h>
-#include <asm/pb1000.h>
-
-#ifdef CONFIG_USB_OHCI
-// Enable the workaround for the OHCI DoneHead
-// register corruption problem.
-#define CONFIG_AU1000_OHCI_FIX
-        ^^^^^^^^^^^^^^^^^^^^^^
-    !!! I shall not define symbols starting with CONFIG_ !!!
-#endif
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-pb1x00/pb1000.h>
 
 void board_reset (void)
 {
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1000/irqmap.c linux-2.6.11-rc3/arch/mips/au1000/pb1000/irqmap.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1000/irqmap.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/pb1000/irqmap.c	2005-02-03 02:56:33.000000000 +0100
@@ -45,7 +45,7 @@
 #include <asm/io.h>
 #include <asm/mipsregs.h>
 #include <asm/system.h>
-#include <asm/au1000.h>
+#include <asm/mach-au1x00/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 	{ AU1000_GPIO_15, INTC_INT_LOW_LEVEL, 0 },
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1100/board_setup.c linux-2.6.11-rc3/arch/mips/au1000/pb1100/board_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1100/board_setup.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/pb1100/board_setup.c	2005-02-03 02:56:33.000000000 +0100
@@ -40,14 +40,6 @@
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-pb1x00/pb1100.h>
 
-#ifdef CONFIG_USB_OHCI
-// Enable the workaround for the OHCI DoneHead
-// register corruption problem.
-#define CONFIG_AU1000_OHCI_FIX
-        ^^^^^^^^^^^^^^^^^^^^^^
-    !!! I shall not define symbols starting with CONFIG_ !!!
-#endif
-
 void board_reset (void)
 {
     /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1500/board_setup.c linux-2.6.11-rc3/arch/mips/au1000/pb1500/board_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1500/board_setup.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/pb1500/board_setup.c	2005-02-03 02:55:07.000000000 +0100
@@ -40,14 +40,6 @@
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-pb1x00/pb1500.h>
 
-#ifdef CONFIG_USB_OHCI
-// Enable the workaround for the OHCI DoneHead
-// register corruption problem.
-#define CONFIG_AU1000_OHCI_FIX
-        ^^^^^^^^^^^^^^^^^^^^^^
-    !!! I shall not define symbols starting with CONFIG_ !!!
-#endif
-
 void board_reset (void)
 {
     /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1550/board_setup.c linux-2.6.11-rc3/arch/mips/au1000/pb1550/board_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/au1000/pb1550/board_setup.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/au1000/pb1550/board_setup.c	2005-02-03 02:56:33.000000000 +0100
@@ -27,7 +27,6 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/ioport.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/atlas_defconfig linux-2.6.11-rc3/arch/mips/configs/atlas_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/atlas_defconfig	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/atlas_defconfig	2005-02-03 02:56:48.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:55 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:00 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -26,7 +26,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
 CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
@@ -45,7 +45,13 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Loadable module support
 #
-# CONFIG_MODULES is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
 
 #
 # Machine selection
@@ -79,6 +85,7 @@ CONFIG_MIPS_ATLAS=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_MIPS_BONITO64=y
@@ -89,7 +96,6 @@ CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -116,7 +122,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -133,6 +138,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -148,6 +167,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
 
 #
 # Memory Technology Devices (MTD)
@@ -170,17 +190,19 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-CONFIG_BLK_DEV_LOOP=y
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_NBD=m
 # CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 # CONFIG_BLK_DEV_INITRD is not set
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=y
+CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
 # CONFIG_CDROM_PKTCDVD_WCACHE is not set
 
@@ -191,11 +213,35 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
 #
-# CONFIG_IDE is not set
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
 
 #
 # SCSI device support
@@ -207,23 +253,25 @@ CONFIG_SCSI_PROC_FS=y
 # SCSI support type (disk, tape, CD-ROM)
 #
 CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
-# CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
 
 #
 # SCSI Transport Attributes
 #
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_ISCSI_ATTRS=m
 
 #
 # SCSI low-level drivers
@@ -248,19 +296,21 @@ CONFIG_BLK_DEV_SD=y
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
 # CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 # CONFIG_SCSI_QLA22XX is not set
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_QLA6322 is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_NSP32 is not set
@@ -269,7 +319,21 @@ CONFIG_SCSI_QLA2XXX=y
 #
 # Multi-device support (RAID and LVM)
 #
-# CONFIG_MD is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID5=m
+CONFIG_MD_RAID6=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
 
 #
 # Fusion MPT device support
@@ -295,54 +359,260 @@ CONFIG_NET=y
 # Networking options
 #
 CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
+CONFIG_PACKET_MMAP=y
 CONFIG_NETLINK_DEV=y
 CONFIG_UNIX=y
 CONFIG_NET_KEY=y
 CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_FWMARK=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
 CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
 # CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_TUNNEL=m
+CONFIG_IP_TCPDIAG=m
+CONFIG_IP_TCPDIAG_IPV6=y
+
+#
+# IP: Virtual Server Configuration
+#
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_CT_ACCT=y
+CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CT_PROTO_SCTP=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_PHYSDEV=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_MATCH_REALM=m
+CONFIG_IP_NF_MATCH_SCTP=m
+CONFIG_IP_NF_MATCH_COMMENT=m
+CONFIG_IP_NF_MATCH_CONNMARK=m
+CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_CONNMARK=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_TARGET_NOTRACK=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_LIMIT=m
+CONFIG_IP6_NF_MATCH_MAC=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_MULTIPORT=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_MARK=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AHESP=m
+CONFIG_IP6_NF_MATCH_LENGTH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_PHYSDEV=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_MARK=m
+CONFIG_IP6_NF_RAW=m
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
 CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
+CONFIG_XFRM_USER=m
 
 #
 # SCTP Configuration (EXPERIMENTAL)
 #
-# CONFIG_IP_SCTP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
 # CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
+CONFIG_BRIDGE=m
+CONFIG_VLAN_8021Q=m
 # CONFIG_DECNET is not set
+CONFIG_LLC=m
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
-# CONFIG_ATALK is not set
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=y
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
+CONFIG_NET_DIVERT=y
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
 
 #
 # QoS and/or fair queueing
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CLK_JIFFIES=y
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_NET_CLS_IND=y
+# CONFIG_CLS_U32_MARK is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
 
 #
 # Network testing
@@ -354,10 +624,10 @@ CONFIG_XFRM_USER=y
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
 CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
+CONFIG_EQUALIZER=m
+CONFIG_TUN=m
 # CONFIG_ETHERTAP is not set
 
 #
@@ -369,7 +639,7 @@ CONFIG_NETDEVICES=y
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_NET_VENDOR_3COM is not set
@@ -379,7 +649,26 @@ CONFIG_NET_ETHERNET=y
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
-# CONFIG_NET_PCI is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+CONFIG_LAN_SAA9730=y
 
 #
 # Ethernet (1000 Mbit)
@@ -392,6 +681,7 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
 # CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
 
 #
@@ -440,7 +730,7 @@ CONFIG_INPUT=y
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV=m
 CONFIG_INPUT_MOUSEDEV_PSAUX=y
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
@@ -459,13 +749,17 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
 CONFIG_SERIO_RAW=y
 
 #
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_MOUSE_SERIAL=m
+# CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
@@ -513,7 +807,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -544,12 +837,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -564,38 +859,81 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_QUOTA is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+CONFIG_REISERFS_PROC_INFO=y
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_XFS_FS=m
+# CONFIG_XFS_RT is not set
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_SECURITY=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_MINIX_FS=m
+CONFIG_ROMFS_FS=m
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
-# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=m
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 # CONFIG_NTFS_FS is not set
 
 #
@@ -615,18 +953,20 @@ CONFIG_RAMFS=y
 # Miscellaneous filesystems
 #
 # CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
+CONFIG_AFFS_FS=m
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+CONFIG_BEFS_FS=m
+# CONFIG_BEFS_DEBUG is not set
+CONFIG_BFS_FS=m
+CONFIG_EFS_FS=m
+CONFIG_CRAMFS=m
+CONFIG_VXFS_FS=m
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
+CONFIG_SYSV_FS=m
+CONFIG_UFS_FS=m
+# CONFIG_UFS_FS_WRITE is not set
 
 #
 # Network File Systems
@@ -635,11 +975,14 @@ CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
-# CONFIG_NFSD is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFSD_TCP is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
+CONFIG_EXPORTFS=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -658,7 +1001,51 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Native Language Support
 #
-# CONFIG_NLS is not set
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
 
 #
 # Kernel hacking
@@ -670,20 +1057,48 @@ CONFIG_CMDLINE=""
 #
 # Security options
 #
-CONFIG_KEYS=y
-CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
 
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
 
 #
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/capcella_defconfig linux-2.6.11-rc3/arch/mips/configs/capcella_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/capcella_defconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/capcella_defconfig	2005-02-03 02:55:15.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:55 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:00 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -58,6 +58,7 @@ CONFIG_KMOD=y
 #
 # CONFIG_MACH_JAZZ is not set
 CONFIG_MACH_VR41XX=y
+# CONFIG_NEC_CMBVR4133 is not set
 # CONFIG_CASIO_E55 is not set
 # CONFIG_IBM_WORKPAD is not set
 # CONFIG_TANBAC_TB0226 is not set
@@ -93,12 +94,12 @@ CONFIG_VRC4173=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -138,6 +139,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -153,6 +168,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -176,10 +192,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -193,6 +211,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -418,6 +437,7 @@ CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=m
 CONFIG_SERIO_RAW=m
 
 #
@@ -484,7 +504,6 @@ CONFIG_WATCHDOG=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -515,12 +534,14 @@ CONFIG_WATCHDOG=y
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -535,11 +556,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -633,6 +668,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -652,6 +692,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/cobalt_defconfig linux-2.6.11-rc3/arch/mips/configs/cobalt_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/cobalt_defconfig	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/cobalt_defconfig	2005-02-03 02:55:23.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:55 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:00 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -26,7 +26,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
 CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
@@ -79,6 +79,7 @@ CONFIG_MIPS_COBALT=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_I8259=y
@@ -86,7 +87,6 @@ CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_GT64111=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -128,6 +128,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -143,6 +157,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
 
 #
 # Memory Technology Devices (MTD)
@@ -166,11 +181,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
@@ -184,6 +201,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -405,6 +423,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -459,7 +478,6 @@ CONFIG_COBALT_LCD=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -490,12 +508,14 @@ CONFIG_COBALT_LCD=y
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -510,11 +530,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -609,6 +643,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -628,6 +667,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/db1000_defconfig linux-2.6.11-rc3/arch/mips/configs/db1000_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/db1000_defconfig	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/db1000_defconfig	2005-02-03 02:57:16.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:56 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:01 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -101,11 +101,11 @@ CONFIG_MIPS_DB1000=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -132,7 +132,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -151,7 +150,6 @@ CONFIG_MMU=y
 #
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_OBSOLETE is not set
 CONFIG_PCMCIA=m
 
 #
@@ -200,10 +198,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -217,6 +217,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -293,8 +294,6 @@ CONFIG_IP_NF_CONNTRACK_MARK=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
@@ -426,6 +425,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -479,7 +479,6 @@ CONFIG_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 
 #
@@ -515,12 +514,14 @@ CONFIG_SYNCLINK_CS=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -534,11 +535,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -686,6 +701,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -728,6 +748,10 @@ CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/db1100_defconfig linux-2.6.11-rc3/arch/mips/configs/db1100_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/db1100_defconfig	2005-01-22 02:47:33.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/db1100_defconfig	2005-02-03 02:55:35.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:56 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:01 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -101,11 +101,11 @@ CONFIG_MIPS_DB1100=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -132,7 +132,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -149,7 +148,6 @@ CONFIG_MMU=y
 #
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_OBSOLETE is not set
 CONFIG_PCMCIA=m
 
 #
@@ -198,10 +196,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -215,6 +215,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -291,8 +292,6 @@ CONFIG_IP_NF_CONNTRACK_MARK=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
@@ -424,6 +423,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+CONFIG_SERIO_LIBPS2=m
 CONFIG_SERIO_RAW=m
 
 #
@@ -474,7 +474,6 @@ CONFIG_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 
 #
@@ -510,12 +509,14 @@ CONFIG_SYNCLINK_CS=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -529,11 +530,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -681,6 +696,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -723,6 +743,10 @@ CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/db1500_defconfig linux-2.6.11-rc3/arch/mips/configs/db1500_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/db1500_defconfig	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/db1500_defconfig	2005-02-03 02:55:50.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:56 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:01 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -101,12 +101,12 @@ CONFIG_MIPS_DB1500=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -133,7 +133,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -154,7 +153,6 @@ CONFIG_MMU=y
 #
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_OBSOLETE is not set
 CONFIG_PCMCIA=m
 CONFIG_CARDBUS=y
 
@@ -234,6 +232,7 @@ CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
 
 #
 # Mapping drivers for chip access
@@ -252,6 +251,7 @@ CONFIG_MTD_DB1X00_USER=y
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
 # CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
 
 #
 # Disk-On-Chip Device Drivers
@@ -282,12 +282,14 @@ CONFIG_MTD_DB1X00_USER=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_UB is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -301,6 +303,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -402,8 +405,6 @@ CONFIG_IP_NF_CONNTRACK_MARK=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
@@ -557,6 +558,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -609,7 +611,6 @@ CONFIG_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 
 #
@@ -645,6 +646,8 @@ CONFIG_SYNCLINK_CS=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -705,6 +708,7 @@ CONFIG_USB_ARCH_HAS_OHCI=y
 # CONFIG_USB_EHCI_HCD is not set
 CONFIG_USB_OHCI_HCD=y
 # CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
 
 #
 # USB Device Class drivers
@@ -714,6 +718,10 @@ CONFIG_USB_OHCI_HCD=y
 # CONFIG_USB_MIDI is not set
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
 # CONFIG_USB_STORAGE is not set
 
 #
@@ -769,7 +777,6 @@ CONFIG_USB_HIDINPUT=y
 #
 # CONFIG_USB_EMI62 is not set
 # CONFIG_USB_EMI26 is not set
-# CONFIG_USB_TIGL is not set
 # CONFIG_USB_AUERSWALD is not set
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
@@ -778,6 +785,7 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_CYTHERM is not set
 # CONFIG_USB_PHIDGETKIT is not set
 # CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
 
 #
 # USB ATM/DSL drivers
@@ -789,6 +797,16 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -938,6 +956,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -980,6 +1003,10 @@ CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/db1550_defconfig linux-2.6.11-rc3/arch/mips/configs/db1550_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/db1550_defconfig	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/db1550_defconfig	2005-02-03 02:55:08.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:57 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:02 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -101,12 +101,12 @@ CONFIG_MIPS_DB1550=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -133,7 +133,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -154,7 +153,6 @@ CONFIG_MMU=y
 #
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_OBSOLETE is not set
 CONFIG_PCMCIA=m
 CONFIG_CARDBUS=y
 
@@ -252,6 +250,7 @@ CONFIG_MTD_DB1550_USER=y
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
 # CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
 
 #
 # Disk-On-Chip Device Drivers
@@ -268,6 +267,7 @@ CONFIG_MTD_NAND=m
 CONFIG_MTD_NAND_IDS=m
 CONFIG_MTD_NAND_AU1550=m
 # CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
 
 #
 # Parallel port support
@@ -286,11 +286,13 @@ CONFIG_MTD_NAND_AU1550=m
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -304,6 +306,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -433,8 +436,6 @@ CONFIG_IP_NF_CONNTRACK_MARK=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
@@ -596,6 +597,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -649,7 +651,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 
 #
@@ -685,6 +686,8 @@ CONFIG_SYNCLINK_CS=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -699,11 +702,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -853,6 +870,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -895,6 +917,10 @@ CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ddb5476_defconfig linux-2.6.11-rc3/arch/mips/configs/ddb5476_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ddb5476_defconfig	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ddb5476_defconfig	2005-02-03 02:57:16.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:57 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:02 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -79,6 +79,7 @@ CONFIG_DDB5476=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_I8259=y
@@ -86,7 +87,6 @@ CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_DDB5XXX_COMMON=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_FB=y
 CONFIG_HAVE_STD_PC_SERIAL_PORT=y
 
 #
@@ -130,6 +130,21 @@ CONFIG_ISA=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+CONFIG_PCMCIA_PROBE=y
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -145,6 +160,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -170,10 +186,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
@@ -187,6 +205,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -424,6 +443,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -478,7 +498,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -509,6 +528,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+CONFIG_FB=y
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -544,6 +564,7 @@ CONFIG_DUMMY_CONSOLE=y
 # Logo configuration
 #
 # CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -558,11 +579,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -654,6 +689,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -673,6 +713,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ddb5477_defconfig linux-2.6.11-rc3/arch/mips/configs/ddb5477_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ddb5477_defconfig	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ddb5477_defconfig	2005-02-03 02:56:22.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:58 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:02 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -80,6 +80,7 @@ CONFIG_DDB5477_BUS_FREQUENCY=0
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_I8259=y
@@ -87,7 +88,6 @@ CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_DDB5XXX_COMMON=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -129,6 +129,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -144,6 +158,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -167,10 +182,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
@@ -184,6 +201,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -406,6 +424,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -460,7 +479,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -491,12 +509,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -511,11 +531,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -609,6 +643,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -628,6 +667,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/decstation_defconfig linux-2.6.11-rc3/arch/mips/configs/decstation_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/decstation_defconfig	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/decstation_defconfig	2005-02-03 02:56:11.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:58 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:03 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -85,6 +85,7 @@ CONFIG_MACH_DECSTATION=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_EARLY_PRINTK=y
@@ -92,7 +93,6 @@ CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=4
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -129,6 +129,19 @@ CONFIG_TC=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -144,6 +157,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -163,9 +177,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -179,6 +195,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -212,6 +229,7 @@ CONFIG_SCSI_CONSTANTS=y
 #
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 
 #
 # SCSI low-level drivers
@@ -219,7 +237,6 @@ CONFIG_SCSI_CONSTANTS=y
 CONFIG_SCSI_DECNCR=y
 # CONFIG_SCSI_DECSII is not set
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 # CONFIG_SCSI_DEBUG is not set
 
 #
@@ -382,6 +399,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -434,7 +452,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -465,12 +482,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -484,11 +503,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -590,6 +623,11 @@ CONFIG_ULTRIX_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -609,6 +647,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/e55_defconfig linux-2.6.11-rc3/arch/mips/configs/e55_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/e55_defconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/e55_defconfig	2005-02-03 02:55:15.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:58 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:03 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -58,6 +58,7 @@ CONFIG_KMOD=y
 #
 # CONFIG_MACH_JAZZ is not set
 CONFIG_MACH_VR41XX=y
+# CONFIG_NEC_CMBVR4133 is not set
 CONFIG_CASIO_E55=y
 # CONFIG_IBM_WORKPAD is not set
 # CONFIG_TANBAC_TB0226 is not set
@@ -92,12 +93,12 @@ CONFIG_CASIO_E55=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -134,6 +135,20 @@ CONFIG_ISA=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+CONFIG_PCMCIA_PROBE=y
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +164,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -170,9 +186,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 # CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_XD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -186,6 +204,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -397,6 +416,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -463,7 +483,6 @@ CONFIG_WATCHDOG=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -494,6 +513,7 @@ CONFIG_WATCHDOG=y
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
@@ -501,6 +521,7 @@ CONFIG_WATCHDOG=y
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -514,11 +535,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -611,6 +646,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -630,6 +670,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ev64120_defconfig linux-2.6.11-rc3/arch/mips/configs/ev64120_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ev64120_defconfig	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ev64120_defconfig	2005-02-03 02:55:40.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:59 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:03 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -86,6 +86,7 @@ CONFIG_MIPS_EV64120=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
@@ -94,7 +95,6 @@ CONFIG_MIPS_GT64120=y
 # CONFIG_SYSCLK_83 is not set
 CONFIG_SYSCLK_100=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -137,6 +137,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -152,6 +166,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -175,10 +190,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -192,6 +209,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -400,6 +418,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -454,7 +473,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -485,12 +503,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -505,11 +525,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -601,6 +635,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -620,6 +659,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=y
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ev96100_defconfig linux-2.6.11-rc3/arch/mips/configs/ev96100_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ev96100_defconfig	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ev96100_defconfig	2005-02-03 02:56:11.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:59 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:03 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -85,6 +85,7 @@ CONFIG_MIPS_EV96100=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
@@ -93,7 +94,6 @@ CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_MIPS_GT96100=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -137,6 +137,19 @@ CONFIG_HW_HAS_PCI=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -152,6 +165,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -171,9 +185,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -187,6 +203,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -357,6 +374,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -410,7 +428,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -441,12 +458,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -460,11 +479,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -556,6 +589,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -575,6 +613,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ip27_defconfig linux-2.6.11-rc3/arch/mips/configs/ip27_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ip27_defconfig	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ip27_defconfig	2005-02-03 02:55:50.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:00 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:04 2005
 #
 CONFIG_MIPS=y
 CONFIG_MIPS64=y
@@ -91,12 +91,12 @@ CONFIG_NUMA=y
 # CONFIG_SIBYTE_SB1xxx_SOC is not set
 # CONFIG_SNI_RM200_PCI is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_IP27=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=7
-# CONFIG_FB is not set
 CONFIG_ARC64=y
 CONFIG_BOOT_ELF64=y
 CONFIG_QL_ISP_A64=y
@@ -145,6 +145,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -165,6 +179,7 @@ CONFIG_BINFMT_ELF32=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -188,11 +203,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_CRYPTOLOOP=m
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -205,6 +222,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -238,6 +256,7 @@ CONFIG_SCSI_LOGGING=y
 #
 CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 
 #
 # SCSI low-level drivers
@@ -266,14 +285,12 @@ CONFIG_SCSI_SPI_ATTRS=y
 CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 # CONFIG_SCSI_QLA22XX is not set
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_QLA6322 is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -509,6 +526,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -562,7 +580,6 @@ CONFIG_SGI_IP27_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -593,6 +610,8 @@ CONFIG_SGI_IP27_RTC=y
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -607,11 +626,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -732,6 +765,11 @@ CONFIG_SGI_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -774,6 +812,10 @@ CONFIG_CRYPTO_CRC32C=m
 CONFIG_CRYPTO_TEST=m
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ip32_defconfig linux-2.6.11-rc3/arch/mips/configs/ip32_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ip32_defconfig	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ip32_defconfig	2005-02-03 02:55:23.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:00 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:04 2005
 #
 CONFIG_MIPS=y
 CONFIG_MIPS64=y
@@ -78,14 +78,16 @@ CONFIG_SGI_IP32=y
 # CONFIG_SIBYTE_SB1xxx_SOC is not set
 # CONFIG_SNI_RM200_PCI is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
+CONFIG_DMA_IP32=y
+CONFIG_OWN_DMA=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_ARC32=y
-# CONFIG_FB is not set
 CONFIG_ARC_MEMORY=y
 CONFIG_ARC_PROMLIB=y
 
@@ -131,6 +133,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -151,6 +167,7 @@ CONFIG_BINFMT_ELF32=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -174,11 +191,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -191,6 +210,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -225,6 +245,7 @@ CONFIG_SCSI_LOGGING=y
 #
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 
 #
 # SCSI low-level drivers
@@ -258,14 +279,12 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 # CONFIG_SCSI_QLA22XX is not set
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_QLA6322 is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -465,6 +484,7 @@ CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 # CONFIG_SERIO_MACEPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -519,7 +539,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -550,12 +569,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -570,11 +591,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -678,6 +713,11 @@ CONFIG_SGI_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -697,6 +737,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/it8172_defconfig linux-2.6.11-rc3/arch/mips/configs/it8172_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/it8172_defconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/it8172_defconfig	2005-02-03 02:55:15.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:00 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:05 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -87,6 +87,7 @@ CONFIG_MIPS_ITE8172=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
@@ -94,7 +95,6 @@ CONFIG_ITE_BOARD_GEN=y
 CONFIG_IT8172_CIR=y
 CONFIG_IT8712=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -134,6 +134,19 @@ CONFIG_HW_HAS_PCI=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +162,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -192,6 +206,7 @@ CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
 
 #
 # Mapping drivers for chip access
@@ -209,6 +224,7 @@ CONFIG_MTD_PHYSMAP_BANKWIDTH=2
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
 # CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
 
 #
 # Disk-On-Chip Device Drivers
@@ -235,10 +251,12 @@ CONFIG_MTD_PHYSMAP_BANKWIDTH=2
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -252,6 +270,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -443,6 +462,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -500,7 +520,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -531,12 +550,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -570,11 +591,25 @@ CONFIG_SOUND_IT8172=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -668,6 +703,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -687,6 +727,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ivr_defconfig linux-2.6.11-rc3/arch/mips/configs/ivr_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ivr_defconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ivr_defconfig	2005-02-03 02:55:15.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:01 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:05 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -86,13 +86,13 @@ CONFIG_MIPS_IVR=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_ITE_BOARD_GEN=y
 CONFIG_IT8172_CIR=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -134,6 +134,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +163,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -172,10 +187,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -189,6 +206,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -413,6 +431,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -468,7 +487,6 @@ CONFIG_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -499,12 +517,14 @@ CONFIG_RTC=y
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -519,11 +539,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -615,6 +649,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -634,6 +673,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/jaguar-atx_defconfig linux-2.6.11-rc3/arch/mips/configs/jaguar-atx_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/jaguar-atx_defconfig	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/jaguar-atx_defconfig	2005-02-03 02:56:48.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:01 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:05 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -78,6 +78,7 @@ CONFIG_JAGUAR_DMALOW=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_LIMITED_DMA=y
@@ -89,7 +90,6 @@ CONFIG_PCI_MARVELL=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -137,6 +137,19 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -152,6 +165,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -174,10 +188,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -191,6 +207,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -305,7 +322,6 @@ CONFIG_NET_PCI=y
 # CONFIG_ADAPTEC_STARFIRE is not set
 # CONFIG_DGRS is not set
 CONFIG_EEPRO100=y
-# CONFIG_EEPRO100_PIO is not set
 # CONFIG_E100 is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
@@ -430,7 +446,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -461,6 +476,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -475,11 +492,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -576,6 +607,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/jmr3927_defconfig linux-2.6.11-rc3/arch/mips/configs/jmr3927_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/jmr3927_defconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/jmr3927_defconfig	2005-02-03 02:55:15.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:01 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:06 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -79,13 +79,13 @@ CONFIG_TOSHIBA_JMR3927=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 CONFIG_MIPS_TX3927=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_FB=y
 CONFIG_TOSHIBA_BOARDS=y
 
 #
@@ -127,6 +127,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -142,6 +156,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -165,10 +180,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
@@ -182,6 +199,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -384,6 +402,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -409,6 +428,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_DIGI is not set
 # CONFIG_MOXA_INTELLIO is not set
 # CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
 # CONFIG_SYNCLINK is not set
 # CONFIG_SYNCLINKMP is not set
 # CONFIG_N_HDLC is not set
@@ -452,7 +472,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -483,6 +502,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+CONFIG_FB=y
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -517,6 +537,7 @@ CONFIG_DUMMY_CONSOLE=y
 # Logo configuration
 #
 # CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -531,11 +552,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -624,6 +659,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -643,6 +683,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/lasat200_defconfig linux-2.6.11-rc3/arch/mips/configs/lasat200_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/lasat200_defconfig	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/lasat200_defconfig	2005-02-03 02:56:10.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:02 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:06 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -89,13 +89,13 @@ CONFIG_LASAT_SYSCTL=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_MIPS_NILE4=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -140,6 +140,20 @@ CONFIG_PCI_LEGACY_PROC=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -155,6 +169,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -216,6 +231,7 @@ CONFIG_MTD_LASAT=y
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
 # CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
 
 #
 # Disk-On-Chip Device Drivers
@@ -246,10 +262,12 @@ CONFIG_MTD_LASAT=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -263,6 +281,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -511,6 +530,7 @@ CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -565,7 +585,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -596,12 +615,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -616,11 +637,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -719,6 +754,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -738,6 +778,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/malta_defconfig linux-2.6.11-rc3/arch/mips/configs/malta_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/malta_defconfig	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/malta_defconfig	2005-02-03 02:56:35.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:02 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:53:14 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -26,7 +26,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
 CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
@@ -85,6 +85,7 @@ CONFIG_MIPS_MALTA=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_GENERIC_ISA_DMA=y
@@ -97,7 +98,6 @@ CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 CONFIG_HAVE_STD_PC_SERIAL_PORT=y
 
 #
@@ -124,8 +124,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
-CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -142,6 +140,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -157,6 +169,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
 
 #
 # Memory Technology Devices (MTD)
@@ -175,15 +188,18 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_FD=m
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_NBD=m
 # CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 # CONFIG_BLK_DEV_INITRD is not set
 CONFIG_INITRAMFS_SOURCE=""
@@ -199,25 +215,162 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
 #
-# CONFIG_IDE is not set
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+# CONFIG_IDEPCI_SHARE_IRQ is not set
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+CONFIG_BLK_DEV_PIIX=y
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
 
 #
 # SCSI device support
 #
-# CONFIG_SCSI is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_ISCSI_ATTRS=m
+
+#
+# SCSI low-level drivers
+#
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+CONFIG_SCSI_3W_9XXX=m
+CONFIG_SCSI_ACARD=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=32
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=m
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
 
 #
 # Multi-device support (RAID and LVM)
 #
-# CONFIG_MD is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID5=m
+CONFIG_MD_RAID6=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
 
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -237,54 +390,261 @@ CONFIG_NET=y
 #
 # Networking options
 #
-# CONFIG_PACKET is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
 CONFIG_NETLINK_DEV=y
 CONFIG_UNIX=y
 CONFIG_NET_KEY=y
 CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_FWMARK=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
 # CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
 CONFIG_INET_TUNNEL=m
 CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
+CONFIG_IP_TCPDIAG_IPV6=y
+
+#
+# IP: Virtual Server Configuration
+#
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_CT_ACCT=y
+CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CT_PROTO_SCTP=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_PHYSDEV=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_MATCH_REALM=m
+CONFIG_IP_NF_MATCH_SCTP=m
+CONFIG_IP_NF_MATCH_COMMENT=m
+CONFIG_IP_NF_MATCH_CONNMARK=m
+CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_CONNMARK=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_TARGET_NOTRACK=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_LIMIT=m
+CONFIG_IP6_NF_MATCH_MAC=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_MULTIPORT=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_MARK=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AHESP=m
+CONFIG_IP6_NF_MATCH_LENGTH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_PHYSDEV=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_MARK=m
+CONFIG_IP6_NF_RAW=m
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
 #
 # SCTP Configuration (EXPERIMENTAL)
 #
-# CONFIG_IP_SCTP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
 # CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
+CONFIG_BRIDGE=m
+CONFIG_VLAN_8021Q=m
 # CONFIG_DECNET is not set
+CONFIG_LLC=m
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
-# CONFIG_ATALK is not set
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=y
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
+CONFIG_NET_DIVERT=y
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
 
 #
 # QoS and/or fair queueing
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CLK_JIFFIES=y
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_NET_CLS_IND=y
+# CONFIG_CLS_U32_MARK is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
 
 #
 # Network testing
@@ -296,10 +656,10 @@ CONFIG_XFRM_USER=m
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
 CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
+CONFIG_EQUALIZER=m
+CONFIG_TUN=m
 # CONFIG_ETHERTAP is not set
 
 #
@@ -380,6 +740,7 @@ CONFIG_PCNET32=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -420,7 +781,8 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_RAW=m
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
 
 #
 # Input Device Drivers
@@ -473,7 +835,6 @@ CONFIG_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -504,12 +865,14 @@ CONFIG_RTC=y
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -524,23 +887,59 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_QUOTA is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+CONFIG_REISERFS_PROC_INFO=y
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_XFS_FS=m
+# CONFIG_XFS_RT is not set
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_SECURITY=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_MINIX_FS=m
+CONFIG_ROMFS_FS=m
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
@@ -548,14 +947,21 @@ CONFIG_AUTOFS_FS=y
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=m
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 # CONFIG_NTFS_FS is not set
 
 #
@@ -575,18 +981,20 @@ CONFIG_RAMFS=y
 # Miscellaneous filesystems
 #
 # CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-CONFIG_EFS_FS=y
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
+CONFIG_AFFS_FS=m
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+CONFIG_BEFS_FS=m
+# CONFIG_BEFS_DEBUG is not set
+CONFIG_BFS_FS=m
+CONFIG_EFS_FS=m
+CONFIG_CRAMFS=m
+CONFIG_VXFS_FS=m
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
+CONFIG_SYSV_FS=m
+CONFIG_UFS_FS=m
+# CONFIG_UFS_FS_WRITE is not set
 
 #
 # Network File Systems
@@ -621,7 +1029,51 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Native Language Support
 #
-# CONFIG_NLS is not set
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
 
 #
 # Kernel hacking
@@ -633,14 +1085,40 @@ CONFIG_CMDLINE=""
 #
 # Security options
 #
-CONFIG_KEYS=y
-CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
 
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
 
 #
 # Library routines
@@ -648,5 +1126,7 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRC_CCITT is not set
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/mpc30x_defconfig linux-2.6.11-rc3/arch/mips/configs/mpc30x_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/mpc30x_defconfig	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/mpc30x_defconfig	2005-02-03 02:56:48.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:02 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:07 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -58,6 +58,7 @@ CONFIG_KMOD=y
 #
 # CONFIG_MACH_JAZZ is not set
 CONFIG_MACH_VR41XX=y
+# CONFIG_NEC_CMBVR4133 is not set
 # CONFIG_CASIO_E55 is not set
 # CONFIG_IBM_WORKPAD is not set
 # CONFIG_TANBAC_TB0226 is not set
@@ -93,12 +94,12 @@ CONFIG_VRC4173=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -138,6 +139,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -153,6 +168,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -176,10 +192,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -193,6 +211,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -396,6 +415,7 @@ CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -450,7 +470,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -481,12 +500,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -501,11 +522,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -597,6 +632,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -639,6 +679,10 @@ CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_3_defconfig linux-2.6.11-rc3/arch/mips/configs/ocelot_3_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_3_defconfig	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ocelot_3_defconfig	2005-02-03 02:55:36.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:03 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:07 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -86,6 +86,7 @@ CONFIG_MOMENCO_OCELOT_3=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
@@ -96,7 +97,6 @@ CONFIG_PCI_MARVELL=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_FB=y
 
 #
 # CPU selection
@@ -144,6 +144,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -159,6 +173,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -182,11 +197,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
@@ -198,6 +215,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -231,6 +249,7 @@ CONFIG_SCSI_PROC_FS=y
 #
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 
 #
 # SCSI low-level drivers
@@ -260,14 +279,12 @@ CONFIG_SCSI_PROC_FS=y
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=m
 # CONFIG_SCSI_QLA21XX is not set
 # CONFIG_SCSI_QLA22XX is not set
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_QLA6322 is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_NSP32 is not set
@@ -346,8 +363,6 @@ CONFIG_NETFILTER=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 
 #
 # IPv6: Netfilter Configuration
@@ -524,6 +539,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_SERPORT is not set
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 # CONFIG_SERIO_RAW is not set
 
 #
@@ -577,7 +593,6 @@ CONFIG_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -608,6 +623,7 @@ CONFIG_RTC=y
 #
 # Graphics support
 #
+CONFIG_FB=y
 CONFIG_FB_MODE_HELPERS=y
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -648,6 +664,7 @@ CONFIG_LOGO=y
 CONFIG_LOGO_LINUX_MONO=y
 CONFIG_LOGO_LINUX_VGA16=y
 CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -662,11 +679,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -817,6 +848,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -835,6 +871,10 @@ CONFIG_CMDLINE="ip=any root=nfs"
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_c_defconfig linux-2.6.11-rc3/arch/mips/configs/ocelot_c_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_c_defconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ocelot_c_defconfig	2005-02-03 02:55:15.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:03 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:07 2005
 #
 CONFIG_MIPS=y
 CONFIG_MIPS64=y
@@ -77,6 +77,7 @@ CONFIG_MOMENCO_OCELOT_C=y
 # CONFIG_SIBYTE_SB1xxx_SOC is not set
 # CONFIG_SNI_RM200_PCI is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
@@ -85,7 +86,6 @@ CONFIG_IRQ_MV64340=y
 CONFIG_PCI_MARVELL=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -129,6 +129,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +163,7 @@ CONFIG_BINFMT_ELF32=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -172,10 +187,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -188,6 +205,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -390,6 +408,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -444,7 +463,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -475,12 +493,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -495,11 +515,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -593,6 +627,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -612,6 +651,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_defconfig linux-2.6.11-rc3/arch/mips/configs/ocelot_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_defconfig	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ocelot_defconfig	2005-02-03 02:55:50.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:04 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:08 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -79,6 +79,7 @@ CONFIG_MOMENCO_OCELOT=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
@@ -90,7 +91,6 @@ CONFIG_SWAP_IO_SPACE=y
 # CONFIG_SYSCLK_83 is not set
 CONFIG_SYSCLK_100=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -134,6 +134,19 @@ CONFIG_HW_HAS_PCI=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +162,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -168,9 +182,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
@@ -184,6 +200,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -353,6 +370,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -406,7 +424,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -437,12 +454,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -456,11 +475,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -554,6 +587,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -573,6 +611,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_g_defconfig linux-2.6.11-rc3/arch/mips/configs/ocelot_g_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/ocelot_g_defconfig	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/ocelot_g_defconfig	2005-02-03 02:55:53.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:04 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:08 2005
 #
 CONFIG_MIPS=y
 CONFIG_MIPS64=y
@@ -77,6 +77,7 @@ CONFIG_MOMENCO_OCELOT_G=y
 # CONFIG_SIBYTE_SB1xxx_SOC is not set
 # CONFIG_SNI_RM200_PCI is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
@@ -88,7 +89,6 @@ CONFIG_SWAP_IO_SPACE=y
 # CONFIG_SYSCLK_83 is not set
 CONFIG_SYSCLK_100=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -132,6 +132,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -152,6 +166,7 @@ CONFIG_BINFMT_ELF32=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -175,10 +190,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -191,6 +208,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=y
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -393,6 +411,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -447,7 +466,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -478,12 +496,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -498,11 +518,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -596,6 +630,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -615,6 +654,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/osprey_defconfig linux-2.6.11-rc3/arch/mips/configs/osprey_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/osprey_defconfig	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/osprey_defconfig	2005-02-03 02:57:05.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:04 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:08 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -85,12 +85,12 @@ CONFIG_NEC_OSPREY=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 CONFIG_VR4181=y
 
 #
@@ -127,6 +127,19 @@ CONFIG_CPU_HAS_SYNC=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -142,6 +155,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -161,9 +175,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -177,6 +193,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -347,6 +364,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -400,7 +418,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -431,12 +448,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -450,11 +469,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -548,6 +581,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -567,6 +605,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/pb1100_defconfig linux-2.6.11-rc3/arch/mips/configs/pb1100_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/pb1100_defconfig	2005-01-22 02:48:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/pb1100_defconfig	2005-02-03 02:55:52.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:05 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:08 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -101,13 +101,13 @@ CONFIG_MIPS_PB1100=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_SWAP_IO_SPACE=y
-# CONFIG_AU1000_USB_DEVICE is not set
+# CONFIG_AU1X00_USB_DEVICE is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -134,7 +134,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -153,7 +152,6 @@ CONFIG_MMU=y
 #
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_OBSOLETE is not set
 CONFIG_PCMCIA=m
 
 #
@@ -245,6 +243,7 @@ CONFIG_MTD_PB1500_USER=y
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
 # CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
 
 #
 # Disk-On-Chip Device Drivers
@@ -271,10 +270,12 @@ CONFIG_MTD_PB1500_USER=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -288,6 +289,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -364,8 +366,6 @@ CONFIG_IP_NF_CONNTRACK_MARK=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
@@ -489,6 +489,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -539,7 +540,6 @@ CONFIG_RTC=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 
 #
@@ -575,12 +575,14 @@ CONFIG_SYNCLINK_CS=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -594,11 +596,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -748,6 +764,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -790,6 +811,10 @@ CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/pb1500_defconfig linux-2.6.11-rc3/arch/mips/configs/pb1500_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/pb1500_defconfig	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/pb1500_defconfig	2005-02-03 02:55:35.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:05 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:09 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -101,12 +101,12 @@ CONFIG_MIPS_PB1500=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 # CONFIG_AU1X00_USB_DEVICE is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -133,7 +133,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -154,7 +153,6 @@ CONFIG_MMU=y
 #
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_OBSOLETE is not set
 CONFIG_PCMCIA=m
 CONFIG_CARDBUS=y
 
@@ -166,6 +164,7 @@ CONFIG_PD6729=m
 # CONFIG_I82092 is not set
 # CONFIG_TCIC is not set
 # CONFIG_PCMCIA_AU1X00 is not set
+CONFIG_PCCARD_NONSTATIC=m
 
 #
 # PCI Hotplug Support
@@ -212,11 +211,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -230,6 +231,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -359,8 +361,6 @@ CONFIG_IP_NF_CONNTRACK_MARK=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
@@ -522,6 +522,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -575,7 +576,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 
 #
@@ -611,6 +611,8 @@ CONFIG_SYNCLINK_CS=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -625,11 +627,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -777,6 +793,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -819,6 +840,10 @@ CONFIG_CRYPTO_MICHAEL_MIC=y
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/pb1550_defconfig linux-2.6.11-rc3/arch/mips/configs/pb1550_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/pb1550_defconfig	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/pb1550_defconfig	2005-02-03 02:55:15.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:05 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:09 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -101,12 +101,12 @@ CONFIG_MIPS_PB1550=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -133,7 +133,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -154,7 +153,6 @@ CONFIG_MMU=y
 #
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA_OBSOLETE is not set
 CONFIG_PCMCIA=m
 CONFIG_CARDBUS=y
 
@@ -166,6 +164,7 @@ CONFIG_PD6729=m
 # CONFIG_I82092 is not set
 # CONFIG_TCIC is not set
 # CONFIG_PCMCIA_AU1X00 is not set
+CONFIG_PCCARD_NONSTATIC=m
 
 #
 # PCI Hotplug Support
@@ -212,11 +211,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -230,6 +231,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -359,8 +361,6 @@ CONFIG_IP_NF_CONNTRACK_MARK=y
 # CONFIG_IP_NF_QUEUE is not set
 # CONFIG_IP_NF_IPTABLES is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
 
@@ -514,6 +514,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -567,7 +568,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 
 #
@@ -603,6 +603,8 @@ CONFIG_SYNCLINK_CS=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -617,11 +619,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -769,6 +785,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -811,6 +832,10 @@ CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/rm200_defconfig linux-2.6.11-rc3/arch/mips/configs/rm200_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/rm200_defconfig	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/rm200_defconfig	2005-02-03 02:55:23.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:06 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:09 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -87,16 +87,16 @@ CONFIG_KMOD=y
 CONFIG_SNI_RM200_PCI=y
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_GENERIC_ISA_DMA=y
 CONFIG_I8259=y
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_ARC32=y
-# CONFIG_FB is not set
 CONFIG_HAVE_STD_PC_SERIAL_PORT=y
 CONFIG_ARC_CONSOLE=y
 CONFIG_ARC_MEMORY=y
@@ -145,6 +145,21 @@ CONFIG_ISA=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+CONFIG_PCMCIA_PROBE=y
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -160,6 +175,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -223,12 +239,14 @@ CONFIG_PARIDE_ON26=m
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=m
 CONFIG_BLK_DEV_CRYPTOLOOP=m
 CONFIG_BLK_DEV_NBD=m
 CONFIG_BLK_DEV_SX8=m
 CONFIG_BLK_DEV_UB=m
 CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
@@ -243,6 +261,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -277,6 +296,7 @@ CONFIG_SCSI_CONSTANTS=y
 #
 CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 
 #
 # SCSI low-level drivers
@@ -326,14 +346,12 @@ CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 # CONFIG_SCSI_QLA22XX is not set
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_QLA6322 is not set
 # CONFIG_SCSI_SYM53C416 is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
@@ -495,8 +513,6 @@ CONFIG_IP_NF_TARGET_NOTRACK=m
 CONFIG_IP_NF_ARPTABLES=m
 CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 
 #
 # IPv6: Netfilter Configuration
@@ -550,6 +566,7 @@ CONFIG_BRIDGE_EBT_MARK_T=m
 CONFIG_BRIDGE_EBT_REDIRECT=m
 CONFIG_BRIDGE_EBT_SNAT=m
 CONFIG_BRIDGE_EBT_LOG=m
+# CONFIG_BRIDGE_EBT_ULOG is not set
 CONFIG_XFRM=y
 # CONFIG_XFRM_USER is not set
 
@@ -600,6 +617,7 @@ CONFIG_NET_CLS_FW=m
 CONFIG_NET_CLS_U32=m
 # CONFIG_CLS_U32_PERF is not set
 # CONFIG_NET_CLS_IND is not set
+# CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
 # CONFIG_NET_CLS_ACT is not set
@@ -690,7 +708,6 @@ CONFIG_PCNET32=y
 # CONFIG_CS89x0 is not set
 # CONFIG_DGRS is not set
 CONFIG_EEPRO100=m
-# CONFIG_EEPRO100_PIO is not set
 # CONFIG_E100 is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
@@ -786,6 +803,7 @@ CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 CONFIG_SERIO_PARKBD=m
 # CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
 CONFIG_SERIO_RAW=m
 
 #
@@ -858,7 +876,6 @@ CONFIG_RTC=m
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -873,7 +890,7 @@ CONFIG_RTC=m
 CONFIG_W1=m
 CONFIG_W1_MATROX=m
 CONFIG_W1_DS9490=m
-CONFIG_W1_DS9490R_BRIDGE=m
+CONFIG_W1_DS9490_BRIDGE=m
 CONFIG_W1_THERM=m
 CONFIG_W1_SMEM=m
 
@@ -894,6 +911,7 @@ CONFIG_W1_SMEM=m
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
@@ -901,6 +919,7 @@ CONFIG_W1_SMEM=m
 CONFIG_VGA_CONSOLE=y
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -931,6 +950,7 @@ CONFIG_USB_EHCI_HCD=m
 # CONFIG_USB_EHCI_ROOT_HUB_TT is not set
 CONFIG_USB_OHCI_HCD=m
 CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
 
 #
 # USB Device Class drivers
@@ -938,6 +958,10 @@ CONFIG_USB_UHCI_HCD=m
 CONFIG_USB_BLUETOOTH_TTY=m
 CONFIG_USB_ACM=m
 CONFIG_USB_PRINTER=m
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
 CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
 # CONFIG_USB_STORAGE_RW_DETECT is not set
@@ -979,7 +1003,6 @@ CONFIG_USB_XPAD=m
 #
 CONFIG_USB_MDC800=m
 CONFIG_USB_MICROTEK=m
-CONFIG_USB_HPUSBSCSI=m
 
 #
 # USB Multimedia devices
@@ -1044,6 +1067,7 @@ CONFIG_USB_SERIAL_IPAQ=m
 CONFIG_USB_SERIAL_IR=m
 CONFIG_USB_SERIAL_EDGEPORT=m
 CONFIG_USB_SERIAL_EDGEPORT_TI=m
+# CONFIG_USB_SERIAL_GARMIN is not set
 # CONFIG_USB_SERIAL_IPW is not set
 CONFIG_USB_SERIAL_KEYSPAN_PDA=m
 CONFIG_USB_SERIAL_KEYSPAN=m
@@ -1065,6 +1089,7 @@ CONFIG_USB_SERIAL_MCT_U232=m
 CONFIG_USB_SERIAL_PL2303=m
 CONFIG_USB_SERIAL_SAFE=m
 CONFIG_USB_SERIAL_SAFE_PADDED=y
+# CONFIG_USB_SERIAL_TI is not set
 CONFIG_USB_SERIAL_CYBERJACK=m
 CONFIG_USB_SERIAL_XIRCOM=m
 CONFIG_USB_SERIAL_OMNINET=m
@@ -1075,7 +1100,6 @@ CONFIG_USB_EZUSB=y
 #
 # CONFIG_USB_EMI62 is not set
 # CONFIG_USB_EMI26 is not set
-CONFIG_USB_TIGL=m
 CONFIG_USB_AUERSWALD=m
 CONFIG_USB_RIO500=m
 CONFIG_USB_LEGOTOWER=m
@@ -1084,6 +1108,7 @@ CONFIG_USB_LED=m
 CONFIG_USB_CYTHERM=m
 CONFIG_USB_PHIDGETKIT=m
 CONFIG_USB_PHIDGETSERVO=m
+# CONFIG_USB_IDMOUSE is not set
 CONFIG_USB_TEST=m
 
 #
@@ -1096,6 +1121,16 @@ CONFIG_USB_TEST=m
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=m
@@ -1179,7 +1214,6 @@ CONFIG_CRAMFS=m
 CONFIG_VXFS_FS=m
 CONFIG_HPFS_FS=m
 CONFIG_QNX4FS_FS=m
-# CONFIG_QNX4FS_RW is not set
 CONFIG_SYSV_FS=m
 CONFIG_UFS_FS=m
 # CONFIG_UFS_FS_WRITE is not set
@@ -1207,7 +1241,7 @@ CONFIG_SMB_FS=m
 CONFIG_CIFS=m
 # CONFIG_CIFS_STATS is not set
 # CONFIG_CIFS_XATTR is not set
-# CONFIG_CIFS_POSIX is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 CONFIG_NCP_FS=m
 CONFIG_NCPFS_PACKET_SIGNING=y
 CONFIG_NCPFS_IOCTL_LOCKING=y
@@ -1287,6 +1321,11 @@ CONFIG_NLS_KOI8_U=m
 CONFIG_NLS_UTF8=m
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -1329,6 +1368,10 @@ CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_TEST=m
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/sb1250-swarm_defconfig linux-2.6.11-rc3/arch/mips/configs/sb1250-swarm_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/sb1250-swarm_defconfig	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/sb1250-swarm_defconfig	2005-02-03 02:57:04.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:06 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:10 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -110,13 +110,13 @@ CONFIG_SIBYTE_CFE=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -143,8 +143,7 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_SIBYTE_DMA_PAGEOPS is not set
-# CONFIG_CPU_HAS_PREFETCH is not set
-CONFIG_VTAG_ICACHE=y
+CONFIG_CPU_HAS_PREFETCH=y
 CONFIG_SB1_PASS_1_WORKAROUNDS=y
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -166,6 +165,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -181,6 +194,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -204,10 +218,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=9220
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
@@ -223,6 +239,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -441,6 +458,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -454,6 +472,8 @@ CONFIG_SERIO_RAW=m
 CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_ROCKETPORT is not set
 # CONFIG_CYCLADES is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
 # CONFIG_SYNCLINK is not set
 # CONFIG_SYNCLINKMP is not set
 # CONFIG_N_HDLC is not set
@@ -491,7 +511,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -522,6 +541,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -536,11 +557,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -636,6 +671,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -679,6 +719,10 @@ CONFIG_CRYPTO_MICHAEL_MIC=y
 # CONFIG_CRYPTO_TEST is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/sead_defconfig linux-2.6.11-rc3/arch/mips/configs/sead_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/sead_defconfig	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/sead_defconfig	2005-02-03 02:55:53.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:06 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:10 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -77,13 +77,13 @@ CONFIG_MIPS_SEAD=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_BOARDS_GEN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -110,7 +110,6 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_VTAG_ICACHE is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -123,6 +122,19 @@ CONFIG_CPU_HAS_SYNC=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -138,6 +150,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -157,9 +170,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=18432
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
@@ -245,6 +260,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
 
 #
@@ -298,7 +314,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -328,12 +343,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -347,11 +364,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -425,6 +456,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -444,6 +480,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/tb0226_defconfig linux-2.6.11-rc3/arch/mips/configs/tb0226_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/tb0226_defconfig	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/tb0226_defconfig	2005-02-03 02:56:10.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:07 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:12 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -58,6 +58,7 @@ CONFIG_KMOD=y
 #
 # CONFIG_MACH_JAZZ is not set
 CONFIG_MACH_VR41XX=y
+# CONFIG_NEC_CMBVR4133 is not set
 # CONFIG_CASIO_E55 is not set
 # CONFIG_IBM_WORKPAD is not set
 CONFIG_TANBAC_TB0226=y
@@ -91,12 +92,12 @@ CONFIG_TANBAC_TB0226=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_FB=y
 
 #
 # CPU selection
@@ -134,6 +135,19 @@ CONFIG_HW_HAS_PCI=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +163,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -168,10 +183,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=m
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_NBD=m
 CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
@@ -186,6 +203,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -242,12 +260,12 @@ CONFIG_SCSI_CONSTANTS=y
 #
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 
 #
 # SCSI low-level drivers
 #
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 # CONFIG_SCSI_DEBUG is not set
 
 #
@@ -420,6 +438,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -473,7 +492,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -504,6 +522,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+CONFIG_FB=y
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_VIRTUAL is not set
@@ -519,6 +538,7 @@ CONFIG_DUMMY_CONSOLE=y
 # Logo configuration
 #
 # CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -542,11 +562,25 @@ CONFIG_SOUND=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -690,6 +724,11 @@ CONFIG_NLS_ISO8859_1=m
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -709,6 +748,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/tb0229_defconfig linux-2.6.11-rc3/arch/mips/configs/tb0229_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/tb0229_defconfig	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/tb0229_defconfig	2005-02-03 02:56:49.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:07 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:12 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -58,14 +58,16 @@ CONFIG_KMOD=y
 #
 # CONFIG_MACH_JAZZ is not set
 CONFIG_MACH_VR41XX=y
+# CONFIG_NEC_CMBVR4133 is not set
 # CONFIG_CASIO_E55 is not set
 # CONFIG_IBM_WORKPAD is not set
 # CONFIG_TANBAC_TB0226 is not set
 CONFIG_TANBAC_TB0229=y
+CONFIG_TANBAC_TB0219=y
 # CONFIG_VICTOR_MPC30X is not set
 # CONFIG_ZAO_CAPCELLA is not set
 CONFIG_PCI_VR41XX=y
-CONFIG_VRC4173=y
+# CONFIG_VRC4173 is not set
 # CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
@@ -93,13 +95,12 @@ CONFIG_VRC4173=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
-CONFIG_TANBAC_TB0219=y
 
 #
 # CPU selection
@@ -139,6 +140,20 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -154,6 +169,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -177,11 +193,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=m
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_NBD=m
 # CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 # CONFIG_BLK_DEV_INITRD is not set
 CONFIG_INITRAMFS_SOURCE=""
@@ -197,6 +215,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -315,7 +334,7 @@ CONFIG_DUMMY=m
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_NET_VENDOR_3COM is not set
@@ -325,7 +344,26 @@ CONFIG_NET_ETHERNET=y
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
-# CONFIG_NET_PCI is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+CONFIG_EEPRO100=y
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -338,6 +376,7 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
 # CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
 
 #
@@ -414,6 +453,7 @@ CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -468,7 +508,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -499,12 +538,14 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -519,11 +560,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -538,6 +593,7 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 CONFIG_JFS_FS=m
 # CONFIG_JFS_POSIX_ACL is not set
+# CONFIG_JFS_SECURITY is not set
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
 CONFIG_XFS_FS=y
@@ -680,11 +736,16 @@ CONFIG_NLS_ISO8859_1=m
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
 CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE=""
+CONFIG_CMDLINE="mem=64M console=ttyS0,38400 ip=bootp root=/dev/nfs"
 
 #
 # Security options
@@ -699,10 +760,14 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 CONFIG_CRC_CCITT=m
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=m
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/workpad_defconfig linux-2.6.11-rc3/arch/mips/configs/workpad_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/workpad_defconfig	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/workpad_defconfig	2005-02-03 02:56:33.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:12:08 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:12 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -58,6 +58,7 @@ CONFIG_KMOD=y
 #
 # CONFIG_MACH_JAZZ is not set
 CONFIG_MACH_VR41XX=y
+# CONFIG_NEC_CMBVR4133 is not set
 # CONFIG_CASIO_E55 is not set
 CONFIG_IBM_WORKPAD=y
 # CONFIG_TANBAC_TB0226 is not set
@@ -92,12 +93,12 @@ CONFIG_VRC4171=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -134,6 +135,20 @@ CONFIG_ISA=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+CONFIG_PCMCIA_PROBE=y
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +164,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -170,9 +186,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 # CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_XD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -186,6 +204,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -397,6 +416,7 @@ CONFIG_SERIO=y
 CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
 
 #
@@ -463,7 +483,6 @@ CONFIG_WATCHDOG=y
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -494,6 +513,7 @@ CONFIG_WATCHDOG=y
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
@@ -501,6 +521,7 @@ CONFIG_WATCHDOG=y
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -514,11 +535,25 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -615,6 +650,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -634,6 +674,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/configs/yosemite_defconfig linux-2.6.11-rc3/arch/mips/configs/yosemite_defconfig
--- linux-2.6.11-rc2-bk10/arch/mips/configs/yosemite_defconfig	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/configs/yosemite_defconfig	2005-02-03 02:56:48.000000000 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Fri Nov 26 00:00:39 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:13 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -80,14 +80,15 @@ CONFIG_PMC_YOSEMITE=y
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
+CONFIG_IRQ_CPU_RM9K=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_FB is not set
 
 #
 # CPU selection
@@ -134,6 +135,19 @@ CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -149,6 +163,7 @@ CONFIG_TRAD_SIGNALS=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
 
 #
@@ -172,10 +187,12 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -189,6 +206,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -401,7 +419,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_WATCHDOG is not set
 # CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
+CONFIG_GEN_RTC=y
+CONFIG_GEN_RTC_X=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -409,7 +428,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -440,6 +458,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Graphics support
 #
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -454,11 +474,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -548,6 +582,7 @@ CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_KOBJECT is not set
 # CONFIG_DEBUG_HIGHMEM is not set
 # CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 # CONFIG_DEBUG_STACK_USAGE is not set
@@ -567,6 +602,10 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_CRYPTO is not set
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
diff -purN linux-2.6.11-rc2-bk10/arch/mips/ddb5xxx/ddb5074/irq.c linux-2.6.11-rc3/arch/mips/ddb5xxx/ddb5074/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/ddb5xxx/ddb5074/irq.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/ddb5xxx/ddb5074/irq.c	2005-02-03 02:56:53.000000000 +0100
@@ -4,7 +4,6 @@
  *  Copyright (C) 2000 Geert Uytterhoeven <geert@sonycom.com>
  *                     Sony Software Development Center Europe (SDCE), Brussels
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/signal.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/ddb5xxx/ddb5074/setup.c linux-2.6.11-rc3/arch/mips/ddb5xxx/ddb5074/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/ddb5xxx/ddb5074/setup.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/ddb5xxx/ddb5074/setup.c	2005-02-03 02:56:33.000000000 +0100
@@ -4,7 +4,6 @@
  *  Copyright (C) 2000 Geert Uytterhoeven <geert@sonycom.com>
  *                     Sony Software Development Center Europe (SDCE), Brussels
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kbd_ll.h>
 #include <linux/kernel.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/ddb5xxx/ddb5476/setup.c linux-2.6.11-rc3/arch/mips/ddb5xxx/ddb5476/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/ddb5xxx/ddb5476/setup.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/ddb5xxx/ddb5476/setup.c	2005-02-03 02:56:11.000000000 +0100
@@ -4,7 +4,6 @@
  *  Copyright (C) 2000 Geert Uytterhoeven <geert@sonycom.com>
  *                     Sony Software Development Center Europe (SDCE), Brussels
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kbd_ll.h>
 #include <linux/kernel.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/dec/boot/decstation.c linux-2.6.11-rc3/arch/mips/dec/boot/decstation.c
--- linux-2.6.11-rc2-bk10/arch/mips/dec/boot/decstation.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/dec/boot/decstation.c	2005-02-03 02:55:53.000000000 +0100
@@ -1,7 +1,6 @@
 /*
  * arch/mips/dec/decstation.c
  */
-#include <linux/config.h>
 
 #define RELOC
 #define INITRD
diff -purN linux-2.6.11-rc2-bk10/arch/mips/dec/ioasic-irq.c linux-2.6.11-rc3/arch/mips/dec/ioasic-irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/dec/ioasic-irq.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/dec/ioasic-irq.c	2005-02-03 02:56:49.000000000 +0100
@@ -21,7 +21,7 @@
 #include <asm/dec/ioasic_ints.h>
 
 
-static spinlock_t ioasic_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(ioasic_lock);
 
 static int ioasic_irq_base;
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/dec/kn02-irq.c linux-2.6.11-rc3/arch/mips/dec/kn02-irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/dec/kn02-irq.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/dec/kn02-irq.c	2005-02-03 02:56:48.000000000 +0100
@@ -29,7 +29,7 @@
  * There is no default value -- it has to be initialized.
  */
 u32 cached_kn02_csr;
-spinlock_t kn02_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(kn02_lock);
 
 
 static int kn02_irq_base;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/dec/setup.c linux-2.6.11-rc3/arch/mips/dec/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/dec/setup.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/dec/setup.c	2005-02-03 02:55:36.000000000 +0100
@@ -8,7 +8,6 @@
  * Copyright (C) 1998 Harald Koerfgen
  * Copyright (C) 2000, 2001, 2002, 2003  Maciej W. Rozycki
  */
-#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/param.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/galileo-boards/ev96100/time.c linux-2.6.11-rc3/arch/mips/galileo-boards/ev96100/time.c
--- linux-2.6.11-rc2-bk10/arch/mips/galileo-boards/ev96100/time.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/galileo-boards/ev96100/time.c	2005-02-03 02:55:52.000000000 +0100
@@ -32,6 +32,7 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel_stat.h>
 #include <linux/module.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/gt64120/ev64120/irq.c linux-2.6.11-rc3/arch/mips/gt64120/ev64120/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/gt64120/ev64120/irq.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/gt64120/ev64120/irq.c	2005-02-03 02:56:33.000000000 +0100
@@ -119,7 +119,7 @@ void gt64120_irq_setup(void)
 	/* Sets the exception_handler array. */
 	set_except_vector(0, galileo_handle_int);
 
-	cli();
+	local_irq_disable();
 
 	/*
 	 * Enable timer.  Other interrupts will be enabled as they are
diff -purN linux-2.6.11-rc2-bk10/arch/mips/gt64120/momenco_ocelot/irq.c linux-2.6.11-rc3/arch/mips/gt64120/momenco_ocelot/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/gt64120/momenco_ocelot/irq.c	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/gt64120/momenco_ocelot/irq.c	2005-02-03 02:54:38.000000000 +0100
@@ -28,7 +28,6 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/kernel_stat.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/gt64120/momenco_ocelot/setup.c linux-2.6.11-rc3/arch/mips/gt64120/momenco_ocelot/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/gt64120/momenco_ocelot/setup.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/gt64120/momenco_ocelot/setup.c	2005-02-03 02:55:52.000000000 +0100
@@ -304,7 +304,7 @@ static void __init momenco_ocelot_setup(
 	}
 
 	/* Fix up the DiskOnChip mapping */
-	GT_WRITE(0x468, 0xfef73);
+	GT_WRITE(GT_DEV_B3_OFS, 0xfef73);
 }
 
 early_initcall(momenco_ocelot_setup);
@@ -322,8 +322,8 @@ static void __init setup_l3cache(unsigne
 	printk("Enabling L3 cache...");
 
 	/* Enable the L3 cache in the GT64120A's CPU Configuration register */
-	tmp =  GT_READ(0);
-	GT_WRITE(0, tmp | (1<<14));
+	tmp = GT_READ(GT_CPU_OFS);
+	GT_WRITE(GT_CPU_OFS, tmp | (1<<14));
 
 	/* Enable the L3 cache in the CPU */
 	set_c0_config(1<<12 /* CONF_TE */);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/ite-boards/generic/irq.c linux-2.6.11-rc3/arch/mips/ite-boards/generic/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/ite-boards/generic/irq.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/ite-boards/generic/irq.c	2005-02-03 02:55:53.000000000 +0100
@@ -32,7 +32,6 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/irq.h>
@@ -57,14 +56,6 @@
 #include <asm/it8172/it8172_int.h>
 #include <asm/it8172/it8172_dbg.h>
 
-#undef DEBUG_IRQ
-#ifdef DEBUG_IRQ
-/* note: prints function name for you */
-#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
-#else
-#define DPRINTK(fmt, args...)
-#endif
-
 /* revisit */
 #define EXT_IRQ0_TO_IP 2 /* IP 2 */
 #define EXT_IRQ5_TO_IP 7 /* IP 7 */
@@ -81,111 +72,50 @@ extern asmlinkage void it8172_IRQ(void);
 struct it8172_intc_regs volatile *it8172_hw0_icregs =
 	(struct it8172_intc_regs volatile *)(KSEG1ADDR(IT8172_PCI_IO_BASE + IT_INTC_BASE));
 
-/* Function for careful CP0 interrupt mask access */
-static inline void modify_cp0_intmask(unsigned clr_mask, unsigned set_mask)
-{
-        unsigned long status = read_c0_status();
-        status &= ~((clr_mask & 0xFF) << 8);
-        status |=   (set_mask & 0xFF) << 8;
-        write_c0_status(status);
-}
-
-static inline void mask_irq(unsigned int irq_nr)
-{
-        modify_cp0_intmask(irq_nr, 0);
-}
-
-static inline void unmask_irq(unsigned int irq_nr)
-{
-        modify_cp0_intmask(0, irq_nr);
-}
-
-void local_disable_irq(unsigned int irq_nr)
-{
-        unsigned long flags;
-
-        local_irq_save(flags);
-	disable_it8172_irq(irq_nr);
-        local_irq_restore(flags);
-}
-
-void local_enable_irq(unsigned int irq_nr)
+static void disable_it8172_irq(unsigned int irq_nr)
 {
-	unsigned long flags;
-
-        local_irq_save(flags);
-	enable_it8172_irq(irq_nr);
-        local_irq_restore(flags);
-}
-
-
-void disable_it8172_irq(unsigned int irq_nr)
-{
-	DPRINTK("disable_it8172_irq %d\n", irq_nr);
-
 	if ( (irq_nr >= IT8172_LPC_IRQ_BASE) && (irq_nr <= IT8172_SERIRQ_15)) {
 		/* LPC interrupt */
-		DPRINTK("DB lpc_mask  %x\n", it8172_hw0_icregs->lpc_mask);
 		it8172_hw0_icregs->lpc_mask |=
 			(1 << (irq_nr - IT8172_LPC_IRQ_BASE));
-		DPRINTK("DA lpc_mask  %x\n", it8172_hw0_icregs->lpc_mask);
-	}
-	else if ( (irq_nr >= IT8172_LB_IRQ_BASE) && (irq_nr <= IT8172_IOCHK_IRQ)) {
+	} else if ( (irq_nr >= IT8172_LB_IRQ_BASE) && (irq_nr <= IT8172_IOCHK_IRQ)) {
 		/* Local Bus interrupt */
-		DPRINTK("DB lb_mask  %x\n", it8172_hw0_icregs->lb_mask);
 		it8172_hw0_icregs->lb_mask |=
 			(1 << (irq_nr - IT8172_LB_IRQ_BASE));
-		DPRINTK("DA lb_mask  %x\n", it8172_hw0_icregs->lb_mask);
-	}
-	else if ( (irq_nr >= IT8172_PCI_DEV_IRQ_BASE) && (irq_nr <= IT8172_DMA_IRQ)) {
+	} else if ( (irq_nr >= IT8172_PCI_DEV_IRQ_BASE) && (irq_nr <= IT8172_DMA_IRQ)) {
 		/* PCI and other interrupts */
-		DPRINTK("DB pci_mask  %x\n", it8172_hw0_icregs->pci_mask);
 		it8172_hw0_icregs->pci_mask |=
 			(1 << (irq_nr - IT8172_PCI_DEV_IRQ_BASE));
-		DPRINTK("DA pci_mask  %x\n", it8172_hw0_icregs->pci_mask);
-	}
-	else if ( (irq_nr >= IT8172_NMI_IRQ_BASE) && (irq_nr <= IT8172_POWER_NMI_IRQ)) {
+	} else if ( (irq_nr >= IT8172_NMI_IRQ_BASE) && (irq_nr <= IT8172_POWER_NMI_IRQ)) {
 		/* NMI interrupts */
-		DPRINTK("DB nmi_mask  %x\n", it8172_hw0_icregs->nmi_mask);
 		it8172_hw0_icregs->nmi_mask |=
 			(1 << (irq_nr - IT8172_NMI_IRQ_BASE));
-		DPRINTK("DA nmi_mask  %x\n", it8172_hw0_icregs->nmi_mask);
-	}
-	else {
+	} else {
 		panic("disable_it8172_irq: bad irq %d", irq_nr);
 	}
 }
 
-void enable_it8172_irq(unsigned int irq_nr)
+static void enable_it8172_irq(unsigned int irq_nr)
 {
-	DPRINTK("enable_it8172_irq %d\n", irq_nr);
 	if ( (irq_nr >= IT8172_LPC_IRQ_BASE) && (irq_nr <= IT8172_SERIRQ_15)) {
 		/* LPC interrupt */
-		DPRINTK("EB before lpc_mask  %x\n", it8172_hw0_icregs->lpc_mask);
 		it8172_hw0_icregs->lpc_mask &=
 			~(1 << (irq_nr - IT8172_LPC_IRQ_BASE));
-		DPRINTK("EA after lpc_mask  %x\n", it8172_hw0_icregs->lpc_mask);
 	}
 	else if ( (irq_nr >= IT8172_LB_IRQ_BASE) && (irq_nr <= IT8172_IOCHK_IRQ)) {
 		/* Local Bus interrupt */
-		DPRINTK("EB lb_mask  %x\n", it8172_hw0_icregs->lb_mask);
 		it8172_hw0_icregs->lb_mask &=
 			~(1 << (irq_nr - IT8172_LB_IRQ_BASE));
-		DPRINTK("EA lb_mask  %x\n", it8172_hw0_icregs->lb_mask);
 	}
 	else if ( (irq_nr >= IT8172_PCI_DEV_IRQ_BASE) && (irq_nr <= IT8172_DMA_IRQ)) {
 		/* PCI and other interrupts */
-		DPRINTK("EB pci_mask  %x\n", it8172_hw0_icregs->pci_mask);
 		it8172_hw0_icregs->pci_mask &=
 			~(1 << (irq_nr - IT8172_PCI_DEV_IRQ_BASE));
-		DPRINTK("EA pci_mask  %x\n", it8172_hw0_icregs->pci_mask);
 	}
 	else if ( (irq_nr >= IT8172_NMI_IRQ_BASE) && (irq_nr <= IT8172_POWER_NMI_IRQ)) {
 		/* NMI interrupts */
-		DPRINTK("EB nmi_mask  %x\n", it8172_hw0_icregs->nmi_mask);
 		it8172_hw0_icregs->nmi_mask &=
 			~(1 << (irq_nr - IT8172_NMI_IRQ_BASE));
-		DPRINTK("EA nmi_mask  %x\n", it8172_hw0_icregs->nmi_mask);
 	}
 	else {
 		panic("enable_it8172_irq: bad irq %d", irq_nr);
@@ -243,7 +173,7 @@ void enable_cpu_timer(void)
         unsigned long flags;
 
         local_irq_save(flags);
-	unmask_irq(1<<EXT_IRQ5_TO_IP); /* timer interrupt */
+	set_c0_status(0x100 << EXT_IRQ5_TO_IP);
         local_irq_restore(flags);
 }
 
@@ -305,7 +235,6 @@ void mips_spurious_interrupt(struct pt_r
 	cause = read_c0_cause();
 	printk("status %x cause %x\n", status, cause);
 	printk("epc %x badvaddr %x \n", regs->cp0_epc, regs->cp0_badvaddr);
-//	while(1);
 #endif
 }
 
@@ -326,9 +255,7 @@ void it8172_hw0_irqdispatch(struct pt_re
 			status >>= 1;
 		}
 		irq += IT8172_PCI_DEV_IRQ_BASE;
-		//printk("pci int %d\n", irq);
-	}
-	else if (intstatus & 0x1) {
+	} else if (intstatus & 0x1) {
 		/* Local Bus interrupt */
 		irq = 0;
 		status |= it8172_hw0_icregs->lb_req;
@@ -337,9 +264,7 @@ void it8172_hw0_irqdispatch(struct pt_re
 			status >>= 1;
 		}
 		irq += IT8172_LB_IRQ_BASE;
-		//printk("lb int %d\n", irq);
-	}
-	else if (intstatus & 0x2) {
+	} else if (intstatus & 0x2) {
 		/* LPC interrupt */
 		/* Since some lpc interrupts are edge triggered,
 		 * we could lose an interrupt this way because
@@ -353,7 +278,6 @@ void it8172_hw0_irqdispatch(struct pt_re
 			status >>= 1;
 		}
 		irq += IT8172_LPC_IRQ_BASE;
-		//printk("LPC int %d\n", irq);
 	} else
 		return;
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/jazz/irq.c linux-2.6.11-rc3/arch/mips/jazz/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/jazz/irq.c	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/jazz/irq.c	2005-02-03 02:54:39.000000000 +0100
@@ -17,7 +17,7 @@
 
 extern asmlinkage void jazz_handle_int(void);
 
-static spinlock_t r4030_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(r4030_lock);
 
 static void enable_r4030_irq(unsigned int irq)
 {
diff -purN linux-2.6.11-rc2-bk10/arch/mips/jazz/jazzdma.c linux-2.6.11-rc3/arch/mips/jazz/jazzdma.c
--- linux-2.6.11-rc2-bk10/arch/mips/jazz/jazzdma.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/jazz/jazzdma.c	2005-02-03 02:56:53.000000000 +0100
@@ -29,7 +29,7 @@
 
 static unsigned long vdma_pagetable_start;
 
-static spinlock_t vdma_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(vdma_lock);
 
 /*
  * Debug stuff
diff -purN linux-2.6.11-rc2-bk10/arch/mips/jmr3927/rbhma3100/irq.c linux-2.6.11-rc3/arch/mips/jmr3927/rbhma3100/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/jmr3927/rbhma3100/irq.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/jmr3927/rbhma3100/irq.c	2005-02-03 02:55:50.000000000 +0100
@@ -89,38 +89,10 @@ static unsigned char irc_level[TX3927_NU
 	6, 6, 6			/* TMR */
 };
 
-static inline void mask_irq(unsigned int irq_nr)
-{
-	struct tb_irq_space* sp;
-	for (sp = tb_irq_spaces; sp; sp = sp->next) {
-		if (sp->start_irqno <= irq_nr &&
-		    irq_nr < sp->start_irqno + sp->nr_irqs) {
-			if (sp->mask_func)
-				sp->mask_func(irq_nr - sp->start_irqno,
-					      sp->space_id);
-			break;
-		}
-	}
-}
-
-static inline void unmask_irq(unsigned int irq_nr)
-{
-	struct tb_irq_space* sp;
-	for (sp = tb_irq_spaces; sp; sp = sp->next) {
-		if (sp->start_irqno <= irq_nr &&
-		    irq_nr < sp->start_irqno + sp->nr_irqs) {
-			if (sp->unmask_func)
-				sp->unmask_func(irq_nr - sp->start_irqno,
-						sp->space_id);
-			break;
-		}
-	}
-}
-
 static void jmr3927_irq_disable(unsigned int irq_nr);
 static void jmr3927_irq_enable(unsigned int irq_nr);
 
-static spinlock_t jmr3927_irq_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(jmr3927_irq_lock);
 
 static unsigned int jmr3927_irq_startup(unsigned int irq)
 {
@@ -133,9 +105,8 @@ static unsigned int jmr3927_irq_startup(
 
 static void jmr3927_irq_ack(unsigned int irq)
 {
-	if (irq == JMR3927_IRQ_IRC_TMR0) {
+	if (irq == JMR3927_IRQ_IRC_TMR0)
 		jmr3927_tmrptr->tisr = 0;       /* ack interrupt */
-	}
 
 	jmr3927_irq_disable(irq);
 }
@@ -147,19 +118,37 @@ static void jmr3927_irq_end(unsigned int
 
 static void jmr3927_irq_disable(unsigned int irq_nr)
 {
+	struct tb_irq_space* sp;
 	unsigned long flags;
 
 	spinlock_irqsave(&jmr3927_irq_lock, flags);
-	mask_irq(irq_nr);
+	for (sp = tb_irq_spaces; sp; sp = sp->next) {
+		if (sp->start_irqno <= irq_nr &&
+		    irq_nr < sp->start_irqno + sp->nr_irqs) {
+			if (sp->mask_func)
+				sp->mask_func(irq_nr - sp->start_irqno,
+					      sp->space_id);
+			break;
+		}
+	}
 	spinlock_irqrestore(&jmr3927_irq_lock, flags);
 }
 
 static void jmr3927_irq_enable(unsigned int irq_nr)
 {
+	struct tb_irq_space* sp;
 	unsigned long flags;
 
 	spinlock_irqsave(&jmr3927_irq_lock, flags);
-	unmask_irq(irq_nr);
+	for (sp = tb_irq_spaces; sp; sp = sp->next) {
+		if (sp->start_irqno <= irq_nr &&
+		    irq_nr < sp->start_irqno + sp->nr_irqs) {
+			if (sp->unmask_func)
+				sp->unmask_func(irq_nr - sp->start_irqno,
+						sp->space_id);
+			break;
+		}
+	}
 	spinlock_irqrestore(&jmr3927_irq_lock, flags);
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/jmr3927/rbhma3100/setup.c linux-2.6.11-rc3/arch/mips/jmr3927/rbhma3100/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/jmr3927/rbhma3100/setup.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/jmr3927/rbhma3100/setup.c	2005-02-03 02:56:48.000000000 +0100
@@ -108,7 +108,7 @@ static inline void do_reset(void)
 
 static void jmr3927_machine_restart(char *command)
 {
-	cli();
+	local_irq_disable();
 	puts("Rebooting...");
 	do_reset();
 }
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/Makefile linux-2.6.11-rc3/arch/mips/kernel/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/Makefile	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/Makefile	2005-02-03 02:55:50.000000000 +0100
@@ -8,6 +8,9 @@ obj-y		+= cpu-probe.o branch.o entry.o g
 		   ptrace.o reset.o semaphore.o setup.o signal.o syscall.o \
 		   time.o traps.o unaligned.o
 
+binfmt_irix-objs	:= irixelf.o irixinv.o irixioctl.o irixsig.o	\
+			   irix5sys.o sysirix.o
+
 ifdef CONFIG_MODULES
 obj-y				+= mips_ksyms.o module.o
 obj-$(CONFIG_MIPS32)		+= module-elf32.o
@@ -35,15 +38,16 @@ obj-$(CONFIG_CPU_R6000)		+= r6000_fpu.o 
 
 obj-$(CONFIG_SMP)		+= smp.o
 
+obj-$(CONFIG_NO_ISA)		+= dma-no-isa.o
 obj-$(CONFIG_I8259)		+= i8259.o
 obj-$(CONFIG_IRQ_CPU)		+= irq_cpu.o
 obj-$(CONFIG_IRQ_CPU_RM7K)	+= irq-rm7000.o
+obj-$(CONFIG_IRQ_CPU_RM9K)	+= irq-rm9000.o
 obj-$(CONFIG_IRQ_MV64340)	+= irq-mv6434x.o
 
 obj-$(CONFIG_MIPS32)		+= scall32-o32.o
 obj-$(CONFIG_MIPS64)		+= scall64-64.o
-obj-$(CONFIG_BINFMT_IRIX)	+= irixelf.o irixioctl.o irixsig.o sysirix.o \
-				   irixinv.o
+obj-$(CONFIG_BINFMT_IRIX)	+= binfmt_irix.o
 obj-$(CONFIG_MIPS32_COMPAT)	+= ioctl32.o linux32.o signal32.o
 obj-$(CONFIG_MIPS32_N32)	+= binfmt_elfn32.o scall64-n32.o signal_n32.o
 obj-$(CONFIG_MIPS32_O32)	+= binfmt_elfo32.o scall64-o32.o ptrace32.o
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/irix5sys.S linux-2.6.11-rc3/arch/mips/kernel/irix5sys.S
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/irix5sys.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/irix5sys.S	2005-02-03 02:54:39.000000000 +0100
@@ -0,0 +1,1041 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * 32-bit IRIX5 ABI system call table derived from original file 'irix5sys.h'
+ * created by David S. Miller.
+ *
+ * Copyright (C) 1996 - 2004 David S. Miller <dm@engr.sgi.com>
+ * Copyright (C) 2004 Steven J. Hill <sjhill@realitydiluted.com>
+ */
+#include <asm/asm.h>
+
+	/*
+	 * Key:
+	 *         V == Valid and should work as expected for most cases.
+	 *        HV == Half Valid, some things will work, some likely will not
+	 *        IV == InValid, certainly will not work at all yet
+	 *        ?V == ?'ably Valid, I have not done enough looking into it
+	 *        DC == Don't Care, a rats ass we couldn't give
+	 */
+
+	.macro	irix5syscalltable
+
+	sys	sys_syscall	0	/* 1000  sysindir()	       V*/
+	sys	sys_exit	1	/* 1001  exit()		       V*/
+	sys	sys_fork	0	/* 1002  fork()		       V*/
+	sys	sys_read	3	/* 1003  read()		       V*/
+	sys	sys_write	3	/* 1004  write()	       V*/
+	sys	sys_open	3	/* 1005  open()		       V*/
+	sys	sys_close	1	/* 1006  close()	       V*/
+	sys	irix_unimp	0	/* 1007  (XXX IRIX 4 wait)     V*/
+	sys	sys_creat	2	/* 1008  creat()	       V*/
+	sys	sys_link	2	/* 1009  link()		       V*/
+	sys	sys_unlink	1	/* 1010  unlink()	       V*/
+	sys	irix_exec	0	/* 1011  exec()		       V*/
+	sys	sys_chdir	1	/* 1012  chdir()	       V*/
+	sys	irix_gtime	0	/* 1013  time()		       V*/
+	sys	irix_unimp	0	/* 1014  (XXX IRIX 4 mknod)    V*/
+	sys	sys_chmod	2	/* 1015  chmod()	       V*/
+	sys	sys_chown	3	/* 1016  chown()	       V*/
+	sys	irix_brk	1	/* 1017  break()	       V*/
+	sys	irix_unimp	0	/* 1018  (XXX IRIX 4 stat)     V*/
+	sys	sys_lseek	3	/* 1019  lseek()     XXX64bit HV*/
+	sys	irix_getpid	0	/* 1020  getpid()	       V*/
+	sys	irix_mount	6	/* 1021  mount()	      IV*/
+	sys	sys_umount	1	/* 1022  umount()	       V*/
+	sys	sys_setuid	1	/* 1023  setuid()	       V*/
+	sys	irix_getuid	0	/* 1024  getuid()	       V*/
+	sys	irix_stime	1	/* 1025  stime()	       V*/
+	sys	irix_unimp	4	/* 1026  XXX ptrace()	      IV*/
+	sys	irix_alarm	1	/* 1027  alarm()	       V*/
+	sys	irix_unimp	0	/* 1028  (XXX IRIX 4 fstat)    V*/
+	sys	irix_pause	0	/* 1029  pause()	       V*/
+	sys	sys_utime	2	/* 1030  utime()	       V*/
+	sys	irix_unimp	0	/* 1031  nuthin'	       V*/
+	sys	irix_unimp	0	/* 1032  nobody home man...    V*/
+	sys	sys_access	2	/* 1033  access()	       V*/
+	sys	sys_nice	1	/* 1034  nice()		       V*/
+	sys	irix_statfs	2	/* 1035  statfs()	       V*/
+	sys	sys_sync	0	/* 1036  sync()		       V*/
+	sys	sys_kill	2	/* 1037  kill()		       V*/
+	sys	irix_fstatfs	2	/* 1038  fstatfs()	       V*/
+	sys	irix_setpgrp	1	/* 1039  setpgrp()	       V*/
+	sys	irix_syssgi	0	/* 1040  syssgi()	      HV*/
+	sys	sys_dup		1	/* 1041  dup()		       V*/
+	sys	sys_pipe	0	/* 1042  pipe()		       V*/
+	sys	irix_times	1	/* 1043  times()	       V*/
+	sys	irix_unimp	0	/* 1044  XXX profil()	      IV*/
+	sys	irix_unimp	0	/* 1045  XXX lock()	      IV*/
+	sys	sys_setgid	1	/* 1046  setgid()	       V*/
+	sys	irix_getgid	0	/* 1047  getgid()	       V*/
+	sys	irix_unimp	0	/* 1048  (XXX IRIX 4 ssig)     V*/
+	sys	irix_msgsys	6	/* 1049  sys_msgsys	       V*/
+	sys	sys_sysmips	4	/* 1050  sysmips()	      HV*/
+	sys	irix_unimp	0	/* 1051	 XXX sysacct()	      IV*/
+	sys	irix_shmsys	5	/* 1052  sys_shmsys	       V*/
+	sys	irix_semsys	0	/* 1053  sys_semsys	       V*/
+	sys	irix_ioctl	3	/* 1054  ioctl()	      HV*/
+	sys	irix_uadmin	0	/* 1055  XXX sys_uadmin()     HC*/
+	sys	irix_sysmp	0	/* 1056  sysmp()	      HV*/
+	sys	irix_utssys	4	/* 1057  sys_utssys()	      HV*/
+	sys	irix_unimp	0	/* 1058  nada enchilada	       V*/
+	sys	irix_exece	0	/* 1059  exece()	       V*/
+	sys	sys_umask	1	/* 1060  umask()	       V*/
+	sys	sys_chroot	1	/* 1061  chroot()	       V*/
+	sys	irix_fcntl	3	/* 1062  fcntl()	      ?V*/
+	sys	irix_ulimit	2	/* 1063  ulimit()	      HV*/
+	sys	irix_unimp	0	/* 1064  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1065  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1066  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1067  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1068  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1069  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1070  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1071  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1072  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1073  XXX AFS shit	      DC*/
+	sys	irix_unimp	0	/* 1074  nuttin'	       V*/
+	sys	irix_unimp	0	/* 1075  XXX sys_getrlimit64()IV*/
+	sys	irix_unimp	0	/* 1076  XXX sys_setrlimit64()IV*/
+	sys	sys_nanosleep	2	/* 1077  nanosleep()	       V*/
+	sys	irix_lseek64	5	/* 1078  lseek64()	      ?V*/
+	sys	sys_rmdir	1	/* 1079  rmdir()	       V*/
+	sys	sys_mkdir	2	/* 1080  mkdir()	       V*/
+	sys	sys_getdents	3	/* 1081  getdents()	       V*/
+	sys	irix_sginap	1	/* 1082  sys_sginap()	       V*/
+	sys	irix_sgikopt	3	/* 1083  sys_sgikopt()	      DC*/
+	sys	sys_sysfs	3	/* 1084  sysfs()	      ?V*/
+	sys	irix_unimp	0	/* 1085  XXX sys_getmsg()     DC*/
+	sys	irix_unimp	0	/* 1086  XXX sys_putmsg()     DC*/
+	sys	sys_poll	3	/* 1087  poll()	               V*/
+	sys	irix_sigreturn	0	/* 1088  sigreturn()	      ?V*/
+	sys	sys_accept	3	/* 1089  accept()	       V*/
+	sys	sys_bind	3	/* 1090  bind()		       V*/
+	sys	sys_connect	3	/* 1091  connect()	       V*/
+	sys	irix_gethostid	0	/* 1092  sys_gethostid()      ?V*/
+	sys	sys_getpeername	3	/* 1093  getpeername()	       V*/
+	sys	sys_getsockname	3	/* 1094  getsockname()	       V*/
+	sys	sys_getsockopt	5	/* 1095  getsockopt()	       V*/
+	sys	sys_listen	2	/* 1096  listen()	       V*/
+	sys	sys_recv	4	/* 1097  recv()		       V*/
+	sys	sys_recvfrom	6	/* 1098  recvfrom()	       V*/
+	sys	sys_recvmsg	3	/* 1099  recvmsg()	       V*/
+	sys	sys_select	5	/* 1100  select()	       V*/
+	sys	sys_send	4	/* 1101  send()		       V*/
+	sys	sys_sendmsg	3	/* 1102  sendmsg()	       V*/
+	sys	sys_sendto	6	/* 1103  sendto()	       V*/
+	sys	irix_sethostid	1	/* 1104  sys_sethostid()      ?V*/
+	sys	sys_setsockopt	5	/* 1105  setsockopt()	       V*/
+	sys	sys_shutdown	2	/* 1106  shutdown()	      ?V*/
+	sys	irix_socket	3	/* 1107  socket()	       V*/
+	sys	sys_gethostname	2	/* 1108  sys_gethostname()    ?V*/
+	sys	sys_sethostname	2	/* 1109  sethostname()	      ?V*/
+	sys	irix_getdomainname 2	/* 1110  sys_getdomainname()  ?V*/
+	sys	sys_setdomainname 2	/* 1111  setdomainname()      ?V*/
+	sys	sys_truncate	2	/* 1112  truncate()	       V*/
+	sys	sys_ftruncate	2	/* 1113  ftruncate()	       V*/
+	sys	sys_rename	2	/* 1114  rename()	       V*/
+	sys	sys_symlink	2	/* 1115  symlink()	       V*/
+	sys	sys_readlink	3	/* 1116  readlink()	       V*/
+	sys	irix_unimp	0	/* 1117  XXX IRIX 4 lstat()   DC*/
+	sys	irix_unimp	0	/* 1118  nothin'	       V*/
+	sys	irix_unimp	0	/* 1119  XXX nfs_svc()	      DC*/
+	sys	irix_unimp	0	/* 1120  XXX nfs_getfh()      DC*/
+	sys	irix_unimp	0	/* 1121  XXX async_daemon()   DC*/
+	sys	irix_unimp	0	/* 1122  XXX exportfs()	      DC*/
+	sys	sys_setregid	2	/* 1123  setregid()	       V*/
+	sys	sys_setreuid	2	/* 1124  setreuid()	       V*/
+	sys	sys_getitimer	2	/* 1125  getitimer()	       V*/
+	sys	sys_setitimer	3	/* 1126  setitimer()	       V*/
+	sys	irix_unimp	1	/* 1127  XXX adjtime() 	      IV*/
+	sys	irix_gettimeofday 1	/* 1128  gettimeofday()	       V*/
+	sys	irix_unimp	0	/* 1129  XXX sproc()	      IV*/
+	sys	irix_prctl	0	/* 1130  prctl()	      HV*/
+	sys	irix_unimp	0	/* 1131  XXX procblk()	      IV*/
+	sys	irix_unimp	0	/* 1132  XXX sprocsp()	      IV*/
+	sys	irix_unimp	0	/* 1133  XXX sgigsc()	      IV*/
+	sys	irix_mmap32	6	/* 1134  mmap()	   XXXflags?  ?V*/
+	sys	sys_munmap	2	/* 1135  munmap()	       V*/
+	sys	sys_mprotect	3	/* 1136  mprotect()	       V*/
+	sys	sys_msync	4	/* 1137  msync()	       V*/
+	sys	irix_madvise	3	/* 1138  madvise()	      DC*/
+	sys	irix_pagelock	3	/* 1139  pagelock()	      IV*/
+	sys	irix_getpagesize 0	/* 1140  getpagesize()         V*/
+	sys	irix_quotactl	0	/* 1141  quotactl()	       V*/
+	sys	irix_unimp	0	/* 1142  nobody home man       V*/
+	sys	sys_getpgid	1	/* 1143  BSD getpgrp()	       V*/
+	sys	irix_BSDsetpgrp 2	/* 1143  BSD setpgrp()	       V*/
+	sys	sys_vhangup	0	/* 1144  vhangup()	       V*/
+	sys	sys_fsync	1	/* 1145  fsync()	       V*/
+	sys	sys_fchdir	1	/* 1146  fchdir()	       V*/
+	sys	sys_getrlimit	2	/* 1147  getrlimit()	      ?V*/
+	sys	sys_setrlimit	2	/* 1148  setrlimit()	      ?V*/
+	sys	sys_cacheflush	3	/* 1150  cacheflush()	      HV*/
+	sys	sys_cachectl	3	/* 1151  cachectl()	      HV*/
+	sys	sys_fchown	3	/* 1152  fchown()	      ?V*/
+	sys	sys_fchmod	2	/* 1153  fchmod()	      ?V*/
+	sys	irix_unimp	0	/* 1154  XXX IRIX 4 wait3()    V*/
+	sys	sys_socketpair	4	/* 1155  socketpair()	       V*/
+	sys	irix_systeminfo	3	/* 1156  systeminfo()	      IV*/
+	sys	irix_uname	1	/* 1157  uname()	      IV*/
+	sys	irix_xstat	3	/* 1158  xstat()	       V*/
+	sys	irix_lxstat	3	/* 1159  lxstat()	       V*/
+	sys	irix_fxstat	3	/* 1160  fxstat()	       V*/
+	sys	irix_xmknod	0	/* 1161  xmknod()	      ?V*/
+	sys	irix_sigaction	4	/* 1162  sigaction()	      ?V*/
+	sys	irix_sigpending	1	/* 1163  sigpending()	      ?V*/
+	sys	irix_sigprocmask 3	/* 1164  sigprocmask()	      ?V*/
+	sys	irix_sigsuspend	0	/* 1165  sigsuspend()	      ?V*/
+	sys	irix_sigpoll_sys 3	/* 1166  sigpoll_sys()	      IV*/
+	sys	irix_swapctl	2	/* 1167  swapctl()	      IV*/
+	sys	irix_getcontext	0	/* 1168  getcontext()	      HV*/
+	sys	irix_setcontext	0	/* 1169  setcontext()	      HV*/
+	sys	irix_waitsys	5	/* 1170  waitsys()	      IV*/
+	sys	irix_sigstack	2	/* 1171  sigstack()	      HV*/
+	sys	irix_sigaltstack 2	/* 1172  sigaltstack()	      HV*/
+	sys	irix_sigsendset	2	/* 1173  sigsendset()	      IV*/
+	sys	irix_statvfs	2	/* 1174  statvfs()	       V*/
+	sys	irix_fstatvfs	2	/* 1175  fstatvfs()	       V*/
+	sys	irix_unimp	0	/* 1176  XXX getpmsg()	      DC*/
+	sys	irix_unimp	0	/* 1177  XXX putpmsg()	      DC*/
+	sys	sys_lchown	3	/* 1178  lchown()	       V*/
+	sys	irix_priocntl	0	/* 1179  priocntl()	      DC*/
+	sys	irix_sigqueue	4	/* 1180  sigqueue()	      IV*/
+	sys	sys_readv	3	/* 1181  readv()	       V*/
+	sys	sys_writev	3	/* 1182  writev()	       V*/
+	sys	irix_truncate64 4	/* 1183  truncate64() XX32bit HV*/
+	sys	irix_ftruncate64 4	/* 1184  ftruncate64()XX32bit HV*/
+	sys	irix_mmap64	0	/* 1185  mmap64()     XX32bit HV*/
+	sys	irix_dmi	0	/* 1186  dmi()		      DC*/
+	sys	irix_pread	6	/* 1187  pread()	      IV*/
+	sys	irix_pwrite	6	/* 1188  pwrite()	      IV*/
+	sys	sys_fsync	1	/* 1189  fdatasync()  XXPOSIX HV*/
+	sys	irix_sgifastpath 7	/* 1190  sgifastpath() WHEEE  IV*/
+	sys	irix_unimp	0	/* 1191  XXX attr_get()	      DC*/
+	sys	irix_unimp	0	/* 1192  XXX attr_getf()      DC*/
+	sys	irix_unimp	0	/* 1193  XXX attr_set()	      DC*/
+	sys	irix_unimp	0	/* 1194  XXX attr_setf()      DC*/
+	sys	irix_unimp	0	/* 1195  XXX attr_remove()    DC*/
+	sys	irix_unimp	0	/* 1196  XXX attr_removef()   DC*/
+	sys	irix_unimp	0	/* 1197  XXX attr_list()      DC*/
+	sys	irix_unimp	0	/* 1198  XXX attr_listf()     DC*/
+	sys	irix_unimp	0	/* 1199  XXX attr_multi()     DC*/
+	sys	irix_unimp	0	/* 1200  XXX attr_multif()    DC*/
+	sys	irix_statvfs64	2	/* 1201  statvfs64()	       V*/
+	sys	irix_fstatvfs64	2	/* 1202  fstatvfs64()	       V*/
+	sys	irix_getmountid	2	/* 1203  getmountid()XXXfsids HV*/
+	sys	irix_nsproc	5	/* 1204  nsproc()	      IV*/
+	sys	irix_getdents64 3	/* 1205  getdents64()	      HV*/
+	sys	irix_unimp	0	/* 1206  XXX DFS garbage      DC*/
+	sys	irix_ngetdents	4	/* 1207  ngetdents() XXXeop   HV*/
+	sys	irix_ngetdents64 4	/* 1208  ngetdents64() XXXeop HV*/
+	sys	irix_unimp	0	/* 1209  nothin'	       V*/
+	sys	irix_unimp	0	/* 1210  XXX pidsprocsp()	*/
+	sys	irix_unimp	0	/* 1211  XXX rexec()		*/
+	sys	irix_unimp	0	/* 1212  XXX timer_create()	*/
+	sys	irix_unimp	0	/* 1213  XXX timer_delete()	*/
+	sys	irix_unimp	0	/* 1214  XXX timer_settime()	*/
+	sys	irix_unimp	0	/* 1215  XXX timer_gettime()	*/
+	sys	irix_unimp	0	/* 1216  XXX timer_setoverrun()	*/
+	sys	sys_sched_rr_get_interval 2		/* 1217  sched_rr_get_interval()V*/
+	sys	sys_sched_yield	0	/* 1218  sched_yield()	       V*/
+	sys	sys_sched_getscheduler 1 /* 1219  sched_getscheduler()  V*/
+	sys	sys_sched_setscheduler 3 /* 1220  sched_setscheduler()  V*/
+	sys	sys_sched_getparam 2	/* 1221  sched_getparam()      V*/
+	sys	sys_sched_setparam 2	/* 1222  sched_setparam()      V*/
+	sys	irix_unimp	0	/* 1223  XXX usync_cntl()	*/
+	sys	irix_unimp	0	/* 1224  XXX psema_cntl()	*/
+	sys	irix_unimp	0	/* 1225  XXX restartreturn()	*/
+
+	/* Just to pad things out nicely. */
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+	sys	irix_unimp	0
+
+	.endm
+
+	/*
+	 * Pre-compute the number of _instruction_ bytes needed to load
+	 * or store the arguments 6-8. Negative values are ignored.
+	 */
+	.macro  sys function, nargs
+	PTR	\function
+	LONG	(\nargs << 2) - (5 << 2)
+	.endm
+
+	.align	4
+EXPORT(sys_call_table_irix5)
+	irix5syscalltable
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/irix5sys.h linux-2.6.11-rc3/arch/mips/kernel/irix5sys.h
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/irix5sys.h	2005-01-22 02:46:46.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/irix5sys.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1029 +0,0 @@
-/*
- * irix5sys.h: 32-bit IRIX5 ABI system call table.
- *
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- */
-
-/* This file is being included twice - once to build a list of all
- * syscalls and once to build a table of how many arguments each syscall
- * accepts.  Syscalls that receive a pointer to the saved registers are
- * marked as having zero arguments.
- */
-#include <linux/config.h>
-
-/* Keys:
- *         V == Valid and should work as expected for most cases.
- *        HV == Half Valid, some things will work, some likely will not
- *        IV == InValid, certainly will not work at all yet
- *        ?V == ?'ably Valid, I have not done enough looking into it
- *        DC == Don't Care, a rats ass we couldn't give
- */
-
-#ifdef CONFIG_BINFMT_IRIX
-	sys	sys_syscall	0	/* 1000  sysindir()	       V*/
-	sys	sys_exit	1	/* 1001  exit()		       V*/
-	sys	sys_fork	0	/* 1002  fork()		       V*/
-	sys	sys_read	3	/* 1003  read()		       V*/
-	sys	sys_write	3	/* 1004  write()	       V*/
-	sys	sys_open	3	/* 1005  open()		       V*/
-	sys	sys_close	1	/* 1006  close()	       V*/
-	sys	irix_unimp	0	/* 1007  (XXX IRIX 4 wait)     V*/
-	sys	sys_creat	2	/* 1008  creat()	       V*/
-	sys	sys_link	2	/* 1009  link()		       V*/
-	sys	sys_unlink	1	/* 1010  unlink()	       V*/
-	sys	irix_exec	0	/* 1011  exec()		       V*/
-	sys	sys_chdir	1	/* 1012  chdir()	       V*/
-	sys	irix_gtime	0	/* 1013  time()		       V*/
-	sys	irix_unimp	0	/* 1014  (XXX IRIX 4 mknod)    V*/
-	sys	sys_chmod	2	/* 1015  chmod()	       V*/
-	sys	sys_chown	3	/* 1016  chown()	       V*/
-	sys	irix_brk	1	/* 1017  break()	       V*/
-	sys	irix_unimp	0	/* 1018  (XXX IRIX 4 stat)     V*/
-	sys	sys_lseek	3	/* 1019  lseek()     XXX64bit HV*/
-	sys	irix_getpid	0	/* 1020  getpid()	       V*/
-	sys	irix_mount	6	/* 1021  mount()	      IV*/
-	sys	sys_umount	1	/* 1022  umount()	       V*/
-	sys	sys_setuid	1	/* 1023  setuid()	       V*/
-	sys	irix_getuid	0	/* 1024  getuid()	       V*/
-	sys	irix_stime	1	/* 1025  stime()	       V*/
-	sys	irix_unimp	4	/* 1026  XXX ptrace()	      IV*/
-	sys	irix_alarm	1	/* 1027  alarm()	       V*/
-	sys	irix_unimp	0	/* 1028  (XXX IRIX 4 fstat)    V*/
-	sys	irix_pause	0	/* 1029  pause()	       V*/
-	sys	sys_utime	2	/* 1030  utime()	       V*/
-	sys	irix_unimp	0	/* 1031  nuthin'	       V*/
-	sys	irix_unimp	0	/* 1032  nobody home man...    V*/
-	sys	sys_access	2	/* 1033  access()	       V*/
-	sys	sys_nice	1	/* 1034  nice()		       V*/
-	sys	irix_statfs	2	/* 1035  statfs()	       V*/
-	sys	sys_sync	0	/* 1036  sync()		       V*/
-	sys	sys_kill	2	/* 1037  kill()		       V*/
-	sys	irix_fstatfs	2	/* 1038  fstatfs()	       V*/
-	sys	irix_setpgrp	1	/* 1039  setpgrp()	       V*/
-	sys	irix_syssgi	0	/* 1040  syssgi()	      HV*/
-	sys	sys_dup		1	/* 1041  dup()		       V*/
-	sys	sys_pipe	0	/* 1042  pipe()		       V*/
-	sys	irix_times	1	/* 1043  times()	       V*/
-	sys	irix_unimp	0	/* 1044  XXX profil()	      IV*/
-	sys	irix_unimp	0	/* 1045  XXX lock()	      IV*/
-	sys	sys_setgid	1	/* 1046  setgid()	       V*/
-	sys	irix_getgid	0	/* 1047  getgid()	       V*/
-	sys	irix_unimp	0	/* 1048  (XXX IRIX 4 ssig)     V*/
-	sys	irix_msgsys	6	/* 1049  sys_msgsys	       V*/
-	sys	sys_sysmips	4	/* 1050  sysmips()	      HV*/
-	sys	irix_unimp	0	/* 1051	 XXX sysacct()	      IV*/
-	sys	irix_shmsys	5	/* 1052  sys_shmsys	       V*/
-	sys	irix_semsys	0	/* 1053  sys_semsys	       V*/
-	sys	irix_ioctl	3	/* 1054  ioctl()	      HV*/
-	sys	irix_uadmin	0	/* 1055  XXX sys_uadmin()     HC*/
-	sys	irix_sysmp	0	/* 1056  sysmp()	      HV*/
-	sys	irix_utssys	4	/* 1057  sys_utssys()	      HV*/
-	sys	irix_unimp	0	/* 1058  nada enchilada	       V*/
-	sys	irix_exece	0	/* 1059  exece()	       V*/
-	sys	sys_umask	1	/* 1060  umask()	       V*/
-	sys	sys_chroot	1	/* 1061  chroot()	       V*/
-	sys	irix_fcntl	3	/* 1062  fcntl()	      ?V*/
-	sys	irix_ulimit	2	/* 1063  ulimit()	      HV*/
-	sys	irix_unimp	0	/* 1064  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1065  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1066  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1067  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1068  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1069  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1070  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1071  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1072  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1073  XXX AFS shit	      DC*/
-	sys	irix_unimp	0	/* 1074  nuttin'	       V*/
-	sys	irix_unimp	0	/* 1075  XXX sys_getrlimit64()IV*/
-	sys	irix_unimp	0	/* 1076  XXX sys_setrlimit64()IV*/
-	sys	sys_nanosleep	2	/* 1077  nanosleep()	       V*/
-	sys	irix_lseek64	5	/* 1078  lseek64()	      ?V*/
-	sys	sys_rmdir	1	/* 1079  rmdir()	       V*/
-	sys	sys_mkdir	2	/* 1080  mkdir()	       V*/
-	sys	sys_getdents	3	/* 1081  getdents()	       V*/
-	sys	irix_sginap	1	/* 1082  sys_sginap()	       V*/
-	sys	irix_sgikopt	3	/* 1083  sys_sgikopt()	      DC*/
-	sys	sys_sysfs	3	/* 1084  sysfs()	      ?V*/
-	sys	irix_unimp	0	/* 1085  XXX sys_getmsg()     DC*/
-	sys	irix_unimp	0	/* 1086  XXX sys_putmsg()     DC*/
-	sys	sys_poll	3	/* 1087  poll()	               V*/
-	sys	irix_sigreturn	0	/* 1088  sigreturn()	      ?V*/
-	sys	sys_accept	3	/* 1089  accept()	       V*/
-	sys	sys_bind	3	/* 1090  bind()		       V*/
-	sys	sys_connect	3	/* 1091  connect()	       V*/
-	sys	irix_gethostid	0	/* 1092  sys_gethostid()      ?V*/
-	sys	sys_getpeername	3	/* 1093  getpeername()	       V*/
-	sys	sys_getsockname	3	/* 1094  getsockname()	       V*/
-	sys	sys_getsockopt	5	/* 1095  getsockopt()	       V*/
-	sys	sys_listen	2	/* 1096  listen()	       V*/
-	sys	sys_recv	4	/* 1097  recv()		       V*/
-	sys	sys_recvfrom	6	/* 1098  recvfrom()	       V*/
-	sys	sys_recvmsg	3	/* 1099  recvmsg()	       V*/
-	sys	sys_select	5	/* 1100  select()	       V*/
-	sys	sys_send	4	/* 1101  send()		       V*/
-	sys	sys_sendmsg	3	/* 1102  sendmsg()	       V*/
-	sys	sys_sendto	6	/* 1103  sendto()	       V*/
-	sys	irix_sethostid	1	/* 1104  sys_sethostid()      ?V*/
-	sys	sys_setsockopt	5	/* 1105  setsockopt()	       V*/
-	sys	sys_shutdown	2	/* 1106  shutdown()	      ?V*/
-	sys	irix_socket	3	/* 1107  socket()	       V*/
-	sys	sys_gethostname	2	/* 1108  sys_gethostname()    ?V*/
-	sys	sys_sethostname	2	/* 1109  sethostname()	      ?V*/
-	sys	irix_getdomainname 2	/* 1110  sys_getdomainname()  ?V*/
-	sys	sys_setdomainname 2	/* 1111  setdomainname()      ?V*/
-	sys	sys_truncate	2	/* 1112  truncate()	       V*/
-	sys	sys_ftruncate	2	/* 1113  ftruncate()	       V*/
-	sys	sys_rename	2	/* 1114  rename()	       V*/
-	sys	sys_symlink	2	/* 1115  symlink()	       V*/
-	sys	sys_readlink	3	/* 1116  readlink()	       V*/
-	sys	irix_unimp	0	/* 1117  XXX IRIX 4 lstat()   DC*/
-	sys	irix_unimp	0	/* 1118  nothin'	       V*/
-	sys	irix_unimp	0	/* 1119  XXX nfs_svc()	      DC*/
-	sys	irix_unimp	0	/* 1120  XXX nfs_getfh()      DC*/
-	sys	irix_unimp	0	/* 1121  XXX async_daemon()   DC*/
-	sys	irix_unimp	0	/* 1122  XXX exportfs()	      DC*/
-	sys	sys_setregid	2	/* 1123  setregid()	       V*/
-	sys	sys_setreuid	2	/* 1124  setreuid()	       V*/
-	sys	sys_getitimer	2	/* 1125  getitimer()	       V*/
-	sys	sys_setitimer	3	/* 1126  setitimer()	       V*/
-	sys	irix_unimp	1	/* 1127  XXX adjtime() 	      IV*/
-	sys	irix_gettimeofday 1	/* 1128  gettimeofday()	       V*/
-	sys	irix_unimp	0	/* 1129  XXX sproc()	      IV*/
-	sys	irix_prctl	0	/* 1130  prctl()	      HV*/
-	sys	irix_unimp	0	/* 1131  XXX procblk()	      IV*/
-	sys	irix_unimp	0	/* 1132  XXX sprocsp()	      IV*/
-	sys	irix_unimp	0	/* 1133  XXX sgigsc()	      IV*/
-	sys	irix_mmap32	6	/* 1134  mmap()	   XXXflags?  ?V*/
-	sys	sys_munmap	2	/* 1135  munmap()	       V*/
-	sys	sys_mprotect	3	/* 1136  mprotect()	       V*/
-	sys	sys_msync	4	/* 1137  msync()	       V*/
-	sys	irix_madvise	3	/* 1138  madvise()	      DC*/
-	sys	irix_pagelock	3	/* 1139  pagelock()	      IV*/
-	sys	irix_getpagesize 0	/* 1140  getpagesize()         V*/
-	sys	irix_quotactl	0	/* 1141  quotactl()	       V*/
-	sys	irix_unimp	0	/* 1142  nobody home man       V*/
-	sys	sys_getpgid	1	/* 1143  BSD getpgrp()	       V*/
-	sys	irix_BSDsetpgrp 2	/* 1143  BSD setpgrp()	       V*/
-	sys	sys_vhangup	0	/* 1144  vhangup()	       V*/
-	sys	sys_fsync	1	/* 1145  fsync()	       V*/
-	sys	sys_fchdir	1	/* 1146  fchdir()	       V*/
-	sys	sys_getrlimit	2	/* 1147  getrlimit()	      ?V*/
-	sys	sys_setrlimit	2	/* 1148  setrlimit()	      ?V*/
-	sys	sys_cacheflush	3	/* 1150  cacheflush()	      HV*/
-	sys	sys_cachectl	3	/* 1151  cachectl()	      HV*/
-	sys	sys_fchown	3	/* 1152  fchown()	      ?V*/
-	sys	sys_fchmod	2	/* 1153  fchmod()	      ?V*/
-	sys	irix_unimp	0	/* 1154  XXX IRIX 4 wait3()    V*/
-	sys	sys_socketpair	4	/* 1155  socketpair()	       V*/
-	sys	irix_systeminfo	3	/* 1156  systeminfo()	      IV*/
-	sys	irix_uname	1	/* 1157  uname()	      IV*/
-	sys	irix_xstat	3	/* 1158  xstat()	       V*/
-	sys	irix_lxstat	3	/* 1159  lxstat()	       V*/
-	sys	irix_fxstat	3	/* 1160  fxstat()	       V*/
-	sys	irix_xmknod	0	/* 1161  xmknod()	      ?V*/
-	sys	irix_sigaction	4	/* 1162  sigaction()	      ?V*/
-	sys	irix_sigpending	1	/* 1163  sigpending()	      ?V*/
-	sys	irix_sigprocmask 3	/* 1164  sigprocmask()	      ?V*/
-	sys	irix_sigsuspend	0	/* 1165  sigsuspend()	      ?V*/
-	sys	irix_sigpoll_sys 3	/* 1166  sigpoll_sys()	      IV*/
-	sys	irix_swapctl	2	/* 1167  swapctl()	      IV*/
-	sys	irix_getcontext	0	/* 1168  getcontext()	      HV*/
-	sys	irix_setcontext	0	/* 1169  setcontext()	      HV*/
-	sys	irix_waitsys	5	/* 1170  waitsys()	      IV*/
-	sys	irix_sigstack	2	/* 1171  sigstack()	      HV*/
-	sys	irix_sigaltstack 2	/* 1172  sigaltstack()	      HV*/
-	sys	irix_sigsendset	2	/* 1173  sigsendset()	      IV*/
-	sys	irix_statvfs	2	/* 1174  statvfs()	       V*/
-	sys	irix_fstatvfs	2	/* 1175  fstatvfs()	       V*/
-	sys	irix_unimp	0	/* 1176  XXX getpmsg()	      DC*/
-	sys	irix_unimp	0	/* 1177  XXX putpmsg()	      DC*/
-	sys	sys_lchown	3	/* 1178  lchown()	       V*/
-	sys	irix_priocntl	0	/* 1179  priocntl()	      DC*/
-	sys	irix_sigqueue	4	/* 1180  sigqueue()	      IV*/
-	sys	sys_readv	3	/* 1181  readv()	       V*/
-	sys	sys_writev	3	/* 1182  writev()	       V*/
-	sys	irix_truncate64 4	/* 1183  truncate64() XX32bit HV*/
-	sys	irix_ftruncate64 4	/* 1184  ftruncate64()XX32bit HV*/
-	sys	irix_mmap64	0	/* 1185  mmap64()     XX32bit HV*/
-	sys	irix_dmi	0	/* 1186  dmi()		      DC*/
-	sys	irix_pread	6	/* 1187  pread()	      IV*/
-	sys	irix_pwrite	6	/* 1188  pwrite()	      IV*/
-	sys	sys_fsync	1	/* 1189  fdatasync()  XXPOSIX HV*/
-	sys	irix_sgifastpath 7	/* 1190  sgifastpath() WHEEE  IV*/
-	sys	irix_unimp	0	/* 1191  XXX attr_get()	      DC*/
-	sys	irix_unimp	0	/* 1192  XXX attr_getf()      DC*/
-	sys	irix_unimp	0	/* 1193  XXX attr_set()	      DC*/
-	sys	irix_unimp	0	/* 1194  XXX attr_setf()      DC*/
-	sys	irix_unimp	0	/* 1195  XXX attr_remove()    DC*/
-	sys	irix_unimp	0	/* 1196  XXX attr_removef()   DC*/
-	sys	irix_unimp	0	/* 1197  XXX attr_list()      DC*/
-	sys	irix_unimp	0	/* 1198  XXX attr_listf()     DC*/
-	sys	irix_unimp	0	/* 1199  XXX attr_multi()     DC*/
-	sys	irix_unimp	0	/* 1200  XXX attr_multif()    DC*/
-	sys	irix_statvfs64	2	/* 1201  statvfs64()	       V*/
-	sys	irix_fstatvfs64	2	/* 1202  fstatvfs64()	       V*/
-	sys	irix_getmountid	2	/* 1203  getmountid()XXXfsids HV*/
-	sys	irix_nsproc	5	/* 1204  nsproc()	      IV*/
-	sys	irix_getdents64 3	/* 1205  getdents64()	      HV*/
-	sys	irix_unimp	0	/* 1206  XXX DFS garbage      DC*/
-	sys	irix_ngetdents	4	/* 1207  ngetdents() XXXeop   HV*/
-	sys	irix_ngetdents64 4	/* 1208  ngetdents64() XXXeop HV*/
-	sys	irix_unimp	0	/* 1209  nothin'	       V*/
-	sys	irix_unimp	0	/* 1210  XXX pidsprocsp()	*/
-	sys	irix_unimp	0	/* 1211  XXX rexec()		*/
-	sys	irix_unimp	0	/* 1212  XXX timer_create()	*/
-	sys	irix_unimp	0	/* 1213  XXX timer_delete()	*/
-	sys	irix_unimp	0	/* 1214  XXX timer_settime()	*/
-	sys	irix_unimp	0	/* 1215  XXX timer_gettime()	*/
-	sys	irix_unimp	0	/* 1216  XXX timer_setoverrun()	*/
-	sys	sys_sched_rr_get_interval 2		/* 1217  sched_rr_get_interval()V*/
-	sys	sys_sched_yield	0	/* 1218  sched_yield()	       V*/
-	sys	sys_sched_getscheduler 1 /* 1219  sched_getscheduler()  V*/
-	sys	sys_sched_setscheduler 3 /* 1220  sched_setscheduler()  V*/
-	sys	sys_sched_getparam 2	/* 1221  sched_getparam()      V*/
-	sys	sys_sched_setparam 2	/* 1222  sched_setparam()      V*/
-	sys	irix_unimp	0	/* 1223  XXX usync_cntl()	*/
-	sys	irix_unimp	0	/* 1224  XXX psema_cntl()	*/
-	sys	irix_unimp	0	/* 1225  XXX restartreturn()	*/
-
-/* Just to pad things out nicely. */
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-	sys	irix_unimp	0
-#else
-	mille	sys_ni_syscall	0
-#endif
-
-/* YEEEEEEEEEEEEEEEEEE!!!! */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/irixelf.c linux-2.6.11-rc3/arch/mips/kernel/irixelf.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/irixelf.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/irixelf.c	2005-02-03 02:57:04.000000000 +0100
@@ -1,15 +1,16 @@
 /*
- * irixelf.c: Code to load IRIX ELF executables which conform to
- *            the MIPS ABI.
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  *
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * irixelf.c: Code to load IRIX ELF executables conforming to the MIPS ABI.
+ *            Based off of work by Eric Youngdale.
  *
- * Based upon work which is:
- * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).
+ * Copyright (C) 1993 - 1994 Eric Youngdale <ericy@cais.com>
+ * Copyright (C) 1996 - 2004 David S. Miller <dm@engr.sgi.com>
+ * Copyright (C) 2004 Steven J. Hill <sjhill@realitydiluted.com>
  */
-
 #include <linux/module.h>
-
 #include <linux/fs.h>
 #include <linux/stat.h>
 #include <linux/sched.h>
@@ -211,13 +212,13 @@ unsigned long * create_irix_tables(char 
 		__put_user((unsigned long)p,argv++);
 		p += strlen_user(p);
 	}
-	__put_user(NULL, argv);
+	__put_user((unsigned long) NULL, argv);
 	current->mm->arg_end = current->mm->env_start = (unsigned long) p;
 	while (envc-->0) {
 		__put_user((unsigned long)p,envp++);
 		p += strlen_user(p);
 	}
-	__put_user(NULL, envp);
+	__put_user((unsigned long) NULL, envp);
 	current->mm->env_end = (unsigned long) p;
 	return sp;
 }
@@ -622,6 +623,7 @@ static int load_irix_binary(struct linux
 	}
 
 	retval = kernel_read(bprm->file, elf_ex.e_phoff, (char *)elf_phdata, size);
+
 	if (retval < 0)
 		goto out_free_ph;
 
@@ -934,7 +936,8 @@ unsigned long irix_mapelf(int fd, struct
 	}
 
 #ifdef DEBUG_ELF
-	printk("irix_mapelf: Success, returning %08lx\n", user_phdrp->p_vaddr);
+	printk("irix_mapelf: Success, returning %08lx\n",
+		(unsigned long) user_phdrp->p_vaddr);
 #endif
 	fput(filp);
 	return user_phdrp->p_vaddr;
@@ -1297,6 +1300,20 @@ end_coredump:
 
 static int __init init_irix_binfmt(void)
 {
+	int init_inventory(void);
+	extern asmlinkage unsigned long sys_call_table;
+	extern asmlinkage unsigned long sys_call_table_irix5;
+
+	init_inventory();
+
+	/*
+	 * Copy the IRIX5 syscall table (8000 bytes) into the main syscall
+	 * table. The IRIX5 calls are located by an offset of 8000 bytes
+	 * from the beginning of the main table.
+	 */
+	memcpy((void *) ((unsigned long) &sys_call_table + 8000),
+		&sys_call_table_irix5, 8000);
+
 	return register_binfmt(&irix_format);
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/irixinv.c linux-2.6.11-rc3/arch/mips/kernel/irixinv.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/irixinv.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/irixinv.c	2005-02-03 02:55:07.000000000 +0100
@@ -6,10 +6,8 @@
  * Miguel de Icaza, 1997.
  */
 #include <linux/mm.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <asm/uaccess.h>
 #include <asm/inventory.h>
+#include <asm/uaccess.h>
 
 #define MAX_INVENTORY 50
 int inventory_items = 0;
@@ -49,7 +47,7 @@ int dump_inventory_to_user (void *userbu
 	return inventory_items * sizeof (inventory_t);
 }
 
-static int __init init_inventory(void)
+int __init init_inventory(void)
 {
 	/*
 	 * gross hack while we put the right bits all over the kernel
@@ -77,5 +75,3 @@ static int __init init_inventory(void)
 
 	return 0;
 }
-
-module_init(init_inventory);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/irixsig.c linux-2.6.11-rc3/arch/mips/kernel/irixsig.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/irixsig.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/irixsig.c	2005-02-03 02:56:35.000000000 +0100
@@ -99,7 +99,7 @@ static void setup_irix_frame(struct k_si
 	__put_user((u64) regs->hi, &ctx->hi);
 	__put_user((u64) regs->lo, &ctx->lo);
 	__put_user((u64) regs->cp0_epc, &ctx->pc);
-	__put_user(current->used_math, &ctx->usedfp);
+	__put_user(!!used_math(), &ctx->usedfp);
 	__put_user((u64) regs->cp0_cause, &ctx->cp0_cause);
 	__put_user((u64) regs->cp0_badvaddr, &ctx->cp0_badvaddr);
 
@@ -624,7 +624,7 @@ repeat:
 			}
 			goto end_waitsys;
 
-		case TASK_ZOMBIE:
+		case EXIT_ZOMBIE:
 			current->signal->cutime += p->utime + p->signal->cutime;
 			current->signal->cstime += p->stime + p->signal->cstime;
 			if (ru != NULL)
@@ -725,7 +725,7 @@ asmlinkage int irix_getcontext(struct pt
 	__put_user(regs->cp0_epc, &ctx->regs[35]);
 
 	flags = 0x0f;
-	if(!current->used_math) {
+	if(!used_math()) {
 		flags &= ~(0x08);
 	} else {
 		/* XXX wheee... */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/irq-rm9000.c linux-2.6.11-rc3/arch/mips/kernel/irq-rm9000.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/irq-rm9000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/irq-rm9000.c	2005-02-03 02:57:16.000000000 +0100
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2003 Ralf Baechle
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Handler for RM9000 extended interrupts.  These are a non-standard
+ * feature so we handle them separately from standard interrupts.
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+static int irq_base;
+
+static inline void unmask_rm9k_irq(unsigned int irq)
+{
+	set_c0_intcontrol(0x1000 << (irq - irq_base));
+}
+
+static inline void mask_rm9k_irq(unsigned int irq)
+{
+	clear_c0_intcontrol(0x1000 << (irq - irq_base));
+}
+
+static inline void rm9k_cpu_irq_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	unmask_rm9k_irq(irq);
+	local_irq_restore(flags);
+}
+
+static void rm9k_cpu_irq_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	mask_rm9k_irq(irq);
+	local_irq_restore(flags);
+}
+
+static unsigned int rm9k_cpu_irq_startup(unsigned int irq)
+{
+	rm9k_cpu_irq_enable(irq);
+
+	return 0;
+}
+
+#define	rm9k_cpu_irq_shutdown	rm9k_cpu_irq_disable
+
+/*
+ * Performance counter interrupts are global on all processors.
+ */
+static void local_rm9k_perfcounter_irq_startup(void *args)
+{
+	unsigned int irq = (unsigned int) args;
+
+	rm9k_cpu_irq_enable(irq);
+}
+
+static unsigned int rm9k_perfcounter_irq_startup(unsigned int irq)
+{
+	on_each_cpu(local_rm9k_perfcounter_irq_startup, (void *) irq, 0, 1);
+
+	return 0;
+}
+
+static void local_rm9k_perfcounter_irq_shutdown(void *args)
+{
+	unsigned int irq = (unsigned int) args;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	mask_rm9k_irq(irq);
+	local_irq_restore(flags);
+}
+
+static void rm9k_perfcounter_irq_shutdown(unsigned int irq)
+{
+	on_each_cpu(local_rm9k_perfcounter_irq_shutdown, (void *) irq, 0, 1);
+}
+
+
+/*
+ * While we ack the interrupt interrupts are disabled and thus we don't need
+ * to deal with concurrency issues.  Same for rm9k_cpu_irq_end.
+ */
+static void rm9k_cpu_irq_ack(unsigned int irq)
+{
+	mask_rm9k_irq(irq);
+}
+
+static void rm9k_cpu_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		unmask_rm9k_irq(irq);
+}
+
+static hw_irq_controller rm9k_irq_controller = {
+	"RM9000",
+	rm9k_cpu_irq_startup,
+	rm9k_cpu_irq_shutdown,
+	rm9k_cpu_irq_enable,
+	rm9k_cpu_irq_disable,
+	rm9k_cpu_irq_ack,
+	rm9k_cpu_irq_end,
+};
+
+static hw_irq_controller rm9k_perfcounter_irq = {
+	"RM9000",
+	rm9k_perfcounter_irq_startup,
+	rm9k_perfcounter_irq_shutdown,
+	rm9k_cpu_irq_enable,
+	rm9k_cpu_irq_disable,
+	rm9k_cpu_irq_ack,
+	rm9k_cpu_irq_end,
+};
+
+unsigned int rm9000_perfcount_irq;
+
+EXPORT_SYMBOL(rm9000_perfcount_irq);
+
+void __init rm9k_cpu_irq_init(int base)
+{
+	int i;
+
+	clear_c0_intcontrol(0x0000f000);		/* Mask all */
+
+	for (i = base; i < base + 4; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &rm9k_irq_controller;
+	}
+
+	rm9000_perfcount_irq = base + 1;
+	irq_desc[rm9000_perfcount_irq].handler = &rm9k_perfcounter_irq;
+
+	irq_base = base;
+}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/irq.c linux-2.6.11-rc3/arch/mips/kernel/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/irq.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/irq.c	2005-02-03 02:55:14.000000000 +0100
@@ -125,7 +125,7 @@ void __init init_IRQ(void)
 		irq_desc[i].action  = NULL;
 		irq_desc[i].depth   = 1;
 		irq_desc[i].handler = &no_irq_type;
-		irq_desc[i].lock = SPIN_LOCK_UNLOCKED;
+		spin_lock_init(&irq_desc[i].lock);
 	}
 
 	arch_init_irq();
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/linux32.c linux-2.6.11-rc3/arch/mips/kernel/linux32.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/linux32.c	2005-02-03 10:03:08.823527841 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/linux32.c	2005-02-03 02:56:10.000000000 +0100
@@ -99,7 +99,7 @@ int cp_compat_stat(struct kstat *stat, s
 }
 
 asmlinkage unsigned long
-sys32_mmap2(unsigned long addr, size_t len, unsigned long prot,
+sys32_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
          unsigned long flags, unsigned long fd, unsigned long pgoff)
 {
 	struct file * file = NULL;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/mips_ksyms.c linux-2.6.11-rc3/arch/mips/kernel/mips_ksyms.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/mips_ksyms.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/mips_ksyms.c	2005-02-03 02:55:15.000000000 +0100
@@ -5,9 +5,11 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 97, 98, 99, 2000, 01, 03 by Ralf Baechle
+ * Copyright (C) 1996, 97, 98, 99, 2000, 01, 03, 04, 05 by Ralf Baechle
  * Copyright (C) 1999, 2000, 01 Silicon Graphics, Inc.
  */
+#include <linux/config.h>
+#include <linux/interrupt.h>
 #include <linux/module.h>
 #include <asm/checksum.h>
 #include <asm/pgtable.h>
@@ -60,3 +62,6 @@ EXPORT_SYMBOL(__strnlen_user_asm);
 EXPORT_SYMBOL(csum_partial);
 
 EXPORT_SYMBOL(invalid_pte_table);
+#ifdef CONFIG_GENERIC_IRQ_PROBE
+EXPORT_SYMBOL(probe_irq_mask);
+#endif
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/module.c linux-2.6.11-rc3/arch/mips/kernel/module.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/module.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/module.c	2005-02-03 02:55:23.000000000 +0100
@@ -2,7 +2,7 @@
 #include <linux/spinlock.h>
 
 static LIST_HEAD(dbe_list);
-static spinlock_t dbe_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(dbe_lock);
 
 /* Given an address, look for it in the module exception tables. */
 const struct exception_table_entry *search_module_dbetables(unsigned long addr)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/process.c linux-2.6.11-rc3/arch/mips/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/process.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/process.c	2005-02-03 02:55:50.000000000 +0100
@@ -76,7 +76,7 @@ void start_thread(struct pt_regs * regs,
 #endif
 	status |= KU_USER;
 	regs->cp0_status = status;
-	current->used_math = 0;
+	clear_used_math();
 	lose_fpu();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
@@ -113,19 +113,15 @@ int copy_thread(int nr, unsigned long cl
 	*childregs = *regs;
 	childregs->regs[7] = 0;	/* Clear error flag */
 
-#ifdef CONFIG_BINFMT_IRIX
+#if defined(CONFIG_BINFMT_IRIX)
 	if (current->personality != PER_LINUX) {
 		/* Under IRIX things are a little different. */
-		childregs->regs[2] = 0;
 		childregs->regs[3] = 1;
-		regs->regs[2] = p->pid;
 		regs->regs[3] = 0;
-	} else
-#endif
-	{
-		childregs->regs[2] = 0;	/* Child gets zero as return value */
-		regs->regs[2] = p->pid;
 	}
+#endif
+	childregs->regs[2] = 0;	/* Child gets zero as return value */
+	regs->regs[2] = p->pid;
 
 	if (childregs->cp0_status & ST0_CU0) {
 		childregs->regs[28] = (unsigned long) ti;
@@ -153,6 +149,36 @@ int copy_thread(int nr, unsigned long cl
 int dump_fpu(struct pt_regs *regs, elf_fpregset_t *r)
 {
 	memcpy(r, &current->thread.fpu, sizeof(current->thread.fpu));
+
+	return 1;
+}
+
+void dump_regs(elf_greg_t *gp, struct pt_regs *regs)
+{
+	int i;
+
+	for (i = 0; i < EF_R0; i++)
+		gp[i] = 0;
+	gp[EF_R0] = 0;
+	for (i = 1; i <= 31; i++)
+		gp[EF_R0 + i] = regs->regs[i];
+	gp[EF_R26] = 0;
+	gp[EF_R27] = 0;
+	gp[EF_LO] = regs->lo;
+	gp[EF_HI] = regs->hi;
+	gp[EF_CP0_EPC] = regs->cp0_epc;
+	gp[EF_CP0_BADVADDR] = regs->cp0_badvaddr;
+	gp[EF_CP0_STATUS] = regs->cp0_status;
+	gp[EF_CP0_CAUSE] = regs->cp0_cause;
+#ifdef EF_UNUSED0
+	gp[EF_UNUSED0] = 0;
+#endif
+}
+
+int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
+{
+	memcpy(fpr, &t->thread.fpu, sizeof(current->thread.fpu));
+
 	return 1;
 }
 
@@ -263,7 +289,6 @@ arch_initcall(frame_info_init);
  */
 unsigned long thread_saved_pc(struct task_struct *tsk)
 {
-	extern void ret_from_fork(void);
 	struct thread_struct *t = &tsk->thread;
 
 	/* New born processes are a special case */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/ptrace.c linux-2.6.11-rc3/arch/mips/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/ptrace.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/ptrace.c	2005-02-03 02:57:04.000000000 +0100
@@ -119,7 +119,7 @@ asmlinkage int sys_ptrace(long request, 
 			tmp = regs->regs[addr];
 			break;
 		case FPR_BASE ... FPR_BASE + 31:
-			if (child->used_math) {
+			if (tsk_used_math(child)) {
 				fpureg_t *fregs = get_fpu_regs(child);
 
 #ifdef CONFIG_MIPS32
@@ -205,7 +205,7 @@ asmlinkage int sys_ptrace(long request, 
 		case FPR_BASE ... FPR_BASE + 31: {
 			fpureg_t *fregs = get_fpu_regs(child);
 
-			if (!child->used_math) {
+			if (!tsk_used_math(child)) {
 				/* FP not yet used  */
 				memset(&child->thread.fpu.hard, ~0,
 				       sizeof(child->thread.fpu.hard));
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/ptrace32.c linux-2.6.11-rc3/arch/mips/kernel/ptrace32.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/ptrace32.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/ptrace32.c	2005-02-03 02:55:50.000000000 +0100
@@ -112,7 +112,7 @@ asmlinkage int sys32_ptrace(int request,
 			tmp = regs->regs[addr];
 			break;
 		case FPR_BASE ... FPR_BASE + 31:
-			if (child->used_math) {
+			if (tsk_used_math(child)) {
 				fpureg_t *fregs = get_fpu_regs(child);
 
 				/*
@@ -193,7 +193,7 @@ asmlinkage int sys32_ptrace(int request,
 		case FPR_BASE ... FPR_BASE + 31: {
 			fpureg_t *fregs = get_fpu_regs(child);
 
-			if (!child->used_math) {
+			if (!tsk_used_math(child)) {
 				/* FP not yet used  */
 				memset(&child->thread.fpu.hard, ~0,
 				       sizeof(child->thread.fpu.hard));
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/reg.c linux-2.6.11-rc3/arch/mips/kernel/reg.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/reg.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/reg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/*
- * offset.c: Calculate pt_regs and task_struct indices.
- *
- * Copyright (C) 1996 David S. Miller
- * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Ralf Baechle
- */
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-
-#include <asm/ptrace.h>
-#include <asm/processor.h>
-
-#define text(t) __asm__("\n@@@" t)
-#define _offset(type, member) ((unsigned long) &(((type *)NULL)->member))
-#define index(string, ptr, member) \
-	__asm__("\n@@@" string "%0" : : "i" (_offset(ptr, member)/sizeof(long)))
-#define size(string, size) \
-	__asm__("\n@@@" string "%0" : : "i" (sizeof(size)))
-#define linefeed text("")
-
-void output_ptreg_defines(void)
-{
-	text("/* MIPS pt_regs indices. */");
-	index("#define EF_R0     ", struct pt_regs, regs[0]);
-	index("#define EF_R1     ", struct pt_regs, regs[1]);
-	index("#define EF_R2     ", struct pt_regs, regs[2]);
-	index("#define EF_R3     ", struct pt_regs, regs[3]);
-	index("#define EF_R4     ", struct pt_regs, regs[4]);
-	index("#define EF_R5     ", struct pt_regs, regs[5]);
-	index("#define EF_R6     ", struct pt_regs, regs[6]);
-	index("#define EF_R7     ", struct pt_regs, regs[7]);
-	index("#define EF_R8     ", struct pt_regs, regs[8]);
-	index("#define EF_R9     ", struct pt_regs, regs[9]);
-	index("#define EF_R10    ", struct pt_regs, regs[10]);
-	index("#define EF_R11    ", struct pt_regs, regs[11]);
-	index("#define EF_R12    ", struct pt_regs, regs[12]);
-	index("#define EF_R13    ", struct pt_regs, regs[13]);
-	index("#define EF_R14    ", struct pt_regs, regs[14]);
-	index("#define EF_R15    ", struct pt_regs, regs[15]);
-	index("#define EF_R16    ", struct pt_regs, regs[16]);
-	index("#define EF_R17    ", struct pt_regs, regs[17]);
-	index("#define EF_R18    ", struct pt_regs, regs[18]);
-	index("#define EF_R19    ", struct pt_regs, regs[19]);
-	index("#define EF_R20    ", struct pt_regs, regs[20]);
-	index("#define EF_R21    ", struct pt_regs, regs[21]);
-	index("#define EF_R22    ", struct pt_regs, regs[22]);
-	index("#define EF_R23    ", struct pt_regs, regs[23]);
-	index("#define EF_R24    ", struct pt_regs, regs[24]);
-	index("#define EF_R25    ", struct pt_regs, regs[25]);
-	index("#define EF_R26    ", struct pt_regs, regs[26]);
-	index("#define EF_R27    ", struct pt_regs, regs[27]);
-	index("#define EF_R28    ", struct pt_regs, regs[28]);
-	index("#define EF_R29    ", struct pt_regs, regs[29]);
-	index("#define EF_R30    ", struct pt_regs, regs[30]);
-	index("#define EF_R31    ", struct pt_regs, regs[31]);
-	linefeed;
-	index("#define EF_LO     ", struct pt_regs, lo);
-	index("#define EF_HI     ", struct pt_regs, hi);
-	linefeed;
-	index("#define EF_EPC    ", struct pt_regs, cp0_epc);
-	index("#define EF_BVADDR ", struct pt_regs, cp0_badvaddr);
-	index("#define EF_STATUS ", struct pt_regs, cp0_status);
-	index("#define EF_CAUSE  ", struct pt_regs, cp0_cause);
-	linefeed;
-	size("#define EF_SIZE   ", struct pt_regs);
-	linefeed;
-}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/scall32-o32.S linux-2.6.11-rc3/arch/mips/kernel/scall32-o32.S
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/scall32-o32.S	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/scall32-o32.S	2005-02-03 02:55:07.000000000 +0100
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1995, 96, 97, 98, 99, 2000, 01, 02 by Ralf Baechle
  * Copyright (C) 2001 MIPS Technologies, Inc.
+ * Copyright (C) 2004 Thiemo Seufer
  */
 #include <linux/config.h>
 #include <linux/errno.h>
@@ -32,26 +33,30 @@ NESTED(handle_sys, PT_SIZE, sp)
 
 	lw	t1, PT_EPC(sp)		# skip syscall on return
 
+#if defined(CONFIG_BINFMT_IRIX)
 	sltiu	t0, v0, MAX_SYSCALL_NO + 1 # check syscall number
+#else
+	subu	v0, v0, __NR_O32_Linux	# check syscall number
+	sltiu	t0, v0, __NR_O32_Linux_syscalls + 1
+#endif
 	addiu	t1, 4			# skip to next instruction
 	sw	t1, PT_EPC(sp)
 	beqz	t0, illegal_syscall
 
-	/* XXX Put both in one cacheline, should save a bit. */
-	sll	t0, v0, 2
-	lw	t2, sys_call_table(t0)	# syscall routine
-	lbu	t3, sys_narg_table(v0)	# number of arguments
-	beqz	t2, illegal_syscall;
+	sll	t0, v0, 3
+	la	t1, sys_call_table
+	addu	t1, t0
+	lw	t2, (t1)		# syscall routine
+	lw	t3, 4(t1)		# >= 0 if we need stack arguments
+	beqz	t2, illegal_syscall
 
-	subu	t0, t3, 5		# 5 or more arguments?
 	sw	a3, PT_R26(sp)		# save a3 for syscall restarting
-	bgez	t0, stackargs
+	bgez	t3, stackargs
 
 stack_done:
-	sw	a3, PT_R26(sp)          # save for syscall restart
-	LONG_L	t0, TI_FLAGS($28)	# syscall tracing enabled?
+	lw	t0, TI_FLAGS($28)	# syscall tracing enabled?
 	li	t1, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
-	and	t0, t1, t0
+	and	t0, t1
 	bnez	t0, syscall_trace_entry	# -> yes
 
 	jalr	t2			# Do The Real Thing (TM)
@@ -70,9 +75,9 @@ o32_syscall_exit:
 	local_irq_disable		# make sure need_resched and
 					# signals dont change between
 					# sampling and return
-	LONG_L	a2, TI_FLAGS($28)	# current->work
+	lw	a2, TI_FLAGS($28)	# current->work
 	li	t0, _TIF_ALLWORK_MASK
-	and	t0, a2, t0
+	and	t0, a2
 	bnez	t0, o32_syscall_exit_work
 
 	j	restore_partial
@@ -116,49 +121,48 @@ syscall_trace_entry:
 	 */
 stackargs:
 	lw	t0, PT_R29(sp)		# get old user stack pointer
-	subu	t3, 4
-	sll	t1, t3, 2		# stack valid?
 
-	addu	t1, t0			# end address
-	or	t0, t1
-	bltz	t0, bad_stack		# -> sp is bad
-
-	lw	t0, PT_R29(sp)		# get old user stack pointer
-	PTR_LA	t1, 4f			# copy 1 to 3 arguments
-	sll	t3, t3, 4
-	subu	t1, t3
-	jr	t1
-
-	/* Ok, copy the args from the luser stack to the kernel stack */
 	/*
-	 * I know Ralf doesn't like nops but this avoids code
-	 * duplication for R3000 targets (and this is the
-	 * only place where ".set reorder" doesn't help).
-	 * Harald.
+	 * We intentionally keep the kernel stack a little below the top of
+	 * userspace so we don't have to do a slower byte accurate check here.
+	 */
+	lw	t5, TI_ADDR_LIMIT($28)
+	addu	t4, t0, 32
+	and	t5, t4
+	bltz	t5, bad_stack		# -> sp is bad
+
+	/* Ok, copy the args from the luser stack to the kernel stack.
+	 * t3 is the precomputed number of instruction bytes needed to
+	 * load or store arguments 6-8.
 	 */
+
+	la	t1, 5f			# load up to 3 arguments
+	subu	t1, t3
+1:	lw	t5, 16(t0)		# argument #5 from usp
 	.set    push
 	.set    noreorder
 	.set	nomacro
-1:	lw	t1, 24(t0)		# argument #7 from usp
-	nop
-	sw	t1, 24(sp)
-	nop
-2:	lw	t1, 20(t0)		# argument #5 from usp
-	nop
-	sw	t1, 20(sp)
-	nop
-3:	lw	t1, 16(t0)		# argument #5 from usp
-	nop
-	sw	t1, 16(sp)
-	nop
-4:	.set	pop
+	jr	t1
+	 addiu	t1, 6f - 5f
 
-	j	stack_done		# go back
+2:	lw	t8, 28(t0)		# argument #8 from usp
+3:	lw	t7, 24(t0)		# argument #7 from usp
+4:	lw	t6, 20(t0)		# argument #6 from usp
+5:	jr	t1
+	 sw	t5, 16(sp)		# argument #5 to ksp
+
+	sw	t8, 28(sp)		# argument #8 to ksp
+	sw	t7, 24(sp)		# argument #7 to ksp
+	sw	t6, 20(sp)		# argument #6 to ksp
+6:	j	stack_done		# go back
+	 nop
+	.set	pop
 
 	.section __ex_table,"a"
 	PTR	1b,bad_stack
 	PTR	2b,bad_stack
 	PTR	3b,bad_stack
+	PTR	4b,bad_stack
 	.previous
 
 	/*
@@ -177,7 +181,7 @@ bad_stack:
 	 * The system call does not exist in this kernel
 	 */
 illegal_syscall:
-	li	v0, ENOSYS			# error
+	li	v0, -ENOSYS			# error
 	sw	v0, PT_R2(sp)
 	li	t0, 1				# set error flag
 	sw	t0, PT_R7(sp)
@@ -238,12 +242,12 @@ illegal_syscall:
 	sw	v0, PT_R2(sp)		# result
 
 	/* Success, so skip usual error handling garbage.  */
-	LONG_L	a2, TI_FLAGS($28)	# syscall tracing enabled?
+	lw	a2, TI_FLAGS($28)	# syscall tracing enabled?
 	li	t0, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
 	and	t0, a2, t0
 	bnez	t0, 1f
 
-	b	o32_syscall_exit
+	j	o32_syscall_exit
 
 1:	SAVE_STATIC
 	move	a0, sp
@@ -269,69 +273,49 @@ bad_alignment:
 	END(sys_sysmips)
 
 	LEAF(sys_syscall)
-	lw	t0, PT_R29(sp)			# user sp
-
-	sltu	v0, a0, __NR_O32_Linux + __NR_O32_Linux_syscalls + 1
-	beqz	v0, enosys
-
-	sll	v0, a0, 2
-	la	v1, sys_syscall
-	lw	t2, sys_call_table(v0)		# function pointer
-	lbu	t4, sys_narg_table(a0)		# number of arguments
-
-	li	v0, -EINVAL
-	beq	t2, v1, out			# do not recurse
+#if defined(CONFIG_BINFMT_IRIX)
+	sltiu	v0, a0, MAX_SYSCALL_NO + 1 # check syscall number
+#else
+	subu	t0, a0, __NR_O32_Linux	# check syscall number
+	sltiu	v0, t0, __NR_O32_Linux_syscalls + 1
+#endif
+	sll	t1, t0, 3
+	beqz	v0, einval
 
-	beqz	t2, enosys			# null function pointer?
+	lw	t2, sys_call_table(t1)		# syscall routine
 
-	andi	v0, t0, 0x3			# unaligned stack pointer?
-	bnez	v0, sigsegv
+#if defined(CONFIG_BINFMT_IRIX)
+	li	v1, 4000			# nr of sys_syscall
+#else
+	li	v1, 4000 - __NR_O32_Linux	# index of sys_syscall
+#endif
+	beq	t0, v1, einval			# do not recurse
 
-	addu	v0, t0, 16			# v0 = usp + 16
-	addu	t1, v0, 12			# 3 32-bit arguments
-	lw	v1, TI_ADDR_LIMIT($28)
-	or	v0, v0, t1
-	and	v1, v1, v0
-	bltz	v1, efault
+	/* Some syscalls like execve get their arguments from struct pt_regs
+	   and claim zero arguments in the syscall table. Thus we have to
+	   assume the worst case and shuffle around all potential arguments.
+	   If you want performance, don't use indirect syscalls. */
 
 	move	a0, a1				# shift argument registers
 	move	a1, a2
 	move	a2, a3
-
-1:	lw	a3, 16(t0)
-2:	lw	t3, 20(t0)
-3:	lw	t4, 24(t0)
-
-	.section	__ex_table, "a"
-	.word	1b, efault
-	.word	2b, efault
-	.word	3b, efault
-	.previous
-
-	sw	t3, 16(sp)			# put into new stackframe
-	sw	t4, 20(sp)
-
-	bnez	t4, 1f				# zero arguments?
-	addu	a0, sp, 32			# then pass sp in a0
-1:
-
-	sw	t3, 16(sp)
-	sw	v1, 20(sp)
+	lw	a3, 16(sp)
+	lw	t4, 20(sp)
+	lw	t5, 24(sp)
+	lw	t6, 28(sp)
+	sw	t4, 16(sp)
+	sw	t5, 20(sp)
+	sw	t6, 24(sp)
+	sw	a0, PT_R4(sp)			# .. and push back a0 - a3, some
+	sw	a1, PT_R5(sp)			# syscalls expect them there
+	sw	a2, PT_R6(sp)
+	sw	a3, PT_R7(sp)
+	sw	a3, PT_R26(sp)			# update a3 for syscall restarting
 	jr	t2
 	/* Unreached */
 
-enosys:	li	v0, -ENOSYS
-	b	out
-
-sigsegv:
-	li	a0, _SIGSEGV
-	move	a1, $28
-	jal	force_sig
-	/* Fall through */
-
-efault:	li	v0, -EFAULT
-
-out:	jr	ra
+einval:	li	v0, -EINVAL
+	jr	ra
 	END(sys_syscall)
 
 	.macro	fifty ptr, nargs, from=1, to=50
@@ -349,12 +333,14 @@ out:	jr	ra
 	.endm
 
 	.macro	syscalltable
+#if defined(CONFIG_BINFMT_IRIX)
 	mille	sys_ni_syscall		0	/*    0 -  999 SVR4 flavour */
-	#include "irix5sys.h"			/* 1000 - 1999 32-bit IRIX */
+	mille	sys_ni_syscall		0	/* 1000 - 1999 32-bit IRIX */
 	mille	sys_ni_syscall		0	/* 2000 - 2999 BSD43 flavour */
 	mille	sys_ni_syscall		0	/* 3000 - 3999 POSIX flavour */
+#endif
 
-	sys	sys_syscall		0	/* 4000 */
+	sys	sys_syscall		8	/* 4000 */
 	sys	sys_exit		1
 	sys	sys_fork		0
 	sys	sys_read		3
@@ -405,7 +391,7 @@ out:	jr	ra
 	sys	sys_ni_syscall		0	/* was signal(2) */
 	sys	sys_geteuid		0
 	sys	sys_getegid		0	/* 4050 */
-	sys	sys_acct		0
+	sys	sys_acct		1
 	sys	sys_umount		2
 	sys	sys_ni_syscall		0
 	sys	sys_ioctl		3
@@ -485,7 +471,7 @@ out:	jr	ra
 	sys	sys_init_module		5
 	sys	sys_delete_module	1
 	sys	sys_ni_syscall		0	/* 4130	was get_kernel_syms */
-	sys	sys_quotactl		0
+	sys	sys_quotactl		4
 	sys	sys_getpgid		1
 	sys	sys_fchdir		1
 	sys	sys_bdflush		2
@@ -506,7 +492,7 @@ out:	jr	ra
 	sys	sys_sysmips		4
 	sys	sys_ni_syscall		0	/* 4150 */
 	sys	sys_getsid		1
-	sys	sys_fdatasync		0
+	sys	sys_fdatasync		1
 	sys	sys_sysctl		1
 	sys	sys_mlock		2
 	sys	sys_munlock		2	/* 4155 */
@@ -640,19 +626,16 @@ out:	jr	ra
 
 	.endm
 
+	/* We pre-compute the number of _instruction_ bytes needed to
+	   load or store the arguments 6-8. Negative values are ignored. */
+
 	.macro  sys function, nargs
 	PTR	\function
+	LONG	(\nargs << 2) - (5 << 2)
 	.endm
 
 	.align	3
-sys_call_table:
+	.type	sys_call_table,@object
+EXPORT(sys_call_table)
 	syscalltable
 	.size	sys_call_table, . - sys_call_table
-
-	.macro	sys function, nargs
-	.byte	\nargs
-	.endm
-
-sys_narg_table:
-	syscalltable
-	.size	sys_narg_table, . - sys_narg_table
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/scall64-64.S linux-2.6.11-rc3/arch/mips/kernel/scall64-64.S
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/scall64-64.S	2005-01-22 02:48:29.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/scall64-64.S	2005-02-03 02:56:22.000000000 +0100
@@ -53,8 +53,10 @@ NESTED(handle_sys64, PT_SIZE, sp)
 
 	sd	a3, PT_R26(sp)		# save a3 for syscall restarting
 
-	LONG_L	t0, TI_FLAGS($28)
-	bltz	t0, syscall_trace_entry	# syscall tracing enabled?
+	li	t1, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
+	LONG_L	t0, TI_FLAGS($28)	# syscall tracing enabled?
+	and	t0, t1, t0
+	bnez	t0, syscall_trace_entry
 
 	jalr	t2			# Do The Real Thing (TM)
 
@@ -112,7 +114,7 @@ syscall_trace_entry:
 
 illegal_syscall:
 	/* This also isn't a 64-bit syscall, throw an error.  */
-	li	v0, ENOSYS			# error
+	li	v0, -ENOSYS			# error
 	sd	v0, PT_R2(sp)
 	li	t0, 1				# set error flag
 	sd	t0, PT_R7(sp)
@@ -173,8 +175,8 @@ illegal_syscall:
 	sd	v0, PT_R2(sp)		# result
 
 	/* Success, so skip usual error handling garbage.  */
-	LONG_L	a2, TI_FLAGS($28)	# syscall tracing enabled?
 	li	t0, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
+	LONG_L	a2, TI_FLAGS($28)	# syscall tracing enabled?
 	and	t0, a2, t0
 	bnez	t0, 1f
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/scall64-o32.S linux-2.6.11-rc3/arch/mips/kernel/scall64-o32.S
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/scall64-o32.S	2005-01-22 02:46:40.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/scall64-o32.S	2005-02-03 02:54:37.000000000 +0100
@@ -6,6 +6,7 @@
  * Copyright (C) 1995 - 2000, 2001 by Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 2001 MIPS Technologies, Inc.
+ * Copyright (C) 2004 Thiemo Seufer
  *
  * Hairy, the userspace application uses a different argument passing
  * convention than the kernel, so we have to translate things from o32
@@ -43,6 +44,8 @@ NESTED(handle_sys, PT_SIZE, sp)
  RESTORE_ALL
 #endif
 
+	/* We don't want to stumble over broken sign extensions from
+	   userland. O32 does never use the upper half. */
 	sll	a0, a0, 0
 	sll	a1, a1, 0
 	sll	a2, a2, 0
@@ -68,11 +71,13 @@ NESTED(handle_sys, PT_SIZE, sp)
 1:	lw	a4, 16(t0)		# argument #5 from usp
 2:	lw	a5, 20(t0)		# argument #6 from usp
 3:	lw	a6, 24(t0)		# argument #7 from usp
+4:	lw	a7, 28(t0)		# argument #8 from usp (for indirect syscalls)
 
 	.section __ex_table,"a"
 	PTR	1b, bad_stack
 	PTR	2b, bad_stack
 	PTR	3b, bad_stack
+	PTR	4b, bad_stack
 	.previous
 
 	li	t1, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
@@ -91,7 +96,7 @@ NESTED(handle_sys, PT_SIZE, sp)
 	sd	v0, PT_R0(sp)		# flag for syscall restarting
 1:	sd	v0, PT_R2(sp)		# result
 
-FEXPORT(o32_syscall_exit)
+o32_syscall_exit:
 	local_irq_disable		# make need_resched and
 					# signals dont change between
 					# sampling and return
@@ -109,12 +114,12 @@ o32_syscall_exit_work:
 
 trace_a_syscall:
 	SAVE_STATIC
-	sd	a4, PT_R8(sp)
+	sd	a4, PT_R8(sp)		# Save argument registers
 	sd	a5, PT_R9(sp)
 	sd	a6, PT_R10(sp)
-	sd	a7, PT_R11(sp)
+	sd	a7, PT_R11(sp)		# For indirect syscalls
 
-	move	s0, t2
+	move	s0, t2			# Save syscall pointer
 	move	a0, sp
 	li	a1, 0
 	jal	do_syscall_trace
@@ -125,7 +130,8 @@ trace_a_syscall:
 	ld	a3, PT_R7(sp)
 	ld	a4, PT_R8(sp)
 	ld	a5, PT_R9(sp)
-	ld	a6, PT_R10(sp)		# For indirect syscalls
+	ld	a6, PT_R10(sp)
+	ld	a7, PT_R11(sp)		# For indirect syscalls
 	jalr	s0
 
 	li	t0, -EMAXERRNO - 1	# error?
@@ -162,40 +168,17 @@ not_o32_scall:
 #else
 	j	handle_sys64
 #endif
-
-illegal_syscall:
-	/* This also isn't a 64-bit syscall, throw an error.  */
-	li	v0, ENOSYS		# error
-	sd	v0, PT_R2(sp)
-	li	t0, 1			# set error flag
-	sd	t0, PT_R7(sp)
-	j	o32_syscall_exit
 	END(handle_sys)
 
 LEAF(sys32_syscall)
-	ld	t0, PT_R29(sp)		# user sp
-
 	sltu	v0, a0, __NR_O32_Linux + __NR_O32_Linux_syscalls + 1
-	beqz	v0, enosys
+	beqz	v0, einval
 
 	dsll	v0, a0, 3
-	dla	v1, sys32_syscall
 	ld	t2, (sys_call_table - (__NR_O32_Linux * 8))(v0)
 
-	li	v0, -EINVAL
-	beq	t2, v1, out		# do not recurse
-
-	beqz	t2, enosys		# null function pointer?
-
-	andi	v0, t0, 0x3		# unaligned stack pointer?
-	bnez	v0, sigsegv
-
-	daddiu	v0, t0, 16		# v0 = usp + 16
-	daddu	t1, v0, 12		# 3 32-bit arguments
-	ld	v1, TI_ADDR_LIMIT($28)
-	or	v0, v0, t1
-	and	v1, v1, v0
-	bnez	v1, efault
+	li	v1, 4000		# indirect syscall number
+	beq	a0, v1, einval		# do not recurse
 
 	move	a0, a1			# shift argument registers
 	move	a1, a2
@@ -203,25 +186,21 @@ LEAF(sys32_syscall)
 	move	a3, a4
 	move	a4, a5
 	move	a5, a6
+	move	a6, a7
+	sd	a0, PT_R4(sp)		# ... and push back a0 - a3, some
+	sd	a1, PT_R5(sp)		# syscalls expect them there
+	sd	a2, PT_R6(sp)
+	sd	a3, PT_R7(sp)
+	sd	a3, PT_R26(sp)		# update a3 for syscall restarting
 	jr	t2
 	/* Unreached */
 
-enosys:	li	v0, -ENOSYS
-	b	out
-
-sigsegv:
-	li	a0, _SIGSEGV
-	move	a1, $28
-	jal	force_sig
-	/* Fall through */
-
-efault:	li	v0, -EFAULT
-
-out:	jr	ra
+einval:	li	v0, -EINVAL
+	jr	ra
 	END(sys32_syscall)
 
 	.align	3
-	.type	sys_call_table,@object;
+	.type	sys_call_table,@object
 sys_call_table:
 	PTR	sys32_syscall			/* 4000 */
 	PTR	sys_exit
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/semaphore.c linux-2.6.11-rc3/arch/mips/kernel/semaphore.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/semaphore.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/semaphore.c	2005-02-03 02:56:11.000000000 +0100
@@ -15,7 +15,6 @@
  * indicate that some process(es) are waiting for the semaphore.
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/init.h>
@@ -64,7 +63,7 @@ static inline int __sem_update_count(str
 		: "=&r" (old_count), "=&r" (tmp), "=m" (sem->count)
 		: "r" (incr), "m" (sem->count));
 	} else {
-		static spinlock_t semaphore_lock = SPIN_LOCK_UNLOCKED;
+		static DEFINE_SPINLOCK(semaphore_lock);
 		unsigned long flags;
 
 		spin_lock_irqsave(&semaphore_lock, flags);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/setup.c linux-2.6.11-rc3/arch/mips/kernel/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/setup.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/setup.c	2005-02-03 02:55:15.000000000 +0100
@@ -281,12 +281,12 @@ static inline void bootmem_init(void)
 		initrd_reserve_bootmem = 1;
 	} else {
 		unsigned long tmp;
-		unsigned long *initrd_header;
+		u32 *initrd_header;
 
-		tmp = ((reserved_end + PAGE_SIZE-1) & PAGE_MASK) - 8;
+		tmp = ((reserved_end + PAGE_SIZE-1) & PAGE_MASK) - sizeof(u32) * 2;
 		if (tmp < reserved_end)
 			tmp += PAGE_SIZE;
-		initrd_header = (unsigned long *)tmp;
+		initrd_header = (u32 *)tmp;
 		if (initrd_header[0] == 0x494E5244) {
 			initrd_start = (unsigned long)&initrd_header[2];
 			initrd_end = initrd_start + initrd_header[1];
@@ -425,8 +425,10 @@ static inline void bootmem_init(void)
 		if (CPHYSADDR(initrd_end) > PFN_PHYS(max_low_pfn)) {
 			printk("initrd extends beyond end of memory "
 			       "(0x%0*Lx > 0x%0*Lx)\ndisabling initrd\n",
-			       sizeof(long) * 2, CPHYSADDR(initrd_end),
-			       sizeof(long) * 2, PFN_PHYS(max_low_pfn));
+			       sizeof(long) * 2,
+			       (unsigned long long)CPHYSADDR(initrd_end),
+			       sizeof(long) * 2,
+			       (unsigned long long)PFN_PHYS(max_low_pfn));
 			initrd_start = initrd_end = 0;
 			initrd_reserve_bootmem = 0;
 		}
@@ -441,10 +443,21 @@ static inline void resource_init(void)
 {
 	int i;
 
+#if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
+	/*
+	 * The 64bit code in 32bit object format trick can't represent
+	 * 64bit wide relocations for linker script symbols.
+	 */
+	code_resource.start = CPHYSADDR(&_text);
+	code_resource.end = CPHYSADDR(&_etext) - 1;
+	data_resource.start = CPHYSADDR(&_etext);
+	data_resource.end = CPHYSADDR(&_edata) - 1;
+#else
 	code_resource.start = virt_to_phys(&_text);
 	code_resource.end = virt_to_phys(&_etext) - 1;
 	data_resource.start = virt_to_phys(&_etext);
 	data_resource.end = virt_to_phys(&_edata) - 1;
+#endif
 
 	/*
 	 * Request address space for all standard RAM.
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/signal-common.h linux-2.6.11-rc3/arch/mips/kernel/signal-common.h
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/signal-common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/signal-common.h	2005-02-03 02:55:53.000000000 +0100
@@ -0,0 +1,137 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1991, 1992  Linus Torvalds
+ * Copyright (C) 1994 - 2000  Ralf Baechle
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ */
+
+static inline int
+setup_sigcontext(struct pt_regs *regs, struct sigcontext *sc)
+{
+	int err = 0;
+
+	err |= __put_user(regs->cp0_epc, &sc->sc_pc);
+	err |= __put_user(regs->cp0_status, &sc->sc_status);
+
+#define save_gp_reg(i) do {						\
+	err |= __put_user(regs->regs[i], &sc->sc_regs[i]);		\
+} while(0)
+	__put_user(0, &sc->sc_regs[0]); save_gp_reg(1); save_gp_reg(2);
+	save_gp_reg(3); save_gp_reg(4); save_gp_reg(5); save_gp_reg(6);
+	save_gp_reg(7); save_gp_reg(8); save_gp_reg(9); save_gp_reg(10);
+	save_gp_reg(11); save_gp_reg(12); save_gp_reg(13); save_gp_reg(14);
+	save_gp_reg(15); save_gp_reg(16); save_gp_reg(17); save_gp_reg(18);
+	save_gp_reg(19); save_gp_reg(20); save_gp_reg(21); save_gp_reg(22);
+	save_gp_reg(23); save_gp_reg(24); save_gp_reg(25); save_gp_reg(26);
+	save_gp_reg(27); save_gp_reg(28); save_gp_reg(29); save_gp_reg(30);
+	save_gp_reg(31);
+#undef save_gp_reg
+
+	err |= __put_user(regs->hi, &sc->sc_mdhi);
+	err |= __put_user(regs->lo, &sc->sc_mdlo);
+	err |= __put_user(regs->cp0_cause, &sc->sc_cause);
+	err |= __put_user(regs->cp0_badvaddr, &sc->sc_badvaddr);
+
+	err |= __put_user(!!used_math(), &sc->sc_used_math);
+
+	if (!used_math())
+		goto out;
+
+	/*
+	 * Save FPU state to signal context.  Signal handler will "inherit"
+	 * current FPU state.
+	 */
+	preempt_disable();
+
+	if (!is_fpu_owner()) {
+		own_fpu();
+		restore_fp(current);
+	}
+	err |= save_fp_context(sc);
+
+	preempt_enable();
+
+out:
+	return err;
+}
+
+static inline int
+restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc)
+{
+	int err = 0;
+	unsigned int used_math;
+
+	/* Always make any pending restarted system calls return -EINTR */
+	current_thread_info()->restart_block.fn = do_no_restart_syscall;
+
+	err |= __get_user(regs->cp0_epc, &sc->sc_pc);
+	err |= __get_user(regs->hi, &sc->sc_mdhi);
+	err |= __get_user(regs->lo, &sc->sc_mdlo);
+
+#define restore_gp_reg(i) do {						\
+	err |= __get_user(regs->regs[i], &sc->sc_regs[i]);		\
+} while(0)
+	restore_gp_reg( 1); restore_gp_reg( 2); restore_gp_reg( 3);
+	restore_gp_reg( 4); restore_gp_reg( 5); restore_gp_reg( 6);
+	restore_gp_reg( 7); restore_gp_reg( 8); restore_gp_reg( 9);
+	restore_gp_reg(10); restore_gp_reg(11); restore_gp_reg(12);
+	restore_gp_reg(13); restore_gp_reg(14); restore_gp_reg(15);
+	restore_gp_reg(16); restore_gp_reg(17); restore_gp_reg(18);
+	restore_gp_reg(19); restore_gp_reg(20); restore_gp_reg(21);
+	restore_gp_reg(22); restore_gp_reg(23); restore_gp_reg(24);
+	restore_gp_reg(25); restore_gp_reg(26); restore_gp_reg(27);
+	restore_gp_reg(28); restore_gp_reg(29); restore_gp_reg(30);
+	restore_gp_reg(31);
+#undef restore_gp_reg
+
+	err |= __get_user(used_math, &sc->sc_used_math);
+	conditional_used_math(used_math);
+
+	preempt_disable();
+
+	if (used_math()) {
+		/* restore fpu context if we have used it before */
+		own_fpu();
+		err |= restore_fp_context(sc);
+	} else {
+		/* signal handler may have used FPU.  Give it up. */
+		lose_fpu();
+	}
+
+	preempt_enable();
+
+	return err;
+}
+
+/*
+ * Determine which stack to use..
+ */
+static inline void *
+get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size)
+{
+	unsigned long sp, almask;
+
+	/* Default to using normal stack */
+	sp = regs->regs[29];
+
+	/*
+ 	 * FPU emulator may have it's own trampoline active just
+ 	 * above the user stack, 16-bytes before the next lowest
+ 	 * 16 byte boundary.  Try to avoid trashing it.
+ 	 */
+ 	sp -= 32;
+
+	/* This is the X/Open sanctioned signal stack switching.  */
+	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
+		sp = current->sas_ss_sp + current->sas_ss_size;
+
+	if (PLAT_TRAMPOLINE_STUFF_LINE)
+		almask = ~(PLAT_TRAMPOLINE_STUFF_LINE - 1);
+	else
+		almask = ALMASK;
+
+	return (void *)((sp - frame_size) & almask);
+}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/signal.c linux-2.6.11-rc3/arch/mips/kernel/signal.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/signal.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/signal.c	2005-02-03 02:57:16.000000000 +0100
@@ -28,12 +28,15 @@
 #include <asm/sim.h>
 #include <asm/uaccess.h>
 #include <asm/ucontext.h>
+#include <asm/cpu-features.h>
+
+#include "signal-common.h"
 
 #define DEBUG_SIG 0
 
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
-extern asmlinkage int do_signal(sigset_t *oldset, struct pt_regs *regs);
+static int do_signal(sigset_t *oldset, struct pt_regs *regs);
 
 /*
  * Atomically swap in the new signal mask, and wait for a signal.
@@ -151,51 +154,6 @@ asmlinkage int sys_sigaltstack(nabi_no_r
 	return do_sigaltstack(uss, uoss, usp);
 }
 
-asmlinkage int restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc)
-{
-	int err = 0;
-
-	/* Always make any pending restarted system calls return -EINTR */
-	current_thread_info()->restart_block.fn = do_no_restart_syscall;
-
-	err |= __get_user(regs->cp0_epc, &sc->sc_pc);
-	err |= __get_user(regs->hi, &sc->sc_mdhi);
-	err |= __get_user(regs->lo, &sc->sc_mdlo);
-
-#define restore_gp_reg(i) do {						\
-	err |= __get_user(regs->regs[i], &sc->sc_regs[i]);		\
-} while(0)
-	restore_gp_reg( 1); restore_gp_reg( 2); restore_gp_reg( 3);
-	restore_gp_reg( 4); restore_gp_reg( 5); restore_gp_reg( 6);
-	restore_gp_reg( 7); restore_gp_reg( 8); restore_gp_reg( 9);
-	restore_gp_reg(10); restore_gp_reg(11); restore_gp_reg(12);
-	restore_gp_reg(13); restore_gp_reg(14); restore_gp_reg(15);
-	restore_gp_reg(16); restore_gp_reg(17); restore_gp_reg(18);
-	restore_gp_reg(19); restore_gp_reg(20); restore_gp_reg(21);
-	restore_gp_reg(22); restore_gp_reg(23); restore_gp_reg(24);
-	restore_gp_reg(25); restore_gp_reg(26); restore_gp_reg(27);
-	restore_gp_reg(28); restore_gp_reg(29); restore_gp_reg(30);
-	restore_gp_reg(31);
-#undef restore_gp_reg
-
-	err |= __get_user(current->used_math, &sc->sc_used_math);
-
-	preempt_disable();
-
-	if (current->used_math) {
-		/* restore fpu context if we have used it before */
-		own_fpu();
-		err |= restore_fp_context(sc);
-	} else {
-		/* signal handler may have used FPU.  Give it up. */
-		lose_fpu();
-	}
-
-	preempt_enable();
-
-	return err;
-}
-
 #if PLAT_TRAMPOLINE_STUFF_LINE
 #define __tramp __attribute__((aligned(PLAT_TRAMPOLINE_STUFF_LINE)))
 #else
@@ -219,7 +177,9 @@ struct rt_sigframe {
 };
 
 #ifdef CONFIG_TRAD_SIGNALS
-asmlinkage void sys_sigreturn(struct pt_regs regs)
+save_static_function(sys_sigreturn);
+__attribute_used__ noinline static void
+_sys_sigreturn(nabi_no_regargs struct pt_regs regs)
 {
 	struct sigframe *frame;
 	sigset_t blocked;
@@ -256,7 +216,9 @@ badframe:
 }
 #endif
 
-asmlinkage void sys_rt_sigreturn(nabi_no_regargs struct pt_regs regs)
+save_static_function(sys_rt_sigreturn);
+__attribute_used__ noinline static void
+_sys_rt_sigreturn(nabi_no_regargs struct pt_regs regs)
 {
 	struct rt_sigframe *frame;
 	sigset_t set;
@@ -297,85 +259,6 @@ badframe:
 	force_sig(SIGSEGV, current);
 }
 
-inline int setup_sigcontext(struct pt_regs *regs, struct sigcontext *sc)
-{
-	int err = 0;
-
-	err |= __put_user(regs->cp0_epc, &sc->sc_pc);
-	err |= __put_user(regs->cp0_status, &sc->sc_status);
-
-#define save_gp_reg(i) do {						\
-	err |= __put_user(regs->regs[i], &sc->sc_regs[i]);		\
-} while(0)
-	__put_user(0, &sc->sc_regs[0]); save_gp_reg(1); save_gp_reg(2);
-	save_gp_reg(3); save_gp_reg(4); save_gp_reg(5); save_gp_reg(6);
-	save_gp_reg(7); save_gp_reg(8); save_gp_reg(9); save_gp_reg(10);
-	save_gp_reg(11); save_gp_reg(12); save_gp_reg(13); save_gp_reg(14);
-	save_gp_reg(15); save_gp_reg(16); save_gp_reg(17); save_gp_reg(18);
-	save_gp_reg(19); save_gp_reg(20); save_gp_reg(21); save_gp_reg(22);
-	save_gp_reg(23); save_gp_reg(24); save_gp_reg(25); save_gp_reg(26);
-	save_gp_reg(27); save_gp_reg(28); save_gp_reg(29); save_gp_reg(30);
-	save_gp_reg(31);
-#undef save_gp_reg
-
-	err |= __put_user(regs->hi, &sc->sc_mdhi);
-	err |= __put_user(regs->lo, &sc->sc_mdlo);
-	err |= __put_user(regs->cp0_cause, &sc->sc_cause);
-	err |= __put_user(regs->cp0_badvaddr, &sc->sc_badvaddr);
-
-	err |= __put_user(current->used_math, &sc->sc_used_math);
-
-	if (!current->used_math)
-		goto out;
-
-	/*
-	 * Save FPU state to signal context.  Signal handler will "inherit"
-	 * current FPU state.
-	 */
-	preempt_disable();
-
-	if (!is_fpu_owner()) {
-		own_fpu();
-		restore_fp(current);
-	}
-	err |= save_fp_context(sc);
-
-	preempt_enable();
-
-out:
-	return err;
-}
-
-/*
- * Determine which stack to use..
- */
-static inline void *get_sigframe(struct k_sigaction *ka, struct pt_regs *regs,
-	size_t frame_size)
-{
-	unsigned long sp, almask;
-
-	/* Default to using normal stack */
-	sp = regs->regs[29];
-
-	/*
- 	 * FPU emulator may have it's own trampoline active just
- 	 * above the user stack, 16-bytes before the next lowest
- 	 * 16 byte boundary.  Try to avoid trashing it.
- 	 */
- 	sp -= 32;
-
-	/* This is the X/Open sanctioned signal stack switching.  */
-	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
-		sp = current->sas_ss_sp + current->sas_ss_size;
-
-	if (PLAT_TRAMPOLINE_STUFF_LINE)
-		almask = ~(PLAT_TRAMPOLINE_STUFF_LINE - 1);
-	else
-		almask = ALMASK;
-
-	return (void *)((sp - frame_size) & ~(PLAT_TRAMPOLINE_STUFF_LINE - 1));
-}
-
 #ifdef CONFIG_TRAD_SIGNALS
 static void inline setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
 	int signr, sigset_t *set)
@@ -394,8 +277,7 @@ static void inline setup_frame(struct k_
 	 *         syscall
 	 */
 	if (PLAT_TRAMPOLINE_STUFF_LINE)
-		__builtin_memset(frame->sf_code, '0',
-		                 PLAT_TRAMPOLINE_STUFF_LINE);
+		__clear_user(frame->sf_code, PLAT_TRAMPOLINE_STUFF_LINE);
 	err |= __put_user(0x24020000 + __NR_sigreturn, frame->sf_code + 0);
 	err |= __put_user(0x0000000c                 , frame->sf_code + 1);
 	flush_cache_sigtramp((unsigned long) frame->sf_code);
@@ -451,8 +333,7 @@ static void inline setup_rt_frame(struct
 	 *         syscall
 	 */
 	if (PLAT_TRAMPOLINE_STUFF_LINE)
-		__builtin_memset(frame->rs_code, '0',
-		                 PLAT_TRAMPOLINE_STUFF_LINE);
+		__clear_user(frame->rs_code, PLAT_TRAMPOLINE_STUFF_LINE);
 	err |= __put_user(0x24020000 + __NR_rt_sigreturn, frame->rs_code + 0);
 	err |= __put_user(0x0000000c                    , frame->rs_code + 1);
 	flush_cache_sigtramp((unsigned long) frame->rs_code);
@@ -556,7 +437,7 @@ static inline void handle_signal(unsigne
 extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
 extern int do_irix_signal(sigset_t *oldset, struct pt_regs *regs);
 
-asmlinkage int do_signal(sigset_t *oldset, struct pt_regs *regs)
+static int do_signal(sigset_t *oldset, struct pt_regs *regs)
 {
 	struct k_sigaction ka;
 	siginfo_t info;
@@ -610,8 +491,6 @@ no_signal:
 	return 0;
 }
 
-extern int do_irix_signal(sigset_t *oldset, struct pt_regs *regs);
-
 /*
  * notification of userspace execution resumption
  * - triggered by current->work.notify_resume
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/signal32.c linux-2.6.11-rc3/arch/mips/kernel/signal32.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/signal32.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/signal32.c	2005-02-03 02:55:52.000000000 +0100
@@ -37,7 +37,7 @@ typedef union sigval32 {
 	s32 sival_ptr;
 } sigval_t32;
 
-typedef struct compat_siginfo{
+typedef struct compat_siginfo {
 	int si_signo;
 	int si_code;
 	int si_errno;
@@ -106,7 +106,7 @@ typedef struct compat_siginfo{
 
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
-extern asmlinkage int do_signal32(sigset_t *oldset, struct pt_regs *regs);
+extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
 
 /* 32-bit compatibility types */
 
@@ -192,6 +192,7 @@ static inline int get_sigset(sigset_t *k
 /*
  * Atomically swap in the new signal mask, and wait for a signal.
  */
+
 save_static_function(sys32_sigsuspend);
 __attribute_used__ noinline static int
 _sys32_sigsuspend(nabi_no_regargs struct pt_regs regs)
@@ -333,10 +334,10 @@ asmlinkage int sys32_sigaltstack(nabi_no
 	return ret;
 }
 
-static asmlinkage int restore_sigcontext32(struct pt_regs *regs,
-					   struct sigcontext32 *sc)
+static int restore_sigcontext32(struct pt_regs *regs, struct sigcontext32 *sc)
 {
 	int err = 0;
+	__u32 used_math;
 
 	/* Always make any pending restarted system calls return -EINTR */
 	current_thread_info()->restart_block.fn = do_no_restart_syscall;
@@ -361,11 +362,12 @@ static asmlinkage int restore_sigcontext
 	restore_gp_reg(31);
 #undef restore_gp_reg
 
-	err |= __get_user(current->used_math, &sc->sc_used_math);
+	err |= __get_user(used_math, &sc->sc_used_math);
+	conditional_used_math(used_math);
 
 	preempt_disable();
 
-	if (current->used_math) {
+	if (used_math()) {
 		/* restore fpu context if we have used it before */
 		own_fpu();
 		err |= restore_fp_context32(sc);
@@ -389,7 +391,7 @@ struct sigframe {
 struct rt_sigframe32 {
 	u32 rs_ass[4];			/* argument save space for o32 */
 	u32 rs_code[2];			/* signal trampoline */
-	struct compat_siginfo_t rs_info;
+	compat_siginfo_t rs_info;
 	struct ucontext32 rs_uc;
 };
 
@@ -440,7 +442,9 @@ int copy_siginfo_to_user32(compat_siginf
 	return err;
 }
 
-asmlinkage void sys32_sigreturn(nabi_no_regargs struct pt_regs regs)
+save_static_function(sys32_sigreturn);
+__attribute_used__ noinline static void
+_sys32_sigreturn(nabi_no_regargs struct pt_regs regs)
 {
 	struct sigframe *frame;
 	sigset_t blocked;
@@ -476,7 +480,9 @@ badframe:
 	force_sig(SIGSEGV, current);
 }
 
-asmlinkage void sys32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)
+save_static_function(sys32_rt_sigreturn);
+__attribute_used__ noinline static void
+_sys32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)
 {
 	struct rt_sigframe32 *frame;
 	sigset_t set;
@@ -552,9 +558,9 @@ static inline int setup_sigcontext32(str
 	err |= __put_user(regs->cp0_cause, &sc->sc_cause);
 	err |= __put_user(regs->cp0_badvaddr, &sc->sc_badvaddr);
 
-	err |= __put_user(current->used_math, &sc->sc_used_math);
+	err |= __put_user(!!used_math(), &sc->sc_used_math);
 
-	if (!current->used_math)
+	if (!used_math())
 		goto out;
 
 	/* 
@@ -759,7 +765,7 @@ static inline void handle_signal(unsigne
 	}
 }
 
-asmlinkage int do_signal32(sigset_t *oldset, struct pt_regs *regs)
+int do_signal32(sigset_t *oldset, struct pt_regs *regs)
 {
 	struct k_sigaction ka;
 	siginfo_t info;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/signal_n32.c linux-2.6.11-rc3/arch/mips/kernel/signal_n32.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/signal_n32.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/signal_n32.c	2005-02-03 02:56:10.000000000 +0100
@@ -35,9 +35,12 @@
 #include <asm/ucontext.h>
 #include <asm/system.h>
 #include <asm/fpu.h>
+#include <asm/cpu-features.h>
+
+#include "signal-common.h"
 
 /*
- * Including <asm/unistd.h would give use the 64-bit syscall numbers ...
+ * Including <asm/unistd.h> would give use the 64-bit syscall numbers ...
  */
 #define __NR_N32_rt_sigreturn		6211
 #define __NR_N32_restart_syscall	6214
@@ -59,17 +62,22 @@ struct ucontextn32 {
 	sigset_t            uc_sigmask;   /* mask last for extensibility */
 };
 
+#if PLAT_TRAMPOLINE_STUFF_LINE
+#define __tramp __attribute__((aligned(PLAT_TRAMPOLINE_STUFF_LINE)))
+#else
+#define __tramp
+#endif
+
 struct rt_sigframe_n32 {
 	u32 rs_ass[4];			/* argument save space for o32 */
-	u32 rs_code[2];			/* signal trampoline */
-	struct siginfo rs_info;
+	u32 rs_code[2] __tramp;		/* signal trampoline */
+	struct siginfo rs_info __tramp;
 	struct ucontextn32 rs_uc;
 };
 
-extern asmlinkage int restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc);
-extern int inline setup_sigcontext(struct pt_regs *regs, struct sigcontext *sc);
-
-asmlinkage void sysn32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)
+save_static_function(sysn32_rt_sigreturn);
+__attribute_used__ noinline static void
+_sysn32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)
 {
 	struct rt_sigframe_n32 *frame;
 	sigset_t set;
@@ -118,31 +126,6 @@ badframe:
 	force_sig(SIGSEGV, current);
 }
 
-/*
- * Determine which stack to use..
- */
-static inline void *get_sigframe(struct k_sigaction *ka, struct pt_regs *regs,
-	size_t frame_size)
-{
-	unsigned long sp;
-
-	/* Default to using normal stack */
-	sp = regs->regs[29];
-
-	/*
- 	 * FPU emulator may have it's own trampoline active just
- 	 * above the user stack, 16-bytes before the next lowest
- 	 * 16 byte boundary.  Try to avoid trashing it.
- 	 */
- 	sp -= 32;
-
-	/* This is the X/Open sanctioned signal stack switching.  */
-	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
-		sp = current->sas_ss_sp + current->sas_ss_size;
-
-	return (void *)((sp - frame_size) & ALMASK);
-}
-
 void setup_rt_frame_n32(struct k_sigaction * ka,
 	struct pt_regs *regs, int signr, sigset_t *set, siginfo_t *info)
 {
@@ -160,8 +143,10 @@ void setup_rt_frame_n32(struct k_sigacti
 	 *         li      v0, __NR_rt_sigreturn
 	 *         syscall
 	 */
+	if (PLAT_TRAMPOLINE_STUFF_LINE)
+		__clear_user(frame->rs_code, PLAT_TRAMPOLINE_STUFF_LINE);
 	err |= __put_user(0x24020000 + __NR_N32_rt_sigreturn, frame->rs_code + 0);
-	err |= __put_user(0x0000000c                    , frame->rs_code + 1);
+	err |= __put_user(0x0000000c                        , frame->rs_code + 1);
 	flush_cache_sigtramp((unsigned long) frame->rs_code);
 
 	/* Create siginfo.  */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/smp.c linux-2.6.11-rc3/arch/mips/kernel/smp.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/smp.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/smp.c	2005-02-03 02:55:15.000000000 +0100
@@ -18,7 +18,6 @@
  * Copyright (C) 2000, 2001 Silicon Graphics, Inc.
  * Copyright (C) 2000, 2001, 2003 Broadcom Corporation
  */
-#include <linux/config.h>
 #include <linux/cache.h>
 #include <linux/delay.h>
 #include <linux/init.h>
@@ -94,6 +93,7 @@ static void smp_tune_scheduling (void)
 }
 
 extern void __init calibrate_delay(void);
+extern ATTRIB_NORET void cpu_idle(void);
 
 /*
  * First C code run on the secondary CPUs after being started up by
@@ -123,7 +123,7 @@ asmlinkage void start_secondary(void)
 	cpu_idle();
 }
 
-spinlock_t smp_call_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(smp_call_lock);
 
 struct call_data_struct *call_data;
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/syscall.c linux-2.6.11-rc3/arch/mips/kernel/syscall.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/syscall.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/syscall.c	2005-02-03 02:56:33.000000000 +0100
@@ -3,10 +3,11 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1995, 1996, 1997, 2000, 2001 by Ralf Baechle
+ * Copyright (C) 1995, 1996, 1997, 2000, 2001, 05 by Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 2001 MIPS Technologies, Inc.
  */
+#include <linux/a.out.h>
 #include <linux/errno.h>
 #include <linux/linkage.h>
 #include <linux/mm.h>
@@ -66,11 +67,7 @@ unsigned long arch_get_unmapped_area(str
 	int do_color_align;
 	unsigned long task_size;
 
-#ifdef CONFIG_MIPS32
-	task_size = TASK_SIZE;
-#else
-	task_size = (current->thread.mflags & MF_32BIT_ADDR) ? TASK_SIZE32 : TASK_SIZE;
-#endif
+	task_size = STACK_TOP;
 
 	if (flags & MAP_FIXED) {
 		/*
@@ -116,7 +113,7 @@ unsigned long arch_get_unmapped_area(str
 }
 
 /* common code for old and new mmaps */
-static inline long
+static inline unsigned long
 do_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
         unsigned long flags, unsigned long fd, unsigned long pgoff)
 {
@@ -140,8 +137,9 @@ out:
 	return error;
 }
 
-asmlinkage unsigned long old_mmap(unsigned long addr, size_t len, int prot,
-                                  int flags, int fd, off_t offset)
+asmlinkage unsigned long
+old_mmap(unsigned long addr, unsigned long len, int prot,
+	int flags, int fd, off_t offset)
 {
 	unsigned long result;
 
@@ -155,7 +153,7 @@ out:
 	return result;
 }
 
-asmlinkage long
+asmlinkage unsigned long
 sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
           unsigned long flags, unsigned long fd, unsigned long pgoff)
 {
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/sysirix.c linux-2.6.11-rc3/arch/mips/kernel/sysirix.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/sysirix.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/sysirix.c	2005-02-03 02:56:48.000000000 +0100
@@ -1648,7 +1648,7 @@ asmlinkage int irix_statvfs64(char *fnam
 	struct kstatfs kbuf;
 	int error, i;
 
-	printk("[%s:%d] Wheee.. irix_statvfs(%s,%p)\n",
+	printk("[%s:%d] Wheee.. irix_statvfs64(%s,%p)\n",
 	       current->comm, current->pid, fname, buf);
 	error = verify_area(VERIFY_WRITE, buf, sizeof(struct irix_statvfs64));
 	if(error)
@@ -1694,7 +1694,7 @@ asmlinkage int irix_fstatvfs64(int fd, s
 	struct file *file;
 	int error, i;
 
-	printk("[%s:%d] Wheee.. irix_fstatvfs(%d,%p)\n",
+	printk("[%s:%d] Wheee.. irix_fstatvfs64(%d,%p)\n",
 	       current->comm, current->pid, fd, buf);
 
 	error = verify_area(VERIFY_WRITE, buf, sizeof(struct irix_statvfs));
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/time.c linux-2.6.11-rc3/arch/mips/kernel/time.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/time.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/time.c	2005-02-03 02:55:50.000000000 +0100
@@ -11,7 +11,6 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -53,7 +52,7 @@ EXPORT_SYMBOL(jiffies_64);
  */
 extern volatile unsigned long wall_jiffies;
 
-spinlock_t rtc_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(rtc_lock);
 
 /*
  * By default we provide the null RTC ops
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/traps.c linux-2.6.11-rc3/arch/mips/kernel/traps.c
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/traps.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/traps.c	2005-02-03 02:55:50.000000000 +0100
@@ -38,12 +38,9 @@
 #include <asm/watch.h>
 #include <asm/types.h>
 
-extern asmlinkage void handle_mod(void);
+extern asmlinkage void handle_tlbm(void);
 extern asmlinkage void handle_tlbl(void);
 extern asmlinkage void handle_tlbs(void);
-extern asmlinkage void __xtlb_mod(void);
-extern asmlinkage void __xtlb_tlbl(void);
-extern asmlinkage void __xtlb_tlbs(void);
 extern asmlinkage void handle_adel(void);
 extern asmlinkage void handle_ades(void);
 extern asmlinkage void handle_ibe(void);
@@ -82,7 +79,12 @@ void show_stack(struct task_struct *task
 	long stackdata;
 	int i;
 
-	sp = sp ? sp : (unsigned long *) &sp;
+	if (!sp) {
+		if (task && task != current)
+			sp = (unsigned long *) task->thread.reg29;
+		else
+			sp = (unsigned long *) &sp;
+	}
 
 	printk("Stack :");
 	i = 0;
@@ -110,8 +112,12 @@ void show_trace(struct task_struct *task
 	const int field = 2 * sizeof(unsigned long);
 	unsigned long addr;
 
-	if (!stack)
-		stack = (unsigned long*)&stack;
+	if (!stack) {
+		if (task && task != current)
+			stack = (unsigned long *) task->thread.reg29;
+		else
+			stack = (unsigned long *) &stack;
+	}
 
 	printk("Call Trace:");
 #ifdef CONFIG_KALLSYMS
@@ -244,7 +250,7 @@ void show_registers(struct pt_regs *regs
 	printk("\n");
 }
 
-static spinlock_t die_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(die_lock);
 
 NORET_TYPE void __die(const char * str, struct pt_regs * regs,
 	const char * file, const char * func, unsigned long line)
@@ -655,11 +661,11 @@ asmlinkage void do_cpu(struct pt_regs *r
 		preempt_disable();
 
 		own_fpu();
-		if (current->used_math) {	/* Using the FPU again.  */
+		if (used_math()) {	/* Using the FPU again.  */
 			restore_fp(current);
 		} else {			/* First time FPU user.  */
 			init_fpu();
-			current->used_math = 1;
+			set_used_math();
 		}
 
 		if (!cpu_has_fpu) {
@@ -1001,16 +1007,10 @@ void __init trap_init(void)
 	if (board_be_init)
 		board_be_init();
 
-#ifdef CONFIG_MIPS32
-	set_except_vector(1, handle_mod);
+	set_except_vector(1, handle_tlbm);
 	set_except_vector(2, handle_tlbl);
 	set_except_vector(3, handle_tlbs);
-#endif
-#ifdef CONFIG_MIPS64
-	set_except_vector(1, __xtlb_mod);
-	set_except_vector(2, __xtlb_tlbl);
-	set_except_vector(3, __xtlb_tlbs);
-#endif
+
 	set_except_vector(4, handle_adel);
 	set_except_vector(5, handle_ades);
 
@@ -1047,7 +1047,7 @@ void __init trap_init(void)
 		 * unaligned ldc1/sdc1 exception.  The handlers have not been
 		 * written yet.  Well, anyway there is no R6000 machine on the
 		 * current list of targets for Linux/MIPS.
-		 * (Duh, crap, there is someone with a tripple R6k machine)
+		 * (Duh, crap, there is someone with a triple R6k machine)
 		 */
 		//set_except_vector(14, handle_mc);
 		//set_except_vector(15, handle_ndc);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/kernel/vmlinux.lds.S linux-2.6.11-rc3/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.11-rc2-bk10/arch/mips/kernel/vmlinux.lds.S	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/kernel/vmlinux.lds.S	2005-02-03 02:55:36.000000000 +0100
@@ -156,6 +156,7 @@ SECTIONS
 	*(.options)
 	*(.pdr)
 	*(.reginfo)
+	*(.mdebug*)
   }
 
   /* This is the MIPS specific mdebug section.  */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/lib/Makefile linux-2.6.11-rc3/arch/mips/lib/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/lib/Makefile	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/lib/Makefile	2005-02-03 02:55:07.000000000 +0100
@@ -2,7 +2,7 @@
 # Makefile for MIPS-specific library files..
 #
 
-lib-y	+= csum_partial_copy.o dec_and_lock.o memcpy.o promlib.o strlen_user.o \
-	   strncpy_user.o strnlen_user.o
+lib-y	+= csum_partial_copy.o dec_and_lock.o iomap.o memcpy.o promlib.o \
+	   strlen_user.o strncpy_user.o strnlen_user.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/lib/iomap.c linux-2.6.11-rc3/arch/mips/lib/iomap.c
--- linux-2.6.11-rc2-bk10/arch/mips/lib/iomap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/lib/iomap.c	2005-02-03 02:55:07.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ *  iomap.c, Memory Mapped I/O routines for MIPS architecture.
+ *
+ *  This code is based on lib/iomap.c, by Linus Torvalds.
+ *
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+
+void __iomem *ioport_map(unsigned long port, unsigned int nr)
+{
+	unsigned long end;
+
+	end = port + nr - 1UL;
+	if (ioport_resource.start > port ||
+	    ioport_resource.end < end || port > end)
+		return NULL;
+
+	return (void __iomem *)(mips_io_port_base + port);
+}
+
+void ioport_unmap(void __iomem *addr)
+{
+}
+EXPORT_SYMBOL(ioport_map);
+EXPORT_SYMBOL(ioport_unmap);
+
+void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
+{
+	unsigned long start, len, flags;
+
+	if (dev == NULL)
+		return NULL;
+
+	start = pci_resource_start(dev, bar);
+	len = pci_resource_len(dev, bar);
+	if (!start || !len)
+		return NULL;
+
+	if (maxlen != 0 && len > maxlen)
+		len = maxlen;
+
+	flags = pci_resource_flags(dev, bar);
+	if (flags & IORESOURCE_IO)
+		return ioport_map(start, len);
+	if (flags & IORESOURCE_MEM) {
+		if (flags & IORESOURCE_CACHEABLE)
+			return ioremap_cacheable_cow(start, len);
+		return ioremap_nocache(start, len);
+	}
+
+	return NULL;
+}
+
+void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
+{
+	iounmap(addr);
+}
+EXPORT_SYMBOL(pci_iomap);
+EXPORT_SYMBOL(pci_iounmap);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/lib-64/dump_tlb.c linux-2.6.11-rc3/arch/mips/lib-64/dump_tlb.c
--- linux-2.6.11-rc2-bk10/arch/mips/lib-64/dump_tlb.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/lib-64/dump_tlb.c	2005-02-03 02:57:16.000000000 +0100
@@ -148,16 +148,16 @@ void dump_list_process(struct task_struc
 	printk("tasks->mm.pgd        == %08lx\n", (unsigned long) t->mm->pgd);
 
 	page_dir = pgd_offset(t->mm, 0);
-	printk("page_dir == %08lx\n", (unsigned long) page_dir);
+	printk("page_dir == %016lx\n", (unsigned long) page_dir);
 
 	pgd = pgd_offset(t->mm, addr);
-	printk("pgd == %08lx, ", (unsigned long) pgd);
+	printk("pgd == %016lx\n", (unsigned long) pgd);
 
 	pmd = pmd_offset(pgd, addr);
-	printk("pmd == %08lx, ", (unsigned long) pmd);
+	printk("pmd == %016lx\n", (unsigned long) pmd);
 
 	pte = pte_offset(pmd, addr);
-	printk("pte == %08lx, ", (unsigned long) pte);
+	printk("pte == %016lx\n", (unsigned long) pte);
 
 	page = *pte;
 	printk("page == %08lx\n", pte_val(page));
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/cp1emu.c linux-2.6.11-rc3/arch/mips/math-emu/cp1emu.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/cp1emu.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/cp1emu.c	2005-02-03 02:56:48.000000000 +0100
@@ -2,7 +2,7 @@
  * cp1emu.c: a MIPS coprocessor 1 (fpu) instruction emulator
  *
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_add.c linux-2.6.11-rc3/arch/mips/math-emu/dp_add.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_add.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_add.c	2005-02-03 02:55:23.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_cmp.c linux-2.6.11-rc3/arch/mips/math-emu/dp_cmp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_cmp.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_cmp.c	2005-02-03 02:56:34.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_div.c linux-2.6.11-rc3/arch/mips/math-emu/dp_div.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_div.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_div.c	2005-02-03 02:55:07.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_fint.c linux-2.6.11-rc3/arch/mips/math-emu/dp_fint.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_fint.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_fint.c	2005-02-03 02:56:48.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_flong.c linux-2.6.11-rc3/arch/mips/math-emu/dp_flong.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_flong.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_flong.c	2005-02-03 02:56:21.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_frexp.c linux-2.6.11-rc3/arch/mips/math-emu/dp_frexp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_frexp.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_frexp.c	2005-02-03 02:55:22.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_fsp.c linux-2.6.11-rc3/arch/mips/math-emu/dp_fsp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_fsp.c	2005-01-22 02:47:16.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_fsp.c	2005-02-03 02:55:14.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_logb.c linux-2.6.11-rc3/arch/mips/math-emu/dp_logb.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_logb.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_logb.c	2005-02-03 02:55:03.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_modf.c linux-2.6.11-rc3/arch/mips/math-emu/dp_modf.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_modf.c	2005-01-22 02:48:27.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_modf.c	2005-02-03 02:56:10.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_mul.c linux-2.6.11-rc3/arch/mips/math-emu/dp_mul.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_mul.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_mul.c	2005-02-03 02:55:50.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_scalb.c linux-2.6.11-rc3/arch/mips/math-emu/dp_scalb.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_scalb.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_scalb.c	2005-02-03 02:56:53.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_simple.c linux-2.6.11-rc3/arch/mips/math-emu/dp_simple.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_simple.c	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_simple.c	2005-02-03 02:56:33.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_sqrt.c linux-2.6.11-rc3/arch/mips/math-emu/dp_sqrt.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_sqrt.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_sqrt.c	2005-02-03 02:56:48.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_sub.c linux-2.6.11-rc3/arch/mips/math-emu/dp_sub.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_sub.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_sub.c	2005-02-03 02:56:22.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_tint.c linux-2.6.11-rc3/arch/mips/math-emu/dp_tint.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_tint.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_tint.c	2005-02-03 02:55:07.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_tlong.c linux-2.6.11-rc3/arch/mips/math-emu/dp_tlong.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/dp_tlong.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/dp_tlong.c	2005-02-03 02:55:50.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754.c linux-2.6.11-rc3/arch/mips/math-emu/ieee754.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754.c	2005-02-03 02:54:59.000000000 +0100
@@ -8,7 +8,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754.h linux-2.6.11-rc3/arch/mips/math-emu/ieee754.h
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754.h	2005-02-03 02:55:08.000000000 +0100
@@ -3,7 +3,7 @@
 */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754d.c linux-2.6.11-rc3/arch/mips/math-emu/ieee754d.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754d.c	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754d.c	2005-02-03 02:56:48.000000000 +0100
@@ -3,7 +3,7 @@
  *
  * MIPS floating point support
  *
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  *  This program is free software; you can distribute it and/or modify it
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754dp.c linux-2.6.11-rc3/arch/mips/math-emu/ieee754dp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754dp.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754dp.c	2005-02-03 02:56:22.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754dp.h linux-2.6.11-rc3/arch/mips/math-emu/ieee754dp.h
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754dp.h	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754dp.h	2005-02-03 02:56:10.000000000 +0100
@@ -4,7 +4,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754int.h linux-2.6.11-rc3/arch/mips/math-emu/ieee754int.h
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754int.h	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754int.h	2005-02-03 02:56:10.000000000 +0100
@@ -4,7 +4,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754m.c linux-2.6.11-rc3/arch/mips/math-emu/ieee754m.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754m.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754m.c	2005-02-03 02:55:53.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754sp.c linux-2.6.11-rc3/arch/mips/math-emu/ieee754sp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754sp.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754sp.c	2005-02-03 02:55:36.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754sp.h linux-2.6.11-rc3/arch/mips/math-emu/ieee754sp.h
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754sp.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754sp.h	2005-02-03 02:57:04.000000000 +0100
@@ -4,7 +4,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754xcpt.c linux-2.6.11-rc3/arch/mips/math-emu/ieee754xcpt.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/ieee754xcpt.c	2005-01-22 02:47:16.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/ieee754xcpt.c	2005-02-03 02:55:14.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_add.c linux-2.6.11-rc3/arch/mips/math-emu/sp_add.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_add.c	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_add.c	2005-02-03 02:56:33.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_cmp.c linux-2.6.11-rc3/arch/mips/math-emu/sp_cmp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_cmp.c	2005-01-22 02:46:42.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_cmp.c	2005-02-03 02:54:38.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_div.c linux-2.6.11-rc3/arch/mips/math-emu/sp_div.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_div.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_div.c	2005-02-03 02:57:17.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_fdp.c linux-2.6.11-rc3/arch/mips/math-emu/sp_fdp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_fdp.c	2005-01-22 02:48:01.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_fdp.c	2005-02-03 02:55:52.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_fint.c linux-2.6.11-rc3/arch/mips/math-emu/sp_fint.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_fint.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_fint.c	2005-02-03 02:55:36.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_flong.c linux-2.6.11-rc3/arch/mips/math-emu/sp_flong.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_flong.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_flong.c	2005-02-03 02:56:35.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_frexp.c linux-2.6.11-rc3/arch/mips/math-emu/sp_frexp.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_frexp.c	2005-01-22 02:46:41.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_frexp.c	2005-02-03 02:54:38.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_logb.c linux-2.6.11-rc3/arch/mips/math-emu/sp_logb.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_logb.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_logb.c	2005-02-03 02:56:33.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_modf.c linux-2.6.11-rc3/arch/mips/math-emu/sp_modf.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_modf.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_modf.c	2005-02-03 02:56:49.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_mul.c linux-2.6.11-rc3/arch/mips/math-emu/sp_mul.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_mul.c	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_mul.c	2005-02-03 02:56:10.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_scalb.c linux-2.6.11-rc3/arch/mips/math-emu/sp_scalb.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_scalb.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_scalb.c	2005-02-03 02:57:04.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_simple.c linux-2.6.11-rc3/arch/mips/math-emu/sp_simple.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_simple.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_simple.c	2005-02-03 02:55:53.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_sqrt.c linux-2.6.11-rc3/arch/mips/math-emu/sp_sqrt.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_sqrt.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_sqrt.c	2005-02-03 02:55:07.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_sub.c linux-2.6.11-rc3/arch/mips/math-emu/sp_sub.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_sub.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_sub.c	2005-02-03 02:55:36.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_tint.c linux-2.6.11-rc3/arch/mips/math-emu/sp_tint.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_tint.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_tint.c	2005-02-03 02:57:03.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_tlong.c linux-2.6.11-rc3/arch/mips/math-emu/sp_tlong.c
--- linux-2.6.11-rc2-bk10/arch/mips/math-emu/sp_tlong.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/math-emu/sp_tlong.c	2005-02-03 02:57:04.000000000 +0100
@@ -3,7 +3,7 @@
  */
 /*
  * MIPS floating point support
- * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.
+ * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
  * ########################################################################
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mips-boards/atlas/atlas_int.c linux-2.6.11-rc3/arch/mips/mips-boards/atlas/atlas_int.c
--- linux-2.6.11-rc2-bk10/arch/mips/mips-boards/atlas/atlas_int.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mips-boards/atlas/atlas_int.c	2005-02-03 02:56:22.000000000 +0100
@@ -23,7 +23,6 @@
  * Atlas board.
  *
  */
-#include <linux/config.h>
 #include <linux/compiler.h>
 #include <linux/init.h>
 #include <linux/sched.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mips-boards/generic/gdb_hook.c linux-2.6.11-rc3/arch/mips/mips-boards/generic/gdb_hook.c
--- linux-2.6.11-rc2-bk10/arch/mips/mips-boards/generic/gdb_hook.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mips-boards/generic/gdb_hook.c	2005-02-03 02:55:36.000000000 +0100
@@ -18,7 +18,6 @@
  * This is the interface to the remote debugger stub.
  */
 #include <linux/types.h>
-#include <linux/config.h>
 #include <linux/serial.h>
 #include <linux/serialP.h>
 #include <linux/serial_reg.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mips-boards/malta/malta_int.c linux-2.6.11-rc3/arch/mips/mips-boards/malta/malta_int.c
--- linux-2.6.11-rc2-bk10/arch/mips/mips-boards/malta/malta_int.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mips-boards/malta/malta_int.c	2005-02-03 02:55:23.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000, 2001 MIPS Technologies, Inc.
+ * Copyright (C) 2000, 2001, 2004 MIPS Technologies, Inc.
  * Copyright (C) 2001 Ralf Baechle
  *
  *  This program is free software; you can distribute it and/or modify it
@@ -21,7 +21,6 @@
  * The interrupt controller is located in the South Bridge a PIIX4 device
  * with two internal 82C95 interrupt controllers.
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/sched.h>
@@ -41,7 +40,7 @@
 
 extern asmlinkage void mipsIRQ(void);
 
-static spinlock_t mips_irq_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(mips_irq_lock);
 
 static inline int mips_pcibios_iack(void)
 {
@@ -155,9 +154,9 @@ void corehi_irqdispatch(struct pt_regs *
         case MIPS_REVISION_CORID_CORE_FPGAR2:
                 data = GT_READ(GT_INTRCAUSE_OFS);
                 printk("GT_INTRCAUSE = %08x\n", data);
-                data = GT_READ(0x70);
-                datahi = GT_READ(0x78);
-                printk("GT_CPU_ERR_ADDR = %02x%08x\n", datahi, data);
+                data = GT_READ(GT_CPUERR_ADDRLO_OFS);
+                datahi = GT_READ(GT_CPUERR_ADDRHI_OFS);
+                printk("GT_CPUERR_ADDR = %02x%08x\n", datahi, data);
                 break;
         case MIPS_REVISION_CORID_BONITO64:
         case MIPS_REVISION_CORID_CORE_20K:
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/Makefile linux-2.6.11-rc3/arch/mips/mm/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/mm/Makefile	2005-01-22 02:48:27.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/Makefile	2005-02-03 02:56:10.000000000 +0100
@@ -3,7 +3,7 @@
 #
 
 obj-y				+= cache.o extable.o fault.o init.o pgtable.o \
-				   tlbex.o
+				   tlbex.o tlbex-fault.o
 
 obj-$(CONFIG_MIPS32)		+= ioremap.o pgtable-32.o
 obj-$(CONFIG_MIPS64)		+= pgtable-64.o
@@ -27,40 +27,6 @@ obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o pg-
 obj-$(CONFIG_CPU_TX49XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_VR41XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 
-#
-# TLB exception handling code differs between 32-bit and 64-bit kernels.
-#
-ifdef CONFIG_MIPS32
-obj-$(CONFIG_CPU_R3000)		+= tlbex32-r3k.o
-obj-$(CONFIG_CPU_TX49XX)	+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_R4300)		+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_R4X00)		+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_VR41XX)	+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_R5000)		+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_NEVADA)	+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_R5432)		+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_RM7000)	+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_RM9000)	+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_R10000)	+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_MIPS32)	+= tlbex32-mips32.o
-obj-$(CONFIG_CPU_MIPS64)	+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_SB1)		+= tlbex32-r4k.o
-obj-$(CONFIG_CPU_TX39XX)	+= tlbex32-r3k.o
-endif
-ifdef CONFIG_MIPS64
-obj-$(CONFIG_CPU_R4300)		+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_R4X00)		+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_R5000)		+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_NEVADA)	+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_R5432)		+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_RM7000)	+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_RM9000)	+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_R10000)	+= tlb64-glue-r4k.o
-obj-$(CONFIG_CPU_SB1)		+= tlb64-glue-sb1.o
-obj-$(CONFIG_CPU_MIPS64)	+= tlb64-glue-r4k.o
-endif
-
-
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
 obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm7k.o
@@ -68,8 +34,11 @@ obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm
 #
 # Choose one DMA coherency model
 #
+ifndef CONFIG_OWN_DMA
 obj-$(CONFIG_DMA_COHERENT)	+= dma-coherent.o
 obj-$(CONFIG_DMA_NONCOHERENT)	+= dma-noncoherent.o
+endif
 obj-$(CONFIG_DMA_IP27)		+= dma-ip27.o
+obj-$(CONFIG_DMA_IP32)		+= dma-ip32.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/c-r4k.c linux-2.6.11-rc3/arch/mips/mm/c-r4k.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/c-r4k.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/c-r4k.c	2005-02-03 02:56:49.000000000 +0100
@@ -238,6 +238,22 @@ static inline void r4k_blast_scache_page
 		r4k_blast_scache_page = blast_scache128_page;
 }
 
+static void (* r4k_blast_scache_page_indexed)(unsigned long addr);
+
+static inline void r4k_blast_scache_page_indexed_setup(void)
+{
+	unsigned long sc_lsize = cpu_scache_line_size();
+
+	if (sc_lsize == 16)
+		r4k_blast_scache_page_indexed = blast_scache16_page_indexed;
+	else if (sc_lsize == 32)
+		r4k_blast_scache_page_indexed = blast_scache32_page_indexed;
+	else if (sc_lsize == 64)
+		r4k_blast_scache_page_indexed = blast_scache64_page_indexed;
+	else if (sc_lsize == 128)
+		r4k_blast_scache_page_indexed = blast_scache128_page_indexed;
+}
+
 static void (* r4k_blast_scache)(void);
 
 static inline void r4k_blast_scache_setup(void)
@@ -318,9 +334,6 @@ static inline void local_r4k_flush_cache
 {
 	struct mm_struct *mm = args;
 
-	if (!cpu_has_dc_aliases)
-		return;
-
 	if (!cpu_context(smp_processor_id(), mm))
 		return;
 
@@ -340,6 +353,9 @@ static inline void local_r4k_flush_cache
 
 static void r4k_flush_cache_mm(struct mm_struct *mm)
 {
+	if (!cpu_has_dc_aliases)
+		return;
+
 	on_each_cpu(local_r4k_flush_cache_mm, mm, 1, 1);
 }
 
@@ -359,13 +375,6 @@ static inline void local_r4k_flush_cache
 	pmd_t *pmdp;
 	pte_t *ptep;
 
-	/*
-	 * If ownes no valid ASID yet, cannot possibly have gotten
-	 * this page into the cache.
-	 */
-	if (cpu_context(smp_processor_id(), mm) == 0)
-		return;
-
 	page &= PAGE_MASK;
 	pgdp = pgd_offset(mm, page);
 	pmdp = pmd_offset(pgdp, page);
@@ -385,8 +394,11 @@ static inline void local_r4k_flush_cache
 	 * in that case, which doesn't overly flush the cache too much.
 	 */
 	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID)) {
-		if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc))
+		if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
 			r4k_blast_dcache_page(page);
+			if (exec && !cpu_icache_snoops_remote_store)
+				r4k_blast_scache_page(page);
+		}
 		if (exec)
 			r4k_blast_icache_page(page);
 
@@ -398,8 +410,11 @@ static inline void local_r4k_flush_cache
 	 * to work correctly.
 	 */
 	page = INDEX_BASE + (page & (dcache_size - 1));
-	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc))
+	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
 		r4k_blast_dcache_page_indexed(page);
+		if (exec && !cpu_icache_snoops_remote_store)
+			r4k_blast_scache_page_indexed(page);
+	}
 	if (exec) {
 		if (cpu_has_vtag_icache) {
 			int cpu = smp_processor_id();
@@ -416,6 +431,13 @@ static void r4k_flush_cache_page(struct 
 {
 	struct flush_cache_page_args args;
 
+	/*
+	 * If ownes no valid ASID yet, cannot possibly have gotten
+	 * this page into the cache.
+	 */
+	if (cpu_context(smp_processor_id(), vma->vm_mm) == 0)
+		return;
+
 	args.vma = vma;
 	args.page = page;
 
@@ -442,14 +464,15 @@ static inline void local_r4k_flush_icach
 	struct flush_icache_range_args *fir_args = args;
 	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
 	unsigned long ic_lsize = current_cpu_data.icache.linesz;
+	unsigned long sc_lsize = current_cpu_data.scache.linesz;
 	unsigned long start = fir_args->start;
 	unsigned long end = fir_args->end;
 	unsigned long addr, aend;
 
 	if (!cpu_has_ic_fills_f_dc) {
-		if (end - start > dcache_size)
+		if (end - start > dcache_size) {
 			r4k_blast_dcache();
-		else {
+		} else {
 			addr = start & ~(dc_lsize - 1);
 			aend = (end - 1) & ~(dc_lsize - 1);
 
@@ -461,6 +484,23 @@ static inline void local_r4k_flush_icach
 				addr += dc_lsize;
 			}
 		}
+
+		if (!cpu_icache_snoops_remote_store) {
+			if (end - start > scache_size) {
+				r4k_blast_scache();
+			} else {
+				addr = start & ~(sc_lsize - 1);
+				aend = (end - 1) & ~(sc_lsize - 1);
+
+				while (1) {
+					/* Hit_Writeback_Inv_D */
+					protected_writeback_scache_line(addr);
+					if (addr == aend)
+						break;
+					addr += sc_lsize;
+				}
+			}
+		}
 	}
 
 	if (end - start > icache_size)
@@ -527,6 +567,8 @@ static inline void local_r4k_flush_icach
 	if (!cpu_has_ic_fills_f_dc) {
 		unsigned long addr = (unsigned long) page_address(page);
 		r4k_blast_dcache_page(addr);
+		if (!cpu_icache_snoops_remote_store)
+			r4k_blast_scache_page(addr);
 		ClearPageDcacheDirty(page);
 	}
 
@@ -669,10 +711,13 @@ static void local_r4k_flush_cache_sigtra
 {
 	unsigned long ic_lsize = current_cpu_data.icache.linesz;
 	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
+	unsigned long sc_lsize = current_cpu_data.scache.linesz;
 	unsigned long addr = (unsigned long) arg;
 
 	R4600_HIT_CACHEOP_WAR_IMPL;
 	protected_writeback_dcache_line(addr & ~(dc_lsize - 1));
+	if (!cpu_icache_snoops_remote_store)
+		protected_writeback_scache_line(addr & ~(sc_lsize - 1));
 	protected_flush_icache_line(addr & ~(ic_lsize - 1));
 	if (MIPS4K_ICACHE_REFILL_WAR) {
 		__asm__ __volatile__ (
@@ -739,8 +784,8 @@ static inline void rm7k_erratum31(void)
 	}
 }
 
-static char *way_string[] = { NULL, "direct mapped", "2-way", "3-way", "4-way",
-	"5-way", "6-way", "7-way", "8-way"
+static char *way_string[] __initdata = { NULL, "direct mapped", "2-way",
+	"3-way", "4-way", "5-way", "6-way", "7-way", "8-way"
 };
 
 static void __init probe_pcache(void)
@@ -1178,6 +1223,7 @@ void __init ld_mmu_r4xx0(void)
 	r4k_blast_icache_page_indexed_setup();
 	r4k_blast_icache_setup();
 	r4k_blast_scache_page_setup();
+	r4k_blast_scache_page_indexed_setup();
 	r4k_blast_scache_setup();
 
 	/*
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/c-sb1.c linux-2.6.11-rc3/arch/mips/mm/c-sb1.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/c-sb1.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/c-sb1.c	2005-02-03 02:55:52.000000000 +0100
@@ -503,7 +503,7 @@ void ld_mmu_sb1(void)
 	/* Special cache error handler for SB1 */
 	memcpy((void *)(CAC_BASE   + 0x100), &except_vec2_sb1, 0x80);
 	memcpy((void *)(UNCAC_BASE + 0x100), &except_vec2_sb1, 0x80);
-	memcpy((void *)KSEG1ADDR(&handle_vec2_sb1), &handle_vec2_sb1, 0x80);
+	memcpy((void *)CKSEG1ADDR(&handle_vec2_sb1), &handle_vec2_sb1, 0x80);
 
 	probe_cache_sizes();
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/cache.c linux-2.6.11-rc3/arch/mips/mm/cache.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/cache.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/cache.c	2005-02-03 02:55:37.000000000 +0100
@@ -45,10 +45,17 @@ EXPORT_SYMBOL(_dma_cache_inv);
 
 #endif /* CONFIG_DMA_NONCOHERENT */
 
-asmlinkage int sys_cacheflush(void *addr, int bytes, int cache)
+/*
+ * We could optimize the case where the cache argument is not BCACHE but
+ * that seems very atypical use ...
+ */
+asmlinkage int sys_cacheflush(unsigned long addr, unsigned long int bytes,
+	unsigned int cache)
 {
-	/* This should flush more selectivly ...  */
-	__flush_cache_all();
+	if (verify_area(VERIFY_WRITE, (void *) addr, bytes))
+		return -EFAULT;
+
+	flush_icache_range(addr, addr + bytes);
 
 	return 0;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/cerr-sb1.c linux-2.6.11-rc3/arch/mips/mm/cerr-sb1.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/cerr-sb1.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/cerr-sb1.c	2005-02-03 02:56:33.000000000 +0100
@@ -251,14 +251,14 @@ static const uint8_t parity[256] = {
 
 /* Masks to select bits for Hamming parity, mask_72_64[i] for bit[i] */
 static const uint64_t mask_72_64[8] = {
-	0x0738C808099264FFL,
-	0x38C808099264FF07L,
-	0xC808099264FF0738L,
-	0x08099264FF0738C8L,
-	0x099264FF0738C808L,
-	0x9264FF0738C80809L,
-	0x64FF0738C8080992L,
-	0xFF0738C808099264L
+	0x0738C808099264FFULL,
+	0x38C808099264FF07ULL,
+	0xC808099264FF0738ULL,
+	0x08099264FF0738C8ULL,
+	0x099264FF0738C808ULL,
+	0x9264FF0738C80809ULL,
+	0x64FF0738C8080992ULL,
+	0xFF0738C808099264ULL
 };
 
 /* Calculate the parity on a range of bits */
@@ -330,9 +330,9 @@ static uint32_t extract_ic(unsigned shor
 				    ((lru >> 4) & 0x3),
 				    ((lru >> 6) & 0x3));
 		}
-		va = (taglo & 0xC0000FFFFFFFE000) | addr;
+		va = (taglo & 0xC0000FFFFFFFE000ULL) | addr;
 		if ((taglo & (1 << 31)) && (((taglo >> 62) & 0x3) == 3))
-			va |= 0x3FFFF00000000000;
+			va |= 0x3FFFF00000000000ULL;
 		valid = ((taghi >> 29) & 1);
 		if (valid) {
 			tlo_tmp = taglo & 0xfff3ff;
@@ -473,7 +473,7 @@ static uint32_t extract_dc(unsigned shor
 		: "r" ((way << 13) | addr));
 
 		taglo = ((unsigned long long)taglohi << 32) | taglolo;
-		pa = (taglo & 0xFFFFFFE000) | addr;
+		pa = (taglo & 0xFFFFFFE000ULL) | addr;
 		if (way == 0) {
 			lru = (taghi >> 14) & 0xff;
 			prom_printf("[Bank %d Set 0x%02x]  LRU > %d %d %d %d > MRU\n",
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/cex-sb1.S linux-2.6.11-rc3/arch/mips/mm/cex-sb1.S
--- linux-2.6.11-rc2-bk10/arch/mips/mm/cex-sb1.S	2005-01-22 02:46:40.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/cex-sb1.S	2005-02-03 02:54:35.000000000 +0100
@@ -15,7 +15,6 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
-#include <linux/config.h>
 #include <linux/init.h>
 
 #include <asm/asm.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/dma-ip32.c linux-2.6.11-rc3/arch/mips/mm/dma-ip32.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/dma-ip32.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/dma-ip32.c	2005-02-03 02:55:15.000000000 +0100
@@ -0,0 +1,382 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000  Ani Joshi <ajoshi@unixbox.com>
+ * Copyright (C) 2000, 2001  Ralf Baechle <ralf@gnu.org>
+ * Copyright (C) 2005 Ilya A. Volynets-Evenbakh <ilya@total-knowledge.com>
+ * swiped from i386, and cloned for MIPS by Geert, polished by Ralf.
+ * IP32 changes by Ilya.
+ */
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <asm/ip32/crime.h>
+
+/*
+ * Warning on the terminology - Linux calls an uncached area coherent;
+ * MIPS terminology calls memory areas with hardware maintained coherency
+ * coherent.
+ */
+
+/*
+ * Few notes.
+ * 1. CPU sees memory as two chunks: 0-256M@0x0, and the rest @0x40000000+256M
+ * 2. PCI sees memory as one big chunk @0x0 (or we could use 0x40000000 for native-endian)
+ * 3. All other devices see memory as one big chunk at 0x40000000
+ * 4. Non-PCI devices will pass NULL as struct device*
+ * Thus we translate differently, depending on device.
+ */
+
+#define RAM_OFFSET_MASK	0x3fffffff
+
+void *dma_alloc_noncoherent(struct device *dev, size_t size,
+	dma_addr_t * dma_handle, int gfp)
+{
+	void *ret;
+	/* ignore region specifiers */
+	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
+
+	if (dev == NULL || (dev->coherent_dma_mask < 0xffffffff))
+		gfp |= GFP_DMA;
+	ret = (void *) __get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+		unsigned long addr = virt_to_phys(ret)&RAM_OFFSET_MASK;
+		memset(ret, 0, size);
+		if(dev==NULL)
+		    addr+= CRIME_HI_MEM_BASE;
+		*dma_handle = addr;
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(dma_alloc_noncoherent);
+
+void *dma_alloc_coherent(struct device *dev, size_t size,
+	dma_addr_t * dma_handle, int gfp)
+{
+	void *ret;
+
+	ret = dma_alloc_noncoherent(dev, size, dma_handle, gfp);
+	if (ret) {
+		dma_cache_wback_inv((unsigned long) ret, size);
+		ret = UNCAC_ADDR(ret);
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(dma_alloc_coherent);
+
+void dma_free_noncoherent(struct device *dev, size_t size, void *vaddr,
+	dma_addr_t dma_handle)
+{
+	free_pages((unsigned long) vaddr, get_order(size));
+}
+
+EXPORT_SYMBOL(dma_free_noncoherent);
+
+void dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+	dma_addr_t dma_handle)
+{
+	unsigned long addr = (unsigned long) vaddr;
+
+	addr = CAC_ADDR(addr);
+	free_pages(addr, get_order(size));
+}
+
+EXPORT_SYMBOL(dma_free_coherent);
+
+static inline void __dma_sync(unsigned long addr, size_t size,
+	enum dma_data_direction direction)
+{
+	switch (direction) {
+	case DMA_TO_DEVICE:
+		dma_cache_wback(addr, size);
+		break;
+
+	case DMA_FROM_DEVICE:
+		dma_cache_inv(addr, size);
+		break;
+
+	case DMA_BIDIRECTIONAL:
+		dma_cache_wback_inv(addr, size);
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+dma_addr_t dma_map_single(struct device *dev, void *ptr, size_t size,
+	enum dma_data_direction direction)
+{
+	unsigned long addr = (unsigned long) ptr;
+
+	switch (direction) {
+	case DMA_TO_DEVICE:
+		dma_cache_wback(addr, size);
+		break;
+
+	case DMA_FROM_DEVICE:
+		dma_cache_inv(addr, size);
+		break;
+
+	case DMA_BIDIRECTIONAL:
+		dma_cache_wback_inv(addr, size);
+		break;
+
+	default:
+		BUG();
+	}
+
+	addr = virt_to_phys(ptr)&RAM_OFFSET_MASK;;
+	if(dev == NULL)
+	    addr+=CRIME_HI_MEM_BASE;
+	return (dma_addr_t)addr;
+}
+
+EXPORT_SYMBOL(dma_map_single);
+
+void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
+	enum dma_data_direction direction)
+{
+	switch (direction) {
+	case DMA_TO_DEVICE:
+		break;
+
+	case DMA_FROM_DEVICE:
+		break;
+
+	case DMA_BIDIRECTIONAL:
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+EXPORT_SYMBOL(dma_unmap_single);
+
+int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+	enum dma_data_direction direction)
+{
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	for (i = 0; i < nents; i++, sg++) {
+		unsigned long addr;
+
+		addr = (unsigned long) page_address(sg->page)+sg->offset;
+		if (addr)
+			__dma_sync(addr, sg->length, direction);
+		addr = __pa(addr)&RAM_OFFSET_MASK;;
+		if(dev == NULL)
+			addr +=  CRIME_HI_MEM_BASE;
+		sg->dma_address = (dma_addr_t)addr;
+	}
+
+	return nents;
+}
+
+EXPORT_SYMBOL(dma_map_sg);
+
+dma_addr_t dma_map_page(struct device *dev, struct page *page,
+	unsigned long offset, size_t size, enum dma_data_direction direction)
+{
+	unsigned long addr;
+
+	BUG_ON(direction == DMA_NONE);
+
+	addr = (unsigned long) page_address(page) + offset;
+	dma_cache_wback_inv(addr, size);
+	addr = __pa(addr)&RAM_OFFSET_MASK;;
+	if(dev == NULL)
+		addr +=  CRIME_HI_MEM_BASE;
+
+	return (dma_addr_t)addr;
+}
+
+EXPORT_SYMBOL(dma_map_page);
+
+void dma_unmap_page(struct device *dev, dma_addr_t dma_address, size_t size,
+	enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	if (direction != DMA_TO_DEVICE) {
+		unsigned long addr;
+
+		dma_address&=RAM_OFFSET_MASK;
+		addr = dma_address + PAGE_OFFSET;
+		if(dma_address>=256*1024*1024)
+			addr+=CRIME_HI_MEM_BASE;
+		dma_cache_wback_inv(addr, size);
+	}
+}
+
+EXPORT_SYMBOL(dma_unmap_page);
+
+void dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nhwentries,
+	enum dma_data_direction direction)
+{
+	unsigned long addr;
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	if (direction == DMA_TO_DEVICE)
+		return;
+
+	for (i = 0; i < nhwentries; i++, sg++) {
+		addr = (unsigned long) page_address(sg->page);
+		if (!addr)
+			continue;
+		dma_cache_wback_inv(addr + sg->offset, sg->length);
+	}
+}
+
+EXPORT_SYMBOL(dma_unmap_sg);
+
+void dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,
+	size_t size, enum dma_data_direction direction)
+{
+	unsigned long addr;
+
+	BUG_ON(direction == DMA_NONE);
+
+	dma_handle&=RAM_OFFSET_MASK;
+	addr = dma_handle + PAGE_OFFSET;
+	if(dma_handle>=256*1024*1024)
+	    addr+=CRIME_HI_MEM_BASE;
+	__dma_sync(addr, size, direction);
+}
+
+EXPORT_SYMBOL(dma_sync_single_for_cpu);
+
+void dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle,
+	size_t size, enum dma_data_direction direction)
+{
+	unsigned long addr;
+
+	BUG_ON(direction == DMA_NONE);
+
+	dma_handle&=RAM_OFFSET_MASK;
+	addr = dma_handle + PAGE_OFFSET;
+	if(dma_handle>=256*1024*1024)
+	    addr+=CRIME_HI_MEM_BASE;
+	__dma_sync(addr, size, direction);
+}
+
+EXPORT_SYMBOL(dma_sync_single_for_device);
+
+void dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t dma_handle,
+	unsigned long offset, size_t size, enum dma_data_direction direction)
+{
+	unsigned long addr;
+
+	BUG_ON(direction == DMA_NONE);
+
+	dma_handle&=RAM_OFFSET_MASK;
+	addr = dma_handle + offset + PAGE_OFFSET;
+	if(dma_handle>=256*1024*1024)
+	    addr+=CRIME_HI_MEM_BASE;
+	__dma_sync(addr, size, direction);
+}
+
+EXPORT_SYMBOL(dma_sync_single_range_for_cpu);
+
+void dma_sync_single_range_for_device(struct device *dev, dma_addr_t dma_handle,
+	unsigned long offset, size_t size, enum dma_data_direction direction)
+{
+	unsigned long addr;
+
+	BUG_ON(direction == DMA_NONE);
+
+	dma_handle&=RAM_OFFSET_MASK;
+	addr = dma_handle + offset + PAGE_OFFSET;
+	if(dma_handle>=256*1024*1024)
+	    addr+=CRIME_HI_MEM_BASE;
+	__dma_sync(addr, size, direction);
+}
+
+EXPORT_SYMBOL(dma_sync_single_range_for_device);
+
+void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nelems,
+	enum dma_data_direction direction)
+{
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	/* Make sure that gcc doesn't leave the empty loop body.  */
+	for (i = 0; i < nelems; i++, sg++)
+		__dma_sync((unsigned long)page_address(sg->page),
+		           sg->length, direction);
+}
+
+EXPORT_SYMBOL(dma_sync_sg_for_cpu);
+
+void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int nelems,
+	enum dma_data_direction direction)
+{
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	/* Make sure that gcc doesn't leave the empty loop body.  */
+	for (i = 0; i < nelems; i++, sg++)
+		__dma_sync((unsigned long)page_address(sg->page),
+		           sg->length, direction);
+}
+
+EXPORT_SYMBOL(dma_sync_sg_for_device);
+
+int dma_mapping_error(dma_addr_t dma_addr)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(dma_mapping_error);
+
+int dma_supported(struct device *dev, u64 mask)
+{
+	/*
+	 * we fall back to GFP_DMA when the mask isn't all 1s,
+	 * so we can't guarantee allocations that must be
+	 * within a tighter range than GFP_DMA..
+	 */
+	if (mask < 0x00ffffff)
+		return 0;
+
+	return 1;
+}
+
+EXPORT_SYMBOL(dma_supported);
+
+int dma_is_consistent(dma_addr_t dma_addr)
+{
+	return 1;
+}
+
+EXPORT_SYMBOL(dma_is_consistent);
+
+void dma_cache_sync(void *vaddr, size_t size, enum dma_data_direction direction)
+{
+	if (direction == DMA_NONE)
+		return;
+
+	dma_cache_wback_inv((unsigned long)vaddr, size);
+}
+
+EXPORT_SYMBOL(dma_cache_sync);
+
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/init.c linux-2.6.11-rc3/arch/mips/mm/init.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/init.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/init.c	2005-02-03 02:56:22.000000000 +0100
@@ -61,7 +61,7 @@ unsigned long setup_zero_pages(void)
 	else
 		order = 0;
 
-	empty_zero_page = __get_free_pages(GFP_KERNEL, order);
+	empty_zero_page = __get_free_pages(GFP_KERNEL | __GFP_ZERO, order);
 	if (!empty_zero_page)
 		panic("Oh boy, that early out of memory?");
 
@@ -74,7 +74,6 @@ unsigned long setup_zero_pages(void)
 
 	size = PAGE_SIZE << order;
 	zero_page_mask = (size - 1) & PAGE_MASK;
-	memset((void *)empty_zero_page, 0, size);
 
 	return 1UL << order;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/pg-r4k.c linux-2.6.11-rc3/arch/mips/mm/pg-r4k.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/pg-r4k.c	2005-01-22 02:48:14.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/pg-r4k.c	2005-02-03 02:55:52.000000000 +0100
@@ -3,9 +3,8 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2003, 04, 05 Ralf Baechle (ralf@linux-mips.org)
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -58,12 +57,6 @@ void copy_page(void *to, void *from) __a
 EXPORT_SYMBOL(copy_page);
 
 /*
- * An address fits into a single register so it's safe to use 64-bit registers
- * if we have 64-bit adresses.
- */
-#define cpu_has_64bit_registers	cpu_has_64bit_addresses
-
-/*
  * This is suboptimal for 32-bit kernels; we assume that R10000 is only used
  * with 64-bit kernels.  The prefetch offsets have been experimentally tuned
  * an Origin 200.
@@ -145,7 +138,7 @@ static inline void __build_load_reg(int 
 	union mips_instruction mi;
 	unsigned int width;
 
-	if (cpu_has_64bit_registers) {
+	if (cpu_has_64bit_gp_regs) {
 		mi.i_format.opcode     = ld_op;
 		width = 8;
 	} else {
@@ -266,7 +259,7 @@ static inline void build_addiu_a2_a0(uns
 
 	BUG_ON(offset > 0x7fff);
 
-	mi.i_format.opcode     = cpu_has_64bit_addresses ? daddiu_op : addiu_op;
+	mi.i_format.opcode     = cpu_has_64bit_gp_regs ? daddiu_op : addiu_op;
 	mi.i_format.rs         = 4;		/* $a0 */
 	mi.i_format.rt         = 6;		/* $a2 */
 	mi.i_format.simmediate = offset;
@@ -280,7 +273,7 @@ static inline void build_addiu_a1(unsign
 
 	BUG_ON(offset > 0x7fff);
 
-	mi.i_format.opcode     = cpu_has_64bit_addresses ? daddiu_op : addiu_op;
+	mi.i_format.opcode     = cpu_has_64bit_gp_regs ? daddiu_op : addiu_op;
 	mi.i_format.rs         = 5;		/* $a1 */
 	mi.i_format.rt         = 5;		/* $a1 */
 	mi.i_format.simmediate = offset;
@@ -296,7 +289,7 @@ static inline void build_addiu_a0(unsign
 
 	BUG_ON(offset > 0x7fff);
 
-	mi.i_format.opcode     = cpu_has_64bit_addresses ? daddiu_op : addiu_op;
+	mi.i_format.opcode     = cpu_has_64bit_gp_regs ? daddiu_op : addiu_op;
 	mi.i_format.rs         = 4;		/* $a0 */
 	mi.i_format.rt         = 4;		/* $a0 */
 	mi.i_format.simmediate = offset;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/pg-sb1.c linux-2.6.11-rc3/arch/mips/mm/pg-sb1.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/pg-sb1.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/pg-sb1.c	2005-02-03 02:57:04.000000000 +0100
@@ -2,6 +2,7 @@
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
  * Copyright (C) 2000 SiByte, Inc.
+ * Copyright (C) 2005 Thiemo Seufer
  *
  * Written by Justin Carlson of SiByte, Inc.
  *         and Kip Walker of Broadcom Corp.
@@ -39,11 +40,7 @@
 #define SB1_PREF_STORE_STREAMED_HINT "5"
 #endif
 
-#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
 static inline void clear_page_cpu(void *page)
-#else
-void clear_page(void *page)
-#endif
 {
 	unsigned char *addr = (unsigned char *) page;
 	unsigned char *end = addr + PAGE_SIZE;
@@ -57,90 +54,143 @@ void clear_page(void *page)
 	 * since we know we're on an SB1, we force the assembler to take
 	 * 64-bit operands to speed things up
 	 */
-	do {
-		__asm__ __volatile__(
-		"	.set	mips4		\n"
+	__asm__ __volatile__(
+	"	.set	push		\n"
+	"	.set	mips4		\n"
+	"	.set	noreorder	\n"
 #ifdef CONFIG_CPU_HAS_PREFETCH
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  0(%0)  \n"  /* Prefetch the first 4 lines */
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ", 32(%0)  \n"
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ", 64(%0)  \n"
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ", 96(%0)  \n"
-#endif
-		"1:	sd	$0,  0(%0)	\n"  /* Throw out a cacheline of 0's */
-		"	sd	$0,  8(%0)	\n"
-		"	sd	$0, 16(%0)	\n"
-		"	sd	$0, 24(%0)	\n"
-#ifdef CONFIG_CPU_HAS_PREFETCH
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ",128(%0)  \n"  /* Prefetch 4 lines ahead     */
+	"	daddiu	%0, %0, 128	\n"
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%0)  \n"  /* Prefetch the first 4 lines */
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -96(%0)  \n"
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -64(%0)  \n"
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -32(%0)  \n"
+	"1:	sd	$0, -128(%0)	\n"  /* Throw out a cacheline of 0's */
+	"	sd	$0, -120(%0)	\n"
+	"	sd	$0, -112(%0)	\n"
+	"	sd	$0, -104(%0)	\n"
+	"	daddiu	%0, %0, 32	\n"
+	"	bnel	%0, %1, 1b	\n"
+	"	 pref	" SB1_PREF_STORE_STREAMED_HINT ",  -32(%0)  \n"
+	"	daddiu	%0, %0, -128	\n"
 #endif
-		"	.set	mips0		\n"
-		:
-		: "r" (addr)
-		: "memory");
-		addr += 32;
-	} while (addr != end);
+	"	sd	$0, 0(%0)	\n"  /* Throw out a cacheline of 0's */
+	"1:	sd	$0, 8(%0)	\n"
+	"	sd	$0, 16(%0)	\n"
+	"	sd	$0, 24(%0)	\n"
+	"	daddiu	%0, %0, 32	\n"
+	"	bnel	%0, %1, 1b	\n"
+	"	 sd	$0, 0(%0)	\n"
+	"	.set	pop		\n"
+	: "+r" (addr)
+	: "r" (end)
+	: "memory");
 }
 
-#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
 static inline void copy_page_cpu(void *to, void *from)
-#else
-void copy_page(void *to, void *from)
-#endif
 {
-	unsigned char *src = from;
-	unsigned char *dst = to;
+	unsigned char *src = (unsigned char *)from;
+	unsigned char *dst = (unsigned char *)to;
 	unsigned char *end = src + PAGE_SIZE;
 
 	/*
-	 * This should be optimized in assembly...can't use ld/sd, though,
-	 * because the top 32 bits could be nuked if we took an interrupt
-	 * during the routine.	And this is not a good place to be cli()'ing
-	 *
 	 * The pref's used here are using "streaming" hints, which cause the
 	 * copied data to be kicked out of the cache sooner.  A page copy often
 	 * ends up copying a lot more data than is commonly used, so this seems
 	 * to make sense in terms of reducing cache pollution, but I've no real
 	 * performance data to back this up
 	 */
-
-	do {
-		__asm__ __volatile__(
-		"	.set	mips4					\n"
+	__asm__ __volatile__(
+	"	.set	push		\n"
+	"	.set	mips4		\n"
+	"	.set	noreorder	\n"
 #ifdef CONFIG_CPU_HAS_PREFETCH
-		"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  0(%0)\n"  /* Prefetch the first 3 lines */
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  0(%1)\n"
-		"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  32(%0)\n"
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  32(%1)\n"
-		"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  64(%0)\n"
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  64(%1)\n"
-#endif
-		"1:	lw	$2,  0(%0)	\n"  /* Block copy a cacheline */
-		"	lw	$3,  4(%0)	\n"
-		"	lw	$4,  8(%0)	\n"
-		"	lw	$5, 12(%0)	\n"
-		"	lw	$6, 16(%0)	\n"
-		"	lw	$7, 20(%0)	\n"
-		"	lw	$8, 24(%0)	\n"
-		"	lw	$9, 28(%0)	\n"
-#ifdef CONFIG_CPU_HAS_PREFETCH
-		"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ", 96(%0)  \n"  /* Prefetch ahead         */
-		"	pref	" SB1_PREF_STORE_STREAMED_HINT ", 96(%1)  \n"
+	"	daddiu	%0, %0, 128	\n"
+	"	daddiu	%1, %1, 128	\n"
+	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ", -128(%0)\n"  /* Prefetch the first 4 lines */
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%1)\n"
+	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  -96(%0)\n"
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -96(%1)\n"
+	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  -64(%0)\n"
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -64(%1)\n"
+	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  -32(%0)\n"
+	"1:	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -32(%1)\n"
+# ifdef CONFIG_MIPS64
+	"	ld	$8, -128(%0)	\n"  /* Block copy a cacheline */
+	"	ld	$9, -120(%0)	\n"
+	"	ld	$10, -112(%0)	\n"
+	"	ld	$11, -104(%0)	\n"
+	"	sd	$8, -128(%1)	\n"
+	"	sd	$9, -120(%1)	\n"
+	"	sd	$10, -112(%1)	\n"
+	"	sd	$11, -104(%1)	\n"
+# else
+	"	lw	$2, -128(%0)	\n"  /* Block copy a cacheline */
+	"	lw	$3, -124(%0)	\n"
+	"	lw	$6, -120(%0)	\n"
+	"	lw	$7, -116(%0)	\n"
+	"	lw	$8, -112(%0)	\n"
+	"	lw	$9, -108(%0)	\n"
+	"	lw	$10, -104(%0)	\n"
+	"	lw	$11, -100(%0)	\n"
+	"	sw	$2, -128(%1)	\n"
+	"	sw	$3, -124(%1)	\n"
+	"	sw	$6, -120(%1)	\n"
+	"	sw	$7, -116(%1)	\n"
+	"	sw	$8, -112(%1)	\n"
+	"	sw	$9, -108(%1)	\n"
+	"	sw	$10, -104(%1)	\n"
+	"	sw	$11, -100(%1)	\n"
+# endif
+	"	daddiu	%0, %0, 32	\n"
+	"	daddiu	%1, %1, 32	\n"
+	"	bnel	%0, %2, 1b	\n"
+	"	 pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  -32(%0)\n"
+	"	daddiu	%0, %0, -128	\n"
+	"	daddiu	%1, %1, -128	\n"
+#endif
+#ifdef CONFIG_MIPS64
+	"	ld	$8, 0(%0)	\n"  /* Block copy a cacheline */
+	"1:	ld	$9, 8(%0)	\n"
+	"	ld	$10, 16(%0)	\n"
+	"	ld	$11, 24(%0)	\n"
+	"	sd	$8, 0(%1)	\n"
+	"	sd	$9, 8(%1)	\n"
+	"	sd	$10, 16(%1)	\n"
+	"	sd	$11, 24(%1)	\n"
+#else
+	"	lw	$2, 0(%0)	\n"  /* Block copy a cacheline */
+	"1:	lw	$3, 4(%0)	\n"
+	"	lw	$6, 8(%0)	\n"
+	"	lw	$7, 12(%0)	\n"
+	"	lw	$8, 16(%0)	\n"
+	"	lw	$9, 20(%0)	\n"
+	"	lw	$10, 24(%0)	\n"
+	"	lw	$11, 28(%0)	\n"
+	"	sw	$2, 0(%1)	\n"
+	"	sw	$3, 4(%1)	\n"
+	"	sw	$6, 8(%1)	\n"
+	"	sw	$7, 12(%1)	\n"
+	"	sw	$8, 16(%1)	\n"
+	"	sw	$9, 20(%1)	\n"
+	"	sw	$10, 24(%1)	\n"
+	"	sw	$11, 28(%1)	\n"
+#endif
+	"	daddiu	%0, %0, 32	\n"
+	"	daddiu	%1, %1, 32	\n"
+	"	bnel	%0, %2, 1b	\n"
+#ifdef CONFIG_MIPS64
+	"	 ld	$8, 0(%0)	\n"
+#else
+	"	 lw	$2, 0(%0)	\n"
+#endif
+	"	.set	pop		\n"
+	: "+r" (src), "+r" (dst)
+	: "r" (end)
+#ifdef CONFIG_MIPS64
+	: "$8","$9","$10","$11","memory");
+#else
+	: "$2","$3","$6","$7","$8","$9","$10","$11","memory");
 #endif
-		"	sw	$2,  0(%1)	\n"
-		"	sw	$3,  4(%1)	\n"
-		"	sw	$4,  8(%1)	\n"
-		"	sw	$5, 12(%1)	\n"
-		"	sw	$6, 16(%1)	\n"
-		"	sw	$7, 20(%1)	\n"
-		"	sw	$8, 24(%1)	\n"
-		"	sw	$9, 28(%1)	\n"
-		"	.set	mips0		\n"
-		:
-		: "r" (src), "r" (dst)
-		: "$2","$3","$4","$5","$6","$7","$8","$9","memory");
-		src += 32;
-		dst += 32;
-	} while (src != end);
 }
 
 
@@ -151,10 +201,10 @@ void copy_page(void *to, void *from)
  * particular CPU. 
  */
 typedef struct dmadscr_s {
-	uint64_t  dscr_a;
-	uint64_t  dscr_b;
-	uint64_t  pad_a;
-	uint64_t  pad_b;
+	u64 dscr_a;
+	u64 dscr_b;
+	u64 pad_a;
+	u64 pad_b;
 } dmadscr_t;
 
 static dmadscr_t page_descr[NR_CPUS] __attribute__((aligned(SMP_CACHE_BYTES)));
@@ -162,14 +212,14 @@ static dmadscr_t page_descr[NR_CPUS] __a
 void sb1_dma_init(void)
 {
 	int cpu = smp_processor_id();
-	uint64_t base_val = PHYSADDR(&page_descr[cpu]) | V_DM_DSCR_BASE_RINGSZ(1);
+	u64 base_val = CPHYSADDR(&page_descr[cpu]) | V_DM_DSCR_BASE_RINGSZ(1);
 
-	__raw_writeq(base_val,
-		     IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
-	__raw_writeq(base_val | M_DM_DSCR_BASE_RESET,
-		     IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
-	__raw_writeq(base_val | M_DM_DSCR_BASE_ENABL,
-		     IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	bus_writeq(base_val,
+		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	bus_writeq(base_val | M_DM_DSCR_BASE_RESET,
+		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	bus_writeq(base_val | M_DM_DSCR_BASE_ENABL,
+		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
 }
 
 void clear_page(void *page)
@@ -177,46 +227,61 @@ void clear_page(void *page)
 	int cpu = smp_processor_id();
 
 	/* if the page is above Kseg0, use old way */
-	if (KSEGX(page) != CAC_BASE)
+	if ((long)KSEGX(page) != (long)CKSEG0)
 		return clear_page_cpu(page);
 
-	page_descr[cpu].dscr_a = PHYSADDR(page) | M_DM_DSCRA_ZERO_MEM | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
+	page_descr[cpu].dscr_a = CPHYSADDR(page) | M_DM_DSCRA_ZERO_MEM | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
 	page_descr[cpu].dscr_b = V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
-	__raw_writeq(1, IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
+	bus_writeq(1, (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
 
 	/*
 	 * Don't really want to do it this way, but there's no
 	 * reliable way to delay completion detection.
 	 */
-	while (!(__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) & M_DM_DSCR_BASE_INTERRUPT)))
+	while (!(bus_readq((void *)(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) &
+			   M_DM_DSCR_BASE_INTERRUPT))))
 		;
-	__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	bus_readq((void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
 }
 
 void copy_page(void *to, void *from)
 {
-	unsigned long from_phys = PHYSADDR(from);
-	unsigned long to_phys = PHYSADDR(to);
+	unsigned long from_phys = CPHYSADDR(from);
+	unsigned long to_phys = CPHYSADDR(to);
 	int cpu = smp_processor_id();
 
 	/* if either page is above Kseg0, use old way */
-	if ((KSEGX(to) != CAC_BASE) || (KSEGX(from) != CAC_BASE))
+	if ((long)KSEGX(to) != (long)CKSEG0
+	    || (long)KSEGX(from) != (long)CKSEG0)
 		return copy_page_cpu(to, from);
 
-	page_descr[cpu].dscr_a = PHYSADDR(to_phys) | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
-	page_descr[cpu].dscr_b = PHYSADDR(from_phys) | V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
-	__raw_writeq(1, IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
+	page_descr[cpu].dscr_a = CPHYSADDR(to_phys) | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
+	page_descr[cpu].dscr_b = CPHYSADDR(from_phys) | V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
+	bus_writeq(1, (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
 
 	/*
 	 * Don't really want to do it this way, but there's no
 	 * reliable way to delay completion detection.
 	 */
-	while (!(__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) & M_DM_DSCR_BASE_INTERRUPT)))
+	while (!(bus_readq((void *)(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) &
+				    M_DM_DSCR_BASE_INTERRUPT))))
 		;
-	__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	bus_readq((void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
 }
 
-#endif
+#else /* !CONFIG_SIBYTE_DMA_PAGEOPS */
+
+void clear_page(void *page)
+{
+	return clear_page_cpu(page);
+}
+
+void copy_page(void *to, void *from)
+{
+	return copy_page_cpu(to, from);
+}
+
+#endif /* !CONFIG_SIBYTE_DMA_PAGEOPS */
 
 EXPORT_SYMBOL(clear_page);
 EXPORT_SYMBOL(copy_page);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/pgtable-32.c linux-2.6.11-rc3/arch/mips/mm/pgtable-32.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/pgtable-32.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/pgtable-32.c	2005-02-03 02:55:14.000000000 +0100
@@ -71,8 +71,8 @@ void __init pagetable_init(void)
 
 	/* Initialize the entire pgd.  */
 	pgd_init((unsigned long)swapper_pg_dir);
-	pgd_init((unsigned long)swapper_pg_dir +
-	         sizeof(pgd_t ) * USER_PTRS_PER_PGD);
+	pgd_init((unsigned long)swapper_pg_dir
+		 + sizeof(pgd_t) * USER_PTRS_PER_PGD);
 
 #ifdef CONFIG_HIGHMEM
 	pgd_base = swapper_pg_dir;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/pgtable-64.c linux-2.6.11-rc3/arch/mips/mm/pgtable-64.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/pgtable-64.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/pgtable-64.c	2005-02-03 02:55:08.000000000 +0100
@@ -55,5 +55,4 @@ void __init pagetable_init(void)
 	/* Initialize the entire pgd.  */
 	pgd_init((unsigned long)swapper_pg_dir);
 	pmd_init((unsigned long)invalid_pmd_table, (unsigned long)invalid_pte_table);
-	memset((void *)invalid_pte_table, 0, sizeof(pte_t) * PTRS_PER_PTE);
 }
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/pgtable.c linux-2.6.11-rc3/arch/mips/mm/pgtable.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/pgtable.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/pgtable.c	2005-02-03 02:55:36.000000000 +0100
@@ -1,3 +1,4 @@
+#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/swap.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/sc-rm7k.c linux-2.6.11-rc3/arch/mips/mm/sc-rm7k.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/sc-rm7k.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/sc-rm7k.c	2005-02-03 02:57:04.000000000 +0100
@@ -96,13 +96,13 @@ static void rm7k_sc_inv(unsigned long ad
 }
 
 /*
- * This function is executed in the uncached segment KSEG1.
+ * This function is executed in the uncached segment CKSEG1.
  * It must not touch the stack, because the stack pointer still points
- * into KSEG0.
+ * into CKSEG0.
  *
  * Three options:
  *	- Write it in assembly and guarantee that we don't use the stack.
- *	- Disable caching for KSEG0 before calling it.
+ *	- Disable caching for CKSEG0 before calling it.
  *	- Pray that GCC doesn't randomly start using the stack.
  *
  * This being Linux, we obviously take the least sane of those options -
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlb-andes.c linux-2.6.11-rc3/arch/mips/mm/tlb-andes.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlb-andes.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlb-andes.c	2005-02-03 02:55:15.000000000 +0100
@@ -7,7 +7,6 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) 2000 Kanoj Sarcar (kanoj@sgi.com)
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlb-sb1.c linux-2.6.11-rc3/arch/mips/mm/tlb-sb1.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlb-sb1.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlb-sb1.c	2005-02-03 02:57:04.000000000 +0100
@@ -17,7 +17,6 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <asm/mmu_context.h>
 #include <asm/bootinfo.h>
@@ -25,7 +24,7 @@
 
 extern void build_tlb_refill_handler(void);
 
-#define UNIQUE_ENTRYHI(idx) (KSEG0 + ((idx) << (PAGE_SHIFT + 1)))
+#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
 
 /* Dump the current entry* and pagemask registers */
 static inline void dump_cur_tlb_regs(void)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlb64-glue-r4k.S linux-2.6.11-rc3/arch/mips/mm/tlb64-glue-r4k.S
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlb64-glue-r4k.S	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlb64-glue-r4k.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1999 Ralf Baechle
- * Copyright (C) 1999 Silicon Graphics, Inc.
- */
-#include <linux/init.h>
-#include <asm/mipsregs.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-
-	.macro	__BUILD_cli
-	CLI
-	.endm
-
-	.macro	__BUILD_sti
-	STI
-	.endm
-
-	.macro	__BUILD_kmode
-	KMODE
-	.endm
-
-	.macro	tlb_handler name interruptible writebit
-	NESTED(__\name, PT_SIZE, sp)
-	SAVE_ALL
-	dmfc0	a2, CP0_BADVADDR
-	__BUILD_\interruptible
-	li	a1, \writebit
-	sd	a2, PT_BVADDR(sp)
-	move	a0, sp
-	jal	do_page_fault
-	j	ret_from_exception
-	END(__\name)
-	.endm
-
-	tlb_handler	xtlb_mod kmode 1
-	tlb_handler	xtlb_tlbl kmode 0
-	tlb_handler	xtlb_tlbs kmode 1
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlb64-glue-sb1.S linux-2.6.11-rc3/arch/mips/mm/tlb64-glue-sb1.S
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlb64-glue-sb1.S	2005-01-22 02:49:12.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlb64-glue-sb1.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1999 Ralf Baechle
- * Copyright (C) 1999 Silicon Graphics, Inc.
- */
-#include <linux/init.h>
-#include <asm/mipsregs.h>
-#include <asm/page.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-#include <asm/war.h>
-
-	.macro	__BUILD_cli
-	CLI
-	.endm
-
-	.macro	__BUILD_sti
-	STI
-	.endm
-
-	.macro	__BUILD_kmode
-	KMODE
-	.endm
-
-	.macro	tlb_handler name interruptible writebit
-	NESTED(__\name, PT_SIZE, sp)
-	SAVE_ALL
-	dmfc0	a2, CP0_BADVADDR
-	__BUILD_\interruptible
-	li	a1, \writebit
-	sd	a2, PT_BVADDR(sp)
-	move	a0, sp
-	jal	do_page_fault
-	j	ret_from_exception
-	END(__\name)
-	.endm
-
-	.macro	tlb_handler_m3 name interruptible writebit
-	NESTED(__\name, PT_SIZE, sp)
-	dmfc0	k0, CP0_BADVADDR
-	dmfc0	k1, CP0_ENTRYHI
-	xor	k0, k1
-	dsrl	k0, k0, PAGE_SHIFT + 1
-	bnez	k0, 1f
-	SAVE_ALL
-	dmfc0	a2, CP0_BADVADDR
-	__BUILD_\interruptible
-	li	a1, \writebit
-	sd	a2, PT_BVADDR(sp)
-	move	a0, sp
-	jal	do_page_fault
-1:
-	j	ret_from_exception
-	END(__\name)
-	.endm
-
-	tlb_handler	xtlb_mod kmode 1
-#if BCM1250_M3_WAR
-	tlb_handler_m3	xtlb_tlbl kmode 0
-#else
-	tlb_handler	xtlb_tlbl kmode 0
-#endif
-	tlb_handler	xtlb_tlbs kmode 1
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex-fault.S linux-2.6.11-rc3/arch/mips/mm/tlbex-fault.S
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex-fault.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlbex-fault.S	2005-02-03 02:55:14.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999 Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ */
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+	.macro tlb_do_page_fault, write
+	NESTED(tlb_do_page_fault_\write, PT_SIZE, sp)
+	SAVE_ALL
+	MFC0	a2, CP0_BADVADDR
+	KMODE
+	move	a0, sp
+	REG_S	a2, PT_BVADDR(sp)
+	li	a1, \write
+	jal	do_page_fault
+	j	ret_from_exception
+	END(tlb_do_page_fault_\write)
+	.endm
+
+	tlb_do_page_fault 0
+	tlb_do_page_fault 1
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex.c linux-2.6.11-rc3/arch/mips/mm/tlbex.c
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex.c	2005-01-22 02:47:29.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlbex.c	2005-02-03 02:55:15.000000000 +0100
@@ -5,7 +5,7 @@
  *
  * Synthesize TLB refill handlers at runtime.
  *
- * Copyright (C) 2004 by Thiemo Seufer
+ * Copyright (C) 2004,2005 by Thiemo Seufer
  */
 
 #include <stdarg.h>
@@ -19,11 +19,11 @@
 
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
-#include <asm/cacheflush.h>
 #include <asm/mmu_context.h>
 #include <asm/inst.h>
 #include <asm/elf.h>
 #include <asm/smp.h>
+#include <asm/war.h>
 
 /* #define DEBUG_TLB */
 
@@ -44,6 +44,11 @@ static __init int __attribute__((unused)
 	return BCM1250_M3_WAR;
 }
 
+static __init int __attribute__((unused)) r10000_llsc_war(void)
+{
+	return R10000_LLSC_WAR;
+}
+
 /*
  * A little micro-assembler, intended for TLB refill handler
  * synthesizing. It is intentionally kept simple, does only support
@@ -84,13 +89,14 @@ enum fields
 enum opcode {
 	insn_invalid,
 	insn_addu, insn_addiu, insn_and, insn_andi, insn_beq,
-	insn_bgez, insn_bgezl, insn_bltz, insn_bltzl, insn_bne,
-	insn_daddu, insn_daddiu, insn_dmfc0, insn_dmtc0,
+	insn_beql, insn_bgez, insn_bgezl, insn_bltz, insn_bltzl,
+	insn_bne, insn_daddu, insn_daddiu, insn_dmfc0, insn_dmtc0,
 	insn_dsll, insn_dsll32, insn_dsra, insn_dsrl, insn_dsrl32,
 	insn_dsubu, insn_eret, insn_j, insn_jal, insn_jr, insn_ld,
-	insn_lui, insn_lw, insn_mfc0, insn_mtc0, insn_ori, insn_rfe,
-	insn_sd, insn_sll, insn_sra, insn_srl, insn_subu, insn_sw,
-	insn_tlbp, insn_tlbwi, insn_tlbwr, insn_xor, insn_xori
+	insn_ll, insn_lld, insn_lui, insn_lw, insn_mfc0, insn_mtc0,
+	insn_ori, insn_rfe, insn_sc, insn_scd, insn_sd, insn_sll,
+	insn_sra, insn_srl, insn_subu, insn_sw, insn_tlbp, insn_tlbwi,
+	insn_tlbwr, insn_xor, insn_xori
 };
 
 struct insn {
@@ -114,6 +120,7 @@ static __initdata struct insn insn_table
 	{ insn_and, M(spec_op,0,0,0,0,and_op), RS | RT | RD },
 	{ insn_andi, M(andi_op,0,0,0,0,0), RS | RT | UIMM },
 	{ insn_beq, M(beq_op,0,0,0,0,0), RS | RT | BIMM },
+	{ insn_beql, M(beql_op,0,0,0,0,0), RS | RT | BIMM },
 	{ insn_bgez, M(bcond_op,0,bgez_op,0,0,0), RS | BIMM },
 	{ insn_bgezl, M(bcond_op,0,bgezl_op,0,0,0), RS | BIMM },
 	{ insn_bltz, M(bcond_op,0,bltz_op,0,0,0), RS | BIMM },
@@ -134,12 +141,16 @@ static __initdata struct insn insn_table
 	{ insn_jal, M(jal_op,0,0,0,0,0), JIMM },
 	{ insn_jr, M(spec_op,0,0,0,0,jr_op), RS },
 	{ insn_ld, M(ld_op,0,0,0,0,0), RS | RT | SIMM },
+	{ insn_ll, M(ll_op,0,0,0,0,0), RS | RT | SIMM },
+	{ insn_lld, M(lld_op,0,0,0,0,0), RS | RT | SIMM },
 	{ insn_lui, M(lui_op,0,0,0,0,0), RT | SIMM },
 	{ insn_lw, M(lw_op,0,0,0,0,0), RS | RT | SIMM },
 	{ insn_mfc0, M(cop0_op,mfc_op,0,0,0,0), RT | RD },
 	{ insn_mtc0, M(cop0_op,mtc_op,0,0,0,0), RT | RD },
 	{ insn_ori, M(ori_op,0,0,0,0,0), RS | RT | UIMM },
 	{ insn_rfe, M(cop0_op,cop_op,0,0,0,rfe_op), 0 },
+	{ insn_sc, M(sc_op,0,0,0,0,0), RS | RT | SIMM },
+	{ insn_scd, M(scd_op,0,0,0,0,0), RS | RT | SIMM },
 	{ insn_sd, M(sd_op,0,0,0,0,0), RS | RT | SIMM },
 	{ insn_sll, M(spec_op,0,0,0,0,sll_op), RT | RD | RE },
 	{ insn_sra, M(spec_op,0,0,0,0,sra_op), RT | RD | RE },
@@ -341,6 +352,7 @@ I_u3u1u2(_addu);
 I_u2u1u3(_andi);
 I_u3u1u2(_and);
 I_u1u2s3(_beq);
+I_u1u2s3(_beql);
 I_u1s2(_bgez);
 I_u1s2(_bgezl);
 I_u1s2(_bltz);
@@ -361,12 +373,16 @@ I_u1(_j);
 I_u1(_jal);
 I_u1(_jr);
 I_u2s3u1(_ld);
+I_u2s3u1(_ll);
+I_u2s3u1(_lld);
 I_u1s2(_lui);
 I_u2s3u1(_lw);
 I_u1u2(_mfc0);
 I_u1u2(_mtc0);
 I_u2u1u3(_ori);
 I_0(_rfe);
+I_u2s3u1(_sc);
+I_u2s3u1(_scd);
 I_u2s3u1(_sd);
 I_u2u1u3(_sll);
 I_u2u1u3(_sra);
@@ -389,8 +405,14 @@ enum label_id {
 	label_leave,
 	label_vmalloc,
 	label_vmalloc_done,
-	label_tlbwr_hazard,
-	label_split
+	label_tlbw_hazard,
+	label_split,
+	label_nopage_tlbl,
+	label_nopage_tlbs,
+	label_nopage_tlbm,
+	label_smp_pgtable_change,
+	label_r3000_write_probe_fail,
+	label_r3000_write_probe_ok
 };
 
 struct label {
@@ -416,8 +438,14 @@ L_LA(_second_part)
 L_LA(_leave)
 L_LA(_vmalloc)
 L_LA(_vmalloc_done)
-L_LA(_tlbwr_hazard)
+L_LA(_tlbw_hazard)
 L_LA(_split)
+L_LA(_nopage_tlbl)
+L_LA(_nopage_tlbs)
+L_LA(_nopage_tlbm)
+L_LA(_smp_pgtable_change)
+L_LA(_r3000_write_probe_fail)
+L_LA(_r3000_write_probe_ok)
 
 /* convenience macros for instructions */
 #ifdef CONFIG_MIPS64
@@ -431,6 +459,8 @@ L_LA(_split)
 # define i_ADDIU(buf, rs, rt, val) i_daddiu(buf, rs, rt, val)
 # define i_ADDU(buf, rs, rt, rd) i_daddu(buf, rs, rt, rd)
 # define i_SUBU(buf, rs, rt, rd) i_dsubu(buf, rs, rt, rd)
+# define i_LL(buf, rs, rt, off) i_lld(buf, rs, rt, off)
+# define i_SC(buf, rs, rt, off) i_scd(buf, rs, rt, off)
 #else
 # define i_LW(buf, rs, rt, off) i_lw(buf, rs, rt, off)
 # define i_SW(buf, rs, rt, off) i_sw(buf, rs, rt, off)
@@ -442,28 +472,33 @@ L_LA(_split)
 # define i_ADDIU(buf, rs, rt, val) i_addiu(buf, rs, rt, val)
 # define i_ADDU(buf, rs, rt, rd) i_addu(buf, rs, rt, rd)
 # define i_SUBU(buf, rs, rt, rd) i_subu(buf, rs, rt, rd)
+# define i_LL(buf, rs, rt, off) i_ll(buf, rs, rt, off)
+# define i_SC(buf, rs, rt, off) i_sc(buf, rs, rt, off)
 #endif
 
 #define i_b(buf, off) i_beq(buf, 0, 0, off)
+#define i_beqz(buf, rs, off) i_beq(buf, rs, 0, off)
+#define i_beqzl(buf, rs, off) i_beql(buf, rs, 0, off)
 #define i_bnez(buf, rs, off) i_bne(buf, rs, 0, off)
+#define i_bnezl(buf, rs, off) i_bnel(buf, rs, 0, off)
 #define i_move(buf, a, b) i_ADDU(buf, a, 0, b)
 #define i_nop(buf) i_sll(buf, 0, 0, 0)
 #define i_ssnop(buf) i_sll(buf, 0, 0, 1)
 #define i_ehb(buf) i_sll(buf, 0, 0, 3)
 
-#if CONFIG_MIPS64
-static __init int in_compat_space_p(long addr)
+#ifdef CONFIG_MIPS64
+static __init int __attribute__((unused)) in_compat_space_p(long addr)
 {
 	/* Is this address in 32bit compat space? */
 	return (((addr) & 0xffffffff00000000) == 0xffffffff00000000);
 }
 
-static __init int rel_highest(long val)
+static __init int __attribute__((unused)) rel_highest(long val)
 {
 	return ((((val + 0x800080008000L) >> 48) & 0xffff) ^ 0x8000) - 0x8000;
 }
 
-static __init int rel_higher(long val)
+static __init int __attribute__((unused)) rel_higher(long val)
 {
 	return ((((val + 0x80008000L) >> 32) & 0xffff) ^ 0x8000) - 0x8000;
 }
@@ -550,22 +585,33 @@ static __init void resolve_relocs(struct
 				__resolve_relocs(rel, l);
 }
 
-static __init void copy_handler(struct reloc *rel, struct label *lab,
-				u32 *first, u32 *end, u32* target)
+static __init void move_relocs(struct reloc *rel, u32 *first, u32 *end,
+			       long off)
 {
-	long off = (long)(target - first);
-
-	memcpy(target, first, (end - first) * sizeof(u32));
-
 	for (; rel->lab != label_invalid; rel++)
 		if (rel->addr >= first && rel->addr < end)
 			rel->addr += off;
+}
 
+static __init void move_labels(struct label *lab, u32 *first, u32 *end,
+			       long off)
+{
 	for (; lab->lab != label_invalid; lab++)
 		if (lab->addr >= first && lab->addr < end)
 			lab->addr += off;
 }
 
+static __init void copy_handler(struct reloc *rel, struct label *lab,
+				u32 *first, u32 *end, u32 *target)
+{
+	long off = (long)(target - first);
+
+	memcpy(target, first, (end - first) * sizeof(u32));
+
+	move_relocs(rel, first, end, off);
+	move_labels(lab, first, end, off);
+}
+
 static __init int __attribute__((unused)) insn_has_bdelay(struct reloc *rel,
 							  u32 *addr)
 {
@@ -594,6 +640,20 @@ static void __attribute__((unused)) il_b
 	i_b(p, 0);
 }
 
+static void il_beqz(u32 **p, struct reloc **r, unsigned int reg,
+		    enum label_id l)
+{
+	r_mips_pc16(r, *p, l);
+	i_beqz(p, reg, 0);
+}
+
+static void __attribute__((unused))
+il_beqzl(u32 **p, struct reloc **r, unsigned int reg, enum label_id l)
+{
+	r_mips_pc16(r, *p, l);
+	i_beqzl(p, reg, 0);
+}
+
 static void il_bnez(u32 **p, struct reloc **r, unsigned int reg,
 		    enum label_id l)
 {
@@ -608,7 +668,7 @@ static void il_bgezl(u32 **p, struct rel
 	i_bgezl(p, reg, 0);
 }
 
-/* The only registers allowed in TLB handlers. */
+/* The only general purpose registers allowed in TLB handlers. */
 #define K0		26
 #define K1		27
 
@@ -642,7 +702,6 @@ static __initdata u32 tlb_handler[128];
 static __initdata struct label labels[128];
 static __initdata struct reloc relocs[128];
 
-#ifdef CONFIG_MIPS32
 /*
  * The R3000 TLB handler is simple.
  */
@@ -676,10 +735,11 @@ static void __init build_r3000_tlb_refil
 		panic("TLB refill handler space exceeded");
 
 	printk("Synthesized TLB handler (%u instructions).\n",
-	       p - tlb_handler);
+	       (unsigned int)(p - tlb_handler));
 #ifdef DEBUG_TLB
 	{
 		int i;
+
 		for (i = 0; i < (p - tlb_handler); i++)
 			printk("%08x\n", tlb_handler[i]);
 	}
@@ -688,7 +748,6 @@ static void __init build_r3000_tlb_refil
 	memcpy((void *)CAC_BASE, tlb_handler, 0x80);
 	flush_icache_range(CAC_BASE, CAC_BASE + 0x80);
 }
-#endif /* CONFIG_MIPS32 */
 
 /*
  * The R4000 TLB handler is much more complicated. We have two
@@ -738,12 +797,22 @@ static __init void __attribute__((unused
 }
 
 /*
- * Write random TLB entry, and care about the hazards from the
- * preceeding mtc0 and for the following eret.
+ * Write random or indexed TLB entry, and care about the hazards from
+ * the preceeding mtc0 and for the following eret.
  */
-static __init void build_tlb_write_random_entry(u32 **p, struct label **l,
-						struct reloc **r)
+enum tlb_write_entry { tlb_random, tlb_indexed };
+
+static __init void build_tlb_write_entry(u32 **p, struct label **l,
+					 struct reloc **r,
+					 enum tlb_write_entry wmode)
 {
+	void(*tlbw)(u32 **) = NULL;
+
+	switch (wmode) {
+	case tlb_random: tlbw = i_tlbwr; break;
+	case tlb_indexed: tlbw = i_tlbwi; break;
+	}
+
 	switch (current_cpu_data.cputype) {
 	case CPU_R4000PC:
 	case CPU_R4000SC:
@@ -753,11 +822,11 @@ static __init void build_tlb_write_rando
 	case CPU_R4400MC:
 		/*
 		 * This branch uses up a mtc0 hazard nop slot and saves
-		 * two nops after the tlbwr.
+		 * two nops after the tlbw instruction.
 		 */
-		il_bgezl(p, r, 0, label_tlbwr_hazard);
-		i_tlbwr(p);
-		l_tlbwr_hazard(l, *p);
+		il_bgezl(p, r, 0, label_tlbw_hazard);
+		tlbw(p);
+		l_tlbw_hazard(l, *p);
 		i_nop(p);
 		break;
 
@@ -766,12 +835,13 @@ static __init void build_tlb_write_rando
 	case CPU_R5000:
 	case CPU_R5000A:
 	case CPU_5KC:
+	case CPU_TX49XX:
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
 	case CPU_AU1550:
 		i_nop(p);
-		i_tlbwr(p);
+		tlbw(p);
 		break;
 
 	case CPU_R10000:
@@ -781,24 +851,32 @@ static __init void build_tlb_write_rando
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
-		i_tlbwr(p);
+		tlbw(p);
 		break;
 
 	case CPU_NEVADA:
 		i_nop(p); /* QED specifies 2 nops hazard */
 		/*
 		 * This branch uses up a mtc0 hazard nop slot and saves
-		 * a nop after the tlbwr.
+		 * a nop after the tlbw instruction.
 		 */
-		il_bgezl(p, r, 0, label_tlbwr_hazard);
-		i_tlbwr(p);
-		l_tlbwr_hazard(l, *p);
+		il_bgezl(p, r, 0, label_tlbw_hazard);
+		tlbw(p);
+		l_tlbw_hazard(l, *p);
+		break;
+
+	case CPU_RM7000:
+		i_nop(p);
+		i_nop(p);
+		i_nop(p);
+		i_nop(p);
+		tlbw(p);
 		break;
 
 	case CPU_4KEC:
 	case CPU_24K:
 		i_ehb(p);
-		i_tlbwr(p);
+		tlbw(p);
 		break;
 
 	case CPU_RM9000:
@@ -812,13 +890,32 @@ static __init void build_tlb_write_rando
 		i_ssnop(p);
 		i_ssnop(p);
 		i_ssnop(p);
-		i_tlbwr(p);
+		tlbw(p);
 		i_ssnop(p);
 		i_ssnop(p);
 		i_ssnop(p);
 		i_ssnop(p);
 		break;
 
+	case CPU_VR4111:
+	case CPU_VR4121:
+	case CPU_VR4122:
+	case CPU_VR4181:
+	case CPU_VR4181A:
+		i_nop(p);
+		i_nop(p);
+		tlbw(p);
+		i_nop(p);
+		i_nop(p);
+		break;
+
+	case CPU_VR4131:
+	case CPU_VR4133:
+		i_nop(p);
+		i_nop(p);
+		tlbw(p);
+		break;
+
 	default:
 		panic("No TLB refill handler yet (CPU type: %d)",
 		      current_cpu_data.cputype);
@@ -826,7 +923,7 @@ static __init void build_tlb_write_rando
 	}
 }
 
-#if CONFIG_MIPS64
+#ifdef CONFIG_MIPS64
 /*
  * TMP and PTR are scratch.
  * TMP will be clobbered, PTR will hold the pmd entry.
@@ -844,7 +941,7 @@ build_get_pmde64(u32 **p, struct label *
 	il_bltz(p, r, tmp, label_vmalloc);
 	/* No i_nop needed here, since the next insn doesn't touch TMP. */
 
-# ifdef CONFIG_SMP
+#ifdef CONFIG_SMP
 	/*
 	 * 64 bit SMP has the lower part of &pgd_current[smp_processor_id()]
 	 * stored in CONTEXT.
@@ -852,7 +949,17 @@ build_get_pmde64(u32 **p, struct label *
 	if (in_compat_space_p(pgdc)) {
 		i_dmfc0(p, ptr, C0_CONTEXT);
 		i_dsra(p, ptr, ptr, 23);
+		i_ld(p, ptr, 0, ptr);
 	} else {
+#ifdef CONFIG_BUILD_ELF64
+		i_dmfc0(p, ptr, C0_CONTEXT);
+		i_dsrl(p, ptr, ptr, 23);
+		i_dsll(p, ptr, ptr, 3);
+		i_LA_mostly(p, tmp, pgdc);
+		i_daddu(p, ptr, ptr, tmp);
+		i_dmfc0(p, tmp, C0_BADVADDR);
+		i_ld(p, ptr, rel_lo(pgdc), ptr);
+#else
 		i_dmfc0(p, ptr, C0_CONTEXT);
 		i_lui(p, tmp, rel_highest(pgdc));
 		i_dsll(p, ptr, ptr, 9);
@@ -860,12 +967,13 @@ build_get_pmde64(u32 **p, struct label *
 		i_dsrl32(p, ptr, ptr, 0);
 		i_and(p, ptr, ptr, tmp);
 		i_dmfc0(p, tmp, C0_BADVADDR);
+		i_ld(p, ptr, 0, ptr);
+#endif
 	}
-	i_ld(p, ptr, 0, ptr);
-# else
+#else
 	i_LA_mostly(p, ptr, pgdc);
 	i_ld(p, ptr, rel_lo(pgdc), ptr);
-# endif
+#endif
 
 	l_vmalloc_done(l, *p);
 	i_dsrl(p, tmp, tmp, PGDIR_SHIFT-3); /* get pgd offset in bytes */
@@ -902,13 +1010,14 @@ build_get_pgd_vmalloc64(u32 **p, struct 
 	}
 }
 
-#else /* CONFIG_MIPS32 */
+#else /* !CONFIG_MIPS64 */
 
 /*
  * TMP and PTR are scratch.
  * TMP will be clobbered, PTR will hold the pgd entry.
  */
-static __init void build_get_pgde32(u32 **p, unsigned int tmp, unsigned int ptr)
+static __init void __attribute__((unused))
+build_get_pgde32(u32 **p, unsigned int tmp, unsigned int ptr)
 {
 	long pgdc = (long)pgd_current;
 
@@ -928,17 +1037,13 @@ static __init void build_get_pgde32(u32 
 	i_sll(p, tmp, tmp, PGD_T_LOG2);
 	i_addu(p, ptr, ptr, tmp); /* add in pgd offset */
 }
-#endif /* CONFIG_MIPS32 */
+
+#endif /* !CONFIG_MIPS64 */
 
 static __init void build_adjust_context(u32 **p, unsigned int ctx)
 {
-	unsigned int shift = 0;
-	unsigned int mask = 0xff0;
-
-#if !defined(CONFIG_MIPS64) && !defined(CONFIG_64BIT_PHYS_ADDR)
-	shift++;
-	mask |= 0x008;
-#endif
+	unsigned int shift = 4 - (PTE_T_LOG2 + 1);
+	unsigned int mask = (PTRS_PER_PTE / 2 - 1) << (PTE_T_LOG2 + 1);
 
 	switch (current_cpu_data.cputype) {
 	case CPU_VR41XX:
@@ -994,7 +1099,7 @@ static __init void build_update_entries(
 	 * Kernel is a special case. Only a few CPUs use it.
 	 */
 #ifdef CONFIG_64BIT_PHYS_ADDR
-	if (cpu_has_64bit_gp_regs) {
+	if (cpu_has_64bits) {
 		i_ld(p, tmp, 0, ptep); /* get even pte */
 		i_ld(p, ptep, sizeof(pte_t), ptep); /* get odd pte */
 		i_dsrl(p, tmp, tmp, 6); /* convert to entrylo0 */
@@ -1049,20 +1154,20 @@ static void __init build_r4000_tlb_refil
 		i_MFC0(&p, K0, C0_BADVADDR);
 		i_MFC0(&p, K1, C0_ENTRYHI);
 		i_xor(&p, K0, K0, K1);
-		i_SRL(&p, K0, K0, PAGE_SHIFT+1);
+		i_SRL(&p, K0, K0, PAGE_SHIFT + 1);
 		il_bnez(&p, &r, K0, label_leave);
 		/* No need for i_nop */
 	}
 
 #ifdef CONFIG_MIPS64
-	build_get_pmde64(&p, &l, &r, K0, K1); /* get pmd ptr in K1 */
+	build_get_pmde64(&p, &l, &r, K0, K1); /* get pmd in K1 */
 #else
-	build_get_pgde32(&p, K0, K1); /* get pgd ptr in K1 */
+	build_get_pgde32(&p, K0, K1); /* get pgd in K1 */
 #endif
 
 	build_get_ptep(&p, K0, K1);
 	build_update_entries(&p, K0, K1);
-	build_tlb_write_random_entry(&p, &l, &r);
+	build_tlb_write_entry(&p, &l, &r, tlb_random);
 	l_leave(&l, p);
 	i_eret(&p); /* return from trap */
 
@@ -1121,6 +1226,7 @@ static void __init build_r4000_tlb_refil
 			i_nop(&f);
 		else {
 			copy_handler(relocs, labels, split, split + 1, f);
+			move_labels(labels, f, f + 1, -1);
 			f++;
 			split++;
 		}
@@ -1132,7 +1238,8 @@ static void __init build_r4000_tlb_refil
 #endif /* CONFIG_MIPS64 */
 
 	resolve_relocs(relocs, labels);
-	printk("Synthesized TLB handler (%u instructions).\n", final_len);
+	printk("Synthesized TLB refill handler (%u instructions).\n",
+	       final_len);
 
 #ifdef DEBUG_TLB
 	{
@@ -1147,10 +1254,530 @@ static void __init build_r4000_tlb_refil
 	flush_icache_range(CAC_BASE, CAC_BASE + 0x100);
 }
 
+/*
+ * TLB load/store/modify handlers.
+ *
+ * Only the fastpath gets synthesized at runtime, the slowpath for
+ * do_page_fault remains normal asm.
+ */
+extern void tlb_do_page_fault_0(void);
+extern void tlb_do_page_fault_1(void);
+
+#define __tlb_handler_align \
+	__attribute__((__aligned__(1 << CONFIG_MIPS_L1_CACHE_SHIFT)))
+
+/*
+ * 128 instructions for the fastpath handler is generous and should
+ * never be exceeded.
+ */
+#define FASTPATH_SIZE 128
+
+u32 __tlb_handler_align handle_tlbl[FASTPATH_SIZE];
+u32 __tlb_handler_align handle_tlbs[FASTPATH_SIZE];
+u32 __tlb_handler_align handle_tlbm[FASTPATH_SIZE];
+
+static void __init
+iPTE_LW(u32 **p, struct label **l, unsigned int pte, int offset,
+	unsigned int ptr)
+{
+#ifdef CONFIG_SMP
+# ifdef CONFIG_64BIT_PHYS_ADDR
+	if (cpu_has_64bits)
+		i_lld(p, pte, offset, ptr);
+	else
+# endif
+		i_LL(p, pte, offset, ptr);
+#else
+# ifdef CONFIG_64BIT_PHYS_ADDR
+	if (cpu_has_64bits)
+		i_ld(p, pte, offset, ptr);
+	else
+# endif
+		i_LW(p, pte, offset, ptr);
+#endif
+}
+
+static void __init
+iPTE_SW(u32 **p, struct reloc **r, unsigned int pte, int offset,
+	unsigned int ptr)
+{
+#ifdef CONFIG_SMP
+# ifdef CONFIG_64BIT_PHYS_ADDR
+	if (cpu_has_64bits)
+		i_scd(p, pte, offset, ptr);
+	else
+# endif
+		i_SC(p, pte, offset, ptr);
+
+	if (r10000_llsc_war())
+		il_beqzl(p, r, pte, label_smp_pgtable_change);
+	else
+		il_beqz(p, r, pte, label_smp_pgtable_change);
+
+# ifdef CONFIG_64BIT_PHYS_ADDR
+	if (!cpu_has_64bits) {
+		/* no i_nop needed */
+		i_ll(p, pte, sizeof(pte_t) / 2, ptr);
+		i_ori(p, pte, pte, _PAGE_VALID);
+		i_sc(p, pte, sizeof(pte_t) / 2, ptr);
+		il_beqz(p, r, pte, label_smp_pgtable_change);
+		/* no i_nop needed */
+		i_lw(p, pte, 0, ptr);
+	} else
+		i_nop(p);
+# else
+	i_nop(p);
+# endif
+#else
+# ifdef CONFIG_64BIT_PHYS_ADDR
+	if (cpu_has_64bits)
+		i_sd(p, pte, offset, ptr);
+	else
+# endif
+		i_SW(p, pte, offset, ptr);
+
+# ifdef CONFIG_64BIT_PHYS_ADDR
+	if (!cpu_has_64bits) {
+		i_lw(p, pte, sizeof(pte_t) / 2, ptr);
+		i_ori(p, pte, pte, _PAGE_VALID);
+		i_sw(p, pte, sizeof(pte_t) / 2, ptr);
+		i_lw(p, pte, 0, ptr);
+	}
+# endif
+#endif
+}
+
+/*
+ * Check if PTE is present, if not then jump to LABEL. PTR points to
+ * the page table where this PTE is located, PTE will be re-loaded
+ * with it's original value.
+ */
+static void __init
+build_pte_present(u32 **p, struct label **l, struct reloc **r,
+		  unsigned int pte, unsigned int ptr, enum label_id lid)
+{
+	i_andi(p, pte, pte, _PAGE_PRESENT | _PAGE_READ);
+	i_xori(p, pte, pte, _PAGE_PRESENT | _PAGE_READ);
+	il_bnez(p, r, pte, lid);
+	iPTE_LW(p, l, pte, 0, ptr);
+}
+
+/* Make PTE valid, store result in PTR. */
+static void __init
+build_make_valid(u32 **p, struct reloc **r, unsigned int pte,
+		 unsigned int ptr)
+{
+	i_ori(p, pte, pte, _PAGE_VALID | _PAGE_ACCESSED);
+	iPTE_SW(p, r, pte, 0, ptr);
+}
+
+/*
+ * Check if PTE can be written to, if not branch to LABEL. Regardless
+ * restore PTE with value from PTR when done.
+ */
+static void __init
+build_pte_writable(u32 **p, struct label **l, struct reloc **r,
+		   unsigned int pte, unsigned int ptr, enum label_id lid)
+{
+	i_andi(p, pte, pte, _PAGE_PRESENT | _PAGE_WRITE);
+	i_xori(p, pte, pte, _PAGE_PRESENT | _PAGE_WRITE);
+	il_bnez(p, r, pte, lid);
+	iPTE_LW(p, l, pte, 0, ptr);
+}
+
+/* Make PTE writable, update software status bits as well, then store
+ * at PTR.
+ */
+static void __init
+build_make_write(u32 **p, struct reloc **r, unsigned int pte,
+		 unsigned int ptr)
+{
+	i_ori(p, pte, pte,
+	      _PAGE_ACCESSED | _PAGE_MODIFIED | _PAGE_VALID | _PAGE_DIRTY);
+	iPTE_SW(p, r, pte, 0, ptr);
+}
+
+/*
+ * Check if PTE can be modified, if not branch to LABEL. Regardless
+ * restore PTE with value from PTR when done.
+ */
+static void __init
+build_pte_modifiable(u32 **p, struct label **l, struct reloc **r,
+		     unsigned int pte, unsigned int ptr, enum label_id lid)
+{
+	i_andi(p, pte, pte, _PAGE_WRITE);
+	il_beqz(p, r, pte, lid);
+	iPTE_LW(p, l, pte, 0, ptr);
+}
+
+/*
+ * R3000 style TLB load/store/modify handlers.
+ */
+
+/* This places the pte in the page table at PTR into ENTRYLO0. */
+static void __init
+build_r3000_pte_reload(u32 **p, unsigned int ptr)
+{
+	i_lw(p, ptr, 0, ptr);
+	i_nop(p); /* load delay */
+	i_mtc0(p, ptr, C0_ENTRYLO0);
+	i_nop(p); /* cp0 delay */
+}
+
+/*
+ * The index register may have the probe fail bit set,
+ * because we would trap on access kseg2, i.e. without refill.
+ */
+static void __init
+build_r3000_tlb_write(u32 **p, struct label **l, struct reloc **r,
+		      unsigned int tmp)
+{
+	i_mfc0(p, tmp, C0_INDEX);
+	i_nop(p); /* cp0 delay */
+	il_bltz(p, r, tmp, label_r3000_write_probe_fail);
+	i_nop(p); /* branch delay */
+	i_tlbwi(p);
+	il_b(p, r, label_r3000_write_probe_ok);
+	i_nop(p); /* branch delay */
+	l_r3000_write_probe_fail(l, *p);
+	i_tlbwr(p);
+	l_r3000_write_probe_ok(l, *p);
+}
+
+static void __init
+build_r3000_tlbchange_handler_head(u32 **p, unsigned int pte,
+				   unsigned int ptr)
+{
+	long pgdc = (long)pgd_current;
+
+	i_mfc0(p, pte, C0_BADVADDR);
+	i_lui(p, ptr, rel_hi(pgdc)); /* cp0 delay */
+	i_lw(p, ptr, rel_lo(pgdc), ptr);
+	i_srl(p, pte, pte, 22); /* load delay */
+	i_sll(p, pte, pte, 2);
+	i_addu(p, ptr, ptr, pte);
+	i_mfc0(p, pte, C0_CONTEXT);
+	i_lw(p, ptr, 0, ptr); /* cp0 delay */
+	i_andi(p, pte, pte, 0xffc); /* load delay */
+	i_addu(p, ptr, ptr, pte);
+	i_lw(p, pte, 0, ptr);
+	i_nop(p); /* load delay */
+	i_tlbp(p);
+}
+
+static void __init
+build_r3000_tlbchange_handler_tail(u32 **p, unsigned int tmp)
+{
+	i_mfc0(p, tmp, C0_EPC);
+	i_nop(p); /* cp0 delay */
+	i_jr(p, tmp);
+	i_rfe(p); /* branch delay */
+}
+
+static void __init build_r3000_tlb_load_handler(void)
+{
+	u32 *p = handle_tlbl;
+	struct label *l = labels;
+	struct reloc *r = relocs;
+
+	memset(handle_tlbl, 0, sizeof(handle_tlbl));
+	memset(labels, 0, sizeof(labels));
+	memset(relocs, 0, sizeof(relocs));
+
+	build_r3000_tlbchange_handler_head(&p, K0, K1);
+	build_pte_present(&p, &l, &r, K0, K1, label_nopage_tlbl);
+	build_make_valid(&p, &r, K0, K1);
+	build_r3000_pte_reload(&p, K1);
+	build_r3000_tlb_write(&p, &l, &r, K0);
+	build_r3000_tlbchange_handler_tail(&p, K0);
+
+	l_nopage_tlbl(&l, p);
+	i_j(&p, (unsigned long)tlb_do_page_fault_0 & 0x0fffffff);
+	i_nop(&p);
+
+	if ((p - handle_tlbl) > FASTPATH_SIZE)
+		panic("TLB load handler fastpath space exceeded");
+
+	resolve_relocs(relocs, labels);
+	printk("Synthesized TLB load handler fastpath (%u instructions).\n",
+	       (unsigned int)(p - handle_tlbl));
+
+#ifdef DEBUG_TLB
+	{
+		int i;
+
+		for (i = 0; i < FASTPATH_SIZE; i++)
+			printk("%08x\n", handle_tlbl[i]);
+	}
+#endif
+
+	flush_icache_range((unsigned long)handle_tlbl,
+			   (unsigned long)handle_tlbl + FASTPATH_SIZE * sizeof(u32));
+}
+
+static void __init build_r3000_tlb_store_handler(void)
+{
+	u32 *p = handle_tlbs;
+	struct label *l = labels;
+	struct reloc *r = relocs;
+
+	memset(handle_tlbs, 0, sizeof(handle_tlbs));
+	memset(labels, 0, sizeof(labels));
+	memset(relocs, 0, sizeof(relocs));
+
+	build_r3000_tlbchange_handler_head(&p, K0, K1);
+	build_pte_writable(&p, &l, &r, K0, K1, label_nopage_tlbs);
+	build_make_write(&p, &r, K0, K1);
+	build_r3000_pte_reload(&p, K1);
+	build_r3000_tlb_write(&p, &l, &r, K0);
+	build_r3000_tlbchange_handler_tail(&p, K0);
+
+	l_nopage_tlbs(&l, p);
+	i_j(&p, (unsigned long)tlb_do_page_fault_1 & 0x0fffffff);
+	i_nop(&p);
+
+	if ((p - handle_tlbs) > FASTPATH_SIZE)
+		panic("TLB store handler fastpath space exceeded");
+
+	resolve_relocs(relocs, labels);
+	printk("Synthesized TLB store handler fastpath (%u instructions).\n",
+	       (unsigned int)(p - handle_tlbs));
+
+#ifdef DEBUG_TLB
+	{
+		int i;
+
+		for (i = 0; i < FASTPATH_SIZE; i++)
+			printk("%08x\n", handle_tlbs[i]);
+	}
+#endif
+
+	flush_icache_range((unsigned long)handle_tlbs,
+			   (unsigned long)handle_tlbs + FASTPATH_SIZE * sizeof(u32));
+}
+
+static void __init build_r3000_tlb_modify_handler(void)
+{
+	u32 *p = handle_tlbm;
+	struct label *l = labels;
+	struct reloc *r = relocs;
+
+	memset(handle_tlbm, 0, sizeof(handle_tlbm));
+	memset(labels, 0, sizeof(labels));
+	memset(relocs, 0, sizeof(relocs));
+
+	build_r3000_tlbchange_handler_head(&p, K0, K1);
+	build_pte_modifiable(&p, &l, &r, K0, K1, label_nopage_tlbm);
+	build_make_write(&p, &r, K0, K1);
+	build_r3000_pte_reload(&p, K1);
+	i_tlbwi(&p);
+	build_r3000_tlbchange_handler_tail(&p, K0);
+
+	l_nopage_tlbm(&l, p);
+	i_j(&p, (unsigned long)tlb_do_page_fault_1 & 0x0fffffff);
+	i_nop(&p);
+
+	if ((p - handle_tlbm) > FASTPATH_SIZE)
+		panic("TLB modify handler fastpath space exceeded");
+
+	resolve_relocs(relocs, labels);
+	printk("Synthesized TLB modify handler fastpath (%u instructions).\n",
+	       (unsigned int)(p - handle_tlbm));
+
+#ifdef DEBUG_TLB
+	{
+		int i;
+
+		for (i = 0; i < FASTPATH_SIZE; i++)
+			printk("%08x\n", handle_tlbm[i]);
+	}
+#endif
+
+	flush_icache_range((unsigned long)handle_tlbm,
+			   (unsigned long)handle_tlbm + FASTPATH_SIZE * sizeof(u32));
+}
+
+/*
+ * R4000 style TLB load/store/modify handlers.
+ */
+static void __init
+build_r4000_tlbchange_handler_head(u32 **p, struct label **l,
+				   struct reloc **r, unsigned int pte,
+				   unsigned int ptr)
+{
+#ifdef CONFIG_MIPS64
+	build_get_pmde64(p, l, r, pte, ptr); /* get pmd in ptr */
+#else
+	build_get_pgde32(p, pte, ptr); /* get pgd in ptr */
+#endif
+
+	i_MFC0(p, pte, C0_BADVADDR);
+	i_LW(p, ptr, 0, ptr);
+	i_SRL(p, pte, pte, PAGE_SHIFT + PTE_ORDER - PTE_T_LOG2);
+	i_andi(p, pte, pte, (PTRS_PER_PTE - 1) << PTE_T_LOG2);
+	i_ADDU(p, ptr, ptr, pte);
+
+#ifdef CONFIG_SMP
+	l_smp_pgtable_change(l, *p);
+# endif
+	iPTE_LW(p, l, pte, 0, ptr); /* get even pte */
+	build_tlb_probe_entry(p);
+}
+
+static void __init
+build_r4000_tlbchange_handler_tail(u32 **p, struct label **l,
+				   struct reloc **r, unsigned int tmp,
+				   unsigned int ptr)
+{
+	i_ori(p, ptr, ptr, sizeof(pte_t));
+	i_xori(p, ptr, ptr, sizeof(pte_t));
+	build_update_entries(p, tmp, ptr);
+	build_tlb_write_entry(p, l, r, tlb_indexed);
+	l_leave(l, *p);
+	i_eret(p); /* return from trap */
+
+#ifdef CONFIG_MIPS64
+	build_get_pgd_vmalloc64(p, l, r, tmp, ptr);
+#endif
+}
+
+static void __init build_r4000_tlb_load_handler(void)
+{
+	u32 *p = handle_tlbl;
+	struct label *l = labels;
+	struct reloc *r = relocs;
+
+	memset(handle_tlbl, 0, sizeof(handle_tlbl));
+	memset(labels, 0, sizeof(labels));
+	memset(relocs, 0, sizeof(relocs));
+
+	if (bcm1250_m3_war()) {
+		i_MFC0(&p, K0, C0_BADVADDR);
+		i_MFC0(&p, K1, C0_ENTRYHI);
+		i_xor(&p, K0, K0, K1);
+		i_SRL(&p, K0, K0, PAGE_SHIFT + 1);
+		il_bnez(&p, &r, K0, label_leave);
+		/* No need for i_nop */
+	}
+
+	build_r4000_tlbchange_handler_head(&p, &l, &r, K0, K1);
+	build_pte_present(&p, &l, &r, K0, K1, label_nopage_tlbl);
+	build_make_valid(&p, &r, K0, K1);
+	build_r4000_tlbchange_handler_tail(&p, &l, &r, K0, K1);
+
+	l_nopage_tlbl(&l, p);
+	i_j(&p, (unsigned long)tlb_do_page_fault_0 & 0x0fffffff);
+	i_nop(&p);
+
+	if ((p - handle_tlbl) > FASTPATH_SIZE)
+		panic("TLB load handler fastpath space exceeded");
+
+	resolve_relocs(relocs, labels);
+	printk("Synthesized TLB load handler fastpath (%u instructions).\n",
+	       (unsigned int)(p - handle_tlbl));
+
+#ifdef DEBUG_TLB
+	{
+		int i;
+
+		for (i = 0; i < FASTPATH_SIZE; i++)
+			printk("%08x\n", handle_tlbl[i]);
+	}
+#endif
+
+	flush_icache_range((unsigned long)handle_tlbl,
+			   (unsigned long)handle_tlbl + FASTPATH_SIZE * sizeof(u32));
+}
+
+static void __init build_r4000_tlb_store_handler(void)
+{
+	u32 *p = handle_tlbs;
+	struct label *l = labels;
+	struct reloc *r = relocs;
+
+	memset(handle_tlbs, 0, sizeof(handle_tlbs));
+	memset(labels, 0, sizeof(labels));
+	memset(relocs, 0, sizeof(relocs));
+
+	build_r4000_tlbchange_handler_head(&p, &l, &r, K0, K1);
+	build_pte_writable(&p, &l, &r, K0, K1, label_nopage_tlbs);
+	build_make_write(&p, &r, K0, K1);
+	build_r4000_tlbchange_handler_tail(&p, &l, &r, K0, K1);
+
+	l_nopage_tlbs(&l, p);
+	i_j(&p, (unsigned long)tlb_do_page_fault_1 & 0x0fffffff);
+	i_nop(&p);
+
+	if ((p - handle_tlbs) > FASTPATH_SIZE)
+		panic("TLB store handler fastpath space exceeded");
+
+	resolve_relocs(relocs, labels);
+	printk("Synthesized TLB store handler fastpath (%u instructions).\n",
+	       (unsigned int)(p - handle_tlbs));
+
+#ifdef DEBUG_TLB
+	{
+		int i;
+
+		for (i = 0; i < FASTPATH_SIZE; i++)
+			printk("%08x\n", handle_tlbs[i]);
+	}
+#endif
+
+	flush_icache_range((unsigned long)handle_tlbs,
+			   (unsigned long)handle_tlbs + FASTPATH_SIZE * sizeof(u32));
+}
+
+static void __init build_r4000_tlb_modify_handler(void)
+{
+	u32 *p = handle_tlbm;
+	struct label *l = labels;
+	struct reloc *r = relocs;
+
+	memset(handle_tlbm, 0, sizeof(handle_tlbm));
+	memset(labels, 0, sizeof(labels));
+	memset(relocs, 0, sizeof(relocs));
+
+	build_r4000_tlbchange_handler_head(&p, &l, &r, K0, K1);
+	build_pte_modifiable(&p, &l, &r, K0, K1, label_nopage_tlbm);
+	/* Present and writable bits set, set accessed and dirty bits. */
+	build_make_write(&p, &r, K0, K1);
+	build_r4000_tlbchange_handler_tail(&p, &l, &r, K0, K1);
+
+	l_nopage_tlbm(&l, p);
+	i_j(&p, (unsigned long)tlb_do_page_fault_1 & 0x0fffffff);
+	i_nop(&p);
+
+	if ((p - handle_tlbm) > FASTPATH_SIZE)
+		panic("TLB modify handler fastpath space exceeded");
+
+	resolve_relocs(relocs, labels);
+	printk("Synthesized TLB modify handler fastpath (%u instructions).\n",
+	       (unsigned int)(p - handle_tlbm));
+
+#ifdef DEBUG_TLB
+	{
+		int i;
+
+		for (i = 0; i < FASTPATH_SIZE; i++)
+			printk("%08x\n", handle_tlbm[i]);
+	}
+#endif
+
+	flush_icache_range((unsigned long)handle_tlbm,
+			   (unsigned long)handle_tlbm + FASTPATH_SIZE * sizeof(u32));
+}
+
 void __init build_tlb_refill_handler(void)
 {
+	/*
+	 * The refill handler is generated per-CPU, multi-node systems
+	 * may have local storage for it. The other handlers are only
+	 * needed once.
+	 */
+	static int run_once = 0;
+
 	switch (current_cpu_data.cputype) {
-#ifdef CONFIG_MIPS32
 	case CPU_R2000:
 	case CPU_R3000:
 	case CPU_R3000A:
@@ -1159,13 +1786,18 @@ void __init build_tlb_refill_handler(voi
 	case CPU_TX3922:
 	case CPU_TX3927:
 		build_r3000_tlb_refill_handler();
+		if (!run_once) {
+			build_r3000_tlb_load_handler();
+			build_r3000_tlb_store_handler();
+			build_r3000_tlb_modify_handler();
+			run_once++;
+		}
 		break;
 
 	case CPU_R6000:
 	case CPU_R6000A:
 		panic("No R6000 TLB refill handler yet");
 		break;
-#endif
 
 	case CPU_R8000:
 		panic("No R8000 TLB refill handler yet");
@@ -1173,5 +1805,11 @@ void __init build_tlb_refill_handler(voi
 
 	default:
 		build_r4000_tlb_refill_handler();
+		if (!run_once) {
+			build_r4000_tlb_load_handler();
+			build_r4000_tlb_store_handler();
+			build_r4000_tlb_modify_handler();
+			run_once++;
+		}
 	}
 }
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex32-mips32.S linux-2.6.11-rc3/arch/mips/mm/tlbex32-mips32.S
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex32-mips32.S	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlbex32-mips32.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,253 +0,0 @@
-/*
- * TLB exception handling code for MIPS32 CPUs.
- *
- * Copyright (C) 1994, 1995, 1996 by Ralf Baechle and Andreas Busse
- *
- * Multi-cpu abstraction and reworking:
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- *
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
- *
- * Pete Popov, ppopov@pacbell.net
- * Added 36 bit phys address support.
- * Copyright (C) 2002 MontaVista Software, Inc.
- */
-#include <linux/init.h>
-#include <asm/asm.h>
-#include <asm/cachectl.h>
-#include <asm/fpregdef.h>
-#include <asm/mipsregs.h>
-#include <asm/page.h>
-#include <asm/pgtable-bits.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-
-#define TLB_OPTIMIZE /* If you are paranoid, disable this. */
-
-#ifdef CONFIG_64BIT_PHYS_ADDR
-
-/* We really only support 36 bit physical addresses on MIPS32 */
-#define PTE_L		lw
-#define PTE_S		sw
-#define PTE_SRL		srl
-#define P_MTC0		mtc0
-#define PTE_HALF        4 /* pte_high contains pre-shifted, ready to go entry */
-#define PTE_SIZE        8
-#define PTEP_INDX_MSK	0xff0
-#define PTE_INDX_MSK	0xff8
-#define PTE_INDX_SHIFT 9
-#define CONVERT_PTE(pte)
-#define PTE_MAKEWRITE_HIGH(pte, ptr) \
-	lw	pte, PTE_HALF(ptr); \
-	ori	pte, (_PAGE_VALID | _PAGE_DIRTY); \
-	sw	pte, PTE_HALF(ptr); \
-	lw	pte, 0(ptr);
-
-#define PTE_MAKEVALID_HIGH(pte, ptr) \
-	lw	pte, PTE_HALF(ptr); \
-	ori	pte, pte, _PAGE_VALID; \
-	sw	pte, PTE_HALF(ptr); \
-	lw	pte, 0(ptr);
-
-#else
-
-#define PTE_L		lw
-#define PTE_S		sw
-#define PTE_SRL		srl
-#define P_MTC0		mtc0
-#define PTE_HALF        0
-#define PTE_SIZE	4
-#define PTEP_INDX_MSK	0xff8
-#define PTE_INDX_MSK	0xffc
-#define PTE_INDX_SHIFT	10
-#define CONVERT_PTE(pte) srl pte, pte, 6
-#define PTE_MAKEWRITE_HIGH(pte, ptr)
-#define PTE_MAKEVALID_HIGH(pte, ptr)
-
-#endif  /* CONFIG_64BIT_PHYS_ADDR */
-
-#ifdef CONFIG_64BIT_PHYS_ADDR
-#define GET_PTE_OFF(reg)
-#else
-#define GET_PTE_OFF(reg)	srl	reg, reg, 1
-#endif
-
-/*
- * ABUSE of CPP macros 101.
- *
- * After this macro runs, the pte faulted on is
- * in register PTE, a ptr into the table in which
- * the pte belongs is in PTR.
- */
-
-#ifdef CONFIG_SMP
-#define GET_PGD(scratch, ptr)        \
-	mfc0    ptr, CP0_CONTEXT;    \
-	la      scratch, pgd_current;\
-	srl     ptr, 23;             \
-	sll     ptr, 2;              \
-	addu    ptr, scratch, ptr;   \
-	lw      ptr, (ptr);
-#else
-#define GET_PGD(scratch, ptr)    \
-	lw	ptr, pgd_current;
-#endif
-
-#define LOAD_PTE(pte, ptr) \
-	GET_PGD(pte, ptr)          \
-	mfc0	pte, CP0_BADVADDR; \
-	srl	pte, pte, _PGDIR_SHIFT; \
-	sll	pte, pte, 2; \
-	addu	ptr, ptr, pte; \
-	mfc0	pte, CP0_BADVADDR; \
-	lw	ptr, (ptr); \
-	srl	pte, pte, PTE_INDX_SHIFT; \
-	and	pte, pte, PTE_INDX_MSK; \
-	addu	ptr, ptr, pte; \
-	PTE_L	pte, (ptr);
-
-	/* This places the even/odd pte pair in the page
-	 * table at PTR into ENTRYLO0 and ENTRYLO1 using
-	 * TMP as a scratch register.
-	 */
-#define PTE_RELOAD(ptr, tmp) \
-	ori	ptr, ptr, PTE_SIZE; \
-	xori	ptr, ptr, PTE_SIZE; \
-	PTE_L	tmp, (PTE_HALF+PTE_SIZE)(ptr); \
-	CONVERT_PTE(tmp); \
-	P_MTC0	tmp, CP0_ENTRYLO1; \
-	PTE_L	ptr, PTE_HALF(ptr); \
-	CONVERT_PTE(ptr); \
-	P_MTC0	ptr, CP0_ENTRYLO0;
-
-#define DO_FAULT(write) \
-	.set	noat; \
-	SAVE_ALL; \
-	mfc0	a2, CP0_BADVADDR; \
-	KMODE; \
-	.set	at; \
-	move	a0, sp; \
-	jal	do_page_fault; \
-	 li	a1, write; \
-	j	ret_from_exception; \
-	 nop; \
-	.set	noat;
-
-	/* Check is PTE is present, if not then jump to LABEL.
-	 * PTR points to the page table where this PTE is located,
-	 * when the macro is done executing PTE will be restored
-	 * with it's original value.
-	 */
-#define PTE_PRESENT(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	bnez	pte, label; \
-	PTE_L	pte, (ptr);
-
-	/* Make PTE valid, store result in PTR. */
-#define PTE_MAKEVALID(pte, ptr) \
-	ori	pte, pte, (_PAGE_VALID | _PAGE_ACCESSED); \
-	PTE_S	pte, (ptr);
-
-	/* Check if PTE can be written to, if not branch to LABEL.
-	 * Regardless restore PTE with value from PTR when done.
-	 */
-#define PTE_WRITABLE(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	bnez	pte, label; \
-	PTE_L	pte, (ptr);
-
-	/* Make PTE writable, update software status bits as well,
-	 * then store at PTR.
-	 */
-#define PTE_MAKEWRITE(pte, ptr) \
-	ori	pte, pte, (_PAGE_ACCESSED | _PAGE_MODIFIED | \
-			   _PAGE_VALID | _PAGE_DIRTY); \
-	PTE_S	pte, (ptr);
-
-	.set	noreorder
-
-	.align	5
-	NESTED(handle_tlbl, PT_SIZE, sp)
-	.set	noat
-invalid_tlbl:
-#ifdef TLB_OPTIMIZE
-	/* Test present bit in entry. */
-	LOAD_PTE(k0, k1)
-	tlbp
-	PTE_PRESENT(k0, k1, nopage_tlbl)
-	PTE_MAKEVALID_HIGH(k0, k1)
-	PTE_MAKEVALID(k0, k1)
-	PTE_RELOAD(k1, k0)
-	nop
-	b	1f
-	 tlbwi
-1:
-	nop
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nopage_tlbl:
-	DO_FAULT(0)
-	END(handle_tlbl)
-
-	.align	5
-	NESTED(handle_tlbs, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-        li      k0,0
-	LOAD_PTE(k0, k1)
-	tlbp				# find faulting entry
-	PTE_WRITABLE(k0, k1, nopage_tlbs)
-	PTE_MAKEWRITE(k0, k1)
-	PTE_MAKEWRITE_HIGH(k0, k1)
-	PTE_RELOAD(k1, k0)
-	nop
-	b	1f
-	 tlbwi
-1:
-	nop
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nopage_tlbs:
-	DO_FAULT(1)
-	END(handle_tlbs)
-
-	.align	5
-	NESTED(handle_mod, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-	LOAD_PTE(k0, k1)
-	tlbp					# find faulting entry
-	andi	k0, k0, _PAGE_WRITE
-	beqz	k0, nowrite_mod
-	PTE_L	k0, (k1)
-
-	/* Present and writable bits set, set accessed and dirty bits. */
-	PTE_MAKEWRITE(k0, k1)
-	PTE_MAKEWRITE_HIGH(k0, k1)
-	/* Now reload the entry into the tlb. */
-	PTE_RELOAD(k1, k0)
-	nop
-	b	1f
-	 tlbwi
-1:
-	nop
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nowrite_mod:
-	DO_FAULT(1)
-	END(handle_mod)
-
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex32-r3k.S linux-2.6.11-rc3/arch/mips/mm/tlbex32-r3k.S
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex32-r3k.S	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlbex32-r3k.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,194 +0,0 @@
-/*
- * TLB exception handling code for R2000/R3000.
- *
- * Copyright (C) 1994, 1995, 1996 by Ralf Baechle and Andreas Busse
- *
- * Multi-CPU abstraction reworking:
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- *
- * Further modifications to make this work:
- * Copyright (c) 1998 Harald Koerfgen
- * Copyright (c) 1998, 1999 Gleb Raiko & Vladimir Roganov
- * Copyright (c) 2001 Ralf Baechle
- * Copyright (c) 2001 MIPS Technologies, Inc.
- */
-#include <linux/init.h>
-#include <asm/asm.h>
-#include <asm/cachectl.h>
-#include <asm/fpregdef.h>
-#include <asm/mipsregs.h>
-#include <asm/page.h>
-#include <asm/pgtable-bits.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-
-#define TLB_OPTIMIZE /* If you are paranoid, disable this. */
-
-	/* ABUSE of CPP macros 101. */
-
-	/* After this macro runs, the pte faulted on is
-	 * in register PTE, a ptr into the table in which
-	 * the pte belongs is in PTR.
-	 */
-#define LOAD_PTE(pte, ptr) \
-	mfc0	pte, CP0_BADVADDR; \
-	lw	ptr, pgd_current; \
-	srl	pte, pte, 22; \
-	sll	pte, pte, 2; \
-	addu	ptr, ptr, pte; \
-	mfc0	pte, CP0_CONTEXT; \
-	lw	ptr, (ptr); \
-	andi	pte, pte, 0xffc; \
-	addu	ptr, ptr, pte; \
-	lw	pte, (ptr); \
-	nop;
-
-	/* This places the even/odd pte pair in the page
-	 * table at PTR into ENTRYLO0 and ENTRYLO1 using
-	 * TMP as a scratch register.
-	 */
-#define PTE_RELOAD(ptr) \
-	lw	ptr, (ptr)	; \
-	nop			; \
-	mtc0	ptr, CP0_ENTRYLO0; \
-	nop;
-
-#define DO_FAULT(write) \
-	.set	noat; \
-	.set	macro; \
-	SAVE_ALL; \
-	mfc0	a2, CP0_BADVADDR; \
-	KMODE; \
-	.set	at; \
-	move	a0, sp; \
-	jal	do_page_fault; \
-	 li	a1, write; \
-	j	ret_from_exception; \
-	 nop; \
-	.set	noat; \
-	.set	nomacro;
-
-	/* Check is PTE is present, if not then jump to LABEL.
-	 * PTR points to the page table where this PTE is located,
-	 * when the macro is done executing PTE will be restored
-	 * with it's original value.
-	 */
-#define PTE_PRESENT(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	bnez	pte, label; \
-	.set	push;       \
-	.set	reorder;    \
-	 lw	pte, (ptr); \
-	.set	pop;
-
-	/* Make PTE valid, store result in PTR. */
-#define PTE_MAKEVALID(pte, ptr) \
-	ori	pte, pte, (_PAGE_VALID | _PAGE_ACCESSED); \
-	sw	pte, (ptr);
-
-	/* Check if PTE can be written to, if not branch to LABEL.
-	 * Regardless restore PTE with value from PTR when done.
-	 */
-#define PTE_WRITABLE(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	bnez	pte, label; \
-	.set    push;       \
-	.set    reorder;    \
-	lw      pte, (ptr); \
-	.set    pop;
-
-
-	/* Make PTE writable, update software status bits as well,
-	 * then store at PTR.
-	 */
-#define PTE_MAKEWRITE(pte, ptr) \
-	ori	pte, pte, (_PAGE_ACCESSED | _PAGE_MODIFIED | \
-			   _PAGE_VALID | _PAGE_DIRTY); \
-	sw	pte, (ptr);
-
-/*
- * The index register may have the probe fail bit set,
- * because we would trap on access kseg2, i.e. without refill.
- */
-#define TLB_WRITE(reg) \
-	mfc0	reg, CP0_INDEX; \
-	nop; \
-	bltz    reg, 1f; \
-	 nop; \
-	tlbwi; \
-	j	2f; \
-	 nop; \
-1:	tlbwr; \
-2:
-
-#define RET(reg) \
-	mfc0	reg, CP0_EPC; \
-	nop; \
-	jr	reg; \
-	 rfe
-
-	.set	noreorder
-
-	.align	5
-NESTED(handle_tlbl, PT_SIZE, sp)
-	.set	noat
-
-#ifdef TLB_OPTIMIZE
-	/* Test present bit in entry. */
-	LOAD_PTE(k0, k1)
-        tlbp
-        PTE_PRESENT(k0, k1, nopage_tlbl)
-        PTE_MAKEVALID(k0, k1)
-        PTE_RELOAD(k1)
-	TLB_WRITE(k0)
-	RET(k0)
-nopage_tlbl:
-#endif
-
-	DO_FAULT(0)
-END(handle_tlbl)
-
-NESTED(handle_tlbs, PT_SIZE, sp)
-	.set	noat
-
-#ifdef TLB_OPTIMIZE
-	LOAD_PTE(k0, k1)
-	tlbp                            # find faulting entry
-	PTE_WRITABLE(k0, k1, nopage_tlbs)
-	PTE_MAKEWRITE(k0, k1)
-	PTE_RELOAD(k1)
-	TLB_WRITE(k0)
-	RET(k0)
-nopage_tlbs:
-#endif
-
-	DO_FAULT(1)
-END(handle_tlbs)
-
-	.align	5
-NESTED(handle_mod, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	LOAD_PTE(k0, k1)
-	tlbp					# find faulting entry
-	andi	k0, k0, _PAGE_WRITE
-	beqz	k0, nowrite_mod
-	.set	push
-	.set    reorder
-	lw	k0, (k1)
-	.set    pop
-
-	/* Present and writable bits set, set accessed and dirty bits. */
-	PTE_MAKEWRITE(k0, k1)
-
-	/* Now reload the entry into the tlb. */
-	PTE_RELOAD(k1)
-	tlbwi
-	RET(k0)
-#endif
-
-nowrite_mod:
-	DO_FAULT(1)
-END(handle_mod)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex32-r4k.S linux-2.6.11-rc3/arch/mips/mm/tlbex32-r4k.S
--- linux-2.6.11-rc2-bk10/arch/mips/mm/tlbex32-r4k.S	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/mm/tlbex32-r4k.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,262 +0,0 @@
-/*
- * TLB exception handling code for r4k.
- *
- * Copyright (C) 1994, 1995, 1996 by Ralf Baechle and Andreas Busse
- *
- * Multi-cpu abstraction and reworking:
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- *
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
- */
-#include <linux/init.h>
-#include <linux/config.h>
-
-#include <asm/asm.h>
-#include <asm/offset.h>
-#include <asm/cachectl.h>
-#include <asm/fpregdef.h>
-#include <asm/mipsregs.h>
-#include <asm/page.h>
-#include <asm/pgtable-bits.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-#include <asm/war.h>
-
-#define TLB_OPTIMIZE /* If you are paranoid, disable this. */
-
-#ifdef CONFIG_64BIT_PHYS_ADDR
-#define PTE_L		ld
-#define PTE_S		sd
-#define PTE_SRL		dsrl
-#define P_MTC0		dmtc0
-#define PTE_SIZE	8
-#define PTEP_INDX_MSK	0xff0
-#define PTE_INDX_MSK	0xff8
-#define PTE_INDX_SHIFT	9
-#else
-#define PTE_L		lw
-#define PTE_S		sw
-#define PTE_SRL		srl
-#define P_MTC0		mtc0
-#define PTE_SIZE	4
-#define PTEP_INDX_MSK	0xff8
-#define PTE_INDX_MSK	0xffc
-#define PTE_INDX_SHIFT	10
-#endif
-
-/*
- * ABUSE of CPP macros 101.
- *
- * After this macro runs, the pte faulted on is
- * in register PTE, a ptr into the table in which
- * the pte belongs is in PTR.
- */
-
-#ifdef CONFIG_SMP
-#define GET_PGD(scratch, ptr)        \
-	mfc0    ptr, CP0_CONTEXT;    \
-	la      scratch, pgd_current;\
-	srl     ptr, 23;             \
-	sll     ptr, 2;              \
-	addu    ptr, scratch, ptr;   \
-	lw      ptr, (ptr);
-#else
-#define GET_PGD(scratch, ptr)    \
-	lw	ptr, pgd_current;
-#endif
-
-#define LOAD_PTE(pte, ptr) \
-	GET_PGD(pte, ptr)          \
-	mfc0	pte, CP0_BADVADDR; \
-	srl	pte, pte, _PGDIR_SHIFT; \
-	sll	pte, pte, 2; \
-	addu	ptr, ptr, pte; \
-	mfc0	pte, CP0_BADVADDR; \
-	lw	ptr, (ptr); \
-	srl	pte, pte, PTE_INDX_SHIFT; \
-	and	pte, pte, PTE_INDX_MSK; \
-	addu	ptr, ptr, pte; \
-	PTE_L	pte, (ptr);
-
-	/* This places the even/odd pte pair in the page
-	 * table at PTR into ENTRYLO0 and ENTRYLO1 using
-	 * TMP as a scratch register.
-	 */
-#define PTE_RELOAD(ptr, tmp) \
-	ori	ptr, ptr, PTE_SIZE; \
-	xori	ptr, ptr, PTE_SIZE; \
-	PTE_L	tmp, PTE_SIZE(ptr); \
-	PTE_L	ptr, 0(ptr); \
-	PTE_SRL	tmp, tmp, 6; \
-	P_MTC0	tmp, CP0_ENTRYLO1; \
-	PTE_SRL	ptr, ptr, 6; \
-	P_MTC0	ptr, CP0_ENTRYLO0;
-
-#define DO_FAULT(write) \
-	.set	noat; \
-	SAVE_ALL; \
-	mfc0	a2, CP0_BADVADDR; \
-	KMODE; \
-	.set	at; \
-	move	a0, sp; \
-	jal	do_page_fault; \
-	 li	a1, write; \
-	j	ret_from_exception; \
-	 nop; \
-	.set	noat;
-
-	/* Check is PTE is present, if not then jump to LABEL.
-	 * PTR points to the page table where this PTE is located,
-	 * when the macro is done executing PTE will be restored
-	 * with it's original value.
-	 */
-#define PTE_PRESENT(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	bnez	pte, label; \
-	 PTE_L	pte, (ptr);
-
-	/* Make PTE valid, store result in PTR. */
-#define PTE_MAKEVALID(pte, ptr) \
-	ori	pte, pte, (_PAGE_VALID | _PAGE_ACCESSED); \
-	PTE_S	pte, (ptr);
-
-	/* Check if PTE can be written to, if not branch to LABEL.
-	 * Regardless restore PTE with value from PTR when done.
-	 */
-#define PTE_WRITABLE(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	bnez	pte, label; \
-	 PTE_L	pte, (ptr);
-
-	/* Make PTE writable, update software status bits as well,
-	 * then store at PTR.
-	 */
-#define PTE_MAKEWRITE(pte, ptr) \
-	ori	pte, pte, (_PAGE_ACCESSED | _PAGE_MODIFIED | \
-			   _PAGE_VALID | _PAGE_DIRTY); \
-	PTE_S	pte, (ptr);
-
-
-	.set	noreorder
-
-/*
- * From the IDT errata for the QED RM5230 (Nevada), processor revision 1.0:
- * 2. A timing hazard exists for the TLBP instruction.
- *
- *      stalling_instruction
- *      TLBP
- *
- * The JTLB is being read for the TLBP throughout the stall generated by the
- * previous instruction. This is not really correct as the stalling instruction
- * can modify the address used to access the JTLB.  The failure symptom is that
- * the TLBP instruction will use an address created for the stalling instruction
- * and not the address held in C0_ENHI and thus report the wrong results.
- *
- * The software work-around is to not allow the instruction preceding the TLBP
- * to stall - make it an NOP or some other instruction guaranteed not to stall.
- *
- * Errata 2 will not be fixed.  This errata is also on the R5000.
- *
- * As if we MIPS hackers wouldn't know how to nop pipelines happy ...
- */
-#define R5K_HAZARD nop
-
-	/*
-	 * Note for many R4k variants tlb probes cannot be executed out
-	 * of the instruction cache else you get bogus results.
-	 */
-	.align	5
-	NESTED(handle_tlbl, PT_SIZE, sp)
-	.set	noat
-#if BCM1250_M3_WAR
-	mfc0	k0, CP0_BADVADDR
-	mfc0	k1, CP0_ENTRYHI
-	xor	k0, k1
-	srl	k0, k0, PAGE_SHIFT+1
-	beqz	k0, 1f
-	 nop
-	.set	mips3
-	eret
-	.set	mips0
-1:
-#endif
-invalid_tlbl:
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-	/* Test present bit in entry. */
-	LOAD_PTE(k0, k1)
-	R5K_HAZARD
-	tlbp
-	PTE_PRESENT(k0, k1, nopage_tlbl)
-	PTE_MAKEVALID(k0, k1)
-	PTE_RELOAD(k1, k0)
-	mtc0_tlbw_hazard
-	tlbwi
-	nop
-	tlbw_eret_hazard
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nopage_tlbl:
-	DO_FAULT(0)
-	END(handle_tlbl)
-
-	.align	5
-	NESTED(handle_tlbs, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-        li      k0,0
-	LOAD_PTE(k0, k1)
-	R5K_HAZARD
-	tlbp				# find faulting entry
-	PTE_WRITABLE(k0, k1, nopage_tlbs)
-	PTE_MAKEWRITE(k0, k1)
-	PTE_RELOAD(k1, k0)
-	mtc0_tlbw_hazard
-	tlbwi
-	nop
-	tlbw_eret_hazard
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nopage_tlbs:
-	DO_FAULT(1)
-	END(handle_tlbs)
-
-	.align	5
-	NESTED(handle_mod, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-	LOAD_PTE(k0, k1)
-	R5K_HAZARD
-	tlbp					# find faulting entry
-	andi	k0, k0, _PAGE_WRITE
-	beqz	k0, nowrite_mod
-	 PTE_L	k0, (k1)
-
-	/* Present and writable bits set, set accessed and dirty bits. */
-	PTE_MAKEWRITE(k0, k1)
-
-	/* Now reload the entry into the tlb. */
-	PTE_RELOAD(k1, k0)
-	mtc0_tlbw_hazard
-	tlbwi
-	nop
-	tlbw_eret_hazard
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nowrite_mod:
-	DO_FAULT(1)
-	END(handle_mod)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_3/reset.c linux-2.6.11-rc3/arch/mips/momentum/ocelot_3/reset.c
--- linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_3/reset.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/momentum/ocelot_3/reset.c	2005-02-03 02:55:07.000000000 +0100
@@ -4,7 +4,7 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  *
- * Copyright (C) 1997, 2001 Ralf Baechle
+ * Copyright (C) 1997, 01, 05 Ralf Baechle
  * Copyright 2001 MontaVista Software Inc.
  * Author: jsun@mvista.com or jsun@junsun.net
  *
@@ -20,7 +20,6 @@
  * Copyright (C) 2004 MontaVista Software Inc.
  * Author: Manish Lachwani, mlachwani@mvista.com
  */
-#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/delay.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_3/setup.c linux-2.6.11-rc3/arch/mips/momentum/ocelot_3/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_3/setup.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/momentum/ocelot_3/setup.c	2005-02-03 02:55:23.000000000 +0100
@@ -4,7 +4,7 @@
  * BRIEF MODULE DESCRIPTION
  * Momentum Computer Ocelot-3 board dependent boot routines
  *
- * Copyright (C) 1996, 1997, 2001  Ralf Baechle
+ * Copyright (C) 1996, 1997, 01, 05  Ralf Baechle
  * Copyright (C) 2000 RidgeRun, Inc.
  * Copyright (C) 2001 Red Hat, Inc.
  * Copyright (C) 2002 Momentum Computer
@@ -47,7 +47,6 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_c/irq.c linux-2.6.11-rc3/arch/mips/momentum/ocelot_c/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_c/irq.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/momentum/ocelot_c/irq.c	2005-02-03 02:56:33.000000000 +0100
@@ -5,7 +5,7 @@
  *
  * Copyright 2001 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- * Copyright (C) 2000, 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright (C) 2000, 01, 05 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -28,7 +28,6 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/kernel_stat.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_g/gt-irq.c linux-2.6.11-rc3/arch/mips/momentum/ocelot_g/gt-irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_g/gt-irq.c	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/momentum/ocelot_g/gt-irq.c	2005-02-03 02:57:05.000000000 +0100
@@ -11,6 +11,7 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_g/irq.c linux-2.6.11-rc3/arch/mips/momentum/ocelot_g/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/momentum/ocelot_g/irq.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/momentum/ocelot_g/irq.c	2005-02-03 02:55:23.000000000 +0100
@@ -5,7 +5,7 @@
  *
  * Copyright 2001 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- * Copyright (C) 2000, 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright (C) 2000, 01, 05 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -28,7 +28,6 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/kernel_stat.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/oprofile/Kconfig linux-2.6.11-rc3/arch/mips/oprofile/Kconfig
--- linux-2.6.11-rc2-bk10/arch/mips/oprofile/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/oprofile/Kconfig	2005-02-03 02:55:52.000000000 +0100
@@ -0,0 +1,23 @@
+
+menu "Profiling support"
+	depends on EXPERIMENTAL
+
+config PROFILING
+	bool "Profiling support (EXPERIMENTAL)"
+	help
+	  Say Y here to enable the extended profiling support mechanisms used
+	  by profilers such as OProfile.
+
+
+config OPROFILE
+	tristate "OProfile system profiling (EXPERIMENTAL)"
+	depends on PROFILING
+	help
+	  OProfile is a profiling system capable of profiling the
+	  whole system, include the kernel, kernel modules, libraries,
+	  and applications.
+
+	  If unsure, say N.
+
+endmenu
+
diff -purN linux-2.6.11-rc2-bk10/arch/mips/oprofile/Makefile linux-2.6.11-rc3/arch/mips/oprofile/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/oprofile/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/oprofile/Makefile	2005-02-03 02:55:23.000000000 +0100
@@ -0,0 +1,15 @@
+EXTRA_CFLAGS := -Werror
+
+obj-$(CONFIG_OPROFILE) += oprofile.o
+
+DRIVER_OBJS = $(addprefix ../../../drivers/oprofile/, \
+		oprof.o cpu_buffer.o buffer_sync.o \
+		event_buffer.o oprofile_files.o \
+		oprofilefs.o oprofile_stats.o \
+		timer_int.o )
+
+oprofile-y				:= $(DRIVER_OBJS) common.o
+
+oprofile-$(CONFIG_CPU_MIPS32)		+= op_model_mipsxx.o
+oprofile-$(CONFIG_CPU_MIPS64)		+= op_model_mipsxx.o
+oprofile-$(CONFIG_CPU_RM9000)		+= op_model_rm9000.o
diff -purN linux-2.6.11-rc2-bk10/arch/mips/oprofile/common.c linux-2.6.11-rc3/arch/mips/oprofile/common.c
--- linux-2.6.11-rc2-bk10/arch/mips/oprofile/common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/oprofile/common.c	2005-02-03 02:55:15.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 by Ralf Baechle
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/oprofile.h>
+#include <linux/smp.h>
+#include <asm/cpu-info.h>
+
+#include "op_impl.h"
+
+extern struct op_mips_model op_model_mipsxx __attribute__((weak));
+extern struct op_mips_model op_model_rm9000 __attribute__((weak));
+
+static struct op_mips_model *model;
+
+static struct op_counter_config ctr[20];
+
+static int op_mips_setup(void)
+{
+	/* Pre-compute the values to stuff in the hardware registers.  */
+	model->reg_setup(ctr);
+
+	/* Configure the registers on all cpus.  */
+	on_each_cpu(model->cpu_setup, 0, 0, 1);
+
+        return 0;
+}
+
+static int op_mips_create_files(struct super_block * sb, struct dentry * root)
+{
+	int i;
+
+	for (i = 0; i < model->num_counters; ++i) {
+		struct dentry *dir;
+		char buf[3];
+
+		snprintf(buf, sizeof buf, "%d", i);
+		dir = oprofilefs_mkdir(sb, root, buf);
+
+		oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
+		oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
+		oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
+		/* Dummies.  */
+		oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
+		oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
+		oprofilefs_create_ulong(sb, dir, "exl", &ctr[i].exl);
+		oprofilefs_create_ulong(sb, dir, "unit_mask", &ctr[i].unit_mask);
+	}
+
+	return 0;
+}
+
+static int op_mips_start(void)
+{
+	on_each_cpu(model->cpu_start, NULL, 0, 1);
+
+	return 0;
+}
+
+static void op_mips_stop(void)
+{
+	/* Disable performance monitoring for all counters.  */
+	on_each_cpu(model->cpu_stop, NULL, 0, 1);
+}
+
+void __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	struct op_mips_model *lmodel = NULL;
+
+	switch (current_cpu_data.cputype) {
+	case CPU_24K:
+		lmodel = &op_model_mipsxx;
+		break;
+
+	case CPU_RM9000:
+		lmodel = &op_model_rm9000;
+		break;
+	};
+
+	if (!lmodel)
+		return;
+
+	if (lmodel->init())
+		return;
+
+	model = lmodel;
+
+	ops->create_files = op_mips_create_files;
+	ops->setup = op_mips_setup;
+	ops->start = op_mips_start;
+	ops->stop = op_mips_stop;
+	ops->cpu_type = lmodel->cpu_type;
+
+	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
+	       lmodel->cpu_type);
+}
+
+void oprofile_arch_exit(void)
+{
+	model->exit();
+}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/oprofile/op_impl.h linux-2.6.11-rc3/arch/mips/oprofile/op_impl.h
--- linux-2.6.11-rc2-bk10/arch/mips/oprofile/op_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/oprofile/op_impl.h	2005-02-03 02:56:33.000000000 +0100
@@ -0,0 +1,37 @@
+/**
+ * @file arch/alpha/oprofile/op_impl.h
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author Richard Henderson <rth@twiddle.net>
+ */
+
+#ifndef OP_IMPL_H
+#define OP_IMPL_H 1
+
+/* Per-counter configuration as set via oprofilefs.  */
+struct op_counter_config {
+	unsigned long enabled;
+	unsigned long event;
+	unsigned long count;
+	/* Dummies because I am too lazy to hack the userspace tools.  */
+	unsigned long kernel;
+	unsigned long user;
+	unsigned long exl;
+	unsigned long unit_mask;
+};
+
+/* Per-architecture configury and hooks.  */
+struct op_mips_model {
+	void (*reg_setup) (struct op_counter_config *);
+	void (*cpu_setup) (void * dummy);
+	int (*init)(void);
+	void (*exit)(void);
+	void (*cpu_start)(void *args);
+	void (*cpu_stop)(void *args);
+	char *cpu_type;
+	unsigned char num_counters;
+};
+
+#endif
diff -purN linux-2.6.11-rc2-bk10/arch/mips/oprofile/op_model_rm9000.c linux-2.6.11-rc3/arch/mips/oprofile/op_model_rm9000.c
--- linux-2.6.11-rc2-bk10/arch/mips/oprofile/op_model_rm9000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/oprofile/op_model_rm9000.c	2005-02-03 02:56:10.000000000 +0100
@@ -0,0 +1,137 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 by Ralf Baechle
+ */
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+
+#include "op_impl.h"
+
+#define RM9K_COUNTER1_EVENT(event)	((event) << 0)
+#define RM9K_COUNTER1_SUPERVISOR	(1ULL    <<  7)
+#define RM9K_COUNTER1_KERNEL		(1ULL    <<  8)
+#define RM9K_COUNTER1_USER		(1ULL    <<  9)
+#define RM9K_COUNTER1_ENABLE		(1ULL    << 10)
+#define RM9K_COUNTER1_OVERFLOW		(1ULL    << 15)
+
+#define RM9K_COUNTER2_EVENT(event)	((event) << 16)
+#define RM9K_COUNTER2_SUPERVISOR	(1ULL    << 23)
+#define RM9K_COUNTER2_KERNEL		(1ULL    << 24)
+#define RM9K_COUNTER2_USER		(1ULL    << 25)
+#define RM9K_COUNTER2_ENABLE		(1ULL    << 26)
+#define RM9K_COUNTER2_OVERFLOW		(1ULL    << 31)
+
+extern unsigned int rm9000_perfcount_irq;
+
+static struct rm9k_register_config {
+	unsigned int control;
+	unsigned int reset_counter1;
+	unsigned int reset_counter2;
+} reg;
+
+/* Compute all of the registers in preparation for enabling profiling.  */
+
+static void rm9000_reg_setup(struct op_counter_config *ctr)
+{
+	unsigned int control = 0;
+
+	/* Compute the performance counter control word.  */
+	/* For now count kernel and user mode */
+	if (ctr[0].enabled)
+		control |= RM9K_COUNTER1_EVENT(ctr[0].event) |
+		           RM9K_COUNTER1_KERNEL |
+		           RM9K_COUNTER1_USER |
+		           RM9K_COUNTER1_ENABLE;
+	if (ctr[1].enabled)
+		control |= RM9K_COUNTER2_EVENT(ctr[1].event) |
+		           RM9K_COUNTER2_KERNEL |
+		           RM9K_COUNTER2_USER |
+		           RM9K_COUNTER2_ENABLE;
+	reg.control = control;
+
+	reg.reset_counter1 = 0x80000000 - ctr[0].count;
+	reg.reset_counter2 = 0x80000000 - ctr[1].count;
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void rm9000_cpu_setup (void *args)
+{
+	uint64_t perfcount;
+
+	perfcount = ((uint64_t) reg.reset_counter2 << 32) | reg.reset_counter1;
+	write_c0_perfcount(perfcount);
+}
+
+static void rm9000_cpu_start(void *args)
+{
+	/* Start all counters on current CPU */
+	write_c0_perfcontrol(reg.control);
+}
+
+static void rm9000_cpu_stop(void *args)
+{
+	/* Stop all counters on current CPU */
+	write_c0_perfcontrol(0);
+}
+
+static irqreturn_t rm9000_perfcount_handler(int irq, void * dev_id,
+	struct pt_regs *regs)
+{
+	unsigned int control = read_c0_perfcontrol();
+	uint32_t counter1, counter2;
+	uint64_t counters;
+
+	/*
+	 * RM9000 combines two 32-bit performance counters into a single
+	 * 64-bit coprocessor zero register.  To avoid a race updating the
+	 * registers we need to stop the counters while we're messing with
+	 * them ...
+	 */
+	write_c0_perfcontrol(0);
+
+	counters = read_c0_perfcount();
+	counter1 = counters;
+	counter2 = counters >> 32;
+
+	if (control & RM9K_COUNTER1_OVERFLOW) {
+		oprofile_add_sample(regs, 0);
+		counter1 = reg.reset_counter1;
+	}
+	if (control & RM9K_COUNTER2_OVERFLOW) {
+		oprofile_add_sample(regs, 1);
+		counter2 = reg.reset_counter2;
+	}
+
+	counters = ((uint64_t)counter2 << 32) | counter1;
+	write_c0_perfcount(counters);
+	write_c0_perfcontrol(reg.control);
+
+	return IRQ_HANDLED;
+}
+
+static int rm9000_init(void)
+{
+	return request_irq(rm9000_perfcount_irq, rm9000_perfcount_handler,
+	                   0, "Perfcounter", NULL);
+}
+
+static void rm9000_exit(void)
+{
+	free_irq(rm9000_perfcount_irq, NULL);
+}
+
+struct op_mips_model op_model_rm9000 = {
+	.reg_setup	= rm9000_reg_setup,
+	.cpu_setup	= rm9000_cpu_setup,
+	.init		= rm9000_init,
+	.exit		= rm9000_exit,
+	.cpu_start	= rm9000_cpu_start,
+	.cpu_stop	= rm9000_cpu_stop,
+	.cpu_type	= "mips/rm9000",
+	.num_counters	= 2
+};
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/Makefile linux-2.6.11-rc3/arch/mips/pci/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/pci/Makefile	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/Makefile	2005-02-03 02:54:38.000000000 +0100
@@ -17,6 +17,7 @@ obj-$(CONFIG_MIPS_MSC)		+= ops-msc.o
 obj-$(CONFIG_MIPS_NILE4)	+= ops-nile4.o
 obj-$(CONFIG_MIPS_TX3927)	+= ops-jmr3927.o
 obj-$(CONFIG_PCI_VR41XX)	+= ops-vr41xx.o pci-vr41xx.o
+obj-$(CONFIG_NEC_CMBVR4133)	+= fixup-vr4133.o
 
 #
 # These are still pretty much in the old state, watch, go blind.
@@ -43,7 +44,7 @@ obj-$(CONFIG_PMC_YOSEMITE)	+= fixup-yose
 				   pci-yosemite.o
 obj-$(CONFIG_SGI_IP27)		+= pci-ip27.o
 obj-$(CONFIG_SGI_IP32)		+= fixup-ip32.o ops-mace.o pci-ip32.o
-obj-$(CONFIG_SIBYTE_SB1250)	+= pci-sb1250.o
+obj-$(CONFIG_SIBYTE_SB1250)	+= fixup-sb1250.o pci-sb1250.o
 obj-$(CONFIG_SNI_RM200_PCI)	+= fixup-sni.o ops-sni.o
 obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0219.o
 obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-atlas.c linux-2.6.11-rc3/arch/mips/pci/fixup-atlas.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-atlas.c	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/fixup-atlas.c	2005-02-03 02:57:04.000000000 +0100
@@ -1,3 +1,4 @@
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <asm/mips-boards/atlasint.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-au1000.c linux-2.6.11-rc3/arch/mips/pci/fixup-au1000.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-au1000.c	2005-01-22 02:47:14.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/fixup-au1000.c	2005-02-03 02:55:07.000000000 +0100
@@ -98,6 +98,19 @@ static char irq_tab_alchemy[][5] __initd
 };
 #endif
 
+#ifdef CONFIG_MIPS_MTX1
+static char irq_tab_alchemy[][5] __initdata = {
+ [0] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 00 - AdapterA-Slot0 (top)    */
+ [1] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 01 - AdapterA-Slot1 (bottom) */
+ [2] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 02 - AdapterB-Slot0 (top)    */
+ [3] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 03 - AdapterB-Slot1 (bottom) */
+ [4] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 04 - AdapterC-Slot0 (top)    */
+ [5] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 05 - AdapterC-Slot1 (bottom) */
+ [6] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 06 - AdapterD-Slot0 (top)    */
+ [7] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 07 - AdapterD-Slot1 (bottom) */
+};
+#endif
+
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return irq_tab_alchemy[slot][pin];
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-sb1250.c linux-2.6.11-rc3/arch/mips/pci/fixup-sb1250.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-sb1250.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/fixup-sb1250.c	2005-02-03 02:55:15.000000000 +0100
@@ -0,0 +1,24 @@
+/*
+ *	arch/mips/pci/fixup-sb1250.c
+ *
+ *	Copyright (C) 2004  MIPS Technologies, Inc.  All rights reserved.
+ *	    Author:	Maciej W. Rozycki <macro@mips.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+
+/*
+ * The BCM1250, etc. PCI/HT bridge reports as a host bridge.
+ */
+static void __init quirk_sb1250_ht(struct pci_dev *dev)
+{
+	dev->class = PCI_CLASS_BRIDGE_PCI << 8;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SIBYTE, PCI_DEVICE_ID_BCM1250_HT,
+			quirk_sb1250_ht);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-vr4133.c linux-2.6.11-rc3/arch/mips/pci/fixup-vr4133.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/fixup-vr4133.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/fixup-vr4133.c	2005-02-03 02:55:39.000000000 +0100
@@ -0,0 +1,204 @@
+/*
+ * arch/mips/vr41xx/nec-cmbvr4133/pci_fixup.c
+ *
+ * The NEC CMB-VR4133 Board specific PCI fixups.
+ *
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com> and
+ *         Alex Sapkov <asapkov@ru.mvista.com>
+ *
+ * 2003-2004 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Modified for support in 2.6
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/vr41xx/cmbvr4133.h>
+
+extern int vr4133_rockhopper;
+extern void ali_m1535plus_init(struct pci_dev *dev);
+extern void ali_m5229_init(struct pci_dev *dev);
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	/*
+	 * We have to reset AMD PCnet adapter on Rockhopper since
+	 * PMON leaves it enabled and generating interrupts. This leads
+	 * to a lock if some PCI device driver later enables the IRQ line
+	 * shared with PCnet and there is no AMD PCnet driver to catch its
+	 * interrupts.
+	 */
+#ifdef CONFIG_ROCKHOPPER
+	if (dev->vendor == PCI_VENDOR_ID_AMD &&
+		dev->device == PCI_DEVICE_ID_AMD_LANCE) {
+		inl(pci_resource_start(dev, 0) + 0x18);
+	}
+#endif
+
+	/*
+	 * we have to open the bridges' windows down to 0 because otherwise
+ 	 * we cannot access ISA south bridge I/O registers that get mapped from
+	 * 0. for example, 8259 PIC would be unaccessible without that
+	 */
+	if(dev->vendor == PCI_VENDOR_ID_INTEL && dev->device == PCI_DEVICE_ID_INTEL_S21152BB) {
+		pci_write_config_byte(dev, PCI_IO_BASE, 0);
+		if(dev->bus->number == 0) {
+			pci_write_config_word(dev, PCI_IO_BASE_UPPER16, 0);
+		} else {
+			pci_write_config_word(dev, PCI_IO_BASE_UPPER16, 1);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * M1535 IRQ mapping
+ * Feel free to change this, although it shouldn't be needed
+ */
+#define M1535_IRQ_INTA  7
+#define M1535_IRQ_INTB  9
+#define M1535_IRQ_INTC  10
+#define M1535_IRQ_INTD  11
+
+#define M1535_IRQ_USB   9
+#define M1535_IRQ_IDE   14
+#define M1535_IRQ_IDE2  15
+#define M1535_IRQ_PS2   12
+#define M1535_IRQ_RTC   8
+#define M1535_IRQ_FDC   6
+#define M1535_IRQ_AUDIO 5
+#define M1535_IRQ_COM1  4
+#define M1535_IRQ_COM2  4
+#define M1535_IRQ_IRDA  3
+#define M1535_IRQ_KBD   1
+#define M1535_IRQ_TMR   0
+
+/* Rockhopper "slots" assignment; this is hard-coded ... */
+#define ROCKHOPPER_M5451_SLOT  1
+#define ROCKHOPPER_M1535_SLOT  2
+#define ROCKHOPPER_M5229_SLOT  11
+#define ROCKHOPPER_M5237_SLOT  15
+#define ROCKHOPPER_PMU_SLOT    12
+/* ... and hard-wired. */
+#define ROCKHOPPER_PCI1_SLOT   3
+#define ROCKHOPPER_PCI2_SLOT   4
+#define ROCKHOPPER_PCI3_SLOT   5
+#define ROCKHOPPER_PCI4_SLOT   6
+#define ROCKHOPPER_PCNET_SLOT  1
+
+#define M1535_IRQ_MASK(n) (1 << (n))
+
+#define M1535_IRQ_EDGE  (M1535_IRQ_MASK(M1535_IRQ_TMR)  | \
+                         M1535_IRQ_MASK(M1535_IRQ_KBD)  | \
+                         M1535_IRQ_MASK(M1535_IRQ_COM1) | \
+                         M1535_IRQ_MASK(M1535_IRQ_COM2) | \
+                         M1535_IRQ_MASK(M1535_IRQ_IRDA) | \
+                         M1535_IRQ_MASK(M1535_IRQ_RTC)  | \
+                         M1535_IRQ_MASK(M1535_IRQ_FDC)  | \
+                         M1535_IRQ_MASK(M1535_IRQ_PS2))
+
+#define M1535_IRQ_LEVEL (M1535_IRQ_MASK(M1535_IRQ_IDE)  | \
+                         M1535_IRQ_MASK(M1535_IRQ_USB)  | \
+                         M1535_IRQ_MASK(M1535_IRQ_INTA) | \
+                         M1535_IRQ_MASK(M1535_IRQ_INTB) | \
+                         M1535_IRQ_MASK(M1535_IRQ_INTC) | \
+                         M1535_IRQ_MASK(M1535_IRQ_INTD))
+
+struct irq_map_entry {
+	u16 bus;
+	u8 slot;
+	u8 irq;
+};
+static struct irq_map_entry int_map[] = {
+	{1, ROCKHOPPER_M5451_SLOT, M1535_IRQ_AUDIO},	/* Audio controller */
+	{1, ROCKHOPPER_PCI1_SLOT, M1535_IRQ_INTD},	/* PCI slot #1 */
+	{1, ROCKHOPPER_PCI2_SLOT, M1535_IRQ_INTC},	/* PCI slot #2 */
+	{1, ROCKHOPPER_M5237_SLOT, M1535_IRQ_USB},	/* USB host controller */
+	{1, ROCKHOPPER_M5229_SLOT, IDE_PRIMARY_IRQ},	/* IDE controller */
+	{2, ROCKHOPPER_PCNET_SLOT, M1535_IRQ_INTD},	/* AMD Am79c973 on-board
+							   ethernet */
+	{2, ROCKHOPPER_PCI3_SLOT, M1535_IRQ_INTB},	/* PCI slot #3 */
+	{2, ROCKHOPPER_PCI4_SLOT, M1535_IRQ_INTC}	/* PCI slot #4 */
+};
+
+static int pci_intlines[] =
+    { M1535_IRQ_INTA, M1535_IRQ_INTB, M1535_IRQ_INTC, M1535_IRQ_INTD };
+
+/* Determine the Rockhopper IRQ line number for the PCI device */
+int rockhopper_get_irq(struct pci_dev *dev, u8 pin, u8 slot)
+{
+	struct pci_bus *bus;
+	int i;
+
+	bus = dev->bus;
+	if (bus == NULL)
+		return -1;
+
+	for (i = 0; i < sizeof (int_map) / sizeof (int_map[0]); i++) {
+		if (int_map[i].bus == bus->number && int_map[i].slot == slot) {
+			int line;
+			for (line = 0; line < 4; line++)
+				if (pci_intlines[line] == int_map[i].irq)
+					break;
+			if (line < 4)
+				return pci_intlines[(line + (pin - 1)) % 4];
+			else
+				return int_map[i].irq;
+		}
+	}
+	return -1;
+}
+
+#ifdef CONFIG_ROCKHOPPER
+void i8259_init(void)
+{
+	outb(0x11, 0x20);		/* Master ICW1 */
+	outb(I8259_IRQ_BASE, 0x21);	/* Master ICW2 */
+	outb(0x04, 0x21);		/* Master ICW3 */
+	outb(0x01, 0x21);		/* Master ICW4 */
+	outb(0xff, 0x21);		/* Master IMW */
+
+	outb(0x11, 0xa0);		/* Slave ICW1 */
+	outb(I8259_IRQ_BASE + 8, 0xa1);	/* Slave ICW2 */
+	outb(0x02, 0xa1);		/* Slave ICW3 */
+	outb(0x01, 0xa1);		/* Slave ICW4 */
+	outb(0xff, 0xa1);		/* Slave IMW */
+
+	outb(0x00, 0x4d0);
+	outb(0x02, 0x4d1);	/* USB IRQ9 is level */
+}
+#endif
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	extern int pci_probe_only;
+	pci_probe_only = 1;
+
+#ifdef CONFIG_ROCKHOPPER
+	if( dev->bus->number == 1 && vr4133_rockhopper )  {
+		if(slot == ROCKHOPPER_PCI1_SLOT || slot == ROCKHOPPER_PCI2_SLOT)
+			dev->irq = CMBVR41XX_INTA_IRQ;
+		else
+			dev->irq = rockhopper_get_irq(dev, pin, slot);
+	} else
+		dev->irq = CMBVR41XX_INTA_IRQ;
+#else
+	dev->irq = CMBVR41XX_INTA_IRQ;
+#endif
+
+	return dev->irq;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, ali_m1535plus_init);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M5229, ali_m5229_init);
+
+
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/ops-msc.c linux-2.6.11-rc3/arch/mips/pci/ops-msc.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/ops-msc.c	2005-01-22 02:49:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/ops-msc.c	2005-02-03 02:56:53.000000000 +0100
@@ -1,6 +1,9 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004, 2005  MIPS Technologies, Inc.
+ *    All rights reserved.
+ *    Authors: Carsten Langgaard <carstenl@mips.com>
+ *             Maciej W. Rozycki <macro@mips.com>
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -18,6 +21,7 @@
  * MIPS boards specific PCI support.
  *
  */
+#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/ops-sni.c linux-2.6.11-rc3/arch/mips/pci/ops-sni.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/ops-sni.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/ops-sni.c	2005-02-03 02:55:53.000000000 +0100
@@ -21,9 +21,9 @@
  *
  * ASIC PCI only supports type 1 config cycles.
  */
-static int set_config_address(unsigned char busno, unsigned int devfn, int reg)
+static int set_config_address(unsigned int busno, unsigned int devfn, int reg)
 {
-	if ((busno > 255) || (devfn > 255) || (reg > 255))
+	if ((devfn > 255) || (reg > 255))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
 	if (busno == 0 && devfn >= PCI_DEVFN(8, 0))
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/ops-titan.c linux-2.6.11-rc3/arch/mips/pci/ops-titan.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/ops-titan.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/ops-titan.c	2005-02-03 02:55:23.000000000 +0100
@@ -22,91 +22,69 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-#include <linux/init.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/version.h>
 
-#include <asm/pci.h>
-#include <asm/io.h>
 #include <asm/titan_dep.h>
 
-/*
- * Titan PCI Config Read Byte
- */
 static int titan_read_config(struct pci_bus *bus, unsigned int devfn, int reg,
 	int size, u32 * val)
 {
+	uint32_t address, tmp;
 	int dev, busno, func;
-	uint32_t address_reg, data_reg;
-	uint32_t address;
 
 	busno = bus->number;
 	dev = PCI_SLOT(devfn);
 	func = PCI_FUNC(devfn);
 
-	address_reg = TITAN_PCI_0_CONFIG_ADDRESS;
-	data_reg = TITAN_PCI_0_CONFIG_DATA;
-
 	address = (busno << 16) | (dev << 11) | (func << 8) |
 	          (reg & 0xfc) | 0x80000000;
 
+
 	/* start the configuration cycle */
-	TITAN_WRITE(address_reg, address);
+	TITAN_WRITE(TITAN_PCI_0_CONFIG_ADDRESS, address);
+	tmp = TITAN_READ(TITAN_PCI_0_CONFIG_DATA) >> ((reg & 3) << 3);
 
 	switch (size) {
 	case 1:
-		*val = TITAN_READ_8(data_reg + (~reg & 0x3));
-		break;
-
+		tmp &= 0xff;
 	case 2:
-		*val = TITAN_READ_16(data_reg + (~reg & 0x2));
-		break;
-
-	case 4:
-		*val = TITAN_READ(data_reg);
-		break;
+		tmp &= 0xffff;
 	}
+	*val = tmp;
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-/*
- * Titan PCI Config Byte Write
- */
 static int titan_write_config(struct pci_bus *bus, unsigned int devfn, int reg,
 	int size, u32 val)
 {
-	uint32_t address_reg, data_reg, address;
+	uint32_t address;
 	int dev, busno, func;
 
 	busno = bus->number;
 	dev = PCI_SLOT(devfn);
 	func = PCI_FUNC(devfn);
 
-	address_reg = TITAN_PCI_0_CONFIG_ADDRESS;
-	data_reg = TITAN_PCI_0_CONFIG_DATA;
-
 	address = (busno << 16) | (dev << 11) | (func << 8) |
 		(reg & 0xfc) | 0x80000000;
 
 	/* start the configuration cycle */
-	TITAN_WRITE(address_reg, address);
+	TITAN_WRITE(TITAN_PCI_0_CONFIG_ADDRESS, address);
 
 	/* write the data */
 	switch (size) {
 	case 1:
-		TITAN_WRITE_8(data_reg + (~reg & 0x3), val);
+		TITAN_WRITE_8(TITAN_PCI_0_CONFIG_DATA + (~reg & 0x3), val);
 		break;
 
 	case 2:
-		TITAN_WRITE_16(data_reg + (~reg & 0x2), val);
+		TITAN_WRITE_16(TITAN_PCI_0_CONFIG_DATA + (~reg & 0x2), val);
 		break;
 
 	case 4:
-		TITAN_WRITE(data_reg, val);
+		TITAN_WRITE(TITAN_PCI_0_CONFIG_DATA, val);
 		break;
 	}
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/ops-tx4927.c linux-2.6.11-rc3/arch/mips/pci/ops-tx4927.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/ops-tx4927.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/ops-tx4927.c	2005-02-03 02:55:36.000000000 +0100
@@ -42,8 +42,8 @@
 #include <linux/init.h>
 
 #include <asm/addrspace.h>
+#include <asm/byteorder.h>
 #include <asm/tx4927/tx4927_pci.h>
-#include <asm/debug.h>
 
 /* initialize in setup */
 struct resource pci_io_resource = {
@@ -107,16 +107,6 @@ static int tx4927_pcibios_read_config(st
         dev = PCI_SLOT(devfn);
         func = PCI_FUNC(devfn);
 
-	if (size == 2) {
-		if (where & 1)
-	                return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
-	if (size == 4) {
-		if (where & 3)
-			return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
 	/* check if the bus is top-level */
 	if (bus->parent != NULL) {
 		busno = bus->number;
@@ -130,11 +120,21 @@ static int tx4927_pcibios_read_config(st
 	switch (size) {
 	case 1:
 		*val = *(volatile u8 *) ((ulong) & tx4927_pcicptr->
-                              g2pcfgdata | (where & 3));
+                              g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+						(where & 3));
+#else
+						((where & 0x3) ^ 0x3));
+#endif
 		break;
 	case 2:
 		*val = *(volatile u16 *) ((ulong) & tx4927_pcicptr->
-                               g2pcfgdata | (where & 3));
+                               g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+						(where & 3));
+#else
+						((where & 0x3) ^ 0x2));
+#endif
 		break;
 	case 4:
 		*val = tx4927_pcicptr->g2pcfgdata;
@@ -156,16 +156,6 @@ static int tx4927_pcibios_write_config(s
         dev = PCI_SLOT(devfn);
         func = PCI_FUNC(devfn);
 
-	if (size == 1) {
-		if (where & 1)
-			return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
-	if (size == 4) {
-		if (where & 3)
-			return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
 	/* check if the bus is top-level */
 	if (bus->parent != NULL) {
 		busno = bus->number;
@@ -179,12 +169,22 @@ static int tx4927_pcibios_write_config(s
 	switch (size) {
 	case 1:
 		 *(volatile u8 *) ((ulong) & tx4927_pcicptr->
-                          g2pcfgdata | (where & 3)) = val;
+                          g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+					(where & 3)) = val;
+#else
+					((where & 0x3) ^ 0x3)) = val;
+#endif
 		break;
 
 	case 2:
 		*(volatile u16 *) ((ulong) & tx4927_pcicptr->
-                           g2pcfgdata | (where & 3)) = val;
+                           g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+					(where & 3)) = val;
+#else
+					((where & 0x3) ^ 0x2)) = val;
+#endif
 		break;
 	case 4:
 		tx4927_pcicptr->g2pcfgdata = val;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/pci-sb1250.c linux-2.6.11-rc3/arch/mips/pci/pci-sb1250.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/pci-sb1250.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/pci-sb1250.c	2005-02-03 02:55:15.000000000 +0100
@@ -182,8 +182,8 @@ static int sb1250_pcibios_write(struct p
 }
 
 struct pci_ops sb1250_pci_ops = {
-	.read = sb1250_pcibios_read,
-	.write = sb1250_pcibios_write
+	.read	= sb1250_pcibios_read,
+	.write	= sb1250_pcibios_write,
 };
 
 static struct resource sb1250_mem_resource = {
@@ -192,7 +192,7 @@ static struct resource sb1250_mem_resour
 	.end	= 0x5fffffffUL,
 	.flags	= IORESOURCE_MEM,
 };
-                                                                                
+
 static struct resource sb1250_io_resource = {
 	.name	= "SB1250 PCI I/O",
 	.start	= 0x00000000UL,
@@ -215,9 +215,13 @@ static int __init sb1250_pcibios_init(vo
 	/* CFE will assign PCI resources */
 	pci_probe_only = 1;
 
+	/* Avoid ISA compat ranges.  */
+	PCIBIOS_MIN_IO = 0x00008000UL;
+	PCIBIOS_MIN_MEM = 0x01000000UL;
+
 	/* Set I/O resource limits.  */
-	ioport_resource.end = 0x01ffffff;	/* 32MB accessible by sb1250 */
-	iomem_resource.end = 0xffffffff;	/* no HT support yet */
+	ioport_resource.end = 0x01ffffffUL;	/* 32MB accessible by sb1250 */
+	iomem_resource.end = 0xffffffffUL;	/* no HT support yet */
 
 	cfg_space =
 	    ioremap(A_PHYS_LDTPCI_CFG_MATCH_BITS, 16 * 1024 * 1024);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/pci-vr41xx.c linux-2.6.11-rc3/arch/mips/pci/pci-vr41xx.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/pci-vr41xx.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/pci-vr41xx.c	2005-02-03 02:57:16.000000000 +0100
@@ -270,7 +270,7 @@ static int __init vr41xx_pciu_init(void)
 	/* Clear bus error */
 	readl(BUSERRADREG);
 
-	writel(CONFIG_DONE, PCIENREG);
+	writel(BLOODY_CONFIG_DONE, PCIENREG);
 
 	if (setup->mem_resource != NULL)
 		vr41xx_pci_controller.mem_resource = setup->mem_resource;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/pci-vr41xx.h linux-2.6.11-rc3/arch/mips/pci/pci-vr41xx.h
--- linux-2.6.11-rc2-bk10/arch/mips/pci/pci-vr41xx.h	2005-01-22 02:48:27.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/pci-vr41xx.h	2005-02-03 02:56:10.000000000 +0100
@@ -73,7 +73,7 @@
 #define PCIRECONTREG		KSEG1ADDR(0x0f000c30)
  #define RTRYCNT(reg)		((reg) & 0x000000ffU)
 #define PCIENREG		KSEG1ADDR(0x0f000c34)
- #define CONFIG_DONE		0x4U
+ #define BLOODY_CONFIG_DONE	0x4U
 #define PCICLKSELREG		KSEG1ADDR(0x0f000c38)
  #define EQUAL_VTCLOCK		0x2U
  #define HALF_VTCLOCK		0x0U
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/pci-yosemite.c linux-2.6.11-rc3/arch/mips/pci/pci-yosemite.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/pci-yosemite.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/pci-yosemite.c	2005-02-03 02:56:53.000000000 +0100
@@ -9,7 +9,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/pci.h>
-#include <asm/gt64240.h>
+#include <asm/titan_dep.h>
 
 extern struct pci_ops titan_pci_ops;
 
@@ -23,6 +23,7 @@ static struct resource py_mem_resource =
  * anyway.  So we just claim 64kB here.
  */
 #define TITAN_IO_SIZE	0x0000ffffUL
+#define TITAN_IO_BASE	0xe8000000UL
 
 static struct resource py_io_resource = {
 	"Titan IO MEM", 0x00001000UL, TITAN_IO_SIZE - 1, IORESOURCE_IO,
@@ -42,11 +43,12 @@ static int __init pmc_yosemite_setup(voi
 {
 	unsigned long io_v_base;
 
-	io_v_base = (unsigned long) ioremap(0xe0000000UL,TITAN_IO_SIZE);
+	io_v_base = (unsigned long) ioremap(TITAN_IO_BASE, TITAN_IO_SIZE);
 	if (!io_v_base)
 		panic(ioremap_failed);
 
 	set_io_port_base(io_v_base);
+	TITAN_WRITE(RM9000x2_OCD_LKM7, TITAN_READ(RM9000x2_OCD_LKM7) | 1);
 
 	ioport_resource.end = TITAN_IO_SIZE - 1;
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pci/pci.c linux-2.6.11-rc3/arch/mips/pci/pci.c
--- linux-2.6.11-rc2-bk10/arch/mips/pci/pci.c	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pci/pci.c	2005-02-03 02:56:10.000000000 +0100
@@ -59,7 +59,7 @@ pcibios_align_resource(void *data, struc
 
 	if (res->flags & IORESOURCE_IO) {
 		/* Make sure we start at our min on all hoses */
-		if (start - hose->io_resource->start < PCIBIOS_MIN_IO)
+		if (start < PCIBIOS_MIN_IO + hose->io_resource->start)
 			start = PCIBIOS_MIN_IO + hose->io_resource->start;
 
 		/*
@@ -69,7 +69,7 @@ pcibios_align_resource(void *data, struc
 			start = (start + 0x3ff) & ~0x3ff;
 	} else if (res->flags & IORESOURCE_MEM) {
 		/* Make sure we start at our min on all hoses */
-		if (start - hose->mem_resource->start < PCIBIOS_MIN_MEM)
+		if (start < PCIBIOS_MIN_MEM + hose->mem_resource->start)
 			start = PCIBIOS_MIN_MEM + hose->mem_resource->start;
 	}
 
@@ -294,6 +294,8 @@ pcibios_resource_to_bus(struct pci_dev *
 
 #ifdef CONFIG_HOTPLUG
 EXPORT_SYMBOL(pcibios_resource_to_bus);
+EXPORT_SYMBOL(PCIBIOS_MIN_IO);
+EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif
 
 char *pcibios_setup(char *str)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h	2005-01-22 02:49:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h	2005-02-03 02:56:53.000000000 +0100
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 2003 PMC-Sierra Inc.
  *  Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -29,7 +30,6 @@
  * Header file for atmel_read_eeprom.c 
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/dbg_io.c linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/dbg_io.c
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/dbg_io.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/dbg_io.c	2005-02-03 02:56:48.000000000 +0100
@@ -31,9 +31,6 @@
  * the interrupt came from channel A or B.
  */
 
-#include <linux/config.h>
-
-#ifdef CONFIG_KGDB
 #include <asm/serial.h>
 
 /*
@@ -181,4 +178,3 @@ int putDebugChar(unsigned char byte)
 
 	return 1;
 }
-#endif
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/irq-handler.S linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/irq-handler.S
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/irq-handler.S	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/irq-handler.S	2005-02-03 02:56:34.000000000 +0100
@@ -34,37 +34,24 @@
 
 		and	t0, t2
 
+		andi	t2, t0, STATUSF_IP7	/* INTB5 hardware line */
+		bnez	t2, ll_timer_irq	/* Timer */
 		andi	t1, t0, STATUSF_IP2	/* INTB0 hardware line */
 		bnez	t1, ll_pcia_irq		/* 64-bit PCI */
-		andi	t1, t0, STATUSF_IP3	/* INTB1 hardware line */
-		bnez	t1, ll_pcib_irq		/* second 64-bit PCI slot */
+		andi	t2, t0, STATUSF_IP3	/* INTB1 hardware line */
+		bnez	t2, ll_pcib_irq		/* second 64-bit PCI slot */
 		andi	t1, t0, STATUSF_IP4	/* INTB2 hardware line */
 		bnez	t1, ll_duart_irq	/* UART	*/
-		andi    t1, t0, STATUSF_IP5	/* SMP inter-core interrupts */
-		bnez    t1, ll_smp_irq
+		andi    t2, t0, STATUSF_IP5	/* SMP inter-core interrupts */
+		bnez    t2, ll_smp_irq
 		andi	t1, t0, STATUSF_IP6
 		bnez	t1, ll_ht_irq		/* Hypertransport */
-		andi	t1, t0, STATUSF_IP7	/* INTB5 hardware line */
-		bnez	t1, ll_timer_irq	/* Timer */
 
-		nop
-		nop
-
-		/* Extended interrupts */
-                mfc0    t0, CP0_CAUSE
-                cfc0    t1, CP0_S1_INTCONTROL
-
-                sll     t2, t1, 8
-
-                and     t0, t2
-                srl     t0, t0, 16
-
-		.set	reorder
-
-		j	spurious_interrupt
-		nop
+		move	a0, sp
+		j	do_extended_irq
 		END(titan_handle_int)
 
+		.set	reorder
 		.align	5
 
 ll_pcia_irq:
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/irq.c linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/irq.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/irq.c	2005-02-03 02:56:33.000000000 +0100
@@ -24,7 +24,7 @@
  *
  * Second level Interrupt handlers for the PMC-Sierra Titan/Yosemite board
  */
-
+#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/kernel_stat.h>
@@ -58,7 +58,7 @@
 extern asmlinkage void titan_handle_int(void);
 extern void jaguar_mailbox_irq(struct pt_regs *);
 
-/* 
+/*
  * Handle hypertransport & SMP interrupts. The interrupt lines are scarce.
  * For interprocessor interrupts, the best thing to do is to use the INTMSG
  * register. We use the same external interrupt line, i.e. INTB3 and monitor
@@ -66,15 +66,15 @@ extern void jaguar_mailbox_irq(struct pt
  */
 asmlinkage void ll_ht_smp_irq_handler(int irq, struct pt_regs *regs)
 {
-        u32 status = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
+	u32 status = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
 
 	/* Ack all the bits that correspond to the interrupt sources */
 	if (status != 0)
-	        OCD_WRITE(RM9000x2_OCD_INTP0STATUS4, IRQ_ACK_BITS);
+		OCD_WRITE(RM9000x2_OCD_INTP0STATUS4, IRQ_ACK_BITS);
 
 	status = OCD_READ(RM9000x2_OCD_INTP1STATUS4);
 	if (status != 0)
-                OCD_WRITE(RM9000x2_OCD_INTP1STATUS4, IRQ_ACK_BITS);
+		OCD_WRITE(RM9000x2_OCD_INTP1STATUS4, IRQ_ACK_BITS);
 
 #ifdef CONFIG_HT_LEVEL_TRIGGER
 	/*
@@ -110,6 +110,21 @@ asmlinkage void ll_ht_smp_irq_handler(in
 	do_IRQ(irq, regs);
 }
 
+asmlinkage void do_extended_irq(struct pt_regs *regs)
+{
+	unsigned int intcontrol = read_c0_intcontrol();
+	unsigned int cause = read_c0_cause();
+	unsigned int status = read_c0_status();
+	unsigned int pending_sr, pending_ic;
+
+	pending_sr = status & cause & 0xff00;
+	pending_ic = (cause >> 8) & intcontrol & 0xff00;
+
+	if (pending_ic & (1 << 13))
+		do_IRQ(13, regs);
+
+}
+
 #ifdef CONFIG_KGDB
 extern void init_second_port(void);
 #endif
@@ -124,6 +139,7 @@ void __init arch_init_irq(void)
 	set_except_vector(0, titan_handle_int);
 	mips_cpu_irq_init(0);
 	rm7k_cpu_irq_init(8);
+	rm9k_cpu_irq_init(12);
 
 #ifdef CONFIG_KGDB
 	/* At this point, initialize the second serial port */
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/prom.c linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/prom.c
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/prom.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/prom.c	2005-02-03 02:57:17.000000000 +0100
@@ -43,7 +43,7 @@ const char *get_system_type(void)
 
 static void prom_cpu0_exit(void *arg)
 {
-	void *nvram = (void *) YOSEMITE_NVRAM_BASE_ADDR;
+	void *nvram = (void *) YOSEMITE_RTC_BASE;
 
 	/* Ask the NVRAM/RTC/watchdog chip to assert reset in 1/16 second */
 	writeb(0x84, nvram + 0xff7);
@@ -94,8 +94,6 @@ void __init prom_init(void)
 	_machine_halt = prom_halt;
 	_machine_power_off = prom_halt;
 
-#ifdef CONFIG_MIPS32
-
 	debug_vectors = cv;
 	arcs_cmdline[0] = '\0';
 
@@ -109,6 +107,11 @@ void __init prom_init(void)
 		strcat(arcs_cmdline, " ");
 	}
 
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	if ((strstr(arcs_cmdline, "console=ttyS")) == NULL)
+		strcat(arcs_cmdline, "console=ttyS0,115200");
+#endif
+
 	while (*env) {
 		if (strncmp("ocd_base", *env, strlen("ocd_base")) == 0)
 			yosemite_base =
@@ -122,7 +125,6 @@ void __init prom_init(void)
 
 		env++;
 	}
-#endif /* CONFIG_MIPS32 */
 
 	mips_machgroup = MACH_GROUP_TITAN;
 	mips_machtype = MACH_TITAN_YOSEMITE;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/py-console.c linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/py-console.c
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/py-console.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/py-console.c	2005-02-03 02:55:52.000000000 +0100
@@ -48,9 +48,12 @@ struct yo_uartregs {
 #define iu_iir u3.iir
 #define iu_fcr u3.fcr
 
+#define ssnop()		__asm__ __volatile__("sll	$0, $0, 1\n");
+#define ssnop_4()	do { ssnop(); ssnop(); ssnop(); ssnop(); } while (0)
+
 #define IO_BASE_64	0x9000000000000000ULL
 
-static unsigned char readb_outer_space(unsigned long phys)
+static unsigned char readb_outer_space(unsigned long long phys)
 {
 	unsigned long long vaddr = IO_BASE_64 | phys;
 	unsigned char res;
@@ -58,29 +61,23 @@ static unsigned char readb_outer_space(u
 
 	sr = read_c0_status();
 	write_c0_status((sr | ST0_KX) & ~ ST0_IE);
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
+	ssnop_4();
 
 	__asm__ __volatile__ (
 	"	.set	mips3		\n"
-	"	ld	%0, (%0)	\n"
+	"	ld	%0, %1		\n"
 	"	lbu	%0, (%0)	\n"
 	"	.set	mips0		\n"
 	: "=r" (res)
-	: "0" (&vaddr));
+	: "m" (vaddr));
 
 	write_c0_status(sr);
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
+	ssnop_4();
 
 	return res;
 }
 
-static void writeb_outer_space(unsigned long phys, unsigned char c)
+static void writeb_outer_space(unsigned long long phys, unsigned char c)
 {
 	unsigned long long vaddr = IO_BASE_64 | phys;
 	unsigned long tmp;
@@ -88,30 +85,24 @@ static void writeb_outer_space(unsigned 
 
 	sr = read_c0_status();
 	write_c0_status((sr | ST0_KX) & ~ ST0_IE);
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
+	ssnop_4();
 
 	__asm__ __volatile__ (
 	"	.set	mips3		\n"
-	"	ld	%0, (%1)	\n"
+	"	ld	%0, %1		\n"
 	"	sb	%2, (%0)	\n"
 	"	.set	mips0		\n"
-	: "=r" (tmp)
-	: "r" (&vaddr), "r" (c));
+	: "=&r" (tmp)
+	: "m" (vaddr), "r" (c));
 
 	write_c0_status(sr);
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
-	__asm__("sll	$0, $0, 2\n");
+	ssnop_4();
 }
 
 void prom_putchar(char c)
 {
-	unsigned long lsr = 0xfd000008UL + offsetof(struct yo_uartregs, iu_lsr);
-	unsigned long thr = 0xfd000008UL + offsetof(struct yo_uartregs, iu_thr);
+	unsigned long lsr = 0xfd000008ULL + offsetof(struct yo_uartregs, iu_lsr);
+	unsigned long thr = 0xfd000008ULL + offsetof(struct yo_uartregs, iu_thr);
 
 	while ((readb_outer_space(lsr) & 0x20) == 0);
 	writeb_outer_space(thr, c);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/setup.c linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/setup.c	2005-01-22 02:46:40.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/setup.c	2005-02-03 02:54:37.000000000 +0100
@@ -35,6 +35,10 @@
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/timex.h>
+#include <linux/termios.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
 
 #include <asm/time.h>
 #include <asm/bootinfo.h>
@@ -45,84 +49,80 @@
 #include <asm/ptrace.h>
 #include <asm/reboot.h>
 #include <asm/serial.h>
-#include <linux/termios.h>
-#include <linux/tty.h>
-#include <linux/serial.h>
-#include <linux/serial_core.h>
 #include <asm/titan_dep.h>
+#include <asm/m48t37.h>
 
 #include "setup.h"
 
 unsigned char titan_ge_mac_addr_base[6] = {
-	0x00, 0x03, 0xcc, 0x1d, 0x22, 0x00
+	// 0x00, 0x03, 0xcc, 0x1d, 0x22, 0x00
+	0x00, 0xe0, 0x04, 0x00, 0x00, 0x21
 };
 
 unsigned long cpu_clock;
 unsigned long yosemite_base;
 
+static struct m48t37_rtc *m48t37_base;
+
 void __init bus_error_init(void)
 {
 	/* Do nothing */
 }
 
+
 unsigned long m48t37y_get_time(void)
 {
-	//unsigned char *rtc_base = (unsigned char *) YOSEMITE_RTC_BASE;
-	unsigned char *rtc_base = (unsigned char *) 0xfc000000UL;
 	unsigned int year, month, day, hour, min, sec;
-return;
 
 	/* Stop the update to the time */
-	rtc_base[0x7ff8] = 0x40;
+	m48t37_base->control = 0x40;
 
-	year = BCD2BIN(rtc_base[0x7fff]);
-	year += BCD2BIN(rtc_base[0x7fff1]) * 100;
+	year = BCD2BIN(m48t37_base->year);
+	year += BCD2BIN(m48t37_base->century) * 100;
 
-	month = BCD2BIN(rtc_base[0x7ffe]);
-	day = BCD2BIN(rtc_base[0x7ffd]);
-	hour = BCD2BIN(rtc_base[0x7ffb]);
-	min = BCD2BIN(rtc_base[0x7ffa]);
-	sec = BCD2BIN(rtc_base[0x7ff9]);
+	month = BCD2BIN(m48t37_base->month);
+	day = BCD2BIN(m48t37_base->date);
+	hour = BCD2BIN(m48t37_base->hour);
+	min = BCD2BIN(m48t37_base->min);
+	sec = BCD2BIN(m48t37_base->sec);
 
 	/* Start the update to the time again */
-	rtc_base[0x7ff8] = 0x00;
+	m48t37_base->control = 0x00;
 
 	return mktime(year, month, day, hour, min, sec);
 }
 
 int m48t37y_set_time(unsigned long sec)
 {
-	unsigned char *rtc_base = (unsigned char *) YOSEMITE_RTC_BASE;
 	struct rtc_time tm;
-return;
 
 	/* convert to a more useful format -- note months count from 0 */
 	to_tm(sec, &tm);
 	tm.tm_mon += 1;
 
 	/* enable writing */
-	rtc_base[0x7ff8] = 0x80;
+	m48t37_base->control = 0x80;
 
 	/* year */
-	rtc_base[0x7fff] = BIN2BCD(tm.tm_year % 100);
-	rtc_base[0x7ff1] = BIN2BCD(tm.tm_year / 100);
+	m48t37_base->year = BIN2BCD(tm.tm_year % 100);
+	m48t37_base->century = BIN2BCD(tm.tm_year / 100);
 
 	/* month */
-	rtc_base[0x7ffe] = BIN2BCD(tm.tm_mon);
+	m48t37_base->month = BIN2BCD(tm.tm_mon);
 
 	/* day */
-	rtc_base[0x7ffd] = BIN2BCD(tm.tm_mday);
+	m48t37_base->date = BIN2BCD(tm.tm_mday);
 
 	/* hour/min/sec */
-	rtc_base[0x7ffb] = BIN2BCD(tm.tm_hour);
-	rtc_base[0x7ffa] = BIN2BCD(tm.tm_min);
-	rtc_base[0x7ff9] = BIN2BCD(tm.tm_sec);
+	m48t37_base->hour = BIN2BCD(tm.tm_hour);
+	m48t37_base->min = BIN2BCD(tm.tm_min);
+	m48t37_base->sec = BIN2BCD(tm.tm_sec);
 
 	/* day of week -- not really used, but let's keep it up-to-date */
-	rtc_base[0x7ffc] = BIN2BCD(tm.tm_wday + 1);
+	m48t37_base->day = BIN2BCD(tm.tm_wday + 1);
 
 	/* disable writing */
-	rtc_base[0x7ff8] = 0x00;
+	m48t37_base->control = 0x00;
 
 	return 0;
 }
@@ -136,13 +136,9 @@ void yosemite_time_init(void)
 {
 	board_timer_setup = yosemite_timer_setup;
 	mips_hpt_frequency = cpu_clock / 2;
-
-	rtc_get_time = m48t37y_get_time;
-	rtc_set_time = m48t37y_set_time;
+mips_hpt_frequency = 33000000 * 3 * 5;
 }
 
-unsigned long uart_base = 0xfd000000L;
-
 /* No other usable initialization hook than this ...  */
 extern void (*late_time_init)(void);
 
@@ -161,16 +157,18 @@ EXPORT_SYMBOL(ocd_base);
 
 static void __init py_map_ocd(void)
 {
-        struct uart_port up;
-
-	/*
-	 * Not specifically interrupt stuff but in case of SMP core_send_ipi
-	 * needs this first so I'm mapping it here ...
-	 */
 	ocd_base = (unsigned long) ioremap(OCD_BASE, OCD_SIZE);
 	if (!ocd_base)
 		panic("Mapping OCD failed - game over.  Your score is 0.");
 
+	/* Kludge for PMON bug ... */
+	OCD_WRITE(0x0710, 0x0ffff029);
+}
+
+static void __init py_uart_setup(void)
+{
+	struct uart_port up;
+
 	/*
 	 * Register to interrupt zero because we share the interrupt with
 	 * the serial driver which we don't properly support yet.
@@ -188,12 +186,36 @@ static void __init py_map_ocd(void)
 		printk(KERN_ERR "Early serial init of port 0 failed\n");
 }
 
-static int __init pmc_yosemite_setup(void)
+static void __init py_rtc_setup(void)
+{
+	m48t37_base = ioremap(YOSEMITE_RTC_BASE, YOSEMITE_RTC_SIZE);
+	if (!m48t37_base)
+		printk(KERN_ERR "Mapping the RTC failed\n");
+
+	rtc_get_time = m48t37y_get_time;
+	rtc_set_time = m48t37y_set_time;
+
+	write_seqlock(&xtime_lock);
+	xtime.tv_sec = m48t37y_get_time();
+	xtime.tv_nsec = 0;
+
+	set_normalized_timespec(&wall_to_monotonic,
+	                        -xtime.tv_sec, -xtime.tv_nsec);
+	write_sequnlock(&xtime_lock);
+}
+
+/* Not only time init but that's what the hook it's called through is named */
+static void __init py_late_time_init(void)
 {
-	extern void pmon_smp_bootstrap(void);
+	py_map_ocd();
+	py_uart_setup();
+	py_rtc_setup();
+}
 
+static int __init pmc_yosemite_setup(void)
+{
 	board_time_init = yosemite_time_init;
-	late_time_init = py_map_ocd;
+	late_time_init = py_late_time_init;
 
 	/* Add memory regions */
 	add_memory_region(0x00000000, 0x10000000, BOOT_MEM_RAM);
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/setup.h linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/setup.h
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/setup.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/setup.h	2005-02-03 02:55:50.000000000 +0100
@@ -1,6 +1,7 @@
 /*
- * Copyright 2003 PMC-Sierra
+ * Copyright 2003, 04 PMC-Sierra
  * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ * Copyright 2004 Ralf Baechle <ralf@linux-mips.org>
  *
  * Board specific definititions for the PMC-Sierra Yosemite
  *
@@ -12,9 +13,9 @@
 #ifndef __SETUP_H__
 #define __SETUP_H__
 
-/* NVRAM Base */
-#define	YOSEMITE_NVRAM_BASE_ADDR	0xbb000678	/* XXX Need change */
-#define	YOSEMITE_RTC_BASE		0xbb000679	/* XXX Need change */
+/* M48T37 RTC + NVRAM */
+#define	YOSEMITE_RTC_BASE		0xfc800000
+#define	YOSEMITE_RTC_SIZE		0x00800000
 
 #define HYPERTRANSPORT_BAR0_ADDR        0x00000006
 #define HYPERTRANSPORT_SIZE0            0x0fffffff
diff -purN linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/smp.c linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/smp.c
--- linux-2.6.11-rc2-bk10/arch/mips/pmc-sierra/yosemite/smp.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/pmc-sierra/yosemite/smp.c	2005-02-03 02:55:36.000000000 +0100
@@ -4,6 +4,9 @@
 #include <asm/pmon.h>
 #include <asm/titan_dep.h>
 
+extern unsigned int (*mips_hpt_read)(void);
+extern void (*mips_hpt_init)(unsigned int);
+
 #define LAUNCHSTACK_SIZE 256
 
 static spinlock_t launch_lock __initdata;
@@ -37,8 +40,8 @@ void __init prom_grab_secondary(void)
 {
 	spin_lock(&launch_lock);
 
-	debug_vectors->cpustart(1, &prom_smp_bootstrap,
-	                        launchstack + LAUNCHSTACK_SIZE, 0);
+	pmon_cpustart(1, &prom_smp_bootstrap,
+	              launchstack + LAUNCHSTACK_SIZE, 0);
 }
 
 /*
@@ -47,23 +50,38 @@ void __init prom_grab_secondary(void)
  * We don't want to start the secondary CPU yet nor do we have a nice probing
  * feature in PMON so we just assume presence of the secondary core.
  */
-void prom_prepare_cpus(unsigned int max_cpus)
+static char maxcpus_string[] __initdata =
+	KERN_WARNING "max_cpus set to 0; using 1 instead\n";
+
+void __init prom_prepare_cpus(unsigned int max_cpus)
 {
+	int enabled = 0, i;
+
+	if (max_cpus == 0) {
+		printk(maxcpus_string);
+		max_cpus = 1;
+	}
+
 	cpus_clear(phys_cpu_present_map);
 
-	/*
-	 * The boot CPU
-	 */
-	cpu_set(0, phys_cpu_present_map);
-	__cpu_number_map[0]	= 0;
-	__cpu_logical_map[0]	= 0;
+	for (i = 0; i < 2; i++) {
+		if (i == max_cpus)
+			break;
+
+		/*
+		 * The boot CPU
+		 */
+		cpu_set(i, phys_cpu_present_map);
+		__cpu_number_map[i]	= i;
+		__cpu_logical_map[i]	= i;
+		enabled++;
+	}
 
 	/*
-	 * The secondary core
+	 * Be paranoid.  Enable the IPI only if we're really about to go SMP.
 	 */
-	cpu_set(1, phys_cpu_present_map);
-	__cpu_number_map[1]	= 1;
-	__cpu_logical_map[1]	= 1;
+	if (enabled > 1)
+		set_c0_status(STATUSF_IP5);
 }
 
 /*
@@ -95,6 +113,8 @@ void prom_cpus_done(void)
  */
 void prom_init_secondary(void)
 {
+	mips_hpt_init(mips_hpt_read());
+
 	set_c0_status(ST0_CO | ST0_IE | ST0_IM);
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/Makefile linux-2.6.11-rc3/arch/mips/sgi-ip27/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/Makefile	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/Makefile	2005-02-03 02:56:48.000000000 +0100
@@ -6,6 +6,7 @@ obj-y	:= ip27-berr.o ip27-console.o ip27
 	   ip27-klconfig.o ip27-klnuma.o ip27-memory.o ip27-nmi.o ip27-reset.o \
 	   ip27-timer.o ip27-hubio.o ip27-xtalk.o
 
+obj-$(CONFIG_KGDB)	+= ip27-dbgio.o
 obj-$(CONFIG_SMP)	+= ip27-smp.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-dbgio.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-dbgio.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-dbgio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-dbgio.c	2005-02-03 02:56:10.000000000 +0100
@@ -0,0 +1,60 @@
+/*
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright 2004 Ralf Baechle <ralf@linux-mips.org>
+ */
+#include <asm/sn/addrs.h>
+#include <asm/sn/sn0/hub.h>
+#include <asm/sn/klconfig.h>
+#include <asm/sn/ioc3.h>
+#include <asm/sn/sn_private.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#define IOC3_CLK        (22000000 / 3)
+#define IOC3_FLAGS      (0)
+
+static inline struct ioc3_uartregs *console_uart(void)
+{
+	struct ioc3 *ioc3;
+
+	ioc3 = (struct ioc3 *)KL_CONFIG_CH_CONS_INFO(get_nasid())->memory_base;
+
+	return &ioc3->sregs.uarta;
+}
+
+unsigned char getDebugChar(void)
+{
+	struct ioc3_uartregs *uart = console_uart();
+
+	while ((uart->iu_lsr & UART_LSR_DR) == 0);
+	return uart->iu_rbr;
+}
+
+void putDebugChar(unsigned char c)
+{
+	struct ioc3_uartregs *uart = console_uart();
+
+	while ((uart->iu_lsr & UART_LSR_THRE) == 0);
+	uart->iu_thr = c;
+}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-init.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-init.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-init.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-init.c	2005-02-03 02:56:53.000000000 +0100
@@ -77,15 +77,14 @@ static void __init per_hub_init(cnodeid_
 	 * copy over the caliased exception handlers.
 	 */
 	if (get_compact_nodeid() == cnode) {
-		extern char except_vec0, except_vec1_r4k;
 		extern char except_vec2_generic, except_vec3_generic;
+		extern void build_tlb_refill_handler(void);
 
-		memcpy((void *)(KSEG0 + 0x100), &except_vec2_generic, 0x80);
-		memcpy((void *)(KSEG0 + 0x180), &except_vec3_generic, 0x80);
-		memcpy((void *)KSEG0, &except_vec0, 0x80);
-		memcpy((void *)KSEG0 + 0x080, &except_vec1_r4k, 0x80);
-		memcpy((void *)(KSEG0 + 0x100), (void *) KSEG0, 0x80);
-		memcpy((void *)(KSEG0 + 0x180), &except_vec3_generic, 0x100);
+		memcpy((void *)(CKSEG0 + 0x100), &except_vec2_generic, 0x80);
+		memcpy((void *)(CKSEG0 + 0x180), &except_vec3_generic, 0x80);
+		build_tlb_refill_handler();
+		memcpy((void *)(CKSEG0 + 0x100), (void *) CKSEG0, 0x80);
+		memcpy((void *)(CKSEG0 + 0x180), &except_vec3_generic, 0x100);
 		__flush_cache_all();
 	}
 #endif
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-irq-glue.S linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-irq-glue.S
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-irq-glue.S	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-irq-glue.S	2005-02-03 02:57:05.000000000 +0100
@@ -21,7 +21,7 @@ NESTED(ip27_irq, PT_SIZE, sp)
 	mfc0	t0, CP0_STATUS
 	and	s0, t0
 	move	a0, sp
-	la	ra, ret_from_irq
+	PTR_LA	ra, ret_from_irq
 
 	/* First check for RT interrupt.  */
 	andi	t0, s0, CAUSEF_IP4
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-klnuma.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-klnuma.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-klnuma.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-klnuma.c	2005-02-03 02:55:37.000000000 +0100
@@ -7,6 +7,7 @@
 #include <linux/init.h>
 #include <linux/mmzone.h>
 #include <linux/kernel.h>
+#include <linux/nodemask.h>
 #include <linux/string.h>
 
 #include <asm/page.h>
@@ -19,7 +20,6 @@
 #include <asm/sn/mapped_kernel.h>
 #include <asm/sn/sn_private.h>
 
-extern char _end;
 static cpumask_t ktext_repmask;
 
 /*
@@ -118,12 +118,12 @@ void __init replicate_kernel_text()
  */
 pfn_t node_getfirstfree(cnodeid_t cnode)
 {
-	unsigned long loadbase = CKSEG0;
+	unsigned long loadbase = REP_BASE;
 	nasid_t nasid = COMPACT_TO_NASID_NODEID(cnode);
 	unsigned long offset;
 
 #ifdef CONFIG_MAPPED_KERNEL
-	loadbase = CKSSEG + 16777216;
+	loadbase += 16777216;
 #endif
 	offset = PAGE_ALIGN((unsigned long)(&_end)) - loadbase;
 	if ((cnode == 0) || (cpu_isset(cnode, ktext_repmask)))
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-memory.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-memory.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-memory.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-memory.c	2005-02-03 02:55:23.000000000 +0100
@@ -3,18 +3,20 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2000 by Ralf Baechle
+ * Copyright (C) 2000, 05 by Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2000 by Silicon Graphics, Inc.
  * Copyright (C) 2004 by Christoph Hellwig
  *
  * On SGI IP27 the ARC memory configuration data is completly bogus but
  * alternate easier to use mechanisms are available.
  */
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/mmzone.h>
 #include <linux/module.h>
+#include <linux/nodemask.h>
 #include <linux/swap.h>
 #include <linux/bootmem.h>
 #include <asm/page.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-nmi.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-nmi.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-nmi.c	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-nmi.c	2005-02-03 02:54:38.000000000 +0100
@@ -1,6 +1,7 @@
 #include <linux/kallsyms.h>
 #include <linux/kernel.h>
 #include <linux/mmzone.h>
+#include <linux/nodemask.h>
 #include <linux/spinlock.h>
 #include <linux/smp.h>
 #include <asm/atomic.h>
@@ -21,7 +22,7 @@
 
 typedef unsigned long machreg_t;
 
-spinlock_t nmi_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(nmi_lock);
 
 /*
  * Lets see what else we need to do here. Set up sp, gp?
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-reset.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-reset.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-reset.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-reset.c	2005-02-03 02:55:53.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/timer.h>
 #include <linux/smp.h>
 #include <linux/mmzone.h>
+#include <linux/nodemask.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-smp.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-smp.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-smp.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-smp.c	2005-02-03 02:56:11.000000000 +0100
@@ -8,6 +8,7 @@
  */
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/nodemask.h>
 #include <asm/page.h>
 #include <asm/processor.h>
 #include <asm/sn/arch.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-timer.c linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-timer.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip27/ip27-timer.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip27/ip27-timer.c	2005-02-03 02:57:16.000000000 +0100
@@ -1,9 +1,8 @@
 /*
- * Copytight (C) 1999, 2000 Ralf Baechle (ralf@gnu.org)
+ * Copytight (C) 1999, 2000, 05 Ralf Baechle (ralf@linux-mips.org)
  * Copytight (C) 1999, 2000 Silicon Graphics, Inc.
  */
 #include <linux/bcd.h>
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/Makefile linux-2.6.11-rc3/arch/mips/sgi-ip32/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/Makefile	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip32/Makefile	2005-02-03 02:55:53.000000000 +0100
@@ -4,6 +4,6 @@
 #
 
 obj-y	+= ip32-berr.o ip32-irq.o ip32-irq-glue.o ip32-setup.o ip32-reset.o \
-	   crime.o
+	   crime.o ip32-memory.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/crime.c linux-2.6.11-rc3/arch/mips/sgi-ip32/crime.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/crime.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip32/crime.c	2005-02-03 02:55:15.000000000 +0100
@@ -4,6 +4,7 @@
  * for more details.
  *
  * Copyright (C) 2001, 2003 Keith M Wesolowski
+ * Copyright (C) 2005 Ilya A. Volynets <ilya@total-knowledge.com>
  */
 #include <linux/types.h>
 #include <linux/init.h>
@@ -24,7 +25,8 @@ void __init crime_init(void)
 {
 	unsigned int id, rev;
 	const int field = 2 * sizeof(unsigned long);
-	
+
+	set_io_port_base((unsigned long) ioremap(MACEPCI_LOW_IO, 0x2000000));
 	crime = ioremap(CRIME_BASE, sizeof(struct sgi_crime));
 	mace = ioremap(MACE_BASE, sizeof(struct sgi_mace));
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-irq.c linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-irq.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-irq.c	2005-02-03 02:55:52.000000000 +0100
@@ -117,7 +117,7 @@ static void inline flush_mace_bus(void)
  * IRQ spinlock - Ralf says not to disable CPU interrupts,
  * and I think he knows better.
  */
-static spinlock_t ip32_irq_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(ip32_irq_lock);
 
 /* Some initial interrupts to set up */
 extern irqreturn_t crime_memerr_intr (int irq, void *dev_id,
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-memory.c linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-memory.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-memory.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-memory.c	2005-02-03 02:55:23.000000000 +0100
@@ -0,0 +1,49 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 Keith M Wesolowski
+ * Copyright (C) 2005 Ilya A. Volynets (Total Knowledge)
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+
+#include <asm/ip32/crime.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+
+extern void crime_init(void);
+
+void __init prom_meminit (void)
+{
+	u64 base, size;
+	int bank;
+
+	crime_init();
+
+	for (bank=0; bank < CRIME_MAXBANKS; bank++) {
+		u64 bankctl = crime->bank_ctrl[bank];
+		base = (bankctl & CRIME_MEM_BANK_CONTROL_ADDR) << 25;
+		if (bank != 0 && base == 0)
+			continue;
+		size = (bankctl & CRIME_MEM_BANK_CONTROL_SDRAM_SIZE) ? 128 : 32;
+		size <<= 20;
+		if (base + size > (256 << 20))
+			base += CRIME_HI_MEM_BASE;
+
+		printk("CRIME MC: bank %u base 0x%016lx size %luMB\n",
+			bank, base, size);
+		add_memory_region (base, size, BOOT_MEM_RAM);
+	}
+}
+
+
+unsigned long __init prom_free_prom_memory (void)
+{
+	return 0;
+}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-reset.c linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-reset.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-reset.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-reset.c	2005-02-03 02:56:47.000000000 +0100
@@ -189,11 +189,13 @@ static __init int ip32_reboot_setup(void
 	_machine_restart = ip32_machine_restart;
 	_machine_halt = ip32_machine_halt;
 	_machine_power_off = ip32_machine_power_off;
-	request_irq(MACEISA_RTC_IRQ, ip32_rtc_int, 0, "rtc", NULL);
+
 	init_timer(&blink_timer);
 	blink_timer.function = blink_timeout;
 	notifier_chain_register(&panic_notifier_list, &panic_block);
 
+	request_irq(MACEISA_RTC_IRQ, ip32_rtc_int, 0, "rtc", NULL);
+
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-setup.c linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/sgi-ip32/ip32-setup.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sgi-ip32/ip32-setup.c	2005-02-03 02:56:48.000000000 +0100
@@ -6,7 +6,7 @@
  * for more details.
  *
  * Copyright (C) 2000 Harald Koerfgen
- * Copyright (C) 2002, 03 Ilya A. Volynets
+ * Copyright (C) 2002, 2003, 2005 Ilya A. Volynets
  */
 #include <linux/config.h>
 #include <linux/console.h>
@@ -94,10 +94,6 @@ void __init ip32_timer_setup(struct irqa
 
 static int __init ip32_setup(void)
 {
-	set_io_port_base((unsigned long) ioremap(MACEPCI_LOW_IO, 0x2000000));
-
-	crime_init();
-
 	board_be_init = ip32_be_init;
 
 	rtc_get_time = mc146818_get_cmos_time;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/bcm1250_tbprof.c linux-2.6.11-rc3/arch/mips/sibyte/sb1250/bcm1250_tbprof.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2005-02-03 02:55:50.000000000 +0100
@@ -64,24 +64,24 @@ static void arm_tb(void)
 	u_int64_t tb_options = M_SCD_TRACE_CFG_FREEZE_FULL;
 	/* Generate an SCD_PERFCNT interrupt in TB_PERIOD Zclks to
 	   trigger start of trace.  XXX vary sampling period */
-	__raw_writeq(0, IOADDR(A_SCD_PERF_CNT_1));
-	scdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));
+	bus_writeq(0, IOADDR(A_SCD_PERF_CNT_1));
+	scdperfcnt = bus_readq(IOADDR(A_SCD_PERF_CNT_CFG));
 	/* Unfortunately, in Pass 2 we must clear all counters to knock down
 	   a previous interrupt request.  This means that bus profiling
 	   requires ALL of the SCD perf counters. */
-	__raw_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) | // keep counters 0,2,3 as is
+	bus_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) | // keep counters 0,2,3 as is
 		   M_SPC_CFG_ENABLE |		 // enable counting
 		   M_SPC_CFG_CLEAR |		 // clear all counters
 		   V_SPC_CFG_SRC1(1),		 // counter 1 counts cycles
-	      IOADDR(A_SCD_PERF_CNT_CFG));
-	__raw_writeq(next, IOADDR(A_SCD_PERF_CNT_1));
+		   IOADDR(A_SCD_PERF_CNT_CFG));
+	bus_writeq(next, IOADDR(A_SCD_PERF_CNT_1));
 	/* Reset the trace buffer */
-	__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
+	bus_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 #if 0 && defined(M_SCD_TRACE_CFG_FORCECNT)
 	/* XXXKW may want to expose control to the data-collector */
 	tb_options |= M_SCD_TRACE_CFG_FORCECNT;
 #endif
-	__raw_writeq(tb_options, IOADDR(A_SCD_TRACE_CFG));
+	bus_writeq(tb_options, IOADDR(A_SCD_TRACE_CFG));
 	sbp.tb_armed = 1;
 }
 
@@ -93,22 +93,23 @@ static irqreturn_t sbprof_tb_intr(int ir
 		/* XXX should use XKPHYS to make writes bypass L2 */
 		u_int64_t *p = sbp.sbprof_tbbuf[sbp.next_tb_sample++];
 		/* Read out trace */
-		__raw_writeq(M_SCD_TRACE_CFG_START_READ, IOADDR(A_SCD_TRACE_CFG));
+		bus_writeq(M_SCD_TRACE_CFG_START_READ, IOADDR(A_SCD_TRACE_CFG));
 		__asm__ __volatile__ ("sync" : : : "memory");
 		/* Loop runs backwards because bundles are read out in reverse order */
 		for (i = 256 * 6; i > 0; i -= 6) {
 			// Subscripts decrease to put bundle in the order
 			//   t0 lo, t0 hi, t1 lo, t1 hi, t2 lo, t2 hi
-			p[i-1] = __raw_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 hi
-			p[i-2] = __raw_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 lo
-			p[i-3] = __raw_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 hi
-			p[i-4] = __raw_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 lo
-			p[i-5] = __raw_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 hi
-			p[i-6] = __raw_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 lo
+			p[i-1] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 hi
+			p[i-2] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 lo
+			p[i-3] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 hi
+			p[i-4] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 lo
+			p[i-5] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 hi
+			p[i-6] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 lo
 		}
 		if (!sbp.tb_enable) {
 			DBG(printk(DEVNAME ": tb_intr shutdown\n"));
-			__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
+			bus_writeq(M_SCD_TRACE_CFG_RESET,
+				   IOADDR(A_SCD_TRACE_CFG));
 			sbp.tb_armed = 0;
 			wake_up(&sbp.tb_sync);
 		} else {
@@ -117,7 +118,7 @@ static irqreturn_t sbprof_tb_intr(int ir
 	} else {
 		/* No more trace buffer samples */
 		DBG(printk(DEVNAME ": tb_intr full\n"));
-		__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
+		bus_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 		sbp.tb_armed = 0;
 		if (!sbp.tb_enable) {
 			wake_up(&sbp.tb_sync);
@@ -151,13 +152,13 @@ int sbprof_zbprof_start(struct file *fil
 		return -EBUSY;
 	}
 	/* Make sure there isn't a perf-cnt interrupt waiting */
-	scdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));
+	scdperfcnt = bus_readq(IOADDR(A_SCD_PERF_CNT_CFG));
 	/* Disable and clear counters, override SRC_1 */
-	__raw_writeq((scdperfcnt & ~(M_SPC_CFG_SRC1 | M_SPC_CFG_ENABLE)) |
+	bus_writeq((scdperfcnt & ~(M_SPC_CFG_SRC1 | M_SPC_CFG_ENABLE)) |
 		   M_SPC_CFG_ENABLE |
 		   M_SPC_CFG_CLEAR |
 		   V_SPC_CFG_SRC1(1),
-	      IOADDR(A_SCD_PERF_CNT_CFG));
+		   IOADDR(A_SCD_PERF_CNT_CFG));
 
 	/* We grab this interrupt to prevent others from trying to use
            it, even though we don't want to service the interrupts
@@ -171,52 +172,55 @@ int sbprof_zbprof_start(struct file *fil
 	/* I need the core to mask these, but the interrupt mapper to
 	   pass them through.  I am exploiting my knowledge that
 	   cp0_status masks out IP[5]. krw */
-	__raw_writeq(K_INT_MAP_I3,
-		     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) + (K_INT_PERF_CNT<<3)));
+	bus_writeq(K_INT_MAP_I3,
+		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+			  (K_INT_PERF_CNT << 3)));
 
 	/* Initialize address traps */
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_0));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_1));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_2));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_3));
-
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_0));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_1));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_2));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_3));
-
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_0));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_1));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_2));
-	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_3));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_0));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_1));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_2));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_3));
+
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_0));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_1));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_2));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_3));
+
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_0));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_1));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_2));
+	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_3));
 
 	/* Initialize Trace Event 0-7 */
 	//				when interrupt
-	__raw_writeq(M_SCD_TREVT_INTERRUPT, IOADDR(A_SCD_TRACE_EVENT_0));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_1));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_2));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_3));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_4));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_5));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_6));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_7));
+	bus_writeq(M_SCD_TREVT_INTERRUPT, IOADDR(A_SCD_TRACE_EVENT_0));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_1));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_2));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_3));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_4));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_5));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_6));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_7));
 
 	/* Initialize Trace Sequence 0-7 */
 	//				     Start on event 0 (interrupt)
-	__raw_writeq(V_SCD_TRSEQ_FUNC_START|0x0fff,
-		     IOADDR(A_SCD_TRACE_SEQUENCE_0));
+	bus_writeq(V_SCD_TRSEQ_FUNC_START | 0x0fff,
+		   IOADDR(A_SCD_TRACE_SEQUENCE_0));
 	//			  dsamp when d used | asamp when a used
-	__raw_writeq(M_SCD_TRSEQ_ASAMPLE|M_SCD_TRSEQ_DSAMPLE|K_SCD_TRSEQ_TRIGGER_ALL,
-		     IOADDR(A_SCD_TRACE_SEQUENCE_1));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_2));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_3));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_4));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_5));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_6));
-	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_7));
+	bus_writeq(M_SCD_TRSEQ_ASAMPLE | M_SCD_TRSEQ_DSAMPLE |
+		   K_SCD_TRSEQ_TRIGGER_ALL,
+		   IOADDR(A_SCD_TRACE_SEQUENCE_1));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_2));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_3));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_4));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_5));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_6));
+	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_7));
 
 	/* Now indicate the PERF_CNT interrupt as a trace-relevant interrupt */
-	__raw_writeq((1ULL << K_INT_PERF_CNT), IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_TRACE)));
+	bus_writeq((1ULL << K_INT_PERF_CNT),
+		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_TRACE)));
 
 	arm_tb();
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/bus_watcher.c linux-2.6.11-rc3/arch/mips/sibyte/sb1250/bus_watcher.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/bus_watcher.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/sb1250/bus_watcher.c	2005-02-03 02:55:51.000000000 +0100
@@ -188,7 +188,8 @@ static irqreturn_t sibyte_bw_int(int irq
 	csr_out32(M_SCD_TRACE_CFG_START_READ, IOADDR(A_SCD_TRACE_CFG));
 
 	for (i=0; i<256*6; i++)
-		printk("%016llx\n", (unsigned long long)__raw_readq(IOADDR(A_SCD_TRACE_READ)));
+		printk("%016llx\n",
+		       (unsigned long long)bus_readq(IOADDR(A_SCD_TRACE_READ)));
 
 	csr_out32(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 	csr_out32(M_SCD_TRACE_CFG_START, IOADDR(A_SCD_TRACE_CFG));
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/irq.c linux-2.6.11-rc3/arch/mips/sibyte/sb1250/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/irq.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/sb1250/irq.c	2005-02-03 02:56:48.000000000 +0100
@@ -88,7 +88,7 @@ static struct hw_interrupt_type sb1250_i
 /* Store the CPU id (not the logical number) */
 int sb1250_irq_owner[SB1250_NR_IRQS];
 
-spinlock_t sb1250_imr_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(sb1250_imr_lock);
 
 void sb1250_mask_irq(int cpu, int irq)
 {
@@ -96,9 +96,11 @@ void sb1250_mask_irq(int cpu, int irq)
 	u64 cur_ints;
 
 	spin_lock_irqsave(&sb1250_imr_lock, flags);
-	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) + R_IMR_INTERRUPT_MASK));
+	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
+				      R_IMR_INTERRUPT_MASK));
 	cur_ints |= (((u64) 1) << irq);
-	____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) + R_IMR_INTERRUPT_MASK));
+	__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+				      R_IMR_INTERRUPT_MASK));
 	spin_unlock_irqrestore(&sb1250_imr_lock, flags);
 }
 
@@ -108,9 +110,11 @@ void sb1250_unmask_irq(int cpu, int irq)
 	u64 cur_ints;
 
 	spin_lock_irqsave(&sb1250_imr_lock, flags);
-	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) + R_IMR_INTERRUPT_MASK));
+	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
+				      R_IMR_INTERRUPT_MASK));
 	cur_ints &= ~(((u64) 1) << irq);
-	____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) + R_IMR_INTERRUPT_MASK));
+	__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+				      R_IMR_INTERRUPT_MASK));
 	spin_unlock_irqrestore(&sb1250_imr_lock, flags);
 }
 
@@ -145,19 +149,23 @@ static void sb1250_set_affinity(unsigned
 
 	/* Swizzle each CPU's IMR (but leave the IP selection alone) */
 	old_cpu = sb1250_irq_owner[irq];
-	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(old_cpu) + R_IMR_INTERRUPT_MASK));
+	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(old_cpu) +
+			       R_IMR_INTERRUPT_MASK));
 	int_on = !(cur_ints & (((u64) 1) << irq));
 	if (int_on) {
 		/* If it was on, mask it */
 		cur_ints |= (((u64) 1) << irq);
-		____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(old_cpu) + R_IMR_INTERRUPT_MASK));
+		__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(old_cpu) +
+					      R_IMR_INTERRUPT_MASK));
 	}
 	sb1250_irq_owner[irq] = cpu;
 	if (int_on) {
 		/* unmask for the new CPU */
-		cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) + R_IMR_INTERRUPT_MASK));
+		cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
+				       R_IMR_INTERRUPT_MASK));
 		cur_ints &= ~(((u64) 1) << irq);
-		____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) + R_IMR_INTERRUPT_MASK));
+		__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+					      R_IMR_INTERRUPT_MASK));
 	}
 	spin_unlock(&sb1250_imr_lock);
 	spin_unlock_irqrestore(&desc->lock, flags);
@@ -200,8 +208,8 @@ static void ack_sb1250_irq(unsigned int 
 	 * deliver the interrupts to all CPUs (which makes affinity
 	 * changing easier for us)
 	 */
-	pending = __raw_readq(IOADDR(A_IMR_REGISTER(sb1250_irq_owner[irq],
-						    R_IMR_LDT_INTERRUPT)));
+	pending = bus_readq(IOADDR(A_IMR_REGISTER(sb1250_irq_owner[irq],
+						  R_IMR_LDT_INTERRUPT)));
 	pending &= ((u64)1 << (irq));
 	if (pending) {
 		int i;
@@ -216,8 +224,9 @@ static void ack_sb1250_irq(unsigned int 
 			 * Clear for all CPUs so an affinity switch
 			 * doesn't find an old status
 			 */
-			__raw_writeq(pending, 
-				     IOADDR(A_IMR_REGISTER(cpu, R_IMR_LDT_INTERRUPT_CLR)));
+			bus_writeq(pending,
+				   IOADDR(A_IMR_REGISTER(cpu,
+						R_IMR_LDT_INTERRUPT_CLR)));
 		}
 
 		/*
@@ -331,14 +340,12 @@ void __init arch_init_irq(void)
 
 	/* Default everything to IP2 */
 	for (i = 0; i < SB1250_NR_IRQS; i++) {	/* was I0 */
-		__raw_writeq(IMR_IP2_VAL,
-			     IOADDR(A_IMR_REGISTER(0,
-						   R_IMR_INTERRUPT_MAP_BASE) +
-				    (i << 3)));
-		__raw_writeq(IMR_IP2_VAL,
-			     IOADDR(A_IMR_REGISTER(1,
-						    R_IMR_INTERRUPT_MAP_BASE) +
-				    (i << 3)));
+		bus_writeq(IMR_IP2_VAL,
+			   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+				  (i << 3)));
+		bus_writeq(IMR_IP2_VAL,
+			   IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
+				  (i << 3)));
 	}
 
 	init_sb1250_irqs();
@@ -348,21 +355,23 @@ void __init arch_init_irq(void)
 	 * inter-cpu messages
 	 */
 	/* Was I1 */
-	__raw_writeq(IMR_IP3_VAL, IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-					 (K_INT_MBOX_0 << 3)));
-	__raw_writeq(IMR_IP3_VAL, IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
-					 (K_INT_MBOX_0 << 3)));
+	bus_writeq(IMR_IP3_VAL,
+		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+			  (K_INT_MBOX_0 << 3)));
+	bus_writeq(IMR_IP3_VAL,
+		   IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
+			  (K_INT_MBOX_0 << 3)));
 
 	/* Clear the mailboxes.  The firmware may leave them dirty */
-	__raw_writeq(0xffffffffffffffff,
-		     IOADDR(A_IMR_REGISTER(0, R_IMR_MAILBOX_CLR_CPU)));
-	__raw_writeq(0xffffffffffffffff,
-		     IOADDR(A_IMR_REGISTER(1, R_IMR_MAILBOX_CLR_CPU)));
+	bus_writeq(0xffffffffffffffffULL,
+		   IOADDR(A_IMR_REGISTER(0, R_IMR_MAILBOX_CLR_CPU)));
+	bus_writeq(0xffffffffffffffffULL,
+		   IOADDR(A_IMR_REGISTER(1, R_IMR_MAILBOX_CLR_CPU)));
 
 	/* Mask everything except the mailbox registers for both cpus */
 	tmp = ~((u64) 0) ^ (((u64) 1) << K_INT_MBOX_0);
-	__raw_writeq(tmp, IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MASK)));
-	__raw_writeq(tmp, IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MASK)));
+	bus_writeq(tmp, IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MASK)));
+	bus_writeq(tmp, IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MASK)));
 
 	sb1250_steal_irq(K_INT_MBOX_0);
 
@@ -387,12 +396,12 @@ void __init arch_init_irq(void)
 		sb1250_duart_present[kgdb_port] = 0;
 #endif
 		/* Setup uart 1 settings, mapper */
-		__raw_writeq(M_DUART_IMR_BRK, IOADDR(A_DUART_IMRREG(kgdb_port)));
+		bus_writeq(M_DUART_IMR_BRK, IOADDR(A_DUART_IMRREG(kgdb_port)));
 
 		sb1250_steal_irq(kgdb_irq);
-		__raw_writeq(IMR_IP6_VAL,
-			     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-				    (kgdb_irq<<3)));
+		bus_writeq(IMR_IP6_VAL,
+			   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+				  (kgdb_irq<<3)));
 		sb1250_unmask_irq(0, kgdb_irq);
 	}
 #endif
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/irq_handler.S linux-2.6.11-rc3/arch/mips/sibyte/sb1250/irq_handler.S
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/irq_handler.S	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/sb1250/irq_handler.S	2005-02-03 02:55:51.000000000 +0100
@@ -123,7 +123,7 @@
 	 * check the 1250 interrupt registers to figure out what to do
 	 * Need to detect which CPU we're on, now that smp_affinity is supported.
 	 */
-	PTR_LA	v0, KSEG1 + A_IMR_CPU0_BASE
+	PTR_LA	v0, CKSEG1 + A_IMR_CPU0_BASE
 #ifdef CONFIG_SMP
 	lw	t1, TI_CPU($28)
 	sll	t1, IMR_REGISTER_SPACING_SHIFT
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/setup.c linux-2.6.11-rc3/arch/mips/sibyte/sb1250/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/setup.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/sb1250/setup.c	2005-02-03 02:55:15.000000000 +0100
@@ -153,7 +153,7 @@ void sb1250_setup(void)
 	int bad_config = 0;
 
 	sb1_pass = read_c0_prid() & 0xff;
-	sys_rev = __raw_readq(IOADDR(A_SCD_SYSTEM_REVISION));
+	sys_rev = bus_readq(IOADDR(A_SCD_SYSTEM_REVISION));
 	soc_type = SYS_SOC_TYPE(sys_rev);
 	soc_pass = G_SYS_REVISION(sys_rev);
 
@@ -162,7 +162,7 @@ void sb1250_setup(void)
 		machine_restart(NULL);
 	}
 
-	plldiv = G_SYS_PLL_DIV(__raw_readq(IOADDR(A_SCD_SYSTEM_CFG)));
+	plldiv = G_SYS_PLL_DIV(bus_readq(IOADDR(A_SCD_SYSTEM_CFG)));
 	zbbus_mhz = ((plldiv >> 1) * 50) + ((plldiv & 1) * 25);
 
 	prom_printf("Broadcom SiByte %s %s @ %d MHz (SB1 rev %d)\n",
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/smp.c linux-2.6.11-rc3/arch/mips/sibyte/sb1250/smp.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/smp.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/sb1250/smp.c	2005-02-03 02:57:16.000000000 +0100
@@ -73,7 +73,7 @@ void sb1250_smp_finish(void)
  */
 void core_send_ipi(int cpu, unsigned int action)
 {
-	__raw_writeq((((u64)action)<< 48), mailbox_set_regs[cpu]);
+	bus_writeq((((u64)action) << 48), mailbox_set_regs[cpu]);
 }
 
 void sb1250_mailbox_interrupt(struct pt_regs *regs)
@@ -83,10 +83,10 @@ void sb1250_mailbox_interrupt(struct pt_
 
 	kstat_this_cpu.irqs[K_INT_MBOX_0]++;
 	/* Load the mailbox register to figure out what we're supposed to do */
-	action = (____raw_readq(mailbox_regs[cpu]) >> 48) & 0xffff;
+	action = (__bus_readq(mailbox_regs[cpu]) >> 48) & 0xffff;
 
 	/* Clear the mailbox to clear the interrupt */
-	____raw_writeq(((u64)action)<<48, mailbox_clear_regs[cpu]);
+	__bus_writeq(((u64)action) << 48, mailbox_clear_regs[cpu]);
 
 	/*
 	 * Nothing to do for SMP_RESCHEDULE_YOURSELF; returning from the
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/time.c linux-2.6.11-rc3/arch/mips/sibyte/sb1250/time.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/sb1250/time.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/sb1250/time.c	2005-02-03 02:55:53.000000000 +0100
@@ -67,21 +67,24 @@ void sb1250_time_init(void)
 	sb1250_mask_irq(cpu, irq);
 
 	/* Map the timer interrupt to ip[4] of this cpu */
-	__raw_writeq(IMR_IP4_VAL, IOADDR(A_IMR_REGISTER(cpu, R_IMR_INTERRUPT_MAP_BASE) +
-					 (irq << 3)));
+	bus_writeq(IMR_IP4_VAL,
+		   IOADDR(A_IMR_REGISTER(cpu, R_IMR_INTERRUPT_MAP_BASE) +
+			  (irq << 3)));
 
 	/* the general purpose timer ticks at 1 Mhz independent if the rest of the system */
 	/* Disable the timer and set up the count */
-	__raw_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	bus_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 #ifdef CONFIG_SIMULATION
-	__raw_writeq(50000 / HZ, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+	bus_writeq(50000 / HZ,
+		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
 #else
-	__raw_writeq(1000000/HZ, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+	bus_writeq(1000000/HZ,
+		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
 #endif
 
 	/* Set the timer running */
-	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
-		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	bus_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
+		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
 	sb1250_unmask_irq(cpu, irq);
 	sb1250_steal_irq(irq);
@@ -102,8 +105,8 @@ void sb1250_timer_interrupt(struct pt_re
 	int irq = K_INT_TIMER_0 + cpu;
 
 	/* Reset the timer */
-	____raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
-		       IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	__bus_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
+		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
 	/*
 	 * CPU 0 handles the global timer interrupt job
@@ -127,7 +130,7 @@ void sb1250_timer_interrupt(struct pt_re
 unsigned long sb1250_gettimeoffset(void)
 {
 	unsigned long count =
-		__raw_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
+		bus_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
 
 	return 1000000/HZ - count;
  }
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/swarm/rtc_m41t81.c linux-2.6.11-rc3/arch/mips/sibyte/swarm/rtc_m41t81.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/swarm/rtc_m41t81.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/swarm/rtc_m41t81.c	2005-02-03 02:55:15.000000000 +0100
@@ -82,57 +82,59 @@
 #define M41T81REG_SQW	0x13		/* square wave register */
 
 #define M41T81_CCR_ADDRESS	0x68
-#define SMB_CSR(reg) (IOADDR(A_SMB_REGISTER(1, reg)))
+#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
 
 static int m41t81_read(uint8_t addr)
 {
-	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
-	__raw_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE), SMB_CSR(R_SMB_START));
+	bus_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE),
+		   SMB_CSR(R_SMB_START));
 
-	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	__raw_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE), SMB_CSR(R_SMB_START));
+	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
+		   SMB_CSR(R_SMB_START));
 
-	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	}
 
-	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int m41t81_write(uint8_t addr, int b)
 {
-	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	__raw_writeq((addr & 0xFF), SMB_CSR(R_SMB_CMD));
-	__raw_writeq((b & 0xff), SMB_CSR(R_SMB_DATA));
-	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
-	      SMB_CSR(R_SMB_START));
+	bus_writeq((addr & 0xFF), SMB_CSR(R_SMB_CMD));
+	bus_writeq((b & 0xff), SMB_CSR(R_SMB_DATA));
+	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		   SMB_CSR(R_SMB_START));
 
-	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	} 
 
 	/* read the same byte again to make sure it is written */
-	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
-	      SMB_CSR(R_SMB_START));
+	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		   SMB_CSR(R_SMB_START));
 
-	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 	
 	return 0;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/swarm/rtc_xicor1241.c linux-2.6.11-rc3/arch/mips/sibyte/swarm/rtc_xicor1241.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/swarm/rtc_xicor1241.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/swarm/rtc_xicor1241.c	2005-02-03 02:55:22.000000000 +0100
@@ -57,50 +57,52 @@
 
 #define X1241_CCR_ADDRESS	0x6F
 
-#define SMB_CSR(reg) (IOADDR(A_SMB_REGISTER(1, reg)))
+#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
 
 static int xicor_read(uint8_t addr)
 {
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
-	__raw_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
-	__raw_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE), SMB_CSR(R_SMB_START));
+	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
+	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
+		   SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	__raw_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE), SMB_CSR(R_SMB_START));
+	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
+		   SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         }
 
-	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
-	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
-	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
-	      SMB_CSR(R_SMB_START));
+	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
+	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		   SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         } else {
 		return 0;
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sibyte/swarm/time.c linux-2.6.11-rc3/arch/mips/sibyte/swarm/time.c
--- linux-2.6.11-rc2-bk10/arch/mips/sibyte/swarm/time.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sibyte/swarm/time.c	2005-02-03 02:55:23.000000000 +0100
@@ -79,46 +79,48 @@ static unsigned int usec_bias = 0;
 
 static int xicor_read(uint8_t addr)
 {
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
-	__raw_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
-	__raw_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE), SMB_CSR(R_SMB_START));
+	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
+	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
+		   SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	__raw_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE), SMB_CSR(R_SMB_START));
+	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
+		   SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         }
 
-	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
-	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
-	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
-	      SMB_CSR(R_SMB_START));
+	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
+	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		   SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         } else {
 		return 0;
@@ -226,8 +228,8 @@ void __init swarm_time_init(void)
 	/* Establish communication with the Xicor 1241 RTC */
 	/* XXXKW how do I share the SMBus with the I2C subsystem? */
 
-	__raw_writeq(K_SMB_FREQ_400KHZ, SMB_CSR(R_SMB_FREQ));
-	__raw_writeq(0, SMB_CSR(R_SMB_CONTROL));
+	bus_writeq(K_SMB_FREQ_400KHZ, SMB_CSR(R_SMB_FREQ));
+	bus_writeq(0, SMB_CSR(R_SMB_CONTROL));
 
 	if ((status = xicor_read(X1241REG_SR_RTCF)) < 0) {
 		printk("x1241: couldn't detect on SWARM SMBus 1\n");
diff -purN linux-2.6.11-rc2-bk10/arch/mips/sni/irq.c linux-2.6.11-rc3/arch/mips/sni/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/sni/irq.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/sni/irq.c	2005-02-03 02:55:35.000000000 +0100
@@ -17,7 +17,7 @@
 #include <asm/io.h>
 #include <asm/sni.h>
 
-spinlock_t pciasic_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(pciasic_lock);
 
 extern asmlinkage void sni_rm200_pci_handle_int(void);
 
diff -purN linux-2.6.11-rc2-bk10/arch/mips/tx4927/common/tx4927_irq.c linux-2.6.11-rc3/arch/mips/tx4927/common/tx4927_irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/tx4927/common/tx4927_irq.c	2005-01-22 02:48:59.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/tx4927/common/tx4927_irq.c	2005-02-03 02:56:53.000000000 +0100
@@ -143,8 +143,8 @@ static void tx4927_irq_pic_end(unsigned 
  * Kernel structs for all pic's
  */
 
-static spinlock_t tx4927_cp0_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t tx4927_pic_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(tx4927_cp0_lock);
+static DEFINE_SPINLOCK(tx4927_pic_lock);
 
 #define TX4927_CP0_NAME "TX4927-CP0"
 static struct hw_interrupt_type tx4927_irq_cp0_type = {
diff -purN linux-2.6.11-rc2-bk10/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_irq.c linux-2.6.11-rc3/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_irq.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_irq.c	2005-02-03 02:55:36.000000000 +0100
@@ -248,7 +248,7 @@ static void toshiba_rbtx4927_irq_isa_mas
 static void toshiba_rbtx4927_irq_isa_end(unsigned int irq);
 #endif
 
-static spinlock_t toshiba_rbtx4927_ioc_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(toshiba_rbtx4927_ioc_lock);
 
 
 #define TOSHIBA_RBTX4927_IOC_NAME "RBTX4927-IOC"
@@ -669,7 +669,7 @@ void __init arch_init_irq(void)
 {
 	extern void tx4927_irq_init(void);
 
-	cli();
+	local_irq_disable();
 
 	tx4927_irq_init();
 	toshiba_rbtx4927_irq_ioc_init();
diff -purN linux-2.6.11-rc2-bk10/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c linux-2.6.11-rc3/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2005-02-03 02:56:10.000000000 +0100
@@ -727,7 +727,7 @@ void toshiba_rbtx4927_restart(char *comm
 	reg_wr08(RBTX4927_SW_RESET_DO, RBTX4927_SW_RESET_DO_SET);
 
 	/* do something passive while waiting for reset */
-	cli();
+	local_irq_disable();
 	while (1)
 		asm_wait();
 
@@ -738,7 +738,7 @@ void toshiba_rbtx4927_restart(char *comm
 void toshiba_rbtx4927_halt(void)
 {
 	printk(KERN_NOTICE "System Halted\n");
-	cli();
+	local_irq_disable();
 	while (1) {
 		asm_wait();
 	}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr4181/common/irq.c linux-2.6.11-rc3/arch/mips/vr4181/common/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr4181/common/irq.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr4181/common/irq.c	2005-02-03 02:56:53.000000000 +0100
@@ -1,6 +1,7 @@
 /*
  * Copyright (C) 2001 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  * linux/arch/mips/vr4181/common/irq.c
  *	Completely re-written to use the new irq.c
@@ -12,7 +13,6 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/kernel_stat.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr4181/common/time.c linux-2.6.11-rc3/arch/mips/vr4181/common/time.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr4181/common/time.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr4181/common/time.c	2005-02-03 02:55:53.000000000 +0100
@@ -29,7 +29,7 @@
  * RTC ops
  */
 
-spinlock_t rtc_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(rtc_lock);
 
 /* per VR41xx docs, bad data can be read if between 2 counts */
 static inline unsigned short
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr4181/osprey/setup.c linux-2.6.11-rc3/arch/mips/vr4181/osprey/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr4181/osprey/setup.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr4181/osprey/setup.c	2005-02-03 02:57:04.000000000 +0100
@@ -8,6 +8,7 @@
  *
  * Copyright 2001 MontaVista Software Inc.
  * Author: jsun@mvista.com or jsun@junsun.net
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -15,7 +16,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/ide.h>
 #include <linux/init.h>
 #include <linux/delay.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/giu.c linux-2.6.11-rc3/arch/mips/vr41xx/common/giu.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/giu.c	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/common/giu.c	2005-02-03 02:55:07.000000000 +0100
@@ -4,6 +4,7 @@
  *  Copyright (C) 2002 MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
  *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -28,7 +29,6 @@
  *  - Added support for NEC VR4133.
  *  - Removed board_irq_init.
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/irq.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/icu.c linux-2.6.11-rc3/arch/mips/vr41xx/common/icu.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/icu.c	2005-01-22 02:46:45.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/common/icu.c	2005-02-03 02:54:39.000000000 +0100
@@ -4,6 +4,7 @@
  *  Copyright (C) 2001-2002  MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
  *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -28,7 +29,6 @@
  *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *  - Coped with INTASSIGN of NEC VR4133.
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/ksyms.c linux-2.6.11-rc3/arch/mips/vr41xx/common/ksyms.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/ksyms.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/common/ksyms.c	2005-02-03 02:55:15.000000000 +0100
@@ -2,6 +2,7 @@
  *   ksyms.c, Export NEC VR4100 series specific functions needed for loadable modules.
  *
  *  Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -17,7 +18,6 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
-#include <linux/config.h>
 #include <linux/module.h>
 
 #include <asm/vr41xx/vr41xx.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/vrc4173.c linux-2.6.11-rc3/arch/mips/vr41xx/common/vrc4173.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/common/vrc4173.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/common/vrc4173.c	2005-02-03 02:57:16.000000000 +0100
@@ -4,6 +4,7 @@
  *  Copyright (C) 2001-2003  MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
  *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -19,7 +20,6 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/Makefile linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/Makefile
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/Makefile	2005-02-03 02:54:38.000000000 +0100
@@ -0,0 +1,8 @@
+#
+# Makefile for the NEC-CMBVR4133
+#
+
+obj-y				:= init.o setup.o
+
+obj-$(CONFIG_PCI)		+= m1535plus.o
+obj-$(CONFIG_ROCKHOPPER)	+= irq.o
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/init.c linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/init.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/init.c	2005-02-03 02:55:52.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ * arch/mips/vr41xx/nec-cmbvr4133/init.c
+ *
+ * PROM library initialisation code for NEC CMB-VR4133 board.
+ *
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com> and
+ *         Jun Sun <jsun@mvista.com, or source@mvista.com> and
+ *         Alex Sapkov <asapkov@ru.mvista.com>
+ *
+ * 2001-2004 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for NEC-CMBVR4133 in 2.6
+ * Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+
+#ifdef CONFIG_ROCKHOPPER
+#include <asm/io.h>
+#include <linux/pci.h>
+
+#define PCICONFDREG	0xaf000c14
+#define PCICONFAREG	0xaf000c18
+#endif
+
+const char *get_system_type(void)
+{
+	return "NEC CMB-VR4133";
+}
+
+#ifdef CONFIG_ROCKHOPPER
+void disable_pcnet(void)
+{
+	u32 data;
+
+	/*
+	 * Workaround for the bug in PMON on VR4133. PMON leaves
+	 * AMD PCNet controller (on Rockhopper) initialized and running in
+	 * bus master mode. We have do disable it before doing any
+	 * further initialization. Or we get problems with PCI bus 2
+	 * and random lockups and crashes.
+	 */
+
+	writel((2 << 16)		|
+	       (PCI_DEVFN(1,0) << 8)	|
+	       (0 & 0xfc)		|
+               1UL,
+	       PCICONFAREG);
+
+	data = readl(PCICONFDREG);
+
+	writel((2 << 16)		|
+	       (PCI_DEVFN(1,0) << 8)	|
+	       (4 & 0xfc)		|
+               1UL,
+	       PCICONFAREG);
+
+	data = readl(PCICONFDREG);
+
+	writel((2 << 16)		|
+	       (PCI_DEVFN(1,0) << 8)	|
+	       (4 & 0xfc)		|
+               1UL,
+	       PCICONFAREG);
+
+	data &= ~4;
+
+	writel(data, PCICONFDREG);
+}
+#endif
+
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/irq.c linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/irq.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/irq.c	2005-02-03 02:56:48.000000000 +0100
@@ -0,0 +1,114 @@
+/*
+ * arch/mips/vr41xx/nec-cmbvr4133/irq.c
+ *
+ * Interrupt routines for the NEC CMB-VR4133 board.
+ *
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com> and
+ *         Alex Sapkov <asapkov@ru.mvista.com>
+ *
+ * 2003-2004 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for NEC-CMBVR4133 in 2.6
+ * Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/vr41xx/cmbvr4133.h>
+
+extern void enable_8259A_irq(unsigned int irq);
+extern void disable_8259A_irq(unsigned int irq);
+extern void mask_and_ack_8259A(unsigned int irq);
+extern void init_8259A(int hoge);
+
+extern int vr4133_rockhopper;
+
+static unsigned int startup_i8259_irq(unsigned int irq)
+{
+	enable_8259A_irq(irq - I8259_IRQ_BASE);
+	return 0;
+}
+
+static void shutdown_i8259_irq(unsigned int irq)
+{
+	disable_8259A_irq(irq - I8259_IRQ_BASE);
+}
+
+static void enable_i8259_irq(unsigned int irq)
+{
+	enable_8259A_irq(irq - I8259_IRQ_BASE);
+}
+
+static void disable_i8259_irq(unsigned int irq)
+{
+	disable_8259A_irq(irq - I8259_IRQ_BASE);
+}
+
+static void ack_i8259_irq(unsigned int irq)
+{
+	mask_and_ack_8259A(irq - I8259_IRQ_BASE);
+}
+
+static void end_i8259_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_8259A_irq(irq - I8259_IRQ_BASE);
+}
+
+static struct hw_interrupt_type i8259_irq_type = {
+	.typename       = "XT-PIC",
+	.startup        = startup_i8259_irq,
+	.shutdown       = shutdown_i8259_irq,
+	.enable         = enable_i8259_irq,
+	.disable        = disable_i8259_irq,
+	.ack            = ack_i8259_irq,
+	.end            = end_i8259_irq,
+};
+
+static int i8259_get_irq_number(int irq)
+{
+	unsigned long isr;
+
+	isr = inb(0x20);
+	irq = ffz(~isr);
+	if (irq == 2) {
+		isr = inb(0xa0);
+		irq = 8 + ffz(~isr);
+	}
+
+	if (irq < 0 || irq > 15)
+		return -EINVAL;
+
+	return I8259_IRQ_BASE + irq;
+}
+
+static struct irqaction i8259_slave_cascade = {
+	.handler        = &no_action,
+	.name           = "cascade",
+};
+
+void __init rockhopper_init_irq(void)
+{
+	int i;
+
+	if(!vr4133_rockhopper) {
+		printk(KERN_ERR "Not a Rockhopper Board \n");
+		return;
+	}
+
+	for (i = I8259_IRQ_BASE; i <= I8259_IRQ_LAST; i++)
+		irq_desc[i].handler = &i8259_irq_type;
+
+	setup_irq(I8259_SLAVE_IRQ, &i8259_slave_cascade);
+
+	vr41xx_set_irq_trigger(CMBVR41XX_INTC_PIN, TRIGGER_LEVEL, SIGNAL_THROUGH);
+	vr41xx_set_irq_level(CMBVR41XX_INTC_PIN, LEVEL_HIGH);
+	vr41xx_cascade_irq(CMBVR41XX_INTC_IRQ, i8259_get_irq_number);
+}
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/m1535plus.c linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/m1535plus.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/m1535plus.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/m1535plus.c	2005-02-03 02:55:15.000000000 +0100
@@ -0,0 +1,250 @@
+/*
+ * arch/mips/vr41xx/nec-cmbvr4133/m1535plus.c
+ *
+ * Initialize for ALi M1535+(included M5229 and M5237).
+ *
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com> and
+ *         Alex Sapkov <asapkov@ru.mvista.com>
+ *
+ * 2003-2004 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for NEC-CMBVR4133 in 2.6
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/serial.h>
+
+#include <asm/vr41xx/cmbvr4133.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+
+#define CONFIG_PORT(port)	((port) ? 0x3f0 : 0x370)
+#define DATA_PORT(port)		((port) ? 0x3f1 : 0x371)
+#define INDEX_PORT(port)	CONFIG_PORT(port)
+
+#define ENTER_CONFIG_MODE(port)				\
+	do {						\
+		outb_p(0x51, CONFIG_PORT(port));	\
+		outb_p(0x23, CONFIG_PORT(port));	\
+	} while(0)
+
+#define SELECT_LOGICAL_DEVICE(port, dev_no)		\
+	do {						\
+		outb_p(0x07, INDEX_PORT(port));		\
+		outb_p((dev_no), DATA_PORT(port));	\
+	} while(0)
+
+#define WRITE_CONFIG_DATA(port,index,data)		\
+	do {						\
+		outb_p((index), INDEX_PORT(port));	\
+		outb_p((data), DATA_PORT(port));	\
+	} while(0)
+
+#define EXIT_CONFIG_MODE(port)	outb(0xbb, CONFIG_PORT(port))
+
+#define PCI_CONFIG_ADDR	KSEG1ADDR(0x0f000c18)
+#define PCI_CONFIG_DATA	KSEG1ADDR(0x0f000c14)
+
+#ifdef CONFIG_BLK_DEV_FD
+
+void __devinit ali_m1535plus_fdc_init(int port)
+{
+	ENTER_CONFIG_MODE(port);
+	SELECT_LOGICAL_DEVICE(port, 0);		/* FDC */
+	WRITE_CONFIG_DATA(port, 0x30, 0x01);	/* FDC: enable */
+	WRITE_CONFIG_DATA(port, 0x60, 0x03);	/* I/O port base: 0x3f0 */
+	WRITE_CONFIG_DATA(port, 0x61, 0xf0);
+	WRITE_CONFIG_DATA(port, 0x70, 0x06);	/* IRQ: 6 */
+	WRITE_CONFIG_DATA(port, 0x74, 0x02);	/* DMA: channel 2 */
+	WRITE_CONFIG_DATA(port, 0xf0, 0x08);
+	WRITE_CONFIG_DATA(port, 0xf1, 0x00);
+	WRITE_CONFIG_DATA(port, 0xf2, 0xff);
+	WRITE_CONFIG_DATA(port, 0xf4, 0x00);
+	EXIT_CONFIG_MODE(port);
+}
+
+#endif
+
+void __devinit ali_m1535plus_parport_init(int port)
+{
+	ENTER_CONFIG_MODE(port);
+	SELECT_LOGICAL_DEVICE(port, 3);		/* Parallel Port */
+	WRITE_CONFIG_DATA(port, 0x30, 0x01);
+	WRITE_CONFIG_DATA(port, 0x60, 0x03);	/* I/O port base: 0x378 */
+	WRITE_CONFIG_DATA(port, 0x61, 0x78);
+	WRITE_CONFIG_DATA(port, 0x70, 0x07);	/* IRQ: 7 */
+	WRITE_CONFIG_DATA(port, 0x74, 0x04);	/* DMA: None */
+	WRITE_CONFIG_DATA(port, 0xf0, 0x8c);	/* IRQ polarity: Active Low */
+	WRITE_CONFIG_DATA(port, 0xf1, 0xc5);
+	EXIT_CONFIG_MODE(port);
+}
+
+void __devinit ali_m1535plus_keyboard_init(int port)
+{
+	ENTER_CONFIG_MODE(port);
+	SELECT_LOGICAL_DEVICE(port, 7);		/* KEYBOARD */
+	WRITE_CONFIG_DATA(port, 0x30, 0x01);	/* KEYBOARD: eable */
+	WRITE_CONFIG_DATA(port, 0x70, 0x01);	/* IRQ: 1 */
+	WRITE_CONFIG_DATA(port, 0x72, 0x0c);	/* PS/2 Mouse IRQ: 12 */
+	WRITE_CONFIG_DATA(port, 0xf0, 0x00);
+	EXIT_CONFIG_MODE(port);
+}
+
+void __devinit ali_m1535plus_hotkey_init(int port)
+{
+	ENTER_CONFIG_MODE(port);
+	SELECT_LOGICAL_DEVICE(port, 0xc);	/* HOTKEY */
+	WRITE_CONFIG_DATA(port, 0x30, 0x00);
+	WRITE_CONFIG_DATA(port, 0xf0, 0x35);
+	WRITE_CONFIG_DATA(port, 0xf1, 0x14);
+	WRITE_CONFIG_DATA(port, 0xf2, 0x11);
+	WRITE_CONFIG_DATA(port, 0xf3, 0x71);
+	WRITE_CONFIG_DATA(port, 0xf5, 0x05);
+	EXIT_CONFIG_MODE(port);
+}
+
+void ali_m1535plus_init(struct pci_dev *dev)
+{
+	pci_write_config_byte(dev, 0x40, 0x18); /* PCI Interface Control */
+	pci_write_config_byte(dev, 0x41, 0xc0); /* PS2 keyb & mouse enable */
+	pci_write_config_byte(dev, 0x42, 0x41); /* ISA bus cycle control */
+	pci_write_config_byte(dev, 0x43, 0x00); /* ISA bus cycle control 2 */
+	pci_write_config_byte(dev, 0x44, 0x5d); /* IDE enable & IRQ 14 */
+	pci_write_config_byte(dev, 0x45, 0x0b); /* PCI int polling mode */
+	pci_write_config_byte(dev, 0x47, 0x00); /* BIOS chip select control */
+
+	/* IRQ routing */
+	pci_write_config_byte(dev, 0x48, 0x03); /* INTA IRQ10, INTB disable */
+	pci_write_config_byte(dev, 0x49, 0x00); /* INTC and INTD disable */
+	pci_write_config_byte(dev, 0x4a, 0x00); /* INTE and INTF disable */
+	pci_write_config_byte(dev, 0x4b, 0x90); /* Audio IRQ11, Modem disable */
+
+	pci_write_config_word(dev, 0x50, 0x4000); /* Parity check IDE enable */
+	pci_write_config_word(dev, 0x52, 0x0000); /* USB & RTC disable */
+	pci_write_config_word(dev, 0x54, 0x0002); /* ??? no info */
+	pci_write_config_word(dev, 0x56, 0x0002); /* PCS1J signal disable */
+
+	pci_write_config_byte(dev, 0x59, 0x00); /* PCSDS */
+	pci_write_config_byte(dev, 0x5a, 0x00);
+	pci_write_config_byte(dev, 0x5b, 0x00);
+	pci_write_config_word(dev, 0x5c, 0x0000);
+	pci_write_config_byte(dev, 0x5e, 0x00);
+	pci_write_config_byte(dev, 0x5f, 0x00);
+	pci_write_config_word(dev, 0x60, 0x0000);
+
+	pci_write_config_byte(dev, 0x6c, 0x00);
+	pci_write_config_byte(dev, 0x6d, 0x48); /* ROM address mapping */
+	pci_write_config_byte(dev, 0x6e, 0x00); /* ??? what for? */
+
+	pci_write_config_byte(dev, 0x70, 0x12); /* Serial IRQ control */
+	pci_write_config_byte(dev, 0x71, 0xEF); /* DMA channel select */
+	pci_write_config_byte(dev, 0x72, 0x03); /* USB IDSEL */
+	pci_write_config_byte(dev, 0x73, 0x00); /* ??? no info */
+
+	/*
+	 * IRQ setup ALi M5237 USB Host Controller
+	 * IRQ: 9
+	 */
+	pci_write_config_byte(dev, 0x74, 0x01); /* USB IRQ9 */
+
+	pci_write_config_byte(dev, 0x75, 0x1f); /* IDE2 IRQ 15  */
+	pci_write_config_byte(dev, 0x76, 0x80); /* ACPI disable */
+	pci_write_config_byte(dev, 0x77, 0x40); /* Modem disable */
+	pci_write_config_dword(dev, 0x78, 0x20000000); /* Pin select 2 */
+	pci_write_config_byte(dev, 0x7c, 0x00); /* Pin select 3 */
+	pci_write_config_byte(dev, 0x81, 0x00); /* ID read/write control */
+	pci_write_config_byte(dev, 0x90, 0x00); /* PCI PM block control */
+	pci_write_config_word(dev, 0xa4, 0x0000); /* PMSCR */
+
+#ifdef CONFIG_BLK_DEV_FD
+	ali_m1535plus_fdc_init(1);
+#endif
+
+	ali_m1535plus_keyboard_init(1);
+	ali_m1535plus_hotkey_init(1);
+}
+
+static inline void ali_config_writeb(u8 reg, u8 val, int devfn)
+{
+	u32 data;
+	int shift;
+
+	writel((1 << 16) | (devfn << 8) | (reg & 0xfc) | 1UL, PCI_CONFIG_ADDR);
+        data = readl(PCI_CONFIG_DATA);
+
+	shift = (reg & 3) << 3;
+	data &= ~(0xff << shift);
+	data |= (((u32)val) << shift);
+
+	writel(data, PCI_CONFIG_DATA);
+}
+
+static inline u8 ali_config_readb(u8 reg, int devfn)
+{
+	u32 data;
+
+	writel((1 << 16) | (devfn << 8) | (reg & 0xfc) | 1UL, PCI_CONFIG_ADDR);
+	data = readl(PCI_CONFIG_DATA);
+
+	return (u8)(data >> ((reg & 3) << 3));
+}
+
+static inline u16 ali_config_readw(u8 reg, int devfn)
+{
+	u32 data;
+
+	writel((1 << 16) | (devfn << 8) | (reg & 0xfc) | 1UL, PCI_CONFIG_ADDR);
+	data = readl(PCI_CONFIG_DATA);
+
+	return (u16)(data >> ((reg & 2) << 3));
+}
+
+int vr4133_rockhopper = 0;
+void __init ali_m5229_preinit(void)
+{
+	if (ali_config_readw(PCI_VENDOR_ID,16) == PCI_VENDOR_ID_AL &&
+	    ali_config_readw(PCI_DEVICE_ID,16) == PCI_DEVICE_ID_AL_M1533) {
+		printk(KERN_INFO "Found an NEC Rockhopper \n");
+		vr4133_rockhopper = 1;
+		/*
+		 * Enable ALi M5229 IDE Controller (both channels)
+		 * IDSEL: A27
+		 */
+		ali_config_writeb(0x58, 0x4c, 16);
+	}
+}
+
+void __init ali_m5229_init(struct pci_dev *dev)
+{
+	/*
+	 * Enable Primary/Secondary Channel Cable Detect 40-Pin
+	 */
+	pci_write_config_word(dev, 0x4a, 0xc023);
+
+	/*
+	 * Set only the 3rd byteis for the master IDE's cycle and
+	 * enable Internal IDE Function
+	 */
+	pci_write_config_byte(dev, 0x50, 0x23); /* Class code attr register */
+
+	pci_write_config_byte(dev, 0x09, 0xff); /* Set native mode & stuff */
+	pci_write_config_byte(dev, 0x52, 0x00); /* use timing registers */
+	pci_write_config_byte(dev, 0x58, 0x02); /* Primary addr setup timing */
+	pci_write_config_byte(dev, 0x59, 0x22); /* Primary cmd block timing */
+	pci_write_config_byte(dev, 0x5a, 0x22); /* Pr drv 0 R/W timing */
+	pci_write_config_byte(dev, 0x5b, 0x22); /* Pr drv 1 R/W timing */
+	pci_write_config_byte(dev, 0x5c, 0x02); /* Sec addr setup timing */
+	pci_write_config_byte(dev, 0x5d, 0x22); /* Sec cmd block timing */
+	pci_write_config_byte(dev, 0x5e, 0x22); /* Sec drv 0 R/W timing */
+	pci_write_config_byte(dev, 0x5f, 0x22); /* Sec drv 1 R/W timing */
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x20);
+	pci_write_config_word(dev, PCI_COMMAND,
+	                           PCI_COMMAND_PARITY | PCI_COMMAND_MASTER |
+				   PCI_COMMAND_IO);
+}
+
diff -purN linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/setup.c linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/setup.c
--- linux-2.6.11-rc2-bk10/arch/mips/vr41xx/nec-cmbvr4133/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/mips/vr41xx/nec-cmbvr4133/setup.c	2005-02-03 02:57:04.000000000 +0100
@@ -0,0 +1,108 @@
+/*
+ * arch/mips/vr41xx/nec-cmbvr4133/setup.c
+ *
+ * Setup for the NEC CMB-VR4133.
+ *
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com> and
+ *         Alex Sapkov <asapkov@ru.mvista.com>
+ *
+ * 2001-2004 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for CMBVR4133 board in 2.6
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/ide.h>
+#include <linux/ioport.h>
+
+#include <asm/reboot.h>
+#include <asm/time.h>
+#include <asm/vr41xx/cmbvr4133.h>
+#include <asm/bootinfo.h>
+
+#ifdef CONFIG_MTD
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+
+static struct mtd_partition cmbvr4133_mtd_parts[] = {
+	{
+		.name =		"User FS",
+		.size =		0x1be0000,
+		.offset =	0,
+		.mask_flags = 	0,
+	},
+	{
+		.name =		"PMON",
+		.size =		0x140000,
+		.offset =	MTDPART_OFS_APPEND,
+		.mask_flags =	MTD_WRITEABLE,  /* force read-only */
+	},
+	{
+		.name =		"User FS2",
+		.size =		MTDPART_SIZ_FULL,
+		.offset =	MTDPART_OFS_APPEND,
+		.mask_flags = 	0,
+	}
+};
+
+#define number_partitions (sizeof(cmbvr4133_mtd_parts)/sizeof(struct mtd_partition))
+#endif
+
+extern void (*late_time_init)(void);
+
+static void __init vr4133_serial_init(void)
+{
+	vr41xx_select_siu_interface(SIU_RS232C, IRDA_NONE);
+	vr41xx_siu_init();
+	vr41xx_dsiu_init();
+}
+
+extern void i8259_init(void);
+
+static int __init nec_cmbvr4133_setup(void)
+{
+#ifdef CONFIG_ROCKHOPPER
+	extern void disable_pcnet(void);
+
+	disable_pcnet();
+#endif
+	set_io_port_base(KSEG1ADDR(0x16000000));
+
+	mips_machgroup = MACH_GROUP_NEC_VR41XX;
+	mips_machtype = MACH_NEC_CMBVR4133;
+
+	late_time_init = vr4133_serial_init;
+
+#ifdef CONFIG_PCI
+#ifdef CONFIG_ROCKHOPPER
+	ali_m5229_preinit();
+#endif
+#endif
+
+#ifdef CONFIG_ROCKHOPPER
+	rockhopper_init_irq();
+#endif
+
+#ifdef CONFIG_MTD
+	/* we use generic physmap mapping driver and we use partitions */
+	physmap_configure(0x1C000000, 0x02000000, 4, NULL);
+	physmap_set_partitions(cmbvr4133_mtd_parts, number_partitions);
+#endif
+
+	/* 128 MB memory support */
+	add_memory_region(0, 0x08000000, BOOT_MEM_RAM);
+
+#ifdef CONFIG_ROCKHOPPER
+	i8259_init();
+#endif
+	return 0;
+}
+
+early_initcall(nec_cmbvr4133_setup);
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/boot/common/misc-common.c linux-2.6.11-rc3/arch/ppc/boot/common/misc-common.c
--- linux-2.6.11-rc2-bk10/arch/ppc/boot/common/misc-common.c	2005-02-03 10:03:08.830526752 +0100
+++ linux-2.6.11-rc3/arch/ppc/boot/common/misc-common.c	2005-02-03 02:55:52.000000000 +0100
@@ -59,7 +59,8 @@ void _vprintk(void(*putc)(const char), c
 unsigned char *ISA_io = NULL;
 
 #if defined(CONFIG_SERIAL_CPM_CONSOLE) || defined(CONFIG_SERIAL_8250_CONSOLE) \
-	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE)
+	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE) \
+	|| defined(CONFIG_SERIAL_MPSC_CONSOLE)
 extern unsigned long com_port;
 
 extern int serial_tstc(unsigned long com_port);
@@ -81,7 +82,8 @@ void exit(void)
 int tstc(void)
 {
 #if defined(CONFIG_SERIAL_CPM_CONSOLE) || defined(CONFIG_SERIAL_8250_CONSOLE) \
-	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE)
+	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE) \
+	|| defined(CONFIG_SERIAL_MPSC_CONSOLE)
 	if(keyb_present)
 		return (CRT_tstc() || serial_tstc(com_port));
 	else
@@ -95,7 +97,8 @@ int getc(void)
 {
 	while (1) {
 #if defined(CONFIG_SERIAL_CPM_CONSOLE) || defined(CONFIG_SERIAL_8250_CONSOLE) \
-	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE)
+	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE) \
+	|| defined(CONFIG_SERIAL_MPSC_CONSOLE)
 		if (serial_tstc(com_port))
 			return (serial_getc(com_port));
 #endif /* serial console */
@@ -111,7 +114,8 @@ putc(const char c)
 	int x,y;
 
 #if defined(CONFIG_SERIAL_CPM_CONSOLE) || defined(CONFIG_SERIAL_8250_CONSOLE) \
-	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE)
+	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE) \
+	|| defined(CONFIG_SERIAL_MPSC_CONSOLE)
 	serial_putc(com_port, c);
 	if ( c == '\n' )
 		serial_putc(com_port, '\r');
@@ -159,7 +163,8 @@ void puts(const char *s)
 
 	while ( ( c = *s++ ) != '\0' ) {
 #if defined(CONFIG_SERIAL_CPM_CONSOLE) || defined(CONFIG_SERIAL_8250_CONSOLE) \
-	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE)
+	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE) \
+	|| defined(CONFIG_SERIAL_MPSC_CONSOLE)
 	        serial_putc(com_port, c);
 	        if ( c == '\n' ) serial_putc(com_port, '\r');
 #endif /* serial console */
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/boot/simple/misc-ev64260.S linux-2.6.11-rc3/arch/ppc/boot/simple/misc-ev64260.S
--- linux-2.6.11-rc2-bk10/arch/ppc/boot/simple/misc-ev64260.S	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/boot/simple/misc-ev64260.S	2005-02-03 02:57:04.000000000 +0100
@@ -6,12 +6,10 @@
  *
  * Author: Mark Greer <mgreer@mvista.com>
  *
- * Copyright 2001 MontaVista Software Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
+ * 2001 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
  */
 
 #include <asm/ppc_asm.h>
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/boot/simple/misc.c linux-2.6.11-rc3/arch/ppc/boot/simple/misc.c
--- linux-2.6.11-rc2-bk10/arch/ppc/boot/simple/misc.c	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/boot/simple/misc.c	2005-02-03 02:56:33.000000000 +0100
@@ -50,7 +50,8 @@
  */
 #if (defined(CONFIG_SERIAL_8250_CONSOLE) \
 	|| defined(CONFIG_VGA_CONSOLE) \
-	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE)) \
+	|| defined(CONFIG_SERIAL_MPC52xx_CONSOLE) \
+	|| defined(CONFIG_SERIAL_MPSC_CONSOLE)) \
 	&& !defined(CONFIG_GEMINI)
 #define INTERACTIVE_CONSOLE	1
 #endif
@@ -98,7 +99,7 @@ decompress_kernel(unsigned long load_add
 	struct bi_record *rec;
 	unsigned long initrd_loc = 0, TotalMemory = 0;
 
-#ifdef CONFIG_SERIAL_8250_CONSOLE
+#if defined(CONFIG_SERIAL_8250_CONSOLE) || defined(CONFIG_SERIAL_MPSC_CONSOLE)
 	com_port = serial_init(0, NULL);
 #endif
 
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/boot/simple/mv64x60_tty.c linux-2.6.11-rc3/arch/ppc/boot/simple/mv64x60_tty.c
--- linux-2.6.11-rc2-bk10/arch/ppc/boot/simple/mv64x60_tty.c	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/boot/simple/mv64x60_tty.c	2005-02-03 02:56:10.000000000 +0100
@@ -6,12 +6,10 @@
  *
  * Author: Mark A. Greer <mgreer@mvista.com>
  *
- * Copyright 2001 MontaVista Software Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
+ * 2001 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
  */
 
 /* This code assumes that the data cache has been disabled (L1, L2, L3). */
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/configs/katana_defconfig linux-2.6.11-rc3/arch/ppc/configs/katana_defconfig
--- linux-2.6.11-rc2-bk10/arch/ppc/configs/katana_defconfig	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/configs/katana_defconfig	2005-02-03 02:57:04.000000000 +0100
@@ -1,11 +1,12 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Fri Nov 19 15:17:10 2004
+# Linux kernel version: 2.6.11-rc2
+# Tue Jan 25 16:31:13 2005
 #
 CONFIG_MMU=y
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_PPC=y
 CONFIG_PPC32=y
@@ -79,8 +80,10 @@ CONFIG_NOT_COHERENT_CACHE=y
 # CONFIG_APUS is not set
 CONFIG_KATANA=y
 # CONFIG_WILLOW is not set
+# CONFIG_CPCI690 is not set
 # CONFIG_PCORE is not set
 # CONFIG_POWERPMC250 is not set
+# CONFIG_CHESTNUT is not set
 # CONFIG_SPRUCE is not set
 # CONFIG_EV64260 is not set
 # CONFIG_LOPEC is not set
@@ -100,6 +103,7 @@ CONFIG_KATANA=y
 # CONFIG_RPX8260 is not set
 # CONFIG_TQM8260 is not set
 # CONFIG_ADS8272 is not set
+# CONFIG_PQ2FADS is not set
 # CONFIG_LITE5200 is not set
 CONFIG_MV64360=y
 CONFIG_MV64X60=y
@@ -127,6 +131,15 @@ CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
 # Advanced setup
 #
 CONFIG_ADVANCED_OPTIONS=y
@@ -153,6 +166,7 @@ CONFIG_BOOT_LOAD=0x00800000
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -176,11 +190,13 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
@@ -194,6 +210,7 @@ CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -449,6 +466,10 @@ CONFIG_HW_CONSOLE=y
 #
 # Non-8250 serial port support
 #
+CONFIG_SERIAL_MPSC=y
+CONFIG_SERIAL_MPSC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -510,6 +531,7 @@ CONFIG_GEN_RTC=y
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -524,11 +546,25 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -649,3 +685,7 @@ CONFIG_CRC32=y
 # Cryptographic options
 #
 # CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/configs/stx_gp3_defconfig linux-2.6.11-rc3/arch/ppc/configs/stx_gp3_defconfig
--- linux-2.6.11-rc2-bk10/arch/ppc/configs/stx_gp3_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/configs/stx_gp3_defconfig	2005-02-03 02:56:53.000000000 +0100
@@ -0,0 +1,972 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 14:32:58 2005
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+CONFIG_E500=y
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+# CONFIG_SPE is not set
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_85xx=y
+CONFIG_PPC_INDIRECT_PCI_BE=y
+
+#
+# Freescale 85xx options
+#
+# CONFIG_MPC8540_ADS is not set
+# CONFIG_MPC8555_CDS is not set
+# CONFIG_MPC8560_ADS is not set
+# CONFIG_SBC8560 is not set
+CONFIG_STX_GP3=y
+CONFIG_MPC8560=y
+
+#
+# Platform options
+#
+CONFIG_CPM2=y
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HIGHMEM=y
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_MISC=m
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+CONFIG_PARPORT=m
+CONFIG_PARPORT_PC=m
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+# CONFIG_PARPORT_OTHER is not set
+# CONFIG_PARPORT_1284 is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_PPA is not set
+# CONFIG_SCSI_IMM is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=m
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+# CONFIG_IP_NF_CT_ACCT is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_TFTP is not set
+# CONFIG_IP_NF_AMANDA is not set
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+# CONFIG_IP_NF_MATCH_LIMIT is not set
+# CONFIG_IP_NF_MATCH_IPRANGE is not set
+# CONFIG_IP_NF_MATCH_MAC is not set
+# CONFIG_IP_NF_MATCH_PKTTYPE is not set
+# CONFIG_IP_NF_MATCH_MARK is not set
+# CONFIG_IP_NF_MATCH_MULTIPORT is not set
+# CONFIG_IP_NF_MATCH_TOS is not set
+# CONFIG_IP_NF_MATCH_RECENT is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_DSCP is not set
+# CONFIG_IP_NF_MATCH_AH_ESP is not set
+# CONFIG_IP_NF_MATCH_LENGTH is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_MATCH_TCPMSS is not set
+# CONFIG_IP_NF_MATCH_HELPER is not set
+# CONFIG_IP_NF_MATCH_STATE is not set
+# CONFIG_IP_NF_MATCH_CONNTRACK is not set
+# CONFIG_IP_NF_MATCH_OWNER is not set
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_REALM is not set
+# CONFIG_IP_NF_MATCH_SCTP is not set
+# CONFIG_IP_NF_MATCH_COMMENT is not set
+# CONFIG_IP_NF_MATCH_HASHLIMIT is not set
+CONFIG_IP_NF_FILTER=m
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+# CONFIG_IP_NF_TARGET_TCPMSS is not set
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_SAME is not set
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+CONFIG_GIANFAR=y
+CONFIG_GFAR_NAPI=y
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1280
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=1024
+CONFIG_INPUT_JOYDEV=m
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_CPM=y
+CONFIG_SERIAL_CPM_CONSOLE=y
+# CONFIG_SERIAL_CPM_SCC1 is not set
+CONFIG_SERIAL_CPM_SCC2=y
+# CONFIG_SERIAL_CPM_SCC3 is not set
+# CONFIG_SERIAL_CPM_SCC4 is not set
+# CONFIG_SERIAL_CPM_SMC1 is not set
+# CONFIG_SERIAL_CPM_SMC2 is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_PRINTER=m
+# CONFIG_LP_CONSOLE is not set
+# CONFIG_PPDEV is not set
+# CONFIG_TIPAR is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+CONFIG_AGP=m
+CONFIG_DRM=m
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+CONFIG_AUTOFS_FS=m
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=m
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_SCC_ENET is not set
+# CONFIG_FEC_ENET is not set
+
+#
+# CPM2 Options
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_KGDB_CONSOLE is not set
+# CONFIG_XMON is not set
+CONFIG_BDI_SWITCH=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/kernel/entry.S linux-2.6.11-rc3/arch/ppc/kernel/entry.S
--- linux-2.6.11-rc2-bk10/arch/ppc/kernel/entry.S	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/kernel/entry.S	2005-02-03 02:56:48.000000000 +0100
@@ -624,18 +624,8 @@ resume_kernel:
 	beq+	restore
 	andi.	r0,r3,MSR_EE	/* interrupts off? */
 	beq	restore		/* don't schedule if so */
-1:	lis	r0,PREEMPT_ACTIVE@h
-	stw	r0,TI_PREEMPT(r9)
-	ori	r10,r10,MSR_EE
-	SYNC
-	MTMSRD(r10)		/* hard-enable interrupts */
-	bl	schedule
-	LOAD_MSR_KERNEL(r10,MSR_KERNEL)
-	SYNC
-	MTMSRD(r10)		/* disable interrupts */
+1:	bl	preempt_schedule_irq
 	rlwinm	r9,r1,0,0,18
-	li	r0,0
-	stw	r0,TI_PREEMPT(r9)
 	lwz	r3,TI_FLAGS(r9)
 	andi.	r0,r3,_TIF_NEED_RESCHED
 	bne-	1b
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/kernel/idle.c linux-2.6.11-rc3/arch/ppc/kernel/idle.c
--- linux-2.6.11-rc2-bk10/arch/ppc/kernel/idle.c	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/kernel/idle.c	2005-02-03 02:54:39.000000000 +0100
@@ -41,17 +41,14 @@ void default_idle(void)
 	if (!need_resched()) {
 		if (powersave != NULL)
 			powersave();
-		else {
 #ifdef CONFIG_SMP
+		else {
 			set_thread_flag(TIF_POLLING_NRFLAG);
-			local_irq_enable();
 			while (!need_resched())
 				barrier();
 			clear_thread_flag(TIF_POLLING_NRFLAG);
-#else
-			local_irq_enable();
-#endif
 		}
+#endif
 	}
 	if (need_resched())
 		schedule();
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/kernel/l2cr.S linux-2.6.11-rc3/arch/ppc/kernel/l2cr.S
--- linux-2.6.11-rc2-bk10/arch/ppc/kernel/l2cr.S	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/kernel/l2cr.S	2005-02-03 02:55:53.000000000 +0100
@@ -45,6 +45,7 @@
 #include <asm/cputable.h>
 #include <asm/ppc_asm.h>
 #include <asm/cache.h>
+#include <asm/page.h>
 
 /* Usage:
 
@@ -284,7 +285,7 @@ END_FTR_SECTION_IFCLR(CPU_FTR_L3CR)
 	/* Tweak some bits */
 	rlwinm	r5,r3,0,0,0		/* r5 contains the new enable bit */
 	rlwinm	r3,r3,0,22,20		/* Turn off the invalidate bit */
-	rlwinm	r3,r3,0,1,31		/* Turn off the enable bit */
+	rlwinm	r3,r3,0,2,31		/* Turn off the enable & PE bits */
 	rlwinm	r3,r3,0,5,3		/* Turn off the clken bit */
 	/* Check to see if we need to flush */
 	rlwinm.	r4,r4,0,0,0
@@ -379,7 +380,7 @@ END_FTR_SECTION_IFSET(CPU_FTR_L3CR)
 /* flush_disable_L1()	- Flush and disable L1 cache
  *
  * clobbers r0, r3, ctr, cr0
- *
+ * Must be called with interrupts disabled and MMU enabled.
  */
 _GLOBAL(__flush_disable_L1)
 	/* Stop pending alitvec streams and memory accesses */
@@ -393,7 +394,7 @@ END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
 	 */
 	li	r3,0x4000	/* 512kB / 32B */
 	mtctr	r3
-	li	r3, 0
+	lis	r3,KERNELBASE@h
 1:
 	lwz	r0,0(r3)
 	addi	r3,r3,0x0020	/* Go to start of next cache line */
@@ -404,7 +405,7 @@ END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
 	/* Now flush those cache lines */
 	li	r3,0x4000	/* 512kB / 32B */
 	mtctr	r3
-	li	r3, 0
+	lis	r3,KERNELBASE@h
 1:
 	dcbf	0,r3
 	addi	r3,r3,0x0020	/* Go to start of next cache line */
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/kernel/ppc_ksyms.c linux-2.6.11-rc3/arch/ppc/kernel/ppc_ksyms.c
--- linux-2.6.11-rc2-bk10/arch/ppc/kernel/ppc_ksyms.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/kernel/ppc_ksyms.c	2005-02-03 02:56:48.000000000 +0100
@@ -190,6 +190,7 @@ EXPORT_SYMBOL(flush_icache_user_range);
 EXPORT_SYMBOL(flush_dcache_page);
 EXPORT_SYMBOL(flush_tlb_kernel_range);
 EXPORT_SYMBOL(flush_tlb_page);
+EXPORT_SYMBOL(_tlbie);
 #ifdef CONFIG_ALTIVEC
 EXPORT_SYMBOL(last_task_used_altivec);
 EXPORT_SYMBOL(giveup_altivec);
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/kernel/process.c linux-2.6.11-rc3/arch/ppc/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/ppc/kernel/process.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/kernel/process.c	2005-02-03 02:55:52.000000000 +0100
@@ -325,17 +325,6 @@ void show_regs(struct pt_regs * regs)
 	       current, current->pid, current->comm, current->thread_info);
 	printk("Last syscall: %ld ", current->thread.last_syscall);
 
-#if defined(CONFIG_4xx) && defined(DCRN_PLB0_BEAR)
-	printk("\nPLB0: bear= 0x%8.8x acr=   0x%8.8x besr=  0x%8.8x\n",
-	    mfdcr(DCRN_PLB0_BEAR), mfdcr(DCRN_PLB0_ACR),
-	    mfdcr(DCRN_PLB0_BESR));
-#endif
-#if defined(CONFIG_4xx) && defined(DCRN_POB0_BEAR)
-	printk("PLB0 to OPB: bear= 0x%8.8x besr0= 0x%8.8x besr1= 0x%8.8x\n",
-	    mfdcr(DCRN_POB0_BEAR), mfdcr(DCRN_POB0_BESR0),
-	    mfdcr(DCRN_POB0_BESR1));
-#endif
-
 #ifdef CONFIG_SMP
 	printk(" CPU: %d", smp_processor_id());
 #endif /* CONFIG_SMP */
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/kernel/traps.c linux-2.6.11-rc3/arch/ppc/kernel/traps.c
--- linux-2.6.11-rc2-bk10/arch/ppc/kernel/traps.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/kernel/traps.c	2005-02-03 02:55:15.000000000 +0100
@@ -199,6 +199,15 @@ static inline int check_io_access(struct
 #define clear_single_step(regs)	((regs)->msr &= ~MSR_SE)
 #endif
 
+/*
+ * This is "fall-back" implementation for configurations
+ * which don't provide platform-specific machine check info
+ */
+void __attribute__ ((weak))
+platform_machine_check(struct pt_regs *regs)
+{
+}
+
 void MachineCheckException(struct pt_regs *regs)
 {
 	unsigned long reason = get_mc_reason(regs);
@@ -323,6 +332,12 @@ void MachineCheckException(struct pt_reg
 	}
 #endif /* CONFIG_4xx */
 
+	/*
+	 * Optional platform-provided routine to print out
+	 * additional info, e.g. bus error registers.
+	 */
+	platform_machine_check(regs);
+
 	debugger(regs);
 	die("machine check", regs, SIGBUS);
 }
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/oprofile/common.c linux-2.6.11-rc3/arch/ppc/oprofile/common.c
--- linux-2.6.11-rc2-bk10/arch/ppc/oprofile/common.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/oprofile/common.c	2005-02-03 02:55:23.000000000 +0100
@@ -124,7 +124,7 @@ static struct oprofile_operations oprof_
 	.cpu_type	= NULL		/* To be filled in below. */
 };
 
-void __init oprofile_arch_init(struct oprofile_operations *ops)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	char *name;
 	int cpu_id = smp_processor_id();
@@ -132,14 +132,13 @@ void __init oprofile_arch_init(struct op
 #ifdef CONFIG_FSL_BOOKE
 	model = &op_model_fsl_booke;
 #else
-	printk(KERN_ERR "oprofile enabled on unsupported processor!\n");
-	return;
+	return -ENODEV;
 #endif
 
 	name = kmalloc(32, GFP_KERNEL);
 
 	if (NULL == name)
-		return;
+		return -ENOMEM;
 
 	sprintf(name, "ppc/%s", cur_cpu_spec[cpu_id]->cpu_name);
 
@@ -151,6 +150,8 @@ void __init oprofile_arch_init(struct op
 
 	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
 	       oprof_ppc32_ops.cpu_type);
+
+	return 0;
 }
 
 void oprofile_arch_exit(void)
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/Kconfig linux-2.6.11-rc3/arch/ppc/platforms/85xx/Kconfig
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/Kconfig	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/Kconfig	2005-02-03 02:56:53.000000000 +0100
@@ -37,6 +37,12 @@ config SBC8560
 	  This option enables support for the WindRiver PowerQUICC III 
 	  SBC8560 board.
 
+config STX_GP3
+	bool "Silicon Turnkey Express GP3"
+	help
+	  This option enables support for the Silicon Turnkey Express GP3
+	  board.
+
 endchoice
 
 # It's often necessary to know the specific 85xx processor type.
@@ -54,7 +60,7 @@ config MPC8555
 
 config MPC8560
 	bool
-	depends on SBC8560 || MPC8560_ADS
+	depends on SBC8560 || MPC8560_ADS || STX_GP3
 	default y
 
 config 85xx_PCI2
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/Makefile linux-2.6.11-rc3/arch/ppc/platforms/85xx/Makefile
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/Makefile	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/Makefile	2005-02-03 02:55:07.000000000 +0100
@@ -7,3 +7,4 @@ obj-$(CONFIG_MPC8540_ADS)	+= mpc85xx_ads
 obj-$(CONFIG_MPC8555_CDS)	+= mpc85xx_cds_common.o
 obj-$(CONFIG_MPC8560_ADS)	+= mpc85xx_ads_common.o mpc8560_ads.o
 obj-$(CONFIG_SBC8560)		+= sbc85xx.o sbc8560.o
+obj-$(CONFIG_STX_GP3)		+= stx_gp3.o
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc8540_ads.c linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc8540_ads.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc8540_ads.c	2005-01-22 02:47:33.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc8540_ads.c	2005-02-03 02:55:35.000000000 +0100
@@ -147,10 +147,25 @@ platform_init(unsigned long r3, unsigned
 #ifdef CONFIG_SERIAL_TEXT_DEBUG
 	{
 		bd_t *binfo = (bd_t *) __res;
+		struct uart_port p;
 
 		/* Use the last TLB entry to map CCSRBAR to allow access to DUART regs */
 		settlbcam(NUM_TLBCAMS - 1, binfo->bi_immr_base,
 			  binfo->bi_immr_base, MPC85xx_CCSRBAR_SIZE, _PAGE_IO, 0);
+
+		memset(&p, 0, sizeof (p));
+		p.iotype = SERIAL_IO_MEM;
+		p.membase = (void *) binfo->bi_immr_base + MPC85xx_UART0_OFFSET;
+		p.uartclk = binfo->bi_busfreq;
+
+		gen550_init(0, &p);
+
+		memset(&p, 0, sizeof (p));
+		p.iotype = SERIAL_IO_MEM;
+		p.membase = (void *) binfo->bi_immr_base + MPC85xx_UART1_OFFSET;
+		p.uartclk = binfo->bi_busfreq;
+
+		gen550_init(1, &p);
 	}
 #endif
 
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc8540_ads.h linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc8540_ads.h
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc8540_ads.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc8540_ads.h	2005-02-03 02:57:05.000000000 +0100
@@ -22,8 +22,4 @@
 #include <syslib/ppc85xx_setup.h>
 #include <platforms/85xx/mpc85xx_ads_common.h>
 
-#define SERIAL_PORT_DFNS	\
-	STD_UART_OP(0)		\
-	STD_UART_OP(1)
-
 #endif /* __MACH_MPC8540ADS_H__ */
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_cds_common.c linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_cds_common.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_cds_common.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_cds_common.c	2005-02-03 02:56:48.000000000 +0100
@@ -396,11 +396,25 @@ platform_init(unsigned long r3, unsigned
 #ifdef CONFIG_SERIAL_TEXT_DEBUG
 	{
 		bd_t *binfo = (bd_t *) __res;
+		struct uart_port p;
 
 		/* Use the last TLB entry to map CCSRBAR to allow access to DUART regs */
 		settlbcam(NUM_TLBCAMS - 1, binfo->bi_immr_base,
-			binfo->bi_immr_base, MPC85xx_CCSRBAR_SIZE, _PAGE_IO, 0);
+			  binfo->bi_immr_base, MPC85xx_CCSRBAR_SIZE, _PAGE_IO, 0);
 
+		memset(&p, 0, sizeof (p));
+		p.iotype = SERIAL_IO_MEM;
+		p.membase = (void *) binfo->bi_immr_base + MPC85xx_UART0_OFFSET;
+		p.uartclk = binfo->bi_busfreq;
+
+		gen550_init(0, &p);
+
+		memset(&p, 0, sizeof (p));
+		p.iotype = SERIAL_IO_MEM;
+		p.membase = (void *) binfo->bi_immr_base + MPC85xx_UART1_OFFSET;
+		p.uartclk = binfo->bi_busfreq;
+
+		gen550_init(1, &p);
 	}
 #endif
 
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_cds_common.h linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_cds_common.h
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2005-02-03 10:03:08.854523018 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2005-02-03 02:55:14.000000000 +0100
@@ -73,8 +73,4 @@
 
 #define MPC85XX_PCI2_IO_SIZE         0x01000000
 
-#define SERIAL_PORT_DFNS		\
-	       STD_UART_OP(0)		\
-	       STD_UART_OP(1)
-
 #endif /* __MACH_MPC85XX_CDS_H__ */
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_devices.c linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_devices.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_devices.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_devices.c	2005-02-03 02:55:14.000000000 +0100
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/device.h>
+#include <linux/serial_8250.h>
 #include <linux/fsl_devices.h>
 #include <asm/mpc85xx.h>
 #include <asm/irq.h>
@@ -47,6 +48,21 @@ static struct fsl_i2c_platform_data mpc8
 	.device_flags = FSL_I2C_DEV_SEPARATE_DFSRR,
 };
 
+static struct plat_serial8250_port serial_platform_data[] = {
+	[0] = {
+		.mapbase	= 0x4500,
+		.irq		= MPC85xx_IRQ_DUART,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_SHARE_IRQ,
+	},
+	[1] = {
+		.mapbase	= 0x4600,
+		.irq		= MPC85xx_IRQ_DUART,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_SHARE_IRQ,
+	},
+};
+
 struct platform_device ppc_sys_platform_devices[] = {
 	[MPC85xx_TSEC1] = {
 		.name = "fsl-gianfar",
@@ -223,6 +239,11 @@ struct platform_device ppc_sys_platform_
 			},
 		},
 	},
+	[MPC85xx_DUART] = {
+		.name = "serial8250",
+		.id	= 0,
+		.dev.platform_data = serial_platform_data,
+	},
 	[MPC85xx_PERFMON] = {
 		.name = "fsl-perfmon",
 		.id	= 1,
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_sys.c linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_sys.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/mpc85xx_sys.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/mpc85xx_sys.c	2005-02-03 02:55:36.000000000 +0100
@@ -24,12 +24,12 @@ struct ppc_sys_spec ppc_sys_specs[] = {
 		.ppc_sys_name	= "MPC8540",
 		.mask 		= 0xFFFF0000,
 		.value 		= 0x80300000,
-		.num_devices	= 9,
+		.num_devices	= 10,
 		.device_list	= (enum ppc_sys_devices[])
 		{
 			MPC85xx_TSEC1, MPC85xx_TSEC2, MPC85xx_FEC, MPC85xx_IIC1,
 			MPC85xx_DMA0, MPC85xx_DMA1, MPC85xx_DMA2, MPC85xx_DMA3,
-			MPC85xx_PERFMON,
+			MPC85xx_PERFMON, MPC85xx_DUART,
 		},
 	},
 	{
@@ -52,12 +52,12 @@ struct ppc_sys_spec ppc_sys_specs[] = {
 		.ppc_sys_name	= "MPC8541",
 		.mask 		= 0xFFFF0000,
 		.value 		= 0x80720000,
-		.num_devices	= 12,
+		.num_devices	= 13,
 		.device_list	= (enum ppc_sys_devices[])
 		{
 			MPC85xx_TSEC1, MPC85xx_TSEC2, MPC85xx_IIC1,
 			MPC85xx_DMA0, MPC85xx_DMA1, MPC85xx_DMA2, MPC85xx_DMA3,
-			MPC85xx_PERFMON,
+			MPC85xx_PERFMON, MPC85xx_DUART,
 			MPC85xx_CPM_SPI, MPC85xx_CPM_I2C,
 			MPC85xx_CPM_FCC1, MPC85xx_CPM_FCC2,
 		},
@@ -66,12 +66,12 @@ struct ppc_sys_spec ppc_sys_specs[] = {
 		.ppc_sys_name	= "MPC8541E",
 		.mask 		= 0xFFFF0000,
 		.value 		= 0x807A0000,
-		.num_devices	= 13,
+		.num_devices	= 14,
 		.device_list	= (enum ppc_sys_devices[])
 		{
 			MPC85xx_TSEC1, MPC85xx_TSEC2, MPC85xx_IIC1,
 			MPC85xx_DMA0, MPC85xx_DMA1, MPC85xx_DMA2, MPC85xx_DMA3,
-			MPC85xx_PERFMON, MPC85xx_SEC2,
+			MPC85xx_PERFMON, MPC85xx_DUART, MPC85xx_SEC2,
 			MPC85xx_CPM_SPI, MPC85xx_CPM_I2C,
 			MPC85xx_CPM_FCC1, MPC85xx_CPM_FCC2,
 		},
@@ -80,12 +80,12 @@ struct ppc_sys_spec ppc_sys_specs[] = {
 		.ppc_sys_name	= "MPC8555",
 		.mask 		= 0xFFFF0000,
 		.value 		= 0x80710000,
-		.num_devices	= 19,
+		.num_devices	= 20,
 		.device_list	= (enum ppc_sys_devices[])
 		{
 			MPC85xx_TSEC1, MPC85xx_TSEC2, MPC85xx_IIC1,
 			MPC85xx_DMA0, MPC85xx_DMA1, MPC85xx_DMA2, MPC85xx_DMA3,
-			MPC85xx_PERFMON,
+			MPC85xx_PERFMON, MPC85xx_DUART,
 			MPC85xx_CPM_SPI, MPC85xx_CPM_I2C, MPC85xx_CPM_SCC1,
 			MPC85xx_CPM_SCC2, MPC85xx_CPM_SCC3,
 			MPC85xx_CPM_FCC1, MPC85xx_CPM_FCC2, MPC85xx_CPM_FCC3,
@@ -97,12 +97,12 @@ struct ppc_sys_spec ppc_sys_specs[] = {
 		.ppc_sys_name	= "MPC8555E",
 		.mask 		= 0xFFFF0000,
 		.value 		= 0x80790000,
-		.num_devices	= 20,
+		.num_devices	= 21,
 		.device_list	= (enum ppc_sys_devices[])
 		{
 			MPC85xx_TSEC1, MPC85xx_TSEC2, MPC85xx_IIC1,
 			MPC85xx_DMA0, MPC85xx_DMA1, MPC85xx_DMA2, MPC85xx_DMA3,
-			MPC85xx_PERFMON, MPC85xx_SEC2,
+			MPC85xx_PERFMON, MPC85xx_DUART, MPC85xx_SEC2,
 			MPC85xx_CPM_SPI, MPC85xx_CPM_I2C, MPC85xx_CPM_SCC1,
 			MPC85xx_CPM_SCC2, MPC85xx_CPM_SCC3,
 			MPC85xx_CPM_FCC1, MPC85xx_CPM_FCC2, MPC85xx_CPM_FCC3,
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/stx_gp3.c linux-2.6.11-rc3/arch/ppc/platforms/85xx/stx_gp3.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/stx_gp3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/stx_gp3.c	2005-02-03 02:55:53.000000000 +0100
@@ -0,0 +1,381 @@
+/*
+ * arch/ppc/platforms/85xx/stx_gp3.c
+ *
+ * STx GP3 board specific routines
+ *
+ * Dan Malek <dan@embeddededge.com>
+ * Copyright 2004 Embedded Edge, LLC
+ *
+ * Copied from mpc8560_ads.c
+ * Copyright 2002, 2003 Motorola Inc.
+ *
+ * Ported to 2.6, Matt Porter <mporter@kernel.crashing.org>
+ * Copyright 2004-2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/root_dev.h>
+#include <linux/seq_file.h>
+#include <linux/serial.h>
+#include <linux/module.h>
+#include <linux/fsl_devices.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/atomic.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/prom.h>
+#include <asm/open_pic.h>
+#include <asm/bootinfo.h>
+#include <asm/pci-bridge.h>
+#include <asm/mpc85xx.h>
+#include <asm/irq.h>
+#include <asm/immap_85xx.h>
+#include <asm/immap_cpm2.h>
+#include <asm/mpc85xx.h>
+#include <asm/ppc_sys.h>
+
+#include <syslib/cpm2_pic.h>
+#include <syslib/ppc85xx_common.h>
+
+extern void cpm2_reset(void);
+
+unsigned char __res[sizeof(bd_t)];
+
+#ifndef CONFIG_PCI
+unsigned long isa_io_base = 0;
+unsigned long isa_mem_base = 0;
+unsigned long pci_dram_offset = 0;
+#endif
+
+/* Internal interrupts are all Level Sensitive, and Positive Polarity */
+static u8 gp3_openpic_initsenses[] __initdata = {
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  0: L2 Cache */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  1: ECM */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  2: DDR DRAM */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  3: LBIU */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  4: DMA 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  5: DMA 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  6: DMA 2 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  7: DMA 3 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  8: PCI/PCI-X */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal  9: RIO Inbound Port Write Error */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 10: RIO Doorbell Inbound */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 11: RIO Outbound Message */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 12: RIO Inbound Message */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 13: TSEC 0 Transmit */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 14: TSEC 0 Receive */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 15: Unused */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 16: Unused */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 17: Unused */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 18: TSEC 0 Receive/Transmit Error */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 19: TSEC 1 Transmit */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 20: TSEC 1 Receive */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 21: Unused */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 22: Unused */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 23: Unused */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 24: TSEC 1 Receive/Transmit Error */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 25: Fast Ethernet */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 26: DUART */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 27: I2C */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 28: Performance Monitor */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 29: Unused */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 30: CPM */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_POSITIVE),	/* Internal 31: Unused */
+	0x0,						/* External  0: */
+#if defined(CONFIG_PCI)
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 1: PCI slot 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 2: PCI slot 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 3: PCI slot 2 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE),	/* External 4: PCI slot 3 */
+#else
+	0x0,				/* External  1: */
+	0x0,				/* External  2: */
+	0x0,				/* External  3: */
+	0x0,				/* External  4: */
+#endif
+	0x0,				/* External  5: */
+	0x0,				/* External  6: */
+	0x0,				/* External  7: */
+	0x0,				/* External  8: */
+	0x0,				/* External  9: */
+	0x0,				/* External 10: */
+	0x0,				/* External 11: */
+};
+
+/*
+ * Setup the architecture
+ */
+static void __init
+gp3_setup_arch(void)
+{
+	bd_t *binfo = (bd_t *) __res;
+	unsigned int freq;
+	struct gianfar_platform_data *pdata;
+
+	cpm2_reset();
+
+	/* get the core frequency */
+	freq = binfo->bi_intfreq;
+
+	if (ppc_md.progress)
+		ppc_md.progress("gp3_setup_arch()", 0);
+
+	/* Set loops_per_jiffy to a half-way reasonable value,
+	   for use until calibrate_delay gets called. */
+	loops_per_jiffy = freq / HZ;
+
+#ifdef CONFIG_PCI
+	/* setup PCI host bridges */
+	mpc85xx_setup_hose();
+#endif
+
+	/* setup the board related information for the enet controllers */
+	pdata = (struct gianfar_platform_data *) ppc_sys_get_pdata(MPC85xx_TSEC1);
+/*	pdata->board_flags = FSL_GIANFAR_BRD_HAS_PHY_INTR; */
+	pdata->interruptPHY = MPC85xx_IRQ_EXT5;
+	pdata->phyid = 2;
+	pdata->phy_reg_addr += binfo->bi_immr_base;
+	memcpy(pdata->mac_addr, binfo->bi_enetaddr, 6);
+
+	pdata = (struct gianfar_platform_data *) ppc_sys_get_pdata(MPC85xx_TSEC2);
+/*	pdata->board_flags = FSL_GIANFAR_BRD_HAS_PHY_INTR; */
+	pdata->interruptPHY = MPC85xx_IRQ_EXT5;
+	pdata->phyid = 4;
+	/* fixup phy address */
+	pdata->phy_reg_addr += binfo->bi_immr_base;
+	memcpy(pdata->mac_addr, binfo->bi_enet1addr, 6);
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else
+#endif
+#ifdef	CONFIG_ROOT_NFS
+		ROOT_DEV = Root_NFS;
+#else
+		ROOT_DEV = Root_HDA1;
+#endif
+
+	printk ("bi_immr_base = %8.8lx\n", binfo->bi_immr_base);
+}
+
+static irqreturn_t cpm2_cascade(int irq, void *dev_id, struct pt_regs *regs)
+{
+	while ((irq = cpm2_get_irq(regs)) >= 0)
+		__do_IRQ(irq, regs);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction cpm2_irqaction = {
+	.handler	= cpm2_cascade,
+	.flags		= SA_INTERRUPT,
+	.mask		= CPU_MASK_NONE,
+	.name		= "cpm2_cascade",
+};
+
+static void __init
+gp3_init_IRQ(void)
+{
+	int i;
+	volatile cpm2_map_t *immap = cpm2_immr;
+	bd_t *binfo = (bd_t *) __res;
+
+	/*
+	 * Setup OpenPIC
+	 */
+
+	/* Determine the Physical Address of the OpenPIC regs */
+	phys_addr_t OpenPIC_PAddr =
+	    binfo->bi_immr_base + MPC85xx_OPENPIC_OFFSET;
+	OpenPIC_Addr = ioremap(OpenPIC_PAddr, MPC85xx_OPENPIC_SIZE);
+	OpenPIC_InitSenses = gp3_openpic_initsenses;
+	OpenPIC_NumInitSenses = sizeof (gp3_openpic_initsenses);
+
+	/* Skip reserved space and internal sources */
+	openpic_set_sources(0, 32, OpenPIC_Addr + 0x10200);
+
+	/* Map PIC IRQs 0-11 */
+	openpic_set_sources(32, 12, OpenPIC_Addr + 0x10000);
+
+	/*
+	 * Let openpic interrupts starting from an offset, to
+	 * leave space for cascading interrupts underneath.
+	 */
+	openpic_init(MPC85xx_OPENPIC_IRQ_OFFSET);
+
+	/*
+	 * Setup CPM2 PIC
+	 */
+
+	/* disable all CPM interupts */
+	immap->im_intctl.ic_simrh = 0x0;
+	immap->im_intctl.ic_simrl = 0x0;
+
+	for (i = CPM_IRQ_OFFSET; i < (NR_CPM_INTS + CPM_IRQ_OFFSET); i++)
+		irq_desc[i].handler = &cpm2_pic;
+
+	/*
+	 * Initialize the default interrupt mapping priorities,
+	 * in case the boot rom changed something on us.
+	 */
+	immap->im_intctl.ic_sicr = 0;
+	immap->im_intctl.ic_scprrh = 0x05309770;
+	immap->im_intctl.ic_scprrl = 0x05309770;
+
+	setup_irq(MPC85xx_IRQ_CPM, &cpm2_irqaction);
+
+	return;
+}
+
+static int
+gp3_show_cpuinfo(struct seq_file *m)
+{
+	uint pvid, svid, phid1;
+	bd_t *binfo = (bd_t *) __res;
+	uint	memsize;
+	unsigned int freq;
+	extern unsigned long total_memory;	/* in mm/init */
+
+	/* get the core frequency */
+	freq = binfo->bi_intfreq;
+
+	pvid = mfspr(PVR);
+	svid = mfspr(SVR);
+
+	memsize = total_memory;
+
+	seq_printf(m, "Vendor\t\t: RPC Electronics STx \n");
+
+	switch (svid & 0xffff0000) {
+	case SVR_8540:
+		seq_printf(m, "Machine\t\t: GP3 - MPC8540\n");
+		break;
+	case SVR_8560:
+		seq_printf(m, "Machine\t\t: GP3 - MPC8560\n");
+		break;
+	default:
+		seq_printf(m, "Machine\t\t: unknown\n");
+		break;
+	}
+	seq_printf(m, "bus freq\t: %u.%.6u MHz\n", freq / 1000000,
+		   freq % 1000000);
+	seq_printf(m, "PVR\t\t: 0x%x\n", pvid);
+	seq_printf(m, "SVR\t\t: 0x%x\n", svid);
+
+	/* Display cpu Pll setting */
+	phid1 = mfspr(HID1);
+	seq_printf(m, "PLL setting\t: 0x%x\n", ((phid1 >> 24) & 0x3f));
+
+	/* Display the amount of memory */
+	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
+
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+int mpc85xx_map_irq(struct pci_dev *dev, unsigned char idsel,
+		    unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *        A      B      C      D
+	     */
+	{
+		{PIRQA, PIRQB, PIRQC, PIRQD},
+		{PIRQD, PIRQA, PIRQB, PIRQC},
+		{PIRQC, PIRQD, PIRQA, PIRQB},
+		{PIRQB, PIRQC, PIRQD, PIRQA},
+	};
+
+	const long min_idsel = 12, max_idsel = 15, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+}
+
+int mpc85xx_exclude_device(u_char bus, u_char devfn)
+{
+	if (bus == 0 && PCI_SLOT(devfn) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	else
+		return PCIBIOS_SUCCESSFUL;
+}
+#endif /* CONFIG_PCI */
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	/* parse_bootinfo must always be called first */
+	parse_bootinfo(find_bootinfo());
+
+	/*
+	 * If we were passed in a board information, copy it into the
+	 * residual data area.
+	 */
+	if (r3) {
+		memcpy((void *) __res, (void *) (r3 + KERNELBASE),
+		       sizeof (bd_t));
+
+	}
+#if defined(CONFIG_BLK_DEV_INITRD)
+	/*
+	 * If the init RAM disk has been configured in, and there's a valid
+	 * starting address for it, set it up.
+	 */
+	if (r4) {
+		initrd_start = r4 + KERNELBASE;
+		initrd_end = r5 + KERNELBASE;
+	}
+#endif				/* CONFIG_BLK_DEV_INITRD */
+
+	/* Copy the kernel command line arguments to a safe place. */
+
+	if (r6) {
+		*(char *) (r7 + KERNELBASE) = 0;
+		strcpy(cmd_line, (char *) (r6 + KERNELBASE));
+	}
+
+	identify_ppc_sys_by_id(mfspr(SVR));
+
+	/* setup the PowerPC module struct */
+	ppc_md.setup_arch = gp3_setup_arch;
+	ppc_md.show_cpuinfo = gp3_show_cpuinfo;
+
+	ppc_md.init_IRQ = gp3_init_IRQ;
+	ppc_md.get_irq = openpic_get_irq;
+
+	ppc_md.restart = mpc85xx_restart;
+	ppc_md.power_off = mpc85xx_power_off;
+	ppc_md.halt = mpc85xx_halt;
+
+	ppc_md.find_end_of_memory = mpc85xx_find_end_of_memory;
+
+	ppc_md.calibrate_decr = mpc85xx_calibrate_decr;
+
+	if (ppc_md.progress)
+		ppc_md.progress("platform_init(): exit", 0);
+
+	return;
+}
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/stx_gp3.h linux-2.6.11-rc3/arch/ppc/platforms/85xx/stx_gp3.h
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/85xx/stx_gp3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/85xx/stx_gp3.h	2005-02-03 02:55:35.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * arch/ppc/platforms/stx8560_gp3.h
+ *
+ * STx GP3 board definitions
+ *
+ * Dan Malek (dan@embeddededge.com)
+ * Copyright 2004 Embedded Edge, LLC
+ *
+ * Ported to 2.6, Matt Porter <mporter@kernel.crashing.org>
+ * Copyright 2004-2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef __MACH_STX_GP3_H
+#define __MACH_STX_GP3_H
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <asm/ppcboot.h>
+
+#define BOARD_CCSRBAR		((uint)0xe0000000)
+#define CCSRBAR_SIZE		((uint)1024*1024)
+
+#define CPM_MAP_ADDR		(CCSRBAR + MPC85xx_CPM_OFFSET)
+
+#define BCSR_ADDR		((uint)0xfc000000)
+#define BCSR_SIZE		((uint)(16 * 1024))
+
+#define BCSR_TSEC1_RESET	0x00000080
+#define BCSR_TSEC2_RESET	0x00000040
+#define BCSR_LED1		0x00000008
+#define BCSR_LED2		0x00000004
+#define BCSR_LED3		0x00000002
+#define BCSR_LED4		0x00000001
+
+extern void mpc85xx_setup_hose(void) __init;
+extern void mpc85xx_restart(char *cmd);
+extern void mpc85xx_power_off(void);
+extern void mpc85xx_halt(void);
+extern int mpc85xx_show_cpuinfo(struct seq_file *m);
+extern void mpc85xx_init_IRQ(void) __init;
+extern unsigned long mpc85xx_find_end_of_memory(void) __init;
+extern void mpc85xx_calibrate_decr(void) __init;
+
+#define PCI_CFG_ADDR_OFFSET	(0x8000)
+#define PCI_CFG_DATA_OFFSET	(0x8004)
+
+/* PCI interrupt controller */
+#define PIRQA		MPC85xx_IRQ_EXT1
+#define PIRQB		MPC85xx_IRQ_EXT2
+#define PIRQC		MPC85xx_IRQ_EXT3
+#define PIRQD		MPC85xx_IRQ_EXT4
+#define PCI_MIN_IDSEL	16
+#define PCI_MAX_IDSEL	19
+#define PCI_IRQ_SLOT	4
+
+#define MPC85XX_PCI1_LOWER_IO	0x00000000
+#define MPC85XX_PCI1_UPPER_IO	0x00ffffff
+
+#define MPC85XX_PCI1_LOWER_MEM	0x80000000
+#define MPC85XX_PCI1_UPPER_MEM	0x9fffffff
+
+#define MPC85XX_PCI1_IO_BASE	0xe2000000
+#define MPC85XX_PCI1_MEM_OFFSET	0x00000000
+
+#define MPC85XX_PCI1_IO_SIZE	0x01000000
+
+#endif /* __MACH_STX_GP3_H */
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/Makefile linux-2.6.11-rc3/arch/ppc/platforms/Makefile
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/Makefile	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/Makefile	2005-02-03 02:57:04.000000000 +0100
@@ -11,7 +11,7 @@ obj-$(CONFIG_PCI)		+= apus_pci.o
 endif
 obj-$(CONFIG_PPC_PMAC)		+= pmac_pic.o pmac_setup.o pmac_time.o \
 					pmac_feature.o pmac_pci.o pmac_sleep.o \
-					pmac_low_i2c.o
+					pmac_low_i2c.o pmac_cache.o
 obj-$(CONFIG_PPC_CHRP)		+= chrp_setup.o chrp_time.o chrp_pci.o
 obj-$(CONFIG_PPC_PREP)		+= prep_pci.o prep_setup.o
 ifeq ($(CONFIG_PPC_PMAC),y)
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/chrp_pci.c linux-2.6.11-rc3/arch/ppc/platforms/chrp_pci.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/chrp_pci.c	2005-02-03 10:03:08.856522707 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/chrp_pci.c	2005-02-03 02:57:04.000000000 +0100
@@ -304,6 +304,6 @@ chrp_find_bridges(void)
 	}
 
 	/* Do not fixup interrupts from OF tree on pegasos */
-	if (is_pegasos != 0)
+	if (is_pegasos == 0)
 		ppc_md.pcibios_fixup = chrp_pcibios_fixup;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/cpci690.c linux-2.6.11-rc3/arch/ppc/platforms/cpci690.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/cpci690.c	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/cpci690.c	2005-02-03 02:54:39.000000000 +0100
@@ -289,35 +289,6 @@ cpci690_setup_peripherals(void)
 	return;
 }
 
-static int __init
-cpci690_fixup_pd(void)
-{
-#if defined(CONFIG_SERIAL_MPSC)
-	struct list_head	*entry;
-	struct platform_device	*pd;
-	struct device		*dev;
-	struct mpsc_pd_dd	*dd;
-
-	list_for_each(entry, &platform_bus_type.devices.list) {
-		dev = container_of(entry, struct device, bus_list);
-		pd = container_of(dev, struct platform_device, dev);
-
-		if (!strncmp(pd->name, MPSC_CTLR_NAME, BUS_ID_SIZE)) {
-			dd = (struct mpsc_pd_dd *) dev_get_drvdata(&pd->dev);
-
-			dd->max_idle = 40;
-			dd->default_baud = 9600;
-			dd->brg_clk_src = 8;
-			dd->brg_clk_freq = 133000000;
-		}
-	}
-#endif
-
-	return 0;
-}
-
-subsys_initcall(cpci690_fixup_pd);
-
 static void __init
 cpci690_setup_arch(void)
 {
@@ -359,6 +330,50 @@ cpci690_setup_arch(void)
 	return;
 }
 
+/* Platform device data fixup routines. */
+#if defined(CONFIG_SERIAL_MPSC)
+static void __init
+cpci690_fixup_mpsc_pdata(struct platform_device *pdev)
+{
+	struct mpsc_pdata *pdata;
+
+	pdata = (struct mpsc_pdata *)pdev->dev.platform_data;
+
+	pdata->max_idle = 40;
+	pdata->default_baud = 9600;
+	pdata->brg_clk_src = 8;
+	pdata->brg_clk_freq = 133000000;
+
+	return;
+}
+
+static int __init
+cpci690_platform_notify(struct device *dev)
+{
+	static struct {
+		char	*bus_id;
+		void	((*rtn)(struct platform_device *pdev));
+	} dev_map[] = {
+		{ MPSC_CTLR_NAME "0", cpci690_fixup_mpsc_pdata },
+		{ MPSC_CTLR_NAME "1", cpci690_fixup_mpsc_pdata },
+	};
+	struct platform_device	*pdev;
+	int	i;
+
+	if (dev && dev->bus_id)
+		for (i=0; i<ARRAY_SIZE(dev_map); i++)
+			if (!strncmp(dev->bus_id, dev_map[i].bus_id,
+				BUS_ID_SIZE)) {
+
+				pdev = container_of(dev,
+					struct platform_device, dev);
+				dev_map[i].rtn(pdev);
+			}
+
+	return 0;
+}
+#endif
+
 static void
 cpci690_reset_board(void)
 {
@@ -489,5 +504,9 @@ platform_init(unsigned long r3, unsigned
 	ppc_md.early_serial_map = cpci690_early_serial_map;
 #endif	/* CONFIG_KGDB */
 
+#if defined(CONFIG_SERIAL_MPSC)
+	platform_notify = cpci690_platform_notify;
+#endif
+
 	return;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/ev64260.c linux-2.6.11-rc3/arch/ppc/platforms/ev64260.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/ev64260.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/ev64260.c	2005-02-03 02:55:35.000000000 +0100
@@ -294,7 +294,7 @@ ev64260_setup_bridge(void)
 
         /* Lookup PCI host bridges */
         if (mv64x60_init(&bh, &si))
-                printk("Bridge initialization failed.\n");
+                printk(KERN_ERR "Bridge initialization failed.\n");
 
 	pci_dram_offset = 0; /* System mem at same addr on PCI & cpu bus */
 	ppc_md.pci_swizzle = common_swizzle;
@@ -337,7 +337,8 @@ ev64260_early_serial_map(void)
 #endif
 
 		if (early_serial_setup(&port) != 0)
-			printk("Early serial init of port 0 failed\n");
+			printk(KERN_WARNING "Early serial init of port 0"
+				"failed\n");
 
 		first_time = 0;
 	}
@@ -351,35 +352,6 @@ ev64260_early_serial_map(void)
 }
 #endif
 
-static int __init
-ev64260_fixup_pd(void)
-{
-#if defined(CONFIG_SERIAL_MPSC)
-	struct list_head	*entry;
-	struct platform_device	*pd;
-	struct device		*dev;
-	struct mpsc_pd_dd	*dd;
-
-	list_for_each(entry, &platform_bus_type.devices.list) {
-		dev = container_of(entry, struct device, bus_list);
-		pd = container_of(dev, struct platform_device, dev);
-
-		if (!strncmp(pd->name, MPSC_CTLR_NAME, BUS_ID_SIZE)) {
-			dd = (struct mpsc_pd_dd *) dev_get_drvdata(&pd->dev);
-
-			dd->max_idle = 40;
-			dd->default_baud = EV64260_DEFAULT_BAUD;
-			dd->brg_clk_src = EV64260_MPSC_CLK_SRC;
-			dd->brg_clk_freq = EV64260_MPSC_CLK_FREQ;
-		}
-	}
-#endif
-
-	return 0;
-}
-
-subsys_initcall(ev64260_fixup_pd);
-
 static void __init
 ev64260_setup_arch(void)
 {
@@ -417,8 +389,8 @@ ev64260_setup_arch(void)
 	ev64260_early_serial_map();
 #endif
 
-	printk(BOARD_VENDOR " " BOARD_MACHINE "\n");
-	printk("EV-64260-BP port (C) 2001 MontaVista Software, Inc. (source@mvista.com)\n");
+	printk(KERN_INFO "%s %s port (C) 2001 MontaVista Software, Inc."
+		"(source@mvista.com)\n", BOARD_VENDOR, BOARD_MACHINE);
 
 	if (ppc_md.progress)
 		ppc_md.progress("ev64260_setup_arch: exit", 0);
@@ -426,6 +398,50 @@ ev64260_setup_arch(void)
 	return;
 }
 
+/* Platform device data fixup routines. */
+#if defined(CONFIG_SERIAL_MPSC)
+static void __init
+ev64260_fixup_mpsc_pdata(struct platform_device *pdev)
+{
+	struct mpsc_pdata *pdata;
+
+	pdata = (struct mpsc_pdata *)pdev->dev.platform_data;
+
+	pdata->max_idle = 40;
+	pdata->default_baud = EV64260_DEFAULT_BAUD;
+	pdata->brg_clk_src = EV64260_MPSC_CLK_SRC;
+	pdata->brg_clk_freq = EV64260_MPSC_CLK_FREQ;
+
+	return;
+}
+
+static int __init
+ev64260_platform_notify(struct device *dev)
+{
+	static struct {
+		char	*bus_id;
+		void	((*rtn)(struct platform_device *pdev));
+	} dev_map[] = {
+		{ MPSC_CTLR_NAME "0", ev64260_fixup_mpsc_pdata },
+		{ MPSC_CTLR_NAME "1", ev64260_fixup_mpsc_pdata },
+	};
+	struct platform_device	*pdev;
+	int	i;
+
+	if (dev && dev->bus_id)
+		for (i=0; i<ARRAY_SIZE(dev_map); i++)
+			if (!strncmp(dev->bus_id, dev_map[i].bus_id,
+				BUS_ID_SIZE)) {
+
+				pdev = container_of(dev,
+					struct platform_device, dev);
+				dev_map[i].rtn(pdev);
+			}
+
+	return 0;
+}
+#endif
+
 static void
 ev64260_reset_board(void *addr)
 {
@@ -462,7 +478,7 @@ ev64260_reset_board(void *addr)
 	/* map bootrom back in to gt @ reset defaults */
 	mv64x60_set_32bit_window(&bh, MV64x60_CPU2BOOT_WIN,
 						0xff800000, 8*1024*1024, 0);
-	bh.ci->disable_window_32bit(&bh, MV64x60_CPU2BOOT_WIN);
+	bh.ci->enable_window_32bit(&bh, MV64x60_CPU2BOOT_WIN);
 
 	/* move reg base back to default, setup default pci0 */
 	mv64x60_write(&bh, MV64x60_INTERNAL_SPACE_DECODE,
@@ -531,7 +547,7 @@ ev64260_calibrate_decr(void)
 
 	freq = ev64260_get_bus_speed()/4;
 
-	printk("time_init: decrementer frequency = %lu.%.6lu MHz\n",
+	printk(KERN_INFO "time_init: decrementer frequency = %lu.%.6lu MHz\n",
 	       freq/1000000, freq%1000000);
 
 	tb_ticks_per_jiffy = freq / HZ;
@@ -627,5 +643,9 @@ platform_init(unsigned long r3, unsigned
 
 #endif
 
+#if defined(CONFIG_SERIAL_MPSC)
+	platform_notify = ev64260_platform_notify;
+#endif
+
 	return;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/katana.c linux-2.6.11-rc3/arch/ppc/platforms/katana.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/katana.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/katana.c	2005-02-03 02:56:48.000000000 +0100
@@ -8,9 +8,9 @@
  * Based on code done by Rabeeh Khoury - rabeeh@galileo.co.il
  * Based on code done by - Mark A. Greer <mgreer@mvista.com>
  *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
  * option) any later version.
  */
 /*
@@ -194,6 +194,14 @@ katana_bus_freq(void)
 	bd_cfg_0 = in_8((volatile char *)(cpld_base + KATANA_CPLD_BD_CFG_0));
 
 	switch (bd_cfg_0 & KATANA_CPLD_BD_CFG_0_SYSCLK_MASK) {
+	case KATANA_CPLD_BD_CFG_0_SYSCLK_200:
+		return 200000000;
+		break;
+
+	case KATANA_CPLD_BD_CFG_0_SYSCLK_166:
+		return 166666666;
+		break;
+
 	case KATANA_CPLD_BD_CFG_0_SYSCLK_133:
 		return 133333333;
 		break;
@@ -234,7 +242,7 @@ katana_intr_setup(void)
 	/* Config GPP intr ctlr to respond to level trigger */
 	mv64x60_set_bits(&bh, MV64x60_COMM_ARBITER_CNTL, (1<<10));
 
-	/* XXXX Erranum FEr PCI-#8 */
+	/* Erranum FEr PCI-#8 */
 	mv64x60_clr_bits(&bh, MV64x60_PCI0_CMD, (1<<5) | (1<<9));
 	mv64x60_clr_bits(&bh, MV64x60_PCI1_CMD, (1<<5) | (1<<9));
 
@@ -392,7 +400,7 @@ katana_setup_bridge(void)
 
 	/* Lookup PCI host bridges */
 	if (mv64x60_init(&bh, &si))
-		printk("Bridge initialization failed.\n");
+		printk(KERN_WARNING "Bridge initialization failed.\n");
 
 	pci_dram_offset = 0; /* sys mem at same addr on PCI & cpu bus */
 	ppc_md.pci_swizzle = common_swizzle;
@@ -433,7 +441,7 @@ katana_setup_arch(void)
 	 * avoid dirty data in cache
 	 */
 	if (PVR_REV(mfspr(PVR)) == 0x0200) {
-		printk("DD2.0 detected. Setting L2 cache"
+		printk(KERN_INFO "DD2.0 detected. Setting L2 cache"
 			"to Writethrough mode\n");
 		_set_L2CR(L2CR_L2E | L2CR_L2PE | L2CR_L2WT);
 	}
@@ -447,83 +455,96 @@ katana_setup_arch(void)
 	katana_setup_peripherals();
 	katana_enable_ipmi();
 
-	printk("Artesyn Communication Products, LLC - Katana(TM)\n");
+	printk(KERN_INFO "Artesyn Communication Products, LLC - Katana(TM)\n");
 	if (ppc_md.progress)
 		ppc_md.progress("katana_setup_arch: exit", 0);
 	return;
 }
 
-/* Platform device data fixup routine. */
-static int __init
-katana_fixup_pd(void)
-{
-	struct list_head	*entry;
-	struct platform_device	*pd;
-	struct device		*dev;
+/* Platform device data fixup routines. */
 #if defined(CONFIG_SERIAL_MPSC)
-	struct mpsc_pd_dd	*dd;
+static void __init
+katana_fixup_mpsc_pdata(struct platform_device *pdev)
+{
+	struct mpsc_pdata *pdata;
+
+	pdata = (struct mpsc_pdata *)pdev->dev.platform_data;
+
+	pdata->max_idle = 40;
+	pdata->default_baud = KATANA_DEFAULT_BAUD;
+	pdata->brg_clk_src = KATANA_MPSC_CLK_SRC;
+	pdata->brg_clk_freq = KATANA_MPSC_CLK_FREQ;
+
+	return;
+}
 #endif
+
 #if defined(CONFIG_MV643XX_ETH)
-	struct mv64xxx_eth_pd_dd *eth_dd;
+static void __init
+katana_fixup_eth_pdata(struct platform_device *pdev)
+{
+	struct mv64xxx_eth_platform_data *eth_pd;
 	static u16 phy_addr[] = {
 		KATANA_ETH0_PHY_ADDR,
 		KATANA_ETH1_PHY_ADDR,
 		KATANA_ETH2_PHY_ADDR,
 	};
-	struct resource	*rx_r;
-	struct resource	*tx_r;
-	int		rx_size = KATANA_ETH_RX_QUEUE_SIZE * ETH_DESC_SIZE;
-	int		tx_size = KATANA_ETH_TX_QUEUE_SIZE * ETH_DESC_SIZE;
-#endif
+	int	rx_size = KATANA_ETH_RX_QUEUE_SIZE * MV64340_ETH_DESC_SIZE;
+	int	tx_size = KATANA_ETH_TX_QUEUE_SIZE * MV64340_ETH_DESC_SIZE;
 
-	list_for_each(entry, &platform_bus_type.devices.list) {
-		dev = container_of(entry, struct device, bus_list);
-		pd = container_of(dev, struct platform_device, dev);
+	eth_pd = pdev->dev.platform_data;
+	eth_pd->force_phy_addr = 1;
+	eth_pd->phy_addr = phy_addr[pdev->id];
+	eth_pd->tx_queue_size = KATANA_ETH_TX_QUEUE_SIZE;
+	eth_pd->rx_queue_size = KATANA_ETH_RX_QUEUE_SIZE;
+	eth_pd->tx_sram_addr = mv643xx_sram_alloc(tx_size);
 
-#if defined(CONFIG_SERIAL_MPSC)
-		if (!strncmp(pd->name, MPSC_CTLR_NAME, BUS_ID_SIZE)) {
-			dd = (struct mpsc_pd_dd *)dev_get_drvdata(&pd->dev);
+	if (eth_pd->tx_sram_addr)
+		eth_pd->tx_sram_size = tx_size;
+	else
+		printk(KERN_ERR "mv643xx_sram_alloc failed\n");
 
-			dd->max_idle = 40;	/* XXXX what should be? */
-			dd->default_baud = KATANA_DEFAULT_BAUD;
-			dd->brg_clk_src = KATANA_MPSC_CLK_SRC;
-			dd->brg_clk_freq = KATANA_MPSC_CLK_FREQ;
-		}
+	eth_pd->rx_sram_addr = mv643xx_sram_alloc(rx_size);
+	if (eth_pd->rx_sram_addr)
+		eth_pd->rx_sram_size = rx_size;
+	else
+		printk(KERN_ERR "mv643xx_sram_alloc failed\n");
+}
+#endif
+
+static int __init
+katana_platform_notify(struct device *dev)
+{
+	static struct {
+		char	*bus_id;
+		void	((*rtn)(struct platform_device *pdev));
+	} dev_map[] = {
+#if defined(CONFIG_SERIAL_MPSC)
+		{ MPSC_CTLR_NAME "0", katana_fixup_mpsc_pdata },
+		{ MPSC_CTLR_NAME "1", katana_fixup_mpsc_pdata },
 #endif
 #if defined(CONFIG_MV643XX_ETH)
-		if (!strncmp(pd->name, MV64XXX_ETH_NAME, BUS_ID_SIZE)) {
-			eth_dd = (struct mv64xxx_eth_pd_dd *)
-						dev_get_drvdata(&pd->dev);
-			eth_dd->phy_addr = phy_addr[pd->id];
-			eth_dd->port_config = KATANA_ETH_PORT_CONFIG_VALUE;
-			eth_dd->port_config_extend =
-					KATANA_ETH_PORT_CONFIG_EXTEND_VALUE;
-			eth_dd->port_sdma_config =
-					KATANA_ETH_PORT_SDMA_CONFIG_VALUE;
-			eth_dd->port_serial_control =
-					KATANA_ETH_PORT_SERIAL_CONTROL_VALUE;
-			eth_dd->tx_queue_size = KATANA_ETH_TX_QUEUE_SIZE;
-			eth_dd->rx_queue_size = KATANA_ETH_RX_QUEUE_SIZE;
-
-			rx_r = &pd->resource[5];
-			rx_r->start = KATANA_INTERNAL_SRAM_BASE +
-						(rx_size + tx_size) * pd->id;
-			rx_r->end = rx_r->start + rx_size - 1;
-			rx_r->flags = IORESOURCE_MEM;
-
-			tx_r = &pd->resource[6];
-			tx_r->start = rx_r->start + rx_size;
-			tx_r->end = tx_r->start + tx_size - 1;
-			tx_r->flags = IORESOURCE_MEM;
-		}
+		{ MV64XXX_ETH_NAME "0", katana_fixup_eth_pdata },
+		{ MV64XXX_ETH_NAME "1", katana_fixup_eth_pdata },
+		{ MV64XXX_ETH_NAME "2", katana_fixup_eth_pdata },
 #endif
-	}
+	};
+	struct platform_device	*pdev;
+	int	i;
+
+	if (dev && dev->bus_id)
+		for (i=0; i<ARRAY_SIZE(dev_map); i++)
+			if (!strncmp(dev->bus_id, dev_map[i].bus_id,
+				BUS_ID_SIZE)) {
+
+				pdev = container_of(dev,
+					struct platform_device, dev);
+				dev_map[i].rtn(pdev);
+			}
 
 	return 0;
 }
 
-subsys_initcall(katana_fixup_pd);
-
 static void
 katana_restart(char *cmd)
 {
@@ -595,7 +616,7 @@ katana_calibrate_decr(void)
 
 	freq = katana_bus_freq() / 4;
 
-	printk("time_init: decrementer frequency = %lu.%.6lu MHz\n",
+	printk(KERN_INFO "time_init: decrementer frequency = %lu.%.6lu MHz\n",
 	       freq / 1000000, freq % 1000000);
 
 	tb_ticks_per_jiffy = freq / HZ;
@@ -654,7 +675,10 @@ platform_init(unsigned long r3, unsigned
 	mv64x60_progress_init(KATANA_BRIDGE_REG_BASE);
 #endif
 
-	katana_set_bat(); /* Need for katana_find_end_of_memory and progress */
+#if defined(CONFIG_SERIAL_MPSC) || defined(CONFIG_MV643XX_ETH)
+	platform_notify = katana_platform_notify;
+#endif
 
+	katana_set_bat(); /* Need for katana_find_end_of_memory and progress */
 	return;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/katana.h linux-2.6.11-rc3/arch/ppc/platforms/katana.h
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/katana.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/katana.h	2005-02-03 02:57:04.000000000 +0100
@@ -8,9 +8,9 @@
  * Based on code done by Rabeeh Khoury - rabeeh@galileo.co.il
  * Based on code done by Mark A. Greer <mgreer@mvista.com>
  *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
  * option) any later version.
  */
 
@@ -107,6 +107,8 @@
 #define KATANA_CPLD_RST_CMD_HR			0x01
 
 #define KATANA_CPLD_BD_CFG_0_SYSCLK_MASK	0xc0
+#define KATANA_CPLD_BD_CFG_0_SYSCLK_200		0x00
+#define KATANA_CPLD_BD_CFG_0_SYSCLK_166		0x80
 #define KATANA_CPLD_BD_CFG_0_SYSCLK_133		0xc0
 #define KATANA_CPLD_BD_CFG_0_SYSCLK_100		0x40
 
@@ -170,8 +172,8 @@
 #define KATANA_PRODUCT_ID_750i			0x02
 #define KATANA_PRODUCT_ID_752i			0x04
 
-#define KATANA_ETH_TX_QUEUE_SIZE		1050
-#define KATANA_ETH_RX_QUEUE_SIZE		450
+#define KATANA_ETH_TX_QUEUE_SIZE		800
+#define KATANA_ETH_RX_QUEUE_SIZE		400
 
 #define	KATANA_ETH_PORT_CONFIG_VALUE			\
 	ETH_UNICAST_NORMAL_MODE			|	\
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_cache.S linux-2.6.11-rc3/arch/ppc/platforms/pmac_cache.S
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_cache.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/pmac_cache.S	2005-02-03 02:55:50.000000000 +0100
@@ -0,0 +1,325 @@
+/*
+ * This file contains low-level cache management functions
+ * used for sleep and CPU speed changes on Apple machines.
+ * (In fact the only thing that is Apple-specific is that we assume
+ * that we can read from ROM at physical address 0xfff00000.)
+ *
+ *    Copyright (C) 2004 Paul Mackerras (paulus@samba.org) and
+ *                       Benjamin Herrenschmidt (benh@kernel.crashing.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/processor.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+
+/*
+ * Flush and disable all data caches (dL1, L2, L3). This is used
+ * when going to sleep, when doing a PMU based cpufreq transition,
+ * or when "offlining" a CPU on SMP machines. This code is over
+ * paranoid, but I've had enough issues with various CPU revs and
+ * bugs that I decided it was worth beeing over cautious
+ */
+
+_GLOBAL(flush_disable_caches)
+BEGIN_FTR_SECTION
+	b	flush_disable_745x
+END_FTR_SECTION_IFSET(CPU_FTR_SPEC7450)
+BEGIN_FTR_SECTION
+	b	flush_disable_75x
+END_FTR_SECTION_IFSET(CPU_FTR_L2CR)
+	b	__flush_disable_L1
+
+/* This is the code for G3 and 74[01]0 */
+flush_disable_75x:
+	mflr	r10
+
+	/* Turn off EE and DR in MSR */
+	mfmsr	r11
+	rlwinm	r0,r11,0,~MSR_EE
+	rlwinm	r0,r0,0,~MSR_DR
+	sync
+	mtmsr	r0
+	isync
+
+	/* Stop DST streams */
+BEGIN_FTR_SECTION
+	DSSALL
+	sync
+END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
+
+	/* Stop DPM */
+	mfspr	r8,SPRN_HID0		/* Save HID0 in r8 */
+	rlwinm	r4,r8,0,12,10		/* Turn off HID0[DPM] */
+	sync
+	mtspr	SPRN_HID0,r4		/* Disable DPM */
+	sync
+
+	/* disp-flush L1 */
+	li	r4,0x4000
+	mtctr	r4
+	lis	r4,0xfff0
+1:	lwzx	r0,r0,r4
+	addi	r4,r4,32
+	bdnz	1b
+	sync
+	isync
+
+	/* disable / invalidate / enable L1 data */
+	mfspr	r3,SPRN_HID0
+	rlwinm	r0,r0,0,~HID0_DCE
+	mtspr	SPRN_HID0,r3
+	sync
+	isync
+	ori	r3,r3,HID0_DCE|HID0_DCI
+	sync
+	isync
+	mtspr	SPRN_HID0,r3
+	xori	r3,r3,HID0_DCI
+	mtspr	SPRN_HID0,r3
+	sync
+
+	/* Get the current enable bit of the L2CR into r4 */
+	mfspr	r5,L2CR
+	/* Set to data-only (pre-745x bit) */
+	oris	r3,r5,L2CR_L2DO@h
+	b	2f
+	/* When disabling L2, code must be in L1 */
+	.balign 32
+1:	mtspr	L2CR,r3
+3:	sync
+	isync
+	b	1f
+2:	b	3f
+3:	sync
+	isync
+	b	1b
+1:	/* disp-flush L2. The interesting thing here is that the L2 can be
+	 * up to 2Mb ... so using the ROM, we'll end up wrapping back to memory
+	 * but that is probbaly fine. We disp-flush over 4Mb to be safe
+	 */
+	lis	r4,2
+	mtctr	r4
+	lis	r4,0xfff0
+1:	lwzx	r0,r0,r4
+	addi	r4,r4,32
+	bdnz	1b
+	sync
+	isync
+	/* now disable L2 */
+	rlwinm	r5,r5,0,~L2CR_L2E
+	b	2f
+	/* When disabling L2, code must be in L1 */
+	.balign 32
+1:	mtspr	L2CR,r5
+3:	sync
+	isync
+	b	1f
+2:	b	3f
+3:	sync
+	isync
+	b	1b
+1:	sync
+	isync
+	/* Invalidate L2. This is pre-745x, we clear the L2I bit ourselves */
+	oris	r4,r5,L2CR_L2I@h
+	mtspr	L2CR,r4
+	sync
+	isync
+	xoris	r4,r4,L2CR_L2I@h
+	sync
+	mtspr	L2CR,r4
+	sync
+
+	/* now disable the L1 data cache */
+	mfspr	r0,HID0
+	rlwinm	r0,r0,0,~HID0_DCE
+	mtspr	HID0,r0
+	sync
+	isync
+
+	/* Restore HID0[DPM] to whatever it was before */
+	sync
+	mtspr	SPRN_HID0,r8
+	sync
+
+	/* restore DR and EE */
+	sync
+	mtmsr	r11
+	isync
+
+	mtlr	r10
+	blr
+
+/* This code is for 745x processors */
+flush_disable_745x:
+	/* Turn off EE and DR in MSR */
+	mfmsr	r11
+	rlwinm	r0,r11,0,~MSR_EE
+	rlwinm	r0,r0,0,~MSR_DR
+	sync
+	mtmsr	r0
+	isync
+
+	/* Stop prefetch streams */
+	DSSALL
+	sync
+
+	/* Disable L2 prefetching */
+	mfspr	r0,SPRN_MSSCR0
+	rlwinm	r0,r0,0,0,29
+	mtspr	SPRN_MSSCR0,r0
+	sync
+	isync
+	lis	r4,0
+	dcbf	0,r4
+	dcbf	0,r4
+	dcbf	0,r4
+	dcbf	0,r4
+	dcbf	0,r4
+	dcbf	0,r4
+	dcbf	0,r4
+	dcbf	0,r4
+
+	/* Due to a bug with the HW flush on some CPU revs, we occasionally
+	 * experience data corruption. I'm adding a displacement flush along
+	 * with a dcbf loop over a few Mb to "help". The problem isn't totally
+	 * fixed by this in theory, but at least, in practice, I couldn't reproduce
+	 * it even with a big hammer...
+	 */
+
+        lis     r4,0x0002
+        mtctr   r4
+ 	li      r4,0
+1:
+        lwzx    r0,r0,r4
+        addi    r4,r4,32                /* Go to start of next cache line */
+        bdnz    1b
+        isync
+
+        /* Now, flush the first 4MB of memory */
+        lis     r4,0x0002
+        mtctr   r4
+	li      r4,0
+        sync
+1:
+        dcbf    0,r4
+        addi    r4,r4,32                /* Go to start of next cache line */
+        bdnz    1b
+
+	/* Flush and disable the L1 data cache */
+	mfspr	r6,SPRN_LDSTCR
+	lis	r3,0xfff0	/* read from ROM for displacement flush */
+	li	r4,0xfe		/* start with only way 0 unlocked */
+	li	r5,128		/* 128 lines in each way */
+1:	mtctr	r5
+	rlwimi	r6,r4,0,24,31
+	mtspr	SPRN_LDSTCR,r6
+	sync
+	isync
+2:	lwz	r0,0(r3)	/* touch each cache line */
+	addi	r3,r3,32
+	bdnz	2b
+	rlwinm	r4,r4,1,24,30	/* move on to the next way */
+	ori	r4,r4,1
+	cmpwi	r4,0xff		/* all done? */
+	bne	1b
+	/* now unlock the L1 data cache */
+	li	r4,0
+	rlwimi	r6,r4,0,24,31
+	sync
+	mtspr	SPRN_LDSTCR,r6
+	sync
+	isync
+
+	/* Flush the L2 cache using the hardware assist */
+	mfspr	r3,L2CR
+	cmpwi	r3,0		/* check if it is enabled first */
+	bge	4f
+	oris	r0,r3,(L2CR_L2IO_745x|L2CR_L2DO_745x)@h
+	b	2f
+	/* When disabling/locking L2, code must be in L1 */
+	.balign 32
+1:	mtspr	L2CR,r0		/* lock the L2 cache */
+3:	sync
+	isync
+	b	1f
+2:	b	3f
+3:	sync
+	isync
+	b	1b
+1:	sync
+	isync
+	ori	r0,r3,L2CR_L2HWF_745x
+	sync
+	mtspr	L2CR,r0		/* set the hardware flush bit */
+3:	mfspr	r0,L2CR		/* wait for it to go to 0 */
+	andi.	r0,r0,L2CR_L2HWF_745x
+	bne	3b
+	sync
+	rlwinm	r3,r3,0,~L2CR_L2E
+	b	2f
+	/* When disabling L2, code must be in L1 */
+	.balign 32
+1:	mtspr	L2CR,r3		/* disable the L2 cache */
+3:	sync
+	isync
+	b	1f
+2:	b	3f
+3:	sync
+	isync
+	b	1b
+1:	sync
+	isync
+	oris	r4,r3,L2CR_L2I@h
+	mtspr	L2CR,r4
+	sync
+	isync
+1:	mfspr	r4,L2CR
+	andis.	r0,r4,L2CR_L2I@h
+	bne	1b
+	sync
+
+BEGIN_FTR_SECTION
+	/* Flush the L3 cache using the hardware assist */
+4:	mfspr	r3,L3CR
+	cmpwi	r3,0		/* check if it is enabled */
+	bge	6f
+	oris	r0,r3,L3CR_L3IO@h
+	ori	r0,r0,L3CR_L3DO
+	sync
+	mtspr	L3CR,r0		/* lock the L3 cache */
+	sync
+	isync
+	ori	r0,r0,L3CR_L3HWF
+	sync
+	mtspr	L3CR,r0		/* set the hardware flush bit */
+5:	mfspr	r0,L3CR		/* wait for it to go to zero */
+	andi.	r0,r0,L3CR_L3HWF
+	bne	5b
+	rlwinm	r3,r3,0,~L3CR_L3E
+	sync
+	mtspr	L3CR,r3		/* disable the L3 cache */
+	sync
+	ori	r4,r3,L3CR_L3I
+	mtspr	SPRN_L3CR,r4
+1:	mfspr	r4,SPRN_L3CR
+	andi.	r0,r4,L3CR_L3I
+	bne	1b
+	sync
+END_FTR_SECTION_IFSET(CPU_FTR_L3CR)
+
+6:	mfspr	r0,HID0		/* now disable the L1 data cache */
+	rlwinm	r0,r0,0,~HID0_DCE
+	mtspr	HID0,r0
+	sync
+	isync
+	mtmsr	r11		/* restore DR and EE */
+	isync
+	blr
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_cpufreq.c linux-2.6.11-rc3/arch/ppc/platforms/pmac_cpufreq.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_cpufreq.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/pmac_cpufreq.c	2005-02-03 02:55:53.000000000 +0100
@@ -154,6 +154,14 @@ static int __pmac dfs_set_cpu_speed(int 
 	return 0;
 }
 
+static unsigned int __pmac dfs_get_cpu_speed(unsigned int cpu)
+{
+	if (mfspr(HID1) & HID1_DFS)
+		return low_freq;
+	else
+		return hi_freq;
+}
+
 
 /* Switch CPU speed using slewing GPIOs
  */
@@ -229,10 +237,6 @@ static int __pmac pmu_set_cpu_speed(int 
 	/* Save & disable L2 and L3 caches */
 	save_l3cr = _get_L3CR();	/* (returns -1 if not available) */
 	save_l2cr = _get_L2CR();	/* (returns -1 if not available) */
-	if (save_l3cr != 0xffffffff && (save_l3cr & L3CR_L3E) != 0)
-		_set_L3CR(save_l3cr & 0x7fffffff);
-	if (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)
-		_set_L2CR(save_l2cr & 0x7fffffff);
 
 	/* Send the new speed command. My assumption is that this command
 	 * will cause PLL_CFG[0..3] to be changed next time CPU goes to sleep
@@ -458,14 +462,13 @@ static int __pmac pmac_cpufreq_init_7447
 {
 	struct device_node *volt_gpio_np;
 	u32 *reg;
+	struct cpufreq_driver *driver = &pmac_cpufreq_driver;
 
 	/* OF only reports the high frequency */
 	hi_freq = cur_freq;
 	low_freq = cur_freq/2;
-	if (mfspr(HID1) & HID1_DFS)
-		cur_freq = low_freq;
-	else
-		cur_freq = hi_freq;
+	driver->get = dfs_get_cpu_speed;
+	cur_freq = driver->get(0);
 
 	volt_gpio_np = of_find_node_by_name(NULL, "cpu-vcore-select");
 	if (!volt_gpio_np){
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_feature.c linux-2.6.11-rc3/arch/ppc/platforms/pmac_feature.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_feature.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/pmac_feature.c	2005-02-03 02:56:48.000000000 +0100
@@ -1177,6 +1177,39 @@ core99_usb_enable(struct device_node* no
 			(void)MACIO_IN32(KEYLARGO_FCR3);
 			udelay(10);
 		}
+		if (macio->type == macio_intrepid) {
+			/* wait for clock stopped bits to clear */
+			u32 test0 = 0, test1 = 0;
+			u32 status0, status1;
+			int timeout = 1000;
+
+			UNLOCK(flags);
+			switch (number) {
+			case 0:
+				test0 = UNI_N_CLOCK_STOPPED_USB0;
+				test1 = UNI_N_CLOCK_STOPPED_USB0PCI;
+				break;
+			case 2:
+				test0 = UNI_N_CLOCK_STOPPED_USB1;
+				test1 = UNI_N_CLOCK_STOPPED_USB1PCI;
+				break;
+			case 4:
+				test0 = UNI_N_CLOCK_STOPPED_USB2;
+				test1 = UNI_N_CLOCK_STOPPED_USB2PCI;
+				break;
+			}
+			do {
+				if (--timeout <= 0) {
+					printk(KERN_ERR "core99_usb_enable: "
+					       "Timeout waiting for clocks\n");
+					break;
+				}
+				mdelay(1);
+				status0 = UN_IN(UNI_N_CLOCK_STOP_STATUS0);
+				status1 = UN_IN(UNI_N_CLOCK_STOP_STATUS1);
+			} while ((status0 & test0) | (status1 & test1));
+			LOCK(flags);
+		}
 	} else {
 		/* Turn OFF */
 		if (number < 4) {
@@ -1199,20 +1232,20 @@ core99_usb_enable(struct device_node* no
 			udelay(1);
 		}
 		if (number == 0) {
-			MACIO_BIC(KEYLARGO_FCR0, KL0_USB0_CELL_ENABLE);
+			if (macio->type != macio_intrepid)
+				MACIO_BIC(KEYLARGO_FCR0, KL0_USB0_CELL_ENABLE);
 			(void)MACIO_IN32(KEYLARGO_FCR0);
 			udelay(1);
 			MACIO_BIS(KEYLARGO_FCR0, (KL0_USB0_PAD_SUSPEND0 | KL0_USB0_PAD_SUSPEND1));
 			(void)MACIO_IN32(KEYLARGO_FCR0);
 		} else if (number == 2) {
-			MACIO_BIC(KEYLARGO_FCR0, KL0_USB1_CELL_ENABLE);
+			if (macio->type != macio_intrepid)
+				MACIO_BIC(KEYLARGO_FCR0, KL0_USB1_CELL_ENABLE);
 			(void)MACIO_IN32(KEYLARGO_FCR0);
 			udelay(1);
 			MACIO_BIS(KEYLARGO_FCR0, (KL0_USB1_PAD_SUSPEND0 | KL0_USB1_PAD_SUSPEND1));
 			(void)MACIO_IN32(KEYLARGO_FCR0);
 		} else if (number == 4) {
-			MACIO_BIC(KEYLARGO_FCR1, KL1_USB2_CELL_ENABLE);
-			(void)MACIO_IN32(KEYLARGO_FCR1);
 			udelay(1);
 			MACIO_BIS(KEYLARGO_FCR1, (KL1_USB2_PAD_SUSPEND0 | KL1_USB2_PAD_SUSPEND1));
 			(void)MACIO_IN32(KEYLARGO_FCR1);
@@ -1535,22 +1568,17 @@ intrepid_shutdown(struct macio_chip* mac
 	u32 temp;
 
 	MACIO_BIC(KEYLARGO_FCR0,KL0_SCCA_ENABLE | KL0_SCCB_ENABLE |
-				KL0_SCC_CELL_ENABLE |
-				KL0_USB0_CELL_ENABLE | KL0_USB1_CELL_ENABLE);
+		  KL0_SCC_CELL_ENABLE);
 
 	MACIO_BIC(KEYLARGO_FCR1,
-		KL1_USB2_CELL_ENABLE |
+		  /*KL1_USB2_CELL_ENABLE |*/
 		KL1_I2S0_CELL_ENABLE | KL1_I2S0_CLK_ENABLE_BIT |
 		KL1_I2S0_ENABLE | KL1_I2S1_CELL_ENABLE |
 		KL1_I2S1_CLK_ENABLE_BIT | KL1_I2S1_ENABLE);
 	if (pmac_mb.board_flags & PMAC_MB_MOBILE)
 		MACIO_BIC(KEYLARGO_FCR1, KL1_UIDE_RESET_N);
 
-	MACIO_BIS(KEYLARGO_FCR2, KL2_ALT_DATA_OUT);
-
 	temp = MACIO_IN32(KEYLARGO_FCR3);
-	temp |= KL3_IT_SHUTDOWN_PLL1 | KL3_IT_SHUTDOWN_PLL2 |
-		KL3_IT_SHUTDOWN_PLL3;
 	temp &= ~(KL3_CLK49_ENABLE | KL3_CLK45_ENABLE |
 		  KL3_I2S1_CLK18_ENABLE | KL3_I2S0_CLK18_ENABLE);
 	if (sleep_mode)
@@ -1558,7 +1586,8 @@ intrepid_shutdown(struct macio_chip* mac
 	MACIO_OUT32(KEYLARGO_FCR3, temp);
 
 	/* Flush posted writes & wait a bit */
-	(void)MACIO_IN32(KEYLARGO_FCR0); mdelay(1);
+	(void)MACIO_IN32(KEYLARGO_FCR0);
+	mdelay(10);
 }
 
 static int __pmac
@@ -1572,6 +1601,12 @@ core99_sleep(void)
 	    macio->type != macio_intrepid)
 		return -ENODEV;
 
+	/* The device-tree contains that in the hwclock node */
+	if (macio->type == macio_intrepid) {
+		UN_OUT(UNI_N_CLOCK_SPREADING, 0);
+		mdelay(40);
+	}
+
 	/* We power off the wireless slot in case it was not done
 	 * by the driver. We don't power it on automatically however
 	 */
@@ -1634,11 +1669,15 @@ core99_sleep(void)
 	 */
 
 	save_unin_clock_ctl = UN_IN(UNI_N_CLOCK_CNTL);
+	/* Note: do not switch GMAC off, driver does it when necessary, WOL must keep it
+	 * enabled !
+	 */
 	UN_OUT(UNI_N_CLOCK_CNTL, save_unin_clock_ctl &
-		~(UNI_N_CLOCK_CNTL_GMAC|UNI_N_CLOCK_CNTL_FW/*|UNI_N_CLOCK_CNTL_PCI*/));
+	       ~(/*UNI_N_CLOCK_CNTL_GMAC|*/UNI_N_CLOCK_CNTL_FW/*|UNI_N_CLOCK_CNTL_PCI*/));
 	udelay(100);
 	UN_OUT(UNI_N_HWINIT_STATE, UNI_N_HWINIT_STATE_SLEEPING);
 	UN_OUT(UNI_N_POWER_MGT, UNI_N_POWER_MGT_SLEEP);
+	mdelay(10);
 
 	/*
 	 * FIXME: A bit of black magic with OpenPIC (don't ask me why)
@@ -1710,6 +1749,12 @@ core99_wake_up(void)
 	UN_OUT(UNI_N_CLOCK_CNTL, save_unin_clock_ctl);
 	udelay(100);
 
+	/* Restore clock spreading */
+	if (macio->type == macio_intrepid) {
+		UN_OUT(UNI_N_CLOCK_SPREADING, 2);
+		mdelay(40);
+	}
+
 	return 0;
 }
 
@@ -1733,6 +1778,33 @@ core99_sleep_state(struct device_node* n
 	}
 	if ((pmac_mb.board_flags & PMAC_MB_CAN_SLEEP) == 0)
 		return -EPERM;
+
+#ifdef CONFIG_CPU_FREQ_PMAC
+	/* XXX should be elsewhere */
+	if (machine_is_compatible("PowerBook6,5") ||
+	    machine_is_compatible("PowerBook6,4") ||
+	    machine_is_compatible("PowerBook5,5") ||
+	    machine_is_compatible("PowerBook5,4")) {
+		struct device_node *volt_gpio_np;
+		u32 *reg = NULL;
+
+		volt_gpio_np = of_find_node_by_name(NULL, "cpu-vcore-select");
+		if (volt_gpio_np != NULL)
+			reg = (u32 *)get_property(volt_gpio_np, "reg", NULL);
+		if (reg != NULL) {
+			/* Set the CPU voltage high if sleeping */
+			if (value == 1) {
+				pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL,
+						  *reg, 0x05);
+			} else if (value == 0 && (mfspr(HID1) & HID1_DFS)) {
+				pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL,
+						  *reg, 0x04);
+			}
+			mdelay(2);
+		}
+	}
+#endif /* CONFIG_CPU_FREQ_PMAC */
+
 	if (value == 1)
 		return core99_sleep();
 	else if (value == 0)
@@ -1743,6 +1815,18 @@ core99_sleep_state(struct device_node* n
 #endif /* CONFIG_POWER4 */
 
 static long __pmac
+generic_dev_can_wake(struct device_node* node, long param, long value)
+{
+	/* Todo: eventually check we are really dealing with on-board
+	 * video device ...
+	 */
+
+	if (pmac_mb.board_flags & PMAC_MB_MAY_SLEEP)
+		pmac_mb.board_flags |= PMAC_MB_CAN_SLEEP;
+	return 0;
+}
+
+static long __pmac
 generic_get_mb_info(struct device_node* node, long param, long value)
 {
 	switch(param) {
@@ -1767,6 +1851,7 @@ generic_get_mb_info(struct device_node* 
  */
 static struct feature_table_entry any_features[]  __pmacdata = {
 	{ PMAC_FTR_GET_MB_INFO,		generic_get_mb_info },
+	{ PMAC_FTR_DEVICE_CAN_WAKE,	generic_dev_can_wake },
 	{ 0, NULL }
 };
 
@@ -1995,7 +2080,7 @@ static struct pmac_mb_def pmac_mb_defs[]
 	},
 	{	"PowerBook1,1",			"PowerBook 101 (Lombard)",
 		PMAC_TYPE_101_PBOOK,		paddington_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_MOBILE
 	},
 	{	"iMac,1",			"iMac (first generation)",
 		PMAC_TYPE_ORIG_IMAC,		paddington_features,
@@ -2003,23 +2088,23 @@ static struct pmac_mb_def pmac_mb_defs[]
 	},
 	{	"PowerMac4,1",			"iMac \"Flower Power\"",
 		PMAC_TYPE_PANGEA_IMAC,		pangea_features,
-		PMAC_MB_CAN_SLEEP
+		PMAC_MB_MAY_SLEEP
 	},
 	{	"PowerBook4,3",			"iBook 2 rev. 2",
 		PMAC_TYPE_IBOOK2,		pangea_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
 	},
 	{	"PowerBook4,2",			"iBook 2",
 		PMAC_TYPE_IBOOK2,		pangea_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
 	},
 	{	"PowerBook4,1",			"iBook 2",
 		PMAC_TYPE_IBOOK2,		pangea_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
 	},
 	{	"PowerMac4,4",			"eMac",
 		PMAC_TYPE_EMAC,			core99_features,
-		PMAC_MB_CAN_SLEEP
+		PMAC_MB_MAY_SLEEP
 	},
 	{	"PowerMac4,2",			"Flat panel iMac",
 		PMAC_TYPE_FLAT_PANEL_IMAC,	pangea_features,
@@ -2043,55 +2128,57 @@ static struct pmac_mb_def pmac_mb_defs[]
 	},
 	{	"PowerMac3,2",			"PowerMac G4 AGP Graphics",
 		PMAC_TYPE_SAWTOOTH,		core99_features,
-		PMAC_MB_OLD_CORE99
+		PMAC_MB_MAY_SLEEP | PMAC_MB_OLD_CORE99
 	},
 	{	"PowerMac3,3",			"PowerMac G4 AGP Graphics",
 		PMAC_TYPE_SAWTOOTH,		core99_features,
-		PMAC_MB_OLD_CORE99
+		PMAC_MB_MAY_SLEEP | PMAC_MB_OLD_CORE99
 	},
 	{	"PowerMac2,1",			"iMac FireWire",
 		PMAC_TYPE_FW_IMAC,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_OLD_CORE99
+		PMAC_MB_MAY_SLEEP | PMAC_MB_OLD_CORE99
 	},
 	{	"PowerMac2,2",			"iMac FireWire",
 		PMAC_TYPE_FW_IMAC,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_OLD_CORE99
+		PMAC_MB_MAY_SLEEP | PMAC_MB_OLD_CORE99
 	},
 	{	"PowerBook2,2",			"iBook FireWire",
 		PMAC_TYPE_FW_IBOOK,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_OLD_CORE99 | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER |
+		PMAC_MB_OLD_CORE99 | PMAC_MB_MOBILE
 	},
 	{	"PowerMac5,1",			"PowerMac G4 Cube",
 		PMAC_TYPE_CUBE,			core99_features,
-		PMAC_MB_OLD_CORE99
+		PMAC_MB_MAY_SLEEP | PMAC_MB_OLD_CORE99
 	},
 	{	"PowerMac3,4",			"PowerMac G4 Silver",
 		PMAC_TYPE_QUICKSILVER,		core99_features,
-		0
+		PMAC_MB_MAY_SLEEP
 	},
 	{	"PowerMac3,5",			"PowerMac G4 Silver",
 		PMAC_TYPE_QUICKSILVER,		core99_features,
-		0
+		PMAC_MB_MAY_SLEEP
 	},
 	{	"PowerBook3,1",			"PowerBook Pismo",
 		PMAC_TYPE_PISMO,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_OLD_CORE99 | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER |
+		PMAC_MB_OLD_CORE99 | PMAC_MB_MOBILE
 	},
 	{	"PowerBook3,2",			"PowerBook Titanium",
 		PMAC_TYPE_TITANIUM,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
 	},
 	{	"PowerBook3,3",			"PowerBook Titanium II",
 		PMAC_TYPE_TITANIUM2,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
 	},
 	{	"PowerBook3,4",			"PowerBook Titanium III",
 		PMAC_TYPE_TITANIUM3,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
 	},
 	{	"PowerBook3,5",			"PowerBook Titanium IV",
 		PMAC_TYPE_TITANIUM4,		core99_features,
-		PMAC_MB_CAN_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
 	},
 	{	"RackMac1,1",			"XServe",
 		PMAC_TYPE_RACKMAC,		rackmac_features,
@@ -2103,7 +2190,7 @@ static struct pmac_mb_def pmac_mb_defs[]
 	},
 	{	"PowerMac3,6",			"PowerMac G4 Windtunnel",
 		PMAC_TYPE_WINDTUNNEL,		core99_features,
-		0,
+		PMAC_MB_MAY_SLEEP,
 	},
 	{	"PowerBook5,1",			"PowerBook G4 17\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
@@ -2111,39 +2198,39 @@ static struct pmac_mb_def pmac_mb_defs[]
 	},
 	{	"PowerBook5,2",			"PowerBook G4 15\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook5,3",			"PowerBook G4 17\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook5,4",			"PowerBook G4 15\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook5,5",			"PowerBook G4 17\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook6,1",			"PowerBook G4 12\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook6,2",			"PowerBook G4",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook6,3",			"iBook G4",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook6,4",			"PowerBook G4 12\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 	{	"PowerBook6,5",			"iBook G4",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_MAY_SLEEP | PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
 #else /* CONFIG_POWER4 */
 	{	"PowerMac7,2",			"PowerMac G5",
@@ -2820,3 +2907,27 @@ void __init pmac_check_ht_link(void)
 }
 
 #endif /* CONFIG_POWER4 */
+
+/*
+ * Early video resume hook
+ */
+
+static void (*pmac_early_vresume_proc)(void *data) __pmacdata;
+static void *pmac_early_vresume_data __pmacdata;
+
+void pmac_set_early_video_resume(void (*proc)(void *data), void *data)
+{
+	if (_machine != _MACH_Pmac)
+		return;
+	preempt_disable();
+	pmac_early_vresume_proc = proc;
+	pmac_early_vresume_data = data;
+	preempt_enable();
+}
+EXPORT_SYMBOL(pmac_set_early_video_resume);
+
+void __pmac pmac_call_early_video_resume(void)
+{
+	if (pmac_early_vresume_proc)
+		pmac_early_vresume_proc(pmac_early_vresume_data);
+}
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_pci.c linux-2.6.11-rc3/arch/ppc/platforms/pmac_pci.c
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_pci.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/pmac_pci.c	2005-02-03 02:55:52.000000000 +0100
@@ -913,8 +913,12 @@ pmac_pci_enable_device_hook(struct pci_d
 	 * (iBook second controller)
 	 */
 	if (dev->vendor == PCI_VENDOR_ID_APPLE
-	    && dev->device == PCI_DEVICE_ID_APPLE_KL_USB && !node)
+	    && (dev->class == ((PCI_CLASS_SERIAL_USB << 8) | 0x10))
+	    && !node) {
+		printk(KERN_INFO "Apple USB OHCI %s disabled by firmware\n",
+		       pci_name(dev));
 		return -EINVAL;
+	}
 
 	if (!node)
 		return 0;
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_sleep.S linux-2.6.11-rc3/arch/ppc/platforms/pmac_sleep.S
--- linux-2.6.11-rc2-bk10/arch/ppc/platforms/pmac_sleep.S	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/platforms/pmac_sleep.S	2005-02-03 02:55:07.000000000 +0100
@@ -161,12 +161,8 @@ _GLOBAL(low_sleep_handler)
 	addi r3,r3,sleep_storage@l
 	stw r5,0(r3)
 
-	/* Disable DPM during cache flush */
-	mfspr	r3, SPRN_HID0
-	rlwinm	r3,r3,0,12,10
-	sync
-	mtspr	SPRN_HID0,r3
-	sync
+	/* Flush & disable all caches */
+	bl	flush_disable_caches
 
 	/* Turn off data relocation. */
 	mfmsr	r3		/* Save MSR in r7 */
@@ -175,8 +171,13 @@ _GLOBAL(low_sleep_handler)
 	mtmsr	r3
 	isync
 
-	/* Flush & disable L1 cache */
-	bl	__flush_disable_L1
+BEGIN_FTR_SECTION
+	/* Flush any pending L2 data prefetches to work around HW bug */
+	sync
+	lis	r3,0xfff0
+	lwz	r0,0(r3)	/* perform cache-inhibited load to ROM */
+	sync			/* (caches are disabled at this point) */
+END_FTR_SECTION_IFSET(CPU_FTR_SPEC7450)
 
 /*
  * Set the HID0 and MSR for sleep.
@@ -212,17 +213,16 @@ _GLOBAL(low_sleep_handler)
  * r4 has the physical address of SL_PC(sp) (unused)
  */
 _GLOBAL(core99_wake_up)
-	/* Make sure HID0 no longer contains any sleep bit */
+	/* Make sure HID0 no longer contains any sleep bit and that data cache
+	 * is disabled
+	 */
 	mfspr	r3,HID0
 	rlwinm	r3,r3,0,11,7		/* clear SLEEP, NAP, DOZE bits */
+	rlwinm	3,r3,0,18,15		/* clear DCE, ICE */
 	mtspr	HID0,r3
 	sync
 	isync
 
-	/* Won't that cause problems on CPU that doesn't support it ? */
-	lis	r3, 0
-	mtspr	SPRN_MMCR0, r3
-
 	/* sanitize MSR */
 	mfmsr	r3
 	ori	r3,r3,MSR_EE|MSR_IP
@@ -246,10 +246,6 @@ _GLOBAL(core99_wake_up)
  */
 
 grackle_wake_up:
-	/* Invalidate & enable L1 cache, we don't care about
-	 * whatever the ROM may have tried to write to memory
-	 */
-	bl	__inval_enable_L1
 
 	/* Restore the kernel's segment registers before
 	 * we do any r1 memory access as we are not sure they
@@ -271,6 +267,11 @@ grackle_wake_up:
 	/* Restore various CPU config stuffs */
 	bl	__restore_cpu_setup
 
+	/* Invalidate & enable L1 cache, we don't care about
+	 * whatever the ROM may have tried to write to memory
+	 */
+	bl	__inval_enable_L1
+
 	/* Restore the BATs, and SDR1.  Then we can turn on the MMU. */
 	lwz	r4,SL_SDR1(r1)
 	mtsdr1	r4
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/syslib/ibm44x_common.c linux-2.6.11-rc3/arch/ppc/syslib/ibm44x_common.c
--- linux-2.6.11-rc2-bk10/arch/ppc/syslib/ibm44x_common.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/syslib/ibm44x_common.c	2005-02-03 02:55:50.000000000 +0100
@@ -172,3 +172,16 @@ void __init ibm44x_platform_init(void)
 #endif
 }
 
+/* Called from MachineCheckException */
+void platform_machine_check(struct pt_regs *regs)
+{
+    	printk("PLB0: BEAR=0x%08x%08x ACR=  0x%08x BESR= 0x%08x\n",
+		mfdcr(DCRN_PLB0_BEARH), mfdcr(DCRN_PLB0_BEARL),
+		mfdcr(DCRN_PLB0_ACR),  mfdcr(DCRN_PLB0_BESR));
+	printk("POB0: BEAR=0x%08x%08x BESR0=0x%08x BESR1=0x%08x\n",
+		mfdcr(DCRN_POB0_BEARH), mfdcr(DCRN_POB0_BEARL),
+		mfdcr(DCRN_POB0_BESR0), mfdcr(DCRN_POB0_BESR1));
+	printk("OPB0: BEAR=0x%08x%08x BSTAT=0x%08x\n",
+		mfdcr(DCRN_OPB0_BEARH), mfdcr(DCRN_OPB0_BEARL),
+		mfdcr(DCRN_OPB0_BSTAT));
+}
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/syslib/mpc10x_common.c linux-2.6.11-rc3/arch/ppc/syslib/mpc10x_common.c
--- linux-2.6.11-rc2-bk10/arch/ppc/syslib/mpc10x_common.c	2005-01-22 02:47:29.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/syslib/mpc10x_common.c	2005-02-03 02:55:15.000000000 +0100
@@ -306,6 +306,41 @@ mpc10x_bridge_init(struct pci_controller
 	mpc10x_disable_store_gathering(hose);
 #endif
 
+	/*
+	 * 8240 erratum 26, 8241/8245 erratum 29, 107 erratum 23: speculative
+	 * PCI reads may return stale data so turn off.
+	 */
+	if ((host_bridge == MPC10X_BRIDGE_8240)
+		|| (host_bridge == MPC10X_BRIDGE_8245)
+		|| (host_bridge == MPC10X_BRIDGE_107)) {
+
+		early_read_config_dword(hose, 0, PCI_DEVFN(0,0),
+			MPC10X_CFG_PICR1_REG, &picr1);
+
+		picr1 &= ~MPC10X_CFG_PICR1_SPEC_PCI_RD;
+
+		early_write_config_dword(hose, 0, PCI_DEVFN(0,0),
+			MPC10X_CFG_PICR1_REG, picr1);
+	}
+
+	/*
+	 * 8241/8245 erratum 28: PCI reads from local memory may return
+	 * stale data.  Workaround by setting PICR2[0] to disable copyback
+	 * optimization.  Oddly, the latest available user manual for the
+	 * 8245 (Rev 2., dated 10/2003) says PICR2[0] is reserverd.
+	 */
+	if (host_bridge == MPC10X_BRIDGE_8245) {
+		ulong	picr2;
+
+		early_read_config_dword(hose, 0, PCI_DEVFN(0,0),
+			MPC10X_CFG_PICR2_REG, &picr2);
+
+		picr2 |= MPC10X_CFG_PICR2_COPYBACK_OPT;
+
+		early_write_config_dword(hose, 0, PCI_DEVFN(0,0),
+			 MPC10X_CFG_PICR2_REG, picr2);
+	}
+
 	if (ppc_md.progress) ppc_md.progress("mpc10x:exit", 0x100);
 	return 0;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/syslib/mv64360_pic.c linux-2.6.11-rc3/arch/ppc/syslib/mv64360_pic.c
--- linux-2.6.11-rc2-bk10/arch/ppc/syslib/mv64360_pic.c	2005-01-22 02:46:42.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/syslib/mv64360_pic.c	2005-02-03 02:54:38.000000000 +0100
@@ -369,7 +369,8 @@ mv64360_register_hdlrs(void)
 	u32	mask;
 	int	rc;
 
-	/* Register CPU interface error interrupt handler */
+	/* Clear old errors and register CPU interface error intr handler */
+	mv64x60_write(&bh, MV64x60_CPU_ERR_CAUSE, 0);
 	if ((rc = request_irq(MV64x60_IRQ_CPU_ERR,
 		mv64360_cpu_error_int_handler, SA_INTERRUPT, CPU_INTR_STR, 0)))
 		printk(KERN_WARNING "Can't register cpu error handler: %d", rc);
@@ -377,7 +378,8 @@ mv64360_register_hdlrs(void)
 	mv64x60_write(&bh, MV64x60_CPU_ERR_MASK, 0);
 	mv64x60_write(&bh, MV64x60_CPU_ERR_MASK, 0x000000ff);
 
-	/* Register internal SRAM error interrupt handler */
+	/* Clear old errors and register internal SRAM error intr handler */
+	mv64x60_write(&bh, MV64360_SRAM_ERR_CAUSE, 0);
 	if ((rc = request_irq(MV64360_IRQ_SRAM_PAR_ERR,
 		mv64360_sram_error_int_handler,SA_INTERRUPT,SRAM_INTR_STR, 0)))
 		printk(KERN_WARNING "Can't register SRAM error handler: %d",rc);
@@ -393,18 +395,20 @@ mv64360_register_hdlrs(void)
 		(mv64x60_get_bridge_rev() > 1))
 		mask |= 0x1;	/* enable DPErr on 64460 */
 
-	/* Register PCI 0 error interrupt handler */
+	/* Clear old errors and register PCI 0 error intr handler */
+	mv64x60_write(&bh, MV64x60_PCI0_ERR_CAUSE, 0);
 	if ((rc = request_irq(MV64360_IRQ_PCI0, mv64360_pci_error_int_handler,
-		    SA_INTERRUPT, PCI0_INTR_STR, (void *)0)))
+			SA_INTERRUPT, PCI0_INTR_STR, (void *)0)))
 		printk(KERN_WARNING "Can't register pci 0 error handler: %d",
 			rc);
 
 	mv64x60_write(&bh, MV64x60_PCI0_ERR_MASK, 0);
 	mv64x60_write(&bh, MV64x60_PCI0_ERR_MASK, mask);
 
-	/* Register PCI 1 error interrupt handler */
+	/* Clear old errors and register PCI 1 error intr handler */
+	mv64x60_write(&bh, MV64x60_PCI1_ERR_CAUSE, 0);
 	if ((rc = request_irq(MV64360_IRQ_PCI1, mv64360_pci_error_int_handler,
-		    SA_INTERRUPT, PCI1_INTR_STR, (void *)1)))
+			SA_INTERRUPT, PCI1_INTR_STR, (void *)1)))
 		printk(KERN_WARNING "Can't register pci 1 error handler: %d",
 			rc);
 
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/syslib/mv64x60.c linux-2.6.11-rc3/arch/ppc/syslib/mv64x60.c
--- linux-2.6.11-rc2-bk10/arch/ppc/syslib/mv64x60.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/syslib/mv64x60.c	2005-02-03 02:55:23.000000000 +0100
@@ -34,10 +34,10 @@
 u8		mv64x60_pci_exclude_bridge = 1;
 spinlock_t	mv64x60_lock; /* Only really used by PIC code once init done */
 
-static u32	mv64x60_bridge_pbase = 0;
-static u32	mv64x60_bridge_vbase = 0;
-static u32	mv64x60_bridge_type = MV64x60_TYPE_INVALID;
-static u32	mv64x60_bridge_rev = 0;
+static phys_addr_t 	mv64x60_bridge_pbase = 0;
+static void 		*mv64x60_bridge_vbase = 0;
+static u32		mv64x60_bridge_type = MV64x60_TYPE_INVALID;
+static u32		mv64x60_bridge_rev = 0;
 
 static u32 gt64260_translate_size(u32 base, u32 size, u32 num_bits);
 static u32 gt64260_untranslate_size(u32 base, u32 size, u32 num_bits);
@@ -88,7 +88,7 @@ static struct mv64x60_chip_info gt64260a
 	.translate_size		= gt64260_translate_size,
 	.untranslate_size	= gt64260_untranslate_size,
 	.set_pci2mem_window	= gt64260_set_pci2mem_window,
-	.set_pci2regs_window    = gt64260_set_pci2regs_window,
+	.set_pci2regs_window	= gt64260_set_pci2regs_window,
 	.is_enabled_32bit	= gt64260_is_enabled_32bit,
 	.enable_window_32bit	= gt64260_enable_window_32bit,
 	.disable_window_32bit	= gt64260_disable_window_32bit,
@@ -104,7 +104,7 @@ static struct mv64x60_chip_info gt64260b
 	.translate_size		= gt64260_translate_size,
 	.untranslate_size	= gt64260_untranslate_size,
 	.set_pci2mem_window	= gt64260_set_pci2mem_window,
-	.set_pci2regs_window    = gt64260_set_pci2regs_window,
+	.set_pci2regs_window	= gt64260_set_pci2regs_window,
 	.is_enabled_32bit	= gt64260_is_enabled_32bit,
 	.enable_window_32bit	= gt64260_enable_window_32bit,
 	.disable_window_32bit	= gt64260_disable_window_32bit,
@@ -120,7 +120,7 @@ static struct mv64x60_chip_info mv64360_
 	.translate_size		= mv64360_translate_size,
 	.untranslate_size	= mv64360_untranslate_size,
 	.set_pci2mem_window	= mv64360_set_pci2mem_window,
-	.set_pci2regs_window    = mv64360_set_pci2regs_window,
+	.set_pci2regs_window	= mv64360_set_pci2regs_window,
 	.is_enabled_32bit	= mv64360_is_enabled_32bit,
 	.enable_window_32bit	= mv64360_enable_window_32bit,
 	.disable_window_32bit	= mv64360_disable_window_32bit,
@@ -138,7 +138,7 @@ static struct mv64x60_chip_info mv64460_
 	.translate_size		= mv64360_translate_size,
 	.untranslate_size	= mv64360_untranslate_size,
 	.set_pci2mem_window	= mv64360_set_pci2mem_window,
-	.set_pci2regs_window    = mv64360_set_pci2regs_window,
+	.set_pci2regs_window	= mv64360_set_pci2regs_window,
 	.is_enabled_32bit	= mv64360_is_enabled_32bit,
 	.enable_window_32bit	= mv64360_enable_window_32bit,
 	.disable_window_32bit	= mv64360_disable_window_32bit,
@@ -160,7 +160,7 @@ static struct mv64x60_chip_info mv64460_
  *****************************************************************************
  */
 #ifdef CONFIG_SERIAL_MPSC
-static struct mpsc_shared_pd_dd mv64x60_mpsc_shared_pd_dd = {
+static struct mpsc_shared_pdata mv64x60_mpsc_shared_pdata = {
 	.mrr_val		= 0x3ffffe38,
 	.rcrr_val		= 0,
 	.tcrr_val		= 0,
@@ -192,11 +192,11 @@ static struct platform_device mpsc_share
 	.num_resources	= ARRAY_SIZE(mv64x60_mpsc_shared_resources),
 	.resource	= mv64x60_mpsc_shared_resources,
 	.dev = {
-		.driver_data = &mv64x60_mpsc_shared_pd_dd,
+		.platform_data = &mv64x60_mpsc_shared_pdata,
 	},
 };
 
-static struct mpsc_pd_dd mv64x60_mpsc0_pd_dd = {
+static struct mpsc_pdata mv64x60_mpsc0_pdata = {
 	.mirror_regs		= 0,
 	.cache_mgmt		= 0,
 	.max_idle		= 0,
@@ -248,11 +248,11 @@ static struct platform_device mpsc0_devi
 	.num_resources	= ARRAY_SIZE(mv64x60_mpsc0_resources),
 	.resource	= mv64x60_mpsc0_resources,
 	.dev = {
-		.driver_data = &mv64x60_mpsc0_pd_dd,
+		.platform_data = &mv64x60_mpsc0_pdata,
 	},
 };
 
-static struct mpsc_pd_dd mv64x60_mpsc1_pd_dd = {
+static struct mpsc_pdata mv64x60_mpsc1_pdata = {
 	.mirror_regs		= 0,
 	.cache_mgmt		= 0,
 	.max_idle		= 0,
@@ -305,7 +305,130 @@ static struct platform_device mpsc1_devi
 	.num_resources	= ARRAY_SIZE(mv64x60_mpsc1_resources),
 	.resource	= mv64x60_mpsc1_resources,
 	.dev = {
-		.driver_data = &mv64x60_mpsc1_pd_dd,
+		.platform_data = &mv64x60_mpsc1_pdata,
+	},
+};
+#endif
+
+#ifdef CONFIG_MV643XX_ETH
+static struct resource mv64x60_eth_shared_resources[] = {
+	[0] = {
+		.name	= "ethernet shared base",
+		.start	= MV64340_ETH_SHARED_REGS,
+		.end	= MV64340_ETH_SHARED_REGS +
+					MV64340_ETH_SHARED_REGS_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device mv64x60_eth_shared_device = {
+	.name		= MV64XXX_ETH_SHARED_NAME,
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(mv64x60_eth_shared_resources),
+	.resource	= mv64x60_eth_shared_resources,
+};
+
+#ifdef CONFIG_MV643XX_ETH_0
+static struct resource mv64x60_eth0_resources[] = {
+	[0] = {
+		.name	= "eth0 irq",
+		.start	= MV64x60_IRQ_ETH_0,
+		.end	= MV64x60_IRQ_ETH_0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv64xxx_eth_platform_data eth0_pd;
+
+static struct platform_device eth0_device = {
+	.name		= MV64XXX_ETH_NAME,
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(mv64x60_eth0_resources),
+	.resource	= mv64x60_eth0_resources,
+	.dev = {
+		.platform_data = &eth0_pd,
+	},
+};
+#endif
+
+#ifdef CONFIG_MV643XX_ETH_1
+static struct resource mv64x60_eth1_resources[] = {
+	[0] = {
+		.name	= "eth1 irq",
+		.start	= MV64x60_IRQ_ETH_1,
+		.end	= MV64x60_IRQ_ETH_1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv64xxx_eth_platform_data eth1_pd;
+
+static struct platform_device eth1_device = {
+	.name		= MV64XXX_ETH_NAME,
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(mv64x60_eth1_resources),
+	.resource	= mv64x60_eth1_resources,
+	.dev = {
+		.platform_data = &eth1_pd,
+	},
+};
+#endif
+
+#ifdef CONFIG_MV643XX_ETH_2
+static struct resource mv64x60_eth2_resources[] = {
+	[0] = {
+		.name	= "eth2 irq",
+		.start	= MV64x60_IRQ_ETH_2,
+		.end	= MV64x60_IRQ_ETH_2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv64xxx_eth_platform_data eth2_pd;
+
+static struct platform_device eth2_device = {
+	.name		= MV64XXX_ETH_NAME,
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(mv64x60_eth2_resources),
+	.resource	= mv64x60_eth2_resources,
+	.dev = {
+		.platform_data = &eth2_pd,
+	},
+};
+#endif
+#endif
+
+#ifdef	CONFIG_I2C_MV64XXX
+static struct mv64xxx_i2c_pdata mv64xxx_i2c_pdata = {
+	.freq_m			= 8,
+	.freq_n			= 3,
+	.timeout		= 1000, /* Default timeout of 1 second */
+	.retries		= 1,
+};
+
+static struct resource mv64xxx_i2c_resources[] = {
+	/* Do not change the order of the IORESOURCE_MEM resources */
+	[0] = {
+		.name	= "mv64xxx i2c base",
+		.start	= MV64XXX_I2C_OFFSET,
+		.end	= MV64XXX_I2C_OFFSET + MV64XXX_I2C_REG_BLOCK_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.name	= "mv64xxx i2c irq",
+		.start	= MV64x60_IRQ_I2C,
+		.end	= MV64x60_IRQ_I2C,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device i2c_device = {
+	.name		= MV64XXX_I2C_CTLR_NAME,
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(mv64xxx_i2c_resources),
+	.resource	= mv64xxx_i2c_resources,
+	.dev = {
+		.platform_data = &mv64xxx_i2c_pdata,
 	},
 };
 #endif
@@ -316,6 +439,21 @@ static struct platform_device *mv64x60_p
 	&mpsc0_device,
 	&mpsc1_device,
 #endif
+#ifdef CONFIG_MV643XX_ETH
+	&mv64x60_eth_shared_device,
+#endif
+#ifdef CONFIG_MV643XX_ETH_0
+	&eth0_device,
+#endif
+#ifdef CONFIG_MV643XX_ETH_1
+	&eth1_device,
+#endif
+#ifdef CONFIG_MV643XX_ETH_2
+	&eth2_device,
+#endif
+#ifdef	CONFIG_I2C_MV64XXX
+	&i2c_device,
+#endif
 };
 
 /*
@@ -344,7 +482,7 @@ mv64x60_init(struct mv64x60_handle *bh, 
 	mv64x60_early_init(bh, si);
 
 	if (mv64x60_get_type(bh) || mv64x60_setup_for_chip(bh)) {
-		iounmap((void *)bh->v_base);
+		iounmap(bh->v_base);
 		bh->v_base = 0;
 		if (ppc_md.progress)
 			ppc_md.progress("mv64x60_init: Can't determine chip",0);
@@ -416,7 +554,7 @@ mv64x60_early_init(struct mv64x60_handle
 	memset(bh, 0, sizeof(*bh));
 
 	bh->p_base = si->phys_reg_base;
-	bh->v_base = (u32)ioremap(bh->p_base, MV64x60_INTERNAL_SPACE_SIZE);
+	bh->v_base = ioremap(bh->p_base, MV64x60_INTERNAL_SPACE_SIZE);
 
 	mv64x60_bridge_pbase = bh->p_base;
 	mv64x60_bridge_vbase = bh->v_base;
@@ -598,7 +736,7 @@ mv64x60_get_64bit_window(struct mv64x60_
  */
 void __init
 mv64x60_set_64bit_window(struct mv64x60_handle *bh, u32 window,
-			u32 base_hi, u32 base_lo, u32 size, u32 other_bits)
+	u32 base_hi, u32 base_lo, u32 size, u32 other_bits)
 {
 	u32	val, base_lo_reg, size_reg, base_lo_bits, size_bits;
 	u32	(*map_to_field)(u32 val, u32 num_bits);
@@ -645,7 +783,7 @@ mv64x60_mask(u32 val, u32 num_bits)
 }
 
 /*
- * mv64x60_mask_shift_left()
+ * mv64x60_shift_left()
  *
  * Take the low-order 'num_bits' of 'val', shift left to align at bit 31 (MSB).
  */
@@ -702,7 +840,7 @@ mv64x60_get_type(struct mv64x60_handle *
 	/* Get the revision of the chip */
 	early_read_config_word(&hose, 0, PCI_DEVFN(0, 0), PCI_CLASS_REVISION,
 		&val);
-	bh->rev = (u32) (val & 0xff);
+	bh->rev = (u32)(val & 0xff);
 
 	/* Figure out the type of Marvell bridge it is */
 	early_read_config_word(&hose, 0, PCI_DEVFN(0, 0), PCI_DEVICE_ID, &val);
@@ -790,7 +928,7 @@ mv64x60_setup_for_chip(struct mv64x60_ha
  *
  * Return the virtual address of the bridge's registers.
  */
-u32
+void *
 mv64x60_get_bridge_vbase(void)
 {
 	return mv64x60_bridge_vbase;
@@ -836,13 +974,13 @@ u32 __init
 mv64x60_get_mem_size(u32 bridge_base, u32 chip_type)
 {
 	struct mv64x60_handle	bh;
-	u32			mem_windows[MV64x60_CPU2MEM_WINDOWS][2];
-	u32			rc = 0;
+	u32	mem_windows[MV64x60_CPU2MEM_WINDOWS][2];
+	u32	rc = 0;
 
 	memset(&bh, 0, sizeof(bh));
 
 	bh.type = chip_type;
-	bh.v_base = bridge_base;
+	bh.v_base = (void *)bridge_base;
 
 	if (!mv64x60_setup_for_chip(&bh)) {
 		mv64x60_get_mem_windows(&bh, mem_windows);
@@ -1117,7 +1255,7 @@ mv64x60_config_resources(struct pci_cont
 			IORESOURCE_IO, s[hose->index][0]);
 		hose->io_space.start = pi->pci_io.pci_base_lo;
 		hose->io_space.end = pi->pci_io.pci_base_lo + pi->pci_io.size-1;
-		hose->io_base_phys = (ulong)pi->pci_io.cpu_base;
+		hose->io_base_phys = pi->pci_io.cpu_base;
 		hose->io_base_virt = (void *)isa_io_base;
 	}
 
@@ -1592,8 +1730,8 @@ gt64260a_chip_specific_init(struct mv64x
 	struct resource	*r;
 #endif
 #if !defined(CONFIG_NOT_COHERENT_CACHE)
-	u32		val;
-	u8		save_exclude;
+	u32	val;
+	u8	save_exclude;
 #endif
 
 	if (si->pci_0.enable_bus)
@@ -1638,10 +1776,10 @@ gt64260a_chip_specific_init(struct mv64x
 	mv64x60_clr_bits(bh, 0xf2c0, (1<< 6) | (1<<14) | (1<<22) | (1<<30));
 
 #ifdef CONFIG_SERIAL_MPSC
-	mv64x60_mpsc0_pd_dd.mirror_regs = 1;
-	mv64x60_mpsc0_pd_dd.cache_mgmt = 1;
-	mv64x60_mpsc1_pd_dd.mirror_regs = 1;
-	mv64x60_mpsc1_pd_dd.cache_mgmt = 1;
+	mv64x60_mpsc0_pdata.mirror_regs = 1;
+	mv64x60_mpsc0_pdata.cache_mgmt = 1;
+	mv64x60_mpsc1_pdata.mirror_regs = 1;
+	mv64x60_mpsc1_pdata.cache_mgmt = 1;
 
 	if ((r = platform_get_resource(&mpsc1_device, IORESOURCE_IRQ, 0))
 		!= NULL) {
@@ -1667,8 +1805,8 @@ gt64260b_chip_specific_init(struct mv64x
 	struct resource	*r;
 #endif
 #if !defined(CONFIG_NOT_COHERENT_CACHE)
-	u32		val;
-	u8		save_exclude;
+	u32	val;
+	u8	save_exclude;
 #endif
 
 	if (si->pci_0.enable_bus)
@@ -1720,8 +1858,8 @@ gt64260b_chip_specific_init(struct mv64x
 	 * can't access cache coherent regions.  However, testing has shown
 	 * that the MPSC, at least, still has this bug.
 	 */
-	mv64x60_mpsc0_pd_dd.cache_mgmt = 1;
-	mv64x60_mpsc1_pd_dd.cache_mgmt = 1;
+	mv64x60_mpsc0_pdata.cache_mgmt = 1;
+	mv64x60_mpsc1_pdata.cache_mgmt = 1;
 
 	if ((r = platform_get_resource(&mpsc1_device, IORESOURCE_IRQ, 0))
 		!= NULL) {
@@ -2228,10 +2366,10 @@ mv64360_chip_specific_init(struct mv64x6
 	struct mv64x60_setup_info *si)
 {
 #ifdef CONFIG_SERIAL_MPSC
-	mv64x60_mpsc0_pd_dd.brg_can_tune = 1;
-	mv64x60_mpsc0_pd_dd.cache_mgmt = 1;
-	mv64x60_mpsc1_pd_dd.brg_can_tune = 1;
-	mv64x60_mpsc1_pd_dd.cache_mgmt = 1;
+	mv64x60_mpsc0_pdata.brg_can_tune = 1;
+	mv64x60_mpsc0_pdata.cache_mgmt = 1;
+	mv64x60_mpsc1_pdata.brg_can_tune = 1;
+	mv64x60_mpsc1_pdata.cache_mgmt = 1;
 #endif
 
 	return;
@@ -2247,8 +2385,8 @@ mv64460_chip_specific_init(struct mv64x6
 	struct mv64x60_setup_info *si)
 {
 #ifdef CONFIG_SERIAL_MPSC
-	mv64x60_mpsc0_pd_dd.brg_can_tune = 1;
-	mv64x60_mpsc1_pd_dd.brg_can_tune = 1;
+	mv64x60_mpsc0_pdata.brg_can_tune = 1;
+	mv64x60_mpsc1_pdata.brg_can_tune = 1;
 #endif
 	return;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/syslib/ppc4xx_setup.c linux-2.6.11-rc3/arch/ppc/syslib/ppc4xx_setup.c
--- linux-2.6.11-rc2-bk10/arch/ppc/syslib/ppc4xx_setup.c	2005-01-22 02:46:42.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/syslib/ppc4xx_setup.c	2005-02-03 02:54:38.000000000 +0100
@@ -303,3 +303,19 @@ ppc4xx_init(unsigned long r3, unsigned l
 	ppc_ide_md.ide_init_hwif = ppc4xx_ide_init_hwif_ports;
 #endif /* defined(CONFIG_PCI) && defined(CONFIG_IDE) */
 }
+
+/* Called from MachineCheckException */
+void platform_machine_check(struct pt_regs *regs)
+{
+#if defined(DCRN_PLB0_BEAR)
+	printk("PLB0: BEAR= 0x%08x ACR=   0x%08x BESR=  0x%08x\n",
+	    mfdcr(DCRN_PLB0_BEAR), mfdcr(DCRN_PLB0_ACR),
+	    mfdcr(DCRN_PLB0_BESR));
+#endif
+#if defined(DCRN_POB0_BEAR)
+	printk("PLB0 to OPB: BEAR= 0x%08x BESR0= 0x%08x BESR1= 0x%08x\n",
+	    mfdcr(DCRN_POB0_BEAR), mfdcr(DCRN_POB0_BESR0),
+	    mfdcr(DCRN_POB0_BESR1));
+#endif
+
+}
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/syslib/ppc85xx_setup.c linux-2.6.11-rc3/arch/ppc/syslib/ppc85xx_setup.c
--- linux-2.6.11-rc2-bk10/arch/ppc/syslib/ppc85xx_setup.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/syslib/ppc85xx_setup.c	2005-02-03 02:56:48.000000000 +0100
@@ -21,12 +21,14 @@
 #include <linux/serial.h>
 #include <linux/tty.h>	/* for linux/serial_core.h */
 #include <linux/serial_core.h>
+#include <linux/serial_8250.h>
 
 #include <asm/prom.h>
 #include <asm/time.h>
 #include <asm/mpc85xx.h>
 #include <asm/immap_85xx.h>
 #include <asm/mmu.h>
+#include <asm/ppc_sys.h>
 #include <asm/kgdb.h>
 
 #include <syslib/ppc85xx_setup.h>
@@ -72,40 +74,39 @@ mpc85xx_calibrate_decr(void)
 void __init
 mpc85xx_early_serial_map(void)
 {
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
 	struct uart_port serial_req;
+#endif
+	struct plat_serial8250_port *pdata;
 	bd_t *binfo = (bd_t *) __res;
-	phys_addr_t duart_paddr = binfo->bi_immr_base + MPC85xx_UART0_OFFSET;
+	pdata = (struct plat_serial8250_port *) ppc_sys_get_pdata(MPC85xx_DUART);
 
 	/* Setup serial port access */
+	pdata[0].uartclk = binfo->bi_busfreq;
+	pdata[0].mapbase += binfo->bi_immr_base;
+	pdata[0].membase = ioremap(pdata[0].mapbase, MPC85xx_UART0_SIZE);
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
 	memset(&serial_req, 0, sizeof (serial_req));
-	serial_req.uartclk = binfo->bi_busfreq;
-	serial_req.line = 0;
-	serial_req.irq = MPC85xx_IRQ_DUART;
-	serial_req.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
 	serial_req.iotype = SERIAL_IO_MEM;
-	serial_req.membase = ioremap(duart_paddr, MPC85xx_UART0_SIZE);
-	serial_req.mapbase = duart_paddr;
+	serial_req.mapbase = pdata[0].mapbase;
+	serial_req.membase = pdata[0].membase;
 	serial_req.regshift = 0;
 
-#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
 	gen550_init(0, &serial_req);
 #endif
 
-	if (early_serial_setup(&serial_req) != 0)
-		printk("Early serial init of port 0 failed\n");
-
-	/* Assume early_serial_setup() doesn't modify serial_req */
-	duart_paddr = binfo->bi_immr_base + MPC85xx_UART1_OFFSET;
-	serial_req.line = 1;
-	serial_req.mapbase = duart_paddr;
-	serial_req.membase = ioremap(duart_paddr, MPC85xx_UART1_SIZE);
+	pdata[1].uartclk = binfo->bi_busfreq;
+	pdata[1].mapbase += binfo->bi_immr_base;
+	pdata[1].membase = ioremap(pdata[1].mapbase, MPC85xx_UART0_SIZE);
 
 #if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
+	/* Assume gen550_init() doesn't modify serial_req */
+	serial_req.mapbase = pdata[1].mapbase;
+	serial_req.membase = pdata[1].membase;
+
 	gen550_init(1, &serial_req);
 #endif
-
-	if (early_serial_setup(&serial_req) != 0)
-		printk("Early serial init of port 1 failed\n");
 }
 #endif
 
diff -purN linux-2.6.11-rc2-bk10/arch/ppc/syslib/ppc85xx_setup.h linux-2.6.11-rc3/arch/ppc/syslib/ppc85xx_setup.h
--- linux-2.6.11-rc2-bk10/arch/ppc/syslib/ppc85xx_setup.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc/syslib/ppc85xx_setup.h	2005-02-03 02:56:11.000000000 +0100
@@ -43,9 +43,6 @@ extern void mpc85xx_setup_hose(void) __i
 #define PCIX_STATUS	0x64
 
 /* Serial Config */
-#define MPC85XX_0_SERIAL                (CCSRBAR + 0x4500)
-#define MPC85XX_1_SERIAL                (CCSRBAR + 0x4600)
-
 #ifdef CONFIG_SERIAL_MANY_PORTS
 #define RS_TABLE_SIZE  64
 #else
@@ -56,12 +53,6 @@ extern void mpc85xx_setup_hose(void) __i
 #define BASE_BAUD 115200
 #endif
 
-#define STD_UART_OP(num)					\
-	{ 0, BASE_BAUD, num, MPC85xx_IRQ_DUART,			\
-		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
-		iomem_base: (u8 *)MPC85XX_##num##_SERIAL,	\
-		io_type: SERIAL_IO_MEM},
-
 /* Offset of CPM register space */
 #define CPM_MAP_ADDR	(CCSRBAR + MPC85xx_CPM_OFFSET)
 
diff -purN linux-2.6.11-rc2-bk10/arch/ppc64/Kconfig.debug linux-2.6.11-rc3/arch/ppc64/Kconfig.debug
--- linux-2.6.11-rc2-bk10/arch/ppc64/Kconfig.debug	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc64/Kconfig.debug	2005-02-03 02:56:48.000000000 +0100
@@ -34,7 +34,7 @@ config DEBUGGER
 
 config XMON
 	bool "Include xmon kernel debugger"
-	depends on DEBUGGER
+	depends on DEBUGGER && !PPC_ISERIES
 	help
 	  Include in-kernel hooks for the xmon kernel monitor/debugger.
 	  Unless you are intending to debug the kernel, say N here.
diff -purN linux-2.6.11-rc2-bk10/arch/ppc64/kernel/pSeries_iommu.c linux-2.6.11-rc3/arch/ppc64/kernel/pSeries_iommu.c
--- linux-2.6.11-rc2-bk10/arch/ppc64/kernel/pSeries_iommu.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/arch/ppc64/kernel/pSeries_iommu.c	2005-02-03 02:55:15.000000000 +0100
@@ -309,6 +309,7 @@ static void iommu_table_setparms_lpar(st
 static void iommu_bus_setup_pSeries(struct pci_bus *bus)
 {
 	struct device_node *dn, *pdn;
+	struct iommu_table *tbl;
 
 	DBG("iommu_bus_setup_pSeries, bus %p, bus->self %p\n", bus, bus->self);
 
@@ -326,7 +327,6 @@ static void iommu_bus_setup_pSeries(stru
 	if (!bus->self) {
 		/* Root bus */
 		if (is_python(dn)) {
-			struct iommu_table *tbl;
 			unsigned int *iohole;
 
 			DBG("Python root bus %s\n", bus->name);
@@ -352,19 +352,35 @@ static void iommu_bus_setup_pSeries(stru
 			iommu_table_setparms(dn->phb, dn, tbl);
 			dn->iommu_table = iommu_init_table(tbl);
 		} else {
-			/* 256 MB window by default */
-			dn->phb->dma_window_size = 1 << 28;
-			/* always skip the first 256MB */
-			dn->phb->dma_window_base_cur = 1 << 28;
+			/* Do a 128MB table at root. This is used for the IDE
+			 * controller on some SMP-mode POWER4 machines. It
+			 * doesn't hurt to allocate it on other machines
+			 * -- it'll just be unused since new tables are
+			 * allocated on the EADS level.
+			 *
+			 * Allocate at offset 128MB to avoid having to deal
+			 * with ISA holes; 128MB table for IDE is plenty.
+			 */
+			dn->phb->dma_window_size = 1 << 27;
+			dn->phb->dma_window_base_cur = 1 << 27;
+
+			tbl = kmalloc(sizeof(struct iommu_table), GFP_KERNEL);
 
-			/* No table at PHB level for non-python PHBs */
+			iommu_table_setparms(dn->phb, dn, tbl);
+			dn->iommu_table = iommu_init_table(tbl);
+
+			/* All child buses have 256MB tables */
+			dn->phb->dma_window_size = 1 << 28;
 		}
 	} else {
 		pdn = pci_bus_to_OF_node(bus->parent);
 
-		if (!pdn->iommu_table) {
+		if (!bus->parent->self && !is_python(pdn)) {
 			struct iommu_table *tbl;
-			/* First child, allocate new table (256MB window) */
+			/* First child and not python means this is the EADS
+			 * level. Allocate new table for this slot with 256MB
+			 * window.
+			 */
 
 			tbl = kmalloc(sizeof(struct iommu_table), GFP_KERNEL);
 
@@ -372,7 +388,7 @@ static void iommu_bus_setup_pSeries(stru
 
 			dn->iommu_table = iommu_init_table(tbl);
 		} else {
-			/* Lower than first child or under python, copy parent table */
+			/* Lower than first child or under python, use parent table */
 			dn->iommu_table = pdn->iommu_table;
 		}
 	}
diff -purN linux-2.6.11-rc2-bk10/arch/s390/kernel/process.c linux-2.6.11-rc3/arch/s390/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/s390/kernel/process.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/s390/kernel/process.c	2005-02-03 02:56:33.000000000 +0100
@@ -215,8 +215,7 @@ void exit_thread(void)
 
 void flush_thread(void)
 {
-
-        current->used_math = 0;
+	clear_used_math();
 	clear_tsk_thread_flag(current, TIF_USEDFPU);
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/s390/kernel/setup.c linux-2.6.11-rc3/arch/s390/kernel/setup.c
--- linux-2.6.11-rc2-bk10/arch/s390/kernel/setup.c	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/s390/kernel/setup.c	2005-02-03 02:55:07.000000000 +0100
@@ -96,7 +96,7 @@ void __devinit cpu_init (void)
          * Force FPU initialization:
          */
         clear_thread_flag(TIF_USEDFPU);
-        current->used_math = 0;
+        clear_used_math();
 
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
diff -purN linux-2.6.11-rc2-bk10/arch/s390/mm/extmem.c linux-2.6.11-rc3/arch/s390/mm/extmem.c
--- linux-2.6.11-rc2-bk10/arch/s390/mm/extmem.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/s390/mm/extmem.c	2005-02-03 02:56:22.000000000 +0100
@@ -117,7 +117,7 @@ segment_by_name (char *name)
 	struct list_head *l;
 	struct dcss_segment *tmp, *retval = NULL;
 
-	BUG_ON (!spin_is_locked(&dcss_lock));
+	assert_spin_locked(&dcss_lock);
 	dcss_mkname (name, dcss_name);
 	list_for_each (l, &dcss_list) {
 		tmp = list_entry (l, struct dcss_segment, list);
@@ -271,7 +271,7 @@ segment_overlaps_others (struct dcss_seg
 	struct list_head *l;
 	struct dcss_segment *tmp;
 
-	BUG_ON (!spin_is_locked(&dcss_lock));
+	assert_spin_locked(&dcss_lock);
 	list_for_each(l, &dcss_list) {
 		tmp = list_entry(l, struct dcss_segment, list);
 		if ((tmp->start_addr >> 20) > (seg->end >> 20))
diff -purN linux-2.6.11-rc2-bk10/arch/sh/kernel/cpu/init.c linux-2.6.11-rc3/arch/sh/kernel/cpu/init.c
--- linux-2.6.11-rc2-bk10/arch/sh/kernel/cpu/init.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh/kernel/cpu/init.c	2005-02-03 02:57:04.000000000 +0100
@@ -194,7 +194,7 @@ asmlinkage void __init sh_cpu_init(void)
 	/* FPU initialization */
 	if ((cpu_data->flags & CPU_HAS_FPU)) {
 		clear_thread_flag(TIF_USEDFPU);
-		current->used_math = 0;
+		clear_used_math();
 	}
 
 #ifdef CONFIG_SH_DSP
diff -purN linux-2.6.11-rc2-bk10/arch/sh/kernel/cpu/sh4/fpu.c linux-2.6.11-rc3/arch/sh/kernel/cpu/sh4/fpu.c
--- linux-2.6.11-rc2-bk10/arch/sh/kernel/cpu/sh4/fpu.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh/kernel/cpu/sh4/fpu.c	2005-02-03 02:55:23.000000000 +0100
@@ -323,13 +323,13 @@ do_fpu_state_restore(unsigned long r4, u
 		return;
 	}
 
-	if (tsk->used_math) {
+	if (used_math()) {
 		/* Using the FPU again.  */
 		restore_fpu(tsk);
 	} else	{
 		/* First time FPU user.  */
 		fpu_init();
-		tsk->used_math = 1;
+		set_used_math();
 	}
 	set_tsk_thread_flag(tsk, TIF_USEDFPU);
 }
diff -purN linux-2.6.11-rc2-bk10/arch/sh/kernel/process.c linux-2.6.11-rc3/arch/sh/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/sh/kernel/process.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh/kernel/process.c	2005-02-03 02:56:22.000000000 +0100
@@ -208,7 +208,7 @@ void flush_thread(void)
 
 	/* Forget lazy FPU state */
 	clear_fpu(tsk, regs);
-	tsk->used_math = 0;
+	clear_used_math();
 #endif
 }
 
@@ -225,7 +225,7 @@ int dump_fpu(struct pt_regs *regs, elf_f
 #if defined(CONFIG_SH_FPU)
 	struct task_struct *tsk = current;
 
-	fpvalid = tsk->used_math;
+	fpvalid = !!tsk_used_math(tsk);
 	if (fpvalid) {
 		unlazy_fpu(tsk, regs);
 		memcpy(fpu, &tsk->thread.fpu.hard, sizeof(*fpu));
@@ -260,7 +260,7 @@ dump_task_fpu (struct task_struct *tsk, 
 	int fpvalid = 0;
 
 #if defined(CONFIG_SH_FPU)
-	fpvalid = tsk->used_math;
+	fpvalid = !!tsk_used_math(tsk);
 	if (fpvalid) {
 		struct pt_regs *regs = (struct pt_regs *)
 					((unsigned long)tsk->thread_info
@@ -286,7 +286,7 @@ int copy_thread(int nr, unsigned long cl
 
 	unlazy_fpu(tsk, regs);
 	p->thread.fpu = tsk->thread.fpu;
-	p->used_math = tsk->used_math;
+	copy_to_stopped_child_used_math(p);
 #endif
 
 	childregs = ((struct pt_regs *)
diff -purN linux-2.6.11-rc2-bk10/arch/sh/kernel/ptrace.c linux-2.6.11-rc3/arch/sh/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/sh/kernel/ptrace.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh/kernel/ptrace.c	2005-02-03 02:55:07.000000000 +0100
@@ -150,7 +150,7 @@ asmlinkage int sys_ptrace(long request, 
 			tmp = get_stack_long(child, addr);
 		else if (addr >= (long) &dummy->fpu &&
 			 addr < (long) &dummy->u_fpvalid) {
-			if (!child->used_math) {
+			if (!tsk_used_math(child)) {
 				if (addr == (long)&dummy->fpu.fpscr)
 					tmp = FPSCR_INIT;
 				else
@@ -159,7 +159,7 @@ asmlinkage int sys_ptrace(long request, 
 				tmp = ((long *)&child->thread.fpu)
 					[(addr - (long)&dummy->fpu) >> 2];
 		} else if (addr == (long) &dummy->u_fpvalid)
-			tmp = child->used_math;
+			tmp = !!tsk_used_math(child);
 		else
 			tmp = 0;
 		ret = put_user(tmp, (unsigned long *)data);
@@ -185,12 +185,12 @@ asmlinkage int sys_ptrace(long request, 
 			ret = put_stack_long(child, addr, data);
 		else if (addr >= (long) &dummy->fpu &&
 			 addr < (long) &dummy->u_fpvalid) {
-			child->used_math = 1;
+			set_stopped_child_used_math(child);
 			((long *)&child->thread.fpu)
 				[(addr - (long)&dummy->fpu) >> 2] = data;
 			ret = 0;
 		} else if (addr == (long) &dummy->u_fpvalid) {
-			child->used_math = data?1:0;
+			conditional_stopped_child_used_math(data, child);
 			ret = 0;
 		}
 		break;
diff -purN linux-2.6.11-rc2-bk10/arch/sh/kernel/signal.c linux-2.6.11-rc3/arch/sh/kernel/signal.c
--- linux-2.6.11-rc2-bk10/arch/sh/kernel/signal.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh/kernel/signal.c	2005-02-03 02:57:04.000000000 +0100
@@ -162,7 +162,7 @@ static inline int restore_sigcontext_fpu
 	if (!(cpu_data->flags & CPU_HAS_FPU))
 		return 0;
 
-	tsk->used_math = 1;
+	set_used_math();
 	return __copy_from_user(&tsk->thread.fpu.hard, &sc->sc_fpregs[0],
 				sizeof(long)*(16*2+2));
 }
@@ -175,7 +175,7 @@ static inline int save_sigcontext_fpu(st
 	if (!(cpu_data->flags & CPU_HAS_FPU))
 		return 0;
 
-	if (!tsk->used_math) {
+	if (!used_math()) {
 		__put_user(0, &sc->sc_ownedfp);
 		return 0;
 	}
@@ -185,7 +185,7 @@ static inline int save_sigcontext_fpu(st
 	/* This will cause a "finit" to be triggered by the next
 	   attempted FPU operation by the 'current' process.
 	   */
-	tsk->used_math = 0;
+	clear_used_math();
 
 	unlazy_fpu(tsk, regs);
 	return __copy_to_user(&sc->sc_fpregs[0], &tsk->thread.fpu.hard,
@@ -219,7 +219,7 @@ restore_sigcontext(struct pt_regs *regs,
 
 		regs->sr |= SR_FD; /* Release FPU */
 		clear_fpu(tsk, regs);
-		tsk->used_math = 0;
+		clear_used_math();
 		__get_user (owned_fp, &sc->sc_ownedfp);
 		if (owned_fp)
 			err |= restore_sigcontext_fpu(sc);
diff -purN linux-2.6.11-rc2-bk10/arch/sh/oprofile/op_model_sh7750.c linux-2.6.11-rc3/arch/sh/oprofile/op_model_sh7750.c
--- linux-2.6.11-rc2-bk10/arch/sh/oprofile/op_model_sh7750.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh/oprofile/op_model_sh7750.c	2005-02-03 02:57:04.000000000 +0100
@@ -112,14 +112,9 @@ static struct op_counter_config ctr[NR_C
  */
 
 static int sh7750_timer_notify(struct notifier_block *self,
-			       unsigned long val, void *data)
+			       unsigned long val, void *regs)
 {
-	struct pt_regs *regs = data;
-	unsigned long pc;
-
-	pc = instruction_pointer(regs);
-	oprofile_add_sample(pc, !user_mode(regs), 0, smp_processor_id());
-
+	oprofile_add_sample((struct pt_regs *)regs, 0);
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk10/arch/sh64/kernel/fpu.c linux-2.6.11-rc3/arch/sh64/kernel/fpu.c
--- linux-2.6.11-rc2-bk10/arch/sh64/kernel/fpu.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh64/kernel/fpu.c	2005-02-03 02:55:52.000000000 +0100
@@ -158,12 +158,12 @@ do_fpu_state_restore(unsigned long ex, s
 		fpsave(&last_task_used_math->thread.fpu.hard);
         }
         last_task_used_math = current;
-        if (current->used_math) {
+        if (used_math()) {
                 fpload(&current->thread.fpu.hard);
         } else {
 		/* First time FPU user.  */
 		fpload(&init_fpuregs.hard);
-                current->used_math = 1;
+                set_used_math();
         }
 	release_fpu();
 }
diff -purN linux-2.6.11-rc2-bk10/arch/sh64/kernel/process.c linux-2.6.11-rc3/arch/sh64/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/sh64/kernel/process.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh64/kernel/process.c	2005-02-03 02:57:04.000000000 +0100
@@ -688,7 +688,7 @@ void flush_thread(void)
 		last_task_used_math = NULL;
 	}
 	/* Force FPU state to be reinitialised after exec */
-	current->used_math = 0;
+	clear_used_math();
 #endif
 
 	/* if we are a kernel thread, about to change to user thread,
@@ -713,7 +713,7 @@ int dump_fpu(struct pt_regs *regs, elf_f
 	int fpvalid;
 	struct task_struct *tsk = current;
 
-	fpvalid = tsk->used_math;
+	fpvalid = !!tsk_used_math(tsk);
 	if (fpvalid) {
 		if (current == last_task_used_math) {
 			grab_fpu();
diff -purN linux-2.6.11-rc2-bk10/arch/sh64/kernel/ptrace.c linux-2.6.11-rc3/arch/sh64/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/sh64/kernel/ptrace.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh64/kernel/ptrace.c	2005-02-03 02:57:16.000000000 +0100
@@ -63,7 +63,7 @@ get_fpu_long(struct task_struct *task, u
 	struct pt_regs *regs;
 	regs = (struct pt_regs*)((unsigned char *)task + THREAD_SIZE) - 1;
 
-	if (!task->used_math) {
+	if (!tsk_used_math(task)) {
 		if (addr == offsetof(struct user_fpu_struct, fpscr)) {
 			tmp = FPSCR_INIT;
 		} else {
@@ -105,9 +105,9 @@ put_fpu_long(struct task_struct *task, u
 
 	regs = (struct pt_regs*)((unsigned char *)task + THREAD_SIZE) - 1;
 
-	if (!task->used_math) {
+	if (!tsk_used_math(task)) {
 		fpinit(&task->thread.fpu.hard);
-		task->used_math = 1;
+		set_stopped_child_used_math(task);
 	} else if (last_task_used_math == task) {
 		grab_fpu();
 		fpsave(&task->thread.fpu.hard);
@@ -187,7 +187,7 @@ asmlinkage int sys_ptrace(long request, 
 			 (addr <  offsetof(struct user, u_fpvalid))) {
 			tmp = get_fpu_long(child, addr - offsetof(struct user, fpu));
 		} else if (addr == offsetof(struct user, u_fpvalid)) {
-			tmp = child->used_math;
+			tmp = !!tsk_used_math(child);
 		} else {
 			break;
 		}
diff -purN linux-2.6.11-rc2-bk10/arch/sh64/kernel/signal.c linux-2.6.11-rc3/arch/sh64/kernel/signal.c
--- linux-2.6.11-rc2-bk10/arch/sh64/kernel/signal.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/sh64/kernel/signal.c	2005-02-03 02:55:52.000000000 +0100
@@ -186,7 +186,7 @@ restore_sigcontext_fpu(struct pt_regs *r
 	int fpvalid;
 
 	err |= __get_user (fpvalid, &sc->sc_fpvalid);
-	current->used_math = fpvalid;
+	conditional_used_math(fpvalid);
 	if (! fpvalid)
 		return err;
 
@@ -207,7 +207,7 @@ setup_sigcontext_fpu(struct pt_regs *reg
 	int err = 0;
 	int fpvalid;
 
-	fpvalid = current->used_math;
+	fpvalid = !!used_math();
 	err |= __put_user(fpvalid, &sc->sc_fpvalid);
 	if (! fpvalid)
 		return err;
@@ -222,7 +222,7 @@ setup_sigcontext_fpu(struct pt_regs *reg
 
 	err |= __copy_to_user(&sc->sc_fpregs[0], &current->thread.fpu.hard,
 			      (sizeof(long long) * 32) + (sizeof(int) * 1));
-	current->used_math = 0;
+	clear_used_math();
 
 	return err;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/sparc/kernel/process.c linux-2.6.11-rc3/arch/sparc/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/sparc/kernel/process.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc/kernel/process.c	2005-02-03 02:55:14.000000000 +0100
@@ -599,7 +599,7 @@ void dump_thread(struct pt_regs * regs, 
  */
 int dump_fpu (struct pt_regs * regs, elf_fpregset_t * fpregs)
 {
-	if (current->used_math == 0) {
+	if (used_math()) {
 		memset(fpregs, 0, sizeof(*fpregs));
 		fpregs->pr_q_entrysize = 8;
 		return 1;
diff -purN linux-2.6.11-rc2-bk10/arch/sparc/kernel/signal.c linux-2.6.11-rc3/arch/sparc/kernel/signal.c
--- linux-2.6.11-rc2-bk10/arch/sparc/kernel/signal.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc/kernel/signal.c	2005-02-03 02:56:22.000000000 +0100
@@ -202,7 +202,7 @@ restore_fpu_state(struct pt_regs *regs, 
 		regs->psr &= ~PSR_EF;
 	}
 #endif
-	current->used_math = 1;
+	set_used_math();
 	clear_tsk_thread_flag(current, TIF_USEDFPU);
 
 	if (verify_area(VERIFY_READ, fpu, sizeof(*fpu)))
@@ -584,7 +584,7 @@ save_fpu_state(struct pt_regs *regs, __s
 				      &current->thread.fpqueue[0],
 				      ((sizeof(unsigned long) +
 				      (sizeof(unsigned long *)))*16));
-	current->used_math = 0;
+	clear_used_math();
 	return err;
 }
 
@@ -599,7 +599,7 @@ new_setup_frame(struct k_sigaction *ka, 
 	synchronize_user_stack();
 
 	sigframe_size = NF_ALIGNEDSZ;
-	if (!current->used_math)
+	if (!used_math())
 		sigframe_size -= sizeof(__siginfo_fpu_t);
 
 	sf = (struct new_signal_frame __user *)
@@ -616,7 +616,7 @@ new_setup_frame(struct k_sigaction *ka, 
 	
 	err |= __put_user(0, &sf->extra_size);
 
-	if (current->used_math) {
+	if (used_math()) {
 		err |= save_fpu_state(regs, &sf->fpu_state);
 		err |= __put_user(&sf->fpu_state, &sf->fpu_save);
 	} else {
@@ -677,7 +677,7 @@ new_setup_rt_frame(struct k_sigaction *k
 
 	synchronize_user_stack();
 	sigframe_size = RT_ALIGNEDSZ;
-	if (!current->used_math)
+	if (!used_math())
 		sigframe_size -= sizeof(__siginfo_fpu_t);
 	sf = (struct rt_signal_frame __user *)
 		get_sigframe(&ka->sa, regs, sigframe_size);
@@ -690,7 +690,7 @@ new_setup_rt_frame(struct k_sigaction *k
 	err |= __put_user(regs->npc, &sf->regs.npc);
 	err |= __put_user(regs->y, &sf->regs.y);
 	psr = regs->psr;
-	if (current->used_math)
+	if (used_math())
 		psr |= PSR_EF;
 	err |= __put_user(psr, &sf->regs.psr);
 	err |= __copy_to_user(&sf->regs.u_regs, regs->u_regs, sizeof(regs->u_regs));
diff -purN linux-2.6.11-rc2-bk10/arch/sparc/kernel/traps.c linux-2.6.11-rc3/arch/sparc/kernel/traps.c
--- linux-2.6.11-rc2-bk10/arch/sparc/kernel/traps.c	2005-01-22 02:48:14.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc/kernel/traps.c	2005-02-03 02:55:52.000000000 +0100
@@ -246,17 +246,17 @@ void do_fpd_trap(struct pt_regs *regs, u
 		       &fptask->thread.fpqueue[0], &fptask->thread.fpqdepth);
 	}
 	last_task_used_math = current;
-	if(current->used_math) {
+	if(used_math()) {
 		fpload(&current->thread.float_regs[0], &current->thread.fsr);
 	} else {
 		/* Set initial sane state. */
 		fpload(&init_fregs[0], &init_fsr);
-		current->used_math = 1;
+		set_used_math();
 	}
 #else
-	if(!current->used_math) {
+	if(!used_math()) {
 		fpload(&init_fregs[0], &init_fsr);
-		current->used_math = 1;
+		set_used_math();
 	} else {
 		fpload(&current->thread.float_regs[0], &current->thread.fsr);
 	}
diff -purN linux-2.6.11-rc2-bk10/arch/sparc/mm/srmmu.c linux-2.6.11-rc3/arch/sparc/mm/srmmu.c
--- linux-2.6.11-rc2-bk10/arch/sparc/mm/srmmu.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc/mm/srmmu.c	2005-02-03 02:55:53.000000000 +0100
@@ -2197,6 +2197,7 @@ void __init ld_mmu_srmmu(void)
 	BTFIXUPSET_CALL(free_pgd_fast, srmmu_free_pgd_fast, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(get_pgd_fast, srmmu_get_pgd_fast, BTFIXUPCALL_NORM);
 
+	BTFIXUPSET_HALF(pte_readi, SRMMU_NOREAD);
 	BTFIXUPSET_HALF(pte_writei, SRMMU_WRITE);
 	BTFIXUPSET_HALF(pte_dirtyi, SRMMU_DIRTY);
 	BTFIXUPSET_HALF(pte_youngi, SRMMU_REF);
diff -purN linux-2.6.11-rc2-bk10/arch/sparc/mm/sun4c.c linux-2.6.11-rc3/arch/sparc/mm/sun4c.c
--- linux-2.6.11-rc2-bk10/arch/sparc/mm/sun4c.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc/mm/sun4c.c	2005-02-03 02:56:33.000000000 +0100
@@ -2225,6 +2225,7 @@ void __init ld_mmu_sun4c(void)
 	BTFIXUPSET_CALL(free_pgd_fast, sun4c_free_pgd_fast, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(get_pgd_fast, sun4c_get_pgd_fast, BTFIXUPCALL_NORM);
 
+	BTFIXUPSET_HALF(pte_readi, _SUN4C_PAGE_READ);
 	BTFIXUPSET_HALF(pte_writei, _SUN4C_PAGE_WRITE);
 	BTFIXUPSET_HALF(pte_dirtyi, _SUN4C_PAGE_MODIFIED);
 	BTFIXUPSET_HALF(pte_youngi, _SUN4C_PAGE_ACCESSED);
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/kernel/process.c linux-2.6.11-rc3/arch/sparc64/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/kernel/process.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/kernel/process.c	2005-02-03 02:55:50.000000000 +0100
@@ -167,7 +167,7 @@ static void show_regwindow32(struct pt_r
 	mm_segment_t old_fs;
 	
 	__asm__ __volatile__ ("flushw");
-	rw = (struct reg_window32 __user *)((long)(unsigned)regs->u_regs[14]);
+	rw = compat_ptr((unsigned)regs->u_regs[14]);
 	old_fs = get_fs();
 	set_fs (USER_DS);
 	if (copy_from_user (&r_w, rw, sizeof(r_w))) {
@@ -434,14 +434,13 @@ void flush_thread(void)
 		if (test_thread_flag(TIF_32BIT)) {
 			struct mm_struct *mm = t->task->mm;
 			pgd_t *pgd0 = &mm->pgd[0];
+			pud_t *pud0 = pud_offset(pgd0, 0);
 
-			if (pgd_none(*pgd0)) {
-				pmd_t *page = pmd_alloc_one_fast(NULL, 0);
-				if (!page)
-					page = pmd_alloc_one(NULL, 0);
-				pgd_set(pgd0, page);
+			if (pud_none(*pud0)) {
+				pmd_t *page = pmd_alloc_one(mm, 0);
+				pud_set(pud0, page);
 			}
-			pgd_cache = ((unsigned long) pgd_val(*pgd0)) << 11UL;
+			pgd_cache = ((unsigned long) pud_val(*pud0)) << 11UL;
 		}
 		__asm__ __volatile__("stxa %0, [%1] %2\n\t"
 				     "membar #Sync"
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/kernel/setup.c linux-2.6.11-rc3/arch/sparc64/kernel/setup.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/kernel/setup.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/kernel/setup.c	2005-02-03 02:55:36.000000000 +0100
@@ -151,6 +151,7 @@ int prom_callback(long *args)
 			struct task_struct *p;
 			struct mm_struct *mm = NULL;
 			pgd_t *pgdp;
+			pud_t *pudp;
 			pmd_t *pmdp;
 			pte_t *ptep;
 
@@ -166,7 +167,10 @@ int prom_callback(long *args)
 			pgdp = pgd_offset(mm, va);
 			if (pgd_none(*pgdp))
 				goto done;
-			pmdp = pmd_offset(pgdp, va);
+			pudp = pud_offset(pgdp, va);
+			if (pud_none(*pudp))
+				goto done;
+			pmdp = pmd_offset(pudp, va);
 			if (pmd_none(*pmdp))
 				goto done;
 
@@ -208,6 +212,7 @@ int prom_callback(long *args)
 			 * vmalloc or prom_inherited mapping.
 			 */
 			pgd_t *pgdp;
+			pud_t *pudp;
 			pmd_t *pmdp;
 			pte_t *ptep;
 			int error;
@@ -221,7 +226,10 @@ int prom_callback(long *args)
 			pgdp = pgd_offset_k(va);
 			if (pgd_none(*pgdp))
 				goto done;
-			pmdp = pmd_offset(pgdp, va);
+			pudp = pud_offset(pgdp, va);
+			if (pud_none(*pudp))
+				goto done;
+			pmdp = pmd_offset(pudp, va);
 			if (pmd_none(*pmdp))
 				goto done;
 
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/kernel/signal32.c linux-2.6.11-rc3/arch/sparc64/kernel/signal32.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/kernel/signal32.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/kernel/signal32.c	2005-02-03 02:57:04.000000000 +0100
@@ -194,7 +194,7 @@ int copy_siginfo_to_user32(compat_siginf
 		case __SI_FAULT >> 16:
 		case __SI_POLL >> 16:
 			err |= __put_user(from->si_trapno, &to->si_trapno);
-			err |= __put_user((long)from->si_addr, &to->si_addr);
+			err |= __put_user((unsigned long)from->si_addr, &to->si_addr);
 			break;
 		case __SI_RT >> 16: /* This is not generated by the kernel as of now.  */
 		case __SI_MESGQ >> 16:
@@ -275,7 +275,7 @@ asmlinkage void do_rt_sigsuspend32(u32 u
 		regs->u_regs[UREG_I0] = EINVAL;
 		return;
 	}
-	if (copy_from_user(&set32, (void __user *)(long)uset, sizeof(set32))) {
+	if (copy_from_user(&set32, compat_ptr(uset), sizeof(set32))) {
 		regs->tstate |= TSTATE_ICARRY;
 		regs->u_regs[UREG_I0] = EFAULT;
 		return;
@@ -720,9 +720,9 @@ setup_frame32(struct sigaction *sa, stru
 			sig_address = NULL;
 		}
 	}
-	err |= __put_user((long)sig_address, &sframep->sig_address);
+	err |= __put_user(ptr_to_compat(sig_address), &sframep->sig_address);
 	err |= __put_user(sig_code, &sframep->sig_code);
-	err |= __put_user((u64)sc, &sframep->sig_scptr);
+	err |= __put_user(ptr_to_compat(sc), &sframep->sig_scptr);
 	if (err)
 		goto sigsegv;
 
@@ -857,7 +857,8 @@ static void new_setup_frame32(struct k_s
 		/* Flush instruction space. */
 		unsigned long address = ((unsigned long)&(sf->insns[0]));
 		pgd_t *pgdp = pgd_offset(current->mm, address);
-		pmd_t *pmdp = pmd_offset(pgdp, address);
+		pud_t *pudp = pud_offset(pgdp, address);
+		pmd_t *pmdp = pmd_offset(pudp, address);
 		pte_t *ptep;
 
 		regs->u_regs[UREG_I7] = (unsigned long) (&(sf->insns[0]) - 2);
@@ -967,7 +968,7 @@ setup_svr4_frame32(struct sigaction *sa,
 	/* Save the currently window file: */
 
 	/* 1. Link sfp->uc->gwins to our windows */
-	err |= __put_user((u32)(long)gw, &mc->gwin);
+	err |= __put_user(ptr_to_compat(gw), &mc->gwin);
 	    
 	/* 2. Number of windows to restore at setcontext (): */
 	err |= __put_user(get_thread_wsaved(), &gw->count);
@@ -1268,7 +1269,8 @@ static void setup_rt_frame32(struct k_si
 		/* Flush instruction space. */
 		unsigned long address = ((unsigned long)&(sf->insns[0]));
 		pgd_t *pgdp = pgd_offset(current->mm, address);
-		pmd_t *pmdp = pmd_offset(pgdp, address);
+		pud_t *pudp = pud_offset(pgdp, address);
+		pmd_t *pmdp = pmd_offset(pudp, address);
 		pte_t *ptep;
 
 		regs->u_regs[UREG_I7] = (unsigned long) (&(sf->insns[0]) - 2);
@@ -1446,10 +1448,12 @@ asmlinkage long do_sys32_sigaltstack(u32
 	u32 u_ss_sp = 0;
 	int ret;
 	mm_segment_t old_fs;
+	stack_t32 __user *uss32 = compat_ptr(ussa);
+	stack_t32 __user *uoss32 = compat_ptr(uossa);
 	
-	if (ussa && (get_user(u_ss_sp, &((stack_t32 __user *)(long)ussa)->ss_sp) ||
-		    __get_user(uss.ss_flags, &((stack_t32 __user *)(long)ussa)->ss_flags) ||
-		    __get_user(uss.ss_size, &((stack_t32 __user *)(long)ussa)->ss_size)))
+	if (ussa && (get_user(u_ss_sp, &uss32->ss_sp) ||
+		    __get_user(uss.ss_flags, &uss32->ss_flags) ||
+		    __get_user(uss.ss_size, &uss32->ss_size)))
 		return -EFAULT;
 	uss.ss_sp = compat_ptr(u_ss_sp);
 	old_fs = get_fs();
@@ -1457,9 +1461,9 @@ asmlinkage long do_sys32_sigaltstack(u32
 	ret = do_sigaltstack(ussa ? (stack_t __user *) &uss : NULL,
 			     uossa ? (stack_t __user *) &uoss : NULL, sp);
 	set_fs(old_fs);
-	if (!ret && uossa && (put_user((long)uoss.ss_sp, &((stack_t32 __user *)(long)uossa)->ss_sp) ||
-		    __put_user(uoss.ss_flags, &((stack_t32 __user *)(long)uossa)->ss_flags) ||
-		    __put_user(uoss.ss_size, &((stack_t32 __user *)(long)uossa)->ss_size)))
+	if (!ret && uossa && (put_user(ptr_to_compat(uoss.ss_sp), &uoss32->ss_sp) ||
+		    __put_user(uoss.ss_flags, &uoss32->ss_flags) ||
+		    __put_user(uoss.ss_size, &uoss32->ss_size)))
 		return -EFAULT;
 	return ret;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/kernel/sparc64_ksyms.c linux-2.6.11-rc3/arch/sparc64/kernel/sparc64_ksyms.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/kernel/sparc64_ksyms.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/kernel/sparc64_ksyms.c	2005-02-03 02:56:33.000000000 +0100
@@ -86,7 +86,7 @@ extern int svr4_getcontext(svr4_ucontext
 extern int svr4_setcontext(svr4_ucontext_t *uc, struct pt_regs *regs);
 extern int compat_sys_ioctl(unsigned int fd, unsigned int cmd, u32 arg);
 extern int (*handle_mathemu)(struct pt_regs *, struct fpustate *);
-extern long sparc32_open(const char * filename, int flags, int mode);
+extern long sparc32_open(const char __user * filename, int flags, int mode);
 extern int io_remap_page_range(struct vm_area_struct *vma, unsigned long from, unsigned long offset, unsigned long size, pgprot_t prot, int space);
 extern void (*prom_palette)(int);
 
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/kernel/sys_sparc32.c linux-2.6.11-rc3/arch/sparc64/kernel/sys_sparc32.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/kernel/sys_sparc32.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/kernel/sys_sparc32.c	2005-02-03 02:56:11.000000000 +0100
@@ -1090,8 +1090,8 @@ asmlinkage long compat_sys_sigaction(int
         ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
 
 	if (!ret && oact) {
-		ret = put_user((long)old_ka.sa.sa_handler, &oact->sa_handler);
-		ret |= __put_user((long)old_ka.sa.sa_restorer, &oact->sa_restorer);
+		ret = put_user(ptr_to_compat(old_ka.sa.sa_handler), &oact->sa_handler);
+		ret |= __put_user(ptr_to_compat(old_ka.sa.sa_restorer), &oact->sa_restorer);
 		ret |= __put_user(old_ka.sa.sa_flags, &oact->sa_flags);
 		ret |= __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
         }
@@ -1147,10 +1147,10 @@ asmlinkage long compat_sys_rt_sigaction(
 		case 2: set32.sig[3] = (old_ka.sa.sa_mask.sig[1] >> 32); set32.sig[2] = old_ka.sa.sa_mask.sig[1];
 		case 1: set32.sig[1] = (old_ka.sa.sa_mask.sig[0] >> 32); set32.sig[0] = old_ka.sa.sa_mask.sig[0];
 		}
-		ret = put_user((long)old_ka.sa.sa_handler, &oact->sa_handler);
+		ret = put_user(ptr_to_compat(old_ka.sa.sa_handler), &oact->sa_handler);
 		ret |= __copy_to_user(&oact->sa_mask, &set32, sizeof(compat_sigset_t));
 		ret |= __put_user(old_ka.sa.sa_flags, &oact->sa_flags);
-		ret |= __put_user((long)old_ka.sa.sa_restorer, &oact->sa_restorer);
+		ret |= __put_user(ptr_to_compat(old_ka.sa.sa_restorer), &oact->sa_restorer);
 		if (ret)
 			ret = -EFAULT;
         }
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/kernel/sys_sunos32.c linux-2.6.11-rc3/arch/sparc64/kernel/sys_sunos32.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/kernel/sys_sunos32.c	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/kernel/sys_sunos32.c	2005-02-03 02:56:10.000000000 +0100
@@ -1177,11 +1177,11 @@ asmlinkage int sunos_shmsys(int op, u32 
 	return rval;
 }
 
-extern asmlinkage long sparc32_open(const char * filename, int flags, int mode);
+extern asmlinkage long sparc32_open(const char __user * filename, int flags, int mode);
 
 asmlinkage int sunos_open(u32 fname, int flags, int mode)
 {
-	const char *filename = (const char *)(long)fname;
+	const char __user *filename = compat_ptr(fname);
 
 	return sparc32_open(filename, flags, mode);
 }
@@ -1294,7 +1294,7 @@ asmlinkage int sunos_sigaction (int sig,
 
 	if (!ret && oact) {
 		old_ka.sa.sa_flags ^= SUNOS_SV_INTERRUPT;
-		if (put_user((long)old_ka.sa.sa_handler, &oact->sa_handler) ||
+		if (put_user(ptr_to_compat(old_ka.sa.sa_handler), &oact->sa_handler) ||
 		    __put_user(old_ka.sa.sa_flags, &oact->sa_flags))
 			return -EFAULT;
 		__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/lib/atomic.S linux-2.6.11-rc3/arch/sparc64/lib/atomic.S
--- linux-2.6.11-rc2-bk10/arch/sparc64/lib/atomic.S	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/lib/atomic.S	2005-02-03 02:56:48.000000000 +0100
@@ -7,8 +7,22 @@
 #include <asm/asi.h>
 
 	.text
-	.align	64
 
+	/* We use these stubs for the uncommon case
+	 * of contention on the atomic value.  This is
+	 * so that we can keep the main fast path 8
+	 * instructions long and thus fit into a single
+	 * L2 cache line.
+	 */
+__atomic_add_membar:
+	ba,pt	%xcc, __atomic_add
+	 membar	#StoreLoad | #StoreStore
+
+__atomic_sub_membar:
+	ba,pt	%xcc, __atomic_sub
+	 membar	#StoreLoad | #StoreStore
+
+	.align	64
 	.globl	__atomic_add
 	.type	__atomic_add,#function
 __atomic_add: /* %o0 = increment, %o1 = atomic_ptr */
@@ -16,10 +30,10 @@ __atomic_add: /* %o0 = increment, %o1 = 
 	add	%g5, %o0, %g7
 	cas	[%o1], %g5, %g7
 	cmp	%g5, %g7
-	bne,pn	%icc, __atomic_add
-	 membar	#StoreLoad | #StoreStore
+	bne,pn	%icc, __atomic_add_membar
+	 add	%g7, %o0, %g7
 	retl
-	 add	%g7, %o0, %o0
+	 sra	%g7, 0, %o0
 	.size	__atomic_add, .-__atomic_add
 
 	.globl	__atomic_sub
@@ -29,10 +43,10 @@ __atomic_sub: /* %o0 = increment, %o1 = 
 	sub	%g5, %o0, %g7
 	cas	[%o1], %g5, %g7
 	cmp	%g5, %g7
-	bne,pn	%icc, __atomic_sub
-	 membar	#StoreLoad | #StoreStore
+	bne,pn	%icc, __atomic_sub_membar
+	 sub	%g7, %o0, %g7
 	retl
-	 sub	%g7, %o0, %o0
+	 sra	%g7, 0, %o0
 	.size	__atomic_sub, .-__atomic_sub
 
 	.globl	__atomic64_add
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/mm/fault.c linux-2.6.11-rc3/arch/sparc64/mm/fault.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/mm/fault.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/mm/fault.c	2005-02-03 02:56:53.000000000 +0100
@@ -175,6 +175,7 @@ static void bad_kernel_pc(struct pt_regs
 static unsigned int get_user_insn(unsigned long tpc)
 {
 	pgd_t *pgdp = pgd_offset(current->mm, tpc);
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep, pte;
 	unsigned long pa;
@@ -183,7 +184,10 @@ static unsigned int get_user_insn(unsign
 
 	if (pgd_none(*pgdp))
 		goto outret;
-	pmdp = pmd_offset(pgdp, tpc);
+	pudp = pud_offset(pgdp, tpc);
+	if (pud_none(*pudp))
+		goto outret;
+	pmdp = pmd_offset(pudp, tpc);
 	if (pmd_none(*pmdp))
 		goto outret;
 
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/mm/generic.c linux-2.6.11-rc3/arch/sparc64/mm/generic.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/mm/generic.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/mm/generic.c	2005-02-03 02:56:33.000000000 +0100
@@ -96,6 +96,27 @@ static inline int io_remap_pmd_range(pmd
 	return 0;
 }
 
+static inline int io_remap_pud_range(pud_t * pud, unsigned long address, unsigned long size,
+	unsigned long offset, pgprot_t prot, int space)
+{
+	unsigned long end;
+
+	address &= ~PUD_MASK;
+	end = address + size;
+	if (end > PUD_SIZE)
+		end = PUD_SIZE;
+	offset -= address;
+	do {
+		pmd_t *pmd = pmd_alloc(current->mm, pud, address);
+		if (!pud)
+			return -ENOMEM;
+		io_remap_pmd_range(pmd, address, end - address, address + offset, prot, space);
+		address = (address + PUD_SIZE) & PUD_MASK;
+		pud++;
+	} while (address < end);
+	return 0;
+}
+
 int io_remap_page_range(struct vm_area_struct *vma, unsigned long from, unsigned long offset, unsigned long size, pgprot_t prot, int space)
 {
 	int error = 0;
@@ -111,11 +132,11 @@ int io_remap_page_range(struct vm_area_s
 
 	spin_lock(&mm->page_table_lock);
 	while (from < end) {
-		pmd_t *pmd = pmd_alloc(current->mm, dir, from);
+		pud_t *pud = pud_alloc(current->mm, dir, from);
 		error = -ENOMEM;
-		if (!pmd)
+		if (!pud)
 			break;
-		error = io_remap_pmd_range(pmd, from, end - from, offset + from, prot, space);
+		error = io_remap_pud_range(pud, from, end - from, offset + from, prot, space);
 		if (error)
 			break;
 		from = (from + PGDIR_SIZE) & PGDIR_MASK;
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/mm/hugetlbpage.c linux-2.6.11-rc3/arch/sparc64/mm/hugetlbpage.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/mm/hugetlbpage.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/mm/hugetlbpage.c	2005-02-03 02:56:21.000000000 +0100
@@ -24,14 +24,18 @@
 static pte_t *huge_pte_alloc(struct mm_struct *mm, unsigned long addr)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte = NULL;
 
 	pgd = pgd_offset(mm, addr);
 	if (pgd) {
-		pmd = pmd_alloc(mm, pgd, addr);
-		if (pmd)
-			pte = pte_alloc_map(mm, pmd, addr);
+		pud = pud_offset(pgd, addr);
+		if (pud) {
+			pmd = pmd_alloc(mm, pud, addr);
+			if (pmd)
+				pte = pte_alloc_map(mm, pmd, addr);
+		}
 	}
 	return pte;
 }
@@ -39,14 +43,18 @@ static pte_t *huge_pte_alloc(struct mm_s
 static pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte = NULL;
 
 	pgd = pgd_offset(mm, addr);
 	if (pgd) {
-		pmd = pmd_offset(pgd, addr);
-		if (pmd)
-			pte = pte_offset_map(pmd, addr);
+		pud = pud_offset(pgd, addr);
+		if (pud) {
+			pmd = pmd_offset(pud, addr);
+			if (pmd)
+				pte = pte_offset_map(pmd, addr);
+		}
 	}
 	return pte;
 }
diff -purN linux-2.6.11-rc2-bk10/arch/sparc64/mm/init.c linux-2.6.11-rc3/arch/sparc64/mm/init.c
--- linux-2.6.11-rc2-bk10/arch/sparc64/mm/init.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/arch/sparc64/mm/init.c	2005-02-03 02:55:36.000000000 +0100
@@ -1462,7 +1462,8 @@ void __init paging_init(void)
 	memset(swapper_pmd_dir, 0, sizeof(swapper_pmd_dir));
 
 	/* Now can init the kernel/bad page tables. */
-	pgd_set(&swapper_pg_dir[0], swapper_pmd_dir + (shift / sizeof(pgd_t)));
+	pud_set(pud_offset(&swapper_pg_dir[0], 0),
+		swapper_pmd_dir + (shift / sizeof(pgd_t)));
 	
 	sparc64_vpte_patchme1[0] |=
 		(((unsigned long)pgd_val(init_mm.pgd[0])) >> 10);
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/ia32/fpu32.c linux-2.6.11-rc3/arch/x86_64/ia32/fpu32.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/ia32/fpu32.c	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc3/arch/x86_64/ia32/fpu32.c	2005-02-03 02:54:39.000000000 +0100
@@ -157,7 +157,7 @@ int restore_i387_ia32(struct task_struct
 				     sizeof(struct i387_fxsave_struct)))
 			return -1;
 		tsk->thread.i387.fxsave.mxcsr &= mxcsr_feature_mask;
-		tsk->used_math = 1;
+		set_stopped_child_used_math(tsk);
 	} 
 	return convert_fxsr_from_user(&tsk->thread.i387.fxsave, buf);
 }  
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.11-rc3/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/ia32/ia32_binfmt.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/arch/x86_64/ia32/ia32_binfmt.c	2005-02-03 02:54:59.000000000 +0100
@@ -214,7 +214,7 @@ elf_core_copy_task_fpregs(struct task_st
 	struct _fpstate_ia32 *fpstate = (void*)fpu; 
 	mm_segment_t oldfs = get_fs();
 
-	if (!tsk->used_math) 
+	if (!tsk_used_math(tsk))
 		return 0;
 	if (!regs)
 		regs = (struct pt_regs *)tsk->thread.rsp0;
@@ -235,7 +235,7 @@ static inline int 
 elf_core_copy_task_xfpregs(struct task_struct *t, elf_fpxregset_t *xfpu)
 {
 	struct pt_regs *regs = ((struct pt_regs *)(t->thread.rsp0))-1; 
-	if (!t->used_math) 
+	if (!tsk_used_math(t))
 		return 0;
 	if (t == current)
 		unlazy_fpu(t); 
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/ia32/ia32_signal.c linux-2.6.11-rc3/arch/x86_64/ia32/ia32_signal.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/ia32/ia32_signal.c	2005-01-22 02:49:00.000000000 +0100
+++ linux-2.6.11-rc3/arch/x86_64/ia32/ia32_signal.c	2005-02-03 02:56:53.000000000 +0100
@@ -35,8 +35,6 @@
 #include <asm/proto.h>
 #include <asm/vsyscall32.h>
 
-#define ptr_to_u32(x) ((u32)(u64)(x))	/* avoid gcc warning */ 
-
 #define DEBUG_SIG 0
 
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
@@ -62,7 +60,7 @@ int copy_siginfo_to_user32(compat_siginf
 	if (from->si_code < 0) {
 		err |= __put_user(from->si_pid, &to->si_pid);
  		err |= __put_user(from->si_uid, &to->si_uid);
- 		err |= __put_user((u32)(u64)from->si_ptr, &to->si_ptr);
+ 		err |= __put_user(ptr_to_compat(from->si_ptr), &to->si_ptr);
 	} else {
  		/* First 32bits of unions are always present:
  		 * si_pid === si_band === si_tid === si_addr(LS half) */
@@ -83,7 +81,7 @@ int copy_siginfo_to_user32(compat_siginf
 			break;
 		case __SI_TIMER >> 16:
 			err |= __put_user(from->si_overrun, &to->si_overrun); 
-			err |= __put_user((u32)(u64)from->si_ptr, &to->si_ptr);
+			err |= __put_user(ptr_to_compat(from->si_ptr), &to->si_ptr);
 			break;
 		case __SI_RT >> 16: /* This is not generated by the kernel as of now.  */
 		case __SI_MESGQ >> 16:
@@ -160,7 +158,7 @@ sys32_sigaltstack(const stack_ia32_t __u
 	set_fs(seg); 
 	if (ret >= 0 && uoss_ptr)  {
 		if (!access_ok(VERIFY_WRITE,uoss_ptr,sizeof(stack_ia32_t)) ||
-		    __put_user((u32)(u64)uoss.ss_sp, &uoss_ptr->ss_sp) ||
+		    __put_user(ptr_to_compat(uoss.ss_sp), &uoss_ptr->ss_sp) ||
 		    __put_user(uoss.ss_flags, &uoss_ptr->ss_flags) ||
 		    __put_user(uoss.ss_size, &uoss_ptr->ss_size))
 			ret = -EFAULT;
@@ -263,9 +261,9 @@ ia32_restore_sigcontext(struct pt_regs *
 			err |= restore_i387_ia32(current, buf, 0);
 		} else {
 			struct task_struct *me = current;
-			if (me->used_math) {
+			if (used_math()) {
 				clear_fpu(me);
-				me->used_math = 0;
+				clear_used_math();
 			}
 		}
 	}
@@ -389,9 +387,9 @@ ia32_setup_sigcontext(struct sigcontext_
 	if (tmp < 0)
 	  err = -EFAULT;
 	else { 
-		current->used_math = 0;
+		clear_used_math();
 		stts();
-	  err |= __put_user((u32)(u64)(tmp ? fpstate : NULL), &sc->fpstate);
+	  err |= __put_user(ptr_to_compat(tmp ? fpstate : NULL), &sc->fpstate);
 	}
 
 	/* non-iBCS2 extensions.. */
@@ -467,7 +465,7 @@ void ia32_setup_frame(int sig, struct k_
 		void __user *restorer = VSYSCALL32_SIGRETURN; 
 		if (ka->sa.sa_flags & SA_RESTORER)
 			restorer = ka->sa.sa_restorer;       
-		err |= __put_user(ptr_to_u32(restorer), &frame->pretcode);
+		err |= __put_user(ptr_to_compat(restorer), &frame->pretcode);
 	}
 	/* These are actually not used anymore, but left because some 
 	   gdb versions depend on them as a marker. */
@@ -540,8 +538,8 @@ void ia32_setup_rt_frame(int sig, struct
 			   : sig),
 			  &frame->sig);
 	}
-	err |= __put_user((u32)(u64)&frame->info, &frame->pinfo);
-	err |= __put_user((u32)(u64)&frame->uc, &frame->puc);
+	err |= __put_user(ptr_to_compat(&frame->info), &frame->pinfo);
+	err |= __put_user(ptr_to_compat(&frame->uc), &frame->puc);
 	err |= copy_siginfo_to_user32(&frame->info, info);
 	if (err)
 		goto give_sigsegv;
@@ -564,7 +562,7 @@ void ia32_setup_rt_frame(int sig, struct
 		void __user *restorer = VSYSCALL32_RTSIGRETURN; 
 		if (ka->sa.sa_flags & SA_RESTORER)
 			restorer = ka->sa.sa_restorer;       
-		err |= __put_user(ptr_to_u32(restorer), &frame->pretcode);
+		err |= __put_user(ptr_to_compat(restorer), &frame->pretcode);
 	}
 
 	/* This is movl $,%eax ; int $0x80 */
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/ia32/ptrace32.c linux-2.6.11-rc3/arch/x86_64/ia32/ptrace32.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/ia32/ptrace32.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/x86_64/ia32/ptrace32.c	2005-02-03 02:55:23.000000000 +0100
@@ -358,14 +358,14 @@ asmlinkage long sys32_ptrace(long reques
 			break;
 		/* no checking to be bug-to-bug compatible with i386 */
 		__copy_from_user(&child->thread.i387.fxsave, u, sizeof(*u));
-		child->used_math = 1;
+		set_stopped_child_used_math(child);
 		child->thread.i387.fxsave.mxcsr &= mxcsr_feature_mask;
 		ret = 0; 
 		break;
 	}
 
 	case PTRACE_GETEVENTMSG:
-		ret = put_user(child->ptrace_message,(unsigned int __user *)(u64)data);
+		ret = put_user(child->ptrace_message,(unsigned int __user *)compat_ptr(data));
 		break;
 
 	default:
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/ia32/sys_ia32.c linux-2.6.11-rc3/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/ia32/sys_ia32.c	2005-02-03 10:03:08.924512128 +0100
+++ linux-2.6.11-rc3/arch/x86_64/ia32/sys_ia32.c	2005-02-03 02:55:50.000000000 +0100
@@ -73,10 +73,7 @@
 #include <net/sock.h>
 #include <asm/ia32.h>
 
-#define A(__x)		((unsigned long)(__x))
 #define AA(__x)		((unsigned long)(__x))
-#define ROUND_UP(x,a)	((__typeof__(x))(((unsigned long)(x) + ((a) - 1)) & ~((a) - 1)))
-#define NAME_OFFSET(de) ((int) ((de)->d_name - (char __user *) (de)))
 
 int cp_compat_stat(struct kstat *kbuf, struct compat_stat __user *ubuf)
 {
@@ -305,8 +302,8 @@ sys32_rt_sigaction(int sig, struct sigac
 			set32.sig[0] = old_ka.sa.sa_mask.sig[0];
 		}
 		if (verify_area(VERIFY_WRITE, oact, sizeof(*oact)) ||
-		    __put_user((long)old_ka.sa.sa_handler, &oact->sa_handler) ||
-		    __put_user((long)old_ka.sa.sa_restorer, &oact->sa_restorer) ||
+		    __put_user(ptr_to_compat(old_ka.sa.sa_handler), &oact->sa_handler) ||
+		    __put_user(ptr_to_compat(old_ka.sa.sa_restorer), &oact->sa_restorer) ||
 		    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||
 		    __copy_to_user(&oact->sa_mask, &set32, sizeof(compat_sigset_t)))
 			return -EFAULT;
@@ -342,8 +339,8 @@ sys32_sigaction (int sig, struct old_sig
 
 	if (!ret && oact) {
 		if (verify_area(VERIFY_WRITE, oact, sizeof(*oact)) ||
-		    __put_user((long)old_ka.sa.sa_handler, &oact->sa_handler) ||
-		    __put_user((long)old_ka.sa.sa_restorer, &oact->sa_restorer) ||
+		    __put_user(ptr_to_compat(old_ka.sa.sa_handler), &oact->sa_handler) ||
+		    __put_user(ptr_to_compat(old_ka.sa.sa_restorer), &oact->sa_restorer) ||
 		    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||
 		    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))
 			return -EFAULT;
@@ -670,9 +667,9 @@ sys32_sysctl(struct sysctl_ia32 __user *
 {
 	struct sysctl_ia32 a32;
 	mm_segment_t old_fs = get_fs ();
-	void *oldvalp, *newvalp;
+	void __user *oldvalp, *newvalp;
 	size_t oldlen;
-	int *namep;
+	int __user *namep;
 	long ret;
 	extern int do_sysctl(int *name, int nlen, void *oldval, size_t *oldlenp,
 		     void *newval, size_t newlen);
@@ -688,9 +685,9 @@ sys32_sysctl(struct sysctl_ia32 __user *
 	 * addresses, we KNOW that access_ok() will always succeed, so this is an
 	 * expensive NOP, but so what...
 	 */
-	namep = (int *) A(a32.name);
-	oldvalp = (void *) A(a32.oldval);
-	newvalp = (void *) A(a32.newval);
+	namep = compat_ptr(a32.name);
+	oldvalp = compat_ptr(a32.oldval);
+	newvalp =  compat_ptr(a32.newval);
 
 	if ((oldvalp && get_user(oldlen, (int __user *)compat_ptr(a32.oldlenp)))
 	    || !access_ok(VERIFY_WRITE, namep, 0)
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/kernel/i387.c linux-2.6.11-rc3/arch/x86_64/kernel/i387.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/kernel/i387.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/arch/x86_64/kernel/i387.c	2005-02-03 02:55:23.000000000 +0100
@@ -57,12 +57,12 @@ void __init fpu_init(void)
 	mxcsr_feature_mask_init();
 	/* clean state in init */
 	current_thread_info()->status = 0;
-	current->used_math = 0;
+	clear_used_math();
 }
 
 void init_fpu(struct task_struct *child)
 {
-	if (child->used_math) { 
+	if (tsk_used_math(child)) {
 		if (child == current)
 			unlazy_fpu(child);
 		return;
@@ -70,7 +70,8 @@ void init_fpu(struct task_struct *child)
 	memset(&child->thread.i387.fxsave, 0, sizeof(struct i387_fxsave_struct));
 	child->thread.i387.fxsave.cwd = 0x37f;
 	child->thread.i387.fxsave.mxcsr = 0x1f80;
-	child->used_math = 1;
+	/* only the device not available exception or ptrace can call init_fpu */
+	set_stopped_child_used_math(child);
 }
 
 /*
@@ -91,9 +92,9 @@ int save_i387(struct _fpstate __user *bu
 	if ((unsigned long)buf % 16) 
 		printk("save_i387: bad fpstate %p\n",buf); 
 
-	if (!tsk->used_math) 
+	if (!used_math())
 		return 0;
-	tsk->used_math = 0; /* trigger finit */ 
+	clear_used_math(); /* trigger finit */
 	if (tsk->thread_info->status & TS_USEDFPU) {
 		err = save_i387_checking((struct i387_fxsave_struct __user *)buf);
 		if (err) return err;
@@ -133,7 +134,7 @@ int dump_fpu( struct pt_regs *regs, stru
 {
 	struct task_struct *tsk = current;
 
-	if (!tsk->used_math) 
+	if (!used_math())
 		return 0;
 
 	unlazy_fpu(tsk);
@@ -143,7 +144,7 @@ int dump_fpu( struct pt_regs *regs, stru
 
 int dump_task_fpu(struct task_struct *tsk, struct user_i387_struct *fpu)
 {
-	int fpvalid = tsk->used_math;
+	int fpvalid = !!tsk_used_math(tsk);
 
 	if (fpvalid) {
 		if (tsk == current)
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/kernel/process.c linux-2.6.11-rc3/arch/x86_64/kernel/process.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/kernel/process.c	2005-02-03 10:03:08.930511195 +0100
+++ linux-2.6.11-rc3/arch/x86_64/kernel/process.c	2005-02-03 02:55:53.000000000 +0100
@@ -314,7 +314,7 @@ void flush_thread(void)
 	 * Forget coprocessor state..
 	 */
 	clear_fpu(tsk);
-	tsk->used_math = 0;
+	clear_used_math();
 }
 
 void release_thread(struct task_struct *dead_task)
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/kernel/ptrace.c linux-2.6.11-rc3/arch/x86_64/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/kernel/ptrace.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/arch/x86_64/kernel/ptrace.c	2005-02-03 02:55:23.000000000 +0100
@@ -480,7 +480,7 @@ asmlinkage long sys_ptrace(long request,
 			ret = -EIO;
 			break;
 		}
-		child->used_math = 1;
+		set_stopped_child_used_math(child);
 		ret = set_fpregs(child, (struct user_i387_struct __user *)data);
 		break;
 	}
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/kernel/signal.c linux-2.6.11-rc3/arch/x86_64/kernel/signal.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/kernel/signal.c	2005-01-22 02:48:29.000000000 +0100
+++ linux-2.6.11-rc3/arch/x86_64/kernel/signal.c	2005-02-03 02:56:22.000000000 +0100
@@ -126,9 +126,9 @@ restore_sigcontext(struct pt_regs *regs,
 			err |= restore_i387(buf);
 		} else {
 			struct task_struct *me = current;
-			if (me->used_math) {
+			if (used_math()) {
 				clear_fpu(me);
-				me->used_math = 0;
+				clear_used_math();
 			}
 		}
 	}
@@ -251,7 +251,7 @@ static void setup_rt_frame(int sig, stru
 	int err = 0;
 	struct task_struct *me = current;
 
-	if (me->used_math) {
+	if (used_math()) {
 		fp = get_stack(ka, regs, sizeof(struct _fpstate)); 
 		frame = (void __user *)round_down((unsigned long)fp - sizeof(struct rt_sigframe), 16) - 8;
 
diff -purN linux-2.6.11-rc2-bk10/arch/x86_64/kernel/traps.c linux-2.6.11-rc3/arch/x86_64/kernel/traps.c
--- linux-2.6.11-rc2-bk10/arch/x86_64/kernel/traps.c	2005-02-03 10:03:08.938509950 +0100
+++ linux-2.6.11-rc3/arch/x86_64/kernel/traps.c	2005-02-03 02:54:39.000000000 +0100
@@ -892,7 +892,7 @@ asmlinkage void math_state_restore(void)
 	struct task_struct *me = current;
 	clts();			/* Allow maths ops (or we recurse) */
 
-	if (!me->used_math)
+	if (!used_math())
 		init_fpu(me);
 	restore_fpu_checking(&me->thread.i387.fxsave);
 	me->thread_info->status |= TS_USEDFPU;
diff -purN linux-2.6.11-rc2-bk10/crypto/tcrypt.h linux-2.6.11-rc3/crypto/tcrypt.h
--- linux-2.6.11-rc2-bk10/crypto/tcrypt.h	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/crypto/tcrypt.h	2005-02-03 02:56:48.000000000 +0100
@@ -1986,7 +1986,7 @@ static struct cipher_testvec arc4_dec_tv
 #define TEA_ENC_TEST_VECTORS	4
 #define TEA_DEC_TEST_VECTORS	4
 
-static struct cipher_testvec xtea_enc_tv_template[] =
+static struct cipher_testvec tea_enc_tv_template[] =
 {
 	{
 		.key    = { [0 ... 15] = 0x00 },
@@ -2080,7 +2080,7 @@ static struct cipher_testvec tea_dec_tv_
 #define XTEA_ENC_TEST_VECTORS	4
 #define XTEA_DEC_TEST_VECTORS	4
 
-static struct cipher_testvec tea_enc_tv_template[] =
+static struct cipher_testvec xtea_enc_tv_template[] =
 {
 	{
 		.key    = { [0 ... 15] = 0x00 },
diff -purN linux-2.6.11-rc2-bk10/drivers/atm/fore200e.c linux-2.6.11-rc3/drivers/atm/fore200e.c
--- linux-2.6.11-rc2-bk10/drivers/atm/fore200e.c	2005-02-03 10:03:09.121481479 +0100
+++ linux-2.6.11-rc3/drivers/atm/fore200e.c	2005-02-03 02:57:03.000000000 +0100
@@ -39,6 +39,7 @@
 #include <linux/sonet.h>
 #include <linux/atm_suni.h>
 #include <linux/dma-mapping.h>
+#include <linux/delay.h>
 #include <asm/io.h>
 #include <asm/string.h>
 #include <asm/page.h>
diff -purN linux-2.6.11-rc2-bk10/drivers/base/attribute_container.c linux-2.6.11-rc3/drivers/base/attribute_container.c
--- linux-2.6.11-rc2-bk10/drivers/base/attribute_container.c	2005-02-03 10:03:09.139478679 +0100
+++ linux-2.6.11-rc3/drivers/base/attribute_container.c	2005-02-03 02:55:52.000000000 +0100
@@ -150,7 +150,7 @@ attribute_container_add_device(struct de
 		if (fn)
 			fn(cont, dev, &ic->classdev);
 		else
-			class_device_add(&ic->classdev);
+			attribute_container_add_class_device(&ic->classdev);
 		list_add_tail(&ic->node, &cont->containers);
 	}
 	up(&attribute_container_mutex);
@@ -195,8 +195,10 @@ attribute_container_remove_device(struct
 			list_del(&ic->node);
 			if (fn)
 				fn(cont, dev, &ic->classdev);
-			else
+			else {
+				attribute_container_remove_attrs(&ic->classdev);
 				class_device_unregister(&ic->classdev);
+			}
 		}
 	}
 	up(&attribute_container_mutex);
@@ -264,7 +266,107 @@ attribute_container_trigger(struct devic
 	up(&attribute_container_mutex);
 }
 EXPORT_SYMBOL_GPL(attribute_container_trigger);
-     
+
+/**
+ * attribute_container_add_attrs - add attributes
+ *
+ * @classdev: The class device
+ *
+ * This simply creates all the class device sysfs files from the
+ * attributes listed in the container
+ */
+int
+attribute_container_add_attrs(struct class_device *classdev)
+{
+	struct attribute_container *cont =
+		attribute_container_classdev_to_container(classdev);
+	struct class_device_attribute **attrs =	cont->attrs;
+	int i, error;
+
+	if (!attrs)
+		return 0;
+
+	for (i = 0; attrs[i]; i++) {
+		error = class_device_create_file(classdev, attrs[i]);
+		if (error)
+			return error;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(attribute_container_add_attrs);
+
+/**
+ * attribute_container_add_class_device - same function as class_device_add
+ *
+ * @classdev:	the class device to add
+ *
+ * This performs essentially the same function as class_device_add except for
+ * attribute containers, namely add the classdev to the system and then
+ * create the attribute files
+ */
+int
+attribute_container_add_class_device(struct class_device *classdev)
+{
+	int error = class_device_add(classdev);
+	if (error)
+		return error;
+	return attribute_container_add_attrs(classdev);
+}
+EXPORT_SYMBOL_GPL(attribute_container_add_class_device);
+
+/**
+ * attribute_container_add_class_device_adapter - simple adapter for triggers
+ *
+ * This function is identical to attribute_container_add_class_device except
+ * that it is designed to be called from the triggers
+ */
+int
+attribute_container_add_class_device_adapter(struct attribute_container *cont,
+					     struct device *dev,
+					     struct class_device *classdev)
+{
+	return attribute_container_add_class_device(classdev);
+}
+EXPORT_SYMBOL_GPL(attribute_container_add_class_device_adapter);
+
+/**
+ * attribute_container_remove_attrs - remove any attribute files
+ *
+ * @classdev: The class device to remove the files from
+ *
+ */
+void
+attribute_container_remove_attrs(struct class_device *classdev)
+{
+	struct attribute_container *cont =
+		attribute_container_classdev_to_container(classdev);
+	struct class_device_attribute **attrs =	cont->attrs;
+	int i;
+
+	if (!attrs)
+		return;
+
+	for (i = 0; attrs[i]; i++)
+		class_device_remove_file(classdev, attrs[i]);
+}
+EXPORT_SYMBOL_GPL(attribute_container_remove_attrs);
+
+/**
+ * attribute_container_class_device_del - equivalent of class_device_del
+ *
+ * @classdev: the class device
+ *
+ * This function simply removes all the attribute files and then calls
+ * class_device_del.
+ */
+void
+attribute_container_class_device_del(struct class_device *classdev)
+{
+	attribute_container_remove_attrs(classdev);
+	class_device_del(classdev);
+}
+EXPORT_SYMBOL_GPL(attribute_container_class_device_del);
 
 int __init
 attribute_container_init(void)
diff -purN linux-2.6.11-rc2-bk10/drivers/base/cpu.c linux-2.6.11-rc3/drivers/base/cpu.c
--- linux-2.6.11-rc2-bk10/drivers/base/cpu.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/drivers/base/cpu.c	2005-02-03 02:55:35.000000000 +0100
@@ -64,7 +64,6 @@ void unregister_cpu(struct cpu *cpu, str
 
 	return;
 }
-EXPORT_SYMBOL(unregister_cpu);
 #else /* ... !CONFIG_HOTPLUG_CPU */
 static inline void register_cpu_control(struct cpu *cpu)
 {
@@ -96,9 +95,6 @@ int __devinit register_cpu(struct cpu *c
 		register_cpu_control(cpu);
 	return error;
 }
-#ifdef CONFIG_HOTPLUG_CPU
-EXPORT_SYMBOL(register_cpu);
-#endif
 
 
 
diff -purN linux-2.6.11-rc2-bk10/drivers/base/transport_class.c linux-2.6.11-rc3/drivers/base/transport_class.c
--- linux-2.6.11-rc2-bk10/drivers/base/transport_class.c	2005-02-03 10:03:09.144477901 +0100
+++ linux-2.6.11-rc3/drivers/base/transport_class.c	2005-02-03 02:55:23.000000000 +0100
@@ -146,25 +146,6 @@ void transport_setup_device(struct devic
 EXPORT_SYMBOL_GPL(transport_setup_device);
 
 
-static int transport_add_classdev(struct attribute_container *cont,
-				  struct device *dev,
-				  struct class_device *classdev)
-{
-	struct class_device_attribute **attrs =	cont->attrs;
-	int i, error;
-
-	error = class_device_add(classdev);
-	if (error)
-		return error;
-	for (i = 0; attrs[i]; i++) {
-		error = class_device_create_file(classdev, attrs[i]);
-		if (error)
-			return error;
-	}
-
-	return 0;
-}
-
 /**
  * transport_add_device - declare a new dev for transport class association
  *
@@ -178,7 +159,8 @@ static int transport_add_classdev(struct
 
 void transport_add_device(struct device *dev)
 {
-	attribute_container_device_trigger(dev, transport_add_classdev);
+	attribute_container_device_trigger(dev,
+			   attribute_container_add_class_device_adapter);
 }
 EXPORT_SYMBOL_GPL(transport_add_device);
 
@@ -220,6 +202,9 @@ static int transport_remove_classdev(str
 	if (tclass->remove)
 		tclass->remove(dev);
 
+	if (tclass->remove != anon_transport_dummy_function)
+		attribute_container_class_device_del(classdev);
+
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/cdrom/isp16.c linux-2.6.11-rc3/drivers/cdrom/isp16.c
--- linux-2.6.11-rc2-bk10/drivers/cdrom/isp16.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/cdrom/isp16.c	2005-02-03 02:56:48.000000000 +0100
@@ -77,10 +77,6 @@ module_param(isp16_cdrom_irq, int, 0);
 module_param(isp16_cdrom_dma, int, 0);
 module_param(isp16_cdrom_type, charp, 0);
 
-#ifdef MODULE
-void isp16_exit(void);
-#endif
-
 #define ISP16_IN(p) (outb(isp16_ctrl,ISP16_CTRL_PORT), inb(p))
 #define ISP16_OUT(p,b) (outb(isp16_ctrl,ISP16_CTRL_PORT), outb(b,p))
 
@@ -112,7 +108,7 @@ __setup("isp16=", isp16_setup);
  *  ISP16 initialisation.
  *
  */
-int __init isp16_init(void)
+static int __init isp16_init(void)
 {
 	u_char expected_drive;
 
@@ -366,15 +362,13 @@ isp16_cdi_config(int base, u_char drive_
 	return 0;
 }
 
-void __exit isp16_exit(void)
+static void __exit isp16_exit(void)
 {
 	release_region(ISP16_IO_BASE, ISP16_IO_SIZE);
 	printk(KERN_INFO "ISP16: module released.\n");
 }
 
-#ifdef MODULE
 module_init(isp16_init);
-#endif
 module_exit(isp16_exit);
 
 MODULE_LICENSE("GPL");
diff -purN linux-2.6.11-rc2-bk10/drivers/cdrom/isp16.h linux-2.6.11-rc3/drivers/cdrom/isp16.h
--- linux-2.6.11-rc2-bk10/drivers/cdrom/isp16.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/cdrom/isp16.h	2005-02-03 02:55:36.000000000 +0100
@@ -70,5 +70,3 @@
 
 #define ISP16_IO_BASE 0xF8D
 #define ISP16_IO_SIZE 5  /* ports used from 0xF8D up to 0xF91 */
-
-int isp16_init(void);
diff -purN linux-2.6.11-rc2-bk10/drivers/cdrom/viocd.c linux-2.6.11-rc3/drivers/cdrom/viocd.c
--- linux-2.6.11-rc2-bk10/drivers/cdrom/viocd.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/cdrom/viocd.c	2005-02-03 02:57:04.000000000 +0100
@@ -765,8 +765,6 @@ static int __init viocd_init(void)
 	vio_setHandler(viomajorsubtype_cdio, vio_handle_cd_event);
 
 	get_viocd_info();
-	if (viocd_numdev == 0)
-		goto out_undo_vio;
 
 	spin_lock_init(&viocd_reqlock);
 
@@ -786,7 +784,6 @@ out_free_info:
 	dma_free_coherent(iSeries_vio_dev,
 			sizeof(*viocd_unitinfo) * VIOCD_MAX_CD,
 			viocd_unitinfo, unitinfo_dmaaddr);
-out_undo_vio:
 	vio_clearHandler(viomajorsubtype_cdio);
 	viopath_close(viopath_hostLp, viomajorsubtype_cdio, MAX_CD_REQ + 2);
 out_unregister:
diff -purN linux-2.6.11-rc2-bk10/drivers/char/Kconfig linux-2.6.11-rc3/drivers/char/Kconfig
--- linux-2.6.11-rc2-bk10/drivers/char/Kconfig	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/Kconfig	2005-02-03 02:54:59.000000000 +0100
@@ -348,22 +348,6 @@ config ISTALLION
 	  To compile this driver as a module, choose M here: the
 	  module will be called istallion.
 
-config SERIAL_TX3912
-	bool "TX3912/PR31700 serial port support"
-	depends on SERIAL_NONSTANDARD && MIPS && BROKEN_ON_SMP
-	help
-	  The TX3912 is a Toshiba RISC processor based on the MIPS 3900 core;
-	  see <http://www.toshiba.com/taec/components/Generic/risc/tx3912.htm>.
-	  Say Y here to enable kernel support for the on-board serial port.
-
-config SERIAL_TX3912_CONSOLE
-	bool "Console on TX3912/PR31700 serial port"
-	depends on SERIAL_TX3912
-	help
-	  The TX3912 is a Toshiba RISC processor based on the MIPS 3900 core;
-	  see <http://www.toshiba.com/taec/components/Generic/risc/tx3912.htm>.
-	  Say Y here to direct console I/O to the on-board serial port.
-
 config AU1000_UART
 	bool "Enable Au1000 UART Support"
 	depends on SERIAL_NONSTANDARD && MIPS
diff -purN linux-2.6.11-rc2-bk10/drivers/char/Makefile linux-2.6.11-rc3/drivers/char/Makefile
--- linux-2.6.11-rc2-bk10/drivers/char/Makefile	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/Makefile	2005-02-03 02:56:53.000000000 +0100
@@ -20,7 +20,6 @@ obj-$(CONFIG_ESPSERIAL)		+= esp.o
 obj-$(CONFIG_MVME147_SCC)	+= generic_serial.o vme_scc.o
 obj-$(CONFIG_MVME162_SCC)	+= generic_serial.o vme_scc.o
 obj-$(CONFIG_BVME6000_SCC)	+= generic_serial.o vme_scc.o
-obj-$(CONFIG_SERIAL_TX3912)	+= generic_serial.o serial_tx3912.o
 obj-$(CONFIG_ROCKETPORT)	+= rocket.o
 obj-$(CONFIG_SERIAL167)		+= serial167.o
 obj-$(CONFIG_CYCLADES)		+= cyclades.o
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/Makefile linux-2.6.11-rc3/drivers/char/drm/Makefile
--- linux-2.6.11-rc2-bk10/drivers/char/drm/Makefile	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/Makefile	2005-02-03 02:56:53.000000000 +0100
@@ -5,7 +5,8 @@
 drm-objs    :=	drm_auth.o drm_bufs.o drm_context.o drm_dma.o drm_drawable.o \
 		drm_drv.o drm_fops.o drm_init.o drm_ioctl.o drm_irq.o \
 		drm_lock.o drm_memory.o drm_proc.o drm_stub.o drm_vm.o \
-		drm_agpsupport.o drm_scatter.o ati_pcigart.o
+		drm_agpsupport.o drm_scatter.o ati_pcigart.o drm_pci.o \
+		drm_sysfs.o
 
 gamma-objs  := gamma_drv.o gamma_dma.o
 tdfx-objs   := tdfx_drv.o
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drmP.h linux-2.6.11-rc3/drivers/char/drm/drmP.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drmP.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drmP.h	2005-02-03 02:56:22.000000000 +0100
@@ -557,7 +557,7 @@ typedef struct drm_vbl_sig {
 struct drm_device;
 
 struct drm_driver {
-	int (*preinit)(struct drm_device *);
+	int (*preinit)(struct drm_device *, unsigned long flags);
 	void (*prerelease)(struct drm_device *, struct file *filp);
 	void (*pretakedown)(struct drm_device *);
 	int (*postcleanup)(struct drm_device *);
@@ -960,7 +960,7 @@ extern int 	      drm_put_minor(drm_devi
 extern unsigned int   drm_debug;
 extern unsigned int   drm_cards_limit;
 extern drm_minor_t    *drm_minors;
-extern struct class_simple *drm_class;
+extern struct drm_sysfs_class *drm_class;
 extern struct proc_dir_entry *drm_proc_root;
 
 				/* Proc support (drm_proc.h) */
@@ -987,6 +987,24 @@ extern int            drm_ati_pcigart_cl
 					       unsigned long addr,
 					       dma_addr_t bus_addr);
 
+extern void *drm_pci_alloc(drm_device_t * dev, size_t size,
+			   size_t align, dma_addr_t maxaddr,
+			   dma_addr_t * busaddr);
+
+extern void drm_pci_free(drm_device_t * dev, size_t size,
+			 void *vaddr, dma_addr_t busaddr);
+
+			       /* sysfs support (drm_sysfs.c) */
+struct drm_sysfs_class;
+extern struct drm_sysfs_class *drm_sysfs_create(struct module *owner,
+						char *name);
+extern void drm_sysfs_destroy(struct drm_sysfs_class *cs);
+extern struct class_device *drm_sysfs_device_add(struct drm_sysfs_class *cs,
+						 dev_t dev,
+						 struct device *device,
+						 const char *fmt, ...);
+extern void drm_sysfs_device_remove(dev_t dev);
+
 
 /* Inline replacements for DRM_IOREMAP macros */
 static __inline__ void drm_core_ioremap(struct drm_map *map, struct drm_device *dev)
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drm_drv.c linux-2.6.11-rc3/drivers/char/drm/drm_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drm_drv.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drm_drv.c	2005-02-03 02:56:33.000000000 +0100
@@ -403,7 +403,7 @@ static int __init drm_core_init(void)
 	if (register_chrdev(DRM_MAJOR, "drm", &drm_stub_fops))
 		goto err_p1;
 	
-	drm_class = class_simple_create(THIS_MODULE, "drm");
+	drm_class = drm_sysfs_create(THIS_MODULE, "drm");
 	if (IS_ERR(drm_class)) {
 		printk (KERN_ERR "DRM: Error creating drm class.\n");
 		ret = PTR_ERR(drm_class);
@@ -426,7 +426,7 @@ static int __init drm_core_init(void)
 		);
 	return 0;
 err_p3:
-	class_simple_destroy(drm_class);
+	drm_sysfs_destroy(drm_class);
 err_p2:
 	unregister_chrdev(DRM_MAJOR, "drm");
 	drm_free(drm_minors, sizeof(*drm_minors) * drm_cards_limit, DRM_MEM_STUB);
@@ -437,7 +437,7 @@ err_p1:	
 static void __exit drm_core_exit (void)
 {
 	remove_proc_entry("dri", NULL);
-	class_simple_destroy(drm_class);
+	drm_sysfs_destroy(drm_class);
 
 	unregister_chrdev(DRM_MAJOR, "drm");
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drm_ioctl.c linux-2.6.11-rc3/drivers/char/drm/drm_ioctl.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drm_ioctl.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drm_ioctl.c	2005-02-03 02:55:22.000000000 +0100
@@ -304,6 +304,17 @@ int drm_getstats( struct inode *inode, s
 	return 0;
 }
 
+/**
+ * Setversion ioctl.
+ *
+ * \param inode device inode.
+ * \param filp file pointer.
+ * \param cmd command.
+ * \param arg user argument, pointing to a drm_lock structure.
+ * \return zero on success or negative number on failure.
+ *
+ * Sets the requested interface version
+ */
 int drm_setversion(DRM_IOCTL_ARGS)
 {
 	DRM_DEVICE;
@@ -311,13 +322,15 @@ int drm_setversion(DRM_IOCTL_ARGS)
 	drm_set_version_t retv;
 	int if_version;
 	drm_set_version_t __user *argp = (void __user *)data;
+	drm_version_t version;
 
 	DRM_COPY_FROM_USER_IOCTL(sv, argp, sizeof(sv));
 
+	dev->driver->version(&version);
 	retv.drm_di_major = DRM_IF_MAJOR;
 	retv.drm_di_minor = DRM_IF_MINOR;
-	retv.drm_dd_major = DRIVER_MAJOR;
-	retv.drm_dd_minor = DRIVER_MINOR;
+	retv.drm_dd_major = version.version_major;
+	retv.drm_dd_minor = version.version_minor;
 
 	DRM_COPY_TO_USER_IOCTL(argp, retv, sizeof(sv));
 
@@ -336,8 +349,8 @@ int drm_setversion(DRM_IOCTL_ARGS)
 	}
 
 	if (sv.drm_dd_major != -1) {
-		if (sv.drm_dd_major != DRIVER_MAJOR ||
-		    sv.drm_dd_minor < 0 || sv.drm_dd_minor > DRIVER_MINOR)
+		if (sv.drm_dd_major != version.version_major ||
+		    sv.drm_dd_minor < 0 || sv.drm_dd_minor > version.version_minor)
 			return EINVAL;
 
 		if (dev->driver->set_version)
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drm_memory.h linux-2.6.11-rc3/drivers/char/drm/drm_memory.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drm_memory.h	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drm_memory.h	2005-02-03 02:55:15.000000000 +0100
@@ -57,8 +57,6 @@
 # endif
 #endif
 
-#include <asm/tlbflush.h>
-
 /*
  * Find the drm_map that covers the range [offset, offset+size).
  */
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drm_pci.c linux-2.6.11-rc3/drivers/char/drm/drm_pci.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drm_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drm_pci.c	2005-02-03 02:55:36.000000000 +0100
@@ -0,0 +1,140 @@
+/* drm_pci.h -- PCI DMA memory management wrappers for DRM -*- linux-c -*- */
+/**
+ * \file drm_pci.c
+ * \brief Functions and ioctls to manage PCI memory
+ *
+ * \warning These interfaces aren't stable yet.
+ *
+ * \todo Implement the remaining ioctl's for the PCI pools.
+ * \todo The wrappers here are so thin that they would be better off inlined..
+ *
+ * \author Jose Fonseca <jrfonseca@tungstengraphics.com>
+ * \author Leif Delgass <ldelgass@retinalburn.net>
+ */
+
+/*
+ * Copyright 2003 Jos�Fonseca.
+ * Copyright 2003 Leif Delgass.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/pci.h>
+#include "drmP.h"
+
+/**********************************************************************/
+/** \name PCI memory */
+/*@{*/
+
+/**
+ * \brief Allocate a PCI consistent memory block, for DMA.
+ */
+void *drm_pci_alloc(drm_device_t * dev, size_t size, size_t align,
+		    dma_addr_t maxaddr, dma_addr_t * busaddr)
+{
+	void *address;
+#if DRM_DEBUG_MEMORY
+	int area = DRM_MEM_DMA;
+
+	spin_lock(&drm_mem_lock);
+	if ((drm_ram_used >> PAGE_SHIFT)
+	    > (DRM_RAM_PERCENT * drm_ram_available) / 100) {
+		spin_unlock(&drm_mem_lock);
+		return 0;
+	}
+	spin_unlock(&drm_mem_lock);
+#endif
+
+	/* pci_alloc_consistent only guarantees alignment to the smallest
+	 * PAGE_SIZE order which is greater than or equal to the requested size.
+	 * Return NULL here for now to make sure nobody tries for larger alignment
+	 */
+	if (align > size)
+		return NULL;
+
+	if (pci_set_dma_mask(dev->pdev, maxaddr) != 0) {
+		DRM_ERROR("Setting pci dma mask failed\n");
+		return NULL;
+	}
+
+	address = pci_alloc_consistent(dev->pdev, size, busaddr);
+
+#if DRM_DEBUG_MEMORY
+	if (address == NULL) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[area].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return NULL;
+	}
+
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_allocated += size;
+	drm_ram_used += size;
+	spin_unlock(&drm_mem_lock);
+#else
+	if (address == NULL)
+		return NULL;
+#endif
+
+	memset(address, 0, size);
+
+	return address;
+}
+EXPORT_SYMBOL(drm_pci_alloc);
+
+/**
+ * \brief Free a PCI consistent memory block.
+ */
+void
+drm_pci_free(drm_device_t * dev, size_t size, void *vaddr, dma_addr_t busaddr)
+{
+#if DRM_DEBUG_MEMORY
+	int area = DRM_MEM_DMA;
+	int alloc_count;
+	int free_count;
+#endif
+
+	if (!vaddr) {
+#if DRM_DEBUG_MEMORY
+		DRM_MEM_ERROR(area, "Attempt to free address 0\n");
+#endif
+	} else {
+		pci_free_consistent(dev->pdev, size, vaddr, busaddr);
+	}
+
+#if DRM_DEBUG_MEMORY
+	spin_lock(&drm_mem_lock);
+	free_count = ++drm_mem_stats[area].free_count;
+	alloc_count = drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_freed += size;
+	drm_ram_used -= size;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(area,
+			      "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+#endif
+
+}
+EXPORT_SYMBOL(drm_pci_free);
+
+/*@}*/
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drm_pciids.h linux-2.6.11-rc3/drivers/char/drm/drm_pciids.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drm_pciids.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drm_pciids.h	2005-02-03 02:55:50.000000000 +0100
@@ -3,64 +3,75 @@
    Please contact dri-devel@lists.sf.net to add new cards to this list
 */
 #define radeon_PCI_IDS \
-	{0x1002, 0x4136, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4137, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4237, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4336, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4337, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4437, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4965, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4966, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4967, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C58, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C59, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C5A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C65, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C66, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x4C67, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x514A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x514B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x514C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x514D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x514E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x514F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5158, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5159, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x515A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5168, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5169, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x516A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x516B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x516C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5836, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5960, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5961, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5962, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5963, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5968, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5969, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x596A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x596B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5c61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5c62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5c63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0x1002, 0x5c64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x1002, 0x4136, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|CHIP_IS_IGP}, \
+	{0x1002, 0x4137, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|CHIP_IS_IGP}, \
+	{0x1002, 0x4144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R300}, \
+	{0x1002, 0x4150, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4151, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4152, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4153, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4154, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4156, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350}, \
+	{0x1002, 0x4237, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS250|CHIP_IS_IGP}, \
+	{0x1002, 0x4242, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x4243, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x4336, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS100|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4337, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS200|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4437, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS250|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4965, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4966, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4967, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250}, \
+	{0x1002, 0x4C57, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C58, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C59, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C5A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C65, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C66, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4C67, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R250|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x4E50, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV350|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5144, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5145, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5146, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5147, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R100|CHIP_SINGLE_CRTC}, \
+	{0x1002, 0x5148, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5149, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x514F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5157, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
+	{0x1002, 0x5158, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV200}, \
+	{0x1002, 0x5159, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x515A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV100}, \
+	{0x1002, 0x5168, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5169, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x516A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x516B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x516C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R200}, \
+	{0x1002, 0x5834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
+	{0x1002, 0x5835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5836, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
+	{0x1002, 0x5837, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|CHIP_IS_IGP}, \
+	{0x1002, 0x5960, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5961, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5962, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5963, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5964, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5968, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5969, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x596A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x596B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5c61, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5c62, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
+	{0x1002, 0x5c63, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280|CHIP_IS_MOBILITY}, \
+	{0x1002, 0x5c64, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV280}, \
 	{0, 0, 0}
 
 #define r128_PCI_IDS \
@@ -207,5 +218,6 @@
 	{0x8086, 0x3582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
 	{0x8086, 0x2572, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
 	{0x8086, 0x2582, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
+	{0x8086, 0x2982, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
 	{0, 0, 0}
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drm_stub.c linux-2.6.11-rc3/drivers/char/drm/drm_stub.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drm_stub.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drm_stub.c	2005-02-03 02:57:17.000000000 +0100
@@ -50,7 +50,7 @@ module_param_named(cards_limit, drm_card
 module_param_named(debug, drm_debug, int, 0666);
 
 drm_minor_t *drm_minors;
-struct class_simple *drm_class;
+struct drm_sysfs_class *drm_class;
 struct proc_dir_entry *drm_proc_root;
 
 static int drm_fill_in_dev(drm_device_t *dev, struct pci_dev *pdev, const struct pci_device_id *ent, struct drm_driver *driver)
@@ -87,7 +87,7 @@ static int drm_fill_in_dev(drm_device_t 
 	dev->driver = driver;
 	
 	if (dev->driver->preinit)
-		if ((retcode = dev->driver->preinit(dev)))
+		if ((retcode = dev->driver->preinit(dev, ent->driver_data)))
 			goto error_out_unreg;
 
 	if (drm_core_has_AGP(dev)) {
@@ -205,10 +205,13 @@ int drm_probe(struct pci_dev *pdev, cons
 			}
 
 			
-			dev_class = class_simple_device_add(drm_class, 
-							    MKDEV(DRM_MAJOR, minor), &pdev->dev, "card%d", minor);
+			dev_class = drm_sysfs_device_add(drm_class,
+							 MKDEV(DRM_MAJOR,
+							       minor),
+							 &pdev->dev,
+							 "card%d", minor);
 			if (IS_ERR(dev_class)) {
-				printk(KERN_ERR "DRM: Error class_simple_device_add.\n");
+				printk(KERN_ERR "DRM: Error sysfs_device_add.\n");
 				ret = PTR_ERR(dev_class);
 				goto err_g2;
 			}
@@ -246,7 +249,7 @@ int drm_put_minor(drm_device_t *dev)
 	DRM_DEBUG("release minor %d\n", dev->minor);
 	
 	drm_proc_cleanup(dev->minor, drm_proc_root, minors->dev_root);
-	class_simple_device_remove(MKDEV(DRM_MAJOR, dev->minor));
+	drm_sysfs_device_remove(MKDEV(DRM_MAJOR, dev->minor));
 	
 	*minors = (drm_minor_t){.dev = NULL, .type = DRM_MINOR_FREE};
 	drm_free(dev, sizeof(*dev), DRM_MEM_STUB);
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/drm_sysfs.c linux-2.6.11-rc3/drivers/char/drm/drm_sysfs.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/drm_sysfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/drm_sysfs.c	2005-02-03 02:56:21.000000000 +0100
@@ -0,0 +1,208 @@
+/*
+ * drm_sysfs.c - Modifications to drm_sysfs_class.c to support
+ *               extra sysfs attribute from DRM. Normal drm_sysfs_class
+ *               does not allow adding attributes.
+ *
+ * Copyright (c) 2004 Jon Smirl <jonsmirl@gmail.com>
+ * Copyright (c) 2003-2004 Greg Kroah-Hartman <greg@kroah.com>
+ * Copyright (c) 2003-2004 IBM Corp.
+ *
+ * This file is released under the GPLv2
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/device.h>
+#include <linux/kdev_t.h>
+#include <linux/err.h>
+
+#include "drm_core.h"
+
+struct drm_sysfs_class {
+	struct class_device_attribute attr;
+	struct class class;
+};
+#define to_drm_sysfs_class(d) container_of(d, struct drm_sysfs_class, class)
+
+struct simple_dev {
+	struct list_head node;
+	dev_t dev;
+	struct class_device class_dev;
+};
+#define to_simple_dev(d) container_of(d, struct simple_dev, class_dev)
+
+static LIST_HEAD(simple_dev_list);
+static DEFINE_SPINLOCK(simple_dev_list_lock);
+
+static void release_simple_dev(struct class_device *class_dev)
+{
+	struct simple_dev *s_dev = to_simple_dev(class_dev);
+	kfree(s_dev);
+}
+
+static ssize_t show_dev(struct class_device *class_dev, char *buf)
+{
+	struct simple_dev *s_dev = to_simple_dev(class_dev);
+	return print_dev_t(buf, s_dev->dev);
+}
+
+static void drm_sysfs_class_release(struct class *class)
+{
+	struct drm_sysfs_class *cs = to_drm_sysfs_class(class);
+	kfree(cs);
+}
+
+/* Display the version of drm_core. This doesn't work right in current design */
+static ssize_t version_show(struct class *dev, char *buf)
+{
+	return sprintf(buf, "%s %d.%d.%d %s\n", DRIVER_NAME, DRIVER_MAJOR,
+		       DRIVER_MINOR, DRIVER_PATCHLEVEL, DRIVER_DATE);
+}
+
+static CLASS_ATTR(version, S_IRUGO, version_show, NULL);
+
+/**
+ * drm_sysfs_create - create a struct drm_sysfs_class structure
+ * @owner: pointer to the module that is to "own" this struct drm_sysfs_class
+ * @name: pointer to a string for the name of this class.
+ *
+ * This is used to create a struct drm_sysfs_class pointer that can then be used
+ * in calls to drm_sysfs_device_add().
+ *
+ * Note, the pointer created here is to be destroyed when finished by making a
+ * call to drm_sysfs_destroy().
+ */
+struct drm_sysfs_class *drm_sysfs_create(struct module *owner, char *name)
+{
+	struct drm_sysfs_class *cs;
+	int retval;
+
+	cs = kmalloc(sizeof(*cs), GFP_KERNEL);
+	if (!cs) {
+		retval = -ENOMEM;
+		goto error;
+	}
+	memset(cs, 0x00, sizeof(*cs));
+
+	cs->class.name = name;
+	cs->class.class_release = drm_sysfs_class_release;
+	cs->class.release = release_simple_dev;
+
+	cs->attr.attr.name = "dev";
+	cs->attr.attr.mode = S_IRUGO;
+	cs->attr.attr.owner = owner;
+	cs->attr.show = show_dev;
+	cs->attr.store = NULL;
+
+	retval = class_register(&cs->class);
+	if (retval)
+		goto error;
+	class_create_file(&cs->class, &class_attr_version);
+
+	return cs;
+
+      error:
+	kfree(cs);
+	return ERR_PTR(retval);
+}
+
+/**
+ * drm_sysfs_destroy - destroys a struct drm_sysfs_class structure
+ * @cs: pointer to the struct drm_sysfs_class that is to be destroyed
+ *
+ * Note, the pointer to be destroyed must have been created with a call to
+ * drm_sysfs_create().
+ */
+void drm_sysfs_destroy(struct drm_sysfs_class *cs)
+{
+	if ((cs == NULL) || (IS_ERR(cs)))
+		return;
+
+	class_unregister(&cs->class);
+}
+
+/**
+ * drm_sysfs_device_add - adds a class device to sysfs for a character driver
+ * @cs: pointer to the struct drm_sysfs_class that this device should be registered to.
+ * @dev: the dev_t for the device to be added.
+ * @device: a pointer to a struct device that is assiociated with this class device.
+ * @fmt: string for the class device's name
+ *
+ * A struct class_device will be created in sysfs, registered to the specified
+ * class.  A "dev" file will be created, showing the dev_t for the device.  The
+ * pointer to the struct class_device will be returned from the call.  Any further
+ * sysfs files that might be required can be created using this pointer.
+ * Note: the struct drm_sysfs_class passed to this function must have previously been
+ * created with a call to drm_sysfs_create().
+ */
+struct class_device *drm_sysfs_device_add(struct drm_sysfs_class *cs, dev_t dev,
+					  struct device *device,
+					  const char *fmt, ...)
+{
+	va_list args;
+	struct simple_dev *s_dev = NULL;
+	int retval;
+
+	if ((cs == NULL) || (IS_ERR(cs))) {
+		retval = -ENODEV;
+		goto error;
+	}
+
+	s_dev = kmalloc(sizeof(*s_dev), GFP_KERNEL);
+	if (!s_dev) {
+		retval = -ENOMEM;
+		goto error;
+	}
+	memset(s_dev, 0x00, sizeof(*s_dev));
+
+	s_dev->dev = dev;
+	s_dev->class_dev.dev = device;
+	s_dev->class_dev.class = &cs->class;
+
+	va_start(args, fmt);
+	vsnprintf(s_dev->class_dev.class_id, BUS_ID_SIZE, fmt, args);
+	va_end(args);
+	retval = class_device_register(&s_dev->class_dev);
+	if (retval)
+		goto error;
+
+	class_device_create_file(&s_dev->class_dev, &cs->attr);
+
+	spin_lock(&simple_dev_list_lock);
+	list_add(&s_dev->node, &simple_dev_list);
+	spin_unlock(&simple_dev_list_lock);
+
+	return &s_dev->class_dev;
+
+      error:
+	kfree(s_dev);
+	return ERR_PTR(retval);
+}
+
+/**
+ * drm_sysfs_device_remove - removes a class device that was created with drm_sysfs_device_add()
+ * @dev: the dev_t of the device that was previously registered.
+ *
+ * This call unregisters and cleans up a class device that was created with a
+ * call to drm_sysfs_device_add()
+ */
+void drm_sysfs_device_remove(dev_t dev)
+{
+	struct simple_dev *s_dev = NULL;
+	int found = 0;
+
+	spin_lock(&simple_dev_list_lock);
+	list_for_each_entry(s_dev, &simple_dev_list, node) {
+		if (s_dev->dev == dev) {
+			found = 1;
+			break;
+		}
+	}
+	if (found) {
+		list_del(&s_dev->node);
+		spin_unlock(&simple_dev_list_lock);
+		class_device_unregister(&s_dev->class_dev);
+	} else {
+		spin_unlock(&simple_dev_list_lock);
+	}
+}
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/ffb.h linux-2.6.11-rc3/drivers/char/drm/ffb.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/ffb.h	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/ffb.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-/* ffb.h -- ffb DRM template customization -*- linux-c -*-
- */
-
-#ifndef __FFB_H__
-#define __FFB_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) ffb_##x
-
-#endif
-
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/gamma.h linux-2.6.11-rc3/drivers/char/drm/gamma.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/gamma.h	2005-01-22 02:46:41.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/gamma.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/* gamma.c -- 3dlabs GMX 2000 driver -*- linux-c -*-
- * Created: Mon Jan  4 08:58:31 1999 by gareth@valinux.com
- *
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-#ifndef __GAMMA_H__
-#define __GAMMA_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) gamma_##x
-
-/* General customization:
- */
-#define DRIVER_AUTHOR		"VA Linux Systems Inc."
-
-#define DRIVER_NAME		"gamma"
-#define DRIVER_DESC		"3DLabs gamma"
-#define DRIVER_DATE		"20010624"
-
-#define DRIVER_MAJOR		2
-#define DRIVER_MINOR		0
-#define DRIVER_PATCHLEVEL	0
-
-#define DRIVER_IOCTLS							  \
-	[DRM_IOCTL_NR(DRM_IOCTL_DMA)]	     = { gamma_dma,	  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_GAMMA_INIT)] = { gamma_dma_init,  1, 1 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_GAMMA_COPY)] = { gamma_dma_copy,  1, 1 }
-
-#define IOCTL_TABLE_NAME	DRM(ioctls)
-#define IOCTL_FUNC_NAME 	DRM(ioctl)
-
-#define __HAVE_COUNTERS		5
-#define __HAVE_COUNTER6		_DRM_STAT_IRQ
-#define __HAVE_COUNTER7		_DRM_STAT_DMA
-#define __HAVE_COUNTER8		_DRM_STAT_PRIMARY
-#define __HAVE_COUNTER9		_DRM_STAT_SPECIAL
-#define __HAVE_COUNTER10	_DRM_STAT_MISSED
-
-/* Driver customization:
- */
-#define DRIVER_PRETAKEDOWN() do {					\
-	gamma_do_cleanup_dma( dev );					\
-} while (0)
-
-/* DMA customization:
- */
-#define __HAVE_MULTIPLE_DMA_QUEUES	1
-#define __HAVE_DMA_WAITQUEUE		1
-
-/* removed from DRM HAVE_DMA_FREELIST & HAVE_DMA_SCHEDULE */
-
-#endif /* __GAMMA_H__ */
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i810.h linux-2.6.11-rc3/drivers/char/drm/i810.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i810.h	2005-01-22 02:47:33.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i810.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/* i810.h -- Intel i810/i815 DRM template customization -*- linux-c -*-
- * Created: Thu Feb 15 00:01:12 2001 by gareth@valinux.com
- *
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-#ifndef __I810_H__
-#define __I810_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) i810_##x
-
-/* General customization:
- */
-
-#define DRIVER_AUTHOR		"VA Linux Systems Inc."
-
-#define DRIVER_NAME		"i810"
-#define DRIVER_DESC		"Intel i810"
-#define DRIVER_DATE		"20030605"
-
-/* Interface history
- *
- * 1.1   - XFree86 4.1
- * 1.2   - XvMC interfaces
- *       - XFree86 4.2
- * 1.2.1 - Disable copying code (leave stub ioctls for backwards compatibility)
- *       - Remove requirement for interrupt (leave stubs again)
- * 1.3   - Add page flipping.
- * 1.4   - fix DRM interface
- */
-#define DRIVER_MAJOR		1
-#define DRIVER_MINOR		4
-#define DRIVER_PATCHLEVEL	0
-
-#define DRIVER_IOCTLS							    \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_INIT)]   = { i810_dma_init,    1, 1 }, \
-   	[DRM_IOCTL_NR(DRM_IOCTL_I810_VERTEX)] = { i810_dma_vertex,  1, 0 }, \
-   	[DRM_IOCTL_NR(DRM_IOCTL_I810_CLEAR)]  = { i810_clear_bufs,  1, 0 }, \
-      	[DRM_IOCTL_NR(DRM_IOCTL_I810_FLUSH)]  = { i810_flush_ioctl, 1, 0 }, \
-   	[DRM_IOCTL_NR(DRM_IOCTL_I810_GETAGE)] = { i810_getage,      1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_GETBUF)] = { i810_getbuf,      1, 0 }, \
-   	[DRM_IOCTL_NR(DRM_IOCTL_I810_SWAP)]   = { i810_swap_bufs,   1, 0 }, \
-   	[DRM_IOCTL_NR(DRM_IOCTL_I810_COPY)]   = { i810_copybuf,     1, 0 }, \
-   	[DRM_IOCTL_NR(DRM_IOCTL_I810_DOCOPY)] = { i810_docopy,      1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_OV0INFO)] = { i810_ov0_info,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_FSTATUS)] = { i810_fstatus,    1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_OV0FLIP)] = { i810_ov0_flip,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_MC)]      = { i810_dma_mc,     1, 1 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_RSTATUS)] = { i810_rstatus,    1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I810_FLIP)] =    { i810_flip_bufs,  1, 0 }
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i810_dma.c linux-2.6.11-rc3/drivers/char/drm/i810_dma.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i810_dma.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i810_dma.c	2005-02-03 02:55:36.000000000 +0100
@@ -50,6 +50,26 @@
 #define up_write up
 #endif
 
+drm_ioctl_desc_t i810_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_I810_INIT)]    = { i810_dma_init,    1, 1 },
+	[DRM_IOCTL_NR(DRM_I810_VERTEX)]  = { i810_dma_vertex,  1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_CLEAR)]   = { i810_clear_bufs,  1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_FLUSH)]   = { i810_flush_ioctl, 1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_GETAGE)]  = { i810_getage,      1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_GETBUF)]  = { i810_getbuf,      1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_SWAP)]    = { i810_swap_bufs,   1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_COPY)]    = { i810_copybuf,     1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_DOCOPY)]  = { i810_docopy,      1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_OV0INFO)] = { i810_ov0_info,    1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_FSTATUS)] = { i810_fstatus,     1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_OV0FLIP)] = { i810_ov0_flip,    1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_MC)]      = { i810_dma_mc,      1, 1 },
+	[DRM_IOCTL_NR(DRM_I810_RSTATUS)] = { i810_rstatus,     1, 0 },
+	[DRM_IOCTL_NR(DRM_I810_FLIP)]    = { i810_flip_bufs,   1, 0 }
+};
+
+int i810_max_ioctl = DRM_ARRAY_SIZE(i810_ioctls);
+
 static drm_buf_t *i810_freelist_get(drm_device_t *dev)
 {
    	drm_device_dma_t *dma = dev->dma;
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i810_drv.c linux-2.6.11-rc3/drivers/char/drm/i810_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i810_drv.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i810_drv.c	2005-02-03 02:56:53.000000000 +0100
@@ -76,23 +76,8 @@ static struct pci_device_id pciidlist[] 
 	i810_PCI_IDS
 };
 
-static drm_ioctl_desc_t ioctls[] = {
-	[DRM_IOCTL_NR(DRM_I810_INIT)]    = { i810_dma_init,    1, 1 },
-	[DRM_IOCTL_NR(DRM_I810_VERTEX)]  = { i810_dma_vertex,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_CLEAR)]   = { i810_clear_bufs,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_FLUSH)]   = { i810_flush_ioctl, 1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_GETAGE)]  = { i810_getage,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_GETBUF)]  = { i810_getbuf,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_SWAP)]    = { i810_swap_bufs,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_COPY)]    = { i810_copybuf,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_DOCOPY)]  = { i810_docopy,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_OV0INFO)] = { i810_ov0_info,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_FSTATUS)] = { i810_fstatus,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_OV0FLIP)] = { i810_ov0_flip,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_MC)]      = { i810_dma_mc,      1, 1 },
-	[DRM_IOCTL_NR(DRM_I810_RSTATUS)] = { i810_rstatus,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I810_FLIP)]    = { i810_flip_bufs,   1, 0 }
-};
+extern drm_ioctl_desc_t i810_ioctls[];
+extern int i810_max_ioctl;
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_DMA | DRIVER_DMA_QUEUE,
@@ -105,8 +90,7 @@ static struct drm_driver driver = {
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.ioctls = i810_ioctls,
 	.fops = {
 		.owner = THIS_MODULE,
 		.open = drm_open,
@@ -124,6 +108,7 @@ static struct drm_driver driver = {
 
 static int __init i810_init(void)
 {
+	driver.num_ioctls = i810_max_ioctl;
 	return drm_init(&driver);
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i830.h linux-2.6.11-rc3/drivers/char/drm/i830.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i830.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i830.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-/* i830.h -- Intel I830 DRM template customization -*- linux-c -*-
- * Created: Thu Feb 15 00:01:12 2001 by gareth@valinux.com
- *
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-#ifndef __I830_H__
-#define __I830_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) i830_##x
-
-/* General customization:
- */
-
-#define DRIVER_AUTHOR		"VA Linux Systems Inc."
-
-#define DRIVER_NAME		"i830"
-#define DRIVER_DESC		"Intel 830M"
-#define DRIVER_DATE		"20021108"
-
-/* Interface history:
- *
- * 1.1: Original.
- * 1.2: ?
- * 1.3: New irq emit/wait ioctls.
- *      New pageflip ioctl.
- *      New getparam ioctl.
- *      State for texunits 3&4 in sarea.
- *      New (alternative) layout for texture state.
- */
-#define DRIVER_MAJOR		1
-#define DRIVER_MINOR		3
-#define DRIVER_PATCHLEVEL	2
-
-#define DRIVER_IOCTLS							    \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_INIT)]   = { i830_dma_init,    1, 1 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_VERTEX)] = { i830_dma_vertex,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_CLEAR)]  = { i830_clear_bufs,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_FLUSH)]  = { i830_flush_ioctl, 1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_GETAGE)] = { i830_getage,      1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_GETBUF)] = { i830_getbuf,      1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_SWAP)]   = { i830_swap_bufs,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_COPY)]   = { i830_copybuf,     1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_DOCOPY)] = { i830_docopy,      1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_FLIP)]   = { i830_flip_bufs,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_IRQ_EMIT)] = { i830_irq_emit,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_IRQ_WAIT)] = { i830_irq_wait,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_GETPARAM)] = { i830_getparam,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I830_SETPARAM)] = { i830_setparam,  1, 0 } 
-
-/* Driver will work either way: IRQ's save cpu time when waiting for
- * the card, but are subject to subtle interactions between bios,
- * hardware and the driver.
- */
-/* XXX: Add vblank support? */
-#define USE_IRQS 0
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i830_dma.c linux-2.6.11-rc3/drivers/char/drm/i830_dma.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i830_dma.c	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i830_dma.c	2005-02-03 02:55:07.000000000 +0100
@@ -52,6 +52,25 @@
 #define up_write up
 #endif
 
+drm_ioctl_desc_t i830_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_I830_INIT)]     = { i830_dma_init,    1, 1 },
+	[DRM_IOCTL_NR(DRM_I830_VERTEX)]   = { i830_dma_vertex,  1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_CLEAR)]    = { i830_clear_bufs,  1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_FLUSH)]    = { i830_flush_ioctl, 1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_GETAGE)]   = { i830_getage,      1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_GETBUF)]   = { i830_getbuf,      1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_SWAP)]     = { i830_swap_bufs,   1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_COPY)]     = { i830_copybuf,     1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_DOCOPY)]   = { i830_docopy,      1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_FLIP)]     = { i830_flip_bufs,   1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_IRQ_EMIT)] = { i830_irq_emit,    1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_IRQ_WAIT)] = { i830_irq_wait,    1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_GETPARAM)] = { i830_getparam,    1, 0 },
+	[DRM_IOCTL_NR(DRM_I830_SETPARAM)] = { i830_setparam,    1, 0 } 
+};
+
+int i830_max_ioctl = DRM_ARRAY_SIZE(i830_ioctls);
+
 static inline void i830_print_status_page(drm_device_t *dev)
 {
    	drm_device_dma_t *dma = dev->dma;
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i830_drv.c linux-2.6.11-rc3/drivers/char/drm/i830_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i830_drv.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i830_drv.c	2005-02-03 02:55:35.000000000 +0100
@@ -77,22 +77,8 @@ static struct pci_device_id pciidlist[] 
 	i830_PCI_IDS
 };
 
-static drm_ioctl_desc_t ioctls[] = {
-	[DRM_IOCTL_NR(DRM_I830_INIT)]     = { i830_dma_init,    1, 1 },
-	[DRM_IOCTL_NR(DRM_I830_VERTEX)]   = { i830_dma_vertex,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_CLEAR)]    = { i830_clear_bufs,  1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_FLUSH)]    = { i830_flush_ioctl, 1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_GETAGE)]   = { i830_getage,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_GETBUF)]   = { i830_getbuf,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_SWAP)]     = { i830_swap_bufs,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_COPY)]     = { i830_copybuf,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_DOCOPY)]   = { i830_docopy,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_FLIP)]     = { i830_flip_bufs,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_IRQ_EMIT)] = { i830_irq_emit,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_IRQ_WAIT)] = { i830_irq_wait,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_GETPARAM)] = { i830_getparam,    1, 0 },
-	[DRM_IOCTL_NR(DRM_I830_SETPARAM)] = { i830_setparam,    1, 0 } 
-};
+extern drm_ioctl_desc_t i830_ioctls[];
+extern int i830_max_ioctl;
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_DMA | DRIVER_DMA_QUEUE,
@@ -114,8 +100,7 @@ static struct drm_driver driver = {
 #endif
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.ioctls = i830_ioctls,
 	.fops = {
 		.owner = THIS_MODULE,
 		.open = drm_open,
@@ -134,6 +119,7 @@ static struct drm_driver driver = {
 
 static int __init i830_init(void)
 {
+	driver.num_ioctls = i830_max_ioctl;
 	return drm_init(&driver);
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i915.h linux-2.6.11-rc3/drivers/char/drm/i915.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i915.h	2005-01-22 02:46:42.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i915.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/* i915.h -- Intel I915 DRM template customization -*- linux-c -*-
- */
-/**************************************************************************
- * 
- * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- * 
- **************************************************************************/
-
-#ifndef __I915_H__
-#define __I915_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) i915_##x
-
-/* General customization:
- */
-
-#define DRIVER_AUTHOR		"Tungsten Graphics, Inc."
-
-#define DRIVER_NAME		"i915"
-#define DRIVER_DESC		"Intel Graphics"
-#define DRIVER_DATE		"20040405"
-
-/* Interface history:
- *
- * 1.1: Original.
- */
-#define DRIVER_MAJOR		1
-#define DRIVER_MINOR		1
-#define DRIVER_PATCHLEVEL	0
-
-#define DRIVER_IOCTLS							    \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_INIT)]   = { i915_dma_init,    1, 1 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_FLUSH)]  = { i915_flush_ioctl, 1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_FLIP)]   = { i915_flip_bufs,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_BATCHBUFFER)] = { i915_batchbuffer, 1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_IRQ_EMIT)] = { i915_irq_emit,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_IRQ_WAIT)] = { i915_irq_wait,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_GETPARAM)] = { i915_getparam,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_SETPARAM)] = { i915_setparam,  1, 1 }, \
-        [DRM_IOCTL_NR(DRM_IOCTL_I915_ALLOC)]   = { i915_mem_alloc,  1, 0 }, \
-        [DRM_IOCTL_NR(DRM_IOCTL_I915_FREE)]    = { i915_mem_free,    1, 0 }, \
-        [DRM_IOCTL_NR(DRM_IOCTL_I915_INIT_HEAP)] = { i915_mem_init_heap, 1, 1 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_I915_CMDBUFFER)] = { i915_cmdbuffer, 1, 0 }
-
-/* We use our own dma mechanisms, not the drm template code.  However,
- * the shared IRQ code is useful to us:
- */
-#define __HAVE_PM		1
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i915_dma.c linux-2.6.11-rc3/drivers/char/drm/i915_dma.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i915_dma.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i915_dma.c	2005-02-03 02:55:36.000000000 +0100
@@ -12,6 +12,23 @@
 #include "i915_drm.h"
 #include "i915_drv.h"
 
+drm_ioctl_desc_t i915_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_I915_INIT)] = {i915_dma_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_I915_FLUSH)] = {i915_flush_ioctl, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_FLIP)] = {i915_flip_bufs, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_BATCHBUFFER)] = {i915_batchbuffer, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_IRQ_EMIT)] = {i915_irq_emit, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_IRQ_WAIT)] = {i915_irq_wait, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_GETPARAM)] = {i915_getparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_SETPARAM)] = {i915_setparam, 1, 1},
+	[DRM_IOCTL_NR(DRM_I915_ALLOC)] = {i915_mem_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_FREE)] = {i915_mem_free, 1, 0},
+	[DRM_IOCTL_NR(DRM_I915_INIT_HEAP)] = {i915_mem_init_heap, 1, 1},
+	[DRM_IOCTL_NR(DRM_I915_CMDBUFFER)] = {i915_cmdbuffer, 1, 0}
+};
+
+int i915_max_ioctl = DRM_ARRAY_SIZE(i915_ioctls);
+
 /* Really want an OS-independent resettable timer.  Would like to have
  * this loop run for (eg) 3 sec, but have the timer reset every time
  * the head pointer changes, so that EBUSY only happens if the ring
@@ -76,9 +93,8 @@ int i915_dma_cleanup(drm_device_t * dev)
 		}
 
 		if (dev_priv->hw_status_page) {
-			pci_free_consistent(dev->pdev, PAGE_SIZE,
-					    dev_priv->hw_status_page,
-					    dev_priv->dma_status_page);
+			drm_pci_free(dev, PAGE_SIZE, dev_priv->hw_status_page,
+				     dev_priv->dma_status_page);
 			/* Need to rewrite hardware status page */
 			I915_WRITE(0x02080, 0x1ffff000);
 		}
@@ -155,9 +171,9 @@ static int i915_initialize(drm_device_t 
 	dev_priv->allow_batchbuffer = 1;
 
 	/* Program Hardware Status Page */
-	dev_priv->hw_status_page =
-	    pci_alloc_consistent(dev->pdev, PAGE_SIZE,
-				 &dev_priv->dma_status_page);
+	dev_priv->hw_status_page = drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE,
+						 0xffffffff, 
+						 &dev_priv->dma_status_page);
 
 	if (!dev_priv->hw_status_page) {
 		dev->dev_private = (void *)dev_priv;
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/i915_drv.c linux-2.6.11-rc3/drivers/char/drm/i915_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/i915_drv.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/i915_drv.c	2005-02-03 02:55:39.000000000 +0100
@@ -52,20 +52,8 @@ static struct pci_device_id pciidlist[] 
 	i915_PCI_IDS
 };
 
-static drm_ioctl_desc_t ioctls[] = {
-	[DRM_IOCTL_NR(DRM_I915_INIT)]        = { i915_dma_init,      1, 1 },
-	[DRM_IOCTL_NR(DRM_I915_FLUSH)]       = { i915_flush_ioctl,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_FLIP)]        = { i915_flip_bufs,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_BATCHBUFFER)] = { i915_batchbuffer,   1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_IRQ_EMIT)]    = { i915_irq_emit,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_IRQ_WAIT)]    = { i915_irq_wait,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_GETPARAM)]    = { i915_getparam,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_SETPARAM)]    = { i915_setparam,      1, 1 },
-	[DRM_IOCTL_NR(DRM_I915_ALLOC)]       = { i915_mem_alloc,     1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_FREE)]        = { i915_mem_free,      1, 0 },
-	[DRM_IOCTL_NR(DRM_I915_INIT_HEAP)]   = { i915_mem_init_heap, 1, 1 },
-	[DRM_IOCTL_NR(DRM_I915_CMDBUFFER)]   = { i915_cmdbuffer,     1, 0 }
-};
+extern drm_ioctl_desc_t i915_ioctls[];
+extern int i915_max_ioctl;
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
@@ -81,8 +69,7 @@ static struct drm_driver driver = {
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.ioctls = i915_ioctls,
 	.fops = {
 		.owner = THIS_MODULE,
 		.open = drm_open,
@@ -100,6 +87,7 @@ static struct drm_driver driver = {
 
 static int __init i915_init(void)
 {
+	driver.num_ioctls = i915_max_ioctl;
 	return drm_init(&driver);
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/mga.h linux-2.6.11-rc3/drivers/char/drm/mga.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/mga.h	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/mga.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-/* mga.h -- Matrox G200/G400 DRM template customization -*- linux-c -*-
- * Created: Thu Jan 11 21:29:32 2001 by gareth@valinux.com
- *
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-#ifndef __MGA_H__
-#define __MGA_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) mga_##x
-
-/* General customization:
- */
-
-#define DRIVER_AUTHOR		"Gareth Hughes, VA Linux Systems Inc."
-
-#define DRIVER_NAME		"mga"
-#define DRIVER_DESC		"Matrox G200/G400"
-#define DRIVER_DATE		"20021029"
-
-#define DRIVER_MAJOR		3
-#define DRIVER_MINOR		1
-#define DRIVER_PATCHLEVEL	0
-
-#define DRIVER_IOCTLS							   \
-	[DRM_IOCTL_NR(DRM_IOCTL_DMA)]	      = { mga_dma_buffers, 1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_INIT)]    = { mga_dma_init,    1, 1 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_FLUSH)]   = { mga_dma_flush,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_RESET)]   = { mga_dma_reset,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_SWAP)]    = { mga_dma_swap,    1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_CLEAR)]   = { mga_dma_clear,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_VERTEX)]  = { mga_dma_vertex,  1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_INDICES)] = { mga_dma_indices, 1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_ILOAD)]   = { mga_dma_iload,   1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_BLIT)]    = { mga_dma_blit,    1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_MGA_GETPARAM)]= { mga_getparam,    1, 0 },
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/mga_drv.c linux-2.6.11-rc3/drivers/char/drm/mga_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/mga_drv.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/mga_drv.c	2005-02-03 02:55:50.000000000 +0100
@@ -74,18 +74,8 @@ static struct pci_device_id pciidlist[] 
 	mga_PCI_IDS
 };
 
-static drm_ioctl_desc_t ioctls[] = {
-	[DRM_IOCTL_NR(DRM_MGA_INIT)]    = { mga_dma_init,    1, 1 },
-	[DRM_IOCTL_NR(DRM_MGA_FLUSH)]   = { mga_dma_flush,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_RESET)]   = { mga_dma_reset,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_SWAP)]    = { mga_dma_swap,    1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_CLEAR)]   = { mga_dma_clear,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_VERTEX)]  = { mga_dma_vertex,  1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_INDICES)] = { mga_dma_indices, 1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_ILOAD)]   = { mga_dma_iload,   1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_BLIT)]    = { mga_dma_blit,    1, 0 },
-	[DRM_IOCTL_NR(DRM_MGA_GETPARAM)]= { mga_getparam,    1, 0 },
-};
+extern drm_ioctl_desc_t mga_ioctls[];
+extern int mga_max_ioctl;
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR | DRIVER_HAVE_DMA | DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
@@ -101,8 +91,7 @@ static struct drm_driver driver = {
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.ioctls = mga_ioctls,
 	.dma_ioctl = mga_dma_buffers,
 	.fops = {
 		.owner = THIS_MODULE,
@@ -121,6 +110,7 @@ static struct drm_driver driver = {
 
 static int __init mga_init(void)
 {
+	driver.num_ioctls = mga_max_ioctl;
 	return drm_init(&driver);
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/mga_state.c linux-2.6.11-rc3/drivers/char/drm/mga_state.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/mga_state.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/mga_state.c	2005-02-03 02:55:37.000000000 +0100
@@ -37,6 +37,20 @@
 #include "mga_drm.h"
 #include "mga_drv.h"
 
+drm_ioctl_desc_t mga_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_MGA_INIT)]    = { mga_dma_init,    1, 1 },
+	[DRM_IOCTL_NR(DRM_MGA_FLUSH)]   = { mga_dma_flush,   1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_RESET)]   = { mga_dma_reset,   1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_SWAP)]    = { mga_dma_swap,    1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_CLEAR)]   = { mga_dma_clear,   1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_VERTEX)]  = { mga_dma_vertex,  1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_INDICES)] = { mga_dma_indices, 1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_ILOAD)]   = { mga_dma_iload,   1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_BLIT)]    = { mga_dma_blit,    1, 0 },
+	[DRM_IOCTL_NR(DRM_MGA_GETPARAM)]= { mga_getparam,    1, 0 },
+};
+
+int mga_max_ioctl = DRM_ARRAY_SIZE(mga_ioctls);
 
 /* ================================================================
  * DMA hardware state programming functions
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/r128.h linux-2.6.11-rc3/drivers/char/drm/r128.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/r128.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/r128.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/* r128.h -- ATI Rage 128 DRM template customization -*- linux-c -*-
- * Created: Wed Feb 14 16:07:10 2001 by gareth@valinux.com
- *
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Gareth Hughes <gareth@valinux.com>
- */
-
-#ifndef __R128_H__
-#define __R128_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) r128_##x
-
-/* General customization:
- */
-#define DRIVER_AUTHOR		"Gareth Hughes, VA Linux Systems Inc."
-
-#define DRIVER_NAME		"r128"
-#define DRIVER_DESC		"ATI Rage 128"
-#define DRIVER_DATE		"20030725"
-
-#define DRIVER_MAJOR		2
-#define DRIVER_MINOR		5
-#define DRIVER_PATCHLEVEL	0
-
-/* Interface history:
- *
- * ??  - ??
- * 2.4 - Add support for ycbcr textures (no new ioctls)
- * 2.5 - Add FLIP ioctl, disable FULLSCREEN.
- */
-#define DRIVER_IOCTLS							    \
-   [DRM_IOCTL_NR(DRM_IOCTL_DMA)]             = { r128_cce_buffers,  1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_INIT)]       = { r128_cce_init,     1, 1 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_START)]  = { r128_cce_start,    1, 1 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_STOP)]   = { r128_cce_stop,     1, 1 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_RESET)]  = { r128_cce_reset,    1, 1 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_IDLE)]   = { r128_cce_idle,     1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_RESET)]      = { r128_engine_reset, 1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_FULLSCREEN)] = { r128_fullscreen,   1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_SWAP)]       = { r128_cce_swap,     1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_FLIP)]       = { r128_cce_flip,     1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_CLEAR)]      = { r128_cce_clear,    1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_VERTEX)]     = { r128_cce_vertex,   1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_INDICES)]    = { r128_cce_indices,  1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_BLIT)]       = { r128_cce_blit,     1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_DEPTH)]      = { r128_cce_depth,    1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_STIPPLE)]    = { r128_cce_stipple,  1, 0 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_INDIRECT)]   = { r128_cce_indirect, 1, 1 }, \
-   [DRM_IOCTL_NR(DRM_IOCTL_R128_GETPARAM)]   = { r128_getparam, 1, 0 },
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/r128_drv.c linux-2.6.11-rc3/drivers/char/drm/r128_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/r128_drv.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/r128_drv.c	2005-02-03 02:55:23.000000000 +0100
@@ -68,31 +68,8 @@ static struct pci_device_id pciidlist[] 
 	r128_PCI_IDS
 };
 
-/* Interface history:
- *
- * ??  - ??
- * 2.4 - Add support for ycbcr textures (no new ioctls)
- * 2.5 - Add FLIP ioctl, disable FULLSCREEN.
- */
-static drm_ioctl_desc_t ioctls[] = {
-   [DRM_IOCTL_NR(DRM_R128_INIT)]       = { r128_cce_init,     1, 1 },
-   [DRM_IOCTL_NR(DRM_R128_CCE_START)]  = { r128_cce_start,    1, 1 },
-   [DRM_IOCTL_NR(DRM_R128_CCE_STOP)]   = { r128_cce_stop,     1, 1 },
-   [DRM_IOCTL_NR(DRM_R128_CCE_RESET)]  = { r128_cce_reset,    1, 1 },
-   [DRM_IOCTL_NR(DRM_R128_CCE_IDLE)]   = { r128_cce_idle,     1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_RESET)]      = { r128_engine_reset, 1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_FULLSCREEN)] = { r128_fullscreen,   1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_SWAP)]       = { r128_cce_swap,     1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_FLIP)]       = { r128_cce_flip,     1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_CLEAR)]      = { r128_cce_clear,    1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_VERTEX)]     = { r128_cce_vertex,   1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_INDICES)]    = { r128_cce_indices,  1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_BLIT)]       = { r128_cce_blit,     1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_DEPTH)]      = { r128_cce_depth,    1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_STIPPLE)]    = { r128_cce_stipple,  1, 0 },
-   [DRM_IOCTL_NR(DRM_R128_INDIRECT)]   = { r128_cce_indirect, 1, 1 },
-   [DRM_IOCTL_NR(DRM_R128_GETPARAM)]   = { r128_getparam, 1, 0 },
-};
+extern drm_ioctl_desc_t r128_ioctls[];
+extern int r128_max_ioctl;
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_SG | DRIVER_HAVE_DMA | DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
@@ -109,8 +86,7 @@ static struct drm_driver driver = {
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.ioctls = r128_ioctls,
 	.dma_ioctl = r128_cce_buffers,
 	.fops = {
 		.owner = THIS_MODULE,
@@ -129,6 +105,7 @@ static struct drm_driver driver = {
 
 static int __init r128_init(void)
 {
+	driver.num_ioctls = r128_max_ioctl;
 	return drm_init(&driver);
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/r128_drv.h linux-2.6.11-rc3/drivers/char/drm/r128_drv.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/r128_drv.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/r128_drv.h	2005-02-03 02:57:04.000000000 +0100
@@ -42,6 +42,12 @@
 #define DRIVER_DESC		"ATI Rage 128"
 #define DRIVER_DATE		"20030725"
 
+/* Interface history:
+ *
+ * ??  - ??
+ * 2.4 - Add support for ycbcr textures (no new ioctls)
+ * 2.5 - Add FLIP ioctl, disable FULLSCREEN.
+ */
 #define DRIVER_MAJOR		2
 #define DRIVER_MINOR		5
 #define DRIVER_PATCHLEVEL	0
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/r128_state.c linux-2.6.11-rc3/drivers/char/drm/r128_state.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/r128_state.c	2005-01-22 02:47:18.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/r128_state.c	2005-02-03 02:55:15.000000000 +0100
@@ -32,6 +32,27 @@
 #include "r128_drm.h"
 #include "r128_drv.h"
 
+drm_ioctl_desc_t r128_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_R128_INIT)]       = { r128_cce_init,     1, 1 },
+	[DRM_IOCTL_NR(DRM_R128_CCE_START)]  = { r128_cce_start,    1, 1 },
+	[DRM_IOCTL_NR(DRM_R128_CCE_STOP)]   = { r128_cce_stop,     1, 1 },
+	[DRM_IOCTL_NR(DRM_R128_CCE_RESET)]  = { r128_cce_reset,    1, 1 },
+	[DRM_IOCTL_NR(DRM_R128_CCE_IDLE)]   = { r128_cce_idle,     1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_RESET)]      = { r128_engine_reset, 1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_FULLSCREEN)] = { r128_fullscreen,   1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_SWAP)]       = { r128_cce_swap,     1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_FLIP)]       = { r128_cce_flip,     1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_CLEAR)]      = { r128_cce_clear,    1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_VERTEX)]     = { r128_cce_vertex,   1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_INDICES)]    = { r128_cce_indices,  1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_BLIT)]       = { r128_cce_blit,     1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_DEPTH)]      = { r128_cce_depth,    1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_STIPPLE)]    = { r128_cce_stipple,  1, 0 },
+	[DRM_IOCTL_NR(DRM_R128_INDIRECT)]   = { r128_cce_indirect, 1, 1 },
+	[DRM_IOCTL_NR(DRM_R128_GETPARAM)]   = { r128_getparam, 1, 0 },
+};
+
+int r128_max_ioctl = DRM_ARRAY_SIZE(r128_ioctls);
 
 /* ================================================================
  * CCE hardware state programming functions
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/radeon.h linux-2.6.11-rc3/drivers/char/drm/radeon.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/radeon.h	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/radeon.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/* radeon.h -- ATI Radeon DRM template customization -*- linux-c -*-
- * Created: Wed Feb 14 17:07:34 2001 by gareth@valinux.com
- *
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Gareth Hughes <gareth@valinux.com>
- *    Keith Whitwell <keith@tungstengraphics.com>
- */
-
-#ifndef __RADEON_H__
-#define __RADEON_H__
-
-/* This remains constant for all DRM template files.
- */
-#define DRM(x) radeon_##x
-
-/* General customization:
- */
-
-#define DRIVER_AUTHOR		"Gareth Hughes, Keith Whitwell, others."
-
-#define DRIVER_NAME		"radeon"
-#define DRIVER_DESC		"ATI Radeon"
-#define DRIVER_DATE		"20020828"
-
-#define DRIVER_MAJOR		1
-#define DRIVER_MINOR		11
-#define DRIVER_PATCHLEVEL	0
-
-/* Interface history:
- *
- * 1.1 - ??
- * 1.2 - Add vertex2 ioctl (keith)
- *     - Add stencil capability to clear ioctl (gareth, keith)
- *     - Increase MAX_TEXTURE_LEVELS (brian)
- * 1.3 - Add cmdbuf ioctl (keith)
- *     - Add support for new radeon packets (keith)
- *     - Add getparam ioctl (keith)
- *     - Add flip-buffers ioctl, deprecate fullscreen foo (keith).
- * 1.4 - Add scratch registers to get_param ioctl.
- * 1.5 - Add r200 packets to cmdbuf ioctl
- *     - Add r200 function to init ioctl
- *     - Add 'scalar2' instruction to cmdbuf
- * 1.6 - Add static GART memory manager
- *       Add irq handler (won't be turned on unless X server knows to)
- *       Add irq ioctls and irq_active getparam.
- *       Add wait command for cmdbuf ioctl
- *       Add GART offset query for getparam
- * 1.7 - Add support for cube map registers: R200_PP_CUBIC_FACES_[0..5]
- *       and R200_PP_CUBIC_OFFSET_F1_[0..5].
- *       Added packets R200_EMIT_PP_CUBIC_FACES_[0..5] and
- *       R200_EMIT_PP_CUBIC_OFFSETS_[0..5].  (brian)
- * 1.8 - Remove need to call cleanup ioctls on last client exit (keith)
- *       Add 'GET' queries for starting additional clients on different VT's.
- * 1.9 - Add DRM_IOCTL_RADEON_CP_RESUME ioctl.
- *       Add texture rectangle support for r100.
- * 1.10- Add SETPARAM ioctl; first parameter to set is FB_LOCATION, which
- *       clients use to tell the DRM where they think the framebuffer is 
- *       located in the card's address space
- * 1.11- Add packet R200_EMIT_RB3D_BLENDCOLOR to support GL_EXT_blend_color
- *       and GL_EXT_blend_[func|equation]_separate on r200
- */
-#define DRIVER_IOCTLS							     \
- [DRM_IOCTL_NR(DRM_IOCTL_DMA)]               = { radeon_cp_buffers,  1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_INIT)]    = { radeon_cp_init,     1, 1 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_START)]   = { radeon_cp_start,    1, 1 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_STOP)]    = { radeon_cp_stop,     1, 1 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_RESET)]   = { radeon_cp_reset,    1, 1 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_IDLE)]    = { radeon_cp_idle,     1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_RESUME)]  = { radeon_cp_resume,   1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_RESET)]    = { radeon_engine_reset,  1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_FULLSCREEN)] = { radeon_fullscreen,  1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_SWAP)]       = { radeon_cp_swap,     1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CLEAR)]      = { radeon_cp_clear,    1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_VERTEX)]     = { radeon_cp_vertex,   1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_INDICES)]    = { radeon_cp_indices,  1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_TEXTURE)]    = { radeon_cp_texture,  1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_STIPPLE)]    = { radeon_cp_stipple,  1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_INDIRECT)]   = { radeon_cp_indirect, 1, 1 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_VERTEX2)]    = { radeon_cp_vertex2,  1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_CMDBUF)]     = { radeon_cp_cmdbuf,   1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_GETPARAM)]   = { radeon_cp_getparam, 1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_FLIP)]       = { radeon_cp_flip,     1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_ALLOC)]      = { radeon_mem_alloc,   1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_FREE)]       = { radeon_mem_free,    1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_INIT_HEAP)]  = { radeon_mem_init_heap, 1, 1 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_IRQ_EMIT)]   = { radeon_irq_emit,    1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_IRQ_WAIT)]   = { radeon_irq_wait,    1, 0 }, \
- [DRM_IOCTL_NR(DRM_IOCTL_RADEON_SETPARAM)]   = { radeon_cp_setparam, 1, 0 }, \
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_cp.c linux-2.6.11-rc3/drivers/char/drm/radeon_cp.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_cp.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/radeon_cp.c	2005-02-03 02:55:15.000000000 +0100
@@ -556,6 +556,264 @@ static u32 radeon_cp_microcode[][2] = {
 	{ 0000000000, 0000000000 },
 };
 
+static u32 R300_cp_microcode[][2] = {
+	{ 0x4200e000, 0000000000 },
+	{ 0x4000e000, 0000000000 },
+	{ 0x000000af, 0x00000008 },
+	{ 0x000000b3, 0x00000008 },
+	{ 0x6c5a504f, 0000000000 },
+	{ 0x4f4f497a, 0000000000 },
+	{ 0x5a578288, 0000000000 },
+	{ 0x4f91906a, 0000000000 },
+	{ 0x4f4f4f4f, 0000000000 },
+	{ 0x4fe24f44, 0000000000 },
+	{ 0x4f9c9c9c, 0000000000 },
+	{ 0xdc4f4fde, 0000000000 },
+	{ 0xa1cd4f4f, 0000000000 },
+	{ 0xd29d9d9d, 0000000000 },
+	{ 0x4f0f9fd7, 0000000000 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x000d0012, 0x00000038 },
+	{ 0x0000e8b4, 0x00000004 },
+	{ 0x000d0014, 0x00000038 },
+	{ 0x0000e8b6, 0x00000004 },
+	{ 0x000d0016, 0x00000038 },
+	{ 0x0000e854, 0x00000004 },
+	{ 0x000d0018, 0x00000038 },
+	{ 0x0000e855, 0x00000004 },
+	{ 0x000d001a, 0x00000038 },
+	{ 0x0000e856, 0x00000004 },
+	{ 0x000d001c, 0x00000038 },
+	{ 0x0000e857, 0x00000004 },
+	{ 0x000d001e, 0x00000038 },
+	{ 0x0000e824, 0x00000004 },
+	{ 0x000d0020, 0x00000038 },
+	{ 0x0000e825, 0x00000004 },
+	{ 0x000d0022, 0x00000038 },
+	{ 0x0000e830, 0x00000004 },
+	{ 0x000d0024, 0x00000038 },
+	{ 0x0000f0c0, 0x00000004 },
+	{ 0x000d0026, 0x00000038 },
+	{ 0x0000f0c1, 0x00000004 },
+	{ 0x000d0028, 0x00000038 },
+	{ 0x0000f041, 0x00000004 },
+	{ 0x000d002a, 0x00000038 },
+	{ 0x0000f184, 0x00000004 },
+	{ 0x000d002c, 0x00000038 },
+	{ 0x0000f185, 0x00000004 },
+	{ 0x000d002e, 0x00000038 },
+	{ 0x0000f186, 0x00000004 },
+	{ 0x000d0030, 0x00000038 },
+	{ 0x0000f187, 0x00000004 },
+	{ 0x000d0032, 0x00000038 },
+	{ 0x0000f180, 0x00000004 },
+	{ 0x000d0034, 0x00000038 },
+	{ 0x0000f393, 0x00000004 },
+	{ 0x000d0036, 0x00000038 },
+	{ 0x0000f38a, 0x00000004 },
+	{ 0x000d0038, 0x00000038 },
+	{ 0x0000f38e, 0x00000004 },
+	{ 0x0000e821, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00000043, 0x00000018 },
+	{ 0x00cce800, 0x00000004 },
+	{ 0x001b0001, 0x00000004 },
+	{ 0x08004800, 0x00000004 },
+	{ 0x001b0001, 0x00000004 },
+	{ 0x08004800, 0x00000004 },
+	{ 0x001b0001, 0x00000004 },
+	{ 0x08004800, 0x00000004 },
+	{ 0x0000003a, 0x00000008 },
+	{ 0x0000a000, 0000000000 },
+	{ 0x02c0a000, 0x00000004 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x00130000, 0x00000004 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0xc980c045, 0x00000008 },
+	{ 0x2000451d, 0x00000004 },
+	{ 0x0000e580, 0x00000004 },
+	{ 0x000ce581, 0x00000004 },
+	{ 0x08004580, 0x00000004 },
+	{ 0x000ce581, 0x00000004 },
+	{ 0x0000004c, 0x00000008 },
+	{ 0x0000a000, 0000000000 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x0000e50e, 0x00000004 },
+	{ 0x00032000, 0x00000004 },
+	{ 0x00022056, 0x00000028 },
+	{ 0x00000056, 0x00000024 },
+	{ 0x0800450f, 0x00000004 },
+	{ 0x0000a050, 0x00000008 },
+	{ 0x0000e565, 0x00000004 },
+	{ 0x0000e566, 0x00000004 },
+	{ 0x00000057, 0x00000008 },
+	{ 0x03cca5b4, 0x00000004 },
+	{ 0x05432000, 0x00000004 },
+	{ 0x00022000, 0x00000004 },
+	{ 0x4ccce063, 0x00000030 },
+	{ 0x08274565, 0x00000004 },
+	{ 0x00000063, 0x00000030 },
+	{ 0x08004564, 0x00000004 },
+	{ 0x0000e566, 0x00000004 },
+	{ 0x0000005a, 0x00000008 },
+	{ 0x00802066, 0x00000010 },
+	{ 0x00202000, 0x00000004 },
+	{ 0x001b00ff, 0x00000004 },
+	{ 0x01000069, 0x00000010 },
+	{ 0x001f2000, 0x00000004 },
+	{ 0x001c00ff, 0x00000004 },
+	{ 0000000000, 0x0000000c },
+	{ 0x00000085, 0x00000030 },
+	{ 0x0000005a, 0x00000008 },
+	{ 0x0000e576, 0x00000004 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x00012000, 0x00000004 },
+	{ 0x00082000, 0x00000004 },
+	{ 0x1800650e, 0x00000004 },
+	{ 0x00092000, 0x00000004 },
+	{ 0x000a2000, 0x00000004 },
+	{ 0x000f0000, 0x00000004 },
+	{ 0x00400000, 0x00000004 },
+	{ 0x00000079, 0x00000018 },
+	{ 0x0000e563, 0x00000004 },
+	{ 0x00c0e5f9, 0x000000c2 },
+	{ 0x0000006e, 0x00000008 },
+	{ 0x0000a06e, 0x00000008 },
+	{ 0x0000e576, 0x00000004 },
+	{ 0x0000e577, 0x00000004 },
+	{ 0x0000e50e, 0x00000004 },
+	{ 0x0000e50f, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x0000007c, 0x00000018 },
+	{ 0x00c0e5f9, 0x000000c2 },
+	{ 0x0000007c, 0x00000008 },
+	{ 0x0014e50e, 0x00000004 },
+	{ 0x0040e50f, 0x00000004 },
+	{ 0x00c0007f, 0x00000008 },
+	{ 0x0000e570, 0x00000004 },
+	{ 0x0000e571, 0x00000004 },
+	{ 0x0000e572, 0x0000000c },
+	{ 0x0000a000, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x0000e568, 0x00000004 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x00000089, 0x00000018 },
+	{ 0x000b0000, 0x00000004 },
+	{ 0x18c0e562, 0x00000004 },
+	{ 0x0000008b, 0x00000008 },
+	{ 0x00c0008a, 0x00000008 },
+	{ 0x000700e4, 0x00000004 },
+	{ 0x00000097, 0x00000038 },
+	{ 0x000ca099, 0x00000030 },
+	{ 0x080045bb, 0x00000004 },
+	{ 0x000c209a, 0x00000030 },
+	{ 0x0800e5bc, 0000000000 },
+	{ 0x0000e5bb, 0x00000004 },
+	{ 0x0000e5bc, 0000000000 },
+	{ 0x00120000, 0x0000000c },
+	{ 0x00120000, 0x00000004 },
+	{ 0x001b0002, 0x0000000c },
+	{ 0x0000a000, 0x00000004 },
+	{ 0x0000e821, 0x00000004 },
+	{ 0x0000e800, 0000000000 },
+	{ 0x0000e821, 0x00000004 },
+	{ 0x0000e82e, 0000000000 },
+	{ 0x02cca000, 0x00000004 },
+	{ 0x00140000, 0x00000004 },
+	{ 0x000ce1cc, 0x00000004 },
+	{ 0x050de1cd, 0x00000004 },
+	{ 0x000000a7, 0x00000020 },
+	{ 0x4200e000, 0000000000 },
+	{ 0x000000ae, 0x00000038 },
+	{ 0x000ca000, 0x00000004 },
+	{ 0x00140000, 0x00000004 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x00160000, 0x00000004 },
+	{ 0x700ce000, 0x00000004 },
+	{ 0x001400aa, 0x00000008 },
+	{ 0x4000e000, 0000000000 },
+	{ 0x02400000, 0x00000004 },
+	{ 0x400ee000, 0x00000004 },
+	{ 0x02400000, 0x00000004 },
+	{ 0x4000e000, 0000000000 },
+	{ 0x000c2000, 0x00000004 },
+	{ 0x0240e51b, 0x00000004 },
+	{ 0x0080e50a, 0x00000005 },
+	{ 0x0080e50b, 0x00000005 },
+	{ 0x00220000, 0x00000004 },
+	{ 0x000700e4, 0x00000004 },
+	{ 0x000000c1, 0x00000038 },
+	{ 0x000c209a, 0x00000030 },
+	{ 0x0880e5bd, 0x00000005 },
+	{ 0x000c2099, 0x00000030 },
+	{ 0x0800e5bb, 0x00000005 },
+	{ 0x000c209a, 0x00000030 },
+	{ 0x0880e5bc, 0x00000005 },
+	{ 0x000000c4, 0x00000008 },
+	{ 0x0080e5bd, 0x00000005 },
+	{ 0x0000e5bb, 0x00000005 },
+	{ 0x0080e5bc, 0x00000005 },
+	{ 0x00210000, 0x00000004 },
+	{ 0x02800000, 0x00000004 },
+	{ 0x00c000c8, 0x00000018 },
+	{ 0x4180e000, 0x00000040 },
+	{ 0x000000ca, 0x00000024 },
+	{ 0x01000000, 0x0000000c },
+	{ 0x0100e51d, 0x0000000c },
+	{ 0x000045bb, 0x00000004 },
+	{ 0x000080c4, 0x00000008 },
+	{ 0x0000f3ce, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00cc2000, 0x00000004 },
+	{ 0x08c053cf, 0x00000040 },
+	{ 0x00008000, 0000000000 },
+	{ 0x0000f3d2, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00cc2000, 0x00000004 },
+	{ 0x08c053d3, 0x00000040 },
+	{ 0x00008000, 0000000000 },
+	{ 0x0000f39d, 0x00000004 },
+	{ 0x0140a000, 0x00000004 },
+	{ 0x00cc2000, 0x00000004 },
+	{ 0x08c0539e, 0x00000040 },
+	{ 0x00008000, 0000000000 },
+	{ 0x03c00830, 0x00000004 },
+	{ 0x4200e000, 0000000000 },
+	{ 0x0000a000, 0x00000004 },
+	{ 0x200045e0, 0x00000004 },
+	{ 0x0000e5e1, 0000000000 },
+	{ 0x00000001, 0000000000 },
+	{ 0x000700e1, 0x00000004 },
+	{ 0x0800e394, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+};
 
 int RADEON_READ_PLL(drm_device_t *dev, int addr)
 {
@@ -680,8 +938,7 @@ static void radeon_cp_load_microcode( dr
 
 	RADEON_WRITE( RADEON_CP_ME_RAM_ADDR, 0 );
 
-	if (dev_priv->is_r200)
-	{
+	if (dev_priv->microcode_version==UCODE_R200) {
 		DRM_INFO("Loading R200 Microcode\n");
 		for ( i = 0 ; i < 256 ; i++ ) 
 		{
@@ -690,9 +947,16 @@ static void radeon_cp_load_microcode( dr
 			RADEON_WRITE( RADEON_CP_ME_RAM_DATAL,
 				      R200_cp_microcode[i][0] );
 		}
-	}
-	else
-	{
+	} else if (dev_priv->microcode_version==UCODE_R300) {
+		DRM_INFO("Loading R300 Microcode\n");
+		for ( i = 0 ; i < 256 ; i++ ) 
+		{
+			RADEON_WRITE( RADEON_CP_ME_RAM_DATAH,
+				      R300_cp_microcode[i][1] );
+			RADEON_WRITE( RADEON_CP_ME_RAM_DATAL,
+				      R300_cp_microcode[i][0] );
+		}
+	} else {
 		for ( i = 0 ; i < 256 ; i++ ) {
 			RADEON_WRITE( RADEON_CP_ME_RAM_DATAH,
 				      radeon_cp_microcode[i][1] );
@@ -1002,15 +1266,9 @@ static void radeon_set_pcigart( drm_rade
 
 static int radeon_do_init_cp( drm_device_t *dev, drm_radeon_init_t *init )
 {
-	drm_radeon_private_t *dev_priv;
+	drm_radeon_private_t *dev_priv = dev->dev_private;;
 	DRM_DEBUG( "\n" );
 
-	dev_priv = drm_alloc( sizeof(drm_radeon_private_t), DRM_MEM_DRIVER );
-	if ( dev_priv == NULL )
-		return DRM_ERR(ENOMEM);
-
-	memset( dev_priv, 0, sizeof(drm_radeon_private_t) );
-
 	dev_priv->is_pci = init->is_pci;
 
 	if ( dev_priv->is_pci && !dev->sg ) {
@@ -1029,7 +1287,17 @@ static int radeon_do_init_cp( drm_device
 		return DRM_ERR(EINVAL);
 	}
 
-	dev_priv->is_r200 = (init->func == RADEON_INIT_R200_CP);
+	switch(init->func) {
+	case RADEON_INIT_R200_CP:
+		dev_priv->microcode_version=UCODE_R200;
+		break;
+	case RADEON_INIT_R300_CP:
+		dev_priv->microcode_version=UCODE_R300;
+		break;
+	default:
+		dev_priv->microcode_version=UCODE_R100;
+	}
+	
 	dev_priv->do_boxes = 0;
 	dev_priv->cp_mode = init->cp_mode;
 
@@ -1078,7 +1346,7 @@ static int radeon_do_init_cp( drm_device
 	 */
 	dev_priv->depth_clear.rb3d_cntl = (RADEON_PLANE_MASK_ENABLE |
 					   (dev_priv->color_fmt << 10) |
-					   (1<<15));
+					   (dev_priv->microcode_version == UCODE_R100 ? RADEON_ZBLOCK16 : 0));
 
 	dev_priv->depth_clear.rb3d_zstencilcntl = 
 		(dev_priv->depth_fmt |
@@ -1272,6 +1540,7 @@ static int radeon_do_init_cp( drm_device
 
 int radeon_do_cleanup_cp( drm_device_t *dev )
 {
+	drm_radeon_private_t *dev_priv = dev->dev_private;
 	DRM_DEBUG( "\n" );
 
 	/* Make sure interrupts are disabled here because the uninstall ioctl
@@ -1280,30 +1549,28 @@ int radeon_do_cleanup_cp( drm_device_t *
 	 */
 	if ( dev->irq_enabled ) drm_irq_uninstall(dev);
 
-	if ( dev->dev_private ) {
-		drm_radeon_private_t *dev_priv = dev->dev_private;
-
 #if __OS_HAS_AGP
-		if ( !dev_priv->is_pci ) {
-			if ( dev_priv->cp_ring != NULL )
-				drm_core_ioremapfree( dev_priv->cp_ring, dev );
-			if ( dev_priv->ring_rptr != NULL )
-				drm_core_ioremapfree( dev_priv->ring_rptr, dev );
-			if ( dev->agp_buffer_map != NULL )
-				drm_core_ioremapfree( dev->agp_buffer_map, dev );
-		} else
-#endif
+	if ( !dev_priv->is_pci ) {
+		if ( dev_priv->cp_ring != NULL )
+			drm_core_ioremapfree( dev_priv->cp_ring, dev );
+		if ( dev_priv->ring_rptr != NULL )
+			drm_core_ioremapfree( dev_priv->ring_rptr, dev );
+		if ( dev->agp_buffer_map != NULL )
 		{
-			if (!drm_ati_pcigart_cleanup( dev,
-						dev_priv->phys_pci_gart,
-						dev_priv->bus_pci_gart ))
-				DRM_ERROR( "failed to cleanup PCI GART!\n" );
+			drm_core_ioremapfree( dev->agp_buffer_map, dev );
+			dev->agp_buffer_map = NULL;
 		}
-
-		drm_free( dev->dev_private, sizeof(drm_radeon_private_t),
-			   DRM_MEM_DRIVER );
-		dev->dev_private = NULL;
+	} else
+#endif
+	{
+		if (!drm_ati_pcigart_cleanup( dev,
+					      dev_priv->phys_pci_gart,
+					      dev_priv->bus_pci_gart ))
+			DRM_ERROR( "failed to cleanup PCI GART!\n" );
 	}
+	
+	/* only clear to the start of flags */
+	memset(dev_priv, 0, offsetof(drm_radeon_private_t, flags));
 
 	return 0;
 }
@@ -1360,6 +1627,7 @@ int radeon_cp_init( DRM_IOCTL_ARGS )
 	switch ( init.func ) {
 	case RADEON_INIT_CP:
 	case RADEON_INIT_R200_CP:
+	case RADEON_INIT_R300_CP:
 		return radeon_do_init_cp( dev, &init );
 	case RADEON_CLEANUP_CP:
 		return radeon_do_cleanup_cp( dev );
@@ -1440,7 +1708,7 @@ int radeon_cp_stop( DRM_IOCTL_ARGS )
 void radeon_do_release( drm_device_t *dev )
 {
 	drm_radeon_private_t *dev_priv = dev->dev_private;
-	int ret;
+	int i, ret;
 
 	if (dev_priv) {
 		if (dev_priv->cp_running) {
@@ -1458,7 +1726,16 @@ void radeon_do_release( drm_device_t *de
 		}
 
 		/* Disable *all* interrupts */
-		RADEON_WRITE( RADEON_GEN_INT_CNTL, 0 );
+		if (dev_priv->mmio)	/* remove this after permanent addmaps */
+			RADEON_WRITE( RADEON_GEN_INT_CNTL, 0 );
+
+		if (dev_priv->mmio) {/* remove all surfaces */
+			for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+				RADEON_WRITE(RADEON_SURFACE0_INFO + 16*i, 0);
+				RADEON_WRITE(RADEON_SURFACE0_LOWER_BOUND + 16*i, 0);
+				RADEON_WRITE(RADEON_SURFACE0_UPPER_BOUND + 16*i, 0);
+			}
+		}
 
 		/* Free memory heap structures */
 		radeon_mem_takedown( &(dev_priv->gart_heap) );
@@ -1742,3 +2019,42 @@ int radeon_cp_buffers( DRM_IOCTL_ARGS )
 
 	return ret;
 }
+
+int radeon_driver_preinit(struct drm_device *dev, unsigned long flags)
+{
+	drm_radeon_private_t *dev_priv;
+	int ret = 0;
+
+	dev_priv = drm_alloc(sizeof(drm_radeon_private_t), DRM_MEM_DRIVER);
+	if (dev_priv == NULL)
+		return DRM_ERR(ENOMEM);
+
+	memset(dev_priv, 0, sizeof(drm_radeon_private_t));
+	dev->dev_private = (void *)dev_priv;
+	dev_priv->flags = flags;
+
+	switch (flags & CHIP_FAMILY_MASK) {
+	case CHIP_R100:
+	case CHIP_RV200:
+	case CHIP_R200:
+	case CHIP_R300:
+		dev_priv->flags |= CHIP_HAS_HIERZ;
+		break;
+	default:
+	/* all other chips have no hierarchical z buffer */
+		break;
+	}
+	return ret;
+}
+
+int radeon_driver_postcleanup(struct drm_device *dev)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	DRM_DEBUG("\n");
+
+	drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
+
+	dev->dev_private = NULL;
+	return 0;
+}
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_drm.h linux-2.6.11-rc3/drivers/char/drm/radeon_drm.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_drm.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/radeon_drm.h	2005-02-03 02:56:11.000000000 +0100
@@ -145,7 +145,8 @@
 #define RADEON_EMIT_PP_TEX_SIZE_1                   74
 #define RADEON_EMIT_PP_TEX_SIZE_2                   75
 #define R200_EMIT_RB3D_BLENDCOLOR                   76
-#define RADEON_MAX_STATE_PACKETS                    77
+#define R200_EMIT_TCL_POINT_SPRITE_CNTL             77
+#define RADEON_MAX_STATE_PACKETS                    78
 
 
 /* Commands understood by cmd_buffer ioctl.  More can be added but
@@ -192,7 +193,10 @@ typedef union {
 #define RADEON_FRONT			0x1
 #define RADEON_BACK			0x2
 #define RADEON_DEPTH			0x4
-#define RADEON_STENCIL                  0x8
+#define RADEON_STENCIL			0x8
+#define RADEON_CLEAR_FASTZ		0x80000000
+#define RADEON_USE_HIERZ		0x40000000
+#define RADEON_USE_COMP_ZBUF		0x20000000
 
 /* Primitive types
  */
@@ -227,6 +231,8 @@ typedef union {
 #define RADEON_MAX_TEXTURE_LEVELS	12
 #define RADEON_MAX_TEXTURE_UNITS	3
 
+#define RADEON_MAX_SURFACES		8
+
 /* Blits have strict offset rules.  All blit offset must be aligned on
  * a 1K-byte boundary.
  */
@@ -361,6 +367,7 @@ typedef struct {
         int pfState;                /* number of 3d windows (0,1,2ormore) */
         int pfCurrentPage;	    /* which buffer is being displayed? */
 	int crtc2_base;		    /* CRTC2 frame offset */
+	int tiling_enabled;	/* set by drm, read by 2d + 3d clients */
 } drm_radeon_sarea_t;
 
 
@@ -399,6 +406,8 @@ typedef struct {
 #define DRM_RADEON_IRQ_WAIT   0x17
 #define DRM_RADEON_CP_RESUME  0x18
 #define DRM_RADEON_SETPARAM   0x19
+#define DRM_RADEON_SURF_ALLOC 0x1a
+#define DRM_RADEON_SURF_FREE  0x1b
 
 #define DRM_IOCTL_RADEON_CP_INIT    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_INIT, drm_radeon_init_t)
 #define DRM_IOCTL_RADEON_CP_START   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_START)
@@ -425,12 +434,15 @@ typedef struct {
 #define DRM_IOCTL_RADEON_IRQ_WAIT   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_IRQ_WAIT, drm_radeon_irq_wait_t)
 #define DRM_IOCTL_RADEON_CP_RESUME  DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESUME)
 #define DRM_IOCTL_RADEON_SETPARAM   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SETPARAM, drm_radeon_setparam_t)
+#define DRM_IOCTL_RADEON_SURF_ALLOC DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_ALLOC, drm_radeon_surface_alloc_t)
+#define DRM_IOCTL_RADEON_SURF_FREE  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_FREE, drm_radeon_surface_free_t)
 
 typedef struct drm_radeon_init {
 	enum {
 		RADEON_INIT_CP    = 0x01,
 		RADEON_CLEANUP_CP = 0x02,
-		RADEON_INIT_R200_CP = 0x03
+		RADEON_INIT_R200_CP = 0x03,
+		RADEON_INIT_R300_CP = 0x04
 	} func;
 	unsigned long sarea_priv_offset;
 	int is_pci;
@@ -623,7 +635,19 @@ typedef struct drm_radeon_setparam {
 	int64_t      value;
 } drm_radeon_setparam_t;
 
-#define RADEON_SETPARAM_FB_LOCATION    1 /* determined framebuffer location */
+#define RADEON_SETPARAM_FB_LOCATION    1	/* determined framebuffer location */
+#define RADEON_SETPARAM_SWITCH_TILING  2	/* enable/disable color tiling */
+
+/* 1.14: Clients can allocate/free a surface
+ */
+typedef struct drm_radeon_surface_alloc {
+	unsigned int address;
+	unsigned int size;
+	unsigned int flags;
+} drm_radeon_surface_alloc_t;
 
+typedef struct drm_radeon_surface_free {
+	unsigned int address;
+} drm_radeon_surface_free_t;
 
 #endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_drv.c linux-2.6.11-rc3/drivers/char/drm/radeon_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_drv.c	2005-01-22 02:48:29.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/radeon_drv.c	2005-02-03 02:56:22.000000000 +0100
@@ -69,70 +69,14 @@ static struct pci_device_id pciidlist[] 
 	radeon_PCI_IDS
 };
 
-/* Interface history:
- *
- * 1.1 - ??
- * 1.2 - Add vertex2 ioctl (keith)
- *     - Add stencil capability to clear ioctl (gareth, keith)
- *     - Increase MAX_TEXTURE_LEVELS (brian)
- * 1.3 - Add cmdbuf ioctl (keith)
- *     - Add support for new radeon packets (keith)
- *     - Add getparam ioctl (keith)
- *     - Add flip-buffers ioctl, deprecate fullscreen foo (keith).
- * 1.4 - Add scratch registers to get_param ioctl.
- * 1.5 - Add r200 packets to cmdbuf ioctl
- *     - Add r200 function to init ioctl
- *     - Add 'scalar2' instruction to cmdbuf
- * 1.6 - Add static GART memory manager
- *       Add irq handler (won't be turned on unless X server knows to)
- *       Add irq ioctls and irq_active getparam.
- *       Add wait command for cmdbuf ioctl
- *       Add GART offset query for getparam
- * 1.7 - Add support for cube map registers: R200_PP_CUBIC_FACES_[0..5]
- *       and R200_PP_CUBIC_OFFSET_F1_[0..5].
- *       Added packets R200_EMIT_PP_CUBIC_FACES_[0..5] and
- *       R200_EMIT_PP_CUBIC_OFFSETS_[0..5].  (brian)
- * 1.8 - Remove need to call cleanup ioctls on last client exit (keith)
- *       Add 'GET' queries for starting additional clients on different VT's.
- * 1.9 - Add DRM_IOCTL_RADEON_CP_RESUME ioctl.
- *       Add texture rectangle support for r100.
- * 1.10- Add SETPARAM ioctl; first parameter to set is FB_LOCATION, which
- *       clients use to tell the DRM where they think the framebuffer is 
- *       located in the card's address space
- * 1.11- Add packet R200_EMIT_RB3D_BLENDCOLOR to support GL_EXT_blend_color
- *       and GL_EXT_blend_[func|equation]_separate on r200
- */
-static drm_ioctl_desc_t ioctls[] = {
- [DRM_IOCTL_NR(DRM_RADEON_CP_INIT)]    = { radeon_cp_init,      1, 1 },
- [DRM_IOCTL_NR(DRM_RADEON_CP_START)]   = { radeon_cp_start,     1, 1 },
- [DRM_IOCTL_NR(DRM_RADEON_CP_STOP)]    = { radeon_cp_stop,      1, 1 },
- [DRM_IOCTL_NR(DRM_RADEON_CP_RESET)]   = { radeon_cp_reset,     1, 1 },
- [DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)]    = { radeon_cp_idle,      1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)]  = { radeon_cp_resume,    1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_RESET)]      = { radeon_engine_reset, 1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = { radeon_fullscreen,   1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_SWAP)]       = { radeon_cp_swap,      1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_CLEAR)]      = { radeon_cp_clear,     1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_VERTEX)]     = { radeon_cp_vertex,    1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_INDICES)]    = { radeon_cp_indices,   1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_TEXTURE)]    = { radeon_cp_texture,   1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_STIPPLE)]    = { radeon_cp_stipple,   1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_INDIRECT)]   = { radeon_cp_indirect,  1, 1 },
- [DRM_IOCTL_NR(DRM_RADEON_VERTEX2)]    = { radeon_cp_vertex2,   1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_CMDBUF)]     = { radeon_cp_cmdbuf,    1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_GETPARAM)]   = { radeon_cp_getparam,  1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_FLIP)]       = { radeon_cp_flip,      1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_ALLOC)]      = { radeon_mem_alloc,    1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_FREE)]       = { radeon_mem_free,     1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)]  = { radeon_mem_init_heap,1, 1 },
- [DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)]   = { radeon_irq_emit,     1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)]   = { radeon_irq_wait,     1, 0 },
- [DRM_IOCTL_NR(DRM_RADEON_SETPARAM)]   = { radeon_cp_setparam,  1, 0 },
-};
+extern drm_ioctl_desc_t radeon_ioctls[];
+extern int radeon_max_ioctl;
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_USE_MTRR | DRIVER_PCI_DMA | DRIVER_SG | DRIVER_HAVE_IRQ | DRIVER_HAVE_DMA | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
 	.dev_priv_size = sizeof(drm_radeon_buf_priv_t),
+	.preinit = radeon_driver_preinit,
+	.postcleanup = radeon_driver_postcleanup,
 	.prerelease = radeon_driver_prerelease,
 	.pretakedown = radeon_driver_pretakedown,
 	.open_helper = radeon_driver_open_helper,
@@ -147,8 +91,7 @@ static struct drm_driver driver = {
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.ioctls = radeon_ioctls,
 	.dma_ioctl = radeon_cp_buffers,
 	.fops = {
 		.owner = THIS_MODULE,
@@ -167,6 +110,7 @@ static struct drm_driver driver = {
 
 static int __init radeon_init(void)
 {
+	driver.num_ioctls = radeon_max_ioctl;
 	return drm_init(&driver);
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_drv.h linux-2.6.11-rc3/drivers/char/drm/radeon_drv.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_drv.h	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/radeon_drv.h	2005-02-03 02:55:52.000000000 +0100
@@ -38,15 +38,93 @@
 
 #define DRIVER_NAME		"radeon"
 #define DRIVER_DESC		"ATI Radeon"
-#define DRIVER_DATE		"20020828"
+#define DRIVER_DATE		"20050125"
 
+/* Interface history:
+ *
+ * 1.1 - ??
+ * 1.2 - Add vertex2 ioctl (keith)
+ *     - Add stencil capability to clear ioctl (gareth, keith)
+ *     - Increase MAX_TEXTURE_LEVELS (brian)
+ * 1.3 - Add cmdbuf ioctl (keith)
+ *     - Add support for new radeon packets (keith)
+ *     - Add getparam ioctl (keith)
+ *     - Add flip-buffers ioctl, deprecate fullscreen foo (keith).
+ * 1.4 - Add scratch registers to get_param ioctl.
+ * 1.5 - Add r200 packets to cmdbuf ioctl
+ *     - Add r200 function to init ioctl
+ *     - Add 'scalar2' instruction to cmdbuf
+ * 1.6 - Add static GART memory manager
+ *       Add irq handler (won't be turned on unless X server knows to)
+ *       Add irq ioctls and irq_active getparam.
+ *       Add wait command for cmdbuf ioctl
+ *       Add GART offset query for getparam
+ * 1.7 - Add support for cube map registers: R200_PP_CUBIC_FACES_[0..5]
+ *       and R200_PP_CUBIC_OFFSET_F1_[0..5].
+ *       Added packets R200_EMIT_PP_CUBIC_FACES_[0..5] and
+ *       R200_EMIT_PP_CUBIC_OFFSETS_[0..5].  (brian)
+ * 1.8 - Remove need to call cleanup ioctls on last client exit (keith)
+ *       Add 'GET' queries for starting additional clients on different VT's.
+ * 1.9 - Add DRM_IOCTL_RADEON_CP_RESUME ioctl.
+ *       Add texture rectangle support for r100.
+ * 1.10- Add SETPARAM ioctl; first parameter to set is FB_LOCATION, which
+ *       clients use to tell the DRM where they think the framebuffer is 
+ *       located in the card's address space
+ * 1.11- Add packet R200_EMIT_RB3D_BLENDCOLOR to support GL_EXT_blend_color
+ *       and GL_EXT_blend_[func|equation]_separate on r200
+ * 1.12- Add R300 CP microcode support - this just loads the CP on r300
+ *       (No 3D support yet - just microcode loading)
+ * 1.13- Add packet R200_EMIT_TCL_POINT_SPRITE_CNTL for ARB_point_parameters
+ *     - Add hyperz support, add hyperz flags to clear ioctl.
+ * 1.14- Add support for color tiling
+ *     - Add R100/R200 surface allocation/free support
+ */
 #define DRIVER_MAJOR		1
-#define DRIVER_MINOR		11
+#define DRIVER_MINOR		14
 #define DRIVER_PATCHLEVEL	0
 
 #define GET_RING_HEAD(dev_priv)		DRM_READ32(  (dev_priv)->ring_rptr, 0 )
 #define SET_RING_HEAD(dev_priv,val)	DRM_WRITE32( (dev_priv)->ring_rptr, 0, (val) )
 
+/*
+ * Radeon chip families
+ */
+enum radeon_family {
+	CHIP_R100,
+	CHIP_RS100,
+	CHIP_RV100,
+	CHIP_R200,
+	CHIP_RV200,
+	CHIP_RS200,
+	CHIP_R250,
+	CHIP_RS250,
+	CHIP_RV250,
+	CHIP_RV280,
+	CHIP_R300,
+	CHIP_RS300,
+	CHIP_RV350,
+	CHIP_LAST,
+};
+
+enum radeon_cp_microcode_version {
+	UCODE_R100,
+	UCODE_R200,
+	UCODE_R300,
+};
+
+/*
+ * Chip flags
+ */
+enum radeon_chip_flags {
+	CHIP_FAMILY_MASK = 0x0000ffffUL,
+	CHIP_FLAGS_MASK = 0xffff0000UL,
+	CHIP_IS_MOBILITY = 0x00010000UL,
+	CHIP_IS_IGP = 0x00020000UL,
+	CHIP_SINGLE_CRTC = 0x00040000UL,
+	CHIP_IS_AGP = 0x00080000UL,
+	CHIP_HAS_HIERZ = 0x00100000UL, 
+};
+
 typedef struct drm_radeon_freelist {
    	unsigned int age;
    	drm_buf_t *buf;
@@ -85,6 +163,21 @@ struct mem_block {
 	DRMFILE filp;		/* 0: free, -1: heap, other: real files */
 };
 
+struct radeon_surface {
+	int refcount;
+	u32 lower;
+	u32 upper;
+	u32 flags;
+};
+
+struct radeon_virt_surface {
+	int surface_index;
+	u32 lower;
+	u32 upper;
+	u32 flags;
+	DRMFILE filp;
+};
+
 typedef struct drm_radeon_private {
 	drm_radeon_ring_buffer_t ring;
 	drm_radeon_sarea_t *sarea_priv;
@@ -106,7 +199,7 @@ typedef struct drm_radeon_private {
 
 	int usec_timeout;
 
-	int is_r200;
+	int microcode_version;
 
 	int is_pci;
 	unsigned long phys_pci_gart;
@@ -163,6 +256,11 @@ typedef struct drm_radeon_private {
    	wait_queue_head_t swi_queue;
    	atomic_t swi_emitted;
 
+	struct radeon_surface surfaces[RADEON_MAX_SURFACES];
+	struct radeon_virt_surface virt_surfaces[2*RADEON_MAX_SURFACES];
+
+	/* starting from here on, data is preserved accross an open */
+	uint32_t flags;		/* see radeon_chip_flags */
 } drm_radeon_private_t;
 
 typedef struct drm_radeon_buf_priv {
@@ -189,6 +287,9 @@ extern int radeon_do_cp_idle( drm_radeon
 extern int radeon_do_cleanup_cp( drm_device_t *dev );
 extern int radeon_do_cleanup_pageflip( drm_device_t *dev );
 
+extern int radeon_driver_preinit(struct drm_device *dev, unsigned long flags);
+extern int radeon_driver_postcleanup(struct drm_device *dev);
+
 				/* radeon_state.c */
 extern int radeon_cp_clear( DRM_IOCTL_ARGS );
 extern int radeon_cp_swap( DRM_IOCTL_ARGS );
@@ -208,6 +309,8 @@ extern int radeon_mem_free( DRM_IOCTL_AR
 extern int radeon_mem_init_heap( DRM_IOCTL_ARGS );
 extern void radeon_mem_takedown( struct mem_block **heap );
 extern void radeon_mem_release( DRMFILE filp, struct mem_block *heap );
+extern int radeon_surface_alloc(DRM_IOCTL_ARGS);
+extern int radeon_surface_free(DRM_IOCTL_ARGS);
 
 				/* radeon_irq.c */
 extern int radeon_irq_emit( DRM_IOCTL_ARGS );
@@ -382,7 +485,9 @@ extern int radeon_postcleanup( struct dr
 #	define RADEON_ROP_ENABLE		(1 << 6)
 #	define RADEON_STENCIL_ENABLE		(1 << 7)
 #	define RADEON_Z_ENABLE			(1 << 8)
+#	define RADEON_ZBLOCK16			(1 << 15)
 #define RADEON_RB3D_DEPTHOFFSET		0x1c24
+#define RADEON_RB3D_DEPTHCLEARVALUE	0x3230
 #define RADEON_RB3D_DEPTHPITCH		0x1c28
 #define RADEON_RB3D_PLANEMASK		0x1d84
 #define RADEON_RB3D_STENCILREFMASK	0x1d7c
@@ -395,11 +500,15 @@ extern int radeon_postcleanup( struct dr
 #define RADEON_RB3D_ZSTENCILCNTL	0x1c2c
 #	define RADEON_Z_TEST_MASK		(7 << 4)
 #	define RADEON_Z_TEST_ALWAYS		(7 << 4)
+#	define RADEON_Z_HIERARCHY_ENABLE	(1 << 8)
 #	define RADEON_STENCIL_TEST_ALWAYS	(7 << 12)
 #	define RADEON_STENCIL_S_FAIL_REPLACE	(2 << 16)
 #	define RADEON_STENCIL_ZPASS_REPLACE	(2 << 20)
 #	define RADEON_STENCIL_ZFAIL_REPLACE	(2 << 24)
+#	define RADEON_Z_COMPRESSION_ENABLE	(1 << 28)
+#	define RADEON_FORCE_Z_DIRTY		(1 << 29)
 #	define RADEON_Z_WRITE_ENABLE		(1 << 30)
+#	define RADEON_Z_DECOMPRESSION_ENABLE	(1 << 31)
 #define RADEON_RBBM_SOFT_RESET		0x00f0
 #	define RADEON_SOFT_RESET_CP		(1 <<  0)
 #	define RADEON_SOFT_RESET_HI		(1 <<  1)
@@ -478,6 +587,7 @@ extern int radeon_postcleanup( struct dr
 #	define RADEON_SURF_TILE_MODE_16BIT_Z	(3 << 16)
 #define RADEON_SURFACE0_LOWER_BOUND	0x0b04
 #define RADEON_SURFACE0_UPPER_BOUND	0x0b08
+#	define RADEON_SURF_ADDRESS_FIXED_MASK	(0x3ff << 0)
 #define RADEON_SURFACE1_INFO		0x0b1c
 #define RADEON_SURFACE1_LOWER_BOUND	0x0b14
 #define RADEON_SURFACE1_UPPER_BOUND	0x0b18
@@ -507,7 +617,7 @@ extern int radeon_postcleanup( struct dr
 #	define RADEON_WAIT_3D_IDLECLEAN		(1 << 17)
 #	define RADEON_WAIT_HOST_IDLECLEAN	(1 << 18)
 
-#define RADEON_RB3D_ZMASKOFFSET		0x1c34
+#define RADEON_RB3D_ZMASKOFFSET		0x3234
 #define RADEON_RB3D_ZSTENCILCNTL	0x1c2c
 #	define RADEON_DEPTH_FORMAT_16BIT_INT_Z	(0 << 0)
 #	define RADEON_DEPTH_FORMAT_24BIT_INT_Z	(2 << 0)
@@ -562,6 +672,8 @@ extern int radeon_postcleanup( struct dr
 #	define RADEON_3D_DRAW_IMMD		0x00002900
 #	define RADEON_3D_DRAW_INDX		0x00002A00
 #	define RADEON_3D_LOAD_VBPNTR		0x00002F00
+#	define RADEON_3D_CLEAR_ZMASK		0x00003200
+#	define RADEON_3D_CLEAR_HIZ		0x00003700
 #	define RADEON_CNTL_HOSTDATA_BLT		0x00009400
 #	define RADEON_CNTL_PAINT_MULTI		0x00009A00
 #	define RADEON_CNTL_BITBLT_MULTI		0x00009B00
@@ -720,6 +832,8 @@ extern int radeon_postcleanup( struct dr
 
 #define R200_RB3D_BLENDCOLOR              0x3218
 
+#define R200_SE_TCL_POINT_SPRITE_CNTL     0x22c4
+
 /* Constants */
 #define RADEON_MAX_USEC_TIMEOUT		100000	/* 100 ms */
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_state.c linux-2.6.11-rc3/drivers/char/drm/radeon_state.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/radeon_state.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/radeon_state.c	2005-02-03 02:56:34.000000000 +0100
@@ -33,6 +33,37 @@
 #include "radeon_drm.h"
 #include "radeon_drv.h"
 
+drm_ioctl_desc_t radeon_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)]    = { radeon_cp_init,      1, 1 },
+	[DRM_IOCTL_NR(DRM_RADEON_CP_START)]   = { radeon_cp_start,     1, 1 },
+	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)]    = { radeon_cp_stop,      1, 1 },
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)]   = { radeon_cp_reset,     1, 1 },
+	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)]    = { radeon_cp_idle,      1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)]  = { radeon_cp_resume,    1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_RESET)]      = { radeon_engine_reset, 1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = { radeon_fullscreen,   1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_SWAP)]       = { radeon_cp_swap,      1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)]      = { radeon_cp_clear,     1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)]     = { radeon_cp_vertex,    1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_INDICES)]    = { radeon_cp_indices,   1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)]    = { radeon_cp_texture,   1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)]    = { radeon_cp_stipple,   1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)]   = { radeon_cp_indirect,  1, 1 },
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)]    = { radeon_cp_vertex2,   1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)]     = { radeon_cp_cmdbuf,    1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)]   = { radeon_cp_getparam,  1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_FLIP)]       = { radeon_cp_flip,      1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)]      = { radeon_mem_alloc,    1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_FREE)]       = { radeon_mem_free,     1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)]  = { radeon_mem_init_heap,1, 1 },
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)]   = { radeon_irq_emit,     1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)]   = { radeon_irq_wait,     1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)]   = { radeon_cp_setparam,  1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = { radeon_surface_alloc,1, 0 },
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)]  = { radeon_surface_free, 1, 0 }
+};
+
+int radeon_max_ioctl = DRM_ARRAY_SIZE(radeon_ioctls);
 
 /* ================================================================
  * Helper functions for client state checking and fixup
@@ -203,6 +234,7 @@ static __inline__ int radeon_check_and_f
 	case RADEON_EMIT_PP_TEX_SIZE_1:
 	case RADEON_EMIT_PP_TEX_SIZE_2:
 	case R200_EMIT_RB3D_BLENDCOLOR:
+	case R200_EMIT_TCL_POINT_SPRITE_CNTL:
 		/* These packets don't contain memory offsets */
 		break;
 
@@ -567,6 +599,7 @@ static struct { 
 	{ RADEON_PP_TEX_SIZE_1, 2, "RADEON_PP_TEX_SIZE_1" },
 	{ RADEON_PP_TEX_SIZE_2, 2, "RADEON_PP_TEX_SIZE_2" },
 	{ R200_RB3D_BLENDCOLOR, 3, "R200_RB3D_BLENDCOLOR" },
+	{ R200_SE_TCL_POINT_SPRITE_CNTL, 1, "R200_SE_TCL_POINT_SPRITE_CNTL" },
 };
 
 
@@ -777,13 +810,160 @@ static void radeon_cp_dispatch_clear( dr
 			}
 		}
 	}
+	
+	/* hyper z clear */
+	/* no docs available, based on reverse engeneering by Stephane Marchesin */
+	if ((flags & (RADEON_DEPTH | RADEON_STENCIL)) && (flags & RADEON_CLEAR_FASTZ)) {
+
+		int i;
+		int depthpixperline = dev_priv->depth_fmt==RADEON_DEPTH_FORMAT_16BIT_INT_Z? 
+			(dev_priv->depth_pitch / 2): (dev_priv->depth_pitch / 4);
+		
+		u32 clearmask;
+
+		u32 tempRB3D_DEPTHCLEARVALUE = clear->clear_depth |
+			((clear->depth_mask & 0xff) << 24);
+	
+		
+		/* Make sure we restore the 3D state next time.
+		 * we haven't touched any "normal" state - still need this?
+		 */
+		dev_priv->sarea_priv->ctx_owner = 0;
+
+		if ((dev_priv->flags & CHIP_HAS_HIERZ) && (flags & RADEON_USE_HIERZ)) {
+		/* FIXME : reverse engineer that for Rx00 cards */
+		/* FIXME : the mask supposedly contains low-res z values. So can't set
+		   just to the max (0xff? or actually 0x3fff?), need to take z clear
+		   value into account? */
+		/* pattern seems to work for r100, though get slight
+		   rendering errors with glxgears. If hierz is not enabled for r100,
+		   only 4 bits which indicate clear (15,16,31,32, all zero) matter, the
+		   other ones are ignored, and the same clear mask can be used. That's
+		   very different behaviour than R200 which needs different clear mask
+		   and different number of tiles to clear if hierz is enabled or not !?!
+		*/
+			clearmask = (0xff<<22)|(0xff<<6)| 0x003f003f;
+		}
+		else {
+		/* clear mask : chooses the clearing pattern.
+		   rv250: could be used to clear only parts of macrotiles
+		   (but that would get really complicated...)?
+		   bit 0 and 1 (either or both of them ?!?!) are used to
+		   not clear tile (or maybe one of the bits indicates if the tile is
+		   compressed or not), bit 2 and 3 to not clear tile 1,...,.
+		   Pattern is as follows:
+		        | 0,1 | 4,5 | 8,9 |12,13|16,17|20,21|24,25|28,29|
+		   bits -------------------------------------------------
+		        | 2,3 | 6,7 |10,11|14,15|18,19|22,23|26,27|30,31|
+		   rv100: clearmask covers 2x8 4x1 tiles, but one clear still
+		   covers 256 pixels ?!?
+		*/
+			clearmask = 0x0;
+		}
+
+		BEGIN_RING( 8 );
+		RADEON_WAIT_UNTIL_2D_IDLE();
+		OUT_RING_REG( RADEON_RB3D_DEPTHCLEARVALUE,
+			tempRB3D_DEPTHCLEARVALUE);
+		/* what offset is this exactly ? */
+		OUT_RING_REG( RADEON_RB3D_ZMASKOFFSET, 0 );
+		/* need ctlstat, otherwise get some strange black flickering */
+		OUT_RING_REG( RADEON_RB3D_ZCACHE_CTLSTAT, RADEON_RB3D_ZC_FLUSH_ALL );
+		ADVANCE_RING();
+
+		for (i = 0; i < nbox; i++) {
+			int tileoffset, nrtilesx, nrtilesy, j;
+			/* it looks like r200 needs rv-style clears, at least if hierz is not enabled? */
+			if ((dev_priv->flags&CHIP_HAS_HIERZ) && !(dev_priv->microcode_version==UCODE_R200)) {
+				/* FIXME : figure this out for r200 (when hierz is enabled). Or
+				   maybe r200 actually doesn't need to put the low-res z value into
+				   the tile cache like r100, but just needs to clear the hi-level z-buffer?
+				   Works for R100, both with hierz and without.
+				   R100 seems to operate on 2x1 8x8 tiles, but...
+				   odd: offset/nrtiles need to be 64 pix (4 block) aligned? Potentially
+				   problematic with resolutions which are not 64 pix aligned? */
+				tileoffset = ((pbox[i].y1 >> 3) * depthpixperline + pbox[i].x1) >> 6;
+				nrtilesx = ((pbox[i].x2 & ~63) - (pbox[i].x1 & ~63)) >> 4;
+				nrtilesy = (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
+				for (j = 0; j <= nrtilesy; j++) {
+					BEGIN_RING( 4 );
+					OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_ZMASK, 2 ) );
+					/* first tile */
+					OUT_RING( tileoffset * 8 );
+					/* the number of tiles to clear */
+					OUT_RING( nrtilesx + 4 );
+					/* clear mask : chooses the clearing pattern. */
+					OUT_RING( clearmask );
+					ADVANCE_RING();
+					tileoffset += depthpixperline >> 6;
+				}
+			}
+			else if (dev_priv->microcode_version==UCODE_R200) {
+				/* works for rv250. */
+				/* find first macro tile (8x2 4x4 z-pixels on rv250) */
+				tileoffset = ((pbox[i].y1 >> 3) * depthpixperline + pbox[i].x1) >> 5;
+				nrtilesx = (pbox[i].x2 >> 5) - (pbox[i].x1 >> 5);
+				nrtilesy = (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
+				for (j = 0; j <= nrtilesy; j++) {
+					BEGIN_RING( 4 );
+					OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_ZMASK, 2 ) );
+					/* first tile */
+					/* judging by the first tile offset needed, could possibly
+					   directly address/clear 4x4 tiles instead of 8x2 * 4x4
+					   macro tiles, though would still need clear mask for
+					   right/bottom if truely 4x4 granularity is desired ? */
+					OUT_RING( tileoffset * 16 );
+					/* the number of tiles to clear */
+					OUT_RING( nrtilesx + 1 );
+					/* clear mask : chooses the clearing pattern. */
+					OUT_RING( clearmask );
+					ADVANCE_RING();
+					tileoffset += depthpixperline >> 5;
+				}
+			}
+			else { /* rv 100 */
+				/* rv100 might not need 64 pix alignment, who knows */
+				/* offsets are, hmm, weird */
+				tileoffset = ((pbox[i].y1 >> 4) * depthpixperline + pbox[i].x1) >> 6;
+				nrtilesx = ((pbox[i].x2 & ~63) - (pbox[i].x1 & ~63)) >> 4;
+				nrtilesy = (pbox[i].y2 >> 4) - (pbox[i].y1 >> 4);
+				for (j = 0; j <= nrtilesy; j++) {
+					BEGIN_RING( 4 );
+					OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_ZMASK, 2 ) );
+					OUT_RING( tileoffset * 128 );
+					/* the number of tiles to clear */
+					OUT_RING( nrtilesx + 4 );
+					/* clear mask : chooses the clearing pattern. */
+					OUT_RING( clearmask );
+					ADVANCE_RING();
+					tileoffset += depthpixperline >> 6;
+				}
+			}
+		}
+
+		/* TODO don't always clear all hi-level z tiles */
+		if ((dev_priv->flags & CHIP_HAS_HIERZ) && (dev_priv->microcode_version==UCODE_R200)
+			&& (flags & RADEON_USE_HIERZ))
+		/* r100 and cards without hierarchical z-buffer have no high-level z-buffer */
+		/* FIXME : the mask supposedly contains low-res z values. So can't set
+		   just to the max (0xff? or actually 0x3fff?), need to take z clear
+		   value into account? */
+		{
+			BEGIN_RING( 4 );
+			OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_HIZ, 2 ) );
+			OUT_RING( 0x0 ); /* First tile */
+			OUT_RING( 0x3cc0 );
+			OUT_RING( (0xff<<22)|(0xff<<6)| 0x003f003f);
+			ADVANCE_RING();
+		}
+	}
 
 	/* We have to clear the depth and/or stencil buffers by
 	 * rendering a quad into just those buffers.  Thus, we have to
 	 * make sure the 3D engine is configured correctly.
 	 */
-	if ( dev_priv->is_r200 &&
-	     (flags & (RADEON_DEPTH | RADEON_STENCIL)) ) {
+	if ((dev_priv->microcode_version == UCODE_R200) &&
+	    (flags & (RADEON_DEPTH | RADEON_STENCIL))) {
 
 		int tempPP_CNTL;
 		int tempRE_CNTL;
@@ -802,7 +982,6 @@ static void radeon_cp_dispatch_clear( dr
 		tempRE_CNTL = 0;
 
 		tempRB3D_CNTL = depth_clear->rb3d_cntl;
-		tempRB3D_CNTL &= ~(1<<15); /* unset radeon magic flag */
 
 		tempRB3D_ZSTENCILCNTL = depth_clear->rb3d_zstencilcntl;
 		tempRB3D_STENCILREFMASK = 0x0;
@@ -853,6 +1032,14 @@ static void radeon_cp_dispatch_clear( dr
 			tempRB3D_STENCILREFMASK = 0x00000000;
 		}
 
+		if (flags & RADEON_USE_COMP_ZBUF) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_COMPRESSION_ENABLE |
+				RADEON_Z_DECOMPRESSION_ENABLE;
+		}
+		if (flags & RADEON_USE_HIERZ) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;
+		}
+
 		BEGIN_RING( 26 );
 		RADEON_WAIT_UNTIL_2D_IDLE();
 
@@ -907,6 +1094,8 @@ static void radeon_cp_dispatch_clear( dr
 	} 
 	else if ( (flags & (RADEON_DEPTH | RADEON_STENCIL)) ) {
 
+		int tempRB3D_ZSTENCILCNTL = depth_clear->rb3d_zstencilcntl;
+
 		rb3d_cntl = depth_clear->rb3d_cntl;
 
 		if ( flags & RADEON_DEPTH ) {
@@ -923,6 +1112,14 @@ static void radeon_cp_dispatch_clear( dr
 			rb3d_stencilrefmask = 0x00000000;
 		}
 
+		if (flags & RADEON_USE_COMP_ZBUF) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_COMPRESSION_ENABLE |
+				RADEON_Z_DECOMPRESSION_ENABLE;
+		}
+		if (flags & RADEON_USE_HIERZ) {
+			tempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;
+		}
+
 		BEGIN_RING( 13 );
 		RADEON_WAIT_UNTIL_2D_IDLE();
 
@@ -930,8 +1127,7 @@ static void radeon_cp_dispatch_clear( dr
 		OUT_RING( 0x00000000 );
 		OUT_RING( rb3d_cntl );
 		
-		OUT_RING_REG( RADEON_RB3D_ZSTENCILCNTL,
-			      depth_clear->rb3d_zstencilcntl );
+		OUT_RING_REG( RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL );
 		OUT_RING_REG( RADEON_RB3D_STENCILREFMASK,
 			      rb3d_stencilrefmask );
 		OUT_RING_REG( RADEON_RB3D_PLANEMASK,
@@ -1537,10 +1733,203 @@ static void radeon_cp_dispatch_stipple( 
 	ADVANCE_RING();
 }
 
+static void radeon_apply_surface_regs(int surf_index, drm_radeon_private_t *dev_priv)
+{
+	if (!dev_priv->mmio)
+		return;
+
+	radeon_do_cp_idle(dev_priv);
+
+	RADEON_WRITE(RADEON_SURFACE0_INFO + 16*surf_index,
+		dev_priv->surfaces[surf_index].flags);
+	RADEON_WRITE(RADEON_SURFACE0_LOWER_BOUND + 16*surf_index,
+		dev_priv->surfaces[surf_index].lower);
+	RADEON_WRITE(RADEON_SURFACE0_UPPER_BOUND + 16*surf_index,
+		dev_priv->surfaces[surf_index].upper);
+}
+
+
+/* Allocates a virtual surface
+ * doesn't always allocate a real surface, will stretch an existing 
+ * surface when possible.
+ *
+ * Note that refcount can be at most 2, since during a free refcount=3
+ * might mean we have to allocate a new surface which might not always
+ * be available.
+ * For example : we allocate three contigous surfaces ABC. If B is 
+ * freed, we suddenly need two surfaces to store A and C, which might
+ * not always be available.
+ */
+static int alloc_surface(drm_radeon_surface_alloc_t* new, drm_radeon_private_t *dev_priv, DRMFILE filp)
+{
+	struct radeon_virt_surface *s;
+	int i;
+	int virt_surface_index;
+	uint32_t new_upper, new_lower;
+
+	new_lower = new->address;
+	new_upper = new_lower + new->size - 1;
+
+	/* sanity check */
+	if ((new_lower >= new_upper) || (new->flags == 0) || (new->size == 0) ||
+		((new_upper & RADEON_SURF_ADDRESS_FIXED_MASK) != RADEON_SURF_ADDRESS_FIXED_MASK) ||
+		((new_lower & RADEON_SURF_ADDRESS_FIXED_MASK) != 0))
+		return -1;
+
+	/* make sure there is no overlap with existing surfaces */
+	for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+		if ((dev_priv->surfaces[i].refcount != 0) &&
+		(( (new_lower >= dev_priv->surfaces[i].lower) &&
+			(new_lower < dev_priv->surfaces[i].upper) ) ||
+		 ( (new_lower < dev_priv->surfaces[i].lower) &&
+			(new_upper > dev_priv->surfaces[i].lower) )) ){
+		return -1;}
+	}
+
+	/* find a virtual surface */
+	for (i = 0; i < 2*RADEON_MAX_SURFACES; i++)
+		if (dev_priv->virt_surfaces[i].filp == 0)
+			break;
+	if (i == 2*RADEON_MAX_SURFACES) {
+		return -1;}
+	virt_surface_index = i;
+
+	/* try to reuse an existing surface */
+	for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+		/* extend before */
+		if ((dev_priv->surfaces[i].refcount == 1) &&
+		  (new->flags == dev_priv->surfaces[i].flags) &&
+		  (new_upper + 1 == dev_priv->surfaces[i].lower)) {
+			s = &(dev_priv->virt_surfaces[virt_surface_index]);
+			s->surface_index = i;
+			s->lower = new_lower;
+			s->upper = new_upper;
+			s->flags = new->flags;
+			s->filp = filp;
+			dev_priv->surfaces[i].refcount++;
+			dev_priv->surfaces[i].lower = s->lower;
+			radeon_apply_surface_regs(s->surface_index, dev_priv);
+			return virt_surface_index;
+		}
+
+		/* extend after */
+		if ((dev_priv->surfaces[i].refcount == 1) &&
+		  (new->flags == dev_priv->surfaces[i].flags) &&
+		  (new_lower == dev_priv->surfaces[i].upper + 1)) {
+			s = &(dev_priv->virt_surfaces[virt_surface_index]);
+			s->surface_index = i;
+			s->lower = new_lower;
+			s->upper = new_upper;
+			s->flags = new->flags;
+			s->filp = filp;
+			dev_priv->surfaces[i].refcount++;
+			dev_priv->surfaces[i].upper = s->upper;
+			radeon_apply_surface_regs(s->surface_index, dev_priv);
+			return virt_surface_index;
+		}
+	}
+
+	/* okay, we need a new one */
+	for (i = 0; i < RADEON_MAX_SURFACES; i++) {
+		if (dev_priv->surfaces[i].refcount == 0) {
+			s = &(dev_priv->virt_surfaces[virt_surface_index]);
+			s->surface_index = i;
+			s->lower = new_lower;
+			s->upper = new_upper;
+			s->flags = new->flags;
+			s->filp = filp;
+			dev_priv->surfaces[i].refcount = 1;
+			dev_priv->surfaces[i].lower = s->lower;
+			dev_priv->surfaces[i].upper = s->upper;
+			dev_priv->surfaces[i].flags = s->flags;
+			radeon_apply_surface_regs(s->surface_index, dev_priv);
+			return virt_surface_index;
+		}
+	}
+
+	/* we didn't find anything */
+	return -1;
+}
+
+static int free_surface(DRMFILE filp, drm_radeon_private_t *dev_priv, int lower)
+{
+	struct radeon_virt_surface *s;
+	int i;
+	/* find the virtual surface */
+	for(i = 0; i < 2*RADEON_MAX_SURFACES; i++) {
+		s = &(dev_priv->virt_surfaces[i]);
+		if (s->filp) {
+			if ((lower == s->lower) && (filp == s->filp)) {
+				if (dev_priv->surfaces[s->surface_index].lower == s->lower)
+					dev_priv->surfaces[s->surface_index].lower = s->upper;
+
+				if (dev_priv->surfaces[s->surface_index].upper == s->upper)
+					dev_priv->surfaces[s->surface_index].upper = s->lower;
+
+				dev_priv->surfaces[s->surface_index].refcount--;
+				if (dev_priv->surfaces[s->surface_index].refcount == 0)
+					dev_priv->surfaces[s->surface_index].flags = 0;
+				s->filp = 0;
+				radeon_apply_surface_regs(s->surface_index, dev_priv);
+				return 0;
+			}
+		}
+	}
+	return 1;
+}
+
+static void radeon_surfaces_release(DRMFILE filp, drm_radeon_private_t *dev_priv)
+{
+	int i;
+	for( i = 0; i < 2*RADEON_MAX_SURFACES; i++)
+	{
+		if (dev_priv->virt_surfaces[i].filp == filp)
+			free_surface(filp, dev_priv, dev_priv->virt_surfaces[i].lower);
+	}
+}
 
 /* ================================================================
  * IOCTL functions
  */
+int radeon_surface_alloc(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_surface_alloc_t alloc;
+
+	if (!dev_priv) {
+		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+		return DRM_ERR(EINVAL);
+	}
+
+	DRM_COPY_FROM_USER_IOCTL(alloc, (drm_radeon_surface_alloc_t __user *)data,
+				  sizeof(alloc));
+
+	if (alloc_surface(&alloc, dev_priv, filp) == -1)
+		return DRM_ERR(EINVAL);
+	else
+		return 0;
+}
+
+int radeon_surface_free(DRM_IOCTL_ARGS)
+{
+	DRM_DEVICE;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_surface_free_t memfree;
+
+	if (!dev_priv) {
+		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+		return DRM_ERR(EINVAL);
+	}
+
+	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_mem_free_t __user *)data,
+				  sizeof(memfree) );
+
+	if (free_surface(filp, dev_priv, memfree.address))
+		return DRM_ERR(EINVAL);
+	else
+		return 0;
+}
 
 int radeon_cp_clear( DRM_IOCTL_ARGS )
 {
@@ -2539,6 +2928,20 @@ int radeon_cp_setparam( DRM_IOCTL_ARGS )
 		radeon_priv = filp_priv->driver_priv;
 		radeon_priv->radeon_fb_delta = dev_priv->fb_location - sp.value;
 		break;
+	case RADEON_SETPARAM_SWITCH_TILING:
+		if (sp.value == 0) {
+			DRM_DEBUG( "color tiling disabled\n" );
+			dev_priv->front_pitch_offset &= ~RADEON_DST_TILE_MACRO;
+			dev_priv->back_pitch_offset &= ~RADEON_DST_TILE_MACRO;
+			dev_priv->sarea_priv->tiling_enabled = 0;
+		}
+		else if (sp.value == 1) {
+			DRM_DEBUG( "color tiling enabled\n" );
+			dev_priv->front_pitch_offset |= RADEON_DST_TILE_MACRO;
+			dev_priv->back_pitch_offset |= RADEON_DST_TILE_MACRO;
+			dev_priv->sarea_priv->tiling_enabled = 1;
+		}
+		break;	
 	default:
 		DRM_DEBUG( "Invalid parameter %d\n", sp.param );
 		return DRM_ERR( EINVAL );
@@ -2562,6 +2965,7 @@ void radeon_driver_prerelease(drm_device
 		}						
 		radeon_mem_release( filp, dev_priv->gart_heap ); 
 		radeon_mem_release( filp, dev_priv->fb_heap );	
+		radeon_surfaces_release(filp, dev_priv);
 	}				
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/sis.h linux-2.6.11-rc3/drivers/char/drm/sis.h
--- linux-2.6.11-rc2-bk10/drivers/char/drm/sis.h	2005-01-22 02:49:09.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/sis.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-/* sis_drv.h -- Private header for sis driver -*- linux-c -*-
- *
- * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
- * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
- * All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- * 
- */
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/linux/drm/kernel/sis.h,v 1.3 2002/10/30 12:52:38 alanh Exp $ */
-
-#ifndef __SIS_H__
-#define __SIS_H__
-
-/* This remains constant for all DRM template files.
- * Name it sisdrv_##x as there's a conflict with sis_free/malloc in the kernel
- * that's used for fb devices 
- */
-#ifdef __linux__
-#define DRM(x) sisdrv_##x
-#else
-#define DRM(x) sis_##x
-#endif
-
-/* General customization:
- */
-
-#define DRIVER_AUTHOR		"SIS"
-#define DRIVER_NAME		"sis"
-#define DRIVER_DESC		"SIS 300/630/540"
-#define DRIVER_DATE		"20030826"
-#define DRIVER_MAJOR		1
-#define DRIVER_MINOR		1
-#define DRIVER_PATCHLEVEL	0
-
-#define DRIVER_IOCTLS \
-	[DRM_IOCTL_NR(DRM_IOCTL_SIS_FB_ALLOC)]  = { sis_fb_alloc,	1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_SIS_FB_FREE)]   = { sis_fb_free,	1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_SIS_AGP_INIT)]  = { sis_ioctl_agp_init,	1, 1 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_SIS_AGP_ALLOC)] = { sis_ioctl_agp_alloc, 1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_SIS_AGP_FREE)]	= { sis_ioctl_agp_free,	1, 0 }, \
-	[DRM_IOCTL_NR(DRM_IOCTL_SIS_FB_INIT)]	= { sis_fb_init,	1, 1 }
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/sis_drv.c linux-2.6.11-rc3/drivers/char/drm/sis_drv.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/sis_drv.c	2005-01-22 02:46:43.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/sis_drv.c	2005-02-03 02:54:38.000000000 +0100
@@ -63,14 +63,8 @@ static struct pci_device_id pciidlist[] 
 	sisdrv_PCI_IDS
 };
 
-static drm_ioctl_desc_t ioctls[] = {
-	[DRM_IOCTL_NR(DRM_SIS_FB_ALLOC)]  = { sis_fb_alloc,        1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_FB_FREE)]   = { sis_fb_free,         1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_AGP_INIT)]  = { sis_ioctl_agp_init,  1, 1 },
-	[DRM_IOCTL_NR(DRM_SIS_AGP_ALLOC)] = { sis_ioctl_agp_alloc, 1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_AGP_FREE)]  = { sis_ioctl_agp_free,  1, 0 },
-	[DRM_IOCTL_NR(DRM_SIS_FB_INIT)]   = { sis_fb_init,         1, 1 }
-};
+extern drm_ioctl_desc_t sis_ioctls[];
+extern int sis_max_ioctl;
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_USE_AGP | DRIVER_USE_MTRR,
@@ -81,8 +75,7 @@ static struct drm_driver driver = {
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.postinit = postinit,
 	.version = version,
-	.ioctls = ioctls,
-	.num_ioctls = DRM_ARRAY_SIZE(ioctls),
+	.ioctls = sis_ioctls,
 	.fops = {
 		.owner = THIS_MODULE,
 		.open = drm_open,
@@ -100,6 +93,7 @@ static struct drm_driver driver = {
 
 static int __init sis_init(void)
 {
+	driver.num_ioctls = sis_max_ioctl;
 	return drm_init(&driver);
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/drm/sis_mm.c linux-2.6.11-rc3/drivers/char/drm/sis_mm.c
--- linux-2.6.11-rc2-bk10/drivers/char/drm/sis_mm.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/drm/sis_mm.c	2005-02-03 02:56:21.000000000 +0100
@@ -36,6 +36,17 @@
 #include <video/sisfb.h>
 #endif
 
+drm_ioctl_desc_t sis_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_SIS_FB_ALLOC)]  = { sis_fb_alloc,        1, 0 },
+	[DRM_IOCTL_NR(DRM_SIS_FB_FREE)]   = { sis_fb_free,         1, 0 },
+	[DRM_IOCTL_NR(DRM_SIS_AGP_INIT)]  = { sis_ioctl_agp_init,  1, 1 },
+	[DRM_IOCTL_NR(DRM_SIS_AGP_ALLOC)] = { sis_ioctl_agp_alloc, 1, 0 },
+	[DRM_IOCTL_NR(DRM_SIS_AGP_FREE)]  = { sis_ioctl_agp_free,  1, 0 },
+	[DRM_IOCTL_NR(DRM_SIS_FB_INIT)]   = { sis_fb_init,         1, 1 }
+};
+
+int sis_max_ioctl = DRM_ARRAY_SIZE(sis_ioctls);
+
 #define MAX_CONTEXT 100
 #define VIDEO_TYPE 0 
 #define AGP_TYPE 1
diff -purN linux-2.6.11-rc2-bk10/drivers/char/ftape/compressor/zftape-compress.c linux-2.6.11-rc3/drivers/char/ftape/compressor/zftape-compress.c
--- linux-2.6.11-rc2-bk10/drivers/char/ftape/compressor/zftape-compress.c	2005-02-03 10:03:09.171473700 +0100
+++ linux-2.6.11-rc3/drivers/char/ftape/compressor/zftape-compress.c	2005-02-03 02:56:35.000000000 +0100
@@ -1172,7 +1172,7 @@ int zft_compressor_init(void)
         if (TRACE_LEVEL >= ft_t_info) {
 		printk(
 KERN_INFO "(c) 1997 Claus-Justus Heine (claus@momo.math.rwth-aachen.de)\n"
-KERN_INFO "Compressor for zftape (lzrw3 algorithm)\n"
+KERN_INFO "Compressor for zftape (lzrw3 algorithm)\n");
         }
 #else /* !MODULE */
 	/* print a short no-nonsense boot message */
diff -purN linux-2.6.11-rc2-bk10/drivers/char/ftape/lowlevel/ftape-init.c linux-2.6.11-rc3/drivers/char/ftape/lowlevel/ftape-init.c
--- linux-2.6.11-rc2-bk10/drivers/char/ftape/lowlevel/ftape-init.c	2005-02-03 10:03:09.172473545 +0100
+++ linux-2.6.11-rc3/drivers/char/ftape/lowlevel/ftape-init.c	2005-02-03 02:56:35.000000000 +0100
@@ -72,7 +72,7 @@ static int __init ftape_init(void)
 KERN_INFO "(c) 1993-1996 Bas Laarhoven (bas@vimec.nl)\n"
 KERN_INFO "(c) 1995-1996 Kai Harrekilde-Petersen (khp@dolphinics.no)\n"
 KERN_INFO "(c) 1996-1997 Claus-Justus Heine (claus@momo.math.rwth-aachen.de)\n"
-KERN_INFO "QIC-117 driver for QIC-40/80/3010/3020 floppy tape drives\n"
+KERN_INFO "QIC-117 driver for QIC-40/80/3010/3020 floppy tape drives\n");
         }
 #else /* !MODULE */
 	/* print a short no-nonsense boot message */
diff -purN linux-2.6.11-rc2-bk10/drivers/char/ite_gpio.c linux-2.6.11-rc3/drivers/char/ite_gpio.c
--- linux-2.6.11-rc2-bk10/drivers/char/ite_gpio.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/ite_gpio.c	2005-02-03 02:56:22.000000000 +0100
@@ -30,9 +30,7 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-
 #include <linux/module.h>
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/miscdevice.h>
@@ -238,10 +236,6 @@ EXPORT_SYMBOL(ite_gpio_int_wait);
 
 static int ite_gpio_open(struct inode *inode, struct file *file)
 {
-	unsigned int minor = iminor(inode); 
-	if (minor != GPIO_MINOR)
-		return -ENODEV;
-
 	return 0;
 }
 
@@ -255,7 +249,6 @@ static int ite_gpio_release(struct inode
 static int ite_gpio_ioctl(struct inode *inode, struct file *file,
 	unsigned int cmd, unsigned long arg)
 {
-
 	static struct ite_gpio_ioctl_data ioctl_data;
 
 	if (copy_from_user(&ioctl_data, (struct ite_gpio_ioctl_data *)arg,
@@ -314,10 +307,12 @@ static int ite_gpio_ioctl(struct inode *
 			return -ENOIOCTLCMD;
 
 	}
+
 	return 0;
 }
 
-static void ite_gpio_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+static void ite_gpio_irq_handler(int this_irq, void *dev_id,
+	struct pt_regs *regs)
 {
 	int i,line;
 
@@ -362,18 +357,15 @@ DEB(printk("interrupt 0x%x %d\n",ITE_GPA
 	}
 }
 
-static struct file_operations ite_gpio_fops =
-{
+static struct file_operations ite_gpio_fops = {
 	.owner		= THIS_MODULE,
 	.ioctl		= ite_gpio_ioctl,
 	.open		= ite_gpio_open,
 	.release	= ite_gpio_release,
 };
 
-/* GPIO_MINOR in include/linux/miscdevice.h */
-static struct miscdevice ite_gpio_miscdev =
-{
-	GPIO_MINOR,
+static struct miscdevice ite_gpio_miscdev = {
+	MISC_DYNAMIC_MINOR,
 	"ite_gpio",
 	&ite_gpio_fops
 };
@@ -416,7 +408,7 @@ int __init ite_gpio_init(void)
 	return 0;
 }	
 
-void __exit ite_gpio_exit(void)
+static void __exit ite_gpio_exit(void)
 {
 	misc_deregister(&ite_gpio_miscdev);
 }
diff -purN linux-2.6.11-rc2-bk10/drivers/char/n_tty.c linux-2.6.11-rc3/drivers/char/n_tty.c
--- linux-2.6.11-rc2-bk10/drivers/char/n_tty.c	2005-01-22 02:46:46.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/n_tty.c	2005-02-03 02:54:39.000000000 +0100
@@ -1143,13 +1143,13 @@ static inline int copy_from_read_buf(str
 
 {
 	int retval;
-	ssize_t n;
+	size_t n;
 	unsigned long flags;
 
 	retval = 0;
 	spin_lock_irqsave(&tty->read_lock, flags);
 	n = min(tty->read_cnt, N_TTY_BUF_SIZE - tty->read_tail);
-	n = min((ssize_t)*nr, n);
+	n = min(*nr, n);
 	spin_unlock_irqrestore(&tty->read_lock, flags);
 	if (n) {
 		mb();
diff -purN linux-2.6.11-rc2-bk10/drivers/char/random.c linux-2.6.11-rc3/drivers/char/random.c
--- linux-2.6.11-rc2-bk10/drivers/char/random.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/random.c	2005-02-03 02:55:07.000000000 +0100
@@ -1322,7 +1322,7 @@ static inline void xfer_secondary_pool(s
 
 		bytes=extract_entropy(random_state, tmp, bytes,
 				      EXTRACT_ENTROPY_LIMIT);
-		add_entropy_words(r, tmp, bytes);
+		add_entropy_words(r, tmp, (bytes + 3) / 4);
 		credit_entropy_store(r, bytes*8);
 	}
 }
diff -purN linux-2.6.11-rc2-bk10/drivers/char/serial_tx3912.c linux-2.6.11-rc3/drivers/char/serial_tx3912.c
--- linux-2.6.11-rc2-bk10/drivers/char/serial_tx3912.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/serial_tx3912.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,981 +0,0 @@
-/*
- *  drivers/char/serial_tx3912.c
- *
- *  Copyright (C) 1999 Harald Koerfgen
- *  Copyright (C) 2000 Jim Pick <jim@jimpick.com>
- *  Copyright (C) 2001 Steven J. Hill (sjhill@realitydiluted.com)
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *  
- *  Serial driver for TMPR3912/05 and PR31700 processors
- */
-#include <linux/init.h>
-#include <linux/config.h>
-#include <linux/tty.h>
-#include <linux/major.h>
-#include <linux/ptrace.h>
-#include <linux/console.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/delay.h>
-#include <asm/wbflush.h>
-#include <asm/tx3912.h>
-#include "serial_tx3912.h"
-
-/*
- * Forward declarations for serial routines
- */
-static void rs_disable_tx_interrupts (void * ptr);
-static void rs_enable_tx_interrupts (void * ptr); 
-static void rs_disable_rx_interrupts (void * ptr); 
-static void rs_enable_rx_interrupts (void * ptr); 
-static int rs_get_CD (void * ptr); 
-static void rs_shutdown_port (void * ptr); 
-static int rs_set_real_termios (void *ptr);
-static int rs_chars_in_buffer (void * ptr); 
-
-/*
- * Used by generic serial driver to access hardware
- */
-static struct real_driver rs_real_driver = { 
-	.disable_tx_interrupts = rs_disable_tx_interrupts, 
-	.enable_tx_interrupts  = rs_enable_tx_interrupts, 
-	.disable_rx_interrupts = rs_disable_rx_interrupts, 
-	.enable_rx_interrupts  = rs_enable_rx_interrupts, 
-	.get_CD                = rs_get_CD, 
-	.shutdown_port         = rs_shutdown_port,  
-	.set_real_termios      = rs_set_real_termios,  
-	.chars_in_buffer       = rs_chars_in_buffer, 
-}; 
-
-/*
- * Structures and such for TTY sessions and usage counts
- */
-static struct tty_driver *rs_driver;
-struct rs_port *rs_ports;
-int rs_initialized = 0;
-
-/*
- * ----------------------------------------------------------------------
- *
- * Here starts the interrupt handling routines.  All of the following
- * subroutines are declared as inline and are folded into
- * rs_interrupt().  They were separated out for readability's sake.
- *
- * Note: rs_interrupt() is a "fast" interrupt, which means that it
- * runs with interrupts turned off.  People who may want to modify
- * rs_interrupt() should try to keep the interrupt handler as fast as
- * possible.  After you are done making modifications, it is not a bad
- * idea to do:
- * 
- * gcc -S -DKERNEL -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer serial.c
- *
- * and look at the resulting assemble code in serial.s.
- *
- * 				- Ted Ts'o (tytso@mit.edu), 7-Mar-93
- * -----------------------------------------------------------------------
- */
-static inline void receive_char_pio(struct rs_port *port)
-{
-	struct tty_struct *tty = port->gs.tty;
-	unsigned char ch;
-	int counter = 2048;
-
-	/* While there are characters, get them ... */
-	while (counter>0) {
-		if (!(inl(port->base + TX3912_UART_CTRL1) & UART_RX_HOLD_FULL))
-			break;
-		ch = inb(port->base + TX3912_UART_DATA);
-		if (tty->flip.count < TTY_FLIPBUF_SIZE) {
-			*tty->flip.char_buf_ptr++ = ch;
-			*tty->flip.flag_buf_ptr++ = 0;
-			tty->flip.count++;
-		}
-		udelay(1); /* Allow things to happen - it take a while */
-		counter--;
-	}
-	if (!counter)
-		printk( "Ugh, looped in receive_char_pio!\n" );
-
-	tty_flip_buffer_push(tty);
-
-#if 0
-	/* Now handle error conditions */
-	if (*status & (INTTYPE(UART_RXOVERRUN_INT) |
-			INTTYPE(UART_FRAMEERR_INT) |
-			INTTYPE(UART_PARITYERR_INT) |
-			INTTYPE(UART_BREAK_INT))) {
-
-		/*
-		 * Now check to see if character should be
-		 * ignored, and mask off conditions which
-		 * should be ignored.
-	       	 */
-		if (*status & port->ignore_status_mask) {
-			goto ignore_char;
-		}
-		*status &= port->read_status_mask;
-		
-		if (*status & INTTYPE(UART_BREAK_INT)) {
-			rs_dprintk(TX3912_UART_DEBUG_INTERRUPTS, "handling break....");
-			*tty->flip.flag_buf_ptr = TTY_BREAK;
-		}
-		else if (*status & INTTYPE(UART_PARITYERR_INT)) {
-			*tty->flip.flag_buf_ptr = TTY_PARITY;
-		}
-		else if (*status & INTTYPE(UART_FRAMEERR_INT)) {
-			*tty->flip.flag_buf_ptr = TTY_FRAME;
-		}
-		if (*status & INTTYPE(UART_RXOVERRUN_INT)) {
-			/*
-			 * Overrun is special, since it's
-			 * reported immediately, and doesn't
-			 * affect the current character
-			 */
-			if (tty->flip.count < TTY_FLIPBUF_SIZE) {
-				tty->flip.count++;
-				tty->flip.flag_buf_ptr++;
-				tty->flip.char_buf_ptr++;
-				*tty->flip.flag_buf_ptr = TTY_OVERRUN;
-			}
-		}
-	}
-
-	tty->flip.flag_buf_ptr++;
-	tty->flip.char_buf_ptr++;
-	tty->flip.count++;
-
-ignore_char:
-	tty_flip_buffer_push(tty);
-#endif
-}
-
-static inline void transmit_char_pio(struct rs_port *port)
-{
-	/* While I'm able to transmit ... */
-	for (;;) {
-		if (!(inl(port->base + TX3912_UART_CTRL1) & UART_TX_EMPTY))
-			break;
-		else if (port->x_char) {
-			outb(port->x_char, port->base + TX3912_UART_DATA);
-			port->icount.tx++;
-			port->x_char = 0;
-		}
-		else if (port->gs.xmit_cnt <= 0 || port->gs.tty->stopped ||
-		    port->gs.tty->hw_stopped) {
-			break;
-		}
-		else {
-			outb(port->gs.xmit_buf[port->gs.xmit_tail++],
-				port->base + TX3912_UART_DATA);
-			port->icount.tx++;
-			port->gs.xmit_tail &= SERIAL_XMIT_SIZE-1;
-			if (--port->gs.xmit_cnt <= 0) {
-				break;
-			}
-		}
-		udelay(10); /* Allow things to happen - it take a while */
-	}
-
-	if (port->gs.xmit_cnt <= 0 || port->gs.tty->stopped ||
-	     port->gs.tty->hw_stopped) {
-		rs_disable_tx_interrupts(port);
-	}
-	
-        if (port->gs.xmit_cnt <= port->gs.wakeup_chars) {
-        	tty_wakeup(port->gs.tty);
-                rs_dprintk (TX3912_UART_DEBUG_TRANSMIT, "Waking up.... ldisc (%d)....\n",
-                            port->gs.wakeup_chars); 
-       	}	
-}
-
-
-
-static inline void check_modem_status(struct rs_port *port)
-{
-        /* We don't have a carrier detect line - but just respond
-           like we had one anyways so that open() becomes unblocked */
-	wake_up_interruptible(&port->gs.open_wait);
-}
-
-int count = 0;
-
-/*
- * This is the serial driver's interrupt routine (inlined, because
- * there are two different versions of this, one for each serial port,
- * differing only by the bits used in interrupt status 2 register)
- */
-
-static inline void rs_rx_interrupt(int irq, void *dev_id,
-				  struct pt_regs * regs, int intshift)
-{
-	struct rs_port * port;
-	unsigned long int2status;
-	unsigned long flags;
-	unsigned long ints;
-
-	save_and_cli(flags);
-
-	port = (struct rs_port *)dev_id;
-	rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "rs_interrupt (port %p, shift %d)...", port, intshift);
-
-	/* Get the interrrupts we have enabled */
-	int2status = IntStatus2 & IntEnable2;
-
-	/* Get interrupts in easy to use form */
-	ints = int2status >> intshift;
-
-	/* Clear any interrupts we might be about to handle */
-	IntClear2 = int2status & (
-		(INTTYPE(UART_RXOVERRUN_INT) |
-		 INTTYPE(UART_FRAMEERR_INT) |
-		 INTTYPE(UART_BREAK_INT) |
-		 INTTYPE(UART_PARITYERR_INT) |
-		 INTTYPE(UART_RX_INT)) << intshift);
-
-	if (!port || !port->gs.tty) {
-		restore_flags(flags);
-		return;
-	}
-
-	/* RX Receiver Holding Register Overrun */
-	if (ints & INTTYPE(UART_RXOVERRUN_INT)) {
-		rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "overrun");
-		port->icount.overrun++;
-	}
-
-	/* RX Frame Error */
-	if (ints & INTTYPE(UART_FRAMEERR_INT)) {
-		rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "frame error");
-		port->icount.frame++;
-	}
-
-	/* Break signal received */
-	if (ints & INTTYPE(UART_BREAK_INT)) {
-		rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "break");
-		port->icount.brk++;
-      	}
-
-	/* RX Parity Error */
-	if (ints & INTTYPE(UART_PARITYERR_INT)) {
-		rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "parity error");
-		port->icount.parity++;
-	}
-
-	/* Receive byte (non-DMA) */
-	if (ints & INTTYPE(UART_RX_INT)) {
-		receive_char_pio(port);
-	}
-
-	restore_flags(flags);
-
-	rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "end.\n");
-}
-
-static inline void rs_tx_interrupt(int irq, void *dev_id,
-				  struct pt_regs * regs, int intshift)
-{
-	struct rs_port * port;
-	unsigned long int2status;
-	unsigned long flags;
-	unsigned long ints;
-
-	save_and_cli(flags);
-
-	port = (struct rs_port *)dev_id;
-	rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "rs_interrupt (port %p, shift %d)...", port, intshift);
-
-	/* Get the interrrupts we have enabled */
-	int2status = IntStatus2 & IntEnable2;
-
-	if (!port || !port->gs.tty) {
-		restore_flags(flags);
-		return;
-	}
-
-	/* Get interrupts in easy to use form */
-	ints = int2status >> intshift;
-
-	/* Clear any interrupts we might be about to handle */
-	IntClear2 = int2status & (
-		(INTTYPE(UART_TX_INT) |
-		 INTTYPE(UART_EMPTY_INT) |
-		 INTTYPE(UART_TXOVERRUN_INT)) << intshift);
-
-	/* TX holding register empty, so transmit byte (non-DMA) */
-	if (ints & (INTTYPE(UART_TX_INT) | INTTYPE(UART_EMPTY_INT))) {
-		transmit_char_pio(port);
-	}
-
-	/* TX Transmit Holding Register Overrun (shouldn't happen) */
-	if (ints & INTTYPE(UART_TXOVERRUN_INT)) {
-		printk ( "rs: TX overrun\n");
-	}
-
-	/*
-	check_modem_status();
-	*/
-
-	restore_flags(flags);
-
-	rs_dprintk (TX3912_UART_DEBUG_INTERRUPTS, "end.\n");
-}
-
-static void rs_rx_interrupt_uarta(int irq, void *dev_id,
-					 struct pt_regs * regs)
-{
-	rs_rx_interrupt(irq, dev_id, regs, UARTA_SHIFT);
-}
-
-static void rs_tx_interrupt_uarta(int irq, void *dev_id,
-					 struct pt_regs * regs)
-{
-	rs_tx_interrupt(irq, dev_id, regs, UARTA_SHIFT);
-}
-
-/*
- ***********************************************************************
- *                Here are the routines that actually                  *
- *              interface with the generic_serial driver               *
- ***********************************************************************
- */
-static void rs_disable_tx_interrupts (void * ptr) 
-{
-	struct rs_port *port = ptr; 
-	unsigned long flags;
-
-	save_and_cli(flags);
-        port->gs.flags &= ~GS_TX_INTEN;
-
-	IntEnable2 &= ~((INTTYPE(UART_TX_INT) |
-			INTTYPE(UART_EMPTY_INT) |
-			INTTYPE(UART_TXOVERRUN_INT)) << port->intshift);
-
-	IntClear2 = (INTTYPE(UART_TX_INT) |
-			INTTYPE(UART_EMPTY_INT) |
-			INTTYPE(UART_TXOVERRUN_INT)) << port->intshift;
-
-	restore_flags(flags);
-}
-
-static void rs_enable_tx_interrupts (void * ptr) 
-{
-	struct rs_port *port = ptr; 
-	unsigned long flags;
-
-	save_and_cli(flags);
-
-	IntClear2 = (INTTYPE(UART_TX_INT) |
-			INTTYPE(UART_EMPTY_INT) |
-			INTTYPE(UART_TXOVERRUN_INT)) << port->intshift;
-
-	IntEnable2 |= (INTTYPE(UART_TX_INT) |
-			INTTYPE(UART_EMPTY_INT) |
-			INTTYPE(UART_TXOVERRUN_INT)) << port->intshift;
-
-	/* Send a char to start TX interrupts happening */
-	transmit_char_pio(port);
-
-	restore_flags(flags);
-}
-
-static void rs_disable_rx_interrupts (void * ptr) 
-{
-	struct rs_port *port = ptr;
-	unsigned long flags;
-
-	save_and_cli(flags);
-
-	IntEnable2 &= ~((INTTYPE(UART_RX_INT) |
-			 INTTYPE(UART_RXOVERRUN_INT) |
-			 INTTYPE(UART_FRAMEERR_INT) |
-			 INTTYPE(UART_BREAK_INT) |
-			 INTTYPE(UART_PARITYERR_INT)) << port->intshift);
-
-	IntClear2 = (INTTYPE(UART_RX_INT) |
-			 INTTYPE(UART_RXOVERRUN_INT) |
-			 INTTYPE(UART_FRAMEERR_INT) |
-			 INTTYPE(UART_BREAK_INT) |
-			 INTTYPE(UART_PARITYERR_INT)) << port->intshift;
-
-	restore_flags(flags);
-}
-
-static void rs_enable_rx_interrupts (void * ptr) 
-{
-	struct rs_port *port = ptr;
-	unsigned long flags;
-
-	save_and_cli(flags);
-
-	IntEnable2 |= (INTTYPE(UART_RX_INT) |
-			 INTTYPE(UART_RXOVERRUN_INT) |
-			 INTTYPE(UART_FRAMEERR_INT) |
-			 INTTYPE(UART_BREAK_INT) |
-			 INTTYPE(UART_PARITYERR_INT)) << port->intshift;
-
-	/* Empty the input buffer - apparently this is *vital* */
-	while (inl(port->base + TX3912_UART_CTRL1) & UART_RX_HOLD_FULL) { 
-		inb(port->base + TX3912_UART_DATA);
-	}
-
-	IntClear2 = (INTTYPE(UART_RX_INT) |
-			 INTTYPE(UART_RXOVERRUN_INT) |
-			 INTTYPE(UART_FRAMEERR_INT) |
-			 INTTYPE(UART_BREAK_INT) |
-			 INTTYPE(UART_PARITYERR_INT)) << port->intshift;
-
-	restore_flags(flags);
-}
-
-
-static int rs_get_CD (void * ptr) 
-{
-	/* No Carried Detect in Hardware - just return true */
-	func_exit();
-	return (1);
-}
-
-static void rs_shutdown_port (void * ptr) 
-{
-	struct rs_port *port = ptr; 
-
-	func_enter();
-
-	port->gs.flags &= ~GS_ACTIVE;
-
-	func_exit();
-}
-
-static int rs_set_real_termios (void *ptr)
-{
-	struct rs_port *port = ptr;
-	int t;
-
-	switch (port->gs.baud) {
-		/* Save some typing work... */
-#define e(x) case x:t= TX3912_UART_CTRL2_B ## x ; break
-		e(300);e(600);e(1200);e(2400);e(4800);e(9600);
-		e(19200);e(38400);e(57600);e(76800);e(115200);e(230400);
-	case 0      :t = -1;
-		break;
-	default:
-		/* Can I return "invalid"? */
-		t = TX3912_UART_CTRL2_B9600;
-		printk (KERN_INFO "rs: unsupported baud rate: %d.\n", port->gs.baud);
-		break;
-	}
-#undef e
-	if (t >= 0) {
-		/* Jim: Set Hardware Baud rate - there is some good
-		   code in drivers/char/serial.c */
-
-	  	/* Program hardware for parity, data bits, stop bits (note: these are hardcoded to 8N1 */
-		UartA_Ctrl1 &= 0xf000000f;
-		UartA_Ctrl1 &= ~(UART_DIS_TXD | SER_SEVEN_BIT | SER_EVEN_PARITY | SER_TWO_STOP);
-
-#define CFLAG port->gs.tty->termios->c_cflag
-		if (C_PARENB(port->gs.tty)) {
-			if (!C_PARODD(port->gs.tty))
-				UartA_Ctrl1 |= SER_EVEN_PARITY;
-			else
-				UartA_Ctrl1 |= SER_ODD_PARITY;
-		}
-		if ((CFLAG & CSIZE)==CS6)
-			printk(KERN_ERR "6 bits not supported\n");
-		if ((CFLAG & CSIZE)==CS5)
-			printk(KERN_ERR "5 bits not supported\n");
-		if ((CFLAG & CSIZE)==CS7)
-			UartA_Ctrl1 |= SER_SEVEN_BIT;
-		if (C_CSTOPB(port->gs.tty))
-			UartA_Ctrl1 |= SER_TWO_STOP;
-
-		outl(t, port->base + TX3912_UART_CTRL2);
-		outl(0, port->base + TX3912_UART_DMA_CTRL1);
-		outl(0, port->base + TX3912_UART_DMA_CTRL2);
-        	UartA_Ctrl1 |= TX3912_UART_CTRL1_UARTON;
-
-        /* wait until UARTA is stable */
-        while (~UartA_Ctrl1 & TX3912_UART_CTRL1_UARTON);
-	}
-
-	func_exit ();
-        return 0;
-}
-
-static int rs_chars_in_buffer (void * ptr) 
-{
-	struct rs_port *port = ptr;
-	int scratch;
-
-	scratch = inl(port->base + TX3912_UART_CTRL1);
-
-	return ((scratch & UART_TX_EMPTY) ? 0 : 1);
-}
-
-/* ********************************************************************** *
- *                Here are the routines that actually                     *
- *               interface with the rest of the system                    *
- * ********************************************************************** */
-static int rs_open  (struct tty_struct * tty, struct file * filp)
-{
-	struct rs_port *port;
-	int retval, line;
-
-	func_enter();
-
-	if (!rs_initialized) {
-		return -EIO;
-	}
-
-	line = tty->index;
-	rs_dprintk (TX3912_UART_DEBUG_OPEN, "%d: opening line %d. tty=%p ctty=%p)\n", 
-	            (int) current->pid, line, tty, current->tty);
-
-	if ((line < 0) || (line >= TX3912_UART_NPORTS))
-		return -ENODEV;
-
-	/* Pre-initialized already */
-	port = & rs_ports[line];
-
-	rs_dprintk (TX3912_UART_DEBUG_OPEN, "port = %p\n", port);
-
-	tty->driver_data = port;
-	port->gs.tty = tty;
-	port->gs.count++;
-
-	rs_dprintk (TX3912_UART_DEBUG_OPEN, "starting port\n");
-
-	/*
-	 * Start up serial port
-	 */
-	retval = gs_init_port(&port->gs);
-	rs_dprintk (TX3912_UART_DEBUG_OPEN, "done gs_init\n");
-	if (retval) {
-		port->gs.count--;
-		return retval;
-	}
-
-	port->gs.flags |= GS_ACTIVE;
-
-	rs_dprintk (TX3912_UART_DEBUG_OPEN, "before inc_use_count (count=%d.\n", 
-	            port->gs.count);
-	rs_dprintk (TX3912_UART_DEBUG_OPEN, "after inc_use_count\n");
-
-	/* Jim: Initialize port hardware here */
-
-	/* Enable high-priority interrupts for UARTA */
-	IntEnable6 |= INT6_UARTARXINT; 
-	rs_enable_rx_interrupts(&rs_ports[0]); 
-
-	retval = gs_block_til_ready(&port->gs, filp);
-	rs_dprintk (TX3912_UART_DEBUG_OPEN, "Block til ready returned %d. Count=%d\n", 
-	            retval, port->gs.count);
-
-	if (retval) {
-		port->gs.count--;
-		return retval;
-	}
-	/* tty->low_latency = 1; */
-
-	func_exit();
-
-	/* Jim */
-/*	cli(); */
-
-	return 0;
-
-}
-
-
-static int rs_ioctl (struct tty_struct * tty, struct file * filp, 
-                     unsigned int cmd, unsigned long arg)
-{
-	int rc;
-	struct rs_port *port = tty->driver_data;
-	int ival;
-
-	rc = 0;
-	switch (cmd) {
-	case TIOCGSOFTCAR:
-		rc = put_user(((tty->termios->c_cflag & CLOCAL) ? 1 : 0),
-		              (unsigned int *) arg);
-		break;
-	case TIOCSSOFTCAR:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			tty->termios->c_cflag =
-				(tty->termios->c_cflag & ~CLOCAL) |
-				(ival ? CLOCAL : 0);
-		}
-		break;
-	case TIOCGSERIAL:
-		if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
-		                      sizeof(struct serial_struct))) == 0)
-			rc = gs_getserial(&port->gs, (struct serial_struct *) arg);
-		break;
-	case TIOCSSERIAL:
-		if ((rc = verify_area(VERIFY_READ, (void *) arg,
-		                      sizeof(struct serial_struct))) == 0)
-			rc = gs_setserial(&port->gs, (struct serial_struct *) arg);
-		break;
-	default:
-		rc = -ENOIOCTLCMD;
-		break;
-	}
-
-	/* func_exit(); */
-	return rc;
-}
-
-
-/*
- * This function is used to send a high-priority XON/XOFF character to
- * the device
- */
-static void rs_send_xchar(struct tty_struct * tty, char ch)
-{
-	struct rs_port *port = (struct rs_port *)tty->driver_data;
-	func_enter ();
-	
-	port->x_char = ch;
-	if (ch) {
-		/* Make sure transmit interrupts are on */
-		rs_enable_tx_interrupts(tty);
-	}
-
-	func_exit();
-}
-
-
-/*
- * ------------------------------------------------------------
- * rs_throttle()
- * 
- * This routine is called by the upper-layer tty layer to signal that
- * incoming characters should be throttled.
- * ------------------------------------------------------------
- */
-static void rs_throttle(struct tty_struct * tty)
-{
-#ifdef TX3912_UART_DEBUG_THROTTLE
-	char	buf[64];
-	
-	printk("throttle %s: %d....\n", tty_name(tty, buf),
-	       tty->ldisc.chars_in_buffer(tty));
-#endif
-
-	func_enter ();
-	
-	if (I_IXOFF(tty))
-		rs_send_xchar(tty, STOP_CHAR(tty));
-
-	func_exit ();
-}
-
-static void rs_unthrottle(struct tty_struct * tty)
-{
-	struct rs_port *port = (struct rs_port *)tty->driver_data;
-#ifdef TX3912_UART_DEBUG_THROTTLE
-	char	buf[64];
-	
-	printk("unthrottle %s: %d....\n", tty_name(tty, buf),
-	       tty->ldisc.chars_in_buffer(tty));
-#endif
-
-	func_enter();
-	
-	if (I_IXOFF(tty)) {
-		if (port->x_char)
-			port->x_char = 0;
-		else
-			rs_send_xchar(tty, START_CHAR(tty));
-	}
-
-	func_exit();
-}
-
-
-
-
-
-/* ********************************************************************** *
- *                    Here are the initialization routines.               *
- * ********************************************************************** */
-
-void * ckmalloc (int size)
-{
-        void *p;
-
-        p = kmalloc(size, GFP_KERNEL);
-        if (p) 
-                memset(p, 0, size);
-        return p;
-}
-
-
-
-static int rs_init_portstructs(void)
-{
-	struct rs_port *port;
-	int i;
-
-	/* Debugging */
-	func_enter();
-
-	rs_ports          = ckmalloc(TX3912_UART_NPORTS * sizeof (struct rs_port));
-	if (!rs_ports)
-		return -ENOMEM;
-
-	port = rs_ports;
-	for (i=0; i < TX3912_UART_NPORTS;i++) {
-		rs_dprintk (TX3912_UART_DEBUG_INIT, "initing port %d\n", i);
-		port->gs.magic = SERIAL_MAGIC;
-		port->gs.close_delay = HZ/2;
-		port->gs.closing_wait = 30 * HZ;
-		port->gs.rd = &rs_real_driver;
-#ifdef NEW_WRITE_LOCKING
-		port->gs.port_write_sem = MUTEX;
-#endif
-#ifdef DECLARE_WAITQUEUE
-		init_waitqueue_head(&port->gs.open_wait);
-		init_waitqueue_head(&port->gs.close_wait);
-#endif
-		port->base = (i == 0) ? TX3912_UARTA_BASE : TX3912_UARTB_BASE;
-		port->intshift = (i == 0) ? UARTA_SHIFT : UARTB_SHIFT;
-		rs_dprintk (TX3912_UART_DEBUG_INIT, "base 0x%08lx intshift %d\n",
-			    port->base, port->intshift);
-		port++;
-	}
-
-	func_exit();
-	return 0;
-}
-
-static struct tty_operations rs_ops = {
-	.open	= rs_open,
-	.close = gs_close,
-	.write = gs_write,
-	.put_char = gs_put_char, 
-	.flush_chars = gs_flush_chars,
-	.write_room = gs_write_room,
-	.chars_in_buffer = gs_chars_in_buffer,
-	.flush_buffer = gs_flush_buffer,
-	.ioctl = rs_ioctl,
-	.throttle = rs_throttle,
-	.unthrottle = rs_unthrottle,
-	.set_termios = gs_set_termios,
-	.stop = gs_stop,
-	.start = gs_start,
-	.hangup = gs_hangup,
-};
-
-static int rs_init_drivers(void)
-{
-	int error;
-
-	func_enter();
-
-	rs_driver = alloc_tty_driver(TX3912_UART_NPORTS);
-	if (!rs_driver)
-		return -ENOMEM;
-	rs_driver->owner = THIS_MODULE;
-	rs_driver->driver_name = "serial";
-	rs_driver->name = "ttyS";
-	rs_driver->major = TTY_MAJOR;
-	rs_driver->minor_start = 64;
-	rs_driver->type = TTY_DRIVER_TYPE_SERIAL;
-	rs_driver->subtype = SERIAL_TYPE_NORMAL;
-	rs_driver->init_termios = tty_std_termios;
-	rs_driver->init_termios.c_cflag =
-		B115200 | CS8 | CREAD | HUPCL | CLOCAL;
-	tty_set_operations(rs_driver, &rs_ops);
-	if ((error = tty_register_driver(rs_driver))) {
-		printk(KERN_ERR "Couldn't register serial driver, error = %d\n",
-		       error);
-		put_tty_driver(rs_driver);
-		return 1;
-	}
-	return 0;
-}
-
-
-static void __init tx3912_rs_init(void)
-{
-	int rc;
-
-
-	func_enter();
-	rs_dprintk (TX3912_UART_DEBUG_INIT, "Initing serial module... (rs_debug=%d)\n", rs_debug);
-
-	rc = rs_init_portstructs ();
-	rs_init_drivers ();
-	if (request_irq(2, rs_tx_interrupt_uarta, SA_SHIRQ | SA_INTERRUPT,
-			"serial", &rs_ports[0])) {
-		printk(KERN_ERR "rs: Cannot allocate irq for UARTA.\n");
-		rc = 0;
-	}
-	if (request_irq(3, rs_rx_interrupt_uarta, SA_SHIRQ | SA_INTERRUPT,
-			"serial", &rs_ports[0])) {
-		printk(KERN_ERR "rs: Cannot allocate irq for UARTA.\n");
-		rc = 0;
-	}
-
-	IntEnable6 |= INT6_UARTARXINT; 
-	rs_enable_rx_interrupts(&rs_ports[0]); 
-
-#ifndef CONFIG_SERIAL_TX3912_CONSOLE
-{
-	unsigned int scratch = 0;
-
-	/* Setup master clock for UART */
-	scratch = inl(TX3912_CLK_CTRL_BASE);
-	scratch &= ~TX3912_CLK_CTRL_SIBMCLKDIV_MASK;
-	scratch |= ((0x2 << TX3912_CLK_CTRL_SIBMCLKDIV_SHIFT) &
-				TX3912_CLK_CTRL_SIBMCLKDIV_MASK)
-			| TX3912_CLK_CTRL_SIBMCLKDIR
-			| TX3912_CLK_CTRL_ENSIBMCLK
-			| TX3912_CLK_CTRL_CSERSEL;
-	outl(scratch, TX3912_CLK_CTRL_BASE);
-
-	/* Configure UARTA clock */
-	scratch = inl(TX3912_CLK_CTRL_BASE);
-	scratch |= ((0x3 << TX3912_CLK_CTRL_CSERDIV_SHIFT) &
-				TX3912_CLK_CTRL_CSERDIV_MASK)
-			| TX3912_CLK_CTRL_ENCSERCLK
-			| TX3912_CLK_CTRL_ENUARTACLK;
-	outl(scratch, TX3912_CLK_CTRL_BASE);
-		
-	/* Setup UARTA for 115200,8N1 */
-	outl(0, TX3912_UARTA_BASE + TX3912_UART_CTRL1);
-	outl(TX3912_UART_CTRL2_B115200, TX3912_UARTA_BASE + TX3912_UART_CTRL2);
-	outl(0, TX3912_UARTA_BASE + TX3912_UART_DMA_CTRL1);
-	outl(0, TX3912_UARTA_BASE + TX3912_UART_DMA_CTRL2);
-
-	/* Enable UARTA */
-	outl(TX3912_UART_CTRL1_ENUART, TX3912_UARTA_BASE + TX3912_UART_CTRL1);
-	while (~inl(TX3912_UARTA_BASE + TX3912_UART_CTRL1) &
-		TX3912_UART_CTRL1_UARTON);
-}
-#endif
-
-	/* Note: I didn't do anything to enable the second UART */
-	if (rc >= 0) 
-		rs_initialized++;
-
-	func_exit();
-}
-module_init(tx3912_rs_init);
-
-/*
- * Begin serial console routines
- */
-#ifdef CONFIG_SERIAL_TX3912_CONSOLE
-
-void serial_outc(unsigned char c)
-{
-	int i;
-	unsigned long int2;
-	#define BUSY_WAIT 10000
-
-	/*
-	 * Turn UARTA interrupts off
-	 */
-	int2 = IntEnable2;
-	IntEnable2 &=
-		~(INT2_UARTATXINT | INT2_UARTATXOVERRUN | INT2_UARTAEMPTY);
-
-	/*
-	 * The UART_TX_EMPTY bit in UartA_Ctrl1 seems
-	 * not to be very reliable :-(
-	 *
-	 * Wait for the Tx register to become empty
-	 */
-	for (i = 0; !(IntStatus2 & INT2_UARTATXINT) && (i < BUSY_WAIT); i++);
-
-	IntClear2 = INT2_UARTATXINT | INT2_UARTATXOVERRUN | INT2_UARTAEMPTY;
-	UartA_Data = c;
-	for (i = 0; !(IntStatus2 & INT2_UARTATXINT) && (i < BUSY_WAIT); i++);
-	IntClear2 = INT2_UARTATXINT | INT2_UARTATXOVERRUN | INT2_UARTAEMPTY;
-
-	IntEnable2 = int2;
-}
-
-static void serial_console_write(struct console *co, const char *s,
-		unsigned count)
-{
-    	unsigned int i;
-
-	for (i = 0; i < count; i++) {
-		if (*s == '\n')
-			serial_outc('\r');
-		serial_outc(*s++);
-    	}
-}
-
-static struct tty_driver *serial_console_device(struct console *c, int *index)
-{
-	*index = c->index;
-	return rs_driver;
-}
-
-static __init int serial_console_setup(struct console *co, char *options)
-{
-	unsigned int scratch = 0;
-
-	/* Setup master clock for UART */
-	scratch = inl(TX3912_CLK_CTRL_BASE);
-	scratch &= ~TX3912_CLK_CTRL_SIBMCLKDIV_MASK;
-	scratch |= ((0x2 << TX3912_CLK_CTRL_SIBMCLKDIV_SHIFT) &
-				TX3912_CLK_CTRL_SIBMCLKDIV_MASK)
-			| TX3912_CLK_CTRL_SIBMCLKDIR
-			| TX3912_CLK_CTRL_ENSIBMCLK
-			| TX3912_CLK_CTRL_CSERSEL;
-	outl(scratch, TX3912_CLK_CTRL_BASE);
-
-	/* Configure UARTA clock */
-	scratch = inl(TX3912_CLK_CTRL_BASE);
-	scratch |= ((0x3 << TX3912_CLK_CTRL_CSERDIV_SHIFT) &
-				TX3912_CLK_CTRL_CSERDIV_MASK)
-			| TX3912_CLK_CTRL_ENCSERCLK
-			| TX3912_CLK_CTRL_ENUARTACLK;
-	outl(scratch, TX3912_CLK_CTRL_BASE);
-		
-	/* Setup UARTA for 115200,8N1 */
-	outl(0, TX3912_UARTA_BASE + TX3912_UART_CTRL1);
-	outl(TX3912_UART_CTRL2_B115200, TX3912_UARTA_BASE + TX3912_UART_CTRL2);
-	outl(0, TX3912_UARTA_BASE + TX3912_UART_DMA_CTRL1);
-	outl(0, TX3912_UARTA_BASE + TX3912_UART_DMA_CTRL2);
-
-	/* Enable UARTA */
-	outl(TX3912_UART_CTRL1_ENUART, TX3912_UARTA_BASE + TX3912_UART_CTRL1);
-	while (~inl(TX3912_UARTA_BASE + TX3912_UART_CTRL1) &
-		TX3912_UART_CTRL1_UARTON);
-
-	return 0;
-}
-
-static struct console sercons = {
-	.name     = "ttyS",
-	.write    = serial_console_write,
-	.device   = serial_console_device,
-	.setup    = serial_console_setup,
-	.flags    = CON_PRINTBUFFER,
-	.index    = -1
-};
-
-static int __init tx3912_console_init(void)
-{
-	register_console(&sercons);
-	return 0;
-}
-console_initcall(tx3912_console_init);
-
-#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/char/serial_tx3912.h linux-2.6.11-rc3/drivers/char/serial_tx3912.h
--- linux-2.6.11-rc2-bk10/drivers/char/serial_tx3912.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/serial_tx3912.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-/*
- *  drivers/char/serial_tx3912.h
- *
- *  Copyright (C) 1999 Harald Koerfgen
- *  Copyright (C) 2000 Jim Pick <jim@jimpick.com>
- *  Copyright (C) 2001 Steven J. Hill (sjhill@realitydiluted.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- *  Serial driver for TMPR3912/05 and PR31700 processors
- */
-#include <linux/serialP.h>
-#include <linux/generic_serial.h>
-
-/* UART Interrupt (Interrupt 2) bits (UARTA,UARTB) */
-#define UART_RX_INT         9  /* receiver holding register full  (31, 21) */
-#define UART_RXOVERRUN_INT  8  /* receiver overrun error          (30, 20) */
-#define UART_FRAMEERR_INT   7  /* receiver frame error            (29, 19) */
-#define UART_BREAK_INT      6  /* received break signal           (28, 18) */
-#define UART_PARITYERR_INT  5  /* receiver parity error           (27, 17) */
-#define UART_TX_INT         4  /* transmit holding register empty (26, 16) */
-#define UART_TXOVERRUN_INT  3  /* transmit overrun error          (25, 15) */
-#define UART_EMPTY_INT      2  /* both trans/recv regs empty      (24, 14) */
-#define UART_DMAFULL_INT    1  /* DMA at end of buffer            (23, 13) */
-#define UART_DMAHALF_INT    0  /* DMA halfway through buffer      (22, 12) */
-
-#define UARTA_SHIFT        22
-#define UARTB_SHIFT        12
-
-#define INTTYPE(interrupttype)            (1 << interrupttype)
-
-/* 
- * This driver can spew a whole lot of debugging output at you. If you
- * need maximum performance, you should disable the DEBUG define.
- */
-#undef TX3912_UART_DEBUG
-
-#ifdef TX3912_UART_DEBUG
-#define TX3912_UART_DEBUG_OPEN		0x00000001
-#define TX3912_UART_DEBUG_SETTING	0x00000002
-#define TX3912_UART_DEBUG_FLOW		0x00000004
-#define TX3912_UART_DEBUG_MODEMSIGNALS	0x00000008
-#define TX3912_UART_DEBUG_TERMIOS	0x00000010
-#define TX3912_UART_DEBUG_TRANSMIT	0x00000020
-#define TX3912_UART_DEBUG_RECEIVE	0x00000040
-#define TX3912_UART_DEBUG_INTERRUPTS	0x00000080
-#define TX3912_UART_DEBUG_PROBE		0x00000100
-#define TX3912_UART_DEBUG_INIT		0x00000200
-#define TX3912_UART_DEBUG_CLEANUP	0x00000400
-#define TX3912_UART_DEBUG_CLOSE		0x00000800
-#define TX3912_UART_DEBUG_FIRMWARE	0x00001000
-#define TX3912_UART_DEBUG_MEMTEST	0x00002000
-#define TX3912_UART_DEBUG_THROTTLE	0x00004000
-#define TX3912_UART_DEBUG_ALL		0xffffffff
-
-int rs_debug = TX3912_UART_DEBUG_ALL & ~TX3912_UART_DEBUG_TRANSMIT;
-
-#define rs_dprintk(f, str...) if (rs_debug & f) printk (str)
-#define func_enter() rs_dprintk (TX3912_UART_DEBUG_FLOW,	\
-				"rs: enter %s\n", __FUNCTION__)
-#define func_exit() rs_dprintk (TX3912_UART_DEBUG_FLOW,	\
-				"rs: exit %s\n", __FUNCTION__)
-
-#else
-#define rs_dprintk(f, str...)
-#define func_enter()
-#define func_exit()
-
-#endif	/* TX3912_UART_DEBUG */
-
-/*
- * Number of serial ports
- */
-#define TX3912_UART_NPORTS  2
-
-/*
- * Hardware specific serial port structure
- */
-struct rs_port { 	
-	struct gs_port		gs;		/* Must be first field! */
-
-	unsigned long		base;
-	int			intshift;	/* Register shift */
-	struct wait_queue	*shutdown_wait; 
-	int			stat_flags;
-        struct async_icount	icount;		/* Counters for 4 input IRQs */
-	int			read_status_mask;
-	int			ignore_status_mask;
-	int			x_char;		/* XON/XOFF character */
-}; 
diff -purN linux-2.6.11-rc2-bk10/drivers/char/tty_io.c linux-2.6.11-rc3/drivers/char/tty_io.c
--- linux-2.6.11-rc2-bk10/drivers/char/tty_io.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/drivers/char/tty_io.c	2005-02-03 02:56:10.000000000 +0100
@@ -1156,8 +1156,8 @@ static inline void pty_line_name(struct 
 	int i = index + driver->name_base;
 	/* ->name is initialized to "ttyp", but "tty" is expected */
 	sprintf(p, "%s%c%x",
-			driver->subtype == PTY_TYPE_SLAVE ? "tty" : driver->name,
-			ptychar[i >> 4 & 0xf], i & 0xf);
+		driver->subtype == PTY_TYPE_SLAVE ? "pty" : driver->name,
+		ptychar[i >> 4 & 0xf], i & 0xf);
 }
 
 static inline void tty_line_name(struct tty_driver *driver, int index, char *p)
diff -purN linux-2.6.11-rc2-bk10/drivers/i2c/algos/i2c-algo-sibyte.c linux-2.6.11-rc3/drivers/i2c/algos/i2c-algo-sibyte.c
--- linux-2.6.11-rc2-bk10/drivers/i2c/algos/i2c-algo-sibyte.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/i2c/algos/i2c-algo-sibyte.c	2005-02-03 02:54:59.000000000 +0100
@@ -181,9 +181,6 @@ int i2c_sibyte_add_bus(struct i2c_adapte
 		printk("\n");
 	}
 
-#ifdef MODULE
-	MOD_INC_USE_COUNT;
-#endif
 	i2c_add_adapter(i2c_adap);
 
 	return 0;
@@ -197,9 +194,6 @@ int i2c_sibyte_del_bus(struct i2c_adapte
 	if ((res = i2c_del_adapter(adap)) < 0)
 		return res;
 
-#ifdef MODULE
-	MOD_DEC_USE_COUNT;
-#endif
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/i2c/busses/Kconfig linux-2.6.11-rc3/drivers/i2c/busses/Kconfig
--- linux-2.6.11-rc2-bk10/drivers/i2c/busses/Kconfig	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/i2c/busses/Kconfig	2005-02-03 02:56:35.000000000 +0100
@@ -74,6 +74,16 @@ config I2C_AMD8111
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-amd8111.
 
+config I2C_AU1550
+	tristate "Au1550 SMBus interface"
+	depends on I2C && SOC_AU1550
+	help
+	  If you say yes to this option, support will be included for the
+	  Au1550 SMBus interface.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-au1550.
+
 config I2C_ELEKTOR
 	tristate "Elektor ISA card"
 	depends on I2C && ISA && BROKEN_ON_SMP
diff -purN linux-2.6.11-rc2-bk10/drivers/i2c/busses/Makefile linux-2.6.11-rc3/drivers/i2c/busses/Makefile
--- linux-2.6.11-rc2-bk10/drivers/i2c/busses/Makefile	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/drivers/i2c/busses/Makefile	2005-02-03 02:57:05.000000000 +0100
@@ -8,6 +8,7 @@ obj-$(CONFIG_I2C_ALI15X3)	+= i2c-ali15x3
 obj-$(CONFIG_I2C_AMD756)	+= i2c-amd756.o
 obj-$(CONFIG_I2C_AMD756_S4882)	+= i2c-amd756-s4882.o
 obj-$(CONFIG_I2C_AMD8111)	+= i2c-amd8111.o
+obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
 obj-$(CONFIG_I2C_ELEKTOR)	+= i2c-elektor.o
 obj-$(CONFIG_I2C_HYDRA)		+= i2c-hydra.o
 obj-$(CONFIG_I2C_I801)		+= i2c-i801.o
diff -purN linux-2.6.11-rc2-bk10/drivers/i2c/busses/i2c-au1550.c linux-2.6.11-rc3/drivers/i2c/busses/i2c-au1550.c
--- linux-2.6.11-rc2-bk10/drivers/i2c/busses/i2c-au1550.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/i2c/busses/i2c-au1550.c	2005-02-03 02:56:53.000000000 +0100
@@ -0,0 +1,435 @@
+/*
+ * i2c-au1550.c: SMBus (i2c) adapter for Alchemy PSC interface
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ * 2.6 port by Matt Porter <mporter@kernel.crashing.org>
+ *
+ * The documentation describes this as an SMBus controller, but it doesn't
+ * understand any of the SMBus protocol in hardware.  It's really an I2C
+ * controller that could emulate most of the SMBus in software.
+ *
+ * This is just a skeleton adapter to use with the Au1550 PSC
+ * algorithm.  It was developed for the Pb1550, but will work with
+ * any Au1550 board that has a similar PSC configuration.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-pb1x00/pb1550.h>
+#include <asm/mach-au1x00/au1xxx_psc.h>
+
+#include "i2c-au1550.h"
+
+static int
+wait_xfer_done(struct i2c_au1550_data *adap)
+{
+	u32	stat;
+	int	i;
+	volatile psc_smb_t	*sp;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Wait for Tx FIFO Underflow.
+	*/
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		stat = sp->psc_smbevnt;
+		au_sync();
+		if ((stat & PSC_SMBEVNT_TU) != 0) {
+			/* Clear it.  */
+			sp->psc_smbevnt = PSC_SMBEVNT_TU;
+			au_sync();
+			return 0;
+		}
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int
+wait_ack(struct i2c_au1550_data *adap)
+{
+	u32	stat;
+	volatile psc_smb_t	*sp;
+
+	if (wait_xfer_done(adap))
+		return -ETIMEDOUT;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	stat = sp->psc_smbevnt;
+	au_sync();
+
+	if ((stat & (PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | PSC_SMBEVNT_AL)) != 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int
+wait_master_done(struct i2c_au1550_data *adap)
+{
+	u32	stat;
+	int	i;
+	volatile psc_smb_t	*sp;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Wait for Master Done.
+	*/
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		stat = sp->psc_smbevnt;
+		au_sync();
+		if ((stat & PSC_SMBEVNT_MD) != 0)
+			return 0;
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int
+do_address(struct i2c_au1550_data *adap, unsigned int addr, int rd)
+{
+	volatile psc_smb_t	*sp;
+	u32			stat;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Reset the FIFOs, clear events.
+	*/
+	sp->psc_smbpcr = PSC_SMBPCR_DC;
+	sp->psc_smbevnt = PSC_SMBEVNT_ALLCLR;
+	au_sync();
+	do {
+		stat = sp->psc_smbpcr;
+		au_sync();
+	} while ((stat & PSC_SMBPCR_DC) != 0);
+
+	/* Write out the i2c chip address and specify operation
+	*/
+	addr <<= 1;
+	if (rd)
+		addr |= 1;
+
+	/* Put byte into fifo, start up master.
+	*/
+	sp->psc_smbtxrx = addr;
+	au_sync();
+	sp->psc_smbpcr = PSC_SMBPCR_MS;
+	au_sync();
+	if (wait_ack(adap))
+		return -EIO;
+	return 0;
+}
+
+static u32
+wait_for_rx_byte(struct i2c_au1550_data *adap, u32 *ret_data)
+{
+	int	j;
+	u32	data, stat;
+	volatile psc_smb_t	*sp;
+
+	if (wait_xfer_done(adap))
+		return -EIO;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	j =  adap->xfer_timeout * 100;
+	do {
+		j--;
+		if (j <= 0)
+			return -EIO;
+
+		stat = sp->psc_smbstat;
+		au_sync();
+		if ((stat & PSC_SMBSTAT_RE) == 0)
+			j = 0;
+		else
+			udelay(1);
+	} while (j > 0);
+	data = sp->psc_smbtxrx;
+	au_sync();
+	*ret_data = data;
+
+	return 0;
+}
+
+static int
+i2c_read(struct i2c_au1550_data *adap, unsigned char *buf,
+		    unsigned int len)
+{
+	int	i;
+	u32	data;
+	volatile psc_smb_t	*sp;
+
+	if (len == 0)
+		return 0;
+
+	/* A read is performed by stuffing the transmit fifo with
+	 * zero bytes for timing, waiting for bytes to appear in the
+	 * receive fifo, then reading the bytes.
+	 */
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	i = 0;
+	while (i < (len-1)) {
+		sp->psc_smbtxrx = 0;
+		au_sync();
+		if (wait_for_rx_byte(adap, &data))
+			return -EIO;
+
+		buf[i] = data;
+		i++;
+	}
+
+	/* The last byte has to indicate transfer done.
+	*/
+	sp->psc_smbtxrx = PSC_SMBTXRX_STP;
+	au_sync();
+	if (wait_master_done(adap))
+		return -EIO;
+
+	data = sp->psc_smbtxrx;
+	au_sync();
+	buf[i] = data;
+	return 0;
+}
+
+static int
+i2c_write(struct i2c_au1550_data *adap, unsigned char *buf,
+		     unsigned int len)
+{
+	int	i;
+	u32	data;
+	volatile psc_smb_t	*sp;
+
+	if (len == 0)
+		return 0;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	i = 0;
+	while (i < (len-1)) {
+		data = buf[i];
+		sp->psc_smbtxrx = data;
+		au_sync();
+		if (wait_ack(adap))
+			return -EIO;
+		i++;
+	}
+
+	/* The last byte has to indicate transfer done.
+	*/
+	data = buf[i];
+	data |= PSC_SMBTXRX_STP;
+	sp->psc_smbtxrx = data;
+	au_sync();
+	if (wait_master_done(adap))
+		return -EIO;
+	return 0;
+}
+
+static int
+au1550_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_au1550_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *p;
+	int i, err = 0;
+
+	for (i = 0; !err && i < num; i++) {
+		p = &msgs[i];
+		err = do_address(adap, p->addr, p->flags & I2C_M_RD);
+		if (err || !p->len)
+			continue;
+		if (p->flags & I2C_M_RD)
+			err = i2c_read(adap, p->buf, p->len);
+		else
+			err = i2c_write(adap, p->buf, p->len);
+	}
+
+	/* Return the number of messages processed, or the error code.
+	*/
+	if (err == 0)
+		err = num;
+	return err;
+}
+
+static u32
+au1550_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm au1550_algo = {
+	.name		= "Au1550 algorithm",
+	.id		= I2C_ALGO_AU1550,
+	.master_xfer	= au1550_xfer,
+	.functionality	= au1550_func,
+};
+
+/*
+ * registering functions to load algorithms at runtime
+ * Prior to calling us, the 50MHz clock frequency and routing
+ * must have been set up for the PSC indicated by the adapter.
+ */
+int
+i2c_au1550_add_bus(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_au1550_data *adap = i2c_adap->algo_data;
+	volatile psc_smb_t	*sp;
+	u32	stat;
+
+	i2c_adap->algo = &au1550_algo;
+
+	/* Now, set up the PSC for SMBus PIO mode.
+	*/
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+	sp->psc_ctrl = PSC_CTRL_DISABLE;
+	au_sync();
+	sp->psc_sel = PSC_SEL_PS_SMBUSMODE;
+	sp->psc_smbcfg = 0;
+	au_sync();
+	sp->psc_ctrl = PSC_CTRL_ENABLE;
+	au_sync();
+	do {
+		stat = sp->psc_smbstat;
+		au_sync();
+	} while ((stat & PSC_SMBSTAT_SR) == 0);
+
+	sp->psc_smbcfg = (PSC_SMBCFG_RT_FIFO8 | PSC_SMBCFG_TT_FIFO8 |
+				PSC_SMBCFG_DD_DISABLE);
+
+	/* Divide by 8 to get a 6.25 MHz clock.  The later protocol
+	 * timings are based on this clock.
+	 */
+	sp->psc_smbcfg |= PSC_SMBCFG_SET_DIV(PSC_SMBCFG_DIV8);
+	sp->psc_smbmsk = PSC_SMBMSK_ALLMASK;
+	au_sync();
+
+	/* Set the protocol timer values.  See Table 71 in the
+	 * Au1550 Data Book for standard timing values.
+	 */
+	sp->psc_smbtmr = PSC_SMBTMR_SET_TH(0) | PSC_SMBTMR_SET_PS(15) | \
+		PSC_SMBTMR_SET_PU(15) | PSC_SMBTMR_SET_SH(15) | \
+		PSC_SMBTMR_SET_SU(15) | PSC_SMBTMR_SET_CL(15) | \
+		PSC_SMBTMR_SET_CH(15);
+	au_sync();
+
+	sp->psc_smbcfg |= PSC_SMBCFG_DE_ENABLE;
+	do {
+		stat = sp->psc_smbstat;
+		au_sync();
+	} while ((stat & PSC_SMBSTAT_DR) == 0);
+
+	return i2c_add_adapter(i2c_adap);
+}
+
+
+int
+i2c_au1550_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+static int
+pb1550_reg(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int
+pb1550_unreg(struct i2c_client *client)
+{
+	return 0;
+}
+
+static struct i2c_au1550_data pb1550_i2c_info = {
+	SMBUS_PSC_BASE, 200, 200
+};
+
+static struct i2c_adapter pb1550_board_adapter = {
+	name:              "pb1550 adapter",
+	id:                I2C_HW_AU1550_PSC,
+	algo:              NULL,
+	algo_data:         &pb1550_i2c_info,
+	client_register:   pb1550_reg,
+	client_unregister: pb1550_unreg,
+};
+
+/* BIG hack to support the control interface on the Wolfson WM8731
+ * audio codec on the Pb1550 board.  We get an address and two data
+ * bytes to write, create an i2c message, and send it across the
+ * i2c transfer function.  We do this here because we have access to
+ * the i2c adapter structure.
+ */
+static struct i2c_msg wm_i2c_msg;  /* We don't want this stuff on the stack */
+static	u8 i2cbuf[2];
+
+int
+pb1550_wm_codec_write(u8 addr, u8 reg, u8 val)
+{
+	wm_i2c_msg.addr = addr;
+	wm_i2c_msg.flags = 0;
+	wm_i2c_msg.buf = i2cbuf;
+	wm_i2c_msg.len = 2;
+	i2cbuf[0] = reg;
+	i2cbuf[1] = val;
+
+	return pb1550_board_adapter.algo->master_xfer(&pb1550_board_adapter, &wm_i2c_msg, 1);
+}
+
+static int __init
+i2c_au1550_init(void)
+{
+	printk(KERN_INFO "Au1550 I2C: ");
+
+	/* This is where we would set up a 50MHz clock source
+	 * and routing.  On the Pb1550, the SMBus is PSC2, which
+	 * uses a shared clock with USB.  This has been already
+	 * configured by Yamon as a 48MHz clock, close enough
+	 * for our work.
+	 */
+        if (i2c_au1550_add_bus(&pb1550_board_adapter) < 0) {
+		printk("failed to initialize.\n");
+                return -ENODEV;
+	}
+
+	printk("initialized.\n");
+	return 0;
+}
+
+static void __exit
+i2c_au1550_exit(void)
+{
+	i2c_au1550_del_bus(&pb1550_board_adapter);
+}
+
+MODULE_AUTHOR("Dan Malek, Embedded Edge, LLC.");
+MODULE_DESCRIPTION("SMBus adapter Alchemy pb1550");
+MODULE_LICENSE("GPL");
+
+module_init (i2c_au1550_init);
+module_exit (i2c_au1550_exit);
diff -purN linux-2.6.11-rc2-bk10/drivers/i2c/busses/i2c-au1550.h linux-2.6.11-rc3/drivers/i2c/busses/i2c-au1550.h
--- linux-2.6.11-rc2-bk10/drivers/i2c/busses/i2c-au1550.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/i2c/busses/i2c-au1550.h	2005-02-03 02:55:40.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ * 2.6 port by Matt Porter <mporter@kernel.crashing.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef I2C_AU1550_H
+#define I2C_AU1550_H
+
+struct i2c_au1550_data {
+	u32	psc_base;
+	int	xfer_timeout;
+	int	ack_timeout;
+};
+
+int i2c_au1550_add_bus(struct i2c_adapter *);
+int i2c_au1550_del_bus(struct i2c_adapter *);
+
+#endif /* I2C_AU1550_H */
diff -purN linux-2.6.11-rc2-bk10/drivers/ide/pci/via82cxxx.c linux-2.6.11-rc3/drivers/ide/pci/via82cxxx.c
--- linux-2.6.11-rc2-bk10/drivers/ide/pci/via82cxxx.c	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/drivers/ide/pci/via82cxxx.c	2005-02-03 02:57:04.000000000 +0100
@@ -36,6 +36,10 @@
 #include <linux/ide.h>
 #include <asm/io.h>
 
+#ifdef CONFIG_PPC_MULTIPLATFORM
+#include <asm/processor.h>
+#endif
+
 #include "ide-timing.h"
 
 #define DISPLAY_VIA_TIMINGS
@@ -584,6 +588,13 @@ static void __init init_hwif_via82cxxx(i
 	hwif->tuneproc = &via82cxxx_tune_drive;
 	hwif->speedproc = &via_set_drive;
 
+
+#ifdef CONFIG_PPC_MULTIPLATFORM
+	if(_machine == _MACH_chrp && _chrp_type == _CHRP_Pegasos) {
+		hwif->irq = hwif->channel ? 15 : 14;
+	}
+#endif
+
 	for (i = 0; i < 2; i++) {
 		hwif->drives[i].io_32bit = 1;
 		hwif->drives[i].unmask = (via_config->flags & VIA_NO_UNMASK) ? 0 : 1;
diff -purN linux-2.6.11-rc2-bk10/drivers/infiniband/core/user_mad.c linux-2.6.11-rc3/drivers/infiniband/core/user_mad.c
--- linux-2.6.11-rc2-bk10/drivers/infiniband/core/user_mad.c	2005-02-03 10:03:09.181472144 +0100
+++ linux-2.6.11-rc3/drivers/infiniband/core/user_mad.c	2005-02-03 02:55:23.000000000 +0100
@@ -56,7 +56,10 @@ MODULE_LICENSE("Dual BSD/GPL");
 
 enum {
 	IB_UMAD_MAX_PORTS  = 64,
-	IB_UMAD_MAX_AGENTS = 32
+	IB_UMAD_MAX_AGENTS = 32,
+
+	IB_UMAD_MAJOR      = 231,
+	IB_UMAD_MINOR_BASE = 0
 };
 
 struct ib_umad_port {
@@ -97,7 +100,7 @@ struct ib_umad_packet {
 	DECLARE_PCI_UNMAP_ADDR(mapping)
 };
 
-static dev_t base_dev;
+static const dev_t base_dev = MKDEV(IB_UMAD_MAJOR, IB_UMAD_MINOR_BASE);
 static spinlock_t map_lock;
 static DECLARE_BITMAP(dev_map, IB_UMAD_MAX_PORTS * 2);
 
@@ -789,10 +792,10 @@ static int __init ib_umad_init(void)
 
 	spin_lock_init(&map_lock);
 
-	ret = alloc_chrdev_region(&base_dev, 0, IB_UMAD_MAX_PORTS * 2,
-				  "infiniband_mad");
+	ret = register_chrdev_region(base_dev, IB_UMAD_MAX_PORTS * 2,
+				     "infiniband_mad");
 	if (ret) {
-		printk(KERN_ERR "user_mad: couldn't get device number\n");
+		printk(KERN_ERR "user_mad: couldn't register device number\n");
 		goto out;
 	}
 
diff -purN linux-2.6.11-rc2-bk10/drivers/input/gameport/cs461x.c linux-2.6.11-rc3/drivers/input/gameport/cs461x.c
--- linux-2.6.11-rc2-bk10/drivers/input/gameport/cs461x.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/drivers/input/gameport/cs461x.c	2005-02-03 02:54:59.000000000 +0100
@@ -118,7 +118,7 @@ MODULE_LICENSE("GPL");
 */
 
 static unsigned long ba0_addr;
-static unsigned int *ba0;
+static unsigned int __iomem *ba0;
 
 static char phys[32];
 static char name[] = "CS416x Gameport";
@@ -127,34 +127,34 @@ static char name[] = "CS416x Gameport";
 static unsigned long ba1_addr;
 static union ba1_t {
         struct {
-                unsigned int *data0;
-                unsigned int *data1;
-                unsigned int *pmem;
-                unsigned int *reg;
+                unsigned int __iomem *data0;
+                unsigned int __iomem *data1;
+                unsigned int __iomem *pmem;
+                unsigned int __iomem *reg;
         } name;
-        unsigned int *idx[4];
+        unsigned int __iomem *idx[4];
 } ba1;
 
 static void cs461x_poke(unsigned long reg, unsigned int val)
 {
-        ba1.idx[(reg >> 16) & 3][(reg >> 2) & 0x3fff] = val;
+        writel(val, &ba1.idx[(reg >> 16) & 3][(reg >> 2) & 0x3fff]);
 }
 
 static unsigned int cs461x_peek(unsigned long reg)
 {
-        return ba1.idx[(reg >> 16) & 3][(reg >> 2) & 0x3fff];
+        return readl(&ba1.idx[(reg >> 16) & 3][(reg >> 2) & 0x3fff]);
 }
 
 #endif
 
 static void cs461x_pokeBA0(unsigned long reg, unsigned int val)
 {
-        ba0[reg >> 2] = val;
+        writel(val, &ba0[reg >> 2]);
 }
 
 static unsigned int cs461x_peekBA0(unsigned long reg)
 {
-        return ba0[reg >> 2];
+        return readl(&ba0[reg >> 2]);
 }
 
 static int cs461x_free(struct pci_dev *pdev)
diff -purN linux-2.6.11-rc2-bk10/drivers/input/joystick/sidewinder.c linux-2.6.11-rc3/drivers/input/joystick/sidewinder.c
--- linux-2.6.11-rc2-bk10/drivers/input/joystick/sidewinder.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/input/joystick/sidewinder.c	2005-02-03 02:56:47.000000000 +0100
@@ -45,7 +45,7 @@ MODULE_LICENSE("GPL");
  * as well as break everything.
  */
 
-#define SW_DEBUG
+/* #define SW_DEBUG */
 
 #define SW_START	400	/* The time we wait for the first bit [400 us] */
 #define SW_STROBE	45	/* Max time per bit [45 us] */
diff -purN linux-2.6.11-rc2-bk10/drivers/input/serio/i8042.c linux-2.6.11-rc3/drivers/input/serio/i8042.c
--- linux-2.6.11-rc2-bk10/drivers/input/serio/i8042.c	2005-02-03 10:03:09.234463899 +0100
+++ linux-2.6.11-rc3/drivers/input/serio/i8042.c	2005-02-03 02:55:07.000000000 +0100
@@ -482,7 +482,7 @@ static int i8042_set_mux_mode(unsigned i
 	if (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != 0x0f)
 		return -1;
 	param = mode ? 0x56 : 0xf6;
-	if (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != 0xa9)
+	if (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != (mode ? 0xa9 : 0x09))
 		return -1;
 	param = mode ? 0xa4 : 0xa5;
 	if (i8042_command(&param, I8042_CMD_AUX_LOOP) || param == (mode ? 0x5b : 0x5a))
@@ -787,7 +787,8 @@ void i8042_controller_reset(void)
  * Disable MUX mode if present.
  */
 
-	i8042_set_mux_mode(0, NULL);
+	if (i8042_mux_present)
+		i8042_set_mux_mode(0, NULL);
 
 /*
  * Restore the original control register setting.
diff -purN linux-2.6.11-rc2-bk10/drivers/input/serio/i8042.h linux-2.6.11-rc3/drivers/input/serio/i8042.h
--- linux-2.6.11-rc2-bk10/drivers/input/serio/i8042.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/input/serio/i8042.h	2005-02-03 02:56:33.000000000 +0100
@@ -15,7 +15,7 @@
  * Arch-dependent inline functions and defines.
  */
 
-#if defined(CONFIG_MIPS_JAZZ)
+#if defined(CONFIG_MACH_JAZZ)
 #include "i8042-jazzio.h"
 #elif defined(CONFIG_SGI_IP22)
 #include "i8042-ip22io.h"
diff -purN linux-2.6.11-rc2-bk10/drivers/input/serio/libps2.c linux-2.6.11-rc3/drivers/input/serio/libps2.c
--- linux-2.6.11-rc2-bk10/drivers/input/serio/libps2.c	2005-02-03 10:03:09.235463743 +0100
+++ linux-2.6.11-rc3/drivers/input/serio/libps2.c	2005-02-03 02:55:15.000000000 +0100
@@ -60,9 +60,9 @@ int ps2_sendbyte(struct ps2dev *ps2dev, 
 	serio_continue_rx(ps2dev->serio);
 
 	if (serio_write(ps2dev->serio, byte) == 0)
-		wait_event_interruptible_timeout(ps2dev->wait,
-					!(ps2dev->flags & PS2_FLAG_ACK),
-					msecs_to_jiffies(timeout));
+		wait_event_timeout(ps2dev->wait,
+				   !(ps2dev->flags & PS2_FLAG_ACK),
+				   msecs_to_jiffies(timeout));
 
 	serio_pause_rx(ps2dev->serio);
 	ps2dev->flags &= ~PS2_FLAG_ACK;
@@ -115,8 +115,8 @@ int ps2_command(struct ps2dev *ps2dev, u
 	 */
 	timeout = msecs_to_jiffies(command == PS2_CMD_RESET_BAT ? 4000 : 500);
 
-	wait_event_interruptible_timeout(ps2dev->wait,
-		!(ps2dev->flags & PS2_FLAG_CMD1), timeout);
+	timeout = wait_event_timeout(ps2dev->wait,
+				     !(ps2dev->flags & PS2_FLAG_CMD1), timeout);
 
 	if (ps2dev->cmdcnt && timeout > 0) {
 
@@ -147,8 +147,8 @@ int ps2_command(struct ps2dev *ps2dev, u
 			serio_continue_rx(ps2dev->serio);
 		}
 
-		wait_event_interruptible_timeout(ps2dev->wait,
-				!(ps2dev->flags & PS2_FLAG_CMD), timeout);
+		wait_event_timeout(ps2dev->wait,
+				   !(ps2dev->flags & PS2_FLAG_CMD), timeout);
 	}
 
 	if (param)
@@ -259,7 +259,7 @@ int ps2_handle_ack(struct ps2dev *ps2dev
 		ps2dev->flags |= PS2_FLAG_CMD | PS2_FLAG_CMD1;
 
 	ps2dev->flags &= ~PS2_FLAG_ACK;
-	wake_up_interruptible(&ps2dev->wait);
+	wake_up(&ps2dev->wait);
 
 	if (data != PS2_RET_ACK)
 		ps2_handle_response(ps2dev, data);
@@ -281,12 +281,12 @@ int ps2_handle_response(struct ps2dev *p
 	if (ps2dev->flags & PS2_FLAG_CMD1) {
 		ps2dev->flags &= ~PS2_FLAG_CMD1;
 		if (ps2dev->cmdcnt)
-			wake_up_interruptible(&ps2dev->wait);
+			wake_up(&ps2dev->wait);
 	}
 
 	if (!ps2dev->cmdcnt) {
 		ps2dev->flags &= ~PS2_FLAG_CMD;
-		wake_up_interruptible(&ps2dev->wait);
+		wake_up(&ps2dev->wait);
 	}
 
 	return 1;
@@ -298,7 +298,7 @@ void ps2_cmd_aborted(struct ps2dev *ps2d
 		ps2dev->nak = 1;
 
 	if (ps2dev->flags & (PS2_FLAG_ACK | PS2_FLAG_CMD))
-		wake_up_interruptible(&ps2dev->wait);
+		wake_up(&ps2dev->wait);
 
 	ps2dev->flags = 0;
 }
diff -purN linux-2.6.11-rc2-bk10/drivers/input/serio/maceps2.c linux-2.6.11-rc3/drivers/input/serio/maceps2.c
--- linux-2.6.11-rc2-bk10/drivers/input/serio/maceps2.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/input/serio/maceps2.c	2005-02-03 02:55:36.000000000 +0100
@@ -62,8 +62,8 @@ static int maceps2_write(struct serio *d
 	unsigned int timeout = MACE_PS2_TIMEOUT;
 
 	do {
-		if (mace_read(port->status) & PS2_STATUS_TX_EMPTY) {
-			mace_write(val, port->tx);
+		if (port->status & PS2_STATUS_TX_EMPTY) {
+			port->tx = val;
 			return 0;
 		}
 		udelay(50);
@@ -72,14 +72,15 @@ static int maceps2_write(struct serio *d
 	return -1;
 }
 
-static irqreturn_t maceps2_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t maceps2_interrupt(int irq, void *dev_id,
+				     struct pt_regs *regs)
 {
 	struct serio *dev = dev_id;
 	struct mace_ps2port *port = ((struct maceps2_data *)dev->port_data)->port;
-	unsigned int byte;
+	unsigned long byte;
 
-	if (mace_read(port->status) & PS2_STATUS_RX_FULL) {
-		byte = mace_read(port->rx);
+	if (port->status & PS2_STATUS_RX_FULL) {
+		byte = port->rx;
 		serio_interrupt(dev, byte & 0xff, 0, regs);
         }
 
@@ -96,13 +97,13 @@ static int maceps2_open(struct serio *de
 	}
 
 	/* Reset port */
-	mace_write(PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET,
-		   data->port->control);
+	data->port->control = PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET;
 	udelay(100);
 
         /* Enable interrupts */
-	mace_write(PS2_CONTROL_RX_CLOCK_ENABLE | PS2_CONTROL_TX_ENABLE |
-		   PS2_CONTROL_RX_INT_ENABLE, data->port->control);
+	data->port->control = PS2_CONTROL_RX_CLOCK_ENABLE |
+			      PS2_CONTROL_TX_ENABLE |
+			      PS2_CONTROL_RX_INT_ENABLE;
 
 	return 0;
 }
@@ -111,8 +112,7 @@ static void maceps2_close(struct serio *
 {
 	struct maceps2_data *data = (struct maceps2_data *)dev->port_data;
 
-	mace_write(PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET,
-		   data->port->control);
+	data->port->control = PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET;
 	udelay(100);
 	free_irq(data->irq, dev);
 }
diff -purN linux-2.6.11-rc2-bk10/drivers/input/serio/serport.c linux-2.6.11-rc3/drivers/input/serio/serport.c
--- linux-2.6.11-rc2-bk10/drivers/input/serio/serport.c	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc3/drivers/input/serio/serport.c	2005-02-03 02:56:48.000000000 +0100
@@ -64,6 +64,9 @@ static int serport_ldisc_open(struct tty
 	struct serio *serio;
 	char name[64];
 
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
 	serport = kmalloc(sizeof(struct serport), GFP_KERNEL);
 	serio = kmalloc(sizeof(struct serio), GFP_KERNEL);
 	if (unlikely(!serport || !serio)) {
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/avm/avmcard.h linux-2.6.11-rc3/drivers/isdn/hardware/avm/avmcard.h
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/avm/avmcard.h	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/avm/avmcard.h	2005-02-03 02:56:48.000000000 +0100
@@ -89,7 +89,7 @@ typedef struct avmcard {
 	char msgbuf[128];	/* capimsg msg part */
 	char databuf[2048];	/* capimsg data part */
 
-	void *mbase;
+	void __iomem *mbase;
 	volatile u32 csr;
 	avmcard_dmainfo *dma;
 
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/divamnt.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/divamnt.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/divamnt.c	2005-01-22 02:48:14.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/divamnt.c	2005-02-03 02:55:52.000000000 +0100
@@ -1,4 +1,4 @@
-/* $Id: divamnt.c,v 1.32.6.5 2004/08/28 20:03:53 armin Exp $
+/* $Id: divamnt.c,v 1.32.6.9 2005/01/31 12:22:20 armin Exp $
  *
  * Driver for Eicon DIVA Server ISDN cards.
  * Maint module
@@ -18,13 +18,14 @@
 #include <linux/smp_lock.h>
 #include <linux/poll.h>
 #include <linux/devfs_fs_kernel.h>
+#include <asm/uaccess.h>
 
 #include "platform.h"
 #include "di_defs.h"
 #include "divasync.h"
 #include "debug_if.h"
 
-static char *main_revision = "$Revision: 1.32.6.5 $";
+static char *main_revision = "$Revision: 1.32.6.9 $";
 
 static int major;
 
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/divasi.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/divasi.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/divasi.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/divasi.c	2005-02-03 02:55:36.000000000 +0100
@@ -1,4 +1,4 @@
-/* $Id: divasi.c,v 1.25 2003/09/09 06:46:29 schindler Exp $
+/* $Id: divasi.c,v 1.25.6.2 2005/01/31 12:22:20 armin Exp $
  *
  * Driver for Eicon DIVA Server ISDN cards.
  * User Mode IDI Interface 
@@ -20,6 +20,7 @@
 #include <linux/proc_fs.h>
 #include <linux/skbuff.h>
 #include <linux/devfs_fs_kernel.h>
+#include <asm/uaccess.h>
 
 #include "platform.h"
 #include "di_defs.h"
@@ -27,7 +28,7 @@
 #include "um_xdi.h"
 #include "um_idi.h"
 
-static char *main_revision = "$Revision: 1.25 $";
+static char *main_revision = "$Revision: 1.25.6.2 $";
 
 static int major;
 
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/divasproc.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/divasproc.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/divasproc.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/divasproc.c	2005-02-03 02:56:22.000000000 +0100
@@ -1,4 +1,4 @@
-/* $Id: divasproc.c,v 1.19 2004/03/21 17:26:01 armin Exp $
+/* $Id: divasproc.c,v 1.19.4.3 2005/01/31 12:22:20 armin Exp $
  *
  * Low level driver for Eicon DIVA Server ISDN cards.
  * /proc functions
@@ -16,6 +16,7 @@
 #include <linux/poll.h>
 #include <linux/proc_fs.h>
 #include <linux/list.h>
+#include <asm/uaccess.h>
 
 #include "platform.h"
 #include "debuglib.h"
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/io.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/io.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/io.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/io.c	2005-02-03 02:55:23.000000000 +0100
@@ -227,10 +227,6 @@ void request(PISDN_ADAPTER IoAdapter, EN
         if (pI->descriptor_number >= 0) {
           dword dma_magic;
           void* local_addr;
-#if 0
-          DBG_TRC(("A(%d) dma_alloc(%d)",
-                   IoAdapter->ANum, pI->descriptor_number))
-#endif
           diva_get_dma_map_entry (\
                                (struct _diva_dma_map_entry*)IoAdapter->dma_map,
                                pI->descriptor_number,
@@ -243,9 +239,6 @@ void request(PISDN_ADAPTER IoAdapter, EN
         }
       } else if ((pI->operation == IDI_SYNC_REQ_DMA_DESCRIPTOR_FREE) &&
                  (pI->descriptor_number >= 0)) {
-#if 0
-        DBG_TRC(("A(%d) dma_free(%d)", IoAdapter->ANum, pI->descriptor_number))
-#endif
         diva_free_dma_map_entry((struct _diva_dma_map_entry*)IoAdapter->dma_map,
                                 pI->descriptor_number);
         pI->descriptor_number = -1;
@@ -369,9 +362,6 @@ void request(PISDN_ADAPTER IoAdapter, EN
   }
   if ( IoAdapter )
   {
-#if 0
-   DBG_FTL(("xdi: unknown Req 0 / Rc %d !", e->Rc))
-#endif
    return ;
   }
  }
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/mntfunc.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/mntfunc.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/mntfunc.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/mntfunc.c	2005-02-03 02:54:58.000000000 +0100
@@ -1,4 +1,4 @@
-/* $Id: mntfunc.c,v 1.19.6.2 2004/08/28 20:03:53 armin Exp $
+/* $Id: mntfunc.c,v 1.19.6.4 2005/01/31 12:22:20 armin Exp $
  *
  * Driver for Eicon DIVA Server ISDN cards.
  * Maint module
@@ -187,7 +187,7 @@ int maint_read_write(void __user *buf, i
 		if (!mask) {
 			ret = diva_set_trace_filter (1, "*");
 		} else if (mask < sizeof(data)) {
-			if (copy_from_user(data, (char __user *)buf+12, mask)) {
+			if (diva_os_copy_from_user(NULL, data, (char __user *)buf+12, mask)) {
 				ret = -EFAULT;
 			} else {
 				ret = diva_set_trace_filter ((int)mask, data);
@@ -199,7 +199,7 @@ int maint_read_write(void __user *buf, i
 
 	case DITRACE_READ_SELECTIVE_TRACE_FILTER:
 		if ((ret = diva_get_trace_filter (sizeof(data), data)) > 0) {
-			if (copy_to_user (buf, data, ret))
+			if (diva_os_copy_to_user (NULL, buf, data, ret))
 				ret = -EFAULT;
 		} else {
 			ret = -ENODEV;
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/platform.h linux-2.6.11-rc3/drivers/isdn/hardware/eicon/platform.h
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/platform.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/platform.h	2005-02-03 02:56:22.000000000 +0100
@@ -1,4 +1,4 @@
-/* $Id: platform.h,v 1.37.4.2 2004/08/28 20:03:53 armin Exp $
+/* $Id: platform.h,v 1.37.4.6 2005/01/31 12:22:20 armin Exp $
  *
  * platform.h
  * 
@@ -195,9 +195,7 @@ static __inline__ void* diva_os_malloc (
 }
 static __inline__ void  diva_os_free   (unsigned long flags, void* ptr)
 {
-	if (ptr) {
-		vfree(ptr);
-	}
+	vfree(ptr);
 }
 
 /*
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/s_4bri.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/s_4bri.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/s_4bri.c	2005-01-22 02:46:41.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/s_4bri.c	2005-02-03 02:54:38.000000000 +0100
@@ -359,506 +359,9 @@ int qBri_FPGA_download (PISDN_ADAPTER Io
 	return (1) ;
 }
 
-#if !defined(DIVA_USER_MODE_CARD_CONFIG) /* { */
-/* --------------------------------------------------------------------------
-		Download protocol code to the adapter
-	 -------------------------------------------------------------------------- */
-
-static int qBri_protocol_load (PISDN_ADAPTER BaseIoAdapter, PISDN_ADAPTER IoAdapter) {
-	PISDN_ADAPTER HighIoAdapter;
-
-	byte *p;
-	dword  FileLength ;
-	dword *sharedRam, *File;
-	dword  Addr, ProtOffset, SharedRamOffset, i;
-	dword tasks = BaseIoAdapter->tasks ;
-	int factor = (tasks == 1) ? 1 : 2;
-
-	if (!(File = (dword *)xdiLoadArchive (IoAdapter, &FileLength, 0))) {
-		return (0) ;
-	}
-
-	IoAdapter->features = diva_get_protocol_file_features ((byte*)File,
-	                                       OFFS_PROTOCOL_ID_STRING,
-	                                       IoAdapter->ProtocolIdString,
-	                                       sizeof(IoAdapter->ProtocolIdString)) ;
-	IoAdapter->a.protocol_capabilities = IoAdapter->features ;
-
-	DBG_LOG(("Loading %s", IoAdapter->ProtocolIdString))
-
-	ProtOffset = IoAdapter->ControllerNumber * (IoAdapter->MemorySize >> factor);
-	SharedRamOffset = (IoAdapter->MemorySize >> factor) - MQ_SHARED_RAM_SIZE;
-	Addr = ((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR]))
-	  | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 1])) << 8)
-	  | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 2])) << 16)
-	  | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 3])) << 24) ;
-        if ( Addr != 0 )
-	{
-		IoAdapter->DspCodeBaseAddr = (Addr + 3) & (~3) ;
-		IoAdapter->MaxDspCodeSize = (MQ_UNCACHED_ADDR (ProtOffset + SharedRamOffset) -
-										IoAdapter->DspCodeBaseAddr) & ((IoAdapter->MemorySize >> factor) - 1);
-
-		i = 0 ;
-		while ( BaseIoAdapter->QuadroList->QuadroAdapter[i]->ControllerNumber != tasks - 1 )
-			i++ ;
-		HighIoAdapter = BaseIoAdapter->QuadroList->QuadroAdapter[i] ;
-		Addr = HighIoAdapter->DspCodeBaseAddr ;
-
-		if (tasks == 1) {
-			((byte *) File)[OFFS_DIVA_INIT_TASK_COUNT]   =(byte)1;
-			((byte *) File)[OFFS_DIVA_INIT_TASK_COUNT+1] = (byte)BaseIoAdapter->cardType;
-		}
-
-		((byte *) File)[OFFS_DSP_CODE_BASE_ADDR] = (byte) Addr ;
-		((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 1] = (byte)(Addr >> 8) ;
-		((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 2] = (byte)(Addr >> 16) ;
-		((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 3] = (byte)(Addr >> 24) ;
-		IoAdapter->InitialDspInfo = 0x80 ;
-	}
-	else
-	{
-		if ( IoAdapter->features & PROTCAP_VOIP )
-		{
-			IoAdapter->DspCodeBaseAddr = MQ_CACHED_ADDR (ProtOffset + SharedRamOffset - MQ_VOIP_MAX_DSP_CODE_SIZE) ;
-
-			IoAdapter->MaxDspCodeSize = MQ_VOIP_MAX_DSP_CODE_SIZE ;
-
-		}
-		else if ( IoAdapter->features & PROTCAP_V90D )
-		{
-			IoAdapter->DspCodeBaseAddr = MQ_CACHED_ADDR (ProtOffset + SharedRamOffset - MQ_V90D_MAX_DSP_CODE_SIZE) ;
-
-			IoAdapter->MaxDspCodeSize = (IoAdapter->ControllerNumber == tasks - 1) ? MQ_V90D_MAX_DSP_CODE_SIZE : 0 ;
-
-		}
-		else
-		{
-			IoAdapter->DspCodeBaseAddr = MQ_CACHED_ADDR (ProtOffset + SharedRamOffset - MQ_ORG_MAX_DSP_CODE_SIZE) ;
-
-			IoAdapter->MaxDspCodeSize = (IoAdapter->ControllerNumber == tasks - 1) ? MQ_ORG_MAX_DSP_CODE_SIZE : 0 ;
-
-		}
-		IoAdapter->InitialDspInfo = (MQ_CACHED_ADDR (ProtOffset + SharedRamOffset -
-															MQ_ORG_MAX_DSP_CODE_SIZE) - IoAdapter->DspCodeBaseAddr) >> 14 ;
-
-	}
-	DBG_LOG(("%d: DSP code base 0x%08lx, max size 0x%08lx (%08lx,%02x)",
-	         IoAdapter->ControllerNumber,
-	         IoAdapter->DspCodeBaseAddr, IoAdapter->MaxDspCodeSize,
-	         Addr, IoAdapter->InitialDspInfo))
-
-	if (FileLength > ((IoAdapter->DspCodeBaseAddr - MQ_CACHED_ADDR (ProtOffset)) & (IoAdapter->MemorySize - 1)) )
-	{
-		xdiFreeFile (File) ;
-		DBG_FTL(("Protocol code '%s' too long (%ld)",
-		         &IoAdapter->Protocol[0], FileLength))
-		return (0) ;
-	}
-	IoAdapter->downloadAddr = 0 ;
-	p = DIVA_OS_MEM_ATTACH_RAM(IoAdapter);
-	sharedRam = (dword *)&p[IoAdapter->downloadAddr & (IoAdapter->MemorySize - 1)];
-	memcpy (sharedRam, File, FileLength) ;
-
-	DBG_TRC(("Download addr 0x%08x len %ld - virtual 0x%08x",
-	         IoAdapter->downloadAddr, FileLength, sharedRam))
-
-	if ( memcmp (sharedRam, File, FileLength) )
-	{
-		DBG_FTL(("%s: Memory test failed!", IoAdapter->Properties.Name))
-
-		DBG_FTL(("File=0x%x, sharedRam=0x%x", File, sharedRam))
-		DBG_BLK(( (char *)File, 256))
-		DBG_BLK(( (char *)sharedRam, 256))
-		DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
-
-		xdiFreeFile (File) ;
-		return (0) ;
-	}
-	DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
-	xdiFreeFile (File) ;
-
-	return (1) ;
-}
-
-/* --------------------------------------------------------------------------
-		DSP Code download
-	 -------------------------------------------------------------------------- */
-static long qBri_download_buffer (OsFileHandle *fp, long length, void **addr) {
-	PISDN_ADAPTER BaseIoAdapter = (PISDN_ADAPTER)fp->sysLoadDesc ;
-	PISDN_ADAPTER IoAdapter;
-	word        i ;
-	dword       *sharedRam ;
-	byte *p;
-
-	i = 0 ;
-
-	do
-	{
-		IoAdapter = BaseIoAdapter->QuadroList->QuadroAdapter[i++] ;
-	} while ( (i < BaseIoAdapter->tasks)
-	       && (((dword) length) > IoAdapter->DspCodeBaseAddr +
-	                IoAdapter->MaxDspCodeSize - IoAdapter->downloadAddr) );
-
-	*addr = (void *)IoAdapter->downloadAddr ;
-	if ( ((dword) length) > IoAdapter->DspCodeBaseAddr +
-	                        IoAdapter->MaxDspCodeSize - IoAdapter->downloadAddr )
-	{
-		DBG_FTL(("%s: out of card memory during DSP download (0x%X)",
-		         IoAdapter->Properties.Name,
-		         IoAdapter->downloadAddr + length))
-		return (-1) ;
-	}
-	p = DIVA_OS_MEM_ATTACH_RAM(BaseIoAdapter);
-	sharedRam = (dword*)&p[IoAdapter->downloadAddr & (IoAdapter->MemorySize - 1)];
-
-	if ( fp->sysFileRead (fp, sharedRam, length) != length ) {
-		DIVA_OS_MEM_DETACH_RAM(BaseIoAdapter, p);
-		return (-1) ;
-	}
-	DIVA_OS_MEM_DETACH_RAM(BaseIoAdapter, p);
-
-	IoAdapter->downloadAddr += length ;
-	IoAdapter->downloadAddr  = (IoAdapter->downloadAddr + 3) & (~3) ;
-
-	return (0) ;
-}
-
-/******************************************************************************/
-
-static dword qBri_telindus_load (PISDN_ADAPTER BaseIoAdapter) {
-	PISDN_ADAPTER        IoAdapter = 0;
-	PISDN_ADAPTER        HighIoAdapter = NULL ;
-	char                *error ;
-	OsFileHandle        *fp ;
-	t_dsp_portable_desc  download_table[DSP_MAX_DOWNLOAD_COUNT] ;
-	word                 download_count, i ;
-	dword               *sharedRam ;
-	dword                FileLength ;
-	byte *p;
-
-	if ( !(fp = OsOpenFile (DSP_TELINDUS_FILE)) ) {
-		DBG_FTL(("qBri_telindus_load: %s not found!", DSP_TELINDUS_FILE))
-		return (0) ;
-	}
-
-
-	for ( i = 0 ; i < BaseIoAdapter->tasks ; ++i )
-	{
-		IoAdapter = BaseIoAdapter->QuadroList->QuadroAdapter[i] ;
-		IoAdapter->downloadAddr = IoAdapter->DspCodeBaseAddr ;
-		if ( IoAdapter->ControllerNumber == BaseIoAdapter->tasks - 1 )
-		{
-			HighIoAdapter = IoAdapter ;
-			HighIoAdapter->downloadAddr = (HighIoAdapter->downloadAddr
-			           + sizeof(dword) + sizeof(download_table) + 3) & (~3) ;
-		}
-	}
-
-
-	FileLength      = fp->sysFileSize ;
-	fp->sysLoadDesc = (void *)BaseIoAdapter ;
-	fp->sysCardLoad = qBri_download_buffer ;
-
-	download_count = DSP_MAX_DOWNLOAD_COUNT ;
-	memset (&download_table[0], '\0', sizeof(download_table)) ;
-/*
- *	set start address for download
- */
-	error = dsp_read_file (fp, (word)(IoAdapter->cardType),
-	                       &download_count, NULL, &download_table[0]) ;
-	if ( error )
-	{
-		DBG_FTL(("download file error: %s", error))
-		OsCloseFile (fp) ;
-		return (0) ;
-	}
-	OsCloseFile (fp) ;
-
-
-	/*
-	 *	store # of download files extracted from the archive and download table
-	 */
-		HighIoAdapter->downloadAddr = HighIoAdapter->DspCodeBaseAddr ;
-		p = DIVA_OS_MEM_ATTACH_RAM(BaseIoAdapter);
-		sharedRam = (dword *)&p[HighIoAdapter->downloadAddr & (IoAdapter->MemorySize - 1)];
-		WRITE_DWORD(&(sharedRam[0]), (dword)download_count);
-		memcpy (&sharedRam[1], &download_table[0], sizeof(download_table)) ;
-
-
-	/* memory check */
-	if ( memcmp (&sharedRam[1], &download_table, download_count) ) {
-		DBG_FTL(("%s: Dsp Memory test failed!", IoAdapter->Properties.Name))
-	}
-	DIVA_OS_MEM_DETACH_RAM(BaseIoAdapter, p);
-
-	return (FileLength) ;
-}
-
-/*
-	Load SDP tasks to the card
-	Return start address of image on succesful load
-	Return zero in case of problem
-
-	INPUT:
-		task			->	name of the image containing this task
-		link_addr	->	pointer to start of previous task
-	*/
-static byte* qBri_sdp_load (PISDN_ADAPTER BaseIoAdapter,
-													char* task,
-													byte*	link_addr) {
-	OsFileHandle *fp;
-	dword FileLength;
-	byte tmp[sizeof(dword)];
-	dword gp_addr;
-	dword entry_addr;
-	dword start_addr = 0;
-	dword phys_start_addr;
-	dword end_addr;
-	byte* sharedRam = 0;
-	byte *p;
-
-  if (task) {
-		if (!(fp = OsOpenFile (task))) {
-			DBG_ERR(("Can't open [%s] image", task))
-			return (0);
-		}
-		if ((FileLength = fp->sysFileSize) < DIVA_MIPS_TASK_IMAGE_ID_STRING_OFFS) {
-			OsCloseFile (fp) ;
-			DBG_ERR(("Image [%s] too short", task))
-			return (0);
-		}
-
-		fp->sysFileSeek (fp, DIVA_MIPS_TASK_IMAGE_GP_OFFS, OS_SEEK_SET);
-		if (fp->sysFileRead (fp, tmp, sizeof(dword)) != sizeof(dword)) {
-			OsCloseFile (fp) ;
-			DBG_ERR(("Can't read image [%s]", task))
-			return (0);
-		}
-		gp_addr = ((dword)tmp[0])					|
-							(((dword)tmp[1]) << 8)	|
-							(((dword)tmp[2]) << 16) |
-							(((dword)tmp[3]) << 24);
-		DBG_TRC(("Image [%s] GP = %08lx", task, gp_addr))
-
-		fp->sysFileSeek (fp, DIVA_MIPS_TASK_IMAGE_ENTRY_OFFS, OS_SEEK_SET);
-		if (fp->sysFileRead (fp, tmp, sizeof(dword)) != sizeof(dword)) {
-			OsCloseFile (fp) ;
-			DBG_ERR(("Can't read image [%s]", task))
-			return (0);
-		}
-		entry_addr = ((dword)tmp[0])					|
-									(((dword)tmp[1]) << 8)	|
-									(((dword)tmp[2]) << 16) |
-									(((dword)tmp[3]) << 24);
-		DBG_TRC(("Image [%s] entry = %08lx", task, entry_addr))
-
-		fp->sysFileSeek (fp, DIVA_MIPS_TASK_IMAGE_LOAD_ADDR_OFFS, OS_SEEK_SET);
-		if (fp->sysFileRead (fp, tmp, sizeof(dword)) != sizeof(dword)) {
-			OsCloseFile (fp) ;
-			DBG_ERR(("Can't read image [%s]", task))
-			return (0);
-		}
-		start_addr = ((dword)tmp[0])					|
-									(((dword)tmp[1]) << 8)	|
-									(((dword)tmp[2]) << 16) |
-									(((dword)tmp[3]) << 24);
-		DBG_TRC(("Image [%s] start = %08lx", task, start_addr))
-
-		fp->sysFileSeek (fp, DIVA_MIPS_TASK_IMAGE_END_ADDR_OFFS, OS_SEEK_SET);
-		if (fp->sysFileRead (fp, tmp, sizeof(dword)) != sizeof(dword)) {
-			OsCloseFile (fp) ;
-			DBG_ERR(("Can't read image [%s]", task))
-			return (0);
-		}
-		end_addr = ((dword)tmp[0])					|
-								(((dword)tmp[1]) << 8)	|
-								(((dword)tmp[2]) << 16) |
-								(((dword)tmp[3]) << 24);
-		DBG_TRC(("Image [%s] end = %08lx", task, end_addr))
-
-		phys_start_addr = start_addr & 0x1fffffff;
-
-		if ((phys_start_addr + FileLength) >= BaseIoAdapter->MemorySize) {
-			OsCloseFile (fp) ;
-			DBG_ERR(("Image [%s] too long", task))
-			return (0);
-		}
-
-		fp->sysFileSeek (fp, 0, OS_SEEK_SET);
-		p = DIVA_OS_MEM_ATTACH_RAM(BaseIoAdapter);
-		sharedRam = &p[phys_start_addr];
-		if ((dword)fp->sysFileRead (fp, sharedRam, FileLength) != FileLength) {
-			DIVA_OS_MEM_DETACH_RAM(BaseIoAdapter, p);
-			OsCloseFile (fp) ;
-			DBG_ERR(("Can't read image [%s]", task))
-			return (0);
-		}
-		DIVA_OS_MEM_DETACH_RAM(BaseIoAdapter, p);
-
-		OsCloseFile (fp) ;
-  }
-
-	p = DIVA_OS_MEM_ATTACH_RAM(BaseIoAdapter);
-	if (!link_addr) {
-		link_addr = &p[OFFS_DSP_CODE_BASE_ADDR];
-	}
-
-	DBG_TRC(("Write task [%s] link %08lx at %08lx",
-						task ? task : "none",
-						start_addr,
-						link_addr - (byte*)&BaseIoAdapter->ram[0]))
-
-	link_addr[0] = (byte)(start_addr         & 0xff);
-	link_addr[1] = (byte)((start_addr >>  8) & 0xff);
-	link_addr[2] = (byte)((start_addr >> 16) & 0xff);
-	link_addr[3] = (byte)((start_addr >> 24) & 0xff);
-
-	DIVA_OS_MEM_DETACH_RAM(BaseIoAdapter, p);
-
-	return (task ? &sharedRam[DIVA_MIPS_TASK_IMAGE_LINK_OFFS] : 0);
-}
-
-/* --------------------------------------------------------------------------
-		Load Card
-	 -------------------------------------------------------------------------- */
-static int load_qBri_hardware (PISDN_ADAPTER IoAdapter) {
-	dword         i, offset, controller ;
-	word         *signature ;
-	int           factor = (IoAdapter->tasks == 1) ? 1 : 2;
-	byte *p;
-
-	PISDN_ADAPTER Slave ;
-
-
-	if (
-
-		!IoAdapter->QuadroList
-
-	  || ( (IoAdapter->cardType != CARDTYPE_DIVASRV_Q_8M_PCI)
-	    && (IoAdapter->cardType != CARDTYPE_DIVASRV_VOICE_Q_8M_PCI)
-	    && (IoAdapter->cardType != CARDTYPE_DIVASRV_Q_8M_V2_PCI)
-     && (IoAdapter->cardType != CARDTYPE_DIVASRV_VOICE_Q_8M_V2_PCI)
-     && (IoAdapter->cardType != CARDTYPE_DIVASRV_B_2M_V2_PCI)
-     && (IoAdapter->cardType != CARDTYPE_DIVASRV_VOICE_B_2M_V2_PCI)
-     && (IoAdapter->cardType != CARDTYPE_DIVASRV_B_2F_PCI) ) )
-	{
-		return (0) ;
-	}
-
-/*
- *	Check for first instance
- */
-	if ( IoAdapter->ControllerNumber > 0 )
-		return (1) ;
-
-/*
- *	first initialize the onboard FPGA
- */
-	if ( !qBri_FPGA_download (IoAdapter) )
-		return (0) ;
-
-
-	for ( i = 0; i < IoAdapter->tasks; i++ )
-	{
-		Slave = IoAdapter->QuadroList->QuadroAdapter[i] ;
-		Slave->fpga_features = IoAdapter->fpga_features ;
-	}
-
-
-/*
- *	download protocol code for all instances
- */
-
-	controller = IoAdapter->tasks;
-	do
-	{
-		controller-- ;
-		i = 0 ;
-		while ( IoAdapter->QuadroList->QuadroAdapter[i]->ControllerNumber != controller )
-			i++ ;
-/*
- *	calculate base address for instance
- */
-		Slave          = IoAdapter->QuadroList->QuadroAdapter[i] ;
-		offset         = Slave->ControllerNumber * (IoAdapter->MemorySize >> factor) ;
-		Slave->Address = &IoAdapter->Address[offset] ;
-		Slave->ram     = &IoAdapter->ram[offset] ;
-		Slave->reset   = IoAdapter->reset ;
-		Slave->ctlReg  = IoAdapter->ctlReg ;
-		Slave->prom    = IoAdapter->prom ;
-		Slave->Config  = IoAdapter->Config ;
-		Slave->Control = IoAdapter->Control ;
-
-		if ( !qBri_protocol_load (IoAdapter, Slave) )
-			return (0) ;
-
-	} while (controller != 0) ;
-
-
-/*
- *	download only one copy of the DSP code
- */
- if (IoAdapter->cardType != CARDTYPE_DIVASRV_B_2F_PCI) {
-	if ( !qBri_telindus_load (IoAdapter) )
-		return (0) ;
- } else {
-   byte* link_addr = 0;
-   link_addr = qBri_sdp_load (IoAdapter, DIVA_BRI2F_SDP_1_NAME, link_addr);
-   link_addr = qBri_sdp_load (IoAdapter, DIVA_BRI2F_SDP_2_NAME, link_addr);
-   if (!link_addr) {
-     qBri_sdp_load (IoAdapter, 0, link_addr);
-   }
- }
-
-/*
- *	copy configuration parameters
- */
-
-	for ( i = 0 ; i < IoAdapter->tasks ; ++i )
-	{
-		Slave = IoAdapter->QuadroList->QuadroAdapter[i] ;
-		Slave->ram += (IoAdapter->MemorySize >> factor) - MQ_SHARED_RAM_SIZE ;
-		p = DIVA_OS_MEM_ATTACH_RAM(Slave);
-		DBG_TRC(("Configure instance %d shared memory @ 0x%08lx",
-		         Slave->ControllerNumber, p))
-		memset (p, '\0', 256) ;
-		DIVA_OS_MEM_DETACH_RAM(Slave, p);
-		diva_configure_protocol (Slave);
-	}
-
-/*
- *	start adapter
- */
-	start_qBri_hardware (IoAdapter) ;
-	p = DIVA_OS_MEM_ATTACH_RAM(IoAdapter);
-	signature = (word *)(&p[0x1E]) ;
-/*
- *	wait for signature in shared memory (max. 3 seconds)
- */
-	for ( i = 0 ; i < 300 ; ++i )
-	{
-		diva_os_wait (10) ;
-
-		if ( signature[0] == 0x4447 )
-		{
-			DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
-			DBG_TRC(("Protocol startup time %d.%02d seconds",
-			         (i / 100), (i % 100) ))
-
-			return (1) ;
-		}
-	}
-	DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
-	DBG_FTL(("%s: Adapter selftest failed (0x%04X)!",
-	         IoAdapter->Properties.Name, signature[0] >> 16))
-	qBri_cpu_trapped (IoAdapter) ;
-	return (FALSE) ;
-}
-#else /* } { */
 static int load_qBri_hardware (PISDN_ADAPTER IoAdapter) {
 	return (0);
 }
-#endif /* } */
 
 /* --------------------------------------------------------------------------
 		Card ISR
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/s_bri.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/s_bri.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/s_bri.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/s_bri.c	2005-02-03 02:56:48.000000000 +0100
@@ -119,356 +119,9 @@ static void stop_bri_hardware (PISDN_ADA
  outpp (p, 0x00) ;    /* clear int, halt cpu */
  DIVA_OS_MEM_DETACH_CTLREG(IoAdapter, p);
 }
-#if !defined(DIVA_USER_MODE_CARD_CONFIG) /* { */
-/* ---------------------------------------------------------------------
-  Load protocol on the card
-  --------------------------------------------------------------------- */
-static dword bri_protocol_load (PISDN_ADAPTER IoAdapter) {
- dword   FileLength ;
- word    test, *File = NULL ;
- byte*  addrHi, *addrLo, *ioaddr ;
- char   *FileName = &IoAdapter->Protocol[0] ;
- dword   Addr, i ;
- byte *Port;
- /* -------------------------------------------------------------------
-   Try to load protocol code. 'File' points to memory location
-   that does contain entire protocol code
-   ------------------------------------------------------------------- */
- if ( !(File = (word *)xdiLoadArchive (IoAdapter, &FileLength, 0)) )
-  return (0) ;
- /* -------------------------------------------------------------------
-   Get protocol features and calculate load addresses
-   ------------------------------------------------------------------- */
- IoAdapter->features = diva_get_protocol_file_features ((byte*)File,
-                     OFFS_PROTOCOL_ID_STRING,
-                     IoAdapter->ProtocolIdString,
-                     sizeof(IoAdapter->ProtocolIdString));
- IoAdapter->a.protocol_capabilities = IoAdapter->features ;
- DBG_LOG(("Loading %s", IoAdapter->ProtocolIdString))
- Addr = ((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR]))
-   | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 1])) << 8)
-   | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 2])) << 16)
-   | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 3])) << 24) ;
-        if ( Addr != 0 )
- {
-  IoAdapter->DspCodeBaseAddr = (Addr + 3) & (~3) ;
-  IoAdapter->MaxDspCodeSize = (BRI_UNCACHED_ADDR (IoAdapter->MemoryBase + IoAdapter->MemorySize -
-                                                  BRI_SHARED_RAM_SIZE)
-                            - IoAdapter->DspCodeBaseAddr) & (IoAdapter->MemorySize - 1) ;
-  Addr = IoAdapter->DspCodeBaseAddr ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR] = (byte) Addr ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 1] = (byte)(Addr >> 8) ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 2] = (byte)(Addr >> 16) ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 3] = (byte)(Addr >> 24) ;
-  IoAdapter->InitialDspInfo = 0x80 ;
- }
- else
- {
-  if ( IoAdapter->features & PROTCAP_V90D )
-   IoAdapter->MaxDspCodeSize = BRI_V90D_MAX_DSP_CODE_SIZE ;
-  else
-   IoAdapter->MaxDspCodeSize = BRI_ORG_MAX_DSP_CODE_SIZE ;
-  IoAdapter->DspCodeBaseAddr = BRI_CACHED_ADDR (IoAdapter->MemoryBase + IoAdapter->MemorySize -
-                                                BRI_SHARED_RAM_SIZE - IoAdapter->MaxDspCodeSize);
-  IoAdapter->InitialDspInfo = (IoAdapter->MaxDspCodeSize - BRI_ORG_MAX_DSP_CODE_SIZE) >> 14 ;
- }
- DBG_LOG(("DSP code base 0x%08lx, max size 0x%08lx (%08lx,%02x)",
-      IoAdapter->DspCodeBaseAddr, IoAdapter->MaxDspCodeSize,
-      Addr, IoAdapter->InitialDspInfo))
- if ( FileLength > ((IoAdapter->DspCodeBaseAddr -
-                     BRI_CACHED_ADDR (IoAdapter->MemoryBase)) & (IoAdapter->MemorySize - 1)) )
- {
-  xdiFreeFile (File);
-  DBG_FTL(("Protocol code '%s' too big (%ld)", FileName, FileLength))
-  return (0) ;
- }
- Port = DIVA_OS_MEM_ATTACH_PORT(IoAdapter);
- addrHi =   Port + ((IoAdapter->Properties.Bus == BUS_PCI) ? M_PCI_ADDRH : ADDRH) ;
- addrLo = Port + ADDR ;
- ioaddr = Port + DATA ;
-/*
- * set start address for download (use autoincrement mode !)
- */
- outpp  (addrHi, 0) ;
- outppw (addrLo, 0) ;
- for ( i = 0 ; i < FileLength ; i += 2 )
- {
-  if ( (i & 0x0000FFFF) == 0 )
-  {
-   outpp (addrHi, (byte)(i >> 16)) ;
-  }
-  outppw (ioaddr, File[i/2]) ;
- }
-/*
- * memory test without second load of file
- */
- outpp  (addrHi, 0) ;
- outppw (addrLo, 0) ;
- for ( i = 0 ; i < FileLength ; i += 2 )
- {
-  if ( (i & 0x0000FFFF) == 0 )
-  {
-   outpp (addrHi, (byte)(i >> 16)) ;
-  }
-  test = inppw (ioaddr) ;
-  if ( test != File[i/2] )
-  {
-   DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
-   DBG_FTL(("%s: Memory test failed! (%d - 0x%04X/0x%04X)",
-            IoAdapter->Properties.Name, i, test, File[i/2]))
-   xdiFreeFile (File);
-   return (0) ;
-  }
- }
- DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
- xdiFreeFile (File);
- return (FileLength) ;
-}
-/******************************************************************************/
-typedef struct
-{
- PISDN_ADAPTER IoAdapter ;
- byte*        AddrLo ;
- byte*        AddrHi ;
- word*       Data ;
- dword         DownloadPos ;
-} bri_download_info ;
-static long bri_download_buffer (OsFileHandle *fp, long length, void **addr) {
- int        buffer_size = 2048*sizeof(word);
- word       *buffer = (word*)diva_os_malloc (0, buffer_size);
- bri_download_info *info ;
- word       test ;
- long       i, len, page ;
- if (!buffer) {
-  DBG_ERR(("A: out of memory, s_bri at %d", __LINE__))
-  return (-1);
- }
- info = (bri_download_info *)fp->sysLoadDesc ;
- *addr = (void *)info->DownloadPos ;
- if ( ((dword) length) > info->IoAdapter->DspCodeBaseAddr +
-                         info->IoAdapter->MaxDspCodeSize - info->DownloadPos )
- {
-  DBG_FTL(("%s: out of card memory during DSP download (0x%X)",
-           info->IoAdapter->Properties.Name,
-           info->DownloadPos + length))
-  diva_os_free (0, buffer);
-  return (-1) ;
- }
- for ( len = 0 ; length > 0 ; length -= len )
- {
-  len = (length > buffer_size ? buffer_size : length) ;
-  page = ((long)(info->DownloadPos) + len) & 0xFFFF0000 ;
-  if ( page != (long)(info->DownloadPos & 0xFFFF0000) )
-  {
-   len = 0x00010000 - (((long)info->DownloadPos) & 0x0000FFFF) ;
-  }
-  if ( fp->sysFileRead (fp, &buffer[0], len) != len ) {
-   diva_os_free (0, buffer);
-   return (-1) ;
-  }
-  outpp (info->AddrHi, (byte)(info->DownloadPos >> 16)) ;
-  outppw (info->AddrLo, (word)info->DownloadPos) ;
-  outppw_buffer (info->Data, &buffer[0], (len + 1)) ;
-/*
- * memory test without second load of file
- */
-  outpp (info->AddrHi, (byte)(info->DownloadPos >> 16)) ;
-  outppw (info->AddrLo, (word)info->DownloadPos) ;
-  for ( i = 0 ; i < len ; i += 2 )
-  {
-   if ( (test = inppw (info->Data)) != buffer[i/2] )
-   {
-    DBG_FTL(("%s: Memory test failed! (0x%lX - 0x%04X/0x%04X)",
-             info->IoAdapter->Properties.Name,
-             info->DownloadPos + i, test, buffer[i/2]))
-    diva_os_free (0, buffer);
-    return (-2) ;
-   }
-  }
-  info->DownloadPos += len ;
- }
- info->DownloadPos = (info->DownloadPos + 3) & (~3) ;
- diva_os_free (0, buffer);
- return (0) ;
-}
-/******************************************************************************/
-static dword bri_telindus_load (PISDN_ADAPTER IoAdapter, char *DspTelindusFile) 
-{
- bri_download_info    *pinfo =\
-             (bri_download_info*)diva_os_malloc(0, sizeof(*pinfo));
- char                *error ;
- OsFileHandle        *fp ;
- t_dsp_portable_desc  download_table[DSP_MAX_DOWNLOAD_COUNT] ;
- word                 download_count ;
- dword                FileLength ;
- byte *Port;
- if (!pinfo) {
-  DBG_ERR (("A: out of memory s_bri at %d", __LINE__))
-  return (0);
- }
- if (!(fp = OsOpenFile (DspTelindusFile))) {
-  diva_os_free (0, pinfo);
-  return (0) ;
- }
- FileLength     = fp->sysFileSize ;
- Port = DIVA_OS_MEM_ATTACH_PORT(IoAdapter);
- pinfo->IoAdapter = IoAdapter ;
- pinfo->AddrLo    = Port + ADDR ;
- pinfo->AddrHi    = Port + (IoAdapter->Properties.Bus == BUS_PCI ? M_PCI_ADDRH : ADDRH);
- pinfo->Data = (word*)(Port + DATA) ;
- pinfo->DownloadPos = (IoAdapter->DspCodeBaseAddr +\
-           sizeof(dword) + sizeof(download_table) + 3) & (~3) ;
- fp->sysLoadDesc = (void *)pinfo;
- fp->sysCardLoad = bri_download_buffer ;
- download_count = DSP_MAX_DOWNLOAD_COUNT ;
- memset (&download_table[0], '\0', sizeof(download_table)) ;
-/*
- * set start address for download (use autoincrement mode !)
- */
- error = dsp_read_file (fp, (word)(IoAdapter->cardType),
-                        &download_count, NULL, &download_table[0]) ;
- if ( error )
- {
-  DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
-  DBG_FTL(("download file error: %s", error))
-  OsCloseFile (fp) ;
-  diva_os_free (0, pinfo);
-  return (0) ;
- }
- OsCloseFile (fp) ;
-/*
- * store # of separate download files extracted from archive
- */
- pinfo->DownloadPos = IoAdapter->DspCodeBaseAddr ;
- outpp  (pinfo->AddrHi, (byte)(pinfo->DownloadPos >> 16)) ;
- outppw (pinfo->AddrLo, (word)pinfo->DownloadPos) ;
- outppw (pinfo->Data,   (word)download_count) ;
- outppw (pinfo->Data,   (word)0) ;
-/*
- * copy download table to board
- */
- outppw_buffer (pinfo->Data, &download_table[0], sizeof(download_table)) ;
- DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
- diva_os_free (0, pinfo);
- return (FileLength) ;
-}
-/******************************************************************************/
-static int load_bri_hardware (PISDN_ADAPTER IoAdapter) {
- dword   i ;
- byte*  addrHi, *addrLo, *ioaddr, *p ;
- dword   test ;
- byte *Port;
- if ( IoAdapter->Properties.Card != CARD_MAE )
- {
-  return (FALSE) ;
- }
- reset_bri_hardware (IoAdapter) ;
- Port = DIVA_OS_MEM_ATTACH_PORT(IoAdapter);
- addrHi =   Port + ((IoAdapter->Properties.Bus==BUS_PCI) ? M_PCI_ADDRH : ADDRH);
- addrLo = Port + ADDR ;
- ioaddr = Port + DATA ;
- diva_os_wait (100);
-/*
- * recover
- */
- outpp  (addrHi, (byte) 0) ;
- outppw (addrLo, (word) 0) ;
- outppw (ioaddr, (word) 0) ;
-/*
- * clear shared memory
- */
- outpp  (addrHi, (byte)((BRI_UNCACHED_ADDR (IoAdapter->MemoryBase + \
-          IoAdapter->MemorySize - BRI_SHARED_RAM_SIZE)) >> 16)) ;
- outppw (addrLo, 0) ;
- for ( i = 0 ; i < 0x8000 ; outppw (ioaddr, 0), ++i ) ;
- DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
- diva_os_wait (100) ;
-/*
- * download protocol and dsp files
- */
- switch ( IoAdapter->protocol_id ) {
- default:
-  if ( !xdiSetProtocol (IoAdapter, IoAdapter->ProtocolSuffix) )
-   return (FALSE) ;
-  if ( !bri_protocol_load (IoAdapter) )
-   return (FALSE) ;
-  if ( !bri_telindus_load (IoAdapter, DSP_TELINDUS_FILE) )
-   return (FALSE) ;
-  break ;
- case PROTTYPE_QSIG:
- case PROTTYPE_CORNETN:
-  if ( !xdiSetProtocol (IoAdapter, IoAdapter->ProtocolSuffix) )
-   return (FALSE) ;
-  if (IoAdapter->ProtocolSuffix && *IoAdapter->ProtocolSuffix) {
-   sprintf (&IoAdapter->Protocol[0],
-        "TE_QSIG.%s", IoAdapter->ProtocolSuffix) ;
-  }
-  DBG_TRC(("xdiSetProtocol: %s firmware '%s' archive '%s'",
-     IoAdapter->Properties.Name,
-     &IoAdapter->Protocol[0], &IoAdapter->Archive[0]))
-  if ( !bri_protocol_load (IoAdapter) )
-   return (FALSE) ;
-  if ( !bri_telindus_load (IoAdapter, DSP_QSIG_TELINDUS_FILE) )
-   return (FALSE) ;
-  break ;
- }
-
- Port = DIVA_OS_MEM_ATTACH_PORT(IoAdapter);
- addrHi =   Port + ((IoAdapter->Properties.Bus==BUS_PCI) ? M_PCI_ADDRH : ADDRH);
- addrLo = Port + ADDR ;
- ioaddr = Port + DATA ;
-/*
- * clear signature
- */
- outpp  (addrHi, (byte)((BRI_UNCACHED_ADDR (IoAdapter->MemoryBase + \
-     IoAdapter->MemorySize - BRI_SHARED_RAM_SIZE)) >> 16)) ;
- outppw (addrLo, 0x1e) ;
- outpp (ioaddr, 0) ;
- outpp (ioaddr, 0) ;
-/*
- * copy parameters
- */
- diva_configure_protocol (IoAdapter);
- DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
-/*
- * start the protocol code
- */
- p = DIVA_OS_MEM_ATTACH_CTLREG(IoAdapter);
- outpp (p, 0x08) ;
- DIVA_OS_MEM_DETACH_CTLREG(IoAdapter, p);
-/*
- * wait for signature (max. 3 seconds)
- */
- Port = DIVA_OS_MEM_ATTACH_PORT(IoAdapter);
- addrHi =   Port + ((IoAdapter->Properties.Bus==BUS_PCI) ? M_PCI_ADDRH : ADDRH);
- addrLo = Port + ADDR ;
- ioaddr = Port + DATA ;
- for ( i = 0 ; i < 300 ; ++i )
- {
-  diva_os_wait (10) ;
-  outpp (addrHi, (byte)((BRI_UNCACHED_ADDR (IoAdapter->MemoryBase + \
-      IoAdapter->MemorySize - BRI_SHARED_RAM_SIZE)) >> 16)) ;
-  outppw (addrLo, 0x1e) ;
-  test = (dword)inppw (ioaddr) ;
-  if ( test == 0x4447 )
-  {
-   DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
-   DBG_TRC(("Protocol startup time %d.%02d seconds",
-            (i / 100), (i % 100) ))
-   return (TRUE) ;
-  }
- }
- DIVA_OS_MEM_DETACH_PORT(IoAdapter, Port);
- DBG_FTL(("%s: Adapter selftest failed (0x%04X)!",
-          IoAdapter->Properties.Name, test))
- bri_cpu_trapped (IoAdapter) ;
- return (FALSE) ;
-}
-#else /* } { */
 static int load_bri_hardware (PISDN_ADAPTER IoAdapter) {
  return (0);
 }
-#endif /* } */
 /******************************************************************************/
 static int bri_ISR (struct _ISDN_ADAPTER* IoAdapter) {
  byte __iomem *p;
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/s_pri.c linux-2.6.11-rc3/drivers/isdn/hardware/eicon/s_pri.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/hardware/eicon/s_pri.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/hardware/eicon/s_pri.c	2005-02-03 02:57:04.000000000 +0100
@@ -122,371 +122,9 @@ static void stop_pri_hardware (PISDN_ADA
  WRITE_BYTE(p, _MP_RISC_RESET | _MP_LED1 | _MP_LED2);
  DIVA_OS_MEM_DETACH_RESET(IoAdapter, p);
 }
-#if !defined(DIVA_USER_MODE_CARD_CONFIG) /* { */
-/* -------------------------------------------------------------------------
-  Load protocol code to the PRI Card
-  ------------------------------------------------------------------------- */
-#define DOWNLOAD_ADDR(IoAdapter) (IoAdapter->downloadAddr & (IoAdapter->MemorySize - 1))
-static int pri_protocol_load (PISDN_ADAPTER IoAdapter) {
- dword  FileLength ;
- dword *File ;
- dword *sharedRam ;
- dword  Addr ;
- byte *p;
- if (!(File = (dword *)xdiLoadArchive (IoAdapter, &FileLength, 0))) {
-  return (0) ;
- }
- IoAdapter->features = diva_get_protocol_file_features ((byte*)File,
-                                        OFFS_PROTOCOL_ID_STRING,
-                                        IoAdapter->ProtocolIdString,
-                                        sizeof(IoAdapter->ProtocolIdString)) ;
- IoAdapter->a.protocol_capabilities = IoAdapter->features ;
- DBG_LOG(("Loading %s", IoAdapter->ProtocolIdString))
- Addr = ((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR]))
-   | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 1])) << 8)
-   | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 2])) << 16)
-   | (((dword)(((byte *) File)[OFFS_PROTOCOL_END_ADDR + 3])) << 24) ;
-        if ( Addr != 0 )
- {
-  IoAdapter->DspCodeBaseAddr = (Addr + 3) & (~3) ;
-  IoAdapter->MaxDspCodeSize = (MP_UNCACHED_ADDR (IoAdapter->MemorySize)
-                            - IoAdapter->DspCodeBaseAddr) & (IoAdapter->MemorySize - 1) ;
-  Addr = IoAdapter->DspCodeBaseAddr ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR] = (byte) Addr ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 1] = (byte)(Addr >> 8) ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 2] = (byte)(Addr >> 16) ;
-  ((byte *) File)[OFFS_DSP_CODE_BASE_ADDR + 3] = (byte)(Addr >> 24) ;
-  IoAdapter->InitialDspInfo = 0x80 ;
- }
- else
- {
-  if ( IoAdapter->features & PROTCAP_VOIP )
-   IoAdapter->MaxDspCodeSize = MP_VOIP_MAX_DSP_CODE_SIZE ;
-  else if ( IoAdapter->features & PROTCAP_V90D )
-   IoAdapter->MaxDspCodeSize = MP_V90D_MAX_DSP_CODE_SIZE ;
-  else
-   IoAdapter->MaxDspCodeSize = MP_ORG_MAX_DSP_CODE_SIZE ;
-  IoAdapter->DspCodeBaseAddr = MP_CACHED_ADDR (IoAdapter->MemorySize -
-                                               IoAdapter->MaxDspCodeSize) ;
-  IoAdapter->InitialDspInfo = (IoAdapter->MaxDspCodeSize
-                            - MP_ORG_MAX_DSP_CODE_SIZE) >> 14 ;
- }
- DBG_LOG(("DSP code base 0x%08lx, max size 0x%08lx (%08lx,%02x)",
-          IoAdapter->DspCodeBaseAddr, IoAdapter->MaxDspCodeSize,
-          Addr, IoAdapter->InitialDspInfo))
- if ( FileLength > ((IoAdapter->DspCodeBaseAddr -
-                     MP_CACHED_ADDR (MP_PROTOCOL_OFFSET)) & (IoAdapter->MemorySize - 1)) )
- {
-  xdiFreeFile (File);
-  DBG_FTL(("Protocol code '%s' too long (%ld)",
-           &IoAdapter->Protocol[0], FileLength))
-  return (0) ;
- }
- IoAdapter->downloadAddr = MP_UNCACHED_ADDR (MP_PROTOCOL_OFFSET) ;
- p = DIVA_OS_MEM_ATTACH_RAM(IoAdapter);
- sharedRam = (dword *)(&p[DOWNLOAD_ADDR(IoAdapter)]);
- memcpy (sharedRam, File, FileLength) ;
- if ( memcmp (sharedRam, File, FileLength) )
- {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
-  DBG_FTL(("%s: Memory test failed!", IoAdapter->Properties.Name))
-  xdiFreeFile (File);
-  return (0) ;
- }
- DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
- xdiFreeFile (File);
- return (1) ;
-}
-/******************************************************************************/
-/*------------------------------------------------------------------
-  Dsp related definitions
-  ------------------------------------------------------------------ */
-#define DSP_SIGNATURE_PROBE_WORD 0x5a5a
-/*
-**  Checks presence of DSP on board
-*/
-static int
-dsp_check_presence (volatile byte* addr, volatile byte* data, int dsp)
-{
-  word pattern;
-  *(volatile word*)addr = 0x4000;
-  *(volatile word*)data = DSP_SIGNATURE_PROBE_WORD;
-  *(volatile word*)addr = 0x4000;
-  pattern = *(volatile word*)data;
-  if (pattern != DSP_SIGNATURE_PROBE_WORD) {
-    DBG_TRC(("W: DSP[%d] %04x(is) != %04x(should)",
-              dsp, pattern, DSP_SIGNATURE_PROBE_WORD))
-    return (-1);
-  }
-  *(volatile word*)addr = 0x4000;
-  *(volatile word*)data = ~DSP_SIGNATURE_PROBE_WORD;
-  *(volatile word*)addr = 0x4000;
-  pattern = *(volatile word*)data;
-  if (pattern != (word)~DSP_SIGNATURE_PROBE_WORD) {
-    DBG_ERR(("A: DSP[%d] %04x(is) != %04x(should)",
-              dsp, pattern, (word)~DSP_SIGNATURE_PROBE_WORD))
-    return (-2);
-  }
-  DBG_TRC (("DSP[%d] present", dsp))
-  return (0);
-}
-/*
-**  Check if DSP's are present and operating
-**  Information about detected DSP's is returned as bit mask
-**  Bit 0  - DSP1
-**  ...
-**  ...
-**  ...
-**  Bit 29 - DSP30
-*/
-static dword
-diva_pri_detect_dsps (PISDN_ADAPTER IoAdapter)
-{
-  byte* base;
-  byte* p;
-  dword ret = 0, DspCount = 0 ;
-  dword row_offset[] = {
-    0x00000000,
-    0x00000800, /* 1 - ROW 1 */
-    0x00000840, /* 2 - ROW 2 */
-    0x00001000, /* 3 - ROW 3 */
-    0x00001040, /* 4 - ROW 4 */
-    0x00000000  /* 5 - ROW 0 */
-  };
-  byte *dsp_addr_port, *dsp_data_port, row_state;
-  int dsp_row = 0, dsp_index, dsp_num;
- IoAdapter->InitialDspInfo &= 0xffff ;
- p = DIVA_OS_MEM_ATTACH_RESET(IoAdapter);
-  if (!p)
-  {
-    DIVA_OS_MEM_DETACH_RESET(IoAdapter, p);
-    return (0);
-  }
-  *(volatile byte*)(p) = _MP_RISC_RESET | _MP_DSP_RESET;
-  DIVA_OS_MEM_DETACH_RESET(IoAdapter, p);
-  diva_os_wait (5) ;
-
-  base = DIVA_OS_MEM_ATTACH_CONTROL(IoAdapter);
-  
-  for (dsp_num = 0; dsp_num < 30; dsp_num++) {
-    dsp_row   = dsp_num / 7 + 1;
-    dsp_index = dsp_num % 7;
-    dsp_data_port = base;
-    dsp_addr_port = base;
-    dsp_data_port += row_offset[dsp_row];
-    dsp_addr_port += row_offset[dsp_row];
-    dsp_data_port += (dsp_index * 8);
-    dsp_addr_port += (dsp_index * 8) + 0x80;
-    if (!dsp_check_presence (dsp_addr_port, dsp_data_port, dsp_num+1)) {
-      ret |= (1 << dsp_num);
-   DspCount++ ;
-    }
-  }
-  DIVA_OS_MEM_DETACH_CONTROL(IoAdapter, base);
-
-  p = DIVA_OS_MEM_ATTACH_RESET(IoAdapter);
-  *(volatile byte*)(p) = _MP_RISC_RESET | _MP_LED1 | _MP_LED2;
-  diva_os_wait (50) ;
-  /*
-    Verify modules
-  */
-  for (dsp_row = 0; dsp_row < 4; dsp_row++) {
-    row_state = (byte)((ret >> (dsp_row*7)) & 0x7F);
-    if (row_state && (row_state != 0x7F)) {
-      for (dsp_index = 0; dsp_index < 7; dsp_index++) {
-        if (!(row_state & (1 << dsp_index))) {
-          DBG_ERR (("A: MODULE[%d]-DSP[%d] failed", dsp_row+1, dsp_index+1))
-        }
-      }
-    }
-  }
-  if (!(ret & 0x10000000)) {
-    DBG_ERR (("A: ON BOARD-DSP[1] failed"))
-  }
-  if (!(ret & 0x20000000)) {
-    DBG_ERR (("A: ON BOARD-DSP[2] failed"))
-  }
-  /*
-    Print module population now
-  */
-  DBG_LOG(("+-----------------------+"))
-  DBG_LOG(("| DSP MODULE POPULATION |"))
-  DBG_LOG(("+-----------------------+"))
-  DBG_LOG(("|  1  |  2  |  3  |  4  |"))
-  DBG_LOG(("+-----------------------+"))
-  DBG_LOG(("|  %s  |  %s  |  %s  |  %s  |",
-    ((ret >> (0*7)) & 0x7F) ? "Y" : "N",
-    ((ret >> (1*7)) & 0x7F) ? "Y" : "N",
-    ((ret >> (2*7)) & 0x7F) ? "Y" : "N",
-    ((ret >> (3*7)) & 0x7F) ? "Y" : "N"))
-  DBG_LOG(("+-----------------------+"))
-  DBG_LOG(("DSP's(present-absent):%08x-%08x", ret, ~ret & 0x3fffffff))
-  *(volatile byte*)(p) = 0 ;
-  DIVA_OS_MEM_DETACH_RESET(IoAdapter, p);
-  diva_os_wait (50) ;
- IoAdapter->InitialDspInfo |= DspCount << 16 ;
-  return (ret);
-}
-/* -------------------------------------------------------------------------
-  helper used to download dsp code toi PRI Card
-  ------------------------------------------------------------------------- */
-static long pri_download_buffer (OsFileHandle *fp, long length, void **addr) {
- PISDN_ADAPTER IoAdapter = (PISDN_ADAPTER)fp->sysLoadDesc ;
- dword        *sharedRam ;
- byte *p;
- *addr = (void *)IoAdapter->downloadAddr ;
- if ( ((dword) length) > IoAdapter->DspCodeBaseAddr +
-                         IoAdapter->MaxDspCodeSize - IoAdapter->downloadAddr )
- {
-  DBG_FTL(("%s: out of card memory during DSP download (0x%X)",
-           IoAdapter->Properties.Name,
-           IoAdapter->downloadAddr + length))
-  return (-1) ;
- }
- p = DIVA_OS_MEM_ATTACH_RAM(IoAdapter);
- sharedRam = (dword *)(&p[DOWNLOAD_ADDR(IoAdapter)]);
- if ( fp->sysFileRead (fp, sharedRam, length) != length ) {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
-  return (-1) ;
- }
- IoAdapter->downloadAddr += length ;
- IoAdapter->downloadAddr  = (IoAdapter->downloadAddr + 3) & (~3) ;
- DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
- return (0) ;
-}
-/* -------------------------------------------------------------------------
-  Download DSP code to PRI Card
-  ------------------------------------------------------------------------- */
-static dword pri_telindus_load (PISDN_ADAPTER IoAdapter) {
- char                *error ;
- OsFileHandle        *fp ;
- t_dsp_portable_desc  download_table[DSP_MAX_DOWNLOAD_COUNT] ;
- word                 download_count ;
- dword               *sharedRam ;
- dword                FileLength ;
- byte *p;
- if ( !(fp = OsOpenFile (DSP_TELINDUS_FILE)) )
-  return (0) ;
- IoAdapter->downloadAddr = (IoAdapter->DspCodeBaseAddr
-                         + sizeof(dword) + sizeof(download_table) + 3) & (~3) ;
- FileLength      = fp->sysFileSize ;
- fp->sysLoadDesc = (void *)IoAdapter ;
- fp->sysCardLoad = pri_download_buffer ;
- download_count = DSP_MAX_DOWNLOAD_COUNT ;
- memset (&download_table[0], '\0', sizeof(download_table)) ;
-/*
- * set start address for download (use autoincrement mode !)
- */
- error = dsp_read_file (fp, (word)(IoAdapter->cardType),
-                        &download_count, NULL, &download_table[0]) ;
- if ( error )
- {
-  DBG_FTL(("download file error: %s", error))
-  OsCloseFile (fp) ;
-  return (0) ;
- }
- OsCloseFile (fp) ;
-/*
- * store # of separate download files extracted from archive
- */
- IoAdapter->downloadAddr = IoAdapter->DspCodeBaseAddr ;
- p = DIVA_OS_MEM_ATTACH_RAM(IoAdapter);
- sharedRam = (dword *)(&p[DOWNLOAD_ADDR(IoAdapter)]);
- WRITE_DWORD(&(sharedRam[0]), (dword)download_count);
- memcpy (&sharedRam[1], &download_table[0], sizeof(download_table)) ;
- DIVA_OS_MEM_DETACH_RAM(IoAdapter, p);
- return (FileLength) ;
-}
-/* -------------------------------------------------------------------------
-  Download PRI Card
-  ------------------------------------------------------------------------- */
-#define MIN_DSPS 0x30000000
-static int load_pri_hardware (PISDN_ADAPTER IoAdapter) {
- dword           i ;
- struct mp_load *boot = (struct mp_load *)DIVA_OS_MEM_ATTACH_RAM(IoAdapter);
- if ( IoAdapter->Properties.Card != CARD_MAEP ) {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-  return (0) ;
- }
- boot->err = 0 ;
-#if 0
- IoAdapter->rstFnc (IoAdapter) ;
-#else
- if ( MIN_DSPS != (MIN_DSPS & diva_pri_detect_dsps(IoAdapter)) ) { /* makes reset */
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-  DBG_FTL(("%s: DSP error!", IoAdapter->Properties.Name))
-  return (0) ;
- }
-#endif
-/*
- * check if CPU is alive
- */
- diva_os_wait (10) ;
- i = boot->live ;
- diva_os_wait (10) ;
- if ( i == boot->live )
- {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-  DBG_FTL(("%s: CPU is not alive!", IoAdapter->Properties.Name))
-  return (0) ;
- }
- if ( boot->err )
- {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-  DBG_FTL(("%s: Board Selftest failed!", IoAdapter->Properties.Name))
-  return (0) ;
- }
-/*
- * download protocol and dsp files
- */
- if ( !xdiSetProtocol (IoAdapter, IoAdapter->ProtocolSuffix) ) {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-  return (0) ;
- }
- if ( !pri_protocol_load (IoAdapter) ) {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-  return (0) ;
- }
- if ( !pri_telindus_load (IoAdapter) ) {
-  DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-  return (0) ;
- }
-/*
- * copy configuration parameters
- */
- IoAdapter->ram += MP_SHARED_RAM_OFFSET ;
- memset (boot + MP_SHARED_RAM_OFFSET, '\0', 256) ;
- diva_configure_protocol (IoAdapter);
-/*
- * start adapter
- */
- boot->addr = MP_UNCACHED_ADDR (MP_PROTOCOL_OFFSET) ;
- boot->cmd  = 3 ;
-/*
- * wait for signature in shared memory (max. 3 seconds)
- */
- for ( i = 0 ; i < 300 ; ++i )
- {
-  diva_os_wait (10) ;
-  if ( (boot->signature >> 16) == 0x4447 )
-  {
-   DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
-   DBG_TRC(("Protocol startup time %d.%02d seconds",
-            (i / 100), (i % 100) ))
-   return (1) ;
-  }
- }
- DIVA_OS_MEM_DETACH_RAM(IoAdapter, boot);
- DBG_FTL(("%s: Adapter selftest failed (0x%04X)!",
-          IoAdapter->Properties.Name, boot->signature >> 16))
- pri_cpu_trapped (IoAdapter) ;
- return (0) ;
-}
-#else /* } { */
 static int load_pri_hardware (PISDN_ADAPTER IoAdapter) {
  return (0);
 }
-#endif /* } */
 /* --------------------------------------------------------------------------
   PRI Adapter interrupt Service Routine
    -------------------------------------------------------------------------- */
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/icn/icn.h linux-2.6.11-rc3/drivers/isdn/icn/icn.h
--- linux-2.6.11-rc2-bk10/drivers/isdn/icn/icn.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/icn/icn.h	2005-02-03 02:57:04.000000000 +0100
@@ -174,7 +174,7 @@ typedef struct icn_card {
 typedef struct icn_dev {
 	spinlock_t devlock;     /* spinlock to protect this struct  */
 	unsigned long memaddr;	/* Address of memory mapped buffers */
-	icn_shmem *shmem;       /* Pointer to memory-mapped-buffers */
+	icn_shmem __iomem *shmem;       /* Pointer to memory-mapped-buffers */
 	int mvalid;             /* IO-shmem has been requested      */
 	int channel;            /* Currently mapped channel         */
 	struct icn_card *mcard; /* Currently mapped card            */
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/pcbit/drv.c linux-2.6.11-rc3/drivers/isdn/pcbit/drv.c
--- linux-2.6.11-rc2-bk10/drivers/isdn/pcbit/drv.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/pcbit/drv.c	2005-02-03 02:56:22.000000000 +0100
@@ -96,7 +96,7 @@ int pcbit_init_dev(int board, int mem_ba
 			dev_pcbit[board] = NULL;
 			return -EACCES;
 		}
-		dev->sh_mem = (unsigned char*)ioremap(dev->ph_mem, 4096);
+		dev->sh_mem = ioremap(dev->ph_mem, 4096);
 	}
 	else 
 	{
@@ -109,7 +109,7 @@ int pcbit_init_dev(int board, int mem_ba
 	dev->b1 = kmalloc(sizeof(struct pcbit_chan), GFP_KERNEL);
 	if (!dev->b1) {
 		printk("pcbit_init: couldn't malloc pcbit_chan struct\n");
-		iounmap((unsigned char*)dev->sh_mem);
+		iounmap(dev->sh_mem);
 		release_mem_region(dev->ph_mem, 4096);
 		kfree(dev);
 		return -ENOMEM;
@@ -119,7 +119,7 @@ int pcbit_init_dev(int board, int mem_ba
 	if (!dev->b2) {
 		printk("pcbit_init: couldn't malloc pcbit_chan struct\n");
 		kfree(dev->b1);
-		iounmap((unsigned char*)dev->sh_mem);
+		iounmap(dev->sh_mem);
 		release_mem_region(dev->ph_mem, 4096);
 		kfree(dev);
 		return -ENOMEM;
@@ -139,7 +139,7 @@ int pcbit_init_dev(int board, int mem_ba
 	{
 		kfree(dev->b1);
 		kfree(dev->b2);
-		iounmap((unsigned char*)dev->sh_mem);
+		iounmap(dev->sh_mem);
 		release_mem_region(dev->ph_mem, 4096);
 		kfree(dev);
 		dev_pcbit[board] = NULL;
@@ -161,7 +161,7 @@ int pcbit_init_dev(int board, int mem_ba
 		free_irq(irq, dev);
 		kfree(dev->b1);
 		kfree(dev->b2);
-		iounmap((unsigned char*)dev->sh_mem);
+		iounmap(dev->sh_mem);
 		release_mem_region(dev->ph_mem, 4096);
 		kfree(dev);
 		dev_pcbit[board] = NULL;
@@ -193,7 +193,7 @@ int pcbit_init_dev(int board, int mem_ba
 		free_irq(irq, dev);
 		kfree(dev->b1);
 		kfree(dev->b2);
-		iounmap((unsigned char*)dev->sh_mem);
+		iounmap(dev->sh_mem);
 		release_mem_region(dev->ph_mem, 4096);
 		kfree(dev);
 		dev_pcbit[board] = NULL;
@@ -231,7 +231,7 @@ void pcbit_terminate(int board)
 			del_timer(&dev->b2->fsm_timer);
 		kfree(dev->b1);
 		kfree(dev->b2);
-		iounmap((unsigned char*)dev->sh_mem);
+		iounmap(dev->sh_mem);
 		release_mem_region(dev->ph_mem, 4096);
 		kfree(dev);
 	}
diff -purN linux-2.6.11-rc2-bk10/drivers/isdn/pcbit/pcbit.h linux-2.6.11-rc3/drivers/isdn/pcbit/pcbit.h
--- linux-2.6.11-rc2-bk10/drivers/isdn/pcbit/pcbit.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/drivers/isdn/pcbit/pcbit.h	2005-02-03 02:55:07.000000000 +0100
@@ -45,7 +45,7 @@ struct msn_entry {
 struct pcbit_dev {
 	/* board */
 
-	volatile unsigned char* sh_mem;		/* RDP address	*/
+	volatile unsigned char __iomem *sh_mem;		/* RDP address	*/
 	unsigned long ph_mem;
 	unsigned int irq;
 	unsigned int id;
@@ -79,8 +79,8 @@ struct pcbit_dev {
 	u_char w_busy;
 	u_char r_busy;
 
-	volatile unsigned char *readptr;
-	volatile unsigned char *writeptr;
+	volatile unsigned char __iomem *readptr;
+	volatile unsigned char __iomem *writeptr;
 
 	ushort loadptr;
 
diff -purN linux-2.6.11-rc2-bk10/drivers/macintosh/via-pmu.c linux-2.6.11-rc3/drivers/macintosh/via-pmu.c
--- linux-2.6.11-rc2-bk10/drivers/macintosh/via-pmu.c	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc3/drivers/macintosh/via-pmu.c	2005-02-03 02:56:48.000000000 +0100
@@ -45,6 +45,7 @@
 #include <linux/device.h>
 #include <linux/suspend.h>
 #include <linux/syscalls.h>
+#include <linux/cpu.h>
 #include <asm/prom.h>
 #include <asm/machdep.h>
 #include <asm/io.h>
@@ -152,7 +153,6 @@ static int drop_interrupts;
 #ifdef CONFIG_PMAC_PBOOK
 static int option_lid_wakeup = 1;
 static int sleep_in_progress;
-static int can_sleep;
 #endif /* CONFIG_PMAC_PBOOK */
 static unsigned long async_req_locks;
 static unsigned int pmu_irq_stats[11];
@@ -406,8 +406,6 @@ static int __init via_pmu_start(void)
 	bright_req_2.complete = 1;
 #ifdef CONFIG_PMAC_PBOOK
 	batt_req.complete = 1;
-	if (pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) >= 0)
-		can_sleep = 1;
 #endif
 
 	if (request_irq(vias->intrs[0].line, via_pmu_interrupt, 0, "VIA-PMU",
@@ -885,7 +883,8 @@ proc_read_options(char *page, char **sta
 	char *p = page;
 
 #ifdef CONFIG_PMAC_PBOOK
-	if (pmu_kind == PMU_KEYLARGO_BASED && can_sleep)
+	if (pmu_kind == PMU_KEYLARGO_BASED &&
+	    pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) >= 0)
 		p += sprintf(p, "lid_wakeup=%d\n", option_lid_wakeup);
 #endif /* CONFIG_PMAC_PBOOK */
 	if (pmu_kind == PMU_KEYLARGO_BASED)
@@ -925,7 +924,8 @@ proc_write_options(struct file *file, co
 	while(*val == ' ')
 		val++;
 #ifdef CONFIG_PMAC_PBOOK
-	if (pmu_kind == PMU_KEYLARGO_BASED && can_sleep)
+	if (pmu_kind == PMU_KEYLARGO_BASED &&
+	    pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) >= 0)
 		if (!strcmp(label, "lid_wakeup"))
 			option_lid_wakeup = ((*val) == '1');
 #endif /* CONFIG_PMAC_PBOOK */
@@ -2313,7 +2313,7 @@ static int __pmac
 pmac_suspend_devices(void)
 {
 	int ret;
-	
+
 	pm_prepare_console();
 	
 	/* Notify old-style device drivers & userland */
@@ -2341,13 +2341,13 @@ pmac_suspend_devices(void)
 	/* Send suspend call to devices, hold the device core's dpm_sem */
 	ret = device_suspend(PM_SUSPEND_MEM);
 	if (ret) {
-		printk(KERN_ERR "Driver sleep failed\n");
 		broadcast_wake();
+		printk(KERN_ERR "Driver sleep failed\n");
 		return -EBUSY;
 	}
-	
+
 	preempt_disable();
-	
+
 	/* Make sure the decrementer won't interrupt us */
 	asm volatile("mtdec %0" : : "r" (0x7fffffff));
 	/* Make sure any pending DEC interrupt occurring while we did
@@ -2404,8 +2404,6 @@ pmac_wakeup_devices(void)
 	/* Power back up system devices (including the PIC) */
 	device_power_up();
 
-	pmu_blink(1);
-
 	/* Force a poll of ADB interrupts */
 	adb_int_pending = 1;
 	via_pmu_interrupt(0, NULL, NULL);
@@ -2416,7 +2414,7 @@ pmac_wakeup_devices(void)
 	/* Re-enable local CPU interrupts */
 	local_irq_enable();
 
-	pmu_blink(1);
+	mdelay(100);
 
 	preempt_enable();
 
@@ -2464,8 +2462,6 @@ powerbook_sleep_grackle(void)
 
 	/* For 750, save backside cache setting and disable it */
 	save_l2cr = _get_L2CR();	/* (returns -1 if not available) */
-	if (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)
-		_set_L2CR(save_l2cr & 0x7fffffff);
 
 	if (!__fake_sleep) {
 		/* Ask the PMU to put us to sleep */
@@ -2530,17 +2526,22 @@ powerbook_sleep_Core99(void)
 	struct adb_request req;
 	int ret;
 	
-	if (!can_sleep) {
+	if (pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) < 0) {
 		printk(KERN_ERR "Sleep mode not supported on this machine\n");
 		return -ENOSYS;
 	}
-	
+
+	if (num_online_cpus() > 1 || cpu_is_offline(0))
+		return -EAGAIN;
+
 	ret = pmac_suspend_devices();
 	if (ret) {
 		printk(KERN_ERR "Sleep rejected by devices\n");
 		return ret;
 	}
-	
+
+	printk(KERN_DEBUG "HID1, before: %x\n", mfspr(SPRN_HID1));
+
 	/* Tell PMU what events will wake us up */
 	pmu_request(&req, NULL, 4, PMU_POWER_EVENTS, PMU_PWR_CLR_WAKEUP_EVENTS,
 		0xff, 0xff);
@@ -2550,16 +2551,9 @@ powerbook_sleep_Core99(void)
 		(option_lid_wakeup ? PMU_PWR_WAKEUP_LID_OPEN : 0));
 	pmu_wait_complete(&req);
 
-	/* Save & disable L2 and L3 caches*/
+	/* Save the state of the L2 and L3 caches */
 	save_l3cr = _get_L3CR();	/* (returns -1 if not available) */
 	save_l2cr = _get_L2CR();	/* (returns -1 if not available) */
-	if (save_l3cr != 0xffffffff && (save_l3cr & L3CR_L3E) != 0)
-		_set_L3CR(save_l3cr & 0x7fffffff);
-	if (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)
-		_set_L2CR(save_l2cr & 0x7fffffff);
-
-	/* Save the state of PCI config space for some slots */
-	//pbook_pci_save();
 
 	if (!__fake_sleep) {
 		/* Ask the PMU to put us to sleep */
@@ -2574,7 +2568,7 @@ powerbook_sleep_Core99(void)
 	 * talk to the PMU after this, so I moved it to _after_ sending the
 	 * sleep command to it. Still need to be checked.
 	 */
-	pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,1);
+	pmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 1);
 
 	/* Call low-level ASM sleep handler */
 	if (__fake_sleep)
@@ -2583,18 +2577,13 @@ powerbook_sleep_Core99(void)
 		low_sleep_handler();
 
 	/* Restore Apple core ASICs state */
-	pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,0);
+	pmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 0);
 
 	/* Restore VIA */
 	restore_via_state();
 
-	/* Restore PCI config space. This should be overridable by PCI device
-	 * drivers as some of them may need special restore code. That's yet
-	 * another issue that should be handled by the common code properly,
-	 * maybe one day ?
-	 */
-	/* Don't restore PCI for now, it crashes. Maybe unnecessary on pbook */
-	//pbook_pci_restore();
+	/* Restore video */
+	pmac_call_early_video_resume();
 
 	/* Restore L2 cache */
 	if (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)
@@ -2613,7 +2602,7 @@ powerbook_sleep_Core99(void)
 	pmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);
 	pmu_wait_complete(&req);
 
-	pmu_blink(1);
+	printk(KERN_DEBUG "HID1, after: %x\n", mfspr(SPRN_HID1));
 
 	pmac_wakeup_devices();
 
@@ -2909,7 +2898,10 @@ pmu_ioctl(struct inode * inode, struct f
 		sleep_in_progress = 0;
 		return error;
 	case PMU_IOC_CAN_SLEEP:
-		return put_user((u32)can_sleep, argp);
+		if (pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) < 0)
+			return put_user(0, argp);
+		else
+			return put_user(1, argp);
 
 #ifdef CONFIG_PMAC_BACKLIGHT
 	/* Backlight should have its own device or go via
diff -purN linux-2.6.11-rc2-bk10/drivers/md/raid5.c linux-2.6.11-rc3/drivers/md/raid5.c
--- linux-2.6.11-rc2-bk10/drivers/md/raid5.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/drivers/md/raid5.c	2005-02-03 02:55:15.000000000 +0100
@@ -56,7 +56,7 @@
 #define RAID5_DEBUG	0
 #define RAID5_PARANOIA	1
 #if RAID5_PARANOIA && defined(CONFIG_SMP)
-# define CHECK_DEVLOCK() if (!spin_is_locked(&conf->device_lock)) BUG()
+# define CHECK_DEVLOCK() assert_spin_locked(&conf->device_lock)
 #else
 # define CHECK_DEVLOCK()
 #endif
diff -purN linux-2.6.11-rc2-bk10/drivers/md/raid6main.c linux-2.6.11-rc3/drivers/md/raid6main.c
--- linux-2.6.11-rc2-bk10/drivers/md/raid6main.c	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc3/drivers/md/raid6main.c	2005-02-03 02:54:52.000000000 +0100
@@ -62,7 +62,7 @@
 #define RAID6_PARANOIA	1	/* Check spinlocks */
 #define RAID6_DUMPSTATE 0	/* Include stripe cache state in /proc/mdstat */
 #if RAID6_PARANOIA && defined(CONFIG_SMP)
-# define CHECK_DEVLOCK() if (!spin_is_locked(&conf->device_lock)) BUG()
+# define CHECK_DEVLOCK() assert_spin_locked(&conf->device_lock)
 #else
 # define CHECK_DEVLOCK()
 #endif
diff -purN linux-2.6.11-rc2-bk10/drivers/media/common/saa7146_fops.c linux-2.6.11-rc3/drivers/media/common/saa7146_fops.c
--- linux-2.6.11-rc2-bk10/drivers/media/common/saa7146_fops.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/drivers/media/common/saa7146_fops.c	2005-02-03 02:55:52.000000000 +0100
@@ -73,9 +73,7 @@ int saa7146_buffer_queue(struct saa7146_
 			 struct saa7146_dmaqueue *q,
 			 struct saa7146_buf *buf)
 {
-#ifdef DEBUG_SPINLOCKS
-	BUG_ON(!spin_is_locked(&dev->slock));
-#endif
+	assert_spin_locked(&dev->slock);
 	DEB_EE(("dev:%p, dmaq:%p, buf:%p\n", dev, q, buf));
 
 	BUG_ON(!q);
@@ -96,9 +94,7 @@ void saa7146_buffer_finish(struct saa714
 			   struct saa7146_dmaqueue *q,
 			   int state)
 {
-#ifdef DEBUG_SPINLOCKS
-	BUG_ON(!spin_is_locked(&dev->slock));
-#endif
+	assert_spin_locked(&dev->slock);
 	DEB_EE(("dev:%p, dmaq:%p, state:%d\n", dev, q, state));
 	DEB_EE(("q->curr:%p\n",q->curr));
 
@@ -126,9 +122,7 @@ void saa7146_buffer_next(struct saa7146_
 
 	DEB_INT(("dev:%p, dmaq:%p, vbi:%d\n", dev, q, vbi));
 
-#ifdef DEBUG_SPINLOCKS
-	BUG_ON(!spin_is_locked(&dev->slock));
-#endif
+	assert_spin_locked(&dev->slock);
 	if (!list_empty(&q->queue)) {
 		/* activate next one from queue */
 		buf = list_entry(q->queue.next,struct saa7146_buf,vb.queue);
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/dibusb/dvb-dibusb-core.c linux-2.6.11-rc3/drivers/media/dvb/dibusb/dvb-dibusb-core.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/dibusb/dvb-dibusb-core.c	2005-02-03 10:03:09.279456898 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/dibusb/dvb-dibusb-core.c	2005-02-03 02:54:38.000000000 +0100
@@ -363,8 +363,8 @@ static struct dibusb_usb_device * dibusb
 	for (i = 0; i < sizeof(dibusb_devices)/sizeof(struct dibusb_usb_device); i++) {
 		for (j = 0; j < DIBUSB_ID_MAX_NUM && dibusb_devices[i].cold_ids[j] != NULL; j++) {
 			deb_info("check for cold %x %x\n",dibusb_devices[i].cold_ids[j]->idVendor, dibusb_devices[i].cold_ids[j]->idProduct);
-			if (dibusb_devices[i].cold_ids[j]->idVendor == udev->descriptor.idVendor &&
-				dibusb_devices[i].cold_ids[j]->idProduct == udev->descriptor.idProduct) {
+			if (dibusb_devices[i].cold_ids[j]->idVendor == le16_to_cpu(udev->descriptor.idVendor) &&
+				dibusb_devices[i].cold_ids[j]->idProduct == le16_to_cpu(udev->descriptor.idProduct)) {
 				*cold = 1;
 				return &dibusb_devices[i];
 			}
@@ -372,8 +372,8 @@ static struct dibusb_usb_device * dibusb
 
 		for (j = 0; j < DIBUSB_ID_MAX_NUM && dibusb_devices[i].warm_ids[j] != NULL; j++) {
 			deb_info("check for warm %x %x\n",dibusb_devices[i].warm_ids[j]->idVendor, dibusb_devices[i].warm_ids[j]->idProduct);
-			if (dibusb_devices[i].warm_ids[j]->idVendor == udev->descriptor.idVendor &&
-				dibusb_devices[i].warm_ids[j]->idProduct == udev->descriptor.idProduct) {
+			if (dibusb_devices[i].warm_ids[j]->idVendor == le16_to_cpu(udev->descriptor.idVendor) &&
+				dibusb_devices[i].warm_ids[j]->idProduct == le16_to_cpu(udev->descriptor.idProduct)) {
 				*cold = 0;
 				return &dibusb_devices[i];
 			}
@@ -396,7 +396,7 @@ static int dibusb_probe(struct usb_inter
 
 	if ((dibdev = dibusb_find_device(udev,&cold)) == NULL) {
 		err("something went very wrong, "
-				"unknown product ID: %.4x",udev->descriptor.idProduct);
+				"unknown product ID: %.4x",le16_to_cpu(udev->descriptor.idProduct));
 		return -ENODEV;
 	}
 	
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/dvb-core/dvb_frontend.c linux-2.6.11-rc3/drivers/media/dvb/dvb-core/dvb_frontend.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/dvb-core/dvb_frontend.c	2005-02-03 10:03:09.333448497 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/dvb-core/dvb_frontend.c	2005-02-03 02:55:22.000000000 +0100
@@ -912,8 +912,9 @@ int dvb_unregister_frontend(struct dvb_f
 		fe->ops->release(fe);
 	else
 		printk("dvb_frontend: Demodulator (%s) does not have a release callback!\n", fe->ops->info.name);
-	if (fe->frontend_priv)
-		kfree(fe->frontend_priv);
+	/* fe is invalid now */
+	if (fepriv)
+		kfree(fepriv);
 	up (&frontend_mutex);
 	return 0;
 }
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/dvb-core/dvbdev.c linux-2.6.11-rc3/drivers/media/dvb/dvb-core/dvbdev.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/dvb-core/dvbdev.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/dvb-core/dvbdev.c	2005-02-03 02:55:15.000000000 +0100
@@ -31,6 +31,8 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
 
 #include "dvbdev.h"
 
@@ -50,8 +52,9 @@ static const char * const dnames[] = {
 };
 
 
-#define DVB_MAX_IDS              4
+#define DVB_MAX_IDS              6
 #define nums2minor(num,type,id)  ((num << 6) | (id << 4) | type)
+#define MAX_DVB_MINORS           (DVB_MAX_IDS*64)
 
 struct class_simple *dvb_class;
 EXPORT_SYMBOL(dvb_class);
@@ -109,6 +112,11 @@ static struct file_operations dvb_device
 };
 
 
+static struct cdev dvb_device_cdev = {
+	.kobj   = {.name = "dvb", },
+	.owner  =       THIS_MODULE,
+};
+
 int dvb_generic_open(struct inode *inode, struct file *file)
 {
         struct dvb_device *dvbdev = file->private_data;
@@ -400,25 +408,41 @@ out:
 static int __init init_dvbdev(void)
 {
 	int retval;
+	dev_t dev = MKDEV(DVB_MAJOR, 0);
+
+	if ((retval = register_chrdev_region(dev, MAX_DVB_MINORS, "DVB")) != 0) {
+		printk("dvb-core: unable to get major %d\n", DVB_MAJOR);
+		return retval;
+	}
 
-	if ((retval = register_chrdev(DVB_MAJOR,"DVB", &dvb_device_fops)))
+	cdev_init(&dvb_device_cdev, &dvb_device_fops);
+	if ((retval = cdev_add(&dvb_device_cdev, dev, MAX_DVB_MINORS)) != 0) {
 		printk("dvb-core: unable to get major %d\n", DVB_MAJOR);
+		goto error;
+	}
 
 	devfs_mk_dir("dvb");
 
 	dvb_class = class_simple_create(THIS_MODULE, "dvb");
-	if (IS_ERR(dvb_class))
-		return PTR_ERR(dvb_class);
+	if (IS_ERR(dvb_class)) {
+		retval = PTR_ERR(dvb_class);
+		goto error;
+	}
+	return 0;
 
+error:
+	cdev_del(&dvb_device_cdev);
+	unregister_chrdev_region(dev, MAX_DVB_MINORS);
 	return retval;
 }
 
 
 static void __exit exit_dvbdev(void)
 {
-	unregister_chrdev(DVB_MAJOR, "DVB");
         devfs_remove("dvb");
 	class_simple_destroy(dvb_class);
+	cdev_del(&dvb_device_cdev);
+        unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
 }
 
 module_init(init_dvbdev);
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/cx22700.c linux-2.6.11-rc3/drivers/media/dvb/frontends/cx22700.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/cx22700.c	2005-01-22 02:49:12.000000000 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/frontends/cx22700.c	2005-02-03 02:56:53.000000000 +0100
@@ -1,4 +1,4 @@
-#/*
+/*
     Conexant cx22700 DVB OFDM demodulator driver
 
     Copyright (C) 2001-2002 Convergence Integrated Media GmbH
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/dib3000-common.h linux-2.6.11-rc3/drivers/media/dvb/frontends/dib3000-common.h
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/dib3000-common.h	2005-02-03 10:03:09.342447096 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/frontends/dib3000-common.h	2005-02-03 02:55:23.000000000 +0100
@@ -65,7 +65,7 @@ extern int dib3000_search_status(u16 irq
 
 #define wr_foreach(a,v) { int i; \
 	if (sizeof(a) != sizeof(v)) \
-		err("sizeof: %d %d is different",sizeof(a),sizeof(v));\
+		err("sizeof: %zu %zu is different",sizeof(a),sizeof(v));\
 	for (i=0; i < sizeof(a)/sizeof(u16); i++) \
 		wr(a[i],v[i]); \
 	}
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/nxt2002.c linux-2.6.11-rc3/drivers/media/dvb/frontends/nxt2002.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/nxt2002.c	2005-02-03 10:03:09.370442740 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/frontends/nxt2002.c	2005-02-03 02:56:21.000000000 +0100
@@ -246,7 +246,7 @@ static int nxt2002_load_firmware (struct
 	u16 rambase,position,crc = 0;  
 
 	dprintk("%s\n", __FUNCTION__);
-	dprintk("Firmware is %d bytes\n",fw->size);
+	dprintk("Firmware is %zu bytes\n",fw->size);
 
 	/* Get the RAM base for this nxt2002 */
 	i2c_readbytes(state,0x10,buf,1);
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/sp8870.c linux-2.6.11-rc3/drivers/media/dvb/frontends/sp8870.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/sp8870.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/frontends/sp8870.c	2005-02-03 02:57:04.000000000 +0100
@@ -313,7 +313,7 @@ static int sp8870_init (struct dvb_front
 
 
 	/* request the firmware, this will block until someone uploads it */
-	printk("sp8870: waiting for firmware upload...\n");
+	printk("sp8870: waiting for firmware upload (%s)...\n", SP8870_DEFAULT_FIRMWARE);
 	if (state->config->request_firmware(fe, &fw, SP8870_DEFAULT_FIRMWARE)) {
 		printk("sp8870: no firmware upload (timeout or file not found?)\n");
 		release_firmware(fw);
@@ -325,6 +325,7 @@ static int sp8870_init (struct dvb_front
 		release_firmware(fw);
 		return -EIO;
 	}
+	printk("sp8870: firmware upload complete\n");
 
 	/* enable TS output and interface pins */
 	sp8870_writereg(state, 0xc18, 0x00d);
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/sp887x.c linux-2.6.11-rc3/drivers/media/dvb/frontends/sp887x.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/sp887x.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/frontends/sp887x.c	2005-02-03 02:56:33.000000000 +0100
@@ -518,7 +518,7 @@ static int sp887x_init(struct dvb_fronte
 
 	if (!state->initialised) {
 	/* request the firmware, this will block until someone uploads it */
-	printk("sp887x: waiting for firmware upload...\n");
+		printk("sp887x: waiting for firmware upload (%s)...\n", SP887X_DEFAULT_FIRMWARE);
 		ret = state->config->request_firmware(fe, &fw, SP887X_DEFAULT_FIRMWARE);
 	if (ret) {
 		printk("sp887x: no firmware upload (timeout or file not found?)\n");
@@ -531,6 +531,7 @@ static int sp887x_init(struct dvb_fronte
 			release_firmware(fw);
 			return ret;
 	}
+		printk("sp887x: firmware upload complete\n");
 		state->initialised = 1;
 	}
 
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/tda80xx.c linux-2.6.11-rc3/drivers/media/dvb/frontends/tda80xx.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/frontends/tda80xx.c	2005-02-03 10:03:09.380441184 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/frontends/tda80xx.c	2005-02-03 02:56:22.000000000 +0100
@@ -27,7 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/threads.h>
 #include <linux/interrupt.h>
-#include <linux/irq.h>
+#include <asm/irq.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
diff -purN linux-2.6.11-rc2-bk10/drivers/media/dvb/ttpci/av7110_hw.c linux-2.6.11-rc3/drivers/media/dvb/ttpci/av7110_hw.c
--- linux-2.6.11-rc2-bk10/drivers/media/dvb/ttpci/av7110_hw.c	2005-02-03 10:03:09.402437762 +0100
+++ linux-2.6.11-rc3/drivers/media/dvb/ttpci/av7110_hw.c	2005-02-03 02:56:21.000000000 +0100
@@ -1051,7 +1051,7 @@ int av7110_osd_cmd(struct av7110 *av7110
 			goto out;
 		} else {
 			int i, len = dc->x0-dc->color+1;
-			u8 __user *colors = (u8 *)dc->data;
+			u8 __user *colors = (u8 __user *)dc->data;
 			u8 r, g, b, blend;
 
 			for (i = 0; i<len; i++) {
diff -purN linux-2.6.11-rc2-bk10/drivers/media/video/saa7134/saa7134-core.c linux-2.6.11-rc3/drivers/media/video/saa7134/saa7134-core.c
--- linux-2.6.11-rc2-bk10/drivers/media/video/saa7134/saa7134-core.c	2005-02-03 10:03:09.466427805 +0100
+++ linux-2.6.11-rc3/drivers/media/video/saa7134/saa7134-core.c	2005-02-03 02:55:35.000000000 +0100
@@ -371,10 +371,8 @@ int saa7134_buffer_queue(struct saa7134_
 			 struct saa7134_buf *buf)
 {
 	struct saa7134_buf *next = NULL;
-#ifdef DEBUG_SPINLOCKS
-	BUG_ON(!spin_is_locked(&dev->slock));
-#endif
 
+	assert_spin_locked(&dev->slock);
 	dprintk("buffer_queue %p\n",buf);
 	if (NULL == q->curr) {
 		if (!q->need_two) {
@@ -400,9 +398,7 @@ void saa7134_buffer_finish(struct saa713
 			   struct saa7134_dmaqueue *q,
 			   unsigned int state)
 {
-#ifdef DEBUG_SPINLOCKS
-	BUG_ON(!spin_is_locked(&dev->slock));
-#endif
+	assert_spin_locked(&dev->slock);
 	dprintk("buffer_finish %p\n",q->curr);
 
 	/* finish current buffer */
@@ -417,9 +413,7 @@ void saa7134_buffer_next(struct saa7134_
 {
 	struct saa7134_buf *buf,*next = NULL;
 
-#ifdef DEBUG_SPINLOCKS
-	BUG_ON(!spin_is_locked(&dev->slock));
-#endif
+	assert_spin_locked(&dev->slock);
 	BUG_ON(NULL != q->curr);
 
 	if (!list_empty(&q->queue)) {
@@ -474,9 +468,7 @@ int saa7134_set_dmabits(struct saa7134_d
 	enum v4l2_field cap = V4L2_FIELD_ANY;
 	enum v4l2_field ov  = V4L2_FIELD_ANY;
 
-#ifdef DEBUG_SPINLOCKS
-	BUG_ON(!spin_is_locked(&dev->slock));
-#endif
+	assert_spin_locked(&dev->slock);
 
 	/* video capture -- dma 0 + video task A */
 	if (dev->video_q.curr) {
diff -purN linux-2.6.11-rc2-bk10/drivers/mtd/chips/jedec_probe.c linux-2.6.11-rc3/drivers/mtd/chips/jedec_probe.c
--- linux-2.6.11-rc2-bk10/drivers/mtd/chips/jedec_probe.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/mtd/chips/jedec_probe.c	2005-02-03 02:57:04.000000000 +0100
@@ -1302,7 +1302,7 @@ static const struct amd_flash_info jedec
  		.DevSize	= SIZE_256KiB,
  		.CmdSet		= P_ID_SST_PAGE,
  		.NumEraseRegions= 1,
- 		regions: {ERASEINFO(0x01000,64),
+ 		.regions = {ERASEINFO(0x01000,64),
  		}
          }, {
  		.mfr_id		= MANUFACTURER_SST,
@@ -1314,7 +1314,7 @@ static const struct amd_flash_info jedec
  		.DevSize	= SIZE_256KiB,
  		.CmdSet		= P_ID_SST_PAGE,
  		.NumEraseRegions= 1,
- 		regions: {ERASEINFO(0x01000,64),
+ 		.regions = {ERASEINFO(0x01000,64),
  		}
 	}, {
 		.mfr_id		= MANUFACTURER_SST,
diff -purN linux-2.6.11-rc2-bk10/drivers/mtd/devices/block2mtd.c linux-2.6.11-rc3/drivers/mtd/devices/block2mtd.c
--- linux-2.6.11-rc2-bk10/drivers/mtd/devices/block2mtd.c	2005-01-22 02:46:46.000000000 +0100
+++ linux-2.6.11-rc3/drivers/mtd/devices/block2mtd.c	2005-02-03 02:54:39.000000000 +0100
@@ -422,7 +422,7 @@ static int block2mtd_setup(const char *v
 	char buf[80+12], *str=buf; /* 80 for device, 12 for erase size */
 	char *token[2];
 	char *name;
-	size_t erase_size = PAGE_SIZE;
+	u32 erase_size = PAGE_SIZE;
 	int i, ret;
 
 	if (strnlen(val, sizeof(buf)) >= sizeof(buf))
diff -purN linux-2.6.11-rc2-bk10/drivers/mtd/maps/sun_uflash.c linux-2.6.11-rc3/drivers/mtd/maps/sun_uflash.c
--- linux-2.6.11-rc2-bk10/drivers/mtd/maps/sun_uflash.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/drivers/mtd/maps/sun_uflash.c	2005-02-03 02:56:21.000000000 +0100
@@ -109,7 +109,7 @@ int uflash_devinit(struct linux_ebus_dev
 	/* MTD registration */
 	pdev->mtd = do_map_probe("cfi_probe", &pdev->map);
 	if(0 == pdev->mtd) {
-		iounmap((void *)pdev->map.virt);
+		iounmap(pdev->map.virt);
 		kfree(pdev->name);
 		kfree(pdev);
 		return(-ENXIO);
@@ -163,8 +163,8 @@ static void __exit uflash_cleanup(void)
 			map_destroy(udev->mtd);
 		}
 		if(0 != udev->map.virt) {
-			iounmap((void*)udev->map.virt);
-			udev->map.virt = 0;
+			iounmap(udev->map.virt);
+			udev->map.virt = NULL;
 		}
 		if(0 != udev->name) {
 			kfree(udev->name);
diff -purN linux-2.6.11-rc2-bk10/drivers/net/r8169.c linux-2.6.11-rc3/drivers/net/r8169.c
--- linux-2.6.11-rc2-bk10/drivers/net/r8169.c	2005-01-22 02:48:13.000000000 +0100
+++ linux-2.6.11-rc3/drivers/net/r8169.c	2005-02-03 02:55:52.000000000 +0100
@@ -60,6 +60,7 @@ VERSION 1.6LK	<2004/04/14>
 #include <linux/dma-mapping.h>
 
 #include <asm/io.h>
+#include <asm/irq.h>
 
 #define RTL8169_VERSION "1.6LK"
 #define MODULENAME "r8169"
diff -purN linux-2.6.11-rc2-bk10/drivers/oprofile/cpu_buffer.c linux-2.6.11-rc3/drivers/oprofile/cpu_buffer.c
--- linux-2.6.11-rc2-bk10/drivers/oprofile/cpu_buffer.c	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc3/drivers/oprofile/cpu_buffer.c	2005-02-03 02:54:39.000000000 +0100
@@ -233,7 +233,7 @@ static void oprofile_end_trace(struct op
 void oprofile_add_sample(struct pt_regs * const regs, unsigned long event)
 {
 	struct oprofile_cpu_buffer * cpu_buf = &cpu_buffer[smp_processor_id()];
-	unsigned long pc = instruction_pointer(regs);
+	unsigned long pc = profile_pc(regs);
 	int is_kernel = !user_mode(regs);
 
 	if (!backtrace_depth) {
diff -purN linux-2.6.11-rc2-bk10/drivers/pci/hotplug/shpchprm_legacy.c linux-2.6.11-rc3/drivers/pci/hotplug/shpchprm_legacy.c
--- linux-2.6.11-rc2-bk10/drivers/pci/hotplug/shpchprm_legacy.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pci/hotplug/shpchprm_legacy.c	2005-02-03 02:55:36.000000000 +0100
@@ -41,16 +41,16 @@
 #include "shpchprm.h"
 #include "shpchprm_legacy.h"
 
-static void *shpchp_rom_start;
+static void __iomem *shpchp_rom_start;
 static u16 unused_IRQ;
 
-void shpchprm_cleanup()
+void shpchprm_cleanup(void)
 {
 	if (shpchp_rom_start)
 		iounmap(shpchp_rom_start);
 }
 
-int shpchprm_print_pirt()
+int shpchprm_print_pirt(void)
 {
 	return 0;
 }
@@ -64,10 +64,10 @@ int shpchprm_get_physical_slot_number(st
 }
 
 /* Find the Hot Plug Resource Table in the specified region of memory */
-static void *detect_HRT_floating_pointer(void *begin, void *end)
+static void __iomem *detect_HRT_floating_pointer(void __iomem *begin, void __iomem *end)
 {
-	void *fp;
-	void *endp;
+	void __iomem *fp;
+	void __iomem *endp;
 	u8 temp1, temp2, temp3, temp4;
 	int status = 0;
 
@@ -104,7 +104,7 @@ int shpchprm_find_available_resources(st
 {
 	u8 populated_slot;
 	u8 bridged_slot;
-	void *one_slot;
+	void __iomem *one_slot;
 	struct pci_func *func = NULL;
 	int i = 10, index = 0;
 	u32 temp_dword, rc;
@@ -113,7 +113,7 @@ int shpchprm_find_available_resources(st
 	struct pci_resource *p_mem_node;
 	struct pci_resource *io_node;
 	struct pci_resource *bus_node;
-	void *rom_resource_table;
+	void __iomem *rom_resource_table;
 	struct pci_bus lpci_bus, *pci_bus;
 	u8 cfgspc_irq, temp;
 
@@ -413,7 +413,7 @@ void shpchprm_enable_card(
 
 static int legacy_shpchprm_init_pci(void)
 {
-	shpchp_rom_start = (u8 *) ioremap(ROM_PHY_ADDR, ROM_PHY_LEN);
+	shpchp_rom_start = ioremap(ROM_PHY_ADDR, ROM_PHY_LEN);
 	if (!shpchp_rom_start) {
 		err("Could not ioremap memory region for ROM\n");
 		return -EIO;
diff -purN linux-2.6.11-rc2-bk10/drivers/pci/pci.ids linux-2.6.11-rc3/drivers/pci/pci.ids
--- linux-2.6.11-rc2-bk10/drivers/pci/pci.ids	2005-01-22 02:48:16.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pci/pci.ids	2005-02-03 02:55:52.000000000 +0100
@@ -4433,6 +4433,7 @@
 11ab  Marvell Technology Group Ltd.
 	0146  GT-64010/64010A System Controller
 	1fa6  Marvell W8300 802.11 Adapter
+	4146  GT-64011/GT-64111 System Controller
 	4320  Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
 	4611  GT-64115 System Controller
 	4620  GT-64120/64120A/64121A System Controller
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/Kconfig linux-2.6.11-rc3/drivers/pcmcia/Kconfig
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/Kconfig	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/Kconfig	2005-02-03 02:56:22.000000000 +0100
@@ -134,6 +134,10 @@ config HD64465_PCMCIA
 	tristate "HD64465 host bridge support"
 	depends on HD64465 && PCMCIA
 
+config PCMCIA_AU1X00
+	tristate "Au1x00 pcmcia support"
+	depends on SOC_AU1X00 && PCMCIA
+
 config PCMCIA_SA1100
 	tristate "SA1100 support"
 	depends on ARM && ARCH_SA1100 && PCMCIA
@@ -183,6 +187,14 @@ config M32R_CFC_NUM
 	help
 	  Set the number of M32R CF slots.
 
+config PCMCIA_VRC4171
+	tristate "NEC VRC4171 Card Controllers support"
+	depends on VRC4171 && PCMCIA
+
+config PCMCIA_VRC4173
+	tristate "NEC VRC4173 CARDU support"
+	depends on CPU_VR41XX && PCI && PCMCIA
+
 config PCCARD_NONSTATIC
 	tristate
 	depends on PCCARD
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/Makefile linux-2.6.11-rc3/drivers/pcmcia/Makefile
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/Makefile	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/Makefile	2005-02-03 02:56:33.000000000 +0100
@@ -30,10 +30,23 @@ obj-$(CONFIG_PCMCIA_SA1111)			+= sa11xx_
 obj-$(CONFIG_PCMCIA_PXA2XX)                     += pxa2xx_core.o pxa2xx_cs.o
 obj-$(CONFIG_M32R_PCC)				+= m32r_pcc.o
 obj-$(CONFIG_M32R_CFC)				+= m32r_cfc.o
+obj-$(CONFIG_PCMCIA_AU1X00)			+= au1x00_ss.o
+obj-$(CONFIG_PCMCIA_VRC4171)			+= vrc4171_card.o
+obj-$(CONFIG_PCMCIA_VRC4173)			+= vrc4173_cardu.o
 
 sa11xx_core-y					+= soc_common.o sa11xx_base.o
 pxa2xx_core-y					+= soc_common.o pxa2xx_base.o
 
+au1x00_ss-y					+= au1000_generic.o
+au1x00_ss-$(CONFIG_MIPS_PB1000)			+= au1000_pb1x00.o
+au1x00_ss-$(CONFIG_MIPS_PB1100)			+= au1000_pb1x00.o
+au1x00_ss-$(CONFIG_MIPS_PB1500)			+= au1000_pb1x00.o
+au1x00_ss-$(CONFIG_MIPS_DB1000)			+= au1000_db1x00.o
+au1x00_ss-$(CONFIG_MIPS_DB1100)			+= au1000_db1x00.o
+au1x00_ss-$(CONFIG_MIPS_DB1500)			+= au1000_db1x00.o
+au1x00_ss-$(CONFIG_MIPS_DB1550)			+= au1000_db1x00.o
+au1x00_ss-$(CONFIG_MIPS_XXS1500)               += au1000_xxs1500.o
+
 sa1111_cs-y					+= sa1111_generic.o
 sa1111_cs-$(CONFIG_ASSABET_NEPONSET)		+= sa1100_neponset.o
 sa1111_cs-$(CONFIG_SA1100_BADGE4)		+= sa1100_badge4.o
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_db1x00.c linux-2.6.11-rc3/drivers/pcmcia/au1000_db1x00.c
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_db1x00.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/au1000_db1x00.c	2005-02-03 02:57:17.000000000 +0100
@@ -0,0 +1,288 @@
+/*
+ *
+ * Alchemy Semi Db1x00 boards specific pcmcia routines.
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * Copyright 2004 Pete Popov, updated the driver to 2.6.
+ * Followed the sa11xx API and largely copied many of the hardware
+ * independent functions.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/signal.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-db1x00/db1x00.h>
+
+#include "au1000_generic.h"
+
+#if 0
+#define debug(x,args...) printk(KERN_DEBUG "%s: " x, __func__ , ##args)
+#else
+#define debug(x,args...)
+#endif
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+struct au1000_pcmcia_socket au1000_pcmcia_socket[PCMCIA_NUM_SOCKS];
+extern int au1x00_pcmcia_socket_probe(struct device *, struct pcmcia_low_level *, int, int);
+
+static int db1x00_pcmcia_hw_init(struct au1000_pcmcia_socket *skt)
+{
+#ifdef CONFIG_MIPS_DB1550
+	skt->irq = skt->nr ? AU1000_GPIO_5 : AU1000_GPIO_3;
+#else
+	skt->irq = skt->nr ? AU1000_GPIO_5 : AU1000_GPIO_2;
+#endif
+	return 0;
+}
+
+static void db1x00_pcmcia_shutdown(struct au1000_pcmcia_socket *skt)
+{
+	bcsr->pcmcia = 0; /* turn off power */
+	au_sync_delay(2);
+}
+
+static void
+db1x00_pcmcia_socket_state(struct au1000_pcmcia_socket *skt, struct pcmcia_state *state)
+{
+	u32 inserted;
+	unsigned char vs;
+
+	state->ready = 0;
+	state->vs_Xv = 0;
+	state->vs_3v = 0;
+	state->detect = 0;
+
+	switch (skt->nr) {
+	case 0:
+		vs = bcsr->status & 0x3;
+		inserted = !(bcsr->status & (1<<4));
+		break;
+	case 1:
+		vs = (bcsr->status & 0xC)>>2;
+		inserted = !(bcsr->status & (1<<5));
+		break;
+	default:/* should never happen */
+		return;
+	}
+
+	if (inserted)
+		debug("db1x00 socket %d: inserted %d, vs %d pcmcia %x\n",
+				skt->nr, inserted, vs, bcsr->pcmcia);
+
+	if (inserted) {
+		switch (vs) {
+			case 0:
+			case 2:
+				state->vs_3v=1;
+				break;
+			case 3: /* 5V */
+				break;
+			default:
+				/* return without setting 'detect' */
+				printk(KERN_ERR "db1x00 bad VS (%d)\n",
+						vs);
+		}
+		state->detect = 1;
+		state->ready = 1;
+	}
+	else {
+		/* if the card was previously inserted and then ejected,
+		 * we should turn off power to it
+		 */
+		if ((skt->nr == 0) && (bcsr->pcmcia & BCSR_PCMCIA_PC0RST)) {
+			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC0RST |
+					BCSR_PCMCIA_PC0DRVEN |
+					BCSR_PCMCIA_PC0VPP |
+					BCSR_PCMCIA_PC0VCC);
+			au_sync_delay(10);
+		}
+		else if ((skt->nr == 1) && bcsr->pcmcia & BCSR_PCMCIA_PC1RST) {
+			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC1RST |
+					BCSR_PCMCIA_PC1DRVEN |
+					BCSR_PCMCIA_PC1VPP |
+					BCSR_PCMCIA_PC1VCC);
+			au_sync_delay(10);
+		}
+	}
+
+	state->bvd1=1;
+	state->bvd2=1;
+	state->wrprot=0;
+}
+
+static int
+db1x00_pcmcia_configure_socket(struct au1000_pcmcia_socket *skt, struct socket_state_t *state)
+{
+	u16 pwr;
+	int sock = skt->nr;
+
+	debug("config_skt %d Vcc %dV Vpp %dV, reset %d\n",
+			sock, state->Vcc, state->Vpp,
+			state->flags & SS_RESET);
+
+	/* pcmcia reg was set to zero at init time. Be careful when
+	 * initializing a socket not to wipe out the settings of the
+	 * other socket.
+	 */
+	pwr = bcsr->pcmcia;
+	pwr &= ~(0xf << sock*8); /* clear voltage settings */
+
+	state->Vpp = 0;
+	switch(state->Vcc){
+		case 0:  /* Vcc 0 */
+			pwr |= SET_VCC_VPP(0,0,sock);
+			break;
+		case 50: /* Vcc 5V */
+			switch(state->Vpp) {
+				case 0:
+					pwr |= SET_VCC_VPP(2,0,sock);
+					break;
+				case 50:
+					pwr |= SET_VCC_VPP(2,1,sock);
+					break;
+				case 12:
+					pwr |= SET_VCC_VPP(2,2,sock);
+					break;
+				case 33:
+				default:
+					pwr |= SET_VCC_VPP(0,0,sock);
+					printk("%s: bad Vcc/Vpp (%d:%d)\n",
+							__FUNCTION__,
+							state->Vcc,
+							state->Vpp);
+					break;
+			}
+			break;
+		case 33: /* Vcc 3.3V */
+			switch(state->Vpp) {
+				case 0:
+					pwr |= SET_VCC_VPP(1,0,sock);
+					break;
+				case 12:
+					pwr |= SET_VCC_VPP(1,2,sock);
+					break;
+				case 33:
+					pwr |= SET_VCC_VPP(1,1,sock);
+					break;
+				case 50:
+				default:
+					pwr |= SET_VCC_VPP(0,0,sock);
+					printk("%s: bad Vcc/Vpp (%d:%d)\n",
+							__FUNCTION__,
+							state->Vcc,
+							state->Vpp);
+					break;
+			}
+			break;
+		default: /* what's this ? */
+			pwr |= SET_VCC_VPP(0,0,sock);
+			printk(KERN_ERR "%s: bad Vcc %d\n",
+					__FUNCTION__, state->Vcc);
+			break;
+	}
+
+	bcsr->pcmcia = pwr;
+	au_sync_delay(300);
+
+	if (sock == 0) {
+		if (!(state->flags & SS_RESET)) {
+			pwr |= BCSR_PCMCIA_PC0DRVEN;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(300);
+			pwr |= BCSR_PCMCIA_PC0RST;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+		else {
+			pwr &= ~(BCSR_PCMCIA_PC0RST | BCSR_PCMCIA_PC0DRVEN);
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+	}
+	else {
+		if (!(state->flags & SS_RESET)) {
+			pwr |= BCSR_PCMCIA_PC1DRVEN;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(300);
+			pwr |= BCSR_PCMCIA_PC1RST;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+		else {
+			pwr &= ~(BCSR_PCMCIA_PC1RST | BCSR_PCMCIA_PC1DRVEN);
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+	}
+	return 0;
+}
+
+/*
+ * Enable card status IRQs on (re-)initialisation.  This can
+ * be called at initialisation, power management event, or
+ * pcmcia event.
+ */
+void db1x00_socket_init(struct au1000_pcmcia_socket *skt)
+{
+	/* nothing to do for now */
+}
+
+/*
+ * Disable card status IRQs and PCMCIA bus on suspend.
+ */
+void db1x00_socket_suspend(struct au1000_pcmcia_socket *skt)
+{
+	/* nothing to do for now */
+}
+
+struct pcmcia_low_level db1x00_pcmcia_ops = {
+	.owner			= THIS_MODULE,
+
+	.hw_init 		= db1x00_pcmcia_hw_init,
+	.hw_shutdown		= db1x00_pcmcia_shutdown,
+
+	.socket_state		= db1x00_pcmcia_socket_state,
+	.configure_socket	= db1x00_pcmcia_configure_socket,
+
+	.socket_init		= db1x00_socket_init,
+	.socket_suspend		= db1x00_socket_suspend
+};
+
+int __init au1x_board_init(struct device *dev)
+{
+	int ret = -ENODEV;
+	bcsr->pcmcia = 0; /* turn off power, if it's not already off */
+	au_sync_delay(2);
+	ret = au1x00_pcmcia_socket_probe(dev, &db1x00_pcmcia_ops, 0, 2);
+	return ret;
+}
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_generic.c linux-2.6.11-rc3/drivers/pcmcia/au1000_generic.c
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_generic.c	2005-02-03 10:03:09.640534865 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/au1000_generic.c	2005-02-03 02:55:53.000000000 +0100
@@ -2,9 +2,13 @@
  *
  * Alchemy Semi Au1000 pcmcia driver
  *
- * Copyright 2001 MontaVista Software Inc.
+ * Copyright 2001-2003 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ *         	ppopov@embeddedalley.com or source@mvista.com
+ *
+ * Copyright 2004 Pete Popov, Embedded Alley Solutions, Inc.
+ * Updated the driver to 2.6. Followed the sa11xx API and largely
+ * copied many of the hardware independent functions.
  *
  * ########################################################################
  *
@@ -25,450 +29,255 @@
  *
  * 
  */
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/config.h>
-#include <linux/delay.h>
+#include <linux/cpufreq.h>
 #include <linux/ioport.h>
 #include <linux/kernel.h>
-#include <linux/tqueue.h>
 #include <linux/timer.h>
 #include <linux/mm.h>
-#include <linux/proc_fs.h>
-#include <linux/types.h>
-#include <linux/vmalloc.h>
-
-#include <pcmcia/version.h>
-#include <pcmcia/cs_types.h>
-#include <pcmcia/cs.h>
-#include <pcmcia/ss.h>
-#include <pcmcia/bulkmem.h>
-#include <pcmcia/cistpl.h>
-#include <pcmcia/bus_ops.h>
-#include "cs_internal.h"
+#include <linux/notifier.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/system.h>
 
-#include <asm/au1000.h>
-#include <asm/au1000_pcmcia.h>
-
-#ifdef DEBUG
-static int pc_debug;
-
-module_param(pc_debug, int, 0644);
-
-#define debug(lvl,fmt) do {			\
-	if (pc_debug > (lvl))			\
-		printk(KERN_DEBUG fmt);		\
-} while (0)
-#else
-#define debug(lvl,fmt) do { } while (0)
-#endif
+#include <asm/mach-au1x00/au1000.h>
+#include "au1000_generic.h"
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Pete Popov, MontaVista Software <ppopov@mvista.com>");
+MODULE_AUTHOR("Pete Popov <ppopov@embeddedalley.com>");
 MODULE_DESCRIPTION("Linux PCMCIA Card Services: Au1x00 Socket Controller");
 
-#define MAP_SIZE 0x1000000
-
-/* This structure maintains housekeeping state for each socket, such
- * as the last known values of the card detect pins, or the Card Services
- * callback value associated with the socket:
- */
-static struct au1000_pcmcia_socket *pcmcia_socket;
-static int socket_count;
-
-
-/* Returned by the low-level PCMCIA interface: */
-static struct pcmcia_low_level *pcmcia_low_level;
-
-/* Event poll timer structure */
-static struct timer_list poll_timer;
-
-
-/* Prototypes for routines which are used internally: */
-
-static int  au1000_pcmcia_driver_init(void);
-static void au1000_pcmcia_driver_shutdown(void);
-static void au1000_pcmcia_task_handler(void *data);
-static void au1000_pcmcia_poll_event(unsigned long data);
-static void au1000_pcmcia_interrupt(int irq, void *dev, struct pt_regs *regs);
-static struct tq_struct au1000_pcmcia_task;
-
-#ifdef CONFIG_PROC_FS
-static int au1000_pcmcia_proc_status(char *buf, char **start, 
-		off_t pos, int count, int *eof, void *data);
+#if 0
+#define debug(x,args...) printk(KERN_DEBUG "%s: " x, __func__ , ##args)
+#else
+#define debug(x,args...)
 #endif
 
+#define MAP_SIZE 0x100000
+extern struct au1000_pcmcia_socket au1000_pcmcia_socket[];
+#define PCMCIA_SOCKET(x)	(au1000_pcmcia_socket + (x))
+#define to_au1000_socket(x)	container_of(x, struct au1000_pcmcia_socket, socket)
 
-/* Prototypes for operations which are exported to the
- * new-and-impr^H^H^H^H^H^H^H^H^H^H in-kernel PCMCIA core:
+/* Some boards like to support CF cards as IDE root devices, so they
+ * grab pcmcia sockets directly.
  */
+u32 *pcmcia_base_vaddrs[2];
+extern const unsigned long mips_io_port_base;
 
-static int au1000_pcmcia_init(u32 sock);
-static int au1000_pcmcia_suspend(u32 sock);
-static int au1000_pcmcia_register_callback(u32 sock, 
-		void (*handler)(void *, u32), void *info);
-static int au1000_pcmcia_inquire_socket(u32 sock, socket_cap_t *cap);
-static int au1000_pcmcia_get_status(u32 sock, u_int *value);
-static int au1000_pcmcia_get_socket(u32 sock, socket_state_t *state);
-static int au1000_pcmcia_set_socket(u32 sock, socket_state_t *state);
-static int au1000_pcmcia_get_io_map(u32 sock, struct pccard_io_map *io);
-static int au1000_pcmcia_set_io_map(u32 sock, struct pccard_io_map *io);
-static int au1000_pcmcia_get_mem_map(u32 sock, struct pccard_mem_map *mem);
-static int au1000_pcmcia_set_mem_map(u32 sock, struct pccard_mem_map *mem);
-#ifdef CONFIG_PROC_FS
-static void au1000_pcmcia_proc_setup(u32 sock, struct proc_dir_entry *base);
-#endif
+DECLARE_MUTEX(pcmcia_sockets_lock);
 
-static struct pccard_operations au1000_pcmcia_operations = {
-	au1000_pcmcia_init,
-	au1000_pcmcia_suspend,
-	au1000_pcmcia_register_callback,
-	au1000_pcmcia_inquire_socket,
-	au1000_pcmcia_get_status,
-	au1000_pcmcia_get_socket,
-	au1000_pcmcia_set_socket,
-	au1000_pcmcia_get_io_map,
-	au1000_pcmcia_set_io_map,
-	au1000_pcmcia_get_mem_map,
-	au1000_pcmcia_set_mem_map,
-#ifdef CONFIG_PROC_FS
-	au1000_pcmcia_proc_setup
-#endif
+static int (*au1x00_pcmcia_hw_init[])(struct device *dev) = {
+	au1x_board_init,
 };
 
-static DEFINE_SPINLOCK(pcmcia_lock);
-
-static int __init au1000_pcmcia_driver_init(void)
+static int
+au1x00_pcmcia_skt_state(struct au1000_pcmcia_socket *skt)
 {
-	struct pcmcia_init pcmcia_init;
 	struct pcmcia_state state;
-	unsigned int i;
+	unsigned int stat;
 
-	printk("\nAu1x00 PCMCIA\n");
+	memset(&state, 0, sizeof(struct pcmcia_state));
 
-#ifndef CONFIG_64BIT_PHYS_ADDR
-	printk(KERN_ERR "Au1x00 PCMCIA 36 bit IO support not enabled\n");
-	return -1;
-#endif
-
-#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500)
-	pcmcia_low_level=&pb1x00_pcmcia_ops;
-#else
-#error Unsupported AU1000 board.
-#endif
+	skt->ops->socket_state(skt, &state);
 
-	pcmcia_init.handler=au1000_pcmcia_interrupt;
-	if((socket_count=pcmcia_low_level->init(&pcmcia_init))<0) {
-		printk(KERN_ERR "Unable to initialize PCMCIA service.\n");
-		return -EIO;
-	}
+	stat = state.detect  ? SS_DETECT : 0;
+	stat |= state.ready  ? SS_READY  : 0;
+	stat |= state.wrprot ? SS_WRPROT : 0;
+	stat |= state.vs_3v  ? SS_3VCARD : 0;
+	stat |= state.vs_Xv  ? SS_XVCARD : 0;
+	stat |= skt->cs_state.Vcc ? SS_POWERON : 0;
 
-	/* NOTE: the chip select must already be setup */
-
-	pcmcia_socket = 
-		kmalloc(sizeof(struct au1000_pcmcia_socket) * socket_count, 
-				GFP_KERNEL);
-	if (!pcmcia_socket) {
-		printk(KERN_ERR "Card Services can't get memory \n");
-		return -1;
+	if (skt->cs_state.flags & SS_IOCARD)
+		stat |= state.bvd1 ? SS_STSCHG : 0;
+	else {
+		if (state.bvd1 == 0)
+			stat |= SS_BATDEAD;
+		else if (state.bvd2 == 0)
+			stat |= SS_BATWARN;
 	}
-	memset(pcmcia_socket, 0,
-			sizeof(struct au1000_pcmcia_socket) * socket_count);
-			
-	/* 
-	 * Assuming max of 2 sockets, which the Au1000 supports.
-	 * WARNING: the Pb1000 has two sockets, and both work, but you
-	 * can't use them both at the same time due to glue logic conflicts.
-	 */
-	for(i=0; i < socket_count; i++) {
+	return stat;
+}
 
-		if(pcmcia_low_level->socket_state(i, &state)<0){
-			printk(KERN_ERR "Unable to get PCMCIA status\n");
-			return -EIO;
-		}
-		pcmcia_socket[i].k_state=state;
-		pcmcia_socket[i].cs_state.csc_mask=SS_DETECT;
-		
-		if (i == 0) {
-			pcmcia_socket[i].virt_io = 
-				(u32)ioremap((kio_addr_t)0xF00000000, 0x1000);
-			pcmcia_socket[i].phys_attr = (memaddr_t)0xF40000000;
-			pcmcia_socket[i].phys_mem = (memaddr_t)0xF80000000;
-		}
-		else  {
-			pcmcia_socket[i].virt_io = 
-				(u32)ioremap((kio_addr_t)0xF08000000, 0x1000);
-			pcmcia_socket[i].phys_attr = (memaddr_t)0xF48000000;
-			pcmcia_socket[i].phys_mem = (memaddr_t)0xF88000000;
-		}
-	}
+/*
+ * au100_pcmcia_config_skt
+ *
+ * Convert PCMCIA socket state to our socket configure structure.
+ */
+static int
+au1x00_pcmcia_config_skt(struct au1000_pcmcia_socket *skt, socket_state_t *state)
+{
+	int ret;
 
-	/* Only advertise as many sockets as we can detect: */
-	if(register_ss_entry(socket_count, &au1000_pcmcia_operations)<0){
-		printk(KERN_ERR "Unable to register socket service routine\n");
-		return -ENXIO;
+	ret = skt->ops->configure_socket(skt, state);
+	if (ret == 0) {
+		skt->cs_state = *state;
 	}
 
-	/* Start the event poll timer.  
-	 * It will reschedule by itself afterwards. 
-	 */
-	au1000_pcmcia_poll_event(0);
+	if (ret < 0)
+		debug("unable to configure socket %d\n", skt->nr);
 
-	debug(1, "au1000: initialization complete\n");
-	return 0;
-
-}  /* au1000_pcmcia_driver_init() */
-
-module_init(au1000_pcmcia_driver_init);
-
-static void __exit au1000_pcmcia_driver_shutdown(void)
-{
-	int i;
-
-	del_timer_sync(&poll_timer);
-	unregister_ss_entry(&au1000_pcmcia_operations);
-	pcmcia_low_level->shutdown();
-	flush_scheduled_tasks();
-	for(i=0; i < socket_count; i++) {
-		if (pcmcia_socket[i].virt_io) 
-			iounmap((void *)pcmcia_socket[i].virt_io);
-	}
-	debug(1, "au1000: shutdown complete\n");
+	return ret;
 }
 
-module_exit(au1000_pcmcia_driver_shutdown);
+/* au1x00_pcmcia_sock_init()
+ *
+ * (Re-)Initialise the socket, turning on status interrupts
+ * and PCMCIA bus.  This must wait for power to stabilise
+ * so that the card status signals report correctly.
+ *
+ * Returns: 0
+ */
+static int au1x00_pcmcia_sock_init(struct pcmcia_socket *sock)
+{
+	struct au1000_pcmcia_socket *skt = to_au1000_socket(sock);
 
-static int au1000_pcmcia_init(unsigned int sock) { return 0; }
+	debug("initializing socket %u\n", skt->nr);
 
-static int au1000_pcmcia_suspend(unsigned int sock)
-{
+	skt->ops->socket_init(skt);
 	return 0;
 }
 
-
-static inline unsigned 
-au1000_pcmcia_events(struct pcmcia_state *state, 
-		struct pcmcia_state *prev_state, 
-		unsigned int mask, unsigned int flags)
+/*
+ * au1x00_pcmcia_suspend()
+ *
+ * Remove power on the socket, disable IRQs from the card.
+ * Turn off status interrupts, and disable the PCMCIA bus.
+ *
+ * Returns: 0
+ */
+static int au1x00_pcmcia_suspend(struct pcmcia_socket *sock)
 {
-	unsigned int events=0;
+	struct au1000_pcmcia_socket *skt = to_au1000_socket(sock);
+	int ret;
 
-	if(state->detect!=prev_state->detect){
-		debug(2, "%s(): card detect value %u\n", 
-				__FUNCTION__, state->detect);
-		events |= mask&SS_DETECT;
-	}
+	debug("suspending socket %u\n", skt->nr);
 
+	ret = au1x00_pcmcia_config_skt(skt, &dead_socket);
+	if (ret == 0)
+		skt->ops->socket_suspend(skt);
 
-	if(state->ready!=prev_state->ready){
-		debug(2, "%s(): card ready value %u\n", 
-				__FUNCTION__, state->ready);
-		events |= mask&((flags&SS_IOCARD)?0:SS_READY);
-	}
-
-	*prev_state=*state;
-	return events;
-
-}  /* au1000_pcmcia_events() */
+	return ret;
+}
 
+static DEFINE_SPINLOCK(status_lock);
 
-/* 
- * Au1000_pcmcia_task_handler()
- * Processes socket events.
+/*
+ * au1x00_check_status()
  */
-static void au1000_pcmcia_task_handler(void *data) 
+static void au1x00_check_status(struct au1000_pcmcia_socket *skt)
 {
-	struct pcmcia_state state;
-	int i, events, irq_status;
-
-	for(i=0; i<socket_count; i++)  {
-		if((irq_status = pcmcia_low_level->socket_state(i, &state))<0)
-			printk(KERN_ERR "low-level PCMCIA error\n");
-
-		events = au1000_pcmcia_events(&state, 
-				&pcmcia_socket[i].k_state, 
-				pcmcia_socket[i].cs_state.csc_mask, 
-				pcmcia_socket[i].cs_state.flags);
-		if(pcmcia_socket[i].handler!=NULL) {
-			pcmcia_socket[i].handler(pcmcia_socket[i].handler_info,
-					events);
-		}
-	}
-
-}  /* au1000_pcmcia_task_handler() */
-
-static struct tq_struct au1000_pcmcia_task = {
-	routine: au1000_pcmcia_task_handler
-};
+	unsigned int events;
 
+	debug("entering PCMCIA monitoring thread\n");
 
-static void au1000_pcmcia_poll_event(unsigned long dummy)
-{
-	poll_timer.function = au1000_pcmcia_poll_event;
-	poll_timer.expires = jiffies + AU1000_PCMCIA_POLL_PERIOD;
-	add_timer(&poll_timer);
-	schedule_task(&au1000_pcmcia_task);
+	do {
+		unsigned int status;
+		unsigned long flags;
+
+		status = au1x00_pcmcia_skt_state(skt);
+
+		spin_lock_irqsave(&status_lock, flags);
+		events = (status ^ skt->status) & skt->cs_state.csc_mask;
+		skt->status = status;
+		spin_unlock_irqrestore(&status_lock, flags);
+
+		debug("events: %s%s%s%s%s%s\n",
+			events == 0         ? "<NONE>"   : "",
+			events & SS_DETECT  ? "DETECT "  : "",
+			events & SS_READY   ? "READY "   : "",
+			events & SS_BATDEAD ? "BATDEAD " : "",
+			events & SS_BATWARN ? "BATWARN " : "",
+			events & SS_STSCHG  ? "STSCHG "  : "");
+
+		if (events)
+			pcmcia_parse_events(&skt->socket, events);
+	} while (events);
 }
 
-
 /* 
- * au1000_pcmcia_interrupt()
- * The actual interrupt work is performed by au1000_pcmcia_task(), 
- * because the Card Services event handling code performs scheduling 
- * operations which cannot be executed from within an interrupt context.
+ * au1x00_pcmcia_poll_event()
+ * Let's poll for events in addition to IRQs since IRQ only is unreliable...
  */
-static void 
-au1000_pcmcia_interrupt(int irq, void *dev, struct pt_regs *regs)
+static void au1x00_pcmcia_poll_event(unsigned long dummy)
 {
-	schedule_task(&au1000_pcmcia_task);
-}
+	struct au1000_pcmcia_socket *skt = (struct au1000_pcmcia_socket *)dummy;
+	debug("polling for events\n");
 
+	mod_timer(&skt->poll_timer, jiffies + AU1000_PCMCIA_POLL_PERIOD);
 
-static int 
-au1000_pcmcia_register_callback(unsigned int sock, 
-		void (*handler)(void *, unsigned int), void *info)
-{
-	if(handler==NULL){
-		pcmcia_socket[sock].handler=NULL;
-		MOD_DEC_USE_COUNT;
-	} else {
-		MOD_INC_USE_COUNT;
-		pcmcia_socket[sock].handler=handler;
-		pcmcia_socket[sock].handler_info=info;
-	}
-	return 0;
+	au1x00_check_status(skt);
 }
 
-
-/* au1000_pcmcia_inquire_socket()
- *
- * From the sa1100 socket driver : 
- *
- * Implements the inquire_socket() operation for the in-kernel PCMCIA
- * service (formerly SS_InquireSocket in Card Services).  We set 
- * SS_CAP_STATIC_MAP, which disables the memory resource database check. 
- * (Mapped memory is set up within the socket driver itself.)
+/* au1x00_pcmcia_get_status()
  *
- * In conjunction with the STATIC_MAP capability is a new field,
- * `io_offset', recommended by David Hinds. Rather than go through
- * the SetIOMap interface (which is not quite suited for communicating
- * window locations up from the socket driver), we just pass up 
- * an offset which is applied to client-requested base I/O addresses
- * in alloc_io_space().
+ * From the sa11xx_core.c:
+ * Implements the get_status() operation for the in-kernel PCMCIA
+ * service (formerly SS_GetStatus in Card Services). Essentially just
+ * fills in bits in `status' according to internal driver state or
+ * the value of the voltage detect chipselect register.
+ *
+ * As a debugging note, during card startup, the PCMCIA core issues
+ * three set_socket() commands in a row the first with RESET deasserted,
+ * the second with RESET asserted, and the last with RESET deasserted
+ * again. Following the third set_socket(), a get_status() command will
+ * be issued. The kernel is looking for the SS_READY flag (see
+ * setup_socket(), reset_socket(), and unreset_socket() in cs.c).
  *
- * Returns: 0 on success, -1 if no pin has been configured for `sock'
+ * Returns: 0
  */
-static int au1000_pcmcia_inquire_socket(unsigned int sock, socket_cap_t *cap)
+static int
+au1x00_pcmcia_get_status(struct pcmcia_socket *sock, unsigned int *status)
 {
-	struct pcmcia_irq_info irq_info;
-
-	if(sock > socket_count){
-		printk(KERN_ERR "au1000: socket %u not configured\n", sock);
-		return -1;
-	}
-
-	/* from the sa1100_generic driver: */
-
-	/* SS_CAP_PAGE_REGS: used by setup_cis_mem() in cistpl.c to set the
-	*   force_low argument to validate_mem() in rsrc_mgr.c -- since in
-	*   general, the mapped * addresses of the PCMCIA memory regions
-	*   will not be within 0xffff, setting force_low would be
-	*   undesirable.
-	*
-	* SS_CAP_STATIC_MAP: don't bother with the (user-configured) memory
-	*   resource database; we instead pass up physical address ranges
-	*   and allow other parts of Card Services to deal with remapping.
-	*
-	* SS_CAP_PCCARD: we can deal with 16-bit PCMCIA & CF cards, but
-	*   not 32-bit CardBus devices.
-	*/
-	cap->features=(SS_CAP_PAGE_REGS  | SS_CAP_STATIC_MAP | SS_CAP_PCCARD);
-
-	irq_info.sock=sock;
-	irq_info.irq=-1;
-
-	if(pcmcia_low_level->get_irq_info(&irq_info)<0){
-		printk(KERN_ERR "Error obtaining IRQ info socket %u\n", sock);
-		return -1;
-	}
+	struct au1000_pcmcia_socket *skt = to_au1000_socket(sock);
 
-	cap->irq_mask=0;
-	cap->map_size=MAP_SIZE;
-	cap->pci_irq=irq_info.irq;
-	cap->io_offset=pcmcia_socket[sock].virt_io;
+	skt->status = au1x00_pcmcia_skt_state(skt);
+	*status = skt->status;
 
 	return 0;
+}
 
-}  /* au1000_pcmcia_inquire_socket() */
-
-
-static int 
-au1000_pcmcia_get_status(unsigned int sock, unsigned int *status)
+/* au1x00_pcmcia_get_socket()
+ * Implements the get_socket() operation for the in-kernel PCMCIA
+ * service (formerly SS_GetSocket in Card Services). Not a very
+ * exciting routine.
+ *
+ * Returns: 0
+ */
+static int
+au1x00_pcmcia_get_socket(struct pcmcia_socket *sock, socket_state_t *state)
 {
-	struct pcmcia_state state;
-
-
-	if((pcmcia_low_level->socket_state(sock, &state))<0){
-		printk(KERN_ERR "Unable to get PCMCIA status from kernel.\n");
-		return -1;
-	}
-
-	pcmcia_socket[sock].k_state = state;
+  struct au1000_pcmcia_socket *skt = to_au1000_socket(sock);
 
-	*status = state.detect?SS_DETECT:0;
-
-	*status |= state.ready?SS_READY:0;
-
-	*status |= pcmcia_socket[sock].cs_state.Vcc?SS_POWERON:0;
-
-	if(pcmcia_socket[sock].cs_state.flags&SS_IOCARD)
-		*status |= state.bvd1?SS_STSCHG:0;
-	else {
-		if(state.bvd1==0)
-			*status |= SS_BATDEAD;
-		else if(state.bvd2 == 0)
-			*status |= SS_BATWARN;
-	}
-
-	*status|=state.vs_3v?SS_3VCARD:0;
-
-	*status|=state.vs_Xv?SS_XVCARD:0;
-
-	debug(2, "\tstatus: %s%s%s%s%s%s%s%s\n",
-	(*status&SS_DETECT)?"DETECT ":"",
-	(*status&SS_READY)?"READY ":"", 
-	(*status&SS_BATDEAD)?"BATDEAD ":"",
-	(*status&SS_BATWARN)?"BATWARN ":"",
-	(*status&SS_POWERON)?"POWERON ":"",
-	(*status&SS_STSCHG)?"STSCHG ":"",
-	(*status&SS_3VCARD)?"3VCARD ":"",
-	(*status&SS_XVCARD)?"XVCARD ":"");
-
-	return 0;
-
-}  /* au1000_pcmcia_get_status() */
-
-
-static int 
-au1000_pcmcia_get_socket(unsigned int sock, socket_state_t *state)
-{
-	*state = pcmcia_socket[sock].cs_state;
-	return 0;
+  debug("for sock %u\n", skt->nr);
+  *state = skt->cs_state;
+  return 0;
 }
 
-
-static int 
-au1000_pcmcia_set_socket(unsigned int sock, socket_state_t *state)
+/* au1x00_pcmcia_set_socket()
+ * Implements the set_socket() operation for the in-kernel PCMCIA
+ * service (formerly SS_SetSocket in Card Services). We more or
+ * less punt all of this work and let the kernel handle the details
+ * of power configuration, reset, &c. We also record the value of
+ * `state' in order to regurgitate it to the PCMCIA core later.
+ *
+ * Returns: 0
+ */
+static int
+au1x00_pcmcia_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
 {
-	struct pcmcia_configure configure;
+  struct au1000_pcmcia_socket *skt = to_au1000_socket(sock);
+
+  debug("for sock %u\n", skt->nr);
 
-	debug(2, "\tmask:  %s%s%s%s%s%s\n\tflags: %s%s%s%s%s%s\n"
-	"\tVcc %d  Vpp %d  irq %d\n",
+  debug("\tmask:  %s%s%s%s%s%s\n\tflags: %s%s%s%s%s%s\n",
 	(state->csc_mask==0)?"<NONE>":"",
 	(state->csc_mask&SS_DETECT)?"DETECT ":"",
 	(state->csc_mask&SS_READY)?"READY ":"",
@@ -480,217 +289,294 @@ au1000_pcmcia_set_socket(unsigned int so
 	(state->flags&SS_IOCARD)?"IOCARD ":"",
 	(state->flags&SS_RESET)?"RESET ":"",
 	(state->flags&SS_SPKR_ENA)?"SPKR_ENA ":"",
-	(state->flags&SS_OUTPUT_ENA)?"OUTPUT_ENA ":"",
+	(state->flags&SS_OUTPUT_ENA)?"OUTPUT_ENA ":"");
+  debug("\tVcc %d  Vpp %d  irq %d\n",
 	state->Vcc, state->Vpp, state->io_irq);
 
-	configure.sock=sock;
-	configure.vcc=state->Vcc;
-	configure.vpp=state->Vpp;
-	configure.output=(state->flags&SS_OUTPUT_ENA)?1:0;
-	configure.speaker=(state->flags&SS_SPKR_ENA)?1:0;
-	configure.reset=(state->flags&SS_RESET)?1:0;
-
-	if(pcmcia_low_level->configure_socket(&configure)<0){
-		printk(KERN_ERR "Unable to configure socket %u\n", sock);
-		return -1;
-	}
-
-	pcmcia_socket[sock].cs_state = *state;
-	return 0;
-
-}  /* au1000_pcmcia_set_socket() */
-
-
-static int 
-au1000_pcmcia_get_io_map(unsigned int sock, struct pccard_io_map *map)
-{
-	debug(1, "au1000_pcmcia_get_io_map: sock %d\n", sock);
-	if(map->map>=MAX_IO_WIN){
-		printk(KERN_ERR "%s(): map (%d) out of range\n", 
-				__FUNCTION__, map->map);
-		return -1;
-	}
-	*map=pcmcia_socket[sock].io_map[map->map];
-	return 0;
+  return au1x00_pcmcia_config_skt(skt, state);
 }
 
-
 int 
-au1000_pcmcia_set_io_map(unsigned int sock, struct pccard_io_map *map)
+au1x00_pcmcia_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *map)
 {
+	struct au1000_pcmcia_socket *skt = to_au1000_socket(sock);
 	unsigned int speed;
-	unsigned long start;
 
 	if(map->map>=MAX_IO_WIN){
-		printk(KERN_ERR "%s(): map (%d) out of range\n", 
-				__FUNCTION__, map->map);
+		debug("map (%d) out of range\n", map->map);
 		return -1;
 	}
 
 	if(map->flags&MAP_ACTIVE){
 		speed=(map->speed>0)?map->speed:AU1000_PCMCIA_IO_SPEED;
-		pcmcia_socket[sock].speed_io=speed;
+		skt->spd_io[map->map] = speed;
 	}
 
-	start=map->start;
-
-	if(map->stop==1) {
-		map->stop=PAGE_SIZE-1;
-	}
-
-	map->start=pcmcia_socket[sock].virt_io;
-	map->stop=map->start+(map->stop-start);
-	pcmcia_socket[sock].io_map[map->map]=*map;
-	debug(3, "set_io_map %d start %x stop %x\n", 
-			map->map, map->start, map->stop);
+	map->start=(ioaddr_t)(u32)skt->virt_io;
+	map->stop=map->start+MAP_SIZE;
 	return 0;
 
-}  /* au1000_pcmcia_set_io_map() */
+}  /* au1x00_pcmcia_set_io_map() */
 
 
 static int 
-au1000_pcmcia_get_mem_map(unsigned int sock, struct pccard_mem_map *map)
+au1x00_pcmcia_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *map)
 {
+	struct au1000_pcmcia_socket *skt = to_au1000_socket(sock);
+	unsigned short speed = map->speed;
 
-	if(map->map>=MAX_WIN) {
-		printk(KERN_ERR "%s(): map (%d) out of range\n", 
-				__FUNCTION__, map->map);
+	if(map->map>=MAX_WIN){
+		debug("map (%d) out of range\n", map->map);
 		return -1;
 	}
-	*map=pcmcia_socket[sock].mem_map[map->map];
+
+	if (map->flags & MAP_ATTRIB) {
+		skt->spd_attr[map->map] = speed;
+		skt->spd_mem[map->map] = 0;
+	} else {
+		skt->spd_attr[map->map] = 0;
+		skt->spd_mem[map->map] = speed;
+	}
+
+	if (map->flags & MAP_ATTRIB) {
+		map->static_start = skt->phys_attr + map->card_start;
+	}
+	else {
+		map->static_start = skt->phys_mem + map->card_start;
+	}
+
+	debug("set_mem_map %d start %08lx card_start %08x\n",
+			map->map, map->static_start, map->card_start);
 	return 0;
-}
 
+}  /* au1x00_pcmcia_set_mem_map() */
 
-static int 
-au1000_pcmcia_set_mem_map(unsigned int sock, struct pccard_mem_map *map)
+static struct pccard_operations au1x00_pcmcia_operations = {
+	.init			= au1x00_pcmcia_sock_init,
+	.suspend		= au1x00_pcmcia_suspend,
+	.get_status		= au1x00_pcmcia_get_status,
+	.get_socket		= au1x00_pcmcia_get_socket,
+	.set_socket		= au1x00_pcmcia_set_socket,
+	.set_io_map		= au1x00_pcmcia_set_io_map,
+	.set_mem_map		= au1x00_pcmcia_set_mem_map,
+};
+
+static const char *skt_names[] = {
+	"PCMCIA socket 0",
+	"PCMCIA socket 1",
+};
+
+struct skt_dev_info {
+	int nskt;
+};
+
+int au1x00_pcmcia_socket_probe(struct device *dev, struct pcmcia_low_level *ops, int first, int nr)
 {
-	unsigned int speed;
-	u_long flags;
+	struct skt_dev_info *sinfo;
+	int ret, i;
 
-	if(map->map>=MAX_WIN){
-		printk(KERN_ERR "%s(): map (%d) out of range\n", 
-				__FUNCTION__, map->map);
-		return -1;
+	sinfo = kmalloc(sizeof(struct skt_dev_info), GFP_KERNEL);
+	if (!sinfo) {
+		ret = -ENOMEM;
+		goto out;
 	}
 
-	if(map->flags&MAP_ACTIVE){
-		speed=(map->speed>0)?map->speed:AU1000_PCMCIA_MEM_SPEED;
+	memset(sinfo, 0, sizeof(struct skt_dev_info));
+	sinfo->nskt = nr;
 
-		/* TBD */
-		if(map->flags&MAP_ATTRIB){
-			pcmcia_socket[sock].speed_attr=speed;
-		} 
-		else {
-			pcmcia_socket[sock].speed_mem=speed;
+	/*
+	 * Initialise the per-socket structure.
+	 */
+	for (i = 0; i < nr; i++) {
+		struct au1000_pcmcia_socket *skt = PCMCIA_SOCKET(i);
+		memset(skt, 0, sizeof(*skt));
+
+		skt->socket.ops = &au1x00_pcmcia_operations;
+		skt->socket.owner = ops->owner;
+		skt->socket.dev.dev = dev;
+
+		init_timer(&skt->poll_timer);
+		skt->poll_timer.function = au1x00_pcmcia_poll_event;
+		skt->poll_timer.data = (unsigned long)skt;
+		skt->poll_timer.expires = jiffies + AU1000_PCMCIA_POLL_PERIOD;
+
+		skt->nr		= first + i;
+		skt->irq	= 255;
+		skt->dev	= dev;
+		skt->ops	= ops;
+
+		skt->res_skt.name	= skt_names[skt->nr];
+		skt->res_io.name	= "io";
+		skt->res_io.flags	= IORESOURCE_MEM | IORESOURCE_BUSY;
+		skt->res_mem.name	= "memory";
+		skt->res_mem.flags	= IORESOURCE_MEM;
+		skt->res_attr.name	= "attribute";
+		skt->res_attr.flags	= IORESOURCE_MEM;
+
+		/*
+		 * PCMCIA client drivers use the inb/outb macros to access the
+		 * IO registers. Since mips_io_port_base is added to the
+		 * access address of the mips implementation of inb/outb,
+		 * we need to subtract it here because we want to access the
+		 * I/O or MEM address directly, without going through this
+		 * "mips_io_port_base" mechanism.
+		 */
+		if (i == 0) {
+			skt->virt_io = (void *)
+				(ioremap((phys_t)AU1X_SOCK0_IO, 0x1000) -
+				(u32)mips_io_port_base);
+			skt->phys_attr = AU1X_SOCK0_PSEUDO_PHYS_ATTR;
+			skt->phys_mem = AU1X_SOCK0_PSEUDO_PHYS_MEM;
 		}
-	}
+#ifndef CONFIG_MIPS_XXS1500
+		else  {
+			skt->virt_io = (void *)
+				(ioremap((phys_t)AU1X_SOCK1_IO, 0x1000) -
+				(u32)mips_io_port_base);
+			skt->phys_attr = AU1X_SOCK1_PSEUDO_PHYS_ATTR;
+			skt->phys_mem = AU1X_SOCK1_PSEUDO_PHYS_MEM;
+		}
+#endif
+		pcmcia_base_vaddrs[i] = (u32 *)skt->virt_io;
+		ret = ops->hw_init(skt);
 
-	spin_lock_irqsave(&pcmcia_lock, flags);
-	if (map->flags & MAP_ATTRIB) {
-		map->static_start = pcmcia_socket[sock].phys_attr + 
-			map->card_start;
-	}
-	else {
-		map->static_start = pcmcia_socket[sock].phys_mem + 
-			map->card_start;
+		skt->socket.features = SS_CAP_STATIC_MAP|SS_CAP_PCCARD;
+		skt->socket.irq_mask = 0;
+		skt->socket.map_size = MAP_SIZE;
+		skt->socket.pci_irq = skt->irq;
+		skt->socket.io_offset = (unsigned long)skt->virt_io;
+
+		skt->status = au1x00_pcmcia_skt_state(skt);
+
+		ret = pcmcia_register_socket(&skt->socket);
+		if (ret)
+			goto out_err;
+
+		WARN_ON(skt->socket.sock != i);
+
+		add_timer(&skt->poll_timer);
 	}
 
-	pcmcia_socket[sock].mem_map[map->map]=*map;
-	spin_unlock_irqrestore(&pcmcia_lock, flags);
-	debug(3, "set_mem_map %d start %x card_start %x\n", 
-			map->map, map->static_start,
-			map->card_start);
+	dev_set_drvdata(dev, sinfo);
 	return 0;
 
-}  /* au1000_pcmcia_set_mem_map() */
+	do {
+		struct au1000_pcmcia_socket *skt = PCMCIA_SOCKET(i);
+
+		del_timer_sync(&skt->poll_timer);
+		pcmcia_unregister_socket(&skt->socket);
+out_err:
+		flush_scheduled_work();
+		ops->hw_shutdown(skt);
+
+		i--;
+	} while (i > 0);
+	kfree(sinfo);
+out:
+	return ret;
+}
+
+int au1x00_drv_pcmcia_remove(struct device *dev)
+{
+	struct skt_dev_info *sinfo = dev_get_drvdata(dev);
+	int i;
+
+	down(&pcmcia_sockets_lock);
+	dev_set_drvdata(dev, NULL);
 
+	for (i = 0; i < sinfo->nskt; i++) {
+		struct au1000_pcmcia_socket *skt = PCMCIA_SOCKET(i);
+
+		del_timer_sync(&skt->poll_timer);
+		pcmcia_unregister_socket(&skt->socket);
+		flush_scheduled_work();
+		skt->ops->hw_shutdown(skt);
+		au1x00_pcmcia_config_skt(skt, &dead_socket);
+		iounmap(skt->virt_io);
+		skt->virt_io = NULL;
+	}
+
+	kfree(sinfo);
+	up(&pcmcia_sockets_lock);
+	return 0;
+}
 
-#if defined(CONFIG_PROC_FS)
 
-static void 
-au1000_pcmcia_proc_setup(unsigned int sock, struct proc_dir_entry *base)
+/*
+ * PCMCIA "Driver" API
+ */
+
+static int au1x00_drv_pcmcia_probe(struct device *dev)
 {
-	struct proc_dir_entry *entry;
+	int i, ret = -ENODEV;
 
-	if((entry=create_proc_entry("status", 0, base))==NULL){
-		printk(KERN_ERR "Unable to install \"status\" procfs entry\n");
-		return;
+	down(&pcmcia_sockets_lock);
+	for (i=0; i < ARRAY_SIZE(au1x00_pcmcia_hw_init); i++) {
+		ret = au1x00_pcmcia_hw_init[i](dev);
+		if (ret == 0)
+			break;
 	}
+	up(&pcmcia_sockets_lock);
+	return ret;
+}
 
-	entry->read_proc=au1000_pcmcia_proc_status;
-	entry->data=(void *)sock;
+
+static int au1x00_drv_pcmcia_suspend(struct device *dev, u32 state, u32 level)
+{
+	int ret = 0;
+	if (level == SUSPEND_SAVE_STATE)
+		ret = pcmcia_socket_dev_suspend(dev, state);
+	return ret;
 }
 
+static int au1x00_drv_pcmcia_resume(struct device *dev, u32 level)
+{
+	int ret = 0;
+	if (level == RESUME_RESTORE_STATE)
+		ret = pcmcia_socket_dev_resume(dev);
+	return ret;
+}
+
+
+static struct device_driver au1x00_pcmcia_driver = {
+	.probe		= au1x00_drv_pcmcia_probe,
+	.remove		= au1x00_drv_pcmcia_remove,
+	.name		= "au1x00-pcmcia",
+	.bus		= &platform_bus_type,
+	.suspend	= au1x00_drv_pcmcia_suspend,
+	.resume		= au1x00_drv_pcmcia_resume
+};
+
+static struct platform_device au1x00_device = {
+	.name = "au1x00-pcmcia",
+	.id = 0,
+};
 
-/* au1000_pcmcia_proc_status()
- * Implements the /proc/bus/pccard/??/status file.
+/* au1x00_pcmcia_init()
  *
- * Returns: the number of characters added to the buffer
+ * This routine performs low-level PCMCIA initialization and then
+ * registers this socket driver with Card Services.
+ *
+ * Returns: 0 on success, -ve error code on failure
  */
-static int 
-au1000_pcmcia_proc_status(char *buf, char **start, off_t pos, 
-		int count, int *eof, void *data)
+static int __init au1x00_pcmcia_init(void)
 {
-	char *p=buf;
-	unsigned int sock=(unsigned int)data;
-
-	p+=sprintf(p, "k_flags  : %s%s%s%s%s%s%s\n", 
-	     pcmcia_socket[sock].k_state.detect?"detect ":"",
-	     pcmcia_socket[sock].k_state.ready?"ready ":"",
-	     pcmcia_socket[sock].k_state.bvd1?"bvd1 ":"",
-	     pcmcia_socket[sock].k_state.bvd2?"bvd2 ":"",
-	     pcmcia_socket[sock].k_state.wrprot?"wrprot ":"",
-	     pcmcia_socket[sock].k_state.vs_3v?"vs_3v ":"",
-	     pcmcia_socket[sock].k_state.vs_Xv?"vs_Xv ":"");
-
-	p+=sprintf(p, "status   : %s%s%s%s%s%s%s%s%s\n",
-	     pcmcia_socket[sock].k_state.detect?"SS_DETECT ":"",
-	     pcmcia_socket[sock].k_state.ready?"SS_READY ":"",
-	     pcmcia_socket[sock].cs_state.Vcc?"SS_POWERON ":"",
-	     pcmcia_socket[sock].cs_state.flags&SS_IOCARD?\
-	     "SS_IOCARD ":"",
-	     (pcmcia_socket[sock].cs_state.flags&SS_IOCARD &&
-	      pcmcia_socket[sock].k_state.bvd1)?"SS_STSCHG ":"",
-	     ((pcmcia_socket[sock].cs_state.flags&SS_IOCARD)==0 &&
-	      (pcmcia_socket[sock].k_state.bvd1==0))?"SS_BATDEAD ":"",
-	     ((pcmcia_socket[sock].cs_state.flags&SS_IOCARD)==0 &&
-	      (pcmcia_socket[sock].k_state.bvd2==0))?"SS_BATWARN ":"",
-	     pcmcia_socket[sock].k_state.vs_3v?"SS_3VCARD ":"",
-	     pcmcia_socket[sock].k_state.vs_Xv?"SS_XVCARD ":"");
-
-	p+=sprintf(p, "mask     : %s%s%s%s%s\n",
-	     pcmcia_socket[sock].cs_state.csc_mask&SS_DETECT?\
-	     "SS_DETECT ":"",
-	     pcmcia_socket[sock].cs_state.csc_mask&SS_READY?\
-	     "SS_READY ":"",
-	     pcmcia_socket[sock].cs_state.csc_mask&SS_BATDEAD?\
-	     "SS_BATDEAD ":"",
-	     pcmcia_socket[sock].cs_state.csc_mask&SS_BATWARN?\
-	     "SS_BATWARN ":"",
-	     pcmcia_socket[sock].cs_state.csc_mask&SS_STSCHG?\
-	     "SS_STSCHG ":"");
-
-	p+=sprintf(p, "cs_flags : %s%s%s%s%s\n",
-	     pcmcia_socket[sock].cs_state.flags&SS_PWR_AUTO?\
-	     "SS_PWR_AUTO ":"",
-	     pcmcia_socket[sock].cs_state.flags&SS_IOCARD?\
-	     "SS_IOCARD ":"",
-	     pcmcia_socket[sock].cs_state.flags&SS_RESET?\
-	     "SS_RESET ":"",
-	     pcmcia_socket[sock].cs_state.flags&SS_SPKR_ENA?\
-	     "SS_SPKR_ENA ":"",
-	     pcmcia_socket[sock].cs_state.flags&SS_OUTPUT_ENA?\
-	     "SS_OUTPUT_ENA ":"");
-
-	p+=sprintf(p, "Vcc      : %d\n", pcmcia_socket[sock].cs_state.Vcc);
-	p+=sprintf(p, "Vpp      : %d\n", pcmcia_socket[sock].cs_state.Vpp);
-	p+=sprintf(p, "irq      : %d\n", pcmcia_socket[sock].cs_state.io_irq);
-	p+=sprintf(p, "I/O      : %u\n", pcmcia_socket[sock].speed_io);
-	p+=sprintf(p, "attribute: %u\n", pcmcia_socket[sock].speed_attr);
-	p+=sprintf(p, "common   : %u\n", pcmcia_socket[sock].speed_mem);
-	return p-buf;
+	int error = 0;
+	if ((error = driver_register(&au1x00_pcmcia_driver)))
+		return error;
+	platform_device_register(&au1x00_device);
+	return error;
 }
 
+/* au1x00_pcmcia_exit()
+ * Invokes the low-level kernel service to free IRQs associated with this
+ * socket controller and reset GPIO edge detection.
+ */
+static void __exit au1x00_pcmcia_exit(void)
+{
+	driver_unregister(&au1x00_pcmcia_driver);
+	platform_device_unregister(&au1x00_device);
+}
 
-#endif  /* defined(CONFIG_PROC_FS) */
+module_init(au1x00_pcmcia_init);
+module_exit(au1x00_pcmcia_exit);
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_generic.h linux-2.6.11-rc3/drivers/pcmcia/au1000_generic.h
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_generic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/au1000_generic.h	2005-02-03 02:57:16.000000000 +0100
@@ -0,0 +1,150 @@
+/*
+ * Alchemy Semi Au1000 pcmcia driver include file
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#ifndef __ASM_AU1000_PCMCIA_H
+#define __ASM_AU1000_PCMCIA_H
+
+/* include the world */
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/bulkmem.h>
+#include <pcmcia/cistpl.h>
+#include "cs_internal.h"
+
+#define AU1000_PCMCIA_POLL_PERIOD    (2*HZ)
+#define AU1000_PCMCIA_IO_SPEED       (255)
+#define AU1000_PCMCIA_MEM_SPEED      (300)
+
+#define AU1X_SOCK0_IO        0xF00000000
+#define AU1X_SOCK0_PHYS_ATTR 0xF40000000
+#define AU1X_SOCK0_PHYS_MEM  0xF80000000
+/* pseudo 32 bit phys addresses, which get fixed up to the
+ * real 36 bit address in fixup_bigphys_addr() */
+#define AU1X_SOCK0_PSEUDO_PHYS_ATTR 0xF4000000
+#define AU1X_SOCK0_PSEUDO_PHYS_MEM  0xF8000000
+
+/* pcmcia socket 1 needs external glue logic so the memory map
+ * differs from board to board.
+ */
+#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500) || defined(CONFIG_MIPS_PB1550)
+#define AU1X_SOCK1_IO        0xF08000000
+#define AU1X_SOCK1_PHYS_ATTR 0xF48000000
+#define AU1X_SOCK1_PHYS_MEM  0xF88000000
+#define AU1X_SOCK1_PSEUDO_PHYS_ATTR 0xF4800000
+#define AU1X_SOCK1_PSEUDO_PHYS_MEM  0xF8800000
+#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_DB1550)
+#define AU1X_SOCK1_IO        0xF04000000
+#define AU1X_SOCK1_PHYS_ATTR 0xF44000000
+#define AU1X_SOCK1_PHYS_MEM  0xF84000000
+#define AU1X_SOCK1_PSEUDO_PHYS_ATTR 0xF4400000
+#define AU1X_SOCK1_PSEUDO_PHYS_MEM  0xF8400000
+#endif
+
+struct pcmcia_state {
+  unsigned detect: 1,
+            ready: 1,
+           wrprot: 1,
+	     bvd1: 1,
+	     bvd2: 1,
+            vs_3v: 1,
+            vs_Xv: 1;
+};
+
+struct pcmcia_configure {
+  unsigned sock: 8,
+            vcc: 8,
+            vpp: 8,
+         output: 1,
+        speaker: 1,
+          reset: 1;
+};
+
+struct pcmcia_irqs {
+	int sock;
+	int irq;
+	const char *str;
+};
+
+
+struct au1000_pcmcia_socket {
+	struct pcmcia_socket socket;
+
+	/*
+	 * Info from low level handler
+	 */
+	struct device		*dev;
+	unsigned int		nr;
+	unsigned int		irq;
+
+	/*
+	 * Core PCMCIA state
+	 */
+	struct pcmcia_low_level *ops;
+
+	unsigned int 		status;
+	socket_state_t		cs_state;
+
+	unsigned short		spd_io[MAX_IO_WIN];
+	unsigned short		spd_mem[MAX_WIN];
+	unsigned short		spd_attr[MAX_WIN];
+
+	struct resource		res_skt;
+	struct resource		res_io;
+	struct resource		res_mem;
+	struct resource		res_attr;
+
+	void *                 	virt_io;
+	ioaddr_t              	phys_io;
+	unsigned int           	phys_attr;
+	unsigned int           	phys_mem;
+	unsigned short        	speed_io, speed_attr, speed_mem;
+
+	unsigned int		irq_state;
+
+	struct timer_list	poll_timer;
+};
+
+struct pcmcia_low_level {
+	struct module *owner;
+
+	int (*hw_init)(struct au1000_pcmcia_socket *);
+	void (*hw_shutdown)(struct au1000_pcmcia_socket *);
+
+	void (*socket_state)(struct au1000_pcmcia_socket *, struct pcmcia_state *);
+	int (*configure_socket)(struct au1000_pcmcia_socket *, struct socket_state_t *);
+
+	/*
+	 * Enable card status IRQs on (re-)initialisation.  This can
+	 * be called at initialisation, power management event, or
+	 * pcmcia event.
+	 */
+	void (*socket_init)(struct au1000_pcmcia_socket *);
+
+	/*
+	 * Disable card status IRQs and PCMCIA bus on suspend.
+	 */
+	void (*socket_suspend)(struct au1000_pcmcia_socket *);
+};
+
+extern int au1x_board_init(struct device *dev);
+
+#endif /* __ASM_AU1000_PCMCIA_H */
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_pb1x00.c linux-2.6.11-rc3/drivers/pcmcia/au1000_pb1x00.c
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_pb1x00.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/au1000_pb1x00.c	2005-02-03 02:55:23.000000000 +0100
@@ -30,6 +30,7 @@
 #include <linux/timer.h>
 #include <linux/mm.h>
 #include <linux/proc_fs.h>
+#include <linux/version.h>
 #include <linux/types.h>
 
 #include <pcmcia/version.h>
@@ -55,7 +56,7 @@
 #define PCMCIA_IRQ AU1000_GPIO_15
 #elif defined (CONFIG_MIPS_PB1500)
 #include <asm/pb1500.h>
-#define PCMCIA_IRQ AU1000_GPIO_11   /* fixme */
+#define PCMCIA_IRQ AU1500_GPIO_203
 #elif defined (CONFIG_MIPS_PB1100)
 #include <asm/pb1100.h>
 #define PCMCIA_IRQ AU1000_GPIO_11
@@ -82,9 +83,9 @@ static int pb1x00_pcmcia_init(struct pcm
 #else /* fixme -- take care of the Pb1500 at some point */
 
 	u16 pcr;
-	pcr = au_readw(PB1100_MEM_PCMCIA) & ~0xf; /* turn off power */
-	pcr &= ~(PB1100_PC_DEASSERT_RST | PB1100_PC_DRV_EN);
-	au_writew(pcr, PB1100_MEM_PCMCIA);
+	pcr = au_readw(PCMCIA_BOARD_REG) & ~0xf; /* turn off power */
+	pcr &= ~(PC_DEASSERT_RST | PC_DRV_EN);
+	au_writew(pcr, PCMCIA_BOARD_REG);
 	au_sync_delay(500);
 	return PCMCIA_NUM_SOCKS;
 #endif
@@ -102,9 +103,9 @@ static int pb1x00_pcmcia_shutdown(void)
 	return 0;
 #else
 	u16 pcr;
-	pcr = au_readw(PB1100_MEM_PCMCIA) & ~0xf; /* turn off power */
-	pcr &= ~(PB1100_PC_DEASSERT_RST | PB1100_PC_DRV_EN);
-	au_writew(pcr, PB1100_MEM_PCMCIA);
+	pcr = au_readw(PCMCIA_BOARD_REG) & ~0xf; /* turn off power */
+	pcr &= ~(PC_DEASSERT_RST | PC_DRV_EN);
+	au_writew(pcr, PCMCIA_BOARD_REG);
 	au_sync_delay(2);
 	return 0;
 #endif
@@ -123,9 +124,14 @@ pb1x00_pcmcia_socket_state(unsigned sock
 	vs0 = (vs0 >> 4) & 0x3;
 	vs1 = (vs1 >> 12) & 0x3;
 #else
-	vs0 = (au_readw(PB1100_BOARD_STATUS) >> 4) & 0x3;
+	vs0 = (au_readw(BOARD_STATUS_REG) >> 4) & 0x3;
+#ifdef CONFIG_MIPS_PB1500
+	inserted0 = !((au_readl(GPIO2_PINSTATE) >> 1) & 0x1); /* gpio 201 */
+#else /* Pb1100 */
 	inserted0 = !((au_readl(SYS_PINSTATERD) >> 9) & 0x1); /* gpio 9 */
 #endif
+	inserted1 = 0;
+#endif
 
 	state->ready = 0;
 	state->vs_Xv = 0;
@@ -145,7 +151,7 @@ pb1x00_pcmcia_socket_state(unsigned sock
 					/* return without setting 'detect' */
 					printk(KERN_ERR "pb1x00 bad VS (%d)\n",
 							vs0);
-					return;
+					return 0;
 			}
 			state->detect = 1;
 		}
@@ -163,7 +169,7 @@ pb1x00_pcmcia_socket_state(unsigned sock
 					/* return without setting 'detect' */
 					printk(KERN_ERR "pb1x00 bad VS (%d)\n",
 							vs1);
-					return;
+					return 0;
 			}
 			state->detect = 1;
 		}
@@ -324,7 +330,7 @@ pb1x00_pcmcia_configure_socket(const str
 
 #else
 
-	pcr = au_readw(PB1100_MEM_PCMCIA) & ~0xf;
+	pcr = au_readw(PCMCIA_BOARD_REG) & ~0xf;
 
 	debug("Vcc %dV Vpp %dV, pcr %x, reset %d\n", 
 			configure->vcc, configure->vpp, pcr, configure->reset);
@@ -383,26 +389,27 @@ pb1x00_pcmcia_configure_socket(const str
 			break;
 	}
 
-	au_writew(pcr, PB1100_MEM_PCMCIA);
+	au_writew(pcr, PCMCIA_BOARD_REG);
 	au_sync_delay(300);
 
 	if (!configure->reset) {
-		pcr |= PB1100_PC_DRV_EN;
-		au_writew(pcr, PB1100_MEM_PCMCIA);
+		pcr |= PC_DRV_EN;
+		au_writew(pcr, PCMCIA_BOARD_REG);
 		au_sync_delay(100);
-		pcr |= PB1100_PC_DEASSERT_RST;
-		au_writew(pcr, PB1100_MEM_PCMCIA);
+		pcr |= PC_DEASSERT_RST;
+		au_writew(pcr, PCMCIA_BOARD_REG);
 		au_sync_delay(100);
 	}
 	else {
-		pcr &= ~(PB1100_PC_DEASSERT_RST | PB1100_PC_DRV_EN);
-		au_writew(pcr, PB1100_MEM_PCMCIA);
+		pcr &= ~(PC_DEASSERT_RST | PC_DRV_EN);
+		au_writew(pcr, PCMCIA_BOARD_REG);
 		au_sync_delay(100);
 	}
 #endif
 	return 0;
 }
 
+
 struct pcmcia_low_level pb1x00_pcmcia_ops = { 
 	pb1x00_pcmcia_init,
 	pb1x00_pcmcia_shutdown,
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_xxs1500.c linux-2.6.11-rc3/drivers/pcmcia/au1000_xxs1500.c
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/au1000_xxs1500.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/au1000_xxs1500.c	2005-02-03 02:56:11.000000000 +0100
@@ -0,0 +1,191 @@
+/*
+ *
+ * MyCable board specific pcmcia routines.
+ *
+ * Copyright 2003 MontaVista Software Inc.
+ * Author: Pete Popov, MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/tqueue.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <linux/types.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/bulkmem.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/bus_ops.h>
+#include "cs_internal.h"
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <asm/au1000.h>
+#include <asm/au1000_pcmcia.h>
+#include <asm/xxs1500.h>
+
+#if 0
+#define DEBUG(x,args...)	printk(__FUNCTION__ ": " x,##args)
+#else
+#define DEBUG(x,args...)
+#endif
+
+static int xxs1500_pcmcia_init(struct pcmcia_init *init)
+{
+	return PCMCIA_NUM_SOCKS;
+}
+
+static int xxs1500_pcmcia_shutdown(void)
+{
+	/* turn off power */
+	au_writel(au_readl(GPIO2_PINSTATE) | (1<<14)|(1<<30),
+			GPIO2_OUTPUT);
+	au_sync_delay(100);
+
+	/* assert reset */
+	au_writel(au_readl(GPIO2_PINSTATE) | (1<<4)|(1<<20),
+			GPIO2_OUTPUT);
+	au_sync_delay(100);
+	return 0;
+}
+
+
+static int
+xxs1500_pcmcia_socket_state(unsigned sock, struct pcmcia_state *state)
+{
+	u32 inserted; u32 vs;
+	unsigned long gpio, gpio2;
+
+	if(sock > PCMCIA_MAX_SOCK) return -1;
+
+	gpio = au_readl(SYS_PINSTATERD);
+	gpio2 = au_readl(GPIO2_PINSTATE);
+
+	vs = gpio2 & ((1<<8) | (1<<9));
+	inserted = (!(gpio & 0x1) && !(gpio & 0x2));
+
+	state->ready = 0;
+	state->vs_Xv = 0;
+	state->vs_3v = 0;
+	state->detect = 0;
+
+	if (inserted) {
+		switch (vs) {
+			case 0:
+			case 1:
+			case 2:
+				state->vs_3v=1;
+				break;
+			case 3: /* 5V */
+			default:
+				/* return without setting 'detect' */
+				printk(KERN_ERR "au1x00_cs: unsupported VS\n",
+						vs);
+				return;
+		}
+		state->detect = 1;
+	}
+
+	if (state->detect) {
+		state->ready = 1;
+	}
+
+	state->bvd1= gpio2 & (1<<10);
+	state->bvd2 = gpio2 & (1<<11);
+	state->wrprot=0;
+	return 1;
+}
+
+
+static int xxs1500_pcmcia_get_irq_info(struct pcmcia_irq_info *info)
+{
+
+	if(info->sock > PCMCIA_MAX_SOCK) return -1;
+	info->irq = PCMCIA_IRQ;
+	return 0;
+}
+
+
+static int
+xxs1500_pcmcia_configure_socket(const struct pcmcia_configure *configure)
+{
+
+	if(configure->sock > PCMCIA_MAX_SOCK) return -1;
+
+	DEBUG("Vcc %dV Vpp %dV, reset %d\n",
+			configure->vcc, configure->vpp, configure->reset);
+
+	switch(configure->vcc){
+		case 33: /* Vcc 3.3V */
+			/* turn on power */
+			DEBUG("turn on power\n");
+			au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<14))|(1<<30),
+					GPIO2_OUTPUT);
+			au_sync_delay(100);
+			break;
+		case 50: /* Vcc 5V */
+		default: /* what's this ? */
+			printk(KERN_ERR "au1x00_cs: unsupported VCC\n");
+		case 0:  /* Vcc 0 */
+			/* turn off power */
+			au_sync_delay(100);
+			au_writel(au_readl(GPIO2_PINSTATE) | (1<<14)|(1<<30),
+					GPIO2_OUTPUT);
+			break;
+	}
+
+	if (!configure->reset) {
+		DEBUG("deassert reset\n");
+		au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<4))|(1<<20),
+				GPIO2_OUTPUT);
+		au_sync_delay(100);
+		au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<5))|(1<<21),
+				GPIO2_OUTPUT);
+	}
+	else {
+		DEBUG("assert reset\n");
+		au_writel(au_readl(GPIO2_PINSTATE) | (1<<4)|(1<<20),
+				GPIO2_OUTPUT);
+	}
+	au_sync_delay(100);
+	return 0;
+}
+
+struct pcmcia_low_level xxs1500_pcmcia_ops = {
+	xxs1500_pcmcia_init,
+	xxs1500_pcmcia_shutdown,
+	xxs1500_pcmcia_socket_state,
+	xxs1500_pcmcia_get_irq_info,
+	xxs1500_pcmcia_configure_socket
+};
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/vrc4171_card.c linux-2.6.11-rc3/drivers/pcmcia/vrc4171_card.c
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/vrc4171_card.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/vrc4171_card.c	2005-02-03 02:56:53.000000000 +0100
@@ -0,0 +1,744 @@
+/*
+ * vrc4171_card.c, NEC VRC4171 Card Controller driver for Socket Services.
+ *
+ * Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+#include <asm/vr41xx/vrc4171.h>
+
+#include <pcmcia/ss.h>
+
+#include "i82365.h"
+
+MODULE_DESCRIPTION("NEC VRC4171 Card Controllers driver for Socket Services");
+MODULE_AUTHOR("Yoichi Yuasa <yuasa@hh.iij4u.or.jp>");
+MODULE_LICENSE("GPL");
+
+#define CARD_MAX_SLOTS		2
+#define CARD_SLOTA		0
+#define CARD_SLOTB		1
+#define CARD_SLOTB_OFFSET	0x40
+
+#define CARD_MEM_START		0x10000000
+#define CARD_MEM_END		0x13ffffff
+#define CARD_MAX_MEM_OFFSET	0x3ffffff
+#define CARD_MAX_MEM_SPEED	1000
+
+#define CARD_CONTROLLER_INDEX	0x03e0
+#define CARD_CONTROLLER_DATA	0x03e1
+#define CARD_CONTROLLER_SIZE	2
+ /* Power register */
+  #define VPP_GET_VCC		0x01
+  #define POWER_ENABLE		0x10
+ #define CARD_VOLTAGE_SENSE	0x1f
+  #define VCC_3VORXV_CAPABLE	0x00
+  #define VCC_XV_ONLY		0x01
+  #define VCC_3V_CAPABLE	0x02
+  #define VCC_5V_ONLY		0x03
+ #define CARD_VOLTAGE_SELECT	0x2f
+  #define VCC_3V		0x01
+  #define VCC_5V		0x00
+  #define VCC_XV		0x02
+  #define VCC_STATUS_3V		0x02
+  #define VCC_STATUS_5V		0x01
+  #define VCC_STATUS_XV		0x03
+ #define GLOBAL_CONTROL		0x1e
+  #define EXWRBK		0x04
+  #define IRQPM_EN		0x08
+  #define CLRPMIRQ		0x10
+
+#define IO_MAX_MAPS	2
+#define MEM_MAX_MAPS	5
+
+enum {
+	SLOT_PROBE = 0,
+	SLOT_NOPROBE_IO,
+	SLOT_NOPROBE_MEM,
+	SLOT_NOPROBE_ALL
+};
+
+typedef struct vrc4171_socket {
+	int noprobe;
+	struct pcmcia_socket pcmcia_socket;
+	char name[24];
+	int csc_irq;
+	int io_irq;
+} vrc4171_socket_t;
+
+static vrc4171_socket_t vrc4171_sockets[CARD_MAX_SLOTS];
+static int vrc4171_slotb = SLOTB_IS_NONE;
+static unsigned int vrc4171_irq;
+static uint16_t vrc4171_irq_mask = 0xdeb8;
+
+static inline uint8_t exca_read_byte(int slot, uint8_t index)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	return inb(CARD_CONTROLLER_DATA);
+}
+
+static inline uint16_t exca_read_word(int slot, uint8_t index)
+{
+	uint16_t data;
+
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index++, CARD_CONTROLLER_INDEX);
+	data = inb(CARD_CONTROLLER_DATA);
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	data |= ((uint16_t)inb(CARD_CONTROLLER_DATA)) << 8;
+
+	return data;
+}
+
+static inline uint8_t exca_write_byte(int slot, uint8_t index, uint8_t data)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	outb(data, CARD_CONTROLLER_DATA);
+
+	return data;
+}
+
+static inline uint16_t exca_write_word(int slot, uint8_t index, uint16_t data)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index++, CARD_CONTROLLER_INDEX);
+	outb(data, CARD_CONTROLLER_DATA);
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	outb((uint8_t)(data >> 8), CARD_CONTROLLER_DATA);
+
+	return data;
+}
+
+static inline int search_nonuse_irq(void)
+{
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		if (vrc4171_irq_mask & (1 << i)) {
+			vrc4171_irq_mask &= ~(1 << i);
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static int pccard_init(struct pcmcia_socket *sock)
+{
+	vrc4171_socket_t *socket;
+	unsigned int slot;
+
+	sock->features |= SS_CAP_PCCARD | SS_CAP_PAGE_REGS;
+	sock->irq_mask = 0;
+	sock->map_size = 0x1000;
+	sock->pci_irq = vrc4171_irq;
+
+	slot = sock->sock;
+	socket = &vrc4171_sockets[slot];
+	socket->csc_irq = search_nonuse_irq();
+	socket->io_irq = search_nonuse_irq();
+
+	return 0;
+}
+
+static int pccard_suspend(struct pcmcia_socket *sock)
+{
+	return -EINVAL;
+}
+
+static int pccard_get_status(struct pcmcia_socket *sock, u_int *value)
+{
+	unsigned int slot;
+	uint8_t status, sense;
+	u_int val = 0;
+
+	if (sock == NULL || sock->sock >= CARD_MAX_SLOTS || value == NULL)
+		return -EINVAL;
+
+	slot = sock->sock;
+
+	status = exca_read_byte(slot, I365_STATUS);
+	if (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {
+		if (status & I365_CS_STSCHG)
+			val |= SS_STSCHG;
+	} else {
+		if (!(status & I365_CS_BVD1))
+			val |= SS_BATDEAD;
+		else if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)
+			val |= SS_BATWARN;
+	}
+	if ((status & I365_CS_DETECT) == I365_CS_DETECT)
+		val |= SS_DETECT;
+	if (status & I365_CS_WRPROT)
+		val |= SS_WRPROT;
+	if (status & I365_CS_READY)
+		val |= SS_READY;
+	if (status & I365_CS_POWERON)
+		val |= SS_POWERON;
+
+	sense = exca_read_byte(slot, CARD_VOLTAGE_SENSE);
+	switch (sense) {
+	case VCC_3VORXV_CAPABLE:
+		val |= SS_3VCARD | SS_XVCARD;
+		break;
+	case VCC_XV_ONLY:
+		val |= SS_XVCARD;
+		break;
+	case VCC_3V_CAPABLE:
+		val |= SS_3VCARD;
+		break;
+	default:
+		/* 5V only */
+		break;
+	}
+
+	*value = val;
+
+	return 0;
+}
+
+static inline u_char get_Vcc_value(uint8_t voltage)
+{
+	switch (voltage) {
+	case VCC_STATUS_3V:
+		return 33;
+	case VCC_STATUS_5V:
+		return 50;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static inline u_char get_Vpp_value(uint8_t power, u_char Vcc)
+{
+	if ((power & 0x03) == 0x01 || (power & 0x03) == 0x02)
+		return Vcc;
+
+	return 0;
+}
+
+static int pccard_get_socket(struct pcmcia_socket *sock, socket_state_t *state)
+{
+	unsigned int slot;
+	uint8_t power, voltage, control, cscint;
+
+	if (sock == NULL || sock->sock >= CARD_MAX_SLOTS || state == NULL)
+		return -EINVAL;
+
+	slot = sock->sock;
+
+	power = exca_read_byte(slot, I365_POWER);
+	voltage = exca_read_byte(slot, CARD_VOLTAGE_SELECT);
+
+	state->Vcc = get_Vcc_value(voltage);
+	state->Vpp = get_Vpp_value(power, state->Vcc);
+
+	state->flags = 0;
+	if (power & POWER_ENABLE)
+		state->flags |= SS_PWR_AUTO;
+	if (power & I365_PWR_OUT)
+		state->flags |= SS_OUTPUT_ENA;
+
+	control = exca_read_byte(slot, I365_INTCTL);
+	if (control & I365_PC_IOCARD)
+		state->flags |= SS_IOCARD;
+	if (!(control & I365_PC_RESET))
+		state->flags |= SS_RESET;
+
+        cscint = exca_read_byte(slot, I365_CSCINT);
+	state->csc_mask = 0;
+	if (state->flags & SS_IOCARD) {
+		if (cscint & I365_CSC_STSCHG)
+			state->flags |= SS_STSCHG;
+	} else {
+		if (cscint & I365_CSC_BVD1)
+			state->csc_mask |= SS_BATDEAD;
+		if (cscint & I365_CSC_BVD2)
+			state->csc_mask |= SS_BATWARN;
+	}
+	if (cscint & I365_CSC_READY)
+		state->csc_mask |= SS_READY;
+	if (cscint & I365_CSC_DETECT)
+		state->csc_mask |= SS_DETECT;
+
+	return 0;
+}
+
+static inline uint8_t set_Vcc_value(u_char Vcc)
+{
+	switch (Vcc) {
+	case 33:
+		return VCC_3V;
+	case 50:
+		return VCC_5V;
+	}
+
+	/* Small voltage is chosen for safety. */
+	return VCC_3V;
+}
+
+static int pccard_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
+{
+	vrc4171_socket_t *socket;
+	unsigned int slot;
+	uint8_t voltage, power, control, cscint;
+
+	if (sock == NULL || sock->sock >= CARD_MAX_SLOTS ||
+	    (state->Vpp != state->Vcc && state->Vpp != 0) ||
+	    (state->Vcc != 50 && state->Vcc != 33 && state->Vcc != 0))
+		return -EINVAL;
+
+	slot = sock->sock;
+	socket = &vrc4171_sockets[slot];
+
+	spin_lock_irq(&sock->lock);
+
+	voltage = set_Vcc_value(state->Vcc);
+	exca_write_byte(slot, CARD_VOLTAGE_SELECT, voltage);
+
+	power = POWER_ENABLE;
+	if (state->Vpp == state->Vcc)
+		power |= VPP_GET_VCC;
+	if (state->flags & SS_OUTPUT_ENA)
+		power |= I365_PWR_OUT;
+	exca_write_byte(slot, I365_POWER, power);
+
+	control = 0;
+	if (state->io_irq != 0)
+		control |= socket->io_irq;
+	if (state->flags & SS_IOCARD)
+		control |= I365_PC_IOCARD;
+	if (state->flags & SS_RESET)
+		control	&= ~I365_PC_RESET;
+	else
+		control |= I365_PC_RESET;
+	exca_write_byte(slot, I365_INTCTL, control);
+
+        cscint = 0;
+        exca_write_byte(slot, I365_CSCINT, cscint);
+	exca_read_byte(slot, I365_CSC);	/* clear CardStatus change */
+	if (state->csc_mask != 0)
+		cscint |= socket->csc_irq << 8;
+	if (state->flags & SS_IOCARD) {
+		if (state->csc_mask & SS_STSCHG)
+			cscint |= I365_CSC_STSCHG;
+	} else {
+		if (state->csc_mask & SS_BATDEAD)
+			cscint |= I365_CSC_BVD1;
+		if (state->csc_mask & SS_BATWARN)
+			cscint |= I365_CSC_BVD2;
+	}
+	if (state->csc_mask & SS_READY)
+		cscint |= I365_CSC_READY;
+	if (state->csc_mask & SS_DETECT)
+		cscint |= I365_CSC_DETECT;
+        exca_write_byte(slot, I365_CSCINT, cscint);
+
+	spin_unlock_irq(&sock->lock);
+
+	return 0;
+}
+
+static int pccard_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io)
+{
+	unsigned int slot;
+	uint8_t ioctl, addrwin;
+	u_char map;
+
+	if (sock == NULL || sock->sock >= CARD_MAX_SLOTS ||
+	    io == NULL || io->map >= IO_MAX_MAPS ||
+	    io->start > 0xffff || io->stop > 0xffff || io->start > io->stop)
+		return -EINVAL;
+
+	slot = sock->sock;
+	map = io->map;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_IO(map)) {
+		addrwin &= ~I365_ENA_IO(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	exca_write_word(slot, I365_IO(map)+I365_W_START, io->start);
+	exca_write_word(slot, I365_IO(map)+I365_W_STOP, io->stop);
+
+	ioctl = 0;
+	if (io->speed > 0)
+		ioctl |= I365_IOCTL_WAIT(map);
+	if (io->flags & MAP_16BIT)
+		ioctl |= I365_IOCTL_16BIT(map);
+	if (io->flags & MAP_AUTOSZ)
+		ioctl |= I365_IOCTL_IOCS16(map);
+	if (io->flags & MAP_0WS)
+		ioctl |= I365_IOCTL_0WS(map);
+	exca_write_byte(slot, I365_IOCTL, ioctl);
+
+	if (io->flags & MAP_ACTIVE) {
+		addrwin |= I365_ENA_IO(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	return 0;
+}
+
+static int pccard_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *mem)
+{
+	unsigned int slot;
+	uint16_t start, stop, offset;
+	uint8_t addrwin;
+	u_char map;
+
+	if (sock == NULL || sock->sock >= CARD_MAX_SLOTS ||
+	    mem == NULL || mem->map >= MEM_MAX_MAPS ||
+	    mem->sys_start < CARD_MEM_START || mem->sys_start > CARD_MEM_END ||
+	    mem->sys_stop < CARD_MEM_START || mem->sys_stop > CARD_MEM_END ||
+	    mem->sys_start > mem->sys_stop ||
+	    mem->card_start > CARD_MAX_MEM_OFFSET ||
+	    mem->speed > CARD_MAX_MEM_SPEED)
+		return -EINVAL;
+
+	slot = sock->sock;
+	map = mem->map;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_MEM(map)) {
+		addrwin &= ~I365_ENA_MEM(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	start = (mem->sys_start >> 12) & 0x3fff;
+	if (mem->flags & MAP_16BIT)
+		start |= I365_MEM_16BIT;
+	exca_write_word(slot, I365_MEM(map)+I365_W_START, start);
+
+	stop = (mem->sys_stop >> 12) & 0x3fff;
+	switch (mem->speed) {
+	case 0:
+		break;
+	case 1:
+		stop |= I365_MEM_WS0;
+		break;
+	case 2:
+		stop |= I365_MEM_WS1;
+		break;
+	default:
+		stop |= I365_MEM_WS0 | I365_MEM_WS1;
+		break;
+	}
+	exca_write_word(slot, I365_MEM(map)+I365_W_STOP, stop);
+
+	offset = (mem->card_start >> 12) & 0x3fff;
+	if (mem->flags & MAP_ATTRIB)
+		offset |= I365_MEM_REG;
+	if (mem->flags & MAP_WRPROT)
+		offset |= I365_MEM_WRPROT;
+	exca_write_word(slot, I365_MEM(map)+I365_W_OFF, offset);
+
+	if (mem->flags & MAP_ACTIVE) {
+		addrwin |= I365_ENA_MEM(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	return 0;
+}
+
+static struct pccard_operations vrc4171_pccard_operations = {
+	.init			= pccard_init,
+	.suspend		= pccard_suspend,
+	.get_status		= pccard_get_status,
+	.get_socket		= pccard_get_socket,
+	.set_socket		= pccard_set_socket,
+	.set_io_map		= pccard_set_io_map,
+	.set_mem_map		= pccard_set_mem_map,
+};
+
+static inline unsigned int get_events(int slot)
+{
+	unsigned int events = 0;
+	uint8_t status, csc;
+
+	status = exca_read_byte(slot, I365_STATUS);
+	csc = exca_read_byte(slot, I365_CSC);
+
+	if (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {
+		if ((csc & I365_CSC_STSCHG) && (status & I365_CS_STSCHG))
+			events |= SS_STSCHG;
+	} else {
+		if (csc & (I365_CSC_BVD1 | I365_CSC_BVD2)) {
+			if (!(status & I365_CS_BVD1))
+				events |= SS_BATDEAD;
+			else if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)
+				events |= SS_BATWARN;
+		}
+	}
+	if ((csc & I365_CSC_READY) && (status & I365_CS_READY))
+		events |= SS_READY;
+	if ((csc & I365_CSC_DETECT) && ((status & I365_CS_DETECT) == I365_CS_DETECT))
+		events |= SS_DETECT;
+
+	return events;
+}
+
+static irqreturn_t pccard_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	vrc4171_socket_t *socket;
+	unsigned int events;
+	irqreturn_t retval = IRQ_NONE;
+	uint16_t status;
+
+	status = vrc4171_get_irq_status();
+	if (status & IRQ_A) {
+		socket = &vrc4171_sockets[CARD_SLOTA];
+		if (socket->noprobe == SLOT_PROBE) {
+			if (status & (1 << socket->csc_irq)) {
+				events = get_events(CARD_SLOTA);
+				if (events != 0) {
+					pcmcia_parse_events(&socket->pcmcia_socket, events);
+					retval = IRQ_HANDLED;
+				}
+			}
+		}
+	}
+
+	if (status & IRQ_B) {
+		socket = &vrc4171_sockets[CARD_SLOTB];
+		if (socket->noprobe == SLOT_PROBE) {
+			if (status & (1 << socket->csc_irq)) {
+				events = get_events(CARD_SLOTB);
+				if (events != 0) {
+					pcmcia_parse_events(&socket->pcmcia_socket, events);
+					retval = IRQ_HANDLED;
+				}
+			}
+		}
+	}
+
+	return retval;
+}
+
+static inline void reserve_using_irq(int slot)
+{
+	unsigned int irq;
+
+	irq = exca_read_byte(slot, I365_INTCTL);
+	irq &= 0x0f;
+	vrc4171_irq_mask &= ~(1 << irq);
+
+	irq = exca_read_byte(slot, I365_CSCINT);
+	irq = (irq & 0xf0) >> 4;
+	vrc4171_irq_mask &= ~(1 << irq);
+}
+
+static int __devinit vrc4171_add_socket(int slot)
+{
+	vrc4171_socket_t *socket;
+	int retval;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	if (socket->noprobe != SLOT_PROBE) {
+		uint8_t addrwin;
+
+		switch (socket->noprobe) {
+		case SLOT_NOPROBE_MEM:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0x1f;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		case SLOT_NOPROBE_IO:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0xc0;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		default:
+			break;
+		}
+
+		reserve_using_irq(slot);
+
+		return 0;
+	}
+
+	sprintf(socket->name, "NEC VRC4171 Card Slot %1c", 'A' + slot);
+
+	socket->pcmcia_socket.ops = &vrc4171_pccard_operations;
+
+	retval = pcmcia_register_socket(&socket->pcmcia_socket);
+	if (retval != 0)
+		return retval;
+
+	exca_write_byte(slot, I365_ADDRWIN, 0);
+
+	exca_write_byte(slot, GLOBAL_CONTROL, 0);
+
+	return 0;
+}
+
+static void vrc4171_remove_socket(int slot)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return;
+
+	socket = &vrc4171_sockets[slot];
+
+	pcmcia_unregister_socket(&socket->pcmcia_socket);
+}
+
+static int __devinit vrc4171_card_setup(char *options)
+{
+	if (options == NULL || *options == '\0')
+		return 0;
+
+	if (strncmp(options, "irq:", 4) == 0) {
+		int irq;
+		options += 4;
+		irq = simple_strtoul(options, &options, 0);
+		if (irq >= 0 && irq < NR_IRQS)
+			vrc4171_irq = irq;
+
+		if (*options != ',')
+			return 0;
+		options++;
+	}
+
+	if (strncmp(options, "slota:", 6) == 0) {
+		options += 6;
+		if (*options != '\0') {
+			if (strncmp(options, "memnoprobe", 10) == 0) {
+				vrc4171_sockets[CARD_SLOTA].noprobe = SLOT_NOPROBE_MEM;
+				options += 10;
+			} else if (strncmp(options, "ionoprobe", 9) == 0) {
+				vrc4171_sockets[CARD_SLOTA].noprobe = SLOT_NOPROBE_IO;
+				options += 9;
+			} else if ( strncmp(options, "noprobe", 7) == 0) {
+				vrc4171_sockets[CARD_SLOTA].noprobe = SLOT_NOPROBE_ALL;
+				options += 7;
+			}
+
+			if (*options != ',')
+				return 0;
+			options++;
+		} else
+			return 0;
+
+	}
+
+	if (strncmp(options, "slotb:", 6) == 0) {
+		options += 6;
+		if (*options != '\0') {
+			if (strncmp(options, "pccard", 6) == 0) {
+				vrc4171_slotb = SLOTB_IS_PCCARD;
+				options += 6;
+			} else if (strncmp(options, "cf", 2) == 0) {
+				vrc4171_slotb = SLOTB_IS_CF;
+				options += 2;
+			} else if (strncmp(options, "flashrom", 8) == 0) {
+				vrc4171_slotb = SLOTB_IS_FLASHROM;
+				options += 8;
+			} else if (strncmp(options, "none", 4) == 0) {
+				vrc4171_slotb = SLOTB_IS_NONE;
+				options += 4;
+			}
+
+			if (*options != ',')
+				return 0;
+			options++;
+
+			if (strncmp(options, "memnoprobe", 10) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOT_NOPROBE_MEM;
+			if (strncmp(options, "ionoprobe", 9) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOT_NOPROBE_IO;
+			if (strncmp(options, "noprobe", 7) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOT_NOPROBE_ALL;
+		}
+	}
+
+	return 0;
+}
+
+__setup("vrc4171_card=", vrc4171_card_setup);
+
+static int __devinit vrc4171_card_init(void)
+{
+	int retval, slot;
+
+	vrc4171_set_multifunction_pin(vrc4171_slotb);
+
+	if (request_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE,
+	                       "NEC VRC4171 Card Controller") == NULL)
+		return -EBUSY;
+
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++) {
+		if (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)
+			break;
+
+		retval = vrc4171_add_socket(slot);
+		if (retval != 0)
+			return retval;
+	}
+
+	retval = request_irq(vrc4171_irq, pccard_interrupt, SA_SHIRQ,
+	                     "NEC VRC4171 Card Controller", vrc4171_sockets);
+	if (retval < 0) {
+		for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+			vrc4171_remove_socket(slot);
+
+		return retval;
+	}
+
+	printk(KERN_INFO "NEC VRC4171 Card Controller, connected to IRQ %d\n", vrc4171_irq);
+
+	return 0;
+}
+
+static void __devexit vrc4171_card_exit(void)
+{
+	int slot;
+
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+		vrc4171_remove_socket(slot);
+
+	release_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE);
+}
+
+module_init(vrc4171_card_init);
+module_exit(vrc4171_card_exit);
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/vrc4173_cardu.c linux-2.6.11-rc3/drivers/pcmcia/vrc4173_cardu.c
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/vrc4173_cardu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/vrc4173_cardu.c	2005-02-03 02:55:07.000000000 +0100
@@ -0,0 +1,622 @@
+/*
+ * FILE NAME
+ *	drivers/pcmcia/vrc4173_cardu.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ * 	NEC VRC4173 CARDU driver for Socket Services
+ *	(This device doesn't support CardBus. it is supporting only 16bit PC Card.)
+ *
+ * Copyright 2002,2003 Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+
+#include <pcmcia/ss.h>
+
+#include "vrc4173_cardu.h"
+
+MODULE_DESCRIPTION("NEC VRC4173 CARDU driver for Socket Services");
+MODULE_AUTHOR("Yoichi Yuasa <yuasa@hh.iij4u.or.jp>");
+MODULE_LICENSE("GPL");
+
+static int vrc4173_cardu_slots;
+
+static vrc4173_socket_t cardu_sockets[CARDU_MAX_SOCKETS];
+
+extern struct socket_info_t *pcmcia_register_socket (int slot,
+                                                     struct pccard_operations *vtable,
+                                                     int use_bus_pm);
+extern void pcmcia_unregister_socket(struct socket_info_t *s);
+
+static inline uint8_t exca_readb(vrc4173_socket_t *socket, uint16_t offset)
+{
+	return readb(socket->base + EXCA_REGS_BASE + offset);
+}
+
+static inline uint16_t exca_readw(vrc4173_socket_t *socket, uint16_t offset)
+{
+	uint16_t val;
+
+	val = readb(socket->base + EXCA_REGS_BASE + offset);
+	val |= (u16)readb(socket->base + EXCA_REGS_BASE + offset + 1) << 8;
+
+	return val;
+}
+
+static inline void exca_writeb(vrc4173_socket_t *socket, uint16_t offset, uint8_t val)
+{
+	writeb(val, socket->base + EXCA_REGS_BASE + offset);
+}
+
+static inline void exca_writew(vrc4173_socket_t *socket, uint8_t offset, uint16_t val)
+{
+	writeb((u8)val, socket->base + EXCA_REGS_BASE + offset);
+	writeb((u8)(val >> 8), socket->base + EXCA_REGS_BASE + offset + 1);
+}
+
+static inline uint32_t cardbus_socket_readl(vrc4173_socket_t *socket, u16 offset)
+{
+	return readl(socket->base + CARDBUS_SOCKET_REGS_BASE + offset);
+}
+
+static inline void cardbus_socket_writel(vrc4173_socket_t *socket, u16 offset, uint32_t val)
+{
+	writel(val, socket->base + CARDBUS_SOCKET_REGS_BASE + offset);
+}
+
+static void cardu_pciregs_init(struct pci_dev *dev)
+{
+	u32 syscnt;
+	u16 brgcnt;
+	u8 devcnt;
+
+	pci_write_config_dword(dev, 0x1c, 0x10000000);
+	pci_write_config_dword(dev, 0x20, 0x17fff000);
+	pci_write_config_dword(dev, 0x2c, 0);
+	pci_write_config_dword(dev, 0x30, 0xfffc);
+
+	pci_read_config_word(dev, BRGCNT, &brgcnt);
+	brgcnt &= ~IREQ_INT;
+	pci_write_config_word(dev, BRGCNT, brgcnt);
+
+	pci_read_config_dword(dev, SYSCNT, &syscnt);
+	syscnt &= ~(BAD_VCC_REQ_DISB|PCPCI_EN|CH_ASSIGN_MASK|SUB_ID_WR_EN|PCI_CLK_RIN);
+	syscnt |= (CH_ASSIGN_NODMA|ASYN_INT_MODE);
+	pci_write_config_dword(dev, SYSCNT, syscnt);
+
+	pci_read_config_byte(dev, DEVCNT, &devcnt);
+	devcnt &= ~(ZOOM_VIDEO_EN|SR_PCI_INT_SEL_MASK|PCI_INT_MODE|IRQ_MODE);
+	devcnt |= (SR_PCI_INT_SEL_NONE|IFG);
+	pci_write_config_byte(dev, DEVCNT, devcnt);
+
+	pci_write_config_byte(dev, CHIPCNT, S_PREF_DISB);
+
+	pci_write_config_byte(dev, SERRDIS, 0);
+}
+
+static int cardu_init(unsigned int slot)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[slot];
+
+	cardu_pciregs_init(socket->dev);
+
+	/* CARD_SC bits are cleared by reading CARD_SC. */
+	exca_writeb(socket, GLO_CNT, 0);
+
+	socket->cap.features |= SS_CAP_PCCARD | SS_CAP_PAGE_REGS;
+	socket->cap.irq_mask = 0;
+	socket->cap.map_size = 0x1000;
+	socket->cap.pci_irq  = socket->dev->irq;
+	socket->events = 0;
+	spin_lock_init(socket->event_lock);
+
+	/* Enable PC Card status interrupts */
+	exca_writeb(socket, CARD_SCI, CARD_DT_EN|RDY_EN|BAT_WAR_EN|BAT_DEAD_EN);
+
+	return 0;
+}
+
+static int cardu_suspend(unsigned int slot)
+{
+	return -EINVAL;
+}
+
+static int cardu_register_callback(unsigned int sock,
+                                           void (*handler)(void *, unsigned int),
+                                           void * info)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+
+	socket->handler = handler;
+	socket->info = info;
+
+	return 0;
+}
+
+static int cardu_inquire_socket(unsigned int sock, socket_cap_t *cap)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+
+	*cap = socket->cap;
+
+	return 0;
+}
+
+static int cardu_get_status(unsigned int sock, u_int *value)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint32_t state;
+	uint8_t status;
+	u_int val = 0;
+
+	status = exca_readb(socket, IF_STATUS);
+	if (status & CARD_PWR) val |= SS_POWERON;
+	if (status & READY) val |= SS_READY;
+	if (status & CARD_WP) val |= SS_WRPROT;
+	if ((status & (CARD_DETECT1|CARD_DETECT2)) == (CARD_DETECT1|CARD_DETECT2))
+		val |= SS_DETECT;
+	if (exca_readb(socket, INT_GEN_CNT) & CARD_TYPE_IO) {
+		if (status & STSCHG) val |= SS_STSCHG;
+	} else {
+		status &= BV_DETECT_MASK;
+		if (status != BV_DETECT_GOOD) {
+			if (status == BV_DETECT_WARN) val |= SS_BATWARN;
+			else val |= SS_BATDEAD;
+		}
+	}
+
+	state = cardbus_socket_readl(socket, SKT_PRE_STATE);
+	if (state & VOL_3V_CARD_DT) val |= SS_3VCARD;
+	if (state & VOL_XV_CARD_DT) val |= SS_XVCARD;
+	if (state & CB_CARD_DT) val |= SS_CARDBUS;
+	if (!(state &
+	      (VOL_YV_CARD_DT|VOL_XV_CARD_DT|VOL_3V_CARD_DT|VOL_5V_CARD_DT|CCD20|CCD10)))
+		val |= SS_PENDING;
+
+	*value = val;
+
+	return 0;
+}
+
+static inline u_char get_Vcc_value(uint8_t val)
+{
+	switch (val & VCC_MASK) {
+	case VCC_3V:
+		return 33;
+	case VCC_5V:
+		return 50;
+	}
+
+	return 0;
+}
+
+static inline u_char get_Vpp_value(uint8_t val)
+{
+	switch (val & VPP_MASK) {
+	case VPP_12V:
+		return 120;
+	case VPP_VCC:
+		return get_Vcc_value(val);
+	}
+
+	return 0;
+}
+
+static int cardu_get_socket(unsigned int sock, socket_state_t *state)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint8_t val;
+
+	val = exca_readb(socket, PWR_CNT);
+	state->Vcc = get_Vcc_value(val);
+	state->Vpp = get_Vpp_value(val);
+	state->flags = 0;
+	if (val & CARD_OUT_EN) state->flags |= SS_OUTPUT_ENA;
+
+	val = exca_readb(socket, INT_GEN_CNT);
+	if (!(val & CARD_REST0)) state->flags |= SS_RESET;
+	if (val & CARD_TYPE_IO) state->flags |= SS_IOCARD;
+
+	return 0;
+}
+
+static inline uint8_t set_Vcc_value(u_char Vcc)
+{
+	switch (Vcc) {
+	case 33:
+		return VCC_3V;
+	case 50:
+		return VCC_5V;
+	}
+
+	return VCC_0V;
+}
+
+static inline uint8_t set_Vpp_value(u_char Vpp)
+{
+	switch (Vpp) {
+	case 33:
+	case 50:
+		return VPP_VCC;
+	case 120:
+		return VPP_12V;
+	}
+
+	return VPP_0V;
+}
+
+static int cardu_set_socket(unsigned int sock, socket_state_t *state)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint8_t val;
+
+	if (((state->Vpp == 33) || (state->Vpp == 50)) && (state->Vpp != state->Vcc))
+			return -EINVAL;
+
+	val = set_Vcc_value(state->Vcc);
+	val |= set_Vpp_value(state->Vpp);
+	if (state->flags & SS_OUTPUT_ENA) val |= CARD_OUT_EN;
+	exca_writeb(socket, PWR_CNT, val);
+
+	val = exca_readb(socket, INT_GEN_CNT) & CARD_REST0;
+	if (state->flags & SS_RESET) val &= ~CARD_REST0;
+	else val |= CARD_REST0;
+	if (state->flags & SS_IOCARD) val |= CARD_TYPE_IO;
+	exca_writeb(socket, INT_GEN_CNT, val);
+
+	return 0;
+}
+
+static int cardu_get_io_map(unsigned int sock, struct pccard_io_map *io)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint8_t ioctl, window;
+	u_char map;
+
+	map = io->map;
+	if (map > 1)
+		return -EINVAL;
+
+	io->start = exca_readw(socket, IO_WIN_SA(map));
+	io->stop = exca_readw(socket, IO_WIN_EA(map));
+
+	ioctl = exca_readb(socket, IO_WIN_CNT);
+	window = exca_readb(socket, ADR_WIN_EN);
+	io->flags  = (window & IO_WIN_EN(map)) ? MAP_ACTIVE : 0;
+	if (ioctl & IO_WIN_DATA_AUTOSZ(map))
+		io->flags |= MAP_AUTOSZ;
+	else if (ioctl & IO_WIN_DATA_16BIT(map))
+		io->flags |= MAP_16BIT;
+
+	return 0;
+}
+
+static int cardu_set_io_map(unsigned int sock, struct pccard_io_map *io)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint16_t ioctl;
+	uint8_t window, enable;
+	u_char map;
+
+	map = io->map;
+	if (map > 1)
+		return -EINVAL;
+
+	window = exca_readb(socket, ADR_WIN_EN);
+	enable = IO_WIN_EN(map);
+
+	if (window & enable) {
+		window &= ~enable;
+		exca_writeb(socket, ADR_WIN_EN, window);
+	}
+
+	exca_writew(socket, IO_WIN_SA(map), io->start);
+	exca_writew(socket, IO_WIN_EA(map), io->stop);
+
+	ioctl = exca_readb(socket, IO_WIN_CNT) & ~IO_WIN_CNT_MASK(map);
+	if (io->flags & MAP_AUTOSZ) ioctl |= IO_WIN_DATA_AUTOSZ(map);
+	else if (io->flags & MAP_16BIT) ioctl |= IO_WIN_DATA_16BIT(map);
+	exca_writeb(socket, IO_WIN_CNT, ioctl);
+
+	if (io->flags & MAP_ACTIVE)
+		exca_writeb(socket, ADR_WIN_EN, window | enable);
+
+	return 0;
+}
+
+static int cardu_get_mem_map(unsigned int sock, struct pccard_mem_map *mem)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint32_t start, stop, offset, page;
+	uint8_t window;
+	u_char map;
+
+	map = mem->map;
+	if (map > 4)
+		return -EINVAL;
+
+	window = exca_readb(socket, ADR_WIN_EN);
+	mem->flags = (window & MEM_WIN_EN(map)) ? MAP_ACTIVE : 0;
+
+	start = exca_readw(socket, MEM_WIN_SA(map));
+	mem->flags |= (start & MEM_WIN_DSIZE) ? MAP_16BIT : 0;
+	start = (start & 0x0fff) << 12;
+
+	stop = exca_readw(socket, MEM_WIN_EA(map));
+	stop = ((stop & 0x0fff) << 12) + 0x0fff;
+
+	offset = exca_readw(socket, MEM_WIN_OA(map));
+	mem->flags |= (offset & MEM_WIN_WP) ? MAP_WRPROT : 0;
+	mem->flags |= (offset & MEM_WIN_REGSET) ? MAP_ATTRIB : 0;
+	offset = ((offset & 0x3fff) << 12) + start;
+	mem->card_start = offset & 0x03ffffff;
+
+	page = exca_readb(socket, MEM_WIN_SAU(map)) << 24;
+	mem->sys_start = start + page;
+	mem->sys_stop = start + page;
+
+	return 0;
+}
+
+static int cardu_set_mem_map(unsigned int sock, struct pccard_mem_map *mem)
+{
+	vrc4173_socket_t *socket = &cardu_sockets[sock];
+	uint16_t value;
+	uint8_t window, enable;
+	u_long sys_start, sys_stop, card_start;
+	u_char map;
+
+	map = mem->map;
+	sys_start = mem->sys_start;
+	sys_stop = mem->sys_stop;
+	card_start = mem->card_start;
+
+	if (map > 4 || sys_start > sys_stop || ((sys_start ^ sys_stop) >> 24) ||
+	    (card_start >> 26))
+		return -EINVAL;
+
+	window = exca_readb(socket, ADR_WIN_EN);
+	enable = MEM_WIN_EN(map);
+	if (window & enable) {
+		window &= ~enable;
+		exca_writeb(socket, ADR_WIN_EN, window);
+	}
+
+	exca_writeb(socket, MEM_WIN_SAU(map), sys_start >> 24);
+
+	value = (sys_start >> 12) & 0x0fff;
+	if (mem->flags & MAP_16BIT) value |= MEM_WIN_DSIZE;
+	exca_writew(socket, MEM_WIN_SA(map), value);
+
+	value = (sys_stop >> 12) & 0x0fff;
+	exca_writew(socket, MEM_WIN_EA(map), value);
+
+	value = ((card_start - sys_start) >> 12) & 0x3fff;
+	if (mem->flags & MAP_WRPROT) value |= MEM_WIN_WP;
+	if (mem->flags & MAP_ATTRIB) value |= MEM_WIN_REGSET;
+	exca_writew(socket, MEM_WIN_OA(map), value);
+
+	if (mem->flags & MAP_ACTIVE)
+		exca_writeb(socket, ADR_WIN_EN, window | enable);
+
+	return 0;
+}
+
+static void cardu_proc_setup(unsigned int sock, struct proc_dir_entry *base)
+{
+}
+
+static struct pccard_operations cardu_operations = {
+	.init			= cardu_init,
+	.suspend		= cardu_suspend,
+	.register_callback	= cardu_register_callback,
+	.inquire_socket		= cardu_inquire_socket,
+	.get_status		= cardu_get_status,
+	.get_socket		= cardu_get_socket,
+	.set_socket		= cardu_set_socket,
+	.get_io_map		= cardu_get_io_map,
+	.set_io_map		= cardu_set_io_map,
+	.get_mem_map		= cardu_get_mem_map,
+	.set_mem_map		= cardu_set_mem_map,
+	.proc_setup		= cardu_proc_setup,
+};
+
+static void cardu_bh(void *data)
+{
+	vrc4173_socket_t *socket = (vrc4173_socket_t *)data;
+	uint16_t events;
+
+	spin_lock_irq(&socket->event_lock);
+	events = socket->events;
+	socket->events = 0;
+	spin_unlock_irq(&socket->event_lock);
+
+	if (socket->handler)
+		socket->handler(socket->info, events);
+}
+
+static uint16_t get_events(vrc4173_socket_t *socket)
+{
+	uint16_t events = 0;
+	uint8_t csc, status;
+
+	status = exca_readb(socket, IF_STATUS);
+	csc = exca_readb(socket, CARD_SC);
+	if ((csc & CARD_DT_CHG) &&
+	    ((status & (CARD_DETECT1|CARD_DETECT2)) == (CARD_DETECT1|CARD_DETECT2)))
+		events |= SS_DETECT;
+
+	if ((csc & RDY_CHG) && (status & READY))
+		events |= SS_READY;
+
+	if (exca_readb(socket, INT_GEN_CNT) & CARD_TYPE_IO) {
+		if ((csc & BAT_DEAD_ST_CHG) && (status & STSCHG))
+			events |= SS_STSCHG;
+	} else {
+		if (csc & (BAT_WAR_CHG|BAT_DEAD_ST_CHG)) {
+			if ((status & BV_DETECT_MASK) != BV_DETECT_GOOD) {
+				if (status == BV_DETECT_WARN) events |= SS_BATWARN;
+				else events |= SS_BATDEAD;
+			}
+		}
+	}
+
+	return events;
+}
+
+static void cardu_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	vrc4173_socket_t *socket = (vrc4173_socket_t *)dev_id;
+	uint16_t events;
+
+	INIT_WORK(&socket->tq_work, cardu_bh, socket);
+
+	events = get_events(socket);
+	if (events) {
+		spin_lock(&socket->event_lock);
+		socket->events |= events;
+		spin_unlock(&socket->event_lock);
+		schedule_work(&socket->tq_work);
+	}
+}
+
+static int __devinit vrc4173_cardu_probe(struct pci_dev *dev,
+                                         const struct pci_device_id *ent)
+{
+	vrc4173_socket_t *socket;
+	unsigned long start, len, flags;
+	int slot, err;
+
+	slot = vrc4173_cardu_slots++;
+	socket = &cardu_sockets[slot];
+	if (socket->noprobe != 0)
+		return -EBUSY;
+
+	sprintf(socket->name, "NEC VRC4173 CARDU%1d", slot+1);
+
+	if ((err = pci_enable_device(dev)) < 0)
+		return err;
+
+	start = pci_resource_start(dev, 0);
+	if (start == 0)
+		return -ENODEV;
+
+	len = pci_resource_len(dev, 0);
+	if (len == 0)
+		return -ENODEV;
+
+	if (((flags = pci_resource_flags(dev, 0)) & IORESOURCE_MEM) == 0)
+		return -EBUSY;
+
+	if ((err = pci_request_regions(dev, socket->name)) < 0)
+		return err;
+
+	socket->base = ioremap(start, len);
+	if (socket->base == NULL)
+		return -ENODEV;
+
+	socket->dev = dev;
+
+	socket->pcmcia_socket = pcmcia_register_socket(slot, &cardu_operations, 1);
+	if (socket->pcmcia_socket == NULL) {
+		iounmap(socket->base);
+		socket->base = NULL;
+		return -ENOMEM;
+	}
+
+	if (request_irq(dev->irq, cardu_interrupt, SA_SHIRQ, socket->name, socket) < 0) {
+		pcmcia_unregister_socket(socket->pcmcia_socket);
+		socket->pcmcia_socket = NULL;
+		iounmap(socket->base);
+		socket->base = NULL;
+		return -EBUSY;
+	}
+
+	printk(KERN_INFO "%s at %#08lx, IRQ %d\n", socket->name, start, dev->irq);
+
+	return 0;
+}
+
+static int __devinit vrc4173_cardu_setup(char *options)
+{
+	if (options == NULL || *options == '\0')
+		return 0;
+
+	if (strncmp(options, "cardu1:", 7) == 0) {
+		options += 7;
+		if (*options != '\0') {
+			if (strncmp(options, "noprobe", 7) == 0) {
+				cardu_sockets[CARDU1].noprobe = 1;
+				options += 7;
+			}
+
+			if (*options != ',')
+				return 0;
+		} else
+			return 0;
+	}
+
+	if (strncmp(options, "cardu2:", 7) == 0) {
+		options += 7;
+		if ((*options != '\0') && (strncmp(options, "noprobe", 7) == 0))
+			cardu_sockets[CARDU2].noprobe = 1;
+	}
+
+	return 0;
+}
+
+__setup("vrc4173_cardu=", vrc4173_cardu_setup);
+
+static struct pci_device_id vrc4173_cardu_id_table[] __devinitdata = {
+	{	.vendor		= PCI_VENDOR_ID_NEC,
+		.device		= PCI_DEVICE_ID_NEC_NAPCCARD,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID, },
+        {0, }
+};
+
+static struct pci_driver vrc4173_cardu_driver = {
+	.name		= "NEC VRC4173 CARDU",
+	.probe		= vrc4173_cardu_probe,
+	.id_table	= vrc4173_cardu_id_table,
+};
+
+static int __devinit vrc4173_cardu_init(void)
+{
+	vrc4173_cardu_slots = 0;
+
+	return pci_module_init(&vrc4173_cardu_driver);
+}
+
+static void __devexit vrc4173_cardu_exit(void)
+{
+	pci_unregister_driver(&vrc4173_cardu_driver);
+}
+
+module_init(vrc4173_cardu_init);
+module_exit(vrc4173_cardu_exit);
diff -purN linux-2.6.11-rc2-bk10/drivers/pcmcia/vrc4173_cardu.h linux-2.6.11-rc3/drivers/pcmcia/vrc4173_cardu.h
--- linux-2.6.11-rc2-bk10/drivers/pcmcia/vrc4173_cardu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/pcmcia/vrc4173_cardu.h	2005-02-03 02:55:36.000000000 +0100
@@ -0,0 +1,247 @@
+/*
+ * FILE NAME
+ *	drivers/pcmcia/vrc4173_cardu.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Include file for NEC VRC4173 CARDU.
+ *
+ * Copyright 2002 Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _VRC4173_CARDU_H
+#define _VRC4173_CARDU_H
+
+#include <linux/pci.h>
+
+#include <pcmcia/ss.h>
+
+#define CARDU_MAX_SOCKETS	2
+#define CARDU1			0
+#define CARDU2			1
+
+/*
+ * PCI Configuration Registers
+ */
+#define BRGCNT			0x3e
+ #define POST_WR_EN		0x0400
+ #define MEM1_PREF_EN		0x0200
+ #define MEM0_PREF_EN		0x0100
+ #define IREQ_INT		0x0080
+ #define CARD_RST		0x0040
+ #define MABORT_MODE		0x0020
+ #define VGA_EN			0x0008
+ #define ISA_EN			0x0004
+ #define SERR_EN		0x0002
+ #define PERR_EN		0x0001
+
+#define SYSCNT			0x80
+ #define BAD_VCC_REQ_DISB	0x00200000
+ #define PCPCI_EN		0x00080000
+ #define CH_ASSIGN_MASK		0x00070000
+ #define CH_ASSIGN_NODMA	0x00040000
+ #define SUB_ID_WR_EN		0x00000008
+ #define ASYN_INT_MODE		0x00000004
+ #define PCI_CLK_RIN		0x00000002
+
+#define DEVCNT			0x91
+ #define ZOOM_VIDEO_EN		0x40
+ #define SR_PCI_INT_SEL_MASK	0x18
+ #define SR_PCI_INT_SEL_NONE	0x00
+ #define PCI_INT_MODE		0x04
+ #define IRQ_MODE		0x02
+ #define IFG			0x01
+
+#define CHIPCNT			0x9c
+ #define S_PREF_DISB		0x10
+
+#define SERRDIS			0x9f
+ #define SERR_DIS_MAB		0x10
+ #define SERR_DIS_TAB		0x08
+ #define SERR_DIS_DT_PERR	0x04
+
+/*
+ * ExCA Registers
+ */
+#define EXCA_REGS_BASE		0x800
+#define EXCA_REGS_SIZE		0x800
+
+#define ID_REV			0x000
+ #define IF_TYPE_16BIT		0x80
+
+#define IF_STATUS		0x001
+ #define CARD_PWR		0x40
+ #define READY			0x20
+ #define CARD_WP		0x10
+ #define CARD_DETECT2		0x08
+ #define CARD_DETECT1		0x04
+ #define BV_DETECT_MASK		0x03
+ #define BV_DETECT_GOOD		0x03	/* Memory card */
+ #define BV_DETECT_WARN		0x02
+ #define BV_DETECT_BAD1		0x01
+ #define BV_DETECT_BAD0		0x00
+ #define STSCHG			0x02	/* I/O card */
+ #define SPKR			0x01
+
+#define PWR_CNT			0x002
+ #define CARD_OUT_EN		0x80
+ #define VCC_MASK		0x18
+ #define VCC_3V			0x18
+ #define VCC_5V			0x10
+ #define VCC_0V			0x00
+ #define VPP_MASK		0x03
+ #define VPP_12V		0x02
+ #define VPP_VCC		0x01
+ #define VPP_0V			0x00
+
+#define INT_GEN_CNT		0x003
+ #define CARD_REST0		0x40
+ #define CARD_TYPE_MASK		0x20
+ #define CARD_TYPE_IO		0x20
+ #define CARD_TYPE_MEM		0x00
+
+#define CARD_SC			0x004
+ #define CARD_DT_CHG		0x08
+ #define RDY_CHG		0x04
+ #define BAT_WAR_CHG		0x02
+ #define BAT_DEAD_ST_CHG	0x01
+
+#define CARD_SCI		0x005
+ #define CARD_DT_EN		0x08
+ #define RDY_EN			0x04
+ #define BAT_WAR_EN		0x02
+ #define BAT_DEAD_EN		0x01
+
+#define ADR_WIN_EN		0x006
+ #define IO_WIN_EN(x)		(0x40 << (x))
+ #define MEM_WIN_EN(x)		(0x01 << (x))
+
+#define IO_WIN_CNT		0x007
+ #define IO_WIN_CNT_MASK(x)	(0x03 << ((x) << 2))
+ #define IO_WIN_DATA_AUTOSZ(x)	(0x02 << ((x) << 2))
+ #define IO_WIN_DATA_16BIT(x)	(0x01 << ((x) << 2))
+
+#define IO_WIN_SA(x)		(0x008 + ((x) << 2))
+#define IO_WIN_EA(x)		(0x00a + ((x) << 2))
+
+#define MEM_WIN_SA(x)		(0x010 + ((x) << 3))
+ #define MEM_WIN_DSIZE		0x8000
+
+#define MEM_WIN_EA(x)		(0x012 + ((x) << 3))
+
+#define MEM_WIN_OA(x)		(0x014 + ((x) << 3))
+ #define MEM_WIN_WP		0x8000
+ #define MEM_WIN_REGSET		0x4000
+
+#define GEN_CNT			0x016
+ #define VS2_STATUS		0x80
+ #define VS1_STATUS		0x40
+ #define EXCA_REG_RST_EN	0x02
+
+#define GLO_CNT			0x01e
+ #define FUN_INT_LEV		0x08
+ #define INT_WB_CLR		0x04
+ #define CSC_INT_LEV		0x02
+
+#define IO_WIN_OAL(x)		(0x036 + ((x) << 1))
+#define IO_WIN_OAH(x)		(0x037 + ((x) << 1))
+
+#define MEM_WIN_SAU(x)		(0x040 + (x))
+
+#define IO_SETUP_TIM		0x080
+#define IO_CMD_TIM		0x081
+#define IO_HOLD_TIM		0x082
+#define MEM_SETUP_TIM(x)	(0x084 + ((x) << 2))
+#define MEM_CMD_TIM(x)		(0x085 + ((x) << 2))
+#define MEM_HOLD_TIM(x)		(0x086 + ((x) << 2))
+ #define TIM_CLOCKS(x)		((x) - 1)
+
+#define MEM_TIM_SEL1		0x08c
+#define MEM_TIM_SEL2		0x08d
+ #define MEM_WIN_TIMSEL1(x)	(0x03 << (((x) & 3) << 1))
+
+#define MEM_WIN_PWEN		0x091
+ #define POSTWEN		0x01
+
+/*
+ * CardBus Socket Registers
+ */
+#define CARDBUS_SOCKET_REGS_BASE	0x000
+#define CARDBUS_SOCKET_REGS_SIZE	0x800
+
+#define SKT_EV			0x000
+ #define POW_CYC_EV		0x00000008
+ #define CCD2_EV		0x00000004
+ #define CCD1_EV		0x00000002
+ #define CSTSCHG_EV		0x00000001
+
+#define SKT_MASK		0x004
+ #define POW_CYC_MASK		0x00000008
+ #define CCD_MASK		0x00000006
+ #define CSC_MASK		0x00000001
+
+#define SKT_PRE_STATE		0x008
+#define SKT_FORCE_EV		0x00c
+ #define VOL_3V_SKT		0x20000000
+ #define VOL_5V_SKT		0x10000000
+ #define CVS_TEST		0x00004000
+ #define VOL_YV_CARD_DT		0x00002000
+ #define VOL_XV_CARD_DT		0x00001000
+ #define VOL_3V_CARD_DT		0x00000800
+ #define VOL_5V_CARD_DT		0x00000400
+ #define BAD_VCC_REQ		0x00000200
+ #define DATA_LOST		0x00000100
+ #define NOT_A_CARD		0x00000080
+ #define CREADY			0x00000040
+ #define CB_CARD_DT		0x00000020
+ #define R2_CARD_DT		0x00000010
+ #define POW_UP			0x00000008
+ #define CCD20			0x00000004
+ #define CCD10			0x00000002
+ #define CSTSCHG		0x00000001
+
+#define SKT_CNT			0x010
+ #define STP_CLK_EN		0x00000080
+ #define VCC_CNT_MASK		0x00000070
+ #define VCC_CNT_3V		0x00000030
+ #define VCC_CNT_5V		0x00000020
+ #define VCC_CNT_0V		0x00000000
+ #define VPP_CNT_MASK		0x00000007
+ #define VPP_CNT_3V		0x00000003
+ #define VPP_CNT_5V		0x00000002
+ #define VPP_CNT_12V		0x00000001
+ #define VPP_CNT_0V		0x00000000
+
+typedef struct vrc4173_socket {
+	int noprobe;
+	struct pci_dev *dev;
+	void *base;
+	void (*handler)(void *, unsigned int);
+	void *info;
+	socket_cap_t cap;
+	spinlock_t event_lock;
+	uint16_t events;
+	struct socket_info_t *pcmcia_socket;
+	struct work_struct tq_work;
+	char name[20];
+} vrc4173_socket_t;
+
+#endif /* _VRC4173_CARDU_H */
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/aacraid/aachba.c linux-2.6.11-rc3/drivers/scsi/aacraid/aachba.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/aacraid/aachba.c	2005-02-03 10:03:09.682528331 +0100
+++ linux-2.6.11-rc3/drivers/scsi/aacraid/aachba.c	2005-02-03 02:55:50.000000000 +0100
@@ -1047,7 +1047,7 @@ static void synchronize_callback(void *c
 			COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;
 	else {
 		struct scsi_device *sdev = cmd->device;
-		struct aac_dev *dev = (struct aav_dev *)sdev->host->hostdata;
+		struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
 		u32 cid = ID_LUN_TO_CONTAINER(sdev->id, sdev->lun);
 		printk(KERN_WARNING 
 		     "synchronize_callback: synchronize failed, status = %d\n",
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/gdth.c linux-2.6.11-rc3/drivers/scsi/gdth.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/gdth.c	2005-01-22 02:48:27.000000000 +0100
+++ linux-2.6.11-rc3/drivers/scsi/gdth.c	2005-02-03 02:56:10.000000000 +0100
@@ -642,7 +642,7 @@ static int probe_eisa_isa = 0;
 static int force_dma32 = 0;
 
 /* parameters for modprobe/insmod */
-module_param(irq, int, 0);
+module_param_array(irq, int, NULL, 0);
 module_param(disable, int, 0);
 module_param(reserve_mode, int, 0);
 module_param_array(reserve_list, int, NULL, 0);
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/jazz_esp.c linux-2.6.11-rc3/drivers/scsi/jazz_esp.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/jazz_esp.c	2005-02-03 10:03:09.732520552 +0100
+++ linux-2.6.11-rc3/drivers/scsi/jazz_esp.c	2005-02-03 02:55:07.000000000 +0100
@@ -52,6 +52,40 @@ static volatile unsigned char cmd_buffer
 				 * via PIO.
 				 */
 
+int jazz_esp_detect(Scsi_Host_Template *tpnt);
+static int jazz_esp_release(struct Scsi_Host *shost)
+{
+	if (shost->irq)
+		free_irq(shost->irq, NULL);
+	if (shost->dma_channel != 0xff)
+		free_dma(shost->dma_channel);
+	if (shost->io_port && shost->n_io_port)
+		release_region(shost->io_port, shost->n_io_port);
+	scsi_unregister(shost);
+	return 0;
+}
+
+static Scsi_Host_Template driver_template = {
+	.proc_name		= "jazz_esp",
+	.proc_info		= &esp_proc_info,
+	.name			= "ESP 100/100a/200",
+	.detect			= jazz_esp_detect,
+	.slave_alloc		= esp_slave_alloc,
+	.slave_destroy		= esp_slave_destroy,
+	.release		= jazz_esp_release,
+	.info			= esp_info,
+	.queuecommand		= esp_queue,
+	.eh_abort_handler	= esp_abort,
+	.eh_bus_reset_handler	= esp_reset,
+	.can_queue		= 7,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= DISABLE_CLUSTERING,
+};
+
+#include "scsi_module.c"
+
 /***************************************************************** Detection */
 static int jazz_esp_detect(struct scsi_host_template *tpnt)
 {
@@ -140,18 +174,6 @@ static int jazz_esp_detect(struct scsi_h
     return 0;
 }
 
-static int jazz_esp_release(struct Scsi_Host *shost)
-{
-	if (shost->irq)
-		free_irq(shost->irq, NULL);
-	if (shost->dma_channel != 0xff)
-		free_dma(shost->dma_channel);
-	if (shost->io_port && shost->n_io_port)
-		release_region(shost->io_port, shost->n_io_port);
-	scsi_unregister(shost);
-	return 0;
-}
-
 /************************************************************* DMA Functions */
 static int dma_bytes_sent(struct NCR_ESP *esp, int fifo_count)
 {
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/megaraid/megaraid_mbox.c linux-2.6.11-rc3/drivers/scsi/megaraid/megaraid_mbox.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/megaraid/megaraid_mbox.c	2005-01-22 02:47:33.000000000 +0100
+++ linux-2.6.11-rc3/drivers/scsi/megaraid/megaraid_mbox.c	2005-02-03 02:55:35.000000000 +0100
@@ -1600,7 +1600,7 @@ megaraid_queue_command(struct scsi_cmnd 
 	scp->scsi_done	= done;
 	scp->result	= 0;
 
-	ASSERT(spin_is_locked(adapter->host_lock));
+	assert_spin_locked(adapter->host_lock);
 
 	spin_unlock(adapter->host_lock);
 
@@ -2043,7 +2043,7 @@ megaraid_mbox_runpendq(adapter_t *adapte
 
 	while (!list_empty(&adapter->pend_list)) {
 
-		ASSERT(spin_is_locked(PENDING_LIST_LOCK(adapter)));
+		assert_spin_locked(PENDING_LIST_LOCK(adapter));
 
 		scb = list_entry(adapter->pend_list.next, scb_t, list);
 
@@ -2615,7 +2615,7 @@ megaraid_abort_handler(struct scsi_cmnd 
 	adapter		= SCP2ADAPTER(scp);
 	raid_dev	= ADAP2RAIDDEV(adapter);
 
-	ASSERT(spin_is_locked(adapter->host_lock));
+	assert_spin_locked(adapter->host_lock);
 
 	con_log(CL_ANN, (KERN_WARNING
 		"megaraid: aborting-%ld cmd=%x <c=%d t=%d l=%d>\n",
@@ -2762,7 +2762,7 @@ megaraid_reset_handler(struct scsi_cmnd 
 	adapter		= SCP2ADAPTER(scp);
 	raid_dev	= ADAP2RAIDDEV(adapter);
 
-	ASSERT(spin_is_locked(adapter->host_lock));
+	assert_spin_locked(adapter->host_lock);
 
 	con_log(CL_ANN, (KERN_WARNING "megaraid: reseting the host...\n"));
 
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/scsi_lib.c linux-2.6.11-rc3/drivers/scsi/scsi_lib.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/scsi_lib.c	2005-02-03 10:03:09.774514018 +0100
+++ linux-2.6.11-rc3/drivers/scsi/scsi_lib.c	2005-02-03 02:55:52.000000000 +0100
@@ -692,6 +692,7 @@ void scsi_io_completion(struct scsi_cmnd
 	int this_count = cmd->bufflen;
 	request_queue_t *q = cmd->device->request_queue;
 	struct request *req = cmd->request;
+	int clear_errors = 1;
 	struct scsi_sense_hdr sshdr;
 	int sense_valid = 0;
 	int sense_deferred = 0;
@@ -721,6 +722,7 @@ void scsi_io_completion(struct scsi_cmnd
 	if (blk_pc_request(req)) { /* SG_IO ioctl from block level */
 		req->errors = result;
 		if (result) {
+			clear_errors = 0;
 			if (sense_valid) {
 				/*
 				 * SG_IO wants current and deferred errors
@@ -745,11 +747,6 @@ void scsi_io_completion(struct scsi_cmnd
 	cmd->request_buffer = NULL;
 	cmd->request_bufflen = 0;
 
-	if (blk_pc_request(req)) { /* SG_IO ioctl from block level */
-		scsi_end_request(cmd, 1, good_bytes, 0);
-		return;
-	}
-
 	/*
 	 * Next deal with any sectors which we were able to correctly
 	 * handle.
@@ -759,7 +756,8 @@ void scsi_io_completion(struct scsi_cmnd
 					      req->nr_sectors, good_bytes));
 		SCSI_LOG_HLCOMPLETE(1, printk("use_sg is %d\n", cmd->use_sg));
 
-		req->errors = 0;
+		if (clear_errors)
+			req->errors = 0;
 		/*
 		 * If multiple sectors are requested in one buffer, then
 		 * they will have been finished off by the first command.
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/scsi_transport_fc.c linux-2.6.11-rc3/drivers/scsi/scsi_transport_fc.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/scsi_transport_fc.c	2005-02-03 10:03:09.788511840 +0100
+++ linux-2.6.11-rc3/drivers/scsi/scsi_transport_fc.c	2005-02-03 02:55:07.000000000 +0100
@@ -728,6 +728,7 @@ static int fc_host_match(struct attribut
 			  struct device *dev)
 {
 	struct Scsi_Host *shost;
+	struct fc_internal *i;
 
 	if (!scsi_is_host_device(dev))
 		return 0;
@@ -736,13 +737,17 @@ static int fc_host_match(struct attribut
 	if (!shost->transportt  || shost->transportt->host_attrs.class
 	    != &fc_host_class.class)
 		return 0;
-	return 1;
+
+	i = to_fc_internal(shost->transportt);
+	
+	return &i->t.host_attrs == cont;
 }
 
 static int fc_target_match(struct attribute_container *cont,
 			    struct device *dev)
 {
 	struct Scsi_Host *shost;
+	struct fc_internal *i;
 
 	if (!scsi_is_target_device(dev))
 		return 0;
@@ -751,7 +756,10 @@ static int fc_target_match(struct attrib
 	if (!shost->transportt  || shost->transportt->host_attrs.class
 	    != &fc_host_class.class)
 		return 0;
-	return 1;
+
+	i = to_fc_internal(shost->transportt);
+	
+	return &i->t.target_attrs == cont;
 }
 
 
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/scsi_transport_iscsi.c linux-2.6.11-rc3/drivers/scsi/scsi_transport_iscsi.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/scsi_transport_iscsi.c	2005-02-03 10:03:09.790511529 +0100
+++ linux-2.6.11-rc3/drivers/scsi/scsi_transport_iscsi.c	2005-02-03 02:55:15.000000000 +0100
@@ -258,6 +258,7 @@ static int iscsi_host_match(struct attri
 			  struct device *dev)
 {
 	struct Scsi_Host *shost;
+	struct iscsi_internal *i;
 
 	if (!scsi_is_host_device(dev))
 		return 0;
@@ -266,13 +267,17 @@ static int iscsi_host_match(struct attri
 	if (!shost->transportt  || shost->transportt->host_attrs.class
 	    != &iscsi_host_class.class)
 		return 0;
-	return 1;
+
+	i = to_iscsi_internal(shost->transportt);
+	
+	return &i->t.host_attrs == cont;
 }
 
 static int iscsi_target_match(struct attribute_container *cont,
 			    struct device *dev)
 {
 	struct Scsi_Host *shost;
+	struct iscsi_internal *i;
 
 	if (!scsi_is_target_device(dev))
 		return 0;
@@ -281,7 +286,10 @@ static int iscsi_target_match(struct att
 	if (!shost->transportt  || shost->transportt->host_attrs.class
 	    != &iscsi_host_class.class)
 		return 0;
-	return 1;
+
+	i = to_iscsi_internal(shost->transportt);
+	
+	return &i->t.target_attrs == cont;
 }
 
 struct scsi_transport_template *
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/scsi_transport_spi.c linux-2.6.11-rc3/drivers/scsi/scsi_transport_spi.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/scsi_transport_spi.c	2005-02-03 10:03:09.794510906 +0100
+++ linux-2.6.11-rc3/drivers/scsi/scsi_transport_spi.c	2005-02-03 02:55:52.000000000 +0100
@@ -136,6 +136,7 @@ static int spi_host_match(struct attribu
 			  struct device *dev)
 {
 	struct Scsi_Host *shost;
+	struct spi_internal *i;
 
 	if (!scsi_is_host_device(dev))
 		return 0;
@@ -144,7 +145,10 @@ static int spi_host_match(struct attribu
 	if (!shost->transportt  || shost->transportt->host_attrs.class
 	    != &spi_host_class.class)
 		return 0;
-	return 1;
+
+	i = to_spi_internal(shost->transportt);
+	
+	return &i->t.host_attrs == cont;
 }
 
 static int spi_device_configure(struct device *dev)
@@ -824,6 +828,9 @@ static int spi_device_match(struct attri
 	if (!shost->transportt  || shost->transportt->host_attrs.class
 	    != &spi_host_class.class)
 		return 0;
+	/* Note: this class has no device attributes, so it has
+	 * no per-HBA allocation and thus we don't need to distinguish
+	 * the attribute containers for the device */
 	return 1;
 }
 
@@ -831,6 +838,7 @@ static int spi_target_match(struct attri
 			    struct device *dev)
 {
 	struct Scsi_Host *shost;
+	struct spi_internal *i;
 
 	if (!scsi_is_target_device(dev))
 		return 0;
@@ -839,7 +847,10 @@ static int spi_target_match(struct attri
 	if (!shost->transportt  || shost->transportt->host_attrs.class
 	    != &spi_host_class.class)
 		return 0;
-	return 1;
+
+	i = to_spi_internal(shost->transportt);
+	
+	return &i->t.target_attrs == cont;
 }
 
 static DECLARE_TRANSPORT_CLASS(spi_transport_class,
diff -purN linux-2.6.11-rc2-bk10/drivers/scsi/sr.c linux-2.6.11-rc3/drivers/scsi/sr.c
--- linux-2.6.11-rc2-bk10/drivers/scsi/sr.c	2005-02-03 10:03:09.811508261 +0100
+++ linux-2.6.11-rc3/drivers/scsi/sr.c	2005-02-03 02:57:16.000000000 +0100
@@ -544,7 +544,6 @@ static int sr_open(struct cdrom_device_i
 	return 0;
 
 error_out:
-	scsi_cd_put(cd);
 	return retval;	
 }
 
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/8250_pnp.c linux-2.6.11-rc3/drivers/serial/8250_pnp.c
--- linux-2.6.11-rc2-bk10/drivers/serial/8250_pnp.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/8250_pnp.c	2005-02-03 02:54:59.000000000 +0100
@@ -421,14 +421,14 @@ serial_pnp_probe(struct pnp_dev * dev, c
 	line = serial8250_register_port(&port);
 
 	if (line >= 0)
-		pnp_set_drvdata(dev, (void *)(line + 1));
+		pnp_set_drvdata(dev, (void *)((long)line + 1));
 	return line >= 0 ? 0 : -ENODEV;
 
 }
 
 static void __devexit serial_pnp_remove(struct pnp_dev * dev)
 {
-	int line = (int)pnp_get_drvdata(dev);
+	long line = (long)pnp_get_drvdata(dev);
 	if (line)
 		serial8250_unregister_port(line - 1);
 }
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/Kconfig linux-2.6.11-rc3/drivers/serial/Kconfig
--- linux-2.6.11-rc2-bk10/drivers/serial/Kconfig	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/Kconfig	2005-02-03 02:56:48.000000000 +0100
@@ -792,4 +792,22 @@ config SERIAL_M32R_PLDSIO
 	  If you use an M3T-M32700UT or an OPSPUT platform,
 	  please say Y.
 
+config SERIAL_TXX9
+	bool "TMPTX39XX/49XX SIO support"
+	depends HAS_TXX9_SERIAL
+	select SERIAL_CORE
+	default y
+
+config HAS_TXX9_SERIAL
+	bool
+
+config SERIAL_TXX9_CONSOLE
+	bool "TMPTX39XX/49XX SIO Console support"
+	depends on SERIAL_TXX9=y
+	select SERIAL_CORE_CONSOLE
+
+config SERIAL_TXX9_STDSERIAL
+	bool "TX39XX/49XX SIO act as standard serial"
+	depends on !SERIAL_8250 && SERIAL_TXX9
+
 endmenu
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/icom.c linux-2.6.11-rc3/drivers/serial/icom.c
--- linux-2.6.11-rc2-bk10/drivers/serial/icom.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/icom.c	2005-02-03 02:55:23.000000000 +0100
@@ -105,25 +105,25 @@ static const struct pci_device_id icom_p
 };
 
 struct lookup_proc_table start_proc[4] = {
-	{0, ICOM_CONTROL_START_A},
-	{0, ICOM_CONTROL_START_B},
-	{0, ICOM_CONTROL_START_C},
-	{0, ICOM_CONTROL_START_D}
+	{NULL, ICOM_CONTROL_START_A},
+	{NULL, ICOM_CONTROL_START_B},
+	{NULL, ICOM_CONTROL_START_C},
+	{NULL, ICOM_CONTROL_START_D}
 };
 
 
 struct lookup_proc_table stop_proc[4] = {
-	{0, ICOM_CONTROL_STOP_A},
-	{0, ICOM_CONTROL_STOP_B},
-	{0, ICOM_CONTROL_STOP_C},
-	{0, ICOM_CONTROL_STOP_D}
+	{NULL, ICOM_CONTROL_STOP_A},
+	{NULL, ICOM_CONTROL_STOP_B},
+	{NULL, ICOM_CONTROL_STOP_C},
+	{NULL, ICOM_CONTROL_STOP_D}
 };
 
 struct lookup_int_table int_mask_tbl[4] = {
-	{0, ICOM_INT_MASK_PRC_A},
-	{0, ICOM_INT_MASK_PRC_B},
-	{0, ICOM_INT_MASK_PRC_C},
-	{0, ICOM_INT_MASK_PRC_D},
+	{NULL, ICOM_INT_MASK_PRC_A},
+	{NULL, ICOM_INT_MASK_PRC_B},
+	{NULL, ICOM_INT_MASK_PRC_C},
+	{NULL, ICOM_INT_MASK_PRC_D},
 };
 
 
@@ -148,23 +148,23 @@ static void free_port_memory(struct icom
 	if (icom_port->recv_buf) {
 		pci_free_consistent(dev, 4096, icom_port->recv_buf,
 				    icom_port->recv_buf_pci);
-		icom_port->recv_buf = 0;
+		icom_port->recv_buf = NULL;
 	}
 	if (icom_port->xmit_buf) {
 		pci_free_consistent(dev, 4096, icom_port->xmit_buf,
 				    icom_port->xmit_buf_pci);
-		icom_port->xmit_buf = 0;
+		icom_port->xmit_buf = NULL;
 	}
 	if (icom_port->statStg) {
 		pci_free_consistent(dev, 4096, icom_port->statStg,
 				    icom_port->statStg_pci);
-		icom_port->statStg = 0;
+		icom_port->statStg = NULL;
 	}
 
 	if (icom_port->xmitRestart) {
 		pci_free_consistent(dev, 4096, icom_port->xmitRestart,
 				    icom_port->xmitRestart_pci);
-		icom_port->xmitRestart = 0;
+		icom_port->xmitRestart = NULL;
 	}
 }
 
@@ -344,17 +344,17 @@ static void start_processor(struct icom_
 static void load_code(struct icom_port *icom_port)
 {
 	const struct firmware *fw;
-	char *iram_ptr;
+	char __iomem *iram_ptr;
 	int index;
 	int status = 0;
-	char *dram_ptr = (char *) icom_port->dram;
+	void __iomem *dram_ptr = icom_port->dram;
 	dma_addr_t temp_pci;
 	unsigned char *new_page = NULL;
 	unsigned char cable_id = NO_CABLE;
 	struct pci_dev *dev = icom_port->adapter->pci_dev;
 
 	/* Clear out any pending interrupts */
-	writew(0x3FFF, (void *) icom_port->int_reg);
+	writew(0x3FFF, icom_port->int_reg);
 
 	trace(icom_port, "CLEAR_INTERRUPTS", 0);
 
@@ -378,7 +378,7 @@ static void load_code(struct icom_port *
 		goto load_code_exit;
 	}
 
-	iram_ptr = (char *) icom_port->dram + ICOM_IRAM_OFFSET;
+	iram_ptr = (char __iomem *)icom_port->dram + ICOM_IRAM_OFFSET;
 	for (index = 0; index < fw->size; index++)
 		writeb(fw->data[index], &iram_ptr[index]);
 
@@ -398,7 +398,7 @@ static void load_code(struct icom_port *
 		goto load_code_exit;
 	}
 
-	iram_ptr = (char *) icom_port->dram + ICOM_IRAM_OFFSET;
+	iram_ptr = (char __iomem *) icom_port->dram + ICOM_IRAM_OFFSET;
 	for (index = ICOM_DCE_IRAM_OFFSET; index < fw->size; index++)
 		writeb(fw->data[index], &iram_ptr[index]);
 
@@ -490,7 +490,7 @@ static void load_code(struct icom_port *
 
 	if (status != 0) {
 		/* Clear out any pending interrupts */
-		writew(0x3FFF, (void *) icom_port->int_reg);
+		writew(0x3FFF, icom_port->int_reg);
 
 		/* Turn off port */
 		writeb(ICOM_DISABLE, &(icom_port->dram->disable));
@@ -514,8 +514,8 @@ static int startup(struct icom_port *ico
 
 	trace(icom_port, "STARTUP", 0);
 
-	if (icom_port->dram == 0x00000000) {
-		/* should NEVER be zero */
+	if (!icom_port->dram) {
+		/* should NEVER be NULL */
 		dev_err(&icom_port->adapter->pci_dev->dev,
 			"Unusable Port, port configuration missing\n");
 		return -ENODEV;
@@ -556,9 +556,9 @@ static int startup(struct icom_port *ico
 		int_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask_2;
 
 	if (port == 0 || port == 2)
-		writew(0x00FF,(void *) icom_port->int_reg);
+		writew(0x00FF, icom_port->int_reg);
 	else
-		writew(0x3F00,(void *) icom_port->int_reg);
+		writew(0x3F00, icom_port->int_reg);
 	if (port < 4) {
 		temp = readl(int_mask_tbl[port].global_int_mask);
 		writel(temp & ~int_mask_tbl[port].processor_id, int_mask_tbl[port].global_int_mask);
@@ -859,7 +859,7 @@ static void process_interrupt(u16 port_i
 static irqreturn_t icom_interrupt(int irq, void *dev_id,
 				  struct pt_regs *regs)
 {
-	unsigned long int_reg;
+	void __iomem * int_reg;
 	u32 adapter_interrupts;
 	u16 port_int_reg;
 	struct icom_adapter *icom_adapter;
@@ -871,7 +871,7 @@ static irqreturn_t icom_interrupt(int ir
 	if ((icom_adapter->version | ADAPTER_V2) == ADAPTER_V2) {
 		int_reg = icom_adapter->base_addr + 0x8024;
 
-		adapter_interrupts = readl((void *) int_reg);
+		adapter_interrupts = readl(int_reg);
 
 		if (adapter_interrupts & 0x00003FFF) {
 			/* port 2 interrupt,  NOTE:  for all ADAPTER_V2, port 2 will be active */
@@ -892,14 +892,14 @@ static irqreturn_t icom_interrupt(int ir
 		}
 
 		/* Clear out any pending interrupts */
-		writel(adapter_interrupts, (void *) int_reg);
+		writel(adapter_interrupts, int_reg);
 
 		int_reg = icom_adapter->base_addr + 0x8004;
 	} else {
 		int_reg = icom_adapter->base_addr + 0x4004;
 	}
 
-	adapter_interrupts = readl((void *) int_reg);
+	adapter_interrupts = readl(int_reg);
 
 	if (adapter_interrupts & 0x00003FFF) {
 		/* port 0 interrupt, NOTE:  for all adapters, port 0 will be active */
@@ -919,10 +919,10 @@ static irqreturn_t icom_interrupt(int ir
 	}
 
 	/* Clear out any pending interrupts */
-	writel(adapter_interrupts, (void *) int_reg);
+	writel(adapter_interrupts, int_reg);
 
 	/* flush the write */
-	adapter_interrupts = readl((void *) int_reg);
+	adapter_interrupts = readl(int_reg);
 
 	return IRQ_HANDLED;
 }
@@ -1383,18 +1383,16 @@ static int __devinit icom_init_ports(str
 static void icom_port_active(struct icom_port *icom_port, struct icom_adapter *icom_adapter, int port_num)
 {
 	if (icom_adapter->version == ADAPTER_V1) {
-		icom_port->global_reg = (struct icom_regs *) ((char *)
-			icom_adapter->base_addr + 0x4000);
-		icom_port->int_reg = (unsigned long) icom_adapter->base_addr +
+		icom_port->global_reg = icom_adapter->base_addr + 0x4000;
+		icom_port->int_reg = icom_adapter->base_addr +
 		    0x4004 + 2 - 2 * port_num;
 	} else {
-		icom_port->global_reg = (struct icom_regs *) ((char *)
-			icom_adapter->base_addr + 0x8000);
+		icom_port->global_reg = icom_adapter->base_addr + 0x8000;
 		if (icom_port->port < 2)
-			icom_port->int_reg = (unsigned long) icom_adapter->base_addr +
+			icom_port->int_reg = icom_adapter->base_addr +
 			    0x8004 + 2 - 2 * icom_port->port;
 		else
-			icom_port->int_reg = (unsigned long) icom_adapter->base_addr +
+			icom_port->int_reg = icom_adapter->base_addr +
 			    0x8024 + 2 - 2 * (icom_port->port - 2);
 	}
 }
@@ -1410,9 +1408,8 @@ static int __init icom_load_ports(struct
 
 		if (icom_port->status == ICOM_PORT_ACTIVE) {
 			icom_port_active(icom_port, icom_adapter, port_num);
-			icom_port->dram = (struct func_dram *) ((char *)
-					icom_adapter->base_addr +
-					0x2000 * icom_port->port);
+			icom_port->dram = icom_adapter->base_addr +
+					0x2000 * icom_port->port;
 
 			icom_port->adapter = icom_adapter;
 
@@ -1495,7 +1492,7 @@ static void icom_remove_adapter(struct i
 	}
 
 	free_irq(icom_adapter->irq_number, (void *) icom_adapter);
-	iounmap((void *) icom_adapter->base_addr);
+	iounmap(icom_adapter->base_addr);
 	icom_free_adapter(icom_adapter);
 	pci_release_regions(icom_adapter->pci_dev);
 }
@@ -1572,8 +1569,7 @@ static int __devinit icom_probe(struct p
 		goto probe_exit1;
 	}
 
-	 icom_adapter->base_addr =
-	     (unsigned long) ioremap(icom_adapter->base_addr_pci,
+	 icom_adapter->base_addr = ioremap(icom_adapter->base_addr_pci,
 						pci_resource_len(dev, 0));
 
 	if (!icom_adapter->base_addr)
@@ -1614,7 +1610,7 @@ static int __devinit icom_probe(struct p
 	return 0;
 
 probe_exit2:
-	iounmap((void *) icom_adapter->base_addr);
+	iounmap(icom_adapter->base_addr);
 probe_exit1:
 	icom_free_adapter(icom_adapter);
 
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/icom.h linux-2.6.11-rc3/drivers/serial/icom.h
--- linux-2.6.11-rc2-bk10/drivers/serial/icom.h	2005-01-22 02:46:43.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/icom.h	2005-02-03 02:54:38.000000000 +0100
@@ -234,9 +234,9 @@ struct icom_port {
 	unsigned char cable_id;
 	unsigned char read_status_mask;
 	unsigned char ignore_status_mask;
-	unsigned long int_reg;
-	struct icom_regs *global_reg;
-	struct func_dram *dram;
+	void __iomem * int_reg;
+	struct icom_regs __iomem *global_reg;
+	struct func_dram __iomem *dram;
 	int port;
 	struct statusArea *statStg;
 	dma_addr_t statStg_pci;
@@ -256,7 +256,7 @@ struct icom_port {
 };
 
 struct icom_adapter {
-	unsigned long base_addr;
+	void __iomem * base_addr;
 	unsigned long base_addr_pci;
 	unsigned char irq_number;
 	struct pci_dev *pci_dev;
@@ -278,12 +278,12 @@ struct icom_adapter {
 extern void iCom_sercons_init(void);
 
 struct lookup_proc_table {
-	u32	*global_control_reg;
+	u32	__iomem *global_control_reg;
 	unsigned long	processor_id;
 };
 
 struct lookup_int_table {
-	u32	*global_int_mask;
+	u32	__iomem *global_int_mask;
 	unsigned long	processor_id;
 };
 
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/mpsc.c linux-2.6.11-rc3/drivers/serial/mpsc.c
--- linux-2.6.11-rc2-bk10/drivers/serial/mpsc.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/mpsc.c	2005-02-03 02:56:21.000000000 +0100
@@ -36,16 +36,14 @@
  *
  * 1) Some chips have an erratum where several regs cannot be
  * read.  To work around that, we keep a local copy of those regs in
- * 'mpsc_port_info' and use the *_M or *_S macros when accessing those regs.
+ * 'mpsc_port_info'.
  *
  * 2) Some chips have an erratum where the ctlr will hang when the SDMA ctlr
- * accesses system mem in a cache coherent region.  This *should* be a
- * show-stopper when coherency is turned on but it seems to work okay as
- * long as there are no snoop hits.  Therefore, the ring buffer entries and
- * the buffers themselves are allocated via 'dma_alloc_noncoherent()' and
- * 'dma_cache_sync()' is used.  Also, since most PPC platforms are coherent
- * which makes 'dma_cache_sync()' a no-op, explicit cache management macros
- * have been added ensuring there are no snoop hits when coherency is on.
+ * accesses system mem with coherency enabled.  For that reason, the driver
+ * assumes that coherency for that ctlr has been disabled.  This means
+ * that when in a cache coherent system, the driver has to manually manage
+ * the data cache on the areas that it touches because the dma_* macro are
+ * basically no-ops.
  *
  * 3) There is an erratum (on PPC) where you can't use the instruction to do
  * a DMA_TO_DEVICE/cache clean so DMA_BIDIRECTIONAL/flushes are used in places
@@ -54,7 +52,6 @@
  * 4) AFAICT, hardware flow control isn't supported by the controller --MAG.
  */
 
-#include <linux/mv64xxx.h>
 #include "mpsc.h"
 
 /*
@@ -81,25 +78,48 @@ static struct mpsc_shared_regs mpsc_shar
 static void
 mpsc_brg_init(struct mpsc_port_info *pi, u32 clk_src)
 {
+	u32	v;
+
+	v = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);
+	v = (v & ~(0xf << 18)) | ((clk_src & 0xf) << 18);
+
 	if (pi->brg_can_tune)
-		MPSC_MOD_FIELD_M(pi, brg, BRG_BCR, 1, 25, 0);
+		v &= ~(1 << 25);
+
+	if (pi->mirror_regs)
+		pi->BRG_BCR_m = v;
+	writel(v, pi->brg_base + BRG_BCR);
 
-	MPSC_MOD_FIELD_M(pi, brg, BRG_BCR, 4, 18, clk_src);
-	MPSC_MOD_FIELD(pi, brg, BRG_BTR, 16, 0, 0);
+	writel(readl(pi->brg_base + BRG_BTR) & 0xffff0000,
+		pi->brg_base + BRG_BTR);
 	return;
 }
 
 static void
 mpsc_brg_enable(struct mpsc_port_info *pi)
 {
-	MPSC_MOD_FIELD_M(pi, brg, BRG_BCR, 1, 16, 1);
+	u32	v;
+
+	v = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);
+	v |= (1 << 16);
+
+	if (pi->mirror_regs)
+		pi->BRG_BCR_m = v;
+	writel(v, pi->brg_base + BRG_BCR);
 	return;
 }
 
 static void
 mpsc_brg_disable(struct mpsc_port_info *pi)
 {
-	MPSC_MOD_FIELD_M(pi, brg, BRG_BCR, 1, 16, 0);
+	u32	v;
+
+	v = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);
+	v &= ~(1 << 16);
+
+	if (pi->mirror_regs)
+		pi->BRG_BCR_m = v;
+	writel(v, pi->brg_base + BRG_BCR);
 	return;
 }
 
@@ -115,10 +135,16 @@ mpsc_set_baudrate(struct mpsc_port_info 
 	 * that accounts for the way the mpsc is set up is:
 	 * CDV = (clk / (baud*2*16)) - 1 ==> CDV = (clk / (baud << 5)) - 1.
 	 */
-	u32 cdv = (pi->port.uartclk / (baud << 5)) - 1;
+	u32	cdv = (pi->port.uartclk / (baud << 5)) - 1;
+	u32	v;
 
 	mpsc_brg_disable(pi);
-	MPSC_MOD_FIELD_M(pi, brg, BRG_BCR, 16, 0, cdv);
+	v = (pi->mirror_regs) ? pi->BRG_BCR_m : readl(pi->brg_base + BRG_BCR);
+	v = (v & 0xffff0000) | (cdv & 0xffff);
+
+	if (pi->mirror_regs)
+		pi->BRG_BCR_m = v;
+	writel(v, pi->brg_base + BRG_BCR);
 	mpsc_brg_enable(pi);
 
 	return;
@@ -135,7 +161,7 @@ mpsc_set_baudrate(struct mpsc_port_info 
 static void
 mpsc_sdma_burstsize(struct mpsc_port_info *pi, u32 burst_size)
 {
-	u32 v;
+	u32	v;
 
 	pr_debug("mpsc_sdma_burstsize[%d]: burst_size: %d\n",
 	    pi->port.line, burst_size);
@@ -151,7 +177,8 @@ mpsc_sdma_burstsize(struct mpsc_port_inf
 	else
 		v = 0x3;	/* 8 64-bit words */
 
-	MPSC_MOD_FIELD(pi, sdma, SDMA_SDC, 2, 12, v);
+	writel((readl(pi->sdma_base + SDMA_SDC) & (0x3 << 12)) | (v << 12),
+		pi->sdma_base + SDMA_SDC);
 	return;
 }
 
@@ -161,7 +188,8 @@ mpsc_sdma_init(struct mpsc_port_info *pi
 	pr_debug("mpsc_sdma_init[%d]: burst_size: %d\n", pi->port.line,
 		burst_size);
 
-	MPSC_MOD_FIELD(pi, sdma, SDMA_SDC, 10, 0, 0x03f);
+	writel((readl(pi->sdma_base + SDMA_SDC) & 0x3ff) | 0x03f,
+		pi->sdma_base + SDMA_SDC);
 	mpsc_sdma_burstsize(pi, burst_size);
 	return;
 }
@@ -169,16 +197,21 @@ mpsc_sdma_init(struct mpsc_port_info *pi
 static inline u32
 mpsc_sdma_intr_mask(struct mpsc_port_info *pi, u32 mask)
 {
-	u32 old, v;
+	u32	old, v;
 
 	pr_debug("mpsc_sdma_intr_mask[%d]: mask: 0x%x\n", pi->port.line, mask);
 
-	old = v = MPSC_READ_S(pi, sdma_intr, SDMA_INTR_MASK);
+	old = v = (pi->mirror_regs) ? pi->shared_regs->SDMA_INTR_MASK_m :
+		readl(pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);
+
 	mask &= 0xf;
 	if (pi->port.line)
 		mask <<= 8;
 	v &= ~mask;
-	MPSC_WRITE_S(pi, sdma_intr, SDMA_INTR_MASK, v);
+
+	if (pi->mirror_regs)
+		pi->shared_regs->SDMA_INTR_MASK_m = v;
+	writel(v, pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);
 
 	if (pi->port.line)
 		old >>= 8;
@@ -188,16 +221,21 @@ mpsc_sdma_intr_mask(struct mpsc_port_inf
 static inline void
 mpsc_sdma_intr_unmask(struct mpsc_port_info *pi, u32 mask)
 {
-	u32 v;
+	u32	v;
 
 	pr_debug("mpsc_sdma_intr_unmask[%d]: mask: 0x%x\n", pi->port.line,mask);
 
-	v = MPSC_READ_S(pi, sdma_intr, SDMA_INTR_MASK);
+	v = (pi->mirror_regs) ? pi->shared_regs->SDMA_INTR_MASK_m :
+		readl(pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);
+
 	mask &= 0xf;
 	if (pi->port.line)
 		mask <<= 8;
 	v |= mask;
-	MPSC_WRITE_S(pi, sdma_intr, SDMA_INTR_MASK, v);
+
+	if (pi->mirror_regs)
+		pi->shared_regs->SDMA_INTR_MASK_m = v;
+	writel(v, pi->shared_regs->sdma_intr_base + SDMA_INTR_MASK);
 	return;
 }
 
@@ -205,7 +243,10 @@ static inline void
 mpsc_sdma_intr_ack(struct mpsc_port_info *pi)
 {
 	pr_debug("mpsc_sdma_intr_ack[%d]: Acknowledging IRQ\n", pi->port.line);
-	MPSC_WRITE_S(pi, sdma_intr, SDMA_INTR_CAUSE, 0);
+
+	if (pi->mirror_regs)
+		pi->shared_regs->SDMA_INTR_CAUSE_m = 0;
+	writel(0, pi->shared_regs->sdma_intr_base + SDMA_INTR_CAUSE);
 	return;
 }
 
@@ -215,30 +256,30 @@ mpsc_sdma_set_rx_ring(struct mpsc_port_i
 	pr_debug("mpsc_sdma_set_rx_ring[%d]: rxre_p: 0x%x\n",
 		pi->port.line, (u32) rxre_p);
 
-	MPSC_WRITE(pi, sdma, SDMA_SCRDP, (u32) rxre_p);
+	writel((u32)rxre_p, pi->sdma_base + SDMA_SCRDP);
 	return;
 }
 
 static inline void
 mpsc_sdma_set_tx_ring(struct mpsc_port_info *pi, struct mpsc_tx_desc *txre_p)
 {
-	MPSC_WRITE(pi, sdma, SDMA_SFTDP, (u32) txre_p);
-	MPSC_WRITE(pi, sdma, SDMA_SCTDP, (u32) txre_p);
+	writel((u32)txre_p, pi->sdma_base + SDMA_SFTDP);
+	writel((u32)txre_p, pi->sdma_base + SDMA_SCTDP);
 	return;
 }
 
 static inline void
 mpsc_sdma_cmd(struct mpsc_port_info *pi, u32 val)
 {
-	u32 v;
+	u32	v;
 
-	v = MPSC_READ(pi, sdma, SDMA_SDCM);
+	v = readl(pi->sdma_base + SDMA_SDCM);
 	if (val)
 		v |= val;
 	else
 		v = 0;
 	wmb();
-	MPSC_WRITE(pi, sdma, SDMA_SDCM, v);
+	writel(v, pi->sdma_base + SDMA_SDCM);
 	wmb();
 	return;
 }
@@ -246,7 +287,7 @@ mpsc_sdma_cmd(struct mpsc_port_info *pi,
 static inline uint
 mpsc_sdma_tx_active(struct mpsc_port_info *pi)
 {
-	return MPSC_READ(pi, sdma, SDMA_SDCM) & SDMA_SDCM_TXD;
+	return readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_TXD;
 }
 
 static inline void
@@ -259,7 +300,11 @@ mpsc_sdma_start_tx(struct mpsc_port_info
 		txre = (struct mpsc_tx_desc *)(pi->txr +
 			(pi->txr_tail * MPSC_TXRE_SIZE));
 		dma_cache_sync((void *) txre, MPSC_TXRE_SIZE, DMA_FROM_DEVICE);
-		MPSC_CACHE_INVALIDATE(pi, (u32)txre, (u32)txre+MPSC_TXRE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			invalidate_dcache_range((ulong)txre,
+				(ulong)txre + MPSC_TXRE_SIZE);
+#endif
 
 		if (be32_to_cpu(txre->cmdstat) & SDMA_DESC_CMDSTAT_O) {
 			txre_p = (struct mpsc_tx_desc *)(pi->txr_p +
@@ -305,32 +350,61 @@ mpsc_sdma_stop(struct mpsc_port_info *pi
 static void
 mpsc_hw_init(struct mpsc_port_info *pi)
 {
+	u32	v;
+
 	pr_debug("mpsc_hw_init[%d]: Initializing hardware\n", pi->port.line);
 
 	/* Set up clock routing */
-	MPSC_MOD_FIELD_S(pi, mpsc_routing, MPSC_MRR, 3, 0, 0);
-	MPSC_MOD_FIELD_S(pi, mpsc_routing, MPSC_MRR, 3, 6, 0);
-	MPSC_MOD_FIELD_S(pi, mpsc_routing, MPSC_RCRR, 4, 0, 0);
-	MPSC_MOD_FIELD_S(pi, mpsc_routing, MPSC_RCRR, 4, 8, 1);
-	MPSC_MOD_FIELD_S(pi, mpsc_routing, MPSC_TCRR, 4, 0, 0);
-	MPSC_MOD_FIELD_S(pi, mpsc_routing, MPSC_TCRR, 4, 8, 1);
+	if (pi->mirror_regs) {
+		v = pi->shared_regs->MPSC_MRR_m;
+		v &= ~0x1c7;
+		pi->shared_regs->MPSC_MRR_m = v;
+		writel(v, pi->shared_regs->mpsc_routing_base + MPSC_MRR);
+
+		v = pi->shared_regs->MPSC_RCRR_m;
+		v = (v & ~0xf0f) | 0x100;
+		pi->shared_regs->MPSC_RCRR_m = v;
+		writel(v, pi->shared_regs->mpsc_routing_base + MPSC_RCRR);
+
+		v = pi->shared_regs->MPSC_TCRR_m;
+		v = (v & ~0xf0f) | 0x100;
+		pi->shared_regs->MPSC_TCRR_m = v;
+		writel(v, pi->shared_regs->mpsc_routing_base + MPSC_TCRR);
+	}
+	else {
+		v = readl(pi->shared_regs->mpsc_routing_base + MPSC_MRR);
+		v &= ~0x1c7;
+		writel(v, pi->shared_regs->mpsc_routing_base + MPSC_MRR);
+
+		v = readl(pi->shared_regs->mpsc_routing_base + MPSC_RCRR);
+		v = (v & ~0xf0f) | 0x100;
+		writel(v, pi->shared_regs->mpsc_routing_base + MPSC_RCRR);
+
+		v = readl(pi->shared_regs->mpsc_routing_base + MPSC_TCRR);
+		v = (v & ~0xf0f) | 0x100;
+		writel(v, pi->shared_regs->mpsc_routing_base + MPSC_TCRR);
+	}
 
 	/* Put MPSC in UART mode & enabel Tx/Rx egines */
-	MPSC_WRITE(pi, mpsc, MPSC_MMCRL, 0x000004c4);
+	writel(0x000004c4, pi->mpsc_base + MPSC_MMCRL);
 
 	/* No preamble, 16x divider, low-latency,  */
-	MPSC_WRITE(pi, mpsc, MPSC_MMCRH, 0x04400400);
+	writel(0x04400400, pi->mpsc_base + MPSC_MMCRH);
 
-	MPSC_WRITE_M(pi, mpsc, MPSC_CHR_1, 0);
-	MPSC_WRITE_M(pi, mpsc, MPSC_CHR_2, 0);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_3, pi->mpsc_max_idle);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_4, 0);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_5, 0);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_6, 0);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_7, 0);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_8, 0);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_9, 0);
-	MPSC_WRITE(pi, mpsc, MPSC_CHR_10, 0);
+	if (pi->mirror_regs) {
+		pi->MPSC_CHR_1_m = 0;
+		pi->MPSC_CHR_2_m = 0;
+	}
+	writel(0, pi->mpsc_base + MPSC_CHR_1);
+	writel(0, pi->mpsc_base + MPSC_CHR_2);
+	writel(pi->mpsc_max_idle, pi->mpsc_base + MPSC_CHR_3);
+	writel(0, pi->mpsc_base + MPSC_CHR_4);
+	writel(0, pi->mpsc_base + MPSC_CHR_5);
+	writel(0, pi->mpsc_base + MPSC_CHR_6);
+	writel(0, pi->mpsc_base + MPSC_CHR_7);
+	writel(0, pi->mpsc_base + MPSC_CHR_8);
+	writel(0, pi->mpsc_base + MPSC_CHR_9);
+	writel(0, pi->mpsc_base + MPSC_CHR_10);
 
 	return;
 }
@@ -338,19 +412,21 @@ mpsc_hw_init(struct mpsc_port_info *pi)
 static inline void
 mpsc_enter_hunt(struct mpsc_port_info *pi)
 {
-	u32 v;
-
 	pr_debug("mpsc_enter_hunt[%d]: Hunting...\n", pi->port.line);
 
-	MPSC_MOD_FIELD_M(pi, mpsc, MPSC_CHR_2, 1, 31, 1);
-
-	/* If erratum prevents reading CHR_2, just delay for a while */
-	if (pi->mirror_regs)
+	if (pi->mirror_regs) {
+		writel(pi->MPSC_CHR_2_m | MPSC_CHR_2_EH,
+			pi->mpsc_base + MPSC_CHR_2);
+		/* Erratum prevents reading CHR_2 so just delay for a while */
 		udelay(100);
-	else
-		do {
-			v = MPSC_READ_M(pi, mpsc, MPSC_CHR_2);
-		} while (v & MPSC_CHR_2_EH);
+	}
+	else {
+		writel(readl(pi->mpsc_base + MPSC_CHR_2) | MPSC_CHR_2_EH,
+			pi->mpsc_base + MPSC_CHR_2);
+
+		while (readl(pi->mpsc_base + MPSC_CHR_2) & MPSC_CHR_2_EH)
+			udelay(10);
+	}
 
 	return;
 }
@@ -358,16 +434,32 @@ mpsc_enter_hunt(struct mpsc_port_info *p
 static inline void
 mpsc_freeze(struct mpsc_port_info *pi)
 {
+	u32	v;
+
 	pr_debug("mpsc_freeze[%d]: Freezing\n", pi->port.line);
 
-	MPSC_MOD_FIELD_M(pi, mpsc, MPSC_MPCR, 1, 9, 1);
+	v = (pi->mirror_regs) ? pi->MPSC_MPCR_m :
+		readl(pi->mpsc_base + MPSC_MPCR);
+	v |= MPSC_MPCR_FRZ;
+
+	if (pi->mirror_regs)
+		pi->MPSC_MPCR_m = v;
+	writel(v, pi->mpsc_base + MPSC_MPCR);
 	return;
 }
 
 static inline void
 mpsc_unfreeze(struct mpsc_port_info *pi)
 {
-	MPSC_MOD_FIELD_M(pi, mpsc, MPSC_MPCR, 1, 9, 0);
+	u32	v;
+
+	v = (pi->mirror_regs) ? pi->MPSC_MPCR_m :
+		readl(pi->mpsc_base + MPSC_MPCR);
+	v &= ~MPSC_MPCR_FRZ;
+
+	if (pi->mirror_regs)
+		pi->MPSC_MPCR_m = v;
+	writel(v, pi->mpsc_base + MPSC_MPCR);
 
 	pr_debug("mpsc_unfreeze[%d]: Unfrozen\n", pi->port.line);
 	return;
@@ -376,29 +468,55 @@ mpsc_unfreeze(struct mpsc_port_info *pi)
 static inline void
 mpsc_set_char_length(struct mpsc_port_info *pi, u32 len)
 {
+	u32	v;
+
 	pr_debug("mpsc_set_char_length[%d]: char len: %d\n", pi->port.line,len);
 
-	MPSC_MOD_FIELD_M(pi, mpsc, MPSC_MPCR, 2, 12, len);
+	v = (pi->mirror_regs) ? pi->MPSC_MPCR_m :
+		readl(pi->mpsc_base + MPSC_MPCR);
+	v = (v & ~(0x3 << 12)) | ((len & 0x3) << 12);
+
+	if (pi->mirror_regs)
+		pi->MPSC_MPCR_m = v;
+	writel(v, pi->mpsc_base + MPSC_MPCR);
 	return;
 }
 
 static inline void
 mpsc_set_stop_bit_length(struct mpsc_port_info *pi, u32 len)
 {
+	u32	v;
+
 	pr_debug("mpsc_set_stop_bit_length[%d]: stop bits: %d\n",
 		pi->port.line, len);
 
-	MPSC_MOD_FIELD_M(pi, mpsc, MPSC_MPCR, 1, 14, len);
+	v = (pi->mirror_regs) ? pi->MPSC_MPCR_m :
+		readl(pi->mpsc_base + MPSC_MPCR);
+
+	v = (v & ~(1 << 14)) | ((len & 0x1) << 14);
+
+	if (pi->mirror_regs)
+		pi->MPSC_MPCR_m = v;
+	writel(v, pi->mpsc_base + MPSC_MPCR);
 	return;
 }
 
 static inline void
 mpsc_set_parity(struct mpsc_port_info *pi, u32 p)
 {
+	u32	v;
+
 	pr_debug("mpsc_set_parity[%d]: parity bits: 0x%x\n", pi->port.line, p);
 
-	MPSC_MOD_FIELD_M(pi, mpsc, MPSC_CHR_2, 2, 2, p);	/* TPM */
-	MPSC_MOD_FIELD_M(pi, mpsc, MPSC_CHR_2, 2, 18, p);	/* RPM */
+	v = (pi->mirror_regs) ? pi->MPSC_CHR_2_m :
+		readl(pi->mpsc_base + MPSC_CHR_2);
+
+	p &= 0x3;
+	v = (v & ~0xc000c) | (p << 18) | (p << 2);
+
+	if (pi->mirror_regs)
+		pi->MPSC_CHR_2_m = v;
+	writel(v, pi->mpsc_base + MPSC_CHR_2);
 	return;
 }
 
@@ -560,8 +678,11 @@ mpsc_init_rings(struct mpsc_port_info *p
 
 	dma_cache_sync((void *) pi->dma_region, MPSC_DMA_ALLOC_SIZE,
 		DMA_BIDIRECTIONAL);
-	MPSC_CACHE_FLUSH(pi, pi->dma_region,
-		pi->dma_region + MPSC_DMA_ALLOC_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			flush_dcache_range((ulong)pi->dma_region,
+				(ulong)pi->dma_region + MPSC_DMA_ALLOC_SIZE);
+#endif
 
 	return;
 }
@@ -631,7 +752,11 @@ mpsc_rx_intr(struct mpsc_port_info *pi, 
 	rxre = (struct mpsc_rx_desc *)(pi->rxr + (pi->rxr_posn*MPSC_RXRE_SIZE));
 
 	dma_cache_sync((void *)rxre, MPSC_RXRE_SIZE, DMA_FROM_DEVICE);
-	MPSC_CACHE_INVALIDATE(pi, (u32) rxre, (u32) rxre + MPSC_RXRE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+	if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+		invalidate_dcache_range((ulong)rxre,
+			(ulong)rxre + MPSC_RXRE_SIZE);
+#endif
 
 	/*
 	 * Loop through Rx descriptors handling ones that have been completed.
@@ -651,7 +776,11 @@ mpsc_rx_intr(struct mpsc_port_info *pi, 
 
 		bp = pi->rxb + (pi->rxr_posn * MPSC_RXBE_SIZE);
 		dma_cache_sync((void *) bp, MPSC_RXBE_SIZE, DMA_FROM_DEVICE);
-		MPSC_CACHE_INVALIDATE(pi, bp, bp + MPSC_RXBE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			invalidate_dcache_range((ulong)bp,
+				(ulong)bp + MPSC_RXBE_SIZE);
+#endif
 
 		/*
 		 * Other than for parity error, the manual provides little
@@ -716,20 +845,28 @@ next_frame:
 					    SDMA_DESC_CMDSTAT_L);
 		wmb();
 		dma_cache_sync((void *)rxre, MPSC_RXRE_SIZE, DMA_BIDIRECTIONAL);
-		MPSC_CACHE_FLUSH(pi, (u32) rxre, (u32) rxre + MPSC_RXRE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			flush_dcache_range((ulong)rxre,
+				(ulong)rxre + MPSC_RXRE_SIZE);
+#endif
 
 		/* Advance to next descriptor */
 		pi->rxr_posn = (pi->rxr_posn + 1) & (MPSC_RXR_ENTRIES - 1);
 		rxre = (struct mpsc_rx_desc *)(pi->rxr +
 			(pi->rxr_posn * MPSC_RXRE_SIZE));
 		dma_cache_sync((void *)rxre, MPSC_RXRE_SIZE, DMA_FROM_DEVICE);
-		MPSC_CACHE_INVALIDATE(pi, (u32)rxre, (u32)rxre+MPSC_RXRE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			invalidate_dcache_range((ulong)rxre,
+				(ulong)rxre + MPSC_RXRE_SIZE);
+#endif
 
 		rc = 1;
 	}
 
 	/* Restart rx engine, if its stopped */
-	if ((MPSC_READ(pi, sdma, SDMA_SDCM) & SDMA_SDCM_ERD) == 0)
+	if ((readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_ERD) == 0)
 		mpsc_start_rx(pi);
 
 	tty_flip_buffer_push(tty);
@@ -753,7 +890,11 @@ mpsc_setup_tx_desc(struct mpsc_port_info
 							   : 0));
 	wmb();
 	dma_cache_sync((void *) txre, MPSC_TXRE_SIZE, DMA_BIDIRECTIONAL);
-	MPSC_CACHE_FLUSH(pi, (u32) txre, (u32) txre + MPSC_TXRE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+	if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+		flush_dcache_range((ulong)txre,
+			(ulong)txre + MPSC_TXRE_SIZE);
+#endif
 
 	return;
 }
@@ -798,7 +939,11 @@ mpsc_copy_tx_data(struct mpsc_port_info 
 			return;
 
 		dma_cache_sync((void *) bp, MPSC_TXBE_SIZE, DMA_BIDIRECTIONAL);
-		MPSC_CACHE_FLUSH(pi, bp, bp + MPSC_TXBE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			flush_dcache_range((ulong)bp,
+				(ulong)bp + MPSC_TXBE_SIZE);
+#endif
 		mpsc_setup_tx_desc(pi, i, 1);
 
 		/* Advance to next descriptor */
@@ -819,7 +964,11 @@ mpsc_tx_intr(struct mpsc_port_info *pi)
 			(pi->txr_tail * MPSC_TXRE_SIZE));
 
 		dma_cache_sync((void *) txre, MPSC_TXRE_SIZE, DMA_FROM_DEVICE);
-		MPSC_CACHE_INVALIDATE(pi, (u32) txre, (u32)txre+MPSC_TXRE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			invalidate_dcache_range((ulong)txre,
+				(ulong)txre + MPSC_TXRE_SIZE);
+#endif
 
 		while (!(be32_to_cpu(txre->cmdstat) & SDMA_DESC_CMDSTAT_O)) {
 			rc = 1;
@@ -834,8 +983,11 @@ mpsc_tx_intr(struct mpsc_port_info *pi)
 				(pi->txr_tail * MPSC_TXRE_SIZE));
 			dma_cache_sync((void *) txre, MPSC_TXRE_SIZE,
 				DMA_FROM_DEVICE);
-			MPSC_CACHE_INVALIDATE(pi, (u32) txre,
-			      (u32) txre + MPSC_TXRE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+			if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+				invalidate_dcache_range((ulong)txre,
+					(ulong)txre + MPSC_TXRE_SIZE);
+#endif
 		}
 
 		mpsc_copy_tx_data(pi);
@@ -907,7 +1059,8 @@ mpsc_get_mctrl(struct uart_port *port)
 	ulong iflags;
 
 	spin_lock_irqsave(&pi->port.lock, iflags);
-	status = MPSC_READ_M(pi, mpsc, MPSC_CHR_10);
+	status = (pi->mirror_regs) ? pi->MPSC_CHR_10_m :
+		readl(pi->mpsc_base + MPSC_CHR_10);
 	spin_unlock_irqrestore(&pi->port.lock, iflags);
 
 	mflags = 0;
@@ -976,13 +1129,15 @@ static void
 mpsc_break_ctl(struct uart_port *port, int ctl)
 {
 	struct mpsc_port_info *pi = (struct mpsc_port_info *)port;
-	ulong flags;
+	ulong	flags;
+	u32	v;
+
+	v = ctl ? 0x00ff0000 : 0;
 
 	spin_lock_irqsave(&pi->port.lock, flags);
-	if (ctl) /* Send as many BRK chars as we can */
-		MPSC_WRITE_M(pi, mpsc, MPSC_CHR_1, 0x00ff0000);
-	else /* Stop sending BRK chars */
-		MPSC_WRITE_M(pi, mpsc, MPSC_CHR_1, 0);
+	if (pi->mirror_regs)
+		pi->MPSC_CHR_1_m = v;
+	writel(v, pi->mpsc_base + MPSC_CHR_1);
 	spin_unlock_irqrestore(&pi->port.lock, flags);
 
 	return;
@@ -1246,7 +1401,11 @@ mpsc_console_write(struct console *co, c
 		}
 
 		dma_cache_sync((void *) bp, MPSC_TXBE_SIZE, DMA_BIDIRECTIONAL);
-		MPSC_CACHE_FLUSH(pi, bp, bp + MPSC_TXBE_SIZE);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+		if (pi->cache_mgmt) /* GT642[46]0 Res #COMM-2 */
+			flush_dcache_range((ulong)bp,
+				(ulong)bp + MPSC_TXBE_SIZE);
+#endif
 		mpsc_setup_tx_desc(pi, i, 0);
 		pi->txr_head = (pi->txr_head + 1) & (MPSC_TXR_ENTRIES - 1);
 		mpsc_sdma_start_tx(pi);
@@ -1339,7 +1498,7 @@ mpsc_shared_map_regs(struct platform_dev
 		MPSC_ROUTING_BASE_ORDER)) && request_mem_region(r->start,
 		MPSC_ROUTING_REG_BLOCK_SIZE, "mpsc_routing_regs")) {
 
-		mpsc_shared_regs.mpsc_routing_base = (u32) ioremap(r->start,
+		mpsc_shared_regs.mpsc_routing_base = ioremap(r->start,
 			MPSC_ROUTING_REG_BLOCK_SIZE);
 		mpsc_shared_regs.mpsc_routing_base_p = r->start;
 	}
@@ -1352,12 +1511,12 @@ mpsc_shared_map_regs(struct platform_dev
 		MPSC_SDMA_INTR_BASE_ORDER)) && request_mem_region(r->start,
 		MPSC_SDMA_INTR_REG_BLOCK_SIZE, "sdma_intr_regs")) {
 
-		mpsc_shared_regs.sdma_intr_base = (u32) ioremap(r->start,
+		mpsc_shared_regs.sdma_intr_base = ioremap(r->start,
 			MPSC_SDMA_INTR_REG_BLOCK_SIZE);
 		mpsc_shared_regs.sdma_intr_base_p = r->start;
 	}
 	else {
-		iounmap((void *)mpsc_shared_regs.mpsc_routing_base);
+		iounmap(mpsc_shared_regs.mpsc_routing_base);
 		release_mem_region(mpsc_shared_regs.mpsc_routing_base_p,
 			MPSC_ROUTING_REG_BLOCK_SIZE);
 		mpsc_resource_err("SDMA intr base");
@@ -1371,12 +1530,12 @@ static void
 mpsc_shared_unmap_regs(void)
 {
 	if (!mpsc_shared_regs.mpsc_routing_base) {
-		iounmap((void *)mpsc_shared_regs.mpsc_routing_base);
+		iounmap(mpsc_shared_regs.mpsc_routing_base);
 		release_mem_region(mpsc_shared_regs.mpsc_routing_base_p,
 			MPSC_ROUTING_REG_BLOCK_SIZE);
 	}
 	if (!mpsc_shared_regs.sdma_intr_base) {
-		iounmap((void *)mpsc_shared_regs.sdma_intr_base);
+		iounmap(mpsc_shared_regs.sdma_intr_base);
 		release_mem_region(mpsc_shared_regs.sdma_intr_base_p,
 			MPSC_SDMA_INTR_REG_BLOCK_SIZE);
 	}
@@ -1394,21 +1553,20 @@ static int
 mpsc_shared_drv_probe(struct device *dev)
 {
 	struct platform_device		*pd = to_platform_device(dev);
-	struct mpsc_shared_pd_dd	*dd;
+	struct mpsc_shared_pdata	*pdata;
 	int				 rc = -ENODEV;
 
 	if (pd->id == 0) {
 		if (!(rc = mpsc_shared_map_regs(pd)))  {
-			dd = (struct mpsc_shared_pd_dd *)
-				dev_get_drvdata(dev);
+			pdata = (struct mpsc_shared_pdata *)dev->platform_data;
 
-			mpsc_shared_regs.MPSC_MRR_m = dd->mrr_val;
-			mpsc_shared_regs.MPSC_RCRR_m= dd->rcrr_val;
-			mpsc_shared_regs.MPSC_TCRR_m= dd->tcrr_val;
+			mpsc_shared_regs.MPSC_MRR_m = pdata->mrr_val;
+			mpsc_shared_regs.MPSC_RCRR_m= pdata->rcrr_val;
+			mpsc_shared_regs.MPSC_TCRR_m= pdata->tcrr_val;
 			mpsc_shared_regs.SDMA_INTR_CAUSE_m =
-				dd->intr_cause_val;
+				pdata->intr_cause_val;
 			mpsc_shared_regs.SDMA_INTR_MASK_m =
-				dd->intr_mask_val;
+				pdata->intr_mask_val;
 
 			rc = 0;
 		}
@@ -1469,7 +1627,7 @@ mpsc_drv_map_regs(struct mpsc_port_info 
 	if ((r = platform_get_resource(pd, IORESOURCE_MEM, MPSC_BASE_ORDER)) &&
 		request_mem_region(r->start, MPSC_REG_BLOCK_SIZE, "mpsc_regs")){
 
-		pi->mpsc_base = (u32) ioremap(r->start, MPSC_REG_BLOCK_SIZE);
+		pi->mpsc_base = ioremap(r->start, MPSC_REG_BLOCK_SIZE);
 		pi->mpsc_base_p = r->start;
 	}
 	else {
@@ -1481,7 +1639,7 @@ mpsc_drv_map_regs(struct mpsc_port_info 
 		MPSC_SDMA_BASE_ORDER)) && request_mem_region(r->start,
 		MPSC_SDMA_REG_BLOCK_SIZE, "sdma_regs")) {
 
-		pi->sdma_base = (u32)ioremap(r->start,MPSC_SDMA_REG_BLOCK_SIZE);
+		pi->sdma_base = ioremap(r->start,MPSC_SDMA_REG_BLOCK_SIZE);
 		pi->sdma_base_p = r->start;
 	}
 	else {
@@ -1493,7 +1651,7 @@ mpsc_drv_map_regs(struct mpsc_port_info 
 		&& request_mem_region(r->start, MPSC_BRG_REG_BLOCK_SIZE,
 		"brg_regs")) {
 
-		pi->brg_base = (u32) ioremap(r->start, MPSC_BRG_REG_BLOCK_SIZE);
+		pi->brg_base = ioremap(r->start, MPSC_BRG_REG_BLOCK_SIZE);
 		pi->brg_base_p = r->start;
 	}
 	else {
@@ -1508,15 +1666,15 @@ static void
 mpsc_drv_unmap_regs(struct mpsc_port_info *pi)
 {
 	if (!pi->mpsc_base) {
-		iounmap((void *)pi->mpsc_base);
+		iounmap(pi->mpsc_base);
 		release_mem_region(pi->mpsc_base_p, MPSC_REG_BLOCK_SIZE);
 	}
 	if (!pi->sdma_base) {
-		iounmap((void *)pi->sdma_base);
+		iounmap(pi->sdma_base);
 		release_mem_region(pi->sdma_base_p, MPSC_SDMA_REG_BLOCK_SIZE);
 	}
 	if (!pi->brg_base) {
-		iounmap((void *)pi->brg_base);
+		iounmap(pi->brg_base);
 		release_mem_region(pi->brg_base_p, MPSC_BRG_REG_BLOCK_SIZE);
 	}
 
@@ -1535,35 +1693,35 @@ static void
 mpsc_drv_get_platform_data(struct mpsc_port_info *pi,
 	struct platform_device *pd, int num)
 {
-	struct mpsc_pd_dd	*dd;
+	struct mpsc_pdata	*pdata;
 
-	dd = (struct mpsc_pd_dd *)dev_get_drvdata(&pd->dev);
+	pdata = (struct mpsc_pdata *)pd->dev.platform_data;
 
-	pi->port.uartclk = dd->brg_clk_freq;
+	pi->port.uartclk = pdata->brg_clk_freq;
 	pi->port.iotype = UPIO_MEM;
 	pi->port.line = num;
 	pi->port.type = PORT_MPSC;
 	pi->port.fifosize = MPSC_TXBE_SIZE;
-	pi->port.membase = (char *)pi->mpsc_base;
-	pi->port.mapbase = (ulong) pi->mpsc_base;
+	pi->port.membase = pi->mpsc_base;
+	pi->port.mapbase = (ulong)pi->mpsc_base;
 	pi->port.ops = &mpsc_pops;
 
-	pi->mirror_regs = dd->mirror_regs;
-	pi->cache_mgmt = dd->cache_mgmt;
-	pi->brg_can_tune = dd->brg_can_tune;
-	pi->brg_clk_src = dd->brg_clk_src;
-	pi->mpsc_max_idle = dd->max_idle;
-	pi->default_baud = dd->default_baud;
-	pi->default_bits = dd->default_bits;
-	pi->default_parity = dd->default_parity;
-	pi->default_flow = dd->default_flow;
+	pi->mirror_regs = pdata->mirror_regs;
+	pi->cache_mgmt = pdata->cache_mgmt;
+	pi->brg_can_tune = pdata->brg_can_tune;
+	pi->brg_clk_src = pdata->brg_clk_src;
+	pi->mpsc_max_idle = pdata->max_idle;
+	pi->default_baud = pdata->default_baud;
+	pi->default_bits = pdata->default_bits;
+	pi->default_parity = pdata->default_parity;
+	pi->default_flow = pdata->default_flow;
 
 	/* Initial values of mirrored regs */
-	pi->MPSC_CHR_1_m = dd->chr_1_val;
-	pi->MPSC_CHR_2_m = dd->chr_2_val;
-	pi->MPSC_CHR_10_m = dd->chr_10_val;
-	pi->MPSC_MPCR_m = dd->mpcr_val;
-	pi->BRG_BCR_m = dd->bcr_val;
+	pi->MPSC_CHR_1_m = pdata->chr_1_val;
+	pi->MPSC_CHR_2_m = pdata->chr_2_val;
+	pi->MPSC_CHR_10_m = pdata->chr_10_val;
+	pi->MPSC_MPCR_m = pdata->mpcr_val;
+	pi->BRG_BCR_m = pdata->bcr_val;
 
 	pi->shared_regs = &mpsc_shared_regs;
 
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/mpsc.h linux-2.6.11-rc3/drivers/serial/mpsc.h
--- linux-2.6.11-rc2-bk10/drivers/serial/mpsc.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/mpsc.h	2005-02-03 02:56:33.000000000 +0100
@@ -22,9 +22,11 @@
 #include <linux/console.h>
 #include <linux/sysrq.h>
 #include <linux/serial.h>
+#include <linux/serial_core.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
+#include <linux/mv643xx.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -33,8 +35,7 @@
 #define SUPPORT_SYSRQ
 #endif
 
-#include <linux/serial_core.h>
-#include "mpsc_defs.h"
+#define	MPSC_NUM_CTLRS		2
 
 /*
  * Descriptors and buffers must be cache line aligned.
@@ -79,11 +80,11 @@ struct mpsc_tx_desc {
  * between the two MPSC controllers.  This struct contains those shared regs.
  */
 struct mpsc_shared_regs {
-	u32 mpsc_routing_base_p;
-	u32 sdma_intr_base_p;
+	phys_addr_t mpsc_routing_base_p;
+	phys_addr_t sdma_intr_base_p;
 
-	u32 mpsc_routing_base;
-	u32 sdma_intr_base;
+	void *mpsc_routing_base;
+	void *sdma_intr_base;
 
 	u32 MPSC_MRR_m;
 	u32 MPSC_RCRR_m;
@@ -114,14 +115,14 @@ struct mpsc_port_info {
 	int default_flow;
 
 	/* Physical addresses of various blocks of registers (from platform) */
-	u32 mpsc_base_p;
-	u32 sdma_base_p;
-	u32 brg_base_p;
+	phys_addr_t mpsc_base_p;
+	phys_addr_t sdma_base_p;
+	phys_addr_t brg_base_p;
 
 	/* Virtual addresses of various blocks of registers (from platform) */
-	u32 mpsc_base;
-	u32 sdma_base;
-	u32 brg_base;
+	void *mpsc_base;
+	void *sdma_base;
+	void *brg_base;
 
 	/* Descriptor ring and buffer allocations */
 	void *dma_region;
@@ -149,135 +150,6 @@ struct mpsc_port_info {
 	struct mpsc_shared_regs *shared_regs;
 };
 
-#if defined(CONFIG_PPC32)
-
-#if defined(CONFIG_NOT_COHERENT_CACHE)
-/* No-ops when coherency is off b/c dma_cache_sync() does that work */
-#define	MPSC_CACHE_INVALIDATE(pi, s, e)
-#define	MPSC_CACHE_FLUSH(pi, s, e)
-#else /* defined(CONFIG_NOT_COHERENT_CACHE) */
-/* Coherency is on so dma_cache_sync() is no-op so must do manually */
-#define	MPSC_CACHE_INVALIDATE(pi, s, e) {			\
-	if (pi->cache_mgmt) {					\
-		invalidate_dcache_range((ulong)s, (ulong)e);	\
-	}							\
-}
-
-#define	MPSC_CACHE_FLUSH(pi, s, e) {			\
-	if (pi->cache_mgmt) {				\
-		flush_dcache_range((ulong)s, (ulong)e);	\
-	}						\
-}
-#endif /* defined(CONFIG_NOT_COHERENT_CACHE) */
-
-#else /* defined(CONFIG_PPC32) */
-/* Other architectures need to fill this in */
-#define	MPSC_CACHE_INVALIDATE(pi, s, e)	BUG()
-#define	MPSC_CACHE_FLUSH(pi, s, e)	BUG()
-#endif /* defined(CONFIG_PPC32) */
-
-/*
- * 'MASK_INSERT' takes the low-order 'n' bits of 'i', shifts it 'b' bits to
- * the left, and inserts it into the target 't'.  The corresponding bits in
- * 't' will have been cleared before the bits in 'i' are inserted.
- */
-#ifdef CONFIG_PPC32
-#define MASK_INSERT(t, i, n, b) ({				\
-	u32	rval = (t);					\
-        __asm__ __volatile__(					\
-		"rlwimi %0,%2,%4,32-(%3+%4),31-%4\n"		\
-		: "=r" (rval)					\
-		: "0" (rval), "r" (i), "i" (n), "i" (b));	\
-	rval;							\
-})
-#else
-/* These macros are really just examples.  Feel free to change them --MAG */
-#define GEN_MASK(n, b)			\
-({					\
-	u32	m, sl, sr;		\
-	sl = 32 - (n);			\
-	sr = sl - (b);			\
-	m = (0xffffffff << sl) >> sr;	\
-})
-
-#define MASK_INSERT(t, i, n, b)		\
-({					\
-	u32	m, rval = (t);		\
-	m = GEN_MASK((n), (b));		\
-	rval &= ~m;			\
-	rval |= (((i) << (b)) & m);	\
-})
-#endif
-
-/* I/O macros for regs that you can read */
-#define	MPSC_READ(pi, unit, offset)					\
-	readl((volatile void *)((pi)->unit##_base + (offset)))
-
-#define	MPSC_WRITE(pi, unit, offset, v)					\
-	writel(v, (volatile void *)((pi)->unit##_base + (offset)))
-
-#define	MPSC_MOD_FIELD(pi, unit, offset, num_bits, shift, val)		\
-{									\
-	u32	v;							\
-	v = readl((volatile void *)((pi)->unit##_base + (offset)));	\
-	writel(MASK_INSERT(v,val,num_bits,shift),			\
-		(volatile void *)((pi)->unit##_base+(offset)));		\
-}
-
-/* Macros for regs with erratum that are not shared between MPSC ctlrs */
-#define	MPSC_READ_M(pi, unit, offset)					\
-({									\
-	u32	v;							\
-	if ((pi)->mirror_regs) v = (pi)->offset##_m;			\
-	else v = readl((volatile void *)((pi)->unit##_base + (offset)));\
-	v;								\
-})
-
-#define	MPSC_WRITE_M(pi, unit, offset, v)				\
-({									\
-	if ((pi)->mirror_regs) (pi)->offset##_m = v;			\
-	writel(v, (volatile void *)((pi)->unit##_base + (offset)));	\
-})
-
-#define	MPSC_MOD_FIELD_M(pi, unit, offset, num_bits, shift, val)	\
-({									\
-	u32	v;							\
-	if ((pi)->mirror_regs) v = (pi)->offset##_m;			\
-	else v = readl((volatile void *)((pi)->unit##_base + (offset)));\
-	v = MASK_INSERT(v, val, num_bits, shift);			\
-	if ((pi)->mirror_regs) (pi)->offset##_m = v;			\
-	writel(v, (volatile void *)((pi)->unit##_base + (offset)));	\
-})
-
-/* Macros for regs with erratum that are shared between MPSC ctlrs */
-#define	MPSC_READ_S(pi, unit, offset)					\
-({									\
-	u32	v;							\
-	if ((pi)->mirror_regs) v = (pi)->shared_regs->offset##_m;	\
-	else v = readl((volatile void *)((pi)->shared_regs->unit##_base + \
-		(offset)));						\
-	v;								\
-})
-
-#define	MPSC_WRITE_S(pi, unit, offset, v)				\
-({									\
-	if ((pi)->mirror_regs) (pi)->shared_regs->offset##_m = v;	\
-	writel(v, (volatile void *)((pi)->shared_regs->unit##_base +	\
-		(offset)));						\
-})
-
-#define	MPSC_MOD_FIELD_S(pi, unit, offset, num_bits, shift, val)	\
-({									\
-	u32	v;							\
-	if ((pi)->mirror_regs) v = (pi)->shared_regs->offset##_m;	\
-	else v = readl((volatile void *)((pi)->shared_regs->unit##_base + \
-		(offset)));						\
-	v = MASK_INSERT(v, val, num_bits, shift);			\
-	if ((pi)->mirror_regs) (pi)->shared_regs->offset##_m = v;	\
-	writel(v, (volatile void *)((pi)->shared_regs->unit##_base +	\
-		(offset)));						\
-})
-
 /* Hooks to platform-specific code */
 int mpsc_platform_register_driver(void);
 void mpsc_platform_unregister_driver(void);
@@ -286,4 +158,132 @@ void mpsc_platform_unregister_driver(voi
 struct mpsc_port_info *mpsc_device_probe(int index);
 struct mpsc_port_info *mpsc_device_remove(int index);
 
+/*
+ *****************************************************************************
+ *
+ *	Multi-Protocol Serial Controller Interface Registers
+ *
+ *****************************************************************************
+ */
+
+/* Main Configuratino Register Offsets */
+#define	MPSC_MMCRL			0x0000
+#define	MPSC_MMCRH			0x0004
+#define	MPSC_MPCR			0x0008
+#define	MPSC_CHR_1			0x000c
+#define	MPSC_CHR_2			0x0010
+#define	MPSC_CHR_3			0x0014
+#define	MPSC_CHR_4			0x0018
+#define	MPSC_CHR_5			0x001c
+#define	MPSC_CHR_6			0x0020
+#define	MPSC_CHR_7			0x0024
+#define	MPSC_CHR_8			0x0028
+#define	MPSC_CHR_9			0x002c
+#define	MPSC_CHR_10			0x0030
+#define	MPSC_CHR_11			0x0034
+
+#define	MPSC_MPCR_FRZ			(1 << 9)
+#define	MPSC_MPCR_CL_5			0
+#define	MPSC_MPCR_CL_6			1
+#define	MPSC_MPCR_CL_7			2
+#define	MPSC_MPCR_CL_8			3
+#define	MPSC_MPCR_SBL_1			0
+#define	MPSC_MPCR_SBL_2			1
+
+#define	MPSC_CHR_2_TEV			(1<<1)
+#define	MPSC_CHR_2_TA			(1<<7)
+#define	MPSC_CHR_2_TTCS			(1<<9)
+#define	MPSC_CHR_2_REV			(1<<17)
+#define	MPSC_CHR_2_RA			(1<<23)
+#define	MPSC_CHR_2_CRD			(1<<25)
+#define	MPSC_CHR_2_EH			(1<<31)
+#define	MPSC_CHR_2_PAR_ODD		0
+#define	MPSC_CHR_2_PAR_SPACE		1
+#define	MPSC_CHR_2_PAR_EVEN		2
+#define	MPSC_CHR_2_PAR_MARK		3
+
+/* MPSC Signal Routing */
+#define	MPSC_MRR			0x0000
+#define	MPSC_RCRR			0x0004
+#define	MPSC_TCRR			0x0008
+
+/*
+ *****************************************************************************
+ *
+ *	Serial DMA Controller Interface Registers
+ *
+ *****************************************************************************
+ */
+
+#define	SDMA_SDC			0x0000
+#define	SDMA_SDCM			0x0008
+#define	SDMA_RX_DESC			0x0800
+#define	SDMA_RX_BUF_PTR			0x0808
+#define	SDMA_SCRDP			0x0810
+#define	SDMA_TX_DESC			0x0c00
+#define	SDMA_SCTDP			0x0c10
+#define	SDMA_SFTDP			0x0c14
+
+#define	SDMA_DESC_CMDSTAT_PE		(1<<0)
+#define	SDMA_DESC_CMDSTAT_CDL		(1<<1)
+#define	SDMA_DESC_CMDSTAT_FR		(1<<3)
+#define	SDMA_DESC_CMDSTAT_OR		(1<<6)
+#define	SDMA_DESC_CMDSTAT_BR		(1<<9)
+#define	SDMA_DESC_CMDSTAT_MI		(1<<10)
+#define	SDMA_DESC_CMDSTAT_A		(1<<11)
+#define	SDMA_DESC_CMDSTAT_AM		(1<<12)
+#define	SDMA_DESC_CMDSTAT_CT		(1<<13)
+#define	SDMA_DESC_CMDSTAT_C		(1<<14)
+#define	SDMA_DESC_CMDSTAT_ES		(1<<15)
+#define	SDMA_DESC_CMDSTAT_L		(1<<16)
+#define	SDMA_DESC_CMDSTAT_F		(1<<17)
+#define	SDMA_DESC_CMDSTAT_P		(1<<18)
+#define	SDMA_DESC_CMDSTAT_EI		(1<<23)
+#define	SDMA_DESC_CMDSTAT_O		(1<<31)
+
+#define SDMA_DESC_DFLT			(SDMA_DESC_CMDSTAT_O |	\
+					SDMA_DESC_CMDSTAT_EI)
+
+#define	SDMA_SDC_RFT			(1<<0)
+#define	SDMA_SDC_SFM			(1<<1)
+#define	SDMA_SDC_BLMR			(1<<6)
+#define	SDMA_SDC_BLMT			(1<<7)
+#define	SDMA_SDC_POVR			(1<<8)
+#define	SDMA_SDC_RIFB			(1<<9)
+
+#define	SDMA_SDCM_ERD			(1<<7)
+#define	SDMA_SDCM_AR			(1<<15)
+#define	SDMA_SDCM_STD			(1<<16)
+#define	SDMA_SDCM_TXD			(1<<23)
+#define	SDMA_SDCM_AT			(1<<31)
+
+#define	SDMA_0_CAUSE_RXBUF		(1<<0)
+#define	SDMA_0_CAUSE_RXERR		(1<<1)
+#define	SDMA_0_CAUSE_TXBUF		(1<<2)
+#define	SDMA_0_CAUSE_TXEND		(1<<3)
+#define	SDMA_1_CAUSE_RXBUF		(1<<8)
+#define	SDMA_1_CAUSE_RXERR		(1<<9)
+#define	SDMA_1_CAUSE_TXBUF		(1<<10)
+#define	SDMA_1_CAUSE_TXEND		(1<<11)
+
+#define	SDMA_CAUSE_RX_MASK	(SDMA_0_CAUSE_RXBUF | SDMA_0_CAUSE_RXERR | \
+	SDMA_1_CAUSE_RXBUF | SDMA_1_CAUSE_RXERR)
+#define	SDMA_CAUSE_TX_MASK	(SDMA_0_CAUSE_TXBUF | SDMA_0_CAUSE_TXEND | \
+	SDMA_1_CAUSE_TXBUF | SDMA_1_CAUSE_TXEND)
+
+/* SDMA Interrupt registers */
+#define	SDMA_INTR_CAUSE			0x0000
+#define	SDMA_INTR_MASK			0x0080
+
+/*
+ *****************************************************************************
+ *
+ *	Baud Rate Generator Interface Registers
+ *
+ *****************************************************************************
+ */
+
+#define	BRG_BCR				0x0000
+#define	BRG_BTR				0x0004
+
 #endif				/* __MPSC_H__ */
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/mpsc_defs.h linux-2.6.11-rc3/drivers/serial/mpsc_defs.h
--- linux-2.6.11-rc2-bk10/drivers/serial/mpsc_defs.h	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/mpsc_defs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,146 +0,0 @@
-/*
- * drivers/serial/mpsc_defs.h
- *
- * Register definitions for the Marvell Multi-Protocol Serial Controller (MPSC),
- * Serial DMA Controller (SDMA), and Baud Rate Generator (BRG).
- *
- * Author: Mark A. Greer <mgreer@mvista.com>
- *
- * 2004 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-#ifndef	__MPSC_DEFS_H__
-#define	__MPSC_DEFS_H__
-
-#define	MPSC_NUM_CTLRS		2
-
-/*
- *****************************************************************************
- *
- *	Multi-Protocol Serial Controller Interface Registers
- *
- *****************************************************************************
- */
-
-/* Main Configuratino Register Offsets */
-#define	MPSC_MMCRL			0x0000
-#define	MPSC_MMCRH			0x0004
-#define	MPSC_MPCR			0x0008
-#define	MPSC_CHR_1			0x000c
-#define	MPSC_CHR_2			0x0010
-#define	MPSC_CHR_3			0x0014
-#define	MPSC_CHR_4			0x0018
-#define	MPSC_CHR_5			0x001c
-#define	MPSC_CHR_6			0x0020
-#define	MPSC_CHR_7			0x0024
-#define	MPSC_CHR_8			0x0028
-#define	MPSC_CHR_9			0x002c
-#define	MPSC_CHR_10			0x0030
-#define	MPSC_CHR_11			0x0034
-
-#define	MPSC_MPCR_CL_5			0
-#define	MPSC_MPCR_CL_6			1
-#define	MPSC_MPCR_CL_7			2
-#define	MPSC_MPCR_CL_8			3
-#define	MPSC_MPCR_SBL_1			0
-#define	MPSC_MPCR_SBL_2			3
-
-#define	MPSC_CHR_2_TEV			(1<<1)
-#define	MPSC_CHR_2_TA			(1<<7)
-#define	MPSC_CHR_2_TTCS			(1<<9)
-#define	MPSC_CHR_2_REV			(1<<17)
-#define	MPSC_CHR_2_RA			(1<<23)
-#define	MPSC_CHR_2_CRD			(1<<25)
-#define	MPSC_CHR_2_EH			(1<<31)
-#define	MPSC_CHR_2_PAR_ODD		0
-#define	MPSC_CHR_2_PAR_SPACE		1
-#define	MPSC_CHR_2_PAR_EVEN		2
-#define	MPSC_CHR_2_PAR_MARK		3
-
-/* MPSC Signal Routing */
-#define	MPSC_MRR			0x0000
-#define	MPSC_RCRR			0x0004
-#define	MPSC_TCRR			0x0008
-
-/*
- *****************************************************************************
- *
- *	Serial DMA Controller Interface Registers
- *
- *****************************************************************************
- */
-
-#define	SDMA_SDC			0x0000
-#define	SDMA_SDCM			0x0008
-#define	SDMA_RX_DESC			0x0800
-#define	SDMA_RX_BUF_PTR			0x0808
-#define	SDMA_SCRDP			0x0810
-#define	SDMA_TX_DESC			0x0c00
-#define	SDMA_SCTDP			0x0c10
-#define	SDMA_SFTDP			0x0c14
-
-#define	SDMA_DESC_CMDSTAT_PE		(1<<0)
-#define	SDMA_DESC_CMDSTAT_CDL		(1<<1)
-#define	SDMA_DESC_CMDSTAT_FR		(1<<3)
-#define	SDMA_DESC_CMDSTAT_OR		(1<<6)
-#define	SDMA_DESC_CMDSTAT_BR		(1<<9)
-#define	SDMA_DESC_CMDSTAT_MI		(1<<10)
-#define	SDMA_DESC_CMDSTAT_A		(1<<11)
-#define	SDMA_DESC_CMDSTAT_AM		(1<<12)
-#define	SDMA_DESC_CMDSTAT_CT		(1<<13)
-#define	SDMA_DESC_CMDSTAT_C		(1<<14)
-#define	SDMA_DESC_CMDSTAT_ES		(1<<15)
-#define	SDMA_DESC_CMDSTAT_L		(1<<16)
-#define	SDMA_DESC_CMDSTAT_F		(1<<17)
-#define	SDMA_DESC_CMDSTAT_P		(1<<18)
-#define	SDMA_DESC_CMDSTAT_EI		(1<<23)
-#define	SDMA_DESC_CMDSTAT_O		(1<<31)
-
-#define SDMA_DESC_DFLT			(SDMA_DESC_CMDSTAT_O |	\
-					SDMA_DESC_CMDSTAT_EI)
-
-#define	SDMA_SDC_RFT			(1<<0)
-#define	SDMA_SDC_SFM			(1<<1)
-#define	SDMA_SDC_BLMR			(1<<6)
-#define	SDMA_SDC_BLMT			(1<<7)
-#define	SDMA_SDC_POVR			(1<<8)
-#define	SDMA_SDC_RIFB			(1<<9)
-
-#define	SDMA_SDCM_ERD			(1<<7)
-#define	SDMA_SDCM_AR			(1<<15)
-#define	SDMA_SDCM_STD			(1<<16)
-#define	SDMA_SDCM_TXD			(1<<23)
-#define	SDMA_SDCM_AT			(1<<31)
-
-#define	SDMA_0_CAUSE_RXBUF		(1<<0)
-#define	SDMA_0_CAUSE_RXERR		(1<<1)
-#define	SDMA_0_CAUSE_TXBUF		(1<<2)
-#define	SDMA_0_CAUSE_TXEND		(1<<3)
-#define	SDMA_1_CAUSE_RXBUF		(1<<8)
-#define	SDMA_1_CAUSE_RXERR		(1<<9)
-#define	SDMA_1_CAUSE_TXBUF		(1<<10)
-#define	SDMA_1_CAUSE_TXEND		(1<<11)
-
-#define	SDMA_CAUSE_RX_MASK	(SDMA_0_CAUSE_RXBUF | SDMA_0_CAUSE_RXERR | \
-	SDMA_1_CAUSE_RXBUF | SDMA_1_CAUSE_RXERR)
-#define	SDMA_CAUSE_TX_MASK	(SDMA_0_CAUSE_TXBUF | SDMA_0_CAUSE_TXEND | \
-	SDMA_1_CAUSE_TXBUF | SDMA_1_CAUSE_TXEND)
-
-/* SDMA Interrupt registers */
-#define	SDMA_INTR_CAUSE			0x0000
-#define	SDMA_INTR_MASK			0x0080
-
-/*
- *****************************************************************************
- *
- *	Baud Rate Generator Interface Registers
- *
- *****************************************************************************
- */
-
-#define	BRG_BCR				0x0000
-#define	BRG_BTR				0x0004
-
-#endif /*__MPSC_DEFS_H__ */
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/pmac_zilog.c linux-2.6.11-rc3/drivers/serial/pmac_zilog.c
--- linux-2.6.11-rc2-bk10/drivers/serial/pmac_zilog.c	2005-01-22 02:46:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/pmac_zilog.c	2005-02-03 02:54:56.000000000 +0100
@@ -1946,6 +1946,8 @@ static void pmz_console_write(struct con
 	unsigned long flags;
 	int i;
 
+	if (ZS_IS_ASLEEP(uap))
+		return;
 	spin_lock_irqsave(&uap->port.lock, flags);
 
 	/* Turn of interrupts and enable the transmitter. */
diff -purN linux-2.6.11-rc2-bk10/drivers/serial/serial_txx9.c linux-2.6.11-rc3/drivers/serial/serial_txx9.c
--- linux-2.6.11-rc2-bk10/drivers/serial/serial_txx9.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/serial/serial_txx9.c	2005-02-03 02:55:36.000000000 +0100
@@ -0,0 +1,1171 @@
+/*
+ *  drivers/serial/serial_txx9.c
+ *
+ * Derived from many drivers using generic_serial interface,
+ * especially serial_tx3912.c by Steven J. Hill and r39xx_serial.c
+ * (was in Linux/VR tree) by Jim Pick.
+ *
+ *  Copyright (C) 1999 Harald Koerfgen
+ *  Copyright (C) 2000 Jim Pick <jim@jimpick.com>
+ *  Copyright (C) 2001 Steven J. Hill (sjhill@realitydiluted.com)
+ *  Copyright (C) 2000-2002 Toshiba Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Serial driver for TX3927/TX4927/TX4925/TX4938 internal SIO controller
+ *
+ *  Revision History:
+ *	0.30	Initial revision. (Renamed from serial_txx927.c)
+ *	0.31	Use save_flags instead of local_irq_save.
+ *	0.32	Support SCLK.
+ *	0.33	Switch TXX9_TTY_NAME by CONFIG_SERIAL_TXX9_STDSERIAL.
+ *		Support TIOCSERGETLSR.
+ *	0.34	Support slow baudrate.
+ *	0.40	Merge codes from mainstream kernel (2.4.22).
+ *	0.41	Fix console checking in rs_shutdown_port().
+ *		Disable flow-control in serial_console_write().
+ *	0.42	Fix minor compiler warning.
+ *	1.00	Kernel 2.6.  Converted to new serial core (based on 8250.c).
+ *	1.01	Set fifosize to make tx_empry called properly.
+ *		Use standard uart_get_divisor.
+ *	1.02	Cleanup. (import 8250.c changes)
+ */
+#include <linux/config.h>
+
+#if defined(CONFIG_SERIAL_TXX9_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+static char *serial_version = "1.02";
+static char *serial_name = "TX39/49 Serial driver";
+
+#define PASS_LIMIT	256
+
+#if !defined(CONFIG_SERIAL_TXX9_STDSERIAL)
+/* "ttyS" is used for standard serial driver */
+#define TXX9_TTY_NAME "ttyTX"
+#define TXX9_TTY_DEVFS_NAME "tttx/"
+#define TXX9_TTY_MINOR_START	(64 + 64)	/* ttyTX0(128), ttyTX1(129) */
+#else
+/* acts like standard serial driver */
+#define TXX9_TTY_NAME "ttyS"
+#define TXX9_TTY_DEVFS_NAME "tts/"
+#define TXX9_TTY_MINOR_START	64
+#endif
+#define TXX9_TTY_MAJOR	TTY_MAJOR
+
+/* flag aliases */
+#define UPF_TXX9_HAVE_CTS_LINE	UPF_BUGGY_UART
+#define UPF_TXX9_USE_SCLK	UPF_MAGIC_MULTIPLIER
+
+#ifdef CONFIG_PCI
+/* support for Toshiba TC86C001 SIO */
+#define ENABLE_SERIAL_TXX9_PCI
+#endif
+
+/*
+ * Number of serial ports
+ */
+#ifdef ENABLE_SERIAL_TXX9_PCI
+#define NR_PCI_BOARDS	4
+#define UART_NR  (2 + NR_PCI_BOARDS)
+#else
+#define UART_NR  2
+#endif
+
+struct uart_txx9_port {
+	struct uart_port	port;
+
+	/*
+	 * We provide a per-port pm hook.
+	 */
+	void			(*pm)(struct uart_port *port,
+				      unsigned int state, unsigned int old);
+};
+
+#define TXX9_REGION_SIZE	0x24
+
+/* TXX9 Serial Registers */
+#define TXX9_SILCR	0x00
+#define TXX9_SIDICR	0x04
+#define TXX9_SIDISR	0x08
+#define TXX9_SICISR	0x0c
+#define TXX9_SIFCR	0x10
+#define TXX9_SIFLCR	0x14
+#define TXX9_SIBGR	0x18
+#define TXX9_SITFIFO	0x1c
+#define TXX9_SIRFIFO	0x20
+
+/* SILCR : Line Control */
+#define TXX9_SILCR_SCS_MASK	0x00000060
+#define TXX9_SILCR_SCS_IMCLK	0x00000000
+#define TXX9_SILCR_SCS_IMCLK_BG	0x00000020
+#define TXX9_SILCR_SCS_SCLK	0x00000040
+#define TXX9_SILCR_SCS_SCLK_BG	0x00000060
+#define TXX9_SILCR_UEPS	0x00000010
+#define TXX9_SILCR_UPEN	0x00000008
+#define TXX9_SILCR_USBL_MASK	0x00000004
+#define TXX9_SILCR_USBL_1BIT	0x00000000
+#define TXX9_SILCR_USBL_2BIT	0x00000004
+#define TXX9_SILCR_UMODE_MASK	0x00000003
+#define TXX9_SILCR_UMODE_8BIT	0x00000000
+#define TXX9_SILCR_UMODE_7BIT	0x00000001
+
+/* SIDICR : DMA/Int. Control */
+#define TXX9_SIDICR_TDE	0x00008000
+#define TXX9_SIDICR_RDE	0x00004000
+#define TXX9_SIDICR_TIE	0x00002000
+#define TXX9_SIDICR_RIE	0x00001000
+#define TXX9_SIDICR_SPIE	0x00000800
+#define TXX9_SIDICR_CTSAC	0x00000600
+#define TXX9_SIDICR_STIE_MASK	0x0000003f
+#define TXX9_SIDICR_STIE_OERS		0x00000020
+#define TXX9_SIDICR_STIE_CTSS		0x00000010
+#define TXX9_SIDICR_STIE_RBRKD	0x00000008
+#define TXX9_SIDICR_STIE_TRDY		0x00000004
+#define TXX9_SIDICR_STIE_TXALS	0x00000002
+#define TXX9_SIDICR_STIE_UBRKD	0x00000001
+
+/* SIDISR : DMA/Int. Status */
+#define TXX9_SIDISR_UBRK	0x00008000
+#define TXX9_SIDISR_UVALID	0x00004000
+#define TXX9_SIDISR_UFER	0x00002000
+#define TXX9_SIDISR_UPER	0x00001000
+#define TXX9_SIDISR_UOER	0x00000800
+#define TXX9_SIDISR_ERI	0x00000400
+#define TXX9_SIDISR_TOUT	0x00000200
+#define TXX9_SIDISR_TDIS	0x00000100
+#define TXX9_SIDISR_RDIS	0x00000080
+#define TXX9_SIDISR_STIS	0x00000040
+#define TXX9_SIDISR_RFDN_MASK	0x0000001f
+
+/* SICISR : Change Int. Status */
+#define TXX9_SICISR_OERS	0x00000020
+#define TXX9_SICISR_CTSS	0x00000010
+#define TXX9_SICISR_RBRKD	0x00000008
+#define TXX9_SICISR_TRDY	0x00000004
+#define TXX9_SICISR_TXALS	0x00000002
+#define TXX9_SICISR_UBRKD	0x00000001
+
+/* SIFCR : FIFO Control */
+#define TXX9_SIFCR_SWRST	0x00008000
+#define TXX9_SIFCR_RDIL_MASK	0x00000180
+#define TXX9_SIFCR_RDIL_1	0x00000000
+#define TXX9_SIFCR_RDIL_4	0x00000080
+#define TXX9_SIFCR_RDIL_8	0x00000100
+#define TXX9_SIFCR_RDIL_12	0x00000180
+#define TXX9_SIFCR_RDIL_MAX	0x00000180
+#define TXX9_SIFCR_TDIL_MASK	0x00000018
+#define TXX9_SIFCR_TDIL_MASK	0x00000018
+#define TXX9_SIFCR_TDIL_1	0x00000000
+#define TXX9_SIFCR_TDIL_4	0x00000001
+#define TXX9_SIFCR_TDIL_8	0x00000010
+#define TXX9_SIFCR_TDIL_MAX	0x00000010
+#define TXX9_SIFCR_TFRST	0x00000004
+#define TXX9_SIFCR_RFRST	0x00000002
+#define TXX9_SIFCR_FRSTE	0x00000001
+#define TXX9_SIO_TX_FIFO	8
+#define TXX9_SIO_RX_FIFO	16
+
+/* SIFLCR : Flow Control */
+#define TXX9_SIFLCR_RCS	0x00001000
+#define TXX9_SIFLCR_TES	0x00000800
+#define TXX9_SIFLCR_RTSSC	0x00000200
+#define TXX9_SIFLCR_RSDE	0x00000100
+#define TXX9_SIFLCR_TSDE	0x00000080
+#define TXX9_SIFLCR_RTSTL_MASK	0x0000001e
+#define TXX9_SIFLCR_RTSTL_MAX	0x0000001e
+#define TXX9_SIFLCR_TBRK	0x00000001
+
+/* SIBGR : Baudrate Control */
+#define TXX9_SIBGR_BCLK_MASK	0x00000300
+#define TXX9_SIBGR_BCLK_T0	0x00000000
+#define TXX9_SIBGR_BCLK_T2	0x00000100
+#define TXX9_SIBGR_BCLK_T4	0x00000200
+#define TXX9_SIBGR_BCLK_T6	0x00000300
+#define TXX9_SIBGR_BRD_MASK	0x000000ff
+
+static inline unsigned int sio_in(struct uart_txx9_port *up, int offset)
+{
+	switch (up->port.iotype) {
+	default:
+		return *(volatile u32 *)(up->port.membase + offset);
+	case UPIO_PORT:
+		return inl(up->port.iobase + offset);
+	}
+}
+
+static inline void
+sio_out(struct uart_txx9_port *up, int offset, int value)
+{
+	switch (up->port.iotype) {
+	default:
+		*(volatile u32 *)(up->port.membase + offset) = value;
+		break;
+	case UPIO_PORT:
+		outl(value, up->port.iobase + offset);
+		break;
+	}
+}
+
+static inline void
+sio_mask(struct uart_txx9_port *up, int offset, unsigned int value)
+{
+	sio_out(up, offset, sio_in(up, offset) & ~value);
+}
+static inline void
+sio_set(struct uart_txx9_port *up, int offset, unsigned int value)
+{
+	sio_out(up, offset, sio_in(up, offset) | value);
+}
+
+static inline void
+sio_quot_set(struct uart_txx9_port *up, int quot)
+{
+	quot >>= 1;
+	if (quot < 256)
+		sio_out(up, TXX9_SIBGR, quot | TXX9_SIBGR_BCLK_T0);
+	else if (quot < (256 << 2))
+		sio_out(up, TXX9_SIBGR, (quot >> 2) | TXX9_SIBGR_BCLK_T2);
+	else if (quot < (256 << 4))
+		sio_out(up, TXX9_SIBGR, (quot >> 4) | TXX9_SIBGR_BCLK_T4);
+	else if (quot < (256 << 6))
+		sio_out(up, TXX9_SIBGR, (quot >> 6) | TXX9_SIBGR_BCLK_T6);
+	else
+		sio_out(up, TXX9_SIBGR, 0xff | TXX9_SIBGR_BCLK_T6);
+}
+
+static void serial_txx9_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	sio_mask(up, TXX9_SIDICR, TXX9_SIDICR_TIE);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	sio_set(up, TXX9_SIDICR, TXX9_SIDICR_TIE);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_stop_rx(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	up->port.read_status_mask &= ~TXX9_SIDISR_RDIS;
+#if 0
+	sio_mask(up, TXX9_SIDICR, TXX9_SIDICR_RIE);
+#endif
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_enable_ms(struct uart_port *port)
+{
+	/* TXX9-SIO can not control DTR... */
+}
+
+static inline void
+receive_chars(struct uart_txx9_port *up, unsigned int *status, struct pt_regs *regs)
+{
+	struct tty_struct *tty = up->port.info->tty;
+	unsigned char ch;
+	unsigned int disr = *status;
+	int max_count = 256;
+	char flag;
+
+	do {
+		/* The following is not allowed by the tty layer and
+		   unsafe. It should be fixed ASAP */
+		if (unlikely(tty->flip.count >= TTY_FLIPBUF_SIZE)) {
+			if(tty->low_latency)
+				tty_flip_buffer_push(tty);
+			/* If this failed then we will throw away the
+			   bytes but must do so to clear interrupts */
+		}
+		ch = sio_in(up, TXX9_SIRFIFO);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(disr & (TXX9_SIDISR_UBRK | TXX9_SIDISR_UPER |
+				     TXX9_SIDISR_UFER | TXX9_SIDISR_UOER))) {
+			/*
+			 * For statistics only
+			 */
+			if (disr & TXX9_SIDISR_UBRK) {
+				disr &= ~(TXX9_SIDISR_UFER | TXX9_SIDISR_UPER);
+				up->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(&up->port))
+					goto ignore_char;
+			} else if (disr & TXX9_SIDISR_UPER)
+				up->port.icount.parity++;
+			else if (disr & TXX9_SIDISR_UFER)
+				up->port.icount.frame++;
+			if (disr & TXX9_SIDISR_UOER)
+				up->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ingored.
+			 */
+			disr &= up->port.read_status_mask;
+
+			if (disr & TXX9_SIDISR_UBRK) {
+				flag = TTY_BREAK;
+			} else if (disr & TXX9_SIDISR_UPER)
+				flag = TTY_PARITY;
+			else if (disr & TXX9_SIDISR_UFER)
+				flag = TTY_FRAME;
+		}
+		if (uart_handle_sysrq_char(&up->port, ch, regs))
+			goto ignore_char;
+		if ((disr & up->port.ignore_status_mask) == 0) {
+			tty_insert_flip_char(tty, ch, flag);
+		}
+		if ((disr & TXX9_SIDISR_UOER) &&
+		    tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character.
+			 */
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		}
+	ignore_char:
+		disr = sio_in(up, TXX9_SIDISR);
+	} while (!(disr & TXX9_SIDISR_UVALID) && (max_count-- > 0));
+	tty_flip_buffer_push(tty);
+	*status = disr;
+}
+
+static inline void transmit_chars(struct uart_txx9_port *up)
+{
+	struct circ_buf *xmit = &up->port.info->xmit;
+	int count;
+
+	if (up->port.x_char) {
+		sio_out(up, TXX9_SITFIFO, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
+		serial_txx9_stop_tx(&up->port, 0);
+		return;
+	}
+
+	count = TXX9_SIO_TX_FIFO;
+	do {
+		sio_out(up, TXX9_SITFIFO, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		serial_txx9_stop_tx(&up->port, 0);
+}
+
+static irqreturn_t serial_txx9_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int pass_counter = 0;
+	struct uart_txx9_port *up = dev_id;
+	unsigned int status;
+
+	while (1) {
+		spin_lock(&up->port.lock);
+		status = sio_in(up, TXX9_SIDISR);
+		if (!(sio_in(up, TXX9_SIDICR) & TXX9_SIDICR_TIE))
+			status &= ~TXX9_SIDISR_TDIS;
+		if (!(status & (TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |
+				TXX9_SIDISR_TOUT))) {
+			spin_unlock(&up->port.lock);
+			break;
+		}
+
+		if (status & TXX9_SIDISR_RDIS)
+			receive_chars(up, &status, regs);
+		if (status & TXX9_SIDISR_TDIS)
+			transmit_chars(up);
+		/* Clear TX/RX Int. Status */
+		sio_mask(up, TXX9_SIDISR,
+			 TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |
+			 TXX9_SIDISR_TOUT);
+		spin_unlock(&up->port.lock);
+
+		if (pass_counter++ > PASS_LIMIT)
+			break;
+	}
+
+	return pass_counter ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static unsigned int serial_txx9_tx_empty(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	ret = (sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS) ? TIOCSER_TEMT : 0;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return ret;
+}
+
+static unsigned int serial_txx9_get_mctrl(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	ret =  ((sio_in(up, TXX9_SIFLCR) & TXX9_SIFLCR_RTSSC) ? 0 : TIOCM_RTS)
+		| ((sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS) ? 0 : TIOCM_CTS);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return ret;
+}
+
+static void serial_txx9_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (mctrl & TIOCM_RTS)
+		sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);
+	else
+		sio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (break_state == -1)
+		sio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);
+	else
+		sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int serial_txx9_startup(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	int retval;
+
+	/*
+	 * Clear the FIFO buffers and disable them.
+	 * (they will be reeanbled in set_termios())
+	 */
+	sio_set(up, TXX9_SIFCR,
+		TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+	/* clear reset */
+	sio_mask(up, TXX9_SIFCR,
+		 TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+	sio_out(up, TXX9_SIDICR, 0);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	sio_out(up, TXX9_SIDISR, 0);
+
+	retval = request_irq(up->port.irq, serial_txx9_interrupt,
+			     SA_SHIRQ, "serial_txx9", up);
+	if (retval)
+		return retval;
+
+	/*
+	 * Now, initialize the UART
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+	serial_txx9_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/* Enable RX/TX */
+	sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);
+
+	/*
+	 * Finally, enable interrupts.
+	 */
+	sio_set(up, TXX9_SIDICR, TXX9_SIDICR_RIE);
+
+	return 0;
+}
+
+static void serial_txx9_shutdown(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	sio_out(up, TXX9_SIDICR, 0);	/* disable all intrs */
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	serial_txx9_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/*
+	 * Disable break condition
+	 */
+	sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);
+
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+	if (up->port.cons && up->port.line == up->port.cons->index) {
+		free_irq(up->port.irq, up);
+		return;
+	}
+#endif
+	/* reset FIFOs */
+	sio_set(up, TXX9_SIFCR,
+		TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+	/* clear reset */
+	sio_mask(up, TXX9_SIFCR,
+		 TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+
+	/* Disable RX/TX */
+	sio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);
+
+	free_irq(up->port.irq, up);
+}
+
+static void
+serial_txx9_set_termios(struct uart_port *port, struct termios *termios,
+		       struct termios *old)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned int cval, fcr = 0;
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	cval = sio_in(up, TXX9_SILCR);
+	/* byte size and parity */
+	cval &= ~TXX9_SILCR_UMODE_MASK;
+	switch (termios->c_cflag & CSIZE) {
+	case CS7:
+		cval |= TXX9_SILCR_UMODE_7BIT;
+		break;
+	default:
+	case CS5:	/* not supported */
+	case CS6:	/* not supported */
+	case CS8:
+		cval |= TXX9_SILCR_UMODE_8BIT;
+		break;
+	}
+
+	cval &= ~TXX9_SILCR_USBL_MASK;
+	if (termios->c_cflag & CSTOPB)
+		cval |= TXX9_SILCR_USBL_2BIT;
+	else
+		cval |= TXX9_SILCR_USBL_1BIT;
+	cval &= ~(TXX9_SILCR_UPEN | TXX9_SILCR_UEPS);
+	if (termios->c_cflag & PARENB)
+		cval |= TXX9_SILCR_UPEN;
+	if (!(termios->c_cflag & PARODD))
+		cval |= TXX9_SILCR_UEPS;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16/2);
+	quot = uart_get_divisor(port, baud);
+
+	/* Set up FIFOs */
+	/* TX Int by FIFO Empty, RX Int by Receiving 1 char. */
+	fcr = TXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1;
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	up->port.read_status_mask = TXX9_SIDISR_UOER |
+		TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= TXX9_SIDISR_UFER | TXX9_SIDISR_UPER;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= TXX9_SIDISR_UBRK;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= TXX9_SIDISR_UPER | TXX9_SIDISR_UFER;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= TXX9_SIDISR_UBRK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= TXX9_SIDISR_UOER;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= TXX9_SIDISR_RDIS;
+
+	/* CTS flow control flag */
+	if ((termios->c_cflag & CRTSCTS) &&
+	    (up->port.flags & UPF_TXX9_HAVE_CTS_LINE)) {
+		sio_set(up, TXX9_SIFLCR,
+			TXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);
+	} else {
+		sio_mask(up, TXX9_SIFLCR,
+			 TXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);
+	}
+
+	sio_out(up, TXX9_SILCR, cval);
+	sio_quot_set(up, quot);
+	sio_out(up, TXX9_SIFCR, fcr);
+
+	serial_txx9_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void
+serial_txx9_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	if (state) {
+		/* sleep */
+
+		if (up->pm)
+			up->pm(port, state, oldstate);
+	} else {
+		/* wake */
+
+		if (up->pm)
+			up->pm(port, state, oldstate);
+	}
+}
+
+static int serial_txx9_request_resource(struct uart_txx9_port *up)
+{
+	unsigned int size = TXX9_REGION_SIZE;
+	int ret = 0;
+
+	switch (up->port.iotype) {
+	default:
+		if (!up->port.mapbase)
+			break;
+
+		if (!request_mem_region(up->port.mapbase, size, "serial_txx9")) {
+			ret = -EBUSY;
+			break;
+		}
+
+		if (up->port.flags & UPF_IOREMAP) {
+			up->port.membase = ioremap(up->port.mapbase, size);
+			if (!up->port.membase) {
+				release_mem_region(up->port.mapbase, size);
+				ret = -ENOMEM;
+			}
+		}
+		break;
+
+	case UPIO_PORT:
+		if (!request_region(up->port.iobase, size, "serial_txx9"))
+			ret = -EBUSY;
+		break;
+	}
+	return ret;
+}
+
+static void serial_txx9_release_resource(struct uart_txx9_port *up)
+{
+	unsigned int size = TXX9_REGION_SIZE;
+
+	switch (up->port.iotype) {
+	default:
+		if (!up->port.mapbase)
+			break;
+
+		if (up->port.flags & UPF_IOREMAP) {
+			iounmap(up->port.membase);
+			up->port.membase = NULL;
+		}
+
+		release_mem_region(up->port.mapbase, size);
+		break;
+
+	case UPIO_PORT:
+		release_region(up->port.iobase, size);
+		break;
+	}
+}
+
+static void serial_txx9_release_port(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	serial_txx9_release_resource(up);
+}
+
+static int serial_txx9_request_port(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	return serial_txx9_request_resource(up);
+}
+
+static void serial_txx9_config_port(struct uart_port *port, int uflags)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	int ret;
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = serial_txx9_request_resource(up);
+	if (ret < 0)
+		return;
+	port->type = PORT_TXX9;
+	up->port.fifosize = TXX9_SIO_TX_FIFO;
+
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+	if (up->port.line == up->port.cons->index)
+		return;
+#endif
+	spin_lock_irqsave(&up->port.lock, flags);
+	/*
+	 * Reset the UART.
+	 */
+	sio_out(up, TXX9_SIFCR, TXX9_SIFCR_SWRST);
+#ifdef CONFIG_CPU_TX49XX
+	/* TX4925 BUG WORKAROUND.  Accessing SIOC register
+	 * immediately after soft reset causes bus error. */
+	iob();
+	udelay(1);
+#endif
+	while (sio_in(up, TXX9_SIFCR) & TXX9_SIFCR_SWRST)
+		;
+	/* TX Int by FIFO Empty, RX Int by Receiving 1 char. */
+	sio_set(up, TXX9_SIFCR,
+		TXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1);
+	/* initial settings */
+	sio_out(up, TXX9_SILCR,
+		TXX9_SILCR_UMODE_8BIT | TXX9_SILCR_USBL_1BIT |
+		((up->port.flags & UPF_TXX9_USE_SCLK) ?
+		 TXX9_SILCR_SCS_SCLK_BG : TXX9_SILCR_SCS_IMCLK_BG));
+	sio_quot_set(up, uart_get_divisor(port, 9600));
+	sio_out(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSTL_MAX /* 15 */);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int
+serial_txx9_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->irq < 0 ||
+	    ser->baud_base < 9600 || ser->type != PORT_TXX9)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *
+serial_txx9_type(struct uart_port *port)
+{
+	return "txx9";
+}
+
+static struct uart_ops serial_txx9_pops = {
+	.tx_empty	= serial_txx9_tx_empty,
+	.set_mctrl	= serial_txx9_set_mctrl,
+	.get_mctrl	= serial_txx9_get_mctrl,
+	.stop_tx	= serial_txx9_stop_tx,
+	.start_tx	= serial_txx9_start_tx,
+	.stop_rx	= serial_txx9_stop_rx,
+	.enable_ms	= serial_txx9_enable_ms,
+	.break_ctl	= serial_txx9_break_ctl,
+	.startup	= serial_txx9_startup,
+	.shutdown	= serial_txx9_shutdown,
+	.set_termios	= serial_txx9_set_termios,
+	.pm		= serial_txx9_pm,
+	.type		= serial_txx9_type,
+	.release_port	= serial_txx9_release_port,
+	.request_port	= serial_txx9_request_port,
+	.config_port	= serial_txx9_config_port,
+	.verify_port	= serial_txx9_verify_port,
+};
+
+static struct uart_txx9_port serial_txx9_ports[UART_NR];
+
+static void __init serial_txx9_register_ports(struct uart_driver *drv)
+{
+	int i;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_txx9_port *up = &serial_txx9_ports[i];
+
+		up->port.line = i;
+		up->port.ops = &serial_txx9_pops;
+		uart_add_one_port(drv, &up->port);
+	}
+}
+
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+
+/*
+ *	Wait for transmitter & holding register to empty
+ */
+static inline void wait_for_xmitr(struct uart_txx9_port *up)
+{
+	unsigned int tmout = 10000;
+
+	/* Wait up to 10ms for the character(s) to be sent. */
+	while (--tmout &&
+	       !(sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS))
+		udelay(1);
+
+	/* Wait up to 1s for flow control if necessary */
+	if (up->port.flags & UPF_CONS_FLOW) {
+		tmout = 1000000;
+		while (--tmout &&
+		       (sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS))
+			udelay(1);
+	}
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void
+serial_txx9_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_txx9_port *up = &serial_txx9_ports[co->index];
+	unsigned int ier, flcr;
+	int i;
+
+	/*
+	 *	First save the UER then disable the interrupts
+	 */
+	ier = sio_in(up, TXX9_SIDICR);
+	sio_out(up, TXX9_SIDICR, 0);
+	/*
+	 *	Disable flow-control if enabled (and unnecessary)
+	 */
+	flcr = sio_in(up, TXX9_SIFLCR);
+	if (!(up->port.flags & UPF_CONS_FLOW) && (flcr & TXX9_SIFLCR_TES))
+		sio_out(up, TXX9_SIFLCR, flcr & ~TXX9_SIFLCR_TES);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++, s++) {
+		wait_for_xmitr(up);
+
+		/*
+		 *	Send the character out.
+		 *	If a LF, also do CR...
+		 */
+		sio_out(up, TXX9_SITFIFO, *s);
+		if (*s == 10) {
+			wait_for_xmitr(up);
+			sio_out(up, TXX9_SITFIFO, 13);
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(up);
+	sio_out(up, TXX9_SIFLCR, flcr);
+	sio_out(up, TXX9_SIDICR, ier);
+}
+
+static int serial_txx9_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	struct uart_txx9_port *up;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	up = &serial_txx9_ports[co->index];
+	port = &up->port;
+	if (!port->ops)
+		return -ENODEV;
+
+	/*
+	 * Temporary fix.
+	 */
+	spin_lock_init(&port->lock);
+
+	/*
+	 *	Disable UART interrupts, set DTR and RTS high
+	 *	and set speed.
+	 */
+	sio_out(up, TXX9_SIDICR, 0);
+	/* initial settings */
+	sio_out(up, TXX9_SILCR,
+		TXX9_SILCR_UMODE_8BIT | TXX9_SILCR_USBL_1BIT |
+		((port->flags & UPF_TXX9_USE_SCLK) ?
+		 TXX9_SILCR_SCS_SCLK_BG : TXX9_SILCR_SCS_IMCLK_BG));
+	sio_out(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSTL_MAX /* 15 */);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver serial_txx9_reg;
+static struct console serial_txx9_console = {
+	.name		= TXX9_TTY_NAME,
+	.write		= serial_txx9_console_write,
+	.device		= uart_console_device,
+	.setup		= serial_txx9_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &serial_txx9_reg,
+};
+
+static int __init serial_txx9_console_init(void)
+{
+	register_console(&serial_txx9_console);
+	return 0;
+}
+console_initcall(serial_txx9_console_init);
+
+static int __init serial_txx9_late_console_init(void)
+{
+	if (!(serial_txx9_console.flags & CON_ENABLED))
+		register_console(&serial_txx9_console);
+	return 0;
+}
+late_initcall(serial_txx9_late_console_init);
+
+#define SERIAL_TXX9_CONSOLE	&serial_txx9_console
+#else
+#define SERIAL_TXX9_CONSOLE	NULL
+#endif
+
+static struct uart_driver serial_txx9_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "serial_txx9",
+	.devfs_name		= TXX9_TTY_DEVFS_NAME,
+	.dev_name		= TXX9_TTY_NAME,
+	.major			= TXX9_TTY_MAJOR,
+	.minor			= TXX9_TTY_MINOR_START,
+	.nr			= UART_NR,
+	.cons			= SERIAL_TXX9_CONSOLE,
+};
+
+int __init early_serial_txx9_setup(struct uart_port *port)
+{
+	if (port->line >= ARRAY_SIZE(serial_txx9_ports))
+		return -ENODEV;
+
+	serial_txx9_ports[port->line].port = *port;
+	serial_txx9_ports[port->line].port.ops = &serial_txx9_pops;
+	serial_txx9_ports[port->line].port.flags |= UPF_BOOT_AUTOCONF;
+	return 0;
+}
+
+#ifdef ENABLE_SERIAL_TXX9_PCI
+/**
+ *	serial_txx9_suspend_port - suspend one serial port
+ *	@line:  serial line number
+ *      @level: the level of port suspension, as per uart_suspend_port
+ *
+ *	Suspend one serial port.
+ */
+static void serial_txx9_suspend_port(int line)
+{
+	uart_suspend_port(&serial_txx9_reg, &serial_txx9_ports[line].port);
+}
+
+/**
+ *	serial_txx9_resume_port - resume one serial port
+ *	@line:  serial line number
+ *      @level: the level of port resumption, as per uart_resume_port
+ *
+ *	Resume one serial port.
+ */
+static void serial_txx9_resume_port(int line)
+{
+	uart_resume_port(&serial_txx9_reg, &serial_txx9_ports[line].port);
+}
+
+/*
+ * Probe one serial board.  Unfortunately, there is no rhyme nor reason
+ * to the arrangement of serial ports on a PCI card.
+ */
+static int __devinit
+pciserial_txx9_init_one(struct pci_dev *dev, const struct pci_device_id *ent)
+{
+	struct uart_port port;
+	int line;
+	int rc;
+
+	rc = pci_enable_device(dev);
+	if (rc)
+		return rc;
+
+	memset(&port, 0, sizeof(port));
+	port.ops = &serial_txx9_pops;
+	port.flags |= UPF_BOOT_AUTOCONF; /* uart_ops.config_port will be called */
+	port.flags |= UPF_TXX9_HAVE_CTS_LINE;
+	port.uartclk = 66670000;
+	port.irq = dev->irq;
+	port.iotype = UPIO_PORT;
+	port.iobase = pci_resource_start(dev, 1);
+	line = uart_register_port(&serial_txx9_reg, &port);
+	if (line < 0) {
+		printk(KERN_WARNING "Couldn't register serial port %s: %d\n", pci_name(dev), line);
+	}
+	pci_set_drvdata(dev, (void *)(long)line);
+
+	return 0;
+}
+
+static void __devexit pciserial_txx9_remove_one(struct pci_dev *dev)
+{
+	int line = (int)(long)pci_get_drvdata(dev);
+
+	pci_set_drvdata(dev, NULL);
+
+	if (line) {
+		uart_unregister_port(&serial_txx9_reg, line);
+		pci_disable_device(dev);
+	}
+}
+
+static int pciserial_txx9_suspend_one(struct pci_dev *dev, u32 state)
+{
+	int line = (int)(long)pci_get_drvdata(dev);
+
+	if (line)
+		serial_txx9_suspend_port(line);
+	return 0;
+}
+
+static int pciserial_txx9_resume_one(struct pci_dev *dev)
+{
+	int line = (int)(long)pci_get_drvdata(dev);
+
+	if (line)
+		serial_txx9_resume_port(line);
+	return 0;
+}
+
+static struct pci_device_id serial_txx9_pci_tbl[] = {
+	{	PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 0 },
+	{ 0, }
+};
+
+static struct pci_driver serial_txx9_pci_driver = {
+	.name		= "serial_txx9",
+	.probe		= pciserial_txx9_init_one,
+	.remove		= __devexit_p(pciserial_txx9_remove_one),
+	.suspend	= pciserial_txx9_suspend_one,
+	.resume		= pciserial_txx9_resume_one,
+	.id_table	= serial_txx9_pci_tbl,
+};
+
+MODULE_DEVICE_TABLE(pci, serial_txx9_pci_tbl);
+#endif /* ENABLE_SERIAL_TXX9_PCI */
+
+static int __init serial_txx9_init(void)
+{
+	int ret;
+
+ 	printk(KERN_INFO "%s version %s\n", serial_name, serial_version);
+
+	ret = uart_register_driver(&serial_txx9_reg);
+	if (ret >= 0) {
+		serial_txx9_register_ports(&serial_txx9_reg);
+
+#ifdef ENABLE_SERIAL_TXX9_PCI
+		ret = pci_module_init(&serial_txx9_pci_driver);
+#endif
+	}
+	return ret;
+}
+
+static void __exit serial_txx9_exit(void)
+{
+	int i;
+
+#ifdef ENABLE_SERIAL_TXX9_PCI
+	pci_unregister_driver(&serial_txx9_pci_driver);
+#endif
+	for (i = 0; i < UART_NR; i++)
+		uart_remove_one_port(&serial_txx9_reg, &serial_txx9_ports[i].port);
+
+	uart_unregister_driver(&serial_txx9_reg);
+}
+
+module_init(serial_txx9_init);
+module_exit(serial_txx9_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("TX39/49 serial driver");
+
+MODULE_ALIAS_CHARDEV_MAJOR(TXX9_TTY_MAJOR);
diff -purN linux-2.6.11-rc2-bk10/drivers/tc/lk201.c linux-2.6.11-rc3/drivers/tc/lk201.c
--- linux-2.6.11-rc2-bk10/drivers/tc/lk201.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/drivers/tc/lk201.c	2005-02-03 02:57:04.000000000 +0100
@@ -4,20 +4,44 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
+ * Copyright (C) 1999-2002 Harald Koerfgen <hkoerfg@web.de>
+ * Copyright (C) 2001, 2002, 2003, 2004  Maciej W. Rozycki
  */
+
+#include <linux/config.h>
+
 #include <linux/errno.h>
+#include <linux/sched.h>
 #include <linux/tty.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/kbd_ll.h>
-#include <asm/wbflush.h>
+#include <linux/kbd_kern.h>
+#include <linux/vt_kern.h>
+
+#include <asm/keyboard.h>
 #include <asm/dec/tc.h>
 #include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
 
-#include "zs.h"
 #include "lk201.h"
 
+/*
+ * Only handle DECstations that have an LK201 interface.
+ * Maxine uses LK501 at the Access.Bus and various DECsystems
+ * have no keyboard interface at all.
+ */
+#define LK_IFACE	(mips_machtype == MACH_DS23100    || \
+			 mips_machtype == MACH_DS5000_200 || \
+			 mips_machtype == MACH_DS5000_1XX || \
+			 mips_machtype == MACH_DS5000_2X0)
+/*
+ * These use the Z8530 SCC.  Others use the DZ11.
+ */
+#define LK_IFACE_ZS	(mips_machtype == MACH_DS5000_1XX || \
+			 mips_machtype == MACH_DS5000_2X0)
+
 /* Simple translation table for the SysRq keys */
 
 #ifdef CONFIG_MAGIC_SYSRQ
@@ -27,25 +51,29 @@
  */
 unsigned char lk201_sysrq_xlate[128];
 unsigned char *kbd_sysrq_xlate = lk201_sysrq_xlate;
+
+unsigned char kbd_sysrq_key = -1;
 #endif
 
 #define KEYB_LINE	3
 
-static int __init lk201_init(struct dec_serial *);
-static void __init lk201_info(struct dec_serial *);
-static void lk201_kbd_rx_char(unsigned char, unsigned char);
-
-struct zs_hook lk201_kbdhook = {
-	.init_channel   = lk201_init,
-	.init_info      = lk201_info,
-	.cflags         = B4800 | CS8 | CSTOPB | CLOCAL
+static int __init lk201_init(void *);
+static void __init lk201_info(void *);
+static void lk201_rx_char(unsigned char, unsigned char);
+
+static struct dec_serial_hook lk201_hook = {
+	.init_channel	= lk201_init,
+	.init_info	= lk201_info,
+	.rx_char	= NULL,
+	.poll_rx_char	= NULL,
+	.poll_tx_char	= NULL,
+	.cflags		= B4800 | CS8 | CSTOPB | CLOCAL,
 };
 
 /*
  * This is used during keyboard initialisation
  */
 static unsigned char lk201_reset_string[] = {
-	LK_CMD_LEDS_ON, LK_PARAM_LED_MASK(0xf),	/* show we are resetting */
 	LK_CMD_SET_DEFAULTS,
 	LK_CMD_MODE(LK_MODE_RPT_DOWN, 1),
 	LK_CMD_MODE(LK_MODE_RPT_DOWN, 2),
@@ -61,28 +89,199 @@ static unsigned char lk201_reset_string[
 	LK_CMD_MODE(LK_MODE_RPT_DOWN, 12),
 	LK_CMD_MODE(LK_MODE_DOWN, 13),
 	LK_CMD_MODE(LK_MODE_RPT_DOWN, 14),
-	LK_CMD_ENB_RPT,
 	LK_CMD_DIS_KEYCLK,
-	LK_CMD_RESUME,
 	LK_CMD_ENB_BELL, LK_PARAM_VOLUME(4),
-	LK_CMD_LEDS_OFF, LK_PARAM_LED_MASK(0xf)
 };
 
-static int __init lk201_reset(struct dec_serial *info)
+static void *lk201_handle;
+
+static int lk201_send(unsigned char ch)
+{
+	if (lk201_hook.poll_tx_char(lk201_handle, ch)) {
+		printk(KERN_ERR "lk201: transmit timeout\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static inline int lk201_get_id(void)
+{
+	return lk201_send(LK_CMD_REQ_ID);
+}
+
+static int lk201_reset(void)
+{
+	int i, r;
+
+	for (i = 0; i < sizeof(lk201_reset_string); i++) {
+		r = lk201_send(lk201_reset_string[i]);
+		if (r < 0)
+			return r;
+	}
+	return 0;
+}
+
+static void lk201_report(unsigned char id[6])
+{
+	char *report = "lk201: keyboard attached, ";
+
+	switch (id[2]) {
+	case LK_STAT_PWRUP_OK:
+		printk(KERN_INFO "%sself-test OK\n", report);
+		break;
+	case LK_STAT_PWRUP_KDOWN:
+		/* The keyboard will resend the power-up ID
+		   after all keys are released, so we don't
+		   bother handling the error specially.  Still
+		   there may be a short-circuit inside.
+		 */
+		printk(KERN_ERR "%skey down (stuck?), code: 0x%02x\n",
+		       report, id[3]);
+		break;
+	case LK_STAT_PWRUP_ERROR:
+		printk(KERN_ERR "%sself-test failure\n", report);
+		break;
+	default:
+		printk(KERN_ERR "%sunknown error: 0x%02x\n",
+		       report, id[2]);
+	}
+}
+
+static void lk201_id(unsigned char id[6])
+{
+	/*
+	 * Report whether there is an LK201 or an LK401
+	 * The LK401 has ALT keys...
+	 */
+	switch (id[4]) {
+	case 1:
+		printk(KERN_INFO "lk201: LK201 detected\n");
+		break;
+	case 2:
+		printk(KERN_INFO "lk201: LK401 detected\n");
+		break;
+	case 3:
+		printk(KERN_INFO "lk201: LK443 detected\n");
+		break;
+	case 4:
+		printk(KERN_INFO "lk201: LK421 detected\n");
+		break;
+	default:
+		printk(KERN_WARNING
+		       "lk201: unknown keyboard detected, ID %d\n", id[4]);
+		printk(KERN_WARNING "lk201: ... please report to "
+		       "<linux-mips@linux-mips.org>\n");
+	}
+}
+
+#define DEFAULT_KEYB_REP_DELAY	(250/5)	/* [5ms] */
+#define DEFAULT_KEYB_REP_RATE	30	/* [cps] */
+
+static struct kbd_repeat kbdrate = {
+	DEFAULT_KEYB_REP_DELAY,
+	DEFAULT_KEYB_REP_RATE
+};
+
+static void parse_kbd_rate(struct kbd_repeat *r)
 {
+	if (r->delay <= 0)
+		r->delay = kbdrate.delay;
+	if (r->rate <= 0)
+		r->rate = kbdrate.rate;
+
+	if (r->delay < 5)
+		r->delay = 5;
+	if (r->delay > 630)
+		r->delay = 630;
+	if (r->rate < 12)
+		r->rate = 12;
+	if (r->rate > 127)
+		r->rate = 127;
+	if (r->rate == 125)
+		r->rate = 124;
+}
+
+static int write_kbd_rate(struct kbd_repeat *rep)
+{
+	int delay, rate;
 	int i;
 
-	for (i = 0; i < sizeof(lk201_reset_string); i++)
-		if (info->hook->poll_tx_char(info, lk201_reset_string[i])) {
-			printk("%s transmit timeout\n", __FUNCTION__);
-			return -EIO;
-		}
+	delay = rep->delay / 5;
+	rate = rep->rate;
+	for (i = 0; i < 4; i++) {
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_CMD_RPT_RATE(i)))
+			return 1;
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_PARAM_DELAY(delay)))
+			return 1;
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_PARAM_RATE(rate)))
+			return 1;
+	}
 	return 0;
 }
 
+static int lk201_kbd_rate(struct kbd_repeat *rep)
+{
+	if (rep == NULL)
+		return -EINVAL;
+
+	parse_kbd_rate(rep);
+
+	if (write_kbd_rate(rep)) {
+		memcpy(rep, &kbdrate, sizeof(struct kbd_repeat));
+		return -EIO;
+	}
+
+	memcpy(&kbdrate, rep, sizeof(struct kbd_repeat));
+
+	return 0;
+}
+
+static void lk201_kd_mksound(unsigned int hz, unsigned int ticks)
+{
+	if (!ticks)
+		return;
+
+	/*
+	 * Can't set frequency and we "approximate"
+	 * duration by volume. ;-)
+	 */
+	ticks /= HZ / 32;
+	if (ticks > 7)
+		ticks = 7;
+	ticks = 7 - ticks;
+
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_ENB_BELL))
+		return;
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_VOLUME(ticks)))
+		return;
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_BELL))
+		return;
+}
+
 void kbd_leds(unsigned char leds)
 {
-	return;
+	unsigned char l = 0;
+
+	if (!lk201_handle)		/* FIXME */
+		return;
+
+	/* FIXME -- Only Hold and Lock LEDs for now. --macro */
+	if (leds & LED_SCR)
+		l |= LK_LED_HOLD;
+	if (leds & LED_CAP)
+		l |= LK_LED_LOCK;
+
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_LEDS_ON))
+		return;
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_LED_MASK(l)))
+		return;
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_LEDS_OFF))
+		return;
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_LED_MASK(~l)))
+		return;
 }
 
 int kbd_setkeycode(unsigned int scancode, unsigned int keycode)
@@ -107,128 +306,136 @@ char kbd_unexpected_up(unsigned char key
 	return 0x80;
 }
 
-static void lk201_kbd_rx_char(unsigned char ch, unsigned char stat)
+static void lk201_rx_char(unsigned char ch, unsigned char fl)
 {
+	static unsigned char id[6];
+	static int id_i;
+
 	static int shift_state = 0;
 	static int prev_scancode;
 	unsigned char c = scancodeRemap[ch];
 
-	if (!stat || stat == 4) {
-		switch (ch) {
-		case LK_KEY_ACK:
-			break;
-		case LK_KEY_LOCK:
-			shift_state ^= LK_LOCK;
-			handle_scancode(c, shift_state && LK_LOCK ? 1 : 0);
-			break;
-		case LK_KEY_SHIFT:
-			shift_state ^= LK_SHIFT;
-			handle_scancode(c, shift_state && LK_SHIFT ? 1 : 0);
-			break;
-		case LK_KEY_CTRL:
-			shift_state ^= LK_CTRL;
-			handle_scancode(c, shift_state && LK_CTRL ? 1 : 0);
-			break;
-		case LK_KEY_COMP:
-			shift_state ^= LK_COMP;
-			handle_scancode(c, shift_state && LK_COMP ? 1 : 0);
-			break;
-		case LK_KEY_RELEASE:
-			if (shift_state & LK_SHIFT)
-				handle_scancode(scancodeRemap[LK_KEY_SHIFT], 0);
-			if (shift_state & LK_CTRL)
-				handle_scancode(scancodeRemap[LK_KEY_CTRL], 0);
-			if (shift_state & LK_COMP)
-				handle_scancode(scancodeRemap[LK_KEY_COMP], 0);
-			if (shift_state & LK_LOCK)
-				handle_scancode(scancodeRemap[LK_KEY_LOCK], 0);
-			shift_state = 0;
-			break;
-		case LK_KEY_REPEAT:
-			handle_scancode(prev_scancode, 1);
-			break;
-		default:
-			prev_scancode = c;
-			handle_scancode(c, 1);
-			break;
+	if (fl != TTY_NORMAL && fl != TTY_OVERRUN) {
+		printk(KERN_ERR "lk201: keyboard receive error: 0x%02x\n", fl);
+		return;
+	}
+
+	/* Assume this is a power-up ID. */
+	if (ch == LK_STAT_PWRUP_ID && !id_i) {
+		id[id_i++] = ch;
+		return;
+	}
+
+	/* Handle the power-up sequence. */
+	if (id_i) {
+		id[id_i++] = ch;
+		if (id_i == 4) {
+			/* OK, the power-up concluded. */
+			lk201_report(id);
+			if (id[2] == LK_STAT_PWRUP_OK)
+				lk201_get_id();
+			else {
+				id_i = 0;
+				printk(KERN_ERR "lk201: keyboard power-up "
+				       "error, skipping initialization\n");
+			}
+		} else if (id_i == 6) {
+			/* We got the ID; report it and start operation. */
+			id_i = 0;
+			lk201_id(id);
+			lk201_reset();
 		}
-	} else
-		printk("Error reading LKx01 keyboard: 0x%02x\n", stat);
+		return;
+	}
+
+	/* Everything else is a scancode/status response. */
+	id_i = 0;
+	switch (ch) {
+	case LK_STAT_RESUME_ERR:
+	case LK_STAT_ERROR:
+	case LK_STAT_INHIBIT_ACK:
+	case LK_STAT_TEST_ACK:
+	case LK_STAT_MODE_KEYDOWN:
+	case LK_STAT_MODE_ACK:
+		break;
+	case LK_KEY_LOCK:
+		shift_state ^= LK_LOCK;
+		handle_scancode(c, (shift_state & LK_LOCK) ? 1 : 0);
+		break;
+	case LK_KEY_SHIFT:
+		shift_state ^= LK_SHIFT;
+		handle_scancode(c, (shift_state & LK_SHIFT) ? 1 : 0);
+		break;
+	case LK_KEY_CTRL:
+		shift_state ^= LK_CTRL;
+		handle_scancode(c, (shift_state & LK_CTRL) ? 1 : 0);
+		break;
+	case LK_KEY_COMP:
+		shift_state ^= LK_COMP;
+		handle_scancode(c, (shift_state & LK_COMP) ? 1 : 0);
+		break;
+	case LK_KEY_RELEASE:
+		if (shift_state & LK_SHIFT)
+			handle_scancode(scancodeRemap[LK_KEY_SHIFT], 0);
+		if (shift_state & LK_CTRL)
+			handle_scancode(scancodeRemap[LK_KEY_CTRL], 0);
+		if (shift_state & LK_COMP)
+			handle_scancode(scancodeRemap[LK_KEY_COMP], 0);
+		if (shift_state & LK_LOCK)
+			handle_scancode(scancodeRemap[LK_KEY_LOCK], 0);
+		shift_state = 0;
+		break;
+	case LK_KEY_REPEAT:
+		handle_scancode(prev_scancode, 1);
+		break;
+	default:
+		prev_scancode = c;
+		handle_scancode(c, 1);
+		break;
+	}
+	tasklet_schedule(&keyboard_tasklet);
 }
 
-static void __init lk201_info(struct dec_serial *info)
+static void __init lk201_info(void *handle)
 {
 }
 
-static int __init lk201_init(struct dec_serial *info)
+static int __init lk201_init(void *handle)
 {
-	unsigned int ch, id = 0;
-	int result;
-
-	printk("DECstation LK keyboard driver v0.04... ");
+	/* First install handlers. */
+	lk201_handle = handle;
+	kbd_rate = lk201_kbd_rate;
+	kd_mksound = lk201_kd_mksound;
 
-	result = lk201_reset(info);
-	if (result)
-		return result;
-	mdelay(10);
-
-	/*
-	 * Detect whether there is an LK201 or an LK401
-	 * The LK401 has ALT keys...
-	 */
-	info->hook->poll_tx_char(info, LK_CMD_REQ_ID);
-	while ((ch = info->hook->poll_rx_char(info)) > 0)
-		id = ch;
-
-	switch (id) {
-	case 1:
-		printk("LK201 detected\n");
-		break;
-	case 2:
-		printk("LK401 detected\n");
-		break;
-	default:
-		printk("unknown keyboard, ID %d,\n", id);
-		printk("... please report to <linux-mips@oss.sgi.com>\n");
-	}
+	lk201_hook.rx_char = lk201_rx_char;
 
-	/*
-	 * now we're ready
-	 */
-	info->hook->rx_char = lk201_kbd_rx_char;
+	/* Then just issue a reset -- the handlers will do the rest. */
+	lk201_send(LK_CMD_POWER_UP);
 
 	return 0;
 }
 
 void __init kbd_init_hw(void)
 {
-	extern int register_zs_hook(unsigned int, struct zs_hook *);
-	extern int unregister_zs_hook(unsigned int);
+	/* Maxine uses LK501 at the Access.Bus. */
+	if (!LK_IFACE)
+		return;
 
-	if (TURBOCHANNEL) {
-		if (mips_machtype != MACH_DS5000_XX) {
-			/*
-			 * This is not a MAXINE, so:
-			 *
-			 * kbd_init_hw() is being called before
-			 * rs_init() so just register the kbd hook
-			 * and let zs_init do the rest :-)
-			 */
-			if (mips_machtype == MACH_DS5000_200)
-				printk("LK201 Support for DS5000/200 not yet ready ...\n");
-			else
-				if(!register_zs_hook(KEYB_LINE, &lk201_kbdhook))
-					unregister_zs_hook(KEYB_LINE);
-		}
+	printk(KERN_INFO "lk201: DECstation LK keyboard driver v0.05.\n");
+
+	if (LK_IFACE_ZS) {
+		/*
+		 * kbd_init_hw() is being called before
+		 * rs_init() so just register the kbd hook
+		 * and let zs_init do the rest :-)
+		 */
+		if (!register_dec_serial_hook(KEYB_LINE, &lk201_hook))
+			unregister_dec_serial_hook(KEYB_LINE);
 	} else {
 		/*
 		 * TODO: modify dz.c to allow similar hooks
 		 * for LK201 handling on DS2100, DS3100, and DS5000/200
 		 */
-		printk("LK201 Support for DS3100 not yet ready ...\n");
+		printk(KERN_ERR "lk201: support for DZ11 not yet ready.\n");
 	}
 }
-
-
-
-
diff -purN linux-2.6.11-rc2-bk10/drivers/tc/lk201.h linux-2.6.11-rc3/drivers/tc/lk201.h
--- linux-2.6.11-rc2-bk10/drivers/tc/lk201.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/tc/lk201.h	2005-02-03 02:55:51.000000000 +0100
@@ -2,52 +2,124 @@
  *	Commands to the keyboard processor
  */
 
-#define	LK_PARAM		0x80	/* start/end parameter list */
+#define LK_PARAM		0x80	/* start/end parameter list */
 
-#define	LK_CMD_RESUME		0x8b
-#define	LK_CMD_INHIBIT		0xb9
-#define	LK_CMD_LEDS_ON		0x13	/* 1 param: led bitmask */
-#define	LK_CMD_LEDS_OFF		0x11	/* 1 param: led bitmask */
-#define	LK_CMD_DIS_KEYCLK	0x99
-#define	LK_CMD_ENB_KEYCLK	0x1b	/* 1 param: volume */
-#define	LK_CMD_DIS_CTLCLK	0xb9
-#define	LK_CMD_ENB_CTLCLK	0xbb
-#define	LK_CMD_SOUND_CLK	0x9f
-#define	LK_CMD_DIS_BELL		0xa1
-#define	LK_CMD_ENB_BELL		0x23	/* 1 param: volume */
-#define	LK_CMD_BELL		0xa7
-#define	LK_CMD_TMP_NORPT	0xc1
-#define	LK_CMD_ENB_RPT		0xe3
-#define	LK_CMD_DIS_RPT		0xe1
-#define	LK_CMD_RPT_TO_DOWN	0xd9
-#define	LK_CMD_REQ_ID		0xab
-#define	LK_CMD_POWER_UP		0xfd
-#define	LK_CMD_TEST_MODE	0xcb
-#define	LK_CMD_SET_DEFAULTS	0xd3
+#define LK_CMD_RESUME		0x8b	/* resume transmission to the host */
+#define LK_CMD_INHIBIT		0x89	/* stop transmission to the host */
+#define LK_CMD_LEDS_ON		0x13	/* light LEDs */
+					/* 1st param: led bitmask */
+#define LK_CMD_LEDS_OFF		0x11	/* turn off LEDs */
+					/* 1st param: led bitmask */
+#define LK_CMD_DIS_KEYCLK	0x99	/* disable the keyclick */
+#define LK_CMD_ENB_KEYCLK	0x1b	/* enable the keyclick */
+					/* 1st param: volume */
+#define LK_CMD_DIS_CTLCLK	0xb9	/* disable the Ctrl keyclick */
+#define LK_CMD_ENB_CTLCLK	0xbb	/* enable the Ctrl keyclick */
+#define LK_CMD_SOUND_CLK	0x9f	/* emit a keyclick */
+#define LK_CMD_DIS_BELL		0xa1	/* disable the bell */
+#define LK_CMD_ENB_BELL		0x23	/* enable the bell */
+					/* 1st param: volume */
+#define LK_CMD_BELL		0xa7	/* emit a bell */
+#define LK_CMD_TMP_NORPT	0xd1	/* disable typematic */
+					/* for the currently pressed key */
+#define LK_CMD_ENB_RPT		0xe3	/* enable typematic */
+					/* for RPT_DOWN groups */
+#define LK_CMD_DIS_RPT		0xe1	/* disable typematic */
+					/* for RPT_DOWN groups */
+#define LK_CMD_RPT_TO_DOWN	0xd9	/* set RPT_DOWN groups to DOWN */
+#define LK_CMD_REQ_ID		0xab	/* request the keyboard ID */
+#define LK_CMD_POWER_UP		0xfd	/* init power-up sequence */
+#define LK_CMD_TEST_MODE	0xcb	/* enter the factory test mode */
+#define LK_CMD_TEST_EXIT	0x80	/* exit the factory test mode */
+#define LK_CMD_SET_DEFAULTS	0xd3	/* set power-up defaults */
+
+#define LK_CMD_MODE(m,div)	(LK_PARAM|(((div)&0xf)<<3)|(((m)&0x3)<<1))
+					/* select the repeat mode */
+					/* for the selected key group */
+#define LK_CMD_MODE_AR(m,div)	((((div)&0xf)<<3)|(((m)&0x3)<<1))
+					/* select the repeat mode */
+					/* and the repeat register */
+					/* for the selected key group */
+					/* 1st param: register number */
+#define LK_CMD_RPT_RATE(r)	(0x78|(((r)&0x3)<<1))
+					/* set the delay and repeat rate */
+					/* for the selected repeat register */
+					/* 1st param: initial delay */
+					/* 2nd param: repeat rate */
 
 /* there are 4 leds, represent them in the low 4 bits of a byte */
-#define	LK_PARAM_LED_MASK(ledbmap)	(LK_PARAM|(ledbmap))
+#define LK_PARAM_LED_MASK(ledbmap)	(LK_PARAM|((ledbmap)&0xf))
+#define LK_LED_WAIT		0x1	/* Wait LED */
+#define LK_LED_COMP		0x2	/* Compose LED */
+#define LK_LED_LOCK		0x4	/* Lock LED */
+#define LK_LED_HOLD		0x8	/* Hold Screen LED */
 
 /* max volume is 0, lowest is 0x7 */
-#define	LK_PARAM_VOLUME(v)		(LK_PARAM|((v)&0x7))
+#define LK_PARAM_VOLUME(v)		(LK_PARAM|((v)&0x7))
 
-/* mode set command(s) details */
-#define	LK_MODE_DOWN		0x0
-#define	LK_MODE_RPT_DOWN	0x2
-#define	LK_MODE_DOWN_UP		0x6
-#define	LK_CMD_MODE(m,div)	(LK_PARAM|(div<<3)|m)
+/* mode set command details, div is a key group number */
+#define LK_MODE_DOWN		0x0	/* make only */
+#define LK_MODE_RPT_DOWN	0x1	/* make and typematic */
+#define LK_MODE_DOWN_UP		0x3	/* make and release */
+
+/* there are 4 repeat registers */
+#define LK_PARAM_AR(r)		(LK_PARAM|((v)&0x3))
+
+/*
+ * Mappings between key groups and keycodes are as follows:
+ *
+ *  1: 0xbf - 0xff -- alphanumeric,
+ *  2: 0x91 - 0xa5 -- numeric keypad,
+ *  3: 0xbc        -- Backspace,
+ *  4: 0xbd - 0xbe -- Tab, Return,
+ *  5: 0xb0 - 0xb2 -- Lock, Compose Character,
+ *  6: 0xad - 0xaf -- Ctrl, Shift,
+ *  7: 0xa6 - 0xa8 -- Left Arrow, Right Arrow,
+ *  8: 0xa9 - 0xac -- Up Arrow, Down Arrow, Right Shift,
+ *  9: 0x88 - 0x90 -- editor keypad,
+ * 10: 0x56 - 0x62 -- F1 - F5,
+ * 11: 0x63 - 0x6e -- F6 - F10,
+ * 12: 0x6f - 0x7a -- F11 - F14,
+ * 13: 0x7b - 0x7d -- Help, Do,
+ * 14: 0x7e - 0x87 -- F17 - F20.
+ *
+ * Notes:
+ * 1. Codes in the 0x00 - 0x40 range are reserved.
+ * 2. The assignment of the 0x41 - 0x55 range is undiscovered, probably 10.
+ */
+
+/* delay is 5 - 630 ms; 0x00 and 0x7f are reserved */
+#define LK_PARAM_DELAY(t)	((t)&0x7f)
+
+/* rate is 12 - 127 Hz; 0x00 - 0x0b and 0x7d (power-up!) are reserved */
+#define LK_PARAM_RATE(r)	(LK_PARAM|((r)&0x7f))
 
 #define LK_SHIFT 1<<0
 #define LK_CTRL 1<<1
 #define LK_LOCK 1<<2
 #define LK_COMP 1<<3
 
-#define LK_KEY_SHIFT 174
-#define LK_KEY_CTRL 175
-#define LK_KEY_LOCK 176
-#define LK_KEY_COMP 177
-#define LK_KEY_RELEASE 179
-#define LK_KEY_REPEAT 180
-#define LK_KEY_ACK 186
+#define LK_KEY_SHIFT		0xae
+#define LK_KEY_CTRL		0xaf
+#define LK_KEY_LOCK		0xb0
+#define LK_KEY_COMP		0xb1
+
+#define LK_KEY_RELEASE		0xb3	/* all keys released */
+#define LK_KEY_REPEAT		0xb4	/* repeat the last key */
+
+/* status responses */
+#define LK_STAT_RESUME_ERR	0xb5	/* keystrokes lost while inhibited */
+#define LK_STAT_ERROR		0xb6	/* an invalid command received */
+#define LK_STAT_INHIBIT_ACK	0xb7	/* transmission inhibited */
+#define LK_STAT_TEST_ACK	0xb8	/* the factory test mode entered */
+#define LK_STAT_MODE_KEYDOWN	0xb9	/* a key is down on a change */
+					/* to the DOWN_UP mode; */
+					/* the keycode follows */
+#define LK_STAT_MODE_ACK	0xba	/* the mode command succeeded */
+
+#define LK_STAT_PWRUP_ID	0x01	/* the power-up response start mark */
+#define LK_STAT_PWRUP_OK	0x00	/* the power-up self test OK */
+#define LK_STAT_PWRUP_KDOWN	0x3d	/* a key was down during the test */
+#define LK_STAT_PWRUP_ERROR	0x3e	/* keyboard self test failure */
 
-extern unsigned char scancodeRemap[256];
\ No newline at end of file
+extern unsigned char scancodeRemap[256];
diff -purN linux-2.6.11-rc2-bk10/drivers/tc/tc.c linux-2.6.11-rc3/drivers/tc/tc.c
--- linux-2.6.11-rc2-bk10/drivers/tc/tc.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/tc/tc.c	2005-02-03 02:56:48.000000000 +0100
@@ -8,46 +8,46 @@
  * for more details.
  *
  * Copyright (c) Harald Koerfgen, 1998
+ * Copyright (c) 2001, 2003  Maciej W. Rozycki
  */
 #include <linux/string.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
 #include <asm/addrspace.h>
 #include <asm/errno.h>
 #include <asm/dec/machtype.h>
+#include <asm/dec/prom.h>
 #include <asm/dec/tcinfo.h>
 #include <asm/dec/tcmodule.h>
 #include <asm/dec/interrupts.h>
-
+#include <asm/paccess.h>
 #include <asm/ptrace.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
 
 #define TC_DEBUG
 
 MODULE_LICENSE("GPL");
 slot_info tc_bus[MAX_SLOT];
-static int max_tcslot;
+static int num_tcslots;
 static tcinfo *info;
 
 unsigned long system_base;
 
-extern void (*dbe_board_handler)(struct pt_regs *regs);
-extern unsigned long *(*rex_slot_address)(int);
-extern void *(*rex_gettcinfo)(void);
-
 /*
  * Interface to the world. Read comment in include/asm-mips/tc.h.
  */
 
-int search_tc_card(char *name)
+int search_tc_card(const char *name)
 {
 	int slot;
 	slot_info *sip;
 
-	for (slot = 0; slot <= max_tcslot; slot++) {
+	for (slot = 0; slot < num_tcslots; slot++) {
 		sip = &tc_bus[slot];
-		if ((sip->flags & FREE) && (strncmp(sip->name, name, strlen(name)) == 0)) {
+		if ((sip->flags & FREE) &&
+		    (strncmp(sip->name, name, strlen(name)) == 0)) {
 			return slot;
 		}
 	}
@@ -68,7 +68,8 @@ void claim_tc_card(int slot)
 void release_tc_card(int slot)
 {
 	if (tc_bus[slot].flags & FREE) {
-		printk("release_tc_card: attempting to release a card already free\n");
+		printk("release_tc_card: "
+		       "attempting to release a card already free\n");
 		return;
 	}
 	tc_bus[slot].flags &= ~IN_USE;
@@ -93,73 +94,84 @@ unsigned long get_tc_speed(void)
 /*
  * Probing for TURBOchannel modules
  */
-static void __init my_dbe_handler(struct pt_regs *regs)
+static void __init tc_probe(unsigned long startaddr, unsigned long size,
+			    int slots)
 {
-	regs->cp0_epc += 4;
-}
-
-static void __init tc_probe(unsigned long startaddr, unsigned long size, int max_slot)
-{
-	int i, slot;
+	int i, slot, err;
 	long offset;
+	unsigned char pattern[4];
 	unsigned char *module;
-	void (*old_be_handler)(struct pt_regs *regs);
-
-	/* Install our exception handler temporarily */
 
-	old_be_handler = dbe_board_handler;
-	dbe_board_handler = my_dbe_handler;
-	for (slot = 0; slot <= max_slot; slot++) {
+	for (slot = 0; slot < slots; slot++) {
 		module = (char *)(startaddr + slot * size);
-		offset = -1;
-		if (module[OLDCARD + TC_PATTERN0] == 0x55 && module[OLDCARD + TC_PATTERN1] == 0x00
-		  && module[OLDCARD + TC_PATTERN2] == 0xaa && module[OLDCARD + TC_PATTERN3] == 0xff)
-			offset = OLDCARD;
-		if (module[TC_PATTERN0] == 0x55 && module[TC_PATTERN1] == 0x00
-		  && module[TC_PATTERN2] == 0xaa && module[TC_PATTERN3] == 0xff)
-			offset = 0;
-
-		if (offset != -1) {
-			tc_bus[slot].base_addr = (unsigned long)module;
-			for(i = 0; i < 8; i++) {
-				tc_bus[slot].firmware[i] = module[TC_FIRM_VER + offset + 4 * i];
-				tc_bus[slot].vendor[i] = module[TC_VENDOR + offset + 4 * i];
-				tc_bus[slot].name[i] = module[TC_MODULE + offset + 4 * i];
-			}
-			tc_bus[slot].firmware[8] = 0;
-			tc_bus[slot].vendor[8] = 0;
-			tc_bus[slot].name[8] = 0;
-			/*
-			 * Looks unneccesary, but we may change
-			 * TC? in the future
-			 */
-			switch (slot) {
-			case 0:
-				tc_bus[slot].interrupt = TC0;
-				break;
-			case 1:
-				tc_bus[slot].interrupt = TC1;
-				break;
-			case 2:
-				tc_bus[slot].interrupt = TC2;
-				break;
-			/*
-			 * Yuck! DS5000/200 onboard devices
-			 */
-			case 5:
-				tc_bus[slot].interrupt = SCSI_INT;
-				break;
-			case 6:
-				tc_bus[slot].interrupt = ETHER;
-				break;
-			default:
-				tc_bus[slot].interrupt = -1;
-				break;
-			}	
+
+		offset = OLDCARD;
+
+		err = 0;
+		err |= get_dbe(pattern[0], module + OLDCARD + TC_PATTERN0);
+		err |= get_dbe(pattern[1], module + OLDCARD + TC_PATTERN1);
+		err |= get_dbe(pattern[2], module + OLDCARD + TC_PATTERN2);
+		err |= get_dbe(pattern[3], module + OLDCARD + TC_PATTERN3);
+		if (err)
+			continue;
+
+		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
+		    pattern[2] != 0xaa || pattern[3] != 0xff) {
+			offset = NEWCARD;
+
+			err = 0;
+			err |= get_dbe(pattern[0], module + TC_PATTERN0);
+			err |= get_dbe(pattern[1], module + TC_PATTERN1);
+			err |= get_dbe(pattern[2], module + TC_PATTERN2);
+			err |= get_dbe(pattern[3], module + TC_PATTERN3);
+			if (err)
+				continue;
 		}
-	}
 
-	dbe_board_handler = old_be_handler;
+		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
+		    pattern[2] != 0xaa || pattern[3] != 0xff)
+			continue;
+
+		tc_bus[slot].base_addr = (unsigned long)module;
+		for(i = 0; i < 8; i++) {
+			tc_bus[slot].firmware[i] =
+				module[TC_FIRM_VER + offset + 4 * i];
+			tc_bus[slot].vendor[i] =
+				module[TC_VENDOR + offset + 4 * i];
+			tc_bus[slot].name[i] =
+				module[TC_MODULE + offset + 4 * i];
+		}
+		tc_bus[slot].firmware[8] = 0;
+		tc_bus[slot].vendor[8] = 0;
+		tc_bus[slot].name[8] = 0;
+		/*
+		 * Looks unneccesary, but we may change
+		 * TC? in the future
+		 */
+		switch (slot) {
+		case 0:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC0];
+			break;
+		case 1:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC1];
+			break;
+		case 2:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC2];
+			break;
+		/*
+		 * Yuck! DS5000/200 onboard devices
+		 */
+		case 5:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC5];
+			break;
+		case 6:
+			tc_bus[slot].interrupt = dec_interrupt[DEC_IRQ_TC6];
+			break;
+		default:
+			tc_bus[slot].interrupt = -1;
+			break;
+		}
+	}
 }
 
 /*
@@ -189,15 +201,16 @@ void __init tc_init(void)
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
-		max_tcslot = 6;
+		num_tcslots = 7;
 		break;
 	case MACH_DS5000_1XX:
 	case MACH_DS5000_2X0:
-		max_tcslot = 2;
+	case MACH_DS5900:
+		num_tcslots = 3;
 		break;
 	case MACH_DS5000_XX:
 	default:
-		max_tcslot = 1;
+		num_tcslots = 2;
 		break;
 	}
 
@@ -210,22 +223,22 @@ void __init tc_init(void)
 
 		slot_size = info->slot_size << 20;
 
-		tc_probe(slot0addr, slot_size, max_tcslot);
+		tc_probe(slot0addr, slot_size, num_tcslots);
 
   		/*
   		 * All TURBOchannel DECstations have the onboard devices
- 		 * where the (max_tcslot + 1 or 2 on DS5k/xx) Option Module
+ 		 * where the (num_tcslots + 0 or 1 on DS5k/xx) Option Module
  		 * would be.
  		 */
  		if(mips_machtype == MACH_DS5000_XX)
- 			i = 2;
-		else
  			i = 1;
- 		
- 	        system_base = slot0addr + slot_size * (max_tcslot + i);
+		else
+ 			i = 0;
+
+ 	        system_base = slot0addr + slot_size * (num_tcslots + i);
 
 #ifdef TC_DEBUG
-		for (i = 0; i <= max_tcslot; i++)
+		for (i = 0; i < num_tcslots; i++)
 			if (tc_bus[i].base_addr) {
 				printk("    slot %d: ", i);
 				printk("%s %s %s\n", tc_bus[i].vendor,
@@ -244,4 +257,4 @@ EXPORT_SYMBOL(release_tc_card);
 EXPORT_SYMBOL(get_tc_base_addr);
 EXPORT_SYMBOL(get_tc_irq_nr);
 EXPORT_SYMBOL(get_tc_speed);
-
+EXPORT_SYMBOL(system_base);
diff -purN linux-2.6.11-rc2-bk10/drivers/tc/zs.c linux-2.6.11-rc3/drivers/tc/zs.c
--- linux-2.6.11-rc2-bk10/drivers/tc/zs.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/tc/zs.c	2005-02-03 02:56:34.000000000 +0100
@@ -6,7 +6,7 @@
  *
  * DECstation changes
  * Copyright (C) 1998-2000 Harald Koerfgen
- * Copyright (C) 2000,2001 Maciej W. Rozycki <macro@ds2.pg.gda.pl>
+ * Copyright (C) 2000, 2001, 2002, 2003, 2004  Maciej W. Rozycki
  *
  * For the rest of the code the original Copyright applies:
  * Copyright (C) 1996 Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
@@ -55,8 +55,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
-#include <linux/bitops.h>
-#ifdef CONFIG_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
 #include <linux/console.h>
 #endif
 
@@ -65,18 +64,15 @@
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
-#include <asm/wbflush.h>
 #include <asm/bootinfo.h>
+#include <asm/dec/serial.h>
+
 #ifdef CONFIG_MACH_DECSTATION
 #include <asm/dec/interrupts.h>
 #include <asm/dec/machtype.h>
 #include <asm/dec/tc.h>
 #include <asm/dec/ioasic_addrs.h>
 #endif
-#ifdef CONFIG_BAGET_MIPS
-#include <asm/baget/baget.h>
-unsigned long system_base;
-#endif
 #ifdef CONFIG_KGDB
 #include <asm/kgdb.h>
 #endif
@@ -94,7 +90,7 @@ unsigned long system_base;
 #define NUM_SERIAL	2		/* Max number of ZS chips supported */
 #define NUM_CHANNELS	(NUM_SERIAL * 2)	/* 2 channels per chip */
 #define CHANNEL_A_NR  (zs_parms->channel_a_offset > zs_parms->channel_b_offset)
-                                        /* Number of channel A in the chip */ 
+                                        /* Number of channel A in the chip */
 #define ZS_CHAN_IO_SIZE 8
 #define ZS_CLOCK        7372800 	/* Z8530 RTxC input clock rate */
 
@@ -105,7 +101,8 @@ struct zs_parms {
 	unsigned long scc1;
 	int channel_a_offset;
 	int channel_b_offset;
-	int irq;
+	int irq0;
+	int irq1;
 	int clock;
 };
 
@@ -113,24 +110,15 @@ static struct zs_parms *zs_parms;
 
 #ifdef CONFIG_MACH_DECSTATION
 static struct zs_parms ds_parms = {
-	scc0 : SCC0,
-	scc1 : SCC1,
+	scc0 : IOASIC_SCC0,
+	scc1 : IOASIC_SCC1,
 	channel_a_offset : 1,
 	channel_b_offset : 9,
-	irq : SERIAL,
+	irq0 : -1,
+	irq1 : -1,
 	clock : ZS_CLOCK
 };
 #endif
-#ifdef CONFIG_BAGET_MIPS
-static struct zs_parms baget_parms = {
-	scc0 : UNI_SCC0,
-	scc1 : UNI_SCC1,
-	channel_a_offset : 9,
-	channel_b_offset : 1,
-	irq : BAGET_SCC_IRQ,
-	clock : 14745000
-};
-#endif
 
 #ifdef CONFIG_MACH_DECSTATION
 #define DS_BUS_PRESENT (IOASIC)
@@ -138,13 +126,7 @@ static struct zs_parms baget_parms = {
 #define DS_BUS_PRESENT 0
 #endif
 
-#ifdef CONFIG_BAGET_MIPS
-#define BAGET_BUS_PRESENT (mips_machtype == MACH_BAGET202)
-#else
-#define BAGET_BUS_PRESENT 0
-#endif
-
-#define BUS_PRESENT (DS_BUS_PRESENT || BAGET_BUS_PRESENT)
+#define BUS_PRESENT (DS_BUS_PRESENT)
 
 struct dec_zschannel zs_channels[NUM_CHANNELS];
 struct dec_serial zs_soft[NUM_CHANNELS];
@@ -153,28 +135,28 @@ struct dec_serial *zs_chain;	/* list of 
 
 struct tty_struct zs_ttys[NUM_CHANNELS];
 
-#ifdef CONFIG_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
 static struct console sercons;
 #endif
-#if defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) \
-    && !defined(MODULE)
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
 static unsigned long break_pressed; /* break, really ... */
 #endif
 
 static unsigned char zs_init_regs[16] __initdata = {
-	0,                           /* write 0 */
-	0,			     /* write 1 */
-	0xf0,                        /* write 2 */
-	(Rx8),                       /* write 3 */
-	(X16CLK | SB1),              /* write 4 */
-	(Tx8),                       /* write 5 */
-	0, 0, 0,                     /* write 6, 7, 8 */
-	(VIS),                       /* write 9 */
-	(NRZ),                       /* write 10 */
-	(TCBR | RCBR),               /* write 11 */
-	0, 0,                        /* BRG time constant, write 12 + 13 */
-	(BRSRC | BRENABL),           /* write 14 */
-	0 			     /* write 15 */
+	0,				/* write 0 */
+	0,				/* write 1 */
+	0,				/* write 2 */
+	0,				/* write 3 */
+	(X16CLK),			/* write 4 */
+	0,				/* write 5 */
+	0, 0, 0,			/* write 6, 7, 8 */
+	(MIE | DLC | NV),		/* write 9 */
+	(NRZ),				/* write 10 */
+	(TCBR | RCBR),			/* write 11 */
+	0, 0,				/* BRG time constant, write 12 + 13 */
+	(BRSRC | BRENABL),		/* write 14 */
+	0				/* write 15 */
 };
 
 DECLARE_TASK_QUEUE(tq_zs_serial);
@@ -190,7 +172,6 @@ static struct tty_driver *serial_driver;
 /*
  * Debugging.
  */
-#undef SERIAL_DEBUG_INTR
 #undef SERIAL_DEBUG_OPEN
 #undef SERIAL_DEBUG_FLOW
 #undef SERIAL_DEBUG_THROTTLE
@@ -251,7 +232,7 @@ static int baud_table[] = {
 	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
 	9600, 19200, 38400, 57600, 115200, 0 };
 
-/* 
+/*
  * Reading and writing Z8530 registers.
  */
 static inline unsigned char read_zsreg(struct dec_zschannel *channel,
@@ -261,7 +242,7 @@ static inline unsigned char read_zsreg(s
 
 	if (reg != 0) {
 		*channel->control = reg & 0xf;
-		wbflush(); RECOVERY_DELAY;
+		fast_iob(); RECOVERY_DELAY;
 	}
 	retval = *channel->control;
 	RECOVERY_DELAY;
@@ -273,10 +254,10 @@ static inline void write_zsreg(struct de
 {
 	if (reg != 0) {
 		*channel->control = reg & 0xf;
-		wbflush(); RECOVERY_DELAY;
+		fast_iob(); RECOVERY_DELAY;
 	}
 	*channel->control = value;
-	wbflush(); RECOVERY_DELAY;
+	fast_iob(); RECOVERY_DELAY;
 	return;
 }
 
@@ -293,7 +274,7 @@ static inline void write_zsdata(struct d
 				unsigned char value)
 {
 	*channel->data = value;
-	wbflush(); RECOVERY_DELAY;
+	fast_iob(); RECOVERY_DELAY;
 	return;
 }
 
@@ -303,9 +284,9 @@ static inline void load_zsregs(struct de
 /*	ZS_CLEARERR(channel);
 	ZS_CLEARFIFO(channel); */
 	/* Load 'em up */
-	write_zsreg(channel, R4, regs[R4]);
 	write_zsreg(channel, R3, regs[R3] & ~RxENABLE);
 	write_zsreg(channel, R5, regs[R5] & ~TxENAB);
+	write_zsreg(channel, R4, regs[R4]);
 	write_zsreg(channel, R9, regs[R9]);
 	write_zsreg(channel, R1, regs[R1]);
 	write_zsreg(channel, R2, regs[R2]);
@@ -372,8 +353,6 @@ static inline void rs_recv_clear(struct 
  * -----------------------------------------------------------------------
  */
 
-static int tty_break;	/* Set whenever BREAK condition is detected.  */
-
 /*
  * This routine is used by the interrupt handler to schedule
  * processing in the software interrupt portion of the driver.
@@ -397,23 +376,18 @@ static _INLINE_ void receive_chars(struc
 		stat = read_zsreg(info->zs_channel, R1);
 		ch = read_zsdata(info->zs_channel);
 
-		if (!tty && !info->hook && !info->hook->rx_char)
+		if (!tty && (!info->hook || !info->hook->rx_char))
 			continue;
 
-		if (tty_break) {
-			tty_break = 0;
-#if defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
-			if (info->line == sercons.index) {
-				if (!break_pressed) {
-					break_pressed = jiffies;
-					goto ignore_char;
-				}
-				break_pressed = 0;
-			}
-#endif
+		flag = TTY_NORMAL;
+		if (info->tty_break) {
+			info->tty_break = 0;
 			flag = TTY_BREAK;
 			if (info->flags & ZILOG_SAK)
 				do_SAK(tty);
+			/* Ignore the null char got when BREAK is removed.  */
+			if (ch == 0)
+				continue;
 		} else {
 			if (stat & Rx_OVR) {
 				flag = TTY_OVERRUN;
@@ -421,20 +395,22 @@ static _INLINE_ void receive_chars(struc
 				flag = TTY_FRAME;
 			} else if (stat & PAR_ERR) {
 				flag = TTY_PARITY;
-			} else
-				flag = 0;
-			if (flag)
+			}
+			if (flag != TTY_NORMAL)
 				/* reset the error indication */
 				write_zsreg(info->zs_channel, R0, ERR_RES);
 		}
 
-#if defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
 		if (break_pressed && info->line == sercons.index) {
-			if (ch != 0 &&
-			    time_before(jiffies, break_pressed + HZ*5)) {
+			/* Ignore the null char got when BREAK is removed.  */
+			if (ch == 0)
+				continue;
+			if (time_before(jiffies, break_pressed + HZ * 5)) {
 				handle_sysrq(ch, regs, NULL);
 				break_pressed = 0;
-				goto ignore_char;
+				continue;
 			}
 			break_pressed = 0;
 		}
@@ -444,22 +420,8 @@ static _INLINE_ void receive_chars(struc
 			(*info->hook->rx_char)(ch, flag);
 			return;
   		}
-		
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
-			static int flip_buf_ovf;
-			++flip_buf_ovf;
-			continue;
-		}
-		tty->flip.count++;
-		{
-			static int flip_max_cnt;
-			if (flip_max_cnt < tty->flip.count)
-				flip_max_cnt = tty->flip.count;
-		}
 
-		*tty->flip.flag_buf_ptr++ = flag;
-		*tty->flip.char_buf_ptr++ = ch;
-	ignore_char:
+		tty_insert_flip_char(tty, ch, flag);
 	}
 	if (tty)
 		tty_flip_buffer_push(tty);
@@ -501,18 +463,22 @@ static _INLINE_ void status_handle(struc
 	/* Get status from Read Register 0 */
 	stat = read_zsreg(info->zs_channel, R0);
 
-	if (stat & BRK_ABRT) {
-#ifdef SERIAL_DEBUG_INTR
-		printk("handling break....");
+	if ((stat & BRK_ABRT) && !(info->read_reg_zero & BRK_ABRT)) {
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
+		if (info->line == sercons.index) {
+			if (!break_pressed)
+				break_pressed = jiffies;
+		} else
 #endif
-		tty_break = 1;
+			info->tty_break = 1;
 	}
 
 	if (info->zs_channel != info->zs_chan_a) {
 
-		/* FIXEM: Check for DCD transitions */
-		if (((stat ^ info->read_reg_zero) & DCD) != 0
-		    && info->tty && !C_CLOCAL(info->tty)) {
+		/* Check for DCD transitions */
+		if (info->tty && !C_CLOCAL(info->tty) &&
+		    ((stat ^ info->read_reg_zero) & DCD) != 0 ) {
 			if (stat & DCD) {
 				wake_up_interruptible(&info->open_wait);
 			} else {
@@ -563,7 +529,7 @@ void rs_interrupt(int irq, void *dev_id,
 		shift = 0;	/* Channel B */
 
 	for (;;) {
-		zs_intreg = read_zsreg(info->zs_chan_a, R3) >> shift; 
+		zs_intreg = read_zsreg(info->zs_chan_a, R3) >> shift;
 		if ((zs_intreg & CHAN_IRQMASK) == 0)
 			break;
 
@@ -577,7 +543,7 @@ void rs_interrupt(int irq, void *dev_id,
 			status_handle(info);
 		}
 	}
-	
+
 	/* Why do we need this ? */
 	write_zsreg(info->zs_channel, 0, RES_H_IUS);
 }
@@ -586,14 +552,14 @@ void rs_interrupt(int irq, void *dev_id,
 void zs_dump (void) {
 	int i, j;
 	for (i = 0; i < zs_channels_found; i++) {
-		struct dec_zschannel *ch = &zs_channels[i]; 
+		struct dec_zschannel *ch = &zs_channels[i];
 		if ((long)ch->control == UNI_IO_BASE+UNI_SCC1A_CTRL) {
 			for (j = 0; j < 15; j++) {
-				printk("W%d = 0x%x\t", 
+				printk("W%d = 0x%x\t",
 				       j, (int)ch->curregs[j]);
 			}
 			for (j = 0; j < 15; j++) {
-				printk("R%d = 0x%x\t", 
+				printk("R%d = 0x%x\t",
 				       j, (int)read_zsreg(ch,j));
 			}
 			printk("\n\n");
@@ -622,7 +588,7 @@ static void rs_stop(struct tty_struct *t
 
 	if (serial_paranoia_check(info, tty->name, "rs_stop"))
 		return;
-	
+
 #if 1
 	save_flags(flags); cli();
 	if (info->zs_channel->curregs[5] & TxENAB) {
@@ -637,10 +603,10 @@ static void rs_start(struct tty_struct *
 {
 	struct dec_serial *info = (struct dec_serial *)tty->driver_data;
 	unsigned long flags;
-	
+
 	if (serial_paranoia_check(info, tty->name, "rs_start"))
 		return;
-	
+
 	save_flags(flags); cli();
 #if 1
 	if (info->xmit_cnt && info->xmit_buf && !(info->zs_channel->curregs[5] & TxENAB)) {
@@ -673,7 +639,7 @@ static void do_softint(void *private_)
 {
 	struct dec_serial	*info = (struct dec_serial *) private_;
 	struct tty_struct	*tty;
-	
+
 	tty = info->tty;
 	if (!tty)
 		return;
@@ -711,8 +677,13 @@ int zs_startup(struct dec_serial * info)
 	/*
 	 * Clear the interrupt registers.
 	 */
-	write_zsreg(info->zs_channel, 0, ERR_RES);
-	write_zsreg(info->zs_channel, 0, RES_H_IUS);
+	write_zsreg(info->zs_channel, R0, ERR_RES);
+	write_zsreg(info->zs_channel, R0, RES_H_IUS);
+
+	/*
+	 * Set the speed of the serial port
+	 */
+	change_speed(info);
 
 	/*
 	 * Turn on RTS and DTR.
@@ -722,35 +693,30 @@ int zs_startup(struct dec_serial * info)
 	/*
 	 * Finally, enable sequencing and interrupts
 	 */
-	info->zs_channel->curregs[1] = (info->zs_channel->curregs[1] & ~0x18) | (EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB);
-	info->zs_channel->curregs[3] |= (RxENABLE | Rx8);
-	info->zs_channel->curregs[5] |= (TxENAB | Tx8);
-	info->zs_channel->curregs[15] |= (DCDIE | CTSIE | TxUIE | BRKIE);
-	info->zs_channel->curregs[9] |= (VIS | MIE);
-	write_zsreg(info->zs_channel, 1, info->zs_channel->curregs[1]);
-	write_zsreg(info->zs_channel, 3, info->zs_channel->curregs[3]);
-	write_zsreg(info->zs_channel, 5, info->zs_channel->curregs[5]);
-	write_zsreg(info->zs_channel, 15, info->zs_channel->curregs[15]);
-	write_zsreg(info->zs_channel, 9, info->zs_channel->curregs[9]);
+	info->zs_channel->curregs[R1] &= ~RxINT_MASK;
+	info->zs_channel->curregs[R1] |= (RxINT_ALL | TxINT_ENAB |
+					  EXT_INT_ENAB);
+	info->zs_channel->curregs[R3] |= RxENABLE;
+	info->zs_channel->curregs[R5] |= TxENAB;
+	info->zs_channel->curregs[R15] |= (DCDIE | CTSIE | TxUIE | BRKIE);
+	write_zsreg(info->zs_channel, R1, info->zs_channel->curregs[R1]);
+	write_zsreg(info->zs_channel, R3, info->zs_channel->curregs[R3]);
+	write_zsreg(info->zs_channel, R5, info->zs_channel->curregs[R5]);
+	write_zsreg(info->zs_channel, R15, info->zs_channel->curregs[R15]);
 
 	/*
 	 * And clear the interrupt registers again for luck.
 	 */
-	write_zsreg(info->zs_channel, 0, ERR_RES);
-	write_zsreg(info->zs_channel, 0, RES_H_IUS);
+	write_zsreg(info->zs_channel, R0, ERR_RES);
+	write_zsreg(info->zs_channel, R0, RES_H_IUS);
+
+	/* Save the current value of RR0 */
+	info->read_reg_zero = read_zsreg(info->zs_channel, R0);
 
 	if (info->tty)
 		clear_bit(TTY_IO_ERROR, &info->tty->flags);
 	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
 
-	/*
-	 * Set the speed of the serial port
-	 */
-	change_speed(info);
-
-	/* Save the current value of RR0 */
-	info->read_reg_zero = read_zsreg(info->zs_channel, 0);
-
 	info->flags |= ZILOG_INITIALIZED;
 	restore_flags(flags);
 	return 0;
@@ -771,9 +737,9 @@ static void shutdown(struct dec_serial *
 	printk("Shutting down serial port %d (irq %d)....", info->line,
 	       info->irq);
 #endif
-	
+
 	save_flags(flags); cli(); /* Disable interrupts */
-	
+
 	if (info->xmit_buf) {
 		free_page((unsigned long) info->xmit_buf);
 		info->xmit_buf = 0;
@@ -833,13 +799,11 @@ static void change_speed(struct dec_seri
 
 	save_flags(flags); cli();
 	info->zs_baud = baud_table[i];
-	info->clk_divisor = 16;
 	if (info->zs_baud) {
-		info->zs_channel->curregs[4] = X16CLK;
 		brg = BPS_TO_BRG(info->zs_baud, zs_parms->clock/info->clk_divisor);
 		info->zs_channel->curregs[12] = (brg & 255);
 		info->zs_channel->curregs[13] = ((brg >> 8) & 255);
-		zs_rtsdtr(info, DTR, 1); 
+		zs_rtsdtr(info, DTR, 1);
 	} else {
 		zs_rtsdtr(info, RTS | DTR, 0);
 		return;
@@ -942,13 +906,21 @@ static int rs_write(struct tty_struct * 
 
 	save_flags(flags);
 	while (1) {
-		cli();		
-		c = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
-					  SERIAL_XMIT_SIZE - info->xmit_head));
+		cli();
+		c = min(count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+				   SERIAL_XMIT_SIZE - info->xmit_head));
 		if (c <= 0)
 			break;
 
-		memcpy(info->xmit_buf + info->xmit_head, buf, c);
+		if (from_user) {
+			down(&tmp_buf_sem);
+			copy_from_user(tmp_buf, buf, c);
+			c = min(c, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+				       SERIAL_XMIT_SIZE - info->xmit_head));
+			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
+			up(&tmp_buf_sem);
+		} else
+			memcpy(info->xmit_buf + info->xmit_head, buf, c);
 		info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE-1);
 		info->xmit_cnt += c;
 		restore_flags(flags);
@@ -968,7 +940,7 @@ static int rs_write_room(struct tty_stru
 {
 	struct dec_serial *info = (struct dec_serial *)tty->driver_data;
 	int	ret;
-				
+
 	if (serial_paranoia_check(info, tty->name, "rs_write_room"))
 		return 0;
 	ret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;
@@ -980,7 +952,7 @@ static int rs_write_room(struct tty_stru
 static int rs_chars_in_buffer(struct tty_struct *tty)
 {
 	struct dec_serial *info = (struct dec_serial *)tty->driver_data;
-			
+
 	if (serial_paranoia_check(info, tty->name, "rs_chars_in_buffer"))
 		return 0;
 	return info->xmit_cnt;
@@ -989,7 +961,7 @@ static int rs_chars_in_buffer(struct tty
 static void rs_flush_buffer(struct tty_struct *tty)
 {
 	struct dec_serial *info = (struct dec_serial *)tty->driver_data;
-				
+
 	if (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))
 		return;
 	cli();
@@ -1001,7 +973,7 @@ static void rs_flush_buffer(struct tty_s
 /*
  * ------------------------------------------------------------
  * rs_throttle()
- * 
+ *
  * This routine is called by the upper-layer tty layer to signal that
  * incoming characters should be throttled.
  * ------------------------------------------------------------
@@ -1013,14 +985,14 @@ static void rs_throttle(struct tty_struc
 
 #ifdef SERIAL_DEBUG_THROTTLE
 	char	buf[64];
-	
+
 	printk("throttle %s: %d....\n", _tty_name(tty, buf),
 	       tty->ldisc.chars_in_buffer(tty));
 #endif
 
 	if (serial_paranoia_check(info, tty->name, "rs_throttle"))
 		return;
-	
+
 	if (I_IXOFF(tty)) {
 		save_flags(flags); cli();
 		info->x_char = STOP_CHAR(tty);
@@ -1041,14 +1013,14 @@ static void rs_unthrottle(struct tty_str
 
 #ifdef SERIAL_DEBUG_THROTTLE
 	char	buf[64];
-	
+
 	printk("unthrottle %s: %d....\n", _tty_name(tty, buf),
 	       tty->ldisc.chars_in_buffer(tty));
 #endif
 
 	if (serial_paranoia_check(info, tty->name, "rs_unthrottle"))
 		return;
-	
+
 	if (I_IXOFF(tty)) {
 		save_flags(flags); cli();
 		if (info->x_char)
@@ -1145,7 +1117,7 @@ check_and_exit:
  * 	    release the bus after transmitting. This must be done when
  * 	    the transmit shift register is empty, not be done when the
  * 	    transmit holding register is empty.  This functionality
- * 	    allows an RS485 driver to be written in user space. 
+ * 	    allows an RS485 driver to be written in user space.
  */
 static int get_lsr_info(struct dec_serial * info, unsigned int *value)
 {
@@ -1192,7 +1164,7 @@ static int rs_tiocmget(struct tty_struct
 }
 
 static int rs_tiocmset(struct tty_struct *tty, struct file *file,
-		       unsigned int set, unsigned int clear)
+                       unsigned int set, unsigned int clear)
 {
 	struct dec_serial * info = (struct dec_serial *)tty->driver_data;
 	int error;
@@ -1210,6 +1182,7 @@ static int rs_tiocmset(struct tty_struct
 	if (info->zs_channel == info->zs_chan_a)
 		return 0;
 
+	get_user(arg, value);
 	cli();
 	if (set & TIOCM_RTS)
 		info->zs_chan_a->curregs[5] |= RTS;
@@ -1264,38 +1237,38 @@ static int rs_ioctl(struct tty_struct *t
 		if (tty->flags & (1 << TTY_IO_ERROR))
 		    return -EIO;
 	}
-	
+
 	switch (cmd) {
-		case TIOCGSERIAL:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-						sizeof(struct serial_struct));
-			if (error)
-				return error;
-			return get_serial_info(info,
-					       (struct serial_struct *) arg);
-		case TIOCSSERIAL:
-			return set_serial_info(info,
-					       (struct serial_struct *) arg);
-		case TIOCSERGETLSR: /* Get line status register */
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-				sizeof(unsigned int));
-			if (error)
-				return error;
-			else
-			    return get_lsr_info(info, (unsigned int *) arg);
+	case TIOCGSERIAL:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(struct serial_struct));
+		if (error)
+			return error;
+		return get_serial_info(info, (struct serial_struct *)arg);
+
+	case TIOCSSERIAL:
+		return set_serial_info(info, (struct serial_struct *)arg);
+
+	case TIOCSERGETLSR:			/* Get line status register */
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(unsigned int));
+		if (error)
+			return error;
+		else
+			return get_lsr_info(info, (unsigned int *)arg);
+
+	case TIOCSERGSTRUCT:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(struct dec_serial));
+		if (error)
+			return error;
+		copy_from_user((struct dec_serial *)arg, info,
+			       sizeof(struct dec_serial));
+		return 0;
 
-		case TIOCSERGSTRUCT:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-						sizeof(struct dec_serial));
-			if (error)
-				return error;
-			copy_from_user((struct dec_serial *) arg,
-				       info, sizeof(struct dec_serial));
-			return 0;
-			
-		default:
-			return -ENOIOCTLCMD;
-		}
+	default:
+		return -ENOIOCTLCMD;
+	}
 	return 0;
 }
 
@@ -1317,7 +1290,7 @@ static void rs_set_termios(struct tty_st
 /*
  * ------------------------------------------------------------
  * rs_close()
- * 
+ *
  * This routine is called when the serial port gets closed.
  * Wait for the last remaining data to be sent.
  * ------------------------------------------------------------
@@ -1329,14 +1302,14 @@ static void rs_close(struct tty_struct *
 
 	if (!info || serial_paranoia_check(info, tty->name, "rs_close"))
 		return;
-	
+
 	save_flags(flags); cli();
-	
+
 	if (tty_hung_up_p(filp)) {
 		restore_flags(flags);
 		return;
 	}
-	
+
 #ifdef SERIAL_DEBUG_OPEN
 	printk("rs_close ttyS%d, count = %d\n", info->line, info->count);
 #endif
@@ -1363,7 +1336,7 @@ static void rs_close(struct tty_struct *
 	}
 	info->flags |= ZILOG_CLOSING;
 	/*
-	 * Now we wait for the transmit buffer to clear; and we notify 
+	 * Now we wait for the transmit buffer to clear; and we notify
 	 * the line discipline to only process XON/XOFF characters.
 	 */
 	tty->closing = 1;
@@ -1411,7 +1384,8 @@ static void rs_close(struct tty_struct *
 static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
 {
 	struct dec_serial *info = (struct dec_serial *) tty->driver_data;
-	unsigned long orig_jiffies, char_time;
+	unsigned long orig_jiffies;
+	int char_time;
 
 	if (serial_paranoia_check(info, tty->name, "rs_wait_until_sent"))
 		return;
@@ -1427,7 +1401,7 @@ static void rs_wait_until_sent(struct tt
 	if (char_time == 0)
 		char_time = 1;
 	if (timeout)
-		char_time = min_t(unsigned long, char_time, timeout);
+		char_time = min(char_time, timeout);
 	while ((read_zsreg(info->zs_channel, 1) & Tx_BUF_EMP) == 0) {
 		current->state = TASK_INTERRUPTIBLE;
 		schedule_timeout(char_time);
@@ -1485,11 +1459,6 @@ static int block_til_ready(struct tty_st
 	}
 
 	/*
-	 * If this is a callout device, then just make sure the normal
-	 * device isn't being used.
-	 */
-	
-	/*
 	 * If non-blocking mode is set, or the port is not enabled,
 	 * then make the check up front and then exit.
 	 */
@@ -1516,7 +1485,7 @@ static int block_til_ready(struct tty_st
 	       info->line, info->count);
 #endif
 	cli();
-	if (!tty_hung_up_p(filp)) 
+	if (!tty_hung_up_p(filp))
 		info->count--;
 	sti();
 	info->blocked_open++;
@@ -1532,7 +1501,7 @@ static int block_til_ready(struct tty_st
 			if (info->flags & ZILOG_HUP_NOTIFY)
 				retval = -EAGAIN;
 			else
-				retval = -ERESTARTSYS;	
+				retval = -ERESTARTSYS;
 #else
 			retval = -EAGAIN;
 #endif
@@ -1564,7 +1533,7 @@ static int block_til_ready(struct tty_st
 		return retval;
 	info->flags |= ZILOG_NORMAL_ACTIVE;
 	return 0;
-}	
+}
 
 /*
  * This routine is called whenever a serial port is opened.  It
@@ -1626,7 +1595,7 @@ int rs_open(struct tty_struct *tty, stru
 		return retval;
 	}
 
-#ifdef CONFIG_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
 	if (sercons.cflag && sercons.index == line) {
 		tty->termios->c_cflag = sercons.cflag;
 		sercons.cflag = 0;
@@ -1645,7 +1614,7 @@ int rs_open(struct tty_struct *tty, stru
 
 static void __init show_serial_version(void)
 {
-	printk("DECstation Z8530 serial driver version 0.05\n");
+	printk("DECstation Z8530 serial driver version 0.09\n");
 }
 
 /*  Initialize Z8530s zs_channels
@@ -1655,6 +1624,7 @@ static void __init probe_sccs(void)
 {
 	struct dec_serial **pp;
 	int i, n, n_chips = 0, n_channels, chip, channel;
+	unsigned long flags;
 
 	/*
 	 * did we get here by accident?
@@ -1663,7 +1633,7 @@ static void __init probe_sccs(void)
 		printk("Not on JUNKIO machine, skipping probe_sccs\n");
 		return;
 	}
-	
+
 	/*
 	 * When serial console is activated, tc_init has not been called yet
 	 * and system_base is undefined. Unfortunately we have to hardcode
@@ -1672,27 +1642,25 @@ static void __init probe_sccs(void)
 	switch(mips_machtype) {
 #ifdef CONFIG_MACH_DECSTATION
 	case MACH_DS5000_2X0:
-		system_base = 0xbf800000;
+	case MACH_DS5900:
+		system_base = KSEG1ADDR(0x1f800000);
 		n_chips = 2;
 		zs_parms = &ds_parms;
+		zs_parms->irq0 = dec_interrupt[DEC_IRQ_SCC0];
+		zs_parms->irq1 = dec_interrupt[DEC_IRQ_SCC1];
 		break;
 	case MACH_DS5000_1XX:
-		system_base = 0xbc000000;
+		system_base = KSEG1ADDR(0x1c000000);
 		n_chips = 2;
 		zs_parms = &ds_parms;
+		zs_parms->irq0 = dec_interrupt[DEC_IRQ_SCC0];
+		zs_parms->irq1 = dec_interrupt[DEC_IRQ_SCC1];
 		break;
 	case MACH_DS5000_XX:
-		system_base = 0xbc000000;
+		system_base = KSEG1ADDR(0x1c000000);
 		n_chips = 1;
 		zs_parms = &ds_parms;
-		break;
-#endif
-#ifdef CONFIG_BAGET_MIPS
-	case MACH_BAGET202:
-		system_base = UNI_IO_BASE;
-		n_chips = 2;
-		zs_parms = &baget_parms;
-		zs_init_regs[2] = 0x8;
+		zs_parms->irq0 = dec_interrupt[DEC_IRQ_SCC0];
 		break;
 #endif
 	default:
@@ -1710,15 +1678,15 @@ static void __init probe_sccs(void)
 			/*
 			 * The sccs reside on the high byte of the 16 bit IOBUS
 			 */
-			zs_channels[n_channels].control = 
-				(volatile unsigned char *)system_base + 
-			  (0 == chip ? zs_parms->scc0 : zs_parms->scc1) + 
-			  (0 == channel ? zs_parms->channel_a_offset : 
+			zs_channels[n_channels].control =
+				(volatile unsigned char *)system_base +
+			  (0 == chip ? zs_parms->scc0 : zs_parms->scc1) +
+			  (0 == channel ? zs_parms->channel_a_offset :
 			                  zs_parms->channel_b_offset);
-			zs_channels[n_channels].data = 
+			zs_channels[n_channels].data =
 				zs_channels[n_channels].control + 4;
 
-#ifndef CONFIG_SERIAL_CONSOLE
+#ifndef CONFIG_SERIAL_DEC_CONSOLE
 			/*
 			 * We're called early and memory managment isn't up, yet.
 			 * Thus check_region would fail.
@@ -1729,20 +1697,24 @@ static void __init probe_sccs(void)
 				panic("SCC I/O region is not free");
 #endif
 			zs_soft[n_channels].zs_channel = &zs_channels[n_channels];
-			zs_soft[n_channels].irq = zs_parms->irq;
+			/* HACK alert! */
+			if (!(chip & 1))
+				zs_soft[n_channels].irq = zs_parms->irq0;
+			else
+				zs_soft[n_channels].irq = zs_parms->irq1;
 
-			/* 
+			/*
 			 *  Identification of channel A. Location of channel A
                          *  inside chip depends on mapping of internal address
 			 *  the chip decodes channels by.
-			 *  CHANNEL_A_NR returns either 0 (in case of 
+			 *  CHANNEL_A_NR returns either 0 (in case of
 			 *  DECstations) or 1 (in case of Baget).
 			 */
 			if (CHANNEL_A_NR == channel)
-				zs_soft[n_channels].zs_chan_a = 
+				zs_soft[n_channels].zs_chan_a =
 				    &zs_channels[n_channels+1-2*CHANNEL_A_NR];
 			else
-				zs_soft[n_channels].zs_chan_a = 
+				zs_soft[n_channels].zs_chan_a =
 				    &zs_channels[n_channels];
 
 			*pp = &zs_soft[n_channels];
@@ -1760,16 +1732,17 @@ static void __init probe_sccs(void)
 		}
 	}
 
-/*	save_and_cli(flags);
+	save_and_cli(flags);
 	for (n = 0; n < zs_channels_found; n++) {
-		if (((int)zs_channels[n].control & 0xf) == 1) {
+		if (n % 2 == 0) {
 			write_zsreg(zs_soft[n].zs_chan_a, R9, FHWRES);
-			mdelay(10);
+			udelay(10);
 			write_zsreg(zs_soft[n].zs_chan_a, R9, 0);
 		}
-		load_zsregs(zs_soft[n].zs_channel, zs_soft[n].zs_channel->curregs);
-	} 
-	restore_flags(flags); */
+		load_zsregs(zs_soft[n].zs_channel,
+			    zs_soft[n].zs_channel->curregs);
+	}
+	restore_flags(flags);
 }
 
 static struct tty_operations serial_ops = {
@@ -1797,7 +1770,6 @@ static struct tty_operations serial_ops 
 int __init zs_init(void)
 {
 	int channel, i;
-	unsigned long flags;
 	struct dec_serial *info;
 
 	if(!BUS_PRESENT)
@@ -1809,7 +1781,6 @@ int __init zs_init(void)
 	/* Find out how many Z8530 SCCs we have */
 	if (zs_chain == 0)
 		probe_sccs();
-
 	serial_driver = alloc_tty_driver(zs_channels_found);
 	if (!serial_driver)
 		return -ENOMEM;
@@ -1833,39 +1804,25 @@ int __init zs_init(void)
 	tty_set_operations(serial_driver, &serial_ops);
 
 	if (tty_register_driver(serial_driver))
-		panic("Couldn't register serial driver\n");
-
-	save_flags(flags); cli();
-
-	for (channel = 0; channel < zs_channels_found; ++channel) {
-		if (zs_soft[channel].hook &&
-		    zs_soft[channel].hook->init_channel)
-			(*zs_soft[channel].hook->init_channel)
-				(&zs_soft[channel]);
+		panic("Couldn't register serial driver");
 
-		zs_soft[channel].clk_divisor = 16;
-		zs_soft[channel].zs_baud = get_zsbaud(&zs_soft[channel]);
+	for (info = zs_chain, i = 0; info; info = info->zs_next, i++) {
 
-		if (request_irq(zs_parms->irq, rs_interrupt, SA_SHIRQ,
-				"SCC", &zs_soft[channel]))
-			printk(KERN_ERR "decserial: can't get irq %d\n",
-			       zs_parms->irq);
-	}
+		/* Needed before interrupts are enabled. */
+		info->tty = 0;
+		info->x_char = 0;
 
-	for (info = zs_chain, i = 0; info; info = info->zs_next, i++)
-	{
 		if (info->hook && info->hook->init_info) {
 			(*info->hook->init_info)(info);
 			continue;
 		}
+
 		info->magic = SERIAL_MAGIC;
 		info->port = (int) info->zs_channel->control;
 		info->line = i;
-		info->tty = 0;
 		info->custom_divisor = 16;
 		info->close_delay = 50;
 		info->closing_wait = 3000;
-		info->x_char = 0;
 		info->event = 0;
 		info->count = 0;
 		info->blocked_open = 0;
@@ -1873,94 +1830,83 @@ int __init zs_init(void)
 		info->tqueue.data = info;
 		init_waitqueue_head(&info->open_wait);
 		init_waitqueue_head(&info->close_wait);
-		printk("ttyS%d at 0x%08x (irq = %d)", info->line,
-		       info->port, info->irq);
-		printk(" is a Z85C30 SCC\n");
+		printk("ttyS%02d at 0x%08x (irq = %d) is a Z85C30 SCC\n",
+		       info->line, info->port, info->irq);
 		tty_register_device(serial_driver, info->line, NULL);
+
 	}
 
-	restore_flags(flags);
+	for (channel = 0; channel < zs_channels_found; ++channel) {
+		zs_soft[channel].clk_divisor = 16;
+		zs_soft[channel].zs_baud = get_zsbaud(&zs_soft[channel]);
 
-	return 0;
-}
+		if (request_irq(zs_soft[channel].irq, rs_interrupt, SA_SHIRQ,
+				"scc", &zs_soft[channel]))
+			printk(KERN_ERR "decserial: can't get irq %d\n",
+			       zs_soft[channel].irq);
 
-/*
- * register_serial and unregister_serial allows for serial ports to be
- * configured at run-time, to support PCMCIA modems.
- */
-/* PowerMac: Unused at this time, just here to make things link. */
-int register_serial(struct serial_struct *req)
-{
-	return -1;
-}
+		if (zs_soft[channel].hook) {
+			zs_startup(&zs_soft[channel]);
+			if (zs_soft[channel].hook->init_channel)
+				(*zs_soft[channel].hook->init_channel)
+					(&zs_soft[channel]);
+		}
+	}
 
-void unregister_serial(int line)
-{
-	return;
+	return 0;
 }
 
 /*
  * polling I/O routines
  */
 static int
-zs_poll_tx_char(struct dec_serial *info, unsigned char ch)
+zs_poll_tx_char(void *handle, unsigned char ch)
 {
+	struct dec_serial *info = handle;
 	struct dec_zschannel *chan = info->zs_channel;
 	int    ret;
 
 	if(chan) {
 		int loops = 10000;
-//		int nine = read_zsreg(chan, R9);
-
-		RECOVERY_DELAY;
-//        	write_zsreg(chan, R9, nine & ~MIE);
-               	wbflush();
-		RECOVERY_DELAY;
-
-        	while (!(*(chan->control) & Tx_BUF_EMP) && --loops)
-	        	RECOVERY_DELAY;
-
-                if (loops) {
-                        ret = 0;
-        	        *(chan->data) = ch;
-                	wbflush();
-			RECOVERY_DELAY;
-                } else
-                        ret = -EAGAIN;
 
-//        	write_zsreg(chan, R9, nine);
-               	wbflush();
-		RECOVERY_DELAY;
+		while (loops && !(read_zsreg(chan, 0) & Tx_BUF_EMP))
+			loops--;
 
-                return ret;
-        }
+		if (loops) {
+			write_zsdata(chan, ch);
+			ret = 0;
+		} else
+			ret = -EAGAIN;
 
-	return -ENODEV;
+		return ret;
+	} else
+		return -ENODEV;
 }
 
 static int
-zs_poll_rx_char(struct dec_serial *info)
+zs_poll_rx_char(void *handle)
 {
+	struct dec_serial *info = handle;
         struct dec_zschannel *chan = info->zs_channel;
         int    ret;
 
 	if(chan) {
                 int loops = 10000;
 
-                while((read_zsreg(chan, 0) & Rx_CH_AV) == 0)
-		        loops--;
+		while (loops && !(read_zsreg(chan, 0) & Rx_CH_AV))
+			loops--;
 
                 if (loops)
                         ret = read_zsdata(chan);
                 else
                         ret = -EAGAIN;
 
-                return ret;
-        } else
-                return -ENODEV;
+		return ret;
+	} else
+		return -ENODEV;
 }
 
-unsigned int register_zs_hook(unsigned int channel, struct zs_hook *hook)
+int register_zs_hook(unsigned int channel, struct dec_serial_hook *hook)
 {
 	struct dec_serial *info = &zs_soft[channel];
 
@@ -1970,22 +1916,15 @@ unsigned int register_zs_hook(unsigned i
 
 		return 0;
 	} else {
-		info->hook = hook;
-
-		if (zs_chain == 0)
-			probe_sccs();
-
-		if (!(info->flags & ZILOG_INITIALIZED))
-			zs_startup(info);
-
 		hook->poll_rx_char = zs_poll_rx_char;
 		hook->poll_tx_char = zs_poll_tx_char;
+		info->hook = hook;
 
 		return 1;
 	}
 }
 
-unsigned int unregister_zs_hook(unsigned int channel)
+int unregister_zs_hook(unsigned int channel)
 {
 	struct dec_serial *info = &zs_soft[channel];
 
@@ -2004,7 +1943,7 @@ unsigned int unregister_zs_hook(unsigned
  * Serial console driver
  * ------------------------------------------------------------
  */
-#ifdef CONFIG_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
 
 
 /*
@@ -2041,11 +1980,13 @@ static struct tty_driver *serial_console
 static int __init serial_console_setup(struct console *co, char *options)
 {
 	struct dec_serial *info;
-	int	baud = 9600;
-	int	bits = 8;
-	int	parity = 'n';
-	int	cflag = CREAD | HUPCL | CLOCAL;
-	char	*s;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int cflag = CREAD | HUPCL | CLOCAL;
+	int clk_divisor = 16;
+	int brg;
+	char *s;
 	unsigned long flags;
 
 	if(!BUS_PRESENT)
@@ -2097,6 +2038,10 @@ static int __init serial_console_setup(s
 	case 9600:
 	default:
 		cflag |= B9600;
+		/*
+		 * Set this to a sane value to prevent a divide error.
+		 */
+		baud  = 9600;
 		break;
 	}
 	switch(bits) {
@@ -2117,43 +2062,64 @@ static int __init serial_console_setup(s
 		break;
 	}
 	co->cflag = cflag;
-#if 1 
+
 	save_and_cli(flags);
 
 	/*
+	 * Set up the baud rate generator.
+	 */
+	brg = BPS_TO_BRG(baud, zs_parms->clock / clk_divisor);
+	info->zs_channel->curregs[R12] = (brg & 255);
+	info->zs_channel->curregs[R13] = ((brg >> 8) & 255);
+
+	/*
+	 * Set byte size and parity.
+	 */
+	if (bits == 7) {
+		info->zs_channel->curregs[R3] |= Rx7;
+		info->zs_channel->curregs[R5] |= Tx7;
+	} else {
+		info->zs_channel->curregs[R3] |= Rx8;
+		info->zs_channel->curregs[R5] |= Tx8;
+	}
+	if (cflag & PARENB) {
+		info->zs_channel->curregs[R4] |= PAR_ENA;
+	}
+	if (!(cflag & PARODD)) {
+		info->zs_channel->curregs[R4] |= PAR_EVEN;
+	}
+	info->zs_channel->curregs[R4] |= SB1;
+
+	/*
 	 * Turn on RTS and DTR.
 	 */
 	zs_rtsdtr(info, RTS | DTR, 1);
 
 	/*
-	 * Finally, enable sequencing
+	 * Finally, enable sequencing.
 	 */
-	info->zs_channel->curregs[3] |= (RxENABLE | Rx8);
-	info->zs_channel->curregs[5] |= (TxENAB | Tx8);
-	info->zs_channel->curregs[9] |= (VIS);
-	write_zsreg(info->zs_channel, 3, info->zs_channel->curregs[3]);
-	write_zsreg(info->zs_channel, 5, info->zs_channel->curregs[5]);
-	write_zsreg(info->zs_channel, 9, info->zs_channel->curregs[9]);
+	info->zs_channel->curregs[R3] |= RxENABLE;
+	info->zs_channel->curregs[R5] |= TxENAB;
 
 	/*
 	 * Clear the interrupt registers.
 	 */
-	write_zsreg(info->zs_channel, 0, ERR_RES);
-	write_zsreg(info->zs_channel, 0, RES_H_IUS);
+	write_zsreg(info->zs_channel, R0, ERR_RES);
+	write_zsreg(info->zs_channel, R0, RES_H_IUS);
 
 	/*
-	 * Set the speed of the serial port
+	 * Load up the new values.
 	 */
-	change_speed(info);
+	load_zsregs(info->zs_channel, info->zs_channel->curregs);
 
 	/* Save the current value of RR0 */
-	info->read_reg_zero = read_zsreg(info->zs_channel, 0);
+	info->read_reg_zero = read_zsreg(info->zs_channel, R0);
 
-	zs_soft[co->index].clk_divisor = 16;
+	zs_soft[co->index].clk_divisor = clk_divisor;
 	zs_soft[co->index].zs_baud = get_zsbaud(&zs_soft[co->index]);
 
 	restore_flags(flags);
-#endif
+
 	return 0;
 }
 
@@ -2173,7 +2139,7 @@ void __init zs_serial_console_init(void)
 {
 	register_console(&sercons);
 }
-#endif /* ifdef CONFIG_SERIAL_CONSOLE */
+#endif /* ifdef CONFIG_SERIAL_DEC_CONSOLE */
 
 #ifdef CONFIG_KGDB
 struct dec_zschannel *zs_kgdbchan;
@@ -2211,7 +2177,7 @@ void kgdb_interruptible(int yes)
 	int one, nine;
 	nine = read_zsreg(chan, 9);
 	if (yes == 1) {
-		one = EXT_INT_ENAB|INT_ALL_Rx;
+		one = EXT_INT_ENAB|RxINT_ALL;
 		nine |= MIE;
 		printk("turning serial ints on\n");
 	} else {
@@ -2223,22 +2189,23 @@ void kgdb_interruptible(int yes)
 	write_zsreg(chan, 9, nine);
 }
 
-static int kgdbhook_init_channel(struct dec_serial* info) 
+static int kgdbhook_init_channel(void *handle)
 {
 	return 0;
 }
 
-static void kgdbhook_init_info(struct dec_serial* info)
+static void kgdbhook_init_info(void *handle)
 {
 }
 
-static void kgdbhook_rx_char(struct dec_serial* info, 
-			     unsigned char ch, unsigned char stat)
+static void kgdbhook_rx_char(void *handle, unsigned char ch, unsigned char fl)
 {
+	struct dec_serial *info = handle;
+
+	if (fl != TTY_NORMAL)
+		return;
 	if (ch == 0x03 || ch == '$')
 		breakpoint();
-	if (stat & (Rx_OVR|FRM_ERR|PAR_ERR))
-		write_zsreg(info->zs_channel, 0, ERR_RES);
 }
 
 /* This sets up the serial port we're using, and turns on
@@ -2264,11 +2231,11 @@ static inline void kgdb_chaninit(struct 
  * for /dev/ttyb which is determined in setup_arch() from the
  * boot command line flags.
  */
-struct zs_hook zs_kgdbhook = {
-	init_channel : kgdbhook_init_channel,
-	init_info    : kgdbhook_init_info,
-	cflags       : B38400|CS8|CLOCAL,
-	rx_char      : kgdbhook_rx_char,
+struct dec_serial_hook zs_kgdbhook = {
+	.init_channel	= kgdbhook_init_channel,
+	.init_info	= kgdbhook_init_info,
+	.rx_char	= kgdbhook_rx_char,
+	.cflags		= B38400 | CS8 | CLOCAL,
 }
 
 void __init zs_kgdb_hook(int tty_num)
diff -purN linux-2.6.11-rc2-bk10/drivers/tc/zs.h linux-2.6.11-rc3/drivers/tc/zs.h
--- linux-2.6.11-rc2-bk10/drivers/tc/zs.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/drivers/tc/zs.h	2005-02-03 02:55:35.000000000 +0100
@@ -1,14 +1,18 @@
 /*
- * macserial.h: Definitions for the Macintosh Z8530 serial driver.
+ * drivers/tc/zs.h: Definitions for the DECstation Z85C30 serial driver.
  *
  * Adapted from drivers/sbus/char/sunserial.h by Paul Mackerras.
+ * Adapted from drivers/macintosh/macserial.h by Harald Koerfgen.
  *
  * Copyright (C) 1996 Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
+ * Copyright (C) 2004  Maciej W. Rozycki
  */
 #ifndef _DECSERIAL_H
 #define _DECSERIAL_H
 
+#include <asm/dec/serial.h>
+
 #define NUM_ZSREGS    16
 
 struct serial_struct {
@@ -89,61 +93,48 @@ struct dec_zschannel {
 	unsigned char curregs[NUM_ZSREGS];
 };
 
-struct dec_serial;
-
-struct zs_hook {
-	int (*init_channel)(struct dec_serial* info);
-	void (*init_info)(struct dec_serial* info);
-	void (*rx_char)(unsigned char ch, unsigned char stat);
-	int  (*poll_rx_char)(struct dec_serial* info);
-	int  (*poll_tx_char)(struct dec_serial* info,
-			     unsigned char ch);
-	unsigned cflags;
-};
-
 struct dec_serial {
-	struct dec_serial *zs_next;	/* For IRQ servicing chain */
-	struct dec_zschannel *zs_channel; /* Channel registers */
-	struct dec_zschannel *zs_chan_a;	/* A side registers */
-	unsigned char read_reg_zero;
-
-	char soft_carrier;  /* Use soft carrier on this channel */
-	char break_abort;   /* Is serial console in, so process brk/abrt */
-	struct zs_hook *hook;  /* Hook on this channel */
-	char is_cons;       /* Is this our console. */
-	unsigned char tx_active; /* character is being xmitted */
-	unsigned char tx_stopped; /* output is suspended */
-
-	/* We need to know the current clock divisor
-	 * to read the bps rate the chip has currently
-	 * loaded.
+	struct dec_serial	*zs_next;	/* For IRQ servicing chain.  */
+	struct dec_zschannel	*zs_channel;	/* Channel registers.  */
+	struct dec_zschannel	*zs_chan_a;	/* A side registers.  */
+	unsigned char		read_reg_zero;
+
+	struct dec_serial_hook	*hook;		/* Hook on this channel.  */
+	int			tty_break;	/* Set on BREAK condition.  */
+	int			is_cons;	/* Is this our console.  */
+	int			tx_active;	/* Char is being xmitted.  */
+	int			tx_stopped;	/* Output is suspended.  */
+
+	/*
+	 * We need to know the current clock divisor
+	 * to read the bps rate the chip has currently loaded.
 	 */
-	unsigned char clk_divisor;  /* May be 1, 16, 32, or 64 */
-	int zs_baud;
+	int			clk_divisor;	/* May be 1, 16, 32, or 64.  */
+	int			zs_baud;
 
-	char change_needed;
+	char			change_needed;
 
 	int			magic;
 	int			baud_base;
 	int			port;
 	int			irq;
-	int			flags; 		/* defined in tty.h */
-	int			type; 		/* UART type */
+	int			flags; 		/* Defined in tty.h.  */
+	int			type; 		/* UART type.  */
 	struct tty_struct 	*tty;
 	int			read_status_mask;
 	int			ignore_status_mask;
 	int			timeout;
 	int			xmit_fifo_size;
 	int			custom_divisor;
-	int			x_char;	/* xon/xoff character */
+	int			x_char;		/* XON/XOFF character.  */
 	int			close_delay;
 	unsigned short		closing_wait;
 	unsigned short		closing_wait2;
 	unsigned long		event;
 	unsigned long		last_active;
 	int			line;
-	int			count;	    /* # of fd on device */
-	int			blocked_open; /* # of blocked opens */
+	int			count;		/* # of fds on device.  */
+	int			blocked_open;	/* # of blocked opens.  */
 	unsigned char 		*xmit_buf;
 	int			xmit_head;
 	int			xmit_tail;
@@ -219,8 +210,9 @@ struct dec_serial {
 
 #define	RxINT_DISAB	0	/* Rx Int Disable */
 #define	RxINT_FCERR	0x8	/* Rx Int on First Character Only or Error */
-#define	INT_ALL_Rx	0x10	/* Int on all Rx Characters or error */
-#define	INT_ERR_Rx	0x18	/* Int on error only */
+#define	RxINT_ALL	0x10	/* Int on all Rx Characters or error */
+#define	RxINT_ERR	0x18	/* Int on error only */
+#define	RxINT_MASK	0x18
 
 #define	WT_RDY_RT	0x20	/* Wait/Ready on R/T */
 #define	WT_FN_RDYFN	0x40	/* Wait/FN/Ready FN */
diff -purN linux-2.6.11-rc2-bk10/drivers/usb/atm/speedtch.c linux-2.6.11-rc3/drivers/usb/atm/speedtch.c
--- linux-2.6.11-rc2-bk10/drivers/usb/atm/speedtch.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/drivers/usb/atm/speedtch.c	2005-02-03 02:57:17.000000000 +0100
@@ -494,7 +494,7 @@ static void speedtch_upload_firmware(str
 			dbg("speedtch_upload_firmware: write BLOCK1 to modem failed (%d)!", ret);
 			goto fail_release;
 		}
-		dbg("speedtch_upload_firmware: BLOCK1 uploaded (%d bytes)", fw1->size);
+		dbg("speedtch_upload_firmware: BLOCK1 uploaded (%zu bytes)", fw1->size);
 	}
 
 	/* USB led blinking green, ADSL led off */
@@ -522,7 +522,7 @@ static void speedtch_upload_firmware(str
 			goto fail_release;
 		}
 	}
-	dbg("speedtch_upload_firmware: BLOCK3 uploaded (%d bytes)", fw2->size);
+	dbg("speedtch_upload_firmware: BLOCK3 uploaded (%zu bytes)", fw2->size);
 
 	/* USB led static green, ADSL led static red */
 
diff -purN linux-2.6.11-rc2-bk10/drivers/usb/host/ehci-q.c linux-2.6.11-rc3/drivers/usb/host/ehci-q.c
--- linux-2.6.11-rc2-bk10/drivers/usb/host/ehci-q.c	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc3/drivers/usb/host/ehci-q.c	2005-02-03 02:56:33.000000000 +0100
@@ -986,13 +986,10 @@ static void start_unlink_async (struct e
 	struct ehci_qh	*prev;
 
 #ifdef DEBUG
+	assert_spin_locked(&ehci->lock);
 	if (ehci->reclaim
 			|| (qh->qh_state != QH_STATE_LINKED
 				&& qh->qh_state != QH_STATE_UNLINK_WAIT)
-#ifdef CONFIG_SMP
-// this macro lies except on SMP compiles
-			|| !spin_is_locked (&ehci->lock)
-#endif
 			)
 		BUG ();
 #endif
diff -purN linux-2.6.11-rc2-bk10/drivers/usb/host/ohci-au1xxx.c linux-2.6.11-rc3/drivers/usb/host/ohci-au1xxx.c
--- linux-2.6.11-rc2-bk10/drivers/usb/host/ohci-au1xxx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/usb/host/ohci-au1xxx.c	2005-02-03 02:55:15.000000000 +0100
@@ -0,0 +1,362 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ *
+ * Bus Glue for AMD Alchemy Au1xxx
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Rusell King et al.
+ *
+ * Modified for LH7A404 from ohci-sa1111.c
+ *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
+ * Modified for AMD Alchemy Au1xxx
+ *  by Matt Porter <mporter@kernel.crashing.org>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <asm/mach-au1x00/au1000.h>
+
+#define USBH_ENABLE_BE (1<<0)
+#define USBH_ENABLE_C  (1<<1)
+#define USBH_ENABLE_E  (1<<2)
+#define USBH_ENABLE_CE (1<<3)
+#define USBH_ENABLE_RD (1<<4)
+
+#ifdef __LITTLE_ENDIAN
+#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C)
+#elif __BIG_ENDIAN
+#define USBH_ENABLE_INIT (USBH_ENABLE_CE | USBH_ENABLE_E | USBH_ENABLE_C | USBH_ENABLE_BE)
+#else
+#error not byte order defined
+#endif
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+static void au1xxx_start_hc(struct platform_device *dev)
+{
+	printk(KERN_DEBUG __FILE__
+		": starting Au1xxx OHCI USB Controller\n");
+
+	/* enable host controller */
+	au_writel(USBH_ENABLE_CE, USB_HOST_CONFIG);
+	udelay(1000);
+	au_writel(USBH_ENABLE_INIT, USB_HOST_CONFIG);
+	udelay(1000);
+
+	/* wait for reset complete (read register twice; see au1500 errata) */
+	while (au_readl(USB_HOST_CONFIG),
+		!(au_readl(USB_HOST_CONFIG) & USBH_ENABLE_RD))
+		udelay(1000);
+
+	printk(KERN_DEBUG __FILE__
+	": Clock to USB host has been enabled \n");
+}
+
+static void au1xxx_stop_hc(struct platform_device *dev)
+{
+	printk(KERN_DEBUG __FILE__
+	       ": stopping Au1xxx OHCI USB Controller\n");
+
+	/* Disable clock */
+	au_writel(readl((void *)USB_HOST_CONFIG) & ~USBH_ENABLE_CE, USB_HOST_CONFIG);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+
+static irqreturn_t usb_hcd_au1xxx_hcim_irq (int irq, void *__hcd,
+					     struct pt_regs * r)
+{
+	struct usb_hcd *hcd = __hcd;
+
+	return usb_hcd_irq(irq, hcd, r);
+}
+
+/*-------------------------------------------------------------------------*/
+
+void usb_hcd_au1xxx_remove (struct usb_hcd *, struct platform_device *);
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_hcd_au1xxx_probe - initialize Au1xxx-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_hcd_au1xxx_probe (const struct hc_driver *driver,
+			  struct usb_hcd **hcd_out,
+			  struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd = 0;
+
+	unsigned int *addr = NULL;
+
+	if (!request_mem_region(dev->resource[0].start,
+				dev->resource[0].end
+				- dev->resource[0].start + 1, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		return -EBUSY;
+	}
+
+	au1xxx_start_hc(dev);
+
+	addr = ioremap(dev->resource[0].start,
+		       dev->resource[0].end
+		       - dev->resource[0].start + 1);
+	if (!addr) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	if(dev->resource[1].flags != IORESOURCE_IRQ) {
+		pr_debug ("resource[1] is not IORESOURCE_IRQ");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	hcd = usb_create_hcd(driver);
+	if (hcd == NULL) {
+		pr_debug ("usb_create_hcd failed");
+		retval = -ENOMEM;
+		goto err1;
+	}
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	hcd->irq = dev->resource[1].start;
+	hcd->regs = addr;
+	hcd->self.controller = &dev->dev;
+
+	retval = hcd_buffer_create (hcd);
+	if (retval != 0) {
+		pr_debug ("pool alloc fail");
+		goto err2;
+	}
+
+	retval = request_irq (hcd->irq, usb_hcd_au1xxx_hcim_irq, SA_INTERRUPT,
+			      hcd->driver->description, hcd);
+	if (retval != 0) {
+		pr_debug("request_irq failed");
+		retval = -EBUSY;
+		goto err3;
+	}
+
+	pr_debug ("%s (Au1xxx) at 0x%p, irq %d",
+	     hcd->driver->description, hcd->regs, hcd->irq);
+
+	hcd->self.bus_name = "au1xxx";
+
+	usb_register_bus (&hcd->self);
+
+	if ((retval = driver->start (hcd)) < 0)
+	{
+		usb_hcd_au1xxx_remove(hcd, dev);
+		printk("bad driver->start\n");
+		return retval;
+	}
+
+	*hcd_out = hcd;
+	return 0;
+
+ err3:
+	hcd_buffer_destroy (hcd);
+ err2:
+	usb_put_hcd(hcd);
+ err1:
+	au1xxx_stop_hc(dev);
+	release_mem_region(dev->resource[0].start,
+				dev->resource[0].end
+			   - dev->resource[0].start + 1);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_au1xxx_remove - shutdown processing for Au1xxx-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_au1xxx_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_hcd_au1xxx_remove (struct usb_hcd *hcd, struct platform_device *dev)
+{
+	pr_debug ("remove: %s, state %x", hcd->self.bus_name, hcd->state);
+
+	if (in_interrupt ())
+		BUG ();
+
+	hcd->state = USB_STATE_QUIESCING;
+
+	pr_debug ("%s: roothub graceful disconnect", hcd->self.bus_name);
+	usb_disconnect (&hcd->self.root_hub);
+
+	hcd->driver->stop (hcd);
+	hcd->state = USB_STATE_HALT;
+
+	free_irq (hcd->irq, hcd);
+	hcd_buffer_destroy (hcd);
+
+	usb_deregister_bus (&hcd->self);
+
+	au1xxx_stop_hc(dev);
+	release_mem_region(dev->resource[0].start,
+			   dev->resource[0].end
+			   - dev->resource[0].start + 1);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+ohci_au1xxx_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
+
+	ohci_dbg (ohci, "ohci_au1xxx_start, ohci:%p", ohci);
+
+	if ((ret = ohci_init (ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run (ohci)) < 0) {
+		err ("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_au1xxx_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"Au1xxx OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_au1xxx_start,
+#ifdef	CONFIG_PM
+	/* suspend:		ohci_au1xxx_suspend,  -- tbd */
+	/* resume:		ohci_au1xxx_resume,   -- tbd */
+#endif /*CONFIG_PM*/
+	.stop =			ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_au1xxx_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = NULL;
+	int ret;
+
+	pr_debug ("In ohci_hcd_au1xxx_drv_probe");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_hcd_au1xxx_probe(&ohci_au1xxx_hc_driver, &hcd, pdev);
+
+	if (ret == 0)
+		dev_set_drvdata(dev, hcd);
+
+	return ret;
+}
+
+static int ohci_hcd_au1xxx_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	usb_hcd_au1xxx_remove(hcd, pdev);
+	dev_set_drvdata(dev, NULL);
+	return 0;
+}
+	/*TBD*/
+/*static int ohci_hcd_au1xxx_drv_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	return 0;
+}
+static int ohci_hcd_au1xxx_drv_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	return 0;
+}
+*/
+
+static struct device_driver ohci_hcd_au1xxx_driver = {
+	.name		= "au1xxx-ohci",
+	.bus		= &platform_bus_type,
+	.probe		= ohci_hcd_au1xxx_drv_probe,
+	.remove		= ohci_hcd_au1xxx_drv_remove,
+	/*.suspend	= ohci_hcd_au1xxx_drv_suspend, */
+	/*.resume	= ohci_hcd_au1xxx_drv_resume, */
+};
+
+static int __init ohci_hcd_au1xxx_init (void)
+{
+	pr_debug (DRIVER_INFO " (Au1xxx)");
+	pr_debug ("block sizes: ed %d td %d\n",
+		sizeof (struct ed), sizeof (struct td));
+
+	return driver_register(&ohci_hcd_au1xxx_driver);
+}
+
+static void __exit ohci_hcd_au1xxx_cleanup (void)
+{
+	driver_unregister(&ohci_hcd_au1xxx_driver);
+}
+
+module_init (ohci_hcd_au1xxx_init);
+module_exit (ohci_hcd_au1xxx_cleanup);
diff -purN linux-2.6.11-rc2-bk10/drivers/usb/host/ohci-hcd.c linux-2.6.11-rc3/drivers/usb/host/ohci-hcd.c
--- linux-2.6.11-rc2-bk10/drivers/usb/host/ohci-hcd.c	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/usb/host/ohci-hcd.c	2005-02-03 02:55:07.000000000 +0100
@@ -897,11 +897,16 @@ MODULE_LICENSE ("GPL");
 #include "ohci-pxa27x.c"
 #endif
 
+#ifdef CONFIG_SOC_AU1X00
+#include "ohci-au1xxx.c"
+#endif
+
 #if !(defined(CONFIG_PCI) \
       || defined(CONFIG_SA1111) \
       || defined(CONFIG_ARCH_OMAP) \
       || defined (CONFIG_ARCH_LH7A404) \
       || defined (CONFIG_PXA27x) \
+      || defined (CONFIG_SOC_AU1X00) \
 	)
 #error "missing bus glue for ohci-hcd"
 #endif
diff -purN linux-2.6.11-rc2-bk10/drivers/usb/input/hid-debug.h linux-2.6.11-rc3/drivers/usb/input/hid-debug.h
--- linux-2.6.11-rc2-bk10/drivers/usb/input/hid-debug.h	2005-02-03 10:03:09.845502972 +0100
+++ linux-2.6.11-rc3/drivers/usb/input/hid-debug.h	2005-02-03 02:55:53.000000000 +0100
@@ -86,12 +86,12 @@ static const struct hid_usage_entry hid_
       {0, 0x92, "D-PadRight"},
       {0, 0x93, "D-PadLeft"},
   {  7, 0, "Keyboard" },
+  {  8, 0, "LED" },
       {0, 0x01, "NumLock"},
       {0, 0x02, "CapsLock"},
       {0, 0x03, "ScrollLock"},
       {0, 0x04, "Compose"},
       {0, 0x05, "Kana"},
-  {  8, 0, "LED" },
   {  9, 0, "Button" },
   { 10, 0, "Ordinal" },
   { 12, 0, "Consumer" },
diff -purN linux-2.6.11-rc2-bk10/drivers/usb/input/hid-input.c linux-2.6.11-rc3/drivers/usb/input/hid-input.c
--- linux-2.6.11-rc2-bk10/drivers/usb/input/hid-input.c	2005-02-03 10:03:09.847502661 +0100
+++ linux-2.6.11-rc3/drivers/usb/input/hid-input.c	2005-02-03 02:55:50.000000000 +0100
@@ -185,9 +185,9 @@ static void hidinput_configure_usage(str
 			break;
 
 		case HID_UP_LED:
-			if (usage->hid - 1 >= LED_MAX)
+			if (((usage->hid - 1) & 0xffff) >= LED_MAX)
 				goto ignore;
-			map_led(usage->hid - 1);
+			map_led((usage->hid - 1) & 0xffff);
 			break;
 
 		case HID_UP_DIGITIZER:
@@ -492,6 +492,9 @@ static int hidinput_input_event(struct i
 	if (type == EV_FF)
 		return hid_ff_event(hid, dev, type, code, value);
 
+	if (type != EV_LED)
+		return -1;
+
 	if ((offset = hid_find_field(hid, type, code, &field)) == -1) {
 		warn("event field not found");
 		return -1;
diff -purN linux-2.6.11-rc2-bk10/drivers/usb/misc/idmouse.c linux-2.6.11-rc3/drivers/usb/misc/idmouse.c
--- linux-2.6.11-rc2-bk10/drivers/usb/misc/idmouse.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/drivers/usb/misc/idmouse.c	2005-02-03 02:55:23.000000000 +0100
@@ -296,7 +296,8 @@ static ssize_t idmouse_read(struct file 
 		return 0;
 	}
 
-	count = min ((loff_t)count, IMGSIZE - (*ppos));
+	if (count > IMGSIZE - *ppos)
+		count = IMGSIZE - *ppos;
 
 	if (copy_to_user (buffer, dev->bulk_in_buffer + *ppos, count)) {
 		result = -EFAULT;
diff -purN linux-2.6.11-rc2-bk10/drivers/video/Kconfig linux-2.6.11-rc3/drivers/video/Kconfig
--- linux-2.6.11-rc2-bk10/drivers/video/Kconfig	2005-02-03 10:03:09.852501883 +0100
+++ linux-2.6.11-rc3/drivers/video/Kconfig	2005-02-03 02:54:59.000000000 +0100
@@ -919,6 +919,42 @@ config FB_PM3
 	  similar boards, 3DLabs Permedia3 Create!, Appian Jeronimo 2000
 	  and maybe other boards.
 
+config FB_E1356
+	tristate "Epson SED1356 framebuffer support"
+	depends on FB && EXPERIMENTAL && PCI && MIPS
+
+config PB1000_CRT
+	bool "Use CRT on Pb1000 (J65)"
+	depends on MIPS_PB1000=y && FB_E1356
+
+config PB1000_NTSC
+	bool "Use Compsite NTSC on Pb1000 (J63)"
+	depends on MIPS_PB1000=y && FB_E1356
+
+config PB1000_TFT
+	bool "Use TFT Panel on Pb1000 (J64)"
+	depends on MIPS_PB1000=y && FB_E1356
+
+config PB1500_CRT
+	bool "Use CRT on Pb1500 " if MIPS_PB1500=y
+	depends on FB_E1356
+
+config PB1500_CRT
+	prompt "Use CRT on Pb1100 "
+	depends on FB_E1356 && MIPS_PB1100=y
+
+config PB1500_TFT
+	bool "Use TFT Panel on Pb1500 " if MIPS_PB1500=y
+	depends on FB_E1356
+
+config PB1500_TFT
+	prompt "Use TFT Panel on Pb1100 "
+	depends on FB_E1356 && MIPS_PB1100=y
+
+config FB_AU1100
+	bool "Au1100 LCD Driver"
+	depends on FB && EXPERIMENTAL && PCI && MIPS && MIPS_PB1100=y
+
 config FB_SBUS
 	bool "SBUS and UPA framebuffers"
 	depends on FB && (SPARC32 || SPARC64)
@@ -978,29 +1014,35 @@ config FB_HIT
 	  This is the frame buffer device driver for the Hitachi HD64461 LCD
 	  frame buffer card.
 
+config FB_PMAG_AA
+	bool "PMAG-AA TURBOchannel framebuffer support"
+	depends on FB && MACH_DECSTATION && TC
+	help
+	  Support for the PMAG-AA TURBOchannel framebuffer card (1280x1024x1)
+	  used mainly in the MIPS-based DECstation series.
+
 config FB_PMAG_BA
 	bool "PMAG-BA TURBOchannel framebuffer support"
-	depends on FB && DECSTATION && TC
+	depends on FB && MACH_DECSTATION && TC
 	help
-	  Say Y here to directly support the on-board PMAG-BA framebuffer in
-	  the 5000/1xx versions of the DECstation.  There is a page dedicated
-	  to Linux on DECstations at <http://decstation.unix-ag.org/>.
+	  Support for the PMAG-BA TURBOchannel framebuffer card (1024x864x8)
+	  used mainly in the MIPS-based DECstation series.
 
 config FB_PMAGB_B
-	bool "PMAGB-B TURBOchannel framebuffer spport"
-	depends on FB && DECSTATION && TC
+	bool "PMAGB-B TURBOchannel framebuffer support"
+	depends on FB && MACH_DECSTATION && TC
 	help
-	  Say Y here to directly support the on-board PMAGB-B framebuffer in
-	  the 5000/1xx versions of the DECstation.  There is a page dedicated
-	  to Linux on DECstations at <http://decstation.unix-ag.org/>.
+	  Support for the PMAGB-B TURBOchannel framebuffer card used mainly
+	  in the MIPS-based DECstation series. The card is currently only
+	  supported in 1280x1024x8 mode.
 
 config FB_MAXINE
-	bool "Maxine (Personal DECstation) onboard framebuffer spport"
-	depends on FB && DECSTATION && TC
+	bool "Maxine (Personal DECstation) onboard framebuffer support"
+	depends on FB && MACH_DECSTATION && TC
 	help
-	  Say Y here to directly support the on-board framebuffer in the
-	  Maxine (5000/20, /25, /33) version of the DECstation.  There is a
-	  page dedicated to Linux on DECstations at <http://decstation.unix-ag.org/>.
+	  Support for the onboard framebuffer (1024x768x8) in the Personal
+	  DECstation series (Personal DECstation 5000/20, /25, /33, /50,
+	  Codename "Maxine").
 
 config FB_TX3912
 	bool "TMPTX3912/PR31700 frame buffer support"
@@ -1011,6 +1053,13 @@ config FB_TX3912
 
 	  Say Y here to enable kernel support for the on-board framebuffer.
 
+config FB_G364
+	bool
+	depends on MIPS_MAGNUM_4000 || OLIVETTI_M700
+	help
+	  The G364 driver is the framebuffer used in MIPS Magnum 4000 and
+	  Olivetti M700-10 systems.
+
 config FB_68328
 	bool "Motorola 68328 native frame buffer support"
 	depends on (M68328 || M68EZ328 || M68VZ328)
diff -purN linux-2.6.11-rc2-bk10/drivers/video/Makefile linux-2.6.11-rc3/drivers/video/Makefile
--- linux-2.6.11-rc2-bk10/drivers/video/Makefile	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/Makefile	2005-02-03 02:55:07.000000000 +0100
@@ -82,12 +82,8 @@ obj-$(CONFIG_FB_G364)             += g36
 obj-$(CONFIG_FB_SA1100)           += sa1100fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_SUN3)             += sun3fb.o
 obj-$(CONFIG_FB_HIT)              += hitfb.o cfbfillrect.o cfbimgblt.o
-obj-$(CONFIG_FB_TX3912)           += tx3912fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_EPSON1355)	  += epson1355fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_PVR2)             += pvr2fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
-obj-$(CONFIG_FB_PMAG_BA)          += pmag-ba-fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
-obj-$(CONFIG_FB_PMAGB_B)          += pmagb-b-fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
-obj-$(CONFIG_FB_MAXINE)           += maxinefb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_VOODOO1)          += sstfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_ARMCLCD)	  += amba-clcd.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_68328)            += 68328fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
@@ -96,6 +92,12 @@ obj-$(CONFIG_FB_CIRRUS)		  += cirrusfb.o
 obj-$(CONFIG_FB_ASILIANT)	  += asiliantfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_PXA)		  += pxafb.o cfbimgblt.o cfbcopyarea.o cfbfillrect.o
 obj-$(CONFIG_FB_W100)		   += w100fb.o cfbimgblt.o cfbcopyarea.o cfbfillrect.o
+obj-$(CONFIG_FB_AU1100)		  += au1100fb.o fbgen.o
+obj-$(CONFIG_FB_PMAG_AA)	  += pmag-aa-fb.o  cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_PMAG_BA)	  += pmag-ba-fb.o  cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_PMAGB_B)	  += pmagb-b-fb.o  cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_MAXINE)		  += maxinefb.o  cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_TX3912)		  += tx3912fb.o  cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_VESA)             += vesafb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
diff -purN linux-2.6.11-rc2-bk10/drivers/video/au1100fb.c linux-2.6.11-rc3/drivers/video/au1100fb.c
--- linux-2.6.11-rc2-bk10/drivers/video/au1100fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/au1100fb.c	2005-02-03 02:55:07.000000000 +0100
@@ -0,0 +1,676 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1100 LCD Driver.
+ *
+ * Copyright 2002 MontaVista Software
+ * Author: MontaVista Software, Inc.
+ *		ppopov@mvista.com or source@mvista.com
+ *
+ * Copyright 2002 Alchemy Semiconductor
+ * Author: Alchemy Semiconductor
+ *
+ * Based on:
+ * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device
+ *  Created 28 Dec 1997 by Geert Uytterhoeven
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+
+#include <asm/au1000.h>
+#include <asm/pb1100.h>
+#include "au1100fb.h"
+
+#include <video/fbcon.h>
+#include <video/fbcon-mfb.h>
+#include <video/fbcon-cfb2.h>
+#include <video/fbcon-cfb4.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+
+/*
+ * Sanity check. If this is a new Au1100 based board, search for
+ * the PB1100 ifdefs to make sure you modify the code accordingly.
+ */
+#if defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_HYDROGEN3)
+#else
+error Unknown Au1100 board
+#endif
+
+#define CMAPSIZE 16
+
+static int my_lcd_index; /* default is zero */
+struct known_lcd_panels *p_lcd;
+AU1100_LCD *p_lcd_reg = (AU1100_LCD *)AU1100_LCD_ADDR;
+
+struct au1100fb_info {
+	struct fb_info_gen gen;
+	unsigned long fb_virt_start;
+	unsigned long fb_size;
+	unsigned long fb_phys;
+	int mmaped;
+	int nohwcursor;
+
+	struct { unsigned red, green, blue, pad; } palette[256];
+
+#if defined(FBCON_HAS_CFB16)
+	u16 fbcon_cmap16[16];
+#endif
+};
+
+
+struct au1100fb_par {
+        struct fb_var_screeninfo var;
+
+	int line_length;  // in bytes
+	int cmap_len;     // color-map length
+};
+
+
+static struct au1100fb_info fb_info;
+static struct au1100fb_par current_par;
+static struct display disp;
+
+int au1100fb_init(void);
+void au1100fb_setup(char *options, int *ints);
+static int au1100fb_mmap(struct fb_info *fb, struct file *file,
+		struct vm_area_struct *vma);
+static int au1100_blank(int blank_mode, struct fb_info_gen *info);
+static int au1100fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
+			  u_long arg, int con, struct fb_info *info);
+
+void au1100_nocursor(struct display *p, int mode, int xx, int yy){};
+
+static struct fb_ops au1100fb_ops = {
+	owner:		THIS_MODULE,
+	fb_get_fix:	fbgen_get_fix,
+	fb_get_var:	fbgen_get_var,
+	fb_set_var:	fbgen_set_var,
+	fb_get_cmap:	fbgen_get_cmap,
+	fb_set_cmap:	fbgen_set_cmap,
+	fb_pan_display: fbgen_pan_display,
+        fb_ioctl:       au1100fb_ioctl,
+	fb_mmap:        au1100fb_mmap,
+};
+
+static void au1100_detect(void)
+{
+	/*
+	 *  This function should detect the current video mode settings
+	 *  and store it as the default video mode
+	 */
+
+	/*
+	 * Yeh, well, we're not going to change any settings so we're
+	 * always stuck with the default ...
+	 */
+
+}
+
+static int au1100_encode_fix(struct fb_fix_screeninfo *fix,
+		const void *_par, struct fb_info_gen *_info)
+{
+        struct au1100fb_info *info = (struct au1100fb_info *) _info;
+        struct au1100fb_par *par = (struct au1100fb_par *) _par;
+	struct fb_var_screeninfo *var = &par->var;
+
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+
+	fix->smem_start = info->fb_phys;
+	fix->smem_len = info->fb_size;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux = 0;
+        fix->visual = (var->bits_per_pixel == 8) ?
+	       	FB_VISUAL_PSEUDOCOLOR	: FB_VISUAL_TRUECOLOR;
+	fix->ywrapstep = 0;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+	fix->line_length = current_par.line_length;
+	return 0;
+}
+
+static void set_color_bitfields(struct fb_var_screeninfo *var)
+{
+	switch (var->bits_per_pixel) {
+	case 8:
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 0;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 16:	/* RGB 565 */
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	}
+
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+}
+
+static int au1100_decode_var(const struct fb_var_screeninfo *var,
+		void *_par, struct fb_info_gen *_info)
+{
+
+	struct au1100fb_par *par = (struct au1100fb_par *)_par;
+
+	/*
+	 * Don't allow setting any of these yet: xres and yres don't
+	 * make sense for LCD panels.
+	 */
+	if (var->xres != p_lcd->xres ||
+	    var->yres != p_lcd->yres ||
+	    var->xres != p_lcd->xres ||
+	    var->yres != p_lcd->yres) {
+		return -EINVAL;
+	}
+	if(var->bits_per_pixel != p_lcd->bpp) {
+		return -EINVAL;
+	}
+
+	memset(par, 0, sizeof(struct au1100fb_par));
+	par->var = *var;
+
+	/* FIXME */
+	switch (var->bits_per_pixel) {
+		case 8:
+			par->var.bits_per_pixel = 8;
+			break;
+		case 16:
+			par->var.bits_per_pixel = 16;
+			break;
+		default:
+			printk("color depth %d bpp not supported\n",
+					var->bits_per_pixel);
+			return -EINVAL;
+
+	}
+	set_color_bitfields(&par->var);
+	par->cmap_len = (par->var.bits_per_pixel == 8) ? 256 : 16;
+	return 0;
+}
+
+static int au1100_encode_var(struct fb_var_screeninfo *var,
+		const void *par, struct fb_info_gen *_info)
+{
+
+	*var = ((struct au1100fb_par *)par)->var;
+	return 0;
+}
+
+static void
+au1100_get_par(void *_par, struct fb_info_gen *_info)
+{
+	*(struct au1100fb_par *)_par = current_par;
+}
+
+static void au1100_set_par(const void *par, struct fb_info_gen *info)
+{
+	/* nothing to do: we don't change any settings */
+}
+
+static int au1100_getcolreg(unsigned regno, unsigned *red, unsigned *green,
+			 unsigned *blue, unsigned *transp,
+			 struct fb_info *info)
+{
+
+	struct au1100fb_info* i = (struct au1100fb_info*)info;
+
+	if (regno > 255)
+		return 1;
+
+	*red    = i->palette[regno].red;
+	*green  = i->palette[regno].green;
+	*blue   = i->palette[regno].blue;
+	*transp = 0;
+
+	return 0;
+}
+
+static int au1100_setcolreg(unsigned regno, unsigned red, unsigned green,
+			 unsigned blue, unsigned transp,
+			 struct fb_info *info)
+{
+	struct au1100fb_info* i = (struct au1100fb_info *)info;
+	u32 rgbcol;
+
+	if (regno > 255)
+		return 1;
+
+	i->palette[regno].red    = red;
+	i->palette[regno].green  = green;
+	i->palette[regno].blue   = blue;
+
+	switch(p_lcd->bpp) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		red >>= 10;
+		green >>= 10;
+		blue >>= 10;
+		p_lcd_reg->lcd_pallettebase[regno] = (blue&0x1f) |
+			((green&0x3f)<<5) | ((red&0x1f)<<11);
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+	case 16:
+		i->fbcon_cmap16[regno] =
+			((red & 0xf800) >> 0) |
+			((green & 0xfc00) >> 5) |
+			((blue & 0xf800) >> 11);
+		break;
+#endif
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+static int  au1100_blank(int blank_mode, struct fb_info_gen *_info)
+{
+
+	switch (blank_mode) {
+	case VESA_NO_BLANKING:
+		/* turn on panel */
+		//printk("turn on panel\n");
+#ifdef CONFIG_MIPS_PB1100
+		p_lcd_reg->lcd_control |= LCD_CONTROL_GO;
+		au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight,
+			PB1100_G_CONTROL);
+#endif
+#ifdef CONFIG_MIPS_HYDROGEN3
+		/*  Turn controller & power supply on,  GPIO213 */
+		au_writel(0x20002000, 0xB1700008);
+		au_writel(0x00040000, 0xB1900108);
+		au_writel(0x01000100, 0xB1700008);
+#endif
+		au_sync();
+		break;
+
+	case VESA_VSYNC_SUSPEND:
+	case VESA_HSYNC_SUSPEND:
+	case VESA_POWERDOWN:
+		/* turn off panel */
+		//printk("turn off panel\n");
+#ifdef CONFIG_MIPS_PB1100
+		au_writew(au_readw(PB1100_G_CONTROL) & ~p_lcd->mode_backlight,
+			PB1100_G_CONTROL);
+		p_lcd_reg->lcd_control &= ~LCD_CONTROL_GO;
+#endif
+		au_sync();
+		break;
+	default:
+		break;
+
+	}
+	return 0;
+}
+
+static void au1100_set_disp(const void *unused, struct display *disp,
+			 struct fb_info_gen *info)
+{
+	disp->screen_base = (char *)fb_info.fb_virt_start;
+
+	switch (disp->var.bits_per_pixel) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		disp->dispsw = &fbcon_cfb8;
+		if (fb_info.nohwcursor)
+			fbcon_cfb8.cursor = au1100_nocursor;
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+	case 16:
+		disp->dispsw = &fbcon_cfb16;
+		disp->dispsw_data = fb_info.fbcon_cmap16;
+		if (fb_info.nohwcursor)
+			fbcon_cfb16.cursor = au1100_nocursor;
+		break;
+#endif
+	default:
+		disp->dispsw = &fbcon_dummy;
+		disp->dispsw_data = NULL;
+		break;
+	}
+}
+
+static int
+au1100fb_mmap(struct fb_info *_fb,
+	     struct file *file,
+	     struct vm_area_struct *vma)
+{
+	unsigned int len;
+	unsigned long start=0, off;
+	struct au1100fb_info *fb = (struct au1100fb_info *)_fb;
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
+		return -EINVAL;
+	}
+
+	start = fb_info.fb_phys & PAGE_MASK;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + fb_info.fb_size);
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	if ((vma->vm_end - vma->vm_start + off) > len) {
+		return -EINVAL;
+	}
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
+	//pgprot_val(vma->vm_page_prot) |= _CACHE_CACHABLE_NONCOHERENT;
+	pgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6
+
+	/* This is an IO map - tell maydump to skip this VMA */
+	vma->vm_flags |= VM_IO;
+
+	if (io_remap_page_range(vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+
+	fb->mmaped = 1;
+	return 0;
+}
+
+int au1100_pan_display(const struct fb_var_screeninfo *var,
+		       struct fb_info_gen *info)
+{
+	return 0;
+}
+
+static int au1100fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
+			  u_long arg, int con, struct fb_info *info)
+{
+	/* nothing to do yet */
+	return -EINVAL;
+}
+
+static struct fbgen_hwswitch au1100_switch = {
+	au1100_detect,
+	au1100_encode_fix,
+	au1100_decode_var,
+	au1100_encode_var,
+	au1100_get_par,
+	au1100_set_par,
+	au1100_getcolreg,
+	au1100_setcolreg,
+	au1100_pan_display,
+	au1100_blank,
+	au1100_set_disp
+};
+
+
+int au1100_setmode(void)
+{
+	int words;
+
+	/* FIXME Need to accomodate for swivel mode and 12bpp, <8bpp*/
+	switch (p_lcd->mode_control & LCD_CONTROL_SM)
+	{
+		case LCD_CONTROL_SM_0:
+		case LCD_CONTROL_SM_180:
+		words = (p_lcd->xres * p_lcd->yres * p_lcd->bpp) / 32;
+			break;
+		case LCD_CONTROL_SM_90:
+		case LCD_CONTROL_SM_270:
+			/* is this correct? */
+		words = (p_lcd->xres * p_lcd->bpp) / 8;
+			break;
+		default:
+			printk("mode_control reg not initialized\n");
+			return -EINVAL;
+	}
+
+	/*
+	 * Setup LCD controller
+	 */
+
+	p_lcd_reg->lcd_control = p_lcd->mode_control;
+	p_lcd_reg->lcd_intstatus = 0;
+	p_lcd_reg->lcd_intenable = 0;
+	p_lcd_reg->lcd_horztiming = p_lcd->mode_horztiming;
+	p_lcd_reg->lcd_verttiming = p_lcd->mode_verttiming;
+	p_lcd_reg->lcd_clkcontrol = p_lcd->mode_clkcontrol;
+	p_lcd_reg->lcd_words = words - 1;
+	p_lcd_reg->lcd_dmaaddr0 = fb_info.fb_phys;
+
+	/* turn on panel */
+#ifdef CONFIG_MIPS_PB1100
+	au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight,
+			PB1100_G_CONTROL);
+#endif
+#ifdef CONFIG_MIPS_HYDROGEN3
+	/*  Turn controller & power supply on,  GPIO213 */
+	au_writel(0x20002000, 0xB1700008);
+	au_writel(0x00040000, 0xB1900108);
+	au_writel(0x01000100, 0xB1700008);
+#endif
+
+	p_lcd_reg->lcd_control |= LCD_CONTROL_GO;
+
+	return 0;
+}
+
+
+int __init au1100fb_init(void)
+{
+	uint32 sys_clksrc;
+	unsigned long page;
+
+	/*
+	* Get the panel information/display mode and update the registry
+	*/
+	p_lcd = &panels[my_lcd_index];
+
+	switch (p_lcd->mode_control & LCD_CONTROL_SM)
+	{
+		case LCD_CONTROL_SM_0:
+		case LCD_CONTROL_SM_180:
+		p_lcd->xres =
+			(p_lcd->mode_horztiming & LCD_HORZTIMING_PPL) + 1;
+		p_lcd->yres =
+			(p_lcd->mode_verttiming & LCD_VERTTIMING_LPP) + 1;
+			break;
+		case LCD_CONTROL_SM_90:
+		case LCD_CONTROL_SM_270:
+		p_lcd->yres =
+			(p_lcd->mode_horztiming & LCD_HORZTIMING_PPL) + 1;
+		p_lcd->xres =
+			(p_lcd->mode_verttiming & LCD_VERTTIMING_LPP) + 1;
+			break;
+	}
+
+	/*
+	 * Panel dimensions x bpp must be divisible by 32
+	 */
+	if (((p_lcd->yres * p_lcd->bpp) % 32) != 0)
+		printk("VERT %% 32\n");
+	if (((p_lcd->xres * p_lcd->bpp) % 32) != 0)
+		printk("HORZ %% 32\n");
+
+	/*
+	 * Allocate LCD framebuffer from system memory
+	 */
+	fb_info.fb_size = (p_lcd->xres * p_lcd->yres * p_lcd->bpp) / 8;
+
+	current_par.var.xres = p_lcd->xres;
+	current_par.var.xres_virtual = p_lcd->xres;
+	current_par.var.yres = p_lcd->yres;
+	current_par.var.yres_virtual = p_lcd->yres;
+	current_par.var.bits_per_pixel = p_lcd->bpp;
+
+	/* FIX!!! only works for 8/16 bpp */
+	current_par.line_length = p_lcd->xres * p_lcd->bpp / 8; /* in bytes */
+	fb_info.fb_virt_start = (unsigned long )
+		__get_free_pages(GFP_ATOMIC | GFP_DMA,
+				get_order(fb_info.fb_size + 0x1000));
+	if (!fb_info.fb_virt_start) {
+		printk("Unable to allocate fb memory\n");
+		return -ENOMEM;
+	}
+	fb_info.fb_phys = virt_to_bus((void *)fb_info.fb_virt_start);
+
+	/*
+	 * Set page reserved so that mmap will work. This is necessary
+	 * since we'll be remapping normal memory.
+	 */
+	for (page = fb_info.fb_virt_start;
+	     page < PAGE_ALIGN(fb_info.fb_virt_start + fb_info.fb_size);
+	     page += PAGE_SIZE) {
+		SetPageReserved(virt_to_page(page));
+	}
+
+	memset((void *)fb_info.fb_virt_start, 0, fb_info.fb_size);
+
+	/* set freqctrl now to allow more time to stabilize */
+	/* zero-out out LCD bits */
+	sys_clksrc = au_readl(SYS_CLKSRC) & ~0x000003e0;
+	sys_clksrc |= p_lcd->mode_toyclksrc;
+	au_writel(sys_clksrc, SYS_CLKSRC);
+
+	/* FIXME add check to make sure auxpll is what is expected! */
+	au1100_setmode();
+
+	fb_info.gen.parsize = sizeof(struct au1100fb_par);
+	fb_info.gen.fbhw = &au1100_switch;
+
+	strcpy(fb_info.gen.info.modename, "Au1100 LCD");
+	fb_info.gen.info.changevar = NULL;
+	fb_info.gen.info.node = -1;
+
+	fb_info.gen.info.fbops = &au1100fb_ops;
+	fb_info.gen.info.disp = &disp;
+	fb_info.gen.info.switch_con = &fbgen_switch;
+	fb_info.gen.info.updatevar = &fbgen_update_var;
+	fb_info.gen.info.blank = &fbgen_blank;
+	fb_info.gen.info.flags = FBINFO_FLAG_DEFAULT;
+
+	/* This should give a reasonable default video mode */
+	fbgen_get_var(&disp.var, -1, &fb_info.gen.info);
+	fbgen_do_set_var(&disp.var, 1, &fb_info.gen);
+	fbgen_set_disp(-1, &fb_info.gen);
+	fbgen_install_cmap(0, &fb_info.gen);
+	if (register_framebuffer(&fb_info.gen.info) < 0)
+		return -EINVAL;
+	printk(KERN_INFO "fb%d: %s frame buffer device\n",
+			GET_FB_IDX(fb_info.gen.info.node),
+			fb_info.gen.info.modename);
+
+	return 0;
+}
+
+
+void au1100fb_cleanup(struct fb_info *info)
+{
+	unregister_framebuffer(info);
+}
+
+
+void au1100fb_setup(char *options, int *ints)
+{
+	char* this_opt;
+	int i;
+	int num_panels = sizeof(panels)/sizeof(struct known_lcd_panels);
+
+
+	if (!options || !*options)
+		return;
+
+	for(this_opt=strtok(options, ","); this_opt;
+	    this_opt=strtok(NULL, ",")) {
+		if (!strncmp(this_opt, "panel:", 6)) {
+#if defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_DB1100)
+			/* Read Pb1100 Switch S10 ? */
+			if (!strncmp(this_opt+6, "s10", 3))
+			{
+				int panel;
+				panel = *(volatile int *)0xAE000008; /* BCSR SWITCHES */
+				panel >>= 8;
+				panel &= 0x0F;
+				if (panel >= num_panels) panel = 0;
+				my_lcd_index = panel;
+			}
+			else
+#endif
+			/* Get the panel name, everything else if fixed */
+			for (i=0; i<num_panels; i++) {
+				if (!strncmp(this_opt+6, panels[i].panel_name,
+							strlen(this_opt))) {
+					my_lcd_index = i;
+					break;
+				}
+			}
+		}
+		else if (!strncmp(this_opt, "nohwcursor", 10)) {
+			printk("nohwcursor\n");
+			fb_info.nohwcursor = 1;
+		}
+	}
+
+	printk("au1100fb: Panel %d %s\n", my_lcd_index,
+		panels[my_lcd_index].panel_name);
+}
+
+
+
+#ifdef MODULE
+MODULE_LICENSE("GPL");
+int init_module(void)
+{
+	return au1100fb_init();
+}
+
+void cleanup_module(void)
+{
+	au1100fb_cleanup(void);
+}
+
+MODULE_AUTHOR("Pete Popov <ppopov@mvista.com>");
+MODULE_DESCRIPTION("Au1100 LCD framebuffer device driver");
+#endif /* MODULE */
diff -purN linux-2.6.11-rc2-bk10/drivers/video/au1100fb.h linux-2.6.11-rc3/drivers/video/au1100fb.h
--- linux-2.6.11-rc2-bk10/drivers/video/au1100fb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/au1100fb.h	2005-02-03 02:55:15.000000000 +0100
@@ -0,0 +1,381 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Hardware definitions for the Au1100 LCD controller
+ *
+ * Copyright 2002 MontaVista Software
+ * Copyright 2002 Alchemy Semiconductor
+ * Author:	Alchemy Semiconductor, MontaVista Software
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AU1100LCD_H
+#define _AU1100LCD_H
+
+/********************************************************************/
+#define uint32 unsigned long
+typedef volatile struct
+{
+	uint32	lcd_control;
+	uint32	lcd_intstatus;
+	uint32	lcd_intenable;
+	uint32	lcd_horztiming;
+	uint32	lcd_verttiming;
+	uint32	lcd_clkcontrol;
+	uint32	lcd_dmaaddr0;
+	uint32	lcd_dmaaddr1;
+	uint32	lcd_words;
+	uint32	lcd_pwmdiv;
+	uint32	lcd_pwmhi;
+	uint32	reserved[(0x0400-0x002C)/4];
+	uint32	lcd_pallettebase[256];
+
+} AU1100_LCD;
+
+/********************************************************************/
+
+#define AU1100_LCD_ADDR		0xB5000000
+
+/*
+ * Register bit definitions
+ */
+
+/* lcd_control */
+#define LCD_CONTROL_SBPPF		(7<<18)
+#define LCD_CONTROL_SBPPF_655	(0<<18)
+#define LCD_CONTROL_SBPPF_565	(1<<18)
+#define LCD_CONTROL_SBPPF_556	(2<<18)
+#define LCD_CONTROL_SBPPF_1555	(3<<18)
+#define LCD_CONTROL_SBPPF_5551	(4<<18)
+#define LCD_CONTROL_WP			(1<<17)
+#define LCD_CONTROL_WD			(1<<16)
+#define LCD_CONTROL_C			(1<<15)
+#define LCD_CONTROL_SM			(3<<13)
+#define LCD_CONTROL_SM_0		(0<<13)
+#define LCD_CONTROL_SM_90		(1<<13)
+#define LCD_CONTROL_SM_180		(2<<13)
+#define LCD_CONTROL_SM_270		(3<<13)
+#define LCD_CONTROL_DB			(1<<12)
+#define LCD_CONTROL_CCO			(1<<11)
+#define LCD_CONTROL_DP			(1<<10)
+#define LCD_CONTROL_PO			(3<<8)
+#define LCD_CONTROL_PO_00		(0<<8)
+#define LCD_CONTROL_PO_01		(1<<8)
+#define LCD_CONTROL_PO_10		(2<<8)
+#define LCD_CONTROL_PO_11		(3<<8)
+#define LCD_CONTROL_MPI			(1<<7)
+#define LCD_CONTROL_PT			(1<<6)
+#define LCD_CONTROL_PC			(1<<5)
+#define LCD_CONTROL_BPP			(7<<1)
+#define LCD_CONTROL_BPP_1		(0<<1)
+#define LCD_CONTROL_BPP_2		(1<<1)
+#define LCD_CONTROL_BPP_4		(2<<1)
+#define LCD_CONTROL_BPP_8		(3<<1)
+#define LCD_CONTROL_BPP_12		(4<<1)
+#define LCD_CONTROL_BPP_16		(5<<1)
+#define LCD_CONTROL_GO			(1<<0)
+
+/* lcd_intstatus, lcd_intenable */
+#define LCD_INT_SD				(1<<7)
+#define LCD_INT_OF				(1<<6)
+#define LCD_INT_UF				(1<<5)
+#define LCD_INT_SA				(1<<3)
+#define LCD_INT_SS				(1<<2)
+#define LCD_INT_S1				(1<<1)
+#define LCD_INT_S0				(1<<0)
+
+/* lcd_horztiming */
+#define LCD_HORZTIMING_HN2		(255<<24)
+#define LCD_HORZTIMING_HN2_N(N)	(((N)-1)<<24)
+#define LCD_HORZTIMING_HN1		(255<<16)
+#define LCD_HORZTIMING_HN1_N(N)	(((N)-1)<<16)
+#define LCD_HORZTIMING_HPW		(63<<10)
+#define LCD_HORZTIMING_HPW_N(N)	(((N)-1)<<10)
+#define LCD_HORZTIMING_PPL		(1023<<0)
+#define LCD_HORZTIMING_PPL_N(N)	(((N)-1)<<0)
+
+/* lcd_verttiming */
+#define LCD_VERTTIMING_VN2		(255<<24)
+#define LCD_VERTTIMING_VN2_N(N)	(((N)-1)<<24)
+#define LCD_VERTTIMING_VN1		(255<<16)
+#define LCD_VERTTIMING_VN1_N(N)	(((N)-1)<<16)
+#define LCD_VERTTIMING_VPW		(63<<10)
+#define LCD_VERTTIMING_VPW_N(N)	(((N)-1)<<10)
+#define LCD_VERTTIMING_LPP		(1023<<0)
+#define LCD_VERTTIMING_LPP_N(N)	(((N)-1)<<0)
+
+/* lcd_clkcontrol */
+#define LCD_CLKCONTROL_IB		(1<<18)
+#define LCD_CLKCONTROL_IC		(1<<17)
+#define LCD_CLKCONTROL_IH		(1<<16)
+#define LCD_CLKCONTROL_IV		(1<<15)
+#define LCD_CLKCONTROL_BF		(31<<10)
+#define LCD_CLKCONTROL_BF_N(N)	(((N)-1)<<10)
+#define LCD_CLKCONTROL_PCD		(1023<<0)
+#define LCD_CLKCONTROL_PCD_N(N)	((N)<<0)
+
+/* lcd_pwmdiv */
+#define LCD_PWMDIV_EN			(1<<12)
+#define LCD_PWMDIV_PWMDIV		(2047<<0)
+#define LCD_PWMDIV_PWMDIV_N(N)	(((N)-1)<<0)
+
+/* lcd_pwmhi */
+#define LCD_PWMHI_PWMHI1		(2047<<12)
+#define LCD_PWMHI_PWMHI1_N(N)	((N)<<12)
+#define LCD_PWMHI_PWMHI0		(2047<<0)
+#define LCD_PWMHI_PWMHI0_N(N)	((N)<<0)
+
+/* lcd_pallettebase - MONOCHROME */
+#define LCD_PALLETTE_MONO_MI		(15<<0)
+#define LCD_PALLETTE_MONO_MI_N(N)	((N)<<0)
+
+/* lcd_pallettebase - COLOR */
+#define LCD_PALLETTE_COLOR_BI		(15<<8)
+#define LCD_PALLETTE_COLOR_BI_N(N)	((N)<<8)
+#define LCD_PALLETTE_COLOR_GI		(15<<4)
+#define LCD_PALLETTE_COLOR_GI_N(N)	((N)<<4)
+#define LCD_PALLETTE_COLOR_RI		(15<<0)
+#define LCD_PALLETTE_COLOR_RI_N(N)	((N)<<0)
+
+/* lcd_palletebase - COLOR TFT PALLETIZED */
+#define LCD_PALLETTE_TFT_DC			(65535<<0)
+#define LCD_PALLETTE_TFT_DC_N(N)	((N)<<0)
+
+/********************************************************************/
+
+struct known_lcd_panels
+{
+	uint32 xres;
+	uint32 yres;
+	uint32 bpp;
+	unsigned char  panel_name[256];
+	uint32 mode_control;
+	uint32 mode_horztiming;
+	uint32 mode_verttiming;
+	uint32 mode_clkcontrol;
+	uint32 mode_pwmdiv;
+	uint32 mode_pwmhi;
+	uint32 mode_toyclksrc;
+	uint32 mode_backlight;
+
+};
+
+#if defined(__BIG_ENDIAN)
+#define LCD_DEFAULT_PIX_FORMAT LCD_CONTROL_PO_11
+#else
+#define LCD_DEFAULT_PIX_FORMAT LCD_CONTROL_PO_00
+#endif
+
+/*
+ * The fb driver assumes that AUX PLL is at 48MHz.  That can
+ * cover up to 800x600 resolution; if you need higher resolution,
+ * you should modify the driver as needed, not just this structure.
+ */
+struct known_lcd_panels panels[] =
+{
+	{ /* 0: Pb1100 LCDA: Sharp 320x240 TFT panel */
+		320, /* xres */
+		240, /* yres */
+		16,  /* bpp  */
+
+		"Sharp_320x240_16",
+		/* mode_control */
+		( LCD_CONTROL_SBPPF_565
+		/*LCD_CONTROL_WP*/
+		/*LCD_CONTROL_WD*/
+		| LCD_CONTROL_C
+		| LCD_CONTROL_SM_0
+		/*LCD_CONTROL_DB*/
+		/*LCD_CONTROL_CCO*/
+		/*LCD_CONTROL_DP*/
+		| LCD_DEFAULT_PIX_FORMAT
+		/*LCD_CONTROL_MPI*/
+		| LCD_CONTROL_PT
+		| LCD_CONTROL_PC
+		| LCD_CONTROL_BPP_16 ),
+
+		/* mode_horztiming */
+		( LCD_HORZTIMING_HN2_N(8)
+		| LCD_HORZTIMING_HN1_N(60)
+		| LCD_HORZTIMING_HPW_N(12)
+		| LCD_HORZTIMING_PPL_N(320) ),
+
+		/* mode_verttiming */
+		( LCD_VERTTIMING_VN2_N(5)
+		| LCD_VERTTIMING_VN1_N(17)
+		| LCD_VERTTIMING_VPW_N(1)
+		| LCD_VERTTIMING_LPP_N(240) ),
+
+		/* mode_clkcontrol */
+		( 0
+		/*LCD_CLKCONTROL_IB*/
+		/*LCD_CLKCONTROL_IC*/
+		/*LCD_CLKCONTROL_IH*/
+		/*LCD_CLKCONTROL_IV*/
+		| LCD_CLKCONTROL_PCD_N(1) ),
+
+		/* mode_pwmdiv */
+		0,
+
+		/* mode_pwmhi */
+		0,
+
+		/* mode_toyclksrc */
+		((1<<7) | (1<<6) | (1<<5)),
+
+		/* mode_backlight */
+		6
+	},
+
+	{ /* 1: Pb1100 LCDC 640x480 TFT panel */
+		640, /* xres */
+		480, /* yres */
+		16,  /* bpp  */
+
+		"Generic_640x480_16",
+
+		/* mode_control */
+		0x004806a | LCD_DEFAULT_PIX_FORMAT,
+
+		/* mode_horztiming */
+		0x3434d67f,
+
+		/* mode_verttiming */
+		0x0e0e39df,
+
+		/* mode_clkcontrol */
+		( 0
+		/*LCD_CLKCONTROL_IB*/
+		/*LCD_CLKCONTROL_IC*/
+		/*LCD_CLKCONTROL_IH*/
+		/*LCD_CLKCONTROL_IV*/
+		| LCD_CLKCONTROL_PCD_N(1) ),
+
+		/* mode_pwmdiv */
+		0,
+
+		/* mode_pwmhi */
+		0,
+
+		/* mode_toyclksrc */
+		((1<<7) | (1<<6) | (0<<5)),
+
+		/* mode_backlight */
+		7
+	},
+
+	{ /* 2: Pb1100 LCDB 640x480 PrimeView TFT panel */
+		640, /* xres */
+		480, /* yres */
+		16,  /* bpp  */
+
+		"PrimeView_640x480_16",
+
+		/* mode_control */
+		0x0004886a | LCD_DEFAULT_PIX_FORMAT,
+
+		/* mode_horztiming */
+		0x0e4bfe7f,
+
+		/* mode_verttiming */
+		0x210805df,
+
+		/* mode_clkcontrol */
+		0x00038001,
+
+		/* mode_pwmdiv */
+		0,
+
+		/* mode_pwmhi */
+		0,
+
+		/* mode_toyclksrc */
+		((1<<7) | (1<<6) | (0<<5)),
+
+		/* mode_backlight */
+		7
+	},
+
+	{ /* 3: Pb1100 800x600x16bpp NEON CRT */
+		800, /* xres */
+		600, /* yres */
+		16,  /* bpp */
+
+		"NEON_800x600_16",
+
+		/* mode_control */
+		0x0004886A | LCD_DEFAULT_PIX_FORMAT,
+
+		/* mode_horztiming */
+		0x005AFF1F,
+
+		/* mode_verttiming */
+		0x16000E57,
+
+		/* mode_clkcontrol */
+		0x00020000,
+
+		/* mode_pwmdiv */
+		0,
+
+		/* mode_pwmhi */
+		0,
+
+		/* mode_toyclksrc */
+		((1<<7) | (1<<6) | (0<<5)),
+
+		/* mode_backlight */
+		7
+	},
+
+	{ /* 4: Pb1100 640x480x16bpp NEON CRT */
+		640, /* xres */
+		480, /* yres */
+		16,  /* bpp */
+
+		"NEON_640x480_16",
+
+		/* mode_control */
+		0x0004886A | LCD_DEFAULT_PIX_FORMAT,
+
+		/* mode_horztiming */
+		0x0052E27F,
+
+		/* mode_verttiming */
+		0x18000DDF,
+
+		/* mode_clkcontrol */
+		0x00020000,
+
+		/* mode_pwmdiv */
+		0,
+
+		/* mode_pwmhi */
+		0,
+
+		/* mode_toyclksrc */
+		((1<<7) | (1<<6) | (0<<5)),
+
+		/* mode_backlight */
+		7
+	},
+};
+#endif /* _AU1100LCD_H */
diff -purN linux-2.6.11-rc2-bk10/drivers/video/backlight/Kconfig linux-2.6.11-rc3/drivers/video/backlight/Kconfig
--- linux-2.6.11-rc2-bk10/drivers/video/backlight/Kconfig	2005-02-03 10:03:09.857501105 +0100
+++ linux-2.6.11-rc3/drivers/video/backlight/Kconfig	2005-02-03 02:55:53.000000000 +0100
@@ -41,3 +41,12 @@ config LCD_DEVICE
 	bool
 	depends on LCD_CLASS_DEVICE
 	default y
+
+config BACKLIGHT_CORGI
+	tristate "Sharp Corgi Backlight Driver (SL-C7xx Series)"
+	depends on BACKLIGHT_DEVICE && PXA_SHARPSL
+	default y
+	help
+	  If you have a Sharp Zaurus SL-C7xx, say y to enable the
+	  backlight driver.
+
diff -purN linux-2.6.11-rc2-bk10/drivers/video/backlight/Makefile linux-2.6.11-rc3/drivers/video/backlight/Makefile
--- linux-2.6.11-rc2-bk10/drivers/video/backlight/Makefile	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/backlight/Makefile	2005-02-03 02:57:04.000000000 +0100
@@ -2,3 +2,4 @@
 
 obj-$(CONFIG_LCD_CLASS_DEVICE)     += lcd.o
 obj-$(CONFIG_BACKLIGHT_CLASS_DEVICE) += backlight.o
+obj-$(CONFIG_BACKLIGHT_CORGI)	+= corgi_bl.o
diff -purN linux-2.6.11-rc2-bk10/drivers/video/backlight/corgi_bl.c linux-2.6.11-rc3/drivers/video/backlight/corgi_bl.c
--- linux-2.6.11-rc2-bk10/drivers/video/backlight/corgi_bl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/backlight/corgi_bl.c	2005-02-03 02:55:35.000000000 +0100
@@ -0,0 +1,198 @@
+/*
+ *  Backlight Driver for Sharp Corgi
+ *
+ *  Copyright (c) 2004-2005 Richard Purdie
+ *
+ *  Based on Sharp's 2.4 Backlight Driver
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+
+#include <asm/arch-pxa/corgi.h>
+#include <asm/hardware/scoop.h>
+
+#define CORGI_MAX_INTENSITY 		0x3e
+#define CORGI_DEFAULT_INTENSITY		0x1f
+#define CORGI_LIMIT_MASK			0x0b
+
+static int corgibl_powermode = FB_BLANK_UNBLANK;
+static int current_intensity = 0;
+static int corgibl_limit = 0;
+static spinlock_t bl_lock = SPIN_LOCK_UNLOCKED;
+
+static void corgibl_send_intensity(int intensity)
+{
+	unsigned long flags;
+	void (*corgi_kick_batt)(void);
+
+	if (corgibl_powermode != FB_BLANK_UNBLANK) {
+		intensity = 0;
+	} else {
+		if (corgibl_limit)
+			intensity &= CORGI_LIMIT_MASK;
+	}
+
+	/* Skip 0x20 as it will blank the display */
+	if (intensity >= 0x20)
+		intensity++;
+
+	spin_lock_irqsave(&bl_lock, flags);
+	/* Bits 0-4 are accessed via the SSP interface */
+	corgi_ssp_blduty_set(intensity & 0x1f);
+	/* Bit 5 is via SCOOP */
+	if (intensity & 0x0020)
+		set_scoop_gpio(CORGI_SCP_BACKLIGHT_CONT);
+	else
+		reset_scoop_gpio(CORGI_SCP_BACKLIGHT_CONT);
+	spin_unlock_irqrestore(&bl_lock, flags);
+}
+
+static void corgibl_blank(int blank)
+{
+	switch(blank) {
+
+	case FB_BLANK_NORMAL:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_POWERDOWN:
+		if (corgibl_powermode == FB_BLANK_UNBLANK) {
+			corgibl_send_intensity(0);
+			corgibl_powermode = blank;
+		}
+		break;
+	case FB_BLANK_UNBLANK:
+		if (corgibl_powermode != FB_BLANK_UNBLANK) {
+			corgibl_powermode = blank;
+			corgibl_send_intensity(current_intensity);
+		}
+		break;
+	}
+}
+
+#ifdef CONFIG_PM
+static int corgibl_suspend(struct device *dev, u32 state, u32 level)
+{
+	if (level == SUSPEND_POWER_DOWN)
+		corgibl_blank(FB_BLANK_POWERDOWN);
+	return 0;
+}
+
+static int corgibl_resume(struct device *dev, u32 level)
+{
+	if (level == RESUME_POWER_ON)
+		corgibl_blank(FB_BLANK_UNBLANK);
+	return 0;
+}
+#else
+#define corgibl_suspend	NULL
+#define corgibl_resume	NULL
+#endif
+
+
+static int corgibl_set_power(struct backlight_device *bd, int state)
+{
+	corgibl_blank(state);
+	return 0;
+}
+
+static int corgibl_get_power(struct backlight_device *bd)
+{
+	return corgibl_powermode;
+}
+
+static int corgibl_set_intensity(struct backlight_device *bd, int intensity)
+{
+	if (intensity > CORGI_MAX_INTENSITY)
+		intensity = CORGI_MAX_INTENSITY;
+	corgibl_send_intensity(intensity);
+	current_intensity=intensity;
+	return 0;
+}
+
+static int corgibl_get_intensity(struct backlight_device *bd)
+{
+	return current_intensity;
+}
+
+/*
+ * Called when the battery is low to limit the backlight intensity.
+ * If limit==0 clear any limit, otherwise limit the intensity
+ */
+void corgibl_limit_intensity(int limit)
+{
+	corgibl_limit = (limit ? 1 : 0);
+	corgibl_send_intensity(current_intensity);
+}
+EXPORT_SYMBOL(corgibl_limit_intensity);
+
+
+static struct backlight_properties corgibl_data = {
+	.owner		= THIS_MODULE,
+	.get_power      = corgibl_get_power,
+	.set_power      = corgibl_set_power,
+	.max_brightness = CORGI_MAX_INTENSITY,
+	.get_brightness = corgibl_get_intensity,
+	.set_brightness = corgibl_set_intensity,
+};
+
+static struct backlight_device *corgi_backlight_device;
+
+static int __init corgibl_probe(struct device *dev)
+{
+	corgi_backlight_device = backlight_device_register ("corgi-bl",
+		NULL, &corgibl_data);
+	if (IS_ERR (corgi_backlight_device))
+		return PTR_ERR (corgi_backlight_device);
+
+	corgibl_set_intensity(NULL, CORGI_DEFAULT_INTENSITY);
+
+	printk("Corgi Backlight Driver Initialized.\n");
+	return 0;
+}
+
+static int corgibl_remove(struct device *dev)
+{
+	backlight_device_unregister(corgi_backlight_device);
+
+	corgibl_set_intensity(NULL, 0);
+
+	printk("Corgi Backlight Driver Unloaded\n");
+	return 0;
+}
+
+static struct device_driver corgibl_driver = {
+	.name		= "corgi-bl",
+	.bus		= &platform_bus_type,
+	.probe		= corgibl_probe,
+	.remove		= corgibl_remove,
+	.suspend	= corgibl_suspend,
+	.resume		= corgibl_resume,
+};
+
+static int __init corgibl_init(void)
+{
+	return driver_register(&corgibl_driver);
+}
+
+static void __exit corgibl_exit(void)
+{
+ 	driver_unregister(&corgibl_driver);
+}
+
+module_init(corgibl_init);
+module_exit(corgibl_exit);
+
+MODULE_AUTHOR("Richard Purdie <rpurdie@rpsys.net>");
+MODULE_DESCRIPTION("Corgi Backlight Driver");
+MODULE_LICENSE("GPLv2");
diff -purN linux-2.6.11-rc2-bk10/drivers/video/bt431.h linux-2.6.11-rc3/drivers/video/bt431.h
--- linux-2.6.11-rc2-bk10/drivers/video/bt431.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/bt431.h	2005-02-03 02:56:33.000000000 +0100
@@ -0,0 +1,236 @@
+/*
+ *	linux/drivers/video/bt431.h
+ *
+ *	Copyright 2003  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License. See the file COPYING in the main directory of this
+ *	archive for more details.
+ */
+#include <linux/types.h>
+#include <asm/system.h>
+
+/*
+ * Bt431 cursor generator registers, 32-bit aligned.
+ * Two twin Bt431 are used on the DECstation's PMAG-AA.
+ */
+struct bt431_regs {
+	volatile u16 addr_lo;
+	u16 pad0;
+	volatile u16 addr_hi;
+	u16 pad1;
+	volatile u16 addr_cmap;
+	u16 pad2;
+	volatile u16 addr_reg;
+	u16 pad3;
+};
+
+static inline u16 bt431_set_value(u8 val)
+{
+	return ((val << 8) | (val & 0xff)) & 0xffff;
+}
+
+static inline u8 bt431_get_value(u16 val)
+{
+	return val & 0xff;
+}
+
+/*
+ * Additional registers addressed indirectly.
+ */
+#define BT431_REG_CMD		0x0000
+#define BT431_REG_CXLO		0x0001
+#define BT431_REG_CXHI		0x0002
+#define BT431_REG_CYLO		0x0003
+#define BT431_REG_CYHI		0x0004
+#define BT431_REG_WXLO		0x0005
+#define BT431_REG_WXHI		0x0006
+#define BT431_REG_WYLO		0x0007
+#define BT431_REG_WYHI		0x0008
+#define BT431_REG_WWLO		0x0009
+#define BT431_REG_WWHI		0x000a
+#define BT431_REG_WHLO		0x000b
+#define BT431_REG_WHHI		0x000c
+
+#define BT431_REG_CRAM_BASE	0x0000
+#define BT431_REG_CRAM_END	0x01ff
+
+/*
+ * Command register.
+ */
+#define BT431_CMD_CURS_ENABLE	0x40
+#define BT431_CMD_XHAIR_ENABLE	0x20
+#define BT431_CMD_OR_CURSORS	0x10
+#define BT431_CMD_AND_CURSORS	0x00
+#define BT431_CMD_1_1_MUX	0x00
+#define BT431_CMD_4_1_MUX	0x04
+#define BT431_CMD_5_1_MUX	0x08
+#define BT431_CMD_xxx_MUX	0x0c
+#define BT431_CMD_THICK_1	0x00
+#define BT431_CMD_THICK_3	0x01
+#define BT431_CMD_THICK_5	0x02
+#define BT431_CMD_THICK_7	0x03
+
+static inline void bt431_select_reg(struct bt431_regs *regs, int ir)
+{
+	/*
+	 * The compiler splits the write in two bytes without these
+	 * helper variables.
+	 */
+	volatile u16 *lo = &(regs->addr_lo);
+	volatile u16 *hi = &(regs->addr_hi);
+
+	mb();
+	*lo = bt431_set_value(ir & 0xff);
+	wmb();
+	*hi = bt431_set_value((ir >> 8) & 0xff);
+}
+
+/* Autoincrement read/write. */
+static inline u8 bt431_read_reg_inc(struct bt431_regs *regs)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_reg);
+
+	mb();
+	return bt431_get_value(*r);
+}
+
+static inline void bt431_write_reg_inc(struct bt431_regs *regs, u8 value)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_reg);
+
+	mb();
+	*r = bt431_set_value(value);
+}
+
+static inline u8 bt431_read_reg(struct bt431_regs *regs, int ir)
+{
+	bt431_select_reg(regs, ir);
+	return bt431_read_reg_inc(regs);
+}
+
+static inline void bt431_write_reg(struct bt431_regs *regs, int ir, u8 value)
+{
+	bt431_select_reg(regs, ir);
+	bt431_write_reg_inc(regs, value);
+}
+
+/* Autoincremented read/write for the cursor map. */
+static inline u16 bt431_read_cmap_inc(struct bt431_regs *regs)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_cmap);
+
+	mb();
+	return *r;
+}
+
+static inline void bt431_write_cmap_inc(struct bt431_regs *regs, u16 value)
+{
+	/*
+	 * The compiler splits the write in two bytes without the
+	 * helper variable.
+	 */
+	volatile u16 *r = &(regs->addr_cmap);
+
+	mb();
+	*r = value;
+}
+
+static inline u16 bt431_read_cmap(struct bt431_regs *regs, int cr)
+{
+	bt431_select_reg(regs, cr);
+	return bt431_read_cmap_inc(regs);
+}
+
+static inline void bt431_write_cmap(struct bt431_regs *regs, int cr, u16 value)
+{
+	bt431_select_reg(regs, cr);
+	bt431_write_cmap_inc(regs, value);
+}
+
+static inline void bt431_enable_cursor(struct bt431_regs *regs)
+{
+	bt431_write_reg(regs, BT431_REG_CMD,
+			BT431_CMD_CURS_ENABLE | BT431_CMD_OR_CURSORS
+			| BT431_CMD_4_1_MUX | BT431_CMD_THICK_1);
+}
+
+static inline void bt431_erase_cursor(struct bt431_regs *regs)
+{
+	bt431_write_reg(regs, BT431_REG_CMD, BT431_CMD_4_1_MUX);
+}
+
+static inline void bt431_position_cursor(struct bt431_regs *regs, u16 x, u16 y)
+{
+	/*
+	 * Magic from the MACH sources.
+	 *
+	 * Cx = x + D + H - P
+	 *  P = 37 if 1:1, 52 if 4:1, 57 if 5:1
+	 *  D = pixel skew between outdata and external data
+	 *  H = pixels between HSYNCH falling and active video
+	 *
+	 * Cy = y + V - 32
+	 *  V = scanlines between HSYNCH falling, two or more
+	 *      clocks after VSYNCH falling, and active video
+	 */
+	x += 412 - 52;
+	y += 68 - 32;
+
+	/* Use autoincrement. */
+	bt431_select_reg(regs, BT431_REG_CXLO);
+	bt431_write_reg_inc(regs, x & 0xff); /* BT431_REG_CXLO */
+	bt431_write_reg_inc(regs, (x >> 8) & 0x0f); /* BT431_REG_CXHI */
+	bt431_write_reg_inc(regs, y & 0xff); /* BT431_REG_CYLO */
+	bt431_write_reg_inc(regs, (y >> 8) & 0x0f); /* BT431_REG_CYHI */
+}
+
+static inline void bt431_set_font(struct bt431_regs *regs, u8 fgc,
+				  u16 width, u16 height)
+{
+	int i;
+	u16 fgp = fgc ? 0xffff : 0x0000;
+	u16 bgp = fgc ? 0x0000 : 0xffff;
+
+	bt431_select_reg(regs, BT431_REG_CRAM_BASE);
+	for (i = BT431_REG_CRAM_BASE; i <= BT431_REG_CRAM_END; i++) {
+		u16 value;
+
+		if (height << 6 <= i << 3)
+			value = bgp;
+		else if (width <= i % 8 << 3)
+			value = bgp;
+		else if (((width >> 3) & 0xffff) > i % 8)
+			value = fgp;
+		else
+			value = fgp & ~(bgp << (width % 8 << 1));
+
+		bt431_write_cmap_inc(regs, value);
+	}
+}
+
+static inline void bt431_init_cursor(struct bt431_regs *regs)
+{
+	/* no crosshair window */
+	bt431_select_reg(regs, BT431_REG_WXLO);
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WXLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WXHI */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WYLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WYHI */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WWLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WWHI */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WHLO */
+	bt431_write_reg_inc(regs, 0x00); /* BT431_REG_WHHI */
+}
diff -purN linux-2.6.11-rc2-bk10/drivers/video/bt455.h linux-2.6.11-rc3/drivers/video/bt455.h
--- linux-2.6.11-rc2-bk10/drivers/video/bt455.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/bt455.h	2005-02-03 02:56:48.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ *	linux/drivers/video/bt455.h
+ *
+ *	Copyright 2003  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License. See the file COPYING in the main directory of this
+ *	archive for more details.
+ */
+#include <linux/types.h>
+#include <asm/system.h>
+
+/*
+ * Bt455 byte-wide registers, 32-bit aligned.
+ */
+struct bt455_regs {
+	volatile u8 addr_cmap;
+	u8 pad0[3];
+	volatile u8 addr_cmap_data;
+	u8 pad1[3];
+	volatile u8 addr_clr;
+	u8 pad2[3];
+	volatile u8 addr_ovly;
+	u8 pad3[3];
+};
+
+static inline void bt455_select_reg(struct bt455_regs *regs, int ir)
+{
+	mb();
+	regs->addr_cmap = ir & 0x0f;
+}
+
+/*
+ * Read/write to a Bt455 color map register.
+ */
+static inline void bt455_read_cmap_entry(struct bt455_regs *regs, int cr,
+					 u8* red, u8* green, u8* blue)
+{
+	bt455_select_reg(regs, cr);
+	mb();
+	*red = regs->addr_cmap_data & 0x0f;
+	rmb();
+	*green = regs->addr_cmap_data & 0x0f;
+	rmb();
+	*blue = regs->addr_cmap_data & 0x0f;
+}
+
+static inline void bt455_write_cmap_entry(struct bt455_regs *regs, int cr,
+					  u8 red, u8 green, u8 blue)
+{
+	bt455_select_reg(regs, cr);
+	wmb();
+	regs->addr_cmap_data = red & 0x0f;
+	wmb();
+	regs->addr_cmap_data = green & 0x0f;
+	wmb();
+	regs->addr_cmap_data = blue & 0x0f;
+}
+
+static inline void bt455_write_ovly_entry(struct bt455_regs *regs, int cr,
+					  u8 red, u8 green, u8 blue)
+{
+	bt455_select_reg(regs, cr);
+	wmb();
+	regs->addr_ovly = red & 0x0f;
+	wmb();
+	regs->addr_ovly = green & 0x0f;
+	wmb();
+	regs->addr_ovly = blue & 0x0f;
+}
+
+static inline void bt455_set_cursor(struct bt455_regs *regs)
+{
+	mb();
+	regs->addr_ovly = 0x0f;
+	wmb();
+	regs->addr_ovly = 0x0f;
+	wmb();
+	regs->addr_ovly = 0x0f;
+}
+
+static inline void bt455_erase_cursor(struct bt455_regs *regs)
+{
+	/* bt455_write_cmap_entry(regs, 8, 0x00, 0x00, 0x00); */
+	/* bt455_write_cmap_entry(regs, 9, 0x00, 0x00, 0x00); */
+	bt455_write_ovly_entry(regs, 8, 0x03, 0x03, 0x03);
+	bt455_write_ovly_entry(regs, 9, 0x07, 0x07, 0x07);
+
+	wmb();
+	regs->addr_ovly = 0x09;
+	wmb();
+	regs->addr_ovly = 0x09;
+	wmb();
+	regs->addr_ovly = 0x09;
+}
diff -purN linux-2.6.11-rc2-bk10/drivers/video/fbmon.c linux-2.6.11-rc3/drivers/video/fbmon.c
--- linux-2.6.11-rc2-bk10/drivers/video/fbmon.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/fbmon.c	2005-02-03 02:56:48.000000000 +0100
@@ -183,7 +183,7 @@ static int edid_check_header(unsigned ch
 			err = 0;
 	}
 
-	return 1;
+	return err;
 }
 
 static void parse_vendor_block(unsigned char *block, struct fb_monspecs *specs)
diff -purN linux-2.6.11-rc2-bk10/drivers/video/g364fb.c linux-2.6.11-rc3/drivers/video/g364fb.c
--- linux-2.6.11-rc2-bk10/drivers/video/g364fb.c	2005-01-22 02:47:14.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/g364fb.c	2005-02-03 02:55:07.000000000 +0100
@@ -15,6 +15,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/console.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
diff -purN linux-2.6.11-rc2-bk10/drivers/video/gbefb.c linux-2.6.11-rc3/drivers/video/gbefb.c
--- linux-2.6.11-rc2-bk10/drivers/video/gbefb.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/gbefb.c	2005-02-03 02:55:36.000000000 +0100
@@ -85,7 +85,6 @@ static struct {
 
 static int gbe_revision;
 
-static struct fb_info fb_info;
 static int ypan, ywrap;
 
 static uint32_t pseudo_palette[256];
@@ -190,8 +189,6 @@ struct fb_var_screeninfo *default_var = 
 
 static int flat_panel_enabled = 0;
 
-static struct gbefb_par par_current;
-
 static void gbe_reset(void)
 {
 	/* Turn on dotclock PLL */
@@ -1045,6 +1042,36 @@ static struct fb_ops gbefb_ops = {
 };
 
 /*
+ * sysfs
+ */
+
+static ssize_t gbefb_show_memsize(struct device *dev, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", gbe_mem_size);
+}
+
+static DEVICE_ATTR(size, S_IRUGO, gbefb_show_memsize, NULL);
+
+static ssize_t gbefb_show_rev(struct device *device, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", gbe_revision);
+}
+
+static DEVICE_ATTR(revision, S_IRUGO, gbefb_show_rev, NULL);
+
+static void __devexit gbefb_remove_sysfs(struct device *dev)
+{
+	device_remove_file(dev, &dev_attr_size);
+	device_remove_file(dev, &dev_attr_revision);
+}
+
+static void gbefb_create_sysfs(struct device *dev)
+{
+	device_create_file(dev, &dev_attr_size);
+	device_create_file(dev, &dev_attr_revision);
+}
+
+/*
  * Initialization
  */
 
@@ -1079,13 +1106,21 @@ int __init gbefb_setup(char *options)
 	return 0;
 }
 
-int __init gbefb_init(void)
+static int __init gbefb_probe(struct device *dev)
 {
 	int i, ret = 0;
-
+	struct fb_info *info;
+	struct gbefb_par *par;
+	struct platform_device *p_dev = to_platform_device(dev);
 #ifndef MODULE
 	char *options = NULL;
+#endif
 
+	info = framebuffer_alloc(sizeof(struct gbefb_par), &p_dev->dev);
+	if (!info)
+		return -ENOMEM;
+
+#ifndef MODULE
 	if (fb_get_options("gbefb", &options))
 		return -ENODEV;
 	gbefb_setup(options);
@@ -1093,7 +1128,8 @@ int __init gbefb_init(void)
 
 	if (!request_mem_region(GBE_BASE, sizeof(struct sgi_gbe), "GBE")) {
 		printk(KERN_ERR "gbefb: couldn't reserve mmio region\n");
-		return -EBUSY;
+		ret = -EBUSY;
+		goto out_release_framebuffer;
 	}
 
 	gbe = (struct sgi_gbe *) ioremap(GBE_BASE, sizeof(struct sgi_gbe));
@@ -1113,7 +1149,6 @@ int __init gbefb_init(void)
 		goto out_unmap;
 	}
 
-
 	if (gbe_mem_phys) {
 		/* memory was allocated at boot time */
 		gbe_mem = ioremap_nocache(gbe_mem_phys, gbe_mem_size);
@@ -1140,32 +1175,35 @@ int __init gbefb_init(void)
 	for (i = 0; i < (gbe_mem_size >> TILE_SHIFT); i++)
 		gbe_tiles.cpu[i] = (gbe_mem_phys >> TILE_SHIFT) + i;
 
-	fb_info.fbops = &gbefb_ops;
-	fb_info.pseudo_palette = pseudo_palette;
-	fb_info.flags = FBINFO_DEFAULT;
-	fb_info.screen_base = gbe_mem;
-	fb_alloc_cmap(&fb_info.cmap, 256, 0);
+	info->fbops = &gbefb_ops;
+	info->pseudo_palette = pseudo_palette;
+	info->flags = FBINFO_DEFAULT;
+	info->screen_base = gbe_mem;
+	fb_alloc_cmap(&info->cmap, 256, 0);
 
 	/* reset GBE */
 	gbe_reset();
 
+	par = info->par;
 	/* turn on default video mode */
-	if (fb_find_mode(&par_current.var, &fb_info, mode_option, NULL, 0,
+	if (fb_find_mode(&par->var, info, mode_option, NULL, 0,
 			 default_mode, 8) == 0)
-		par_current.var = *default_var;
-	fb_info.var = par_current.var;
-	gbefb_check_var(&par_current.var, &fb_info);
-	gbefb_encode_fix(&fb_info.fix, &fb_info.var);
-	fb_info.par = &par_current;
+		par->var = *default_var;
+	info->var = par->var;
+	gbefb_check_var(&par->var, info);
+	gbefb_encode_fix(&info->fix, &info->var);
 
-	if (register_framebuffer(&fb_info) < 0) {
-		ret = -ENXIO;
+	if (register_framebuffer(info) < 0) {
 		printk(KERN_ERR "gbefb: couldn't register framebuffer\n");
+		ret = -ENXIO;
 		goto out_gbe_unmap;
 	}
 
+	dev_set_drvdata(&p_dev->dev, info);
+	gbefb_create_sysfs(dev);
+
 	printk(KERN_INFO "fb%d: %s rev %d @ 0x%08x using %dkB memory\n",
-	       fb_info.node, fb_info.fix.id, gbe_revision, (unsigned) GBE_BASE,
+	       info->node, info->fix.id, gbe_revision, (unsigned) GBE_BASE,
 	       gbe_mem_size >> 10);
 
 	return 0;
@@ -1182,12 +1220,18 @@ out_unmap:
 	iounmap(gbe);
 out_release_mem_region:
 	release_mem_region(GBE_BASE, sizeof(struct sgi_gbe));
+out_release_framebuffer:
+	framebuffer_release(info);
+
 	return ret;
 }
 
-void __exit gbefb_exit(void)
+static int __devexit gbefb_remove(struct device* dev)
 {
-	unregister_framebuffer(&fb_info);
+	struct platform_device *p_dev = to_platform_device(dev);
+	struct fb_info *info = dev_get_drvdata(&p_dev->dev);
+
+	unregister_framebuffer(info);
 	gbe_turn_off();
 	if (gbe_dma_addr)
 		dma_free_coherent(NULL, gbe_mem_size, gbe_mem, gbe_mem_phys);
@@ -1197,12 +1241,40 @@ void __exit gbefb_exit(void)
 			  (void *)gbe_tiles.cpu, gbe_tiles.dma);
 	release_mem_region(GBE_BASE, sizeof(struct sgi_gbe));
 	iounmap(gbe);
+	gbefb_remove_sysfs(dev);
+	framebuffer_release(info);
+
+	return 0;
 }
 
-module_init(gbefb_init);
+static struct device_driver gbefb_driver = {
+	.name = "gbefb",
+	.bus = &platform_bus_type,
+	.probe = gbefb_probe,
+	.remove = __devexit_p(gbefb_remove),
+};
+
+static struct platform_device gbefb_device = {
+	.name = "gbefb",
+};
 
-#ifdef MODULE
+int __init gbefb_init(void)
+{
+	int ret = driver_register(&gbefb_driver);
+	if (!ret) {
+		ret = platform_device_register(&gbefb_device);
+		if (ret)
+			driver_unregister(&gbefb_driver);
+	}
+	return ret;
+}
+
+void __exit gbefb_exit(void)
+{
+	 driver_unregister(&gbefb_driver);
+}
+
+module_init(gbefb_init);
 module_exit(gbefb_exit);
-#endif
 
 MODULE_LICENSE("GPL");
diff -purN linux-2.6.11-rc2-bk10/drivers/video/logo/Kconfig linux-2.6.11-rc3/drivers/video/logo/Kconfig
--- linux-2.6.11-rc2-bk10/drivers/video/logo/Kconfig	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/logo/Kconfig	2005-02-03 02:55:50.000000000 +0100
@@ -25,7 +25,7 @@ config LOGO_LINUX_CLUT224
 
 config LOGO_DEC_CLUT224
 	bool "224-color Digital Equipment Corporation Linux logo"
-	depends on LOGO && DECSTATION
+	depends on LOGO && MACH_DECSTATION
 	default y
 
 config LOGO_MAC_CLUT224
diff -purN linux-2.6.11-rc2-bk10/drivers/video/matrox/matroxfb_base.c linux-2.6.11-rc3/drivers/video/matrox/matroxfb_base.c
--- linux-2.6.11-rc2-bk10/drivers/video/matrox/matroxfb_base.c	2005-02-03 10:03:09.878497838 +0100
+++ linux-2.6.11-rc3/drivers/video/matrox/matroxfb_base.c	2005-02-03 02:56:22.000000000 +0100
@@ -2536,9 +2536,9 @@ MODULE_PARM_DESC(dfp_type, "Specifies DF
 module_param_string(outputs, outputs, sizeof(outputs), 0);
 MODULE_PARM_DESC(outputs, "Specifies which CRTC is mapped to which output (string of up to three letters, consisting of 0 (disabled), 1 (CRTC1), 2 (CRTC2)) (default=111 for Gx50, 101 for G200/G400 with DFP, and 100 for all other devices)");
 #ifdef CONFIG_PPC_PMAC
-module_param(vmode, int, 0);
+module_param_named(vmode, default_vmode, int, 0);
 MODULE_PARM_DESC(vmode, "Specify the vmode mode number that should be used (640x480 default)");
-module_param(cmode, int, 0);
+module_param_named(cmode, default_cmode, int, 0);
 MODULE_PARM_DESC(cmode, "Specify the video depth that should be used (8bit default)");
 #endif
 
diff -purN linux-2.6.11-rc2-bk10/drivers/video/maxinefb.c linux-2.6.11-rc3/drivers/video/maxinefb.c
--- linux-2.6.11-rc2-bk10/drivers/video/maxinefb.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/maxinefb.c	2005-02-03 02:55:23.000000000 +0100
@@ -43,31 +43,25 @@
 static struct fb_info fb_info;
 
 static struct fb_var_screeninfo maxinefb_defined = {
-	.xres 		= 1024,
-	.yres 		= 768,
-	.xres_virtual 	= 1024,
-	.yres_virtual 	= 768,
-	.bits_per_pixel = 8,
-	.red.length	= 8,
-	.green.length	= 8,
-	.blue.length	= 8,
-	.activate 	= FB_ACTIVATE_NOW,
-	.height 	= -1,
-	.width 		= -1,
-	.vmode 		= FB_VMODE_NONINTERLACED,
+	.xres =		1024,
+	.yres =		768,
+	.xres_virtual =	1024,
+	.yres_virtual =	768,
+	.bits_per_pixel =8,
+	.activate =	FB_ACTIVATE_NOW,
+	.height =	-1,
+	.width =	-1,
+	.vmode =	FB_VMODE_NONINTERLACED,
 };
 
 static struct fb_fix_screeninfo maxinefb_fix = {
-	.id 		= "Maxine onboard graphics 1024x768x8",
-	.smem_len 	= (1024*768),
-	.type 		= FB_TYPE_PACKED_PIXELS,
-	.visual 	= FB_VISUAL_PSEUDOCOLOR,
-	.line_length 	= 1024,
+	.id =		"Maxine onboard graphics 1024x768x8",
+	.smem_len =	(1024*768),
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_PSEUDOCOLOR,
+	.line_length =	1024,
 };
 
-/* Reference to machine type set in arch/mips/dec/prom/identify.c, KM */
-extern unsigned long mips_machtype;
-
 /* Handle the funny Inmos RamDAC/video controller ... */
 
 void maxinefb_ims332_write_register(int regno, register unsigned int val)
@@ -100,12 +94,12 @@ static int maxinefb_setcolreg(unsigned r
 	/* value to be written into the palette reg. */
 	unsigned long hw_colorvalue = 0;
 
-	red   >>= 8;	/* The cmap fields are 16 bits    */
-	green >>= 8;	/* wide, but the harware colormap */
-	blue  >>= 8;	/* registers are only 8 bits wide */
+	red   >>= 8;    /* The cmap fields are 16 bits    */
+	green >>= 8;    /* wide, but the harware colormap */
+	blue  >>= 8;    /* registers are only 8 bits wide */
 
 	hw_colorvalue = (blue << 16) + (green << 8) + (red);
-	
+
 	maxinefb_ims332_write_register(IMS332_REG_COLOR_PALETTE + regno,
 				       hw_colorvalue);
 	return 0;
@@ -113,16 +107,18 @@ static int maxinefb_setcolreg(unsigned r
 
 static struct fb_ops maxinefb_ops = {
 	.owner		= THIS_MODULE,
-	.fb_setcolreg	= maxinefb_setcolreg,	
+	.fb_get_fix	= gen_get_fix,
+	.fb_get_var	= gen_get_var,
+	.fb_setcolreg	= maxinefb_setcolreg,
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
-	.fb_imageblit	= cfb_imageblit,		
+	.fb_imageblit	= cfb_imageblit,
 	.fb_cursor	= soft_cursor,
 };
 
 int __init maxinefb_init(void)
 {
-	volatile unsigned char *fboff;
+	unsigned long fboff;
 	unsigned long fb_start;
 	int i;
 
@@ -142,7 +138,7 @@ int __init maxinefb_init(void)
 
 	/* Clear screen */
 	for (fboff = fb_start; fboff < fb_start + 0x1ffff; fboff++)
-		*fboff = 0x0;
+		*(volatile unsigned char *)fboff = 0x0;
 
 	maxinefb_fix.smem_start = fb_start;
 	
@@ -159,7 +155,7 @@ int __init maxinefb_init(void)
 	}
 
 	fb_info.fbops = &maxinefb_ops;
-	fb_info.screen_base = (char *) maxinefb_fix.smem_start;
+	fb_info.screen_base = (char *)maxinefb_fix.smem_start;
 	fb_info.var = maxinefb_defined;
 	fb_info.fix = maxinefb_fix;
 	fb_info.flags = FBINFO_DEFAULT;
diff -purN linux-2.6.11-rc2-bk10/drivers/video/pmag-aa-fb.c linux-2.6.11-rc3/drivers/video/pmag-aa-fb.c
--- linux-2.6.11-rc2-bk10/drivers/video/pmag-aa-fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/pmag-aa-fb.c	2005-02-03 02:56:47.000000000 +0100
@@ -0,0 +1,514 @@
+/*
+ *	linux/drivers/video/pmag-aa-fb.c
+ *	Copyright 2002 Karsten Merker <merker@debian.org>
+ *
+ *	PMAG-AA TurboChannel framebuffer card support ... derived from
+ *	pmag-ba-fb.c, which is Copyright (C) 1999, 2000, 2001 by
+ *	Michael Engel <engel@unix-ag.org>, Karsten Merker <merker@debian.org>
+ *	and Harald Koerfgen <hkoerfg@web.de>, which itself is derived from
+ *	"HP300 Topcat framebuffer support (derived from macfb of all things)
+ *	Phil Blundell <philb@gnu.org> 1998"
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License.  See the file COPYING in the main directory of this
+ *	archive for more details.
+ *
+ *	2002-09-28  Karsten Merker <merker@linuxtag.org>
+ *		Version 0.01: First try to get a PMAG-AA running.
+ *
+ *	2003-02-24  Thiemo Seufer  <seufer@csv.ica.uni-stuttgart.de>
+ *		Version 0.02: Major code cleanup.
+ *
+ *	2003-09-21  Thiemo Seufer  <seufer@csv.ica.uni-stuttgart.de>
+ *		Hardware cursor support.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+
+#include <asm/bootinfo.h>
+#include <asm/dec/machtype.h>
+#include <asm/dec/tc.h>
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+
+#include "bt455.h"
+#include "bt431.h"
+
+/* Version information */
+#define DRIVER_VERSION "0.02"
+#define DRIVER_AUTHOR "Karsten Merker <merker@linuxtag.org>"
+#define DRIVER_DESCRIPTION "PMAG-AA Framebuffer Driver"
+
+/* Prototypes */
+static int aafb_set_var(struct fb_var_screeninfo *var, int con,
+			struct fb_info *info);
+
+/*
+ * Bt455 RAM DAC register base offset (rel. to TC slot base address).
+ */
+#define PMAG_AA_BT455_OFFSET		0x100000
+
+/*
+ * Bt431 cursor generator offset (rel. to TC slot base address).
+ */
+#define PMAG_AA_BT431_OFFSET		0x180000
+
+/*
+ * Begin of PMAG-AA framebuffer memory relative to TC slot address,
+ * resolution is 1280x1024x1 (8 bits deep, but only LSB is used).
+ */
+#define PMAG_AA_ONBOARD_FBMEM_OFFSET	0x200000
+
+struct aafb_cursor {
+	struct timer_list timer;
+	int enable;
+	int on;
+	int vbl_cnt;
+	int blink_rate;
+	u16 x, y, width, height;
+};
+
+#define CURSOR_TIMER_FREQ	(HZ / 50)
+#define CURSOR_BLINK_RATE	(20)
+#define CURSOR_DRAW_DELAY	(2)
+
+struct aafb_info {
+	struct fb_info info;
+	struct display disp;
+	struct aafb_cursor cursor;
+	struct bt455_regs *bt455;
+	struct bt431_regs *bt431;
+	unsigned long fb_start;
+	unsigned long fb_size;
+	unsigned long fb_line_length;
+};
+
+/*
+ * Max 3 TURBOchannel slots -> max 3 PMAG-AA.
+ */
+static struct aafb_info my_fb_info[3];
+
+static struct aafb_par {
+} current_par;
+
+static int currcon = -1;
+
+static void aafb_set_cursor(struct aafb_info *info, int on)
+{
+	struct aafb_cursor *c = &info->cursor;
+
+	if (on) {
+		bt431_position_cursor(info->bt431, c->x, c->y);
+		bt431_enable_cursor(info->bt431);
+	} else
+		bt431_erase_cursor(info->bt431);
+}
+
+static void aafbcon_cursor(struct display *disp, int mode, int x, int y)
+{
+	struct aafb_info *info = (struct aafb_info *)disp->fb_info;
+	struct aafb_cursor *c = &info->cursor;
+
+	x *= fontwidth(disp);
+	y *= fontheight(disp);
+
+	if (c->x == x && c->y == y && (mode == CM_ERASE) == !c->enable)
+		return;
+
+	c->enable = 0;
+	if (c->on)
+		aafb_set_cursor(info, 0);
+	c->x = x - disp->var.xoffset;
+	c->y = y - disp->var.yoffset;
+
+	switch (mode) {
+		case CM_ERASE:
+			c->on = 0;
+			break;
+		case CM_DRAW:
+		case CM_MOVE:
+			if (c->on)
+				aafb_set_cursor(info, c->on);
+			else
+				c->vbl_cnt = CURSOR_DRAW_DELAY;
+			c->enable = 1;
+			break;
+	}
+}
+
+static int aafbcon_set_font(struct display *disp, int width, int height)
+{
+	struct aafb_info *info = (struct aafb_info *)disp->fb_info;
+	struct aafb_cursor *c = &info->cursor;
+	u8 fgc = ~attr_bgcol_ec(disp, disp->conp);
+
+	if (width > 64 || height > 64 || width < 0 || height < 0)
+		return -EINVAL;
+
+	c->height = height;
+	c->width = width;
+
+	bt431_set_font(info->bt431, fgc, width, height);
+
+	return 1;
+}
+
+static void aafb_cursor_timer_handler(unsigned long data)
+{
+	struct aafb_info *info = (struct aafb_info *)data;
+	struct aafb_cursor *c = &info->cursor;
+
+	if (!c->enable)
+		goto out;
+
+	if (c->vbl_cnt && --c->vbl_cnt == 0) {
+		c->on ^= 1;
+		aafb_set_cursor(info, c->on);
+		c->vbl_cnt = c->blink_rate;
+	}
+
+out:
+	c->timer.expires = jiffies + CURSOR_TIMER_FREQ;
+	add_timer(&c->timer);
+}
+
+static void __init aafb_cursor_init(struct aafb_info *info)
+{
+	struct aafb_cursor *c = &info->cursor;
+
+	c->enable = 1;
+	c->on = 1;
+	c->x = c->y = 0;
+	c->width = c->height = 0;
+	c->vbl_cnt = CURSOR_DRAW_DELAY;
+	c->blink_rate = CURSOR_BLINK_RATE;
+
+	init_timer(&c->timer);
+	c->timer.data = (unsigned long)info;
+	c->timer.function = aafb_cursor_timer_handler;
+	mod_timer(&c->timer, jiffies + CURSOR_TIMER_FREQ);
+}
+
+static void __exit aafb_cursor_exit(struct aafb_info *info)
+{
+	struct aafb_cursor *c = &info->cursor;
+
+	del_timer_sync(&c->timer);
+}
+
+static struct display_switch aafb_switch8 = {
+	.setup = fbcon_cfb8_setup,
+	.bmove = fbcon_cfb8_bmove,
+	.clear = fbcon_cfb8_clear,
+	.putc = fbcon_cfb8_putc,
+	.putcs = fbcon_cfb8_putcs,
+	.revc = fbcon_cfb8_revc,
+	.cursor = aafbcon_cursor,
+	.set_font = aafbcon_set_font,
+	.clear_margins = fbcon_cfb8_clear_margins,
+	.fontwidthmask = FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+
+static void aafb_get_par(struct aafb_par *par)
+{
+	*par = current_par;
+}
+
+static int aafb_get_fix(struct fb_fix_screeninfo *fix, int con,
+			struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+	strcpy(fix->id, "PMAG-AA");
+	fix->smem_start = ip->fb_start;
+	fix->smem_len = ip->fb_size;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->ypanstep = 1;
+	fix->ywrapstep = 1;
+	fix->visual = FB_VISUAL_MONO10;
+	fix->line_length = 1280;
+	fix->accel = FB_ACCEL_NONE;
+
+	return 0;
+}
+
+static void aafb_set_disp(struct display *disp, int con,
+			  struct aafb_info *info)
+{
+	struct fb_fix_screeninfo fix;
+
+	disp->fb_info = &info->info;
+	aafb_set_var(&disp->var, con, &info->info);
+	if (disp->conp && disp->conp->vc_sw && disp->conp->vc_sw->con_cursor)
+		disp->conp->vc_sw->con_cursor(disp->conp, CM_ERASE);
+	disp->dispsw = &aafb_switch8;
+	disp->dispsw_data = 0;
+
+	aafb_get_fix(&fix, con, &info->info);
+	disp->screen_base = (u8 *) fix.smem_start;
+	disp->visual = fix.visual;
+	disp->type = fix.type;
+	disp->type_aux = fix.type_aux;
+	disp->ypanstep = fix.ypanstep;
+	disp->ywrapstep = fix.ywrapstep;
+	disp->line_length = fix.line_length;
+	disp->next_line = 2048;
+	disp->can_soft_blank = 1;
+	disp->inverse = 0;
+	disp->scrollmode = SCROLL_YREDRAW;
+
+	aafbcon_set_font(disp, fontwidth(disp), fontheight(disp));
+}
+
+static int aafb_get_cmap(struct fb_cmap *cmap, int kspc, int con,
+			 struct fb_info *info)
+{
+	static u16 color[2] = {0x0000, 0x000f};
+	static struct fb_cmap aafb_cmap = {0, 2, color, color, color, NULL};
+
+	fb_copy_cmap(&aafb_cmap, cmap, kspc ? 0 : 2);
+	return 0;
+}
+
+static int aafb_set_cmap(struct fb_cmap *cmap, int kspc, int con,
+			 struct fb_info *info)
+{
+	u16 color[2] = {0x0000, 0x000f};
+
+	if (cmap->start == 0
+	    && cmap->len == 2
+	    && memcmp(cmap->red, color, sizeof(color)) == 0
+	    && memcmp(cmap->green, color, sizeof(color)) == 0
+	    && memcmp(cmap->blue, color, sizeof(color)) == 0
+	    && cmap->transp == NULL)
+		return 0;
+	else
+		return -EINVAL;
+}
+
+static int aafb_ioctl(struct inode *inode, struct file *file, u32 cmd,
+		      unsigned long arg, int con, struct fb_info *info)
+{
+	/* TODO: Not yet implemented */
+	return -ENOIOCTLCMD;
+}
+
+static int aafb_switch(int con, struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+	struct display *old = (currcon < 0) ? &ip->disp : (fb_display + currcon);
+	struct display *new = (con < 0) ? &ip->disp : (fb_display + con);
+
+	if (old->conp && old->conp->vc_sw && old->conp->vc_sw->con_cursor)
+		old->conp->vc_sw->con_cursor(old->conp, CM_ERASE);
+
+	/* Set the current console. */
+	currcon = con;
+	aafb_set_disp(new, con, ip);
+
+	return 0;
+}
+
+static void aafb_encode_var(struct fb_var_screeninfo *var,
+			    struct aafb_par *par)
+{
+	var->xres = 1280;
+	var->yres = 1024;
+	var->xres_virtual = 2048;
+	var->yres_virtual = 1024;
+	var->xoffset = 0;
+	var->yoffset = 0;
+	var->bits_per_pixel = 8;
+	var->grayscale = 1;
+	var->red.offset = 0;
+	var->red.length = 0;
+	var->red.msb_right = 0;
+	var->green.offset = 0;
+	var->green.length = 1;
+	var->green.msb_right = 0;
+	var->blue.offset = 0;
+	var->blue.length = 0;
+	var->blue.msb_right = 0;
+	var->transp.offset = 0;
+	var->transp.length = 0;
+	var->transp.msb_right = 0;
+	var->nonstd = 0;
+	var->activate &= ~FB_ACTIVATE_MASK & FB_ACTIVATE_NOW;
+	var->accel_flags = 0;
+	var->sync = FB_SYNC_ON_GREEN;
+	var->vmode &= ~FB_VMODE_MASK & FB_VMODE_NONINTERLACED;
+}
+
+static int aafb_get_var(struct fb_var_screeninfo *var, int con,
+			struct fb_info *info)
+{
+	if (con < 0) {
+		struct aafb_par par;
+
+		memset(var, 0, sizeof(struct fb_var_screeninfo));
+		aafb_get_par(&par);
+		aafb_encode_var(var, &par);
+	} else
+		*var = info->var;
+
+	return 0;
+}
+
+static int aafb_set_var(struct fb_var_screeninfo *var, int con,
+			struct fb_info *info)
+{
+	struct aafb_par par;
+
+	aafb_get_par(&par);
+	aafb_encode_var(var, &par);
+	info->var = *var;
+
+	return 0;
+}
+
+static int aafb_update_var(int con, struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+	struct display *disp = (con < 0) ? &ip->disp : (fb_display + con);
+
+	if (con == currcon)
+		aafbcon_cursor(disp, CM_ERASE, ip->cursor.x, ip->cursor.y);
+
+	return 0;
+}
+
+/* 0 unblanks, any other blanks. */
+
+static void aafb_blank(int blank, struct fb_info *info)
+{
+	struct aafb_info *ip = (struct aafb_info *)info;
+	u8 val = blank ? 0x00 : 0x0f;
+
+	bt455_write_cmap_entry(ip->bt455, 1, val, val, val);
+	aafbcon_cursor(&ip->disp, CM_ERASE, ip->cursor.x, ip->cursor.y);
+}
+
+static struct fb_ops aafb_ops = {
+	.owner = THIS_MODULE,
+	.fb_get_fix = aafb_get_fix,
+	.fb_get_var = aafb_get_var,
+	.fb_set_var = aafb_set_var,
+	.fb_get_cmap = aafb_get_cmap,
+	.fb_set_cmap = aafb_set_cmap,
+	.fb_ioctl = aafb_ioctl
+};
+
+static int __init init_one(int slot)
+{
+	unsigned long base_addr = get_tc_base_addr(slot);
+	struct aafb_info *ip = &my_fb_info[slot];
+
+	memset(ip, 0, sizeof(struct aafb_info));
+
+	/*
+	 * Framebuffer display memory base address and friends.
+	 */
+	ip->bt455 = (struct bt455_regs *) (base_addr + PMAG_AA_BT455_OFFSET);
+	ip->bt431 = (struct bt431_regs *) (base_addr + PMAG_AA_BT431_OFFSET);
+	ip->fb_start = base_addr + PMAG_AA_ONBOARD_FBMEM_OFFSET;
+	ip->fb_size = 2048 * 1024; /* fb_fix_screeninfo.smem_length
+				      seems to be physical */
+	ip->fb_line_length = 2048;
+
+	/*
+	 * Let there be consoles..
+	 */
+	strcpy(ip->info.modename, "PMAG-AA");
+	ip->info.node = -1;
+	ip->info.flags = FBINFO_FLAG_DEFAULT;
+	ip->info.fbops = &aafb_ops;
+	ip->info.disp = &ip->disp;
+	ip->info.changevar = NULL;
+	ip->info.switch_con = &aafb_switch;
+	ip->info.updatevar = &aafb_update_var;
+	ip->info.blank = &aafb_blank;
+
+	aafb_set_disp(&ip->disp, currcon, ip);
+
+	/*
+	 * Configure the RAM DACs.
+	 */
+	bt455_erase_cursor(ip->bt455);
+
+	/* Init colormap. */
+	bt455_write_cmap_entry(ip->bt455, 0, 0x00, 0x00, 0x00);
+	bt455_write_cmap_entry(ip->bt455, 1, 0x0f, 0x0f, 0x0f);
+
+	/* Init hardware cursor. */
+	bt431_init_cursor(ip->bt431);
+	aafb_cursor_init(ip);
+
+	/* Clear the screen. */
+	memset ((void *)ip->fb_start, 0, ip->fb_size);
+
+	if (register_framebuffer(&ip->info) < 0)
+		return -EINVAL;
+
+	printk(KERN_INFO "fb%d: %s frame buffer in TC slot %d\n",
+	       GET_FB_IDX(ip->info.node), ip->info.modename, slot);
+
+	return 0;
+}
+
+static int __exit exit_one(int slot)
+{
+	struct aafb_info *ip = &my_fb_info[slot];
+
+	if (unregister_framebuffer(&ip->info) < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+/*
+ * Initialise the framebuffer.
+ */
+int __init pmagaafb_init(void)
+{
+	int sid;
+	int found = 0;
+
+	while ((sid = search_tc_card("PMAG-AA")) >= 0) {
+		found = 1;
+		claim_tc_card(sid);
+		init_one(sid);
+	}
+
+	return found ? 0 : -ENXIO;
+}
+
+static void __exit pmagaafb_exit(void)
+{
+	int sid;
+
+	while ((sid = search_tc_card("PMAG-AA")) >= 0) {
+		exit_one(sid);
+		release_tc_card(sid);
+	}
+}
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_LICENSE("GPL");
+#ifdef MODULE
+module_init(pmagaafb_init);
+module_exit(pmagaafb_exit);
+#endif
diff -purN linux-2.6.11-rc2-bk10/drivers/video/pmag-ba-fb.c linux-2.6.11-rc3/drivers/video/pmag-ba-fb.c
--- linux-2.6.11-rc2-bk10/drivers/video/pmag-ba-fb.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/pmag-ba-fb.c	2005-02-03 02:56:53.000000000 +0100
@@ -52,27 +52,27 @@ struct pmag_ba_ramdac_regs {
 static struct fb_info pmagba_fb_info[3];
 
 static struct fb_var_screeninfo pmagbafb_defined = {
-	.xres 		= 1024,
+	.xres		= 1024,
 	.yres		= 864,
-	.xres_virtual 	= 1024,
-	.yres_virtual 	= 864,
-	.bits_per_pixel = 8,
+	.xres_virtual	= 1024,
+	.yres_virtual	= 864,
+	.bits_per_pixel	= 8,
 	.red.length	= 8,
 	.green.length	= 8,
 	.blue.length	= 8,
-	.activate 	= FB_ACTIVATE_NOW, 
-	.height 	= 274,	
-	.width 		= 195,
-	.accel 		= FB_ACCEL_NONE,
-	.vmode 		= FB_VMODE_NONINTERLACED,
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= 274,
+	.width		= 195,
+	.accel		= FB_ACCEL_NONE,
+	.vmode		= FB_VMODE_NONINTERLACED,
 };
 
 static struct fb_fix_screeninfo pmagbafb_fix = {
-	.id 		= "PMAG-BA",
-	.smem_len 	= (1024 * 864),
-	.type 		= FB_TYPE_PACKED_PIXELS,
-	.visual 	= FB_VISUAL_PSEUDOCOLOR,
-	.line_length 	= 1024,
+	.id		= "PMAG-BA",
+	.smem_len	= (1024 * 864),
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_PSEUDOCOLOR,
+	.line_length	= 1024,
 };
 
 /*
@@ -89,10 +89,10 @@ void pmagbafb_erase_cursor(struct pmag_b
  * Set the palette. 
  */
 static int pmagbafb_setcolreg(unsigned regno, unsigned red, unsigned green,
-                              unsigned blue, unsigned transp,
-                              struct fb_info *info)
+			      unsigned blue, unsigned transp,
+			      struct fb_info *info)
 {
-	struct pmag_ba_ramdac_regs *bt459_regs = (struct pmag_ba_ramdac_regs *) info->par; 
+	struct pmag_ba_ramdac_regs *bt459_regs = (struct pmag_ba_ramdac_regs *) info->par;
 
 	if (regno >= info->cmap.len)
 		return 1;
@@ -111,6 +111,8 @@ static int pmagbafb_setcolreg(unsigned r
 
 static struct fb_ops pmagbafb_ops = {
 	.owner		= THIS_MODULE,
+	.fb_get_fix	= gen_get_fix,
+	.fb_get_var	= gen_get_var,
 	.fb_setcolreg	= pmagbafb_setcolreg,
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
@@ -122,6 +124,7 @@ int __init pmagbafb_init_one(int slot)
 {
 	unsigned long base_addr = get_tc_base_addr(slot);
 	struct fb_info *info = &pmagba_fb_info[slot]; 
+	struct display *disp = &pmagba_disp[slot];
 
 	printk("PMAG-BA framebuffer in slot %d\n", slot);
 	/*
@@ -145,7 +148,7 @@ int __init pmagbafb_init_one(int slot)
 	info->flags = FBINFO_DEFAULT;
 
 	fb_alloc_cmap(&fb_info.cmap, 256, 0);
-	
+
 	if (register_framebuffer(info) < 0)
 		return 1;
 	return 0;
diff -purN linux-2.6.11-rc2-bk10/drivers/video/pmagb-b-fb.c linux-2.6.11-rc3/drivers/video/pmagb-b-fb.c
--- linux-2.6.11-rc2-bk10/drivers/video/pmagb-b-fb.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/pmagb-b-fb.c	2005-02-03 02:56:10.000000000 +0100
@@ -55,27 +55,27 @@ struct pmagb_b_ramdac_regs {
 static struct fb_info pmagbb_fb_info[3];
 
 static struct fb_var_screeninfo pmagbbfb_defined = {
-	.xres 		= 1280,
-	.yres 		= 1024,
-	.xres_virtual 	= 1280,
-	.yres_virtual 	= 1024,
-	.bits_per_pixel = 8,
+	.xres		= 1280,
+	.yres		= 1024,
+	.xres_virtual	= 1280,
+	.yres_virtual	= 1024,
+	.bits_per_pixel	= 8,
 	.red.length	= 8,
 	.green.length	= 8,
 	.blue.length	= 8,
-	.activate 	= FB_ACTIVATE_NOW,
-	.height 	= 274,
-	.width 		= 195,
-	.accel_flags 	= FB_ACCEL_NONE,
-	.vmode 		= FB_VMODE_NONINTERLACED,
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= 274,
+	.width		= 195,
+	.accel_flags	= FB_ACCEL_NONE,
+	.vmode		= FB_VMODE_NONINTERLACED,
 };
 
 static struct fb_fix_screeninfo pmagbafb_fix = {
-	.id 		= "PMAGB-BA",
-	.smem_len 	= (1280 * 1024),
-	.type 		= FB_TYPE_PACKED_PIXELS,
-	.visual 	= FB_VISUAL_PSEUDOCOLOR,
-	.line_length 	= 1280,
+	.id		= "PMAGB-BA",
+	.smem_len	= (1280 * 1024),
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_PSEUDOCOLOR,
+	.line_length	= 1280,
 }
 
 /*
diff -purN linux-2.6.11-rc2-bk10/drivers/video/tx3912fb.c linux-2.6.11-rc3/drivers/video/tx3912fb.c
--- linux-2.6.11-rc2-bk10/drivers/video/tx3912fb.c	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/drivers/video/tx3912fb.c	2005-02-03 02:56:10.000000000 +0100
@@ -10,7 +10,6 @@
  *
  *  Framebuffer for LCD controller in TMPR3912/05 and PR31700 processors
  */
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -35,11 +34,7 @@ static u32 cfb8[16];
 
 static struct fb_fix_screeninfo tx3912fb_fix __initdata = {
 	.id =		"tx3912fb",
-#ifdef CONFIG_NINO_16MB
-	.smem_len =	(240 * 320),
-#else
 	.smem_len =	((240 * 320)/2),
-#endif
 	.type =		FB_TYPE_PACKED_PIXELS,
 	.visual =	FB_VISUAL_TRUECOLOR, 
 	.xpanstep =	1,
@@ -53,17 +48,10 @@ static struct fb_var_screeninfo tx3912fb
 	.yres =		320,
 	.xres_virtual =	240,
 	.yres_virtual =	320,
-#ifdef CONFIG_NINO_16MB
-	.bits_per_pixel =8,
-	.red =		{ 5, 3, 0 },	/* RGB 332 */
-	.green =	{ 2, 3, 0 },
-	.blue =		{ 0, 2, 0 },
-#else
 	.bits_per_pixel =4,
 	.red =		{ 0, 4, 0 },	/* ??? */
 	.green =	{ 0, 4, 0 },
 	.blue =		{ 0, 4, 0 },
-#endif
 	.activate =	FB_ACTIVATE_NOW,
 	.width =	-1,
 	.height =	-1,
diff -purN linux-2.6.11-rc2-bk10/fs/Kconfig linux-2.6.11-rc3/fs/Kconfig
--- linux-2.6.11-rc2-bk10/fs/Kconfig	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/fs/Kconfig	2005-02-03 02:55:53.000000000 +0100
@@ -304,82 +304,7 @@ config FS_POSIX_ACL
 	depends on EXT2_FS_POSIX_ACL || EXT3_FS_POSIX_ACL || JFS_POSIX_ACL || REISERFS_FS_POSIX_ACL || NFSD_V4
 	default y
 
-config XFS_FS
-	tristate "XFS filesystem support"
-	help
-	  XFS is a high performance journaling filesystem which originated
-	  on the SGI IRIX platform.  It is completely multi-threaded, can
-	  support large files and large filesystems, extended attributes,
-	  variable block sizes, is extent based, and makes extensive use of
-	  Btrees (directories, extents, free space) to aid both performance
-	  and scalability.
-
-	  Refer to the documentation at <http://oss.sgi.com/projects/xfs/>
-	  for complete details.  This implementation is on-disk compatible
-	  with the IRIX version of XFS.
-
-	  To compile this file system support as a module, choose M here: the
-	  module will be called xfs.  Be aware, however, that if the file
-	  system of your root partition is compiled as a module, you'll need
-	  to use an initial ramdisk (initrd) to boot.
-
-config XFS_RT
-	bool "Realtime support (EXPERIMENTAL)"
-	depends on XFS_FS && EXPERIMENTAL
-	help
-	  If you say Y here you will be able to mount and use XFS filesystems
-	  which contain a realtime subvolume. The realtime subvolume is a
-	  separate area of disk space where only file data is stored. The
-	  realtime subvolume is designed to provide very deterministic
-	  data rates suitable for media streaming applications.
-
-	  See the xfs man page in section 5 for a bit more information.
-
-	  This feature is unsupported at this time, is not yet fully
-	  functional, and may cause serious problems.
-
-	  If unsure, say N.
-
-config XFS_QUOTA
-	bool "Quota support"
-	depends on XFS_FS
-	help
-	  If you say Y here, you will be able to set limits for disk usage on
-	  a per user and/or a per group basis under XFS.  XFS considers quota
-	  information as filesystem metadata and uses journaling to provide a
-	  higher level guarantee of consistency.  The on-disk data format for
-	  quota is also compatible with the IRIX version of XFS, allowing a
-	  filesystem to be migrated between Linux and IRIX without any need
-	  for conversion.
-
-	  If unsure, say N.  More comprehensive documentation can be found in
-	  README.quota in the xfsprogs package.  XFS quota can be used either
-	  with or without the generic quota support enabled (CONFIG_QUOTA) -
-	  they are completely independent subsystems.
-
-config XFS_SECURITY
-	bool "Security Label support"
-	depends on XFS_FS
-	help
-	  Security labels support alternative access control models
-	  implemented by security modules like SELinux.  This option
-	  enables an extended attribute namespace for inode security
-	  labels in the XFS filesystem.
-
-	  If you are not using a security module that requires using
-	  extended attributes for inode security labels, say N.
-
-config XFS_POSIX_ACL
-	bool "POSIX ACL support"
-	depends on XFS_FS
-	help
-	  POSIX Access Control Lists (ACLs) support permissions for users and
-	  groups beyond the owner/group/world scheme.
-
-	  To learn more about Access Control Lists, visit the POSIX ACLs for
-	  Linux website <http://acl.bestbits.at/>.
-
-	  If you don't know what Access Control Lists are, say N.
+source "fs/xfs/Kconfig"
 
 config MINIX_FS
 	tristate "Minix fs support"
diff -purN linux-2.6.11-rc2-bk10/fs/aio.c linux-2.6.11-rc3/fs/aio.c
--- linux-2.6.11-rc2-bk10/fs/aio.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/fs/aio.c	2005-02-03 02:55:50.000000000 +0100
@@ -1285,6 +1285,7 @@ asmlinkage long sys_io_setup(unsigned nr
 		if (!ret)
 			return 0;
 
+		get_ioctx(ioctx); /* io_destroy() expects us to hold a ref */
 		io_destroy(ioctx);
 	}
 
diff -purN linux-2.6.11-rc2-bk10/fs/ext2/xattr.c linux-2.6.11-rc3/fs/ext2/xattr.c
--- linux-2.6.11-rc2-bk10/fs/ext2/xattr.c	2005-01-22 02:48:27.000000000 +0100
+++ linux-2.6.11-rc3/fs/ext2/xattr.c	2005-02-03 02:56:10.000000000 +0100
@@ -706,8 +706,14 @@ ext2_xattr_set2(struct inode *inode, str
 	inode->i_ctime = CURRENT_TIME_SEC;
 	if (IS_SYNC(inode)) {
 		error = ext2_sync_inode (inode);
-		if (error)
+		/* In case sync failed due to ENOSPC the inode was actually
+		 * written (only some dirty data were not) so we just proceed
+		 * as if nothing happened and cleanup the unused block */
+		if (error && error != -ENOSPC) {
+			if (new_bh && new_bh != old_bh)
+				DQUOT_FREE_BLOCK(inode, 1);
 			goto cleanup;
+		}
 	} else
 		mark_inode_dirty(inode);
 
diff -purN linux-2.6.11-rc2-bk10/fs/nfsd/export.c linux-2.6.11-rc3/fs/nfsd/export.c
--- linux-2.6.11-rc2-bk10/fs/nfsd/export.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/fs/nfsd/export.c	2005-02-03 02:56:10.000000000 +0100
@@ -305,11 +305,6 @@ void svc_export_request(struct cache_det
 
 static struct svc_export *svc_export_lookup(struct svc_export *, int);
 
-extern struct dentry *
-find_exported_dentry(struct super_block *sb, void *obj, void *parent,
-		     int (*acceptable)(void *context, struct dentry *de),
-		     void *context);
-
 static int check_export(struct inode *inode, int flags)
 {
 
diff -purN linux-2.6.11-rc2-bk10/fs/openpromfs/inode.c linux-2.6.11-rc3/fs/openpromfs/inode.c
--- linux-2.6.11-rc2-bk10/fs/openpromfs/inode.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/fs/openpromfs/inode.c	2005-02-03 02:55:51.000000000 +0100
@@ -94,8 +94,6 @@ static ssize_t property_read(struct file
 	openprom_property *op;
 	char buffer[64];
 	
-	if (*ppos >= 0xffffff || count >= 0xffffff)
-		return -EINVAL;
 	if (!filp->private_data) {
 		node = nodes[(u16)((long)inode->u.generic_ip)].node;
 		i = ((u32)(long)inode->u.generic_ip) >> 16;
@@ -168,6 +166,8 @@ static ssize_t property_read(struct file
 		op = (openprom_property *)filp->private_data;
 	if (!count || !(op->len || (op->flag & OPP_ASCIIZ)))
 		return 0;
+	if (*ppos >= 0xffffff || count >= 0xffffff)
+		return -EINVAL;
 	if (op->flag & OPP_STRINGLIST) {
 		for (k = 0, p = op->value; p < op->value + op->len; p++)
 			if (!*p)
diff -purN linux-2.6.11-rc2-bk10/fs/partitions/Kconfig linux-2.6.11-rc3/fs/partitions/Kconfig
--- linux-2.6.11-rc2-bk10/fs/partitions/Kconfig	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/fs/partitions/Kconfig	2005-02-03 02:56:48.000000000 +0100
@@ -188,14 +188,14 @@ config LDM_DEBUG
 
 config SGI_PARTITION
 	bool "SGI partition support" if PARTITION_ADVANCED
-	default y if (SGI_IP22 || SGI_IP27)
+	default y if (SGI_IP22 || SGI_IP27 || ((MACH_JAZZ || SNI_RM200_PCI) && !CPU_LITTLE_ENDIAN))
 	help
 	  Say Y here if you would like to be able to read the hard disk
 	  partition table format used by SGI machines.
 
 config ULTRIX_PARTITION
 	bool "Ultrix partition table support" if PARTITION_ADVANCED
-	default y if DECSTATION
+	default y if MACH_DECSTATION
 	help
 	  Say Y here if you would like to be able to read the hard disk
 	  partition table format used by DEC (now Compaq) Ultrix machines.
diff -purN linux-2.6.11-rc2-bk10/fs/partitions/check.c linux-2.6.11-rc3/fs/partitions/check.c
--- linux-2.6.11-rc2-bk10/fs/partitions/check.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/fs/partitions/check.c	2005-02-03 02:56:48.000000000 +0100
@@ -73,6 +73,9 @@ static int (*check_part[])(struct parsed
 #ifdef CONFIG_EFI_PARTITION
 	efi_partition,		/* this must come before msdos */
 #endif
+#ifdef CONFIG_SGI_PARTITION
+	sgi_partition,
+#endif
 #ifdef CONFIG_LDM_PARTITION
 	ldm_partition,		/* this must come before msdos */
 #endif
@@ -97,9 +100,6 @@ static int (*check_part[])(struct parsed
 #ifdef CONFIG_MAC_PARTITION
 	mac_partition,
 #endif
-#ifdef CONFIG_SGI_PARTITION
-	sgi_partition,
-#endif
 #ifdef CONFIG_ULTRIX_PARTITION
 	ultrix_partition,
 #endif
diff -purN linux-2.6.11-rc2-bk10/fs/partitions/sgi.c linux-2.6.11-rc3/fs/partitions/sgi.c
--- linux-2.6.11-rc2-bk10/fs/partitions/sgi.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/fs/partitions/sgi.c	2005-02-03 02:55:15.000000000 +0100
@@ -69,8 +69,12 @@ int sgi_partition(struct parsed_partitio
 	for(i = 0; i < 16; i++, p++) {
 		blocks = be32_to_cpu(p->num_blocks);
 		start  = be32_to_cpu(p->first_block);
-		if (blocks)
-			put_partition(state, slot++, start, blocks);
+		if (blocks) {
+			put_partition(state, slot, start, blocks);
+			if (be32_to_cpu(p->type) == LINUX_RAID_PARTITION)
+				state->parts[slot].flags = 1;
+		}
+		slot++;
 	}
 	printk("\n");
 	put_dev_sector(sect);
diff -purN linux-2.6.11-rc2-bk10/fs/proc/base.c linux-2.6.11-rc3/fs/proc/base.c
--- linux-2.6.11-rc2-bk10/fs/proc/base.c	2005-01-22 02:48:27.000000000 +0100
+++ linux-2.6.11-rc3/fs/proc/base.c	2005-02-03 02:56:10.000000000 +0100
@@ -71,7 +71,12 @@ enum pid_directory_inos {
 	PROC_TGID_ATTR_EXEC,
 	PROC_TGID_ATTR_FSCREATE,
 #endif
+#ifdef CONFIG_AUDITSYSCALL
+	PROC_TGID_LOGINUID,
+#endif
 	PROC_TGID_FD_DIR,
+	PROC_TGID_OOM_SCORE,
+	PROC_TGID_OOM_ADJUST,
 	PROC_TID_INO,
 	PROC_TID_STATUS,
 	PROC_TID_MEM,
@@ -97,7 +102,12 @@ enum pid_directory_inos {
 	PROC_TID_ATTR_EXEC,
 	PROC_TID_ATTR_FSCREATE,
 #endif
+#ifdef CONFIG_AUDITSYSCALL
+	PROC_TID_LOGINUID,
+#endif
 	PROC_TID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
+	PROC_TID_OOM_SCORE,
+	PROC_TID_OOM_ADJUST,
 };
 
 struct pid_entry {
@@ -133,6 +143,11 @@ static struct pid_entry tgid_base_stuff[
 #ifdef CONFIG_SCHEDSTATS
 	E(PROC_TGID_SCHEDSTAT, "schedstat", S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TGID_OOM_SCORE, "oom_score",S_IFREG|S_IRUGO),
+	E(PROC_TGID_OOM_ADJUST,"oom_adj", S_IFREG|S_IRUGO|S_IWUSR),
+#ifdef CONFIG_AUDITSYSCALL
+	E(PROC_TGID_LOGINUID, "loginuid", S_IFREG|S_IWUSR|S_IRUGO),
+#endif
 	{0,0,NULL,0}
 };
 static struct pid_entry tid_base_stuff[] = {
@@ -158,6 +173,11 @@ static struct pid_entry tid_base_stuff[]
 #ifdef CONFIG_SCHEDSTATS
 	E(PROC_TID_SCHEDSTAT, "schedstat",S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TID_OOM_SCORE,  "oom_score",S_IFREG|S_IRUGO),
+	E(PROC_TID_OOM_ADJUST, "oom_adj", S_IFREG|S_IRUGO|S_IWUSR),
+#ifdef CONFIG_AUDITSYSCALL
+	E(PROC_TID_LOGINUID, "loginuid", S_IFREG|S_IWUSR|S_IRUGO),
+#endif
 	{0,0,NULL,0}
 };
 
@@ -384,6 +404,18 @@ static int proc_pid_schedstat(struct tas
 }
 #endif
 
+/* The badness from the OOM killer */
+unsigned long badness(struct task_struct *p, unsigned long uptime);
+static int proc_oom_score(struct task_struct *task, char *buffer)
+{
+	unsigned long points;
+	struct timespec uptime;
+
+	do_posix_clock_monotonic_gettime(&uptime);
+	points = badness(task, uptime.tv_sec);
+	return sprintf(buffer, "%lu\n", points);
+}
+
 /************************************************************************/
 /*                       Here the fs part begins                        */
 /************************************************************************/
@@ -657,10 +689,125 @@ static struct file_operations proc_mem_o
 	.open		= mem_open,
 };
 
+static ssize_t oom_adjust_read(struct file *file, char *buf,
+				size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[8];
+	size_t len;
+	int oom_adjust = task->oomkilladj;
+	loff_t __ppos = *ppos;
+
+	len = sprintf(buffer, "%i\n", oom_adjust);
+	if (__ppos >= len)
+		return 0;
+	if (count > len-__ppos)
+		count = len-__ppos;
+	if (copy_to_user(buf, buffer + __ppos, count))
+		return -EFAULT;
+	*ppos = __ppos + count;
+	return count;
+}
+
+static ssize_t oom_adjust_write(struct file *file, const char *buf,
+				size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[8], *end;
+	int oom_adjust;
+
+	if (!capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+	memset(buffer, 0, 8);
+	if (count > 6)
+		count = 6;
+	if (copy_from_user(buffer, buf, count))
+		return -EFAULT;
+	oom_adjust = simple_strtol(buffer, &end, 0);
+	if (oom_adjust < -16 || oom_adjust > 15)
+		return -EINVAL;
+	if (*end == '\n')
+		end++;
+	task->oomkilladj = oom_adjust;
+	if (end - buffer == 0)
+		return -EIO;
+	return end - buffer;
+}
+
+static struct file_operations proc_oom_adjust_operations = {
+	read:		oom_adjust_read,
+	write:		oom_adjust_write,
+};
+
 static struct inode_operations proc_mem_inode_operations = {
 	.permission	= proc_permission,
 };
 
+#ifdef CONFIG_AUDITSYSCALL
+#define TMPBUFLEN 21
+static ssize_t proc_loginuid_read(struct file * file, char __user * buf,
+				  size_t count, loff_t *ppos)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+	struct task_struct *task = proc_task(inode);
+	ssize_t length;
+	char tmpbuf[TMPBUFLEN];
+
+	length = scnprintf(tmpbuf, TMPBUFLEN, "%u",
+				audit_get_loginuid(task->audit_context));
+	return simple_read_from_buffer(buf, count, ppos, tmpbuf, length);
+}
+
+static ssize_t proc_loginuid_write(struct file * file, const char __user * buf,
+				   size_t count, loff_t *ppos)
+{
+	struct inode * inode = file->f_dentry->d_inode;
+	char *page, *tmp;
+	ssize_t length;
+	struct task_struct *task = proc_task(inode);
+	uid_t loginuid;
+
+	if (!capable(CAP_AUDIT_CONTROL))
+		return -EPERM;
+
+	if (current != task)
+		return -EPERM;
+
+	if (count > PAGE_SIZE)
+		count = PAGE_SIZE;
+
+	if (*ppos != 0) {
+		/* No partial writes. */
+		return -EINVAL;
+	}
+	page = (char*)__get_free_page(GFP_USER);
+	if (!page)
+		return -ENOMEM;
+	length = -EFAULT;
+	if (copy_from_user(page, buf, count))
+		goto out_free_page;
+
+	loginuid = simple_strtoul(page, &tmp, 10);
+	if (tmp == page) {
+		length = -EINVAL;
+		goto out_free_page;
+
+	}
+	length = audit_set_loginuid(task->audit_context, loginuid);
+	if (likely(length == 0))
+		length = count;
+
+out_free_page:
+	free_page((unsigned long) page);
+	return length;
+}
+
+static struct file_operations proc_loginuid_operations = {
+	.read		= proc_loginuid_read,
+	.write		= proc_loginuid_write,
+};
+#endif
+
 static int proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	struct inode *inode = dentry->d_inode;
@@ -1336,6 +1483,21 @@ static struct dentry *proc_pident_lookup
 			ei->op.proc_read = proc_pid_schedstat;
 			break;
 #endif
+		case PROC_TID_OOM_SCORE:
+		case PROC_TGID_OOM_SCORE:
+			inode->i_fop = &proc_info_file_operations;
+			ei->op.proc_read = proc_oom_score;
+			break;
+		case PROC_TID_OOM_ADJUST:
+		case PROC_TGID_OOM_ADJUST:
+			inode->i_fop = &proc_oom_adjust_operations;
+			break;
+#ifdef CONFIG_AUDITSYSCALL
+		case PROC_TID_LOGINUID:
+		case PROC_TGID_LOGINUID:
+			inode->i_fop = &proc_loginuid_operations;
+			break;
+#endif
 		default:
 			printk("procfs: impossible type (%d)",p->type);
 			iput(inode);
diff -purN linux-2.6.11-rc2-bk10/fs/proc/generic.c linux-2.6.11-rc3/fs/proc/generic.c
--- linux-2.6.11-rc2-bk10/fs/proc/generic.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/fs/proc/generic.c	2005-02-03 02:57:04.000000000 +0100
@@ -60,7 +60,7 @@ proc_file_read(struct file *file, char _
 		return -ENOMEM;
 
 	while ((nbytes > 0) && !eof) {
-		count = min_t(ssize_t, PROC_BLOCK_SIZE, nbytes);
+		count = min_t(size_t, PROC_BLOCK_SIZE, nbytes);
 
 		start = NULL;
 		if (dp->get_info) {
diff -purN linux-2.6.11-rc2-bk10/fs/reiserfs/file.c linux-2.6.11-rc3/fs/reiserfs/file.c
--- linux-2.6.11-rc2-bk10/fs/reiserfs/file.c	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc3/fs/reiserfs/file.c	2005-02-03 02:54:39.000000000 +0100
@@ -588,7 +588,7 @@ error_exit:
 
 /* Unlock pages prepared by reiserfs_prepare_file_region_for_write */
 static void reiserfs_unprepare_pages(struct page **prepared_pages, /* list of locked pages */
-			      int num_pages /* amount of pages */) {
+			      size_t num_pages /* amount of pages */) {
     int i; // loop counter
 
     for (i=0; i < num_pages ; i++) {
@@ -619,7 +619,7 @@ static int reiserfs_copy_from_user_to_fi
     int offset; // offset in page
 
     for ( i = 0, offset = (pos & (PAGE_CACHE_SIZE-1)); i < num_pages ; i++,offset=0) {
-	int count = min_t(int,PAGE_CACHE_SIZE-offset,write_bytes); // How much of bytes to write to this page
+	size_t count = min_t(size_t,PAGE_CACHE_SIZE-offset,write_bytes); // How much of bytes to write to this page
 	struct page *page=prepared_pages[i]; // Current page we process.
 
 	fault_in_pages_readable( buf, count);
@@ -718,8 +718,8 @@ static int reiserfs_submit_file_region_f
 				struct reiserfs_transaction_handle *th,
 				struct inode *inode,
 				loff_t pos, /* Writing position offset */
-				int num_pages, /* Number of pages to write */
-				int write_bytes, /* number of bytes to write */
+				size_t num_pages, /* Number of pages to write */
+				size_t write_bytes, /* number of bytes to write */
 				struct page **prepared_pages /* list of pages */
 				)
 {
@@ -854,9 +854,9 @@ static int reiserfs_check_for_tail_and_c
 static int reiserfs_prepare_file_region_for_write(
 				struct inode *inode /* Inode of the file */,
 				loff_t pos, /* position in the file */
-				int num_pages, /* number of pages to
+				size_t num_pages, /* number of pages to
 					          prepare */
-				int write_bytes, /* Amount of bytes to be
+				size_t write_bytes, /* Amount of bytes to be
 						    overwritten from
 						    @pos */
 				struct page **prepared_pages /* pointer to array
@@ -1252,10 +1252,9 @@ static ssize_t reiserfs_file_write( stru
     while ( count > 0) {
 	/* This is the main loop in which we running until some error occures
 	   or until we write all of the data. */
-	int num_pages;/* amount of pages we are going to write this iteration */
-	int write_bytes; /* amount of bytes to write during this iteration */
-	int blocks_to_allocate; /* how much blocks we need to allocate for
-				   this iteration */
+	size_t num_pages;/* amount of pages we are going to write this iteration */
+	size_t write_bytes; /* amount of bytes to write during this iteration */
+	size_t blocks_to_allocate; /* how much blocks we need to allocate for this iteration */
         
         /*  (pos & (PAGE_CACHE_SIZE-1)) is an idiom for offset into a page of pos*/
 	num_pages = !!((pos+count) & (PAGE_CACHE_SIZE - 1)) + /* round up partial
@@ -1269,7 +1268,7 @@ static ssize_t reiserfs_file_write( stru
 	    /* If we were asked to write more data than we want to or if there
 	       is not that much space, then we shorten amount of data to write
 	       for this iteration. */
-	    num_pages = min_t(int, REISERFS_WRITE_PAGES_AT_A_TIME, reiserfs_can_fit_pages(inode->i_sb));
+	    num_pages = min_t(size_t, REISERFS_WRITE_PAGES_AT_A_TIME, reiserfs_can_fit_pages(inode->i_sb));
 	    /* Also we should not forget to set size in bytes accordingly */
 	    write_bytes = (num_pages << PAGE_CACHE_SHIFT) - 
 			    (pos & (PAGE_CACHE_SIZE-1));
@@ -1295,7 +1294,7 @@ static ssize_t reiserfs_file_write( stru
 	    // But overwriting files on absolutelly full volumes would not
 	    // be very efficient. Well, people are not supposed to fill
 	    // 100% of disk space anyway.
-	    write_bytes = min_t(int, count, inode->i_sb->s_blocksize - (pos & (inode->i_sb->s_blocksize - 1)));
+	    write_bytes = min_t(size_t, count, inode->i_sb->s_blocksize - (pos & (inode->i_sb->s_blocksize - 1)));
 	    num_pages = 1;
 	    // No blocks were claimed before, so do it now.
 	    reiserfs_claim_blocks_to_be_allocated(inode->i_sb, 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits));
diff -purN linux-2.6.11-rc2-bk10/fs/udf/balloc.c linux-2.6.11-rc3/fs/udf/balloc.c
--- linux-2.6.11-rc2-bk10/fs/udf/balloc.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/fs/udf/balloc.c	2005-02-03 02:55:23.000000000 +0100
@@ -148,6 +148,7 @@ static void udf_bitmap_free_blocks(struc
 	struct udf_bitmap *bitmap,
 	kernel_lb_addr bloc, uint32_t offset, uint32_t count)
 {
+	struct udf_sb_info *sbi = UDF_SB(sb);
 	struct buffer_head * bh = NULL;
 	unsigned long block;
 	unsigned long block_group;
@@ -156,7 +157,7 @@ static void udf_bitmap_free_blocks(struc
 	int bitmap_nr;
 	unsigned long overflow;
 
-	lock_super(sb);
+	down(&sbi->s_alloc_sem);
 	if (bloc.logicalBlockNum < 0 ||
 		(bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum))
 	{
@@ -215,7 +216,7 @@ error_return:
 	sb->s_dirt = 1;
 	if (UDF_SB_LVIDBH(sb))
 		mark_buffer_dirty(UDF_SB_LVIDBH(sb));
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 	return;
 }
 
@@ -224,13 +225,13 @@ static int udf_bitmap_prealloc_blocks(st
 	struct udf_bitmap *bitmap, uint16_t partition, uint32_t first_block,
 	uint32_t block_count)
 {
+	struct udf_sb_info *sbi = UDF_SB(sb);
 	int alloc_count = 0;
 	int bit, block, block_group, group_start;
 	int nr_groups, bitmap_nr;
 	struct buffer_head *bh;
 
-	lock_super(sb);
-
+	down(&sbi->s_alloc_sem);
 	if (first_block < 0 || first_block >= UDF_SB_PARTLEN(sb, partition))
 		goto out;
 
@@ -279,7 +280,7 @@ out:
 		mark_buffer_dirty(UDF_SB_LVIDBH(sb));
 	}
 	sb->s_dirt = 1;
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 	return alloc_count;
 }
 
@@ -287,6 +288,7 @@ static int udf_bitmap_new_block(struct s
 	struct inode * inode,
 	struct udf_bitmap *bitmap, uint16_t partition, uint32_t goal, int *err)
 {
+	struct udf_sb_info *sbi = UDF_SB(sb);
 	int newbit, bit=0, block, block_group, group_start;
 	int end_goal, nr_groups, bitmap_nr, i;
 	struct buffer_head *bh = NULL;
@@ -294,7 +296,7 @@ static int udf_bitmap_new_block(struct s
 	int newblock = 0;
 
 	*err = -ENOSPC;
-	lock_super(sb);
+	down(&sbi->s_alloc_sem);
 
 repeat:
 	if (goal < 0 || goal >= UDF_SB_PARTLEN(sb, partition))
@@ -367,7 +369,7 @@ repeat:
 	}
 	if (i >= (nr_groups*2))
 	{
-		unlock_super(sb);
+		up(&sbi->s_alloc_sem);
 		return newblock;
 	}
 	if (bit < sb->s_blocksize << 3)
@@ -376,7 +378,7 @@ repeat:
 		bit = udf_find_next_one_bit(bh->b_data, sb->s_blocksize << 3, group_start << 3);
 	if (bit >= sb->s_blocksize << 3)
 	{
-		unlock_super(sb);
+		up(&sbi->s_alloc_sem);
 		return 0;
 	}
 
@@ -390,7 +392,7 @@ got_block:
 	 */
 	if (inode && DQUOT_ALLOC_BLOCK(inode, 1))
 	{
-		unlock_super(sb);
+		up(&sbi->s_alloc_sem);
 		*err = -EDQUOT;
 		return 0;
 	}
@@ -413,13 +415,13 @@ got_block:
 		mark_buffer_dirty(UDF_SB_LVIDBH(sb));
 	}
 	sb->s_dirt = 1;
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 	*err = 0;
 	return newblock;
 
 error_return:
 	*err = -EIO;
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 	return 0;
 }
 
@@ -428,6 +430,7 @@ static void udf_table_free_blocks(struct
 	struct inode * table,
 	kernel_lb_addr bloc, uint32_t offset, uint32_t count)
 {
+	struct udf_sb_info *sbi = UDF_SB(sb);
 	uint32_t start, end;
 	uint32_t nextoffset, oextoffset, elen;
 	kernel_lb_addr nbloc, obloc, eloc;
@@ -435,7 +438,7 @@ static void udf_table_free_blocks(struct
 	int8_t etype;
 	int i;
 
-	lock_super(sb);
+	down(&sbi->s_alloc_sem);
 	if (bloc.logicalBlockNum < 0 ||
 		(bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum))
 	{
@@ -669,7 +672,7 @@ static void udf_table_free_blocks(struct
 
 error_return:
 	sb->s_dirt = 1;
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 	return;
 }
 
@@ -678,6 +681,7 @@ static int udf_table_prealloc_blocks(str
 	struct inode *table, uint16_t partition, uint32_t first_block,
 	uint32_t block_count)
 {
+	struct udf_sb_info *sbi = UDF_SB(sb);
 	int alloc_count = 0;
 	uint32_t extoffset, elen, adsize;
 	kernel_lb_addr bloc, eloc;
@@ -694,8 +698,7 @@ static int udf_table_prealloc_blocks(str
 	else
 		return 0;
 
-	lock_super(sb);
-
+	down(&sbi->s_alloc_sem);
 	extoffset = sizeof(struct unallocSpaceEntry);
 	bloc = UDF_I_LOCATION(table);
 
@@ -739,7 +742,7 @@ static int udf_table_prealloc_blocks(str
 		mark_buffer_dirty(UDF_SB_LVIDBH(sb));
 		sb->s_dirt = 1;
 	}
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 	return alloc_count;
 }
 
@@ -747,6 +750,7 @@ static int udf_table_new_block(struct su
 	struct inode * inode,
 	struct inode *table, uint16_t partition, uint32_t goal, int *err)
 {
+	struct udf_sb_info *sbi = UDF_SB(sb);
 	uint32_t spread = 0xFFFFFFFF, nspread = 0xFFFFFFFF;
 	uint32_t newblock = 0, adsize;
 	uint32_t extoffset, goal_extoffset, elen, goal_elen = 0;
@@ -763,8 +767,7 @@ static int udf_table_new_block(struct su
 	else
 		return newblock;
 
-	lock_super(sb);
-
+	down(&sbi->s_alloc_sem);
 	if (goal < 0 || goal >= UDF_SB_PARTLEN(sb, partition))
 		goal = 0;
 
@@ -814,7 +817,7 @@ static int udf_table_new_block(struct su
 	if (spread == 0xFFFFFFFF)
 	{
 		udf_release_data(goal_bh);
-		unlock_super(sb);
+		up(&sbi->s_alloc_sem);
 		return 0;
 	}
 
@@ -830,7 +833,7 @@ static int udf_table_new_block(struct su
 	if (inode && DQUOT_ALLOC_BLOCK(inode, 1))
 	{
 		udf_release_data(goal_bh);
-		unlock_super(sb);
+		up(&sbi->s_alloc_sem);
 		*err = -EDQUOT;
 		return 0;
 	}
@@ -849,7 +852,7 @@ static int udf_table_new_block(struct su
 	}
 
 	sb->s_dirt = 1;
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 	*err = 0;
 	return newblock;
 }
diff -purN linux-2.6.11-rc2-bk10/fs/udf/ialloc.c linux-2.6.11-rc3/fs/udf/ialloc.c
--- linux-2.6.11-rc2-bk10/fs/udf/ialloc.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/fs/udf/ialloc.c	2005-02-03 02:55:50.000000000 +0100
@@ -35,11 +35,8 @@
 
 void udf_free_inode(struct inode * inode)
 {
-	struct super_block * sb = inode->i_sb;
-	int is_directory;
-	unsigned long ino;
-
-	ino = inode->i_ino;
+	struct super_block *sb = inode->i_sb;
+	struct udf_sb_info *sbi = UDF_SB(sb);
 
 	/*
 	 * Note: we must free any quota before locking the superblock,
@@ -48,36 +45,32 @@ void udf_free_inode(struct inode * inode
 	DQUOT_FREE_INODE(inode);
 	DQUOT_DROP(inode);
 
-	lock_super(sb);
-
-	is_directory = S_ISDIR(inode->i_mode);
-
 	clear_inode(inode);
 
-	if (UDF_SB_LVIDBH(sb))
-	{
-		if (is_directory)
+	down(&sbi->s_alloc_sem);
+	if (sbi->s_lvidbh) {
+		if (S_ISDIR(inode->i_mode))
 			UDF_SB_LVIDIU(sb)->numDirs =
 				cpu_to_le32(le32_to_cpu(UDF_SB_LVIDIU(sb)->numDirs) - 1);
 		else
 			UDF_SB_LVIDIU(sb)->numFiles =
 				cpu_to_le32(le32_to_cpu(UDF_SB_LVIDIU(sb)->numFiles) - 1);
 		
-		mark_buffer_dirty(UDF_SB_LVIDBH(sb));
+		mark_buffer_dirty(sbi->s_lvidbh);
 	}
-	unlock_super(sb);
+	up(&sbi->s_alloc_sem);
 
 	udf_free_blocks(sb, NULL, UDF_I_LOCATION(inode), 0, 1);
 }
 
 struct inode * udf_new_inode (struct inode *dir, int mode, int * err)
 {
-	struct super_block *sb;
+	struct super_block *sb = dir->i_sb;
+	struct udf_sb_info *sbi = UDF_SB(sb);
 	struct inode * inode;
 	int block;
 	uint32_t start = UDF_I_LOCATION(dir).logicalBlockNum;
 
-	sb = dir->i_sb;
 	inode = new_inode(sb);
 
 	if (!inode)
@@ -94,8 +87,8 @@ struct inode * udf_new_inode (struct ino
 		iput(inode);
 		return NULL;
 	}
-	lock_super(sb);
 
+	down(&sbi->s_alloc_sem);
 	UDF_I_UNIQUE(inode) = 0;
 	UDF_I_LENEXTENTS(inode) = 0;
 	UDF_I_NEXT_ALLOC_BLOCK(inode) = 0;
@@ -160,8 +153,8 @@ struct inode * udf_new_inode (struct ino
 		UDF_I_CRTIME(inode) = current_fs_time(inode->i_sb);
 	insert_inode_hash(inode);
 	mark_inode_dirty(inode);
+	up(&sbi->s_alloc_sem);
 
-	unlock_super(sb);
 	if (DQUOT_ALLOC_INODE(inode))
 	{
 		DQUOT_DROP(inode);
diff -purN linux-2.6.11-rc2-bk10/fs/udf/super.c linux-2.6.11-rc3/fs/udf/super.c
--- linux-2.6.11-rc2-bk10/fs/udf/super.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/fs/udf/super.c	2005-02-03 02:56:11.000000000 +0100
@@ -1504,6 +1504,8 @@ static int udf_fill_super(struct super_b
 	sb->s_fs_info = sbi;
 	memset(UDF_SB(sb), 0x00, sizeof(struct udf_sb_info));
 
+	init_MUTEX(&sbi->s_alloc_sem);
+
 	if (!udf_parse_options((char *)options, &uopt))
 		goto error_out;
 
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/Kconfig linux-2.6.11-rc3/fs/xfs/Kconfig
--- linux-2.6.11-rc2-bk10/fs/xfs/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/Kconfig	2005-02-03 02:55:51.000000000 +0100
@@ -0,0 +1,85 @@
+menu "XFS support"
+
+config XFS_FS
+	tristate "XFS filesystem support"
+	select EXPORTFS if NFSD!=n
+	help
+	  XFS is a high performance journaling filesystem which originated
+	  on the SGI IRIX platform.  It is completely multi-threaded, can
+	  support large files and large filesystems, extended attributes,
+	  variable block sizes, is extent based, and makes extensive use of
+	  Btrees (directories, extents, free space) to aid both performance
+	  and scalability.
+
+	  Refer to the documentation at <http://oss.sgi.com/projects/xfs/>
+	  for complete details.  This implementation is on-disk compatible
+	  with the IRIX version of XFS.
+
+	  To compile this file system support as a module, choose M here: the
+	  module will be called xfs.  Be aware, however, that if the file
+	  system of your root partition is compiled as a module, you'll need
+	  to use an initial ramdisk (initrd) to boot.
+
+config XFS_EXPORT
+	bool
+	default y if XFS_FS && EXPORTFS
+
+config XFS_RT
+	bool "Realtime support (EXPERIMENTAL)"
+	depends on XFS_FS && EXPERIMENTAL
+	help
+	  If you say Y here you will be able to mount and use XFS filesystems
+	  which contain a realtime subvolume. The realtime subvolume is a
+	  separate area of disk space where only file data is stored. The
+	  realtime subvolume is designed to provide very deterministic
+	  data rates suitable for media streaming applications.
+
+	  See the xfs man page in section 5 for a bit more information.
+
+	  This feature is unsupported at this time, is not yet fully
+	  functional, and may cause serious problems.
+
+	  If unsure, say N.
+
+config XFS_QUOTA
+	bool "Quota support"
+	depends on XFS_FS
+	help
+	  If you say Y here, you will be able to set limits for disk usage on
+	  a per user and/or a per group basis under XFS.  XFS considers quota
+	  information as filesystem metadata and uses journaling to provide a
+	  higher level guarantee of consistency.  The on-disk data format for
+	  quota is also compatible with the IRIX version of XFS, allowing a
+	  filesystem to be migrated between Linux and IRIX without any need
+	  for conversion.
+
+	  If unsure, say N.  More comprehensive documentation can be found in
+	  README.quota in the xfsprogs package.  XFS quota can be used either
+	  with or without the generic quota support enabled (CONFIG_QUOTA) -
+	  they are completely independent subsystems.
+
+config XFS_SECURITY
+	bool "Security Label support"
+	depends on XFS_FS
+	help
+	  Security labels support alternative access control models
+	  implemented by security modules like SELinux.  This option
+	  enables an extended attribute namespace for inode security
+	  labels in the XFS filesystem.
+
+	  If you are not using a security module that requires using
+	  extended attributes for inode security labels, say N.
+
+config XFS_POSIX_ACL
+	bool "POSIX ACL support"
+	depends on XFS_FS
+	help
+	  POSIX Access Control Lists (ACLs) support permissions for users and
+	  groups beyond the owner/group/world scheme.
+
+	  To learn more about Access Control Lists, visit the POSIX ACLs for
+	  Linux website <http://acl.bestbits.at/>.
+
+	  If you don't know what Access Control Lists are, say N.
+
+endmenu
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/Makefile linux-2.6.11-rc3/fs/xfs/Makefile
--- linux-2.6.11-rc2-bk10/fs/xfs/Makefile	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/Makefile	2005-02-03 02:57:16.000000000 +0100
@@ -70,6 +70,7 @@ xfs-$(CONFIG_XFS_POSIX_ACL)	+= xfs_acl.o
 xfs-$(CONFIG_PROC_FS)		+= linux-2.6/xfs_stats.o
 xfs-$(CONFIG_SYSCTL)		+= linux-2.6/xfs_sysctl.o
 xfs-$(CONFIG_COMPAT)		+= linux-2.6/xfs_ioctl32.o
+xfs-$(CONFIG_XFS_EXPORT)	+= linux-2.6/xfs_export.o
 
 
 xfs-y				+= xfs_alloc.o \
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/kmem.h linux-2.6.11-rc3/fs/xfs/linux-2.6/kmem.h
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/kmem.h	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/kmem.h	2005-02-03 02:57:04.000000000 +0100
@@ -94,9 +94,9 @@ static __inline unsigned int kmem_flags_
 #endif
 
 	if (flags & KM_NOSLEEP) {
-		lflags = GFP_ATOMIC;
+		lflags |= GFP_ATOMIC;
 	} else {
-		lflags = GFP_KERNEL;
+		lflags |= GFP_KERNEL;
 
 		/* avoid recusive callbacks to filesystem during transactions */
 		if (PFLAGS_TEST_FSTRANS() || (flags & KM_NOFS))
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_aops.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_aops.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_aops.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_aops.c	2005-02-03 02:57:17.000000000 +0100
@@ -71,7 +71,7 @@ xfs_page_trace(
 	bhv_desc_t	*bdp;
 	vnode_t		*vp = LINVFS_GET_VP(inode);
 	loff_t		isize = i_size_read(inode);
-	loff_t		offset = page->index << PAGE_CACHE_SHIFT;
+	loff_t		offset = (loff_t)page->index << PAGE_CACHE_SHIFT;
 	int		delalloc = -1, unmapped = -1, unwritten = -1;
 
 	if (page_has_buffers(page))
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_buf.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_buf.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_buf.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_buf.c	2005-02-03 02:54:59.000000000 +0100
@@ -53,6 +53,7 @@
 #include <linux/workqueue.h>
 #include <linux/percpu.h>
 #include <linux/blkdev.h>
+#include <linux/hash.h>
 
 #include "xfs_linux.h"
 
@@ -127,34 +128,71 @@ ktrace_t *pagebuf_trace_buf;
 	kmem_zone_free(pagebuf_cache, (pb));
 
 /*
- * Pagebuf hashing
- */
+ * Page Region interfaces.
+ *
+ * For pages in filesystems where the blocksize is smaller than the
+ * pagesize, we use the page->private field (long) to hold a bitmap
+ * of uptodate regions within the page.
+ *
+ * Each such region is "bytes per page / bits per long" bytes long.
+ *
+ * NBPPR == number-of-bytes-per-page-region
+ * BTOPR == bytes-to-page-region (rounded up)
+ * BTOPRT == bytes-to-page-region-truncated (rounded down)
+ */
+#if (BITS_PER_LONG == 32)
+#define PRSHIFT		(PAGE_CACHE_SHIFT - 5)	/* (32 == 1<<5) */
+#elif (BITS_PER_LONG == 64)
+#define PRSHIFT		(PAGE_CACHE_SHIFT - 6)	/* (64 == 1<<6) */
+#else
+#error BITS_PER_LONG must be 32 or 64
+#endif
+#define NBPPR		(PAGE_CACHE_SIZE/BITS_PER_LONG)
+#define BTOPR(b)	(((unsigned int)(b) + (NBPPR - 1)) >> PRSHIFT)
+#define BTOPRT(b)	(((unsigned int)(b) >> PRSHIFT))
 
-#define NBITS	8
-#define NHASH	(1<<NBITS)
+STATIC unsigned long
+page_region_mask(
+	size_t		offset,
+	size_t		length)
+{
+	unsigned long	mask;
+	int		first, final;
 
-typedef struct {
-	struct list_head	pb_hash;
-	spinlock_t		pb_hash_lock;
-} pb_hash_t;
+	first = BTOPR(offset);
+	final = BTOPRT(offset + length - 1);
+	first = min(first, final);
 
-STATIC pb_hash_t	pbhash[NHASH];
-#define pb_hash(pb)	&pbhash[pb->pb_hash_index]
+	mask = ~0UL;
+	mask <<= BITS_PER_LONG - (final - first);
+	mask >>= BITS_PER_LONG - (final);
 
-STATIC int
-_bhash(
-	struct block_device *bdev,
-	loff_t		base)
-{
-	int		bit, hval;
-
-	base >>= 9;
-	base ^= (unsigned long)bdev / L1_CACHE_BYTES;
-	for (bit = hval = 0; base && bit < sizeof(base) * 8; bit += NBITS) {
-		hval ^= (int)base & (NHASH-1);
-		base >>= NBITS;
-	}
-	return hval;
+	ASSERT(offset + length <= PAGE_CACHE_SIZE);
+	ASSERT((final - first) < BITS_PER_LONG && (final - first) >= 0);
+
+	return mask;
+}
+
+STATIC inline void
+set_page_region(
+	struct page	*page,
+	size_t		offset,
+	size_t		length)
+{
+	page->private |= page_region_mask(offset, length);
+	if (page->private == ~0UL)
+		SetPageUptodate(page);
+}
+
+STATIC inline int
+test_page_region(
+	struct page	*page,
+	size_t		offset,
+	size_t		length)
+{
+	unsigned long	mask = page_region_mask(offset, length);
+
+	return (mask && (page->private & mask) == mask);
 }
 
 /*
@@ -179,8 +217,8 @@ free_address(
 {
 	a_list_t	*aentry;
 
-	aentry = kmalloc(sizeof(a_list_t), GFP_ATOMIC);
-	if (aentry) {
+	aentry = kmalloc(sizeof(a_list_t), GFP_ATOMIC & ~__GFP_HIGH);
+	if (likely(aentry)) {
 		spin_lock(&as_lock);
 		aentry->next = as_free_head;
 		aentry->vm_addr = addr;
@@ -340,7 +378,6 @@ _pagebuf_lookup_pages(
 	uint			flags)
 {
 	struct address_space	*mapping = bp->pb_target->pbr_mapping;
-	unsigned int		sectorshift = bp->pb_target->pbr_sshift;
 	size_t			blocksize = bp->pb_target->pbr_bsize;
 	size_t			size = bp->pb_count_desired;
 	size_t			nbytes, offset;
@@ -400,22 +437,11 @@ _pagebuf_lookup_pages(
 
 		if (!PageUptodate(page)) {
 			page_count--;
-			if (blocksize == PAGE_CACHE_SIZE) {
+			if (blocksize >= PAGE_CACHE_SIZE) {
 				if (flags & PBF_READ)
 					bp->pb_locked = 1;
 			} else if (!PagePrivate(page)) {
-				unsigned long	j, range;
-
-				/*
-				 * In this case page->private holds a bitmap
-				 * of uptodate sectors within the page
-				 */
-				ASSERT(blocksize < PAGE_CACHE_SIZE);
-				range = (offset + nbytes) >> sectorshift;
-				for (j = offset >> sectorshift; j < range; j++)
-					if (!test_bit(j, &page->private))
-						break;
-				if (j == range)
+				if (test_page_region(page, offset, nbytes))
 					page_count++;
 			}
 		}
@@ -483,8 +509,8 @@ _pagebuf_map_pages(
  *	are unlocked.  No I/O is implied by this call.
  */
 xfs_buf_t *
-_pagebuf_find(				/* find buffer for block	*/
-	xfs_buftarg_t		*target,/* target for block		*/
+_pagebuf_find(
+	xfs_buftarg_t		*btp,	/* block device target		*/
 	loff_t			ioff,	/* starting offset of range	*/
 	size_t			isize,	/* length of range		*/
 	page_buf_flags_t	flags,	/* PBF_TRYLOCK			*/
@@ -492,59 +518,55 @@ _pagebuf_find(				/* find buffer for blo
 {
 	loff_t			range_base;
 	size_t			range_length;
-	int			hval;
-	pb_hash_t		*h;
+	xfs_bufhash_t		*hash;
 	xfs_buf_t		*pb, *n;
-	int			not_locked;
 
 	range_base = (ioff << BBSHIFT);
 	range_length = (isize << BBSHIFT);
 
-	/* Ensure we never do IOs smaller than the sector size */
-	BUG_ON(range_length < (1 << target->pbr_sshift));
+	/* Check for IOs smaller than the sector size / not sector aligned */
+	ASSERT(!(range_length < (1 << btp->pbr_sshift)));
+	ASSERT(!(range_base & (loff_t)btp->pbr_smask));
 
-	/* Ensure we never do IOs that are not sector aligned */
-	BUG_ON(range_base & (loff_t)target->pbr_smask);
+	hash = &btp->bt_hash[hash_long((unsigned long)ioff, btp->bt_hashshift)];
 
-	hval = _bhash(target->pbr_bdev, range_base);
-	h = &pbhash[hval];
+	spin_lock(&hash->bh_lock);
 
-	spin_lock(&h->pb_hash_lock);
-	list_for_each_entry_safe(pb, n, &h->pb_hash, pb_hash_list) {
-		if (pb->pb_target == target &&
-		    pb->pb_file_offset == range_base &&
+	list_for_each_entry_safe(pb, n, &hash->bh_list, pb_hash_list) {
+		ASSERT(btp == pb->pb_target);
+		if (pb->pb_file_offset == range_base &&
 		    pb->pb_buffer_length == range_length) {
-			/* If we look at something bring it to the
-			 * front of the list for next time
+			/*
+			 * If we look at something bring it to the
+			 * front of the list for next time.
 			 */
 			atomic_inc(&pb->pb_hold);
-			list_move(&pb->pb_hash_list, &h->pb_hash);
+			list_move(&pb->pb_hash_list, &hash->bh_list);
 			goto found;
 		}
 	}
 
 	/* No match found */
 	if (new_pb) {
-		_pagebuf_initialize(new_pb, target, range_base,
+		_pagebuf_initialize(new_pb, btp, range_base,
 				range_length, flags);
-		new_pb->pb_hash_index = hval;
-		list_add(&new_pb->pb_hash_list, &h->pb_hash);
+		new_pb->pb_hash = hash;
+		list_add(&new_pb->pb_hash_list, &hash->bh_list);
 	} else {
 		XFS_STATS_INC(pb_miss_locked);
 	}
 
-	spin_unlock(&h->pb_hash_lock);
-	return (new_pb);
+	spin_unlock(&hash->bh_lock);
+	return new_pb;
 
 found:
-	spin_unlock(&h->pb_hash_lock);
+	spin_unlock(&hash->bh_lock);
 
 	/* Attempt to get the semaphore without sleeping,
 	 * if this does not work then we need to drop the
 	 * spinlock and do a hard attempt on the semaphore.
 	 */
-	not_locked = down_trylock(&pb->pb_sema);
-	if (not_locked) {
+	if (down_trylock(&pb->pb_sema)) {
 		if (!(flags & PBF_TRYLOCK)) {
 			/* wait for buffer ownership */
 			PB_TRACE(pb, "get_lock", 0);
@@ -711,8 +733,6 @@ pagebuf_readahead(
 	bdi = target->pbr_mapping->backing_dev_info;
 	if (bdi_read_congested(bdi))
 		return;
-	if (bdi_write_congested(bdi))
-		return;
 
 	flags |= (PBF_TRYLOCK|PBF_ASYNC|PBF_READ_AHEAD);
 	xfs_buf_read_flags(target, ioff, isize, flags);
@@ -866,18 +886,29 @@ void
 pagebuf_rele(
 	xfs_buf_t		*pb)
 {
-	pb_hash_t		*hash = pb_hash(pb);
+	xfs_bufhash_t		*hash = pb->pb_hash;
 
 	PB_TRACE(pb, "rele", pb->pb_relse);
 
-	if (atomic_dec_and_lock(&pb->pb_hold, &hash->pb_hash_lock)) {
+	/*
+	 * pagebuf_lookup buffers are not hashed, not delayed write,
+	 * and don't have their own release routines.  Special case.
+	 */
+	if (unlikely(!hash)) {
+		ASSERT(!pb->pb_relse);
+		if (atomic_dec_and_test(&pb->pb_hold))
+			xfs_buf_free(pb);
+		return;
+	}
+
+	if (atomic_dec_and_lock(&pb->pb_hold, &hash->bh_lock)) {
 		int		do_free = 1;
 
 		if (pb->pb_relse) {
 			atomic_inc(&pb->pb_hold);
-			spin_unlock(&hash->pb_hash_lock);
+			spin_unlock(&hash->bh_lock);
 			(*(pb->pb_relse)) (pb);
-			spin_lock(&hash->pb_hash_lock);
+			spin_lock(&hash->bh_lock);
 			do_free = 0;
 		}
 
@@ -892,10 +923,10 @@ pagebuf_rele(
 
 		if (do_free) {
 			list_del_init(&pb->pb_hash_list);
-			spin_unlock(&hash->pb_hash_lock);
+			spin_unlock(&hash->bh_lock);
 			pagebuf_free(pb);
 		} else {
-			spin_unlock(&hash->pb_hash_lock);
+			spin_unlock(&hash->bh_lock);
 		}
 	}
 }
@@ -935,6 +966,7 @@ pagebuf_cond_lock(			/* lock buffer, if 
 	return(locked ? 0 : -EBUSY);
 }
 
+#ifdef DEBUG
 /*
  *	pagebuf_lock_value
  *
@@ -946,6 +978,7 @@ pagebuf_lock_value(
 {
 	return(atomic_read(&pb->pb_sema.count));
 }
+#endif
 
 /*
  *	pagebuf_lock
@@ -1216,7 +1249,6 @@ bio_end_io_pagebuf(
 {
 	xfs_buf_t		*pb = (xfs_buf_t *)bio->bi_private;
 	unsigned int		i, blocksize = pb->pb_target->pbr_bsize;
-	unsigned int		sectorshift = pb->pb_target->pbr_sshift;
 	struct bio_vec		*bvec = bio->bi_io_vec;
 
 	if (bio->bi_size)
@@ -1234,14 +1266,7 @@ bio_end_io_pagebuf(
 			SetPageUptodate(page);
 		} else if (!PagePrivate(page) &&
 				(pb->pb_flags & _PBF_PAGE_CACHE)) {
-			unsigned long	j, range;
-
-			ASSERT(blocksize < PAGE_CACHE_SIZE);
-			range = (bvec->bv_offset + bvec->bv_len) >> sectorshift;
-			for (j = bvec->bv_offset >> sectorshift; j < range; j++)
-				set_bit(j, &page->private);
-			if (page->private == (unsigned long)(PAGE_CACHE_SIZE-1))
-				SetPageUptodate(page);
+			set_page_region(page, bvec->bv_offset, bvec->bv_len);
 		}
 
 		if (_pagebuf_iolocked(pb)) {
@@ -1470,28 +1495,59 @@ pagebuf_iomove(
  */
 void
 xfs_wait_buftarg(
-	xfs_buftarg_t *target)
+	xfs_buftarg_t	*btp)
 {
-	xfs_buf_t	*pb, *n;
-	pb_hash_t	*h;
-	int		i;
+	xfs_buf_t	*bp, *n;
+	xfs_bufhash_t	*hash;
+	uint		i;
 
-	for (i = 0; i < NHASH; i++) {
-		h = &pbhash[i];
+	for (i = 0; i < (1 << btp->bt_hashshift); i++) {
+		hash = &btp->bt_hash[i];
 again:
-		spin_lock(&h->pb_hash_lock);
-		list_for_each_entry_safe(pb, n, &h->pb_hash, pb_hash_list) {
-			if (pb->pb_target == target &&
-					!(pb->pb_flags & PBF_FS_MANAGED)) {
-				spin_unlock(&h->pb_hash_lock);
+		spin_lock(&hash->bh_lock);
+		list_for_each_entry_safe(bp, n, &hash->bh_list, pb_hash_list) {
+			ASSERT(btp == bp->pb_target);
+			if (!(bp->pb_flags & PBF_FS_MANAGED)) {
+				spin_unlock(&hash->bh_lock);
 				delay(100);
 				goto again;
 			}
 		}
-		spin_unlock(&h->pb_hash_lock);
+		spin_unlock(&hash->bh_lock);
 	}
 }
 
+/*
+ * Allocate buffer hash table for a given target.
+ * For devices containing metadata (i.e. not the log/realtime devices)
+ * we need to allocate a much larger hash table.
+ */
+STATIC void
+xfs_alloc_bufhash(
+	xfs_buftarg_t		*btp,
+	int			external)
+{
+	unsigned int		i;
+
+	btp->bt_hashshift = external ? 3 : 8;	/* 8 or 256 buckets */
+	btp->bt_hashmask = (1 << btp->bt_hashshift) - 1;
+	btp->bt_hash = kmem_zalloc((1 << btp->bt_hashshift) *
+					sizeof(xfs_bufhash_t), KM_SLEEP);
+	for (i = 0; i < (1 << btp->bt_hashshift); i++) {
+		spin_lock_init(&btp->bt_hash[i].bh_lock);
+		INIT_LIST_HEAD(&btp->bt_hash[i].bh_list);
+	}
+}
+
+STATIC void
+xfs_free_bufhash(
+	xfs_buftarg_t		*btp)
+{
+	kmem_free(btp->bt_hash,
+			(1 << btp->bt_hashshift) * sizeof(xfs_bufhash_t));
+	btp->bt_hash = NULL;
+}
+
 void
 xfs_free_buftarg(
 	xfs_buftarg_t		*btp,
@@ -1500,6 +1556,7 @@ xfs_free_buftarg(
 	xfs_flush_buftarg(btp, 1);
 	if (external)
 		xfs_blkdev_put(btp->pbr_bdev);
+	xfs_free_bufhash(btp);
 	iput(btp->pbr_mapping->host);
 	kmem_free(btp, sizeof(*btp));
 }
@@ -1514,11 +1571,12 @@ xfs_incore_relse(
 	truncate_inode_pages(btp->pbr_mapping, 0LL);
 }
 
-int
-xfs_setsize_buftarg(
+STATIC int
+xfs_setsize_buftarg_flags(
 	xfs_buftarg_t		*btp,
 	unsigned int		blocksize,
-	unsigned int		sectorsize)
+	unsigned int		sectorsize,
+	int			verbose)
 {
 	btp->pbr_bsize = blocksize;
 	btp->pbr_sshift = ffs(sectorsize) - 1;
@@ -1530,9 +1588,42 @@ xfs_setsize_buftarg(
 			sectorsize, XFS_BUFTARG_NAME(btp));
 		return EINVAL;
 	}
+
+	if (verbose &&
+	    (PAGE_CACHE_SIZE / BITS_PER_LONG) > sectorsize) {
+		printk(KERN_WARNING
+			"XFS: %u byte sectors in use on device %s.  "
+			"This is suboptimal; %u or greater is ideal.\n",
+			sectorsize, XFS_BUFTARG_NAME(btp),
+			(unsigned int)PAGE_CACHE_SIZE / BITS_PER_LONG);
+	}
+
 	return 0;
 }
 
+/*
+* When allocating the initial buffer target we have not yet
+* read in the superblock, so don't know what sized sectors
+* are being used is at this early stage.  Play safe.
+*/
+STATIC int
+xfs_setsize_buftarg_early(
+	xfs_buftarg_t		*btp,
+	struct block_device	*bdev)
+{
+	return xfs_setsize_buftarg_flags(btp,
+			PAGE_CACHE_SIZE, bdev_hardsect_size(bdev), 0);
+}
+
+int
+xfs_setsize_buftarg(
+	xfs_buftarg_t		*btp,
+	unsigned int		blocksize,
+	unsigned int		sectorsize)
+{
+	return xfs_setsize_buftarg_flags(btp, blocksize, sectorsize, 1);
+}
+
 STATIC int
 xfs_mapping_buftarg(
 	xfs_buftarg_t		*btp,
@@ -1561,14 +1652,15 @@ xfs_mapping_buftarg(
 	mapping = &inode->i_data;
 	mapping->a_ops = &mapping_aops;
 	mapping->backing_dev_info = bdi;
-	mapping_set_gfp_mask(mapping, GFP_KERNEL);
+	mapping_set_gfp_mask(mapping, GFP_NOFS);
 	btp->pbr_mapping = mapping;
 	return 0;
 }
 
 xfs_buftarg_t *
 xfs_alloc_buftarg(
-	struct block_device	*bdev)
+	struct block_device	*bdev,
+	int			external)
 {
 	xfs_buftarg_t		*btp;
 
@@ -1576,10 +1668,11 @@ xfs_alloc_buftarg(
 
 	btp->pbr_dev =  bdev->bd_dev;
 	btp->pbr_bdev = bdev;
-	if (xfs_setsize_buftarg(btp, PAGE_CACHE_SIZE, bdev_hardsect_size(bdev)))
+	if (xfs_setsize_buftarg_early(btp, bdev))
 		goto error;
 	if (xfs_mapping_buftarg(btp, bdev))
 		goto error;
+	xfs_alloc_bufhash(btp, external);
 	return btp;
 
 error:
@@ -1843,8 +1936,6 @@ pagebuf_daemon_stop(void)
 int __init
 pagebuf_init(void)
 {
-	int			i;
-
 	pagebuf_cache = kmem_cache_create("xfs_buf_t", sizeof(xfs_buf_t), 0,
 			SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (pagebuf_cache == NULL) {
@@ -1865,11 +1956,6 @@ pagebuf_init(void)
 		return -ENOMEM;
 	}
 
-	for (i = 0; i < NHASH; i++) {
-		spin_lock_init(&pbhash[i].pb_hash_lock);
-		INIT_LIST_HEAD(&pbhash[i].pb_hash);
-	}
-
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_buf.h linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_buf.h
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_buf.h	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_buf.h	2005-02-03 02:56:10.000000000 +0100
@@ -95,6 +95,11 @@ typedef enum page_buf_flags_e {		/* pb_f
 #define PBF_NOT_DONE(pb) (((pb)->pb_flags & (PBF_PARTIAL|PBF_NONE)) != 0)
 #define PBF_DONE(pb) (((pb)->pb_flags & (PBF_PARTIAL|PBF_NONE)) == 0)
 
+typedef struct xfs_bufhash {
+	struct list_head	bh_list;
+	spinlock_t		bh_lock;
+} xfs_bufhash_t;
+
 typedef struct xfs_buftarg {
 	dev_t			pbr_dev;
 	struct block_device	*pbr_bdev;
@@ -102,32 +107,35 @@ typedef struct xfs_buftarg {
 	unsigned int		pbr_bsize;
 	unsigned int		pbr_sshift;
 	size_t			pbr_smask;
+
+	/* per-device buffer hash table */
+	uint			bt_hashmask;
+	uint			bt_hashshift;
+	xfs_bufhash_t		*bt_hash;
 } xfs_buftarg_t;
 
 /*
  *	xfs_buf_t:  Buffer structure for page cache-based buffers
  *
  * This buffer structure is used by the page cache buffer management routines
- * to refer to an assembly of pages forming a logical buffer.  The actual
- * I/O is performed with buffer_head or bio structures, as required by drivers,
- * for drivers which do not understand this structure.  The buffer structure is
- * used on temporary basis only, and discarded when released.
- *
- * The real data storage is recorded in the page cache.  Metadata is
- * hashed to the inode for the block device on which the file system resides.
- * File data is hashed to the inode for the file.  Pages which are only
- * partially filled with data have bits set in their block_map entry
- * to indicate which disk blocks in the page are not valid.
+ * to refer to an assembly of pages forming a logical buffer.  The actual I/O
+ * is performed with buffer_head structures, as required by drivers.
+ * 
+ * The buffer structure is used on temporary basis only, and discarded when
+ * released.  The real data storage is recorded in the page cache.  Metadata is
+ * hashed to the block device on which the file system resides.
  */
 
 struct xfs_buf;
+
+/* call-back function on I/O completion */
 typedef void (*page_buf_iodone_t)(struct xfs_buf *);
-			/* call-back function on I/O completion */
+/* call-back function on I/O completion */
 typedef void (*page_buf_relse_t)(struct xfs_buf *);
-			/* call-back function on I/O completion */
+/* pre-write function */
 typedef int (*page_buf_bdstrat_t)(struct xfs_buf *);
 
-#define PB_PAGES	4
+#define PB_PAGES	2
 
 typedef struct xfs_buf {
 	struct semaphore	pb_sema;	/* semaphore for lockables  */
@@ -136,8 +144,9 @@ typedef struct xfs_buf {
 	wait_queue_head_t	pb_waiters;	/* unpin waiters	    */
 	struct list_head	pb_list;
 	page_buf_flags_t	pb_flags;	/* status flags */
-	struct list_head	pb_hash_list;
-	xfs_buftarg_t		*pb_target;	/* logical object */
+	struct list_head	pb_hash_list;	/* hash table list */
+	xfs_bufhash_t		*pb_hash;	/* hash table list start */
+	xfs_buftarg_t		*pb_target;	/* buffer target (device) */
 	atomic_t		pb_hold;	/* reference count */
 	xfs_daddr_t		pb_bn;		/* block number for I/O */
 	loff_t			pb_file_offset;	/* offset in file */
@@ -154,10 +163,9 @@ typedef struct xfs_buf {
 	void			*pb_fspriv2;
 	void			*pb_fspriv3;
 	unsigned short		pb_error;	/* error code on I/O */
-	unsigned short		pb_page_count;	/* size of page array */
-	unsigned short		pb_offset;	/* page offset in first page */
-	unsigned char		pb_locked;	/* page array is locked */
-	unsigned char		pb_hash_index;	/* hash table index	*/
+ 	unsigned short		pb_locked;	/* page array is locked */
+ 	unsigned int		pb_page_count;	/* size of page array */
+	unsigned int		pb_offset;	/* page offset in first page */
 	struct page		**pb_pages;	/* array of page pointers */
 	struct page		*pb_page_array[PB_PAGES]; /* inline pages */
 #ifdef PAGEBUF_LOCK_TRACKING
@@ -455,7 +463,7 @@ extern inline xfs_caddr_t xfs_buf_offset
 				pagebuf_associate_memory(bp, val, count)
 #define XFS_BUF_ADDR(bp)	((bp)->pb_bn)
 #define XFS_BUF_SET_ADDR(bp, blk)		\
-			((bp)->pb_bn = (blk))
+			((bp)->pb_bn = (xfs_daddr_t)(blk))
 #define XFS_BUF_OFFSET(bp)	((bp)->pb_file_offset)
 #define XFS_BUF_SET_OFFSET(bp, off)		\
 			((bp)->pb_file_offset = (off))
@@ -564,7 +572,7 @@ static inline int xfs_bdwrite(void *mp, 
  *	Handling of buftargs.
  */
 
-extern xfs_buftarg_t *xfs_alloc_buftarg(struct block_device *);
+extern xfs_buftarg_t *xfs_alloc_buftarg(struct block_device *, int);
 extern void xfs_free_buftarg(xfs_buftarg_t *, int);
 extern void xfs_wait_buftarg(xfs_buftarg_t *);
 extern int xfs_setsize_buftarg(xfs_buftarg_t *, unsigned int, unsigned int);
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_export.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_export.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_export.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_export.c	2005-02-03 02:55:51.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2004-2005 Silicon Graphics, Inc.  All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
+ * Mountain View, CA  94043, or:
+ *
+ * http://www.sgi.com
+ *
+ * For further information regarding this notice, see:
+ *
+ * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/
+ */
+
+#include "xfs.h"
+
+
+STATIC struct dentry *
+linvfs_decode_fh(
+	struct super_block	*sb,
+	__u32			*fh,
+	int			fh_len,
+	int			fileid_type,
+	int (*acceptable)(
+		void		*context,
+		struct dentry	*de),
+	void			*context)
+{
+	__u32 parent[2];
+	parent[0] = parent[1] = 0;
+	
+	if (fh_len < 2 || fileid_type > 2)
+		return NULL;
+	
+	if (fileid_type == 2 && fh_len > 2) {
+		if (fh_len == 3) {
+			printk(KERN_WARNING
+			       "XFS: detected filehandle without "
+			       "parent inode generation information.");
+			return ERR_PTR(-ESTALE);
+		}
+			
+		parent[0] = fh[2];
+		parent[1] = fh[3];
+	}
+	
+	return find_exported_dentry(sb, fh, parent, acceptable, context);
+
+}
+
+STATIC struct dentry *
+linvfs_get_dentry(
+	struct super_block	*sb,
+	void			*data)
+{
+	vnode_t			*vp;
+	struct inode		*inode;
+	struct dentry		*result;
+	xfs_fid2_t		xfid;
+	vfs_t			*vfsp = LINVFS_GET_VFS(sb);
+	int			error;
+
+	xfid.fid_len = sizeof(xfs_fid2_t) - sizeof(xfid.fid_len);
+	xfid.fid_pad = 0;
+	xfid.fid_gen = ((__u32 *)data)[1];
+	xfid.fid_ino = ((__u32 *)data)[0];
+
+	VFS_VGET(vfsp, &vp, (fid_t *)&xfid, error);
+	if (error || vp == NULL)
+		return ERR_PTR(-ESTALE) ;
+
+	inode = LINVFS_GET_IP(vp);
+	result = d_alloc_anon(inode);
+        if (!result) {
+		iput(inode);
+		return ERR_PTR(-ENOMEM);
+	}
+	return result;
+}
+
+STATIC struct dentry *
+linvfs_get_parent(
+	struct dentry		*child)
+{
+	int			error;
+	vnode_t			*vp, *cvp;
+	struct dentry		*parent;
+	struct dentry		dotdot;
+
+	dotdot.d_name.name = "..";
+	dotdot.d_name.len = 2;
+	dotdot.d_inode = NULL;
+
+	cvp = NULL;
+	vp = LINVFS_GET_VP(child->d_inode);
+	VOP_LOOKUP(vp, &dotdot, &cvp, 0, NULL, NULL, error);
+	if (unlikely(error))
+		return ERR_PTR(-error);
+
+	parent = d_alloc_anon(LINVFS_GET_IP(cvp));
+	if (unlikely(!parent)) {
+		VN_RELE(cvp);
+		return ERR_PTR(-ENOMEM);
+	}
+	return parent;
+}
+
+struct export_operations linvfs_export_ops = {
+	.decode_fh		= linvfs_decode_fh,
+	.get_parent		= linvfs_get_parent,
+	.get_dentry		= linvfs_get_dentry,
+};
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_file.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_file.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_file.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_file.c	2005-02-03 02:55:52.000000000 +0100
@@ -82,23 +82,23 @@ __linvfs_read(
 
 
 STATIC ssize_t
-linvfs_read(
+linvfs_aio_read(
 	struct kiocb		*iocb,
 	char			__user *buf,
 	size_t			count,
 	loff_t			pos)
 {
-	return __linvfs_read(iocb, buf, 0, count, pos);
+	return __linvfs_read(iocb, buf, IO_ISAIO, count, pos);
 }
 
 STATIC ssize_t
-linvfs_read_invis(
+linvfs_aio_read_invis(
 	struct kiocb		*iocb,
 	char			__user *buf,
 	size_t			count,
 	loff_t			pos)
 {
-	return __linvfs_read(iocb, buf, IO_INVIS, count, pos);
+	return __linvfs_read(iocb, buf, IO_ISAIO|IO_INVIS, count, pos);
 }
 
 
@@ -126,23 +126,23 @@ __linvfs_write(
 
 
 STATIC ssize_t
-linvfs_write(
+linvfs_aio_write(
 	struct kiocb		*iocb,
 	const char		__user *buf,
 	size_t			count,
 	loff_t			pos)
 {
-	return __linvfs_write(iocb, buf, 0, count, pos);
+	return __linvfs_write(iocb, buf, IO_ISAIO, count, pos);
 }
 
 STATIC ssize_t
-linvfs_write_invis(
+linvfs_aio_write_invis(
 	struct kiocb		*iocb,
 	const char		__user *buf,
 	size_t			count,
 	loff_t			pos)
 {
-	return __linvfs_write(iocb, buf, IO_INVIS, count, pos);
+	return __linvfs_write(iocb, buf, IO_ISAIO|IO_INVIS, count, pos);
 }
 
 
@@ -489,8 +489,8 @@ struct file_operations linvfs_file_opera
 	.write		= do_sync_write,
 	.readv		= linvfs_readv,
 	.writev		= linvfs_writev,
-	.aio_read	= linvfs_read,
-	.aio_write	= linvfs_write,
+	.aio_read	= linvfs_aio_read,
+	.aio_write	= linvfs_aio_write,
 	.sendfile	= linvfs_sendfile,
 	.unlocked_ioctl	= linvfs_ioctl,
 #ifdef CONFIG_COMPAT
@@ -508,8 +508,8 @@ struct file_operations linvfs_invis_file
 	.write		= do_sync_write,
 	.readv		= linvfs_readv_invis,
 	.writev		= linvfs_writev_invis,
-	.aio_read	= linvfs_read_invis,
-	.aio_write	= linvfs_write_invis,
+	.aio_read	= linvfs_aio_read_invis,
+	.aio_write	= linvfs_aio_write_invis,
 	.sendfile	= linvfs_sendfile,
 	.unlocked_ioctl	= linvfs_ioctl_invis,
 #ifdef CONFIG_COMPAT
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_ioctl.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_ioctl.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_ioctl.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_ioctl.c	2005-02-03 02:57:16.000000000 +0100
@@ -499,7 +499,7 @@ xfs_attrmulti_by_handle(
 	xfs_fsop_attrmulti_handlereq_t am_hreq;
 	struct inode		*inode;
 	vnode_t			*vp;
-	int			i, size;
+	unsigned int		i, size;
 
 	error = xfs_vget_fsop_handlereq(mp, parinode, CAP_SYS_ADMIN, arg,
 					sizeof(xfs_fsop_attrmulti_handlereq_t),
@@ -509,6 +509,11 @@ xfs_attrmulti_by_handle(
 		return -error;
 
 	size = am_hreq.opcount * sizeof(attr_multiop_t);
+	if (!size || size > 16 * PAGE_SIZE) {
+		VN_RELE(vp);
+		return -XFS_ERROR(E2BIG);
+	}
+
 	ops = (xfs_attr_multiop_t *)kmalloc(size, GFP_KERNEL);
 	if (!ops) {
 		VN_RELE(vp);
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_iops.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_iops.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_iops.c	2005-01-22 02:47:33.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_iops.c	2005-02-03 02:55:35.000000000 +0100
@@ -369,33 +369,6 @@ linvfs_rename(
 	return 0;
 }
 
-STATIC int
-linvfs_readlink(
-	struct dentry	*dentry,
-	char		__user *buf,
-	int		size)
-{
-	vnode_t		*vp = LINVFS_GET_VP(dentry->d_inode);
-	uio_t		uio;
-	iovec_t		iov;
-	int		error;
-
-	iov.iov_base = buf;
-	iov.iov_len = size;
-
-	uio.uio_iov = &iov;
-	uio.uio_offset = 0;
-	uio.uio_segflg = UIO_USERSPACE;
-	uio.uio_resid = size;
-	uio.uio_iovcnt = 1;
-
-	VOP_READLINK(vp, &uio, 0, NULL, error);
-	if (error)
-		return -error;
-
-	return (size - uio.uio_resid);
-}
-
 /*
  * careful here - this function can get called recursively, so
  * we need to be very careful about how much stack we use.
@@ -694,7 +667,7 @@ struct inode_operations linvfs_dir_inode
 };
 
 struct inode_operations linvfs_symlink_inode_operations = {
-	.readlink		= linvfs_readlink,
+	.readlink		= generic_readlink,
 	.follow_link		= linvfs_follow_link,
 	.put_link		= linvfs_put_link,
 	.permission		= linvfs_permission,
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_linux.h linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_linux.h
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_linux.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_linux.h	2005-02-03 02:57:04.000000000 +0100
@@ -144,7 +144,10 @@ static inline void set_buffer_unwritten_
 #define xfs_inherit_nosymlinks	xfs_params.inherit_nosym.val
 #define xfs_rotorstep		xfs_params.rotorstep.val
 
-#define current_cpu()		smp_processor_id()
+#ifndef __smp_processor_id
+#define __smp_processor_id()	smp_processor_id()
+#endif
+#define current_cpu()		__smp_processor_id()
 #define current_pid()		(current->pid)
 #define current_fsuid(cred)	(current->fsuid)
 #define current_fsgid(cred)	(current->fsgid)
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_lrw.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_lrw.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_lrw.c	2005-01-22 02:46:37.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_lrw.c	2005-02-03 02:54:37.000000000 +0100
@@ -317,7 +317,7 @@ xfs_read(
 	xfs_rw_enter_trace(XFS_READ_ENTER, &ip->i_iocore,
 				(void *)iovp, segs, *offset, ioflags);
 	ret = __generic_file_aio_read(iocb, iovp, segs, offset);
-	if (ret == -EIOCBQUEUED)
+	if (ret == -EIOCBQUEUED && !(ioflags & IO_ISAIO))
 		ret = wait_on_sync_kiocb(iocb);
 	if (ret > 0)
 		XFS_STATS_ADD(xs_read_bytes, ret);
@@ -854,7 +854,7 @@ retry:
 
 	current->backing_dev_info = NULL;
 
-	if (ret == -EIOCBQUEUED)
+	if (ret == -EIOCBQUEUED && !(ioflags & IO_ISAIO))
 		ret = wait_on_sync_kiocb(iocb);
 
 	if ((ret == -ENOSPC) &&
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_stats.h linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_stats.h
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_stats.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_stats.h	2005-02-03 02:55:23.000000000 +0100
@@ -140,11 +140,13 @@ struct xfsstats {
 
 DECLARE_PER_CPU(struct xfsstats, xfsstats);
 
-/* We don't disable preempt, not too worried about poking the
- * wrong cpu's stat for now */
-#define XFS_STATS_INC(count)		(__get_cpu_var(xfsstats).count++)
-#define XFS_STATS_DEC(count)		(__get_cpu_var(xfsstats).count--)
-#define XFS_STATS_ADD(count, inc)	(__get_cpu_var(xfsstats).count += (inc))
+/*
+ * We don't disable preempt, not too worried about poking the
+ * wrong CPU's stat for now (also aggregated before reporting).
+ */
+#define XFS_STATS_INC(v)	(per_cpu(xfsstats, current_cpu()).v++)
+#define XFS_STATS_DEC(v)	(per_cpu(xfsstats, current_cpu()).v--)
+#define XFS_STATS_ADD(v, inc)	(per_cpu(xfsstats, current_cpu()).v += (inc))
 
 extern void xfs_init_procfs(void);
 extern void xfs_cleanup_procfs(void);
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_super.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_super.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_super.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_super.c	2005-02-03 02:56:48.000000000 +0100
@@ -75,7 +75,6 @@
 
 STATIC struct quotactl_ops linvfs_qops;
 STATIC struct super_operations linvfs_sops;
-STATIC struct export_operations linvfs_export_ops;
 STATIC kmem_zone_t *linvfs_inode_zone;
 STATIC kmem_shaker_t xfs_inode_shaker;
 
@@ -659,63 +658,6 @@ linvfs_freeze_fs(
 	VFS_FREEZE(LINVFS_GET_VFS(sb));
 }
 
-STATIC struct dentry *
-linvfs_get_parent(
-	struct dentry		*child)
-{
-	int			error;
-	vnode_t			*vp, *cvp;
-	struct dentry		*parent;
-	struct dentry		dotdot;
-
-	dotdot.d_name.name = "..";
-	dotdot.d_name.len = 2;
-	dotdot.d_inode = NULL;
-
-	cvp = NULL;
-	vp = LINVFS_GET_VP(child->d_inode);
-	VOP_LOOKUP(vp, &dotdot, &cvp, 0, NULL, NULL, error);
-	if (unlikely(error))
-		return ERR_PTR(-error);
-
-	parent = d_alloc_anon(LINVFS_GET_IP(cvp));
-	if (unlikely(!parent)) {
-		VN_RELE(cvp);
-		return ERR_PTR(-ENOMEM);
-	}
-	return parent;
-}
-
-STATIC struct dentry *
-linvfs_get_dentry(
-	struct super_block	*sb,
-	void			*data)
-{
-	vnode_t			*vp;
-	struct inode		*inode;
-	struct dentry		*result;
-	xfs_fid2_t		xfid;
-	vfs_t			*vfsp = LINVFS_GET_VFS(sb);
-	int			error;
-
-	xfid.fid_len = sizeof(xfs_fid2_t) - sizeof(xfid.fid_len);
-	xfid.fid_pad = 0;
-	xfid.fid_gen = ((__u32 *)data)[1];
-	xfid.fid_ino = ((__u32 *)data)[0];
-
-	VFS_VGET(vfsp, &vp, (fid_t *)&xfid, error);
-	if (error || vp == NULL)
-		return ERR_PTR(-ESTALE) ;
-
-	inode = LINVFS_GET_IP(vp);
-	result = d_alloc_anon(inode);
-        if (!result) {
-		iput(inode);
-		return ERR_PTR(-ENOMEM);
-	}
-	return result;
-}
-
 STATIC int
 linvfs_show_options(
 	struct seq_file		*m,
@@ -808,7 +750,9 @@ linvfs_fill_super(
 	}
 
 	sb_min_blocksize(sb, BBSIZE);
+#ifdef CONFIG_XFS_EXPORT
 	sb->s_export_op = &linvfs_export_ops;
+#endif
 	sb->s_qcop = &linvfs_qops;
 	sb->s_op = &linvfs_sops;
 
@@ -877,12 +821,6 @@ linvfs_get_sb(
 	return get_sb_bdev(fs_type, flags, dev_name, data, linvfs_fill_super);
 }
 
-
-STATIC struct export_operations linvfs_export_ops = {
-	.get_parent		= linvfs_get_parent,
-	.get_dentry		= linvfs_get_dentry,
-};
-
 STATIC struct super_operations linvfs_sops = {
 	.alloc_inode		= linvfs_alloc_inode,
 	.destroy_inode		= linvfs_destroy_inode,
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_super.h linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_super.h
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_super.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_super.h	2005-02-03 02:55:23.000000000 +0100
@@ -133,4 +133,6 @@ extern int  xfs_blkdev_get(struct xfs_mo
 				struct block_device **);
 extern void xfs_blkdev_put(struct block_device *);
 
+extern struct export_operations linvfs_export_ops;
+
 #endif	/* __XFS_SUPER_H__ */
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_vnode.c linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_vnode.c
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_vnode.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_vnode.c	2005-02-03 02:55:36.000000000 +0100
@@ -199,7 +199,6 @@ vn_revalidate_core(
 {
 	struct inode	*inode = LINVFS_GET_IP(vp);
 
-	inode = LINVFS_GET_IP(vp);
 	inode->i_mode	    = VTTOIF(vap->va_type) | vap->va_mode;
 	inode->i_nlink	    = vap->va_nlink;
 	inode->i_uid	    = vap->va_uid;
@@ -416,8 +415,8 @@ vn_remove(
 /*  3 */		(void *)(vn_count(vp)), \
 /*  4 */		(void *)(ra),				\
 /*  5 */		(void *)(__psunsigned_t)(vp)->v_flag,	\
-/*  6 */		(void *)(__psint_t)smp_processor_id(),	\
-/*  7 */		(void *)(__psint_t)(current->pid),	\
+/*  6 */		(void *)(__psint_t)current_cpu(),	\
+/*  7 */		(void *)(__psint_t)current_pid(),	\
 /*  8 */		(void *)__return_address,		\
 /*  9 */		0, 0, 0, 0, 0, 0, 0)
 
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_vnode.h linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_vnode.h
--- linux-2.6.11-rc2-bk10/fs/xfs/linux-2.6/xfs_vnode.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/linux-2.6/xfs_vnode.h	2005-02-03 02:57:04.000000000 +0100
@@ -379,6 +379,7 @@ typedef struct vnodeops {
 /*
  * Flags for read/write calls - same values as IRIX
  */
+#define IO_ISAIO	0x00001		/* don't wait for completion */
 #define IO_ISDIRECT	0x00004		/* bypass page cache */
 #define IO_INVIS	0x00020		/* don't update inode timestamps */
 
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/xfs_clnt.h linux-2.6.11-rc3/fs/xfs/xfs_clnt.h
--- linux-2.6.11-rc2-bk10/fs/xfs/xfs_clnt.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/xfs_clnt.h	2005-02-03 02:56:21.000000000 +0100
@@ -64,6 +64,7 @@ struct xfs_mount_args {
 	int	sunit;		/* stripe unit (BBs) */
 	int	swidth;		/* stripe width (BBs), multiple of sunit */
 	uchar_t iosizelog;	/* log2 of the preferred I/O size */
+	int	ihashsize;	/* inode hash table size (buckets) */
 };
 
 /*
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/xfs_iget.c linux-2.6.11-rc3/fs/xfs/xfs_iget.c
--- linux-2.6.11-rc2-bk10/fs/xfs/xfs_iget.c	2005-01-22 02:48:59.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/xfs_iget.c	2005-02-03 02:56:53.000000000 +0100
@@ -55,22 +55,32 @@
 #include "xfs_inode.h"
 #include "xfs_quota.h"
 #include "xfs_utils.h"
+#include "xfs_bit.h"
 
 /*
  * Initialize the inode hash table for the newly mounted file system.
- *
- * mp -- this is the mount point structure for the file system being
- *       initialized
+ * Choose an initial table size based on user specified value, else
+ * use a simple algorithm using the maximum number of inodes as an
+ * indicator for table size, and cap it at 16 pages (gettin' big).
  */
 void
 xfs_ihash_init(xfs_mount_t *mp)
 {
-	int	i;
+	__uint64_t	icount;
+	uint		i, flags = KM_SLEEP | KM_MAYFAIL;
+
+	if (!mp->m_ihsize) {
+		icount = mp->m_maxicount ? mp->m_maxicount :
+			 (mp->m_sb.sb_dblocks << mp->m_sb.sb_inopblog);
+		mp->m_ihsize = 1 << max_t(uint, xfs_highbit64(icount) / 3, 8);
+		mp->m_ihsize = min_t(uint, mp->m_ihsize, 16 * PAGE_SIZE);
+	}
 
-	mp->m_ihsize = XFS_BUCKETS(mp);
-	mp->m_ihash = (xfs_ihash_t *)kmem_zalloc(mp->m_ihsize
-				      * sizeof(xfs_ihash_t), KM_SLEEP);
-	ASSERT(mp->m_ihash != NULL);
+	while (!(mp->m_ihash = (xfs_ihash_t *)kmem_zalloc(mp->m_ihsize *
+						sizeof(xfs_ihash_t), flags))) {
+		if ((mp->m_ihsize >>= 1) <= NBPP)
+			flags = KM_SLEEP;
+	}
 	for (i = 0; i < mp->m_ihsize; i++) {
 		rwlock_init(&(mp->m_ihash[i].ih_lock));
 	}
@@ -88,29 +98,19 @@ xfs_ihash_free(xfs_mount_t *mp)
 
 /*
  * Initialize the inode cluster hash table for the newly mounted file system.
- *
- * mp -- this is the mount point structure for the file system being
- *       initialized
+ * Its size is derived from the ihash table size.
  */
 void
 xfs_chash_init(xfs_mount_t *mp)
 {
-	int	i;
+	uint	i;
 
-	/*
-	 * m_chash size is based on m_ihash
-	 * with a minimum of 37 entries
-	 */
-	mp->m_chsize = (XFS_BUCKETS(mp)) /
-			 (XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog);
-	if (mp->m_chsize < 37) {
-		mp->m_chsize = 37;
-	}
+	mp->m_chsize = max_t(uint, 1, mp->m_ihsize /
+			 (XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog));
+	mp->m_chsize = min_t(uint, mp->m_chsize, mp->m_ihsize);
 	mp->m_chash = (xfs_chash_t *)kmem_zalloc(mp->m_chsize
 						 * sizeof(xfs_chash_t),
 						 KM_SLEEP);
-	ASSERT(mp->m_chash != NULL);
-
 	for (i = 0; i < mp->m_chsize; i++) {
 		spinlock_init(&mp->m_chash[i].ch_lock,"xfshash");
 	}
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/xfs_inode.h linux-2.6.11-rc3/fs/xfs/xfs_inode.h
--- linux-2.6.11-rc2-bk10/fs/xfs/xfs_inode.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/xfs_inode.h	2005-02-03 02:56:22.000000000 +0100
@@ -182,10 +182,6 @@ typedef struct xfs_ihash {
 	uint			ih_version;
 } xfs_ihash_t;
 
-/*
- * Inode hashing and hash bucket locking.
- */
-#define XFS_BUCKETS(mp) (37*(mp)->m_sb.sb_agcount-1)
 #define XFS_IHASH(mp,ino) ((mp)->m_ihash + (((uint)(ino)) % (mp)->m_ihsize))
 
 /*
@@ -193,7 +189,6 @@ typedef struct xfs_ihash {
  * find inodes that share a cluster and can be flushed to disk at the same
  * time.
  */
-
 typedef struct xfs_chashlist {
 	struct xfs_chashlist	*chl_next;
 	struct xfs_inode	*chl_ip;
@@ -207,6 +202,8 @@ typedef struct xfs_chash {
 	lock_t			ch_lock;
 } xfs_chash_t;
 
+#define XFS_CHASH(mp,blk) ((mp)->m_chash + (((uint)blk) % (mp)->m_chsize))
+
 
 /*
  * This is the xfs in-core inode structure.
@@ -450,12 +447,6 @@ xfs_inode_t *xfs_bhvtoi(struct bhv_desc 
 #define BHV_IS_XFS(bdp)		(BHV_OPS(bdp) == &xfs_vnodeops)
 
 /*
- * Pick the inode cluster hash bucket
- * (m_chash is the same size as m_ihash)
- */
-#define XFS_CHASH(mp,blk) ((mp)->m_chash + (((uint)blk) % (mp)->m_chsize))
-
-/*
  * For multiple groups support: if S_ISGID bit is set in the parent
  * directory, group of new file is set to that of the parent, and
  * new subdirectory gets S_ISGID bit from parent.
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/xfs_mount.h linux-2.6.11-rc3/fs/xfs/xfs_mount.h
--- linux-2.6.11-rc2-bk10/fs/xfs/xfs_mount.h	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/xfs_mount.h	2005-02-03 02:57:04.000000000 +0100
@@ -296,7 +296,7 @@ typedef struct xfs_mount {
 	xfs_agnumber_t		m_agirotor;	/* last ag dir inode alloced */
 	lock_t			m_agirotor_lock;/* .. and lock protecting it */
 	xfs_agnumber_t		m_maxagi;	/* highest inode alloc group */
-	int			m_ihsize;	/* size of next field */
+	uint			m_ihsize;	/* size of next field */
 	struct xfs_ihash	*m_ihash;	/* fs private inode hash table*/
 	struct xfs_inode	*m_inodes;	/* active inode list */
 	struct list_head	m_del_inodes;	/* inodes to reclaim */
@@ -376,7 +376,7 @@ typedef struct xfs_mount {
 	xfs_dablk_t		m_dirdatablk;	/* blockno of dir data v2 */
 	xfs_dablk_t		m_dirleafblk;	/* blockno of dir non-data v2 */
 	xfs_dablk_t		m_dirfreeblk;	/* blockno of dirfreeindex v2 */
-	int			m_chsize;	/* size of next field */
+	uint			m_chsize;	/* size of next field */
 	struct xfs_chash	*m_chash;	/* fs private inode per-cluster
 						 * hash table */
 	struct xfs_dmops	m_dm_ops;	/* vector of DMI ops */
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/xfs_vfsops.c linux-2.6.11-rc3/fs/xfs/xfs_vfsops.c
--- linux-2.6.11-rc2-bk10/fs/xfs/xfs_vfsops.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/xfs_vfsops.c	2005-02-03 02:55:15.000000000 +0100
@@ -252,6 +252,7 @@ xfs_start_flags(
 			ap->logbufsize);
 		return XFS_ERROR(EINVAL);
 	}
+	mp->m_ihsize = ap->ihashsize;
 	mp->m_logbsize = ap->logbufsize;
 	mp->m_fsname_len = strlen(ap->fsname) + 1;
 	mp->m_fsname = kmem_alloc(mp->m_fsname_len, KM_SLEEP);
@@ -468,19 +469,19 @@ xfs_mount(
 	 * Setup xfs_mount buffer target pointers
 	 */
 	error = ENOMEM;
-	mp->m_ddev_targp = xfs_alloc_buftarg(ddev);
+	mp->m_ddev_targp = xfs_alloc_buftarg(ddev, 0);
 	if (!mp->m_ddev_targp) {
 		xfs_blkdev_put(logdev);
 		xfs_blkdev_put(rtdev);
 		return error;
 	}
 	if (rtdev) {
-		mp->m_rtdev_targp = xfs_alloc_buftarg(rtdev);
+		mp->m_rtdev_targp = xfs_alloc_buftarg(rtdev, 1);
 		if (!mp->m_rtdev_targp)
 			goto error0;
 	}
 	mp->m_logdev_targp = (logdev && logdev != ddev) ?
-				xfs_alloc_buftarg(logdev) : mp->m_ddev_targp;
+				xfs_alloc_buftarg(logdev, 1) : mp->m_ddev_targp;
 	if (!mp->m_logdev_targp)
 		goto error0;
 
@@ -1579,7 +1580,7 @@ xfs_syncsub(
 }
 
 /*
- * xfs_vget - called by DMAPI to get vnode from file handle
+ * xfs_vget - called by DMAPI and NFSD to get vnode from file handle
  */
 STATIC int
 xfs_vget(
@@ -1621,7 +1622,7 @@ xfs_vget(
 		return XFS_ERROR(EIO);
 	}
 
-	if (ip->i_d.di_mode == 0 || (igen && (ip->i_d.di_gen != igen))) {
+	if (ip->i_d.di_mode == 0 || ip->i_d.di_gen != igen) {
 		xfs_iput_new(ip, XFS_ILOCK_SHARED);
 		*vpp = NULL;
 		return XFS_ERROR(ENOENT);
@@ -1646,6 +1647,7 @@ xfs_vget(
 #define MNTOPT_SWIDTH	"swidth"	/* data volume stripe width */
 #define MNTOPT_NOUUID	"nouuid"	/* ignore filesystem UUID */
 #define MNTOPT_MTPT	"mtpt"		/* filesystem mount point */
+#define MNTOPT_IHASHSIZE    "ihashsize"    /* size of inode hash table */
 #define MNTOPT_NORECOVERY   "norecovery"   /* don't run XFS recovery */
 #define MNTOPT_NOLOGFLUSH   "nologflush"   /* don't hard flush on log writes */
 #define MNTOPT_OSYNCISOSYNC "osyncisosync" /* o_sync is REALLY o_sync */
@@ -1734,6 +1736,13 @@ xfs_parseargs(
 			iosize = simple_strtoul(value, &eov, 10);
 			args->flags |= XFSMNT_IOSIZE;
 			args->iosizelog = (uint8_t) iosize;
+		} else if (!strcmp(this_char, MNTOPT_IHASHSIZE)) {
+			if (!value || !*value) {
+				printk("XFS: %s option requires an argument\n",
+					this_char); 
+				return EINVAL;
+			}
+			args->ihashsize = simple_strtoul(value, &eov, 10);
 		} else if (!strcmp(this_char, MNTOPT_WSYNC)) {
 			args->flags |= XFSMNT_WSYNC;
 		} else if (!strcmp(this_char, MNTOPT_OSYNCISOSYNC)) {
diff -purN linux-2.6.11-rc2-bk10/fs/xfs/xfs_vnodeops.c linux-2.6.11-rc3/fs/xfs/xfs_vnodeops.c
--- linux-2.6.11-rc2-bk10/fs/xfs/xfs_vnodeops.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/fs/xfs/xfs_vnodeops.c	2005-02-03 02:57:04.000000000 +0100
@@ -3900,7 +3900,7 @@ xfs_finish_reclaim(
 	int		error;
 
 	if (vp && VN_BAD(vp))
-		return 0;
+		goto reclaim;
 
 	/* The hash lock here protects a thread in xfs_iget_core from
 	 * racing with us on linking the inode back with a vnode.
@@ -3948,8 +3948,7 @@ xfs_finish_reclaim(
 			 */
 			if (error) {
 				xfs_iunlock(ip, XFS_ILOCK_EXCL);
-				xfs_ireclaim(ip);
-				return (0);
+				goto reclaim;
 			}
 			xfs_iflock(ip); /* synchronize with xfs_iflush_done */
 		}
@@ -3968,6 +3967,7 @@ xfs_finish_reclaim(
 		xfs_iunlock(ip, XFS_ILOCK_EXCL);
 	}
 
+ reclaim:
 	xfs_ireclaim(ip);
 	return 0;
 }
diff -purN linux-2.6.11-rc2-bk10/include/asm-alpha/bitops.h linux-2.6.11-rc3/include/asm-alpha/bitops.h
--- linux-2.6.11-rc2-bk10/include/asm-alpha/bitops.h	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-alpha/bitops.h	2005-02-03 02:55:52.000000000 +0100
@@ -376,12 +376,13 @@ static inline unsigned long hweight64(un
  * Find next zero bit in a bitmap reasonably efficiently..
  */
 static inline unsigned long
-find_next_zero_bit(void * addr, unsigned long size, unsigned long offset)
+find_next_zero_bit(const void *addr, unsigned long size, unsigned long offset)
 {
-	unsigned long * p = ((unsigned long *) addr) + (offset >> 6);
+	const unsigned long *p = addr;
 	unsigned long result = offset & ~63UL;
 	unsigned long tmp;
 
+	p += offset >> 6;
 	if (offset >= size)
 		return size;
 	size -= result;
@@ -419,10 +420,11 @@ find_next_zero_bit(void * addr, unsigned
 static inline unsigned long
 find_next_bit(const void * addr, unsigned long size, unsigned long offset)
 {
-	const unsigned long * p = ((const unsigned long *) addr) + (offset >> 6);
+	const unsigned long *p = addr;
 	unsigned long result = offset & ~63UL;
 	unsigned long tmp;
 
+	p += offset >> 6;
 	if (offset >= size)
 		return size;
 	size -= result;
diff -purN linux-2.6.11-rc2-bk10/include/asm-alpha/page.h linux-2.6.11-rc3/include/asm-alpha/page.h
--- linux-2.6.11-rc2-bk10/include/asm-alpha/page.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-alpha/page.h	2005-02-03 02:56:33.000000000 +0100
@@ -18,6 +18,9 @@
 extern void clear_page(void *page);
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vmaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 extern void copy_page(void * _to, void * _from);
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-alpha/pgtable.h linux-2.6.11-rc3/include/asm-alpha/pgtable.h
--- linux-2.6.11-rc2-bk10/include/asm-alpha/pgtable.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-alpha/pgtable.h	2005-02-03 02:55:23.000000000 +0100
@@ -194,7 +194,7 @@ extern unsigned long __zero_page(void);
  * and a page entry and page directory to the page they refer to.
  */
 #ifndef CONFIG_DISCONTIGMEM
-#define page_to_pa(page)	((page - mem_map) << PAGE_SHIFT)
+#define page_to_pa(page)	(((page) - mem_map) << PAGE_SHIFT)
 
 #define pte_pfn(pte)	(pte_val(pte) >> 32)
 #define pte_page(pte)	pfn_to_page(pte_pfn(pte))
@@ -272,10 +272,10 @@ extern inline pte_t pte_mkyoung(pte_t pt
 #define PAGE_DIR_OFFSET(tsk,address) pgd_offset((tsk),(address))
 
 /* to find an entry in a kernel page-table-directory */
-#define pgd_offset_k(address) pgd_offset(&init_mm, address)
+#define pgd_offset_k(address) pgd_offset(&init_mm, (address))
 
 /* to find an entry in a page-table-directory. */
-#define pgd_index(address)	((address >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
+#define pgd_index(address)	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
 #define pgd_offset(mm, address)	((mm)->pgd+pgd_index(address))
 
 /* Find an entry in the second-level page table.. */
diff -purN linux-2.6.11-rc2-bk10/include/asm-alpha/thread_info.h linux-2.6.11-rc3/include/asm-alpha/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-alpha/thread_info.h	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-alpha/thread_info.h	2005-02-03 02:56:48.000000000 +0100
@@ -77,6 +77,7 @@ register struct thread_info *__current_t
 #define TIF_UAC_NOPRINT		6	/* see sysinfo.h */
 #define TIF_UAC_NOFIX		7
 #define TIF_UAC_SIGBUS		8
+#define TIF_MEMDIE		9
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-alpha/uaccess.h linux-2.6.11-rc3/include/asm-alpha/uaccess.h
--- linux-2.6.11-rc2-bk10/include/asm-alpha/uaccess.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-alpha/uaccess.h	2005-02-03 02:56:33.000000000 +0100
@@ -91,7 +91,8 @@ extern void __get_user_unknown(void);
 
 #define __get_user_nocheck(x,ptr,size)				\
 ({								\
-	long __gu_err = 0, __gu_val;				\
+	long __gu_err = 0;					\
+	unsigned long __gu_val;					\
 	__chk_user_ptr(ptr);					\
 	switch (size) {						\
 	  case 1: __get_user_8(ptr); break;			\
@@ -106,7 +107,8 @@ extern void __get_user_unknown(void);
 
 #define __get_user_check(x,ptr,size,segment)				\
 ({									\
-	long __gu_err = -EFAULT, __gu_val = 0;				\
+	long __gu_err = -EFAULT;					\
+	unsigned long __gu_val = 0;					\
 	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);		\
 	if (__access_ok((unsigned long)__gu_addr,size,segment)) {	\
 		__gu_err = 0;						\
@@ -123,7 +125,7 @@ extern void __get_user_unknown(void);
 })
 
 struct __large_struct { unsigned long buf[100]; };
-#define __m(x) (*(struct __large_struct *)(x))
+#define __m(x) (*(struct __large_struct __user *)(x))
 
 #define __get_user_64(addr)				\
 	__asm__("1: ldq %0,%2\n"			\
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/arch-iop3xx/iop321.h linux-2.6.11-rc3/include/asm-arm/arch-iop3xx/iop321.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/arch-iop3xx/iop321.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/arch-iop3xx/iop321.h	2005-02-03 02:57:04.000000000 +0100
@@ -31,7 +31,7 @@
 /*
  * IOP321 I/O and Mem space regions for PCI autoconfiguration
  */
-#define IOP321_PCI_IO_WINDOW_SIZE   0x10000
+#define IOP321_PCI_IO_WINDOW_SIZE   0x00010000
 #define IOP321_PCI_LOWER_IO_PA      0x90000000
 #define IOP321_PCI_LOWER_IO_VA      0xfe000000
 #define IOP321_PCI_LOWER_IO_BA      (*IOP321_OIOWTVR)
@@ -40,14 +40,13 @@
 #define IOP321_PCI_UPPER_IO_BA      (IOP321_PCI_LOWER_IO_BA + IOP321_PCI_IO_WINDOW_SIZE - 1)
 #define IOP321_PCI_IO_OFFSET        (IOP321_PCI_LOWER_IO_VA - IOP321_PCI_LOWER_IO_BA)
 
-#define IOP321_PCI_MEM_WINDOW_SIZE  (~*IOP321_IALR1 + 1)
+//#define IOP321_PCI_MEM_WINDOW_SIZE  (~*IOP321_IALR1 + 1)
+#define IOP321_PCI_MEM_WINDOW_SIZE  0x04000000 /* 64M outbound window */
 #define IOP321_PCI_LOWER_MEM_PA     0x80000000
-#define IOP321_PCI_LOWER_MEM_VA     0x80000000
 #define IOP321_PCI_LOWER_MEM_BA     (*IOP321_OMWTVR0)
 #define IOP321_PCI_UPPER_MEM_PA     (IOP321_PCI_LOWER_MEM_PA + IOP321_PCI_MEM_WINDOW_SIZE - 1)
-#define IOP321_PCI_UPPER_MEM_VA     (IOP321_PCI_LOWER_MEM_VA + IOP321_PCI_MEM_WINDOW_SIZE - 1)
 #define IOP321_PCI_UPPER_MEM_BA     (IOP321_PCI_LOWER_MEM_BA + IOP321_PCI_MEM_WINDOW_SIZE - 1)
-#define IOP321_PCI_MEM_OFFSET       (IOP321_PCI_LOWER_MEM_VA - IOP321_PCI_LOWER_MEM_BA)
+#define IOP321_PCI_MEM_OFFSET       (IOP321_PCI_LOWER_MEM_PA - IOP321_PCI_LOWER_MEM_BA)
 
 
 /*
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/arch-iop3xx/iop331.h linux-2.6.11-rc3/include/asm-arm/arch-iop3xx/iop331.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/arch-iop3xx/iop331.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/arch-iop3xx/iop331.h	2005-02-03 02:55:23.000000000 +0100
@@ -31,7 +31,7 @@
 /*
  * IOP331 I/O and Mem space regions for PCI autoconfiguration
  */
-#define IOP331_PCI_IO_WINDOW_SIZE   0x10000
+#define IOP331_PCI_IO_WINDOW_SIZE   0x00010000
 #define IOP331_PCI_LOWER_IO_PA      0x90000000
 #define IOP331_PCI_LOWER_IO_VA      0xfe000000
 #define IOP331_PCI_LOWER_IO_BA      (*IOP331_OIOWTVR)
@@ -40,14 +40,14 @@
 #define IOP331_PCI_UPPER_IO_BA      (IOP331_PCI_LOWER_IO_BA + IOP331_PCI_IO_WINDOW_SIZE - 1)
 #define IOP331_PCI_IO_OFFSET        (IOP331_PCI_LOWER_IO_VA - IOP331_PCI_LOWER_IO_BA)
 
-#define IOP331_PCI_MEM_WINDOW_SIZE  (~*IOP331_IALR1 + 1)
+/* this can be 128M if OMWTVR1 is set */
+#define IOP331_PCI_MEM_WINDOW_SIZE	0x04000000 /* 64M outbound window */
+//#define IOP331_PCI_MEM_WINDOW_SIZE  (~*IOP331_IALR1 + 1)
 #define IOP331_PCI_LOWER_MEM_PA     0x80000000
-#define IOP331_PCI_LOWER_MEM_VA     0x80000000
 #define IOP331_PCI_LOWER_MEM_BA     (*IOP331_OMWTVR0)
 #define IOP331_PCI_UPPER_MEM_PA     (IOP331_PCI_LOWER_MEM_PA + IOP331_PCI_MEM_WINDOW_SIZE - 1)
-#define IOP331_PCI_UPPER_MEM_VA     (IOP331_PCI_LOWER_MEM_VA + IOP331_PCI_MEM_WINDOW_SIZE - 1)
 #define IOP331_PCI_UPPER_MEM_BA     (IOP331_PCI_LOWER_MEM_BA + IOP331_PCI_MEM_WINDOW_SIZE - 1)
-#define IOP331_PCI_MEM_OFFSET       (IOP331_PCI_LOWER_MEM_VA - IOP331_PCI_LOWER_MEM_BA)
+#define IOP331_PCI_MEM_OFFSET       (IOP331_PCI_LOWER_MEM_PA - IOP331_PCI_LOWER_MEM_BA)
 
 /*
  * IOP331 chipset registers
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/arch-ixp4xx/gtwx5715.h linux-2.6.11-rc3/include/asm-arm/arch-ixp4xx/gtwx5715.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/arch-ixp4xx/gtwx5715.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/arch-ixp4xx/gtwx5715.h	2005-02-03 02:56:10.000000000 +0100
@@ -0,0 +1,120 @@
+/*
+ * include/asm-arm/arch-ixp4xx/gtwx5715.h
+ *
+ * Gemtek GTWX5715 Gateway (Linksys WRV54G)
+ *
+ * Copyright 2004 (c) George T. Joseph
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+#include "irqs.h"
+
+#define GTWX5715_GPIO0	0
+#define GTWX5715_GPIO1	1
+#define GTWX5715_GPIO2	2
+#define GTWX5715_GPIO3	3
+#define GTWX5715_GPIO4	4
+#define GTWX5715_GPIO5	5
+#define GTWX5715_GPIO6	6
+#define GTWX5715_GPIO7	7
+#define GTWX5715_GPIO8	8
+#define GTWX5715_GPIO9	9
+#define GTWX5715_GPIO10	10
+#define GTWX5715_GPIO11	11
+#define GTWX5715_GPIO12	12
+#define GTWX5715_GPIO13	13
+#define GTWX5715_GPIO14	14
+
+#define GTWX5715_GPIO0_IRQ			IRQ_IXP4XX_GPIO0
+#define GTWX5715_GPIO1_IRQ			IRQ_IXP4XX_GPIO1
+#define GTWX5715_GPIO2_IRQ			IRQ_IXP4XX_GPIO2
+#define GTWX5715_GPIO3_IRQ			IRQ_IXP4XX_GPIO3
+#define GTWX5715_GPIO4_IRQ			IRQ_IXP4XX_GPIO4
+#define GTWX5715_GPIO5_IRQ			IRQ_IXP4XX_GPIO5
+#define GTWX5715_GPIO6_IRQ			IRQ_IXP4XX_GPIO6
+#define GTWX5715_GPIO7_IRQ			IRQ_IXP4XX_GPIO7
+#define GTWX5715_GPIO8_IRQ			IRQ_IXP4XX_GPIO8
+#define GTWX5715_GPIO9_IRQ			IRQ_IXP4XX_GPIO9
+#define GTWX5715_GPIO10_IRQ		IRQ_IXP4XX_GPIO10
+#define GTWX5715_GPIO11_IRQ		IRQ_IXP4XX_GPIO11
+#define GTWX5715_GPIO12_IRQ		IRQ_IXP4XX_GPIO12
+#define GTWX5715_GPIO13_IRQ		IRQ_IXP4XX_SW_INT1
+#define GTWX5715_GPIO14_IRQ		IRQ_IXP4XX_SW_INT2
+
+
+#define	GTWX5715_FLASH_BASE	IXP4XX_EXP_BUS_CS0_BASE_PHYS
+#define	GTWX5715_FLASH_SIZE	(0x00800000)
+
+/* PCI controller GPIO to IRQ pin mappings
+
+			INTA	INTB
+SLOT 0	10		11
+SLOT 1	11		10
+
+*/
+
+#define	GTWX5715_PCI_SLOT0_DEVID	0
+#define	GTWX5715_PCI_SLOT0_INTA_GPIO	GTWX5715_GPIO10
+#define	GTWX5715_PCI_SLOT0_INTB_GPIO	GTWX5715_GPIO11
+#define	GTWX5715_PCI_SLOT0_INTA_IRQ	GTWX5715_GPIO10_IRQ
+#define	GTWX5715_PCI_SLOT0_INTB_IRQ	GTWX5715_GPIO11_IRQ
+
+#define	GTWX5715_PCI_SLOT1_DEVID	1
+#define	GTWX5715_PCI_SLOT1_INTA_GPIO	GTWX5715_GPIO11
+#define	GTWX5715_PCI_SLOT1_INTB_GPIO	GTWX5715_GPIO10
+#define	GTWX5715_PCI_SLOT1_INTA_IRQ	GTWX5715_GPIO11_IRQ
+#define	GTWX5715_PCI_SLOT1_INTB_IRQ	GTWX5715_GPIO10_IRQ
+
+#define GTWX5715_PCI_SLOT_COUNT			2
+#define GTWX5715_PCI_INT_PIN_COUNT		2
+
+/*
+ * GPIO 5,6,7 and12 are hard wired to the Kendin KS8995M Switch
+ * and operate as an SPI type interface.  The details of the interface
+ * are available on Kendin/Micrel's web site.
+ */
+
+#define GTWX5715_KSSPI_SELECT	GTWX5715_GPIO5
+#define GTWX5715_KSSPI_TXD		GTWX5715_GPIO6
+#define GTWX5715_KSSPI_CLOCK	GTWX5715_GPIO7
+#define GTWX5715_KSSPI_RXD		GTWX5715_GPIO12
+
+/*
+ * The "reset" button is wired to GPIO 3.
+ * The GPIO is brought "low" when the button is pushed.
+ */
+
+#define GTWX5715_BUTTON_GPIO	GTWX5715_GPIO3
+#define GTWX5715_BUTTON_IRQ	GTWX5715_GPIO3_IRQ
+
+/*
+ *  Board Label      Front Label
+ *  LED1             Power
+ *  LED2             Wireless-G
+ *  LED3             not populated but could be
+ *  LED4             Internet
+ *  LED5 - LED8      Controlled by KS8995M Switch
+ *  LED9             DMZ
+ */
+
+#define GTWX5715_LED1_GPIO		GTWX5715_GPIO2
+#define GTWX5715_LED2_GPIO		GTWX5715_GPIO9
+#define GTWX5715_LED3_GPIO		GTWX5715_GPIO8
+#define GTWX5715_LED4_GPIO		GTWX5715_GPIO1
+#define GTWX5715_LED9_GPIO		GTWX5715_GPIO4
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/arch-ixp4xx/uncompress.h linux-2.6.11-rc3/include/asm-arm/arch-ixp4xx/uncompress.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/arch-ixp4xx/uncompress.h	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/arch-ixp4xx/uncompress.h	2005-02-03 02:55:03.000000000 +0100
@@ -46,9 +46,9 @@ static void putstr(const char *s)
 static __inline__ void __arch_decomp_setup(unsigned long arch_id)
 {
 	/*
-	 * Coyote only has UART2 connected
+	 * Coyote and gtwx5715 only have UART2 connected
 	 */
-	if (machine_is_adi_coyote())
+	if (machine_is_adi_coyote() || machine_is_gtwx5715())
 		uart_base = (volatile u32*) IXP4XX_UART2_BASE_PHYS;
 	else
 		uart_base = (volatile u32*) IXP4XX_UART1_BASE_PHYS;
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/arch-pxa/corgi.h linux-2.6.11-rc3/include/asm-arm/arch-pxa/corgi.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/arch-pxa/corgi.h	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/arch-pxa/corgi.h	2005-02-03 02:55:01.000000000 +0100
@@ -18,29 +18,30 @@
  * Corgi (Non Standard) GPIO Definitions
  */
 #define CORGI_GPIO_KEY_INT			(0)	/* Keyboard Interrupt */
-#define CORGI_GPIO_AC_IN			(1)
-#define CORGI_GPIO_WAKEUP			(3)
-#define CORGI_GPIO_AK_INT			(4)	/* IR Controller Interrupt */
+#define CORGI_GPIO_AC_IN			(1) /* Charger Detection */
+#define CORGI_GPIO_WAKEUP			(3) /* System wakeup notification? */
+#define CORGI_GPIO_AK_INT			(4)	/* Headphone Jack Control Interrupt */
 #define CORGI_GPIO_TP_INT			(5)	/* Touch Panel Interrupt */
-#define CORGI_GPIO_nSD_WP			(7)
+#define CORGI_GPIO_nSD_WP			(7) /* SD Write Protect? */
 #define CORGI_GPIO_nSD_DETECT		(9) /* MMC/SD Card Detect */
-#define CORGI_GPIO_nSD_INT			(10)
-#define CORGI_GPIO_MAIN_BAT_LOW		(11)
-#define CORGI_GPIO_BAT_COVER		(11)
-#define CORGI_GPIO_LED_ORANGE		(13)
+#define CORGI_GPIO_nSD_INT			(10) /* SD Interrupt for SDIO? */
+#define CORGI_GPIO_MAIN_BAT_LOW		(11) /* Main Battery Low Notification */
+#define CORGI_GPIO_BAT_COVER		(11) /* Battery Cover Detect */
+#define CORGI_GPIO_LED_ORANGE		(13) /* Orange LED Control */
 #define CORGI_GPIO_CF_CD			(14) /* Compact Flash Card Detect */
-#define CORGI_GPIO_CHRG_FULL		(16)
+#define CORGI_GPIO_CHRG_FULL		(16) /* Charging Complete Notification */
 #define CORGI_GPIO_CF_IRQ			(17) /* Compact Flash Interrupt */
 #define CORGI_GPIO_LCDCON_CS		(19) /* LCD Control Chip Select */
-#define CORGI_GPIO_MAX1111_CS		(20) /* MAX111 Chip Select */
-#define CORGI_GPIO_ADC_TEMP_ON		(21)
-#define CORGI_GPIO_IR_ON			(22)
+#define CORGI_GPIO_MAX1111_CS		(20) /* MAX1111 Chip Select */
+#define CORGI_GPIO_ADC_TEMP_ON		(21) /* Select battery voltage or temperature */
+#define CORGI_GPIO_IR_ON			(22) /* Enable IR Transciever */
 #define CORGI_GPIO_ADS7846_CS		(24) /* ADS7846 Chip Select */
 #define CORGI_GPIO_SD_PWR			(33) /* MMC/SD Power */
-#define CORGI_GPIO_CHRG_ON			(38)
-#define CORGI_GPIO_DISCHARGE_ON		(42)
+#define CORGI_GPIO_CHRG_ON			(38) /* Enable battery Charging */
+#define CORGI_GPIO_DISCHARGE_ON		(42) /* Enable battery Discharge */
+#define CORGI_GPIO_CHRG_UKN			(43) /* Unknown Charging (Bypass Control?) */
 #define CORGI_GPIO_HSYNC			(44) /* LCD HSync Pulse */
-#define CORGI_GPIO_USB_PULLUP		(45)
+#define CORGI_GPIO_USB_PULLUP		(45) /* USB show presence to host */
 
 
 /*
@@ -97,6 +98,7 @@
 			CORGI_SCP_MIC_BIAS )
 #define CORGI_SCOOP_IO_OUT	( CORGI_SCP_MUTE_L | CORGI_SCP_MUTE_R )
 
+
 /*
  * Corgi Parameter Area Definitions
  */
@@ -131,5 +133,18 @@ struct sharpsl_flash_param_info {
   unsigned int phadadj;
 };
 
+
+/*
+ * External Functions
+ */
+extern unsigned long corgi_ssp_ads7846_putget(unsigned long);
+extern unsigned long corgi_ssp_ads7846_get(void);
+extern void corgi_ssp_ads7846_put(ulong data);
+extern void corgi_ssp_ads7846_lock(void);
+extern void corgi_ssp_ads7846_unlock(void);
+extern void corgi_ssp_lcdtg_send (u8 adrs, u8 data);
+extern void corgi_ssp_blduty_set(int duty);
+extern int corgi_ssp_max1111_get(ulong data);
+
 #endif /* __ASM_ARCH_CORGI_H  */
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/arch-pxa/pxa-regs.h linux-2.6.11-rc3/include/asm-arm/arch-pxa/pxa-regs.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/arch-pxa/pxa-regs.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/arch-pxa/pxa-regs.h	2005-02-03 02:56:11.000000000 +0100
@@ -1337,7 +1337,7 @@
 #define GPIO18_RDY_MD		(18 | GPIO_ALT_FN_1_IN)
 #define GPIO19_DREQ1_MD		(19 | GPIO_ALT_FN_1_IN)
 #define GPIO20_DREQ0_MD		(20 | GPIO_ALT_FN_1_IN)
-#define GPIO23_SCLK_md		(23 | GPIO_ALT_FN_2_OUT)
+#define GPIO23_SCLK_MD		(23 | GPIO_ALT_FN_2_OUT)
 #define GPIO24_SFRM_MD		(24 | GPIO_ALT_FN_2_OUT)
 #define GPIO25_STXD_MD		(25 | GPIO_ALT_FN_2_OUT)
 #define GPIO26_SRXD_MD		(26 | GPIO_ALT_FN_1_IN)
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/bitops.h linux-2.6.11-rc3/include/asm-arm/bitops.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/bitops.h	2005-02-03 10:03:10.013476835 +0100
+++ linux-2.6.11-rc3/include/asm-arm/bitops.h	2005-02-03 02:54:58.000000000 +0100
@@ -356,7 +356,7 @@ static __inline__ int generic_fls(int x)
  * Find first bit set in a 168-bit bitmap, where the first
  * 128 bits are unlikely to be set.
  */
-static inline int sched_find_first_bit(unsigned long *b)
+static inline int sched_find_first_bit(const unsigned long *b)
 {
 	unsigned long v;
 	unsigned int off;
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/elf.h linux-2.6.11-rc3/include/asm-arm/elf.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/elf.h	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/elf.h	2005-02-03 02:56:48.000000000 +0100
@@ -17,6 +17,7 @@ typedef unsigned long elf_freg_t[3];
 #define EM_ARM	40
 #define EF_ARM_APCS26 0x08
 #define EF_ARM_SOFT_FLOAT 0x200
+#define EF_ARM_EABI_MASK 0xFF000000
 
 #define R_ARM_NONE	0
 #define R_ARM_PC24	1
@@ -120,7 +121,8 @@ extern char elf_platform[];
 #define SET_PERSONALITY(ex,ibcs2) \
 do { \
 	set_personality(PER_LINUX_32BIT); \
-	if ((ex).e_flags & EF_ARM_SOFT_FLOAT) \
+	if (((ex).e_flags & EF_ARM_EABI_MASK) || \
+	    ((ex).e_flags & EF_ARM_SOFT_FLOAT)) \
 		set_thread_flag(TIF_USING_IWMMXT); \
 } while (0)
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/ptrace.h linux-2.6.11-rc3/include/asm-arm/ptrace.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/ptrace.h	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/ptrace.h	2005-02-03 02:56:10.000000000 +0100
@@ -19,6 +19,7 @@
 
 #define PTRACE_OLDSETOPTIONS	21
 
+#define PTRACE_GET_THREAD_AREA	22
 /*
  * PSR bits
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/thread_info.h linux-2.6.11-rc3/include/asm-arm/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/thread_info.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/thread_info.h	2005-02-03 02:55:51.000000000 +0100
@@ -53,6 +53,7 @@ struct thread_info {
 	__u32			cpu_domain;	/* cpu domain */
 	struct cpu_context_save	cpu_context;	/* cpu context */
 	__u8			used_cp[16];	/* thread used copro */
+	unsigned long		tp_value;
 	union fp_state		fpstate;
 	union vfp_state		vfpstate;
 	struct restart_block	restart_block;
@@ -128,6 +129,7 @@ extern void iwmmxt_task_release(struct t
 #define TIF_SYSCALL_TRACE	8
 #define TIF_POLLING_NRFLAG	16
 #define TIF_USING_IWMMXT	17
+#define TIF_MEMDIE		18
 
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm/unistd.h linux-2.6.11-rc3/include/asm-arm/unistd.h
--- linux-2.6.11-rc2-bk10/include/asm-arm/unistd.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm/unistd.h	2005-02-03 02:56:48.000000000 +0100
@@ -281,7 +281,7 @@
 #define __NR_remap_file_pages		(__NR_SYSCALL_BASE+253)
 					/* 254 for set_thread_area */
 					/* 255 for get_thread_area */
-					/* 256 for set_tid_address */
+#define __NR_set_tid_address		(__NR_SYSCALL_BASE+256)
 #define __NR_timer_create		(__NR_SYSCALL_BASE+257)
 #define __NR_timer_settime		(__NR_SYSCALL_BASE+258)
 #define __NR_timer_gettime		(__NR_SYSCALL_BASE+259)
@@ -316,6 +316,8 @@
 #define __ARM_NR_usr26			(__ARM_NR_BASE+3)
 #define __ARM_NR_usr32			(__ARM_NR_BASE+4)
 
+#define __ARM_NR_set_tls		(__ARM_NR_BASE+0x800)
+
 #define __sys2(x) #x
 #define __sys1(x) __sys2(x)
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm26/constants.h linux-2.6.11-rc3/include/asm-arm26/constants.h
--- linux-2.6.11-rc2-bk10/include/asm-arm26/constants.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm26/constants.h	2005-02-03 02:56:48.000000000 +0100
@@ -7,7 +7,6 @@
  *
  */
 
-#define TSK_USED_MATH 788 /* offsetof(struct task_struct, used_math) */
 #define TSK_ACTIVE_MM 96 /* offsetof(struct task_struct, active_mm) */
 
 #define VMA_VM_MM 0 /* offsetof(struct vm_area_struct, vm_mm) */
diff -purN linux-2.6.11-rc2-bk10/include/asm-arm26/thread_info.h linux-2.6.11-rc3/include/asm-arm26/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-arm26/thread_info.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-arm26/thread_info.h	2005-02-03 02:55:23.000000000 +0100
@@ -126,6 +126,7 @@ extern void free_thread_info(struct thre
 #define TIF_SYSCALL_TRACE	8
 #define TIF_USED_FPU		16
 #define TIF_POLLING_NRFLAG	17
+#define TIF_MEMDIE		18
 
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
diff -purN linux-2.6.11-rc2-bk10/include/asm-cris/page.h linux-2.6.11-rc3/include/asm-cris/page.h
--- linux-2.6.11-rc2-bk10/include/asm-cris/page.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-cris/page.h	2005-02-03 02:55:23.000000000 +0100
@@ -21,6 +21,9 @@
 #define clear_user_page(page, vaddr, pg)    clear_page(page)
 #define copy_user_page(to, from, vaddr, pg) copy_page(to, from)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 /*
  * These are used to make use of C type-checking..
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-cris/thread_info.h linux-2.6.11-rc3/include/asm-cris/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-cris/thread_info.h	2005-01-22 02:49:09.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-cris/thread_info.h	2005-02-03 02:56:53.000000000 +0100
@@ -85,6 +85,7 @@ struct thread_info {
 #define TIF_SIGPENDING		2	/* signal pending */
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		17
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-generic/cputime.h linux-2.6.11-rc3/include/asm-generic/cputime.h
--- linux-2.6.11-rc2-bk10/include/asm-generic/cputime.h	2005-01-22 02:49:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-generic/cputime.h	2005-02-03 02:56:53.000000000 +0100
@@ -35,8 +35,8 @@ typedef u64 cputime64_t;
 /*
  * Convert cputime to seconds and back.
  */
-#define cputime_to_secs(__ct)		(jiffies_to_msecs(__ct) / 1000)
-#define secs_to_cputime(__secs)		(msecs_to_jiffies((__secs) * 1000))
+#define cputime_to_secs(jif)		((jif) / HZ)
+#define secs_to_cputime(sec)		((sec) * HZ)
 
 /*
  * Convert cputime to timespec and back.
diff -purN linux-2.6.11-rc2-bk10/include/asm-h8300/page.h linux-2.6.11-rc3/include/asm-h8300/page.h
--- linux-2.6.11-rc2-bk10/include/asm-h8300/page.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-h8300/page.h	2005-02-03 02:56:35.000000000 +0100
@@ -30,6 +30,9 @@
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 /*
  * These are used to make use of C type-checking..
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-h8300/thread_info.h linux-2.6.11-rc3/include/asm-h8300/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-h8300/thread_info.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-h8300/thread_info.h	2005-02-03 02:57:16.000000000 +0100
@@ -93,6 +93,7 @@ static inline struct thread_info *curren
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_POLLING_NRFLAG	4	/* true if poll_idle() is polling
 					   TIF_NEED_RESCHED */
+#define TIF_MEMDIE		5
 
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -purN linux-2.6.11-rc2-bk10/include/asm-i386/page.h linux-2.6.11-rc3/include/asm-i386/page.h
--- linux-2.6.11-rc2-bk10/include/asm-i386/page.h	2005-01-22 02:47:29.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-i386/page.h	2005-02-03 02:55:15.000000000 +0100
@@ -36,6 +36,9 @@
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 /*
  * These are used to make use of C type-checking..
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-i386/thread_info.h linux-2.6.11-rc3/include/asm-i386/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-i386/thread_info.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-i386/thread_info.h	2005-02-03 02:55:08.000000000 +0100
@@ -141,6 +141,7 @@ register unsigned long current_stack_poi
 #define TIF_IRET		5	/* return with iret */
 #define TIF_SYSCALL_AUDIT	7	/* syscall auditing active */
 #define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		17
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-ia64/page.h linux-2.6.11-rc3/include/asm-ia64/page.h
--- linux-2.6.11-rc2-bk10/include/asm-ia64/page.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ia64/page.h	2005-02-03 02:55:08.000000000 +0100
@@ -75,6 +75,16 @@ do {						\
 	flush_dcache_page(page);		\
 } while (0)
 
+
+#define alloc_zeroed_user_highpage(vma, vaddr) \
+({						\
+	struct page *page = alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr); \
+	flush_dcache_page(page);		\
+	page;					\
+})
+
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 #define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
 
 #ifdef CONFIG_VIRTUAL_MEM_MAP
diff -purN linux-2.6.11-rc2-bk10/include/asm-ia64/thread_info.h linux-2.6.11-rc3/include/asm-ia64/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-ia64/thread_info.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ia64/thread_info.h	2005-02-03 02:57:04.000000000 +0100
@@ -75,6 +75,7 @@ struct thread_info {
 #define TIF_SYSCALL_AUDIT	4	/* syscall auditing active */
 #define TIF_SIGDELAYED		5	/* signal delayed from MCA/INIT/NMI/PMI context */
 #define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		17
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_SYSCALL_AUDIT	(1 << TIF_SYSCALL_AUDIT)
diff -purN linux-2.6.11-rc2-bk10/include/asm-m32r/page.h linux-2.6.11-rc3/include/asm-m32r/page.h
--- linux-2.6.11-rc2-bk10/include/asm-m32r/page.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-m32r/page.h	2005-02-03 02:55:23.000000000 +0100
@@ -17,6 +17,9 @@ extern void copy_page(void *to, void *fr
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 /*
  * These are used to make use of C type-checking..
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-m32r/thread_info.h linux-2.6.11-rc3/include/asm-m32r/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-m32r/thread_info.h	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-m32r/thread_info.h	2005-02-03 02:56:48.000000000 +0100
@@ -155,6 +155,7 @@ static inline unsigned int get_thread_fa
 #define TIF_IRET		5	/* return with iret */
 #define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
 					/* 31..28 fault code */
+#define TIF_MEMDIE		17
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-m68k/thread_info.h linux-2.6.11-rc3/include/asm-m68k/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-m68k/thread_info.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-m68k/thread_info.h	2005-02-03 02:56:11.000000000 +0100
@@ -48,6 +48,7 @@ struct thread_info {
 #define TIF_NOTIFY_RESUME	2	/* resumption notification requested */
 #define TIF_SIGPENDING		3	/* signal pending */
 #define TIF_NEED_RESCHED	4	/* rescheduling necessary */
+#define TIF_MEMDIE		5
 
 extern int thread_flag_fixme(void);
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-m68knommu/page.h linux-2.6.11-rc3/include/asm-m68knommu/page.h
--- linux-2.6.11-rc2-bk10/include/asm-m68knommu/page.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-m68knommu/page.h	2005-02-03 02:55:50.000000000 +0100
@@ -30,6 +30,9 @@
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 /*
  * These are used to make use of C type-checking..
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-m68knommu/thread_info.h linux-2.6.11-rc3/include/asm-m68knommu/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-m68knommu/thread_info.h	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-m68knommu/thread_info.h	2005-02-03 02:55:50.000000000 +0100
@@ -85,6 +85,7 @@ static inline struct thread_info *curren
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_POLLING_NRFLAG	4	/* true if poll_idle() is polling
 					   TIF_NEED_RESCHED */
+#define TIF_MEMDIE		5
 
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/addrspace.h linux-2.6.11-rc3/include/asm-mips/addrspace.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/addrspace.h	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/addrspace.h	2005-02-03 02:54:39.000000000 +0100
@@ -126,6 +126,7 @@
     || defined (CONFIG_CPU_R4X00)					\
     || defined (CONFIG_CPU_R5000)					\
     || defined (CONFIG_CPU_NEVADA)					\
+    || defined (CONFIG_CPU_TX49XX)					\
     || defined (CONFIG_CPU_MIPS64)
 #define	KUSIZE			0x0000010000000000	/* 2^^40 */
 #define	KUSIZE_64		0x0000010000000000	/* 2^^40 */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/bitops.h linux-2.6.11-rc3/include/asm-mips/bitops.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/bitops.h	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/bitops.h	2005-02-03 02:55:07.000000000 +0100
@@ -92,7 +92,7 @@ static inline void set_bit(unsigned long
 		__bi_flags;
 
 		a += nr >> SZLONG_LOG;
-		mask = 1 << (nr & SZLONG_MASK);
+		mask = 1UL << (nr & SZLONG_MASK);
 		__bi_local_irq_save(flags);
 		*a |= mask;
 		__bi_local_irq_restore(flags);
@@ -152,7 +152,7 @@ static inline void clear_bit(unsigned lo
 		__bi_flags;
 
 		a += nr >> SZLONG_LOG;
-		mask = 1 << (nr & SZLONG_MASK);
+		mask = 1UL << (nr & SZLONG_MASK);
 		__bi_local_irq_save(flags);
 		*a &= ~mask;
 		__bi_local_irq_restore(flags);
@@ -214,7 +214,7 @@ static inline void change_bit(unsigned l
 		__bi_flags;
 
 		a += nr >> SZLONG_LOG;
-		mask = 1 << (nr & SZLONG_MASK);
+		mask = 1UL << (nr & SZLONG_MASK);
 		__bi_local_irq_save(flags);
 		*a ^= mask;
 		__bi_local_irq_restore(flags);
@@ -293,7 +293,7 @@ static inline int test_and_set_bit(unsig
 		__bi_flags;
 
 		a += nr >> SZLONG_LOG;
-		mask = 1 << (nr & SZLONG_MASK);
+		mask = 1UL << (nr & SZLONG_MASK);
 		__bi_local_irq_save(flags);
 		retval = (mask & *a) != 0;
 		*a |= mask;
@@ -320,7 +320,7 @@ static inline int __test_and_set_bit(uns
 	int retval;
 
 	a += nr >> SZLONG_LOG;
-	mask = 1 << (nr & SZLONG_MASK);
+	mask = 1UL << (nr & SZLONG_MASK);
 	retval = (mask & *a) != 0;
 	*a |= mask;
 
@@ -385,7 +385,7 @@ static inline int test_and_clear_bit(uns
 		__bi_flags;
 
 		a += nr >> SZLONG_LOG;
-		mask = 1 << (nr & SZLONG_MASK);
+		mask = 1UL << (nr & SZLONG_MASK);
 		__bi_local_irq_save(flags);
 		retval = (mask & *a) != 0;
 		*a &= ~mask;
@@ -474,7 +474,7 @@ static inline int test_and_change_bit(un
 		__bi_flags;
 
 		a += nr >> SZLONG_LOG;
-		mask = 1 << (nr & SZLONG_MASK);
+		mask = 1UL << (nr & SZLONG_MASK);
 		__bi_local_irq_save(flags);
 		retval = (mask & *a) != 0;
 		*a ^= mask;
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/bootinfo.h linux-2.6.11-rc3/include/asm-mips/bootinfo.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/bootinfo.h	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/bootinfo.h	2005-02-03 02:55:15.000000000 +0100
@@ -195,6 +195,7 @@
 #define  MACH_CASIO_E55		5	/* CASIO CASSIOPEIA E-10/15/55/65 */
 #define  MACH_TANBAC_TB0226	6	/* TANBAC TB0226 (Mbase) */
 #define  MACH_TANBAC_TB0229	7	/* TANBAC TB0229 (VR4131DIMM) */
+#define  MACH_NEC_CMBVR4133	8	/* CMB VR4133 Board */
 
 #define MACH_GROUP_HP_LJ	20	/* Hewlett Packard LaserJet	*/
 #define  MACH_HP_LASERJET	1
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/break.h linux-2.6.11-rc3/include/asm-mips/break.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/break.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/break.h	2005-02-03 02:56:33.000000000 +0100
@@ -27,7 +27,7 @@
 #define BRK_STACKOVERFLOW 9	/* For Ada stackchecking */
 #define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
 #define _BRK_THREADBP	11	/* For threads, user bp (used by debuggers) */
-#define BRK_MULOVF	1023	/* Multiply overflow */
 #define BRK_BUG		512	/* Used by BUG() */
+#define BRK_MULOVF	1023	/* Multiply overflow */
 
 #endif /* __ASM_BREAK_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/cpu-features.h linux-2.6.11-rc3/include/asm-mips/cpu-features.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/cpu-features.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/cpu-features.h	2005-02-03 02:56:47.000000000 +0100
@@ -3,11 +3,13 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003 Ralf Baechle
+ * Copyright (C) 2003, 2004 Ralf Baechle
  */
 #ifndef __ASM_CPU_FEATURES_H
 #define __ASM_CPU_FEATURES_H
 
+#include <linux/config.h>
+
 #include <asm/cpu.h>
 #include <asm/cpu-info.h>
 #include <cpu-feature-overrides.h>
@@ -75,6 +77,25 @@
 #endif
 
 /*
+ * I-Cache snoops remote store.  This only matters on SMP.  Some multiprocessors
+ * such as the R10000 have I-Caches that snoop local stores; the embedded ones
+ * don't.  For maintaining I-cache coherency this means we need to flush the
+ * D-cache all the way back to whever the I-cache does refills from, so the
+ * I-cache has a chance to see the new data at all.  Then we have to flush the
+ * I-cache also.
+ * Note we may have been rescheduled and may no longer be running on the CPU
+ * that did the store so we can't optimize this into only doing the flush on
+ * the local CPU.
+ */
+#ifndef cpu_icache_snoops_remote_store
+#ifdef CONFIG_SMP
+#define cpu_icache_snoops_remote_store	(cpu_data[0].icache.flags & MIPS_IC_SNOOPS_REMOTE)
+#else
+#define cpu_icache_snoops_remote_store	1
+#endif
+#endif
+
+/*
  * Certain CPUs may throw bizarre exceptions if not the whole cacheline
  * contains valid instructions.  For these we ensure proper alignment of
  * signal trampolines and pad them to the size of a full cache lines with
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/cpu-info.h linux-2.6.11-rc3/include/asm-mips/cpu-info.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/cpu-info.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/cpu-info.h	2005-02-03 02:55:51.000000000 +0100
@@ -37,6 +37,7 @@ struct cache_desc {
 #define MIPS_CACHE_VTAG		0x00000002	/* Virtually tagged cache */
 #define MIPS_CACHE_ALIASES	0x00000004	/* Cache could have aliases */
 #define MIPS_CACHE_IC_F_DC	0x00000008	/* Ic can refill from D-cache */
+#define MIPS_IC_SNOOPS_REMOTE	0x00000010	/* Ic snoops remote stores */
 
 struct cpuinfo_mips {
 	unsigned long		udelay_val;
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/debug.h linux-2.6.11-rc3/include/asm-mips/debug.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/debug.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/debug.h	2005-02-03 02:55:23.000000000 +0100
@@ -29,9 +29,9 @@
 #include <linux/kernel.h>
 
 #define db_assert(x)  if (!(x)) { \
-	panic("assertion failed at %s:%d: %s\n", __FILE__, __LINE__, #x); }
+	panic("assertion failed at %s:%d: %s", __FILE__, __LINE__, #x); }
 #define db_warn(x)  if (!(x)) { \
-	printk(KERN_WARNING "warning at %s:%d: %s\n", __FILE__, __LINE__, #x); }
+	printk(KERN_WARNING "warning at %s:%d: %s", __FILE__, __LINE__, #x); }
 #define db_verify(x, y) db_assert(x y)
 #define db_verify_warn(x, y) db_warn(x y)
 #define db_run(x)  do { x; } while (0)
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/elf.h linux-2.6.11-rc3/include/asm-mips/elf.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/elf.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/elf.h	2005-02-03 02:55:50.000000000 +0100
@@ -23,7 +23,8 @@
 #define EF_MIPS_ABI_O64		0x00002000	/* O32 extended for 64 bit.  */
 
 #define PT_MIPS_REGINFO		0x70000000
-#define PT_MIPS_OPTIONS		0x70000001
+#define PT_MIPS_RTPROC		0x70000001
+#define PT_MIPS_OPTIONS		0x70000002
 
 /* Flags in the e_flags field of the header */
 #define EF_MIPS_NOREORDER	0x00000001
@@ -40,9 +41,10 @@
 #define DT_MIPS_ICHECKSUM	0x70000003
 #define DT_MIPS_IVERSION	0x70000004
 #define DT_MIPS_FLAGS		0x70000005
-  #define RHF_NONE		  0
-  #define RHF_HARDWAY		  1
-  #define RHF_NOTPOT		  2
+	#define RHF_NONE	0x00000000
+	#define RHF_HARDWAY	0x00000001
+	#define RHF_NOTPOT	0x00000002
+	#define RHF_SGI_ONLY	0x00000010
 #define DT_MIPS_BASE_ADDRESS	0x70000006
 #define DT_MIPS_CONFLICT	0x70000008
 #define DT_MIPS_LIBLIST		0x70000009
@@ -222,18 +224,22 @@ do {	current->thread.mflags &= ~MF_ABI_M
 
 #endif /* CONFIG_MIPS64 */
 
+extern void dump_regs(elf_greg_t *, struct pt_regs *regs);
+extern int dump_task_fpu(struct task_struct *, elf_fpregset_t *);
+
+#define ELF_CORE_COPY_REGS(elf_regs, regs)			\
+	dump_regs((elf_greg_t *)&(elf_regs), regs);
+#define ELF_CORE_COPY_FPREGS(tsk, elf_fpregs)			\
+	dump_task_fpu(tsk, elf_fpregs)
+
 #endif /* __KERNEL__ */
 
 /* This one accepts IRIX binaries.  */
-#define irix_elf_check_arch(hdr)	((hdr)->e_machine == EM_MIPS)
+#define irix_elf_check_arch(hdr)	((hdr)->e_flags & RHF_SGI_ONLY)
 
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	PAGE_SIZE
 
-#define ELF_CORE_COPY_REGS(_dest,_regs)				\
-	memcpy((char *) &_dest, (char *) _regs,			\
-	       sizeof(struct pt_regs));
-
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  This could be done in userspace,
    but it's not easy, and we've already done it here.  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/gt64120.h linux-2.6.11-rc3/include/asm-mips/gt64120.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/gt64120.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/gt64120.h	2005-02-03 02:56:10.000000000 +0100
@@ -1,6 +1,9 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2000, 2004, 2005  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -18,20 +21,20 @@
 #ifndef _ASM_GT64120_H
 #define _ASM_GT64120_H
 
-#include <linux/config.h>
 #include <asm/addrspace.h>
 #include <asm/byteorder.h>
 
-#define MSK(n)                    ((1 << (n)) - 1)
+#define MSK(n)			((1 << (n)) - 1)
 
 /*
  *  Register offset addresses
  */
+/* CPU Configuration.  */
 #define GT_CPU_OFS		0x000
 
-/*
- * Interrupt Registers
- */
+#define GT_MULTI_OFS		0x120
+
+/* CPU Address Decode.  */
 #define GT_SCS10LD_OFS		0x008
 #define GT_SCS10HD_OFS		0x010
 #define GT_SCS32LD_OFS		0x018
@@ -45,6 +48,7 @@
 #define GT_PCI0M0LD_OFS		0x058
 #define GT_PCI0M0HD_OFS		0x060
 #define GT_ISD_OFS		0x068
+
 #define GT_PCI0M1LD_OFS		0x080
 #define GT_PCI0M1HD_OFS		0x088
 #define GT_PCI1IOLD_OFS		0x090
@@ -53,10 +57,14 @@
 #define GT_PCI1M0HD_OFS		0x0a8
 #define GT_PCI1M1LD_OFS		0x0b0
 #define GT_PCI1M1HD_OFS		0x0b8
+#define GT_PCI1M1LD_OFS		0x0b0
+#define GT_PCI1M1HD_OFS		0x0b8
+
+#define GT_SCS10AR_OFS		0x0d0
+#define GT_SCS32AR_OFS		0x0d8
+#define GT_CS20R_OFS		0x0e0
+#define GT_CS3BOOTR_OFS		0x0e8
 
-/*
- * GT64120A only
- */
 #define GT_PCI0IOREMAP_OFS	0x0f0
 #define GT_PCI0M0REMAP_OFS	0x0f8
 #define GT_PCI0M1REMAP_OFS	0x100
@@ -64,6 +72,19 @@
 #define GT_PCI1M0REMAP_OFS	0x110
 #define GT_PCI1M1REMAP_OFS	0x118
 
+/* CPU Error Report.  */
+#define GT_CPUERR_ADDRLO_OFS	0x070
+#define GT_CPUERR_ADDRHI_OFS	0x078
+
+#define GT_CPUERR_DATALO_OFS	0x128			/* GT-64120A only  */
+#define GT_CPUERR_DATAHI_OFS	0x130			/* GT-64120A only  */
+#define GT_CPUERR_PARITY_OFS	0x138			/* GT-64120A only  */
+
+/* CPU Sync Barrier.  */
+#define GT_PCI0SYNC_OFS		0x0c0
+#define GT_PCI1SYNC_OFS		0x0c8
+
+/* SDRAM and Device Address Decode.  */
 #define GT_SCS0LD_OFS		0x400
 #define GT_SCS0HD_OFS		0x404
 #define GT_SCS1LD_OFS		0x408
@@ -83,37 +104,138 @@
 #define GT_BOOTLD_OFS		0x440
 #define GT_BOOTHD_OFS		0x444
 
-#define GT_SDRAM_B0_OFS	    	0x44c
+#define GT_ADERR_OFS		0x470
+
+/* SDRAM Configuration.  */
 #define GT_SDRAM_CFG_OFS	0x448
-#define GT_SDRAM_B2_OFS		0x454
+
 #define GT_SDRAM_OPMODE_OFS	0x474
 #define GT_SDRAM_BM_OFS		0x478
 #define GT_SDRAM_ADDRDECODE_OFS	0x47c
 
-#define GT_PCI0_CMD_OFS		0xc00	/* GT64120A only */
+/* SDRAM Parameters.  */
+#define GT_SDRAM_B0_OFS		0x44c
+#define GT_SDRAM_B1_OFS		0x450
+#define GT_SDRAM_B2_OFS		0x454
+#define GT_SDRAM_B3_OFS		0x458
+
+/* Device Parameters.  */
+#define GT_DEV_B0_OFS		0x45c
+#define GT_DEV_B1_OFS		0x460
+#define GT_DEV_B2_OFS		0x464
+#define GT_DEV_B3_OFS		0x468
+#define GT_DEV_BOOT_OFS		0x46c
+
+/* ECC.  */
+#define GT_ECC_ERRDATALO	0x480			/* GT-64120A only  */
+#define GT_ECC_ERRDATAHI	0x484			/* GT-64120A only  */
+#define GT_ECC_MEM		0x488			/* GT-64120A only  */
+#define GT_ECC_CALC		0x48c			/* GT-64120A only  */
+#define GT_ECC_ERRADDR		0x490			/* GT-64120A only  */
+
+/* DMA Record.  */
+#define GT_DMA0_CNT_OFS		0x800
+#define GT_DMA1_CNT_OFS		0x804
+#define GT_DMA2_CNT_OFS		0x808
+#define GT_DMA3_CNT_OFS		0x80c
+#define GT_DMA0_SA_OFS		0x810
+#define GT_DMA1_SA_OFS		0x814
+#define GT_DMA2_SA_OFS		0x818
+#define GT_DMA3_SA_OFS		0x81c
+#define GT_DMA0_DA_OFS		0x820
+#define GT_DMA1_DA_OFS		0x824
+#define GT_DMA2_DA_OFS		0x828
+#define GT_DMA3_DA_OFS		0x82c
+#define GT_DMA0_NEXT_OFS	0x830
+#define GT_DMA1_NEXT_OFS	0x834
+#define GT_DMA2_NEXT_OFS	0x838
+#define GT_DMA3_NEXT_OFS	0x83c
+
+#define GT_DMA0_CUR_OFS		0x870
+#define GT_DMA1_CUR_OFS		0x874
+#define GT_DMA2_CUR_OFS		0x878
+#define GT_DMA3_CUR_OFS		0x87c
+
+/* DMA Channel Control.  */
+#define GT_DMA0_CTRL_OFS	0x840
+#define GT_DMA1_CTRL_OFS	0x844
+#define GT_DMA2_CTRL_OFS	0x848
+#define GT_DMA3_CTRL_OFS	0x84c
+
+/* DMA Arbiter.  */
+#define GT_DMA_ARB_OFS		0x860
+
+/* Timer/Counter.  */
+#define GT_TC0_OFS		0x850
+#define GT_TC1_OFS		0x854
+#define GT_TC2_OFS		0x858
+#define GT_TC3_OFS		0x85c
+
+#define GT_TC_CONTROL_OFS	0x864
+
+/* PCI Internal.  */
+#define GT_PCI0_CMD_OFS		0xc00
 #define GT_PCI0_TOR_OFS		0xc04
-#define GT_PCI0_BS_SCS10_OFS    0xc08
-#define GT_PCI0_BS_SCS32_OFS    0xc0c
-#define GT_INTRCAUSE_OFS	0xc18
-#define GT_INTRMASK_OFS		0xc1c	/* GT64120A only */
+#define GT_PCI0_BS_SCS10_OFS	0xc08
+#define GT_PCI0_BS_SCS32_OFS	0xc0c
+#define GT_PCI0_BS_CS20_OFS	0xc10
+#define GT_PCI0_BS_CS3BT_OFS	0xc14
+
+#define GT_PCI1_IACK_OFS	0xc30
 #define GT_PCI0_IACK_OFS	0xc34
+
 #define GT_PCI0_BARE_OFS	0xc3c
-#define GT_HINTRCAUSE_OFS	0xc98	/* GT64120A only */
-#define GT_HINTRMASK_OFS	0xc9c	/* GT64120A only */
-#define GT_PCI1_CFGADDR_OFS	0xcf0	/* GT64120A only */
-#define GT_PCI1_CFGDATA_OFS	0xcf4	/* GT64120A only */
+#define GT_PCI0_PREFMBR_OFS	0xc40
+
+#define GT_PCI0_SCS10_BAR_OFS	0xc48
+#define GT_PCI0_SCS32_BAR_OFS	0xc4c
+#define GT_PCI0_CS20_BAR_OFS	0xc50
+#define GT_PCI0_CS3BT_BAR_OFS	0xc54
+#define GT_PCI0_SSCS10_BAR_OFS	0xc58
+#define GT_PCI0_SSCS32_BAR_OFS	0xc5c
+
+#define GT_PCI0_SCS3BT_BAR_OFS	0xc64
+
+#define GT_PCI1_CMD_OFS		0xc80
+#define GT_PCI1_TOR_OFS		0xc84
+#define GT_PCI1_BS_SCS10_OFS	0xc88
+#define GT_PCI1_BS_SCS32_OFS	0xc8c
+#define GT_PCI1_BS_CS20_OFS	0xc90
+#define GT_PCI1_BS_CS3BT_OFS	0xc94
+
+#define GT_PCI1_BARE_OFS	0xcbc
+#define GT_PCI1_PREFMBR_OFS	0xcc0
+
+#define GT_PCI1_SCS10_BAR_OFS	0xcc8
+#define GT_PCI1_SCS32_BAR_OFS	0xccc
+#define GT_PCI1_CS20_BAR_OFS	0xcd0
+#define GT_PCI1_CS3BT_BAR_OFS	0xcd4
+#define GT_PCI1_SSCS10_BAR_OFS	0xcd8
+#define GT_PCI1_SSCS32_BAR_OFS	0xcdc
+
+#define GT_PCI1_SCS3BT_BAR_OFS	0xce4
+
+#define GT_PCI1_CFGADDR_OFS	0xcf0
+#define GT_PCI1_CFGDATA_OFS	0xcf4
 #define GT_PCI0_CFGADDR_OFS	0xcf8
 #define GT_PCI0_CFGDATA_OFS	0xcfc
 
+/* Interrupts.  */
+#define GT_INTRCAUSE_OFS	0xc18
+#define GT_INTRMASK_OFS		0xc1c
+
+#define GT_PCI0_ICMASK_OFS	0xc24
+#define GT_PCI0_SERR0MASK_OFS	0xc28
+
+#define GT_CPU_INTSEL_OFS	0xc70
+#define GT_PCI0_INTSEL_OFS	0xc74
+
+#define GT_HINTRCAUSE_OFS	0xc98
+#define GT_HINTRMASK_OFS	0xc9c
+
+#define GT_PCI0_HICMASK_OFS	0xca4
+#define GT_PCI1_SERR1MASK_OFS	0xca8
 
-/*
- * Timer/Counter.  GT64120A only.
- */
-#define GT_TC0_OFS		0x850
-#define GT_TC1_OFS		0x854
-#define GT_TC2_OFS		0x858
-#define GT_TC3_OFS		0x85C
-#define GT_TC_CONTROL_OFS	0x864
 
 /*
  * I2O Support Registers
@@ -167,9 +289,9 @@
 /*
  *  Register encodings
  */
-#define GT_CPU_ENDIAN_SHF       12
-#define GT_CPU_ENDIAN_MSK       (MSK(1) << GT_CPU_ENDIAN_SHF)
-#define GT_CPU_ENDIAN_BIT       GT_CPU_ENDIAN_MSK
+#define GT_CPU_ENDIAN_SHF	12
+#define GT_CPU_ENDIAN_MSK	(MSK(1) << GT_CPU_ENDIAN_SHF)
+#define GT_CPU_ENDIAN_BIT	GT_CPU_ENDIAN_MSK
 #define GT_CPU_WR_SHF		16
 #define GT_CPU_WR_MSK		(MSK(1) << GT_CPU_WR_SHF)
 #define GT_CPU_WR_BIT		GT_CPU_WR_MSK
@@ -177,6 +299,15 @@
 #define GT_CPU_WR_DDDD		1
 
 
+#define GT_PCI_DCRM_SHF		21
+#define GT_PCI_LD_SHF		0
+#define GT_PCI_LD_MSK		(MSK(15) << GT_PCI_LD_SHF)
+#define GT_PCI_HD_SHF		0
+#define GT_PCI_HD_MSK		(MSK(7) << GT_PCI_HD_SHF)
+#define GT_PCI_REMAP_SHF	0
+#define GT_PCI_REMAP_MSK	(MSK(11) << GT_PCI_REMAP_SHF)
+
+
 #define GT_CFGADDR_CFGEN_SHF	31
 #define GT_CFGADDR_CFGEN_MSK	(MSK(1) << GT_CFGADDR_CFGEN_SHF)
 #define GT_CFGADDR_CFGEN_BIT	GT_CFGADDR_CFGEN_MSK
@@ -285,7 +416,7 @@
 #define GT_SDRAM_CFG_REFINT_MSK		(MSK(14) << GT_SDRAM_CFG_REFINT_SHF)
 
 #define GT_SDRAM_CFG_NINTERLEAVE_SHF	14
-#define GT_SDRAM_CFG_NINTERLEAVE_MSK    (MSK(1) << GT_SDRAM_CFG_NINTERLEAVE_SHF)
+#define GT_SDRAM_CFG_NINTERLEAVE_MSK	(MSK(1) << GT_SDRAM_CFG_NINTERLEAVE_SHF)
 #define GT_SDRAM_CFG_NINTERLEAVE_BIT	GT_SDRAM_CFG_NINTERLEAVE_MSK
 
 #define GT_SDRAM_CFG_RMW_SHF		15
@@ -370,7 +501,7 @@
 #define GT_PCI0_CFGADDR_REGNUM_SHF	2
 #define GT_PCI0_CFGADDR_REGNUM_MSK	(MSK(6) << GT_PCI0_CFGADDR_REGNUM_SHF)
 #define GT_PCI0_CFGADDR_FUNCTNUM_SHF	8
-#define GT_PCI0_CFGADDR_FUNCTNUM_MSK    (MSK(3) << GT_PCI0_CFGADDR_FUNCTNUM_SHF)
+#define GT_PCI0_CFGADDR_FUNCTNUM_MSK	(MSK(3) << GT_PCI0_CFGADDR_FUNCTNUM_SHF)
 #define GT_PCI0_CFGADDR_DEVNUM_SHF	11
 #define GT_PCI0_CFGADDR_DEVNUM_MSK	(MSK(5) << GT_PCI0_CFGADDR_DEVNUM_SHF)
 #define GT_PCI0_CFGADDR_BUSNUM_SHF	16
@@ -379,18 +510,18 @@
 #define GT_PCI0_CFGADDR_CONFIGEN_MSK	(MSK(1) << GT_PCI0_CFGADDR_CONFIGEN_SHF)
 #define GT_PCI0_CFGADDR_CONFIGEN_BIT	GT_PCI0_CFGADDR_CONFIGEN_MSK
 
-#define GT_PCI0_CMD_MBYTESWAP_SHF       0
-#define GT_PCI0_CMD_MBYTESWAP_MSK       (MSK(1) << GT_PCI0_CMD_MBYTESWAP_SHF)
-#define GT_PCI0_CMD_MBYTESWAP_BIT       GT_PCI0_CMD_MBYTESWAP_MSK
-#define GT_PCI0_CMD_MWORDSWAP_SHF       10
-#define GT_PCI0_CMD_MWORDSWAP_MSK       (MSK(1) << GT_PCI0_CMD_MWORDSWAP_SHF)
-#define GT_PCI0_CMD_MWORDSWAP_BIT       GT_PCI0_CMD_MWORDSWAP_MSK
-#define GT_PCI0_CMD_SBYTESWAP_SHF       16
-#define GT_PCI0_CMD_SBYTESWAP_MSK       (MSK(1) << GT_PCI0_CMD_SBYTESWAP_SHF)
-#define GT_PCI0_CMD_SBYTESWAP_BIT       GT_PCI0_CMD_SBYTESWAP_MSK
-#define GT_PCI0_CMD_SWORDSWAP_SHF       11
-#define GT_PCI0_CMD_SWORDSWAP_MSK       (MSK(1) << GT_PCI0_CMD_SWORDSWAP_SHF)
-#define GT_PCI0_CMD_SWORDSWAP_BIT       GT_PCI0_CMD_SWORDSWAP_MSK
+#define GT_PCI0_CMD_MBYTESWAP_SHF	0
+#define GT_PCI0_CMD_MBYTESWAP_MSK	(MSK(1) << GT_PCI0_CMD_MBYTESWAP_SHF)
+#define GT_PCI0_CMD_MBYTESWAP_BIT	GT_PCI0_CMD_MBYTESWAP_MSK
+#define GT_PCI0_CMD_MWORDSWAP_SHF	10
+#define GT_PCI0_CMD_MWORDSWAP_MSK	(MSK(1) << GT_PCI0_CMD_MWORDSWAP_SHF)
+#define GT_PCI0_CMD_MWORDSWAP_BIT	GT_PCI0_CMD_MWORDSWAP_MSK
+#define GT_PCI0_CMD_SBYTESWAP_SHF	16
+#define GT_PCI0_CMD_SBYTESWAP_MSK	(MSK(1) << GT_PCI0_CMD_SBYTESWAP_SHF)
+#define GT_PCI0_CMD_SBYTESWAP_BIT	GT_PCI0_CMD_SBYTESWAP_MSK
+#define GT_PCI0_CMD_SWORDSWAP_SHF	11
+#define GT_PCI0_CMD_SWORDSWAP_MSK	(MSK(1) << GT_PCI0_CMD_SWORDSWAP_SHF)
+#define GT_PCI0_CMD_SWORDSWAP_BIT	GT_PCI0_CMD_SWORDSWAP_MSK
 
 /*
  *  Misc
@@ -401,8 +532,8 @@
 #define GT_DEF_PCI0_MEM0_SIZE	0x02000000UL
 #define GT_DEF_BASE		0x14000000UL
 
-#define GT_MAX_BANKSIZE		(256 * 1024 * 1024)   /* Max 256MB bank */
-#define GT_LATTIM_MIN    	6		      /* Minimum lat	*/
+#define GT_MAX_BANKSIZE		(256 * 1024 * 1024)	/* Max 256MB bank  */
+#define GT_LATTIM_MIN		6			/* Minimum lat  */
 
 /*
  * The gt64120_dep.h file must define the following macros
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/hardirq.h linux-2.6.11-rc3/include/asm-mips/hardirq.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/hardirq.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/hardirq.h	2005-02-03 02:55:23.000000000 +0100
@@ -3,14 +3,13 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1997, 1998, 1999, 2000, 2001 by Ralf Baechle
+ * Copyright (C) 1997, 98, 99, 2000, 01, 05 Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 2001 MIPS Technologies, Inc.
  */
 #ifndef _ASM_HARDIRQ_H
 #define _ASM_HARDIRQ_H
 
-#include <linux/config.h>
 #include <linux/threads.h>
 #include <linux/irq.h>
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/hazards.h linux-2.6.11-rc3/include/asm-mips/hazards.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/hazards.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/hazards.h	2005-02-03 02:56:22.000000000 +0100
@@ -16,6 +16,10 @@
 	sll	$0, $0, 1
 	.endm
 
+	.macro	_ehb
+	sll	$0, $0, 3
+	.endm
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
@@ -23,17 +27,19 @@
  */
 #ifdef CONFIG_CPU_RM9000
 
-#define mtc0_tlbw_hazard						\
-	.set	push;							\
-	.set	mips32;							\
-	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.macro	mtc0_tlbw_hazard
+	.set	push
+	.set	mips32
+	_ssnop; _ssnop; _ssnop; _ssnop
 	.set	pop
+	.endm
 
-#define tlbw_eret_hazard						\
-	.set	push;							\
-	.set	mips32;							\
-	_ssnop; _ssnop; _ssnop; _ssnop;					\
+	.macro	tlbw_eret_hazard
+	.set	push
+	.set	mips32
+	_ssnop; _ssnop; _ssnop; _ssnop
 	.set	pop
+	.endm
 
 #else
 
@@ -43,9 +49,12 @@
  * hazard so this is nice trick to have an optimal code for a range of
  * processors.
  */
-#define mtc0_tlbw_hazard						\
+	.macro	mtc0_tlbw_hazard
 	b	. + 8
-#define tlbw_eret_hazard
+	.endm
+
+	.macro	tlbw_eret_hazard
+	.endm
 #endif
 
 /*
@@ -58,31 +67,51 @@
 /*
  * Use a macro for ehb unless explicit support for MIPSR2 is enabled
  */
-	.macro	ehb
-	sll	$0, $0, 3
-	.endm
 
-#define irq_enable_hazard						\
-	ehb		# irq_enable_hazard
+#define irq_enable_hazard
+	_ehb
 
-#define irq_disable_hazard						\
-	ehb		# irq_disable_hazard
+#define irq_disable_hazard
+	_ehb
 
-#else
+#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000)
+
+/*
+ * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ */
 
 #define irq_enable_hazard
+
 #define irq_disable_hazard
 
+#else
+
+/*
+ * Classic MIPS needs 1 - 3 nops or ssnops
+ */
+#define irq_enable_hazard
+#define irq_disable_hazard						\
+	_ssnop; _ssnop; _ssnop
+
 #endif
 
 #else /* __ASSEMBLY__ */
 
+__asm__(
+	"	.macro	_ssnop					\n\t"
+	"	sll	$0, $2, 1				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro	_ehb					\n\t"
+	"	sll	$0, $0, 3				\n\t"
+	"	.endm						\n\t");
+
+#ifdef CONFIG_CPU_RM9000
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
-#ifdef CONFIG_CPU_RM9000
 
 #define mtc0_tlbw_hazard()						\
 	__asm__ __volatile__(						\
@@ -125,27 +154,23 @@
  * Use a macro for ehb unless explicit support for MIPSR2 is enabled
  */
 __asm__(
-	"	.macro	ehb					\n\t"
-	"	sll	$0, $0, 3				\n\t"
-	"	.endm						\n\t"
-	"							\n\t"
 	"	.macro\tirq_enable_hazard			\n\t"
-	"	ehb						\n\t"
+	"	_ehb						\n\t"
 	"	.endm						\n\t"
 	"							\n\t"
 	"	.macro\tirq_disable_hazard			\n\t"
-	"	ehb						\n\t"
+	"	_ehb						\n\t"
 	"	.endm");
 
 #define irq_enable_hazard()						\
 	__asm__ __volatile__(						\
-	"ehb\t\t\t\t# irq_enable_hazard")
+	"_ehb\t\t\t\t# irq_enable_hazard")
 
 #define irq_disable_hazard()						\
 	__asm__ __volatile__(						\
-	"ehb\t\t\t\t# irq_disable_hazard")
+	"_ehb\t\t\t\t# irq_disable_hazard")
 
-#elif defined(CONFIG_CPU_R10000)
+#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000)
 
 /*
  * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
@@ -170,10 +195,6 @@ __asm__(
  */
 
 __asm__(
-	"	.macro	_ssnop					\n\t"
-	"	sll	$0, $2, 1				\n\t"
-	"	.endm						\n\t"
-	"							\n\t"
 	"	#						\n\t"
 	"	# There is a hazard but we do not care		\n\t"
 	"	#						\n\t"
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/io.h linux-2.6.11-rc3/include/asm-mips/io.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/io.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/io.h	2005-02-03 02:55:36.000000000 +0100
@@ -6,21 +6,26 @@
  * Copyright (C) 1994, 1995 Waldorf GmbH
  * Copyright (C) 1994 - 2000 Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2004, 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Author:	Maciej W. Rozycki <macro@mips.com>
  */
 #ifndef _ASM_IO_H
 #define _ASM_IO_H
 
 #include <linux/config.h>
 #include <linux/compiler.h>
+#include <linux/kernel.h>
 #include <linux/types.h>
 
 #include <asm/addrspace.h>
+#include <asm/bug.h>
+#include <asm/byteorder.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
 #include <asm/page.h>
 #include <asm/pgtable-bits.h>
 #include <asm/processor.h>
-#include <asm/byteorder.h>
+
 #include <mangle-port.h>
 
 /*
@@ -29,34 +34,54 @@
 #undef CONF_SLOWDOWN_IO
 
 /*
- * Sane hardware offers swapping of I/O space accesses in hardware; less
- * sane hardware forces software to fiddle with this ...
+ * Raw operations are never swapped in software.  Otoh values that raw
+ * operations are working on may or may not have been swapped by the bus
+ * hardware.  An example use would be for flash memory that's used for
+ * execute in place.
  */
-#if defined(CONFIG_SWAP_IO_SPACE) && defined(__MIPSEB__)
+# define __raw_ioswabb(x)	(x)
+# define __raw_ioswabw(x)	(x)
+# define __raw_ioswabl(x)	(x)
+# define __raw_ioswabq(x)	(x)
 
-#define __ioswab8(x) (x)
+/*
+ * Sane hardware offers swapping of PCI/ISA I/O space accesses in hardware;
+ * less sane hardware forces software to fiddle with this...
+ */
+#if defined(CONFIG_SWAP_IO_SPACE)
 
-#ifdef CONFIG_SGI_IP22
+# define ioswabb(x)		(x)
+# ifdef CONFIG_SGI_IP22
 /*
  * IP22 seems braindead enough to swap 16bits values in hardware, but
  * not 32bits.  Go figure... Can't tell without documentation.
  */
-#define __ioswab16(x) (x)
-#else
-#define __ioswab16(x) swab16(x)
-#endif
-#define __ioswab32(x) swab32(x)
-#define __ioswab64(x) swab64(x)
+#  define ioswabw(x)		(x)
+# else
+#  define ioswabw(x)		le16_to_cpu(x)
+# endif
+# define ioswabl(x)		le32_to_cpu(x)
+# define ioswabq(x)		le64_to_cpu(x)
 
 #else
 
-#define __ioswab8(x) (x)
-#define __ioswab16(x) (x)
-#define __ioswab32(x) (x)
-#define __ioswab64(x) (x)
+# define ioswabb(x)		(x)
+# define ioswabw(x)		(x)
+# define ioswabl(x)		(x)
+# define ioswabq(x)		(x)
 
 #endif
 
+/*
+ * Native bus accesses never swapped.
+ */
+#define bus_ioswabb(x)		(x)
+#define bus_ioswabw(x)		(x)
+#define bus_ioswabl(x)		(x)
+#define bus_ioswabq(x)		(x)
+
+#define __bus_ioswabq		bus_ioswabq
+
 #define IO_SPACE_LIMIT 0xffff
 
 /*
@@ -239,114 +264,214 @@ static inline void * __ioremap_mode(phys
 
 static inline void iounmap(volatile void __iomem *addr)
 {
-	if (cpu_has_64bits)
+	if (cpu_has_64bit_addresses)
 		return;
 
 	__iounmap(addr);
 }
 
-#define __raw_readb(addr)						\
-	(*(volatile unsigned char *) __swizzle_addr_b((unsigned long)(addr)))
-#define __raw_readw(addr)						\
-	(*(volatile unsigned short *) __swizzle_addr_w((unsigned long)(addr)))
-#define __raw_readl(addr)						\
-	(*(volatile unsigned int *) __swizzle_addr_l((unsigned long)(addr)))
-#ifdef CONFIG_MIPS32
-#define ____raw_readq(addr)						\
-({									\
-	u64 __res;							\
-									\
-	__asm__ __volatile__ (						\
-		"	.set	mips3		# ____raw_readq	\n"	\
-		"	ld	%L0, (%1)			\n"	\
-		"	dsra32	%M0, %L0, 0			\n"	\
-		"	sll	%L0, %L0, 0			\n"	\
-		"	.set	mips0				\n"	\
-		: "=r" (__res)						\
-		: "r" (__swizzle_addr_q((unsigned long)(addr))));	\
-	__res;								\
-})
-#define __raw_readq(addr)						\
-({									\
-	unsigned long __flags;						\
-	u64 __res;							\
-									\
-	local_irq_save(__flags);					\
-	__res = ____raw_readq(addr);					\
-	local_irq_restore(__flags);					\
-	__res;								\
-})
-#endif
-#ifdef CONFIG_MIPS64
-#define ____raw_readq(addr)						\
-	(*(volatile unsigned long *)__swizzle_addr_q((unsigned long)(addr)))
-#define __raw_readq(addr)	____raw_readq(addr)
-#endif
 
-#define readb(addr)		__ioswab8(__raw_readb(addr))
-#define readw(addr)		__ioswab16(__raw_readw(addr))
-#define readl(addr)		__ioswab32(__raw_readl(addr))
-#define readq(addr)		__ioswab64(__raw_readq(addr))
-#define readb_relaxed(addr)	readb(addr)
-#define readw_relaxed(addr)	readw(addr)
-#define readl_relaxed(addr)	readl(addr)
-#define readq_relaxed(addr)	readq(addr)
-
-#define __raw_writeb(b,addr)						\
-do {									\
-	((*(volatile unsigned char *)__swizzle_addr_b((unsigned long)(addr))) = (b));	\
-} while (0)
-
-#define __raw_writew(w,addr)						\
-do {									\
-	((*(volatile unsigned short *)__swizzle_addr_w((unsigned long)(addr))) = (w));	\
-} while (0)
-
-#define __raw_writel(l,addr)						\
-do {									\
-	((*(volatile unsigned int *)__swizzle_addr_l((unsigned long)(addr))) = (l));	\
-} while (0)
-
-#ifdef CONFIG_MIPS32
-#define ____raw_writeq(val,addr)					\
-do {									\
-	u64 __tmp;							\
-									\
-	__asm__ __volatile__ (						\
-		"	.set	mips3				\n"	\
-		"	dsll32	%L0, %L0, 0	# ____raw_writeq\n"	\
-		"	dsrl32	%L0, %L0, 0			\n"	\
-		"	dsll32	%M0, %M0, 0			\n"	\
-		"	or	%L0, %L0, %M0			\n"	\
-		"	sd	%L0, (%2)			\n"	\
-		"	.set	mips0				\n"	\
-		: "=r" (__tmp)						\
-		: "0" ((unsigned long long)val),			\
-		  "r" (__swizzle_addr_q((unsigned long)(addr))));	\
-} while (0)
-
-#define __raw_writeq(val,addr)						\
-do {									\
-	unsigned long __flags;						\
-									\
-	local_irq_save(__flags);					\
-	____raw_writeq(val, addr);					\
-	local_irq_restore(__flags);					\
-} while (0)
-#endif
-#ifdef CONFIG_MIPS64
-#define ____raw_writeq(q,addr)						\
-do {									\
-	*(volatile unsigned long *)__swizzle_addr_q((unsigned long)(addr)) = (q);	\
-} while (0)
+#define __BUILD_MEMORY_SINGLE(pfx, bwlq, type, irq)			\
+									\
+static inline void pfx##write##bwlq(type val,				\
+				    volatile void __iomem *mem)		\
+{									\
+	volatile type *__mem;						\
+	type __val;							\
+									\
+	__mem = (void *)__swizzle_addr_##bwlq((unsigned long)(mem));	\
+									\
+	__val = pfx##ioswab##bwlq(val);					\
+									\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	\
+		*__mem = __val;						\
+	else if (cpu_has_64bits) {					\
+		unsigned long __flags;					\
+		type __tmp;						\
+									\
+		if (irq)						\
+			local_irq_save(__flags);			\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __writeq""\n\t"	\
+			"dsll32	%L0, %L0, 0"			"\n\t"	\
+			"dsrl32	%L0, %L0, 0"			"\n\t"	\
+			"dsll32	%M0, %M0, 0"			"\n\t"	\
+			"or	%L0, %L0, %M0"			"\n\t"	\
+			"sd	%L0, %2"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__tmp)					\
+			: "0" (__val), "m" (*__mem));			\
+		if (irq)						\
+			local_irq_restore(__flags);			\
+	} else								\
+		BUG();							\
+}									\
+									\
+static inline type pfx##read##bwlq(volatile void __iomem *mem)		\
+{									\
+	volatile type *__mem;						\
+	type __val;							\
+									\
+	__mem = (void *)__swizzle_addr_##bwlq((unsigned long)(mem));	\
+									\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	\
+		__val = *__mem;						\
+	else if (cpu_has_64bits) {					\
+		unsigned long __flags;					\
+									\
+		local_irq_save(__flags);				\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __readq"	"\n\t"	\
+			"ld	%L0, %1"			"\n\t"	\
+			"dsra32	%M0, %L0, 0"			"\n\t"	\
+			"sll	%L0, %L0, 0"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__val)					\
+			: "m" (*__mem));				\
+		local_irq_restore(__flags);				\
+	} else {							\
+		__val = 0;						\
+		BUG();							\
+	}								\
+									\
+	return pfx##ioswab##bwlq(__val);				\
+}
 
-#define __raw_writeq(q,addr)	____raw_writeq(q, addr)
-#endif
+#define __BUILD_IOPORT_SINGLE(pfx, bwlq, type, p, slow)			\
+									\
+static inline void pfx##out##bwlq##p(type val, unsigned long port)	\
+{									\
+	volatile type *__addr;						\
+	type __val;							\
+									\
+	port = __swizzle_addr_##bwlq(port);				\
+	__addr = (void *)(mips_io_port_base + port);			\
+									\
+	__val = pfx##ioswab##bwlq(val);					\
+									\
+	if (sizeof(type) != sizeof(u64)) {				\
+		*__addr = __val;					\
+		slow;							\
+	} else								\
+		BUILD_BUG();						\
+}									\
+									\
+static inline type pfx##in##bwlq##p(unsigned long port)			\
+{									\
+	volatile type *__addr;						\
+	type __val;							\
+									\
+	port = __swizzle_addr_##bwlq(port);				\
+	__addr = (void *)(mips_io_port_base + port);			\
+									\
+	if (sizeof(type) != sizeof(u64)) {				\
+		__val = *__addr;					\
+		slow;							\
+	} else {							\
+		__val = 0;						\
+		BUILD_BUG();						\
+	}								\
+									\
+	return pfx##ioswab##bwlq(__val);				\
+}
+
+#define __BUILD_MEMORY_PFX(bus, bwlq, type)				\
+									\
+__BUILD_MEMORY_SINGLE(bus, bwlq, type, 1)
+
+#define __BUILD_IOPORT_PFX(bus, bwlq, type)				\
+									\
+__BUILD_IOPORT_SINGLE(bus, bwlq, type, ,)				\
+__BUILD_IOPORT_SINGLE(bus, bwlq, type, _p, SLOW_DOWN_IO)
+
+#define BUILDIO(bwlq, type)						\
+									\
+__BUILD_MEMORY_PFX(, bwlq, type)					\
+__BUILD_MEMORY_PFX(__raw_, bwlq, type)					\
+__BUILD_MEMORY_PFX(bus_, bwlq, type)					\
+__BUILD_IOPORT_PFX(, bwlq, type)					\
+__BUILD_IOPORT_PFX(__raw_, bwlq, type)
+
+#define __BUILDIO(bwlq, type)						\
+									\
+__BUILD_MEMORY_SINGLE(__bus_, bwlq, type, 0)
+
+BUILDIO(b, u8)
+BUILDIO(w, u16)
+BUILDIO(l, u32)
+BUILDIO(q, u64)
+
+__BUILDIO(q, u64)
+
+#define readb_relaxed			readb
+#define readw_relaxed			readw
+#define readl_relaxed			readl
+#define readq_relaxed			readq
+
+/*
+ * Some code tests for these symbols
+ */
+#define readq				readq
+#define writeq				writeq
+
+#define __BUILD_MEMORY_STRING(bwlq, type)				\
+									\
+static inline void writes##bwlq(volatile void __iomem *mem, void *addr,	\
+				unsigned int count)			\
+{									\
+	volatile type *__addr = addr;					\
+									\
+	while (count--) {						\
+		__raw_write##bwlq(*__addr, mem);			\
+		__addr++;						\
+	}								\
+}									\
+									\
+static inline void reads##bwlq(volatile void __iomem *mem, void *addr,	\
+			       unsigned int count)			\
+{									\
+	volatile type *__addr = addr;					\
+									\
+	while (count--) {						\
+		*__addr = __raw_read##bwlq(mem);			\
+		__addr++;						\
+	}								\
+}
+
+#define __BUILD_IOPORT_STRING(bwlq, type)				\
+									\
+static inline void outs##bwlq(unsigned long port, void *addr,		\
+			      unsigned int count)			\
+{									\
+	volatile type *__addr = addr;					\
+									\
+	while (count--) {						\
+		__raw_out##bwlq(*__addr, port);				\
+		__addr++;						\
+	}								\
+}									\
+									\
+static inline void ins##bwlq(unsigned long port, void *addr,		\
+			     unsigned int count)			\
+{									\
+	volatile type *__addr = addr;					\
+									\
+	while (count--) {						\
+		*__addr = __raw_in##bwlq(port);				\
+		__addr++;						\
+	}								\
+}
+
+#define BUILDSTRING(bwlq, type)						\
+									\
+__BUILD_MEMORY_STRING(bwlq, type)					\
+__BUILD_IOPORT_STRING(bwlq, type)
+
+BUILDSTRING(b, u8)
+BUILDSTRING(w, u16)
+BUILDSTRING(l, u32)
+BUILDSTRING(q, u64)
 
-#define writeb(b,addr)		__raw_writeb(__ioswab8(b),(addr))
-#define writew(w,addr)		__raw_writew(__ioswab16(w),(addr))
-#define writel(l,addr)		__raw_writel(__ioswab32(l),(addr))
-#define writeq(q,addr)		__raw_writeq(__ioswab64(q),(addr))
 
 /* Depends on MIPS II instruction set */
 #define mmiowb() asm volatile ("sync" ::: "memory")
@@ -356,6 +481,34 @@ do {									\
 #define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
 
 /*
+ * Memory Mapped I/O
+ */
+#define ioread8(addr)		readb(addr)
+#define ioread16(addr)		readw(addr)
+#define ioread32(addr)		readl(addr)
+
+#define iowrite8(b,addr)	writeb(b,addr)
+#define iowrite16(w,addr)	writew(w,addr)
+#define iowrite32(l,addr)	writel(l,addr)
+
+#define ioread8_rep(a,b,c)	readsb(a,b,c)
+#define ioread16_rep(a,b,c)	readsw(a,b,c)
+#define ioread32_rep(a,b,c)	readsl(a,b,c)
+
+#define iowrite8_rep(a,b,c)	writesb(a,b,c)
+#define iowrite16_rep(a,b,c)	writesw(a,b,c)
+#define iowrite32_rep(a,b,c)	writesl(a,b,c)
+
+/* Create a virtual mapping cookie for an IO port range */
+extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
+extern void ioport_unmap(void __iomem *);
+
+/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
+struct pci_dev;
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
+/*
  * ISA space is 'always mapped' on currently supported MIPS systems, no need
  * to explicitly ioremap() it. The fact that the ISA IO space is mapped
  * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
@@ -394,7 +547,7 @@ do {									\
  *     address should have been obtained by ioremap.
  *     Returns 1 on a match.
  */
-static inline int check_signature(unsigned long io_addr,
+static inline int check_signature(char __iomem *io_addr,
 	const unsigned char *signature, int length)
 {
 	int retval = 0;
@@ -410,177 +563,6 @@ out:
 	return retval;
 }
 
-static inline void __outb(unsigned char val, unsigned long port)
-{
-	port = __swizzle_addr_b(port);
-
-	*(volatile u8 *)(mips_io_port_base + port) = __ioswab8(val);
-}
-
-static inline void __outw(unsigned short val, unsigned long port)
-{
-	port = __swizzle_addr_w(port);
-
-	*(volatile u16 *)(mips_io_port_base + port) = __ioswab16(val);
-}
-
-static inline void __outl(unsigned int val, unsigned long port)
-{
-	port = __swizzle_addr_l(port);
-
-	*(volatile u32 *)(mips_io_port_base + port) = __ioswab32(val);
-}
-
-static inline void __outb_p(unsigned char val, unsigned long port)
-{
-	port = __swizzle_addr_b(port);
-
-	*(volatile u8 *)(mips_io_port_base + port) = __ioswab8(val);
-	SLOW_DOWN_IO;
-}
-
-static inline void __outw_p(unsigned short val, unsigned long port)
-{
-	port = __swizzle_addr_w(port);
-
-	*(volatile u16 *)(mips_io_port_base + port) = __ioswab16(val);
-	SLOW_DOWN_IO;
-}
-
-static inline void __outl_p(unsigned int val, unsigned long port)
-{
-	port = __swizzle_addr_l(port);
-
-	*(volatile u32 *)(mips_io_port_base + port) = __ioswab32(val);
-	SLOW_DOWN_IO;
-}
-
-#define outb(val, port)		__outb(val, port)
-#define outw(val, port)		__outw(val, port)
-#define outl(val, port)		__outl(val, port)
-#define outb_p(val, port)	__outb_p(val, port)
-#define outw_p(val, port)	__outw_p(val, port)
-#define outl_p(val, port)	__outl_p(val, port)
-
-static inline unsigned char __inb(unsigned long port)
-{
-	port = __swizzle_addr_b(port);
-
-	return __ioswab8(*(volatile u8 *)(mips_io_port_base + port));
-}
-
-static inline unsigned short __inw(unsigned long port)
-{
-	port = __swizzle_addr_w(port);
-
-	return __ioswab16(*(volatile u16 *)(mips_io_port_base + port));
-}
-
-static inline unsigned int __inl(unsigned long port)
-{
-	port = __swizzle_addr_l(port);
-
-	return __ioswab32(*(volatile u32 *)(mips_io_port_base + port));
-}
-
-static inline unsigned char __inb_p(unsigned long port)
-{
-	u8 __val;
-
-	port = __swizzle_addr_b(port);
-
-	__val = *(volatile u8 *)(mips_io_port_base + port);
-	SLOW_DOWN_IO;
-
-	return __ioswab8(__val);
-}
-
-static inline unsigned short __inw_p(unsigned long port)
-{
-	u16 __val;
-
-	port = __swizzle_addr_w(port);
-
-	__val = *(volatile u16 *)(mips_io_port_base + port);
-	SLOW_DOWN_IO;
-
-	return __ioswab16(__val);
-}
-
-static inline unsigned int __inl_p(unsigned long port)
-{
-	u32 __val;
-
-	port = __swizzle_addr_l(port);
-
-	__val = *(volatile u32 *)(mips_io_port_base + port);
-	SLOW_DOWN_IO;
-
-	return __ioswab32(__val);
-}
-
-#define inb(port)	__inb(port)
-#define inw(port)	__inw(port)
-#define inl(port)	__inl(port)
-#define inb_p(port)	__inb_p(port)
-#define inw_p(port)	__inw_p(port)
-#define inl_p(port)	__inl_p(port)
-
-static inline void __outsb(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		outb(*(u8 *)addr, port);
-		addr++;
-	}
-}
-
-static inline void __insb(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		*(u8 *)addr = inb(port);
-		addr++;
-	}
-}
-
-static inline void __outsw(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		outw(*(u16 *)addr, port);
-		addr += 2;
-	}
-}
-
-static inline void __insw(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		*(u16 *)addr = inw(port);
-		addr += 2;
-	}
-}
-
-static inline void __outsl(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		outl(*(u32 *)addr, port);
-		addr += 4;
-	}
-}
-
-static inline void __insl(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		*(u32 *)addr = inl(port);
-		addr += 4;
-	}
-}
-
-#define outsb(port, addr, count)	__outsb(port, addr, count)
-#define insb(port, addr, count)		__insb(port, addr, count)
-#define outsw(port, addr, count)	__outsw(port, addr, count)
-#define insw(port, addr, count)		__insw(port, addr, count)
-#define outsl(port, addr, count)	__outsl(port, addr, count)
-#define insl(port, addr, count)		__insl(port, addr, count)
-
 /*
  * The caches on some architectures aren't dma-coherent and have need to
  * handle this in software.  There are three types of operations that
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/ip32/crime.h linux-2.6.11-rc3/include/asm-mips/ip32/crime.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/ip32/crime.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/ip32/crime.h	2005-02-03 02:56:33.000000000 +0100
@@ -156,4 +156,6 @@ struct sgi_crime {
 
 extern struct sgi_crime *crime;
 
+#define CRIME_HI_MEM_BASE	0x40000000	/* this is where whole 1G of RAM is mapped */
+
 #endif /* __ASM_CRIME_H__ */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/irq_cpu.h linux-2.6.11-rc3/include/asm-mips/irq_cpu.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/irq_cpu.h	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/irq_cpu.h	2005-02-03 02:55:50.000000000 +0100
@@ -15,5 +15,6 @@
 
 extern void mips_cpu_irq_init(int irq_base);
 extern void rm7k_cpu_irq_init(int irq_base);
+extern void rm9k_cpu_irq_init(int irq_base);
 
 #endif /* _ASM_IRQ_CPU_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/it8172/it8172_lpc.h linux-2.6.11-rc3/include/asm-mips/it8172/it8172_lpc.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/it8172/it8172_lpc.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/it8172/it8172_lpc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-/*
- *
- * BRIEF MODULE DESCRIPTION
- *	IT8172 system controller defines.
- *
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/m48t37.h linux-2.6.11-rc3/include/asm-mips/m48t37.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/m48t37.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/m48t37.h	2005-02-03 02:57:05.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ *  Registers for the SGS-Thomson M48T37 Timekeeper RAM chip
+ */
+#ifndef _ASM_M48T37_H
+#define _ASM_M48T37_H
+
+#include <linux/spinlock.h>
+
+extern spinlock_t rtc_lock;
+
+struct m48t37_rtc {
+	volatile u8	pad[0x7ff0];    /* NVRAM */
+	volatile u8	flags;
+	volatile u8	century;
+	volatile u8	alarm_sec;
+	volatile u8	alarm_min;
+	volatile u8	alarm_hour;
+	volatile u8	alarm_data;
+	volatile u8	interrupts;
+	volatile u8	watchdog;
+	volatile u8	control;
+	volatile u8	sec;
+	volatile u8	min;
+	volatile u8	hour;
+	volatile u8	day;
+	volatile u8	date;
+	volatile u8	month;
+	volatile u8	year;
+};
+
+#define M48T37_RTC_SET		0x80
+#define M48T37_RTC_STOPPED	0x80
+#define M48T37_RTC_READ		0x40
+
+#endif /* _ASM_M48T37_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-atlas/mc146818rtc.h linux-2.6.11-rc3/include/asm-mips/mach-atlas/mc146818rtc.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-atlas/mc146818rtc.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-atlas/mc146818rtc.h	2005-02-03 02:56:49.000000000 +0100
@@ -1,7 +1,9 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
- * Copyright (C) 2003 by Ralf Baechle
+ * Copyright (C) 1999, 2000, 2005  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
+ * Copyright (C) 2003, 05 Ralf Baechle (ralf@linux-mips.org)
  *
  * This program is free software; you can distribute it and/or modify it
  * under the terms of the GNU General Public License (Version 2) as
@@ -19,33 +21,34 @@
 #ifndef __ASM_MACH_ATLAS_MC146818RTC_H
 #define __ASM_MACH_ATLAS_MC146818RTC_H
 
-#include <asm/io.h>
+#include <linux/types.h>
+
+#include <asm/addrspace.h>
+
 #include <asm/mips-boards/atlas.h>
 #include <asm/mips-boards/atlasint.h>
 
-
-#define RTC_PORT(x)	(ATLAS_RTC_ADR_REG + (x)*8)
-#define RTC_IOMAPPED	1
-#define RTC_EXTENT	16
+#define RTC_PORT(x)	(ATLAS_RTC_ADR_REG + (x) * 8)
+#define RTC_IO_EXTENT	0x100
+#define RTC_IOMAPPED	0
 #define RTC_IRQ		ATLASINT_RTC
 
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-#define ATLAS_RTC_PORT(x) (RTC_PORT(x) + 0)
-#else
-#define ATLAS_RTC_PORT(x) (RTC_PORT(x) + 3)
-#endif
-
 static inline unsigned char CMOS_READ(unsigned long addr)
 {
-	outb(addr, ATLAS_RTC_PORT(0));
+	volatile u32 *ireg = (void *)CKSEG1ADDR(RTC_PORT(0));
+	volatile u32 *dreg = (void *)CKSEG1ADDR(RTC_PORT(1));
 
-	return inb(ATLAS_RTC_PORT(1));
+	*ireg = addr;
+	return *dreg;
 }
 
 static inline void CMOS_WRITE(unsigned char data, unsigned long addr)
 {
-	outb(addr, ATLAS_RTC_PORT(0));
-	outb(data, ATLAS_RTC_PORT(1));
+	volatile u32 *ireg = (void *)CKSEG1ADDR(RTC_PORT(0));
+	volatile u32 *dreg = (void *)CKSEG1ADDR(RTC_PORT(1));
+
+	*ireg = addr;
+	*dreg = data;
 }
 
 #define RTC_ALWAYS_BCD	0
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-au1x00/au1000.h linux-2.6.11-rc3/include/asm-mips/mach-au1x00/au1000.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-au1x00/au1000.h	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-au1x00/au1000.h	2005-02-03 02:55:15.000000000 +0100
@@ -35,6 +35,8 @@
 #ifndef _AU1000_H_
 #define _AU1000_H_
 
+#include <linux/config.h>
+
 #ifndef _LANGUAGE_ASSEMBLY
 
 #include <linux/delay.h>
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-au1x00/au1xxx_dbdma.h linux-2.6.11-rc3/include/asm-mips/mach-au1x00/au1xxx_dbdma.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-au1x00/au1xxx_dbdma.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-au1x00/au1xxx_dbdma.h	2005-02-03 02:55:23.000000000 +0100
@@ -34,6 +34,8 @@
 #ifndef _AU1000_DBDMA_H_
 #define _AU1000_DBDMA_H_
 
+#include <linux/config.h>
+
 #ifndef _LANGUAGE_ASSEMBLY
 
 /* The DMA base addresses.
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-au1x00/au1xxx_psc.h linux-2.6.11-rc3/include/asm-mips/mach-au1x00/au1xxx_psc.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-au1x00/au1xxx_psc.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-au1x00/au1xxx_psc.h	2005-02-03 02:55:36.000000000 +0100
@@ -33,27 +33,14 @@
 #ifndef _AU1000_PSC_H_
 #define _AU1000_PSC_H_
 
-/* The PSC base addresses.
-*/
-#define PSC_BASE0		0xb1a00000
-#define PSC_BASE1		0xb1b00000
-#define PSC_BASE2		0xb0a00000
-#define PSC_BASE3		0xb0d00000
-
-/* These should be defined in a board specific file!
-*/
-#ifdef CONFIG_MIPS_PB1550
-#define SPI_PSC_BASE		PSC_BASE0
-#define AC97_PSC_BASE		PSC_BASE1
-#define SMBUS_PSC_BASE		PSC_BASE2
-#endif
-#ifdef CONFIG_MIPS_DB1550
-#define SPI_PSC_BASE		PSC_BASE0
-#define AC97_PSC_BASE		PSC_BASE1
-#define SMBUS_PSC_BASE		PSC_BASE2
+/* The PSC base addresses.  */
+#ifdef CONFIG_SOC_AU1550
+#define PSC0_BASE_ADDR		0xb1a00000
+#define PSC1_BASE_ADDR		0xb1b00000
+#define PSC2_BASE_ADDR		0xb0a00000
+#define PSC3_BASE_ADDR		0xb0d00000
 #endif
 
-
 /* The PSC select and control registers are common to
  * all protocols.
  */
@@ -208,4 +195,328 @@
 #define PSC_AC97RST_SNC		(1 << 0)
 
 
+/* PSC in I2S Mode.
+*/
+typedef struct	psc_i2s {
+	u32	psc_sel;
+	u32	psc_ctrl;
+	u32	psc_i2scfg;
+	u32	psc_i2smsk;
+	u32	psc_i2spcr;
+	u32	psc_i2sstat;
+	u32	psc_i2sevent;
+	u32	psc_i2stxrx;
+	u32	psc_i2sudf;
+} psc_i2s_t;
+
+/* I2S Config Register.
+*/
+#define PSC_I2SCFG_RT_MASK	(3 << 30)
+#define PSC_I2SCFG_RT_FIFO1	(0 << 30)
+#define PSC_I2SCFG_RT_FIFO2	(1 << 30)
+#define PSC_I2SCFG_RT_FIFO4	(2 << 30)
+#define PSC_I2SCFG_RT_FIFO8	(3 << 30)
+
+#define PSC_I2SCFG_TT_MASK	(3 << 28)
+#define PSC_I2SCFG_TT_FIFO1	(0 << 28)
+#define PSC_I2SCFG_TT_FIFO2	(1 << 28)
+#define PSC_I2SCFG_TT_FIFO4	(2 << 28)
+#define PSC_I2SCFG_TT_FIFO8	(3 << 28)
+
+#define PSC_I2SCFG_DD_DISABLE	(1 << 27)
+#define PSC_I2SCFG_DE_ENABLE	(1 << 26)
+#define PSC_I2SCFG_SET_WS(x)	(((((x) / 2) - 1) & 0x7f) << 16)
+#define PSC_I2SCFG_WI		(1 << 15)
+
+#define PSC_I2SCFG_DIV_MASK	(3 << 13)
+#define PSC_I2SCFG_DIV2		(0 << 13)
+#define PSC_I2SCFG_DIV4		(1 << 13)
+#define PSC_I2SCFG_DIV8		(2 << 13)
+#define PSC_I2SCFG_DIV16	(3 << 13)
+
+#define PSC_I2SCFG_BI		(1 << 12)
+#define PSC_I2SCFG_BUF		(1 << 11)
+#define PSC_I2SCFG_MLJ		(1 << 10)
+#define PSC_I2SCFG_XM		(1 << 9)
+
+/* The word length equation is simply LEN+1.
+ */
+#define PSC_I2SCFG_SET_LEN(x)	((((x) - 1) & 0x1f) << 4)
+#define PSC_I2SCFG_GET_LEN(x)	((((x) >> 4) & 0x1f) + 1)
+
+#define PSC_I2SCFG_LB		(1 << 2)
+#define PSC_I2SCFG_MLF		(1 << 1)
+#define PSC_I2SCFG_MS		(1 << 0)
+
+/* I2S Mask Register.
+*/
+#define PSC_I2SMSK_RR		(1 << 13)
+#define PSC_I2SMSK_RO		(1 << 12)
+#define PSC_I2SMSK_RU		(1 << 11)
+#define PSC_I2SMSK_TR		(1 << 10)
+#define PSC_I2SMSK_TO		(1 << 9)
+#define PSC_I2SMSK_TU		(1 << 8)
+#define PSC_I2SMSK_RD		(1 << 5)
+#define PSC_I2SMSK_TD		(1 << 4)
+#define PSC_I2SMSK_ALLMASK	(PSC_I2SMSK_RR | PSC_I2SMSK_RO | \
+				 PSC_I2SMSK_RU | PSC_I2SMSK_TR | \
+				 PSC_I2SMSK_TO | PSC_I2SMSK_TU | \
+				 PSC_I2SMSK_RD | PSC_I2SMSK_TD)
+
+/* I2S Protocol Control Register.
+*/
+#define PSC_I2SPCR_RC		(1 << 6)
+#define PSC_I2SPCR_RP		(1 << 5)
+#define PSC_I2SPCR_RS		(1 << 4)
+#define PSC_I2SPCR_TC		(1 << 2)
+#define PSC_I2SPCR_TP		(1 << 1)
+#define PSC_I2SPCR_TS		(1 << 0)
+
+/* I2S Status register (read only).
+*/
+#define PSC_I2SSTAT_RF		(1 << 13)
+#define PSC_I2SSTAT_RE		(1 << 12)
+#define PSC_I2SSTAT_RR		(1 << 11)
+#define PSC_I2SSTAT_TF		(1 << 10)
+#define PSC_I2SSTAT_TE		(1 << 9)
+#define PSC_I2SSTAT_TR		(1 << 8)
+#define PSC_I2SSTAT_RB		(1 << 5)
+#define PSC_I2SSTAT_TB		(1 << 4)
+#define PSC_I2SSTAT_DI		(1 << 2)
+#define PSC_I2SSTAT_DR		(1 << 1)
+#define PSC_I2SSTAT_SR		(1 << 0)
+
+/* I2S Event Register.
+*/
+#define PSC_I2SEVNT_RR		(1 << 13)
+#define PSC_I2SEVNT_RO		(1 << 12)
+#define PSC_I2SEVNT_RU		(1 << 11)
+#define PSC_I2SEVNT_TR		(1 << 10)
+#define PSC_I2SEVNT_TO		(1 << 9)
+#define PSC_I2SEVNT_TU		(1 << 8)
+#define PSC_I2SEVNT_RD		(1 << 5)
+#define PSC_I2SEVNT_TD		(1 << 4)
+
+/* PSC in SPI Mode.
+*/
+typedef struct	psc_spi {
+	u32	psc_sel;
+	u32	psc_ctrl;
+	u32	psc_spicfg;
+	u32	psc_spimsk;
+	u32	psc_spipcr;
+	u32	psc_spistat;
+	u32	psc_spievent;
+	u32	psc_spitxrx;
+} psc_spi_t;
+
+/* SPI Config Register.
+*/
+#define PSC_SPICFG_RT_MASK	(3 << 30)
+#define PSC_SPICFG_RT_FIFO1	(0 << 30)
+#define PSC_SPICFG_RT_FIFO2	(1 << 30)
+#define PSC_SPICFG_RT_FIFO4	(2 << 30)
+#define PSC_SPICFG_RT_FIFO8	(3 << 30)
+
+#define PSC_SPICFG_TT_MASK	(3 << 28)
+#define PSC_SPICFG_TT_FIFO1	(0 << 28)
+#define PSC_SPICFG_TT_FIFO2	(1 << 28)
+#define PSC_SPICFG_TT_FIFO4	(2 << 28)
+#define PSC_SPICFG_TT_FIFO8	(3 << 28)
+
+#define PSC_SPICFG_DD_DISABLE	(1 << 27)
+#define PSC_SPICFG_DE_ENABLE	(1 << 26)
+#define PSC_SPICFG_CLR_BAUD(x)	((x) & ~((0x3f) << 15))
+#define PSC_SPICFG_SET_BAUD(x)	(((x) & 0x3f) << 15)
+
+#define PSC_SPICFG_SET_DIV(x)	(((x) & 0x03) << 13)
+#define PSC_SPICFG_DIV2		0
+#define PSC_SPICFG_DIV4		1
+#define PSC_SPICFG_DIV8		2
+#define PSC_SPICFG_DIV16	3
+
+#define PSC_SPICFG_BI		(1 << 12)
+#define PSC_SPICFG_PSE		(1 << 11)
+#define PSC_SPICFG_CGE		(1 << 10)
+#define PSC_SPICFG_CDE		(1 << 9)
+
+#define PSC_SPICFG_CLR_LEN(x)	((x) & ~((0x1f) << 4))
+#define PSC_SPICFG_SET_LEN(x)	(((x-1) & 0x1f) << 4)
+
+#define PSC_SPICFG_LB		(1 << 3)
+#define PSC_SPICFG_MLF		(1 << 1)
+#define PSC_SPICFG_MO		(1 << 0)
+
+/* SPI Mask Register.
+*/
+#define PSC_SPIMSK_MM		(1 << 16)
+#define PSC_SPIMSK_RR		(1 << 13)
+#define PSC_SPIMSK_RO		(1 << 12)
+#define PSC_SPIMSK_RU		(1 << 11)
+#define PSC_SPIMSK_TR		(1 << 10)
+#define PSC_SPIMSK_TO		(1 << 9)
+#define PSC_SPIMSK_TU		(1 << 8)
+#define PSC_SPIMSK_SD		(1 << 5)
+#define PSC_SPIMSK_MD		(1 << 4)
+#define PSC_SPIMSK_ALLMASK	(PSC_SPIMSK_MM | PSC_SPIMSK_RR | \
+				 PSC_SPIMSK_RO | PSC_SPIMSK_TO | \
+				 PSC_SPIMSK_TU | PSC_SPIMSK_SD | \
+				 PSC_SPIMSK_MD)
+
+/* SPI Protocol Control Register.
+*/
+#define PSC_SPIPCR_RC		(1 << 6)
+#define PSC_SPIPCR_SP		(1 << 5)
+#define PSC_SPIPCR_SS		(1 << 4)
+#define PSC_SPIPCR_TC		(1 << 2)
+#define PSC_SPIPCR_MS		(1 << 0)
+
+/* SPI Status register (read only).
+*/
+#define PSC_SPISTAT_RF		(1 << 13)
+#define PSC_SPISTAT_RE		(1 << 12)
+#define PSC_SPISTAT_RR		(1 << 11)
+#define PSC_SPISTAT_TF		(1 << 10)
+#define PSC_SPISTAT_TE		(1 << 9)
+#define PSC_SPISTAT_TR		(1 << 8)
+#define PSC_SPISTAT_SB		(1 << 5)
+#define PSC_SPISTAT_MB		(1 << 4)
+#define PSC_SPISTAT_DI		(1 << 2)
+#define PSC_SPISTAT_DR		(1 << 1)
+#define PSC_SPISTAT_SR		(1 << 0)
+
+/* SPI Event Register.
+*/
+#define PSC_SPIEVNT_MM		(1 << 16)
+#define PSC_SPIEVNT_RR		(1 << 13)
+#define PSC_SPIEVNT_RO		(1 << 12)
+#define PSC_SPIEVNT_RU		(1 << 11)
+#define PSC_SPIEVNT_TR		(1 << 10)
+#define PSC_SPIEVNT_TO		(1 << 9)
+#define PSC_SPIEVNT_TU		(1 << 8)
+#define PSC_SPIEVNT_SD		(1 << 5)
+#define PSC_SPIEVNT_MD		(1 << 4)
+
+/* Transmit register control.
+*/
+#define PSC_SPITXRX_LC		(1 << 29)
+#define PSC_SPITXRX_SR		(1 << 28)
+
+/* PSC in SMBus (I2C) Mode.
+*/
+typedef struct	psc_smb {
+	u32	psc_sel;
+	u32	psc_ctrl;
+	u32	psc_smbcfg;
+	u32	psc_smbmsk;
+	u32	psc_smbpcr;
+	u32	psc_smbstat;
+	u32	psc_smbevnt;
+	u32	psc_smbtxrx;
+	u32	psc_smbtmr;
+} psc_smb_t;
+
+/* SMBus Config Register.
+*/
+#define PSC_SMBCFG_RT_MASK	(3 << 30)
+#define PSC_SMBCFG_RT_FIFO1	(0 << 30)
+#define PSC_SMBCFG_RT_FIFO2	(1 << 30)
+#define PSC_SMBCFG_RT_FIFO4	(2 << 30)
+#define PSC_SMBCFG_RT_FIFO8	(3 << 30)
+
+#define PSC_SMBCFG_TT_MASK	(3 << 28)
+#define PSC_SMBCFG_TT_FIFO1	(0 << 28)
+#define PSC_SMBCFG_TT_FIFO2	(1 << 28)
+#define PSC_SMBCFG_TT_FIFO4	(2 << 28)
+#define PSC_SMBCFG_TT_FIFO8	(3 << 28)
+
+#define PSC_SMBCFG_DD_DISABLE	(1 << 27)
+#define PSC_SMBCFG_DE_ENABLE	(1 << 26)
+
+#define PSC_SMBCFG_SET_DIV(x)	(((x) & 0x03) << 13)
+#define PSC_SMBCFG_DIV2		0
+#define PSC_SMBCFG_DIV4		1
+#define PSC_SMBCFG_DIV8		2
+#define PSC_SMBCFG_DIV16	3
+
+#define PSC_SMBCFG_GCE		(1 << 9)
+#define PSC_SMBCFG_SFM		(1 << 8)
+
+#define PSC_SMBCFG_SET_SLV(x)	(((x) & 0x7f) << 1)
+
+/* SMBus Mask Register.
+*/
+#define PSC_SMBMSK_DN		(1 << 30)
+#define PSC_SMBMSK_AN		(1 << 29)
+#define PSC_SMBMSK_AL		(1 << 28)
+#define PSC_SMBMSK_RR		(1 << 13)
+#define PSC_SMBMSK_RO		(1 << 12)
+#define PSC_SMBMSK_RU		(1 << 11)
+#define PSC_SMBMSK_TR		(1 << 10)
+#define PSC_SMBMSK_TO		(1 << 9)
+#define PSC_SMBMSK_TU		(1 << 8)
+#define PSC_SMBMSK_SD		(1 << 5)
+#define PSC_SMBMSK_MD		(1 << 4)
+#define PSC_SMBMSK_ALLMASK	(PSC_SMBMSK_DN | PSC_SMBMSK_AN | \
+				 PSC_SMBMSK_AL | PSC_SMBMSK_RR | \
+				 PSC_SMBMSK_RO | PSC_SMBMSK_TO | \
+				 PSC_SMBMSK_TU | PSC_SMBMSK_SD | \
+				 PSC_SMBMSK_MD)
+
+/* SMBus Protocol Control Register.
+*/
+#define PSC_SMBPCR_DC		(1 << 2)
+#define PSC_SMBPCR_MS		(1 << 0)
+
+/* SMBus Status register (read only).
+*/
+#define PSC_SMBSTAT_BB		(1 << 28)
+#define PSC_SMBSTAT_RF		(1 << 13)
+#define PSC_SMBSTAT_RE		(1 << 12)
+#define PSC_SMBSTAT_RR		(1 << 11)
+#define PSC_SMBSTAT_TF		(1 << 10)
+#define PSC_SMBSTAT_TE		(1 << 9)
+#define PSC_SMBSTAT_TR		(1 << 8)
+#define PSC_SMBSTAT_SB		(1 << 5)
+#define PSC_SMBSTAT_MB		(1 << 4)
+#define PSC_SMBSTAT_DI		(1 << 2)
+#define PSC_SMBSTAT_DR		(1 << 1)
+#define PSC_SMBSTAT_SR		(1 << 0)
+
+/* SMBus Event Register.
+*/
+#define PSC_SMBEVNT_DN		(1 << 30)
+#define PSC_SMBEVNT_AN		(1 << 29)
+#define PSC_SMBEVNT_AL		(1 << 28)
+#define PSC_SMBEVNT_RR		(1 << 13)
+#define PSC_SMBEVNT_RO		(1 << 12)
+#define PSC_SMBEVNT_RU		(1 << 11)
+#define PSC_SMBEVNT_TR		(1 << 10)
+#define PSC_SMBEVNT_TO		(1 << 9)
+#define PSC_SMBEVNT_TU		(1 << 8)
+#define PSC_SMBEVNT_SD		(1 << 5)
+#define PSC_SMBEVNT_MD		(1 << 4)
+#define PSC_SMBEVNT_ALLCLR	(PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | \
+				 PSC_SMBEVNT_AL | PSC_SMBEVNT_RR | \
+				 PSC_SMBEVNT_RO | PSC_SMBEVNT_TO | \
+				 PSC_SMBEVNT_TU | PSC_SMBEVNT_SD | \
+				 PSC_SMBEVNT_MD)
+
+/* Transmit register control.
+*/
+#define PSC_SMBTXRX_RSR		(1 << 30)
+#define PSC_SMBTXRX_STP		(1 << 29)
+#define PSC_SMBTXRX_DATAMASK	(0xff)
+
+/* SMBus protocol timers register.
+*/
+#define PSC_SMBTMR_SET_TH(x)	(((x) & 0x3) << 30)
+#define PSC_SMBTMR_SET_PS(x)	(((x) & 0x1f) << 25)
+#define PSC_SMBTMR_SET_PU(x)	(((x) & 0x1f) << 20)
+#define PSC_SMBTMR_SET_SH(x)	(((x) & 0x1f) << 15)
+#define PSC_SMBTMR_SET_SU(x)	(((x) & 0x1f) << 10)
+#define PSC_SMBTMR_SET_CL(x)	(((x) & 0x1f) << 5)
+#define PSC_SMBTMR_SET_CH(x)	(((x) & 0x1f) << 0)
+
+
 #endif /* _AU1000_PSC_H_ */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-db1x00/db1x00.h linux-2.6.11-rc3/include/asm-mips/mach-db1x00/db1x00.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-db1x00/db1x00.h	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-db1x00/db1x00.h	2005-02-03 02:55:53.000000000 +0100
@@ -4,6 +4,7 @@
  * Copyright 2001 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
  *         	ppopov@mvista.com or source@mvista.com
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  * ########################################################################
  *
@@ -27,6 +28,8 @@
 #ifndef __ASM_DB1X00_H
 #define __ASM_DB1X00_H
 
+#include <linux/config.h>
+
 #ifdef CONFIG_MIPS_DB1550
 #define BCSR_KSEG1_ADDR 0xAF000000
 #define NAND_PHYS_ADDR  0x20000000
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ev64120/mach-gt64120.h linux-2.6.11-rc3/include/asm-mips/mach-ev64120/mach-gt64120.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ev64120/mach-gt64120.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ev64120/mach-gt64120.h	2005-02-03 02:56:22.000000000 +0100
@@ -18,29 +18,29 @@ extern unsigned long gt64120_base;
 /*
  *   PCI Bus allocation
  */
-#define GT_PCI_MEM_BASE    0x12000000UL
-#define GT_PCI_MEM_SIZE    0x02000000UL
-#define GT_PCI_IO_BASE     0x10000000UL
-#define GT_PCI_IO_SIZE     0x02000000UL
-#define GT_ISA_IO_BASE     PCI_IO_BASE
+#define GT_PCI_MEM_BASE	0x12000000UL
+#define GT_PCI_MEM_SIZE	0x02000000UL
+#define GT_PCI_IO_BASE	0x10000000UL
+#define GT_PCI_IO_SIZE	0x02000000UL
+#define GT_ISA_IO_BASE	PCI_IO_BASE
 
 /*
  *   Duart I/O ports.
  */
-#define EV64120_COM1_BASE_ADDR  (0x1d000000 + 0x20)
-#define EV64120_COM2_BASE_ADDR  (0x1d000000 + 0x00)
+#define EV64120_COM1_BASE_ADDR	(0x1d000000 + 0x20)
+#define EV64120_COM2_BASE_ADDR	(0x1d000000 + 0x00)
 
 
 /*
  *   EV64120 interrupt controller register base.
  */
-#define EV64120_ICTRL_REGS_BASE   (KSEG1ADDR(0x1f000000))
+#define EV64120_ICTRL_REGS_BASE	(KSEG1ADDR(0x1f000000))
 
 /*
  *   EV64120 UART register base.
  */
-#define EV64120_UART0_REGS_BASE    (KSEG1ADDR(EV64120_COM1_BASE_ADDR))
-#define EV64120_UART1_REGS_BASE    (KSEG1ADDR(EV64120_COM2_BASE_ADDR))
+#define EV64120_UART0_REGS_BASE	(KSEG1ADDR(EV64120_COM1_BASE_ADDR))
+#define EV64120_UART1_REGS_BASE	(KSEG1ADDR(EV64120_COM2_BASE_ADDR))
 #define EV64120_BASE_BAUD ( 3686400 / 16 )
 
 /*
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ev96100/mach-gt64120.h linux-2.6.11-rc3/include/asm-mips/mach-ev96100/mach-gt64120.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ev96100/mach-gt64120.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ev96100/mach-gt64120.h	2005-02-03 02:57:05.000000000 +0100
@@ -18,29 +18,29 @@
  *
  *   (Guessing ...)
  */
-#define GT_PCI_MEM_BASE    0x12000000UL
-#define GT_PCI_MEM_SIZE    0x02000000UL
-#define GT_PCI_IO_BASE     0x10000000UL
-#define GT_PCI_IO_SIZE     0x02000000UL
-#define GT_ISA_IO_BASE     PCI_IO_BASE
+#define GT_PCI_MEM_BASE	0x12000000UL
+#define GT_PCI_MEM_SIZE	0x02000000UL
+#define GT_PCI_IO_BASE	0x10000000UL
+#define GT_PCI_IO_SIZE	0x02000000UL
+#define GT_ISA_IO_BASE	PCI_IO_BASE
 
 /*
  *   Duart I/O ports.
  */
-#define EV96100_COM1_BASE_ADDR  (0xBD000000 + 0x20)
-#define EV96100_COM2_BASE_ADDR  (0xBD000000 + 0x00)
+#define EV96100_COM1_BASE_ADDR	(0xBD000000 + 0x20)
+#define EV96100_COM2_BASE_ADDR	(0xBD000000 + 0x00)
 
 
 /*
  *   EV96100 interrupt controller register base.
  */
-#define EV96100_ICTRL_REGS_BASE   (KSEG1ADDR(0x1f000000))
+#define EV96100_ICTRL_REGS_BASE	(KSEG1ADDR(0x1f000000))
 
 /*
  *   EV96100 UART register base.
  */
-#define EV96100_UART0_REGS_BASE    EV96100_COM1_BASE_ADDR
-#define EV96100_UART1_REGS_BASE    EV96100_COM2_BASE_ADDR
-#define EV96100_BASE_BAUD ( 3686400 / 16 )
+#define EV96100_UART0_REGS_BASE	EV96100_COM1_BASE_ADDR
+#define EV96100_UART1_REGS_BASE	EV96100_COM2_BASE_ADDR
+#define EV96100_BASE_BAUD	( 3686400 / 16 )
 
 #endif /* _ASM_GT64120_EV96100_GT64120_DEP_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-generic/ide.h linux-2.6.11-rc3/include/asm-mips/mach-generic/ide.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-generic/ide.h	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-generic/ide.h	2005-02-03 02:56:10.000000000 +0100
@@ -16,6 +16,8 @@
 #ifdef __KERNEL__
 
 #include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/stddef.h>
 
 #ifndef MAX_HWIFS
 # ifdef CONFIG_BLK_DEV_IDEPCI
@@ -27,32 +29,68 @@
 
 #define IDE_ARCH_OBSOLETE_DEFAULTS
 
+static __inline__ int ide_probe_legacy(void)
+{
+#ifdef CONFIG_PCI
+	struct pci_dev *dev;
+	if ((dev = pci_get_class(PCI_CLASS_BRIDGE_EISA << 8, NULL)) != NULL ||
+	    (dev = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL)) != NULL) {
+		pci_dev_put(dev);
+
+		return 1;
+	}
+	return 0;
+#elif defined(CONFIG_EISA) || defined(CONFIG_ISA)
+	return 1;
+#else
+	return 0;
+#endif
+}
+
 static __inline__ int ide_default_irq(unsigned long base)
 {
-	switch (base) {
-		case 0x1f0: return 14;
-		case 0x170: return 15;
-		case 0x1e8: return 11;
-		case 0x168: return 10;
-		case 0x1e0: return 8;
-		case 0x160: return 12;
+	if (ide_probe_legacy())
+		switch (base) {
+		case 0x1f0:
+			return 14;
+		case 0x170:
+			return 15;
+		case 0x1e8:
+			return 11;
+		case 0x168:
+			return 10;
+		case 0x1e0:
+			return 8;
+		case 0x160:
+			return 12;
 		default:
 			return 0;
-	}
+		}
+	else
+		return 0;
 }
 
 static __inline__ unsigned long ide_default_io_base(int index)
 {
-	switch (index) {
-		case 0:	return 0x1f0;
-		case 1:	return 0x170;
-		case 2: return 0x1e8;
-		case 3: return 0x168;
-		case 4: return 0x1e0;
-		case 5: return 0x160;
+	if (ide_probe_legacy())
+		switch (index) {
+		case 0:
+			return 0x1f0;
+		case 1:
+			return 0x170;
+		case 2:
+			return 0x1e8;
+		case 3:
+			return 0x168;
+		case 4:
+			return 0x1e0;
+		case 5:
+			return 0x160;
 		default:
 			return 0;
-	}
+		}
+	else
+		return 0;
 }
 
 #define IDE_ARCH_OBSOLETE_INIT
@@ -64,7 +102,17 @@ static __inline__ unsigned long ide_defa
 #define ide_init_default_irq(base)	ide_default_irq(base)
 #endif
 
-#include <asm-generic/ide_iops.h>
+/* MIPS port and memory-mapped I/O string operations.  */
+
+#define __ide_insw	insw
+#define __ide_insl	insl
+#define __ide_outsw	outsw
+#define __ide_outsl	outsl
+
+#define __ide_mm_insw	readsw
+#define __ide_mm_insl	readsl
+#define __ide_mm_outsw	writesw
+#define __ide_mm_outsl	writesl
 
 #endif /* __KERNEL__ */
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip27/cpu-feature-overrides.h linux-2.6.11-rc3/include/asm-mips/mach-ip27/cpu-feature-overrides.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip27/cpu-feature-overrides.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ip27/cpu-feature-overrides.h	2005-02-03 02:56:22.000000000 +0100
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_icache_snoops_remote_store	1
 
 #define cpu_has_nofpuex		0
 #define cpu_has_64bits		1
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip32/cpu-feature-overrides.h linux-2.6.11-rc3/include/asm-mips/mach-ip32/cpu-feature-overrides.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip32/cpu-feature-overrides.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ip32/cpu-feature-overrides.h	2005-02-03 02:55:23.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Ilya A. Volynets-Evenbakh
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ */
+#ifndef __ASM_MACH_IP32_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_IP32_CPU_FEATURE_OVERRIDES_H
+
+#include <linux/config.h>
+
+/*
+ * R5000 has an interesting "restriction":  ll(d)/sc(d)
+ * instructions to XKPHYS region simply do uncached bus
+ * requests. This breaks all the atomic bitops functions.
+ * so, for 64bit IP32 kernel we just don't use ll/sc.
+ * This does not affect luserland.
+ */
+#if defined(CONFIG_CPU_R5000) && defined(CONFIG_MIPS64)
+#define cpu_has_llsc		0
+#else
+#define cpu_has_llsc		1
+#endif
+
+/* Settings which are common for all ip32 CPUs */
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_fpu		1
+#define cpu_has_32fpr		1
+#define cpu_has_counter		1
+#define cpu_has_mips16		0
+#define cpu_has_vce		0
+#define cpu_has_cache_cdex_s	0
+#define cpu_has_mcheck		0
+#define cpu_has_ejtag		0
+#define cpu_has_vtag_icache	0
+#define cpu_has_ic_fills_f_dc	0
+
+#endif /* __ASM_MACH_IP32_CPU_FEATURE_OVERRIDES_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip32/mc146818rtc.h linux-2.6.11-rc3/include/asm-mips/mach-ip32/mc146818rtc.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip32/mc146818rtc.h	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ip32/mc146818rtc.h	2005-02-03 02:55:07.000000000 +0100
@@ -15,7 +15,6 @@
 #include <asm/ip32/mace.h>
 
 #define RTC_PORT(x)	(0x70 + (x))
-#define RTC_IRQ		MACEISA_RTC_IRQ
 
 static unsigned char CMOS_READ(unsigned long addr)
 {
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip32/spaces.h linux-2.6.11-rc3/include/asm-mips/mach-ip32/spaces.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ip32/spaces.h	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ip32/spaces.h	2005-02-03 02:57:04.000000000 +0100
@@ -3,20 +3,13 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 1994 - 1999, 2000, 03, 04, 05 Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2000, 2002  Maciej W. Rozycki
  * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
  */
 #ifndef _ASM_MACH_IP32_SPACES_H
 #define _ASM_MACH_IP32_SPACES_H
 
-#include <linux/config.h>
-
-/*
- * This handles the memory map.
- */
-#define PAGE_OFFSET		0xffffffff80000000
-
 /*
  * Memory above this physical address will be considered highmem.
  * Fixme: 59 bits is a fictive number and makes assumptions about processors
@@ -26,11 +19,7 @@
 #define HIGHMEM_START		(1UL << 59UL)
 #endif
 
-#ifdef CONFIG_DMA_NONCOHERENT
 #define CAC_BASE		0x9800000000000000
-#else
-#define CAC_BASE		0xa800000000000000
-#endif
 #define IO_BASE			0x9000000000000000
 #define UNCAC_BASE		0x9000000000000000
 #define MAP_BASE		0xc000000000000000
@@ -39,4 +28,9 @@
 #define TO_CAC(x)		(CAC_BASE   | ((x) & TO_PHYS_MASK))
 #define TO_UNCAC(x)		(UNCAC_BASE | ((x) & TO_PHYS_MASK))
 
+/*
+ * This handles the memory map.
+ */
+#define PAGE_OFFSET		CAC_BASE
+
 #endif /* __ASM_MACH_IP32_SPACES_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ja/cpu-feature-overrides.h linux-2.6.11-rc3/include/asm-mips/mach-ja/cpu-feature-overrides.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ja/cpu-feature-overrides.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ja/cpu-feature-overrides.h	2005-02-03 02:56:22.000000000 +0100
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex		0
 #define cpu_has_64bits		1
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-lasat/mach-gt64120.h linux-2.6.11-rc3/include/asm-mips/mach-lasat/mach-gt64120.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-lasat/mach-gt64120.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-lasat/mach-gt64120.h	2005-02-03 02:55:07.000000000 +0100
@@ -18,10 +18,10 @@
  *
  *   (Guessing ...)
  */
-#define GT_PCI_MEM_BASE    0x12000000UL
-#define GT_PCI_MEM_SIZE    0x02000000UL
-#define GT_PCI_IO_BASE     0x10000000UL
-#define GT_PCI_IO_SIZE     0x02000000UL
-#define GT_ISA_IO_BASE     PCI_IO_BASE
+#define GT_PCI_MEM_BASE	0x12000000UL
+#define GT_PCI_MEM_SIZE	0x02000000UL
+#define GT_PCI_IO_BASE	0x10000000UL
+#define GT_PCI_IO_SIZE	0x02000000UL
+#define GT_ISA_IO_BASE	PCI_IO_BASE
 
 #endif /* _ASM_GT64120_LASAT_GT64120_DEP_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-mips/cpu-feature-overrides.h linux-2.6.11-rc3/include/asm-mips/mach-mips/cpu-feature-overrides.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-mips/cpu-feature-overrides.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-mips/cpu-feature-overrides.h	2005-02-03 02:55:23.000000000 +0100
@@ -4,10 +4,13 @@
  * for more details.
  *
  * Copyright (C) 2003, 2004 Chris Dearman
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  */
 #ifndef __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H
 #define __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H
 
+#include <linux/config.h>
+
 /*
  * CPU feature overrides for MIPS boards
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-mips/mach-gt64120.h linux-2.6.11-rc3/include/asm-mips/mach-mips/mach-gt64120.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-mips/mach-gt64120.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-mips/mach-gt64120.h	2005-02-03 02:55:51.000000000 +0100
@@ -8,7 +8,7 @@
 #ifndef _ASM_MACH_MIPS_MACH_GT64120_DEP_H
 #define _ASM_MACH_MIPS_MACH_GT64120_DEP_H
 
-#define MIPS_GT_BASE    0x1be00000
+#define MIPS_GT_BASE	0x1be00000
 
 extern unsigned long _pcictrl_gt64120;
 /*
@@ -19,10 +19,10 @@ extern unsigned long _pcictrl_gt64120;
 /*
  *   PCI Bus allocation
  */
-#define GT_PCI_MEM_BASE    0x12000000UL
-#define GT_PCI_MEM_SIZE    0x02000000UL
-#define GT_PCI_IO_BASE     0x10000000UL
-#define GT_PCI_IO_SIZE     0x02000000UL
-#define GT_ISA_IO_BASE     PCI_IO_BASE
+#define GT_PCI_MEM_BASE	0x12000000UL
+#define GT_PCI_MEM_SIZE	0x02000000UL
+#define GT_PCI_IO_BASE	0x10000000UL
+#define GT_PCI_IO_SIZE	0x02000000UL
+#define GT_ISA_IO_BASE	PCI_IO_BASE
 
 #endif /* _ASM_MACH_MIPS_MACH_GT64120_DEP_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ocelot/mach-gt64120.h linux-2.6.11-rc3/include/asm-mips/mach-ocelot/mach-gt64120.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ocelot/mach-gt64120.h	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ocelot/mach-gt64120.h	2005-02-03 02:56:10.000000000 +0100
@@ -13,14 +13,14 @@
 /*
  * PCI address allocation
  */
-#define GT_PCI_MEM_BASE    (0x22000000UL)
-#define GT_PCI_MEM_SIZE    GT_DEF_PCI0_MEM0_SIZE
-#define GT_PCI_IO_BASE     (0x20000000UL)
-#define GT_PCI_IO_SIZE     GT_DEF_PCI0_IO_SIZE
+#define GT_PCI_MEM_BASE	(0x22000000UL)
+#define GT_PCI_MEM_SIZE	GT_DEF_PCI0_MEM0_SIZE
+#define GT_PCI_IO_BASE	(0x20000000UL)
+#define GT_PCI_IO_SIZE	GT_DEF_PCI0_IO_SIZE
 
 extern unsigned long gt64120_base;
 
-#define GT64120_BASE       (gt64120_base)
+#define GT64120_BASE	(gt64120_base)
 
 /*
  * GT timer irq
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h linux-2.6.11-rc3/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h	2005-02-03 02:55:22.000000000 +0100
@@ -28,6 +28,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex 	0
 #define cpu_has_64bits		1
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-pb1x00/pb1550.h linux-2.6.11-rc3/include/asm-mips/mach-pb1x00/pb1550.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-pb1x00/pb1550.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-pb1x00/pb1550.h	2005-02-03 02:56:33.000000000 +0100
@@ -3,6 +3,7 @@
  * Board Registers defines.
  *
  * Copyright 2004 Embedded Edge LLC.
+ * Copyright 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  * ########################################################################
  *
@@ -26,8 +27,19 @@
 #ifndef __ASM_PB1550_H
 #define __ASM_PB1550_H
 
+#include <linux/config.h>
 #include <linux/types.h>
 
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC3_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC3_RX
+
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC2_BASE_ADDR
+#define I2S_PSC_BASE        PSC3_BASE_ADDR
+
 #define BCSR_PHYS_ADDR 0xAF000000
 
 typedef volatile struct
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-sibyte/cpu-feature-overrides.h linux-2.6.11-rc3/include/asm-mips/mach-sibyte/cpu-feature-overrides.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-sibyte/cpu-feature-overrides.h	2005-01-22 02:48:02.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-sibyte/cpu-feature-overrides.h	2005-02-03 02:55:52.000000000 +0100
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	1
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex		0
 #define cpu_has_64bits		1
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mach-yosemite/cpu-feature-overrides.h linux-2.6.11-rc3/include/asm-mips/mach-yosemite/cpu-feature-overrides.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mach-yosemite/cpu-feature-overrides.h	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mach-yosemite/cpu-feature-overrides.h	2005-02-03 02:56:10.000000000 +0100
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex		0
 #define cpu_has_64bits		1
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mipsregs.h linux-2.6.11-rc3/include/asm-mips/mipsregs.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mipsregs.h	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mipsregs.h	2005-02-03 02:55:52.000000000 +0100
@@ -533,31 +533,50 @@
 #ifndef __ASSEMBLY__
 
 /*
- * Functions to access the r10k performance counter and control registers
+ * Functions to access the R10000 performance counters.  These are basically
+ * mfc0 and mtc0 instructions from and to coprocessor register with a 5-bit
+ * performance counter number encoded into bits 1 ... 5 of the instruction.
+ * Only performance counters 0 to 1 actually exist, so for a non-R10000 aware
+ * disassembler these will look like an access to sel 0 or 1.
  */
-#define read_r10k_perf_cntr(counter)                            \
-({ unsigned int __res;                                          \
-        __asm__ __volatile__(                                   \
-        "mfpc\t%0, "STR(counter)                                \
-        : "=r" (__res));                                        \
-        __res;})
+#define read_r10k_perf_cntr(counter)				\
+({								\
+	unsigned int __res;					\
+	__asm__ __volatile__(					\
+	"mfpc\t%0, %1"						\
+        : "=r" (__res)						\
+	: "i" (counter));					\
+								\
+        __res;							\
+})
 
 #define write_r10k_perf_cntr(counter,val)                       \
-        __asm__ __volatile__(                                   \
-        "mtpc\t%0, "STR(counter)                                \
-        : : "r" (val));
-
-#define read_r10k_perf_cntl(counter)                            \
-({ unsigned int __res;                                          \
-        __asm__ __volatile__(                                   \
-        "mfps\t%0, "STR(counter)                                \
-        : "=r" (__res));                                        \
-        __res;})
+do {								\
+	__asm__ __volatile__(					\
+	"mtpc\t%0, %1"						\
+	:							\
+	: "r" (val), "i" (counter));				\
+} while (0)
+
+#define read_r10k_perf_event(counter)				\
+({								\
+	unsigned int __res;					\
+	__asm__ __volatile__(					\
+	"mfps\t%0, %1"						\
+        : "=r" (__res)						\
+	: "i" (counter));					\
+								\
+        __res;							\
+})
 
 #define write_r10k_perf_cntl(counter,val)                       \
-        __asm__ __volatile__(                                   \
-        "mtps\t%0, "STR(counter)                                \
-        : : "r" (val));
+do {								\
+	__asm__ __volatile__(					\
+	"mtps\t%0, %1"						\
+	:							\
+	: "r" (val), "i" (counter));				\
+} while (0)
+
 
 /*
  * Macros to access the system control coprocessor
@@ -579,8 +598,10 @@
 })
 
 #define __read_64bit_c0_register(source, sel)				\
-({ unsigned long __res;							\
-	if (sel == 0)							\
+({ unsigned long long __res;						\
+	if (sizeof(unsigned long) == 4)					\
+		__res = __read_64bit_c0_split(source, sel);		\
+	else if (sel == 0)						\
 		__asm__ __volatile__(					\
 			".set\tmips3\n\t"				\
 			"dmfc0\t%0, " #source "\n\t"			\
@@ -611,7 +632,9 @@ do {									\
 
 #define __write_64bit_c0_register(register, sel, value)			\
 do {									\
-	if (sel == 0)							\
+	if (sizeof(unsigned long) == 4)					\
+		__write_64bit_c0_split(register, sel, value);		\
+	else if (sel == 0)						\
 		__asm__ __volatile__(					\
 			".set\tmips3\n\t"				\
 			"dmtc0\t%z0, " #register "\n\t"			\
@@ -627,8 +650,8 @@ do {									\
 
 #define __read_ulong_c0_register(reg, sel)				\
 	((sizeof(unsigned long) == 4) ?					\
-	__read_32bit_c0_register(reg, sel) :				\
-	__read_64bit_c0_register(reg, sel))
+	(unsigned long) __read_32bit_c0_register(reg, sel) :		\
+	(unsigned long) __read_64bit_c0_register(reg, sel))
 
 #define __write_ulong_c0_register(reg, sel, val)			\
 do {									\
@@ -822,6 +845,10 @@ do {									\
 #define read_c0_framemask()	__read_32bit_c0_register($21, 0)
 #define write_c0_framemask(val)	__write_32bit_c0_register($21, 0, val)
 
+/* RM9000 PerfControl performance counter control register */
+#define read_c0_perfcontrol()	__read_32bit_c0_register($22, 0)
+#define write_c0_perfcontrol(val) __write_32bit_c0_register($22, 0, val)
+
 #define read_c0_diag()		__read_32bit_c0_register($22, 0)
 #define write_c0_diag(val)	__write_32bit_c0_register($22, 0, val)
 
@@ -846,6 +873,30 @@ do {									\
 #define read_c0_depc()		__read_ulong_c0_register($24, 0)
 #define write_c0_depc(val)	__write_ulong_c0_register($24, 0, val)
 
+/*
+ * MIPS32 / MIPS64 performance counters
+ */
+#define read_c0_perfctrl0()	__read_32bit_c0_register($25, 0)
+#define write_c0_perfctrl0(val)	__write_32bit_c0_register($25, 0, val)
+#define read_c0_perfcntr0()	__read_32bit_c0_register($25, 1)
+#define write_c0_perfcntr0(val)	__write_32bit_c0_register($25, 1, val)
+#define read_c0_perfctrl1()	__read_32bit_c0_register($25, 2)
+#define write_c0_perfctrl1(val)	__write_32bit_c0_register($25, 2, val)
+#define read_c0_perfcntr1()	__read_32bit_c0_register($25, 3)
+#define write_c0_perfcntr1(val)	__write_32bit_c0_register($25, 3, val)
+#define read_c0_perfctrl2()	__read_32bit_c0_register($25, 4)
+#define write_c0_perfctrl2(val)	__write_32bit_c0_register($25, 4, val)
+#define read_c0_perfcntr2()	__read_32bit_c0_register($25, 5)
+#define write_c0_perfcntr2(val)	__write_32bit_c0_register($25, 5, val)
+#define read_c0_perfctrl3()	__read_32bit_c0_register($25, 6)
+#define write_c0_perfctrl3(val)	__write_32bit_c0_register($25, 6, val)
+#define read_c0_perfcntr3()	__read_32bit_c0_register($25, 7)
+#define write_c0_perfcntr3(val)	__write_32bit_c0_register($25, 7, val)
+
+/* RM9000 PerfCount performance counter register */
+#define read_c0_perfcount()	__read_64bit_c0_register($25, 0)
+#define write_c0_perfcount(val)	__write_64bit_c0_register($25, 0, val)
+
 #define read_c0_ecc()		__read_32bit_c0_register($26, 0)
 #define write_c0_ecc(val)	__write_32bit_c0_register($26, 0, val)
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/mmu_context.h linux-2.6.11-rc3/include/asm-mips/mmu_context.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/mmu_context.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/mmu_context.h	2005-02-03 02:55:51.000000000 +0100
@@ -19,26 +19,30 @@
 #include <asm/tlbflush.h>
 
 /*
- * For the fast tlb miss handlers, we currently keep a per cpu array
- * of pointers to the current pgd for each processor. Also, the proc.
- * id is stuffed into the context register. This should be changed to
- * use the processor id via current->processor, where current is stored
- * in watchhi/lo. The context register should be used to contiguously
- * map the page tables.
+ * For the fast tlb miss handlers, we keep a per cpu array of pointers
+ * to the current pgd for each processor. Also, the proc. id is stuffed
+ * into the context register.
  */
+extern unsigned long pgd_current[];
+
 #define TLBMISS_HANDLER_SETUP_PGD(pgd) \
 	pgd_current[smp_processor_id()] = (unsigned long)(pgd)
+
 #ifdef CONFIG_MIPS32
-#define TLBMISS_HANDLER_SETUP() \
-	write_c0_context((unsigned long) smp_processor_id() << 23); \
+#define TLBMISS_HANDLER_SETUP()						\
+	write_c0_context((unsigned long) smp_processor_id() << 23);	\
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 #endif
-#ifdef CONFIG_MIPS64
-#define TLBMISS_HANDLER_SETUP() \
+#if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
+#define TLBMISS_HANDLER_SETUP()						\
 	write_c0_context((unsigned long) &pgd_current[smp_processor_id()] << 23); \
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 #endif
-extern unsigned long pgd_current[];
+#if defined(CONFIG_MIPS64) && defined(CONFIG_BUILD_ELF64)
+#define TLBMISS_HANDLER_SETUP()						\
+	write_c0_context((unsigned long) smp_processor_id() << 23);	\
+	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
+#endif
 
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 
@@ -150,7 +154,7 @@ static inline void
 activate_mm(struct mm_struct *prev, struct mm_struct *next)
 {
 	unsigned long flags;
-	int cpu = smp_processor_id();
+	unsigned int cpu = smp_processor_id();
 
 	local_irq_save(flags);
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/pgtable-32.h linux-2.6.11-rc3/include/asm-mips/pgtable-32.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/pgtable-32.h	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/pgtable-32.h	2005-02-03 02:55:52.000000000 +0100
@@ -98,7 +98,7 @@ extern int add_temporary_entry(unsigned 
 
 extern void load_pgd(unsigned long pg_dir);
 
-extern pmd_t invalid_pte_table[PAGE_SIZE/sizeof(pmd_t)];
+extern pte_t invalid_pte_table[PAGE_SIZE/sizeof(pte_t)];
 
 /*
  * Empty pgd/pmd entries point to the invalid_pte_table.
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/pmon.h linux-2.6.11-rc3/include/asm-mips/pmon.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/pmon.h	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/pmon.h	2005-02-03 02:55:15.000000000 +0100
@@ -4,22 +4,43 @@
  * for more details.
  *
  * Copyright (C) 2004 by Ralf Baechle
+ *
+ * The cpustart method is a PMC-Sierra's function to start the secondary CPU.
+ * Stock PMON 2000 has the smpfork, semlock and semunlock methods instead.
  */
 #ifndef _ASM_PMON_H
 #define _ASM_PMON_H
 
 struct callvectors {
-	int	(*open) (char*, int, int);		/*	 0 */
-	int	(*close) (int);				/*	 4 */
-	int	(*read) (int, void*, int);		/*	 8 */
-	int	(*write) (int, void*, int);		/*	12 */
-	off_t	(*lseek) (int, off_t, int);		/*	16 */
-	int	(*printf) (const char*, ...);		/*	20 */
-	void	(*cacheflush) (void);			/*	24 */
-	char*	(*gets) (char*);			/*	28 */
-	int	(*cpustart) (int, void *, int, int);	/*	32 */
+	int	(*open) (char*, int, int);
+	int	(*close) (int);
+	int	(*read) (int, void*, int);
+	int	(*write) (int, void*, int);
+	off_t	(*lseek) (int, off_t, int);
+	int	(*printf) (const char*, ...);
+	void	(*cacheflush) (void);
+	char*	(*gets) (char*);
+	union {
+		int	(*smpfork) (unsigned long cp, char *sp);
+		int	(*cpustart) (long, long, long, long);
+	} _s;
+	int	(*semlock) (int sem);
+	void	(*semunlock) (int sem);
 };
 
 extern struct callvectors *debug_vectors;
 
+#define pmon_open(name, flags, mode)	debug_vectors->open(name, flage, mode)
+#define pmon_close(fd)			debug_vectors->close(fd)
+#define pmon_read(fd, buf, count)	debug_vectors->read(fd, buf, count)
+#define pmon_write(fd, buf, count)	debug_vectors->write(fd, buf, count)
+#define pmon_lseek(fd, off, whence)	debug_vectors->lseek(fd, off, whence)
+#define pmon_printf(fmt...)		debug_vectors->printf(fmt)
+#define pmon_cacheflush()		debug_vectors->cacheflush()
+#define pmon_gets(s)			debug_vectors->gets(s)
+#define pmon_cpustart(n, f, sp, gp)	debug_vectors->_s.cpustart(n, f, sp, gp)
+#define pmon_smpfork(cp, sp)		debug_vectors->_s.smpfork(cp, sp)
+#define pmon_semlock(sem)		debug_vectors->semlock(sem)
+#define pmon_semunlock(sem)		debug_vectors->semunlock(sem)
+
 #endif /* _ASM_PMON_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/prefetch.h linux-2.6.11-rc3/include/asm-mips/prefetch.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/prefetch.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/prefetch.h	2005-02-03 02:57:16.000000000 +0100
@@ -8,6 +8,8 @@
 #ifndef __ASM_PREFETCH_H
 #define __ASM_PREFETCH_H
 
+#include <linux/config.h>
+
 /*
  * R5000 and RM5200 implements pref and prefx instructions but they're nops, so
  * rather than wasting time we pretend these processors don't support
@@ -41,4 +43,46 @@
 #define Pref_WriteBackInvalidate	25
 #define Pref_PrepareForStore		30
 
+#ifdef __ASSEMBLY__
+
+	.macro	__pref hint addr
+#ifdef CONFIG_CPU_HAS_PREFETCH
+	pref	\hint, \addr
+#endif
+	.endm
+
+	.macro	pref_load addr
+	__pref	Pref_Load, \addr
+	.endm
+
+	.macro	pref_store addr
+	__pref	Pref_Store, \addr
+	.endm
+
+	.macro	pref_load_streamed addr
+	__pref	Pref_LoadStreamed, \addr
+	.endm
+
+	.macro	pref_store_streamed addr
+	__pref	Pref_StoreStreamed, \addr
+	.endm
+
+	.macro	pref_load_retained addr
+	__pref	Pref_LoadRetained, \addr
+	.endm
+
+	.macro	pref_store_retained addr
+	__pref	Pref_StoreRetained, \addr
+	.endm
+
+	.macro	pref_wback_inv addr
+	__pref	Pref_WriteBackInvalidate, \addr
+	.endm
+
+	.macro	pref_prepare_for_store addr
+	__pref	Pref_PrepareForStore, \addr
+	.endm
+
+#endif
+
 #endif /* __ASM_PREFETCH_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/processor.h linux-2.6.11-rc3/include/asm-mips/processor.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/processor.h	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/processor.h	2005-02-03 02:54:59.000000000 +0100
@@ -66,11 +66,6 @@ extern unsigned int vced_count, vcei_cou
 	PAGE_ALIGN(TASK_SIZE32 / 3) : PAGE_ALIGN(TASK_SIZE / 3))
 #endif
 
-/*
- * Size of io_bitmap in longwords.
- */
-#define IO_BITMAP_SIZE	2048
-
 #define NUM_FPU_REGS	32
 
 typedef __u64 fpureg_t;
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/r4kcache.h linux-2.6.11-rc3/include/asm-mips/r4kcache.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/r4kcache.h	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/r4kcache.h	2005-02-03 02:55:07.000000000 +0100
@@ -117,6 +117,21 @@ static inline void protected_writeback_d
 		: "i" (Hit_Writeback_Inv_D), "r" (addr));
 }
 
+static inline void protected_writeback_scache_line(unsigned long addr)
+{
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".set mips3\n"
+		"1:\tcache %0,(%1)\n"
+		"2:\t.set mips0\n\t"
+		".set reorder\n\t"
+		".section\t__ex_table,\"a\"\n\t"
+		STR(PTR)"\t1b,2b\n\t"
+		".previous"
+		:
+		: "i" (Hit_Writeback_Inv_SD), "r" (addr));
+}
+
 /*
  * This one is RM7000-specific
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/reg.h linux-2.6.11-rc3/include/asm-mips/reg.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/reg.h	2005-02-03 02:56:33.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * Various register offset definitions for debuggers, core file
+ * examiners and whatnot.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1999 Ralf Baechle
+ * Copyright (C) 1995, 1999 Silicon Graphics
+ */
+#ifndef __ASM_MIPS_REG_H
+#define __ASM_MIPS_REG_H
+
+#include <linux/config.h>
+
+#if defined(CONFIG_MIPS32) || defined(WANT_COMPAT_REG_H)
+
+#define EF_R0			6
+#define EF_R1			7
+#define EF_R2			8
+#define EF_R3			9
+#define EF_R4			10
+#define EF_R5			11
+#define EF_R6			12
+#define EF_R7			13
+#define EF_R8			14
+#define EF_R9			15
+#define EF_R10			16
+#define EF_R11			17
+#define EF_R12			18
+#define EF_R13			19
+#define EF_R14			20
+#define EF_R15			21
+#define EF_R16			22
+#define EF_R17			23
+#define EF_R18			24
+#define EF_R19			25
+#define EF_R20			26
+#define EF_R21			27
+#define EF_R22			28
+#define EF_R23			29
+#define EF_R24			30
+#define EF_R25			31
+
+/*
+ * k0/k1 unsaved
+ */
+#define EF_R26			32
+#define EF_R27			33
+
+#define EF_R28			34
+#define EF_R29			35
+#define EF_R30			36
+#define EF_R31			37
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			38
+#define EF_HI			39
+
+#define EF_CP0_EPC		40
+#define EF_CP0_BADVADDR		41
+#define EF_CP0_STATUS		42
+#define EF_CP0_CAUSE		43
+#define EF_UNUSED0		44
+
+#define EF_SIZE			180
+
+#endif
+
+#if CONFIG_MIPS64
+
+#define EF_R0			 0
+#define EF_R1			 1
+#define EF_R2			 2
+#define EF_R3			 3
+#define EF_R4			 4
+#define EF_R5			 5
+#define EF_R6			 6
+#define EF_R7			 7
+#define EF_R8			 8
+#define EF_R9			 9
+#define EF_R10			10
+#define EF_R11			11
+#define EF_R12			12
+#define EF_R13			13
+#define EF_R14			14
+#define EF_R15			15
+#define EF_R16			16
+#define EF_R17			17
+#define EF_R18			18
+#define EF_R19			19
+#define EF_R20			20
+#define EF_R21			21
+#define EF_R22			22
+#define EF_R23			23
+#define EF_R24			24
+#define EF_R25			25
+
+/*
+ * k0/k1 unsaved
+ */
+#define EF_R26			26
+#define EF_R27			27
+
+
+#define EF_R28			28
+#define EF_R29			29
+#define EF_R30			30
+#define EF_R31			31
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			32
+#define EF_HI			33
+
+#define EF_CP0_EPC		34
+#define EF_CP0_BADVADDR		35
+#define EF_CP0_STATUS		36
+#define EF_CP0_CAUSE		37
+
+#define EF_SIZE			304	/* size in bytes */
+
+#endif /* CONFIG_MIPS64 */
+
+#endif /* __ASM_MIPS_REG_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/sibyte/sb1250.h linux-2.6.11-rc3/include/asm-mips/sibyte/sb1250.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/sibyte/sb1250.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/sibyte/sb1250.h	2005-02-03 02:56:33.000000000 +0100
@@ -58,6 +58,6 @@ extern void prom_printf(char *fmt, ...);
 
 #endif
 
-#define IOADDR(a) (UNCAC_BASE + (a))
+#define IOADDR(a) (IO_BASE + (a))
 
 #endif
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/sigcontext.h linux-2.6.11-rc3/include/asm-mips/sigcontext.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/sigcontext.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/sigcontext.h	2005-02-03 02:57:04.000000000 +0100
@@ -41,8 +41,6 @@ struct sigcontext {
                                                                                 
 #if _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32
 
-#include <linux/types.h>
-
 /*
  * Keep this struct definition in sync with the sigcontext fragment
  * in arch/mips/tools/offset.c
@@ -66,6 +64,9 @@ struct sigcontext {
 };
 
 #ifdef __KERNEL__
+
+#include <linux/posix_types.h>
+
 struct sigcontext32 {
 	__u32	sc_regmask;		/* Unused */
 	__u32	sc_status;
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/sn/mapped_kernel.h linux-2.6.11-rc3/include/asm-mips/sn/mapped_kernel.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/sn/mapped_kernel.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/sn/mapped_kernel.h	2005-02-03 02:55:50.000000000 +0100
@@ -23,10 +23,16 @@
 #include <linux/config.h>
 #include <asm/addrspace.h>
 
+#ifdef CONFIG_BUILD_ELF64
+#define REP_BASE	CAC_BASE
+#else
+#define REP_BASE	CKSEG0
+#endif
+
 #ifdef CONFIG_MAPPED_KERNEL
 
-#define MAPPED_ADDR_RO_TO_PHYS(x)	(x - CKSSEG)
-#define MAPPED_ADDR_RW_TO_PHYS(x)	(x - CKSSEG - 16777216)
+#define MAPPED_ADDR_RO_TO_PHYS(x)	(x - REP_BASE)
+#define MAPPED_ADDR_RW_TO_PHYS(x)	(x - REP_BASE - 16777216)
 
 #define MAPPED_KERN_RO_PHYSBASE(n) \
 			(PLAT_NODE_DATA(n)->kern_vars.kv_ro_baseaddr)
@@ -42,8 +48,8 @@
 
 #else /* CONFIG_MAPPED_KERNEL */
 
-#define MAPPED_KERN_RO_TO_PHYS(x)	(x - CKSEG0)
-#define MAPPED_KERN_RW_TO_PHYS(x)	(x - CKSEG0)
+#define MAPPED_KERN_RO_TO_PHYS(x)	(x - REP_BASE)
+#define MAPPED_KERN_RW_TO_PHYS(x)	(x - REP_BASE)
 
 #endif /* CONFIG_MAPPED_KERNEL */
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/sn/sn0/hubio.h linux-2.6.11-rc3/include/asm-mips/sn/sn0/hubio.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/sn/sn0/hubio.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/sn/sn0/hubio.h	2005-02-03 02:55:07.000000000 +0100
@@ -486,6 +486,7 @@ typedef union h1_icrba_u {
 #define ICRBN_A_CERR_SHFT	54
 #define ICRBN_A_ERR_MASK	0x3ff
 
+#if 0	/* Disabled, this causes namespace polution and break allmodconfig */
 /*
  * Easy access macros.
  */
@@ -499,6 +500,7 @@ typedef union h1_icrba_u {
 #define	a_addr		icrba_fields_s.addr
 #define	a_valid		icrba_fields_s.valid
 #define	a_iow		icrba_fields_s.iow
+#endif
 
 #endif /* !__ASSEMBLY__ */
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/sn/sn_private.h linux-2.6.11-rc3/include/asm-mips/sn/sn_private.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/sn/sn_private.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/sn/sn_private.h	2005-02-03 02:56:22.000000000 +0100
@@ -12,8 +12,8 @@ extern void cpu_time_init(void);
 extern void per_cpu_init(void);
 extern void install_cpu_nmi_handler(int slice);
 extern void install_ipi(void);
-extern void setup_replication_mask();
-extern void replicate_kernel_text();
+extern void setup_replication_mask(void);
+extern void replicate_kernel_text(void);
 extern pfn_t node_getfirstfree(cnodeid_t);
 
 #endif /* __ASM_SN_SN_PRIVATE_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/spinlock.h linux-2.6.11-rc3/include/asm-mips/spinlock.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/spinlock.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/spinlock.h	2005-02-03 02:56:53.000000000 +0100
@@ -9,6 +9,7 @@
 #ifndef _ASM_SPINLOCK_H
 #define _ASM_SPINLOCK_H
 
+#include <linux/config.h>
 #include <asm/war.h>
 
 /*
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/stackframe.h linux-2.6.11-rc3/include/asm-mips/stackframe.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/stackframe.h	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/stackframe.h	2005-02-03 02:54:39.000000000 +0100
@@ -64,7 +64,7 @@
 		addu	k1, k0
 		LONG_L	k1, %lo(kernelsp)(k1)
 #endif
-#ifdef CONFIG_MIPS64
+#if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
 		MFC0	k1, CP0_CONTEXT
 		dsra	k1, 23
 		lui	k0, %hi(pgd_current)
@@ -74,6 +74,12 @@
 		daddu	k1, k0
 		LONG_L	k1, %lo(kernelsp)(k1)
 #endif
+#if defined(CONFIG_MIPS64) && defined(CONFIG_BUILD_ELF64)
+		MFC0	k1, CP0_CONTEXT
+		dsrl	k1, 23
+		dsll	k1, k1, 3
+		LONG_L	k1, kernelsp(k1)
+#endif
 		.endm
 
 		.macro	set_saved_sp stackp temp temp2
@@ -83,13 +89,18 @@
 		sll	\temp, 2
 		LONG_S	\stackp, kernelsp(\temp)
 #endif
-#ifdef CONFIG_MIPS64
+#if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
 		lw	\temp, TI_CPU(gp)
 		dsll	\temp, 3
 		lui	\temp2, %hi(kernelsp)
 		daddu	\temp, \temp2
 		LONG_S	\stackp, %lo(kernelsp)(\temp)
 #endif
+#if defined(CONFIG_MIPS64) && defined(CONFIG_BUILD_ELF64)
+		lw	\temp, TI_CPU(gp)
+		dsll	\temp, 3
+		LONG_S	\stackp, kernelsp(\temp)
+#endif
 		.endm
 #else
 		.macro	get_saved_sp	/* Uniprocessor variation */
@@ -104,6 +115,7 @@
 
 		.macro	SAVE_SOME
 		.set	push
+		.set	noat
 		.set	reorder
 		mfc0	k0, CP0_STATUS
 		sll	k0, 3		/* extract cu0 bit */
@@ -278,16 +290,16 @@
 
 		.macro	RESTORE_ALL
 		RESTORE_TEMP
-		RESTORE_AT
 		RESTORE_STATIC
+		RESTORE_AT
 		RESTORE_SOME
 		RESTORE_SP
 		.endm
 
 		.macro	RESTORE_ALL_AND_RET
 		RESTORE_TEMP
-		RESTORE_AT
 		RESTORE_STATIC
+		RESTORE_AT
 		RESTORE_SOME
 		RESTORE_SP_AND_RET
 		.endm
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/string.h linux-2.6.11-rc3/include/asm-mips/string.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/string.h	2005-02-03 10:03:10.034473568 +0100
+++ linux-2.6.11-rc3/include/asm-mips/string.h	2005-02-03 02:54:38.000000000 +0100
@@ -18,6 +18,8 @@
  */
 #ifdef CONFIG_MIPS32
 
+#ifndef IN_STRING_C
+
 #define __HAVE_ARCH_STRCPY
 static __inline__ char *strcpy(char *__dest, __const__ char *__src)
 {
@@ -96,6 +98,8 @@ static __inline__ int strcmp(__const__ c
   return __res;
 }
 
+#endif /* !defined(IN_STRING_C) */
+
 #define __HAVE_ARCH_STRNCMP
 static __inline__ int
 strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count)
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/thread_info.h linux-2.6.11-rc3/include/asm-mips/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/thread_info.h	2005-01-22 02:46:40.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/thread_info.h	2005-02-03 02:54:37.000000000 +0100
@@ -116,6 +116,7 @@ register struct thread_info *__current_t
 #define TIF_SYSCALL_AUDIT	4	/* syscall auditing active */
 #define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
 #define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		18
 #define TIF_SYSCALL_TRACE	31	/* syscall trace active */
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/uaccess.h linux-2.6.11-rc3/include/asm-mips/uaccess.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/uaccess.h	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/uaccess.h	2005-02-03 02:54:59.000000000 +0100
@@ -150,7 +150,7 @@ static inline int verify_area(int type, 
  * Returns zero on success, or -EFAULT on error.
  */
 #define put_user(x,ptr)	\
-	__put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__put_user_check((x),(ptr),sizeof(*(ptr)))
 
 /*
  * get_user: - Get a simple variable from user space.
@@ -170,7 +170,7 @@ static inline int verify_area(int type, 
  * On error, the variable @x is set to zero.
  */
 #define get_user(x,ptr) \
-	__get_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__get_user_check((x),(ptr),sizeof(*(ptr)))
 
 /*
  * __put_user: - Write a simple value into user space, with less checking.
@@ -192,7 +192,7 @@ static inline int verify_area(int type, 
  * Returns zero on success, or -EFAULT on error.
  */
 #define __put_user(x,ptr) \
-	__put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__put_user_nocheck((x),(ptr),sizeof(*(ptr)))
 
 /*
  * __get_user: - Get a simple variable from user space, with less checking.
@@ -215,7 +215,7 @@ static inline int verify_area(int type, 
  * On error, the variable @x is set to zero.
  */
 #define __get_user(x,ptr) \
-	__get_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+	__get_user_nocheck((x),(ptr),sizeof(*(ptr)))
 
 struct __large_struct { unsigned long buf[100]; };
 #define __m(x) (*(struct __large_struct *)(x))
@@ -232,9 +232,10 @@ struct __large_struct { unsigned long bu
 
 #define __get_user_nocheck(x,ptr,size)					\
 ({									\
-	long __gu_err = 0;						\
 	__typeof(*(ptr)) __gu_val = 0;					\
 	long __gu_addr;							\
+	long __gu_err = 0;						\
+									\
 	might_sleep();							\
 	__gu_addr = (long) (ptr);					\
 	switch (size) {							\
@@ -244,17 +245,18 @@ struct __large_struct { unsigned long bu
 	case 8: __GET_USER_DW(__gu_err); break;				\
 	default: __get_user_unknown(); break;				\
 	}								\
-	 x = (__typeof__(*(ptr))) __gu_val;				\
+	x = (__typeof__(*(ptr))) __gu_val;				\
 	__gu_err;							\
 })
 
 #define __get_user_check(x,ptr,size)					\
 ({									\
 	__typeof__(*(ptr)) __gu_val = 0;				\
-	long __gu_addr = (long) (ptr);					\
+	long __gu_addr;							\
 	long __gu_err;							\
 									\
 	might_sleep();							\
+	__gu_addr = (long) (ptr);					\
 	__gu_err = verify_area(VERIFY_READ, (void *) __gu_addr, size);	\
 									\
 	if (likely(!__gu_err)) {					\
@@ -267,7 +269,7 @@ struct __large_struct { unsigned long bu
 		}							\
 	}								\
 	x = (__typeof__(*(ptr))) __gu_val;				\
-	 __gu_err;							\
+	__gu_err;							\
 })
 
 #define __get_user_asm(insn,__gu_err)					\
@@ -324,9 +326,10 @@ extern void __get_user_unknown(void);
 
 #define __put_user_nocheck(x,ptr,size)					\
 ({									\
-	long __pu_err = 0;						\
 	__typeof__(*(ptr)) __pu_val;					\
 	long __pu_addr;							\
+	long __pu_err = 0;						\
+									\
 	might_sleep();							\
 	__pu_val = (x);							\
 	__pu_addr = (long) (ptr);					\
@@ -342,11 +345,13 @@ extern void __get_user_unknown(void);
 
 #define __put_user_check(x,ptr,size)					\
 ({									\
-	__typeof__(*(ptr)) __pu_val = (x);				\
-	long __pu_addr = (long) (ptr);					\
+	__typeof__(*(ptr)) __pu_val;					\
+	long __pu_addr;							\
 	long __pu_err;							\
 									\
 	might_sleep();							\
+	__pu_val = (x);							\
+	__pu_addr = (long) (ptr);					\
 	__pu_err = verify_area(VERIFY_WRITE, (void *) __pu_addr, size);	\
 									\
 	if (likely(!__pu_err)) {					\
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/unistd.h linux-2.6.11-rc3/include/asm-mips/unistd.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/unistd.h	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/unistd.h	2005-02-03 02:54:52.000000000 +0100
@@ -1100,6 +1100,9 @@ type name (atype a,btype b,ctype c,dtype
 #endif /* (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
 
 #ifdef __KERNEL__
+
+#include <linux/config.h>
+
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
 #define __ARCH_WANT_SYS_ALARM
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/vr41xx/cmbvr4133.h linux-2.6.11-rc3/include/asm-mips/vr41xx/cmbvr4133.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/vr41xx/cmbvr4133.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/vr41xx/cmbvr4133.h	2005-02-03 02:55:51.000000000 +0100
@@ -0,0 +1,61 @@
+/*
+ * include/asm-mips/vr41xx/cmbvr4133.h
+ *
+ * Include file for NEC CMB-VR4133.
+ *
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com> and
+ *         Jun Sun <jsun@mvista.com, or source@mvista.com> and
+ *         Alex Sapkov <asapkov@ru.mvista.com>
+ *
+ * 2002-2004 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __NEC_CMBVR4133_H
+#define __NEC_CMBVR4133_H
+
+#include <asm/addrspace.h>
+#include <asm/vr41xx/vr41xx.h>
+
+/*
+ * General-Purpose I/O Pin Number
+ */
+#define CMBVR41XX_INTA_PIN		1
+#define CMBVR41XX_INTB_PIN		1
+#define CMBVR41XX_INTC_PIN		3
+#define CMBVR41XX_INTD_PIN		1
+#define CMBVR41XX_INTE_PIN		1
+
+/*
+ * Interrupt Number
+ */
+#define CMBVR41XX_INTA_IRQ		GIU_IRQ(CMBVR41XX_INTA_PIN)
+#define CMBVR41XX_INTB_IRQ		GIU_IRQ(CMBVR41XX_INTB_PIN)
+#define CMBVR41XX_INTC_IRQ		GIU_IRQ(CMBVR41XX_INTC_PIN)
+#define CMBVR41XX_INTD_IRQ		GIU_IRQ(CMBVR41XX_INTD_PIN)
+#define CMBVR41XX_INTE_IRQ		GIU_IRQ(CMBVR41XX_INTE_PIN)
+
+#define I8259_IRQ_BASE			72
+#define I8259_IRQ(x)			(I8259_IRQ_BASE + (x))
+#define TIMER_IRQ			I8259_IRQ(0)
+#define KEYBOARD_IRQ			I8259_IRQ(1)
+#define I8259_SLAVE_IRQ			I8259_IRQ(2)
+#define UART3_IRQ			I8259_IRQ(3)
+#define UART1_IRQ			I8259_IRQ(4)
+#define UART2_IRQ			I8259_IRQ(5)
+#define FDC_IRQ				I8259_IRQ(6)
+#define PARPORT_IRQ			I8259_IRQ(7)
+#define RTC_IRQ				I8259_IRQ(8)
+#define USB_IRQ				I8259_IRQ(9)
+#define I8259_INTA_IRQ			I8259_IRQ(10)
+#define AUDIO_IRQ			I8259_IRQ(11)
+#define AUX_IRQ				I8259_IRQ(12)
+#define IDE_PRIMARY_IRQ			I8259_IRQ(14)
+#define IDE_SECONDARY_IRQ		I8259_IRQ(15)
+#define I8259_IRQ_LAST			IDE_SECONDARY_IRQ
+
+#define RTC_PORT(x)	(0xaf000100 + (x))
+#define RTC_IO_EXTENT	0x140
+
+#endif /* __NEC_CMBVR4133_H */
diff -purN linux-2.6.11-rc2-bk10/include/asm-mips/vr41xx/vrc4173.h linux-2.6.11-rc3/include/asm-mips/vr41xx/vrc4173.h
--- linux-2.6.11-rc2-bk10/include/asm-mips/vr41xx/vrc4173.h	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-mips/vr41xx/vrc4173.h	2005-02-03 02:56:48.000000000 +0100
@@ -5,6 +5,7 @@
  *  Copyright (C) 2001-2003 Montavista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
  *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -23,6 +24,7 @@
 #ifndef __NEC_VRC4173_H 
 #define __NEC_VRC4173_H 
 
+#include <linux/config.h>
 #include <asm/io.h>
 
 /*
diff -purN linux-2.6.11-rc2-bk10/include/asm-parisc/thread_info.h linux-2.6.11-rc3/include/asm-parisc/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-parisc/thread_info.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-parisc/thread_info.h	2005-02-03 02:55:35.000000000 +0100
@@ -63,6 +63,7 @@ struct thread_info {
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_POLLING_NRFLAG	4	/* true if poll_idle() is polling TIF_NEED_RESCHED */
 #define TIF_32BIT               5       /* 32 bit binary */
+#define TIF_MEMDIE		6
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/ibm44x.h linux-2.6.11-rc3/include/asm-ppc/ibm44x.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/ibm44x.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/ibm44x.h	2005-02-03 02:57:17.000000000 +0100
@@ -239,7 +239,7 @@
 #define MALOBISR_CH0		0x80000000	/* EOB channel 1 bit */
 #define MALOBISR_CH2		0x40000000	/* EOB channel 2 bit */
 
-/* 440GP PLB Arbiter DCRs */
+/* 440GP/GX PLB Arbiter DCRs */
 #define DCRN_PLB0_REVID		0x082		/* PLB Arbiter Revision ID */
 #define DCRN_PLB0_ACR		0x083		/* PLB Arbiter Control */
 #define DCRN_PLB0_BESR		0x084		/* PLB Error Status */
@@ -247,6 +247,17 @@
 #define DCRN_PLB0_BEAR		DCRN_PLB0_BEARL	/* 40x compatibility */
 #define DCRN_PLB0_BEARH		0x087		/* PLB Error Address High */
 
+/* 440GP/GX PLB to OPB bridge DCRs */
+#define DCRN_POB0_BESR0		0x090
+#define DCRN_POB0_BESR1		0x094
+#define DCRN_POB0_BEARL		0x092
+#define DCRN_POB0_BEARH		0x093
+
+/* 440GP/GX OPB to PLB bridge DCRs */
+#define DCRN_OPB0_BSTAT		0x0a9
+#define DCRN_OPB0_BEARL		0x0aa
+#define DCRN_OPB0_BEARH		0x0ab
+
 /* 440GP Clock, PM, chip control */
 #define DCRN_CPC0_SR		0x0b0
 #define DCRN_CPC0_ER		0x0b1
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/mpc10x.h linux-2.6.11-rc3/include/asm-ppc/mpc10x.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/mpc10x.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/mpc10x.h	2005-02-03 02:56:22.000000000 +0100
@@ -105,8 +105,12 @@
 #define	MPC10X_CFG_PICR1_ADDR_MAP_MASK	0x00010000
 #define	MPC10X_CFG_PICR1_ADDR_MAP_A	0x00010000
 #define	MPC10X_CFG_PICR1_ADDR_MAP_B	0x00000000
+#define	MPC10X_CFG_PICR1_SPEC_PCI_RD	0x00000004
 #define	MPC10X_CFG_PICR1_ST_GATH_EN	0x00000040
 
+#define	MPC10X_CFG_PICR2_REG		0xac
+#define	MPC10X_CFG_PICR2_COPYBACK_OPT	0x00000001
+
 #define	MPC10X_CFG_MAPB_OPTIONS_REG	0xe0
 #define	MPC10X_CFG_MAPB_OPTIONS_CFAE	0x80	/* CPU_FD_ALIAS_EN */
 #define	MPC10X_CFG_MAPB_OPTIONS_PFAE	0x40	/* PCI_FD_ALIAS_EN */
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/mpc85xx.h linux-2.6.11-rc3/include/asm-ppc/mpc85xx.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/mpc85xx.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/mpc85xx.h	2005-02-03 02:57:16.000000000 +0100
@@ -34,6 +34,9 @@
 #ifdef CONFIG_SBC8560
 #include <platforms/85xx/sbc8560.h>
 #endif
+#ifdef CONFIG_STX_GP3
+#include <platforms/85xx/stx_gp3.h>
+#endif
 
 #define _IO_BASE        isa_io_base
 #define _ISA_MEM_BASE   isa_mem_base
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/mv64x60.h linux-2.6.11-rc3/include/asm-ppc/mv64x60.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/mv64x60.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/mv64x60.h	2005-02-03 02:56:22.000000000 +0100
@@ -27,7 +27,7 @@
 #include <asm/pci-bridge.h>
 #include <asm/mv64x60_defs.h>
 
-extern u8      mv64x60_pci_exclude_bridge;
+extern u8	mv64x60_pci_exclude_bridge;
 
 extern spinlock_t mv64x60_lock;
 
@@ -210,7 +210,7 @@ struct mv64x60_chip_info {
 	void	(*enable_window_64bit)(mv64x60_handle_t *bh, u32 window);
 	void	(*disable_window_64bit)(mv64x60_handle_t *bh, u32 window);
 	void	(*disable_all_windows)(mv64x60_handle_t *bh,
-		       struct mv64x60_setup_info *si);
+			struct mv64x60_setup_info *si);
 	void	(*config_io2mem_windows)(mv64x60_handle_t *bh,
 			struct mv64x60_setup_info *si,
 			u32 mem_windows[MV64x60_CPU2MEM_WINDOWS][2]);
@@ -223,16 +223,16 @@ struct mv64x60_chip_info {
 };
 
 struct mv64x60_handle {
-	u32	type;		/* type of bridge */
-	u32	rev;		/* revision of bridge */
-	u32	v_base;		/* virtual base addr of bridge regs */
-	u32	p_base;		/* physical base addr of bridge regs */
+	u32		type;		/* type of bridge */
+	u32		rev;		/* revision of bridge */
+	void		*v_base;	/* virtual base addr of bridge regs */
+	phys_addr_t	p_base;		/* physical base addr of bridge regs */
 
-	u32	pci_mode_a;	/* pci bus 0 mode: conventional pci, pci-x */
-	u32	pci_mode_b;	/* pci bus 1 mode: conventional pci, pci-x */
+	u32		pci_mode_a;	/* pci 0 mode: conventional pci, pci-x*/
+	u32		pci_mode_b;	/* pci 1 mode: conventional pci, pci-x*/
 
-	u32	io_base_a;	/* vaddr of pci 0's I/O space */
-	u32	io_base_b;	/* vaddr of pci 1's I/O space */
+	u32		io_base_a;	/* vaddr of pci 0's I/O space */
+	u32		io_base_b;	/* vaddr of pci 1's I/O space */
 
 	struct pci_controller	*hose_a;
 	struct pci_controller	*hose_b;
@@ -247,7 +247,7 @@ mv64x60_write(struct mv64x60_handle *bh,
 	ulong	flags;
 
 	spin_lock_irqsave(&mv64x60_lock, flags);
-	out_le32((volatile u32 *)(bh->v_base + offset), val);
+	out_le32(bh->v_base + offset, val);
 	spin_unlock_irqrestore(&mv64x60_lock, flags);
 }
 
@@ -256,7 +256,7 @@ mv64x60_read(struct mv64x60_handle *bh, 
 	ulong	flags;
 
 	spin_lock_irqsave(&mv64x60_lock, flags);
-	return in_le32((volatile u32 *)(bh->v_base + offset));
+	return in_le32(bh->v_base + offset);
 	spin_unlock_irqrestore(&mv64x60_lock, flags);
 }
 
@@ -282,11 +282,11 @@ int mv64x60_init(struct mv64x60_handle *
 u32 mv64x60_get_mem_size(u32 bridge_base, u32 chip_type);
 void mv64x60_early_init(struct mv64x60_handle *bh,
 	struct mv64x60_setup_info *si);
-void mv64x60_alloc_hose(struct mv64x60_handle *bh, u32 cfg_addr, u32 cfg_data,
-	struct pci_controller **hose);
+void mv64x60_alloc_hose(struct mv64x60_handle *bh, u32 cfg_addr,
+	u32 cfg_data, struct pci_controller **hose);
 int mv64x60_get_type(struct mv64x60_handle *bh);
 int mv64x60_setup_for_chip(struct mv64x60_handle *bh);
-u32 mv64x60_get_bridge_vbase(void);
+void *mv64x60_get_bridge_vbase(void);
 u32 mv64x60_get_bridge_type(void);
 u32 mv64x60_get_bridge_rev(void);
 void mv64x60_get_mem_windows(struct mv64x60_handle *bh,
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/mv64x60_defs.h linux-2.6.11-rc3/include/asm-ppc/mv64x60_defs.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/mv64x60_defs.h	2005-01-22 02:48:47.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/mv64x60_defs.h	2005-02-03 02:56:33.000000000 +0100
@@ -216,9 +216,9 @@
 #define MV64360_CPU1_SYNC_BARRIER_VIRT		0x00d8
 
 /* CPU Deadlock and Ordering registers (Rev B part only) */
-#define GT64260_CPU_DEADLOCK_ORDERING                   0x02d0
-#define GT64260_CPU_WB_PRIORITY_BUFFER_DEPTH            0x02d8
-#define GT64260_CPU_COUNTERS_SYNC_BARRIER_ATTRIBUTE     0x02e0
+#define GT64260_CPU_DEADLOCK_ORDERING			0x02d0
+#define GT64260_CPU_WB_PRIORITY_BUFFER_DEPTH		0x02d8
+#define GT64260_CPU_COUNTERS_SYNC_BARRIER_ATTRIBUTE	0x02e0
 
 /* CPU Access Protection Registers (gt64260 realy has 8 but don't need) */
 #define	MV64x260_CPU_PROT_WINDOWS		4
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/pmac_feature.h linux-2.6.11-rc3/include/asm-ppc/pmac_feature.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/pmac_feature.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/pmac_feature.h	2005-02-03 02:57:04.000000000 +0100
@@ -125,6 +125,7 @@
 #define PMAC_MB_HAS_FW_POWER		0x00000002
 #define PMAC_MB_OLD_CORE99		0x00000004
 #define PMAC_MB_MOBILE			0x00000008
+#define PMAC_MB_MAY_SLEEP		0x00000010
 
 /*
  * Feature calls supported on pmac
@@ -238,7 +239,10 @@ static inline long pmac_call_feature(int
 
 /* PMAC_FTR_SLEEP_STATE		(struct device_node* node, 0, int value)
  * set the sleep state of the motherboard.
+ *
  * Pass -1 as value to query for sleep capability
+ * Pass 1 to set IOs to sleep
+ * Pass 0 to set IOs to wake
  */
 #define PMAC_FTR_SLEEP_STATE		PMAC_FTR_DEF(15)
 
@@ -279,11 +283,22 @@ static inline long pmac_call_feature(int
  */
 #define PMAC_FTR_AACK_DELAY_ENABLE     	PMAC_FTR_DEF(20)
 
+/* PMAC_FTR_DEVICE_CAN_WAKE
+ *
+ * Used by video drivers to inform system that they can actually perform
+ * wakeup from sleep
+ */
+#define PMAC_FTR_DEVICE_CAN_WAKE	PMAC_FTR_DEF(22)
+
 
 /* Don't use those directly, they are for the sake of pmac_setup.c */
 extern long pmac_do_feature_call(unsigned int selector, ...);
 extern void pmac_feature_init(void);
 
+/* Video suspend tweak */
+extern void pmac_set_early_video_resume(void (*proc)(void *data), void *data);
+extern void pmac_call_early_video_resume(void);
+
 #define PMAC_FTR_DEF(x) ((_MACH_Pmac << 16) | (x))
 
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/reg.h linux-2.6.11-rc3/include/asm-ppc/reg.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/reg.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/reg.h	2005-02-03 02:57:17.000000000 +0100
@@ -244,6 +244,10 @@
 #define L2CR_L2DF		0x00004000	/* L2 differential clock */
 #define L2CR_L2BYP		0x00002000	/* L2 DLL bypass */
 #define L2CR_L2IP		0x00000001	/* L2 GI in progress */
+#define L2CR_L2IO_745x		0x00100000	/* L2 instr. only (745x) */
+#define L2CR_L2DO_745x		0x00010000	/* L2 data only (745x) */
+#define L2CR_L2REP_745x		0x00001000	/* L2 repl. algorithm (745x) */
+#define L2CR_L2HWF_745x		0x00000800	/* L2 hardware flush (745x) */
 #define SPRN_L3CR		0x3FA	/* Level 3 Cache Control Regsiter */
 #define L3CR_L3E		0x80000000	/* L3 enable */
 #define L3CR_L3PE		0x40000000	/* L3 data parity enable */
@@ -329,7 +333,6 @@
 #define MMCR0_PMC2_CYCLES	0x1
 #define MMCR0_PMC2_ITLB		0x7
 #define MMCR0_PMC2_LOADMISSTIME	0x5
-#define MMCR0_PMXE		(1 << 26)
 
 /* Short-hand versions for a number of the above SPRNs */
 #define CTR	SPRN_CTR	/* Counter Register */
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/thread_info.h linux-2.6.11-rc3/include/asm-ppc/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/thread_info.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/thread_info.h	2005-02-03 02:57:05.000000000 +0100
@@ -76,6 +76,7 @@ static inline struct thread_info *curren
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_POLLING_NRFLAG	4	/* true if poll_idle() is polling
 					   TIF_NEED_RESCHED */
+#define TIF_MEMDIE		5
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc/uninorth.h linux-2.6.11-rc3/include/asm-ppc/uninorth.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc/uninorth.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc/uninorth.h	2005-02-03 02:56:35.000000000 +0100
@@ -148,6 +148,55 @@
 #define UNI_N_AACK_DELAY		0x0100
 #define UNI_N_AACK_DELAY_ENABLE		0x00000001
 
+/* Clock status for Intrepid */
+#define UNI_N_CLOCK_STOP_STATUS0	0x0150
+#define UNI_N_CLOCK_STOPPED_EXTAGP	0x00200000
+#define UNI_N_CLOCK_STOPPED_AGPDEL	0x00100000
+#define UNI_N_CLOCK_STOPPED_I2S0_45_49	0x00080000
+#define UNI_N_CLOCK_STOPPED_I2S0_18	0x00040000
+#define UNI_N_CLOCK_STOPPED_I2S1_45_49	0x00020000
+#define UNI_N_CLOCK_STOPPED_I2S1_18	0x00010000
+#define UNI_N_CLOCK_STOPPED_TIMER	0x00008000
+#define UNI_N_CLOCK_STOPPED_SCC_RTCLK18	0x00004000
+#define UNI_N_CLOCK_STOPPED_SCC_RTCLK32	0x00002000
+#define UNI_N_CLOCK_STOPPED_SCC_VIA32	0x00001000
+#define UNI_N_CLOCK_STOPPED_SCC_SLOT0	0x00000800
+#define UNI_N_CLOCK_STOPPED_SCC_SLOT1	0x00000400
+#define UNI_N_CLOCK_STOPPED_SCC_SLOT2	0x00000200
+#define UNI_N_CLOCK_STOPPED_PCI_FBCLKO	0x00000100
+#define UNI_N_CLOCK_STOPPED_VEO0	0x00000080
+#define UNI_N_CLOCK_STOPPED_VEO1	0x00000040
+#define UNI_N_CLOCK_STOPPED_USB0	0x00000020
+#define UNI_N_CLOCK_STOPPED_USB1	0x00000010
+#define UNI_N_CLOCK_STOPPED_USB2	0x00000008
+#define UNI_N_CLOCK_STOPPED_32		0x00000004
+#define UNI_N_CLOCK_STOPPED_45		0x00000002
+#define UNI_N_CLOCK_STOPPED_49		0x00000001
+
+#define UNI_N_CLOCK_STOP_STATUS1	0x0160
+#define UNI_N_CLOCK_STOPPED_PLL4REF	0x00080000
+#define UNI_N_CLOCK_STOPPED_CPUDEL	0x00040000
+#define UNI_N_CLOCK_STOPPED_CPU		0x00020000
+#define UNI_N_CLOCK_STOPPED_BUF_REFCKO	0x00010000
+#define UNI_N_CLOCK_STOPPED_PCI2	0x00008000
+#define UNI_N_CLOCK_STOPPED_FW		0x00004000
+#define UNI_N_CLOCK_STOPPED_GB		0x00002000
+#define UNI_N_CLOCK_STOPPED_ATA66	0x00001000
+#define UNI_N_CLOCK_STOPPED_ATA100	0x00000800
+#define UNI_N_CLOCK_STOPPED_MAX		0x00000400
+#define UNI_N_CLOCK_STOPPED_PCI1	0x00000200
+#define UNI_N_CLOCK_STOPPED_KLPCI	0x00000100
+#define UNI_N_CLOCK_STOPPED_USB0PCI	0x00000080
+#define UNI_N_CLOCK_STOPPED_USB1PCI	0x00000040
+#define UNI_N_CLOCK_STOPPED_USB2PCI	0x00000020
+#define UNI_N_CLOCK_STOPPED_7PCI1	0x00000008
+#define UNI_N_CLOCK_STOPPED_AGP		0x00000004
+#define UNI_N_CLOCK_STOPPED_PCI0	0x00000002
+#define UNI_N_CLOCK_STOPPED_18		0x00000001
+
+/* Intrepid registe to OF do-platform-clockspreading */
+#define UNI_N_CLOCK_SPREADING		0x190
+
 /* Uninorth 1.5 rev. has additional perf. monitor registers at 0xf00-0xf50 */
 
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc64/mmu.h linux-2.6.11-rc3/include/asm-ppc64/mmu.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc64/mmu.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc64/mmu.h	2005-02-03 02:56:21.000000000 +0100
@@ -122,10 +122,13 @@ static inline void __tlbie(unsigned long
 	/* clear top 16 bits, non SLS segment */
 	va &= ~(0xffffULL << 48);
 
-	if (large)
+	if (large) {
+		va &= HPAGE_MASK;
 		asm volatile("tlbie %0,1" : : "r"(va) : "memory");
-	else
+	} else {
+		va &= PAGE_MASK;
 		asm volatile("tlbie %0,0" : : "r"(va) : "memory");
+	}
 }
 
 static inline void tlbie(unsigned long va, int large)
@@ -139,6 +142,7 @@ static inline void __tlbiel(unsigned lon
 {
 	/* clear top 16 bits, non SLS segment */
 	va &= ~(0xffffULL << 48);
+	va &= PAGE_MASK;
 
 	/* 
 	 * Thanks to Alan Modra we are now able to use machine specific 
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc64/thread_info.h linux-2.6.11-rc3/include/asm-ppc64/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc64/thread_info.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc64/thread_info.h	2005-02-03 02:55:07.000000000 +0100
@@ -100,6 +100,7 @@ static inline struct thread_info *curren
 #define TIF_ABI_PENDING		7	/* 32/64 bit switch needed */
 #define TIF_SYSCALL_AUDIT	8	/* syscall auditing active */
 #define TIF_SINGLESTEP		9	/* singlestepping active */
+#define TIF_MEMDIE		10
 
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -purN linux-2.6.11-rc2-bk10/include/asm-ppc64/uaccess.h linux-2.6.11-rc3/include/asm-ppc64/uaccess.h
--- linux-2.6.11-rc2-bk10/include/asm-ppc64/uaccess.h	2005-01-22 02:48:16.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-ppc64/uaccess.h	2005-02-03 02:55:52.000000000 +0100
@@ -244,7 +244,7 @@ __copy_from_user(void *to, const void __
 			return ret;
 		}
 	}
-	return __copy_tofrom_user((void __user *) to, from, n);
+	return __copy_tofrom_user((__force void __user *) to, from, n);
 }
 
 static inline unsigned long
@@ -269,7 +269,7 @@ __copy_to_user(void __user *to, const vo
 			return ret;
 		}
 	}
-	return __copy_tofrom_user(to, (const void __user *) from, n);
+	return __copy_tofrom_user(to, (__force const void __user *) from, n);
 }
 
 #define __copy_in_user(to, from, size) \
diff -purN linux-2.6.11-rc2-bk10/include/asm-s390/page.h linux-2.6.11-rc3/include/asm-s390/page.h
--- linux-2.6.11-rc2-bk10/include/asm-s390/page.h	2005-01-22 02:47:29.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-s390/page.h	2005-02-03 02:55:15.000000000 +0100
@@ -106,6 +106,9 @@ static inline void copy_page(void *to, v
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
 /* Pure 2^n version of get_order */
 extern __inline__ int get_order(unsigned long size)
 {
diff -purN linux-2.6.11-rc2-bk10/include/asm-s390/thread_info.h linux-2.6.11-rc3/include/asm-s390/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-s390/thread_info.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-s390/thread_info.h	2005-02-03 02:56:21.000000000 +0100
@@ -100,6 +100,7 @@ static inline struct thread_info *curren
 #define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling 
 					   TIF_NEED_RESCHED */
 #define TIF_31BIT		18	/* 32bit process */ 
+#define TIF_MEMDIE		19
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-sh/spinlock.h linux-2.6.11-rc3/include/asm-sh/spinlock.h
--- linux-2.6.11-rc2-bk10/include/asm-sh/spinlock.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sh/spinlock.h	2005-02-03 02:55:23.000000000 +0100
@@ -51,9 +51,7 @@ static inline void _raw_spin_lock(spinlo
 
 static inline void _raw_spin_unlock(spinlock_t *lock)
 {
-#ifdef CONFIG_DEBUG_SPINLOCK
-	BUG_ON(!spin_is_locked(lock));
-#endif
+	assert_spin_locked(lock);
 
 	lock->lock = 0;
 }
diff -purN linux-2.6.11-rc2-bk10/include/asm-sh/thread_info.h linux-2.6.11-rc3/include/asm-sh/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-sh/thread_info.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sh/thread_info.h	2005-02-03 02:56:22.000000000 +0100
@@ -83,6 +83,7 @@ static inline struct thread_info *curren
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
 #define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		18
 #define TIF_USERSPACE		31	/* true if FS sets userspace */
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -purN linux-2.6.11-rc2-bk10/include/asm-sh64/thread_info.h linux-2.6.11-rc3/include/asm-sh64/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-sh64/thread_info.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sh64/thread_info.h	2005-02-03 02:55:36.000000000 +0100
@@ -74,6 +74,7 @@ static inline struct thread_info *curren
 #define TIF_SYSCALL_TRACE	0	/* syscall trace active */
 #define TIF_SIGPENDING		2	/* signal pending */
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_MEMDIE		4
 
 #define THREAD_SIZE	16384
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc/bitops.h linux-2.6.11-rc3/include/asm-sparc/bitops.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc/bitops.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc/bitops.h	2005-02-03 02:56:48.000000000 +0100
@@ -312,10 +312,10 @@ static inline int ffs(int x)
  * 'size' bits, starting the search at bit 'offset'. This is largely based
  * on Linus's ALPHA routines, which are pretty portable BTW.
  */
-static inline unsigned long find_next_zero_bit(unsigned long *addr,
+static inline unsigned long find_next_zero_bit(const unsigned long *addr,
     unsigned long size, unsigned long offset)
 {
-	unsigned long *p = addr + (offset >> 5);
+	const unsigned long *p = addr + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
@@ -446,10 +446,10 @@ static inline int __test_and_clear_le_bi
 	return retval;
 }
 
-static inline unsigned long find_next_zero_le_bit(unsigned long *addr,
+static inline unsigned long find_next_zero_le_bit(const unsigned long *addr,
     unsigned long size, unsigned long offset)
 {
-	unsigned long *p = addr + (offset >> 5);
+	const unsigned long *p = addr + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc/pgtable.h linux-2.6.11-rc3/include/asm-sparc/pgtable.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc/pgtable.h	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc/pgtable.h	2005-02-03 02:55:53.000000000 +0100
@@ -186,10 +186,31 @@ BTFIXUPDEF_CALL(void, pgd_clear, pgd_t *
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
  */
+BTFIXUPDEF_HALF(pte_readi)
 BTFIXUPDEF_HALF(pte_writei)
 BTFIXUPDEF_HALF(pte_dirtyi)
 BTFIXUPDEF_HALF(pte_youngi)
 
+extern int pte_read(pte_t pte) __attribute_const__;
+extern __inline__ int pte_read(pte_t pte)
+{
+	switch (sparc_cpu_model){
+	case sun4:
+	case sun4c:
+		return pte_val(pte) & BTFIXUP_HALF(pte_readi);
+	case sun4d:
+	case sun4e:
+	case sun4m:
+		return !(pte_val(pte) & BTFIXUP_HALF(pte_readi));
+	/* pacify gcc warnings */
+	case sun4u:
+	case sun_unknown:
+	case ap1000:
+	default:
+		return 0;
+	}
+}
+
 extern int pte_write(pte_t pte) __attribute_const__;
 extern __inline__ int pte_write(pte_t pte)
 {
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc/pgtsrmmu.h linux-2.6.11-rc3/include/asm-sparc/pgtsrmmu.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc/pgtsrmmu.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc/pgtsrmmu.h	2005-02-03 02:55:35.000000000 +0100
@@ -73,6 +73,7 @@
 #define SRMMU_CACHE        0x80
 #define SRMMU_DIRTY        0x40
 #define SRMMU_REF          0x20
+#define SRMMU_NOREAD       0x10
 #define SRMMU_EXEC         0x08
 #define SRMMU_WRITE        0x04
 #define SRMMU_VALID        0x02 /* SRMMU_ET_PTE */
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc/thread_info.h linux-2.6.11-rc3/include/asm-sparc/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc/thread_info.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc/thread_info.h	2005-02-03 02:56:53.000000000 +0100
@@ -138,6 +138,7 @@ BTFIXUPDEF_CALL(void, free_thread_info, 
 					 * this quantum (SMP) */
 #define TIF_POLLING_NRFLAG	9	/* true if poll_idle() is polling
 					 * TIF_NEED_RESCHED */
+#define TIF_MEMDIE		10
 
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc/uaccess.h linux-2.6.11-rc3/include/asm-sparc/uaccess.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc/uaccess.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc/uaccess.h	2005-02-03 02:56:48.000000000 +0100
@@ -111,7 +111,7 @@ __get_user_check((x),__gu_addr,sizeof(*(
 #define __get_user(x,ptr) __get_user_nocheck((x),(ptr),sizeof(*(ptr)),__typeof__(*(ptr)))
 
 struct __large_struct { unsigned long buf[100]; };
-#define __m(x) ((struct __large_struct *)(x))
+#define __m(x) ((struct __large_struct __user *)(x))
 
 #define __put_user_check(x,addr,size) ({ \
 register int __pu_ret; \
@@ -299,27 +299,27 @@ extern unsigned long __copy_user(void __
 static inline unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)
 {
 	if (n && __access_ok((unsigned long) to, n))
-		return __copy_user(to, (void __user *) from, n);
+		return __copy_user(to, (__force void __user *) from, n);
 	else
 		return n;
 }
 
 static inline unsigned long __copy_to_user(void __user *to, const void *from, unsigned long n)
 {
-	return __copy_user(to, (void __user *) from, n);
+	return __copy_user(to, (__force void __user *) from, n);
 }
 
 static inline unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
 {
 	if (n && __access_ok((unsigned long) from, n))
-		return __copy_user((void __user *) to, from, n);
+		return __copy_user((__force void __user *) to, from, n);
 	else
 		return n;
 }
 
 static inline unsigned long __copy_from_user(void *to, const void __user *from, unsigned long n)
 {
-	return __copy_user((void __user *) to, from, n);
+	return __copy_user((__force void __user *) to, from, n);
 }
 
 #define __copy_to_user_inatomic __copy_to_user
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc64/compat.h linux-2.6.11-rc3/include/asm-sparc64/compat.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc64/compat.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc64/compat.h	2005-02-03 02:56:10.000000000 +0100
@@ -121,6 +121,11 @@ static inline void __user *compat_ptr(co
 	return (void __user *)(unsigned long)uptr;
 }
 
+static inline compat_uptr_t ptr_to_compat(void __user *uptr)
+{
+	return (u32)(unsigned long)uptr;
+}
+
 static __inline__ void __user *compat_alloc_user_space(long len)
 {
 	struct pt_regs *regs = current_thread_info()->kregs;
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc64/page.h linux-2.6.11-rc3/include/asm-sparc64/page.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc64/page.h	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc64/page.h	2005-02-03 02:55:50.000000000 +0100
@@ -21,11 +21,14 @@ extern void clear_user_page(void *addr, 
 #define copy_page(X,Y)	memcpy((void *)(X), (void *)(Y), PAGE_SIZE)
 extern void copy_user_page(void *to, void *from, unsigned long vaddr, struct page *topage);
 
-/* GROSS, defining this makes gcc pass these types as aggregates,
- * and thus on the stack, turn this crap off... -DaveM
+/* Unlike sparc32, sparc64's parameter passing API is more
+ * sane in that structures which as small enough are passed
+ * in registers instead of on the stack.  Thus, setting
+ * STRICT_MM_TYPECHECKS does not generate worse code so
+ * let's enable it to get the type checking.
  */
 
-/* #define STRICT_MM_TYPECHECKS */
+#define STRICT_MM_TYPECHECKS
 
 #ifdef STRICT_MM_TYPECHECKS
 /* These are used to make use of C type-checking.. */
@@ -33,25 +36,19 @@ typedef struct { unsigned long pte; } pt
 typedef struct { unsigned long iopte; } iopte_t;
 typedef struct { unsigned int pmd; } pmd_t;
 typedef struct { unsigned int pgd; } pgd_t;
-typedef struct { unsigned long ctxd; } ctxd_t;
 typedef struct { unsigned long pgprot; } pgprot_t;
-typedef struct { unsigned long iopgprot; } iopgprot_t;
 
 #define pte_val(x)	((x).pte)
 #define iopte_val(x)	((x).iopte)
 #define pmd_val(x)      ((x).pmd)
 #define pgd_val(x)	((x).pgd)
-#define ctxd_val(x)	((x).ctxd)
 #define pgprot_val(x)	((x).pgprot)
-#define iopgprot_val(x)	((x).iopgprot)
 
 #define __pte(x)	((pte_t) { (x) } )
 #define __iopte(x)	((iopte_t) { (x) } )
 #define __pmd(x)        ((pmd_t) { (x) } )
 #define __pgd(x)	((pgd_t) { (x) } )
-#define __ctxd(x)	((ctxd_t) { (x) } )
 #define __pgprot(x)	((pgprot_t) { (x) } )
-#define __iopgprot(x)	((iopgprot_t) { (x) } )
 
 #else
 /* .. while these make it easier on the compiler */
@@ -59,25 +56,19 @@ typedef unsigned long pte_t;
 typedef unsigned long iopte_t;
 typedef unsigned int pmd_t;
 typedef unsigned int pgd_t;
-typedef unsigned long ctxd_t;
 typedef unsigned long pgprot_t;
-typedef unsigned long iopgprot_t;
 
 #define pte_val(x)	(x)
 #define iopte_val(x)	(x)
 #define pmd_val(x)      (x)
 #define pgd_val(x)	(x)
-#define ctxd_val(x)	(x)
 #define pgprot_val(x)	(x)
-#define iopgprot_val(x)	(x)
 
 #define __pte(x)	(x)
 #define __iopte(x)	(x)
 #define __pmd(x)        (x)
 #define __pgd(x)	(x)
-#define __ctxd(x)	(x)
 #define __pgprot(x)	(x)
-#define __iopgprot(x)	(x)
 
 #endif /* (STRICT_MM_TYPECHECKS) */
 
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc64/pgalloc.h linux-2.6.11-rc3/include/asm-sparc64/pgalloc.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc64/pgalloc.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc64/pgalloc.h	2005-02-03 02:56:53.000000000 +0100
@@ -133,7 +133,7 @@ static __inline__ void free_pgd_slow(pgd
 #define DCACHE_COLOR(address)		0
 #endif
 
-#define pgd_populate(MM, PGD, PMD)	pgd_set(PGD, PMD)
+#define pud_populate(MM, PUD, PMD)	pud_set(PUD, PMD)
 
 static __inline__ pmd_t *pmd_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc64/pgtable.h linux-2.6.11-rc3/include/asm-sparc64/pgtable.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc64/pgtable.h	2005-01-22 02:46:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc64/pgtable.h	2005-02-03 02:54:52.000000000 +0100
@@ -12,7 +12,7 @@
  * the SpitFire page tables.
  */
 
-#include <asm-generic/4level-fixup.h>
+#include <asm-generic/pgtable-nopud.h>
 
 #include <linux/config.h>
 #include <asm/spitfire.h>
@@ -263,23 +263,23 @@ static inline pte_t pte_modify(pte_t ori
 }
 #define pmd_set(pmdp, ptep)	\
 	(pmd_val(*(pmdp)) = (__pa((unsigned long) (ptep)) >> 11UL))
-#define pgd_set(pgdp, pmdp)	\
-	(pgd_val(*(pgdp)) = (__pa((unsigned long) (pmdp)) >> 11UL))
+#define pud_set(pudp, pmdp)	\
+	(pud_val(*(pudp)) = (__pa((unsigned long) (pmdp)) >> 11UL))
 #define __pmd_page(pmd)		\
 	((unsigned long) __va((((unsigned long)pmd_val(pmd))<<11UL)))
 #define pmd_page(pmd) 			virt_to_page((void *)__pmd_page(pmd))
-#define pgd_page(pgd)		\
-	((unsigned long) __va((((unsigned long)pgd_val(pgd))<<11UL)))
+#define pud_page(pud)		\
+	((unsigned long) __va((((unsigned long)pud_val(pud))<<11UL)))
 #define pte_none(pte) 			(!pte_val(pte))
 #define pte_present(pte)		(pte_val(pte) & _PAGE_PRESENT)
 #define pmd_none(pmd)			(!pmd_val(pmd))
 #define pmd_bad(pmd)			(0)
 #define pmd_present(pmd)		(pmd_val(pmd) != 0U)
 #define pmd_clear(pmdp)			(pmd_val(*(pmdp)) = 0U)
-#define pgd_none(pgd)			(!pgd_val(pgd))
-#define pgd_bad(pgd)			(0)
-#define pgd_present(pgd)		(pgd_val(pgd) != 0U)
-#define pgd_clear(pgdp)			(pgd_val(*(pgdp)) = 0U)
+#define pud_none(pud)			(!pud_val(pud))
+#define pud_bad(pud)			(0)
+#define pud_present(pud)		(pud_val(pud) != 0U)
+#define pud_clear(pudp)			(pud_val(*(pudp)) = 0U)
 
 /* The following only work if pte_present() is true.
  * Undefined behaviour if not..
@@ -313,8 +313,8 @@ static inline pte_t pte_modify(pte_t ori
 #define pgd_offset_k(address) pgd_offset(&init_mm, address)
 
 /* Find an entry in the second-level page table.. */
-#define pmd_offset(dir, address)	\
-	((pmd_t *) pgd_page(*(dir)) + \
+#define pmd_offset(pudp, address)	\
+	((pmd_t *) pud_page(*(pudp)) + \
 	 (((address) >> PMD_SHIFT) & (REAL_PTRS_PER_PMD-1)))
 
 /* Find an entry in the third-level page table.. */
@@ -384,6 +384,7 @@ static __inline__ unsigned long
 sun4u_get_pte (unsigned long addr)
 {
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 
@@ -392,7 +393,8 @@ sun4u_get_pte (unsigned long addr)
 	if ((addr >= LOW_OBP_ADDRESS) && (addr < HI_OBP_ADDRESS))
 		return prom_virt_to_phys(addr, NULL);
 	pgdp = pgd_offset_k(addr);
-	pmdp = pmd_offset(pgdp, addr);
+	pudp = pud_offset(pgdp, addr);
+	pmdp = pmd_offset(pudp, addr);
 	ptep = pte_offset_kernel(pmdp, addr);
 	return pte_val(*ptep) & _PAGE_PADDR;
 }
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc64/thread_info.h linux-2.6.11-rc3/include/asm-sparc64/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc64/thread_info.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc64/thread_info.h	2005-02-03 02:56:22.000000000 +0100
@@ -228,6 +228,7 @@ register struct thread_info *current_thr
  *       an immediate value in instructions such as andcc.
  */
 #define TIF_ABI_PENDING		12
+#define TIF_MEMDIE		13
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-sparc64/tlb.h linux-2.6.11-rc3/include/asm-sparc64/tlb.h
--- linux-2.6.11-rc2-bk10/include/asm-sparc64/tlb.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-sparc64/tlb.h	2005-02-03 02:56:33.000000000 +0100
@@ -121,6 +121,7 @@ static inline void tlb_remove_page(struc
 #define tlb_remove_tlb_entry(mp,ptep,addr) do { } while (0)
 #define pte_free_tlb(mp,ptepage) pte_free(ptepage)
 #define pmd_free_tlb(mp,pmdp) pmd_free(pmdp)
+#define pud_free_tlb(tlb,pudp) __pud_free_tlb(tlb,pudp)
 
 #define tlb_migrate_finish(mm)	do { } while (0)
 #define tlb_start_vma(tlb, vma) do { } while (0)
diff -purN linux-2.6.11-rc2-bk10/include/asm-um/thread_info.h linux-2.6.11-rc3/include/asm-um/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-um/thread_info.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-um/thread_info.h	2005-02-03 02:55:35.000000000 +0100
@@ -71,6 +71,7 @@ static inline struct thread_info *curren
 					 * TIF_NEED_RESCHED 
 					 */
 #define TIF_RESTART_BLOCK 	4
+#define TIF_MEMDIE	 	5
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
diff -purN linux-2.6.11-rc2-bk10/include/asm-v850/thread_info.h linux-2.6.11-rc3/include/asm-v850/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-v850/thread_info.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-v850/thread_info.h	2005-02-03 02:55:36.000000000 +0100
@@ -83,6 +83,7 @@ struct thread_info {
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_POLLING_NRFLAG	4	/* true if poll_idle() is polling
 					   TIF_NEED_RESCHED */
+#define TIF_MEMDIE		5
 
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/compat.h linux-2.6.11-rc3/include/asm-x86_64/compat.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/compat.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/compat.h	2005-02-03 02:56:22.000000000 +0100
@@ -191,6 +191,11 @@ static inline void __user *compat_ptr(co
 	return (void __user *)(unsigned long)uptr;
 }
 
+static inline compat_uptr_t ptr_to_compat(void __user *uptr)
+{
+	return (u32)(unsigned long)uptr;
+}
+
 static __inline__ void __user *compat_alloc_user_space(long len)
 {
 	struct pt_regs *regs = (void *)current->thread.rsp0 - sizeof(struct pt_regs); 
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/i387.h linux-2.6.11-rc3/include/asm-x86_64/i387.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/i387.h	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/i387.h	2005-02-03 02:55:52.000000000 +0100
@@ -25,16 +25,6 @@ extern void mxcsr_feature_mask_init(void
 extern void init_fpu(struct task_struct *child);
 extern int save_i387(struct _fpstate __user *buf);
 
-static inline int need_signal_i387(struct task_struct *me) 
-{ 
-	if (!me->used_math)
-		return 0;
-	me->used_math = 0; 
-	if (me->thread_info->status & TS_USEDFPU)
-		return 0;
-	return 1;
-} 
-
 /*
  * FPU lazy state save handling...
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/page.h linux-2.6.11-rc3/include/asm-x86_64/page.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/page.h	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/page.h	2005-02-03 02:55:00.000000000 +0100
@@ -38,6 +38,8 @@ void copy_page(void *, void *);
 #define clear_user_page(page, vaddr, pg)	clear_page(page)
 #define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
 
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
 /*
  * These are used to make use of C type-checking..
  */
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/pgtable.h linux-2.6.11-rc3/include/asm-x86_64/pgtable.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/pgtable.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/pgtable.h	2005-02-03 02:56:22.000000000 +0100
@@ -119,8 +119,8 @@ extern inline void pgd_clear (pgd_t * pg
 #define MAXMEM		 0x3fffffffffffUL
 #define VMALLOC_START    0xffffc20000000000UL
 #define VMALLOC_END      0xffffe1ffffffffffUL
-#define MODULES_VADDR    0xffffffff88000000
-#define MODULES_END      0xfffffffffff00000
+#define MODULES_VADDR    0xffffffff88000000UL
+#define MODULES_END      0xfffffffffff00000UL
 #define MODULES_LEN   (MODULES_END - MODULES_VADDR)
 
 #define _PAGE_BIT_PRESENT	0
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/processor.h linux-2.6.11-rc3/include/asm-x86_64/processor.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/processor.h	2005-01-22 02:49:12.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/processor.h	2005-02-03 02:56:53.000000000 +0100
@@ -162,7 +162,7 @@ static inline void clear_in_cr4 (unsigne
 /*
  * User space process size. 47bits.
  */
-#define TASK_SIZE	(0x800000000000)
+#define TASK_SIZE	(0x800000000000UL)
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/spinlock.h linux-2.6.11-rc3/include/asm-x86_64/spinlock.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/spinlock.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/spinlock.h	2005-02-03 02:56:53.000000000 +0100
@@ -75,7 +75,7 @@ static inline void _raw_spin_unlock(spin
 {
 #ifdef CONFIG_DEBUG_SPINLOCK
 	BUG_ON(lock->magic != SPINLOCK_MAGIC);
-	BUG_ON(!spin_is_locked(lock));
+	assert_spin_locked(lock);
 #endif
 	__asm__ __volatile__(
 		spin_unlock_string
@@ -94,7 +94,7 @@ static inline void _raw_spin_unlock(spin
 	char oldval = 1;
 #ifdef CONFIG_DEBUG_SPINLOCK
 	BUG_ON(lock->magic != SPINLOCK_MAGIC);
-	BUG_ON(!spin_is_locked(lock));
+	assert_spin_locked(lock);
 #endif
 	__asm__ __volatile__(
 		spin_unlock_string
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/thread_info.h linux-2.6.11-rc3/include/asm-x86_64/thread_info.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/thread_info.h	2005-01-22 02:48:29.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/thread_info.h	2005-02-03 02:56:22.000000000 +0100
@@ -106,6 +106,7 @@ static inline struct thread_info *stack_
 #define TIF_IA32		17	/* 32bit process */ 
 #define TIF_FORK		18	/* ret_from_fork */
 #define TIF_ABI_PENDING		19
+#define TIF_MEMDIE		20
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc2-bk10/include/asm-x86_64/uaccess.h linux-2.6.11-rc3/include/asm-x86_64/uaccess.h
--- linux-2.6.11-rc2-bk10/include/asm-x86_64/uaccess.h	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc3/include/asm-x86_64/uaccess.h	2005-02-03 02:57:16.000000000 +0100
@@ -198,7 +198,7 @@ struct __large_struct { unsigned long bu
 #define __get_user_nocheck(x,ptr,size)				\
 ({								\
 	int __gu_err;						\
-	long __gu_val;						\
+	unsigned long __gu_val;					\
 	__get_user_size(__gu_val,(ptr),(size),__gu_err);	\
 	(x) = (__typeof__(*(ptr)))__gu_val;			\
 	__gu_err;						\
diff -purN linux-2.6.11-rc2-bk10/include/linux/ac97_codec.h linux-2.6.11-rc3/include/linux/ac97_codec.h
--- linux-2.6.11-rc2-bk10/include/linux/ac97_codec.h	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/ac97_codec.h	2005-02-03 02:55:03.000000000 +0100
@@ -176,6 +176,39 @@
 #define AC97_EXTSTAT_PRK          0x2000
 #define AC97_EXTSTAT_PRL          0x4000
 
+/* extended audio ID register bit defines */
+#define AC97_EXTID_VRA            0x0001
+#define AC97_EXTID_DRA            0x0002
+#define AC97_EXTID_SPDIF          0x0004
+#define AC97_EXTID_VRM            0x0008
+#define AC97_EXTID_DSA0           0x0010
+#define AC97_EXTID_DSA1           0x0020
+#define AC97_EXTID_CDAC           0x0040
+#define AC97_EXTID_SDAC           0x0080
+#define AC97_EXTID_LDAC           0x0100
+#define AC97_EXTID_AMAP           0x0200
+#define AC97_EXTID_REV0           0x0400
+#define AC97_EXTID_REV1           0x0800
+#define AC97_EXTID_ID0            0x4000
+#define AC97_EXTID_ID1            0x8000
+
+/* extended status register bit defines */
+#define AC97_EXTSTAT_VRA          0x0001
+#define AC97_EXTSTAT_DRA          0x0002
+#define AC97_EXTSTAT_SPDIF        0x0004
+#define AC97_EXTSTAT_VRM          0x0008
+#define AC97_EXTSTAT_SPSA0        0x0010
+#define AC97_EXTSTAT_SPSA1        0x0020
+#define AC97_EXTSTAT_CDAC         0x0040
+#define AC97_EXTSTAT_SDAC         0x0080
+#define AC97_EXTSTAT_LDAC         0x0100
+#define AC97_EXTSTAT_MADC         0x0200
+#define AC97_EXTSTAT_SPCV         0x0400
+#define AC97_EXTSTAT_PRI          0x0800
+#define AC97_EXTSTAT_PRJ          0x1000
+#define AC97_EXTSTAT_PRK          0x2000
+#define AC97_EXTSTAT_PRL          0x4000
+
 /* useful power states */
 #define AC97_PWR_D0               0x0000      /* everything on */
 #define AC97_PWR_D1              AC97_PWR_PR0|AC97_PWR_PR1|AC97_PWR_PR4
diff -purN linux-2.6.11-rc2-bk10/include/linux/attribute_container.h linux-2.6.11-rc3/include/linux/attribute_container.h
--- linux-2.6.11-rc2-bk10/include/linux/attribute_container.h	2005-02-03 10:03:10.057469989 +0100
+++ linux-2.6.11-rc3/include/linux/attribute_container.h	2005-02-03 02:55:15.000000000 +0100
@@ -55,6 +55,18 @@ void attribute_container_device_trigger(
 void attribute_container_trigger(struct device *dev, 
 				 int (*fn)(struct attribute_container *,
 					   struct device *));
+int attribute_container_add_attrs(struct class_device *classdev);
+int attribute_container_add_class_device(struct class_device *classdev);
+int attribute_container_add_class_device_adapter(struct attribute_container *cont,
+						 struct device *dev,
+						 struct class_device *classdev);
+void attribute_container_remove_attrs(struct class_device *classdev);
+void attribute_container_class_device_del(struct class_device *classdev);
+
+
+
+
+
 
 struct class_device_attribute **attribute_container_classdev_to_attrs(const struct class_device *classdev);
 
diff -purN linux-2.6.11-rc2-bk10/include/linux/audit.h linux-2.6.11-rc3/include/linux/audit.h
--- linux-2.6.11-rc2-bk10/include/linux/audit.h	2005-01-22 02:48:17.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/audit.h	2005-02-03 02:55:52.000000000 +0100
@@ -114,12 +114,6 @@ struct audit_status {
 	__u32		backlog;	/* messages waiting in queue */
 };
 
-struct audit_login {
-	__u32		loginuid;
-	int		msglen;
-	char		msg[1024];
-};
-
 struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
 	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
 	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
@@ -155,6 +149,7 @@ extern int  audit_receive_filter(int typ
 extern void audit_get_stamp(struct audit_context *ctx,
 			    struct timespec *t, int *serial);
 extern int  audit_set_loginuid(struct audit_context *ctx, uid_t loginuid);
+extern uid_t audit_get_loginuid(struct audit_context *ctx);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -163,6 +158,7 @@ extern int  audit_set_loginuid(struct au
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
 #define audit_inode(n,i,d) do { ; } while (0)
+#define audit_get_loginuid(c) ({ -1; })
 #endif
 
 #ifdef CONFIG_AUDIT
diff -purN linux-2.6.11-rc2-bk10/include/linux/firmware.h linux-2.6.11-rc3/include/linux/firmware.h
--- linux-2.6.11-rc2-bk10/include/linux/firmware.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/firmware.h	2005-02-03 02:55:36.000000000 +0100
@@ -7,6 +7,7 @@ struct firmware {
 	size_t size;
 	u8 *data;
 };
+struct device;
 int request_firmware(const struct firmware **fw, const char *name,
 		     struct device *device);
 int request_firmware_nowait(
diff -purN linux-2.6.11-rc2-bk10/include/linux/fs.h linux-2.6.11-rc3/include/linux/fs.h
--- linux-2.6.11-rc2-bk10/include/linux/fs.h	2005-02-03 10:03:10.069468122 +0100
+++ linux-2.6.11-rc3/include/linux/fs.h	2005-02-03 02:55:23.000000000 +0100
@@ -1151,6 +1151,10 @@ struct export_operations {
 
 };
 
+extern struct dentry *
+find_exported_dentry(struct super_block *sb, void *obj, void *parent,
+		     int (*acceptable)(void *context, struct dentry *de),
+		     void *context);
 
 struct file_system_type {
 	const char *name;
diff -purN linux-2.6.11-rc2-bk10/include/linux/highmem.h linux-2.6.11-rc3/include/linux/highmem.h
--- linux-2.6.11-rc2-bk10/include/linux/highmem.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/highmem.h	2005-02-03 02:56:33.000000000 +0100
@@ -42,6 +42,17 @@ static inline void clear_user_highpage(s
 	smp_wmb();
 }
 
+#ifndef __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+static inline struct page *
+alloc_zeroed_user_highpage(struct vm_area_struct *vma, unsigned long vaddr)
+{
+	struct page *page = alloc_page_vma(GFP_HIGHUSER, vma, vaddr);
+
+	clear_user_highpage(page, vaddr);
+	return page;
+}
+#endif
+
 static inline void clear_highpage(struct page *page)
 {
 	void *kaddr = kmap_atomic(page, KM_USER0);
diff -purN linux-2.6.11-rc2-bk10/include/linux/i2c-id.h linux-2.6.11-rc3/include/linux/i2c-id.h
--- linux-2.6.11-rc2-bk10/include/linux/i2c-id.h	2005-02-03 10:03:10.070467967 +0100
+++ linux-2.6.11-rc3/include/linux/i2c-id.h	2005-02-03 02:57:05.000000000 +0100
@@ -200,6 +200,7 @@
 
 #define I2C_ALGO_SIBYTE 0x150000	/* Broadcom SiByte SOCs		*/
 #define I2C_ALGO_SGI	0x160000        /* SGI algorithm                */
+#define I2C_ALGO_AU1550	0x170000        /* Au1550 PSC algorithm		*/
 
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
@@ -274,6 +275,9 @@
 /* --- XSCALE on-chip adapters                          */
 #define I2C_HW_IOP3XX 0x00
 
+/* --- Au1550 PSC adapters adapters					*/
+#define I2C_HW_AU1550_PSC	0x00
+
 /* --- SMBus only adapters						*/
 #define I2C_HW_SMBUS_PIIX4	0x00
 #define I2C_HW_SMBUS_ALI15X3	0x01
diff -purN linux-2.6.11-rc2-bk10/include/linux/jbd.h linux-2.6.11-rc3/include/linux/jbd.h
--- linux-2.6.11-rc2-bk10/include/linux/jbd.h	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/jbd.h	2005-02-03 02:56:33.000000000 +0100
@@ -1062,12 +1062,6 @@ extern int jbd_blocks_per_page(struct in
 
 #ifdef __KERNEL__
 
-#ifdef CONFIG_SMP
-#define assert_spin_locked(lock)	J_ASSERT(spin_is_locked(lock))
-#else
-#define assert_spin_locked(lock)	do {} while(0)
-#endif
-
 #define buffer_trace_init(bh)	do {} while (0)
 #define print_buffer_fields(bh)	do {} while (0)
 #define print_buffer_trace(bh)	do {} while (0)
diff -purN linux-2.6.11-rc2-bk10/include/linux/jiffies.h linux-2.6.11-rc3/include/linux/jiffies.h
--- linux-2.6.11-rc2-bk10/include/linux/jiffies.h	2005-01-22 02:46:48.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/jiffies.h	2005-02-03 02:54:56.000000000 +0100
@@ -287,6 +287,19 @@ static inline unsigned long msecs_to_jif
 #endif
 }
 
+static inline unsigned long usecs_to_jiffies(const unsigned int u)
+{
+	if (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))
+		return MAX_JIFFY_OFFSET;
+#if HZ <= 1000 && !(1000 % HZ)
+	return (u + (1000000 / HZ) - 1000) / (1000000 / HZ);
+#elif HZ > 1000 && !(HZ % 1000)
+	return u * (HZ / 1000000);
+#else
+	return (u * HZ + 999999) / 1000000;
+#endif
+}
+
 /*
  * The TICK_NSEC - 1 rounds up the value to the next resolution.  Note
  * that a remainder subtract here would not do the right thing as the
diff -purN linux-2.6.11-rc2-bk10/include/linux/kobject.h linux-2.6.11-rc3/include/linux/kobject.h
--- linux-2.6.11-rc2-bk10/include/linux/kobject.h	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/kobject.h	2005-02-03 02:54:59.000000000 +0100
@@ -23,6 +23,7 @@
 #include <linux/rwsem.h>
 #include <linux/kref.h>
 #include <linux/kobject_uevent.h>
+#include <linux/kernel.h>
 #include <asm/atomic.h>
 
 #define KOBJ_NAME_LEN	20
diff -purN linux-2.6.11-rc2-bk10/include/linux/mmzone.h linux-2.6.11-rc3/include/linux/mmzone.h
--- linux-2.6.11-rc2-bk10/include/linux/mmzone.h	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/mmzone.h	2005-02-03 02:55:53.000000000 +0100
@@ -112,18 +112,14 @@ struct zone {
 	unsigned long		free_pages;
 	unsigned long		pages_min, pages_low, pages_high;
 	/*
-	 * protection[] is a pre-calculated number of extra pages that must be
-	 * available in a zone in order for __alloc_pages() to allocate memory
-	 * from the zone. i.e., for a GFP_KERNEL alloc of "order" there must
-	 * be "(1<<order) + protection[ZONE_NORMAL]" free pages in the zone
-	 * for us to choose to allocate the page from that zone.
-	 *
-	 * It uses both min_free_kbytes and sysctl_lower_zone_protection.
-	 * The protection values are recalculated if either of these values
-	 * change.  The array elements are in zonelist order:
-	 *	[0] == GFP_DMA, [1] == GFP_KERNEL, [2] == GFP_HIGHMEM.
+	 * We don't know if the memory that we're going to allocate will be freeable
+	 * or/and it will be released eventually, so to avoid totally wasting several
+	 * GB of ram we must reserve some of the lower zone memory (otherwise we risk
+	 * to run OOM on the lower zones despite there's tons of freeable ram
+	 * on the higher zones). This array is recalculated at runtime if the
+	 * sysctl_lowmem_reserve_ratio sysctl changes.
 	 */
-	unsigned long		protection[MAX_NR_ZONES];
+	unsigned long		lowmem_reserve[MAX_NR_ZONES];
 
 	struct per_cpu_pageset	pageset[NR_CPUS];
 
@@ -368,7 +364,8 @@ struct ctl_table;
 struct file;
 int min_free_kbytes_sysctl_handler(struct ctl_table *, int, struct file *, 
 					void __user *, size_t *, loff_t *);
-int lower_zone_protection_sysctl_handler(struct ctl_table *, int, struct file *,
+extern int sysctl_lowmem_reserve_ratio[MAX_NR_ZONES-1];
+int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *, int, struct file *,
 					void __user *, size_t *, loff_t *);
 
 #include <linux/topology.h>
diff -purN linux-2.6.11-rc2-bk10/include/linux/mv643xx.h linux-2.6.11-rc3/include/linux/mv643xx.h
--- linux-2.6.11-rc2-bk10/include/linux/mv643xx.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/mv643xx.h	2005-02-03 02:56:33.000000000 +0100
@@ -1048,7 +1048,7 @@ extern void mv64340_irq_init(unsigned in
 #define MPSC_ROUTING_REG_BLOCK_SIZE	0x000c
 #define MPSC_SDMA_INTR_REG_BLOCK_SIZE	0x0084
 
-struct mpsc_shared_pd_dd {
+struct mpsc_shared_pdata {
 	u32	mrr_val;
 	u32	rcrr_val;
 	u32	tcrr_val;
@@ -1067,7 +1067,7 @@ struct mpsc_shared_pd_dd {
 #define MPSC_SDMA_REG_BLOCK_SIZE	0x0c18
 #define MPSC_BRG_REG_BLOCK_SIZE		0x0008
 
-struct mpsc_pd_dd {
+struct mpsc_pdata {
 	u8	mirror_regs;
 	u8	cache_mgmt;
 	u8	max_idle;
diff -purN linux-2.6.11-rc2-bk10/include/linux/pci_ids.h linux-2.6.11-rc3/include/linux/pci_ids.h
--- linux-2.6.11-rc2-bk10/include/linux/pci_ids.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/pci_ids.h	2005-02-03 02:57:16.000000000 +0100
@@ -582,6 +582,7 @@
 #define PCI_DEVICE_ID_NEC_CBUS_2	0x002d /* PCI-Cbus Bridge */
 #define PCI_DEVICE_ID_NEC_USB		0x0035 /* PCI-USB Host */
 #define PCI_DEVICE_ID_NEC_CBUS_3	0x003b
+#define PCI_DEVICE_ID_NEC_NAPCCARD	0x003e
 #define PCI_DEVICE_ID_NEC_PCX2		0x0046 /* PowerVR */
 #define PCI_DEVICE_ID_NEC_NILE4		0x005a
 #define PCI_DEVICE_ID_NEC_VRC5476       0x009b
@@ -1030,6 +1031,7 @@
 #define PCI_DEVICE_ID_AL_M1523		0x1523
 #define PCI_DEVICE_ID_AL_M1531		0x1531
 #define PCI_DEVICE_ID_AL_M1533		0x1533
+#define PCI_DEVICE_ID_AL_M1535 		0x1535
 #define PCI_DEVICE_ID_AL_M1541		0x1541
 #define PCI_DEVICE_ID_AL_M1543		0x1543
 #define PCI_DEVICE_ID_AL_M1563		0x1563
@@ -1469,6 +1471,7 @@
 #define PCI_DEVICE_ID_TOSHIBA_TX3927	0x000a
 #define PCI_DEVICE_ID_TOSHIBA_TC35815CF	0x0030
 #define PCI_DEVICE_ID_TOSHIBA_TX4927	0x0180
+#define PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC	0x0108
 
 #define PCI_VENDOR_ID_RICOH		0x1180
 #define PCI_DEVICE_ID_RICOH_RL5C465	0x0465
@@ -1924,6 +1927,9 @@
 #define PCI_DEVICE_ID_PANACOM_QUADMODEM	0x0400
 #define PCI_DEVICE_ID_PANACOM_DUALMODEM	0x0402
 
+#define PCI_VENDOR_ID_SIPACKETS		0x14d9
+#define PCI_DEVICE_ID_SP_HT		0x0010
+
 #define PCI_VENDOR_ID_AFAVLAB		0x14db
 #define PCI_DEVICE_ID_AFAVLAB_P028	0x2180
 #define PCI_DEVICE_ID_AFAVLAB_P030	0x2182
@@ -2007,6 +2013,9 @@
 #define PCI_DEVICE_ID_FARSITE_TE1       0x1610
 #define PCI_DEVICE_ID_FARSITE_TE1C      0x1612
 
+#define PCI_VENDOR_ID_SIBYTE		0x166d
+#define PCI_DEVICE_ID_BCM1250_HT	0x0002
+
 #define PCI_VENDOR_ID_LINKSYS		0x1737
 #define PCI_DEVICE_ID_LINKSYS_EG1032	0x1032
 #define PCI_DEVICE_ID_LINKSYS_EG1064	0x1064
@@ -2327,6 +2336,7 @@
 #define PCI_DEVICE_ID_INTEL_IXP4XX	0x8500
 #define PCI_DEVICE_ID_INTEL_IXP2400	0x9001
 #define PCI_DEVICE_ID_INTEL_IXP2800	0x9004
+#define PCI_DEVICE_ID_INTEL_S21152BB	0xb152
 
 #define PCI_VENDOR_ID_COMPUTONE		0x8e0e
 #define PCI_DEVICE_ID_COMPUTONE_IP2EX	0x0291
diff -purN linux-2.6.11-rc2-bk10/include/linux/sched.h linux-2.6.11-rc3/include/linux/sched.h
--- linux-2.6.11-rc2-bk10/include/linux/sched.h	2005-01-22 02:47:14.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/sched.h	2005-02-03 02:55:07.000000000 +0100
@@ -614,7 +614,7 @@ struct task_struct {
 	struct key *process_keyring;	/* keyring private to this process (CLONE_THREAD) */
 	struct key *thread_keyring;	/* keyring private to this thread */
 #endif
-	unsigned short used_math;
+	int oomkilladj; /* OOM kill score adjustment (bit shift). */
 	char comm[TASK_COMM_LEN];
 /* file system info */
 	int link_count, total_link_count;
@@ -683,7 +683,7 @@ struct task_struct {
 #endif
 #ifdef CONFIG_NUMA
   	struct mempolicy *mempolicy;
-  	short il_next;		/* could be shared with used_math */
+	short il_next;
 #endif
 };
 
@@ -724,9 +724,8 @@ do { if (atomic_dec_and_test(&(tsk)->usa
 #define PF_DUMPCORE	0x00000200	/* dumped core */
 #define PF_SIGNALED	0x00000400	/* killed by a signal */
 #define PF_MEMALLOC	0x00000800	/* Allocating memory */
-#define PF_MEMDIE	0x00001000	/* Killed for out-of-memory */
-#define PF_FLUSHER	0x00002000	/* responsible for disk writeback */
-
+#define PF_FLUSHER	0x00001000	/* responsible for disk writeback */
+#define PF_USED_MATH	0x00002000	/* if unset the fpu must be initialized before use */
 #define PF_FREEZE	0x00004000	/* this task is being frozen for suspend now */
 #define PF_NOFREEZE	0x00008000	/* this thread should not be frozen */
 #define PF_FROZEN	0x00010000	/* frozen for system suspend */
@@ -737,6 +736,31 @@ do { if (atomic_dec_and_test(&(tsk)->usa
 #define PF_SYNCWRITE	0x00200000	/* I am doing a sync write */
 #define PF_BORROWED_MM	0x00400000	/* I am a kthread doing use_mm */
 
+/*
+ * Only the _current_ task can read/write to tsk->flags, but other
+ * tasks can access tsk->flags in readonly mode for example
+ * with tsk_used_math (like during threaded core dumping).
+ * There is however an exception to this rule during ptrace
+ * or during fork: the ptracer task is allowed to write to the
+ * child->flags of its traced child (same goes for fork, the parent
+ * can write to the child->flags), because we're guaranteed the
+ * child is not running and in turn not changing child->flags
+ * at the same time the parent does it.
+ */
+#define clear_stopped_child_used_math(child) do { (child)->flags &= ~PF_USED_MATH; } while (0)
+#define set_stopped_child_used_math(child) do { (child)->flags |= PF_USED_MATH; } while (0)
+#define clear_used_math() clear_stopped_child_used_math(current)
+#define set_used_math() set_stopped_child_used_math(current)
+#define conditional_stopped_child_used_math(condition, child) \
+	do { (child)->flags &= ~PF_USED_MATH, (child)->flags |= (condition) ? PF_USED_MATH : 0; } while (0)
+#define conditional_used_math(condition) \
+	conditional_stopped_child_used_math(condition, current)
+#define copy_to_stopped_child_used_math(child) \
+	do { (child)->flags &= ~PF_USED_MATH, (child)->flags |= current->flags & PF_USED_MATH; } while (0)
+/* NOTE: this will return 0 or PF_USED_MATH, it will never return 1 */
+#define tsk_used_math(p) ((p)->flags & PF_USED_MATH)
+#define used_math() tsk_used_math(current)
+
 #ifdef CONFIG_SMP
 extern int set_cpus_allowed(task_t *p, cpumask_t new_mask);
 #else
diff -purN linux-2.6.11-rc2-bk10/include/linux/serial_core.h linux-2.6.11-rc3/include/linux/serial_core.h
--- linux-2.6.11-rc2-bk10/include/linux/serial_core.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/serial_core.h	2005-02-03 02:55:08.000000000 +0100
@@ -103,6 +103,9 @@
 /* Marvell MPSC */
 #define PORT_MPSC	63
 
+/* TXX9 type number */
+#define PORT_TXX9       64
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>
diff -purN linux-2.6.11-rc2-bk10/include/linux/serial_reg.h linux-2.6.11-rc3/include/linux/serial_reg.h
--- linux-2.6.11-rc2-bk10/include/linux/serial_reg.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/serial_reg.h	2005-02-03 02:56:22.000000000 +0100
@@ -307,5 +307,19 @@
 #define SERIAL_RSA_BAUD_BASE (921600)
 #define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
 
+/*
+ * Extra serial register definitions for the internal UARTs
+ * in TI OMAP processors.
+ */
+#define UART_OMAP_MDR1		0x08	/* Mode definition register */
+#define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
+#define UART_OMAP_SCR		0x10	/* Supplementary control register */
+#define UART_OMAP_SSR		0x11	/* Supplementary status register */
+#define UART_OMAP_EBLR		0x12	/* BOF length register */
+#define UART_OMAP_OSC_12M_SEL	0x13	/* OMAP1510 12MHz osc select */
+#define UART_OMAP_MVER		0x14	/* Module version register */
+#define UART_OMAP_SYSC		0x15	/* System configuration register */
+#define UART_OMAP_SYSS		0x16	/* System status register */
+
 #endif /* _LINUX_SERIAL_REG_H */
 
diff -purN linux-2.6.11-rc2-bk10/include/linux/spinlock.h linux-2.6.11-rc3/include/linux/spinlock.h
--- linux-2.6.11-rc2-bk10/include/linux/spinlock.h	2005-01-22 02:48:02.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/spinlock.h	2005-02-03 02:55:52.000000000 +0100
@@ -38,6 +38,8 @@
  * If CONFIG_SMP is set, pull in the _raw_* definitions
  */
 #ifdef CONFIG_SMP
+
+#define assert_spin_locked(x)	BUG_ON(!spin_is_locked(x))
 #include <asm/spinlock.h>
 
 int __lockfunc _spin_trylock(spinlock_t *lock);
@@ -145,6 +147,14 @@ typedef struct {
 		0; \
 	})
 
+/* with debugging, assert_spin_locked() on UP does check
+ * the lock value properly */
+#define assert_spin_locked(x) \
+	({ \
+		CHECK_LOCK(x); \
+		BUG_ON(!(x)->lock); \
+	})
+
 /* without debugging, spin_trylock on UP always says
  * TRUE. --> printk if already locked. */
 #define _raw_spin_trylock(x) \
@@ -201,6 +211,7 @@ typedef struct {
 #define spin_lock_init(lock)	do { (void)(lock); } while(0)
 #define _raw_spin_lock(lock)	do { (void)(lock); } while(0)
 #define spin_is_locked(lock)	((void)(lock), 0)
+#define assert_spin_locked(lock)	do { (void)(lock); } while(0)
 #define _raw_spin_trylock(lock)	(((void)(lock), 1))
 #define spin_unlock_wait(lock)	(void)(lock)
 #define _raw_spin_unlock(lock) do { (void)(lock); } while(0)
diff -purN linux-2.6.11-rc2-bk10/include/linux/sysctl.h linux-2.6.11-rc3/include/linux/sysctl.h
--- linux-2.6.11-rc2-bk10/include/linux/sysctl.h	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/sysctl.h	2005-02-03 02:55:53.000000000 +0100
@@ -160,7 +160,7 @@ enum
 	VM_PAGEBUF=17,		/* struct: Control pagebuf parameters */
 	VM_HUGETLB_PAGES=18,	/* int: Number of available Huge Pages */
 	VM_SWAPPINESS=19,	/* Tendency to steal mapped memory */
-	VM_LOWER_ZONE_PROTECTION=20,/* Amount of protection of lower zones */
+	VM_LOWMEM_RESERVE_RATIO=20,/* reservation ratio for lower memory zones */
 	VM_MIN_FREE_KBYTES=21,	/* Minimum free kilobytes to maintain */
 	VM_MAX_MAP_COUNT=22,	/* int: Maximum number of mmaps/address-space */
 	VM_LAPTOP_MODE=23,	/* vm laptop mode */
diff -purN linux-2.6.11-rc2-bk10/include/linux/udf_fs_sb.h linux-2.6.11-rc3/include/linux/udf_fs_sb.h
--- linux-2.6.11-rc2-bk10/include/linux/udf_fs_sb.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc3/include/linux/udf_fs_sb.h	2005-02-03 02:56:48.000000000 +0100
@@ -18,6 +18,8 @@
 #ifndef _UDF_FS_SB_H
 #define _UDF_FS_SB_H 1
 
+#include <asm/semaphore.h>
+
 #pragma pack(1)
 
 #define UDF_MAX_BLOCK_LOADED	8
@@ -113,6 +115,8 @@ struct udf_sb_info
 
 	/* VAT inode */
 	struct inode		*s_vat;
+
+	struct semaphore	s_alloc_sem;
 };
 
 #endif /* _UDF_FS_SB_H */
diff -purN linux-2.6.11-rc2-bk10/include/video/maxinefb.h linux-2.6.11-rc3/include/video/maxinefb.h
--- linux-2.6.11-rc2-bk10/include/video/maxinefb.h	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/include/video/maxinefb.h	2005-02-03 02:55:15.000000000 +0100
@@ -8,17 +8,18 @@
  *      archive for more details.
  */
 
+#include <asm/addrspace.h>
 
 /*
  * IMS332 video controller register base address
  */
-#define MAXINEFB_IMS332_ADDRESS                  0xbc140000
+#define MAXINEFB_IMS332_ADDRESS		KSEG1ADDR(0x1c140000)
 
 /*
  * Begin of DECstation 5000/xx onboard framebuffer memory, default resolution
  * is 1024x768x8
  */
-#define DS5000_xx_ONBOARD_FBMEM_START	0xaa000000
+#define DS5000_xx_ONBOARD_FBMEM_START	KSEG1ADDR(0x0a000000)
 
 /*
  *      The IMS 332 video controller used in the DECstation 5000/xx series
diff -purN linux-2.6.11-rc2-bk10/init/initramfs.c linux-2.6.11-rc3/init/initramfs.c
--- linux-2.6.11-rc2-bk10/init/initramfs.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/init/initramfs.c	2005-02-03 02:55:07.000000000 +0100
@@ -26,7 +26,7 @@ static void __init free(void *where)
 
 /* link hash */
 
-static struct hash {
+static __initdata struct hash {
 	int ino, minor, major;
 	struct hash *next;
 	char *name;
diff -purN linux-2.6.11-rc2-bk10/init/main.c linux-2.6.11-rc3/init/main.c
--- linux-2.6.11-rc2-bk10/init/main.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/init/main.c	2005-02-03 02:55:15.000000000 +0100
@@ -373,14 +373,9 @@ static void noinline rest_init(void)
 {
 	kernel_thread(init, NULL, CLONE_FS | CLONE_SIGHAND);
 	numa_default_policy();
-	/*
-	 * Re-enable preemption but disable interrupts to make sure
-	 * we dont get preempted until we schedule() in cpu_idle().
-	 */
-	local_irq_disable();
-	preempt_enable_no_resched();
 	unlock_kernel();
- 	cpu_idle();
+	preempt_enable_no_resched();
+	cpu_idle();
 } 
 
 /* Check for early params. */
diff -purN linux-2.6.11-rc2-bk10/kernel/audit.c linux-2.6.11-rc3/kernel/audit.c
--- linux-2.6.11-rc2-bk10/kernel/audit.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/kernel/audit.c	2005-02-03 02:57:04.000000000 +0100
@@ -145,6 +145,11 @@ struct audit_buffer {
 	int		     count; /* Times requeued */
 };
 
+void audit_set_type(struct audit_buffer *ab, int type)
+{
+	ab->type = type;
+}
+
 struct audit_entry {
 	struct list_head  list;
 	struct audit_rule rule;
@@ -160,7 +165,7 @@ static void audit_panic(const char *mess
 		printk(KERN_ERR "audit: %s\n", message);
 		break;
 	case AUDIT_FAIL_PANIC:
-		panic(message);
+		panic("audit: %s\n", message);
 		break;
 	}
 }
@@ -312,7 +317,6 @@ static int audit_netlink_ok(kernel_cap_t
 	case AUDIT_GET:
 	case AUDIT_LIST:
 	case AUDIT_SET:
-	case AUDIT_LOGIN:
 	case AUDIT_ADD:
 	case AUDIT_DEL:
 		if (!cap_raised(eff_cap, CAP_AUDIT_CONTROL))
@@ -334,7 +338,6 @@ static int audit_receive_msg(struct sk_b
 	u32			uid, pid, seq;
 	void			*data;
 	struct audit_status	*status_get, status_set;
-	struct audit_login	*login;
 	int			err;
 	struct audit_buffer	*ab;
 	u16			msg_type = nlh->nlmsg_type;
@@ -397,27 +400,6 @@ static int audit_receive_msg(struct sk_b
 		ab->pid  = pid;
 		audit_log_end(ab);
 		break;
-	case AUDIT_LOGIN:
-		if (nlh->nlmsg_len < sizeof(struct audit_login))
-			return -EINVAL;
-		login = (struct audit_login *)data;
-		ab = audit_log_start(NULL);
-		if (ab) {
-			audit_log_format(ab, "login pid=%d uid=%d loginuid=%d"
-					 " length=%d msg='%.1024s'",
-					 pid, uid,
-					 login->loginuid,
-					 login->msglen,
-					 login->msg);
-			ab->type = AUDIT_LOGIN;
-			ab->pid  = pid;
-			audit_log_end(ab);
-		}
-#ifdef CONFIG_AUDITSYSCALL
-		err = audit_set_loginuid(current->audit_context,
-					 login->loginuid);
-#endif
-		break;
 	case AUDIT_ADD:
 	case AUDIT_DEL:
 		if (nlh->nlmsg_len < sizeof(struct audit_rule))
@@ -494,6 +476,10 @@ static void audit_log_move(struct audit_
 	char		*start;
 	int		extra = ab->nlh ? 0 : NLMSG_SPACE(0);
 
+	/* possible resubmission */
+	if (ab->len == 0)
+		return;
+
 	skb = skb_peek(&ab->sklist);
 	if (!skb || skb_tailroom(skb) <= ab->len + extra) {
 		skb = alloc_skb(2 * ab->len + extra, GFP_ATOMIC);
@@ -535,6 +521,7 @@ static inline int audit_log_drain(struct
 		}
 		if (retval == -EAGAIN && ab->count < 5) {
 			++ab->count;
+			skb_queue_tail(&ab->sklist, skb);
 			audit_log_end_irq(ab);
 			return 1;
 		}
@@ -658,10 +645,10 @@ struct audit_buffer *audit_log_start(str
 
 	if (!ab)
 		ab = kmalloc(sizeof(*ab), GFP_ATOMIC);
-	if (!ab)
-		audit_log_lost("audit: out of memory in audit_log_start");
-	if (!ab)
+	if (!ab) {
+		audit_log_lost("out of memory in audit_log_start");
 		return NULL;
+	}
 
 	atomic_inc(&audit_backlog);
 	skb_queue_head_init(&ab->sklist);
diff -purN linux-2.6.11-rc2-bk10/kernel/auditsc.c linux-2.6.11-rc3/kernel/auditsc.c
--- linux-2.6.11-rc2-bk10/kernel/auditsc.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/kernel/auditsc.c	2005-02-03 02:56:33.000000000 +0100
@@ -547,8 +547,8 @@ int audit_alloc(struct task_struct *tsk)
 
 				/* Preserve login uid */
 	context->loginuid = -1;
-	if (tsk->audit_context)
-		context->loginuid = tsk->audit_context->loginuid;
+	if (current->audit_context)
+		context->loginuid = current->audit_context->loginuid;
 
 	tsk->audit_context  = context;
 	set_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);
@@ -903,12 +903,27 @@ void audit_get_stamp(struct audit_contex
 	}
 }
 
+extern int audit_set_type(struct audit_buffer *ab, int type);
+
 int audit_set_loginuid(struct audit_context *ctx, uid_t loginuid)
 {
 	if (ctx) {
-		if (loginuid < 0)
-			return -EINVAL;
+		struct audit_buffer *ab;
+
+		ab = audit_log_start(NULL);
+		if (ab) {
+			audit_log_format(ab, "login pid=%d uid=%u "
+				"old loginuid=%u new loginuid=%u",
+				ctx->pid, ctx->uid, ctx->loginuid, loginuid);
+			audit_set_type(ab, AUDIT_LOGIN);
+			audit_log_end(ab);
+		}
 		ctx->loginuid = loginuid;
 	}
 	return 0;
 }
+
+uid_t audit_get_loginuid(struct audit_context *ctx)
+{
+	return ctx ? ctx->loginuid : -1;
+}
diff -purN linux-2.6.11-rc2-bk10/kernel/irq/manage.c linux-2.6.11-rc3/kernel/irq/manage.c
--- linux-2.6.11-rc2-bk10/kernel/irq/manage.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/kernel/irq/manage.c	2005-02-03 02:57:16.000000000 +0100
@@ -15,6 +15,8 @@
 
 #ifdef CONFIG_SMP
 
+cpumask_t irq_affinity[NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
+
 /**
  *	synchronize_irq - wait for pending IRQ handlers (on other CPUs)
  *
diff -purN linux-2.6.11-rc2-bk10/kernel/irq/proc.c linux-2.6.11-rc3/kernel/irq/proc.c
--- linux-2.6.11-rc2-bk10/kernel/irq/proc.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc3/kernel/irq/proc.c	2005-02-03 02:55:23.000000000 +0100
@@ -19,8 +19,6 @@ static struct proc_dir_entry *root_irq_d
  */
 static struct proc_dir_entry *smp_affinity_entry[NR_IRQS];
 
-cpumask_t irq_affinity[NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
-
 static int irq_affinity_read_proc(char *page, char **start, off_t off,
 				  int count, int *eof, void *data)
 {
diff -purN linux-2.6.11-rc2-bk10/kernel/ptrace.c linux-2.6.11-rc3/kernel/ptrace.c
--- linux-2.6.11-rc2-bk10/kernel/ptrace.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc3/kernel/ptrace.c	2005-02-03 02:57:04.000000000 +0100
@@ -320,32 +320,44 @@ static int ptrace_setoptions(struct task
 static int ptrace_getsiginfo(struct task_struct *child, siginfo_t __user * data)
 {
 	siginfo_t lastinfo;
+	int error = -ESRCH;
 
-	spin_lock_irq(&child->sighand->siglock);
-	if (likely(child->last_siginfo != NULL)) {
-		memcpy(&lastinfo, child->last_siginfo, sizeof (siginfo_t));
+	read_lock(&tasklist_lock);
+	if (likely(child->sighand != NULL)) {
+		error = -EINVAL;
+		spin_lock_irq(&child->sighand->siglock);
+		if (likely(child->last_siginfo != NULL)) {
+			lastinfo = *child->last_siginfo;
+			error = 0;
+		}
 		spin_unlock_irq(&child->sighand->siglock);
-		return copy_siginfo_to_user(data, &lastinfo);
 	}
-	spin_unlock_irq(&child->sighand->siglock);
-	return -EINVAL;
+	read_unlock(&tasklist_lock);
+	if (!error)
+		return copy_siginfo_to_user(data, &lastinfo);
+	return error;
 }
 
 static int ptrace_setsiginfo(struct task_struct *child, siginfo_t __user * data)
 {
 	siginfo_t newinfo;
+	int error = -ESRCH;
 
-	if (copy_from_user(&newinfo, data, sizeof (siginfo_t)) != 0)
+	if (copy_from_user(&newinfo, data, sizeof (siginfo_t)))
 		return -EFAULT;
 
-	spin_lock_irq(&child->sighand->siglock);
-	if (likely(child->last_siginfo != NULL)) {
-		memcpy(child->last_siginfo, &newinfo, sizeof (siginfo_t));
+	read_lock(&tasklist_lock);
+	if (likely(child->sighand != NULL)) {
+		error = -EINVAL;
+		spin_lock_irq(&child->sighand->siglock);
+		if (likely(child->last_siginfo != NULL)) {
+			*child->last_siginfo = newinfo;
+			error = 0;
+		}
 		spin_unlock_irq(&child->sighand->siglock);
-		return 0;
 	}
-	spin_unlock_irq(&child->sighand->siglock);
-	return -EINVAL;
+	read_unlock(&tasklist_lock);
+	return error;
 }
 
 int ptrace_request(struct task_struct *child, long request,
diff -purN linux-2.6.11-rc2-bk10/kernel/sched.c linux-2.6.11-rc3/kernel/sched.c
--- linux-2.6.11-rc2-bk10/kernel/sched.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc3/kernel/sched.c	2005-02-03 02:56:33.000000000 +0100
@@ -416,11 +416,11 @@ struct file_operations proc_schedstat_op
 	.release = single_release,
 };
 
-# define schedstat_inc(rq, field)	rq->field++;
-# define schedstat_add(rq, field, amt)	rq->field += amt;
+# define schedstat_inc(rq, field)	do { (rq)->field++; } while (0)
+# define schedstat_add(rq, field, amt)	do { (rq)->field += (amt); } while (0)
 #else /* !CONFIG_SCHEDSTATS */
-# define schedstat_inc(rq, field)	do { } while (0);
-# define schedstat_add(rq, field, amt)	do { } while (0);
+# define schedstat_inc(rq, field)	do { } while (0)
+# define schedstat_add(rq, field, amt)	do { } while (0)
 #endif
 
 /*
@@ -778,7 +778,7 @@ static void resched_task(task_t *p)
 {
 	int need_resched, nrpolling;
 
-	BUG_ON(!spin_is_locked(&task_rq(p)->lock));
+	assert_spin_locked(&task_rq(p)->lock);
 
 	/* minimise the chance of sending an interrupt to poll_idle() */
 	nrpolling = test_tsk_thread_flag(p,TIF_POLLING_NRFLAG);
@@ -2867,6 +2867,48 @@ need_resched:
 }
 
 EXPORT_SYMBOL(preempt_schedule);
+
+/*
+ * this is is the entry point to schedule() from kernel preemption
+ * off of irq context.
+ * Note, that this is called and return with irqs disabled. This will
+ * protect us against recursive calling from irq.
+ */
+asmlinkage void __sched preempt_schedule_irq(void)
+{
+	struct thread_info *ti = current_thread_info();
+#ifdef CONFIG_PREEMPT_BKL
+	struct task_struct *task = current;
+	int saved_lock_depth;
+#endif
+	/* Catch callers which need to be fixed*/
+	BUG_ON(ti->preempt_count || !irqs_disabled());
+
+need_resched:
+	add_preempt_count(PREEMPT_ACTIVE);
+	/*
+	 * We keep the big kernel semaphore locked, but we
+	 * clear ->lock_depth so that schedule() doesnt
+	 * auto-release the semaphore:
+	 */
+#ifdef CONFIG_PREEMPT_BKL
+	saved_lock_depth = task->lock_depth;
+	task->lock_depth = -1;
+#endif
+	local_irq_enable();
+	schedule();
+	local_irq_disable();
+#ifdef CONFIG_PREEMPT_BKL
+	task->lock_depth = saved_lock_depth;
+#endif
+	sub_preempt_count(PREEMPT_ACTIVE);
+
+	/* we could miss a preemption opportunity between schedule and now */
+	barrier();
+	if (unlikely(test_thread_flag(TIF_NEED_RESCHED)))
+		goto need_resched;
+}
+
 #endif /* CONFIG_PREEMPT */
 
 int default_wake_function(wait_queue_t *curr, unsigned mode, int sync, void *key)
@@ -3020,15 +3062,17 @@ wait_for_completion_timeout(struct compl
 			__set_current_state(TASK_UNINTERRUPTIBLE);
 			spin_unlock_irq(&x->wait.lock);
 			timeout = schedule_timeout(timeout);
-			if (!timeout)
-				goto out;
 			spin_lock_irq(&x->wait.lock);
+			if (!timeout) {
+				__remove_wait_queue(&x->wait, &wait);
+				goto out;
+			}
 		} while (!x->done);
 		__remove_wait_queue(&x->wait, &wait);
 	}
 	x->done--;
-	spin_unlock_irq(&x->wait.lock);
 out:
+	spin_unlock_irq(&x->wait.lock);
 	return timeout;
 }
 EXPORT_SYMBOL(wait_for_completion_timeout);
@@ -3048,6 +3092,7 @@ int fastcall __sched wait_for_completion
 		do {
 			if (signal_pending(current)) {
 				ret = -ERESTARTSYS;
+				__remove_wait_queue(&x->wait, &wait);
 				goto out;
 			}
 			__set_current_state(TASK_INTERRUPTIBLE);
@@ -3080,21 +3125,23 @@ wait_for_completion_interruptible_timeou
 		do {
 			if (signal_pending(current)) {
 				timeout = -ERESTARTSYS;
-				goto out_unlock;
+				__remove_wait_queue(&x->wait, &wait);
+				goto out;
 			}
 			__set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock_irq(&x->wait.lock);
 			timeout = schedule_timeout(timeout);
-			if (!timeout)
-				goto out;
 			spin_lock_irq(&x->wait.lock);
+			if (!timeout) {
+				__remove_wait_queue(&x->wait, &wait);
+				goto out;
+			}
 		} while (!x->done);
 		__remove_wait_queue(&x->wait, &wait);
 	}
 	x->done--;
-out_unlock:
-	spin_unlock_irq(&x->wait.lock);
 out:
+	spin_unlock_irq(&x->wait.lock);
 	return timeout;
 }
 EXPORT_SYMBOL(wait_for_completion_interruptible_timeout);
diff -purN linux-2.6.11-rc2-bk10/kernel/signal.c linux-2.6.11-rc3/kernel/signal.c
--- linux-2.6.11-rc2-bk10/kernel/signal.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/kernel/signal.c	2005-02-03 02:55:39.000000000 +0100
@@ -847,10 +847,7 @@ specific_send_sig_info(int sig, struct s
 
 	if (!irqs_disabled())
 		BUG();
-#ifdef CONFIG_SMP
-	if (!spin_is_locked(&t->sighand->siglock))
-		BUG();
-#endif
+	assert_spin_locked(&t->sighand->siglock);
 
 	if (((unsigned long)info > 2) && (info->si_code == SI_TIMER))
 		/*
@@ -1044,10 +1041,7 @@ __group_send_sig_info(int sig, struct si
 {
 	int ret = 0;
 
-#ifdef CONFIG_SMP
-	if (!spin_is_locked(&p->sighand->siglock))
-		BUG();
-#endif
+	assert_spin_locked(&p->sighand->siglock);
 	handle_stop_signal(sig, p);
 
 	if (((unsigned long)info > 2) && (info->si_code == SI_TIMER))
diff -purN linux-2.6.11-rc2-bk10/kernel/sysctl.c linux-2.6.11-rc3/kernel/sysctl.c
--- linux-2.6.11-rc2-bk10/kernel/sysctl.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/kernel/sysctl.c	2005-02-03 02:55:07.000000000 +0100
@@ -61,7 +61,6 @@ extern int core_uses_pid;
 extern char core_pattern[];
 extern int cad_pid;
 extern int pid_max;
-extern int sysctl_lower_zone_protection;
 extern int min_free_kbytes;
 extern int printk_ratelimit_jiffies;
 extern int printk_ratelimit_burst;
@@ -745,14 +744,13 @@ static ctl_table vm_table[] = {
 	 },
 #endif
 	{
-		.ctl_name	= VM_LOWER_ZONE_PROTECTION,
-		.procname	= "lower_zone_protection",
-		.data		= &sysctl_lower_zone_protection,
-		.maxlen		= sizeof(sysctl_lower_zone_protection),
+		.ctl_name	= VM_LOWMEM_RESERVE_RATIO,
+		.procname	= "lowmem_reserve_ratio",
+		.data		= &sysctl_lowmem_reserve_ratio,
+		.maxlen		= sizeof(sysctl_lowmem_reserve_ratio),
 		.mode		= 0644,
-		.proc_handler	= &lower_zone_protection_sysctl_handler,
+		.proc_handler	= &lowmem_reserve_ratio_sysctl_handler,
 		.strategy	= &sysctl_intvec,
-		.extra1		= &zero,
 	},
 	{
 		.ctl_name	= VM_MIN_FREE_KBYTES,
diff -purN linux-2.6.11-rc2-bk10/mm/memory.c linux-2.6.11-rc3/mm/memory.c
--- linux-2.6.11-rc2-bk10/mm/memory.c	2005-02-03 10:03:10.117460655 +0100
+++ linux-2.6.11-rc3/mm/memory.c	2005-02-03 02:55:50.000000000 +0100
@@ -84,20 +84,6 @@ EXPORT_SYMBOL(high_memory);
 EXPORT_SYMBOL(vmalloc_earlyreserve);
 
 /*
- * We special-case the C-O-W ZERO_PAGE, because it's such
- * a common occurrence (no need to read the page to know
- * that it's zero - better for the cache and memory subsystem).
- */
-static inline void copy_cow_page(struct page * from, struct page * to, unsigned long address)
-{
-	if (from == ZERO_PAGE(address)) {
-		clear_user_highpage(to, address);
-		return;
-	}
-	copy_user_highpage(to, from, address);
-}
-
-/*
  * Note: this doesn't free the actual pages themselves. That
  * has been handled earlier when unmapping all the memory regions.
  */
@@ -1330,11 +1316,16 @@ static int do_wp_page(struct mm_struct *
 
 	if (unlikely(anon_vma_prepare(vma)))
 		goto no_new_page;
-	new_page = alloc_page_vma(GFP_HIGHUSER, vma, address);
-	if (!new_page)
-		goto no_new_page;
-	copy_cow_page(old_page,new_page,address);
-
+	if (old_page == ZERO_PAGE(address)) {
+		new_page = alloc_zeroed_user_highpage(vma, address);
+		if (!new_page)
+			goto no_new_page;
+	} else {
+		new_page = alloc_page_vma(GFP_HIGHUSER, vma, address);
+		if (!new_page)
+			goto no_new_page;
+		copy_user_highpage(new_page, old_page, address);
+	}
 	/*
 	 * Re-check the pte - we dropped the lock
 	 */
@@ -1805,10 +1796,9 @@ do_anonymous_page(struct mm_struct *mm, 
 
 		if (unlikely(anon_vma_prepare(vma)))
 			goto no_mem;
-		page = alloc_page_vma(GFP_HIGHUSER, vma, addr);
+		page = alloc_zeroed_user_highpage(vma, addr);
 		if (!page)
 			goto no_mem;
-		clear_user_highpage(page, addr);
 
 		spin_lock(&mm->page_table_lock);
 		page_table = pte_offset_map(pmd, addr);
@@ -2106,7 +2096,6 @@ int handle_mm_fault(struct mm_struct *mm
 }
 
 #ifndef __ARCH_HAS_4LEVEL_HACK
-#if (PTRS_PER_PUD > 1)
 /*
  * Allocate page upper directory.
  *
@@ -2135,12 +2124,10 @@ pud_t fastcall *__pud_alloc(struct mm_st
 		goto out;
 	}
 	pgd_populate(mm, pgd, new);
-out:
+ out:
 	return pud_offset(pgd, address);
 }
-#endif
 
-#if (PTRS_PER_PMD > 1)
 /*
  * Allocate page middle directory.
  *
@@ -2169,10 +2156,9 @@ pmd_t fastcall *__pmd_alloc(struct mm_st
 		goto out;
 	}
 	pud_populate(mm, pud, new);
-out:
+ out:
 	return pmd_offset(pud, address);
 }
-#endif
 #else
 pmd_t fastcall *__pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
 {
diff -purN linux-2.6.11-rc2-bk10/mm/oom_kill.c linux-2.6.11-rc3/mm/oom_kill.c
--- linux-2.6.11-rc2-bk10/mm/oom_kill.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/mm/oom_kill.c	2005-02-03 02:55:53.000000000 +0100
@@ -42,21 +42,33 @@
  *    of least surprise ... (be careful when you change it)
  */
 
-static unsigned long badness(struct task_struct *p, unsigned long uptime)
+unsigned long badness(struct task_struct *p, unsigned long uptime)
 {
 	unsigned long points, cpu_time, run_time, s;
+	struct list_head *tsk;
 
 	if (!p->mm)
 		return 0;
 
-	if (p->flags & PF_MEMDIE)
-		return 0;
 	/*
 	 * The memory size of the process is the basis for the badness.
 	 */
 	points = p->mm->total_vm;
 
 	/*
+	 * Processes which fork a lot of child processes are likely
+	 * a good choice. We add the vmsize of the childs if they
+	 * have an own mm. This prevents forking servers to flood the
+	 * machine with an endless amount of childs
+	 */
+	list_for_each(tsk, &p->children) {
+		struct task_struct *chld;
+		chld = list_entry(tsk, struct task_struct, sibling);
+		if (chld->mm != p->mm && chld->mm)
+			points += chld->mm->total_vm;
+	}
+
+	/*
 	 * CPU time is in tens of seconds and run time is in thousands
          * of seconds. There is no particular reason for this other than
          * that it turned out to work very well in practice.
@@ -99,6 +111,17 @@ static unsigned long badness(struct task
 	 */
 	if (cap_t(p->cap_effective) & CAP_TO_MASK(CAP_SYS_RAWIO))
 		points /= 4;
+
+	/*
+	 * Adjust the score by oomkilladj.
+	 */
+	if (p->oomkilladj) {
+		if (p->oomkilladj > 0)
+			points <<= p->oomkilladj;
+		else
+			points >>= -(p->oomkilladj);
+	}
+
 #ifdef DEBUG
 	printk(KERN_DEBUG "OOMkill: task %d (%s) got %d points\n",
 	p->pid, p->comm, points);
@@ -121,14 +144,25 @@ static struct task_struct * select_bad_p
 
 	do_posix_clock_monotonic_gettime(&uptime);
 	do_each_thread(g, p)
-		if (p->pid) {
-			unsigned long points = badness(p, uptime.tv_sec);
-			if (points > maxpoints) {
+		/* skip the init task with pid == 1 */
+		if (p->pid > 1) {
+			unsigned long points;
+
+			/*
+			 * This is in the process of releasing memory so wait it
+			 * to finish before killing some other task by mistake.
+			 */
+			if ((unlikely(test_tsk_thread_flag(p, TIF_MEMDIE)) || (p->flags & PF_EXITING)) &&
+			    !(p->flags & PF_DEAD))
+				return ERR_PTR(-1UL);
+			if (p->flags & PF_SWAPOFF)
+				return p;
+
+			points = badness(p, uptime.tv_sec);
+			if (points > maxpoints || !chosen) {
 				chosen = p;
 				maxpoints = points;
 			}
-			if (p->flags & PF_SWAPOFF)
-				return p;
 		}
 	while_each_thread(g, p);
 	return chosen;
@@ -141,6 +175,12 @@ static struct task_struct * select_bad_p
  */
 static void __oom_kill_task(task_t *p)
 {
+	if (p->pid == 1) {
+		WARN_ON(1);
+		printk(KERN_WARNING "tried to kill init!\n");
+		return;
+	}
+
 	task_lock(p);
 	if (!p->mm || p->mm == &init_mm) {
 		WARN_ON(1);
@@ -157,25 +197,53 @@ static void __oom_kill_task(task_t *p)
 	 * exit() and clear out its resources quickly...
 	 */
 	p->time_slice = HZ;
-	p->flags |= PF_MEMALLOC | PF_MEMDIE;
+	set_tsk_thread_flag(p, TIF_MEMDIE);
 
-	/* This process has hardware access, be more careful. */
-	if (cap_t(p->cap_effective) & CAP_TO_MASK(CAP_SYS_RAWIO)) {
-		force_sig(SIGTERM, p);
-	} else {
-		force_sig(SIGKILL, p);
-	}
+	force_sig(SIGKILL, p);
 }
 
 static struct mm_struct *oom_kill_task(task_t *p)
 {
 	struct mm_struct *mm = get_task_mm(p);
-	if (!mm || mm == &init_mm)
+	task_t * g, * q;
+
+	if (!mm)
 		return NULL;
+	if (mm == &init_mm) {
+		mmput(mm);
+		return NULL;
+	}
+
 	__oom_kill_task(p);
+	/*
+	 * kill all processes that share the ->mm (i.e. all threads),
+	 * but are in a different thread group
+	 */
+	do_each_thread(g, q)
+		if (q->mm == mm && q->tgid != p->tgid)
+			__oom_kill_task(q);
+	while_each_thread(g, q);
+
 	return mm;
 }
 
+static struct mm_struct *oom_kill_process(struct task_struct *p)
+{
+ 	struct mm_struct *mm;
+	struct task_struct *c;
+	struct list_head *tsk;
+
+	/* Try to kill a child first */
+	list_for_each(tsk, &p->children) {
+		c = list_entry(tsk, struct task_struct, sibling);
+		if (c->mm == p->mm)
+			continue;
+		mm = oom_kill_task(c);
+		if (mm)
+			return mm;
+	}
+	return oom_kill_task(p);
+}
 
 /**
  * oom_kill - kill the "best" process when we run out of memory
@@ -185,117 +253,40 @@ static struct mm_struct *oom_kill_task(t
  * OR try to be smart about which process to kill. Note that we
  * don't have to be perfect here, we just have to be good.
  */
-static void oom_kill(void)
+void out_of_memory(int gfp_mask)
 {
-	struct mm_struct *mm;
-	struct task_struct *g, *p, *q;
-	
+	struct mm_struct *mm = NULL;
+	task_t * p;
+
 	read_lock(&tasklist_lock);
 retry:
 	p = select_bad_process();
 
+	if (PTR_ERR(p) == -1UL)
+		goto out;
+
 	/* Found nothing?!?! Either we hang forever, or we panic. */
 	if (!p) {
+		read_unlock(&tasklist_lock);
 		show_free_areas();
 		panic("Out of memory and no killable processes...\n");
 	}
 
-	mm = oom_kill_task(p);
-	if (!mm)
-		goto retry;
-	/*
-	 * kill all processes that share the ->mm (i.e. all threads),
-	 * but are in a different thread group
-	 */
-	do_each_thread(g, q)
-		if (q->mm == mm && q->tgid != p->tgid)
-			__oom_kill_task(q);
-	while_each_thread(g, q);
-	if (!p->mm)
-		printk(KERN_INFO "Fixed up OOM kill of mm-less task\n");
-	read_unlock(&tasklist_lock);
-	mmput(mm);
-
-	/*
-	 * Make kswapd go out of the way, so "p" has a good chance of
-	 * killing itself before someone else gets the chance to ask
-	 * for more memory.
-	 */
-	yield();
-	return;
-}
-
-/**
- * out_of_memory - is the system out of memory?
- */
-void out_of_memory(int gfp_mask)
-{
-	/*
-	 * oom_lock protects out_of_memory()'s static variables.
-	 * It's a global lock; this is not performance-critical.
-	 */
-	static DEFINE_SPINLOCK(oom_lock);
-	static unsigned long first, last, count, lastkill;
-	unsigned long now, since;
-
-	spin_lock(&oom_lock);
-	now = jiffies;
-	since = now - last;
-	last = now;
-
-	/*
-	 * If it's been a long time since last failure,
-	 * we're not oom.
-	 */
-	if (since > 5*HZ)
-		goto reset;
-
-	/*
-	 * If we haven't tried for at least one second,
-	 * we're not really oom.
-	 */
-	since = now - first;
-	if (since < HZ)
-		goto out_unlock;
-
-	/*
-	 * If we have gotten only a few failures,
-	 * we're not really oom. 
-	 */
-	if (++count < 10)
-		goto out_unlock;
-
-	/*
-	 * If we just killed a process, wait a while
-	 * to give that task a chance to exit. This
-	 * avoids killing multiple processes needlessly.
-	 */
-	since = now - lastkill;
-	if (since < HZ*5)
-		goto out_unlock;
-
-	/*
-	 * Ok, really out of memory. Kill something.
-	 */
-	lastkill = now;
-
 	printk("oom-killer: gfp_mask=0x%x\n", gfp_mask);
 	show_free_areas();
+	mm = oom_kill_process(p);
+	if (!mm)
+		goto retry;
 
-	/* oom_kill() sleeps */
-	spin_unlock(&oom_lock);
-	oom_kill();
-	spin_lock(&oom_lock);
+ out:
+	read_unlock(&tasklist_lock);
+	if (mm)
+		mmput(mm);
 
-reset:
 	/*
-	 * We dropped the lock above, so check to be sure the variable
-	 * first only ever increases to prevent false OOM's.
+	 * Give "p" a good chance of killing itself before we
+	 * retry to allocate memory.
 	 */
-	if (time_after(now, first))
-		first = now;
-	count = 0;
-
-out_unlock:
-	spin_unlock(&oom_lock);
+	__set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(1);
 }
diff -purN linux-2.6.11-rc2-bk10/mm/page_alloc.c linux-2.6.11-rc3/mm/page_alloc.c
--- linux-2.6.11-rc2-bk10/mm/page_alloc.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc3/mm/page_alloc.c	2005-02-03 02:57:05.000000000 +0100
@@ -44,7 +44,15 @@ struct pglist_data *pgdat_list;
 unsigned long totalram_pages;
 unsigned long totalhigh_pages;
 long nr_swap_pages;
-int sysctl_lower_zone_protection = 0;
+/*
+ * results with 256, 32 in the lowmem_reserve sysctl:
+ *	1G machine -> (16M dma, 800M-16M normal, 1G-800M high)
+ *	1G machine -> (16M dma, 784M normal, 224M high)
+ *	NORMAL allocation will leave 784M/256 of ram reserved in the ZONE_DMA
+ *	HIGHMEM allocation will leave 224M/32 of ram reserved in ZONE_NORMAL
+ *	HIGHMEM allocation will (224M+784M)/256 of ram reserved in ZONE_DMA
+ */
+int sysctl_lowmem_reserve_ratio[MAX_NR_ZONES-1] = { 256, 32 };
 
 EXPORT_SYMBOL(totalram_pages);
 EXPORT_SYMBOL(nr_swap_pages);
@@ -654,7 +662,7 @@ buffered_rmqueue(struct zone *zone, int 
  * of the allocation.
  */
 int zone_watermark_ok(struct zone *z, int order, unsigned long mark,
-		int alloc_type, int can_try_harder, int gfp_high)
+		      int classzone_idx, int can_try_harder, int gfp_high)
 {
 	/* free_pages my go negative - that's OK */
 	long min = mark, free_pages = z->free_pages - (1 << order) + 1;
@@ -665,7 +673,7 @@ int zone_watermark_ok(struct zone *z, in
 	if (can_try_harder)
 		min -= min / 4;
 
-	if (free_pages <= min + z->protection[alloc_type])
+	if (free_pages <= min + z->lowmem_reserve[classzone_idx])
 		return 0;
 	for (o = 0; o < order; o++) {
 		/* At the next order, this order's pages become unavailable */
@@ -682,19 +690,6 @@ int zone_watermark_ok(struct zone *z, in
 
 /*
  * This is the 'heart' of the zoned buddy allocator.
- *
- * Herein lies the mysterious "incremental min".  That's the
- *
- *	local_low = z->pages_low;
- *	min += local_low;
- *
- * thing.  The intent here is to provide additional protection to low zones for
- * allocation requests which _could_ use higher zones.  So a GFP_HIGHMEM
- * request is not allowed to dip as deeply into the normal zone as a GFP_KERNEL
- * request.  This preserves additional space in those lower zones for requests
- * which really do need memory from those zones.  It means that on a decent
- * sized machine, GFP_HIGHMEM and GFP_KERNEL requests basically leave the DMA
- * zone untouched.
  */
 struct page * fastcall
 __alloc_pages(unsigned int gfp_mask, unsigned int order,
@@ -706,9 +701,10 @@ __alloc_pages(unsigned int gfp_mask, uns
 	struct reclaim_state reclaim_state;
 	struct task_struct *p = current;
 	int i;
-	int alloc_type;
+	int classzone_idx;
 	int do_retry;
 	int can_try_harder;
+	int did_some_progress;
 
 	might_sleep_if(wait);
 
@@ -726,13 +722,14 @@ __alloc_pages(unsigned int gfp_mask, uns
 		return NULL;
 	}
 
-	alloc_type = zone_idx(zones[0]);
+	classzone_idx = zone_idx(zones[0]);
 
+ restart:
 	/* Go through the zonelist once, looking for a zone with enough free */
 	for (i = 0; (z = zones[i]) != NULL; i++) {
 
 		if (!zone_watermark_ok(z, order, z->pages_low,
-				alloc_type, 0, 0))
+				       classzone_idx, 0, 0))
 			continue;
 
 		page = buffered_rmqueue(z, order, gfp_mask);
@@ -749,8 +746,8 @@ __alloc_pages(unsigned int gfp_mask, uns
 	 */
 	for (i = 0; (z = zones[i]) != NULL; i++) {
 		if (!zone_watermark_ok(z, order, z->pages_min,
-				alloc_type, can_try_harder,
-				gfp_mask & __GFP_HIGH))
+				       classzone_idx, can_try_harder,
+				       gfp_mask & __GFP_HIGH))
 			continue;
 
 		page = buffered_rmqueue(z, order, gfp_mask);
@@ -759,7 +756,7 @@ __alloc_pages(unsigned int gfp_mask, uns
 	}
 
 	/* This allocation should allow future memory freeing. */
-	if ((p->flags & (PF_MEMALLOC | PF_MEMDIE)) && !in_interrupt()) {
+	if (((p->flags & PF_MEMALLOC) || unlikely(test_thread_flag(TIF_MEMDIE))) && !in_interrupt()) {
 		/* go through the zonelist yet again, ignoring mins */
 		for (i = 0; (z = zones[i]) != NULL; i++) {
 			page = buffered_rmqueue(z, order, gfp_mask);
@@ -774,26 +771,56 @@ __alloc_pages(unsigned int gfp_mask, uns
 		goto nopage;
 
 rebalance:
+	cond_resched();
+
 	/* We now go into synchronous reclaim */
 	p->flags |= PF_MEMALLOC;
 	reclaim_state.reclaimed_slab = 0;
 	p->reclaim_state = &reclaim_state;
 
-	try_to_free_pages(zones, gfp_mask, order);
+	did_some_progress = try_to_free_pages(zones, gfp_mask, order);
 
 	p->reclaim_state = NULL;
 	p->flags &= ~PF_MEMALLOC;
 
-	/* go through the zonelist yet one more time */
-	for (i = 0; (z = zones[i]) != NULL; i++) {
-		if (!zone_watermark_ok(z, order, z->pages_min,
-				alloc_type, can_try_harder,
-				gfp_mask & __GFP_HIGH))
-			continue;
+	cond_resched();
 
-		page = buffered_rmqueue(z, order, gfp_mask);
-		if (page)
-			goto got_pg;
+	if (likely(did_some_progress)) {
+		/*
+		 * Go through the zonelist yet one more time, keep
+		 * very high watermark here, this is only to catch
+		 * a parallel oom killing, we must fail if we're still
+		 * under heavy pressure.
+		 */
+		for (i = 0; (z = zones[i]) != NULL; i++) {
+			if (!zone_watermark_ok(z, order, z->pages_min,
+					       classzone_idx, can_try_harder,
+					       gfp_mask & __GFP_HIGH))
+				continue;
+
+			page = buffered_rmqueue(z, order, gfp_mask);
+			if (page)
+				goto got_pg;
+		}
+	} else if ((gfp_mask & __GFP_FS) && !(gfp_mask & __GFP_NORETRY)) {
+		/*
+		 * Go through the zonelist yet one more time, keep
+		 * very high watermark here, this is only to catch
+		 * a parallel oom killing, we must fail if we're still
+		 * under heavy pressure.
+		 */
+		for (i = 0; (z = zones[i]) != NULL; i++) {
+			if (!zone_watermark_ok(z, order, z->pages_high,
+					       classzone_idx, 0, 0))
+				continue;
+
+			page = buffered_rmqueue(z, order, gfp_mask);
+			if (page)
+				goto got_pg;
+		}
+
+		out_of_memory(gfp_mask);
+		goto restart;
 	}
 
 	/*
@@ -1210,9 +1237,9 @@ void show_free_areas(void)
 			zone->pages_scanned,
 			(zone->all_unreclaimable ? "yes" : "no")
 			);
-		printk("protections[]:");
+		printk("lowmem_reserve[]:");
 		for (i = 0; i < MAX_NR_ZONES; i++)
-			printk(" %lu", zone->protection[i]);
+			printk(" %lu", zone->lowmem_reserve[i]);
 		printk("\n");
 	}
 
@@ -1884,87 +1911,29 @@ void __init page_alloc_init(void)
 	hotcpu_notifier(page_alloc_cpu_notify, 0);
 }
 
-static unsigned long higherzone_val(struct zone *z, int max_zone,
-					int alloc_type)
-{
-	int z_idx = zone_idx(z);
-	struct zone *higherzone;
-	unsigned long pages;
-
-	/* there is no higher zone to get a contribution from */
-	if (z_idx == MAX_NR_ZONES-1)
-		return 0;
-
-	higherzone = &z->zone_pgdat->node_zones[z_idx+1];
-
-	/* We always start with the higher zone's protection value */
-	pages = higherzone->protection[alloc_type];
-
-	/*
-	 * We get a lower-zone-protection contribution only if there are
-	 * pages in the higher zone and if we're not the highest zone
-	 * in the current zonelist.  e.g., never happens for GFP_DMA. Happens
-	 * only for ZONE_DMA in a GFP_KERNEL allocation and happens for ZONE_DMA
-	 * and ZONE_NORMAL for a GFP_HIGHMEM allocation.
-	 */
-	if (higherzone->present_pages && z_idx < alloc_type)
-		pages += higherzone->pages_low * sysctl_lower_zone_protection;
-
-	return pages;
-}
-
 /*
- * setup_per_zone_protection - called whenver min_free_kbytes or
- *	sysctl_lower_zone_protection changes.  Ensures that each zone
- *	has a correct pages_protected value, so an adequate number of
+ * setup_per_zone_lowmem_reserve - called whenever
+ *	sysctl_lower_zone_reserve_ratio changes.  Ensures that each zone
+ *	has a correct pages reserved value, so an adequate number of
  *	pages are left in the zone after a successful __alloc_pages().
- *
- *	This algorithm is way confusing.  I tries to keep the same behavior
- *	as we had with the incremental min iterative algorithm.
  */
-static void setup_per_zone_protection(void)
+static void setup_per_zone_lowmem_reserve(void)
 {
 	struct pglist_data *pgdat;
-	struct zone *zones, *zone;
-	int max_zone;
-	int i, j;
+	int j, idx;
 
 	for_each_pgdat(pgdat) {
-		zones = pgdat->node_zones;
+		for (j = 0; j < MAX_NR_ZONES; j++) {
+			struct zone * zone = pgdat->node_zones + j;
+			unsigned long present_pages = zone->present_pages;
 
-		for (i = 0, max_zone = 0; i < MAX_NR_ZONES; i++)
-			if (zones[i].present_pages)
-				max_zone = i;
+			zone->lowmem_reserve[j] = 0;
 
-		/*
-		 * For each of the different allocation types:
-		 * GFP_DMA -> GFP_KERNEL -> GFP_HIGHMEM
-		 */
-		for (i = 0; i < GFP_ZONETYPES; i++) {
-			/*
-			 * For each of the zones:
-			 * ZONE_HIGHMEM -> ZONE_NORMAL -> ZONE_DMA
-			 */
-			for (j = MAX_NR_ZONES-1; j >= 0; j--) {
-				zone = &zones[j];
+			for (idx = j-1; idx >= 0; idx--) {
+				struct zone * lower_zone = pgdat->node_zones + idx;
 
-				/*
-				 * We never protect zones that don't have memory
-				 * in them (j>max_zone) or zones that aren't in
-				 * the zonelists for a certain type of
-				 * allocation (j>=i).  We have to assign these
-				 * to zero because the lower zones take
-				 * contributions from the higher zones.
-				 */
-				if (j > max_zone || j >= i) {
-					zone->protection[i] = 0;
-					continue;
-				}
-				/*
-				 * The contribution of the next higher zone
-				 */
-				zone->protection[i] = higherzone_val(zone,
-								max_zone, i);
+				lower_zone->lowmem_reserve[j] = present_pages / sysctl_lowmem_reserve_ratio[idx];
+				present_pages += lower_zone->present_pages;
 			}
 		}
 	}
@@ -2059,7 +2028,7 @@ static int __init init_per_zone_pages_mi
 	if (min_free_kbytes > 65536)
 		min_free_kbytes = 65536;
 	setup_per_zone_pages_min();
-	setup_per_zone_protection();
+	setup_per_zone_lowmem_reserve();
 	return 0;
 }
 module_init(init_per_zone_pages_min)
@@ -2074,20 +2043,23 @@ int min_free_kbytes_sysctl_handler(ctl_t
 {
 	proc_dointvec(table, write, file, buffer, length, ppos);
 	setup_per_zone_pages_min();
-	setup_per_zone_protection();
 	return 0;
 }
 
 /*
- * lower_zone_protection_sysctl_handler - just a wrapper around
- *	proc_dointvec() so that we can call setup_per_zone_protection()
- *	whenever sysctl_lower_zone_protection changes.
+ * lowmem_reserve_ratio_sysctl_handler - just a wrapper around
+ *	proc_dointvec() so that we can call setup_per_zone_lowmem_reserve()
+ *	whenever sysctl_lowmem_reserve_ratio changes.
+ *
+ * The reserve ratio obviously has absolutely no relation with the
+ * pages_min watermarks. The lowmem reserve ratio can only make sense
+ * if in function of the boot time zone sizes.
  */
-int lower_zone_protection_sysctl_handler(ctl_table *table, int write,
+int lowmem_reserve_ratio_sysctl_handler(ctl_table *table, int write,
 		 struct file *file, void __user *buffer, size_t *length, loff_t *ppos)
 {
 	proc_dointvec_minmax(table, write, file, buffer, length, ppos);
-	setup_per_zone_protection();
+	setup_per_zone_lowmem_reserve();
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk10/mm/slab.c linux-2.6.11-rc3/mm/slab.c
--- linux-2.6.11-rc2-bk10/mm/slab.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/mm/slab.c	2005-02-03 02:57:17.000000000 +0100
@@ -894,16 +894,13 @@ static void *kmem_getpages(kmem_cache_t 
 
 	flags |= cachep->gfpflags;
 	if (likely(nodeid == -1)) {
-		addr = (void*)__get_free_pages(flags, cachep->gfporder);
-		if (!addr)
-			return NULL;
-		page = virt_to_page(addr);
+		page = alloc_pages(flags, cachep->gfporder);
 	} else {
 		page = alloc_pages_node(nodeid, flags, cachep->gfporder);
-		if (!page)
-			return NULL;
-		addr = page_address(page);
 	}
+	if (!page)
+		return NULL;
+	addr = page_address(page);
 
 	i = (1 << cachep->gfporder);
 	if (cachep->flags & SLAB_RECLAIM_ACCOUNT)
diff -purN linux-2.6.11-rc2-bk10/mm/swap_state.c linux-2.6.11-rc3/mm/swap_state.c
--- linux-2.6.11-rc2-bk10/mm/swap_state.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/mm/swap_state.c	2005-02-03 02:55:50.000000000 +0100
@@ -59,6 +59,8 @@ void show_swap_cache_info(void)
 		swap_cache_info.add_total, swap_cache_info.del_total,
 		swap_cache_info.find_success, swap_cache_info.find_total,
 		swap_cache_info.noent_race, swap_cache_info.exist_race);
+	printk("Free swap  = %lukB\n", nr_swap_pages << (PAGE_SHIFT - 10));
+	printk("Total swap = %lukB\n", total_swap_pages << (PAGE_SHIFT - 10));
 }
 
 /*
diff -purN linux-2.6.11-rc2-bk10/mm/vmscan.c linux-2.6.11-rc3/mm/vmscan.c
--- linux-2.6.11-rc2-bk10/mm/vmscan.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/mm/vmscan.c	2005-02-03 02:55:14.000000000 +0100
@@ -937,8 +937,6 @@ int try_to_free_pages(struct zone **zone
 		if (sc.nr_scanned && priority < DEF_PRIORITY - 2)
 			blk_congestion_wait(WRITE, HZ/10);
 	}
-	if ((gfp_mask & __GFP_FS) && !(gfp_mask & __GFP_NORETRY))
-		out_of_memory(gfp_mask);
 out:
 	for (i = 0; zones[i] != 0; i++)
 		zones[i]->prev_priority = zones[i]->temp_priority;
diff -purN linux-2.6.11-rc2-bk10/net/core/pktgen.c linux-2.6.11-rc3/net/core/pktgen.c
--- linux-2.6.11-rc2-bk10/net/core/pktgen.c	2005-02-03 10:03:10.172452098 +0100
+++ linux-2.6.11-rc3/net/core/pktgen.c	2005-02-03 02:57:16.000000000 +0100
@@ -473,13 +473,13 @@ static inline __u64 tv_diff(const struct
 
 static char version[] __initdata = VERSION;
 
-static ssize_t proc_pgctrl_read(struct file* file, char * buf, size_t count, loff_t *ppos);
-static ssize_t proc_pgctrl_write(struct file* file, const char * buf, size_t count, loff_t *ppos);
+static ssize_t proc_pgctrl_read(struct file* file, char __user * buf, size_t count, loff_t *ppos);
+static ssize_t proc_pgctrl_write(struct file* file, const char __user * buf, size_t count, loff_t *ppos);
 static int proc_if_read(char *buf , char **start, off_t offset, int len, int *eof, void *data);
 
 static int proc_thread_read(char *buf , char **start, off_t offset, int len, int *eof, void *data);
-static int proc_if_write(struct file *file, const char *user_buffer, unsigned long count, void *data);
-static int proc_thread_write(struct file *file, const char *user_buffer, unsigned long count, void *data);
+static int proc_if_write(struct file *file, const char __user *user_buffer, unsigned long count, void *data);
+static int proc_thread_write(struct file *file, const char __user *user_buffer, unsigned long count, void *data);
 static int create_proc_dir(void);
 static int remove_proc_dir(void);
 
@@ -510,7 +510,7 @@ static char module_fname[128];
 static struct proc_dir_entry *module_proc_ent = NULL;
 
 static struct notifier_block pktgen_notifier_block = {
-	notifier_call: pktgen_device_event,
+	.notifier_call = pktgen_device_event,
 };
 
 static struct file_operations pktgen_fops = {
@@ -527,7 +527,7 @@ static struct file_operations pktgen_fop
 static struct proc_dir_entry *pg_proc_dir = NULL;
 static int proc_pgctrl_read_eof=0;
 
-static ssize_t proc_pgctrl_read(struct file* file, char * buf,
+static ssize_t proc_pgctrl_read(struct file* file, char __user * buf,
                                  size_t count, loff_t *ppos)
 { 
 	char data[200];
@@ -560,7 +560,7 @@ static ssize_t proc_pgctrl_read(struct f
 	return len;
 }
 
-static ssize_t proc_pgctrl_write(struct file* file,const char * buf,
+static ssize_t proc_pgctrl_write(struct file* file,const char __user * buf,
 				 size_t count, loff_t *ppos)
 {
 	char *data = NULL;
@@ -734,7 +734,7 @@ static int proc_if_read(char *buf , char
 }
 
 
-static int count_trail_chars(const char *user_buffer, unsigned int maxlen)
+static int count_trail_chars(const char __user *user_buffer, unsigned int maxlen)
 {
 	int i;
 
@@ -758,7 +758,7 @@ done:
 	return i;
 }
 
-static unsigned long num_arg(const char *user_buffer, unsigned long maxlen, 
+static unsigned long num_arg(const char __user *user_buffer, unsigned long maxlen, 
 			     unsigned long *num)
 {
 	int i = 0;
@@ -777,7 +777,7 @@ static unsigned long num_arg(const char 
 	return i;
 }
 
-static int strn_len(const char *user_buffer, unsigned int maxlen)
+static int strn_len(const char __user *user_buffer, unsigned int maxlen)
 {
 	int i = 0;
 
@@ -802,7 +802,7 @@ done_str:
 	return i;
 }
 
-static int proc_if_write(struct file *file, const char *user_buffer,
+static int proc_if_write(struct file *file, const char __user *user_buffer,
                             unsigned long count, void *data)
 {
 	int i = 0, max, len;
@@ -1392,7 +1392,7 @@ static int proc_thread_read(char *buf , 
 	return p - buf;
 }
 
-static int proc_thread_write(struct file *file, const char *user_buffer,
+static int proc_thread_write(struct file *file, const char __user *user_buffer,
                                 unsigned long count, void *data)
 {
 	int i = 0, max, len, ret;
@@ -2941,7 +2941,7 @@ static int pktgen_add_device(struct pktg
                         return -ENODEV;
                 }
 
-                pkt_dev->proc_ent = create_proc_entry(pkt_dev->fname, 0600, 0);
+                pkt_dev->proc_ent = create_proc_entry(pkt_dev->fname, 0600, NULL);
                 if (!pkt_dev->proc_ent) {
                         printk("pktgen: cannot create %s procfs entry.\n", pkt_dev->fname);
 			if (pkt_dev->flows)
@@ -3005,7 +3005,7 @@ static int pktgen_create_thread(const ch
 	t->cpu = cpu;
         
         sprintf(t->fname, "net/%s/%s", PG_PROC_DIR, t->name);
-        t->proc_ent = create_proc_entry(t->fname, 0600, 0);
+        t->proc_ent = create_proc_entry(t->fname, 0600, NULL);
         if (!t->proc_ent) {
                 printk("pktgen: cannot create %s procfs entry.\n", t->fname);
                 kfree(t);
@@ -3088,7 +3088,7 @@ static int __init pg_init(void) 
 	create_proc_dir();
 
         sprintf(module_fname, "net/%s/pgctrl", PG_PROC_DIR);
-        module_proc_ent = create_proc_entry(module_fname, 0600, 0);
+        module_proc_ent = create_proc_entry(module_fname, 0600, NULL);
         if (!module_proc_ent) {
                 printk("pktgen: ERROR: cannot create %s procfs entry.\n", module_fname);
                 return -EINVAL;
diff -purN linux-2.6.11-rc2-bk10/scripts/reference_discarded.pl linux-2.6.11-rc3/scripts/reference_discarded.pl
--- linux-2.6.11-rc2-bk10/scripts/reference_discarded.pl	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc3/scripts/reference_discarded.pl	2005-02-03 02:55:50.000000000 +0100
@@ -90,6 +90,7 @@ foreach $object (keys(%object)) {
 		     $from !~ /\.data\.exit$/ &&
 		     $from !~ /\.exit\.data$/ &&
 		     $from !~ /\.altinstructions$/ &&
+		     $from !~ /\.pdr$/ &&
 		     $from !~ /\.debug_info$/ &&
 		     $from !~ /\.debug_aranges$/ &&
 		     $from !~ /\.debug_ranges$/ &&
diff -purN linux-2.6.11-rc2-bk10/scripts/reference_init.pl linux-2.6.11-rc3/scripts/reference_init.pl
--- linux-2.6.11-rc2-bk10/scripts/reference_init.pl	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc3/scripts/reference_init.pl	2005-02-03 02:56:22.000000000 +0100
@@ -95,6 +95,7 @@ foreach $object (sort(keys(%object))) {
 		     $from !~ /\.text\.lock$/ &&
 		     $from !~ /\.pci_fixup_header$/ &&
 		     $from !~ /\.pci_fixup_final$/ &&
+		     $from !~ /\.pdr$/ &&
 		     $from !~ /\__param$/ &&
 		     $from !~ /\.altinstructions/ &&
 		     $from !~ /\.debug_/)) {
diff -purN linux-2.6.11-rc2-bk10/sound/Kconfig linux-2.6.11-rc3/sound/Kconfig
--- linux-2.6.11-rc2-bk10/sound/Kconfig	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc3/sound/Kconfig	2005-02-03 02:56:48.000000000 +0100
@@ -55,6 +55,8 @@ source "sound/ppc/Kconfig"
 
 source "sound/arm/Kconfig"
 
+source "sound/mips/Kconfig"
+
 # the following will depenend on the order of config.
 # here assuming USB is defined before ALSA
 source "sound/usb/Kconfig"
diff -purN linux-2.6.11-rc2-bk10/sound/Makefile linux-2.6.11-rc3/sound/Makefile
--- linux-2.6.11-rc2-bk10/sound/Makefile	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/sound/Makefile	2005-02-03 02:55:23.000000000 +0100
@@ -4,7 +4,7 @@
 obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/
+obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/
 
 ifeq ($(CONFIG_SND),y)
   obj-y += last.o
diff -purN linux-2.6.11-rc2-bk10/sound/mips/Kconfig linux-2.6.11-rc3/sound/mips/Kconfig
--- linux-2.6.11-rc2-bk10/sound/mips/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/sound/mips/Kconfig	2005-02-03 02:55:23.000000000 +0100
@@ -0,0 +1,15 @@
+# ALSA MIPS drivers
+
+menu "ALSA MIPS devices"
+	depends on SND!=n && MIPS
+
+config SND_AU1X00
+	tristate "Au1x00 AC97 Port Driver"
+	depends on (SOC_AU1000 || SOC_AU1100 || SOC_AU1500) && SND
+	select SND_PCM
+	select SND_AC97_CODEC
+	help
+	  ALSA Sound driver for the Au1x00's AC97 port.
+
+endmenu
+
diff -purN linux-2.6.11-rc2-bk10/sound/mips/Makefile linux-2.6.11-rc3/sound/mips/Makefile
--- linux-2.6.11-rc2-bk10/sound/mips/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/sound/mips/Makefile	2005-02-03 02:57:05.000000000 +0100
@@ -0,0 +1,8 @@
+#
+# Makefile for ALSA
+#
+
+snd-au1x00-objs := au1x00.o
+
+# Toplevel Module Dependency
+obj-$(CONFIG_SND_AU1X00) += snd-au1x00.o
diff -purN linux-2.6.11-rc2-bk10/sound/mips/au1x00.c linux-2.6.11-rc3/sound/mips/au1x00.c
--- linux-2.6.11-rc2-bk10/sound/mips/au1x00.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/sound/mips/au1x00.c	2005-02-03 02:54:59.000000000 +0100
@@ -0,0 +1,686 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *  Driver for AMD Au1000 MIPS Processor, AC'97 Sound Port
+ *
+ * Copyright 2004 Cooper Street Innovations Inc.
+ * Author: Charles Eidsness	<charles@cooper-street.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * History:
+ *
+ * 2004-09-09 Charles Eidsness	-- Original verion -- based on
+ * 				  sa11xx-uda1341.c ALSA driver and the
+ *				  au1000.c OSS driver.
+ * 2004-09-09 Matt Porter	-- Added support for ALSA 1.0.6
+ *
+ */
+
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1000_dma.h>
+
+MODULE_AUTHOR("Charles Eidsness <charles@cooper-street.com>");
+MODULE_DESCRIPTION("Au1000 AC'97 ALSA Driver");
+MODULE_LICENSE("GPL");
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+MODULE_SUPPORTED_DEVICE("{{AMD,Au1000 AC'97}}");
+#else
+MODULE_CLASSES("{sound}");
+MODULE_DEVICES("{{AMD,Au1000 AC'97}}");
+#endif
+
+#define chip_t au1000_t
+
+#define PLAYBACK 0
+#define CAPTURE 1
+#define AC97_SLOT_3 0x01
+#define AC97_SLOT_4 0x02
+#define AC97_SLOT_6 0x08
+#define AC97_CMD_IRQ 31
+#define READ 0
+#define WRITE 1
+#define READ_WAIT 2
+#define RW_DONE 3
+
+DECLARE_WAIT_QUEUE_HEAD(ac97_command_wq);
+
+typedef struct au1000_period au1000_period_t;
+struct au1000_period
+{
+	u32 start;
+	u32 relative_end;	/*realtive to start of buffer*/
+	au1000_period_t * next;
+};
+
+/*Au1000 AC97 Port Control Reisters*/
+typedef struct au1000_ac97_reg au1000_ac97_reg_t;
+struct au1000_ac97_reg {
+	u32 volatile config;
+	u32 volatile status;
+	u32 volatile data;
+	u32 volatile cmd;
+	u32 volatile cntrl;
+};
+
+typedef struct audio_stream audio_stream_t;
+struct audio_stream {
+	snd_pcm_substream_t * substream;
+	int dma;
+	spinlock_t dma_lock;
+	au1000_period_t * buffer;
+	unsigned long period_size;
+};
+
+typedef struct snd_card_au1000 {
+	snd_card_t *card;
+	au1000_ac97_reg_t volatile *ac97_ioport;
+
+	struct resource *ac97_res_port;
+	spinlock_t ac97_lock;
+	ac97_t *ac97;
+
+	snd_pcm_t *pcm;
+	audio_stream_t *stream[2];	/* playback & capture */
+} au1000_t;
+
+static au1000_t *au1000 = NULL;
+
+/*--------------------------- Local Functions --------------------------------*/
+static void
+au1000_set_ac97_xmit_slots(long xmit_slots)
+{
+	u32 volatile ac97_config;
+
+	spin_lock(&au1000->ac97_lock);
+	ac97_config = au1000->ac97_ioport->config;
+	ac97_config = ac97_config & ~AC97C_XMIT_SLOTS_MASK;
+	ac97_config |= (xmit_slots << AC97C_XMIT_SLOTS_BIT);
+	au1000->ac97_ioport->config = ac97_config;
+	spin_unlock(&au1000->ac97_lock);
+}
+
+static void
+au1000_set_ac97_recv_slots(long recv_slots)
+{
+	u32 volatile ac97_config;
+
+	spin_lock(&au1000->ac97_lock);
+	ac97_config = au1000->ac97_ioport->config;
+	ac97_config = ac97_config & ~AC97C_RECV_SLOTS_MASK;
+	ac97_config |= (recv_slots << AC97C_RECV_SLOTS_BIT);
+	au1000->ac97_ioport->config = ac97_config;
+	spin_unlock(&au1000->ac97_lock);
+}
+
+
+static void
+au1000_dma_stop(audio_stream_t *stream)
+{
+	unsigned long   flags;
+	au1000_period_t * pointer;
+	au1000_period_t * pointer_next;
+
+	if (stream->buffer != NULL) {
+		spin_lock_irqsave(&stream->dma_lock, flags);
+		disable_dma(stream->dma);
+		spin_unlock_irqrestore(&stream->dma_lock, flags);
+
+		pointer = stream->buffer;
+		pointer_next = stream->buffer->next;
+
+		do {
+			kfree(pointer);
+			pointer = pointer_next;
+			pointer_next = pointer->next;
+		} while (pointer != stream->buffer);
+
+		stream->buffer = NULL;
+	}
+}
+
+static void
+au1000_dma_start(audio_stream_t *stream)
+{
+	snd_pcm_substream_t *substream = stream->substream;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	unsigned long flags, dma_start;
+	int i;
+	au1000_period_t * pointer;
+
+	if (stream->buffer == NULL) {
+		dma_start = virt_to_phys(runtime->dma_area);
+
+		stream->period_size = frames_to_bytes(runtime,
+			runtime->period_size);
+		stream->buffer = kmalloc(sizeof(au1000_period_t), GFP_KERNEL);
+		pointer = stream->buffer;
+		for (i = 0 ; i < runtime->periods ; i++) {
+			pointer->start = (u32)(dma_start +
+				(i * stream->period_size));
+			pointer->relative_end = (u32)
+				(((i+1) * stream->period_size) - 0x1);
+			if ( i < runtime->periods - 1) {
+				pointer->next = kmalloc(sizeof(au1000_period_t)
+					, GFP_KERNEL);
+				pointer = pointer->next;
+			}
+		}
+		pointer->next = stream->buffer;
+
+		spin_lock_irqsave(&stream->dma_lock, flags);
+		init_dma(stream->dma);
+		if (get_dma_active_buffer(stream->dma) == 0) {
+			clear_dma_done0(stream->dma);
+			set_dma_addr0(stream->dma, stream->buffer->start);
+			set_dma_count0(stream->dma, stream->period_size >> 1);
+			set_dma_addr1(stream->dma, stream->buffer->next->start);
+			set_dma_count1(stream->dma, stream->period_size >> 1);
+		} else {
+			clear_dma_done1(stream->dma);
+			set_dma_addr1(stream->dma, stream->buffer->start);
+			set_dma_count1(stream->dma, stream->period_size >> 1);
+			set_dma_addr0(stream->dma, stream->buffer->next->start);
+			set_dma_count0(stream->dma, stream->period_size >> 1);
+		}
+		enable_dma_buffers(stream->dma);
+		start_dma(stream->dma);
+		spin_unlock_irqrestore(&stream->dma_lock, flags);
+	}
+}
+
+static irqreturn_t
+au1000_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	audio_stream_t *stream = (audio_stream_t *) dev_id;
+	snd_pcm_substream_t *substream = stream->substream;
+
+	spin_lock(&stream->dma_lock);
+	switch (get_dma_buffer_done(stream->dma)) {
+	case DMA_D0:
+		stream->buffer = stream->buffer->next;
+		clear_dma_done0(stream->dma);
+		set_dma_addr0(stream->dma, stream->buffer->next->start);
+		set_dma_count0(stream->dma, stream->period_size >> 1);
+		enable_dma_buffer0(stream->dma);
+		break;
+	case DMA_D1:
+		stream->buffer = stream->buffer->next;
+		clear_dma_done1(stream->dma);
+		set_dma_addr1(stream->dma, stream->buffer->next->start);
+		set_dma_count1(stream->dma, stream->period_size >> 1);
+		enable_dma_buffer1(stream->dma);
+		break;
+	case (DMA_D0 | DMA_D1):
+		spin_unlock(&stream->dma_lock);
+		printk(KERN_ERR "DMA %d missed interrupt.\n",stream->dma);
+		au1000_dma_stop(stream);
+		au1000_dma_start(stream);
+		spin_lock(&stream->dma_lock);
+		break;
+	case (~DMA_D0 & ~DMA_D1):
+		printk(KERN_ERR "DMA %d empty irq.\n",stream->dma);
+	}
+	spin_unlock(&stream->dma_lock);
+	snd_pcm_period_elapsed(substream);
+	return IRQ_HANDLED;
+}
+
+/*-------------------------- PCM Audio Streams -------------------------------*/
+
+static unsigned int rates[] = {8000, 11025, 16000, 22050};
+static snd_pcm_hw_constraint_list_t hw_constraints_rates = {
+	.count	=  sizeof(rates) / sizeof(rates[0]),
+	.list	= rates,
+	.mask	= 0,
+};
+
+static snd_pcm_hardware_t snd_au1000 =
+{
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED | \
+				SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |
+				SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050),
+	.rate_min		= 8000,
+	.rate_max		= 22050,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 16*1024,
+	.periods_min		= 8,
+	.periods_max		= 255,
+	.fifo_size		= 16,
+};
+
+static int
+snd_au1000_playback_open(snd_pcm_substream_t * substream)
+{
+	au1000->stream[PLAYBACK]->substream = substream;
+	au1000->stream[PLAYBACK]->buffer = NULL;
+	substream->private_data = au1000->stream[PLAYBACK];
+	substream->runtime->hw = snd_au1000;
+	return (snd_pcm_hw_constraint_list(substream->runtime, 0,
+		SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates) < 0);
+}
+
+static int
+snd_au1000_capture_open(snd_pcm_substream_t * substream)
+{
+	au1000->stream[CAPTURE]->substream = substream;
+	au1000->stream[CAPTURE]->buffer = NULL;
+	substream->private_data = au1000->stream[CAPTURE];
+	substream->runtime->hw = snd_au1000;
+	return (snd_pcm_hw_constraint_list(substream->runtime, 0,
+		SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates) < 0);
+
+}
+
+static int
+snd_au1000_playback_close(snd_pcm_substream_t * substream)
+{
+	au1000->stream[PLAYBACK]->substream = NULL;
+	return 0;
+}
+
+static int
+snd_au1000_capture_close(snd_pcm_substream_t * substream)
+{
+	au1000->stream[CAPTURE]->substream = NULL;
+	return 0;
+}
+
+static int
+snd_au1000_hw_params(snd_pcm_substream_t * substream,
+					snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static int
+snd_au1000_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int
+snd_au1000_playback_prepare(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if (runtime->channels == 1 )
+		au1000_set_ac97_xmit_slots(AC97_SLOT_4);
+	else
+		au1000_set_ac97_xmit_slots(AC97_SLOT_3 | AC97_SLOT_4);
+	snd_ac97_set_rate(au1000->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
+	return 0;
+}
+
+static int
+snd_au1000_capture_prepare(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if (runtime->channels == 1 )
+		au1000_set_ac97_recv_slots(AC97_SLOT_4);
+	else
+		au1000_set_ac97_recv_slots(AC97_SLOT_3 | AC97_SLOT_4);
+	snd_ac97_set_rate(au1000->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);
+	return 0;
+}
+
+static int
+snd_au1000_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	audio_stream_t *stream = substream->private_data;
+	int err = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		au1000_dma_start(stream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		au1000_dma_stop(stream);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	return err;
+}
+
+static snd_pcm_uframes_t
+snd_au1000_pointer(snd_pcm_substream_t * substream)
+{
+	audio_stream_t *stream = substream->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long flags;
+	long location;
+
+	spin_lock_irqsave(&stream->dma_lock, flags);
+	location = get_dma_residue(stream->dma);
+	spin_unlock_irqrestore(&stream->dma_lock, flags);
+	location = stream->buffer->relative_end - location;
+	if (location == -1)
+		location = 0;
+	return bytes_to_frames(runtime,location);
+}
+
+static snd_pcm_ops_t snd_card_au1000_playback_ops = {
+	.open			= snd_au1000_playback_open,
+	.close			= snd_au1000_playback_close,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params	        = snd_au1000_hw_params,
+	.hw_free	        = snd_au1000_hw_free,
+	.prepare		= snd_au1000_playback_prepare,
+	.trigger		= snd_au1000_trigger,
+	.pointer		= snd_au1000_pointer,
+};
+
+static snd_pcm_ops_t snd_card_au1000_capture_ops = {
+	.open			= snd_au1000_capture_open,
+	.close			= snd_au1000_capture_close,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params	        = snd_au1000_hw_params,
+	.hw_free	        = snd_au1000_hw_free,
+	.prepare		= snd_au1000_capture_prepare,
+	.trigger		= snd_au1000_trigger,
+	.pointer		= snd_au1000_pointer,
+};
+
+static int __devinit
+snd_au1000_pcm_new(void)
+{
+	snd_pcm_t *pcm;
+	int err;
+	unsigned long flags;
+
+	if ((err = snd_pcm_new(au1000->card, "AU1000 AC97 PCM", 0, 1, 1, &pcm)) < 0)
+		return err;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+		snd_dma_continuous_data(GFP_KERNEL), 128*1024, 128*1024);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+		&snd_card_au1000_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+		&snd_card_au1000_capture_ops);
+
+	pcm->private_data = au1000;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "Au1000 AC97 PCM");
+
+	flags = claim_dma_lock();
+	if ((au1000->stream[PLAYBACK]->dma = request_au1000_dma(DMA_ID_AC97C_TX,
+			"AC97 TX", au1000_dma_interrupt, SA_INTERRUPT,
+			au1000->stream[PLAYBACK])) < 0) {
+		release_dma_lock(flags);
+		return -EBUSY;
+	}
+	if ((au1000->stream[CAPTURE]->dma = request_au1000_dma(DMA_ID_AC97C_RX,
+			"AC97 RX", au1000_dma_interrupt, SA_INTERRUPT,
+			au1000->stream[CAPTURE])) < 0){
+		release_dma_lock(flags);
+		return -EBUSY;
+	}
+	/* enable DMA coherency in read/write DMA channels */
+	set_dma_mode(au1000->stream[PLAYBACK]->dma,
+		     get_dma_mode(au1000->stream[PLAYBACK]->dma) & ~DMA_NC);
+	set_dma_mode(au1000->stream[CAPTURE]->dma,
+		     get_dma_mode(au1000->stream[CAPTURE]->dma) & ~DMA_NC);
+	release_dma_lock(flags);
+	spin_lock_init(&au1000->stream[PLAYBACK]->dma_lock);
+	spin_lock_init(&au1000->stream[CAPTURE]->dma_lock);
+	au1000->pcm = pcm;
+	return 0;
+}
+
+
+/*-------------------------- AC97 CODEC Control ------------------------------*/
+
+static unsigned short
+snd_au1000_ac97_read(ac97_t *ac97, unsigned short reg)
+{
+	u32 volatile cmd;
+	u16 volatile data;
+	int             i;
+	spin_lock(au1000->ac97_lock);
+/* would rather use the interupt than this polling but it works and I can't
+get the interupt driven case to work efficiently */
+	for (i = 0; i < 0x5000; i++)
+		if (!(au1000->ac97_ioport->status & AC97C_CP))
+			break;
+	if (i == 0x5000)
+		printk(KERN_ERR "au1000 AC97: AC97 command read timeout\n");
+
+	cmd = (u32) reg & AC97C_INDEX_MASK;
+	cmd |= AC97C_READ;
+	au1000->ac97_ioport->cmd = cmd;
+
+	/* now wait for the data */
+	for (i = 0; i < 0x5000; i++)
+		if (!(au1000->ac97_ioport->status & AC97C_CP))
+			break;
+	if (i == 0x5000) {
+		printk(KERN_ERR "au1000 AC97: AC97 command read timeout\n");
+		return 0;
+	}
+
+	data = au1000->ac97_ioport->cmd & 0xffff;
+	spin_unlock(au1000->ac97_lock);
+
+	return data;
+
+}
+
+
+static void
+snd_au1000_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
+{
+	u32 cmd;
+	int i;
+	spin_lock(au1000->ac97_lock);
+/* would rather use the interupt than this polling but it works and I can't
+get the interupt driven case to work efficiently */
+	for (i = 0; i < 0x5000; i++)
+		if (!(au1000->ac97_ioport->status & AC97C_CP))
+			break;
+	if (i == 0x5000)
+		printk(KERN_ERR "au1000 AC97: AC97 command write timeout\n");
+
+	cmd = (u32) reg & AC97C_INDEX_MASK;
+	cmd &= ~AC97C_READ;
+	cmd |= ((u32) val << AC97C_WD_BIT);
+	au1000->ac97_ioport->cmd = cmd;
+	spin_unlock(au1000->ac97_lock);
+}
+static void
+snd_au1000_ac97_free(ac97_t *ac97)
+{
+	au1000->ac97 = NULL;
+}
+
+static int __devinit
+snd_au1000_ac97_new(void)
+{
+	int err;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	ac97_bus_t *pbus;
+	ac97_template_t ac97;
+ 	static ac97_bus_ops_t ops = {
+		.write = snd_au1000_ac97_write,
+		.read = snd_au1000_ac97_read,
+	};
+#else
+	ac97_bus_t bus, *pbus;
+	ac97_t ac97;
+#endif
+
+	if ((au1000->ac97_res_port = request_region(AC97C_CONFIG,
+	       		sizeof(au1000_ac97_reg_t), "Au1x00 AC97")) == NULL) {
+		snd_printk(KERN_ERR "ALSA AC97: can't grap AC97 port\n");
+		return -EBUSY;
+	}
+	au1000->ac97_ioport = (au1000_ac97_reg_t *) au1000->ac97_res_port->start;
+
+	spin_lock_init(&au1000->ac97_lock);
+
+	spin_lock(&au1000->ac97_lock);
+
+	/* configure pins for AC'97
+	TODO: move to board_setup.c */
+	au_writel(au_readl(SYS_PINFUNC) & ~0x02, SYS_PINFUNC);
+
+	/* Initialise Au1000's AC'97 Control Block */
+	au1000->ac97_ioport->cntrl = AC97C_RS | AC97C_CE;
+	udelay(10);
+	au1000->ac97_ioport->cntrl = AC97C_CE;
+	udelay(10);
+
+	/* Initialise External CODEC -- cold reset */
+	au1000->ac97_ioport->config = AC97C_RESET;
+	udelay(10);
+	au1000->ac97_ioport->config = 0x0;
+	mdelay(5);
+
+	spin_unlock(&au1000->ac97_lock);
+
+	/* Initialise AC97 middle-layer */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	if ((err = snd_ac97_bus(au1000->card, 0, &ops, au1000, &pbus)) < 0)
+ 		return err;
+#else
+	memset(&bus, 0, sizeof(bus));
+	bus.write = snd_au1000_ac97_write;
+	bus.read = snd_au1000_ac97_read;
+	if ((err = snd_ac97_bus(au1000->card, &bus, &pbus)) < 0)
+		return err;
+#endif
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = au1000;
+	ac97.private_free = snd_au1000_ac97_free;
+	if ((err = snd_ac97_mixer(pbus, &ac97, &au1000->ac97)) < 0)
+		return err;
+	return 0;
+
+}
+
+/*------------------------------ Setup / Destroy ----------------------------*/
+
+void
+snd_au1000_free(snd_card_t *card)
+{
+
+	if (au1000->ac97_res_port) {
+		/* put internal AC97 block into reset */
+		au1000->ac97_ioport->cntrl = AC97C_RS;
+		au1000->ac97_ioport = NULL;
+		release_resource(au1000->ac97_res_port);
+		kfree_nocheck(au1000->ac97_res_port);
+	}
+
+	if (au1000->stream[PLAYBACK]->dma >= 0)
+		free_au1000_dma(au1000->stream[PLAYBACK]->dma);
+
+	if (au1000->stream[CAPTURE]->dma >= 0)
+		free_au1000_dma(au1000->stream[CAPTURE]->dma);
+
+	kfree(au1000->stream[PLAYBACK]);
+	au1000->stream[PLAYBACK] = NULL;
+	kfree(au1000->stream[CAPTURE]);
+	au1000->stream[CAPTURE] = NULL;
+	kfree(au1000);
+	au1000 = NULL;
+
+}
+
+static int __init
+au1000_init(void)
+{
+	int err;
+
+	au1000 = kmalloc(sizeof(au1000_t), GFP_KERNEL);
+	if (au1000 == NULL)
+		return -ENOMEM;
+	au1000->stream[PLAYBACK] = kmalloc(sizeof(audio_stream_t), GFP_KERNEL);
+	if (au1000->stream[PLAYBACK] == NULL)
+		return -ENOMEM;
+	au1000->stream[CAPTURE] = kmalloc(sizeof(audio_stream_t), GFP_KERNEL);
+	if (au1000->stream[CAPTURE] == NULL)
+		return -ENOMEM;
+	/* so that snd_au1000_free will work as intended */
+	au1000->stream[PLAYBACK]->dma = -1;
+	au1000->stream[CAPTURE]->dma = -1;
+ 	au1000->ac97_res_port = NULL;
+
+	au1000->card = snd_card_new(-1, "AC97", THIS_MODULE, sizeof(au1000_t));
+	if (au1000->card == NULL) {
+		snd_au1000_free(au1000->card);
+		return -ENOMEM;
+	}
+
+	au1000->card->private_data = (au1000_t *)au1000;
+	au1000->card->private_free = snd_au1000_free;
+
+	if ((err = snd_au1000_ac97_new()) < 0 ) {
+		snd_card_free(au1000->card);
+		return err;
+	}
+
+	if ((err = snd_au1000_pcm_new()) < 0) {
+		snd_card_free(au1000->card);
+		return err;
+	}
+
+	strcpy(au1000->card->driver, "AMD-Au1000-AC97");
+	strcpy(au1000->card->shortname, "Au1000-AC97");
+	sprintf(au1000->card->longname, "AMD Au1000--AC97 ALSA Driver");
+
+	if ((err = snd_card_register(au1000->card)) < 0) {
+		snd_card_free(au1000->card);
+		return err;
+	}
+
+	printk( KERN_INFO "ALSA AC97: Driver Initialized\n" );
+	return 0;
+}
+
+static void __exit au1000_exit(void)
+{
+	snd_card_free(au1000->card);
+}
+
+module_init(au1000_init);
+module_exit(au1000_exit);
+
diff -purN linux-2.6.11-rc2-bk10/sound/oss/Kconfig linux-2.6.11-rc3/sound/oss/Kconfig
--- linux-2.6.11-rc2-bk10/sound/oss/Kconfig	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/Kconfig	2005-02-03 02:56:33.000000000 +0100
@@ -100,6 +100,16 @@ config SOUND_CS4281
 	  Picture and feature list at
 	  <http://www.pcbroker.com/crystal4281.html>.
 
+config SOUND_BCM_CS4297A
+	tristate "Crystal Sound CS4297a (for Swarm)"
+	depends on SOUND_PRIME!=n && SIBYTE_SWARM && SOUND
+	help
+	  The BCM91250A has a Crystal CS4297a on synchronous serial
+	  port B (in addition to the DB-9 serial port).  Say Y or M
+	  here to enable the sound chip instead of the UART.  Also
+	  note that CONFIG_KGDB should not be enabled at the same
+	  time, since it also attempts to use this UART port.
+
 config SOUND_ES1370
 	tristate "Ensoniq AudioPCI (ES1370)"
 	depends on SOUND_PRIME!=n && SOUND && PCI && SOUND_GAMEPORT
@@ -194,6 +204,10 @@ config SOUND_HAL2
 	  Say Y or M if you have an SGI Indy system and want to be able to
 	  use it's on-board A2 audio system.
 
+config SOUND_IT8172
+	tristate "IT8172G Sound"
+	depends on SOUND_PRIME!=n && (MIPS_ITE8172 || MIPS_IVR) && SOUND
+
 config SOUND_VRC5477
 	tristate "NEC Vrc5477 AC97 sound"
 	depends on SOUND_PRIME!=n && DDB5477 && SOUND
@@ -202,6 +216,14 @@ config SOUND_VRC5477
 	  integrated, multi-function controller chip for MIPS CPUs.  Works
 	  with the AC97 codec.
 
+config SOUND_AU1000
+	tristate "Au1000 Sound"
+	depends on SOUND_PRIME!=n && (SOC_AU1000 || SOC_AU1100 || SOC_AU1500) && SOUND
+
+config SOUND_AU1550_AC97
+	tristate "Au1550 AC97 Sound"
+	depends on SOUND_PRIME!=n && SOC_AU1550 && SOUND
+
 config SOUND_TRIDENT
 	tristate "Trident 4DWave DX/NX, SiS 7018 or ALi 5451 PCI Audio Core"
 	depends on SOUND_PRIME!=n && SOUND && SOUND_GAMEPORT
diff -purN linux-2.6.11-rc2-bk10/sound/oss/Makefile linux-2.6.11-rc3/sound/oss/Makefile
--- linux-2.6.11-rc2-bk10/sound/oss/Makefile	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/Makefile	2005-02-03 02:55:23.000000000 +0100
@@ -64,6 +64,8 @@ endif
 obj-$(CONFIG_SOUND_ES1370)	+= es1370.o
 obj-$(CONFIG_SOUND_ES1371)	+= es1371.o ac97_codec.o
 obj-$(CONFIG_SOUND_VRC5477)	+= nec_vrc5477.o ac97_codec.o
+obj-$(CONFIG_SOUND_AU1000)	+= au1000.o ac97_codec.o
+obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o
 obj-$(CONFIG_SOUND_ESSSOLO1)	+= esssolo1.o
 obj-$(CONFIG_SOUND_FUSION)	+= cs46xx.o ac97_codec.o
 obj-$(CONFIG_SOUND_MAESTRO)	+= maestro.o
@@ -71,6 +73,7 @@ obj-$(CONFIG_SOUND_MAESTRO3)	+= maestro3
 obj-$(CONFIG_SOUND_TRIDENT)	+= trident.o ac97_codec.o
 obj-$(CONFIG_SOUND_HARMONY)	+= harmony.o
 obj-$(CONFIG_SOUND_EMU10K1)	+= ac97_codec.o
+obj-$(CONFIG_SOUND_BCM_CS4297A)	+= swarm_cs4297a.o
 obj-$(CONFIG_SOUND_RME96XX)     += rme96xx.o
 obj-$(CONFIG_SOUND_BT878)	+= btaudio.o
 obj-$(CONFIG_SOUND_ALI5455)	+= ali5455.o ac97_codec.o
diff -purN linux-2.6.11-rc2-bk10/sound/oss/ac97_codec.c linux-2.6.11-rc3/sound/oss/ac97_codec.c
--- linux-2.6.11-rc2-bk10/sound/oss/ac97_codec.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/ac97_codec.c	2005-02-03 02:55:14.000000000 +0100
@@ -177,6 +177,7 @@ static const struct {
 	{0x83847608, "SigmaTel STAC9708",	&sigmatel_9708_ops},
 	{0x83847609, "SigmaTel STAC9721/23",	&sigmatel_9721_ops},
 	{0x83847644, "SigmaTel STAC9744/45",	&sigmatel_9744_ops},
+	{0x83847652, "SigmaTel STAC9752/53",	&default_ops},
 	{0x83847656, "SigmaTel STAC9756/57",	&sigmatel_9744_ops},
 	{0x83847666, "SigmaTel STAC9750T",	&sigmatel_9744_ops},
 	{0x83847684, "SigmaTel STAC9783/84?",	&null_ops},
diff -purN linux-2.6.11-rc2-bk10/sound/oss/au1000.c linux-2.6.11-rc3/sound/oss/au1000.c
--- linux-2.6.11-rc2-bk10/sound/oss/au1000.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/au1000.c	2005-02-03 02:56:11.000000000 +0100
@@ -59,6 +59,7 @@
 #include <linux/slab.h>
 #include <linux/soundcard.h>
 #include <linux/init.h>
+#include <linux/page-flags.h>
 #include <linux/poll.h>
 #include <linux/pci.h>
 #include <linux/bitops.h>
@@ -66,21 +67,18 @@
 #include <linux/spinlock.h>
 #include <linux/smp_lock.h>
 #include <linux/ac97_codec.h>
-#include <linux/wrapper.h>
 #include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
-#include <asm/au1000.h>
-#include <asm/au1000_dma.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1000_dma.h>
 
 /* --------------------------------------------------------------------- */
 
 #undef OSS_DOCUMENTED_MIXER_SEMANTICS
-#define AU1000_DEBUG
+#undef AU1000_DEBUG
 #undef AU1000_VERBOSE_DEBUG
 
-#define USE_COHERENT_DMA
-
 #define AU1000_MODULE_NAME "Au1000 audio"
 #define PFX AU1000_MODULE_NAME
 
@@ -116,7 +114,7 @@ struct au1000_state {
 	struct proc_dir_entry *ac97_ps;
 #endif				/* AU1000_DEBUG */
 
-	struct ac97_codec *codec;
+	struct ac97_codec codec;
 	unsigned        codec_base_caps;// AC'97 reg 00h, "Reset Register"
 	unsigned        codec_ext_caps;	// AC'97 reg 28h, "Extended Audio ID"
 	int             no_vra;	// do not use VRA
@@ -191,35 +189,6 @@ static inline unsigned ld2(unsigned int 
 	return r;
 }
 
-
-#ifdef USE_COHERENT_DMA
-static inline void * dma_alloc(size_t size, dma_addr_t * dma_handle)
-{
-	void* ret = (void *)__get_free_pages(GFP_ATOMIC | GFP_DMA,
-					     get_order(size));
-	if (ret != NULL) {
-		memset(ret, 0, size);
-		*dma_handle = virt_to_phys(ret);
-	}
-	return ret;
-}
-
-static inline void dma_free(size_t size, void* va, dma_addr_t dma_handle)
-{
-	free_pages((unsigned long)va, get_order(size));
-}
-#else
-static inline void * dma_alloc(size_t size, dma_addr_t * dma_handle)
-{
-	return pci_alloc_consistent(NULL, size, dma_handle);
-}
-
-static inline void dma_free(size_t size, void* va, dma_addr_t dma_handle)
-{
-	pci_free_consistent(NULL, size, va, dma_handle);
-}
-#endif
-
 /* --------------------------------------------------------------------- */
 
 static void au1000_delay(int msec)
@@ -356,17 +325,17 @@ static void set_adc_rate(struct au1000_s
 
 	adc->src_factor = 1;
 
-	ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+	ac97_extstat = rdcodec(&s->codec, AC97_EXTENDED_STATUS);
 
 	rate = rate > 48000 ? 48000 : rate;
 
 	// enable VRA
-	wrcodec(s->codec, AC97_EXTENDED_STATUS,
+	wrcodec(&s->codec, AC97_EXTENDED_STATUS,
 		ac97_extstat | AC97_EXTSTAT_VRA);
 	// now write the sample rate
-	wrcodec(s->codec, AC97_PCM_LR_ADC_RATE, (u16) rate);
+	wrcodec(&s->codec, AC97_PCM_LR_ADC_RATE, (u16) rate);
 	// read it back for actual supported rate
-	adc_rate = rdcodec(s->codec, AC97_PCM_LR_ADC_RATE);
+	adc_rate = rdcodec(&s->codec, AC97_PCM_LR_ADC_RATE);
 
 #ifdef AU1000_VERBOSE_DEBUG
 	dbg("%s: set to %d Hz", __FUNCTION__, adc_rate);
@@ -374,11 +343,11 @@ static void set_adc_rate(struct au1000_s
 
 	// some codec's don't allow unequal DAC and ADC rates, in which case
 	// writing one rate reg actually changes both.
-	dac_rate = rdcodec(s->codec, AC97_PCM_FRONT_DAC_RATE);
+	dac_rate = rdcodec(&s->codec, AC97_PCM_FRONT_DAC_RATE);
 	if (dac->num_channels > 2)
-		wrcodec(s->codec, AC97_PCM_SURR_DAC_RATE, dac_rate);
+		wrcodec(&s->codec, AC97_PCM_SURR_DAC_RATE, dac_rate);
 	if (dac->num_channels > 4)
-		wrcodec(s->codec, AC97_PCM_LFE_DAC_RATE, dac_rate);
+		wrcodec(&s->codec, AC97_PCM_LFE_DAC_RATE, dac_rate);
 
 	adc->sample_rate = adc_rate;
 	dac->sample_rate = dac_rate;
@@ -401,23 +370,23 @@ static void set_dac_rate(struct au1000_s
 
 	dac->src_factor = 1;
 
-	ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+	ac97_extstat = rdcodec(&s->codec, AC97_EXTENDED_STATUS);
 
 	rate = rate > 48000 ? 48000 : rate;
 
 	// enable VRA
-	wrcodec(s->codec, AC97_EXTENDED_STATUS,
+	wrcodec(&s->codec, AC97_EXTENDED_STATUS,
 		ac97_extstat | AC97_EXTSTAT_VRA);
 	// now write the sample rate
-	wrcodec(s->codec, AC97_PCM_FRONT_DAC_RATE, (u16) rate);
+	wrcodec(&s->codec, AC97_PCM_FRONT_DAC_RATE, (u16) rate);
 	// I don't support different sample rates for multichannel,
 	// so make these channels the same.
 	if (dac->num_channels > 2)
-		wrcodec(s->codec, AC97_PCM_SURR_DAC_RATE, (u16) rate);
+		wrcodec(&s->codec, AC97_PCM_SURR_DAC_RATE, (u16) rate);
 	if (dac->num_channels > 4)
-		wrcodec(s->codec, AC97_PCM_LFE_DAC_RATE, (u16) rate);
+		wrcodec(&s->codec, AC97_PCM_LFE_DAC_RATE, (u16) rate);
 	// read it back for actual supported rate
-	dac_rate = rdcodec(s->codec, AC97_PCM_FRONT_DAC_RATE);
+	dac_rate = rdcodec(&s->codec, AC97_PCM_FRONT_DAC_RATE);
 
 #ifdef AU1000_VERBOSE_DEBUG
 	dbg("%s: set to %d Hz", __FUNCTION__, dac_rate);
@@ -425,7 +394,7 @@ static void set_dac_rate(struct au1000_s
 
 	// some codec's don't allow unequal DAC and ADC rates, in which case
 	// writing one rate reg actually changes both.
-	adc_rate = rdcodec(s->codec, AC97_PCM_LR_ADC_RATE);
+	adc_rate = rdcodec(&s->codec, AC97_PCM_LR_ADC_RATE);
 
 	dac->sample_rate = dac_rate;
 	adc->sample_rate = adc_rate;
@@ -603,8 +572,11 @@ extern inline void dealloc_dmabuf(struct
 		pend = virt_to_page(db->rawbuf +
 				    (PAGE_SIZE << db->buforder) - 1);
 		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			mem_map_unreserve(page);
-		dma_free(PAGE_SIZE << db->buforder, db->rawbuf, db->dmaaddr);
+			ClearPageReserved(page);
+		dma_free_noncoherent(NULL,
+				PAGE_SIZE << db->buforder,
+				db->rawbuf,
+				db->dmaaddr);
 	}
 	db->rawbuf = db->nextIn = db->nextOut = NULL;
 	db->mapped = db->ready = 0;
@@ -622,8 +594,10 @@ static int prog_dmabuf(struct au1000_sta
 		db->ready = db->mapped = 0;
 		for (order = DMABUF_DEFAULTORDER;
 		     order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf = dma_alloc(PAGE_SIZE << order,
-						  &db->dmaaddr)))
+			if ((db->rawbuf = dma_alloc_noncoherent(NULL,
+						PAGE_SIZE << order,
+						&db->dmaaddr,
+						0)))
 				break;
 		if (!db->rawbuf)
 			return -ENOMEM;
@@ -633,7 +607,7 @@ static int prog_dmabuf(struct au1000_sta
 		pend = virt_to_page(db->rawbuf +
 				    (PAGE_SIZE << db->buforder) - 1);
 		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			mem_map_reserve(page);
+			SetPageReserved(page);
 	}
 
 	db->cnt_factor = 1;
@@ -708,7 +682,7 @@ extern inline int prog_dmabuf_dac(struct
 
 
 /* hold spinlock for the following */
-static void dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct au1000_state *s = (struct au1000_state *) dev_id;
 	struct dmabuf  *dac = &s->dma_dac;
@@ -723,7 +697,7 @@ static void dac_dma_interrupt(int irq, v
 
 	if ((buff_done = get_dma_buffer_done(dac->dmanr)) == 0) {
 		/* fastpath out, to ease interrupt sharing */
-		return;
+		return IRQ_HANDLED;
 	}
 
 	spin_lock(&s->lock);
@@ -786,10 +760,12 @@ static void dac_dma_interrupt(int irq, v
 		wake_up(&dac->wait);
 
 	spin_unlock(&s->lock);
+
+	return IRQ_HANDLED;
 }
 
 
-static void adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct au1000_state *s = (struct au1000_state *) dev_id;
 	struct dmabuf  *adc = &s->dma_adc;
@@ -804,7 +780,7 @@ static void adc_dma_interrupt(int irq, v
 
 	if ((buff_done = get_dma_buffer_done(adc->dmanr)) == 0) {
 		/* fastpath out, to ease interrupt sharing */
-		return;
+		return IRQ_HANDLED;
 	}
 
 	spin_lock(&s->lock);
@@ -816,7 +792,7 @@ static void adc_dma_interrupt(int irq, v
 			stop_adc(s);
 			adc->error++;
 			err("adc overrun");
-			return;
+			return IRQ_NONE;
 		}
 
 		adc->nextIn += adc->dma_fragsize;
@@ -853,7 +829,7 @@ static void adc_dma_interrupt(int irq, v
 			adc->error++;
 			err("adc overrun");
 			spin_unlock(&s->lock);
-			return;
+			return IRQ_NONE;
 		}
 
 		adc->nextIn += 2*adc->dma_fragsize;
@@ -873,6 +849,8 @@ static void adc_dma_interrupt(int irq, v
 		wake_up(&adc->wait);
 
 	spin_unlock(&s->lock);
+
+	return IRQ_HANDLED;
 }
 
 /* --------------------------------------------------------------------- */
@@ -904,7 +882,7 @@ static int au1000_ioctl_mixdev(struct in
 			       unsigned int cmd, unsigned long arg)
 {
 	struct au1000_state *s = (struct au1000_state *)file->private_data;
-	struct ac97_codec *codec = s->codec;
+	struct ac97_codec *codec = &s->codec;
 
 	return mixdev_ioctl(codec, cmd, arg);
 }
@@ -1338,8 +1316,7 @@ static int au1000_mmap(struct file *file
 		ret = -EINVAL;
 		goto out;
 	}
-	if (remap_pfn_range(vma->vm_start,
-			     virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
+	if (remap_pfn_range(vma, vma->vm_start, virt_to_phys(db->rawbuf),
 			     size, vma->vm_page_prot)) {
 		ret = -EAGAIN;
 		goto out;
@@ -1500,9 +1477,9 @@ static int au1000_ioctl(struct inode *in
 			s->dma_dac.num_channels = val ? 2 : 1;
 			if (s->codec_ext_caps & AC97_EXT_DACS) {
 				// disable surround and center/lfe in AC'97
-				u16 ext_stat = rdcodec(s->codec,
+				u16 ext_stat = rdcodec(&s->codec,
 						       AC97_EXTENDED_STATUS);
-				wrcodec(s->codec, AC97_EXTENDED_STATUS,
+				wrcodec(&s->codec, AC97_EXTENDED_STATUS,
 					ext_stat | (AC97_EXTSTAT_PRI |
 						    AC97_EXTSTAT_PRJ |
 						    AC97_EXTSTAT_PRK));
@@ -1552,9 +1529,9 @@ static int au1000_ioctl(struct inode *in
 					// disable surround and center/lfe
 					// channels in AC'97
 					u16             ext_stat =
-						rdcodec(s->codec,
+						rdcodec(&s->codec,
 							AC97_EXTENDED_STATUS);
-					wrcodec(s->codec,
+					wrcodec(&s->codec,
 						AC97_EXTENDED_STATUS,
 						ext_stat | (AC97_EXTSTAT_PRI |
 							    AC97_EXTSTAT_PRJ |
@@ -1563,14 +1540,14 @@ static int au1000_ioctl(struct inode *in
 					// enable surround, center/lfe
 					// channels in AC'97
 					u16             ext_stat =
-						rdcodec(s->codec,
+						rdcodec(&s->codec,
 							AC97_EXTENDED_STATUS);
 					ext_stat &= ~AC97_EXTSTAT_PRJ;
 					if (val == 6)
 						ext_stat &=
 							~(AC97_EXTSTAT_PRI |
 							  AC97_EXTSTAT_PRK);
-					wrcodec(s->codec,
+					wrcodec(&s->codec,
 						AC97_EXTENDED_STATUS,
 						ext_stat);
 				}
@@ -1832,7 +1809,7 @@ static int au1000_ioctl(struct inode *in
 		return -EINVAL;
 	}
 
-	return mixdev_ioctl(s->codec, cmd, arg);
+	return mixdev_ioctl(&s->codec, cmd, arg);
 }
 
 
@@ -1983,7 +1960,7 @@ static int proc_au1000_dump(char *buf, c
 	len += sprintf(buf + len, "----------------------\n");
 	for (cnt = 0; cnt <= 0x7e; cnt += 2)
 		len += sprintf(buf + len, "reg %02x = %04x\n",
-			       cnt, rdcodec(s->codec, cnt));
+			       cnt, rdcodec(&s->codec, cnt));
 
 	if (fpos >= len) {
 		*start = buf;
@@ -2010,7 +1987,9 @@ static int __devinit au1000_probe(void)
 {
 	struct au1000_state *s = &au1000_state;
 	int             val;
+#ifdef AU1000_DEBUG
 	char            proc_str[80];
+#endif
 
 	memset(s, 0, sizeof(struct au1000_state));
 
@@ -2019,23 +1998,16 @@ static int __devinit au1000_probe(void)
 	init_waitqueue_head(&s->open_wait);
 	init_MUTEX(&s->open_sem);
 	spin_lock_init(&s->lock);
-	
-	s->codec = ac97_alloc_codec();
-	if(s->codec == NULL)
-	{
-		error("Out of memory");
-		return -1;
-	}
-	s->codec->private_data = s;
-	s->codec->id = 0;
-	s->codec->codec_read = rdcodec;
-	s->codec->codec_write = wrcodec;
-	s->codec->codec_wait = waitcodec;
+	s->codec.private_data = s;
+	s->codec.id = 0;
+	s->codec.codec_read = rdcodec;
+	s->codec.codec_write = wrcodec;
+	s->codec.codec_wait = waitcodec;
 
-	if (!request_region(virt_to_phys((void *) AC97C_CONFIG),
+	if (!request_mem_region(CPHYSADDR(AC97C_CONFIG),
 			    0x14, AU1000_MODULE_NAME)) {
 		err("AC'97 ports in use");
-		goto err_codec;
+		return -1;
 	}
 	// Allocate the DMA Channels
 	if ((s->dma_dac.dmanr = request_au1000_dma(DMA_ID_AC97C_TX,
@@ -2057,25 +2029,17 @@ static int __devinit au1000_probe(void)
 	     s->dma_dac.dmanr, get_dma_done_irq(s->dma_dac.dmanr),
 	     s->dma_adc.dmanr, get_dma_done_irq(s->dma_adc.dmanr));
 
-#ifdef USE_COHERENT_DMA
 	// enable DMA coherency in read/write DMA channels
 	set_dma_mode(s->dma_dac.dmanr,
 		     get_dma_mode(s->dma_dac.dmanr) & ~DMA_NC);
 	set_dma_mode(s->dma_adc.dmanr,
 		     get_dma_mode(s->dma_adc.dmanr) & ~DMA_NC);
-#else
-	// disable DMA coherency in read/write DMA channels
-	set_dma_mode(s->dma_dac.dmanr,
-		     get_dma_mode(s->dma_dac.dmanr) | DMA_NC);
-	set_dma_mode(s->dma_adc.dmanr,
-		     get_dma_mode(s->dma_adc.dmanr) | DMA_NC);
-#endif
 
 	/* register devices */
 
 	if ((s->dev_audio = register_sound_dsp(&au1000_audio_fops, -1)) < 0)
 		goto err_dev1;
-	if ((s->codec->dev_mixer =
+	if ((s->codec.dev_mixer =
 	     register_sound_mixer(&au1000_mixer_fops, -1)) < 0)
 		goto err_dev2;
 
@@ -2108,11 +2072,11 @@ static int __devinit au1000_probe(void)
 	au_writel(0, AC97C_CONFIG);
 
 	/* codec init */
-	if (!ac97_probe_codec(s->codec))
+	if (!ac97_probe_codec(&s->codec))
 		goto err_dev3;
 
-	s->codec_base_caps = rdcodec(s->codec, AC97_RESET);
-	s->codec_ext_caps = rdcodec(s->codec, AC97_EXTENDED_ID);
+	s->codec_base_caps = rdcodec(&s->codec, AC97_RESET);
+	s->codec_ext_caps = rdcodec(&s->codec, AC97_EXTENDED_ID);
 	info("AC'97 Base/Extended ID = %04x/%04x",
 	     s->codec_base_caps, s->codec_ext_caps);
 
@@ -2124,12 +2088,12 @@ static int __devinit au1000_probe(void)
 	 * ALTPCM). ac97_codec.c does not handle detection
 	 * of this channel correctly.
 	 */
-	s->codec->supported_mixers |= SOUND_MASK_ALTPCM;
+	s->codec.supported_mixers |= SOUND_MASK_ALTPCM;
 	/*
 	 * Now set AUX_OUT's default volume.
 	 */
 	val = 0x4343;
-	mixdev_ioctl(s->codec, SOUND_MIXER_WRITE_ALTPCM,
+	mixdev_ioctl(&s->codec, SOUND_MIXER_WRITE_ALTPCM,
 		     (unsigned long) &val);
 	
 	if (!(s->codec_ext_caps & AC97_EXTID_VRA)) {
@@ -2137,8 +2101,8 @@ static int __devinit au1000_probe(void)
 		s->no_vra = 1;
 	} else if (!vra) {
 		// Boot option says disable VRA
-		u16 ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
-		wrcodec(s->codec, AC97_EXTENDED_STATUS,
+		u16 ac97_extstat = rdcodec(&s->codec, AC97_EXTENDED_STATUS);
+		wrcodec(&s->codec, AC97_EXTENDED_STATUS,
 			ac97_extstat & ~AC97_EXTSTAT_VRA);
 		s->no_vra = 1;
 	}
@@ -2147,20 +2111,38 @@ static int __devinit au1000_probe(void)
 
 	/* set mic to be the recording source */
 	val = SOUND_MASK_MIC;
-	mixdev_ioctl(s->codec, SOUND_MIXER_WRITE_RECSRC,
+	mixdev_ioctl(&s->codec, SOUND_MIXER_WRITE_RECSRC,
 		     (unsigned long) &val);
 
 #ifdef AU1000_DEBUG
 	sprintf(proc_str, "driver/%s/%d/ac97", AU1000_MODULE_NAME,
-		s->codec->id);
+		s->codec.id);
 	s->ac97_ps = create_proc_read_entry (proc_str, 0, NULL,
-					     ac97_read_proc, s->codec);
+					     ac97_read_proc, &s->codec);
+#endif
+
+#ifdef CONFIG_MIPS_XXS1500
+	/* deassert eapd */
+	wrcodec(&s->codec, AC97_POWER_CONTROL,
+			rdcodec(&s->codec, AC97_POWER_CONTROL) & ~0x8000);
+	/* mute a number of signals which seem to be causing problems
+	 * if not muted.
+	 */
+	wrcodec(&s->codec, AC97_PCBEEP_VOL, 0x8000);
+	wrcodec(&s->codec, AC97_PHONE_VOL, 0x8008);
+	wrcodec(&s->codec, AC97_MIC_VOL, 0x8008);
+	wrcodec(&s->codec, AC97_LINEIN_VOL, 0x8808);
+	wrcodec(&s->codec, AC97_CD_VOL, 0x8808);
+	wrcodec(&s->codec, AC97_VIDEO_VOL, 0x8808);
+	wrcodec(&s->codec, AC97_AUX_VOL, 0x8808);
+	wrcodec(&s->codec, AC97_PCMOUT_VOL, 0x0808);
+	wrcodec(&s->codec, AC97_GENERAL_PURPOSE, 0x2000);
 #endif
 
 	return 0;
 
  err_dev3:
-	unregister_sound_mixer(s->codec->dev_mixer);
+	unregister_sound_mixer(s->codec.dev_mixer);
  err_dev2:
 	unregister_sound_dsp(s->dev_audio);
  err_dev1:
@@ -2168,9 +2150,7 @@ static int __devinit au1000_probe(void)
  err_dma2:
 	free_au1000_dma(s->dma_dac.dmanr);
  err_dma1:
-	release_region(virt_to_phys((void *) AC97C_CONFIG), 0x14);
- err_codec:
- 	ac97_release_codec(s->codec);
+	release_mem_region(CPHYSADDR(AC97C_CONFIG), 0x14);
 	return -1;
 }
 
@@ -2187,10 +2167,9 @@ static void au1000_remove(void)
 	synchronize_irq();
 	free_au1000_dma(s->dma_adc.dmanr);
 	free_au1000_dma(s->dma_dac.dmanr);
-	release_region(virt_to_phys((void *) AC97C_CONFIG), 0x14);
+	release_mem_region(CPHYSADDR(AC97C_CONFIG), 0x14);
 	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->codec->dev_mixer);
-	ac97_release_codec(s->codec);
+	unregister_sound_mixer(s->codec.dev_mixer);
 }
 
 static int __init init_au1000(void)
@@ -2219,7 +2198,7 @@ static int __init au1000_setup(char *opt
 	if (!options || !*options)
 		return 0;
 
-	while (this_opt = strsep(&options, ",")) {
+	while ((this_opt = strsep(&options, ","))) {
 		if (!*this_opt)
 			continue;
 		if (!strncmp(this_opt, "vra", 3)) {
diff -purN linux-2.6.11-rc2-bk10/sound/oss/au1550_ac97.c linux-2.6.11-rc3/sound/oss/au1550_ac97.c
--- linux-2.6.11-rc2-bk10/sound/oss/au1550_ac97.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/au1550_ac97.c	2005-02-03 02:56:21.000000000 +0100
@@ -0,0 +1,2119 @@
+/*
+ * au1550_ac97.c  --  Sound driver for Alchemy Au1550 MIPS Internet Edge
+ *                    Processor.
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ *
+ * Mostly copied from the au1000.c driver and some from the
+ * PowerMac dbdma driver.
+ * We assume the processor can do memory coherent DMA.
+ *
+ * Ported to 2.6 by Matt Porter <mporter@kernel.crashing.org>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#undef DEBUG
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/sound.h>
+#include <linux/slab.h>
+#include <linux/soundcard.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <linux/bitops.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/ac97_codec.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/hardirq.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_psc.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+
+#undef OSS_DOCUMENTED_MIXER_SEMANTICS
+
+/* misc stuff */
+#define POLL_COUNT   0x50000
+#define AC97_EXT_DACS (AC97_EXTID_SDAC | AC97_EXTID_CDAC | AC97_EXTID_LDAC)
+
+/* The number of DBDMA ring descriptors to allocate.  No sense making
+ * this too large....if you can't keep up with a few you aren't likely
+ * to be able to with lots of them, either.
+ */
+#define NUM_DBDMA_DESCRIPTORS 4
+
+#define err(format, arg...) printk(KERN_ERR format "\n" , ## arg)
+
+/* Boot options
+ * 0 = no VRA, 1 = use VRA if codec supports it
+ */
+static int      vra = 1;
+MODULE_PARM(vra, "i");
+MODULE_PARM_DESC(vra, "if 1 use VRA if codec supports it");
+
+static struct au1550_state {
+	/* soundcore stuff */
+	int             dev_audio;
+
+	struct ac97_codec *codec;
+	unsigned        codec_base_caps; /* AC'97 reg 00h, "Reset Register" */
+	unsigned        codec_ext_caps;  /* AC'97 reg 28h, "Extended Audio ID" */
+	int             no_vra;		/* do not use VRA */
+
+	spinlock_t      lock;
+	struct semaphore open_sem;
+	struct semaphore sem;
+	mode_t          open_mode;
+	wait_queue_head_t open_wait;
+
+	struct dmabuf {
+		u32		dmanr;
+		unsigned        sample_rate;
+		unsigned	src_factor;
+		unsigned        sample_size;
+		int             num_channels;
+		int		dma_bytes_per_sample;
+		int		user_bytes_per_sample;
+		int		cnt_factor;
+
+		void		*rawbuf;
+		unsigned        buforder;
+		unsigned	numfrag;
+		unsigned        fragshift;
+		void		*nextIn;
+		void		*nextOut;
+		int		count;
+		unsigned        total_bytes;
+		unsigned        error;
+		wait_queue_head_t wait;
+
+		/* redundant, but makes calculations easier */
+		unsigned	fragsize;
+		unsigned	dma_fragsize;
+		unsigned	dmasize;
+		unsigned	dma_qcount;
+
+		/* OSS stuff */
+		unsigned        mapped:1;
+		unsigned        ready:1;
+		unsigned        stopped:1;
+		unsigned        ossfragshift;
+		int             ossmaxfrags;
+		unsigned        subdivision;
+	} dma_dac, dma_adc;
+} au1550_state;
+
+static unsigned
+ld2(unsigned int x)
+{
+	unsigned        r = 0;
+
+	if (x >= 0x10000) {
+		x >>= 16;
+		r += 16;
+	}
+	if (x >= 0x100) {
+		x >>= 8;
+		r += 8;
+	}
+	if (x >= 0x10) {
+		x >>= 4;
+		r += 4;
+	}
+	if (x >= 4) {
+		x >>= 2;
+		r += 2;
+	}
+	if (x >= 2)
+		r++;
+	return r;
+}
+
+static void
+au1550_delay(int msec)
+{
+	unsigned long   tmo;
+	signed long     tmo2;
+
+	if (in_interrupt())
+		return;
+
+	tmo = jiffies + (msec * HZ) / 1000;
+	for (;;) {
+		tmo2 = tmo - jiffies;
+		if (tmo2 <= 0)
+			break;
+		schedule_timeout(tmo2);
+	}
+}
+
+static u16
+rdcodec(struct ac97_codec *codec, u8 addr)
+{
+	struct au1550_state *s = (struct au1550_state *)codec->private_data;
+	unsigned long   flags;
+	u32             cmd, val;
+	u16             data;
+	int             i;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("rdcodec: codec cmd pending expired!");
+
+	cmd = (u32)PSC_AC97CDC_INDX(addr);
+	cmd |= PSC_AC97CDC_RD;	/* read command */
+	au_writel(cmd, PSC_AC97CDC);
+	au_sync();
+
+	/* now wait for the data
+	*/
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT) {
+		err("rdcodec: read poll expired!");
+		return 0;
+	}
+
+	/* wait for command done?
+	*/
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97EVNT);
+		au_sync();
+		if (val & PSC_AC97EVNT_CD)
+			break;
+	}
+	if (i == POLL_COUNT) {
+		err("rdcodec: read cmdwait expired!");
+		return 0;
+	}
+
+	data = au_readl(PSC_AC97CDC) & 0xffff;
+	au_sync();
+
+	/* Clear command done event.
+	*/
+	au_writel(PSC_AC97EVNT_CD, PSC_AC97EVNT);
+	au_sync();
+
+	spin_unlock_irqrestore(&s->lock, flags);
+
+	return data;
+}
+
+
+static void
+wrcodec(struct ac97_codec *codec, u8 addr, u16 data)
+{
+	struct au1550_state *s = (struct au1550_state *)codec->private_data;
+	unsigned long   flags;
+	u32             cmd, val;
+	int             i;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("wrcodec: codec cmd pending expired!");
+
+	cmd = (u32)PSC_AC97CDC_INDX(addr);
+	cmd |= (u32)data;
+	au_writel(cmd, PSC_AC97CDC);
+	au_sync();
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("wrcodec: codec cmd pending expired!");
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97EVNT);
+		au_sync();
+		if (val & PSC_AC97EVNT_CD)
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("wrcodec: read cmdwait expired!");
+
+	/* Clear command done event.
+	*/
+	au_writel(PSC_AC97EVNT_CD, PSC_AC97EVNT);
+	au_sync();
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+waitcodec(struct ac97_codec *codec)
+{
+	u16	temp;
+	u32	val;
+	int	i;
+
+	/* codec_wait is used to wait for a ready state after
+	 * an AC97C_RESET.
+	 */
+	au1550_delay(10);
+
+	/* first poll the CODEC_READY tag bit
+	*/
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (val & PSC_AC97STAT_CR)
+			break;
+	}
+	if (i == POLL_COUNT) {
+		err("waitcodec: CODEC_READY poll expired!");
+		return;
+	}
+
+	/* get AC'97 powerdown control/status register
+	*/
+	temp = rdcodec(codec, AC97_POWER_CONTROL);
+
+	/* If anything is powered down, power'em up
+	*/
+	if (temp & 0x7f00) {
+		/* Power on
+		*/
+		wrcodec(codec, AC97_POWER_CONTROL, 0);
+		au1550_delay(100);
+
+		/* Reread
+		*/
+		temp = rdcodec(codec, AC97_POWER_CONTROL);
+	}
+
+	/* Check if Codec REF,ANL,DAC,ADC ready
+	*/
+	if ((temp & 0x7f0f) != 0x000f)
+		err("codec reg 26 status (0x%x) not ready!!", temp);
+}
+
+/* stop the ADC before calling */
+static void
+set_adc_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *adc = &s->dma_adc;
+	struct dmabuf  *dac = &s->dma_dac;
+	unsigned        adc_rate, dac_rate;
+	u16             ac97_extstat;
+
+	if (s->no_vra) {
+		/* calc SRC factor
+		*/
+		adc->src_factor = ((96000 / rate) + 1) >> 1;
+		adc->sample_rate = 48000 / adc->src_factor;
+		return;
+	}
+
+	adc->src_factor = 1;
+
+	ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+
+	rate = rate > 48000 ? 48000 : rate;
+
+	/* enable VRA
+	*/
+	wrcodec(s->codec, AC97_EXTENDED_STATUS,
+		ac97_extstat | AC97_EXTSTAT_VRA);
+
+	/* now write the sample rate
+	*/
+	wrcodec(s->codec, AC97_PCM_LR_ADC_RATE, (u16) rate);
+
+	/* read it back for actual supported rate
+	*/
+	adc_rate = rdcodec(s->codec, AC97_PCM_LR_ADC_RATE);
+
+	pr_debug("set_adc_rate: set to %d Hz\n", adc_rate);
+
+	/* some codec's don't allow unequal DAC and ADC rates, in which case
+	 * writing one rate reg actually changes both.
+	 */
+	dac_rate = rdcodec(s->codec, AC97_PCM_FRONT_DAC_RATE);
+	if (dac->num_channels > 2)
+		wrcodec(s->codec, AC97_PCM_SURR_DAC_RATE, dac_rate);
+	if (dac->num_channels > 4)
+		wrcodec(s->codec, AC97_PCM_LFE_DAC_RATE, dac_rate);
+
+	adc->sample_rate = adc_rate;
+	dac->sample_rate = dac_rate;
+}
+
+/* stop the DAC before calling */
+static void
+set_dac_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *dac = &s->dma_dac;
+	struct dmabuf  *adc = &s->dma_adc;
+	unsigned        adc_rate, dac_rate;
+	u16             ac97_extstat;
+
+	if (s->no_vra) {
+		/* calc SRC factor
+		*/
+		dac->src_factor = ((96000 / rate) + 1) >> 1;
+		dac->sample_rate = 48000 / dac->src_factor;
+		return;
+	}
+
+	dac->src_factor = 1;
+
+	ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+
+	rate = rate > 48000 ? 48000 : rate;
+
+	/* enable VRA
+	*/
+	wrcodec(s->codec, AC97_EXTENDED_STATUS,
+		ac97_extstat | AC97_EXTSTAT_VRA);
+
+	/* now write the sample rate
+	*/
+	wrcodec(s->codec, AC97_PCM_FRONT_DAC_RATE, (u16) rate);
+
+	/* I don't support different sample rates for multichannel,
+	 * so make these channels the same.
+	 */
+	if (dac->num_channels > 2)
+		wrcodec(s->codec, AC97_PCM_SURR_DAC_RATE, (u16) rate);
+	if (dac->num_channels > 4)
+		wrcodec(s->codec, AC97_PCM_LFE_DAC_RATE, (u16) rate);
+	/* read it back for actual supported rate
+	*/
+	dac_rate = rdcodec(s->codec, AC97_PCM_FRONT_DAC_RATE);
+
+	pr_debug("set_dac_rate: set to %d Hz\n", dac_rate);
+
+	/* some codec's don't allow unequal DAC and ADC rates, in which case
+	 * writing one rate reg actually changes both.
+	 */
+	adc_rate = rdcodec(s->codec, AC97_PCM_LR_ADC_RATE);
+
+	dac->sample_rate = dac_rate;
+	adc->sample_rate = adc_rate;
+}
+
+static void
+stop_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	u32		stat;
+	unsigned long   flags;
+
+	if (db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	au_writel(PSC_AC97PCR_TP, PSC_AC97PCR);
+	au_sync();
+
+	/* Wait for Transmit Busy to show disabled.
+	*/
+	do {
+		stat = readl((void *)PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_TB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+stop_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	unsigned long   flags;
+	u32		stat;
+
+	if (db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	au_writel(PSC_AC97PCR_RP, PSC_AC97PCR);
+	au_sync();
+
+	/* Wait for Receive Busy to show disabled.
+	*/
+	do {
+		stat = readl((void *)PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_RB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+
+static void
+set_xmit_slots(int num_channels)
+{
+	u32	ac97_config, stat;
+
+	ac97_config = au_readl(PSC_AC97CFG);
+	au_sync();
+	ac97_config &= ~(PSC_AC97CFG_TXSLOT_MASK | PSC_AC97CFG_DE_ENABLE);
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	switch (num_channels) {
+	case 6:		/* stereo with surround and center/LFE,
+			 * slots 3,4,6,7,8,9
+			 */
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(6);
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(9);
+
+	case 4:		/* stereo with surround, slots 3,4,7,8 */
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(7);
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(8);
+
+	case 2:		/* stereo, slots 3,4 */
+	case 1:		/* mono */
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(3);
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(4);
+	}
+
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	ac97_config |= PSC_AC97CFG_DE_ENABLE;
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		stat = readl((void *)PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_DR) == 0);
+}
+
+static void
+set_recv_slots(int num_channels)
+{
+	u32	ac97_config, stat;
+
+	ac97_config = au_readl(PSC_AC97CFG);
+	au_sync();
+	ac97_config &= ~(PSC_AC97CFG_RXSLOT_MASK | PSC_AC97CFG_DE_ENABLE);
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	/* Always enable slots 3 and 4 (stereo). Slot 6 is
+	 * optional Mic ADC, which we don't support yet.
+	 */
+	ac97_config |= PSC_AC97CFG_RXSLOT_ENA(3);
+	ac97_config |= PSC_AC97CFG_RXSLOT_ENA(4);
+
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	ac97_config |= PSC_AC97CFG_DE_ENABLE;
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		stat = readl((void *)PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_DR) == 0);
+}
+
+static void
+start_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	unsigned long   flags;
+
+	if (!db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	set_xmit_slots(db->num_channels);
+	au_writel(PSC_AC97PCR_TC, PSC_AC97PCR);
+	au_sync();
+	au_writel(PSC_AC97PCR_TS, PSC_AC97PCR);
+	au_sync();
+
+	au1xxx_dbdma_start(db->dmanr);
+
+	db->stopped = 0;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+start_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	int	i;
+
+	if (!db->stopped)
+		return;
+
+	/* Put two buffers on the ring to get things started.
+	*/
+	for (i=0; i<2; i++) {
+		au1xxx_dbdma_put_dest(db->dmanr, db->nextIn, db->dma_fragsize);
+
+		db->nextIn += db->dma_fragsize;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+	}
+
+	set_recv_slots(db->num_channels);
+	au1xxx_dbdma_start(db->dmanr);
+	au_writel(PSC_AC97PCR_RC, PSC_AC97PCR);
+	au_sync();
+	au_writel(PSC_AC97PCR_RS, PSC_AC97PCR);
+	au_sync();
+
+	db->stopped = 0;
+}
+
+static int
+prog_dmabuf(struct au1550_state *s, struct dmabuf *db)
+{
+	unsigned user_bytes_per_sec;
+	unsigned        bufs;
+	unsigned        rate = db->sample_rate;
+
+	if (!db->rawbuf) {
+		db->ready = db->mapped = 0;
+		db->buforder = 5;	/* 32 * PAGE_SIZE */
+		db->rawbuf = kmalloc((PAGE_SIZE << db->buforder), GFP_KERNEL);
+		if (!db->rawbuf)
+			return -ENOMEM;
+	}
+
+	db->cnt_factor = 1;
+	if (db->sample_size == 8)
+		db->cnt_factor *= 2;
+	if (db->num_channels == 1)
+		db->cnt_factor *= 2;
+	db->cnt_factor *= db->src_factor;
+
+	db->count = 0;
+	db->dma_qcount = 0;
+	db->nextIn = db->nextOut = db->rawbuf;
+
+	db->user_bytes_per_sample = (db->sample_size>>3) * db->num_channels;
+	db->dma_bytes_per_sample = 2 * ((db->num_channels == 1) ?
+					2 : db->num_channels);
+
+	user_bytes_per_sec = rate * db->user_bytes_per_sample;
+	bufs = PAGE_SIZE << db->buforder;
+	if (db->ossfragshift) {
+		if ((1000 << db->ossfragshift) < user_bytes_per_sec)
+			db->fragshift = ld2(user_bytes_per_sec/1000);
+		else
+			db->fragshift = db->ossfragshift;
+	} else {
+		db->fragshift = ld2(user_bytes_per_sec / 100 /
+				    (db->subdivision ? db->subdivision : 1));
+		if (db->fragshift < 3)
+			db->fragshift = 3;
+	}
+
+	db->fragsize = 1 << db->fragshift;
+	db->dma_fragsize = db->fragsize * db->cnt_factor;
+	db->numfrag = bufs / db->dma_fragsize;
+
+	while (db->numfrag < 4 && db->fragshift > 3) {
+		db->fragshift--;
+		db->fragsize = 1 << db->fragshift;
+		db->dma_fragsize = db->fragsize * db->cnt_factor;
+		db->numfrag = bufs / db->dma_fragsize;
+	}
+
+	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
+		db->numfrag = db->ossmaxfrags;
+
+	db->dmasize = db->dma_fragsize * db->numfrag;
+	memset(db->rawbuf, 0, bufs);
+
+	pr_debug("prog_dmabuf: rate=%d, samplesize=%d, channels=%d\n",
+	    rate, db->sample_size, db->num_channels);
+	pr_debug("prog_dmabuf: fragsize=%d, cnt_factor=%d, dma_fragsize=%d\n",
+	    db->fragsize, db->cnt_factor, db->dma_fragsize);
+	pr_debug("prog_dmabuf: numfrag=%d, dmasize=%d\n", db->numfrag, db->dmasize);
+
+	db->ready = 1;
+	return 0;
+}
+
+static int
+prog_dmabuf_adc(struct au1550_state *s)
+{
+	stop_adc(s);
+	return prog_dmabuf(s, &s->dma_adc);
+
+}
+
+static int
+prog_dmabuf_dac(struct au1550_state *s)
+{
+	stop_dac(s);
+	return prog_dmabuf(s, &s->dma_dac);
+}
+
+
+/* hold spinlock for the following */
+static void
+dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct au1550_state *s = (struct au1550_state *) dev_id;
+	struct dmabuf  *db = &s->dma_dac;
+	u32	ac97c_stat;
+
+	ac97c_stat = au_readl(PSC_AC97STAT);
+	if (ac97c_stat & (AC97C_XU | AC97C_XO | AC97C_TE))
+		pr_debug("AC97C status = 0x%08x\n", ac97c_stat);
+	db->dma_qcount--;
+
+	if (db->count >= db->fragsize) {
+		if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+			err("qcount < 2 and no ring room!");
+		}
+		db->nextOut += db->fragsize;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		db->count -= db->fragsize;
+		db->total_bytes += db->dma_fragsize;
+		db->dma_qcount++;
+	}
+
+	/* wake up anybody listening */
+	if (waitqueue_active(&db->wait))
+		wake_up(&db->wait);
+}
+
+
+static void
+adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct	au1550_state *s = (struct au1550_state *)dev_id;
+	struct	dmabuf  *dp = &s->dma_adc;
+	u32	obytes;
+	char	*obuf;
+
+	/* Pull the buffer from the dma queue.
+	*/
+	au1xxx_dbdma_get_dest(dp->dmanr, (void *)(&obuf), &obytes);
+
+	if ((dp->count + obytes) > dp->dmasize) {
+		/* Overrun. Stop ADC and log the error
+		*/
+		stop_adc(s);
+		dp->error++;
+		err("adc overrun");
+		return;
+	}
+
+	/* Put a new empty buffer on the destination DMA.
+	*/
+	au1xxx_dbdma_put_dest(dp->dmanr, dp->nextIn, dp->dma_fragsize);
+
+	dp->nextIn += dp->dma_fragsize;
+	if (dp->nextIn >= dp->rawbuf + dp->dmasize)
+		dp->nextIn -= dp->dmasize;
+
+	dp->count += obytes;
+	dp->total_bytes += obytes;
+
+	/* wake up anybody listening
+	*/
+	if (waitqueue_active(&dp->wait))
+		wake_up(&dp->wait);
+
+}
+
+static loff_t
+au1550_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+
+static int
+au1550_open_mixdev(struct inode *inode, struct file *file)
+{
+	file->private_data = &au1550_state;
+	return 0;
+}
+
+static int
+au1550_release_mixdev(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int
+mixdev_ioctl(struct ac97_codec *codec, unsigned int cmd,
+                        unsigned long arg)
+{
+	return codec->mixer_ioctl(codec, cmd, arg);
+}
+
+static int
+au1550_ioctl_mixdev(struct inode *inode, struct file *file,
+			       unsigned int cmd, unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct ac97_codec *codec = s->codec;
+
+	return mixdev_ioctl(codec, cmd, arg);
+}
+
+static /*const */ struct file_operations au1550_mixer_fops = {
+	owner:THIS_MODULE,
+	llseek:au1550_llseek,
+	ioctl:au1550_ioctl_mixdev,
+	open:au1550_open_mixdev,
+	release:au1550_release_mixdev,
+};
+
+static int
+drain_dac(struct au1550_state *s, int nonblock)
+{
+	unsigned long   flags;
+	int             count, tmo;
+
+	if (s->dma_dac.mapped || !s->dma_dac.ready || s->dma_dac.stopped)
+		return 0;
+
+	for (;;) {
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count <= s->dma_dac.fragsize)
+			break;
+		if (signal_pending(current))
+			break;
+		if (nonblock)
+			return -EBUSY;
+		tmo = 1000 * count / (s->no_vra ?
+				      48000 : s->dma_dac.sample_rate);
+		tmo /= s->dma_dac.dma_bytes_per_sample;
+		au1550_delay(tmo);
+	}
+	if (signal_pending(current))
+		return -ERESTARTSYS;
+	return 0;
+}
+
+static inline u8 S16_TO_U8(s16 ch)
+{
+	return (u8) (ch >> 8) + 0x80;
+}
+static inline s16 U8_TO_S16(u8 ch)
+{
+	return (s16) (ch - 0x80) << 8;
+}
+
+/*
+ * Translates user samples to dma buffer suitable for AC'97 DAC data:
+ *     If mono, copy left channel to right channel in dma buffer.
+ *     If 8 bit samples, cvt to 16-bit before writing to dma buffer.
+ *     If interpolating (no VRA), duplicate every audio frame src_factor times.
+ */
+static int
+translate_from_user(struct dmabuf *db, char* dmabuf, char* userbuf,
+							       int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+	s16             ch, dmasample[6];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_from_user(dmabuf, userbuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		if (copy_from_user(usersample, userbuf,
+				   db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				ch = U8_TO_S16(usersample[i]);
+			else
+				ch = *((s16 *) (&usersample[i * 2]));
+			dmasample[i] = ch;
+			if (mono)
+				dmasample[i + 1] = ch;	/* right channel */
+		}
+
+		/* duplicate every audio frame src_factor times
+		*/
+		for (i = 0; i < db->src_factor; i++)
+			memcpy(dmabuf, dmasample, db->dma_bytes_per_sample);
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Translates AC'97 ADC samples to user buffer:
+ *     If mono, send only left channel to user buffer.
+ *     If 8 bit samples, cvt from 16 to 8 bit before writing to user buffer.
+ *     If decimating (no VRA), skip over src_factor audio frames.
+ */
+static int
+translate_to_user(struct dmabuf *db, char* userbuf, char* dmabuf,
+							     int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_to_user(userbuf, dmabuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				usersample[i] =
+					S16_TO_U8(*((s16 *) (&dmabuf[i * 2])));
+			else
+				*((s16 *) (&usersample[i * 2])) =
+					*((s16 *) (&dmabuf[i * 2]));
+		}
+
+		if (copy_to_user(userbuf, usersample,
+				 db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Copy audio data to/from user buffer from/to dma buffer, taking care
+ * that we wrap when reading/writing the dma buffer. Returns actual byte
+ * count written to or read from the dma buffer.
+ */
+static int
+copy_dmabuf_user(struct dmabuf *db, char* userbuf, int count, int to_user)
+{
+	char           *bufptr = to_user ? db->nextOut : db->nextIn;
+	char           *bufend = db->rawbuf + db->dmasize;
+	int             cnt, ret;
+
+	if (bufptr + count > bufend) {
+		int             partial = (int) (bufend - bufptr);
+		if (to_user) {
+			if ((cnt = translate_to_user(db, userbuf,
+						     bufptr, partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_to_user(db, userbuf + partial,
+						     db->rawbuf,
+						     count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		} else {
+			if ((cnt = translate_from_user(db, bufptr, userbuf,
+						       partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_from_user(db, db->rawbuf,
+						       userbuf + partial,
+						       count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		}
+	} else {
+		if (to_user)
+			ret = translate_to_user(db, userbuf, bufptr, count);
+		else
+			ret = translate_from_user(db, bufptr, userbuf, count);
+	}
+
+	return ret;
+}
+
+
+static ssize_t
+au1550_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_adc;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+	ret = 0;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for samples in ADC dma buffer
+		*/
+		do {
+			if (db->stopped)
+				start_adc(s);
+			spin_lock_irqsave(&s->lock, flags);
+			avail = db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from nextOut to user
+		*/
+		if ((cnt = copy_dmabuf_user(db, buffer,
+					    count > avail ?
+					    avail : count, 1)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count -= cnt;
+		db->nextOut += cnt;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+static ssize_t
+au1550_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_dac;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret = 0;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+	pr_debug("write: count=%d\n", count);
+
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_READ, buffer, count))
+		return -EFAULT;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for space in playback buffer
+		*/
+		do {
+			spin_lock_irqsave(&s->lock, flags);
+			avail = (int) db->dmasize - db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from user to nextIn
+		*/
+		if ((cnt = copy_dmabuf_user(db, (char *) buffer,
+					    count > avail ?
+					    avail : count, 0)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count += cnt;
+		db->nextIn += cnt;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+
+		/* If the data is available, we want to keep two buffers
+		 * on the dma queue.  If the queue count reaches zero,
+		 * we know the dma has stopped.
+		 */
+		while ((db->dma_qcount < 2) && (db->count >= db->fragsize)) {
+			if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+				err("qcount < 2 and no ring room!");
+			}
+			db->nextOut += db->fragsize;
+			if (db->nextOut >= db->rawbuf + db->dmasize)
+				db->nextOut -= db->dmasize;
+			db->total_bytes += db->dma_fragsize;
+			if (db->dma_qcount == 0)
+				start_dac(s);
+			db->dma_qcount++;
+		}
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+
+/* No kernel lock - we have our own spinlock */
+static unsigned int
+au1550_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	unsigned int    mask = 0;
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!s->dma_dac.ready)
+			return 0;
+		poll_wait(file, &s->dma_dac.wait, wait);
+	}
+	if (file->f_mode & FMODE_READ) {
+		if (!s->dma_adc.ready)
+			return 0;
+		poll_wait(file, &s->dma_adc.wait, wait);
+	}
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	if (file->f_mode & FMODE_READ) {
+		if (s->dma_adc.count >= (signed)s->dma_adc.dma_fragsize)
+			mask |= POLLIN | POLLRDNORM;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if (s->dma_dac.mapped) {
+			if (s->dma_dac.count >=
+			    (signed)s->dma_dac.dma_fragsize)
+				mask |= POLLOUT | POLLWRNORM;
+		} else {
+			if ((signed) s->dma_dac.dmasize >=
+			    s->dma_dac.count + (signed)s->dma_dac.dma_fragsize)
+				mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+	spin_unlock_irqrestore(&s->lock, flags);
+	return mask;
+}
+
+static int
+au1550_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db;
+	unsigned long   size;
+	int ret = 0;
+
+	lock_kernel();
+	down(&s->sem);
+	if (vma->vm_flags & VM_WRITE)
+		db = &s->dma_dac;
+	else if (vma->vm_flags & VM_READ)
+		db = &s->dma_adc;
+	else {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (vma->vm_pgoff != 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+	size = vma->vm_end - vma->vm_start;
+	if (size > (PAGE_SIZE << db->buforder)) {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (remap_pfn_range(vma, vma->vm_start, page_to_pfn(virt_to_page(db->rawbuf)),
+			     size, vma->vm_page_prot)) {
+		ret = -EAGAIN;
+		goto out;
+	}
+	vma->vm_flags &= ~VM_IO;
+	db->mapped = 1;
+out:
+	up(&s->sem);
+	unlock_kernel();
+	return ret;
+}
+
+#ifdef DEBUG
+static struct ioctl_str_t {
+	unsigned int    cmd;
+	const char     *str;
+} ioctl_str[] = {
+	{SNDCTL_DSP_RESET, "SNDCTL_DSP_RESET"},
+	{SNDCTL_DSP_SYNC, "SNDCTL_DSP_SYNC"},
+	{SNDCTL_DSP_SPEED, "SNDCTL_DSP_SPEED"},
+	{SNDCTL_DSP_STEREO, "SNDCTL_DSP_STEREO"},
+	{SNDCTL_DSP_GETBLKSIZE, "SNDCTL_DSP_GETBLKSIZE"},
+	{SNDCTL_DSP_SAMPLESIZE, "SNDCTL_DSP_SAMPLESIZE"},
+	{SNDCTL_DSP_CHANNELS, "SNDCTL_DSP_CHANNELS"},
+	{SOUND_PCM_WRITE_CHANNELS, "SOUND_PCM_WRITE_CHANNELS"},
+	{SOUND_PCM_WRITE_FILTER, "SOUND_PCM_WRITE_FILTER"},
+	{SNDCTL_DSP_POST, "SNDCTL_DSP_POST"},
+	{SNDCTL_DSP_SUBDIVIDE, "SNDCTL_DSP_SUBDIVIDE"},
+	{SNDCTL_DSP_SETFRAGMENT, "SNDCTL_DSP_SETFRAGMENT"},
+	{SNDCTL_DSP_GETFMTS, "SNDCTL_DSP_GETFMTS"},
+	{SNDCTL_DSP_SETFMT, "SNDCTL_DSP_SETFMT"},
+	{SNDCTL_DSP_GETOSPACE, "SNDCTL_DSP_GETOSPACE"},
+	{SNDCTL_DSP_GETISPACE, "SNDCTL_DSP_GETISPACE"},
+	{SNDCTL_DSP_NONBLOCK, "SNDCTL_DSP_NONBLOCK"},
+	{SNDCTL_DSP_GETCAPS, "SNDCTL_DSP_GETCAPS"},
+	{SNDCTL_DSP_GETTRIGGER, "SNDCTL_DSP_GETTRIGGER"},
+	{SNDCTL_DSP_SETTRIGGER, "SNDCTL_DSP_SETTRIGGER"},
+	{SNDCTL_DSP_GETIPTR, "SNDCTL_DSP_GETIPTR"},
+	{SNDCTL_DSP_GETOPTR, "SNDCTL_DSP_GETOPTR"},
+	{SNDCTL_DSP_MAPINBUF, "SNDCTL_DSP_MAPINBUF"},
+	{SNDCTL_DSP_MAPOUTBUF, "SNDCTL_DSP_MAPOUTBUF"},
+	{SNDCTL_DSP_SETSYNCRO, "SNDCTL_DSP_SETSYNCRO"},
+	{SNDCTL_DSP_SETDUPLEX, "SNDCTL_DSP_SETDUPLEX"},
+	{SNDCTL_DSP_GETODELAY, "SNDCTL_DSP_GETODELAY"},
+	{SNDCTL_DSP_GETCHANNELMASK, "SNDCTL_DSP_GETCHANNELMASK"},
+	{SNDCTL_DSP_BIND_CHANNEL, "SNDCTL_DSP_BIND_CHANNEL"},
+	{OSS_GETVERSION, "OSS_GETVERSION"},
+	{SOUND_PCM_READ_RATE, "SOUND_PCM_READ_RATE"},
+	{SOUND_PCM_READ_CHANNELS, "SOUND_PCM_READ_CHANNELS"},
+	{SOUND_PCM_READ_BITS, "SOUND_PCM_READ_BITS"},
+	{SOUND_PCM_READ_FILTER, "SOUND_PCM_READ_FILTER"}
+};
+#endif
+
+static int
+dma_count_done(struct dmabuf *db)
+{
+	if (db->stopped)
+		return 0;
+
+	return db->dma_fragsize - au1xxx_get_dma_residue(db->dmanr);
+}
+
+
+static int
+au1550_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	audio_buf_info  abinfo;
+	count_info      cinfo;
+	int             count;
+	int             val, mapped, ret, diff;
+
+	mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
+		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
+
+#ifdef DEBUG
+	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
+		if (ioctl_str[count].cmd == cmd)
+			break;
+	}
+	if (count < sizeof(ioctl_str) / sizeof(ioctl_str[0]))
+		pr_debug("ioctl %s, arg=0x%lxn", ioctl_str[count].str, arg);
+	else
+		pr_debug("ioctl 0x%x unknown, arg=0x%lx\n", cmd, arg);
+#endif
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *) arg);
+
+	case SNDCTL_DSP_SYNC:
+		if (file->f_mode & FMODE_WRITE)
+			return drain_dac(s, file->f_flags & O_NONBLOCK);
+		return 0;
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return 0;
+
+	case SNDCTL_DSP_GETCAPS:
+		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
+				DSP_CAP_TRIGGER | DSP_CAP_MMAP, (int *)arg);
+
+	case SNDCTL_DSP_RESET:
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			synchronize_irq();
+			s->dma_dac.count = s->dma_dac.total_bytes = 0;
+			s->dma_dac.nextIn = s->dma_dac.nextOut =
+				s->dma_dac.rawbuf;
+		}
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			synchronize_irq();
+			s->dma_adc.count = s->dma_adc.total_bytes = 0;
+			s->dma_adc.nextIn = s->dma_adc.nextOut =
+				s->dma_adc.rawbuf;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val >= 0) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				set_adc_rate(s, val);
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				set_dac_rate(s, val);
+			}
+			if (s->open_mode & FMODE_READ)
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			if (s->open_mode & FMODE_WRITE)
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+		}
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SNDCTL_DSP_STEREO:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.num_channels = val ? 2 : 1;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.num_channels = val ? 2 : 1;
+			if (s->codec_ext_caps & AC97_EXT_DACS) {
+				/* disable surround and center/lfe in AC'97
+				*/
+				u16 ext_stat = rdcodec(s->codec,
+						       AC97_EXTENDED_STATUS);
+				wrcodec(s->codec, AC97_EXTENDED_STATUS,
+					ext_stat | (AC97_EXTSTAT_PRI |
+						    AC97_EXTSTAT_PRJ |
+						    AC97_EXTSTAT_PRK));
+			}
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_CHANNELS:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 0) {
+			if (file->f_mode & FMODE_READ) {
+				if (val < 0 || val > 2)
+					return -EINVAL;
+				stop_adc(s);
+				s->dma_adc.num_channels = val;
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				switch (val) {
+				case 1:
+				case 2:
+					break;
+				case 3:
+				case 5:
+					return -EINVAL;
+				case 4:
+					if (!(s->codec_ext_caps &
+					      AC97_EXTID_SDAC))
+						return -EINVAL;
+					break;
+				case 6:
+					if ((s->codec_ext_caps &
+					     AC97_EXT_DACS) != AC97_EXT_DACS)
+						return -EINVAL;
+					break;
+				default:
+					return -EINVAL;
+				}
+
+				stop_dac(s);
+				if (val <= 2 &&
+				    (s->codec_ext_caps & AC97_EXT_DACS)) {
+					/* disable surround and center/lfe
+					 * channels in AC'97
+					 */
+					u16             ext_stat =
+						rdcodec(s->codec,
+							AC97_EXTENDED_STATUS);
+					wrcodec(s->codec,
+						AC97_EXTENDED_STATUS,
+						ext_stat | (AC97_EXTSTAT_PRI |
+							    AC97_EXTSTAT_PRJ |
+							    AC97_EXTSTAT_PRK));
+				} else if (val >= 4) {
+					/* enable surround, center/lfe
+					 * channels in AC'97
+					 */
+					u16             ext_stat =
+						rdcodec(s->codec,
+							AC97_EXTENDED_STATUS);
+					ext_stat &= ~AC97_EXTSTAT_PRJ;
+					if (val == 6)
+						ext_stat &=
+							~(AC97_EXTSTAT_PRI |
+							  AC97_EXTSTAT_PRK);
+					wrcodec(s->codec,
+						AC97_EXTENDED_STATUS,
+						ext_stat);
+				}
+
+				s->dma_dac.num_channels = val;
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_GETFMTS:	/* Returns a mask */
+		return put_user(AFMT_S16_LE | AFMT_U8, (int *) arg);
+
+	case SNDCTL_DSP_SETFMT:	/* Selects ONE fmt */
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != AFMT_QUERY) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				if (val == AFMT_S16_LE)
+					s->dma_adc.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_adc.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				if (val == AFMT_S16_LE)
+					s->dma_dac.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_dac.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		} else {
+			if (file->f_mode & FMODE_READ)
+				val = (s->dma_adc.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+			else
+				val = (s->dma_dac.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_POST:
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = 0;
+		spin_lock_irqsave(&s->lock, flags);
+		if (file->f_mode & FMODE_READ && !s->dma_adc.stopped)
+			val |= PCM_ENABLE_INPUT;
+		if (file->f_mode & FMODE_WRITE && !s->dma_dac.stopped)
+			val |= PCM_ENABLE_OUTPUT;
+		spin_unlock_irqrestore(&s->lock, flags);
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			if (val & PCM_ENABLE_INPUT)
+				start_adc(s);
+			else
+				stop_adc(s);
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			if (val & PCM_ENABLE_OUTPUT)
+				start_dac(s);
+			else
+				stop_dac(s);
+		}
+		return 0;
+
+	case SNDCTL_DSP_GETOSPACE:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_dac.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = (s->dma_dac.dmasize - count) /
+			s->dma_dac.cnt_factor;
+		abinfo.fragstotal = s->dma_dac.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
+		pr_debug("ioctl SNDCTL_DSP_GETOSPACE: bytes=%d, fragments=%d\n", abinfo.bytes, abinfo.fragments);
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_GETISPACE:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_adc.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_adc.count;
+		count += dma_count_done(&s->dma_adc);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = count / s->dma_adc.cnt_factor;
+		abinfo.fragstotal = s->dma_adc.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		return 0;
+
+	case SNDCTL_DSP_GETODELAY:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		count /= s->dma_dac.cnt_factor;
+		return put_user(count, (int *) arg);
+
+	case SNDCTL_DSP_GETIPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_adc.total_bytes;
+		count = s->dma_adc.count;
+		if (!s->dma_adc.stopped) {
+			diff = dma_count_done(&s->dma_adc);
+			count += diff;
+			cinfo.bytes += diff;
+			cinfo.ptr =  virt_to_phys(s->dma_adc.nextIn) + diff -
+				virt_to_phys(s->dma_adc.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_adc.nextIn) -
+				virt_to_phys(s->dma_adc.rawbuf);
+		if (s->dma_adc.mapped)
+			s->dma_adc.count &= (s->dma_adc.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETOPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_dac.total_bytes;
+		count = s->dma_dac.count;
+		if (!s->dma_dac.stopped) {
+			diff = dma_count_done(&s->dma_dac);
+			count -= diff;
+			cinfo.bytes += diff;
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) + diff -
+				virt_to_phys(s->dma_dac.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) -
+				virt_to_phys(s->dma_dac.rawbuf);
+		if (s->dma_dac.mapped)
+			s->dma_dac.count &= (s->dma_dac.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_dac.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		if (file->f_mode & FMODE_WRITE)
+			return put_user(s->dma_dac.fragsize, (int *) arg);
+		else
+			return put_user(s->dma_adc.fragsize, (int *) arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.ossfragshift = val & 0xffff;
+			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_adc.ossfragshift < 4)
+				s->dma_adc.ossfragshift = 4;
+			if (s->dma_adc.ossfragshift > 15)
+				s->dma_adc.ossfragshift = 15;
+			if (s->dma_adc.ossmaxfrags < 4)
+				s->dma_adc.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.ossfragshift = val & 0xffff;
+			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_dac.ossfragshift < 4)
+				s->dma_dac.ossfragshift = 4;
+			if (s->dma_dac.ossfragshift > 15)
+				s->dma_dac.ossfragshift = 15;
+			if (s->dma_dac.ossmaxfrags < 4)
+				s->dma_dac.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SUBDIVIDE:
+		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
+		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
+			return -EINVAL;
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 1 && val != 2 && val != 4)
+			return -EINVAL;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.subdivision = val;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.subdivision = val;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SOUND_PCM_READ_RATE:
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SOUND_PCM_READ_CHANNELS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.num_channels, (int *)arg);
+		else
+			return put_user(s->dma_dac.num_channels, (int *)arg);
+
+	case SOUND_PCM_READ_BITS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.sample_size, (int *)arg);
+		else
+			return put_user(s->dma_dac.sample_size, (int *)arg);
+
+	case SOUND_PCM_WRITE_FILTER:
+	case SNDCTL_DSP_SETSYNCRO:
+	case SOUND_PCM_READ_FILTER:
+		return -EINVAL;
+	}
+
+	return mixdev_ioctl(s->codec, cmd, arg);
+}
+
+
+static int
+au1550_open(struct inode *inode, struct file *file)
+{
+	int             minor = MINOR(inode->i_rdev);
+	DECLARE_WAITQUEUE(wait, current);
+	struct au1550_state *s = &au1550_state;
+	int             ret;
+
+#ifdef DEBUG
+	if (file->f_flags & O_NONBLOCK)
+		pr_debug("open: non-blocking\n");
+	else
+		pr_debug("open: blocking\n");
+#endif
+
+	file->private_data = s;
+	/* wait for device to become free */
+	down(&s->open_sem);
+	while (s->open_mode & file->f_mode) {
+		if (file->f_flags & O_NONBLOCK) {
+			up(&s->open_sem);
+			return -EBUSY;
+		}
+		add_wait_queue(&s->open_wait, &wait);
+		__set_current_state(TASK_INTERRUPTIBLE);
+		up(&s->open_sem);
+		schedule();
+		remove_wait_queue(&s->open_wait, &wait);
+		set_current_state(TASK_RUNNING);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+		down(&s->open_sem);
+	}
+
+	stop_dac(s);
+	stop_adc(s);
+
+	if (file->f_mode & FMODE_READ) {
+		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
+			s->dma_adc.subdivision = s->dma_adc.total_bytes = 0;
+		s->dma_adc.num_channels = 1;
+		s->dma_adc.sample_size = 8;
+		set_adc_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_adc.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
+			s->dma_dac.subdivision = s->dma_dac.total_bytes = 0;
+		s->dma_dac.num_channels = 1;
+		s->dma_dac.sample_size = 8;
+		set_dac_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_dac.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		if ((ret = prog_dmabuf_adc(s)))
+			return ret;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if ((ret = prog_dmabuf_dac(s)))
+			return ret;
+	}
+
+	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
+	up(&s->open_sem);
+	init_MUTEX(&s->sem);
+	return 0;
+}
+
+static int
+au1550_release(struct inode *inode, struct file *file)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+
+	lock_kernel();
+
+	if (file->f_mode & FMODE_WRITE) {
+		unlock_kernel();
+		drain_dac(s, file->f_flags & O_NONBLOCK);
+		lock_kernel();
+	}
+
+	down(&s->open_sem);
+	if (file->f_mode & FMODE_WRITE) {
+		stop_dac(s);
+		kfree(s->dma_dac.rawbuf);
+		s->dma_dac.rawbuf = NULL;
+	}
+	if (file->f_mode & FMODE_READ) {
+		stop_adc(s);
+		kfree(s->dma_adc.rawbuf);
+		s->dma_adc.rawbuf = NULL;
+	}
+	s->open_mode &= ((~file->f_mode) & (FMODE_READ|FMODE_WRITE));
+	up(&s->open_sem);
+	wake_up(&s->open_wait);
+	unlock_kernel();
+	return 0;
+}
+
+static /*const */ struct file_operations au1550_audio_fops = {
+	owner:		THIS_MODULE,
+	llseek:		au1550_llseek,
+	read:		au1550_read,
+	write:		au1550_write,
+	poll:		au1550_poll,
+	ioctl:		au1550_ioctl,
+	mmap:		au1550_mmap,
+	open:		au1550_open,
+	release:	au1550_release,
+};
+
+MODULE_AUTHOR("Advanced Micro Devices (AMD), dan@embeddededge.com");
+MODULE_DESCRIPTION("Au1550 AC97 Audio Driver");
+
+static int __devinit
+au1550_probe(void)
+{
+	struct au1550_state *s = &au1550_state;
+	int             val;
+
+	memset(s, 0, sizeof(struct au1550_state));
+
+	init_waitqueue_head(&s->dma_adc.wait);
+	init_waitqueue_head(&s->dma_dac.wait);
+	init_waitqueue_head(&s->open_wait);
+	init_MUTEX(&s->open_sem);
+	spin_lock_init(&s->lock);
+
+	s->codec = ac97_alloc_codec();
+	if(s->codec == NULL) {
+		err("Out of memory");
+		return -1;
+	}
+	s->codec->private_data = s;
+	s->codec->id = 0;
+	s->codec->codec_read = rdcodec;
+	s->codec->codec_write = wrcodec;
+	s->codec->codec_wait = waitcodec;
+
+	if (!request_mem_region(CPHYSADDR(AC97_PSC_SEL),
+			    0x30, "Au1550 AC97")) {
+		err("AC'97 ports in use");
+	}
+
+	/* Allocate the DMA Channels
+	*/
+	if ((s->dma_dac.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_MEM_CHAN,
+	    DBDMA_AC97_TX_CHAN, dac_dma_interrupt, (void *)s)) == 0) {
+		err("Can't get DAC DMA");
+		goto err_dma1;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_dac.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_dac.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		err("Can't get DAC DMA descriptors");
+		goto err_dma1;
+	}
+
+	if ((s->dma_adc.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_AC97_RX_CHAN,
+	    DBDMA_MEM_CHAN, adc_dma_interrupt, (void *)s)) == 0) {
+		err("Can't get ADC DMA");
+		goto err_dma2;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_adc.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_adc.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		err("Can't get ADC DMA descriptors");
+		goto err_dma2;
+	}
+
+	pr_info("DAC: DMA%d, ADC: DMA%d", DBDMA_AC97_TX_CHAN, DBDMA_AC97_RX_CHAN);
+
+	/* register devices */
+
+	if ((s->dev_audio = register_sound_dsp(&au1550_audio_fops, -1)) < 0)
+		goto err_dev1;
+	if ((s->codec->dev_mixer =
+	     register_sound_mixer(&au1550_mixer_fops, -1)) < 0)
+		goto err_dev2;
+
+	/* The GPIO for the appropriate PSC was configured by the
+	 * board specific start up.
+	 *
+	 * configure PSC for AC'97
+	 */
+	au_writel(0, AC97_PSC_CTRL);	/* Disable PSC */
+	au_sync();
+	au_writel((PSC_SEL_CLK_SERCLK | PSC_SEL_PS_AC97MODE), AC97_PSC_SEL);
+	au_sync();
+
+	/* cold reset the AC'97
+	*/
+	au_writel(PSC_AC97RST_RST, PSC_AC97RST);
+	au_sync();
+	au1550_delay(10);
+	au_writel(0, PSC_AC97RST);
+	au_sync();
+
+	/* need to delay around 500msec(bleech) to give
+	   some CODECs enough time to wakeup */
+	au1550_delay(500);
+
+	/* warm reset the AC'97 to start the bitclk
+	*/
+	au_writel(PSC_AC97RST_SNC, PSC_AC97RST);
+	au_sync();
+	udelay(100);
+	au_writel(0, PSC_AC97RST);
+	au_sync();
+
+	/* Enable PSC
+	*/
+	au_writel(PSC_CTRL_ENABLE, AC97_PSC_CTRL);
+	au_sync();
+
+	/* Wait for PSC ready.
+	*/
+	do {
+		val = readl((void *)PSC_AC97STAT);
+		au_sync();
+	} while ((val & PSC_AC97STAT_SR) == 0);
+
+	/* Configure AC97 controller.
+	 * Deep FIFO, 16-bit sample, DMA, make sure DMA matches fifo size.
+	 */
+	val = PSC_AC97CFG_SET_LEN(16);
+	val |= PSC_AC97CFG_RT_FIFO8 | PSC_AC97CFG_TT_FIFO8;
+
+	/* Enable device so we can at least
+	 * talk over the AC-link.
+	 */
+	au_writel(val, PSC_AC97CFG);
+	au_writel(PSC_AC97MSK_ALLMASK, PSC_AC97MSK);
+	au_sync();
+	val |= PSC_AC97CFG_DE_ENABLE;
+	au_writel(val, PSC_AC97CFG);
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		val = readl((void *)PSC_AC97STAT);
+		au_sync();
+	} while ((val & PSC_AC97STAT_DR) == 0);
+
+	/* codec init */
+	if (!ac97_probe_codec(s->codec))
+		goto err_dev3;
+
+	s->codec_base_caps = rdcodec(s->codec, AC97_RESET);
+	s->codec_ext_caps = rdcodec(s->codec, AC97_EXTENDED_ID);
+	pr_info("AC'97 Base/Extended ID = %04x/%04x",
+	     s->codec_base_caps, s->codec_ext_caps);
+
+	if (!(s->codec_ext_caps & AC97_EXTID_VRA)) {
+		/* codec does not support VRA
+		*/
+		s->no_vra = 1;
+	} else if (!vra) {
+		/* Boot option says disable VRA
+		*/
+		u16 ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+		wrcodec(s->codec, AC97_EXTENDED_STATUS,
+			ac97_extstat & ~AC97_EXTSTAT_VRA);
+		s->no_vra = 1;
+	}
+	if (s->no_vra)
+		pr_info("no VRA, interpolating and decimating");
+
+	/* set mic to be the recording source */
+	val = SOUND_MASK_MIC;
+	mixdev_ioctl(s->codec, SOUND_MIXER_WRITE_RECSRC,
+		     (unsigned long) &val);
+
+	return 0;
+
+ err_dev3:
+	unregister_sound_mixer(s->codec->dev_mixer);
+ err_dev2:
+	unregister_sound_dsp(s->dev_audio);
+ err_dev1:
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+ err_dma2:
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+ err_dma1:
+	release_mem_region(CPHYSADDR(AC97_PSC_SEL), 0x30);
+
+	ac97_release_codec(s->codec);
+	return -1;
+}
+
+static void __devinit
+au1550_remove(void)
+{
+	struct au1550_state *s = &au1550_state;
+
+	if (!s)
+		return;
+	synchronize_irq();
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+	release_mem_region(CPHYSADDR(AC97_PSC_SEL), 0x30);
+	unregister_sound_dsp(s->dev_audio);
+	unregister_sound_mixer(s->codec->dev_mixer);
+	ac97_release_codec(s->codec);
+}
+
+static int __init
+init_au1550(void)
+{
+	return au1550_probe();
+}
+
+static void __exit
+cleanup_au1550(void)
+{
+	au1550_remove();
+}
+
+module_init(init_au1550);
+module_exit(cleanup_au1550);
+
+#ifndef MODULE
+
+static int __init
+au1550_setup(char *options)
+{
+	char           *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ","))) {
+		if (!*this_opt)
+			continue;
+		if (!strncmp(this_opt, "vra", 3)) {
+			vra = 1;
+		}
+	}
+
+	return 1;
+}
+
+__setup("au1550_audio=", au1550_setup);
+
+#endif /* MODULE */
diff -purN linux-2.6.11-rc2-bk10/sound/oss/i810_audio.c linux-2.6.11-rc3/sound/oss/i810_audio.c
--- linux-2.6.11-rc2-bk10/sound/oss/i810_audio.c	2005-02-03 10:03:10.231442919 +0100
+++ linux-2.6.11-rc3/sound/oss/i810_audio.c	2005-02-03 02:56:33.000000000 +0100
@@ -1202,7 +1202,10 @@ static void __i810_update_lvi(struct i81
 	 * the next sg segment, it won't even get a start.  So, instead, when
 	 * we are stopped, we set both the LVI value and also we increment
 	 * the CIV value to the next sg segment to be played so that when
-	 * we call start, things will operate properly
+	 * we call start, things will operate properly.  Since the CIV can't
+	 * be written to directly for this purpose, we set the LVI to CIV + 1
+	 * temporarily.  Once the engine has started we set the LVI to its
+	 * final value.
 	 */
 	if (!dmabuf->enable && dmabuf->ready) {
 		if (!(dmabuf->trigger & trigger))
diff -purN linux-2.6.11-rc2-bk10/sound/oss/ite8172.c linux-2.6.11-rc3/sound/oss/ite8172.c
--- linux-2.6.11-rc2-bk10/sound/oss/ite8172.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/ite8172.c	2005-02-03 02:55:15.000000000 +0100
@@ -96,6 +96,19 @@
 #define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
 
 
+#define IT8172_MODULE_NAME "IT8172 audio"
+#define PFX IT8172_MODULE_NAME
+
+#ifdef IT8172_DEBUG
+#define dbg(format, arg...) printk(KERN_DEBUG PFX ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
+
+
 static const unsigned sample_shift[] = { 0, 1, 1, 2 };
 
 
@@ -285,7 +298,7 @@ struct it8172_state {
 	struct proc_dir_entry *ac97_ps;
 #endif /* IT8172_DEBUG */
 
-	struct ac97_codec *codec;
+	struct ac97_codec codec;
 
 	unsigned short pcc, capcc;
 	unsigned dacrate, adcrate;
@@ -664,7 +677,7 @@ static inline void dealloc_dmabuf(struct
 		pend = virt_to_page(db->rawbuf +
 				    (PAGE_SIZE << db->buforder) - 1);
 		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			mem_map_unreserve(page);
+			ClearPageReserved(page);
 		pci_free_consistent(s->dev, PAGE_SIZE << db->buforder,
 				    db->rawbuf, db->dmaaddr);
 	}
@@ -697,7 +710,7 @@ static int prog_dmabuf(struct it8172_sta
 		pend = virt_to_page(db->rawbuf +
 				    (PAGE_SIZE << db->buforder) - 1);
 		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			mem_map_reserve(page);
+			SetPageReserved(page);
 	}
 
 	db->count = 0;
@@ -858,12 +871,6 @@ static irqreturn_t it8172_interrupt(int 
 
 /* --------------------------------------------------------------------- */
 
-static loff_t it8172_llseek(struct file *file, loff_t offset, int origin)
-{
-	return -ESPIPE;
-}
-
-
 static int it8172_open_mixdev(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
@@ -874,7 +881,7 @@ static int it8172_open_mixdev(struct ino
 		if (list == &devs)
 			return -ENODEV;
 		s = list_entry(list, struct it8172_state, devs);
-		if (s->codec->dev_mixer == minor)
+		if (s->codec.dev_mixer == minor)
 			break;
 	}
 	file->private_data = s;
@@ -998,14 +1005,14 @@ static int it8172_ioctl_mixdev(struct in
 			       unsigned int cmd, unsigned long arg)
 {
 	struct it8172_state *s = (struct it8172_state *)file->private_data;
-	struct ac97_codec *codec = s->codec;
+	struct ac97_codec *codec = &s->codec;
 
 	return mixdev_ioctl(codec, cmd, arg);
 }
 
 static /*const*/ struct file_operations it8172_mixer_fops = {
 	.owner		= THIS_MODULE,
-	.llseek		= it8172_llseek,
+	.llseek		= no_llseek,
 	.ioctl		= it8172_ioctl_mixdev,
 	.open		= it8172_open_mixdev,
 	.release	= it8172_release_mixdev,
@@ -1409,14 +1416,14 @@ static int it8172_ioctl(struct inode *in
 	case SNDCTL_DSP_RESET:
 		if (file->f_mode & FMODE_WRITE) {
 			stop_dac(s);
-			synchronize_irq();
+			synchronize_irq(s->irq);
 			s->dma_dac.count = s->dma_dac.total_bytes = 0;
 			s->dma_dac.nextIn = s->dma_dac.nextOut =
 				s->dma_dac.rawbuf;
 		}
 		if (file->f_mode & FMODE_READ) {
 			stop_adc(s);
-			synchronize_irq();
+			synchronize_irq(s->irq);
 			s->dma_adc.count = s->dma_adc.total_bytes = 0;
 			s->dma_adc.nextIn = s->dma_adc.nextOut =
 				s->dma_adc.rawbuf;
@@ -1651,7 +1658,9 @@ static int it8172_ioctl(struct inode *in
 		if (count < 0)
 			count = 0;
 		cinfo.blocks = count >> s->dma_adc.fragshift;
-		return copy_to_user((void *)arg, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
+		if (copy_to_user((void *)arg, &cinfo, sizeof(cinfo)))
+			return -EFAULT;
+		return 0;
 
 	case SNDCTL_DSP_GETOPTR:
 		if (!(file->f_mode & FMODE_READ))
@@ -1674,7 +1683,9 @@ static int it8172_ioctl(struct inode *in
 		if (count < 0)
 			count = 0;
 		cinfo.blocks = count >> s->dma_dac.fragshift;
-		return copy_to_user((void *)arg, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
+		if (copy_to_user((void *)arg, &cinfo, sizeof(cinfo)))
+			return -EFAULT;
+		return 0;
 
 	case SNDCTL_DSP_GETBLKSIZE:
 		if (file->f_mode & FMODE_WRITE)
@@ -1761,7 +1772,7 @@ static int it8172_ioctl(struct inode *in
 		return -EINVAL;
 	}
 
-	return mixdev_ioctl(s->codec, cmd, arg);
+	return mixdev_ioctl(&s->codec, cmd, arg);
 }
 
 
@@ -1871,7 +1882,7 @@ static int it8172_release(struct inode *
 
 static /*const*/ struct file_operations it8172_audio_fops = {
 	.owner		= THIS_MODULE,
-	.llseek		= it8172_llseek,
+	.llseek		= no_llseek,
 	.read		= it8172_read,
 	.write		= it8172_write,
 	.poll		= it8172_poll,
@@ -1929,7 +1940,7 @@ static int proc_it8172_dump (char *buf, 
 	len += sprintf (buf + len, "----------------------\n");
 	for (cnt=0; cnt <= 0x7e; cnt = cnt +2)
 		len+= sprintf (buf + len, "reg %02x = %04x\n",
-			       cnt, rdcodec(s->codec, cnt));
+			       cnt, rdcodec(&s->codec, cnt));
 
 	if (fpos >=len){
 		*start = buf;
@@ -1994,16 +2005,11 @@ static int __devinit it8172_probe(struct
 	s->vendor = pcidev->vendor;
 	s->device = pcidev->device;
 	pci_read_config_byte(pcidev, PCI_REVISION_ID, &s->rev);
-	
-	s->codec = ac97_alloc_codec();
-	if(s->codec == NULL)
-		goto err_codec;
-		
-	s->codec->private_data = s;
-	s->codec->id = 0;
-	s->codec->codec_read = rdcodec;
-	s->codec->codec_write = wrcodec;
-	s->codec->codec_wait = waitcodec;
+	s->codec.private_data = s;
+	s->codec.id = 0;
+	s->codec.codec_read = rdcodec;
+	s->codec.codec_write = wrcodec;
+	s->codec.codec_wait = waitcodec;
 
 	if (!request_region(s->io, pci_resource_len(pcidev,0),
 			    IT8172_MODULE_NAME)) {
@@ -2022,12 +2028,12 @@ static int __devinit it8172_probe(struct
 	/* register devices */
 	if ((s->dev_audio = register_sound_dsp(&it8172_audio_fops, -1)) < 0)
 		goto err_dev1;
-	if ((s->codec->dev_mixer =
+	if ((s->codec.dev_mixer =
 	     register_sound_mixer(&it8172_mixer_fops, -1)) < 0)
 		goto err_dev2;
 
 #ifdef IT8172_DEBUG
-	/* intialize the debug proc device */
+	/* initialize the debug proc device */
 	s->ps = create_proc_read_entry(IT8172_MODULE_NAME, 0, NULL,
 				       proc_it8172_dump, NULL);
 #endif /* IT8172_DEBUG */
@@ -2093,11 +2099,11 @@ static int __devinit it8172_probe(struct
 	outw(0, s->io+IT_AC_CODECC);
     
 	/* codec init */
-	if (!ac97_probe_codec(s->codec))
+	if (!ac97_probe_codec(&s->codec))
 		goto err_dev3;
 
 	/* add I2S as allowable recording source */
-	s->codec->record_sources |= SOUND_MASK_I2S;
+	s->codec.record_sources |= SOUND_MASK_I2S;
 	
 	/* Enable Volume button interrupts */
 	imc = inb(s->io+IT_AC_IMC);
@@ -2117,23 +2123,23 @@ static int __devinit it8172_probe(struct
 
 	/* set mic to be the recording source */
 	val = SOUND_MASK_MIC;
-	mixdev_ioctl(s->codec, SOUND_MIXER_WRITE_RECSRC,
+	mixdev_ioctl(&s->codec, SOUND_MIXER_WRITE_RECSRC,
 		     (unsigned long)&val);
 
 	/* mute AC'97 master and PCM when in S/PDIF mode */
 	if (s->spdif_volume != -1) {
 		val = 0x0000;
-		s->codec->mixer_ioctl(s->codec, SOUND_MIXER_WRITE_VOLUME,
+		s->codec.mixer_ioctl(&s->codec, SOUND_MIXER_WRITE_VOLUME,
 				     (unsigned long)&val);
-		s->codec->mixer_ioctl(s->codec, SOUND_MIXER_WRITE_PCM,
+		s->codec.mixer_ioctl(&s->codec, SOUND_MIXER_WRITE_PCM,
 				     (unsigned long)&val);
 	}
     
 #ifdef IT8172_DEBUG
 	sprintf(proc_str, "driver/%s/%d/ac97", IT8172_MODULE_NAME,
-		s->codec->id);
+		s->codec.id);
 	s->ac97_ps = create_proc_read_entry (proc_str, 0, NULL,
-					     ac97_read_proc, s->codec);
+					     ac97_read_proc, &s->codec);
 #endif
     
 	/* store it in the driver field */
@@ -2147,7 +2153,7 @@ static int __devinit it8172_probe(struct
 	return 0;
 
  err_dev3:
-	unregister_sound_mixer(s->codec->dev_mixer);
+	unregister_sound_mixer(s->codec.dev_mixer);
  err_dev2:
 	unregister_sound_dsp(s->dev_audio);
  err_dev1:
@@ -2156,8 +2162,6 @@ static int __devinit it8172_probe(struct
  err_irq:
 	release_region(s->io, pci_resource_len(pcidev,0));
  err_region:
- 	ac97_release_codec(s->codec);
- err_codec:
 	kfree(s);
 	return -1;
 }
@@ -2173,12 +2177,11 @@ static void __devexit it8172_remove(stru
 	if (s->ps)
 		remove_proc_entry(IT8172_MODULE_NAME, NULL);
 #endif /* IT8172_DEBUG */
-	synchronize_irq();
+	synchronize_irq(s->irq);
 	free_irq(s->irq, s);
 	release_region(s->io, pci_resource_len(dev,0));
 	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->codec->dev_mixer);
-	ac97_codec_release(s->codec);
+	unregister_sound_mixer(s->codec.dev_mixer);
 	kfree(s);
 	pci_set_drvdata(dev, NULL);
 }
@@ -2202,8 +2205,6 @@ static struct pci_driver it8172_driver =
 
 static int __init init_it8172(void)
 {
-	if (!pci_present())   /* No PCI bus in this machine! */
-		return -ENODEV;
 	info("version v0.5 time " __TIME__ " " __DATE__);
 	return pci_module_init(&it8172_driver);
 }
diff -purN linux-2.6.11-rc2-bk10/sound/oss/nec_vrc5477.c linux-2.6.11-rc3/sound/oss/nec_vrc5477.c
--- linux-2.6.11-rc2-bk10/sound/oss/nec_vrc5477.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/nec_vrc5477.c	2005-02-03 02:57:16.000000000 +0100
@@ -78,7 +78,6 @@
 #include <linux/spinlock.h>
 #include <linux/smp_lock.h>
 #include <linux/ac97_codec.h>
-#include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/uaccess.h>
@@ -396,10 +395,47 @@ static void set_dac_rate(struct vrc5477_
 	}
 }
 
+static int ac97_codec_not_present(struct ac97_codec *codec)
+{
+	struct vrc5477_ac97_state *s =
+		(struct vrc5477_ac97_state *)codec->private_data;
+	unsigned long flags;
+	unsigned short count  = 0xffff;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	/* wait until we can access codec registers */
+	do {
+	       if (!(inl(s->io + VRC5477_CODEC_WR) & 0x80000000))
+		       break;
+	} while (--count);
+
+	if (count == 0) {
+		spin_unlock_irqrestore(&s->lock, flags);
+		return -1;
+	}
+
+	/* write 0 to reset */
+	outl((AC97_RESET << 16) | 0, s->io + VRC5477_CODEC_WR);
+
+	/* test whether we get a response from ac97 chip */
+	count  = 0xffff;
+	do {
+	       if (!(inl(s->io + VRC5477_CODEC_WR) & 0x80000000))
+		       break;
+	} while (--count);
+
+	if (count == 0) {
+		spin_unlock_irqrestore(&s->lock, flags);
+		return -1;
+	}
+	spin_unlock_irqrestore(&s->lock, flags);
+	return 0;
+}
 
 /* --------------------------------------------------------------------- */
 
-static inline void 
+extern inline void
 stop_dac(struct vrc5477_ac97_state *s)
 {
 	struct dmabuf* db = &s->dma_dac;
@@ -517,7 +553,7 @@ static void start_dac(struct vrc5477_ac9
 	spin_unlock_irqrestore(&s->lock, flags);
 }	
 
-static inline void stop_adc(struct vrc5477_ac97_state *s)
+extern inline void stop_adc(struct vrc5477_ac97_state *s)
 {
 	struct dmabuf* db = &s->dma_adc;
 	unsigned long flags;
@@ -616,7 +652,7 @@ static void start_adc(struct vrc5477_ac9
 #define DMABUF_DEFAULTORDER (16-PAGE_SHIFT)
 #define DMABUF_MINORDER 1
 
-static inline void dealloc_dmabuf(struct vrc5477_ac97_state *s, 
+extern inline void dealloc_dmabuf(struct vrc5477_ac97_state *s,
 				  struct dmabuf *db)
 {
 	if (db->lbuf) {
@@ -1858,6 +1894,13 @@ static int __devinit vrc5477_ac97_probe(
 
         }
 
+	/* test if get response from ac97, if not return */
+        if (ac97_codec_not_present(&(s->codec))) {
+		printk(KERN_ERR PFX "no ac97 codec\n");
+		goto err_region;
+
+        }
+
 	if (!request_region(s->io, pci_resource_len(pcidev,0),
 			    VRC5477_AC97_MODULE_NAME)) {
 		printk(KERN_ERR PFX "io ports %#lx->%#lx in use\n",
@@ -1973,7 +2016,7 @@ static void __devexit vrc5477_ac97_remov
 		remove_proc_entry(VRC5477_AC97_MODULE_NAME, NULL);
 #endif /* VRC5477_AC97_DEBUG */
 
-	synchronize_irq(s->irq);
+	synchronize_irq();
 	free_irq(s->irq, s);
 	release_region(s->io, pci_resource_len(dev,0));
 	unregister_sound_dsp(s->dev_audio);
@@ -1996,7 +2039,7 @@ static struct pci_driver vrc5477_ac97_dr
 	.name		= VRC5477_AC97_MODULE_NAME,
 	.id_table	= id_table,
 	.probe		= vrc5477_ac97_probe,
-	.remove		= __devexit_p(vrc5477_ac97_remove),
+	.remove		= __devexit_p(vrc5477_ac97_remove)
 };
 
 static int __init init_vrc5477_ac97(void)
diff -purN linux-2.6.11-rc2-bk10/sound/oss/swarm_cs4297a.c linux-2.6.11-rc3/sound/oss/swarm_cs4297a.c
--- linux-2.6.11-rc2-bk10/sound/oss/swarm_cs4297a.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/sound/oss/swarm_cs4297a.c	2005-02-03 02:55:53.000000000 +0100
@@ -10,7 +10,9 @@
 *               (audio@crystal.cirrus.com).
 *            -- adapted from cs4281 PCI driver for cs4297a on
 *               BCM1250 Synchronous Serial interface
-*               (kwalker@broadcom.com)
+*               (Kip Walker, Broadcom Corp.)
+*      Copyright (C) 2004  Maciej W. Rozycki
+*      Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
@@ -71,12 +73,13 @@
 #include <linux/pci.h>
 #include <linux/bitops.h>
 #include <linux/interrupt.h>
-#include <asm/io.h>
-#include <asm/dma.h>
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
-#include <linux/wrapper.h>
+
+#include <asm/byteorder.h>
+#include <asm/dma.h>
+#include <asm/io.h>
 #include <asm/uaccess.h>
 
 #include <asm/sibyte/sb1250_regs.h>
@@ -86,7 +89,6 @@
 #include <asm/sibyte/sb1250_syncser.h>
 #include <asm/sibyte/sb1250_mac.h>
 #include <asm/sibyte/sb1250.h>
-#include <asm/sibyte/64bit.h>
 
 struct cs4297a_state;
 
@@ -561,44 +563,44 @@ static int ser_init(struct cs4297a_state
         CS_DBGOUT(CS_INIT, 2, 
                   printk(KERN_INFO "cs4297a: Setting up serial parameters\n"));
 
-        out64(M_SYNCSER_CMD_RX_RESET | M_SYNCSER_CMD_TX_RESET, SS_CSR(R_SER_CMD));
+        __raw_writeq(M_SYNCSER_CMD_RX_RESET | M_SYNCSER_CMD_TX_RESET, SS_CSR(R_SER_CMD));
 
-        out64(M_SYNCSER_MSB_FIRST, SS_CSR(R_SER_MODE));
-        out64(32, SS_CSR(R_SER_MINFRM_SZ));
-        out64(32, SS_CSR(R_SER_MAXFRM_SZ));
-
-        out64(1, SS_CSR(R_SER_TX_RD_THRSH));
-        out64(4, SS_CSR(R_SER_TX_WR_THRSH));
-        out64(8, SS_CSR(R_SER_RX_RD_THRSH));
+        __raw_writeq(M_SYNCSER_MSB_FIRST, SS_CSR(R_SER_MODE));
+        __raw_writeq(32, SS_CSR(R_SER_MINFRM_SZ));
+        __raw_writeq(32, SS_CSR(R_SER_MAXFRM_SZ));
+
+        __raw_writeq(1, SS_CSR(R_SER_TX_RD_THRSH));
+        __raw_writeq(4, SS_CSR(R_SER_TX_WR_THRSH));
+        __raw_writeq(8, SS_CSR(R_SER_RX_RD_THRSH));
 
         /* This looks good from experimentation */
-        out64((M_SYNCSER_TXSYNC_INT | V_SYNCSER_TXSYNC_DLY(0) | M_SYNCSER_TXCLK_EXT |
+        __raw_writeq((M_SYNCSER_TXSYNC_INT | V_SYNCSER_TXSYNC_DLY(0) | M_SYNCSER_TXCLK_EXT |
                M_SYNCSER_RXSYNC_INT | V_SYNCSER_RXSYNC_DLY(1) | M_SYNCSER_RXCLK_EXT | M_SYNCSER_RXSYNC_EDGE),
               SS_CSR(R_SER_LINE_MODE));
 
         /* This looks good from experimentation */
-        out64(V_SYNCSER_SEQ_COUNT(14) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE,
+        __raw_writeq(V_SYNCSER_SEQ_COUNT(14) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE,
               SS_TXTBL(0));
-        out64(V_SYNCSER_SEQ_COUNT(15) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
+        __raw_writeq(V_SYNCSER_SEQ_COUNT(15) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
               SS_TXTBL(1));
-        out64(V_SYNCSER_SEQ_COUNT(13) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
+        __raw_writeq(V_SYNCSER_SEQ_COUNT(13) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
               SS_TXTBL(2));
-        out64(V_SYNCSER_SEQ_COUNT( 0) | M_SYNCSER_SEQ_ENABLE |
+        __raw_writeq(V_SYNCSER_SEQ_COUNT( 0) | M_SYNCSER_SEQ_ENABLE |
               M_SYNCSER_SEQ_STROBE | M_SYNCSER_SEQ_LAST, SS_TXTBL(3));
 
-        out64(V_SYNCSER_SEQ_COUNT(14) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE,
+        __raw_writeq(V_SYNCSER_SEQ_COUNT(14) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE,
               SS_RXTBL(0));
-        out64(V_SYNCSER_SEQ_COUNT(15) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
+        __raw_writeq(V_SYNCSER_SEQ_COUNT(15) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
               SS_RXTBL(1));
-        out64(V_SYNCSER_SEQ_COUNT(13) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
+        __raw_writeq(V_SYNCSER_SEQ_COUNT(13) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,
               SS_RXTBL(2));
-        out64(V_SYNCSER_SEQ_COUNT( 0) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE |
+        __raw_writeq(V_SYNCSER_SEQ_COUNT( 0) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE |
               M_SYNCSER_SEQ_LAST, SS_RXTBL(3));
 
         for (i=4; i<16; i++) {
                 /* Just in case... */
-                out64(M_SYNCSER_SEQ_LAST, SS_TXTBL(i));
-                out64(M_SYNCSER_SEQ_LAST, SS_RXTBL(i));
+                __raw_writeq(M_SYNCSER_SEQ_LAST, SS_TXTBL(i));
+                __raw_writeq(M_SYNCSER_SEQ_LAST, SS_RXTBL(i));
         }
 
         return 0;
@@ -620,7 +622,7 @@ static int init_serdma(serdma_t *dma)
         memset(dma->descrtab, 0, dma->ringsz * sizeof(serdma_descr_t));
         dma->descrtab_end = dma->descrtab + dma->ringsz;
 	/* XXX bloddy mess, use proper DMA API here ...  */
-	dma->descrtab_phys = PHYSADDR((int)dma->descrtab);
+	dma->descrtab_phys = CPHYSADDR((long)dma->descrtab);
         dma->descr_add = dma->descr_rem = dma->descrtab;
 
         /* Frame buffer area */
@@ -631,7 +633,7 @@ static int init_serdma(serdma_t *dma)
                 return -1;
         }
         memset(dma->dma_buf, 0, DMA_BUF_SIZE);
-        dma->dma_buf_phys = PHYSADDR((int)dma->dma_buf);
+        dma->dma_buf_phys = CPHYSADDR((long)dma->dma_buf);
 
         /* Samples buffer area */
         dma->sbufsz = SAMPLE_BUF_SIZE;
@@ -665,8 +667,8 @@ static int dma_init(struct cs4297a_state
             init_serdma(&s->dma_dac))
                 return -1;
 
-        if (in64(SS_CSR(R_SER_DMA_DSCR_COUNT_RX))||
-            in64(SS_CSR(R_SER_DMA_DSCR_COUNT_TX))) {
+        if (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_RX))||
+            __raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX))) {
                 panic("DMA state corrupted?!");
         }
 
@@ -681,38 +683,38 @@ static int dma_init(struct cs4297a_state
                 s->dma_adc.descrtab[i].descr_b = 0;
         }
 
-        out64((M_DMA_EOP_INT_EN | V_DMA_INT_PKTCNT(DMA_INT_CNT) |
+        __raw_writeq((M_DMA_EOP_INT_EN | V_DMA_INT_PKTCNT(DMA_INT_CNT) |
                V_DMA_RINGSZ(DMA_DESCR) | M_DMA_TDX_EN),
               SS_CSR(R_SER_DMA_CONFIG0_RX));
-        out64(M_DMA_L2CA, SS_CSR(R_SER_DMA_CONFIG1_RX));
-        out64(s->dma_adc.descrtab_phys, SS_CSR(R_SER_DMA_DSCR_BASE_RX));
+        __raw_writeq(M_DMA_L2CA, SS_CSR(R_SER_DMA_CONFIG1_RX));
+        __raw_writeq(s->dma_adc.descrtab_phys, SS_CSR(R_SER_DMA_DSCR_BASE_RX));
 
-        out64(V_DMA_RINGSZ(DMA_DESCR), SS_CSR(R_SER_DMA_CONFIG0_TX));
-        out64(M_DMA_L2CA | M_DMA_NO_DSCR_UPDT, SS_CSR(R_SER_DMA_CONFIG1_TX));
-        out64(s->dma_dac.descrtab_phys, SS_CSR(R_SER_DMA_DSCR_BASE_TX));
+        __raw_writeq(V_DMA_RINGSZ(DMA_DESCR), SS_CSR(R_SER_DMA_CONFIG0_TX));
+        __raw_writeq(M_DMA_L2CA | M_DMA_NO_DSCR_UPDT, SS_CSR(R_SER_DMA_CONFIG1_TX));
+        __raw_writeq(s->dma_dac.descrtab_phys, SS_CSR(R_SER_DMA_DSCR_BASE_TX));
 
         /* Prep the receive DMA descriptor ring */
-        out64(DMA_DESCR, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
+        __raw_writeq(DMA_DESCR, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
 
-        out64(M_SYNCSER_DMA_RX_EN | M_SYNCSER_DMA_TX_EN, SS_CSR(R_SER_DMA_ENABLE));
+        __raw_writeq(M_SYNCSER_DMA_RX_EN | M_SYNCSER_DMA_TX_EN, SS_CSR(R_SER_DMA_ENABLE));
 
-        out64((M_SYNCSER_RX_SYNC_ERR | M_SYNCSER_RX_OVERRUN | M_SYNCSER_RX_EOP_COUNT),
+        __raw_writeq((M_SYNCSER_RX_SYNC_ERR | M_SYNCSER_RX_OVERRUN | M_SYNCSER_RX_EOP_COUNT),
               SS_CSR(R_SER_INT_MASK));
 
         /* Enable the rx/tx; let the codec warm up to the sync and
            start sending good frames before the receive FIFO is
            enabled */
-        out64(M_SYNCSER_CMD_TX_EN, SS_CSR(R_SER_CMD));
+        __raw_writeq(M_SYNCSER_CMD_TX_EN, SS_CSR(R_SER_CMD));
         udelay(1000);
-        out64(M_SYNCSER_CMD_RX_EN | M_SYNCSER_CMD_TX_EN, SS_CSR(R_SER_CMD));
+        __raw_writeq(M_SYNCSER_CMD_RX_EN | M_SYNCSER_CMD_TX_EN, SS_CSR(R_SER_CMD));
 
         /* XXXKW is this magic? (the "1" part) */
-        while ((in64(SS_CSR(R_SER_STATUS)) & 0xf1) != 1)
+        while ((__raw_readq(SS_CSR(R_SER_STATUS)) & 0xf1) != 1)
                 ;
 
         CS_DBGOUT(CS_INIT, 4, 
                   printk(KERN_INFO "cs4297a: status: %08x\n",
-                         (unsigned int)(in64(SS_CSR(R_SER_STATUS)) & 0xffffffff)));
+                         (unsigned int)(__raw_readq(SS_CSR(R_SER_STATUS)) & 0xffffffff)));
 
         return 0;
 }
@@ -752,8 +754,8 @@ static int serdma_reg_access(struct cs42
 
                 descr = &d->descrtab[swptr];
                 data_p = &d->dma_buf[swptr * 4];
-                *data_p = data;
-                out64(1, SS_CSR(R_SER_DMA_DSCR_COUNT_TX));
+		*data_p = cpu_to_be64(data);
+                __raw_writeq(1, SS_CSR(R_SER_DMA_DSCR_COUNT_TX));
                 CS_DBGOUT(CS_DESCR, 4,
                           printk(KERN_INFO "cs4297a: add_tx  %p (%x -> %x)\n",
                                  data_p, swptr, d->hwptr));
@@ -807,7 +809,7 @@ static void stop_dac(struct cs4297a_stat
         /* XXXKW what do I really want here?  My theory for now is
            that I just flip the "ena" bit, and the interrupt handler
            will stop processing the xmit channel */
-        out64((s->ena & FMODE_READ) ? M_SYNCSER_DMA_RX_EN : 0,
+        __raw_writeq((s->ena & FMODE_READ) ? M_SYNCSER_DMA_RX_EN : 0,
               SS_CSR(R_SER_DMA_ENABLE));
 #endif
 
@@ -926,11 +928,11 @@ static void cs4297a_update_ptr(struct cs
         serdma_descr_t *descr;
 
 	// update ADC pointer 
-        status = intflag ? in64(SS_CSR(R_SER_STATUS)) : 0;
+        status = intflag ? __raw_readq(SS_CSR(R_SER_STATUS)) : 0;
 
 	if ((s->ena & FMODE_READ) || (status & (M_SYNCSER_RX_EOP_COUNT))) {
                 d = &s->dma_adc;
-                hwptr = (unsigned) (((in64(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -
+                hwptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -
                                      d->descrtab_phys) / sizeof(serdma_descr_t));
 
                 if (s->ena & FMODE_READ) {
@@ -944,12 +946,12 @@ static void cs4297a_update_ptr(struct cs
                         s_ptr = (u32 *)&(d->dma_buf[d->swptr*4]);
                         descr = &d->descrtab[d->swptr];
                         while (diff2--) {
-                                u64 data = *(u64 *)s_ptr;
+				u64 data = be64_to_cpu(*(u64 *)s_ptr);
                                 u64 descr_a;
                                 u16 left, right;
                                 descr_a = descr->descr_a;
                                 descr->descr_a &= ~M_DMA_SERRX_SOP;
-                                if ((descr_a & M_DMA_DSCRA_A_ADDR) != PHYSADDR((int)s_ptr)) {
+                                if ((descr_a & M_DMA_DSCRA_A_ADDR) != CPHYSADDR((long)s_ptr)) {
                                         printk(KERN_ERR "cs4297a: RX Bad address (read)\n");
                                 }
                                 if (((data & 0x9800000000000000) != 0x9800000000000000) ||
@@ -971,10 +973,11 @@ static void cs4297a_update_ptr(struct cs
                                         continue;
                                 }
                                 good_diff++;
-                                left = ((s_ptr[1] & 0xff) << 8) | ((s_ptr[2] >> 24) & 0xff);
-                                right = (s_ptr[2] >> 4) & 0xffff;
-                                *d->sb_hwptr++ = left;
-                                *d->sb_hwptr++ = right;
+				left = ((be32_to_cpu(s_ptr[1]) & 0xff) << 8) |
+				       ((be32_to_cpu(s_ptr[2]) >> 24) & 0xff);
+				right = (be32_to_cpu(s_ptr[2]) >> 4) & 0xffff;
+				*d->sb_hwptr++ = cpu_to_be16(left);
+				*d->sb_hwptr++ = cpu_to_be16(right);
                                 if (d->sb_hwptr == d->sb_end)
                                         d->sb_hwptr = d->sample_buf;
                                 descr++;
@@ -991,7 +994,7 @@ static void cs4297a_update_ptr(struct cs
                                 printk(KERN_ERR "cs4297a: bogus receive overflow!!\n");
                         }
                         d->swptr = (d->swptr + diff) % d->ringsz;
-                        out64(diff, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
+                        __raw_writeq(diff, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
                         if (d->mapped) {
                                 if (d->count >= (signed) d->fragsize)
                                         wake_up(&d->wait);
@@ -1019,11 +1022,11 @@ static void cs4297a_update_ptr(struct cs
                            here because of an interrupt, so there must
                            be a buffer to process. */
                         do {
-                                data = *data_p;
-                                if ((descr->descr_a & M_DMA_DSCRA_A_ADDR) != PHYSADDR((int)data_p)) {
-                                        printk(KERN_ERR "cs4297a: RX Bad address %d (%x %x)\n", d->swptr,
-                                               (int)(descr->descr_a & M_DMA_DSCRA_A_ADDR),
-                                               (int)PHYSADDR((int)data_p));
+				data = be64_to_cpu(*data_p);
+                                if ((descr->descr_a & M_DMA_DSCRA_A_ADDR) != CPHYSADDR((long)data_p)) {
+                                        printk(KERN_ERR "cs4297a: RX Bad address %d (%llx %lx)\n", d->swptr,
+                                               (long long)(descr->descr_a & M_DMA_DSCRA_A_ADDR),
+                                               (long)CPHYSADDR((long)data_p));
                                 }
                                 if (!(data & (1LL << 63)) ||
                                     !(descr->descr_a & M_DMA_SERRX_SOP) ||
@@ -1047,7 +1050,7 @@ static void cs4297a_update_ptr(struct cs
                                         d->swptr = 0;
                                         data_p = d->dma_buf;
                                 }
-                                out64(1, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
+                                __raw_writeq(1, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
                         } while (--diff);
                         d->hwptr = hwptr;
 
@@ -1072,7 +1075,7 @@ static void cs4297a_update_ptr(struct cs
 	//
 	if (s->ena & FMODE_WRITE) {
                 serdma_t *d = &s->dma_dac;
-                hwptr = (unsigned) (((in64(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
+                hwptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
                                      d->descrtab_phys) / sizeof(serdma_descr_t));
                 diff = (d->ringsz + hwptr - d->hwptr) % d->ringsz;
                 CS_DBGOUT(CS_WAVE_WRITE, 4, printk(KERN_INFO
@@ -1611,7 +1614,7 @@ static int drain_dac(struct cs4297a_stat
         if (nonblock)
                 return -EBUSY;
 	add_wait_queue(&s->dma_dac.wait, &wait);
-        while ((count = in64(SS_CSR(R_SER_DMA_DSCR_COUNT_TX))) ||
+        while ((count = __raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX))) ||
                (s->dma_dac.count > 0)) {
                 if (!signal_pending(current)) {
                         set_current_state(TASK_INTERRUPTIBLE);
@@ -1624,7 +1627,7 @@ static int drain_dac(struct cs4297a_stat
         }
         spin_lock_irqsave(&s->lock, flags);
         /* Reset the bookkeeping */
-        hwptr = (int)(((in64(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
+        hwptr = (int)(((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
                        s->dma_dac.descrtab_phys) / sizeof(serdma_descr_t));
         s->dma_dac.hwptr = s->dma_dac.swptr = hwptr;
         spin_unlock_irqrestore(&s->lock, flags);
@@ -1787,7 +1790,6 @@ static ssize_t cs4297a_write(struct file
                 u32 *s_tmpl;
                 u32 *t_tmpl;
                 u32 left, right;
-                /* XXXKW check system endian here ... */
                 int swap = (s->prop_dac.fmt == AFMT_S16_LE) || (s->prop_dac.fmt == AFMT_U16_LE);
                 
                 /* XXXXXX this is broken for BLOAT_FACTOR */
@@ -1798,7 +1800,7 @@ static ssize_t cs4297a_write(struct file
 		}
 		if (d->underrun) {
 			d->underrun = 0;
-                        hwptr = (unsigned) (((in64(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
+                        hwptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
                                              d->descrtab_phys) / sizeof(serdma_descr_t));
 			d->swptr = d->hwptr = hwptr;
 		}
@@ -1828,21 +1830,21 @@ static ssize_t cs4297a_write(struct file
 
                 /* XXXKW assuming 16-bit stereo! */
                 do {
-                        t_tmpl[0] = 0x98000000;
-                        left = s_tmpl[0] >> 16;
-                        if (left & 0x8000)
-                                left |= 0xf0000;
-                        right = s_tmpl[0] & 0xffff;
-                        if (right & 0x8000)
-                                right |= 0xf0000;
-                        if (swap) {
-                          t_tmpl[1] = left & 0xff;
-                          t_tmpl[2] = ((left & 0xff00) << 16) | ((right & 0xff) << 12) |
-                              ((right & 0xff00) >> 4);
-                        } else {
-                          t_tmpl[1] = left >> 8;
-                          t_tmpl[2] = ((left & 0xff) << 24) | (right << 4);
-                        }
+			u32 tmp;
+
+			t_tmpl[0] = cpu_to_be32(0x98000000);
+
+			tmp = be32_to_cpu(s_tmpl[0]);
+			left = tmp & 0xffff;
+			right = tmp >> 16;
+			if (swap) {
+				left = swab16(left);
+				right = swab16(right);
+			}
+			t_tmpl[1] = cpu_to_be32(left >> 8);
+			t_tmpl[2] = cpu_to_be32(((left & 0xff) << 24) |
+						(right << 4));
+
                         s_tmpl++;
                         t_tmpl += 8;
                         copy_cnt -= 4;
@@ -1850,7 +1852,8 @@ static ssize_t cs4297a_write(struct file
 
                 /* Mux in any pending read/write accesses */
                 if (s->reg_request) {
-                        *(u64 *)(d->dma_buf + (swptr * 4)) |= s->reg_request;
+			*(u64 *)(d->dma_buf + (swptr * 4)) |=
+				cpu_to_be64(s->reg_request);
                         s->reg_request = 0;
                         wake_up(&s->dma_dac.reg_wait);
                 }
@@ -1860,7 +1863,7 @@ static ssize_t cs4297a_write(struct file
                                  "cs4297a: copy in %d to swptr %x\n", cnt, swptr));
 
 		swptr = (swptr + (cnt/FRAME_SAMPLE_BYTES)) % d->ringsz;
-                out64(cnt/FRAME_SAMPLE_BYTES, SS_CSR(R_SER_DMA_DSCR_COUNT_TX));
+                __raw_writeq(cnt/FRAME_SAMPLE_BYTES, SS_CSR(R_SER_DMA_DSCR_COUNT_TX));
 		spin_lock_irqsave(&s->lock, flags);
 		d->swptr = swptr;
 		d->count += cnt;
@@ -1993,20 +1996,20 @@ static int cs4297a_ioctl(struct inode *i
 			 "cs4297a: cs4297a_ioctl(): DSP_RESET\n"));
 		if (file->f_mode & FMODE_WRITE) {
 			stop_dac(s);
-			synchronize_irq();
+			synchronize_irq(s->irq);
                         s->dma_dac.count = s->dma_dac.total_bytes =
                                 s->dma_dac.blocks = s->dma_dac.wakeup = 0;
 			s->dma_dac.swptr = s->dma_dac.hwptr =
-                                (int)(((in64(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
+                                (int)(((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -
                                        s->dma_dac.descrtab_phys) / sizeof(serdma_descr_t));
 		}
 		if (file->f_mode & FMODE_READ) {
 			stop_adc(s);
-			synchronize_irq();
+			synchronize_irq(s->irq);
                         s->dma_adc.count = s->dma_adc.total_bytes =
                                 s->dma_adc.blocks = s->dma_dac.wakeup = 0;
 			s->dma_adc.swptr = s->dma_adc.hwptr =
-                                (int)(((in64(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -
+                                (int)(((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -
                                        s->dma_adc.descrtab_phys) / sizeof(serdma_descr_t));
 		}
 		return 0;
@@ -2378,7 +2381,7 @@ static int cs4297a_open(struct inode *in
 		"cs4297a: cs4297a_open(): inode=0x%.8x file=0x%.8x f_mode=0x%x\n",
 			(unsigned) inode, (unsigned) file, file->f_mode));
 	CS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO
-                "cs4297a: status = %08x\n", (int)in64(SS_CSR(R_SER_STATUS_DEBUG))));
+                "cs4297a: status = %08x\n", (int)__raw_readq(SS_CSR(R_SER_STATUS_DEBUG))));
 
 	list_for_each(entry, &cs4297a_devs)
 	{
@@ -2404,9 +2407,9 @@ static int cs4297a_open(struct inode *in
 		return -ENODEV;
 	}
 	if (file->f_mode & FMODE_WRITE) {
-                if (in64(SS_CSR(R_SER_DMA_DSCR_COUNT_TX)) != 0) {
+                if (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX)) != 0) {
                         printk(KERN_ERR "cs4297a: TX pipe needs to drain\n");
-                        while (in64(SS_CSR(R_SER_DMA_DSCR_COUNT_TX)))
+                        while (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX)))
                                 ;
                 }
           
@@ -2501,12 +2504,12 @@ static /*const */ struct file_operations
 	.release	= cs4297a_release,
 };
 
-static irqreturn_t cs4297a_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static void cs4297a_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct cs4297a_state *s = (struct cs4297a_state *) dev_id;
         u32 status;
 
-        status = in64(SS_CSR(R_SER_STATUS_DEBUG));
+        status = __raw_readq(SS_CSR(R_SER_STATUS_DEBUG));
 
         CS_DBGOUT(CS_INTERRUPT, 6, printk(KERN_INFO
                  "cs4297a: cs4297a_interrupt() HISR=0x%.8x\n", status));
@@ -2514,16 +2517,16 @@ static irqreturn_t cs4297a_interrupt(int
 #if 0
         /* XXXKW what check *should* be done here? */
         if (!(status & (M_SYNCSER_RX_EOP_COUNT | M_SYNCSER_RX_OVERRUN | M_SYNCSER_RX_SYNC_ERR))) {
-                status = in64(SS_CSR(R_SER_STATUS));
+                status = __raw_readq(SS_CSR(R_SER_STATUS));
                 printk(KERN_ERR "cs4297a: unexpected interrupt (status %08x)\n", status);
-                return IRQ_HANDLED;
+                return;
         }
 #endif
 
         if (status & M_SYNCSER_RX_SYNC_ERR) {
-                status = in64(SS_CSR(R_SER_STATUS));
+                status = __raw_readq(SS_CSR(R_SER_STATUS));
                 printk(KERN_ERR "cs4297a: rx sync error (status %08x)\n", status);
-                return IRQ_HANDLED;
+                return;
         }
 
         if (status & M_SYNCSER_RX_OVERRUN) {
@@ -2533,9 +2536,9 @@ static irqreturn_t cs4297a_interrupt(int
 
                 /* Fix things up: get the receive descriptor pool
                    clean and give them back to the hardware */
-                while (in64(SS_CSR(R_SER_DMA_DSCR_COUNT_RX)))
+                while (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_RX)))
                         ;
-                newptr = (unsigned) (((in64(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -
+                newptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -
                                      s->dma_adc.descrtab_phys) / sizeof(serdma_descr_t));
                 for (i=0; i<DMA_DESCR; i++) {
                         s->dma_adc.descrtab[i].descr_a &= ~M_DMA_SERRX_SOP;
@@ -2543,7 +2546,7 @@ static irqreturn_t cs4297a_interrupt(int
                 s->dma_adc.swptr = s->dma_adc.hwptr = newptr;
                 s->dma_adc.count = 0;
                 s->dma_adc.sb_swptr = s->dma_adc.sb_hwptr = s->dma_adc.sample_buf;
-                out64(DMA_DESCR, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
+                __raw_writeq(DMA_DESCR, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));
         }
 
 	spin_lock(&s->lock);
@@ -2552,9 +2555,9 @@ static irqreturn_t cs4297a_interrupt(int
 
 	CS_DBGOUT(CS_INTERRUPT, 6, printk(KERN_INFO
 		  "cs4297a: cs4297a_interrupt()-\n"));
-	return IRQ_HANDLED;
 }
 
+#if 0
 static struct initvol {
 	int mixch;
 	int vol;
@@ -2570,26 +2573,31 @@ static struct initvol {
 	{SOUND_MIXER_WRITE_SPEAKER, 0x4040},
 	{SOUND_MIXER_WRITE_MIC, 0x0000}
 };
+#endif
 
 static int __init cs4297a_init(void)
 {
 	struct cs4297a_state *s;
-        u64 cfg;
-        u32 pwr, id;
+	u32 pwr, id;
 	mm_segment_t fs;
-        int rval, mdio_val;
+	int rval;
+#ifndef CONFIG_BCM_CS4297A_CSWARM
+	u64 cfg;
+	int mdio_val;
+#endif
 
 	CS_DBGOUT(CS_INIT | CS_FUNCTION, 2, printk(KERN_INFO 
 		"cs4297a: cs4297a_init_module()+ \n"));
 
-        mdio_val = in64(KSEG1 + A_MAC_REGISTER(2, R_MAC_MDIO)) &
+#ifndef CONFIG_BCM_CS4297A_CSWARM
+        mdio_val = __raw_readq(KSEG1 + A_MAC_REGISTER(2, R_MAC_MDIO)) &
                 (M_MAC_MDIO_DIR|M_MAC_MDIO_OUT);
 
         /* Check syscfg for synchronous serial on port 1 */
-        cfg = in64(KSEG1 + A_SCD_SYSTEM_CFG);
+        cfg = __raw_readq(KSEG1 + A_SCD_SYSTEM_CFG);
         if (!(cfg & M_SYS_SER1_ENABLE)) {
-                out64(cfg | M_SYS_SER1_ENABLE, KSEG1+A_SCD_SYSTEM_CFG);
-                cfg = in64(KSEG1 + A_SCD_SYSTEM_CFG);
+                __raw_writeq(cfg | M_SYS_SER1_ENABLE, KSEG1+A_SCD_SYSTEM_CFG);
+                cfg = __raw_readq(KSEG1 + A_SCD_SYSTEM_CFG);
                 if (!(cfg & M_SYS_SER1_ENABLE)) {
                   printk(KERN_INFO "cs4297a: serial port 1 not configured for synchronous operation\n");
                   return -1;
@@ -2599,14 +2607,15 @@ static int __init cs4297a_init(void)
                 
                 /* Force the codec (on SWARM) to reset by clearing
                    GENO, preserving MDIO (no effect on CSWARM) */
-                out64(mdio_val, KSEG1+A_MAC_REGISTER(2, R_MAC_MDIO));
+                __raw_writeq(mdio_val, KSEG1+A_MAC_REGISTER(2, R_MAC_MDIO));
                 udelay(10);
         }
 
         /* Now set GENO */
-        out64(mdio_val | M_MAC_GENC, KSEG1+A_MAC_REGISTER(2, R_MAC_MDIO));
+        __raw_writeq(mdio_val | M_MAC_GENC, KSEG1+A_MAC_REGISTER(2, R_MAC_MDIO));
         /* Give the codec some time to finish resetting (start the bit clock) */
         udelay(100);
+#endif
 
 	if (!(s = kmalloc(sizeof(struct cs4297a_state), GFP_KERNEL))) {
 		CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
@@ -2659,6 +2668,8 @@ static int __init cs4297a_init(void)
         } while (!rval && (pwr != 0xf));
 
         if (!rval) {
+		char *sb1250_duart_present;
+
                 fs = get_fs();
                 set_fs(KERNEL_DS);
 #if 0
@@ -2679,7 +2690,11 @@ static int __init cs4297a_init(void)
                 list_add(&s->list, &cs4297a_devs);
 
                 cs4297a_read_ac97(s, AC97_VENDOR_ID1, &id);
-                
+
+		sb1250_duart_present = symbol_get(sb1250_duart_present);
+		if (sb1250_duart_present)
+			sb1250_duart_present[1] = 0;
+
                 printk(KERN_INFO "cs4297a: initialized (vendor id = %x)\n", id);
 
                 CS_DBGOUT(CS_INIT | CS_FUNCTION, 2,
@@ -2718,9 +2733,7 @@ static void __exit cs4297a_cleanup(void)
 
 // --------------------------------------------------------------------- 
 
-EXPORT_NO_SYMBOLS;
-
-MODULE_AUTHOR("Kip Walker, kwalker@broadcom.com");
+MODULE_AUTHOR("Kip Walker, Broadcom Corp.");
 MODULE_DESCRIPTION("Cirrus Logic CS4297a Driver for Broadcom SWARM board");
 
 // --------------------------------------------------------------------- 
diff -purN linux-2.6.11-rc2-bk10/sound/pci/bt87x.c linux-2.6.11-rc3/sound/pci/bt87x.c
--- linux-2.6.11-rc2-bk10/sound/pci/bt87x.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc3/sound/pci/bt87x.c	2005-02-03 02:55:53.000000000 +0100
@@ -162,7 +162,7 @@ struct snd_bt87x {
 	snd_card_t *card;
 	struct pci_dev *pci;
 
-	void *mmio;
+	void __iomem *mmio;
 	int irq;
 
 	int dig_rate;
diff -purN linux-2.6.11-rc2-bk10/sound/pci/mixart/mixart_core.c linux-2.6.11-rc3/sound/pci/mixart/mixart_core.c
--- linux-2.6.11-rc2-bk10/sound/pci/mixart/mixart_core.c	2005-01-22 02:49:11.000000000 +0100
+++ linux-2.6.11-rc3/sound/pci/mixart/mixart_core.c	2005-02-03 02:56:53.000000000 +0100
@@ -95,7 +95,7 @@ static int get_msg(mixart_mgr_t *mgr, mi
 	}
 	size -= MSG_DESCRIPTOR_SIZE;
 
-	memcpy_fromio(resp->data, (void *)MIXART_MEM(mgr, msg_frame_address + MSG_HEADER_SIZE ), size);
+	memcpy_fromio(resp->data, MIXART_MEM(mgr, msg_frame_address + MSG_HEADER_SIZE ), size);
 	resp->size = size;
 
 	/* swap if necessary */
diff -purN linux-2.6.11-rc2-bk10/sound/pci/rme9652/hdsp.c linux-2.6.11-rc3/sound/pci/rme9652/hdsp.c
--- linux-2.6.11-rc2-bk10/sound/pci/rme9652/hdsp.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc3/sound/pci/rme9652/hdsp.c	2005-02-03 02:55:36.000000000 +0100
@@ -4958,7 +4958,7 @@ static int __devinit hdsp_request_fw_loa
 #ifdef SNDRV_BIG_ENDIAN
 	{
 		int i;
-		u32 *src = hdsp->data;
+		u32 *src = (void *)fw->data;
 		for (i = 0; i < ARRAY_SIZE(hdsp->firmware_cache); i++, src++)
 			hdsp->firmware_cache[i] = ((*src & 0x000000ff) << 16) |
 				((*src & 0x0000ff00) << 8)  |
