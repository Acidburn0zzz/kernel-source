From: Olaf Kirch <okir@suse.de>
Subject: 
References: SUSE41010 - LTC8781

This is a workaround for an interoperability problem with Solaris9 clients.
The Solaris client seems unable to grok large readdirplus replies (or, at least,
the replies generated by a Linux server). Linux-Linux works fine however with
any size of readdirplus.

Index: linux-2.6.14/fs/nfsd/nfs3xdr.c
===================================================================
--- linux-2.6.14.orig/fs/nfsd/nfs3xdr.c
+++ linux-2.6.14/fs/nfsd/nfs3xdr.c
@@ -29,6 +29,14 @@
 #endif
 
 
+/* By default, READDIRPLUS will return up the the max blocksize
+ * worth of data. Some Solaris clients do not seem to be able
+ * to grok this, and will retry the request forever.
+ * This allows to dumb the Linux nfsd down to a reply size
+ * that works (eg 8192).
+ */
+unsigned int	nfsd_max_readdirplus = NFSSVC_MAXBLKSIZE;
+
 /*
  * Mapping of S_IF* types to NFS file types
  */
@@ -569,7 +577,7 @@ nfs3svc_decode_readdirplusargs(struct sv
 	args->dircount = ntohl(*p++);
 	args->count    = ntohl(*p++);
 
-	len = (args->count > NFSSVC_MAXBLKSIZE) ? NFSSVC_MAXBLKSIZE :
+	len = (args->count > nfsd_max_readdirplus) ? nfsd_max_readdirplus :
 						  args->count;
 	args->count = len;
 
Index: linux-2.6.14/fs/nfsd/nfsctl.c
===================================================================
--- linux-2.6.14.orig/fs/nfsd/nfsctl.c
+++ linux-2.6.14/fs/nfsd/nfsctl.c
@@ -69,6 +69,9 @@ static ssize_t write_threads(struct file
 static ssize_t write_leasetime(struct file *file, char *buf, size_t size);
 static ssize_t write_recoverydir(struct file *file, char *buf, size_t size);
 
+
+extern unsigned int	nfsd_max_readdirplus;
+
 static ssize_t (*write_op[])(struct file *, char *, size_t) = {
 	[NFSD_Svc] = write_svc,
 	[NFSD_Add] = write_add,
@@ -417,6 +420,14 @@ static struct file_system_type nfsd_fs_t
 static struct ctl_table_header *nfs_sysctl_table;
 
 static ctl_table nfs_sysctls[] = {
+	{
+		.ctl_name	= -2,
+		.procname	= "nfsd_max_readdirplus",
+		.data		= &nfsd_max_readdirplus,
+		.maxlen		= sizeof(nfsd_max_readdirplus),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 
