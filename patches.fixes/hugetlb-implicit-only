Index: working-2.6/mm/mmap.c
===================================================================
--- working-2.6.orig/mm/mmap.c	2004-06-15 11:02:35.000000000 +1000
+++ working-2.6/mm/mmap.c	2004-06-15 11:19:18.050608696 +1000
@@ -33,6 +33,7 @@
 #include <linux/mount.h>
 #include <linux/objrmap.h>
 #include <linux/audit.h>
+#include <linux/err.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -74,6 +75,9 @@
 EXPORT_SYMBOL(sysctl_max_map_count);
 EXPORT_SYMBOL(vm_committed_space);
 
+int mmap_use_hugepages = 0;
+int mmap_hugepages_map_sz = 256;
+
 /*
  * Requires inode->i_mapping->i_shared_sem
  */
@@ -535,7 +539,7 @@
  * The caller must hold down_write(current->mm->mmap_sem).
  */
 
-unsigned long __do_mmap_pgoff(struct mm_struct *mm, struct file * file, 
+unsigned long __finish_do_mmap_pgoff(struct mm_struct *mm, struct file * file, 
 			    unsigned long addr, unsigned long len,
 			    unsigned long prot, unsigned long flags,
 			    unsigned long pgoff)
@@ -550,40 +554,19 @@
 	unsigned long charged = 0;
 	anon_vma_t * anon_vma_cache;
 
-	if (file) {
-		if (is_file_hugepages(file))
-			accountable = 0;
-
-		if (!file->f_op || !file->f_op->mmap)
-			return -ENODEV;
-
-		if ((prot & PROT_EXEC) && (file->f_vfsmnt->mnt_flags & MNT_NOEXEC))
-			return -EPERM;
-	}
-
-	if (!len)
-		return addr;
-
-	/* Careful about overflows.. */
-	len = PAGE_ALIGN(len);
-	if (!len || len > TASK_SIZE)
-		return -EINVAL;
-
-	/* offset overflow? */
-	if ((pgoff + (len >> PAGE_SHIFT)) < pgoff)
-		return -EINVAL;
-
-	/* Too many mappings? */
-	if (mm->map_count > sysctl_max_map_count)
-		return -ENOMEM;
-
-	/* Obtain the address to map to. we verify (or select) it and ensure
-	 * that it represents a valid section of the address space.
+	/* Obtain the address to map to. we verify (or select) it and
+	 * ensure that it represents a valid section of the address
+	 * space.  VM_HUGETLB will never appear in vm_flags when
+	 * CONFIG_HUGETLB is unset.
 	 */
 	addr = get_unmapped_area(file, addr, len, pgoff, flags);
 	if (addr & ~PAGE_MASK)
 		return addr;
 
+	/* Huge pages aren't accounted for here */
+	if (file && is_file_hugepages(file))
+		accountable = 0;
+
 	/* Do simple checking here so the lower-level routines won't have
 	 * to. we assume access permissions have been handled by the open
 	 * of the memory object, so we don't do any here.
@@ -786,11 +769,17 @@
 unmap_and_free_vma:
 	if (correct_wcount)
 		atomic_inc(&inode->i_writecount);
-	vma->vm_file = NULL;
-	fput(file);
 
-	/* Undo any partial mapping done by a device driver. */
+	/*
+	 * Undo any partial mapping done by a device driver.  
+	 * hugetlb wants to know the vma's file etc. so nuke  
+	 * the file afterward.                                
+	 */                                                   
 	zap_page_range(vma, vma->vm_start, vma->vm_end - vma->vm_start);
+
+	if (file)
+		fput(vma->vm_file); 
+
 free_vma:
 	kmem_cache_free(vm_area_cachep, vma);
 unacct_error:
@@ -799,6 +788,103 @@
 	return error;
 }
 
+#ifdef CONFIG_HUGETLBFS
+static int mmap_hugetlb_implicit(unsigned long len, unsigned long flags)
+{
+	/* Are we enabled? */
+	if (!mmap_use_hugepages)
+		return 0;
+	/* Must be HPAGE aligned */
+	if (len & ~HPAGE_MASK)
+		return 0;
+	if (! (flags & MAP_SHARED))
+		return 0;
+	/* Are we capable ? */
+	if (!can_do_mlock())
+		return 0;
+	/* Are we under the minimum size? */
+	if (mmap_hugepages_map_sz
+		&& len < (mmap_hugepages_map_sz << 20))
+		return 0;
+	/* Do we have enough huge pages ? */
+	if (!is_hugepage_mem_enough(len))
+		return 0;
+
+	return 1;
+}
+#else
+static inline int mmap_hugetlb_implicit(unsigned long len, unsigned long flags)
+{
+	return 0;
+}
+#endif /* CONFIG_HUGETLBFS */
+
+/*
+ * The caller must hold down_write(current->mm->mmap_sem).
+ */
+unsigned long __do_mmap_pgoff(struct mm_struct *mm, 
+		struct file * file, unsigned long addr,
+		unsigned long len, unsigned long prot,
+		unsigned long flags, unsigned long pgoff)
+{
+	struct file *hugetlb_file = NULL;
+	int hugetlb_implicit = 0;
+	unsigned long result;
+
+	if (file) {
+		if (!file->f_op || !file->f_op->mmap)
+			return -ENODEV;
+
+		if ((prot & PROT_EXEC) && (file->f_vfsmnt->mnt_flags & MNT_NOEXEC))
+			return -EPERM;
+	}
+
+	if (!len)
+		return addr;
+
+	/* Careful about overflows.. */
+	len = PAGE_ALIGN(len);
+	if (!len || len > TASK_SIZE)
+		return -EINVAL;
+
+	/* offset overflow? */
+	if ((pgoff + (len >> PAGE_SHIFT)) < pgoff)
+		return -EINVAL;
+
+	/* Too many mappings? */
+	if (current->mm->map_count > sysctl_max_map_count)
+		return -ENOMEM;
+
+	/* Create an implicit hugetlb file if necessary */
+	if (!file && (hugetlb_implicit = mmap_hugetlb_implicit(len, flags))) {
+		file = hugetlb_file = hugetlb_zero_setup(len);
+		if (IS_ERR(file)) {
+			if (!hugetlb_implicit)
+				return PTR_ERR(file);
+			file = hugetlb_file = NULL;
+			hugetlb_implicit = 0;
+		}
+	}
+
+again:
+	result = __finish_do_mmap_pgoff(mm, file, addr, len, prot, flags, pgoff);
+
+	/* Drop reference to implicit hugetlb file, it's already been
+	 * "gotten" in __finish_do_mmap_pgoff in case of success
+	 */
+	if (hugetlb_file)
+		fput(hugetlb_file);
+
+	/* If implicit huge tlb & we failed, try again without */
+	if ((result & ~PAGE_MASK) && hugetlb_implicit) {
+		hugetlb_implicit = 0;
+		file = NULL;
+		goto again;
+	}
+
+	return result;
+}
+
 EXPORT_SYMBOL(__do_mmap_pgoff);
 
 /* Get an address range which is currently unmapped.
Index: working-2.6/ipc/shm.c
===================================================================
--- working-2.6.orig/ipc/shm.c	2004-06-15 11:02:35.000000000 +1000
+++ working-2.6/ipc/shm.c	2004-06-15 11:18:05.068520080 +1000
@@ -33,6 +33,8 @@
 
 #define shm_flags	shm_perm.mode
 
+int shm_use_hugepages;
+
 static struct file_operations shm_file_operations;
 static struct vm_operations_struct shm_vm_ops;
 
@@ -168,6 +170,31 @@
 	.get_policy = shmem_get_policy,
 };
 
+#ifdef CONFIG_HUGETLBFS
+static int shm_with_hugepages(int shmflag, size_t size)
+{
+	/* flag specified explicitly */
+	if (shmflag & SHM_HUGETLB)
+		return 1;
+	/* Are we disabled? */
+	if (!shm_use_hugepages)
+		return 0;
+	/* Must be HPAGE aligned */
+	if (size & ~HPAGE_MASK)
+		return 0;
+	/* Do we have enough free huge pages? */
+	if (!is_hugepage_mem_enough(size))
+		return 0;
+	
+	return 1;
+}
+#else
+static inline int shm_with_hugepages(int shmflag, size_t size)
+{
+	return 0;
+}
+#endif
+
 static int newseg (key_t key, int shmflg, size_t size)
 {
 	int error;
@@ -197,9 +224,10 @@
 		return error;
 	}
 
-	if (shmflg & SHM_HUGETLB)
+	if (shm_with_hugepages(shmflg, size)) {
+		shmflg |= SHM_HUGETLB;
 		file = hugetlb_zero_setup(size);
-	else {
+	} else {
 		sprintf (name, "SYSV%08x", key);
 		file = shmem_file_setup(name, size, VM_ACCOUNT);
 	}
Index: working-2.6/kernel/sysctl.c
===================================================================
--- working-2.6.orig/kernel/sysctl.c	2004-06-15 11:02:33.000000000 +1000
+++ working-2.6/kernel/sysctl.c	2004-06-15 11:18:05.070519776 +1000
@@ -68,6 +68,8 @@
 extern int min_free_kbytes;
 extern int printk_ratelimit_jiffies;
 extern int printk_ratelimit_burst;
+extern int shm_use_hugepages;
+extern int mmap_use_hugepages, mmap_hugepages_map_sz;
 
 /* this is needed for the proc_dointvec_minmax for [fs_]overflow UID and GID */
 static int maxolduid = 65535;
@@ -674,6 +676,32 @@
 		.mode		= 0444,
 		.proc_handler	= &proc_dointvec,
 	},
+#ifdef CONFIG_HUGETLBFS
+	{
+		.ctl_name	= KERN_SHMUSEHUGEPAGES,
+		.procname	= "shm-use-hugepages",
+		.data		= &shm_use_hugepages,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= KERN_MMAPUSEHUGEPAGES,
+		.procname	= "mmap-use-hugepages",
+		.data		= &mmap_use_hugepages,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= KERN_HPAGES_MAP_SZ,
+		.procname	= "mmap-hugepages-min-mapping",
+		.data		= &mmap_hugepages_map_sz,
+		.maxlen		= sizeof(int),
+		.mode		0644,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
Index: working-2.6/include/linux/sysctl.h
===================================================================
--- working-2.6.orig/include/linux/sysctl.h	2004-06-15 11:02:33.000000000 +1000
+++ working-2.6/include/linux/sysctl.h	2004-06-15 11:32:56.852605960 +1000
@@ -137,6 +137,10 @@
 	KERN_MAXTIMESLICE=67,	/* int: nice -20 max timeslice */
 	KERN_MINTIMESLICE=68,	/* int: nice +19 min timeslice */
 	KERN_HZ=69,		/* unsigned long: interal kernel HZ */
+	KERN_SHMUSEHUGEPAGES=70,/* int: back shm with huge pages */
+	KERN_MMAPUSEHUGEPAGES=71,       /* int: back anon mmap with hpages */
+	KERN_HPAGES_MAP_SZ=72,  /* int: min size (MB) of mapping */
+
 };
 
 
