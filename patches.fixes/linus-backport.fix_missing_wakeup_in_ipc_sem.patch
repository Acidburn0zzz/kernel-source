Subject: [PATCH] fix missing wakeup in ipc/sem
X-BK-ChangeSetKey: manfred@colorfullife.com[torvalds]|ChangeSet|20050105053413|42326
Date:	Wed, 05 Jan 2005 17:11:09 +0000
Patch-mainline: yes
From: olh@suse.de


ChangeSet 1.2109, 2005/01/04 21:34:13-08:00, manfred@colorfullife.com

	[PATCH] fix missing wakeup in ipc/sem
	
	My patch that removed the spin_lock calls from the tail of sys_semtimedop
	introduced a bug:
	
	Before my patch was merged, every operation that altered an array called
	update_queue.  That call woke up threads that were waiting until a
	semaphore value becomes 0.  I've accidentially removed that call.
	
	The attached patch fixes that by modifying update_queue: the function now
	loops internally and wakes up all threads.  The patch also removes
	update_queue calls from the error path of sys_semtimedop: failed operations
	do not modify the array, no need to rescan the list of waiting threads.
	
	Signed-Off-By: Manfred Spraul <manfred@colorfullife.com>
	Signed-off-by: Andrew Morton <akpm@osdl.org>
	Signed-off-by: Linus Torvalds <torvalds@osdl.org>



 include/linux/sem.h |    1 +
 ipc/sem.c           |   27 +++++++++++++++++++++------
 2 files changed, 22 insertions(+), 6 deletions(-)


diff -Nru a/include/linux/sem.h b/include/linux/sem.h
--- a/include/linux/sem.h	2005-01-04 23:28:47 -08:00
+++ b/include/linux/sem.h	2005-01-04 23:28:47 -08:00
@@ -109,6 +109,7 @@
 	int			id;	 /* internal sem id */
 	struct sembuf *		sops;	 /* array of pending operations */
 	int			nsops;	 /* number of operations */
+	int			alter;   /* does the operation alter the array? */
 };
 
 /* Each task has a list of undo requests. They are executed automatically
diff -Nru a/ipc/sem.c b/ipc/sem.c
--- a/ipc/sem.c	2005-01-04 23:28:47 -08:00
+++ b/ipc/sem.c	2005-01-04 23:28:47 -08:00
@@ -358,8 +358,22 @@
 		if (error <= 0) {
 			struct sem_queue *n;
 			remove_from_queue(sma,q);
-			n = q->next;
 			q->status = IN_WAKEUP;
+			/*
+			 * Continue scanning. The next operation
+			 * that must be checked depends on the type of the
+			 * completed operation:
+			 * - if the operation modified the array, then
+			 *   restart from the head of the queue and
+			 *   check for threads that might be waiting
+			 *   for semaphore values to become 0.
+			 * - if the operation didn't modify the array,
+			 *   then just continue.
+			 */
+			if (q->alter)
+				n = sma->sem_pending;
+			else
+				n = q->next;
 			wake_up_process(q->sleeper);
 			/* hands-off: q will disappear immediately after
 			 * writing q->status.
@@ -1119,8 +1133,11 @@
 		goto out_unlock_free;
 
 	error = try_atomic_semop (sma, sops, nsops, un, current->tgid);
-	if (error <= 0)
-		goto update;
+	if (error <= 0) {
+		if (alter && error == 0)
+			update_queue (sma);
+		goto out_unlock_free;
+	}
 
 	/* We need to sleep on this operation, so we put the current
 	 * task into the pending queue and go to sleep.
@@ -1132,6 +1149,7 @@
 	queue.undo = un;
 	queue.pid = current->tgid;
 	queue.id = semid;
+	queue.alter = alter;
 	if (alter)
 		append_to_queue(sma ,&queue);
 	else
@@ -1183,9 +1201,6 @@
 	remove_from_queue(sma,&queue);
 	goto out_unlock_free;
 
-update:
-	if (alter)
-		update_queue (sma);
 out_unlock_free:
 	sem_unlock(sma);
 out_free:
-
To unsubscribe from this list: send the line "unsubscribe bk-commits-head" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

