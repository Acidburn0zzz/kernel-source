From: olh@suse.de
Subject: patch-2.6.11-rc5-bk2

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc5-bk1.log	2005-02-26 13:31:07.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc5-bk2.log	2005-02-27 13:32:06.000000000 +0100
 ChangeSet@1.2063, 2005-02-26 10:12:16-08:00, torvalds@ppc970.osdl.org
   Properly limit keyboard keycodes to KEY_MAX.
   
   It can only be set by root, but let's not tempt people to do
   things that can't work.
 
 ChangeSet@1.2062, 2005-02-26 10:03:27-08:00, Andries.Brouwer@cwi.nl
   [PATCH] more apic.c
   
   setup_APIC_timer is only called in __init context and uses __initdata
 
 ChangeSet@1.2061, 2005-02-26 10:03:13-08:00, Andries.Brouwer@cwi.nl
   [PATCH] __initdata in apic.c
   
   wait_timer_tick refers to the __init functions wait_8254_wraparound
   or wait_hpet_tick, hence must be __initdata.
 
 ChangeSet@1.2060, 2005-02-26 10:02:59-08:00, Andries.Brouwer@cwi.nl
   [PATCH] remove __initdata in scsi_devinfo.c
   
   scsi_dev_flags is referred to in
   module_param_string(dev_flags, scsi_dev_flags, sizeof(scsi_dev_flags), 0);
 
 ChangeSet@1.2059, 2005-02-26 10:02:45-08:00, Andries.Brouwer@cwi.nl
   [PATCH] __init in cfq-iosched.c
   
   cfq_init() calls __init cfq_slab_setup and hence must be __init itself
   
   also made it static
 
 ChangeSet@1.2058, 2005-02-26 10:02:30-08:00, Andries.Brouwer@cwi.nl
   [PATCH] __devinitdata in parport_pc
   
   parport_init_mode is referred to in int __devinit sio_via_probe().
 
 ChangeSet@1.2035.21.6, 2005-02-23 20:02:03-08:00, davem@nuts.davemloft.net
   Merge bk://bk.skbuff.net:20611/linux-2.6-sysctl/
   into nuts.davemloft.net:/disk1/BK/net-2.6
 
 ChangeSet@1.2035.21.5, 2005-02-23 19:59:02-08:00, robert.olsson@data.slu.se
   [PKTGEN]: reduce stack usage
   
   From Randy Dunlap
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2035.21.4, 2005-02-23 19:50:04-08:00, laforge@netfilter.org
   [NETFILTER]: ipt_hashlimit rule load time race condition
   
   This is the best we've got: We cannot release and re-grab lock,
   since checkentry() is called before ip_tables.c grabs ipt_mutex.  
   We also cannot grab the hashtable spinlock, since htable_create will 
   call vmalloc, and that can sleep.  And we cannot just re-search
   the list of htable's in htable_create(), since then we would
   create duplicate proc files.
   
   Signed-off-by: Harald Welte <laforge@netfilter.org>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2035.21.3, 2005-02-23 19:48:15-08:00, robert.olsson@data.slu.se
   [PKTGEN]: Replace interruptible_sleep_on_timeout()
   
   From Nishanth Aravamudan <nacc@us.ibm.com>
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2035.21.2, 2005-02-23 19:44:58-08:00, yoshfuji@linux-ipv6.org
   [IPV6]: Unregister per-device snmp6 proc entry earlier.
   
   Do it in addrconf_ifdown.  This fixes OOPSes on shutdown
   with 2.6.10
   
   Signed-off-by: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
   Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2035.21.1, 2005-02-23 19:38:18-08:00, kaber@trash.net
   [NETFILTER]: Prevent NAT from seeing fragments
   
   The path for loopback is:
   LOCAL_OUT: conntrack defrags
   POST_ROUTING: conntrack refrags
   PRE_ROUTING: skip conntrack defrag because skb->nfct != NULL
   PRE_ROUTING: NAT gets hit by fragments
   
   Always defrag on loopback if NAT is compiled in.
   
   Signed-off-by: Patrick McHardy <kaber@trash.net>
   Acked-by: Rusty Russel <rusty@rustcorp.com.au>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
diff -purN linux-2.6.11-rc5-bk1/Makefile linux-2.6.11-rc5-bk2/Makefile
--- linux-2.6.11-rc5-bk1/Makefile	2005-02-27 14:53:30.041618098 +0100
+++ linux-2.6.11-rc5-bk2/Makefile	2005-02-27 14:53:35.632680856 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc5-bk1
+EXTRAVERSION = -rc5-bk2
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc5-bk1/arch/i386/kernel/apic.c linux-2.6.11-rc5-bk2/arch/i386/kernel/apic.c
--- linux-2.6.11-rc5-bk1/arch/i386/kernel/apic.c	2005-02-24 05:03:37.000000000 +0100
+++ linux-2.6.11-rc5-bk2/arch/i386/kernel/apic.c	2005-02-27 14:53:35.636680233 +0100
@@ -894,7 +894,7 @@ static void __init wait_8254_wraparound(
  * Default initialization for 8254 timers. If we use other timers like HPET,
  * we override this later
  */
-void (*wait_timer_tick)(void) = wait_8254_wraparound;
+void (*wait_timer_tick)(void) __initdata = wait_8254_wraparound;
 
 /*
  * This function sets up the local APIC timer, with a timeout of
@@ -930,7 +930,7 @@ void __setup_APIC_LVTT(unsigned int cloc
 	apic_write_around(APIC_TMICT, clocks/APIC_DIVISOR);
 }
 
-static void setup_APIC_timer(unsigned int clocks)
+static void __init setup_APIC_timer(unsigned int clocks)
 {
 	unsigned long flags;
 
diff -purN linux-2.6.11-rc5-bk1/drivers/block/cfq-iosched.c linux-2.6.11-rc5-bk2/drivers/block/cfq-iosched.c
--- linux-2.6.11-rc5-bk1/drivers/block/cfq-iosched.c	2005-02-24 05:03:05.000000000 +0100
+++ linux-2.6.11-rc5-bk2/drivers/block/cfq-iosched.c	2005-02-27 14:53:35.640679611 +0100
@@ -1819,7 +1819,7 @@ static struct elevator_type iosched_cfq 
 	.elevator_owner =	THIS_MODULE,
 };
 
-int cfq_init(void)
+static int __init cfq_init(void)
 {
 	int ret;
 
diff -purN linux-2.6.11-rc5-bk1/drivers/char/keyboard.c linux-2.6.11-rc5-bk2/drivers/char/keyboard.c
--- linux-2.6.11-rc5-bk1/drivers/char/keyboard.c	2005-02-24 05:03:50.000000000 +0100
+++ linux-2.6.11-rc5-bk2/drivers/char/keyboard.c	2005-02-27 14:53:35.642679299 +0100
@@ -198,6 +198,8 @@ int setkeycode(unsigned int scancode, un
 
 	if (scancode < 0 || scancode >= dev->keycodemax)
 		return -EINVAL;
+	if (keycode < 0 || keycode > KEY_MAX)
+		return -EINVAL;
 
 	oldkey = SET_INPUT_KEYCODE(dev, scancode, keycode);
 
diff -purN linux-2.6.11-rc5-bk1/drivers/parport/parport_pc.c linux-2.6.11-rc5-bk2/drivers/parport/parport_pc.c
--- linux-2.6.11-rc5-bk1/drivers/parport/parport_pc.c	2005-02-24 05:03:28.000000000 +0100
+++ linux-2.6.11-rc5-bk2/drivers/parport/parport_pc.c	2005-02-27 14:53:35.648678365 +0100
@@ -2488,7 +2488,7 @@ static int __devinit sio_ite_8872_probe 
 
 /* VIA 8231 support by Pavel Fedin <sonic_amiga@rambler.ru>
    based on VIA 686a support code by Jeff Garzik <jgarzik@pobox.com> */
-static int __initdata parport_init_mode = 0;
+static int __devinitdata parport_init_mode = 0;
 
 /* Data for two known VIA chips */
 static struct parport_pc_via_data via_686a_data __devinitdata = {
diff -purN linux-2.6.11-rc5-bk1/drivers/scsi/scsi_devinfo.c linux-2.6.11-rc5-bk2/drivers/scsi/scsi_devinfo.c
--- linux-2.6.11-rc5-bk1/drivers/scsi/scsi_devinfo.c	2005-02-24 05:02:37.000000000 +0100
+++ linux-2.6.11-rc5-bk2/drivers/scsi/scsi_devinfo.c	2005-02-27 14:53:35.650678054 +0100
@@ -28,7 +28,7 @@ struct scsi_dev_info_list {
 static const char spaces[] = "                "; /* 16 of them */
 static unsigned scsi_default_dev_flags;
 static LIST_HEAD(scsi_dev_info_list);
-static __initdata char scsi_dev_flags[256];
+static char scsi_dev_flags[256];
 
 /*
  * scsi_static_device_list: deprecated list of devices that require
diff -purN linux-2.6.11-rc5-bk1/include/linux/sysctl.h linux-2.6.11-rc5-bk2/include/linux/sysctl.h
--- linux-2.6.11-rc5-bk1/include/linux/sysctl.h	2005-02-24 05:03:00.000000000 +0100
+++ linux-2.6.11-rc5-bk2/include/linux/sysctl.h	2005-02-27 14:53:35.662676185 +0100
@@ -797,6 +797,8 @@ extern int proc_dointvec_jiffies(ctl_tab
 				 void __user *, size_t *, loff_t *);
 extern int proc_dointvec_userhz_jiffies(ctl_table *, int, struct file *,
 					void __user *, size_t *, loff_t *);
+extern int proc_dointvec_ms_jiffies(ctl_table *, int, struct file *,
+				    void __user *, size_t *, loff_t *);
 extern int proc_doulongvec_minmax(ctl_table *, int, struct file *,
 				  void __user *, size_t *, loff_t *);
 extern int proc_doulongvec_ms_jiffies_minmax(ctl_table *table, int,
@@ -814,6 +816,7 @@ extern int do_sysctl_strategy (ctl_table
 extern ctl_handler sysctl_string;
 extern ctl_handler sysctl_intvec;
 extern ctl_handler sysctl_jiffies;
+extern ctl_handler sysctl_ms_jiffies;
 
 
 /*
diff -purN linux-2.6.11-rc5-bk1/include/net/ipv6.h linux-2.6.11-rc5-bk2/include/net/ipv6.h
--- linux-2.6.11-rc5-bk1/include/net/ipv6.h	2005-02-24 05:03:10.000000000 +0100
+++ linux-2.6.11-rc5-bk2/include/net/ipv6.h	2005-02-27 14:53:35.663676030 +0100
@@ -149,6 +149,8 @@ extern atomic_t			inet6_sock_nr;
 
 int snmp6_register_dev(struct inet6_dev *idev);
 int snmp6_unregister_dev(struct inet6_dev *idev);
+int snmp6_alloc_dev(struct inet6_dev *idev);
+int snmp6_free_dev(struct inet6_dev *idev);
 int snmp6_mib_init(void *ptr[2], size_t mibsize, size_t mibalign);
 void snmp6_mib_free(void *ptr[2]);
 
diff -purN linux-2.6.11-rc5-bk1/kernel/sysctl.c linux-2.6.11-rc5-bk2/kernel/sysctl.c
--- linux-2.6.11-rc5-bk1/kernel/sysctl.c	2005-02-24 05:02:21.000000000 +0100
+++ linux-2.6.11-rc5-bk2/kernel/sysctl.c	2005-02-27 14:53:35.668675251 +0100
@@ -1902,6 +1902,27 @@ static int do_proc_dointvec_userhz_jiffi
 	return 0;
 }
 
+static int do_proc_dointvec_ms_jiffies_conv(int *negp, unsigned long *lvalp,
+					    int *valp,
+					    int write, void *data)
+{
+	if (write) {
+		*valp = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);
+	} else {
+		int val = *valp;
+		unsigned long lval;
+		if (val < 0) {
+			*negp = -1;
+			lval = (unsigned long)-val;
+		} else {
+			*negp = 0;
+			lval = (unsigned long)val;
+		}
+		*lvalp = jiffies_to_msecs(lval);
+	}
+	return 0;
+}
+
 /**
  * proc_dointvec_jiffies - read a vector of integers as seconds
  * @table: the sysctl table
@@ -1946,6 +1967,28 @@ int proc_dointvec_userhz_jiffies(ctl_tab
 		    	    do_proc_dointvec_userhz_jiffies_conv,NULL);
 }
 
+/**
+ * proc_dointvec_ms_jiffies - read a vector of integers as 1 milliseconds
+ * @table: the sysctl table
+ * @write: %TRUE if this is a write to the sysctl file
+ * @filp: the file structure
+ * @buffer: the user buffer
+ * @lenp: the size of the user buffer
+ *
+ * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+ * values from/to the user buffer, treated as an ASCII string. 
+ * The values read are assumed to be in 1/1000 seconds, and 
+ * are converted into jiffies.
+ *
+ * Returns 0 on success.
+ */
+int proc_dointvec_ms_jiffies(ctl_table *table, int write, struct file *filp,
+			     void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	return do_proc_dointvec(table, write, filp, buffer, lenp, ppos,
+				do_proc_dointvec_ms_jiffies_conv, NULL);
+}
+
 #else /* CONFIG_PROC_FS */
 
 int proc_dostring(ctl_table *table, int write, struct file *filp,
@@ -1990,6 +2033,12 @@ int proc_dointvec_userhz_jiffies(ctl_tab
 	return -ENOSYS;
 }
 
+int proc_dointvec_ms_jiffies(ctl_table *table, int write, struct file *filp,
+			     void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	return -ENOSYS;
+}
+
 int proc_doulongvec_minmax(ctl_table *table, int write, struct file *filp,
 		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
@@ -2119,6 +2168,33 @@ int sysctl_jiffies(ctl_table *table, int
 	return 1;
 }
 
+/* Strategy function to convert jiffies to seconds */ 
+int sysctl_ms_jiffies(ctl_table *table, int __user *name, int nlen,
+		void __user *oldval, size_t __user *oldlenp,
+		void __user *newval, size_t newlen, void **context)
+{
+	if (oldval) {
+		size_t olen;
+		if (oldlenp) { 
+			if (get_user(olen, oldlenp))
+				return -EFAULT;
+			if (olen!=sizeof(int))
+				return -EINVAL; 
+		}
+		if (put_user(jiffies_to_msecs(*(int *)(table->data)), (int __user *)oldval) ||
+		    (oldlenp && put_user(sizeof(int),oldlenp)))
+			return -EFAULT;
+	}
+	if (newval && newlen) { 
+		int new;
+		if (newlen != sizeof(int))
+			return -EINVAL; 
+		if (get_user(new, (int __user *)newval))
+			return -EFAULT;
+		*(int *)(table->data) = msecs_to_jiffies(new);
+	}
+	return 1;
+}
 
 #else /* CONFIG_SYSCTL */
 
@@ -2149,6 +2225,13 @@ int sysctl_jiffies(ctl_table *table, int
 	return -ENOSYS;
 }
 
+int sysctl_ms_jiffies(ctl_table *table, int __user *name, int nlen,
+		void __user *oldval, size_t __user *oldlenp,
+		void __user *newval, size_t newlen, void **context)
+{
+	return -ENOSYS;
+}
+
 int proc_dostring(ctl_table *table, int write, struct file *filp,
 		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
@@ -2185,6 +2268,12 @@ int proc_dointvec_userhz_jiffies(ctl_tab
 	return -ENOSYS;
 }
 
+int proc_dointvec_ms_jiffies(ctl_table *table, int write, struct file *filp,
+			     void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	return -ENOSYS;
+}
+
 int proc_doulongvec_minmax(ctl_table *table, int write, struct file *filp,
 		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
@@ -2219,11 +2308,13 @@ EXPORT_SYMBOL(proc_dointvec);
 EXPORT_SYMBOL(proc_dointvec_jiffies);
 EXPORT_SYMBOL(proc_dointvec_minmax);
 EXPORT_SYMBOL(proc_dointvec_userhz_jiffies);
+EXPORT_SYMBOL(proc_dointvec_ms_jiffies);
 EXPORT_SYMBOL(proc_dostring);
 EXPORT_SYMBOL(proc_doulongvec_minmax);
 EXPORT_SYMBOL(proc_doulongvec_ms_jiffies_minmax);
 EXPORT_SYMBOL(register_sysctl_table);
 EXPORT_SYMBOL(sysctl_intvec);
 EXPORT_SYMBOL(sysctl_jiffies);
+EXPORT_SYMBOL(sysctl_ms_jiffies);
 EXPORT_SYMBOL(sysctl_string);
 EXPORT_SYMBOL(unregister_sysctl_table);
diff -purN linux-2.6.11-rc5-bk1/net/core/pktgen.c linux-2.6.11-rc5-bk2/net/core/pktgen.c
--- linux-2.6.11-rc5-bk1/net/core/pktgen.c	2005-02-24 05:03:54.000000000 +0100
+++ linux-2.6.11-rc5-bk2/net/core/pktgen.c	2005-02-27 14:53:35.675674162 +0100
@@ -104,6 +104,8 @@
  * Corrections from Nikolai Malykh (nmalykh@bilim.com) 
  * Removed unused flags F_SET_SRCMAC & F_SET_SRCIP 041230
  *
+ * interruptible_sleep_on_timeout() replaced Nishanth Aravamudan <nacc@us.ibm.com> 
+ * 050103
  */
 #include <linux/sys.h>
 #include <linux/types.h>
@@ -135,6 +137,7 @@
 #include <linux/ipv6.h>
 #include <linux/udp.h>
 #include <linux/proc_fs.h>
+#include <linux/wait.h>
 #include <net/checksum.h>
 #include <net/ipv6.h>
 #include <net/addrconf.h>
@@ -148,7 +151,7 @@
 #include <asm/timex.h>
 
 
-#define VERSION  "pktgen v2.56: Packet Generator for packet performance testing.\n"
+#define VERSION  "pktgen v2.58: Packet Generator for packet performance testing.\n"
 
 /* #define PG_DEBUG(a) a */
 #define PG_DEBUG(a) 
@@ -808,6 +811,7 @@ static int proc_if_write(struct file *fi
         struct pktgen_dev *pkt_dev = (struct pktgen_dev*)(data);
         char* pg_result = NULL;
         int tmp = 0;
+	char buf[128];
         
         pg_result = &(pkt_dev->result[0]);
         
@@ -1068,7 +1072,6 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "dst_min") || !strcmp(name, "dst")) {
-                char buf[IP_NAME_SZ];
 		len = strn_len(&user_buffer[i], sizeof(pkt_dev->dst_min) - 1);
                 if (len < 0) { return len; }
 
@@ -1088,7 +1091,6 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "dst_max")) {
-                char buf[IP_NAME_SZ];
 		len = strn_len(&user_buffer[i], sizeof(pkt_dev->dst_max) - 1);
                 if (len < 0) { return len; }
 
@@ -1109,9 +1111,7 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "dst6")) {
-                char buf[128];
-
-		len = strn_len(&user_buffer[i], 128 - 1);
+		len = strn_len(&user_buffer[i], sizeof(buf) - 1);
                 if (len < 0) return len; 
 
 		pkt_dev->flags |= F_IPV6;
@@ -1133,9 +1133,7 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "dst6_min")) {
-                char buf[128];
-
-		len = strn_len(&user_buffer[i], 128 - 1);
+		len = strn_len(&user_buffer[i], sizeof(buf) - 1);
                 if (len < 0) return len; 
 
 		pkt_dev->flags |= F_IPV6;
@@ -1156,9 +1154,7 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "dst6_max")) {
-                char buf[128];
-
-		len = strn_len(&user_buffer[i], 128 - 1);
+		len = strn_len(&user_buffer[i], sizeof(buf) - 1);
                 if (len < 0) return len; 
 
 		pkt_dev->flags |= F_IPV6;
@@ -1178,9 +1174,7 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "src6")) {
-                char buf[128];
-
-		len = strn_len(&user_buffer[i], 128 - 1);
+		len = strn_len(&user_buffer[i], sizeof(buf) - 1);
                 if (len < 0) return len; 
 
 		pkt_dev->flags |= F_IPV6;
@@ -1202,7 +1196,6 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "src_min")) {
-                char buf[IP_NAME_SZ];
 		len = strn_len(&user_buffer[i], sizeof(pkt_dev->src_min) - 1);
                 if (len < 0) { return len; }
                 if (copy_from_user(buf, &user_buffer[i], len))
@@ -1221,7 +1214,6 @@ static int proc_if_write(struct file *fi
 		return count;
 	}
 	if (!strcmp(name, "src_max")) {
-                char buf[IP_NAME_SZ];
 		len = strn_len(&user_buffer[i], sizeof(pkt_dev->src_max) - 1);
                 if (len < 0) { return len; }
                 if (copy_from_user(buf, &user_buffer[i], len))
@@ -2402,16 +2394,14 @@ static int thread_is_running(struct pktg
 
 static int pktgen_wait_thread_run(struct pktgen_thread *t )
 {
-        wait_queue_head_t queue;
-        
-        init_waitqueue_head(&queue);
-        
         if_lock(t);
 
         while(thread_is_running(t)) {
+
                 if_unlock(t);
-        
-                interruptible_sleep_on_timeout(&queue, HZ/10);
+
+		msleep_interruptible(100); 
+
                 if (signal_pending(current)) 
                         goto signal;
                 if_lock(t);
@@ -2738,6 +2728,7 @@ retry_now:
 
 static void pktgen_thread_worker(struct pktgen_thread *t) 
 {
+	DEFINE_WAIT(wait);
         struct pktgen_dev *pkt_dev = NULL;
 	int cpu = t->cpu;
 	sigset_t tmpsig;
@@ -2805,9 +2796,11 @@ static void pktgen_thread_worker(struct 
 					do_softirq();
 				tx_since_softirq = 0;
 			}
+		} else {
+			prepare_to_wait(&(t->queue), &wait, TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+			finish_wait(&(t->queue), &wait);
 		}
-                else 
-                        interruptible_sleep_on_timeout(&(t->queue), HZ/10);
 
                 /* 
 		 * Back from sleep, either due to the timeout or signal.
@@ -3117,8 +3110,7 @@ static void __exit pg_cleanup(void)
                 struct pktgen_thread *t = pktgen_threads;
                 pktgen_threads->control |= (T_TERMINATE);
 
-                while( t == pktgen_threads) 
-                        interruptible_sleep_on_timeout(&queue, HZ);
+		wait_event_interruptible_timeout(queue, (t != pktgen_threads), HZ);
         }
 
         /* Un-register us from receiving netdevice events */
diff -purN linux-2.6.11-rc5-bk1/net/ipv4/netfilter/ip_conntrack_standalone.c linux-2.6.11-rc5-bk2/net/ipv4/netfilter/ip_conntrack_standalone.c
--- linux-2.6.11-rc5-bk1/net/ipv4/netfilter/ip_conntrack_standalone.c	2005-02-24 05:02:38.000000000 +0100
+++ linux-2.6.11-rc5-bk2/net/ipv4/netfilter/ip_conntrack_standalone.c	2005-02-27 14:53:35.677673850 +0100
@@ -384,10 +384,12 @@ static unsigned int ip_conntrack_defrag(
 				        const struct net_device *out,
 				        int (*okfn)(struct sk_buff *))
 {
+#if !defined(CONFIG_IP_NF_NAT) && !defined(CONFIG_IP_NF_NAT_MODULE)
 	/* Previously seen (loopback)?  Ignore.  Do this before
            fragment check. */
 	if ((*pskb)->nfct)
 		return NF_ACCEPT;
+#endif
 
 	/* Gather fragments. */
 	if ((*pskb)->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
diff -purN linux-2.6.11-rc5-bk1/net/ipv4/netfilter/ipt_hashlimit.c linux-2.6.11-rc5-bk2/net/ipv4/netfilter/ipt_hashlimit.c
--- linux-2.6.11-rc5-bk1/net/ipv4/netfilter/ipt_hashlimit.c	2005-02-24 05:02:46.000000000 +0100
+++ linux-2.6.11-rc5-bk2/net/ipv4/netfilter/ipt_hashlimit.c	2005-02-27 14:53:35.679673539 +0100
@@ -98,6 +98,7 @@ struct ipt_hashlimit_htable {
 };
 
 static DECLARE_RWLOCK(hashlimit_lock);	/* protects htables list */
+static DECLARE_MUTEX(hlimit_mutex);	/* additional checkentry protection */
 static LIST_HEAD(hashlimit_htables);
 static kmem_cache_t *hashlimit_cachep;
 
@@ -531,10 +532,19 @@ hashlimit_checkentry(const char *tablena
 	if (!r->cfg.expire)
 		return 0;
 
+	/* This is the best we've got: We cannot release and re-grab lock,
+	 * since checkentry() is called before ip_tables.c grabs ipt_mutex.  
+	 * We also cannot grab the hashtable spinlock, since htable_create will 
+	 * call vmalloc, and that can sleep.  And we cannot just re-search
+	 * the list of htable's in htable_create(), since then we would
+	 * create duplicate proc files. -HW */
+	down(&hlimit_mutex);
 	r->hinfo = htable_find_get(r->name);
 	if (!r->hinfo && (htable_create(r) != 0)) {
+		up(&hlimit_mutex);
 		return 0;
 	}
+	up(&hlimit_mutex);
 
 	/* Ugly hack: For SMP, we only want to use one set */
 	r->u.master = r;
diff -purN linux-2.6.11-rc5-bk1/net/ipv4/route.c linux-2.6.11-rc5-bk2/net/ipv4/route.c
--- linux-2.6.11-rc5-bk1/net/ipv4/route.c	2005-02-24 05:03:55.000000000 +0100
+++ linux-2.6.11-rc5-bk2/net/ipv4/route.c	2005-02-27 14:53:35.683672916 +0100
@@ -2545,10 +2545,10 @@ ctl_table ipv4_route_table[] = {
 		.ctl_name	= NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS,
 		.procname	= "gc_min_interval_ms",
 		.data		= &ip_rt_gc_min_interval,
-		.maxlen		= sizeof(unsigned long),
+		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= &proc_doulongvec_ms_jiffies_minmax,
-		.strategy	= &sysctl_jiffies,
+		.proc_handler	= &proc_dointvec_ms_jiffies,
+		.strategy	= &sysctl_ms_jiffies,
 	},
 	{
 		.ctl_name	= NET_IPV4_ROUTE_GC_TIMEOUT,
diff -purN linux-2.6.11-rc5-bk1/net/ipv6/addrconf.c linux-2.6.11-rc5-bk2/net/ipv6/addrconf.c
--- linux-2.6.11-rc5-bk1/net/ipv6/addrconf.c	2005-02-24 05:03:27.000000000 +0100
+++ linux-2.6.11-rc5-bk2/net/ipv6/addrconf.c	2005-02-27 14:53:35.691671671 +0100
@@ -308,7 +308,7 @@ void in6_dev_finish_destroy(struct inet6
 		printk("Freeing alive inet6 device %p\n", idev);
 		return;
 	}
-	snmp6_unregister_dev(idev);
+	snmp6_free_dev(idev);
 	kfree(idev);
 }
 
@@ -339,6 +339,16 @@ static struct inet6_dev * ipv6_add_dev(s
 		/* We refer to the device */
 		dev_hold(dev);
 
+		if (snmp6_alloc_dev(ndev) < 0) {
+			ADBG((KERN_WARNING
+				"%s(): cannot allocate memory for statistics; dev=%s.\n",
+				__FUNCTION__, dev->name));
+			neigh_parms_release(&nd_tbl, ndev->nd_parms);
+			ndev->dead = 1;
+			in6_dev_finish_destroy(ndev);
+			return NULL;
+		}
+
 		if (snmp6_register_dev(ndev) < 0) {
 			ADBG((KERN_WARNING
 				"%s(): cannot create /proc/net/dev_snmp6/%s\n",
@@ -2013,6 +2023,10 @@ static int addrconf_ifdown(struct net_de
 		dev->ip6_ptr = NULL;
 		idev->dead = 1;
 		write_unlock_bh(&addrconf_lock);
+
+		/* Step 1.5: remove snmp6 entry */
+		snmp6_unregister_dev(idev);
+
 	}
 
 	/* Step 2: clear hash table */
diff -purN linux-2.6.11-rc5-bk1/net/ipv6/af_inet6.c linux-2.6.11-rc5-bk2/net/ipv6/af_inet6.c
--- linux-2.6.11-rc5-bk1/net/ipv6/af_inet6.c	2005-02-24 05:03:03.000000000 +0100
+++ linux-2.6.11-rc5-bk2/net/ipv6/af_inet6.c	2005-02-27 14:53:35.693671359 +0100
@@ -652,8 +652,10 @@ snmp6_mib_free(void *ptr[2])
 {
 	if (ptr == NULL)
 		return;
-	free_percpu(ptr[0]);
-	free_percpu(ptr[1]);
+	if (ptr[0])
+		free_percpu(ptr[0]);
+	if (ptr[1])
+		free_percpu(ptr[1]);
 	ptr[0] = ptr[1] = NULL;
 }
 
diff -purN linux-2.6.11-rc5-bk1/net/ipv6/proc.c linux-2.6.11-rc5-bk2/net/ipv6/proc.c
--- linux-2.6.11-rc5-bk1/net/ipv6/proc.c	2005-02-24 05:02:38.000000000 +0100
+++ linux-2.6.11-rc5-bk2/net/ipv6/proc.c	2005-02-27 14:53:35.694671204 +0100
@@ -201,33 +201,23 @@ static struct file_operations snmp6_seq_
 
 int snmp6_register_dev(struct inet6_dev *idev)
 {
-	int err = -ENOMEM;
 	struct proc_dir_entry *p;
 
 	if (!idev || !idev->dev)
 		return -EINVAL;
 
-	if (snmp6_mib_init((void **)idev->stats.icmpv6, sizeof(struct icmpv6_mib),
-			   __alignof__(struct icmpv6_mib)) < 0)
-		goto err_icmp;
+	if (!proc_net_devsnmp6)
+		return -ENOENT;
 
-	if (!proc_net_devsnmp6) {
-		err = -ENOENT;
-		goto err_proc;
-	}
 	p = create_proc_entry(idev->dev->name, S_IRUGO, proc_net_devsnmp6);
 	if (!p)
-		goto err_proc;
+		return -ENOMEM;
+
 	p->data = idev;
 	p->proc_fops = &snmp6_seq_fops;
 
 	idev->stats.proc_dir_entry = p;
 	return 0;
-
-err_proc:
-	snmp6_mib_free((void **)idev->stats.icmpv6);
-err_icmp:
-	return err;
 }
 
 int snmp6_unregister_dev(struct inet6_dev *idev)
@@ -238,8 +228,6 @@ int snmp6_unregister_dev(struct inet6_de
 		return -EINVAL;
 	remove_proc_entry(idev->stats.proc_dir_entry->name,
 			  proc_net_devsnmp6);
-	snmp6_mib_free((void **)idev->stats.icmpv6);
-
 	return 0;
 }
 
@@ -280,6 +268,17 @@ void ipv6_misc_proc_exit(void)
 
 int snmp6_register_dev(struct inet6_dev *idev)
 {
+	return 0;
+}
+
+int snmp6_unregister_dev(struct inet6_dev *idev)
+{
+	return 0;
+}
+#endif	/* CONFIG_PROC_FS */
+
+int snmp6_alloc_dev(struct inet6_dev *idev)
+{
 	int err = -ENOMEM;
 
 	if (!idev || !idev->dev)
@@ -295,11 +294,10 @@ err_icmp:
 	return err;
 }
 
-int snmp6_unregister_dev(struct inet6_dev *idev)
+int snmp6_free_dev(struct inet6_dev *idev)
 {
 	snmp6_mib_free((void **)idev->stats.icmpv6);
 	return 0;
 }
 
-#endif
 
