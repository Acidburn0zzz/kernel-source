From: Hannes Reinecke <hare@suse.de>
Subject: Reattach device handler for multipath devices
References: bnc#435688

The multipath daemon might have specified a different device_handler
than the one a device is attached to by default.
So we should try to re-attach with the user-specified device_handler
and only return an error if that fails.
And we should _not_ detach existing hardware handlers. This will
set the path to failed during failover.

Signed-off-by: Hannes Reinecke <hare@suse.de

diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 4840733..4e39966 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -167,8 +167,6 @@ static void free_pgpaths(struct list_head *pgpaths, struct dm_target *ti)
 
 	list_for_each_entry_safe(pgpath, tmp, pgpaths, list) {
 		list_del(&pgpath->list);
-		if (m->hw_handler_name)
-			scsi_dh_detach(bdev_get_queue(pgpath->path.dev->bdev));
 		dm_put_device(ti, pgpath->path.dev);
 		spin_lock_irqsave(&m->lock, flags);
 		if (m->pgpath_to_activate == pgpath)
@@ -592,9 +590,19 @@ static struct pgpath *parse_path(struct arg_set *as, struct path_selector *ps,
 	}
 
 	if (m->hw_handler_name) {
-		r = scsi_dh_attach(bdev_get_queue(p->path.dev->bdev),
-				   m->hw_handler_name);
+		struct request_queue *q = bdev_get_queue(p->path.dev->bdev);
+
+		r = scsi_dh_attach(q, m->hw_handler_name);
+		if (r == -EBUSY) {
+			/*
+			 * Already attached to different hw_handler,
+			 * try to reattach with correct one.
+			 */
+			scsi_dh_detach(q);
+			r = scsi_dh_attach(q, m->hw_handler_name);
+		}
 		if (r < 0) {
+			ti->error = "error attaching hardware handler";
 			dm_put_device(ti, p->path.dev);
 			goto bad;
 		}
diff --git a/drivers/scsi/device_handler/scsi_dh.c b/drivers/scsi/device_handler/scsi_dh.c
index a518f2e..f5d592f 100644
--- a/drivers/scsi/device_handler/scsi_dh.c
+++ b/drivers/scsi/device_handler/scsi_dh.c
@@ -493,7 +493,6 @@ void scsi_dh_detach(struct request_queue *q)
 {
 	unsigned long flags;
 	struct scsi_device *sdev;
-	struct scsi_device_handler *scsi_dh = NULL;
 
 	spin_lock_irqsave(q->queue_lock, flags);
 	sdev = q->queuedata;
@@ -504,12 +503,9 @@ void scsi_dh_detach(struct request_queue *q)
 	if (!sdev)
 		return;
 
-	if (sdev->scsi_dh_data) {
-		/* if sdev is not on internal list, detach */
-		scsi_dh = sdev->scsi_dh_data->scsi_dh;
-		if (!device_handler_match(scsi_dh, sdev))
-			scsi_dh_handler_detach(sdev, scsi_dh);
-	}
+	if (sdev->scsi_dh_data)
+		scsi_dh_handler_detach(sdev, sdev->scsi_dh_data->scsi_dh);
+
 	put_device(&sdev->sdev_gendev);
 }
 EXPORT_SYMBOL_GPL(scsi_dh_detach);
