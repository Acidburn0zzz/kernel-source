From: Hannes Reinecke <hare@suse.de>
Subject: dm multipath devices are not getting created for readonly devices
References: bnc#382705

Currently we cannot create device-mapper tables for multipath devices
whenever they are read-only.
This patch modifies the device-mapper to set the 'READ-ONLY' flag
automatically whenever a read-only is added to the table.

Signed-off-by: Hannes Reinecke <hare@suse.de>

---
 drivers/md/dm-table.c |   10 +++++++++-
 drivers/md/dm.c       |   18 ++++++++++++++++--
 2 files changed, 25 insertions(+), 3 deletions(-)

--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -310,16 +310,25 @@ static void __exit dm_exit(void)
 static int dm_blk_open(struct inode *inode, struct file *file)
 {
 	struct mapped_device *md;
+	int retval = 0;
 
 	spin_lock(&_minor_lock);
 
 	md = inode->i_bdev->bd_disk->private_data;
-	if (!md)
+	if (!md) {
+		retval = -ENXIO;
 		goto out;
+	}
 
 	if (test_bit(DMF_FREEING, &md->flags) ||
 	    test_bit(DMF_DELETING, &md->flags)) {
 		md = NULL;
+		retval = -ENXIO;
+		goto out;
+	}
+	if (md->disk->policy && (file->f_mode & FMODE_WRITE)) {
+		md = NULL;
+		retval = -EROFS;
 		goto out;
 	}
 
@@ -329,7 +338,7 @@ static int dm_blk_open(struct inode *ino
 out:
 	spin_unlock(&_minor_lock);
 
-	return md ? 0 : -ENXIO;
+	return retval;
 }
 
 static int dm_blk_close(struct inode *inode, struct file *file)
@@ -1901,6 +1910,11 @@ static int __bind(struct mapped_device *
 	write_lock(&md->map_lock);
 	md->map = t;
 	dm_table_set_restrictions(t, q);
+	if (!(dm_table_get_mode(t) & FMODE_WRITE)) {
+		set_disk_ro(md->disk, 1);
+	} else {
+		set_disk_ro(md->disk, 0);
+	}
 	write_unlock(&md->map_lock);
 
 	return 0;
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@ -451,11 +451,19 @@ static int __table_get_device(struct dm_
 		dd->mode = mode;
 		dd->bdev = NULL;
 
-		if ((r = open_dev(dd, dev, t->md))) {
+		r = open_dev(dd, dev, t->md);
+		if (r == -EROFS) {
+			dd->mode &= ~FMODE_WRITE;
+			r = open_dev(dd, dev, t->md);
+		}
+		if (r) {
 			kfree(dd);
 			return r;
 		}
 
+		if (dd->mode != mode)
+			t->mode = dd->mode;
+
 		format_dev_t(dd->name, dev);
 
 		atomic_set(&dd->count, 0);
