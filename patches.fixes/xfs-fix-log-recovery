# From: FSG QA <fsgqa@localhost.localdomain.sgi.com>
# Subject: TAKE 913531 - recovery of v2 logs of log record size of 256K will
# 	fail on Linux
# Date: Wed, 5 May 2004 15:22:22 +1000
# 
# Remove the 128K limitation on pagebuf_get_no_daddr() and allow
# the kmem_alloc() to fail.
# 
# This will get recovery of 256K happening (assuming it has no
# problems getting 256K for its buffer).
# pv913534 (todo) addresses the possibility of using smaller buffers
# in v2 log recovery.
# 
# --Tim
# 
# Date:  Tue May  4 21:52:50 PDT 2004
# Workarea:  snap.melbourne.sgi.com:/home/fsgqa/qa/xfs-linux
# Inspected by:  hch@lst.de,nathans@sgi.com
# 
# The following file(s) were checked into:
#   bonnie.engr.sgi.com:/isms/xfs-kern/xfs-linux
# 
# 
--- xfs-linux/fs/xfs/xfs_log.c
+++ xfs-linux/fs/xfs/xfs_log.c
@@ -497,7 +497,7 @@
 		if (readonly)
 			vfsp->vfs_flag |= VFS_RDONLY;
 		if (error) {
-			cmn_err(CE_WARN, "XFS: log mount/recovery failed");
+			cmn_err(CE_WARN, "XFS: log mount/recovery failed: error %d", error);
 			xlog_unalloc_log(mp->m_log);
 			return error;
 		}
# 	- Print out error code if recovery fails.
--- xfs-linux/fs/xfs/linux/xfs_buf.c
+++ xfs-linux/fs/xfs/linux/xfs_buf.c
@@ -812,16 +812,13 @@
 	void			*data;
 	int			error;
 
-	if (unlikely(len > 0x20000))
-		goto fail;
-
 	bp = pagebuf_allocate(0);
 	if (unlikely(bp == NULL))
 		goto fail;
 	_pagebuf_initialize(bp, target, 0, len, PBF_FORCEIO);
 
  try_again:
-	data = kmem_alloc(malloc_len, KM_SLEEP);
+	data = kmem_alloc(malloc_len, KM_SLEEP | KM_MAYFAIL);
 	if (unlikely(data == NULL))
 		goto fail_free_buf;
 
# 	- Remove the 128K limitiation on pagebuf_get_no_daddr() and allow
# 	  the kmem_alloc to fail.
--- xfs-linux/fs/xfs/linux/kmem.h
+++ xfs-linux/fs/xfs/linux/kmem.h
@@ -52,6 +52,7 @@
 #define KM_SLEEP	0x0001
 #define KM_NOSLEEP	0x0002
 #define KM_NOFS		0x0004
+#define KM_MAYFAIL	0x0005
 
 typedef unsigned long xfs_pflags_t;
 
@@ -78,28 +79,31 @@
 	*(NSTATEP) = *(OSTATEP);	\
 } while (0)
 
-/*
- * XXX get rid of the unconditional  __GFP_NOFAIL by adding
- * a KM_FAIL flag and using it where we're allowed to fail.
- */
 static __inline unsigned int
 kmem_flags_convert(int flags)
 {
 	int lflags;
 
 #if DEBUG
-	if (unlikely(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS))) {
+	if (unlikely(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS|KM_MAYFAIL))) {
 		printk(KERN_WARNING
 		    "XFS: memory allocation with wrong flags (%x)\n", flags);
 		BUG();
 	}
 #endif
 
-	lflags = (flags & KM_NOSLEEP) ? GFP_ATOMIC : (GFP_KERNEL|__GFP_NOFAIL);
+	if (flags & KM_NOSLEEP) {
+		lflags = GFP_ATOMIC;
+	} else {
+		lflags = GFP_KERNEL;
+
+		/* avoid recusive callbacks to filesystem during transactions */
+		if (PFLAGS_TEST_FSTRANS() || (flags & KM_NOFS))
+			lflags &= ~__GFP_FS;
 
-	/* avoid recusive callbacks to filesystem during transactions */
-	if (PFLAGS_TEST_FSTRANS() || (flags & KM_NOFS))
-		lflags &= ~__GFP_FS;
+		if (!(flags & KM_MAYFAIL))
+			lflags |= __GFP_NOFAIL;
+	}
 
 	return lflags;
 }
# 	- Add KM_MAYFAIL and if not KM_MAYFAIL set then set __GFP_NOFAIL.
