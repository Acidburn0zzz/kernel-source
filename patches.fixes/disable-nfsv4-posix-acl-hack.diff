From: Andreas Gruenbacher <agruen@suse.de>
Subject: Disable NFSv4 deamon-side POSIX ACL <=> NFSv4 ACL mapping
References: 169033

The NFSv4 deamon maps from local POSIX acls to NFSv4 acls on the wire,
which the NFSv4 client translates into "system.nfsv4_acl" extended
attributes, and vice versa.  This approach leads to errors when trying
to copy files from a NFSv4 mount to a different file system that does
not understand "system.nfsv4_acl" extended attributes (i.e., anything
but NFSv4).

Trying to do this mapping in the kernel is broken, and makes no sense
in my eyes.  There are two ways in which this could be fixed:

(1) Map NFSv4 acls to POSIX acls in the NFSv4 client, and map requests
    for setting POSIX acls into requests for setting NFSv4 acls, so
    that the pseudo-NFSv4 acls are never exposed to user space.
    
    The huge disadvantage of this approach is that as soon as the server
    or client supports "real" NFSv4 ACLs that do not match the limited
    pattern that the mapping understands, things will turn very ugly.

(2) Remove the mapping code entirely, and implement the NFSACL sideband
    protocol for NFSv4 as well. (Solaris seems to do this.)  This will
    not block us from implementing full NFSv4 ACLs somewhen in the
    future. The NFSACL protocol is implemented for NFSv2 and NFSv3
    already, so adding NFSv4 support should not be be very hard.


This patch disables the NFSv4 ACL mapping in nfsd.


Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

Index: linux-2.6.16/fs/nfsd/nfs4xdr.c
===================================================================
--- linux-2.6.16.orig/fs/nfsd/nfs4xdr.c
+++ linux-2.6.16/fs/nfsd/nfs4xdr.c
@@ -264,6 +264,7 @@ nfsd4_decode_fattr(struct nfsd4_compound
 		READ64(iattr->ia_size);
 		iattr->ia_valid |= ATTR_SIZE;
 	}
+#if 0
 	if (bmval[0] & FATTR4_WORD0_ACL) {
 		int nace, i;
 		struct nfs4_ace ace;
@@ -307,6 +308,13 @@ nfsd4_decode_fattr(struct nfsd4_compound
 		}
 	} else
 		*acl = NULL;
+#else
+	*acl = NULL;
+	if (bmval[0] & FATTR4_WORD0_ACL) {
+		status = -EOPNOTSUPP;
+		goto out_nfserr;
+	}
+#endif
 	if (bmval[1] & FATTR4_WORD1_MODE) {
 		READ_BUF(4);
 		len += 4;
@@ -1322,6 +1330,7 @@ nfsd4_encode_fattr(struct svc_fh *fhp, s
 			goto out;
 		fhp = &tempfh;
 	}
+#if 0
 	if (bmval0 & (FATTR4_WORD0_ACL | FATTR4_WORD0_ACLSUPPORT
 			| FATTR4_WORD0_SUPPORTED_ATTRS)) {
 		status = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);
@@ -1336,6 +1345,10 @@ nfsd4_encode_fattr(struct svc_fh *fhp, s
 				goto out_nfserr;
 		}
 	}
+#else
+	if (bmval0 & FATTR4_WORD0_ACL)
+	  bmval0 &= ~FATTR4_WORD0_ACL;
+#endif
 	if ((buflen -= 16) < 0)
 		goto out_resource;
 
