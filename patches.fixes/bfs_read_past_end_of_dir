ChangeSet
  1.1608.6.115 04/05/10 14:07:02 akpm@osdl.org[torvalds] +1 -0
  [PATCH] bfs filesystem read past the end of dir
  
  From: Jakub Jermar <jermar@itbs.cz>
  
  I found out that BFS filesystem will eventually try to read and interpret
  garbage past the end of directory in bfs_add_entry().  If the garbage
  (interpreted as i-node number) is not set to zero (does it have to be?)
  bfs_add_entry() will consider it a regular directory entry. 
  
  This causes weird things like this:
  # touch a
  # rm a
  # ls
  # touch b
  # ls
  a
  
  My patch detects an attempt to read past the end of directory and explicitly
  clears the garbage that represents i-node number.  Thus the correct behaviour
  is achieved.
  
  (was unable to contact Tigran)

  fs/bfs/dir.c
    1.23 04/05/10 04:25:51 akpm@osdl.org[torvalds] +6 -1
    bfs filesystem read past the end of dir

diff -Nru a/fs/bfs/dir.c b/fs/bfs/dir.c
--- a/fs/bfs/dir.c	Tue May 11 07:40:23 2004
+++ b/fs/bfs/dir.c	Tue May 11 07:40:23 2004
@@ -274,7 +274,7 @@
 {
 	struct buffer_head * bh;
 	struct bfs_dirent * de;
-	int block, sblock, eblock, off;
+	int block, sblock, eblock, off, eoff;
 	int i;
 
 	dprintf("name=%s, namelen=%d\n", name, namelen);
@@ -286,12 +286,17 @@
 
 	sblock = BFS_I(dir)->i_sblock;
 	eblock = BFS_I(dir)->i_eblock;
+	eoff = dir->i_size % BFS_BSIZE;
 	for (block=sblock; block<=eblock; block++) {
 		bh = sb_bread(dir->i_sb, block);
 		if(!bh) 
 			return -ENOSPC;
 		for (off=0; off<BFS_BSIZE; off+=BFS_DIRENT_SIZE) {
 			de = (struct bfs_dirent *)(bh->b_data + off);
+			if (block==eblock && off>=eoff) {
+				/* Do not read/interpret the garbage in the end of eblock. */
+				de->ino = 0;
+			}
 			if (!de->ino) {
 				if ((block-sblock)*BFS_BSIZE + off >= dir->i_size) {
 					dir->i_size += BFS_DIRENT_SIZE;
.........................................................................
# vim: syntax=diff

