From: Konstantin Karasyov <konstantin.a.karasyov@intel.com>
Subject: fix fans on HP laptops
Patch-mainline: not yet
References: http://bugzilla.kernel.org/show_bug.cgi?id=7570#c8

Signed-off-by: Thomas Renninger <trenn@suse.de>



diff -upN linux-2.6.20-rc3.5534.7122/drivers/acpi/bus.c linux-2.6.20-rc3.5534.7122.7570/drivers/acpi/bus.c
--- linux-2.6.20-rc3.5534.7122/drivers/acpi/bus.c	2007-01-01 00:53:20.000000000 +0000
+++ linux-2.6.20-rc3.5534.7122.7570/drivers/acpi/bus.c	2007-01-07 20:13:02.000000000 +0000
@@ -202,15 +202,14 @@ int acpi_bus_set_power(acpi_handle handl
 	 * Get device's current power state if it's unknown
 	 * This means device power state isn't initialized or previous setting failed
 	 */
-	if (!device->flags.force_power_state) {
-		if (device->power.state == ACPI_STATE_UNKNOWN)
-			acpi_bus_get_power(device->handle, &device->power.state);
-		if (state == device->power.state) {
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
-					  state));
-			return 0;
-		}
+	if ((device->power.state == ACPI_STATE_UNKNOWN) || device->flags.force_power_state)
+		acpi_bus_get_power(device->handle, &device->power.state);
+	if ((state == device->power.state) && !device->flags.force_power_state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n",
+				  state));
+		return 0;
 	}
+
 	if (!device->power.states[state].flags.valid) {
 		printk(KERN_WARNING PREFIX "Device does not support D%d\n", state);
 		return -ENODEV;
diff -upN linux-2.6.20-rc3.5534.7122/drivers/acpi/power.c linux-2.6.20-rc3.5534.7122.7570/drivers/acpi/power.c
--- linux-2.6.20-rc3.5534.7122/drivers/acpi/power.c	2007-01-07 20:08:16.000000000 +0000
+++ linux-2.6.20-rc3.5534.7122.7570/drivers/acpi/power.c	2007-01-07 20:13:02.000000000 +0000
@@ -456,6 +456,10 @@ int acpi_power_transition(struct acpi_de
 			goto end;
 	}
 
+	if (device->power.state == state) {
+		goto end;
+	}
+
 	/*
 	 * Then we dereference all power resources used in the current list.
 	 */
diff -upN linux-2.6.20-rc3.5534.7122/drivers/acpi/thermal.c linux-2.6.20-rc3.5534.7122.7570/drivers/acpi/thermal.c
--- linux-2.6.20-rc3.5534.7122/drivers/acpi/thermal.c	2007-01-01 00:53:20.000000000 +0000
+++ linux-2.6.20-rc3.5534.7122.7570/drivers/acpi/thermal.c	2007-01-07 20:27:02.000000000 +0000
@@ -1356,28 +1356,32 @@ static int acpi_thermal_remove(struct ac
 static int acpi_thermal_resume(struct acpi_device *device, int state)
 {
 	struct acpi_thermal *tz = NULL;
-	int i;
+	int i, j, power_state, result;
+
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
 	tz = acpi_driver_data(device);
 
-	acpi_thermal_get_temperature(tz);
-
 	for (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {
-		if (tz->trips.active[i].flags.valid) {
- 			tz->temperature = tz->trips.active[i].temperature;
-			tz->trips.active[i].flags.enabled = 0;
-
-			acpi_thermal_active(tz);
-
-			tz->state.active |= tz->trips.active[i].flags.enabled;
-			tz->state.active_index = i;
+		if (!(&tz->trips.active[i]))
+			break;
+		if (!tz->trips.active[i].flags.valid)
+			break;
+		tz->trips.active[i].flags.enabled = 1;
+		for (j = 0; j < tz->trips.active[i].devices.count; j++) {
+			result = acpi_bus_get_power(tz->trips.active[i].devices.
+			    handles[j], &power_state);
+			if (result || (power_state != ACPI_STATE_D0)) {
+				tz->trips.active[i].flags.enabled = 0;
+				break;
+			}
 		}
+		tz->state.active |= tz->trips.active[i].flags.enabled;
 	}
 
- 	acpi_thermal_check(tz);
+	acpi_thermal_check(tz);
 
 	return AE_OK;
 }
