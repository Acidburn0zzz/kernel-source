
WARNING! this has abug

From akpm@osdl.org Tue Mar 16 19:57:02 2004
Return-Path: <mason@watt>
Received: from watt ([unix socket]) (authenticated user=mason bits=0) by
	watt (Cyrus v2.1.15) with LMTP; Tue, 16 Mar 2004 19:57:02 -0500
X-Sieve: CMU Sieve 2.2
Return-Path: <akpm@osdl.org>
Received: from extimap.suse.de [195.135.220.6] by localhost with IMAP
	(fetchmail-6.2.3) for mason@localhost (single-drop); Tue, 16 Mar 2004
	19:57:01 -0500 (EST)
Received: from extimap.suse.de ([unix socket]) by extimap (Cyrus v2.1.16)
	with LMTP; Wed, 17 Mar 2004 01:53:27 +0100
X-Sieve: CMU Sieve 2.2
Received: by extimap.suse.de (Postfix, from userid 65534) id A184D8843D;
	Wed, 17 Mar 2004 01:53:27 +0100 (CET)
Received: from Cantor.suse.de (ns.suse.de [195.135.220.2]) (using TLSv1
	with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits)) (Client CN "mail.suse.de",
	Issuer "SuSE Linux AG internal IMAP-Server CA" (verified OK)) by
	extimap.suse.de (Postfix) with ESMTP id AFF5788402 for
	<mason@extimap.suse.de>; Wed, 17 Mar 2004 01:53:26 +0100 (CET)
Received: from hermes.suse.de (Hermes.suse.de [195.135.221.8]) (using TLSv1
	with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits)) (No client certificate
	requested) by Cantor.suse.de (Postfix) with ESMTP id 935843062D8 for
	<mason@extimap.suse.de>; Wed, 17 Mar 2004 01:53:14 +0100 (CET)
X-Sieve: CMU Sieve 2.2
Received: from Cantor.suse.de (ns.suse.de [195.135.220.2]) (using TLSv1
	with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits)) (No client certificate
	requested) by hermes.suse.de (Postfix) with ESMTP id F340D8C20 for
	<mason@suse.com>; Wed, 17 Mar 2004 01:53:13 +0100 (CET)
Received: from mail.osdl.org (fw.osdl.org [65.172.181.6]) by Cantor.suse.de
	(Postfix) with ESMTP id 7F4B8308348 for <mason@suse.com>; Wed, 17 Mar 2004
	01:50:11 +0100 (CET)
Received: from akpm.pao.digeo.com (build.pdx.osdl.net [172.20.1.2]) by
	mail.osdl.org (8.11.6/8.11.6) with SMTP id i2H0o7E15754; Tue, 16 Mar 2004
	16:50:07 -0800
Date: Tue, 16 Mar 2004 16:52:14 -0800
From: Andrew Morton <akpm@osdl.org>
To: Chris Mason <mason@suse.com>
Cc: daniel@osdl.org, linux-kernel@vger.kernel.org, linux-aio@kvack.org
Subject: Re: 2.6.4-mm2
Message-Id: <20040316165214.3b17ad2e.akpm@osdl.org>
In-Reply-To: <1079474312.4186.927.camel@watt.suse.com>
References: <20040314172809.31bd72f7.akpm@osdl.org>
	 <1079461971.23783.5.camel@ibm-c.pdx.osdl.net>
	 <1079474312.4186.927.camel@watt.suse.com>
X-Mailer: Sylpheed version 0.9.7 (GTK+ 1.2.10; i586-pc-linux-gnu)
Mime-Version: 1.0
X-Bogosity: No, tests=bogofilter, spamicity=0.440823, version=0.14.4
Content-Type: text/plain; CHARSET=US-ASCII
X-Evolution-Source: imap://mason@watt/
Content-Transfer-Encoding: 8bit

Chris Mason <mason@suse.com> wrote:
>
> The sync all proc now calls pagevec_lookup_tag(PAGECACHE_TAG_DIRTY), no
> pages are returned, so it returns.
> 
> The sync none proc gets to the buffer_locked check in
> __block_write_full_page and properly retags the page with
> PAGECACHE_TAG_DIRTY, but it's too late.  The sync all proc has already
> skipped the page.

OK, so how about we prevent this transient state by leaving the page tagged
as dirty in the radix tree while calling its ->writepage?  That way,
fsync() will still find the page during the PAGECACHE_TAG_DIRTY walk and
will block in lock_page() until things sort themselves out?


Untested patch:


fdatasync can fail to wait on some pages due to a race.

If some task (eg pdflush) is flushing the same mapping it can remove a page's
dirty tag but not then mark that page as being under writeback, because
pdflush hit a locked buffer in __block_write_full_page().  This will happen
because kjournald is writing the buffer.  In this situation
__block_write_full_page() will redirty the page so that fsync notices it, but
there is a window where the page eludes the radix tree dirty page walk.

Consequently a concurrent fsync will fail to notice the page when walking the
radix tree's dirty pages.

The approach taken by this patch is to leave the page marked as dirty in the
radix tree while ->writepage is working out what to do with it.  This ensures
that a concurrent write-for-sync will successfully locate the page and will
then block in lock_page() until the non-write-for-sync code has finished
altering the page state.


Index: linux.t/fs/mpage.c
===================================================================
--- linux.t.orig/fs/mpage.c	2004-03-17 22:54:00.455038430 -0500
+++ linux.t/fs/mpage.c	2004-03-17 23:12:21.812693450 -0500
@@ -643,7 +643,7 @@ mpage_writepages(struct address_space *m
 				wait_on_page_writeback(page);
 
 			if (page->mapping == mapping && !PageWriteback(page) &&
-						test_clear_page_dirty(page)) {
+						clear_page_dirty_for_io(page)) {
 				if (writepage) {
 					ret = (*writepage)(page, wbc);
 					if (ret) {
Index: linux.t/mm/vmscan.c
===================================================================
--- linux.t.orig/mm/vmscan.c	2004-03-17 22:54:00.033159947 -0500
+++ linux.t/mm/vmscan.c	2004-03-17 23:12:21.816692287 -0500
@@ -352,7 +352,7 @@ shrink_list(struct list_head *page_list,
 				goto keep_locked;
 			if (!may_write_to_queue(mapping->backing_dev_info))
 				goto keep_locked;
-			if (test_clear_page_dirty(page)) {
+			if (clear_page_dirty_for_io(page)) {
 				int res;
 				struct writeback_control wbc = {
 					.sync_mode = WB_SYNC_NONE,
Index: linux.t/mm/page-writeback.c
===================================================================
--- linux.t.orig/mm/page-writeback.c	2004-03-17 22:54:00.563007331 -0500
+++ linux.t/mm/page-writeback.c	2004-03-17 23:13:07.805107118 -0500
@@ -511,7 +511,7 @@ int write_one_page(struct page *page, in
 	if (wait)
 		wait_on_page_writeback(page);
 
-	if (test_clear_page_dirty(page)) {
+	if (clear_page_dirty_for_io(page)) {
 		page_cache_get(page);
 		ret = mapping->a_ops->writepage(page, &wbc);
 		if (ret == 0 && wait) {
@@ -615,6 +615,36 @@ int test_clear_page_dirty(struct page *p
 EXPORT_SYMBOL(test_clear_page_dirty);
 
 /*
+ * Clear a page's dirty flag, while caring for dirty memory accounting.
+ * Returns true if the page was previously dirty.
+ *
+ * This is for preparing to put the page under writeout.  We leave the page
+ * tagged as dirty in the radix tree so that a concurrent write-for-sync
+ * can discover it via a PAGECACHE_TAG_DIRTY walk.  The ->writepage
+ * implementation will run either set_page_writeback() or set_page_dirty(),
+ * at which stage we bring the page's dirty flag and radix-tree dirty tag
+ * back into sync.
+ *
+ * This incoherency between the page's dirty flag and radix-tree tag is
+ * unfortunate, but it only exists while the page is locked.
+ */
+int clear_page_dirty_for_io(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	if (mapping) {
+		if (TestClearPageDirty(page)) {
+			if (!mapping->backing_dev_info->memory_backed)
+				dec_page_state(nr_dirty);
+			return 1;
+		}
+		return 0;
+	}
+	return TestClearPageDirty(page);
+}
+EXPORT_SYMBOL(clear_page_dirty_for_io);
+
+/*
  * Clear a page's dirty flag while ignoring dirty memory accounting
  */
 int __clear_page_dirty(struct page *page)
@@ -667,9 +697,12 @@ int test_set_page_writeback(struct page 
 
 		spin_lock_irqsave(&mapping->tree_lock, flags);
 		ret = TestSetPageWriteback(page);
-		if (ret)
+		if (!ret)
 			radix_tree_tag_set(&mapping->page_tree, page->index,
 						PAGECACHE_TAG_WRITEBACK);
+		if (!PageDirty(page))
+			radix_tree_tag_clear(&mapping->page_tree, page->index,
+						PAGECACHE_TAG_DIRTY);
 		spin_unlock_irqrestore(&mapping->tree_lock, flags);
 	} else {
 		ret = TestSetPageWriteback(page);
Index: linux.t/include/linux/mm.h
===================================================================
--- linux.t.orig/include/linux/mm.h	2004-03-17 22:54:00.523018850 -0500
+++ linux.t/include/linux/mm.h	2004-03-17 23:12:21.814692868 -0500
@@ -474,6 +474,7 @@ extern long do_mprotect(struct mm_struct
 int __set_page_dirty_buffers(struct page *page);
 int __set_page_dirty_nobuffers(struct page *page);
 int set_page_dirty_lock(struct page *page);
+int clear_page_dirty_for_io(struct page *page);
 
 /*
  * Prototype to add a shrinker callback for ageable caches.
