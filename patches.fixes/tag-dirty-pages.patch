

Arrange for all dirty pagecache pages to be tagged as dirty within their
radix tree.


Index: linux.t/fs/buffer.c
===================================================================
--- linux.t.orig/fs/buffer.c	2004-03-16 11:07:34.745928119 -0500
+++ linux.t/fs/buffer.c	2004-03-16 11:07:42.077961283 -0500
@@ -880,6 +880,8 @@ int __set_page_dirty_buffers(struct page
 				inc_page_state(nr_dirty);
 			list_del(&page->list);
 			list_add(&page->list, &mapping->dirty_pages);
+			radix_tree_tag_set(&mapping->page_tree, page->index,
+						PAGECACHE_TAG_DIRTY);
 		}
 		spin_unlock_irq(&mapping->tree_lock);
 		__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);
Index: linux.t/include/linux/fs.h
===================================================================
--- linux.t.orig/include/linux/fs.h	2004-03-16 11:07:34.851914146 -0500
+++ linux.t/include/linux/fs.h	2004-03-16 11:07:42.079961019 -0500
@@ -368,6 +368,13 @@ struct block_device {
 };
 
 /*
+ * Radix-tre tags, for tagging dirty and writeback pages within the pagecache
+ * radix trees
+ */
+#define PAGECACHE_TAG_DIRTY	0
+#define PAGECACHE_TAG_WRITEBACK	1
+
+/*
  * Use sequence counter to get consistent i_size on 32-bit processors.
  */
 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
Index: linux.t/include/linux/page-flags.h
===================================================================
--- linux.t.orig/include/linux/page-flags.h	2004-03-16 11:07:14.738564858 -0500
+++ linux.t/include/linux/page-flags.h	2004-03-16 11:07:42.081960756 -0500
@@ -323,4 +323,6 @@ static inline void clear_page_dirty(stru
 	test_clear_page_dirty(page);
 }
 
+int __clear_page_dirty(struct page *page);
+
 #endif	/* PAGE_FLAGS_H */
Index: linux.t/mm/page-writeback.c
===================================================================
--- linux.t.orig/mm/page-writeback.c	2004-03-16 11:07:34.906906895 -0500
+++ linux.t/mm/page-writeback.c	2004-03-16 11:07:42.082960624 -0500
@@ -561,6 +561,8 @@ int __set_page_dirty_nobuffers(struct pa
 					inc_page_state(nr_dirty);
 				list_del(&page->list);
 				list_add(&page->list, &mapping->dirty_pages);
+				radix_tree_tag_set(&mapping->page_tree,
+					page->index, PAGECACHE_TAG_DIRTY);
 			}
 			spin_unlock_irq(&mapping->tree_lock);
 			if (!PageSwapCache(page))
@@ -601,13 +603,45 @@ EXPORT_SYMBOL(set_page_dirty_lock);
  */
 int test_clear_page_dirty(struct page *page)
 {
-	if (TestClearPageDirty(page)) {
-		struct address_space *mapping = page->mapping;
+	struct address_space *mapping = page->mapping;
+	unsigned long flags;
 
-		if (mapping && !mapping->backing_dev_info->memory_backed)
-			dec_page_state(nr_dirty);
-		return 1;
+	if (mapping) {
+		spin_lock_irqsave(&mapping->tree_lock, flags);
+		if (TestClearPageDirty(page)) {
+			radix_tree_tag_clear(&mapping->page_tree, page->index,
+						PAGECACHE_TAG_DIRTY);
+			spin_unlock_irqrestore(&mapping->tree_lock, flags);
+			if (!mapping->backing_dev_info->memory_backed)
+				dec_page_state(nr_dirty);
+			return 1;
+		}
+		spin_unlock_irqrestore(&mapping->tree_lock, flags);
+		return 0;
 	}
-	return 0;
+	return TestClearPageDirty(page);
 }
 EXPORT_SYMBOL(test_clear_page_dirty);
+
+/*
+ * Clear a page's dirty flag while ignoring dirty memory accounting
+ */
+int __clear_page_dirty(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	if (mapping) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&mapping->tree_lock, flags);
+		if (TestClearPageDirty(page)) {
+			radix_tree_tag_clear(&mapping->page_tree, page->index,
+						PAGECACHE_TAG_DIRTY);
+			spin_unlock_irqrestore(&mapping->tree_lock, flags);
+			return 1;
+		}
+		spin_unlock_irqrestore(&mapping->tree_lock, flags);
+		return 0;
+	}
+	return TestClearPageDirty(page);
+}
Index: linux.t/mm/swap_state.c
===================================================================
--- linux.t.orig/mm/swap_state.c	2004-03-16 11:07:34.923904654 -0500
+++ linux.t/mm/swap_state.c	2004-03-16 11:07:42.083960492 -0500
@@ -150,7 +150,7 @@ int add_to_swap(struct page * page)
 		switch (err) {
 		case 0:				/* Success */
 			SetPageUptodate(page);
-			ClearPageDirty(page);
+			__clear_page_dirty(page);
 			set_page_dirty(page);
 			INC_CACHE_INFO(add_total);
 			return 1;
@@ -247,7 +247,7 @@ int move_from_swap_cache(struct page *pa
 	if (!err) {
 		swap_free(entry);
 		/* shift page from clean_pages to dirty_pages list */
-		ClearPageDirty(page);
+		__clear_page_dirty(page);
 		set_page_dirty(page);
 	}
 	return err;
