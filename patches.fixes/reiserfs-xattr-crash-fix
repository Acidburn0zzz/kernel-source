From: Jeff Mahoney <jeffm@suse.com>
Subject: reiserfs: Fix crash during umount
References: bnc#610598
Patch-mainline: Submitted to reiserfs-devel Jun 4 2010

 There is a conflict between shrink_dcache_for_umount_subtree and how
 xattrs are cleaned up for deleted files at umount.

 shrink_dcache_for_umount_subtree wants to ensure that all dentries for a
 file system have been evicted and it walks the dentry tree from the root
 of the file system to do this. It will BUG if there are any dentries
 left with elevated counts.

 The reiserfs xattr infrastructure caches two dentries. One is for
 .reiserfs_priv and the other is for .reiserfs_priv/xattrs. When
 shrink_dcache_for_umount_subtree goes through, it will BUG on these dentries
 if they aren't freed. OTOH, it will Oops in reiserfs_delete_xattrs if
 they are due to the xattr code needing to walk the list of xattrs for
 a file undergoing delayed deletion. This will end up loading up other
 dentries and possibly queue up more delayed deletions.

 This patch detaches the tree under .reiserfs_priv during ->kill_sb. This
 allows shrink_dcache_for_umount_subtree to complete successfully as well
 as keeps around the .reiserfs_priv tree for deletion handling. After
 the regular cycle is completed, it will call shrink_dcache_for_umount_subtree
 again itself to ensure that the xattrs are cleaned up.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/dcache.c                    |    3 +-
 fs/reiserfs/super.c            |   22 ++------------------
 fs/reiserfs/xattr.c            |   43 +++++++++++++++++++++++++++++++++++++++--
 include/linux/dcache.h         |    1 
 include/linux/reiserfs_xattr.h |    1 
 5 files changed, 48 insertions(+), 22 deletions(-)

--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -885,7 +885,7 @@ EXPORT_SYMBOL(shrink_dcache_sb);
  * - see the comments on shrink_dcache_for_umount() for a description of the
  *   locking
  */
-static void shrink_dcache_for_umount_subtree(struct dentry *dentry)
+void shrink_dcache_for_umount_subtree(struct dentry *dentry)
 {
 	struct dentry *parent;
 	unsigned detached = 0;
@@ -978,6 +978,7 @@ static void shrink_dcache_for_umount_sub
 				    struct dentry, d_u.d_child);
 	}
 }
+EXPORT_SYMBOL_GPL(shrink_dcache_for_umount_subtree);
 
 /*
  * destroy the dentries attached to a superblock on unmounting
--- a/fs/reiserfs/super.c
+++ b/fs/reiserfs/super.c
@@ -450,29 +450,13 @@ int remove_save_link(struct inode *inode
 	return journal_end(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);
 }
 
-static void reiserfs_kill_sb(struct super_block *s)
-{
-	if (REISERFS_SB(s)) {
-		if (REISERFS_SB(s)->xattr_root) {
-			d_invalidate(REISERFS_SB(s)->xattr_root);
-			dput(REISERFS_SB(s)->xattr_root);
-			REISERFS_SB(s)->xattr_root = NULL;
-		}
-		if (REISERFS_SB(s)->priv_root) {
-			d_invalidate(REISERFS_SB(s)->priv_root);
-			dput(REISERFS_SB(s)->priv_root);
-			REISERFS_SB(s)->priv_root = NULL;
-		}
-	}
-
-	kill_block_super(s);
-}
-
 static void reiserfs_put_super(struct super_block *s)
 {
 	struct reiserfs_transaction_handle th;
 	th.t_trans_id = 0;
 
+	reiserfs_xattr_shutdown(s);
+
 	dquot_disable(s, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
 	reiserfs_write_lock(s);
@@ -2259,7 +2243,7 @@ struct file_system_type reiserfs_fs_type
 	.owner = THIS_MODULE,
 	.name = "reiserfs",
 	.mount = get_super_block,
-	.kill_sb = reiserfs_kill_sb,
+	.kill_sb = kill_block_super,
 	.fs_flags = FS_REQUIRES_DEV,
 };
 
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -989,18 +989,36 @@ static const struct dentry_operations xa
 
 int reiserfs_lookup_privroot(struct super_block *s)
 {
+	struct qstr fake_name = {
+		.name = ".priv_root",
+		.len = strlen(".priv_root"),
+	};
+	struct dentry *fake_root = d_alloc_pseudo(s, &fake_name);
 	struct dentry *dentry;
 	int err = 0;
 
+	if (!fake_root) {
+		reiserfs_warning(s, "", "Couldn't initalize fake root for "
+				 "extended attributes.");
+		return -ENOMEM;
+	}
+
 	/* If we don't have the privroot located yet - go find it */
 	reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
 	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
-		REISERFS_SB(s)->priv_root = dentry;
+		REISERFS_SB(s)->priv_root = fake_root;
 		d_set_d_op(dentry, &xattr_lookup_poison_ops);
-		if (dentry->d_inode)
+		if (dentry->d_inode) {
 			dentry->d_inode->i_flags |= S_PRIVATE;
+
+			/* This is disconnected from the root */
+			ihold(dentry->d_inode);
+			d_add(fake_root, dentry->d_inode);
+		}
+		d_delete(dentry);
+		dput(dentry);
 	} else
 		err = PTR_ERR(dentry);
 	mutex_unlock(&s->s_root->d_inode->i_mutex);
@@ -1055,3 +1073,24 @@ error:
 
 	return err;
 }
+
+void reiserfs_xattr_shutdown(struct super_block *s)
+{
+	struct dentry *priv_root = REISERFS_SB(s)->priv_root;
+
+	if (REISERFS_SB(s)->xattr_root) {
+		dput(REISERFS_SB(s)->xattr_root);
+		REISERFS_SB(s)->xattr_root = NULL;
+	}
+
+	if (priv_root) {
+		dput(priv_root);
+		REISERFS_SB(s)->priv_root = NULL;
+
+		/* This will drop the final reference to priv_root and
+		 * clean up anything that was deleted during the call in
+		 * generic_shutdown_super(). */
+		shrink_dcache_for_umount_subtree(priv_root);
+		sync_filesystem(s);
+	}
+}
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -246,6 +246,7 @@ extern struct dentry * d_obtain_alias(st
 extern void shrink_dcache_sb(struct super_block *);
 extern void shrink_dcache_parent(struct dentry *);
 extern void shrink_dcache_for_umount(struct super_block *);
+extern void shrink_dcache_for_umount_subtree(struct dentry *);
 extern int d_invalidate(struct dentry *);
 
 /* only used at mount-time */
--- a/include/linux/reiserfs_xattr.h
+++ b/include/linux/reiserfs_xattr.h
@@ -38,6 +38,7 @@ struct nameidata;
 int reiserfs_xattr_register_handlers(void) __init;
 void reiserfs_xattr_unregister_handlers(void);
 int reiserfs_xattr_init(struct super_block *sb, int mount_flags);
+void reiserfs_xattr_shutdown(struct super_block *sb);
 int reiserfs_lookup_privroot(struct super_block *sb);
 int reiserfs_delete_xattrs(struct inode *inode);
 int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs);
