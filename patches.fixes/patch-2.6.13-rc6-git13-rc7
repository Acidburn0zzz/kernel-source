Subject: patch-2.6.13-rc7
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

diff -purN linux-2.6.13-rc6-git13/Makefile linux-2.6.13-rc7/Makefile
--- linux-2.6.13-rc6-git13/Makefile	2005-08-21 12:03:32.000000000 +0200
+++ linux-2.6.13-rc7/Makefile	2005-08-24 05:39:14.000000000 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 13
-EXTRAVERSION = -rc6-git13
+EXTRAVERSION =-rc7
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.13-rc6-git13/arch/alpha/Kconfig linux-2.6.13-rc7/arch/alpha/Kconfig
--- linux-2.6.13-rc6-git13/arch/alpha/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/alpha/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -522,7 +522,7 @@ source "mm/Kconfig"
 
 config NUMA
 	bool "NUMA Support (EXPERIMENTAL)"
-	depends on DISCONTIGMEM
+	depends on DISCONTIGMEM && BROKEN
 	help
 	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
 	  Access).  This option is for configuring high-end multiprocessor
diff -purN linux-2.6.13-rc6-git13/arch/alpha/kernel/smp.c linux-2.6.13-rc7/arch/alpha/kernel/smp.c
--- linux-2.6.13-rc6-git13/arch/alpha/kernel/smp.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/alpha/kernel/smp.c	2005-08-24 05:39:14.000000000 +0200
@@ -1036,7 +1036,7 @@ debug_spin_lock(spinlock_t * lock, const
 	"	br	1b\n"
 	".previous"
 	: "=r" (tmp), "=m" (lock->lock), "=r" (stuck)
-	: "1" (lock->lock), "2" (stuck) : "memory");
+	: "m" (lock->lock), "2" (stuck) : "memory");
 
 	if (stuck < 0) {
 		printk(KERN_WARNING
@@ -1115,7 +1115,7 @@ void _raw_write_lock(rwlock_t * lock)
 	".previous"
 	: "=m" (*(volatile int *)lock), "=&r" (regx), "=&r" (regy),
 	  "=&r" (stuck_lock), "=&r" (stuck_reader)
-	: "0" (*(volatile int *)lock), "3" (stuck_lock), "4" (stuck_reader) : "memory");
+	: "m" (*(volatile int *)lock), "3" (stuck_lock), "4" (stuck_reader) : "memory");
 
 	if (stuck_lock < 0) {
 		printk(KERN_WARNING "write_lock stuck at %p\n", inline_pc);
@@ -1153,7 +1153,7 @@ void _raw_read_lock(rwlock_t * lock)
 	"	br	1b\n"
 	".previous"
 	: "=m" (*(volatile int *)lock), "=&r" (regx), "=&r" (stuck_lock)
-	: "0" (*(volatile int *)lock), "2" (stuck_lock) : "memory");
+	: "m" (*(volatile int *)lock), "2" (stuck_lock) : "memory");
 
 	if (stuck_lock < 0) {
 		printk(KERN_WARNING "read_lock stuck at %p\n", inline_pc);
diff -purN linux-2.6.13-rc6-git13/arch/alpha/oprofile/common.c linux-2.6.13-rc7/arch/alpha/oprofile/common.c
--- linux-2.6.13-rc6-git13/arch/alpha/oprofile/common.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/alpha/oprofile/common.c	2005-08-24 05:39:14.000000000 +0200
@@ -65,7 +65,7 @@ op_axp_setup(void)
 	model->reg_setup(&reg, ctr, &sys);
 
 	/* Configure the registers on all cpus.  */
-	smp_call_function(model->cpu_setup, &reg, 0, 1);
+	(void)smp_call_function(model->cpu_setup, &reg, 0, 1);
 	model->cpu_setup(&reg);
 	return 0;
 }
@@ -86,7 +86,7 @@ op_axp_cpu_start(void *dummy)
 static int
 op_axp_start(void)
 {
-	smp_call_function(op_axp_cpu_start, NULL, 0, 1);
+	(void)smp_call_function(op_axp_cpu_start, NULL, 0, 1);
 	op_axp_cpu_start(NULL);
 	return 0;
 }
@@ -101,7 +101,7 @@ op_axp_cpu_stop(void *dummy)
 static void
 op_axp_stop(void)
 {
-	smp_call_function(op_axp_cpu_stop, NULL, 0, 1);
+	(void)smp_call_function(op_axp_cpu_stop, NULL, 0, 1);
 	op_axp_cpu_stop(NULL);
 }
 
diff -purN linux-2.6.13-rc6-git13/arch/arm/Kconfig linux-2.6.13-rc7/arch/arm/Kconfig
--- linux-2.6.13-rc6-git13/arch/arm/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/arm/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -310,7 +310,7 @@ menu "Kernel Features"
 
 config SMP
 	bool "Symmetric Multi-Processing (EXPERIMENTAL)"
-	depends on EXPERIMENTAL #&& n
+	depends on EXPERIMENTAL && BROKEN #&& n
 	help
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
diff -purN linux-2.6.13-rc6-git13/arch/arm/kernel/traps.c linux-2.6.13-rc7/arch/arm/kernel/traps.c
--- linux-2.6.13-rc6-git13/arch/arm/kernel/traps.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/arm/kernel/traps.c	2005-08-24 05:39:14.000000000 +0200
@@ -617,7 +617,7 @@ baddataabort(int code, unsigned long ins
 	notify_die("unknown data abort code", regs, &info, instr, 0);
 }
 
-volatile void __bug(const char *file, int line, void *data)
+void __attribute__((noreturn)) __bug(const char *file, int line, void *data)
 {
 	printk(KERN_CRIT"kernel BUG at %s:%d!", file, line);
 	if (data)
diff -purN linux-2.6.13-rc6-git13/arch/arm/nwfpe/fpopcode.h linux-2.6.13-rc7/arch/arm/nwfpe/fpopcode.h
--- linux-2.6.13-rc6-git13/arch/arm/nwfpe/fpopcode.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/arm/nwfpe/fpopcode.h	2005-08-24 05:39:14.000000000 +0200
@@ -370,20 +370,20 @@ TABLE 5
 #define getRoundingMode(opcode)		((opcode & MASK_ROUNDING_MODE) >> 5)
 
 #ifdef CONFIG_FPE_NWFPE_XP
-static inline const floatx80 getExtendedConstant(const unsigned int nIndex)
+static inline __attribute_pure__ floatx80 getExtendedConstant(const unsigned int nIndex)
 {
 	extern const floatx80 floatx80Constant[];
 	return floatx80Constant[nIndex];
 }
 #endif
 
-static inline const float64 getDoubleConstant(const unsigned int nIndex)
+static inline __attribute_pure__ float64 getDoubleConstant(const unsigned int nIndex)
 {
 	extern const float64 float64Constant[];
 	return float64Constant[nIndex];
 }
 
-static inline const float32 getSingleConstant(const unsigned int nIndex)
+static inline __attribute_pure__ float32 getSingleConstant(const unsigned int nIndex)
 {
 	extern const float32 float32Constant[];
 	return float32Constant[nIndex];
diff -purN linux-2.6.13-rc6-git13/arch/i386/kernel/traps.c linux-2.6.13-rc7/arch/i386/kernel/traps.c
--- linux-2.6.13-rc6-git13/arch/i386/kernel/traps.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/i386/kernel/traps.c	2005-08-24 05:39:14.000000000 +0200
@@ -803,15 +803,17 @@ void math_error(void __user *eip)
 	 */
 	cwd = get_fpu_cwd(task);
 	swd = get_fpu_swd(task);
-	switch (((~cwd) & swd & 0x3f) | (swd & 0x240)) {
+	switch (swd & ~cwd & 0x3f) {
 		case 0x000:
 		default:
 			break;
 		case 0x001: /* Invalid Op */
-		case 0x041: /* Stack Fault */
-		case 0x241: /* Stack Fault | Direction */
+			/*
+			 * swd & 0x240 == 0x040: Stack Underflow
+			 * swd & 0x240 == 0x240: Stack Overflow
+			 * User must clear the SF bit (0x40) if set
+			 */
 			info.si_code = FPE_FLTINV;
-			/* Should we clear the SF or let user space do it ???? */
 			break;
 		case 0x002: /* Denormalize */
 		case 0x010: /* Underflow */
diff -purN linux-2.6.13-rc6-git13/arch/ia64/hp/sim/boot/boot_head.S linux-2.6.13-rc7/arch/ia64/hp/sim/boot/boot_head.S
--- linux-2.6.13-rc6-git13/arch/ia64/hp/sim/boot/boot_head.S	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/ia64/hp/sim/boot/boot_head.S	2005-08-24 05:39:14.000000000 +0200
@@ -22,7 +22,7 @@ GLOBAL_ENTRY(_start)
 	.save rp, r0
 	.body
 	movl gp = __gp
-	movl sp = stack_mem
+	movl sp = stack_mem+16384-16
 	bsw.1
 	br.call.sptk.many rp=start_bootloader
 END(_start)
diff -purN linux-2.6.13-rc6-git13/arch/ia64/sn/kernel/io_init.c linux-2.6.13-rc7/arch/ia64/sn/kernel/io_init.c
--- linux-2.6.13-rc6-git13/arch/ia64/sn/kernel/io_init.c	2005-08-21 12:03:32.000000000 +0200
+++ linux-2.6.13-rc7/arch/ia64/sn/kernel/io_init.c	2005-08-24 05:39:14.000000000 +0200
@@ -323,7 +323,7 @@ void sn_pci_controller_fixup(int segment
 	struct pci_controller *controller;
 	struct pcibus_bussoft *prom_bussoft_ptr;
 	struct hubdev_info *hubdev_info;
-	void *provider_soft;
+	void *provider_soft = NULL;
 	struct sn_pcibus_provider *provider;
 
  	status = sal_get_pcibus_info((u64) segment, (u64) busnum,
@@ -339,7 +339,7 @@ void sn_pci_controller_fixup(int segment
 	if (bus == NULL) {
  		bus = pci_scan_bus(busnum, &pci_root_ops, controller);
  		if (bus == NULL)
- 			return;	/* error, or bus already scanned */
+ 			goto error_return; /* error, or bus already scanned */
  		bus->sysdata = NULL;
 	}
 
@@ -352,28 +352,30 @@ void sn_pci_controller_fixup(int segment
 	 */
 
 	if (prom_bussoft_ptr->bs_asic_type >= PCIIO_ASIC_MAX_TYPES)
-		return;		/* unsupported asic type */
+		goto error_return; /* unsupported asic type */
 
 	if (prom_bussoft_ptr->bs_asic_type == PCIIO_ASIC_TYPE_PPB)
 		goto error_return; /* no further fixup necessary */
 
 	provider = sn_pci_provider[prom_bussoft_ptr->bs_asic_type];
 	if (provider == NULL)
-		return;		/* no provider registerd for this asic */
+		goto error_return; /* no provider registerd for this asic */
 
-	provider_soft = NULL;
+	bus->sysdata = controller;
 	if (provider->bus_fixup)
 		provider_soft = (*provider->bus_fixup) (prom_bussoft_ptr, controller);
 
-	if (provider_soft == NULL)
-		return;		/* fixup failed or not applicable */
+	if (provider_soft == NULL) {
+		/* fixup failed or not applicable */
+		bus->sysdata = NULL;
+		goto error_return;
+	}
 
 	/*
 	 * Generic bus fixup goes here.  Don't reference prom_bussoft_ptr
 	 * after this point.
 	 */
 
-	bus->sysdata = controller;
 	PCI_CONTROLLER(bus)->platform_data = provider_soft;
 	nasid = NASID_GET(SN_PCIBUS_BUSSOFT(bus)->bs_base);
 	cnode = nasid_to_cnodeid(nasid);
diff -purN linux-2.6.13-rc6-git13/arch/m32r/Kconfig linux-2.6.13-rc7/arch/m32r/Kconfig
--- linux-2.6.13-rc6-git13/arch/m32r/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/m32r/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -269,7 +269,7 @@ config NR_CPUS
 # Common NUMA Features
 config NUMA
 	bool "Numa Memory Allocation Support"
-	depends on SMP
+	depends on SMP && BROKEN
 	default n
 
 # turning this on wastes a bunch of space.
@@ -286,6 +286,7 @@ menu "Bus options (PCI, PCMCIA, EISA, MC
 
 config PCI
 	bool "PCI support"
+	depends on BROKEN
 	default n
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
diff -purN linux-2.6.13-rc6-git13/arch/m32r/Kconfig.debug linux-2.6.13-rc7/arch/m32r/Kconfig.debug
--- linux-2.6.13-rc6-git13/arch/m32r/Kconfig.debug	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/m32r/Kconfig.debug	2005-08-24 05:39:14.000000000 +0200
@@ -20,7 +20,7 @@ config DEBUG_STACK_USAGE
 
 config DEBUG_PAGEALLOC
 	bool "Page alloc debugging"
-	depends on DEBUG_KERNEL
+	depends on DEBUG_KERNEL && BROKEN
 	help
 	  Unmap pages from the kernel linear mapping after free_pages().
 	  This results in a large slowdown, but helps to find certain types
diff -purN linux-2.6.13-rc6-git13/arch/m32r/kernel/setup_m32700ut.c linux-2.6.13-rc7/arch/m32r/kernel/setup_m32700ut.c
--- linux-2.6.13-rc6-git13/arch/m32r/kernel/setup_m32700ut.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/m32r/kernel/setup_m32700ut.c	2005-08-24 05:39:14.000000000 +0200
@@ -30,9 +30,11 @@
 typedef struct {
 	unsigned long icucr;  /* ICU Control Register */
 } icu_data_t;
+static icu_data_t icu_data[M32700UT_NUM_CPU_IRQ];
+#else
+icu_data_t icu_data[M32700UT_NUM_CPU_IRQ];
 #endif /* CONFIG_SMP */
 
-static icu_data_t icu_data[M32700UT_NUM_CPU_IRQ];
 
 static void disable_m32700ut_irq(unsigned int irq)
 {
diff -purN linux-2.6.13-rc6-git13/arch/m32r/kernel/setup_opsput.c linux-2.6.13-rc7/arch/m32r/kernel/setup_opsput.c
--- linux-2.6.13-rc6-git13/arch/m32r/kernel/setup_opsput.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/m32r/kernel/setup_opsput.c	2005-08-24 05:39:14.000000000 +0200
@@ -31,9 +31,11 @@
 typedef struct {
 	unsigned long icucr;  /* ICU Control Register */
 } icu_data_t;
+static icu_data_t icu_data[OPSPUT_NUM_CPU_IRQ];
+#else
+icu_data_t icu_data[OPSPUT_NUM_CPU_IRQ];
 #endif /* CONFIG_SMP */
 
-static icu_data_t icu_data[OPSPUT_NUM_CPU_IRQ];
 
 static void disable_opsput_irq(unsigned int irq)
 {
diff -purN linux-2.6.13-rc6-git13/arch/m32r/kernel/smpboot.c linux-2.6.13-rc7/arch/m32r/kernel/smpboot.c
--- linux-2.6.13-rc6-git13/arch/m32r/kernel/smpboot.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/m32r/kernel/smpboot.c	2005-08-24 05:39:14.000000000 +0200
@@ -91,6 +91,7 @@ extern struct {
 
 /* which physical physical ID maps to which logical CPU number */
 static volatile int physid_2_cpu[NR_CPUS];
+#define physid_to_cpu(physid)	physid_2_cpu[physid]
 
 /* which logical CPU number maps to which physical ID */
 volatile int cpu_2_physid[NR_CPUS];
diff -purN linux-2.6.13-rc6-git13/arch/m32r/lib/csum_partial_copy.c linux-2.6.13-rc7/arch/m32r/lib/csum_partial_copy.c
--- linux-2.6.13-rc6-git13/arch/m32r/lib/csum_partial_copy.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/m32r/lib/csum_partial_copy.c	2005-08-24 05:39:14.000000000 +0200
@@ -58,3 +58,4 @@ csum_partial_copy_from_user (const unsig
 	return csum_partial(dst, len-missing, sum);
 }
 EXPORT_SYMBOL(csum_partial_copy_from_user);
+EXPORT_SYMBOL(csum_partial);
diff -purN linux-2.6.13-rc6-git13/arch/m32r/mm/discontig.c linux-2.6.13-rc7/arch/m32r/mm/discontig.c
--- linux-2.6.13-rc6-git13/arch/m32r/mm/discontig.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/m32r/mm/discontig.c	2005-08-24 05:39:14.000000000 +0200
@@ -12,12 +12,14 @@
 #include <linux/mmzone.h>
 #include <linux/initrd.h>
 #include <linux/nodemask.h>
+#include <linux/module.h>
 
 #include <asm/setup.h>
 
 extern char _end[];
 
 struct pglist_data *node_data[MAX_NUMNODES];
+EXPORT_SYMBOL(node_data);
 static bootmem_data_t node_bdata[MAX_NUMNODES] __initdata;
 
 pg_data_t m32r_node_data[MAX_NUMNODES];
diff -purN linux-2.6.13-rc6-git13/arch/ppc/Kconfig linux-2.6.13-rc7/arch/ppc/Kconfig
--- linux-2.6.13-rc6-git13/arch/ppc/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/ppc/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -911,6 +911,7 @@ config PPCBUG_NVRAM
 	default y if PPC_PREP
 
 config SMP
+	depends on PPC_STD_MMU
 	bool "Symmetric multi-processing support"
 	---help---
 	  This enables support for systems with more than one CPU. If you have
@@ -930,7 +931,7 @@ config SMP
 
 config IRQ_ALL_CPUS
 	bool "Distribute interrupts on all CPUs by default"
-	depends on SMP
+	depends on SMP && !MV64360
 	help
 	  This option gives the kernel permission to distribute IRQs across
 	  multiple CPUs.  Saying N here will route all IRQs to the first
@@ -1121,7 +1122,9 @@ config PROC_HARDWARE
 
 source "drivers/zorro/Kconfig"
 
+if !44x || BROKEN
 source kernel/power/Kconfig
+endif
 
 config SECCOMP
 	bool "Enable seccomp to safely compute untrusted bytecode"
diff -purN linux-2.6.13-rc6-git13/arch/ppc/platforms/4xx/Kconfig linux-2.6.13-rc7/arch/ppc/platforms/4xx/Kconfig
--- linux-2.6.13-rc6-git13/arch/ppc/platforms/4xx/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/ppc/platforms/4xx/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -3,6 +3,11 @@ config 4xx
 	depends on 40x || 44x
 	default y
 
+config WANT_EARLY_SERIAL
+	bool
+	select SERIAL_8250
+	default n
+
 menu "IBM 4xx options"
 	depends on 4xx
 
@@ -18,6 +23,7 @@ config ASH
 
 config BUBINGA
 	bool "Bubinga"
+	select WANT_EARLY_SERIAL
 	help
 	  This option enables support for the IBM 405EP evaluation board.
 
@@ -70,21 +76,25 @@ choice
 
 config BAMBOO
 	bool "Bamboo"
+	select WANT_EARLY_SERIAL
 	help
 	  This option enables support for the IBM PPC440EP evaluation board.
 
 config EBONY
 	bool "Ebony"
+	select WANT_EARLY_SERIAL
 	help
 	  This option enables support for the IBM PPC440GP evaluation board.
 
 config LUAN
 	bool "Luan"
+	select WANT_EARLY_SERIAL
 	help
 	  This option enables support for the IBM PPC440SP evaluation board.
 
 config OCOTEA
 	bool "Ocotea"
+	select WANT_EARLY_SERIAL
 	help
 	  This option enables support for the IBM PPC440GX evaluation board.
 
@@ -230,10 +240,6 @@ config PPC_GEN550
 	depends on 4xx
 	default y
 
-config PM
-	bool "Power Management support (EXPERIMENTAL)"
-	depends on 4xx && EXPERIMENTAL
-
 choice
 	prompt "TTYS0 device and default console"
 	depends on 40x
diff -purN linux-2.6.13-rc6-git13/arch/s390/kernel/cpcmd.c linux-2.6.13-rc7/arch/s390/kernel/cpcmd.c
--- linux-2.6.13-rc6-git13/arch/s390/kernel/cpcmd.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/s390/kernel/cpcmd.c	2005-08-24 05:39:14.000000000 +0200
@@ -46,9 +46,9 @@ int  __cpcmd(const char *cmd, char *resp
 				"lra	3,0(%4)\n"
 				"lr	5,%5\n"
 				"diag	2,4,0x8\n"
-				"brc	8, .Litfits\n"
+				"brc	8, 1f\n"
 				"ar	5, %5\n"
-				".Litfits: \n"
+				"1: \n"
 				"lr	%0,4\n"
 				"lr	%1,5\n"
 				: "=d" (return_code), "=d" (return_len)
@@ -64,9 +64,9 @@ int  __cpcmd(const char *cmd, char *resp
 				"sam31\n"
 				"diag	2,4,0x8\n"
 				"sam64\n"
-				"brc	8, .Litfits\n"
+				"brc	8, 1f\n"
 				"agr	5, %5\n"
-				".Litfits: \n"
+				"1: \n"
 				"lgr	%0,4\n"
 				"lgr	%1,5\n"
 				: "=d" (return_code), "=d" (return_len)
diff -purN linux-2.6.13-rc6-git13/arch/x86_64/pci/k8-bus.c linux-2.6.13-rc7/arch/x86_64/pci/k8-bus.c
--- linux-2.6.13-rc6-git13/arch/x86_64/pci/k8-bus.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/arch/x86_64/pci/k8-bus.c	2005-08-24 05:39:14.000000000 +0200
@@ -47,13 +47,22 @@ fill_mp_bus_to_cpumask(void)
 			 * if there are no busses hanging off of the current
 			 * ldt link then both the secondary and subordinate
 			 * bus number fields are set to 0.
+			 * 
+			 * RED-PEN
+			 * This is slightly broken because it assumes
+ 			 * HT node IDs == Linux node ids, which is not always
+			 * true. However it is probably mostly true.
 			 */
 			if (!(SECONDARY_LDT_BUS_NUMBER(ldtbus) == 0
 				&& SUBORDINATE_LDT_BUS_NUMBER(ldtbus) == 0)) {
 				for (j = SECONDARY_LDT_BUS_NUMBER(ldtbus);
 				     j <= SUBORDINATE_LDT_BUS_NUMBER(ldtbus);
-				     j++)
-					pci_bus_to_node[j] = NODE_ID(nid);
+				     j++) { 
+					int node = NODE_ID(nid);
+					if (!node_online(node))
+						node = 0;
+					pci_bus_to_node[j] = node;
+				}		
 			}
 		}
 	}
diff -purN linux-2.6.13-rc6-git13/drivers/char/Kconfig linux-2.6.13-rc7/drivers/char/Kconfig
--- linux-2.6.13-rc6-git13/drivers/char/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/char/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -80,7 +80,7 @@ config SERIAL_NONSTANDARD
 
 config COMPUTONE
 	tristate "Computone IntelliPort Plus serial support"
-	depends on SERIAL_NONSTANDARD && BROKEN_ON_SMP
+	depends on SERIAL_NONSTANDARD && BROKEN_ON_SMP && (BROKEN || !SPARC32)
 	---help---
 	  This driver supports the entire family of Intelliport II/Plus
 	  controllers with the exception of the MicroChannel controllers and
@@ -138,7 +138,7 @@ config CYZ_INTR
 
 config DIGIEPCA
 	tristate "Digiboard Intelligent Async Support"
-	depends on SERIAL_NONSTANDARD && BROKEN_ON_SMP
+	depends on SERIAL_NONSTANDARD && BROKEN_ON_SMP && (!64BIT || BROKEN)
 	---help---
 	  This is a driver for Digi International's Xx, Xeve, and Xem series
 	  of cards which provide multiple serial ports. You would need
@@ -208,7 +208,7 @@ config SYNCLINK
 
 config SYNCLINKMP
 	tristate "SyncLink Multiport support"
-	depends on SERIAL_NONSTANDARD
+	depends on SERIAL_NONSTANDARD && (BROKEN || !SPARC32)
 	help
 	  Enable support for the SyncLink Multiport (2 or 4 ports)
 	  serial adapter, running asynchronous and HDLC communications up
@@ -735,7 +735,7 @@ config SGI_IP27_RTC
 
 config GEN_RTC
 	tristate "Generic /dev/rtc emulation"
-	depends on RTC!=y && !IA64 && !ARM && !PPC64
+	depends on RTC!=y && !IA64 && !ARM && !PPC64 && !M32R && !SPARC32
 	---help---
 	  If you say Y here and create a character special file /dev/rtc with
 	  major number 10 and minor number 135 using mknod ("man mknod"), you
diff -purN linux-2.6.13-rc6-git13/drivers/infiniband/Kconfig linux-2.6.13-rc7/drivers/infiniband/Kconfig
--- linux-2.6.13-rc6-git13/drivers/infiniband/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/infiniband/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -1,6 +1,7 @@
 menu "InfiniBand support"
 
 config INFINIBAND
+	depends on PCI || BROKEN
 	tristate "InfiniBand support"
 	---help---
 	  Core support for InfiniBand (IB).  Make sure to also select
diff -purN linux-2.6.13-rc6-git13/drivers/isdn/hisax/Kconfig linux-2.6.13-rc7/drivers/isdn/hisax/Kconfig
--- linux-2.6.13-rc6-git13/drivers/isdn/hisax/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/isdn/hisax/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -134,6 +134,7 @@ config HISAX_AVM_A1
 
 config HISAX_FRITZPCI
 	bool "AVM PnP/PCI (Fritz!PnP/PCI)"
+	depends on BROKEN || !PPC64
 	help
 	  This enables HiSax support for the AVM "Fritz!PnP" and "Fritz!PCI".
 	  See <file:Documentation/isdn/README.HiSax> on how to configure it.
diff -purN linux-2.6.13-rc6-git13/drivers/macintosh/Kconfig linux-2.6.13-rc7/drivers/macintosh/Kconfig
--- linux-2.6.13-rc6-git13/drivers/macintosh/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/macintosh/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -103,7 +103,7 @@ config PMAC_MEDIABAY
 # on non-powerbook machines (but only on PMU based ones AFAIK)
 config PMAC_BACKLIGHT
 	bool "Backlight control for LCD screens"
-	depends on ADB_PMU
+	depends on ADB_PMU && (BROKEN || !PPC64)
 	help
 	  Say Y here to build in code to manage the LCD backlight on a
 	  Macintosh PowerBook.  With this code, the backlight will be turned
diff -purN linux-2.6.13-rc6-git13/drivers/md/md.c linux-2.6.13-rc7/drivers/md/md.c
--- linux-2.6.13-rc6-git13/drivers/md/md.c	2005-08-21 12:03:33.000000000 +0200
+++ linux-2.6.13-rc7/drivers/md/md.c	2005-08-24 05:39:14.000000000 +0200
@@ -256,8 +256,7 @@ static inline void mddev_unlock(mddev_t 
 {
 	up(&mddev->reconfig_sem);
 
-	if (mddev->thread)
-		md_wakeup_thread(mddev->thread);
+	md_wakeup_thread(mddev->thread);
 }
 
 mdk_rdev_t * find_rdev_nr(mddev_t *mddev, int nr)
@@ -1714,6 +1713,7 @@ static int do_md_run(mddev_t * mddev)
 	mddev->in_sync = 1;
 	
 	set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
+	md_wakeup_thread(mddev->thread);
 	
 	if (mddev->sb_dirty)
 		md_update_sb(mddev);
@@ -2236,8 +2236,7 @@ static int add_new_disk(mddev_t * mddev,
 			export_rdev(rdev);
 
 		set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
-		if (mddev->thread)
-			md_wakeup_thread(mddev->thread);
+		md_wakeup_thread(mddev->thread);
 		return err;
 	}
 
diff -purN linux-2.6.13-rc6-git13/drivers/media/video/Kconfig linux-2.6.13-rc7/drivers/media/video/Kconfig
--- linux-2.6.13-rc6-git13/drivers/media/video/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/media/video/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -356,7 +356,7 @@ config VIDEO_M32R_AR
 
 config VIDEO_M32R_AR_M64278
 	tristate "Use Colour AR module M64278(VGA)"
-	depends on VIDEO_M32R_AR
+	depends on VIDEO_M32R_AR && PLAT_M32700UT
 	---help---
 	  Say Y here to use the Renesas M64278E-800 camera module,
 	  which supports VGA(640x480 pixcels) size of images.
diff -purN linux-2.6.13-rc6-git13/drivers/net/Kconfig linux-2.6.13-rc7/drivers/net/Kconfig
--- linux-2.6.13-rc6-git13/drivers/net/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/net/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -1145,7 +1145,7 @@ config IBMVETH
 	  be called ibmveth.
 
 config IBM_EMAC
-	tristate "IBM PPC4xx EMAC driver support"
+	bool "IBM PPC4xx EMAC driver support"
 	depends on 4xx
 	select CRC32
 	---help---
@@ -1154,7 +1154,7 @@ config IBM_EMAC
 
 config IBM_EMAC_ERRMSG
 	bool "Verbose error messages"
-	depends on IBM_EMAC
+	depends on IBM_EMAC && BROKEN
 
 config IBM_EMAC_RXB
 	int "Number of receive buffers"
diff -purN linux-2.6.13-rc6-git13/drivers/net/ibm_emac/ibm_emac_core.c linux-2.6.13-rc7/drivers/net/ibm_emac/ibm_emac_core.c
--- linux-2.6.13-rc6-git13/drivers/net/ibm_emac/ibm_emac_core.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/net/ibm_emac/ibm_emac_core.c	2005-08-24 05:39:14.000000000 +0200
@@ -1712,11 +1712,10 @@ struct mal_commac_ops emac_commac_ops = 
 };
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
-static int emac_netpoll(struct net_device *ndev)
+static void emac_netpoll(struct net_device *ndev)
 {
 	emac_rxeob_dev((void *)ndev, 0);
 	emac_txeob_dev((void *)ndev, 0);
-	return 0;
 }
 #endif
 
diff -purN linux-2.6.13-rc6-git13/drivers/net/tokenring/Kconfig linux-2.6.13-rc7/drivers/net/tokenring/Kconfig
--- linux-2.6.13-rc6-git13/drivers/net/tokenring/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/net/tokenring/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -84,7 +84,7 @@ config 3C359
 
 config TMS380TR
 	tristate "Generic TMS380 Token Ring ISA/PCI adapter support"
-	depends on TR && (PCI || ISA)
+	depends on TR && (PCI || ISA && ISA_DMA_API)
 	select FW_LOADER
 	---help---
 	  This driver provides generic support for token ring adapters
diff -purN linux-2.6.13-rc6-git13/drivers/net/wireless/Kconfig linux-2.6.13-rc7/drivers/net/wireless/Kconfig
--- linux-2.6.13-rc6-git13/drivers/net/wireless/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/net/wireless/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -270,7 +270,7 @@ config PCMCIA_HERMES
 
 config AIRO_CS
 	tristate "Cisco/Aironet 34X/35X/4500/4800 PCMCIA cards"
-	depends on NET_RADIO && PCMCIA
+	depends on NET_RADIO && PCMCIA && (BROKEN || !M32R)
 	---help---
 	  This is the standard Linux driver to support Cisco/Aironet PCMCIA
 	  802.11 wireless cards.  This driver is the same as the Aironet
diff -purN linux-2.6.13-rc6-git13/drivers/parport/Kconfig linux-2.6.13-rc7/drivers/parport/Kconfig
--- linux-2.6.13-rc6-git13/drivers/parport/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/parport/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -34,7 +34,7 @@ config PARPORT
 
 config PARPORT_PC
 	tristate "PC-style hardware"
-	depends on PARPORT && (!SPARC64 || PCI) && !SPARC32
+	depends on PARPORT && (!SPARC64 || PCI) && !SPARC32 && !M32R
 	---help---
 	  You should say Y here if you have a PC-style parallel port. All
 	  IBM PC compatible computers and some Alphas have PC-style
diff -purN linux-2.6.13-rc6-git13/drivers/pcmcia/pcmcia_resource.c linux-2.6.13-rc7/drivers/pcmcia/pcmcia_resource.c
--- linux-2.6.13-rc6-git13/drivers/pcmcia/pcmcia_resource.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/pcmcia/pcmcia_resource.c	2005-08-24 05:39:14.000000000 +0200
@@ -41,6 +41,7 @@ module_param(io_speed, int, 0444);
 
 
 #ifdef CONFIG_PCMCIA_PROBE
+#include <asm/irq.h>
 /* mask of IRQs already reserved by other cards, we should avoid using them */
 static u8 pcmcia_used_irq[NR_IRQS];
 #endif
diff -purN linux-2.6.13-rc6-git13/drivers/s390/cio/qdio.c linux-2.6.13-rc7/drivers/s390/cio/qdio.c
--- linux-2.6.13-rc6-git13/drivers/s390/cio/qdio.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/s390/cio/qdio.c	2005-08-24 05:39:14.000000000 +0200
@@ -230,7 +230,7 @@ qdio_siga_input(struct qdio_q *q)
 }
 
 /* locked by the locks in qdio_activate and qdio_cleanup */
-static __u32 * volatile 
+static __u32 volatile *
 qdio_get_indicator(void)
 {
 	int i;
diff -purN linux-2.6.13-rc6-git13/drivers/s390/crypto/z90crypt.h linux-2.6.13-rc7/drivers/s390/crypto/z90crypt.h
--- linux-2.6.13-rc6-git13/drivers/s390/crypto/z90crypt.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/s390/crypto/z90crypt.h	2005-08-24 05:39:14.000000000 +0200
@@ -36,15 +36,6 @@
 #define z90crypt_VARIANT 2	// 2 = added PCIXCC MCL3 and CEX2C support
 
 /**
- * If we are not using the sparse checker, __user has no use.
- */
-#ifdef __CHECKER__
-# define __user		__attribute__((noderef, address_space(1)))
-#else
-# define __user
-#endif
-
-/**
  * struct ica_rsa_modexpo
  *
  * Requirements:
diff -purN linux-2.6.13-rc6-git13/drivers/scsi/Kconfig linux-2.6.13-rc7/drivers/scsi/Kconfig
--- linux-2.6.13-rc6-git13/drivers/scsi/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/scsi/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -1696,7 +1696,7 @@ config TT_DMA_EMUL
 
 config MAC_SCSI
 	bool "Macintosh NCR5380 SCSI"
-	depends on MAC && SCSI
+	depends on MAC && SCSI=y
 	help
 	  This is the NCR 5380 SCSI controller included on most of the 68030
 	  based Macintoshes.  If you have one of these say Y and read the
@@ -1717,7 +1717,7 @@ config SCSI_MAC_ESP
 
 config MVME147_SCSI
 	bool "WD33C93 SCSI driver for MVME147"
-	depends on MVME147 && SCSI
+	depends on MVME147 && SCSI=y
 	help
 	  Support for the on-board SCSI controller on the Motorola MVME147
 	  single-board computer.
@@ -1758,7 +1758,7 @@ config SUN3_SCSI
 
 config SUN3X_ESP
 	bool "Sun3x ESP SCSI"
-	depends on SUN3X && SCSI
+	depends on SUN3X && SCSI=y
 	help
 	  The ESP was an on-board SCSI controller used on Sun 3/80
 	  machines.  Say Y here to compile in support for it.
diff -purN linux-2.6.13-rc6-git13/drivers/scsi/ahci.c linux-2.6.13-rc7/drivers/scsi/ahci.c
--- linux-2.6.13-rc6-git13/drivers/scsi/ahci.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/scsi/ahci.c	2005-08-24 05:39:14.000000000 +0200
@@ -1105,6 +1105,7 @@ MODULE_AUTHOR("Jeff Garzik");
 MODULE_DESCRIPTION("AHCI SATA low-level driver");
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(pci, ahci_pci_tbl);
+MODULE_VERSION(DRV_VERSION);
 
 module_init(ahci_init);
 module_exit(ahci_exit);
diff -purN linux-2.6.13-rc6-git13/drivers/scsi/arm/Kconfig linux-2.6.13-rc7/drivers/scsi/arm/Kconfig
--- linux-2.6.13-rc6-git13/drivers/scsi/arm/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/scsi/arm/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -3,7 +3,7 @@
 #
 config SCSI_ACORNSCSI_3
 	tristate "Acorn SCSI card (aka30) support"
-	depends on ARCH_ACORN && SCSI
+	depends on ARCH_ACORN && SCSI && BROKEN
 	help
 	  This enables support for the Acorn SCSI card (aka30). If you have an
 	  Acorn system with one of these, say Y. If unsure, say N.
diff -purN linux-2.6.13-rc6-git13/drivers/scsi/ata_piix.c linux-2.6.13-rc7/drivers/scsi/ata_piix.c
--- linux-2.6.13-rc6-git13/drivers/scsi/ata_piix.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/scsi/ata_piix.c	2005-08-24 05:39:14.000000000 +0200
@@ -32,7 +32,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"ata_piix"
-#define DRV_VERSION	"1.03"
+#define DRV_VERSION	"1.04"
 
 enum {
 	PIIX_IOCFG		= 0x54, /* IDE I/O configuration register */
diff -purN linux-2.6.13-rc6-git13/drivers/scsi/libata-core.c linux-2.6.13-rc7/drivers/scsi/libata-core.c
--- linux-2.6.13-rc6-git13/drivers/scsi/libata-core.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/scsi/libata-core.c	2005-08-24 05:39:14.000000000 +0200
@@ -2268,19 +2268,6 @@ void ata_qc_prep(struct ata_queued_cmd *
  *	spin_lock_irqsave(host_set lock)
  */
 
-
-
-/**
- *	ata_sg_init_one - Prepare a one-entry scatter-gather list.
- *	@qc:  Queued command
- *	@buf:  transfer buffer
- *	@buflen:  length of buf
- *
- *	Builds a single-entry scatter-gather list to initiate a
- *	transfer utilizing the specified buffer.
- *
- *	LOCKING:
- */
 void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf, unsigned int buflen)
 {
 	struct scatterlist *sg;
@@ -2312,18 +2299,6 @@ void ata_sg_init_one(struct ata_queued_c
  *	spin_lock_irqsave(host_set lock)
  */
 
-
-/**
- *	ata_sg_init - Assign a scatter gather list to a queued command
- *	@qc:  Queued command
- *	@sg:  Scatter-gather list
- *	@n_elem:  length of sg list
- *
- *	Attaches a scatter-gather list to a queued command.
- *
- *	LOCKING:
- */
-
 void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
 		 unsigned int n_elem)
 {
diff -purN linux-2.6.13-rc6-git13/drivers/scsi/libata.h linux-2.6.13-rc7/drivers/scsi/libata.h
--- linux-2.6.13-rc6-git13/drivers/scsi/libata.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/scsi/libata.h	2005-08-24 05:39:14.000000000 +0200
@@ -26,7 +26,7 @@
 #define __LIBATA_H__
 
 #define DRV_NAME	"libata"
-#define DRV_VERSION	"1.11"	/* must be exactly four chars */
+#define DRV_VERSION	"1.12"	/* must be exactly four chars */
 
 struct ata_scsi_args {
 	u16			*id;
diff -purN linux-2.6.13-rc6-git13/drivers/scsi/sata_promise.c linux-2.6.13-rc7/drivers/scsi/sata_promise.c
--- linux-2.6.13-rc6-git13/drivers/scsi/sata_promise.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/scsi/sata_promise.c	2005-08-24 05:39:14.000000000 +0200
@@ -40,7 +40,7 @@
 #include "sata_promise.h"
 
 #define DRV_NAME	"sata_promise"
-#define DRV_VERSION	"1.01"
+#define DRV_VERSION	"1.02"
 
 
 enum {
diff -purN linux-2.6.13-rc6-git13/drivers/serial/Kconfig linux-2.6.13-rc7/drivers/serial/Kconfig
--- linux-2.6.13-rc6-git13/drivers/serial/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/serial/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -211,7 +211,7 @@ comment "Non-8250 serial port support"
 
 config SERIAL_AMBA_PL010
 	tristate "ARM AMBA PL010 serial port support"
-	depends on ARM_AMBA
+	depends on ARM_AMBA && (BROKEN || !ARCH_VERSATILE)
 	select SERIAL_CORE
 	help
 	  This selects the ARM(R) AMBA(R) PrimeCell PL010 UART.  If you have
@@ -819,7 +819,7 @@ config SERIAL_M32R_SIO_CONSOLE
 
 config SERIAL_M32R_PLDSIO
 	bool "M32R SIO I/F on a PLD"
-	depends on SERIAL_M32R_SIO=y
+	depends on SERIAL_M32R_SIO=y && (PLAT_OPSPUT || PALT_USRV || PLAT_M32700UT)
 	default n
 	help
 	  Say Y here if you want to use the M32R serial controller
diff -purN linux-2.6.13-rc6-git13/drivers/serial/m32r_sio.c linux-2.6.13-rc7/drivers/serial/m32r_sio.c
--- linux-2.6.13-rc6-git13/drivers/serial/m32r_sio.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/serial/m32r_sio.c	2005-08-24 05:39:14.000000000 +0200
@@ -1123,7 +1123,7 @@ static int __init m32r_sio_console_setup
 	return uart_set_options(port, co, baud, parity, bits, flow);
 }
 
-extern struct uart_driver m32r_sio_reg;
+static struct uart_driver m32r_sio_reg;
 static struct console m32r_sio_console = {
 	.name		= "ttyS",
 	.write		= m32r_sio_console_write,
diff -purN linux-2.6.13-rc6-git13/drivers/usb/net/usbnet.c linux-2.6.13-rc7/drivers/usb/net/usbnet.c
--- linux-2.6.13-rc6-git13/drivers/usb/net/usbnet.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/usb/net/usbnet.c	2005-08-24 05:39:14.000000000 +0200
@@ -1922,7 +1922,7 @@ static int genelink_rx_fixup (struct usb
 
 			// copy the packet data to the new skb
 			memcpy(skb_put(gl_skb, size), packet->packet_data, size);
-			skb_return (dev, skb);
+			skb_return (dev, gl_skb);
 		}
 
 		// advance to the next packet
diff -purN linux-2.6.13-rc6-git13/drivers/usb/net/zd1201.c linux-2.6.13-rc7/drivers/usb/net/zd1201.c
--- linux-2.6.13-rc6-git13/drivers/usb/net/zd1201.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/usb/net/zd1201.c	2005-08-24 05:39:14.000000000 +0200
@@ -346,8 +346,7 @@ static void zd1201_usbrx(struct urb *urb
 			if (datalen<14)
 				goto resubmit;
 			if ((seq & IEEE802_11_SCTL_FRAG) == 0) {
-				frag = kmalloc(sizeof(struct zd1201_frag*),
-				    GFP_ATOMIC);
+				frag = kmalloc(sizeof(*frag), GFP_ATOMIC);
 				if (!frag)
 					goto resubmit;
 				skb = dev_alloc_skb(IEEE802_11_DATA_LEN +14+2);
diff -purN linux-2.6.13-rc6-git13/drivers/video/console/Kconfig linux-2.6.13-rc7/drivers/video/console/Kconfig
--- linux-2.6.13-rc6-git13/drivers/video/console/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/drivers/video/console/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -6,7 +6,7 @@ menu "Console display driver support"
 
 config VGA_CONSOLE
 	bool "VGA text console" if EMBEDDED || !X86
-	depends on !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC32 && !SPARC64 && !M68K && !PARISC
+	depends on !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC32 && !SPARC64 && !M68K && !PARISC && !ARCH_VERSATILE
 	default y
 	help
 	  Saying Y here will allow you to use Linux in text mode through a
diff -purN linux-2.6.13-rc6-git13/include/asm-alpha/system.h linux-2.6.13-rc7/include/asm-alpha/system.h
--- linux-2.6.13-rc6-git13/include/asm-alpha/system.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-alpha/system.h	2005-08-24 05:39:14.000000000 +0200
@@ -443,22 +443,19 @@ __xchg_u64(volatile long *m, unsigned lo
    if something tries to do an invalid xchg().  */
 extern void __xchg_called_with_bad_pointer(void);
 
-static inline unsigned long
-__xchg(volatile void *ptr, unsigned long x, int size)
-{
-	switch (size) {
-		case 1:
-			return __xchg_u8(ptr, x);
-		case 2:
-			return __xchg_u16(ptr, x);
-		case 4:
-			return __xchg_u32(ptr, x);
-		case 8:
-			return __xchg_u64(ptr, x);
-	}
-	__xchg_called_with_bad_pointer();
-	return x;
-}
+#define __xchg(ptr, x, size) \
+({ \
+	unsigned long __xchg__res; \
+	volatile void *__xchg__ptr = (ptr); \
+	switch (size) { \
+		case 1: __xchg__res = __xchg_u8(__xchg__ptr, x); break; \
+		case 2: __xchg__res = __xchg_u16(__xchg__ptr, x); break; \
+		case 4: __xchg__res = __xchg_u32(__xchg__ptr, x); break; \
+		case 8: __xchg__res = __xchg_u64(__xchg__ptr, x); break; \
+		default: __xchg_called_with_bad_pointer(); __xchg__res = x; \
+	} \
+	__xchg__res; \
+})
 
 #define xchg(ptr,x)							     \
   ({									     \
diff -purN linux-2.6.13-rc6-git13/include/asm-arm/arch-ixp4xx/timex.h linux-2.6.13-rc7/include/asm-arm/arch-ixp4xx/timex.h
--- linux-2.6.13-rc6-git13/include/asm-arm/arch-ixp4xx/timex.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-arm/arch-ixp4xx/timex.h	2005-08-24 05:39:14.000000000 +0200
@@ -7,7 +7,9 @@
 
 /*
  * We use IXP425 General purpose timer for our timer needs, it runs at 
- * 66.66... MHz
+ * 66.66... MHz. We do a convulted calculation of CLOCK_TICK_RATE b/c the
+ * timer register ignores the bottom 2 bits of the LATCH value.
  */
-#define CLOCK_TICK_RATE (66666666)
+#define FREQ 66666666
+#define CLOCK_TICK_RATE (((FREQ / HZ & ~IXP4XX_OST_RELOAD_MASK) + 1) * HZ)
 
diff -purN linux-2.6.13-rc6-git13/include/asm-arm/bug.h linux-2.6.13-rc7/include/asm-arm/bug.h
--- linux-2.6.13-rc6-git13/include/asm-arm/bug.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-arm/bug.h	2005-08-24 05:39:14.000000000 +0200
@@ -5,7 +5,7 @@
 
 #ifdef CONFIG_BUG
 #ifdef CONFIG_DEBUG_BUGVERBOSE
-extern volatile void __bug(const char *file, int line, void *data);
+extern void __bug(const char *file, int line, void *data) __attribute__((noreturn));
 
 /* give file/line information */
 #define BUG()		__bug(__FILE__, __LINE__, NULL)
diff -purN linux-2.6.13-rc6-git13/include/asm-arm/cpu-multi32.h linux-2.6.13-rc7/include/asm-arm/cpu-multi32.h
--- linux-2.6.13-rc6-git13/include/asm-arm/cpu-multi32.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-arm/cpu-multi32.h	2005-08-24 05:39:14.000000000 +0200
@@ -31,7 +31,7 @@ extern struct processor {
 	/*
 	 * Special stuff for a reset
 	 */
-	volatile void (*reset)(unsigned long addr);
+	void (*reset)(unsigned long addr) __attribute__((noreturn));
 	/*
 	 * Idle the processor
 	 */
diff -purN linux-2.6.13-rc6-git13/include/asm-arm/cpu-single.h linux-2.6.13-rc7/include/asm-arm/cpu-single.h
--- linux-2.6.13-rc6-git13/include/asm-arm/cpu-single.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-arm/cpu-single.h	2005-08-24 05:39:14.000000000 +0200
@@ -41,4 +41,4 @@ extern int cpu_do_idle(void);
 extern void cpu_dcache_clean_area(void *, int);
 extern void cpu_do_switch_mm(unsigned long pgd_phys, struct mm_struct *mm);
 extern void cpu_set_pte(pte_t *ptep, pte_t pte);
-extern volatile void cpu_reset(unsigned long addr);
+extern void cpu_reset(unsigned long addr) __attribute__((noreturn));
diff -purN linux-2.6.13-rc6-git13/include/asm-ia64/io.h linux-2.6.13-rc7/include/asm-ia64/io.h
--- linux-2.6.13-rc6-git13/include/asm-ia64/io.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-ia64/io.h	2005-08-24 05:39:14.000000000 +0200
@@ -120,14 +120,6 @@ static inline void ___ia64_mmiowb(void)
 	ia64_mfa();
 }
 
-static inline const unsigned long
-__ia64_get_io_port_base (void)
-{
-	extern unsigned long ia64_iobase;
-
-	return ia64_iobase;
-}
-
 static inline void*
 __ia64_mk_io_addr (unsigned long port)
 {
diff -purN linux-2.6.13-rc6-git13/include/asm-m32r/smp.h linux-2.6.13-rc7/include/asm-m32r/smp.h
--- linux-2.6.13-rc6-git13/include/asm-m32r/smp.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-m32r/smp.h	2005-08-24 05:39:14.000000000 +0200
@@ -61,9 +61,7 @@ extern physid_mask_t phys_cpu_present_ma
  * Some lowlevel functions might want to know about
  * the real CPU ID <-> CPU # mapping.
  */
-extern volatile int physid_2_cpu[NR_CPUS];
 extern volatile int cpu_2_physid[NR_CPUS];
-#define physid_to_cpu(physid)	physid_2_cpu[physid]
 #define cpu_to_physid(cpu_id)	cpu_2_physid[cpu_id]
 
 #define raw_smp_processor_id()	(current_thread_info()->cpu)
diff -purN linux-2.6.13-rc6-git13/include/asm-ppc/time.h linux-2.6.13-rc7/include/asm-ppc/time.h
--- linux-2.6.13-rc6-git13/include/asm-ppc/time.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-ppc/time.h	2005-08-24 05:39:14.000000000 +0200
@@ -58,7 +58,7 @@ static __inline__ void set_dec(unsigned 
 /* Accessor functions for the timebase (RTC on 601) registers. */
 /* If one day CONFIG_POWER is added just define __USE_RTC as 1 */
 #ifdef CONFIG_6xx
-extern __inline__ int const __USE_RTC(void) {
+extern __inline__ int __attribute_pure__ __USE_RTC(void) {
 	return (mfspr(SPRN_PVR)>>16) == 1;
 }
 #else
diff -purN linux-2.6.13-rc6-git13/include/asm-s390/uaccess.h linux-2.6.13-rc7/include/asm-s390/uaccess.h
--- linux-2.6.13-rc6-git13/include/asm-s390/uaccess.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/asm-s390/uaccess.h	2005-08-24 05:39:14.000000000 +0200
@@ -149,11 +149,11 @@ struct exception_table_entry
 })
 #endif
 
-#ifndef __CHECKER__
 #define __put_user(x, ptr) \
 ({								\
 	__typeof__(*(ptr)) __x = (x);				\
 	int __pu_err;						\
+        __chk_user_ptr(ptr);                                    \
 	switch (sizeof (*(ptr))) {				\
 	case 1:							\
 	case 2:							\
@@ -167,14 +167,6 @@ struct exception_table_entry
 	 }							\
 	__pu_err;						\
 })
-#else
-#define __put_user(x, ptr)			\
-({						\
-	void __user *p;				\
-	p = (ptr);				\
-	0;					\
-})
-#endif
 
 #define put_user(x, ptr)					\
 ({								\
@@ -213,11 +205,11 @@ extern int __put_user_bad(void) __attrib
 })
 #endif
 
-#ifndef __CHECKER__
 #define __get_user(x, ptr)					\
 ({								\
 	__typeof__(*(ptr)) __x;					\
 	int __gu_err;						\
+        __chk_user_ptr(ptr);                                    \
 	switch (sizeof(*(ptr))) {				\
 	case 1:							\
 	case 2:							\
@@ -232,15 +224,6 @@ extern int __put_user_bad(void) __attrib
 	(x) = __x;						\
 	__gu_err;						\
 })
-#else
-#define __get_user(x, ptr)			\
-({						\
-	void __user *p;				\
-	p = (ptr);				\
-	0;					\
-})
-#endif
-
 
 #define get_user(x, ptr)					\
 ({								\
diff -purN linux-2.6.13-rc6-git13/include/net/ax25.h linux-2.6.13-rc7/include/net/ax25.h
--- linux-2.6.13-rc6-git13/include/net/ax25.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/net/ax25.h	2005-08-24 05:39:14.000000000 +0200
@@ -139,11 +139,25 @@ enum {
 #define AX25_DEF_DS_TIMEOUT	(3 * 60 * HZ)		/* DAMA timeout 3 minutes */
 
 typedef struct ax25_uid_assoc {
-	struct ax25_uid_assoc	*next;
+	struct hlist_node	uid_node;
+	atomic_t		refcount;
 	uid_t			uid;
 	ax25_address		call;
 } ax25_uid_assoc;
 
+#define ax25_uid_for_each(__ax25, node, list) \
+	hlist_for_each_entry(__ax25, node, list, uid_node)
+
+#define ax25_uid_hold(ax25) \
+	atomic_inc(&((ax25)->refcount))
+
+static inline void ax25_uid_put(ax25_uid_assoc *assoc)
+{
+	if (atomic_dec_and_test(&assoc->refcount)) {
+		kfree(assoc);
+	}
+}
+
 typedef struct {
 	ax25_address		calls[AX25_MAX_DIGIS];
 	unsigned char		repeated[AX25_MAX_DIGIS];
@@ -376,7 +390,7 @@ extern unsigned long ax25_display_timer(
 
 /* ax25_uid.c */
 extern int  ax25_uid_policy;
-extern ax25_address *ax25_findbyuid(uid_t);
+extern ax25_uid_assoc *ax25_findbyuid(uid_t);
 extern int  ax25_uid_ioctl(int, struct sockaddr_ax25 *);
 extern struct file_operations ax25_uid_fops;
 extern void ax25_uid_free(void);
diff -purN linux-2.6.13-rc6-git13/include/net/sock.h linux-2.6.13-rc7/include/net/sock.h
--- linux-2.6.13-rc6-git13/include/net/sock.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/net/sock.h	2005-08-24 05:39:14.000000000 +0200
@@ -384,6 +384,11 @@ enum sock_flags {
 	SOCK_QUEUE_SHRUNK, /* write queue has been shrunk recently */
 };
 
+static inline void sock_copy_flags(struct sock *nsk, struct sock *osk)
+{
+	nsk->sk_flags = osk->sk_flags;
+}
+
 static inline void sock_set_flag(struct sock *sk, enum sock_flags flag)
 {
 	__set_bit(flag, &sk->sk_flags);
diff -purN linux-2.6.13-rc6-git13/include/sound/core.h linux-2.6.13-rc7/include/sound/core.h
--- linux-2.6.13-rc6-git13/include/sound/core.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/include/sound/core.h	2005-08-24 05:39:14.000000000 +0200
@@ -360,11 +360,13 @@ int snd_device_free_all(snd_card_t *card
 
 /* isadma.c */
 
+#ifdef CONFIG_ISA_DMA_API
 #define DMA_MODE_NO_ENABLE	0x0100
 
 void snd_dma_program(unsigned long dma, unsigned long addr, unsigned int size, unsigned short mode);
 void snd_dma_disable(unsigned long dma);
 unsigned int snd_dma_pointer(unsigned long dma, unsigned int size);
+#endif
 
 /* misc.c */
 
diff -purN linux-2.6.13-rc6-git13/kernel/cpuset.c linux-2.6.13-rc7/kernel/cpuset.c
--- linux-2.6.13-rc6-git13/kernel/cpuset.c	2005-08-21 12:03:34.000000000 +0200
+++ linux-2.6.13-rc7/kernel/cpuset.c	2005-08-24 05:39:14.000000000 +0200
@@ -636,6 +636,23 @@ static void update_cpu_domains(struct cp
 		return;
 
 	/*
+	 * Hack to avoid 2.6.13 partial node dynamic sched domain bug.
+	 * Require the 'cpu_exclusive' cpuset to include all (or none)
+	 * of the CPUs on each node, or return w/o changing sched domains.
+	 * Remove this hack when dynamic sched domains fixed.
+	 */
+	{
+		int i, j;
+
+		for_each_cpu_mask(i, cur->cpus_allowed) {
+			for_each_cpu_mask(j, node_to_cpumask(cpu_to_node(i))) {
+				if (!cpu_isset(j, cur->cpus_allowed))
+					return;
+			}
+		}
+	}
+
+	/*
 	 * Get all cpus from parent's cpus_allowed not part of exclusive
 	 * children
 	 */
diff -purN linux-2.6.13-rc6-git13/kernel/timer.c linux-2.6.13-rc7/kernel/timer.c
--- linux-2.6.13-rc6-git13/kernel/timer.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/kernel/timer.c	2005-08-24 05:39:14.000000000 +0200
@@ -1023,7 +1023,7 @@ asmlinkage long sys_getppid(void)
 	parent = me->group_leader->real_parent;
 	for (;;) {
 		pid = parent->tgid;
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)
 {
 		struct task_struct *old = parent;
 
diff -purN linux-2.6.13-rc6-git13/lib/vsprintf.c linux-2.6.13-rc7/lib/vsprintf.c
--- linux-2.6.13-rc6-git13/lib/vsprintf.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/lib/vsprintf.c	2005-08-24 05:39:14.000000000 +0200
@@ -269,6 +269,7 @@ int vsnprintf(char *buf, size_t size, co
 	int qualifier;		/* 'h', 'l', or 'L' for integer fields */
 				/* 'z' support added 23/7/1999 S.H.    */
 				/* 'z' changed to 'Z' --davidm 1/25/99 */
+				/* 't' added for ptrdiff_t */
 
 	/* Reject out-of-range values early */
 	if (unlikely((int) size < 0)) {
@@ -339,7 +340,7 @@ int vsnprintf(char *buf, size_t size, co
 		/* get the conversion qualifier */
 		qualifier = -1;
 		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
-		    *fmt =='Z' || *fmt == 'z') {
+		    *fmt =='Z' || *fmt == 'z' || *fmt == 't') {
 			qualifier = *fmt;
 			++fmt;
 			if (qualifier == 'l' && *fmt == 'l') {
@@ -467,6 +468,8 @@ int vsnprintf(char *buf, size_t size, co
 				num = (signed long) num;
 		} else if (qualifier == 'Z' || qualifier == 'z') {
 			num = va_arg(args, size_t);
+		} else if (qualifier == 't') {
+			num = va_arg(args, ptrdiff_t);
 		} else if (qualifier == 'h') {
 			num = (unsigned short) va_arg(args, int);
 			if (flags & SIGN)
diff -purN linux-2.6.13-rc6-git13/net/ax25/af_ax25.c linux-2.6.13-rc7/net/ax25/af_ax25.c
--- linux-2.6.13-rc6-git13/net/ax25/af_ax25.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ax25/af_ax25.c	2005-08-24 05:39:14.000000000 +0200
@@ -875,12 +875,7 @@ struct sock *ax25_make_new(struct sock *
 	sk->sk_sndbuf   = osk->sk_sndbuf;
 	sk->sk_state    = TCP_ESTABLISHED;
 	sk->sk_sleep    = osk->sk_sleep;
-
-	if (sock_flag(osk, SOCK_DBG))
-		sock_set_flag(sk, SOCK_DBG);
-
-	if (sock_flag(osk, SOCK_ZAPPED))
-		sock_set_flag(sk, SOCK_ZAPPED);
+	sock_copy_flags(sk, osk);
 
 	oax25 = ax25_sk(osk);
 
@@ -1007,7 +1002,8 @@ static int ax25_bind(struct socket *sock
 	struct sock *sk = sock->sk;
 	struct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;
 	ax25_dev *ax25_dev = NULL;
-	ax25_address *call;
+	ax25_uid_assoc *user;
+	ax25_address call;
 	ax25_cb *ax25;
 	int err = 0;
 
@@ -1026,9 +1022,15 @@ static int ax25_bind(struct socket *sock
 	if (addr->fsa_ax25.sax25_family != AF_AX25)
 		return -EINVAL;
 
-	call = ax25_findbyuid(current->euid);
-	if (call == NULL && ax25_uid_policy && !capable(CAP_NET_ADMIN)) {
-		return -EACCES;
+	user = ax25_findbyuid(current->euid);
+	if (user) {
+		call = user->call;
+		ax25_uid_put(user);
+	} else {
+		if (ax25_uid_policy && !capable(CAP_NET_ADMIN))
+			return -EACCES;
+
+		call = addr->fsa_ax25.sax25_call;
 	}
 
 	lock_sock(sk);
@@ -1039,10 +1041,7 @@ static int ax25_bind(struct socket *sock
 		goto out;
 	}
 
-	if (call == NULL)
-		ax25->source_addr = addr->fsa_ax25.sax25_call;
-	else
-		ax25->source_addr = *call;
+	ax25->source_addr = call;
 
 	/*
 	 * User already set interface with SO_BINDTODEVICE
diff -purN linux-2.6.13-rc6-git13/net/ax25/ax25_route.c linux-2.6.13-rc7/net/ax25/ax25_route.c
--- linux-2.6.13-rc6-git13/net/ax25/ax25_route.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ax25/ax25_route.c	2005-08-24 05:39:14.000000000 +0200
@@ -422,8 +422,8 @@ static inline void ax25_adjust_path(ax25
  */
 int ax25_rt_autobind(ax25_cb *ax25, ax25_address *addr)
 {
+	ax25_uid_assoc *user;
 	ax25_route *ax25_rt;
-	ax25_address *call;
 	int err;
 
 	if ((ax25_rt = ax25_get_route(addr, NULL)) == NULL)
@@ -434,16 +434,18 @@ int ax25_rt_autobind(ax25_cb *ax25, ax25
 		goto put;
 	}
 
-	if ((call = ax25_findbyuid(current->euid)) == NULL) {
+	user = ax25_findbyuid(current->euid);
+	if (user) {
+		ax25->source_addr = user->call;
+		ax25_uid_put(user);
+	} else {
 		if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {
 			err = -EPERM;
 			goto put;
 		}
-		call = (ax25_address *)ax25->ax25_dev->dev->dev_addr;
+		ax25->source_addr = *(ax25_address *)ax25->ax25_dev->dev->dev_addr;
 	}
 
-	ax25->source_addr = *call;
-
 	if (ax25_rt->digipeat != NULL) {
 		if ((ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
 			err = -ENOMEM;
diff -purN linux-2.6.13-rc6-git13/net/ax25/ax25_uid.c linux-2.6.13-rc7/net/ax25/ax25_uid.c
--- linux-2.6.13-rc6-git13/net/ax25/ax25_uid.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ax25/ax25_uid.c	2005-08-24 05:39:14.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/fcntl.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
+#include <linux/list.h>
 #include <linux/notifier.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
@@ -41,38 +42,41 @@
  *	Callsign/UID mapper. This is in kernel space for security on multi-amateur machines.
  */
 
-static ax25_uid_assoc *ax25_uid_list;
+HLIST_HEAD(ax25_uid_list);
 static DEFINE_RWLOCK(ax25_uid_lock);
 
 int ax25_uid_policy = 0;
 
-ax25_address *ax25_findbyuid(uid_t uid)
+ax25_uid_assoc *ax25_findbyuid(uid_t uid)
 {
-	ax25_uid_assoc *ax25_uid;
-	ax25_address *res = NULL;
+	ax25_uid_assoc *ax25_uid, *res = NULL;
+	struct hlist_node *node;
 
 	read_lock(&ax25_uid_lock);
-	for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
+	ax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {
 		if (ax25_uid->uid == uid) {
-			res = &ax25_uid->call;
+			ax25_uid_hold(ax25_uid);
+			res = ax25_uid;
 			break;
 		}
 	}
 	read_unlock(&ax25_uid_lock);
 
-	return NULL;
+	return res;
 }
 
 int ax25_uid_ioctl(int cmd, struct sockaddr_ax25 *sax)
 {
-	ax25_uid_assoc *s, *ax25_uid;
+	ax25_uid_assoc *ax25_uid;
+	struct hlist_node *node;
+	ax25_uid_assoc *user;
 	unsigned long res;
 
 	switch (cmd) {
 	case SIOCAX25GETUID:
 		res = -ENOENT;
 		read_lock(&ax25_uid_lock);
-		for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
+		ax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {
 			if (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0) {
 				res = ax25_uid->uid;
 				break;
@@ -85,19 +89,22 @@ int ax25_uid_ioctl(int cmd, struct socka
 	case SIOCAX25ADDUID:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
-		if (ax25_findbyuid(sax->sax25_uid))
+		user = ax25_findbyuid(sax->sax25_uid);
+		if (user) {
+			ax25_uid_put(user);
 			return -EEXIST;
+		}
 		if (sax->sax25_uid == 0)
 			return -EINVAL;
 		if ((ax25_uid = kmalloc(sizeof(*ax25_uid), GFP_KERNEL)) == NULL)
 			return -ENOMEM;
 
+		atomic_set(&ax25_uid->refcount, 1);
 		ax25_uid->uid  = sax->sax25_uid;
 		ax25_uid->call = sax->sax25_call;
 
 		write_lock(&ax25_uid_lock);
-		ax25_uid->next = ax25_uid_list;
-		ax25_uid_list  = ax25_uid;
+		hlist_add_head(&ax25_uid->uid_node, &ax25_uid_list);
 		write_unlock(&ax25_uid_lock);
 
 		return 0;
@@ -106,34 +113,21 @@ int ax25_uid_ioctl(int cmd, struct socka
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 
+		ax25_uid = NULL;
 		write_lock(&ax25_uid_lock);
-		for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
-			if (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0) {
+		ax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {
+			if (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0)
 				break;
-			}
 		}
 		if (ax25_uid == NULL) {
 			write_unlock(&ax25_uid_lock);
 			return -ENOENT;
 		}
-		if ((s = ax25_uid_list) == ax25_uid) {
-			ax25_uid_list = s->next;
-			write_unlock(&ax25_uid_lock);
-			kfree(ax25_uid);
-			return 0;
-		}
-		while (s != NULL && s->next != NULL) {
-			if (s->next == ax25_uid) {
-				s->next = ax25_uid->next;
-				write_unlock(&ax25_uid_lock);
-				kfree(ax25_uid);
-				return 0;
-			}
-			s = s->next;
-		}
+		hlist_del_init(&ax25_uid->uid_node);
+		ax25_uid_put(ax25_uid);
 		write_unlock(&ax25_uid_lock);
 
-		return -ENOENT;
+		return 0;
 
 	default:
 		return -EINVAL;
@@ -147,13 +141,11 @@ int ax25_uid_ioctl(int cmd, struct socka
 static void *ax25_uid_seq_start(struct seq_file *seq, loff_t *pos)
 {
 	struct ax25_uid_assoc *pt;
-	int i = 1;
+	struct hlist_node *node;
+	int i = 0;
 
 	read_lock(&ax25_uid_lock);
-	if (*pos == 0)
-		return SEQ_START_TOKEN;
-
-	for (pt = ax25_uid_list; pt != NULL; pt = pt->next) {
+	ax25_uid_for_each(pt, node, &ax25_uid_list) {
 		if (i == *pos)
 			return pt;
 		++i;
@@ -164,8 +156,9 @@ static void *ax25_uid_seq_start(struct s
 static void *ax25_uid_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 {
 	++*pos;
-	return (v == SEQ_START_TOKEN) ? ax25_uid_list : 
-		((struct ax25_uid_assoc *) v)->next;
+
+	return hlist_entry(((ax25_uid_assoc *)v)->uid_node.next,
+	                   ax25_uid_assoc, uid_node);
 }
 
 static void ax25_uid_seq_stop(struct seq_file *seq, void *v)
@@ -179,7 +172,6 @@ static int ax25_uid_seq_show(struct seq_
 		seq_printf(seq, "Policy: %d\n", ax25_uid_policy);
 	else {
 		struct ax25_uid_assoc *pt = v;
-		
 
 		seq_printf(seq, "%6d %s\n", pt->uid, ax2asc(&pt->call));
 	}
@@ -213,16 +205,13 @@ struct file_operations ax25_uid_fops = {
  */
 void __exit ax25_uid_free(void)
 {
-	ax25_uid_assoc *s, *ax25_uid;
+	ax25_uid_assoc *ax25_uid;
+	struct hlist_node *node;
 
 	write_lock(&ax25_uid_lock);
-	ax25_uid = ax25_uid_list;
-	while (ax25_uid != NULL) {
-		s        = ax25_uid;
-		ax25_uid = ax25_uid->next;
-
-		kfree(s);
+	ax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {
+		hlist_del_init(&ax25_uid->uid_node);
+		ax25_uid_put(ax25_uid);
 	}
-	ax25_uid_list = NULL;
 	write_unlock(&ax25_uid_lock);
 }
diff -purN linux-2.6.13-rc6-git13/net/ipv4/inetpeer.c linux-2.6.13-rc7/net/ipv4/inetpeer.c
--- linux-2.6.13-rc6-git13/net/ipv4/inetpeer.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ipv4/inetpeer.c	2005-08-24 05:39:14.000000000 +0200
@@ -450,10 +450,13 @@ static void peer_check_expire(unsigned l
 	/* Trigger the timer after inet_peer_gc_mintime .. inet_peer_gc_maxtime
 	 * interval depending on the total number of entries (more entries,
 	 * less interval). */
-	peer_periodic_timer.expires = jiffies
-		+ inet_peer_gc_maxtime
-		- (inet_peer_gc_maxtime - inet_peer_gc_mintime) / HZ *
-			peer_total / inet_peer_threshold * HZ;
+	if (peer_total >= inet_peer_threshold)
+		peer_periodic_timer.expires = jiffies + inet_peer_gc_mintime;
+	else
+		peer_periodic_timer.expires = jiffies
+			+ inet_peer_gc_maxtime
+			- (inet_peer_gc_maxtime - inet_peer_gc_mintime) / HZ *
+				peer_total / inet_peer_threshold * HZ;
 	add_timer(&peer_periodic_timer);
 }
 
diff -purN linux-2.6.13-rc6-git13/net/ipv4/netfilter/ip_queue.c linux-2.6.13-rc7/net/ipv4/netfilter/ip_queue.c
--- linux-2.6.13-rc6-git13/net/ipv4/netfilter/ip_queue.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ipv4/netfilter/ip_queue.c	2005-08-24 05:39:14.000000000 +0200
@@ -214,6 +214,12 @@ ipq_build_packet_message(struct ipq_queu
 		break;
 	
 	case IPQ_COPY_PACKET:
+		if (entry->skb->ip_summed == CHECKSUM_HW &&
+		    (*errp = skb_checksum_help(entry->skb,
+		                               entry->info->outdev == NULL))) {
+			read_unlock_bh(&queue_lock);
+			return NULL;
+		}
 		if (copy_range == 0 || copy_range > entry->skb->len)
 			data_len = entry->skb->len;
 		else
@@ -385,6 +391,7 @@ ipq_mangle_ipv4(ipq_verdict_msg_t *v, st
 	if (!skb_ip_make_writable(&e->skb, v->data_len))
 		return -ENOMEM;
 	memcpy(e->skb->data, v->payload, v->data_len);
+	e->skb->ip_summed = CHECKSUM_NONE;
 	e->skb->nfcache |= NFC_ALTERED;
 
 	/*
diff -purN linux-2.6.13-rc6-git13/net/ipv4/tcp.c linux-2.6.13-rc7/net/ipv4/tcp.c
--- linux-2.6.13-rc6-git13/net/ipv4/tcp.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ipv4/tcp.c	2005-08-24 05:39:14.000000000 +0200
@@ -584,7 +584,7 @@ static inline void skb_entail(struct soc
 	sk_charge_skb(sk, skb);
 	if (!sk->sk_send_head)
 		sk->sk_send_head = skb;
-	else if (tp->nonagle&TCP_NAGLE_PUSH)
+	if (tp->nonagle & TCP_NAGLE_PUSH)
 		tp->nonagle &= ~TCP_NAGLE_PUSH; 
 }
 
diff -purN linux-2.6.13-rc6-git13/net/ipv4/tcp_ipv4.c linux-2.6.13-rc7/net/ipv4/tcp_ipv4.c
--- linux-2.6.13-rc6-git13/net/ipv4/tcp_ipv4.c	2005-08-21 12:03:34.000000000 +0200
+++ linux-2.6.13-rc7/net/ipv4/tcp_ipv4.c	2005-08-24 05:39:14.000000000 +0200
@@ -242,9 +242,14 @@ static int tcp_v4_get_port(struct sock *
 		tcp_port_rover = rover;
 		spin_unlock(&tcp_portalloc_lock);
 
-		/* Exhausted local port range during search? */
+		/* Exhausted local port range during search?  It is not
+		 * possible for us to be holding one of the bind hash
+		 * locks if this test triggers, because if 'remaining'
+		 * drops to zero, we broke out of the do/while loop at
+		 * the top level, not from the 'break;' statement.
+		 */
 		ret = 1;
-		if (remaining <= 0)
+		if (unlikely(remaining <= 0))
 			goto fail;
 
 		/* OK, here is the one we will use.  HEAD is
diff -purN linux-2.6.13-rc6-git13/net/ipv4/tcp_output.c linux-2.6.13-rc7/net/ipv4/tcp_output.c
--- linux-2.6.13-rc6-git13/net/ipv4/tcp_output.c	2005-08-21 12:03:34.000000000 +0200
+++ linux-2.6.13-rc7/net/ipv4/tcp_output.c	2005-08-24 05:39:14.000000000 +0200
@@ -925,10 +925,6 @@ static int tcp_tso_should_defer(struct s
 
 	limit = min(send_win, cong_win);
 
-	/* If sk_send_head can be sent fully now, just do it.  */
-	if (skb->len <= limit)
-		return 0;
-
 	if (sysctl_tcp_tso_win_divisor) {
 		u32 chunk = min(tp->snd_wnd, tp->snd_cwnd * tp->mss_cache);
 
diff -purN linux-2.6.13-rc6-git13/net/ipv6/netfilter/ip6_queue.c linux-2.6.13-rc7/net/ipv6/netfilter/ip6_queue.c
--- linux-2.6.13-rc6-git13/net/ipv6/netfilter/ip6_queue.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ipv6/netfilter/ip6_queue.c	2005-08-24 05:39:14.000000000 +0200
@@ -211,6 +211,12 @@ ipq_build_packet_message(struct ipq_queu
 		break;
 	
 	case IPQ_COPY_PACKET:
+		if (entry->skb->ip_summed == CHECKSUM_HW &&
+		    (*errp = skb_checksum_help(entry->skb,
+		                               entry->info->outdev == NULL))) {
+			read_unlock_bh(&queue_lock);
+			return NULL;
+		}
 		if (copy_range == 0 || copy_range > entry->skb->len)
 			data_len = entry->skb->len;
 		else
@@ -381,6 +387,7 @@ ipq_mangle_ipv6(ipq_verdict_msg_t *v, st
 	if (!skb_ip_make_writable(&e->skb, v->data_len))
 		return -ENOMEM;
 	memcpy(e->skb->data, v->payload, v->data_len);
+	e->skb->ip_summed = CHECKSUM_NONE;
 	e->skb->nfcache |= NFC_ALTERED;
 
 	/*
diff -purN linux-2.6.13-rc6-git13/net/ipv6/tcp_ipv6.c linux-2.6.13-rc7/net/ipv6/tcp_ipv6.c
--- linux-2.6.13-rc6-git13/net/ipv6/tcp_ipv6.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/ipv6/tcp_ipv6.c	2005-08-24 05:39:14.000000000 +0200
@@ -158,9 +158,14 @@ static int tcp_v6_get_port(struct sock *
 		tcp_port_rover = rover;
 		spin_unlock(&tcp_portalloc_lock);
 
-		/* Exhausted local port range during search? */
+		/* Exhausted local port range during search?  It is not
+		 * possible for us to be holding one of the bind hash
+		 * locks if this test triggers, because if 'remaining'
+		 * drops to zero, we broke out of the do/while loop at
+		 * the top level, not from the 'break;' statement.
+		 */
 		ret = 1;
-		if (remaining <= 0)
+		if (unlikely(remaining <= 0))
 			goto fail;
 
 		/* OK, here is the one we will use. */
diff -purN linux-2.6.13-rc6-git13/net/netrom/af_netrom.c linux-2.6.13-rc7/net/netrom/af_netrom.c
--- linux-2.6.13-rc6-git13/net/netrom/af_netrom.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/netrom/af_netrom.c	2005-08-24 05:39:14.000000000 +0200
@@ -459,12 +459,7 @@ static struct sock *nr_make_new(struct s
 	sk->sk_sndbuf   = osk->sk_sndbuf;
 	sk->sk_state    = TCP_ESTABLISHED;
 	sk->sk_sleep    = osk->sk_sleep;
-
-	if (sock_flag(osk, SOCK_ZAPPED))
-		sock_set_flag(sk, SOCK_ZAPPED);
-
-	if (sock_flag(osk, SOCK_DBG))
-		sock_set_flag(sk, SOCK_DBG);
+	sock_copy_flags(sk, osk);
 
 	skb_queue_head_init(&nr->ack_queue);
 	skb_queue_head_init(&nr->reseq_queue);
@@ -541,7 +536,8 @@ static int nr_bind(struct socket *sock, 
 	struct nr_sock *nr = nr_sk(sk);
 	struct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;
 	struct net_device *dev;
-	ax25_address *user, *source;
+	ax25_uid_assoc *user;
+	ax25_address *source;
 
 	lock_sock(sk);
 	if (!sock_flag(sk, SOCK_ZAPPED)) {
@@ -580,16 +576,19 @@ static int nr_bind(struct socket *sock, 
 	} else {
 		source = &addr->fsa_ax25.sax25_call;
 
-		if ((user = ax25_findbyuid(current->euid)) == NULL) {
+		user = ax25_findbyuid(current->euid);
+		if (user) {
+			nr->user_addr   = user->call;
+			ax25_uid_put(user);
+		} else {
 			if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {
 				release_sock(sk);
 				dev_put(dev);
 				return -EPERM;
 			}
-			user = source;
+			nr->user_addr   = *source;
 		}
 
-		nr->user_addr   = *user;
 		nr->source_addr = *source;
 	}
 
@@ -609,7 +608,8 @@ static int nr_connect(struct socket *soc
 	struct sock *sk = sock->sk;
 	struct nr_sock *nr = nr_sk(sk);
 	struct sockaddr_ax25 *addr = (struct sockaddr_ax25 *)uaddr;
-	ax25_address *user, *source = NULL;
+	ax25_address *source = NULL;
+	ax25_uid_assoc *user;
 	struct net_device *dev;
 
 	lock_sock(sk);
@@ -650,16 +650,19 @@ static int nr_connect(struct socket *soc
 		}
 		source = (ax25_address *)dev->dev_addr;
 
-		if ((user = ax25_findbyuid(current->euid)) == NULL) {
+		user = ax25_findbyuid(current->euid);
+		if (user) {
+			nr->user_addr   = user->call;
+			ax25_uid_put(user);
+		} else {
 			if (ax25_uid_policy && !capable(CAP_NET_ADMIN)) {
 				dev_put(dev);
 				release_sock(sk);
 				return -EPERM;
 			}
-			user = source;
+			nr->user_addr   = *source;
 		}
 
-		nr->user_addr   = *user;
 		nr->source_addr = *source;
 		nr->device      = dev;
 
diff -purN linux-2.6.13-rc6-git13/net/rose/af_rose.c linux-2.6.13-rc7/net/rose/af_rose.c
--- linux-2.6.13-rc6-git13/net/rose/af_rose.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/rose/af_rose.c	2005-08-24 05:39:14.000000000 +0200
@@ -556,12 +556,7 @@ static struct sock *rose_make_new(struct
 	sk->sk_sndbuf   = osk->sk_sndbuf;
 	sk->sk_state    = TCP_ESTABLISHED;
 	sk->sk_sleep    = osk->sk_sleep;
-
-	if (sock_flag(osk, SOCK_ZAPPED))
-		sock_set_flag(sk, SOCK_ZAPPED);
-
-	if (sock_flag(osk, SOCK_DBG))
-		sock_set_flag(sk, SOCK_DBG);
+	sock_copy_flags(sk, osk);
 
 	init_timer(&rose->timer);
 	init_timer(&rose->idletimer);
@@ -631,7 +626,8 @@ static int rose_bind(struct socket *sock
 	struct rose_sock *rose = rose_sk(sk);
 	struct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;
 	struct net_device *dev;
-	ax25_address *user, *source;
+	ax25_address *source;
+	ax25_uid_assoc *user;
 	int n;
 
 	if (!sock_flag(sk, SOCK_ZAPPED))
@@ -656,14 +652,17 @@ static int rose_bind(struct socket *sock
 
 	source = &addr->srose_call;
 
-	if ((user = ax25_findbyuid(current->euid)) == NULL) {
+	user = ax25_findbyuid(current->euid);
+	if (user) {
+		rose->source_call = user->call;
+		ax25_uid_put(user);
+	} else {
 		if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))
 			return -EACCES;
-		user = source;
+		rose->source_call   = *source;
 	}
 
 	rose->source_addr   = addr->srose_addr;
-	rose->source_call   = *user;
 	rose->device        = dev;
 	rose->source_ndigis = addr->srose_ndigis;
 
@@ -690,8 +689,8 @@ static int rose_connect(struct socket *s
 	struct rose_sock *rose = rose_sk(sk);
 	struct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;
 	unsigned char cause, diagnostic;
-	ax25_address *user;
 	struct net_device *dev;
+	ax25_uid_assoc *user;
 	int n;
 
 	if (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {
@@ -741,12 +740,14 @@ static int rose_connect(struct socket *s
 		if ((dev = rose_dev_first()) == NULL)
 			return -ENETUNREACH;
 
-		if ((user = ax25_findbyuid(current->euid)) == NULL)
+		user = ax25_findbyuid(current->euid);
+		if (!user)
 			return -EINVAL;
 
 		memcpy(&rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);
-		rose->source_call = *user;
+		rose->source_call = user->call;
 		rose->device      = dev;
+		ax25_uid_put(user);
 
 		rose_insert_socket(sk);		/* Finish the bind */
 	}
diff -purN linux-2.6.13-rc6-git13/net/rose/rose_route.c linux-2.6.13-rc7/net/rose/rose_route.c
--- linux-2.6.13-rc6-git13/net/rose/rose_route.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/rose/rose_route.c	2005-08-24 05:39:14.000000000 +0200
@@ -994,8 +994,10 @@ int rose_route_frame(struct sk_buff *skb
 	 *	1. The frame isn't for us,
 	 *	2. It isn't "owned" by any existing route.
 	 */
-	if (frametype != ROSE_CALL_REQUEST)	/* XXX */
-		return 0;
+	if (frametype != ROSE_CALL_REQUEST) {	/* XXX */
+		res = 0;
+		goto out;
+	}
 
 	len  = (((skb->data[3] >> 4) & 0x0F) + 1) / 2;
 	len += (((skb->data[3] >> 0) & 0x0F) + 1) / 2;
diff -purN linux-2.6.13-rc6-git13/net/sched/sch_generic.c linux-2.6.13-rc7/net/sched/sch_generic.c
--- linux-2.6.13-rc6-git13/net/sched/sch_generic.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/sched/sch_generic.c	2005-08-24 05:39:14.000000000 +0200
@@ -438,6 +438,7 @@ struct Qdisc * qdisc_create_dflt(struct 
 	if (!ops->init || ops->init(sch, NULL) == 0)
 		return sch;
 
+	qdisc_destroy(sch);
 errout:
 	return NULL;
 }
diff -purN linux-2.6.13-rc6-git13/net/sctp/proc.c linux-2.6.13-rc7/net/sctp/proc.c
--- linux-2.6.13-rc6-git13/net/sctp/proc.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/sctp/proc.c	2005-08-24 05:39:14.000000000 +0200
@@ -57,6 +57,7 @@ static struct snmp_mib sctp_snmp_list[] 
 	SNMP_MIB_ITEM("SctpReasmUsrMsgs", SCTP_MIB_REASMUSRMSGS),
 	SNMP_MIB_ITEM("SctpOutSCTPPacks", SCTP_MIB_OUTSCTPPACKS),
 	SNMP_MIB_ITEM("SctpInSCTPPacks", SCTP_MIB_INSCTPPACKS),
+	SNMP_MIB_SENTINEL
 };
 
 /* Return the current value of a particular entry in the mib by adding its
diff -purN linux-2.6.13-rc6-git13/net/sunrpc/auth_gss/gss_krb5_crypto.c linux-2.6.13-rc7/net/sunrpc/auth_gss/gss_krb5_crypto.c
--- linux-2.6.13-rc6-git13/net/sunrpc/auth_gss/gss_krb5_crypto.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/net/sunrpc/auth_gss/gss_krb5_crypto.c	2005-08-24 05:39:14.000000000 +0200
@@ -185,9 +185,7 @@ make_checksum(s32 cksumtype, char *heade
 			sg->page = body->pages[i];
 			sg->offset = offset;
 			sg->length = thislen;
-			kmap(sg->page); /* XXX kmap_atomic? */
 			crypto_digest_update(tfm, sg, 1);
-			kunmap(sg->page);
 			len -= thislen;
 			i++;
 			offset = 0;
diff -purN linux-2.6.13-rc6-git13/sound/Kconfig linux-2.6.13-rc7/sound/Kconfig
--- linux-2.6.13-rc6-git13/sound/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -77,7 +77,7 @@ source "sound/parisc/Kconfig"
 endmenu
 
 menu "Open Sound System"
-	depends on SOUND!=n && (BROKEN || (!SPARC32 && !SPARC64))
+	depends on SOUND!=n
 
 config SOUND_PRIME
 	tristate "Open Sound System (DEPRECATED)"
diff -purN linux-2.6.13-rc6-git13/sound/core/Makefile linux-2.6.13-rc7/sound/core/Makefile
--- linux-2.6.13-rc6-git13/sound/core/Makefile	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/core/Makefile	2005-08-24 05:39:14.000000000 +0200
@@ -5,7 +5,7 @@
 
 snd-objs     := sound.o init.o memory.o info.o control.o misc.o \
                 device.o wrappers.o
-ifeq ($(CONFIG_ISA),y)
+ifeq ($(CONFIG_ISA_DMA_API),y)
 snd-objs     += isadma.o
 endif
 ifeq ($(CONFIG_SND_OSSEMUL),y)
diff -purN linux-2.6.13-rc6-git13/sound/core/sound.c linux-2.6.13-rc7/sound/core/sound.c
--- linux-2.6.13-rc6-git13/sound/core/sound.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/core/sound.c	2005-08-24 05:39:14.000000000 +0200
@@ -432,7 +432,7 @@ EXPORT_SYMBOL(snd_device_new);
 EXPORT_SYMBOL(snd_device_register);
 EXPORT_SYMBOL(snd_device_free);
   /* isadma.c */
-#ifdef CONFIG_ISA
+#ifdef CONFIG_ISA_DMA_API
 EXPORT_SYMBOL(snd_dma_program);
 EXPORT_SYMBOL(snd_dma_disable);
 EXPORT_SYMBOL(snd_dma_pointer);
diff -purN linux-2.6.13-rc6-git13/sound/isa/Kconfig linux-2.6.13-rc7/sound/isa/Kconfig
--- linux-2.6.13-rc6-git13/sound/isa/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/isa/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -1,7 +1,7 @@
 # ALSA ISA drivers
 
 menu "ISA devices"
-	depends on SND!=n && ISA
+	depends on SND!=n && ISA && ISA_DMA_API
 
 config SND_AD1848_LIB
         tristate
diff -purN linux-2.6.13-rc6-git13/sound/oss/Kconfig linux-2.6.13-rc7/sound/oss/Kconfig
--- linux-2.6.13-rc6-git13/sound/oss/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/oss/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -6,7 +6,7 @@
 # Prompt user for primary drivers.
 config SOUND_BT878
 	tristate "BT878 audio dma"
-	depends on SOUND_PRIME
+	depends on SOUND_PRIME && PCI
 	---help---
 	  Audio DMA support for bt878 based grabber boards.  As you might have
 	  already noticed, bt878 is listed with two functions in /proc/pci.
@@ -80,14 +80,14 @@ config SOUND_EMU10K1
 
 config MIDI_EMU10K1
 	bool "Creative SBLive! MIDI (EXPERIMENTAL)"
-	depends on SOUND_EMU10K1 && EXPERIMENTAL
+	depends on SOUND_EMU10K1 && EXPERIMENTAL && ISA_DMA_API
 	help
 	  Say Y if you want to be able to use the OSS /dev/sequencer
 	  interface.  This code is still experimental.
 
 config SOUND_FUSION
 	tristate "Crystal SoundFusion (CS4280/461x)"
-	depends on SOUND_PRIME
+	depends on SOUND_PRIME && PCI
 	help
 	  This module drives the Crystal SoundFusion devices (CS4280/46xx
 	  series) when wired as native sound drivers with AC97 codecs.  If
@@ -95,7 +95,7 @@ config SOUND_FUSION
 
 config SOUND_CS4281
 	tristate "Crystal Sound CS4281"
-	depends on SOUND_PRIME
+	depends on SOUND_PRIME && PCI
 	help
 	  Picture and feature list at
 	  <http://www.pcbroker.com/crystal4281.html>.
@@ -179,7 +179,7 @@ config SOUND_HARMONY
 
 config SOUND_SONICVIBES
 	tristate "S3 SonicVibes"
-	depends on SOUND_PRIME
+	depends on SOUND_PRIME && PCI
 	help
 	  Say Y or M if you have a PCI sound card utilizing the S3
 	  SonicVibes chipset. To find out if your sound card uses a
@@ -226,7 +226,7 @@ config SOUND_AU1550_AC97
 
 config SOUND_TRIDENT
 	tristate "Trident 4DWave DX/NX, SiS 7018 or ALi 5451 PCI Audio Core"
-	depends on SOUND_PRIME
+	depends on SOUND_PRIME && PCI
 	---help---
 	  Say Y or M if you have a PCI sound card utilizing the Trident
 	  4DWave-DX/NX chipset or your mother board chipset has SiS 7018
@@ -503,7 +503,7 @@ config SOUND_VIA82CXXX
 
 config MIDI_VIA82CXXX
 	bool "VIA 82C686 MIDI"
-	depends on SOUND_VIA82CXXX
+	depends on SOUND_VIA82CXXX && ISA_DMA_API
 	help
 	  Answer Y to use the MIDI interface of the Via686. You may need to
 	  enable this in the BIOS before it will work. This is for connection
@@ -512,7 +512,7 @@ config MIDI_VIA82CXXX
 
 config SOUND_OSS
 	tristate "OSS sound modules"
-	depends on SOUND_PRIME
+	depends on SOUND_PRIME && ISA_DMA_API
 	help
 	  OSS is the Open Sound System suite of sound card drivers.  They make
 	  sound programming easier since they provide a common API.  Say Y or
diff -purN linux-2.6.13-rc6-git13/sound/oss/Makefile linux-2.6.13-rc7/sound/oss/Makefile
--- linux-2.6.13-rc6-git13/sound/oss/Makefile	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/oss/Makefile	2005-08-24 05:39:14.000000000 +0200
@@ -80,7 +80,7 @@ obj-$(CONFIG_SOUND_ALI5455)	+= ali5455.o
 obj-$(CONFIG_SOUND_IT8172)	+= ite8172.o ac97_codec.o
 obj-$(CONFIG_SOUND_FORTE)	+= forte.o ac97_codec.o
 
-obj-$(CONFIG_SOUND_AD1980)	+= ac97_plugin_ad1980.o
+obj-$(CONFIG_SOUND_AD1980)	+= ac97_plugin_ad1980.o ac97_codec.o
 obj-$(CONFIG_SOUND_WM97XX)	+= ac97_plugin_wm97xx.o
 
 ifeq ($(CONFIG_MIDI_EMU10K1),y)
diff -purN linux-2.6.13-rc6-git13/sound/oss/i810_audio.c linux-2.6.13-rc7/sound/oss/i810_audio.c
--- linux-2.6.13-rc6-git13/sound/oss/i810_audio.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/oss/i810_audio.c	2005-08-24 05:39:14.000000000 +0200
@@ -3430,9 +3430,9 @@ out_iospace:
 		release_mem_region(card->iobase_mmio_phys, 256);
 	}
 out_pio:	
-	release_region(card->iobase, 64);
-out_region2:
 	release_region(card->ac97base, 256);
+out_region2:
+	release_region(card->iobase, 64);
 out_region1:
 	pci_free_consistent(pci_dev, sizeof(struct i810_channel)*NR_HW_CH,
 	    card->channel, card->chandma);
diff -purN linux-2.6.13-rc6-git13/sound/oss/vidc.h linux-2.6.13-rc7/sound/oss/vidc.h
--- linux-2.6.13-rc6-git13/sound/oss/vidc.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/oss/vidc.h	2005-08-24 05:39:14.000000000 +0200
@@ -10,10 +10,6 @@
  *  VIDC sound function prototypes
  */
 
-/* vidc.c */
-
-extern int vidc_busy;
-
 /* vidc_fill.S */
 
 /*
diff -purN linux-2.6.13-rc6-git13/sound/pci/Kconfig linux-2.6.13-rc7/sound/pci/Kconfig
--- linux-2.6.13-rc6-git13/sound/pci/Kconfig	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc7/sound/pci/Kconfig	2005-08-24 05:39:14.000000000 +0200
@@ -314,7 +314,7 @@ config SND_YMFPCI
 
 config SND_ALS4000
 	tristate "Avance Logic ALS4000"
-	depends on SND
+	depends on SND && ISA_DMA_API
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_PCM
