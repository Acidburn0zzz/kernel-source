This patch fixes possible quota files corruption which could happen when
root did not have any inodes&space allocated.

Index: linux-2.6.5/fs/dquot.c
===================================================================
--- linux-2.6.5.orig/fs/dquot.c
+++ linux-2.6.5/fs/dquot.c
@@ -1071,8 +1071,11 @@ int dquot_transfer(struct inode *inode, 
 		if (transfer_to[cnt] == NODQUOT)
 			continue;
 
-		dquot_decr_inodes(transfer_from[cnt], 1);
-		dquot_decr_space(transfer_from[cnt], space);
+		/* Due to IO error we might not have transfer_from[] structure */
+		if (transfer_from[cnt] != NODQUOT) {
+			dquot_decr_inodes(transfer_from[cnt], 1);
+			dquot_decr_space(transfer_from[cnt], space);
+		}
 
 		dquot_incr_inodes(transfer_to[cnt], 1);
 		dquot_incr_space(transfer_to[cnt], space);
Index: linux-2.6.5/fs/quota_v2.c
===================================================================
--- linux-2.6.5.orig/fs/quota_v2.c
+++ linux-2.6.5/fs/quota_v2.c
@@ -415,7 +415,7 @@ static int v2_write_dquot(struct dquot *
 	mm_segment_t fs;
 	loff_t offset;
 	ssize_t ret;
-	struct v2_disk_dqblk ddquot;
+	struct v2_disk_dqblk ddquot, empty;
 
 	if (!dquot->dq_off)
 		if ((ret = dq_insert_tree(dquot)) < 0) {
@@ -425,6 +425,12 @@ static int v2_write_dquot(struct dquot *
 	filp = sb_dqopt(dquot->dq_sb)->files[type];
 	offset = dquot->dq_off;
 	mem2diskdqb(&ddquot, &dquot->dq_dqb, dquot->dq_id);
+	/* Argh... We may need to write structure full of zeroes but that would be
+	 * treated as an empty place by the rest of the code. Format change would
+	 * be definitely cleaner but the problems probably are not worth it */
+	memset(&empty, 0, sizeof(struct v2_disk_dqblk));
+	if (!memcmp(&empty, &ddquot, sizeof(struct v2_disk_dqblk)))
+		ddquot.dqb_itime = cpu_to_le64(1);
 	fs = get_fs();
 	set_fs(KERNEL_DS);
 	ret = filp->f_op->write(filp, (char *)&ddquot, sizeof(struct v2_disk_dqblk), &offset);
@@ -616,7 +622,7 @@ static int v2_read_dquot(struct dquot *d
 	struct file *filp;
 	mm_segment_t fs;
 	loff_t offset;
-	struct v2_disk_dqblk ddquot;
+	struct v2_disk_dqblk ddquot, empty;
 	int ret = 0;
 
 	filp = sb_dqopt(dquot->dq_sb)->files[type];
@@ -646,8 +652,14 @@ static int v2_read_dquot(struct dquot *d
 			printk(KERN_ERR "VFS: Error while reading quota structure for id %u.\n", dquot->dq_id);
 			memset(&ddquot, 0, sizeof(struct v2_disk_dqblk));
 		}
-		else
+		else {
 			ret = 0;
+			/* We need to escape back all-zero structure */
+			memset(&empty, 0, sizeof(struct v2_disk_dqblk));
+			empty.dqb_itime = cpu_to_le64(1);
+			if (!memcmp(&empty, &ddquot, sizeof(struct v2_disk_dqblk)))
+				ddquot.dqb_itime = 0;
+		}
 		set_fs(fs);
 		disk2memdqb(&dquot->dq_dqb, &ddquot);
 	}
Index: linux-2.6.5/include/linux/quotaio_v2.h
===================================================================
--- linux-2.6.5.orig/include/linux/quotaio_v2.h
+++ linux-2.6.5/include/linux/quotaio_v2.h
@@ -59,7 +59,7 @@ struct v2_disk_dqinfo {
 
 /*
  *  Structure of header of block with quota structures. It is padded to 16 bytes so
- *  there will be space for exactly 18 quota-entries in a block
+ *  there will be space for exactly 21 quota-entries in a block
  */
 struct v2_disk_dqdbheader {
 	__u32 dqdh_next_free;	/* Number of next block with free entry */
