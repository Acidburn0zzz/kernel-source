diff -purNa linux-2.6.3/fs/nfs/nfs4proc.c linux-2.6.3-sunrpc/fs/nfs/nfs4proc.c
--- linux-2.6.3/fs/nfs/nfs4proc.c	2004-02-19 11:36:36.000000000 +0100
+++ linux-2.6.3-sunrpc/fs/nfs/nfs4proc.c	2004-02-19 11:53:03.000000000 +0100
@@ -1856,7 +1856,7 @@ nfs4_async_handle_error(struct rpc_task 
 		case -NFS4ERR_STALE_CLIENTID:
 		case -NFS4ERR_STALE_STATEID:
 		case -NFS4ERR_EXPIRED:
-			rpc_sleep_on(&clp->cl_rpcwaitq, task, NULL, NULL);
+			rpc_sleep_on(&clp->cl_rpcwaitq, task, NULL, NULL, 0);
 			nfs4_schedule_state_recovery(clp);
 			task->tk_status = 0;
 			return -EAGAIN;
diff -purNa linux-2.6.3/fs/nfs/unlink.c linux-2.6.3-sunrpc/fs/nfs/unlink.c
--- linux-2.6.3/fs/nfs/unlink.c	2004-02-04 04:44:44.000000000 +0100
+++ linux-2.6.3-sunrpc/fs/nfs/unlink.c	2004-02-19 11:53:11.000000000 +0100
@@ -182,7 +182,7 @@ nfs_async_unlink(struct dentry *dentry)
 	dentry->d_flags |= DCACHE_NFSFS_RENAMED;
 	data->cred = rpcauth_lookupcred(clnt->cl_auth, 0);
 
-	rpc_sleep_on(&nfs_delete_queue, task, NULL, NULL);
+	rpc_sleep_on(&nfs_delete_queue, task, NULL, NULL, 0);
 	status = 0;
  out:
 	return status;
diff -purNa linux-2.6.3/include/linux/sunrpc/clnt.h linux-2.6.3-sunrpc/include/linux/sunrpc/clnt.h
--- linux-2.6.3/include/linux/sunrpc/clnt.h	2004-02-19 11:36:36.000000000 +0100
+++ linux-2.6.3-sunrpc/include/linux/sunrpc/clnt.h	2004-02-19 11:49:44.000000000 +0100
@@ -116,7 +116,7 @@ struct rpc_clnt *rpc_clone_client(struct
 int		rpc_shutdown_client(struct rpc_clnt *);
 int		rpc_destroy_client(struct rpc_clnt *);
 void		rpc_release_client(struct rpc_clnt *);
-void		rpc_getport(struct rpc_task *, struct rpc_clnt *);
+void		rpc_getport(struct rpc_task *, struct rpc_clnt *, unsigned long);
 int		rpc_register(u32, u32, int, unsigned short, int *);
 
 void		rpc_call_setup(struct rpc_task *, struct rpc_message *, int);
diff -purNa linux-2.6.3/include/linux/sunrpc/sched.h linux-2.6.3-sunrpc/include/linux/sunrpc/sched.h
--- linux-2.6.3/include/linux/sunrpc/sched.h	2004-02-19 11:36:36.000000000 +0100
+++ linux-2.6.3-sunrpc/include/linux/sunrpc/sched.h	2004-02-19 11:46:48.000000000 +0100
@@ -176,7 +176,8 @@ void		rpc_run_child(struct rpc_task *par
 int		rpc_add_wait_queue(struct rpc_wait_queue *, struct rpc_task *);
 void		rpc_remove_wait_queue(struct rpc_task *);
 void		rpc_sleep_on(struct rpc_wait_queue *, struct rpc_task *,
-					rpc_action action, rpc_action timer);
+					rpc_action action, rpc_action timer,
+					unsigned long timeout);
 void		rpc_add_timer(struct rpc_task *, rpc_action);
 void		rpc_wake_up_task(struct rpc_task *);
 void		rpc_wake_up(struct rpc_wait_queue *);
diff -purNa linux-2.6.3/net/sunrpc/clnt.c linux-2.6.3-sunrpc/net/sunrpc/clnt.c
--- linux-2.6.3/net/sunrpc/clnt.c	2004-02-19 11:40:49.000000000 +0100
+++ linux-2.6.3-sunrpc/net/sunrpc/clnt.c	2004-02-19 11:49:13.000000000 +0100
@@ -642,8 +642,7 @@ call_bind(struct rpc_task *task)
 
 	if (!clnt->cl_port) {
 		task->tk_action = call_connect;
-		task->tk_timeout = RPC_CONNECT_TIMEOUT;
-		rpc_getport(task, clnt);
+		rpc_getport(task, clnt, RPC_CONNECT_TIMEOUT);
 	}
 }
 
diff -purNa linux-2.6.3/net/sunrpc/pmap_clnt.c linux-2.6.3-sunrpc/net/sunrpc/pmap_clnt.c
--- linux-2.6.3/net/sunrpc/pmap_clnt.c	2004-02-19 11:36:37.000000000 +0100
+++ linux-2.6.3-sunrpc/net/sunrpc/pmap_clnt.c	2004-02-19 11:49:56.000000000 +0100
@@ -39,7 +39,7 @@ static spinlock_t		pmap_lock = SPIN_LOCK
  * be called for an ongoing RPC request.
  */
 void
-rpc_getport(struct rpc_task *task, struct rpc_clnt *clnt)
+rpc_getport(struct rpc_task *task, struct rpc_clnt *clnt, unsigned long timeout)
 {
 	struct rpc_portmap *map = clnt->cl_pmap;
 	struct sockaddr_in *sap = &clnt->cl_xprt->addr;
@@ -58,7 +58,7 @@ rpc_getport(struct rpc_task *task, struc
 
 	spin_lock(&pmap_lock);
 	if (map->pm_binding) {
-		rpc_sleep_on(&map->pm_bindwait, task, NULL, 0);
+		rpc_sleep_on(&map->pm_bindwait, task, NULL, 0, timeout);
 		spin_unlock(&pmap_lock);
 		return;
 	}
diff -purNa linux-2.6.3/net/sunrpc/sched.c linux-2.6.3-sunrpc/net/sunrpc/sched.c
--- linux-2.6.3/net/sunrpc/sched.c	2004-02-19 11:40:49.000000000 +0100
+++ linux-2.6.3-sunrpc/net/sunrpc/sched.c	2004-02-19 11:47:41.000000000 +0100
@@ -336,12 +336,14 @@ __rpc_sleep_on(struct rpc_wait_queue *q,
 
 void
 rpc_sleep_on(struct rpc_wait_queue *q, struct rpc_task *task,
-				rpc_action action, rpc_action timer)
+				rpc_action action, rpc_action timer,
+				unsigned long timeout)
 {
 	/*
 	 * Protect the queue operations.
 	 */
 	spin_lock_bh(&rpc_queue_lock);
+	task->tk_timeout = timeout;
 	__rpc_sleep_on(q, task, action, timer);
 	spin_unlock_bh(&rpc_queue_lock);
 }
@@ -471,8 +473,7 @@ static void	__rpc_atrun(struct rpc_task 
 void
 rpc_delay(struct rpc_task *task, unsigned long delay)
 {
-	task->tk_timeout = delay;
-	rpc_sleep_on(&delay_queue, task, NULL, __rpc_atrun);
+	rpc_sleep_on(&delay_queue, task, NULL, __rpc_atrun, delay);
 }
 
 static void
diff -purNa linux-2.6.3/net/sunrpc/xprt.c linux-2.6.3-sunrpc/net/sunrpc/xprt.c
--- linux-2.6.3/net/sunrpc/xprt.c	2004-02-19 11:40:49.000000000 +0100
+++ linux-2.6.3-sunrpc/net/sunrpc/xprt.c	2004-02-19 11:52:14.000000000 +0100
@@ -161,12 +161,11 @@ __xprt_lock_write(struct rpc_xprt *xprt,
 	smp_mb__after_clear_bit();
 out_sleep:
 	dprintk("RPC: %4d failed to lock socket %p\n", task->tk_pid, xprt);
-	task->tk_timeout = 0;
 	task->tk_status = -EAGAIN;
 	if (req && req->rq_ntrans)
-		rpc_sleep_on(&xprt->resend, task, NULL, NULL);
+		rpc_sleep_on(&xprt->resend, task, NULL, NULL, 0);
 	else
-		rpc_sleep_on(&xprt->sending, task, NULL, NULL);
+		rpc_sleep_on(&xprt->sending, task, NULL, NULL, 0);
 	return 0;
 }
 
@@ -522,15 +521,18 @@ xprt_connect(struct rpc_task *task)
 		/* Protect against TCP socket state changes */
 		lock_sock(inet);
 		if (inet->sk_state != TCP_ESTABLISHED) {
+			unsigned long	timeout;
+
 			dprintk("RPC: %4d  waiting for connection\n",
 					task->tk_pid);
-			task->tk_timeout = RPC_CONNECT_TIMEOUT;
+			timeout = RPC_CONNECT_TIMEOUT;
 			/* if the socket is already closing, delay briefly */
 			if ((1 << inet->sk_state) &
 			    ~(TCPF_SYN_SENT | TCPF_SYN_RECV))
-				task->tk_timeout = RPC_REESTABLISH_TIMEOUT;
-			rpc_sleep_on(&xprt->pending, task, xprt_connect_status,
-									NULL);
+				timeout = RPC_REESTABLISH_TIMEOUT;
+			rpc_sleep_on(&xprt->pending, task,
+					xprt_connect_status, NULL,
+					timeout);
 		}
 		release_sock(inet);
 		break;
@@ -1169,6 +1171,7 @@ xprt_transmit(struct rpc_task *task)
 	struct rpc_clnt *clnt = task->tk_client;
 	struct rpc_rqst	*req = task->tk_rqstp;
 	struct rpc_xprt	*xprt = req->rq_xprt;
+	unsigned long timeout;
 	int status, retry = 0;
 
 
@@ -1247,8 +1250,8 @@ xprt_transmit(struct rpc_task *task)
 			if (!xprt_connected(xprt))
 				task->tk_status = -ENOTCONN;
 			else if (test_bit(SOCK_NOSPACE, &xprt->sock->flags)) {
-				task->tk_timeout = req->rq_timeout.to_current;
-				rpc_sleep_on(&xprt->pending, task, NULL, NULL);
+				rpc_sleep_on(&xprt->pending, task, NULL, NULL,
+						req->rq_timeout.to_current);
 			}
 			spin_unlock_bh(&xprt->sock_lock);
 			return;
@@ -1257,8 +1260,8 @@ xprt_transmit(struct rpc_task *task)
 		rpc_delay(task, HZ>>4);
 		return;
 	case -ECONNREFUSED:
-		task->tk_timeout = RPC_REESTABLISH_TIMEOUT;
-		rpc_sleep_on(&xprt->sending, task, NULL, NULL);
+		rpc_sleep_on(&xprt->sending, task,
+				NULL, NULL, RPC_REESTABLISH_TIMEOUT);
 	case -ENOTCONN:
 		return;
 	default:
@@ -1273,19 +1276,23 @@ xprt_transmit(struct rpc_task *task)
 	spin_lock_bh(&xprt->sock_lock);
 	if (!xprt->nocong) {
 		int timer = task->tk_msg.rpc_proc->p_timer;
-		task->tk_timeout = rpc_calc_rto(clnt->cl_rtt, timer);
-		task->tk_timeout <<= rpc_ntimeo(clnt->cl_rtt, timer);
-		task->tk_timeout <<= clnt->cl_timeout.to_retries
+		timeout = rpc_calc_rto(clnt->cl_rtt, timer);
+		timeout <<= rpc_ntimeo(clnt->cl_rtt, timer);
+		timeout <<= clnt->cl_timeout.to_retries
 			- req->rq_timeout.to_retries;
-		if (task->tk_timeout > req->rq_timeout.to_maxval)
-			task->tk_timeout = req->rq_timeout.to_maxval;
+		if (timeout > req->rq_timeout.to_maxval)
+			timeout = req->rq_timeout.to_maxval;
+		else if (timeout == 0) {
+			printk(KERN_ERR "RPC task timeout == 0, please tell okir\n");
+			timeout = req->rq_timeout.to_maxval;
+		}
 	} else
-		task->tk_timeout = req->rq_timeout.to_current;
+		timeout = req->rq_timeout.to_current;
 	/* Don't race with disconnect */
 	if (!xprt_connected(xprt))
 		task->tk_status = -ENOTCONN;
 	else if (!req->rq_received)
-		rpc_sleep_on(&xprt->pending, task, NULL, xprt_timer);
+		rpc_sleep_on(&xprt->pending, task, NULL, xprt_timer, timeout);
 	__xprt_release_write(xprt, task);
 	spin_unlock_bh(&xprt->sock_lock);
 }
@@ -1326,8 +1333,7 @@ do_xprt_reserve(struct rpc_task *task)
 	}
 	dprintk("RPC:      waiting for request slot\n");
 	task->tk_status = -EAGAIN;
-	task->tk_timeout = 0;
-	rpc_sleep_on(&xprt->backlog, task, NULL, NULL);
+	rpc_sleep_on(&xprt->backlog, task, NULL, NULL, 0);
 }
 
 /*
--- linux-2.6.3/net/sunrpc/auth_gss/auth_gss.c.nulltimeout	2004-02-19 12:53:29.000000000 +0100
+++ linux-2.6.3/net/sunrpc/auth_gss/auth_gss.c	2004-02-19 12:53:49.000000000 +0100
@@ -376,8 +376,7 @@
 	/* Has someone updated the credential behind our back? */
 	if (!gss_cred_is_uptodate_ctx(cred)) {
 		/* No, so do upcall and sleep */
-		task->tk_timeout = 0;
-		rpc_sleep_on(&gss_msg->waitq, task, NULL, NULL);
+		rpc_sleep_on(&gss_msg->waitq, task, NULL, NULL, 0);
 		spin_unlock(&gss_auth->lock);
 		res = rpc_queue_upcall(dentry->d_inode, msg);
 		if (res)
@@ -391,8 +390,7 @@
 	return res;
 out_sleep:
 	/* Sleep forever */
-	task->tk_timeout = 0;
-	rpc_sleep_on(&gss_msg->waitq, task, NULL, NULL);
+	rpc_sleep_on(&gss_msg->waitq, task, NULL, NULL, 0);
 	spin_unlock(&gss_auth->lock);
 	if (gss_new)
 		kfree(gss_new);
