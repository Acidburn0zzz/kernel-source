# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/05/01 17:39:13-07:00 herbert@gondor.apana.org.au 
#   [IPV4/IPV6]: Fix listing of listening sockets.
#   
#   There is a bug in listening_get_first() which used by /proc/net/tcp*
#   where it wasn't looping through all the sockets in each hash chain.
#   This problem doesn't show up unless the first socket in a chain doesn't
#   match the family that is being looked up.
#   
#   The following patch fixes this by getting rid of listening_get_first()
#   altogether.
# 
# net/ipv4/tcp_ipv4.c
#   2004/05/01 17:38:53-07:00 herbert@gondor.apana.org.au +7 -41
#   [IPV4/IPV6]: Fix listing of listening sockets.
#   
#   There is a bug in listening_get_first() which used by /proc/net/tcp*
#   where it wasn't looping through all the sockets in each hash chain.
#   This problem doesn't show up unless the first socket in a chain doesn't
#   match the family that is being looked up.
#   
#   The following patch fixes this by getting rid of listening_get_first()
#   altogether.
# 
Index: linux-2.6.5/net/ipv4/tcp_ipv4.c
===================================================================
--- linux-2.6.5.orig/net/ipv4/tcp_ipv4.c	2004-06-08 14:10:03.000000000 +0200
+++ linux-2.6.5/net/ipv4/tcp_ipv4.c	2004-06-08 14:11:20.000000000 +0200
@@ -2170,46 +2170,6 @@
 		hlist_entry(tw->tw_node.next, typeof(*tw), tw_node) : NULL;
 }
 
-static void *listening_get_first(struct seq_file *seq, int noopenreq)
-{
-	struct tcp_iter_state* st = seq->private;
-	void *rc = NULL;
-
-	for (st->bucket = 0; st->bucket < TCP_LHTABLE_SIZE; ++st->bucket) {
-		struct open_request *req;
-		struct tcp_opt *tp;
-		struct sock *sk = sk_head(&tcp_listening_hash[st->bucket]);
-
-		if (!sk)
-			continue;
-		if (sk->sk_family == st->family) {
-			rc = sk;
-			goto out;
-		}
-	       	tp = tcp_sk(sk);
-		read_lock_bh(&tp->syn_wait_lock);
-		if (!noopenreq && tp->listen_opt && tp->listen_opt->qlen) {
-			st->uid		= sock_i_uid(sk);
-			st->syn_wait_sk = sk;
-			st->state	= TCP_SEQ_STATE_OPENREQ;
-			for (st->sbucket = 0; st->sbucket < TCP_SYNQ_HSIZE;
-			     ++st->sbucket) {
-				for (req = tp->listen_opt->syn_table[st->sbucket];
-				     req; req = req->dl_next) {
-					if (req->class->family != st->family)
-						continue;
-					rc = req;
-					goto out;
-				}
-			}
-			st->state = TCP_SEQ_STATE_LISTENING;
-		}
-		read_unlock_bh(&tp->syn_wait_lock);
-	}
-out:
-	return rc;
-}
-
 static void *listening_get_next(struct seq_file *seq, void *cur, int noopenreq)
 {
 	struct tcp_opt *tp;
@@ -2217,6 +2177,12 @@
 	struct sock *sk = cur;
 	struct tcp_iter_state* st = seq->private;
 
+	if (!sk) {
+		st->bucket = 0;
+		sk = sk_head(&tcp_listening_hash[0]);
+		goto get_sk;
+	}
+
 	++st->num;
 
 	if (st->state == TCP_SEQ_STATE_OPENREQ) {
@@ -2270,7 +2236,7 @@
 
 static void *listening_get_idx(struct seq_file *seq, loff_t *pos, int noopenreq)
 {
-	void *rc = listening_get_first(seq, noopenreq);
+	void *rc = listening_get_next(seq, NULL, noopenreq);
 
 	while (rc && *pos) {
 		rc = listening_get_next(seq, rc, noopenreq);
