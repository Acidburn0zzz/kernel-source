ChangeSet
  1.1619 04/05/06 10:22:19 vandrove@vc.cvut.cz[torvalds] +1 -0
  [PATCH] ncpfs data corruption when using large TCP transfers
  
  ncpfs was forgetting to update iovec's iov_base field whenever partial
  transmission occured. This was causing data corruption during large
  (60kB) writes.
  
  The code now also passes copy of iovec to the sock_sendmsg, so it does
  not rely on network stack updating (or not updating) passed iovec in
  case of success (or failure).

  fs/ncpfs/sock.c
    1.18 04/05/05 12:51:07 vandrove@vc.cvut.cz[torvalds] +5 -1
    ncpfs data corruption when using large TCP transfers

diff -Nru a/fs/ncpfs/sock.c b/fs/ncpfs/sock.c
--- a/fs/ncpfs/sock.c	Fri May  7 06:19:00 2004
+++ b/fs/ncpfs/sock.c	Fri May  7 06:19:00 2004
@@ -205,6 +205,7 @@
 	struct ncp_request_reply *rq;
 	struct msghdr msg;
 	struct iovec* iov;
+	struct iovec iovc[3];
 	int result;
 
 	rq = server->tx.creq;
@@ -212,10 +213,12 @@
 		return;
 	}
 
+	/* sock_sendmsg updates iov pointers for us :-( */
+	memcpy(iovc, rq->tx_ciov, rq->tx_iovlen * sizeof(iov[0]));
 	msg.msg_name = NULL;
 	msg.msg_namelen = 0;
 	msg.msg_control = NULL;
-	msg.msg_iov = rq->tx_ciov;
+	msg.msg_iov = iovc;
 	msg.msg_iovlen = rq->tx_iovlen;
 	msg.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT;
 	result = sock_sendmsg(server->ncp_sock, &msg, rq->tx_totallen);
@@ -239,6 +242,7 @@
 		iov++;
 		rq->tx_iovlen--;
 	}
+	iov->iov_base += result;
 	iov->iov_len -= result;
 	rq->tx_ciov = iov;
 }
.........................................................................
# vim: syntax=diff

