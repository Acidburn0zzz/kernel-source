ChangeSet
  1.1713.17.5 04/04/12 12:40:05 akpm@osdl.org[torvalds] +8 -0
  [PATCH] generalise system_running
  
  From: Olof Johansson <olof@austin.ibm.com>
  
  It's currently a boolean, but that means that system_running goes to zero
  again when shutting down.  So we then use code (in the page allocator) which
  is only designed to be used during bootup - it is marked __init.
  
  So we need to be able to distinguish early boot state from late shutdown
  state.  Rename system_running to system_state and give it the three
  appropriate states.

  mm/page_alloc.c
    1.199 04/04/12 10:53:58 akpm@osdl.org[torvalds] +1 -1
    generalise system_running

  kernel/sys.c
    1.74 04/04/12 10:53:58 akpm@osdl.org[torvalds] +4 -4
    generalise system_running

  kernel/sched.c
    1.257 04/04/12 10:53:58 akpm@osdl.org[torvalds] +2 -1
    generalise system_running

  kernel/printk.c
    1.36 04/04/12 10:53:58 akpm@osdl.org[torvalds] +2 -1
    generalise system_running

  kernel/kmod.c
    1.37 04/04/12 10:53:58 akpm@osdl.org[torvalds] +1 -1
    generalise system_running

  init/main.c
    1.129 04/04/12 10:53:58 akpm@osdl.org[torvalds] +2 -6
    generalise system_running

  include/linux/kernel.h
    1.48 04/04/12 10:53:58 akpm@osdl.org[torvalds] +7 -1
    generalise system_running

  arch/ppc/platforms/pmac_nvram.c
    1.13 04/04/12 10:53:58 akpm@osdl.org[torvalds] +4 -4
    generalise system_running

diff -Nru a/arch/ppc/platforms/pmac_nvram.c b/arch/ppc/platforms/pmac_nvram.c
--- a/arch/ppc/platforms/pmac_nvram.c	Tue Apr 13 07:16:25 2004
+++ b/arch/ppc/platforms/pmac_nvram.c	Tue Apr 13 07:16:25 2004
@@ -154,11 +154,11 @@
 	struct adb_request req;
 	DECLARE_COMPLETION(req_complete); 
 	
-	req.arg = system_running ? &req_complete : NULL;
+	req.arg = system_state == SYSTEM_RUNNING ? &req_complete : NULL;
 	if (pmu_request(&req, pmu_nvram_complete, 3, PMU_READ_NVRAM,
 			(addr >> 8) & 0xff, addr & 0xff))
 		return 0xff;
-	if (system_running)
+	if (system_state == SYSTEM_RUNNING)
 		wait_for_completion(&req_complete);
 	while (!req.complete)
 		pmu_poll();
@@ -170,11 +170,11 @@
 	struct adb_request req;
 	DECLARE_COMPLETION(req_complete); 
 	
-	req.arg = system_running ? &req_complete : NULL;
+	req.arg = system_state == SYSTEM_RUNNING ? &req_complete : NULL;
 	if (pmu_request(&req, pmu_nvram_complete, 4, PMU_WRITE_NVRAM,
 			(addr >> 8) & 0xff, addr & 0xff, val))
 		return;
-	if (system_running)
+	if (system_state == SYSTEM_RUNNING)
 		wait_for_completion(&req_complete);
 	while (!req.complete)
 		pmu_poll();
diff -Nru a/include/linux/kernel.h b/include/linux/kernel.h
--- a/include/linux/kernel.h	Tue Apr 13 07:16:25 2004
+++ b/include/linux/kernel.h	Tue Apr 13 07:16:25 2004
@@ -109,9 +109,15 @@
 extern void bust_spinlocks(int yes);
 extern int oops_in_progress;		/* If set, an oops, panic(), BUG() or die() is in progress */
 extern int panic_on_oops;
-extern int system_running;
+extern int system_state;		/* See values below */
 extern int tainted;
 extern const char *print_tainted(void);
+
+/* Values used for system_state */
+#define SYSTEM_BOOTING 0
+#define SYSTEM_RUNNING 1
+#define SYSTEM_SHUTDOWN 2
+
 #define TAINT_PROPRIETARY_MODULE	(1<<0)
 #define TAINT_FORCED_MODULE		(1<<1)
 #define TAINT_UNSAFE_SMP		(1<<2)
diff -Nru a/init/main.c b/init/main.c
--- a/init/main.c	Tue Apr 13 07:16:25 2004
+++ b/init/main.c	Tue Apr 13 07:16:25 2004
@@ -94,11 +94,7 @@
 extern void tc_init(void);
 #endif
 
-/*
- * Are we up and running (ie do we have all the infrastructure
- * set up)
- */
-int system_running;
+int system_state;	/* SYSTEM_BOOTING/RUNNING/SHUTDOWN */
 
 /*
  * Boot command-line arguments
@@ -613,7 +609,7 @@
 	 */
 	free_initmem();
 	unlock_kernel();
-	system_running = 1;
+	system_state = SYSTEM_RUNNING;
 
 	if (sys_open("/dev/console", O_RDWR, 0) < 0)
 		printk("Warning: unable to open an initial console.\n");
diff -Nru a/kernel/kmod.c b/kernel/kmod.c
--- a/kernel/kmod.c	Tue Apr 13 07:16:25 2004
+++ b/kernel/kmod.c	Tue Apr 13 07:16:25 2004
@@ -249,7 +249,7 @@
 	};
 	DECLARE_WORK(work, __call_usermodehelper, &sub_info);
 
-	if (!system_running)
+	if (system_state != SYSTEM_RUNNING)
 		return -EBUSY;
 
 	if (path[0] == '\0')
diff -Nru a/kernel/printk.c b/kernel/printk.c
--- a/kernel/printk.c	Tue Apr 13 07:16:26 2004
+++ b/kernel/printk.c	Tue Apr 13 07:16:26 2004
@@ -522,7 +522,8 @@
 			log_level_unknown = 1;
 	}
 
-	if (!cpu_online(smp_processor_id()) && !system_running) {
+	if (!cpu_online(smp_processor_id()) &&
+	    system_state != SYSTEM_RUNNING) {
 		/*
 		 * Some console drivers may assume that per-cpu resources have
 		 * been allocated.  So don't allow them to be called by this
diff -Nru a/kernel/sched.c b/kernel/sched.c
--- a/kernel/sched.c	Tue Apr 13 07:16:26 2004
+++ b/kernel/sched.c	Tue Apr 13 07:16:26 2004
@@ -2982,7 +2982,8 @@
 #if defined(in_atomic)
 	static unsigned long prev_jiffy;	/* ratelimiting */
 
-	if ((in_atomic() || irqs_disabled()) && system_running) {
+	if ((in_atomic() || irqs_disabled()) &&
+	    system_state == SYSTEM_RUNNING) {
 		if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
 			return;
 		prev_jiffy = jiffies;
diff -Nru a/kernel/sys.c b/kernel/sys.c
--- a/kernel/sys.c	Tue Apr 13 07:16:25 2004
+++ b/kernel/sys.c	Tue Apr 13 07:16:25 2004
@@ -436,7 +436,7 @@
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, NULL);
-		system_running = 0;
+		system_state = SYSTEM_SHUTDOWN;
 		device_shutdown();
 		printk(KERN_EMERG "Restarting system.\n");
 		machine_restart(NULL);
@@ -452,7 +452,7 @@
 
 	case LINUX_REBOOT_CMD_HALT:
 		notifier_call_chain(&reboot_notifier_list, SYS_HALT, NULL);
-		system_running = 0;
+		system_state = SYSTEM_SHUTDOWN;
 		device_shutdown();
 		printk(KERN_EMERG "System halted.\n");
 		machine_halt();
@@ -462,7 +462,7 @@
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
 		notifier_call_chain(&reboot_notifier_list, SYS_POWER_OFF, NULL);
-		system_running = 0;
+		system_state = SYSTEM_SHUTDOWN;
 		device_shutdown();
 		printk(KERN_EMERG "Power down.\n");
 		machine_power_off();
@@ -478,7 +478,7 @@
 		buffer[sizeof(buffer) - 1] = '\0';
 
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, buffer);
-		system_running = 0;
+		system_state = SYSTEM_SHUTDOWN;
 		device_shutdown();
 		printk(KERN_EMERG "Restarting system with command '%s'.\n", buffer);
 		machine_restart(buffer);
diff -Nru a/mm/page_alloc.c b/mm/page_alloc.c
--- a/mm/page_alloc.c	Tue Apr 13 07:16:25 2004
+++ b/mm/page_alloc.c	Tue Apr 13 07:16:25 2004
@@ -734,7 +734,7 @@
 	struct page * page;
 
 #ifdef CONFIG_NUMA
-	if (unlikely(!system_running))
+	if (unlikely(system_state == SYSTEM_BOOTING))
 		return get_boot_pages(gfp_mask, order);
 #endif
 	page = alloc_pages(gfp_mask, order);
.........................................................................
# vim: syntax=diff

