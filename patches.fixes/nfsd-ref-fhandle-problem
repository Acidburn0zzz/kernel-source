Status: ok
From: NeilBrown <neilb@suse.de>
Subject: Ignore ref_fh when crossing a mountpoint.
Patch-mainline: no
References: 158737


nfsd tries to return to a client the same sort of filehandle as was
used by the client.  This removes some filehandle aliasing issues and
means that a server upgrade followed by a downgrade will not confused
clients not restarted during that time.

However when crossing a mountpoint, the filehandle used for one
filesystem doesn't provide any useful information on what sort of
filehandle should be used on the other, and can provide misleading
information.  So if the reference filehandle is on a different
filesystem to the one being generated, ignore it.

Signed-off-by: Neil Brown <neilb@suse.de>

### Diffstat output
 ./fs/nfsd/nfsfh.c |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

Acked-by: 

diff ./fs/nfsd/nfsfh.c~current~ ./fs/nfsd/nfsfh.c
Index: linux-2.6.16/fs/nfsd/nfsfh.c
===================================================================
--- linux-2.6.16.orig/fs/nfsd/nfsfh.c	2006-03-20 16:53:29.000000000 +1100
+++ linux-2.6.16/fs/nfsd/nfsfh.c	2006-04-07 12:11:49.000000000 +1000
@@ -312,8 +312,8 @@
 fh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry, struct svc_fh *ref_fh)
 {
 	/* ref_fh is a reference file handle.
-	 * if it is non-null, then we should compose a filehandle which is
-	 * of the same version, where possible.
+	 * if it is non-null and for the same filesystem, then we should compose
+	 * a filehandle which is of the same version, where possible.
 	 * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca
 	 * Then create a 32byte filehandle using nfs_fhbase_old
 	 *
@@ -332,7 +332,7 @@
 		parent->d_name.name, dentry->d_name.name,
 		(inode ? inode->i_ino : 0));
 
-	if (ref_fh) {
+	if (ref_fh && ref_fh->fs_export == exp) {
 		ref_fh_version = ref_fh->fh_handle.fh_version;
 		if (ref_fh_version == 0xca)
 			ref_fh_fsid_type = 0;
