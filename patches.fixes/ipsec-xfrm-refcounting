From: Herbert Xu <herbert@gondor.apana.org.au>
To: ebs@ebshome.net (Eugene Surovegin)
Subject: Re: [IPSEC] fix ref counting in __xfrm4_bundle_create()
Cc: netdev@oss.sgi.com, davem@redhat.com
Date: Sat, 29 May 2004 13:27:13 +1000
Sender: netdev-bounce@oss.sgi.com

Eugene Surovegin <ebs@ebshome.net> wrote:
> 
> Unfortunately, error path in __xfrm4_bundle_create() also calls xfrm_state_put() 
> (indirectly through dst_free() -> ... -> xfrm_dst_destroy()) and we end up 
> calling xfrm_state_put() _twice_.

Well spotted.  Hopefully this should finally put an end to all these
xfrm_state bug reports :)

However, can you see if the following patch fixes this problem as well?
It moves the dst->xfrm assignment to a spot where errors cannot occur.


Index: linux-2.6.5/net/ipv4/xfrm4_policy.c
===================================================================
--- linux-2.6.5.orig/net/ipv4/xfrm4_policy.c	2004-04-04 05:37:39.000000000 +0200
+++ linux-2.6.5/net/ipv4/xfrm4_policy.c	2004-06-01 12:06:27.000000000 +0200
@@ -90,7 +90,6 @@
 			goto error;
 		}
 
-		dst1->xfrm = xfrm[i];
 		if (!dst)
 			dst = dst1;
 		else {
@@ -120,10 +119,12 @@
 		dst_hold(&rt->u.dst);
 	}
 	dst_prev->child = &rt->u.dst;
+	i = 0;
 	for (dst_prev = dst; dst_prev != &rt->u.dst; dst_prev = dst_prev->child) {
 		struct xfrm_dst *x = (struct xfrm_dst*)dst_prev;
 		x->u.rt.fl = *fl;
 
+		dst_prev->xfrm = xfrm[i++];
 		dst_prev->dev = rt->u.dst.dev;
 		if (rt->u.dst.dev)
 			dev_hold(rt->u.dst.dev);
Index: linux-2.6.5/net/ipv6/xfrm6_policy.c
===================================================================
--- linux-2.6.5.orig/net/ipv6/xfrm6_policy.c	2004-06-01 12:05:02.000000000 +0200
+++ linux-2.6.5/net/ipv6/xfrm6_policy.c	2004-06-01 12:06:27.000000000 +0200
@@ -107,7 +107,6 @@
 			goto error;
 		}
 
-		dst1->xfrm = xfrm[i];
 		if (!dst)
 			dst = dst1;
 		else {
@@ -139,9 +138,11 @@
 		dst_hold(&rt->u.dst);
 	}
 	dst_prev->child = &rt->u.dst;
+	i = 0;
 	for (dst_prev = dst; dst_prev != &rt->u.dst; dst_prev = dst_prev->child) {
 		struct xfrm_dst *x = (struct xfrm_dst*)dst_prev;
 
+		dst_prev->xfrm = xfrm[i++];
 		dst_prev->dev = rt->u.dst.dev;
 		if (rt->u.dst.dev)
 			dev_hold(rt->u.dst.dev);
Index: linux-2.6.5/net/xfrm/xfrm_policy.c
===================================================================
--- linux-2.6.5.orig/net/xfrm/xfrm_policy.c	2004-06-01 12:06:18.000000000 +0200
+++ linux-2.6.5/net/xfrm/xfrm_policy.c	2004-06-01 12:06:27.000000000 +0200
@@ -1016,6 +1016,8 @@
 
 static void xfrm_dst_destroy(struct dst_entry *dst)
 {
+	if (!dst->xfrm)
+		return;
 	xfrm_state_put(dst->xfrm);
 	dst->xfrm = NULL;
 }
