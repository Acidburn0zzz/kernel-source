Subject: FC devloss callback not called when devloss timer fires
From: James Smart <james.smart@emulex.com>
References: bnc#463289

When a SCSI target goes away for more than devloss timer the LLDD is not being
called for dev_loss_tmo_callbk in the FC transport code. 

The correct fix is to call dev_loss_tmo_callbk() at the tail end of
fc_timeout_deleted_rport() - but it has to be synchronized with the completion
of fc_starget_delete() that is pushed to the work queue just prior to the
routine exiting.

Signed-off-by: James Smart <james.smart@emulex.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>

 ---

drivers/scsi/scsi_transport_fc.c |   22 ++++++++++++++++++++--
include/scsi/scsi_transport_fc.h |    1 +
 2 files changed, 21 insertions(+), 2 deletions(-)

--- a/drivers/scsi/scsi_transport_fc.c	2008-12-19 13:50:10.000000000 -0500
+++ b/drivers/scsi/scsi_transport_fc.c	2008-12-19 13:50:06.000000000 -0500
@@ -2407,8 +2407,12 @@ fc_rport_final_delete(struct work_struct
 	/*
 	 * Notify the driver that the rport is now dead. The LLDD will
 	 * also guarantee that any communication to the rport is terminated
+	 *
+	 * Avoid this call if we already called it when we preserved the
+	 * rport for the binding.
 	 */
-	if (i->f->dev_loss_tmo_callbk)
+	if (!(rport->flags & FC_RPORT_DEVLOSS_CALLBK_DONE) &&
+	    (i->f->dev_loss_tmo_callbk))
 		i->f->dev_loss_tmo_callbk(rport);
 
 	transport_remove_device(dev);
@@ -2647,7 +2651,8 @@ fc_remote_port_add(struct Scsi_Host *sho
 				spin_lock_irqsave(shost->host_lock, flags);
 
 				rport->flags &= ~(FC_RPORT_FAST_FAIL_TIMEDOUT |
-						  FC_RPORT_DEVLOSS_PENDING);
+						  FC_RPORT_DEVLOSS_PENDING |
+						  FC_RPORT_DEVLOSS_CALLBK_DONE);
 
 				/* if target, initiate a scan */
 				if (rport->scsi_target_id != -1) {
@@ -2944,6 +2949,7 @@ fc_timeout_deleted_rport(struct work_str
 	struct fc_rport *rport =
 		container_of(work, struct fc_rport, dev_loss_work.work);
 	struct Scsi_Host *shost = rport_to_shost(rport);
+	struct fc_internal *i = to_fc_internal(shost->transportt);
 	struct fc_host_attrs *fc_host = shost_to_fc_host(shost);
 	unsigned long flags;
 
@@ -3030,6 +3036,8 @@ fc_timeout_deleted_rport(struct work_str
 		break;
 	}
 
+	rport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;
+
 	/*
 	 * As this only occurs if the remote port (scsi target)
 	 * went away and didn't come back - we'll remove
@@ -3039,8 +3047,18 @@ fc_timeout_deleted_rport(struct work_str
 
 	scsi_target_unblock(&rport->dev);
 	fc_queue_work(shost, &rport->stgt_delete_work);
+
+	/*
+	 * Notify the driver that the rport is now dead. The LLDD will
+	 * also guarantee that any communication to the rport is terminated
+	 * 
+	 * Note: we set the CALLBK_DONE flag above to correspond
+	 */
+	if (i->f->dev_loss_tmo_callbk)
+		i->f->dev_loss_tmo_callbk(rport);
 }
 
+
 /**
  * fc_timeout_fail_rport_io - Timeout handler for a fast io failing on a disconnected SCSI target.
  * @work:	rport to terminate io on.
--- a/include/scsi/scsi_transport_fc.h	2008-12-19 11:20:30.000000000 -0500
+++ b/include/scsi/scsi_transport_fc.h	2008-12-19 11:21:24.000000000 -0500
@@ -358,6 +358,7 @@ struct fc_rport {	/* aka fc_starget_attr
 #define FC_RPORT_DEVLOSS_PENDING	0x01
 #define FC_RPORT_SCAN_PENDING		0x02
 #define FC_RPORT_FAST_FAIL_TIMEDOUT	0x04
+#define FC_RPORT_DEVLOSS_CALLBK_DONE	0x08
 
 #define	dev_to_rport(d)				\
 	container_of(d, struct fc_rport, dev)
