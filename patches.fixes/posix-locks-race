From: Olaf Kirch <okir@suse.de>
Subject: Fix race conditions with file lock vs close
References: 84156, 64661, 86975
Patch-mainline: submitted 2005-07-11

When a multithreaded application tries to obtain a lock on a remote
file server (NFS or other), while another thread closes the file, we
risk oopsing or running into a BUG(). This can happen if the close
happens inbetween sys_fcntl() grabbing the file pointer, and before
the call to __posix_lock_file.

The fix is to change fcntl_setlk* and make them check if the file
is still open after the lock has been obtained.

Signed-off-by: Olaf Kirch <okir@suse.de>

Index: linux-2.6.12/fs/fcntl.c
===================================================================
--- linux-2.6.12.orig/fs/fcntl.c	2005-07-11 12:08:16.000000000 +0200
+++ linux-2.6.12/fs/fcntl.c	2005-07-11 12:10:57.000000000 +0200
@@ -288,7 +288,7 @@ static long do_fcntl(int fd, unsigned in
 		break;
 	case F_SETLK:
 	case F_SETLKW:
-		err = fcntl_setlk(filp, cmd, (struct flock __user *) arg);
+		err = fcntl_setlk(filp, cmd, (struct flock __user *) arg, fd);
 		break;
 	case F_GETOWN:
 		/*
@@ -376,7 +376,7 @@ asmlinkage long sys_fcntl64(unsigned int
 			break;
 		case F_SETLK64:
 		case F_SETLKW64:
-			err = fcntl_setlk64(filp, cmd, (struct flock64 __user *) arg);
+			err = fcntl_setlk64(filp, cmd, (struct flock64 __user *) arg, fd);
 			break;
 		default:
 			err = do_fcntl(fd, cmd, arg, filp);
Index: linux-2.6.12/fs/locks.c
===================================================================
--- linux-2.6.12.orig/fs/locks.c	2005-07-11 12:08:35.000000000 +0200
+++ linux-2.6.12/fs/locks.c	2005-07-11 12:10:57.000000000 +0200
@@ -1589,7 +1589,7 @@ out:
 /* Apply the lock described by l to an open file descriptor.
  * This implements both the F_SETLK and F_SETLKW commands of fcntl().
  */
-int fcntl_setlk(struct file *filp, unsigned int cmd, struct flock __user *l)
+int fcntl_setlk(struct file *filp, unsigned int cmd, struct flock __user *l, int fd)
 {
 	struct file_lock *file_lock = locks_alloc_lock();
 	struct flock flock;
@@ -1664,6 +1664,18 @@ int fcntl_setlk(struct file *filp, unsig
 		break;
 	}
 
+	/* Make sure the file is still open, otherwise we need
+	 * to release the lock we just claimed. */
+	spin_lock(&current->files->file_lock);
+	if (current->files->fd[fd] != filp) {
+		/* Darn - someone closed the file in the meanwhile. */
+		spin_unlock(&current->files->file_lock);
+		locks_remove_posix(filp, current->files);
+		error = -EBADF;
+	} else {
+		spin_unlock(&current->files->file_lock);
+	}
+
  out:
 	locks_free_lock(file_lock);
 	return error;
@@ -1722,7 +1734,7 @@ out:
 /* Apply the lock described by l to an open file descriptor.
  * This implements both the F_SETLK and F_SETLKW commands of fcntl().
  */
-int fcntl_setlk64(struct file *filp, unsigned int cmd, struct flock64 __user *l)
+int fcntl_setlk64(struct file *filp, unsigned int cmd, struct flock64 __user *l, int fd)
 {
 	struct file_lock *file_lock = locks_alloc_lock();
 	struct flock64 flock;
@@ -1797,6 +1809,18 @@ int fcntl_setlk64(struct file *filp, uns
 		break;
 	}
 
+	/* Make sure the file is still open, otherwise we need
+	 * to release the lock we just claimed. */
+	spin_lock(&current->files->file_lock);
+	if (current->files->fd[fd] != filp) {
+		/* Darn - someone closed the file in the meanwhile. */
+		spin_unlock(&current->files->file_lock);
+		locks_remove_posix(filp, current->files);
+		error = -EBADF;
+	} else {
+		spin_unlock(&current->files->file_lock);
+	}
+
 out:
 	locks_free_lock(file_lock);
 	return error;
Index: linux-2.6.12/include/linux/fs.h
===================================================================
--- linux-2.6.12.orig/include/linux/fs.h	2005-07-11 12:05:26.000000000 +0200
+++ linux-2.6.12/include/linux/fs.h	2005-07-11 12:10:57.000000000 +0200
@@ -697,11 +697,11 @@ extern struct list_head file_lock_list;
 #include <linux/fcntl.h>
 
 extern int fcntl_getlk(struct file *, struct flock __user *);
-extern int fcntl_setlk(struct file *, unsigned int, struct flock __user *);
+extern int fcntl_setlk(struct file *, unsigned int, struct flock __user *, int);
 
 #if BITS_PER_LONG == 32
 extern int fcntl_getlk64(struct file *, struct flock64 __user *);
-extern int fcntl_setlk64(struct file *, unsigned int, struct flock64 __user *);
+extern int fcntl_setlk64(struct file *, unsigned int, struct flock64 __user *, int);
 #endif
 
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
