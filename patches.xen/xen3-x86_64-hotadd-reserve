Subject: Support memory hotadd without sparsemem
From: ak@suse.de
References: 142035 148522 149117 160861
Patch-mainline: 2.6.17

Memory hotadd doesn't need SPARSEMEM, but can be handled by just preallocating
mem_maps. This only needs some untangling of ifdefs to enable the necessary 
code even without SPARSEMEM.

Originally from Keith Mannthey, hacked by AK.


Signed-off-by: Andi Kleen <ak@suse.de>

Automatically created from "patches.arch/x86_64-hotadd-reserve" by xen-port-patches.py

Index: head-2006-06-06/arch/x86_64/mm/init-xen.c
===================================================================
--- head-2006-06-06.orig/arch/x86_64/mm/init-xen.c	2006-06-06 12:53:28.000000000 +0200
+++ head-2006-06-06/arch/x86_64/mm/init-xen.c	2006-06-06 12:53:39.000000000 +0200
@@ -812,9 +812,8 @@ void __init clear_kernel_mapping(unsigne
 
 /*
  * Memory hotplug specific functions
- * These are only for non-NUMA machines right now.
  */
-#ifdef CONFIG_MEMORY_HOTPLUG
+#if defined(CONFIG_ACPI_HOTPLUG_MEMORY) || defined(CONFIG_ACPI_HOTPLUG_MEMORY_MODULE)
 
 void online_page(struct page *page)
 {
@@ -825,6 +824,39 @@ void online_page(struct page *page)
 	num_physpages++;
 }
 
+#ifndef CONFIG_MEMORY_HOTPLUG
+/*
+ * Memory Hotadd without sparsemem. The mem_maps have been allocated in advance,
+ * just online the pages.
+ */
+int __add_pages(struct zone *z, unsigned long start_pfn, unsigned long nr_pages)
+{
+	int err = -EIO;
+	unsigned long pfn;
+	unsigned long total = 0, mem = 0;
+	for (pfn = start_pfn; pfn < start_pfn + nr_pages; pfn++) {
+		unsigned long addr = pfn << PAGE_SHIFT;
+		if (pfn_valid(pfn) && e820_mapped(addr, addr+1, E820_RAM)) {
+			online_page(pfn_to_page(pfn));
+			err = 0;
+			mem++;
+		}
+		total++;
+	}
+	if (!err) {
+		z->spanned_pages += total;
+		z->present_pages += mem;
+		z->zone_pgdat->node_spanned_pages += total;
+		z->zone_pgdat->node_present_pages += mem;
+	}
+	return err;
+}
+#endif
+
+/*
+ * Memory is added always to NORMAL zone. This means you will never get
+ * additional DMA/DMA32 memory.
+ */
 int add_memory(u64 start, u64 size)
 {
 	struct pglist_data *pgdat = NODE_DATA(0);
Index: head-2006-06-06/arch/x86_64/kernel/e820-xen.c
===================================================================
--- head-2006-06-06.orig/arch/x86_64/kernel/e820-xen.c	2006-06-06 12:51:13.000000000 +0200
+++ head-2006-06-06/arch/x86_64/kernel/e820-xen.c	2006-06-06 12:53:39.000000000 +0200
@@ -103,7 +103,7 @@ static inline int bad_addr(unsigned long
 	return 0;
 } 
 
-int __init e820_mapped(unsigned long start, unsigned long end, unsigned type) 
+int __meminit e820_mapped(unsigned long start, unsigned long end, unsigned type)
 { 
 	int i;
 	for (i = 0; i < e820.nr_map; i++) { 
Index: head-2006-06-06/arch/i386/mm/init-xen.c
===================================================================
--- head-2006-06-06.orig/arch/i386/mm/init-xen.c	2006-06-06 12:52:32.000000000 +0200
+++ head-2006-06-06/arch/i386/mm/init-xen.c	2006-06-06 12:53:39.000000000 +0200
@@ -722,6 +722,7 @@ void __init mem_init(void)
  * Specifically, in the case of x86, we will always add
  * memory to the highmem for now.
  */
+#ifdef CONFIG_HOTPLUG_MEMORY
 #ifndef CONFIG_NEED_MULTIPLE_NODES
 int add_memory(u64 start, u64 size)
 {
@@ -738,6 +739,7 @@ int remove_memory(u64 start, u64 size)
 	return -EINVAL;
 }
 #endif
+#endif
 
 kmem_cache_t *pgd_cache;
 kmem_cache_t *pmd_cache;
