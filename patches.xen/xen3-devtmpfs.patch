From: Kay Sievers <kay.sievers@vrfy.org>
Subject: driver-core: devtmpfs - driver-core maintained /dev tmpfs

Devtmpfs lets the kernel create a tmpfs very early at kernel
initialization, before any driver-core device is registered. Every
device with a major/minor will have a device node created in this
tmpfs instance. After the rootfs is mounted by the kernel, the
populated tmpfs is mounted at /dev. In initramfs
"mount --move /dev /root/dev" can move it to the manually mounted
root filesystem before changing into /root and /sbin/init is
executed.

The tmpfs instance can be changed and altered by userspace at any time,
and in any way needed - just like today's udev-mounted tmpfs. Unmodified
udev versions will run just fine on top of it, and will recognize an
already existing kernel-created device node and use it.

The default node permissions are root:root 0600. Proper permissions
and user/group ownership, meaningful symlinks, all other policy besides
the node name, still needs to be applied by udev, just as without
devtmpfs.

If a node is created by devtmps, devtmpfs will remove the device node
when the device goes away. If the device node was created by
userspace, or the devtmpfs created node was replaced by userspace, it
will not be removed by devtmpfs.

This makes init=/bin/sh work without any further userspace support.
/dev will be fully populated and dynamic, and always reflect the current
device state of the kernel. Especially in the face of the already
implemented dynamic device numbers for block devices, this can be very
helpful in a rescue situation, where static devices nodes will no longer
work.
Custom, embedded-like systems should be able to use this as a dynamic
/dev directory without any need for aditional userspace tools.

With the kernel populated /dev, existing initramfs or kernel-mount
bootup logic can be optimized to be more efficient, and not to require a
full coldplug run, which is currently needed to bootstrap the inital
/dev directory content, before continuing bringing up the rest of
the system. There will be no missed events to replay, because /dev is
available before the first kernel device is registered with the
driver-core. A coldplug run can take, depending on the speed of the
system and the amount of devices which need to be handled, from one
to several seconds.

Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
Signed-off-by: Jan Blunck <jblunck@suse.de>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
Automatically created from "patches.suse/devtmpfs.patch" by xen-port-patches.py

--- head-2009-05-19.orig/arch/x86/kernel/microcode_core-xen.c	2009-05-19 09:55:40.000000000 +0200
+++ head-2009-05-19/arch/x86/kernel/microcode_core-xen.c	2009-05-19 10:09:44.000000000 +0200
@@ -118,6 +118,7 @@ static const struct file_operations micr
 static struct miscdevice microcode_dev = {
 	.minor		= MICROCODE_MINOR,
 	.name		= "microcode",
+	.devnode	= "cpu/microcode",
 	.fops		= &microcode_fops,
 };
 
