From: www.kernel.org
Subject: Linux 2.6.18
Patch-mainline: 2.6.18

Automatically created from "patches.kernel.org/patch-2.6.18" by xen-port-patches.py

Acked-by: jbeulich@novell.com

Index: head-2007-02-08/arch/i386/Kconfig
===================================================================
--- head-2007-02-08.orig/arch/i386/Kconfig	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/Kconfig	2007-02-09 10:13:48.000000000 +0100
@@ -16,7 +16,6 @@ config X86_32
 
 config GENERIC_TIME
 	bool
-	depends on !X86_XEN
 	default y
 
 config LOCKDEP_SUPPORT
@@ -271,7 +270,6 @@ config NR_CPUS
 config SCHED_SMT
 	bool "SMT (Hyperthreading) scheduler support"
 	depends on X86_HT
-	depends on !X86_XEN
 	help
 	  SMT scheduler support improves the CPU scheduler's decision making
 	  when dealing with Intel Pentium 4 chips with HyperThreading at a
@@ -891,7 +889,6 @@ config HOTPLUG_CPU
 
 config COMPAT_VDSO
 	bool "Compat VDSO support"
-	depends on !X86_XEN
 	default y
 	depends on !PARAVIRT
 	help
Index: head-2007-02-08/arch/i386/kernel/alternative.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/alternative.c	2007-02-04 19:44:54.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/alternative.c	2007-02-09 10:13:18.000000000 +0100
@@ -165,7 +165,7 @@ void apply_alternatives(struct alt_instr
 #ifdef CONFIG_X86_64
 		/* vsyscall code is not mapped yet. resolve it manually. */
 		if (instr >= (u8 *)VSYSCALL_START && instr < (u8*)VSYSCALL_END) {
-			instr = __va(instr - (u8*)VSYSCALL_START + (u8*)__pa_symbol(&__vsyscall_0));
+			instr -= VSYSCALL_START - (unsigned long)&__vsyscall_0;
 			DPRINTK("%s: vsyscall fixup: %p => %p\n",
 				__FUNCTION__, a->instr, instr);
 		}
Index: head-2007-02-08/arch/i386/kernel/entry-xen.S
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/entry-xen.S	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/entry-xen.S	2007-02-09 10:13:18.000000000 +0100
@@ -368,6 +368,7 @@ sysexit_scrit:	/**** START OF SYSEXIT CR
 	movl ESI(%esp), %esi
 	sysexit
 14:	__DISABLE_INTERRUPTS
+	TRACE_IRQS_OFF
 sysexit_ecrit:	/**** END OF SYSEXIT CRITICAL REGION ****/
 	push %esp
 	call evtchn_do_upcall
@@ -427,11 +428,13 @@ restore_nocheck:
 restore_nocheck:
 	movl EFLAGS(%esp), %eax
 	testl $(VM_MASK|NMI_MASK), %eax
+	CFI_REMEMBER_STATE
 	jnz hypervisor_iret
 	shr $9, %eax			# EAX[0] == IRET_EFLAGS.IF
 	GET_VCPU_INFO
 	andb evtchn_upcall_mask(%esi),%al
 	andb $1,%al			# EAX[0] == IRET_EFLAGS.IF & event_mask
+	CFI_REMEMBER_STATE
 	jnz restore_all_enable_events	#        != 0 => enable event delivery
 #endif
 	TRACE_IRQS_IRET
@@ -455,8 +458,8 @@ iret_exc:
 	.long 1b,iret_exc
 .previous
 
-#ifndef CONFIG_XEN
 	CFI_RESTORE_STATE
+#ifndef CONFIG_XEN
 ldt_ss:
 	larl OLDSS(%esp), %eax
 	jnz restore_nocheck
@@ -485,14 +488,36 @@ ldt_ss:
 	.align 4
 	.long 1b,iret_exc
 .previous
-	CFI_ENDPROC
 #else
+        ALIGN
+restore_all_enable_events:
+	TRACE_IRQS_ON
+	__ENABLE_INTERRUPTS
+scrit:	/**** START OF CRITICAL REGION ****/
+	__TEST_PENDING
+	jnz  14f			# process more events if necessary...
+	RESTORE_REGS
+	addl $4, %esp
+	CFI_ADJUST_CFA_OFFSET -4
+1:	iret
+.section __ex_table,"a"
+	.align 4
+	.long 1b,iret_exc
+.previous
+14:	__DISABLE_INTERRUPTS
+	TRACE_IRQS_OFF
+	jmp  11f
+ecrit:  /**** END OF CRITICAL REGION ****/
+
+	CFI_RESTORE_STATE
 hypervisor_iret:
 	andl $~NMI_MASK, EFLAGS(%esp)
 	RESTORE_REGS
 	addl $4, %esp
+	CFI_ADJUST_CFA_OFFSET -4
 	jmp  hypercall_page + (__HYPERVISOR_iret * 32)
 #endif
+	CFI_ENDPROC
 
 	# perform work that needs to be done immediately before resumption
 	ALIGN
@@ -736,7 +761,9 @@ error_code:
 # critical region we know that the entire frame is present and correct
 # so we can simply throw away the new one.
 ENTRY(hypervisor_callback)
+	RING0_INT_FRAME
 	pushl %eax
+	CFI_ADJUST_CFA_OFFSET 4
 	SAVE_ALL
 	movl EIP(%esp),%eax
 	cmpl $scrit,%eax
@@ -748,27 +775,15 @@ ENTRY(hypervisor_callback)
 	cmpl $sysexit_ecrit,%eax
 	ja   11f
 	addl $OLDESP,%esp		# Remove eflags...ebx from stack frame.
+	CFI_ADJUST_CFA_OFFSET -OLDESP
 11:	push %esp
+	CFI_ADJUST_CFA_OFFSET 4
 	call evtchn_do_upcall
 	add  $4,%esp
+	CFI_ADJUST_CFA_OFFSET -4
 	jmp  ret_from_intr
+	CFI_ENDPROC
 
-        ALIGN
-restore_all_enable_events:
-	__ENABLE_INTERRUPTS
-scrit:	/**** START OF CRITICAL REGION ****/
-	__TEST_PENDING
-	jnz  14f			# process more events if necessary...
-	RESTORE_REGS
-	addl $4, %esp
-1:	iret
-.section __ex_table,"a"
-	.align 4
-	.long 1b,iret_exc
-.previous
-14:	__DISABLE_INTERRUPTS
-	jmp  11b
-ecrit:  /**** END OF CRITICAL REGION ****/
 # [How we do the fixup]. We want to merge the current stack frame with the
 # just-interrupted frame. How we do this depends on where in the critical
 # region the interrupted handler was executing, and so how many saved
@@ -835,6 +850,7 @@ ENTRY(failsafe_callback)
 	addl $16,%esp		# EAX != 0 => Category 2 (Bad IRET)
 	jmp iret_exc
 5:	addl $16,%esp		# EAX == 0 => Category 1 (Bad segment)
+	RING0_INT_FRAME
 	pushl $0
 	SAVE_ALL
 	jmp ret_from_exception
@@ -860,6 +876,7 @@ ENTRY(failsafe_callback)
 	.long 4b,9b;		\
 .previous
 #endif
+	CFI_ENDPROC
 
 ENTRY(coprocessor_error)
 	RING0_INT_FRAME
@@ -1187,8 +1204,11 @@ ENDPROC(arch_unwind_init_running)
 #endif
 
 ENTRY(fixup_4gb_segment)
+	RING0_EC_FRAME
 	pushl $do_fixup_4gb_segment
+	CFI_ADJUST_CFA_OFFSET 4
 	jmp error_code
+	CFI_ENDPROC
 
 .section .rodata,"a"
 .align 4
Index: head-2007-02-08/arch/i386/kernel/head-xen.S
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/head-xen.S	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/head-xen.S	2007-02-09 10:13:18.000000000 +0100
@@ -63,9 +63,6 @@ ENTRY(startup_32)
 
 	pushl %eax		# fake return address
 	jmp start_kernel
-L6:
-	jmp L6			# main should never return here, but
-				# just in case, we know what happens.
 
 #define HYPERCALL_PAGE_OFFSET 0x1000
 .org HYPERCALL_PAGE_OFFSET
Index: head-2007-02-08/arch/i386/kernel/io_apic-xen.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/io_apic-xen.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/io_apic-xen.c	2007-02-09 10:13:18.000000000 +0100
@@ -90,7 +90,6 @@ atomic_t irq_mis_count;
 static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
 
 static DEFINE_SPINLOCK(ioapic_lock);
-static DEFINE_SPINLOCK(vector_lock);
 
 int timer_over_8254 __initdata = 1;
 
@@ -1209,33 +1208,22 @@ u8 irq_vector[NR_IRQ_VECTORS] __read_mos
 
 int assign_irq_vector(int irq)
 {
-	unsigned long flags;
-	int vector;
 	struct physdev_irq irq_op;
 
 	BUG_ON(irq != AUTO_ASSIGN && (unsigned)irq >= NR_IRQ_VECTORS);
 
-	spin_lock_irqsave(&vector_lock, flags);
-
-	if (irq != AUTO_ASSIGN && IO_APIC_VECTOR(irq) > 0) {
-		spin_unlock_irqrestore(&vector_lock, flags);
+	if (irq != AUTO_ASSIGN && IO_APIC_VECTOR(irq) > 0)
 		return IO_APIC_VECTOR(irq);
-	}
 
 	irq_op.irq = irq;
-	if (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op)) {
-		spin_unlock_irqrestore(&vector_lock, flags);
+	if (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op))
 		return -ENOSPC;
-	}
 
-	vector = irq_op.vector;
-	vector_irq[vector] = irq;
+	vector_irq[irq_op.vector] = irq;
 	if (irq != AUTO_ASSIGN)
-		IO_APIC_VECTOR(irq) = vector;
-
-	spin_unlock_irqrestore(&vector_lock, flags);
+		IO_APIC_VECTOR(irq) = irq_op.vector;
 
-	return vector;
+	return irq_op.vector;
 }
 
 #ifndef CONFIG_XEN
Index: head-2007-02-08/arch/i386/kernel/Makefile
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/Makefile	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/Makefile	2007-02-09 10:13:18.000000000 +0100
@@ -77,6 +77,52 @@ $(obj)/vsyscall-%.so: $(src)/vsyscall.ld
 		      $(obj)/vsyscall-%.o $(obj)/$(vsyscall_note) FORCE
 	$(call if_changed,syscall)
 
+ifeq ($(CONFIG_XEN)$(CONFIG_COMPAT_VDSO),yy)
+
+# vsyscall.o also contains the vsyscall DSO relocation info as __initdata.
+# We must build both the alternative images before we can assemble it.
+# Note: kbuild does not track this dependency due to usage of .include
+$(obj)/vsyscall.o: $(obj)/vsyscall-int80.rel $(obj)/vsyscall-sysenter.rel
+targets += $(foreach F,int80 sysenter,vsyscall-$F.so.alt vsyscall-$F.rel)
+targets += vsyscall.lds.alt
+
+# The alternative DSO images are built using an alternate base address.
+quiet_cmd_syscall_alt = REBASE  $@
+      cmd_syscall_alt = sed 's,^\([[:space:]]*\.[[:space:]]*=[[:space:]]*\),\1-0x55AA0000 + ,' $< >$@
+
+quiet_cmd_syscall_rel = COMPARE $@
+      cmd_syscall_rel = set -e; \
+			cmp -l $(basename $<) $< \
+			| { read off1 old1 new1; \
+			    read off2 old2 new2; \
+			    test $$(expr $$off1 + 1) = $$off2; \
+			    echo " .long $$(expr $$off1 - 3)"; \
+			    while read off1 old3 new3; do \
+				read off2 old4 new4; \
+				test $$(expr $$off1 + 1) = $$off2; \
+				test $$old1 = $$old3 -a $$new1 = $$new3; \
+				test $$old2 = $$old4 -a $$new2 = $$new4; \
+				echo " .long $$(expr $$off1 - 3)"; \
+			    done; \
+			  } >$@
+
+SYSCFLAGS_vsyscall-sysenter.so.alt = $(vsyscall-flags)
+SYSCFLAGS_vsyscall-int80.so.alt    = $(vsyscall-flags)
+
+$(obj)/vsyscall.lds.alt: $(obj)/vsyscall.lds FORCE
+	$(call if_changed,syscall_alt)
+
+$(obj)/vsyscall-int80.so.alt $(obj)/vsyscall-sysenter.so.alt: \
+$(obj)/vsyscall-%.so.alt: $(obj)/vsyscall.lds.alt \
+		      $(obj)/vsyscall-%.o $(obj)/$(vsyscall_note) FORCE
+	$(call if_changed,syscall)
+
+$(obj)/vsyscall-int80.rel $(obj)/vsyscall-sysenter.rel: \
+$(obj)/vsyscall-%.rel: $(obj)/vsyscall-%.so.alt FORCE
+	$(call if_changed,syscall_rel)
+
+endif
+
 # We also create a special relocatable object that should mirror the symbol
 # table and layout of the linked DSO.  With ld -R we can then refer to
 # these symbols in the kernel code rather than hand-coded addresses.
@@ -97,7 +143,7 @@ include $(srctree)/scripts/Makefile.xen
 
 obj-y += fixup.o
 microcode-$(subst m,y,$(CONFIG_MICROCODE)) := microcode-xen.o
-n-obj-xen := i8259.o timers/ reboot.o smpboot.o trampoline.o
+n-obj-xen := i8259.o reboot.o smpboot.o trampoline.o tsc.o
 
 obj-y := $(call filterxen, $(obj-y), $(n-obj-xen))
 obj-y := $(call cherrypickxen, $(obj-y))
Index: head-2007-02-08/arch/i386/kernel/process-xen.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/process-xen.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/process-xen.c	2007-02-09 10:13:18.000000000 +0100
@@ -611,7 +611,8 @@ struct task_struct fastcall * __switch_t
 		mcl++;
 	}
 
-	if (unlikely(prev->io_bitmap_ptr || next->io_bitmap_ptr)) {
+	if (unlikely(test_tsk_thread_flag(prev_p, TIF_IO_BITMAP)
+	             || test_tsk_thread_flag(next_p, TIF_IO_BITMAP))) {
 		iobmp_op.bitmap   = (char *)next->io_bitmap_ptr;
 		iobmp_op.nr_ports = next->io_bitmap_ptr ? IO_BITMAP_BITS : 0;
 		mcl->op      = __HYPERVISOR_physdev_op;
Index: head-2007-02-08/arch/i386/kernel/sysenter.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/sysenter.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/sysenter.c	2007-02-09 10:13:18.000000000 +0100
@@ -25,6 +25,8 @@
 
 #ifdef CONFIG_XEN
 #include <xen/interface/callback.h>
+extern const unsigned long vdso_rel_int80_start[], vdso_rel_int80_end[];
+extern const unsigned long vdso_rel_sysenter_start[], vdso_rel_sysenter_end[];
 #endif
 
 /*
@@ -70,6 +72,142 @@ void enable_sep_cpu(void)
 #endif
 }
 
+#if defined(CONFIG_XEN) && defined(CONFIG_COMPAT_VDSO)
+static void __init relocate_vdso(Elf32_Ehdr *ehdr, unsigned long old_base, unsigned long new_base,
+                                 const unsigned long *reloc_start, const unsigned long *reloc_end)
+{
+#if 1
+	const unsigned long *reloc;
+
+	for (reloc = reloc_start; reloc < reloc_end; ++reloc) {
+		unsigned long *ptr = (void *)((unsigned long)ehdr + *reloc);
+
+		*ptr += new_base - old_base;
+	}
+#else
+	unsigned i, ndynsym = 0, szdynsym = 0;
+	unsigned long dynsym = 0;
+
+	BUG_ON(ehdr->e_ident[EI_MAG0] != ELFMAG0);
+	BUG_ON(ehdr->e_ident[EI_MAG1] != ELFMAG1);
+	BUG_ON(ehdr->e_ident[EI_MAG2] != ELFMAG2);
+	BUG_ON(ehdr->e_ident[EI_MAG3] != ELFMAG3);
+	BUG_ON(ehdr->e_ident[EI_CLASS] != ELFCLASS32);
+	BUG_ON(ehdr->e_ident[EI_DATA] != ELFDATA2LSB);
+	BUG_ON(ehdr->e_ehsize < sizeof(*ehdr));
+	ehdr->e_entry += new_base - old_base;
+	BUG_ON(ehdr->e_phentsize < sizeof(Elf32_Phdr));
+	for (i = 0; i < ehdr->e_phnum; ++i) {
+		Elf32_Phdr *phdr = (void *)((unsigned long)ehdr + ehdr->e_phoff + i * ehdr->e_phentsize);
+
+		phdr->p_vaddr += new_base - old_base;
+		switch(phdr->p_type) {
+		case PT_LOAD:
+		case PT_NOTE:
+			break;
+		case PT_DYNAMIC: {
+				Elf32_Dyn *dyn = (void *)(phdr->p_vaddr - new_base + (unsigned long)ehdr);
+				unsigned j;
+
+				for(j = 0; dyn[j].d_tag != DT_NULL; ++j) {
+					switch(dyn[j].d_tag) {
+					case DT_HASH:
+					case DT_STRTAB:
+					case DT_SYMTAB:
+					case 0x6ffffff0: /* DT_VERSYM */
+					case 0x6ffffffc: /* DT_VERDEF */
+						break;
+					case DT_SONAME:
+					case DT_STRSZ:
+					case 0x6ffffffd: /* DT_VERDEFNUM */
+						continue;
+					case DT_SYMENT:
+						szdynsym = dyn[j].d_un.d_val;
+						continue;
+					default:
+						if (dyn[j].d_tag >= 0x60000000 /* OLD_DT_LOOS */
+						    || dyn[j].d_tag < 31 /* DT_ENCODING */
+						    || !(dyn[j].d_tag & 1)) {
+							printk(KERN_WARNING "vDSO dynamic info %u has unsupported tag %08X\n", j, dyn[j].d_tag);
+							WARN_ON(1);
+							continue;
+						}
+						break;
+					}
+					dyn[j].d_un.d_ptr += new_base - old_base;
+					switch(dyn[j].d_tag) {
+					case DT_HASH:
+						ndynsym = ((Elf32_Word *)dyn[j].d_un.d_ptr)[1];
+						break;
+					case DT_SYMTAB:
+						dynsym = dyn[j].d_un.d_ptr;
+						break;
+					}
+				}
+			}
+			break;
+		case PT_GNU_EH_FRAME:
+			/* XXX */
+			break;
+		default:
+			printk(KERN_WARNING "vDSO program header %u has unsupported type %08X\n", i, phdr->p_type);
+			WARN_ON(1);
+			break;
+		}
+	}
+	BUG_ON(ehdr->e_shentsize < sizeof(Elf32_Shdr));
+	BUG_ON(ehdr->e_shnum >= SHN_LORESERVE);
+	for (i = 1; i < ehdr->e_shnum; ++i) {
+		Elf32_Shdr *shdr = (void *)((unsigned long)ehdr + ehdr->e_shoff + i * ehdr->e_shentsize);
+
+		if (!(shdr->sh_flags & SHF_ALLOC))
+			continue;
+		shdr->sh_addr += new_base - old_base;
+		switch(shdr->sh_type) {
+		case SHT_DYNAMIC:
+		case SHT_HASH:
+		case SHT_NOBITS:
+		case SHT_NOTE:
+		case SHT_PROGBITS:
+		case SHT_STRTAB:
+		case 0x6ffffffd: /* SHT_GNU_verdef */
+		case 0x6fffffff: /* SHT_GNU_versym */
+			break;
+		case SHT_DYNSYM:
+			BUG_ON(shdr->sh_entsize < sizeof(Elf32_Sym));
+			if (!szdynsym)
+				szdynsym = shdr->sh_entsize;
+			else
+				WARN_ON(szdynsym != shdr->sh_entsize);
+			if (!ndynsym)
+				ndynsym = shdr->sh_size / szdynsym;
+			else
+				WARN_ON(ndynsym != shdr->sh_size / szdynsym);
+			if (!dynsym)
+				dynsym = shdr->sh_addr;
+			else
+				WARN_ON(dynsym != shdr->sh_addr);
+			break;
+		default:
+			printk(KERN_WARNING "vDSO section %u has unsupported type %08X\n", i, shdr->sh_type);
+			WARN_ON(shdr->sh_size);
+			break;
+		}
+	}
+	dynsym += (unsigned long)ehdr - new_base;
+	for(i = 1; i < ndynsym; ++i) {
+		Elf32_Sym *sym = (void *)(dynsym + i * szdynsym);
+
+		if (sym->st_shndx == SHN_ABS)
+			continue;
+		sym->st_value += new_base - old_base;
+	}
+#endif
+}
+#else
+#define relocate_vdso(ehdr, old, new, start, end) ((void)0)
+#endif
+
 /*
  * These symbols are defined by vsyscall.o to mark the bounds
  * of the ELF DSO images included therein.
@@ -103,12 +241,16 @@ int __init sysenter_setup(void)
 		memcpy(syscall_page,
 		       &vsyscall_int80_start,
 		       &vsyscall_int80_end - &vsyscall_int80_start);
+		relocate_vdso(syscall_page, VDSO_PRELINK, __fix_to_virt(FIX_VDSO),
+		              vdso_rel_int80_start, vdso_rel_int80_end);
 		return 0;
 	}
 
 	memcpy(syscall_page,
 	       &vsyscall_sysenter_start,
 	       &vsyscall_sysenter_end - &vsyscall_sysenter_start);
+	relocate_vdso(syscall_page, VDSO_PRELINK, __fix_to_virt(FIX_VDSO),
+	              vdso_rel_sysenter_start, vdso_rel_sysenter_end);
 
 	return 0;
 }
Index: head-2007-02-08/arch/i386/kernel/time-xen.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/time-xen.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/time-xen.c	2007-02-09 10:13:18.000000000 +0100
@@ -96,10 +96,6 @@ extern unsigned long wall_jiffies;
 DEFINE_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL(rtc_lock);
 
-extern struct init_timer_opts timer_tsc_init;
-extern struct timer_opts timer_tsc;
-#define timer_none timer_tsc
-
 /* These are peridically updated in shared_info, and then copied here. */
 struct shadow_time_info {
 	u64 tsc_timestamp;     /* TSC at last update of time vals.  */
@@ -239,6 +235,7 @@ static u64 get_nsec_offset(struct shadow
 	return scale_delta(delta, shadow->tsc_to_nsec_mul, shadow->tsc_shift);
 }
 
+#ifdef CONFIG_X86_64
 static unsigned long get_usec_offset(struct shadow_time_info *shadow)
 {
 	u64 now, delta;
@@ -246,6 +243,7 @@ static unsigned long get_usec_offset(str
 	delta = now - shadow->tsc_timestamp;
 	return scale_delta(delta, shadow->tsc_to_usec_mul, shadow->tsc_shift);
 }
+#endif
 
 static void __update_wallclock(time_t sec, long nsec)
 {
@@ -356,6 +354,8 @@ void rtc_cmos_write(unsigned char val, u
 }
 EXPORT_SYMBOL(rtc_cmos_write);
 
+#ifdef CONFIG_X86_64
+
 /*
  * This version of gettimeofday has microsecond resolution
  * and better than microsecond precision on fast x86 machines with TSC.
@@ -484,6 +484,8 @@ int do_settimeofday(struct timespec *tv)
 
 EXPORT_SYMBOL(do_settimeofday);
 
+#endif
+
 static void sync_xen_wallclock(unsigned long dummy);
 static DEFINE_TIMER(sync_xen_wallclock_timer, sync_xen_wallclock, 0, 0);
 static void sync_xen_wallclock(unsigned long dummy)
@@ -535,11 +537,15 @@ static int set_rtc_mmss(unsigned long no
 	return retval;
 }
 
+#ifdef CONFIG_X86_64
 /* monotonic_clock(): returns # of nanoseconds passed since time_init()
  *		Note: This function is required to return accurate
  *		time even in the absence of multiple timer ticks.
  */
 unsigned long long monotonic_clock(void)
+#else
+unsigned long long sched_clock(void)
+#endif
 {
 	int cpu = get_cpu();
 	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
@@ -559,9 +565,9 @@ unsigned long long monotonic_clock(void)
 
 	return time;
 }
+#ifdef CONFIG_X86_64
 EXPORT_SYMBOL(monotonic_clock);
 
-#ifdef __x86_64__
 unsigned long long sched_clock(void)
 {
 	return monotonic_clock();
@@ -929,11 +935,11 @@ void __init time_init(void)
 
 	update_wallclock();
 
+#ifdef CONFIG_X86_64
 	init_cpu_khz();
 	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
 	       cpu_khz / 1000, cpu_khz % 1000);
 
-#if defined(__x86_64__)
 	vxtime.mode = VXTIME_TSC;
 	vxtime.quot = (1000000L << 32) / vxtime_hz;
 	vxtime.tsc_quot = (1000L << 32) / cpu_khz;
@@ -1076,6 +1082,58 @@ void local_teardown_timer(unsigned int c
 }
 #endif
 
+#ifndef CONFIG_X86_64
+
+void tsc_init(void)
+{
+	init_cpu_khz();
+	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
+	       cpu_khz / 1000, cpu_khz % 1000);
+
+	use_tsc_delay();
+}
+
+#include <linux/clocksource.h>
+
+void mark_tsc_unstable(void)
+{
+#ifndef CONFIG_XEN /* XXX Should tell the hypervisor about this fact. */
+	tsc_unstable = 1;
+#endif
+}
+EXPORT_SYMBOL_GPL(mark_tsc_unstable);
+
+static cycle_t read_tsc(void)
+{
+	cycle_t ret;
+
+	rdtscll(ret);
+
+	return ret;
+}
+
+static struct clocksource clocksource_xen = {
+	.name			= "xen",
+	.rating			= 300,
+	.read			= read_tsc,
+	.mask			= CLOCKSOURCE_MASK(64),
+	.mult			= 0, /* to be set */
+	.shift			= 22,
+	.is_continuous		= 1,
+};
+
+static int __init init_xen_clocksource(void)
+{
+	clocksource_xen.mult = clocksource_khz2mult(cpu_khz,
+						clocksource_xen.shift);
+
+	return clocksource_register(&clocksource_xen);
+}
+
+module_init(init_xen_clocksource);
+
+#endif
+
 /*
  * /proc/sys/xen: This really belongs in another file. It can stay here for
  * now however.
Index: head-2007-02-08/arch/i386/kernel/vsyscall.S
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/vsyscall.S	2007-02-04 19:44:54.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/vsyscall.S	2007-02-09 10:13:18.000000000 +0100
@@ -12,4 +12,20 @@ vsyscall_sysenter_start:
 	.incbin "arch/i386/kernel/vsyscall-sysenter.so"
 vsyscall_sysenter_end:
 
+#if defined(CONFIG_XEN) && defined(CONFIG_COMPAT_VDSO)
+
+	.align 4
+
+	.globl vdso_rel_int80_start, vdso_rel_int80_end
+vdso_rel_int80_start:
+	.include "arch/i386/kernel/vsyscall-int80.rel"
+vdso_rel_int80_end:
+
+	.globl vdso_rel_sysenter_start, vdso_rel_sysenter_end
+vdso_rel_sysenter_start:
+	.include "arch/i386/kernel/vsyscall-sysenter.rel"
+vdso_rel_sysenter_end:
+
+#endif
+
 __FINIT
Index: head-2007-02-08/arch/x86_64/kernel/entry-xen.S
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/entry-xen.S	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/entry-xen.S	2007-02-09 10:13:18.000000000 +0100
@@ -116,19 +116,21 @@ NMI_MASK = 0x80000000
 	CFI_ADJUST_CFA_OFFSET	-(6*8)
 	.endm
 
-	.macro	CFI_DEFAULT_STACK start=1
+	.macro	CFI_DEFAULT_STACK start=1,adj=0
 	.if \start
 	CFI_STARTPROC	simple
-	CFI_DEF_CFA	rsp,SS+8
+	CFI_DEF_CFA	rsp,SS+8-(\adj*ARGOFFSET)
 	.else
-	CFI_DEF_CFA_OFFSET SS+8
+	CFI_DEF_CFA_OFFSET SS+8-(\adj*ARGOFFSET)
 	.endif
+	.if \adj == 0
 	CFI_REL_OFFSET	r15,R15
 	CFI_REL_OFFSET	r14,R14
 	CFI_REL_OFFSET	r13,R13
 	CFI_REL_OFFSET	r12,R12
 	CFI_REL_OFFSET	rbp,RBP
 	CFI_REL_OFFSET	rbx,RBX
+	.endif
 	CFI_REL_OFFSET	r11,R11
 	CFI_REL_OFFSET	r10,R10
 	CFI_REL_OFFSET	r9,R9
@@ -363,8 +365,8 @@ ENTRY(int_ret_from_sys_call)
 	CFI_REL_OFFSET	r9,R9-ARGOFFSET
 	CFI_REL_OFFSET	r10,R10-ARGOFFSET
 	CFI_REL_OFFSET	r11,R11-ARGOFFSET
-	TRACE_IRQS_OFF
         XEN_BLOCK_EVENTS(%rsi)
+	TRACE_IRQS_OFF
 	testb $3,CS-ARGOFFSET(%rsp)
         jnz 1f
         /* Need to set the proper %ss (not NULL) for ring 3 iretq */
@@ -534,7 +536,7 @@ END(stub_rt_sigreturn)
  */ 
 
 retint_check:
-	CFI_DEFAULT_STACK
+	CFI_DEFAULT_STACK adj=1
 	movl threadinfo_flags(%rcx),%edx
 	andl %edi,%edx
 	CFI_REMEMBER_STATE
@@ -838,6 +840,7 @@ ENTRY(error_entry)
 	CFI_REL_OFFSET	r15,R15
 #if 0        
 	cmpl $__KERNEL_CS,CS(%rsp)
+	CFI_REMEMBER_STATE
 	je  error_kernelspace
 #endif        
 error_call_handler:
@@ -864,7 +867,7 @@ error_exit:		
 	TRACE_IRQS_IRETQ
 	jmp   retint_restore_args
 
-error_kernelspace:
+#if 0
          /*
          * We need to re-write the logic here because we don't do iretq to 
          * to return to user mode. It's still possible that we get trap/fault
@@ -872,7 +875,8 @@ error_kernelspace:
          * for example).
          *
          */           
-#if 0
+	CFI_RESTORE_STATE
+error_kernelspace:
 	incl %ebx
        /* There are two places in the kernel that can potentially fault with
           usergs. Handle them here. The exception handlers after
@@ -888,11 +892,13 @@ error_kernelspace:
 	cmpq $gs_change,RIP(%rsp)
         je   error_swapgs
 	jmp  error_sti
-#endif        
+#endif
+	CFI_ENDPROC
 END(error_entry)
 	
 ENTRY(hypervisor_callback)
 	zeroentry do_hypervisor_callback
+END(hypervisor_callback)
         
 /*
  * Copied from arch/xen/i386/kernel/entry.S
@@ -920,37 +926,47 @@ ENTRY(do_hypervisor_callback)   # do_hyp
 	popq %rsp
 	decl %gs:pda_irqcount
 	jmp  error_exit
+END(do_hypervisor_callback)
 
 #ifdef CONFIG_X86_LOCAL_APIC
 KPROBE_ENTRY(nmi)
 	zeroentry do_nmi_callback
 ENTRY(do_nmi_callback)
+	CFI_STARTPROC
         addq $8, %rsp
+	CFI_DEFAULT_STACK start=0,adj=1
         call do_nmi
         orl  $NMI_MASK,EFLAGS(%rsp)
         RESTORE_REST
         XEN_BLOCK_EVENTS(%rsi)
         GET_THREAD_INFO(%rcx)
         jmp  retint_restore_args
+	CFI_ENDPROC
 	.previous .text
+END(nmi)
 #endif
 
         ALIGN
 restore_all_enable_events:  
+	CFI_DEFAULT_STACK adj=1
+	TRACE_IRQS_ON
 	XEN_UNBLOCK_EVENTS(%rsi)        # %rsi is already set up...
 
 scrit:	/**** START OF CRITICAL REGION ****/
 	XEN_TEST_PENDING(%rsi)
+	CFI_REMEMBER_STATE
 	jnz  14f			# process more events if necessary...
 	XEN_PUT_VCPU_INFO(%rsi)
         RESTORE_ARGS 0,8,0
         HYPERVISOR_IRET 0
         
+	CFI_RESTORE_STATE
 14:	XEN_LOCKED_BLOCK_EVENTS(%rsi)
 	XEN_PUT_VCPU_INFO(%rsi)
 	SAVE_REST
         movq %rsp,%rdi                  # set the argument again
 	jmp  11b
+	CFI_ENDPROC
 ecrit:  /**** END OF CRITICAL REGION ****/
 # At this point, unlike on x86-32, we don't do the fixup to simplify the 
 # code and the stack frame is more complex on x86-64.
@@ -970,8 +986,12 @@ ecrit:  /**** END OF CRITICAL REGION ***
 # We distinguish between categories by comparing each saved segment register
 # with its current contents: any discrepancy means we in category 1.
 ENTRY(failsafe_callback)
+	_frame (RIP-0x30)
+	CFI_REL_OFFSET rcx, 0
+	CFI_REL_OFFSET r11, 8
 	movw %ds,%cx
 	cmpw %cx,0x10(%rsp)
+	CFI_REMEMBER_STATE
 	jne 1f
 	movw %es,%cx
 	cmpw %cx,0x18(%rsp)
@@ -984,17 +1004,26 @@ ENTRY(failsafe_callback)
 	jne 1f
 	/* All segments match their saved values => Category 2 (Bad IRET). */
 	movq (%rsp),%rcx
+	CFI_RESTORE rcx
 	movq 8(%rsp),%r11
+	CFI_RESTORE r11
 	addq $0x30,%rsp
+	CFI_ADJUST_CFA_OFFSET -0x30
 	movq $11,%rdi	/* SIGSEGV */
 	jmp do_exit			
+	CFI_RESTORE_STATE
 1:	/* Segment mismatch => Category 1 (Bad segment). Retry the IRET. */
 	movq (%rsp),%rcx
+	CFI_RESTORE rcx
 	movq 8(%rsp),%r11
+	CFI_RESTORE r11
 	addq $0x30,%rsp
+	CFI_ADJUST_CFA_OFFSET -0x30
 	pushq $0
+	CFI_ADJUST_CFA_OFFSET 8
 	SAVE_ALL
 	jmp error_exit
+	CFI_ENDPROC
 #if 0	      
         .section __ex_table,"a"
         .align 8
@@ -1117,12 +1146,12 @@ END(device_not_available)
 
 	/* runs on exception stack */
 KPROBE_ENTRY(debug)
- 	INTR_FRAME
-/*	pushq $0
+/* 	INTR_FRAME
+	pushq $0
 	CFI_ADJUST_CFA_OFFSET 8	*/
 	zeroentry do_debug
-/*	paranoid_exit */
-	CFI_ENDPROC
+/*	paranoidexit
+	CFI_ENDPROC */
 END(debug)
 	.previous .text
 
@@ -1144,12 +1173,12 @@ END(nmi)
 #endif        
 
 KPROBE_ENTRY(int3)
- 	INTR_FRAME
-/* 	pushq $0
+/* 	INTR_FRAME
+ 	pushq $0
  	CFI_ADJUST_CFA_OFFSET 8 */
  	zeroentry do_int3
-/* 	jmp paranoid_exit1 */
- 	CFI_ENDPROC
+/* 	jmp paranoid_exit1
+ 	CFI_ENDPROC */
 END(int3)
 	.previous .text
 
@@ -1193,9 +1222,11 @@ END(segment_not_present)
 
 	/* runs on exception stack */
 ENTRY(stack_segment)
-	XCPT_FRAME
+/*	XCPT_FRAME
+	paranoidentry do_stack_segment */
 	errorentry do_stack_segment
-	CFI_ENDPROC
+/*	jmp paranoid_exit1
+	CFI_ENDPROC */
 END(stack_segment)
 
 KPROBE_ENTRY(general_protection)
Index: head-2007-02-08/arch/x86_64/kernel/genapic_xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/genapic_xen.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/genapic_xen.c	2007-02-09 10:13:18.000000000 +0100
@@ -10,7 +10,6 @@
  *
  * Hacked to pieces for Xen by Chris Wright.
  */
-#include <linux/config.h>
 #include <linux/threads.h>
 #include <linux/cpumask.h>
 #include <linux/string.h>
Index: head-2007-02-08/arch/x86_64/kernel/head-xen.S
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/head-xen.S	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/head-xen.S	2007-02-09 10:13:18.000000000 +0100
@@ -40,6 +40,7 @@ ENTRY(_start)
 	/* rsi is pointer to startup info structure.
 	   pass it to C */
 	movq %rsi,%rdi
+	pushq $0		# fake return address
 	jmp x86_64_start_kernel
 
 ENTRY(stext)
Index: head-2007-02-08/arch/x86_64/kernel/init_task.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/init_task.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/init_task.c	2007-02-09 10:13:18.000000000 +0100
@@ -47,11 +47,11 @@ EXPORT_SYMBOL(init_task);
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */ 
 DEFINE_PER_CPU(struct tss_struct, init_tss) ____cacheline_internodealigned_in_smp = INIT_TSS;
-#endif
 
 /* Copies of the original ist values from the tss are only accessed during
  * debugging, no special alignment required.
  */
 DEFINE_PER_CPU(struct orig_ist, orig_ist);
+#endif
 
 #define ALIGN_TO_4K __attribute__((section(".data.init_task")))
Index: head-2007-02-08/arch/x86_64/kernel/io_apic-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/io_apic-xen.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/io_apic-xen.c	2007-02-09 10:13:18.000000000 +0100
@@ -58,7 +58,6 @@ static struct { int pin, apic; } ioapic_
 #endif
 
 static DEFINE_SPINLOCK(ioapic_lock);
-static DEFINE_SPINLOCK(vector_lock);
 
 /*
  * # of IRQ routing registers
@@ -888,33 +887,22 @@ u8 irq_vector[NR_IRQ_VECTORS] __read_mos
 
 int assign_irq_vector(int irq)
 {
-	unsigned long flags;
-	int vector;
 	struct physdev_irq irq_op;
   
   	BUG_ON(irq != AUTO_ASSIGN && (unsigned)irq >= NR_IRQ_VECTORS);
 
-	spin_lock_irqsave(&vector_lock, flags);
-
-  	if (irq != AUTO_ASSIGN && IO_APIC_VECTOR(irq) > 0) {
-		spin_unlock_irqrestore(&vector_lock, flags);
+  	if (irq != AUTO_ASSIGN && IO_APIC_VECTOR(irq) > 0)
   		return IO_APIC_VECTOR(irq);
-	}
 
 	irq_op.irq = irq;
-	if (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op)) {
-		spin_unlock_irqrestore(&vector_lock, flags);
+	if (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op))
 		return -ENOSPC;
-	}
 
-	vector = irq_op.vector;
-	vector_irq[vector] = irq;
+	vector_irq[irq_op.vector] = irq;
 	if (irq != AUTO_ASSIGN)
-		IO_APIC_VECTOR(irq) = vector;
-
-	spin_unlock_irqrestore(&vector_lock, flags);
+		IO_APIC_VECTOR(irq) = irq_op.vector;
 
-	return vector;
+	return irq_op.vector;
 }
 
 extern void (*interrupt[NR_IRQS])(void);
Index: head-2007-02-08/arch/x86_64/kernel/pci-nommu.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/pci-nommu.c	2007-02-04 19:44:54.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/pci-nommu.c	2007-02-09 10:13:18.000000000 +0100
@@ -92,6 +92,8 @@ void __init no_iommu_init(void)
 	if (dma_ops)
 		return;
 
+#ifndef CONFIG_XEN
 	force_iommu = 0; /* no HW IOMMU */
+#endif
 	dma_ops = &nommu_dma_ops;
 }
Index: head-2007-02-08/arch/x86_64/kernel/setup-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/setup-xen.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/setup-xen.c	2007-02-09 10:13:18.000000000 +0100
@@ -695,6 +695,14 @@ void __init setup_arch(char **cmdline_p)
 	contig_initmem_init(0, end_pfn);
 #endif
 
+#ifdef CONFIG_XEN
+	/*
+	 * Reserve kernel, physmap, start info, initial page tables, and
+	 * direct mapping.
+	 */
+	reserve_bootmem_generic(__pa_symbol(&_text),
+	                        (table_end << PAGE_SHIFT) - __pa_symbol(&_text));
+#else
 	/* Reserve direct mapping */
 	reserve_bootmem_generic(table_start << PAGE_SHIFT, 
 				(table_end - table_start) << PAGE_SHIFT);
@@ -703,12 +711,6 @@ void __init setup_arch(char **cmdline_p)
 	reserve_bootmem_generic(__pa_symbol(&_text),
 				__pa_symbol(&_end) - __pa_symbol(&_text));
 
-#ifdef CONFIG_XEN
-	/* reserve physmap, start info and initial page tables */
-	reserve_bootmem_generic(__pa_symbol(&_end),
-				(table_start << PAGE_SHIFT) -
-				__pa_symbol(&_end));
-#else
 	/*
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
 	 * enabling clean reboots, SMP operation, laptop functions.
Index: head-2007-02-08/arch/x86_64/kernel/x8664_ksyms-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/x8664_ksyms-xen.c	2007-02-09 16:11:13.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,60 +0,0 @@
-/* Exports for assembly files.
-   All C exports should go in the respective C files. */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/smp.h>
-
-#include <asm/semaphore.h>
-#include <asm/processor.h>
-#include <asm/uaccess.h>
-#include <asm/pgtable.h>
-
-EXPORT_SYMBOL(kernel_thread);
-
-EXPORT_SYMBOL(__down_failed);
-EXPORT_SYMBOL(__down_failed_interruptible);
-EXPORT_SYMBOL(__down_failed_trylock);
-EXPORT_SYMBOL(__up_wakeup);
-
-EXPORT_SYMBOL(__get_user_1);
-EXPORT_SYMBOL(__get_user_2);
-EXPORT_SYMBOL(__get_user_4);
-EXPORT_SYMBOL(__get_user_8);
-EXPORT_SYMBOL(__put_user_1);
-EXPORT_SYMBOL(__put_user_2);
-EXPORT_SYMBOL(__put_user_4);
-EXPORT_SYMBOL(__put_user_8);
-
-EXPORT_SYMBOL(copy_user_generic);
-EXPORT_SYMBOL(copy_from_user);
-EXPORT_SYMBOL(copy_to_user);
-
-EXPORT_SYMBOL(copy_page);
-EXPORT_SYMBOL(clear_page);
-
-#ifdef CONFIG_SMP
-extern void FASTCALL( __write_lock_failed(rwlock_t *rw));
-extern void FASTCALL( __read_lock_failed(rwlock_t *rw));
-EXPORT_SYMBOL(__write_lock_failed);
-EXPORT_SYMBOL(__read_lock_failed);
-#endif
-
-/* Export string functions. We normally rely on gcc builtin for most of these,
-   but gcc sometimes decides not to inline them. */    
-#undef memcpy
-#undef memset
-#undef memmove
-
-extern void * memset(void *,int,__kernel_size_t);
-extern void * memcpy(void *,const void *,__kernel_size_t);
-extern void * __memcpy(void *,const void *,__kernel_size_t);
-
-EXPORT_SYMBOL(memset);
-EXPORT_SYMBOL(memcpy);
-EXPORT_SYMBOL(__memcpy);
-
-EXPORT_SYMBOL(empty_zero_page);
-
-EXPORT_SYMBOL(load_gs_index);
-
Index: head-2007-02-08/arch/x86_64/mm/init-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/mm/init-xen.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/mm/init-xen.c	2007-02-09 10:13:18.000000000 +0100
@@ -384,7 +384,7 @@ unsigned long __initdata table_start, ta
 
 unsigned long get_machine_pfn(unsigned long addr)
 {
-	pud_t* pud = pud_offset_k(NULL, addr);
+	pud_t* pud = pud_offset(pgd_offset_k(addr), addr);
 	pmd_t* pmd = pmd_offset(pud, addr);
 	pte_t *pte = pte_offset_kernel(pmd, addr);
 
@@ -1076,11 +1076,6 @@ void __init mem_init(void)
 
 void free_init_pages(char *what, unsigned long begin, unsigned long end)
 {
-#ifdef __DO_LATER__
-	/*
-	 * Some pages can be pinned, but some are not. Unpinning such pages 
-	 * triggers BUG(). 
-	 */
 	unsigned long addr;
 
 	if (begin >= end)
@@ -1102,18 +1097,21 @@ void free_init_pages(char *what, unsigne
 		free_page(addr);
 		totalram_pages++;
 	}
-#endif
 }
 
 void free_initmem(void)
 {
-#ifdef __DO_LATER__
 	memset(__initdata_begin, POISON_FREE_INITDATA,
 		__initdata_end - __initdata_begin);
-#endif
+#ifdef __DO_LATER__
+	/*
+	 * Some pages can be pinned, but some are not. Unpinning such pages
+	 * triggers BUG().
+	 */
 	free_init_pages("unused kernel memory",
 			(unsigned long)(&__init_begin),
 			(unsigned long)(&__init_end));
+#endif
 }
 
 #ifdef CONFIG_DEBUG_RODATA
@@ -1173,7 +1171,7 @@ int kern_addr_valid(unsigned long addr) 
 	if (pgd_none(*pgd))
 		return 0;
 
-	pud = pud_offset_k(pgd, addr);
+	pud = pud_offset(pgd, addr);
 	if (pud_none(*pud))
 		return 0; 
 
Index: head-2007-02-08/drivers/char/mem.c
===================================================================
--- head-2007-02-08.orig/drivers/char/mem.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/char/mem.c	2007-02-09 10:13:18.000000000 +0100
@@ -822,7 +822,7 @@ static const struct file_operations mem_
 	.get_unmapped_area = get_unmapped_area_mem,
 };
 #else
-extern struct file_operations mem_fops;
+extern const struct file_operations mem_fops;
 #endif
 
 static const struct file_operations kmem_fops = {
Index: head-2007-02-08/drivers/xen/blktap/blktap.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/blktap/blktap.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/blktap/blktap.c	2007-02-09 10:13:18.000000000 +0100
@@ -335,7 +335,7 @@ static int blktap_ioctl(struct inode *in
                         unsigned int cmd, unsigned long arg);
 static unsigned int blktap_poll(struct file *file, poll_table *wait);
 
-static struct file_operations blktap_fops = {
+static const struct file_operations blktap_fops = {
 	.owner   = THIS_MODULE,
 	.poll    = blktap_poll,
 	.ioctl   = blktap_ioctl,
Index: head-2007-02-08/drivers/xen/char/mem.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/char/mem.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/char/mem.c	2007-02-09 10:13:18.000000000 +0100
@@ -8,7 +8,6 @@
  *  Shared /dev/zero mmaping support, Feb 2000, Kanoj Sarcar <kanoj@sgi.com>
  */
 
-#include <linux/config.h>
 #include <linux/mm.h>
 #include <linux/miscdevice.h>
 #include <linux/slab.h>
@@ -195,7 +194,7 @@ static int open_mem(struct inode * inode
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
 
-struct file_operations mem_fops = {
+const struct file_operations mem_fops = {
 	.llseek		= memory_lseek,
 	.read		= read_mem,
 	.write		= write_mem,
Index: head-2007-02-08/drivers/xen/evtchn/evtchn.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/evtchn/evtchn.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/evtchn/evtchn.c	2007-02-09 10:13:18.000000000 +0100
@@ -407,7 +407,7 @@ static int evtchn_release(struct inode *
 	return 0;
 }
 
-static struct file_operations evtchn_fops = {
+static const struct file_operations evtchn_fops = {
 	.owner   = THIS_MODULE,
 	.read    = evtchn_read,
 	.write   = evtchn_write,
Index: head-2007-02-08/drivers/xen/pcifront/pci_op.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/pcifront/pci_op.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/pcifront/pci_op.c	2007-02-09 10:13:18.000000000 +0100
@@ -239,17 +239,17 @@ static void free_root_bus_devs(struct pc
 {
 	struct pci_dev *dev;
 
-	down_write(&pci_bus_sem);
+	down_read(&pci_bus_sem);
 	while (!list_empty(&bus->devices)) {
 		dev = container_of(bus->devices.next, struct pci_dev, bus_list);
-		up_write(&pci_bus_sem);
+		up_read(&pci_bus_sem);
 
 		dev_dbg(&dev->dev, "removing device\n");
 		pci_remove_bus_device(dev);
 
-		down_write(&pci_bus_sem);
+		down_read(&pci_bus_sem);
 	}
-	up_write(&pci_bus_sem);
+	up_read(&pci_bus_sem);
 }
 
 void pcifront_free_roots(struct pcifront_device *pdev)
Index: head-2007-02-08/drivers/xen/privcmd/privcmd.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/privcmd/privcmd.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/privcmd/privcmd.c	2007-02-09 10:13:18.000000000 +0100
@@ -249,7 +249,7 @@ static int privcmd_enforce_singleshot_ma
 }
 #endif
 
-static struct file_operations privcmd_file_ops = {
+static const struct file_operations privcmd_file_ops = {
 	.ioctl = privcmd_ioctl,
 	.mmap  = privcmd_mmap,
 };
Index: head-2007-02-08/drivers/xen/tpmback/tpmback.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/tpmback/tpmback.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/tpmback/tpmback.c	2007-02-09 10:13:18.000000000 +0100
@@ -629,7 +629,7 @@ static unsigned int vtpm_op_poll(struct 
 	return flags;
 }
 
-static struct file_operations vtpm_ops = {
+static const struct file_operations vtpm_ops = {
 	.owner = THIS_MODULE,
 	.llseek = no_llseek,
 	.open = vtpm_op_open,
Index: head-2007-02-08/drivers/xen/xenbus/xenbus_dev.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/xenbus/xenbus_dev.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/xenbus/xenbus_dev.c	2007-02-09 10:13:18.000000000 +0100
@@ -343,7 +343,7 @@ static unsigned int xenbus_dev_poll(stru
 	return 0;
 }
 
-static struct file_operations xenbus_dev_file_ops = {
+static const struct file_operations xenbus_dev_file_ops = {
 	.read = xenbus_dev_read,
 	.write = xenbus_dev_write,
 	.open = xenbus_dev_open,
Index: head-2007-02-08/fs/aio.c
===================================================================
--- head-2007-02-08.orig/fs/aio.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/fs/aio.c	2007-02-09 10:13:18.000000000 +0100
@@ -1280,7 +1280,7 @@ static unsigned int aio_queue_fd_poll(st
 	return pollflags;
 }
 
-static struct file_operations aioq_fops = {
+static const struct file_operations aioq_fops = {
 	.release	= aio_queue_fd_close,
 	.poll		= aio_queue_fd_poll
 };
Index: head-2007-02-08/fs/eventpoll.c
===================================================================
--- head-2007-02-08.orig/fs/eventpoll.c	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/fs/eventpoll.c	2007-02-09 10:13:18.000000000 +0100
@@ -267,7 +267,7 @@ static int ep_events_transfer(struct eve
 static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
 		   int maxevents, long timeout);
 static int eventpollfs_delete_dentry(struct dentry *dentry);
-static struct inode *ep_eventpoll_inode(struct file_operations *fops);
+static struct inode *ep_eventpoll_inode(const struct file_operations *fops);
 static int eventpollfs_get_sb(struct file_system_type *fs_type,
 			      int flags, const char *dev_name,
 			      void *data, struct vfsmount *mnt);
@@ -751,7 +751,7 @@ asmlinkage long sys_epoll_pwait(int epfd
  * Creates the file descriptor to be used by the epoll interface.
  */
 int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-		    struct eventpoll *ep, struct file_operations *fops)
+		    struct eventpoll *ep, const struct file_operations *fops)
 {
 	struct qstr this;
 	char name[32];
@@ -1618,7 +1618,7 @@ static int eventpollfs_delete_dentry(str
 }
 
 
-static struct inode *ep_eventpoll_inode(struct file_operations *fops)
+static struct inode *ep_eventpoll_inode(const struct file_operations *fops)
 {
 	int error = -ENOMEM;
 	struct inode *inode = new_inode(eventpoll_mnt->mnt_sb);
Index: head-2007-02-08/include/asm-i386/elf.h
===================================================================
--- head-2007-02-08.orig/include/asm-i386/elf.h	2007-02-04 19:44:54.000000000 +0100
+++ head-2007-02-08/include/asm-i386/elf.h	2007-02-09 10:13:18.000000000 +0100
@@ -137,7 +137,11 @@ extern int dump_task_extended_fpu (struc
 
 #ifdef CONFIG_COMPAT_VDSO
 # define VDSO_COMPAT_BASE	VDSO_HIGH_BASE
-# define VDSO_PRELINK		VDSO_HIGH_BASE
+# ifndef CONFIG_XEN
+#  define VDSO_PRELINK		VDSO_HIGH_BASE
+# else
+#  define VDSO_PRELINK		(0UL - FIX_VDSO * PAGE_SIZE)
+# endif
 #else
 # define VDSO_COMPAT_BASE	VDSO_BASE
 # define VDSO_PRELINK		0
Index: head-2007-02-08/include/asm-i386/mach-xen/asm/irqflags.h
===================================================================
--- head-2007-02-08.orig/include/asm-i386/mach-xen/asm/irqflags.h	2007-02-09 16:11:07.000000000 +0100
+++ head-2007-02-08/include/asm-i386/mach-xen/asm/irqflags.h	2007-02-09 16:11:50.000000000 +0100
@@ -27,7 +27,7 @@
  */
 
 #define __raw_local_save_flags()					\
-	(&HYPERVISOR_shared_info->vcpu_info[__vcpu_id])->evtchn_upcall_mask;
+	((&HYPERVISOR_shared_info->vcpu_info[__vcpu_id])->evtchn_upcall_mask)
 
 #define raw_local_save_flags(flags) \
 		do { (flags) = __raw_local_save_flags(); } while (0)
Index: head-2007-02-08/include/asm-i386/mach-xen/asm/page.h
===================================================================
--- head-2007-02-08.orig/include/asm-i386/mach-xen/asm/page.h	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/include/asm-i386/mach-xen/asm/page.h	2007-02-09 10:13:18.000000000 +0100
@@ -208,8 +208,6 @@ extern int page_is_ram(unsigned long pag
 	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
 		 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define __HAVE_ARCH_GATE_AREA 1
-
 #include <asm-generic/memory_model.h>
 #include <asm-generic/page.h>
 
Index: head-2007-02-08/include/asm-i386/mach-xen/asm/processor.h
===================================================================
--- head-2007-02-08.orig/include/asm-i386/mach-xen/asm/processor.h	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/include/asm-i386/mach-xen/asm/processor.h	2007-02-09 11:35:42.000000000 +0100
@@ -23,7 +23,7 @@
 #include <xen/interface/physdev.h>
 
 /* flag for disabling the tsc */
-extern int tsc_disable;
+#define tsc_disable 0
 
 struct desc_struct {
 	unsigned long a,b;
Index: head-2007-02-08/include/asm-i386/mach-xen/asm/system.h
===================================================================
--- head-2007-02-08.orig/include/asm-i386/mach-xen/asm/system.h	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/include/asm-i386/mach-xen/asm/system.h	2007-02-09 10:13:18.000000000 +0100
@@ -138,7 +138,7 @@ __asm__ __volatile__ ("movw %%dx,%1\n\t"
 })
 
 #define write_cr4(x) \
-	__asm__ __volatile__("movl %0,%%cr4": :"r" (x));
+	__asm__ __volatile__("movl %0,%%cr4": :"r" (x))
 
 /*
  * Clear and set 'TS' bit respectively
Index: head-2007-02-08/include/asm-i386/thread_info.h
===================================================================
--- head-2007-02-08.orig/include/asm-i386/thread_info.h	2007-02-04 19:44:54.000000000 +0100
+++ head-2007-02-08/include/asm-i386/thread_info.h	2007-02-09 10:13:18.000000000 +0100
@@ -158,7 +158,11 @@ static inline struct thread_info *curren
 #define _TIF_ALLWORK_MASK	(0x0000FFFF & ~_TIF_SECCOMP)
 
 /* flags to check in __switch_to() */
+#ifndef CONFIG_XEN
 #define _TIF_WORK_CTXSW (_TIF_DEBUG|_TIF_IO_BITMAP)
+#else
+#define _TIF_WORK_CTXSW _TIF_DEBUG
+#endif
 
 /*
  * Thread-synchronous status.
Index: head-2007-02-08/include/asm-x86_64/mach-xen/asm/irqflags.h
===================================================================
--- head-2007-02-08.orig/include/asm-x86_64/mach-xen/asm/irqflags.h	2007-02-08 13:09:55.000000000 +0100
+++ head-2007-02-08/include/asm-x86_64/mach-xen/asm/irqflags.h	2007-02-09 16:12:04.000000000 +0100
@@ -30,7 +30,7 @@
  */
 
 #define __raw_local_save_flags()					\
-	(&HYPERVISOR_shared_info->vcpu_info[__vcpu_id])->evtchn_upcall_mask;
+	((&HYPERVISOR_shared_info->vcpu_info[__vcpu_id])->evtchn_upcall_mask)
 
 #define raw_local_save_flags(flags) \
 		do { (flags) = __raw_local_save_flags(); } while (0)
Index: head-2007-02-08/include/asm-x86_64/mach-xen/asm/pgtable.h
===================================================================
--- head-2007-02-08.orig/include/asm-x86_64/mach-xen/asm/pgtable.h	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/include/asm-x86_64/mach-xen/asm/pgtable.h	2007-02-09 10:13:18.000000000 +0100
@@ -402,19 +402,6 @@ static inline int pmd_large(pmd_t pte) {
 /* to find an entry in a page-table-directory. */
 #define pud_index(address) (((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
 #define pud_offset(pgd, address) ((pud_t *) pgd_page(*(pgd)) + pud_index(address))
-static inline pud_t *__pud_offset_k(pud_t *pud, unsigned long address)
-{ 
-	return pud + pud_index(address);
-} 
-
-/* Find correct pud via the hidden fourth level page level: */
-
-/* This accesses the reference page table of the boot cpu. 
-   Other CPUs get synced lazily via the page fault handler. */
-static inline pud_t *pud_offset_k(pgd_t *pgd, unsigned long address)
-{
-	return pud_offset(pgd_offset_k(address), address);
-}
 
 /* PMD  - Level 2 access */
 #define pmd_page_kernel(pmd) ((unsigned long) __va(pmd_val(pmd) & PTE_MASK))
Index: head-2007-02-08/include/asm-x86_64/mach-xen/asm/processor.h
===================================================================
--- head-2007-02-08.orig/include/asm-x86_64/mach-xen/asm/processor.h	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/include/asm-x86_64/mach-xen/asm/processor.h	2007-02-09 10:13:18.000000000 +0100
@@ -246,11 +246,13 @@ DECLARE_PER_CPU(struct tss_struct,init_t
 
 
 extern struct cpuinfo_x86 boot_cpu_data;
+#ifndef CONFIG_X86_NO_TSS
 /* Save the original ist values for checking stack pointers during debugging */
 struct orig_ist {
 	unsigned long ist[7];
 };
 DECLARE_PER_CPU(struct orig_ist, orig_ist);
+#endif
 
 #ifdef CONFIG_X86_VSMP
 #define ARCH_MIN_TASKALIGN	(1 << INTERNODE_CACHE_SHIFT)
Index: head-2007-02-08/include/asm-x86_64/mach-xen/asm/timer.h
===================================================================
--- head-2007-02-08.orig/include/asm-x86_64/mach-xen/asm/timer.h	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/include/asm-x86_64/mach-xen/asm/timer.h	2007-02-09 10:13:18.000000000 +0100
@@ -16,25 +16,9 @@
  *                   timer.
  * @delay: delays this many clock cycles.
  */
-struct timer_opts {
-	char* name;
-	void (*mark_offset)(void);
-	unsigned long (*get_offset)(void);
-	unsigned long long (*monotonic_clock)(void);
-	void (*delay)(unsigned long);
-	unsigned long (*read_timer)(void);
-	int (*suspend)(pm_message_t state);
-	int (*resume)(void);
-};
-
-struct init_timer_opts {
-	int (*init)(char *override);
-	struct timer_opts *opts;
-};
 
 #define TICK_SIZE (tick_nsec / 1000)
 
-extern struct timer_opts* __init select_timer(void);
 extern void clock_fallback(void);
 void setup_pit_timer(void);
 
@@ -42,26 +26,13 @@ void setup_pit_timer(void);
 
 extern int pit_latch_buggy;
 
-extern struct timer_opts *cur_timer;
 extern int timer_ack;
 
 /* list of externed timers */
-extern struct timer_opts timer_none;
-extern struct timer_opts timer_pit;
-extern struct init_timer_opts timer_pit_init;
-extern struct init_timer_opts timer_tsc_init;
-#ifdef CONFIG_X86_CYCLONE_TIMER
-extern struct init_timer_opts timer_cyclone_init;
-#endif
-
 extern unsigned long calibrate_tsc(void);
 extern void init_cpu_khz(void);
 #ifdef CONFIG_HPET_TIMER
-extern struct init_timer_opts timer_hpet_init;
 extern unsigned long calibrate_tsc_hpet(unsigned long *tsc_hpet_quotient_ptr);
 #endif
 
-#ifdef CONFIG_X86_PM_TIMER
-extern struct init_timer_opts timer_pmtmr_init;
-#endif
 #endif
Index: head-2007-02-08/include/linux/eventpoll.h
===================================================================
--- head-2007-02-08.orig/include/linux/eventpoll.h	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/include/linux/eventpoll.h	2007-02-09 10:13:18.000000000 +0100
@@ -95,7 +95,7 @@ static inline void eventpoll_release(str
  */
 struct eventpoll;
 int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-             struct eventpoll *ep, struct file_operations *fops);
+             struct eventpoll *ep, const struct file_operations *fops);
 #else
 
 static inline void eventpoll_init_file(struct file *file) {}
Index: head-2007-02-08/arch/x86_64/Kconfig
===================================================================
--- head-2007-02-08.orig/arch/x86_64/Kconfig	2007-02-09 16:11:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/Kconfig	2007-02-09 10:14:08.000000000 +0100
@@ -490,7 +490,7 @@ config IOMMU
 config CALGARY_IOMMU
 	bool "IBM Calgary IOMMU support"
 	select SWIOTLB
-	depends on PCI && EXPERIMENTAL
+	depends on PCI && !X86_64_XEN && EXPERIMENTAL
 	help
 	  Support for hardware IOMMUs in IBM's xSeries x366 and x460
 	  systems. Needed to run systems with more than 3GB of memory
