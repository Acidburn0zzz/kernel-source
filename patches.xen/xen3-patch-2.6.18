From: www.kernel.org
Subject: Linux 2.6.18
Patch-mainline: 2.6.18

Automatically created from "patches.kernel.org/patch-2.6.18" by xen-port-patches.py

Acked-by: jbeulich@novell.com

Index: head-2007-05-31/arch/i386/Kconfig
===================================================================
--- head-2007-05-31.orig/arch/i386/Kconfig	2007-06-04 13:43:03.000000000 +0200
+++ head-2007-05-31/arch/i386/Kconfig	2007-05-31 14:39:30.000000000 +0200
@@ -16,7 +16,6 @@ config X86_32
 
 config GENERIC_TIME
 	bool
-	depends on !X86_XEN
 	default y
 
 config CLOCKSOURCE_WATCHDOG
Index: head-2007-05-31/arch/i386/kernel/Makefile
===================================================================
--- head-2007-05-31.orig/arch/i386/kernel/Makefile	2007-06-04 13:43:03.000000000 +0200
+++ head-2007-05-31/arch/i386/kernel/Makefile	2007-05-31 14:39:30.000000000 +0200
@@ -97,7 +97,7 @@ include $(srctree)/scripts/Makefile.xen
 
 obj-y += fixup.o
 microcode-$(subst m,y,$(CONFIG_MICROCODE)) := microcode-xen.o
-n-obj-xen := i8259.o timers/ reboot.o smpboot.o trampoline.o
+n-obj-xen := i8253.o i8259.o reboot.o smpboot.o trampoline.o tsc.o
 
 obj-y := $(call filterxen, $(obj-y), $(n-obj-xen))
 obj-y := $(call cherrypickxen, $(obj-y))
Index: head-2007-05-31/arch/i386/kernel/time-xen.c
===================================================================
--- head-2007-05-31.orig/arch/i386/kernel/time-xen.c	2007-06-04 13:43:03.000000000 +0200
+++ head-2007-05-31/arch/i386/kernel/time-xen.c	2007-05-31 14:39:30.000000000 +0200
@@ -75,8 +75,13 @@
 
 #if defined (__i386__)
 #include <asm/i8259.h>
+#include <asm/i8253.h>
+DEFINE_SPINLOCK(i8253_lock);
+EXPORT_SYMBOL(i8253_lock);
 #endif
 
+#define XEN_SHIFT 22
+
 int pit_latch_buggy;              /* extern */
 
 #if defined(__x86_64__)
@@ -96,10 +101,6 @@ extern unsigned long wall_jiffies;
 DEFINE_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL(rtc_lock);
 
-extern struct init_timer_opts timer_tsc_init;
-extern struct timer_opts timer_tsc;
-#define timer_none timer_tsc
-
 /* These are peridically updated in shared_info, and then copied here. */
 struct shadow_time_info {
 	u64 tsc_timestamp;     /* TSC at last update of time vals.  */
@@ -238,6 +239,7 @@ static u64 get_nsec_offset(struct shadow
 	return scale_delta(delta, shadow->tsc_to_nsec_mul, shadow->tsc_shift);
 }
 
+#ifdef CONFIG_X86_64
 static unsigned long get_usec_offset(struct shadow_time_info *shadow)
 {
 	u64 now, delta;
@@ -245,6 +247,7 @@ static unsigned long get_usec_offset(str
 	delta = now - shadow->tsc_timestamp;
 	return scale_delta(delta, shadow->tsc_to_usec_mul, shadow->tsc_shift);
 }
+#endif
 
 static void __update_wallclock(time_t sec, long nsec)
 {
@@ -354,6 +357,8 @@ void rtc_cmos_write(unsigned char val, u
 }
 EXPORT_SYMBOL(rtc_cmos_write);
 
+#ifdef CONFIG_X86_64
+
 /*
  * This version of gettimeofday has microsecond resolution
  * and better than microsecond precision on fast x86 machines with TSC.
@@ -482,6 +487,8 @@ int do_settimeofday(struct timespec *tv)
 
 EXPORT_SYMBOL(do_settimeofday);
 
+#endif
+
 static void sync_xen_wallclock(unsigned long dummy);
 static DEFINE_TIMER(sync_xen_wallclock_timer, sync_xen_wallclock, 0, 0);
 static void sync_xen_wallclock(unsigned long dummy)
@@ -533,11 +540,15 @@ static int set_rtc_mmss(unsigned long no
 	return retval;
 }
 
+#ifdef CONFIG_X86_64
 /* monotonic_clock(): returns # of nanoseconds passed since time_init()
  *		Note: This function is required to return accurate
  *		time even in the absence of multiple timer ticks.
  */
 unsigned long long monotonic_clock(void)
+#else
+unsigned long long sched_clock(void)
+#endif
 {
 	int cpu = get_cpu();
 	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
@@ -557,9 +568,9 @@ unsigned long long monotonic_clock(void)
 
 	return time;
 }
+#ifdef CONFIG_X86_64
 EXPORT_SYMBOL(monotonic_clock);
 
-#ifdef __x86_64__
 unsigned long long sched_clock(void)
 {
 	return monotonic_clock();
@@ -728,6 +739,64 @@ irqreturn_t timer_interrupt(int irq, voi
 	return IRQ_HANDLED;
 }
 
+#ifndef CONFIG_X86_64
+
+void tsc_init(void)
+{
+	init_cpu_khz();
+	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
+	       cpu_khz / 1000, cpu_khz % 1000);
+
+	use_tsc_delay();
+}
+
+#include <linux/clocksource.h>
+
+void mark_tsc_unstable(void)
+{
+#ifndef CONFIG_XEN /* XXX Should tell the hypervisor about this fact. */
+	tsc_unstable = 1;
+#endif
+}
+EXPORT_SYMBOL_GPL(mark_tsc_unstable);
+
+static cycle_t xen_clocksource_read(void)
+{
+	int cpu = get_cpu();
+	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
+	cycle_t ret;
+
+	get_time_values_from_xen(cpu);
+
+	ret = shadow->system_timestamp + get_nsec_offset(shadow);
+
+	put_cpu();
+
+	return ret;
+}
+
+static struct clocksource clocksource_xen = {
+	.name			= "xen",
+	.rating			= 400,
+	.read			= xen_clocksource_read,
+	.mask			= CLOCKSOURCE_MASK(64),
+	.mult			= 1 << XEN_SHIFT,		/* time directly in nanoseconds */
+	.shift			= XEN_SHIFT,
+	.is_continuous		= 1,
+};
+
+static int __init init_xen_clocksource(void)
+{
+	clocksource_xen.mult = clocksource_khz2mult(cpu_khz,
+						clocksource_xen.shift);
+
+	return clocksource_register(&clocksource_xen);
+}
+
+module_init(init_xen_clocksource);
+
+#endif
+
 static void init_missing_ticks_accounting(int cpu)
 {
 	struct vcpu_register_runstate_memory_area area;
@@ -935,11 +1004,11 @@ void __init time_init(void)
 
 	update_wallclock();
 
+#ifdef CONFIG_X86_64
 	init_cpu_khz();
 	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
 	       cpu_khz / 1000, cpu_khz % 1000);
 
-#if defined(__x86_64__)
 	vxtime.mode = VXTIME_TSC;
 	vxtime.quot = (1000000L << 32) / vxtime_hz;
 	vxtime.tsc_quot = (1000L << 32) / cpu_khz;
Index: head-2007-05-31/drivers/xen/Kconfig
===================================================================
--- head-2007-05-31.orig/drivers/xen/Kconfig	2007-06-04 13:43:03.000000000 +0200
+++ head-2007-05-31/drivers/xen/Kconfig	2007-06-04 13:48:38.000000000 +0200
@@ -216,6 +216,7 @@ config XEN_DISABLE_SERIAL
 config XEN_SYSFS
 	tristate "Export Xen attributes in sysfs"
 	depends on SYSFS
+	select SYS_HYPERVISOR
 	default y
 	help
 	  Xen hypervisor attributes will show up under /sys/hypervisor/.
Index: head-2007-05-31/drivers/xen/core/Makefile
===================================================================
--- head-2007-05-31.orig/drivers/xen/core/Makefile	2007-06-04 12:50:06.000000000 +0200
+++ head-2007-05-31/drivers/xen/core/Makefile	2007-06-04 13:55:09.000000000 +0200
@@ -5,7 +5,7 @@
 obj-y := evtchn.o gnttab.o features.o reboot.o machine_reboot.o
 
 obj-$(CONFIG_PROC_FS)		+= xen_proc.o
-obj-$(CONFIG_SYSFS)		+= hypervisor_sysfs.o
+obj-$(CONFIG_SYS_HYPERVISOR)	+= hypervisor_sysfs.o
 obj-$(CONFIG_HOTPLUG_CPU)	+= cpu_hotplug.o
 obj-$(CONFIG_XEN_SYSFS)		+= xen_sysfs.o
 obj-$(CONFIG_XEN_SMPBOOT)	+= smpboot.o
Index: head-2007-05-31/drivers/xen/core/hypervisor_sysfs.c
===================================================================
--- head-2007-05-31.orig/drivers/xen/core/hypervisor_sysfs.c	2007-05-31 13:53:45.000000000 +0200
+++ head-2007-05-31/drivers/xen/core/hypervisor_sysfs.c	2007-06-04 13:57:46.000000000 +0200
@@ -12,8 +12,6 @@
 #include <linux/kobject.h>
 #include <xen/hypervisor_sysfs.h>
 
-decl_subsys(hypervisor, NULL, NULL);
-
 static ssize_t hyp_sysfs_show(struct kobject *kobj,
 			      struct attribute *attr,
 			      char *buffer)
@@ -37,7 +35,7 @@ static ssize_t hyp_sysfs_store(struct ko
 	return 0;
 }
 
-struct sysfs_ops hyp_sysfs_ops = {
+static struct sysfs_ops hyp_sysfs_ops = {
 	.show = hyp_sysfs_show,
 	.store = hyp_sysfs_store,
 };
@@ -52,8 +50,7 @@ static int __init hypervisor_subsys_init
 		return -ENODEV;
 
 	hypervisor_subsys.kset.kobj.ktype = &hyp_sysfs_kobj_type;
-	return subsystem_register(&hypervisor_subsys);
+	return 0;
 }
 
 device_initcall(hypervisor_subsys_init);
-EXPORT_SYMBOL_GPL(hypervisor_subsys);
Index: head-2007-05-31/include/asm-i386/mach-xen/asm/processor.h
===================================================================
--- head-2007-05-31.orig/include/asm-i386/mach-xen/asm/processor.h	2007-06-04 13:43:03.000000000 +0200
+++ head-2007-05-31/include/asm-i386/mach-xen/asm/processor.h	2007-05-31 14:39:30.000000000 +0200
@@ -23,7 +23,7 @@
 #include <xen/interface/physdev.h>
 
 /* flag for disabling the tsc */
-extern int tsc_disable;
+#define tsc_disable 0
 
 struct desc_struct {
 	unsigned long a,b;
Index: head-2007-05-31/include/asm-i386/thread_info.h
===================================================================
--- head-2007-05-31.orig/include/asm-i386/thread_info.h	2007-06-04 13:43:03.000000000 +0200
+++ head-2007-05-31/include/asm-i386/thread_info.h	2007-05-31 14:39:30.000000000 +0200
@@ -160,7 +160,11 @@ static inline struct thread_info *curren
 #define _TIF_ALLWORK_MASK	(0x0000FFFF & ~_TIF_SECCOMP)
 
 /* flags to check in __switch_to() */
+#ifndef CONFIG_XEN
 #define _TIF_WORK_CTXSW (_TIF_DEBUG|_TIF_IO_BITMAP)
+#else
+#define _TIF_WORK_CTXSW _TIF_DEBUG
+#endif
 
 /*
  * Thread-synchronous status.
Index: head-2007-05-31/include/asm-x86_64/mach-xen/asm/timer.h
===================================================================
--- head-2007-05-31.orig/include/asm-x86_64/mach-xen/asm/timer.h	2007-06-04 13:43:03.000000000 +0200
+++ head-2007-05-31/include/asm-x86_64/mach-xen/asm/timer.h	2007-05-31 14:39:30.000000000 +0200
@@ -2,39 +2,8 @@
 #define _ASMi386_TIMER_H
 #include <linux/init.h>
 
-/**
- * struct timer_ops - used to define a timer source
- *
- * @name: name of the timer.
- * @init: Probes and initializes the timer. Takes clock= override 
- *        string as an argument. Returns 0 on success, anything else
- *        on failure.
- * @mark_offset: called by the timer interrupt.
- * @get_offset:  called by gettimeofday(). Returns the number of microseconds
- *               since the last timer interupt.
- * @monotonic_clock: returns the number of nanoseconds since the init of the
- *                   timer.
- * @delay: delays this many clock cycles.
- */
-struct timer_opts {
-	char* name;
-	void (*mark_offset)(void);
-	unsigned long (*get_offset)(void);
-	unsigned long long (*monotonic_clock)(void);
-	void (*delay)(unsigned long);
-	unsigned long (*read_timer)(void);
-	int (*suspend)(pm_message_t state);
-	int (*resume)(void);
-};
-
-struct init_timer_opts {
-	int (*init)(char *override);
-	struct timer_opts *opts;
-};
-
 #define TICK_SIZE (tick_nsec / 1000)
 
-extern struct timer_opts* __init select_timer(void);
 extern void clock_fallback(void);
 void setup_pit_timer(void);
 
@@ -42,26 +11,13 @@ void setup_pit_timer(void);
 
 extern int pit_latch_buggy;
 
-extern struct timer_opts *cur_timer;
 extern int timer_ack;
 
 /* list of externed timers */
-extern struct timer_opts timer_none;
-extern struct timer_opts timer_pit;
-extern struct init_timer_opts timer_pit_init;
-extern struct init_timer_opts timer_tsc_init;
-#ifdef CONFIG_X86_CYCLONE_TIMER
-extern struct init_timer_opts timer_cyclone_init;
-#endif
-
 extern unsigned long calibrate_tsc(void);
 extern void init_cpu_khz(void);
 #ifdef CONFIG_HPET_TIMER
-extern struct init_timer_opts timer_hpet_init;
 extern unsigned long calibrate_tsc_hpet(unsigned long *tsc_hpet_quotient_ptr);
 #endif
 
-#ifdef CONFIG_X86_PM_TIMER
-extern struct init_timer_opts timer_pmtmr_init;
-#endif
 #endif
Index: head-2007-05-31/include/xen/hypervisor_sysfs.h
===================================================================
--- head-2007-05-31.orig/include/xen/hypervisor_sysfs.h	2007-05-31 13:53:11.000000000 +0200
+++ head-2007-05-31/include/xen/hypervisor_sysfs.h	2007-06-04 13:43:51.000000000 +0200
@@ -20,8 +20,6 @@ static struct hyp_sysfs_attr  _name##_at
 static struct hyp_sysfs_attr _name##_attr = \
 	__ATTR(_name, 0644, _name##_show, _name##_store)
 
-extern struct subsystem hypervisor_subsys;
-
 struct hyp_sysfs_attr {
 	struct attribute attr;
 	ssize_t (*show)(struct hyp_sysfs_attr *, char *);
