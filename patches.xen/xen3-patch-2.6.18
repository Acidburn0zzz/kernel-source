From: www.kernel.org
Subject: Linux 2.6.18
Patch-mainline: 2.6.18

Automatically created from "patches.kernel.org/patch-2.6.18" by xen-port-patches.py

Acked-by: jbeulich@novell.com

Index: head-2007-10-15/arch/i386/Kconfig
===================================================================
--- head-2007-10-15.orig/arch/i386/Kconfig	2007-10-15 17:49:16.000000000 +0200
+++ head-2007-10-15/arch/i386/Kconfig	2007-10-15 17:56:33.000000000 +0200
@@ -16,7 +16,6 @@ config X86_32
 
 config GENERIC_TIME
 	bool
-	depends on !X86_XEN
 	default y
 
 config GENERIC_CMOS_UPDATE
Index: head-2007-10-15/arch/i386/kernel/Makefile
===================================================================
--- head-2007-10-15.orig/arch/i386/kernel/Makefile	2007-10-15 17:49:16.000000000 +0200
+++ head-2007-10-15/arch/i386/kernel/Makefile	2007-10-15 17:57:07.000000000 +0200
@@ -90,5 +90,5 @@ stacktrace-y		  += ../../x86_64/kernel/s
 early_printk-y            += ../../x86_64/kernel/early_printk.o
 early-quirks-y		  += ../../x86_64/kernel/early-quirks.o
 
-disabled-obj-$(CONFIG_XEN) := i8259.o reboot.o smpboot.o trampoline.o
+disabled-obj-$(CONFIG_XEN) := i8253.o i8259.o reboot.o smpboot.o trampoline.o tsc.o
 %/head.o %/head.s: $(if $(CONFIG_XEN),EXTRA_AFLAGS,dummy) :=
Index: head-2007-10-15/arch/i386/kernel/time-xen.c
===================================================================
--- head-2007-10-15.orig/arch/i386/kernel/time-xen.c	2007-10-15 17:49:16.000000000 +0200
+++ head-2007-10-15/arch/i386/kernel/time-xen.c	2007-10-15 17:56:33.000000000 +0200
@@ -76,8 +76,13 @@
 
 #if defined (__i386__)
 #include <asm/i8259.h>
+#include <asm/i8253.h>
+DEFINE_SPINLOCK(i8253_lock);
+EXPORT_SYMBOL(i8253_lock);
 #endif
 
+#define XEN_SHIFT 22
+
 int pit_latch_buggy;              /* extern */
 
 #if defined(__x86_64__)
@@ -97,10 +102,6 @@ extern unsigned long wall_jiffies;
 DEFINE_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL(rtc_lock);
 
-extern struct init_timer_opts timer_tsc_init;
-extern struct timer_opts timer_tsc;
-#define timer_none timer_tsc
-
 /* These are peridically updated in shared_info, and then copied here. */
 struct shadow_time_info {
 	u64 tsc_timestamp;     /* TSC at last update of time vals.  */
@@ -248,6 +249,7 @@ static u64 get_nsec_offset(struct shadow
 	return scale_delta(delta, shadow->tsc_to_nsec_mul, shadow->tsc_shift);
 }
 
+#ifdef CONFIG_X86_64
 static unsigned long get_usec_offset(struct shadow_time_info *shadow)
 {
 	u64 now, delta;
@@ -255,6 +257,7 @@ static unsigned long get_usec_offset(str
 	delta = now - shadow->tsc_timestamp;
 	return scale_delta(delta, shadow->tsc_to_usec_mul, shadow->tsc_shift);
 }
+#endif
 
 static void __update_wallclock(time_t sec, long nsec)
 {
@@ -364,6 +367,8 @@ void rtc_cmos_write(unsigned char val, u
 }
 EXPORT_SYMBOL(rtc_cmos_write);
 
+#ifdef CONFIG_X86_64
+
 /*
  * This version of gettimeofday has microsecond resolution
  * and better than microsecond precision on fast x86 machines with TSC.
@@ -498,6 +503,8 @@ int do_settimeofday(struct timespec *tv)
 
 EXPORT_SYMBOL(do_settimeofday);
 
+#endif
+
 static void sync_xen_wallclock(unsigned long dummy);
 static DEFINE_TIMER(sync_xen_wallclock_timer, sync_xen_wallclock, 0, 0);
 static void sync_xen_wallclock(unsigned long dummy)
@@ -549,11 +556,15 @@ static int set_rtc_mmss(unsigned long no
 	return retval;
 }
 
+#ifdef CONFIG_X86_64
 /* monotonic_clock(): returns # of nanoseconds passed since time_init()
  *		Note: This function is required to return accurate
  *		time even in the absence of multiple timer ticks.
  */
 unsigned long long monotonic_clock(void)
+#else
+unsigned long long sched_clock(void)
+#endif
 {
 	int cpu = get_cpu();
 	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
@@ -573,9 +584,9 @@ unsigned long long monotonic_clock(void)
 
 	return time;
 }
+#ifdef CONFIG_X86_64
 EXPORT_SYMBOL(monotonic_clock);
 
-#ifdef __x86_64__
 unsigned long long sched_clock(void)
 {
 	return monotonic_clock();
@@ -745,6 +756,90 @@ irqreturn_t timer_interrupt(int irq, voi
 	return IRQ_HANDLED;
 }
 
+#ifndef CONFIG_X86_64
+
+void tsc_init(void)
+{
+	init_cpu_khz();
+	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
+	       cpu_khz / 1000, cpu_khz % 1000);
+
+	use_tsc_delay();
+}
+
+#include <linux/clocksource.h>
+
+void mark_tsc_unstable(void)
+{
+#ifndef CONFIG_XEN /* XXX Should tell the hypervisor about this fact. */
+	tsc_unstable = 1;
+#endif
+}
+EXPORT_SYMBOL_GPL(mark_tsc_unstable);
+
+static cycle_t xen_clocksource_read(void)
+{
+	int cpu = get_cpu();
+	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
+	cycle_t ret;
+
+	get_time_values_from_xen(cpu);
+
+	ret = shadow->system_timestamp + get_nsec_offset(shadow);
+
+	put_cpu();
+
+#ifdef CONFIG_SMP
+	for (;;) {
+		static cycle_t last_ret;
+#ifndef CONFIG_64BIT
+		cycle_t last = cmpxchg64(&last_ret, 0, 0);
+#else
+		cycle_t last = last_ret;
+#define cmpxchg64 cmpxchg
+#endif
+
+		if ((s64)(ret - last) < 0) {
+			if (last - ret > permitted_clock_jitter
+			    && printk_ratelimit())
+				printk(KERN_WARNING "clocksource/%d: "
+				       "Time went backwards: "
+				       "delta=%Ld shadow=%Lu offset=%Lu\n",
+				       cpu, ret - last,
+				       shadow->system_timestamp,
+				       get_nsec_offset(shadow));
+			ret = last;
+		}
+		if (cmpxchg64(&last_ret, last, ret) == last)
+			break;
+	}
+#endif
+
+	return ret;
+}
+
+static struct clocksource clocksource_xen = {
+	.name			= "xen",
+	.rating			= 400,
+	.read			= xen_clocksource_read,
+	.mask			= CLOCKSOURCE_MASK(64),
+	.mult			= 1 << XEN_SHIFT,		/* time directly in nanoseconds */
+	.shift			= XEN_SHIFT,
+	.is_continuous		= 1,
+};
+
+static int __init init_xen_clocksource(void)
+{
+	clocksource_xen.mult = clocksource_khz2mult(cpu_khz,
+						clocksource_xen.shift);
+
+	return clocksource_register(&clocksource_xen);
+}
+
+module_init(init_xen_clocksource);
+
+#endif
+
 static void init_missing_ticks_accounting(int cpu)
 {
 	struct vcpu_register_runstate_memory_area area;
@@ -954,11 +1049,11 @@ void __init time_init(void)
 
 	update_wallclock();
 
+#ifdef CONFIG_X86_64
 	init_cpu_khz();
 	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
 	       cpu_khz / 1000, cpu_khz % 1000);
 
-#if defined(__x86_64__)
 	vxtime.mode = VXTIME_TSC;
 	vxtime.quot = (1000000L << 32) / vxtime_hz;
 	vxtime.tsc_quot = (1000L << 32) / cpu_khz;
Index: head-2007-10-15/include/asm-i386/mach-xen/asm/processor.h
===================================================================
--- head-2007-10-15.orig/include/asm-i386/mach-xen/asm/processor.h	2007-10-15 17:49:16.000000000 +0200
+++ head-2007-10-15/include/asm-i386/mach-xen/asm/processor.h	2007-10-15 17:56:33.000000000 +0200
@@ -23,7 +23,7 @@
 #include <xen/interface/physdev.h>
 
 /* flag for disabling the tsc */
-extern int tsc_disable;
+#define tsc_disable 0
 
 struct desc_struct {
 	unsigned long a,b;
Index: head-2007-10-15/include/asm-i386/thread_info.h
===================================================================
--- head-2007-10-15.orig/include/asm-i386/thread_info.h	2007-10-09 22:31:38.000000000 +0200
+++ head-2007-10-15/include/asm-i386/thread_info.h	2007-10-15 18:00:50.000000000 +0200
@@ -160,8 +160,12 @@ static inline struct thread_info *curren
 #define _TIF_ALLWORK_MASK	(0x0000FFFF & ~_TIF_SECCOMP)
 
 /* flags to check in __switch_to() */
+#ifndef CONFIG_XEN
 #define _TIF_WORK_CTXSW_NEXT (_TIF_IO_BITMAP | _TIF_NOTSC | _TIF_DEBUG)
 #define _TIF_WORK_CTXSW_PREV (_TIF_IO_BITMAP | _TIF_NOTSC)
+#else
+#define _TIF_WORK_CTXSW _TIF_DEBUG
+#endif
 
 /*
  * Thread-synchronous status.
Index: head-2007-10-15/include/asm-x86_64/mach-xen/asm/timer.h
===================================================================
--- head-2007-10-15.orig/include/asm-x86_64/mach-xen/asm/timer.h	2007-10-15 17:49:16.000000000 +0200
+++ head-2007-10-15/include/asm-x86_64/mach-xen/asm/timer.h	2007-10-15 17:56:33.000000000 +0200
@@ -2,39 +2,8 @@
 #define _ASMi386_TIMER_H
 #include <linux/init.h>
 
-/**
- * struct timer_ops - used to define a timer source
- *
- * @name: name of the timer.
- * @init: Probes and initializes the timer. Takes clock= override 
- *        string as an argument. Returns 0 on success, anything else
- *        on failure.
- * @mark_offset: called by the timer interrupt.
- * @get_offset:  called by gettimeofday(). Returns the number of microseconds
- *               since the last timer interupt.
- * @monotonic_clock: returns the number of nanoseconds since the init of the
- *                   timer.
- * @delay: delays this many clock cycles.
- */
-struct timer_opts {
-	char* name;
-	void (*mark_offset)(void);
-	unsigned long (*get_offset)(void);
-	unsigned long long (*monotonic_clock)(void);
-	void (*delay)(unsigned long);
-	unsigned long (*read_timer)(void);
-	int (*suspend)(pm_message_t state);
-	int (*resume)(void);
-};
-
-struct init_timer_opts {
-	int (*init)(char *override);
-	struct timer_opts *opts;
-};
-
 #define TICK_SIZE (tick_nsec / 1000)
 
-extern struct timer_opts* __init select_timer(void);
 extern void clock_fallback(void);
 void setup_pit_timer(void);
 
@@ -42,26 +11,13 @@ void setup_pit_timer(void);
 
 extern int pit_latch_buggy;
 
-extern struct timer_opts *cur_timer;
 extern int timer_ack;
 
 /* list of externed timers */
-extern struct timer_opts timer_none;
-extern struct timer_opts timer_pit;
-extern struct init_timer_opts timer_pit_init;
-extern struct init_timer_opts timer_tsc_init;
-#ifdef CONFIG_X86_CYCLONE_TIMER
-extern struct init_timer_opts timer_cyclone_init;
-#endif
-
 extern unsigned long calibrate_tsc(void);
 extern void init_cpu_khz(void);
 #ifdef CONFIG_HPET_TIMER
-extern struct init_timer_opts timer_hpet_init;
 extern unsigned long calibrate_tsc_hpet(unsigned long *tsc_hpet_quotient_ptr);
 #endif
 
-#ifdef CONFIG_X86_PM_TIMER
-extern struct init_timer_opts timer_pmtmr_init;
-#endif
 #endif
