From: www.kernel.org
Subject: Linux 2.6.18
Patch-mainline: 2.6.18

Automatically created from "patches.kernel.org/patch-2.6.18" by xen-port-patches.py

Acked-by: jbeulich@novell.com

Index: head-2007-03-19/arch/i386/Kconfig
===================================================================
--- head-2007-03-19.orig/arch/i386/Kconfig	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/arch/i386/Kconfig	2007-03-19 16:22:08.000000000 +0100
@@ -16,7 +16,6 @@ config X86_32
 
 config GENERIC_TIME
 	bool
-	depends on !X86_XEN
 	default y
 
 config CLOCKSOURCE_WATCHDOG
@@ -913,7 +912,6 @@ config HOTPLUG_CPU
 
 config COMPAT_VDSO
 	bool "Compat VDSO support"
-	depends on !X86_XEN
 	default y
 	help
 	  Map the VDSO to the predictable old-style address too.
Index: head-2007-03-19/arch/i386/kernel/Makefile
===================================================================
--- head-2007-03-19.orig/arch/i386/kernel/Makefile	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/arch/i386/kernel/Makefile	2007-03-21 16:27:46.000000000 +0100
@@ -77,6 +77,52 @@ $(obj)/vsyscall-%.so: $(src)/vsyscall.ld
 		      $(obj)/vsyscall-%.o $(obj)/$(vsyscall_note) FORCE
 	$(call if_changed,syscall)
 
+ifeq ($(CONFIG_XEN)$(CONFIG_COMPAT_VDSO),yy)
+
+# vsyscall.o also contains the vsyscall DSO relocation info as __initdata.
+# We must build both alternative images before we can assemble it.
+# Note: kbuild does not track this dependency due to usage of .include
+$(obj)/vsyscall.o: $(obj)/vsyscall-int80.rel $(obj)/vsyscall-sysenter.rel
+targets += $(foreach F,int80 sysenter,vsyscall-$F.so.alt vsyscall-$F.rel)
+targets += vsyscall.lds.alt
+
+# The alternative DSO images are built using an alternate base address.
+quiet_cmd_syscall_alt = REBASE  $@
+      cmd_syscall_alt = sed 's,^\([[:space:]]*\.[[:space:]]*=[[:space:]]*\),\1-0x55AA0000 + ,' $< >$@
+
+quiet_cmd_syscall_rel = COMPARE $@
+      cmd_syscall_rel = set -e; \
+			cmp -l $(basename $<) $< \
+			| { read off1 old1 new1; \
+			    read off2 old2 new2; \
+			    test $$(expr $$off1 + 1) = $$off2; \
+			    echo " .long $$(expr $$off1 - 3)"; \
+			    while read off1 old3 new3; do \
+				read off2 old4 new4; \
+				test $$(expr $$off1 + 1) = $$off2; \
+				test $$old1 = $$old3 -a $$new1 = $$new3; \
+				test $$old2 = $$old4 -a $$new2 = $$new4; \
+				echo " .long $$(expr $$off1 - 3)"; \
+			    done; \
+			  } >$@
+
+SYSCFLAGS_vsyscall-sysenter.so.alt = $(vsyscall-flags)
+SYSCFLAGS_vsyscall-int80.so.alt    = $(vsyscall-flags)
+
+$(obj)/vsyscall.lds.alt: $(obj)/vsyscall.lds FORCE
+	$(call if_changed,syscall_alt)
+
+$(obj)/vsyscall-int80.so.alt $(obj)/vsyscall-sysenter.so.alt: \
+$(obj)/vsyscall-%.so.alt: $(obj)/vsyscall.lds.alt \
+		      $(obj)/vsyscall-%.o $(obj)/$(vsyscall_note) FORCE
+	$(call if_changed,syscall)
+
+$(obj)/vsyscall-int80.rel $(obj)/vsyscall-sysenter.rel: \
+$(obj)/vsyscall-%.rel: $(obj)/vsyscall-%.so.alt FORCE
+	$(call if_changed,syscall_rel)
+
+endif
+
 # We also create a special relocatable object that should mirror the symbol
 # table and layout of the linked DSO.  With ld -R we can then refer to
 # these symbols in the kernel code rather than hand-coded addresses.
@@ -97,7 +143,7 @@ include $(srctree)/scripts/Makefile.xen
 
 obj-y += fixup.o
 microcode-$(subst m,y,$(CONFIG_MICROCODE)) := microcode-xen.o
-n-obj-xen := i8259.o timers/ reboot.o smpboot.o trampoline.o
+n-obj-xen := i8253.o i8259.o reboot.o smpboot.o trampoline.o tsc.o
 
 obj-y := $(call filterxen, $(obj-y), $(n-obj-xen))
 obj-y := $(call cherrypickxen, $(obj-y))
Index: head-2007-03-19/arch/i386/kernel/sysenter.c
===================================================================
--- head-2007-03-19.orig/arch/i386/kernel/sysenter.c	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/arch/i386/kernel/sysenter.c	2007-03-19 16:22:08.000000000 +0100
@@ -25,6 +25,8 @@
 
 #ifdef CONFIG_XEN
 #include <xen/interface/callback.h>
+extern const unsigned long vdso_rel_int80_start[], vdso_rel_int80_end[];
+extern const unsigned long vdso_rel_sysenter_start[], vdso_rel_sysenter_end[];
 #endif
 
 /*
@@ -70,6 +72,142 @@ void enable_sep_cpu(void)
 #endif
 }
 
+#if defined(CONFIG_XEN) && defined(CONFIG_COMPAT_VDSO)
+static void __init relocate_vdso(Elf32_Ehdr *ehdr, unsigned long old_base, unsigned long new_base,
+                                 const unsigned long *reloc_start, const unsigned long *reloc_end)
+{
+#if 1
+	const unsigned long *reloc;
+
+	for (reloc = reloc_start; reloc < reloc_end; ++reloc) {
+		unsigned long *ptr = (void *)((unsigned long)ehdr + *reloc);
+
+		*ptr += new_base - old_base;
+	}
+#else
+	unsigned i, ndynsym = 0, szdynsym = 0;
+	unsigned long dynsym = 0;
+
+	BUG_ON(ehdr->e_ident[EI_MAG0] != ELFMAG0);
+	BUG_ON(ehdr->e_ident[EI_MAG1] != ELFMAG1);
+	BUG_ON(ehdr->e_ident[EI_MAG2] != ELFMAG2);
+	BUG_ON(ehdr->e_ident[EI_MAG3] != ELFMAG3);
+	BUG_ON(ehdr->e_ident[EI_CLASS] != ELFCLASS32);
+	BUG_ON(ehdr->e_ident[EI_DATA] != ELFDATA2LSB);
+	BUG_ON(ehdr->e_ehsize < sizeof(*ehdr));
+	ehdr->e_entry += new_base - old_base;
+	BUG_ON(ehdr->e_phentsize < sizeof(Elf32_Phdr));
+	for (i = 0; i < ehdr->e_phnum; ++i) {
+		Elf32_Phdr *phdr = (void *)((unsigned long)ehdr + ehdr->e_phoff + i * ehdr->e_phentsize);
+
+		phdr->p_vaddr += new_base - old_base;
+		switch(phdr->p_type) {
+		case PT_LOAD:
+		case PT_NOTE:
+			break;
+		case PT_DYNAMIC: {
+				Elf32_Dyn *dyn = (void *)(phdr->p_vaddr - new_base + (unsigned long)ehdr);
+				unsigned j;
+
+				for(j = 0; dyn[j].d_tag != DT_NULL; ++j) {
+					switch(dyn[j].d_tag) {
+					case DT_HASH:
+					case DT_STRTAB:
+					case DT_SYMTAB:
+					case 0x6ffffff0: /* DT_VERSYM */
+					case 0x6ffffffc: /* DT_VERDEF */
+						break;
+					case DT_SONAME:
+					case DT_STRSZ:
+					case 0x6ffffffd: /* DT_VERDEFNUM */
+						continue;
+					case DT_SYMENT:
+						szdynsym = dyn[j].d_un.d_val;
+						continue;
+					default:
+						if (dyn[j].d_tag >= 0x60000000 /* OLD_DT_LOOS */
+						    || dyn[j].d_tag < 31 /* DT_ENCODING */
+						    || !(dyn[j].d_tag & 1)) {
+							printk(KERN_WARNING "vDSO dynamic info %u has unsupported tag %08X\n", j, dyn[j].d_tag);
+							WARN_ON(1);
+							continue;
+						}
+						break;
+					}
+					dyn[j].d_un.d_ptr += new_base - old_base;
+					switch(dyn[j].d_tag) {
+					case DT_HASH:
+						ndynsym = ((Elf32_Word *)dyn[j].d_un.d_ptr)[1];
+						break;
+					case DT_SYMTAB:
+						dynsym = dyn[j].d_un.d_ptr;
+						break;
+					}
+				}
+			}
+			break;
+		case PT_GNU_EH_FRAME:
+			/* XXX */
+			break;
+		default:
+			printk(KERN_WARNING "vDSO program header %u has unsupported type %08X\n", i, phdr->p_type);
+			WARN_ON(1);
+			break;
+		}
+	}
+	BUG_ON(ehdr->e_shentsize < sizeof(Elf32_Shdr));
+	BUG_ON(ehdr->e_shnum >= SHN_LORESERVE);
+	for (i = 1; i < ehdr->e_shnum; ++i) {
+		Elf32_Shdr *shdr = (void *)((unsigned long)ehdr + ehdr->e_shoff + i * ehdr->e_shentsize);
+
+		if (!(shdr->sh_flags & SHF_ALLOC))
+			continue;
+		shdr->sh_addr += new_base - old_base;
+		switch(shdr->sh_type) {
+		case SHT_DYNAMIC:
+		case SHT_HASH:
+		case SHT_NOBITS:
+		case SHT_NOTE:
+		case SHT_PROGBITS:
+		case SHT_STRTAB:
+		case 0x6ffffffd: /* SHT_GNU_verdef */
+		case 0x6fffffff: /* SHT_GNU_versym */
+			break;
+		case SHT_DYNSYM:
+			BUG_ON(shdr->sh_entsize < sizeof(Elf32_Sym));
+			if (!szdynsym)
+				szdynsym = shdr->sh_entsize;
+			else
+				WARN_ON(szdynsym != shdr->sh_entsize);
+			if (!ndynsym)
+				ndynsym = shdr->sh_size / szdynsym;
+			else
+				WARN_ON(ndynsym != shdr->sh_size / szdynsym);
+			if (!dynsym)
+				dynsym = shdr->sh_addr;
+			else
+				WARN_ON(dynsym != shdr->sh_addr);
+			break;
+		default:
+			printk(KERN_WARNING "vDSO section %u has unsupported type %08X\n", i, shdr->sh_type);
+			WARN_ON(shdr->sh_size);
+			break;
+		}
+	}
+	dynsym += (unsigned long)ehdr - new_base;
+	for(i = 1; i < ndynsym; ++i) {
+		Elf32_Sym *sym = (void *)(dynsym + i * szdynsym);
+
+		if (sym->st_shndx == SHN_ABS)
+			continue;
+		sym->st_value += new_base - old_base;
+	}
+#endif
+}
+#else
+#define relocate_vdso(ehdr, old, new, start, end) ((void)0)
+#endif
+
 /*
  * These symbols are defined by vsyscall.o to mark the bounds
  * of the ELF DSO images included therein.
@@ -104,12 +242,16 @@ int __init sysenter_setup(void)
 		memcpy(syscall_page,
 		       &vsyscall_int80_start,
 		       &vsyscall_int80_end - &vsyscall_int80_start);
+		relocate_vdso(syscall_page, VDSO_PRELINK, __fix_to_virt(FIX_VDSO),
+		              vdso_rel_int80_start, vdso_rel_int80_end);
 		return 0;
 	}
 
 	memcpy(syscall_page,
 	       &vsyscall_sysenter_start,
 	       &vsyscall_sysenter_end - &vsyscall_sysenter_start);
+	relocate_vdso(syscall_page, VDSO_PRELINK, __fix_to_virt(FIX_VDSO),
+	              vdso_rel_sysenter_start, vdso_rel_sysenter_end);
 
 	return 0;
 }
Index: head-2007-03-19/arch/i386/kernel/time-xen.c
===================================================================
--- head-2007-03-19.orig/arch/i386/kernel/time-xen.c	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/arch/i386/kernel/time-xen.c	2007-03-22 17:31:56.000000000 +0100
@@ -75,8 +75,13 @@
 
 #if defined (__i386__)
 #include <asm/i8259.h>
+#include <asm/i8253.h>
+DEFINE_SPINLOCK(i8253_lock);
+EXPORT_SYMBOL(i8253_lock);
 #endif
 
+#define XEN_SHIFT 22
+
 int pit_latch_buggy;              /* extern */
 
 #if defined(__x86_64__)
@@ -96,10 +101,6 @@ extern unsigned long wall_jiffies;
 DEFINE_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL(rtc_lock);
 
-extern struct init_timer_opts timer_tsc_init;
-extern struct timer_opts timer_tsc;
-#define timer_none timer_tsc
-
 /* These are peridically updated in shared_info, and then copied here. */
 struct shadow_time_info {
 	u64 tsc_timestamp;     /* TSC at last update of time vals.  */
@@ -238,6 +239,7 @@ static u64 get_nsec_offset(struct shadow
 	return scale_delta(delta, shadow->tsc_to_nsec_mul, shadow->tsc_shift);
 }
 
+#ifdef CONFIG_X86_64
 static unsigned long get_usec_offset(struct shadow_time_info *shadow)
 {
 	u64 now, delta;
@@ -245,6 +247,7 @@ static unsigned long get_usec_offset(str
 	delta = now - shadow->tsc_timestamp;
 	return scale_delta(delta, shadow->tsc_to_usec_mul, shadow->tsc_shift);
 }
+#endif
 
 static void __update_wallclock(time_t sec, long nsec)
 {
@@ -354,6 +357,8 @@ void rtc_cmos_write(unsigned char val, u
 }
 EXPORT_SYMBOL(rtc_cmos_write);
 
+#ifdef CONFIG_X86_64
+
 /*
  * This version of gettimeofday has microsecond resolution
  * and better than microsecond precision on fast x86 machines with TSC.
@@ -482,6 +487,8 @@ int do_settimeofday(struct timespec *tv)
 
 EXPORT_SYMBOL(do_settimeofday);
 
+#endif
+
 static void sync_xen_wallclock(unsigned long dummy);
 static DEFINE_TIMER(sync_xen_wallclock_timer, sync_xen_wallclock, 0, 0);
 static void sync_xen_wallclock(unsigned long dummy)
@@ -533,11 +540,15 @@ static int set_rtc_mmss(unsigned long no
 	return retval;
 }
 
+#ifdef CONFIG_X86_64
 /* monotonic_clock(): returns # of nanoseconds passed since time_init()
  *		Note: This function is required to return accurate
  *		time even in the absence of multiple timer ticks.
  */
 unsigned long long monotonic_clock(void)
+#else
+unsigned long long sched_clock(void)
+#endif
 {
 	int cpu = get_cpu();
 	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
@@ -557,9 +568,9 @@ unsigned long long monotonic_clock(void)
 
 	return time;
 }
+#ifdef CONFIG_X86_64
 EXPORT_SYMBOL(monotonic_clock);
 
-#ifdef __x86_64__
 unsigned long long sched_clock(void)
 {
 	return monotonic_clock();
@@ -728,6 +739,64 @@ irqreturn_t timer_interrupt(int irq, voi
 	return IRQ_HANDLED;
 }
 
+#ifndef CONFIG_X86_64
+
+void tsc_init(void)
+{
+	init_cpu_khz();
+	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
+	       cpu_khz / 1000, cpu_khz % 1000);
+
+	use_tsc_delay();
+}
+
+#include <linux/clocksource.h>
+
+void mark_tsc_unstable(void)
+{
+#ifndef CONFIG_XEN /* XXX Should tell the hypervisor about this fact. */
+	tsc_unstable = 1;
+#endif
+}
+EXPORT_SYMBOL_GPL(mark_tsc_unstable);
+
+static cycle_t xen_clocksource_read(void)
+{
+	int cpu = get_cpu();
+	struct shadow_time_info *shadow = &per_cpu(shadow_time, cpu);
+	cycle_t ret;
+
+	get_time_values_from_xen(cpu);
+
+	ret = shadow->system_timestamp + get_nsec_offset(shadow);
+
+	put_cpu();
+
+	return ret;
+}
+
+static struct clocksource clocksource_xen = {
+	.name			= "xen",
+	.rating			= 400,
+	.read			= xen_clocksource_read,
+	.mask			= CLOCKSOURCE_MASK(64),
+	.mult			= 1 << XEN_SHIFT,		/* time directly in nanoseconds */
+	.shift			= XEN_SHIFT,
+	.is_continuous		= 1,
+};
+
+static int __init init_xen_clocksource(void)
+{
+	clocksource_xen.mult = clocksource_khz2mult(cpu_khz,
+						clocksource_xen.shift);
+
+	return clocksource_register(&clocksource_xen);
+}
+
+module_init(init_xen_clocksource);
+
+#endif
+
 static void init_missing_ticks_accounting(int cpu)
 {
 	struct vcpu_register_runstate_memory_area area;
@@ -935,11 +1004,11 @@ void __init time_init(void)
 
 	update_wallclock();
 
+#ifdef CONFIG_X86_64
 	init_cpu_khz();
 	printk(KERN_INFO "Xen reported: %u.%03u MHz processor.\n",
 	       cpu_khz / 1000, cpu_khz % 1000);
 
-#if defined(__x86_64__)
 	vxtime.mode = VXTIME_TSC;
 	vxtime.quot = (1000000L << 32) / vxtime_hz;
 	vxtime.tsc_quot = (1000L << 32) / cpu_khz;
Index: head-2007-03-19/arch/i386/kernel/vsyscall.S
===================================================================
--- head-2007-03-19.orig/arch/i386/kernel/vsyscall.S	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/arch/i386/kernel/vsyscall.S	2007-03-19 16:22:08.000000000 +0100
@@ -12,4 +12,20 @@ vsyscall_sysenter_start:
 	.incbin "arch/i386/kernel/vsyscall-sysenter.so"
 vsyscall_sysenter_end:
 
+#if defined(CONFIG_XEN) && defined(CONFIG_COMPAT_VDSO)
+
+	.align 4
+
+	.globl vdso_rel_int80_start, vdso_rel_int80_end
+vdso_rel_int80_start:
+	.include "arch/i386/kernel/vsyscall-int80.rel"
+vdso_rel_int80_end:
+
+	.globl vdso_rel_sysenter_start, vdso_rel_sysenter_end
+vdso_rel_sysenter_start:
+	.include "arch/i386/kernel/vsyscall-sysenter.rel"
+vdso_rel_sysenter_end:
+
+#endif
+
 __FINIT
Index: head-2007-03-19/include/asm-i386/elf.h
===================================================================
--- head-2007-03-19.orig/include/asm-i386/elf.h	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/include/asm-i386/elf.h	2007-03-19 16:22:08.000000000 +0100
@@ -137,7 +137,11 @@ extern int dump_task_extended_fpu (struc
 
 #ifdef CONFIG_COMPAT_VDSO
 # define VDSO_COMPAT_BASE	VDSO_HIGH_BASE
-# define VDSO_PRELINK		VDSO_HIGH_BASE
+# ifndef CONFIG_XEN
+#  define VDSO_PRELINK		VDSO_HIGH_BASE
+# else
+#  define VDSO_PRELINK		(0UL - FIX_VDSO * PAGE_SIZE)
+# endif
 #else
 # define VDSO_COMPAT_BASE	VDSO_BASE
 # define VDSO_PRELINK		0
Index: head-2007-03-19/include/asm-i386/mach-xen/asm/processor.h
===================================================================
--- head-2007-03-19.orig/include/asm-i386/mach-xen/asm/processor.h	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/include/asm-i386/mach-xen/asm/processor.h	2007-03-19 16:22:08.000000000 +0100
@@ -23,7 +23,7 @@
 #include <xen/interface/physdev.h>
 
 /* flag for disabling the tsc */
-extern int tsc_disable;
+#define tsc_disable 0
 
 struct desc_struct {
 	unsigned long a,b;
Index: head-2007-03-19/include/asm-i386/thread_info.h
===================================================================
--- head-2007-03-19.orig/include/asm-i386/thread_info.h	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/include/asm-i386/thread_info.h	2007-03-19 16:22:08.000000000 +0100
@@ -158,7 +158,11 @@ static inline struct thread_info *curren
 #define _TIF_ALLWORK_MASK	(0x0000FFFF & ~_TIF_SECCOMP)
 
 /* flags to check in __switch_to() */
+#ifndef CONFIG_XEN
 #define _TIF_WORK_CTXSW (_TIF_DEBUG|_TIF_IO_BITMAP)
+#else
+#define _TIF_WORK_CTXSW _TIF_DEBUG
+#endif
 
 /*
  * Thread-synchronous status.
Index: head-2007-03-19/include/asm-x86_64/mach-xen/asm/timer.h
===================================================================
--- head-2007-03-19.orig/include/asm-x86_64/mach-xen/asm/timer.h	2007-03-22 17:30:59.000000000 +0100
+++ head-2007-03-19/include/asm-x86_64/mach-xen/asm/timer.h	2007-03-19 16:22:08.000000000 +0100
@@ -2,39 +2,8 @@
 #define _ASMi386_TIMER_H
 #include <linux/init.h>
 
-/**
- * struct timer_ops - used to define a timer source
- *
- * @name: name of the timer.
- * @init: Probes and initializes the timer. Takes clock= override 
- *        string as an argument. Returns 0 on success, anything else
- *        on failure.
- * @mark_offset: called by the timer interrupt.
- * @get_offset:  called by gettimeofday(). Returns the number of microseconds
- *               since the last timer interupt.
- * @monotonic_clock: returns the number of nanoseconds since the init of the
- *                   timer.
- * @delay: delays this many clock cycles.
- */
-struct timer_opts {
-	char* name;
-	void (*mark_offset)(void);
-	unsigned long (*get_offset)(void);
-	unsigned long long (*monotonic_clock)(void);
-	void (*delay)(unsigned long);
-	unsigned long (*read_timer)(void);
-	int (*suspend)(pm_message_t state);
-	int (*resume)(void);
-};
-
-struct init_timer_opts {
-	int (*init)(char *override);
-	struct timer_opts *opts;
-};
-
 #define TICK_SIZE (tick_nsec / 1000)
 
-extern struct timer_opts* __init select_timer(void);
 extern void clock_fallback(void);
 void setup_pit_timer(void);
 
@@ -42,26 +11,13 @@ void setup_pit_timer(void);
 
 extern int pit_latch_buggy;
 
-extern struct timer_opts *cur_timer;
 extern int timer_ack;
 
 /* list of externed timers */
-extern struct timer_opts timer_none;
-extern struct timer_opts timer_pit;
-extern struct init_timer_opts timer_pit_init;
-extern struct init_timer_opts timer_tsc_init;
-#ifdef CONFIG_X86_CYCLONE_TIMER
-extern struct init_timer_opts timer_cyclone_init;
-#endif
-
 extern unsigned long calibrate_tsc(void);
 extern void init_cpu_khz(void);
 #ifdef CONFIG_HPET_TIMER
-extern struct init_timer_opts timer_hpet_init;
 extern unsigned long calibrate_tsc_hpet(unsigned long *tsc_hpet_quotient_ptr);
 #endif
 
-#ifdef CONFIG_X86_PM_TIMER
-extern struct init_timer_opts timer_pmtmr_init;
-#endif
 #endif
