From: www.kernel.org
Subject: Update to 2.6.22-rc7
Patch-mainline: 2.6.22-rc7

Automatically created from "patches.kernel.org/patch-2.6.22-rc6-rc7" by xen-port-patches.py

Acked-by: jbeulich@novell.com

Index: head-2007-07-02/arch/x86_64/kernel/io_apic-xen.c
===================================================================
--- head-2007-07-02.orig/arch/x86_64/kernel/io_apic-xen.c	2007-07-02 13:40:51.000000000 +0200
+++ head-2007-07-02/arch/x86_64/kernel/io_apic-xen.c	2007-07-02 13:58:08.000000000 +0200
@@ -1497,6 +1497,7 @@ static void ack_lapic_irq (unsigned int 
 static void end_lapic_irq (unsigned int i) { /* nothing */ }
 
 static struct hw_interrupt_type lapic_irq_type __read_mostly = {
+	.name = "local-APIC",
 	.typename = "local-APIC-edge",
 	.startup = NULL, /* startup_irq() not used for IRQ0 */
 	.shutdown = NULL, /* shutdown_irq() not used for IRQ0 */
Index: head-2007-07-02/arch/x86_64/kernel/irq-xen.c
===================================================================
--- head-2007-07-02.orig/arch/x86_64/kernel/irq-xen.c	2007-07-02 13:40:51.000000000 +0200
+++ head-2007-07-02/arch/x86_64/kernel/irq-xen.c	2007-07-02 13:58:08.000000000 +0200
@@ -145,17 +145,43 @@ void fixup_irqs(cpumask_t map)
 
 	for (irq = 0; irq < NR_IRQS; irq++) {
 		cpumask_t mask;
+		int break_affinity = 0;
+		int set_affinity = 1;
+
 		if (irq == 2)
 			continue;
 
+		/* interrupt's are disabled at this point */
+		spin_lock(&irq_desc[irq].lock);
+
+		if (!irq_has_action(irq) ||
+		    cpus_equal(irq_desc[irq].affinity, map)) {
+			spin_unlock(&irq_desc[irq].lock);
+			continue;
+		}
+
 		cpus_and(mask, irq_desc[irq].affinity, map);
-		if (any_online_cpu(mask) == NR_CPUS) {
-			printk("Breaking affinity for irq %i\n", irq);
+		if (cpus_empty(mask)) {
+			break_affinity = 1;
 			mask = map;
 		}
+
+		if (irq_desc[irq].chip->mask)
+			irq_desc[irq].chip->mask(irq);
+
 		if (irq_desc[irq].chip->set_affinity)
 			irq_desc[irq].chip->set_affinity(irq, mask);
-		else if (irq_desc[irq].action && !(warned++))
+		else if (!(warned++))
+			set_affinity = 0;
+
+		if (irq_desc[irq].chip->unmask)
+			irq_desc[irq].chip->unmask(irq);
+
+		spin_unlock(&irq_desc[irq].lock);
+
+		if (break_affinity && set_affinity)
+			printk("Broke affinity for irq %i\n", irq);
+		else if (!set_affinity)
 			printk("Cannot set affinity for irq %i\n", irq);
 	}
 
