From: jbeulich@novell.com
Subject: allow microcode driver to be built as a module

Eliminating the dependency on sys_m{,un}lock as well as the needless use of
static variables.

Index: head-2006-04-20/arch/i386/kernel/microcode-xen.c
===================================================================
--- head-2006-04-20.orig/arch/i386/kernel/microcode-xen.c	2006-04-20 10:12:46.000000000 +0200
+++ head-2006-04-20/arch/i386/kernel/microcode-xen.c	2006-04-20 14:49:27.000000000 +0200
@@ -51,30 +51,32 @@ MODULE_LICENSE("GPL");
 /* no concurrent ->write()s are allowed on /dev/cpu/microcode */
 static DECLARE_MUTEX(microcode_sem);
 
-static void __user *user_buffer;	/* user area microcode data buffer */
-static unsigned int user_buffer_size;	/* it's size */
-				
 static int microcode_open (struct inode *unused1, struct file *unused2)
 {
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
 
 
-static int do_microcode_update (void)
+static int do_microcode_update (const void __user *ubuf, size_t len)
 {
 	int err;
-	dom0_op_t op;
+	void *kbuf;
 
-	err = sys_mlock((unsigned long)user_buffer, user_buffer_size);
-	if (err != 0)
-		return err;
-
-	op.cmd = DOM0_MICROCODE;
-	op.u.microcode.data = user_buffer;
-	op.u.microcode.length = user_buffer_size;
-	err = HYPERVISOR_dom0_op(&op);
+	kbuf = vmalloc(len);
+	if (!kbuf)
+		return -ENOMEM;
+
+	if (copy_from_user(kbuf, ubuf, len) == 0) {
+		dom0_op_t op;
+
+		op.cmd = DOM0_MICROCODE;
+		op.u.microcode.data = kbuf;
+		op.u.microcode.length = len;
+		err = HYPERVISOR_dom0_op(&op);
+	} else
+		err = -EFAULT;
 
-	(void)sys_munlock((unsigned long)user_buffer, user_buffer_size);
+	vfree(kbuf);
 
 	return err;
 }
@@ -88,17 +90,9 @@ static ssize_t microcode_write (struct f
 		return -EINVAL;
 	}
 
-	if ((len >> PAGE_SHIFT) > num_physpages) {
-		printk(KERN_ERR "microcode: too much data (max %ld pages)\n", num_physpages);
-		return -EINVAL;
-	}
-
 	down(&microcode_sem);
 
-	user_buffer = (void __user *) buf;
-	user_buffer_size = (int) len;
-
-	ret = do_microcode_update();
+	ret = do_microcode_update(buf, len);
 	if (!ret)
 		ret = (ssize_t)len;
 
