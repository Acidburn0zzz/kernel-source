Subject: patch-2.6.13-rc4
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

Automatically created from "patches.fixes/patch-2.6.13-rc3-rc4" by xen-port-patches.py
Further porting to arch/xen by kys and ccoffing

diff -uNrp linux-2.6.13-rc3/arch/xen/i386/kernel/process.c linux-2.6.13-rc4/arch/xen/i386/kernel/process.c
--- linux-2.6.13-rc3/arch/xen/i386/kernel/process.c	2005-08-18 17:54:59.725813000 -0600
+++ linux-2.6.13-rc4/arch/xen/i386/kernel/process.c	2005-08-18 18:05:45.060214425 -0600
@@ -609,9 +609,14 @@ struct task_struct fastcall * __switch_t
 
 	/*
 	 * Restore %fs and %gs if needed.
+	 *
+	 * Glibc normally makes %fs be zero, and %gs is one of
+	 * the TLS segments.
 	 */
-	if (unlikely(next->fs | next->gs)) {
+	if (unlikely(next->fs | prev->fs)) {
 		loadsegment(fs, next->fs);
+	}
+	if (prev->gs | next->gs) {
 		loadsegment(gs, next->gs);
 	}
 
@@ -619,13 +624,13 @@ struct task_struct fastcall * __switch_t
 	 * Now maybe reload the debug registers
 	 */
 	if (unlikely(next->debugreg[7])) {
-		set_debugreg(next->thread.debugreg[0], 0);
-		set_debugreg(next->thread.debugreg[1], 1);
-		set_debugreg(next->thread.debugreg[2], 2);
-		set_debugreg(next->thread.debugreg[3], 3);
+		set_debugreg(next->debugreg[0], 0);
+		set_debugreg(next->debugreg[1], 1);
+		set_debugreg(next->debugreg[2], 2);
+		set_debugreg(next->debugreg[3], 3);
 		/* no 4 and 5 */
-		set_debugreg(next->thread.debugreg[6], 6);
-		set_debugreg(next->thread.debugreg[7], 7);
+		set_debugreg(next->debugreg[6], 6);
+		set_debugreg(next->debugreg[7], 7);
 	}
 
 	disable_tsc(prev_p, next_p);
@@ -819,6 +824,8 @@ asmlinkage int sys_get_thread_area(struc
 	if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
 		return -EINVAL;
 
+	memset(&info, 0, sizeof(info));
+
 	desc = current->thread.tls_array + idx - GDT_ENTRY_TLS_MIN;
 
 	info.entry_number = idx;
diff -uNrp linux-2.6.13-rc3/arch/xen/i386/kernel/setup.c linux-2.6.13-rc4/arch/xen/i386/kernel/setup.c
--- linux-2.6.13-rc3/arch/xen/i386/kernel/setup.c	2005-08-18 17:54:59.727813000 -0600
+++ linux-2.6.13-rc4/arch/xen/i386/kernel/setup.c	2005-08-18 17:59:20.671604791 -0600
@@ -1472,7 +1472,7 @@ static struct nop { 
    This runs before SMP is initialized to avoid SMP problems with
    self modifying code. This implies that assymetric systems where
    APs have less capabilities than the boot processor are not handled. 
-   In this case boot with "noreplacement". */ 
+   Tough. Make sure you disable such features by hand. */ 
 void apply_alternatives(void *start, void *end) 
 { 
 	struct alt_instr *a; 
@@ -1500,24 +1500,12 @@ void apply_alternatives(void *start, voi
 	}
 } 
 
-static int no_replacement __initdata = 0; 
- 
 void __init alternative_instructions(void)
 {
 	extern struct alt_instr __alt_instructions[], __alt_instructions_end[];
-	if (no_replacement) 
-		return;
 	apply_alternatives(__alt_instructions, __alt_instructions_end);
 }
 
-static int __init noreplacement_setup(char *s)
-{ 
-     no_replacement = 1; 
-     return 0; 
-} 
-
-__setup("noreplacement", noreplacement_setup); 
-
 static char * __init machine_specific_memory_setup(void);
 
 #ifdef CONFIG_MCA
diff -uNrp linux-2.6.13-rc3/arch/xen/i386/pci/irq.c linux-2.6.13-rc4/arch/xen/i386/pci/irq.c
--- linux-2.6.13-rc3/arch/xen/i386/pci/irq.c	2005-08-18 17:54:59.793804000 -0600
+++ linux-2.6.13-rc4/arch/xen/i386/pci/irq.c	2005-08-18 17:59:20.673604529 -0600
@@ -556,6 +556,13 @@ static __init int intel_router_probe(str
 static __init int via_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)
 {
 	/* FIXME: We should move some of the quirk fixup stuff here */
+
+	if (router->device == PCI_DEVICE_ID_VIA_82C686 &&
+			device == PCI_DEVICE_ID_VIA_82C586_0) {
+		/* Asus k7m bios wrongly reports 82C686A as 586-compatible */
+		device = PCI_DEVICE_ID_VIA_82C686;
+	}
+
 	switch(device)
 	{
 		case PCI_DEVICE_ID_VIA_82C586_0:
diff -uNrp linux-2.6.13-rc3/arch/xen/Kconfig.debug linux-2.6.13-rc4/arch/xen/Kconfig.debug
--- linux-2.6.13-rc3/arch/xen/Kconfig.debug	2005-08-18 17:54:59.400856000 -0600
+++ linux-2.6.13-rc4/arch/xen/Kconfig.debug	2005-08-18 18:00:11.644922656 -0600
@@ -20,6 +20,9 @@ config EARLY_PRINTK
 config DEBUG_STACKOVERFLOW
 	bool "Check for stack overflows"
 	depends on DEBUG_KERNEL && X86
+	help
+	  This option will cause messages to be printed if free stack space
+	  drops below a certain limit.
 
 config KPROBES
 	bool "Kprobes"
diff -uNrp linux-2.6.13-rc3/arch/xen/x86_64/ia32/ia32entry.S linux-2.6.13-rc4/arch/xen/x86_64/ia32/ia32entry.S
--- linux-2.6.13-rc3/arch/xen/x86_64/ia32/ia32entry.S	2005-08-18 17:54:59.739812000 -0600
+++ linux-2.6.13-rc4/arch/xen/x86_64/ia32/ia32entry.S	2005-08-18 17:59:20.674604398 -0600
@@ -618,11 +618,15 @@ ia32_sys_call_table:
 	.quad compat_sys_mq_getsetattr
 	.quad compat_sys_kexec_load	/* reserved for kexec */
 	.quad compat_sys_waitid
-	.quad quiet_ni_syscall		/* sys_altroot */
+	.quad quiet_ni_syscall		/* 285: sys_altroot */
 	.quad sys_add_key
 	.quad sys_request_key
 	.quad sys_keyctl
-	/* don't forget to change IA32_NR_syscalls */
+	.quad sys_ioprio_set
+	.quad sys_ioprio_get		/* 290 */
+	.quad sys_inotify_init
+	.quad sys_inotify_add_watch
+	.quad sys_inotify_rm_watch
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
 		.quad ni_syscall
diff -uNrp linux-2.6.13-rc3/arch/xen/x86_64/ia32/syscall32.c linux-2.6.13-rc4/arch/xen/x86_64/ia32/syscall32.c
--- linux-2.6.13-rc3/arch/xen/x86_64/ia32/syscall32.c	2005-08-18 17:54:59.491844000 -0600
+++ linux-2.6.13-rc4/arch/xen/x86_64/ia32/syscall32.c	2005-08-18 17:59:20.674604398 -0600
@@ -77,6 +77,7 @@ int syscall32_setup_pages(struct linux_b
 	int npages = (VSYSCALL32_END - VSYSCALL32_BASE) >> PAGE_SHIFT;
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
+	int ret;
 
 	vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
 	if (!vma)
@@ -98,7 +99,11 @@ int syscall32_setup_pages(struct linux_b
 	vma->vm_mm = mm;
 
 	down_write(&mm->mmap_sem);
-	insert_vm_struct(mm, vma);
+	if ((ret = insert_vm_struct(mm, vma))) {
+		up_write(&mm->mmap_sem);
+		kmem_cache_free(vm_area_cachep, vma);
+		return ret;
+	}
 	mm->total_vm += npages;
 	up_write(&mm->mmap_sem);
 	return 0;
diff -uNrp linux-2.6.13-rc3/arch/xen/x86_64/kernel/smpboot.c linux-2.6.13-rc4/arch/xen/x86_64/kernel/smpboot.c
--- linux-2.6.13-rc3/arch/xen/x86_64/kernel/smpboot.c	2005-08-18 17:54:59.752810000 -0600
+++ linux-2.6.13-rc4/arch/xen/x86_64/kernel/smpboot.c	2005-08-18 18:06:27.822608532 -0600
@@ -244,7 +244,7 @@ static __cpuinit void sync_master(void *
 {
 	unsigned long flags, i;
 
-	if (smp_processor_id() != boot_cpu_id)
+	if (smp_processor_id() != 0)
 		return;
 
 	go[MASTER] = 0;
@@ -300,7 +300,7 @@ static __cpuinit void sync_tsc(void)
 	int i, done = 0;
 	long delta, adj, adjust_latency = 0;
 	unsigned long flags, rt, master_time_stamp, bound;
-#if DEBUG_TSC_SYNC
+#ifdef DEBUG_TSC_SYNC
 	static struct syncdebug {
 		long rt;	/* roundtrip time */
 		long master;	/* master's timestamp */
@@ -336,7 +336,7 @@ static __cpuinit void sync_tsc(void)
 				rdtscll(t);
 				wrmsrl(MSR_IA32_TSC, t + adj);
 			}
-#if DEBUG_TSC_SYNC
+#ifdef DEBUG_TSC_SYNC
 			t[i].rt = rt;
 			t[i].master = master_time_stamp;
 			t[i].diff = delta;
@@ -346,7 +346,7 @@ static __cpuinit void sync_tsc(void)
 	}
 	spin_unlock_irqrestore(&tsc_sync_lock, flags);
 
-#if DEBUG_TSC_SYNC
+#ifdef DEBUG_TSC_SYNC
 	for (i = 0; i < NUM_ROUNDS; ++i)
 		printk("rt=%5ld master=%5ld diff=%5ld adjlat=%5ld\n",
 		       t[i].rt, t[i].master, t[i].diff, t[i].lat);
@@ -596,7 +596,7 @@ extern volatile unsigned long init_rsp;
 extern void (*initial_code)(void);
 
 #ifndef CONFIG_XEN
-#if APIC_DEBUG
+#ifdef APIC_DEBUG
 static void inquire_remote_apic(int apicid)
 {
 	unsigned i, regs[] = { APIC_ID >> 4, APIC_LVR >> 4, APIC_SPIV >> 4 };
@@ -1000,7 +1000,7 @@ do_rest:
 			else
 				/* trampoline code not run */
 				printk("Not responding.\n");
-#if APIC_DEBUG
+#ifdef APIC_DEBUG
 			inquire_remote_apic(apicid);
 #endif
 		}
diff -uNrp linux-2.6.13-rc3/include/asm-xen/asm-i386/ptrace.h linux-2.6.13-rc4/include/asm-xen/asm-i386/ptrace.h
--- linux-2.6.13-rc3/include/asm-xen/asm-i386/ptrace.h	2005-08-18 17:54:59.761809000 -0600
+++ linux-2.6.13-rc4/include/asm-xen/asm-i386/ptrace.h	2005-08-18 18:10:53.117829614 -0600
@@ -55,16 +55,26 @@ struct pt_regs {
 #define PTRACE_SET_THREAD_AREA    26
 
 #ifdef __KERNEL__
+
+#include <asm/vm86.h>
+
 struct task_struct;
 extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code);
-#define user_mode(regs)		(2 & (regs)->xcs)
-#define user_mode_vm(regs)	((VM_MASK & (regs)->eflags) || user_mode(regs))
+
+static inline int user_mode(struct pt_regs *regs)
+{
+	return (regs->xcs & 2) != 0;
+}
+static inline int user_mode_vm(struct pt_regs *regs)
+{
+	return ((regs->xcs & 2) | (regs->eflags & VM_MASK)) != 0;
+}
 #define instruction_pointer(regs) ((regs)->eip)
 #if defined(CONFIG_SMP) && defined(CONFIG_FRAME_POINTER)
 extern unsigned long profile_pc(struct pt_regs *regs);
 #else
 #define profile_pc(regs) instruction_pointer(regs)
 #endif
-#endif
+#endif /* __KERNEL__ */
 
 #endif
