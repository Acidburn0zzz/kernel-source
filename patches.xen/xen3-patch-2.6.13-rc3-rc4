Subject: patch-2.6.13-rc4
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

Automatically created from "patches.fixes/patch-2.6.13-rc3-rc4" by xen-port-patches.py
Further porting to arch/xen by kys, ccoffing, and jbeulich

Index: xen-2005-08-19/arch/xen/i386/kernel/process.c
===================================================================
--- xen-2005-08-19.orig/arch/xen/i386/kernel/process.c	2005-08-19 12:12:43.556747096 +0200
+++ xen-2005-08-19/arch/xen/i386/kernel/process.c	2005-08-19 12:38:47.958921816 +0200
@@ -609,9 +609,14 @@
 
 	/*
 	 * Restore %fs and %gs if needed.
+	 *
+	 * Glibc normally makes %fs be zero, and %gs is one of
+	 * the TLS segments.
 	 */
-	if (unlikely(next->fs | next->gs)) {
+	if (unlikely(next->fs | prev->fs)) {
 		loadsegment(fs, next->fs);
+	}
+	if (prev->gs | next->gs) {
 		loadsegment(gs, next->gs);
 	}
 
@@ -619,13 +624,13 @@
 	 * Now maybe reload the debug registers
 	 */
 	if (unlikely(next->debugreg[7])) {
-		set_debugreg(next->thread.debugreg[0], 0);
-		set_debugreg(next->thread.debugreg[1], 1);
-		set_debugreg(next->thread.debugreg[2], 2);
-		set_debugreg(next->thread.debugreg[3], 3);
+		set_debugreg(next->debugreg[0], 0);
+		set_debugreg(next->debugreg[1], 1);
+		set_debugreg(next->debugreg[2], 2);
+		set_debugreg(next->debugreg[3], 3);
 		/* no 4 and 5 */
-		set_debugreg(next->thread.debugreg[6], 6);
-		set_debugreg(next->thread.debugreg[7], 7);
+		set_debugreg(next->debugreg[6], 6);
+		set_debugreg(next->debugreg[7], 7);
 	}
 
 	disable_tsc(prev_p, next_p);
@@ -819,6 +824,8 @@
 	if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
 		return -EINVAL;
 
+	memset(&info, 0, sizeof(info));
+
 	desc = current->thread.tls_array + idx - GDT_ENTRY_TLS_MIN;
 
 	info.entry_number = idx;
Index: xen-2005-08-19/arch/xen/i386/kernel/setup.c
===================================================================
--- xen-2005-08-19.orig/arch/xen/i386/kernel/setup.c	2005-08-19 12:12:43.555747248 +0200
+++ xen-2005-08-19/arch/xen/i386/kernel/setup.c	2005-08-19 12:38:47.962921208 +0200
@@ -1472,7 +1472,7 @@
    This runs before SMP is initialized to avoid SMP problems with
    self modifying code. This implies that assymetric systems where
    APs have less capabilities than the boot processor are not handled. 
-   In this case boot with "noreplacement". */ 
+   Tough. Make sure you disable such features by hand. */
 void apply_alternatives(void *start, void *end) 
 { 
 	struct alt_instr *a; 
@@ -1500,24 +1500,12 @@
 	}
 } 
 
-static int no_replacement __initdata = 0; 
- 
 void __init alternative_instructions(void)
 {
 	extern struct alt_instr __alt_instructions[], __alt_instructions_end[];
-	if (no_replacement) 
-		return;
 	apply_alternatives(__alt_instructions, __alt_instructions_end);
 }
 
-static int __init noreplacement_setup(char *s)
-{ 
-     no_replacement = 1; 
-     return 0; 
-} 
-
-__setup("noreplacement", noreplacement_setup); 
-
 static char * __init machine_specific_memory_setup(void);
 
 #ifdef CONFIG_MCA
Index: xen-2005-08-19/arch/xen/i386/pci/irq.c
===================================================================
--- xen-2005-08-19.orig/arch/xen/i386/pci/irq.c	2005-08-19 12:37:56.084807880 +0200
+++ xen-2005-08-19/arch/xen/i386/pci/irq.c	2005-08-19 12:48:30.586348984 +0200
@@ -556,6 +556,13 @@
 static __init int via_router_probe(struct irq_router *r, struct pci_dev *router, u16 device)
 {
 	/* FIXME: We should move some of the quirk fixup stuff here */
+
+	if (router->device == PCI_DEVICE_ID_VIA_82C686 &&
+			device == PCI_DEVICE_ID_VIA_82C586_0) {
+		/* Asus k7m bios wrongly reports 82C686A as 586-compatible */
+		device = PCI_DEVICE_ID_VIA_82C686;
+	}
+
 	switch(device)
 	{
 		case PCI_DEVICE_ID_VIA_82C586_0:
Index: xen-2005-08-19/arch/xen/Kconfig.debug
===================================================================
--- xen-2005-08-19.orig/arch/xen/Kconfig.debug	2005-08-19 12:12:43.557746944 +0200
+++ xen-2005-08-19/arch/xen/Kconfig.debug	2005-08-19 12:38:47.979918624 +0200
@@ -20,6 +20,9 @@
 config DEBUG_STACKOVERFLOW
 	bool "Check for stack overflows"
 	depends on DEBUG_KERNEL && X86
+	help
+	  This option will cause messages to be printed if free stack space
+	  drops below a certain limit.
 
 config KPROBES
 	bool "Kprobes"
Index: xen-2005-08-19/arch/xen/x86_64/ia32/ia32entry.S
===================================================================
--- xen-2005-08-19.orig/arch/xen/x86_64/ia32/ia32entry.S	2005-08-19 12:12:43.558746792 +0200
+++ xen-2005-08-19/arch/xen/x86_64/ia32/ia32entry.S	2005-08-19 12:38:47.982918168 +0200
@@ -618,11 +618,15 @@
 	.quad compat_sys_mq_getsetattr
 	.quad compat_sys_kexec_load	/* reserved for kexec */
 	.quad compat_sys_waitid
-	.quad quiet_ni_syscall		/* sys_altroot */
+	.quad quiet_ni_syscall		/* 285: sys_altroot */
 	.quad sys_add_key
 	.quad sys_request_key
 	.quad sys_keyctl
-	/* don't forget to change IA32_NR_syscalls */
+	.quad sys_ioprio_set
+	.quad sys_ioprio_get		/* 290 */
+	.quad sys_inotify_init
+	.quad sys_inotify_add_watch
+	.quad sys_inotify_rm_watch
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
 		.quad ni_syscall
Index: xen-2005-08-19/arch/xen/x86_64/ia32/syscall32.c
===================================================================
--- xen-2005-08-19.orig/arch/xen/x86_64/ia32/syscall32.c	2005-08-19 12:12:43.557746944 +0200
+++ xen-2005-08-19/arch/xen/x86_64/ia32/syscall32.c	2005-08-19 12:48:30.589348528 +0200
@@ -77,6 +77,7 @@
 	int npages = (VSYSCALL32_END - VSYSCALL32_BASE) >> PAGE_SHIFT;
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
+	int ret;
 
 	vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
 	if (!vma)
@@ -98,7 +99,11 @@
 	vma->vm_mm = mm;
 
 	down_write(&mm->mmap_sem);
-	insert_vm_struct(mm, vma);
+	if ((ret = insert_vm_struct(mm, vma))) {
+		up_write(&mm->mmap_sem);
+		kmem_cache_free(vm_area_cachep, vma);
+		return ret;
+	}
 	mm->total_vm += npages;
 	up_write(&mm->mmap_sem);
 	return 0;
Index: xen-2005-08-19/arch/xen/x86_64/kernel/smpboot.c
===================================================================
--- xen-2005-08-19.orig/arch/xen/x86_64/kernel/smpboot.c	2005-08-19 12:12:43.559746640 +0200
+++ xen-2005-08-19/arch/xen/x86_64/kernel/smpboot.c	2005-08-19 12:48:30.592348072 +0200
@@ -244,7 +244,7 @@
 {
 	unsigned long flags, i;
 
-	if (smp_processor_id() != boot_cpu_id)
+	if (smp_processor_id() != 0)
 		return;
 
 	go[MASTER] = 0;
@@ -300,7 +300,7 @@
 	int i, done = 0;
 	long delta, adj, adjust_latency = 0;
 	unsigned long flags, rt, master_time_stamp, bound;
-#if DEBUG_TSC_SYNC
+#ifdef DEBUG_TSC_SYNC
 	static struct syncdebug {
 		long rt;	/* roundtrip time */
 		long master;	/* master's timestamp */
@@ -336,7 +336,7 @@
 				rdtscll(t);
 				wrmsrl(MSR_IA32_TSC, t + adj);
 			}
-#if DEBUG_TSC_SYNC
+#ifdef DEBUG_TSC_SYNC
 			t[i].rt = rt;
 			t[i].master = master_time_stamp;
 			t[i].diff = delta;
@@ -346,7 +346,7 @@
 	}
 	spin_unlock_irqrestore(&tsc_sync_lock, flags);
 
-#if DEBUG_TSC_SYNC
+#ifdef DEBUG_TSC_SYNC
 	for (i = 0; i < NUM_ROUNDS; ++i)
 		printk("rt=%5ld master=%5ld diff=%5ld adjlat=%5ld\n",
 		       t[i].rt, t[i].master, t[i].diff, t[i].lat);
@@ -596,7 +596,7 @@
 extern void (*initial_code)(void);
 
 #ifndef CONFIG_XEN
-#if APIC_DEBUG
+#ifdef APIC_DEBUG
 static void inquire_remote_apic(int apicid)
 {
 	unsigned i, regs[] = { APIC_ID >> 4, APIC_LVR >> 4, APIC_SPIV >> 4 };
@@ -1000,7 +1000,7 @@
 			else
 				/* trampoline code not run */
 				printk("Not responding.\n");
-#if APIC_DEBUG
+#ifdef APIC_DEBUG
 			inquire_remote_apic(apicid);
 #endif
 		}
Index: xen-2005-08-19/include/asm-xen/asm-i386/ptrace.h
===================================================================
--- xen-2005-08-19.orig/include/asm-xen/asm-i386/ptrace.h	2005-08-19 12:12:43.560746488 +0200
+++ xen-2005-08-19/include/asm-xen/asm-i386/ptrace.h	2005-08-19 12:38:47.990916952 +0200
@@ -55,16 +55,26 @@
 #define PTRACE_SET_THREAD_AREA    26
 
 #ifdef __KERNEL__
+
+#include <asm/vm86.h>
+
 struct task_struct;
 extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code);
-#define user_mode(regs)		(2 & (regs)->xcs)
-#define user_mode_vm(regs)	((VM_MASK & (regs)->eflags) || user_mode(regs))
+
+static inline int user_mode(struct pt_regs *regs)
+{
+	return (regs->xcs & 2) != 0;
+}
+static inline int user_mode_vm(struct pt_regs *regs)
+{
+	return ((regs->xcs & 2) | (regs->eflags & VM_MASK)) != 0;
+}
 #define instruction_pointer(regs) ((regs)->eip)
 #if defined(CONFIG_SMP) && defined(CONFIG_FRAME_POINTER)
 extern unsigned long profile_pc(struct pt_regs *regs);
 #else
 #define profile_pc(regs) instruction_pointer(regs)
 #endif
-#endif
+#endif /* __KERNEL__ */
 
 #endif
Index: xen-2005-08-19/arch/xen/kernel/reboot.c
===================================================================
--- xen-2005-08-19.orig/arch/xen/kernel/reboot.c	2005-08-19 08:49:22.000000000 +0200
+++ xen-2005-08-19/arch/xen/kernel/reboot.c	2005-08-19 12:49:23.545298000 +0200
@@ -30,6 +30,11 @@
 	HYPERVISOR_reboot();
 }
 
+void machine_emergency_restart(void)
+{
+	machine_restart(NULL);
+}
+
 void machine_halt(void)
 {
 	machine_power_off();
