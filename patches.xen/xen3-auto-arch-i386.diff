Subject: xen3 arch-i386
From: http://xenbits.xensource.com/linux-2.6.18-xen.hg (tip 425:9dea529497fe)
Patch-mainline: obsolete
Acked-by: jbeulich@novell.com

Index: head-2008-02-20/arch/x86/Makefile_32
===================================================================
--- head-2008-02-20.orig/arch/x86/Makefile_32	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/Makefile_32	2008-02-20 10:27:45.000000000 +0100
@@ -89,6 +89,10 @@ mcore-$(CONFIG_X86_BIGSMP)	:= arch/x86/m
 mflags-$(CONFIG_X86_SUMMIT) := -Iinclude/asm-x86/mach-summit
 mcore-$(CONFIG_X86_SUMMIT)  := arch/x86/mach-default
 
+# Xen subarch support
+mflags-$(CONFIG_X86_XEN)	:= -Iinclude/asm-i386/mach-xen
+mcore-$(CONFIG_X86_XEN)		:= mach-xen
+
 # generic subarchitecture
 mflags-$(CONFIG_X86_GENERICARCH) := -Iinclude/asm-x86/mach-generic
 mcore-$(CONFIG_X86_GENERICARCH) := arch/x86/mach-default
@@ -128,9 +132,20 @@ KBUILD_AFLAGS += $(mflags-y)
 
 boot := arch/x86/boot
 
-PHONY += zImage bzImage compressed zlilo bzlilo \
+PHONY += zImage bzImage vmlinuz compressed zlilo bzlilo \
          zdisk bzdisk fdimage fdimage144 fdimage288 isoimage install
 
+ifdef CONFIG_XEN
+CPPFLAGS := -D__XEN_INTERFACE_VERSION__=$(CONFIG_XEN_INTERFACE_VERSION) \
+	-Iinclude$(if $(KBUILD_SRC),2)/asm/mach-xen $(CPPFLAGS)
+all: vmlinuz
+
+# KBUILD_IMAGE specifies the target image being built
+KBUILD_IMAGE := $(boot)/vmlinuz
+
+vmlinuz: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(KBUILD_IMAGE)
+else
 all: bzImage
 
 # KBUILD_IMAGE specify target image being built
@@ -152,6 +167,7 @@ zdisk bzdisk: vmlinux
 
 fdimage fdimage144 fdimage288 isoimage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(KBUILD_IMAGE) $@
+endif
 
 install:
 	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(KBUILD_IMAGE) install
Index: head-2008-02-20/arch/x86/boot/Makefile
===================================================================
--- head-2008-02-20.orig/arch/x86/boot/Makefile	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/boot/Makefile	2008-02-20 10:27:45.000000000 +0100
@@ -25,7 +25,7 @@ SVGA_MODE := -DSVGA_MODE=NORMAL_VGA
 
 #RAMDISK := -DRAMDISK=512
 
-targets		:= vmlinux.bin setup.bin setup.elf zImage bzImage
+targets		:= vmlinux.bin setup.bin setup.elf zImage bzImage vmlinuz vmlinux-stripped
 subdir- 	:= compressed
 
 setup-y		+= a20.o apm.o cmdline.o copy.o cpu.o cpucheck.o edd.o
@@ -168,5 +168,13 @@ zlilo: $(BOOTIMAGE)
 	cp System.map $(INSTALL_PATH)/
 	if [ -x /sbin/lilo ]; then /sbin/lilo; else /etc/lilo/install; fi
 
+$(obj)/vmlinuz: $(obj)/vmlinux-stripped FORCE
+	$(call if_changed,gzip)
+	@echo 'Kernel: $@ is ready' ' (#'`cat .version`')'
+
+$(obj)/vmlinux-stripped: OBJCOPYFLAGS := -g --strip-unneeded
+$(obj)/vmlinux-stripped: vmlinux FORCE
+	$(call if_changed,objcopy)
+
 install:
 	sh $(srctree)/$(src)/install.sh $(KERNELRELEASE) $(BOOTIMAGE) System.map "$(INSTALL_PATH)"
Index: head-2008-02-20/arch/x86/kernel/Makefile_32
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/Makefile_32	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/Makefile_32	2008-02-20 10:27:45.000000000 +0100
@@ -49,6 +49,7 @@ obj-$(CONFIG_PARAVIRT)		+= paravirt_32.o
 obj-y				+= pcspeaker.o
 
 obj-$(CONFIG_SCx200)		+= scx200_32.o
+obj-$(CONFIG_XEN)		+= fixup.o
 
 # vsyscall_32.o contains the vsyscall DSO images as __initdata.
 # We must build both images before we can assemble it.
@@ -86,4 +87,5 @@ $(obj)/vsyscall-syms.o: $(src)/vsyscall_
 			$(obj)/vsyscall-sysenter_32.o $(obj)/vsyscall-note_32.o FORCE
 	$(call if_changed,syscall)
 
-
+disabled-obj-$(CONFIG_XEN) := i8259.o reboot.o smpboot.o trampoline.o
+%/head.o %/head.s: $(if $(CONFIG_XEN),EXTRA_AFLAGS,dummy) :=
Index: head-2008-02-20/arch/x86/kernel/acpi/Makefile
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/acpi/Makefile	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/acpi/Makefile	2008-02-20 10:27:45.000000000 +0100
@@ -5,3 +5,4 @@ ifneq ($(CONFIG_ACPI_PROCESSOR),)
 obj-y				+= cstate.o processor.o
 endif
 
+disabled-obj-$(CONFIG_XEN)	:= cstate.o wakeup.o
Index: head-2008-02-20/arch/x86/kernel/asm-offsets_32.c
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/asm-offsets_32.c	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/asm-offsets_32.c	2008-02-20 10:27:45.000000000 +0100
@@ -101,9 +101,14 @@ void foo(void)
 	OFFSET(pbe_orig_address, pbe, orig_address);
 	OFFSET(pbe_next, pbe, next);
 
+#ifndef CONFIG_X86_NO_TSS
 	/* Offset from the sysenter stack to tss.esp0 */
-	DEFINE(TSS_sysenter_esp0, offsetof(struct tss_struct, x86_tss.esp0) -
+	DEFINE(SYSENTER_stack_esp0, offsetof(struct tss_struct, x86_tss.esp0) -
 		 sizeof(struct tss_struct));
+#else
+	/* sysenter stack points directly to esp0 */
+	DEFINE(SYSENTER_stack_esp0, 0);
+#endif
 
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
 	DEFINE(PAGE_SHIFT_asm, PAGE_SHIFT);
Index: head-2008-02-20/arch/x86/kernel/cpu/mtrr/Makefile
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/cpu/mtrr/Makefile	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/cpu/mtrr/Makefile	2008-02-20 10:27:45.000000000 +0100
@@ -1,3 +1,4 @@
 obj-y		:= main.o if.o generic.o state.o
 obj-$(CONFIG_X86_32) += amd.o cyrix.o centaur.o
 
+obj-$(CONFIG_XEN) := main.o if.o
Index: head-2008-02-20/arch/x86/kernel/crash.c
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/crash.c	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/crash.c	2008-02-20 10:27:45.000000000 +0100
@@ -35,6 +35,7 @@
 /* This keeps a track of which one is crashing cpu. */
 static int crashing_cpu;
 
+#ifndef CONFIG_XEN
 #if defined(CONFIG_SMP) && defined(CONFIG_X86_LOCAL_APIC)
 static atomic_t waiting_for_crash_ipi;
 
@@ -120,6 +121,7 @@ static void nmi_shootdown_cpus(void)
 	/* There are no cpus to shootdown */
 }
 #endif
+#endif /* CONFIG_XEN */
 
 void machine_crash_shutdown(struct pt_regs *regs)
 {
@@ -136,11 +138,13 @@ void machine_crash_shutdown(struct pt_re
 
 	/* Make a note of crashing cpu. Will be used in NMI callback.*/
 	crashing_cpu = safe_smp_processor_id();
+#ifndef CONFIG_XEN
 	nmi_shootdown_cpus();
 	lapic_shutdown();
 #if defined(CONFIG_X86_IO_APIC)
 	disable_IO_APIC();
 #endif
+#endif /* CONFIG_XEN */
 #ifdef CONFIG_HPET_TIMER
 	hpet_disable();
 #endif
Index: head-2008-02-20/arch/x86/kernel/entry_32.S
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/entry_32.S	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/entry_32.S	2008-02-20 10:27:45.000000000 +0100
@@ -288,7 +288,7 @@ ENTRY(sysenter_entry)
 	CFI_SIGNAL_FRAME
 	CFI_DEF_CFA esp, 0
 	CFI_REGISTER esp, ebp
-	movl TSS_sysenter_esp0(%esp),%esp
+	movl SYSENTER_stack_esp0(%esp),%esp
 sysenter_past_esp:
 	/*
 	 * No need to follow this irqs on/off section: the syscall
@@ -743,7 +743,7 @@ END(device_not_available)
  * that sets up the real kernel stack. Check here, since we can't
  * allow the wrong stack to be used.
  *
- * "TSS_sysenter_esp0+12" is because the NMI/debug handler will have
+ * "SYSENTER_stack_esp0+12" is because the NMI/debug handler will have
  * already pushed 3 words if it hits on the sysenter instruction:
  * eflags, cs and eip.
  *
@@ -755,7 +755,7 @@ END(device_not_available)
 	cmpw $__KERNEL_CS,4(%esp);		\
 	jne ok;					\
 label:						\
-	movl TSS_sysenter_esp0+offset(%esp),%esp;	\
+	movl SYSENTER_stack_esp0+offset(%esp),%esp;	\
 	CFI_DEF_CFA esp, 0;			\
 	CFI_UNDEFINED eip;			\
 	pushfl;					\
Index: head-2008-02-20/arch/x86/kernel/machine_kexec_32.c
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/machine_kexec_32.c	2008-02-20 10:22:45.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/machine_kexec_32.c	2008-02-20 10:27:45.000000000 +0100
@@ -21,6 +21,10 @@
 #include <asm/desc.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_XEN
+#include <xen/interface/kexec.h>
+#endif
+
 #define PAGE_ALIGNED __attribute__ ((__aligned__(PAGE_SIZE)))
 static u32 kexec_pgd[1024] PAGE_ALIGNED;
 #ifdef CONFIG_X86_PAE
@@ -30,6 +34,40 @@ static u32 kexec_pmd1[1024] PAGE_ALIGNED
 static u32 kexec_pte0[1024] PAGE_ALIGNED;
 static u32 kexec_pte1[1024] PAGE_ALIGNED;
 
+#ifdef CONFIG_XEN
+
+#define __ma(x) (pfn_to_mfn(__pa((x)) >> PAGE_SHIFT) << PAGE_SHIFT)
+
+#if PAGES_NR > KEXEC_XEN_NO_PAGES
+#error PAGES_NR is greater than KEXEC_XEN_NO_PAGES - Xen support will break
+#endif
+
+#if PA_CONTROL_PAGE != 0
+#error PA_CONTROL_PAGE is non zero - Xen support will break
+#endif
+
+void machine_kexec_setup_load_arg(xen_kexec_image_t *xki, struct kimage *image)
+{
+	void *control_page;
+
+	memset(xki->page_list, 0, sizeof(xki->page_list));
+
+	control_page = page_address(image->control_code_page);
+	memcpy(control_page, relocate_kernel, PAGE_SIZE);
+
+	xki->page_list[PA_CONTROL_PAGE] = __ma(control_page);
+	xki->page_list[PA_PGD] = __ma(kexec_pgd);
+#ifdef CONFIG_X86_PAE
+	xki->page_list[PA_PMD_0] = __ma(kexec_pmd0);
+	xki->page_list[PA_PMD_1] = __ma(kexec_pmd1);
+#endif
+	xki->page_list[PA_PTE_0] = __ma(kexec_pte0);
+	xki->page_list[PA_PTE_1] = __ma(kexec_pte1);
+
+}
+
+#endif /* CONFIG_XEN */
+
 /*
  * A architecture hook called to validate the
  * proposed image and prepare the control pages
@@ -56,6 +94,7 @@ void machine_kexec_cleanup(struct kimage
 {
 }
 
+#ifndef CONFIG_XEN
 /*
  * Do not allocate memory (or fail in any way) in machine_kexec().
  * We are past the point of no return, committed to rebooting now.
@@ -89,6 +128,7 @@ NORET_TYPE void machine_kexec(struct kim
 	relocate_kernel((unsigned long)image->head, (unsigned long)page_list,
 			image->start, cpu_has_pae);
 }
+#endif
 
 void arch_crash_save_vmcoreinfo(void)
 {
Index: head-2008-02-20/arch/x86/kernel/sysenter_32.c
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/sysenter_32.c	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/sysenter_32.c	2008-02-20 10:27:45.000000000 +0100
@@ -36,6 +36,10 @@ enum {
 #define VDSO_DEFAULT	VDSO_ENABLED
 #endif
 
+#ifdef CONFIG_XEN
+#include <xen/interface/callback.h>
+#endif
+
 /*
  * Should the kernel map a VDSO page into processes and pass its
  * address down to glibc upon exec()?
@@ -174,6 +178,7 @@ static __init void relocate_vdso(Elf32_E
 
 void enable_sep_cpu(void)
 {
+#ifndef CONFIG_XEN
 	int cpu = get_cpu();
 	struct tss_struct *tss = &per_cpu(init_tss, cpu);
 
@@ -187,7 +192,36 @@ void enable_sep_cpu(void)
 	wrmsr(MSR_IA32_SYSENTER_CS, __KERNEL_CS, 0);
 	wrmsr(MSR_IA32_SYSENTER_ESP, tss->x86_tss.esp1, 0);
 	wrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long) sysenter_entry, 0);
-	put_cpu();	
+#else
+	extern asmlinkage void sysenter_entry_pv(void);
+	static struct callback_register sysenter = {
+		.type = CALLBACKTYPE_sysenter,
+		.address = { __KERNEL_CS, (unsigned long)sysenter_entry_pv },
+	};
+
+	if (!boot_cpu_has(X86_FEATURE_SEP))
+		return;
+
+	get_cpu();
+
+	if (xen_feature(XENFEAT_supervisor_mode_kernel))
+		sysenter.address.eip = (unsigned long)sysenter_entry;
+
+	switch (HYPERVISOR_callback_op(CALLBACKOP_register, &sysenter)) {
+	case 0:
+		break;
+#if CONFIG_XEN_COMPAT < 0x030200
+	case -ENOSYS:
+		sysenter.type = CALLBACKTYPE_sysenter_deprecated;
+		if (HYPERVISOR_callback_op(CALLBACKOP_register, &sysenter) == 0)
+			break;
+#endif
+	default:
+		clear_bit(X86_FEATURE_SEP, boot_cpu_data.x86_capability);
+		break;
+	}
+#endif
+	put_cpu();
 }
 
 static struct vm_area_struct gate_vma;
Index: head-2008-02-20/arch/x86/kernel/traps_32.c
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/traps_32.c	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/traps_32.c	2008-02-20 10:27:45.000000000 +0100
@@ -729,18 +729,11 @@ mem_parity_error(unsigned char reason, s
 static __kprobes void
 io_check_error(unsigned char reason, struct pt_regs * regs)
 {
-	unsigned long i;
-
 	printk(KERN_EMERG "NMI: IOCK error (debug interrupt?)\n");
 	show_registers(regs);
 
 	/* Re-enable the IOCK line, wait for a few seconds */
-	reason = (reason & 0xf) | 8;
-	outb(reason, 0x61);
-	i = 2000;
-	while (--i) udelay(1000);
-	reason &= ~8;
-	outb(reason, 0x61);
+	clear_io_check_error(reason);
 }
 
 static __kprobes void
Index: head-2008-02-20/arch/x86/kernel/vm86_32.c
===================================================================
--- head-2008-02-20.orig/arch/x86/kernel/vm86_32.c	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/kernel/vm86_32.c	2008-02-20 10:27:45.000000000 +0100
@@ -123,7 +123,9 @@ static int copy_vm86_regs_from_user(stru
 struct pt_regs * FASTCALL(save_v86_state(struct kernel_vm86_regs * regs));
 struct pt_regs * fastcall save_v86_state(struct kernel_vm86_regs * regs)
 {
+#ifndef CONFIG_X86_NO_TSS
 	struct tss_struct *tss;
+#endif
 	struct pt_regs *ret;
 	unsigned long tmp;
 
@@ -146,12 +148,16 @@ struct pt_regs * fastcall save_v86_state
 		do_exit(SIGSEGV);
 	}
 
+#ifndef CONFIG_X86_NO_TSS
 	tss = &per_cpu(init_tss, get_cpu());
+#endif
 	current->thread.esp0 = current->thread.saved_esp0;
 	current->thread.sysenter_cs = __KERNEL_CS;
 	load_esp0(tss, &current->thread);
 	current->thread.saved_esp0 = 0;
+#ifndef CONFIG_X86_NO_TSS
 	put_cpu();
+#endif
 
 	ret = KVM86->regs32;
 
@@ -277,7 +283,9 @@ out:
 
 static void do_sys_vm86(struct kernel_vm86_struct *info, struct task_struct *tsk)
 {
+#ifndef CONFIG_X86_NO_TSS
 	struct tss_struct *tss;
+#endif
 /*
  * make sure the vm86() system call doesn't try to do anything silly
  */
@@ -322,12 +330,16 @@ static void do_sys_vm86(struct kernel_vm
 	tsk->thread.saved_fs = info->regs32->xfs;
 	savesegment(gs, tsk->thread.saved_gs);
 
+#ifndef CONFIG_X86_NO_TSS
 	tss = &per_cpu(init_tss, get_cpu());
+#endif
 	tsk->thread.esp0 = (unsigned long) &info->VM86_TSS_ESP0;
 	if (cpu_has_sep)
 		tsk->thread.sysenter_cs = 0;
 	load_esp0(tss, &tsk->thread);
+#ifndef CONFIG_X86_NO_TSS
 	put_cpu();
+#endif
 
 	tsk->thread.screen_bitmap = info->screen_bitmap;
 	if (info->flags & VM86_SCREEN_BITMAP)
Index: head-2008-02-20/arch/x86/lib/Makefile
===================================================================
--- head-2008-02-20.orig/arch/x86/lib/Makefile	2008-01-24 23:58:37.000000000 +0100
+++ head-2008-02-20/arch/x86/lib/Makefile	2008-02-20 10:27:45.000000000 +0100
@@ -3,3 +3,5 @@ include ${srctree}/arch/x86/lib/Makefile
 else
 include ${srctree}/arch/x86/lib/Makefile_64
 endif
+
+lib-$(CONFIG_XEN_SCRUB_PAGES) += scrub.o
Index: head-2008-02-20/arch/x86/mm/Makefile_32
===================================================================
--- head-2008-02-20.orig/arch/x86/mm/Makefile_32	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/mm/Makefile_32	2008-02-20 10:27:45.000000000 +0100
@@ -8,3 +8,4 @@ obj-$(CONFIG_NUMA) += discontig_32.o
 obj-$(CONFIG_HUGETLB_PAGE) += hugetlbpage.o
 obj-$(CONFIG_HIGHMEM) += highmem_32.o
 obj-$(CONFIG_BOOT_IOREMAP) += boot_ioremap_32.o
+obj-$(CONFIG_XEN) += hypervisor.o
Index: head-2008-02-20/arch/x86/oprofile/Makefile
===================================================================
--- head-2008-02-20.orig/arch/x86/oprofile/Makefile	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/oprofile/Makefile	2008-02-20 10:27:45.000000000 +0100
@@ -6,7 +6,14 @@ DRIVER_OBJS = $(addprefix ../../../drive
 		oprofilefs.o oprofile_stats.o  \
 		timer_int.o )
 
+ifdef CONFIG_XEN
+XENOPROF_COMMON_OBJS = $(addprefix ../../../drivers/xen/xenoprof/, \
+			 xenoprofile.o)
+oprofile-y				:= $(DRIVER_OBJS) \
+					   $(XENOPROF_COMMON_OBJS) xenoprof.o
+else 
 oprofile-y				:= $(DRIVER_OBJS) init.o backtrace.o
 oprofile-$(CONFIG_X86_LOCAL_APIC) 	+= nmi_int.o op_model_athlon.o \
 					   op_model_ppro.o op_model_p4.o
 oprofile-$(CONFIG_X86_IO_APIC)		+= nmi_timer_int.o
+endif
Index: head-2008-02-20/arch/x86/pci/Makefile_32
===================================================================
--- head-2008-02-20.orig/arch/x86/pci/Makefile_32	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/pci/Makefile_32	2008-02-20 10:27:45.000000000 +0100
@@ -4,6 +4,10 @@ obj-$(CONFIG_PCI_BIOS)		+= pcbios.o
 obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig_32.o direct.o mmconfig-shared.o
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
 
+# pcifront should be after pcbios.o, mmconfig.o, and direct.o as it should only
+# take over if direct access to the PCI bus is unavailable
+obj-$(CONFIG_XEN_PCIDEV_FRONTEND)	+= pcifront.o
+
 pci-y				:= fixup.o
 pci-$(CONFIG_ACPI)		+= acpi.o
 pci-y				+= legacy.o irq.o
Index: head-2008-02-20/arch/x86/power/Makefile
===================================================================
--- head-2008-02-20.orig/arch/x86/power/Makefile	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/power/Makefile	2008-02-20 10:27:45.000000000 +0100
@@ -1,2 +1,4 @@
-obj-$(CONFIG_PM)		+= cpu.o
+obj-$(subst m,y,$(CONFIG_APM))	+= cpu.o
+obj-$(CONFIG_SOFTWARE_SUSPEND)	+= cpu.o
+obj-$(CONFIG_ACPI_SLEEP)	+= cpu.o
 obj-$(CONFIG_HIBERNATION)	+= swsusp.o suspend.o
Index: head-2008-02-20/arch/x86/power/cpu.c
===================================================================
--- head-2008-02-20.orig/arch/x86/power/cpu.c	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/arch/x86/power/cpu.c	2008-02-20 10:27:45.000000000 +0100
@@ -63,11 +63,12 @@ static void do_fpu_end(void)
 
 static void fix_processor_context(void)
 {
+#ifndef CONFIG_X86_NO_TSS
 	int cpu = smp_processor_id();
 	struct tss_struct * t = &per_cpu(init_tss, cpu);
 
 	set_tss_desc(cpu,t);	/* This just modifies memory; should not be necessary. But... This is necessary, because 386 hardware has concept of busy TSS or some similar stupidity. */
-
+#endif
 	load_TR_desc();				/* This does ltr */
 	load_LDT(&current->active_mm->context);	/* This does lldt */
 
Index: head-2008-02-20/include/asm-x86/acpi_32.h
===================================================================
--- head-2008-02-20.orig/include/asm-x86/acpi_32.h	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/include/asm-x86/acpi_32.h	2008-02-20 10:27:45.000000000 +0100
@@ -126,6 +126,11 @@ extern unsigned long acpi_wakeup_address
 /* early initialization routine */
 extern void acpi_reserve_bootmem(void);
 
+#ifdef CONFIG_ACPI_PV_SLEEP
+extern int acpi_notify_hypervisor_state(u8 sleep_state,
+	u32 pm1a_cnt, u32 pm1b_cnt);
+#endif /* CONFIG_ACPI_PV_SLEEP */
+
 #else	/* !CONFIG_ACPI */
 
 #define acpi_lapic 0
@@ -136,7 +141,9 @@ static inline void disable_acpi(void) { 
 
 #endif	/* !CONFIG_ACPI */
 
+#ifndef CONFIG_XEN
 #define ARCH_HAS_POWER_INIT	1
+#endif
 
 #endif /*__KERNEL__*/
 
Index: head-2008-02-20/include/asm-x86/apic_32.h
===================================================================
--- head-2008-02-20.orig/include/asm-x86/apic_32.h	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/include/asm-x86/apic_32.h	2008-02-20 10:27:45.000000000 +0100
@@ -111,7 +111,9 @@ extern int APIC_init_uniprocessor (void)
 
 extern void enable_NMI_through_LVT0 (void * dummy);
 
+#ifndef CONFIG_XEN
 #define ARCH_APICTIMER_STOPS_ON_C3	1
+#endif
 
 extern int timer_over_8254;
 extern int local_apic_timer_c2_ok;
Index: head-2008-02-20/include/asm-x86/kexec_32.h
===================================================================
--- head-2008-02-20.orig/include/asm-x86/kexec_32.h	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/include/asm-x86/kexec_32.h	2008-02-20 10:27:45.000000000 +0100
@@ -94,6 +94,19 @@ relocate_kernel(unsigned long indirectio
 		unsigned long start_address,
 		unsigned int has_pae) ATTRIB_NORET;
 
+/* Under Xen we need to work with machine addresses. These macros give the
+ * machine address of a certain page to the generic kexec code instead of 
+ * the pseudo physical address which would be given by the default macros.
+ */
+
+#ifdef CONFIG_XEN
+#define KEXEC_ARCH_HAS_PAGE_MACROS
+#define kexec_page_to_pfn(page)  pfn_to_mfn(page_to_pfn(page))
+#define kexec_pfn_to_page(pfn)   pfn_to_page(mfn_to_pfn(pfn))
+#define kexec_virt_to_phys(addr) virt_to_machine(addr)
+#define kexec_phys_to_virt(addr) phys_to_virt(machine_to_phys(addr))
+#endif
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _I386_KEXEC_H */
Index: head-2008-02-20/include/asm-x86/mach-default/mach_traps.h
===================================================================
--- head-2008-02-20.orig/include/asm-x86/mach-default/mach_traps.h	2008-02-20 09:26:06.000000000 +0100
+++ head-2008-02-20/include/asm-x86/mach-default/mach_traps.h	2008-02-20 10:27:45.000000000 +0100
@@ -15,6 +15,18 @@ static inline void clear_mem_error(unsig
 	outb(reason, 0x61);
 }
 
+static inline void clear_io_check_error(unsigned char reason)
+{
+	unsigned long i;
+
+	reason = (reason & 0xf) | 8;
+	outb(reason, 0x61);
+	i = 2000;
+	while (--i) udelay(1000);
+	reason &= ~8;
+	outb(reason, 0x61);
+}
+
 static inline unsigned char get_nmi_reason(void)
 {
 	return inb(0x61);
