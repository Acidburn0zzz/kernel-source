Subject: xen3 arch-i386
From: http://xenbits.xensource.com/xen-3.0.3-testing.hg (tip 11772)
Patch-mainline: obsolete
Acked-by: jbeulich@novell.com

Index: head-2006-10-16/arch/i386/kernel/acpi/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/kernel/acpi/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/kernel/acpi/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -6,3 +6,7 @@ ifneq ($(CONFIG_ACPI_PROCESSOR),)
 obj-y				+= cstate.o processor.o
 endif
 
+ifdef CONFIG_XEN
+include $(srctree)/scripts/Makefile.xen
+obj-y := $(call cherrypickxen, $(obj-y), $(src))
+endif
Index: head-2006-10-16/arch/i386/kernel/asm-offsets.c
===================================================================
--- head-2006-10-16.orig/arch/i386/kernel/asm-offsets.c	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/kernel/asm-offsets.c	2006-10-16 10:09:20.000000000 +0200
@@ -66,9 +66,14 @@ void foo(void)
 	OFFSET(pbe_orig_address, pbe, orig_address);
 	OFFSET(pbe_next, pbe, next);
 
+#ifndef CONFIG_X86_NO_TSS
 	/* Offset from the sysenter stack to tss.esp0 */
-	DEFINE(TSS_sysenter_esp0, offsetof(struct tss_struct, esp0) -
+	DEFINE(SYSENTER_stack_esp0, offsetof(struct tss_struct, esp0) -
 		 sizeof(struct tss_struct));
+#else
+	/* sysenter stack points directly to esp0 */
+	DEFINE(SYSENTER_stack_esp0, 0);
+#endif
 
 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
 	DEFINE(VDSO_PRELINK, VDSO_PRELINK);
Index: head-2006-10-16/arch/i386/kernel/cpu/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/kernel/cpu/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/kernel/cpu/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -17,3 +17,8 @@ obj-$(CONFIG_X86_MCE)	+=	mcheck/
 
 obj-$(CONFIG_MTRR)	+= 	mtrr/
 obj-$(CONFIG_CPU_FREQ)	+=	cpufreq/
+
+ifdef CONFIG_XEN
+include $(srctree)/scripts/Makefile.xen
+obj-y := $(call cherrypickxen, $(obj-y), $(src))
+endif
Index: head-2006-10-16/arch/i386/kernel/cpu/mtrr/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/kernel/cpu/mtrr/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/kernel/cpu/mtrr/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -3,3 +3,10 @@ obj-y		+= amd.o
 obj-y		+= cyrix.o
 obj-y		+= centaur.o
 
+ifdef CONFIG_XEN
+include $(srctree)/scripts/Makefile.xen
+n-obj-xen := generic.o state.o amd.o cyrix.o centaur.o
+
+obj-y := $(call filterxen, $(obj-y), $(n-obj-xen))
+obj-y := $(call cherrypickxen, $(obj-y))
+endif
Index: head-2006-10-16/arch/i386/kernel/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/kernel/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/kernel/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -44,6 +44,12 @@ EXTRA_AFLAGS   := -traditional
 
 obj-$(CONFIG_SCx200)		+= scx200.o
 
+ifdef CONFIG_XEN
+vsyscall_note := vsyscall-note-xen.o
+else
+vsyscall_note := vsyscall-note.o
+endif
+
 # vsyscall.o contains the vsyscall DSO images as __initdata.
 # We must build both images before we can assemble it.
 # Note: kbuild does not track this dependency due to usage of .incbin
@@ -65,7 +71,7 @@ SYSCFLAGS_vsyscall-int80.so	= $(vsyscall
 
 $(obj)/vsyscall-int80.so $(obj)/vsyscall-sysenter.so: \
 $(obj)/vsyscall-%.so: $(src)/vsyscall.lds \
-		      $(obj)/vsyscall-%.o $(obj)/vsyscall-note.o FORCE
+		      $(obj)/vsyscall-%.o $(obj)/$(vsyscall_note) FORCE
 	$(call if_changed,syscall)
 
 # We also create a special relocatable object that should mirror the symbol
@@ -77,8 +83,19 @@ $(obj)/built-in.o: ld_flags += -R $(obj)
 
 SYSCFLAGS_vsyscall-syms.o = -r
 $(obj)/vsyscall-syms.o: $(src)/vsyscall.lds \
-			$(obj)/vsyscall-sysenter.o $(obj)/vsyscall-note.o FORCE
+			$(obj)/vsyscall-sysenter.o $(obj)/$(vsyscall_note) FORCE
 	$(call if_changed,syscall)
 
 k8-y                      += ../../x86_64/kernel/k8.o
 
+ifdef CONFIG_XEN
+include $(srctree)/scripts/Makefile.xen
+
+obj-y += fixup.o
+microcode-$(subst m,y,$(CONFIG_MICROCODE)) := microcode-xen.o
+n-obj-xen := i8259.o timers/ reboot.o smpboot.o trampoline.o
+
+obj-y := $(call filterxen, $(obj-y), $(n-obj-xen))
+obj-y := $(call cherrypickxen, $(obj-y))
+extra-y := $(call cherrypickxen, $(extra-y))
+endif
Index: head-2006-10-16/arch/i386/kernel/sysenter.c
===================================================================
--- head-2006-10-16.orig/arch/i386/kernel/sysenter.c	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/kernel/sysenter.c	2006-10-16 10:09:20.000000000 +0200
@@ -42,8 +42,18 @@ __setup("vdso=", vdso_setup);
 
 extern asmlinkage void sysenter_entry(void);
 
+#ifdef CONFIG_XEN
+#include <xen/interface/callback.h>
+
+static struct callback_register sysenter_cb = {
+	.type = CALLBACKTYPE_sysenter,
+	.address = { __KERNEL_CS, (unsigned long)sysenter_entry },
+};
+#endif
+
 void enable_sep_cpu(void)
 {
+#ifndef CONFIG_X86_NO_TSS
 	int cpu = get_cpu();
 	struct tss_struct *tss = &per_cpu(init_tss, cpu);
 
@@ -58,6 +68,7 @@ void enable_sep_cpu(void)
 	wrmsr(MSR_IA32_SYSENTER_ESP, tss->esp1, 0);
 	wrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long) sysenter_entry, 0);
 	put_cpu();	
+#endif
 }
 
 /*
@@ -82,6 +93,12 @@ int __init sysenter_setup(void)
 	__set_fixmap(FIX_VDSO, __pa(syscall_page), PAGE_KERNEL_RO);
 #endif
 
+#ifdef CONFIG_XEN
+	if (boot_cpu_has(X86_FEATURE_SEP) &&
+	    HYPERVISOR_callback_op(CALLBACKOP_register, &sysenter_cb) < 0)
+		clear_bit(X86_FEATURE_SEP, boot_cpu_data.x86_capability);
+#endif
+
 	if (!boot_cpu_has(X86_FEATURE_SEP)) {
 		memcpy(syscall_page,
 		       &vsyscall_int80_start,
Index: head-2006-10-16/arch/i386/kernel/vm86.c
===================================================================
--- head-2006-10-16.orig/arch/i386/kernel/vm86.c	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/kernel/vm86.c	2006-10-16 10:09:20.000000000 +0200
@@ -97,7 +97,9 @@
 struct pt_regs * FASTCALL(save_v86_state(struct kernel_vm86_regs * regs));
 struct pt_regs * fastcall save_v86_state(struct kernel_vm86_regs * regs)
 {
+#ifndef CONFIG_X86_NO_TSS
 	struct tss_struct *tss;
+#endif
 	struct pt_regs *ret;
 	unsigned long tmp;
 
@@ -122,12 +124,16 @@ struct pt_regs * fastcall save_v86_state
 		do_exit(SIGSEGV);
 	}
 
+#ifndef CONFIG_X86_NO_TSS
 	tss = &per_cpu(init_tss, get_cpu());
+#endif
 	current->thread.esp0 = current->thread.saved_esp0;
 	current->thread.sysenter_cs = __KERNEL_CS;
 	load_esp0(tss, &current->thread);
 	current->thread.saved_esp0 = 0;
+#ifndef CONFIG_X86_NO_TSS
 	put_cpu();
+#endif
 
 	loadsegment(fs, current->thread.saved_fs);
 	loadsegment(gs, current->thread.saved_gs);
@@ -251,7 +257,9 @@ out:
 
 static void do_sys_vm86(struct kernel_vm86_struct *info, struct task_struct *tsk)
 {
+#ifndef CONFIG_X86_NO_TSS
 	struct tss_struct *tss;
+#endif
 	long eax;
 /*
  * make sure the vm86() system call doesn't try to do anything silly
@@ -296,12 +304,16 @@ static void do_sys_vm86(struct kernel_vm
 	savesegment(fs, tsk->thread.saved_fs);
 	savesegment(gs, tsk->thread.saved_gs);
 
+#ifndef CONFIG_X86_NO_TSS
 	tss = &per_cpu(init_tss, get_cpu());
+#endif
 	tsk->thread.esp0 = (unsigned long) &info->VM86_TSS_ESP0;
 	if (cpu_has_sep)
 		tsk->thread.sysenter_cs = 0;
 	load_esp0(tss, &tsk->thread);
+#ifndef CONFIG_X86_NO_TSS
 	put_cpu();
+#endif
 
 	tsk->thread.screen_bitmap = info->screen_bitmap;
 	if (info->flags & VM86_SCREEN_BITMAP)
Index: head-2006-10-16/arch/i386/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -48,6 +48,11 @@ CFLAGS				+= $(shell if [ $(call cc-vers
 
 CFLAGS += $(cflags-y)
 
+cppflags-$(CONFIG_XEN) += \
+	-D__XEN_INTERFACE_VERSION__=$(CONFIG_XEN_INTERFACE_VERSION)
+
+CPPFLAGS += $(cppflags-y)
+
 # Default subarch .c files
 mcore-y  := mach-default
 
@@ -71,6 +76,10 @@ mcore-$(CONFIG_X86_BIGSMP)	:= mach-defau
 mflags-$(CONFIG_X86_SUMMIT) := -Iinclude/asm-i386/mach-summit
 mcore-$(CONFIG_X86_SUMMIT)  := mach-default
 
+# Xen subarch support
+mflags-$(CONFIG_X86_XEN)	:= -Iinclude/asm-i386/mach-xen
+mcore-$(CONFIG_X86_XEN)		:= mach-xen
+
 # generic subarchitecture
 mflags-$(CONFIG_X86_GENERICARCH) := -Iinclude/asm-i386/mach-generic
 mcore-$(CONFIG_X86_GENERICARCH) := mach-default
@@ -106,6 +115,19 @@ boot := arch/i386/boot
 PHONY += zImage bzImage compressed zlilo bzlilo \
          zdisk bzdisk fdimage fdimage144 fdimage288 isoimage install
 
+ifdef CONFIG_XEN
+CPPFLAGS := -Iinclude$(if $(KBUILD_SRC),2)/asm/mach-xen $(CPPFLAGS)
+head-y := arch/i386/kernel/head-xen.o arch/i386/kernel/init_task-xen.o
+boot := arch/i386/boot-xen
+.PHONY: vmlinuz
+all: vmlinuz
+
+vmlinuz: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $@
+
+install:
+	$(Q)$(MAKE) $(build)=$(boot) XENGUEST=$(XENGUEST) $@
+else
 all: bzImage
 
 # KBUILD_IMAGE specify target image being built
@@ -128,6 +150,7 @@ fdimage fdimage144 fdimage288 isoimage: 
 
 install:
 	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(KBUILD_IMAGE) install
+endif
 
 archclean:
 	$(Q)$(MAKE) $(clean)=arch/i386/boot
@@ -145,4 +168,5 @@ endef
 
 CLEAN_FILES += arch/$(ARCH)/boot/fdimage \
 	       arch/$(ARCH)/boot/image.iso \
-	       arch/$(ARCH)/boot/mtools.conf
+	       arch/$(ARCH)/boot/mtools.conf \
+	       vmlinuz vmlinux-stripped
Index: head-2006-10-16/arch/i386/mm/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/mm/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/mm/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -8,3 +8,11 @@ obj-$(CONFIG_NUMA) += discontig.o
 obj-$(CONFIG_HUGETLB_PAGE) += hugetlbpage.o
 obj-$(CONFIG_HIGHMEM) += highmem.o
 obj-$(CONFIG_BOOT_IOREMAP) += boot_ioremap.o
+
+ifdef CONFIG_XEN
+include $(srctree)/scripts/Makefile.xen
+
+obj-y		+= hypervisor.o
+
+obj-y := $(call cherrypickxen, $(obj-y))
+endif
Index: head-2006-10-16/arch/i386/mm/pgtable.c
===================================================================
--- head-2006-10-16.orig/arch/i386/mm/pgtable.c	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/mm/pgtable.c	2006-10-16 10:09:20.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/slab.h>
 #include <linux/pagemap.h>
 #include <linux/spinlock.h>
+#include <linux/module.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -137,6 +138,10 @@ void set_pmd_pfn(unsigned long vaddr, un
 	__flush_tlb_one(vaddr);
 }
 
+static int nr_fixmaps = 0;
+unsigned long __FIXADDR_TOP = 0xfffff000;
+EXPORT_SYMBOL(__FIXADDR_TOP);
+
 void __set_fixmap (enum fixed_addresses idx, unsigned long phys, pgprot_t flags)
 {
 	unsigned long address = __fix_to_virt(idx);
@@ -146,6 +151,13 @@ void __set_fixmap (enum fixed_addresses 
 		return;
 	}
 	set_pte_pfn(address, phys >> PAGE_SHIFT, flags);
+	nr_fixmaps++;
+}
+
+void set_fixaddr_top(unsigned long top)
+{
+	BUG_ON(nr_fixmaps > 0);
+	__FIXADDR_TOP = top - PAGE_SIZE;
 }
 
 pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
@@ -214,10 +226,9 @@ void pgd_ctor(void *pgd, kmem_cache_t *c
 		spin_lock_irqsave(&pgd_lock, flags);
 	}
 
-	if (PTRS_PER_PMD == 1 || HAVE_SHARED_KERNEL_PMD)
-		clone_pgd_range((pgd_t *)pgd + USER_PTRS_PER_PGD,
-				swapper_pg_dir + USER_PTRS_PER_PGD,
-				KERNEL_PGD_PTRS);
+	clone_pgd_range((pgd_t *)pgd + USER_PTRS_PER_PGD,
+			swapper_pg_dir + USER_PTRS_PER_PGD,
+			KERNEL_PGD_PTRS);
 	if (PTRS_PER_PMD > 1)
 		return;
 
@@ -249,30 +260,6 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 			goto out_oom;
 		set_pgd(&pgd[i], __pgd(1 + __pa(pmd)));
 	}
-
-	if (!HAVE_SHARED_KERNEL_PMD) {
-		unsigned long flags;
-
-		for (i = USER_PTRS_PER_PGD; i < PTRS_PER_PGD; i++) {
-			pmd_t *pmd = kmem_cache_alloc(pmd_cache, GFP_KERNEL);
-			if (!pmd)
-				goto out_oom;
-			set_pgd(&pgd[USER_PTRS_PER_PGD], __pgd(1 + __pa(pmd)));
-		}
-
-		spin_lock_irqsave(&pgd_lock, flags);
-		for (i = USER_PTRS_PER_PGD; i < PTRS_PER_PGD; i++) {
-			unsigned long v = (unsigned long)i << PGDIR_SHIFT;
-			pgd_t *kpgd = pgd_offset_k(v);
-			pud_t *kpud = pud_offset(kpgd, v);
-			pmd_t *kpmd = pmd_offset(kpud, v);
-			pmd_t *pmd = (void *)__va(pgd_val(pgd[i])-1);
-			memcpy(pmd, kpmd, PAGE_SIZE);
-		}
-		pgd_list_add(pgd);
-		spin_unlock_irqrestore(&pgd_lock, flags);
-	}
-
 	return pgd;
 
 out_oom:
@@ -287,23 +274,9 @@ void pgd_free(pgd_t *pgd)
 	int i;
 
 	/* in the PAE case user pgd entries are overwritten before usage */
-	if (PTRS_PER_PMD > 1) {
-		for (i = 0; i < USER_PTRS_PER_PGD; ++i) {
-			pmd_t *pmd = (void *)__va(pgd_val(pgd[i])-1);
-			kmem_cache_free(pmd_cache, pmd);
-		}
-		if (!HAVE_SHARED_KERNEL_PMD) {
-			unsigned long flags;
-			spin_lock_irqsave(&pgd_lock, flags);
-			pgd_list_del(pgd);
-			spin_unlock_irqrestore(&pgd_lock, flags);
-			for (i = USER_PTRS_PER_PGD; i < PTRS_PER_PGD; i++) {
-				pmd_t *pmd = (void *)__va(pgd_val(pgd[i])-1);
-				memset(pmd, 0, PTRS_PER_PMD*sizeof(pmd_t));
-				kmem_cache_free(pmd_cache, pmd);
-			}
-		}
-	}
+	if (PTRS_PER_PMD > 1)
+		for (i = 0; i < USER_PTRS_PER_PGD; ++i)
+			kmem_cache_free(pmd_cache, (void *)__va(pgd_val(pgd[i])-1));
 	/* in the non-PAE case, free_pgtables() clears user pgd entries */
 	kmem_cache_free(pgd_cache, pgd);
 }
Index: head-2006-10-16/arch/i386/oprofile/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/oprofile/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/oprofile/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -6,7 +6,11 @@ DRIVER_OBJS = $(addprefix ../../../drive
 		oprofilefs.o oprofile_stats.o  \
 		timer_int.o )
 
+ifdef CONFIG_XEN
+oprofile-y				:= $(DRIVER_OBJS) xenoprof.o
+else 
 oprofile-y				:= $(DRIVER_OBJS) init.o backtrace.o
 oprofile-$(CONFIG_X86_LOCAL_APIC) 	+= nmi_int.o op_model_athlon.o \
 					   op_model_ppro.o op_model_p4.o
 oprofile-$(CONFIG_X86_IO_APIC)		+= nmi_timer_int.o
+endif
Index: head-2006-10-16/arch/i386/pci/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/pci/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/pci/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -4,6 +4,10 @@ obj-$(CONFIG_PCI_BIOS)		+= pcbios.o
 obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig.o direct.o
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
 
+# pcifront should be after pcbios.o, mmconfig.o, and direct.o as it should only
+# take over if direct access to the PCI bus is unavailable
+obj-$(CONFIG_XEN_PCIDEV_FRONTEND)	+= pcifront.o
+
 pci-y				:= fixup.o
 pci-$(CONFIG_ACPI)		+= acpi.o
 pci-y				+= legacy.o irq.o
@@ -12,3 +16,8 @@ pci-$(CONFIG_X86_VISWS)		:= visws.o fixu
 pci-$(CONFIG_X86_NUMAQ)		:= numa.o irq.o
 
 obj-y				+= $(pci-y) common.o
+
+ifdef CONFIG_XEN
+include $(srctree)/scripts/Makefile.xen
+obj-y := $(call cherrypickxen, $(obj-y))
+endif
Index: head-2006-10-16/arch/i386/power/Makefile
===================================================================
--- head-2006-10-16.orig/arch/i386/power/Makefile	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/arch/i386/power/Makefile	2006-10-16 10:09:20.000000000 +0200
@@ -1,2 +1,4 @@
-obj-$(CONFIG_PM)		+= cpu.o
+obj-$(CONFIG_PM_LEGACY)		+= cpu.o
+obj-$(CONFIG_SOFTWARE_SUSPEND)	+= cpu.o
+obj-$(CONFIG_ACPI_SLEEP)	+= cpu.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= swsusp.o
Index: head-2006-10-16/include/asm-i386/a.out.h
===================================================================
--- head-2006-10-16.orig/include/asm-i386/a.out.h	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/include/asm-i386/a.out.h	2006-10-16 10:09:20.000000000 +0200
@@ -19,7 +19,7 @@ struct exec
 
 #ifdef __KERNEL__
 
-#define STACK_TOP	TASK_SIZE
+#define STACK_TOP	(TASK_SIZE - 3*PAGE_SIZE)
 
 #endif
 
Index: head-2006-10-16/include/asm-i386/apic.h
===================================================================
--- head-2006-10-16.orig/include/asm-i386/apic.h	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/include/asm-i386/apic.h	2006-10-16 10:09:20.000000000 +0200
@@ -119,10 +119,12 @@ extern void enable_NMI_through_LVT0 (voi
 
 extern int disable_timer_pin_1;
 
+#ifndef CONFIG_XEN
 void smp_send_timer_broadcast_ipi(struct pt_regs *regs);
 void switch_APIC_timer_to_ipi(void *cpumask);
 void switch_ipi_to_APIC_timer(void *cpumask);
 #define ARCH_APICTIMER_STOPS_ON_C3	1
+#endif
 
 extern int timer_over_8254;
 
Index: head-2006-10-16/include/asm-i386/fixmap.h
===================================================================
--- head-2006-10-16.orig/include/asm-i386/fixmap.h	2006-10-16 10:08:00.000000000 +0200
+++ head-2006-10-16/include/asm-i386/fixmap.h	2006-10-16 10:09:20.000000000 +0200
@@ -19,7 +19,7 @@
  * Leave one empty page between vmalloc'ed areas and
  * the start of the fixmap.
  */
-#define __FIXADDR_TOP	0xfffff000
+extern unsigned long __FIXADDR_TOP;
 
 #ifndef __ASSEMBLY__
 #include <linux/kernel.h>
@@ -94,6 +94,8 @@ enum fixed_addresses {
 extern void __set_fixmap (enum fixed_addresses idx,
 					unsigned long phys, pgprot_t flags);
 
+extern void set_fixaddr_top(unsigned long top);
+
 #define set_fixmap(idx, phys) \
 		__set_fixmap(idx, phys, PAGE_KERNEL)
 /*
