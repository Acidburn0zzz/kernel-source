From: Keir Fraser <keir@xensource.com>
Subject: Use io_remap_page_range in DRM

When remapping non-RAM-backed pages, remap_pfn_range will crash
then domain under Xen. This happens when using the DRM drivers. 

Signed-off-by: Kurt Garloff <garloff@suse.de>

Index: linux-2.6.11/drivers/char/agp/frontend.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/frontend.c
+++ linux-2.6.11/drivers/char/agp/frontend.c
@@ -626,9 +626,9 @@ static int agp_mmap(struct file *file, s
 
 		DBG("client vm_ops=%p", kerninfo.vm_ops);
 		if (kerninfo.vm_ops) {
 			vma->vm_ops = kerninfo.vm_ops;
-		} else if (remap_pfn_range(vma, vma->vm_start,
+		} else if (io_remap_pfn_range(vma, vma->vm_start,
 				(kerninfo.aper_base + offset) >> PAGE_SHIFT,
 					    size, vma->vm_page_prot)) {
 			goto out_again;
 		}
@@ -642,9 +642,9 @@ static int agp_mmap(struct file *file, s
 
 		DBG("controller vm_ops=%p", kerninfo.vm_ops);
 		if (kerninfo.vm_ops) {
 			vma->vm_ops = kerninfo.vm_ops;
-		} else if (remap_pfn_range(vma, vma->vm_start,
+		} else if (io_remap_pfn_range(vma, vma->vm_start,
 					    kerninfo.aper_base >> PAGE_SHIFT,
 					    size, vma->vm_page_prot)) {
 			goto out_again;
 		}
Index: linux-2.6.11/drivers/char/drm/drm_vm.c
===================================================================
--- linux-2.6.11.orig/drivers/char/drm/drm_vm.c
+++ linux-2.6.11/drivers/char/drm/drm_vm.c
@@ -629,9 +629,9 @@ int drm_mmap(struct file *filp, struct v
 					vm_offset + offset,
 					vma->vm_end - vma->vm_start,
 					vma->vm_page_prot, 0))
 #else
-		if (remap_pfn_range(DRM_RPR_ARG(vma) vma->vm_start,
+		if (io_remap_pfn_range(vma, vma->vm_start,
 				     (vm_offset + offset) >> PAGE_SHIFT,
 				     vma->vm_end - vma->vm_start,
 				     vma->vm_page_prot))
 #endif
Index: linux-2.6.11/drivers/char/drm/i810_dma.c
===================================================================
--- linux-2.6.11.orig/drivers/char/drm/i810_dma.c
+++ linux-2.6.11/drivers/char/drm/i810_dma.c
@@ -138,9 +138,9 @@ int i810_mmap_buffers(struct file *filp,
 
    	buf_priv->currently_mapped = I810_BUF_MAPPED;
 	unlock_kernel();
 
-	if (remap_pfn_range(DRM_RPR_ARG(vma) vma->vm_start,
+	if (io_remap_pfn_range(vma, vma->vm_start,
 			     VM_OFFSET(vma) >> PAGE_SHIFT,
 			     vma->vm_end - vma->vm_start,
 			     vma->vm_page_prot)) return -EAGAIN;
 	return 0;
Index: linux-2.6.11/drivers/char/drm/i830_dma.c
===================================================================
--- linux-2.6.11.orig/drivers/char/drm/i830_dma.c
+++ linux-2.6.11/drivers/char/drm/i830_dma.c
@@ -156,9 +156,9 @@ int i830_mmap_buffers(struct file *filp,
    
    	buf_priv->currently_mapped = I830_BUF_MAPPED;
 	unlock_kernel();
 
-	if (remap_pfn_range(DRM_RPR_ARG(vma) vma->vm_start,
+	if (io_remap_pfn_range(vma, vma->vm_start,
 			     VM_OFFSET(vma) >> PAGE_SHIFT,
 			     vma->vm_end - vma->vm_start,
 			     vma->vm_page_prot)) return -EAGAIN;
 	return 0;
Index: linux-2.6.11/drivers/char/hpet.c
===================================================================
--- linux-2.6.11.orig/drivers/char/hpet.c
+++ linux-2.6.11/drivers/char/hpet.c
@@ -75,8 +75,9 @@ struct hpet_dev {
 
 struct hpets {
 	struct hpets *hp_next;
 	struct hpet __iomem *hp_hpet;
+	unsigned long hp_hpet_phys;
 	struct time_interpolator *hp_interpolator;
 	unsigned long hp_period;
 	unsigned long hp_delta;
 	unsigned int hp_ntimer;
@@ -264,18 +265,18 @@ static int hpet_mmap(struct file *file, 
 	if (((vma->vm_end - vma->vm_start) != PAGE_SIZE) || vma->vm_pgoff)
 		return -EINVAL;
 
 	devp = file->private_data;
-	addr = (unsigned long)devp->hd_hpet;
+	addr = devp->hd_hpets->hp_hpet_phys;
 
 	if (addr & (PAGE_SIZE - 1))
 		return -ENOSYS;
 
 	vma->vm_flags |= VM_IO;
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 	addr = __pa(addr);
 
-	if (remap_pfn_range(vma, vma->vm_start, addr >> PAGE_SHIFT,
+	if (io_remap_pfn_range(vma, vma->vm_start, addr >> PAGE_SHIFT,
 					PAGE_SIZE, vma->vm_page_prot)) {
 		printk(KERN_ERR "remap_pfn_range failed in hpet.c\n");
 		return -EAGAIN;
 	}
@@ -794,8 +795,9 @@ int hpet_alloc(struct hpet_data *hdp)
 	memset(hpetp, 0, siz);
 
 	hpetp->hp_which = hpet_nhpet++;
 	hpetp->hp_hpet = hdp->hd_address;
+	hpetp->hp_hpet_phys = hdp->hd_phys_address;
 
 	hpetp->hp_ntimer = hdp->hd_nirqs;
 
 	for (i = 0; i < hdp->hd_nirqs; i++)
Index: linux-2.6.11/drivers/sbus/char/flash.c
===================================================================
--- linux-2.6.11.orig/drivers/sbus/char/flash.c
+++ linux-2.6.11/drivers/sbus/char/flash.c
@@ -74,9 +74,9 @@ flash_mmap(struct file *file, struct vm_
 	pgprot_val(vma->vm_page_prot) &= ~(_PAGE_CACHE);
 	pgprot_val(vma->vm_page_prot) |= _PAGE_E;
 	vma->vm_flags |= (VM_SHM | VM_LOCKED);
 
-	if (remap_pfn_range(vma, vma->vm_start, addr, size, vma->vm_page_prot))
+	if (io_remap_pfn_range(vma, vma->vm_start, addr, size, vma->vm_page_prot))
 		return -EAGAIN;
 		
 	return 0;
 }
Index: linux-2.6.11/include/linux/mm.h
===================================================================
--- linux-2.6.11.orig/include/linux/mm.h
+++ linux-2.6.11/include/linux/mm.h
@@ -827,8 +827,12 @@ extern unsigned long vmalloc_to_pfn(void
 extern struct page * follow_page(struct mm_struct *mm, unsigned long address,
 		int write);
 int remap_pfn_range(struct vm_area_struct *, unsigned long,
 		unsigned long, unsigned long, pgprot_t);
+/* Allow arch override for mapping of device and I/O (non-RAM) pages. */
+#ifndef io_remap_pfn_range
+#define io_remap_pfn_range remap_pfn_range
+#endif
 
 static inline __deprecated /* since 25 Sept 2004 -- wli */
 int remap_page_range(struct vm_area_struct *vma, unsigned long uvaddr,
 			unsigned long paddr, unsigned long size, pgprot_t prot)
