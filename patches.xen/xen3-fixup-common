Subject: Fix xen build.
From: kraxel@suse.de

$subject says all.

Index: head-2006-04-05/drivers/base/bus.c
===================================================================
--- head-2006-04-05.orig/drivers/base/bus.c	2006-04-06 11:47:16.000000000 +0200
+++ head-2006-04-05/drivers/base/bus.c	2006-04-06 11:51:31.000000000 +0200
@@ -189,10 +189,12 @@ static ssize_t driver_bind(struct device
 		if (dev->parent)
 			up(&dev->parent->sem);
 
+#ifdef CONFIG_XEN
 		if (err > 0) 		/* success */
 			err = count;
 		else if (err == 0)	/* driver didn't accept device */
 			err = -ENODEV;
+#endif
 	}
 	put_device(dev);
 	put_bus(bus);
Index: head-2006-04-05/drivers/char/tpm/tpm.c
===================================================================
--- head-2006-04-05.orig/drivers/char/tpm/tpm.c	2006-04-06 11:49:45.000000000 +0200
+++ head-2006-04-05/drivers/char/tpm/tpm.c	2006-04-06 11:51:31.000000000 +0200
@@ -414,7 +414,9 @@ ssize_t tpm_write(struct file *file, con
 	                        get_chip_buffersize(chip));
 
 	atomic_set(&chip->data_pending, out_size);
+#ifdef CONFIG_XEN
 	atomic_set(&chip->data_position, 0);
+#endif
 	up(&chip->buffer_mutex);
 
 	/* Set a timeout by which the reader must come claim the result */
@@ -430,33 +432,52 @@ ssize_t tpm_read(struct file * file, cha
 {
 	struct tpm_chip *chip = file->private_data;
 	int ret_size;
-	int pos, pending = 0;
-
+#ifdef CONFIG_XEN
+	int pending = 0;
+#endif
+
+#ifndef CONFIG_XEN
+	del_singleshot_timer_sync(&chip->user_read_timer);
+	flush_scheduled_work();
+#endif
 	ret_size = atomic_read(&chip->data_pending);
+#ifndef CONFIG_XEN
+	atomic_set(&chip->data_pending, 0);
+#endif
 	if (ret_size > 0) {	/* relay data */
+		int pos;
+
 		if (size < ret_size)
 			ret_size = size;
 
+#ifndef CONFIG_XEN
+		pos = 0;
+#else
 		pos = atomic_read(&chip->data_position);
+#endif
 
 		down(&chip->buffer_mutex);
-		if (copy_to_user(buf, &chip->data_buffer[pos], ret_size)) {
+		if (copy_to_user(buf, &chip->data_buffer[pos], ret_size))
 			ret_size = -EFAULT;
-		} else {
+#ifdef CONFIG_XEN
+		else {
 			pending = atomic_read(&chip->data_pending) - ret_size;
 			if ( pending ) {
 				atomic_set( &chip->data_pending, pending );
 				atomic_set( &chip->data_position, pos+ret_size );
 			}
 		}
+#endif
 		up(&chip->buffer_mutex);
 	}
 	
+#ifdef CONFIG_XEN
 	if ( ret_size <= 0 || pending == 0 ) {
 		atomic_set( &chip->data_pending, 0 );
 		del_singleshot_timer_sync(&chip->user_read_timer);
 		flush_scheduled_work();
 	}
+#endif
 
 	return ret_size;
 }
Index: head-2006-04-05/drivers/char/tpm/tpm.h
===================================================================
--- head-2006-04-05.orig/drivers/char/tpm/tpm.h	2006-04-06 11:49:45.000000000 +0200
+++ head-2006-04-05/drivers/char/tpm/tpm.h	2006-04-06 11:51:31.000000000 +0200
@@ -75,7 +75,9 @@ struct tpm_chip {
 	/* Data passed to and from the tpm via the read/write calls */
 	u8 *data_buffer;
 	atomic_t data_pending;
+#ifdef CONFIG_XEN
 	atomic_t data_position;
+#endif
 	struct semaphore buffer_mutex;
 
 	struct timer_list user_read_timer;	/* user needs to claim result */
Index: head-2006-04-05/net/ipv4/netfilter/ip_nat_proto_tcp.c
===================================================================
--- head-2006-04-05.orig/net/ipv4/netfilter/ip_nat_proto_tcp.c	2006-04-06 11:47:16.000000000 +0200
+++ head-2006-04-05/net/ipv4/netfilter/ip_nat_proto_tcp.c	2006-04-06 11:51:31.000000000 +0200
@@ -129,14 +129,15 @@ tcp_manip_pkt(struct sk_buff **pskb,
 	if (hdrsize < sizeof(*hdr))
 		return 1;
 
-	if ((*pskb)->proto_csum_blank) {
+#ifdef CONFIG_XEN
+	if ((*pskb)->proto_csum_blank)
 		hdr->check = ip_nat_cheat_check(oldip, ~newip, hdr->check);
-	} else {
+	else
+#endif
 		hdr->check = ip_nat_cheat_check(~oldip, newip,
 					ip_nat_cheat_check(oldport ^ 0xFFFF,
 							   newport,
 							   hdr->check));
-	}
 	return 1;
 }
 
Index: head-2006-04-05/net/ipv4/netfilter/ip_nat_proto_udp.c
===================================================================
--- head-2006-04-05.orig/net/ipv4/netfilter/ip_nat_proto_udp.c	2006-04-06 11:47:16.000000000 +0200
+++ head-2006-04-05/net/ipv4/netfilter/ip_nat_proto_udp.c	2006-04-06 11:51:31.000000000 +0200
@@ -114,14 +114,15 @@ udp_manip_pkt(struct sk_buff **pskb,
 		portptr = &hdr->dest;
 	}
 	if (hdr->check) { /* 0 is a special case meaning no checksum */
-		if ((*pskb)->proto_csum_blank) {
+#ifdef CONFIG_XEN
+		if ((*pskb)->proto_csum_blank)
 			hdr->check = ip_nat_cheat_check(oldip, ~newip, hdr->check);
-		} else {
+		else
+#endif
 			hdr->check = ip_nat_cheat_check(~oldip, newip,
 					ip_nat_cheat_check(*portptr ^ 0xFFFF,
 							   newport,
 							   hdr->check));
-		}
 	}
 	*portptr = newport;
 	return 1;
