Subject: Fix xen build.
From: kraxel@suse.de

$subject says all.

Index: head-2006-03-24/drivers/base/bus.c
===================================================================
--- head-2006-03-24.orig/drivers/base/bus.c	2006-03-25 09:02:32.000000000 -0700
+++ head-2006-03-24/drivers/base/bus.c	2006-03-25 09:24:29.000000000 -0700
@@ -189,10 +189,12 @@
 		if (dev->parent)
 			up(&dev->parent->sem);
 
+#ifdef CONFIG_XEN
 		if (err > 0) 		/* success */
 			err = count;
 		else if (err == 0)	/* driver didn't accept device */
 			err = -ENODEV;
+#endif
 	}
 	put_device(dev);
 	put_bus(bus);
Index: head-2006-03-24/drivers/char/tpm/tpm.c
===================================================================
--- head-2006-03-24.orig/drivers/char/tpm/tpm.c	2006-03-25 09:15:51.000000000 -0700
+++ head-2006-03-24/drivers/char/tpm/tpm.c	2006-03-25 09:24:29.000000000 -0700
@@ -414,7 +414,9 @@
 	                        get_chip_buffersize(chip));
 
 	atomic_set(&chip->data_pending, out_size);
+#ifdef CONFIG_XEN
 	atomic_set(&chip->data_position, 0);
+#endif
 	up(&chip->buffer_mutex);
 
 	/* Set a timeout by which the reader must come claim the result */
@@ -430,33 +432,52 @@
 {
 	struct tpm_chip *chip = file->private_data;
 	int ret_size;
-	int pos, pending = 0;
-
+#ifdef CONFIG_XEN
+	int pending = 0;
+#endif
+
+#ifndef CONFIG_XEN
+	del_singleshot_timer_sync(&chip->user_read_timer);
+	flush_scheduled_work();
+#endif
 	ret_size = atomic_read(&chip->data_pending);
+#ifndef CONFIG_XEN
+	atomic_set(&chip->data_pending, 0);
+#endif
 	if (ret_size > 0) {	/* relay data */
+		int pos;
+
 		if (size < ret_size)
 			ret_size = size;
 
+#ifndef CONFIG_XEN
+		pos = 0;
+#else
 		pos = atomic_read(&chip->data_position);
+#endif
 
 		down(&chip->buffer_mutex);
-		if (copy_to_user(buf, &chip->data_buffer[pos], ret_size)) {
+		if (copy_to_user(buf, &chip->data_buffer[pos], ret_size))
 			ret_size = -EFAULT;
-		} else {
+#ifdef CONFIG_XEN
+		else {
 			pending = atomic_read(&chip->data_pending) - ret_size;
 			if ( pending ) {
 				atomic_set( &chip->data_pending, pending );
 				atomic_set( &chip->data_position, pos+ret_size );
 			}
 		}
+#endif
 		up(&chip->buffer_mutex);
 	}
 	
+#ifdef CONFIG_XEN
 	if ( ret_size <= 0 || pending == 0 ) {
 		atomic_set( &chip->data_pending, 0 );
 		del_singleshot_timer_sync(&chip->user_read_timer);
 		flush_scheduled_work();
 	}
+#endif
 
 	return ret_size;
 }
Index: head-2006-03-24/drivers/char/tpm/tpm.h
===================================================================
--- head-2006-03-24.orig/drivers/char/tpm/tpm.h	2006-03-25 09:15:51.000000000 -0700
+++ head-2006-03-24/drivers/char/tpm/tpm.h	2006-03-25 09:24:29.000000000 -0700
@@ -75,7 +75,9 @@
 	/* Data passed to and from the tpm via the read/write calls */
 	u8 *data_buffer;
 	atomic_t data_pending;
+#ifdef CONFIG_XEN
 	atomic_t data_position;
+#endif
 	struct semaphore buffer_mutex;
 
 	struct timer_list user_read_timer;	/* user needs to claim result */
Index: head-2006-03-24/kernel/irq/manage.c
===================================================================
--- head-2006-03-24.orig/kernel/irq/manage.c	2006-03-25 09:15:51.000000000 -0700
+++ head-2006-03-24/kernel/irq/manage.c	2006-03-25 09:24:29.000000000 -0700
@@ -259,7 +259,7 @@
 #ifndef CONFIG_XEN
 static
 #endif
-int teardown_irq(unsigned int irq, struct irqaction * old)
+int teardown_irq(unsigned int irq, struct irqaction * old, void *dev_id)
 {
 	struct irq_desc *desc;
 	struct irqaction **p;
@@ -341,7 +341,7 @@
 
 		spin_unlock_irqrestore(&desc->lock,flags);
 
-		if (teardown_irq(irq, action) == 0)
+		if (teardown_irq(irq, action, dev_id) == 0)
 			kfree(action);
 		return;
 	}
Index: head-2006-03-24/include/linux/irq.h
===================================================================
--- head-2006-03-24.orig/include/linux/irq.h	2006-03-25 09:15:51.000000000 -0700
+++ head-2006-03-24/include/linux/irq.h	2006-03-25 09:24:29.000000000 -0700
@@ -95,7 +95,7 @@
 
 extern int setup_irq(unsigned int irq, struct irqaction * new);
 #ifdef CONFIG_XEN
-extern int teardown_irq(unsigned int irq, struct irqaction * old);
+extern int teardown_irq(unsigned int irq, struct irqaction * old, void *dev_id);
 #endif
 
 #ifdef CONFIG_GENERIC_HARDIRQS
Index: head-2006-03-24/net/ipv4/netfilter/ip_nat_proto_tcp.c
===================================================================
--- head-2006-03-24.orig/net/ipv4/netfilter/ip_nat_proto_tcp.c	2006-03-25 09:02:33.000000000 -0700
+++ head-2006-03-24/net/ipv4/netfilter/ip_nat_proto_tcp.c	2006-03-25 09:24:29.000000000 -0700
@@ -129,14 +129,15 @@
 	if (hdrsize < sizeof(*hdr))
 		return 1;
 
-	if ((*pskb)->proto_csum_blank) {
+#ifdef CONFIG_XEN
+	if ((*pskb)->proto_csum_blank)
 		hdr->check = ip_nat_cheat_check(oldip, ~newip, hdr->check);
-	} else {
+	else
+#endif
 		hdr->check = ip_nat_cheat_check(~oldip, newip,
 					ip_nat_cheat_check(oldport ^ 0xFFFF,
 							   newport,
 							   hdr->check));
-	}
 	return 1;
 }
 
Index: head-2006-03-24/net/ipv4/netfilter/ip_nat_proto_udp.c
===================================================================
--- head-2006-03-24.orig/net/ipv4/netfilter/ip_nat_proto_udp.c	2006-03-25 09:02:33.000000000 -0700
+++ head-2006-03-24/net/ipv4/netfilter/ip_nat_proto_udp.c	2006-03-25 09:24:29.000000000 -0700
@@ -114,14 +114,15 @@
 		portptr = &hdr->dest;
 	}
 	if (hdr->check) { /* 0 is a special case meaning no checksum */
-		if ((*pskb)->proto_csum_blank) {
+#ifdef CONFIG_XEN
+		if ((*pskb)->proto_csum_blank)
 			hdr->check = ip_nat_cheat_check(oldip, ~newip, hdr->check);
-		} else {
+		else
+#endif
 			hdr->check = ip_nat_cheat_check(~oldip, newip,
 					ip_nat_cheat_check(*portptr ^ 0xFFFF,
 							   newport,
 							   hdr->check));
-		}
 	}
 	*portptr = newport;
 	return 1;
