Subject: update include/arch-xen/xen-public to xen 3.0.0 level.
From: kraxel@suse.de

Index: linux-2.6.14/include/asm-xen/xen-public/acm_ops.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/acm_ops.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/acm_ops.h	2005-12-05 17:00:02.000000000 +0100
@@ -63,7 +63,7 @@ struct acm_getssid {
         ssidref_t    ssidref;
     } id;
     void *ssidbuf;
-    uint16_t ssidbuf_size;
+    uint32_t ssidbuf_size;
 };
 
 #define ACM_GETDECISION        8
Index: linux-2.6.14/include/asm-xen/xen-public/arch-ia64.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/arch-ia64.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/arch-ia64.h	2005-12-05 17:00:02.000000000 +0100
@@ -38,6 +38,33 @@ typedef struct {
 
 #define INVALID_MFN       (~0UL)
 
+#define MEM_G   (1UL << 30)	
+#define MEM_M   (1UL << 20)	
+
+#define MMIO_START       (3 * MEM_G)
+#define MMIO_SIZE        (512 * MEM_M)
+
+#define VGA_IO_START     0xA0000UL
+#define VGA_IO_SIZE      0x20000
+
+#define LEGACY_IO_START  (MMIO_START + MMIO_SIZE)
+#define LEGACY_IO_SIZE   (64*MEM_M)  
+
+#define IO_PAGE_START (LEGACY_IO_START + LEGACY_IO_SIZE)
+#define IO_PAGE_SIZE  PAGE_SIZE
+
+#define STORE_PAGE_START (IO_PAGE_START + IO_PAGE_SIZE)
+#define STORE_PAGE_SIZE	 PAGE_SIZE
+
+#define IO_SAPIC_START   0xfec00000UL
+#define IO_SAPIC_SIZE    0x100000
+
+#define PIB_START 0xfee00000UL
+#define PIB_SIZE 0x100000 
+
+#define GFW_START        (4*MEM_G -16*MEM_M)
+#define GFW_SIZE         (16*MEM_M)
+
 /*
  * NB. This may become a 64-bit count with no shift. If this happens then the 
  * structure size will still be 8 bytes, so no other alignments will change.
Index: linux-2.6.14/include/asm-xen/xen-public/dom0_ops.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/dom0_ops.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/dom0_ops.h	2005-12-05 17:00:02.000000000 +0100
@@ -19,7 +19,7 @@
  * This makes sure that old versions of dom0 tools will stop working in a
  * well-defined way (rather than crashing the machine, for instance).
  */
-#define DOM0_INTERFACE_VERSION   0xAAAA1012
+#define DOM0_INTERFACE_VERSION   0x03000000
 
 /************************************************************************/
 
@@ -98,7 +98,7 @@ typedef struct {
 typedef struct {
     /* IN variables. */
     domid_t               domain;
-    uint16_t              vcpu;
+    uint32_t              vcpu;
     /* IN/OUT parameters */
     vcpu_guest_context_t *ctxt;
 } dom0_setdomaininfo_t;
@@ -107,7 +107,7 @@ typedef struct {
 typedef struct {
     /* IN variables. */
     uint32_t write;
-    uint32_t cpu_mask;
+    cpumap_t cpu_mask;
     uint32_t msr;
     uint32_t in1;
     uint32_t in2;
@@ -116,21 +116,6 @@ typedef struct {
     uint32_t out2;
 } dom0_msr_t;
 
-#define DOM0_DEBUG            16
-typedef struct {
-    /* IN variables. */
-    domid_t  domain;
-    uint8_t  opcode;
-    uint32_t in1;
-    uint32_t in2;
-    uint32_t in3;
-    uint32_t in4;
-    /* OUT variables. */
-    uint32_t status;
-    uint32_t out1;
-    uint32_t out2;
-} dom0_debug_t;
-
 /*
  * Set clock such that it would read <secs,nsecs> after 00:00:00 UTC,
  * 1 January, 1970 if the current system time was <system_time>.
@@ -182,8 +167,8 @@ typedef struct {
 typedef struct {
     /* IN variables. */
     domid_t   domain;
-    uint16_t  vcpu;
-    cpumap_t cpumap;
+    uint32_t  vcpu;
+    cpumap_t  cpumap;
 } dom0_pincpudomain_t;
 
 /* Get trace buffers machine base address */
@@ -196,9 +181,9 @@ typedef struct {
 #define DOM0_TBUF_SET_SIZE     3
 #define DOM0_TBUF_ENABLE       4
 #define DOM0_TBUF_DISABLE      5
-    uint8_t op;
+    uint32_t      op;
     /* IN/OUT variables */
-    unsigned long cpu_mask;
+    cpumap_t      cpu_mask;
     uint32_t      evt_mask;
     /* OUT variables */
     unsigned long buffer_mfn;
@@ -327,7 +312,7 @@ typedef struct {
 #define DOM0_PERFCCONTROL_OP_RESET 1   /* Reset all counters to zero. */
 #define DOM0_PERFCCONTROL_OP_QUERY 2   /* Get perfctr information. */
 typedef struct {
-    uint8_t      name[80];             /*  name of perf counter */
+    uint8_t      name[80];             /* name of perf counter */
     uint32_t     nr_vals;              /* number of values for this counter */
     uint32_t     vals[64];             /* array of values */
 } dom0_perfc_desc_t;
@@ -349,16 +334,16 @@ typedef struct {
 #define DOM0_IOPORT_PERMISSION   36
 typedef struct {
     domid_t  domain;                  /* domain to be affected */
-    uint16_t first_port;              /* first port int range */
-    uint16_t nr_ports;                /* size of port range */
-    uint16_t allow_access;            /* allow or deny access to range? */
+    uint32_t first_port;              /* first port int range */
+    uint32_t nr_ports;                /* size of port range */
+    uint8_t  allow_access;            /* allow or deny access to range? */
 } dom0_ioport_permission_t;
 
 #define DOM0_GETVCPUCONTEXT      37
 typedef struct {
     /* IN variables. */
     domid_t  domain;                  /* domain to be affected */
-    uint16_t vcpu;                    /* vcpu # */
+    uint32_t vcpu;                    /* vcpu # */
     /* OUT variables. */
     vcpu_guest_context_t *ctxt;
 } dom0_getvcpucontext_t;
@@ -367,7 +352,7 @@ typedef struct {
 typedef struct {
     /* IN variables. */
     domid_t  domain;                  /* domain to be affected */
-    uint16_t vcpu;                    /* vcpu # */
+    uint32_t vcpu;                    /* vcpu # */
     /* OUT variables. */
     uint8_t  online;                  /* currently online (not hotplugged)? */
     uint8_t  blocked;                 /* blocked waiting for an event? */
@@ -381,35 +366,36 @@ typedef struct {
 typedef struct {
     /* IN variables. */
     domid_t               first_domain;
-    unsigned int          max_domains;
+    uint32_t              max_domains;
     dom0_getdomaininfo_t *buffer;
     /* OUT variables. */
-    unsigned int          num_domains;
+    uint32_t              num_domains;
 } dom0_getdomaininfolist_t;
 
 #define DOM0_PLATFORM_QUIRK      39  
 #define QUIRK_NOIRQBALANCING  1
 typedef struct {
     /* IN variables. */
-    int quirk_id;
+    uint32_t quirk_id;
 } dom0_platform_quirk_t;
 
 #define DOM0_PHYSICAL_MEMORY_MAP 40
 typedef struct {
     /* IN variables. */
-    int max_map_entries;
+    uint32_t max_map_entries;
     /* OUT variables. */
-    int nr_map_entries;
+    uint32_t nr_map_entries;
     struct dom0_memory_map_entry {
         uint64_t start, end;
-        int is_ram;
+        uint32_t flags; /* reserved */
+        uint8_t  is_ram;
     } *memory_map;
 } dom0_physical_memory_map_t;
 
 #define DOM0_MAX_VCPUS 41
 typedef struct {
-    domid_t domain;             /* domain to be affected */
-    unsigned int max;           /* maximum number of vcpus */
+    domid_t  domain;        /* domain to be affected */
+    uint32_t max;           /* maximum number of vcpus */
 } dom0_max_vcpus_t;
 
 #define DOM0_SETDOMAINHANDLE 44
@@ -433,7 +419,6 @@ typedef struct {
         dom0_getdomaininfo_t     getdomaininfo;
         dom0_getpageframeinfo_t  getpageframeinfo;
         dom0_msr_t               msr;
-        dom0_debug_t             debug;
         dom0_settime_t           settime;
         dom0_readconsole_t       readconsole;
         dom0_pincpudomain_t      pincpudomain;
Index: linux-2.6.14/include/asm-xen/xen-public/event_channel.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/event_channel.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/event_channel.h	2005-12-05 17:00:02.000000000 +0100
@@ -9,6 +9,8 @@
 #ifndef __XEN_PUBLIC_EVENT_CHANNEL_H__
 #define __XEN_PUBLIC_EVENT_CHANNEL_H__
 
+typedef uint32_t evtchn_port_t;
+
 /*
  * EVTCHNOP_alloc_unbound: Allocate a port in domain <dom> and mark as
  * accepting interdomain bindings from domain <remote_dom>. A fresh port
@@ -20,9 +22,9 @@
 #define EVTCHNOP_alloc_unbound    6
 typedef struct evtchn_alloc_unbound {
     /* IN parameters */
-    domid_t  dom, remote_dom;
+    domid_t dom, remote_dom;
     /* OUT parameters */
-    uint32_t port;
+    evtchn_port_t port;
 } evtchn_alloc_unbound_t;
 
 /*
@@ -37,10 +39,10 @@ typedef struct evtchn_alloc_unbound {
 #define EVTCHNOP_bind_interdomain 0
 typedef struct evtchn_bind_interdomain {
     /* IN parameters. */
-    domid_t  remote_dom;
-    uint32_t remote_port;
+    domid_t remote_dom;
+    evtchn_port_t remote_port;
     /* OUT parameters. */
-    uint32_t local_port;
+    evtchn_port_t local_port;
 } evtchn_bind_interdomain_t;
 
 /*
@@ -57,7 +59,7 @@ typedef struct evtchn_bind_virq {
     uint32_t virq;
     uint32_t vcpu;
     /* OUT parameters. */
-    uint32_t port;
+    evtchn_port_t port;
 } evtchn_bind_virq_t;
 
 /*
@@ -73,7 +75,7 @@ typedef struct evtchn_bind_pirq {
 #define BIND_PIRQ__WILL_SHARE 1
     uint32_t flags; /* BIND_PIRQ__* */
     /* OUT parameters. */
-    uint32_t port;
+    evtchn_port_t port;
 } evtchn_bind_pirq_t;
 
 /*
@@ -86,7 +88,7 @@ typedef struct evtchn_bind_pirq {
 typedef struct evtchn_bind_ipi {
     uint32_t vcpu;
     /* OUT parameters. */
-    uint32_t port;
+    evtchn_port_t port;
 } evtchn_bind_ipi_t;
 
 /*
@@ -97,7 +99,7 @@ typedef struct evtchn_bind_ipi {
 #define EVTCHNOP_close            3
 typedef struct evtchn_close {
     /* IN parameters. */
-    uint32_t port;
+    evtchn_port_t port;
 } evtchn_close_t;
 
 /*
@@ -107,7 +109,7 @@ typedef struct evtchn_close {
 #define EVTCHNOP_send             4
 typedef struct evtchn_send {
     /* IN parameters. */
-    uint32_t port;
+    evtchn_port_t port;
 } evtchn_send_t;
 
 /*
@@ -122,7 +124,7 @@ typedef struct evtchn_send {
 typedef struct evtchn_status {
     /* IN parameters */
     domid_t  dom;
-    uint32_t port;
+    evtchn_port_t port;
     /* OUT parameters */
 #define EVTCHNSTAT_closed       0  /* Channel is not in use.                 */
 #define EVTCHNSTAT_unbound      1  /* Channel is waiting interdom connection.*/
@@ -134,11 +136,11 @@ typedef struct evtchn_status {
     uint32_t vcpu;                 /* VCPU to which this channel is bound.   */
     union {
         struct {
-            domid_t  dom;
+            domid_t dom;
         } unbound; /* EVTCHNSTAT_unbound */
         struct {
-            domid_t  dom;
-            uint32_t port;
+            domid_t dom;
+            evtchn_port_t port;
         } interdomain; /* EVTCHNSTAT_interdomain */
         uint32_t pirq;      /* EVTCHNSTAT_pirq        */
         uint32_t virq;      /* EVTCHNSTAT_virq        */
@@ -158,7 +160,7 @@ typedef struct evtchn_status {
 #define EVTCHNOP_bind_vcpu        8
 typedef struct evtchn_bind_vcpu {
     /* IN parameters. */
-    uint32_t port;
+    evtchn_port_t port;
     uint32_t vcpu;
 } evtchn_bind_vcpu_t;
 
Index: linux-2.6.14/include/asm-xen/xen-public/grant_table.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/grant_table.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/grant_table.h	2005-12-05 17:00:02.000000000 +0100
@@ -73,14 +73,14 @@
  */
 typedef struct grant_entry {
     /* GTF_xxx: various type and flag information.  [XEN,GST] */
-    uint16_t     flags;
+    uint16_t flags;
     /* The domain being granted foreign privileges. [GST] */
-    domid_t domid;
+    domid_t  domid;
     /*
      * GTF_permit_access: Frame that @domid is allowed to map and access. [GST]
      * GTF_accept_transfer: Frame whose ownership transferred by @domid. [XEN]
      */
-    uint32_t     frame;
+    uint32_t frame;
 } grant_entry_t;
 
 /*
@@ -131,7 +131,12 @@ typedef struct grant_entry {
 /*
  * Reference to a grant entry in a specified domain's grant table.
  */
-typedef uint16_t grant_ref_t;
+typedef uint32_t grant_ref_t;
+
+/*
+ * Handle to track a mapping created via a grant reference.
+ */
+typedef uint32_t grant_handle_t;
 
 /*
  * GNTTABOP_map_grant_ref: Map the grant entry (<dom>,<ref>) for access
@@ -154,11 +159,12 @@ typedef uint16_t grant_ref_t;
 typedef struct gnttab_map_grant_ref {
     /* IN parameters. */
     uint64_t host_addr;
-    domid_t  dom;
+    uint32_t flags;               /* GNTMAP_* */
     grant_ref_t ref;
-    uint16_t flags;               /* GNTMAP_* */
+    domid_t  dom;
     /* OUT parameters. */
-    int16_t  handle;              /* +ve: handle; -ve: GNTST_* */
+    int16_t  status;              /* GNTST_* */
+    grant_handle_t handle;
     uint64_t dev_bus_addr;
 } gnttab_map_grant_ref_t;
 
@@ -178,7 +184,7 @@ typedef struct gnttab_unmap_grant_ref {
     /* IN parameters. */
     uint64_t host_addr;
     uint64_t dev_bus_addr;
-    uint16_t handle;
+    grant_handle_t handle;
     /* OUT parameters. */
     int16_t  status;              /* GNTST_* */
 } gnttab_unmap_grant_ref_t;
@@ -196,7 +202,7 @@ typedef struct gnttab_unmap_grant_ref {
 typedef struct gnttab_setup_table {
     /* IN parameters. */
     domid_t  dom;
-    uint16_t nr_frames;
+    uint32_t nr_frames;
     /* OUT parameters. */
     int16_t  status;              /* GNTST_* */
     unsigned long *frame_list;
@@ -283,7 +289,8 @@ typedef struct {
     "invalid virtual address",                  \
     "invalid device address",                   \
     "no spare translation slot in the I/O MMU", \
-    "permission denied"                         \
+    "permission denied",                        \
+    "bad page"                                  \
 }
 
 #endif /* __XEN_PUBLIC_GRANT_TABLE_H__ */
Index: linux-2.6.14/include/asm-xen/xen-public/io/blkif.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/io/blkif.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/io/blkif.h	2005-12-05 17:00:02.000000000 +0100
@@ -10,6 +10,19 @@
 #define __XEN_PUBLIC_IO_BLKIF_H__
 
 #include "ring.h"
+#include "../grant_table.h"
+
+/*
+ * Front->back notifications: When enqueuing a new request, sending a
+ * notification can be made conditional on req_event (i.e., the generic
+ * hold-off mechanism provided by the ring macros). Backends must set
+ * req_event appropriately (e.g., using RING_FINAL_CHECK_FOR_REQUESTS()).
+ * 
+ * Back->front notifications: When enqueuing a new response, sending a
+ * notification can be made conditional on rsp_event (i.e., the generic
+ * hold-off mechanism provided by the ring macros). Frontends must set
+ * rsp_event appropriately (e.g., using RING_FINAL_CHECK_FOR_RESPONSES()).
+ */
 
 #ifndef blkif_vdev_t
 #define blkif_vdev_t   uint16_t
@@ -19,9 +32,6 @@
 #define BLKIF_OP_READ      0
 #define BLKIF_OP_WRITE     1
 
-/* NB. Ring size must be small enough for sizeof(blkif_ring_t) <= PAGE_SIZE. */
-#define BLKIF_RING_SIZE        64
-
 /*
  * Maximum scatter/gather segments per request.
  * This is carefully chosen so that sizeof(blkif_ring_t) <= PAGE_SIZE.
@@ -33,24 +43,18 @@ typedef struct blkif_request {
     uint8_t        operation;    /* BLKIF_OP_???                         */
     uint8_t        nr_segments;  /* number of segments                   */
     blkif_vdev_t   handle;       /* only for read/write requests         */
-    unsigned long  id;           /* private guest value, echoed in resp  */
+    uint64_t       id;           /* private guest value, echoed in resp  */
     blkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */
-    /* @f_a_s[4:0]=last_sect ; @f_a_s[9:5]=first_sect                        */
-    /* @f_a_s[:16]= grant reference (16 bits)                                */
-    /* @first_sect: first sector in frame to transfer (inclusive).           */
-    /* @last_sect: last sector in frame to transfer (inclusive).             */
-    unsigned long  frame_and_sects[BLKIF_MAX_SEGMENTS_PER_REQUEST];
+    struct blkif_request_segment {
+        grant_ref_t gref;        /* reference to I/O buffer frame        */
+        /* @first_sect: first sector in frame to transfer (inclusive).   */
+        /* @last_sect: last sector in frame to transfer (inclusive).     */
+        uint8_t     first_sect, last_sect;
+    } seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];
 } blkif_request_t;
 
-#define blkif_fas(_addr, _fs, _ls) ((_addr)|((_fs)<<5)|(_ls))
-#define blkif_first_sect(_fas) (((_fas)>>5)&31)
-#define blkif_last_sect(_fas)  ((_fas)&31)
-
-#define blkif_fas_from_gref(_gref, _fs, _ls) (((_gref)<<16)|((_fs)<<5)|(_ls))
-#define blkif_gref_from_fas(_fas) ((_fas)>>16)
-
 typedef struct blkif_response {
-    unsigned long   id;              /* copied from request */
+    uint64_t        id;              /* copied from request */
     uint8_t         operation;       /* copied from request */
     int16_t         status;          /* BLKIF_RSP_???       */
 } blkif_response_t;
@@ -58,9 +62,6 @@ typedef struct blkif_response {
 #define BLKIF_RSP_ERROR  -1 /* non-specific 'error' */
 #define BLKIF_RSP_OKAY    0 /* non-specific 'okay'  */
 
-#define BLKIF_MAJOR(dev) ((dev)>>8)
-#define BLKIF_MINOR(dev) ((dev) & 0xff)
-
 /*
  * Generate blkif ring structures and types.
  */
Index: linux-2.6.14/include/asm-xen/xen-public/io/netif.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/io/netif.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/io/netif.h	2005-12-05 17:00:02.000000000 +0100
@@ -9,17 +9,31 @@
 #ifndef __XEN_PUBLIC_IO_NETIF_H__
 #define __XEN_PUBLIC_IO_NETIF_H__
 
+#include "ring.h"
+#include "../grant_table.h"
+
+/*
+ * Note that there is *never* any need to notify the backend when enqueuing
+ * receive requests (netif_rx_request_t). Notifications after enqueuing any
+ * other type of message should be conditional on the appropriate req_event
+ * or rsp_event field in the shared ring.
+ */
+
+/* Protocol checksum field is blank in the packet (hardware offload)? */
+#define _NETTXF_csum_blank (0)
+#define  NETTXF_csum_blank (1U<<_NETTXF_csum_blank)
+
 typedef struct netif_tx_request {
     grant_ref_t gref;      /* Reference to buffer page */
-    uint16_t offset:15;    /* Offset within buffer page */
-    uint16_t csum_blank:1; /* Proto csum field blank?   */
+    uint16_t offset;       /* Offset within buffer page */
+    uint16_t flags;        /* NETTXF_* */
     uint16_t id;           /* Echoed in response message. */
     uint16_t size;         /* Packet size in bytes.       */
 } netif_tx_request_t;
 
 typedef struct netif_tx_response {
     uint16_t id;
-    int8_t   status;
+    int16_t  status;       /* NETIF_RSP_* */
 } netif_tx_response_t;
 
 typedef struct {
@@ -27,65 +41,24 @@ typedef struct {
     grant_ref_t gref;      /* Reference to incoming granted frame */
 } netif_rx_request_t;
 
+/* Protocol checksum already validated (e.g., performed by hardware)? */
+#define _NETRXF_csum_valid (0)
+#define  NETRXF_csum_valid (1U<<_NETRXF_csum_valid)
+
 typedef struct {
-    uint16_t offset;     /* Offset in page of start of received packet  */
-    uint16_t csum_valid; /* Protocol checksum is validated?       */
     uint16_t id;
-    int16_t  status;     /* -ve: BLKIF_RSP_* ; +ve: Rx'ed pkt size. */
+    uint16_t offset;       /* Offset in page of start of received packet  */
+    uint16_t flags;        /* NETRXF_* */
+    int16_t  status;       /* -ve: BLKIF_RSP_* ; +ve: Rx'ed pkt size. */
 } netif_rx_response_t;
 
 /*
- * We use a special capitalised type name because it is _essential_ that all 
- * arithmetic on indexes is done on an integer type of the correct size.
+ * Generate netif ring structures and types.
  */
-typedef uint32_t NETIF_RING_IDX;
 
-/*
- * Ring indexes are 'free running'. That is, they are not stored modulo the
- * size of the ring buffer. The following macros convert a free-running counter
- * into a value that can directly index a ring-buffer array.
- */
-#define MASK_NETIF_RX_IDX(_i) ((_i)&(NETIF_RX_RING_SIZE-1))
-#define MASK_NETIF_TX_IDX(_i) ((_i)&(NETIF_TX_RING_SIZE-1))
-
-#define NETIF_TX_RING_SIZE 256
-#define NETIF_RX_RING_SIZE 256
-
-/* This structure must fit in a memory page. */
-typedef struct netif_tx_interface {
-    /*
-     * Frontend places packets into ring at tx_req_prod.
-     * Frontend receives event when tx_resp_prod passes tx_event.
-     * 'req_cons' is a shadow of the backend's request consumer -- the frontend
-     * may use it to determine if all queued packets have been seen by the
-     * backend.
-     */
-    NETIF_RING_IDX req_prod;
-    NETIF_RING_IDX req_cons;
-    NETIF_RING_IDX resp_prod;
-    NETIF_RING_IDX event;
-    union {
-        netif_tx_request_t  req;
-        netif_tx_response_t resp;
-    } ring[NETIF_TX_RING_SIZE];
-} netif_tx_interface_t;
-
-/* This structure must fit in a memory page. */
-typedef struct netif_rx_interface {
-    /*
-     * Frontend places empty buffers into ring at rx_req_prod.
-     * Frontend receives event when rx_resp_prod passes rx_event.
-     */
-    NETIF_RING_IDX req_prod;
-    NETIF_RING_IDX resp_prod;
-    NETIF_RING_IDX event;
-    union {
-        netif_rx_request_t  req;
-        netif_rx_response_t resp;
-    } ring[NETIF_RX_RING_SIZE];
-} netif_rx_interface_t;
+DEFINE_RING_TYPES(netif_tx, netif_tx_request_t, netif_tx_response_t);
+DEFINE_RING_TYPES(netif_rx, netif_rx_request_t, netif_rx_response_t);
 
-/* Descriptor status values */
 #define NETIF_RSP_DROPPED         -2
 #define NETIF_RSP_ERROR           -1
 #define NETIF_RSP_OKAY             0
Index: linux-2.6.14/include/asm-xen/xen-public/io/ring.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/io/ring.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/io/ring.h	2005-12-05 17:00:03.000000000 +0100
@@ -1,7 +1,10 @@
-/*
+/******************************************************************************
+ * ring.h
+ * 
  * Shared producer-consumer ring macros.
+ *
  * Tim Deegan and Andrew Warfield November 2004.
- */ 
+ */
 
 #ifndef __XEN_PUBLIC_IO_RING_H__
 #define __XEN_PUBLIC_IO_RING_H__
@@ -22,35 +25,38 @@ typedef unsigned int RING_IDX;
  * power of two (so we can mask with (size-1) to loop around).
  */
 #define __RING_SIZE(_s, _sz) \
-    (__RD32(((_sz) - 2*sizeof(RING_IDX)) / sizeof((_s)->ring[0])))
+    (__RD32(((_sz) - (long)&(_s)->ring + (long)(_s)) / sizeof((_s)->ring[0])))
 
 /*
- *  Macros to make the correct C datatypes for a new kind of ring.
+ * Macros to make the correct C datatypes for a new kind of ring.
  * 
- *  To make a new ring datatype, you need to have two message structures,
- *  let's say request_t, and response_t already defined.
+ * To make a new ring datatype, you need to have two message structures,
+ * let's say request_t, and response_t already defined.
  *
- *  In a header where you want the ring datatype declared, you then do:
+ * In a header where you want the ring datatype declared, you then do:
  *
  *     DEFINE_RING_TYPES(mytag, request_t, response_t);
  *
- *  These expand out to give you a set of types, as you can see below.
- *  The most important of these are:
+ * These expand out to give you a set of types, as you can see below.
+ * The most important of these are:
  *  
  *     mytag_sring_t      - The shared ring.
  *     mytag_front_ring_t - The 'front' half of the ring.
  *     mytag_back_ring_t  - The 'back' half of the ring.
  *
- *  To initialize a ring in your code you need to know the location and size
- *  of the shared memory area (PAGE_SIZE, for instance). To initialise
- *  the front half:
+ * To initialize a ring in your code you need to know the location and size
+ * of the shared memory area (PAGE_SIZE, for instance). To initialise
+ * the front half:
  *
- *      mytag_front_ring_t front_ring;
+ *     mytag_front_ring_t front_ring;
+ *     SHARED_RING_INIT((mytag_sring_t *)shared_page);
+ *     FRONT_RING_INIT(&front_ring, (mytag_sring_t *)shared_page, PAGE_SIZE);
  *
- *      SHARED_RING_INIT((mytag_sring_t *)shared_page);
- *      FRONT_RING_INIT(&front_ring, (mytag_sring_t *)shared_page, PAGE_SIZE);
+ * Initializing the back follows similarly (note that only the front
+ * initializes the shared ring):
  *
- *  Initializing the back follows similarly...
+ *     mytag_back_ring_t back_ring;
+ *     BACK_RING_INIT(&back_ring, (mytag_sring_t *)shared_page, PAGE_SIZE);
  */
          
 #define DEFINE_RING_TYPES(__name, __req_t, __rsp_t)                     \
@@ -63,8 +69,9 @@ union __name##_sring_entry {            
                                                                         \
 /* Shared ring page */                                                  \
 struct __name##_sring {                                                 \
-    RING_IDX req_prod;                                                  \
-    RING_IDX rsp_prod;                                                  \
+    RING_IDX req_prod, req_event;                                       \
+    RING_IDX rsp_prod, rsp_event;                                       \
+    uint8_t  pad[48];                                                   \
     union __name##_sring_entry ring[1]; /* variable-length */           \
 };                                                                      \
                                                                         \
@@ -90,24 +97,25 @@ typedef struct __name##_front_ring __nam
 typedef struct __name##_back_ring __name##_back_ring_t
 
 /*
- *   Macros for manipulating rings.  
+ * Macros for manipulating rings.  
  * 
- *   FRONT_RING_whatever works on the "front end" of a ring: here 
- *   requests are pushed on to the ring and responses taken off it.
+ * FRONT_RING_whatever works on the "front end" of a ring: here 
+ * requests are pushed on to the ring and responses taken off it.
  * 
- *   BACK_RING_whatever works on the "back end" of a ring: here 
- *   requests are taken off the ring and responses put on.
+ * BACK_RING_whatever works on the "back end" of a ring: here 
+ * requests are taken off the ring and responses put on.
  * 
- *   N.B. these macros do NO INTERLOCKS OR FLOW CONTROL.  
- *   This is OK in 1-for-1 request-response situations where the 
- *   requestor (front end) never has more than RING_SIZE()-1
- *   outstanding requests.
+ * N.B. these macros do NO INTERLOCKS OR FLOW CONTROL.  
+ * This is OK in 1-for-1 request-response situations where the 
+ * requestor (front end) never has more than RING_SIZE()-1
+ * outstanding requests.
  */
 
 /* Initialising empty rings */
 #define SHARED_RING_INIT(_s) do {                                       \
-    (_s)->req_prod = 0;                                                 \
-    (_s)->rsp_prod = 0;                                                 \
+    (_s)->req_prod  = (_s)->rsp_prod  = 0;                              \
+    (_s)->req_event = (_s)->rsp_event = 1;                              \
+    memset((_s)->pad, 0, sizeof((_s)->pad));                            \
 } while(0)
 
 #define FRONT_RING_INIT(_r, _s, __size) do {                            \
@@ -143,10 +151,6 @@ typedef struct __name##_back_ring __name
 #define RING_SIZE(_r)                                                   \
     ((_r)->nr_ents)
 
-/* How many empty slots are on a ring? */
-#define RING_PENDING_REQUESTS(_r)                                       \
-   ( ((_r)->req_prod_pvt - (_r)->rsp_cons) )
-   
 /* Test if there is an empty slot available on the front ring. 
  * (This is only meaningful from the front. )
  */
@@ -162,25 +166,6 @@ typedef struct __name##_back_ring __name
      (((_r)->req_cons - (_r)->rsp_prod_pvt) !=                          \
       RING_SIZE(_r)) )
       
-/* Test if there are messages waiting to be pushed. */
-#define RING_HAS_UNPUSHED_REQUESTS(_r)                                  \
-   ( (_r)->req_prod_pvt != (_r)->sring->req_prod )
-   
-#define RING_HAS_UNPUSHED_RESPONSES(_r)                                 \
-   ( (_r)->rsp_prod_pvt != (_r)->sring->rsp_prod )
-
-/* Copy the private producer pointer into the shared ring so the other end 
- * can see the updates we've made. */
-#define RING_PUSH_REQUESTS(_r) do {                                     \
-    wmb();                                                              \
-    (_r)->sring->req_prod = (_r)->req_prod_pvt;                         \
-} while (0)
-
-#define RING_PUSH_RESPONSES(_r) do {                                    \
-    wmb();                                                              \
-    (_r)->sring->rsp_prod = (_r)->rsp_prod_pvt;                         \
-} while (0)
-
 /* Direct access to individual ring elements, by index. */
 #define RING_GET_REQUEST(_r, _idx)                                      \
  (&((_r)->sring->ring[                                                  \
@@ -196,6 +181,82 @@ typedef struct __name##_back_ring __name
 #define RING_REQUEST_CONS_OVERFLOW(_r, _cons)                           \
     (((_cons) - (_r)->rsp_prod_pvt) >= RING_SIZE(_r))
 
+#define RING_PUSH_REQUESTS(_r) do {                                     \
+    wmb(); /* back sees requests /before/ updated producer index */     \
+    (_r)->sring->req_prod = (_r)->req_prod_pvt;                         \
+} while (0)
+
+#define RING_PUSH_RESPONSES(_r) do {                                    \
+    wmb(); /* front sees responses /before/ updated producer index */   \
+    (_r)->sring->rsp_prod = (_r)->rsp_prod_pvt;                         \
+} while (0)
+
+/*
+ * Notification hold-off (req_event and rsp_event):
+ * 
+ * When queueing requests or responses on a shared ring, it may not always be
+ * necessary to notify the remote end. For example, if requests are in flight
+ * in a backend, the front may be able to queue further requests without
+ * notifying the back (if the back checks for new requests when it queues
+ * responses).
+ * 
+ * When enqueuing requests or responses:
+ * 
+ *  Use RING_PUSH_{REQUESTS,RESPONSES}_AND_CHECK_NOTIFY(). The second argument
+ *  is a boolean return value. True indicates that the receiver requires an
+ *  asynchronous notification.
+ * 
+ * After dequeuing requests or responses (before sleeping the connection):
+ * 
+ *  Use RING_FINAL_CHECK_FOR_REQUESTS() or RING_FINAL_CHECK_FOR_RESPONSES().
+ *  The second argument is a boolean return value. True indicates that there
+ *  are pending messages on the ring (i.e., the connection should not be put
+ *  to sleep).
+ *  
+ *  These macros will set the req_event/rsp_event field to trigger a
+ *  notification on the very next message that is enqueued. If you want to
+ *  create batches of work (i.e., only receive a notification after several
+ *  messages have been enqueued) then you will need to create a customised
+ *  version of the FINAL_CHECK macro in your own code, which sets the event
+ *  field appropriately.
+ */
+
+#define RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(_r, _notify) do {           \
+    RING_IDX __old = (_r)->sring->req_prod;                             \
+    RING_IDX __new = (_r)->req_prod_pvt;                                \
+    wmb(); /* back sees requests /before/ updated producer index */     \
+    (_r)->sring->req_prod = __new;                                      \
+    mb(); /* back sees new requests /before/ we check req_event */      \
+    (_notify) = ((RING_IDX)(__new - (_r)->sring->req_event) <           \
+                 (RING_IDX)(__new - __old));                            \
+} while (0)
+
+#define RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(_r, _notify) do {          \
+    RING_IDX __old = (_r)->sring->rsp_prod;                             \
+    RING_IDX __new = (_r)->rsp_prod_pvt;                                \
+    wmb(); /* front sees responses /before/ updated producer index */   \
+    (_r)->sring->rsp_prod = __new;                                      \
+    mb(); /* front sees new responses /before/ we check rsp_event */    \
+    (_notify) = ((RING_IDX)(__new - (_r)->sring->rsp_event) <           \
+                 (RING_IDX)(__new - __old));                            \
+} while (0)
+
+#define RING_FINAL_CHECK_FOR_REQUESTS(_r, _work_to_do) do {             \
+    (_work_to_do) = RING_HAS_UNCONSUMED_REQUESTS(_r);                   \
+    if (_work_to_do) break;                                             \
+    (_r)->sring->req_event = (_r)->req_cons + 1;                        \
+    mb();                                                               \
+    (_work_to_do) = RING_HAS_UNCONSUMED_REQUESTS(_r);                   \
+} while (0)
+
+#define RING_FINAL_CHECK_FOR_RESPONSES(_r, _work_to_do) do {            \
+    (_work_to_do) = RING_HAS_UNCONSUMED_RESPONSES(_r);                  \
+    if (_work_to_do) break;                                             \
+    (_r)->sring->rsp_event = (_r)->rsp_cons + 1;                        \
+    mb();                                                               \
+    (_work_to_do) = RING_HAS_UNCONSUMED_RESPONSES(_r);                  \
+} while (0)
+
 #endif /* __XEN_PUBLIC_IO_RING_H__ */
 
 /*
Index: linux-2.6.14/include/asm-xen/xen-public/io/tpmif.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/io/tpmif.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/io/tpmif.h	2005-12-05 17:00:03.000000000 +0100
@@ -16,9 +16,11 @@
 #ifndef __XEN_PUBLIC_IO_TPMIF_H__
 #define __XEN_PUBLIC_IO_TPMIF_H__
 
+#include "../grant_table.h"
+
 typedef struct {
     unsigned long addr;   /* Machine address of packet.   */
-    int      ref;         /* grant table access reference */
+    grant_ref_t ref;      /* grant table access reference */
     uint16_t id;          /* Echoed in response message.  */
     uint16_t size;        /* Packet size in bytes.        */
 } tpmif_tx_request_t;
Index: linux-2.6.14/include/asm-xen/xen-public/sched_ctl.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/sched_ctl.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/sched_ctl.h	2005-12-05 17:00:03.000000000 +0100
@@ -48,8 +48,8 @@ struct sched_adjdom_cmd {
             uint64_t period;
             uint64_t slice;
             uint64_t latency;
-            uint16_t extratime;
-            uint16_t weight;
+            uint32_t extratime;
+            uint32_t weight;
         } sedf;
 
     } u;
Index: linux-2.6.14/include/asm-xen/xen-public/xen.h
===================================================================
--- linux-2.6.14.orig/include/asm-xen/xen-public/xen.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/include/asm-xen/xen-public/xen.h	2005-12-05 17:00:03.000000000 +0100
@@ -410,9 +410,9 @@ typedef struct start_info {
     unsigned long shared_info;  /* MACHINE address of shared info struct. */
     uint32_t flags;             /* SIF_xxx flags.                         */
     unsigned long store_mfn;    /* MACHINE page number of shared page.    */
-    uint16_t store_evtchn;      /* Event channel for store communication. */
+    uint32_t store_evtchn;      /* Event channel for store communication. */
     unsigned long console_mfn;  /* MACHINE address of console page.       */
-    uint16_t console_evtchn;    /* Event channel for console messages.    */
+    uint32_t console_evtchn;    /* Event channel for console messages.    */
     /* THE FOLLOWING ARE ONLY FILLED IN ON INITIAL BOOT (NOT RESUME).     */
     unsigned long pt_base;      /* VIRTUAL address of page directory.     */
     unsigned long nr_pt_frames; /* Number of bootstrap p.t. frames.       */
