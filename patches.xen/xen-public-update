Subject: update xen3 hypervisor headers
From: kraxel@suse.de

Index: head-2006-02-07/include/asm-xen/xen-public/acm.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/acm.h	2006-02-07 15:04:58.928941488 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/acm.h	2006-02-07 15:05:06.557781728 +0100
@@ -1,25 +1,8 @@
-/****************************************************************
- * acm.h
- * 
- * Copyright (C) 2005 IBM Corporation
+/*
+ * acm.h: Xen access control module interface defintions
  *
- * Author:
  * Reiner Sailer <sailer@watson.ibm.com>
- *
- * Contributors:
- * Stefan Berger <stefanb@watson.ibm.com> 
- * added network byte order support for binary policies
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2 of the
- * License.
- *
- * sHype general access control module header file.
- *     here are all definitions that are shared between
- *     xen-core, guest-kernels, and applications.
- *
- * todo: move from static policy choice to compile option.
+ * Copyright (c) 2005, International Business Machines Corporation.
  */
 
 #ifndef _XEN_PUBLIC_ACM_H
Index: head-2006-02-07/include/asm-xen/xen-public/acm_ops.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/acm_ops.h	2006-02-07 15:04:58.931941032 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/acm_ops.h	2006-02-07 15:05:06.559781424 +0100
@@ -1,19 +1,8 @@
-/******************************************************************************
- * acm_ops.h
- *
- * Copyright (C) 2005 IBM Corporation
+/*
+ * acm_ops.h: Xen access control module hypervisor commands
  *
- * Author:
  * Reiner Sailer <sailer@watson.ibm.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2 of the
- * License.
- *
- * Process acm policy command requests from guest OS.
- * access checked by policy; not restricted to DOM0
- *
+ * Copyright (c) 2005, International Business Machines Corporation.
  */
 
 #ifndef __XEN_PUBLIC_ACM_OPS_H__
Index: head-2006-02-07/include/asm-xen/xen-public/arch-ia64.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/arch-ia64.h	2006-02-07 15:04:58.929941336 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/arch-ia64.h	2006-02-07 15:05:06.562780968 +0100
@@ -9,7 +9,7 @@
 
 /* Maximum number of virtual CPUs in multi-processor guests. */
 /* WARNING: before changing this, check that shared_info fits on a page */
-#define MAX_VIRT_CPUS 1
+#define MAX_VIRT_CPUS 4
 
 #ifndef __ASSEMBLY__
 
@@ -38,6 +38,33 @@ typedef struct {
 
 #define INVALID_MFN       (~0UL)
 
+#define MEM_G   (1UL << 30)	
+#define MEM_M   (1UL << 20)	
+
+#define MMIO_START       (3 * MEM_G)
+#define MMIO_SIZE        (512 * MEM_M)
+
+#define VGA_IO_START     0xA0000UL
+#define VGA_IO_SIZE      0x20000
+
+#define LEGACY_IO_START  (MMIO_START + MMIO_SIZE)
+#define LEGACY_IO_SIZE   (64*MEM_M)  
+
+#define IO_PAGE_START (LEGACY_IO_START + LEGACY_IO_SIZE)
+#define IO_PAGE_SIZE  PAGE_SIZE
+
+#define STORE_PAGE_START (IO_PAGE_START + IO_PAGE_SIZE)
+#define STORE_PAGE_SIZE	 PAGE_SIZE
+
+#define IO_SAPIC_START   0xfec00000UL
+#define IO_SAPIC_SIZE    0x100000
+
+#define PIB_START 0xfee00000UL
+#define PIB_SIZE 0x100000 
+
+#define GFW_START        (4*MEM_G -16*MEM_M)
+#define GFW_SIZE         (16*MEM_M)
+
 /*
  * NB. This may become a 64-bit count with no shift. If this happens then the 
  * structure size will still be 8 bytes, so no other alignments will change.
@@ -249,6 +276,12 @@ typedef struct {
     unsigned long start_info_pfn;
 } arch_shared_info_t;
 
+typedef struct {
+    unsigned long start;
+    unsigned long size; 
+} arch_initrd_info_t;
+
+#define IA64_COMMAND_LINE_SIZE 512
 typedef struct vcpu_guest_context {
 #define VGCF_FPU_VALID (1<<0)
 #define VGCF_VMX_GUEST (1<<1)
@@ -262,6 +295,8 @@ typedef struct vcpu_guest_context {
     cpu_user_regs_t regs;
     arch_vcpu_info_t vcpu;
     arch_shared_info_t shared;
+    arch_initrd_info_t initrd;
+    char cmdline[IA64_COMMAND_LINE_SIZE];
 } vcpu_guest_context_t;
 
 #endif /* !__ASSEMBLY__ */
Index: head-2006-02-07/include/asm-xen/xen-public/arch-x86_32.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/arch-x86_32.h	2006-02-07 15:04:58.930941184 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/arch-x86_32.h	2006-01-31 16:53:52.000000000 +0100
@@ -49,10 +49,15 @@
  * machine->physical mapping table starts at this address, read-only.
  */
 #ifdef CONFIG_X86_PAE
-# define HYPERVISOR_VIRT_START (0xF5800000UL)
+#define __HYPERVISOR_VIRT_START 0xF5800000
 #else
-# define HYPERVISOR_VIRT_START (0xFC000000UL)
+#define __HYPERVISOR_VIRT_START 0xFC000000
 #endif
+
+#ifndef HYPERVISOR_VIRT_START
+#define HYPERVISOR_VIRT_START mk_unsigned_long(__HYPERVISOR_VIRT_START)
+#endif
+
 #ifndef machine_to_phys_mapping
 #define machine_to_phys_mapping ((unsigned long *)HYPERVISOR_VIRT_START)
 #endif
@@ -109,11 +114,11 @@ typedef struct vcpu_guest_context {
     /* FPU registers come first so they can be aligned for FXSAVE/FXRSTOR. */
     struct { char x[512]; } fpu_ctxt;       /* User-level FPU registers     */
 #define VGCF_I387_VALID (1<<0)
-#define VGCF_VMX_GUEST  (1<<1)
+#define VGCF_HVM_GUEST  (1<<1)
 #define VGCF_IN_KERNEL  (1<<2)
     unsigned long flags;                    /* VGCF_* flags                 */
     cpu_user_regs_t user_regs;              /* User-level CPU registers     */
-    trap_info_t   trap_ctxt[256];           /* Virtual IDT                  */
+    struct trap_info trap_ctxt[256];        /* Virtual IDT                  */
     unsigned long ldt_base, ldt_ents;       /* LDT (linear address, # ents) */
     unsigned long gdt_frames[16], gdt_ents; /* GDT (machine frames, # ents) */
     unsigned long kernel_ss, kernel_sp;     /* Virtual TSS (only SS1/SP1)   */
@@ -130,6 +135,7 @@ typedef struct arch_shared_info {
     unsigned long max_pfn;                  /* max pfn that appears in table */
     /* Frame containing list of mfns containing list of mfns containing p2m. */
     unsigned long pfn_to_mfn_frame_list_list; 
+    unsigned long nmi_reason;
 } arch_shared_info_t;
 
 typedef struct {
@@ -137,7 +143,7 @@ typedef struct {
     unsigned long pad[5]; /* sizeof(vcpu_info_t) == 64 */
 } arch_vcpu_info_t;
 
-#endif
+#endif /* !__ASSEMBLY__ */
 
 #endif
 
Index: head-2006-02-07/include/asm-xen/xen-public/arch-x86_64.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/arch-x86_64.h	2006-02-07 15:04:58.930941184 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/arch-x86_64.h	2006-01-31 16:53:52.000000000 +0100
@@ -59,9 +59,12 @@
 /* And the trap vector is... */
 #define TRAP_INSTR "syscall"
 
+#define __HYPERVISOR_VIRT_START 0xFFFF800000000000
+#define __HYPERVISOR_VIRT_END   0xFFFF880000000000
+
 #ifndef HYPERVISOR_VIRT_START
-#define HYPERVISOR_VIRT_START (0xFFFF800000000000UL)
-#define HYPERVISOR_VIRT_END   (0xFFFF880000000000UL)
+#define HYPERVISOR_VIRT_START mk_unsigned_long(__HYPERVISOR_VIRT_START)
+#define HYPERVISOR_VIRT_END   mk_unsigned_long(__HYPERVISOR_VIRT_END)
 #endif
 
 /* Maximum number of virtual CPUs in multi-processor guests. */
@@ -85,11 +88,20 @@
 #define SEGBASE_GS_USER_SEL 3 /* Set user %gs specified in base[15:0] */
 
 /*
- * int HYPERVISOR_switch_to_user(void)
+ * int HYPERVISOR_iret(void)
  * All arguments are on the kernel stack, in the following format.
  * Never returns if successful. Current kernel context is lost.
+ * The saved CS is mapped as follows:
+ *   RING0 -> RING3 kernel mode.
+ *   RING1 -> RING3 kernel mode.
+ *   RING2 -> RING3 kernel mode.
+ *   RING3 -> RING3 user mode.
+ * However RING0 indicates that the guest kernel should return to iteself
+ * directly with
+ *      orb   $3,1*8(%rsp)
+ *      iretq
  * If flags contains VGCF_IN_SYSCALL:
- *   Restore RAX, RIP, RFLAGS, RSP. 
+ *   Restore RAX, RIP, RFLAGS, RSP.
  *   Discard R11, RCX, CS, SS.
  * Otherwise:
  *   Restore RAX, R11, RCX, CS:RIP, RFLAGS, SS:RSP.
@@ -97,10 +109,19 @@
  */
 /* Guest exited in SYSCALL context? Return to guest with SYSRET? */
 #define VGCF_IN_SYSCALL (1<<8)
+struct iret_context {
+    /* Top of stack (%rsp at point of hypercall). */
+    uint64_t rax, r11, rcx, flags, rip, cs, rflags, rsp, ss;
+    /* Bottom of iret stack frame. */
+};
+/*
+ * For compatibility with HYPERVISOR_switch_to_user which is the old
+ * name for HYPERVISOR_iret.
+ */
 struct switch_to_user {
     /* Top of stack (%rsp at point of hypercall). */
     uint64_t rax, r11, rcx, flags, rip, cs, rflags, rsp, ss;
-    /* Bottom of switch_to_user stack frame. */
+    /* Bottom of iret stack frame. */
 };
 
 /*
@@ -175,11 +196,11 @@ typedef struct vcpu_guest_context {
     /* FPU registers come first so they can be aligned for FXSAVE/FXRSTOR. */
     struct { char x[512]; } fpu_ctxt;       /* User-level FPU registers     */
 #define VGCF_I387_VALID (1<<0)
-#define VGCF_VMX_GUEST  (1<<1)
+#define VGCF_HVM_GUEST  (1<<1)
 #define VGCF_IN_KERNEL  (1<<2)
     unsigned long flags;                    /* VGCF_* flags                 */
     cpu_user_regs_t user_regs;              /* User-level CPU registers     */
-    trap_info_t   trap_ctxt[256];           /* Virtual IDT                  */
+    struct trap_info trap_ctxt[256];        /* Virtual IDT                  */
     unsigned long ldt_base, ldt_ents;       /* LDT (linear address, # ents) */
     unsigned long gdt_frames[16], gdt_ents; /* GDT (machine frames, # ents) */
     unsigned long kernel_ss, kernel_sp;     /* Virtual TSS (only SS1/SP1)   */
@@ -199,6 +220,7 @@ typedef struct arch_shared_info {
     unsigned long max_pfn;                  /* max pfn that appears in table */
     /* Frame containing list of mfns containing list of mfns containing p2m. */
     unsigned long pfn_to_mfn_frame_list_list; 
+    unsigned long nmi_reason;
 } arch_shared_info_t;
 
 typedef struct {
Index: head-2006-02-07/include/asm-xen/xen-public/dom0_ops.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/dom0_ops.h	2006-02-07 15:04:58.927941640 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/dom0_ops.h	2006-01-31 16:53:52.000000000 +0100
@@ -19,12 +19,12 @@
  * This makes sure that old versions of dom0 tools will stop working in a
  * well-defined way (rather than crashing the machine, for instance).
  */
-#define DOM0_INTERFACE_VERSION   0xAAAA1014
+#define DOM0_INTERFACE_VERSION   0x03000000
 
 /************************************************************************/
 
 #define DOM0_GETMEMLIST        2
-typedef struct {
+typedef struct dom0_getmemlist {
     /* IN variables. */
     domid_t       domain;
     unsigned long max_pfns;
@@ -42,7 +42,7 @@ typedef struct sched_ctl_cmd dom0_schedc
 typedef struct sched_adjdom_cmd dom0_adjustdom_t;
 
 #define DOM0_CREATEDOMAIN      8
-typedef struct {
+typedef struct dom0_createdomain {
     /* IN parameters */
     uint32_t ssidref;
     xen_domain_handle_t handle;
@@ -52,25 +52,25 @@ typedef struct {
 } dom0_createdomain_t;
 
 #define DOM0_DESTROYDOMAIN     9
-typedef struct {
+typedef struct dom0_destroydomain {
     /* IN variables. */
     domid_t domain;
 } dom0_destroydomain_t;
 
 #define DOM0_PAUSEDOMAIN      10
-typedef struct {
+typedef struct dom0_pausedomain {
     /* IN parameters. */
     domid_t domain;
 } dom0_pausedomain_t;
 
 #define DOM0_UNPAUSEDOMAIN    11
-typedef struct {
+typedef struct dom0_unpausedomain {
     /* IN parameters. */
     domid_t domain;
 } dom0_unpausedomain_t;
 
 #define DOM0_GETDOMAININFO    12
-typedef struct {
+typedef struct dom0_getdomaininfo {
     /* IN variables. */
     domid_t  domain;                  /* NB. IN/OUT variable. */
     /* OUT variables. */
@@ -94,17 +94,17 @@ typedef struct {
     xen_domain_handle_t handle;
 } dom0_getdomaininfo_t;
 
-#define DOM0_SETDOMAININFO      13
-typedef struct {
+#define DOM0_SETVCPUCONTEXT   13
+typedef struct dom0_setvcpucontext {
     /* IN variables. */
     domid_t               domain;
     uint32_t              vcpu;
     /* IN/OUT parameters */
     vcpu_guest_context_t *ctxt;
-} dom0_setdomaininfo_t;
+} dom0_setvcpucontext_t;
 
 #define DOM0_MSR              15
-typedef struct {
+typedef struct dom0_msr {
     /* IN variables. */
     uint32_t write;
     cpumap_t cpu_mask;
@@ -121,7 +121,7 @@ typedef struct {
  * 1 January, 1970 if the current system time was <system_time>.
  */
 #define DOM0_SETTIME          17
-typedef struct {
+typedef struct dom0_settime {
     /* IN variables. */
     uint32_t secs;
     uint32_t nsecs;
@@ -139,7 +139,7 @@ typedef struct {
 #define LTAB_MASK XTAB
 #define LTABTYPE_MASK (0x7<<28)
 
-typedef struct {
+typedef struct dom0_getpageframeinfo {
     /* IN variables. */
     unsigned long pfn;     /* Machine page frame number to query.       */
     domid_t domain;        /* To which domain does the frame belong?    */
@@ -152,7 +152,7 @@ typedef struct {
  * Read console content from Xen buffer ring.
  */
 #define DOM0_READCONSOLE      19
-typedef struct {
+typedef struct dom0_readconsole {
     /* IN variables. */
     uint32_t clear;        /* Non-zero -> clear after reading. */
     /* IN/OUT variables. */
@@ -163,17 +163,17 @@ typedef struct {
 /* 
  * Set which physical cpus a vcpu can execute on.
  */
-#define DOM0_PINCPUDOMAIN     20
-typedef struct {
+#define DOM0_SETVCPUAFFINITY  20
+typedef struct dom0_setvcpuaffinity {
     /* IN variables. */
     domid_t   domain;
     uint32_t  vcpu;
     cpumap_t  cpumap;
-} dom0_pincpudomain_t;
+} dom0_setvcpuaffinity_t;
 
 /* Get trace buffers machine base address */
 #define DOM0_TBUFCONTROL       21
-typedef struct {
+typedef struct dom0_tbufcontrol {
     /* IN variables */
 #define DOM0_TBUF_GET_INFO     0
 #define DOM0_TBUF_SET_CPU_MASK 1
@@ -194,7 +194,7 @@ typedef struct {
  * Get physical information about the host machine
  */
 #define DOM0_PHYSINFO         22
-typedef struct {
+typedef struct dom0_physinfo {
     uint32_t threads_per_core;
     uint32_t cores_per_socket;
     uint32_t sockets_per_node;
@@ -209,7 +209,7 @@ typedef struct {
  * Get the ID of the current scheduler.
  */
 #define DOM0_SCHED_ID        24
-typedef struct {
+typedef struct dom0_sched_id {
     /* OUT variable */
     uint32_t sched_id;
 } dom0_sched_id_t;
@@ -228,15 +228,14 @@ typedef struct {
 #define DOM0_SHADOW_CONTROL_OP_CLEAN       11
 #define DOM0_SHADOW_CONTROL_OP_PEEK        12
 
-typedef struct dom0_shadow_control
-{
+typedef struct dom0_shadow_control_stats {
     uint32_t fault_count;
     uint32_t dirty_count;
     uint32_t dirty_net_count;     
     uint32_t dirty_block_count;     
 } dom0_shadow_control_stats_t;
 
-typedef struct {
+typedef struct dom0_shadow_control {
     /* IN variables. */
     domid_t        domain;
     uint32_t       op;
@@ -248,14 +247,14 @@ typedef struct {
 } dom0_shadow_control_t;
 
 #define DOM0_SETDOMAINMAXMEM   28
-typedef struct {
+typedef struct dom0_setdomainmaxmem {
     /* IN variables. */
     domid_t       domain;
     unsigned long max_memkb;
 } dom0_setdomainmaxmem_t;
 
 #define DOM0_GETPAGEFRAMEINFO2 29   /* batched interface */
-typedef struct {
+typedef struct dom0_getpageframeinfo2 {
     /* IN variables. */
     domid_t        domain;
     unsigned long  num;
@@ -271,7 +270,7 @@ typedef struct {
  * (x86-specific).
  */
 #define DOM0_ADD_MEMTYPE         31
-typedef struct {
+typedef struct dom0_add_memtype {
     /* IN variables. */
     unsigned long pfn;
     unsigned long nr_pfns;
@@ -289,7 +288,7 @@ typedef struct {
  * (x86-specific).
  */
 #define DOM0_DEL_MEMTYPE         32
-typedef struct {
+typedef struct dom0_del_memtype {
     /* IN variables. */
     uint32_t handle;
     uint32_t reg;
@@ -297,7 +296,7 @@ typedef struct {
 
 /* Read current type of an MTRR (x86-specific). */
 #define DOM0_READ_MEMTYPE        33
-typedef struct {
+typedef struct dom0_read_memtype {
     /* IN variables. */
     uint32_t reg;
     /* OUT variables. */
@@ -311,12 +310,12 @@ typedef struct {
 /* Sub-operations: */
 #define DOM0_PERFCCONTROL_OP_RESET 1   /* Reset all counters to zero. */
 #define DOM0_PERFCCONTROL_OP_QUERY 2   /* Get perfctr information. */
-typedef struct {
+typedef struct dom0_perfc_desc {
     uint8_t      name[80];             /* name of perf counter */
     uint32_t     nr_vals;              /* number of values for this counter */
     uint32_t     vals[64];             /* array of values */
 } dom0_perfc_desc_t;
-typedef struct {
+typedef struct dom0_perfccontrol {
     /* IN variables. */
     uint32_t       op;                /*  DOM0_PERFCCONTROL_OP_??? */
     /* OUT variables. */
@@ -325,14 +324,14 @@ typedef struct {
 } dom0_perfccontrol_t;
 
 #define DOM0_MICROCODE           35
-typedef struct {
+typedef struct dom0_microcode {
     /* IN variables. */
     void    *data;                    /* Pointer to microcode data */
     uint32_t length;                  /* Length of microcode data. */
 } dom0_microcode_t;
 
 #define DOM0_IOPORT_PERMISSION   36
-typedef struct {
+typedef struct dom0_ioport_permission {
     domid_t  domain;                  /* domain to be affected */
     uint32_t first_port;              /* first port int range */
     uint32_t nr_ports;                /* size of port range */
@@ -340,7 +339,7 @@ typedef struct {
 } dom0_ioport_permission_t;
 
 #define DOM0_GETVCPUCONTEXT      37
-typedef struct {
+typedef struct dom0_getvcpucontext {
     /* IN variables. */
     domid_t  domain;                  /* domain to be affected */
     uint32_t vcpu;                    /* vcpu # */
@@ -349,7 +348,7 @@ typedef struct {
 } dom0_getvcpucontext_t;
 
 #define DOM0_GETVCPUINFO         43
-typedef struct {
+typedef struct dom0_getvcpuinfo {
     /* IN variables. */
     domid_t  domain;                  /* domain to be affected */
     uint32_t vcpu;                    /* vcpu # */
@@ -363,7 +362,7 @@ typedef struct {
 } dom0_getvcpuinfo_t;
 
 #define DOM0_GETDOMAININFOLIST   38
-typedef struct {
+typedef struct dom0_getdomaininfolist {
     /* IN variables. */
     domid_t               first_domain;
     uint32_t              max_domains;
@@ -374,13 +373,13 @@ typedef struct {
 
 #define DOM0_PLATFORM_QUIRK      39  
 #define QUIRK_NOIRQBALANCING  1
-typedef struct {
+typedef struct dom0_platform_quirk {
     /* IN variables. */
     uint32_t quirk_id;
 } dom0_platform_quirk_t;
 
 #define DOM0_PHYSICAL_MEMORY_MAP 40
-typedef struct {
+typedef struct dom0_physical_memory_map {
     /* IN variables. */
     uint32_t max_map_entries;
     /* OUT variables. */
@@ -393,54 +392,85 @@ typedef struct {
 } dom0_physical_memory_map_t;
 
 #define DOM0_MAX_VCPUS 41
-typedef struct {
+typedef struct dom0_max_vcpus {
     domid_t  domain;        /* domain to be affected */
     uint32_t max;           /* maximum number of vcpus */
 } dom0_max_vcpus_t;
 
 #define DOM0_SETDOMAINHANDLE 44
-typedef struct {
+typedef struct dom0_setdomainhandle {
     domid_t domain;
     xen_domain_handle_t handle;
 } dom0_setdomainhandle_t;
 
-typedef struct {
+#define DOM0_SETDEBUGGING 45
+typedef struct dom0_setdebugging {
+    domid_t domain;
+    uint8_t enable;
+} dom0_setdebugging_t;
+
+#define DOM0_IRQ_PERMISSION 46
+typedef struct dom0_irq_permission {
+    domid_t domain;          /* domain to be affected */
+    uint8_t pirq;
+    uint8_t allow_access;    /* flag to specify enable/disable of IRQ access */
+} dom0_irq_permission_t;
+
+#define DOM0_IOMEM_PERMISSION 47
+typedef struct dom0_iomem_permission {
+    domid_t  domain;          /* domain to be affected */
+    unsigned long first_pfn;  /* first page (physical page number) in range */
+    unsigned long nr_pfns;    /* number of pages in range (>0) */
+    uint8_t allow_access;     /* allow (!0) or deny (0) access to range? */
+} dom0_iomem_permission_t;
+ 
+#define DOM0_HYPERCALL_INIT   48
+typedef struct dom0_hypercall_init {
+    domid_t  domain;          /* domain to be affected */
+    unsigned long mfn;        /* machine frame to be initialised */
+} dom0_hypercall_init_t;
+ 
+typedef struct dom0_op {
     uint32_t cmd;
     uint32_t interface_version; /* DOM0_INTERFACE_VERSION */
     union {
-        dom0_createdomain_t      createdomain;
-        dom0_pausedomain_t       pausedomain;
-        dom0_unpausedomain_t     unpausedomain;
-        dom0_destroydomain_t     destroydomain;
-        dom0_getmemlist_t        getmemlist;
-        dom0_schedctl_t          schedctl;
-        dom0_adjustdom_t         adjustdom;
-        dom0_setdomaininfo_t     setdomaininfo;
-        dom0_getdomaininfo_t     getdomaininfo;
-        dom0_getpageframeinfo_t  getpageframeinfo;
-        dom0_msr_t               msr;
-        dom0_settime_t           settime;
-        dom0_readconsole_t       readconsole;
-        dom0_pincpudomain_t      pincpudomain;
-        dom0_tbufcontrol_t       tbufcontrol;
-        dom0_physinfo_t          physinfo;
-        dom0_sched_id_t          sched_id;
-        dom0_shadow_control_t    shadow_control;
-        dom0_setdomainmaxmem_t   setdomainmaxmem;
-        dom0_getpageframeinfo2_t getpageframeinfo2;
-        dom0_add_memtype_t       add_memtype;
-        dom0_del_memtype_t       del_memtype;
-        dom0_read_memtype_t      read_memtype;
-        dom0_perfccontrol_t      perfccontrol;
-        dom0_microcode_t         microcode;
-        dom0_ioport_permission_t ioport_permission;
-        dom0_getvcpucontext_t    getvcpucontext;
-        dom0_getvcpuinfo_t       getvcpuinfo;
-        dom0_getdomaininfolist_t getdomaininfolist;
-        dom0_platform_quirk_t    platform_quirk;
-        dom0_physical_memory_map_t physical_memory_map;
-        dom0_max_vcpus_t         max_vcpus;
-        dom0_setdomainhandle_t   setdomainhandle;
+        struct dom0_createdomain      createdomain;
+        struct dom0_pausedomain       pausedomain;
+        struct dom0_unpausedomain     unpausedomain;
+        struct dom0_destroydomain     destroydomain;
+        struct dom0_getmemlist        getmemlist;
+        struct sched_ctl_cmd          schedctl;
+        struct sched_adjdom_cmd       adjustdom;
+        struct dom0_setvcpucontext    setvcpucontext;
+        struct dom0_getdomaininfo     getdomaininfo;
+        struct dom0_getpageframeinfo  getpageframeinfo;
+        struct dom0_msr               msr;
+        struct dom0_settime           settime;
+        struct dom0_readconsole       readconsole;
+        struct dom0_setvcpuaffinity   setvcpuaffinity;
+        struct dom0_tbufcontrol       tbufcontrol;
+        struct dom0_physinfo          physinfo;
+        struct dom0_sched_id          sched_id;
+        struct dom0_shadow_control    shadow_control;
+        struct dom0_setdomainmaxmem   setdomainmaxmem;
+        struct dom0_getpageframeinfo2 getpageframeinfo2;
+        struct dom0_add_memtype       add_memtype;
+        struct dom0_del_memtype       del_memtype;
+        struct dom0_read_memtype      read_memtype;
+        struct dom0_perfccontrol      perfccontrol;
+        struct dom0_microcode         microcode;
+        struct dom0_ioport_permission ioport_permission;
+        struct dom0_getvcpucontext    getvcpucontext;
+        struct dom0_getvcpuinfo       getvcpuinfo;
+        struct dom0_getdomaininfolist getdomaininfolist;
+        struct dom0_platform_quirk    platform_quirk;
+        struct dom0_physical_memory_map physical_memory_map;
+        struct dom0_max_vcpus         max_vcpus;
+        struct dom0_setdomainhandle   setdomainhandle;        
+        struct dom0_setdebugging      setdebugging;
+        struct dom0_irq_permission    irq_permission;
+        struct dom0_iomem_permission  iomem_permission;
+        struct dom0_hypercall_init    hypercall_init;
         uint8_t                  pad[128];
     } u;
 } dom0_op_t;
Index: head-2006-02-07/include/asm-xen/xen-public/event_channel.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/event_channel.h	2006-02-07 15:04:58.930941184 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/event_channel.h	2006-02-07 15:05:06.569779904 +0100
@@ -164,6 +164,16 @@ typedef struct evtchn_bind_vcpu {
     uint32_t vcpu;
 } evtchn_bind_vcpu_t;
 
+/*
+ * EVTCHNOP_unmask: Unmask the specified local event-channel port and deliver
+ * a notification to the appropriate VCPU if an event is pending.
+ */
+#define EVTCHNOP_unmask           9
+typedef struct evtchn_unmask {
+    /* IN parameters. */
+    evtchn_port_t port;
+} evtchn_unmask_t;
+
 typedef struct evtchn_op {
     uint32_t cmd; /* EVTCHNOP_* */
     union {
@@ -176,6 +186,7 @@ typedef struct evtchn_op {
         evtchn_send_t             send;
         evtchn_status_t           status;
         evtchn_bind_vcpu_t        bind_vcpu;
+        evtchn_unmask_t           unmask;
     } u;
 } evtchn_op_t;
 
Index: head-2006-02-07/include/asm-xen/xen-public/hvm/hvm_info_table.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2006-02-07/include/asm-xen/xen-public/hvm/hvm_info_table.h	2006-02-07 15:05:06.570779752 +0100
@@ -0,0 +1,24 @@
+/******************************************************************************
+ * hvm/hvm_info_table.h
+ * 
+ * HVM parameter and information table, written into guest memory map.
+ */
+
+#ifndef __XEN_PUBLIC_HVM_HVM_INFO_TABLE_H__
+#define __XEN_PUBLIC_HVM_HVM_INFO_TABLE_H__
+
+#define HVM_INFO_PFN         0x09F
+#define HVM_INFO_OFFSET      0x800
+#define HVM_INFO_PADDR       ((HVM_INFO_PFN << 12) + HVM_INFO_OFFSET)
+
+struct hvm_info_table {
+    char        signature[8]; /* "HVM INFO" */
+    uint32_t    length;
+    uint8_t     checksum;
+    uint8_t     acpi_enabled;
+    uint8_t     apic_enabled;
+    uint8_t     pad[1];
+    uint32_t    nr_vcpus;
+};
+
+#endif /* __XEN_PUBLIC_HVM_HVM_INFO_TABLE_H__ */
Index: head-2006-02-07/include/asm-xen/xen-public/hvm/ioreq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2006-02-07/include/asm-xen/xen-public/hvm/ioreq.h	2006-02-07 15:05:06.571779600 +0100
@@ -0,0 +1,90 @@
+/*
+ * ioreq.h: I/O request definitions for device models
+ * Copyright (c) 2004, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+
+#ifndef _IOREQ_H_
+#define _IOREQ_H_
+
+#define IOREQ_READ      1
+#define IOREQ_WRITE     0
+
+#define STATE_INVALID           0
+#define STATE_IOREQ_READY       1
+#define STATE_IOREQ_INPROCESS   2
+#define STATE_IORESP_READY      3
+#define STATE_IORESP_HOOK       4
+
+#define IOREQ_TYPE_PIO          0 /* pio */
+#define IOREQ_TYPE_COPY         1 /* mmio ops */
+#define IOREQ_TYPE_AND          2
+#define IOREQ_TYPE_OR           3
+#define IOREQ_TYPE_XOR          4
+
+/*
+ * VMExit dispatcher should cooperate with instruction decoder to
+ * prepare this structure and notify service OS and DM by sending
+ * virq
+ */
+typedef struct {
+    uint64_t addr;          /*  physical address            */
+    uint64_t size;          /*  size in bytes               */
+    uint64_t count;         /*  for rep prefixes            */
+    union {
+        uint64_t data;      /*  data                        */
+        void    *pdata;     /*  pointer to data             */
+    } u;
+    uint8_t state:4;
+    uint8_t pdata_valid:1;  /* if 1, use pdata above        */
+    uint8_t dir:1;          /*  1=read, 0=write             */
+    uint8_t df:1;
+    uint8_t type;           /* I/O type                     */
+} ioreq_t;
+
+#define MAX_VECTOR      256
+#define BITS_PER_BYTE   8
+#define INTR_LEN        (MAX_VECTOR/(BITS_PER_BYTE * sizeof(uint64_t)))
+#define INTR_LEN_32     (MAX_VECTOR/(BITS_PER_BYTE * sizeof(uint32_t)))
+
+typedef struct {
+    uint16_t    pic_elcr;
+    uint16_t    pic_irr;
+    uint16_t    pic_last_irr;
+    uint16_t    pic_clear_irr;
+    int         eport; /* Event channel port */
+} global_iodata_t;
+
+typedef struct {
+    ioreq_t     vp_ioreq;
+} vcpu_iodata_t;
+
+typedef struct {
+    global_iodata_t sp_global;
+    vcpu_iodata_t   vcpu_iodata[1];
+} shared_iopage_t;
+
+#endif /* _IOREQ_H_ */
+
+/*
+ * Local variables:
+ * mode: C
+ * c-set-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
Index: head-2006-02-07/include/asm-xen/xen-public/hvm/vmx_assist.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2006-02-07/include/asm-xen/xen-public/hvm/vmx_assist.h	2006-02-07 15:05:06.573779296 +0100
@@ -0,0 +1,97 @@
+/*
+ * vmx_assist.h: Context definitions for the VMXASSIST world switch.
+ *
+ * Leendert van Doorn, leendert@watson.ibm.com
+ * Copyright (c) 2005, International Business Machines Corporation.
+ */
+
+#ifndef _VMX_ASSIST_H_
+#define _VMX_ASSIST_H_
+
+#define VMXASSIST_BASE         0xD0000
+#define VMXASSIST_MAGIC        0x17101966
+#define VMXASSIST_MAGIC_OFFSET (VMXASSIST_BASE+8)
+
+#define VMXASSIST_NEW_CONTEXT (VMXASSIST_BASE + 12)
+#define VMXASSIST_OLD_CONTEXT (VMXASSIST_NEW_CONTEXT + 4)
+
+#ifndef __ASSEMBLY__
+
+union vmcs_arbytes {
+    struct arbyte_fields {
+        unsigned int seg_type : 4,
+            s         : 1,
+            dpl       : 2,
+            p         : 1, 
+            reserved0 : 4,
+            avl       : 1,
+            reserved1 : 1,     
+            default_ops_size: 1,
+            g         : 1,
+            null_bit  : 1, 
+            reserved2 : 15;
+    } fields;
+    unsigned int bytes;
+};
+
+/*
+ * World switch state
+ */
+typedef struct vmx_assist_context {
+    uint32_t  eip;        /* execution pointer */
+    uint32_t  esp;        /* stack pointer */
+    uint32_t  eflags;     /* flags register */
+    uint32_t  cr0;
+    uint32_t  cr3;        /* page table directory */
+    uint32_t  cr4;
+    uint32_t  idtr_limit; /* idt */
+    uint32_t  idtr_base;
+    uint32_t  gdtr_limit; /* gdt */
+    uint32_t  gdtr_base;
+    uint32_t  cs_sel;     /* cs selector */
+    uint32_t  cs_limit;
+    uint32_t  cs_base;
+    union vmcs_arbytes cs_arbytes;
+    uint32_t  ds_sel;     /* ds selector */
+    uint32_t  ds_limit;
+    uint32_t  ds_base;
+    union vmcs_arbytes ds_arbytes;
+    uint32_t  es_sel;     /* es selector */
+    uint32_t  es_limit;
+    uint32_t  es_base;
+    union vmcs_arbytes es_arbytes;
+    uint32_t  ss_sel;     /* ss selector */
+    uint32_t  ss_limit;
+    uint32_t  ss_base;
+    union vmcs_arbytes ss_arbytes;
+    uint32_t  fs_sel;     /* fs selector */
+    uint32_t  fs_limit;
+    uint32_t  fs_base;
+    union vmcs_arbytes fs_arbytes;
+    uint32_t  gs_sel;     /* gs selector */
+    uint32_t  gs_limit;
+    uint32_t  gs_base;
+    union vmcs_arbytes gs_arbytes;
+    uint32_t  tr_sel;     /* task selector */
+    uint32_t  tr_limit;
+    uint32_t  tr_base;
+    union vmcs_arbytes tr_arbytes;
+    uint32_t  ldtr_sel;   /* ldtr selector */
+    uint32_t  ldtr_limit;
+    uint32_t  ldtr_base;
+    union vmcs_arbytes ldtr_arbytes;
+} vmx_assist_context_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _VMX_ASSIST_H_ */
+
+/*
+ * Local variables:
+ * mode: C
+ * c-set-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
Index: head-2006-02-07/include/asm-xen/xen-public/io/blkif.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/io/blkif.h	2006-02-07 15:04:58.926941792 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/io/blkif.h	2006-02-07 15:05:06.574779144 +0100
@@ -10,6 +10,7 @@
 #define __XEN_PUBLIC_IO_BLKIF_H__
 
 #include "ring.h"
+#include "../grant_table.h"
 
 /*
  * Front->back notifications: When enqueuing a new request, sending a
Index: head-2006-02-07/include/asm-xen/xen-public/io/netif.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/io/netif.h	2006-02-07 15:04:58.924942096 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/io/netif.h	2006-02-07 15:05:06.575778992 +0100
@@ -10,6 +10,7 @@
 #define __XEN_PUBLIC_IO_NETIF_H__
 
 #include "ring.h"
+#include "../grant_table.h"
 
 /*
  * Note that there is *never* any need to notify the backend when enqueuing
Index: head-2006-02-07/include/asm-xen/xen-public/io/tpmif.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/io/tpmif.h	2006-02-07 15:04:58.924942096 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/io/tpmif.h	2006-02-07 15:05:06.577778688 +0100
@@ -16,6 +16,8 @@
 #ifndef __XEN_PUBLIC_IO_TPMIF_H__
 #define __XEN_PUBLIC_IO_TPMIF_H__
 
+#include "../grant_table.h"
+
 typedef struct {
     unsigned long addr;   /* Machine address of packet.   */
     grant_ref_t ref;      /* grant table access reference */
Index: head-2006-02-07/include/asm-xen/xen-public/io/xenbus.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/io/xenbus.h	2006-02-07 15:04:58.925941944 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/io/xenbus.h	2006-02-07 15:05:06.578778536 +0100
@@ -4,28 +4,6 @@
  * Xenbus protocol details.
  *
  * Copyright (C) 2005 XenSource Ltd.
- * 
- * This file may be distributed separately from the Linux kernel, or
- * incorporated into other software packages, subject to the following
- * license:
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this source file (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy, modify,
- * merge, publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
  */
 
 #ifndef _XEN_XENBUS_H
Index: head-2006-02-07/include/asm-xen/xen-public/io/xs_wire.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/io/xs_wire.h	2006-02-07 15:04:58.925941944 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/io/xs_wire.h	2006-02-07 15:05:06.579778384 +0100
@@ -2,27 +2,6 @@
  * Details of the "wire" protocol between Xen Store Daemon and client
  * library or guest kernel.
  * Copyright (C) 2005 Rusty Russell IBM Corporation
- *
- * This file may be distributed separately from the Linux kernel, or
- * incorporated into other software packages, subject to the following license:
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this source file (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy, modify,
- * merge, publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
  */
 
 #ifndef _XS_WIRE_H
Index: head-2006-02-07/include/asm-xen/xen-public/nmi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2006-02-07/include/asm-xen/xen-public/nmi.h	2006-02-07 15:05:06.581778080 +0100
@@ -0,0 +1,54 @@
+/******************************************************************************
+ * nmi.h
+ * 
+ * NMI callback registration and reason codes.
+ * 
+ * Copyright (c) 2005, Keir Fraser <keir@xensource.com>
+ */
+
+#ifndef __XEN_PUBLIC_NMI_H__
+#define __XEN_PUBLIC_NMI_H__
+
+/*
+ * NMI reason codes:
+ * Currently these are x86-specific, stored in arch_shared_info.nmi_reason.
+ */
+ /* I/O-check error reported via ISA port 0x61, bit 6. */
+#define _XEN_NMIREASON_io_error     0
+#define XEN_NMIREASON_io_error      (1UL << _XEN_NMIREASON_io_error)
+ /* Parity error reported via ISA port 0x61, bit 7. */
+#define _XEN_NMIREASON_parity_error 1
+#define XEN_NMIREASON_parity_error  (1UL << _XEN_NMIREASON_parity_error)
+ /* Unknown hardware-generated NMI. */
+#define _XEN_NMIREASON_unknown      2
+#define XEN_NMIREASON_unknown       (1UL << _XEN_NMIREASON_unknown)
+
+/*
+ * long nmi_op(unsigned int cmd, void *arg)
+ * NB. All ops return zero on success, else a negative error code.
+ */
+
+/*
+ * Register NMI callback for this (calling) VCPU. Currently this only makes
+ * sense for domain 0, vcpu 0. All other callers will be returned EINVAL.
+ * arg == address of callback function.
+ */
+#define XENNMI_register_callback   0
+
+/*
+ * Deregister NMI callback for this (calling) VCPU.
+ * arg == NULL.
+ */
+#define XENNMI_unregister_callback 1
+
+#endif /* __XEN_PUBLIC_NMI_H__ */
+
+/*
+ * Local variables:
+ * mode: C
+ * c-set-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
Index: head-2006-02-07/include/asm-xen/xen-public/xen.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/xen.h	2006-02-07 15:04:58.929941336 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/xen.h	2006-01-31 16:53:52.000000000 +0100
@@ -53,12 +53,14 @@
 #define __HYPERVISOR_grant_table_op       20
 #define __HYPERVISOR_vm_assist            21
 #define __HYPERVISOR_update_va_mapping_otherdomain 22
-#define __HYPERVISOR_switch_vm86          23 /* x86/32 only */
-#define __HYPERVISOR_switch_to_user       23 /* x86/64 only */
+#define __HYPERVISOR_iret                 23 /* x86 only */
+#define __HYPERVISOR_switch_vm86          23 /* x86/32 only (obsolete name) */
+#define __HYPERVISOR_switch_to_user       23 /* x86/64 only (obsolete name) */
 #define __HYPERVISOR_vcpu_op              24
 #define __HYPERVISOR_set_segment_base     25 /* x86/64 only */
 #define __HYPERVISOR_mmuext_op            26
 #define __HYPERVISOR_acm_op               27
+#define __HYPERVISOR_nmi_op               28
 
 /* 
  * VIRTUAL INTERRUPTS
@@ -67,12 +69,10 @@
  */
 #define VIRQ_TIMER      0  /* Timebase update, and/or requested timeout.  */
 #define VIRQ_DEBUG      1  /* Request guest to dump debug info.           */
-#define VIRQ_CONSOLE    2  /* (DOM0) bytes received on emergency console. */
+#define VIRQ_CONSOLE    2  /* (DOM0) Bytes received on emergency console. */
 #define VIRQ_DOM_EXC    3  /* (DOM0) Exceptional event for some domain.   */
-#define VIRQ_PARITY_ERR 4  /* (DOM0) NMI parity error.                    */
-#define VIRQ_IO_ERR     5  /* (DOM0) NMI I/O error.                       */
 #define VIRQ_DEBUGGER   6  /* (DOM0) A domain has paused for debugging.   */
-#define NR_VIRQS        7
+#define NR_VIRQS        8
 
 /*
  * MMU-UPDATE REQUESTS
@@ -144,10 +144,6 @@
  * cmd: MMUEXT_SET_LDT
  * linear_addr: Linear address of LDT base (NB. must be page-aligned).
  * nr_ents: Number of entries in LDT.
- * 
- * cmd: MMUEXT_REASSIGN_PAGE
- * mfn: Machine frame number to be reassigned to the FD.
- *      (NB. page must currently belong to the calling domain).
  */
 #define MMUEXT_PIN_L1_TABLE      0
 #define MMUEXT_PIN_L2_TABLE      1
@@ -163,14 +159,13 @@
 #define MMUEXT_INVLPG_ALL       11
 #define MMUEXT_FLUSH_CACHE      12
 #define MMUEXT_SET_LDT          13
-#define MMUEXT_REASSIGN_PAGE    14
 #define MMUEXT_NEW_USER_BASEPTR 15
 
 #ifndef __ASSEMBLY__
 struct mmuext_op {
     unsigned int cmd;
     union {
-        /* [UN]PIN_TABLE, NEW_BASEPTR, NEW_USER_BASEPTR, REASSIGN_PAGE */
+        /* [UN]PIN_TABLE, NEW_BASEPTR, NEW_USER_BASEPTR */
         unsigned long mfn;
         /* INVLPG_LOCAL, INVLPG_ALL, SET_LDT */
         unsigned long linear_addr;
@@ -244,8 +239,7 @@ typedef uint16_t domid_t;
  * Send an array of these to HYPERVISOR_mmu_update().
  * NB. The fields are natural pointer/address size for this architecture.
  */
-typedef struct
-{
+typedef struct mmu_update {
     uint64_t ptr;       /* Machine address of PTE. */
     uint64_t val;       /* New contents of PTE.    */
 } mmu_update_t;
@@ -254,8 +248,7 @@ typedef struct
  * Send an array of these to HYPERVISOR_multicall().
  * NB. The fields are natural register size for this architecture.
  */
-typedef struct
-{
+typedef struct multicall_entry {
     unsigned long op, result;
     unsigned long args[6];
 } multicall_entry_t;
@@ -430,6 +423,15 @@ typedef uint64_t cpumap_t;
 
 typedef uint8_t xen_domain_handle_t[16];
 
+/* Turn a plain number into a C unsigned long constant. */
+#define __mk_unsigned_long(x) x ## UL
+#define mk_unsigned_long(x) __mk_unsigned_long(x)
+
+#else /* __ASSEMBLY__ */
+
+/* In assembly code we cannot use C numeric constant suffixes. */
+#define mk_unsigned_long(x) x
+
 #endif /* !__ASSEMBLY__ */
 
 #endif /* __XEN_PUBLIC_XEN_H__ */
Index: head-2006-02-07/include/asm-xen/xen-public/memory.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/memory.h	2006-02-07 12:06:47.453292840 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/memory.h	2006-01-31 16:53:52.000000000 +0100
@@ -16,11 +16,18 @@
  */
 #define XENMEM_increase_reservation 0
 #define XENMEM_decrease_reservation 1
+#define XENMEM_populate_physmap     6
 typedef struct xen_memory_reservation {
 
     /*
-     * MFN bases of extents to free (XENMEM_decrease_reservation).
-     * MFN bases of extents that were allocated (XENMEM_increase_reservation).
+     * XENMEM_increase_reservation:
+     *   OUT: MFN bases of extents that were allocated
+     * XENMEM_decrease_reservation:
+     *   IN:  MFN bases of extents to free
+     * XENMEM_populate_physmap:
+     *   IN:  PFN bases of extents to populate with memory
+     *   OUT: MFN bases of extents that were allocated
+     *   (NB. This command also updates the mach_to_phys translation table)
      */
     unsigned long *extent_start;
 
@@ -29,11 +36,10 @@ typedef struct xen_memory_reservation {
     unsigned int   extent_order;
 
     /*
-     * XENMEM_increase_reservation: maximum # bits addressable by the user
-     * of the allocated region (e.g., I/O devices often have a 32-bit
-     * limitation even in 64-bit systems). If zero then the user has no
-     * addressing restriction.
-     * XENMEM_decrease_reservation: unused.
+     * Mmaximum # bits addressable by the user of the allocated region (e.g., 
+     * I/O devices often have a 32-bit limitation even in 64-bit systems). If 
+     * zero then the user has no addressing restriction.
+     * This field is not used by XENMEM_decrease_reservation.
      */
     unsigned int   address_bits;
 
@@ -88,6 +94,26 @@ typedef struct xen_machphys_mfn_list {
     unsigned int nr_extents;
 } xen_machphys_mfn_list_t;
 
+/*
+ * Returns the base and size of the specified reserved 'RAM hole' in the
+ * specified guest's pseudophysical address space.
+ * arg == addr of xen_reserved_phys_area_t.
+ */
+#define XENMEM_reserved_phys_area   7
+typedef struct xen_reserved_phys_area {
+    /* Which request to report about? */
+    domid_t domid;
+
+    /*
+     * Which reserved area to report? Out-of-range request reports
+     * -ESRCH. Currently no architecture will have more than one reserved area.
+     */
+    unsigned int idx;
+
+    /* Base and size of the specified reserved area. */
+    unsigned long first_pfn, nr_pfns;
+} xen_reserved_phys_area_t;
+
 #endif /* __XEN_PUBLIC_MEMORY_H__ */
 
 /*
Index: head-2006-02-07/include/asm-xen/xen-public/version.h
===================================================================
--- head-2006-02-07.orig/include/asm-xen/xen-public/version.h	2006-02-07 12:06:47.459291928 +0100
+++ head-2006-02-07/include/asm-xen/xen-public/version.h	2006-01-31 16:53:52.000000000 +0100
@@ -39,6 +39,17 @@ typedef struct xen_platform_parameters {
     unsigned long virt_start;
 } xen_platform_parameters_t;
 
+#define XENVER_get_features 6
+typedef struct xen_feature_info {
+    unsigned int submap_idx;    /* IN: which 32-bit submap to return */
+    uint32_t     submap;        /* OUT: 32-bit submap */
+} xen_feature_info_t;
+
+#define XENFEAT_writable_page_tables       0
+#define XENFEAT_writable_descriptor_tables 1
+
+#define XENFEAT_NR_SUBMAPS 1
+
 #endif /* __XEN_PUBLIC_VERSION_H__ */
 
 /*
