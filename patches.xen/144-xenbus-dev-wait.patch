# HG changeset 144+146+150 patch
# User kfraser@localhost.localdomain
# Date 1185266340 -3600
# Node ID d88e59a7334ae584900a9f7221d494bcd9ef2a63
# Parent  c68699484a654681a2912e70411286f13119c01f
Subject: xenbus: Wait for 30s for devices to connect (previously 10s).
Give a visual update to the user on the console every 5s during this
period.
Signed-off-by: Keir Fraser <keir@xensource.com>

Subject: xenbus: Improvements to wait_for_devices().
 1. When printing a warning about a timed-out device, print the
 current state of both ends of the device connection (i.e., backend as
 well as frontend).
 2. A device is 'not yet connected' only when the local state is *less
 than* XenbusStateConnected. If the state is Closing or Closed
 (usually because of an explicit failure when trying to make the
 connection) then we should not wait for the connection to occur -- it
 will never happen!

Signed-off-by: Keir Fraser <keir@xensource.com>

Subject: Wait for up to 5 minutes for devices to connect.

Heavy load in domain 0 can cause very long delays setting up the
backend.

Signed-off-by: Ian Campbell <ian.campbell@xensource.com>

Acked-by: jbeulich@novell.com

Index: head-2007-08-07/drivers/xen/xenbus/xenbus_probe.c
===================================================================
--- head-2007-08-07.orig/drivers/xen/xenbus/xenbus_probe.c	2007-08-07 09:59:32.000000000 +0200
+++ head-2007-08-07/drivers/xen/xenbus/xenbus_probe.c	2007-08-07 10:00:01.000000000 +0200
@@ -1031,7 +1031,7 @@ static int is_disconnected_device(struct
 		return 0;
 
 	xendrv = to_xenbus_driver(dev->driver);
-	return (xendev->state != XenbusStateConnected ||
+	return (xendev->state < XenbusStateConnected ||
 		(xendrv->is_ready && !xendrv->is_ready(xendev)));
 }
 
@@ -1056,10 +1056,13 @@ static int print_device_status(struct de
 		/* Information only: is this too noisy? */
 		printk(KERN_INFO "XENBUS: Device with no driver: %s\n",
 		       xendev->nodename);
-	} else if (xendev->state != XenbusStateConnected) {
+	} else if (xendev->state < XenbusStateConnected) {
+		enum xenbus_state rstate = XenbusStateUnknown;
+		if (xendev->otherend)
+			rstate = xenbus_read_driver_state(xendev->otherend);
 		printk(KERN_WARNING "XENBUS: Timeout connecting "
-		       "to device: %s (state %d)\n",
-		       xendev->nodename, xendev->state);
+		       "to device: %s (local state %d, remote state %d)\n",
+		       xendev->nodename, xendev->state, rstate);
 	}
 
 	return 0;
@@ -1069,7 +1072,7 @@ static int print_device_status(struct de
 static int ready_to_wait_for_devices;
 
 /*
- * On a 10 second timeout, wait for all devices currently configured.  We need
+ * On a 5-minute timeout, wait for all devices currently configured.  We need
  * to do this to guarantee that the filesystems and / or network devices
  * needed for boot are available, before we can allow the boot to proceed.
  *
@@ -1084,18 +1087,30 @@ static int ready_to_wait_for_devices;
  */
 static void wait_for_devices(struct xenbus_driver *xendrv)
 {
-	unsigned long timeout = jiffies + 10*HZ;
+	unsigned long start = jiffies;
 	struct device_driver *drv = xendrv ? &xendrv->driver : NULL;
+	unsigned int seconds_waited = 0;
 
 	if (!ready_to_wait_for_devices || !is_running_on_xen())
 		return;
 
 	while (exists_disconnected_device(drv)) {
-		if (time_after(jiffies, timeout))
-			break;
+		if (time_after(jiffies, start + (seconds_waited+5)*HZ)) {
+			if (!seconds_waited)
+				printk(KERN_WARNING "XENBUS: Waiting for "
+				       "devices to initialise: ");
+			seconds_waited += 5;
+			printk("%us...", 300 - seconds_waited);
+			if (seconds_waited == 300)
+				break;
+		}
+
 		schedule_timeout_interruptible(HZ/10);
 	}
 
+	if (seconds_waited)
+		printk("\n");
+
 	bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,
 			 print_device_status);
 }
