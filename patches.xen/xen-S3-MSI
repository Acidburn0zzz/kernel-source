From: jbeulich@novell.com
Subject: fix Dom0 resume from S3 when MSI is in use
Patch-mainline: obsolete
References: bnc#435596

--- head-2009-01-06.orig/drivers/pci/msi-xen.c	2009-01-09 11:10:27.000000000 +0100
+++ head-2009-01-06/drivers/pci/msi-xen.c	2009-01-09 11:12:21.000000000 +0100
@@ -320,62 +320,24 @@ static void pci_intx_for_msi(struct pci_
 		pci_intx(dev, enable);
 }
 
-static void __pci_restore_msi_state(struct pci_dev *dev)
-{
-	int pirq;
-
-	if (!dev->msi_enabled)
-		return;
-
-	pci_intx_for_msi(dev, 0);
-	msi_set_enable(dev, 0);
-
-	pirq = msi_map_pirq_to_vector(dev, dev->irq, 0, 0);
-	if (pirq < 0)
-		return;
-}
-
-static void __pci_restore_msix_state(struct pci_dev *dev)
+void pci_restore_msi_state(struct pci_dev *dev)
 {
-	int pos;
-	unsigned long flags;
-	u64 table_base;
-	struct msi_dev_list *msi_dev_entry;
-	struct msi_pirq_entry *pirq_entry, *tmp;
+	int rc;
+	struct physdev_restore_msi restore;
 
-	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
-	if (pos <= 0)
-		return;
-
-	if (!dev->msix_enabled)
+	if (!dev->msi_enabled && !dev->msix_enabled)
 		return;
 
 	pci_intx_for_msi(dev, 0);
-	msix_set_enable(dev, 0);
-
-	msi_dev_entry = get_msi_dev_pirq_list(dev);
-	table_base = find_table_base(dev, pos);
-	if (!table_base)
-		return;
-
-	spin_lock_irqsave(&msi_dev_entry->pirq_list_lock, flags);
-	list_for_each_entry_safe(pirq_entry, tmp,
-				 &msi_dev_entry->pirq_list_head, list) {
-		int rc = msi_map_pirq_to_vector(dev, pirq_entry->pirq,
-						pirq_entry->entry_nr, table_base);
-		if (rc < 0)
-			printk(KERN_WARNING
-			       "%s: re-mapping irq #%d (pirq%d) failed: %d\n",
-			       pci_name(dev), pirq_entry->entry_nr,
-			       pirq_entry->pirq, rc);
-	}
-	spin_unlock_irqrestore(&msi_dev_entry->pirq_list_lock, flags);
-}
-
-void pci_restore_msi_state(struct pci_dev *dev)
-{
-	__pci_restore_msi_state(dev);
-	__pci_restore_msix_state(dev);
+	if (dev->msi_enabled)
+		msi_set_enable(dev, 0);
+	if (dev->msix_enabled)
+		msix_set_enable(dev, 0);
+
+	restore.bus = dev->bus->number;
+	restore.devfn = dev->devfn;
+	rc = HYPERVISOR_physdev_op(PHYSDEVOP_restore_msi, &restore);
+	WARN(rc && rc != -ENOSYS, "restore_msi -> %d\n", rc);
 }
 EXPORT_SYMBOL_GPL(pci_restore_msi_state);
 
--- head-2009-01-06.orig/include/xen/interface/physdev.h	2009-01-09 11:10:12.000000000 +0100
+++ head-2009-01-06/include/xen/interface/physdev.h	2009-01-05 15:11:37.000000000 +0100
@@ -183,6 +183,15 @@ struct physdev_manage_pci {
 typedef struct physdev_manage_pci physdev_manage_pci_t;
 DEFINE_XEN_GUEST_HANDLE(physdev_manage_pci_t);
 
+#define PHYSDEVOP_restore_msi            19
+struct physdev_restore_msi {
+    /* IN */
+    uint8_t bus;
+    uint8_t devfn;
+};
+typedef struct physdev_restore_msi physdev_restore_msi_t;
+DEFINE_XEN_GUEST_HANDLE(physdev_restore_msi_t);
+
 /*
  * Argument to physdev_op_compat() hypercall. Superceded by new physdev_op()
  * hypercall since 0x00030202.
