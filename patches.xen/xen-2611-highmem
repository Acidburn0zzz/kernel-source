From: Kurt Garloff <garloff@suse.de>
Subject: Fix highmem_start_page references.

.

Index: linux-2.6.11/arch/xen/i386/mm/highmem.c
===================================================================
--- linux-2.6.11.orig/arch/xen/i386/mm/highmem.c
+++ linux-2.6.11/arch/xen/i386/mm/highmem.c
@@ -54,9 +54,9 @@ void *kmap_atomic_pte(struct page *page,
 	unsigned long vaddr;
 
 	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
 	inc_preempt_count();
-	if (page < highmem_start_page)
+	if (!PageHighMem(page))
 		return page_address(page);
 
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
Index: linux-2.6.11/arch/xen/i386/mm/pgtable.c
===================================================================
--- linux-2.6.11.orig/arch/xen/i386/mm/pgtable.c
+++ linux-2.6.11/arch/xen/i386/mm/pgtable.c
@@ -231,9 +231,9 @@ struct page *pte_alloc_one(struct mm_str
 
 	pte = alloc_pages(GFP_KERNEL|__GFP_HIGHMEM|__GFP_REPEAT|__GFP_ZERO, 0);
 	if (pte == NULL)
 		return pte;
-	if (pte >= highmem_start_page)
+	if (PageHighMem(pte))
 		return pte;
 	/* not a highmem page -- free page and grab one from the cache */
 	__free_page(pte);
 #endif
@@ -246,9 +246,9 @@ struct page *pte_alloc_one(struct mm_str
 void pte_free(struct page *pte)
 {
 	set_page_count(pte, 1);
 #ifdef CONFIG_HIGHPTE
-	if (pte < highmem_start_page)
+	if (!PageHighMem(pte))
 #endif
 		kmem_cache_free(pte_cache,
 				phys_to_virt(page_to_pseudophys(pte)));
 #ifdef CONFIG_HIGHPTE
