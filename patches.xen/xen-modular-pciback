Subject: Allow pciback to be built as a module
From: jbeulich@novell.com

Index: head-2006-03-06/drivers/xen/Kconfig
===================================================================
--- head-2006-03-06.orig/drivers/xen/Kconfig	2006-03-06 13:18:54.000000000 +0100
+++ head-2006-03-06/drivers/xen/Kconfig	2006-03-09 10:59:09.386287288 +0100
@@ -30,12 +30,14 @@ config XEN_UNPRIVILEGED_GUEST
 	default !XEN_PRIVILEGED_GUEST
 
 config XEN_PCIDEV_BACKEND
-	bool "PCI device backend driver"
-	select PCI
-	default y if XEN_PRIVILEGED_GUEST
+	tristate "PCI device backend driver"
+	depends PCI
+	default XEN_PRIVILEGED_GUEST
 	help
 	  The PCI device backend driver allows the kernel to export arbitrary
-	  PCI devices to other guests.
+	  PCI devices to other guests. If you select this to be a module, you
+	  will need to make sure no other driver has bound to the device(s)
+	  you want to make visible to other guests.
 
 choice
 	prompt "PCI Backend Mode"
Index: head-2006-03-06/drivers/xen/pciback/Makefile
===================================================================
--- head-2006-03-06.orig/drivers/xen/pciback/Makefile	2006-03-06 11:15:49.000000000 +0100
+++ head-2006-03-06/drivers/xen/pciback/Makefile	2006-03-07 11:21:26.000000000 +0100
@@ -1,9 +1,9 @@
-obj-y += pciback.o
+obj-$(CONFIG_XEN_PCIDEV_BACKEND) += pciback.o
 
 pciback-y := pci_stub.o pciback_ops.o xenbus.o
 pciback-y += conf_space.o conf_space_header.o
-pciback-${CONFIG_XEN_PCIDEV_BACKEND_VPCI} += vpci.o
-pciback-${CONFIG_XEN_PCIDEV_BACKEND_PASS} += passthrough.o
+pciback-$(CONFIG_XEN_PCIDEV_BACKEND_VPCI) += vpci.o
+pciback-$(CONFIG_XEN_PCIDEV_BACKEND_PASS) += passthrough.o
 
 ifeq ($(CONFIG_XEN_PCIDEV_BE_DEBUG),y)
 EXTRA_CFLAGS += -DDEBUG
Index: head-2006-03-06/drivers/xen/pciback/conf_space_header.c
===================================================================
--- head-2006-03-06.orig/drivers/xen/pciback/conf_space_header.c	2006-03-06 11:15:49.000000000 +0100
+++ head-2006-03-06/drivers/xen/pciback/conf_space_header.c	2006-03-07 11:57:00.000000000 +0100
@@ -25,12 +25,12 @@ static int command_write(struct pci_dev 
 			printk(KERN_DEBUG "pciback: %s: enable\n",
 			       pci_name(dev));
 		dev->is_enabled = 1;
-		pcibios_enable_device(dev, (1 << PCI_NUM_RESOURCES) - 1);
+		pci_enable_device(dev);
 	} else if (dev->is_enabled && !is_enable_cmd(value)) {
 		if (unlikely(verbose_request))
 			printk(KERN_DEBUG "pciback: %s: disable\n",
 			       pci_name(dev));
-		pciback_disable_device(dev);
+		pci_disable_device(dev);
 	}
 
 	if (!dev->is_busmaster && is_master_cmd(value)) {
@@ -38,7 +38,7 @@ static int command_write(struct pci_dev 
 			printk(KERN_DEBUG "pciback: %s: set bus master\n",
 			       pci_name(dev));
 		dev->is_busmaster = 1;
-		pcibios_set_master(dev);
+		pci_set_master(dev);
 	}
 
 	if (value & PCI_COMMAND_INVALIDATE) {
Index: head-2006-03-06/drivers/xen/pciback/pci_stub.c
===================================================================
--- head-2006-03-06.orig/drivers/xen/pciback/pci_stub.c	2006-03-07 11:34:12.000000000 +0100
+++ head-2006-03-06/drivers/xen/pciback/pci_stub.c	2006-03-09 11:01:27.913227992 +0100
@@ -205,10 +205,14 @@ static int __init pcistub_init_devices_l
 
 	spin_unlock(&pci_stub_devices_lock);
 
+	pciback_xenbus_register();
+
 	return 0;
 }
 
+#ifndef MODULE
 device_initcall(pcistub_init_devices_late);
+#endif
 
 static int __devinit pcistub_seize(struct pci_dev *dev)
 {
@@ -367,6 +371,8 @@ static int __init pcistub_init(void)
 	return -EINVAL;
 }
 
+#ifndef MODULE
+
 /*
  * fs_initcall happens before device_initcall
  * so pciback *should* get called first (b/c we 
@@ -375,3 +381,32 @@ static int __init pcistub_init(void)
  * driver to register)
  */
 fs_initcall(pcistub_init);
+
+#else
+
+static __init int pciback_init(void)
+{
+	int err;
+
+	err = pcistub_init();
+	if (err < 0)
+		return err;
+	if (list_empty(&pci_stub_device_ids))
+		return -ENODEV;
+	pcistub_init_devices_late();
+
+	__unsafe(THIS_MODULE);
+
+	return 0;
+}
+
+static void pciback_cleanup(void)
+{
+	BUG();
+}
+
+module_init(pciback_init);
+module_exit(pciback_cleanup);
+
+MODULE_LICENSE("Dual BSD/GPL");
+#endif
Index: head-2006-03-06/drivers/xen/pciback/pciback.h
===================================================================
--- head-2006-03-06.orig/drivers/xen/pciback/pciback.h	2006-03-06 11:15:49.000000000 +0100
+++ head-2006-03-06/drivers/xen/pciback/pciback.h	2006-03-09 11:00:23.532015424 +0100
@@ -43,7 +43,6 @@ struct pci_dev *pcistub_get_pci_dev(stru
 void pcistub_put_pci_dev(struct pci_dev *dev);
 
 /* Ensure a device is turned off or reset */
-void pciback_disable_device(struct pci_dev *dev);
 void pciback_reset_device(struct pci_dev *pdev);
 
 /* Access a virtual configuration space for a PCI device */
@@ -69,5 +68,7 @@ void pciback_release_devices(struct pcib
 /* Handles events from front-end */
 irqreturn_t pciback_handle_event(int irq, void *dev_id, struct pt_regs *regs);
 
+int pciback_xenbus_register(void);
+
 extern int verbose_request;
 #endif
Index: head-2006-03-06/drivers/xen/pciback/pciback_ops.c
===================================================================
--- head-2006-03-06.orig/drivers/xen/pciback/pciback_ops.c	2006-03-06 11:15:49.000000000 +0100
+++ head-2006-03-06/drivers/xen/pciback/pciback_ops.c	2006-03-07 11:56:43.000000000 +0100
@@ -10,17 +10,6 @@
 int verbose_request = 0;
 module_param(verbose_request, int, 0644);
 
-/* For those architectures without a pcibios_disable_device */
-void __attribute__ ((weak)) pcibios_disable_device(struct pci_dev *dev) { }
-
-void pciback_disable_device(struct pci_dev *dev)
-{
-	if (dev->is_enabled) {
-		dev->is_enabled = 0;
-		pcibios_disable_device(dev);
-	}
-}
-
 /* Ensure a device is "turned off" and ready to be exported.
  * This also sets up the device's private data to keep track of what should
  * be in the base address registers (BARs) so that we can keep the
@@ -32,7 +21,7 @@ void pciback_reset_device(struct pci_dev
 
 	/* Disable devices (but not bridges) */
 	if (dev->hdr_type == PCI_HEADER_TYPE_NORMAL) {
-		pciback_disable_device(dev);
+		pci_disable_device(dev);
 
 		pci_write_config_word(dev, PCI_COMMAND, 0);
 
Index: head-2006-03-06/drivers/xen/pciback/xenbus.c
===================================================================
--- head-2006-03-06.orig/drivers/xen/pciback/xenbus.c	2006-03-06 11:15:49.000000000 +0100
+++ head-2006-03-06/drivers/xen/pciback/xenbus.c	2006-03-09 11:00:46.108583264 +0100
@@ -430,10 +430,7 @@ static struct xenbus_driver xenbus_pciba
 	.otherend_changed 	= pciback_frontend_changed,
 };
 
-static __init int pciback_xenbus_register(void)
+int __init pciback_xenbus_register(void)
 {
 	return xenbus_register_backend(&xenbus_pciback_driver);
 }
-
-/* Must only initialize our xenbus driver after the pcistub driver */
-device_initcall(pciback_xenbus_register);
