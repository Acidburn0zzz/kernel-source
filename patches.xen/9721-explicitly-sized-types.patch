# HG changeset 9721 patch
From: kaf24@firebug.cl.cam.ac.uk
# Node ID 89ba6c7b4804bb30ecd95a478a4be6e6decec2e7
# Parent  ecae09fda29a9fc08059984b12259e1811a1444b
Subject: Use explicitly-sized types in the dom0_ops and privcmd structures.
As discussed previously, the these operations are not performance-sensitive, so
the additional cache footprint shouldn't be an issue.

Signed-off-by: Hollis Blanchard <hollisb@us.ibm.com>

Backported to 3.0-testing as this is a dom0 interface breaker (also breaks
old libxenctrl and any other app/lib that executes hypercalls -- will need
recompiling).
xen-unstable changeset:   10277:c191c649cdb387e7ec573d218c9581c639c87700
xen-unstable date:        Tue Jun  6 10:25:59 2006 +0100

Acked-by: Jan Beulich <jbeulich@novell.com>

Index: head-2006-06-07/drivers/xen/privcmd/privcmd.c
===================================================================
--- head-2006-06-07.orig/drivers/xen/privcmd/privcmd.c	2006-06-07 09:31:02.000000000 +0200
+++ head-2006-06-07/drivers/xen/privcmd/privcmd.c	2006-06-07 09:33:06.000000000 +0200
@@ -61,11 +61,11 @@ static int privcmd_ioctl(struct inode *i
 		__asm__ __volatile__ (
 			"pushl %%ebx; pushl %%ecx; pushl %%edx; "
 			"pushl %%esi; pushl %%edi; "
-			"movl  4(%%eax),%%ebx ;"
-			"movl  8(%%eax),%%ecx ;"
-			"movl 12(%%eax),%%edx ;"
-			"movl 16(%%eax),%%esi ;"
-			"movl 20(%%eax),%%edi ;"
+			"movl  8(%%eax),%%ebx ;"
+			"movl 16(%%eax),%%ecx ;"
+			"movl 24(%%eax),%%edx ;"
+			"movl 32(%%eax),%%esi ;"
+			"movl 40(%%eax),%%edi ;"
 			"movl   (%%eax),%%eax ;"
 			"shll $5,%%eax ;"
 			"addl $hypercall_page,%%eax ;"
@@ -219,7 +219,7 @@ static int privcmd_ioctl(struct inode *i
 	batch_err:
 		printk("batch_err ret=%d vma=%p addr=%lx "
 		       "num=%d arr=%p %lx-%lx\n", 
-		       ret, vma, m.addr, m.num, m.arr,
+		       ret, vma, (unsigned long)m.addr, m.num, m.arr,
 		       vma ? vma->vm_start : 0, vma ? vma->vm_end : 0);
 		break;
 	}
Index: head-2006-06-07/include/xen/public/privcmd.h
===================================================================
--- head-2006-06-07.orig/include/xen/public/privcmd.h	2006-06-07 09:31:01.000000000 +0200
+++ head-2006-06-07/include/xen/public/privcmd.h	2006-06-07 09:33:06.000000000 +0200
@@ -33,20 +33,22 @@
 #ifndef __LINUX_PUBLIC_PRIVCMD_H__
 #define __LINUX_PUBLIC_PRIVCMD_H__
 
+#include <linux/types.h>
+
 #ifndef __user
 #define __user
 #endif
 
 typedef struct privcmd_hypercall
 {
-	unsigned long op;
-	unsigned long arg[5];
+	__u64 op;
+	__u64 arg[5];
 } privcmd_hypercall_t;
 
 typedef struct privcmd_mmap_entry {
-	unsigned long va;
-	unsigned long mfn;
-	unsigned long npages;
+	__u64 va;
+	__u64 mfn;
+	__u64 npages;
 } privcmd_mmap_entry_t; 
 
 typedef struct privcmd_mmap {
@@ -58,7 +60,7 @@ typedef struct privcmd_mmap {
 typedef struct privcmd_mmapbatch {
 	int num;     /* number of pages to populate */
 	domid_t dom; /* target domain */
-	unsigned long addr;  /* virtual address */
+	__u64 addr;  /* virtual address */
 	unsigned long __user *arr; /* array of mfns - top nibble set on err */
 } privcmd_mmapbatch_t; 
 
Index: head-2006-06-07/include/xen/interface/dom0_ops.h
===================================================================
--- head-2006-06-07.orig/include/xen/interface/dom0_ops.h	2006-06-07 09:17:35.000000000 +0200
+++ head-2006-06-07/include/xen/interface/dom0_ops.h	2006-06-07 09:33:06.000000000 +0200
@@ -19,7 +19,7 @@
  * This makes sure that old versions of dom0 tools will stop working in a
  * well-defined way (rather than crashing the machine, for instance).
  */
-#define DOM0_INTERFACE_VERSION   0x03000000
+#define DOM0_INTERFACE_VERSION   0x03000001
 
 /************************************************************************/
 
@@ -27,10 +27,10 @@
 typedef struct dom0_getmemlist {
     /* IN variables. */
     domid_t       domain;
-    unsigned long max_pfns;
+    uint64_t max_pfns;
     GUEST_HANDLE(ulong) buffer;
     /* OUT variables. */
-    unsigned long num_pfns;
+    uint64_t num_pfns;
 } dom0_getmemlist_t;
 DEFINE_GUEST_HANDLE(dom0_getmemlist_t);
 
@@ -91,8 +91,8 @@ typedef struct dom0_getdomaininfo {
 #define DOMFLAGS_SHUTDOWNMASK 255 /* DOMFLAGS_SHUTDOWN guest-supplied code.  */
 #define DOMFLAGS_SHUTDOWNSHIFT 16
     uint32_t flags;
-    unsigned long tot_pages;
-    unsigned long max_pages;
+    uint64_t tot_pages;
+    uint64_t max_pages;
     unsigned long shared_info_frame;       /* MFN of shared_info struct */
     uint64_t cpu_time;
     uint32_t nr_online_vcpus;     /* Number of VCPUs currently online. */
@@ -216,8 +216,8 @@ typedef struct dom0_physinfo {
     uint32_t sockets_per_node;
     uint32_t nr_nodes;
     uint32_t cpu_khz;
-    unsigned long total_pages;
-    unsigned long free_pages;
+    uint64_t total_pages;
+    uint64_t free_pages;
     uint32_t hw_cap[8];
 } dom0_physinfo_t;
 DEFINE_GUEST_HANDLE(dom0_physinfo_t);
@@ -260,7 +260,7 @@ typedef struct dom0_shadow_control {
     uint32_t       op;
     GUEST_HANDLE(ulong) dirty_bitmap;
     /* IN/OUT variables. */
-    unsigned long  pages;        /* size of buffer, updated with actual size */
+    uint64_t       pages;        /* size of buffer, updated with actual size */
     /* OUT variables. */
     dom0_shadow_control_stats_t stats;
 } dom0_shadow_control_t;
@@ -269,16 +269,16 @@ DEFINE_GUEST_HANDLE(dom0_shadow_control_
 #define DOM0_SETDOMAINMAXMEM   28
 typedef struct dom0_setdomainmaxmem {
     /* IN variables. */
-    domid_t       domain;
-    unsigned long max_memkb;
+    domid_t  domain;
+    uint64_t max_memkb;
 } dom0_setdomainmaxmem_t;
 DEFINE_GUEST_HANDLE(dom0_setdomainmaxmem_t);
 
 #define DOM0_GETPAGEFRAMEINFO2 29   /* batched interface */
 typedef struct dom0_getpageframeinfo2 {
     /* IN variables. */
-    domid_t        domain;
-    unsigned long  num;
+    domid_t  domain;
+    uint64_t num;
     /* IN/OUT variables. */
     GUEST_HANDLE(ulong) array;
 } dom0_getpageframeinfo2_t;
@@ -295,11 +295,11 @@ DEFINE_GUEST_HANDLE(dom0_getpageframeinf
 typedef struct dom0_add_memtype {
     /* IN variables. */
     unsigned long mfn;
-    unsigned long nr_mfns;
-    uint32_t      type;
+    uint64_t nr_mfns;
+    uint32_t type;
     /* OUT variables. */
-    uint32_t      handle;
-    uint32_t      reg;
+    uint32_t handle;
+    uint32_t reg;
 } dom0_add_memtype_t;
 DEFINE_GUEST_HANDLE(dom0_add_memtype_t);
 
@@ -325,7 +325,7 @@ typedef struct dom0_read_memtype {
     uint32_t reg;
     /* OUT variables. */
     unsigned long mfn;
-    unsigned long nr_mfns;
+    uint64_t nr_mfns;
     uint32_t type;
 } dom0_read_memtype_t;
 DEFINE_GUEST_HANDLE(dom0_read_memtype_t);
@@ -462,7 +462,7 @@ DEFINE_GUEST_HANDLE(dom0_irq_permission_
 typedef struct dom0_iomem_permission {
     domid_t  domain;          /* domain to be affected */
     unsigned long first_mfn;  /* first page (physical page number) in range */
-    unsigned long nr_mfns;    /* number of pages in range (>0) */
+    uint64_t nr_mfns;         /* number of pages in range (>0) */
     uint8_t allow_access;     /* allow (!0) or deny (0) access to range? */
 } dom0_iomem_permission_t;
 DEFINE_GUEST_HANDLE(dom0_iomem_permission_t);
