Subject: Update Xen-specific files for 2.6.16-rc5
From: jbeulich@novell.com

Index: head-2006-03-02/arch/i386/kernel/cpu/common-xen.c
===================================================================
--- head-2006-03-02.orig/arch/i386/kernel/cpu/common-xen.c	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/arch/i386/kernel/cpu/common-xen.c	2006-03-02 11:04:48.000000000 +0100
@@ -4,6 +4,7 @@
 #include <linux/smp.h>
 #include <linux/module.h>
 #include <linux/percpu.h>
+#include <linux/bootmem.h>
 #include <asm/semaphore.h>
 #include <asm/processor.h>
 #include <asm/i387.h>
@@ -19,6 +20,9 @@
 
 #include "cpu.h"
 
+DEFINE_PER_CPU(struct Xgt_desc_struct, cpu_gdt_descr);
+EXPORT_PER_CPU_SYMBOL(cpu_gdt_descr);
+
 #ifndef CONFIG_XEN
 DEFINE_PER_CPU(unsigned char, cpu_16bit_stack[CPU_16BIT_STACK_SIZE]);
 EXPORT_PER_CPU_SYMBOL(cpu_16bit_stack);
@@ -597,6 +601,8 @@ void __cpuinit cpu_init(void)
 	int cpu = smp_processor_id();
 	struct tss_struct * t = &per_cpu(init_tss, cpu);
 	struct thread_struct *thread = &current->thread;
+	struct desc_struct *gdt;
+	struct Xgt_desc_struct *cpu_gdt_descr = &per_cpu(cpu_gdt_descr, cpu);
 
 	if (cpu_test_and_set(cpu, cpu_initialized)) {
 		printk(KERN_WARNING "CPU#%d already initialized!\n", cpu);
@@ -613,7 +619,54 @@ void __cpuinit cpu_init(void)
 		set_in_cr4(X86_CR4_TSD);
 	}
 
-	cpu_gdt_init(&cpu_gdt_descr[cpu]);
+#ifndef CONFIG_XEN
+	/*
+	 * This is a horrible hack to allocate the GDT.  The problem
+	 * is that cpu_init() is called really early for the boot CPU
+	 * (and hence needs bootmem) but much later for the secondary
+	 * CPUs, when bootmem will have gone away
+	 */
+	if (NODE_DATA(0)->bdata->node_bootmem_map) {
+		gdt = (struct desc_struct *)alloc_bootmem_pages(PAGE_SIZE);
+		/* alloc_bootmem_pages panics on failure, so no check */
+		memset(gdt, 0, PAGE_SIZE);
+	} else {
+		gdt = (struct desc_struct *)get_zeroed_page(GFP_KERNEL);
+		if (unlikely(!gdt)) {
+			printk(KERN_CRIT "CPU%d failed to allocate GDT\n", cpu);
+			for (;;)
+				local_irq_enable();
+		}
+	}
+
+	/*
+	 * Initialize the per-CPU GDT with the boot GDT,
+	 * and set up the GDT descriptor:
+	 */
+ 	memcpy(gdt, cpu_gdt_table, GDT_SIZE);
+
+	/* Set up GDT entry for 16bit stack */
+ 	*(__u64 *)(&gdt[GDT_ENTRY_ESPFIX_SS]) |=
+		((((__u64)stk16_off) << 16) & 0x000000ffffff0000ULL) |
+		((((__u64)stk16_off) << 32) & 0xff00000000000000ULL) |
+		(CPU_16BIT_STACK_SIZE - 1);
+
+	cpu_gdt_descr->size = GDT_SIZE - 1;
+ 	cpu_gdt_descr->address = (unsigned long)gdt;
+#else
+	if (cpu == 0 && cpu_gdt_descr->address == 0) {
+		gdt = (struct desc_struct *)alloc_bootmem_pages(PAGE_SIZE);
+		/* alloc_bootmem_pages panics on failure, so no check */
+		memset(gdt, 0, PAGE_SIZE);
+
+		memcpy(gdt, cpu_gdt_table, GDT_SIZE);
+
+		cpu_gdt_descr->size = GDT_SIZE;
+		cpu_gdt_descr->address = (unsigned long)gdt;
+	}
+#endif
+
+	cpu_gdt_init(cpu_gdt_descr);
 
 	/*
 	 * Set up and load the per-CPU TSS and LDT
Index: head-2006-03-02/arch/i386/kernel/io_apic-xen.c
===================================================================
--- head-2006-03-02.orig/arch/i386/kernel/io_apic-xen.c	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/arch/i386/kernel/io_apic-xen.c	2006-03-02 10:31:10.000000000 +0100
@@ -2631,8 +2631,10 @@ int __init io_apic_get_unique_id (int io
 		spin_unlock_irqrestore(&ioapic_lock, flags);
 
 		/* Sanity check */
-		if (reg_00.bits.ID != apic_id)
-			panic("IOAPIC[%d]: Unable change apic_id!\n", ioapic);
+		if (reg_00.bits.ID != apic_id) {
+			printk("IOAPIC[%d]: Unable to change apic_id!\n", ioapic);
+			return -1;
+		}
 	}
 
 	apic_printk(APIC_VERBOSE, KERN_INFO
Index: head-2006-03-02/arch/i386/kernel/mpparse-xen.c
===================================================================
--- head-2006-03-02.orig/arch/i386/kernel/mpparse-xen.c	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/arch/i386/kernel/mpparse-xen.c	2006-03-02 10:31:10.000000000 +0100
@@ -933,6 +933,7 @@ void __init mp_register_ioapic (
 	u32			gsi_base)
 {
 	int			idx = 0;
+	int			tmpid;
 
 	if (nr_ioapics >= MAX_IO_APICS) {
 		printk(KERN_ERR "ERROR: Max # of I/O APICs (%d) exceeded "
@@ -952,9 +953,14 @@ void __init mp_register_ioapic (
 	mp_ioapics[idx].mpc_apicaddr = address;
 
 	if ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) && (boot_cpu_data.x86 < 15))
-		mp_ioapics[idx].mpc_apicid = io_apic_get_unique_id(idx, id);
+		tmpid = io_apic_get_unique_id(idx, id);
 	else
-		mp_ioapics[idx].mpc_apicid = id;
+		tmpid = id;
+	if (tmpid == -1) {
+		nr_ioapics--;
+		return;
+	}
+	mp_ioapics[idx].mpc_apicid = tmpid;
 	mp_ioapics[idx].mpc_apicver = io_apic_get_version(idx);
 	
 	/* 
Index: head-2006-03-02/arch/i386/mach-xen/Makefile
===================================================================
--- head-2006-03-02.orig/arch/i386/mach-xen/Makefile	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/arch/i386/mach-xen/Makefile	2006-03-02 10:31:10.000000000 +0100
@@ -2,6 +2,4 @@
 # Makefile for the linux kernel.
 #
 
-obj-y				:= setup.o topology.o
-  
-topology-y			:= ../mach-default/topology.o
+obj-y				:= setup.o
Index: head-2006-03-02/arch/x86_64/kernel/io_apic-xen.c
===================================================================
--- head-2006-03-02.orig/arch/x86_64/kernel/io_apic-xen.c	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/arch/x86_64/kernel/io_apic-xen.c	2006-03-02 11:04:32.000000000 +0100
@@ -51,6 +51,8 @@ static int no_timer_check;
 int disable_timer_pin_1 __initdata;
 
 #ifndef CONFIG_XEN
+int timer_over_8254 __initdata = 1;
+
 /* Where if anywhere is the i8259 connect in external int mode */
 static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
 #endif
@@ -301,6 +303,22 @@ static int __init enable_ioapic_setup(ch
 __setup("noapic", disable_ioapic_setup);
 __setup("apic", enable_ioapic_setup);
 
+#ifndef CONFIG_XEN
+static int __init setup_disable_8254_timer(char *s)
+{
+	timer_over_8254 = -1;
+	return 1;
+}
+static int __init setup_enable_8254_timer(char *s)
+{
+	timer_over_8254 = 2;
+	return 1;
+}
+
+__setup("disable_8254_timer", setup_disable_8254_timer);
+__setup("enable_8254_timer", setup_enable_8254_timer);
+#endif
+
 #include <asm/pci-direct.h>
 #include <linux/pci_ids.h>
 #include <linux/pci.h>
@@ -359,25 +377,17 @@ void __init check_ioapic(void) 
 #endif
 					/* RED-PEN skip them on mptables too? */
 					return;
+
+				/* This should be actually default, but
+				   for 2.6.16 let's do it for ATI only where
+				   it's really needed. */
 				case PCI_VENDOR_ID_ATI:
 #ifndef CONFIG_XEN
-					if (apic_runs_main_timer != 0)
-						break;
-#ifdef CONFIG_ACPI
-					/* Don't do this for laptops right
-					   right now because their timer
-					   doesn't necessarily tick in C2/3 */
-					if (acpi_fadt.revision >= 3 &&
-			(acpi_fadt.plvl2_lat + acpi_fadt.plvl3_lat) < 1100) {
-						printk(KERN_INFO
-"ATI board detected, but seems to be a laptop. Timer might be shakey, sorry\n");
-						break;
-					}
-#endif
+					if (timer_over_8254 == 1) {
+						timer_over_8254 = 0;
 					printk(KERN_INFO
-	     "ATI board detected. Using APIC/PM timer.\n");
-					apic_runs_main_timer = 1;
-					nohpet = 1;
+		"ATI board detected. Disabling timer routing over 8254.\n");
+					}
 #endif
 					return;
 				} 
@@ -1848,6 +1858,8 @@ static inline void unlock_ExtINT_logic(v
  * a wide range of boards and BIOS bugs.  Fortunately only the timer IRQ
  * is so screwy.  Thanks to Brian Perkins for testing/hacking this beast
  * fanatically on his truly buggy board.
+ *
+ * FIXME: really need to revamp this for modern platforms only.
  */
 static inline void check_timer(void)
 {
@@ -1870,7 +1882,8 @@ static inline void check_timer(void)
 	 */
 	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
 	init_8259A(1);
-	enable_8259A_irq(0);
+	if (timer_over_8254 > 0)
+		enable_8259A_irq(0);
 
 	pin1  = find_isa_irq_pin(0, mp_INT);
 	apic1 = find_isa_irq_apic(0, mp_INT);
@@ -1925,7 +1938,7 @@ static inline void check_timer(void)
 	}
 	printk(" failed.\n");
 
-	if (nmi_watchdog) {
+	if (nmi_watchdog == NMI_IO_APIC) {
 		printk(KERN_WARNING "timer doesn't work through the IO-APIC - disabling NMI Watchdog!\n");
 		nmi_watchdog = 0;
 	}
Index: head-2006-03-02/arch/x86_64/kernel/setup-xen.c
===================================================================
--- head-2006-03-02.orig/arch/x86_64/kernel/setup-xen.c	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/arch/x86_64/kernel/setup-xen.c	2006-03-02 10:31:10.000000000 +0100
@@ -462,6 +462,12 @@ static __init void parse_cmdline_early (
 		else if(!memcmp(from, "elfcorehdr=", 11))
 			elfcorehdr_addr = memparse(from+11, &from);
 #endif
+
+#ifdef CONFIG_HOTPLUG_CPU
+		else if (!memcmp(from, "additional_cpus=", 16))
+			setup_additional_cpus(from+16);
+#endif
+
 	next_char:
 		c = *(from++);
 		if (!c)
Index: head-2006-03-02/drivers/xen/core/smpboot.c
===================================================================
--- head-2006-03-02.orig/drivers/xen/core/smpboot.c	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/drivers/xen/core/smpboot.c	2006-03-02 13:28:11.000000000 +0100
@@ -150,6 +150,11 @@ void vcpu_prepare(int vcpu)
 {
 	vcpu_guest_context_t ctxt;
 	struct task_struct *idle = idle_task(vcpu);
+#ifdef __x86_64__
+	struct desc_ptr *gdt_descr = &cpu_gdt_descr[vcpu];
+#else
+	struct Xgt_desc_struct *gdt_descr = &per_cpu(cpu_gdt_descr, vcpu);
+#endif
 
 	if (vcpu == 0)
 		return;
@@ -171,8 +176,8 @@ void vcpu_prepare(int vcpu)
 
 	ctxt.ldt_ents = 0;
 
-	ctxt.gdt_frames[0] = virt_to_mfn(cpu_gdt_descr[vcpu].address);
-	ctxt.gdt_ents      = cpu_gdt_descr[vcpu].size / 8;
+	ctxt.gdt_frames[0] = virt_to_mfn(gdt_descr->address);
+	ctxt.gdt_ents      = gdt_descr->size / 8;
 
 #ifdef __i386__
 	ctxt.user_regs.cs = __KERNEL_CS;
@@ -210,6 +215,11 @@ void __init smp_prepare_cpus(unsigned in
 {
 	int cpu;
 	struct task_struct *idle;
+#ifdef __x86_64__
+	struct desc_ptr *gdt_descr;
+#else
+	struct Xgt_desc_struct *gdt_descr;
+#endif
 
 	cpu_data[0] = boot_cpu_data;
 
@@ -226,6 +236,22 @@ void __init smp_prepare_cpus(unsigned in
 		if (cpu == 0)
 			continue;
 
+#ifdef __x86_64__
+		gdt_descr = &cpu_gdt_descr[cpu];
+#else
+		gdt_descr = &per_cpu(cpu_gdt_descr, cpu);
+#endif
+		gdt_descr->address = get_zeroed_page(GFP_KERNEL);
+		if (unlikely(!gdt_descr->address)) {
+			printk(KERN_CRIT "CPU%d failed to allocate GDT\n", cpu);
+			continue;
+		}
+		gdt_descr->size = GDT_SIZE;
+		memcpy((void *)gdt_descr->address, cpu_gdt_table, GDT_SIZE);
+		make_page_readonly(
+			(void *)gdt_descr->address,
+			XENFEAT_writable_descriptor_tables);
+
 		cpu_data[cpu] = boot_cpu_data;
 		cpu_2_logical_apicid[cpu] = cpu;
 		x86_cpu_to_apicid[cpu] = cpu;
@@ -243,17 +269,6 @@ void __init smp_prepare_cpus(unsigned in
 
 		irq_ctx_init(cpu);
 
-		cpu_gdt_descr[cpu].address =
-			__get_free_page(GFP_KERNEL|__GFP_ZERO);
-		BUG_ON(cpu_gdt_descr[0].size > PAGE_SIZE);
-		cpu_gdt_descr[cpu].size = cpu_gdt_descr[0].size;
-		memcpy((void *)cpu_gdt_descr[cpu].address,
-		       (void *)cpu_gdt_descr[0].address,
-		       cpu_gdt_descr[0].size);
-		make_page_readonly(
-			(void *)cpu_gdt_descr[cpu].address,
-			XENFEAT_writable_descriptor_tables);
-
 #ifdef CONFIG_HOTPLUG_CPU
 		if (xen_start_info->flags & SIF_INITDOMAIN)
 			cpu_set(cpu, cpu_present_map);
Index: head-2006-03-02/include/asm-i386/mach-xen/asm/desc.h
===================================================================
--- head-2006-03-02.orig/include/asm-i386/mach-xen/asm/desc.h	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/include/asm-i386/mach-xen/asm/desc.h	2006-03-02 10:31:10.000000000 +0100
@@ -23,11 +23,13 @@ struct Xgt_desc_struct {
 	unsigned short pad;
 } __attribute__ ((packed));
 
-extern struct Xgt_desc_struct idt_descr, cpu_gdt_descr[NR_CPUS];
+extern struct Xgt_desc_struct idt_descr;
+DECLARE_PER_CPU(struct Xgt_desc_struct, cpu_gdt_descr);
+
 
 static inline struct desc_struct *get_cpu_gdt_table(unsigned int cpu)
 {
-	return ((struct desc_struct *)cpu_gdt_descr[cpu].address);
+	return (struct desc_struct *)per_cpu(cpu_gdt_descr, cpu).address;
 }
 
 #define load_TR_desc() __asm__ __volatile__("ltr %w0"::"q" (GDT_ENTRY_TSS*8))
Index: head-2006-03-02/include/asm-x86_64/mach-xen/asm/pci.h
===================================================================
--- head-2006-03-02.orig/include/asm-x86_64/mach-xen/asm/pci.h	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/include/asm-x86_64/mach-xen/asm/pci.h	2006-03-02 10:31:10.000000000 +0100
@@ -19,8 +19,6 @@ extern unsigned int pcibios_assign_all_b
 #endif
 #define pcibios_scan_all_fns(a, b)	0
 
-extern int no_iommu, force_iommu;
-
 extern unsigned long pci_mem_start;
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		(pci_mem_start)
Index: head-2006-03-02/include/asm-x86_64/mach-xen/asm/pgtable.h
===================================================================
--- head-2006-03-02.orig/include/asm-x86_64/mach-xen/asm/pgtable.h	2006-03-02 13:27:51.000000000 +0100
+++ head-2006-03-02/include/asm-x86_64/mach-xen/asm/pgtable.h	2006-03-02 10:31:10.000000000 +0100
@@ -169,7 +169,7 @@ static inline pte_t ptep_get_and_clear_f
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
-#define USER_PTRS_PER_PGD	(TASK_SIZE/PGDIR_SIZE)
+#define USER_PTRS_PER_PGD	((TASK_SIZE-1)/PGDIR_SIZE+1)
 #define FIRST_USER_ADDRESS	0
 
 #ifndef __ASSEMBLY__
