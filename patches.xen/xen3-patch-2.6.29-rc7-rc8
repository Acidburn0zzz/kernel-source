From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 2.6.29-rc8
Patch-mainline: 2.6.29-rc8

 This patch contains the differences between 2.6.29-rc7 and -rc8.

Acked-by: Jeff Mahoney <jeffm@suse.com>
Automatically created from "patches.kernel.org/patch-2.6.29-rc7-rc8" by xen-port-patches.py

--- head-2009-03-18.orig/arch/x86/include/mach-xen/asm/fixmap_64.h	2009-03-18 15:48:51.000000000 +0100
+++ head-2009-03-18/arch/x86/include/mach-xen/asm/fixmap_64.h	2009-03-18 15:55:39.000000000 +0100
@@ -16,7 +16,6 @@
 #include <asm/apicdef.h>
 #include <asm/page.h>
 #include <asm/vsyscall.h>
-#include <asm/efi.h>
 #include <asm/acpi.h>
 
 /*
@@ -48,11 +47,6 @@ enum fixed_addresses {
 	FIX_IO_APIC_BASE_0,
 	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS - 1,
 #endif
-#ifdef CONFIG_EFI
-	FIX_EFI_IO_MAP_LAST_PAGE,
-	FIX_EFI_IO_MAP_FIRST_PAGE = FIX_EFI_IO_MAP_LAST_PAGE
-				  + MAX_EFI_IO_PAGES - 1,
-#endif
 #ifdef CONFIG_PARAVIRT
 	FIX_PARAVIRT_BOOTMAP,
 #else
--- head-2009-03-18.orig/arch/x86/kernel/setup-xen.c	2009-03-18 15:49:22.000000000 +0100
+++ head-2009-03-18/arch/x86/kernel/setup-xen.c	2009-03-18 15:56:15.000000000 +0100
@@ -894,6 +894,9 @@ void __init setup_arch(char **cmdline_p)
 
 	finish_e820_parsing();
 
+	if (efi_enabled)
+		efi_init();
+
 	if (is_initial_xendomain())
 		dmi_scan_machine();
 
@@ -915,8 +918,6 @@ void __init setup_arch(char **cmdline_p)
 	insert_resource(&iomem_resource, &data_resource);
 	insert_resource(&iomem_resource, &bss_resource);
 
-	if (efi_enabled)
-		efi_init();
 
 #ifdef CONFIG_X86_32
 	if (ppro_with_ram_bug()) {
--- head-2009-03-18.orig/arch/x86/mm/pageattr-xen.c	2009-03-18 15:51:09.000000000 +0100
+++ head-2009-03-18/arch/x86/mm/pageattr-xen.c	2009-03-18 15:56:58.000000000 +0100
@@ -535,6 +535,17 @@ static int split_large_page(pte_t *kpte,
 					 mk_pte(base, PAGE_KERNEL_RO), 0))
 		BUG();
 	__set_pmd_pte(kpte, address, level, mk_pte(base, __pgprot(_KERNPG_TABLE)));
+
+	/*
+	 * Intel Atom errata AAH41 workaround.
+	 *
+	 * The real fix should be in hw or in a microcode update, but
+	 * we also probabilistically try to reduce the window of having
+	 * a large TLB mixed with 4K TLBs while instruction fetches are
+	 * going on.
+	 */
+	__flush_tlb_all();
+
 	base = NULL;
 
 out_unlock:
