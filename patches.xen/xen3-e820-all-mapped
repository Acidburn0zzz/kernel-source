Subject: Introduce e820_all_mapped
From: Arjan van de Ven <arjan@linux.intel.com>
Acked-by: ak@suse.de
Patch-mainline: 2.6.17
References: 160583

Introduce a e820_all_mapped() function which checks if the entire
range <start,end> is mapped with type. This is done by moving the local
start variable to the end of each known-good region; if at the end
of the function the start address is still before end, there must be
a part that's not of the correct type; otherwise it's a good region.

Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
Signed-off-by: Andi Kleen <ak@suse.de>

Automatically created from "patches.arch/e820-all-mapped" by xen-port-patches.py

Index: head-2006-04-21/arch/x86_64/kernel/e820-xen.c
===================================================================
--- head-2006-04-21.orig/arch/x86_64/kernel/e820-xen.c	2006-04-21 13:27:19.000000000 +0200
+++ head-2006-04-21/arch/x86_64/kernel/e820-xen.c	2006-04-21 13:28:32.000000000 +0200
@@ -103,6 +103,10 @@ static inline int bad_addr(unsigned long
 	return 0;
 } 
 
+/*
+ * This function checks if any part of the range <start,end> is mapped
+ * with type.
+ */
 int __init e820_any_mapped(unsigned long start, unsigned long end, unsigned type) 
 { 
 	int i;
@@ -117,6 +121,35 @@ int __init e820_any_mapped(unsigned long
 	return 0;
 }
 
+/*
+ * This function checks if the entire range <start,end> is mapped with type.
+ *
+ * Note: this function only works correct if the e820 table is sorted and
+ * not-overlapping, which is the case
+ */
+int __init e820_all_mapped(unsigned long start, unsigned long end, unsigned type)
+{
+	int i;
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		if (type && ei->type != type)
+			continue;
+		/* is the region (part) in overlap with the current region ?*/
+		if (ei->addr >= end || ei->addr + ei->size <= start)
+			continue;
+
+		/* if the region is at the beginning of <start,end> we move
+		 * start to the end of the region since it's ok until there
+		 */
+		if (ei->addr <= start)
+			start = ei->addr + ei->size;
+		/* if start is now at or beyond end, we're done, full coverage */
+		if (start >= end)
+			return 1; /* we're done */
+	}
+	return 0;
+}
+
 /* 
  * Find a free area in a specific range. 
  */ 
@@ -276,6 +309,11 @@ void __init e820_reserve_resources(void)
 		}
 	}
 }
+#else
+int __init e820_all_mapped(unsigned long start, unsigned long end, unsigned type)
+{
+	return 1;
+}
 #endif /* CONFIG_XEN */
 
 void __init e820_print_map(char *who)
Index: head-2006-04-21/arch/i386/kernel/setup-xen.c
===================================================================
--- head-2006-04-21.orig/arch/i386/kernel/setup-xen.c	2006-04-21 13:24:32.000000000 +0200
+++ head-2006-04-21/arch/i386/kernel/setup-xen.c	2006-04-21 13:29:39.000000000 +0200
@@ -1008,6 +1008,36 @@ efi_memory_present_wrapper(unsigned long
 	return 0;
 }
 
+ /*
+  * This function checks if the entire range <start,end> is mapped with type.
+  *
+  * Note: this function only works correct if the e820 table is sorted and
+  * not-overlapping, which is the case
+  */
+int __init
+e820_all_mapped(unsigned long start, unsigned long end, unsigned type)
+{
+	int i;
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		if (type && ei->type != type)
+			continue;
+		/* is the region (part) in overlap with the current region ?*/
+		if (ei->addr >= end || ei->addr + ei->size <= start)
+			continue;
+		/* if the region is at the beginning of <start,end> we move
+		 * start to the end of the region since it's ok until there
+		 */
+		if (ei->addr <= start)
+			start = ei->addr + ei->size;
+		/* if start is now at or beyond end, we're done, full
+		 * coverage */
+		if (start >= end)
+			return 1; /* we're done */
+	}
+	return 0;
+}
+
 /*
  * Find the highest page frame number we have available
  */
@@ -1037,6 +1067,12 @@ void __init find_max_pfn(void)
 	}
 }
 #else
+int __init
+e820_all_mapped(unsigned long start, unsigned long end, unsigned type)
+{
+	return 1;
+}
+
 /* We don't use the fake e820 because we need to respond to user override. */
 void __init find_max_pfn(void)
 {
