Subject: patch-2.6.13-rc7-git2
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

Automatically created from "patches.fixes/patch-2.6.13-rc7-git1-git2" by xen-port-patches.py

Index: linux-2.6.13/arch/xen/x86_64/kernel/e820.c
===================================================================
--- linux-2.6.13.orig/arch/xen/x86_64/kernel/e820.c
+++ linux-2.6.13/arch/xen/x86_64/kernel/e820.c
@@ -203,8 +203,42 @@ unsigned long __init e820_end_of_ram(voi
 	return end_pfn;	
 }
 
 /* 
+ * Compute how much memory is missing in a range.
+ * Unlike the other functions in this file the arguments are in page numbers.
+ */
+unsigned long __init
+e820_hole_size(unsigned long start_pfn, unsigned long end_pfn)
+{
+	unsigned long ram = 0;
+	unsigned long start = start_pfn << PAGE_SHIFT;
+	unsigned long end = end_pfn << PAGE_SHIFT;
+	int i;
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		unsigned long last, addr;
+
+		if (ei->type != E820_RAM ||
+		    ei->addr+ei->size <= start ||
+		    ei->addr >= end)
+			continue;
+
+		addr = round_up(ei->addr, PAGE_SIZE);
+		if (addr < start)
+			addr = start;
+
+		last = round_down(ei->addr + ei->size, PAGE_SIZE);
+		if (last >= end)
+			last = end;
+
+		if (last > addr)
+			ram += last - addr;
+	}
+	return ((end - start) - ram) >> PAGE_SHIFT;
+}
+
+/*
  * Mark e820 reserved areas as busy for the resource manager.
  */
 void __init e820_reserve_resources(void)
 {
Index: linux-2.6.13/arch/xen/x86_64/mm/init.c
===================================================================
--- linux-2.6.13.orig/arch/xen/x86_64/mm/init.c
+++ linux-2.6.13/arch/xen/x86_64/mm/init.c
@@ -693,20 +693,29 @@ void zap_low_mappings(void)
 #ifndef CONFIG_NUMA
 void __init paging_init(void)
 {
 	{
-		unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
+		unsigned long zones_size[MAX_NR_ZONES];
+		unsigned long holes[MAX_NR_ZONES];
                 /*	unsigned int max_dma; */
+
+ 		memset(zones_size, 0, sizeof(zones_size));
+ 		memset(holes, 0, sizeof(holes));
+
                 /* max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT; */
-                /* if (end_pfn < max_dma) */
+                /* if (end_pfn < max_dma) { */
 			zones_size[ZONE_DMA] = end_pfn;
 #if 0                
-		else {
+			holes[ZONE_DMA] = e820_hole_size(0, end_pfn);
+		} else {
 			zones_size[ZONE_DMA] = max_dma;
+			holes[ZONE_DMA] = e820_hole_size(0, max_dma);
 			zones_size[ZONE_NORMAL] = end_pfn - max_dma;
+			holes[ZONE_NORMAL] = e820_hole_size(max_dma, end_pfn);
 		}
 #endif
-		free_area_init(zones_size);
+		free_area_init_node(0, NODE_DATA(0), zones_size,
+                        __pa(PAGE_OFFSET) >> PAGE_SHIFT, holes);
 	}
 
         set_fixmap(FIX_SHARED_INFO, xen_start_info.shared_info);
         HYPERVISOR_shared_info = (shared_info_t *)fix_to_virt(FIX_SHARED_INFO);
