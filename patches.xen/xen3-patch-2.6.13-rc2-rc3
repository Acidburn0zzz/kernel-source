Subject: patch-2.6.13-rc3
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

Automatically created from "patches.fixes/patch-2.6.13-rc2-rc3" by xen-port-patches.py
Further porting to arch/xen by kys and ccoffing

diff -uNrp linux-2.6.12/arch/xen/i386/kernel/cpu/common.c linux-2.6.12-2/arch/xen/i386/kernel/cpu/common.c
--- linux-2.6.12/arch/xen/i386/kernel/cpu/common.c	2005-08-18 17:43:16.812964931 -0600
+++ linux-2.6.12-2/arch/xen/i386/kernel/cpu/common.c	2005-08-18 17:45:25.535089870 -0600
@@ -440,6 +440,11 @@ void __devinit identify_cpu(struct cpuin
 	if (c == &boot_cpu_data)
 		sysenter_setup();
 	enable_sep_cpu();
+
+	if (c == &boot_cpu_data)
+		mtrr_bp_init();
+	else
+		mtrr_ap_init();
 }
 
 #ifdef CONFIG_X86_HT
diff -uNrp linux-2.6.12/arch/xen/i386/kernel/smpboot.c linux-2.6.12-2/arch/xen/i386/kernel/smpboot.c
--- linux-2.6.12/arch/xen/i386/kernel/smpboot.c	2005-08-18 17:43:16.838961523 -0600
+++ linux-2.6.12-2/arch/xen/i386/kernel/smpboot.c	2005-08-18 17:45:25.537089608 -0600
@@ -74,21 +74,21 @@ EXPORT_SYMBOL(smp_num_siblings);
 #endif
 
 /* Package ID of each logical CPU */
-int phys_proc_id[NR_CPUS] = {[0 ... NR_CPUS-1] = BAD_APICID};
+int phys_proc_id[NR_CPUS] __read_mostly = {[0 ... NR_CPUS-1] = BAD_APICID};
 EXPORT_SYMBOL(phys_proc_id);
 
 /* Core ID of each logical CPU */
-int cpu_core_id[NR_CPUS] = {[0 ... NR_CPUS-1] = BAD_APICID};
+int cpu_core_id[NR_CPUS] __read_mostly = {[0 ... NR_CPUS-1] = BAD_APICID};
 EXPORT_SYMBOL(cpu_core_id);
 
-cpumask_t cpu_sibling_map[NR_CPUS];
+cpumask_t cpu_sibling_map[NR_CPUS] __read_mostly;
 EXPORT_SYMBOL(cpu_sibling_map);
 
-cpumask_t cpu_core_map[NR_CPUS];
+cpumask_t cpu_core_map[NR_CPUS] __read_mostly;
 EXPORT_SYMBOL(cpu_core_map);
 
 /* bitmap of online cpus */
-cpumask_t cpu_online_map;
+cpumask_t cpu_online_map __read_mostly;
 EXPORT_SYMBOL(cpu_online_map);
 
 cpumask_t cpu_callin_map;
@@ -106,7 +106,7 @@ static int __devinitdata tsc_sync_disabl
 struct cpuinfo_x86 cpu_data[NR_CPUS] __cacheline_aligned;
 EXPORT_SYMBOL(cpu_data);
 
-u8 x86_cpu_to_apicid[NR_CPUS] =
+u8 x86_cpu_to_apicid[NR_CPUS] __read_mostly =
 			{ [0 ... NR_CPUS-1] = 0xff };
 EXPORT_SYMBOL(x86_cpu_to_apicid);
 
@@ -604,10 +604,10 @@ extern struct {
 #ifdef CONFIG_NUMA
 
 /* which logical CPUs are on which nodes */
-cpumask_t node_2_cpu_mask[MAX_NUMNODES] =
+cpumask_t node_2_cpu_mask[MAX_NUMNODES] __read_mostly =
 				{ [0 ... MAX_NUMNODES-1] = CPU_MASK_NONE };
 /* which node each logical CPU is on */
-int cpu_2_node[NR_CPUS] = { [0 ... NR_CPUS-1] = 0 };
+int cpu_2_node[NR_CPUS] __read_mostly = { [0 ... NR_CPUS-1] = 0 };
 EXPORT_SYMBOL(cpu_2_node);
 
 /* set up a mapping between cpu and node. */
@@ -635,7 +635,7 @@ static inline void unmap_cpu_to_node(int
 
 #endif /* CONFIG_NUMA */
 
-u8 cpu_2_logical_apicid[NR_CPUS] = { [0 ... NR_CPUS-1] = BAD_APICID };
+u8 cpu_2_logical_apicid[NR_CPUS] __read_mostly = { [0 ... NR_CPUS-1] = BAD_APICID };
 
 static void map_cpu_to_logical_apicid(void)
 {
diff -uNrp linux-2.6.12/arch/xen/i386/pci/irq.c linux-2.6.12-2/arch/xen/i386/pci/irq.c
--- linux-2.6.12/arch/xen/i386/pci/irq.c	2005-08-18 17:43:16.847960343 -0600
+++ linux-2.6.12-2/arch/xen/i386/pci/irq.c	2005-08-18 17:45:25.538089477 -0600
@@ -1057,24 +1057,28 @@ static int __init pcibios_irq_init(void)
 subsys_initcall(pcibios_irq_init);
 
 
-static void pirq_penalize_isa_irq(int irq)
+static void pirq_penalize_isa_irq(int irq, int active)
 {
 	/*
 	 *  If any ISAPnP device reports an IRQ in its list of possible
 	 *  IRQ's, we try to avoid assigning it to PCI devices.
 	 */
-	if (irq < 16)
-		pirq_penalty[irq] += 100;
+	if (irq < 16) {
+		if (active)
+			pirq_penalty[irq] += 1000;
+		else
+			pirq_penalty[irq] += 100;
+	}
 }
 
-void pcibios_penalize_isa_irq(int irq)
+void pcibios_penalize_isa_irq(int irq, int active)
 {
 #ifdef CONFIG_ACPI_PCI
 	if (!acpi_noirq)
-		acpi_penalize_isa_irq(irq);
+		acpi_penalize_isa_irq(irq, active);
 	else
 #endif
-		pirq_penalize_isa_irq(irq);
+		pirq_penalize_isa_irq(irq, active);
 }
 
 static int pirq_enable_irq(struct pci_dev *dev)
diff -uNrp linux-2.6.12/arch/xen/x86_64/Kconfig linux-2.6.12-2/arch/xen/x86_64/Kconfig
--- linux-2.6.12/arch/xen/x86_64/Kconfig	2005-08-18 17:43:16.849960081 -0600
+++ linux-2.6.12-2/arch/xen/x86_64/Kconfig	2005-08-18 17:45:25.539089346 -0600
@@ -233,7 +233,7 @@ config SCHED_SMT
 	  cost of slightly increased overhead in some places. If unsure say
 	  N here.
 
-source "kernel/Kconfig.preempt"
+#source "kernel/Kconfig.preempt"
 
 config K8_NUMA
        bool "K8 NUMA support"
@@ -281,7 +281,7 @@ config ARCH_FLATMEM_ENABLE
 	def_bool y
 	depends on !NUMA
 
-source "mm/Kconfig"
+#source "mm/Kconfig"
 
 config HAVE_ARCH_EARLY_PFN_TO_NID
 	def_bool y
@@ -412,7 +412,7 @@ config SECCOMP
 	  If unsure, say Y. Only embedded should say N here.
 
 
-source kernel/Kconfig.hz
+#source kernel/Kconfig.hz
 
 endmenu
 
diff -uNrp linux-2.6.12/arch/xen/x86_64/kernel/setup.c linux-2.6.12-2/arch/xen/x86_64/kernel/setup.c
--- linux-2.6.12/arch/xen/x86_64/kernel/setup.c	2005-08-18 17:43:16.860958639 -0600
+++ linux-2.6.12-2/arch/xen/x86_64/kernel/setup.c	2005-08-18 17:45:25.541089084 -0600
@@ -1297,6 +1297,10 @@ void __cpuinit identify_cpu(struct cpuin
 #ifdef CONFIG_X86_MCE
 	mcheck_init(c);
 #endif
+	if (c == &boot_cpu_data)
+		mtrr_bp_init();
+	else
+		mtrr_ap_init();
 #ifdef CONFIG_NUMA
 	if (c != &boot_cpu_data)
 		numa_add_cpu(c - cpu_data);
diff -uNrp linux-2.6.12/arch/xen/x86_64/Makefile linux-2.6.12-2/arch/xen/x86_64/Makefile
--- linux-2.6.12/arch/xen/x86_64/Makefile	2005-08-18 17:43:16.865957983 -0600
+++ linux-2.6.12-2/arch/xen/x86_64/Makefile	2005-08-18 17:45:25.540089215 -0600
@@ -66,7 +66,9 @@ CFLAGS += $(call cc-option,-funit-at-a-t
 head-y := arch/xen/x86_64/kernel/head.o arch/xen/x86_64/kernel/head64.o arch/xen/x86_64/kernel/init_task.o
 
 libs-y 					+= arch/x86_64/lib/
-core-y					+= arch/xen/x86_64/kernel/ arch/xen/x86_64/mm/
+core-y					+= arch/xen/x86_64/kernel/ \
+					arch/xen/x86_64/mm/ \
+					arch/x86_64/crypto/
 core-$(CONFIG_IA32_EMULATION)		+= arch/xen/x86_64/ia32/
 drivers-$(CONFIG_PCI)			+= arch/xen/x86_64/pci/
 drivers-$(CONFIG_OPROFILE)		+= arch/x86_64/oprofile/
diff -uNrp linux-2.6.12/include/asm-xen/asm-i386/pci.h linux-2.6.12-2/include/asm-xen/asm-i386/pci.h
--- linux-2.6.12/include/asm-xen/asm-i386/pci.h	2005-08-18 17:43:16.870957328 -0600
+++ linux-2.6.12-2/include/asm-xen/asm-i386/pci.h	2005-08-18 17:45:25.542088953 -0600
@@ -27,7 +27,7 @@ void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 
 void pcibios_set_master(struct pci_dev *dev);
-void pcibios_penalize_isa_irq(int irq);
+void pcibios_penalize_isa_irq(int irq, int active);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
 int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
 
diff -uNrp linux-2.6.12/include/asm-xen/asm-i386/processor.h linux-2.6.12-2/include/asm-xen/asm-i386/processor.h
--- linux-2.6.12/include/asm-xen/asm-i386/processor.h	2005-08-18 17:43:16.872957066 -0600
+++ linux-2.6.12-2/include/asm-xen/asm-i386/processor.h	2005-08-18 17:45:25.543088822 -0600
@@ -703,4 +703,15 @@ extern unsigned long boot_option_idle_ov
 extern void enable_sep_cpu(void);
 extern int sysenter_setup(void);
 
+#ifdef CONFIG_MTRR
+/* For the xen port stubbed out these functions. KYS */
+//extern void mtrr_ap_init(void);
+//extern void mtrr_bp_init(void);
+#define mtrr_ap_init() do {} while (0)
+#define mtrr_bp_init() do {} while (0)
+#else
+#define mtrr_ap_init() do {} while (0)
+#define mtrr_bp_init() do {} while (0)
+#endif
+
 #endif /* __ASM_I386_PROCESSOR_H */
diff -uNrp linux-2.6.12/include/asm-xen/asm-x86_64/pci.h linux-2.6.12-2/include/asm-xen/asm-x86_64/pci.h
--- linux-2.6.12/include/asm-xen/asm-x86_64/pci.h	2005-08-18 17:43:16.875956673 -0600
+++ linux-2.6.12-2/include/asm-xen/asm-x86_64/pci.h	2005-08-18 17:45:25.544088691 -0600
@@ -33,7 +33,7 @@ extern int (*pci_config_read)(int seg, i
 extern int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 value);
 
 void pcibios_set_master(struct pci_dev *dev);
-void pcibios_penalize_isa_irq(int irq);
+void pcibios_penalize_isa_irq(int irq, int active);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
 int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
 
