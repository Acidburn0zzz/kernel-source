Subject: patch-2.6.13-rc3
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

Automatically created from "patches.fixes/patch-2.6.13-rc2-rc3" by xen-port-patches.py

diff -purN linux-2.6.13-rc2/arch/xen/i386/Kconfig linux-2.6.13-rc3/arch/xen/i386/Kconfig
--- linux-2.6.13-rc2/arch/xen/i386/Kconfig	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/Kconfig	2005-07-13 06:46:46.000000000 +0200
@@ -1285,6 +1285,8 @@ source "fs/Kconfig.binfmt"
 
 endmenu
 
+source "net/Kconfig"
+
 source "drivers/Kconfig"
 
 source "fs/Kconfig"
diff -purN linux-2.6.13-rc2/arch/xen/i386/kernel/acpi/Makefile linux-2.6.13-rc3/arch/xen/i386/kernel/acpi/Makefile
--- linux-2.6.13-rc2/arch/xen/i386/kernel/acpi/Makefile	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/kernel/acpi/Makefile	2005-07-13 06:46:46.000000000 +0200
@@ -2,3 +2,7 @@ obj-$(CONFIG_ACPI_BOOT)		:= boot.o
 obj-$(CONFIG_X86_IO_APIC)	+= earlyquirk.o
 obj-$(CONFIG_ACPI_SLEEP)	+= sleep.o wakeup.o
 
+ifneq ($(CONFIG_ACPI_PROCESSOR),)
+obj-y				+= cstate.o
+endif
+
diff -purN linux-2.6.13-rc2/arch/xen/i386/kernel/cpu/common.c linux-2.6.13-rc3/arch/xen/i386/kernel/cpu/common.c
--- linux-2.6.13-rc2/arch/xen/i386/kernel/cpu/common.c	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/kernel/cpu/common.c	2005-07-13 06:46:46.000000000 +0200
@@ -435,6 +435,11 @@ void __devinit identify_cpu(struct cpuin
 	if (c == &boot_cpu_data)
 		sysenter_setup();
 	enable_sep_cpu();
+
+	if (c == &boot_cpu_data)
+		mtrr_bp_init();
+	else
+		mtrr_ap_init();
 }
 
 #ifdef CONFIG_X86_HT
diff -purN linux-2.6.13-rc2/arch/xen/i386/kernel/cpu/mtrr/main.c linux-2.6.13-rc3/arch/xen/i386/kernel/cpu/mtrr/main.c
--- linux-2.6.13-rc2/arch/xen/i386/kernel/cpu/mtrr/main.c	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/kernel/cpu/mtrr/main.c	2005-07-13 06:46:46.000000000 +0200
@@ -332,6 +332,8 @@ int mtrr_add_page(unsigned long base, un
 
 	error = -EINVAL;
 
+	/* No CPU hotplug when we change MTRR entries */
+	lock_cpu_hotplug();
 	/*  Search for existing MTRR  */
 	down(&main_lock);
 	for (i = 0; i < num_var_ranges; ++i) {
@@ -372,6 +374,7 @@ int mtrr_add_page(unsigned long base, un
 	error = i;
  out:
 	up(&main_lock);
+	unlock_cpu_hotplug();
 	return error;
 }
 
@@ -461,6 +464,8 @@ int mtrr_del_page(int reg, unsigned long
 		return -ENXIO;
 
 	max = num_var_ranges;
+	/* No CPU hotplug when we change MTRR entries */
+	lock_cpu_hotplug();
 	down(&main_lock);
 	if (reg < 0) {
 		/*  Search for existing MTRR  */
@@ -501,6 +506,7 @@ int mtrr_del_page(int reg, unsigned long
 	error = reg;
  out:
 	up(&main_lock);
+	unlock_cpu_hotplug();
 	return error;
 }
 /**
@@ -544,21 +550,9 @@ static void __init init_ifs(void)
 	centaur_init_mtrr();
 }
 
-static void __init init_other_cpus(void)
-{
-	if (use_intel())
-		get_mtrr_state();
-
-	/* bring up the other processors */
-	set_mtrr(~0U,0,0,0);
-
-	if (use_intel()) {
-		finalize_mtrr_state();
-		mtrr_state_warn();
-	}
-}
-
-
+/* The suspend/resume methods are only for CPU without MTRR. CPU using generic
+ * MTRR driver doesn't require this
+ */
 struct mtrr_value {
 	mtrr_type	ltype;
 	unsigned long	lbase;
@@ -611,13 +605,13 @@ static struct sysdev_driver mtrr_sysdev_
 
 
 /**
- * mtrr_init - initialize mtrrs on the boot CPU
+ * mtrr_bp_init - initialize mtrrs on the boot CPU
  *
  * This needs to be called early; before any of the other CPUs are 
  * initialized (i.e. before smp_init()).
  * 
  */
-static int __init mtrr_init(void)
+void __init mtrr_bp_init(void)
 {
 	init_ifs();
 
@@ -674,12 +668,48 @@ static int __init mtrr_init(void)
 	if (mtrr_if) {
 		set_num_var_ranges();
 		init_table();
-		init_other_cpus();
-
-		return sysdev_driver_register(&cpu_sysdev_class,
-					      &mtrr_sysdev_driver);
+		if (use_intel())
+			get_mtrr_state();
 	}
-	return -ENXIO;
 }
 
-subsys_initcall(mtrr_init);
+void mtrr_ap_init(void)
+{
+	unsigned long flags;
+
+	if (!mtrr_if || !use_intel())
+		return;
+	/*
+	 * Ideally we should hold main_lock here to avoid mtrr entries changed,
+	 * but this routine will be called in cpu boot time, holding the lock
+	 * breaks it. This routine is called in two cases: 1.very earily time
+	 * of software resume, when there absolutely isn't mtrr entry changes;
+	 * 2.cpu hotadd time. We let mtrr_add/del_page hold cpuhotplug lock to
+	 * prevent mtrr entry changes
+	 */
+	local_irq_save(flags);
+
+	mtrr_if->set_all();
+
+	local_irq_restore(flags);
+}
+
+static int __init mtrr_init_finialize(void)
+{
+	if (!mtrr_if)
+		return 0;
+	if (use_intel())
+		mtrr_state_warn();
+	else {
+		/* The CPUs haven't MTRR and seemes not support SMP. They have
+		 * specific drivers, we use a tricky method to support
+		 * suspend/resume for them.
+		 * TBD: is there any system with such CPU which supports
+		 * suspend/resume?  if no, we should remove the code.
+		 */
+		sysdev_driver_register(&cpu_sysdev_class,
+			&mtrr_sysdev_driver);
+	}
+	return 0;
+}
+subsys_initcall(mtrr_init_finialize);
diff -purN linux-2.6.13-rc2/arch/xen/i386/kernel/smpboot.c linux-2.6.13-rc3/arch/xen/i386/kernel/smpboot.c
--- linux-2.6.13-rc2/arch/xen/i386/kernel/smpboot.c	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/kernel/smpboot.c	2005-07-13 06:46:46.000000000 +0200
@@ -68,21 +68,21 @@ EXPORT_SYMBOL(smp_num_siblings);
 #endif
 
 /* Package ID of each logical CPU */
-int phys_proc_id[NR_CPUS] = {[0 ... NR_CPUS-1] = BAD_APICID};
+int phys_proc_id[NR_CPUS] __read_mostly = {[0 ... NR_CPUS-1] = BAD_APICID};
 EXPORT_SYMBOL(phys_proc_id);
 
 /* Core ID of each logical CPU */
-int cpu_core_id[NR_CPUS] = {[0 ... NR_CPUS-1] = BAD_APICID};
+int cpu_core_id[NR_CPUS] __read_mostly = {[0 ... NR_CPUS-1] = BAD_APICID};
 EXPORT_SYMBOL(cpu_core_id);
 
-cpumask_t cpu_sibling_map[NR_CPUS];
+cpumask_t cpu_sibling_map[NR_CPUS] __read_mostly;
 EXPORT_SYMBOL(cpu_sibling_map);
 
-cpumask_t cpu_core_map[NR_CPUS];
+cpumask_t cpu_core_map[NR_CPUS] __read_mostly;
 EXPORT_SYMBOL(cpu_core_map);
 
 /* bitmap of online cpus */
-cpumask_t cpu_online_map;
+cpumask_t cpu_online_map __read_mostly;
 EXPORT_SYMBOL(cpu_online_map);
 
 cpumask_t cpu_callin_map;
@@ -100,7 +100,7 @@ static int __devinitdata tsc_sync_disabl
 struct cpuinfo_x86 cpu_data[NR_CPUS] __cacheline_aligned;
 EXPORT_SYMBOL(cpu_data);
 
-u8 x86_cpu_to_apicid[NR_CPUS] =
+u8 x86_cpu_to_apicid[NR_CPUS] __read_mostly =
 			{ [0 ... NR_CPUS-1] = 0xff };
 EXPORT_SYMBOL(x86_cpu_to_apicid);
 
@@ -550,10 +550,10 @@ extern struct {
 #ifdef CONFIG_NUMA
 
 /* which logical CPUs are on which nodes */
-cpumask_t node_2_cpu_mask[MAX_NUMNODES] =
+cpumask_t node_2_cpu_mask[MAX_NUMNODES] __read_mostly =
 				{ [0 ... MAX_NUMNODES-1] = CPU_MASK_NONE };
 /* which node each logical CPU is on */
-int cpu_2_node[NR_CPUS] = { [0 ... NR_CPUS-1] = 0 };
+int cpu_2_node[NR_CPUS] __read_mostly = { [0 ... NR_CPUS-1] = 0 };
 EXPORT_SYMBOL(cpu_2_node);
 
 /* set up a mapping between cpu and node. */
@@ -581,7 +581,7 @@ static inline void unmap_cpu_to_node(int
 
 #endif /* CONFIG_NUMA */
 
-u8 cpu_2_logical_apicid[NR_CPUS] = { [0 ... NR_CPUS-1] = BAD_APICID };
+u8 cpu_2_logical_apicid[NR_CPUS] __read_mostly = { [0 ... NR_CPUS-1] = BAD_APICID };
 
 static void map_cpu_to_logical_apicid(void)
 {
diff -purN linux-2.6.13-rc2/arch/xen/i386/kernel/time.c linux-2.6.13-rc3/arch/xen/i386/kernel/time.c
--- linux-2.6.13-rc2/arch/xen/i386/kernel/time.c	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/kernel/time.c	2005-07-13 06:46:46.000000000 +0200
@@ -91,7 +91,7 @@ EXPORT_SYMBOL(rtc_lock);
 DEFINE_SPINLOCK(i8253_lock);
 EXPORT_SYMBOL(i8253_lock);
 
-struct timer_opts *cur_timer = &timer_none;
+struct timer_opts *cur_timer __read_mostly = &timer_none;
 
 /*
  * This is a special lock that is owned by the CPU and holds the index
diff -purN linux-2.6.13-rc2/arch/xen/i386/mm/ioremap.c linux-2.6.13-rc3/arch/xen/i386/mm/ioremap.c
--- linux-2.6.13-rc2/arch/xen/i386/mm/ioremap.c	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/mm/ioremap.c	2005-07-13 06:46:46.000000000 +0200
@@ -228,7 +228,8 @@ EXPORT_SYMBOL(ioremap_nocache);
 void iounmap(volatile void __iomem *addr)
 {
 	struct vm_struct *p;
-	if ((void __force *) addr <= high_memory) 
+
+	if ((void __force *)addr <= high_memory)
 		return;
 
 	/*
@@ -241,9 +242,10 @@ void iounmap(volatile void __iomem *addr
 		return;
 
 	write_lock(&vmlist_lock);
-	p = __remove_vm_area((void *) (PAGE_MASK & (unsigned long __force) addr));
+	p = __remove_vm_area((void *)(PAGE_MASK & (unsigned long __force)addr));
 	if (!p) { 
 		printk(KERN_WARNING "iounmap: bad address %p\n", addr);
+		dump_stack();
 		goto out_unlock;
 	}
 
diff -purN linux-2.6.13-rc2/arch/xen/i386/pci/irq.c linux-2.6.13-rc3/arch/xen/i386/pci/irq.c
--- linux-2.6.13-rc2/arch/xen/i386/pci/irq.c	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/i386/pci/irq.c	2005-07-13 06:46:46.000000000 +0200
@@ -1051,24 +1051,28 @@ static int __init pcibios_irq_init(void)
 subsys_initcall(pcibios_irq_init);
 
 
-static void pirq_penalize_isa_irq(int irq)
+static void pirq_penalize_isa_irq(int irq, int active)
 {
 	/*
 	 *  If any ISAPnP device reports an IRQ in its list of possible
 	 *  IRQ's, we try to avoid assigning it to PCI devices.
 	 */
-	if (irq < 16)
-		pirq_penalty[irq] += 100;
+	if (irq < 16) {
+		if (active)
+			pirq_penalty[irq] += 1000;
+		else
+			pirq_penalty[irq] += 100;
+	}
 }
 
-void pcibios_penalize_isa_irq(int irq)
+void pcibios_penalize_isa_irq(int irq, int active)
 {
 #ifdef CONFIG_ACPI_PCI
 	if (!acpi_noirq)
-		acpi_penalize_isa_irq(irq);
+		acpi_penalize_isa_irq(irq, active);
 	else
 #endif
-		pirq_penalize_isa_irq(irq);
+		pirq_penalize_isa_irq(irq, active);
 }
 
 static int pirq_enable_irq(struct pci_dev *dev)
diff -purN linux-2.6.13-rc2/arch/xen/x86_64/Kconfig linux-2.6.13-rc3/arch/xen/x86_64/Kconfig
--- linux-2.6.13-rc2/arch/xen/x86_64/Kconfig	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/x86_64/Kconfig	2005-07-13 06:46:46.000000000 +0200
@@ -515,6 +515,8 @@ config UID16
 
 endmenu
 
+source "net/Kconfig"
+
 source drivers/Kconfig
 
 source "drivers/firmware/Kconfig"
diff -purN linux-2.6.13-rc2/arch/xen/x86_64/Makefile linux-2.6.13-rc3/arch/xen/x86_64/Makefile
--- linux-2.6.13-rc2/arch/xen/x86_64/Makefile	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/x86_64/Makefile	2005-07-13 06:46:46.000000000 +0200
@@ -65,7 +65,9 @@ CFLAGS += $(call cc-option,-mno-sse -mno
 head-y := arch/x86_64/kernel/head.o arch/x86_64/kernel/head64.o arch/x86_64/kernel/init_task.o
 
 libs-y 					+= arch/x86_64/lib/
-core-y					+= arch/x86_64/kernel/ arch/x86_64/mm/
+core-y					+= arch/x86_64/kernel/ \
+					   arch/x86_64/mm/ \
+					   arch/x86_64/crypto/
 core-$(CONFIG_IA32_EMULATION)		+= arch/x86_64/ia32/
 drivers-$(CONFIG_PCI)			+= arch/x86_64/pci/
 drivers-$(CONFIG_OPROFILE)		+= arch/x86_64/oprofile/
diff -purN linux-2.6.13-rc2/arch/xen/x86_64/kernel/setup.c linux-2.6.13-rc3/arch/xen/x86_64/kernel/setup.c
--- linux-2.6.13-rc2/arch/xen/x86_64/kernel/setup.c	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/arch/xen/x86_64/kernel/setup.c	2005-07-13 06:46:46.000000000 +0200
@@ -1076,6 +1076,10 @@ void __cpuinit identify_cpu(struct cpuin
 #ifdef CONFIG_X86_MCE
 	mcheck_init(c);
 #endif
+	if (c == &boot_cpu_data)
+		mtrr_bp_init();
+	else
+		mtrr_ap_init();
 #ifdef CONFIG_NUMA
 	if (c != &boot_cpu_data)
 		numa_add_cpu(c - cpu_data);
diff -purN linux-2.6.13-rc2/include/asm-xen/asm-i386/pci.h linux-2.6.13-rc3/include/asm-xen/asm-i386/pci.h
--- linux-2.6.13-rc2/include/asm-xen/asm-i386/pci.h	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/include/asm-xen/asm-i386/pci.h	2005-07-13 06:46:46.000000000 +0200
@@ -27,7 +27,7 @@ void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 
 void pcibios_set_master(struct pci_dev *dev);
-void pcibios_penalize_isa_irq(int irq);
+void pcibios_penalize_isa_irq(int irq, int active);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
 int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
 
diff -purN linux-2.6.13-rc2/include/asm-xen/asm-i386/processor.h linux-2.6.13-rc3/include/asm-xen/asm-i386/processor.h
--- linux-2.6.13-rc2/include/asm-xen/asm-i386/processor.h	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/include/asm-xen/asm-i386/processor.h	2005-07-13 06:46:46.000000000 +0200
@@ -694,4 +694,12 @@ extern unsigned long boot_option_idle_ov
 extern void enable_sep_cpu(void);
 extern int sysenter_setup(void);
 
+#ifdef CONFIG_MTRR
+extern void mtrr_ap_init(void);
+extern void mtrr_bp_init(void);
+#else
+#define mtrr_ap_init() do {} while (0)
+#define mtrr_bp_init() do {} while (0)
+#endif
+
 #endif /* __ASM_I386_PROCESSOR_H */
diff -purN linux-2.6.13-rc2/include/asm-xen/asm-x86_64/pci.h linux-2.6.13-rc3/include/asm-xen/asm-x86_64/pci.h
--- linux-2.6.13-rc2/include/asm-xen/asm-x86_64/pci.h	2005-07-06 05:46:33.000000000 +0200
+++ linux-2.6.13-rc3/include/asm-xen/asm-x86_64/pci.h	2005-07-13 06:46:46.000000000 +0200
@@ -33,7 +33,7 @@ extern int (*pci_config_read)(int seg, i
 extern int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 value);
 
 void pcibios_set_master(struct pci_dev *dev);
-void pcibios_penalize_isa_irq(int irq);
+void pcibios_penalize_isa_irq(int irq, int active);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
 int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
 
