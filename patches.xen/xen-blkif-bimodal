From: kraxel@suse.de
Subject: multiprotocol blkback drivers.
Patch-mainline: obsolete
References: 208109

This is a patch for the block interface, frontend drivers, backend
drivers and tools to support multiple ring protocols.  Right there are
now just two: the 32bit and the 64bit one.  If needed it can be
extended.

Interface changes (io/blkif.h)
 * Have both request structs there, with "v1" and "v2" added to the
   name.  The old name is aliased to the native protocol of the
   architecture.
 * Add helper functions to convert v1/v2 requests to native.

Frontend changes:
 * Create a new node "protocol", add the protocol number it speaks
   there.

Backend changes:
 * Look at the "protocol" number of the frontend and switch ring
   handling accordingly.  If the protocol node isn't present it assumes
   native protocol.
 * As the request struct is copied anyway before being processed (for
   security reasons) it is converted to native at that point so most
   backend code doesn't need to know what the frontend speaks.
 * In case of blktap this is completely transparent to userspace, the
   kernel/userspace ring is always native no matter what the frontend
   speaks.

Tools changes:
 * Add one more option to the disk configuration, so one can specify the
   protocol the frontend speaks in the config file.  This is needed for
   old frontends which don't advertise the protocol they are speaking
   themself.
   I'm not that happy with this approach, but it works for now and I'm
   kida lost in the stack of python classes doing domain and device
   handling ...

Index: head-2007-01-16/drivers/xen/blkback/blkback.c
===================================================================
--- head-2007-01-16.orig/drivers/xen/blkback/blkback.c	2007-01-18 15:48:19.000000000 +0100
+++ head-2007-01-16/drivers/xen/blkback/blkback.c	2007-01-19 16:47:18.000000000 +0100
@@ -298,17 +298,20 @@ irqreturn_t blkif_be_int(int irq, void *
 
 static int do_block_io_op(blkif_t *blkif)
 {
-	blkif_back_ring_t *blk_ring = &blkif->blk_ring;
+	blkif_back_rings_t *blk_rings = &blkif->blk_rings;
 	blkif_request_t req;
 	pending_req_t *pending_req;
 	RING_IDX rc, rp;
 	int more_to_do = 0;
 
-	rc = blk_ring->req_cons;
-	rp = blk_ring->sring->req_prod;
+	rc = blk_rings->co.req_cons;
+	rp = blk_rings->co.sring->req_prod;
 	rmb(); /* Ensure we see queued requests up to 'rp'. */
 
-	while ((rc != rp) && !RING_REQUEST_CONS_OVERFLOW(blk_ring, rc)) {
+	while ((rc != rp)) {
+
+		if (RING_REQUEST_CONS_OVERFLOW(&blk_rings->co, rc))
+			break;
 
 		pending_req = alloc_req();
 		if (NULL == pending_req) {
@@ -317,8 +320,17 @@ static int do_block_io_op(blkif_t *blkif
 			break;
 		}
 
-		memcpy(&req, RING_GET_REQUEST(blk_ring, rc), sizeof(req));
-		blk_ring->req_cons = ++rc; /* before make_response() */
+		switch (blkif->blk_protocol) {
+		case 1:
+			blkif_get_v1_req(&req, RING_GET_REQUEST(&blk_rings->v1, rc));
+			break;
+		case 2:
+			blkif_get_v2_req(&req, RING_GET_REQUEST(&blk_rings->v2, rc));
+			break;
+		default:
+			BUG();
+		}
+		blk_rings->co.req_cons = ++rc; /* before make_response() */
 
 		switch (req.operation) {
 		case BLKIF_OP_READ:
@@ -498,34 +510,44 @@ static void dispatch_rw_block_io(blkif_t
 static void make_response(blkif_t *blkif, unsigned long id, 
 			  unsigned short op, int st)
 {
-	blkif_response_t *resp;
+	blkif_response_t  resp;
 	unsigned long     flags;
-	blkif_back_ring_t *blk_ring = &blkif->blk_ring;
+	blkif_back_rings_t *blk_rings = &blkif->blk_rings;
 	int more_to_do = 0;
 	int notify;
 
-	spin_lock_irqsave(&blkif->blk_ring_lock, flags);
-
-	/* Place on the response ring for the relevant domain. */ 
-	resp = RING_GET_RESPONSE(blk_ring, blk_ring->rsp_prod_pvt);
-	resp->id        = id;
-	resp->operation = op;
-	resp->status    = st;
-	blk_ring->rsp_prod_pvt++;
-	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(blk_ring, notify);
+	resp.id        = id;
+	resp.operation = op;
+	resp.status    = st;
 
-	if (blk_ring->rsp_prod_pvt == blk_ring->req_cons) {
+	spin_lock_irqsave(&blkif->blk_ring_lock, flags);
+	/* Place on the response ring for the relevant domain. */
+	switch (blkif->blk_protocol) {
+	case 1:
+		memcpy(RING_GET_RESPONSE(&blk_rings->v1, blk_rings->v1.rsp_prod_pvt),
+		       &resp, sizeof(resp));
+		break;
+	case 2:
+		memcpy(RING_GET_RESPONSE(&blk_rings->v2, blk_rings->v2.rsp_prod_pvt),
+		       &resp, sizeof(resp));
+		break;
+	default:
+		BUG();
+	}
+	blk_rings->co.rsp_prod_pvt++;
+	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->co, notify);
+	if (blk_rings->co.rsp_prod_pvt == blk_rings->co.req_cons) {
 		/*
 		 * Tail check for pending requests. Allows frontend to avoid
 		 * notifications if requests are already in flight (lower
 		 * overheads and promotes batching).
 		 */
-		RING_FINAL_CHECK_FOR_REQUESTS(blk_ring, more_to_do);
+		RING_FINAL_CHECK_FOR_REQUESTS(&blk_rings->co, more_to_do);
 
-	} else if (RING_HAS_UNCONSUMED_REQUESTS(blk_ring)) {
+	} else if (RING_HAS_UNCONSUMED_REQUESTS(&blk_rings->co)) {
 		more_to_do = 1;
-
 	}
+
 	spin_unlock_irqrestore(&blkif->blk_ring_lock, flags);
 
 	if (more_to_do)
Index: head-2007-01-16/drivers/xen/blkback/common.h
===================================================================
--- head-2007-01-16.orig/drivers/xen/blkback/common.h	2007-01-18 15:48:13.000000000 +0100
+++ head-2007-01-16/drivers/xen/blkback/common.h	2007-01-19 16:47:18.000000000 +0100
@@ -40,8 +40,7 @@
 #include <asm/pgalloc.h>
 #include <xen/evtchn.h>
 #include <asm/hypervisor.h>
-#include <xen/interface/io/blkif.h>
-#include <xen/interface/io/ring.h>
+#include <xen/blkif.h>
 #include <xen/gnttab.h>
 #include <xen/driver_util.h>
 #include <xen/xenbus.h>
@@ -67,7 +66,8 @@ typedef struct blkif_st {
 	/* Physical parameters of the comms window. */
 	unsigned int      irq;
 	/* Comms information. */
-	blkif_back_ring_t blk_ring;
+	int               blk_protocol;
+	blkif_back_rings_t blk_rings;
 	struct vm_struct *blk_ring_area;
 	/* The VBD attached to this interface. */
 	struct vbd        vbd;
Index: head-2007-01-16/drivers/xen/blkback/interface.c
===================================================================
--- head-2007-01-16.orig/drivers/xen/blkback/interface.c	2007-01-17 10:10:12.000000000 +0100
+++ head-2007-01-16/drivers/xen/blkback/interface.c	2007-01-19 16:47:18.000000000 +0100
@@ -95,7 +95,6 @@ static void unmap_frontend_page(blkif_t 
 
 int blkif_map(blkif_t *blkif, unsigned long shared_page, unsigned int evtchn)
 {
-	blkif_sring_t *sring;
 	int err;
 
 	/* Already connected through? */
@@ -111,8 +110,24 @@ int blkif_map(blkif_t *blkif, unsigned l
 		return err;
 	}
 
-	sring = (blkif_sring_t *)blkif->blk_ring_area->addr;
-	BACK_RING_INIT(&blkif->blk_ring, sring, PAGE_SIZE);
+	switch (blkif->blk_protocol) {
+	case 1:
+	{
+		blkif_v1_sring_t *sring_v1;
+		sring_v1 = (blkif_v1_sring_t *)blkif->blk_ring_area->addr;
+		BACK_RING_INIT(&blkif->blk_rings.v1, sring_v1, PAGE_SIZE);
+		break;
+	}
+	case 2:
+	{
+		blkif_v2_sring_t *sring_v2;
+		sring_v2 = (blkif_v2_sring_t *)blkif->blk_ring_area->addr;
+		BACK_RING_INIT(&blkif->blk_rings.v2, sring_v2, PAGE_SIZE);
+		break;
+	}
+	default:
+		BUG();
+	}
 
 	err = bind_interdomain_evtchn_to_irqhandler(
 		blkif->domid, evtchn, blkif_be_int, 0, "blkif-backend", blkif);
@@ -143,10 +158,10 @@ void blkif_disconnect(blkif_t *blkif)
 		blkif->irq = 0;
 	}
 
-	if (blkif->blk_ring.sring) {
+	if (blkif->blk_rings.co.sring) {
 		unmap_frontend_page(blkif);
 		free_vm_area(blkif->blk_ring_area);
-		blkif->blk_ring.sring = NULL;
+		blkif->blk_rings.co.sring = NULL;
 	}
 }
 
Index: head-2007-01-16/drivers/xen/blkback/xenbus.c
===================================================================
--- head-2007-01-16.orig/drivers/xen/blkback/xenbus.c	2007-01-17 10:10:12.000000000 +0100
+++ head-2007-01-16/drivers/xen/blkback/xenbus.c	2007-01-19 16:47:18.000000000 +0100
@@ -459,6 +459,7 @@ static int connect_ring(struct backend_i
 	struct xenbus_device *dev = be->dev;
 	unsigned long ring_ref;
 	unsigned int evtchn;
+	unsigned int protocol;
 	int err;
 
 	DPRINTK("%s", dev->otherend);
@@ -472,6 +473,19 @@ static int connect_ring(struct backend_i
 		return err;
 	}
 
+	err = xenbus_gather(XBT_NIL, dev->otherend, "protocol",
+			    "%u", &protocol, NULL);
+	if (err)
+		protocol = BLKIF_NATIVE_PROTOCOL;
+	if (protocol < 1 || protocol > 2) {
+		xenbus_dev_fatal(dev, err, "unknown fe protocol %d", protocol);
+		return -1;
+	}
+	be->blkif->blk_protocol = protocol;
+
+	printk("blkback: ring-ref %ld, event-channel %d, protocol %d\n",
+	       ring_ref, evtchn, protocol);
+
 	/* Map the shared frame, irq etc. */
 	err = blkif_map(be->blkif, ring_ref, evtchn);
 	if (err) {
Index: head-2007-01-16/drivers/xen/blkfront/blkfront.c
===================================================================
--- head-2007-01-16.orig/drivers/xen/blkfront/blkfront.c	2007-01-18 15:41:23.000000000 +0100
+++ head-2007-01-16/drivers/xen/blkfront/blkfront.c	2007-01-19 16:47:18.000000000 +0100
@@ -45,6 +45,7 @@
 #include <xen/xenbus.h>
 #include <xen/interface/grant_table.h>
 #include <xen/gnttab.h>
+#include <xen/blkif.h>
 #include <asm/hypervisor.h>
 #include <asm/maddr.h>
 
@@ -180,6 +181,12 @@ again:
 		message = "writing event-channel";
 		goto abort_transaction;
 	}
+	err = xenbus_printf(xbt, dev->nodename,
+			    "protocol", "%u", BLKIF_NATIVE_PROTOCOL);
+	if (err) {
+		message = "writing protocol";
+		goto abort_transaction;
+	}
 
 	err = xenbus_transaction_end(xbt, 0);
 	if (err) {
Index: head-2007-01-16/drivers/xen/blktap/blktap.c
===================================================================
--- head-2007-01-16.orig/drivers/xen/blktap/blktap.c	2007-01-19 16:21:35.000000000 +0100
+++ head-2007-01-16/drivers/xen/blktap/blktap.c	2007-01-19 16:47:18.000000000 +0100
@@ -1085,15 +1085,15 @@ irqreturn_t tap_blkif_be_int(int irq, vo
 static int print_dbug = 1;
 static int do_block_io_op(blkif_t *blkif)
 {
-	blkif_back_ring_t *blk_ring = &blkif->blk_ring;
+	blkif_back_rings_t *blk_rings = &blkif->blk_rings;
 	blkif_request_t req;
 	pending_req_t *pending_req;
 	RING_IDX rc, rp;
 	int more_to_do = 0;
 	tap_blkif_t *info;
 
-	rc = blk_ring->req_cons;
-	rp = blk_ring->sring->req_prod;
+	rc = blk_rings->co.req_cons;
+	rp = blk_rings->co.sring->req_prod;
 	rmb(); /* Ensure we see queued requests up to 'rp'. */
 
 	/*Check blkif has corresponding UE ring*/
@@ -1124,8 +1124,8 @@ static int do_block_io_op(blkif_t *blkif
 			more_to_do = 1;
 			break;
 		}
-		
-		if (RING_REQUEST_CONS_OVERFLOW(blk_ring, rc)) {
+
+		if (RING_REQUEST_CONS_OVERFLOW(&blk_rings->co, rc)) {
 			WPRINTK("RING_REQUEST_CONS_OVERFLOW!"
 			       " More to do\n");
 			more_to_do = 1;
@@ -1139,8 +1139,17 @@ static int do_block_io_op(blkif_t *blkif
 			break;
 		}
 
-		memcpy(&req, RING_GET_REQUEST(blk_ring, rc), sizeof(req));
-		blk_ring->req_cons = ++rc; /* before make_response() */	
+		switch (blkif->blk_protocol) {
+		case 1:
+			blkif_get_v1_req(&req, RING_GET_REQUEST(&blk_rings->v1, rc));
+			break;
+		case 2:
+			blkif_get_v2_req(&req, RING_GET_REQUEST(&blk_rings->v2, rc));
+			break;
+		default:
+			BUG();
+		}
+		blk_rings->co.req_cons = ++rc; /* before make_response() */
 
 		switch (req.operation) {
 		case BLKIF_OP_READ:
@@ -1216,7 +1225,7 @@ static void dispatch_rw_block_io(blkif_t
 		WPRINTK("blktap: fe_ring is full, can't add "
 			"IO Request will be dropped. %d %d\n",
 			RING_SIZE(&info->ufe_ring),
-			RING_SIZE(&blkif->blk_ring));
+			RING_SIZE(&blkif->blk_rings.co));
 		goto fail_response;
 	}
 
@@ -1404,32 +1413,44 @@ static void dispatch_rw_block_io(blkif_t
 static void make_response(blkif_t *blkif, unsigned long id, 
                           unsigned short op, int st)
 {
-	blkif_response_t *resp;
+	blkif_response_t  resp;
 	unsigned long     flags;
-	blkif_back_ring_t *blk_ring = &blkif->blk_ring;
+	blkif_back_rings_t *blk_rings = &blkif->blk_rings;
 	int more_to_do = 0;
 	int notify;
 
+	resp.id        = id;
+	resp.operation = op;
+	resp.status    = st;
+
 	spin_lock_irqsave(&blkif->blk_ring_lock, flags);
-	/* Place on the response ring for the relevant domain. */ 
-	resp = RING_GET_RESPONSE(blk_ring, blk_ring->rsp_prod_pvt);
-	resp->id        = id;
-	resp->operation = op;
-	resp->status    = st;
-	blk_ring->rsp_prod_pvt++;
-	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(blk_ring, notify);
+	/* Place on the response ring for the relevant domain. */
+	switch (blkif->blk_protocol) {
+	case 1:
+		memcpy(RING_GET_RESPONSE(&blk_rings->v1, blk_rings->v1.rsp_prod_pvt),
+		       &resp, sizeof(resp));
+		break;
+	case 2:
+		memcpy(RING_GET_RESPONSE(&blk_rings->v2, blk_rings->v2.rsp_prod_pvt),
+		       &resp, sizeof(resp));
+		break;
+	default:
+		BUG();
+	}
+	blk_rings->co.rsp_prod_pvt++;
+	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->co, notify);
 
-	if (blk_ring->rsp_prod_pvt == blk_ring->req_cons) {
+	if (blk_rings->co.rsp_prod_pvt == blk_rings->co.req_cons) {
 		/*
 		 * Tail check for pending requests. Allows frontend to avoid
 		 * notifications if requests are already in flight (lower
 		 * overheads and promotes batching).
 		 */
-		RING_FINAL_CHECK_FOR_REQUESTS(blk_ring, more_to_do);
-	} else if (RING_HAS_UNCONSUMED_REQUESTS(blk_ring)) {
+		RING_FINAL_CHECK_FOR_REQUESTS(&blk_rings->co, more_to_do);
+	} else if (RING_HAS_UNCONSUMED_REQUESTS(&blk_rings->co)) {
 		more_to_do = 1;
+	}
 
-	}	
 	spin_unlock_irqrestore(&blkif->blk_ring_lock, flags);
 	if (more_to_do)
 		blkif_notify_work(blkif);
Index: head-2007-01-16/drivers/xen/blktap/common.h
===================================================================
--- head-2007-01-16.orig/drivers/xen/blktap/common.h	2007-01-18 15:42:21.000000000 +0100
+++ head-2007-01-16/drivers/xen/blktap/common.h	2007-01-19 16:47:18.000000000 +0100
@@ -39,8 +39,7 @@
 #include <asm/pgalloc.h>
 #include <xen/evtchn.h>
 #include <asm/hypervisor.h>
-#include <xen/interface/io/blkif.h>
-#include <xen/interface/io/ring.h>
+#include <xen/blkif.h>
 #include <xen/gnttab.h>
 #include <xen/driver_util.h>
 
@@ -58,7 +57,8 @@ typedef struct blkif_st {
 	/* Physical parameters of the comms window. */
 	unsigned int      irq;
 	/* Comms information. */
-	blkif_back_ring_t blk_ring;
+	int               blk_protocol;
+	blkif_back_rings_t blk_rings;
 	struct vm_struct *blk_ring_area;
 	/* Back pointer to the backend_info. */
 	struct backend_info *be;
Index: head-2007-01-16/drivers/xen/blktap/interface.c
===================================================================
--- head-2007-01-16.orig/drivers/xen/blktap/interface.c	2007-01-17 10:10:12.000000000 +0100
+++ head-2007-01-16/drivers/xen/blktap/interface.c	2007-01-19 16:47:18.000000000 +0100
@@ -96,7 +96,6 @@ static void unmap_frontend_page(blkif_t 
 int tap_blkif_map(blkif_t *blkif, unsigned long shared_page, 
 		  unsigned int evtchn)
 {
-	blkif_sring_t *sring;
 	int err;
 
 	/* Already connected through? */
@@ -112,8 +111,24 @@ int tap_blkif_map(blkif_t *blkif, unsign
 		return err;
 	}
 
-	sring = (blkif_sring_t *)blkif->blk_ring_area->addr;
-	BACK_RING_INIT(&blkif->blk_ring, sring, PAGE_SIZE);
+	switch (blkif->blk_protocol) {
+	case 1:
+	{
+		blkif_v1_sring_t *sring_v1;
+		sring_v1 = (blkif_v1_sring_t *)blkif->blk_ring_area->addr;
+		BACK_RING_INIT(&blkif->blk_rings.v1, sring_v1, PAGE_SIZE);
+		break;
+	}
+	case 2:
+	{
+		blkif_v2_sring_t *sring_v2;
+		sring_v2 = (blkif_v2_sring_t *)blkif->blk_ring_area->addr;
+		BACK_RING_INIT(&blkif->blk_rings.v2, sring_v2, PAGE_SIZE);
+		break;
+	}
+	default:
+		BUG();
+	}
 
 	err = bind_interdomain_evtchn_to_irqhandler(
 		blkif->domid, evtchn, tap_blkif_be_int,
@@ -134,10 +149,10 @@ void tap_blkif_unmap(blkif_t *blkif)
 		unbind_from_irqhandler(blkif->irq, blkif);
 		blkif->irq = 0;
 	}
-	if (blkif->blk_ring.sring) {
+	if (blkif->blk_rings.co.sring) {
 		unmap_frontend_page(blkif);
 		free_vm_area(blkif->blk_ring_area);
-		blkif->blk_ring.sring = NULL;
+		blkif->blk_rings.co.sring = NULL;
 	}
 }
 
Index: head-2007-01-16/drivers/xen/blktap/xenbus.c
===================================================================
--- head-2007-01-16.orig/drivers/xen/blktap/xenbus.c	2007-01-17 10:10:12.000000000 +0100
+++ head-2007-01-16/drivers/xen/blktap/xenbus.c	2007-01-19 16:47:18.000000000 +0100
@@ -340,6 +340,7 @@ static int connect_ring(struct backend_i
 	struct xenbus_device *dev = be->dev;
 	unsigned long ring_ref;
 	unsigned int evtchn;
+	unsigned int protocol;
 	int err;
 
 	DPRINTK("%s\n", dev->otherend);
@@ -353,6 +354,19 @@ static int connect_ring(struct backend_i
 		return err;
 	}
 
+	err = xenbus_gather(XBT_NIL, dev->otherend, "protocol",
+			    "%u", &protocol, NULL);
+	if (err)
+		protocol = BLKIF_NATIVE_PROTOCOL;
+	if (protocol < 1 || protocol > 2) {
+		xenbus_dev_fatal(dev, err, "unknown fe protocol %d", protocol);
+		return -1;
+	}
+	be->blkif->blk_protocol = protocol;
+
+	printk("blktap: ring-ref %ld, event-channel %d, protocol %d\n",
+	       ring_ref, evtchn, protocol);
+
 	/* Map the shared frame, irq etc. */
 	err = tap_blkif_map(be->blkif, ring_ref, evtchn);
 	if (err) {
Index: head-2007-01-16/include/xen/blkif.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2007-01-16/include/xen/blkif.h	2007-01-19 16:47:18.000000000 +0100
@@ -0,0 +1,99 @@
+#ifndef __XEN_BLKIF_H__
+#define __XEN_BLKIF_H__
+
+#include <xen/interface/io/ring.h>
+#include <xen/interface/io/blkif.h>
+
+/* Not a real protocol.  Used to generate ring structs which contain
+ * the elements common to all protocols only.  This way we get a
+ * compiler-checkable way to use common struct elements, so we can
+ * avoid using switch(protocol) in a number of places.  */
+struct blkif_co_request {
+    char dummy;
+};
+struct blkif_co_response {
+    char dummy;
+};
+
+/* i386 protocol version */
+#pragma pack(push, 4)
+struct blkif_v1_request {
+    uint8_t        operation;    /* BLKIF_OP_???                         */
+    uint8_t        nr_segments;  /* number of segments                   */
+    blkif_vdev_t   handle;       /* only for read/write requests         */
+    uint64_t       id;           /* private guest value, echoed in resp  */
+    blkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */
+    struct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];
+};
+struct blkif_v1_response {
+    uint64_t        id;              /* copied from request */
+    uint8_t         operation;       /* copied from request */
+    int16_t         status;          /* BLKIF_RSP_???       */
+};
+typedef struct blkif_v1_request blkif_v1_request_t;
+typedef struct blkif_v1_response blkif_v1_response_t;
+#pragma pack(pop)
+
+/* x86_64 protocol version */
+struct blkif_v2_request {
+    uint8_t        operation;    /* BLKIF_OP_???                         */
+    uint8_t        nr_segments;  /* number of segments                   */
+    blkif_vdev_t   handle;       /* only for read/write requests         */
+    uint64_t       __attribute__((__aligned__(8))) id;
+    blkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */
+    struct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];
+};
+struct blkif_v2_response {
+    uint64_t       __attribute__((__aligned__(8))) id;
+    uint8_t         operation;       /* copied from request */
+    int16_t         status;          /* BLKIF_RSP_???       */
+};
+typedef struct blkif_v2_request blkif_v2_request_t;
+typedef struct blkif_v2_response blkif_v2_response_t;
+
+DEFINE_RING_TYPES(blkif_co, struct blkif_co_request, struct blkif_co_response);
+DEFINE_RING_TYPES(blkif_v1, struct blkif_v1_request, struct blkif_v1_response);
+DEFINE_RING_TYPES(blkif_v2, struct blkif_v2_request, struct blkif_v2_response);
+
+union blkif_back_rings {
+    blkif_co_back_ring_t co;
+    blkif_v1_back_ring_t v1;
+    blkif_v2_back_ring_t v2;
+};
+typedef union blkif_back_rings blkif_back_rings_t;
+
+#if defined(__i386__)
+# define BLKIF_NATIVE_PROTOCOL 1
+#elif defined(__x86_64__) || defined(__ia64__)
+# define BLKIF_NATIVE_PROTOCOL 2
+#else
+# error arch fixup needed here
+#endif
+
+/* translate requests: v1/v2 to native */
+#if 1 == BLKIF_NATIVE_PROTOCOL
+static void inline blkif_get_v1_req(blkif_request_t *dst, blkif_v1_request_t *src)
+#else
+static void inline blkif_get_v2_req(blkif_request_t *dst, blkif_v2_request_t *src)
+#endif
+{
+	memcpy(dst, src, sizeof(*dst));
+}
+
+#if 1 == BLKIF_NATIVE_PROTOCOL
+static void inline blkif_get_v2_req(blkif_request_t *dst, blkif_v2_request_t *src)
+#else
+static void inline blkif_get_v1_req(blkif_request_t *dst, blkif_v1_request_t *src)
+#endif
+{
+	int i;
+	dst->operation = src->operation;
+	dst->nr_segments = src->nr_segments;
+	dst->handle = src->handle;
+	dst->id = src->id;
+	dst->sector_number = src->sector_number;
+	for (i = 0; i < src->nr_segments; i++)
+		dst->seg[i] = src->seg[i];
+}
+
+#endif /* __XEN_BLKIF_H__ */
