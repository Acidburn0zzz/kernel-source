# HG changeset 9736 patch
From: kaf24@firebug.cl.cam.ac.uk
# Node ID 15089a58a425cfd556f485d37fd2874e59b3e6bf
# Parent  669a737174af5e82d589a584e6f4f904a09aa09c
Subject: Fix interaction between idle loop and RCU subsystem.
References: 180129

There is a problem with the current implementation of stop_hz_timer in
arch/i386/kernel/time-xen.c where the hz timer can be stopped on a CPU
which has RCU callbacks pending.

This patch backports a new RCU API created to fix this problem for the
s390 implementation of stop_hz_timer and also updates the time-xen.c
implementation of stop_hz_timer to call the new API.

Signed-off-by: Harry Butterworth <butterwo@uk.ibm.com>
xen-unstable changeset:   10327:c230dbe793d623d67ca1d486c0c1a8db5c7cab94
xen-unstable date:        Mon Jun 12 14:17:05 2006 +0100

rcu_need_cpu() backport removed as this is already part of our kernel.

Acked-by: Jan Beulich <jbeulich@novell.com>

--- linux-2.6-xen-sparse/arch/i386/kernel/time-xen.c	Sun Jun 11 20:34:23 2006 +0100
+++ linux-2.6-xen-sparse/arch/i386/kernel/time-xen.c	Mon Jun 12 14:18:52 2006 +0100
@@ -978,12 +978,19 @@ void stop_hz_timer(void)
 	unsigned int cpu = smp_processor_id();
 	unsigned long j;
 
-	/* We must do this /before/ checking rcu_pending(). */
 	cpu_set(cpu, nohz_cpu_mask);
+
+	/* See matching smp_mb in rcu_start_batch in rcupdate.c.  These mbs  */
+	/* ensure that if __rcu_pending (nested in rcu_needs_cpu) fetches a  */
+	/* value of rcp->cur that matches rdp->quiescbatch and allows us to  */
+	/* stop the hz timer then the cpumasks created for subsequent values */
+	/* of cur in rcu_start_batch are guaranteed to pick up the updated   */
+	/* nohz_cpu_mask and so will not depend on this cpu.                 */
+
 	smp_mb();
 
 	/* Leave ourselves in 'tick mode' if rcu or softirq pending. */
-	if (rcu_pending(cpu) || local_softirq_pending()) {
+	if (rcu_needs_cpu(cpu) || local_softirq_pending()) {
 		cpu_clear(cpu, nohz_cpu_mask);
 		j = jiffies + 1;
 	} else {
