From: jbeulich@novell.com
Subject: miscellaneous initialization code cleanup
Patch-mainline: obsolete

Index: head-2007-06-11/arch/x86_64/kernel/head-xen.S
===================================================================
--- head-2007-06-11.orig/arch/x86_64/kernel/head-xen.S	2007-06-11 09:08:18.000000000 +0200
+++ head-2007-06-11/arch/x86_64/kernel/head-xen.S	2007-06-11 09:09:41.000000000 +0200
@@ -47,15 +47,13 @@ ENTRY(name)
 
 NEXT_PAGE(init_level4_pgt)
 	.fill	512,8,0
-
         /*
          * We update two pgd entries to make kernel and user pgd consistent
          * at pgd_populate(). It can be used for kernel modules. So we place 
          * this page here for those cases to avoid memory corruption.
-         * We also use this page to establish the initiali mapping for
+         * We also use this page to establish the initial mapping for the
          * vsyscall area.
          */
-NEXT_PAGE(init_level4_user_pgt)
 	.fill	512,8,0
 
 NEXT_PAGE(level3_kernel_pgt)
Index: head-2007-06-11/arch/x86_64/kernel/setup-xen.c
===================================================================
--- head-2007-06-11.orig/arch/x86_64/kernel/setup-xen.c	2007-06-11 09:09:37.000000000 +0200
+++ head-2007-06-11/arch/x86_64/kernel/setup-xen.c	2007-06-11 09:09:41.000000000 +0200
@@ -445,28 +445,18 @@ void __init setup_arch(char **cmdline_p)
         */
        acpi_reserve_bootmem();
 #endif
-#ifdef CONFIG_XEN
 #ifdef CONFIG_BLK_DEV_INITRD
+#ifndef CONFIG_XEN
+	if (LOADER_TYPE && INITRD_START) {
+#else
 	if (xen_start_info->mod_start) {
-		if (INITRD_START + INITRD_SIZE <= (end_pfn << PAGE_SHIFT)) {
-			/*reserve_bootmem_generic(INITRD_START, INITRD_SIZE);*/
-			initrd_start = INITRD_START + PAGE_OFFSET;
-			initrd_end = initrd_start+INITRD_SIZE;
-			initrd_below_start_ok = 1;
-		} else {
-			printk(KERN_ERR "initrd extends beyond end of memory "
-				"(0x%08lx > 0x%08lx)\ndisabling initrd\n",
-				(unsigned long)(INITRD_START + INITRD_SIZE),
-				(unsigned long)(end_pfn << PAGE_SHIFT));
-			initrd_start = 0;
-		}
-	}
 #endif
-#else	/* CONFIG_XEN */
-#ifdef CONFIG_BLK_DEV_INITRD
-	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (end_pfn << PAGE_SHIFT)) {
+#ifndef CONFIG_XEN
 			reserve_bootmem_generic(INITRD_START, INITRD_SIZE);
+#else
+			initrd_below_start_ok = 1;
+#endif
 			initrd_start = INITRD_START + PAGE_OFFSET;
 			initrd_end = initrd_start+INITRD_SIZE;
 		}
@@ -479,7 +469,6 @@ void __init setup_arch(char **cmdline_p)
 		}
 	}
 #endif
-#endif	/* !CONFIG_XEN */
 #ifdef CONFIG_KEXEC
 #ifdef CONFIG_XEN
 	xen_machine_kexec_setup_resources();
Index: head-2007-06-11/arch/x86_64/kernel/setup64-xen.c
===================================================================
--- head-2007-06-11.orig/arch/x86_64/kernel/setup64-xen.c	2007-06-11 09:08:18.000000000 +0200
+++ head-2007-06-11/arch/x86_64/kernel/setup64-xen.c	2007-06-11 09:09:41.000000000 +0200
@@ -127,8 +127,8 @@ void __init setup_per_cpu_areas(void)
 #ifdef CONFIG_XEN
 static void switch_pt(void)
 {
-	xen_pt_switch(__pa(init_level4_pgt));
-        xen_new_user_pt(__pa(init_level4_user_pgt));
+	xen_pt_switch(__pa_symbol(init_level4_pgt));
+	xen_new_user_pt(__pa_symbol(__user_pgd(init_level4_pgt)));
 }
 
 void __cpuinit cpu_gdt_init(struct desc_ptr *gdt_descr)
Index: head-2007-06-11/arch/x86_64/kernel/vsyscall-xen.c
===================================================================
--- head-2007-06-11.orig/arch/x86_64/kernel/vsyscall-xen.c	2007-06-11 09:08:18.000000000 +0200
+++ head-2007-06-11/arch/x86_64/kernel/vsyscall-xen.c	2007-06-11 09:09:41.000000000 +0200
@@ -344,17 +344,6 @@ static void __init map_vsyscall(void)
 	__set_fixmap(VSYSCALL_FIRST_PAGE, physaddr_page0, PAGE_KERNEL_VSYSCALL);
 }
 
-#ifdef CONFIG_XEN
-static void __init map_vsyscall_user(void)
-{
-	extern void __set_fixmap_user(enum fixed_addresses, unsigned long, pgprot_t);
-	extern char __vsyscall_0;
-	unsigned long physaddr_page0 = __pa_symbol(&__vsyscall_0);
-
-	__set_fixmap_user(VSYSCALL_FIRST_PAGE, physaddr_page0, PAGE_KERNEL_VSYSCALL);
-}
-#endif
-
 static int __init vsyscall_init(void)
 {
 	BUG_ON(((unsigned long) &vgettimeofday !=
@@ -364,7 +353,6 @@ static int __init vsyscall_init(void)
 	BUG_ON((unsigned long) &vgetcpu != VSYSCALL_ADDR(__NR_vgetcpu));
 	map_vsyscall();
 #ifdef CONFIG_XEN
-	map_vsyscall_user();
 	vsyscall_gtod_data.sysctl_enabled = 0; /* disable vgettimeofay() */
  	if (boot_cpu_has(X86_FEATURE_RDTSCP))
 		vgetcpu_mode = VGETCPU_RDTSCP;
Index: head-2007-06-11/arch/x86_64/mm/init-xen.c
===================================================================
--- head-2007-06-11.orig/arch/x86_64/mm/init-xen.c	2007-06-11 09:08:50.000000000 +0200
+++ head-2007-06-11/arch/x86_64/mm/init-xen.c	2007-06-11 09:09:41.000000000 +0200
@@ -61,6 +61,8 @@ unsigned int __kernel_page_user;
 EXPORT_SYMBOL(__kernel_page_user);
 #endif
 
+int after_bootmem;
+
 extern unsigned long *contiguous_bitmap;
 
 DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
@@ -86,6 +88,11 @@ static void __meminit early_make_page_re
 	if (xen_feature(feature))
 		return;
 
+	if (after_bootmem) {
+		make_page_readonly(va, feature);
+		return;
+	}
+
 	addr = (unsigned long) page[pgd_index(_va)];
 	addr_to_page(addr, page);
 
@@ -214,8 +221,6 @@ void show_mem(void)
 	printk(KERN_INFO "%lu pages swap cached\n",cached);
 }
 
-int after_bootmem;
-
 static __init void *spp_getpage(void)
 { 
 	void *ptr;
@@ -234,14 +239,8 @@ static __init void *spp_getpage(void)
 	return ptr;
 } 
 
-#define pgd_offset_u(address) (pgd_t *)(init_level4_user_pgt + pgd_index(address))
-
-static inline pud_t *pud_offset_u(unsigned long address)
-{
-	pud_t *pud = level3_user_pgt;
-
-	return pud + pud_index(address);
-}
+#define pgd_offset_u(address) (__user_pgd(init_level4_pgt) + pgd_index(address))
+#define pud_offset_u(address) (level3_user_pgt + pud_index(address))
 
 static __init void set_pte_phys(unsigned long vaddr,
 			 unsigned long phys, pgprot_t prot, int user_mode)
@@ -344,9 +343,6 @@ static __init void set_pte_phys_ma(unsig
 	__flush_tlb_one(vaddr);
 }
 
-#define SET_FIXMAP_KERNEL 0
-#define SET_FIXMAP_USER   1
-
 /* NOTE: this is meant to be run only at boot */
 void __init 
 __set_fixmap (enum fixed_addresses idx, unsigned long phys, pgprot_t prot)
@@ -359,7 +355,8 @@ __set_fixmap (enum fixed_addresses idx, 
 	}
 	switch (idx) {
 	case VSYSCALL_LAST_PAGE ... VSYSCALL_FIRST_PAGE:
-		set_pte_phys(address, phys, prot, SET_FIXMAP_KERNEL);
+		set_pte_phys(address, phys, prot, 0);
+		set_pte_phys(address, phys, prot, 1);
 		break;
 	default:
 		set_pte_phys_ma(address, phys, prot);
@@ -367,22 +364,6 @@ __set_fixmap (enum fixed_addresses idx, 
 	}
 }
 
-/*
- * This only supports vsyscall area.
- */
-void __init
-__set_fixmap_user (enum fixed_addresses idx, unsigned long phys, pgprot_t prot)
-{
-	unsigned long address = __fix_to_virt(idx);
-
-	if (idx >= __end_of_fixed_addresses) {
-		printk("Invalid __set_fixmap\n");
-		return;
-	}
-
-	set_pte_phys(address, phys, prot, SET_FIXMAP_USER); 
-}
-
 unsigned long __meminitdata table_start, table_end;
 
 static __meminit void *alloc_static_page(unsigned long *phys)
@@ -509,9 +490,9 @@ phys_pmd_init(pmd_t *pmd_page, unsigned 
 		pte = alloc_static_page(&pte_phys);
 		pte_save = pte;
 		for (k = 0; k < PTRS_PER_PTE; pte++, k++, address += PTE_SIZE) {
-			if ((address >= end) ||
-			    ((address >> PAGE_SHIFT) >=
-			     xen_start_info->nr_pages)) { 
+			if (address >= (after_bootmem
+			                ? end
+			                : xen_start_info->nr_pages << PAGE_SHIFT)) {
 				__set_pte(pte, __pte(0)); 
 				continue;
 			}
@@ -607,13 +588,15 @@ void __init xen_init_pt(void)
 	init_level4_pgt[pgd_index(__START_KERNEL_map)] = 
 		__pgd(__pa_symbol(level3_kernel_pgt) | _PAGE_TABLE);
 	level3_kernel_pgt[pud_index(__START_KERNEL_map)] = 
-		__pud(__pa_symbol(level2_kernel_pgt) |
-		      _KERNPG_TABLE);
-	memcpy((void *)level2_kernel_pgt, page, PAGE_SIZE);
+		__pud(__pa_symbol(level2_kernel_pgt) | _PAGE_TABLE);
+	memcpy(level2_kernel_pgt, page, PAGE_SIZE);
+
+	__user_pgd(init_level4_pgt)[pgd_index(VSYSCALL_START)] =
+		__pgd(__pa_symbol(level3_user_pgt) | _PAGE_TABLE);
 
 	early_make_page_readonly(init_level4_pgt,
 				 XENFEAT_writable_page_tables);
-	early_make_page_readonly(init_level4_user_pgt,
+	early_make_page_readonly(__user_pgd(init_level4_pgt),
 				 XENFEAT_writable_page_tables);
 	early_make_page_readonly(level3_kernel_pgt,
 				 XENFEAT_writable_page_tables);
@@ -624,11 +607,8 @@ void __init xen_init_pt(void)
 
 	if (!xen_feature(XENFEAT_writable_page_tables)) {
 		xen_pgd_pin(__pa_symbol(init_level4_pgt));
-		xen_pgd_pin(__pa_symbol(init_level4_user_pgt));
+		xen_pgd_pin(__pa_symbol(__user_pgd(init_level4_pgt)));
 	}
-
-	set_pgd((pgd_t *)(init_level4_user_pgt + 511), 
-		mk_kernel_pgd(__pa_symbol(level3_user_pgt)));
 }
 
 static void __init extend_init_mapping(unsigned long tables_space)
Index: head-2007-06-11/include/asm-x86_64/mach-xen/asm/pgalloc.h
===================================================================
--- head-2007-06-11.orig/include/asm-x86_64/mach-xen/asm/pgalloc.h	2007-06-11 09:08:18.000000000 +0200
+++ head-2007-06-11/include/asm-x86_64/mach-xen/asm/pgalloc.h	2007-06-11 09:09:41.000000000 +0200
@@ -137,8 +137,8 @@ static inline pgd_t *pgd_alloc(struct mm
 	/*
 	 * Set level3_user_pgt for vsyscall area
 	 */
-	set_pgd(__user_pgd(pgd) + pgd_index(VSYSCALL_START),
-		__pgd(__pa_symbol(level3_user_pgt) | _PAGE_TABLE));
+	__user_pgd(pgd)[pgd_index(VSYSCALL_START)] =
+		__pgd(__pa_symbol(level3_user_pgt) | _PAGE_TABLE);
 	return pgd;
 }
 
Index: head-2007-06-11/include/asm-x86_64/mach-xen/asm/pgtable.h
===================================================================
--- head-2007-06-11.orig/include/asm-x86_64/mach-xen/asm/pgtable.h	2007-06-11 09:08:18.000000000 +0200
+++ head-2007-06-11/include/asm-x86_64/mach-xen/asm/pgtable.h	2007-06-11 09:09:41.000000000 +0200
@@ -17,7 +17,6 @@
 #include <asm/hypervisor.h>
 
 extern pud_t level3_user_pgt[512];
-extern pud_t init_level4_user_pgt[];
 
 extern void xen_init_pt(void);
 
@@ -391,7 +390,7 @@ static inline int pmd_large(pmd_t pte) {
 #define pgd_page(pgd)		(pfn_to_page(pgd_val(pgd) >> PAGE_SHIFT))
 #define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
 #define pgd_offset(mm, addr) ((mm)->pgd + pgd_index(addr))
-#define pgd_offset_k(address) (pgd_t *)(init_level4_pgt + pgd_index(address))
+#define pgd_offset_k(address) (init_level4_pgt + pgd_index(address))
 #define pgd_present(pgd) (pgd_val(pgd) & _PAGE_PRESENT)
 #define mk_kernel_pgd(address) __pgd((address) | _KERNPG_TABLE)
 
