Subject: Fix x86_64 xen build.
From: kraxel@suse.de

$subject says all.

Index: head-2006-02-09/include/asm-x86_64/mach-xen/asm/swiotlb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2006-02-09/include/asm-x86_64/mach-xen/asm/swiotlb.h	2006-02-09 11:13:00.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-i386/mach-xen/asm/swiotlb.h>
Index: head-2006-02-09/arch/x86_64/xen/kernel/process.c
===================================================================
--- head-2006-02-09.orig/arch/x86_64/xen/kernel/process.c	2006-02-09 11:06:59.000000000 +0100
+++ head-2006-02-09/arch/x86_64/xen/kernel/process.c	2006-02-09 11:13:00.000000000 +0100
@@ -452,13 +452,6 @@ out:
 	return err;
 }
 
-static inline void __save_init_fpu( struct task_struct *tsk )
-{
-	asm volatile( "rex64 ; fxsave %0 ; fnclex"
-		      : "=m" (tsk->thread.i387.fxsave));
-	tsk->thread_info->status &= ~TS_USEDFPU;
-}
-
 /*
  *	switch_to(x,y) should switch tasks from x to y.
  *
Index: head-2006-02-09/include/asm-x86_64/i387.h
===================================================================
--- head-2006-02-09.orig/include/asm-x86_64/i387.h	2006-02-09 11:05:37.000000000 +0100
+++ head-2006-02-09/include/asm-x86_64/i387.h	2006-02-09 11:13:01.000000000 +0100
@@ -170,10 +170,15 @@ static inline void kernel_fpu_end(void)
 	preempt_enable();
 }
 
-static inline void save_init_fpu(struct task_struct *tsk)
+static inline void __save_init_fpu(struct task_struct *tsk)
 {
  	__fxsave_clear(tsk);
 	task_thread_info(tsk)->status &= ~TS_USEDFPU;
+}
+
+static inline void save_init_fpu(struct task_struct *tsk)
+{
+	__save_init_fpu(tsk);
 	stts();
 }
 
Index: head-2006-02-09/include/asm-x86_64/mach-xen/asm/pgtable.h
===================================================================
--- head-2006-02-09.orig/include/asm-x86_64/mach-xen/asm/pgtable.h	2006-02-09 11:06:48.000000000 +0100
+++ head-2006-02-09/include/asm-x86_64/mach-xen/asm/pgtable.h	2006-02-09 11:13:01.000000000 +0100
@@ -440,12 +440,7 @@ static inline pud_t *__pud_offset_k(pud_
    Other CPUs get synced lazily via the page fault handler. */
 static inline pud_t *pud_offset_k(unsigned long address)
 {
-	unsigned long addr;
-
-	addr = pgd_val(init_level4_pgt[pud_index(address)]);
-	addr &= PHYSICAL_PAGE_MASK; /* machine physical */
-        addr = machine_to_phys(addr);
-	return __pud_offset_k((pud_t *)__va(addr), address);
+	return pud_offset(pgd_offset_k(address), address);
 }
 
 /* PMD  - Level 2 access */
Index: head-2006-02-09/arch/x86_64/xen/mm/pageattr.c
===================================================================
--- head-2006-02-09.orig/arch/x86_64/xen/mm/pageattr.c	2006-02-09 11:06:48.000000000 +0100
+++ head-2006-02-09/arch/x86_64/xen/mm/pageattr.c	2006-02-09 11:13:01.000000000 +0100
@@ -40,7 +40,7 @@ static void mm_walk(struct mm_struct *mm
 	int          g,u,m;
 
 	pgd = mm->pgd;
-	for (g = 0; g <= USER_PTRS_PER_PGD; g++, pgd++) {
+	for (g = 0; g <= (TASK_SIZE64 - 1) / PGDIR_SIZE; g++, pgd++) {
 		if (pgd_none(*pgd))
 			continue;
 		pud = pud_offset(pgd, 0);
Index: head-2006-02-09/arch/x86_64/xen/kernel/entry.S
===================================================================
--- head-2006-02-09.orig/arch/x86_64/xen/kernel/entry.S	2006-02-09 11:06:59.000000000 +0100
+++ head-2006-02-09/arch/x86_64/xen/kernel/entry.S	2006-02-09 11:13:01.000000000 +0100
@@ -498,44 +498,10 @@ ENTRY(stub_rt_sigreturn)
 #define XCPT_FRAME _frame ORIG_RAX
 
 /* 
- * Interrupt entry/exit.
+ * Interrupt exit.
  *
- * Interrupt entry points save only callee clobbered registers in fast path.
- *	
- * Entry runs with interrupts off.	
  */ 
 
-/* 0(%rsp): interrupt number */ 
-	.macro interrupt func
-	cld
-#ifdef CONFIG_DEBUG_INFO
-	SAVE_ALL	
-	movq %rsp,%rdi
-	/*
-	 * Setup a stack frame pointer.  This allows gdb to trace
-	 * back to the original stack.
-	 */
-	movq %rsp,%rbp
-	CFI_DEF_CFA_REGISTER	rbp
-#else		
-	SAVE_ARGS
-	leaq -ARGOFFSET(%rsp),%rdi	# arg1 for handler
-#endif	
-#if 0 /* For Xen we don't need to do this */       
-	testl $3,CS(%rdi)
-	je 1f
-	swapgs	
-#endif        
-1:	incl    %gs:pda_irqcount	# RED-PEN should check preempt count
-	movq %gs:pda_irqstackptr,%rax
-	cmoveq %rax,%rsp /*todo This needs CFI annotation! */
-	pushq %rdi			# save old stack	
-#ifndef CONFIG_DEBUG_INFO
-	CFI_ADJUST_CFA_OFFSET	8
-#endif
-	call \func
-	.endm
-
 retint_check:
 	movl threadinfo_flags(%rcx),%edx
 	andl %edi,%edx
@@ -647,7 +613,6 @@ ENTRY(invalidate_interrupt\num)
 ENTRY(call_function_interrupt)
 	apicinterrupt CALL_FUNCTION_VECTOR,smp_call_function_interrupt
 #endif
-#endif /* !CONFIG_XEN */
 
 #ifdef CONFIG_X86_LOCAL_APIC	
 ENTRY(apic_timer_interrupt)
@@ -659,6 +624,7 @@ ENTRY(error_interrupt)
 ENTRY(spurious_interrupt)
 	apicinterrupt SPURIOUS_APIC_VECTOR,smp_spurious_interrupt
 #endif
+#endif /* !CONFIG_XEN */
 				
 /*
  * Exception entry points.
@@ -831,9 +797,15 @@ ENTRY(hypervisor_callback)
 ENTRY(do_hypervisor_callback)   # do_hyperviosr_callback(struct *pt_regs)
 # Since we don't modify %rdi, evtchn_do_upall(struct *pt_regs) will
 # see the correct pointer to the pt_regs
-        addq $8, %rsp            # we don't return, adjust the stack frame
-11:	movb $0, EVENT_MASK(%rsp)         
+	movq %rdi, %rsp            # we don't return, adjust the stack frame
+11:	movb $0, EVENT_MASK(%rdi)
+	movq %gs:pda_irqstackptr,%rax
+	incl %gs:pda_irqcount
+	cmovzq %rax,%rsp
+	pushq %rdi
 	call evtchn_do_upcall
+	popq %rsp
+	decl %gs:pda_irqcount
         jmp  error_exit
 
         ALIGN
Index: head-2006-02-09/arch/x86_64/xen/kernel/x8664_ksyms.c
===================================================================
--- head-2006-02-09.orig/arch/x86_64/xen/kernel/x8664_ksyms.c	2006-02-09 11:10:59.000000000 +0100
+++ head-2006-02-09/arch/x86_64/xen/kernel/x8664_ksyms.c	2006-02-09 11:13:01.000000000 +0100
@@ -47,9 +47,6 @@ EXPORT_SYMBOL(ioremap_nocache);
 EXPORT_SYMBOL(iounmap);
 EXPORT_SYMBOL(kernel_thread);
 EXPORT_SYMBOL(pm_idle);
-#ifdef CONFIG_ACPI_BOOT
-EXPORT_SYMBOL(pm_power_off);
-#endif
 
 EXPORT_SYMBOL(__down_failed);
 EXPORT_SYMBOL(__down_failed_interruptible);
Index: head-2006-02-09/drivers/xen/core/evtchn.c
===================================================================
--- head-2006-02-09.orig/drivers/xen/core/evtchn.c	2006-02-09 11:06:48.000000000 +0100
+++ head-2006-02-09/drivers/xen/core/evtchn.c	2006-02-09 11:15:26.000000000 +0100
@@ -180,7 +180,6 @@ asmlinkage void evtchn_do_upcall(struct 
 		}
 	}
 }
-EXPORT_SYMBOL(evtchn_do_upcall);
 
 static int find_unbound_irq(void)
 {
