Subject: xen3 i386 build fixes.
From: kraxel@suse.de.

$subject says all.

 arch/i386/kernel/Makefile          |    2 +-
 arch/i386/kernel/acpi/earlyquirk.c |    2 ++
 arch/i386/kernel/sysenter.c        |   11 +++++++++++
 arch/i386/mm/init-xen.c            |    1 +
 arch/i386/mm/pgtable.c             |   12 ------------
 include/asm-i386/a.out.h           |    6 ++++++
 include/asm-i386/elf.h             |    6 ++++++
 include/asm-i386/fixmap.h          |   13 ++++++++++---
 include/asm-i386/page.h            |    4 +---
 9 files changed, 38 insertions(+), 19 deletions(-)

--- linux-2.6.15.orig/arch/i386/kernel/Makefile
+++ linux-2.6.15/arch/i386/kernel/Makefile
@@ -83,7 +83,7 @@ $(obj)/built-in.o: ld_flags += -R $(obj)
 
 SYSCFLAGS_vsyscall-syms.o = -r
 $(obj)/vsyscall-syms.o: $(src)/vsyscall.lds \
-			$(foreach F,$(VSYSCALL_TYPES-y),$(obj)/vsyscall-$F.o) \
+			$(obj)/vsyscall-$(if $(CONFIG_X86_SYSENTER),sysenter,int80).o \
 			$(obj)/$(vsyscall_note) FORCE
 	$(call if_changed,syscall)
 
--- linux-2.6.15.orig/arch/i386/kernel/sysenter.c
+++ linux-2.6.15/arch/i386/kernel/sysenter.c
@@ -48,11 +48,20 @@ void enable_sep_cpu(void)
  */
 extern const char vsyscall_int80_start, vsyscall_int80_end;
 extern const char vsyscall_sysenter_start, vsyscall_sysenter_end;
+#ifdef CONFIG_XEN
 static void *syscall_page;
+#endif
 
 int __init sysenter_setup(void)
 {
+#ifndef CONFIG_XEN
+	void *syscall_page;
+#endif
+
 	syscall_page = (void *)get_zeroed_page(GFP_ATOMIC);
+#ifndef CONFIG_XEN
+	__set_fixmap(FIX_VSYSCALL, __pa(syscall_page), PAGE_READONLY_EXEC);
+#endif
 
 #ifdef CONFIG_X86_SYSENTER
 	if (boot_cpu_has(X86_FEATURE_SEP)) {
@@ -70,6 +79,7 @@ int __init sysenter_setup(void)
 	return 0;
 }
 
+#ifdef CONFIG_XEN
 static struct page*
 syscall_nopage(struct vm_area_struct *vma, unsigned long adr, int *type)
 {
@@ -135,3 +145,4 @@ int in_gate_area_no_task(unsigned long a
 {
 	return 0;
 }
+#endif
--- linux-2.6.15.orig/arch/i386/mm/init-xen.c
+++ linux-2.6.15/arch/i386/mm/init-xen.c
@@ -29,6 +29,7 @@
 #include <linux/efi.h>
 #include <linux/memory_hotplug.h>
 #include <linux/initrd.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/processor.h>
 #include <asm/system.h>
--- linux-2.6.15.orig/arch/i386/mm/pgtable.c
+++ linux-2.6.15/arch/i386/mm/pgtable.c
@@ -13,7 +13,6 @@
 #include <linux/slab.h>
 #include <linux/pagemap.h>
 #include <linux/spinlock.h>
-#include <linux/module.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -139,10 +138,6 @@ void set_pmd_pfn(unsigned long vaddr, un
 	__flush_tlb_one(vaddr);
 }
 
-static int nr_fixmaps = 0;
-unsigned long __FIXADDR_TOP = 0xfffff000;
-EXPORT_SYMBOL(__FIXADDR_TOP);
-
 void __set_fixmap (enum fixed_addresses idx, unsigned long phys, pgprot_t flags)
 {
 	unsigned long address = __fix_to_virt(idx);
@@ -152,13 +147,6 @@ void __set_fixmap (enum fixed_addresses 
 		return;
 	}
 	set_pte_pfn(address, phys >> PAGE_SHIFT, flags);
-	nr_fixmaps++;
-}
-
-void set_fixaddr_top(unsigned long top)
-{
-	BUG_ON(nr_fixmaps > 0);
-	__FIXADDR_TOP = top - PAGE_SIZE;
 }
 
 pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
--- linux-2.6.15.orig/include/asm-i386/a.out.h
+++ linux-2.6.15/include/asm-i386/a.out.h
@@ -1,6 +1,8 @@
 #ifndef __I386_A_OUT_H__
 #define __I386_A_OUT_H__
 
+#include <linux/config.h>
+
 struct exec
 {
   unsigned long a_info;		/* Use macros N_MAGIC, etc for access */
@@ -19,7 +21,11 @@ struct exec
 
 #ifdef __KERNEL__
 
+#ifndef CONFIG_XEN
+#define STACK_TOP	TASK_SIZE
+#else
 #define STACK_TOP	(TASK_SIZE - 3*PAGE_SIZE)
+#endif
 
 #endif
 
--- linux-2.6.15.orig/include/asm-i386/elf.h
+++ linux-2.6.15/include/asm-i386/elf.h
@@ -129,15 +129,21 @@ extern int dump_task_extended_fpu (struc
 #define ELF_CORE_COPY_FPREGS(tsk, elf_fpregs) dump_task_fpu(tsk, elf_fpregs)
 #define ELF_CORE_COPY_XFPREGS(tsk, elf_xfpregs) dump_task_extended_fpu(tsk, elf_xfpregs)
 
+#ifndef CONFIG_XEN
+#define VSYSCALL_BASE	(__fix_to_virt(FIX_VSYSCALL))
+#else
 #define VSYSCALL_BASE	(PAGE_OFFSET - 2*PAGE_SIZE)
+#endif
 #define VSYSCALL_EHDR	((const struct elfhdr *) VSYSCALL_BASE)
 #define VSYSCALL_ENTRY	((unsigned long) &__kernel_vsyscall)
 extern void __kernel_vsyscall;
 
+#ifdef CONFIG_XEN
 #define ARCH_HAS_SETUP_ADDITIONAL_PAGES
 struct linux_binprm;
 extern int arch_setup_additional_pages(struct linux_binprm *bprm,
                                        int executable_stack);
+#endif
 
 #define ARCH_DLINFO						\
 do {								\
--- linux-2.6.15.orig/include/asm-i386/fixmap.h
+++ linux-2.6.15/include/asm-i386/fixmap.h
@@ -20,7 +20,7 @@
  * Leave one empty page between vmalloc'ed areas and
  * the start of the fixmap.
  */
-extern unsigned long __FIXADDR_TOP;
+#define __FIXADDR_TOP	0xfffff000
 
 #ifndef __ASSEMBLY__
 #include <linux/kernel.h>
@@ -52,6 +52,7 @@ extern unsigned long __FIXADDR_TOP;
  */
 enum fixed_addresses {
 	FIX_HOLE,
+	FIX_VSYSCALL,
 #ifdef CONFIG_X86_LOCAL_APIC
 	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
 #endif
@@ -94,8 +95,6 @@ enum fixed_addresses {
 extern void __set_fixmap (enum fixed_addresses idx,
 					unsigned long phys, pgprot_t flags);
 
-extern void set_fixaddr_top(unsigned long top);
-
 #define set_fixmap(idx, phys) \
 		__set_fixmap(idx, phys, PAGE_KERNEL)
 /*
@@ -117,6 +116,14 @@ extern void set_fixaddr_top(unsigned lon
 #define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
 #define __virt_to_fix(x)	((FIXADDR_TOP - ((x)&PAGE_MASK)) >> PAGE_SHIFT)
 
+/*
+ * This is the range that is readable by user mode, and things
+ * acting like user mode such as get_user_pages.
+ */
+#define FIXADDR_USER_START	(__fix_to_virt(FIX_VSYSCALL))
+#define FIXADDR_USER_END	(FIXADDR_USER_START + PAGE_SIZE)
+
+
 extern void __this_fixmap_does_not_exist(void);
 
 /*
--- linux-2.6.15.orig/include/asm-i386/page.h
+++ linux-2.6.15/include/asm-i386/page.h
@@ -121,7 +121,7 @@ extern int page_is_ram(unsigned long pag
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
 #define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
-#define MAXMEM			(__FIXADDR_TOP-__PAGE_OFFSET-__VMALLOC_RESERVE)
+#define MAXMEM			(-__PAGE_OFFSET-__VMALLOC_RESERVE)
 #define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
 #define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
 #define pfn_to_kaddr(pfn)      __va((pfn) << PAGE_SHIFT)
@@ -139,8 +139,6 @@ extern int page_is_ram(unsigned long pag
 	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
 		 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define __HAVE_ARCH_GATE_AREA 1
-
 #endif /* __KERNEL__ */
 
 #include <asm-generic/page.h>
--- linux-2.6.15.orig/arch/i386/kernel/acpi/earlyquirk.c
+++ linux-2.6.15/arch/i386/kernel/acpi/earlyquirk.c
@@ -18,11 +18,13 @@ static int __init check_bridge(int vendo
 		acpi_skip_timer_override = 1;
 	}
 #endif
+#ifndef CONFIG_XEN
 	if (vendor == PCI_VENDOR_ID_ATI && timer_over_8254 == 1) {
 		timer_over_8254 = 0;
 		printk(KERN_INFO "ATI board detected. Disabling timer routing "
 				"over 8254.\n");
 	}
+#endif
 	return 0;
 }
 
