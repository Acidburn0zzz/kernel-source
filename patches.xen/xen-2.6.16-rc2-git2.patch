Subject: Update Xen-specific files for 2.6.16-rc2-git2
From: jbeulich@novell.com

Index: head-2006-02-07/arch/i386/xen/kernel/acpi/boot.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/acpi/boot.c	2006-02-07 15:54:54.931479872 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/acpi/boot.c	2006-02-07 12:30:05.000000000 +0100
@@ -255,10 +255,17 @@ acpi_parse_lapic(acpi_table_entry_header
 
 	acpi_table_print_madt_entry(header);
 
-	/* Register even disabled CPUs for cpu hotplug */
-
-	x86_acpiid_to_apicid[processor->acpi_id] = processor->id;
+	/* Record local apic id only when enabled */
+	if (processor->flags.enabled)
+		x86_acpiid_to_apicid[processor->acpi_id] = processor->id;
 
+	/*
+	 * We need to register disabled CPU as well to permit
+	 * counting disabled CPUs. This allows us to size
+	 * cpus_possible_map more accurately, to permit
+	 * to not preallocating memory for all NR_CPUS
+	 * when we use CPU hotplug.
+	 */
 	mp_register_lapic(processor->id,	/* APIC ID */
 			  processor->flags.enabled);	/* Enabled? */
 
Index: head-2006-02-07/arch/i386/xen/kernel/apic.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/apic.c	2006-02-07 15:54:54.932479720 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/apic.c	2006-02-07 12:30:05.000000000 +0100
@@ -69,8 +69,10 @@ void ack_bad_irq(unsigned int irq)
 	 * holds up an irq slot - in excessive cases (when multiple
 	 * unexpected vectors occur) that might lock up the APIC
 	 * completely.
+	 * But only ack when the APIC is enabled -AK
 	 */
-	ack_APIC_irq();
+	if (cpu_has_apic)
+		ack_APIC_irq();
 }
 
 /*
Index: head-2006-02-07/arch/i386/xen/kernel/cpu/common.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/cpu/common.c	2006-02-07 15:54:54.929480176 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/cpu/common.c	2006-02-07 12:30:05.000000000 +0100
@@ -49,6 +49,7 @@ static void default_init(struct cpuinfo_
 
 static struct cpu_dev default_cpu = {
 	.c_init	= default_init,
+	.c_vendor = "Unknown",
 };
 static struct cpu_dev * this_cpu = &default_cpu;
 
@@ -155,6 +156,7 @@ static void __devinit get_cpu_vendor(str
 {
 	char *v = c->x86_vendor_id;
 	int i;
+	static int printed;
 
 	for (i = 0; i < X86_VENDOR_NUM; i++) {
 		if (cpu_devs[i]) {
@@ -164,10 +166,17 @@ static void __devinit get_cpu_vendor(str
 				c->x86_vendor = i;
 				if (!early)
 					this_cpu = cpu_devs[i];
-				break;
+				return;
 			}
 		}
 	}
+	if (!printed) {
+		printed++;
+		printk(KERN_ERR "CPU: Vendor unknown, using generic init.\n");
+		printk(KERN_ERR "CPU: Your system may be unstable.\n");
+	}
+	c->x86_vendor = X86_VENDOR_UNKNOWN;
+	this_cpu = &default_cpu;
 }
 
 
Index: head-2006-02-07/arch/i386/xen/kernel/process.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/process.c	2006-02-07 15:54:54.934479416 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/process.c	2006-02-07 12:30:05.000000000 +0100
@@ -209,8 +209,10 @@ void show_regs(struct pt_regs * regs)
 
 	if (user_mode(regs))
 		printk(" ESP: %04x:%08lx",0xffff & regs->xss,regs->esp);
-	printk(" EFLAGS: %08lx    %s  (%s)\n",
-	       regs->eflags, print_tainted(), system_utsname.release);
+	printk(" EFLAGS: %08lx    %s  (%s %.*s)\n",
+	       regs->eflags, print_tainted(), system_utsname.release,
+	       (int)strcspn(system_utsname.version, " "),
+	       system_utsname.version);
 	printk("EAX: %08lx EBX: %08lx ECX: %08lx EDX: %08lx\n",
 		regs->eax,regs->ebx,regs->ecx,regs->edx);
 	printk("ESI: %08lx EDI: %08lx EBP: %08lx",
Index: head-2006-02-07/arch/i386/xen/kernel/traps.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/traps.c	2006-02-07 15:54:54.933479568 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/traps.c	2006-02-07 12:30:05.000000000 +0100
@@ -163,7 +163,8 @@ static void show_trace_log_lvl(struct ta
 		stack = (unsigned long*)context->previous_esp;
 		if (!stack)
 			break;
-		printk(KERN_EMERG " =======================\n");
+		printk(log_lvl);
+		printk(" =======================\n");
 	}
 }
 
@@ -236,9 +237,11 @@ void show_registers(struct pt_regs *regs
 	}
 	print_modules();
 	printk(KERN_EMERG "CPU:    %d\nEIP:    %04x:[<%08lx>]    %s VLI\n"
-			"EFLAGS: %08lx   (%s) \n",
+			"EFLAGS: %08lx   (%s %.*s) \n",
 		smp_processor_id(), 0xffff & regs->xcs, regs->eip,
-		print_tainted(), regs->eflags, system_utsname.release);
+		print_tainted(), regs->eflags, system_utsname.release,
+		(int)strcspn(system_utsname.version, " "),
+		system_utsname.version);
 	print_symbol(KERN_EMERG "EIP is at %s\n", regs->eip);
 	printk(KERN_EMERG "eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
 		regs->eax, regs->ebx, regs->ecx, regs->edx);
Index: head-2006-02-07/arch/x86_64/xen/kernel/apic.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/apic.c	2006-02-07 15:54:54.938478808 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/apic.c	2006-02-07 13:19:36.000000000 +0100
@@ -44,6 +44,26 @@
 int apic_verbosity;
 int disable_apic;
 
+/*
+ * 'what should we do if we get a hw irq event on an illegal vector'.
+ * each architecture has to answer this themselves.
+ */
+void ack_bad_irq(unsigned int irq)
+{
+	printk("unexpected IRQ trap at vector %02x\n", irq);
+	/*
+	 * Currently unexpected vectors happen only on SMP and APIC.
+	 * We _must_ ack these because every local APIC has only N
+	 * irq slots per priority level, and a 'hanging, unacked' IRQ
+	 * holds up an irq slot - in excessive cases (when multiple
+	 * unexpected vectors occur) that might lock up the APIC
+	 * completely.
+  	 * But don't ack when the APIC is disabled. -AK
+	 */
+	if (!disable_apic)
+		ack_APIC_irq();
+}
+
 void smp_local_timer_interrupt(struct pt_regs *regs)
 {
 
Index: head-2006-02-07/arch/x86_64/xen/kernel/entry.S
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/entry.S	2006-02-07 15:54:54.937478960 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/entry.S	2006-02-07 13:29:12.000000000 +0100
@@ -530,7 +530,9 @@ ENTRY(stub_rt_sigreturn)
 	movq %gs:pda_irqstackptr,%rax
 	cmoveq %rax,%rsp /*todo This needs CFI annotation! */
 	pushq %rdi			# save old stack	
+#ifndef CONFIG_DEBUG_INFO
 	CFI_ADJUST_CFA_OFFSET	8
+#endif
 	call \func
 	.endm
 
@@ -1013,7 +1015,7 @@ KPROBE_ENTRY(debug)
 
 #if 0
 	/* runs on exception stack */	
-ENTRY(nmi)
+KPROBE_ENTRY(nmi)
 	INTR_FRAME
 	pushq $-1
 	CFI_ADJUST_CFA_OFFSET 8
@@ -1060,6 +1062,7 @@ paranoid_schedule:
 	cli
 	jmp paranoid_userspace
 	CFI_ENDPROC
+	.previous .text
 #endif        
 
 KPROBE_ENTRY(int3)
Index: head-2006-02-07/arch/x86_64/xen/kernel/io_apic.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/io_apic.c	2006-02-07 15:54:54.938478808 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/io_apic.c	2006-02-07 15:55:31.165971392 +0100
@@ -356,6 +356,16 @@ void __init check_ioapic(void) 
 #endif
 					/* RED-PEN skip them on mptables too? */
 					return;
+				case PCI_VENDOR_ID_ATI:
+#ifndef CONFIG_XEN
+					if (apic_runs_main_timer != 0)
+						break;
+					printk(KERN_INFO
+	     "ATI board detected. Using APIC/PM timer.\n");
+					apic_runs_main_timer = 1;
+					nohpet = 1;
+#endif
+					return;
 				} 
 
 				/* No multi-function device? */
Index: head-2006-02-07/arch/x86_64/xen/kernel/process.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/process.c	2006-02-07 15:54:54.939478656 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/process.c	2006-02-07 12:30:05.000000000 +0100
@@ -465,8 +465,10 @@ static inline void __save_init_fpu( stru
  * This could still be optimized: 
  * - fold all the options into a flag word and test it with a single test.
  * - could test fs/gs bitsliced
+ *
+ * Kprobes not supported here. Set the probe on schedule instead.
  */
-struct task_struct *
+__kprobes struct task_struct *
 __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 {
 	struct thread_struct *prev = &prev_p->thread,
Index: head-2006-02-07/arch/x86_64/xen/kernel/setup.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/setup.c	2006-02-07 15:54:54.937478960 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/setup.c	2006-02-07 12:30:05.000000000 +0100
@@ -942,7 +942,7 @@ void __init setup_arch(char **cmdline_p)
 	e820_setup_gap();
 
 #ifdef CONFIG_GART_IOMMU
-       iommu_hole_init();
+	iommu_hole_init();
 #endif
 
 #ifdef CONFIG_XEN
@@ -1115,6 +1115,7 @@ static void __init amd_detect_cmp(struct
 static int __init init_amd(struct cpuinfo_x86 *c)
 {
 	int r;
+	unsigned level;
 
 #ifdef CONFIG_SMP
 	unsigned long value;
@@ -1137,6 +1138,11 @@ static int __init init_amd(struct cpuinf
 	   3DNow is IDd by bit 31 in extended CPUID (1*32+31) anyway */
 	clear_bit(0*32+31, &c->x86_capability);
 	
+	/* On C+ stepping K8 rep microcode works well for copy/memset */
+	level = cpuid_eax(1);
+	if (c->x86 == 15 && ((level >= 0x0f48 && level < 0x0f50) || level >= 0x0f58))
+		set_bit(X86_FEATURE_REP_GOOD, &c->x86_capability);
+
 	r = get_model_name(c);
 	if (!r) { 
 		switch (c->x86) { 
Index: head-2006-02-07/arch/x86_64/xen/kernel/traps.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/traps.c	2006-02-07 15:54:54.939478656 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/traps.c	2006-02-07 13:34:22.000000000 +0100
@@ -372,7 +372,7 @@ void out_of_line_bug(void)
 static DEFINE_SPINLOCK(die_lock);
 static int die_owner = -1;
 
-unsigned long oops_begin(void)
+unsigned __kprobes long oops_begin(void)
 {
 	int cpu = safe_smp_processor_id();
 	unsigned long flags;
@@ -391,7 +391,7 @@ unsigned long oops_begin(void)
 	return flags;
 }
 
-void oops_end(unsigned long flags)
+void __kprobes oops_end(unsigned long flags)
 { 
 	die_owner = -1;
 	bust_spinlocks(0);
@@ -400,7 +400,7 @@ void oops_end(unsigned long flags)
 		panic("Oops");
 }
 
-void __die(const char * str, struct pt_regs * regs, long err)
+void __kprobes __die(const char * str, struct pt_regs * regs, long err)
 {
 	static int die_counter;
 	printk(KERN_EMERG "%s: %04lx [%u] ", str, err & 0xffff,++die_counter);
@@ -433,7 +433,7 @@ void die(const char * str, struct pt_reg
 }
 
 #ifdef CONFIG_X86_LOCAL_APIC
-void die_nmi(char *str, struct pt_regs *regs)
+void __kprobes die_nmi(char *str, struct pt_regs *regs)
 {
 	unsigned long flags = oops_begin();
 
@@ -577,7 +577,8 @@ asmlinkage void __kprobes do_general_pro
 	}
 }
 
-static void mem_parity_error(unsigned char reason, struct pt_regs * regs)
+static __kprobes void
+mem_parity_error(unsigned char reason, struct pt_regs * regs)
 {
 	printk("Uhhuh. NMI received. Dazed and confused, but trying to continue\n");
 	printk("You probably have a hardware problem with your RAM chips\n");
@@ -587,7 +588,8 @@ static void mem_parity_error(unsigned ch
 	outb(reason, 0x61);
 }
 
-static void io_check_error(unsigned char reason, struct pt_regs * regs)
+static __kprobes void
+io_check_error(unsigned char reason, struct pt_regs * regs)
 {
 	printk("NMI: IOCK error (debug interrupt?)\n");
 	show_registers(regs);
@@ -600,7 +602,8 @@ static void io_check_error(unsigned char
 	outb(reason, 0x61);
 }
 
-static void unknown_nmi_error(unsigned char reason, struct pt_regs * regs)
+static __kprobes void
+unknown_nmi_error(unsigned char reason, struct pt_regs * regs)
 {	printk("Uhhuh. NMI received for unknown reason %02x.\n", reason);
 	printk("Dazed and confused, but trying to continue\n");
 	printk("Do you have a strange power saving mode enabled?\n");
@@ -608,7 +611,7 @@ static void unknown_nmi_error(unsigned c
 
 /* Runs on IST stack. This code must keep interrupts off all the time.
    Nested NMIs are prevented by the CPU. */
-asmlinkage void default_do_nmi(struct pt_regs *regs)
+asmlinkage __kprobes void default_do_nmi(struct pt_regs *regs)
 {
 	unsigned char reason = 0;
 	int cpu;
@@ -660,7 +663,7 @@ asmlinkage void __kprobes do_int3(struct
 /* Help handler running on IST stack to switch back to user stack
    for scheduling or signal handling. The actual stack switch is done in
    entry.S */
-asmlinkage struct pt_regs *sync_regs(struct pt_regs *eregs)
+asmlinkage __kprobes struct pt_regs *sync_regs(struct pt_regs *eregs)
 {
 	struct pt_regs *regs = eregs;
 	/* Did already sync */
Index: head-2006-02-07/arch/x86_64/xen/mm/fault.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/mm/fault.c	2006-02-07 15:54:54.935479264 +0100
+++ head-2006-02-07/arch/x86_64/xen/mm/fault.c	2006-02-07 13:35:29.000000000 +0100
@@ -34,7 +34,6 @@
 #include <asm/proto.h>
 #include <asm/kdebug.h>
 #include <asm-generic/sections.h>
-#include <asm/kdebug.h>
 
 DEFINE_PER_CPU(pgd_t *, cur_pgd);
 
@@ -161,8 +160,8 @@ void dump_pagetable(unsigned long addres
 	preempt_enable();
 	pgd += pgd_index(address);
 
-	printk("PGD %lx ", pgd_val(*pgd));
 	if (bad_address(pgd)) goto bad;
+	printk("PGD %lx ", pgd_val(*pgd));
 	if (!pgd_present(*pgd)) goto ret; 
 
 	pud = __pud_offset_k((pud_t *)pgd_page(*pgd), address);
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/system.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/system.h	2006-02-07 15:54:54.942478200 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/system.h	2006-02-07 13:36:30.000000000 +0100
@@ -539,7 +539,7 @@ __asm__ __volatile__("6667:movl %1, %0\n
 #else
 #define smp_rmb()	rmb()
 #define smp_mb()	mb()
-#define set_mb(var, value) do { xchg(&var, value); } while (0)
+#define set_mb(var, value) do { (void) xchg(&var, value); } while (0)
 #endif
 #define smp_read_barrier_depends()	read_barrier_depends()
 #else
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/system.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/system.h	2006-02-07 15:54:54.941478352 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/system.h	2006-02-07 12:30:05.000000000 +0100
@@ -331,7 +331,7 @@ static inline unsigned long __cmpxchg(vo
 #define wmb()	asm volatile("" ::: "memory")
 #endif
 #define read_barrier_depends()	do {} while(0)
-#define set_mb(var, value) do { xchg(&var, value); } while (0)
+#define set_mb(var, value) do { (void) xchg(&var, value); } while (0)
 #define set_wmb(var, value) do { var = value; wmb(); } while (0)
 
 #define warn_if_not_ulong(x) do { unsigned long foo; (void) (&(x) == &foo); } while (0)
