Subject: xen3 patch: pmd-shared
From: kraxel

Copied from xen-unstable.hg/patches/linux-2.6.12

Signed-off-by: Gerd Knorr <kraxel@suse.de>
Index: linux-2.6.12/arch/i386/mm/init.c
===================================================================
--- linux-2.6.12.orig/arch/i386/mm/init.c
+++ linux-2.6.12/arch/i386/mm/init.c
@@ -633,9 +633,9 @@ void __init pgtable_cache_init(void)
 				PTRS_PER_PGD*sizeof(pgd_t),
 				PTRS_PER_PGD*sizeof(pgd_t),
 				0,
 				pgd_ctor,
-				PTRS_PER_PMD == 1 ? pgd_dtor : NULL);
+				pgd_dtor);
 	if (!pgd_cache)
 		panic("pgtable_cache_init(): Cannot create pgd cache");
 }
 
Index: linux-2.6.12/arch/i386/mm/pageattr.c
===================================================================
--- linux-2.6.12.orig/arch/i386/mm/pageattr.c
+++ linux-2.6.12/arch/i386/mm/pageattr.c
@@ -74,9 +74,9 @@ static void set_pmd_pte(pte_t *kpte, uns
 	struct page *page;
 	unsigned long flags;
 
 	set_pte_atomic(kpte, pte); 	/* change init_mm */
-	if (PTRS_PER_PMD > 1)
+	if (HAVE_SHARED_KERNEL_PMD)
 		return;
 
 	spin_lock_irqsave(&pgd_lock, flags);
 	for (page = pgd_list; page; page = (struct page *)page->index) {
Index: linux-2.6.12/arch/i386/mm/pgtable.c
===================================================================
--- linux-2.6.12.orig/arch/i386/mm/pgtable.c
+++ linux-2.6.12/arch/i386/mm/pgtable.c
@@ -206,41 +206,60 @@ static inline void pgd_list_del(pgd_t *p
 void pgd_ctor(void *pgd, kmem_cache_t *cache, unsigned long unused)
 {
 	unsigned long flags;
 
-	if (PTRS_PER_PMD == 1)
+	if (!HAVE_SHARED_KERNEL_PMD)
 		spin_lock_irqsave(&pgd_lock, flags);
 
 	memcpy((pgd_t *)pgd + USER_PTRS_PER_PGD,
 			swapper_pg_dir + USER_PTRS_PER_PGD,
 			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
 
-	if (PTRS_PER_PMD > 1)
+	if (HAVE_SHARED_KERNEL_PMD)
 		return;
 
 	pgd_list_add(pgd);
 	spin_unlock_irqrestore(&pgd_lock, flags);
 	memset(pgd, 0, USER_PTRS_PER_PGD*sizeof(pgd_t));
 }
 
-/* never called when PTRS_PER_PMD > 1 */
 void pgd_dtor(void *pgd, kmem_cache_t *cache, unsigned long unused)
 {
 	unsigned long flags; /* can be called from interrupt context */
 
+	if (HAVE_SHARED_KERNEL_PMD)
+		return;
+
 	spin_lock_irqsave(&pgd_lock, flags);
 	pgd_list_del(pgd);
 	spin_unlock_irqrestore(&pgd_lock, flags);
 }
 
 pgd_t *pgd_alloc(struct mm_struct *mm)
 {
-	int i;
+	int i = 0;
 	pgd_t *pgd = kmem_cache_alloc(pgd_cache, GFP_KERNEL);
 
 	if (PTRS_PER_PMD == 1 || !pgd)
 		return pgd;
 
+	if (!HAVE_SHARED_KERNEL_PMD) {
+		/* alloc and copy kernel pmd */
+		unsigned long flags;
+		pgd_t *copy_pgd = pgd_offset_k(PAGE_OFFSET);
+		pud_t *copy_pud = pud_offset(copy_pgd, PAGE_OFFSET);
+		pmd_t *copy_pmd = pmd_offset(copy_pud, PAGE_OFFSET);
+		pmd_t *pmd = kmem_cache_alloc(pmd_cache, GFP_KERNEL);
+		if (0 == pmd)
+			goto out_oom;
+
+		spin_lock_irqsave(&pgd_lock, flags);
+		memcpy(pmd, copy_pmd, PAGE_SIZE);
+		spin_unlock_irqrestore(&pgd_lock, flags);
+		set_pgd(&pgd[USER_PTRS_PER_PGD], __pgd(1 + __pa(pmd)));
+	}
+
+	/* alloc user pmds */
 	for (i = 0; i < USER_PTRS_PER_PGD; ++i) {
 		pmd_t *pmd = kmem_cache_alloc(pmd_cache, GFP_KERNEL);
 		if (!pmd)
 			goto out_oom;
@@ -259,10 +278,17 @@ void pgd_free(pgd_t *pgd)
 {
 	int i;
 
 	/* in the PAE case user pgd entries are overwritten before usage */
-	if (PTRS_PER_PMD > 1)
-		for (i = 0; i < USER_PTRS_PER_PGD; ++i)
-			kmem_cache_free(pmd_cache, (void *)__va(pgd_val(pgd[i])-1));
+	if (PTRS_PER_PMD > 1) {
+		for (i = 0; i < USER_PTRS_PER_PGD; ++i) {
+			pmd_t *pmd = (void *)__va(pgd_val(pgd[i])-1);
+			kmem_cache_free(pmd_cache, pmd);
+		}
+		if (!HAVE_SHARED_KERNEL_PMD) {
+			pmd_t *pmd = (void *)__va(pgd_val(pgd[USER_PTRS_PER_PGD])-1);
+			kmem_cache_free(pmd_cache, pmd);
+		}
+	}
 	/* in the non-PAE case, free_pgtables() clears user pgd entries */
 	kmem_cache_free(pgd_cache, pgd);
 }
Index: linux-2.6.12/include/asm-i386/pgtable-2level-defs.h
===================================================================
--- linux-2.6.12.orig/include/asm-i386/pgtable-2level-defs.h
+++ linux-2.6.12/include/asm-i386/pgtable-2level-defs.h
@@ -1,7 +1,9 @@
 #ifndef _I386_PGTABLE_2LEVEL_DEFS_H
 #define _I386_PGTABLE_2LEVEL_DEFS_H
 
+#define HAVE_SHARED_KERNEL_PMD 0
+
 /*
  * traditional i386 two-level paging structure:
  */
 
Index: linux-2.6.12/include/asm-i386/pgtable-3level-defs.h
===================================================================
--- linux-2.6.12.orig/include/asm-i386/pgtable-3level-defs.h
+++ linux-2.6.12/include/asm-i386/pgtable-3level-defs.h
@@ -1,7 +1,9 @@
 #ifndef _I386_PGTABLE_3LEVEL_DEFS_H
 #define _I386_PGTABLE_3LEVEL_DEFS_H
 
+#define HAVE_SHARED_KERNEL_PMD 1
+
 /*
  * PGDIR_SHIFT determines what a top-level page table entry can map
  */
 #define PGDIR_SHIFT	30
