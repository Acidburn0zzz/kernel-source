From: jbeulich@novell.com
Subject: eliminate init_tss

$subject says it all.

Index: head-2006-03-02/arch/x86_64/kernel/asm-offsets.c
===================================================================
--- head-2006-03-02.orig/arch/x86_64/kernel/asm-offsets.c	2006-03-02 13:27:46.000000000 +0100
+++ head-2006-03-02/arch/x86_64/kernel/asm-offsets.c	2006-02-24 12:37:58.000000000 +0100
@@ -66,7 +66,9 @@ int main(void)
 	DEFINE(pbe_address, offsetof(struct pbe, address));
 	DEFINE(pbe_orig_address, offsetof(struct pbe, orig_address));
 	DEFINE(pbe_next, offsetof(struct pbe, next));
+#ifndef CONFIG_XEN
 	BLANK();
 	DEFINE(TSS_ist, offsetof(struct tss_struct, ist));
+#endif
 	return 0;
 }
Index: head-2006-03-02/arch/x86_64/kernel/init_task.c
===================================================================
--- head-2006-03-02.orig/arch/x86_64/kernel/init_task.c	2006-03-02 13:27:46.000000000 +0100
+++ head-2006-03-02/arch/x86_64/kernel/init_task.c	2006-02-24 12:37:58.000000000 +0100
@@ -37,6 +37,8 @@ union thread_union init_thread_union 
 struct task_struct init_task = INIT_TASK(init_task);
 
 EXPORT_SYMBOL(init_task);
+
+#ifndef CONFIG_XEN
 /*
  * per-CPU TSS segments. Threads are completely 'soft' on Linux,
  * no more per-task TSS's. The TSS size is kept cacheline-aligned
@@ -45,5 +47,6 @@ EXPORT_SYMBOL(init_task);
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */ 
 DEFINE_PER_CPU(struct tss_struct, init_tss) ____cacheline_internodealigned_in_smp = INIT_TSS;
+#endif
 
 #define ALIGN_TO_4K __attribute__((section(".data.init_task")))
Index: head-2006-03-02/arch/x86_64/kernel/process-xen.c
===================================================================
--- head-2006-03-02.orig/arch/x86_64/kernel/process-xen.c	2006-03-02 13:27:46.000000000 +0100
+++ head-2006-03-02/arch/x86_64/kernel/process-xen.c	2006-02-24 12:37:58.000000000 +0100
@@ -289,16 +289,26 @@ void exit_thread(void)
 	kprobe_flush_task(me);
 
 	if (me->thread.io_bitmap_ptr) { 
+#ifndef CONFIG_XEN
 		struct tss_struct *tss = &per_cpu(init_tss, get_cpu());
+#else
+		static physdev_op_t iobmp_op = {
+			.cmd = PHYSDEVOP_SET_IOBITMAP
+		};
+#endif
 
 		kfree(t->io_bitmap_ptr);
 		t->io_bitmap_ptr = NULL;
+#ifndef CONFIG_XEN
 		/*
 		 * Careful, clear this in the TSS too:
 		 */
 		memset(tss->io_bitmap, 0xff, t->io_bitmap_max);
-		t->io_bitmap_max = 0;
 		put_cpu();
+#else
+		HYPERVISOR_physdev_op(&iobmp_op);
+#endif
+		t->io_bitmap_max = 0;
 	}
 }
 
@@ -463,7 +473,6 @@ __switch_to(struct task_struct *prev_p, 
 	struct thread_struct *prev = &prev_p->thread,
 				 *next = &next_p->thread;
 	int cpu = smp_processor_id();  
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
 	physdev_op_t iopl_op, iobmp_op;
 	multicall_entry_t _mcl[8], *mcl = _mcl;
 
@@ -482,10 +491,9 @@ __switch_to(struct task_struct *prev_p, 
 	/*
 	 * Reload esp0, LDT and the page table pointer:
 	 */
-	tss->rsp0 = next->rsp0;
 	mcl->op      = __HYPERVISOR_stack_switch;
 	mcl->args[0] = __KERNEL_DS;
-	mcl->args[1] = tss->rsp0;
+	mcl->args[1] = next->rsp0;
 	mcl++;
 
 	/*
Index: head-2006-03-02/arch/x86_64/kernel/setup64-xen.c
===================================================================
--- head-2006-03-02.orig/arch/x86_64/kernel/setup64-xen.c	2006-03-02 13:27:46.000000000 +0100
+++ head-2006-03-02/arch/x86_64/kernel/setup64-xen.c	2006-02-24 12:37:58.000000000 +0100
@@ -203,8 +203,10 @@ void pda_init(int cpu)
 	pda->irqstackptr += IRQSTACKSIZE-64;
 } 
 
+#ifndef CONFIG_XEN
 char boot_exception_stacks[(N_EXCEPTION_STACKS - 1) * EXCEPTION_STKSZ + DEBUG_STKSZ]
 __attribute__((section(".bss.page_aligned")));
+#endif
 
 /* May not be marked __init: used by software suspend */
 void syscall_init(void)
@@ -246,18 +248,23 @@ void __cpuinit check_efer(void)
 void __cpuinit cpu_init (void)
 {
 	int cpu = stack_smp_processor_id();
+#ifndef CONFIG_XEN
 	struct tss_struct *t = &per_cpu(init_tss, cpu);
 	unsigned long v; 
 	char *estacks = NULL; 
+	unsigned i;
+#endif
 	struct task_struct *me;
-	int i;
 
 	/* CPU 0 is initialised in head64.c */
 	if (cpu != 0) {
 		pda_init(cpu);
 		zap_low_mappings(cpu);
-	} else 
+	}
+#ifndef CONFIG_XEN
+	else
 		estacks = boot_exception_stacks; 
+#endif
 
 	me = current;
 
@@ -294,6 +301,7 @@ void __cpuinit cpu_init (void)
 
 	check_efer();
 
+#ifndef CONFIG_XEN
 	/*
 	 * set up and load the per-CPU TSS
 	 */
@@ -330,6 +338,7 @@ void __cpuinit cpu_init (void)
 	 */
 	for (i = 0; i <= IO_BITMAP_LONGS; i++)
 		t->io_bitmap[i] = ~0UL;
+#endif
 
 	atomic_inc(&init_mm.mm_count);
 	me->active_mm = &init_mm;
Index: head-2006-03-02/arch/x86_64/kernel/traps-xen.c
===================================================================
--- head-2006-03-02.orig/arch/x86_64/kernel/traps-xen.c	2006-03-02 13:27:46.000000000 +0100
+++ head-2006-03-02/arch/x86_64/kernel/traps-xen.c	2006-02-24 12:37:58.000000000 +0100
@@ -134,6 +134,7 @@ int printk_address(unsigned long address
 static unsigned long *in_exception_stack(unsigned cpu, unsigned long stack,
 					unsigned *usedp, const char **idp)
 {
+#ifndef CONFIG_XEN
 	static char ids[][8] = {
 		[DEBUG_STACK - 1] = "#DB",
 		[NMI_STACK - 1] = "NMI",
@@ -185,6 +186,7 @@ static unsigned long *in_exception_stack
 		}
 #endif
 	}
+#endif
 	return NULL;
 }
 
Index: head-2006-03-02/drivers/xen/core/smpboot.c
===================================================================
--- head-2006-03-02.orig/drivers/xen/core/smpboot.c	2006-03-02 13:29:38.000000000 +0100
+++ head-2006-03-02/drivers/xen/core/smpboot.c	2006-03-02 13:29:55.000000000 +0100
@@ -263,7 +263,6 @@ void __init smp_prepare_cpus(unsigned in
 #ifdef __x86_64__
 		cpu_pda(cpu)->pcurrent = idle;
 		cpu_pda(cpu)->cpunumber = cpu;
-		per_cpu(init_tss,cpu).rsp0 = idle->thread.rsp;
 		clear_ti_thread_flag(idle->thread_info, TIF_FORK);
 #endif
 
Index: head-2006-03-02/include/asm-x86_64/mach-xen/asm/desc.h
===================================================================
--- head-2006-03-02.orig/include/asm-x86_64/mach-xen/asm/desc.h	2006-03-02 13:27:46.000000000 +0100
+++ head-2006-03-02/include/asm-x86_64/mach-xen/asm/desc.h	2006-02-24 12:37:58.000000000 +0100
@@ -152,20 +152,6 @@ static inline void set_tssldt_descriptor
 	memcpy(ptr, &d, 16); 
 }
 
-static inline void set_tss_desc(unsigned cpu, void *addr)
-{ 
-	/*
-	 * sizeof(unsigned long) coming from an extra "long" at the end
-	 * of the iobitmap. See tss_struct definition in processor.h
-	 *
-	 * -1? seg base+limit should be pointing to the address of the
-	 * last valid byte
-	 */
-        set_tssldt_descriptor(&cpu_gdt(cpu)[GDT_ENTRY_TSS], 
-		(unsigned long)addr, DESC_TSS,
-		IO_BITMAP_OFFSET + IO_BITMAP_BYTES + sizeof(unsigned long) - 1);
-} 
-
 static inline void set_ldt_desc(unsigned cpu, void *addr, int size)
 { 
 	set_tssldt_descriptor(&cpu_gdt(cpu)[GDT_ENTRY_LDT], (unsigned long)addr,
Index: head-2006-03-02/include/asm-x86_64/mach-xen/asm/processor.h
===================================================================
--- head-2006-03-02.orig/include/asm-x86_64/mach-xen/asm/processor.h	2006-03-02 13:27:46.000000000 +0100
+++ head-2006-03-02/include/asm-x86_64/mach-xen/asm/processor.h	2006-02-24 12:37:58.000000000 +0100
@@ -198,7 +198,6 @@ static inline void clear_in_cr4 (unsigne
 #define IO_BITMAP_BITS  65536
 #define IO_BITMAP_BYTES (IO_BITMAP_BITS/8)
 #define IO_BITMAP_LONGS (IO_BITMAP_BYTES/sizeof(long))
-#define IO_BITMAP_OFFSET offsetof(struct tss_struct,io_bitmap)
 #define INVALID_IO_BITMAP_OFFSET 0x8000
 
 struct i387_fxsave_struct {
@@ -219,31 +218,7 @@ union i387_union {
 	struct i387_fxsave_struct	fxsave;
 };
 
-struct tss_struct {
-	u32 reserved1;
-	u64 rsp0;	
-	u64 rsp1;
-	u64 rsp2;
-	u64 reserved2;
-	u64 ist[7];
-	u32 reserved3;
-	u32 reserved4;
-	u16 reserved5;
-	u16 io_bitmap_base;
-	/*
-	 * The extra 1 is there because the CPU will access an
-	 * additional byte beyond the end of the IO permission
-	 * bitmap. The extra byte must be all 1 bits, and must
-	 * be within the limit. Thus we have:
-	 *
-	 * 128 bytes, the bitmap itself, for ports 0..0x3ff
-	 * 8 bytes, for an extra "long" of ~0UL
-	 */
-	unsigned long io_bitmap[IO_BITMAP_LONGS + 1];
-} __attribute__((packed)) ____cacheline_aligned;
-
 extern struct cpuinfo_x86 boot_cpu_data;
-DECLARE_PER_CPU(struct tss_struct,init_tss);
 
 #ifdef CONFIG_X86_VSMP
 #define ARCH_MIN_TASKALIGN	(1 << INTERNODE_CACHE_SHIFT)
@@ -285,10 +260,6 @@ struct thread_struct {
 	.rsp0 = (unsigned long)&init_stack + sizeof(init_stack) \
 }
 
-#define INIT_TSS  { \
-	.rsp0 = (unsigned long)&init_stack + sizeof(init_stack) \
-}
-
 #define INIT_MMAP \
 { &init_mm, 0, 0, NULL, PAGE_SHARED, VM_READ | VM_WRITE | VM_EXEC, 1, NULL, NULL }
 
