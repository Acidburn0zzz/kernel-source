Subject: Update Xen-specific files for 2.6.15-git8
From: jbeulich@novell.com

Index: head-2006-02-07/arch/i386/xen/boot/Makefile
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/boot/Makefile	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/boot/Makefile	2006-02-08 12:54:18.000000000 +0100
@@ -8,7 +8,7 @@ vmlinux-stripped: vmlinux FORCE
 	$(call if_changed,objcopy)
 
 XINSTALL_NAME ?= $(KERNELRELEASE)
-install: vmlinuz
+install:
 	mkdir -p $(INSTALL_PATH)/boot
 	ln -f -s vmlinuz-$(XINSTALL_NAME)$(INSTALL_SUFFIX) $(INSTALL_PATH)/boot/vmlinuz-$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(XENGUEST)$(INSTALL_SUFFIX)
 	rm -f $(INSTALL_PATH)/boot/vmlinuz-$(XINSTALL_NAME)$(INSTALL_SUFFIX)
Index: head-2006-02-07/arch/i386/xen/kernel/Makefile
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/Makefile	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/Makefile	2006-01-19 14:23:36.000000000 +0100
@@ -11,7 +11,7 @@ obj-y	:= process.o entry.o traps.o \
 		time.o ioport.o ldt.o setup.o \
 		pci-dma.o irq.o quirks.o fixup.o
 
-c-obj-y	:= semaphore.o signal.o vm86.o \
+c-obj-y	:= semaphore.o signal.o \
 		ptrace.o sys_i386.o \
 		i386_ksyms.o i387.o dmi_scan.o bootflag.o
 s-obj-y	:=
@@ -33,6 +33,7 @@ c-obj-$(CONFIG_X86_LOCAL_APIC)	+= nmi.o
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o
 c-obj-$(CONFIG_X86_REBOOTFIXUPS)	+= reboot_fixups.o
 c-obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o crash.o
+c-obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
 c-obj-$(CONFIG_X86_NUMAQ)	+= numaq.o
 c-obj-$(CONFIG_X86_SUMMIT_NUMA)	+= summit.o
 c-obj-$(CONFIG_MODULES)		+= module.o
@@ -41,6 +42,7 @@ obj-y				+= vsyscall.o
 c-obj-$(CONFIG_ACPI_SRAT) 	+= srat.o
 c-obj-$(CONFIG_HPET_TIMER) 	+= time_hpet.o
 c-obj-$(CONFIG_EFI) 		+= efi.o efi_stub.o
+c-obj-$(CONFIG_VM86)		+= vm86.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 c-obj-$(CONFIG_SMP_ALTERNATIVES)+= smpalts.o
 obj-$(CONFIG_SWIOTLB)		+= swiotlb.o
Index: head-2006-02-07/arch/i386/xen/kernel/acpi/boot.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/acpi/boot.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/acpi/boot.c	2006-02-08 12:54:25.000000000 +0100
@@ -113,7 +113,7 @@ char *__acpi_map_table(unsigned long phy
 	if (!phys_addr || !size)
 		return NULL;
 
-	if (phys_addr < (end_pfn_map << PAGE_SHIFT))
+	if (phys_addr+size <= (end_pfn_map << PAGE_SHIFT) + PAGE_SIZE)
 		return __va(phys_addr);
 
 	return NULL;
Index: head-2006-02-07/arch/i386/xen/kernel/cpu/common.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/cpu/common.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/cpu/common.c	2006-02-08 12:54:21.000000000 +0100
@@ -20,9 +20,6 @@
 #include "cpu.h"
 
 #ifndef CONFIG_XEN
-DEFINE_PER_CPU(struct desc_struct, cpu_gdt_table[GDT_ENTRIES]);
-EXPORT_PER_CPU_SYMBOL(cpu_gdt_table);
-
 DEFINE_PER_CPU(unsigned char, cpu_16bit_stack[CPU_16BIT_STACK_SIZE]);
 EXPORT_PER_CPU_SYMBOL(cpu_16bit_stack);
 #endif
@@ -212,7 +209,10 @@ static int __devinit have_cpuid_p(void)
 
 /* Do minimum CPU detection early.
    Fields really needed: vendor, cpuid_level, family, model, mask, cache alignment.
-   The others are not touched to avoid unwanted side effects. */
+   The others are not touched to avoid unwanted side effects.
+
+   WARNING: this function is only called on the BP.  Don't add code here
+   that is supposed to run on all CPUs. */
 static void __init early_cpu_detect(void)
 {
 	struct cpuinfo_x86 *c = &boot_cpu_data;
@@ -244,12 +244,6 @@ static void __init early_cpu_detect(void
 		if (cap0 & (1<<19))
 			c->x86_cache_alignment = ((misc >> 8) & 0xff) * 8;
 	}
-
-	early_intel_workaround(c);
-
-#ifdef CONFIG_X86_HT
-	phys_proc_id[smp_processor_id()] = (cpuid_ebx(1) >> 24) & 0xff;
-#endif
 }
 
 void __devinit generic_identify(struct cpuinfo_x86 * c)
@@ -297,6 +291,12 @@ void __devinit generic_identify(struct c
 				get_model_name(c); /* Default name */
 		}
 	}
+
+	early_intel_workaround(c);
+
+#ifdef CONFIG_X86_HT
+	phys_proc_id[smp_processor_id()] = (cpuid_ebx(1) >> 24) & 0xff;
+#endif
 }
 
 static void __devinit squash_the_stupid_serial_number(struct cpuinfo_x86 *c)
@@ -606,11 +606,6 @@ void __cpuinit cpu_init(void)
 	cpu_gdt_init(&cpu_gdt_descr[cpu]);
 
 	/*
-	 * Delete NT
-	 */
-	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
-
-	/*
 	 * Set up and load the per-CPU TSS and LDT
 	 */
 	atomic_inc(&init_mm.mm_count);
Index: head-2006-02-07/arch/i386/xen/kernel/entry.S
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/entry.S	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/entry.S	2006-02-08 12:54:19.000000000 +0100
@@ -392,6 +392,7 @@ work_notifysig:				# deal with pending s
 
 	ALIGN
 work_notifysig_v86:
+#ifdef CONFIG_VM86
 	pushl %ecx			# save ti_flags for do_notify_resume
 	call save_v86_state		# %eax contains pt_regs pointer
 	popl %ecx
@@ -399,6 +400,7 @@ work_notifysig_v86:
 	xorl %edx, %edx
 	call do_notify_resume
 	jmp resume_userspace
+#endif
 
 	# perform syscall exit tracing
 	ALIGN
@@ -833,6 +835,7 @@ ENTRY(fixup_4gb_segment)
 	pushl $do_fixup_4gb_segment
 	jmp error_code
 
+.section .rodata,"a"
 #include "syscall_table.S"
 
 syscall_table_size=(.-sys_call_table)
Index: head-2006-02-07/arch/i386/xen/kernel/head.S
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/head.S	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/head.S	2006-02-08 12:54:20.000000000 +0100
@@ -160,7 +160,11 @@ ENTRY(cpu_gdt_table)
 	.quad 0x0000000000000000	/* 0x80 TSS descriptor */
 	.quad 0x0000000000000000	/* 0x88 LDT descriptor */
 
-	/* Segments used for calling PnP BIOS */
+	/*
+	 * Segments used for calling PnP BIOS have byte granularity.
+	 * They code segments and data segments have fixed 64k limits,
+	 * the transfer segment sizes are set at run time.
+	 */
 	.quad 0x0000000000000000	/* 0x90 32-bit code */
 	.quad 0x0000000000000000	/* 0x98 16-bit code */
 	.quad 0x0000000000000000	/* 0xa0 16-bit data */
@@ -168,7 +172,7 @@ ENTRY(cpu_gdt_table)
 	.quad 0x0000000000000000	/* 0xb0 16-bit data */
 	/*
 	 * The APM segments have byte granularity and their bases
-	 * and limits are set at run time.
+	 * are set at run time.  All have 64k limits.
 	 */
 	.quad 0x0000000000000000	/* 0xb8 APM CS    code */
 	.quad 0x0000000000000000	/* 0xc0 APM CS 16 code (16 bit) */
@@ -180,10 +184,13 @@ ENTRY(cpu_gdt_table)
 	.quad 0x0000000000000000	/* 0xe8 - unused */
 	.quad 0x0000000000000000	/* 0xf0 - unused */
 	.quad 0x0000000000000000	/* 0xf8 - GDT entry 31: double-fault TSS */
-	.fill GDT_ENTRIES-32,8,0
+	/* Be sure this is zeroed to avoid false validations in Xen */
+	.fill PAGE_SIZE_asm / 8 - GDT_ENTRIES,8,0
 
 .org 0x3000
 ENTRY(default_ldt)
+	/* Be sure this is zeroed to avoid false validations in Xen */
+	.fill PAGE_SIZE_asm / 8,8,0
 
 .org 0x4000
 /*
Index: head-2006-02-07/arch/i386/xen/kernel/init_task.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/init_task.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/init_task.c	2006-02-08 12:54:19.000000000 +0100
@@ -45,5 +45,5 @@ EXPORT_SYMBOL(init_task);
  * per-CPU TSS segments. Threads are completely 'soft' on Linux,
  * no more per-task TSS's.
  */ 
-DEFINE_PER_CPU(struct tss_struct, init_tss) ____cacheline_maxaligned_in_smp = INIT_TSS;
+DEFINE_PER_CPU(struct tss_struct, init_tss) ____cacheline_internodealigned_in_smp = INIT_TSS;
 
Index: head-2006-02-07/arch/i386/xen/kernel/io_apic.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/io_apic.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/io_apic.c	2006-01-19 09:25:47.000000000 +0100
@@ -1701,7 +1701,7 @@ static void __init enable_IO_APIC(void)
 	for(apic = 0; apic < nr_ioapics; apic++) {
 		int pin;
 		/* See if any of the pins is in ExtINT mode */
-		for(pin = 0; pin < nr_ioapic_registers[i]; pin++) {
+		for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
 			struct IO_APIC_route_entry entry;
 			spin_lock_irqsave(&ioapic_lock, flags);
 			*(((int *)&entry) + 0) = io_apic_read(apic, 0x10 + 2 * pin);
@@ -1775,8 +1775,8 @@ void disable_IO_APIC(void)
 		entry.dest_mode       = 0; /* Physical */
 		entry.delivery_mode   = dest_ExtINT; /* ExtInt */
 		entry.vector          = 0;
-		entry.dest.physical.physical_dest = 0;
-
+		entry.dest.physical.physical_dest =
+					GET_APIC_ID(apic_read(APIC_ID));
 
 		/*
 		 * Add it to the IO-APIC irq-routing table:
Index: head-2006-02-07/arch/i386/xen/kernel/ioport.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/ioport.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/ioport.c	2006-01-19 09:25:47.000000000 +0100
@@ -7,6 +7,7 @@
 
 #include <linux/sched.h>
 #include <linux/kernel.h>
+#include <linux/capability.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/ioport.h>
Index: head-2006-02-07/arch/i386/xen/kernel/irq.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/irq.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/irq.c	2006-01-19 09:25:47.000000000 +0100
@@ -19,7 +19,7 @@
 #include <linux/cpu.h>
 #include <linux/delay.h>
 
-DEFINE_PER_CPU(irq_cpustat_t, irq_stat) ____cacheline_maxaligned_in_smp;
+DEFINE_PER_CPU(irq_cpustat_t, irq_stat) ____cacheline_internodealigned_in_smp;
 EXPORT_PER_CPU_SYMBOL(irq_stat);
 
 #ifndef CONFIG_X86_LOCAL_APIC
Index: head-2006-02-07/arch/i386/xen/kernel/microcode.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/microcode.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/microcode.c	2006-01-19 09:25:47.000000000 +0100
@@ -21,6 +21,7 @@
  */
 
 //#define DEBUG /* pr_debug */
+#include <linux/capability.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/sched.h>
Index: head-2006-02-07/arch/i386/xen/kernel/mpparse.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/mpparse.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/mpparse.c	2006-02-08 12:54:25.000000000 +0100
@@ -38,6 +38,12 @@
 int smp_found_config;
 unsigned int __initdata maxcpus = NR_CPUS;
 
+#ifdef CONFIG_HOTPLUG_CPU
+#define CPU_HOTPLUG_ENABLED	(1)
+#else
+#define CPU_HOTPLUG_ENABLED	(0)
+#endif
+
 /*
  * Various Linux-internal data structures created from the
  * MP-table.
@@ -220,14 +226,18 @@ static void __devinit MP_processor_info 
 	cpu_set(num_processors, cpu_possible_map);
 	num_processors++;
 
-	if ((num_processors > 8) &&
-	    ((APIC_XAPIC(ver) &&
-	     (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)) ||
-	     (boot_cpu_data.x86_vendor == X86_VENDOR_AMD)))
-		def_to_bigsmp = 1;
-	else
-		def_to_bigsmp = 0;
-
+	if (CPU_HOTPLUG_ENABLED || (num_processors > 8)) {
+		switch (boot_cpu_data.x86_vendor) {
+		case X86_VENDOR_INTEL:
+			if (!APIC_XAPIC(ver)) {
+				def_to_bigsmp = 0;
+				break;
+			}
+			/* If P4 and above fall through */
+		case X86_VENDOR_AMD:
+			def_to_bigsmp = 1;
+		}
+	}
 	bios_cpu_apicid[num_processors - 1] = m->mpc_apicid;
 }
 #else
Index: head-2006-02-07/arch/i386/xen/kernel/process.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/process.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/process.c	2006-02-08 12:54:29.000000000 +0100
@@ -48,6 +48,7 @@
 #include <asm/processor.h>
 #include <asm/i387.h>
 #include <asm/desc.h>
+#include <asm/vm86.h>
 #include <asm-xen/xen-public/physdev.h>
 #include <asm-xen/xen-public/vcpu.h>
 #ifdef CONFIG_MATH_EMULATION
@@ -300,17 +301,7 @@ void flush_thread(void)
 
 void release_thread(struct task_struct *dead_task)
 {
-	if (dead_task->mm) {
-		// temporary debugging check
-		if (dead_task->mm->context.size) {
-			printk("WARNING: dead process %8s still has LDT? <%p/%d>\n",
-					dead_task->comm,
-					dead_task->mm->context.ldt,
-					dead_task->mm->context.size);
-			BUG();
-		}
-	}
-
+	BUG_ON(dead_task->mm);
 	release_vm86_irqs(dead_task);
 }
 
Index: head-2006-02-07/arch/i386/xen/kernel/setup.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/setup.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/setup.c	2006-02-08 12:54:20.000000000 +0100
@@ -48,6 +48,7 @@
 #include <linux/notifier.h>
 #include <linux/kexec.h>
 #include <linux/crash_dump.h>
+#include <linux/dmi.h>
 
 #include <video/edid.h>
 
@@ -155,7 +156,6 @@ EXPORT_SYMBOL(ist_info);
 struct e820map e820;
 
 extern void early_cpu_init(void);
-extern void dmi_scan_machine(void);
 extern void generic_apic_probe(char *);
 extern int root_mountflags;
 
@@ -940,7 +940,7 @@ static void __init parse_cmdline_early (
 			}
 		}
 #endif
-#ifdef CONFIG_CRASH_DUMP
+#ifdef CONFIG_PROC_VMCORE
 		/* elfcorehdr= specifies the location of elf core header
 		 * stored by the crashed kernel.
 		 */
@@ -997,6 +997,12 @@ efi_find_max_pfn(unsigned long start, un
 	return 0;
 }
 
+static int __init
+efi_memory_present_wrapper(unsigned long start, unsigned long end, void *arg)
+{
+	memory_present(0, start, end);
+	return 0;
+}
 
 /*
  * Find the highest page frame number we have available
@@ -1008,6 +1014,7 @@ void __init find_max_pfn(void)
 	max_pfn = 0;
 	if (efi_enabled) {
 		efi_memmap_walk(efi_find_max_pfn, &max_pfn);
+		efi_memmap_walk(efi_memory_present_wrapper, NULL);
 		return;
 	}
 
@@ -1022,6 +1029,7 @@ void __init find_max_pfn(void)
 			continue;
 		if (end > max_pfn)
 			max_pfn = end;
+		memory_present(0, start, end);
 	}
 }
 #else
@@ -1786,7 +1794,7 @@ void __init setup_arch(char **cmdline_p)
 		if (s) {
 			extern void setup_early_printk(char *);
 
-			setup_early_printk(s);
+			setup_early_printk(strchr(s, '=') + 1);
 			printk("early console enabled\n");
 		}
 	}
Index: head-2006-02-07/arch/i386/xen/kernel/traps.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/traps.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/traps.c	2006-02-08 12:54:28.000000000 +0100
@@ -117,7 +117,7 @@ static inline unsigned long print_contex
 #ifdef	CONFIG_FRAME_POINTER
 	while (valid_stack_ptr(tinfo, (void *)ebp)) {
 		addr = *(unsigned long *)(ebp + 4);
-		printk(" [<%08lx>] ", addr);
+		printk(KERN_EMERG " [<%08lx>] ", addr);
 		print_symbol("%s", addr);
 		printk("\n");
 		ebp = *(unsigned long *)ebp;
@@ -126,7 +126,7 @@ static inline unsigned long print_contex
 	while (valid_stack_ptr(tinfo, stack)) {
 		addr = *stack++;
 		if (__kernel_text_address(addr)) {
-			printk(" [<%08lx>]", addr);
+			printk(KERN_EMERG " [<%08lx>]", addr);
 			print_symbol(" %s", addr);
 			printk("\n");
 		}
@@ -158,7 +158,7 @@ void show_trace(struct task_struct *task
 		stack = (unsigned long*)context->previous_esp;
 		if (!stack)
 			break;
-		printk(" =======================\n");
+		printk(KERN_EMERG " =======================\n");
 	}
 }
 
@@ -175,14 +175,15 @@ void show_stack(struct task_struct *task
 	}
 
 	stack = esp;
+	printk(KERN_EMERG);
 	for(i = 0; i < kstack_depth_to_print; i++) {
 		if (kstack_end(stack))
 			break;
 		if (i && ((i % 8) == 0))
-			printk("\n       ");
+			printk("\n" KERN_EMERG "       ");
 		printk("%08lx ", *stack++);
 	}
-	printk("\nCall Trace:\n");
+	printk("\n" KERN_EMERG "Call Trace:\n");
 	show_trace(task, esp);
 }
 
@@ -213,18 +214,18 @@ void show_registers(struct pt_regs *regs
 		ss = regs->xss & 0xffff;
 	}
 	print_modules();
-	printk("CPU:    %d\nEIP:    %04x:[<%08lx>]    %s VLI\nEFLAGS: %08lx"
-			"   (%s) \n",
+	printk(KERN_EMERG "CPU:    %d\nEIP:    %04x:[<%08lx>]    %s VLI\n"
+			"EFLAGS: %08lx   (%s) \n",
 		smp_processor_id(), 0xffff & regs->xcs, regs->eip,
 		print_tainted(), regs->eflags, system_utsname.release);
-	print_symbol("EIP is at %s\n", regs->eip);
-	printk("eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
+	print_symbol(KERN_EMERG "EIP is at %s\n", regs->eip);
+	printk(KERN_EMERG "eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
 		regs->eax, regs->ebx, regs->ecx, regs->edx);
-	printk("esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
+	printk(KERN_EMERG "esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
 		regs->esi, regs->edi, regs->ebp, esp);
-	printk("ds: %04x   es: %04x   ss: %04x\n",
+	printk(KERN_EMERG "ds: %04x   es: %04x   ss: %04x\n",
 		regs->xds & 0xffff, regs->xes & 0xffff, ss);
-	printk("Process %s (pid: %d, threadinfo=%p task=%p)",
+	printk(KERN_EMERG "Process %s (pid: %d, threadinfo=%p task=%p)",
 		current->comm, current->pid, current_thread_info(), current);
 	/*
 	 * When in-kernel, we also print out the stack and code at the
@@ -233,10 +234,10 @@ void show_registers(struct pt_regs *regs
 	if (in_kernel) {
 		u8 __user *eip;
 
-		printk("\nStack: ");
+		printk("\n" KERN_EMERG "Stack: ");
 		show_stack(NULL, (unsigned long*)esp);
 
-		printk("Code: ");
+		printk(KERN_EMERG "Code: ");
 
 		eip = (u8 __user *)regs->eip - 43;
 		for (i = 0; i < 64; i++, eip++) {
@@ -277,15 +278,15 @@ static void handle_BUG(struct pt_regs *r
 		(unsigned long)file < PAGE_OFFSET || __get_user(c, file))
 		file = "<bad filename>";
 
-	printk("------------[ cut here ]------------\n");
-	printk(KERN_ALERT "kernel BUG at %s:%d!\n", file, line);
+	printk(KERN_EMERG "------------[ cut here ]------------\n");
+	printk(KERN_EMERG "kernel BUG at %s:%d!\n", file, line);
 
 no_bug:
 	return;
 
 	/* Here we know it was a BUG but file-n-line is unavailable */
 bug:
-	printk("Kernel BUG\n");
+	printk(KERN_EMERG "Kernel BUG\n");
 }
 
 /* This is gone through when something in the kernel
@@ -303,28 +304,35 @@ void die(const char * str, struct pt_reg
 		.lock_owner_depth =	0
 	};
 	static int die_counter;
+	unsigned long flags;
 
 	if (die.lock_owner != raw_smp_processor_id()) {
 		console_verbose();
-		spin_lock_irq(&die.lock);
+		spin_lock_irqsave(&die.lock, flags);
 		die.lock_owner = smp_processor_id();
 		die.lock_owner_depth = 0;
 		bust_spinlocks(1);
 	}
+	else
+		local_save_flags(flags);
 
 	if (++die.lock_owner_depth < 3) {
 		int nl = 0;
 		handle_BUG(regs);
-		printk(KERN_ALERT "%s: %04lx [#%d]\n", str, err & 0xffff, ++die_counter);
+		printk(KERN_EMERG "%s: %04lx [#%d]\n", str, err & 0xffff, ++die_counter);
 #ifdef CONFIG_PREEMPT
-		printk("PREEMPT ");
+		printk(KERN_EMERG "PREEMPT ");
 		nl = 1;
 #endif
 #ifdef CONFIG_SMP
+		if (!nl)
+			printk(KERN_EMERG);
 		printk("SMP ");
 		nl = 1;
 #endif
 #ifdef CONFIG_DEBUG_PAGEALLOC
+		if (!nl)
+			printk(KERN_EMERG);
 		printk("DEBUG_PAGEALLOC");
 		nl = 1;
 #endif
@@ -333,11 +341,11 @@ void die(const char * str, struct pt_reg
 	notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
 		show_registers(regs);
   	} else
-		printk(KERN_ERR "Recursive die() failure, output suppressed\n");
+		printk(KERN_EMERG "Recursive die() failure, output suppressed\n");
 
 	bust_spinlocks(0);
 	die.lock_owner = -1;
-	spin_unlock_irq(&die.lock);
+	spin_unlock_irqrestore(&die.lock, flags);
 
 	if (kexec_should_crash(current))
 		crash_kexec(regs);
@@ -449,8 +457,7 @@ DO_VM86_ERROR( 3, SIGTRAP, "int3", int3)
 #endif
 DO_VM86_ERROR( 4, SIGSEGV, "overflow", overflow)
 DO_VM86_ERROR( 5, SIGSEGV, "bounds", bounds)
-DO_ERROR_INFO( 6, SIGILL,  "invalid operand", invalid_op, ILL_ILLOPN, regs->eip)
-DO_VM86_ERROR( 7, SIGSEGV, "device not available", device_not_available)
+DO_ERROR_INFO( 6, SIGILL,  "invalid opcode", invalid_op, ILL_ILLOPN, regs->eip)
 DO_ERROR( 9, SIGFPE,  "coprocessor segment overrun", coprocessor_segment_overrun)
 DO_ERROR(10, SIGSEGV, "invalid TSS", invalid_TSS)
 DO_ERROR(11, SIGBUS,  "segment not present", segment_not_present)
@@ -508,8 +515,10 @@ gp_in_kernel:
 
 static void mem_parity_error(unsigned char reason, struct pt_regs * regs)
 {
-	printk("Uhhuh. NMI received. Dazed and confused, but trying to continue\n");
-	printk("You probably have a hardware problem with your RAM chips\n");
+	printk(KERN_EMERG "Uhhuh. NMI received. Dazed and confused, but trying "
+			"to continue\n");
+	printk(KERN_EMERG "You probably have a hardware problem with your RAM "
+			"chips\n");
 
 	/* Clear and disable the memory parity error line. */
 	clear_mem_error(reason);
@@ -519,7 +528,7 @@ static void io_check_error(unsigned char
 {
 	unsigned long i;
 
-	printk("NMI: IOCK error (debug interrupt?)\n");
+	printk(KERN_EMERG "NMI: IOCK error (debug interrupt?)\n");
 	show_registers(regs);
 
 	/* Re-enable the IOCK line, wait for a few seconds */
@@ -561,11 +570,11 @@ void die_nmi (struct pt_regs *regs, cons
 	* to get a message out.
 	*/
 	bust_spinlocks(1);
-	printk(msg);
+	printk(KERN_EMERG "%s", msg);
 	printk(" on CPU%d, eip %08lx, registers:\n",
 		smp_processor_id(), regs->eip);
 	show_registers(regs);
-	printk("console shuts up ...\n");
+	printk(KERN_EMERG "console shuts up ...\n");
 	console_silent();
 	spin_unlock(&nmi_print_lock);
 	bust_spinlocks(0);
@@ -977,8 +986,8 @@ asmlinkage void math_state_restore(struc
 
 asmlinkage void math_emulate(long arg)
 {
-	printk("math-emulation not enabled and no coprocessor found.\n");
-	printk("killing %s.\n",current->comm);
+	printk(KERN_EMERG "math-emulation not enabled and no coprocessor found.\n");
+	printk(KERN_EMERG "killing %s.\n",current->comm);
 	force_sig(SIGFPE,current);
 	schedule();
 }
@@ -1009,7 +1018,7 @@ static trap_info_t trap_table[] = {
 	{  1, 0|4, __KERNEL_CS, (unsigned long)debug			},
 	{  3, 3|4, __KERNEL_CS, (unsigned long)int3			},
 	{  4, 3, __KERNEL_CS, (unsigned long)overflow			},
-	{  5, 3, __KERNEL_CS, (unsigned long)bounds			},
+	{  5, 0, __KERNEL_CS, (unsigned long)bounds			},
 	{  6, 0, __KERNEL_CS, (unsigned long)invalid_op			},
 	{  7, 0|4, __KERNEL_CS, (unsigned long)device_not_available	},
 	{  9, 0, __KERNEL_CS, (unsigned long)coprocessor_segment_overrun },
Index: head-2006-02-07/arch/i386/xen/mm/init.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/mm/init.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/mm/init.c	2006-02-08 12:54:28.000000000 +0100
@@ -818,6 +818,30 @@ void free_initmem(void)
 	printk (KERN_INFO "Freeing unused kernel memory: %dk freed\n", (__init_end - __init_begin) >> 10);
 }
 
+#ifdef CONFIG_DEBUG_RODATA
+
+extern char __start_rodata, __end_rodata;
+void mark_rodata_ro(void)
+{
+	unsigned long addr = (unsigned long)&__start_rodata;
+
+	for (; addr < (unsigned long)&__end_rodata; addr += PAGE_SIZE)
+		change_page_attr(virt_to_page(addr), 1, PAGE_KERNEL_RO);
+
+	printk ("Write protecting the kernel read-only data: %luk\n",
+			(unsigned long)(&__end_rodata - &__start_rodata) >> 10);
+
+	/*
+	 * change_page_attr() requires a global_flush_tlb() call after it.
+	 * We do this after the printk so that if something went wrong in the
+	 * change, the printk gets out at least to give a better debug hint
+	 * of who is the culprit.
+	 */
+	global_flush_tlb();
+}
+#endif
+
+
 #ifdef CONFIG_BLK_DEV_INITRD
 void free_initrd_mem(unsigned long start, unsigned long end)
 {
Index: head-2006-02-07/arch/i386/xen/pci/irq.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/pci/irq.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/pci/irq.c	2006-02-08 12:54:25.000000000 +0100
@@ -78,7 +78,7 @@ static inline struct irq_routing_table *
 	for (i=0; i < rt->size; i++)
 		sum += addr[i];
 	if (!sum) {
-		DBG("PCI: Interrupt Routing Table found at 0x%p\n", rt);
+		DBG(KERN_DEBUG "PCI: Interrupt Routing Table found at 0x%p\n", rt);
 		return rt;
 	}
 	return NULL;
@@ -131,7 +131,7 @@ static void __init pirq_peer_trick(void)
 #ifdef DEBUG
 		{
 			int j;
-			DBG("%02x:%02x slot=%02x", e->bus, e->devfn/8, e->slot);
+			DBG(KERN_DEBUG "%02x:%02x slot=%02x", e->bus, e->devfn/8, e->slot);
 			for(j=0; j<4; j++)
 				DBG(" %d:%02x/%04x", j, e->irq[j].link, e->irq[j].bitmap);
 			DBG("\n");
@@ -163,10 +163,10 @@ void eisa_set_level_irq(unsigned int irq
 		return;
 
 	eisa_irq_mask |= (1 << irq);
-	printk("PCI: setting IRQ %u as level-triggered\n", irq);
+	printk(KERN_DEBUG "PCI: setting IRQ %u as level-triggered\n", irq);
 	val = inb(port);
 	if (!(val & mask)) {
-		DBG(" -> edge");
+		DBG(KERN_DEBUG " -> edge");
 		outb(val | mask, port);
 	}
 }
@@ -680,11 +680,11 @@ static __init int ali_router_probe(struc
 	{
 	case PCI_DEVICE_ID_AL_M1533:
 	case PCI_DEVICE_ID_AL_M1563:
-		printk("PCI: Using ALI IRQ Router\n");
-			r->name = "ALI";
-			r->get = pirq_ali_get;
-			r->set = pirq_ali_set;
-			return 1;
+		printk(KERN_DEBUG "PCI: Using ALI IRQ Router\n");
+		r->name = "ALI";
+		r->get = pirq_ali_get;
+		r->set = pirq_ali_set;
+		return 1;
 	}
 	return 0;
 }
@@ -752,12 +752,13 @@ static void __init pirq_find_router(stru
 	r->get = NULL;
 	r->set = NULL;
 	
-	DBG("PCI: Attempting to find IRQ router for %04x:%04x\n",
+	DBG(KERN_DEBUG "PCI: Attempting to find IRQ router for %04x:%04x\n",
 	    rt->rtr_vendor, rt->rtr_device);
 
 	pirq_router_dev = pci_find_slot(rt->rtr_bus, rt->rtr_devfn);
 	if (!pirq_router_dev) {
-		DBG("PCI: Interrupt router not found at %02x:%02x\n", rt->rtr_bus, rt->rtr_devfn);
+		DBG(KERN_DEBUG "PCI: Interrupt router not found at "
+			"%02x:%02x\n", rt->rtr_bus, rt->rtr_devfn);
 		return;
 	}
 
@@ -802,7 +803,7 @@ static int pcibios_lookup_irq(struct pci
 	/* Find IRQ pin */
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
 	if (!pin) {
-		DBG(" -> no interrupt pin\n");
+		DBG(KERN_DEBUG " -> no interrupt pin\n");
 		return 0;
 	}
 	pin = pin - 1;
@@ -812,16 +813,16 @@ static int pcibios_lookup_irq(struct pci
 	if (!pirq_table)
 		return 0;
 	
-	DBG("IRQ for %s[%c]", pci_name(dev), 'A' + pin);
+	DBG(KERN_DEBUG "IRQ for %s[%c]", pci_name(dev), 'A' + pin);
 	info = pirq_get_info(dev);
 	if (!info) {
-		DBG(" -> not found in routing table\n");
+		DBG(" -> not found in routing table\n" KERN_DEBUG);
 		return 0;
 	}
 	pirq = info->irq[pin].link;
 	mask = info->irq[pin].bitmap;
 	if (!pirq) {
-		DBG(" -> not routed\n");
+		DBG(" -> not routed\n" KERN_DEBUG);
 		return 0;
 	}
 	DBG(" -> PIRQ %02x, mask %04x, excl %04x", pirq, mask, pirq_table->exclusive_irqs);
@@ -849,9 +850,12 @@ static int pcibios_lookup_irq(struct pci
 	 * reported by the device if possible.
 	 */
 	newirq = dev->irq;
-	if (!((1 << newirq) & mask)) {
+	if (newirq && !((1 << newirq) & mask)) {
 		if ( pci_probe & PCI_USE_PIRQ_MASK) newirq = 0;
-		else printk(KERN_WARNING "PCI: IRQ %i for device %s doesn't match PIRQ mask - try pci=usepirqmask\n", newirq, pci_name(dev));
+		else printk("\n" KERN_WARNING
+			"PCI: IRQ %i for device %s doesn't match PIRQ mask "
+			"- try pci=usepirqmask\n" KERN_DEBUG, newirq,
+			pci_name(dev));
 	}
 	if (!newirq && assign) {
 		for (i = 0; i < 16; i++) {
@@ -926,14 +930,14 @@ static void __init pcibios_fixup_irqs(vo
 	struct pci_dev *dev = NULL;
 	u8 pin;
 
-	DBG("PCI: IRQ fixup\n");
+	DBG(KERN_DEBUG "PCI: IRQ fixup\n");
 	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
 		/*
 		 * If the BIOS has set an out of range IRQ number, just ignore it.
 		 * Also keep track of which IRQ's are already in use.
 		 */
 		if (dev->irq >= 16) {
-			DBG("%s: ignoring bogus IRQ %d\n", pci_name(dev), dev->irq);
+			DBG(KERN_DEBUG "%s: ignoring bogus IRQ %d\n", pci_name(dev), dev->irq);
 			dev->irq = 0;
 		}
 		/* If the IRQ is already assigned to a PCI device, ignore its ISA use penalty */
@@ -1042,7 +1046,7 @@ static struct dmi_system_id __initdata p
 
 static int __init pcibios_irq_init(void)
 {
-	DBG("PCI: IRQ init\n");
+	DBG(KERN_DEBUG "PCI: IRQ init\n");
 
 	if (pcibios_enable_irq || raw_pci_ops == NULL)
 		return 0;
Index: head-2006-02-07/arch/x86_64/xen/boot/Makefile
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/boot/Makefile	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/boot/Makefile	2006-02-08 12:54:18.000000000 +0100
@@ -8,7 +8,7 @@ vmlinux-stripped: vmlinux FORCE
 	$(call if_changed,objcopy)
 
 XINSTALL_NAME ?= $(KERNELRELEASE)
-install: vmlinuz
+install:
 	mkdir -p $(INSTALL_PATH)/boot
 	ln -f -s vmlinuz-$(XINSTALL_NAME)$(INSTALL_SUFFIX) $(INSTALL_PATH)/boot/vmlinuz-$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(XENGUEST)$(INSTALL_SUFFIX)
 	rm -f $(INSTALL_PATH)/boot/vmlinuz-$(XINSTALL_NAME)$(INSTALL_SUFFIX)
Index: head-2006-02-07/arch/x86_64/xen/ia32/Makefile
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/ia32/Makefile	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/ia32/Makefile	2006-02-08 12:54:28.000000000 +0100
@@ -5,8 +5,7 @@ CFLAGS	+= -Iarch/x86_64/kernel
 
 obj-$(CONFIG_IA32_EMULATION) := ia32entry.o syscall32.o syscall32_syscall.o
 
-c-obj-$(CONFIG_IA32_EMULATION) := sys_ia32.o ia32_ioctl.o \
-	ia32_signal.o tls32.o \
+c-obj-$(CONFIG_IA32_EMULATION) := sys_ia32.o ia32_signal.o tls32.o \
 	ia32_binfmt.o fpu32.o ptrace32.o 
 
 s-obj-y :=
@@ -42,7 +41,6 @@ $(obj)/vsyscall-%.so: $(obj)/vsyscall.ld
 AFLAGS_vsyscall-int80.o = -m32 -I$(obj) -Iarch/i386/kernel
 AFLAGS_vsyscall-sysenter.o = -m32 -I$(obj) -Iarch/i386/kernel
 AFLAGS_vsyscall-syscall.o = -m32 -I$(obj) -Iarch/i386/kernel
-CFLAGS_ia32_ioctl.o += -Ifs/
 CFLAGS_syscall32.o += -DUSE_INT80
 AFLAGS_syscall32_syscall.o += -DUSE_INT80
 
Index: head-2006-02-07/arch/x86_64/xen/ia32/ia32entry.S
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/ia32/ia32entry.S	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/ia32/ia32entry.S	2006-02-08 12:54:26.000000000 +0100
@@ -37,6 +37,18 @@
 	movq	%rax,R8(%rsp)
 	.endm
 
+	.macro CFI_STARTPROC32 simple
+	CFI_STARTPROC	\simple
+	CFI_UNDEFINED	r8
+	CFI_UNDEFINED	r9
+	CFI_UNDEFINED	r10
+	CFI_UNDEFINED	r11
+	CFI_UNDEFINED	r12
+	CFI_UNDEFINED	r13
+	CFI_UNDEFINED	r14
+	CFI_UNDEFINED	r15
+	.endm
+
 #if defined (__XEN_X86_64)
 #include "../kernel/xen_entry.S"
 		
@@ -72,7 +84,7 @@
  * with the int 0x80 path.
  */ 	
 ENTRY(ia32_sysenter_target)
-	CFI_STARTPROC	simple
+	CFI_STARTPROC32	simple
 	CFI_DEF_CFA	rsp,0
 	CFI_REGISTER	rsp,rbp
 	__swapgs 
@@ -110,6 +122,7 @@ ENTRY(ia32_sysenter_target)
  	.quad 1b,ia32_badarg
  	.previous	
 	GET_THREAD_INFO(%r10)
+	orl    $TS_COMPAT,threadinfo_status(%r10)
 	testl  $(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_SECCOMP),threadinfo_flags(%r10)
 	CFI_REMEMBER_STATE
 	jnz  sysenter_tracesys
@@ -124,6 +137,7 @@ sysenter_do_call:	
 	__cli
 	testl	$_TIF_ALLWORK_MASK,threadinfo_flags(%r10)
 	jnz	int_ret_from_sys_call
+	andl    $~TS_COMPAT,threadinfo_status(%r10)
 	/* clear IF, that popfq doesn't enable interrupts early */
 	andl  $~0x200,EFLAGS-R11(%rsp) 
 	RESTORE_ARGS 1,24,1,1,1,1
@@ -181,7 +195,7 @@ sysenter_tracesys:
  * with the int 0x80 path.	
  */ 	
 ENTRY(ia32_cstar_target)
-	CFI_STARTPROC	simple
+	CFI_STARTPROC32	simple
 	CFI_DEF_CFA	rsp,0
 	CFI_REGISTER	rip,rcx
 	/*CFI_REGISTER	rflags,r11*/
@@ -212,6 +226,7 @@ ENTRY(ia32_cstar_target)
 	.quad 1b,ia32_badarg
 	.previous	
 	GET_THREAD_INFO(%r10)
+	orl   $TS_COMPAT,threadinfo_status(%r10)
 	testl $(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_SECCOMP),threadinfo_flags(%r10)
 	CFI_REMEMBER_STATE
 	jnz   cstar_tracesys
@@ -226,6 +241,7 @@ cstar_do_call:	
 	__cli
 	testl $_TIF_ALLWORK_MASK,threadinfo_flags(%r10)
 	jnz  int_ret_from_sys_call
+	andl $~TS_COMPAT,threadinfo_status(%r10)
 	RESTORE_ARGS 1,-ARG_SKIP,1,1,1
 	movl RIP-ARGOFFSET(%rsp),%ecx
 	CFI_REGISTER rip,rcx
@@ -303,6 +319,7 @@ ENTRY(ia32_syscall)
 	   this could be a problem. */
 	SAVE_ARGS 0,0,1
 	GET_THREAD_INFO(%r10)
+	orl   $TS_COMPAT,threadinfo_status(%r10)
 	testl $(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_SECCOMP),threadinfo_flags(%r10)
 	jnz ia32_tracesys
 ia32_do_syscall:	
@@ -345,7 +362,7 @@ quiet_ni_syscall:
 	jmp  ia32_ptregs_common	
 	.endm
 
-	CFI_STARTPROC
+	CFI_STARTPROC32
 
 	PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi
 	PTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi
@@ -360,15 +377,26 @@ quiet_ni_syscall:
 
 ENTRY(ia32_ptregs_common)
 	popq %r11
-	CFI_ADJUST_CFA_OFFSET -8
-	CFI_REGISTER rip, r11
+	CFI_ENDPROC
+	CFI_STARTPROC32	simple
+	CFI_DEF_CFA	rsp,SS+8-ARGOFFSET
+	CFI_REL_OFFSET	rax,RAX-ARGOFFSET
+	CFI_REL_OFFSET	rcx,RCX-ARGOFFSET
+	CFI_REL_OFFSET	rdx,RDX-ARGOFFSET
+	CFI_REL_OFFSET	rsi,RSI-ARGOFFSET
+	CFI_REL_OFFSET	rdi,RDI-ARGOFFSET
+	CFI_REL_OFFSET	rip,RIP-ARGOFFSET
+/*	CFI_REL_OFFSET	cs,CS-ARGOFFSET*/
+/*	CFI_REL_OFFSET	rflags,EFLAGS-ARGOFFSET*/
+	CFI_REL_OFFSET	rsp,RSP-ARGOFFSET
+/*	CFI_REL_OFFSET	ss,SS-ARGOFFSET*/
 	SAVE_REST
 	call *%rax
 	RESTORE_REST
 	jmp  ia32_sysret	/* misbalances the return cache */
 	CFI_ENDPROC
 
-	.data
+	.section .rodata,"a"
 	.align 8
 	.globl ia32_sys_call_table
 ia32_sys_call_table:
@@ -635,7 +663,7 @@ ia32_sys_call_table:
 	.quad sys_epoll_wait
 	.quad sys_remap_file_pages
 	.quad sys_set_tid_address
-	.quad sys32_timer_create
+	.quad compat_sys_timer_create
 	.quad compat_sys_timer_settime	/* 260 */
 	.quad compat_sys_timer_gettime
 	.quad sys_timer_getoverrun
@@ -670,6 +698,7 @@ ia32_sys_call_table:
 	.quad sys_inotify_init
 	.quad sys_inotify_add_watch
 	.quad sys_inotify_rm_watch
+	.quad sys_migrate_pages
 ia32_syscall_end:		
 	.rept IA32_NR_syscalls-(ia32_syscall_end-ia32_sys_call_table)/8
 		.quad ni_syscall
Index: head-2006-02-07/arch/x86_64/xen/ia32/vsyscall-int80.S
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/ia32/vsyscall-int80.S	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/ia32/vsyscall-int80.S	2006-01-19 09:25:48.000000000 +0100
@@ -9,6 +9,7 @@
 #include <asm/ia32_unistd.h>
 #include <asm/asm-offsets.h>
 
+	.code32
 	.text
 	.section .text.vsyscall,"ax"
 	.globl __kernel_vsyscall
Index: head-2006-02-07/arch/x86_64/xen/kernel/Makefile
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/Makefile	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/Makefile	2006-01-19 09:25:48.000000000 +0100
@@ -5,14 +5,15 @@ CFLAGS	+= -Iarch/x86_64/kernel
 
 extra-y 	:= head.o head64.o init_task.o ../../kernel/vmlinux.lds
 
-obj-y	:= process.o signal.o entry.o traps.o  \
+obj-y	:= process.o signal.o entry.o traps.o irq.o \
 		ioport.o ldt.o setup.o \
 		x8664_ksyms.o vsyscall.o \
-		setup64.o e820.o irq.o early_printk.o
+		setup64.o e820.o early_printk.o
 c-obj-y	:= i387.o sys_x86_64.o \
-		ptrace.o quirks.o syscall.o bootflag.o
+		ptrace.o quirks.o syscall.o bootflag.o \
+		dmi_scan.o pci-nommu.o
 
-i386-obj-y			:= time.o
+i386-obj-y			:= time.o pci-dma.o
 #obj-y				+= ../../i386/kernel/timers/
 
 s-obj-y	:=
@@ -32,16 +33,17 @@ obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o m
 obj-$(CONFIG_X86_XEN_GENAPIC)	+= genapic.o genapic_xen.o
 c-obj-$(CONFIG_X86_IO_APIC)	+= genapic_cluster.o genapic_flat.o
 c-obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o crash.o
+c-obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
 #obj-$(CONFIG_PM)		+= suspend.o
 #obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend_asm.o
 #obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 #obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 #obj-$(CONFIG_GART_IOMMU)	+= pci-gart.o aperture.o
-obj-$(CONFIG_DUMMY_IOMMU)	+= pci-nommu.o
-i386-obj-$(CONFIG_DUMMY_IOMMU)	+= pci-dma.o
 i386-obj-$(CONFIG_SWIOTLB)	+= swiotlb.o
+#obj-$(CONFIG_SWIOTLB)		+= pci-swiotlb.o
 c-obj-$(CONFIG_KPROBES)		+= kprobes.o
 #obj-$(CONFIG_X86_PM_TIMER)	+= pmtimer.o
+#obj-$(CONFIG_X86_VSMP)		+= vsmp.o
 
 c-obj-$(CONFIG_MODULES)		+= module.o
 
@@ -56,6 +58,7 @@ microcode-$(subst m,y,$(CONFIG_MICROCODE
 intel_cacheinfo-y		+= ../../../i386/kernel/cpu/intel_cacheinfo.o
 quirks-y			+= ../../../i386/xen/kernel/quirks.o
 msr-$(subst m,y,$(CONFIG_X86_MSR))  += ../../../i386/kernel/msr.o
+dmi_scan-y			+= ../../../i386/kernel/dmi_scan.o
 
 c-link	:= init_task.o
 s-link	:= vsyscall.o 
Index: head-2006-02-07/arch/x86_64/xen/kernel/apic.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/apic.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/apic.c	2006-02-08 12:54:21.000000000 +0100
@@ -25,6 +25,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/kernel_stat.h>
 #include <linux/sysdev.h>
+#include <linux/module.h>
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
@@ -33,6 +34,7 @@
 #include <asm/desc.h>
 #include <asm/arch_hooks.h>
 #include <asm/hpet.h>
+#include <asm/idle.h>
 
 #include "io_ports.h"
 
@@ -47,30 +49,7 @@ void smp_local_timer_interrupt(struct pt
 
 	profile_tick(CPU_PROFILING, regs);
 #ifndef CONFIG_XEN
-	int cpu = smp_processor_id();
-
-	if (--per_cpu(prof_counter, cpu) <= 0) {
-		/*
-		 * The multiplier may have changed since the last time we got
-		 * to this point as a result of the user writing to
-		 * /proc/profile. In this case we need to adjust the APIC
-		 * timer accordingly.
-		 *
-		 * Interrupts are already masked off at this point.
-		 */
-		per_cpu(prof_counter, cpu) = per_cpu(prof_multiplier, cpu);
-		if (per_cpu(prof_counter, cpu) != 
-		    per_cpu(prof_old_multiplier, cpu)) {
-			__setup_APIC_LVTT(calibration_result/
-					per_cpu(prof_counter, cpu));
-			per_cpu(prof_old_multiplier, cpu) =
-				per_cpu(prof_counter, cpu);
-		}
-
-#ifdef CONFIG_SMP
-		update_process_times(user_mode(regs));
-#endif
-	}
+	update_process_times(user_mode(regs));
 #endif
 
 	/*
@@ -110,6 +89,7 @@ void smp_apic_timer_interrupt(struct pt_
 	 * Besides, if we don't timer interrupts ignore the global
 	 * interrupt lock, which is the WrongThing (tm) to do.
 	 */
+	exit_idle();
 	irq_enter();
 	smp_local_timer_interrupt(regs);
 	irq_exit();
@@ -121,6 +101,7 @@ void smp_apic_timer_interrupt(struct pt_
 asmlinkage void smp_spurious_interrupt(void)
 {
 	unsigned int v;
+	exit_idle();
 	irq_enter();
 	/*
 	 * Check if this really is a spurious interrupt and ACK it
@@ -156,6 +137,7 @@ asmlinkage void smp_error_interrupt(void
 {
 	unsigned int v, v1;
 
+	exit_idle();
 	irq_enter();
 	/* First tickle the hardware, only then report what went on. -- REW */
 	v = apic_read(APIC_ESR);
Index: head-2006-02-07/arch/x86_64/xen/kernel/e820.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/e820.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/e820.c	2006-01-19 09:25:48.000000000 +0100
@@ -660,6 +660,29 @@ void __init parse_memopt(char *p, char *
         xen_override_max_pfn = (unsigned long) end_user_pfn;
 } 
 
+#ifndef CONFIG_XEN
+void __init parse_memmapopt(char *p, char **from)
+{
+	unsigned long long start_at, mem_size;
+
+	mem_size = memparse(p, from);
+	p = *from;
+	if (*p == '@') {
+		start_at = memparse(p+1, from);
+		add_memory_region(start_at, mem_size, E820_RAM);
+	} else if (*p == '#') {
+		start_at = memparse(p+1, from);
+		add_memory_region(start_at, mem_size, E820_ACPI);
+	} else if (*p == '$') {
+		start_at = memparse(p+1, from);
+		add_memory_region(start_at, mem_size, E820_RESERVED);
+	} else {
+		end_user_pfn = (mem_size >> PAGE_SHIFT);
+	}
+	p = *from;
+}
+#endif
+
 /*
  * Search for the biggest gap in the low 32 bits of the e820
  * memory space.  We pass this space to PCI to assign MMIO resources
Index: head-2006-02-07/arch/x86_64/xen/kernel/early_printk.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/early_printk.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/early_printk.c	2006-01-19 09:25:48.000000000 +0100
@@ -251,7 +251,7 @@ void early_printk(const char *fmt, ...)
 	va_end(ap); 
 } 
 
-static int keep_early; 
+static int __initdata keep_early;
 
 int __init setup_early_printk(char *opt) 
 {  
@@ -261,8 +261,6 @@ int __init setup_early_printk(char *opt)
 	if (early_console_initialized)
 		return -1;
 
-	opt = strchr(opt, '=') + 1;
-
 	strlcpy(buf,opt,sizeof(buf)); 
 	space = strchr(buf, ' '); 
 	if (space)
Index: head-2006-02-07/arch/x86_64/xen/kernel/entry.S
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/entry.S	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/entry.S	2006-02-08 12:54:28.000000000 +0100
@@ -339,6 +339,7 @@ int_with_check:
 	movl threadinfo_flags(%rcx),%edx
 	andl %edi,%edx
 	jnz   int_careful
+	andl    $~TS_COMPAT,threadinfo_status(%rcx)
 	jmp   retint_restore_args
 
 	/* Either reschedule or signal or syscall exit tracking needed. */
@@ -688,7 +689,10 @@ ENTRY(spurious_interrupt)
 #if 0
 	/* error code is on the stack already */
 	/* handle NMI like exceptions that can happen everywhere */
-	.macro paranoidentry sym
+#ifndef DEBUG_IST
+# define DEBUG_IST 0
+#endif
+	.macro paranoidentry sym, ist=0
         movq (%rsp),%rcx
         movq 8(%rsp),%r11
         addq $0x10,%rsp /* skip rcx and r11 */        
@@ -701,10 +705,20 @@ ENTRY(spurious_interrupt)
 	js    1f
 /*	swapgs */
 	xorl  %ebx,%ebx
-1:	movq %rsp,%rdi
+1:
+	.if \ist
+	movq	%gs:pda_data_offset, %rbp
+	.endif
+	movq %rsp,%rdi
 	movq ORIG_RAX(%rsp),%rsi
 	movq $-1,ORIG_RAX(%rsp)
+	.if \ist
+	subq	$EXCEPTION_STACK_SIZE, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
+	.endif
 	call \sym
+	.if \ist
+	addq	$EXCEPTION_STACK_SIZE, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
+	.endif
 	cli
 	.endm
 #endif
@@ -1114,24 +1128,18 @@ ENTRY(machine_check)
 	CFI_ENDPROC
 #endif
 
-ENTRY(call_debug)
-       zeroentry do_call_debug
-
-
 ENTRY(call_softirq)
 	CFI_STARTPROC
 	movq %gs:pda_irqstackptr,%rax
-	pushq %r15
-	CFI_ADJUST_CFA_OFFSET 8
-	movq %rsp,%r15
-	CFI_DEF_CFA_REGISTER	r15
+	movq %rsp,%rdx
+	CFI_DEF_CFA_REGISTER	rdx
 	incl %gs:pda_irqcount
 	cmove %rax,%rsp
+	pushq %rdx
+	/*todo CFI_DEF_CFA_EXPRESSION ...*/
 	call __do_softirq
-	movq %r15,%rsp
+	popq %rsp
 	CFI_DEF_CFA_REGISTER	rsp
 	decl %gs:pda_irqcount
-	popq %r15
-	CFI_ADJUST_CFA_OFFSET -8
 	ret
 	CFI_ENDPROC
Index: head-2006-02-07/arch/x86_64/xen/kernel/head.S
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/head.S	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/head.S	2006-02-08 12:54:28.000000000 +0100
@@ -187,31 +187,6 @@ ENTRY(level3_user_pgt)
         .fill	512,8,0
 
 .org 0x7000
-ENTRY(cpu_gdt_table)
-/* The TLS descriptors are currently at a different place compared to i386.
-   Hopefully nobody expects them at a fixed place (Wine?) */
-	.quad	0x0000000000000000	/* NULL descriptor */
-	.quad	0x008ffa000000ffff	/* __KERNEL_COMPAT32_CS */	
-	.quad	0x00affa000000ffff	/* __KERNEL_CS */
-	.quad	0x00cff2000000ffff	/* __KERNEL_DS */
-	
-       	.quad	0x00cffa000000ffff	/* __USER32_CS */
-	.quad	0x00cff2000000ffff	/* __USER_DS, __USER32_DS  */		
-	.quad	0x00affa000000ffff	/* __USER_CS */
-	.quad	0x00cffa000000ffff	/* __KERNEL32_CS */        
-	.quad	0,0			/* TSS */
-	.quad	0,0			/* LDT */
-	.quad   0,0,0			/* three TLS descriptors */ 
-	.quad	0			/* unused now?   __KERNEL16_CS - 16bit PM for S3 wakeup. */
-
-gdt_end:
-#if 0
-	/* asm/segment.h:GDT_ENTRIES must match this */	
-	/* This should be a multiple of the cache line size */
-	/* GDTs of other CPUs: */	
-	.fill (GDT_SIZE * NR_CPUS) - (gdt_end - cpu_gdt_table)
-#endif
-
 .org 0x8000
 ENTRY(empty_zero_page)
 
@@ -280,10 +255,33 @@ gdt:
  * Also sysret mandates a special GDT layout 
  */
 		 		
-#if 0        		 		
-.align L1_CACHE_BYTES
-#endif
-	.align  L1_CACHE_BYTES
+.align PAGE_SIZE
+
+/* The TLS descriptors are currently at a different place compared to i386.
+   Hopefully nobody expects them at a fixed place (Wine?) */
+
+ENTRY(cpu_gdt_table)
+	.quad	0x0000000000000000	/* NULL descriptor */
+	.quad	0x0			/* unused */
+	.quad	0x00affa000000ffff	/* __KERNEL_CS */
+	.quad	0x00cff2000000ffff	/* __KERNEL_DS */
+       	.quad	0x00cffa000000ffff	/* __USER32_CS */
+	.quad	0x00cff2000000ffff	/* __USER_DS, __USER32_DS  */
+	.quad	0x00affa000000ffff	/* __USER_CS */
+	.quad	0x00cffa000000ffff	/* __KERNEL32_CS */
+	.quad	0,0			/* TSS */
+	.quad	0,0			/* LDT */
+	.quad   0,0,0			/* three TLS descriptors */
+	.quad	0			/* unused */
+
+gdt_end:
+	/* asm/segment.h:GDT_ENTRIES must match this */
+	/* This should be a multiple of the cache line size */
+	/* GDTs of other CPUs are now dynamically allocated */
+
+	/* zero the remaining page */
+	.fill PAGE_SIZE / 8 - GDT_ENTRIES,8,0
+
 ENTRY(idt_table)	
 	.rept   256
 	.quad   0
Index: head-2006-02-07/arch/x86_64/xen/kernel/head64.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/head64.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/head64.c	2006-01-19 09:25:48.000000000 +0100
@@ -45,27 +45,16 @@ static void __init clear_bss(void)
 
 extern char saved_command_line[];
 
-#if 0
-static void __init copy_bootdata(char *real_mode_data)
+static void __init copy_bootdata(struct start_info *start_info)
 {
-	int new_data;
-	char * command_line;
+	int max_cmdline;
 
-	memcpy(x86_boot_params, real_mode_data, BOOT_PARAM_SIZE);
-	new_data = *(int *) (x86_boot_params + NEW_CL_POINTER);
-	if (!new_data) {
-		if (OLD_CL_MAGIC != * (u16 *) OLD_CL_MAGIC_ADDR) {
-			printk("so old bootloader that it does not support commandline?!\n");
-			return;
-		}
-		new_data = OLD_CL_BASE_ADDR + * (u16 *) OLD_CL_OFFSET;
-		printk("old bootloader convention, maybe loadlin?\n");
-	}
-	command_line = (char *) ((u64)(new_data));
-	memcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
+	if ((max_cmdline = MAX_GUEST_CMDLINE) > COMMAND_LINE_SIZE)
+		max_cmdline = COMMAND_LINE_SIZE;
+	memcpy(saved_command_line, start_info->cmd_line, max_cmdline);
+	saved_command_line[max_cmdline-1] = '\0';
 	printk("Bootdata ok (command line is %s)\n", saved_command_line);	
 }
-#endif
 
 static void __init setup_boot_cpu_data(void)
 {
@@ -88,6 +77,7 @@ static void __init setup_boot_cpu_data(v
 void __init x86_64_start_kernel(char * real_mode_data)
 {
 	int i;
+	char *s;
 
         phys_to_machine_mapping = (unsigned long *)xen_start_info->mfn_list;
         start_pfn = (__pa(xen_start_info->pt_base) >> PAGE_SHIFT) + 
@@ -98,16 +88,17 @@ void __init x86_64_start_kernel(char * r
 #if 0
 	asm volatile("lidt %0" :: "m" (idt_descr));
 #endif
+ 	for (i = 0; i < NR_CPUS; i++)
+ 		cpu_pda(i) = &boot_cpu_pda[i];
+
 	pda_init(0);
-        /*	copy_bootdata(real_mode_data); */
+	copy_bootdata(xen_start_info);
 #ifdef CONFIG_SMP
 	cpu_set(0, cpu_online_map);
 #endif
-#if 0
 	s = strstr(saved_command_line, "earlyprintk=");
 	if (s != NULL)
-		setup_early_printk(s);
-#endif
+		setup_early_printk(strchr(s, '=') + 1);
 
 #ifdef CONFIG_NUMA
 	s = strstr(saved_command_line, "numa=");
Index: head-2006-02-07/arch/x86_64/xen/kernel/io_apic.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/io_apic.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/io_apic.c	2006-02-08 12:54:25.000000000 +0100
@@ -37,6 +37,7 @@
 #include <asm/proto.h>
 #include <asm/mach_apic.h>
 #include <asm/acpi.h>
+#include <asm/dma.h>
 
 #define __apicdebuginit  __init
 
@@ -46,6 +47,11 @@ static int no_timer_check;
 
 int disable_timer_pin_1 __initdata;
 
+#ifndef CONFIG_XEN
+/* Where if anywhere is the i8259 connect in external int mode */
+static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
+#endif
+
 static DEFINE_SPINLOCK(ioapic_lock);
 
 /*
@@ -310,9 +316,6 @@ __setup("apic", enable_ioapic_setup);
 void __init check_ioapic(void) 
 { 
 	int num,slot,func; 
-	if (ioapic_force) 
-		return; 
-
 	/* Poor man's PCI discovery */
 	for (num = 0; num < 32; num++) { 
 		for (slot = 0; slot < 32; slot++) { 
@@ -334,7 +337,7 @@ void __init check_ioapic(void) 
 				switch (vendor) { 
 				case PCI_VENDOR_ID_VIA:
 #ifdef CONFIG_GART_IOMMU
-					if ((end_pfn >= (0xffffffff>>PAGE_SHIFT) ||
+					if ((end_pfn > MAX_DMA32_PFN ||
 					     force_iommu) &&
 					    !iommu_aperture_allowed) {
 						printk(KERN_INFO
@@ -414,7 +417,7 @@ static int find_irq_entry(int apic, int 
 /*
  * Find the pin to which IRQ[irq] (ISA) is connected
  */
-static int find_isa_irq_pin(int irq, int type)
+static int __init find_isa_irq_pin(int irq, int type)
 {
 	int i;
 
@@ -431,6 +434,31 @@ static int find_isa_irq_pin(int irq, int
 	}
 	return -1;
 }
+
+static int __init find_isa_irq_apic(int irq, int type)
+{
+	int i;
+
+	for (i = 0; i < mp_irq_entries; i++) {
+		int lbus = mp_irqs[i].mpc_srcbus;
+
+		if ((mp_bus_id_to_type[lbus] == MP_BUS_ISA ||
+		     mp_bus_id_to_type[lbus] == MP_BUS_EISA ||
+		     mp_bus_id_to_type[lbus] == MP_BUS_MCA) &&
+		    (mp_irqs[i].mpc_irqtype == type) &&
+		    (mp_irqs[i].mpc_srcbusirq == irq))
+			break;
+	}
+	if (i < mp_irq_entries) {
+		int apic;
+		for(apic = 0; apic < nr_ioapics; apic++) {
+			if (mp_ioapics[apic].mpc_apicid == mp_irqs[i].mpc_dstapic)
+				return apic;
+		}
+	}
+
+	return -1;
+}
 #endif
 
 /*
@@ -928,7 +956,7 @@ static void __init setup_IO_APIC_irqs(vo
  * Set up the 8259A-master output pin as broadcast to all
  * CPUs.
  */
-static void __init setup_ExtINT_IRQ0_pin(unsigned int pin, int vector)
+static void __init setup_ExtINT_IRQ0_pin(unsigned int apic, unsigned int pin, int vector)
 {
 	struct IO_APIC_route_entry entry;
 	unsigned long flags;
@@ -938,7 +966,7 @@ static void __init setup_ExtINT_IRQ0_pin
 	disable_8259A_irq(0);
 
 	/* mask LVT0 */
-	apic_write_around(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
+	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
 
 	/*
 	 * We use logical delivery to get the timer IRQ
@@ -962,8 +990,8 @@ static void __init setup_ExtINT_IRQ0_pin
 	 * Add it to the IO-APIC irq-routing table:
 	 */
 	spin_lock_irqsave(&ioapic_lock, flags);
-	io_apic_write(0, 0x11+2*pin, *(((int *)&entry)+1));
-	io_apic_write(0, 0x10+2*pin, *(((int *)&entry)+0));
+	io_apic_write(apic, 0x11+2*pin, *(((int *)&entry)+1));
+	io_apic_write(apic, 0x10+2*pin, *(((int *)&entry)+0));
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 
 	enable_8259A_irq(0);
@@ -1245,7 +1273,10 @@ void __init print_IO_APIC(void) { }
 static void __init enable_IO_APIC(void)
 {
 	union IO_APIC_reg_01 reg_01;
-	int i;
+#ifndef CONFIG_XEN
+	int i8259_apic, i8259_pin;
+#endif
+	int i, apic;
 	unsigned long flags;
 
 	for (i = 0; i < PIN_MAP_SIZE; i++) {
@@ -1259,12 +1290,51 @@ static void __init enable_IO_APIC(void)
 	/*
 	 * The number of IO-APIC IRQ registers (== #pins):
 	 */
-	for (i = 0; i < nr_ioapics; i++) {
+	for (apic = 0; apic < nr_ioapics; apic++) {
 		spin_lock_irqsave(&ioapic_lock, flags);
-		reg_01.raw = io_apic_read(i, 1);
+		reg_01.raw = io_apic_read(apic, 1);
 		spin_unlock_irqrestore(&ioapic_lock, flags);
-		nr_ioapic_registers[i] = reg_01.bits.entries+1;
+		nr_ioapic_registers[apic] = reg_01.bits.entries+1;
+	}
+#ifndef CONFIG_XEN
+	for(apic = 0; apic < nr_ioapics; apic++) {
+		int pin;
+		/* See if any of the pins is in ExtINT mode */
+		for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
+			struct IO_APIC_route_entry entry;
+			spin_lock_irqsave(&ioapic_lock, flags);
+			*(((int *)&entry) + 0) = io_apic_read(apic, 0x10 + 2 * pin);
+			*(((int *)&entry) + 1) = io_apic_read(apic, 0x11 + 2 * pin);
+			spin_unlock_irqrestore(&ioapic_lock, flags);
+
+
+			/* If the interrupt line is enabled and in ExtInt mode
+			 * I have found the pin where the i8259 is connected.
+			 */
+			if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
+				ioapic_i8259.apic = apic;
+				ioapic_i8259.pin  = pin;
+				goto found_i8259;
+			}
+		}
 	}
+ found_i8259:
+	/* Look to see what if the MP table has reported the ExtINT */
+	i8259_pin  = find_isa_irq_pin(0, mp_ExtINT);
+	i8259_apic = find_isa_irq_apic(0, mp_ExtINT);
+	/* Trust the MP table if nothing is setup in the hardware */
+	if ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {
+		printk(KERN_WARNING "ExtINT not setup in hardware but reported by MP table\n");
+		ioapic_i8259.pin  = i8259_pin;
+		ioapic_i8259.apic = i8259_apic;
+	}
+	/* Complain if the MP table and the hardware disagree */
+	if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &&
+		(i8259_pin >= 0) && (ioapic_i8259.pin >= 0))
+	{
+		printk(KERN_WARNING "ExtINT in hardware and MP table differ\n");
+	}
+#endif
 
 	/*
 	 * Do not trust the IO-APIC being empty at bootup
@@ -1277,9 +1347,6 @@ static void __init enable_IO_APIC(void)
  */
 void disable_IO_APIC(void)
 {
-#ifndef CONFIG_XEN
-	int pin;
-#endif
 	/*
 	 * Clear the IO-APIC before rebooting:
 	 */
@@ -1290,8 +1357,7 @@ void disable_IO_APIC(void)
 	 * Put that IOAPIC in virtual wire mode
 	 * so legacy interrupts can be delivered.
 	 */
-	pin = find_isa_irq_pin(0, mp_ExtINT);
-	if (pin != -1) {
+	if (ioapic_i8259.pin != -1) {
 		struct IO_APIC_route_entry entry;
 		unsigned long flags;
 
@@ -1302,21 +1368,24 @@ void disable_IO_APIC(void)
 		entry.polarity        = 0; /* High */
 		entry.delivery_status = 0;
 		entry.dest_mode       = 0; /* Physical */
-		entry.delivery_mode   = 7; /* ExtInt */
+		entry.delivery_mode   = dest_ExtINT; /* ExtInt */
 		entry.vector          = 0;
-		entry.dest.physical.physical_dest = 0;
+		entry.dest.physical.physical_dest =
+					GET_APIC_ID(apic_read(APIC_ID));
 
 
 		/*
 		 * Add it to the IO-APIC irq-routing table:
 		 */
 		spin_lock_irqsave(&ioapic_lock, flags);
-		io_apic_write(0, 0x11+2*pin, *(((int *)&entry)+1));
-		io_apic_write(0, 0x10+2*pin, *(((int *)&entry)+0));
+		io_apic_write(ioapic_i8259.apic, 0x11+2*ioapic_i8259.pin,
+			*(((int *)&entry)+1));
+		io_apic_write(ioapic_i8259.apic, 0x10+2*ioapic_i8259.pin,
+			*(((int *)&entry)+0));
 		spin_unlock_irqrestore(&ioapic_lock, flags);
 	}
 
-	disconnect_bsp_APIC(pin != -1);
+	disconnect_bsp_APIC(ioapic_i8259.pin != -1);
 #endif
 }
 
@@ -1639,7 +1708,7 @@ static void enable_lapic_irq (unsigned i
 	unsigned long v;
 
 	v = apic_read(APIC_LVT0);
-	apic_write_around(APIC_LVT0, v & ~APIC_LVT_MASKED);
+	apic_write(APIC_LVT0, v & ~APIC_LVT_MASKED);
 }
 
 static void disable_lapic_irq (unsigned int irq)
@@ -1647,7 +1716,7 @@ static void disable_lapic_irq (unsigned 
 	unsigned long v;
 
 	v = apic_read(APIC_LVT0);
-	apic_write_around(APIC_LVT0, v | APIC_LVT_MASKED);
+	apic_write(APIC_LVT0, v | APIC_LVT_MASKED);
 }
 
 static void ack_lapic_irq (unsigned int irq)
@@ -1694,20 +1763,21 @@ static void setup_nmi (void)
  */
 static inline void unlock_ExtINT_logic(void)
 {
-	int pin, i;
+	int apic, pin, i;
 	struct IO_APIC_route_entry entry0, entry1;
 	unsigned char save_control, save_freq_select;
 	unsigned long flags;
 
-	pin = find_isa_irq_pin(8, mp_INT);
+	pin  = find_isa_irq_pin(8, mp_INT);
+	apic = find_isa_irq_apic(8, mp_INT);
 	if (pin == -1)
 		return;
 
 	spin_lock_irqsave(&ioapic_lock, flags);
-	*(((int *)&entry0) + 1) = io_apic_read(0, 0x11 + 2 * pin);
-	*(((int *)&entry0) + 0) = io_apic_read(0, 0x10 + 2 * pin);
+	*(((int *)&entry0) + 1) = io_apic_read(apic, 0x11 + 2 * pin);
+	*(((int *)&entry0) + 0) = io_apic_read(apic, 0x10 + 2 * pin);
 	spin_unlock_irqrestore(&ioapic_lock, flags);
-	clear_IO_APIC_pin(0, pin);
+	clear_IO_APIC_pin(apic, pin);
 
 	memset(&entry1, 0, sizeof(entry1));
 
@@ -1720,8 +1790,8 @@ static inline void unlock_ExtINT_logic(v
 	entry1.vector = 0;
 
 	spin_lock_irqsave(&ioapic_lock, flags);
-	io_apic_write(0, 0x11 + 2 * pin, *(((int *)&entry1) + 1));
-	io_apic_write(0, 0x10 + 2 * pin, *(((int *)&entry1) + 0));
+	io_apic_write(apic, 0x11 + 2 * pin, *(((int *)&entry1) + 1));
+	io_apic_write(apic, 0x10 + 2 * pin, *(((int *)&entry1) + 0));
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 
 	save_control = CMOS_READ(RTC_CONTROL);
@@ -1739,11 +1809,11 @@ static inline void unlock_ExtINT_logic(v
 
 	CMOS_WRITE(save_control, RTC_CONTROL);
 	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
-	clear_IO_APIC_pin(0, pin);
+	clear_IO_APIC_pin(apic, pin);
 
 	spin_lock_irqsave(&ioapic_lock, flags);
-	io_apic_write(0, 0x11 + 2 * pin, *(((int *)&entry0) + 1));
-	io_apic_write(0, 0x10 + 2 * pin, *(((int *)&entry0) + 0));
+	io_apic_write(apic, 0x11 + 2 * pin, *(((int *)&entry0) + 1));
+	io_apic_write(apic, 0x10 + 2 * pin, *(((int *)&entry0) + 0));
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 }
 
@@ -1755,7 +1825,7 @@ static inline void unlock_ExtINT_logic(v
  */
 static inline void check_timer(void)
 {
-	int pin1, pin2;
+	int apic1, pin1, apic2, pin2;
 	int vector;
 
 	/*
@@ -1772,14 +1842,17 @@ static inline void check_timer(void)
 	 * the 8259A which implies the virtual wire has to be
 	 * disabled in the local APIC.
 	 */
-	apic_write_around(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
+	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
 	init_8259A(1);
 	enable_8259A_irq(0);
 
-	pin1 = find_isa_irq_pin(0, mp_INT);
-	pin2 = find_isa_irq_pin(0, mp_ExtINT);
+	pin1  = find_isa_irq_pin(0, mp_INT);
+	apic1 = find_isa_irq_apic(0, mp_INT);
+	pin2  = ioapic_i8259.pin;
+	apic2 = ioapic_i8259.apic;
 
-	apic_printk(APIC_VERBOSE,KERN_INFO "..TIMER: vector=0x%02X pin1=%d pin2=%d\n", vector, pin1, pin2);
+	apic_printk(APIC_VERBOSE,KERN_INFO "..TIMER: vector=0x%02X apic1=%d pin1=%d apic2=%d pin2=%d\n",
+		vector, apic1, pin1, apic2, pin2);
 
 	if (pin1 != -1) {
 		/*
@@ -1797,17 +1870,20 @@ static inline void check_timer(void)
 				clear_IO_APIC_pin(0, pin1);
 			return;
 		}
-		clear_IO_APIC_pin(0, pin1);
-		apic_printk(APIC_QUIET,KERN_ERR "..MP-BIOS bug: 8254 timer not connected to IO-APIC\n");
+		clear_IO_APIC_pin(apic1, pin1);
+		apic_printk(APIC_QUIET,KERN_ERR "..MP-BIOS bug: 8254 timer not "
+				"connected to IO-APIC\n");
 	}
 
-	apic_printk(APIC_VERBOSE,KERN_INFO "...trying to set up timer (IRQ0) through the 8259A ... ");
+	apic_printk(APIC_VERBOSE,KERN_INFO "...trying to set up timer (IRQ0) "
+				"through the 8259A ... ");
 	if (pin2 != -1) {
-		apic_printk(APIC_VERBOSE,"\n..... (found pin %d) ...", pin2);
+		apic_printk(APIC_VERBOSE,"\n..... (found apic %d pin %d) ...",
+			apic2, pin2);
 		/*
 		 * legacy devices should be connected to IO APIC #0
 		 */
-		setup_ExtINT_IRQ0_pin(pin2, vector);
+		setup_ExtINT_IRQ0_pin(apic2, pin2, vector);
 		if (timer_irq_works()) {
 			printk("works.\n");
 			nmi_watchdog_default();
@@ -1819,7 +1895,7 @@ static inline void check_timer(void)
 		/*
 		 * Cleanup, just in case ...
 		 */
-		clear_IO_APIC_pin(0, pin2);
+		clear_IO_APIC_pin(apic2, pin2);
 	}
 	printk(" failed.\n");
 
@@ -1832,21 +1908,21 @@ static inline void check_timer(void)
 
 	disable_8259A_irq(0);
 	irq_desc[0].handler = &lapic_irq_type;
-	apic_write_around(APIC_LVT0, APIC_DM_FIXED | vector);	/* Fixed mode */
+	apic_write(APIC_LVT0, APIC_DM_FIXED | vector);	/* Fixed mode */
 	enable_8259A_irq(0);
 
 	if (timer_irq_works()) {
 		apic_printk(APIC_QUIET, " works.\n");
 		return;
 	}
-	apic_write_around(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | vector);
+	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | vector);
 	apic_printk(APIC_VERBOSE," failed.\n");
 
 	apic_printk(APIC_VERBOSE, KERN_INFO "...trying to set up timer as ExtINT IRQ...");
 
 	init_8259A(0);
 	make_8259A_irq(0);
-	apic_write_around(APIC_LVT0, APIC_DM_EXTINT);
+	apic_write(APIC_LVT0, APIC_DM_EXTINT);
 
 	unlock_ExtINT_logic();
 
Index: head-2006-02-07/arch/x86_64/xen/kernel/ioport.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/ioport.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/ioport.c	2006-01-19 09:25:48.000000000 +0100
@@ -7,6 +7,7 @@
 
 #include <linux/sched.h>
 #include <linux/kernel.h>
+#include <linux/capability.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/ioport.h>
Index: head-2006-02-07/arch/x86_64/xen/kernel/irq.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/irq.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/irq.c	2006-01-19 09:25:48.000000000 +0100
@@ -11,6 +11,7 @@
  */
 #include <linux/delay.h>
 #include <asm/uaccess.h>
+#include <asm/idle.h>
 #include <linux/module.h>
 #include <linux/seq_file.h>
 #include <linux/interrupt.h>
@@ -72,13 +73,13 @@ skip:
 		seq_printf(p, "NMI: ");
 		for (j = 0; j < NR_CPUS; j++)
 			if (cpu_online(j))
-				seq_printf(p, "%10u ", cpu_pda[j].__nmi_count);
+				seq_printf(p, "%10u ", cpu_pda(j)->__nmi_count);
 		seq_putc(p, '\n');
 #ifdef CONFIG_X86_LOCAL_APIC
 		seq_printf(p, "LOC: ");
 		for (j = 0; j < NR_CPUS; j++)
 			if (cpu_online(j))
-				seq_printf(p, "%10u ", cpu_pda[j].apic_timer_irqs);
+				seq_printf(p, "%10u ", cpu_pda(j)->apic_timer_irqs);
 		seq_putc(p, '\n');
 #endif
 		seq_printf(p, "ERR: %10u\n", atomic_read(&irq_err_count));
@@ -101,6 +102,7 @@ asmlinkage unsigned int do_IRQ(struct pt
 	/* high bits used in ret_from_ code  */
         int irq = regs->orig_rax & __IRQ_MASK(HARDIRQ_BITS);
 
+	exit_idle();
 	irq_enter();
 
 	__do_IRQ(irq, regs);
Index: head-2006-02-07/arch/x86_64/xen/kernel/pci-nommu.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/pci-nommu.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/pci-nommu.c	2006-01-19 09:25:48.000000000 +0100
@@ -19,80 +19,8 @@ EXPORT_SYMBOL(iommu_bio_merge);
 int iommu_sac_force = 0;
 EXPORT_SYMBOL(iommu_sac_force);
 
-#if 0
-/* 
- * Dummy IO MMU functions
- */
-
-void *dma_alloc_coherent(struct device *hwdev, size_t size,
-			 dma_addr_t *dma_handle, gfp_t gfp)
-{
-	void *ret;
-	u64 mask;
-	int order = get_order(size);
-
-	if (hwdev)
-		mask = hwdev->coherent_dma_mask & *hwdev->dma_mask;
-	else
-		mask = 0xffffffff;
-	for (;;) {
-		ret = (void *)__get_free_pages(gfp, order);
-		if (ret == NULL)
-			return NULL;
-		*dma_handle = virt_to_bus(ret);
-		if ((*dma_handle & ~mask) == 0)
-			break;
-		free_pages((unsigned long)ret, order);
-		if (gfp & GFP_DMA)
-			return NULL;
-		gfp |= GFP_DMA;
-	}
-
-	memset(ret, 0, size);
-	return ret;
-}
-EXPORT_SYMBOL(dma_alloc_coherent);
-
-void dma_free_coherent(struct device *hwdev, size_t size,
-			 void *vaddr, dma_addr_t dma_handle)
-{
-	free_pages((unsigned long)vaddr, get_order(size));
-}
-EXPORT_SYMBOL(dma_free_coherent);
-#endif
-
-#if 0
-int dma_supported(struct device *hwdev, u64 mask)
-{
-        /*
-         * we fall back to GFP_DMA when the mask isn't all 1s,
-         * so we can't guarantee allocations that must be
-         * within a tighter range than GFP_DMA..
-	 * RED-PEN this won't work for pci_map_single. Caller has to
-	 * use GFP_DMA in the first place.
-         */
-        if (mask < 0x00ffffff)
-                return 0;
-
-	return 1;
-} 
-EXPORT_SYMBOL(dma_supported);
-#endif
-
 int dma_get_cache_alignment(void)
 {
 	return boot_cpu_data.x86_clflush_size;
 }
 EXPORT_SYMBOL(dma_get_cache_alignment);
-
-static int __init check_ram(void) 
-{ 
-	if (end_pfn >= 0xffffffff>>PAGE_SHIFT) { 
-		printk(
-		KERN_ERR "WARNING more than 4GB of memory but IOMMU not compiled in.\n"
-		KERN_ERR "WARNING 32bit PCI may malfunction.\n");
-	} 
-	return 0;
-} 
-__initcall(check_ram);
-
Index: head-2006-02-07/arch/x86_64/xen/kernel/process.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/process.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/process.c	2006-02-08 12:54:29.000000000 +0100
@@ -39,6 +39,7 @@
 #include <linux/utsname.h>
 #include <linux/random.h>
 #include <linux/kprobes.h>
+#include <linux/notifier.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -56,13 +57,12 @@
 #include <asm/proto.h>
 #include <asm/hardirq.h>
 #include <asm/ia32.h>
+#include <asm/idle.h>
 
 asmlinkage extern void ret_from_fork(void);
 
 unsigned long kernel_thread_flags = CLONE_VM | CLONE_UNTRACED;
 
-static atomic_t hlt_counter = ATOMIC_INIT(0);
-
 unsigned long boot_option_idle_override = 0;
 EXPORT_SYMBOL(boot_option_idle_override);
 
@@ -72,19 +72,49 @@ EXPORT_SYMBOL(boot_option_idle_override)
 void (*pm_idle)(void);
 static DEFINE_PER_CPU(unsigned int, cpu_idle_state);
 
-void disable_hlt(void)
+static struct notifier_block *idle_notifier;
+static DEFINE_SPINLOCK(idle_notifier_lock);
+
+void idle_notifier_register(struct notifier_block *n)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&idle_notifier_lock, flags);
+	notifier_chain_register(&idle_notifier, n);
+	spin_unlock_irqrestore(&idle_notifier_lock, flags);
+}
+EXPORT_SYMBOL_GPL(idle_notifier_register);
+
+void idle_notifier_unregister(struct notifier_block *n)
 {
-	atomic_inc(&hlt_counter);
+	unsigned long flags;
+	spin_lock_irqsave(&idle_notifier_lock, flags);
+	notifier_chain_unregister(&idle_notifier, n);
+	spin_unlock_irqrestore(&idle_notifier_lock, flags);
 }
+EXPORT_SYMBOL(idle_notifier_unregister);
 
-EXPORT_SYMBOL(disable_hlt);
+enum idle_state { CPU_IDLE, CPU_NOT_IDLE };
+static DEFINE_PER_CPU(enum idle_state, idle_state) = CPU_NOT_IDLE;
 
-void enable_hlt(void)
+void enter_idle(void)
 {
-	atomic_dec(&hlt_counter);
+	__get_cpu_var(idle_state) = CPU_IDLE;
+	notifier_call_chain(&idle_notifier, IDLE_START, NULL);
 }
 
-EXPORT_SYMBOL(enable_hlt);
+static void __exit_idle(void)
+{
+	__get_cpu_var(idle_state) = CPU_NOT_IDLE;
+	notifier_call_chain(&idle_notifier, IDLE_END, NULL);
+}
+
+/* Called from interrupts to signify idle end */
+void exit_idle(void)
+{
+	if (current->pid | read_pda(irqcount))
+		return;
+	__exit_idle();
+}
 
 /* XXX XEN doesn't use default_idle(), poll_idle(). Use xen_idle() instead. */
 extern void stop_hz_timer(void);
@@ -110,7 +140,7 @@ void xen_idle(void)
 DECLARE_PER_CPU(int, cpu_state);
 
 #include <asm/nmi.h>
-/* We don't actually take CPU down, just spin without interrupts. */
+/* We halt the CPU with physical CPU hotplug */
 static inline void play_dead(void)
 {
 	idle_task_exit();
@@ -158,7 +188,9 @@ void cpu_idle (void)
 			if (cpu_is_offline(smp_processor_id()))
 				play_dead();
 
+			enter_idle();
 			xen_idle();
+			__exit_idle();
 		}
 
 		preempt_enable_no_resched();
@@ -473,7 +505,7 @@ __switch_to(struct task_struct *prev_p, 
 	if (unlikely(next->tls_array[i] != prev->tls_array[i])) {	\
 		mcl->op      = __HYPERVISOR_update_descriptor;		\
 		mcl->args[0] = virt_to_machine(				\
-			&get_cpu_gdt_table(cpu)[GDT_ENTRY_TLS_MIN + i]);\
+			&cpu_gdt(cpu)[GDT_ENTRY_TLS_MIN + i]);		\
 		mcl->args[1] = next->tls_array[i];			\
 		mcl++;							\
 	}								\
Index: head-2006-02-07/arch/x86_64/xen/kernel/setup.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/setup.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/setup.c	2006-02-08 12:54:21.000000000 +0100
@@ -35,6 +35,7 @@
 #include <asm/processor.h>
 #include <linux/console.h>
 #include <linux/seq_file.h>
+#include <linux/crash_dump.h>
 #include <linux/root_dev.h>
 #include <linux/pci.h>
 #include <linux/acpi.h>
@@ -42,6 +43,9 @@
 #include <linux/edd.h>
 #include <linux/mmzone.h>
 #include <linux/kexec.h>
+#include <linux/cpufreq.h>
+#include <linux/dmi.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/mtrr.h>
 #include <asm/uaccess.h>
@@ -60,7 +64,9 @@
 #include <asm/setup.h>
 #include <asm/mach_apic.h>
 #include <asm/numa.h>
+#include <asm/swiotlb.h>
 #include <asm/sections.h>
+#include <asm/gart-mapping.h>
 #ifdef CONFIG_XEN
 #include <linux/percpu.h>
 #include <asm-xen/xen-public/physdev.h>
@@ -312,18 +318,8 @@ static __init void parse_cmdline_early (
 {
 	char c = ' ', *to = command_line, *from = COMMAND_LINE;
 	int len = 0;
-
-	/* Save unparsed command line copy for /proc/cmdline */
-#ifdef CONFIG_XEN
-	int max_cmdline;
-	
-	if ((max_cmdline = MAX_GUEST_CMDLINE) > COMMAND_LINE_SIZE)
-		max_cmdline = COMMAND_LINE_SIZE;
-	memcpy(saved_command_line, xen_start_info->cmd_line, max_cmdline);
-	saved_command_line[max_cmdline-1] = '\0';
-#else
-	memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
-	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+#ifndef CONFIG_XEN
+	int userdef = 0;
 #endif
 
 	for (;;) {
@@ -387,10 +383,14 @@ static __init void parse_cmdline_early (
 		    !memcmp(from, "disableapic", 11))
 			disable_apic = 1;
 
-		if (!memcmp(from, "noapic", 6)) 
+		/* Don't confuse with noapictimer */
+		if (!memcmp(from, "noapic", 6) &&
+			(from[6] == ' ' || from[6] == 0))
 			skip_ioapic_setup = 1;
 
-		if (!memcmp(from, "apic", 4)) { 
+		/* Make sure to not confuse with apic= */
+		if (!memcmp(from, "apic", 4) &&
+			(from[4] == ' ' || from[4] == 0)) {
 			skip_ioapic_setup = 0;
 			ioapic_force = 1;
 		}
@@ -398,6 +398,30 @@ static __init void parse_cmdline_early (
 		if (!memcmp(from, "mem=", 4))
 			parse_memopt(from+4, &from); 
 
+#ifndef CONFIG_XEN
+		if (!memcmp(from, "memmap=", 7)) {
+			/* exactmap option is for used defined memory */
+			if (!memcmp(from+7, "exactmap", 8)) {
+#ifdef CONFIG_CRASH_DUMP
+				/* If we are doing a crash dump, we
+				 * still need to know the real mem
+				 * size before original memory map is
+				 * reset.
+				 */
+				saved_max_pfn = e820_end_of_ram();
+#endif
+				from += 8+7;
+				end_pfn_map = 0;
+				e820.nr_map = 0;
+				userdef = 1;
+			}
+			else {
+				parse_memmapopt(from+7, &from);
+				userdef = 1;
+			}
+		}
+#endif
+
 #ifdef CONFIG_NUMA
 		if (!memcmp(from, "numa=", 5))
 			numa_setup(from+5); 
@@ -436,6 +460,14 @@ static __init void parse_cmdline_early (
 		}
 #endif
 
+#ifdef CONFIG_PROC_VMCORE
+		/* elfcorehdr= specifies the location of elf core header
+		 * stored by the crashed kernel. This option will be passed
+		 * by kexec loader to the capture kernel.
+		 */
+		else if(!memcmp(from, "elfcorehdr=", 11))
+			elfcorehdr_addr = memparse(from+11, &from);
+#endif
 	next_char:
 		c = *(from++);
 		if (!c)
@@ -444,6 +476,12 @@ static __init void parse_cmdline_early (
 			break;
 		*(to++) = c;
 	}
+#ifndef CONFIG_XEN
+	if (userdef) {
+		printk(KERN_INFO "user-defined physical RAM map:\n");
+		e820_print_map("user");
+	}
+#endif
 	*to = '\0';
 	*cmdline_p = command_line;
 }
@@ -498,6 +536,8 @@ static unsigned char *k8_nops[ASM_NOP_MA
      k8nops + 1 + 2 + 3 + 4 + 5 + 6 + 7,
 }; 
 
+extern char __vsyscall_0;
+
 /* Replace instructions with better alternatives for this CPU type.
 
    This runs before SMP is initialized to avoid SMP problems with
@@ -509,11 +549,17 @@ void apply_alternatives(void *start, voi
 	struct alt_instr *a; 
 	int diff, i, k;
 	for (a = start; (void *)a < end; a++) { 
+		u8 *instr;
+
 		if (!boot_cpu_has(a->cpuid))
 			continue;
 
 		BUG_ON(a->replacementlen > a->instrlen); 
-		__inline_memcpy(a->instr, a->replacement, a->replacementlen); 
+		instr = a->instr;
+		/* vsyscall code is not mapped yet. resolve it manually. */
+		if (instr >= (u8 *)VSYSCALL_START && instr < (u8*)VSYSCALL_END)
+			instr -= VSYSCALL_START - (unsigned long)&__vsyscall_0;
+		__inline_memcpy(instr, a->replacement, a->replacementlen);
 		diff = a->instrlen - a->replacementlen; 
 
 		/* Pad the rest with nops */
@@ -521,7 +567,7 @@ void apply_alternatives(void *start, voi
 			k = diff;
 			if (k > ASM_NOP_MAX)
 				k = ASM_NOP_MAX;
-			__inline_memcpy(a->instr + i, k8_nops[k], k); 
+			__inline_memcpy(instr + i, k8_nops[k], k);
 		} 
 	}
 } 
@@ -862,6 +908,8 @@ void __init setup_arch(char **cmdline_p)
 	acpi_boot_init();
 #endif
 
+	init_cpu_to_node();
+
 #ifdef CONFIG_X86_LOCAL_APIC
 	/*
 	 * get boot-time SMP configuration:
@@ -1067,7 +1115,6 @@ static void __init amd_detect_cmp(struct
 static int __init init_amd(struct cpuinfo_x86 *c)
 {
 	int r;
-	int level;
 
 #ifdef CONFIG_SMP
 	unsigned long value;
@@ -1090,11 +1137,6 @@ static int __init init_amd(struct cpuinf
 	   3DNow is IDd by bit 31 in extended CPUID (1*32+31) anyway */
 	clear_bit(0*32+31, &c->x86_capability);
 	
-	/* C-stepping K8? */
-	level = cpuid_eax(1);
-	if ((level >= 0x0f48 && level < 0x0f50) || level >= 0x0f58)
-		set_bit(X86_FEATURE_K8_C, &c->x86_capability);
-
 	r = get_model_name(c);
 	if (!r) { 
 		switch (c->x86) { 
@@ -1107,6 +1149,10 @@ static int __init init_amd(struct cpuinf
 	} 
 	display_cacheinfo(c);
 
+	/* c->x86_power is 8000_0007 edx. Bit 8 is constant TSC */
+	if (c->x86_power & (1<<8))
+		set_bit(X86_FEATURE_CONSTANT_TSC, &c->x86_capability);
+
 	if (c->extended_cpuid_level >= 0x80000008) {
 		c->x86_max_cores = (cpuid_ecx(0x80000008) & 0xff) + 1;
 		if (c->x86_max_cores & (c->x86_max_cores - 1))
@@ -1225,8 +1271,10 @@ static void __cpuinit init_intel(struct 
 
 	if (c->x86 == 15)
 		c->x86_cache_alignment = c->x86_clflush_size * 2;
-	if (c->x86 >= 15)
+	if ((c->x86 == 0xf && c->x86_model >= 0x03) ||
+	    (c->x86 == 0x6 && c->x86_model >= 0x0e))
 		set_bit(X86_FEATURE_CONSTANT_TSC, &c->x86_capability);
+	set_bit(X86_FEATURE_SYNC_RDTSC, &c->x86_capability);
  	c->x86_max_cores = intel_num_cpu_cores(c);
 
 	srat_detect_node();
@@ -1425,7 +1473,7 @@ static int show_cpuinfo(struct seq_file 
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, "syscall", NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, "nx", NULL, "mmxext", NULL,
-		NULL, "fxsr_opt", NULL, NULL, NULL, "lm", "3dnowext", "3dnow",
+		NULL, "fxsr_opt", "rdtscp", NULL, NULL, "lm", "3dnowext", "3dnow",
 
 		/* Transmeta-defined */
 		"recovery", "longrun", NULL, "lrti", NULL, NULL, NULL, NULL,
@@ -1453,7 +1501,7 @@ static int show_cpuinfo(struct seq_file 
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
 		/* AMD-defined (#2) */
-		"lahf_lm", "cmp_legacy", NULL, NULL, NULL, NULL, NULL, NULL,
+		"lahf_lm", "cmp_legacy", "svm", NULL, "cr8_legacy", NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
@@ -1464,7 +1512,9 @@ static int show_cpuinfo(struct seq_file 
 		"vid",  /* voltage id control */
 		"ttp",  /* thermal trip */
 		"tm",
-		"stc"
+		"stc",
+		NULL,
+		/* nothing */	/* constant_tsc - moved to flags */
 	};
 
 
@@ -1490,8 +1540,11 @@ static int show_cpuinfo(struct seq_file 
 		seq_printf(m, "stepping\t: unknown\n");
 	
 	if (cpu_has(c,X86_FEATURE_TSC)) {
+		unsigned int freq = cpufreq_quick_get((unsigned)(c-cpu_data));
+		if (!freq)
+			freq = cpu_khz;
 		seq_printf(m, "cpu MHz\t\t: %u.%03u\n",
-			     cpu_khz / 1000, (cpu_khz % 1000));
+			     freq / 1000, (freq % 1000));
 	}
 
 	/* Cache size */
@@ -1541,8 +1594,11 @@ static int show_cpuinfo(struct seq_file 
 		unsigned i;
 		for (i = 0; i < 32; i++) 
 			if (c->x86_power & (1 << i)) {
-				if (i < ARRAY_SIZE(x86_power_flags))
-					seq_printf(m, " %s", x86_power_flags[i]);
+				if (i < ARRAY_SIZE(x86_power_flags) &&
+					x86_power_flags[i])
+					seq_printf(m, "%s%s",
+						x86_power_flags[i][0]?" ":"",
+						x86_power_flags[i]);
 				else
 					seq_printf(m, " [%d]", i);
 			}
@@ -1574,3 +1630,11 @@ struct seq_operations cpuinfo_op = {
 	.stop =	c_stop,
 	.show =	show_cpuinfo,
 };
+
+static int __init run_dmi_scan(void)
+{
+	dmi_scan_machine();
+	return 0;
+}
+core_initcall(run_dmi_scan);
+
Index: head-2006-02-07/arch/x86_64/xen/kernel/setup64.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/setup64.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/setup64.c	2006-02-08 12:54:28.000000000 +0100
@@ -37,7 +37,8 @@ char x86_boot_params[BOOT_PARAM_SIZE] __
 
 cpumask_t cpu_initialized __cpuinitdata = CPU_MASK_NONE;
 
-struct x8664_pda cpu_pda[NR_CPUS] __cacheline_aligned; 
+struct x8664_pda *_cpu_pda[NR_CPUS] __read_mostly;
+struct x8664_pda boot_cpu_pda[NR_CPUS] __cacheline_aligned;
 
 struct desc_ptr idt_descr = { 256 * 16, (unsigned long) idt_table }; 
 
@@ -117,7 +118,7 @@ void __init setup_per_cpu_areas(void)
 		}
 		if (!ptr)
 			panic("Cannot allocate cpu data for CPU %d\n", i);
-		cpu_pda[i].data_offset = ptr - __per_cpu_start;
+		cpu_pda(i)->data_offset = ptr - __per_cpu_start;
 		memcpy(ptr, __per_cpu_start, __per_cpu_end - __per_cpu_start);
 	}
 } 
@@ -167,15 +168,15 @@ void __init cpu_gdt_init(struct desc_ptr
 
 void pda_init(int cpu)
 { 
-	struct x8664_pda *pda = &cpu_pda[cpu];
+	struct x8664_pda *pda = cpu_pda(cpu);
 
 	/* Setup up data that may be needed in __get_free_pages early */
 	asm volatile("movl %0,%%fs ; movl %0,%%gs" :: "r" (0)); 
 #ifndef CONFIG_XEN
-	wrmsrl(MSR_GS_BASE, cpu_pda + cpu);
+	wrmsrl(MSR_GS_BASE, pda);
 #else
         HYPERVISOR_set_segment_base(SEGBASE_GS_KERNEL, 
-                                    (unsigned long)(cpu_pda + cpu));
+                                    (unsigned long)pda);
 #endif
 	pda->cpunumber = cpu; 
 	pda->irqcount = -1;
@@ -202,7 +203,7 @@ void pda_init(int cpu)
 	pda->irqstackptr += IRQSTACKSIZE-64;
 } 
 
-char boot_exception_stacks[N_EXCEPTION_STACKS * EXCEPTION_STKSZ] 
+char boot_exception_stacks[(N_EXCEPTION_STACKS - 2) * EXCEPTION_STKSZ + DEBUG_STKSZ]
 __attribute__((section(".bss.page_aligned")));
 
 /* May not be marked __init: used by software suspend */
@@ -272,27 +273,15 @@ void __cpuinit cpu_init (void)
 	 * and set up the GDT descriptor:
 	 */
 #ifndef CONFIG_XEN 
-	if (cpu) {
-		memcpy(cpu_gdt_table[cpu], cpu_gdt_table[0], GDT_SIZE);
-	}	
+	if (cpu)
+ 		memcpy(cpu_gdt(cpu), cpu_gdt_table, GDT_SIZE);
 
 	cpu_gdt_descr[cpu].size = GDT_SIZE;
-	cpu_gdt_descr[cpu].address = (unsigned long)cpu_gdt_table[cpu];
 
-	memcpy(me->thread.tls_array, cpu_gdt_table[cpu], GDT_ENTRY_TLS_ENTRIES * 8);
 #else
-	memcpy(me->thread.tls_array, &get_cpu_gdt_table(cpu)[GDT_ENTRY_TLS_MIN],
-	    GDT_ENTRY_TLS_ENTRIES * 8);
-
 	cpu_gdt_init(&cpu_gdt_descr[cpu]);
 #endif
-       
-	/*
-	 * Delete NT
-	 */
-
-	asm volatile("pushfq ; popq %%rax ; btr $14,%%rax ; pushq %%rax ; popfq" ::: "eax");
-
+	memset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);
 	syscall_init();
 
 	wrmsrl(MSR_FS_BASE, 0);
@@ -306,13 +295,27 @@ void __cpuinit cpu_init (void)
 	 */
 	for (v = 0; v < N_EXCEPTION_STACKS; v++) {
 		if (cpu) {
-			estacks = (char *)__get_free_pages(GFP_ATOMIC, 
-						   EXCEPTION_STACK_ORDER);
+			static const unsigned int order[N_EXCEPTION_STACKS] = {
+				[0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,
+				[DEBUG_STACK - 1] = DEBUG_STACK_ORDER
+			};
+
+			estacks = (char *)__get_free_pages(GFP_ATOMIC, order[v]);
 			if (!estacks)
 				panic("Cannot allocate exception stack %ld %d\n",
 				      v, cpu); 
 		}
-		estacks += EXCEPTION_STKSZ;
+		switch (v + 1) {
+#if DEBUG_STKSZ > EXCEPTION_STKSZ
+		case DEBUG_STACK:
+			cpu_pda[cpu].debugstack = (unsigned long)estacks;
+			estacks += DEBUG_STKSZ;
+			break;
+#endif
+		default:
+			estacks += EXCEPTION_STKSZ;
+			break;
+		}
 		t->ist[v] = (unsigned long)estacks;
 	}
 
Index: head-2006-02-07/arch/x86_64/xen/kernel/smp.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/smp.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/smp.c	2006-01-19 09:25:48.000000000 +0100
@@ -27,6 +27,7 @@
 #include <asm/mmu_context.h>
 #include <asm/proto.h>
 #include <asm/apicdef.h>
+#include <asm/idle.h>
 #ifdef CONFIG_XEN
 #include <asm-xen/evtchn.h>
 
@@ -299,11 +300,6 @@ void flush_tlb_all(void)
 { xen_tlb_flush_all(); }
 #endif /* Xen */
 
-void smp_kdb_stop(void)
-{
-	send_IPI_allbutself(KDB_VECTOR);
-}
-
 /*
  * this function sends a 'reschedule' IPI to another CPU.
  * it goes straight through and wastes no time serializing
@@ -563,6 +559,7 @@ asmlinkage irqreturn_t smp_call_function
 	/*
 	 * At this point the info structure may be out of scope unless wait==1
 	 */
+	exit_idle();
 	irq_enter();
 	(*func)(info);
 	irq_exit();
Index: head-2006-02-07/arch/x86_64/xen/kernel/traps.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/traps.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/traps.c	2006-02-08 12:54:29.000000000 +0100
@@ -70,7 +70,6 @@ asmlinkage void reserved(void);
 asmlinkage void alignment_check(void);
 asmlinkage void machine_check(void);
 asmlinkage void spurious_interrupt_bug(void);
-asmlinkage void call_debug(void);
 
 struct notifier_block *die_chain;
 static DEFINE_SPINLOCK(die_notifier_lock);
@@ -121,19 +120,31 @@ int printk_address(unsigned long address
 static unsigned long *in_exception_stack(unsigned cpu, unsigned long stack,
 					unsigned *usedp, const char **idp)
 {
-	static const char ids[N_EXCEPTION_STACKS][8] = {
+	static char ids[][8] = {
 		[DEBUG_STACK - 1] = "#DB",
 		[NMI_STACK - 1] = "NMI",
 		[DOUBLEFAULT_STACK - 1] = "#DF",
 		[STACKFAULT_STACK - 1] = "#SS",
 		[MCE_STACK - 1] = "#MC",
+#if DEBUG_STKSZ > EXCEPTION_STKSZ
+		[N_EXCEPTION_STACKS ... N_EXCEPTION_STACKS + DEBUG_STKSZ / EXCEPTION_STKSZ - 2] = "#DB[?]"
+#endif
 	};
 	unsigned k;
 
 	for (k = 0; k < N_EXCEPTION_STACKS; k++) {
 		unsigned long end;
 
-		end = per_cpu(init_tss, cpu).ist[k];
+		switch (k + 1) {
+#if DEBUG_STKSZ > EXCEPTION_STKSZ
+		case DEBUG_STACK:
+			end = cpu_pda(cpu)->debugstack + DEBUG_STKSZ;
+			break;
+#endif
+		default:
+			end = per_cpu(init_tss, cpu).ist[k];
+			break;
+		}
 		if (stack >= end)
 			continue;
 		if (stack >= end - EXCEPTION_STKSZ) {
@@ -143,6 +154,22 @@ static unsigned long *in_exception_stack
 			*idp = ids[k];
 			return (unsigned long *)end;
 		}
+#if DEBUG_STKSZ > EXCEPTION_STKSZ
+		if (k == DEBUG_STACK - 1 && stack >= end - DEBUG_STKSZ) {
+			unsigned j = N_EXCEPTION_STACKS - 1;
+
+			do {
+				++j;
+				end -= EXCEPTION_STKSZ;
+				ids[j][4] = '1' + (j - N_EXCEPTION_STACKS);
+			} while (stack < end - EXCEPTION_STKSZ);
+			if (*usedp & (1U << j))
+				break;
+			*usedp |= 1U << j;
+			*idp = ids[j];
+			return (unsigned long *)end;
+		}
+#endif
 	}
 	return NULL;
 }
@@ -156,9 +183,8 @@ static unsigned long *in_exception_stack
 
 void show_trace(unsigned long *stack)
 {
-	unsigned long addr;
 	const unsigned cpu = safe_smp_processor_id();
-	unsigned long *irqstack_end = (unsigned long *)cpu_pda[cpu].irqstackptr;
+	unsigned long *irqstack_end = (unsigned long *)cpu_pda(cpu)->irqstackptr;
 	int i;
 	unsigned used = 0;
 
@@ -166,8 +192,14 @@ void show_trace(unsigned long *stack)
 
 #define HANDLE_STACK(cond) \
 	do while (cond) { \
-		addr = *stack++; \
+		unsigned long addr = *stack++; \
 		if (kernel_text_address(addr)) { \
+			if (i > 50) { \
+				printk("\n       "); \
+				i = 0; \
+			} \
+			else \
+				i += printk(" "); \
 			/* \
 			 * If the address is either in the text segment of the \
 			 * kernel, or in the region which contains vmalloc'ed \
@@ -177,25 +209,19 @@ void show_trace(unsigned long *stack)
 			 * out the call path that was taken. \
 			 */ \
 			i += printk_address(addr); \
-			if (i > 50) { \
-				printk("\n       "); \
-				i = 0; \
-			} \
-			else \
-				i += printk(" "); \
 		} \
 	} while (0)
 
-	for(i = 0; ; ) {
+	for(i = 11; ; ) {
 		const char *id;
 		unsigned long *estack_end;
 		estack_end = in_exception_stack(cpu, (unsigned long)stack,
 						&used, &id);
 
 		if (estack_end) {
-			i += printk(" <%s> ", id);
+			i += printk(" <%s>", id);
 			HANDLE_STACK (stack < estack_end);
-			i += printk(" <EOE> ");
+			i += printk(" <EOE>");
 			stack = (unsigned long *) estack_end[-2];
 			continue;
 		}
@@ -205,11 +231,11 @@ void show_trace(unsigned long *stack)
 				(IRQSTACKSIZE - 64) / sizeof(*irqstack);
 
 			if (stack >= irqstack && stack < irqstack_end) {
-				i += printk(" <IRQ> ");
+				i += printk(" <IRQ>");
 				HANDLE_STACK (stack < irqstack_end);
 				stack = (unsigned long *) (irqstack_end[-1]);
 				irqstack_end = NULL;
-				i += printk(" <EOI> ");
+				i += printk(" <EOI>");
 				continue;
 			}
 		}
@@ -226,8 +252,8 @@ void show_stack(struct task_struct *tsk,
 	unsigned long *stack;
 	int i;
 	const int cpu = safe_smp_processor_id();
-	unsigned long *irqstack_end = (unsigned long *) (cpu_pda[cpu].irqstackptr);
-	unsigned long *irqstack = (unsigned long *) (cpu_pda[cpu].irqstackptr - IRQSTACKSIZE);    
+	unsigned long *irqstack_end = (unsigned long *) (cpu_pda(cpu)->irqstackptr);
+	unsigned long *irqstack = (unsigned long *) (cpu_pda(cpu)->irqstackptr - IRQSTACKSIZE);
 
 	// debugging aid: "show_stack(NULL, NULL);" prints the
 	// back trace for this cpu.
@@ -275,7 +301,7 @@ void show_registers(struct pt_regs *regs
 	int in_kernel = !user_mode(regs);
 	unsigned long rsp;
 	const int cpu = safe_smp_processor_id(); 
-	struct task_struct *cur = cpu_pda[cpu].pcurrent; 
+	struct task_struct *cur = cpu_pda(cpu)->pcurrent;
 
 		rsp = regs->rsp;
 
@@ -314,20 +340,26 @@ bad:
 void handle_BUG(struct pt_regs *regs)
 { 
 	struct bug_frame f;
-	char tmp;
+	long len;
+	const char *prefix = "";
 
 	if (user_mode(regs))
 		return; 
-	if (__copy_from_user(&f, (struct bug_frame *) regs->rip, 
+	if (__copy_from_user(&f, (const void __user *) regs->rip,
 			     sizeof(struct bug_frame)))
 		return; 
 	if (f.filename >= 0 ||
 	    f.ud2[0] != 0x0f || f.ud2[1] != 0x0b) 
 		return;
-	if (__get_user(tmp, (char *)(long)f.filename))
+	len = __strnlen_user((char *)(long)f.filename, PATH_MAX) - 1;
+	if (len < 0 || len >= PATH_MAX)
 		f.filename = (int)(long)"unmapped filename";
+	else if (len > 50) {
+		f.filename += len - 50;
+		prefix = "...";
+	}
 	printk("----------- [cut here ] --------- [please bite here ] ---------\n");
-	printk(KERN_ALERT "Kernel BUG at %.50s:%d\n", (char *)(long)f.filename, f.line);
+	printk(KERN_ALERT "Kernel BUG at %s%.50s:%d\n", prefix, (char *)(long)f.filename, f.line);
 } 
 
 #ifdef CONFIG_BUG
@@ -382,7 +414,7 @@ void __die(const char * str, struct pt_r
 	printk("DEBUG_PAGEALLOC");
 #endif
 	printk("\n");
-	notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
+	notify_die(DIE_OOPS, str, regs, err, current->thread.trap_no, SIGSEGV);
 	show_registers(regs);
 	/* Executive summary in case the oops scrolled away */
 	printk(KERN_ALERT "RIP ");
@@ -399,11 +431,6 @@ void die(const char * str, struct pt_reg
 	oops_end(flags);
 	do_exit(SIGSEGV); 
 }
-static inline void die_if_kernel(const char * str, struct pt_regs * regs, long err)
-{
-	if (!(regs->eflags & VM_MASK) && (regs->cs == __KERNEL_CS))
-		die(str, regs, err);
-}
 
 #ifdef CONFIG_X86_LOCAL_APIC
 void die_nmi(char *str, struct pt_regs *regs)
@@ -428,19 +455,20 @@ static void __kprobes do_trap(int trapnr
 			      struct pt_regs * regs, long error_code,
 			      siginfo_t *info)
 {
+	struct task_struct *tsk = current;
+
 	conditional_sti(regs);
 
-	if (user_mode(regs)) {
-		struct task_struct *tsk = current;
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = trapnr;
 
+	if (user_mode(regs)) {
 		if (exception_trace && unhandled_signal(tsk, signr))
 			printk(KERN_INFO
 			       "%s[%d] trap %s rip:%lx rsp:%lx error:%lx\n",
 			       tsk->comm, tsk->pid, str,
 			       regs->rip,regs->rsp,error_code); 
 
-		tsk->thread.error_code = error_code;
-		tsk->thread.trap_no = trapnr;
 		if (info)
 			force_sig_info(signr, info, tsk);
 		else
@@ -487,7 +515,7 @@ asmlinkage void do_##name(struct pt_regs
 DO_ERROR_INFO( 0, SIGFPE,  "divide error", divide_error, FPE_INTDIV, regs->rip)
 DO_ERROR( 4, SIGSEGV, "overflow", overflow)
 DO_ERROR( 5, SIGSEGV, "bounds", bounds)
-DO_ERROR_INFO( 6, SIGILL,  "invalid operand", invalid_op, ILL_ILLOPN, regs->rip)
+DO_ERROR_INFO( 6, SIGILL,  "invalid opcode", invalid_op, ILL_ILLOPN, regs->rip)
 DO_ERROR( 7, SIGSEGV, "device not available", device_not_available)
 DO_ERROR( 9, SIGFPE,  "coprocessor segment overrun", coprocessor_segment_overrun)
 DO_ERROR(10, SIGSEGV, "invalid TSS", invalid_TSS)
@@ -495,24 +523,41 @@ DO_ERROR(11, SIGBUS,  "segment not prese
 DO_ERROR_INFO(17, SIGBUS, "alignment check", alignment_check, BUS_ADRALN, 0)
 DO_ERROR(18, SIGSEGV, "reserved", reserved)
 DO_ERROR(12, SIGBUS,  "stack segment", stack_segment)
-DO_ERROR( 8, SIGSEGV, "double fault", double_fault)
+
+asmlinkage void do_double_fault(struct pt_regs * regs, long error_code)
+{
+	static const char str[] = "double fault";
+	struct task_struct *tsk = current;
+
+	/* Return not checked because double check cannot be ignored */
+	notify_die(DIE_TRAP, str, regs, error_code, 8, SIGSEGV);
+
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = 8;
+
+	/* This is always a kernel trap and never fixable (and thus must
+	   never return). */
+	for (;;)
+		die(str, regs, error_code);
+}
 
 asmlinkage void __kprobes do_general_protection(struct pt_regs * regs,
 						long error_code)
 {
+	struct task_struct *tsk = current;
+
 	conditional_sti(regs);
 
-	if (user_mode(regs)) {
-		struct task_struct *tsk = current;
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = 13;
 
+	if (user_mode(regs)) {
 		if (exception_trace && unhandled_signal(tsk, SIGSEGV))
 			printk(KERN_INFO
 		       "%s[%d] general protection rip:%lx rsp:%lx error:%lx\n",
 			       tsk->comm, tsk->pid,
 			       regs->rip,regs->rsp,error_code); 
 
-		tsk->thread.error_code = error_code;
-		tsk->thread.trap_no = 13;
 		force_sig(SIGSEGV, tsk);
 		return;
 	} 
@@ -575,7 +620,7 @@ asmlinkage void default_do_nmi(struct pt
 		reason = get_nmi_reason();
 
 	if (!(reason & 0xc0)) {
-		if (notify_die(DIE_NMI_IPI, "nmi_ipi", regs, reason, 0, SIGINT)
+		if (notify_die(DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT)
 								== NOTIFY_STOP)
 			return;
 #ifdef CONFIG_X86_LOCAL_APIC
@@ -591,7 +636,7 @@ asmlinkage void default_do_nmi(struct pt
 		unknown_nmi_error(reason, regs);
 		return;
 	}
-	if (notify_die(DIE_NMI, "nmi", regs, reason, 0, SIGINT) == NOTIFY_STOP)
+	if (notify_die(DIE_NMI, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
 		return; 
 
 	/* AK: following checks seem to be broken on modern chipsets. FIXME */
@@ -602,6 +647,7 @@ asmlinkage void default_do_nmi(struct pt
 		io_check_error(reason, regs);
 }
 
+/* runs on IST stack. */
 asmlinkage void __kprobes do_int3(struct pt_regs * regs, long error_code)
 {
 	if (notify_die(DIE_INT3, "int3", regs, error_code, 3, SIGTRAP) == NOTIFY_STOP) {
@@ -686,11 +732,9 @@ asmlinkage void __kprobes do_debug(struc
 	info.si_signo = SIGTRAP;
 	info.si_errno = 0;
 	info.si_code = TRAP_BRKPT;
-	if (!user_mode(regs))
-		goto clear_dr7; 
+	info.si_addr = user_mode(regs) ? (void __user *)regs->rip : NULL;
+	force_sig_info(SIGTRAP, &info, tsk);
 
-	info.si_addr = (void __user *)regs->rip;
-	force_sig_info(SIGTRAP, &info, tsk);	
 clear_dr7:
 	set_debugreg(0UL, 7);
 	return;
@@ -700,7 +744,7 @@ clear_TF_reenable:
 	regs->eflags &= ~TF_MASK;
 }
 
-static int kernel_math_error(struct pt_regs *regs, char *str)
+static int kernel_math_error(struct pt_regs *regs, const char *str, int trapnr)
 {
 	const struct exception_table_entry *fixup;
 	fixup = search_exception_tables(regs->rip);
@@ -708,8 +752,9 @@ static int kernel_math_error(struct pt_r
 		regs->rip = fixup->fixup;
 		return 1;
 	}
-	notify_die(DIE_GPF, str, regs, 0, 16, SIGFPE);
+	notify_die(DIE_GPF, str, regs, 0, trapnr, SIGFPE);
 	/* Illegal floating point operation in the kernel */
+	current->thread.trap_no = trapnr;
 	die(str, regs, 0);
 	return 0;
 }
@@ -728,7 +773,7 @@ asmlinkage void do_coprocessor_error(str
 
 	conditional_sti(regs);
 	if (!user_mode(regs) &&
-	    kernel_math_error(regs, "kernel x87 math error"))
+	    kernel_math_error(regs, "kernel x87 math error", 16))
 		return;
 
 	/*
@@ -797,7 +842,7 @@ asmlinkage void do_simd_coprocessor_erro
 
 	conditional_sti(regs);
 	if (!user_mode(regs) &&
-        	kernel_math_error(regs, "kernel simd math error"))
+        	kernel_math_error(regs, "kernel simd math error", 19))
 		return;
 
 	/*
@@ -875,12 +920,6 @@ asmlinkage void math_state_restore(void)
 	me->thread_info->status |= TS_USEDFPU;
 }
 
-void do_call_debug(struct pt_regs *regs) 
-{ 
-	notify_die(DIE_CALL, "debug call", regs, 0, 255, SIGINT); 
-}
-
-
 /*
  * NB. All these are "interrupt gates" (i.e. events_mask is set) because we
  * specify <dpl>|4 in the second field.
@@ -890,7 +929,7 @@ static trap_info_t trap_table[] = {
         {  1, 0|4, (__KERNEL_CS|0x3), (unsigned long)debug                      },
         {  3, 3|4, (__KERNEL_CS|0x3), (unsigned long)int3                       },
         {  4, 3|4, (__KERNEL_CS|0x3), (unsigned long)overflow                   },
-        {  5, 3|4, (__KERNEL_CS|0x3), (unsigned long)bounds                     },
+        {  5, 0|4, (__KERNEL_CS|0x3), (unsigned long)bounds                     },
         {  6, 0|4, (__KERNEL_CS|0x3), (unsigned long)invalid_op                 },
         {  7, 0|4, (__KERNEL_CS|0x3), (unsigned long)device_not_available       },
         {  9, 0|4, (__KERNEL_CS|0x3), (unsigned long)coprocessor_segment_overrun},
Index: head-2006-02-07/arch/x86_64/xen/kernel/vsyscall.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/vsyscall.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/vsyscall.c	2006-01-19 09:25:48.000000000 +0100
@@ -35,14 +35,13 @@
 #include <asm/io.h>
 
 #define __vsyscall(nr) __attribute__ ((unused,__section__(".vsyscall_" #nr)))
-#define force_inline __attribute__((always_inline)) inline
 
 int __sysctl_vsyscall __section_sysctl_vsyscall = 1;
 seqlock_t __xtime_lock __section_xtime_lock = SEQLOCK_UNLOCKED;
 
 #include <asm/unistd.h>
 
-static force_inline void timeval_normalize(struct timeval * tv)
+static __always_inline void timeval_normalize(struct timeval * tv)
 {
 	time_t __sec;
 
@@ -53,7 +52,7 @@ static force_inline void timeval_normali
 	}
 }
 
-static force_inline void do_vgettimeofday(struct timeval * tv)
+static __always_inline void do_vgettimeofday(struct timeval * tv)
 {
 	long sequence, t;
 	unsigned long sec, usec;
@@ -66,8 +65,7 @@ static force_inline void do_vgettimeofda
 			(__jiffies - __wall_jiffies) * (1000000 / HZ);
 
 		if (__vxtime.mode != VXTIME_HPET) {
-			sync_core();
-			rdtscll(t);
+			t = get_cycles_sync();
 			if (t < __vxtime.last_tsc)
 				t = __vxtime.last_tsc;
 			usec += ((t - __vxtime.last_tsc) *
@@ -84,12 +82,12 @@ static force_inline void do_vgettimeofda
 }
 
 /* RED-PEN may want to readd seq locking, but then the variable should be write-once. */
-static force_inline void do_get_tz(struct timezone * tz)
+static __always_inline void do_get_tz(struct timezone * tz)
 {
 	*tz = __sys_tz;
 }
 
-static force_inline int gettimeofday(struct timeval *tv, struct timezone *tz)
+static __always_inline int gettimeofday(struct timeval *tv, struct timezone *tz)
 {
 	int ret;
 	asm volatile("vsysc2: syscall"
@@ -98,7 +96,7 @@ static force_inline int gettimeofday(str
 	return ret;
 }
 
-static force_inline long time_syscall(long *t)
+static __always_inline long time_syscall(long *t)
 {
 	long secs;
 	asm volatile("vsysc1: syscall"
Index: head-2006-02-07/arch/x86_64/xen/kernel/x8664_ksyms.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/kernel/x8664_ksyms.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/kernel/x8664_ksyms.c	2006-02-08 12:54:20.000000000 +0100
@@ -13,7 +13,6 @@
 #include <linux/string.h>
 #include <linux/syscalls.h>
 #include <linux/tty.h>
-#include <linux/ioctl32.h>
 
 #include <asm/semaphore.h>
 #include <asm/processor.h>
@@ -45,24 +44,17 @@ extern struct drive_info_struct drive_in
 EXPORT_SYMBOL(drive_info);
 #endif
 
-extern unsigned long get_cmos_time(void);
-
 /* platform dependent support */
 EXPORT_SYMBOL(boot_cpu_data);
 //EXPORT_SYMBOL(dump_fpu);
 EXPORT_SYMBOL(__ioremap);
 EXPORT_SYMBOL(ioremap_nocache);
 EXPORT_SYMBOL(iounmap);
-EXPORT_SYMBOL(enable_irq);
-EXPORT_SYMBOL(disable_irq);
-EXPORT_SYMBOL(disable_irq_nosync);
-EXPORT_SYMBOL(probe_irq_mask);
 EXPORT_SYMBOL(kernel_thread);
 EXPORT_SYMBOL(pm_idle);
 #ifdef CONFIG_ACPI_BOOT
 EXPORT_SYMBOL(pm_power_off);
 #endif
-EXPORT_SYMBOL(get_cmos_time);
 
 EXPORT_SYMBOL(__down_failed);
 EXPORT_SYMBOL(__down_failed_interruptible);
@@ -86,9 +78,6 @@ EXPORT_SYMBOL(__put_user_2);
 EXPORT_SYMBOL(__put_user_4);
 EXPORT_SYMBOL(__put_user_8);
 
-EXPORT_SYMBOL(strpbrk);
-EXPORT_SYMBOL(strstr);
-
 EXPORT_SYMBOL(strncpy_from_user);
 EXPORT_SYMBOL(__strncpy_from_user);
 EXPORT_SYMBOL(clear_user);
@@ -100,23 +89,17 @@ EXPORT_SYMBOL(copy_in_user);
 EXPORT_SYMBOL(strnlen_user);
 
 #ifdef CONFIG_PCI
-EXPORT_SYMBOL(pci_alloc_consistent);
-EXPORT_SYMBOL(pci_free_consistent);
-#endif
-
-#ifdef CONFIG_PCI
 EXPORT_SYMBOL(pci_mem_start);
 #endif
 
 EXPORT_SYMBOL(copy_page);
 EXPORT_SYMBOL(clear_page);
 
-EXPORT_SYMBOL(cpu_pda);
+EXPORT_SYMBOL(_cpu_pda);
 #ifdef CONFIG_SMP
 EXPORT_SYMBOL(__write_lock_failed);
 EXPORT_SYMBOL(__read_lock_failed);
 
-EXPORT_SYMBOL(synchronize_irq);
 EXPORT_SYMBOL(smp_call_function);
 #endif
 
@@ -138,30 +121,17 @@ EXPORT_SYMBOL_GPL(unset_nmi_callback);
 #undef memcpy
 #undef memset
 #undef memmove
-#undef memchr
 #undef strlen
-#undef strncmp
-#undef strncpy
-#undef strchr	
 
 extern void * memset(void *,int,__kernel_size_t);
 extern size_t strlen(const char *);
 extern void * memmove(void * dest,const void *src,size_t count);
-extern void *memchr(const void *s, int c, size_t n);
 extern void * memcpy(void *,const void *,__kernel_size_t);
 extern void * __memcpy(void *,const void *,__kernel_size_t);
 
 EXPORT_SYMBOL(memset);
 EXPORT_SYMBOL(strlen);
 EXPORT_SYMBOL(memmove);
-EXPORT_SYMBOL(strncmp);
-EXPORT_SYMBOL(strncpy);
-EXPORT_SYMBOL(strchr);
-EXPORT_SYMBOL(strncat);
-EXPORT_SYMBOL(memchr);
-EXPORT_SYMBOL(strrchr);
-EXPORT_SYMBOL(strnlen);
-EXPORT_SYMBOL(memscan);
 EXPORT_SYMBOL(memcpy);
 EXPORT_SYMBOL(__memcpy);
 
Index: head-2006-02-07/arch/x86_64/xen/mm/fault.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/mm/fault.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/mm/fault.c	2006-02-08 12:54:21.000000000 +0100
@@ -38,6 +38,13 @@
 
 DEFINE_PER_CPU(pgd_t *, cur_pgd);
 
+/* Page fault error code bits */
+#define PF_PROT	(1<<0)		/* or no page found */
+#define PF_WRITE	(1<<1)
+#define PF_USER	(1<<2)
+#define PF_RSVD	(1<<3)
+#define PF_INSTR	(1<<4)
+
 void bust_spinlocks(int yes)
 {
 	int loglevel_save = console_loglevel;
@@ -71,7 +78,7 @@ static noinline int is_prefetch(struct p
 	unsigned char *max_instr;
 
 	/* If it was a exec fault ignore */
-	if (error_code & (1<<4))
+	if (error_code & PF_INSTR)
 		return 0;
 	
 	instr = (unsigned char *)convert_rip_to_linear(current, regs);
@@ -226,17 +233,22 @@ static noinline void pgtable_bad(unsigne
 				 unsigned long error_code)
 {
 	unsigned long flags = oops_begin();
+	struct task_struct *tsk;
 
 	printk(KERN_ALERT "%s: Corrupted page table at address %lx\n",
 	       current->comm, address);
 	dump_pagetable(address);
+	tsk = current;
+	tsk->thread.cr2 = address;
+	tsk->thread.trap_no = 14;
+	tsk->thread.error_code = error_code;
 	__die("Bad pagetable", regs, error_code);
 	oops_end(flags);
 	do_exit(SIGKILL);
 }
 
 /*
- * Handle a fault on the vmalloc or module mapping area
+ * Handle a fault on the vmalloc area
  *
  * This assumes no large pages in there.
  */
@@ -288,7 +300,6 @@ static int vmalloc_fault(unsigned long a
 	   that. */
 	if (!pte_present(*pte) || pte_pfn(*pte) != pte_pfn(*pte_ref))
 		BUG();
-	__flush_tlb_all();
 	return 0;
 }
 
@@ -310,12 +321,6 @@ int exception_trace = 1;
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
  * routines.
- *
- * error_code:
- *	bit 0 == 0 means no page found, 1 means protection fault
- *	bit 1 == 0 means read, 1 means write
- *	bit 2 == 0 means kernel, 1 means user-mode
- *      bit 3 == 1 means fault was an instruction fetch
  */
 asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
 					unsigned long error_code)
@@ -330,7 +335,7 @@ asmlinkage void __kprobes do_page_fault(
 	siginfo_t info;
 
 	if (!user_mode(regs))
-		error_code &= ~4; /* means kernel */
+		error_code &= ~PF_USER; /* means kernel */
 
 	/* get the address */
 	address = HYPERVISOR_shared_info->vcpu_info[
@@ -363,12 +368,16 @@ asmlinkage void __kprobes do_page_fault(
 	 *
 	 * This verifies that the fault happens in kernel space
 	 * (error_code & 4) == 0, and that the fault was not a
-	 * protection error (error_code & 1) == 0.
+	 * protection error (error_code & 9) == 0.
 	 */
 	if (unlikely(address >= TASK_SIZE64)) {
-		if (!(error_code & 5) &&
-		      ((address >= VMALLOC_START && address < VMALLOC_END) ||
-		       (address >= MODULES_VADDR && address < MODULES_END))) {
+		/*
+		 * Must check for the entire kernel range here: with writable
+		 * page tables the hypervisor may temporarily clear PMD
+		 * entries.
+		 */
+		if (!(error_code & (PF_RSVD|PF_USER|PF_PROT)) &&
+		    address >= HYPERVISOR_VIRT_END) {
 			if (vmalloc_fault(address) < 0)
 				goto bad_area_nosemaphore;
 			return;
@@ -380,7 +389,7 @@ asmlinkage void __kprobes do_page_fault(
 		goto bad_area_nosemaphore;
 	}
 
-	if (unlikely(error_code & (1 << 3)))
+	if (unlikely(error_code & PF_RSVD))
 		pgtable_bad(address, regs, error_code);
 
 	/*
@@ -407,7 +416,7 @@ asmlinkage void __kprobes do_page_fault(
 	 * thus avoiding the deadlock.
 	 */
 	if (!down_read_trylock(&mm->mmap_sem)) {
-		if ((error_code & 4) == 0 &&
+		if ((error_code & PF_USER) == 0 &&
 		    !search_exception_tables(regs->rip))
 			goto bad_area_nosemaphore;
 		down_read(&mm->mmap_sem);
@@ -434,17 +443,17 @@ asmlinkage void __kprobes do_page_fault(
 good_area:
 	info.si_code = SEGV_ACCERR;
 	write = 0;
-	switch (error_code & 3) {
+	switch (error_code & (PF_PROT|PF_WRITE)) {
 		default:	/* 3: write, present */
 			/* fall through */
-		case 2:		/* write, not present */
+		case PF_WRITE:		/* write, not present */
 			if (!(vma->vm_flags & VM_WRITE))
 				goto bad_area;
 			write++;
 			break;
-		case 1:		/* read, present */
+		case PF_PROT:		/* read, present */
 			goto bad_area;
-		case 0:		/* read, not present */
+		case 0:			/* read, not present */
 			if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
 				goto bad_area;
 	}
@@ -479,7 +488,7 @@ bad_area:
 
 bad_area_nosemaphore:
 	/* User mode accesses just cause a SIGSEGV */
-	if (error_code & 4) {
+	if (error_code & PF_USER) {
 		if (is_prefetch(regs, address, error_code))
 			return;
 
@@ -547,6 +556,9 @@ no_context:
 	printk_address(regs->rip);
 	printk("\n");
 	dump_pagetable(address);
+	tsk->thread.cr2 = address;
+	tsk->thread.trap_no = 14;
+	tsk->thread.error_code = error_code;
 	__die("Oops", regs, error_code);
 	/* Executive summary in case the body of the oops scrolled away */
 	printk(KERN_EMERG "CR2: %016lx\n", address);
@@ -572,7 +584,7 @@ do_sigbus:
 	up_read(&mm->mmap_sem);
 
 	/* Kernel mode? Handle exceptions or die */
-	if (!(error_code & 4))
+	if (!(error_code & PF_USER))
 		goto no_context;
 
 	tsk->thread.cr2 = address;
Index: head-2006-02-07/arch/x86_64/xen/mm/init.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/mm/init.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/mm/init.c	2006-02-08 12:54:28.000000000 +0100
@@ -26,6 +26,7 @@
 #include <linux/bootmem.h>
 #include <linux/proc_fs.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -41,6 +42,8 @@
 #include <asm/proto.h>
 #include <asm/smp.h>
 #include <asm/sections.h>
+#include <asm/dma-mapping.h>
+#include <asm/swiotlb.h>
 
 extern unsigned long *contiguous_bitmap;
 
@@ -843,6 +846,29 @@ void free_initmem(void)
 #endif
 }
 
+#ifdef CONFIG_DEBUG_RODATA
+
+extern char __start_rodata, __end_rodata;
+void mark_rodata_ro(void)
+{
+	unsigned long addr = (unsigned long)&__start_rodata;
+
+	for (; addr < (unsigned long)&__end_rodata; addr += PAGE_SIZE)
+		change_page_attr_addr(addr, 1, PAGE_KERNEL_RO);
+
+	printk ("Write protecting the kernel read-only data: %luk\n",
+			(&__end_rodata - &__start_rodata) >> 10);
+
+	/*
+	 * change_page_attr_addr() requires a global_flush_tlb() call after it.
+	 * We do this after the printk so that if something went wrong in the
+	 * change, the printk gets out at least to give a better debug hint
+	 * of who is the culprit.
+	 */
+	global_flush_tlb();
+}
+#endif
+
 #ifdef CONFIG_BLK_DEV_INITRD
 void free_initrd_mem(unsigned long start, unsigned long end)
 {
Index: head-2006-02-07/arch/x86_64/xen/mm/pageattr.c
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/mm/pageattr.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/xen/mm/pageattr.c	2006-02-08 12:54:20.000000000 +0100
@@ -266,6 +266,7 @@ __change_page_attr(unsigned long address
 	pte_t *kpte; 
 	struct page *kpte_page;
 	unsigned kpte_flags;
+	pgprot_t ref_prot2;
 	kpte = lookup_address(address);
 	if (!kpte) return 0;
 	kpte_page = virt_to_page(((unsigned long)kpte) & PAGE_MASK);
@@ -278,10 +279,14 @@ __change_page_attr(unsigned long address
  			 * split_large_page will take the reference for this change_page_attr
  			 * on the split page.
  			 */
-			struct page *split = split_large_page(address, prot, ref_prot); 
+
+			struct page *split;
+			ref_prot2 = __pgprot(pgprot_val(pte_pgprot(*lookup_address(address))) & ~(1<<_PAGE_BIT_PSE));
+
+			split = split_large_page(address, prot, ref_prot2);
 			if (!split)
 				return -ENOMEM;
-			set_pte(kpte,mk_pte(split, ref_prot));
+			set_pte(kpte,mk_pte(split, ref_prot2));
 			kpte_page = split;
 		}	
 		get_page(kpte_page);
Index: head-2006-02-07/arch/x86_64/xen/pci/Makefile-BUS
===================================================================
--- head-2006-02-07.orig/arch/x86_64/xen/pci/Makefile-BUS	2006-02-08 12:29:07.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,22 +0,0 @@
-#
-# Makefile for X86_64 specific PCI routines
-#
-# Reuse the i386 PCI subsystem
-#
-CFLAGS += -I arch/i386/pci
-
-obj-y		:= i386.o
-obj-$(CONFIG_PCI_DIRECT)+= direct.o
-obj-y		+= fixup.o
-obj-$(CONFIG_ACPI)	+= acpi.o
-obj-y			+= legacy.o irq.o common.o
-# mmconfig has a 64bit special
-obj-$(CONFIG_PCI_MMCONFIG) += mmconfig.o
-
-direct-y += ../../i386/pci/direct.o
-acpi-y   += ../../i386/pci/acpi.o
-legacy-y += ../../i386/pci/legacy.o
-irq-y    += ../../i386/pci/irq.o
-common-y += ../../i386/pci/common.o
-fixup-y  += ../../i386/pci/fixup.o
-i386-y  += ../../i386/pci/i386.o
Index: head-2006-02-07/drivers/xen/balloon/balloon.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/balloon/balloon.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/balloon/balloon.c	2006-01-19 09:25:48.000000000 +0100
@@ -92,14 +92,14 @@ static DECLARE_WORK(balloon_worker, ball
 static struct timer_list balloon_timer;
 
 /* Use the private and mapping fields of struct page as a list. */
-#define PAGE_TO_LIST(p) ((struct list_head *)&p->u.private)
+#define PAGE_TO_LIST(p) ((struct list_head *)&p->private)
 #define LIST_TO_PAGE(l)				\
-	(list_entry(((unsigned long *)l), struct page, u.private))
+	(list_entry(((unsigned long *)l), struct page, private))
 #define UNLIST_PAGE(p)				\
 	do {					\
 		list_del(PAGE_TO_LIST(p));	\
 		p->mapping = NULL;		\
-		p->u.private = 0;		\
+		p->private = 0;			\
 	} while(0)
 
 #define IPRINTK(fmt, args...) \
Index: head-2006-02-07/drivers/xen/blkfront/blkfront.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/blkfront/blkfront.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/blkfront/blkfront.c	2006-02-08 12:54:20.000000000 +0100
@@ -642,7 +642,7 @@ static irqreturn_t blkif_int(int irq, vo
 
 	for (i = info->ring.rsp_cons; i != rp; i++) {
 		unsigned long id;
-		int ret;
+		int ret, uptodate;
 
 		bret = RING_GET_RESPONSE(&info->ring, i);
 		id   = bret->id;
@@ -659,11 +659,12 @@ static irqreturn_t blkif_int(int irq, vo
 				DPRINTK("Bad return from blkdev data "
 					"request: %x\n", bret->status);
 
+			uptodate = (bret->status == BLKIF_RSP_OKAY);
 			ret = end_that_request_first(
-				req, (bret->status == BLKIF_RSP_OKAY),
+				req, uptodate,
 				req->hard_nr_sectors);
 			BUG_ON(ret);
-			end_that_request_last(req);
+			end_that_request_last(req, uptodate);
 			break;
 		default:
 			BUG();
Index: head-2006-02-07/drivers/xen/char/mem.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/char/mem.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/char/mem.c	2006-01-19 09:25:48.000000000 +0100
@@ -114,7 +114,7 @@ static loff_t memory_lseek(struct file *
 {
 	loff_t ret;
 
-	down(&file->f_dentry->d_inode->i_sem);
+	mutex_lock(&file->f_dentry->d_inode->i_mutex);
 	switch (orig) {
 		case 0:
 			file->f_pos = offset;
@@ -129,7 +129,7 @@ static loff_t memory_lseek(struct file *
 		default:
 			ret = -EINVAL;
 	}
-	up(&file->f_dentry->d_inode->i_sem);
+	mutex_unlock(&file->f_dentry->d_inode->i_mutex);
 	return ret;
 }
 
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/synch_bitops.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/synch_bitops.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/synch_bitops.h	2006-02-08 12:54:28.000000000 +0100
@@ -15,21 +15,21 @@ static __inline__ void synch_set_bit(int
 {
     __asm__ __volatile__ ( 
         "lock btsl %1,%0"
-        : "=m" (ADDR) : "Ir" (nr) : "memory" );
+        : "+m" (ADDR) : "Ir" (nr) : "memory" );
 }
 
 static __inline__ void synch_clear_bit(int nr, volatile void * addr)
 {
     __asm__ __volatile__ (
         "lock btrl %1,%0"
-        : "=m" (ADDR) : "Ir" (nr) : "memory" );
+        : "+m" (ADDR) : "Ir" (nr) : "memory" );
 }
 
 static __inline__ void synch_change_bit(int nr, volatile void * addr)
 {
     __asm__ __volatile__ (
         "lock btcl %1,%0"
-        : "=m" (ADDR) : "Ir" (nr) : "memory" );
+        : "+m" (ADDR) : "Ir" (nr) : "memory" );
 }
 
 static __inline__ int synch_test_and_set_bit(int nr, volatile void * addr)
@@ -37,7 +37,7 @@ static __inline__ int synch_test_and_set
     int oldbit;
     __asm__ __volatile__ (
         "lock btsl %2,%1\n\tsbbl %0,%0"
-        : "=r" (oldbit), "=m" (ADDR) : "Ir" (nr) : "memory");
+        : "=r" (oldbit), "+m" (ADDR) : "Ir" (nr) : "memory");
     return oldbit;
 }
 
@@ -46,7 +46,7 @@ static __inline__ int synch_test_and_cle
     int oldbit;
     __asm__ __volatile__ (
         "lock btrl %2,%1\n\tsbbl %0,%0"
-        : "=r" (oldbit), "=m" (ADDR) : "Ir" (nr) : "memory");
+        : "=r" (oldbit), "+m" (ADDR) : "Ir" (nr) : "memory");
     return oldbit;
 }
 
@@ -56,7 +56,7 @@ static __inline__ int synch_test_and_cha
 
     __asm__ __volatile__ (
         "lock btcl %2,%1\n\tsbbl %0,%0"
-        : "=r" (oldbit), "=m" (ADDR) : "Ir" (nr) : "memory");
+        : "=r" (oldbit), "+m" (ADDR) : "Ir" (nr) : "memory");
     return oldbit;
 }
 
@@ -85,7 +85,7 @@ static inline unsigned long __synch_cmpx
 	case 2:
 		__asm__ __volatile__("lock; cmpxchgw %w1,%2"
 				     : "=a"(prev)
-				     : "q"(new), "m"(*__synch_xg(ptr)),
+				     : "r"(new), "m"(*__synch_xg(ptr)),
 				       "0"(old)
 				     : "memory");
 		return prev;
@@ -93,14 +93,14 @@ static inline unsigned long __synch_cmpx
 	case 4:
 		__asm__ __volatile__("lock; cmpxchgl %k1,%2"
 				     : "=a"(prev)
-				     : "q"(new), "m"(*__synch_xg(ptr)),
+				     : "r"(new), "m"(*__synch_xg(ptr)),
 				       "0"(old)
 				     : "memory");
 		return prev;
 	case 8:
 		__asm__ __volatile__("lock; cmpxchgq %1,%2"
 				     : "=a"(prev)
-				     : "q"(new), "m"(*__synch_xg(ptr)),
+				     : "r"(new), "m"(*__synch_xg(ptr)),
 				       "0"(old)
 				     : "memory");
 		return prev;
@@ -108,7 +108,7 @@ static inline unsigned long __synch_cmpx
 	case 4:
 		__asm__ __volatile__("lock; cmpxchgl %1,%2"
 				     : "=a"(prev)
-				     : "q"(new), "m"(*__synch_xg(ptr)),
+				     : "r"(new), "m"(*__synch_xg(ptr)),
 				       "0"(old)
 				     : "memory");
 		return prev;
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/desc.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/desc.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/desc.h	2006-02-08 12:54:19.000000000 +0100
@@ -13,9 +13,7 @@
 
 #include <asm/mmu.h>
 
-extern struct desc_struct cpu_gdt_table[NR_CPUS][GDT_ENTRIES];
-
-#define get_cpu_gdt_table(_cpu) ((struct desc_struct *)cpu_gdt_descr[(_cpu)].address)
+extern struct desc_struct cpu_gdt_table[GDT_ENTRIES];
 
 DECLARE_PER_CPU(unsigned char, cpu_16bit_stack[CPU_16BIT_STACK_SIZE]);
 
@@ -27,6 +25,11 @@ struct Xgt_desc_struct {
 
 extern struct Xgt_desc_struct idt_descr, cpu_gdt_descr[NR_CPUS];
 
+static inline struct desc_struct *get_cpu_gdt_table(unsigned int cpu)
+{
+	return ((struct desc_struct *)cpu_gdt_descr[cpu].address);
+}
+
 #define load_TR_desc() __asm__ __volatile__("ltr %w0"::"q" (GDT_ENTRY_TSS*8))
 #define load_LDT_desc() __asm__ __volatile__("lldt %w0"::"q" (GDT_ENTRY_LDT*8))
 
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/dma-mapping.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/dma-mapping.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/dma-mapping.h	2006-01-19 09:25:48.000000000 +0100
@@ -126,7 +126,7 @@ dma_get_cache_alignment(void)
 {
 	/* no easy way to get cache size on all x86, so return the
 	 * maximum possible, to be safe */
-	return (1 << L1_CACHE_SHIFT_MAX);
+	return (1 << INTERNODE_CACHE_SHIFT);
 }
 #else
 extern int dma_get_cache_alignment(void);
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/io.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/io.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/io.h	2006-01-19 09:25:48.000000000 +0100
@@ -143,6 +143,11 @@ extern void iounmap(volatile void __iome
 extern void *bt_ioremap(unsigned long offset, unsigned long size);
 extern void bt_iounmap(void *addr, unsigned long size);
 
+/* Use early IO mappings for DMI because it's initialized early */
+#define dmi_ioremap bt_ioremap
+#define dmi_iounmap bt_iounmap
+#define dmi_alloc alloc_bootmem
+
 /*
  * ISA I/O bus memory addresses are 1:1 with the physical address.
  */
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/processor.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/processor.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/processor.h	2006-02-08 12:54:29.000000000 +0100
@@ -62,9 +62,11 @@ struct cpuinfo_x86 {
 	int 	x86_cache_size;  /* in KB - valid for CPUS which support this
 				    call  */
 	int 	x86_cache_alignment;	/* In bytes */
-	int	fdiv_bug;
-	int	f00f_bug;
-	int	coma_bug;
+	char	fdiv_bug;
+	char	f00f_bug;
+	char	coma_bug;
+	char	pad0;
+	int	x86_power;
 	unsigned long loops_per_jiffy;
 	unsigned char x86_max_cores;	/* cpuid returned max cores value */
 	unsigned char booted_cores;	/* number of cores as seen by OS */
@@ -290,9 +292,11 @@ static inline void clear_in_cr4 (unsigne
 	outb((data), 0x23); \
 } while (0)
 
-static inline void serialize_cpu(void)
+/* Stop speculative execution */
+static inline void sync_core(void)
 {
-	 __asm__ __volatile__ ("cpuid" : : : "ax", "bx", "cx", "dx");
+	int tmp;
+	asm volatile("cpuid" : "=a" (tmp) : "0" (1) : "ebx","ecx","edx","memory");
 }
 
 static inline void __monitor(const void *eax, unsigned long ecx,
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/ptrace.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/ptrace.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/ptrace.h	2006-01-19 09:25:48.000000000 +0100
@@ -54,6 +54,9 @@ struct pt_regs {
 #define PTRACE_GET_THREAD_AREA    25
 #define PTRACE_SET_THREAD_AREA    26
 
+#define PTRACE_SYSEMU		  31
+#define PTRACE_SYSEMU_SINGLESTEP  32
+
 #ifdef __KERNEL__
 
 #include <asm/vm86.h>
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/segment.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/segment.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/segment.h	2006-01-19 09:25:48.000000000 +0100
@@ -89,6 +89,20 @@
 
 #define __BOOT_DS	FLAT_KERNEL_DS
 
+/* The PnP BIOS entries in the GDT */
+#define GDT_ENTRY_PNPBIOS_CS32		(GDT_ENTRY_PNPBIOS_BASE + 0)
+#define GDT_ENTRY_PNPBIOS_CS16		(GDT_ENTRY_PNPBIOS_BASE + 1)
+#define GDT_ENTRY_PNPBIOS_DS		(GDT_ENTRY_PNPBIOS_BASE + 2)
+#define GDT_ENTRY_PNPBIOS_TS1		(GDT_ENTRY_PNPBIOS_BASE + 3)
+#define GDT_ENTRY_PNPBIOS_TS2		(GDT_ENTRY_PNPBIOS_BASE + 4)
+
+/* The PnP BIOS selectors */
+#define PNP_CS32   (GDT_ENTRY_PNPBIOS_CS32 * 8)	/* segment for calling fn */
+#define PNP_CS16   (GDT_ENTRY_PNPBIOS_CS16 * 8)	/* code segment for BIOS */
+#define PNP_DS     (GDT_ENTRY_PNPBIOS_DS * 8)	/* data segment for BIOS */
+#define PNP_TS1    (GDT_ENTRY_PNPBIOS_TS1 * 8)	/* transfer data segment */
+#define PNP_TS2    (GDT_ENTRY_PNPBIOS_TS2 * 8)	/* another data segment */
+
 /*
  * The interrupt descriptor table has room for 256 idt's,
  * the global descriptor table is dependent on the number
Index: head-2006-02-07/include/asm-i386/mach-xen/asm/system.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/mach-xen/asm/system.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/mach-xen/asm/system.h	2006-02-08 12:54:29.000000000 +0100
@@ -57,23 +57,7 @@ __asm__ __volatile__ ("movw %%dx,%1\n\t"
         ); } while(0)
 
 #define set_base(ldt,base) _set_base( ((char *)&(ldt)) , (base) )
-#define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , ((limit)-1)>>12 )
-
-static inline unsigned long _get_base(char * addr)
-{
-	unsigned long __base;
-	__asm__("movb %3,%%dh\n\t"
-		"movb %2,%%dl\n\t"
-		"shll $16,%%edx\n\t"
-		"movw %1,%%dx"
-		:"=&d" (__base)
-		:"m" (*((addr)+2)),
-		 "m" (*((addr)+4)),
-		 "m" (*((addr)+7)));
-	return __base;
-}
-
-#define get_base(ldt) _get_base( ((char *)&(ldt)) )
+#define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , ((limit)-1) )
 
 /*
  * Load a segment. Fall back on loading the zero
@@ -139,6 +123,9 @@ static inline unsigned long _get_base(ch
 		:"=r" (__dummy)); \
 	__dummy; \
 })
+
+#define read_cr4_safe() read_cr4()
+
 #define write_cr4(x) \
 	__asm__ __volatile__("movl %0,%%cr4": :"r" (x));
 
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/desc.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/desc.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/desc.h	2006-02-08 12:54:19.000000000 +0100
@@ -67,9 +67,7 @@ struct desc_ptr {
 
 extern struct desc_ptr idt_descr, cpu_gdt_descr[NR_CPUS];
 
-extern struct desc_struct cpu_gdt_table[NR_CPUS][GDT_ENTRIES];
-
-#define get_cpu_gdt_table(_cpu) ((struct desc_struct *)(cpu_gdt_descr[(_cpu)].address))
+extern struct desc_struct cpu_gdt_table[GDT_ENTRIES];
 
 #define load_TR_desc() asm volatile("ltr %w0"::"r" (GDT_ENTRY_TSS*8))
 #define load_LDT_desc() asm volatile("lldt %w0"::"r" (GDT_ENTRY_LDT*8))
@@ -95,6 +93,9 @@ extern struct desc_struct default_ldt[];
 extern struct gate_struct idt_table[]; 
 extern struct desc_ptr cpu_gdt_descr[];
 
+/* the cpu gdt accessor */
+#define cpu_gdt(_cpu) ((struct desc_struct *)cpu_gdt_descr[_cpu].address)
+
 static inline void _set_gate(void *adr, unsigned type, unsigned long func, unsigned dpl, unsigned ist)  
 {
 	struct gate_struct s; 	
@@ -130,6 +131,11 @@ static inline void set_system_gate(int n
 	_set_gate(&idt_table[nr], GATE_INTERRUPT, (unsigned long) func, 3, 0); 
 } 
 
+static inline void set_system_gate_ist(int nr, void *func, unsigned ist)
+{
+	_set_gate(&idt_table[nr], GATE_INTERRUPT, (unsigned long) func, 3, ist);
+}
+
 static inline void set_tssldt_descriptor(void *ptr, unsigned long tss, unsigned type, 
 					 unsigned size) 
 { 
@@ -155,21 +161,21 @@ static inline void set_tss_desc(unsigned
 	 * -1? seg base+limit should be pointing to the address of the
 	 * last valid byte
 	 */
-        set_tssldt_descriptor((struct ldttss_desc *)&get_cpu_gdt_table(cpu)[GDT_ENTRY_TSS], 
+        set_tssldt_descriptor((struct ldttss_desc *)&cpu_gdt(cpu)[GDT_ENTRY_TSS],
 		(unsigned long)addr, DESC_TSS,
 		IO_BITMAP_OFFSET + IO_BITMAP_BYTES + sizeof(unsigned long) - 1);
 } 
 
 static inline void set_ldt_desc(unsigned cpu, void *addr, int size)
 { 
-	set_tssldt_descriptor((struct ldttss_desc *)&get_cpu_gdt_table(cpu)[GDT_ENTRY_LDT], 
+	set_tssldt_descriptor((struct ldttss_desc *)&cpu_gdt(cpu)[GDT_ENTRY_LDT],
                               (unsigned long)addr, 
 			      DESC_LDT, size * 8 - 1);
 }
 
 static inline void set_seg_base(unsigned cpu, int entry, void *base)
 { 
-	struct desc_struct *d = (struct desc_struct *)&get_cpu_gdt_table(cpu)[entry];
+	struct desc_struct *d = (struct desc_struct *)&cpu_gdt(cpu)[entry];
 	u32 addr = (u32)(u64)base;
 	BUG_ON((u64)base >> 32); 
 	d->base0 = addr & 0xffff;
@@ -212,13 +218,13 @@ static inline void set_seg_base(unsigned
 static inline void load_TLS(struct thread_struct *t, unsigned int cpu)
 {
 #if 0
-	u64 *gdt = (u64 *)(cpu_gdt_table[cpu] + GDT_ENTRY_TLS_MIN);
+	u64 *gdt = (u64 *)(cpu_gdt(cpu) + GDT_ENTRY_TLS_MIN);
 	gdt[0] = t->tls_array[0];
 	gdt[1] = t->tls_array[1];
 	gdt[2] = t->tls_array[2];
 #endif
 #define C(i) \
-	HYPERVISOR_update_descriptor(virt_to_machine(&get_cpu_gdt_table(cpu)[GDT_ENTRY_TLS_MIN + i]), t->tls_array[i])
+	HYPERVISOR_update_descriptor(virt_to_machine(&cpu_gdt(cpu)[GDT_ENTRY_TLS_MIN + i]), t->tls_array[i])
 
 	C(0); C(1); C(2);
 #undef C
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/hw_irq.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/hw_irq.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/hw_irq.h	2006-01-19 09:25:48.000000000 +0100
@@ -46,19 +46,19 @@ struct hw_interrupt_type;
  *  some of the following vectors are 'rare', they are merged
  *  into a single vector (CALL_FUNCTION_VECTOR) to save vector space.
  *  TLB, reschedule and local APIC vectors are performance-critical.
- *
- *  Vectors 0xf0-0xf9 are free (reserved for future Linux use).
  */
 #ifndef CONFIG_XEN
 #define SPURIOUS_APIC_VECTOR	0xff
 #define ERROR_APIC_VECTOR	0xfe
 #define RESCHEDULE_VECTOR	0xfd
 #define CALL_FUNCTION_VECTOR	0xfc
-#define KDB_VECTOR		0xfb	/* reserved for KDB */
+/* fb free - please don't readd KDB here because it's useless
+   (hint - think what a NMI bit does to a vector) */
 #define THERMAL_APIC_VECTOR	0xfa
 #define THRESHOLD_APIC_VECTOR   0xf9
-#define INVALIDATE_TLB_VECTOR_END	0xf8
-#define INVALIDATE_TLB_VECTOR_START	0xf0	/* f0-f8 used for TLB flush */
+/* f8 free */
+#define INVALIDATE_TLB_VECTOR_END	0xf7
+#define INVALIDATE_TLB_VECTOR_START	0xf0	/* f0-f7 used for TLB flush */
 
 #define NUM_INVALIDATE_TLB_VECTORS	8
 #endif
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/io.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/io.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/io.h	2006-01-19 09:25:48.000000000 +0100
@@ -158,6 +158,11 @@ static inline void __iomem * ioremap (un
 extern void __iomem * ioremap_nocache (unsigned long offset, unsigned long size);
 extern void iounmap(volatile void __iomem *addr);
 
+/* Use normal IO mappings for DMI */
+#define dmi_ioremap ioremap
+#define dmi_iounmap(x,l) iounmap(x)
+#define dmi_alloc(l) kmalloc(l, GFP_ATOMIC)
+
 /*
  * ISA I/O bus memory addresses are 1:1 with the physical address.
  */
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/mmu_context.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/mmu_context.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/mmu_context.h	2006-01-19 09:25:48.000000000 +0100
@@ -18,7 +18,7 @@ void destroy_context(struct mm_struct *m
 
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
 {
-#if 0 /*  XEN: no lazy tlb */
+#if defined(CONFIG_SMP) && !defined(CONFIG_XEN)
 	if (read_pda(mmu_state) == TLBSTATE_OK) 
 		write_pda(mmu_state, TLBSTATE_LAZY);
 #endif
@@ -72,7 +72,7 @@ static inline void switch_mm(struct mm_s
 
 		/* stop flush ipis for the previous mm */
 		clear_bit(cpu, &prev->cpu_vm_mask);
-#if 0  /* XEN: no lazy tlb */
+#if defined(CONFIG_SMP) && !defined(CONFIG_XEN)
 		write_pda(mmu_state, TLBSTATE_OK);
 		write_pda(active_mm, next);
 #endif
@@ -99,8 +99,7 @@ static inline void switch_mm(struct mm_s
 
 		BUG_ON(HYPERVISOR_mmuext_op(_op, op-_op, NULL, DOMID_SELF));
 	}
-
-#if 0 /* XEN: no lazy tlb */
+#if defined(CONFIG_SMP) && !defined(CONFIG_XEN)
 	else {
 		write_pda(mmu_state, TLBSTATE_OK);
 		if (read_pda(active_mm) != next)
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/page.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/page.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/page.h	2006-02-08 12:54:28.000000000 +0100
@@ -34,13 +34,18 @@
 #define PHYSICAL_PAGE_MASK	(~(PAGE_SIZE-1) & __PHYSICAL_MASK)
 
 #define THREAD_ORDER 1 
-#ifdef __ASSEMBLY__
-#define THREAD_SIZE  (1 << (PAGE_SHIFT + THREAD_ORDER))
-#else
-#define THREAD_SIZE  (1UL << (PAGE_SHIFT + THREAD_ORDER))
-#endif
+#define THREAD_SIZE  (PAGE_SIZE << THREAD_ORDER)
 #define CURRENT_MASK (~(THREAD_SIZE-1))
 
+#define EXCEPTION_STACK_ORDER 0
+#define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
+
+#define DEBUG_STACK_ORDER EXCEPTION_STACK_ORDER
+#define DEBUG_STKSZ (PAGE_SIZE << DEBUG_STACK_ORDER)
+
+#define IRQSTACK_ORDER 2
+#define IRQSTACKSIZE (PAGE_SIZE << IRQSTACK_ORDER)
+
 #define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
 #define LARGE_PAGE_SIZE (1UL << PMD_SHIFT)
 
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/pci.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/pci.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/pci.h	2006-01-19 09:25:48.000000000 +0100
@@ -42,18 +42,20 @@ int pcibios_set_irq_routing(struct pci_d
 #include <asm/scatterlist.h>
 #include <linux/string.h>
 #include <asm/page.h>
+#include <linux/dma-mapping.h> /* for have_iommu */
 
 extern int iommu_setup(char *opt);
 
-#ifdef CONFIG_GART_IOMMU
 /* The PCI address space does equal the physical memory
  * address space.  The networking and block device layers use
  * this boolean for bounce buffer decisions
  *
- * On AMD64 it mostly equals, but we set it to zero to tell some subsystems
- * that an IOMMU is available.
+ * On AMD64 it mostly equals, but we set it to zero if a hardware
+ * IOMMU (gart) of sotware IOMMU (swiotlb) is available.
  */
-#define PCI_DMA_BUS_IS_PHYS	(no_iommu ? 1 : 0)
+#define PCI_DMA_BUS_IS_PHYS (dma_ops->is_phys)
+
+#ifdef CONFIG_GART_IOMMU
 
 /*
  * x86-64 always supports DAC, but sometimes it is useful to force
@@ -78,6 +80,7 @@ extern int iommu_sac_force;
 
 #elif defined(CONFIG_SWIOTLB)
 
+#undef PCI_DMA_BUS_IS_PHYS
 #define PCI_DMA_BUS_IS_PHYS	0
 
 #define pci_dac_dma_supported(pci_dev, mask)    1
@@ -98,7 +101,9 @@ extern int iommu_sac_force;
 #else
 /* No IOMMU */
 
-#define PCI_DMA_BUS_IS_PHYS	1
+#undef PCI_DMA_BUS_IS_PHYS
+#define PCI_DMA_BUS_IS_PHYS 1
+
 #define pci_dac_dma_supported(pci_dev, mask)    1
 
 #define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME)
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/pgtable.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/pgtable.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/pgtable.h	2006-02-08 12:54:20.000000000 +0100
@@ -160,6 +160,8 @@ static inline pte_t ptep_get_and_clear_f
 
 #define pte_same(a, b)		((a).pte == (b).pte)
 
+#define pte_pgprot(a)	(__pgprot((a).pte & ~PHYSICAL_PAGE_MASK))
+
 #define PMD_SIZE	(1UL << PMD_SHIFT)
 #define PMD_MASK	(~(PMD_SIZE-1))
 #define PUD_SIZE	(1UL << PUD_SHIFT)
@@ -350,25 +352,25 @@ static inline pte_t pfn_pte(unsigned lon
 
 #define __LARGE_PTE (_PAGE_PSE|_PAGE_PRESENT)
 static inline int pte_user(pte_t pte)		{ return __pte_val(pte) & _PAGE_USER; }
-extern inline int pte_read(pte_t pte)		{ return __pte_val(pte) & _PAGE_USER; }
-extern inline int pte_exec(pte_t pte)		{ return __pte_val(pte) & _PAGE_USER; }
-extern inline int pte_dirty(pte_t pte)		{ return __pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return __pte_val(pte) & _PAGE_ACCESSED; }
-extern inline int pte_write(pte_t pte)		{ return __pte_val(pte) & _PAGE_RW; }
+static inline int pte_read(pte_t pte)		{ return __pte_val(pte) & _PAGE_USER; }
+static inline int pte_exec(pte_t pte)		{ return __pte_val(pte) & _PAGE_USER; }
+static inline int pte_dirty(pte_t pte)		{ return __pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return __pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return __pte_val(pte) & _PAGE_RW; }
 static inline int pte_file(pte_t pte)		{ return __pte_val(pte) & _PAGE_FILE; }
 static inline int pte_huge(pte_t pte)		{ return (__pte_val(pte) & __LARGE_PTE) == __LARGE_PTE; }
 
-extern inline pte_t pte_rdprotect(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_USER; return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_USER; return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_wrprotect(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_RW; return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ __pte_val(pte) |= _PAGE_USER; return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ __pte_val(pte) |= _PAGE_USER; return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ __pte_val(pte) |= _PAGE_DIRTY; return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ __pte_val(pte) |= _PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ __pte_val(pte) |= _PAGE_RW; return pte; }
-extern inline pte_t pte_mkhuge(pte_t pte)	{ __pte_val(pte) |= __LARGE_PTE; return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_USER; return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_USER; return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ __pte_val(pte) &= ~_PAGE_RW; return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ __pte_val(pte) |= _PAGE_USER; return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ __pte_val(pte) |= _PAGE_USER; return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ __pte_val(pte) |= _PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ __pte_val(pte) |= _PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ __pte_val(pte) |= _PAGE_RW; return pte; }
+static inline pte_t pte_mkhuge(pte_t pte)	{ __pte_val(pte) |= __LARGE_PTE; return pte; }
 
 struct vm_area_struct;
 
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/processor.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/processor.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/processor.h	2006-02-08 12:54:29.000000000 +0100
@@ -251,7 +251,13 @@ extern struct cpuinfo_x86 boot_cpu_data;
 DECLARE_PER_CPU(struct tss_struct,init_tss);
 DECLARE_PER_CPU(pgd_t *, cur_pgd);
 
+#ifdef CONFIG_X86_VSMP
+#define ARCH_MIN_TASKALIGN	(1 << INTERNODE_CACHE_SHIFT)
+#define ARCH_MIN_MMSTRUCT_ALIGN	(1 << INTERNODE_CACHE_SHIFT)
+#else
 #define ARCH_MIN_TASKALIGN	16
+#define ARCH_MIN_MMSTRUCT_ALIGN	0
+#endif
 
 struct thread_struct {
 	unsigned long	rsp0;
@@ -298,8 +304,6 @@ struct thread_struct {
 #define DEBUG_STACK 4 
 #define MCE_STACK 5
 #define N_EXCEPTION_STACKS 5  /* hw limit: 7 */
-#define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
-#define EXCEPTION_STACK_ORDER 0 
 
 #define start_thread(regs,new_rip,new_rsp) do { \
 	asm volatile("movl %0,%%fs; movl %0,%%es; movl %0,%%ds": :"r" (0));	 \
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/segment.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/segment.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/segment.h	2006-01-19 09:25:48.000000000 +0100
@@ -19,15 +19,13 @@
 #define __USER_DS     0x2b   /* 5*8+3 */ 
 #define __USER_CS     0x33   /* 6*8+3 */ 
 #define __USER32_DS	__USER_DS 
-#define __KERNEL16_CS	(GDT_ENTRY_KERNELCS16 * 8)
-#define __KERNEL_COMPAT32_CS   0x8
 
 #define GDT_ENTRY_TLS 1
 #define GDT_ENTRY_TSS 8	/* needs two entries */
 #define GDT_ENTRY_LDT 10 /* needs two entries */
 #define GDT_ENTRY_TLS_MIN 12
 #define GDT_ENTRY_TLS_MAX 14
-#define GDT_ENTRY_KERNELCS16 15
+/* 15 free */
 
 #define GDT_ENTRY_TLS_ENTRIES 3
 
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/smp.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/smp.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/smp.h	2006-01-19 09:25:48.000000000 +0100
@@ -34,6 +34,7 @@ struct pt_regs;
 extern cpumask_t cpu_present_mask;
 extern cpumask_t cpu_possible_map;
 extern cpumask_t cpu_online_map;
+extern cpumask_t cpu_initialized;
 
 /*
  * Private routines/data
Index: head-2006-02-07/include/asm-x86_64/mach-xen/asm/system.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/mach-xen/asm/system.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/mach-xen/asm/system.h	2006-02-08 12:54:29.000000000 +0100
@@ -23,8 +23,8 @@
 #define __RESTORE(reg,offset) "movq (14-" #offset ")*8(%%rsp),%%" #reg "\n\t"
 
 /* frame pointer must be last for get_wchan */
-#define SAVE_CONTEXT    "pushfq ; pushq %%rbp ; movq %%rsi,%%rbp\n\t"
-#define RESTORE_CONTEXT "movq %%rbp,%%rsi ; popq %%rbp ; popfq\n\t" 
+#define SAVE_CONTEXT    "pushq %%rbp ; movq %%rsi,%%rbp\n\t"
+#define RESTORE_CONTEXT "movq %%rbp,%%rsi ; popq %%rbp\n\t"
 
 #define __EXTRA_CLOBBER  \
 	,"rcx","rbx","rdx","r8","r9","r10","r11","r12","r13","r14","r15"
@@ -141,6 +141,21 @@ struct alt_instr { 
 		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ \
 		      ".previous" :: "i" (feature), ##input)
 
+/* Like alternative_input, but with a single output argument */
+#define alternative_io(oldinstr, newinstr, feature, output, input...) \
+	asm volatile ("661:\n\t" oldinstr "\n662:\n"			\
+		      ".section .altinstructions,\"a\"\n"		\
+		      "  .align 8\n"					\
+		      "  .quad 661b\n"            /* label */		\
+		      "  .quad 663f\n"		  /* new instruction */	\
+		      "  .byte %c[feat]\n"        /* feature bit */	\
+		      "  .byte 662b-661b\n"       /* sourcelen */	\
+		      "  .byte 664f-663f\n"       /* replacementlen */	\
+		      ".previous\n"					\
+		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ \
+		      ".previous" : output : [feat] "i" (feature), ##input)
+
 /*
  * Clear and set 'TS' bit respectively
  */
@@ -369,6 +384,7 @@ do {									\
 } while (0)
 
 #define safe_halt()		((void)0)
+#define halt()			((void)0)
 
 #define __save_and_cli(x)						\
 do {									\
@@ -399,13 +415,6 @@ void cpu_idle_wait(void);
 	preempt_enable_no_resched();					\
 	___x; })
 
-/*
- * disable hlt during certain critical i/o operations
- */
-#define HAVE_DISABLE_HLT
-void disable_hlt(void);
-void enable_hlt(void);
-
 extern unsigned long arch_align_stack(unsigned long sp);
 
 #endif
Index: head-2006-02-07/arch/i386/xen/kernel/pci-dma.c
===================================================================
--- head-2006-02-07.orig/arch/i386/xen/kernel/pci-dma.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/i386/xen/kernel/pci-dma.c	2006-01-19 09:25:48.000000000 +0100
@@ -42,6 +42,7 @@ dma_map_sg(struct device *hwdev, struct 
 	int i, rc;
 
 	BUG_ON(direction == DMA_NONE);
+	WARN_ON(nents == 0 || sg[0].length == 0);
 
 	if (swiotlb) {
 		rc = swiotlb_map_sg(hwdev, sg, nents, direction);
@@ -267,6 +268,7 @@ dma_map_single(struct device *dev, void 
 	dma_addr_t dma;
 
 	BUG_ON(direction == DMA_NONE);
+	WARN_ON(size == 0);
 
 	if (swiotlb) {
 		dma = swiotlb_map_single(dev, ptr, size, direction);
Index: head-2006-02-07/drivers/xen/console/console.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/console/console.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/console/console.c	2006-01-19 09:25:48.000000000 +0100
@@ -378,7 +378,7 @@ static irqreturn_t xencons_priv_interrup
 			CONSOLEIO_read, 16, rbuf)) > 0)
 			for (i = 0; i < l; i++)
 				tty_insert_flip_char(xencons_tty, rbuf[i], 0);
-		if (xencons_tty->flip.count != 0)
+		if (xencons_tty->buf.tail && xencons_tty->buf.tail->used != 0)
 			tty_flip_buffer_push(xencons_tty);
 	}
 
Index: head-2006-02-07/drivers/xen/netback/xenbus.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/netback/xenbus.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/netback/xenbus.c	2006-01-19 09:25:48.000000000 +0100
@@ -129,15 +129,15 @@ static int netback_hotplug(struct xenbus
 		return err;
 	}
 	else {
-		add_hotplug_env_var(envp, num_envp, &i,
-				    buffer, buffer_size, &length,
-				    "script=%s", val);
+		add_uevent_var(envp, num_envp, &i,
+			       buffer, buffer_size, &length,
+			       "script=%s", val);
 		kfree(val);
 	}
 
-	add_hotplug_env_var(envp, num_envp, &i,
-			    buffer, buffer_size, &length,
-			    "vif=%s", netif->dev->name);
+	add_uevent_var(envp, num_envp, &i,
+		       buffer, buffer_size, &length,
+		       "vif=%s", netif->dev->name);
 
 	envp[i] = NULL;
 
@@ -183,7 +183,7 @@ static void backend_changed(struct xenbu
 			return;
 		}
 
-		kobject_hotplug(&dev->dev.kobj, KOBJ_ONLINE);
+		kobject_uevent(&dev->dev.kobj, KOBJ_ONLINE);
 
 		maybe_connect(be);
 	}
@@ -216,7 +216,7 @@ static void frontend_changed(struct xenb
 		break;
 
 	case XenbusStateClosed:
-		kobject_hotplug(&dev->dev.kobj, KOBJ_OFFLINE);
+		kobject_uevent(&dev->dev.kobj, KOBJ_OFFLINE);
 		device_unregister(&dev->dev);
 		break;
 
Index: head-2006-02-07/drivers/xen/netfront/netfront.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/netfront/netfront.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/netfront/netfront.c	2006-02-08 12:54:20.000000000 +0100
@@ -34,6 +34,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/errno.h>
+#include <linux/in.h>
 #include <linux/netdevice.h>
 #include <linux/inetdevice.h>
 #include <linux/etherdevice.h>
Index: head-2006-02-07/drivers/xen/xenbus/xenbus_probe.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/xenbus/xenbus_probe.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/xenbus/xenbus_probe.c	2006-01-19 09:25:48.000000000 +0100
@@ -239,13 +239,13 @@ static int xenbus_hotplug_backend(struct
 		return -ENODEV;
 
 	/* stuff we want to pass to /sbin/hotplug */
-	add_hotplug_env_var(envp, num_envp, &i,
-			    buffer, buffer_size, &length,
-			    "XENBUS_TYPE=%s", xdev->devicetype);
-
-	add_hotplug_env_var(envp, num_envp, &i,
-			    buffer, buffer_size, &length,
-			    "XENBUS_PATH=%s", xdev->nodename);
+	add_uevent_var(envp, num_envp, &i,
+		       buffer, buffer_size, &length,
+		       "XENBUS_TYPE=%s", xdev->devicetype);
+
+	add_uevent_var(envp, num_envp, &i,
+		       buffer, buffer_size, &length,
+		       "XENBUS_PATH=%s", xdev->nodename);
 
 	/* terminate, set to next free slot, shrink available space */
 	envp[i] = NULL;
@@ -270,7 +270,7 @@ static struct xen_bus_type xenbus_backen
 	.bus = {
 		.name  = "xen-backend",
 		.match = xenbus_match,
-		.hotplug = xenbus_hotplug_backend,
+		.uevent = xenbus_hotplug_backend,
 	},
 	.dev = {
 		.bus_id = "xen-backend",
Index: head-2006-02-07/arch/x86_64/Kconfig
===================================================================
--- head-2006-02-07.orig/arch/x86_64/Kconfig	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/arch/x86_64/Kconfig	2006-02-08 12:54:20.000000000 +0100
@@ -122,7 +122,6 @@ endchoice
 config X86_64_XEN
 	bool "Enable Xen compatible kernel"
 	select SWIOTLB if XEN_PHYSDEV_ACCESS
-	select DUMMY_IOMMU if XEN_PHYSDEV_ACCESS
 	help
 	  This option will compile a kernel compatible with Xen hypervisor
 
Index: head-2006-02-07/drivers/xen/core/smpboot.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/core/smpboot.c	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/drivers/xen/core/smpboot.c	2006-02-08 12:54:20.000000000 +0100
@@ -188,7 +188,7 @@ void vcpu_prepare(int vcpu)
 
 	ctxt.ctrlreg[3] = virt_to_mfn(init_level4_pgt) << PAGE_SHIFT;
 
-	ctxt.gs_base_kernel = (unsigned long)(cpu_pda + vcpu);
+	ctxt.gs_base_kernel = (unsigned long)cpu_pda(vcpu);
 #endif
 
 	BUG_ON(HYPERVISOR_vcpu_op(VCPUOP_initialise, vcpu, &ctxt));
@@ -226,8 +226,8 @@ void __init smp_prepare_cpus(unsigned in
 			panic("failed fork for CPU %d", cpu);
 
 #ifdef __x86_64__
-		cpu_pda[cpu].pcurrent = idle;
-		cpu_pda[cpu].cpunumber = cpu;
+		cpu_pda(cpu)->pcurrent = idle;
+		cpu_pda(cpu)->cpunumber = cpu;
 		per_cpu(init_tss,cpu).rsp0 = idle->thread.rsp;
 		clear_ti_thread_flag(idle->thread_info, TIF_FORK);
 #endif
Index: head-2006-02-07/include/asm-i386/apic.h
===================================================================
--- head-2006-02-07.orig/include/asm-i386/apic.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-i386/apic.h	2006-01-19 09:25:48.000000000 +0100
@@ -132,10 +132,12 @@ extern unsigned int nmi_watchdog;
 
 extern int disable_timer_pin_1;
 
+#ifndef CONFIG_XEN
 void smp_send_timer_broadcast_ipi(struct pt_regs *regs);
 void switch_APIC_timer_to_ipi(void *cpumask);
 void switch_ipi_to_APIC_timer(void *cpumask);
 #define ARCH_APICTIMER_STOPS_ON_C3	1
+#endif
 
 #else /* !CONFIG_X86_LOCAL_APIC */
 static inline void lapic_shutdown(void) { }
Index: head-2006-02-07/include/asm-x86_64/apic.h
===================================================================
--- head-2006-02-07.orig/include/asm-x86_64/apic.h	2006-02-08 12:29:07.000000000 +0100
+++ head-2006-02-07/include/asm-x86_64/apic.h	2006-01-19 09:25:48.000000000 +0100
@@ -105,11 +105,13 @@ extern int disable_timer_pin_1;
 
 extern void setup_threshold_lvt(unsigned long lvt_off);
 
+#ifndef CONFIG_XEN
 void smp_send_timer_broadcast_ipi(void);
 void switch_APIC_timer_to_ipi(void *cpumask);
 void switch_ipi_to_APIC_timer(void *cpumask);
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
+#endif
 
 #endif /* CONFIG_X86_LOCAL_APIC */
 
Index: head-2006-02-07/drivers/xen/core/evtchn.c
===================================================================
--- head-2006-02-07.orig/drivers/xen/core/evtchn.c	2006-02-07 12:06:47.000000000 +0100
+++ head-2006-02-07/drivers/xen/core/evtchn.c	2006-02-08 12:54:46.000000000 +0100
@@ -123,8 +123,10 @@ static void init_evtchn_cpu_bindings(voi
 #ifdef CONFIG_X86
 extern fastcall unsigned int do_IRQ(struct pt_regs *regs);
 #if defined (__i386__)
+static inline void exit_idle(void) {}
 #define IRQ_REG orig_eax
 #elif defined (__x86_64__)
+#include <asm/idle.h>
 #define IRQ_REG orig_rax
 #endif
 #define do_IRQ(irq, regs) do {			\
@@ -171,8 +173,10 @@ asmlinkage void evtchn_do_upcall(struct 
 			port = (l1i * BITS_PER_LONG) + l2i;
 			if ((irq = evtchn_to_irq[port]) != -1)
 				do_IRQ(irq, regs);
-			else
+			else {
+				exit_idle();
 				evtchn_device_upcall(port);
+			}
 		}
 	}
 }
