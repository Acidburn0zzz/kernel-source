From: jbeulich@novell.com
Subject: Disallow all accesses to the local APIC page
Patch-mainline: obsolete
References: 191115

Index: head-2007-09-03/arch/i386/kernel/acpi/boot-xen.c
===================================================================
--- head-2007-09-03.orig/arch/i386/kernel/acpi/boot-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/i386/kernel/acpi/boot-xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -85,7 +85,7 @@ int acpi_sci_override_gsi __initdata;
 int acpi_skip_timer_override __initdata;
 int acpi_use_timer_override __initdata;
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
 #endif
 
@@ -227,12 +227,14 @@ static int __init acpi_parse_madt(struct
 		return -ENODEV;
 	}
 
+#ifndef CONFIG_XEN
 	if (madt->address) {
 		acpi_lapic_addr = (u64) madt->address;
 
 		printk(KERN_DEBUG PREFIX "Local APIC address 0x%08x\n",
 		       madt->address);
 	}
+#endif
 
 	acpi_madt_oem_check(madt->header.oem_id, madt->header.oem_table_id);
 
@@ -268,6 +270,7 @@ static int __init
 acpi_parse_lapic_addr_ovr(struct acpi_subtable_header * header,
 			  const unsigned long end)
 {
+#ifndef CONFIG_XEN
 	struct acpi_madt_local_apic_override *lapic_addr_ovr = NULL;
 
 	lapic_addr_ovr = (struct acpi_madt_local_apic_override *)header;
@@ -276,6 +279,7 @@ acpi_parse_lapic_addr_ovr(struct acpi_su
 		return -EINVAL;
 
 	acpi_lapic_addr = lapic_addr_ovr->address;
+#endif
 
 	return 0;
 }
@@ -724,7 +728,9 @@ static int __init acpi_parse_madt_lapic_
 		return count;
 	}
 
+#ifndef CONFIG_XEN
 	mp_register_lapic_address(acpi_lapic_addr);
+#endif
 
 	count = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC, acpi_parse_lapic,
 				      MAX_APICS);
Index: head-2007-09-03/arch/i386/kernel/apic-xen.c
===================================================================
--- head-2007-09-03.orig/arch/i386/kernel/apic-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/i386/kernel/apic-xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -1,81 +1,37 @@
 /*
- *	Local APIC handling, local APIC timers
- *
- *	(c) 1999, 2000 Ingo Molnar <mingo@redhat.com>
- *
- *	Fixes
- *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs;
- *					thanks to Eric Gilmore
- *					and Rolf G. Tews
- *					for testing these extensively.
- *	Maciej W. Rozycki	:	Various updates and fixes.
- *	Mikael Pettersson	:	Power Management for UP-APIC.
- *	Pavel Machek and
- *	Mikael Pettersson	:	PM converted to driver model.
+ *	Local APIC handling stubs
  */
 
 #include <linux/init.h>
 
-#include <linux/mm.h>
-#include <linux/delay.h>
-#include <linux/bootmem.h>
-#include <linux/interrupt.h>
-#include <linux/mc146818rtc.h>
-#include <linux/kernel_stat.h>
-#include <linux/sysdev.h>
-#include <linux/cpu.h>
-#include <linux/clockchips.h>
-#include <linux/acpi_pmtmr.h>
-#include <linux/module.h>
-
-#include <asm/atomic.h>
-#include <asm/smp.h>
-#include <asm/mtrr.h>
-#include <asm/mpspec.h>
-#include <asm/desc.h>
-#include <asm/arch_hooks.h>
-#include <asm/hpet.h>
-#include <asm/i8253.h>
-#include <asm/nmi.h>
-
-#include <mach_apic.h>
-#include <mach_apicdef.h>
-#include <mach_ipi.h>
-
-#include "io_ports.h"
-
-#ifndef CONFIG_XEN
-/*
- * cpu_mask that denotes the CPUs that needs timer interrupt coming in as
- * IPIs in place of local APIC timers
- */
-static cpumask_t timer_bcast_ipi;
-#endif
-
-/*
- * Knob to control our willingness to enable the local APIC.
- */
+#include <asm/hw_irq.h>
 
 /*
  * Debug level, exported for io_apic.c
  */
 int apic_verbosity;
 
-#ifndef CONFIG_XEN
-static int modern_apic(void)
+static int __init apic_set_verbosity(char *str)
 {
-	/* AMD systems use old APIC versions, so check the CPU */
-	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&
-	    boot_cpu_data.x86 >= 0xf)
-		return 1;
-	return lapic_get_version() >= 0x14;
+	if (strcmp("debug", str) == 0)
+		apic_verbosity = APIC_DEBUG;
+	else if (strcmp("verbose", str) == 0)
+		apic_verbosity = APIC_VERBOSE;
+	return 1;
 }
-#endif /* !CONFIG_XEN */
 
-int get_physical_broadcast(void)
+__setup("apic=", apic_set_verbosity);
+
+#ifdef CONFIG_X86_64
+/*
+ * 'what should we do if we get a hw irq event on an illegal vector'.
+ * each architecture has to answer this themselves.
+ */
+void ack_bad_irq(unsigned int irq)
 {
-        return 0xff;
+	printk("unexpected IRQ trap at irq %02x\n", irq);
 }
+#endif
 
 int setup_profiling_timer(unsigned int multiplier)
 {
Index: head-2007-09-03/arch/i386/kernel/cpu/amd.c
===================================================================
--- head-2007-09-03.orig/arch/i386/kernel/cpu/amd.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/i386/kernel/cpu/amd.c	2007-09-03 11:34:19.000000000 +0200
@@ -23,7 +23,7 @@
 extern void vide(void);
 __asm__(".align 4\nvide: ret");
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 #define ENABLE_C1E_MASK         0x18000000
 #define CPUID_PROCESSOR_SIGNATURE       1
 #define CPUID_XFAM              0x0ff00000
@@ -63,7 +63,6 @@ static void __cpuinit init_amd(struct cp
 	u32 l, h;
 	int mbytes = num_physpages >> (20-PAGE_SHIFT);
 	int r;
-	extern int local_apic_timer_disabled;
 
 #ifdef CONFIG_SMP
 	unsigned long long value;
@@ -283,9 +282,12 @@ static void __cpuinit init_amd(struct cp
 			num_cache_leaves = 3;
 	}
 
-#ifdef CONFIG_X86_LOCAL_APIC
-	if (amd_apic_timer_broken())
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
+	if (amd_apic_timer_broken()) {
+		extern int local_apic_timer_disabled;
+
 		local_apic_timer_disabled = 1;
+	}
 #endif
 
 	if (c->x86 == 0x10 && !force_mwait)
Index: head-2007-09-03/arch/i386/kernel/io_apic-xen.c
===================================================================
--- head-2007-09-03.orig/arch/i386/kernel/io_apic-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/i386/kernel/io_apic-xen.c	2007-09-17 15:53:58.000000000 +0200
@@ -62,10 +62,10 @@
 unsigned long io_apic_irqs;
 
 #define clear_IO_APIC() ((void)0)
-#endif /* CONFIG_XEN */
-
+#else
 int (*ioapic_renumber_irq)(int ioapic, int irq);
 atomic_t irq_mis_count;
+#endif /* CONFIG_XEN */
 
 /* Where if anywhere is the i8259 connect in external int mode */
 static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
@@ -73,7 +73,9 @@ static struct { int pin, apic; } ioapic_
 static DEFINE_SPINLOCK(ioapic_lock);
 static DEFINE_SPINLOCK(vector_lock);
 
+#ifndef CONFIG_XEN
 int timer_over_8254 __initdata = 1;
+#endif
 
 /*
  *	Is the SiS APIC rmw bug present ?
@@ -86,7 +88,9 @@ int sis_apic_bug = -1;
  */
 int nr_ioapic_registers[MAX_IO_APICS];
 
+#ifndef CONFIG_XEN
 static int disable_timer_pin_1 __initdata;
+#endif
 
 /*
  * Rough estimation of how many shared IRQs there are, can
@@ -1216,12 +1220,13 @@ static int pin_2_irq(int idx, int apic, 
 				irq += nr_ioapic_registers[i++];
 			irq += pin;
 
+#ifndef CONFIG_XEN
 			/*
 			 * For MPS mode, so far only needed by ES7000 platform
 			 */
 			if (ioapic_renumber_irq)
 				irq = ioapic_renumber_irq(apic, irq);
-
+#endif
 			break;
 		}
 		default:
@@ -2394,6 +2399,7 @@ void __init setup_IO_APIC(void)
 		print_IO_APIC();
 }
 
+#ifndef CONFIG_XEN
 static int __init setup_disable_8254_timer(char *s)
 {
 	timer_over_8254 = -1;
@@ -2407,6 +2413,7 @@ static int __init setup_enable_8254_time
 
 __setup("disable_8254_timer", setup_disable_8254_timer);
 __setup("enable_8254_timer", setup_enable_8254_timer);
+#endif
 
 /*
  *	Called after all the initialization is done. If we didnt find any
@@ -2918,6 +2925,7 @@ int io_apic_set_pci_routing (int ioapic,
 
 #endif /* CONFIG_ACPI */
 
+#ifndef CONFIG_XEN
 static int __init parse_disable_timer_pin_1(char *arg)
 {
 	disable_timer_pin_1 = 1;
@@ -2931,6 +2939,7 @@ static int __init parse_enable_timer_pin
 	return 0;
 }
 early_param("enable_timer_pin_1", parse_enable_timer_pin_1);
+#endif
 
 static int __init parse_noapic(char *arg)
 {
Index: head-2007-09-03/arch/i386/kernel/irq-xen.c
===================================================================
--- head-2007-09-03.orig/arch/i386/kernel/irq-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/i386/kernel/irq-xen.c	2007-09-17 15:34:59.000000000 +0200
@@ -243,7 +243,9 @@ EXPORT_SYMBOL(do_softirq);
  * Interrupt statistics:
  */
 
+#ifndef CONFIG_XEN
 atomic_t irq_err_count;
+#endif
 
 /*
  * /proc/interrupts printing:
@@ -289,6 +291,7 @@ skip:
 		for_each_online_cpu(j)
 			seq_printf(p, "%10u ", nmi_count(j));
 		seq_putc(p, '\n');
+#ifndef CONFIG_XEN
 #ifdef CONFIG_X86_LOCAL_APIC
 		seq_printf(p, "LOC: ");
 		for_each_online_cpu(j)
@@ -300,6 +303,7 @@ skip:
 #if defined(CONFIG_X86_IO_APIC)
 		seq_printf(p, "MIS: %10u\n", atomic_read(&irq_mis_count));
 #endif
+#endif
 	}
 	return 0;
 }
Index: head-2007-09-03/arch/i386/kernel/mpparse-xen.c
===================================================================
--- head-2007-09-03.orig/arch/i386/kernel/mpparse-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/i386/kernel/mpparse-xen.c	2007-09-17 15:54:24.000000000 +0200
@@ -61,7 +61,9 @@ int mp_irq_entries;
 int nr_ioapics;
 
 int pic_mode;
+#ifndef CONFIG_XEN
 unsigned long mp_lapic_addr;
+#endif
 
 unsigned int def_to_bigsmp = 0;
 
@@ -412,6 +414,7 @@ static int __init smp_read_mpc(struct mp
 
 	mps_oem_check(mpc, oem, str);
 
+#ifndef CONFIG_XEN
 	printk("APIC at: 0x%lX\n",mpc->mpc_lapic);
 
 	/* 
@@ -420,6 +423,7 @@ static int __init smp_read_mpc(struct mp
 	 */
 	if (!acpi_lapic)
 		mp_lapic_addr = mpc->mpc_lapic;
+#endif
 
 	/*
 	 *	Now process the configuration blocks.
@@ -572,10 +576,12 @@ static inline void __init construct_defa
 	int linttypes[2] = { mp_ExtINT, mp_NMI };
 	int i;
 
+#ifndef CONFIG_XEN
 	/*
 	 * local APIC has default address
 	 */
 	mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
+#endif
 
 	/*
 	 * 2 CPUs, numbered 0 & 1.
@@ -825,9 +831,9 @@ int es7000_plat;
 
 #ifdef CONFIG_ACPI
 
+#ifndef CONFIG_XEN
 void __init mp_register_lapic_address(u64 address)
 {
-#ifndef CONFIG_XEN
 	mp_lapic_addr = (unsigned long) address;
 
 	set_fixmap_nocache(FIX_APIC_BASE, mp_lapic_addr);
@@ -836,8 +842,8 @@ void __init mp_register_lapic_address(u6
 		boot_cpu_physical_apicid = GET_APIC_ID(apic_read(APIC_ID));
 
 	Dprintk("Boot CPU = %d\n", boot_cpu_physical_apicid);
-#endif
 }
+#endif
 
 void __cpuinit mp_register_lapic (u8 id, u8 enabled)
 {
@@ -921,11 +927,11 @@ void __init mp_register_ioapic(u8 id, u3
 
 #ifndef CONFIG_XEN
 	set_fixmap_nocache(FIX_IO_APIC_BASE_0 + idx, address);
-#endif
 	if ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)
 		&& !APIC_XAPIC(apic_version[boot_cpu_physical_apicid]))
 		tmpid = io_apic_get_unique_id(idx, id);
 	else
+#endif
 		tmpid = id;
 	if (tmpid == -1) {
 		nr_ioapics--;
@@ -1089,8 +1095,10 @@ int mp_register_gsi(u32 gsi, int trigger
 
 	ioapic_pin = gsi - mp_ioapic_routing[ioapic].gsi_base;
 
+#ifndef CONFIG_XEN
 	if (ioapic_renumber_irq)
 		gsi = ioapic_renumber_irq(ioapic, gsi);
+#endif
 
 	/* 
 	 * Avoid pin reprogramming.  PRTs typically include entries  
Index: head-2007-09-03/arch/i386/kernel/smp-xen.c
===================================================================
--- head-2007-09-03.orig/arch/i386/kernel/smp-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/i386/kernel/smp-xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -114,6 +114,7 @@ DEFINE_PER_CPU(struct tlb_state, cpu_tlb
  * We use 'broadcast', CPU->CPU IPIs and self-IPIs too.
  */
 
+#ifndef CONFIG_XEN
 static inline int __prepare_ICR (unsigned int shortcut, int vector)
 {
 	unsigned int icr = shortcut | APIC_DEST_LOGICAL;
@@ -133,6 +134,7 @@ static inline int __prepare_ICR2 (unsign
 {
 	return SET_APIC_DEST_FIELD(mask);
 }
+#endif
 
 DECLARE_PER_CPU(int, ipi_to_irq[NR_IPIS]);
 
Index: head-2007-09-03/arch/x86_64/kernel/Makefile
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/Makefile	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/Makefile	2007-09-03 10:01:35.000000000 +0200
@@ -63,12 +63,14 @@ pcspeaker-y			+= ../../i386/kernel/pcspe
 perfctr-watchdog-y		+= ../../i386/kernel/cpu/perfctr-watchdog.o
 
 ifdef CONFIG_XEN
+apic-y				+= ../../i386/kernel/apic-xen.o
 time-y				+= ../../i386/kernel/time-xen.o
 pci-dma-y			+= ../../i386/kernel/pci-dma-xen.o
 microcode-$(subst m,y,$(CONFIG_MICROCODE))  := ../../i386/kernel/microcode-xen.o
 quirks-y			:= ../../i386/kernel/quirks-xen.o
 
-n-obj-xen := early-quirks.o i8259.o reboot.o i8237.o perfctr-watchdog.o smpboot.o trampoline.o tsc.o tsc_sync.o
+n-obj-xen := early-quirks.o genapic_flat.o i8237.o i8259.o perfctr-watchdog.o \
+	reboot.o smpboot.o trampoline.o tsc.o tsc_sync.o
 
 include $(srctree)/scripts/Makefile.xen
 
Index: head-2007-09-03/arch/x86_64/kernel/apic-xen.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/apic-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,198 +0,0 @@
-/*
- *	Local APIC handling, local APIC timers
- *
- *	(c) 1999, 2000 Ingo Molnar <mingo@redhat.com>
- *
- *	Fixes
- *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs;
- *					thanks to Eric Gilmore
- *					and Rolf G. Tews
- *					for testing these extensively.
- *	Maciej W. Rozycki	:	Various updates and fixes.
- *	Mikael Pettersson	:	Power Management for UP-APIC.
- *	Pavel Machek and
- *	Mikael Pettersson	:	PM converted to driver model.
- */
-
-#include <linux/init.h>
-
-#include <linux/mm.h>
-#include <linux/delay.h>
-#include <linux/bootmem.h>
-#include <linux/interrupt.h>
-#include <linux/mc146818rtc.h>
-#include <linux/kernel_stat.h>
-#include <linux/sysdev.h>
-#include <linux/module.h>
-
-#include <asm/atomic.h>
-#include <asm/smp.h>
-#include <asm/mtrr.h>
-#include <asm/mpspec.h>
-#include <asm/desc.h>
-#include <asm/arch_hooks.h>
-#include <asm/hpet.h>
-#include <asm/idle.h>
-
-int apic_verbosity;
-
-/*
- * 'what should we do if we get a hw irq event on an illegal vector'.
- * each architecture has to answer this themselves.
- */
-void ack_bad_irq(unsigned int irq)
-{
-	printk("unexpected IRQ trap at irq %02x\n", irq);
-	/*
-	 * Currently unexpected vectors happen only on SMP and APIC.
-	 * We _must_ ack these because every local APIC has only N
-	 * irq slots per priority level, and a 'hanging, unacked' IRQ
-	 * holds up an irq slot - in excessive cases (when multiple
-	 * unexpected vectors occur) that might lock up the APIC
-	 * completely.
-  	 * But don't ack when the APIC is disabled. -AK
-	 */
-	if (!disable_apic)
-		ack_APIC_irq();
-}
-
-int setup_profiling_timer(unsigned int multiplier)
-{
-	return -EINVAL;
-}
-
-void smp_local_timer_interrupt(void)
-{
-	profile_tick(CPU_PROFILING);
-#ifndef CONFIG_XEN
-#ifdef CONFIG_SMP
-	update_process_times(user_mode(get_irq_regs()));
-#endif
-#endif
-	/*
-	 * We take the 'long' return path, and there every subsystem
-	 * grabs the appropriate locks (kernel lock/ irq lock).
-	 *
-	 * We might want to decouple profiling from the 'long path',
-	 * and do the profiling totally in assembly.
-	 *
-	 * Currently this isn't too much of an issue (performance wise),
-	 * we can take more than 100K local irqs per second on a 100 MHz P5.
-	 */
-}
-
-/*
- * Local APIC timer interrupt. This is the most natural way for doing
- * local interrupts, but local timer interrupts can be emulated by
- * broadcast interrupts too. [in case the hw doesn't support APIC timers]
- *
- * [ if a single-CPU system runs an SMP kernel then we call the local
- *   interrupt as well. Thus we cannot inline the local irq ... ]
- */
-void smp_apic_timer_interrupt(struct pt_regs *regs)
-{
-	struct pt_regs *old_regs = set_irq_regs(regs);
-
-	/*
-	 * the NMI deadlock-detector uses this.
-	 */
-	add_pda(apic_timer_irqs, 1);
-
-	/*
-	 * NOTE! We'd better ACK the irq immediately,
-	 * because timer handling can be slow.
-	 */
-	ack_APIC_irq();
-	/*
-	 * update_process_times() expects us to have done irq_enter().
-	 * Besides, if we don't timer interrupts ignore the global
-	 * interrupt lock, which is the WrongThing (tm) to do.
-	 */
-	exit_idle();
-	irq_enter();
-	smp_local_timer_interrupt();
-	irq_exit();
-	set_irq_regs(old_regs);
-}
-
-/*
- * This interrupt should _never_ happen with our APIC/SMP architecture
- */
-asmlinkage void smp_spurious_interrupt(void)
-{
-	unsigned int v;
-	exit_idle();
-	irq_enter();
-	/*
-	 * Check if this really is a spurious interrupt and ACK it
-	 * if it is a vectored one.  Just in case...
-	 * Spurious interrupts should not be ACKed.
-	 */
-	v = apic_read(APIC_ISR + ((SPURIOUS_APIC_VECTOR & ~0x1f) >> 1));
-	if (v & (1 << (SPURIOUS_APIC_VECTOR & 0x1f)))
-		ack_APIC_irq();
-
-#if 0
-	static unsigned long last_warning; 
-	static unsigned long skipped; 
-
-	/* see sw-dev-man vol 3, chapter 7.4.13.5 */
-	if (time_before(last_warning+30*HZ,jiffies)) { 
-		printk(KERN_INFO "spurious APIC interrupt on CPU#%d, %ld skipped.\n",
-		       smp_processor_id(), skipped);
-		last_warning = jiffies; 
-		skipped = 0;
-	} else { 
-		skipped++; 
-	} 
-#endif 
-	irq_exit();
-}
-
-/*
- * This interrupt should never happen with our APIC/SMP architecture
- */
-
-asmlinkage void smp_error_interrupt(void)
-{
-	unsigned int v, v1;
-
-	exit_idle();
-	irq_enter();
-	/* First tickle the hardware, only then report what went on. -- REW */
-	v = apic_read(APIC_ESR);
-	apic_write(APIC_ESR, 0);
-	v1 = apic_read(APIC_ESR);
-	ack_APIC_irq();
-	atomic_inc(&irq_err_count);
-
-	/* Here is what the APIC error bits mean:
-	   0: Send CS error
-	   1: Receive CS error
-	   2: Send accept error
-	   3: Receive accept error
-	   4: Reserved
-	   5: Send illegal vector
-	   6: Received illegal vector
-	   7: Illegal register address
-	*/
-	printk (KERN_DEBUG "APIC error on CPU%d: %02x(%02x)\n",
-	        smp_processor_id(), v , v1);
-	irq_exit();
-}
-
-int disable_apic;
-
-/*
- * This initializes the IO-APIC and APIC hardware if this is
- * a UP kernel.
- */
-int __init APIC_init_uniprocessor (void)
-{
-#ifdef CONFIG_X86_IO_APIC
-	if (smp_found_config && !skip_ioapic_setup && nr_ioapics)
-		setup_IO_APIC();
-#endif
-
-	return 1;
-}
Index: head-2007-09-03/arch/x86_64/kernel/early-quirks.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/early-quirks.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/early-quirks.c	2007-09-03 10:01:35.000000000 +0200
@@ -55,6 +55,7 @@ static void __init nvidia_bugs(void)
 
 static void __init ati_bugs(void)
 {
+#ifndef CONFIG_XEN
 #ifdef CONFIG_X86_IO_APIC
 	if (timer_over_8254 == 1) {
 		timer_over_8254 = 0;
@@ -62,6 +63,7 @@ static void __init ati_bugs(void)
 	 	"ATI board detected. Disabling timer routing over 8254.\n");
 	}
 #endif
+#endif
 }
 
 struct chipset {
Index: head-2007-09-03/arch/x86_64/kernel/genapic-xen.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/genapic-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/genapic-xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -17,7 +17,6 @@
 #include <linux/init.h>
 
 #include <asm/smp.h>
-#include <asm/ipi.h>
 #include <asm/genapic.h>
 
 #ifdef CONFIG_ACPI
@@ -72,7 +71,7 @@ void __init setup_apic_routing(void)
 /* Same for both flat and physical. */
 
 #ifdef CONFIG_XEN
-extern void xen_send_IPI_shortcut(unsigned int shortcut, int vector, unsigned int dest);
+extern void xen_send_IPI_shortcut(unsigned int shortcut, int vector);
 #endif
 
 void send_IPI_self(int vector)
@@ -80,6 +79,6 @@ void send_IPI_self(int vector)
 #ifndef CONFIG_XEN
 	__send_IPI_shortcut(APIC_DEST_SELF, vector, APIC_DEST_PHYSICAL);
 #else
-	xen_send_IPI_shortcut(APIC_DEST_SELF, vector, APIC_DEST_PHYSICAL);
+	xen_send_IPI_shortcut(APIC_DEST_SELF, vector);
 #endif
 }
Index: head-2007-09-03/arch/x86_64/kernel/genapic_xen.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/genapic_xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/genapic_xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -18,7 +18,6 @@
 #include <linux/init.h>
 #ifdef CONFIG_XEN_PRIVILEGED_GUEST
 #include <asm/smp.h>
-#include <asm/ipi.h>
 #else
 #include <asm/apic.h>
 #endif
@@ -34,7 +33,7 @@ static inline void __send_IPI_one(unsign
 	notify_remote_via_irq(irq);
 }
 
-void xen_send_IPI_shortcut(unsigned int shortcut, int vector, unsigned int dest)
+void xen_send_IPI_shortcut(unsigned int shortcut, int vector)
 {
 	int cpu;
 
@@ -96,13 +95,13 @@ static void xen_send_IPI_allbutself(int 
 	 */
 	Dprintk("%s\n", __FUNCTION__);
 	if (num_online_cpus() > 1)
-		xen_send_IPI_shortcut(APIC_DEST_ALLBUT, vector, APIC_DEST_LOGICAL);
+		xen_send_IPI_shortcut(APIC_DEST_ALLBUT, vector);
 }
 
 static void xen_send_IPI_all(int vector)
 {
 	Dprintk("%s\n", __FUNCTION__);
-	xen_send_IPI_shortcut(APIC_DEST_ALLINC, vector, APIC_DEST_LOGICAL);
+	xen_send_IPI_shortcut(APIC_DEST_ALLINC, vector);
 }
 
 static void xen_send_IPI_mask(cpumask_t cpumask, int vector)
@@ -152,7 +151,7 @@ struct genapic apic_xen =  {
 #ifdef CONFIG_XEN_PRIVILEGED_GUEST
 	.int_delivery_mode = dest_LowestPrio,
 #endif
-	.int_dest_mode = (APIC_DEST_LOGICAL != 0),
+	.int_dest_mode = 1,
 	.target_cpus = xen_target_cpus,
 	.vector_allocation_domain = xen_vector_allocation_domain,
 #ifdef CONFIG_XEN_PRIVILEGED_GUEST
Index: head-2007-09-03/arch/x86_64/kernel/io_apic-xen.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/io_apic-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/io_apic-xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -66,10 +66,6 @@ static int assign_irq_vector(int irq, cp
 
 int sis_apic_bug; /* not actually supported, dummy for compile */
 
-static int no_timer_check;
-
-static int disable_timer_pin_1 __initdata;
-
 #ifdef CONFIG_XEN
 #include <xen/interface/xen.h>
 #include <xen/interface/physdev.h>
@@ -83,6 +79,10 @@ unsigned long io_apic_irqs;
 
 #define clear_IO_APIC() ((void)0)
 #else
+static int no_timer_check;
+
+static int disable_timer_pin_1 __initdata;
+
 int timer_over_8254 __initdata = 1;
 
 /* Where if anywhere is the i8259 connect in external int mode */
@@ -412,6 +412,7 @@ static int __init disable_ioapic_setup(c
 }
 early_param("noapic", disable_ioapic_setup);
 
+#ifndef CONFIG_XEN
 /* Actually the next is obsolete, but keep it for paranoid reasons -AK */
 static int __init disable_timer_pin_setup(char *arg)
 {
@@ -420,7 +421,6 @@ static int __init disable_timer_pin_setu
 }
 __setup("disable_timer_pin_1", disable_timer_pin_setup);
 
-#ifndef CONFIG_XEN
 static int __init setup_disable_8254_timer(char *s)
 {
 	timer_over_8254 = -1;
@@ -1706,10 +1706,6 @@ static inline void check_timer(void)
 	apic_printk(APIC_VERBOSE," failed :(.\n");
 	panic("IO-APIC + timer doesn't work! Try using the 'noapic' kernel parameter\n");
 }
-#else
-#define check_timer() ((void)0)
-int timer_uses_ioapic_pin_0 = 0;
-#endif /* !CONFIG_XEN */
 
 static int __init notimercheck(char *s)
 {
@@ -1717,6 +1713,10 @@ static int __init notimercheck(char *s)
 	return 1;
 }
 __setup("no_timer_check", notimercheck);
+#else
+#define check_timer() ((void)0)
+int timer_uses_ioapic_pin_0 = 0;
+#endif /* !CONFIG_XEN */
 
 /*
  *
Index: head-2007-09-03/arch/x86_64/kernel/irq-xen.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/irq-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/irq-xen.c	2007-09-17 15:31:32.000000000 +0200
@@ -20,7 +20,9 @@
 #include <asm/idle.h>
 #include <asm/smp.h>
 
+#ifndef CONFIG_XEN
 atomic_t irq_err_count;
+#endif
 
 #ifdef CONFIG_DEBUG_STACKOVERFLOW
 /*
@@ -89,6 +91,7 @@ skip:
 		for_each_online_cpu(j)
 			seq_printf(p, "%10u ", cpu_pda(j)->__nmi_count);
 		seq_putc(p, '\n');
+#ifndef CONFIG_XEN
 #ifdef CONFIG_X86_LOCAL_APIC
 		seq_printf(p, "LOC: ");
 		for_each_online_cpu(j)
@@ -96,6 +99,7 @@ skip:
 		seq_putc(p, '\n');
 #endif
 		seq_printf(p, "ERR: %10u\n", atomic_read(&irq_err_count));
+#endif
 	}
 	return 0;
 }
Index: head-2007-09-03/arch/x86_64/kernel/mpparse-xen.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/mpparse-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/mpparse-xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -52,8 +52,9 @@ struct mpc_config_intsrc mp_irqs[MAX_IRQ
 int mp_irq_entries;
 
 int nr_ioapics;
+#ifndef CONFIG_XEN
 unsigned long mp_lapic_addr = 0;
-
+#endif
 
 
 /* Processor that is doing the boot up */
@@ -246,11 +247,13 @@ static int __init smp_read_mpc(struct mp
 	str[12] = 0;
 	printk("MPTABLE: Product ID: %s ",str);
 
+#ifndef CONFIG_XEN
 	printk("MPTABLE: APIC at: 0x%X\n",mpc->mpc_lapic);
 
 	/* save the local APIC address, it might be non-default */
 	if (!acpi_lapic)
 		mp_lapic_addr = mpc->mpc_lapic;
+#endif
 
 	/*
 	 *	Now process the configuration blocks.
@@ -395,10 +398,12 @@ static inline void __init construct_defa
 	int linttypes[2] = { mp_ExtINT, mp_NMI };
 	int i;
 
+#ifndef CONFIG_XEN
 	/*
 	 * local APIC has default address
 	 */
 	mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
+#endif
 
 	/*
 	 * 2 CPUs, numbered 0 & 1.
@@ -599,15 +604,15 @@ void __init find_smp_config(void)
 
 #ifdef CONFIG_ACPI
 
+#ifndef CONFIG_XEN
 void __init mp_register_lapic_address(u64 address)
 {
-#ifndef CONFIG_XEN
 	mp_lapic_addr = (unsigned long) address;
 	set_fixmap_nocache(FIX_APIC_BASE, mp_lapic_addr);
 	if (boot_cpu_id == -1U)
 		boot_cpu_id = GET_APIC_ID(apic_read(APIC_ID));
-#endif
 }
+#endif
 
 void __cpuinit mp_register_lapic (u8 id, u8 enabled)
 {
Index: head-2007-09-03/arch/x86_64/kernel/traps-xen.c
===================================================================
--- head-2007-09-03.orig/arch/x86_64/kernel/traps-xen.c	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/arch/x86_64/kernel/traps-xen.c	2007-09-03 10:01:35.000000000 +0200
@@ -1051,15 +1051,15 @@ asmlinkage void do_spurious_interrupt_bu
 {
 }
 
-#if 0
+#ifndef CONFIG_XEN
 asmlinkage void __attribute__((weak)) smp_thermal_interrupt(void)
 {
 }
-#endif
 
 asmlinkage void __attribute__((weak)) mce_threshold_interrupt(void)
 {
 }
+#endif
 
 /*
  *  'math_state_restore()' saves the current math information in the
Index: head-2007-09-03/include/asm-i386/apic.h
===================================================================
--- head-2007-09-03.orig/include/asm-i386/apic.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-i386/apic.h	2007-09-03 10:01:35.000000000 +0200
@@ -3,7 +3,9 @@
 
 #include <linux/pm.h>
 #include <linux/delay.h>
+#ifndef CONFIG_XEN
 #include <asm/fixmap.h>
+#endif
 #include <asm/apicdef.h>
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -33,7 +35,7 @@ extern int apic_verbosity;
 
 extern void generic_apic_probe(void);
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 
 /*
  * Basic functions accessing APICs.
@@ -111,18 +113,21 @@ extern int APIC_init_uniprocessor (void)
 
 extern void enable_NMI_through_LVT0 (void * dummy);
 
-#ifndef CONFIG_XEN
 #define ARCH_APICTIMER_STOPS_ON_C3	1
-#endif
 
 extern int timer_over_8254;
 extern int local_apic_timer_c2_ok;
 
 extern int local_apic_timer_disabled;
 
-#else /* !CONFIG_X86_LOCAL_APIC */
+#else /* !CONFIG_X86_LOCAL_APIC || CONFIG_XEN */
+
 static inline void lapic_shutdown(void) { }
 
+#ifdef CONFIG_X86_LOCAL_APIC
+extern int APIC_init_uniprocessor (void);
+#endif
+
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
 #endif /* __ASM_APIC_H */
Index: head-2007-09-03/include/asm-i386/apicdef.h
===================================================================
--- head-2007-09-03.orig/include/asm-i386/apicdef.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-i386/apicdef.h	2007-09-03 10:01:35.000000000 +0200
@@ -1,6 +1,8 @@
 #ifndef __ASM_APICDEF_H
 #define __ASM_APICDEF_H
 
+#ifndef CONFIG_XEN
+
 /*
  * Constants for various Intel APICs. (local APIC, IOAPIC, etc.)
  *
@@ -111,8 +113,20 @@
 
 #define APIC_BASE (fix_to_virt(FIX_APIC_BASE))
 
+#else /* CONFIG_XEN */
+
+enum {
+	APIC_DEST_ALLBUT = 0x1,
+	APIC_DEST_SELF,
+	APIC_DEST_ALLINC
+};
+
+#endif /* CONFIG_XEN */
+
 #define MAX_IO_APICS 64
 
+#ifndef CONFIG_XEN
+
 /*
  * the local APIC register structure, memory mapped. Not terribly well
  * tested, but we might eventually use this one in the future - the
@@ -372,4 +386,6 @@ struct local_apic {
 
 #undef u32
 
+#endif /* CONFIG_XEN */
+
 #endif
Index: head-2007-09-03/include/asm-i386/mach-xen/asm/fixmap.h
===================================================================
--- head-2007-09-03.orig/include/asm-i386/mach-xen/asm/fixmap.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-i386/mach-xen/asm/fixmap.h	2007-09-03 10:01:35.000000000 +0200
@@ -53,13 +53,15 @@ extern unsigned long __FIXADDR_TOP;
 enum fixed_addresses {
 	FIX_HOLE,
 	FIX_VDSO,
+#ifndef CONFIG_XEN
 #ifdef CONFIG_X86_LOCAL_APIC
 	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
 #endif
-#if defined(CONFIG_X86_IO_APIC) && !defined(CONFIG_XEN)
+#ifdef CONFIG_X86_IO_APIC
 	FIX_IO_APIC_BASE_0,
 	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS-1,
 #endif
+#endif
 #ifdef CONFIG_X86_VISWS_APIC
 	FIX_CO_CPU,	/* Cobalt timer */
 	FIX_CO_APIC,	/* Cobalt APIC Redirection Table */ 
Index: head-2007-09-03/include/asm-i386/mach-xen/asm/hw_irq.h
===================================================================
--- head-2007-09-03.orig/include/asm-i386/mach-xen/asm/hw_irq.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-i386/mach-xen/asm/hw_irq.h	2007-09-17 15:46:26.000000000 +0200
@@ -17,8 +17,6 @@
 #include <asm/irq.h>
 #include <asm/sections.h>
 
-#define NMI_VECTOR		0x02
-
 /*
  * Various low-level irq details needed by irq.c, process.c,
  * time.c, io_apic.c and smp.c
@@ -58,9 +56,6 @@ void setup_ioapic_dest(void);
 
 extern unsigned long io_apic_irqs;
 
-extern atomic_t irq_err_count;
-extern atomic_t irq_mis_count;
-
 #define IO_APIC_IRQ(x) (((x) >= 16) || ((1<<(x)) & io_apic_irqs))
 
 #endif /* _ASM_HW_IRQ_H */
Index: head-2007-09-03/include/asm-i386/mach-xen/asm/smp.h
===================================================================
--- head-2007-09-03.orig/include/asm-i386/mach-xen/asm/smp.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-i386/mach-xen/asm/smp.h	2007-09-03 10:01:35.000000000 +0200
@@ -156,7 +156,7 @@ extern unsigned int num_processors;
 
 #ifndef __ASSEMBLY__
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 
 #ifdef APIC_DEFINITION
 extern int hard_smp_processor_id(void);
@@ -179,7 +179,7 @@ static inline int hard_smp_processor_id(
 
 extern u8 apicid_2_node[];
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 static __inline int logical_smp_processor_id(void)
 {
 	/* we don't want to mark this access volatile - bad code generation */
Index: head-2007-09-03/include/asm-i386/mach-xen/irq_vectors.h
===================================================================
--- head-2007-09-03.orig/include/asm-i386/mach-xen/irq_vectors.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-i386/mach-xen/irq_vectors.h	2007-09-03 10:01:35.000000000 +0200
@@ -34,7 +34,7 @@
  * Vectors 0x20-0x2f are used for ISA interrupts.
  */
 
-#if 0
+#ifndef CONFIG_XEN
 /*
  * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
  *
@@ -57,7 +57,6 @@
  * sources per level' errata.
  */
 #define LOCAL_TIMER_VECTOR	0xef
-#endif
 
 #define SPURIOUS_APIC_VECTOR	0xff
 #define ERROR_APIC_VECTOR	0xfe
@@ -79,6 +78,7 @@
  * Since vectors 0x00-0x1f are used/reserved for the CPU,
  * the usable vector space is 0x20-0xff (224 vectors)
  */
+#endif
 
 #define RESCHEDULE_VECTOR	0
 #define CALL_FUNCTION_VECTOR	1
Index: head-2007-09-03/include/asm-i386/mach-xen/mach_apic.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2007-09-03/include/asm-i386/mach-xen/mach_apic.h	2007-09-03 10:01:35.000000000 +0200
@@ -0,0 +1,44 @@
+#ifndef __ASM_MACH_APIC_H
+#define __ASM_MACH_APIC_H
+
+#include <mach_apicdef.h>
+#include <asm/smp.h>
+
+static inline cpumask_t target_cpus(void)
+{
+#ifdef CONFIG_SMP
+	return cpu_online_map;
+#else
+	return cpumask_of_cpu(0);
+#endif
+}
+#define TARGET_CPUS (target_cpus())
+
+#define INT_DELIVERY_MODE dest_LowestPrio
+#define INT_DEST_MODE 1     /* logical delivery broadcast to all procs */
+
+static inline void setup_apic_routing(void)
+{
+}
+
+static inline int multi_timer_check(int apic, int irq)
+{
+	return 0;
+}
+
+static inline int apicid_to_node(int logical_apicid)
+{
+	return 0;
+}
+
+static inline unsigned int cpu_mask_to_apicid(cpumask_t cpumask)
+{
+	return cpus_addr(cpumask)[0];
+}
+
+static inline u32 phys_pkg_id(u32 cpuid_apic, int index_msb)
+{
+	return cpuid_apic >> index_msb;
+}
+
+#endif /* __ASM_MACH_APIC_H */
Index: head-2007-09-03/include/asm-x86_64/apic.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/apic.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/apic.h	2007-09-03 10:01:35.000000000 +0200
@@ -3,7 +3,9 @@
 
 #include <linux/pm.h>
 #include <linux/delay.h>
+#ifndef CONFIG_XEN
 #include <asm/fixmap.h>
+#endif
 #include <asm/apicdef.h>
 #include <asm/system.h>
 
@@ -32,6 +34,8 @@ extern int apic_mapped;
 			printk(s, ##a);    \
 	} while (0)
 
+#ifndef CONFIG_XEN
+
 struct pt_regs;
 
 /*
@@ -93,13 +97,18 @@ extern void setup_APIC_extened_lvt(unsig
 #define K8_APIC_EXT_INT_MSG_EXT 0x7
 #define K8_APIC_EXT_LVT_ENTRY_THRESHOLD    0
 
-#ifndef CONFIG_XEN
 void smp_send_timer_broadcast_ipi(void);
 void switch_APIC_timer_to_ipi(void *cpumask);
 void switch_ipi_to_APIC_timer(void *cpumask);
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
-#endif
+
+#elif defined(CONFIG_X86_LOCAL_APIC)
+
+extern int APIC_init_uniprocessor (void);
+extern void setup_apic_routing(void);
+
+#endif /* CONFIG_XEN / CONFIG_X86_LOCAL_APIC */
 
 extern unsigned boot_cpu_id;
 extern int local_apic_timer_c2_ok;
Index: head-2007-09-03/include/asm-x86_64/apicdef.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/apicdef.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/apicdef.h	2007-09-03 10:01:35.000000000 +0200
@@ -1,6 +1,8 @@
 #ifndef __ASM_APICDEF_H
 #define __ASM_APICDEF_H
 
+#ifndef CONFIG_XEN
+
 /*
  * Constants for various Intel APICs. (local APIC, IOAPIC, etc.)
  *
@@ -114,7 +116,22 @@
 
 #define APIC_BASE (fix_to_virt(FIX_APIC_BASE))
 
+#else /* CONFIG_XEN */
+
+#define			APIC_ALL_CPUS		0xFFu
+
+enum {
+	APIC_DEST_ALLBUT = 0x1,
+	APIC_DEST_SELF,
+	APIC_DEST_ALLINC
+};
+
+#endif /* CONFIG_XEN */
+
 #define MAX_IO_APICS 128
+
+#ifndef CONFIG_XEN
+
 #define MAX_LOCAL_APIC 256
 
 /*
@@ -387,6 +404,8 @@ struct local_apic {
 
 #undef u32
 
+#endif /* CONFIG_XEN */
+
 #define BAD_APICID 0xFFu
 
 #endif
Index: head-2007-09-03/include/asm-x86_64/io_apic.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/io_apic.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/io_apic.h	2007-09-03 10:01:35.000000000 +0200
@@ -125,8 +125,10 @@ extern int sis_apic_bug; /* dummy */ 
 
 void enable_NMI_through_LVT0 (void * dummy);
 
+#ifndef CONFIG_XEN
 extern spinlock_t i8259A_lock;
 
 extern int timer_over_8254;
+#endif
 
 #endif
Index: head-2007-09-03/include/asm-x86_64/ipi.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/ipi.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/ipi.h	2007-09-03 10:01:35.000000000 +0200
@@ -1,6 +1,8 @@
 #ifndef __ASM_IPI_H
 #define __ASM_IPI_H
 
+#ifndef CONFIG_XEN
+
 /*
  * Copyright 2004 James Cleverdon, IBM.
  * Subject to the GNU Public License, v.2
@@ -125,4 +127,6 @@ static inline void send_IPI_mask_sequenc
 	local_irq_restore(flags);
 }
 
+#endif /* CONFIG_XEN */
+
 #endif /* __ASM_IPI_H */
Index: head-2007-09-03/include/asm-x86_64/mach-xen/asm/fixmap.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/mach-xen/asm/fixmap.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/mach-xen/asm/fixmap.h	2007-09-03 10:01:35.000000000 +0200
@@ -12,7 +12,6 @@
 #define _ASM_FIXMAP_H
 
 #include <linux/kernel.h>
-#include <asm/apicdef.h>
 #include <asm/page.h>
 #include <asm/vsyscall.h>
 #include <asm/acpi.h>
@@ -37,10 +36,8 @@ enum fixed_addresses {
 	VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE + ((VSYSCALL_END-VSYSCALL_START) >> PAGE_SHIFT) - 1,
 	VSYSCALL_HPET,
 	FIX_HPET_BASE,
-#ifdef CONFIG_X86_LOCAL_APIC
-	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
-#endif
 #ifndef CONFIG_XEN
+	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
 	FIX_IO_APIC_BASE_0,
 	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS-1,
 #endif
Index: head-2007-09-03/include/asm-x86_64/mach-xen/asm/hw_irq.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/mach-xen/asm/hw_irq.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/mach-xen/asm/hw_irq.h	2007-09-17 15:47:02.000000000 +0200
@@ -22,7 +22,6 @@
 #include <linux/percpu.h>
 #endif
 
-#define NMI_VECTOR		0x02
 /*
  * IDT vectors usable for external interrupt sources start
  * at 0x20:
@@ -125,9 +124,6 @@ extern void setup_ioapic_dest(void);
 
 extern unsigned long io_apic_irqs;
 
-extern atomic_t irq_err_count;
-extern atomic_t irq_mis_count;
-
 #define IO_APIC_IRQ(x) (((x) >= 16) || ((1<<(x)) & io_apic_irqs))
 
 #define __STR(x) #x
Index: head-2007-09-03/include/asm-x86_64/mach-xen/asm/smp.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/mach-xen/asm/smp.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/mach-xen/asm/smp.h	2007-09-03 10:01:35.000000000 +0200
@@ -8,6 +8,7 @@
 #include <linux/cpumask.h>
 #include <linux/bitops.h>
 #include <linux/init.h>
+#include <linux/thread_info.h>
 extern int disable_apic;
 
 #ifdef CONFIG_X86_LOCAL_APIC
@@ -16,7 +17,6 @@ extern int disable_apic;
 #ifdef CONFIG_X86_IO_APIC
 #include <asm/io_apic.h>
 #endif
-#include <asm/thread_info.h>
 #endif
 
 #ifdef CONFIG_SMP
@@ -70,7 +70,7 @@ extern unsigned __cpuinitdata disabled_c
 
 #endif /* CONFIG_SMP */
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 static inline int hard_smp_processor_id(void)
 {
 	/* we don't want to mark this access volatile - bad code generation */
@@ -109,7 +109,7 @@ static inline int cpu_present_to_apicid(
 })
 #endif
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 static __inline int logical_smp_processor_id(void)
 {
 	/* we don't want to mark this access volatile - bad code generation */
Index: head-2007-09-03/include/asm-x86_64/mach-xen/irq_vectors.h
===================================================================
--- head-2007-09-03.orig/include/asm-x86_64/mach-xen/irq_vectors.h	2007-09-17 15:49:04.000000000 +0200
+++ head-2007-09-03/include/asm-x86_64/mach-xen/irq_vectors.h	2007-09-03 10:01:35.000000000 +0200
@@ -4,16 +4,10 @@
  *
  * In addition, there are some standard defines:
  *
- *	FIRST_EXTERNAL_VECTOR:
- *		The first free place for external interrupts
- *
  *	SYSCALL_VECTOR:
  *		The IRQ vector a syscall makes the user to kernel transition
  *		under.
  *
- *	TIMER_IRQ:
- *		The IRQ number the timer interrupt comes in at.
- *
  *	NR_IRQS:
  *		The total number of interrupt vectors (including all the
  *		architecture specific interrupts) needed.
@@ -22,62 +16,8 @@
 #ifndef _ASM_IRQ_VECTORS_H
 #define _ASM_IRQ_VECTORS_H
 
-/*
- * IDT vectors usable for external interrupt sources start
- * at 0x20:
- */
-#define FIRST_EXTERNAL_VECTOR	0x20
-
 #define SYSCALL_VECTOR		0x80
 
-/*
- * Vectors 0x20-0x2f are used for ISA interrupts.
- */
-
-#if 0
-/*
- * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
- *
- *  some of the following vectors are 'rare', they are merged
- *  into a single vector (CALL_FUNCTION_VECTOR) to save vector space.
- *  TLB, reschedule and local APIC vectors are performance-critical.
- *
- *  Vectors 0xf0-0xfa are free (reserved for future Linux use).
- */
-#define INVALIDATE_TLB_VECTOR	0xfd
-#define RESCHEDULE_VECTOR	0xfc
-#define CALL_FUNCTION_VECTOR	0xfb
-
-#define THERMAL_APIC_VECTOR	0xf0
-/*
- * Local APIC timer IRQ vector is on a different priority level,
- * to work around the 'lost local interrupt if more than 2 IRQ
- * sources per level' errata.
- */
-#define LOCAL_TIMER_VECTOR	0xef
-#endif
-
-#define SPURIOUS_APIC_VECTOR	0xff
-#define ERROR_APIC_VECTOR	0xfe
-
-/*
- * First APIC vector available to drivers: (vectors 0x30-0xee)
- * we start at 0x31 to spread out vectors evenly between priority
- * levels. (0x80 is the syscall vector)
- */
-#define FIRST_DEVICE_VECTOR	0x31
-#define FIRST_SYSTEM_VECTOR	0xef
-
-/*
- * 16 8259A IRQ's, 208 potential APIC interrupt sources.
- * Right now the APIC is mostly only used for SMP.
- * 256 vectors is an architectural limit. (we can have
- * more than 256 devices theoretically, but they will
- * have to use shared interrupts)
- * Since vectors 0x00-0x1f are used/reserved for the CPU,
- * the usable vector space is 0x20-0xff (224 vectors)
- */
-
 #define RESCHEDULE_VECTOR	0
 #define CALL_FUNCTION_VECTOR	1
 #define NR_IPIS			2
