Subject: Allow netback to be built as a module
From: jbeulich@novell.com

Index: head-2006-03-02/drivers/xen/core/skbuff.c
===================================================================
--- head-2006-03-02.orig/drivers/xen/core/skbuff.c	2006-03-02 10:28:08.000000000 +0100
+++ head-2006-03-02/drivers/xen/core/skbuff.c	2006-03-02 11:26:38.000000000 +0100
@@ -16,6 +16,7 @@
 
 /* Referenced in netback.c. */
 /*static*/ kmem_cache_t *skbuff_cachep;
+EXPORT_SYMBOL(skbuff_cachep);
 
 #define MAX_SKBUFF_ORDER 4
 static kmem_cache_t *skbuff_order_cachep[MAX_SKBUFF_ORDER + 1];
Index: head-2006-03-02/drivers/xen/netback/Makefile
===================================================================
--- head-2006-03-02.orig/drivers/xen/netback/Makefile	2006-03-02 10:28:08.000000000 +0100
+++ head-2006-03-02/drivers/xen/netback/Makefile	2006-03-02 11:26:38.000000000 +0100
@@ -1,2 +1,5 @@
+obj-$(CONFIG_XEN_NETDEV_BACKEND) := netbk.o
+obj-$(CONFIG_XEN_NETDEV_LOOPBACK) += netloop.o
 
-obj-y	:= netback.o xenbus.o interface.o loopback.o
+netbk-y   := netback.o xenbus.o interface.o
+netloop-y := loopback.o
Index: head-2006-03-02/drivers/xen/netback/loopback.c
===================================================================
--- head-2006-03-02.orig/drivers/xen/netback/loopback.c	2006-03-02 11:06:06.000000000 +0100
+++ head-2006-03-02/drivers/xen/netback/loopback.c	2006-03-02 11:26:38.000000000 +0100
@@ -178,6 +178,23 @@ static int __init make_loopback(int i)
 	return err;
 }
 
+static void __init clean_loopback(int i)
+{
+	struct net_device *dev1, *dev2;
+	char dev_name[IFNAMSIZ];
+
+	sprintf(dev_name, "vif0.%d", i);
+	dev1 = dev_get_by_name(dev_name);
+	sprintf(dev_name, "veth%d", i);
+	dev2 = dev_get_by_name(dev_name);
+	if (dev1 && dev2) {
+		unregister_netdev(dev2);
+		unregister_netdev(dev1);
+		free_netdev(dev2);
+		free_netdev(dev1);
+	}
+}
+
 static int __init loopback_init(void)
 {
 	int i, err = 0;
@@ -191,6 +208,18 @@ static int __init loopback_init(void)
 
 module_init(loopback_init);
 
+static void __exit loopback_exit(void)
+{
+	int i;
+
+	for (i = nloopbacks; i-- > 0; )
+		clean_loopback(i);
+}
+
+module_exit(loopback_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+
 /*
  * Local variables:
  *  c-file-style: "linux"
Index: head-2006-03-02/drivers/xen/netback/netback.c
===================================================================
--- head-2006-03-02.orig/drivers/xen/netback/netback.c	2006-03-02 10:28:08.000000000 +0100
+++ head-2006-03-02/drivers/xen/netback/netback.c	2006-03-02 11:26:38.000000000 +0100
@@ -505,14 +505,12 @@ static void net_tx_action(unsigned long 
 			/* Still too big to send right now? Set a callback. */
 			if (txreq.size > netif->remaining_credit) {
 				netif->remaining_credit = 0;
-				netif->credit_timeout.expires  = 
-					next_credit;
 				netif->credit_timeout.data     =
 					(unsigned long)netif;
 				netif->credit_timeout.function =
 					tx_credit_callback;
-				add_timer_on(&netif->credit_timeout,
-					     smp_processor_id());
+				__mod_timer(&netif->credit_timeout,
+					    next_credit);
 				break;
 			}
 		}
@@ -811,6 +809,8 @@ static int __init netback_init(void)
 		&netif_be_dbg);
 #endif
 
+	__unsafe(THIS_MODULE);
+
 	return 0;
 }
 
@@ -822,6 +822,8 @@ static void netback_cleanup(void)
 module_init(netback_init);
 module_exit(netback_cleanup);
 
+MODULE_LICENSE("Dual BSD/GPL");
+
 /*
  * Local variables:
  *  c-file-style: "linux"
