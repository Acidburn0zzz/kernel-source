From: jbeulich@novell.com
Subject: fix processor handling in presence of external control
Patch-mainline: obsolete

- avoid leaking stuff in acpi_processor_remove()
- remove a pointless change to native code in acpi_processor_hotplug()
  (struct acpi_processor's id field is unsigned)
- don't set up processor_extcntl_ops when nothing controlled by Xen
  (thus processor_cntl_external() will always return false, allowing
  ACPI code to retain native behavior)

Index: head-2008-09-15/arch/x86/kernel/acpi/processor_extcntl_xen.c
===================================================================
--- head-2008-09-15.orig/arch/x86/kernel/acpi/processor_extcntl_xen.c	2008-09-19 12:54:32.000000000 +0200
+++ head-2008-09-15/arch/x86/kernel/acpi/processor_extcntl_xen.c	2008-09-19 12:55:29.000000000 +0200
@@ -215,6 +215,8 @@ void arch_acpi_processor_init_extcntl(co
 {
 	unsigned int pmbits = (xen_start_info->flags & SIF_PM_MASK) >> 8;
 
+	if (!pmbits)
+		return;
 	if (pmbits & XEN_PROCESSOR_PM_CX)
 		xen_extcntl_ops.pm_ops[PM_TYPE_IDLE] = xen_cx_notifier;
 	if (pmbits & XEN_PROCESSOR_PM_PX)
Index: head-2008-09-15/drivers/acpi/processor_core.c
===================================================================
--- head-2008-09-15.orig/drivers/acpi/processor_core.c	2008-09-19 12:55:04.000000000 +0200
+++ head-2008-09-15/drivers/acpi/processor_core.c	2008-09-19 12:13:42.000000000 +0200
@@ -861,7 +861,7 @@ static int acpi_processor_remove(struct 
 
 	pr = acpi_driver_data(device);
 
-	if (pr->id >= nr_cpu_ids) {
+	if (!processor_cntl_external() && pr->id >= nr_cpu_ids) {
 		kfree(pr);
 		return 0;
 	}
@@ -1031,12 +1031,7 @@ static void __ref acpi_processor_hotplug
 			return;
 		}
 
-#ifdef CONFIG_XEN
-		if ((pr->id >= 0) && (pr->id < nr_cpu_ids)
-		    && (cpu_present(pr->id)))
-#else
 		if ((pr->id < nr_cpu_ids) && (cpu_present(pr->id)))
-#endif /* CONFIG_XEN */
 			kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
 
 		if (processor_cntl_external())
