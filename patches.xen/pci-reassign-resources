Subject: xen/dom0: Reassign memory resources to device for pci passthrough
From: http://xenbits.xensource.com/linux-2.6.18-xen.hg (tip 854:950b9eb27661)
Patch-mainline: obsolete
Acked-by: jbeulich@novell.com

--- head-2009-04-07.orig/Documentation/kernel-parameters.txt	2009-04-07 14:19:30.000000000 +0200
+++ head-2009-04-07/Documentation/kernel-parameters.txt	2009-03-18 13:59:26.000000000 +0100
@@ -1933,6 +1933,12 @@ and is between 256 and 4096 characters. 
 			Run specified binary instead of /init from the ramdisk,
 			used for early userspace startup. See initrd.
 
+	reassigndev=	[PCI,XEN]
+			Format: [<segment>:]<bus>:<dev>.<func>[,...]
+			Specifies device to reassign page-aligned memory
+			resources. PCI-PCI bridge can be specified, if
+			resource windows need to be expanded.
+
 	reboot=		[BUGS=X86-32,BUGS=ARM,BUGS=IA-64] Rebooting mode
 			Format: <reboot_mode>[,<reboot_mode2>[,...]]
 			See arch/*/kernel/reboot.c or arch/*/kernel/process.c
--- head-2009-04-07.orig/drivers/pci/Kconfig	2009-04-07 14:19:30.000000000 +0200
+++ head-2009-04-07/drivers/pci/Kconfig	2009-02-06 12:02:32.000000000 +0100
@@ -21,6 +21,9 @@ config PCI_MSI
 
 	   If you don't know what to do here, say N.
 
+config PCI_REASSIGN
+	bool
+
 config PCI_LEGACY
 	bool "Enable deprecated pci_find_* API"
 	depends on PCI
--- head-2009-04-07.orig/drivers/pci/Makefile	2009-04-07 14:19:30.000000000 +0200
+++ head-2009-04-07/drivers/pci/Makefile	2009-02-06 12:03:19.000000000 +0100
@@ -5,6 +5,7 @@
 obj-y		+= access.o bus.o probe.o remove.o pci.o quirks.o slot.o \
 			pci-driver.o search.o pci-sysfs.o rom.o setup-res.o \
 			irq.o
+obj-$(CONFIG_PCI_REASSIGN) += reassigndev.o
 obj-$(CONFIG_PROC_FS) += proc.o
 
 # Build PCI Express stuff if needed
--- head-2009-04-07.orig/drivers/pci/pci.h	2009-04-07 14:19:30.000000000 +0200
+++ head-2009-04-07/drivers/pci/pci.h	2009-02-06 12:04:09.000000000 +0100
@@ -195,4 +195,11 @@ static inline int pci_ari_enabled(struct
 	return bus->self && bus->self->ari_enabled;
 }
 
+#ifdef CONFIG_PCI_REASSIGN
+extern int pci_is_reassigndev(struct pci_dev *dev);
+extern void pci_disable_bridge_window(struct pci_dev *dev);
+#else
+#define pci_is_reassigndev(dev) 0
+#endif
+
 #endif /* DRIVERS_PCI_H */
--- head-2009-04-07.orig/drivers/pci/quirks.c	2009-04-07 14:19:30.000000000 +0200
+++ head-2009-04-07/drivers/pci/quirks.c	2009-04-07 14:23:59.000000000 +0200
@@ -34,6 +34,57 @@ int pcie_mch_quirk;
 EXPORT_SYMBOL(pcie_mch_quirk);
 
 #ifdef CONFIG_PCI_QUIRKS
+#ifdef CONFIG_PCI_REASSIGN
+/*
+ * This quirk function disables memory decoding and releases memory
+ * resources which is specified by kernel's boot parameter 'reassigndev'.
+ * Later on, kernel will assign page-aligned memory resource back
+ * to the device.
+ */
+static void __devinit quirk_release_resources(struct pci_dev *dev)
+{
+	int i;
+	struct resource *r;
+	u16 command;
+
+	if (pci_is_reassigndev(dev)) {
+		if (dev->hdr_type == PCI_HEADER_TYPE_NORMAL &&
+		    (dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {
+			/* PCI Host Bridge isn't a target device */
+			return;
+		}
+		printk(KERN_INFO
+			"PCI: Disable memory decoding and release memory resources [%s].\n",
+			pci_name(dev));
+		pci_read_config_word(dev, PCI_COMMAND, &command);
+		command &= ~PCI_COMMAND_MEMORY;
+		pci_write_config_word(dev, PCI_COMMAND, command);
+
+		for (i=0; i < PCI_NUM_RESOURCES; i++) {
+			r = &dev->resource[i];
+			if (!(r->flags & IORESOURCE_MEM))
+				continue;
+
+			r->end = r->end - r->start;
+			r->start = 0;
+
+			if (i < PCI_BRIDGE_RESOURCES) {
+				pci_update_resource(dev, r, i);
+			}
+		}
+		/* need to disable bridge's resource window,
+		 * to make kernel enable to reassign new resource
+		 * window later on.
+		 */
+		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&
+		    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+			pci_disable_bridge_window(dev);
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, quirk_release_resources);
+#endif  /* CONFIG_PCI_REASSIGN */
+
 /* The Mellanox Tavor device gives false positive parity errors
  * Mark this device with a broken_parity_status, to allow
  * PCI scanning code to "skip" this now blacklisted device.
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2009-04-07/drivers/pci/reassigndev.c	2009-02-06 12:02:32.000000000 +0100
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2008, NEC Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/string.h>
+#include "pci.h"
+
+
+#define	REASSIGNDEV_PARAM_MAX	(2048)
+#define	TOKEN_MAX	(12)	/* "SSSS:BB:DD.F" length is 12 */
+
+static char param_reassigndev[REASSIGNDEV_PARAM_MAX] = {0};
+
+static int __init pci_reassigndev_setup(char *str)
+{
+	strncpy(param_reassigndev, str, REASSIGNDEV_PARAM_MAX);
+	param_reassigndev[REASSIGNDEV_PARAM_MAX - 1] = '\0';
+	return 1;
+}
+__setup("reassigndev=", pci_reassigndev_setup);
+
+int pci_is_reassigndev(struct pci_dev *dev)
+{
+	char dev_str[TOKEN_MAX+1];
+	int seg, bus, slot, func;
+	int len;
+	char *p, *next_str;
+
+	p = param_reassigndev;
+	for (; p; p = next_str + 1) {
+		next_str = strpbrk(p, ",");
+		if (next_str) {
+			len = next_str - p;
+		} else {
+			len = strlen(p);
+		}
+		if (len > 0 && len <= TOKEN_MAX) {
+			strncpy(dev_str, p, len);
+			*(dev_str + len) = '\0';
+
+			if (sscanf(dev_str, "%x:%x:%x.%x",
+				&seg, &bus, &slot, &func) != 4) {
+				if (sscanf(dev_str, "%x:%x.%x",
+					&bus, &slot, &func) == 3) {
+					seg = 0;
+				} else {
+					/* failed to scan strings */
+					seg = -1;
+					bus = -1;
+				}
+			}
+			if (seg == pci_domain_nr(dev->bus) &&
+			    bus == dev->bus->number &&
+			    slot == PCI_SLOT(dev->devfn) &&
+			    func == PCI_FUNC(dev->devfn)) {
+				/* It's a target device */
+				return 1;
+			}
+		}
+		if (!next_str)
+			break;
+	}
+
+	return 0;
+}
--- head-2009-04-07.orig/drivers/pci/setup-bus.c	2009-04-07 14:19:30.000000000 +0200
+++ head-2009-04-07/drivers/pci/setup-bus.c	2009-02-06 12:14:35.000000000 +0100
@@ -26,6 +26,7 @@
 #include <linux/cache.h>
 #include <linux/slab.h>
 
+#include "pci.h"
 
 static void pbus_assign_resources_sorted(struct pci_bus *bus)
 {
@@ -343,7 +344,8 @@ static int pbus_size_mem(struct pci_bus 
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		int i;
-		
+		int reassign = pci_is_reassigndev(dev);
+
 		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 			struct resource *r = &dev->resource[i];
 			resource_size_t r_size;
@@ -351,6 +353,10 @@ static int pbus_size_mem(struct pci_bus 
 			if (r->parent || (r->flags & mask) != type)
 				continue;
 			r_size = resource_size(r);
+
+			if ((i < PCI_BRIDGE_RESOURCES) && reassign)
+				r_size = ALIGN(r_size, PAGE_SIZE);
+
 			/* For bridges size != alignment */
 			align = resource_alignment(r);
 			order = __ffs(align) - 20;
--- head-2009-04-07.orig/drivers/pci/setup-res.c	2009-04-07 14:19:30.000000000 +0200
+++ head-2009-04-07/drivers/pci/setup-res.c	2009-02-06 12:17:35.000000000 +0100
@@ -120,6 +120,21 @@ int pci_claim_resource(struct pci_dev *d
 	return err;
 }
 
+#ifdef CONFIG_PCI_REASSIGN
+void pci_disable_bridge_window(struct pci_dev *dev)
+{
+	printk(KERN_DEBUG "PCI: Disable bridge window on %s\n", pci_name(dev));
+
+	/* MMIO Base/Limit */
+	pci_write_config_dword(dev, PCI_MEMORY_BASE, 0x0000fff0);
+
+	/* Prefetchable MMIO Base/Limit */
+	pci_write_config_dword(dev, PCI_PREF_LIMIT_UPPER32, 0);
+	pci_write_config_dword(dev, PCI_PREF_MEMORY_BASE, 0x0000fff0);
+	pci_write_config_dword(dev, PCI_PREF_BASE_UPPER32, 0xffffffff);
+}
+#endif
+
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct pci_bus *bus = dev->bus;
@@ -137,6 +152,10 @@ int pci_assign_resource(struct pci_dev *
 			resno, res, res->flags);
 		return -EINVAL;
 	}
+	if (resno < PCI_BRIDGE_RESOURCES
+	    && pci_is_reassigndev(dev)
+	    && (res->flags & IORESOURCE_MEM))
+		align = ALIGN(align, PAGE_SIZE);
 
 	/* First, try exact prefetching match.. */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
@@ -159,8 +178,15 @@ int pci_assign_resource(struct pci_dev *
 			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
 	} else {
 		res->flags &= ~IORESOURCE_STARTALIGN;
-		if (resno < PCI_BRIDGE_RESOURCES)
+		if (resno < PCI_BRIDGE_RESOURCES) {
+#ifdef CONFIG_PCI_REASSIGN
+			printk(KERN_DEBUG "PCI: Assign resource(%d) on %s "
+				"%016llx - %016llx\n", resno, pci_name(dev),
+				(unsigned long long)res->start,
+				(unsigned long long)res->end);
+#endif
 			pci_update_resource(dev, resno);
+		}
 	}
 
 	return ret;
@@ -195,6 +221,12 @@ int pci_assign_resource_fixed(struct pci
 		dev_err(&dev->dev, "BAR %d: can't allocate %s resource %pR\n",
 			resno, res->flags & IORESOURCE_IO ? "I/O" : "mem", res);
 	} else if (resno < PCI_BRIDGE_RESOURCES) {
+#ifdef CONFIG_PCI_REASSIGN
+		printk(KERN_DEBUG "PCI: Assign resource(%d) on %s "
+			"%016llx - %016llx\n", resno, pci_name(dev),
+			(unsigned long long)res->start,
+			(unsigned long long)res->end);
+#endif
 		pci_update_resource(dev, resno);
 	}
 
@@ -207,6 +239,7 @@ EXPORT_SYMBOL_GPL(pci_assign_resource_fi
 void pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 {
 	int i;
+	int reassigndev = pci_is_reassigndev(dev);
 
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		struct resource *r;
@@ -228,12 +261,22 @@ void pdev_sort_resources(struct pci_dev 
 				i, r, r->flags);
 			continue;
 		}
+		if (i < PCI_BRIDGE_RESOURCES && (r->flags & IORESOURCE_MEM) &&
+		    reassigndev)
+			r_align = ALIGN(r_align, PAGE_SIZE);
+
 		for (list = head; ; list = list->next) {
 			resource_size_t align = 0;
 			struct resource_list *ln = list->next;
 
-			if (ln)
+			if (ln) {
 				align = resource_alignment(ln->res);
+				if (ln->res - ln->dev->resource <
+				    PCI_BRIDGE_RESOURCES &&
+				    (ln->res->flags & IORESOURCE_MEM) &&
+				    pci_is_reassigndev(ln->dev))
+					align = ALIGN(align, PAGE_SIZE);
+			}
 
 			if (r_align > align) {
 				tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
