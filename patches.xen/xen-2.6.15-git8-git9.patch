Subject: Update Xen-specific files for 2.6.15-git9
From: jbeulich@novell.com

Index: head-2006-01-16/arch/i386/xen/kernel/process.c
===================================================================
--- head-2006-01-16.orig/arch/i386/xen/kernel/process.c	2006-01-16 10:08:11.718243624 +0100
+++ head-2006-01-16/arch/i386/xen/kernel/process.c	2006-01-16 10:16:12.036224192 +0100
@@ -322,18 +322,7 @@ int copy_thread(int nr, unsigned long cl
 	struct task_struct *tsk;
 	int err;
 
-	childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p->thread_info)) - 1;
-	/*
-	 * The below -8 is to reserve 8 bytes on top of the ring0 stack.
-	 * This is necessary to guarantee that the entire "struct pt_regs"
-	 * is accessable even if the CPU haven't stored the SS/ESP registers
-	 * on the stack (interrupt gate does not save these registers
-	 * when switching to the same priv ring).
-	 * Therefore beware: accessing the xss/esp fields of the
-	 * "struct pt_regs" is possible, but they may contain the
-	 * completely wrong values.
-	 */
-	childregs = (struct pt_regs *) ((unsigned long) childregs - 8);
+	childregs = task_pt_regs(p);
 	*childregs = *regs;
 	childregs->eax = 0;
 	childregs->esp = esp;
@@ -440,10 +429,8 @@ EXPORT_SYMBOL(dump_thread);
  */
 int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
 {
-	struct pt_regs ptregs;
-	
-	ptregs = *(struct pt_regs *)
-		((unsigned long)tsk->thread_info+THREAD_SIZE - sizeof(ptregs));
+	struct pt_regs ptregs = *task_pt_regs(tsk);
+
 	ptregs.xcs &= 0xffff;
 	ptregs.xds &= 0xffff;
 	ptregs.xes &= 0xffff;
@@ -468,8 +455,8 @@ static inline void disable_tsc(struct ta
 	 * gcc should eliminate the ->thread_info dereference if
 	 * has_secure_computing returns 0 at compile time (SECCOMP=n).
 	 */
-	prev = prev_p->thread_info;
-	next = next_p->thread_info;
+	prev = task_thread_info(prev_p);
+	next = task_thread_info(next_p);
 
 	if (has_secure_computing(prev) || has_secure_computing(next)) {
 		/* slow path here */
@@ -688,7 +675,7 @@ unsigned long get_wchan(struct task_stru
 	int count = 0;
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
-	stack_page = (unsigned long)p->thread_info;
+	stack_page = (unsigned long)task_stack_page(p);
 	esp = p->thread.esp;
 	if (!stack_page || esp < stack_page || esp > top_esp+stack_page)
 		return 0;
Index: head-2006-01-16/arch/x86_64/xen/kernel/process.c
===================================================================
--- head-2006-01-16.orig/arch/x86_64/xen/kernel/process.c	2006-01-16 10:08:11.766236328 +0100
+++ head-2006-01-16/arch/x86_64/xen/kernel/process.c	2006-01-16 10:14:18.777442144 +0100
@@ -396,7 +396,7 @@ int copy_thread(int nr, unsigned long cl
 	struct task_struct *me = current;
 
 	childregs = ((struct pt_regs *)
-			(THREAD_SIZE + (unsigned long) p->thread_info)) - 1;
+			(THREAD_SIZE + task_stack_page(p))) - 1;
 	*childregs = *regs;
 
 	childregs->rax = 0;
@@ -408,7 +408,7 @@ int copy_thread(int nr, unsigned long cl
 	p->thread.rsp0 = (unsigned long) (childregs+1);
 	p->thread.userrsp = me->thread.userrsp; 
 
-	set_ti_thread_flag(p->thread_info, TIF_FORK);
+	set_tsk_thread_flag(p, TIF_FORK);
 
 	p->thread.fs = me->thread.fs;
 	p->thread.gs = me->thread.gs;
@@ -566,7 +566,7 @@ __switch_to(struct task_struct *prev_p, 
 	write_pda(oldrsp, next->userrsp); 
 	write_pda(pcurrent, next_p); 
 	write_pda(kernelstack,
-	    (unsigned long)next_p->thread_info + THREAD_SIZE - PDA_STACKOFFSET);
+		  task_stack_page(next_p) + THREAD_SIZE - PDA_STACKOFFSET);
 
 	/*
 	 * Now maybe reload the debug registers
@@ -660,7 +660,7 @@ unsigned long get_wchan(struct task_stru
 
 	if (!p || p == current || p->state==TASK_RUNNING)
 		return 0; 
-	stack = (unsigned long)p->thread_info; 
+	stack = (unsigned long)task_stack_page(p);
 	if (p->thread.rsp < stack || p->thread.rsp > stack+THREAD_SIZE)
 		return 0;
 	fp = *(u64 *)(p->thread.rsp);
@@ -780,8 +780,7 @@ int dump_task_regs(struct task_struct *t
 {
 	struct pt_regs *pp, ptregs;
 
-	pp = (struct pt_regs *)(tsk->thread.rsp0);
-	--pp; 
+	pp = task_pt_regs(tsk);
 
 	ptregs = *pp; 
 	ptregs.cs &= 0xffff;
Index: head-2006-01-16/arch/x86_64/xen/kernel/traps.c
===================================================================
--- head-2006-01-16.orig/arch/x86_64/xen/kernel/traps.c	2006-01-16 10:08:11.780234200 +0100
+++ head-2006-01-16/arch/x86_64/xen/kernel/traps.c	2006-01-16 10:14:18.780441688 +0100
@@ -308,7 +308,7 @@ void show_registers(struct pt_regs *regs
 	printk("CPU %d ", cpu);
 	__show_regs(regs);
 	printk("Process %s (pid: %d, threadinfo %p, task %p)\n",
-		cur->comm, cur->pid, cur->thread_info, cur);
+		cur->comm, cur->pid, task_thread_info(cur), cur);
 
 	/*
 	 * When in-kernel, we also print out the stack and code at the
@@ -668,7 +668,7 @@ asmlinkage struct pt_regs *sync_regs(str
 		;
 	/* Exception from user space */
 	else if (user_mode(eregs))
-		regs = ((struct pt_regs *)current->thread.rsp0) - 1;
+		regs = task_pt_regs(current);
 	/* Exception from kernel and interrupts are enabled. Move to
  	   kernel process stack. */
 	else if (eregs->eflags & X86_EFLAGS_IF)
@@ -917,7 +917,7 @@ asmlinkage void math_state_restore(void)
 	if (!used_math())
 		init_fpu(me);
 	restore_fpu_checking(&me->thread.i387.fxsave);
-	me->thread_info->status |= TS_USEDFPU;
+	task_thread_info(me)->status |= TS_USEDFPU;
 }
 
 /*
Index: head-2006-01-16/include/asm-i386/mach-xen/asm/processor.h
===================================================================
--- head-2006-01-16.orig/include/asm-i386/mach-xen/asm/processor.h	2006-01-16 10:08:11.807230096 +0100
+++ head-2006-01-16/include/asm-i386/mach-xen/asm/processor.h	2006-01-16 10:14:18.782441384 +0100
@@ -567,10 +567,20 @@ unsigned long get_wchan(struct task_stru
        (unsigned long)(&__ptr[THREAD_SIZE_LONGS]);                     \
 })
 
+/*
+ * The below -8 is to reserve 8 bytes on top of the ring0 stack.
+ * This is necessary to guarantee that the entire "struct pt_regs"
+ * is accessable even if the CPU haven't stored the SS/ESP registers
+ * on the stack (interrupt gate does not save these registers
+ * when switching to the same priv ring).
+ * Therefore beware: accessing the xss/esp fields of the
+ * "struct pt_regs" is possible, but they may contain the
+ * completely wrong values.
+ */
 #define task_pt_regs(task)                                             \
 ({                                                                     \
        struct pt_regs *__regs__;                                       \
-       __regs__ = (struct pt_regs *)KSTK_TOP((task)->thread_info);     \
+       __regs__ = (struct pt_regs *)(KSTK_TOP(task_stack_page(task))-8); \
        __regs__ - 1;                                                   \
 })
 
Index: head-2006-01-16/include/asm-i386/mach-xen/asm/system.h
===================================================================
--- head-2006-01-16.orig/include/asm-i386/mach-xen/asm/system.h	2006-01-16 10:08:11.812229336 +0100
+++ head-2006-01-16/include/asm-i386/mach-xen/asm/system.h	2006-01-16 10:14:18.785440928 +0100
@@ -649,6 +649,15 @@ void enable_hlt(void);
 extern int es7000_plat;
 void cpu_idle_wait(void);
 
+/*
+ * On SMP systems, when the scheduler does migration-cost autodetection,
+ * it needs a way to flush as much of the CPU's caches as possible:
+ */
+static inline void sched_cacheflush(void)
+{
+	wbinvd();
+}
+
 extern unsigned long arch_align_stack(unsigned long sp);
 
 #endif
Index: head-2006-01-16/include/asm-x86_64/mach-xen/asm/processor.h
===================================================================
--- head-2006-01-16.orig/include/asm-x86_64/mach-xen/asm/processor.h	2006-01-16 10:08:11.828226904 +0100
+++ head-2006-01-16/include/asm-x86_64/mach-xen/asm/processor.h	2006-01-16 10:14:18.787440624 +0100
@@ -343,8 +343,8 @@ extern long kernel_thread(int (*fn)(void
 #define thread_saved_pc(t) (*(unsigned long *)((t)->thread.rsp - 8))
 
 extern unsigned long get_wchan(struct task_struct *p);
-#define KSTK_EIP(tsk) \
-	(((struct pt_regs *)(tsk->thread.rsp0 - sizeof(struct pt_regs)))->rip)
+#define task_pt_regs(tsk) ((struct pt_regs *)(tsk)->thread.rsp0 - 1)
+#define KSTK_EIP(tsk) (task_pt_regs(tsk)->rip)
 #define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
 
 
Index: head-2006-01-16/include/asm-x86_64/mach-xen/asm/system.h
===================================================================
--- head-2006-01-16.orig/include/asm-x86_64/mach-xen/asm/system.h	2006-01-16 10:08:11.834225992 +0100
+++ head-2006-01-16/include/asm-x86_64/mach-xen/asm/system.h	2006-01-16 10:14:18.789440320 +0100
@@ -197,6 +197,15 @@ static inline void write_cr4(unsigned lo
 #define wbinvd() \
 	__asm__ __volatile__ ("wbinvd": : :"memory");
 
+/*
+ * On SMP systems, when the scheduler does migration-cost autodetection,
+ * it needs a way to flush as much of the CPU's caches as possible.
+ */
+static inline void sched_cacheflush(void)
+{
+	wbinvd();
+}
+
 #endif	/* __KERNEL__ */
 
 #define nop() __asm__ __volatile__ ("nop")
