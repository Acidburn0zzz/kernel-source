Subject: Make MTRR handling SMP safe
From: jbeulich@novell.com

Index: head-2006-03-06/arch/i386/kernel/cpu/mtrr/main-xen.c
===================================================================
--- head-2006-03-06.orig/arch/i386/kernel/cpu/mtrr/main-xen.c	2006-03-09 12:23:34.191319888 +0100
+++ head-2006-03-06/arch/i386/kernel/cpu/mtrr/main-xen.c	2006-03-09 12:26:12.319280784 +0100
@@ -8,6 +8,8 @@
 #include <asm/mtrr.h>
 #include "mtrr.h"
 
+static DECLARE_MUTEX(mtrr_sem);
+
 void generic_get_mtrr(unsigned int reg, unsigned long *base,
 		      unsigned int *size, mtrr_type * type)
 {
@@ -63,12 +65,15 @@ int mtrr_add_page(unsigned long base, un
 	int error;
 	dom0_op_t op;
 
+	down(&mtrr_sem);
+
 	op.cmd = DOM0_ADD_MEMTYPE;
 	op.u.add_memtype.mfn     = base;
 	op.u.add_memtype.nr_mfns = size;
 	op.u.add_memtype.type    = type;
 	error = HYPERVISOR_dom0_op(&op);
 	if (error) {
+		up(&mtrr_sem);
 		BUG_ON(error > 0);
 		return error;
 	}
@@ -76,6 +81,8 @@ int mtrr_add_page(unsigned long base, un
 	if (increment)
 		++usage_table[op.u.add_memtype.reg];
 
+	up(&mtrr_sem);
+
 	return op.u.add_memtype.reg;
 }
 
@@ -104,17 +111,18 @@ mtrr_add(unsigned long base, unsigned lo
 
 int mtrr_del_page(int reg, unsigned long base, unsigned long size)
 {
-	int i, max;
+	unsigned i;
 	mtrr_type ltype;
 	unsigned long lbase;
 	unsigned int lsize;
 	int error = -EINVAL;
 	dom0_op_t op;
 
-	max = num_var_ranges;
+	down(&mtrr_sem);
+
 	if (reg < 0) {
 		/*  Search for existing MTRR  */
-		for (i = 0; i < max; ++i) {
+		for (i = 0; i < num_var_ranges; ++i) {
 			mtrr_if->get(i, &lbase, &lsize, &ltype);
 			if (lbase == base && lsize == size) {
 				reg = i;
@@ -143,6 +151,7 @@ int mtrr_del_page(int reg, unsigned long
 	}
 	error = reg;
  out:
+	up(&mtrr_sem);
 	return error;
 }
 
