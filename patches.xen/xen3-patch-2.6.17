From: www.kernel.org
Subject: Linux 2.6.17
Patch-mainline: 2.6.17

Automatically created from "patches.kernel.org/patch-2.6.17" by xen-port-patches.py

Acked-by: jbeulich@novell.com

Index: head-2007-02-08/arch/i386/kernel/alternative-xen.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/alternative-xen.c	2007-02-08 13:09:55.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,389 +0,0 @@
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/list.h>
-#include <asm/alternative.h>
-#include <asm/sections.h>
-
-static int no_replacement    = 0;
-static int smp_alt_once      = 0;
-static int debug_alternative = 0;
-
-static int __init noreplacement_setup(char *s)
-{
-	no_replacement = 1;
-	return 1;
-}
-static int __init bootonly(char *str)
-{
-	smp_alt_once = 1;
-	return 1;
-}
-static int __init debug_alt(char *str)
-{
-	debug_alternative = 1;
-	return 1;
-}
-
-__setup("noreplacement", noreplacement_setup);
-__setup("smp-alt-boot", bootonly);
-__setup("debug-alternative", debug_alt);
-
-#define DPRINTK(fmt, args...) if (debug_alternative) \
-	printk(KERN_DEBUG fmt, args)
-
-#ifdef GENERIC_NOP1
-/* Use inline assembly to define this because the nops are defined
-   as inline assembly strings in the include files and we cannot
-   get them easily into strings. */
-asm("\t.data\nintelnops: "
-	GENERIC_NOP1 GENERIC_NOP2 GENERIC_NOP3 GENERIC_NOP4 GENERIC_NOP5 GENERIC_NOP6
-	GENERIC_NOP7 GENERIC_NOP8);
-extern unsigned char intelnops[];
-static unsigned char *intel_nops[ASM_NOP_MAX+1] = {
-	NULL,
-	intelnops,
-	intelnops + 1,
-	intelnops + 1 + 2,
-	intelnops + 1 + 2 + 3,
-	intelnops + 1 + 2 + 3 + 4,
-	intelnops + 1 + 2 + 3 + 4 + 5,
-	intelnops + 1 + 2 + 3 + 4 + 5 + 6,
-	intelnops + 1 + 2 + 3 + 4 + 5 + 6 + 7,
-};
-#endif
-
-#ifdef K8_NOP1
-asm("\t.data\nk8nops: "
-	K8_NOP1 K8_NOP2 K8_NOP3 K8_NOP4 K8_NOP5 K8_NOP6
-	K8_NOP7 K8_NOP8);
-extern unsigned char k8nops[];
-static unsigned char *k8_nops[ASM_NOP_MAX+1] = {
-	NULL,
-	k8nops,
-	k8nops + 1,
-	k8nops + 1 + 2,
-	k8nops + 1 + 2 + 3,
-	k8nops + 1 + 2 + 3 + 4,
-	k8nops + 1 + 2 + 3 + 4 + 5,
-	k8nops + 1 + 2 + 3 + 4 + 5 + 6,
-	k8nops + 1 + 2 + 3 + 4 + 5 + 6 + 7,
-};
-#endif
-
-#ifdef K7_NOP1
-asm("\t.data\nk7nops: "
-	K7_NOP1 K7_NOP2 K7_NOP3 K7_NOP4 K7_NOP5 K7_NOP6
-	K7_NOP7 K7_NOP8);
-extern unsigned char k7nops[];
-static unsigned char *k7_nops[ASM_NOP_MAX+1] = {
-	NULL,
-	k7nops,
-	k7nops + 1,
-	k7nops + 1 + 2,
-	k7nops + 1 + 2 + 3,
-	k7nops + 1 + 2 + 3 + 4,
-	k7nops + 1 + 2 + 3 + 4 + 5,
-	k7nops + 1 + 2 + 3 + 4 + 5 + 6,
-	k7nops + 1 + 2 + 3 + 4 + 5 + 6 + 7,
-};
-#endif
-
-#ifdef CONFIG_X86_64
-
-extern char __vsyscall_0;
-static inline unsigned char** find_nop_table(void)
-{
-	return k8_nops;
-}
-
-#else /* CONFIG_X86_64 */
-
-static struct nop {
-	int cpuid;
-	unsigned char **noptable;
-} noptypes[] = {
-	{ X86_FEATURE_K8, k8_nops },
-	{ X86_FEATURE_K7, k7_nops },
-	{ -1, NULL }
-};
-
-static unsigned char** find_nop_table(void)
-{
-	unsigned char **noptable = intel_nops;
-	int i;
-
-	for (i = 0; noptypes[i].cpuid >= 0; i++) {
-		if (boot_cpu_has(noptypes[i].cpuid)) {
-			noptable = noptypes[i].noptable;
-			break;
-		}
-	}
-	return noptable;
-}
-
-#endif /* CONFIG_X86_64 */
-
-extern struct alt_instr __alt_instructions[], __alt_instructions_end[];
-extern struct alt_instr __smp_alt_instructions[], __smp_alt_instructions_end[];
-extern u8 *__smp_locks[], *__smp_locks_end[];
-
-extern u8 __smp_alt_begin[], __smp_alt_end[];
-
-/* Replace instructions with better alternatives for this CPU type.
-   This runs before SMP is initialized to avoid SMP problems with
-   self modifying code. This implies that assymetric systems where
-   APs have less capabilities than the boot processor are not handled.
-   Tough. Make sure you disable such features by hand. */
-
-void apply_alternatives(struct alt_instr *start, struct alt_instr *end)
-{
-	unsigned char **noptable = find_nop_table();
-	struct alt_instr *a;
-	u8 *instr;
-	int diff, i, k;
-
-	DPRINTK("%s: alt table %p -> %p\n", __FUNCTION__, start, end);
-	for (a = start; a < end; a++) {
-		BUG_ON(a->replacementlen > a->instrlen);
-		if (!boot_cpu_has(a->cpuid))
-			continue;
-		instr = a->instr;
-#ifdef CONFIG_X86_64
-		/* vsyscall code is not mapped yet. resolve it manually. */
-		if (instr >= (u8 *)VSYSCALL_START && instr < (u8*)VSYSCALL_END) {
-			instr -= VSYSCALL_START - (unsigned long)&__vsyscall_0;
-			DPRINTK("%s: vsyscall fixup: %p => %p\n",
-				__FUNCTION__, a->instr, instr);
-		}
-#endif
-		memcpy(instr, a->replacement, a->replacementlen);
-		diff = a->instrlen - a->replacementlen;
-		/* Pad the rest with nops */
-		for (i = a->replacementlen; diff > 0; diff -= k, i += k) {
-			k = diff;
-			if (k > ASM_NOP_MAX)
-				k = ASM_NOP_MAX;
-			memcpy(a->instr + i, noptable[k], k);
-		}
-	}
-}
-
-#ifdef CONFIG_SMP
-
-static void alternatives_smp_save(struct alt_instr *start, struct alt_instr *end)
-{
-	struct alt_instr *a;
-
-	DPRINTK("%s: alt table %p-%p\n", __FUNCTION__, start, end);
-	for (a = start; a < end; a++) {
-		memcpy(a->replacement + a->replacementlen,
-		       a->instr,
-		       a->instrlen);
-	}
-}
-
-static void alternatives_smp_apply(struct alt_instr *start, struct alt_instr *end)
-{
-	struct alt_instr *a;
-
-	for (a = start; a < end; a++) {
-		memcpy(a->instr,
-		       a->replacement + a->replacementlen,
-		       a->instrlen);
-	}
-}
-
-static void alternatives_smp_lock(u8 **start, u8 **end, u8 *text, u8 *text_end)
-{
-	u8 **ptr;
-
-	for (ptr = start; ptr < end; ptr++) {
-		if (*ptr < text)
-			continue;
-		if (*ptr > text_end)
-			continue;
-		**ptr = 0xf0; /* lock prefix */
-	};
-}
-
-static void alternatives_smp_unlock(u8 **start, u8 **end, u8 *text, u8 *text_end)
-{
-	unsigned char **noptable = find_nop_table();
-	u8 **ptr;
-
-	for (ptr = start; ptr < end; ptr++) {
-		if (*ptr < text)
-			continue;
-		if (*ptr > text_end)
-			continue;
-		**ptr = noptable[1][0];
-	};
-}
-
-struct smp_alt_module {
-	/* what is this ??? */
-	struct module	*mod;
-	char		*name;
-
-	/* ptrs to lock prefixes */
-	u8		**locks;
-	u8		**locks_end;
-
-	/* .text segment, needed to avoid patching init code ;) */
-	u8		*text;
-	u8		*text_end;
-
-	struct list_head next;
-};
-static LIST_HEAD(smp_alt_modules);
-static DEFINE_SPINLOCK(smp_alt);
-
-void alternatives_smp_module_add(struct module *mod, char *name,
-				 void *locks, void *locks_end,
-				 void *text,  void *text_end)
-{
-	struct smp_alt_module *smp;
-	unsigned long flags;
-
-	if (no_replacement)
-		return;
-
-	if (smp_alt_once) {
-		if (boot_cpu_has(X86_FEATURE_UP))
-			alternatives_smp_unlock(locks, locks_end,
-						text, text_end);
-		return;
-	}
-
-	smp = kzalloc(sizeof(*smp), GFP_KERNEL);
-	if (NULL == smp)
-		return; /* we'll run the (safe but slow) SMP code then ... */
-
-	smp->mod	= mod;
-	smp->name	= name;
-	smp->locks	= locks;
-	smp->locks_end	= locks_end;
-	smp->text	= text;
-	smp->text_end	= text_end;
-	DPRINTK("%s: locks %p -> %p, text %p -> %p, name %s\n",
-		__FUNCTION__, smp->locks, smp->locks_end,
-		smp->text, smp->text_end, smp->name);
-
-	spin_lock_irqsave(&smp_alt, flags);
-	list_add_tail(&smp->next, &smp_alt_modules);
-	if (boot_cpu_has(X86_FEATURE_UP))
-		alternatives_smp_unlock(smp->locks, smp->locks_end,
-					smp->text, smp->text_end);
-	spin_unlock_irqrestore(&smp_alt, flags);
-}
-
-void alternatives_smp_module_del(struct module *mod)
-{
-	struct smp_alt_module *item;
-	unsigned long flags;
-
-	if (no_replacement || smp_alt_once)
-		return;
-
-	spin_lock_irqsave(&smp_alt, flags);
-	list_for_each_entry(item, &smp_alt_modules, next) {
-		if (mod != item->mod)
-			continue;
-		list_del(&item->next);
-		spin_unlock_irqrestore(&smp_alt, flags);
-		DPRINTK("%s: %s\n", __FUNCTION__, item->name);
-		kfree(item);
-		return;
-	}
-	spin_unlock_irqrestore(&smp_alt, flags);
-}
-
-void alternatives_smp_switch(int smp)
-{
-	struct smp_alt_module *mod;
-	unsigned long flags;
-
-#ifdef CONFIG_LOCKDEP
-	/*
-	 * A not yet fixed binutils section handling bug prevents
-	 * alternatives-replacement from working reliably, so turn
-	 * it off:
-	 */
-	printk("lockdep: not fixing up alternatives.\n");
-	return;
-#endif
-
-	if (no_replacement || smp_alt_once)
-		return;
-	BUG_ON(!smp && (num_online_cpus() > 1));
-
-	spin_lock_irqsave(&smp_alt, flags);
-	if (smp) {
-		printk(KERN_INFO "SMP alternatives: switching to SMP code\n");
-		clear_bit(X86_FEATURE_UP, boot_cpu_data.x86_capability);
-		clear_bit(X86_FEATURE_UP, cpu_data[0].x86_capability);
-		alternatives_smp_apply(__smp_alt_instructions,
-				       __smp_alt_instructions_end);
-		list_for_each_entry(mod, &smp_alt_modules, next)
-			alternatives_smp_lock(mod->locks, mod->locks_end,
-					      mod->text, mod->text_end);
-	} else {
-		printk(KERN_INFO "SMP alternatives: switching to UP code\n");
-		set_bit(X86_FEATURE_UP, boot_cpu_data.x86_capability);
-		set_bit(X86_FEATURE_UP, cpu_data[0].x86_capability);
-		apply_alternatives(__smp_alt_instructions,
-				   __smp_alt_instructions_end);
-		list_for_each_entry(mod, &smp_alt_modules, next)
-			alternatives_smp_unlock(mod->locks, mod->locks_end,
-						mod->text, mod->text_end);
-	}
-	spin_unlock_irqrestore(&smp_alt, flags);
-}
-
-#endif
-
-void __init alternative_instructions(void)
-{
-	if (no_replacement) {
-		printk(KERN_INFO "(SMP-)alternatives turned off\n");
-		free_init_pages("SMP alternatives",
-				(unsigned long)__smp_alt_begin,
-				(unsigned long)__smp_alt_end);
-		return;
-	}
-	apply_alternatives(__alt_instructions, __alt_instructions_end);
-
-	/* switch to patch-once-at-boottime-only mode and free the
-	 * tables in case we know the number of CPUs will never ever
-	 * change */
-#ifdef CONFIG_HOTPLUG_CPU
-	if (num_possible_cpus() < 2)
-		smp_alt_once = 1;
-#else
-	smp_alt_once = 1;
-#endif
-
-#ifdef CONFIG_SMP
-	if (smp_alt_once) {
-		if (1 == num_possible_cpus()) {
-			printk(KERN_INFO "SMP alternatives: switching to UP code\n");
-			set_bit(X86_FEATURE_UP, boot_cpu_data.x86_capability);
-			set_bit(X86_FEATURE_UP, cpu_data[0].x86_capability);
-			apply_alternatives(__smp_alt_instructions,
-					   __smp_alt_instructions_end);
-			alternatives_smp_unlock(__smp_locks, __smp_locks_end,
-						_text, _etext);
-		}
-		free_init_pages("SMP alternatives",
-				(unsigned long)__smp_alt_begin,
-				(unsigned long)__smp_alt_end);
-	} else {
-		alternatives_smp_save(__smp_alt_instructions,
-				      __smp_alt_instructions_end);
-		alternatives_smp_module_add(NULL, "core kernel",
-					    __smp_locks, __smp_locks_end,
-					    _text, _etext);
-		alternatives_smp_switch(0);
-	}
-#endif
-}
Index: head-2007-02-08/arch/i386/kernel/setup-xen.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/setup-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/setup-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -1034,8 +1034,16 @@ e820_all_mapped(unsigned long s, unsigne
 	u64 start = s;
 	u64 end = e;
 	int i;
+
+#ifndef CONFIG_XEN
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
+#else
+	if (!is_initial_xendomain())
+		return 0;
+	for (i = 0; i < machine_e820.nr_map; ++i) {
+		const struct e820entry *ei = &machine_e820.map[i];
+#endif
 		if (type && ei->type != type)
 			continue;
 		/* is the region (part) in overlap with the current region ?*/
@@ -1505,9 +1513,6 @@ e820_setup_gap(struct e820entry *e820, i
  */
 static int __init request_standard_resources(void)
 {
-#ifdef CONFIG_XEN
-	struct xen_memory_map memmap;
-#endif
 	int	      i;
 
 	/* Nothing to do if not running in dom0. */
@@ -1516,13 +1521,6 @@ static int __init request_standard_resou
 
 	printk("Setting up standard PCI resources\n");
 #ifdef CONFIG_XEN
-	memmap.nr_entries = E820MAX;
-	set_xen_guest_handle(memmap.buffer, machine_e820.map);
-
-	if (HYPERVISOR_memory_op(XENMEM_machine_memory_map, &memmap))
-		BUG();
-	machine_e820.nr_map = memmap.nr_entries;
-
 	legacy_init_iomem_resources(machine_e820.map, machine_e820.nr_map,
 				    &code_resource, &data_resource);
 #else
@@ -1548,10 +1546,20 @@ static void __init register_memory(void)
 {
 
 #ifdef CONFIG_XEN
-	e820_setup_gap(machine_e820.map, machine_e820.nr_map);
-#else
-	e820_setup_gap(e820.map, e820.nr_map);
+	if (is_initial_xendomain()) {
+		struct xen_memory_map memmap;
+
+		memmap.nr_entries = E820MAX;
+		set_xen_guest_handle(memmap.buffer, machine_e820.map);
+
+		BUG_ON(HYPERVISOR_memory_op(XENMEM_machine_memory_map, &memmap));
+
+		machine_e820.nr_map = memmap.nr_entries;
+		e820_setup_gap(machine_e820.map, machine_e820.nr_map);
+	}
+	else
 #endif
+		e820_setup_gap(e820.map, e820.nr_map);
 }
 
 #ifdef CONFIG_MCA
@@ -1839,6 +1847,9 @@ static __init int add_pcspkr(void)
 	struct platform_device *pd;
 	int ret;
 
+	if (!is_initial_xendomain())
+		return 0;
+
 	pd = platform_device_alloc("pcspkr", -1);
 	if (!pd)
 		return -ENOMEM;
Index: head-2007-02-08/arch/i386/kernel/time-xen.c
===================================================================
--- head-2007-02-08.orig/arch/i386/kernel/time-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/i386/kernel/time-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -708,7 +708,7 @@ irqreturn_t timer_interrupt(int irq, voi
 	if (delta_cpu > 0) {
 		do_div(delta_cpu, NS_PER_TICK);
 		per_cpu(processed_system_time, cpu) += delta_cpu * NS_PER_TICK;
-		if (user_mode(regs))
+		if (user_mode_vm(regs))
 			account_user_time(current, (cputime_t)delta_cpu);
 		else
 			account_system_time(current, HARDIRQ_OFFSET,
@@ -722,7 +722,7 @@ irqreturn_t timer_interrupt(int irq, voi
 	/* Local timer processing (see update_process_times()). */
 	run_local_timers();
 	if (rcu_pending(cpu))
-		rcu_check_callbacks(cpu, user_mode(regs));
+		rcu_check_callbacks(cpu, user_mode_vm(regs));
 	scheduler_tick();
 	run_posix_cpu_timers(current);
 	profile_tick(CPU_PROFILING, regs);
Index: head-2007-02-08/arch/i386/mach-xen/setup.c
===================================================================
--- head-2007-02-08.orig/arch/i386/mach-xen/setup.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/i386/mach-xen/setup.c	2007-02-08 17:09:47.000000000 +0100
@@ -67,7 +67,7 @@ char * __init machine_specific_memory_se
 	if ( rc == -ENOSYS ) {
 		memmap.nr_entries = 1;
 		map[0].addr = 0ULL;
-		map[0].size = PFN_PHYS(xen_start_info->nr_pages);
+		map[0].size = PFN_PHYS((unsigned long long)xen_start_info->nr_pages);
 		/* 8MB slack (to balance backend allocations). */
 		map[0].size += 8ULL << 20;
 		map[0].type = E820_RAM;
Index: head-2007-02-08/arch/i386/mm/ioremap-xen.c
===================================================================
--- head-2007-02-08.orig/arch/i386/mm/ioremap-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/i386/mm/ioremap-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -374,8 +374,6 @@ void iounmap(volatile void __iomem *addr
 }
 EXPORT_SYMBOL(iounmap);
 
-#ifdef __i386__
-
 void __init *bt_ioremap(unsigned long phys_addr, unsigned long size)
 {
 	unsigned long offset, last_addr;
@@ -443,5 +441,3 @@ void __init bt_iounmap(void *addr, unsig
 		--nrpages;
 	}
 }
-
-#endif /* __i386__ */
Index: head-2007-02-08/arch/x86_64/kernel/Makefile
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/Makefile	2007-02-08 15:14:00.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/Makefile	2007-02-08 16:59:13.000000000 +0100
@@ -64,7 +64,6 @@ ifdef CONFIG_XEN
 pci-dma-y			+= ../../i386/kernel/pci-dma-xen.o
 microcode-$(subst m,y,$(CONFIG_MICROCODE))  := ../../i386/kernel/microcode-xen.o
 quirks-y			:= ../../i386/kernel/quirks-xen.o
-alternative-y			:= ../../i386/kernel/alternative-xen.o
 
 n-obj-xen := i8259.o reboot.o i8237.o smpboot.o trampoline.o
 
Index: head-2007-02-08/arch/x86_64/kernel/e820-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/e820-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/e820-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -127,8 +127,19 @@ e820_any_mapped(unsigned long start, uns
 int __init e820_all_mapped(unsigned long start, unsigned long end, unsigned type)
 {
 	int i;
+
+#ifndef CONFIG_XEN
 	for (i = 0; i < e820.nr_map; i++) {
 		struct e820entry *ei = &e820.map[i];
+#else
+	extern struct e820map machine_e820;
+
+	if (!is_initial_xendomain())
+		return 0;
+	for (i = 0; i < machine_e820.nr_map; i++) {
+		const struct e820entry *ei = &machine_e820.map[i];
+#endif
+
 		if (type && ei->type != type)
 			continue;
 		/* is the region (part) in overlap with the current region ?*/
Index: head-2007-02-08/arch/x86_64/kernel/early_printk-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/early_printk-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/early_printk-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -18,9 +18,8 @@
 #define VGABASE		((void __iomem *)0xffffffff800b8000UL)
 #endif
 
-static int max_ypos = 25, max_xpos = 80;
-
 #ifndef CONFIG_XEN
+static int max_ypos = 25, max_xpos = 80;
 static int current_ypos = 25, current_xpos = 0; 
 
 static void early_vga_write(struct console *con, const char *str, unsigned n)
@@ -154,10 +153,6 @@ static __init void early_serial_init(cha
 
 #else /* CONFIG_XEN */
 
-#undef SCREEN_INFO
-#define SCREEN_INFO screen_info
-extern struct screen_info screen_info;
-
 static void
 early_serial_write(struct console *con, const char *s, unsigned count)
 {
@@ -273,11 +268,13 @@ int __init setup_early_printk(char *opt)
 		early_serial_init(buf);
 		early_console = &early_serial_console;
 	} else if (!strncmp(buf, "vga", 3)
+#ifndef CONFIG_XEN
 	           && SCREEN_INFO.orig_video_isVGA == 1) {
 		max_xpos = SCREEN_INFO.orig_video_cols;
 		max_ypos = SCREEN_INFO.orig_video_lines;
-#ifndef CONFIG_XEN
 		current_ypos = SCREEN_INFO.orig_y;
+#else
+	           || !strncmp(buf, "xen", 3)) {
 #endif
 		early_console = &early_vga_console;
  	} else if (!strncmp(buf, "simnow", 6)) {
Index: head-2007-02-08/arch/x86_64/kernel/entry-xen.S
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/entry-xen.S	2007-02-08 17:09:04.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/entry-xen.S	2007-02-08 17:09:47.000000000 +0100
@@ -32,9 +32,6 @@
  */
 
 #define ASSEMBLY 1
-#ifdef CONFIG_DEBUG_INFO
-#undef CONFIG_DEBUG_INFO
-#endif
 #include <linux/linkage.h>
 #include <asm/segment.h>
 #include <asm/smp.h>
@@ -537,6 +534,7 @@ END(stub_rt_sigreturn)
  */ 
 
 retint_check:
+	CFI_DEFAULT_STACK
 	movl threadinfo_flags(%rcx),%edx
 	andl %edi,%edx
 	CFI_REMEMBER_STATE
Index: head-2007-02-08/arch/x86_64/kernel/head-xen.S
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/head-xen.S	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/head-xen.S	2007-02-08 17:09:47.000000000 +0100
@@ -25,7 +25,7 @@
 
 #include <xen/interface/elfnote.h>
 
-	.text
+	.section .bootstrap.text, "ax", @progbits
 	.code64
 #define VIRT_ENTRY_OFFSET 0x0
 .org VIRT_ENTRY_OFFSET
Index: head-2007-02-08/arch/x86_64/kernel/mpparse-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/mpparse-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/mpparse-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -170,7 +170,7 @@ static void __cpuinit MP_processor_info 
 	cpu_set(cpu, cpu_present_map);
 }
 #else
-void __init MP_processor_info (struct mpc_config_processor *m)
+static void __cpuinit MP_processor_info (struct mpc_config_processor *m)
 {
 	num_processors++;
 }
Index: head-2007-02-08/arch/x86_64/kernel/process-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/process-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/process-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -492,8 +492,6 @@ __switch_to(struct task_struct *prev_p, 
 	 * This is basically '__unlazy_fpu', except that we queue a
 	 * multicall to indicate FPU task switch, rather than
 	 * synchronously trapping to Xen.
-	 * This must be here to ensure both math_state_restore() and
-	 * kernel_fpu_begin() work consistently. 
 	 * The AMD workaround requires it to be after DS reload, or
 	 * after DS has been cleared, which we do in __prepare_arch_switch.
 	 */
@@ -572,7 +570,7 @@ __switch_to(struct task_struct *prev_p, 
 		HYPERVISOR_set_segment_base(SEGBASE_GS_USER, next->gs); 
 
 	/* 
-	 * Switch the PDA and FPU contexts.
+	 * Switch the PDA context.
 	 */
 	prev->userrsp = read_pda(oldrsp); 
 	write_pda(oldrsp, next->userrsp); 
Index: head-2007-02-08/arch/x86_64/kernel/setup-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/kernel/setup-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/kernel/setup-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -580,13 +580,13 @@ static void discover_ebda(void)
 	if (ebda_size > 64*1024)
 		ebda_size = 64*1024;
 }
+#else
+#define discover_ebda() ((void)0)
 #endif
 
 void __init setup_arch(char **cmdline_p)
 {
 #ifdef CONFIG_XEN
-	struct xen_memory_map memmap;
-
 	/* Register a call for panic conditions. */
 	atomic_notifier_chain_register(&panic_notifier_list, &xen_panic_block);
 
@@ -675,13 +675,12 @@ void __init setup_arch(char **cmdline_p)
 
 	check_efer();
 
-#ifndef CONFIG_XEN
 	discover_ebda();
-#endif
 
 	init_memory_mapping(0, (end_pfn_map << PAGE_SHIFT));
 
-	/* dmi_scan_machine(); */
+	if (is_initial_xendomain())
+		dmi_scan_machine();
 
 #ifdef CONFIG_ACPI_NUMA
 	/*
@@ -892,6 +891,8 @@ void __init setup_arch(char **cmdline_p)
 	probe_roms();
 #ifdef CONFIG_XEN
 	if (is_initial_xendomain()) {
+		struct xen_memory_map memmap;
+
 		memmap.nr_entries = E820MAX;
 		set_xen_guest_handle(memmap.buffer, machine_e820.map);
 
@@ -1375,9 +1376,7 @@ void __cpuinit identify_cpu(struct cpuin
 			c->x86_capability[2] = cpuid_edx(0x80860001);
 	}
 
-#ifdef CONFIG_X86_XEN_GENAPIC
 	c->apicid = phys_pkg_id(0);
-#endif
 
 	/*
 	 * Vendor-specific initialization.  In this section we
@@ -1627,13 +1626,6 @@ struct seq_operations cpuinfo_op = {
 	.show =	show_cpuinfo,
 };
 
-static int __init run_dmi_scan(void)
-{
-	dmi_scan_machine();
-	return 0;
-}
-core_initcall(run_dmi_scan);
-
 #if defined(CONFIG_INPUT_PCSPKR) || defined(CONFIG_INPUT_PCSPKR_MODULE)
 #include <linux/platform_device.h>
 static __init int add_pcspkr(void)
@@ -1641,6 +1633,9 @@ static __init int add_pcspkr(void)
 	struct platform_device *pd;
 	int ret;
 
+	if (!is_initial_xendomain())
+		return 0;
+
 	pd = platform_device_alloc("pcspkr", -1);
 	if (!pd)
 		return -ENOMEM;
Index: head-2007-02-08/arch/x86_64/mm/init-xen.c
===================================================================
--- head-2007-02-08.orig/arch/x86_64/mm/init-xen.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/arch/x86_64/mm/init-xen.c	2007-02-08 17:09:47.000000000 +0100
@@ -208,7 +208,11 @@ static __init void *spp_getpage(void)
 	void *ptr;
 	if (after_bootmem)
 		ptr = (void *) get_zeroed_page(GFP_ATOMIC); 
-	else
+	else if (start_pfn < table_end) {
+		ptr = __va(start_pfn << PAGE_SHIFT);
+		start_pfn++;
+		memset(ptr, 0, PAGE_SIZE);
+	} else
 		ptr = alloc_bootmem_pages(PAGE_SIZE);
 	if (!ptr || ((unsigned long)ptr & ~PAGE_MASK))
 		panic("set_pte_phys: cannot allocate page data %s\n", after_bootmem?"after bootmem":"");
@@ -279,8 +283,8 @@ static __init void set_pte_phys(unsigned
 	__flush_tlb_one(vaddr);
 }
 
-static void set_pte_phys_ma(unsigned long vaddr,
-			 unsigned long phys, pgprot_t prot)
+static __init void set_pte_phys_ma(unsigned long vaddr,
+				   unsigned long phys, pgprot_t prot)
 {
 	pgd_t *pgd;
 	pud_t *pud;
@@ -361,9 +365,10 @@ __set_fixmap (enum fixed_addresses idx, 
 }
 
 /*
- * At this point it only supports vsyscall area.
+ * This only supports vsyscall area.
  */
-void __set_fixmap_user (enum fixed_addresses idx, unsigned long phys, pgprot_t prot)
+void __init
+__set_fixmap_user (enum fixed_addresses idx, unsigned long phys, pgprot_t prot)
 {
 	unsigned long address = __fix_to_virt(idx);
 
@@ -436,17 +441,34 @@ static inline int make_readonly(unsigned
 	return readonly;
 }
 
+#ifndef CONFIG_XEN
 /* Must run before zap_low_mappings */
 __init void *early_ioremap(unsigned long addr, unsigned long size)
 {
-	return ioremap(addr, size);
+	unsigned long map = round_down(addr, LARGE_PAGE_SIZE);
+
+	/* actually usually some more */
+	if (size >= LARGE_PAGE_SIZE) {
+		printk("SMBIOS area too long %lu\n", size);
+		return NULL;
+	}
+	set_pmd(temp_mappings[0].pmd,  __pmd(map | _KERNPG_TABLE | _PAGE_PSE));
+	map += LARGE_PAGE_SIZE;
+	set_pmd(temp_mappings[1].pmd,  __pmd(map | _KERNPG_TABLE | _PAGE_PSE));
+	__flush_tlb();
+	return temp_mappings[0].address + (addr & (LARGE_PAGE_SIZE-1));
 }
 
 /* To avoid virtual aliases later */
 __init void early_iounmap(void *addr, unsigned long size)
 {
-	iounmap(addr);
+	if ((void *)round_down((unsigned long)addr, LARGE_PAGE_SIZE) != temp_mappings[0].address)
+		printk("early_iounmap: bad address %p\n", addr);
+	set_pmd(temp_mappings[0].pmd, __pmd(0));
+	set_pmd(temp_mappings[1].pmd, __pmd(0));
+	__flush_tlb();
 }
+#endif
 
 static void __meminit
 phys_pmd_init(pmd_t *pmd, unsigned long address, unsigned long end)
@@ -648,9 +670,9 @@ void __init extend_init_mapping(unsigned
 	}
 }
 
-static void __init find_early_table_space(unsigned long end)
+static unsigned long __init find_early_table_space(unsigned long end)
 {
-	unsigned long puds, pmds, ptes, tables; 
+	unsigned long puds, pmds, ptes, tables, fixmap_tables;
 
 	puds = (end + PUD_SIZE - 1) >> PUD_SHIFT;
 	pmds = (end + PMD_SIZE - 1) >> PMD_SHIFT;
@@ -660,7 +682,16 @@ static void __init find_early_table_spac
 		round_up(pmds * 8, PAGE_SIZE) + 
 		round_up(ptes * 8, PAGE_SIZE); 
 
-	extend_init_mapping(tables);
+	/* Also reserve pages for fixmaps that need to be set up early.
+	 * Their pud is shared with the kernel pud.
+	 */
+	pmds = (PMD_SIZE - 1 - FIXADDR_START) >> PMD_SHIFT;
+	ptes = (PTE_SIZE - 1 - FIXADDR_START) >> PAGE_SHIFT;
+
+	fixmap_tables = round_up(pmds * 8, PAGE_SIZE) +
+		round_up(ptes * 8, PAGE_SIZE);
+
+	extend_init_mapping(tables + fixmap_tables);
 
 	table_start = start_pfn;
 	table_end = table_start + (tables>>PAGE_SHIFT);
@@ -668,6 +699,8 @@ static void __init find_early_table_spac
 	early_printk("kernel direct mapping tables up to %lx @ %lx-%lx\n",
 		end, table_start << PAGE_SHIFT,
 		(table_start << PAGE_SHIFT) + tables);
+
+	return table_end + (fixmap_tables>>PAGE_SHIFT);
 }
 
 /* Setup the direct mapping of the physical memory at PAGE_OFFSET.
@@ -675,7 +708,7 @@ static void __init find_early_table_spac
    physical memory. To access them they are temporarily mapped. */
 void __meminit init_memory_mapping(unsigned long start, unsigned long end)
 { 
-	unsigned long next; 
+	unsigned long next, table_rsrv_end = 0;
 
 	Dprintk("init_memory_mapping\n");
 
@@ -686,7 +719,7 @@ void __meminit init_memory_mapping(unsig
 	 * discovered.
 	 */
 	if (!after_bootmem)
-		find_early_table_space(end);
+		table_rsrv_end = find_early_table_space(end);
 
 	start = (unsigned long)__va(start);
 	end = (unsigned long)__va(end);
@@ -714,6 +747,7 @@ void __meminit init_memory_mapping(unsig
 
 	if (!after_bootmem) {
 		BUG_ON(start_pfn != table_end);
+		table_end = table_rsrv_end;
 
 		/* Re-vector virtual addresses pointing into the initial
 		   mapping to the just-established permanent ones. */
@@ -739,6 +773,24 @@ void __meminit init_memory_mapping(unsig
 		for (; start < end; start += PAGE_SIZE)
 			WARN_ON(HYPERVISOR_update_va_mapping(
 				start, __pte_ma(0), 0));
+
+		/* Switch to the real shared_info page, and clear the
+		 * dummy page. */
+		set_fixmap(FIX_SHARED_INFO, xen_start_info->shared_info);
+		HYPERVISOR_shared_info = (shared_info_t *)fix_to_virt(FIX_SHARED_INFO);
+		memset(empty_zero_page, 0, sizeof(empty_zero_page));
+
+		/* Setup mapping of lower 1st MB */
+		for (next = 0; next < NR_FIX_ISAMAPS; next++)
+			if (is_initial_xendomain())
+				set_fixmap(FIX_ISAMAP_BEGIN - next, next * PAGE_SIZE);
+			else
+				__set_fixmap(FIX_ISAMAP_BEGIN - next,
+					     virt_to_mfn(empty_zero_page) << PAGE_SHIFT,
+					     PAGE_KERNEL_RO);
+
+		BUG_ON(start_pfn > table_end);
+		table_end = start_pfn;
 	}
 
 	__flush_tlb_all();
@@ -817,7 +869,6 @@ size_zones(unsigned long *z, unsigned lo
 void __init paging_init(void)
 {
 	unsigned long zones[MAX_NR_ZONES], holes[MAX_NR_ZONES];
-	int i;
 
 	memory_present(0, 0, end_pfn);
 	sparse_init();
@@ -825,22 +876,7 @@ void __init paging_init(void)
 	free_area_init_node(0, NODE_DATA(0), zones,
 			    __pa(PAGE_OFFSET) >> PAGE_SHIFT, holes);
 
-	/* Switch to the real shared_info page, and clear the
-	 * dummy page. */
-	set_fixmap(FIX_SHARED_INFO, xen_start_info->shared_info);
-	HYPERVISOR_shared_info = (shared_info_t *)fix_to_virt(FIX_SHARED_INFO);
-	memset(empty_zero_page, 0, sizeof(empty_zero_page));
-
 	init_mm.context.pinned = 1;
-
-	/* Setup mapping of lower 1st MB */
-	for (i = 0; i < NR_FIX_ISAMAPS; i++)
-		if (is_initial_xendomain())
-			set_fixmap(FIX_ISAMAP_BEGIN - i, i * PAGE_SIZE);
-		else
-			__set_fixmap(FIX_ISAMAP_BEGIN - i,
-				     virt_to_mfn(empty_zero_page) << PAGE_SHIFT,
-				     PAGE_KERNEL_RO);
 }
 #endif
 
Index: head-2007-02-08/drivers/xen/balloon/balloon.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/balloon/balloon.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/balloon/balloon.c	2007-02-08 17:09:47.000000000 +0100
@@ -60,7 +60,7 @@
 static struct proc_dir_entry *balloon_pde;
 #endif
 
-static DECLARE_MUTEX(balloon_mutex);
+static DEFINE_MUTEX(balloon_mutex);
 
 /*
  * Protects atomic reservation decrease/increase against concurrent increases.
@@ -321,7 +321,7 @@ static void balloon_process(void *unused
 	int need_sleep = 0;
 	long credit;
 
-	down(&balloon_mutex);
+	mutex_lock(&balloon_mutex);
 
 	do {
 		credit = current_target() - bs.current_pages;
@@ -340,7 +340,7 @@ static void balloon_process(void *unused
 	if (current_target() != bs.current_pages)
 		mod_timer(&balloon_timer, jiffies + HZ);
 
-	up(&balloon_mutex);
+	mutex_unlock(&balloon_mutex);
 }
 
 /* Resets the Xen limit, sets new target, and kicks off processing. */
Index: head-2007-02-08/drivers/xen/core/smpboot.c
===================================================================
--- head-2007-02-08.orig/drivers/xen/core/smpboot.c	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/drivers/xen/core/smpboot.c	2007-02-08 17:09:47.000000000 +0100
@@ -349,8 +349,7 @@ void __init smp_prepare_cpus(unsigned in
 
 void __devinit smp_prepare_boot_cpu(void)
 {
-	cpu_present_map  = cpumask_of_cpu(0);
-	cpu_online_map   = cpumask_of_cpu(0);
+	prefill_possible_map();
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
Index: head-2007-02-08/include/asm-x86_64/mach-xen/asm/io.h
===================================================================
--- head-2007-02-08.orig/include/asm-x86_64/mach-xen/asm/io.h	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/include/asm-x86_64/mach-xen/asm/io.h	2007-02-08 17:09:47.000000000 +0100
@@ -150,8 +150,10 @@ static inline void __iomem * ioremap (un
 	return __ioremap(offset, size, 0);
 }
 
-extern void *early_ioremap(unsigned long addr, unsigned long size);
-extern void early_iounmap(void *addr, unsigned long size);
+extern void *bt_ioremap(unsigned long addr, unsigned long size);
+extern void bt_iounmap(void *addr, unsigned long size);
+#define early_ioremap bt_ioremap
+#define early_iounmap bt_iounmap
 
 /*
  * This one maps high address device memory and turns off caching for that area.
Index: head-2007-02-08/include/asm-x86_64/mach-xen/asm/fixmap.h
===================================================================
--- head-2007-02-08.orig/include/asm-x86_64/mach-xen/asm/fixmap.h	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/include/asm-x86_64/mach-xen/asm/fixmap.h	2007-02-08 17:09:47.000000000 +0100
@@ -53,6 +53,11 @@ enum fixed_addresses {
 #define NR_FIX_ISAMAPS	256
 	FIX_ISAMAP_END,
 	FIX_ISAMAP_BEGIN = FIX_ISAMAP_END + NR_FIX_ISAMAPS - 1,
+	__end_of_permanent_fixed_addresses,
+	/* temporary boot-time mappings, used before ioremap() is functional */
+#define NR_FIX_BTMAPS	16
+	FIX_BTMAP_END = __end_of_permanent_fixed_addresses,
+	FIX_BTMAP_BEGIN = FIX_BTMAP_END + NR_FIX_BTMAPS - 1,
 	__end_of_fixed_addresses
 };
 
Index: head-2007-02-08/include/linux/pfn.h
===================================================================
--- head-2007-02-08.orig/include/linux/pfn.h	2007-02-08 17:07:13.000000000 +0100
+++ head-2007-02-08/include/linux/pfn.h	2007-02-08 17:09:47.000000000 +0100
@@ -1,9 +1,9 @@
 #ifndef _LINUX_PFN_H_
 #define _LINUX_PFN_H_
 
-#define PFN_ALIGN(x)	(((unsigned long long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
+#define PFN_ALIGN(x)	(((unsigned long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
 #define PFN_UP(x)	(((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
 #define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
-#define PFN_PHYS(x)	((unsigned long long)(x) << PAGE_SHIFT)
+#define PFN_PHYS(x)	((x) << PAGE_SHIFT)
 
 #endif
