From: David Riddoch <driddoch@solarflare.com>
# replaces http://xenbits.xensource.com/linux-2.6.18-xen.hg c/s 420:
# HG changeset patch
# User Keir Fraser <keir.fraser@citrix.com>
# Date 1203330547 0
# Node ID fc90e9b2c12b316b5460ece28f013e6de881af1a
# Parent  0034d9389130969f9452b76370f76394e10238b8
Subject: Solarflare: Standard network driver.
Signed-off-by: Kieran Mansley <kmansley@solarflare.com>
References: FATE#303479
Acked-by: jbeulich@novell.com

Index: head-2008-06-18/drivers/net/sfc/Kconfig
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/Kconfig	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/Kconfig	2008-05-08 14:22:11.000000000 +0200
@@ -10,3 +10,21 @@ config SFC
 
 	  To compile this driver as a module, choose M here.  The module
 	  will be called sfc.
+
+config SFC_DEBUGFS
+	bool "Solarflare Solarstorm SFC4000 debugging support"
+	depends on SFC && DEBUG_FS
+	default N
+	help
+	  This option creates an "sfc" subdirectory of debugfs with
+	  debugging information for the SFC4000 driver.
+
+	  If unsure, say N.
+
+config SFC_MTD
+	depends on SFC && MTD && MTD_PARTITIONS
+	tristate "Solarflare Solarstorm SFC4000 flash/EEPROM support"
+	help
+	  This module exposes the on-board flash and/or EEPROM memory as
+	  MTD devices (e.g. /dev/mtd1).  This makes it possible to upload a
+	  new boot ROM to the NIC.
Index: head-2008-06-18/drivers/net/sfc/Makefile
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/Makefile	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/Makefile	2008-05-08 14:22:11.000000000 +0200
@@ -1,5 +1,40 @@
-sfc-y			+= efx.o falcon.o tx.o rx.o falcon_xmac.o \
-			   i2c-direct.o selftest.o ethtool.o xfp_phy.o \
-			   mdio_10g.o tenxpress.o boards.o sfe4001.o
 
-obj-$(CONFIG_SFC)	+= sfc.o
+# Final objects
+sfc_o = sfc.o
+sfc_mtd_o = sfc_mtd.o
+
+# Constituent objects
+sfc_elements_o :=
+sfc_elements_o += efx.o
+sfc_elements_o += falcon.o
+sfc_elements_o += tx.o
+sfc_elements_o += rx.o
+sfc_elements_o += mentormac.o
+sfc_elements_o += falcon_gmac.o
+sfc_elements_o += falcon_xmac.o
+sfc_elements_o += alaska.o
+sfc_elements_o += i2c-direct.o
+sfc_elements_o += selftest.o
+sfc_elements_o += driverlink.o
+ifeq ($(CONFIG_SFC_DEBUGFS),y)
+sfc_elements_o += debugfs.o
+endif
+sfc_elements_o += ethtool.o
+sfc_elements_o += xfp_phy.o
+sfc_elements_o += mdio_10g.o
+sfc_elements_o += txc43128_phy.o
+sfc_elements_o += tenxpress.o
+sfc_elements_o += lm87_support.o
+sfc_elements_o += boards.o
+sfc_elements_o += sfe4001.o
+sfc_elements_o += pm8358_phy.o
+sfc_elements_o += null_phy.o
+
+sfc_mtd_elements_o := mtd.o
+
+obj-$(CONFIG_SFC) += $(sfc_o)
+obj-$(CONFIG_SFC_MTD) += $(sfc_mtd_o)
+
+sfc-objs = $(sfc_elements_o)
+sfc_mtd-objs = $(sfc_mtd_elements_o)
+
Index: head-2008-06-18/drivers/net/sfc/alaska.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/alaska.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,159 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005:      Fen Systems Ltd.
+ * Copyright 2006-2007: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#include "net_driver.h"
+#include <linux/ethtool.h>
+#include "gmii.h"
+#include "phy.h"
+
+/* Marvell 88E1111 "Alaska" PHY control */
+#define ALASKA_PHY_SPECIFIC 16
+#define ALASKA_ALLOW_SLEEP 0x0200
+
+#define ALASKA_EXTENDED_CONTROL 20
+#define EXTENDED_LINE_LOOPBACK 0x8000
+
+#define ALASKA_LED_CONTROL 24
+#define LED_BLINK_MASK 0x0700
+#define LED_BLINK_FAST 0x0100
+#define LED_BLINK_SLOW 0x0300
+#define LED_TX_CTRL_MASK 0x0041
+#define LED_TX_CTRL_LINK_AND_ACTIVITY 0x0001
+
+#define ALASKA_LED_OVERRIDE 25
+#define LED_LINK1000_MASK 0x0030
+#define LED_LINK1000_BLINK 0x0010
+#define LED_TX_MASK 0x0003
+#define LED_TX_BLINK 0x0001
+
+static void alaska_reconfigure(struct efx_nic *efx)
+{
+	struct mii_if_info *gmii = &efx->mii;
+	u32 bmcr, phy_ext;
+
+	/* Configure line loopback if requested */
+	phy_ext = gmii->mdio_read(gmii->dev, gmii->phy_id,
+				  ALASKA_EXTENDED_CONTROL);
+	if (efx->loopback_mode == LOOPBACK_NETWORK)
+		phy_ext |= EXTENDED_LINE_LOOPBACK;
+	else
+		phy_ext &= ~EXTENDED_LINE_LOOPBACK;
+	gmii->mdio_write(gmii->dev, gmii->phy_id, ALASKA_EXTENDED_CONTROL,
+			 phy_ext);
+
+	/* Configure PHY loopback if requested */
+	bmcr = gmii->mdio_read(gmii->dev, gmii->phy_id, MII_BMCR);
+	if (efx->loopback_mode == LOOPBACK_PHY)
+		bmcr |= BMCR_LOOPBACK;
+	else
+		bmcr &= ~BMCR_LOOPBACK;
+	gmii->mdio_write(gmii->dev, gmii->phy_id, MII_BMCR, bmcr);
+
+	/* Read link up status */
+	if (efx->loopback_mode == LOOPBACK_NONE)
+		efx->link_up = mii_link_ok(gmii);
+	else
+		efx->link_up = 1;
+
+	/* Determine link options from PHY */
+	if (gmii->force_media) {
+		efx->link_options = gmii_forced_result(bmcr);
+	} else {
+		int lpa = gmii_lpa(gmii);
+		int adv = gmii_advertised(gmii);
+		efx->link_options = gmii_nway_result(adv & lpa);
+	}
+}
+
+static void alaska_clear_interrupt(struct efx_nic *efx)
+{
+	struct mii_if_info *gmii = &efx->mii;
+
+	/* Read interrupt status register to clear */
+	gmii->mdio_read(gmii->dev, gmii->phy_id, GMII_ISR);
+}
+
+static int alaska_init(struct efx_nic *efx)
+{
+	struct mii_if_info *gmii = &efx->mii;
+	u32 ier, leds, ctrl_1g, phy_spec;
+
+	/* Read ISR to clear any outstanding PHY interrupts */
+	gmii->mdio_read(gmii->dev, gmii->phy_id, GMII_ISR);
+
+	/* Enable PHY interrupts */
+	ier = gmii->mdio_read(gmii->dev, gmii->phy_id, GMII_IER);
+	ier |= IER_LINK_CHG;
+	gmii->mdio_write(gmii->dev, gmii->phy_id, GMII_IER, ier);
+
+	/* Remove 1G half-duplex as unsupported in Mentor MAC */
+	ctrl_1g = gmii->mdio_read(gmii->dev, gmii->phy_id, MII_CTRL1000);
+	ctrl_1g &= ~(ADVERTISE_1000HALF);
+	gmii->mdio_write(gmii->dev, gmii->phy_id, MII_CTRL1000, ctrl_1g);
+
+	/*
+	 * The PHY can save power when there is no external connection
+	 * (sleep mode).  However, this is incompatible with PHY
+	 * loopback, and if enable and disable it quickly the PHY can
+	 * go to sleep even when sleep mode is disabled.  (SFC bug
+	 * 9309.)  Therefore we disable it all the time.
+	 */
+	phy_spec = gmii->mdio_read(gmii->dev, gmii->phy_id,
+				   ALASKA_PHY_SPECIFIC);
+	phy_spec &= ~ALASKA_ALLOW_SLEEP;
+	gmii->mdio_write(gmii->dev, gmii->phy_id, ALASKA_PHY_SPECIFIC,
+			 phy_spec);
+
+	/* Configure LEDs */
+	leds = gmii->mdio_read(gmii->dev, gmii->phy_id, ALASKA_LED_CONTROL);
+	leds &= ~(LED_BLINK_MASK | LED_TX_CTRL_MASK);
+	leds |= (LED_BLINK_FAST | LED_TX_CTRL_LINK_AND_ACTIVITY);
+	gmii->mdio_write(gmii->dev, gmii->phy_id, ALASKA_LED_CONTROL, leds);
+
+	return 0;
+}
+
+static void alaska_fini(struct efx_nic *efx)
+{
+	struct mii_if_info *gmii = &efx->mii;
+	u32 ier;
+
+	/* Disable PHY interrupts */
+	ier = gmii->mdio_read(gmii->dev, gmii->phy_id, GMII_IER);
+	ier &= ~IER_LINK_CHG;
+	gmii->mdio_write(gmii->dev, gmii->phy_id, GMII_IER, ier);
+}
+
+
+struct efx_phy_operations alaska_phy_operations = {
+	.init            = alaska_init,
+	.fini            = alaska_fini,
+	.reconfigure     = alaska_reconfigure,
+	.clear_interrupt = alaska_clear_interrupt,
+	.loopbacks       = (1 << LOOPBACK_PHY) | (1 << LOOPBACK_NETWORK),
+	.startup_loopback = LOOPBACK_PHY,
+};
Index: head-2008-06-18/drivers/net/sfc/bitfield.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/bitfield.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/bitfield.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_BITFIELD_H
@@ -483,7 +500,7 @@ typedef union efx_oword {
 #endif
 
 #define EFX_SET_OWORD_FIELD_VER(efx, oword, field, value) do { \
-	if (falcon_rev(efx) >= FALCON_REV_B0) {			   \
+	if (FALCON_REV(efx) >= FALCON_REV_B0) {			   \
 		EFX_SET_OWORD_FIELD((oword), field##_B0, (value)); \
 	} else { \
 		EFX_SET_OWORD_FIELD((oword), field##_A1, (value)); \
@@ -491,7 +508,7 @@ typedef union efx_oword {
 } while (0)
 
 #define EFX_QWORD_FIELD_VER(efx, qword, field)	\
-	(falcon_rev(efx) >= FALCON_REV_B0 ?	\
+	(FALCON_REV(efx) >= FALCON_REV_B0 ?	\
 	 EFX_QWORD_FIELD((qword), field##_B0) :	\
 	 EFX_QWORD_FIELD((qword), field##_A1))
 
@@ -501,5 +518,8 @@ typedef union efx_oword {
 #define DMA_ADDR_T_WIDTH	(8 * sizeof(dma_addr_t))
 #define EFX_DMA_TYPE_WIDTH(width) \
 	(((width) < DMA_ADDR_T_WIDTH) ? (width) : DMA_ADDR_T_WIDTH)
+#define EFX_DMA_MAX_MASK ((DMA_ADDR_T_WIDTH == 64) ? \
+			  ~((u64) 0) : ~((u32) 0))
+#define EFX_DMA_MASK(mask) ((mask) & EFX_DMA_MAX_MASK)
 
 #endif /* EFX_BITFIELD_H */
Index: head-2008-06-18/drivers/net/sfc/boards.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/boards.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/boards.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,14 +1,31 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #include "net_driver.h"
 #include "phy.h"
+#include "lm87_support.h"
 #include "boards.h"
 #include "efx.h"
 
@@ -27,8 +44,10 @@ static void blink_led_timer(unsigned lon
 	struct efx_blinker *bl = &efx->board_info.blinker;
 	efx->board_info.set_fault_led(efx, bl->state);
 	bl->state = !bl->state;
-	if (bl->resubmit)
-		mod_timer(&bl->timer, jiffies + BLINK_INTERVAL);
+	if (bl->resubmit) {
+		bl->timer.expires = jiffies + BLINK_INTERVAL;
+		add_timer(&bl->timer);
+	}
 }
 
 static void board_blink(struct efx_nic *efx, int blink)
@@ -42,7 +61,8 @@ static void board_blink(struct efx_nic *
 		blinker->state = 0;
 		setup_timer(&blinker->timer, blink_led_timer,
 			    (unsigned long)efx);
-		mod_timer(&blinker->timer, jiffies + BLINK_INTERVAL);
+		blinker->timer.expires = jiffies + BLINK_INTERVAL;
+		add_timer(&blinker->timer);
 	} else {
 		blinker->resubmit = 0;
 		if (blinker->timer.function)
@@ -51,10 +71,63 @@ static void board_blink(struct efx_nic *
 	}
 }
 
+
+struct sensor_conf {
+	const char *name;
+	const unsigned high;
+	const unsigned low;
+};
+
+#define NO_LIMIT	((unsigned)-1)
+
+#define LM87_SENSOR_BYTES	(18)
+
+static int sensor_limits_to_bytes(const struct sensor_conf *limits,
+				  int nlimits, u8 *bytes, int maxbytes)
+{
+	int i, nbytes;
+	nbytes = 0;
+	for (i = 0; i < nlimits; i++) {
+		bytes[nbytes++] = limits[i].high;
+		if (limits[i].low != NO_LIMIT)
+			bytes[nbytes++] = limits[i].low;
+		/* We may have overrun by one at this point, but this test
+		 * should only trigger in development drivers as the sizes
+		 * are not dynamic. */
+		if (nbytes > maxbytes) {
+			printk(KERN_ERR "%s: out of space!\n", __func__);
+			break;
+		}
+	}
+	return nbytes;
+}
+
 /*****************************************************************************
  * Support for the SFE4002
  *
  */
+/* LM87 configuration data for the sensor on the SFE4002 board */
+static const struct sensor_conf sfe4002_lm87_limits[] = {
+	{"1.8V line", 0x91, 0x83},	/* 2.5V sensor, scaled for 1.8V */
+	{"1.2V line", 0x5a, 0x51},	/* Vccp1 */
+	{"3.3V line", 0xca, 0xb6},
+	{"5V line", 0xc9, 0xb6},
+	{"12V line", 0xe0, 0xb0},
+	{"1V line", 0x4b, 0x44},	/* vccp2 */
+	{"Ext. temp.", 0x46, 0x0a},	/* ASIC temp. */
+	{"Int. temp.", 0x3c, 0x0a},	/* Board temp. */
+	{"1.66V line", 0xb2, NO_LIMIT},	/* AIN1 only takes 1 value */
+	{"1.5V line", 0xa1, NO_LIMIT}	/* AIN2 only takes 1 value */
+};
+
+static const int sfe4002_lm87_nlimits = ARRAY_SIZE(sfe4002_lm87_limits);
+
+static u16 sfe4002_lm87_irq_mask = EFX_LM87_NO_INTS;
+
+/* I2C ID of the onboard LM87 chip. This is board-specific as the bottom two
+ * bits are set by strap pins */
+#define SFE4002_LM87_I2C_ID (0x2e)
+
 /****************************************************************************/
 /* LED allocations. Note that on rev A0 boards the schematic and the reality
  * differ: red and green are swapped. Below is the fixed (A1) layout (there
@@ -84,34 +157,321 @@ static void sfe4002_fault_led(struct efx
 			QUAKE_LED_OFF);
 }
 
+static int sfe4002_sensor_meaning(struct efx_nic *efx, int limit_num,
+				  unsigned val)
+{
+	const struct sensor_conf *lim = &sfe4002_lm87_limits[limit_num];
+	if (lim->low == NO_LIMIT)
+		EFX_ERR(efx, "%10s  0x%02x (nominal value 0x%02x)\n", lim->name,
+			val, lim->high);
+	else
+		EFX_ERR(efx, "%10s  0x%02x (nominal range 0x%02x - 0x%02x)\n",
+			lim->name, val, lim->high, lim->low);
+	return 1;
+}
+
+static int sfe4002_check_hw(struct efx_nic *efx)
+{
+	int rc;
+
+	/* A0 board rev. 4002s  report a temperature fault the whole time
+	 * (bad sensor) so we mask it out. */
+	unsigned alarm_mask = (efx->board_info.minor > 0) ?
+		0 : ~EFX_LM87_ETMP_INT;
+
+	/* Check the sensor (NOP if not present). */
+	rc = efx_check_lm87(efx, alarm_mask);
+
+	/* We treat both lm87 interrupts and failure to talk to the lm87
+	 * as problems (since failure will only be reported if we did
+	 * find the sensor at probe time. */
+	if (rc)
+		EFX_ERR(efx, "sensor alert!\n");
+	return rc;
+}
+
 static int sfe4002_init(struct efx_nic *efx)
 {
+	u8 lm87_bytes[LM87_SENSOR_BYTES];
+	int nbytes;
+	int rc;
+
+	efx->board_info.monitor = sfe4002_check_hw;
+	efx->board_info.interpret_sensor = sfe4002_sensor_meaning;
 	efx->board_info.init_leds = sfe4002_init_leds;
 	efx->board_info.set_fault_led = sfe4002_fault_led;
 	efx->board_info.blink = board_blink;
+	/* To clean up shut down the lm87 (NOP if not present) */
+	efx->board_info.fini = efx_remove_lm87;
+
+	nbytes = sensor_limits_to_bytes(sfe4002_lm87_limits,
+					sfe4002_lm87_nlimits, lm87_bytes,
+					LM87_SENSOR_BYTES);
+
+	/* Activate the lm87 sensor if present (succeeds if nothing there) */
+	rc = efx_probe_lm87(efx, SFE4002_LM87_I2C_ID,
+			    lm87_bytes, nbytes, sfe4002_lm87_irq_mask);
+
+	return rc;
+}
+
+/*****************************************************************************
+ * Support for the SFE4003
+ *
+ */
+/* LM87 configuration data for the sensor on the SFE4003 board */
+static const struct sensor_conf sfe4003_lm87_limits[] = {
+	{"1.5V line", 0x78, 0x6d},	/* 2.5V input, values scaled for 1.5V */
+	{"1.2V line", 0x5a, 0x51},	/* Vccp1 */
+	{"3.3V line", 0xca, 0xb6},
+	{"5V line", 0xc0, 0x00},	/* Sensor not connected. */
+	{"12V line", 0xe0, 0xb0},
+	{"1V line", 0x4b, 0x44},	/* Vccp2 */
+	{"Ext. temp.", 0x46, 0x0a},	/* ASIC temp. */
+	{"Int. temp.", 0x3c, 0x0a},	/* Board temp. */
+	{"", 0xff, NO_LIMIT},		/* FAN1/AIN1 unused */
+	{"", 0xff, NO_LIMIT}		/* FAN2/AIN2 unused */
+};
+
+static const int sfe4003_lm87_nlimits = ARRAY_SIZE(sfe4003_lm87_limits);
+
+static u16 sfe4003_lm87_irq_mask = EFX_LM87_NO_INTS;
+
+
+static int sfe4003_sensor_meaning(struct efx_nic *efx, int limit_num,
+				  unsigned val)
+{
+	const struct sensor_conf *lim = &sfe4003_lm87_limits[limit_num];
+	if (lim->low == NO_LIMIT)
+		return 0; /* Neither AIN1 nor AIN2 mean anything to us */
+	else
+		EFX_ERR(efx, "%10s  0x%02x (nominal range 0x%02x - 0x%02x)\n",
+			lim->name, val, lim->high, lim->low);
+	return 1;
+}
+
+/* I2C ID of the onboard LM87 chip. This is board-specific as the bottom two
+ * bits are set by strap pins */
+#define SFE4003_LM87_I2C_ID (0x2e)
+
+/* Board-specific LED info. */
+#define SFE4003_RED_LED_GPIO	(11)
+#define SFE4003_LED_ON		(1)
+#define SFE4003_LED_OFF		(0)
+
+static void sfe4003_fault_led(struct efx_nic *efx, int state)
+{
+	/* The LEDs were not wired to GPIOs before A3 */
+	if (efx->board_info.minor < 3 && efx->board_info.major == 0)
+		return;
+
+	txc_set_gpio_val(efx, SFE4003_RED_LED_GPIO,
+			 state ? SFE4003_LED_ON : SFE4003_LED_OFF);
+}
+
+static int sfe4003_init_leds(struct efx_nic *efx)
+{
+	/* The LEDs were not wired to GPIOs before A3 */
+	if (efx->board_info.minor < 3 && efx->board_info.major == 0)
+		return 0;
+
+	txc_set_gpio_dir(efx, SFE4003_RED_LED_GPIO, TXC_GPIO_DIR_OUTPUT);
+	txc_set_gpio_val(efx, SFE4003_RED_LED_GPIO, SFE4003_LED_OFF);
 	return 0;
 }
 
+static int sfe4003_check_hw(struct efx_nic *efx)
+{
+	int rc;
+	/* A0/A1/A2 board rev. 4003s  report a temperature fault the whole time
+	 * (bad sensor) so we mask it out. */
+	unsigned alarm_mask =
+		~(EFX_LM87_ETMP_INT | EFX_LM87_FAN1_INT | EFX_LM87_FAN2_INT);
+
+	/* Check the sensor (NOP if not present). */
+
+	rc = efx_check_lm87(efx, alarm_mask);
+	/* We treat both lm87 interrupts and failure to talk to the lm87
+	 * as problems (since failure will only be reported if we did
+	 * find the sensor at probe time. */
+	if (rc)
+		EFX_ERR(efx, "sensor alert!\n");
+
+	return rc;
+}
+
+static int sfe4003_init(struct efx_nic *efx)
+{
+	u8 lm87_bytes[LM87_SENSOR_BYTES];
+	int nbytes;
+	int rc;
+	efx->board_info.monitor = sfe4003_check_hw;
+	efx->board_info.interpret_sensor = sfe4003_sensor_meaning;
+	efx->board_info.init_leds = sfe4003_init_leds;
+	efx->board_info.set_fault_led = sfe4003_fault_led;
+	efx->board_info.blink = board_blink;
+	/* To clean up shut down the lm87 (NOP if not present) */
+	efx->board_info.fini = efx_remove_lm87;
+
+	nbytes = sensor_limits_to_bytes(sfe4003_lm87_limits,
+					sfe4003_lm87_nlimits, lm87_bytes,
+					LM87_SENSOR_BYTES);
+
+	/* Activate the lm87 sensor if present (succeeds if nothing there) */
+	rc = efx_probe_lm87(efx, SFE4003_LM87_I2C_ID,
+			    lm87_bytes, nbytes, sfe4003_lm87_irq_mask);
+
+	if (rc < 0)
+		EFX_ERR(efx, "Temperature sensor probe failure: "
+			"please check the jumper position\n");
+	return rc;
+}
+
+/*****************************************************************************
+ * Support for the SFE4005
+ *
+ */
+/* LM87 configuration data for the sensor on the SFE4005 board */
+static const u8 sfe4005_lm87_limits[] = {
+	0x51, /* 2.5V high lim. (actually monitor 1.0V line, so 1050mV)  */
+	0x49, /* 2.5V low lim. (950mV) */
+	0xf6, /* Vccp1 high lim. (3.3V rail, 3465 mV) */
+	0xde, /* Vcpp1 low lim. (3.3V rail, 3135 mV) */
+	0xca, /* 3.3V AUX high lim. (3465 mV)  */
+	0xb6, /* 3.3V AUX low lim. (3135mV) */
+	0xc0, /* 5V high lim. not connected) */
+	0x00, /* 5V low lim. (not connected) */
+	0xd0, /* 12V high lim. (13000mV) */
+	0xb0, /* 12V low lim. (11000mV) */
+	0xc0, /* Vccp2 high lim. (unused) */
+	0x00, /* Vccp2 low lim. (unused) */
+	0x46, /* Ext temp 1 (ASIC) high lim. */
+	0x0a, /* Ext temp 1 low lim. */
+	0x3c, /* Int temp (board) high lim. */
+	0x0a, /* Int temp 1 low lim. */
+	0xff, /* Fan 1 high (unused) */
+	0xff, /* Fan 2 high (unused) */
+};
+
+#define SFE4005_LM87_I2C_ID (0x2e)
+
+/* Until the LM87 monitoring is interrupt driven. */
+#define SFE4005_LM87_IRQMASK	EFX_LM87_NO_INTS
+
+#define SFE4005_PCF8575_I2C_ID	(0x20)
+/* Definitions for the I/O expander that controls the CX4 chip:
+ * which PCF8575 pin maps to which function */
+#define SFE4005_PORT0_EXTLOOP	(1 << 0)
+#define SFE4005_PORT1_EXTLOOP	(1 << 1)
+#define SFE4005_HOSTPROT_LOOP	(1 << 2)
+#define SFE4005_BCAST		(1 << 3) /* TX on both ports */
+#define SFE4005_PORT0_EQ	(1 << 4)
+#define SFE4005_PORT1_EQ	(1 << 5)
+#define SFE4005_HOSTPORT_EQ	(1 << 6)
+#define	SFE4005_PORTSEL		(1 << 7) /* Which port (for RX in BCAST mode) */
+#define SFE4005_PORT0_PRE_LBN	(8)      /* Preemphasis on port 0 (2 bits)*/
+#define SFE4005_PORT1_PRE_LBN	(10)     /* Preemphasis on port 1 (2 bits)*/
+#define SFE4005_HOSTPORT_PRE_LBN (12)    /* Preemphasis on host port (2 bits) */
+#define SFE4005_UNUSED		(1 << 14)
+#define SFE4005_CX4uC_nRESET	(1 << 15) /* Reset the controller on CX4 chip */
+
+
+/* By default only turn on host port EQ. Can also OR in SFE4005_PORT0_EQ,
+ * SFE4005_PORT1_EQ but this hasn't been seen to make a difference. */
+#define SFE4005_CX4_DEFAULTS (SFE4005_CX4uC_nRESET | SFE4005_HOSTPORT_EQ)
+
+static int sfe4005_write_ioexpander(struct efx_nic *efx)
+{
+	unsigned long iobits = (unsigned long)efx->phy_data;
+	struct efx_i2c_interface *i2c = &efx->i2c;
+	u8 send[2], check[2];
+	int rc;
+	/* Do not, EVER, deassert nRESET as that will reset Falcon too,
+	 * and the driver won't know to repush the configuration, so
+	 * nothing will work until the next power cycle. */
+	BUG_ON(!(iobits & SFE4005_CX4uC_nRESET));
+	send[0] = (iobits & 0xff);
+	send[1] = ((iobits >> 8) & 0xff);
+	rc = efx_i2c_send_bytes(i2c, SFE4005_PCF8575_I2C_ID, send, 2);
+	if (rc) {
+		EFX_ERR(efx, "failed to write to I/O expander: %d\n", rc);
+		return rc;
+	}
+	/* Paranoia: just check what the I/O expander reads back */
+	rc = efx_i2c_recv_bytes(i2c, SFE4005_PCF8575_I2C_ID, check, 2);
+	if (rc)
+		EFX_ERR(efx, "failed to read back from I/O expander: %d\n", rc);
+	else if (check[0] != send[0] || check[1] != send[1])
+		EFX_ERR(efx, "read back wrong value from I/O expander: "
+			"wanted %.2x%.2x, got %.2x%.2x\n",
+			send[1], send[0], check[1], check[0]);
+	return rc;
+}
+
+static int sfe4005_init(struct efx_nic *efx)
+{
+	unsigned long iobits = SFE4005_CX4_DEFAULTS;
+	int rc;
+
+	/* There is no PHY as such on the SFE4005 so phy_data is ours. */
+	efx->phy_data = (void *)iobits;
+
+	/* Push the values */
+	rc = sfe4005_write_ioexpander(efx);
+	if (rc)
+		return rc;
+
+	/* Activate the lm87 sensor if present (succeeds if nothing there) */
+	rc = efx_probe_lm87(efx, SFE4005_LM87_I2C_ID,
+			    sfe4005_lm87_limits,
+			    sizeof(sfe4005_lm87_limits), SFE4005_LM87_IRQMASK);
+
+	/* To clean up shut down the lm87 (NOP if not present) */
+	efx->board_info.fini = efx_remove_lm87;
+
+	return rc;
+}
+
 /* This will get expanded as board-specific details get moved out of the
  * PHY drivers. */
 struct efx_board_data {
 	const char *ref_model;
 	const char *gen_type;
 	int (*init) (struct efx_nic *nic);
+	unsigned mwatts;
 };
 
+static void dummy_fini(struct efx_nic *nic)
+{
+}
+
 static int dummy_init(struct efx_nic *nic)
 {
+	nic->board_info.fini = dummy_fini;
 	return 0;
 }
 
+/* Maximum board power (mW)
+ * Falcon controller ASIC accounts for 2.2W
+ * 10Xpress PHY accounts for 12W
+ *
+ */
+#define SFE4001_POWER 18000
+#define SFE4002_POWER 7500
+#define SFE4003_POWER 4500
+#define SFE4005_POWER 4500
+
 static struct efx_board_data board_data[] = {
 	[EFX_BOARD_INVALID] =
-	{NULL,	    NULL,                  dummy_init},
+	{NULL,	    NULL,                  dummy_init,      0},
 	[EFX_BOARD_SFE4001] =
-	{"SFE4001", "10GBASE-T adapter",   sfe4001_poweron},
+	{"SFE4001", "10GBASE-T adapter",   sfe4001_poweron, SFE4001_POWER },
 	[EFX_BOARD_SFE4002] =
-	{"SFE4002", "XFP adapter",         sfe4002_init},
+	{"SFE4002", "XFP adapter",         sfe4002_init,    SFE4002_POWER },
+	[EFX_BOARD_SFE4003] =
+	{"SFE4003", "10GBASE-CX4 adapter", sfe4003_init,    SFE4003_POWER },
+	[EFX_BOARD_SFE4005] =
+	{"SFE4005", "10G blade adapter",   sfe4005_init,    SFE4005_POWER },
 };
 
 int efx_set_board_info(struct efx_nic *efx, u16 revision_info)
@@ -138,6 +498,9 @@ int efx_set_board_info(struct efx_nic *e
 		case PHY_TYPE_XFP:
 			efx->board_info.type = EFX_BOARD_SFE4002;
 			break;
+		case PHY_TYPE_CX4_RTMR:
+			efx->board_info.type = EFX_BOARD_SFE4003;
+			break;
 		default:
 			efx->board_info.type = 0;
 			break;
@@ -159,6 +522,7 @@ int efx_set_board_info(struct efx_nic *e
 			 'A' + efx->board_info.major, efx->board_info.minor);
 
 	efx->board_info.init = data->init;
+	efx->board_info.mwatts = data->mwatts;
 
 	return rc;
 }
Index: head-2008-06-18/drivers/net/sfc/boards.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/boards.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/boards.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,28 +1,51 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_BOARDS_H
 #define EFX_BOARDS_H
 
-/* Board IDs (must fit in 8 bits) */
+/* Board IDs (must fit in 8 bits). Note that 0 must never be assigned because
+ * on early boards it means there is no revision info. Board types pre 400x
+ * are not covered here, but this is not a problem because:
+ * - the early Falcon boards (FPGA, 401, 403) don't have any extra H/W we
+ * need care about and aren't being updated.
+ */
 enum efx_board_type {
-	EFX_BOARD_INVALID = 0,
-	EFX_BOARD_SFE4001 = 1,   /* SFE4001 (10GBASE-T) */
+	EFX_BOARD_INVALID = 0, /* Early boards do not have board rev. info. */
+	EFX_BOARD_SFE4001 = 1,
 	EFX_BOARD_SFE4002 = 2,
+	EFX_BOARD_SFE4003 = 3,
+	EFX_BOARD_SFE4005 = 4,
 	/* Insert new types before here */
 	EFX_BOARD_MAX
 };
 
 extern int efx_set_board_info(struct efx_nic *efx, u16 revision_info);
+
+/* SFE4001 (10GBASE-T) */
 extern int sfe4001_poweron(struct efx_nic *efx);
 extern void sfe4001_poweroff(struct efx_nic *efx);
-/* Are we putting the PHY into flash config mode */
-extern unsigned int sfe4001_phy_flash_cfg;
 
 #endif
Index: head-2008-06-18/drivers/net/sfc/debugfs.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/debugfs.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,836 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/debugfs.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "debugfs.h"
+#include "falcon.h"
+
+/* Parameter definition bound to a structure - each file has one of these */
+struct efx_debugfs_bound_param {
+	const struct efx_debugfs_parameter *param;
+	void *structure;
+};
+
+
+/* Maximum length for a name component or symlink target */
+#define EFX_DEBUGFS_NAME_LEN 32
+
+
+/* Top-level debug directory ([/sys/kernel]/debug/sfc) */
+static struct dentry *efx_debug_root;
+
+/* "cards" directory ([/sys/kernel]/debug/sfc/cards) */
+static struct dentry *efx_debug_cards;
+
+
+/* Sequential file interface to bound parameters */
+
+static int efx_debugfs_seq_show(struct seq_file *file, void *v)
+{
+	struct efx_debugfs_bound_param *binding =
+		(struct efx_debugfs_bound_param *)file->private;
+
+	return binding->param->reader(file,
+				      binding->structure +
+				      binding->param->offset);
+}
+
+static int efx_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, efx_debugfs_seq_show, inode->i_private);
+}
+
+static struct file_operations efx_debugfs_file_ops = {
+	.owner   = THIS_MODULE,
+	.open    = efx_debugfs_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release
+};
+
+
+/**
+ * efx_fini_debugfs_child - remove a named child of a debugfs directory
+ * @dir:		Directory
+ * @name:		Name of child
+ *
+ * This removes the named child from the directory, if it exists.
+ */
+void efx_fini_debugfs_child(struct dentry *dir, const char *name)
+{
+	struct qstr child_name;
+	struct dentry *child;
+
+	child_name.len = strlen(name);
+	child_name.name = name;
+	child_name.hash = full_name_hash(child_name.name, child_name.len);
+	child = d_lookup(dir, &child_name);
+	if (child) {
+		/* If it's a "regular" file, free its parameter binding */
+		if (S_ISREG(child->d_inode->i_mode))
+			kfree(child->d_inode->i_private);
+		debugfs_remove(child);
+		dput(child);
+	}
+}
+
+/*
+ * Remove a debugfs directory.
+ *
+ * This removes the named parameter-files and sym-links from the
+ * directory, and the directory itself.  It does not do any recursion
+ * to subdirectories.
+ */
+static void efx_fini_debugfs_dir(struct dentry *dir,
+				 struct efx_debugfs_parameter *params,
+				 const char *const *symlink_names)
+{
+	if (!dir)
+		return;
+
+	while (params->name) {
+		efx_fini_debugfs_child(dir, params->name);
+		params++;
+	}
+	while (symlink_names && *symlink_names) {
+		efx_fini_debugfs_child(dir, *symlink_names);
+		symlink_names++;
+	}
+	debugfs_remove(dir);
+}
+
+/* Functions for printing various types of parameter. */
+
+int efx_debugfs_read_uint(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%#x\n", *(unsigned int *)data);
+}
+
+int efx_debugfs_read_int(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%d\n", *(int *)data);
+}
+
+int efx_debugfs_read_atomic(struct seq_file *file, void *data)
+{
+	unsigned int value = atomic_read((atomic_t *) data);
+
+	return seq_printf(file, "%#x\n", value);
+}
+
+int efx_debugfs_read_dword(struct seq_file *file, void *data)
+{
+	unsigned int value = EFX_DWORD_FIELD(*(efx_dword_t *) data,
+					     EFX_DWORD_0);
+
+	return seq_printf(file, "%#x\n", value);
+}
+
+static int efx_debugfs_read_int_mode(struct seq_file *file, void *data)
+{
+	unsigned int value = *(enum efx_int_mode *) data;
+
+	return seq_printf(file, "%d => %s\n", value,
+			  STRING_TABLE_LOOKUP(value, efx_interrupt_mode));
+}
+
+#define EFX_INT_MODE_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,			\
+		      enum efx_int_mode, efx_debugfs_read_int_mode)
+
+static int efx_debugfs_read_loop_mode(struct seq_file *file, void *data)
+{
+	unsigned int value = *(enum efx_loopback_mode *)data;
+
+	return seq_printf(file, "%d => %s\n", value,
+			  STRING_TABLE_LOOKUP(value, efx_loopback_mode));
+}
+
+#define EFX_LOOPBACK_MODE_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,			\
+		      enum efx_loopback_mode, efx_debugfs_read_loop_mode)
+
+static int efx_debugfs_read_phy_type(struct seq_file *file, void *data)
+{
+	unsigned int value = *(enum phy_type *) data;
+
+	return seq_printf(file, "%d => %s\n", value,
+			  STRING_TABLE_LOOKUP(value, efx_phy_type));
+}
+
+#define EFX_PHY_TYPE_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,			\
+		      enum phy_type, efx_debugfs_read_phy_type)
+
+int efx_debugfs_read_string(struct seq_file *file, void *data)
+{
+	return seq_puts(file, (const char *)data);
+}
+
+
+/**
+ * efx_init_debugfs_files - create parameter-files in a debugfs directory
+ * @parent:		Containing directory
+ * @params:		Pointer to zero-terminated parameter definition array
+ * @structure:		Structure containing parameters
+ *
+ * Add parameter-files to the given debugfs directory.  Return a
+ * negative error code or 0 on success.
+ */
+static int efx_init_debugfs_files(struct dentry *parent,
+				  struct efx_debugfs_parameter *params,
+				  void *structure)
+{
+	struct efx_debugfs_parameter *param = params;
+
+	while (param->name) {
+		struct dentry *entry;
+		struct efx_debugfs_bound_param *binding;
+
+		binding = kmalloc(sizeof(*binding), GFP_KERNEL);
+		if (!binding)
+			goto err;
+		binding->param = param;
+		binding->structure = structure;
+
+		entry = debugfs_create_file(param->name, S_IRUGO, parent,
+					    binding, &efx_debugfs_file_ops);
+		if (!entry) {
+			kfree(binding);
+			goto err;
+		}
+
+		param++;
+	}
+
+	return 0;
+
+ err:
+	while (param != params) {
+		param--;
+		efx_fini_debugfs_child(parent, param->name);
+	}
+	return -ENOMEM;
+}
+
+/**
+ * efx_init_debugfs_netdev - create debugfs sym-links for net device
+ * @net_dev:		Net device
+ *
+ * Create sym-links named after @net_dev to the debugfs directories for
+ * the corresponding NIC and  port.  Return a negative error code or 0 on
+ * success.  The sym-links must be cleaned up using
+ * efx_fini_debugfs_netdev().
+ */
+int efx_init_debugfs_netdev(struct net_device *net_dev)
+{
+	struct efx_nic *efx = net_dev->priv;
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	size_t len;
+
+	if (snprintf(name, sizeof(name), "nic_%s", net_dev->name) >=
+	    sizeof(name))
+		return -ENAMETOOLONG;
+	if (snprintf(target, sizeof(target), "cards/%s", pci_name(efx->pci_dev))
+	    >= sizeof(target))
+		return -ENAMETOOLONG;
+	efx->debug_symlink = debugfs_create_symlink(name,
+						    efx_debug_root, target);
+	if (!efx->debug_symlink)
+		return -ENOMEM;
+
+	if (snprintf(name, sizeof(name), "if_%s", net_dev->name) >=
+	    sizeof(name))
+		return -ENAMETOOLONG;
+	len = snprintf(target, sizeof(target),
+		       "cards/%s/port0", pci_name(efx->pci_dev));
+	if (len >= sizeof(target))
+		return -ENAMETOOLONG;
+	efx->debug_port_symlink = debugfs_create_symlink(name,
+							 efx_debug_root,
+							 target);
+	if (!efx->debug_port_symlink)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/**
+ * efx_fini_debugfs_netdev - remove debugfs sym-links for net device
+ * @net_dev:		Net device
+ *
+ * Remove sym-links created for @net_dev by efx_init_debugfs_netdev().
+ */
+void efx_fini_debugfs_netdev(struct net_device *net_dev)
+{
+	struct efx_nic *efx = net_dev->priv;
+
+	debugfs_remove(efx->debug_port_symlink);
+	efx->debug_port_symlink = NULL;
+	debugfs_remove(efx->debug_symlink);
+	efx->debug_symlink = NULL;
+}
+
+/* Per-port parameters */
+static struct efx_debugfs_parameter efx_debugfs_port_parameters[] = {
+	EFX_NAMED_PARAMETER(enabled, struct efx_nic, port_enabled,
+			    int, efx_debugfs_read_int),
+	EFX_INT_PARAMETER(struct efx_nic, rx_checksum_enabled),
+	EFX_ATOMIC_PARAMETER(struct efx_nic, netif_stop_count),
+	EFX_INT_PARAMETER(struct efx_nic, link_up),
+	EFX_UINT_PARAMETER(struct efx_nic, link_options),
+	EFX_INT_PARAMETER(struct efx_nic, promiscuous),
+	EFX_UINT_PARAMETER(struct efx_nic, loopback_modes),
+	EFX_LOOPBACK_MODE_PARAMETER(struct efx_nic, loopback_mode),
+	EFX_PHY_TYPE_PARAMETER(struct efx_nic, phy_type),
+	EFX_NAMED_PARAMETER(phy_id, struct efx_nic, mii.phy_id,
+			    int, efx_debugfs_read_int),
+	EFX_UINT_PARAMETER(struct efx_nic, n_link_state_changes),
+	{NULL},
+};
+
+/**
+ * efx_init_debugfs_port - create debugfs directory for port
+ * @efx:		Efx NIC
+ *
+ * Create a debugfs directory containing parameter-files for @efx.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_port().
+ */
+int efx_init_debugfs_port(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Create directory */
+	efx->debug_port_dir = debugfs_create_dir("port0", efx->debug_dir);
+	if (!efx->debug_port_dir)
+		return -ENOMEM;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(efx->debug_port_dir,
+				    efx_debugfs_port_parameters,
+				    (void *)efx);
+	if (rc)
+		efx_fini_debugfs_port(efx);
+
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_port - remove debugfs directory for port
+ * @efx:		Efx NIC
+ *
+ * Remove directory created for @efx by efx_init_debugfs_port().
+ */
+void efx_fini_debugfs_port(struct efx_nic *efx)
+{
+	efx_fini_debugfs_dir(efx->debug_port_dir,
+			     efx_debugfs_port_parameters, NULL);
+	efx->debug_port_dir = NULL;
+}
+
+/**
+ * efx_extend_debugfs_port - add parameter-files to directory for port
+ * @efx:		Efx NIC
+ * @structure:		Structure containing parameters
+ * @params:		Pointer to zero-terminated parameter definition array
+ *
+ * Add parameter-files to the debugfs directory for @efx.  Return
+ * a negative error code or 0 on success.  This is intended for
+ * PHY-specific parameters.  The files must be cleaned up using
+ * efx_trim_debugfs_port().
+ */
+int efx_extend_debugfs_port(struct efx_nic *efx,
+			    void *structure,
+			    struct efx_debugfs_parameter *params)
+{
+	return efx_init_debugfs_files(efx->debug_port_dir, params, structure);
+}
+
+/**
+ * efx_trim_debugfs_port - remove parameter-files from directory for port
+ * @efx:		Efx NIC
+ * @params:		Pointer to zero-terminated parameter definition array
+ *
+ * Remove parameter-files previously added to the debugfs directory
+ * for @efx using efx_extend_debugfs_port().
+ */
+void efx_trim_debugfs_port(struct efx_nic *efx,
+			   struct efx_debugfs_parameter *params)
+{
+	struct dentry *dir = efx->debug_port_dir;
+
+	if (dir) {
+		struct efx_debugfs_parameter *field;
+		for (field = params; field->name; field++)
+			efx_fini_debugfs_child(dir, field->name);
+	}
+}
+
+/* Per-TX-queue parameters */
+static struct efx_debugfs_parameter efx_debugfs_tx_queue_parameters[] = {
+	EFX_UINT_PARAMETER(struct efx_tx_queue, insert_count),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, write_count),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, read_count),
+	EFX_INT_PARAMETER(struct efx_tx_queue, stopped),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_bursts),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_long_headers),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_packets),
+	{NULL},
+};
+
+static void efx_fini_debugfs_tx_queue(struct efx_tx_queue *tx_queue);
+
+/**
+ * efx_init_debugfs_tx_queue - create debugfs directory for TX queue
+ * @tx_queue:		Efx TX queue
+ *
+ * Create a debugfs directory containing parameter-files for @tx_queue.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_tx_queue().
+ */
+static int efx_init_debugfs_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_TX_QUEUE_NAME(tx_queue))
+	    >= sizeof(name))
+		goto err_len;
+	tx_queue->debug_dir = debugfs_create_dir(name,
+						 tx_queue->efx->debug_dir);
+	if (!tx_queue->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(tx_queue->debug_dir,
+				    efx_debugfs_tx_queue_parameters,
+				    (void *)tx_queue);
+	if (rc)
+		goto err;
+
+	/* Create symlink to channel */
+	if (snprintf(target, sizeof(target),
+		     "../" EFX_CHANNEL_NAME(tx_queue->channel)) >=
+	    sizeof(target))
+		goto err_len;
+	if (!debugfs_create_symlink("channel", tx_queue->debug_dir, target))
+		goto err_mem;
+
+	/* Create symlink to port */
+	if (!debugfs_create_symlink("port", tx_queue->debug_dir, "../port0"))
+		goto err_mem;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_tx_queue(tx_queue);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_tx_queue - remove debugfs directory for TX queue
+ * @tx_queue:		Efx TX queue
+ *
+ * Remove directory created for @tx_queue by efx_init_debugfs_tx_queue().
+ */
+static void efx_fini_debugfs_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	static const char *const symlink_names[] = {
+		"channel", "port", NULL
+	};
+
+	efx_fini_debugfs_dir(tx_queue->debug_dir,
+			     efx_debugfs_tx_queue_parameters, symlink_names);
+	tx_queue->debug_dir = NULL;
+}
+
+/* Per-RX-queue parameters */
+static struct efx_debugfs_parameter efx_debugfs_rx_queue_parameters[] = {
+	EFX_INT_PARAMETER(struct efx_rx_queue, added_count),
+	EFX_INT_PARAMETER(struct efx_rx_queue, removed_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, max_fill),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, fast_fill_trigger),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, fast_fill_limit),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, min_fill),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, min_overfill),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, alloc_page_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, alloc_skb_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, slow_fill_count),
+	{NULL},
+};
+
+static void efx_fini_debugfs_rx_queue(struct efx_rx_queue *rx_queue);
+
+/**
+ * efx_init_debugfs_rx_queue - create debugfs directory for RX queue
+ * @rx_queue:		Efx RX queue
+ *
+ * Create a debugfs directory containing parameter-files for @rx_queue.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_rx_queue().
+ */
+static int efx_init_debugfs_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_RX_QUEUE_NAME(rx_queue))
+	    >= sizeof(name))
+		goto err_len;
+	rx_queue->debug_dir = debugfs_create_dir(name,
+						 rx_queue->efx->debug_dir);
+	if (!rx_queue->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(rx_queue->debug_dir,
+				    efx_debugfs_rx_queue_parameters,
+				    (void *)rx_queue);
+	if (rc)
+		goto err;
+
+	/* Create symlink to channel */
+	if (snprintf(target, sizeof(target),
+		     "../" EFX_CHANNEL_NAME(rx_queue->channel)) >=
+	    sizeof(target))
+		goto err_len;
+	if (!debugfs_create_symlink("channel", rx_queue->debug_dir, target))
+		goto err_mem;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_rx_queue(rx_queue);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_rx_queue - remove debugfs directory for RX queue
+ * @rx_queue:		Efx RX queue
+ *
+ * Remove directory created for @rx_queue by efx_init_debugfs_rx_queue().
+ */
+static void efx_fini_debugfs_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	const char *const symlink_names[] = {
+		"channel", NULL
+	};
+
+	efx_fini_debugfs_dir(rx_queue->debug_dir,
+			     efx_debugfs_rx_queue_parameters, symlink_names);
+	rx_queue->debug_dir = NULL;
+}
+
+/* Per-channel parameters */
+static struct efx_debugfs_parameter efx_debugfs_channel_parameters[] = {
+	EFX_INT_PARAMETER(struct efx_channel, enabled),
+	EFX_INT_PARAMETER(struct efx_channel, irq),
+	EFX_UINT_PARAMETER(struct efx_channel, has_interrupt),
+	EFX_UINT_PARAMETER(struct efx_channel, irq_moderation),
+	EFX_UINT_PARAMETER(struct efx_channel, eventq_read_ptr),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_tobe_disc),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_ip_frag_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_ip_hdr_chksum_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_tcp_udp_chksum_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_frm_trunc),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_overlength),
+	EFX_UINT_PARAMETER(struct efx_channel, n_skbuff_leaks),
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_level),
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_push_pages),
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_pop_pages),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_merges),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_bursts),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_slow_start),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_misorder),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_too_many),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_new_stream),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_drop_idle),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_drop_closed),
+	{NULL},
+};
+
+static void efx_fini_debugfs_channel(struct efx_channel *channel);
+
+/**
+ * efx_init_debugfs_channel - create debugfs directory for channel
+ * @channel:		Efx channel
+ *
+ * Create a debugfs directory containing parameter-files for @channel.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_channel().
+ */
+static int efx_init_debugfs_channel(struct efx_channel *channel)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_CHANNEL_NAME(channel))
+	    >= sizeof(name))
+		goto err_len;
+	channel->debug_dir = debugfs_create_dir(name, channel->efx->debug_dir);
+	if (!channel->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(channel->debug_dir,
+				    efx_debugfs_channel_parameters,
+				    (void *)channel);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_channel(channel);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_channel - remove debugfs directory for channel
+ * @channel:		Efx channel
+ *
+ * Remove directory created for @channel by efx_init_debugfs_channel().
+ */
+static void efx_fini_debugfs_channel(struct efx_channel *channel)
+{
+	efx_fini_debugfs_dir(channel->debug_dir,
+			     efx_debugfs_channel_parameters, NULL);
+	channel->debug_dir = NULL;
+}
+
+/* Per-NIC parameters */
+static struct efx_debugfs_parameter efx_debugfs_nic_parameters[] = {
+	EFX_INT_PARAMETER(struct efx_nic, legacy_irq),
+	EFX_INT_PARAMETER(struct efx_nic, rss_queues),
+	EFX_UINT_PARAMETER(struct efx_nic, rx_buffer_len),
+	EFX_INT_MODE_PARAMETER(struct efx_nic, interrupt_mode),
+	{.name = "hardware_desc",
+	 .offset = 0,
+	 .reader = falcon_debugfs_read_hardware_desc},
+	{NULL},
+};
+
+/* Per-NIC error counts */
+static struct efx_debugfs_parameter efx_debugfs_nic_error_parameters[] = {
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, missing_event),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, rx_reset),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, rx_desc_fetch),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, tx_desc_fetch),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, spurious_tx),
+	{NULL},
+};
+
+/**
+ * efx_init_debugfs_channels - create debugfs directories for NIC channels
+ * @efx:		Efx NIC
+ *
+ * Create subdirectories of @efx's debugfs directory for all the
+ * channels, RX queues and TX queues used by this driver.  Return a
+ * negative error code or 0 on success.  The subdirectories must be
+ * cleaned up using efx_fini_debugfs_channels().
+ */
+int efx_init_debugfs_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int rc;
+
+	efx_for_each_channel(channel, efx) {
+		rc = efx_init_debugfs_channel(channel);
+		if (rc)
+			goto err;
+	}
+
+	efx_for_each_rx_queue(rx_queue, efx) {
+		rc = efx_init_debugfs_rx_queue(rx_queue);
+		if (rc)
+			goto err;
+	}
+
+	efx_for_each_tx_queue(tx_queue, efx) {
+		rc = efx_init_debugfs_tx_queue(tx_queue);
+		if (rc)
+			goto err;
+	}
+
+	return 0;
+
+ err:
+	efx_fini_debugfs_channels(efx);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_channels - remove debugfs directories for NIC queues
+ * @efx:		Efx NIC
+ *
+ * Remove subdirectories of @efx's debugfs directory created by
+ * efx_init_debugfs_channels().
+ */
+void efx_fini_debugfs_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+
+	efx_for_each_tx_queue(tx_queue, efx)
+		efx_fini_debugfs_tx_queue(tx_queue);
+
+	efx_for_each_rx_queue(rx_queue, efx)
+		efx_fini_debugfs_rx_queue(rx_queue);
+
+	efx_for_each_channel(channel, efx)
+		efx_fini_debugfs_channel(channel);
+}
+
+/**
+ * efx_init_debugfs_nic - create debugfs directory for NIC
+ * @efx:		Efx NIC
+ *
+ * Create debugfs directory containing parameter-files for @efx,
+ * and a subdirectory "errors" containing per-NIC error counts.
+ * Return a negative error code or 0 on success.  The directories
+ * must be cleaned up using efx_fini_debugfs_nic().
+ */
+int efx_init_debugfs_nic(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Create directory */
+	efx->debug_dir = debugfs_create_dir(pci_name(efx->pci_dev),
+					    efx_debug_cards);
+	if (!efx->debug_dir)
+		goto err_mem;
+
+	/* Create errors directory */
+	efx->errors.debug_dir = debugfs_create_dir("errors", efx->debug_dir);
+	if (!efx->errors.debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(efx->debug_dir,
+				    efx_debugfs_nic_parameters, (void *)efx);
+	if (rc)
+		goto err;
+	rc = efx_init_debugfs_files(efx->errors.debug_dir,
+				    efx_debugfs_nic_error_parameters,
+				    (void *)&efx->errors);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_nic(efx);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_nic - remove debugfs directories for NIC
+ * @efx:		Efx NIC
+ *
+ * Remove debugfs directories created for @efx by efx_init_debugfs_nic().
+ */
+void efx_fini_debugfs_nic(struct efx_nic *efx)
+{
+	efx_fini_debugfs_dir(efx->errors.debug_dir,
+			     efx_debugfs_nic_error_parameters, NULL);
+	efx->errors.debug_dir = NULL;
+	efx_fini_debugfs_dir(efx->debug_dir, efx_debugfs_nic_parameters, NULL);
+	efx->debug_dir = NULL;
+}
+
+/**
+ * efx_init_debugfs - create debugfs directories for sfc driver
+ *
+ * Create debugfs directories "sfc" and "sfc/cards".  This must be
+ * called before any of the other functions that create debugfs
+ * directories.  Return a negative error code or 0 on success.  The
+ * directories must be cleaned up using efx_fini_debugfs().
+ */
+int efx_init_debugfs(void)
+{
+	/* Create top-level directory */
+	efx_debug_root = debugfs_create_dir("sfc", NULL);
+	if (!efx_debug_root)
+		goto err;
+
+	/* Create "cards" directory */
+	efx_debug_cards = debugfs_create_dir("cards", efx_debug_root);
+	if (!efx_debug_cards)
+		goto err;
+
+	return 0;
+
+ err:
+	efx_fini_debugfs();
+	return -ENOMEM;
+}
+
+/**
+ * efx_fini_debugfs - remove debugfs directories for sfc driver
+ *
+ * Remove directories created by efx_init_debugfs().
+ */
+void efx_fini_debugfs(void)
+{
+	debugfs_remove(efx_debug_cards);
+	efx_debug_cards = NULL;
+	debugfs_remove(efx_debug_root);
+	efx_debug_root = NULL;
+}
Index: head-2008-06-18/drivers/net/sfc/debugfs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/debugfs.h	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,172 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#ifndef EFX_DEBUGFS_H
+#define EFX_DEBUGFS_H
+
+#ifdef CONFIG_SFC_DEBUGFS
+
+struct seq_file;
+
+struct efx_debugfs_parameter {
+	const char *name;
+	size_t offset;
+	int (*reader)(struct seq_file *, void *);
+};
+
+extern void efx_fini_debugfs_child(struct dentry *dir, const char *name);
+extern int efx_init_debugfs_netdev(struct net_device *net_dev);
+extern void efx_fini_debugfs_netdev(struct net_device *net_dev);
+extern int efx_init_debugfs_port(struct efx_nic *efx);
+extern void efx_fini_debugfs_port(struct efx_nic *efx);
+extern int efx_init_debugfs_nic(struct efx_nic *efx);
+extern void efx_fini_debugfs_nic(struct efx_nic *efx);
+extern int efx_init_debugfs_channels(struct efx_nic *efx);
+extern void efx_fini_debugfs_channels(struct efx_nic *efx);
+extern int efx_init_debugfs(void);
+extern void efx_fini_debugfs(void);
+extern int efx_extend_debugfs_port(struct efx_nic *efx,
+				   void *context,
+				   struct efx_debugfs_parameter *params);
+extern void efx_trim_debugfs_port(struct efx_nic *efx,
+				  struct efx_debugfs_parameter *params);
+
+/* Helpers for handling debugfs entry reads */
+extern int efx_debugfs_read_uint(struct seq_file *, void *);
+extern int efx_debugfs_read_string(struct seq_file *, void *);
+extern int efx_debugfs_read_int(struct seq_file *, void *);
+extern int efx_debugfs_read_atomic(struct seq_file *, void *);
+extern int efx_debugfs_read_dword(struct seq_file *, void *);
+
+/* Handy macros for filling out parameters */
+
+/* Initialiser for a struct efx_debugfs_parameter with type-checking */
+#define EFX_PARAMETER(container_type, parameter, field_type,		\
+			reader_function) {				\
+	.name = #parameter,						\
+	.offset = ((((field_type *) 0) ==				\
+		    &((container_type *) 0)->parameter) ?		\
+		   offsetof(container_type, parameter) :		\
+		   offsetof(container_type, parameter)),		\
+	.reader = reader_function,					\
+}
+
+/* Likewise, but the file name is not taken from the field name */
+#define EFX_NAMED_PARAMETER(_name, container_type, parameter, field_type, \
+				reader_function) {			\
+	.name = #_name,							\
+	.offset = ((((field_type *) 0) ==				\
+		    &((container_type *) 0)->parameter) ?		\
+		   offsetof(container_type, parameter) :		\
+		   offsetof(container_type, parameter)),		\
+	.reader = reader_function,					\
+}
+
+/* Likewise, but with one file for each of 4 lanes */
+#define EFX_PER_LANE_PARAMETER(prefix, suffix, container_type, parameter, \
+				field_type, reader_function) {		\
+	.name = prefix "0" suffix,					\
+	.offset = ((((field_type *) 0) ==				\
+		      ((container_type *) 0)->parameter) ?		\
+		    offsetof(container_type, parameter[0]) :		\
+		    offsetof(container_type, parameter[0])),		\
+	.reader = reader_function,					\
+},  {									\
+	.name = prefix "1" suffix,					\
+	.offset = offsetof(container_type, parameter[1]),		\
+	.reader = reader_function,					\
+}, {									\
+	.name = prefix "2" suffix,					\
+	.offset = offsetof(container_type, parameter[2]),		\
+	.reader = reader_function,					\
+}, {									\
+	.name = prefix "3" suffix,					\
+	.offset = offsetof(container_type, parameter[3]),		\
+	.reader = reader_function,					\
+}
+
+/* A string parameter (string embedded in the structure) */
+#define EFX_STRING_PARAMETER(container_type, parameter) {	\
+	.name = #parameter,					\
+	.offset = ((((char *) 0) ==				\
+		    ((container_type *) 0)->parameter) ?	\
+		   offsetof(container_type, parameter) :	\
+		   offsetof(container_type, parameter)),	\
+	.reader = efx_debugfs_read_string,			\
+}
+
+/* An unsigned integer parameter */
+#define EFX_UINT_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      unsigned int, efx_debugfs_read_uint)
+
+/* A dword parameter */
+#define EFX_DWORD_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      efx_dword_t, efx_debugfs_read_dword)
+
+/* An atomic_t parameter */
+#define EFX_ATOMIC_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      atomic_t, efx_debugfs_read_atomic)
+
+/* An integer parameter */
+#define EFX_INT_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      int, efx_debugfs_read_int)
+
+#else /* !CONFIG_SFC_DEBUGFS */
+
+static inline int efx_init_debugfs_netdev(struct net_device *net_dev)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_netdev(struct net_device *net_dev) {}
+static inline int efx_init_debugfs_port(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_port(struct efx_nic *efx) {}
+static inline int efx_init_debugfs_nic(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_nic(struct efx_nic *efx) {}
+static inline int efx_init_debugfs_channels(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_channels(struct efx_nic *efx) {}
+static inline int efx_init_debugfs(void)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs(void) {}
+
+#endif /* CONFIG_SFC_DEBUGFS */
+
+#endif /* EFX_DEBUGFS_H */
Index: head-2008-06-18/drivers/net/sfc/driverlink.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/driverlink.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,531 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005:      Fen Systems Ltd.
+ * Copyright 2005-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "driverlink.h"
+
+/* Driverlink semaphore
+ * This semaphore must be held for any operation that modifies any of
+ * the driverlink lists.
+ */
+static DEFINE_MUTEX(efx_driverlink_lock);
+
+/* List of all registered drivers */
+static LIST_HEAD(efx_driver_list);
+
+/* List of all registered Efx ports */
+static LIST_HEAD(efx_port_list);
+
+/* Driver link handle used internally to track devices */
+struct efx_dl_handle {
+	/* The efx_dl_device consumers see */
+	struct efx_dl_device efx_dev;
+	/* The efx_nic providers provide */
+	struct efx_nic *efx;
+	/* Per-device list */
+	struct list_head port_node;
+	/* Per-driver list */
+	struct list_head driver_node;
+};
+
+/* Get the handle for an efx_dl_device */
+static struct efx_dl_handle *efx_dl_handle(struct efx_dl_device *efx_dev)
+{
+	return container_of(efx_dev, struct efx_dl_handle, efx_dev);
+}
+
+/* Remove an Efx device
+ * You must hold the efx_driverlink_lock before calling this
+ * function.
+ */
+static void efx_dl_del_device(struct efx_dl_device *efx_dev)
+{
+	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
+
+	EFX_INFO(efx_handle->efx, "%s driverlink client unregistering\n",
+		 efx_dev->driver->name);
+
+	/* Call driver's remove() routine */
+	if (efx_dev->driver->remove)
+		efx_dev->driver->remove(efx_dev);
+
+	/* Remove handle from per-driver and per-NIC lists */
+	list_del(&efx_handle->driver_node);
+	list_del(&efx_handle->port_node);
+
+	/* Free efx_handle structure */
+	kfree(efx_handle);
+}
+
+/* Try to add an Efx device
+ * Attempt to probe the given device with the driver, creating a
+ * new efx_dl_device. If the probe routine fails, because the driver
+ * doesn't support this port, then the efx_dl_device is destroyed,
+ */
+static void efx_dl_try_add_device(struct efx_nic *efx,
+				  struct efx_dl_driver *driver)
+{
+	struct efx_dl_handle *efx_handle;
+	struct efx_dl_device *efx_dev;
+	int rc;
+
+	/* Allocate and initialise new efx_dl_device structure */
+	efx_handle = kzalloc(sizeof(*efx_handle), GFP_KERNEL);
+	efx_dev = &efx_handle->efx_dev;
+	efx_handle->efx = efx;
+	efx_dev->driver = driver;
+	efx_dev->pci_dev = efx->pci_dev;
+	INIT_LIST_HEAD(&efx_handle->port_node);
+	INIT_LIST_HEAD(&efx_handle->driver_node);
+
+	/* Attempt driver probe */
+	rc = driver->probe(efx_dev, efx->net_dev,
+			   efx->dl_info, efx->silicon_rev);
+	if (rc)
+		goto fail;
+
+	/* Add device to per-driver and per-NIC lists */
+	list_add_tail(&efx_handle->driver_node, &driver->device_list);
+	list_add_tail(&efx_handle->port_node, &efx->dl_device_list);
+
+	EFX_INFO(efx, "%s driverlink client registered\n", driver->name);
+	return;
+
+ fail:
+	EFX_INFO(efx, "%s driverlink client skipped\n", driver->name);
+
+	kfree(efx_dev);
+}
+
+/**
+ * efx_dl_unregister_driver - unregister an Efx device driver
+ * @driver:		Efx driverlink driver
+ *
+ * Unregisters an Efx driver.  The driver's remove() method will be
+ * called for all Efx devices currently claimed by the driver.
+ */
+void efx_dl_unregister_driver(struct efx_dl_driver *driver)
+{
+	struct efx_dl_handle *efx_handle, *efx_handle_n;
+
+	printk(KERN_INFO "Efx driverlink unregistering %s driver\n",
+		 driver->name);
+
+	/* Acquire lock.  We can't return failure */
+	mutex_lock(&efx_driverlink_lock);
+
+	list_for_each_entry_safe(efx_handle, efx_handle_n,
+				 &driver->device_list, driver_node)
+		efx_dl_del_device(&efx_handle->efx_dev);
+
+	list_del(&driver->node);
+
+	mutex_unlock(&efx_driverlink_lock);
+}
+EXPORT_SYMBOL(efx_dl_unregister_driver);
+
+/**
+ * efx_dl_register_driver - register an Efx device driver
+ * @driver:		Efx driverlink driver
+ *
+ * Registers a new Efx driver.  The driver's probe() method will be
+ * called for all Efx NICs currently registered.
+ *
+ * Return a negative error code or 0 on success.
+ */
+int efx_dl_register_driver(struct efx_dl_driver *driver)
+{
+	struct efx_nic *efx;
+	int rc;
+
+	printk(KERN_INFO "Efx driverlink registering %s driver\n",
+		 driver->name);
+
+	/* Initialise driver list structures */
+	INIT_LIST_HEAD(&driver->node);
+	INIT_LIST_HEAD(&driver->device_list);
+
+	/* Acquire lock */
+	rc = mutex_lock_interruptible(&efx_driverlink_lock);
+	if (rc)
+		return rc;
+
+	/* Add driver to driver list */
+	list_add_tail(&driver->node, &efx_driver_list);
+
+	/* Feed all existing devices to driver */
+	list_for_each_entry(efx, &efx_port_list, dl_node)
+		efx_dl_try_add_device(efx, driver);
+
+	/* Release locks */
+	mutex_unlock(&efx_driverlink_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(efx_dl_register_driver);
+
+void efx_dl_unregister_nic(struct efx_nic *efx)
+{
+	struct efx_dl_handle *efx_handle, *efx_handle_n;
+
+	if (!efx)
+		return;
+
+	/* Acquire lock.  We can't return failure, so have to use
+	 * down() instead of down_interruptible()
+	 */
+	mutex_lock(&efx_driverlink_lock);
+
+	/* Remove all devices related to this NIC */
+	list_for_each_entry_safe_reverse(efx_handle, efx_handle_n,
+					 &efx->dl_device_list,
+					 port_node)
+		efx_dl_del_device(&efx_handle->efx_dev);
+
+	/* Remove port from port list */
+	list_del(&efx->dl_node);
+
+	/* Release lock */
+	mutex_unlock(&efx_driverlink_lock);
+}
+
+int efx_dl_register_nic(struct efx_nic *efx)
+{
+	struct efx_dl_driver *driver;
+	int rc;
+
+	/* Acquire lock */
+	rc = mutex_lock_interruptible(&efx_driverlink_lock);
+	if (rc)
+		return rc;
+
+	/* Add port to port list */
+	list_add_tail(&efx->dl_node, &efx_port_list);
+
+	/* Feed port to all existing drivers */
+	list_for_each_entry(driver, &efx_driver_list, node)
+		efx_dl_try_add_device(efx, driver);
+
+	/* Release lock */
+	mutex_unlock(&efx_driverlink_lock);
+
+	return 0;
+}
+
+/*
+ * Dummy callback implementations.
+ *
+ * To avoid a branch point on the fast-path, the callbacks are always
+ * implemented - they are never NULL.
+ */
+static enum efx_veto
+efx_dummy_tx_packet_callback(struct efx_dl_device *efx_dev, struct sk_buff *skb)
+{
+	/* Never veto the packet */
+	return EFX_ALLOW_PACKET;
+}
+
+static enum efx_veto
+efx_dummy_rx_packet_callback(struct efx_dl_device *efx_dev,
+			     const char *pkt_buf, int len)
+{
+	/* Never veto the packet */
+	return EFX_ALLOW_PACKET;
+}
+
+static void
+efx_dummy_link_change_callback(struct efx_dl_device *efx_dev, int link_up)
+{
+}
+
+static int
+efx_dummy_request_mtu_callback(struct efx_dl_device *efx_dev, int new_mtu)
+{
+	/* Always allow */
+	return 0;
+}
+
+static void
+efx_dummy_mtu_changed_callback(struct efx_dl_device *efx_dev, int mtu)
+{
+	return;
+}
+
+static void efx_dummy_event_callback(struct efx_dl_device *efx_dev, void *event)
+{
+	return;
+}
+
+struct efx_dl_callbacks efx_default_callbacks = {
+	.tx_packet	= efx_dummy_tx_packet_callback,
+	.rx_packet	= efx_dummy_rx_packet_callback,
+	.link_change	= efx_dummy_link_change_callback,
+	.request_mtu	= efx_dummy_request_mtu_callback,
+	.mtu_changed	= efx_dummy_mtu_changed_callback,
+	.event		= efx_dummy_event_callback,
+};
+
+#define EFX_DL_UNREGISTER_CALLBACK(_port, _dev, _member)		\
+	do {								\
+		BUG_ON((_port)->dl_cb_dev._member != (_dev));		\
+		(_port)->dl_cb._member =				\
+			efx_default_callbacks._member;			\
+		(_port)->dl_cb_dev._member = NULL;			\
+	} while (0)
+
+
+#define EFX_DL_REGISTER_CALLBACK(_port, _dev, _from, _member)		\
+	if ((_from)->_member) {						\
+		BUG_ON((_port)->dl_cb_dev._member != NULL);		\
+		(_port)->dl_cb._member = (_from)->_member;		\
+		(_port)->dl_cb_dev._member = _dev;			\
+	}
+
+/**
+ * efx_dl_unregister_callbacks - unregister callbacks for an Efx NIC
+ * @efx_dev:		Efx driverlink device
+ * @callbacks:		Callback list
+ *
+ * This removes a set of callbacks registered with
+ * efx_dl_register_callbacks().  It should be called as part of the
+ * client's remove() method.
+ *
+ * The net driver will ensure that all callback functions have
+ * returned to the net driver before efx_dl_unregister_callbacks()
+ * returns.  Note that the device itself may still be running when the
+ * client's remove() method is called.  The client must therefore
+ * unhook its callbacks using efx_dl_unregister_callbacks() and only
+ * then ensure that any delayed tasks triggered by callback methods
+ * (e.g. scheduled tasklets) have completed.
+ */
+void efx_dl_unregister_callbacks(struct efx_dl_device *efx_dev,
+				 struct efx_dl_callbacks *callbacks)
+{
+	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
+	struct efx_nic *efx = efx_handle->efx;
+
+	/* Suspend net driver operations */
+	efx_suspend(efx);
+
+	EFX_INFO(efx, "removing callback hooks into %s driver\n",
+		 efx_dev->driver->name);
+
+	if (callbacks->tx_packet)
+		EFX_DL_UNREGISTER_CALLBACK(efx, efx_dev, tx_packet);
+
+	if (callbacks->rx_packet)
+		EFX_DL_UNREGISTER_CALLBACK(efx, efx_dev, rx_packet);
+
+	if (callbacks->link_change)
+		EFX_DL_UNREGISTER_CALLBACK(efx, efx_dev, link_change);
+
+	if (callbacks->request_mtu)
+		EFX_DL_UNREGISTER_CALLBACK(efx, efx_dev, request_mtu);
+
+	if (callbacks->mtu_changed)
+		EFX_DL_UNREGISTER_CALLBACK(efx, efx_dev, mtu_changed);
+
+	if (callbacks->event)
+		EFX_DL_UNREGISTER_CALLBACK(efx, efx_dev, event);
+
+	/* Resume net driver operations */
+	efx_resume(efx);
+}
+EXPORT_SYMBOL(efx_dl_unregister_callbacks);
+
+/**
+ * efx_dl_register_callbacks - register callbacks for an Efx NIC
+ * @efx_dev:		Efx driverlink device
+ * @callbacks:		Callback list
+ *
+ * This registers a set of callback functions with the net driver.
+ * These functions will be called at various key points to allow
+ * external code to monitor and/or modify the behaviour of the network
+ * driver.  Any of the callback function pointers may be %NULL if a
+ * callback is not required.  The intended user of this mechanism is
+ * the SFC char driver.
+ *
+ * This client should call efx_dl_register_callbacks() during its
+ * probe() method.  The client must ensure that it also calls
+ * efx_dl_unregister_callbacks() as part of its remove() method.
+ *
+ * Only one function may be registered for each callback per NIC.
+ * If a requested callback is already registered for this NIC, this
+ * function will return -%EBUSY.
+ *
+ * The device may already be running, so the client must be prepared
+ * for callbacks to be triggered immediately after calling
+ * efx_dl_register_callbacks().
+ *
+ * Return a negative error code or 0 on success.
+ */
+int efx_dl_register_callbacks(struct efx_dl_device *efx_dev,
+			      struct efx_dl_callbacks *callbacks)
+{
+	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
+	struct efx_nic *efx = efx_handle->efx;
+	int rc = 0;
+
+	/* Suspend net driver operations */
+	efx_suspend(efx);
+
+	/* Check that the requested callbacks are not already hooked. */
+	if ((callbacks->tx_packet && efx->dl_cb_dev.tx_packet) ||
+	    (callbacks->rx_packet && efx->dl_cb_dev.rx_packet) ||
+	    (callbacks->link_change && efx->dl_cb_dev.link_change) ||
+	    (callbacks->request_mtu && efx->dl_cb_dev.request_mtu) ||
+	    (callbacks->mtu_changed && efx->dl_cb_dev.mtu_changed) ||
+	    (callbacks->event && efx->dl_cb_dev.event)) {
+		rc = -EBUSY;
+		goto out;
+	}
+
+	EFX_INFO(efx, "adding callback hooks to %s driver\n",
+		 efx_dev->driver->name);
+
+	/* Hook in callbacks.  For maximum speed, we never check to
+	 * see whether these are NULL before calling; therefore we
+	 * must ensure that they are never NULL.  If the set we're
+	 * being asked to hook in is sparse, we leave the default
+	 * values in place for the empty hooks.
+	 */
+	EFX_DL_REGISTER_CALLBACK(efx, efx_dev, callbacks, tx_packet);
+	EFX_DL_REGISTER_CALLBACK(efx, efx_dev, callbacks, rx_packet);
+	EFX_DL_REGISTER_CALLBACK(efx, efx_dev, callbacks, link_change);
+	EFX_DL_REGISTER_CALLBACK(efx, efx_dev, callbacks, request_mtu);
+	EFX_DL_REGISTER_CALLBACK(efx, efx_dev, callbacks, mtu_changed);
+	EFX_DL_REGISTER_CALLBACK(efx, efx_dev, callbacks, event);
+
+ out:
+	/* Resume net driver operations */
+	efx_resume(efx);
+
+	return rc;
+}
+EXPORT_SYMBOL(efx_dl_register_callbacks);
+
+/**
+ * efx_dl_schedule_reset - schedule an Efx NIC reset
+ * @efx_dev:		Efx driverlink device
+ *
+ * This schedules a hardware reset for a short time in the future.  It
+ * can be called from any context, and so can be used when
+ * efx_dl_reset() cannot be called.
+ */
+void efx_dl_schedule_reset(struct efx_dl_device *efx_dev)
+{
+	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
+	struct efx_nic *efx = efx_handle->efx;
+
+	efx_schedule_reset(efx, RESET_TYPE_ALL);
+}
+EXPORT_SYMBOL(efx_dl_schedule_reset);
+
+/*
+ * Lock the driverlink layer before a reset
+ * To avoid deadlock, efx_driverlink_lock needs to be acquired before
+ * efx->suspend_lock.
+ */
+void efx_dl_reset_lock(void)
+{
+	/* Acquire lock */
+	mutex_lock(&efx_driverlink_lock);
+}
+
+/*
+ * Unlock the driverlink layer after a reset
+ * This call must be matched against efx_dl_reset_lock.
+ */
+void efx_dl_reset_unlock(void)
+{
+	/* Acquire lock */
+	mutex_unlock(&efx_driverlink_lock);
+}
+
+/*
+ * Suspend ready for reset
+ * This calls the reset_suspend method of all drivers registered to
+ * the specified NIC.  It must only be called between
+ * efx_dl_reset_lock and efx_dl_reset_unlock.
+ */
+void efx_dl_reset_suspend(struct efx_nic *efx)
+{
+	struct efx_dl_handle *efx_handle;
+	struct efx_dl_device *efx_dev;
+
+	BUG_ON(!mutex_is_locked(&efx_driverlink_lock));
+
+	/* Call suspend method of each driver in turn */
+	list_for_each_entry_reverse(efx_handle,
+				    &efx->dl_device_list,
+				    port_node) {
+		efx_dev = &efx_handle->efx_dev;
+		if (efx_dev->driver->reset_suspend)
+			efx_dev->driver->reset_suspend(efx_dev);
+	}
+}
+
+/*
+ * Resume after a reset
+ * This calls the reset_resume method of all drivers registered to the
+ * specified NIC.  It must only be called between efx_dl_reset_lock
+ * and efx_dl_reset_unlock.
+ */
+void efx_dl_reset_resume(struct efx_nic *efx, int ok)
+{
+	struct efx_dl_handle *efx_handle;
+	struct efx_dl_device *efx_dev;
+
+	BUG_ON(!mutex_is_locked(&efx_driverlink_lock));
+
+	/* Call resume method of each driver in turn */
+	list_for_each_entry(efx_handle, &efx->dl_device_list,
+			    port_node) {
+		efx_dev = &efx_handle->efx_dev;
+		if (efx_dev->driver->reset_resume)
+			efx_dev->driver->reset_resume(efx_dev, ok);
+	}
+}
+
+/**
+ * efx_dl_get_nic - obtain the Efx NIC for the given driverlink device
+ * @efx_dev:		Efx driverlink device
+ *
+ * Get a pointer to the &struct efx_nic corresponding to
+ * @efx_dev.  This can be used by driverlink clients built along with
+ * the sfc driver, which may have intimate knowledge of its internals.
+ */
+struct efx_nic *efx_dl_get_nic(struct efx_dl_device *efx_dev)
+{
+	return efx_dl_handle(efx_dev)->efx;
+}
+EXPORT_SYMBOL(efx_dl_get_nic);
Index: head-2008-06-18/drivers/net/sfc/driverlink.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/driverlink.h	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,93 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005:      Fen Systems Ltd.
+ * Copyright 2006:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#ifndef EFX_DRIVERLINK_H
+#define EFX_DRIVERLINK_H
+
+/* Forward declarations */
+struct efx_dl_device;
+struct efx_nic;
+
+/*
+ * Efx driverlink
+ *
+ * This header file defines the portions of the Efx driverlink
+ * interface that are used only within the sfc module.  It also
+ * declares efx_dl_get_nic(), which may be used by sfc_mtd
+ * and any other module built along with sfc.
+ */
+
+
+/* Efx callback devices
+ *
+ * A list of the devices that own each callback. The partner to
+ * struct efx_dl_callbacks
+ */
+struct efx_dl_cb_devices {
+	/* Device owning the tx_packet callback */
+	struct efx_dl_device *tx_packet;
+	/* Device owning the rx_packet callback */
+	struct efx_dl_device *rx_packet;
+	/* Device owning the link_change callback. */
+	struct efx_dl_device *link_change;
+	/* Device owning the request_mtu callback. */
+	struct efx_dl_device *request_mtu;
+	/* Device owning the mtu_changed callback. */
+	struct efx_dl_device *mtu_changed;
+	/* Device owning the event callback. */
+	struct efx_dl_device *event;
+};
+
+/* No-op callbacks used for initialisation */
+extern struct efx_dl_callbacks efx_default_callbacks;
+
+/* Macro used to invoke callbacks */
+#define EFX_DL_CALLBACK(_port, _name, ...)				\
+	(_port)->dl_cb._name((_port)->dl_cb_dev._name, __VA_ARGS__)
+
+/* Register an Efx NIC */
+extern int efx_dl_register_nic(struct efx_nic *efx);
+
+/* Unregister an Efx NIC */
+extern void efx_dl_unregister_nic(struct efx_nic *efx);
+
+/* Lock the driverlink layer prior to a reset */
+extern void efx_dl_reset_lock(void);
+
+/* Unlock the driverlink layer following a reset */
+extern void efx_dl_reset_unlock(void);
+
+/* Suspend all drivers prior to a hardware reset */
+extern void efx_dl_reset_suspend(struct efx_nic *efx);
+
+/* Resume all drivers after a hardware reset */
+extern void efx_dl_reset_resume(struct efx_nic *efx, int ok);
+
+/* Obtain the Efx NIC for the given driverlink device. */
+extern struct efx_nic *efx_dl_get_nic(struct efx_dl_device *efx_dev);
+
+#endif /* EFX_DRIVERLINK_H */
Index: head-2008-06-18/drivers/net/sfc/driverlink_api.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/driverlink_api.h	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,595 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2005-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#ifndef EFX_DRIVERLINK_API_H
+#define EFX_DRIVERLINK_API_H
+
+#include <linux/list.h> /* for struct list_head */
+
+/**
+ * DOC: Efx driverlink API
+ *
+ * This file must be included by any driver that wishes to attach to
+ * devices claimed by the Solarflare NIC driver (sfc). It allows separate
+ * kernel modules to expose other functionality offered by the NIC, with
+ * the sfc driver remaining in overall control.
+ *
+ * Overview:
+ *
+ * Driverlink clients define a &struct efx_dl_driver, and register
+ * this structure with the driverlink layer using
+ * efx_dl_register_driver(), which is exported by the sfc driver.
+ *
+ * The probe() routine of each driverlink client driver is called by
+ * the driverlink layer for each physical port in the system, after
+ * the sfc driver has performed start-of-day hardware initialisation
+ * and self-test. If ports are added or removed via pci hotplug then
+ * the &struct efx_dl_driver probe() or remove() routines are called
+ * as appropriate.
+ *
+ * If the port doesn't provide the necessary hardware resources for a
+ * client, then that client can return failure from its probe()
+ * routine. Information provided to the client driver at probe time
+ * includes
+ *
+ * Each probe() routine is given a unique &struct efx_dl_device per
+ * port, which means it can safely use the @priv member to store any
+ * useful state it needs. The probe routine also has the opportunity
+ * to provide a &struct efx_dl_callbacks via
+ * efx_dl_register_callbacks(), which allows the client to intercept
+ * the sfc driver's operations at strategic points.
+ *
+ * Occasionally, the underlying Efx device may need to be reset to
+ * recover from an error condition.  The client's reset_suspend() and
+ * reset_resume() methods [if provided] will be called to enable the
+ * client to suspend operations and preserve any state before the
+ * reset.  The client can itself request a reset using efx_dl_reset()
+ * or efx_dl_schedule_reset(), should it detect an error condition
+ * necessitating a reset.
+ *
+ * Example:
+ *
+ * The MTD driver (mtd.c) uses the driverlink layer.
+ */
+
+/* Forward declarations */
+struct pci_dev;
+struct net_device;
+struct sk_buff;
+struct efx_dl_device;
+struct efx_dl_device_info;
+
+/*
+ * This is used to guard against the registration of driverlink
+ * clients using an incorrect version of the API.
+ */
+#define EFX_DRIVERLINK_API_VERSION 1
+
+
+/**
+ * struct efx_dl_driver - An Efx driverlink device driver
+ *
+ * This is the analogue of a struct pci_driver for a normal PCI
+ * driver.  Driverlink clients should register themselves using
+ * efx_dl_register_driver() at module initialisation, and deregister
+ * themselves using efx_dl_unregister_driver() at module exit.
+ *
+ * All calls to members of efx_dl_driver are serialised by a single
+ * semaphore, so you are allowed to sleep in these functions. Take care
+ * to not call driverlink methods from within these callbacks, otherwise
+ * a deadlock is possible.
+ *
+ * @name: Name of the driver
+ * @probe: Called when device added
+ * @remove: Called when device removed
+ * @reset_suspend: Called before device is reset
+ * @reset_resume: Called after device is reset
+ */
+struct efx_dl_driver {
+	const char *name;
+
+	/*
+	 * probe - Handle device addition.
+	 * @efx_dev:		Efx driverlink device
+	 * @net_dev:		The net_dev relevant to this port
+	 * @dev_info:		A linked list of device information.
+	 * @silicon_rev:	Silicon revision name.
+	 *
+	 * This will be called after driverlink client registration for
+	 * every port on the system, and for every port that appears
+	 * thereafter via hotplug.
+	 *
+	 * The client may use either @efx_dev->pci_dev, the dev_info linked
+	 * list of available driver information, or the silicon revision
+	 * name to determine if they can support this port. If they can,
+	 * they should return 0 to indicate the probe was successful. Any
+	 * other return code indicates that the probe failed, and the
+	 * @efx_dl_dev will be invalidated.
+	 *
+	 * The client should perform whatever initialisation it
+	 * requires, and store a pointer to its private data in
+	 * @efx_dl_dev->priv (which is not shared between clients).
+	 * It may also wish to hook in a callbacks table using
+	 * efx_dl_register_callbacks().
+	 *
+	 * Return a negative error code or 0 on success.
+	 */
+	int (*probe) (struct efx_dl_device *efx_dl_dev,
+		      const struct net_device *net_dev,
+		      const struct efx_dl_device_info *dev_info,
+		      const char *silicon_rev);
+
+	/*
+	 * remove - Handle device removal.
+	 * @efx_dev:		Efx driverlink device
+	 *
+	 * This will be called at driver exit (or hotplug removal) for
+	 * each registered driverlink client.
+	 *
+	 * The client must ensure that it has finished all operations
+	 * using this device before returning from this method.  If it
+	 * has hooked in a callbacks table using
+	 * efx_dl_register_callbacks(), it must unhook it using
+	 * efx_dl_unregister_callbacks(), and then ensure that all
+	 * callback-triggered operations (e.g. scheduled tasklets)
+	 * have completed before returning.  (It does not need to
+	 * explicitly wait for callback methods to finish executing,
+	 * since efx_dl_unregister_callbacks() will sleep until all
+	 * callbacks have returned anyway.)
+	 *
+	 * Note that the device itself may not have been removed; it
+	 * may be simply that the client is being unloaded
+	 * via efx_dl_unregister_driver(). In this case other clients
+	 * (and the sfc driver itself) will still be using the device,
+	 * so the client cannot assume that the device itself is quiescent.
+	 * In particular, callbacks may continue to be triggered at any
+	 * point until efx_dl_unregister_callbacks() is called.
+	 */
+	void (*remove) (struct efx_dl_device *efx_dev);
+
+	/*
+	 * reset_suspend - Suspend ready for reset.
+	 * @efx_dev:		Efx driverlink device
+	 *
+	 * This method will be called immediately before a hardware
+	 * reset (which may or may not have been initiated by the
+	 * driverlink client).  This client must save any state that it
+	 * will need to restore after the reset, and suspend all
+	 * operations that might access the hardware.  It must not
+	 * return until the client can guarantee to have stopped
+	 * touching the hardware.
+	 *
+	 * It is guaranteed that callbacks will be inactive by the
+	 * time this method is called; the driverlink layer will
+	 * already have prevented new callbacks being made and waited
+	 * for all callbacks functions to return before calling
+	 * reset_suspend().  However, any delayed work scheduled by
+	 * the callback functions (e.g. tasklets) may not yet have
+	 * completed.
+	 *
+	 * This method is allowed to sleep, so waiting on tasklets,
+	 * work queues etc. is permitted.  There will always be a
+	 * corresponding call to the reset_resume() method, so it is
+	 * safe to e.g. down a semaphore within reset_suspend() and up
+	 * it within reset_resume().  (However, you obviously cannot
+	 * do the same with a spinlock).
+	 *
+	 * Note that the reset operation may be being carried out in
+	 * the context of scheduled work, so you cannot use
+	 * flush_scheduled_work() to ensure that any work you may have
+	 * scheduled has completed.
+	 *
+	 * During hardware reset, there is a chance of receiving
+	 * spurious interrupts, so the client's ISR (if any) should be
+	 * unhooked or otherwise disabled.
+	 */
+	void (*reset_suspend) (struct efx_dl_device *efx_dev);
+
+	/*
+	 * reset_resume - Restore after a reset.
+	 * @efx_dev:		Efx driverlink device
+	 * @ok:			Reset success indicator
+	 *
+	 * This method will be called after a hardware reset.  There
+	 * will always have been a corresponding call to the
+	 * reset_suspend() method beforehand.
+	 *
+	 * If @ok is non-zero, the client should restore the state
+	 * that it saved during the call to reset_suspend() and resume
+	 * normal operations.
+	 *
+	 * If @ok is zero, the reset operation has failed and the
+	 * hardware is currently in an unusable state.  In this case,
+	 * the client should release any locks taken out by
+	 * reset_suspend(), but should not take any other action; in
+	 * particular, it must not access the hardware, nor resume
+	 * normal operations.  The hardware is effectively dead at
+	 * this point, and our sole aim is to avoid deadlocking or
+	 * crashing the host.
+	 *
+	 * The driverlink layer will still be locked when
+	 * reset_resume() is called, so the client may not call
+	 * driverlink functions.  In particular, if the reset failed,
+	 * the client must not call efx_dl_unregister_callbacks() at
+	 * this point; it should wait until remove() is called.
+	 */
+	void (*reset_resume) (struct efx_dl_device *efx_dev, int ok);
+
+/* private: */
+	struct list_head node;
+	struct list_head device_list;
+};
+
+/**
+ * DOC: Efx driverlink device information
+ *
+ * Each &struct efx_dl_device makes certain hardware resources visible
+ * to driverlink clients, and they describe which resources are
+ * available by passing a linked list of &struct efx_dl_device_info
+ * into the probe() routine.
+ *
+ * The driverlink client's probe function can iterate through the linked list,
+ * and provided that it understands the resources that are exported, it can
+ * choose to make use of them through an external interface.
+ */
+
+/**
+ * enum efx_dl_device_info_type - Device information identifier.
+ *
+ * Each distinct hardware resource API will have a member in this
+ * enumeration.
+ *
+ * @EFX_DL_FALCON_RESOURCES: Information type is &struct efx_dl_falcon_resources
+ */
+enum efx_dl_device_info_type {
+	/** Falcon resources available for export */
+	EFX_DL_FALCON_RESOURCES = 0,
+};
+
+/**
+ * struct efx_dl_device_info - device information structure
+ * @next: Link to next structure, if any
+ * @type: Type code for this structure
+ *
+ * This structure is embedded in other structures provided by the
+ * driverlink device provider, and implements a linked list of
+ * resources pertinent to a driverlink client.
+ *
+ * Example: &struct efx_dl_falcon_resources
+ */
+struct efx_dl_device_info {
+	struct efx_dl_device_info *next;
+	enum efx_dl_device_info_type type;
+};
+
+/**
+ * enum efx_dl_falcon_resource_flags - Falcon resource information flags.
+ *
+ * Flags that describe hardware variations for the described Falcon based port.
+ *
+ * @EFX_DL_FALCON_DUAL_FUNC: Port is dual-function.
+ *	Certain silicon revisions have two pci functions, and require
+ *	certain hardware resources to be accessed via the secondary
+ *	function. See the discussion of @pci_dev in &struct efx_dl_device
+ *	below.
+ * @EFX_DL_FALCON_USE_MSI: Port is initialised to use MSI/MSI-X interrupts.
+ *	Falcon supports traditional legacy interrupts and MSI/MSI-X
+ *	interrupts. Since the sfc driver supports either, as a run
+ *	time configuration, driverlink drivers need to be aware of which
+ *	one to use for their interrupting resources.
+ */
+enum efx_dl_falcon_resource_flags {
+	EFX_DL_FALCON_DUAL_FUNC = 0x1,
+	EFX_DL_FALCON_USE_MSI = 0x2,
+};
+
+/**
+ * struct efx_dl_falcon_resources - Falcon resource information.
+ *
+ * This structure describes Falcon hardware resources available for
+ * use by a driverlink driver.
+ *
+ * @hdr: Resource linked list header
+ * @biu_lock: Register access lock.
+ *	Some Falcon revisions require register access for configuration
+ *	registers to be serialised between ports and PCI functions.
+ *	The sfc driver will provide the appropriate lock semantics for
+ *	the underlying hardware.
+ * @buffer_table_min: First available buffer table entry
+ * @buffer_table_lim: Last available buffer table entry + 1
+ * @evq_timer_min: First available event queue with timer
+ * @evq_timer_lim: Last available event queue with timer + 1
+ * @evq_int_min: First available event queue with interrupt
+ * @evq_int_lim: Last available event queue with interrupt + 1
+ * @rxq_min: First available RX queue
+ * @rxq_lim: Last available RX queue + 1
+ * @txq_min: First available TX queue
+ * @txq_lim: Last available TX queue + 1
+ * @flags: Hardware variation flags
+ */
+struct efx_dl_falcon_resources {
+	struct efx_dl_device_info hdr;
+	spinlock_t *biu_lock;
+	unsigned buffer_table_min, buffer_table_lim;
+	unsigned evq_timer_min, evq_timer_lim;
+	unsigned evq_int_min, evq_int_lim;
+	unsigned rxq_min, rxq_lim;
+	unsigned txq_min, txq_lim;
+	enum efx_dl_falcon_resource_flags flags;
+};
+
+/**
+ * struct efx_dl_device - An Efx driverlink device.
+ *
+ * @pci_dev: Underlying PCI device.
+ *	This is the PCI device used by the sfc driver.  It will
+ *	already have been enabled for bus-mastering DMA etc.
+ * @priv: Driver private data
+ *	Driverlink clients can use this to store a pointer to their
+ *	internal per-device data structure. Each (driver, device)
+ *	tuple has a separate &struct efx_dl_device, so clients can use
+ *	this @priv field independently.
+ * @driver: Efx driverlink driver for this device
+ */
+struct efx_dl_device {
+	struct pci_dev *pci_dev;
+	void *priv;
+	struct efx_dl_driver *driver;
+};
+
+/**
+ * enum efx_veto - Packet veto request flag.
+ *
+ * This is the return type for the rx_packet() and tx_packet() methods
+ * in &struct efx_dl_callbacks.
+ *
+ * @EFX_ALLOW_PACKET: Packet may be transmitted/received
+ * @EFX_VETO_PACKET: Packet must not be transmitted/received
+ */
+enum efx_veto {
+	EFX_ALLOW_PACKET = 0,
+	EFX_VETO_PACKET = 1,
+};
+
+/**
+ * struct efx_dl_callbacks - Efx callbacks
+ *
+ * These methods can be hooked in to the sfc driver via
+ * efx_dl_register_callbacks().  They allow clients to intercept and/or
+ * modify the behaviour of the sfc driver at predetermined points.
+ *
+ * For efficiency, only one client can hook each callback.
+ *
+ * Since these callbacks are called on packet transmit and reception
+ * paths, clients should avoid acquiring locks or allocating memory.
+ *
+ * @tx_packet: Called when packet is about to be transmitted
+ * @rx_packet: Called when packet is received
+ * @link_change: Called when link status has changed
+ * @request_mtu: Called to request MTU change
+ * @mtu_changed: Called when MTU has been changed
+ * @event: Called when NIC event is not handled by the sfc driver
+ */
+struct efx_dl_callbacks {
+	/*
+	 * tx_packet - Packet about to be transmitted.
+	 * @efx_dev:		Efx driverlink device
+	 * @skb:		Socket buffer containing the packet to be sent
+	 *
+	 * This method is called for every packet about to be
+	 * transmitted.  It allows the client to snoop on traffic sent
+	 * via the kernel queues.
+	 *
+	 * The method may return %EFX_VETO_PACKET in order to prevent
+	 * the sfc driver from transmitting the packet.  The net
+	 * driver will then discard the packet.  If the client wishes
+	 * to retain a reference to the packet data after returning
+	 * %EFX_VETO_PACKET, it must obtain its own copy of the
+	 * packet (e.g. by calling skb_get(), or by copying out the
+	 * packet data to an external buffer).
+	 *
+	 * This method must return quickly, since it will have a
+	 * direct performance impact upon the sfc driver.  It will be
+	 * called with interrupts disabled (and may be called in
+	 * interrupt context), so may not sleep. Since the sfc driver
+	 * may have multiple TX queues, running in parallel, please avoid
+	 * the need for locking if it all possible.
+	 */
+	enum efx_veto (*tx_packet) (struct efx_dl_device *efx_dev,
+				    struct sk_buff *skb);
+
+	/*
+	 * rx_packet - Packet received.
+	 * @efx_dev:		Efx driverlink device
+	 * @pkt_hdr:		Pointer to received packet
+	 * @pkt_len:		Length of received packet
+	 *
+	 * This method is called for every received packet.  It allows
+	 * the client to snoop on traffic received by the kernel
+	 * queues.
+	 *
+	 * The method may return %EFX_VETO_PACKET in order to prevent
+	 * the sfc driver from passing the packet to the kernel.  The net
+	 * driver will then discard the packet.
+	 *
+	 * This method must return quickly, since it will have a
+	 * direct performance impact upon the sfc driver.  It is
+	 * called in tasklet context, so may not sleep.  Note that
+	 * there are per-channel tasklets in the sfc driver, so
+	 * rx_packet() may be called simultaneously on different CPUs
+	 * and must lock appropriately.  The design of the sfc driver
+	 * allows for lockless operation between receive channels, so
+	 * please avoid the need for locking if at all possible.
+	 */
+	enum efx_veto (*rx_packet) (struct efx_dl_device *efx_dev,
+				    const char *pkt_hdr, int pkt_len);
+
+	/*
+	 * link_change - Link status change.
+	 * @efx_dev:		Efx driverlink device
+	 * @link_up:		Link up indicator
+	 *
+	 * This method is called to inform the driverlink client
+	 * whenever the PHY link status changes.  By the time this
+	 * function is called, the MAC has already been reconfigured
+	 * with the new autonegotiation settings from the PHY.
+	 *
+	 * This method is called from tasklet context and may not
+	 * sleep.
+	 */
+	void (*link_change) (struct efx_dl_device *efx_dev, int link_up);
+
+	/*
+	 * request_mtu: Request MTU change.
+	 * @efx_dev:		Efx driverlink device
+	 * @new_mtu:		Requested new MTU
+	 *
+	 * This method is called whenever the user requests an MTU
+	 * change on an interface.  The client may return an error, in
+	 * which case the MTU change request will be denied.  If the
+	 * client returns success, the MAC will be reconfigured with a
+	 * new maxmimum frame length equal to
+	 * EFX_MAX_FRAME_LEN(new_mtu).  The client will be notified
+	 * via the mtu_changed() method once the MAC has been
+	 * reconfigured.
+	 *
+	 * The current MTU for the port can be obtained via
+	 * efx_dl_get_netdev(efx_dl_device)->mtu.
+	 *
+	 * The sfc driver guarantees that no other callback functions
+	 * are in progress when this method is called.  This function
+	 * is called in process context and may sleep.
+	 *
+	 * Return a negative error code or 0 on success.
+	 */
+	int (*request_mtu) (struct efx_dl_device *efx_dev, int new_mtu);
+
+	/*
+	 * mtu_changed - MTU has been changed.
+	 * @efx_dev:		Efx driverlink device
+	 * @mtu:		The new MTU
+	 *
+	 * This method is called once the MAC has been reconfigured
+	 * with a new MTU.  There will have been a preceding call to
+	 * request_mtu().
+	 *
+	 * The sfc driver guarantees that no other callback functions
+	 * are in progress when this method is called.  This function
+	 * is called in process context and may sleep.
+	 */
+	void (*mtu_changed) (struct efx_dl_device *efx_dev, int mtu);
+
+	/*
+	 * event - Event callback.
+	 * @efx_dev:		Efx driverlink device
+	 * @p_event:		Pointer to event
+	 *
+	 * This method is called for each event that is not handled by the
+	 * sfc driver.
+	 */
+	void (*event) (struct efx_dl_device *efx_dev, void *p_event);
+};
+
+/* Include API version number in symbol used for efx_dl_register_driver */
+#define efx_dl_stringify_1(x, y) x ## y
+#define efx_dl_stringify_2(x, y) efx_dl_stringify_1(x, y)
+#define efx_dl_register_driver					\
+	efx_dl_stringify_2(efx_dl_register_driver_api_ver_,	\
+			   EFX_DRIVERLINK_API_VERSION)
+
+extern int efx_dl_register_driver(struct efx_dl_driver *driver);
+
+extern void efx_dl_unregister_driver(struct efx_dl_driver *driver);
+
+extern int efx_dl_register_callbacks(struct efx_dl_device *efx_dev,
+				     struct efx_dl_callbacks *callbacks);
+
+extern void efx_dl_unregister_callbacks(struct efx_dl_device *efx_dev,
+					struct efx_dl_callbacks *callbacks);
+
+extern void efx_dl_schedule_reset(struct efx_dl_device *efx_dev);
+
+/**
+ * efx_dl_for_each_device_info_matching - iterate an efx_dl_device_info list
+ * @_dev_info: Pointer to first &struct efx_dl_device_info
+ * @_type: Type code to look for
+ * @_info_type: Structure type corresponding to type code
+ * @_field: Name of &struct efx_dl_device_info field in the type
+ * @_p: Iterator variable
+ *
+ * Example:
+ *
+ * static int driver_dl_probe(... const struct efx_dl_device_info *dev_info ...)
+ * {
+ *        struct efx_dl_falcon_resources *res;
+ *
+ *        efx_dl_for_each_device_info_matching(dev_info,EFX_DL_FALCON_RESOURCES,
+ *                                             struct efx_dl_falcon_resources,
+ *                                             hdr, res) {
+ *                if (res->flags & EFX_DL_FALCON_DUAL_FUNC) {
+ *                          .....
+ *                }
+ *        }
+ * }
+ */
+#define efx_dl_for_each_device_info_matching(_dev_info, _type,		\
+					     _info_type, _field, _p)	\
+	for ((_p) = container_of((_dev_info), _info_type, _field);	\
+	     (_p) != NULL;						\
+	     (_p) = container_of((_p)->_field.next, _info_type, _field))\
+		if ((_p)->_field.type != _type)				\
+			continue;					\
+		else
+
+/**
+ * efx_dl_search_device_info - search an efx_dl_device_info list
+ * @_dev_info: Pointer to first &struct efx_dl_device_info
+ * @_type: Type code to look for
+ * @_info_type: Structure type corresponding to type code
+ * @_field: Name of &struct efx_dl_device_info member in this type
+ * @_p: Result variable
+ *
+ * Example:
+ *
+ * static int driver_dl_probe(... const struct efx_dl_device_info *dev_info ...)
+ * {
+ *        struct efx_dl_falcon_resources *res;
+ *
+ *        efx_dl_search_device_info(dev_info, EFX_DL_FALCON_RESOURCES,
+ *                                  struct efx_dl_falcon_resources, hdr, res);
+ *        if (res != NULL) {
+ *                 ....
+ *        }
+ * }
+ */
+#define efx_dl_search_device_info(_dev_info, _type, _info_type,		\
+				  _field, _p)				\
+	efx_dl_for_each_device_info_matching((_dev_info), (_type),	\
+					     _info_type, _field, (_p))	\
+		break;
+
+#endif /* EFX_DRIVERLINK_API_H */
Index: head-2008-06-18/drivers/net/sfc/efx.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/efx.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/efx.c	2008-06-18 15:54:08.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2005-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #include <linux/module.h>
@@ -19,8 +36,12 @@
 #include <linux/in.h>
 #include <linux/crc32.h>
 #include <linux/ethtool.h>
+#include <asm/uaccess.h>
 #include "net_driver.h"
 #include "gmii.h"
+#include "driverlink.h"
+#include "selftest.h"
+#include "debugfs.h"
 #include "ethtool.h"
 #include "tx.h"
 #include "rx.h"
@@ -28,7 +49,70 @@
 #include "mdio_10g.h"
 #include "falcon.h"
 #include "workarounds.h"
-#include "mac.h"
+
+/**************************************************************************
+ *
+ * Type name strings
+ *
+ **************************************************************************
+ */
+
+/* Loopback mode names (see LOOPBACK_MODE()) */
+const unsigned int efx_loopback_mode_max = LOOPBACK_MAX;
+const char *efx_loopback_mode_names[] = {
+	[LOOPBACK_NONE]	   = "NONE",
+	[LOOPBACK_MAC]	   = "MAC",
+	[LOOPBACK_XGMII]   = "XGMII",
+	[LOOPBACK_XGXS]	   = "XGXS",
+	[LOOPBACK_XAUI]    = "XAUI",
+	[LOOPBACK_PHY]	   = "PHY",
+	[LOOPBACK_PHYXS]   = "PHY(XS)",
+	[LOOPBACK_PCS]     = "PHY(PCS)",
+	[LOOPBACK_PMAPMD]  = "PHY(PMAPMD)",
+	[LOOPBACK_NETWORK] = "NETWORK",
+};
+
+/* Interrupt mode names (see INT_MODE())) */
+const unsigned int efx_interrupt_mode_max = EFX_INT_MODE_MAX;
+const char *efx_interrupt_mode_names[] = {
+	[EFX_INT_MODE_MSIX]   = "MSI-X",
+	[EFX_INT_MODE_MSI]    = "MSI",
+	[EFX_INT_MODE_LEGACY] = "legacy",
+};
+
+/* PHY type names (see PHY_TYPE())) */
+const unsigned int efx_phy_type_max = PHY_TYPE_MAX;
+const char *efx_phy_type_names[] = {
+	[PHY_TYPE_NONE]        = "none",
+	[PHY_TYPE_CX4_RTMR]    = "Mysticom CX4",
+	[PHY_TYPE_1G_ALASKA]   = "1G Alaska",
+	[PHY_TYPE_10XPRESS]    = "SFC 10Xpress",
+	[PHY_TYPE_XFP]         = "Quake XFP",
+	[PHY_TYPE_PM8358]      = "PM8358 XAUI",
+};
+
+const unsigned int efx_reset_type_max = RESET_TYPE_MAX;
+const char *efx_reset_type_names[] = {
+	[RESET_TYPE_INVISIBLE]     = "INVISIBLE",
+	[RESET_TYPE_ALL]           = "ALL",
+	[RESET_TYPE_WORLD]         = "WORLD",
+	[RESET_TYPE_DISABLE]       = "DISABLE",
+	[RESET_TYPE_MONITOR]       = "MONITOR",
+	[RESET_TYPE_INT_ERROR]     = "INT_ERROR",
+	[RESET_TYPE_RX_RECOVERY]   = "RX_RECOVERY",
+	[RESET_TYPE_RX_DESC_FETCH] = "RX_DESC_FETCH",
+	[RESET_TYPE_TX_DESC_FETCH] = "TX_DESC_FETCH",
+	[RESET_TYPE_TX_SKIP]       = "TX_SKIP",
+};
+
+const unsigned int efx_nic_state_max = STATE_MAX;
+const char *efx_nic_state_names[] = {
+	[STATE_INIT]          = "INIT",
+	[STATE_RUNNING]       = "RUNNING",
+	[STATE_FINI]          = "FINI",
+	[STATE_RESETTING]     = "RESETTING",
+	[STATE_DISABLED]      = "DISABLED",
+};
 
 #define EFX_MAX_MTU (9 * 1024)
 
@@ -110,6 +194,13 @@ static unsigned int rx_irq_mod_usec = 60
  */
 static unsigned int tx_irq_mod_usec = 150;
 
+/* Ignore online self-test failures at load
+ *
+ * If set to 1, then the driver will not fail to load
+ * if the online self-test fails. Useful only during testing
+ */
+static unsigned int allow_load_on_failure;
+
 /* This is the first interrupt mode to try out of:
  * 0 => MSI-X
  * 1 => MSI
@@ -117,6 +208,12 @@ static unsigned int tx_irq_mod_usec = 15
  */
 static unsigned int interrupt_mode;
 
+/* If set to 1, then the driver will perform an offline self test
+ * when each interface first comes up. This will appear like the
+ * interface bounces up and down
+ */
+static unsigned int onload_offline_selftest = 1;
+
 /* This is the requested number of CPUs to use for Receive-Side Scaling (RSS),
  * i.e. the number of CPUs among which we may distribute simultaneous
  * interrupt handling.
@@ -199,12 +296,11 @@ static inline int efx_process_channel(st
  */
 static inline void efx_channel_processed(struct efx_channel *channel)
 {
-	/* The interrupt handler for this channel may set work_pending
-	 * as soon as we acknowledge the events we've seen.  Make sure
-	 * it's cleared before then. */
+	/* Write to EVQ_RPTR_REG.  If a new event arrived in a race
+	 * with finishing processing, a new interrupt will be raised.
+	 */
 	channel->work_pending = 0;
-	smp_wmb();
-
+	smp_wmb(); /* Ensure channel updated before any new interrupt. */
 	falcon_eventq_read_ack(channel);
 }
 
@@ -266,13 +362,16 @@ void efx_process_channel_now(struct efx_
 	napi_disable(&channel->napi_str);
 
 	/* Poll the channel */
-	efx_process_channel(channel, efx->type->evq_size);
+	(void) efx_process_channel(channel, efx->type->evq_size);
 
 	/* Ack the eventq. This may cause an interrupt to be generated
 	 * when they are reenabled */
 	efx_channel_processed(channel);
 
+	/* Reenable NAPI polling */
 	napi_enable(&channel->napi_str);
+
+	/* Reenable interrupts */
 	falcon_enable_interrupts(efx);
 }
 
@@ -293,6 +392,7 @@ static int efx_init_eventq(struct efx_ch
 {
 	EFX_LOG(channel->efx, "chan %d init event queue\n", channel->channel);
 
+	/* Initialise fields */
 	channel->eventq_read_ptr = 0;
 
 	return falcon_init_eventq(channel);
@@ -318,6 +418,26 @@ static void efx_remove_eventq(struct efx
  *
  *************************************************************************/
 
+/* Setup per-NIC RX buffer parameters.
+ * Calculate the rx buffer allocation parameters required to support
+ * the current MTU, including padding for header alignment and overruns.
+ */
+static void efx_calc_rx_buffer_params(struct efx_nic *efx)
+{
+	unsigned int order, len;
+
+	len = (max(EFX_PAGE_IP_ALIGN, NET_IP_ALIGN) +
+	       EFX_MAX_FRAME_LEN(efx->net_dev->mtu) +
+	       efx->type->rx_buffer_padding);
+
+	/* Calculate page-order */
+	for (order = 0; ((1u << order) * PAGE_SIZE) < len; ++order)
+		;
+
+	efx->rx_buffer_len = len;
+	efx->rx_buffer_order = order;
+}
+
 static int efx_probe_channel(struct efx_channel *channel)
 {
 	struct efx_tx_queue *tx_queue;
@@ -368,14 +488,8 @@ static int efx_init_channels(struct efx_
 	struct efx_channel *channel;
 	int rc = 0;
 
-	/* Calculate the rx buffer allocation parameters required to
-	 * support the current MTU, including padding for header
-	 * alignment and overruns.
-	 */
-	efx->rx_buffer_len = (max(EFX_PAGE_IP_ALIGN, NET_IP_ALIGN) +
-			      EFX_MAX_FRAME_LEN(efx->net_dev->mtu) +
-			      efx->type->rx_buffer_padding);
-	efx->rx_buffer_order = get_order(efx->rx_buffer_len);
+	/* Recalculate the rx buffer parameters */
+	efx_calc_rx_buffer_params(efx);
 
 	/* Initialise the channels */
 	efx_for_each_channel(channel, efx) {
@@ -428,13 +542,12 @@ static void efx_start_channel(struct efx
 		netif_napi_add(channel->napi_dev, &channel->napi_str,
 			       efx_poll, napi_weight);
 
-	/* The interrupt handler for this channel may set work_pending
-	 * as soon as we enable it.  Make sure it's cleared before
-	 * then.  Similarly, make sure it sees the enabled flag set. */
+	/* Mark channel as enabled */
 	channel->work_pending = 0;
 	channel->enabled = 1;
-	smp_wmb();
+	smp_wmb(); /* ensure channel updated before first interrupt */
 
+	/* Enable NAPI poll handler */
 	napi_enable(&channel->napi_str);
 
 	/* Load up RX descriptors */
@@ -455,7 +568,10 @@ static void efx_stop_channel(struct efx_
 
 	EFX_LOG(channel->efx, "stop chan %d\n", channel->channel);
 
+	/* Mark channel as disabled */
 	channel->enabled = 0;
+
+	/* Wait for any NAPI processing to complete */
 	napi_disable(&channel->napi_str);
 
 	/* Ensure that any worker threads have exited or will be no-ops */
@@ -544,6 +660,9 @@ static void efx_link_status_changed(stru
 			netif_carrier_off(efx->net_dev);
 	}
 
+	/* Inform driverlink client */
+	EFX_DL_CALLBACK(efx, link_change, efx->link_up);
+
 	/* Status message for kernel log */
 	if (efx->link_up) {
 		struct mii_if_info *gmii = &efx->mii;
@@ -558,7 +677,7 @@ static void efx_link_status_changed(stru
 			adv = lpa;
 		}
 		EFX_INFO(efx, "link up at %dMbps %s-duplex "
-			 "(adv %04x lpa %04x) (MTU %d)%s\n",
+			 "(adv %04x lpa %04x) (MTU %d)%s%s%s%s\n",
 			 (efx->link_options & GM_LPA_10000 ? 10000 :
 			  (efx->link_options & GM_LPA_1000 ? 1000 :
 			   (efx->link_options & GM_LPA_100 ? 100 :
@@ -567,9 +686,13 @@ static void efx_link_status_changed(stru
 			  "full" : "half"),
 			 adv, lpa,
 			 efx->net_dev->mtu,
+			 (efx->loopback_mode ? " [" : ""),
+			 (efx->loopback_mode ? LOOPBACK_MODE(efx) : ""),
+			 (efx->loopback_mode ? " LOOPBACK]" : ""),
 			 (efx->promiscuous ? " [PROMISC]" : ""));
 	} else {
-		EFX_INFO(efx, "link down\n");
+		EFX_INFO(efx, "link down%s\n",
+			 efx->phy_powered ? "" : " [OFF]");
 	}
 
 }
@@ -583,7 +706,7 @@ static void __efx_reconfigure_port(struc
 	EFX_LOG(efx, "reconfiguring MAC from PHY settings on CPU %d\n",
 		raw_smp_processor_id());
 
-	falcon_reconfigure_xmac(efx);
+	efx->mac_op->reconfigure(efx);
 
 	/* Inform kernel of loss/gain of carrier */
 	efx_link_status_changed(efx);
@@ -616,6 +739,7 @@ static void efx_reconfigure_work(struct 
 
 static int efx_probe_port(struct efx_nic *efx)
 {
+	unsigned char *dev_addr;
 	int rc;
 
 	EFX_LOG(efx, "create port\n");
@@ -626,22 +750,28 @@ static int efx_probe_port(struct efx_nic
 		goto err;
 
 	/* Sanity check MAC address */
-	if (is_valid_ether_addr(efx->mac_address)) {
-		memcpy(efx->net_dev->dev_addr, efx->mac_address, ETH_ALEN);
+	dev_addr = efx->mac_address;
+	if (is_valid_ether_addr(dev_addr)) {
+		memcpy(efx->net_dev->dev_addr, dev_addr, ETH_ALEN);
 	} else {
 		DECLARE_MAC_BUF(mac);
 
 		EFX_ERR(efx, "invalid MAC address %s\n",
-			print_mac(mac, efx->mac_address));
+			print_mac(mac, dev_addr));
 		if (!allow_bad_hwaddr) {
 			rc = -EINVAL;
 			goto err;
 		}
-		random_ether_addr(efx->net_dev->dev_addr);
+		random_ether_addr(dev_addr);
 		EFX_INFO(efx, "using locally-generated MAC %s\n",
-			 print_mac(mac, efx->net_dev->dev_addr));
+			 print_mac(mac, dev_addr));
 	}
 
+	/* Register debugfs entries */
+	rc = efx_init_debugfs_port(efx);
+	if (rc)
+		goto err;
+
 	return 0;
 
  err:
@@ -655,15 +785,18 @@ static int efx_init_port(struct efx_nic 
 
 	EFX_LOG(efx, "init port\n");
 
+	/* The default power state is ON */
+	efx->phy_powered = 1;
+
 	/* Initialise the MAC and PHY */
-	rc = falcon_init_xmac(efx);
+	rc = efx->mac_op->init(efx);
 	if (rc)
 		return rc;
 
 	efx->port_initialized = 1;
 
 	/* Reconfigure port to program MAC registers */
-	falcon_reconfigure_xmac(efx);
+	efx->mac_op->reconfigure(efx);
 
 	return 0;
 }
@@ -708,9 +841,10 @@ static void efx_fini_port(struct efx_nic
 	if (!efx->port_initialized)
 		return;
 
-	falcon_fini_xmac(efx);
+	efx->mac_op->fini(efx);
 	efx->port_initialized = 0;
 
+	/* Mark the link down */
 	efx->link_up = 0;
 	efx_link_status_changed(efx);
 }
@@ -719,6 +853,7 @@ static void efx_remove_port(struct efx_n
 {
 	EFX_LOG(efx, "destroying port\n");
 
+	efx_fini_debugfs_port(efx);
 	falcon_remove_port(efx);
 }
 
@@ -737,6 +872,7 @@ static int efx_init_io(struct efx_nic *e
 
 	EFX_LOG(efx, "initialising I/O\n");
 
+	/* Generic device-enabling code */
 	rc = pci_enable_device(pci_dev);
 	if (rc) {
 		EFX_ERR(efx, "failed to enable PCI device\n");
@@ -771,6 +907,7 @@ static int efx_init_io(struct efx_nic *e
 		goto fail2;
 	}
 
+	/* Get memory base address */
 	efx->membase_phys = pci_resource_start(efx->pci_dev,
 					       efx->type->mem_bar);
 	rc = pci_request_region(pci_dev, efx->type->mem_bar, "sfc");
@@ -799,6 +936,7 @@ static int efx_init_io(struct efx_nic *e
 	release_mem_region(efx->membase_phys, efx->type->mem_map_size);
  fail3:
 	efx->membase_phys = 0;
+	/* fall-thru */
  fail2:
 	pci_disable_device(efx->pci_dev);
  fail1:
@@ -832,7 +970,28 @@ static void efx_probe_interrupts(struct 
 	if (efx->interrupt_mode == EFX_INT_MODE_MSIX) {
 		BUG_ON(!pci_find_capability(efx->pci_dev, PCI_CAP_ID_MSIX));
 
-		efx->rss_queues = rss_cpus ? rss_cpus : num_online_cpus();
+		if (rss_cpus == 0) {
+#ifdef topology_core_siblings
+			cpumask_t core_mask;
+			int cpu;
+
+			cpus_clear(core_mask);
+			efx->rss_queues = 0;
+			for_each_online_cpu(cpu) {
+				if (!cpu_isset(cpu, core_mask)) {
+					++efx->rss_queues;
+					cpus_or(core_mask, core_mask,
+						topology_core_siblings(cpu));
+				}
+			}
+#else
+			efx->rss_queues = num_online_cpus();
+#endif
+		} else {
+			efx->rss_queues = rss_cpus;
+		}
+
+		/* Limit the number of rss queues appropriately */
 		efx->rss_queues = min(efx->rss_queues, max_channel + 1);
 		efx->rss_queues = min(efx->rss_queues, EFX_MAX_CHANNELS);
 
@@ -948,7 +1107,7 @@ static int efx_probe_nic(struct efx_nic 
 	/* Carry out hardware-type specific initialisation */
 	rc = falcon_probe_nic(efx);
 	if (rc)
-		return rc;
+		goto fail1;
 
 	/* Determine the number of channels and RX queues by trying to hook
 	 * in MSI-X interrupts. */
@@ -957,10 +1116,20 @@ static int efx_probe_nic(struct efx_nic 
 	/* Determine number of RX queues and TX queues */
 	efx_select_used(efx);
 
+	/* Register debugfs entries */
+	rc = efx_init_debugfs_nic(efx);
+	if (rc)
+		goto fail2;
 	/* Initialise the interrupt moderation settings */
 	efx_init_irq_moderation(efx, tx_irq_mod_usec, rx_irq_mod_usec);
 
 	return 0;
+
+ fail2:
+	efx_remove_interrupts(efx);
+	falcon_remove_nic(efx);
+ fail1:
+	return rc;
 }
 
 static void efx_remove_nic(struct efx_nic *efx)
@@ -969,6 +1138,8 @@ static void efx_remove_nic(struct efx_ni
 
 	efx_remove_interrupts(efx);
 	falcon_remove_nic(efx);
+
+	efx_fini_debugfs_nic(efx);
 }
 
 /**************************************************************************
@@ -1065,8 +1236,9 @@ static void efx_flush_all(struct efx_nic
 	cancel_delayed_work_sync(&efx->monitor_work);
 
 	/* Ensure that all RX slow refills are complete. */
-	efx_for_each_rx_queue(rx_queue, efx)
+	efx_for_each_rx_queue(rx_queue, efx) {
 		cancel_delayed_work_sync(&rx_queue->work);
+	}
 
 	/* Stop scheduled port reconfigurations */
 	cancel_work_sync(&efx->reconfigure_work);
@@ -1092,10 +1264,9 @@ static void efx_stop_all(struct efx_nic 
 	falcon_disable_interrupts(efx);
 	if (efx->legacy_irq)
 		synchronize_irq(efx->legacy_irq);
-	efx_for_each_channel_with_interrupt(channel, efx) {
+	efx_for_each_channel_with_interrupt(channel, efx)
 		if (channel->irq)
 			synchronize_irq(channel->irq);
-	}
 
 	/* Stop all NAPI processing and synchronous rx refills */
 	efx_for_each_channel(channel, efx)
@@ -1133,6 +1304,39 @@ static void efx_remove_all(struct efx_ni
 	efx_remove_nic(efx);
 }
 
+static int efx_run_selftests(struct efx_nic *efx)
+{
+	struct efx_self_tests tests;
+	unsigned modes = efx->startup_loopbacks & efx->loopback_modes;
+	int rc;
+
+	rc = efx_online_test(efx, &tests);
+	if (rc) {
+		EFX_ERR(efx, "failed self-tests with interrupt_mode of %s\n",
+			INT_MODE(efx));
+		goto fail;
+	}
+
+	if (onload_offline_selftest && modes) {
+		/* Run offline self test */
+		EFX_LOG(efx, "performing on-load offline self-tests\n");
+		rc = efx_offline_test(efx, &tests, modes);
+		EFX_LOG(efx, "%s on-load offline self-tests\n",
+			rc ? "FAILED" : "PASSED");
+		if (rc)
+			goto fail;
+	}
+
+	return 0;
+
+ fail:
+	EFX_ERR(efx, "self-tests failed. Given up!\n");
+	if (allow_load_on_failure)
+		rc = 0;
+
+	return rc;
+}
+
 /* A convinience function to safely flush all the queues */
 int efx_flush_queues(struct efx_nic *efx)
 {
@@ -1203,7 +1407,7 @@ static void efx_monitor(struct work_stru
 	}
 
 	if (efx->port_enabled)
-		rc = falcon_check_xmac(efx);
+		rc = efx->mac_op->check_hw(efx);
 	mutex_unlock(&efx->mac_lock);
 
 	if (rc) {
@@ -1245,31 +1449,67 @@ static int efx_ioctl(struct net_device *
  *
  **************************************************************************/
 
+/* Allocate the NAPI dev's.
+ * Called after we know how many channels there are.
+ */
 static int efx_init_napi(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
 	int rc;
 
+	/* Allocate the NAPI dev for the port */
+	efx->net_dev = alloc_etherdev(0);
+	if (!efx->net_dev) {
+		rc = -ENOMEM;
+		goto err;
+	}
+	efx->net_dev->priv = efx;
+	efx->mii.dev = efx->net_dev;
+
+	efx->net_dev->features |= (NETIF_F_IP_CSUM | NETIF_F_SG |
+				   NETIF_F_HIGHDMA);
+	efx->net_dev->features |= NETIF_F_TSO;
+	if (lro)
+		efx->net_dev->features |= NETIF_F_LRO;
+
+	/* Copy MAC address */
+	memcpy(&efx->net_dev->dev_addr, efx->mac_address, ETH_ALEN);
+
+	/* Allocate the per channel devs */
 	efx_for_each_channel(channel, efx) {
 		channel->napi_dev = efx->net_dev;
-		rc = efx_lro_init(&channel->lro_mgr, efx);
+
+		/* Initialise LRO/SSR */
+		rc = efx_ssr_init(&channel->ssr, efx);
 		if (rc)
 			goto err;
 	}
+
 	return 0;
  err:
 	efx_fini_napi(efx);
 	return rc;
 }
 
+/* Free the NAPI state for the port and channels */
 static void efx_fini_napi(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
 
 	efx_for_each_channel(channel, efx) {
-		efx_lro_fini(&channel->lro_mgr);
+		/* Fini LRO/SSR */
+		efx_ssr_fini(&channel->ssr);
+
+		/* Finish per channel NAPI */
 		channel->napi_dev = NULL;
 	}
+
+	/* Finish port NAPI */
+	if (efx->net_dev) {
+		efx->net_dev->priv = NULL;
+		free_netdev(efx->net_dev);
+		efx->net_dev = NULL;
+	}
 }
 
 /**************************************************************************
@@ -1336,7 +1576,7 @@ static int efx_net_stop(struct net_devic
 	return 0;
 }
 
-/* Context: process, dev_base_lock or RTNL held, non-blocking. */
+/* Context: process, dev_base_lock held, non-blocking. */
 static struct net_device_stats *efx_net_stats(struct net_device *net_dev)
 {
 	struct efx_nic *efx = net_dev->priv;
@@ -1350,7 +1590,7 @@ static struct net_device_stats *efx_net_
 	if (!spin_trylock(&efx->stats_lock))
 		return stats;
 	if (efx->state == STATE_RUNNING) {
-		falcon_update_stats_xmac(efx);
+		efx->mac_op->update_stats(efx);
 		falcon_update_nic_stats(efx);
 	}
 	spin_unlock(&efx->stats_lock);
@@ -1410,6 +1650,14 @@ static int efx_change_mtu(struct net_dev
 
 	efx_stop_all(efx);
 
+	/* Ask driverlink client if we can change MTU */
+	rc = EFX_DL_CALLBACK(efx, request_mtu, new_mtu);
+	if (rc) {
+		EFX_ERR(efx, "MTU change vetoed by driverlink %s driver\n",
+			efx->dl_cb_dev.request_mtu->driver->name);
+		goto out;
+	}
+
 	EFX_LOG(efx, "changing MTU to %d\n", new_mtu);
 
 	efx_fini_channels(efx);
@@ -1418,6 +1666,10 @@ static int efx_change_mtu(struct net_dev
 	if (rc)
 		goto fail;
 
+	/* Notify driverlink client of new MTU */
+	EFX_DL_CALLBACK(efx, mtu_changed, new_mtu);
+
+ out:
 	efx_start_all(efx);
 	return rc;
 
@@ -1487,6 +1739,7 @@ static void efx_set_multicast_list(struc
 	falcon_set_multicast_hash(efx);
 }
 
+/* Handle net device notifier events */
 static int efx_netdev_event(struct notifier_block *this,
 			    unsigned long event, void *ptr)
 {
@@ -1496,6 +1749,8 @@ static int efx_netdev_event(struct notif
 		struct efx_nic *efx = net_dev->priv;
 
 		strcpy(efx->name, net_dev->name);
+		efx_fini_debugfs_netdev(net_dev);
+		efx_init_debugfs_netdev(net_dev);
 	}
 
 	return NOTIFY_DONE;
@@ -1531,7 +1786,7 @@ static int efx_register_netdev(struct ef
 	netif_carrier_off(efx->net_dev);
 
 	/* Clear MAC statistics */
-	falcon_update_stats_xmac(efx);
+	efx->mac_op->update_stats(efx);
 	memset(&efx->mac_stats, 0, sizeof(efx->mac_stats));
 
 	rc = register_netdev(net_dev);
@@ -1541,6 +1796,14 @@ static int efx_register_netdev(struct ef
 	}
 	strcpy(efx->name, net_dev->name);
 
+	/* Create debugfs symlinks */
+	rc = efx_init_debugfs_netdev(net_dev);
+	if (rc) {
+		EFX_ERR(efx, "failed to init net dev debugfs\n");
+		unregister_netdev(efx->net_dev);
+		return rc;
+	}
+
 	return 0;
 }
 
@@ -1561,6 +1824,7 @@ static void efx_unregister_netdev(struct
 
 	if (efx_dev_registered(efx)) {
 		strlcpy(efx->name, pci_name(efx->pci_dev), sizeof(efx->name));
+		efx_fini_debugfs_netdev(efx->net_dev);
 		unregister_netdev(efx->net_dev);
 	}
 }
@@ -1571,14 +1835,34 @@ static void efx_unregister_netdev(struct
  *
  **************************************************************************/
 
-/* The final hardware and software finalisation before reset. */
+/* Serialise access to the driverlink callbacks, by quiescing event processing
+ * (without flushing the descriptor queues), and acquiring the rtnl_lock */
+void efx_suspend(struct efx_nic *efx)
+{
+	EFX_LOG(efx, "suspending operations\n");
+
+	rtnl_lock();
+	efx_stop_all(efx);
+}
+
+void efx_resume(struct efx_nic *efx)
+{
+	EFX_LOG(efx, "resuming operations\n");
+
+	efx_start_all(efx);
+	rtnl_unlock();
+}
+
+/* The final hardware and software finalisation before reset.
+ * This function does not handle serialisation with the kernel, it
+ * assumes the caller has done this */
 static int efx_reset_down(struct efx_nic *efx, struct ethtool_cmd *ecmd)
 {
 	int rc;
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	rc = falcon_xmac_get_settings(efx, ecmd);
+	rc = efx->mac_op->get_settings(efx, ecmd);
 	if (rc) {
 		EFX_ERR(efx, "could not back up PHY settings\n");
 		goto fail;
@@ -1603,7 +1887,7 @@ static int efx_reset_up(struct efx_nic *
 		goto fail1;
 
 	/* Restore MAC and PHY settings. */
-	rc = falcon_xmac_set_settings(efx, ecmd);
+	rc = efx->mac_op->set_settings(efx, ecmd);
 	if (rc) {
 		EFX_ERR(efx, "could not restore PHY settings\n");
 		goto fail2;
@@ -1624,7 +1908,8 @@ static int efx_reset_up(struct efx_nic *
  * This function will sleep.  You cannot reset from within an atomic
  * state; use efx_schedule_reset() instead.
  *
- * Grabs the rtnl_lock.
+ * Grabs the dl_reset_lock, and to serialise with kernel interfaces the
+ * rtnl_lock.
  */
 static int efx_reset(struct efx_nic *efx)
 {
@@ -1632,6 +1917,10 @@ static int efx_reset(struct efx_nic *efx
 	enum reset_type method = efx->reset_pending;
 	int rc;
 
+	/* Notify driverlink clients of imminent reset. */
+	efx_dl_reset_lock();
+	efx_dl_reset_suspend(efx);
+
 	/* Serialise with kernel interfaces */
 	rtnl_lock();
 
@@ -1643,7 +1932,7 @@ static int efx_reset(struct efx_nic *efx
 	}
 
 	efx->state = STATE_RESETTING;
-	EFX_INFO(efx, "resetting (%d)\n", method);
+	EFX_INFO(efx, "resetting (%s)\n", RESET_TYPE(method));
 
 	/* The net_dev->get_stats handler is quite slow, and will fail
 	 * if a fetch is pending over reset. Serialise against it. */
@@ -1656,6 +1945,7 @@ static int efx_reset(struct efx_nic *efx
 	rc = efx_reset_down(efx, &ecmd);
 	if (rc)
 		goto fail1;
+	falcon_fini_nic(efx);
 
 	rc = falcon_reset_hw(efx, method);
 	if (rc) {
@@ -1684,7 +1974,7 @@ static int efx_reset(struct efx_nic *efx
 	if (method == RESET_TYPE_DISABLE) {
 		/* Reinitialise the device anyway so the driver unload sequence
 		 * can talk to the external SRAM */
-		falcon_init_nic(efx);
+		(void) falcon_init_nic(efx);
 		rc = -EIO;
 		goto fail4;
 	}
@@ -1701,6 +1991,8 @@ static int efx_reset(struct efx_nic *efx
 
  unlock_rtnl:
 	rtnl_unlock();
+	efx_dl_reset_resume(efx, 1);
+	efx_dl_reset_unlock();
 	return 0;
 
  fail5:
@@ -1713,8 +2005,11 @@ static int efx_reset(struct efx_nic *efx
 
 	mutex_unlock(&efx->mac_lock);
 	rtnl_unlock();
+	/* Remove the net_dev */
 	efx_unregister_netdev(efx);
 	efx_fini_port(efx);
+	efx_dl_reset_resume(efx, 0);
+	efx_dl_reset_unlock();
 	return rc;
 }
 
@@ -1756,9 +2051,10 @@ void efx_schedule_reset(struct efx_nic *
 	}
 
 	if (method != type)
-		EFX_LOG(efx, "scheduling reset (%d:%d)\n", type, method);
+		EFX_LOG(efx, "scheduling %s reset for %s\n",
+			RESET_TYPE(method), RESET_TYPE(type));
 	else
-		EFX_LOG(efx, "scheduling reset (%d)\n", method);
+		EFX_LOG(efx, "scheduling %s reset\n", RESET_TYPE(method));
 
 	efx->reset_pending = method;
 
@@ -1796,6 +2092,12 @@ int efx_port_dummy_op_int(struct efx_nic
 void efx_port_dummy_op_void(struct efx_nic *efx) {}
 void efx_port_dummy_op_blink(struct efx_nic *efx, int blink) {}
 
+static struct efx_mac_operations efx_dummy_mac_operations = {
+	.init		= efx_port_dummy_op_int,
+	.reconfigure	= efx_port_dummy_op_void,
+	.fini		= efx_port_dummy_op_void,
+};
+
 static struct efx_phy_operations efx_dummy_phy_operations = {
 	.init		 = efx_port_dummy_op_int,
 	.reconfigure	 = efx_port_dummy_op_void,
@@ -1811,10 +2113,15 @@ static int efx_nic_dummy_op_int(struct e
 	return 0;
 }
 
+static void efx_nic_dummy_op_void(struct efx_nic *nic) {}
+
 static struct efx_board efx_dummy_board_info = {
 	.init    = efx_nic_dummy_op_int,
 	.init_leds = efx_port_dummy_op_int,
 	.set_fault_led = efx_port_dummy_op_blink,
+	.monitor = efx_nic_dummy_op_int,
+	.blink = efx_port_dummy_op_blink,
+	.fini    = efx_nic_dummy_op_void,
 };
 
 /**************************************************************************
@@ -1827,7 +2134,7 @@ static struct efx_board efx_dummy_board_
  * efx_nic (including all sub-structures).
  */
 static int efx_init_struct(struct efx_nic *efx, struct efx_nic_type *type,
-			   struct pci_dev *pci_dev, struct net_device *net_dev)
+			   struct pci_dev *pci_dev)
 {
 	struct efx_channel *channel;
 	struct efx_tx_queue *tx_queue;
@@ -1838,6 +2145,7 @@ static int efx_init_struct(struct efx_ni
 	memset(efx, 0, sizeof(*efx));
 	spin_lock_init(&efx->biu_lock);
 	spin_lock_init(&efx->phy_lock);
+	mutex_init(&efx->spi_lock);
 	INIT_WORK(&efx->reset_work, efx_reset_work);
 	INIT_DELAYED_WORK(&efx->monitor_work, efx_monitor);
 	efx->pci_dev = pci_dev;
@@ -1846,13 +2154,15 @@ static int efx_init_struct(struct efx_ni
 	strlcpy(efx->name, pci_name(pci_dev), sizeof(efx->name));
 	efx->board_info = efx_dummy_board_info;
 
-	efx->net_dev = net_dev;
 	efx->rx_checksum_enabled = 1;
 	spin_lock_init(&efx->netif_stop_lock);
 	spin_lock_init(&efx->stats_lock);
 	mutex_init(&efx->mac_lock);
+	efx->mac_op = &efx_dummy_mac_operations;
 	efx->phy_op = &efx_dummy_phy_operations;
-	efx->mii.dev = net_dev;
+	INIT_LIST_HEAD(&efx->dl_node);
+	INIT_LIST_HEAD(&efx->dl_device_list);
+	efx->dl_cb = efx_default_callbacks;
 	INIT_WORK(&efx->reconfigure_work, efx_reconfigure_work);
 	atomic_set(&efx->netif_stop_count, 1);
 
@@ -1894,6 +2204,7 @@ static int efx_init_struct(struct efx_ni
 	EFX_BUG_ON_PARANOID(efx->type->evq_size <
 			    (efx->type->txd_ring_mask + 1 +
 			     efx->type->rxd_ring_mask + 1));
+
 	EFX_BUG_ON_PARANOID(efx->type->phys_addr_channels > EFX_MAX_CHANNELS);
 
 	/* Higher numbered interrupt modes are less capable! */
@@ -1941,8 +2252,12 @@ static void efx_pci_remove_main(struct e
 	efx_fini_port(efx);
 
 	/* Shutdown the board, then the NIC and board state */
+	efx->board_info.fini(efx);
+	falcon_fini_nic(efx);
 	falcon_fini_interrupt(efx);
+	efx->board_info.fini(efx);
 
+	/* Tear down NAPI and LRO */
 	efx_fini_napi(efx);
 	efx_remove_all(efx);
 }
@@ -1958,6 +2273,9 @@ static void efx_pci_remove(struct pci_de
 	if (!efx)
 		return;
 
+	/* Unregister driver from driverlink layer */
+	efx_dl_unregister_nic(efx);
+
 	/* Mark the NIC as fini, then stop the interface */
 	rtnl_lock();
 	efx->state = STATE_FINI;
@@ -1970,6 +2288,7 @@ static void efx_pci_remove(struct pci_de
 		goto out;
 
 	efx_unregister_netdev(efx);
+	efx_fini_debugfs_channels(efx);
 
 	/* Wait for any scheduled resets to complete. No more will be
 	 * scheduled from this point because efx_stop_all() has been
@@ -1985,7 +2304,7 @@ out:
 
 	pci_set_drvdata(pci_dev, NULL);
 	efx_fini_struct(efx);
-	free_netdev(efx->net_dev);
+	kfree(efx);
 };
 
 /* Main body of NIC initialisation
@@ -2000,6 +2319,7 @@ static int efx_pci_probe_main(struct efx
 	if (rc)
 		goto fail1;
 
+	/* Initialise port/channel net_dev's  */
 	rc = efx_init_napi(efx);
 	if (rc)
 		goto fail2;
@@ -2011,18 +2331,21 @@ static int efx_pci_probe_main(struct efx
 		goto fail3;
 	}
 
+	/* Initialise device */
 	rc = falcon_init_nic(efx);
 	if (rc) {
 		EFX_ERR(efx, "failed to initialise NIC\n");
 		goto fail4;
 	}
 
+	/* Initialise port */
 	rc = efx_init_port(efx);
 	if (rc) {
 		EFX_ERR(efx, "failed to initialise port\n");
 		goto fail5;
 	}
 
+	/* Initialise channels */
 	rc = efx_init_channels(efx);
 	if (rc)
 		goto fail6;
@@ -2031,14 +2354,30 @@ static int efx_pci_probe_main(struct efx
 	if (rc)
 		goto fail7;
 
+	/* Start up device - interrupts can occur from this point */
+	efx_start_all(efx);
+
+	/* Check basic functionality and set interrupt mode */
+	rc = efx_run_selftests(efx);
+	if (rc)
+		goto fail8;
+
+	/* Stop the NIC */
+	efx_stop_all(efx);
+
 	return 0;
 
+ fail8:
+	efx_stop_all(efx);
+	falcon_fini_interrupt(efx);
  fail7:
 	efx_fini_channels(efx);
  fail6:
 	efx_fini_port(efx);
  fail5:
+	falcon_fini_nic(efx);
  fail4:
+	efx->board_info.fini(efx);
  fail3:
 	efx_fini_napi(efx);
  fail2:
@@ -2059,31 +2398,27 @@ static int efx_pci_probe_main(struct efx
 static int __devinit efx_pci_probe(struct pci_dev *pci_dev,
 				   const struct pci_device_id *entry)
 {
-	struct efx_nic_type *type = (struct efx_nic_type *) entry->driver_data;
-	struct net_device *net_dev;
 	struct efx_nic *efx;
+	struct efx_nic_type *type = (struct efx_nic_type *) entry->driver_data;
 	int i, rc;
 
-	/* Allocate and initialise a struct net_device and struct efx_nic */
-	net_dev = alloc_etherdev(sizeof(*efx));
-	if (!net_dev)
-		return -ENOMEM;
-	net_dev->features |= (NETIF_F_IP_CSUM | NETIF_F_SG |
-			      NETIF_F_HIGHDMA | NETIF_F_TSO);
-	if (lro)
-		net_dev->features |= NETIF_F_LRO;
-	efx = net_dev->priv;
+	/* Allocate and initialise a struct efx_nic */
+	efx = kmalloc(sizeof(*efx), GFP_KERNEL);
+	if (!efx) {
+		rc = -ENOMEM;
+		goto fail1;
+	}
 	pci_set_drvdata(pci_dev, efx);
-	rc = efx_init_struct(efx, type, pci_dev, net_dev);
+	rc = efx_init_struct(efx, type, pci_dev);
 	if (rc)
-		goto fail1;
+		goto fail2;
 
 	EFX_INFO(efx, "Solarflare Communications NIC detected\n");
 
 	/* Set up basic I/O (BAR mappings etc) */
 	rc = efx_init_io(efx);
 	if (rc)
-		goto fail2;
+		goto fail3;
 
 	/* No serialisation is required with the reset path because
 	 * we're in STATE_INIT. */
@@ -2101,16 +2436,21 @@ static int __devinit efx_pci_probe(struc
 		/* Retry if a recoverably reset event has been scheduled */
 		if ((efx->reset_pending != RESET_TYPE_INVISIBLE) &&
 		    (efx->reset_pending != RESET_TYPE_ALL))
-			goto fail3;
+			goto fail4;
 
 		efx->reset_pending = RESET_TYPE_NONE;
 	}
 
 	if (rc) {
 		EFX_ERR(efx, "Could not reset NIC\n");
-		goto fail4;
+		goto fail5;
 	}
 
+	/* Self-tests have all passed */
+	rc = efx_init_debugfs_channels(efx);
+	if (rc)
+		goto fail6;
+
 	/* Switch to the running state before we expose the device to
 	 * the OS.  This is to ensure that the initial gathering of
 	 * MAC stats succeeds. */
@@ -2120,25 +2460,36 @@ static int __devinit efx_pci_probe(struc
 
 	rc = efx_register_netdev(efx);
 	if (rc)
-		goto fail5;
+		goto fail7;
 
 	EFX_LOG(efx, "initialisation successful\n");
 
+	/* Register with driverlink layer */
+	rc = efx_dl_register_nic(efx);
+	if (rc)
+		goto fail8;
+
 	return 0;
 
- fail5:
+ fail8:
+	efx_unregister_netdev(efx);
+ fail7:
+	efx_fini_debugfs_channels(efx);
+ fail6:
 	efx_pci_remove_main(efx);
+ fail5:
  fail4:
- fail3:
 	efx_fini_io(efx);
- fail2:
+ fail3:
 	efx_fini_struct(efx);
+ fail2:
+	kfree(efx);
  fail1:
 	EFX_LOG(efx, "initialisation failed. rc=%d\n", rc);
-	free_netdev(net_dev);
 	return rc;
 }
 
+/* PCI driver definition */
 static struct pci_driver efx_pci_driver = {
 	.name		= EFX_DRIVER_NAME,
 	.id_table	= efx_pci_table,
@@ -2156,12 +2507,19 @@ module_param(interrupt_mode, uint, 0444)
 MODULE_PARM_DESC(interrupt_mode,
 		 "Interrupt mode (0=>MSIX 1=>MSI 2=>legacy)");
 
+module_param(onload_offline_selftest, uint, 0444);
+MODULE_PARM_DESC(onload_offline_selftest, "Perform offline selftest on load");
+
 static int __init efx_init_module(void)
 {
 	int rc;
 
 	printk(KERN_INFO "Solarflare NET driver v" EFX_DRIVER_VERSION "\n");
 
+	rc = efx_init_debugfs();
+	if (rc)
+		goto err_debugfs;
+
 	rc = register_netdevice_notifier(&efx_netdev_notifier);
 	if (rc)
 		goto err_notifier;
@@ -2183,6 +2541,8 @@ static int __init efx_init_module(void)
  err_refill:
 	unregister_netdevice_notifier(&efx_netdev_notifier);
  err_notifier:
+	efx_fini_debugfs();
+ err_debugfs:
 	return rc;
 }
 
@@ -2193,6 +2553,7 @@ static void __exit efx_exit_module(void)
 	pci_unregister_driver(&efx_pci_driver);
 	destroy_workqueue(refill_workqueue);
 	unregister_netdevice_notifier(&efx_netdev_notifier);
+	efx_fini_debugfs();
 
 }
 
Index: head-2008-06-18/drivers/net/sfc/efx.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/efx.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/efx.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_EFX_H
Index: head-2008-06-18/drivers/net/sfc/enum.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/enum.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/enum.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,10 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_ENUM_H
@@ -13,47 +29,53 @@
 /**
  * enum efx_loopback_mode - loopback modes
  * @LOOPBACK_NONE: no loopback
+ * @LOOPBACK_NEAR: loopback nearest to bus
+ * @LOOPBACK_MAC: loopback within MAC unspecified level
  * @LOOPBACK_XGMII: loopback within MAC at XGMII level
  * @LOOPBACK_XGXS: loopback within MAC at XGXS level
  * @LOOPBACK_XAUI: loopback within MAC at XAUI level
+ * @LOOPBACK_PHY: loopback within PHY unspecified level
  * @LOOPBACK_PHYXS: loopback within PHY at PHYXS level
  * @LOOPBACK_PCS: loopback within PHY at PCS level
  * @LOOPBACK_PMAPMD: loopback within PHY at PMAPMD level
+ * @LOOPBACK_FAR: loopback furthest from bus
  * @LOOPBACK_NETWORK: reflecting loopback (even further than furthest!)
  */
 /* Please keep in order and up-to-date w.r.t the following two #defines */
 enum efx_loopback_mode {
 	LOOPBACK_NONE = 0,
-	LOOPBACK_MAC = 1,
-	LOOPBACK_XGMII = 2,
-	LOOPBACK_XGXS = 3,
-	LOOPBACK_XAUI = 4,
-	LOOPBACK_PHY = 5,
-	LOOPBACK_PHYXS = 6,
-	LOOPBACK_PCS = 7,
-	LOOPBACK_PMAPMD = 8,
-	LOOPBACK_NETWORK = 9,
+	LOOPBACK_NEAR = 1,
+	LOOPBACK_MAC = 2,
+	LOOPBACK_XGMII = 3,
+	LOOPBACK_XGXS = 4,
+	LOOPBACK_XAUI = 5,
+	LOOPBACK_PHY = 6,
+	LOOPBACK_PHYXS = 7,
+	LOOPBACK_PCS = 8,
+	LOOPBACK_PMAPMD = 9,
+	LOOPBACK_FAR = 10,
+	LOOPBACK_NETWORK = 11,
 	LOOPBACK_MAX
 };
-
-#define LOOPBACK_TEST_MAX LOOPBACK_PMAPMD
-
-extern const char *efx_loopback_mode_names[];
-#define LOOPBACK_MODE_NAME(mode)			\
-	STRING_TABLE_LOOKUP(mode, efx_loopback_mode)
-#define LOOPBACK_MODE(efx)				\
-	LOOPBACK_MODE_NAME(efx->loopback_mode)
+#define LOOPBACK_TEST_MAX LOOPBACK_FAR
 
 /* These loopbacks occur within the controller */
 #define LOOPBACKS_10G_INTERNAL ((1 << LOOPBACK_XGMII)| \
 				(1 << LOOPBACK_XGXS) | \
 				(1 << LOOPBACK_XAUI))
 
+#define LOOPBACKS_1G_INTERNAL (1 << LOOPBACK_MAC)
+
 #define LOOPBACK_MASK(_efx)			\
 	(1 << (_efx)->loopback_mode)
 
-#define LOOPBACK_INTERNAL(_efx)						\
-	((LOOPBACKS_10G_INTERNAL & LOOPBACK_MASK(_efx)) ? 1 : 0)
+#define LOOPBACK_INTERNAL(_efx)					\
+	(((LOOPBACKS_10G_INTERNAL | LOOPBACKS_1G_INTERNAL) &	\
+	  LOOPBACK_MASK(_efx)) ? 1 : 0)
+
+#define LOOPBACK_CHANGED(_from, _to, _mask)		\
+	((LOOPBACK_MASK(_from) ^ LOOPBACK_MASK(_to)) &	\
+	 (_mask) ? 1 : 0)
 
 #define LOOPBACK_OUT_OF(_from, _to, _mask)		\
 	(((LOOPBACK_MASK(_from) & (_mask)) &&		\
Index: head-2008-06-18/drivers/net/sfc/ethtool.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/ethtool.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/ethtool.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,36 +1,40 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
 #include <linux/rtnetlink.h>
+#include <asm/uaccess.h>
 #include "net_driver.h"
 #include "selftest.h"
 #include "efx.h"
 #include "ethtool.h"
 #include "falcon.h"
 #include "gmii.h"
-#include "mac.h"
-
-const char *efx_loopback_mode_names[] = {
-	[LOOPBACK_NONE]		= "NONE",
-	[LOOPBACK_MAC]		= "MAC",
-	[LOOPBACK_XGMII]	= "XGMII",
-	[LOOPBACK_XGXS]		= "XGXS",
-	[LOOPBACK_XAUI] 	= "XAUI",
-	[LOOPBACK_PHY]		= "PHY",
-	[LOOPBACK_PHYXS]	= "PHY(XS)",
-	[LOOPBACK_PCS]	 	= "PHY(PCS)",
-	[LOOPBACK_PMAPMD]	= "PHY(PMAPMD)",
-	[LOOPBACK_NETWORK]	= "NETWORK",
-};
 
 static int efx_ethtool_set_tx_csum(struct net_device *net_dev, u32 enable);
 
@@ -94,7 +98,7 @@ static u64 efx_get_atomic_stat(void *fie
 			 unsigned int, efx_get_uint_stat)
 
 #define EFX_ETHTOOL_ATOMIC_NIC_ERROR_STAT(field)		\
-	EFX_ETHTOOL_STAT(field, nic, field,			\
+	EFX_ETHTOOL_STAT(field, nic, errors.field,		\
 			 atomic_t, efx_get_atomic_stat)
 
 #define EFX_ETHTOOL_UINT_CHANNEL_STAT(field)			\
@@ -199,7 +203,7 @@ int efx_ethtool_get_settings(struct net_
 	int rc;
 
 	mutex_lock(&efx->mac_lock);
-	rc = falcon_xmac_get_settings(efx, ecmd);
+	rc = efx->mac_op->get_settings(efx, ecmd);
 	mutex_unlock(&efx->mac_lock);
 
 	return rc;
@@ -213,7 +217,7 @@ int efx_ethtool_set_settings(struct net_
 	int rc;
 
 	mutex_lock(&efx->mac_lock);
-	rc = falcon_xmac_set_settings(efx, ecmd);
+	rc = efx->mac_op->set_settings(efx, ecmd);
 	mutex_unlock(&efx->mac_lock);
 	if (!rc)
 		efx_reconfigure_port(efx);
@@ -268,11 +272,6 @@ static void efx_fill_test(unsigned int t
 }
 
 #define EFX_PORT_NAME "port%d", 0
-#define EFX_CHANNEL_NAME(_channel) "channel%d", _channel->channel
-#define EFX_TX_QUEUE_NAME(_tx_queue) "txq%d", _tx_queue->queue
-#define EFX_RX_QUEUE_NAME(_rx_queue) "rxq%d", _rx_queue->queue
-#define EFX_LOOPBACK_NAME(_mode, _counter)			\
-	"loopback.%s." _counter, LOOPBACK_MODE_NAME(mode)
 
 /**
  * efx_fill_loopback_test - fill in a block of loopback self-test entries
@@ -282,6 +281,9 @@ static void efx_fill_test(unsigned int t
  * @test_index:		Starting index of the test
  * @strings:		Ethtool strings, or %NULL
  * @data:		Ethtool test results, or %NULL
+ *
+ * Fill in a block of loopback self-test entries.  Return new test
+ * index.
  */
 static int efx_fill_loopback_test(struct efx_nic *efx,
 				  struct efx_loopback_self_tests *lb_tests,
@@ -295,20 +297,24 @@ static int efx_fill_loopback_test(struct
 		efx_fill_test(test_index++, strings, data,
 			      &lb_tests->tx_sent[tx_queue->queue],
 			      EFX_TX_QUEUE_NAME(tx_queue),
-			      EFX_LOOPBACK_NAME(mode, "tx_sent"));
+			      "loopback.%s.tx_sent",
+			      efx_loopback_mode_names[mode]);
 		efx_fill_test(test_index++, strings, data,
 			      &lb_tests->tx_done[tx_queue->queue],
 			      EFX_TX_QUEUE_NAME(tx_queue),
-			      EFX_LOOPBACK_NAME(mode, "tx_done"));
+			      "loopback.%s.tx_done",
+			      efx_loopback_mode_names[mode]);
 	}
 	efx_fill_test(test_index++, strings, data,
 		      &lb_tests->rx_good,
 		      EFX_PORT_NAME,
-		      EFX_LOOPBACK_NAME(mode, "rx_good"));
+		      "loopback.%s.rx_good",
+		      efx_loopback_mode_names[mode]);
 	efx_fill_test(test_index++, strings, data,
 		      &lb_tests->rx_bad,
 		      EFX_PORT_NAME,
-		      EFX_LOOPBACK_NAME(mode, "rx_bad"));
+		      "loopback.%s.rx_bad",
+		      efx_loopback_mode_names[mode]);
 
 	return test_index;
 }
@@ -319,6 +325,12 @@ static int efx_fill_loopback_test(struct
  * @tests:		Efx self-test results structure, or %NULL
  * @strings:		Ethtool strings, or %NULL
  * @data:		Ethtool test results, or %NULL
+ *
+ * Get self-test number of strings, strings, and/or test results.
+ * Return number of strings (== number of test results).
+ *
+ * The reason for merging these three functions is to make sure that
+ * they can never be inconsistent.
  */
 static int efx_ethtool_fill_self_tests(struct efx_nic *efx,
 				       struct efx_self_tests *tests,
@@ -407,8 +419,8 @@ static void efx_ethtool_get_strings(stru
 }
 
 static void efx_ethtool_get_stats(struct net_device *net_dev,
-				  struct ethtool_stats *stats,
-				  u64 *data)
+				  struct ethtool_stats *stats
+				  __attribute__ ((unused)), u64 *data)
 {
 	struct efx_nic *efx = net_dev->priv;
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
@@ -468,7 +480,6 @@ static int efx_ethtool_set_tx_csum(struc
 		return rc;
 
 	efx_flush_queues(efx);
-
 	/* Our TSO requires TX checksumming, so disable TSO when
 	 * checksumming is disabled
 	 */
@@ -508,13 +519,20 @@ static void efx_ethtool_self_test(struct
 	int offline, already_up;
 	int rc;
 
+	/* Make sure we've got rtnl lock since we're playing with
+	 * interrupts, and calling efx_process_channel_now and others
+	 */
 	ASSERT_RTNL();
+
+	/* If the NIC isn't in the RUNNING state then exit */
 	if (efx->state != STATE_RUNNING) {
 		rc = -EIO;
 		goto fail1;
 	}
 
-	/* We need rx buffers and interrupts. */
+	/* Make sure the interface is up. We need interrupts, NAPI
+	 * and some RX buffers so this is helpful.  NB. The caller has
+	 * rtnl_lock so nobody else can call dev_open. */
 	already_up = (efx->net_dev->flags & IFF_UP);
 	if (!already_up) {
 		rc = dev_open(efx->net_dev);
@@ -534,15 +552,23 @@ static void efx_ethtool_self_test(struct
 
 	/* Perform offline tests only if online tests passed */
 	if (offline) {
-		/* Stop the kernel from sending packets during the test. */
+		/* Stop the kernel from sending packets during the test. The
+		 * selftest will be consistently bringing the port up and down
+		 * as it moves between loopback modes, so the watchdog timer
+		 * probably won't run anyway */
 		efx_stop_queue(efx);
+
 		rc = efx_flush_queues(efx);
-		if (!rc)
-			rc = efx_offline_test(efx, &efx_tests,
-					      efx->loopback_modes);
+		if (rc != 0)
+			goto out_offline;
+
+		rc = efx_offline_test(efx, &efx_tests,
+				      efx->loopback_modes);
+ out_offline:
 		efx_wake_queue(efx);
 	}
 
+	/* fall-thru */
  out:
 	if (!already_up)
 		dev_close(efx->net_dev);
@@ -668,7 +694,7 @@ static int efx_ethtool_set_pauseparam(st
 
 	/* Try to push the pause parameters */
 	mutex_lock(&efx->mac_lock);
-	rc = falcon_xmac_set_pause(efx, flow_control);
+	rc = efx->mac_op->set_pause(efx, flow_control);
 	mutex_unlock(&efx->mac_lock);
 
 	if (!rc)
Index: head-2008-06-18/drivers/net/sfc/ethtool.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/ethtool.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/ethtool.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005 Fen Systems Ltd.
- * Copyright 2006 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005:      Fen Systems Ltd.
+ * Copyright 2006:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_ETHTOOL_H
Index: head-2008-06-18/drivers/net/sfc/falcon.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/falcon.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/falcon.c	2008-06-18 15:52:24.000000000 +0200
@@ -1,13 +1,31 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
+#include <asm/io.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/pci.h>
@@ -25,6 +43,7 @@
 #include "mdio_10g.h"
 #include "phy.h"
 #include "boards.h"
+#include "driverlink.h"
 #include "workarounds.h"
 
 /* Falcon hardware control.
@@ -34,12 +53,28 @@
 
 /**
  * struct falcon_nic_data - Falcon NIC state
- * @next_buffer_table: First available buffer table id
+ * @tx_dc_entries: Number of entries in each TX queue descriptor cache
+ * @rx_dc_entries: Number of entries in each RX queue descriptor cache
+ * @tx_dc_base: Base address in SRAM of TX queue descriptor caches
+ * @rx_dc_base: Base address in SRAM of RX queue descriptor caches
+ * @old_loopback_mode: Previous loopback mode used in deconfigure_mac_wrapper
+ * @external_sram_cfg: Size and number of banks of external SRAM
  * @pci_dev2: The secondary PCI device if present
+ * @resources: Driverlink parameters
  */
 struct falcon_nic_data {
-	unsigned next_buffer_table;
+	unsigned tx_dc_entries;
+	unsigned rx_dc_entries;
+	unsigned tx_dc_base;
+	unsigned rx_dc_base;
+
+	enum efx_loopback_mode old_loopback_mode;
+
 	struct pci_dev *pci_dev2;
+
+	int external_sram_cfg;
+
+	struct efx_dl_falcon_resources resources;
 };
 
 /**************************************************************************
@@ -51,20 +86,15 @@ struct falcon_nic_data {
 
 static int disable_dma_stats;
 
-/* This is set to 16 for a good reason.  In summary, if larger than
- * 16, the descriptor cache holds more than a default socket
- * buffer's worth of packets (for UDP we can only have at most one
- * socket buffer's worth outstanding).  This combined with the fact
- * that we only get 1 TX event per descriptor cache means the NIC
- * goes idle.
- */
-#define TX_DC_ENTRIES 16
-#define TX_DC_ENTRIES_ORDER 0
-#define TX_DC_BASE 0x130000
-
-#define RX_DC_ENTRIES 64
-#define RX_DC_ENTRIES_ORDER 2
-#define RX_DC_BASE 0x100000
+/* Specify the size of the RX descriptor cache */
+static int descriptor_cache_size = 64;
+
+/*
+ * Override EEPROM/flash type from non-volatile configuration or GPIO;
+ * may need to be specified if bootstrapping from blank flash.
+ */
+static unsigned int eeprom_type = -1;
+static unsigned int flash_type = -1;
 
 /* RX FIFO XOFF watermark
  *
@@ -116,8 +146,17 @@ MODULE_PARM_DESC(rx_xon_thresh_bytes, "R
  **************************************************************************
  */
 
-/* DMA address mask */
-#define FALCON_DMA_MASK DMA_BIT_MASK(46)
+/* DMA address mask (up to 46-bit, avoiding compiler warnings)
+ *
+ * Note that it is possible to have a platform with 64-bit longs and
+ * 32-bit DMA addresses, or vice versa.  EFX_DMA_MASK takes care of the
+ * platform DMA mask.
+ */
+#if BITS_PER_LONG == 64
+#define FALCON_DMA_MASK EFX_DMA_MASK(0x00003fffffffffffUL)
+#else
+#define FALCON_DMA_MASK EFX_DMA_MASK(0x00003fffffffffffULL)
+#endif
 
 /* TX DMA length mask (13-bit) */
 #define FALCON_TX_DMA_MASK (4096 - 1)
@@ -136,7 +175,7 @@ MODULE_PARM_DESC(rx_xon_thresh_bytes, "R
 #define PCI_EXP_LNKSTA_LNK_WID_LBN	4
 
 #define FALCON_IS_DUAL_FUNC(efx)		\
-	(falcon_rev(efx) < FALCON_REV_B0)
+	(FALCON_REV(efx) < FALCON_REV_B0)
 
 /**************************************************************************
  *
@@ -167,6 +206,44 @@ static inline int falcon_event_present(e
 		  EFX_DWORD_IS_ALL_ONES(event->dword[1])));
 }
 
+/* Read dword from a Falcon PCIE core register */
+static void falcon_pcie_core_read_reg(struct efx_nic *efx, int address,
+				      efx_dword_t *result)
+{
+	efx_oword_t temp;
+
+	BUG_ON(FALCON_REV(efx) < FALCON_REV_B0);
+	BUG_ON(address & 3 || address < 0);
+
+	EFX_POPULATE_OWORD_1(temp, PCIE_CORE_ADDR, address);
+
+	falcon_write(efx, &temp, PCIE_CORE_INDIRECT_REG);
+	falcon_read(efx, &temp, PCIE_CORE_INDIRECT_REG);
+	/* Extract PCIE_CORE_VALUE without byte-swapping */
+	BUILD_BUG_ON(PCIE_CORE_VALUE_LBN != 32 ||
+		     PCIE_CORE_VALUE_WIDTH != 32);
+	result->u32[0] = temp.u32[1];
+}
+
+/* Write dword to a Falcon PCIE core register */
+static void falcon_pcie_core_write_reg(struct efx_nic *efx, int address,
+				       efx_dword_t value)
+{
+	efx_oword_t temp;
+
+	BUG_ON(FALCON_REV(efx) < FALCON_REV_B0);
+	BUG_ON(address & 0x3 || address < 0);
+
+	EFX_POPULATE_OWORD_2(temp,
+			     PCIE_CORE_ADDR, address,
+			     PCIE_CORE_RW, 1);
+	/* Fill PCIE_CORE_VALUE without byte-swapping */
+	BUILD_BUG_ON(PCIE_CORE_VALUE_LBN != 32 ||
+		     PCIE_CORE_VALUE_WIDTH != 32);
+	temp.u32[1] = value.u32[0];
+	falcon_write(efx, &temp, PCIE_CORE_INDIRECT_REG);
+}
+
 /**************************************************************************
  *
  * I2C bus - this is a bit-bashing interface using GPIO pins
@@ -293,6 +370,7 @@ static int falcon_alloc_special_buffer(s
 
 	len = ALIGN(len, FALCON_BUF_SIZE);
 
+	/* Allocate buffer as consistent PCI DMA space */
 	buffer->addr = pci_alloc_consistent(efx->pci_dev, len,
 					    &buffer->dma_addr);
 	if (!buffer->addr)
@@ -305,8 +383,8 @@ static int falcon_alloc_special_buffer(s
 	memset(buffer->addr, 0xff, len);
 
 	/* Select new buffer ID */
-	buffer->index = nic_data->next_buffer_table;
-	nic_data->next_buffer_table += buffer->entries;
+	buffer->index = nic_data->resources.buffer_table_min;
+	nic_data->resources.buffer_table_min += buffer->entries;
 
 	EFX_LOG(efx, "allocating special buffers %d-%d at %llx+%x "
 		"(virt %p phys %lx)\n", buffer->index,
@@ -317,6 +395,7 @@ static int falcon_alloc_special_buffer(s
 	return 0;
 }
 
+/* Release the buffer memory. */
 static void falcon_free_special_buffer(struct efx_nic *efx,
 				       struct efx_special_buffer *buffer)
 {
@@ -378,7 +457,10 @@ static inline efx_qword_t *falcon_tx_des
 	return (((efx_qword_t *) (tx_queue->txd.addr)) + index);
 }
 
-/* This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */
+/* Update TX descriptor write pointer
+ * This writes to the TX_DESC_WPTR register for the specified
+ * channel's transmit descriptor ring.
+ */
 static inline void falcon_notify_tx_desc(struct efx_tx_queue *tx_queue)
 {
 	unsigned write_ptr;
@@ -427,11 +509,22 @@ void falcon_push_buffers(struct efx_tx_q
 int falcon_probe_tx(struct efx_tx_queue *tx_queue)
 {
 	struct efx_nic *efx = tx_queue->efx;
-	return falcon_alloc_special_buffer(efx, &tx_queue->txd,
-					   FALCON_TXD_RING_SIZE *
-					   sizeof(efx_qword_t));
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	rc = falcon_alloc_special_buffer(efx, &tx_queue->txd,
+					 FALCON_TXD_RING_SIZE *
+					 sizeof(efx_qword_t));
+	if (rc)
+		return rc;
+
+	nic_data->resources.txq_min = max(nic_data->resources.txq_min,
+					  (unsigned)tx_queue->queue + 1);
+
+	return 0;
 }
 
+/* Prepare channel's TX datapath. */
 int falcon_init_tx(struct efx_tx_queue *tx_queue)
 {
 	efx_oword_t tx_desc_ptr;
@@ -453,10 +546,10 @@ int falcon_init_tx(struct efx_tx_queue *
 			      TX_DESCQ_OWNER_ID, 0,
 			      TX_DESCQ_LABEL, tx_queue->queue,
 			      TX_DESCQ_SIZE, FALCON_TXD_RING_ORDER,
-			      TX_DESCQ_TYPE, 0,
+			      TX_DESCQ_TYPE, 0,	/* kernel queue */
 			      TX_NON_IP_DROP_DIS_B0, 1);
 
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
+	if (FALCON_REV(efx) >= FALCON_REV_B0) {
 		int csum = !(efx->net_dev->features & NETIF_F_IP_CSUM);
 		EFX_SET_OWORD_FIELD(tx_desc_ptr, TX_IP_CHKSM_DIS_B0, csum);
 		EFX_SET_OWORD_FIELD(tx_desc_ptr, TX_TCP_CHKSM_DIS_B0, csum);
@@ -465,10 +558,11 @@ int falcon_init_tx(struct efx_tx_queue *
 	falcon_write_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
 			   tx_queue->queue);
 
-	if (falcon_rev(efx) < FALCON_REV_B0) {
+	if (FALCON_REV(efx) < FALCON_REV_B0) {
 		efx_oword_t reg;
 
-		BUG_ON(tx_queue->queue >= 128); /* HW limit */
+		/* Only 128 bits in this register */
+		BUG_ON(tx_queue->queue >= 128);
 
 		falcon_read(efx, &reg, TX_CHKSM_CFG_REG_KER_A1);
 		if (efx->net_dev->features & NETIF_F_IP_CSUM)
@@ -567,14 +661,18 @@ void falcon_remove_tx(struct efx_tx_queu
  *
  **************************************************************************/
 
-/* Returns a pointer to the specified descriptor in the RX descriptor queue */
+/* Returns a pointer to the specified transmit descriptor in the RX
+ * descriptor queue.
+ */
 static inline efx_qword_t *falcon_rx_desc(struct efx_rx_queue *rx_queue,
 					       unsigned int index)
 {
 	return (((efx_qword_t *) (rx_queue->rxd.addr)) + index);
 }
 
-/* This creates an entry in the RX descriptor queue */
+/* This creates an entry in the RX descriptor queue corresponding to
+ * the receive buffer.
+ */
 static inline void falcon_build_rx_desc(struct efx_rx_queue *rx_queue,
 					unsigned index)
 {
@@ -616,9 +714,20 @@ void falcon_notify_rx_desc(struct efx_rx
 int falcon_probe_rx(struct efx_rx_queue *rx_queue)
 {
 	struct efx_nic *efx = rx_queue->efx;
-	return falcon_alloc_special_buffer(efx, &rx_queue->rxd,
-					   FALCON_RXD_RING_SIZE *
-					   sizeof(efx_qword_t));
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	rc = falcon_alloc_special_buffer(efx, &rx_queue->rxd,
+					 FALCON_RXD_RING_SIZE *
+					 sizeof(efx_qword_t));
+	if (rc)
+		return rc;
+
+	/* Increment the rxq_min counter */
+	nic_data->resources.rxq_min = max(nic_data->resources.rxq_min,
+					  (unsigned)rx_queue->queue + 1);
+
+	return 0;
 }
 
 int falcon_init_rx(struct efx_rx_queue *rx_queue)
@@ -626,7 +735,7 @@ int falcon_init_rx(struct efx_rx_queue *
 	efx_oword_t rx_desc_ptr;
 	struct efx_nic *efx = rx_queue->efx;
 	int rc;
-	int is_b0 = falcon_rev(efx) >= FALCON_REV_B0;
+	int is_b0 = FALCON_REV(efx) >= FALCON_REV_B0;
 	int iscsi_digest_en = is_b0;
 
 	EFX_LOG(efx, "RX queue %d ring in special buffers %d-%d\n",
@@ -667,6 +776,7 @@ static int falcon_flush_rx_queue(struct 
 	EFX_POPULATE_OWORD_2(rx_flush_descq,
 			     RX_FLUSH_DESCQ_CMD, 1,
 			     RX_FLUSH_DESCQ, rx_queue->queue);
+
 	falcon_write(efx, &rx_flush_descq, RX_FLUSH_DESCQ_REG_KER);
 	msleep(FALCON_FLUSH_TIMEOUT);
 
@@ -733,10 +843,8 @@ void falcon_fini_rx(struct efx_rx_queue 
 			continue;
 		break;
 	}
-	if (rc) {
+	if (rc)
 		EFX_ERR(efx, "failed to flush rx queue %d\n", rx_queue->queue);
-		efx_schedule_reset(efx, RESET_TYPE_INVISIBLE);
-	}
 
 	/* Remove RX descriptor ring from card */
 	EFX_ZERO_OWORD(rx_desc_ptr);
@@ -877,7 +985,7 @@ static void falcon_handle_rx_not_ok(stru
 						   RX_EV_TCP_UDP_CHKSUM_ERR);
 	rx_ev_eth_crc_err = EFX_QWORD_FIELD(*event, RX_EV_ETH_CRC_ERR);
 	rx_ev_frm_trunc = EFX_QWORD_FIELD(*event, RX_EV_FRM_TRUNC);
-	rx_ev_drib_nib = ((falcon_rev(efx) >= FALCON_REV_B0) ?
+	rx_ev_drib_nib = ((FALCON_REV(efx) >= FALCON_REV_B0) ?
 			  0 : EFX_QWORD_FIELD(*event, RX_EV_DRIB_NIB));
 	rx_ev_pause_frm = EFX_QWORD_FIELD(*event, RX_EV_PAUSE_FRM_ERR);
 
@@ -965,6 +1073,7 @@ static void falcon_handle_rx_not_ok(stru
 		tenxpress_crc_err(efx);
 }
 
+
 /* Handle receive events that are not in-order. */
 static void falcon_handle_rx_bad_index(struct efx_rx_queue *rx_queue,
 				       unsigned index)
@@ -978,10 +1087,12 @@ static void falcon_handle_rx_bad_index(s
 	EFX_INFO(efx, "dropped %d events (index=%d expected=%d)\n",
 		dropped, index, expected);
 
+	atomic_inc(&efx->errors.missing_event);
 	efx_schedule_reset(efx, EFX_WORKAROUND_5676(efx) ?
 			   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
 }
 
+
 /* Handle a packet received event
  *
  * Falcon silicon gives a "discard" flag if it's a unicast packet with the
@@ -1058,7 +1169,7 @@ static void falcon_handle_global_event(s
 	    EFX_QWORD_FIELD(*event, XG_PHY_INTR))
 		is_phy_event = 1;
 
-	if ((falcon_rev(efx) >= FALCON_REV_B0) &&
+	if ((FALCON_REV(efx) >= FALCON_REV_B0) &&
 	    EFX_OWORD_FIELD(*event, XG_MNT_INTR_B0))
 		is_phy_event = 1;
 
@@ -1072,7 +1183,7 @@ static void falcon_handle_global_event(s
 		EFX_ERR(efx, "channel %d seen global RX_RESET "
 			"event. Resetting.\n", channel->channel);
 
-		atomic_inc(&efx->rx_reset);
+		atomic_inc(&efx->errors.rx_reset);
 		efx_schedule_reset(efx, EFX_WORKAROUND_6555(efx) ?
 				   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
 		handled = 1;
@@ -1098,10 +1209,12 @@ static void falcon_handle_driver_event(s
 	case TX_DESCQ_FLS_DONE_EV_DECODE:
 		EFX_TRACE(efx, "channel %d TXQ %d flushed\n",
 			  channel->channel, ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
 		break;
 	case RX_DESCQ_FLS_DONE_EV_DECODE:
 		EFX_TRACE(efx, "channel %d RXQ %d flushed\n",
 			  channel->channel, ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
 		break;
 	case EVQ_INIT_DONE_EV_DECODE:
 		EFX_LOG(efx, "channel %d EVQ %d initialised\n",
@@ -1110,19 +1223,23 @@ static void falcon_handle_driver_event(s
 	case SRM_UPD_DONE_EV_DECODE:
 		EFX_TRACE(efx, "channel %d SRAM update done\n",
 			  channel->channel);
+		EFX_DL_CALLBACK(efx, event, event);
 		break;
 	case WAKE_UP_EV_DECODE:
 		EFX_TRACE(efx, "channel %d RXQ %d wakeup event\n",
 			  channel->channel, ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
 		break;
 	case TIMER_EV_DECODE:
 		EFX_TRACE(efx, "channel %d RX queue %d timer expired\n",
 			  channel->channel, ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
 		break;
 	case RX_RECOVERY_EV_DECODE:
 		EFX_ERR(efx, "channel %d seen DRIVER RX_RESET event. "
 			"Resetting.\n", channel->channel);
-		atomic_inc(&efx->rx_reset);
+
+		atomic_inc(&efx->errors.rx_reset);
 		efx_schedule_reset(efx,
 				   EFX_WORKAROUND_6555(efx) ?
 				   RESET_TYPE_RX_RECOVERY :
@@ -1131,17 +1248,20 @@ static void falcon_handle_driver_event(s
 	case RX_DSC_ERROR_EV_DECODE:
 		EFX_ERR(efx, "RX DMA Q %d reports descriptor fetch error."
 			" RX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
+		atomic_inc(&efx->errors.rx_desc_fetch);
 		efx_schedule_reset(efx, RESET_TYPE_RX_DESC_FETCH);
 		break;
 	case TX_DSC_ERROR_EV_DECODE:
 		EFX_ERR(efx, "TX DMA Q %d reports descriptor fetch error."
 			" TX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
+		atomic_inc(&efx->errors.tx_desc_fetch);
 		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
 		break;
 	default:
 		EFX_TRACE(efx, "channel %d unknown driver event code %d "
 			  "data %04x\n", channel->channel, ev_sub_code,
 			  ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
 		break;
 	}
 }
@@ -1242,10 +1362,19 @@ void falcon_set_int_moderation(struct ef
 int falcon_probe_eventq(struct efx_channel *channel)
 {
 	struct efx_nic *efx = channel->efx;
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	unsigned int evq_size;
+	int rc;
 
 	evq_size = FALCON_EVQ_SIZE * sizeof(efx_qword_t);
-	return falcon_alloc_special_buffer(efx, &channel->eventq, evq_size);
+	rc = falcon_alloc_special_buffer(efx, &channel->eventq, evq_size);
+	if (rc)
+		return rc;
+
+	nic_data->resources.evq_int_min = max(nic_data->resources.evq_int_min,
+					      (unsigned)channel->evqnum + 1);
+
+	return 0;
 }
 
 int falcon_init_eventq(struct efx_channel *channel)
@@ -1340,10 +1469,11 @@ void falcon_enable_interrupts(struct efx
 	efx_oword_t int_adr_reg_ker;
 	struct efx_channel *channel;
 
+	/* Zero INT_KER */
 	EFX_ZERO_OWORD(*((efx_oword_t *) efx->irq_status.addr));
 	wmb(); /* Ensure interrupt vector is clear before interrupts enabled */
 
-	/* Program address */
+	/* Program INT_ADR_KER_REG */
 	EFX_POPULATE_OWORD_2(int_adr_reg_ker,
 			     NORM_INT_VEC_DIS_KER, EFX_INT_MODE_USE_MSI(efx),
 			     INT_ADR_KER, efx->irq_status.dma_addr);
@@ -1398,7 +1528,7 @@ static inline void falcon_irq_ack_a1(str
 static irqreturn_t falcon_fatal_interrupt(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
-	efx_oword_t *int_ker = efx->irq_status.addr;
+	efx_oword_t *int_ker = (efx_oword_t *) efx->irq_status.addr;
 	efx_oword_t fatal_intr;
 	int error, mem_perr;
 	static int n_int_errors;
@@ -1441,11 +1571,15 @@ out:
 
 /* Handle a legacy interrupt from Falcon
  * Acknowledges the interrupt and schedule event queue processing.
+ *
+ * This routine must guarantee not to touch the hardware when
+ * interrupts are disabled, to allow for correct semantics of
+ * efx_suspend() and efx_resume().
  */
 static irqreturn_t falcon_legacy_interrupt_b0(int irq, void *dev_id)
 {
-	struct efx_nic *efx = dev_id;
-	efx_oword_t *int_ker = efx->irq_status.addr;
+	struct efx_nic *efx = (struct efx_nic *)dev_id;
+	efx_oword_t *int_ker = (efx_oword_t *) efx->irq_status.addr;
 	struct efx_channel *channel;
 	efx_dword_t reg;
 	u32 queues;
@@ -1482,8 +1616,8 @@ static irqreturn_t falcon_legacy_interru
 
 static irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)
 {
-	struct efx_nic *efx = dev_id;
-	efx_oword_t *int_ker = efx->irq_status.addr;
+	struct efx_nic *efx = (struct efx_nic *)dev_id;
+	efx_oword_t *int_ker = (efx_oword_t *) efx->irq_status.addr;
 	struct efx_channel *channel;
 	int syserr;
 	int queues;
@@ -1532,12 +1666,16 @@ static irqreturn_t falcon_legacy_interru
  * queue processing.  No interrupt acknowledgement cycle is necessary.
  * Also, we never need to check that the interrupt is for us, since
  * MSI interrupts cannot be shared.
+ *
+ * This routine must guarantee not to touch the hardware when
+ * interrupts are disabled, to allow for correct semantics of
+ * efx_suspend() and efx_resume().
  */
 static irqreturn_t falcon_msi_interrupt(int irq, void *dev_id)
 {
-	struct efx_channel *channel = dev_id;
+	struct efx_channel *channel = (struct efx_channel *)dev_id;
 	struct efx_nic *efx = channel->efx;
-	efx_oword_t *int_ker = efx->irq_status.addr;
+	efx_oword_t *int_ker = (efx_oword_t *) efx->irq_status.addr;
 	int syserr;
 
 	efx->last_irq_cpu = raw_smp_processor_id();
@@ -1565,7 +1703,7 @@ static void falcon_setup_rss_indir_table
 	unsigned long offset;
 	efx_dword_t dword;
 
-	if (falcon_rev(efx) < FALCON_REV_B0)
+	if (FALCON_REV(efx) < FALCON_REV_B0)
 		return;
 
 	for (offset = RX_RSS_INDIR_TBL_B0;
@@ -1588,7 +1726,7 @@ int falcon_init_interrupt(struct efx_nic
 
 	if (!EFX_INT_MODE_USE_MSI(efx)) {
 		irq_handler_t handler;
-		if (falcon_rev(efx) >= FALCON_REV_B0)
+		if (FALCON_REV(efx) >= FALCON_REV_B0)
 			handler = falcon_legacy_interrupt_b0;
 		else
 			handler = falcon_legacy_interrupt_a1;
@@ -1629,13 +1767,12 @@ void falcon_fini_interrupt(struct efx_ni
 	efx_oword_t reg;
 
 	/* Disable MSI/MSI-X interrupts */
-	efx_for_each_channel_with_interrupt(channel, efx) {
+	efx_for_each_channel_with_interrupt(channel, efx)
 		if (channel->irq)
 			free_irq(channel->irq, channel);
-	}
 
 	/* ACK legacy interrupt */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
+	if (FALCON_REV(efx) >= FALCON_REV_B0)
 		falcon_read(efx, &reg, INT_ISR0_B0);
 	else
 		falcon_irq_ack_a1(efx);
@@ -1652,8 +1789,6 @@ void falcon_fini_interrupt(struct efx_ni
  **************************************************************************
  */
 
-#define FALCON_SPI_MAX_LEN sizeof(efx_oword_t)
-
 /* Wait for SPI command completion */
 static int falcon_spi_wait(struct efx_nic *efx)
 {
@@ -1675,44 +1810,115 @@ static int falcon_spi_wait(struct efx_ni
 }
 
 static int
-falcon_spi_read(struct efx_nic *efx, int device_id, unsigned int command,
-		unsigned int address, unsigned int addr_len,
-		void *data, unsigned int len)
+falcon_spi_read(const struct efx_spi_device *spi, struct efx_nic *efx,
+		unsigned int command, int address, void *data, unsigned int len)
 {
+	int addressed = (address >= 0);
 	efx_oword_t reg;
 	int rc;
 
-	BUG_ON(len > FALCON_SPI_MAX_LEN);
+	/* Input validation */
+	if (len > FALCON_SPI_MAX_LEN)
+		return -EINVAL;
+
+	/* Acquire SPI lock */
+	mutex_lock(&efx->spi_lock);
 
 	/* Check SPI not currently being accessed */
 	rc = falcon_spi_wait(efx);
 	if (rc)
-		return rc;
+		goto out;
 
-	/* Program address register */
-	EFX_POPULATE_OWORD_1(reg, EE_SPI_HADR_ADR, address);
-	falcon_write(efx, &reg, EE_SPI_HADR_REG_KER);
+	/* Program address register, if we have an address */
+	if (addressed) {
+		EFX_POPULATE_OWORD_1(reg, EE_SPI_HADR_ADR, address);
+		falcon_write(efx, &reg, EE_SPI_HADR_REG_KER);
+	}
 
 	/* Issue read command */
 	EFX_POPULATE_OWORD_7(reg,
 			     EE_SPI_HCMD_CMD_EN, 1,
-			     EE_SPI_HCMD_SF_SEL, device_id,
+			     EE_SPI_HCMD_SF_SEL, spi->device_id,
 			     EE_SPI_HCMD_DABCNT, len,
 			     EE_SPI_HCMD_READ, EE_SPI_READ,
 			     EE_SPI_HCMD_DUBCNT, 0,
-			     EE_SPI_HCMD_ADBCNT, addr_len,
+			     EE_SPI_HCMD_ADBCNT,
+			     (addressed ? spi->addr_len : 0),
 			     EE_SPI_HCMD_ENC, command);
 	falcon_write(efx, &reg, EE_SPI_HCMD_REG_KER);
 
 	/* Wait for read to complete */
 	rc = falcon_spi_wait(efx);
 	if (rc)
-		return rc;
+		goto out;
 
 	/* Read data */
 	falcon_read(efx, &reg, EE_SPI_HDATA_REG_KER);
 	memcpy(data, &reg, len);
-	return 0;
+
+ out:
+	/* Release SPI lock */
+	mutex_unlock(&efx->spi_lock);
+
+	return rc;
+}
+
+static int
+falcon_spi_write(const struct efx_spi_device *spi, struct efx_nic *efx,
+		 unsigned int command, int address, const void *data,
+		 unsigned int len)
+{
+	int addressed = (address >= 0);
+	efx_oword_t reg;
+	int rc;
+
+	/* Input validation */
+	if (len > (addressed ? efx_spi_write_limit(spi, address)
+		   : FALCON_SPI_MAX_LEN))
+		return -EINVAL;
+
+	/* Acquire SPI lock */
+	mutex_lock(&efx->spi_lock);
+
+	/* Check SPI not currently being accessed */
+	rc = falcon_spi_wait(efx);
+	if (rc)
+		goto out;
+
+	/* Program address register, if we have an address */
+	if (addressed) {
+		EFX_POPULATE_OWORD_1(reg, EE_SPI_HADR_ADR, address);
+		falcon_write(efx, &reg, EE_SPI_HADR_REG_KER);
+	}
+
+	/* Program data register, if we have data */
+	if (data) {
+		memcpy(&reg, data, len);
+		falcon_write(efx, &reg, EE_SPI_HDATA_REG_KER);
+	}
+
+	/* Issue write command */
+	EFX_POPULATE_OWORD_7(reg,
+			     EE_SPI_HCMD_CMD_EN, 1,
+			     EE_SPI_HCMD_SF_SEL, spi->device_id,
+			     EE_SPI_HCMD_DABCNT, len,
+			     EE_SPI_HCMD_READ, EE_SPI_WRITE,
+			     EE_SPI_HCMD_DUBCNT, 0,
+			     EE_SPI_HCMD_ADBCNT,
+			     (addressed ? spi->addr_len : 0),
+			     EE_SPI_HCMD_ENC, command);
+	falcon_write(efx, &reg, EE_SPI_HCMD_REG_KER);
+
+	/* Wait for write to complete */
+	rc = falcon_spi_wait(efx);
+	if (rc)
+		goto out;
+
+ out:
+	/* Release SPI lock */
+	mutex_unlock(&efx->spi_lock);
+
+	return rc;
 }
 
 /**************************************************************************
@@ -1726,8 +1932,7 @@ void falcon_drain_tx_fifo(struct efx_nic
 	efx_oword_t temp;
 	int count;
 
-	if ((falcon_rev(efx) < FALCON_REV_B0) ||
-	    (efx->loopback_mode != LOOPBACK_NONE))
+	if (FALCON_REV(efx) < FALCON_REV_B0)
 		return;
 
 	falcon_read(efx, &temp, MAC0_CTRL_REG_KER);
@@ -1771,15 +1976,17 @@ void falcon_drain_tx_fifo(struct efx_nic
 
 	/* If we've reset the EM block and the link is up, then
 	 * we'll have to kick the XAUI link so the PHY can recover */
-	if (efx->link_up && EFX_WORKAROUND_5147(efx))
+	if (efx->link_up && EFX_IS10G(efx) && EFX_WORKAROUND_5147(efx))
 		falcon_reset_xaui(efx);
 }
 
 void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t temp;
+	int changing_loopback;
 
-	if (falcon_rev(efx) < FALCON_REV_B0)
+	if (FALCON_REV(efx) < FALCON_REV_B0)
 		return;
 
 	/* Isolate the MAC -> RX */
@@ -1787,7 +1994,17 @@ void falcon_deconfigure_mac_wrapper(stru
 	EFX_SET_OWORD_FIELD(temp, RX_INGR_EN_B0, 0);
 	falcon_write(efx, &temp, RX_CFG_REG_KER);
 
-	if (!efx->link_up)
+	/* Synchronise the EM block against any loopback mode changes by
+	 * draining the TX fifo and resetting. */
+	changing_loopback = (efx->loopback_mode != nic_data->old_loopback_mode);
+	nic_data->old_loopback_mode = efx->loopback_mode;
+
+	if (EFX_WORKAROUND_11667(efx) && (efx->phy_type == PHY_TYPE_10XPRESS)) {
+		if (changing_loopback)
+			return;
+	}
+
+	if (changing_loopback || !efx->link_up)
 		falcon_drain_tx_fifo(efx);
 }
 
@@ -1817,7 +2034,7 @@ void falcon_reconfigure_mac_wrapper(stru
 			     MAC_SPEED, link_speed);
 	/* On B0, MAC backpressure can be disabled and packets get
 	 * discarded. */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
+	if (FALCON_REV(efx) >= FALCON_REV_B0) {
 		EFX_SET_OWORD_FIELD(reg, TXFIFO_DRAIN_EN_B0,
 				    !efx->link_up);
 	}
@@ -1835,7 +2052,7 @@ void falcon_reconfigure_mac_wrapper(stru
 	EFX_SET_OWORD_FIELD_VER(efx, reg, RX_XOFF_MAC_EN, tx_fc);
 
 	/* Unisolate the MAC -> RX */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
+	if (FALCON_REV(efx) >= FALCON_REV_B0)
 		EFX_SET_OWORD_FIELD(reg, RX_INGR_EN_B0, 1);
 	falcon_write(efx, &reg, RX_CFG_REG_KER);
 }
@@ -1850,13 +2067,14 @@ int falcon_dma_stats(struct efx_nic *efx
 		return 0;
 
 	/* Statistics fetch will fail if the MAC is in TX drain */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
+	if (FALCON_REV(efx) >= FALCON_REV_B0) {
 		efx_oword_t temp;
 		falcon_read(efx, &temp, MAC0_CTRL_REG_KER);
 		if (EFX_OWORD_FIELD(temp, TXFIFO_DRAIN_EN_B0))
 			return 0;
 	}
 
+	/* Clear completion pointer */
 	dma_done = (efx->stats_buffer.addr + done_offset);
 	*dma_done = FALCON_STATS_NOT_DONE;
 	wmb(); /* ensure done flag is clear */
@@ -1875,7 +2093,13 @@ int falcon_dma_stats(struct efx_nic *efx
 		udelay(10);
 	}
 
-	EFX_ERR(efx, "timed out waiting for statistics\n");
+	if (EFX_WORKAROUND_8419(efx)) {
+		disable_dma_stats = 1;
+		EFX_INFO(efx, "MAC stats DMA disabled\n");
+	} else {
+		EFX_ERR(efx, "timed out waiting for statistics\n");
+	}
+
 	return -ETIMEDOUT;
 }
 
@@ -1934,8 +2158,9 @@ static int falcon_gmii_wait(struct efx_n
 static void falcon_mdio_write(struct net_device *net_dev, int phy_id,
 			      int addr, int value)
 {
-	struct efx_nic *efx = net_dev->priv;
+	struct efx_nic *efx = (struct efx_nic *)net_dev->priv;
 	unsigned int phy_id2 = phy_id & FALCON_PHY_ID_ID_MASK;
+	unsigned int phy_10g = phy_id & FALCON_PHY_ID_10G;
 	efx_oword_t reg;
 
 	/* The 'generic' prt/dev packing in mdio_10g.h is conveniently
@@ -1952,16 +2177,18 @@ static void falcon_mdio_write(struct net
 		return;
 
 	/* See falcon_mdio_read for an explanation. */
-	if (!(phy_id & FALCON_PHY_ID_10G)) {
+	if (EFX_ISCLAUSE45(efx) && !phy_10g) {
 		int mmd = ffs(efx->phy_op->mmds) - 1;
 		EFX_TRACE(efx, "Fixing erroneous clause22 write\n");
 		phy_id2 = mdio_clause45_pack(phy_id2, mmd)
 			& FALCON_PHY_ID_ID_MASK;
+		phy_10g = 1;
 	}
 
 	EFX_REGDUMP(efx, "writing GMII %d register %02x with %04x\n", phy_id,
 		    addr, value);
 
+	/* Obtain PHY lock */
 	spin_lock_bh(&efx->phy_lock);
 
 	/* Check MII not currently being accessed */
@@ -1972,7 +2199,13 @@ static void falcon_mdio_write(struct net
 	EFX_POPULATE_OWORD_1(reg, MD_PHY_ADR, addr);
 	falcon_write(efx, &reg, MD_PHY_ADR_REG_KER);
 
-	EFX_POPULATE_OWORD_1(reg, MD_PRT_DEV_ADR, phy_id2);
+	if (phy_10g)
+		EFX_POPULATE_OWORD_1(reg, MD_PRT_DEV_ADR, phy_id2);
+	else
+		/* MDIO clause 22 */
+		EFX_POPULATE_OWORD_2(reg,
+				     MD_PRT_ADR, phy_id2,
+				     MD_DEV_ADR, addr);
 	falcon_write(efx, &reg, MD_ID_REG_KER);
 
 	/* Write data */
@@ -1981,7 +2214,7 @@ static void falcon_mdio_write(struct net
 
 	EFX_POPULATE_OWORD_2(reg,
 			     MD_WRC, 1,
-			     MD_GC, 0);
+			     MD_GC, (phy_10g ? 0 : 1));
 	falcon_write(efx, &reg, MD_CS_REG_KER);
 
 	/* Wait for data to be written */
@@ -1995,6 +2228,7 @@ static void falcon_mdio_write(struct net
 	}
 
  out:
+	/* Release PHY lock */
 	spin_unlock_bh(&efx->phy_lock);
 }
 
@@ -2002,8 +2236,9 @@ static void falcon_mdio_write(struct net
  * could be read, -1 will be returned. */
 static int falcon_mdio_read(struct net_device *net_dev, int phy_id, int addr)
 {
-	struct efx_nic *efx = net_dev->priv;
+	struct efx_nic *efx = (struct efx_nic *)net_dev->priv;
 	unsigned int phy_addr = phy_id & FALCON_PHY_ID_ID_MASK;
+	unsigned int phy_10g = phy_id & FALCON_PHY_ID_10G;
 	efx_oword_t reg;
 	int value = -1;
 
@@ -2018,27 +2253,43 @@ static int falcon_mdio_read(struct net_d
 	 * request. This is enough to allow simple queries like id and link
 	 * state to succeed. TODO: We may need to do more in future.
 	 */
-	if (!(phy_id & FALCON_PHY_ID_10G)) {
+	if (EFX_ISCLAUSE45(efx) && !phy_10g) {
 		int mmd = ffs(efx->phy_op->mmds) - 1;
 		EFX_TRACE(efx, "Fixing erroneous clause22 read\n");
 		phy_addr = mdio_clause45_pack(phy_addr, mmd)
 			& FALCON_PHY_ID_ID_MASK;
+		phy_10g = 1;
 	}
 
+	/* Obtain PHY lock */
 	spin_lock_bh(&efx->phy_lock);
 
 	/* Check MII not currently being accessed */
 	if (falcon_gmii_wait(efx) != 0)
 		goto out;
 
-	EFX_POPULATE_OWORD_1(reg, MD_PHY_ADR, addr);
-	falcon_write(efx, &reg, MD_PHY_ADR_REG_KER);
+	if (!phy_10g) {
+		/* Write the address registers */
+		EFX_POPULATE_OWORD_2(reg,
+				     MD_PRT_ADR, phy_addr,
+				     MD_DEV_ADR, addr);
+		falcon_write(efx, &reg, MD_ID_REG_KER);
+		/* Request data to be read */
+		EFX_POPULATE_OWORD_2(reg,
+				     MD_RIC, 1,
+				     MD_GC, 1);
+	} else {
+		EFX_POPULATE_OWORD_1(reg, MD_PHY_ADR, addr);
+		falcon_write(efx, &reg, MD_PHY_ADR_REG_KER);
 
-	EFX_POPULATE_OWORD_1(reg, MD_PRT_DEV_ADR, phy_addr);
-	falcon_write(efx, &reg, MD_ID_REG_KER);
+		EFX_POPULATE_OWORD_1(reg, MD_PRT_DEV_ADR, phy_addr);
+		falcon_write(efx, &reg, MD_ID_REG_KER);
 
-	/* Request data to be read */
-	EFX_POPULATE_OWORD_2(reg, MD_RDC, 1, MD_GC, 0);
+		/* Request data to be read */
+		EFX_POPULATE_OWORD_2(reg,
+				     MD_RDC, 1,
+				     MD_GC, 0);
+	}
 	falcon_write(efx, &reg, MD_CS_REG_KER);
 
 	/* Wait for data to become available */
@@ -2060,6 +2311,7 @@ static int falcon_mdio_read(struct net_d
 	}
 
  out:
+	/* Release PHY lock */
 	spin_unlock_bh(&efx->phy_lock);
 
 	return value;
@@ -2073,22 +2325,61 @@ static void falcon_init_mdio(struct mii_
 	gmii->reg_num_mask = ((1 << EFX_WIDTH(MD_PHY_ADR)) - 1);
 }
 
+static int falcon_probe_gmac_port(struct efx_nic *efx)
+{
+	struct efx_phy_operations *phy_op = efx->phy_op;
+
+	efx->mac_op = &falcon_gmac_operations;
+	efx->loopback_modes = LOOPBACKS_1G_INTERNAL | phy_op->loopbacks;
+	efx->startup_loopbacks = ((1 << LOOPBACK_MAC) |
+				  (1 << phy_op->startup_loopback));
+	return 0;
+}
+
+static int falcon_probe_xmac_port(struct efx_nic *efx)
+{
+	struct efx_phy_operations *phy_op = efx->phy_op;
+
+	efx->mac_op = &falcon_xmac_operations;
+
+	/* The Falcon B0 FPGA only supports XGMII loopback */
+	if (FALCON_REV(efx) >= FALCON_REV_B0 && !efx->is_asic)
+		efx->loopback_modes = (1 << LOOPBACK_XGMII);
+	else
+		efx->loopback_modes = LOOPBACKS_10G_INTERNAL;
+	efx->loopback_modes |= phy_op->loopbacks;
+
+	efx->startup_loopbacks = ((1 << LOOPBACK_XGMII) |
+				  (1 << phy_op->startup_loopback));
+	return 0;
+}
+
 static int falcon_probe_phy(struct efx_nic *efx)
 {
 	switch (efx->phy_type) {
+	case PHY_TYPE_1G_ALASKA:
+		efx->phy_op = &alaska_phy_operations;
+		break;
 	case PHY_TYPE_10XPRESS:
 		efx->phy_op = &falcon_tenxpress_phy_ops;
 		break;
+	case PHY_TYPE_NONE:
+		efx->phy_op = &falcon_null_phy_ops;
+		break;
 	case PHY_TYPE_XFP:
 		efx->phy_op = &falcon_xfp_phy_ops;
 		break;
+	case PHY_TYPE_CX4_RTMR:
+		efx->phy_op = &falcon_txc_phy_ops;
+		break;
+	case PHY_TYPE_PM8358:
+		efx->phy_op = &falcon_pm8358_phy_ops;
+		break;
 	default:
 		EFX_ERR(efx, "Unknown PHY type %d\n",
 			efx->phy_type);
 		return -1;
 	}
-
-	efx->loopback_modes = LOOPBACKS_10G_INTERNAL | efx->phy_op->loopbacks;
 	return 0;
 }
 
@@ -2102,12 +2393,23 @@ int falcon_probe_port(struct efx_nic *ef
 	if (rc)
 		return rc;
 
+	/* Hook in MAC operations table */
+	if (EFX_IS10G(efx))
+		rc = falcon_probe_xmac_port(efx);
+	else
+		rc = falcon_probe_gmac_port(efx);
+	if (rc)
+		return rc;
+
+	EFX_LOG(efx, "created port using %cMAC\n",
+		EFX_IS10G(efx) ? 'X' : 'G');
+
 	/* Set up GMII structure for PHY */
 	efx->mii.supports_gmii = 1;
 	falcon_init_mdio(&efx->mii);
 
 	/* Hardware flow ctrl. FalconA RX FIFO too small for pause generation */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
+	if (FALCON_REV(efx) >= FALCON_REV_B0)
 		efx->flow_control = EFX_FC_RX | EFX_FC_TX;
 	else
 		efx->flow_control = EFX_FC_RX;
@@ -2127,6 +2429,7 @@ int falcon_probe_port(struct efx_nic *ef
 
 void falcon_remove_port(struct efx_nic *efx)
 {
+	/* Free stats buffer */
 	falcon_free_buffer(efx, &efx->stats_buffer);
 }
 
@@ -2158,6 +2461,78 @@ void falcon_set_multicast_hash(struct ef
  **************************************************************************
  */
 
+static int falcon_clear_b0_memories(struct efx_nic *efx)
+{
+	/* Need to clear memories after a reset. On B0 we can do this
+	 * via the net function.
+	 */
+	int rc = 0, offset;
+	efx_oword_t blanko;
+	efx_dword_t blankd;
+	resource_size_t membase_phys;
+	unsigned long membase_len;
+	void __iomem *membase_orig;
+	unsigned long flags __attribute__ ((unused));
+
+	EFX_ZERO_OWORD(blanko);
+	EFX_ZERO_DWORD(blankd);
+	membase_orig = efx->membase;
+	membase_phys = pci_resource_start(efx->pci_dev, efx->type->mem_bar);
+
+	for (offset = RX_FILTER_TBL0;
+	     offset < RX_RSS_INDIR_TBL_B0;
+	     offset += 0x10)
+		falcon_write(efx, &blanko, offset);
+
+	/* Clear RSS indirection table */
+	for (offset = RX_RSS_INDIR_TBL_B0;
+	     offset < RX_RSS_INDIR_TBL_B0 + 0x800;
+	     offset += 0x10)
+		/* Clear 6 bits every 16 bytes */
+		falcon_writel(efx, &blankd, offset);
+
+	/* Need to split this into several mappings so MSI-X table and PBA
+	 * never get mapped
+	 */
+	membase_phys = membase_phys + 0x2800000;
+	membase_len = 0x3000000 - 0x2800000;
+
+	efx->membase = ioremap_nocache(membase_phys, membase_len);
+	if (efx->membase == NULL) {
+		EFX_ERR(efx, "could not map memory BAR %d at %llx+%lx\n",
+			efx->type->mem_bar, (unsigned long long)membase_phys,
+			membase_len);
+		rc = -ENOMEM;
+		goto out;
+	}
+	/* Clear the buffer table.  The first 7/8 of it is a duplicate
+	 * of the mapping at 0x800000 and must be accessed 2 DWORDs at
+	 * a time.  The final 1/8 must be accessed 4 DWORDs at a time.
+	 * We make sure to obey both rules at the same time.
+	 */
+	for (offset = 0; offset < membase_len; offset += 0x10) {
+		spin_lock_irqsave(&efx->biu_lock, flags);
+		_falcon_writel(efx, 0, offset + 0x0);
+		wmb();
+		_falcon_writel(efx, 0, offset + 0x4);
+		wmb();
+		_falcon_writel(efx, 0, offset + 0x8);
+		wmb();
+		_falcon_writel(efx, 0, offset + 0xc);
+		mmiowb();
+		spin_unlock_irqrestore(&efx->biu_lock, flags);
+	}
+
+	iounmap(efx->membase);
+
+out:
+	/* Restore */
+	efx->membase = membase_orig;
+
+	return rc;
+}
+
+
 /* Resets NIC to known state.  This routine must be called in process
  * context and is allowed to sleep. */
 int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
@@ -2166,10 +2541,11 @@ int falcon_reset_hw(struct efx_nic *efx,
 	efx_oword_t glb_ctl_reg_ker;
 	int rc;
 
-	EFX_LOG(efx, "performing hardware reset (%d)\n", method);
+	EFX_LOG(efx, "performing %s hardware reset\n", RESET_TYPE(method));
 
 	/* Initiate device reset */
 	if (method == RESET_TYPE_WORLD) {
+		/* Save PCI config space */
 		rc = pci_save_state(efx->pci_dev);
 		if (rc) {
 			EFX_ERR(efx, "failed to backup PCI state of primary "
@@ -2204,6 +2580,7 @@ int falcon_reset_hw(struct efx_nic *efx,
 	}
 	falcon_write(efx, &glb_ctl_reg_ker, GLB_CTL_REG_KER);
 
+	/* Wait for 50ms for the chip to come out of reset */
 	EFX_LOG(efx, "waiting for hardware reset\n");
 	schedule_timeout_uninterruptible(HZ / 20);
 
@@ -2235,15 +2612,23 @@ int falcon_reset_hw(struct efx_nic *efx,
 	}
 	EFX_LOG(efx, "hardware reset complete\n");
 
+	if (EFX_WORKAROUND_8202(efx)) {
+		rc = falcon_clear_b0_memories(efx);
+		if (rc)
+			goto fail6;
+	}
+
 	return 0;
 
 	/* pci_save_state() and pci_restore_state() MUST be called in pairs */
 fail2:
 fail3:
 	pci_restore_state(efx->pci_dev);
+	/* fall-thru */
 fail1:
 fail4:
 fail5:
+fail6:
 	return rc;
 }
 
@@ -2252,19 +2637,25 @@ fail5:
  */
 static int falcon_reset_sram(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t srm_cfg_reg_ker, gpio_cfg_reg_ker;
-	int count;
+	int count, onchip, sram_cfg_val;
 
 	/* Set the SRAM wake/sleep GPIO appropriately. */
+	onchip = (nic_data->external_sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY);
 	falcon_read(efx, &gpio_cfg_reg_ker, GPIO_CTL_REG_KER);
 	EFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, GPIO1_OEN, 1);
-	EFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, GPIO1_OUT, 1);
+	EFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, GPIO1_OUT, onchip ? 1 : 0);
 	falcon_write(efx, &gpio_cfg_reg_ker, GPIO_CTL_REG_KER);
 
 	/* Initiate SRAM reset */
+	sram_cfg_val = nic_data->external_sram_cfg;
+	if (nic_data->external_sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY)
+		sram_cfg_val = 0;
+
 	EFX_POPULATE_OWORD_2(srm_cfg_reg_ker,
 			     SRAM_OOB_BT_INIT_EN, 1,
-			     SRM_NUM_BANKS_AND_BANK_SIZE, 0);
+			     SRM_NUM_BANKS_AND_BANK_SIZE, sram_cfg_val);
 	falcon_write(efx, &srm_cfg_reg_ker, SRM_CFG_REG_KER);
 
 	/* Wait for SRAM reset to complete */
@@ -2288,37 +2679,62 @@ static int falcon_reset_sram(struct efx_
 	return -ETIMEDOUT;
 }
 
+static void falcon_spi_device_init(struct efx_spi_device **spi_device_ret,
+				   unsigned int device_id, u32 device_type)
+{
+	struct efx_spi_device *spi_device;
+
+	if (device_type != 0) {
+		spi_device = kmalloc(sizeof(*spi_device), GFP_KERNEL);
+		spi_device->device_id = device_id;
+		spi_device->size =
+			1 << SPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_SIZE);
+		spi_device->addr_len =
+			SPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_ADDR_LEN);
+		spi_device->munge_address = (spi_device->size == 1 << 9 &&
+					     spi_device->addr_len == 1);
+		spi_device->erase_command =
+			SPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_ERASE_CMD);
+		spi_device->erase_size =
+			1 << SPI_DEV_TYPE_FIELD(device_type,
+						SPI_DEV_TYPE_ERASE_SIZE);
+		spi_device->block_size =
+			1 << SPI_DEV_TYPE_FIELD(device_type,
+						SPI_DEV_TYPE_BLOCK_SIZE);
+		spi_device->read = falcon_spi_read;
+		spi_device->write = falcon_spi_write;
+	} else {
+		spi_device = NULL;
+	}
+
+	kfree(*spi_device_ret);
+	*spi_device_ret = spi_device;
+}
+
 /* Extract non-volatile configuration */
 static int falcon_probe_nvconfig(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	struct falcon_nvconfig *nvconfig;
-	efx_oword_t nic_stat;
-	int device_id;
-	unsigned addr_len;
+	struct efx_spi_device *spi;
 	size_t offset, len;
-	int magic_num, struct_ver, board_rev;
+	int magic_num, struct_ver, board_rev, onchip_sram;
 	int rc;
 
-	/* Find the boot device. */
-	falcon_read(efx, &nic_stat, NIC_STAT_REG);
-	if (EFX_OWORD_FIELD(nic_stat, SF_PRST)) {
-		device_id = EE_SPI_FLASH;
-		addr_len = 3;
-	} else if (EFX_OWORD_FIELD(nic_stat, EE_PRST)) {
-		device_id = EE_SPI_EEPROM;
-		addr_len = 2;
-	} else {
-		return -ENODEV;
-	}
-
 	nvconfig = kmalloc(sizeof(*nvconfig), GFP_KERNEL);
 
-	/* Read the whole configuration structure into memory. */
+	/* Read the whole configuration structure into memory.  It's
+	 * in Falcon's boot device, which may be either flash or
+	 * EEPROM, but if both are present Falcon prefers flash.  The
+	 * boot device is always too large for 9-bit addressing, so we
+	 * don't have to munge commands.
+	 */
+	spi = efx->spi_flash ? efx->spi_flash : efx->spi_eeprom;
 	for (offset = 0; offset < sizeof(*nvconfig); offset += len) {
 		len = min(sizeof(*nvconfig) - offset,
 			  (size_t) FALCON_SPI_MAX_LEN);
-		rc = falcon_spi_read(efx, device_id, SPI_READ,
-				     NVCONFIG_BASE + offset, addr_len,
+		rc = falcon_spi_read(spi, efx, SPI_READ,
+				     NVCONFIG_BASE + offset,
 				     (char *)nvconfig + offset, len);
 		if (rc)
 			goto out;
@@ -2337,23 +2753,183 @@ static int falcon_probe_nvconfig(struct 
 		efx->phy_type = PHY_TYPE_NONE;
 		efx->mii.phy_id = PHY_ADDR_INVALID;
 		board_rev = 0;
+		onchip_sram = 1;
+
 	} else {
 		struct falcon_nvconfig_board_v2 *v2 = &nvconfig->board_v2;
+		struct falcon_nvconfig_board_v3 *v3 = &nvconfig->board_v3;
 
 		efx->phy_type = v2->port0_phy_type;
 		efx->mii.phy_id = v2->port0_phy_addr;
 		board_rev = le16_to_cpu(v2->board_revision);
+		onchip_sram = EFX_OWORD_FIELD(nvconfig->nic_stat_reg,
+					      ONCHIP_SRAM);
+
+		if (struct_ver >= 3) {
+			__le32 fl = v3->spi_device_type[EE_SPI_FLASH];
+			__le32 ee = v3->spi_device_type[EE_SPI_EEPROM];
+			falcon_spi_device_init(&efx->spi_flash, EE_SPI_FLASH,
+					       le32_to_cpu(fl));
+			falcon_spi_device_init(&efx->spi_eeprom, EE_SPI_EEPROM,
+					       le32_to_cpu(ee));
+		}
 	}
 
-	EFX_LOG(efx, "PHY is %d phy_id %d\n", efx->phy_type, efx->mii.phy_id);
+	EFX_LOG(efx, "PHY is %s(%d) phy_id %d\n",
+		PHY_TYPE(efx), efx->phy_type,
+		efx->mii.phy_id);
 
 	efx_set_board_info(efx, board_rev);
 
+	/* Read the SRAM configuration.  The register is initialised
+	 * automatically but might may been reset since boot.
+	 */
+	if (onchip_sram) {
+		nic_data->external_sram_cfg = SRM_NB_BSZ_ONCHIP_ONLY;
+	} else {
+		nic_data->external_sram_cfg =
+			EFX_OWORD_FIELD(nvconfig->srm_cfg_reg,
+					SRM_NUM_BANKS_AND_BANK_SIZE);
+		WARN_ON(nic_data->external_sram_cfg == SRM_NB_BSZ_RESERVED);
+		/* Replace invalid setting with the smallest defaults */
+		if (nic_data->external_sram_cfg == SRM_NB_BSZ_DEFAULT)
+			nic_data->external_sram_cfg = SRM_NB_BSZ_1BANKS_2M;
+	}
+	EFX_LOG(efx, "external_sram_cfg=%d (>=0 is external)\n",
+		nic_data->external_sram_cfg);
+
  out:
 	kfree(nvconfig);
 	return rc;
 }
 
+/* Looks at available SRAM resources and silicon revision, and works out
+ * how many queues we can support, and where things like descriptor caches
+ * should live. */
+static int falcon_dimension_resources(struct efx_nic *efx)
+{
+	unsigned buffer_entry_bytes, internal_dcs_entries, dcs;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	struct efx_dl_falcon_resources *res = &nic_data->resources;
+
+	/* Fill out the driverlink resource list */
+	res->hdr.type = EFX_DL_FALCON_RESOURCES;
+	res->biu_lock = &efx->biu_lock;
+	efx->dl_info = &res->hdr;
+
+	/* This is set to 16 for a good reason.  In summary, if larger than
+	 * 16, the descriptor cache holds more than a default socket
+	 * buffer's worth of packets (for UDP we can only have at most one
+	 * socket buffer's worth outstanding).  This combined with the fact
+	 * that we only get 1 TX event per descriptor cache means the NIC
+	 * goes idle.
+	 * 16 gives us up to 256 TXQs on Falcon B in internal-SRAM mode,
+	 * and up to 512 on Falcon A.
+	 */
+	nic_data->tx_dc_entries = 16;
+
+	/* Set the RX descriptor cache size.  Values 16, 32 and 64 are
+	 * supported (8 won't work).  Bigger is better, especially on B
+	 * silicon.
+	 */
+	nic_data->rx_dc_entries = descriptor_cache_size;
+	dcs = ffs(nic_data->rx_dc_entries);
+	if ((dcs < 5) || (dcs > 7) ||
+	    ((1 << (dcs - 1)) != nic_data->rx_dc_entries)) {
+		EFX_ERR(efx, "bad descriptor_cache_size=%d (dcs=%d)\n",
+			nic_data->rx_dc_entries, dcs);
+		return -EINVAL;
+	}
+
+	/* NB. The minimum values get increased as this driver initialises
+	 * its resources, so this should prevent any overlap.
+	 */
+	switch (FALCON_REV(efx)) {
+	case FALCON_REV_A1:
+		res->rxq_min = 16;
+		res->txq_min = 16;
+		res->evq_int_min = 4;
+		res->evq_int_lim = 5;
+		res->evq_timer_min = 5;
+		res->evq_timer_lim = 4096;
+		internal_dcs_entries = 8192;
+		break;
+	case FALCON_REV_B0:
+	default:
+		res->rxq_min = 0;
+		res->txq_min = 0;
+		res->evq_int_min = 0;
+		res->evq_int_lim = 64;
+		res->evq_timer_min = 64;
+		res->evq_timer_lim = 4096;
+		internal_dcs_entries = 4096;
+		break;
+	}
+
+	buffer_entry_bytes = 8;
+
+	if (nic_data->external_sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY) {
+		res->rxq_lim = internal_dcs_entries / nic_data->rx_dc_entries;
+		res->txq_lim = internal_dcs_entries / nic_data->tx_dc_entries;
+		/* Prog model says 8K entries for buffer table in internal
+		 * mode.  But does this not depend on full/half mode?
+		 */
+		res->buffer_table_lim = 8192;
+		nic_data->tx_dc_base = 0x130000;
+		nic_data->rx_dc_base = 0x100000;
+	} else {
+		unsigned sram_bytes, vnic_bytes, max_vnics, n_vnics;
+
+		/* Determine how much SRAM we have to play with.  We have
+		 * to fit buffer table and descriptor caches in.
+		 */
+		switch (nic_data->external_sram_cfg) {
+		case SRM_NB_BSZ_1BANKS_2M:
+		default:
+			sram_bytes = 2 * 1024 * 1024;
+			break;
+		case SRM_NB_BSZ_1BANKS_4M:
+		case SRM_NB_BSZ_2BANKS_4M:
+			sram_bytes = 4 * 1024 * 1024;
+			break;
+		case SRM_NB_BSZ_1BANKS_8M:
+		case SRM_NB_BSZ_2BANKS_8M:
+			sram_bytes = 8 * 1024 * 1024;
+			break;
+		case SRM_NB_BSZ_2BANKS_16M:
+			sram_bytes = 16 * 1024 * 1024;
+			break;
+		}
+		/* For each VNIC allow at least 512 buffer table entries
+		 * and descriptor cache for an rxq and txq.  Buffer table
+		 * space for evqs and dmaqs is relatively trivial, so not
+		 * considered in this calculation.
+		 */
+		vnic_bytes = (512 * buffer_entry_bytes
+			      + nic_data->rx_dc_entries * 8
+			      + nic_data->tx_dc_entries * 8);
+		max_vnics = sram_bytes / vnic_bytes;
+		for (n_vnics = 1; n_vnics < res->evq_timer_min + max_vnics;)
+			n_vnics *= 2;
+		res->rxq_lim = n_vnics;
+		res->txq_lim = n_vnics;
+
+		dcs = n_vnics * nic_data->tx_dc_entries * 8;
+		nic_data->tx_dc_base = sram_bytes - dcs;
+		dcs = n_vnics * nic_data->rx_dc_entries * 8;
+		nic_data->rx_dc_base = nic_data->tx_dc_base - dcs;
+		res->buffer_table_lim = nic_data->rx_dc_base / 8;
+	}
+
+	if (FALCON_IS_DUAL_FUNC(efx))
+		res->flags |= EFX_DL_FALCON_DUAL_FUNC;
+
+	if (EFX_INT_MODE_USE_MSI(efx))
+		res->flags |= EFX_DL_FALCON_USE_MSI;
+
+	return 0;
+}
+
 /* Probe the NIC variant (revision, ASIC vs FPGA, function count, port
  * count, port speed).  Set workaround and feature flags accordingly.
  */
@@ -2362,12 +2938,9 @@ static int falcon_probe_nic_variant(stru
 	efx_oword_t altera_build;
 
 	falcon_read(efx, &altera_build, ALTERA_BUILD_REG_KER);
-	if (EFX_OWORD_FIELD(altera_build, VER_ALL)) {
-		EFX_ERR(efx, "Falcon FPGA not supported\n");
-		return -ENODEV;
-	}
+	efx->is_asic = EFX_OWORD_FIELD(altera_build, VER_ALL) == 0;
 
-	switch (falcon_rev(efx)) {
+	switch (FALCON_REV(efx)) {
 	case FALCON_REV_A0:
 	case 0xff:
 		EFX_ERR(efx, "Falcon rev A0 not supported\n");
@@ -2378,28 +2951,182 @@ static int falcon_probe_nic_variant(stru
 
 		falcon_read(efx, &nic_stat, NIC_STAT_REG);
 
-		if (EFX_OWORD_FIELD(nic_stat, STRAP_PCIE) == 0) {
-			EFX_ERR(efx, "Falcon rev A1 PCI-X not supported\n");
+		if (!efx->is_asic) {
+			EFX_ERR(efx, "Falcon rev A1 FPGA not supported\n");
 			return -ENODEV;
 		}
-		if (!EFX_OWORD_FIELD(nic_stat, STRAP_10G)) {
-			EFX_ERR(efx, "1G mode not supported\n");
+		if (EFX_OWORD_FIELD(nic_stat, STRAP_PCIE) == 0) {
+			EFX_ERR(efx, "Falcon rev A1 PCI-X not supported\n");
 			return -ENODEV;
 		}
+		efx->is_10g = EFX_OWORD_FIELD(nic_stat, STRAP_10G);
+		efx->silicon_rev = "falcon/a1";
 		break;
 	}
 
-	case FALCON_REV_B0:
+	case FALCON_REV_B0:{
+		efx->is_10g = 1;
+		efx->silicon_rev = "falcon/b0";
 		break;
+	}
 
 	default:
-		EFX_ERR(efx, "Unknown Falcon rev %d\n", falcon_rev(efx));
+		EFX_ERR(efx, "Unknown Falcon rev %d\n", FALCON_REV(efx));
 		return -ENODEV;
 	}
 
 	return 0;
 }
 
+/* Probe all SPI devices on the NIC */
+static void falcon_probe_spi_devices(struct efx_nic *efx)
+{
+	efx_oword_t nic_stat, gpio_ctl, ee_vpd_cfg;
+	unsigned int has_flash, has_eeprom, boot_is_external;
+
+	falcon_read(efx, &gpio_ctl, GPIO_CTL_REG_KER);
+	falcon_read(efx, &nic_stat, NIC_STAT_REG);
+	falcon_read(efx, &ee_vpd_cfg, EE_VPD_CFG_REG_KER);
+
+	has_flash = EFX_OWORD_FIELD(nic_stat, SF_PRST);
+	has_eeprom = EFX_OWORD_FIELD(nic_stat, EE_PRST);
+	boot_is_external = EFX_OWORD_FIELD(gpio_ctl, BOOTED_USING_NVDEVICE);
+
+	if (has_flash) {
+		u32 flash_device_type;
+
+		if (flash_type == -1) {
+			/* Default flash SPI device: Atmel AT25F1024
+			 * 128 KB, 24-bit address, 32 KB erase block,
+			 * 256 B write block
+			 */
+			flash_device_type =
+				(17 << SPI_DEV_TYPE_SIZE_LBN)
+				| (3 << SPI_DEV_TYPE_ADDR_LEN_LBN)
+				| (0x52 << SPI_DEV_TYPE_ERASE_CMD_LBN)
+				| (15 << SPI_DEV_TYPE_ERASE_SIZE_LBN)
+				| (8 << SPI_DEV_TYPE_BLOCK_SIZE_LBN);
+		} else {
+			flash_device_type = flash_type;
+		}
+
+		falcon_spi_device_init(&efx->spi_flash, EE_SPI_FLASH,
+				       flash_device_type);
+
+		if (!boot_is_external) {
+			/* Disable VPD and set clock dividers to safe
+			 * values for initial programming.
+			 */
+			EFX_LOG(efx, "Booted from internal ASIC settings;"
+				" setting SPI config\n");
+			EFX_POPULATE_OWORD_3(ee_vpd_cfg, EE_VPD_EN, 0,
+					     /* 125 MHz / 7 ~= 20 MHz */
+					     EE_SF_CLOCK_DIV, 7,
+					     /* 125 MHz / 63 ~= 2 MHz */
+					     EE_EE_CLOCK_DIV, 63);
+			falcon_write(efx, &ee_vpd_cfg, EE_VPD_CFG_REG_KER);
+		}
+	}
+
+	if (has_eeprom) {
+		u32 eeprom_device_type;
+
+		/* eeprom_type may be -1 (default) for automatic detection,
+		 * 0 or 1 to select the default or large EEPROM, or
+		 * some larger number to specify the precise configuration
+		 */
+		if (eeprom_type == -1 || eeprom_type <= 1) {
+			/* If it has no flash, it must have a large EEPROM
+			 * for chip config; otherwise check whether 9-bit
+			 * addressing is used for VPD configuration
+			 */
+			if (eeprom_type == 0 ||
+			    (eeprom_type == -1 && has_flash &&
+			     (!boot_is_external ||
+			      EFX_OWORD_FIELD(ee_vpd_cfg,
+					      EE_VPD_EN_AD9_MODE)))) {
+				/* Default SPI device: Atmel AT25040 or similar
+				 * 512 B, 9-bit address, 8 B write block
+				 */
+				eeprom_device_type =
+					(9 << SPI_DEV_TYPE_SIZE_LBN)
+					| (1 << SPI_DEV_TYPE_ADDR_LEN_LBN)
+					| (3 << SPI_DEV_TYPE_BLOCK_SIZE_LBN);
+			} else {
+				/* "Large" SPI device: Atmel AT25640 or similar
+				 * 8 KB, 16-bit address, 32 B write block
+				 */
+				eeprom_device_type =
+					(13 << SPI_DEV_TYPE_SIZE_LBN)
+					| (2 << SPI_DEV_TYPE_ADDR_LEN_LBN)
+					| (5 << SPI_DEV_TYPE_BLOCK_SIZE_LBN);
+			}
+		} else {
+			eeprom_device_type = eeprom_type;
+		}
+
+		falcon_spi_device_init(&efx->spi_eeprom, EE_SPI_EEPROM,
+				       eeprom_device_type);
+	}
+
+	EFX_LOG(efx, "flash is %s, EEPROM is %s\n",
+		(has_flash ? "present" : "absent"),
+		(has_eeprom ? "present" : "absent"));
+}
+
+static void falcon_remove_spi_devices(struct efx_nic *efx)
+{
+	kfree(efx->spi_eeprom);
+	efx->spi_eeprom = NULL;
+	kfree(efx->spi_flash);
+	efx->spi_flash = NULL;
+}
+
+#ifdef CONFIG_SFC_DEBUGFS
+
+/* Generate a hardware revision string */
+int falcon_debugfs_read_hardware_desc(struct seq_file *file, void *data)
+{
+	struct efx_nic *efx = data;
+	efx_oword_t altera_build;
+	int major, minor, build;
+	int rc, len;
+
+	if (efx->is_asic) {
+		rc = seq_puts(file, "Falcon ASIC");
+	} else {
+		falcon_read(efx, &altera_build, ALTERA_BUILD_REG_KER);
+
+		major = EFX_OWORD_FIELD(altera_build, VER_MAJOR);
+		minor = EFX_OWORD_FIELD(altera_build, VER_MINOR);
+		build = EFX_OWORD_FIELD(altera_build, VER_BUILD);
+		rc = seq_printf(file, "Falcon FPGA v%x.%x.%x",
+				major, minor, build);
+	}
+	len = rc;
+
+	switch (FALCON_REV(efx)) {
+	case FALCON_REV_A1:
+		rc = seq_puts(file, " rev A1 ");
+		break;
+	case FALCON_REV_B0:
+		rc = seq_puts(file, " rev B0 ");
+		break;
+	default:
+		rc = seq_puts(file, " rev ?? ");
+		break;
+	}
+	len += rc;
+
+	rc = seq_printf(file, "%s %s\n",
+			efx->is_10g ? "10G" : "1G", PHY_TYPE(efx));
+	len += rc;
+
+	return rc < 0 ? rc : len;
+}
+
+#endif /* CONFIG_SFC_DEBUGFS */
+
 int falcon_probe_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data;
@@ -2413,7 +3140,7 @@ int falcon_probe_nic(struct efx_nic *efx
 
 	/* Allocate storage for hardware specific data */
 	nic_data = kzalloc(sizeof(*nic_data), GFP_KERNEL);
-	efx->nic_data = nic_data;
+	efx->nic_data = (void *) nic_data;
 
 	/* Determine number of ports etc. */
 	rc = falcon_probe_nic_variant(efx);
@@ -2456,37 +3183,229 @@ int falcon_probe_nic(struct efx_nic *efx
 		(unsigned long long)efx->irq_status.dma_addr,
 		efx->irq_status.addr, virt_to_phys(efx->irq_status.addr));
 
+	/* Determine attached SPI devices */
+	falcon_probe_spi_devices(efx);
+
 	/* Read in the non-volatile configuration */
 	rc = falcon_probe_nvconfig(efx);
 	if (rc)
 		goto fail5;
 
+	if (!efx->is_10g && efx->phy_type != PHY_TYPE_1G_ALASKA) {
+		/* Actually using 1G port, not 10G port */
+		efx->phy_type = PHY_TYPE_1G_ALASKA;
+		efx->mii.phy_id = 2;
+	}
+
+	rc = falcon_dimension_resources(efx);
+	if (rc)
+		goto fail6;
+
 	return 0;
 
+ fail6:
+	efx->dl_info = NULL;
  fail5:
+	falcon_remove_spi_devices(efx);
 	falcon_free_buffer(efx, &efx->irq_status);
  fail4:
+	/* fall-thru */
  fail3:
 	if (nic_data->pci_dev2) {
 		pci_dev_put(nic_data->pci_dev2);
 		nic_data->pci_dev2 = NULL;
 	}
  fail2:
+	/* fall-thru */
  fail1:
 	kfree(efx->nic_data);
 	return rc;
 }
 
+static int falcon_check_power_limit(struct efx_nic *efx)
+{
+	int pciecap_offset = pci_find_capability(efx->pci_dev, PCI_CAP_ID_EXP);
+	u32 pcie_devcap;
+	unsigned val, scale;
+	int rc;
+
+	if (!pciecap_offset)
+		return -EIO;
+	rc = pci_read_config_dword(efx->pci_dev,
+				   (pciecap_offset + PCI_EXP_DEVCAP),
+				   &pcie_devcap);
+	if (rc)
+		return rc;
+
+	val = ((pcie_devcap & PCI_EXP_DEVCAP_PWR_VAL) >>
+	       PCI_EXP_DEVCAP_PWR_VAL_LBN);
+	scale = ((pcie_devcap & PCI_EXP_DEVCAP_PWR_SCL) >>
+		 PCI_EXP_DEVCAP_PWR_SCL_LBN);
+
+	/* Re-scale to milliwatts if necessary */
+	while (scale != 3) {
+		val *= 10;
+		scale++;
+	}
+
+	if (val != 0 && efx->board_info.mwatts > val) {
+		EFX_ERR(efx, "board needs %d mW but only %d mW available\n",
+			efx->board_info.mwatts, val);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void falcon_init_ack_repl_timer(struct efx_nic *efx, int num_lanes)
+{
+	unsigned tlp_size;
+	efx_dword_t pcie_ack_rpl_reg;
+	efx_dword_t pcie_ack_freq_reg;
+	efx_dword_t pcie_ctrl_stat_reg;
+	u16 pcie_devicectrl;
+	int lut_index, tlp_size_decoded;
+	int current_replay, expected_replay;
+	int current_ack_timer, current_ack_freq;
+
+	static struct efx_tlp_ack_factor {
+		int tlp;
+		int replay[4]; /* 0=1x, 1=2x, 3=4x, 4=8x (see pcie docs) */
+	} tlp_ack_factor_lut[4] = {
+		{ 128,  { 421, 257, 174, 166 } },
+		{ 256,  { 689, 391, 241, 225 } },
+		{ 512,  { 903, 498, 295, 193 } },
+		{ 1024, { 1670, 881, 487, 290 } }
+	};
+	struct efx_tlp_ack_factor *tlp_ack_factor;
+
+	/* Get TLP size */
+	falcon_pcie_core_read_reg(efx, PCIE_CORE_ADDR_PCIE_DEVICE_CTRL_STAT,
+				  &pcie_ctrl_stat_reg);
+	pcie_devicectrl = (u16) EFX_EXTRACT_DWORD(pcie_ctrl_stat_reg, 0, 15);
+	tlp_size = ((PCI_EXP_DEVCTL_PAYLOAD & pcie_devicectrl) >>
+		    PCI_EXP_DEVCTL_PAYLOAD_LBN);
+	EFX_WARN_ON_PARANOID(tlp_size > 3); /* => 1024 bytes */
+	tlp_ack_factor = &tlp_ack_factor_lut[tlp_size & 0x3];
+	tlp_size_decoded = tlp_ack_factor->tlp;
+
+	/* Get actual ack & actual and expected replay settings */
+	falcon_pcie_core_read_reg(efx, PCIE_CORE_ADDR_ACK_RPL_TIMER,
+				  &pcie_ack_rpl_reg);
+	current_replay = EFX_DWORD_FIELD(pcie_ack_rpl_reg, PCIE_CORE_RPL_TL);
+	current_ack_timer = EFX_DWORD_FIELD(pcie_ack_rpl_reg,
+					    PCIE_CORE_ACK_TL);
+
+	lut_index = ffs(num_lanes) - 1;
+	expected_replay = tlp_ack_factor->replay[lut_index & 0x3];
+
+	falcon_pcie_core_read_reg(efx, PCIE_CORE_ADDR_ACK_FREQ,
+				  &pcie_ack_freq_reg);
+	current_ack_freq = EFX_DWORD_FIELD(pcie_ack_freq_reg,
+					   PCIE_CORE_ACK_FREQ);
+
+	EFX_LOG(efx, "pcie x%d tlp=%d replay_reg=" EFX_DWORD_FMT " { ack=%d "
+		"current_replay=%d expected_replay=%d } ack_reg="
+		EFX_DWORD_FMT " { current_freq=%d expected_freq=%d }\n",
+		num_lanes, tlp_size_decoded,
+		EFX_DWORD_VAL(pcie_ack_rpl_reg), current_ack_timer,
+		current_replay, expected_replay,
+		EFX_DWORD_VAL(pcie_ack_rpl_reg), current_ack_freq, 0);
+
+	/* If expected replay setting needs to be bigger then set it */
+	if (expected_replay > current_replay) {
+		EFX_SET_DWORD_FIELD(pcie_ack_rpl_reg, PCIE_CORE_RPL_TL,
+				    expected_replay);
+
+		falcon_pcie_core_write_reg(efx, PCIE_CORE_ADDR_ACK_RPL_TIMER,
+					   pcie_ack_rpl_reg);
+	}
+}
+
+static int falcon_init_pcie_core(struct efx_nic *efx)
+{
+	int pciecap_offset;
+	unsigned num_lanes = 0;
+
+	/* Get num lanes */
+	pciecap_offset = pci_find_capability(efx->pci_dev, PCI_CAP_ID_EXP);
+	if (pciecap_offset) {
+		u16 pcie_linkstat;
+		int rc, link_sta;
+
+		link_sta = pciecap_offset + PCI_EXP_LNKSTA;
+		rc = pci_read_config_word(efx->pci_dev, link_sta,
+					  &pcie_linkstat);
+		if (rc)
+			return rc;
+
+		num_lanes = ((pcie_linkstat & PCI_EXP_LNKSTA_LNK_WID)
+			     >> PCI_EXP_LNKSTA_LNK_WID_LBN);
+		EFX_BUG_ON_PARANOID(num_lanes <= 0 || num_lanes > 8);
+
+		if (num_lanes < 8)
+			EFX_ERR(efx, "WARNING: the Solarflare Network Adapter "
+				"has been plugged into a PCI-Express slot with "
+				"less than 8 lanes (%d detected). This will "
+				"limit the maximum achievable bandwidth! "
+				"Consult your motherboard documentation to "
+				"find a slot that is 8 lanes electrically and "
+				"physically\n", num_lanes);
+	}
+
+	if (FALCON_REV(efx) <= FALCON_REV_A1)
+		return 0;
+
+	if (EFX_WORKAROUND_6943(efx) && num_lanes > 0)
+		falcon_init_ack_repl_timer(efx, num_lanes);
+
+	if (EFX_WORKAROUND_9096(efx)) {
+		efx_dword_t pcie_ack_freq_reg;
+
+		/* ensure ack freq timer is 0 = always ack after timeout */
+		falcon_pcie_core_read_reg(efx, PCIE_CORE_ADDR_ACK_FREQ,
+					  &pcie_ack_freq_reg);
+		EFX_SET_DWORD_FIELD(pcie_ack_freq_reg, PCIE_CORE_ACK_FREQ, 0);
+		falcon_pcie_core_write_reg(efx, PCIE_CORE_ADDR_ACK_FREQ,
+					   pcie_ack_freq_reg);
+	}
+
+	return 0;
+}
+
+static void falcon_fini_pcie_core(struct efx_nic *efx)
+{
+	efx_dword_t pcie_ack_freq_reg;
+
+	if (FALCON_REV(efx) <= FALCON_REV_A1)
+		return;
+
+	if (EFX_WORKAROUND_9096(efx)) {
+		/* Set the ACK frequency timer to 1, so TLP's are acked in
+		 * a timely fashion.
+		 */
+		falcon_pcie_core_read_reg(efx, PCIE_CORE_ADDR_ACK_FREQ,
+					  &pcie_ack_freq_reg);
+		EFX_SET_DWORD_FIELD(pcie_ack_freq_reg, PCIE_CORE_ACK_FREQ, 1);
+		falcon_pcie_core_write_reg(efx, PCIE_CORE_ADDR_ACK_FREQ,
+					   pcie_ack_freq_reg);
+	}
+}
+
 /* This call performs hardware-specific global initialisation, such as
  * defining the descriptor cache sizes and number of RSS channels.
  * It does not set up any buffers, descriptor rings or event queues.
  */
 int falcon_init_nic(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	struct falcon_nic_data *data;
 	efx_oword_t temp;
 	unsigned thresh;
 	int rc;
 
+	data = (struct falcon_nic_data *)efx->nic_data;
+
 	/* Set up the address region register. This is only needed
 	 * for the B0 FPGA, but since we are just pushing in the
 	 * reset defaults this may as well be unconditional. */
@@ -2496,11 +3415,25 @@ int falcon_init_nic(struct efx_nic *efx)
 				   ADR_REGION3, (3 << 16));
 	falcon_write(efx, &temp, ADR_REGION_REG_KER);
 
-	/* Use on-chip SRAM */
+	/* Use on-chip SRAM if needed.
+	 */
 	falcon_read(efx, &temp, NIC_STAT_REG);
-	EFX_SET_OWORD_FIELD(temp, ONCHIP_SRAM, 1);
+	if (nic_data->external_sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY)
+		EFX_SET_OWORD_FIELD(temp, ONCHIP_SRAM, 1);
+	else
+		EFX_SET_OWORD_FIELD(temp, ONCHIP_SRAM, 0);
 	falcon_write(efx, &temp, NIC_STAT_REG);
 
+	/* Check power requirements against PCIe power budgeting */
+	rc = falcon_check_power_limit(efx);
+	if (rc)
+		return rc;
+
+	/* Warn if <8 lanes of PCIe detected & set pcie timers */
+	rc = falcon_init_pcie_core(efx);
+	if (rc)
+		return rc;
+
 	/* Set buffer table mode */
 	EFX_POPULATE_OWORD_1(temp, BUF_TBL_MODE, BUF_TBL_MODE_FULL);
 	falcon_write(efx, &temp, BUF_TBL_CFG_REG_KER);
@@ -2510,23 +3443,21 @@ int falcon_init_nic(struct efx_nic *efx)
 		return rc;
 
 	/* Set positions of descriptor caches in SRAM. */
-	EFX_POPULATE_OWORD_1(temp, SRM_TX_DC_BASE_ADR, TX_DC_BASE / 8);
+	EFX_POPULATE_OWORD_1(temp, SRM_TX_DC_BASE_ADR, data->tx_dc_base / 8);
 	falcon_write(efx, &temp, SRM_TX_DC_CFG_REG_KER);
-	EFX_POPULATE_OWORD_1(temp, SRM_RX_DC_BASE_ADR, RX_DC_BASE / 8);
+	EFX_POPULATE_OWORD_1(temp, SRM_RX_DC_BASE_ADR, data->rx_dc_base / 8);
 	falcon_write(efx, &temp, SRM_RX_DC_CFG_REG_KER);
 
 	/* Set TX descriptor cache size. */
-	BUILD_BUG_ON(TX_DC_ENTRIES != (16 << TX_DC_ENTRIES_ORDER));
-	EFX_POPULATE_OWORD_1(temp, TX_DC_SIZE, TX_DC_ENTRIES_ORDER);
+	EFX_POPULATE_OWORD_1(temp, TX_DC_SIZE, ffs(data->tx_dc_entries) - 4);
 	falcon_write(efx, &temp, TX_DC_CFG_REG_KER);
 
 	/* Set RX descriptor cache size.  Set low watermark to size-8, as
 	 * this allows most efficient prefetching.
 	 */
-	BUILD_BUG_ON(RX_DC_ENTRIES != (16 << RX_DC_ENTRIES_ORDER));
-	EFX_POPULATE_OWORD_1(temp, RX_DC_SIZE, RX_DC_ENTRIES_ORDER);
+	EFX_POPULATE_OWORD_1(temp, RX_DC_SIZE, ffs(data->rx_dc_entries) - 4);
 	falcon_write(efx, &temp, RX_DC_CFG_REG_KER);
-	EFX_POPULATE_OWORD_1(temp, RX_DC_PF_LWM, RX_DC_ENTRIES - 8);
+	EFX_POPULATE_OWORD_1(temp, RX_DC_PF_LWM, data->rx_dc_entries - 8);
 	falcon_write(efx, &temp, RX_DC_PF_WM_REG_KER);
 
 	/* Clear the parity enables on the TX data fifos as
@@ -2553,7 +3484,7 @@ int falcon_init_nic(struct efx_nic *efx)
 
 	/* Set number of RSS queues for receive path. */
 	falcon_read(efx, &temp, RX_FILTER_CTL_REG);
-	if (falcon_rev(efx) >= FALCON_REV_B0)
+	if (FALCON_REV(efx) >= FALCON_REV_B0)
 		EFX_SET_OWORD_FIELD(temp, NUM_KER, 0);
 	else
 		EFX_SET_OWORD_FIELD(temp, NUM_KER, efx->rss_queues - 1);
@@ -2590,8 +3521,10 @@ int falcon_init_nic(struct efx_nic *efx)
 	EFX_SET_OWORD_FIELD(temp, TX_SW_EV_EN, 1);
 	/* Prefetch threshold 2 => fetch when descriptor cache half empty */
 	EFX_SET_OWORD_FIELD(temp, TX_PREF_THRESHOLD, 2);
+	if (EFX_WORKAROUND_9008(efx))
+		EFX_SET_OWORD_FIELD(temp, TX_PREF_WD_TMR, (unsigned)0x3fffff);
 	/* Squash TX of packets of 16 bytes or less */
-	if (falcon_rev(efx) >= FALCON_REV_B0 && EFX_WORKAROUND_9141(efx))
+	if (FALCON_REV(efx) >= FALCON_REV_B0 && EFX_WORKAROUND_9141(efx))
 		EFX_SET_OWORD_FIELD(temp, TX_FLUSH_MIN_LEN_EN_B0, 1);
 	falcon_write(efx, &temp, TX_CFG2_REG_KER);
 
@@ -2608,7 +3541,7 @@ int falcon_init_nic(struct efx_nic *efx)
 	if (EFX_WORKAROUND_7575(efx))
 		EFX_SET_OWORD_FIELD_VER(efx, temp, RX_USR_BUF_SIZE,
 					(3 * 4096) / 32);
-	if (falcon_rev(efx) >= FALCON_REV_B0)
+	if (FALCON_REV(efx) >= FALCON_REV_B0)
 		EFX_SET_OWORD_FIELD(temp, RX_INGR_EN_B0, 1);
 
 	/* RX FIFO flow control thresholds */
@@ -2624,7 +3557,7 @@ int falcon_init_nic(struct efx_nic *efx)
 	falcon_write(efx, &temp, RX_CFG_REG_KER);
 
 	/* Set destination of both TX and RX Flush events */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
+	if (FALCON_REV(efx) >= FALCON_REV_B0) {
 		EFX_POPULATE_OWORD_1(temp, FLS_EVQ_ID, 0);
 		falcon_write(efx, &temp, DP_CTRL_REG);
 	}
@@ -2632,13 +3565,20 @@ int falcon_init_nic(struct efx_nic *efx)
 	return 0;
 }
 
+void falcon_fini_nic(struct efx_nic *efx)
+{
+	falcon_fini_pcie_core(efx);
+}
+
 void falcon_remove_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
 
+	falcon_remove_spi_devices(efx);
 	falcon_free_buffer(efx, &efx->irq_status);
 
-	falcon_reset_hw(efx, RESET_TYPE_ALL);
+	/* Reset the NIC finally */
+	(void) falcon_reset_hw(efx, RESET_TYPE_ALL);
 
 	/* Release the second function after the reset */
 	if (nic_data->pci_dev2) {
@@ -2646,15 +3586,16 @@ void falcon_remove_nic(struct efx_nic *e
 		nic_data->pci_dev2 = NULL;
 	}
 
-	/* Tear down the private nic state */
+	/* Tear down the private nic state, and the driverlink nic params */
 	kfree(efx->nic_data);
-	efx->nic_data = NULL;
+	efx->nic_data = efx->dl_info = NULL;
 }
 
 void falcon_update_nic_stats(struct efx_nic *efx)
 {
 	efx_oword_t cnt;
 
+	/* Read the RX drop counter */
 	falcon_read(efx, &cnt, RX_NODESC_DROP_REG_KER);
 	efx->n_rx_nodesc_drop_cnt += EFX_OWORD_FIELD(cnt, RX_NODESC_DROP_CNT);
 }
@@ -2711,5 +3652,6 @@ struct efx_nic_type falcon_b_nic_type = 
 	.phys_addr_channels = 32, /* Hardware limit is 64, but the legacy
 				   * interrupt handler only supports 32
 				   * channels */
+
 };
 
Index: head-2008-06-18/drivers/net/sfc/falcon.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/falcon.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/falcon.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,16 +1,35 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_FALCON_H
 #define EFX_FALCON_H
 
+#include <asm/io.h>
+#include <linux/spinlock.h>
 #include "net_driver.h"
 
 /*
@@ -23,10 +42,7 @@ enum falcon_revision {
 	FALCON_REV_B0 = 2,
 };
 
-static inline int falcon_rev(struct efx_nic *efx)
-{
-	return efx->pci_dev->revision;
-}
+#define FALCON_REV(efx) ((efx)->pci_dev->revision)
 
 extern struct efx_nic_type falcon_a_nic_type;
 extern struct efx_nic_type falcon_b_nic_type;
@@ -87,6 +103,7 @@ extern int falcon_probe_nic(struct efx_n
 extern int falcon_probe_resources(struct efx_nic *efx);
 extern int falcon_init_nic(struct efx_nic *efx);
 extern int falcon_reset_hw(struct efx_nic *efx, enum reset_type method);
+extern void falcon_fini_nic(struct efx_nic *efx);
 extern void falcon_remove_resources(struct efx_nic *efx);
 extern void falcon_remove_nic(struct efx_nic *efx);
 extern void falcon_update_nic_stats(struct efx_nic *efx);
@@ -130,4 +147,9 @@ extern int falcon_reset_xaui(struct efx_
 extern void falcon_generate_event(struct efx_channel *channel,
 				  efx_qword_t *event);
 
+#ifdef CONFIG_SFC_DEBUGFS
+struct seq_file;
+extern int falcon_debugfs_read_hardware_desc(struct seq_file *file, void *data);
+#endif
+
 #endif /* EFX_FALCON_H */
Index: head-2008-06-18/drivers/net/sfc/falcon_gmac.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/falcon_gmac.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,320 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#include <linux/delay.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "falcon.h"
+#include "mac.h"
+#include "falcon_hwdefs.h"
+#include "falcon_io.h"
+#include "gmii.h"
+
+/**************************************************************************
+ *
+ * MAC register access
+ *
+ **************************************************************************/
+
+/* Offset of a GMAC register within Falcon */
+#define FALCON_GMAC_REG(mac_reg)					\
+	(FALCON_GMAC_REGBANK + ((mac_reg) * FALCON_GMAC_REG_SIZE))
+
+static void falcon_gmac_writel(struct efx_nic *efx,
+			       efx_dword_t *value, unsigned int mac_reg)
+{
+	efx_oword_t temp;
+
+	EFX_POPULATE_OWORD_1(temp, MAC_DATA, EFX_DWORD_FIELD(*value, MAC_DATA));
+	falcon_write(efx, &temp, FALCON_GMAC_REG(mac_reg));
+}
+
+static void falcon_gmac_readl(struct efx_nic *efx,
+			      efx_dword_t *value, unsigned int mac_reg)
+{
+	efx_oword_t temp;
+
+	falcon_read(efx, &temp, FALCON_GMAC_REG(mac_reg));
+	EFX_POPULATE_DWORD_1(*value, MAC_DATA, EFX_OWORD_FIELD(temp, MAC_DATA));
+}
+
+/**************************************************************************
+ *
+ * MAC operations
+ *
+ *************************************************************************/
+
+static int falcon_init_gmac(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Reset the MAC */
+	mentormac_reset(efx);
+
+	/* Initialise PHY */
+	rc = efx->phy_op->init(efx);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static void falcon_reconfigure_gmac(struct efx_nic *efx)
+{
+	/* Reconfigure PHY and pick up PHY parameters.  This updates
+	 * the link status. */
+	efx->phy_op->reconfigure(efx);
+
+	/* Isolate the MAC. */
+	falcon_deconfigure_mac_wrapper(efx);
+
+	/* Reconfigure MAC */
+	mentormac_reconfigure(efx);
+
+	/* Reconfigure MAC wrapper */
+	falcon_reconfigure_mac_wrapper(efx);
+}
+
+static void falcon_fini_gmac(struct efx_nic *efx)
+{
+	/* Isolate the MAC - PHY */
+	falcon_deconfigure_mac_wrapper(efx);
+
+	/* Shut down PHY */
+	efx->phy_op->fini(efx);
+
+	/* Reset MAC */
+	mentormac_reset(efx);
+}
+
+static void falcon_update_stats_gmac(struct efx_nic *efx)
+{
+	struct efx_mac_stats *mac_stats = &efx->mac_stats;
+	unsigned long old_rx_pause, old_tx_pause;
+	unsigned long new_rx_pause, new_tx_pause;
+	int rc;
+
+	rc = falcon_dma_stats(efx, GDmaDone_offset);
+	if (rc)
+		return;
+
+	/* Pause frames are erroneously counted as errors (SFC bug 3269) */
+	old_rx_pause = mac_stats->rx_pause;
+	old_tx_pause = mac_stats->tx_pause;
+
+	/* Update MAC stats from DMAed values */
+	FALCON_STAT(efx, GRxGoodOct, rx_good_bytes);
+	FALCON_STAT(efx, GRxBadOct, rx_bad_bytes);
+	FALCON_STAT(efx, GRxMissPkt, rx_missed);
+	FALCON_STAT(efx, GRxFalseCRS, rx_false_carrier);
+	FALCON_STAT(efx, GRxPausePkt, rx_pause);
+	FALCON_STAT(efx, GRxBadPkt, rx_bad);
+	FALCON_STAT(efx, GRxUcastPkt, rx_unicast);
+	FALCON_STAT(efx, GRxMcastPkt, rx_multicast);
+	FALCON_STAT(efx, GRxBcastPkt, rx_broadcast);
+	FALCON_STAT(efx, GRxGoodLt64Pkt, rx_good_lt64);
+	FALCON_STAT(efx, GRxBadLt64Pkt, rx_bad_lt64);
+	FALCON_STAT(efx, GRx64Pkt, rx_64);
+	FALCON_STAT(efx, GRx65to127Pkt, rx_65_to_127);
+	FALCON_STAT(efx, GRx128to255Pkt, rx_128_to_255);
+	FALCON_STAT(efx, GRx256to511Pkt, rx_256_to_511);
+	FALCON_STAT(efx, GRx512to1023Pkt, rx_512_to_1023);
+	FALCON_STAT(efx, GRx1024to15xxPkt, rx_1024_to_15xx);
+	FALCON_STAT(efx, GRx15xxtoJumboPkt, rx_15xx_to_jumbo);
+	FALCON_STAT(efx, GRxGtJumboPkt, rx_gtjumbo);
+	FALCON_STAT(efx, GRxFcsErr64to15xxPkt, rx_bad_64_to_15xx);
+	FALCON_STAT(efx, GRxFcsErr15xxtoJumboPkt, rx_bad_15xx_to_jumbo);
+	FALCON_STAT(efx, GRxFcsErrGtJumboPkt, rx_bad_gtjumbo);
+	FALCON_STAT(efx, GTxGoodBadOct, tx_bytes);
+	FALCON_STAT(efx, GTxGoodOct, tx_good_bytes);
+	FALCON_STAT(efx, GTxSglColPkt, tx_single_collision);
+	FALCON_STAT(efx, GTxMultColPkt, tx_multiple_collision);
+	FALCON_STAT(efx, GTxExColPkt, tx_excessive_collision);
+	FALCON_STAT(efx, GTxDefPkt, tx_deferred);
+	FALCON_STAT(efx, GTxLateCol, tx_late_collision);
+	FALCON_STAT(efx, GTxExDefPkt, tx_excessive_deferred);
+	FALCON_STAT(efx, GTxPausePkt, tx_pause);
+	FALCON_STAT(efx, GTxBadPkt, tx_bad);
+	FALCON_STAT(efx, GTxUcastPkt, tx_unicast);
+	FALCON_STAT(efx, GTxMcastPkt, tx_multicast);
+	FALCON_STAT(efx, GTxBcastPkt, tx_broadcast);
+	FALCON_STAT(efx, GTxLt64Pkt, tx_lt64);
+	FALCON_STAT(efx, GTx64Pkt, tx_64);
+	FALCON_STAT(efx, GTx65to127Pkt, tx_65_to_127);
+	FALCON_STAT(efx, GTx128to255Pkt, tx_128_to_255);
+	FALCON_STAT(efx, GTx256to511Pkt, tx_256_to_511);
+	FALCON_STAT(efx, GTx512to1023Pkt, tx_512_to_1023);
+	FALCON_STAT(efx, GTx1024to15xxPkt, tx_1024_to_15xx);
+	FALCON_STAT(efx, GTx15xxtoJumboPkt, tx_15xx_to_jumbo);
+	FALCON_STAT(efx, GTxGtJumboPkt, tx_gtjumbo);
+	FALCON_STAT(efx, GTxNonTcpUdpPkt, tx_non_tcpudp);
+	FALCON_STAT(efx, GTxMacSrcErrPkt, tx_mac_src_error);
+	FALCON_STAT(efx, GTxIpSrcErrPkt, tx_ip_src_error);
+
+	/* Pause frames are erroneously counted as errors (SFC bug 3269) */
+	new_rx_pause = mac_stats->rx_pause;
+	new_tx_pause = mac_stats->tx_pause;
+	mac_stats->rx_bad -= (new_rx_pause - old_rx_pause);
+	mac_stats->tx_bad -= (new_tx_pause - old_tx_pause);
+
+	/* Derive stats that the MAC doesn't provide directly */
+	mac_stats->tx_bad_bytes =
+		mac_stats->tx_bytes - mac_stats->tx_good_bytes;
+	mac_stats->tx_packets =
+		mac_stats->tx_lt64 + mac_stats->tx_64 +
+		mac_stats->tx_65_to_127 + mac_stats->tx_128_to_255 +
+		mac_stats->tx_256_to_511 + mac_stats->tx_512_to_1023 +
+		mac_stats->tx_1024_to_15xx + mac_stats->tx_15xx_to_jumbo +
+		mac_stats->tx_gtjumbo;
+	mac_stats->tx_collision =
+		mac_stats->tx_single_collision +
+		mac_stats->tx_multiple_collision +
+		mac_stats->tx_excessive_collision +
+		mac_stats->tx_late_collision;
+	mac_stats->rx_bytes =
+		mac_stats->rx_good_bytes + mac_stats->rx_bad_bytes;
+	mac_stats->rx_packets =
+		mac_stats->rx_good_lt64 + mac_stats->rx_bad_lt64 +
+		mac_stats->rx_64 + mac_stats->rx_65_to_127 +
+		mac_stats->rx_128_to_255 + mac_stats->rx_256_to_511 +
+		mac_stats->rx_512_to_1023 + mac_stats->rx_1024_to_15xx +
+		mac_stats->rx_15xx_to_jumbo + mac_stats->rx_gtjumbo;
+	mac_stats->rx_good = mac_stats->rx_packets - mac_stats->rx_bad;
+	mac_stats->rx_lt64 = mac_stats->rx_good_lt64 + mac_stats->rx_bad_lt64;
+}
+
+static int falcon_check_gmac(struct efx_nic *efx)
+{
+	/* Nothing to do */
+	return 0;
+}
+
+static void falcon_gmac_sim_phy_event(struct efx_nic *efx)
+{
+	efx_qword_t phy_event;
+
+	EFX_POPULATE_QWORD_2(phy_event,
+			     EV_CODE, GLOBAL_EV_DECODE,
+			     G_PHY0_INTR, 1);
+	falcon_generate_event(&efx->channel[0], &phy_event);
+}
+
+static void falcon_gmac_reset_phy(struct efx_nic *efx)
+{
+	struct mii_if_info *gmii = &efx->mii;
+	int bmcr, i;
+
+	/* Perform software reset to make new settings take effect */
+	bmcr = gmii->mdio_read(gmii->dev, gmii->phy_id, MII_BMCR);
+	bmcr |= BMCR_RESET;
+	gmii->mdio_write(gmii->dev, gmii->phy_id, MII_BMCR, bmcr);
+
+	/* Wait for the reset to deassert */
+	for (i = 20; i; --i) {
+		udelay(10);
+		if ((gmii->mdio_read(gmii->dev, gmii->phy_id, MII_BMCR) &
+		    BMCR_RESET) == 0)
+			return;
+	}
+
+	EFX_ERR(efx, "wait for PHY reset timed out\n");
+}
+
+
+static int falcon_gmac_get_settings(struct efx_nic *efx,
+				    struct ethtool_cmd *ecmd)
+{
+	struct mii_if_info *gmii = &efx->mii;
+	int rc;
+
+	rc = mii_ethtool_gset(gmii, ecmd);
+	ecmd->supported &= ~(SUPPORTED_1000baseT_Half);
+	return rc;
+}
+
+static int falcon_gmac_set_settings(struct efx_nic *efx,
+				    struct ethtool_cmd *ecmd)
+{
+	struct mii_if_info *gmii = &efx->mii;
+	int rc;
+
+	/* 1000Mbps half-duplex is technically legal, but none of our
+	 * current hardware supports it, so just disallow it. */
+	if (ecmd->speed == SPEED_1000 && ecmd->duplex != DUPLEX_FULL) {
+		EFX_LOG(efx, "rejecting unsupported 1000Mbps HD"
+			" setting\n");
+		return -EINVAL;
+	}
+
+	/* Use MII to set all other settings */
+	rc = mii_ethtool_sset(gmii, ecmd);
+	if (rc)
+		return rc;
+
+	/* Reset the PHY */
+	falcon_gmac_reset_phy(efx);
+
+	return 0;
+}
+
+static int falcon_gmac_set_pause(struct efx_nic *efx,
+				 enum efx_fc_type flow_control)
+{
+	struct mii_if_info *gmii = &efx->mii;
+	int adv;
+
+	/* GMAC has tiny MAC FIFO, so TX flow control won't work */
+	if (flow_control & EFX_FC_TX)
+		return -EINVAL;
+
+	efx->flow_control = flow_control;
+
+	/* Push autonegotiation to PHY */
+	adv = gmii->mdio_read(gmii->dev, gmii->phy_id, MII_ADVERTISE);
+	adv &= ~GM_ADVERTISE_PAUSE_CAP;
+	adv |= (flow_control & EFX_FC_AUTO) ? GM_ADVERTISE_PAUSE_CAP : 0;
+	gmii->mdio_write(gmii->dev, gmii->phy_id, MII_ADVERTISE, adv);
+
+	falcon_gmac_reset_phy(efx);
+
+	return 0;
+}
+
+
+struct efx_mac_operations falcon_gmac_operations = {
+	.mac_writel	= falcon_gmac_writel,
+	.mac_readl	= falcon_gmac_readl,
+	.init		= falcon_init_gmac,
+	.reconfigure	= falcon_reconfigure_gmac,
+	.update_stats	= falcon_update_stats_gmac,
+	.fini		= falcon_fini_gmac,
+	.check_hw	= falcon_check_gmac,
+	.fake_phy_event	= falcon_gmac_sim_phy_event,
+	.get_settings   = falcon_gmac_get_settings,
+	.set_settings   = falcon_gmac_set_settings,
+	.set_pause      = falcon_gmac_set_pause,
+};
Index: head-2008-06-18/drivers/net/sfc/falcon_hwdefs.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/falcon_hwdefs.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/falcon_hwdefs.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_FALCON_HWDEFS_H
@@ -37,8 +54,18 @@
 
 /* Interrupt enable register */
 #define INT_EN_REG_KER 0x0010
+#define INT_LEVEL_SEL_LBN 8
+#define INT_LEVEL_SEL_WIDTH 6
+#define MEM_PERR_INT_EN_KER_LBN 5
+#define MEM_PERR_INT_EN_KER_WIDTH 1
+#define KER_INT_CHAR_LBN 4
+#define KER_INT_CHAR_WIDTH 1
 #define KER_INT_KER_LBN 3
 #define KER_INT_KER_WIDTH 1
+#define ILL_ADR_ERR_INT_EN_KER_LBN 2
+#define ILL_ADR_ERR_INT_EN_KER_WIDTH 1
+#define SRM_PERR_INT_EN_KER_LBN 1
+#define SRM_PERR_INT_EN_KER_WIDTH 1
 #define DRV_INT_EN_KER_LBN 0
 #define DRV_INT_EN_KER_WIDTH 1
 
@@ -61,6 +88,17 @@
 /* Interrupt acknowledge work-around register (A0/A1 only )*/
 #define WORK_AROUND_BROKEN_PCI_READS_REG_KER_A1 0x0070
 
+/* Hardware initialisation register */
+#define HW_INIT_REG_KER 0x00c0
+#define BCSR_TARGET_MASK_LBN 101
+#define BCSR_TARGET_MASK_WIDTH 4
+#define PCIE_TIMEOUT_DIS_LBN 123
+#define PCIE_TIMEOUT_DIS_WIDTH 1
+#define B2B_REQ_EN_B0_LBN 45
+#define B2B_REQ_EN_B0_WIDTH 1
+#define FC_BLOCKING_EN_B0_LBN 44
+#define FC_BLOCKING_EN_B0_WIDTH 1
+
 /* SPI host command register */
 #define EE_SPI_HCMD_REG_KER 0x0100
 #define EE_SPI_HCMD_CMD_EN_LBN 31
@@ -86,40 +124,104 @@
 
 /* SPI host address register */
 #define EE_SPI_HADR_REG_KER 0x0110
+#define EE_SPI_HADR_DUBYTE_LBN 24
+#define EE_SPI_HADR_DUBYTE_WIDTH 8
 #define EE_SPI_HADR_ADR_LBN 0
 #define EE_SPI_HADR_ADR_WIDTH 24
 
 /* SPI host data register */
 #define EE_SPI_HDATA_REG_KER 0x0120
+#define EE_SPI_HDATA3_LBN 96
+#define EE_SPI_HDATA3_WIDTH 32
+#define EE_SPI_HDATA2_LBN 64
+#define EE_SPI_HDATA2_WIDTH 32
+#define EE_SPI_HDATA1_LBN 32
+#define EE_SPI_HDATA1_WIDTH 32
+#define EE_SPI_HDATA0_LBN 0
+#define EE_SPI_HDATA0_WIDTH 32
+
+/* SPI/VPD config register */
+#define EE_VPD_CFG_REG_KER 0x0140
+#define EE_VPD_EN_LBN 0
+#define EE_VPD_EN_WIDTH 1
+#define EE_VPD_EN_AD9_MODE_LBN 1
+#define EE_VPD_EN_AD9_MODE_WIDTH 1
+#define EE_EE_CLOCK_DIV_LBN 112
+#define EE_EE_CLOCK_DIV_WIDTH 7
+#define EE_SF_CLOCK_DIV_LBN 120
+#define EE_SF_CLOCK_DIV_WIDTH 7
 
 /* PCIE CORE ACCESS REG */
+#define PCIE_CORE_INDIRECT_REG 0x01f0
+#define PCIE_CORE_ADDR_LBN 0
+#define PCIE_CORE_ADDR_WIDTH 12
+#define PCIE_CORE_RW_LBN 15
+#define PCIE_CORE_RW_WIDTH 1
+#define PCIE_CORE_VALUE_LBN 32
+#define PCIE_CORE_VALUE_WIDTH 32
+
 #define PCIE_CORE_ADDR_PCIE_DEVICE_CTRL_STAT 0x68
 #define PCIE_CORE_ADDR_PCIE_LINK_CTRL_STAT 0x70
 #define PCIE_CORE_ADDR_ACK_RPL_TIMER 0x700
+#define PCIE_CORE_ACK_TL_LBN 0
+#define PCIE_CORE_ACK_TL_WIDTH 16
+#define PCIE_CORE_RPL_TL_LBN 16
+#define PCIE_CORE_RPL_TL_WIDTH 16
+
 #define PCIE_CORE_ADDR_ACK_FREQ 0x70C
+#define PCIE_CORE_ACK_FREQ_LBN 0
+#define PCIE_CORE_ACK_FREQ_WIDTH 7
+
 
 /* NIC status register */
 #define NIC_STAT_REG 0x0200
+#define EE_STRAP_EN_LBN 31
+#define EE_STRAP_EN_WIDTH 1
+#define EE_STRAP_OVR_LBN 24
+#define EE_STRAP_OVR_WIDTH 4
 #define ONCHIP_SRAM_LBN 16
 #define ONCHIP_SRAM_WIDTH 1
 #define SF_PRST_LBN 9
 #define SF_PRST_WIDTH 1
 #define EE_PRST_LBN 8
 #define EE_PRST_WIDTH 1
+#define EE_STRAP_LBN 7
+#define EE_STRAP_WIDTH 1
 /* See pic_mode_t for decoding of this field */
+#define STRAP_ISCSI_EN_LBN 3
+#define STRAP_ISCSI_EN_WIDTH 1
+#define STRAP_PINS_LBN 0
+#define STRAP_PINS_WIDTH 3
 /* These bit definitions are extrapolated from the list of numerical
  * values for STRAP_PINS.
  */
 #define STRAP_10G_LBN 2
 #define STRAP_10G_WIDTH 1
+#define STRAP_DUAL_PORT_LBN 1
+#define STRAP_DUAL_PORT_WIDTH 1
 #define STRAP_PCIE_LBN 0
 #define STRAP_PCIE_WIDTH 1
 
+#define FLASH_PRESENT_LBN 7
+#define FLASH_PRESENT_WIDTH 1
+#define EEPROM_PRESENT_LBN 6
+#define EEPROM_PRESENT_WIDTH 1
+#define BOOTED_USING_NVDEVICE_LBN 3
+#define BOOTED_USING_NVDEVICE_WIDTH 1
+
 /* GPIO control register */
+
 #define GPIO_CTL_REG_KER 0x0210
+
+#define GPIO_USE_NIC_CLK_LBN (30)
+#define GPIO_USE_NIC_CLK_WIDTH (1)
+
 #define GPIO_OUTPUTS_LBN   (16)
 #define GPIO_OUTPUTS_WIDTH (4)
+
 #define GPIO_INPUTS_LBN (8)
+#define GPIO_INPUT_WIDTH (4)
+
 #define GPIO_DIRECTION_LBN (24)
 #define GPIO_DIRECTION_WIDTH (4)
 #define GPIO_DIRECTION_OUT (1)
@@ -145,7 +247,9 @@
 
 #define GPIO3_IN_LBN (GPIO_INPUTS_LBN + 3)
 #define	GPIO3_IN_WIDTH 1
+#define GPIO2_IN_LBN (GPIO_INPUTS_LBN + 2)
 #define	GPIO2_IN_WIDTH 1
+#define GPIO1_IN_LBN (GPIO_INPUTS_LBN + 1)
 #define	GPIO1_IN_WIDTH 1
 #define GPIO0_IN_LBN (GPIO_INPUTS_LBN + 0)
 #define	GPIO0_IN_WIDTH 1
@@ -156,19 +260,29 @@
 #define EXT_PHY_RST_CTL_WIDTH 1
 #define PCIE_SD_RST_CTL_LBN 61
 #define PCIE_SD_RST_CTL_WIDTH 1
+#define PCIX_RST_CTL_LBN 60
+#define PCIX_RST_CTL_WIDTH 1
+#define PCIE_STCK_RST_CTL_LBN 59
 
+#define PCIE_STCK_RST_CTL_WIDTH 1
 #define PCIE_NSTCK_RST_CTL_LBN 58
 #define PCIE_NSTCK_RST_CTL_WIDTH 1
 #define PCIE_CORE_RST_CTL_LBN 57
 #define PCIE_CORE_RST_CTL_WIDTH 1
 #define EE_RST_CTL_LBN 49
 #define EE_RST_CTL_WIDTH 1
+#define CS_RST_CTL_LBN 48
+#define CS_RST_CTL_WIDTH 1
+#define RST_EXT_PHY_LBN 31
+#define RST_EXT_PHY_WIDTH 1
 #define RST_XGRX_LBN 24
 #define RST_XGRX_WIDTH 1
 #define RST_XGTX_LBN 23
 #define RST_XGTX_WIDTH 1
 #define RST_EM_LBN 22
 #define RST_EM_WIDTH 1
+#define INT_RST_DUR_LBN 4
+#define INT_RST_DUR_WIDTH 3
 #define EXT_PHY_RST_DUR_LBN 1
 #define EXT_PHY_RST_DUR_WIDTH 3
 #define SWRST_LBN 0
@@ -178,12 +292,30 @@
 
 /* Fatal interrupt register */
 #define FATAL_INTR_REG_KER 0x0230
+#define PCI_BUSERR_INT_KER_EN_LBN 43
+#define PCI_BUSERR_INT_KER_EN_WIDTH 1
+#define SRAM_OOB_INT_KER_EN_LBN 42
+#define SRAM_OOB_INT_KER_EN_WIDTH 1
+#define BUFID_OOB_INT_KER_EN_LBN 41
+#define BUFID_OOB_INT_KER_EN_WIDTH 1
+#define MEM_PERR_INT_KER_EN_LBN 40
+#define MEM_PERR_INT_KER_EN_WIDTH 1
 #define RBUF_OWN_INT_KER_EN_LBN 39
 #define RBUF_OWN_INT_KER_EN_WIDTH 1
 #define TBUF_OWN_INT_KER_EN_LBN 38
 #define TBUF_OWN_INT_KER_EN_WIDTH 1
+#define RDESCQ_OWN_INT_KER_EN_LBN 37
+#define RDESCQ_OWN_INT_KER_EN_WIDTH 1
+#define TDESCQ_OWN_INT_KER_EN_LBN 36
+#define TDESCQ_OWN_INT_KER_EN_WIDTH 1
+#define EVQ_OWN_INT_KER_EN_LBN 35
+#define EVQ_OWN_INT_KER_EN_WIDTH 1
+#define EVFF_OFLO_INT_KER_EN_LBN 34
+#define EVFF_OFLO_INT_KER_EN_WIDTH 1
 #define ILL_ADR_INT_KER_EN_LBN 33
 #define ILL_ADR_INT_KER_EN_WIDTH 1
+#define SRM_PERR_INT_KER_EN_LBN 32
+#define SRM_PERR_INT_KER_EN_WIDTH 1
 #define MEM_PERR_INT_KER_LBN 8
 #define MEM_PERR_INT_KER_WIDTH 1
 #define INT_KER_ERROR_LBN 0
@@ -196,6 +328,13 @@
 #define MEM_STAT_REG_KER 0x260
 
 /* Debug probe register */
+#define DEBUG_REG_KER 0x0270
+#define DEBUG_BLK_SEL2_LBN 47
+#define DEBUG_BLK_SEL2_WIDTH 3
+#define DEBUG_BLK_SEL1_LBN 44
+#define DEBUG_BLK_SEL1_WIDTH 3
+#define DEBUG_BLK_SEL0_LBN 41
+#define DEBUG_BLK_SEL0_WIDTH 3
 #define DEBUG_BLK_SEL_MISC 7
 #define DEBUG_BLK_SEL_SERDES 6
 #define DEBUG_BLK_SEL_EM 5
@@ -204,16 +343,91 @@
 #define DEBUG_BLK_SEL_RX 2
 #define DEBUG_BLK_SEL_TX 1
 #define DEBUG_BLK_SEL_BIU 0
+#define MISC_DEBUG_ADDR_LBN 36
+#define MISC_DEBUG_ADDR_WIDTH 5
+#define SERDES_DEBUG_ADDR_LBN 31
+#define SERDES_DEBUG_ADDR_WIDTH 5
+#define EM_DEBUG_ADDR_LBN 26
+#define EM_DEBUG_ADDR_WIDTH 5
+#define SR_DEBUG_ADDR_LBN 21
+#define SR_DEBUG_ADDR_WIDTH 5
+#define EV_DEBUG_ADDR_LBN 16
+#define EV_DEBUG_ADDR_WIDTH 5
+#define RX_DEBUG_ADDR_LBN 11
+#define RX_DEBUG_ADDR_WIDTH 5
+#define TX_DEBUG_ADDR_LBN 5
+#define TX_DEBUG_ADDR_WIDTH 5
+#define BIU_DEBUG_ADDR_LBN 1
+#define BIU_DEBUG_ADDR_WIDTH 5
+#define DEBUG_DIS_LBN 0
+#define DEBUG_DIS_WIDTH 1
+
+/* Scratch register 0 */
+#define DRIVER_REG0_KER 0x0280
+#define DRIVER_DW0_LBN 0
+#define DRIVER_DW0_WIDTH 32
+
+/* Scratch register 1 */
+#define DRIVER_REG1_KER 0x0290
+#define DRIVER_DW1_LBN 0
+#define DRIVER_DW1_WIDTH 32
+
+/* Scratch register 2 */
+#define DRIVER_REG2_KER 0x02A0
+#define DRIVER_DW2_LBN 0
+#define DRIVER_DW2_WIDTH 32
+
+/* Scratch register 3 */
+#define DRIVER_REG3_KER 0x02B0
+#define DRIVER_DW3_LBN 0
+#define DRIVER_DW3_WIDTH 32
+
+/* Scratch register 4 */
+#define DRIVER_REG4_KER 0x02C0
+#define DRIVER_DW3_LBN 0
+#define DRIVER_DW3_WIDTH 32
+
+/* Scratch register 5 */
+#define DRIVER_REG5_KER 0x02D0
+#define DRIVER_DW3_LBN 0
+#define DRIVER_DW3_WIDTH 32
+
+/* Scratch register 6 */
+#define DRIVER_REG6_KER 0x02E0
+#define DRIVER_DW3_LBN 0
+#define DRIVER_DW3_WIDTH 32
+
+/* Scratch register 7 */
+#define DRIVER_REG7_KER 0x02F0
+#define DRIVER_DW3_LBN 0
+#define DRIVER_DW3_WIDTH 32
 
 /* FPGA build version */
 #define ALTERA_BUILD_REG_KER 0x0300
+#define VER_MAJOR_LBN 24
+#define VER_MAJOR_WIDTH 8
+#define VER_MINOR_LBN 16
+#define VER_MINOR_WIDTH 8
+#define VER_BUILD_LBN 0
+#define VER_BUILD_WIDTH 16
 #define VER_ALL_LBN 0
 #define VER_ALL_WIDTH 32
 
 /* Spare EEPROM bits register (flash 0x390) */
 #define SPARE_REG_KER 0x310
+#define MEM_PERR_EN_LBN 64
+#define MEM_PERR_EN_WIDTH 38
 #define MEM_PERR_EN_TX_DATA_LBN 72
 #define MEM_PERR_EN_TX_DATA_WIDTH 2
+#define SPARE_EE_BITS_LBN 1
+#define SPARE_EE_BITS_WIDTH 31
+#define PCIE_LEGACY_ENDPOINT_LBN 0
+#define PCIE_LEGACY_ENDPOINT_WIDTH 1
+
+/* Page mapped view of bottom 1024 EVQ RPTRS */
+#define EVQ_RPTR_REG_P0	0x400
+/* Bit definitions are as for the densely mapped
+ * RPTR registers. */
 
 /* Timer table for kernel access */
 #define TIMER_CMD_REG_KER 0x420
@@ -231,6 +445,13 @@
 #define DRV_EV_DATA_LBN 0
 #define DRV_EV_DATA_WIDTH 64
 
+/* Event Queue control register */
+#define EVQ_CTL_REG_KER 0x450
+#define EVQ_FIFO_NOTAF_TH_LBN 0
+#define EVQ_FIFO_NOTAF_TH_WIDTH 6
+#define EVQ_FIFO_AF_TH_LBN 8
+#define EVQ_FIFO_AF_TH_WIDTH 6
+
 /* Buffer table configuration register */
 #define BUF_TBL_CFG_REG_KER 0x600
 #define BUF_TBL_MODE_LBN 3
@@ -250,8 +471,16 @@
 
 /* SRAM configuration register */
 #define SRM_CFG_REG_KER 0x630
+#define SRAM_OOB_ADR_INTEN_LBN 5
+#define SRAM_OOB_ADR_INTEN_WIDTH 1
+#define SRAM_OOB_BUF_INTEN_LBN 4
+#define SRAM_OOB_BUF_INTEN_WIDTH 1
 #define SRAM_OOB_BT_INIT_EN_LBN 3
 #define SRAM_OOB_BT_INIT_EN_WIDTH 1
+#define SRM_NUM_BANK_LBN 2
+#define SRM_NUM_BANK_WIDTH 1
+#define SRM_BANK_SIZE_LBN 0
+#define SRM_BANK_SIZE_WIDTH 2
 #define SRM_NUM_BANKS_AND_BANK_SIZE_LBN 0
 #define SRM_NUM_BANKS_AND_BANK_SIZE_WIDTH 3
 #define SRM_NB_BSZ_1BANKS_2M 0
@@ -278,10 +507,24 @@
 #define RX_CFG_REG_KER 0x800
 
 /* B0 */
+#define RX_TOEP_TCP_SUPPRESS_B0_LBN 48
+#define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
 #define RX_INGR_EN_B0_LBN 47
 #define RX_INGR_EN_B0_WIDTH 1
+#define RX_TOEP_IPV4_B0_LBN 46
+#define RX_TOEP_IPV4_B0_WIDTH 1
+#define RX_HASH_ALG_B0_LBN 45
+#define RX_HASH_ALG_B0_WIDTH 1
+#define RX_HASH_INSERT_HDR_B0_LBN 44
+#define RX_HASH_INSERT_HDR_B0_WIDTH 1
 #define RX_DESC_PUSH_EN_B0_LBN 43
 #define RX_DESC_PUSH_EN_B0_WIDTH 1
+#define RX_RDW_PATCH_EN_LBN 42 /* Non head of line blocking */
+#define RX_RDW_PATCH_EN_WIDTH 1
+#define RX_PCI_BURST_SIZE_B0_LBN 39
+#define RX_PCI_BURST_SIZE_B0_WIDTH 3
+#define RX_OWNERR_CTL_B0_LBN 38
+#define RX_OWNERR_CTL_B0_WIDTH 1
 #define RX_XON_TX_TH_B0_LBN 33
 #define RX_XON_TX_TH_B0_WIDTH 5
 #define RX_XOFF_TX_TH_B0_LBN 28
@@ -298,6 +541,10 @@
 /* A1 */
 #define RX_DESC_PUSH_EN_A1_LBN 35
 #define RX_DESC_PUSH_EN_A1_WIDTH 1
+#define RX_PCI_BURST_SIZE_A1_LBN 31
+#define RX_PCI_BURST_SIZE_A1_WIDTH 3
+#define RX_OWNERR_CTL_A1_LBN 30
+#define RX_OWNERR_CTL_A1_WIDTH 1
 #define RX_XON_TX_TH_A1_LBN 25
 #define RX_XON_TX_TH_A1_WIDTH 5
 #define RX_XOFF_TX_TH_A1_LBN 20
@@ -313,6 +560,8 @@
 
 /* Receive filter control register */
 #define RX_FILTER_CTL_REG 0x810
+#define SCATTER_ENBL_NO_MATCH_Q_B0_LBN 40
+#define SCATTER_ENBL_NO_MATCH_Q_B0_WIDTH 1
 #define UDP_FULL_SRCH_LIMIT_LBN 32
 #define UDP_FULL_SRCH_LIMIT_WIDTH 8
 #define NUM_KER_LBN 24
@@ -332,7 +581,10 @@
 #define RX_FLUSH_DESCQ_WIDTH 12
 
 /* Receive descriptor update register */
-#define RX_DESC_UPD_REG_KER_DWORD (0x830 + 12)
+#define RX_DESC_UPD_REG_KER 0x0830
+#define RX_DESC_WPTR_LBN 96
+#define RX_DESC_WPTR_WIDTH 12
+#define RX_DESC_UPD_REG_KER_DWORD (RX_DESC_UPD_REG_KER + 12)
 #define RX_DESC_WPTR_DWORD_LBN 0
 #define RX_DESC_WPTR_DWORD_WIDTH 12
 
@@ -354,10 +606,14 @@
 #define RX_SELF_RST_REG_KER 0x890
 #define RX_ISCSI_DIS_LBN 17
 #define RX_ISCSI_DIS_WIDTH 1
+#define RX_PREFETCH_TIMEOUT_EN_LBN 10
+#define RX_PREFETCH_TIMEOUT_EN_WIDTH 1
 #define RX_NODESC_WAIT_DIS_LBN 9
 #define RX_NODESC_WAIT_DIS_WIDTH 1
 #define RX_RECOVERY_EN_LBN 8
 #define RX_RECOVERY_EN_WIDTH 1
+#define RX_SHUTDOWN_REASON_LBN	0
+#define RX_SHUTDOWN_REASON_WIDTH (3)
 
 /* TX queue flush register */
 #define TX_FLUSH_DESCQ_REG_KER 0x0a00
@@ -367,7 +623,10 @@
 #define TX_FLUSH_DESCQ_WIDTH 12
 
 /* Transmit descriptor update register */
-#define TX_DESC_UPD_REG_KER_DWORD (0xa10 + 12)
+#define TX_DESC_UPD_REG_KER 0x0a10
+#define TX_DESC_WPTR_LBN 96
+#define TX_DESC_WPTR_WIDTH 12
+#define TX_DESC_UPD_REG_KER_DWORD (TX_DESC_UPD_REG_KER + 12)
 #define TX_DESC_WPTR_DWORD_LBN 0
 #define TX_DESC_WPTR_DWORD_WIDTH 12
 
@@ -394,14 +653,29 @@
 #define TX_SW_EV_EN_WIDTH 1
 #define TX_RX_SPACER_EN_LBN 57
 #define TX_RX_SPACER_EN_WIDTH 1
+#define TX_PREF_WD_TMR_LBN 22
+#define TX_PREF_WD_TMR_WIDTH 22
 #define TX_PREF_THRESHOLD_LBN 19
 #define TX_PREF_THRESHOLD_WIDTH 2
 #define TX_ONE_PKT_PER_Q_LBN 18
 #define TX_ONE_PKT_PER_Q_WIDTH 1
 #define TX_DIS_NON_IP_EV_LBN 17
 #define TX_DIS_NON_IP_EV_WIDTH 1
+#define TX_DMA_SPACER_LBN 8
+#define TX_DMA_SPACER_WIDTH 8
 #define TX_FLUSH_MIN_LEN_EN_B0_LBN 7
 #define TX_FLUSH_MIN_LEN_EN_B0_WIDTH 1
+#define TX_TCP_DIS_A1_LBN 7
+#define TX_TCP_DIS_A1_WIDTH 1
+#define TX_IP_DIS_A1_LBN 6
+#define TX_IP_DIS_A1_WIDTH 1
+#define TX_MAX_CPL_LBN 2
+#define TX_MAX_CPL_WIDTH 2
+#define TX_MAX_PREF_LBN 0
+#define TX_MAX_PREF_WIDTH 2
+
+/* Transmit VLAN filter control register */
+#define TX_VLAN_REG 0xae0
 
 /* PHY management transmit data register */
 #define MD_TXD_REG_KER 0xc00
@@ -415,8 +689,16 @@
 
 /* PHY management configuration & status register */
 #define MD_CS_REG_KER 0xc20
+#define MD_PT_LBN 7
+#define MD_PT_WIDTH 3
+#define MD_PL_LBN 6
+#define MD_PL_WIDTH 1
+#define MD_INT_CLR_LBN 5
+#define MD_INT_CLR_WIDTH 1
 #define MD_GC_LBN 4
 #define MD_GC_WIDTH 1
+#define MD_PRSP_LBN 3
+#define MD_PRSP_WIDTH 1
 #define MD_RIC_LBN 2
 #define MD_RIC_WIDTH 1
 #define MD_RDC_LBN 1
@@ -441,6 +723,10 @@
 
 /* PHY management status & mask register (DWORD read only) */
 #define MD_STAT_REG_KER 0xc50
+#define MD_PINT_LBN 4
+#define MD_PINT_WIDTH 1
+#define MD_DONE_LBN 3
+#define MD_DONE_WIDTH 1
 #define MD_BSERR_LBN 2
 #define MD_BSERR_WIDTH 1
 #define MD_LNFL_LBN 1
@@ -450,17 +736,23 @@
 
 /* Port 0 and 1 MAC stats registers */
 #define MAC0_STAT_DMA_REG_KER 0xc60
+#define MAC1_STAT_DMA_REG_KER 0xc70
 #define MAC_STAT_DMA_CMD_LBN 48
 #define MAC_STAT_DMA_CMD_WIDTH 1
+#define MAC_STAT_DMA_REGION_LBN 46
+#define MAC_STAT_DMA_REGION_WIDTH 2
 #define MAC_STAT_DMA_ADR_LBN 0
 #define MAC_STAT_DMA_ADR_WIDTH EFX_DMA_TYPE_WIDTH(46)
 
 /* Port 0 and 1 MAC control registers */
 #define MAC0_CTRL_REG_KER 0xc80
+#define MAC1_CTRL_REG_KER 0xc90
 #define MAC_XOFF_VAL_LBN 16
 #define MAC_XOFF_VAL_WIDTH 16
 #define TXFIFO_DRAIN_EN_B0_LBN 7
 #define TXFIFO_DRAIN_EN_B0_WIDTH 1
+#define MAC_XG_DISTXCRC_LBN 5
+#define MAC_XG_DISTXCRC_WIDTH 1
 #define MAC_BCAD_ACPT_LBN 4
 #define MAC_BCAD_ACPT_WIDTH 1
 #define MAC_UC_PROM_LBN 3
@@ -470,6 +762,18 @@
 #define MAC_SPEED_LBN 0
 #define MAC_SPEED_WIDTH 2
 
+/* External interrupt control (replaces MAC1_CTRL in B0) */
+#define GEN_MODE_REG_KER 0xc90
+#define XFP_PHY_INT_POL_SEL_LBN 3
+#define XFP_PHY_INT_POL_SEL_WIDTH 1
+#define XG_PHY_INT_POL_SEL_LBN 2
+#define XG_PHY_INT_POL_SEL_WIDTH 1
+#define XFP_PHY_INT_MASK_LBN 1
+#define XFP_PHY_INT_MASK_WIDTH 1
+#define XG_PHY_INT_MASK_LBN 0
+#define XG_PHY_INT_MASK_WIDTH 1
+
+
 /* 10G XAUI XGXS default values */
 #define XX_TXDRV_DEQ_DEFAULT 0xe /* deq=.6 */
 #define XX_TXDRV_DTX_DEFAULT 0x5 /* 1.25 */
@@ -479,11 +783,19 @@
 #define MAC_MCAST_HASH_REG0_KER 0xca0
 #define MAC_MCAST_HASH_REG1_KER 0xcb0
 
+/* MAC test register. */
+#define MAC_TEST_REG_KER 0xcc0
+#define MAC_PTLOOP_EN_LBN 0
+#define MAC_PTLOOP_EN_WIDTH 1
+
 /* GMAC registers */
 #define FALCON_GMAC_REGBANK 0xe00
 #define FALCON_GMAC_REGBANK_SIZE 0x200
 #define FALCON_GMAC_REG_SIZE 0x10
 
+/* Source MAC filter control register */
+#define TX_SRC_MAC_CTRL_REG 0x1100
+
 /* XMAC registers */
 #define FALCON_XMAC_REGBANK 0x1200
 #define FALCON_XMAC_REGBANK_SIZE 0x200
@@ -509,12 +821,22 @@
 
 /* XGMAC global configuration */
 #define XM_GLB_CFG_REG_MAC 0x02
+#define XM_LINE_LB_DEEP_RSVD_LBN 28
+#define XM_LINE_LB_DEEP_RSVD_WIDTH 1
+#define XM_RMTFLT_GEN_LBN 17
+#define XM_RMTFLT_GEN_WIDTH 1
+#define XM_DEBUG_MODE_LBN 16
+#define XM_DEBUG_MODE_WIDTH 1
 #define XM_RX_STAT_EN_LBN 11
 #define XM_RX_STAT_EN_WIDTH 1
 #define XM_TX_STAT_EN_LBN 10
 #define XM_TX_STAT_EN_WIDTH 1
 #define XM_RX_JUMBO_MODE_LBN 6
 #define XM_RX_JUMBO_MODE_WIDTH 1
+#define XM_WAN_MODE_LBN 5
+#define XM_WAN_MODE_WIDTH 1
+#define XM_AUTOCLR_MODE_LBN 4
+#define XM_AUTOCLR_MODE_WIDTH 1
 #define XM_INTCLR_MODE_LBN 3
 #define XM_INTCLR_MODE_WIDTH 1
 #define XM_CORE_RST_LBN 0
@@ -522,32 +844,56 @@
 
 /* XGMAC transmit configuration */
 #define XM_TX_CFG_REG_MAC 0x03
+#define XM_TX_PROG_LBN 24
+#define XM_TX_PROG_WIDTH 1
 #define XM_IPG_LBN 16
 #define XM_IPG_WIDTH 4
 #define XM_FCNTL_LBN 10
 #define XM_FCNTL_WIDTH 1
 #define XM_TXCRC_LBN 8
 #define XM_TXCRC_WIDTH 1
+#define XM_EDRC_LBN 6
+#define XM_EDRC_WIDTH 1
 #define XM_AUTO_PAD_LBN 5
 #define XM_AUTO_PAD_WIDTH 1
 #define XM_TX_PRMBL_LBN 2
 #define XM_TX_PRMBL_WIDTH 1
 #define XM_TXEN_LBN 1
 #define XM_TXEN_WIDTH 1
+#define XM_TX_RST_LBN 0
+#define XM_TX_RST_WIDTH 1
 
 /* XGMAC receive configuration */
 #define XM_RX_CFG_REG_MAC 0x04
+#define XM_PASS_LENERR_LBN 26
+#define XM_PASS_LENERR_WIDTH 1
 #define XM_PASS_CRC_ERR_LBN 25
 #define XM_PASS_CRC_ERR_WIDTH 1
+#define XM_PASS_PRMBLE_ERR_LBN 24
+#define XM_PASS_PRMBLE_ERR_WIDTH 1
 #define XM_ACPT_ALL_MCAST_LBN 11
 #define XM_ACPT_ALL_MCAST_WIDTH 1
 #define XM_ACPT_ALL_UCAST_LBN 9
 #define XM_ACPT_ALL_UCAST_WIDTH 1
 #define XM_AUTO_DEPAD_LBN 8
 #define XM_AUTO_DEPAD_WIDTH 1
+#define XM_RXCRC_LBN 3
+#define XM_RXCRC_WIDTH 1
+#define XM_RX_PRMBL_LBN 2
+#define XM_RX_PRMBL_WIDTH 1
 #define XM_RXEN_LBN 1
 #define XM_RXEN_WIDTH 1
+#define XM_RX_RST_LBN 0
+#define XM_RX_RST_WIDTH 1
 
+/* XGMAC flow control register */
+#define XM_FC_REG_MAC 0x7
+#define XM_PAUSE_TIME_LBN 16
+#define XM_PAUSE_TIME_WIDTH 16
+#define XM_DIS_FCNTL_LBN 0
+#define XM_DIS_FCNTL_WIDTH 1
+
+/* XGMAC pause time count register */
 /* XGMAC management interrupt mask register */
 #define XM_MGT_INT_MSK_REG_MAC_B0 0x5
 #define XM_MSK_PRMBLE_ERR_LBN 2
@@ -557,15 +903,11 @@
 #define XM_MSK_LCLFLT_LBN 0
 #define XM_MSK_LCLFLT_WIDTH 1
 
-/* XGMAC flow control register */
-#define XM_FC_REG_MAC 0x7
-#define XM_PAUSE_TIME_LBN 16
-#define XM_PAUSE_TIME_WIDTH 16
-#define XM_DIS_FCNTL_LBN 0
-#define XM_DIS_FCNTL_WIDTH 1
-
-/* XGMAC pause time count register */
 #define XM_PAUSE_TIME_REG_MAC 0x9
+#define XM_TX_PAUSE_CNT_LBN 16
+#define XM_TX_PAUSE_CNT_WIDTH 16
+#define XM_RX_PAUSE_CNT_LBN 0
+#define XM_RX_PAUSE_CNT_WIDTH 16
 
 /* XGMAC transmit parameter register */
 #define XM_TX_PARAM_REG_MAC 0x0d
@@ -573,12 +915,22 @@
 #define XM_TX_JUMBO_MODE_WIDTH 1
 #define XM_MAX_TX_FRM_SIZE_LBN 16
 #define XM_MAX_TX_FRM_SIZE_WIDTH 14
+#define XM_PAD_CHAR_LBN 0
+#define XM_PAD_CHAR_WIDTH 8
 
 /* XGMAC receive parameter register */
 #define XM_RX_PARAM_REG_MAC 0x0e
 #define XM_MAX_RX_FRM_SIZE_LBN 0
 #define XM_MAX_RX_FRM_SIZE_WIDTH 14
 
+/* XGXS/XAUI powerdown/reset register */
+#define XX_PWR_RST_REG_MAC 0x10
+
+#define XX_PWRDND_EN_LBN 15
+#define XX_PWRDND_EN_WIDTH 1
+#define XX_PWRDNC_EN_LBN 14
+#define XX_PWRDNC_EN_WIDTH 1
+#define XX_PWRDNB_EN_LBN 13
 /* XGMAC management interrupt status register */
 #define XM_MGT_INT_REG_MAC_B0 0x0f
 #define XM_PRMBLE_ERR 2
@@ -588,14 +940,6 @@
 #define XM_LCLFLT_LBN 0
 #define XM_LCLFLT_WIDTH 1
 
-/* XGXS/XAUI powerdown/reset register */
-#define XX_PWR_RST_REG_MAC 0x10
-
-#define XX_PWRDND_EN_LBN 15
-#define XX_PWRDND_EN_WIDTH 1
-#define XX_PWRDNC_EN_LBN 14
-#define XX_PWRDNC_EN_WIDTH 1
-#define XX_PWRDNB_EN_LBN 13
 #define XX_PWRDNB_EN_WIDTH 1
 #define XX_PWRDNA_EN_LBN 12
 #define XX_PWRDNA_EN_WIDTH 1
@@ -620,6 +964,10 @@
 
 /* XGXS/XAUI powerdown/reset control register */
 #define XX_SD_CTL_REG_MAC 0x11
+#define XX_TERMADJ1_LBN 17
+#define XX_TERMADJ1_WIDTH 1
+#define XX_TERMADJ0_LBN 16
+#define XX_TERMADJ0_WIDTH 1
 #define XX_HIDRVD_LBN 15
 #define XX_HIDRVD_WIDTH 1
 #define XX_LODRVD_LBN 14
@@ -664,7 +1012,6 @@
 #define XX_DTXA_WIDTH 4
 
 /* XAUI XGXS core status register */
-#define XX_CORE_STAT_REG_MAC 0x16
 #define XX_FORCE_SIG_LBN 24
 #define XX_FORCE_SIG_WIDTH 8
 #define XX_FORCE_SIG_DECODE_FORCED 0xff
@@ -672,6 +1019,7 @@
 #define XX_XGXS_LB_EN_WIDTH 1
 #define XX_XGMII_LB_EN_LBN 22
 #define XX_XGMII_LB_EN_WIDTH 1
+#define XX_CORE_STAT_REG_MAC 0x16
 #define XX_ALIGN_DONE_LBN 20
 #define XX_ALIGN_DONE_WIDTH 1
 #define XX_SYNC_STAT_LBN 16
@@ -699,6 +1047,14 @@
 #define RX_ISCSI_DDIG_EN_WIDTH 1
 #define RX_ISCSI_HDIG_EN_LBN 87
 #define RX_ISCSI_HDIG_EN_WIDTH 1
+#define RX_DESC_PREF_ACT_LBN 86
+#define RX_DESC_PREF_ACT_WIDTH 1
+#define RX_DC_HW_RPTR_LBN 80
+#define RX_DC_HW_RPTR_WIDTH 6
+#define RX_DESCQ_HW_RPTR_LBN 68
+#define RX_DESCQ_HW_RPTR_WIDTH 12
+#define RX_DESCQ_SW_WPTR_LBN 56
+#define RX_DESCQ_SW_WPTR_WIDTH 12
 #define RX_DESCQ_BUF_BASE_ID_LBN 36
 #define RX_DESCQ_BUF_BASE_ID_WIDTH 20
 #define RX_DESCQ_EVQ_ID_LBN 24
@@ -736,6 +1092,12 @@
 #define TX_ISCSI_DDIG_EN_WIDTH 1
 #define TX_ISCSI_HDIG_EN_LBN 86
 #define TX_ISCSI_HDIG_EN_WIDTH 1
+#define TX_DC_HW_RPTR_LBN 80
+#define TX_DC_HW_RPTR_WIDTH 6
+#define TX_DESCQ_HW_RPTR_LBN 68
+#define TX_DESCQ_HW_RPTR_WIDTH 12
+#define TX_DESCQ_SW_WPTR_LBN 56
+#define TX_DESCQ_SW_WPTR_WIDTH 12
 #define TX_DESCQ_BUF_BASE_ID_LBN 36
 #define TX_DESCQ_BUF_BASE_ID_WIDTH 20
 #define TX_DESCQ_EVQ_ID_LBN 24
@@ -752,11 +1114,17 @@
 #define TX_DESCQ_SIZE_512 0
 #define TX_DESCQ_TYPE_LBN 1
 #define TX_DESCQ_TYPE_WIDTH 2
+#define TX_DESCQ_FLUSH_LBN 0
+#define TX_DESCQ_FLUSH_WIDTH 1
 
 /* Event queue pointer */
 #define EVQ_PTR_TBL_KER_A1 0x11a00
 #define EVQ_PTR_TBL_KER_B0 0xf60000
 #define EVQ_PTR_TBL_KER_P0 0x500
+#define EVQ_WKUP_OR_INT_EN_LBN 39
+#define EVQ_WKUP_OR_INT_EN_WIDTH 1
+#define EVQ_NXT_WPTR_LBN 24
+#define EVQ_NXT_WPTR_WIDTH 15
 #define EVQ_EN_LBN 23
 #define EVQ_EN_WIDTH 1
 #define EVQ_SIZE_LBN 20
@@ -774,6 +1142,8 @@
 /* Event queue read pointer */
 #define EVQ_RPTR_REG_KER_A1 0x11b00
 #define EVQ_RPTR_REG_KER_B0 0xfa0000
+#define EVQ_RPTR_LBN 0
+#define EVQ_RPTR_WIDTH 14
 #define EVQ_RPTR_REG_KER_DWORD (EVQ_RPTR_REG_KER + 0)
 #define EVQ_RPTR_DWORD_LBN 0
 #define EVQ_RPTR_DWORD_WIDTH 14
@@ -797,6 +1167,20 @@
 #define BUF_OWNER_ID_FBUF_LBN 0
 #define BUF_OWNER_ID_FBUF_WIDTH 14
 
+/* Special buffer descriptors (half-mode) */
+#define BUF_HALF_TBL_KER_A1 0x8000
+#define BUF_HALF_TBL_KER_B0 0x800000
+#define BUF_ADR_HBUF_ODD_LBN 44
+#define BUF_ADR_HBUF_ODD_WIDTH 20
+#define BUF_OWNER_ID_HBUF_ODD_LBN 32
+#define BUF_OWNER_ID_HBUF_ODD_WIDTH 12
+#define BUF_ADR_HBUF_EVEN_LBN 12
+#define BUF_ADR_HBUF_EVEN_WIDTH 20
+#define BUF_OWNER_ID_HBUF_EVEN_LBN 0
+#define BUF_OWNER_ID_HBUF_EVEN_WIDTH 12
+
+#define SRM_DBG_REG_B0 0x3000000
+
 /* Transmit descriptor */
 #define TX_KER_PORT_LBN 63
 #define TX_KER_PORT_WIDTH 1
@@ -880,28 +1264,44 @@
 #define RX_EV_HDR_TYPE_NON_IP_DECODE 3
 #define RX_EV_HDR_TYPE_HAS_CHECKSUMS(hdr_type) \
 	((hdr_type) <= RX_EV_HDR_TYPE_UDP_IPV4_DECODE)
+#define RX_EV_DESC_Q_EMPTY_LBN 41
+#define RX_EV_DESC_Q_EMPTY_WIDTH 1
 #define RX_EV_MCAST_HASH_MATCH_LBN 40
 #define RX_EV_MCAST_HASH_MATCH_WIDTH 1
 #define RX_EV_MCAST_PKT_LBN 39
 #define RX_EV_MCAST_PKT_WIDTH 1
+#define RX_EV_RECOVERY_FLAG_LBN 37
+#define RX_EV_RECOVERY_FLAG_WIDTH 1
 #define RX_EV_Q_LABEL_LBN 32
 #define RX_EV_Q_LABEL_WIDTH 5
 #define RX_EV_JUMBO_CONT_LBN 31
 #define RX_EV_JUMBO_CONT_WIDTH 1
+#define RX_EV_PORT_LBN 30
+#define RX_EV_PORT_WIDTH 1
 #define RX_EV_BYTE_CNT_LBN 16
 #define RX_EV_BYTE_CNT_WIDTH 14
 #define RX_EV_SOP_LBN 15
 #define RX_EV_SOP_WIDTH 1
+#define RX_ISCSI_DDIG_ERR_LBN 13
+#define RX_ISCSI_DDIG_ERR_WIDTH 1
+#define RX_ISCSI_HDIG_ERR_LBN 12
+#define RX_ISCSI_HDIG_ERR_WIDTH 1
 #define RX_EV_DESC_PTR_LBN 0
 #define RX_EV_DESC_PTR_WIDTH 12
 
 /* Transmit events */
 #define TX_EV_PKT_ERR_LBN 38
 #define TX_EV_PKT_ERR_WIDTH 1
+#define TX_EV_PKT_TOO_BIG_LBN 37
+#define TX_EV_PKT_TOO_BIG_WIDTH 1
 #define TX_EV_Q_LABEL_LBN 32
 #define TX_EV_Q_LABEL_WIDTH 5
+#define TX_EV_PORT_LBN 16
+#define TX_EV_PORT_WIDTH 1
 #define TX_EV_WQ_FF_FULL_LBN 15
 #define TX_EV_WQ_FF_FULL_WIDTH 1
+#define TX_EV_BUF_OWNER_ID_ERR_LBN 14
+#define TX_EV_BUF_OWNER_ID_ERR_WIDTH 1
 #define TX_EV_COMP_LBN 12
 #define TX_EV_COMP_WIDTH 1
 #define TX_EV_DESC_PTR_LBN 0
@@ -930,6 +1330,10 @@
 #define DRIVER_EV_RX_FLUSH_FAIL_WIDTH 1
 #define DRIVER_EV_RX_DESCQ_ID_LBN 0
 #define DRIVER_EV_RX_DESCQ_ID_WIDTH 12
+#define DRIVER_EV_EVQ_ID_LBN 0
+#define DRIVER_EV_EVQ_ID_WIDTH 12
+#define DRIVER_EV_SRM_UPD_LBN 0
+#define DRIVER_EV_SRM_UPD_WIDTH 2
 #define SRM_CLR_EV_DECODE 0
 #define SRM_UPD_EV_DECODE 1
 #define SRM_ILLCLR_EV_DECODE 2
@@ -939,8 +1343,12 @@
 #define RX_RECOVERY_B0_WIDTH 1
 #define XG_MNT_INTR_B0_LBN 11
 #define XG_MNT_INTR_B0_WIDTH 1
+
 #define RX_RECOVERY_A1_LBN 11
 #define RX_RECOVERY_A1_WIDTH 1
+
+#define XFP_PHY_INTR_LBN 10
+#define XFP_PHY_INTR_WIDTH 1
 #define XG_PHY_INTR_LBN 9
 #define XG_PHY_INTR_WIDTH 1
 #define G_PHY1_INTR_LBN 8
@@ -949,6 +1357,10 @@
 #define G_PHY0_INTR_WIDTH 1
 
 /* Driver-generated test events */
+#define DRV_GEN_EV_CODE_LBN 60
+#define DRV_GEN_EV_CODE_WIDTH 4
+#define DRV_GEN_EV_DATA_LBN 0
+#define DRV_GEN_EV_DATA_WIDTH 60
 #define EVQ_MAGIC_LBN 0
 #define EVQ_MAGIC_WIDTH 32
 
@@ -959,54 +1371,103 @@
  **************************************************************************
  *
  */
+
 #define GRxGoodOct_offset 0x0
+#define GRxGoodOct_WIDTH 48
 #define GRxBadOct_offset 0x8
+#define GRxBadOct_WIDTH 48
 #define GRxMissPkt_offset 0x10
+#define GRxMissPkt_WIDTH 32
 #define GRxFalseCRS_offset 0x14
+#define GRxFalseCRS_WIDTH 32
 #define GRxPausePkt_offset 0x18
+#define GRxPausePkt_WIDTH 32
 #define GRxBadPkt_offset 0x1C
+#define GRxBadPkt_WIDTH 32
 #define GRxUcastPkt_offset 0x20
+#define GRxUcastPkt_WIDTH 32
 #define GRxMcastPkt_offset 0x24
+#define GRxMcastPkt_WIDTH 32
 #define GRxBcastPkt_offset 0x28
+#define GRxBcastPkt_WIDTH 32
 #define GRxGoodLt64Pkt_offset 0x2C
+#define GRxGoodLt64Pkt_WIDTH 32
 #define GRxBadLt64Pkt_offset 0x30
+#define GRxBadLt64Pkt_WIDTH 32
 #define GRx64Pkt_offset 0x34
+#define GRx64Pkt_WIDTH 32
 #define GRx65to127Pkt_offset 0x38
+#define GRx65to127Pkt_WIDTH 32
 #define GRx128to255Pkt_offset 0x3C
+#define GRx128to255Pkt_WIDTH 32
 #define GRx256to511Pkt_offset 0x40
+#define GRx256to511Pkt_WIDTH 32
 #define GRx512to1023Pkt_offset 0x44
+#define GRx512to1023Pkt_WIDTH 32
 #define GRx1024to15xxPkt_offset 0x48
+#define GRx1024to15xxPkt_WIDTH 32
 #define GRx15xxtoJumboPkt_offset 0x4C
+#define GRx15xxtoJumboPkt_WIDTH 32
 #define GRxGtJumboPkt_offset 0x50
+#define GRxGtJumboPkt_WIDTH 32
 #define GRxFcsErr64to15xxPkt_offset 0x54
+#define GRxFcsErr64to15xxPkt_WIDTH 32
 #define GRxFcsErr15xxtoJumboPkt_offset 0x58
+#define GRxFcsErr15xxtoJumboPkt_WIDTH 32
 #define GRxFcsErrGtJumboPkt_offset 0x5C
+#define GRxFcsErrGtJumboPkt_WIDTH 32
 #define GTxGoodBadOct_offset 0x80
+#define GTxGoodBadOct_WIDTH 48
 #define GTxGoodOct_offset 0x88
+#define GTxGoodOct_WIDTH 48
 #define GTxSglColPkt_offset 0x90
+#define GTxSglColPkt_WIDTH 32
 #define GTxMultColPkt_offset 0x94
+#define GTxMultColPkt_WIDTH 32
 #define GTxExColPkt_offset 0x98
+#define GTxExColPkt_WIDTH 32
 #define GTxDefPkt_offset 0x9C
+#define GTxDefPkt_WIDTH 32
 #define GTxLateCol_offset 0xA0
+#define GTxLateCol_WIDTH 32
 #define GTxExDefPkt_offset 0xA4
+#define GTxExDefPkt_WIDTH 32
 #define GTxPausePkt_offset 0xA8
+#define GTxPausePkt_WIDTH 32
 #define GTxBadPkt_offset 0xAC
+#define GTxBadPkt_WIDTH 32
 #define GTxUcastPkt_offset 0xB0
+#define GTxUcastPkt_WIDTH 32
 #define GTxMcastPkt_offset 0xB4
+#define GTxMcastPkt_WIDTH 32
 #define GTxBcastPkt_offset 0xB8
+#define GTxBcastPkt_WIDTH 32
 #define GTxLt64Pkt_offset 0xBC
+#define GTxLt64Pkt_WIDTH 32
 #define GTx64Pkt_offset 0xC0
+#define GTx64Pkt_WIDTH 32
 #define GTx65to127Pkt_offset 0xC4
+#define GTx65to127Pkt_WIDTH 32
 #define GTx128to255Pkt_offset 0xC8
+#define GTx128to255Pkt_WIDTH 32
 #define GTx256to511Pkt_offset 0xCC
+#define GTx256to511Pkt_WIDTH 32
 #define GTx512to1023Pkt_offset 0xD0
+#define GTx512to1023Pkt_WIDTH 32
 #define GTx1024to15xxPkt_offset 0xD4
+#define GTx1024to15xxPkt_WIDTH 32
 #define GTx15xxtoJumboPkt_offset 0xD8
+#define GTx15xxtoJumboPkt_WIDTH 32
 #define GTxGtJumboPkt_offset 0xDC
+#define GTxGtJumboPkt_WIDTH 32
 #define GTxNonTcpUdpPkt_offset 0xE0
+#define GTxNonTcpUdpPkt_WIDTH 16
 #define GTxMacSrcErrPkt_offset 0xE4
+#define GTxMacSrcErrPkt_WIDTH 16
 #define GTxIpSrcErrPkt_offset 0xE8
+#define GTxIpSrcErrPkt_WIDTH 16
 #define GDmaDone_offset 0xEC
+#define GDmaDone_WIDTH 32
 
 #define XgRxOctets_offset 0x0
 #define XgRxOctets_WIDTH 48
@@ -1099,6 +1560,7 @@
 #define XgTxIpSrcErrPkt_offset 0xD0
 #define XgTxIpSrcErrPkt_WIDTH 16
 #define XgDmaDone_offset 0xD4
+#define XgDmaDone_WIDTH 32
 
 #define FALCON_STATS_NOT_DONE 0x00000000
 #define FALCON_STATS_DONE 0xffffffff
@@ -1108,6 +1570,12 @@
 #define FATAL_INT_WIDTH 1
 #define INT_EVQS_LBN 40
 #define INT_EVQS_WIDTH 4
+#define INT_FLAG_LBN 32
+#define INT_FLAG_WIDTH 1
+#define EVQ_FIFO_HF_LBN 1
+#define EVQ_FIFO_HF_WIDTH 1
+#define EVQ_FIFO_AF_LBN 0
+#define EVQ_FIFO_AF_WIDTH 1
 
 /**************************************************************************
  *
@@ -1125,7 +1593,26 @@ struct falcon_nvconfig_board_v2 {
 	u8 port1_phy_type;
 	__le16 asic_sub_revision;
 	__le16 board_revision;
-} __packed;
+} __attribute__ ((packed));
+
+/* Board configuration v3 extra information */
+struct falcon_nvconfig_board_v3 {
+	__le32 spi_device_type[2];
+} __attribute__ ((packed));
+
+/* Bit numbers for spi_device_type */
+#define SPI_DEV_TYPE_SIZE_LBN 0
+#define SPI_DEV_TYPE_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_ADDR_LEN_LBN 6
+#define SPI_DEV_TYPE_ADDR_LEN_WIDTH 2
+#define SPI_DEV_TYPE_ERASE_CMD_LBN 8
+#define SPI_DEV_TYPE_ERASE_CMD_WIDTH 8
+#define SPI_DEV_TYPE_ERASE_SIZE_LBN 16
+#define SPI_DEV_TYPE_ERASE_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_BLOCK_SIZE_LBN 24
+#define SPI_DEV_TYPE_BLOCK_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_FIELD(type, field) \
+	(((type) >> EFX_LOW_BIT(field)) & EFX_MASK32(field))
 
 #define NVCONFIG_BASE 0x300
 #define NVCONFIG_BOARD_MAGIC_NUM 0xFA1C
@@ -1144,6 +1631,8 @@ struct falcon_nvconfig {
 	__le16 board_struct_ver;
 	__le16 board_checksum;
 	struct falcon_nvconfig_board_v2 board_v2;
-} __packed;
+	efx_oword_t ee_base_page_reg;			/* 0x3B0 */
+	struct falcon_nvconfig_board_v3 board_v3;	/* 0x3C0 */
+} __attribute__ ((packed));
 
 #endif /* EFX_FALCON_HWDEFS_H */
Index: head-2008-06-18/drivers/net/sfc/falcon_io.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/falcon_io.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/falcon_io.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,19 +1,35 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_FALCON_IO_H
 #define EFX_FALCON_IO_H
 
-#include <linux/io.h>
-#include <linux/spinlock.h>
 #include "net_driver.h"
+#include "falcon.h"
 
 /**************************************************************************
  *
@@ -56,33 +72,20 @@
 #define FALCON_USE_QWORD_IO 1
 #endif
 
-#ifdef FALCON_USE_QWORD_IO
-static inline void _falcon_writeq(struct efx_nic *efx, __le64 value,
-				  unsigned int reg)
-{
-	__raw_writeq((__force u64)value, efx->membase + reg);
-}
-static inline __le64 _falcon_readq(struct efx_nic *efx, unsigned int reg)
-{
-	return (__force __le64)__raw_readq(efx->membase + reg);
-}
-#endif
-
-static inline void _falcon_writel(struct efx_nic *efx, __le32 value,
-				  unsigned int reg)
-{
-	__raw_writel((__force u32)value, efx->membase + reg);
-}
-static inline __le32 _falcon_readl(struct efx_nic *efx, unsigned int reg)
-{
-	return (__force __le32)__raw_readl(efx->membase + reg);
-}
+#define _falcon_writeq(efx, value, reg) \
+	__raw_writeq((__force u64) (value), (efx)->membase + (reg))
+#define _falcon_writel(efx, value, reg) \
+	__raw_writel((__force u32) (value), (efx)->membase + (reg))
+#define _falcon_readq(efx, reg) \
+	((__force __le64) __raw_readq((efx)->membase + (reg)))
+#define _falcon_readl(efx, reg) \
+	((__force __le32) __raw_readl((efx)->membase + (reg)))
 
 /* Writes to a normal 16-byte Falcon register, locking as appropriate. */
 static inline void falcon_write(struct efx_nic *efx, efx_oword_t *value,
 				unsigned int reg)
 {
-	unsigned long flags;
+	unsigned long flags __attribute__ ((unused));
 
 	EFX_REGDUMP(efx, "writing register %x with " EFX_OWORD_FMT "\n", reg,
 		    EFX_OWORD_VAL(*value));
@@ -108,7 +111,7 @@ static inline void falcon_write_sram(str
 				     unsigned int index)
 {
 	unsigned int reg = efx->type->buf_tbl_base + (index * sizeof(*value));
-	unsigned long flags;
+	unsigned long flags __attribute__ ((unused));
 
 	EFX_REGDUMP(efx, "writing SRAM register %x with " EFX_QWORD_FMT "\n",
 		    reg, EFX_QWORD_VAL(*value));
@@ -150,7 +153,7 @@ static inline void falcon_writel(struct 
 static inline void falcon_read(struct efx_nic *efx, efx_oword_t *value,
 			       unsigned int reg)
 {
-	unsigned long flags;
+	unsigned long flags __attribute__ ((unused));
 
 	spin_lock_irqsave(&efx->biu_lock, flags);
 	value->u32[0] = _falcon_readl(efx, reg + 0);
@@ -169,7 +172,7 @@ static inline void falcon_read_sram(stru
 				    unsigned int index)
 {
 	unsigned int reg = efx->type->buf_tbl_base + (index * sizeof(*value));
-	unsigned long flags;
+	unsigned long flags __attribute__ ((unused));
 
 	spin_lock_irqsave(&efx->biu_lock, flags);
 #ifdef FALCON_USE_QWORD_IO
@@ -246,7 +249,7 @@ static inline void falcon_writel_page_lo
 					     unsigned int reg,
 					     unsigned int page)
 {
-	unsigned long flags;
+	unsigned long flags __attribute__ ((unused));
 
 	spin_lock_irqsave(&efx->biu_lock, flags);
 	falcon_writel(efx, value, FALCON_PAGED_REG(page, reg));
Index: head-2008-06-18/drivers/net/sfc/falcon_xmac.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/falcon_xmac.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/falcon_xmac.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #include <linux/delay.h>
@@ -31,8 +48,8 @@
 #define FALCON_XMAC_REG(mac_reg)					\
 	(FALCON_XMAC_REGBANK + ((mac_reg) * FALCON_XMAC_REG_SIZE))
 
-void falcon_xmac_writel(struct efx_nic *efx,
-			 efx_dword_t *value, unsigned int mac_reg)
+static void falcon_xmac_writel(struct efx_nic *efx,
+			       efx_dword_t *value, unsigned int mac_reg)
 {
 	efx_oword_t temp;
 
@@ -40,8 +57,8 @@ void falcon_xmac_writel(struct efx_nic *
 	falcon_write(efx, &temp, FALCON_XMAC_REG(mac_reg));
 }
 
-void falcon_xmac_readl(struct efx_nic *efx,
-		       efx_dword_t *value, unsigned int mac_reg)
+static void falcon_xmac_readl(struct efx_nic *efx,
+			      efx_dword_t *value, unsigned int mac_reg)
 {
 	efx_oword_t temp;
 
@@ -60,19 +77,15 @@ static int falcon_reset_xmac(struct efx_
 	int count;
 
 	EFX_POPULATE_DWORD_1(reg, XM_CORE_RST, 1);
-	falcon_xmac_writel(efx, &reg, XM_GLB_CFG_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_GLB_CFG_REG_MAC);
 
 	for (count = 0; count < 10000; count++) {	/* wait upto 100ms */
-		falcon_xmac_readl(efx, &reg, XM_GLB_CFG_REG_MAC);
+		efx->mac_op->mac_readl(efx, &reg, XM_GLB_CFG_REG_MAC);
 		if (EFX_DWORD_FIELD(reg, XM_CORE_RST) == 0)
 			return 0;
 		udelay(10);
 	}
 
-	/* This often fails when DSP is disabled, ignore it */
-	if (sfe4001_phy_flash_cfg != 0)
-		return 0;
-
 	EFX_ERR(efx, "timed out waiting for XMAC core reset\n");
 	return -ETIMEDOUT;
 }
@@ -87,7 +100,7 @@ static void falcon_setup_xaui(struct efx
 	if (efx->phy_type == PHY_TYPE_NONE)
 		return;
 
-	falcon_xmac_readl(efx, &sdctl, XX_SD_CTL_REG_MAC);
+	efx->mac_op->mac_readl(efx, &sdctl, XX_SD_CTL_REG_MAC);
 	EFX_SET_DWORD_FIELD(sdctl, XX_HIDRVD, XX_SD_CTL_DRV_DEFAULT);
 	EFX_SET_DWORD_FIELD(sdctl, XX_LODRVD, XX_SD_CTL_DRV_DEFAULT);
 	EFX_SET_DWORD_FIELD(sdctl, XX_HIDRVC, XX_SD_CTL_DRV_DEFAULT);
@@ -96,7 +109,7 @@ static void falcon_setup_xaui(struct efx
 	EFX_SET_DWORD_FIELD(sdctl, XX_LODRVB, XX_SD_CTL_DRV_DEFAULT);
 	EFX_SET_DWORD_FIELD(sdctl, XX_HIDRVA, XX_SD_CTL_DRV_DEFAULT);
 	EFX_SET_DWORD_FIELD(sdctl, XX_LODRVA, XX_SD_CTL_DRV_DEFAULT);
-	falcon_xmac_writel(efx, &sdctl, XX_SD_CTL_REG_MAC);
+	efx->mac_op->mac_writel(efx, &sdctl, XX_SD_CTL_REG_MAC);
 
 	EFX_POPULATE_DWORD_8(txdrv,
 			     XX_DEQD, XX_TXDRV_DEQ_DEFAULT,
@@ -107,7 +120,7 @@ static void falcon_setup_xaui(struct efx
 			     XX_DTXC, XX_TXDRV_DTX_DEFAULT,
 			     XX_DTXB, XX_TXDRV_DTX_DEFAULT,
 			     XX_DTXA, XX_TXDRV_DTX_DEFAULT);
-	falcon_xmac_writel(efx, &txdrv, XX_TXDRV_CTL_REG_MAC);
+	efx->mac_op->mac_writel(efx, &txdrv, XX_TXDRV_CTL_REG_MAC);
 }
 
 static void falcon_hold_xaui_in_rst(struct efx_nic *efx)
@@ -127,7 +140,7 @@ static void falcon_hold_xaui_in_rst(stru
 	EFX_SET_DWORD_FIELD(reg, XX_RESETD_EN, 1);
 	EFX_SET_DWORD_FIELD(reg, XX_RSTXGXSRX_EN, 1);
 	EFX_SET_DWORD_FIELD(reg, XX_RSTXGXSTX_EN, 1);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 }
 
@@ -135,39 +148,42 @@ static int _falcon_reset_xaui_a(struct e
 {
 	efx_dword_t reg;
 
+	if (!efx->is_asic)
+		return 0;
+
 	falcon_hold_xaui_in_rst(efx);
-	falcon_xmac_readl(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_readl(efx, &reg, XX_PWR_RST_REG_MAC);
 
 	/* Follow the RAMBUS XAUI data reset sequencing
 	 * Channels A and B first: power down, reset PLL, reset, clear
 	 */
 	EFX_SET_DWORD_FIELD(reg, XX_PWRDNA_EN, 0);
 	EFX_SET_DWORD_FIELD(reg, XX_PWRDNB_EN, 0);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
 	EFX_SET_DWORD_FIELD(reg, XX_RSTPLLAB_EN, 0);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
 	EFX_SET_DWORD_FIELD(reg, XX_RESETA_EN, 0);
 	EFX_SET_DWORD_FIELD(reg, XX_RESETB_EN, 0);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
 	/* Channels C and D: power down, reset PLL, reset, clear */
 	EFX_SET_DWORD_FIELD(reg, XX_PWRDNC_EN, 0);
 	EFX_SET_DWORD_FIELD(reg, XX_PWRDND_EN, 0);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
 	EFX_SET_DWORD_FIELD(reg, XX_RSTPLLCD_EN, 0);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
 	EFX_SET_DWORD_FIELD(reg, XX_RESETC_EN, 0);
 	EFX_SET_DWORD_FIELD(reg, XX_RESETD_EN, 0);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
 	/* Setup XAUI */
@@ -176,7 +192,7 @@ static int _falcon_reset_xaui_a(struct e
 
 	/* Take XGXS out of reset */
 	EFX_ZERO_DWORD(reg);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
 	return 0;
@@ -187,12 +203,15 @@ static int _falcon_reset_xaui_b(struct e
 	efx_dword_t reg;
 	int count;
 
+	if (!efx->is_asic)
+		return 0;
+
 	EFX_POPULATE_DWORD_1(reg, XX_RST_XX_EN, 1);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 
 	/* Give some time for the link to establish */
 	for (count = 0; count < 1000; count++) { /* wait upto 10ms */
-		falcon_xmac_readl(efx, &reg, XX_PWR_RST_REG_MAC);
+		efx->mac_op->mac_readl(efx, &reg, XX_PWR_RST_REG_MAC);
 		if (EFX_DWORD_FIELD(reg, XX_RST_XX_EN) == 0) {
 			falcon_setup_xaui(efx);
 			return 0;
@@ -221,12 +240,12 @@ static int falcon_xgmii_status(struct ef
 {
 	efx_dword_t reg;
 
-	if (falcon_rev(efx) < FALCON_REV_B0)
+	if (FALCON_REV(efx) < FALCON_REV_B0)
 		return 1;
 
 	/* The ISR latches, so clear it and re-read */
-	falcon_xmac_readl(efx, &reg, XM_MGT_INT_REG_MAC_B0);
-	falcon_xmac_readl(efx, &reg, XM_MGT_INT_REG_MAC_B0);
+	efx->mac_op->mac_readl(efx, &reg, XM_MGT_INT_REG_MAC_B0);
+	efx->mac_op->mac_readl(efx, &reg, XM_MGT_INT_REG_MAC_B0);
 
 	if (EFX_DWORD_FIELD(reg, XM_LCLFLT) ||
 	    EFX_DWORD_FIELD(reg, XM_RMTFLT)) {
@@ -241,20 +260,20 @@ static void falcon_mask_status_intr(stru
 {
 	efx_dword_t reg;
 
-	if ((falcon_rev(efx) < FALCON_REV_B0) || LOOPBACK_INTERNAL(efx))
+	if ((FALCON_REV(efx) < FALCON_REV_B0) || LOOPBACK_INTERNAL(efx))
 		return;
 
 	/* Flush the ISR */
 	if (enable)
-		falcon_xmac_readl(efx, &reg, XM_MGT_INT_REG_MAC_B0);
+		efx->mac_op->mac_readl(efx, &reg, XM_MGT_INT_REG_MAC_B0);
 
 	EFX_POPULATE_DWORD_2(reg,
 			     XM_MSK_RMTFLT, !enable,
 			     XM_MSK_LCLFLT, !enable);
-	falcon_xmac_writel(efx, &reg, XM_MGT_INT_MSK_REG_MAC_B0);
+	efx->mac_op->mac_writel(efx, &reg, XM_MGT_INT_MSK_REG_MAC_B0);
 }
 
-int falcon_init_xmac(struct efx_nic *efx)
+static int falcon_init_xmac(struct efx_nic *efx)
 {
 	int rc;
 
@@ -267,9 +286,10 @@ int falcon_init_xmac(struct efx_nic *efx
 	if (rc)
 		goto fail2;
 
-	/* Wait again. Give the PHY and MAC time to come back */
+	/* Wait again. Give the PHY and MAC time to faff */
 	schedule_timeout_uninterruptible(HZ / 10);
 
+	/* Reset the MAC */
 	rc = falcon_reset_xmac(efx);
 	if (rc)
 		goto fail2;
@@ -283,16 +303,21 @@ int falcon_init_xmac(struct efx_nic *efx
 	return rc;
 }
 
+/* Get status of XAUI link */
 int falcon_xaui_link_ok(struct efx_nic *efx)
 {
 	efx_dword_t reg;
 	int align_done, sync_status, link_ok = 0;
 
-	if (LOOPBACK_INTERNAL(efx))
+	/* If we're in internal loopback, then the link is up.
+	 * The A1 FPGA/4G has RX and TX XAUI wired together, so the link is up.
+	 * The B0 FPGA has XAUI offchip, so it is always up.
+	 */
+	if (!efx->is_asic || LOOPBACK_INTERNAL(efx))
 		return 1;
 
 	/* Read link status */
-	falcon_xmac_readl(efx, &reg, XX_CORE_STAT_REG_MAC);
+	efx->mac_op->mac_readl(efx, &reg, XX_CORE_STAT_REG_MAC);
 
 	align_done = EFX_DWORD_FIELD(reg, XX_ALIGN_DONE);
 	sync_status = EFX_DWORD_FIELD(reg, XX_SYNC_STAT);
@@ -303,7 +328,7 @@ int falcon_xaui_link_ok(struct efx_nic *
 	EFX_SET_DWORD_FIELD(reg, XX_COMMA_DET, XX_COMMA_DET_RESET);
 	EFX_SET_DWORD_FIELD(reg, XX_CHARERR, XX_CHARERR_RESET);
 	EFX_SET_DWORD_FIELD(reg, XX_DISPERR, XX_DISPERR_RESET);
-	falcon_xmac_writel(efx, &reg, XX_CORE_STAT_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_CORE_STAT_REG_MAC);
 
 	/* If the link is up, then check the phy side of the xaui link
 	 * (error conditions from the wire side propoagate back through
@@ -326,14 +351,23 @@ static void falcon_reconfigure_xmac_core
 {
 	unsigned int max_frame_len;
 	efx_dword_t reg;
+	efx_oword_t mac_test_reg;
 	int rx_fc = (efx->flow_control & EFX_FC_RX) ? 1 : 0;
 
+	if (FALCON_REV(efx) <= FALCON_REV_A1 && !efx->is_asic) {
+		/* 10G FPGA's have the XAUI TX and RX wired together. Fake
+		 * the link status and configure the link options before
+		 * the MAC wrapper is configured */
+		efx->link_options = GM_LPA_10000FULL;
+		efx->link_up = 1;
+	}
+
 	/* Configure MAC  - cut-thru mode is hard wired on */
 	EFX_POPULATE_DWORD_3(reg,
 			     XM_RX_JUMBO_MODE, 1,
 			     XM_TX_STAT_EN, 1,
 			     XM_RX_STAT_EN, 1);
-	falcon_xmac_writel(efx, &reg, XM_GLB_CFG_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_GLB_CFG_REG_MAC);
 
 	/* Configure TX */
 	EFX_POPULATE_DWORD_6(reg,
@@ -343,7 +377,7 @@ static void falcon_reconfigure_xmac_core
 			     XM_TXCRC, 1,
 			     XM_FCNTL, 1,
 			     XM_IPG, 0x3);
-	falcon_xmac_writel(efx, &reg, XM_TX_CFG_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_TX_CFG_REG_MAC);
 
 	/* Configure RX */
 	EFX_POPULATE_DWORD_5(reg,
@@ -352,21 +386,21 @@ static void falcon_reconfigure_xmac_core
 			     XM_ACPT_ALL_MCAST, 1,
 			     XM_ACPT_ALL_UCAST, efx->promiscuous,
 			     XM_PASS_CRC_ERR, 1);
-	falcon_xmac_writel(efx, &reg, XM_RX_CFG_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_RX_CFG_REG_MAC);
 
 	/* Set frame length */
 	max_frame_len = EFX_MAX_FRAME_LEN(efx->net_dev->mtu);
 	EFX_POPULATE_DWORD_1(reg, XM_MAX_RX_FRM_SIZE, max_frame_len);
-	falcon_xmac_writel(efx, &reg, XM_RX_PARAM_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_RX_PARAM_REG_MAC);
 	EFX_POPULATE_DWORD_2(reg,
 			     XM_MAX_TX_FRM_SIZE, max_frame_len,
 			     XM_TX_JUMBO_MODE, 1);
-	falcon_xmac_writel(efx, &reg, XM_TX_PARAM_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_TX_PARAM_REG_MAC);
 
 	EFX_POPULATE_DWORD_2(reg,
 			     XM_PAUSE_TIME, 0xfffe, /* MAX PAUSE TIME */
 			     XM_DIS_FCNTL, rx_fc ? 0 : 1);
-	falcon_xmac_writel(efx, &reg, XM_FC_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_FC_REG_MAC);
 
 	/* Set MAC address */
 	EFX_POPULATE_DWORD_4(reg,
@@ -374,11 +408,22 @@ static void falcon_reconfigure_xmac_core
 			     XM_ADR_1, efx->net_dev->dev_addr[1],
 			     XM_ADR_2, efx->net_dev->dev_addr[2],
 			     XM_ADR_3, efx->net_dev->dev_addr[3]);
-	falcon_xmac_writel(efx, &reg, XM_ADR_LO_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_ADR_LO_REG_MAC);
 	EFX_POPULATE_DWORD_2(reg,
 			     XM_ADR_4, efx->net_dev->dev_addr[4],
 			     XM_ADR_5, efx->net_dev->dev_addr[5]);
-	falcon_xmac_writel(efx, &reg, XM_ADR_HI_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XM_ADR_HI_REG_MAC);
+
+	/* Handle B0 FPGA loopback where RAMBUS XGXS block not present */
+	if (FALCON_REV(efx) >= FALCON_REV_B0 && !efx->is_asic) {
+		int xgmii_loopback =
+			(efx->loopback_mode == LOOPBACK_XGMII) ? 1 : 0;
+
+		/* Set the MAC loopback bit. */
+		EFX_POPULATE_OWORD_1(mac_test_reg,
+				     MAC_PTLOOP_EN, xgmii_loopback);
+		falcon_write(efx, &mac_test_reg, MAC_TEST_REG_KER);
+	}
 }
 
 static void falcon_reconfigure_xgxs_core(struct efx_nic *efx)
@@ -389,17 +434,22 @@ static void falcon_reconfigure_xgxs_core
 	int xgmii_loopback =
 		(efx->loopback_mode == LOOPBACK_XGMII) ? 1 : 0;
 
+	if (FALCON_REV(efx) >= FALCON_REV_B0 && !efx->is_asic)
+		/* RAMBUS XGXS block is not present */
+		return;
+
 	/* XGXS block is flaky and will need to be reset if moving
 	 * into our out of XGMII, XGXS or XAUI loopbacks. */
 	if (EFX_WORKAROUND_5147(efx)) {
 		int old_xgmii_loopback, old_xgxs_loopback, old_xaui_loopback;
 		int reset_xgxs;
 
-		falcon_xmac_readl(efx, &reg, XX_CORE_STAT_REG_MAC);
+		efx->mac_op->mac_readl(efx, &reg,
+					    XX_CORE_STAT_REG_MAC);
 		old_xgxs_loopback = EFX_DWORD_FIELD(reg, XX_XGXS_LB_EN);
 		old_xgmii_loopback = EFX_DWORD_FIELD(reg, XX_XGMII_LB_EN);
 
-		falcon_xmac_readl(efx, &reg, XX_SD_CTL_REG_MAC);
+		efx->mac_op->mac_readl(efx, &reg, XX_SD_CTL_REG_MAC);
 		old_xaui_loopback = EFX_DWORD_FIELD(reg, XX_LPBKA);
 
 		/* The PHY driver may have turned XAUI off */
@@ -407,32 +457,35 @@ static void falcon_reconfigure_xgxs_core
 			      (xaui_loopback != old_xaui_loopback) ||
 			      (xgmii_loopback != old_xgmii_loopback));
 		if (reset_xgxs) {
-			falcon_xmac_readl(efx, &reg, XX_PWR_RST_REG_MAC);
+			efx->mac_op->mac_readl(efx, &reg,
+						    XX_PWR_RST_REG_MAC);
 			EFX_SET_DWORD_FIELD(reg, XX_RSTXGXSTX_EN, 1);
 			EFX_SET_DWORD_FIELD(reg, XX_RSTXGXSRX_EN, 1);
-			falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+			efx->mac_op->mac_writel(efx, &reg,
+						     XX_PWR_RST_REG_MAC);
 			udelay(1);
 			EFX_SET_DWORD_FIELD(reg, XX_RSTXGXSTX_EN, 0);
 			EFX_SET_DWORD_FIELD(reg, XX_RSTXGXSRX_EN, 0);
-			falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+			efx->mac_op->mac_writel(efx, &reg,
+						     XX_PWR_RST_REG_MAC);
 			udelay(1);
 		}
 	}
 
-	falcon_xmac_readl(efx, &reg, XX_CORE_STAT_REG_MAC);
+	efx->mac_op->mac_readl(efx, &reg, XX_CORE_STAT_REG_MAC);
 	EFX_SET_DWORD_FIELD(reg, XX_FORCE_SIG,
 			    (xgxs_loopback || xaui_loopback) ?
 			    XX_FORCE_SIG_DECODE_FORCED : 0);
 	EFX_SET_DWORD_FIELD(reg, XX_XGXS_LB_EN, xgxs_loopback);
 	EFX_SET_DWORD_FIELD(reg, XX_XGMII_LB_EN, xgmii_loopback);
-	falcon_xmac_writel(efx, &reg, XX_CORE_STAT_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_CORE_STAT_REG_MAC);
 
-	falcon_xmac_readl(efx, &reg, XX_SD_CTL_REG_MAC);
+	efx->mac_op->mac_readl(efx, &reg, XX_SD_CTL_REG_MAC);
 	EFX_SET_DWORD_FIELD(reg, XX_LPBKD, xaui_loopback);
 	EFX_SET_DWORD_FIELD(reg, XX_LPBKC, xaui_loopback);
 	EFX_SET_DWORD_FIELD(reg, XX_LPBKB, xaui_loopback);
 	EFX_SET_DWORD_FIELD(reg, XX_LPBKA, xaui_loopback);
-	falcon_xmac_writel(efx, &reg, XX_SD_CTL_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_SD_CTL_REG_MAC);
 }
 
 
@@ -445,7 +498,8 @@ static int falcon_check_xaui_link_up(str
 	max_tries = tries;
 
 	if ((efx->loopback_mode == LOOPBACK_NETWORK) ||
-	    (efx->phy_type == PHY_TYPE_NONE))
+	    (efx->phy_type == PHY_TYPE_NONE) ||
+	    !efx->phy_powered)
 		return 0;
 
 	while (tries) {
@@ -454,30 +508,33 @@ static int falcon_check_xaui_link_up(str
 
 		EFX_LOG(efx, "%s Clobbering XAUI (%d tries left).\n",
 			__func__, tries);
-		falcon_reset_xaui(efx);
+		(void) falcon_reset_xaui(efx);
 		udelay(200);
 		tries--;
 	}
 
-	EFX_LOG(efx, "Failed to bring XAUI link back up in %d tries!\n",
+	EFX_ERR(efx, "Failed to bring XAUI link back up in %d tries!\n",
 		max_tries);
 	return 0;
 }
 
-void falcon_reconfigure_xmac(struct efx_nic *efx)
+static void falcon_reconfigure_xmac(struct efx_nic *efx)
 {
 	int xaui_link_ok;
 
 	falcon_mask_status_intr(efx, 0);
 
+	/* Deconfigure the mac wrapper, draining the tx fifo if necessary */
 	falcon_deconfigure_mac_wrapper(efx);
 
+	/* Reconfigure the PHY, disabling transmit in mac level loopback. */
 	efx->tx_disabled = LOOPBACK_INTERNAL(efx);
 	efx->phy_op->reconfigure(efx);
 
 	falcon_reconfigure_xgxs_core(efx);
 	falcon_reconfigure_xmac_core(efx);
 
+	/* Reconfigure MAC wrapper */
 	falcon_reconfigure_mac_wrapper(efx);
 
 	/* Ensure XAUI link is up */
@@ -487,7 +544,7 @@ void falcon_reconfigure_xmac(struct efx_
 		falcon_mask_status_intr(efx, 1);
 }
 
-void falcon_fini_xmac(struct efx_nic *efx)
+static void falcon_fini_xmac(struct efx_nic *efx)
 {
 	/* Isolate the MAC - PHY */
 	falcon_deconfigure_mac_wrapper(efx);
@@ -496,7 +553,7 @@ void falcon_fini_xmac(struct efx_nic *ef
 	efx->phy_op->fini(efx);
 }
 
-void falcon_update_stats_xmac(struct efx_nic *efx)
+static void falcon_update_stats_xmac(struct efx_nic *efx)
 {
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
 	int rc;
@@ -559,20 +616,23 @@ void falcon_update_stats_xmac(struct efx
 		(mac_stats->rx_bytes - mac_stats->rx_good_bytes);
 }
 
-int falcon_check_xmac(struct efx_nic *efx)
+#define EFX_XAUI_RETRAIN_MAX 8
+
+static int falcon_check_xmac(struct efx_nic *efx)
 {
 	unsigned xaui_link_ok;
 	int rc;
 
 	if ((efx->loopback_mode == LOOPBACK_NETWORK) ||
-	    (efx->phy_type == PHY_TYPE_NONE))
+	    (efx->phy_type == PHY_TYPE_NONE) ||
+	    !efx->phy_powered)
 		return 0;
 
 	falcon_mask_status_intr(efx, 0);
 	xaui_link_ok = falcon_xaui_link_ok(efx);
 
 	if (EFX_WORKAROUND_5147(efx) && !xaui_link_ok)
-		falcon_reset_xaui(efx);
+		(void) falcon_reset_xaui(efx);
 
 	/* Call the PHY check_hw routine */
 	rc = efx->phy_op->check_hw(efx);
@@ -585,7 +645,7 @@ int falcon_check_xmac(struct efx_nic *ef
 }
 
 /* Simulate a PHY event */
-void falcon_xmac_sim_phy_event(struct efx_nic *efx)
+static void falcon_xmac_sim_phy_event(struct efx_nic *efx)
 {
 	efx_qword_t phy_event;
 
@@ -595,7 +655,8 @@ void falcon_xmac_sim_phy_event(struct ef
 	falcon_generate_event(&efx->channel[0], &phy_event);
 }
 
-int falcon_xmac_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+static int falcon_xmac_get_settings(struct efx_nic *efx,
+				    struct ethtool_cmd *ecmd)
 {
 	mdio_clause45_get_settings(efx, ecmd);
 	ecmd->transceiver = XCVR_INTERNAL;
@@ -605,7 +666,8 @@ int falcon_xmac_get_settings(struct efx_
 	return 0;
 }
 
-int falcon_xmac_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+static int falcon_xmac_set_settings(struct efx_nic *efx,
+				    struct ethtool_cmd *ecmd)
 {
 	if (ecmd->transceiver != XCVR_INTERNAL)
 		return -EINVAL;
@@ -618,7 +680,8 @@ int falcon_xmac_set_settings(struct efx_
 }
 
 
-int falcon_xmac_set_pause(struct efx_nic *efx, enum efx_fc_type flow_control)
+static int falcon_xmac_set_pause(struct efx_nic *efx,
+				 enum efx_fc_type flow_control)
 {
 	int reset;
 
@@ -639,7 +702,7 @@ int falcon_xmac_set_pause(struct efx_nic
 	reset = ((flow_control & EFX_FC_TX) &&
 		 !(efx->flow_control & EFX_FC_TX));
 	if (EFX_WORKAROUND_11482(efx) && reset) {
-		if (falcon_rev(efx) >= FALCON_REV_B0) {
+		if (FALCON_REV(efx) >= FALCON_REV_B0) {
 			/* Recover by resetting the EM block */
 			if (efx->link_up)
 				falcon_drain_tx_fifo(efx);
@@ -653,3 +716,17 @@ int falcon_xmac_set_pause(struct efx_nic
 
 	return 0;
 }
+
+struct efx_mac_operations falcon_xmac_operations = {
+	.mac_writel	= falcon_xmac_writel,
+	.mac_readl	= falcon_xmac_readl,
+	.init		= falcon_init_xmac,
+	.reconfigure	= falcon_reconfigure_xmac,
+	.update_stats	= falcon_update_stats_xmac,
+	.fini		= falcon_fini_xmac,
+	.check_hw	= falcon_check_xmac,
+	.fake_phy_event = falcon_xmac_sim_phy_event,
+	.get_settings   = falcon_xmac_get_settings,
+	.set_settings   = falcon_xmac_set_settings,
+	.set_pause      = falcon_xmac_set_pause,
+};
Index: head-2008-06-18/drivers/net/sfc/gmii.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/gmii.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/gmii.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_GMII_H
Index: head-2008-06-18/drivers/net/sfc/i2c-direct.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/i2c-direct.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/i2c-direct.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,13 +1,31 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005:      Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
+#include <asm/io.h>
 #include <linux/delay.h>
 #include "net_driver.h"
 #include "i2c-direct.h"
Index: head-2008-06-18/drivers/net/sfc/i2c-direct.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/i2c-direct.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/i2c-direct.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005 Fen Systems Ltd.
- * Copyright 2006 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005:      Fen Systems Ltd.
+ * Copyright 2006:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_I2C_DIRECT_H
Index: head-2008-06-18/drivers/net/sfc/lm87_support.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/lm87_support.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,295 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************/
+
+#include "net_driver.h"
+#include "lm87_support.h"
+#include "workarounds.h"
+
+/* Setting this to 1 will cause efx_check_lm87 to dump the status when it
+ * detects an alarm. This will result in the canonical name (i.e. that in
+ * the LM87 data book) being printed for each set status bit, along with
+ * the reading for that sensor value, if applicable. If set to 0 only the
+ * raw status1 and status2 register values are printed. */
+#define LM87_VERBOSE_ALARMS	1
+
+/**************************************************************************
+ *
+ * Onboard LM87 temperature and voltage monitor
+ *
+ **************************************************************************
+ */
+
+/* LM87 channel mode: all current boards either do not use AIN1/FAN1 and 2
+ * or use them as AIN. */
+#define LM87_CHANNEL_MODE 0x16
+#define LM87_CHANNEL_AIN1 1
+#define LM87_CHANNEL_AIN2 2
+#define LM87_CHANNEL_INIT (LM87_CHANNEL_AIN2 | LM87_CHANNEL_AIN1)
+
+/* LM87 configuration register 1 */
+#define LM87_CONFIG_1 0x40
+#define LM87_START 0x01
+#define LM87_INTEN 0x02
+#define LM87_INITIALIZATION 0x80
+
+/* LM87 interrupt status register 1 */
+#define LM87_INT_STATUS_1 0x41
+
+/* LM87 interrupt status register 2 */
+#define LM87_INT_STATUS_2 0x42
+
+/* LM87 interrupt mask register 1 */
+#define LM87_INT_MASK_1 0x43
+
+/* LM87 interrupt mask register 2 */
+#define LM87_INT_MASK_2 0x44
+
+/* LM87 monitoring limits */
+#define LM87_LIMITS 0x2b
+
+
+int efx_probe_lm87(struct efx_nic *efx, int addr,
+		   const u8 *limits, int nlimits, const u16 irqmask)
+{
+	struct efx_i2c_interface *i2c = &efx->i2c;
+	u8 byte;
+	int rc;
+
+	/* Check for onboard LM87 */
+	rc = efx_i2c_check_presence_retry(i2c, addr);
+	if (rc) {
+		/* Not an error to lack an LM87, but failure to probe the
+		 * bus is worrying. */
+		if (rc == -EFAULT) {
+			EFX_ERR(efx, "Failed to probe I2C bus for LM87!\n");
+			return rc;
+		} else {
+			EFX_LOG(efx, "has no onboard LM87 chip\n");
+			return 0;
+		}
+	}
+	efx->board_info.lm87_addr = addr;
+	EFX_LOG(efx, "detected onboard LM87 chip at 0x%2x\n", addr);
+
+	/* Reset chip */
+	byte = LM87_INITIALIZATION;
+	rc = efx_i2c_write_retry(i2c, addr, LM87_CONFIG_1, &byte, 1);
+	if (rc) {
+		EFX_ERR(efx, "could not reset LM87\n");
+		return rc;
+	}
+
+	/* Configure channel mode: currently hardwire to make pins 5 and 6
+	 * AIN1 and AIN2 rather than FAN1, FAN2. */
+	byte = LM87_CHANNEL_INIT;
+	rc = efx_i2c_write_retry(i2c, addr, LM87_CHANNEL_MODE, &byte, 1);
+	if (rc) {
+		EFX_ERR(efx, "could not program LM87 chan. mode\n");
+		return rc;
+	}
+
+	/* Configure limits */
+	rc = efx_i2c_write_retry(i2c, addr, LM87_LIMITS, limits, nlimits);
+	if (rc) {
+		EFX_ERR(efx, "could not program LM87 limits\n");
+		return rc;
+	}
+
+	/* Mask off unwanted interrupts */
+	byte = (irqmask & 0xff);
+	rc = efx_i2c_write_retry(i2c, addr, LM87_INT_MASK_1, &byte, 1);
+	if (rc) {
+		EFX_ERR(efx, "could not mask LM87 interrupts\n");
+		return rc;
+	}
+
+	byte = (irqmask >> 8);
+	rc = efx_i2c_write_retry(i2c, addr, LM87_INT_MASK_2, &byte, 1);
+	if (rc) {
+		EFX_ERR(efx, "could not mask LM87 interrupts\n");
+		return rc;
+	}
+
+	/* Start monitoring */
+	byte = LM87_START;
+	if (irqmask != EFX_LM87_NO_INTS)
+		byte |= LM87_INTEN;
+
+	rc = efx_i2c_write_retry(i2c, addr, LM87_CONFIG_1, &byte, 1);
+	if (rc) {
+		EFX_ERR(efx, "could not start LM87\n");
+		return rc;
+	}
+
+	return rc;
+}
+
+void efx_remove_lm87(struct efx_nic *efx)
+{
+	struct efx_i2c_interface *i2c = &efx->i2c;
+	u8 byte;
+
+	if (!efx->board_info.lm87_addr)
+		return;
+
+	/* Reset chip */
+	byte = LM87_INITIALIZATION;
+	if (efx_i2c_write_retry(i2c, efx->board_info.lm87_addr,
+				LM87_CONFIG_1, &byte, 1) != 0)
+		EFX_ERR(efx, "could not reset LM87 on exit\n");
+}
+
+#if LM87_VERBOSE_ALARMS
+/* Bit number to name mapping for status1 */
+static const char *lm_stat_names[] = {
+/* Status 1 contents */
+	"+2.5Vin",
+	"Vccp1",
+	"Vcc",
+	"+5Vin",
+	"Int. Temp.",
+	"Ext. Temp.",
+	"FAN1/AIN1",
+	"FAN2/AIN2",
+/* Status 2 contents */
+	"+12Vin",
+	"Vccp2",
+	"Reserved",
+	"Reserved",
+	"CI",
+	"THERM#",
+	"D1 Fault",
+	"D2 Fault"
+};
+
+/* Where to read the value corresponding to an alarm bit. */
+static const int lm_stat_regs[] = {
+	0x20, 0x21, 0x22, 0x23, 0x27, 0x26, 0x28, 0x29,
+	0x24, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
+/* The positions of the alarm bits do not correspond exactly to the
+ * order of the limit values. Convert so the user only needs to maintain
+ * one array */
+static int lm_bit_to_lim[] = {
+	0, /* 2.5V */
+	1, /* Vccp1 */
+	2, /* Vcc */
+	3, /* 5V */
+	7, /* Int temp. */
+	6, /* Ext temp. */
+	8, /* AIN1 */
+	9, /* AIN2 */
+	4, /* 12V */
+	5  /* Vccp2 */
+};
+
+/* These are bit numbers. I feel justified in hardwiring the max. */
+static const int lm_stat_max = 16;
+
+static void lm87_show_alarm(struct efx_nic *efx, int bit)
+{
+	char valbuf[8];
+	u8 val;
+
+	if (lm_stat_regs[bit] != 0xff) {
+		efx_i2c_read_retry(&efx->i2c, efx->board_info.lm87_addr,
+				   lm_stat_regs[bit], &val, 1);
+		sprintf(valbuf, "0x%02x  ", val);
+	} else {
+		strcpy(valbuf, "----  ");
+	}
+	/* If the board code knows what this sensor is wired to, let it tell
+	 * us, else just print the LM87 datasheet name of the input, and the
+	 * value. */
+	if (efx->board_info.interpret_sensor == NULL ||
+	    (bit < ARRAY_SIZE(lm_bit_to_lim) &&
+	     efx->board_info.interpret_sensor(efx, lm_bit_to_lim[bit], val)
+	     == 0))
+		EFX_ERR(efx, ": %10s  %4s\n",
+			STRING_TABLE_LOOKUP(bit, lm_stat), valbuf);
+}
+
+static void lm87_dump_alarms(struct efx_nic *efx, int stat1, int stat2)
+{
+	int i;
+	EFX_ERR(efx, "   NAME    value\n");
+	for (i = 0; i < 8; i++) {
+		if (stat1 & (1 << i))
+			lm87_show_alarm(efx, i);
+		if (stat2 & (1 << i))
+			lm87_show_alarm(efx, i + 8);
+	}
+}
+
+#else
+#define lm87_dump_alarms(_name, _stat1, _stat2) do {} while (0)
+#endif
+
+/* Read onboard LM87 (if present)
+ * Return error code if lm87 could not be read (-EIO)
+ * _or_ is raising an alarm (-ERANGE). 0 if AOK.
+ */
+int efx_check_lm87(struct efx_nic *efx, unsigned mask)
+{
+	struct efx_i2c_interface *i2c = &efx->i2c;
+	u8 int_status_1, int_status_2;
+	unsigned ints;
+	int rc = 0;
+
+	/* If link is up then do not monitor temperature */
+	if (EFX_WORKAROUND_7884(efx) && efx->link_up)
+		return 0;
+
+	if (!efx->board_info.lm87_addr)
+		return 0;
+
+	/* Read interrupt status registers */
+	rc = efx_i2c_read_retry(i2c, efx->board_info.lm87_addr,
+				LM87_INT_STATUS_1, &int_status_1, 1);
+	if (rc) {
+		EFX_ERR(efx, "could not read LM87 INT status 1\n");
+		return rc;
+	}
+	rc = efx_i2c_read_retry(i2c, efx->board_info.lm87_addr,
+				LM87_INT_STATUS_2, &int_status_2, 1);
+	if (rc) {
+		EFX_ERR(efx, "could not read LM87 INT status 2\n");
+		return rc;
+	}
+
+	int_status_1 &= mask;
+	int_status_2 &= (mask >> 8);
+	ints = ((int_status_2 << 8) | int_status_1);
+
+	/* Check interrupt status */
+	if (ints == 0)
+		return 0;
+
+	EFX_ERR(efx, "LM87 detected a hardware failure (status %02x:%02x)\n",
+		int_status_1, int_status_2);
+	lm87_dump_alarms(efx, int_status_1, int_status_2);
+
+	return -ERANGE;
+}
Index: head-2008-06-18/drivers/net/sfc/lm87_support.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/lm87_support.h	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,58 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************/
+
+#ifndef EFX_LM87_SUPPORT_H
+#define EFX_LM87_SUPPORT_H
+
+/* The interrupt bit masks. These are the same in the interrupt status and
+ * interrupt mask registers. */
+/* Register 1 bits */
+#define EFX_LM87_2_5V_INT	(1)
+#define EFX_LM87_VCCP1_INT	(2)
+#define EFX_LM87_VCC_INT	(4)
+#define EFX_LM87_5_V_INT	(8)
+#define EFX_LM87_ITMP_INT	(0x10)
+#define EFX_LM87_ETMP_INT	(0x20)
+#define EFX_LM87_FAN1_INT	(0x40)
+#define EFX_LM87_FAN2_INT	(0x80)
+/* Register 2 bits */
+#define EFX_LM87_12V_INT	(0x100)
+#define EFX_LM87_VCCP2_INT	(0x200)
+/* Bits 2 and 3 are reserved. */
+#define EFX_LM87_CI_INT		(0x1000)
+#define EFX_LM87_THERM_INT	(0x2000)
+#define EFX_LM87_D1_INT		(0x4000)
+#define EFX_LM87_D2_INT		(0x8000)
+
+#define EFX_LM87_NO_INTS	((u16)-1)
+
+extern
+int efx_probe_lm87(struct efx_nic *efx, int addr, const u8 *limits,
+		   int nlimits, const u16 irqmask);
+
+extern void efx_remove_lm87(struct efx_nic *efx);
+
+extern int efx_check_lm87(struct efx_nic *efx, unsigned mask);
+
+#endif /* EFX_LM87_SUPPORT_H */
Index: head-2008-06-18/drivers/net/sfc/mac.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/mac.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/mac.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2007 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2007: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_MAC_H
@@ -13,21 +30,9 @@
 
 #include "net_driver.h"
 
-extern void falcon_xmac_writel(struct efx_nic *efx,
-			       efx_dword_t *value, unsigned int mac_reg);
-extern void falcon_xmac_readl(struct efx_nic *efx,
-			      efx_dword_t *value, unsigned int mac_reg);
-extern int falcon_init_xmac(struct efx_nic *efx);
-extern void falcon_reconfigure_xmac(struct efx_nic *efx);
-extern void falcon_update_stats_xmac(struct efx_nic *efx);
-extern void falcon_fini_xmac(struct efx_nic *efx);
-extern int falcon_check_xmac(struct efx_nic *efx);
-extern void falcon_xmac_sim_phy_event(struct efx_nic *efx);
-extern int falcon_xmac_get_settings(struct efx_nic *efx,
-				    struct ethtool_cmd *ecmd);
-extern int falcon_xmac_set_settings(struct efx_nic *efx,
-				    struct ethtool_cmd *ecmd);
-extern int falcon_xmac_set_pause(struct efx_nic *efx,
-				 enum efx_fc_type pause_params);
+extern void mentormac_reset(struct efx_nic *efx);
+extern void mentormac_reconfigure(struct efx_nic *efx);
+extern struct efx_mac_operations falcon_gmac_operations;
+extern struct efx_mac_operations falcon_xmac_operations;
 
 #endif
Index: head-2008-06-18/drivers/net/sfc/mdio_10g.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/mdio_10g.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/mdio_10g.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,10 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 /*
  * Useful functions for working with MDIO clause 45 PHYs
@@ -16,6 +32,23 @@
 #include "mdio_10g.h"
 #include "boards.h"
 
+static const char *mmd_block_names[] = {
+	[0]               = "(illegal)",
+	[MDIO_MMD_PMAPMD] = "PMA/PMD",
+	[MDIO_MMD_WIS]    = "WIS",
+	[MDIO_MMD_PCS]    = "PCS",
+	[MDIO_MMD_PHYXS]  = "PHY XS",
+	[MDIO_MMD_DTEXS]  = "DTE XS",
+	[MDIO_MMD_TC]     = "TC",
+	[MDIO_MMD_AN]     = "AN",
+};
+static const int mmd_block_max = ARRAY_SIZE(mmd_block_names);
+
+const char *mdio_clause45_mmd_name(int mmd)
+{
+	return STRING_TABLE_LOOKUP(mmd, mmd_block);
+}
+
 int mdio_clause45_reset_mmd(struct efx_nic *port, int mmd,
 			    int spins, int spintime)
 {
@@ -43,6 +76,7 @@ static int mdio_clause45_check_mmd(struc
 {
 	int status;
 	int phy_id = efx->mii.phy_id;
+	const char *mmdname = STRING_TABLE_LOOKUP(mmd, mmd_block);
 
 	if (LOOPBACK_INTERNAL(efx))
 		return 0;
@@ -52,7 +86,7 @@ static int mdio_clause45_check_mmd(struc
 	if (((status >> MDIO_MMDREG_STAT2_PRESENT_LBN) &
 	     ((1 << MDIO_MMDREG_STAT2_PRESENT_WIDTH) - 1)) !=
 	    MDIO_MMDREG_STAT2_PRESENT_VAL) {
-		EFX_ERR(efx, "PHY MMD %d not responding.\n", mmd);
+		EFX_ERR(efx, "PHY MMD %s not responding.\n", mmdname);
 		return -EIO;
 	}
 
@@ -60,12 +94,12 @@ static int mdio_clause45_check_mmd(struc
 	status = mdio_clause45_read(efx, phy_id, mmd, MDIO_MMDREG_STAT1);
 	if ((status & (1 << MDIO_MMDREG_STAT1_FAULT_LBN)) != 0) {
 		if (fault_fatal) {
-			EFX_ERR(efx, "PHY MMD %d reporting fatal"
-				" fault: status %x\n", mmd, status);
+			EFX_ERR(efx, "PHY MMD %s reporting fatal"
+				" fault: status %x\n", mmdname, status);
 			return -EIO;
 		} else {
-			EFX_LOG(efx, "PHY MMD %d reporting status"
-				" %x (expected)\n", mmd, status);
+			EFX_LOG(efx, "PHY MMD %s reporting status"
+				" %x (expected)\n", mmdname, status);
 		}
 	}
 	return 0;
@@ -95,8 +129,10 @@ int mdio_clause45_wait_reset_mmds(struct
 							  mmd,
 							  MDIO_MMDREG_CTRL1);
 				if (stat < 0) {
-					EFX_ERR(efx, "failed to read status of"
-						" MMD %d\n", mmd);
+					EFX_ERR(efx, "failed to read"
+						" status of MMD %s\n",
+						STRING_TABLE_LOOKUP(mmd,
+								    mmd_block));
 					return -EIO;
 				}
 				if (stat & (1 << MDIO_MMDREG_CTRL1_RESET_LBN))
@@ -173,6 +209,8 @@ int mdio_clause45_links_ok(struct efx_ni
 		return 1;
 	else if (efx->loopback_mode == LOOPBACK_NETWORK)
 		return 0;
+	else if (!efx->phy_powered)
+		return 0;
 	else if (efx->loopback_mode == LOOPBACK_PHYXS)
 		mmd_mask &= ~(MDIO_MMDREG_DEVS0_PHYXS |
 			      MDIO_MMDREG_DEVS0_PCS |
@@ -201,14 +239,14 @@ int mdio_clause45_links_ok(struct efx_ni
 	return ok;
 }
 
-void mdio_clause45_transmit_disable(struct efx_nic *efx)
+void mdio_clause45_transmit_disable(struct efx_nic *efx, int disable)
 {
 	int phy_id = efx->mii.phy_id;
 	int ctrl1, ctrl2;
 
 	ctrl1 = ctrl2 = mdio_clause45_read(efx, phy_id, MDIO_MMD_PMAPMD,
 					   MDIO_MMDREG_TXDIS);
-	if (efx->tx_disabled)
+	if (disable)
 		ctrl2 |= (1 << MDIO_MMDREG_TXDIS_GLOBAL_LBN);
 	else
 		ctrl1 &= ~(1 << MDIO_MMDREG_TXDIS_GLOBAL_LBN);
@@ -260,6 +298,49 @@ void mdio_clause45_phy_reconfigure(struc
 				    MDIO_MMDREG_CTRL1, ctrl2);
 }
 
+static void mdio_clause45_set_mmd_lpower(struct efx_nic *efx,
+					 int lpower, int mmd)
+{
+	const char *mmdname = STRING_TABLE_LOOKUP(mmd, mmd_block);
+	int phy = efx->mii.phy_id;
+	int stat = mdio_clause45_read(efx, phy, mmd, MDIO_MMDREG_STAT1);
+	int ctrl1, ctrl2;
+
+	EFX_TRACE(efx, "Setting low power mode for MMD %s to %d\n",
+		  mmdname, lpower);
+
+	if (stat & (1 << MDIO_MMDREG_STAT1_LPABLE_LBN)) {
+		ctrl1 = ctrl2 = mdio_clause45_read(efx, phy,
+						   mmd, MDIO_MMDREG_CTRL1);
+		if (lpower)
+			ctrl2 |= (1 << MDIO_MMDREG_CTRL1_LPOWER_LBN);
+		else
+			ctrl2 &= ~(1 << MDIO_MMDREG_CTRL1_LPOWER_LBN);
+		if (ctrl1 != ctrl2)
+			mdio_clause45_write(efx, phy, mmd,
+					    MDIO_MMDREG_CTRL1, ctrl2);
+	} else {
+		/* If we ever want a completely generic PHY driver
+		 * that which just does clause 45, we may consider not
+		 * complaining, but for now expect the driver to know
+		 * which MMDs to apply this to. */
+		EFX_ERR(efx, "Attempt change power setting of MMD %s"
+			" which doesn't support it.\n",	mmdname);
+	}
+}
+
+void mdio_clause45_set_mmds_lpower(struct efx_nic *efx,
+				   int low_power, unsigned int mmd_mask)
+{
+	int mmd = 0;
+	while (mmd_mask) {
+		if (mmd_mask & 1)
+			mdio_clause45_set_mmd_lpower(efx, low_power, mmd);
+		mmd_mask = (mmd_mask >> 1);
+		mmd++;
+	}
+}
+
 /**
  * mdio_clause45_get_settings - Read (some of) the PHY settings over MDIO.
  * @efx:		Efx NIC
Index: head-2008-06-18/drivers/net/sfc/mdio_10g.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/mdio_10g.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/mdio_10g.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,10 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_MDIO_10G_H
@@ -51,9 +67,13 @@
 #define MDIO_MMDREG_CTRL1_RESET_LBN	(15)
 #define MDIO_MMDREG_CTRL1_RESET_WIDTH	(1)
 /* Loopback */
-/* Loopback bit for WIS, PCS, PHYSX and DTEXS */
+/* Note that while WIS, PCS, PHYXS and DTEXS have the loopback bit here,
+ * the PMA/PMD does not. */
 #define MDIO_MMDREG_CTRL1_LBACK_LBN	(14)
 #define MDIO_MMDREG_CTRL1_LBACK_WIDTH	(1)
+/* Low power */
+#define MDIO_MMDREG_CTRL1_LPOWER_LBN	(11)
+#define MDIO_MMDREG_CTRL1_LPOWER_WIDTH	(1)
 
 /* Bits in MMDREG_STAT1 */
 #define MDIO_MMDREG_STAT1_FAULT_LBN	(7)
@@ -75,9 +95,13 @@
  * that MMD */
 #define DEV_PRESENT_BIT(_b) (1 << _b)
 
+#define MDIO_MMDREG_DEVS0_DTEXS	 DEV_PRESENT_BIT(MDIO_MMD_DTEXS)
 #define MDIO_MMDREG_DEVS0_PHYXS	 DEV_PRESENT_BIT(MDIO_MMD_PHYXS)
 #define MDIO_MMDREG_DEVS0_PCS	 DEV_PRESENT_BIT(MDIO_MMD_PCS)
+#define MDIO_MMDREG_DEVS0_WIS	 DEV_PRESENT_BIT(MDIO_MMD_WIS)
 #define MDIO_MMDREG_DEVS0_PMAPMD DEV_PRESENT_BIT(MDIO_MMD_PMAPMD)
+#define MDIO_MMDREG_DEVS0_AN     DEV_PRESENT_BIT(MDIO_MMD_AN)
+
 
 /* Bits in MMDREG_STAT2 */
 #define MDIO_MMDREG_STAT2_PRESENT_VAL	(2)
@@ -111,9 +135,21 @@
 #define MDIO_PMAPMD_CTRL2_10_BT		(0xf)
 #define MDIO_PMAPMD_CTRL2_TYPE_MASK	(0xf)
 
+/* PCS 10GBT registers */
+#define MDIO_PCS_10GBT_STATUS		(32)
+#define MDIO_PCS_10GBT_STATUS2		(33)
+#define MDIO_PCS_10GBT_STATUS2_BER_LBN	(8)
+#define MDIO_PCS_10GBT_STATUS2_BER_WIDTH	(6)
+#define MDIO_PCS_10GBT_STATUS2_ERR_LBN	(0)
+#define MDIO_PCS_10GBT_STATUS2_ERR_WIDTH	(8)
+
 /* PHY XGXS lane state */
 #define MDIO_PHYXS_LANE_STATE		(0x18)
 #define MDIO_PHYXS_LANE_ALIGNED_LBN	(12)
+#define MDIO_PHYXS_LANE_SYNC0_LBN	(0)
+#define MDIO_PHYXS_LANE_SYNC1_LBN	(1)
+#define MDIO_PHYXS_LANE_SYNC2_LBN	(2)
+#define MDIO_PHYXS_LANE_SYNC3_LBN	(3)
 
 /* AN registers */
 #define MDIO_AN_STATUS			(1)
@@ -234,11 +270,16 @@ extern int mdio_clause45_links_ok(struct
 				  unsigned int mmd_mask);
 
 /* Generic transmit disable support though PMAPMD */
-extern void mdio_clause45_transmit_disable(struct efx_nic *efx);
+extern void mdio_clause45_transmit_disable(struct efx_nic *efx,
+					   int disable);
 
 /* Generic part of reconfigure: set/clear loopback bits */
 extern void mdio_clause45_phy_reconfigure(struct efx_nic *efx);
 
+/* Set the power state of the specified MMDs */
+extern void mdio_clause45_set_mmds_lpower(struct efx_nic *efx,
+					  int low_power, unsigned int mmd_mask);
+
 /* Read (some of) the PHY settings over MDIO */
 extern void mdio_clause45_get_settings(struct efx_nic *efx,
 				       struct ethtool_cmd *ecmd);
Index: head-2008-06-18/drivers/net/sfc/mentormac.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/mentormac.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,506 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#include <linux/delay.h>
+#include "net_driver.h"
+#include "gmii.h"
+#include "mac.h"
+
+/*
+ * Mentor MAC control
+ */
+
+/**************************************************************************
+ *
+ * Mentor MAC registers
+ *
+ **************************************************************************
+ *
+ * Register addresses are Mentor MAC register numbers.  Falcon maps these
+ * registers in at 16-byte intervals.  The mac_writel() and mac_readl()
+ * methods take care of abstracting away this difference.
+ */
+
+/* GMAC configuration register 1 */
+#define GM_CFG1_REG_MAC 0x00
+#define GM_SW_RST_LBN 31
+#define GM_SW_RST_WIDTH 1
+#define GM_SIM_RST_LBN 30
+#define GM_SIM_RST_WIDTH 1
+#define GM_RST_RX_MAC_CTL_LBN 19
+#define GM_RST_RX_MAC_CTL_WIDTH 1
+#define GM_RST_TX_MAC_CTL_LBN 18
+#define GM_RST_TX_MAC_CTL_WIDTH 1
+#define GM_RST_RX_FUNC_LBN 17
+#define GM_RST_RX_FUNC_WIDTH 1
+#define GM_RST_TX_FUNC_LBN 16
+#define GM_RST_TX_FUNC_WIDTH 1
+#define GM_LOOP_LBN 8
+#define GM_LOOP_WIDTH 1
+#define GM_RX_FC_EN_LBN 5
+#define GM_RX_FC_EN_WIDTH 1
+#define GM_TX_FC_EN_LBN 4
+#define GM_TX_FC_EN_WIDTH 1
+#define GM_SYNC_RXEN_LBN 3
+#define GM_SYNC_RXEN_WIDTH 1
+#define GM_RX_EN_LBN 2
+#define GM_RX_EN_WIDTH 1
+#define GM_SYNC_TXEN_LBN 1
+#define GM_SYNC_TXEN_WIDTH 1
+#define GM_TX_EN_LBN 0
+#define GM_TX_EN_WIDTH 1
+
+/* GMAC configuration register 2 */
+#define GM_CFG2_REG_MAC 0x01
+#define GM_PAMBL_LEN_LBN 12
+#define GM_PAMBL_LEN_WIDTH 4
+#define GM_IF_MODE_LBN 8
+#define GM_IF_MODE_WIDTH 2
+#define GM_HUGE_FRM_EN_LBN 5
+#define GM_HUGE_FRM_EN_WIDTH 1
+#define GM_LEN_CHK_LBN 4
+#define GM_LEN_CHK_WIDTH 1
+#define GM_PAD_CRC_EN_LBN 2
+#define GM_PAD_CRC_EN_WIDTH 1
+#define GM_CRC_EN_LBN 1
+#define GM_CRC_EN_WIDTH 1
+#define GM_FD_LBN 0
+#define GM_FD_WIDTH 1
+
+/* GMAC maximum frame length register */
+#define GM_MAX_FLEN_REG_MAC 0x04
+#define GM_MAX_FLEN_LBN 0
+#define GM_MAX_FLEN_WIDTH 16
+
+/* GMAC MII management configuration register */
+#define GM_MII_MGMT_CFG_REG_MAC 0x08
+#define GM_RST_MII_MGMT_LBN 31
+#define GM_RST_MII_MGMT_WIDTH 1
+#define GM_MGMT_SCAN_AUTO_INC_LBN 5
+#define GM_MGMT_SCAN_AUTO_INC_WIDTH 1
+#define GM_MGMT_PREM_SUPR_LBN 4
+#define GM_MGMT_PREM_SUPR_WIDTH 1
+#define GM_MGMT_CLK_SEL_LBN 0
+#define GM_MGMT_CLK_SEL_WIDTH 3
+
+/* GMAC MII management command register */
+#define GM_MII_MGMT_CMD_REG_MAC 0x09
+#define GM_MGMT_SCAN_CYC_LBN 1
+#define GM_MGMT_SCAN_CYC_WIDTH 1
+#define GM_MGMT_RD_CYC_LBN 0
+#define GM_MGMT_RD_CYC_WIDTH 1
+
+/* GMAC MII management address register */
+#define GM_MII_MGMT_ADR_REG_MAC 0x0a
+#define GM_MGMT_PHY_ADDR_LBN 8
+#define GM_MGMT_PHY_ADDR_WIDTH 5
+#define GM_MGMT_REG_ADDR_LBN 0
+#define GM_MGMT_REG_ADDR_WIDTH 5
+
+/* GMAC MII management control register */
+#define GM_MII_MGMT_CTL_REG_MAC 0x0b
+#define GM_MGMT_CTL_LBN 0
+#define GM_MGMT_CTL_WIDTH 16
+
+/* GMAC MII management status register */
+#define GM_MII_MGMT_STAT_REG_MAC 0x0c
+#define GM_MGMT_STAT_LBN 0
+#define GM_MGMT_STAT_WIDTH 16
+
+/* GMAC MII management indicators register */
+#define GM_MII_MGMT_IND_REG_MAC 0x0d
+#define GM_MGMT_NOT_VLD_LBN 2
+#define GM_MGMT_NOT_VLD_WIDTH 1
+#define GM_MGMT_SCANNING_LBN 1
+#define GM_MGMT_SCANNING_WIDTH 1
+#define GM_MGMT_BUSY_LBN 0
+#define GM_MGMT_BUSY_WIDTH 1
+
+/* GMAC station address register 1 */
+#define GM_ADR1_REG_MAC 0x10
+#define GM_HWADDR_5_LBN 24
+#define GM_HWADDR_5_WIDTH 8
+#define GM_HWADDR_4_LBN 16
+#define GM_HWADDR_4_WIDTH 8
+#define GM_HWADDR_3_LBN 8
+#define GM_HWADDR_3_WIDTH 8
+#define GM_HWADDR_2_LBN 0
+#define GM_HWADDR_2_WIDTH 8
+
+/* GMAC station address register 2 */
+#define GM_ADR2_REG_MAC 0x11
+#define GM_HWADDR_1_LBN 24
+#define GM_HWADDR_1_WIDTH 8
+#define GM_HWADDR_0_LBN 16
+#define GM_HWADDR_0_WIDTH 8
+
+/* GMAC FIFO configuration register 0 */
+#define GMF_CFG0_REG_MAC 0x12
+#define GMF_FTFENRPLY_LBN 20
+#define GMF_FTFENRPLY_WIDTH 1
+#define GMF_STFENRPLY_LBN 19
+#define GMF_STFENRPLY_WIDTH 1
+#define GMF_FRFENRPLY_LBN 18
+#define GMF_FRFENRPLY_WIDTH 1
+#define GMF_SRFENRPLY_LBN 17
+#define GMF_SRFENRPLY_WIDTH 1
+#define GMF_WTMENRPLY_LBN 16
+#define GMF_WTMENRPLY_WIDTH 1
+#define GMF_FTFENREQ_LBN 12
+#define GMF_FTFENREQ_WIDTH 1
+#define GMF_STFENREQ_LBN 11
+#define GMF_STFENREQ_WIDTH 1
+#define GMF_FRFENREQ_LBN 10
+#define GMF_FRFENREQ_WIDTH 1
+#define GMF_SRFENREQ_LBN 9
+#define GMF_SRFENREQ_WIDTH 1
+#define GMF_WTMENREQ_LBN 8
+#define GMF_WTMENREQ_WIDTH 1
+#define GMF_HSTRSTFT_LBN 4
+#define GMF_HSTRSTFT_WIDTH 1
+#define GMF_HSTRSTST_LBN 3
+#define GMF_HSTRSTST_WIDTH 1
+#define GMF_HSTRSTFR_LBN 2
+#define GMF_HSTRSTFR_WIDTH 1
+#define GMF_HSTRSTSR_LBN 1
+#define GMF_HSTRSTSR_WIDTH 1
+#define GMF_HSTRSTWT_LBN 0
+#define GMF_HSTRSTWT_WIDTH 1
+
+/* GMAC FIFO configuration register 1 */
+#define GMF_CFG1_REG_MAC 0x13
+#define GMF_CFGFRTH_LBN 16
+#define GMF_CFGFRTH_WIDTH 5
+#define GMF_CFGXOFFRTX_LBN 0
+#define GMF_CFGXOFFRTX_WIDTH 16
+
+/* GMAC FIFO configuration register 2 */
+#define GMF_CFG2_REG_MAC 0x14
+#define GMF_CFGHWM_LBN 16
+#define GMF_CFGHWM_WIDTH 6
+#define GMF_CFGLWM_LBN 0
+#define GMF_CFGLWM_WIDTH 6
+
+/* GMAC FIFO configuration register 3 */
+#define GMF_CFG3_REG_MAC 0x15
+#define GMF_CFGHWMFT_LBN 16
+#define GMF_CFGHWMFT_WIDTH 6
+#define GMF_CFGFTTH_LBN 0
+#define GMF_CFGFTTH_WIDTH 6
+
+/* GMAC FIFO configuration register 4 */
+#define GMF_CFG4_REG_MAC 0x16
+#define GMF_HSTFLTRFRM_LBN 0
+#define GMF_HSTFLTRFRM_WIDTH 18
+#define GMF_HSTFLTRFRM_PAUSE_LBN 12
+#define GMF_HSTFLTRFRM_PAUSE_WIDTH 12
+
+/* GMAC FIFO configuration register 5 */
+#define GMF_CFG5_REG_MAC 0x17
+#define GMF_CFGHDPLX_LBN 22
+#define GMF_CFGHDPLX_WIDTH 1
+#define GMF_SRFULL_LBN 21
+#define GMF_SRFULL_WIDTH 1
+#define GMF_HSTSRFULLCLR_LBN 20
+#define GMF_HSTSRFULLCLR_WIDTH 1
+#define GMF_CFGBYTMODE_LBN 19
+#define GMF_CFGBYTMODE_WIDTH 1
+#define GMF_HSTDRPLT64_LBN 18
+#define GMF_HSTDRPLT64_WIDTH 1
+#define GMF_HSTFLTRFRMDC_LBN 0
+#define GMF_HSTFLTRFRMDC_WIDTH 18
+#define GMF_HSTFLTRFRMDC_PAUSE_LBN 12
+#define GMF_HSTFLTRFRMDC_PAUSE_WIDTH 1
+
+/* TX total octet count */
+#define GM_TX_OCT_CNT_REG_MAC 0x40
+#define GM_STAT_LBN 0
+#define GM_STAT_WIDTH 32
+
+/* TX good octet count */
+#define GM_TX_GOOD_OCT_CNT_REG_MAC 0x41
+
+/* TX single collision packet count */
+#define GM_TX_SGLCOL_PKT_CNT_REG_MAC 0x42
+
+/* TX multiple collision packet count */
+#define GM_TX_MULTCOL_PKT_CNT_REG_MAC 0x43
+
+/* TX excessive collision packet count */
+#define GM_TX_EXCOL_PKT_CNT_REG_MAC 0x44
+
+/* TX deferred packet count */
+#define GM_TX_DEF_PKT_CNT_REG_MAC 0x45
+
+/* TX late packet count */
+#define GM_TX_LATECOL_PKT_CNT_REG_MAC 0x46
+
+/* TX excessive deferral packet count */
+#define GM_TX_EXDEF_PKT_CNT_REG_MAC 0x47
+
+/* TX pause packet count */
+#define GM_TX_PAUSE_PKT_CNT_REG_MAC 0x48
+
+/* TX bad packet count */
+#define GM_TX_BAD_PKT_CNT_REG_MAC 0x49
+
+/* TX unicast packet count */
+#define GM_TX_UCAST_PKT_CNT_REG_MAC 0x4a
+
+/* TX multicast packet count */
+#define GM_TX_MCAST_PKT_CNT_REG_MAC 0x4b
+
+/* TX broadcast packet count */
+#define GM_TX_BCAST_PKT_CNT_REG_MAC 0x4c
+
+/* TX <64-byte packet count */
+#define GM_TX_LT64_PKT_CNT_REG_MAC 0x4d
+
+/* TX 64-byte packet count */
+#define GM_TX_64_PKT_CNT_REG_MAC 0x4e
+
+/* TX 65-byte to 127-byte packet count */
+#define GM_TX_65_TO_127_PKT_CNT_REG_MAC 0x4f
+
+/* TX 128-byte to 255-byte packet count */
+#define GM_TX_128_TO_255_PKT_CNT_REG_MAC 0x50
+
+/* TX 256-byte to 511-byte packet count */
+#define GM_TX_256_TO_511_PKT_CNT_REG_MAC 0x51
+
+/* TX 512-byte to 1023-byte packet count */
+#define GM_TX_512_TO_1023_PKT_CNT_REG_MAC 0x52
+
+/* TX 1024-byte to 15xx-byte packet count */
+#define GM_TX_1024_TO_15XX_PKT_CNT_REG_MAC 0x53
+
+/* TX 15xx-byte to jumbo packet count */
+#define GM_TX_15XX_TO_JUMBO_PKT_CNT_REG_MAC 0x54
+
+/* TX >jumbo packet count */
+#define GM_TX_GTJUMBO_PKT_CNT_REG_MAC 0x55
+
+/* RX good octet count */
+#define GM_RX_GOOD_OCT_CNT_REG_MAC 0x60
+
+/* RX bad octet count */
+#define GM_RX_BAD_OCT_CNT_REG_MAC 0x61
+
+/* RX missed packet count */
+#define GM_RX_MISS_PKT_CNT_REG_MAC 0x62
+
+/* RX false carrier count */
+#define GM_RX_FALSE_CRS_CNT_REG_MAC 0x63
+
+/* RX pause packet count */
+#define GM_RX_PAUSE_PKT_CNT_REG_MAC 0x64
+
+/* RX bad packet count */
+#define GM_RX_BAD_PKT_CNT_REG_MAC 0x65
+
+/* RX unicast packet count */
+#define GM_RX_UCAST_PKT_CNT_REG_MAC 0x66
+
+/* RX multicast packet count */
+#define GM_RX_MCAST_PKT_CNT_REG_MAC 0x67
+
+/* RX broadcast packet count */
+#define GM_RX_BCAST_PKT_CNT_REG_MAC 0x68
+
+/* RX <64-byte good packet count */
+#define GM_RX_GOOD_LT64_PKT_CNT_REG_MAC 0x69
+
+/* RX <64-byte bad packet count */
+#define GM_RX_BAD_LT64_PKT_CNT_REG_MAC 0x6a
+
+/* RX 64-byte packet count */
+#define GM_RX_64_PKT_CNT_REG_MAC 0x6b
+
+/* RX 65-byte to 127-byte packet count */
+#define GM_RX_65_TO_127_PKT_CNT_REG_MAC 0x6c
+
+/* RX 128-byte to 255-byte packet count*/
+#define GM_RX_128_TO_255_PKT_CNT_REG_MAC 0x6d
+
+/* RX 256-byte to 511-byte packet count */
+#define GM_RX_256_TO_511_PKT_CNT_REG_MAC 0x6e
+
+/* RX 512-byte to 1023-byte packet count */
+#define GM_RX_512_TO_1023_PKT_CNT_REG_MAC 0x6f
+
+/* RX 1024-byte to 15xx-byte packet count */
+#define GM_RX_1024_TO_15XX_PKT_CNT_REG_MAC 0x70
+
+/* RX 15xx-byte to jumbo packet count */
+#define GM_RX_15XX_TO_JUMBO_PKT_CNT_REG_MAC 0x71
+
+/* RX >jumbo packet count */
+#define GM_RX_GTJUMBO_PKT_CNT_REG_MAC 0x72
+
+/* RX 64-byte to 15xx-byte bad crc packet count */
+#define GM_RX_BAD_64_TO_15XX_PKT_CNT_REG_MAC 0x73
+
+/* RX 15xx-byte to jumbo bad crc packet count */
+#define GM_RX_BAD_15XX_TO_JUMBO_PKT_CNT_REG_MAC 0x74
+
+/* RX >jumbo bad crc packet count */
+#define GM_RX_BAD_GTJUMBO_PKT_CNT_REG_MAC 0x75
+
+/**************************************************************************
+ *
+ * GMII access to PHY
+ *
+ **************************************************************************
+ */
+
+/* This does not reset the PHY, only the MAC.  However, TX and RX will
+ * both be disabled on the MAC after this, so the state of the PHY is
+ * somewhat irrelevant until the MAC is reinitialised.
+ */
+void mentormac_reset(struct efx_nic *efx)
+{
+	efx_dword_t reg;
+
+	EFX_POPULATE_DWORD_1(reg, GM_SW_RST, 1);
+	efx->mac_op->mac_writel(efx, &reg, GM_CFG1_REG_MAC);
+	udelay(1000);
+
+	EFX_POPULATE_DWORD_1(reg, GM_SW_RST, 0);
+	efx->mac_op->mac_writel(efx, &reg, GM_CFG1_REG_MAC);
+	udelay(1000);
+
+	/* Configure GMII interface so PHY is accessible */
+	EFX_POPULATE_DWORD_1(reg, GM_MGMT_CLK_SEL, 0x4);
+	efx->mac_op->mac_writel(efx, &reg,
+				     GM_MII_MGMT_CFG_REG_MAC);
+	udelay(10);
+}
+
+void mentormac_reconfigure(struct efx_nic *efx)
+{
+	int loopback, tx_fc, rx_fc, if_mode, full_duplex, bytemode, half_duplex;
+	unsigned int max_frame_len;
+	efx_dword_t reg;
+
+	/* Configuration register 1 */
+	tx_fc = (efx->flow_control & EFX_FC_TX) ? 1 : 0;
+	rx_fc = (efx->flow_control & EFX_FC_RX) ? 1 : 0;
+	loopback = (efx->loopback_mode == LOOPBACK_MAC) ? 1 : 0;
+	bytemode = (efx->link_options & GM_LPA_1000) ? 1 : 0;
+
+	if (efx->loopback_mode != LOOPBACK_NONE)
+		bytemode = 1;
+	if (!(efx->link_options & GM_LPA_DUPLEX))
+		/* Half-duplex operation requires TX flow control */
+		tx_fc = 1;
+	EFX_POPULATE_DWORD_5(reg,
+			     GM_LOOP, loopback,
+			     GM_TX_EN, 1,
+			     GM_TX_FC_EN, tx_fc,
+			     GM_RX_EN, 1,
+			     GM_RX_FC_EN, rx_fc);
+	efx->mac_op->mac_writel(efx, &reg, GM_CFG1_REG_MAC);
+	udelay(10);
+
+	/* Configuration register 2 */
+	if_mode = (bytemode) ? 2 : 1;
+	full_duplex = (efx->link_options & GM_LPA_DUPLEX) ? 1 : 0;
+	EFX_POPULATE_DWORD_4(reg,
+			     GM_IF_MODE, if_mode,
+			     GM_PAD_CRC_EN, 1,
+			     GM_FD, full_duplex,
+			     GM_PAMBL_LEN, 0x7/*datasheet recommended */);
+
+	efx->mac_op->mac_writel(efx, &reg, GM_CFG2_REG_MAC);
+	udelay(10);
+
+	/* Max frame len register */
+	max_frame_len = EFX_MAX_FRAME_LEN(efx->net_dev->mtu);
+	EFX_POPULATE_DWORD_1(reg, GM_MAX_FLEN, max_frame_len);
+	efx->mac_op->mac_writel(efx, &reg, GM_MAX_FLEN_REG_MAC);
+	udelay(10);
+
+	/* FIFO configuration register 0 */
+	EFX_POPULATE_DWORD_5(reg,
+			     GMF_FTFENREQ, 1,
+			     GMF_STFENREQ, 1,
+			     GMF_FRFENREQ, 1,
+			     GMF_SRFENREQ, 1,
+			     GMF_WTMENREQ, 1);
+	efx->mac_op->mac_writel(efx, &reg, GMF_CFG0_REG_MAC);
+	udelay(10);
+
+	/* FIFO configuration register 1 */
+	EFX_POPULATE_DWORD_2(reg,
+			     GMF_CFGFRTH, 0x12,
+			     GMF_CFGXOFFRTX, 0xffff);
+	efx->mac_op->mac_writel(efx, &reg, GMF_CFG1_REG_MAC);
+	udelay(10);
+
+	/* FIFO configuration register 2 */
+	EFX_POPULATE_DWORD_2(reg,
+			     GMF_CFGHWM, 0x3f,
+			     GMF_CFGLWM, 0xa);
+	efx->mac_op->mac_writel(efx, &reg, GMF_CFG2_REG_MAC);
+	udelay(10);
+
+	/* FIFO configuration register 3 */
+	EFX_POPULATE_DWORD_2(reg,
+			     GMF_CFGHWMFT, 0x1c,
+			     GMF_CFGFTTH, 0x08);
+	efx->mac_op->mac_writel(efx, &reg, GMF_CFG3_REG_MAC);
+	udelay(10);
+
+	/* FIFO configuration register 4 */
+	EFX_POPULATE_DWORD_1(reg, GMF_HSTFLTRFRM_PAUSE, 1);
+	efx->mac_op->mac_writel(efx, &reg, GMF_CFG4_REG_MAC);
+	udelay(10);
+
+	/* FIFO configuration register 5 */
+	half_duplex = (efx->link_options & GM_LPA_DUPLEX) ? 0 : 1;
+	efx->mac_op->mac_readl(efx, &reg, GMF_CFG5_REG_MAC);
+	EFX_SET_DWORD_FIELD(reg, GMF_CFGBYTMODE, bytemode);
+	EFX_SET_DWORD_FIELD(reg, GMF_CFGHDPLX, half_duplex);
+	EFX_SET_DWORD_FIELD(reg, GMF_HSTDRPLT64, half_duplex);
+	EFX_SET_DWORD_FIELD(reg, GMF_HSTFLTRFRMDC_PAUSE, 0);
+	efx->mac_op->mac_writel(efx, &reg, GMF_CFG5_REG_MAC);
+	udelay(10);
+
+	/* MAC address */
+	EFX_POPULATE_DWORD_4(reg,
+			     GM_HWADDR_5, efx->net_dev->dev_addr[5],
+			     GM_HWADDR_4, efx->net_dev->dev_addr[4],
+			     GM_HWADDR_3, efx->net_dev->dev_addr[3],
+			     GM_HWADDR_2, efx->net_dev->dev_addr[2]);
+	efx->mac_op->mac_writel(efx, &reg, GM_ADR1_REG_MAC);
+	udelay(10);
+	EFX_POPULATE_DWORD_2(reg,
+			     GM_HWADDR_1, efx->net_dev->dev_addr[1],
+			     GM_HWADDR_0, efx->net_dev->dev_addr[0]);
+	efx->mac_op->mac_writel(efx, &reg, GM_ADR2_REG_MAC);
+	udelay(10);
+}
Index: head-2008-06-18/drivers/net/sfc/mtd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/mtd.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,598 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+
+#define EFX_DRIVER_NAME "sfc_mtd"
+#include "driverlink_api.h"
+#include "net_driver.h"
+#include "spi.h"
+
+/*
+ * Flash and EEPROM (MTD) device driver
+ *
+ * This file provides a separate kernel module (sfc_mtd) which
+ * exposes the flash and EEPROM devices present on Solarflare NICs as
+ * MTD devices, enabling you to reflash the boot ROM code (or use the
+ * remaining space on the flash as a jffs2 filesystem, should you want
+ * to do so).
+ */
+
+#define EFX_MTD_VERIFY_BUF_LEN 16
+#define EFX_MAX_PARTITIONS 2
+#define EFX_FLASH_BOOTROM_OFFSET 0x8000U
+
+/* Write enable for EEPROM/flash configuration area
+ *
+ * Normally, writes to parts of non-volatile storage which contain
+ * critical configuration are disabled to prevent accidents.  This
+ * parameter allows enabling of such writes.
+ */
+static unsigned int efx_allow_nvconfig_writes;
+
+struct efx_mtd {
+	struct mtd_info mtd;
+	struct mtd_partition part[EFX_MAX_PARTITIONS];
+	char part_name[EFX_MAX_PARTITIONS][32];
+	char name[32];
+	struct efx_dl_device *efx_dev;
+	struct efx_nic *efx;
+	/* This must be held when using *spi; it guards against races
+	 * with device reset and between sequences of dependent
+	 * commands. */
+	struct semaphore access_lock;
+	struct efx_spi_device *spi;
+};
+
+/* SPI utilities */
+
+static int efx_spi_fast_wait(struct efx_mtd *efx_mtd)
+{
+	struct efx_spi_device *spi = efx_mtd->spi;
+	u8 status;
+	int i, rc;
+
+	/* Wait up to 1000us for flash/EEPROM to finish a fast operation. */
+	for (i = 0; i < 50; i++) {
+		udelay(20);
+
+		rc = spi->read(spi, efx_mtd->efx, SPI_RDSR, -1,
+			       &status, sizeof(status));
+		if (rc)
+			return rc;
+		if (!(status & SPI_STATUS_NRDY))
+			return 0;
+	}
+	EFX_ERR(efx_mtd->efx, "timed out waiting for %s last status=0x%02x\n",
+		efx_mtd->name, status);
+	return -ETIMEDOUT;
+}
+
+static int efx_spi_slow_wait(struct efx_mtd *efx_mtd, int uninterruptible)
+{
+	struct efx_spi_device *spi = efx_mtd->spi;
+	u8 status;
+	int rc, i;
+
+	/* Wait up to 4s for flash/EEPROM to finish a slow operation. */
+	for (i = 0; i < 40; i++) {
+		__set_current_state(uninterruptible ?
+				    TASK_UNINTERRUPTIBLE : TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ / 10);
+		rc = spi->read(spi, efx_mtd->efx, SPI_RDSR, -1,
+			       &status, sizeof(status));
+		if (rc)
+			return rc;
+		if (!(status & SPI_STATUS_NRDY))
+			return 0;
+		if (signal_pending(current))
+			return -EINTR;
+	}
+	EFX_ERR(efx_mtd->efx, "timed out waiting for %s\n", efx_mtd->name);
+	return -ETIMEDOUT;
+}
+
+static int
+efx_spi_write_enable(struct efx_mtd *efx_mtd)
+{
+	struct efx_spi_device *spi = efx_mtd->spi;
+
+	return spi->write(spi, efx_mtd->efx, SPI_WREN, -1, NULL, 0);
+}
+
+static int efx_spi_unlock(struct efx_mtd *efx_mtd)
+{
+	struct efx_spi_device *spi = efx_mtd->spi;
+	const u8 unlock_mask = (SPI_STATUS_BP2 | SPI_STATUS_BP1 |
+				     SPI_STATUS_BP0);
+	u8 status;
+	int rc;
+
+	rc = spi->read(spi, efx_mtd->efx, SPI_RDSR, -1, &status,
+		       sizeof(status));
+	if (rc)
+		return rc;
+
+	if (!(status & unlock_mask))
+		return 0; /* already unlocked */
+
+	rc = efx_spi_write_enable(efx_mtd);
+	if (rc)
+		return rc;
+	rc = spi->write(spi, efx_mtd->efx, SPI_SST_EWSR, -1, NULL, 0);
+	if (rc)
+		return rc;
+
+	status &= ~unlock_mask;
+	rc = spi->write(spi, efx_mtd->efx, SPI_WRSR, -1, &status,
+			sizeof(status));
+	if (rc)
+		return rc;
+	rc = efx_spi_fast_wait(efx_mtd);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+/* Dummy device used in case of a failed reset */
+
+static int efx_spi_dummy_read(const struct efx_spi_device *spi,
+			      struct efx_nic *efx, unsigned int command,
+			      int address, void *data, unsigned int len)
+{
+	return -EIO;
+}
+
+static int efx_spi_dummy_write(const struct efx_spi_device *spi,
+			       struct efx_nic *efx, unsigned int command,
+			       int address, const void *data, unsigned int len)
+{
+	return -EIO;
+}
+
+static struct efx_spi_device efx_spi_dummy_device = {
+	.block_size	= 1,
+	.erase_command	= 0xff,
+	.read		= efx_spi_dummy_read,
+	.write		= efx_spi_dummy_write,
+};
+
+/* MTD interface */
+
+static int efx_mtd_read(struct mtd_info *mtd, loff_t start, size_t len,
+			size_t *retlen, u8 *buffer)
+{
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_spi_device *spi;
+	unsigned int command;
+	unsigned int block_len;
+	unsigned int pos = 0;
+	int rc;
+
+	rc = down_interruptible(&efx_mtd->access_lock);
+	if (rc)
+		goto out;
+	spi = efx_mtd->spi;
+
+	while (pos < len) {
+		block_len = min((unsigned int)len - pos,
+				efx_spi_read_limit(spi, start + pos));
+		command = efx_spi_munge_command(spi, SPI_READ, start + pos);
+		rc = spi->read(spi, efx_mtd->efx, command, start + pos,
+			       buffer + pos, block_len);
+		if (rc)
+			break;
+		pos += block_len;
+
+		/* Avoid locking up the system */
+		cond_resched();
+		if (signal_pending(current)) {
+			rc = -EINTR;
+			break;
+		}
+	}
+
+	up(&efx_mtd->access_lock);
+out:
+	*retlen = pos;
+	return rc;
+}
+
+/* Check that device contents match buffer.  If repeat is true, buffer
+ * contains a pattern of length EFX_MTD_VERIFY_BUF_LEN which the
+ * device contents should match repeatedly.
+ */
+static int efx_mtd_verify(struct mtd_info *mtd, loff_t start,
+			  size_t len, const u8 *buffer, int repeat)
+{
+	u8 verify_buffer[EFX_MTD_VERIFY_BUF_LEN];
+	unsigned int block_len;
+	size_t read_len;
+	unsigned int pos = 0;
+	int rc = 0;
+
+	while (pos < len) {
+		block_len = min(len - pos, sizeof(verify_buffer));
+		rc = efx_mtd_read(mtd, start + pos, block_len, &read_len,
+				  verify_buffer);
+		if (rc)
+			return rc;
+		if (memcmp(repeat ? buffer : buffer + pos, verify_buffer,
+			   block_len))
+			return -EIO;
+		pos += block_len;
+	}
+
+	return 0;
+}
+
+static int efx_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)
+{
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_spi_device *spi;
+	u8 empty[EFX_MTD_VERIFY_BUF_LEN];
+	int rc;
+
+	if (erase->len != mtd->erasesize) {
+		rc = -EINVAL;
+		goto out;
+	}
+
+	rc = down_interruptible(&efx_mtd->access_lock);
+	if (rc)
+		goto out;
+	spi = efx_mtd->spi;
+	if (spi->erase_command == 0) {
+		rc = -EOPNOTSUPP;
+		goto out_up;
+	}
+
+	rc = efx_spi_unlock(efx_mtd);
+	if (rc)
+		goto out_up;
+	rc = efx_spi_write_enable(efx_mtd);
+	if (rc)
+		goto out_up;
+	rc = spi->write(spi, efx_mtd->efx, spi->erase_command, erase->addr,
+			NULL, 0);
+	if (rc)
+		goto out_up;
+	rc = efx_spi_slow_wait(efx_mtd, 0);
+
+out_up:
+	up(&efx_mtd->access_lock);
+	if (rc)
+		goto out;
+
+	memset(empty, 0xff, sizeof(empty));
+	rc = efx_mtd_verify(mtd, erase->addr, erase->len, empty, 1);
+
+out:
+	if (rc == 0) {
+		erase->state = MTD_ERASE_DONE;
+	} else {
+		erase->state = MTD_ERASE_FAILED;
+		erase->fail_addr = 0xffffffff;
+	}
+	mtd_erase_callback(erase);
+	return rc;
+}
+
+static int efx_mtd_write(struct mtd_info *mtd, loff_t start,
+			 size_t len, size_t *retlen, const u8 *buffer)
+{
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_spi_device *spi;
+	unsigned int command;
+	unsigned int block_len;
+	unsigned int pos = 0;
+	int rc;
+
+	rc = down_interruptible(&efx_mtd->access_lock);
+	if (rc)
+		goto out;
+	spi = efx_mtd->spi;
+
+	rc = efx_spi_unlock(efx_mtd);
+	if (rc)
+		goto out_up;
+
+	while (pos < len) {
+		rc = efx_spi_write_enable(efx_mtd);
+		if (rc)
+			break;
+
+		block_len = min((unsigned int)len - pos,
+				efx_spi_write_limit(spi, start + pos));
+		command = efx_spi_munge_command(spi, SPI_WRITE, start + pos);
+		rc = spi->write(spi, efx_mtd->efx, command, start + pos,
+				buffer + pos, block_len);
+		if (rc)
+			break;
+		pos += block_len;
+
+		rc = efx_spi_fast_wait(efx_mtd);
+		if (rc)
+			break;
+
+		/* Avoid locking up the system */
+		cond_resched();
+		if (signal_pending(current)) {
+			rc = -EINTR;
+			break;
+		}
+	}
+
+out_up:
+	up(&efx_mtd->access_lock);
+	if (rc == 0)
+		rc = efx_mtd_verify(mtd, start, len, buffer, 0);
+out:
+	*retlen = pos;
+	return rc;
+}
+
+static void efx_mtd_sync(struct mtd_info *mtd)
+{
+	struct efx_mtd *efx_mtd = mtd->priv;
+	int rc;
+
+	down(&efx_mtd->access_lock);
+	rc = efx_spi_slow_wait(efx_mtd, 1);
+	if (rc)
+		EFX_ERR(efx_mtd->efx, "%s sync failed (%d)\n",
+			efx_mtd->name, rc);
+	up(&efx_mtd->access_lock);
+}
+
+/* Driverlink interface */
+
+static void efx_mtd_reset_suspend(struct efx_dl_device *efx_dev)
+{
+	struct efx_mtd *efx_mtd = efx_dev->priv;
+
+	if (!efx_mtd)
+		return;
+
+	/* Acquire lock to ensure that any in-progress operations have
+	 * completed, and no new ones can start.
+	 */
+	down(&efx_mtd->access_lock);
+}
+
+static void efx_mtd_reset_resume(struct efx_dl_device *efx_dev, int ok)
+{
+	struct efx_mtd *efx_mtd = efx_dev->priv;
+
+	if (!efx_mtd)
+		return;
+
+	/* If device reset failed already, or SPI device doesn't
+	 * become ready, disable device.
+	 */
+	if (!ok || efx_spi_slow_wait(efx_mtd, 1) != 0) {
+		efx_mtd->spi = &efx_spi_dummy_device;
+		EFX_ERR(efx_mtd->efx, "%s disabled after failed reset\n",
+			efx_mtd->name);
+	}
+
+	up(&efx_mtd->access_lock);
+}
+
+static void efx_mtd_remove(struct efx_dl_device *efx_dev)
+{
+	struct efx_mtd *efx_mtd = efx_dev->priv;
+
+	del_mtd_partitions(&efx_mtd->mtd);
+	kfree(efx_mtd);
+	efx_dev->priv = NULL;
+}
+
+static __devinit int efx_mtd_register(struct efx_mtd *efx_mtd,
+				      struct efx_dl_device *efx_dev,
+				      struct efx_nic *efx,
+				      struct efx_spi_device *spi,
+				      const char *type_name,
+				      const char **part_type_name,
+				      unsigned int num_parts)
+{
+	int i;
+
+	efx_dev->priv = efx_mtd;
+
+	efx_mtd->efx_dev = efx_dev;
+	efx_mtd->efx = efx;
+	efx_mtd->spi = spi;
+	sema_init(&efx_mtd->access_lock, 1);
+
+	efx_mtd->mtd.size = spi->size;
+	efx_mtd->mtd.erasesize = spi->erase_size;
+	efx_mtd->mtd.writesize = 1;
+	if (snprintf(efx_mtd->name, sizeof(efx_mtd->name),
+		     "%s %s", efx->name, type_name) >=
+	    sizeof(efx_mtd->name))
+		return -ENAMETOOLONG;
+
+	efx_mtd->mtd.priv = efx_mtd;
+	efx_mtd->mtd.name = efx_mtd->name;
+	efx_mtd->mtd.erase = efx_mtd_erase;
+	efx_mtd->mtd.read = efx_mtd_read;
+	efx_mtd->mtd.write = efx_mtd_write;
+	efx_mtd->mtd.sync = efx_mtd_sync;
+
+	for (i = 0; i < num_parts; i++) {
+		efx_mtd->part[i].name = efx_mtd->part_name[i];
+		if (snprintf(efx_mtd->part_name[i],
+			     sizeof(efx_mtd->part_name[i]),
+			     "%s %s", efx->name, part_type_name[i]) >=
+		    sizeof(efx_mtd->part_name[i]))
+			return -ENAMETOOLONG;
+
+		if (efx_allow_nvconfig_writes)
+			efx_mtd->part[i].mask_flags &= ~MTD_WRITEABLE;
+	}
+
+	return add_mtd_partitions(&efx_mtd->mtd, efx_mtd->part, num_parts);
+}
+
+static int __devinit
+efx_flash_probe(struct efx_dl_device *efx_dev,
+		const struct net_device *net_dev,
+		const struct efx_dl_device_info *dev_info,
+		const char *silicon_rev)
+{
+	struct efx_nic *efx = efx_dl_get_nic(efx_dev);
+	struct efx_mtd *efx_mtd;
+	const char *part_type_name[2];
+	unsigned int num_parts;
+	int rc;
+
+	if (!efx->spi_flash)
+		return -ENODEV;
+
+	efx_mtd = kzalloc(sizeof(*efx_mtd), GFP_KERNEL);
+	if (!efx_mtd)
+		return -ENOMEM;
+
+	efx_mtd->mtd.type = MTD_NORFLASH;
+	efx_mtd->mtd.flags = MTD_CAP_NORFLASH;
+
+	part_type_name[0] = "sfc_flash_config";
+	efx_mtd->part[0].offset = 0;
+	efx_mtd->part[0].size = min(efx->spi_flash->size,
+				    EFX_FLASH_BOOTROM_OFFSET);
+	efx_mtd->part[0].mask_flags = MTD_WRITEABLE;
+
+	if (efx->spi_flash->size <= EFX_FLASH_BOOTROM_OFFSET) {
+		num_parts = 1;
+	} else {
+		part_type_name[1] = "sfc_flash_bootrom";
+		efx_mtd->part[1].offset = EFX_FLASH_BOOTROM_OFFSET;
+		efx_mtd->part[1].size = (efx->spi_flash->size
+					 - EFX_FLASH_BOOTROM_OFFSET);
+		num_parts = 2;
+	}
+
+	rc = efx_mtd_register(efx_mtd, efx_dev, efx, efx->spi_flash,
+			      "sfc_flash", part_type_name, num_parts);
+	if (rc)
+		kfree(efx_mtd);
+	return rc;
+}
+
+static struct efx_dl_driver efx_flash_driver = {
+	.name		= "sfc_flash",
+	.probe		= efx_flash_probe,
+	.remove		= efx_mtd_remove,
+	.reset_suspend	= efx_mtd_reset_suspend,
+	.reset_resume	= efx_mtd_reset_resume,
+};
+
+static int __devinit
+efx_eeprom_probe(struct efx_dl_device *efx_dev,
+		 const struct net_device *net_dev,
+		 const struct efx_dl_device_info *dev_info,
+		 const char *silicon_rev)
+{
+	struct efx_nic *efx = efx_dl_get_nic(efx_dev);
+	struct efx_mtd *efx_mtd;
+	const char *type_name;
+	const char *part_type_name[1];
+	int rc;
+
+	if (!efx->spi_eeprom)
+		return -ENODEV;
+
+	efx_mtd = kzalloc(sizeof(*efx_mtd), GFP_KERNEL);
+	if (!efx_mtd)
+		return -ENOMEM;
+
+	efx_mtd->mtd.type = MTD_RAM;
+	efx_mtd->mtd.flags = MTD_CAP_RAM;
+
+	efx_mtd->part[0].offset = 0;
+	efx_mtd->part[0].size = efx->spi_eeprom->size;
+	efx_mtd->part[0].mask_flags = MTD_WRITEABLE;
+
+	if (efx->spi_eeprom->size <= 0x200) {
+		type_name = "sfc_small_eeprom";
+		part_type_name[0] = "sfc_small_config";
+	} else {
+		type_name = "sfc_large_eeprom";
+		part_type_name[0] = "sfc_large_config";
+	}
+
+	rc = efx_mtd_register(efx_mtd, efx_dev, efx, efx->spi_eeprom,
+			      type_name, part_type_name, 1);
+	if (rc)
+		kfree(efx_mtd);
+	return rc;
+}
+
+static struct efx_dl_driver efx_eeprom_driver = {
+	.name		= "sfc_eeprom",
+	.probe		= efx_eeprom_probe,
+	.remove		= efx_mtd_remove,
+	.reset_suspend	= efx_mtd_reset_suspend,
+	.reset_resume	= efx_mtd_reset_resume,
+};
+
+/* Kernel module interface */
+
+static int __init efx_mtd_init_module(void)
+{
+	int rc;
+
+	rc = efx_dl_register_driver(&efx_flash_driver);
+	if (rc)
+		return rc;
+	rc = efx_dl_register_driver(&efx_eeprom_driver);
+	if (rc) {
+		efx_dl_unregister_driver(&efx_flash_driver);
+		return rc;
+	}
+
+	return 0;
+}
+
+static void __exit efx_mtd_exit_module(void)
+{
+	efx_dl_unregister_driver(&efx_eeprom_driver);
+	efx_dl_unregister_driver(&efx_flash_driver);
+}
+
+module_init(efx_mtd_init_module);
+module_exit(efx_mtd_exit_module);
+
+MODULE_AUTHOR("Michael Brown <mbrown@fensystems.co.uk> and "
+	      "Solarflare Communications");
+MODULE_DESCRIPTION("SFC MTD driver");
+MODULE_LICENSE("GPL");
Index: head-2008-06-18/drivers/net/sfc/net_driver.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/net_driver.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/net_driver.h	2008-06-18 16:01:03.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2005-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 /* Common definitions for all Efx net driver code */
@@ -29,11 +46,10 @@
 
 #include "enum.h"
 #include "bitfield.h"
+#include "driverlink_api.h"
+#include "driverlink.h"
 #include "i2c-direct.h"
 
-#define EFX_MAX_LRO_DESCRIPTORS 8
-#define EFX_MAX_LRO_AGGR MAX_SKB_FRAGS
-
 /**************************************************************************
  *
  * Build definitions
@@ -42,7 +58,7 @@
 #ifndef EFX_DRIVER_NAME
 #define EFX_DRIVER_NAME	"sfc"
 #endif
-#define EFX_DRIVER_VERSION	"2.2"
+#define EFX_DRIVER_VERSION	"2.2.0134"
 
 #ifdef EFX_ENABLE_DEBUG
 #define EFX_BUG_ON_PARANOID(x) BUG_ON(x)
@@ -81,6 +97,11 @@ do {if (net_ratelimit()) EFX_INFO(efx, f
 #define EFX_LOG_RL(efx, fmt, args...) \
 do {if (net_ratelimit()) EFX_LOG(efx, fmt, ##args); } while (0)
 
+/* Kernel headers may redefine inline anyway */
+#ifndef inline
+#define inline inline __attribute__ ((always_inline))
+#endif
+
 /**************************************************************************
  *
  * Efx data structures
@@ -160,6 +181,7 @@ struct efx_tx_buffer {
  * @channel: The associated channel
  * @buffer: The software buffer ring
  * @txd: The hardware descriptor ring
+ * @debug_dir: debugfs directory
  * @read_count: Current read pointer.
  *	This is the number of buffers that have been removed from both rings.
  * @stopped: Stopped flag.
@@ -193,6 +215,9 @@ struct efx_tx_queue {
 	struct efx_nic *nic;
 	struct efx_tx_buffer *buffer;
 	struct efx_special_buffer txd;
+#ifdef CONFIG_SFC_DEBUGFS
+	struct dentry *debug_dir;
+#endif
 
 	/* Members used mainly on the completion path */
 	unsigned int read_count ____cacheline_aligned_in_smp;
@@ -262,6 +287,7 @@ struct efx_rx_buffer {
  *	the remaining space in the allocation.
  * @buf_dma_addr: Page's DMA address.
  * @buf_data: Page's host address.
+ * @debug_dir: debugfs directory
  */
 struct efx_rx_queue {
 	struct efx_nic *efx;
@@ -288,6 +314,10 @@ struct efx_rx_queue {
 	struct page *buf_page;
 	dma_addr_t buf_dma_addr;
 	char *buf_data;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	struct dentry *debug_dir;
+#endif
 };
 
 /**
@@ -306,6 +336,81 @@ struct efx_buffer {
 };
 
 
+/**
+ * struct efx_ssr_conn - Connection state for Soft Segment Reassembly (SSR) aka LRO
+ * @link: Link for hash table and free list.
+ * @active_link: Link for active_conns list
+ * @saddr: Source IP address
+ * @daddr: Destination IP address
+ * @source: Source TCP port number
+ * @dest: Destination TCP port number
+ * @n_in_order_pkts: Number of in-order packets we've seen with payload.
+ * @next_seq: Next in-order sequence number.
+ * @last_pkt_jiffies: Time we last saw a packet on this connection.
+ * @skb: The SKB we are currently holding.
+ *	If %NULL, then all following fields are undefined.
+ * @skb_tail: The tail of the frag_list of SKBs we're holding.
+ *	Only valid after at least one merge.
+ * @eh: The ethernet header of the skb we are holding.
+ * @iph: The IP header of the skb we are holding.
+ * @th: The TCP header of the skb we are holding.
+ * @th_last: The TCP header of the last packet merged.
+ */
+struct efx_ssr_conn {
+	struct list_head link;
+	struct list_head active_link;
+	unsigned saddr, daddr;
+	unsigned short source, dest;
+	unsigned n_in_order_pkts;
+	unsigned next_seq;
+	unsigned long last_pkt_jiffies;
+	struct sk_buff *skb;
+	struct sk_buff *skb_tail;
+	struct ethhdr *eh;
+	struct iphdr *iph;
+	struct tcphdr *th;
+	struct tcphdr *th_last;
+};
+
+/**
+ * struct efx_ssr_state - Port state for Soft Segment Reassembly (SSR) aka LRO
+ * @efx: The associated NIC.
+ * @conns_mask: Number of hash buckets - 1.
+ * @conns: Hash buckets for tracked connections.
+ * @conns_n: Length of linked list for each hash bucket.
+ * @active_conns: Connections that are holding a packet.
+ *	Connections are self-linked when not in this list.
+ * @free_conns: Free efx_ssr_conn instances.
+ * @last_purge_jiffies: The value of jiffies last time we purged idle
+ *	connections.
+ * @n_merges: Number of packets absorbed by SSR.
+ * @n_bursts: Number of bursts spotted by SSR.
+ * @n_slow_start: Number of packets not merged because connection may be in
+ *	slow-start.
+ * @n_misorder: Number of out-of-order packets seen in tracked streams.
+ * @n_too_many: Incremented when we're trying to track too many streams.
+ * @n_new_stream: Number of distinct streams we've tracked.
+ * @n_drop_idle: Number of streams discarded because they went idle.
+ * @n_drop_closed: Number of streams that have seen a FIN or RST.
+ */
+struct efx_ssr_state {
+	struct efx_nic *efx;
+	unsigned conns_mask;
+	struct list_head *conns;
+	unsigned *conns_n;
+	struct list_head active_conns;
+	struct list_head free_conns;
+	unsigned long last_purge_jiffies;
+	unsigned n_merges;
+	unsigned n_bursts;
+	unsigned n_slow_start;
+	unsigned n_misorder;
+	unsigned n_too_many;
+	unsigned n_new_stream;
+	unsigned n_drop_idle;
+	unsigned n_drop_closed;
+};
+
 /* Flags for channel->used_flags */
 #define EFX_USED_BY_RX 1
 #define EFX_USED_BY_TX 2
@@ -340,6 +445,7 @@ enum efx_rx_alloc_method {
  * @eventq_read_ptr: Event queue read pointer
  * @last_eventq_read_ptr: Last event queue read pointer value.
  * @eventq_magic: Event queue magic value for driver-generated test events
+ * @debug_dir: debugfs directory
  * @lro_mgr: LRO state
  * @rx_alloc_level: Watermark based heuristic counter for pushing descriptors
  *	and diagnostic counters
@@ -373,7 +479,11 @@ struct efx_channel {
 	unsigned int last_eventq_read_ptr;
 	unsigned int eventq_magic;
 
-	struct net_lro_mgr lro_mgr;
+#ifdef CONFIG_SFC_DEBUGFS
+	struct dentry *debug_dir;
+#endif
+
+	struct efx_ssr_state ssr;
 	int rx_alloc_level;
 	int rx_alloc_push_pages;
 	int rx_alloc_pop_pages;
@@ -418,7 +528,13 @@ struct efx_blinker {
  * @init_leds: Sets up board LEDs
  * @set_fault_led: Turns the fault LED on or off
  * @blink: Starts/stops blinking
+ * @monitor: Board-specific health check function
+ * @fini: Cleanup function
+ * @interpret_sensor: Function to interpret LM87 sensor meanings.
+ *	Returns %FALSE if no board-specific meaning.
+ * @mwatts: Power requirements (mW)
  * @blinker: used to blink LEDs in software
+ * @lm87_addr: I2C address of LM87 monitoring chip (0 if absent)
  */
 struct efx_board {
 	int type;
@@ -429,13 +545,43 @@ struct efx_board {
 	 * have a separate init callback that happens later than
 	 * board init. */
 	int (*init_leds)(struct efx_nic *efx);
+	int (*monitor) (struct efx_nic *nic);
 	void (*set_fault_led) (struct efx_nic *efx, int state);
 	void (*blink) (struct efx_nic *efx, int start);
+	void (*fini) (struct efx_nic *nic);
+	int (*interpret_sensor) (struct efx_nic *nic, int num, unsigned val);
+	unsigned mwatts;
 	struct efx_blinker blinker;
+	unsigned int lm87_addr;
 };
 
-#define STRING_TABLE_LOOKUP(val, member)	\
-	member ## _names[val]
+#define STRING_TABLE_LOOKUP(val, member) \
+	((val) < member ## _max) ? member ## _names[val] : "(invalid)"
+
+extern const char *efx_loopback_mode_names[];
+extern const unsigned int efx_loopback_mode_max;
+#define LOOPBACK_MODE(efx) \
+	STRING_TABLE_LOOKUP((efx)->loopback_mode, efx_loopback_mode)
+
+extern const char *efx_interrupt_mode_names[];
+extern const unsigned int efx_interrupt_mode_max;
+#define INT_MODE(efx) \
+	STRING_TABLE_LOOKUP(efx->interrupt_mode, efx_interrupt_mode)
+
+extern const char *efx_reset_type_names[];
+extern const unsigned int efx_reset_type_max;
+#define RESET_TYPE(type) \
+	STRING_TABLE_LOOKUP(type, efx_reset_type)
+
+extern const char *efx_phy_type_names[];
+extern const unsigned int efx_phy_type_max;
+#define PHY_TYPE(efx) \
+	STRING_TABLE_LOOKUP((efx)->phy_type, efx_phy_type)
+
+extern const char *efx_nic_state_names[];
+extern const unsigned int efx_nic_state_max;
+#define STATE_NAME(efx)	\
+	STRING_TABLE_LOOKUP((efx)->state, efx_nic_state)
 
 enum efx_int_mode {
 	/* Be careful if altering to correct macro below */
@@ -458,6 +604,9 @@ enum phy_type {
 
 #define PHY_ADDR_INVALID 0xff
 
+#define EFX_IS10G(efx) ((efx)->is_10g)
+#define EFX_ISCLAUSE45(efx) ((efx)->phy_type != PHY_TYPE_1G_ALASKA)
+
 enum nic_state {
 	STATE_INIT = 0,
 	STATE_RUNNING = 1,
@@ -500,6 +649,40 @@ enum efx_fc_type {
 };
 
 /**
+ * struct efx_mac_operations - Efx MAC operations table
+ * @mac_writel: Write dword to MAC register
+ * @mac_readl: Read dword from a MAC register
+ * @init: Initialise MAC and PHY
+ * @reconfigure: Reconfigure MAC and PHY. Serialised by the mac_lock
+ * @update_stats: Update statistics
+ * @fini: Shut down MAC and PHY
+ * @check_hw: Check hardware. Serialised by the mac_lock
+ * @fake_phy_event: Simulate a PHY event on a port
+ * @get_settings: Get ethtool settings. Serialised by the mac_lock
+ * @set_settings: Set ethtool settings. Serialised by the mac_lock
+ * @set_pause: Set pause parameters. Serialised by the mac_lock
+ */
+struct efx_mac_operations {
+	void (*mac_writel) (struct efx_nic *efx,
+			    efx_dword_t *value, unsigned int mac_reg);
+	void (*mac_readl) (struct efx_nic *efx,
+			   efx_dword_t *value, unsigned int mac_reg);
+	int (*init) (struct efx_nic *efx);
+	void (*reconfigure) (struct efx_nic *efx);
+	void (*update_stats) (struct efx_nic *efx);
+	void (*fini) (struct efx_nic *efx);
+	int (*check_hw) (struct efx_nic *efx);
+	void (*fake_phy_event) (struct efx_nic *efx);
+
+	int (*get_settings) (struct efx_nic *efx,
+			     struct ethtool_cmd *ecmd);
+	int (*set_settings) (struct efx_nic *efx,
+			     struct ethtool_cmd *ecmd);
+	int (*set_pause) (struct efx_nic *efx,
+			  enum efx_fc_type pause_params);
+};
+
+/**
  * struct efx_phy_operations - Efx PHY operations table
  * @init: Initialise PHY
  * @fini: Shut down PHY
@@ -510,6 +693,7 @@ enum efx_fc_type {
  * @reset_xaui: Reset XAUI side of PHY for (software sequenced reset)
  * @mmds: MMD presence mask
  * @loopbacks: Supported loopback modes mask
+ * @startup_loopback: Loopback mode for start-of-day self-test
  */
 struct efx_phy_operations {
 	int (*init) (struct efx_nic *efx);
@@ -520,6 +704,7 @@ struct efx_phy_operations {
 	void (*reset_xaui) (struct efx_nic *efx);
 	int mmds;
 	unsigned loopbacks;
+	unsigned startup_loopback;
 };
 
 /*
@@ -605,6 +790,19 @@ union efx_multicast_hash {
 	efx_oword_t oword[EFX_MCAST_HASH_ENTRIES / sizeof(efx_oword_t) / 8];
 };
 
+/* Efx Error condition statistics */
+struct efx_nic_errors {
+	atomic_t missing_event;
+	atomic_t rx_reset;
+	atomic_t rx_desc_fetch;
+	atomic_t tx_desc_fetch;
+	atomic_t spurious_tx;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	struct dentry *debug_dir;
+#endif
+};
+
 /**
  * struct efx_nic - an Efx NIC
  * @name: Device name (net device name or bus id before net device registered)
@@ -618,6 +816,8 @@ union efx_multicast_hash {
  * @membase: Memory BAR value
  * @biu_lock: BIU (bus interface unit) lock
  * @interrupt_mode: Interrupt mode
+ * @is_asic: Is ASIC (else FPGA)
+ * @is_10g: Is set to 10G (else 1G)
  * @i2c: I2C interface
  * @board_info: Board-level information
  * @state: Device state flag. Serialised by the rtnl_lock.
@@ -628,11 +828,17 @@ union efx_multicast_hash {
  * @rss_queues: Number of RSS queues
  * @rx_buffer_len: RX buffer length
  * @rx_buffer_order: Order (log2) of number of pages for each RX buffer
+ * @errors: Error condition stats
  * @irq_status: Interrupt status buffer
  * @last_irq_cpu: Last CPU to handle interrupt.
  *	This register is written with the SMP processor ID whenever an
  *	interrupt is handled.  It is used by falcon_test_interrupt()
  *	to verify that an interrupt has occurred.
+ * @spi_flash: SPI flash device
+ *	This field will be %NULL if no flash device is present.
+ * @spi_eeprom: SPI EEPROM device
+ *	This field will be %NULL if no EEPROM device is present.
+ * @spi_lock: SPI bus lock
  * @n_rx_nodesc_drop_cnt: RX no descriptor drop count
  * @nic_data: Hardware dependant state
  * @mac_lock: MAC access lock. Protects @port_enabled, efx_monitor() and
@@ -652,12 +858,14 @@ union efx_multicast_hash {
  *	&struct net_device_stats.
  * @stats_buffer: DMA buffer for statistics
  * @stats_lock: Statistics update lock
+ * @mac_op: MAC interface
  * @mac_address: Permanent MAC address
  * @phy_type: PHY type
  * @phy_lock: PHY access lock
  * @phy_op: PHY interface
  * @phy_data: PHY private data (including PHY-specific stats)
  * @mii: PHY interface
+ * @phy_powered: PHY power state
  * @tx_disabled: PHY transmitter turned off
  * @link_up: Link status
  * @link_options: Link options (MII/GMII format)
@@ -669,6 +877,16 @@ union efx_multicast_hash {
  * @loopback_mode: Loopback status
  * @loopback_modes: Supported loopback mode bitmask
  * @loopback_selftest: Offline self-test private state
+ * @silicon_rev: Silicon revision description for driverlink
+ * @dl_info: Linked list of hardware parameters exposed through driverlink
+ * @dl_node: Driverlink port list
+ * @dl_device_list: Driverlink device list
+ * @dl_cb: Driverlink callbacks table
+ * @dl_cb_dev: Driverlink callback owner devices
+ * @debug_dir: NIC debugfs directory
+ * @debug_symlink: NIC debugfs sym-link (nic_eth\%d)
+ * @debug_port_dir: Port debugfs directory
+ * @debug_port_symlink: Port debugfs sym-link (if_eth\%d)
  *
  * The @priv field of the corresponding &struct net_device points to
  * this.
@@ -685,6 +903,8 @@ struct efx_nic {
 	void __iomem *membase;
 	spinlock_t biu_lock;
 	enum efx_int_mode interrupt_mode;
+	unsigned int is_asic:1;
+	unsigned int is_10g:1;
 
 	struct efx_i2c_interface i2c;
 	struct efx_board board_info;
@@ -700,12 +920,18 @@ struct efx_nic {
 	unsigned int rx_buffer_len;
 	unsigned int rx_buffer_order;
 
+	struct efx_nic_errors errors;
+
 	struct efx_buffer irq_status;
 	volatile signed int last_irq_cpu;
 
+	struct efx_spi_device *spi_flash;
+	struct efx_spi_device *spi_eeprom;
+	struct mutex spi_lock;
+
 	unsigned n_rx_nodesc_drop_cnt;
 
-	struct falcon_nic_data *nic_data;
+	void *nic_data;
 
 	struct mutex mac_lock;
 	int port_enabled;
@@ -721,6 +947,7 @@ struct efx_nic {
 	struct efx_buffer stats_buffer;
 	spinlock_t stats_lock;
 
+	struct efx_mac_operations *mac_op;
 	unsigned char mac_address[ETH_ALEN];
 
 	enum phy_type phy_type;
@@ -728,6 +955,7 @@ struct efx_nic {
 	struct efx_phy_operations *phy_op;
 	void *phy_data;
 	struct mii_if_info mii;
+	unsigned phy_powered;
 	unsigned tx_disabled;
 
 	int link_up;
@@ -739,16 +967,30 @@ struct efx_nic {
 	enum efx_fc_type flow_control;
 	struct work_struct reconfigure_work;
 
-	atomic_t rx_reset;
 	enum efx_loopback_mode loopback_mode;
 	unsigned int loopback_modes;
+	unsigned int startup_loopbacks;
 
 	void *loopback_selftest;
+
+	const char *silicon_rev;
+	struct efx_dl_device_info *dl_info;
+	struct list_head dl_node;
+	struct list_head dl_device_list;
+	struct efx_dl_callbacks dl_cb;
+	struct efx_dl_cb_devices dl_cb_dev;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	struct dentry *debug_dir;
+	struct dentry *debug_symlink;
+	struct dentry *debug_port_dir;
+	struct dentry *debug_port_symlink;
+#endif
 };
 
 static inline int efx_dev_registered(struct efx_nic *efx)
 {
-	return efx->net_dev->reg_state == NETREG_REGISTERED;
+	return efx->net_dev && efx->net_dev->reg_state == NETREG_REGISTERED;
 }
 
 /* Net device name, for inclusion in log messages if it has been registered.
@@ -795,7 +1037,7 @@ struct efx_nic_type {
 	unsigned int txd_ring_mask;
 	unsigned int rxd_ring_mask;
 	unsigned int evq_size;
-	u64 max_dma_mask;
+	dma_addr_t max_dma_mask;
 	unsigned int tx_dma_mask;
 	unsigned bug5391_mask;
 
@@ -868,6 +1110,11 @@ struct efx_nic_type {
 			continue;					\
 		else
 
+/* Name formats */
+#define EFX_CHANNEL_NAME(_channel) "channel%d", _channel->channel
+#define EFX_TX_QUEUE_NAME(_tx_queue) "txq%d", _tx_queue->queue
+#define EFX_RX_QUEUE_NAME(_rx_queue) "rxq%d", _rx_queue->queue
+
 /* Returns a pointer to the specified receive buffer in the RX
  * descriptor queue.
  */
Index: head-2008-06-18/drivers/net/sfc/null_phy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/null_phy.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,60 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#include "efx.h"
+#include "falcon.h"
+#include "gmii.h"
+#include "phy.h"
+
+static int falcon_null_phy_check_hw(struct efx_nic *efx)
+{
+	int link_ok = falcon_xaui_link_ok(efx);
+
+	/* Generate PHY event that a PHY would have generated */
+	if (link_ok != efx->link_up)
+		efx->mac_op->fake_phy_event(efx);
+
+	return 0;
+}
+
+static void falcon_null_phy_reconfigure(struct efx_nic *efx)
+{
+	/* CX4 is always 10000FD only */
+	efx->link_options = GM_LPA_10000FULL;
+
+	efx->link_up = falcon_xaui_link_ok(efx);
+}
+
+struct efx_phy_operations falcon_null_phy_ops = {
+	.reconfigure     = falcon_null_phy_reconfigure,
+	.check_hw        = falcon_null_phy_check_hw,
+	.fini            = efx_port_dummy_op_void,
+	.clear_interrupt = efx_port_dummy_op_void,
+	.init            = efx_port_dummy_op_int,
+	.reset_xaui      = efx_port_dummy_op_void,
+	.mmds            = 0,
+	.loopbacks       = 0,
+	.startup_loopback = 0,
+};
Index: head-2008-06-18/drivers/net/sfc/phy.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/phy.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/phy.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,10 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_PHY_H
@@ -27,6 +43,27 @@ extern void tenxpress_phy_blink(struct e
 extern void tenxpress_crc_err(struct efx_nic *efx);
 
 /****************************************************************************
+ * Marvell 88E1111 "Alaska" PHY control
+ */
+extern struct efx_phy_operations alaska_phy_operations;
+
+/****************************************************************************
+* Exported functions from the driver for Transwitch CX4 retimer
+*/
+extern struct efx_phy_operations falcon_txc_phy_ops;
+
+#define TXC_GPIO_DIR_INPUT  (0)
+#define TXC_GPIO_DIR_OUTPUT (1)
+
+extern void txc_set_gpio_dir(struct efx_nic *p, int pin, int dir);
+extern void txc_set_gpio_val(struct efx_nic *p, int pin, int val);
+
+/****************************************************************************
+ * Exported functions from the driver for PMC PM8358 PHY
+ */
+extern struct efx_phy_operations falcon_pm8358_phy_ops;
+
+/****************************************************************************
  * Exported functions from the driver for XFP optical PHYs
  */
 extern struct efx_phy_operations falcon_xfp_phy_ops;
@@ -45,4 +82,9 @@ extern struct efx_phy_operations falcon_
 
 extern void xfp_set_led(struct efx_nic *p, int led, int state);
 
+/****************************************************************************
+ * NULL PHY ops
+ */
+extern struct efx_phy_operations falcon_null_phy_ops;
+
 #endif
Index: head-2008-06-18/drivers/net/sfc/pm8358_phy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/pm8358_phy.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,204 @@
+/* Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+/*
+ *  Driver for PMC-Sierra PM8358 XAUI PHY
+ */
+
+#include <linux/delay.h>
+#include "efx.h"
+#include "gmii.h"
+#include "mdio_10g.h"
+#include "phy.h"
+
+#define PM8358_REQUIRED_DEVS (MDIO_MMDREG_DEVS0_DTEXS)
+#define PM8358_LOOPBACKS (1 << LOOPBACK_PHY)
+
+/* PHY-specific definitions */
+/* Master ID and Global Performance Monitor Update */
+#define PMC_MASTER_REG (0xd000)
+/* Analog TX/RX settings under software control */
+#define PMC_MASTER_ANLG_CTRL (1 << 11)
+
+#define PMC_MCONF2_REG	(0xd002)
+/* Drive TX off centre of data eye (1) vs. clock edge (0) */
+#define	PMC_MCONF2_TEDGE (1 << 2)
+/* Drive RX off centre of data eye (1) vs. clock edge (0) */
+#define PMC_MCONF2_REDGE (1 << 3)
+
+/* Analog RX settings */
+#define PMC_ANALOG_RX_CFG0   (0xd025)
+#define PMC_ANALOG_RX_CFG1   (0xd02d)
+#define PMC_ANALOG_RX_CFG2   (0xd035)
+#define PMC_ANALOG_RX_CFG3   (0xd03d)
+#define PMC_ANALOG_RX_TERM     (1 << 15) /* Bit 15 of RX CFG: 0 for 100 ohms
+					    float, 1 for 50 to 1.2V */
+#define PMC_ANALOG_RX_EQ_MASK (3 << 8)
+#define PMC_ANALOG_RX_EQ_NONE (0 << 8)
+#define PMC_ANALOG_RX_EQ_HALF (1 << 8)
+#define PMC_ANALOG_RX_EQ_FULL (2 << 8)
+#define PMC_ANALOG_RX_EQ_RSVD (3 << 8)
+
+/* Reset the DTE XS MMD. */
+#define PMC_MAX_RESET_TIME 500
+#define PMC_RESET_WAIT 10
+
+static int pmc_reset_phy(struct efx_nic *efx)
+{
+	int rc = mdio_clause45_reset_mmd(efx, MDIO_MMD_DTEXS,
+					 PMC_MAX_RESET_TIME / PMC_RESET_WAIT,
+					 PMC_RESET_WAIT);
+	if (rc >= 0) {
+		EFX_TRACE(efx, "PMC8358: came out of reset with "
+			  "%d0 ms left\n", rc);
+		rc = 0;
+	} else {
+		EFX_ERR(efx, "PMC8358: reset timed out!\n");
+	}
+	return rc;
+}
+
+
+static void pmc_full_rx_eq(struct efx_nic *efx)
+{
+	int i, reg;
+
+	/* Enable software control of analog settings */
+	reg = mdio_clause45_read(efx, efx->mii.phy_id,
+				 MDIO_MMD_DTEXS, PMC_MASTER_REG);
+	reg |= PMC_MASTER_ANLG_CTRL;
+
+	mdio_clause45_write(efx, efx->mii.phy_id,
+			    MDIO_MMD_DTEXS, PMC_MASTER_REG, reg);
+
+	/* Turn RX eq on full for all channels. */
+	for (i = 0; i < 3; i++) {
+		/* The analog CFG registers are evenly spaced 8 apart */
+		u16 addr = PMC_ANALOG_RX_CFG0 + 8 * i;
+
+		reg = mdio_clause45_read(efx, efx->mii.phy_id,
+					 MDIO_MMD_DTEXS, addr);
+		reg = (reg & ~PMC_ANALOG_RX_EQ_MASK) | PMC_ANALOG_RX_EQ_FULL;
+		mdio_clause45_write(efx, efx->mii.phy_id,
+				    MDIO_MMD_DTEXS, addr, reg);
+	}
+}
+
+static void pmc_set_data_edges(struct efx_nic *efx)
+{
+	int reg;
+	/* Set TEDGE, clear REDGE */
+	reg = mdio_clause45_read(efx, efx->mii.phy_id,
+				 MDIO_MMD_DTEXS, PMC_MCONF2_REG);
+	reg &= ~PMC_MCONF2_REDGE;
+	reg |= PMC_MCONF2_TEDGE;
+
+	mdio_clause45_write(efx, efx->mii.phy_id,
+			    MDIO_MMD_DTEXS, PMC_MCONF2_REG, reg);
+}
+
+static int pm8358_phy_init(struct efx_nic *efx)
+{
+	u32 devid;
+	int rc;
+
+	/* The GLB_CTL reset line has been pulled before this is called,
+	 * and it may take up to 5ms for the PLL's to synchronise after
+	 * this is done. Best to wait 10ms here */
+	schedule_timeout_uninterruptible(HZ / 100);
+
+	rc = pmc_reset_phy(efx);
+	if (rc < 0)
+		return rc;
+
+	/* Check that all the MMDs we expect are present and responding. We
+	 * expect faults on some if the link is down, but not on the PHY XS */
+	rc = mdio_clause45_check_mmds(efx, PM8358_REQUIRED_DEVS, 0);
+	if (rc < 0)
+		return rc;
+
+	devid = mdio_clause45_read_id(efx, MDIO_MMD_DTEXS);
+	EFX_LOG(efx, "PM8358: PHY ID reg %x (OUI %x model %x revision"
+		" %x)\n", devid, MDIO_ID_OUI(devid), MDIO_ID_MODEL(devid),
+		MDIO_ID_REV(devid));
+
+	/* Turn on full RX equalisation */
+	pmc_full_rx_eq(efx);
+
+	/* Adjust RX and TX data edge position */
+	pmc_set_data_edges(efx);
+
+	EFX_LOG(efx, "PM8358: PHY init successful.\n");
+	return rc;
+}
+
+static int pm8358_link_ok(struct efx_nic *efx)
+{
+	return mdio_clause45_links_ok(efx, PM8358_REQUIRED_DEVS);
+}
+
+static int pm8358_phy_check_hw(struct efx_nic *efx)
+{
+	int rc = 0;
+	int link_up = pm8358_link_ok(efx);
+	/* Simulate a PHY event if link state has changed */
+	if (link_up != efx->link_up)
+		efx->mac_op->fake_phy_event(efx);
+
+	return rc;
+}
+
+static void pm8358_phy_reconfigure(struct efx_nic *efx)
+{
+	int phy_id = efx->mii.phy_id;
+	int ctrl;
+	/* Handle DTE loopback */
+	ctrl = mdio_clause45_read(efx, phy_id, MDIO_MMD_DTEXS,
+				  MDIO_MMDREG_CTRL1);
+	if (efx->loopback_mode == LOOPBACK_PHY) {
+		EFX_TRACE(efx, "PM8358: setting DTE loopback\n");
+		ctrl |= (1 << MDIO_MMDREG_CTRL1_LBACK_LBN);
+	} else {
+		if (ctrl & (1 << MDIO_MMDREG_CTRL1_LBACK_LBN))
+			EFX_TRACE(efx,
+				  "PM8358: clearing DTE loopback\n");
+		ctrl &= ~(1 << MDIO_MMDREG_CTRL1_LBACK_LBN);
+	}
+	mdio_clause45_write(efx, phy_id, MDIO_MMD_DTEXS,
+			    MDIO_MMDREG_CTRL1, ctrl);
+
+	efx->link_up = pm8358_link_ok(efx);
+	efx->link_options = GM_LPA_10000FULL;
+}
+
+struct efx_phy_operations falcon_pm8358_phy_ops = {
+	.init            = pm8358_phy_init,
+	.reconfigure     = pm8358_phy_reconfigure,
+	.check_hw        = pm8358_phy_check_hw,
+	.fini            = efx_port_dummy_op_void,
+	.clear_interrupt = efx_port_dummy_op_void,
+	.reset_xaui      = efx_port_dummy_op_void,
+	.mmds            = PM8358_REQUIRED_DEVS,
+	.loopbacks       = PM8358_LOOPBACKS,
+	.startup_loopback = LOOPBACK_PHY,
+};
Index: head-2008-06-18/drivers/net/sfc/rx.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/rx.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/rx.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2005-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #include <linux/socket.h>
@@ -22,6 +39,7 @@
 #include "selftest.h"
 #include "workarounds.h"
 
+
 /* Number of RX descriptors pushed at once. */
 #define EFX_RX_BATCH  8
 
@@ -86,121 +104,15 @@ static unsigned int rx_refill_limit = 95
  */
 #define EFX_RXD_HEAD_ROOM 2
 
-static inline unsigned int efx_rx_buf_offset(struct efx_rx_buffer *buf)
-{
-	/* Offset is always within one page, so we don't need to consider
-	 * the page order.
-	 */
-	return (__force unsigned long) buf->data & (PAGE_SIZE - 1);
-}
-static inline unsigned int efx_rx_buf_size(struct efx_nic *efx)
-{
-	return PAGE_SIZE << efx->rx_buffer_order;
-}
-
-
-/**************************************************************************
- *
- * Linux generic LRO handling
- *
- **************************************************************************
- */
-
-static int efx_lro_get_skb_hdr(struct sk_buff *skb, void **ip_hdr,
-			       void **tcpudp_hdr, u64 *hdr_flags, void *priv)
-{
-	struct efx_channel *channel = priv;
-	struct iphdr *iph;
-	struct tcphdr *th;
-
-	iph = (struct iphdr *)skb->data;
-	if (skb->protocol != htons(ETH_P_IP) || iph->protocol != IPPROTO_TCP)
-		goto fail;
-
-	th = (struct tcphdr *)(skb->data + iph->ihl * 4);
-
-	*tcpudp_hdr = th;
-	*ip_hdr = iph;
-	*hdr_flags = LRO_IPV4 | LRO_TCP;
-
-	channel->rx_alloc_level += RX_ALLOC_FACTOR_LRO;
-	return 0;
-fail:
-	channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
-	return -1;
-}
-
-static int efx_get_frag_hdr(struct skb_frag_struct *frag, void **mac_hdr,
-			    void **ip_hdr, void **tcpudp_hdr, u64 *hdr_flags,
-			    void *priv)
-{
-	struct efx_channel *channel = priv;
-	struct ethhdr *eh;
-	struct iphdr *iph;
-
-	/* We support EtherII and VLAN encapsulated IPv4 */
-	eh = page_address(frag->page) + frag->page_offset;
-	*mac_hdr = eh;
-
-	if (eh->h_proto == htons(ETH_P_IP)) {
-		iph = (struct iphdr *)(eh + 1);
-	} else {
-		struct vlan_ethhdr *veh = (struct vlan_ethhdr *)eh;
-		if (veh->h_vlan_encapsulated_proto != htons(ETH_P_IP))
-			goto fail;
-
-		iph = (struct iphdr *)(veh + 1);
-	}
-	*ip_hdr = iph;
-
-	/* We can only do LRO over TCP */
-	if (iph->protocol != IPPROTO_TCP)
-		goto fail;
-
-	*hdr_flags = LRO_IPV4 | LRO_TCP;
-	*tcpudp_hdr = (struct tcphdr *)((u8 *) iph + iph->ihl * 4);
-
-	channel->rx_alloc_level += RX_ALLOC_FACTOR_LRO;
-	return 0;
- fail:
-	channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
-	return -1;
-}
-
-int efx_lro_init(struct net_lro_mgr *lro_mgr, struct efx_nic *efx)
-{
-	size_t s = sizeof(struct net_lro_desc) * EFX_MAX_LRO_DESCRIPTORS;
-	struct net_lro_desc *lro_arr;
-
-	/* Allocate the LRO descriptors structure */
-	lro_arr = kzalloc(s, GFP_KERNEL);
-	if (lro_arr == NULL)
-		return -ENOMEM;
+/* Macros for zero-order pages (potentially) containing multiple RX buffers */
+#define RX_DATA_OFFSET(_data)				\
+	(((unsigned long) (_data)) & (PAGE_SIZE-1))
+#define RX_BUF_OFFSET(_rx_buf)				\
+	RX_DATA_OFFSET((_rx_buf)->data)
 
-	lro_mgr->lro_arr = lro_arr;
-	lro_mgr->max_desc = EFX_MAX_LRO_DESCRIPTORS;
-	lro_mgr->max_aggr = EFX_MAX_LRO_AGGR;
-	lro_mgr->frag_align_pad = EFX_PAGE_SKB_ALIGN;
+#define RX_PAGE_SIZE(_efx)				\
+	(PAGE_SIZE * (1u << (_efx)->rx_buffer_order))
 
-	lro_mgr->get_skb_header = efx_lro_get_skb_hdr;
-	lro_mgr->get_frag_header = efx_get_frag_hdr;
-	lro_mgr->dev = efx->net_dev;
-
-	lro_mgr->features = LRO_F_NAPI;
-
-	/* We can pass packets up with the checksum intact */
-	lro_mgr->ip_summed = CHECKSUM_UNNECESSARY;
-
-	lro_mgr->ip_summed_aggr = CHECKSUM_UNNECESSARY;
-
-	return 0;
-}
-
-void efx_lro_fini(struct net_lro_mgr *lro_mgr)
-{
-	kfree(lro_mgr->lro_arr);
-	lro_mgr->lro_arr = NULL;
-}
 
 /**
  * efx_init_rx_buffer_skb - create new RX buffer using skb-based allocation
@@ -227,13 +139,16 @@ static inline int efx_init_rx_buffer_skb
 	skb_reserve(rx_buf->skb, NET_IP_ALIGN);
 	rx_buf->len = skb_len - NET_IP_ALIGN;
 	rx_buf->data = (char *)rx_buf->skb->data;
+
 	rx_buf->skb->ip_summed = CHECKSUM_UNNECESSARY;
 
+	/* Map for DMA */
 	rx_buf->dma_addr = pci_map_single(efx->pci_dev,
 					  rx_buf->data, rx_buf->len,
 					  PCI_DMA_FROMDEVICE);
 
 	if (unlikely(pci_dma_mapping_error(rx_buf->dma_addr))) {
+		/* Free the SKB */
 		dev_kfree_skb_any(rx_buf->skb);
 		rx_buf->skb = NULL;
 		return -EIO;
@@ -271,8 +186,9 @@ static inline int efx_init_rx_buffer_pag
 		if (unlikely(rx_buf->page == NULL))
 			return -ENOMEM;
 
+		/* Map the entire page for DMA */
 		dma_addr = pci_map_page(efx->pci_dev, rx_buf->page,
-					0, efx_rx_buf_size(efx),
+					0, RX_PAGE_SIZE(efx),
 					PCI_DMA_FROMDEVICE);
 
 		if (unlikely(pci_dma_mapping_error(dma_addr))) {
@@ -283,14 +199,14 @@ static inline int efx_init_rx_buffer_pag
 
 		rx_queue->buf_page = rx_buf->page;
 		rx_queue->buf_dma_addr = dma_addr;
-		rx_queue->buf_data = (page_address(rx_buf->page) +
+		rx_queue->buf_data = ((char *) page_address(rx_buf->page) +
 				      EFX_PAGE_IP_ALIGN);
 	}
 
+	offset = RX_DATA_OFFSET(rx_queue->buf_data);
 	rx_buf->len = bytes;
-	rx_buf->data = rx_queue->buf_data;
-	offset = efx_rx_buf_offset(rx_buf);
 	rx_buf->dma_addr = rx_queue->buf_dma_addr + offset;
+	rx_buf->data = rx_queue->buf_data;
 
 	/* Try to pack multiple buffers per page */
 	if (efx->rx_buffer_order == 0) {
@@ -298,7 +214,7 @@ static inline int efx_init_rx_buffer_pag
 		rx_queue->buf_data += ((bytes + 0x1ff) & ~0x1ff);
 		offset += ((bytes + 0x1ff) & ~0x1ff);
 
-		space = efx_rx_buf_size(efx) - offset;
+		space = RX_PAGE_SIZE(efx) - offset;
 		if (space >= bytes) {
 			/* Refs dropped on kernel releasing each skb */
 			get_page(rx_queue->buf_page);
@@ -347,8 +263,7 @@ static inline void efx_unmap_rx_buffer(s
 		EFX_BUG_ON_PARANOID(rx_buf->skb);
 		if (rx_buf->unmap_addr) {
 			pci_unmap_page(efx->pci_dev, rx_buf->unmap_addr,
-				       efx_rx_buf_size(efx),
-				       PCI_DMA_FROMDEVICE);
+				       RX_PAGE_SIZE(efx), PCI_DMA_FROMDEVICE);
 			rx_buf->unmap_addr = 0;
 		}
 	} else if (likely(rx_buf->skb)) {
@@ -372,7 +287,10 @@ static inline void efx_free_rx_buffer(st
 static inline void efx_fini_rx_buffer(struct efx_rx_queue *rx_queue,
 				      struct efx_rx_buffer *rx_buf)
 {
+	/* Unmap for DMA */
 	efx_unmap_rx_buffer(rx_queue->efx, rx_buf);
+
+	/* Free the skb/page */
 	efx_free_rx_buffer(rx_queue->efx, rx_buf);
 }
 
@@ -404,10 +322,9 @@ static int __efx_fast_push_rx_descriptor
 		return 0;
 
 	/* Record minimum fill level */
-	if (unlikely(fill_level < rx_queue->min_fill)) {
+	if (unlikely(fill_level < rx_queue->min_fill))
 		if (fill_level)
 			rx_queue->min_fill = fill_level;
-	}
 
 	/* Acquire RX add lock.  If this lock is contended, then a fast
 	 * fill must already be in progress (e.g. in the refill
@@ -458,6 +375,7 @@ static int __efx_fast_push_rx_descriptor
 		goto retry;
 
  out_unlock:
+	/* Release RX add lock */
 	spin_unlock_bh(&rx_queue->add_lock);
 
 	return rc;
@@ -541,38 +459,6 @@ static inline void efx_rx_packet__check_
 	rx_queue->channel->n_rx_overlength++;
 }
 
-/* Pass a received packet up through the generic LRO stack
- *
- * Handles driverlink veto, and passes the fragment up via
- * the appropriate LRO method
- */
-static inline void efx_rx_packet_lro(struct efx_channel *channel,
-				     struct efx_rx_buffer *rx_buf)
-{
-	struct net_lro_mgr *lro_mgr = &channel->lro_mgr;
-	void *priv = channel;
-
-	/* Pass the skb/page into the LRO engine */
-	if (rx_buf->page) {
-		struct skb_frag_struct frags;
-
-		frags.page = rx_buf->page;
-		frags.page_offset = efx_rx_buf_offset(rx_buf);
-		frags.size = rx_buf->len;
-
-		lro_receive_frags(lro_mgr, &frags, rx_buf->len,
-				  rx_buf->len, priv, 0);
-
-		EFX_BUG_ON_PARANOID(rx_buf->skb);
-		rx_buf->page = NULL;
-	} else {
-		EFX_BUG_ON_PARANOID(!rx_buf->skb);
-
-		lro_receive_skb(lro_mgr, rx_buf->skb, priv);
-		rx_buf->skb = NULL;
-	}
-}
-
 /* Allocate and construct an SKB around a struct page.*/
 static inline struct sk_buff *efx_rx_mk_skb(struct efx_rx_buffer *rx_buf,
 					    struct efx_nic *efx,
@@ -602,7 +488,7 @@ static inline struct sk_buff *efx_rx_mk_
 	if (unlikely(rx_buf->len > hdr_len)) {
 		struct skb_frag_struct *frag = skb_shinfo(skb)->frags;
 		frag->page = rx_buf->page;
-		frag->page_offset = efx_rx_buf_offset(rx_buf) + hdr_len;
+		frag->page_offset = RX_BUF_OFFSET(rx_buf) + hdr_len;
 		frag->size = skb->len - hdr_len;
 		skb_shinfo(skb)->nr_frags = 1;
 		skb->data_len = frag->size;
@@ -686,6 +572,7 @@ void __efx_rx_packet(struct efx_channel 
 		     struct efx_rx_buffer *rx_buf, int checksummed)
 {
 	struct efx_nic *efx = channel->efx;
+	enum efx_veto veto;
 	struct sk_buff *skb;
 	int lro = efx->net_dev->features & NETIF_F_LRO;
 
@@ -699,8 +586,10 @@ void __efx_rx_packet(struct efx_channel 
 	}
 
 	if (rx_buf->skb) {
+		/* Prefetch more information */
 		prefetch(skb_shinfo(rx_buf->skb));
 
+		/* Reserve space for the data */
 		skb_put(rx_buf->skb, rx_buf->len);
 
 		/* Move past the ethernet header. rx_buf->data still points
@@ -719,7 +608,19 @@ void __efx_rx_packet(struct efx_channel 
 		channel->rx_alloc_pop_pages = (rx_buf->page != NULL);
 	}
 	if (likely(checksummed && lro)) {
-		efx_rx_packet_lro(channel, rx_buf);
+		if (efx_ssr(&channel->ssr, rx_buf)) {
+			channel->rx_alloc_level += RX_ALLOC_FACTOR_LRO;
+			goto done;
+		}
+	}
+
+	/* Allow callback to veto the packet */
+	veto = EFX_DL_CALLBACK(efx, rx_packet, rx_buf->data, rx_buf->len);
+	if (unlikely(veto)) {
+		EFX_LOG(efx, "RX vetoed by driverlink %s driver\n",
+			efx->dl_cb_dev.rx_packet->driver->name);
+		/* Free the buffer now */
+		efx_free_rx_buffer(efx, rx_buf);
 		goto done;
 	}
 
@@ -751,7 +652,9 @@ void __efx_rx_packet(struct efx_channel 
 	/* Update allocation strategy method */
 	channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
 
+	/* fall-thru */
 done:
+	/* Update statistics */
 	efx->net_dev->last_rx = jiffies;
 }
 
@@ -804,6 +707,7 @@ int efx_probe_rx_queue(struct efx_rx_que
 	kfree(rx_queue->buffer);
 	rx_queue->buffer = NULL;
  fail1:
+	/* Mark queue as unused */
 	rx_queue->used = 0;
 
 	return rc;
@@ -843,6 +747,7 @@ void efx_fini_rx_queue(struct efx_rx_que
 
 	EFX_LOG(rx_queue->efx, "shutting down RX queue %d\n", rx_queue->queue);
 
+	/* Flush RX queue and remove descriptor ring */
 	falcon_fini_rx(rx_queue);
 
 	/* Release RX buffers NB start at index 0 not current HW ptr */
@@ -856,8 +761,7 @@ void efx_fini_rx_queue(struct efx_rx_que
 	/* For a page that is part-way through splitting into RX buffers */
 	if (rx_queue->buf_page != NULL) {
 		pci_unmap_page(rx_queue->efx->pci_dev, rx_queue->buf_dma_addr,
-			       efx_rx_buf_size(rx_queue->efx),
-			       PCI_DMA_FROMDEVICE);
+			       RX_PAGE_SIZE(rx_queue->efx), PCI_DMA_FROMDEVICE);
 		__free_pages(rx_queue->buf_page,
 			     rx_queue->efx->rx_buffer_order);
 		rx_queue->buf_page = NULL;
@@ -875,9 +779,10 @@ void efx_remove_rx_queue(struct efx_rx_q
 	rx_queue->used = 0;
 }
 
+/* Flush LRO/SSR state for the given channel */
 void efx_flush_lro(struct efx_channel *channel)
 {
-	lro_flush_all(&channel->lro_mgr);
+	efx_ssr_end_of_burst(&channel->ssr);
 }
 
 
@@ -888,3 +793,439 @@ module_param(rx_refill_threshold, uint, 
 MODULE_PARM_DESC(rx_refill_threshold,
 		 "RX descriptor ring fast/slow fill threshold (%)");
 
+/* Size of the LRO hash table.  Must be a power of 2.  A larger table
+ * means we can accelerate a larger number of streams.
+ */
+static unsigned lro_table_size = 128;
+module_param(lro_table_size, uint, 0644);
+MODULE_PARM_DESC(lro_table_size,
+		 "Size of the LRO hash table.  Must be a power of 2");
+
+/* Maximum length of a hash chain.  If chains get too long then the lookup
+ * time increases and may exceed the benefit of LRO.
+ */
+static unsigned lro_chain_max = 20;
+module_param(lro_chain_max, uint, 0644);
+MODULE_PARM_DESC(lro_chain_max,
+		 "Maximum length of chains in the LRO hash table");
+
+
+/* Maximum time (in jiffies) that a connection can be idle before it's LRO
+ * state is discarded.
+ */
+static unsigned lro_idle_jiffies = HZ / 10 + 1;	/* 100ms */
+module_param(lro_idle_jiffies, uint, 0644);
+MODULE_PARM_DESC(lro_idle_jiffies, "Time (in jiffies) after which an"
+		 " idle connection's LRO state is discarded");
+
+
+/* Number of packets with payload that must arrive in-order before a
+ * connection is eligible for LRO.  The idea is we should avoid coalescing
+ * segments when the sender is in slow-start because reducing the ACK rate
+ * can damage performance.
+ */
+static unsigned lro_slow_start_packets = 20;
+module_param(lro_slow_start_packets, uint, 0644);
+MODULE_PARM_DESC(lro_slow_start_packets, "Number of packets that must "
+		 "pass in-order before starting LRO.");
+
+
+int efx_ssr_init(struct efx_ssr_state *st, struct efx_nic *efx)
+{
+	unsigned i;
+	st->conns_mask = lro_table_size - 1;
+	if ((st->conns_mask + 1) & st->conns_mask) {
+		EFX_ERR(efx, "lro_table_size(=%u) must be a power of 2\n",
+			lro_table_size);
+		return -EINVAL;
+	}
+	st->efx = efx;
+	st->conns = kmalloc((st->conns_mask + 1)
+			    * sizeof(st->conns[0]), GFP_KERNEL);
+	if (st->conns == NULL)
+		return -ENOMEM;
+	st->conns_n = kmalloc((st->conns_mask + 1)
+			      * sizeof(st->conns_n[0]), GFP_KERNEL);
+	if (st->conns_n == NULL) {
+		kfree(st->conns);
+		st->conns = NULL;
+		return -ENOMEM;
+	}
+	for (i = 0; i <= st->conns_mask; ++i) {
+		INIT_LIST_HEAD(&st->conns[i]);
+		st->conns_n[i] = 0;
+	}
+	INIT_LIST_HEAD(&st->active_conns);
+	INIT_LIST_HEAD(&st->free_conns);
+	return 0;
+}
+
+/* Drop the given connection, and add it to the free list */
+static inline void efx_ssr_drop(struct efx_ssr_state *st,
+				struct efx_ssr_conn *c, unsigned conn_hash)
+{
+	EFX_BUG_ON_PARANOID(c->skb);
+	EFX_BUG_ON_PARANOID(st->conns_n[conn_hash] <= 0);
+	--st->conns_n[conn_hash];
+	list_del(&c->link);
+	list_add(&c->link, &st->free_conns);
+}
+
+void efx_ssr_fini(struct efx_ssr_state *st)
+{
+	struct efx_ssr_conn *c;
+	unsigned i;
+
+	/* Return cleanly if efx_ssr_init() has not been called. */
+	if (st->conns == NULL)
+		return;
+
+	EFX_BUG_ON_PARANOID(!list_empty(&st->active_conns));
+
+	for (i = 0; i <= st->conns_mask; ++i)
+		while (!list_empty(&st->conns[i])) {
+			c = list_entry(st->conns[i].prev,
+				       struct efx_ssr_conn, link);
+			efx_ssr_drop(st, c, i);
+		}
+
+	while (!list_empty(&st->free_conns)) {
+		c = list_entry(st->free_conns.prev, struct efx_ssr_conn, link);
+		list_del(&c->link);
+		EFX_BUG_ON_PARANOID(c->skb);
+		kfree(c);
+	}
+
+	kfree(st->conns_n);
+	kfree(st->conns);
+	st->conns = NULL;
+}
+
+/* Calc IP checksum and deliver to the OS */
+static void efx_ssr_deliver(struct efx_ssr_state *st, struct efx_ssr_conn *c)
+{
+	struct efx_nic *efx = st->efx;
+	int veto, len;
+
+	EFX_BUG_ON_PARANOID(!c->skb);
+
+	++st->n_bursts;
+
+	/* Finish off packet munging and recalculate IP header checksum. */
+	c->iph->tot_len = htons(c->iph->tot_len);
+	c->iph->check = 0;
+	c->iph->check = ip_fast_csum((u8 *) c->iph, c->iph->ihl);
+
+	len = c->skb->len + ((char *)c->iph - (char *)c->eh);
+	c->skb->truesize = len + sizeof(struct sk_buff);
+
+	c->th->window = c->th_last->window;
+	c->th->ack_seq = c->th_last->ack_seq;
+	if (c->th->doff == c->th_last->doff) {
+		/* Copy TCP options (take care to avoid going negative). */
+		len = ((c->th->doff - 5) & 0xf) << 2u;
+		memcpy(c->th + 1, c->th_last + 1, len);
+	}
+
+	/* Allow callback to veto the packet. */
+	veto = EFX_DL_CALLBACK(efx, rx_packet, (char *)c->eh, len);
+	if (unlikely(veto)) {
+		EFX_LOG(efx, "RX vetoed by driverlink %s driver\n",
+			efx->dl_cb_dev.rx_packet->driver->name);
+		dev_kfree_skb_any(c->skb);
+	} else {
+		netif_receive_skb(c->skb);
+	}
+
+	c->skb = NULL;
+	list_del_init(&c->active_link);
+}
+
+/* Stop tracking connections that have gone idle in order to keep hash
+ * chains short.
+ */
+static void efx_ssr_purge_idle(struct efx_ssr_state *st, unsigned now)
+{
+	struct efx_ssr_conn *c;
+	unsigned i;
+
+	EFX_BUG_ON_PARANOID(!list_empty(&st->active_conns));
+
+	st->last_purge_jiffies = now;
+	for (i = 0; i <= st->conns_mask; ++i) {
+		if (list_empty(&st->conns[i]))
+			continue;
+
+		c = list_entry(st->conns[i].prev, struct efx_ssr_conn, link);
+		if (now - c->last_pkt_jiffies > lro_idle_jiffies) {
+			++st->n_drop_idle;
+			efx_ssr_drop(st, c, i);
+		}
+	}
+}
+
+/* Push held skbs down into network stack.
+ * Only called when active list is non-empty.
+ */
+void __efx_ssr_end_of_burst(struct efx_ssr_state *st)
+{
+	struct efx_ssr_conn *c;
+	unsigned j;
+
+	EFX_BUG_ON_PARANOID(list_empty(&st->active_conns));
+
+	do {
+		c = list_entry(st->active_conns.next, struct efx_ssr_conn,
+			       active_link);
+		EFX_BUG_ON_PARANOID(!c->skb);
+		efx_ssr_deliver(st, c);
+	} while (!list_empty(&st->active_conns));
+
+	j = jiffies;
+	if (unlikely(j != st->last_purge_jiffies))
+		efx_ssr_purge_idle(st, j);
+}
+
+/* Construct an skb Push held skbs down into network stack.
+ * Only called when active list is non-empty.
+ */
+static inline int
+efx_ssr_merge(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+	      struct tcphdr *th, int data_length)
+{
+	/* Increase lengths appropriately */
+	c->skb->len += data_length;
+	c->skb->data_len += data_length;
+
+	/*
+	 * Keep track of max MSS seen and store in
+	 * gso_size for kernel to use
+	 */
+	if (data_length > skb_shinfo(c->skb)->gso_size)
+		skb_shinfo(c->skb)->gso_size = data_length;
+
+	/* Update the connection state flags */
+	c->iph->tot_len += data_length;
+	c->th->psh |= th->psh;
+	c->th_last = th;
+	++st->n_merges;
+
+	/* Pass packet up now if another segment could overflow the IP
+	 * length.
+	 */
+	return (c->skb->len > 65536 - 9200);
+}
+
+static inline void
+efx_ssr_start(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+	      struct tcphdr *th, int data_length)
+{
+	/* Initialise gso_size appropriately */
+	skb_shinfo(c->skb)->gso_size = data_length;
+
+	/* Mangle header fields for later processing */
+	c->iph->tot_len = ntohs(c->iph->tot_len);
+
+	/* Move this connection the head of the active list */
+	list_del(&c->active_link);
+	list_add(&c->active_link, &st->active_conns);
+}
+
+static inline int
+efx_ssr_conn_page(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+		  struct efx_rx_buffer *rx_buf, struct tcphdr *th,
+		  int hdr_length, int data_length)
+{
+	if (likely(c->skb)) {
+		struct skb_frag_struct *frag;
+		frag = skb_shinfo(c->skb)->frags;
+		frag += skb_shinfo(c->skb)->nr_frags;
+		frag->page = rx_buf->page;
+		frag->page_offset = RX_BUF_OFFSET(rx_buf) + hdr_length;
+		frag->size = data_length;
+		++skb_shinfo(c->skb)->nr_frags;
+		rx_buf->page = NULL;
+
+		if (efx_ssr_merge(st, c, th, data_length) ||
+		    (skb_shinfo(c->skb)->nr_frags == MAX_SKB_FRAGS))
+			efx_ssr_deliver(st, c);
+
+		return 1;
+	} else {
+		c->skb = efx_rx_mk_skb(rx_buf, st->efx, hdr_length);
+		if (unlikely(c->skb == NULL))
+			return 0;
+
+		c->eh = eth_hdr(c->skb);
+		c->iph = (struct iphdr *)c->skb->data;
+		c->th = (struct tcphdr *)((u8 *) c->iph + c->iph->ihl * 4);
+		c->th_last = c->th;
+
+		efx_ssr_start(st, c, th, data_length);
+
+		return 1;
+	}
+}
+
+static inline void
+efx_ssr_conn_skb(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+		 struct efx_rx_buffer *rx_buf, struct ethhdr *eh,
+		 struct iphdr *iph, struct tcphdr *th, int data_length)
+{
+	/* Transfer ownership of the rx_buf->skb to the LRO chain */
+	struct sk_buff *skb = rx_buf->skb;
+	rx_buf->skb = NULL;
+
+	if (likely(c->skb)) {
+		/* Remove the headers */
+		skb_pull(skb, skb->len - data_length);
+
+		/* Tack the new skb onto the head skb's frag_list. */
+		EFX_BUG_ON_PARANOID(skb->next);
+		if (!skb_shinfo(c->skb)->frag_list)
+			skb_shinfo(c->skb)->frag_list = skb;
+		else
+			c->skb_tail->next = skb;
+		c->skb_tail = skb;
+
+		if (efx_ssr_merge(st, c, th, data_length))
+			efx_ssr_deliver(st, c);
+	} else {
+		c->skb = skb;
+		c->eh = eh;
+		c->iph = iph;
+		c->th = th;
+		c->th_last = th;
+
+		efx_ssr_start(st, c, th, data_length);
+	}
+}
+
+/* Process SKB and decide whether to dispatch it to the stack now or
+ * later.
+ */
+int efx_ssr(struct efx_ssr_state *st, struct efx_rx_buffer *rx_buf)
+{
+
+	int eh_proto, data_length, hdr_length, dont_merge;
+	struct efx_ssr_conn *c;
+	struct ethhdr *eh;
+	struct iphdr *iph;
+	struct tcphdr *th;
+	unsigned th_seq, conn_hash, pkt_length;
+
+	/* This does not handle VLAN code */
+	/* Find the IP header. The ethernet header is always at rx_buf->data */
+	eh = (struct ethhdr *)rx_buf->data;
+	if (rx_buf->page) {
+		eh_proto = eh->h_proto;
+		iph = (struct iphdr *)(eh + 1);
+	} else {
+		/* The skb head is at the IP header */
+		eh_proto = rx_buf->skb->protocol;
+		iph = (struct iphdr *)rx_buf->skb->data;
+	}
+
+	/* We're not interested if it isn't TCP over IPv4, or if fragged. */
+	if ((eh_proto - htons(ETH_P_IP)) |
+	    (iph->protocol - IPPROTO_TCP) |
+	    (iph->frag_off & htons(IP_MF | IP_OFFSET)))
+		return 0;
+
+	/* Get the TCP protocol */
+	th = (struct tcphdr *)((u8 *) iph + iph->ihl * 4);
+	hdr_length = (u8 *) th + th->doff * 4 - (u8 *) eh;
+	/* Cope with padding after IP header */
+	pkt_length = ntohs(iph->tot_len) + (u8 *)iph - (u8 *)eh;
+	rx_buf->len = min(pkt_length, rx_buf->len);
+	data_length = rx_buf->len - hdr_length;
+	th_seq = ntohl(th->seq);
+	dont_merge = ((data_length <= 0)
+		      | th->urg | th->syn | th->rst | th->fin);
+
+	/* Very cheap and crude hash. */
+	conn_hash = (th->source ^ th->dest) & st->conns_mask;
+
+	list_for_each_entry(c, &st->conns[conn_hash], link) {
+		if ((c->saddr - iph->saddr) | (c->daddr - iph->daddr) |
+		    (c->source - th->source) | (c->dest - th->dest))
+			continue;
+
+		/* Re-insert at head of list to reduce lookup time. */
+		list_del(&c->link);
+		list_add(&c->link, &st->conns[conn_hash]);
+
+		if (unlikely(th_seq - c->next_seq)) {
+			/* Out-of-order, so start counting again. */
+			if (c->skb)
+				efx_ssr_deliver(st, c);
+			c->n_in_order_pkts = 0;
+			c->next_seq = th_seq + data_length;
+			++st->n_misorder;
+			return 0;
+		}
+		c->next_seq = th_seq + data_length;
+		c->last_pkt_jiffies = jiffies;
+
+		if (c->n_in_order_pkts < lro_slow_start_packets) {
+			/* May be in slow-start, so don't merge. */
+			++st->n_slow_start;
+			++c->n_in_order_pkts;
+			return 0;
+		}
+
+		if (unlikely(dont_merge)) {
+			if (c->skb)
+				efx_ssr_deliver(st, c);
+			if (th->fin || th->rst) {
+				++st->n_drop_closed;
+				efx_ssr_drop(st, c, conn_hash);
+			}
+			return 0;
+		}
+
+		if (rx_buf->page) {
+			return efx_ssr_conn_page(st, c, rx_buf, th, hdr_length,
+						 data_length);
+		} else {
+			efx_ssr_conn_skb(st, c, rx_buf, eh, iph, th,
+					 data_length);
+			return 1;
+		}
+	}
+
+	/* We're not yet tracking this connection. */
+	if (dont_merge)
+		return 0;
+
+	if (st->conns_n[conn_hash] >= lro_chain_max) {
+		++st->n_too_many;
+		return 0;
+	}
+
+	if (!list_empty(&st->free_conns)) {
+		c = list_entry(st->free_conns.next, struct efx_ssr_conn, link);
+		list_del(&c->link);
+	} else {
+		c = kmalloc(sizeof(*c), GFP_ATOMIC);
+		if (c == NULL)
+			return 0;
+		c->skb = NULL;
+		INIT_LIST_HEAD(&c->active_link);
+	}
+
+	/* Create the connection tracking data */
+	++st->conns_n[conn_hash];
+	list_add(&c->link, &st->conns[conn_hash]);
+	c->saddr = iph->saddr;
+	c->daddr = iph->daddr;
+	c->source = th->source;
+	c->dest = th->dest;
+	c->next_seq = th_seq + data_length;
+	c->n_in_order_pkts = 0;
+	EFX_BUG_ON_PARANOID(c->skb);
+	++st->n_new_stream;
+	return 0;
+}
+
+
Index: head-2008-06-18/drivers/net/sfc/rx.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/rx.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/rx.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,24 +1,40 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_RX_H
 #define EFX_RX_H
 
+#include <linux/skbuff.h>
 #include "net_driver.h"
 
+
 int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);
 void efx_remove_rx_queue(struct efx_rx_queue *rx_queue);
 int efx_init_rx_queue(struct efx_rx_queue *rx_queue);
 void efx_fini_rx_queue(struct efx_rx_queue *rx_queue);
 
-int efx_lro_init(struct net_lro_mgr *lro_mgr, struct efx_nic *efx);
-void efx_lro_fini(struct net_lro_mgr *lro_mgr);
 void efx_flush_lro(struct efx_channel *channel);
 void efx_rx_strategy(struct efx_channel *channel);
 void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue);
@@ -26,4 +42,18 @@ void efx_rx_work(struct work_struct *dat
 void __efx_rx_packet(struct efx_channel *channel,
 		     struct efx_rx_buffer *rx_buf, int checksummed);
 
+
+extern int efx_ssr_init(struct efx_ssr_state *st, struct efx_nic *efx);
+extern void efx_ssr_fini(struct efx_ssr_state *st);
+
+extern void __efx_ssr_end_of_burst(struct efx_ssr_state *st);
+extern int efx_ssr(struct efx_ssr_state *st, struct efx_rx_buffer *rx_buf);
+
+
+static inline void efx_ssr_end_of_burst(struct efx_ssr_state *st)
+{
+	if (!list_empty(&st->active_conns))
+		__efx_ssr_end_of_burst(st);
+}
+
 #endif /* EFX_RX_H */
Index: head-2008-06-18/drivers/net/sfc/selftest.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/selftest.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/selftest.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #include <linux/netdevice.h>
@@ -26,7 +43,8 @@
 #include "selftest.h"
 #include "boards.h"
 #include "workarounds.h"
-#include "mac.h"
+
+/* Self tests */
 
 /*
  * Loopback test packet structure
@@ -50,21 +68,20 @@ static const unsigned char payload_sourc
 static const char *payload_msg =
 	"Hello world! This is an Efx loopback test in progress!";
 
-/**
- * efx_selftest_state - persistent state during a selftest
- * @flush:		Drop all packets in efx_loopback_rx_packet
- * @packet_count:	Number of packets being used in this test
- * @skbs:		An array of skbs transmitted
- * @rx_good:		RX good packet count
- * @rx_bad:		RX bad packet count
- * @payload:		Payload used in tests
- */
 struct efx_selftest_state {
+	/* Drop all packets in  efx_loopback_rx_packet */
 	int flush;
+
+	/* Number of packets being used in this test */
 	int packet_count;
-	struct sk_buff **skbs;
+
+	/* RX good packet count */
 	atomic_t rx_good;
+
+	/* RX bad packet count */
 	atomic_t rx_bad;
+
+	/* Payload used in tests */
 	struct efx_loopback_payload payload;
 };
 
@@ -92,11 +109,18 @@ static unsigned int loopback_test_level 
  *
  **************************************************************************/
 
-/* Test generation and receipt of interrupts */
+/*
+ * Test interrupts
+ *
+ * This generates a test interrupt and waits for it to be received by
+ * a CPU.  This routine must be called from process context and will
+ * sleep.
+ */
 static int efx_test_interrupts(struct efx_nic *efx,
 			       struct efx_self_tests *tests)
 {
 	struct efx_channel *channel;
+	unsigned long j_start;
 
 	EFX_LOG(efx, "testing interrupts\n");
 	tests->interrupt = -1;
@@ -105,15 +129,23 @@ static int efx_test_interrupts(struct ef
 	efx->last_irq_cpu = -1;
 	smp_wmb();
 
-	/* ACK each interrupting event queue. Receiving an interrupt due to
-	 * traffic before a test event is raised is considered a pass */
+	/* To guarantee that an interrupt is received make sure that the
+	 * channels are ack'd at least once, reenabling interrupts.
+	 * We will then receive an interrupt, either by explicitly
+	 * requesting one, or receiving traffic.
+	 */
 	efx_for_each_channel_with_interrupt(channel, efx) {
+		/* Process the eventq synchronously */
 		if (channel->work_pending)
 			efx_process_channel_now(channel);
+		/* Check if we haven't already received an interrupt */
 		if (efx->last_irq_cpu >= 0)
 			goto success;
 	}
 
+	j_start = jiffies;
+
+	/* Generate test interrupt. */
 	falcon_generate_interrupt(efx);
 
 	/* Wait for arrival of test interrupt. */
@@ -122,17 +154,22 @@ static int efx_test_interrupts(struct ef
 	if (efx->last_irq_cpu >= 0)
 		goto success;
 
-	EFX_ERR(efx, "timed out waiting for interrupt\n");
+	EFX_ERR(efx, "timed out in %ld jiffies waiting for interrupt\n",
+		jiffies - j_start);
 	return -ETIMEDOUT;
 
  success:
-	EFX_LOG(efx, "test interrupt (mode %d) seen on CPU%d\n",
-		efx->interrupt_mode, efx->last_irq_cpu);
+	EFX_LOG(efx, "%s test interrupt seen on CPU%d\n", INT_MODE(efx),
+		efx->last_irq_cpu);
 	tests->interrupt = 1;
 	return 0;
 }
 
-/* Test generation and receipt of non-interrupting events */
+/*
+ * Test capability of events to receive events
+ * This generates a test event and waits for it to be processed
+ * This routine must be called from process context and will sleep.
+ */
 static int efx_test_eventq(struct efx_channel *channel,
 			   struct efx_self_tests *tests)
 {
@@ -152,6 +189,7 @@ static int efx_test_eventq(struct efx_ch
 	channel->eventq_magic = 0;
 	smp_wmb();
 
+	/* Generate test event */
 	falcon_generate_test_event(channel, magic);
 	udelay(1);
 
@@ -167,11 +205,18 @@ static int efx_test_eventq(struct efx_ch
 	return 0;
 }
 
-/* Test generation and receipt of interrupting events */
+
+/*
+ * Test capability of events to generate interrupts
+ * This generates a test event and waits for it to be processed by an
+ * ISR.  This routine must be called from process context and will
+ * sleep.
+ */
 static int efx_test_eventq_irq(struct efx_channel *channel,
 			       struct efx_self_tests *tests)
 {
 	unsigned int magic, count;
+	unsigned long j_start = jiffies;
 
 	/* Channel specific code, limited to 20 bits */
 	magic = (0x00010150 + channel->channel);
@@ -187,6 +232,7 @@ static int efx_test_eventq_irq(struct ef
 	channel->eventq_magic = 0;
 	smp_wmb();
 
+	/* Generate test event */
 	falcon_generate_test_event(channel, magic);
 
 	/* Wait for arrival of interrupt */
@@ -201,8 +247,8 @@ static int efx_test_eventq_irq(struct ef
 			goto eventq_ok;
 	} while (++count < 2);
 
-	EFX_ERR(channel->efx, "channel %d timed out waiting for event queue\n",
-		channel->channel);
+	EFX_ERR(channel->efx, "channel %d timed out in %ld jiffies waiting for"
+		" event queue\n", channel->channel, jiffies - j_start);
 
 	/* See if interrupt arrived */
 	if (channel->efx->last_irq_cpu >= 0) {
@@ -236,7 +282,12 @@ static int efx_test_eventq_irq(struct ef
  *
  **************************************************************************/
 
-/* Check PHY presence by reading the PHY ID registers */
+/*
+ * Check PHY presence
+ * This reads the PHY ID registers via GMII and checks that neither
+ * are all-zeroes or all-ones (indicating a nonexistent or
+ * uncommunicative PHY).
+ */
 static int efx_test_phy(struct efx_nic *efx,
 			struct efx_self_tests *tests)
 {
@@ -289,52 +340,63 @@ void efx_loopback_rx_packet(struct efx_n
 		return;
 
 	payload = &state->payload;
-	
-	received = (struct efx_loopback_payload *) buf_ptr;
+
+	/* The packet should have been passed up to us before any LRO/SSR, so
+	 * we should be able to compare the data directly. Since the packet
+	 * is going to be thrown away by the caller, modify it in place.
+	 * efx_test_loopback guarantees to not touch state->payload during
+	 * the test */
+	received = (struct efx_loopback_payload *)(char *)buf_ptr;
 	received->ip.saddr = payload->ip.saddr;
 	received->ip.check = payload->ip.check;
-	
+
 	/* Check that header exists */
 	if (pkt_len < sizeof(received->header)) {
-		EFX_ERR(efx, "saw runt RX packet (length %d) in %s loopback "
-			"test\n", pkt_len, LOOPBACK_MODE(efx));
+		EFX_ERR(efx, "saw runt RX packet (length %d) "
+			"in %s loopback test\n", pkt_len,
+			LOOPBACK_MODE(efx));
 		goto err;
 	}
 
-	/* Check that the ethernet header exists */
+	/* Check that header matches */
 	if (memcmp(&received->header, &payload->header, ETH_HLEN) != 0) {
-		EFX_ERR(efx, "saw non-loopback RX packet in %s loopback test\n",
+		EFX_ERR(efx, "saw non-loopback RX packet in"
+			" %s loopback test\n",
 			LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check packet length */
 	if (pkt_len != sizeof(*payload)) {
-		EFX_ERR(efx, "saw incorrect RX packet length %d (wanted %d) in "
-			"%s loopback test\n", pkt_len, (int)sizeof(*payload),
+		EFX_ERR(efx, "saw incorrect RX packet length"
+			" %d (wanted %d) in %s loopback test\n",
+			pkt_len, (int)sizeof(*payload),
 			LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that IP header matches */
 	if (memcmp(&received->ip, &payload->ip, sizeof(payload->ip)) != 0) {
-		EFX_ERR(efx, "saw corrupted IP header in %s loopback test\n",
+		EFX_ERR(efx, "saw corrupted IP header in %s "
+			"loopback test\n",
 			LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that msg and padding matches */
 	if (memcmp(&received->msg, &payload->msg, sizeof(received->msg)) != 0) {
-		EFX_ERR(efx, "saw corrupted RX packet in %s loopback test\n",
+		EFX_ERR(efx, "saw corrupted RX packet in %s "
+			"loopback test\n",
 			LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that iteration matches */
 	if (received->iteration != payload->iteration) {
-		EFX_ERR(efx, "saw RX packet from iteration %d (wanted %d) in "
-			"%s loopback test\n", ntohs(received->iteration),
-			ntohs(payload->iteration), LOOPBACK_MODE(efx));
+		EFX_ERR(efx, "saw RX packet from iteration %d"
+			" (wanted %d) in %s loopback test\n",
+			ntohs(received->iteration), ntohs(payload->iteration),
+			LOOPBACK_MODE(efx));
 		goto err;
 	}
 
@@ -374,7 +436,7 @@ static void efx_iterate_state(struct efx
 	/* saddr set later and used as incrementing count */
 	payload->ip.daddr = htonl(INADDR_LOOPBACK);
 	payload->ip.ihl = 5;
-	payload->ip.check = htons(0xdead);
+	payload->ip.check = 0;		/* offloaded */
 	payload->ip.tot_len = htons(sizeof(*payload) - sizeof(struct ethhdr));
 	payload->ip.version = IPVERSION;
 	payload->ip.protocol = IPPROTO_UDP;
@@ -395,100 +457,91 @@ static void efx_iterate_state(struct efx
 	smp_wmb();
 }
 
-static int efx_tx_loopback(struct efx_tx_queue *tx_queue)
+/*
+ * Perform loopback test with N packets
+ *
+ * This will transmit "num_packets" copies of a test packet, and check
+ * that they were both transmitted (i.e. a TX completion event was
+ * received) and received (i.e. the data arrived intact via loopback).
+ * The port must have already been placed into the desired loopback
+ * mode.
+ */
+static int efx_test_loopback(struct efx_nic *efx,
+			     struct efx_tx_queue *tx_queue,
+			     struct efx_loopback_self_tests *lb_tests)
 {
-	struct efx_nic *efx = tx_queue->efx;
+	struct efx_channel *channel;
 	struct efx_selftest_state *state = efx->loopback_selftest;
 	struct efx_loopback_payload *payload;
 	struct sk_buff *skb;
-	int i, rc;
+	int rc = 0, i, tx_done, rx_good, rx_bad;
+
+	/* Fill out the packet contents */
+	efx_iterate_state(efx);
+
+	/* Create and fill skb */
+	skb = alloc_skb(sizeof(state->payload), GFP_KERNEL);
+	if (!skb) {
+		rc = -ENOMEM;
+		goto out1;
+	}
+	payload = ((struct efx_loopback_payload *)
+		   skb_put(skb, sizeof(state->payload)));
+	memcpy(payload, &state->payload, sizeof(state->payload));
 
 	/* Transmit N copies of buffer */
 	for (i = 0; i < state->packet_count; i++) {
-		/* Allocate an skb, holding an extra reference for 
-		 * transmit completion counting */
-		skb = alloc_skb(sizeof(state->payload), GFP_KERNEL);
-		if (!skb)
-			return -ENOMEM;
-		state->skbs[i] = skb;
-		skb_get(skb);
-
-		/* Copy the payload in, incrementing the source address to
-		 * exercise the rss vectors */
-		payload = ((struct efx_loopback_payload *)
-			   skb_put(skb, sizeof(state->payload)));
-		memcpy(payload, &state->payload, sizeof(state->payload));
+		/* Set the source address in the copy of the packet.
+		 * Incrementing the source address on a per-packet basis
+		 * should ensure that we stress all RSS vectors */
 		payload->ip.saddr = htonl(INADDR_LOOPBACK | (i << 2));
+		skb_get(skb);
 
-		/* Ensure everything we've written is visible to the
-		 * interrupt handler. */
-		smp_wmb();
-
-		if (efx_dev_registered(efx))
-			netif_tx_lock_bh(efx->net_dev);
-		rc = efx_xmit(efx, tx_queue, skb);
-		if (efx_dev_registered(efx))
-			netif_tx_unlock_bh(efx->net_dev);
-
-		if (rc != NETDEV_TX_OK) {
-			EFX_ERR(efx, "TX queue %d could not transmit packet %d "
-				"of %d in %s loopback test\n", tx_queue->queue,
-				i + 1, state->packet_count, LOOPBACK_MODE(efx));
-
-			/* Defer cleaning up the other skbs for the caller */
-			kfree_skb(skb);
-			return -EPIPE;
+		if (efx_xmit(efx, tx_queue, skb) != NETDEV_TX_OK) {
+			EFX_ERR(efx, "TX queue %d could not transmit "
+				"packet %d of %d in %s loopback test\n",
+				tx_queue->queue, i + 1,
+				state->packet_count, LOOPBACK_MODE(efx));
+			rc = -EPIPE;
+			goto out2;
 		}
-	}
 
-	return 0;
-}
-
-static int efx_rx_loopback(struct efx_tx_queue *tx_queue,
-			   struct efx_loopback_self_tests *lb_tests)
-{
-	struct efx_nic *efx = tx_queue->efx;
-	struct efx_selftest_state *state = efx->loopback_selftest;
-	struct sk_buff *skb;
-	int tx_done = 0, rx_good, rx_bad;
-	int i, rc = 0;
-
-	if (efx_dev_registered(efx))
-		netif_tx_lock_bh(efx->net_dev);
+		/* Avoid hogging the PCI bus */
+		udelay(10);
+	}
 
-	/* Count the number of tx completions, and decrement the refcnt. Any
-	 * skbs not already completed will be free'd when the queue is flushed */
-	for (i=0; i < state->packet_count; i++) {
-		skb = state->skbs[i];
-		if (skb && !skb_shared(skb))
-			++tx_done;
-		dev_kfree_skb_any(skb);
+	/* NAPI polling is not enabled, so process channels synchronously */
+	schedule_timeout_uninterruptible(HZ / 50);
+	efx_for_each_channel_with_interrupt(channel, efx) {
+		if (channel->work_pending)
+			efx_process_channel_now(channel);
 	}
 
-	if (efx_dev_registered(efx))
-		netif_tx_unlock_bh(efx->net_dev);
+	if (state->flush)
+		goto out3;
 
 	/* Check TX completion and received packet counts */
+	tx_done = state->packet_count - (atomic_read(&skb->users) - 1);
 	rx_good = atomic_read(&state->rx_good);
 	rx_bad = atomic_read(&state->rx_bad);
 	if (tx_done != state->packet_count) {
 		/* Don't free the skbs; they will be picked up on TX
 		 * overflow or channel teardown.
 		 */
-		EFX_ERR(efx, "TX queue %d saw only %d out of an expected %d "
-			"TX completion events in %s loopback test\n",
-			tx_queue->queue, tx_done, state->packet_count,
-			LOOPBACK_MODE(efx));
+		EFX_ERR(efx, "TX queue %d saw only %d out of an "
+			"expected %d TX completion events in %s loopback "
+			"test\n", tx_queue->queue, tx_done,
+			state->packet_count, LOOPBACK_MODE(efx));
 		rc = -ETIMEDOUT;
 		/* Allow to fall through so we see the RX errors as well */
 	}
 
 	/* We may always be up to a flush away from our desired packet total */
 	if (rx_good != state->packet_count) {
-		EFX_LOG(efx, "TX queue %d saw only %d out of an expected %d "
-			"received packets in %s loopback test\n",
-			tx_queue->queue, rx_good, state->packet_count,
-			LOOPBACK_MODE(efx));
+		EFX_LOG(efx, "TX queue %d saw only %d out of an "
+			"expected %d received packets in %s loopback "
+			"test\n", tx_queue->queue, rx_good,
+			state->packet_count, LOOPBACK_MODE(efx));
 		rc = -ETIMEDOUT;
 		/* Fall through */
 	}
@@ -499,56 +552,59 @@ static int efx_rx_loopback(struct efx_tx
 	lb_tests->rx_good += rx_good;
 	lb_tests->rx_bad += rx_bad;
 
+ out3:
+ out2:
+	/* Free skb */
+	if (skb) {
+		/* If the selftest failed then the skb needs its reference
+		 * count decreasing */
+		while (skb_shared(skb))
+			kfree_skb(skb);
+		dev_kfree_skb_any(skb);
+	}
+
+ out1:
 	return rc;
 }
 
+/* Perform loopback test safely
+ *
+ * This performs a safe loopback test by starting with a single packet
+ * and only increasing the number of packets while the tests are
+ * passing.  This avoids flooding a network with garbage packets if
+ * e.g. setting the loopback mode fails.
+ */
 static int
-efx_test_loopback(struct efx_tx_queue *tx_queue,
-		  struct efx_loopback_self_tests *lb_tests)
+efx_test_loopback_safely(struct efx_nic *efx,
+			 struct efx_tx_queue *tx_queue,
+			 struct efx_loopback_self_tests *lb_tests)
 {
-	struct efx_nic *efx = tx_queue->efx;
 	struct efx_selftest_state *state = efx->loopback_selftest;
-	struct efx_channel *channel;
 	int i, rc = 0;
 
 	for (i = 0; i < loopback_test_level; i++) {
 		/* Determine how many packets to send */
 		state->packet_count = (efx->type->txd_ring_mask + 1) / 3;
 		state->packet_count = min(1 << (i << 2), state->packet_count);
-		state->skbs = kzalloc(sizeof(state->skbs[0]) *
-				      state->packet_count, GFP_KERNEL);
-		if (!state->skbs)
-			return -ENOMEM;
 		state->flush = 0;
 
-		EFX_LOG(efx, "TX queue %d testing %s loopback with %d "
-			"packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
-			state->packet_count);
-
-		efx_iterate_state(efx);
-		rc = efx_tx_loopback(tx_queue);
-		
-		/* NAPI polling is not enabled, so process channels synchronously */
-		schedule_timeout_uninterruptible(HZ / 50);
-		efx_for_each_channel_with_interrupt(channel, efx) {
-			if (channel->work_pending)
-				efx_process_channel_now(channel);
-		}
-
-		rc |= efx_rx_loopback(tx_queue, lb_tests);
-		kfree(state->skbs);
+		EFX_LOG(efx, "TX queue %d testing %s loopback"
+			" with %d packets\n", tx_queue->queue,
+			LOOPBACK_MODE(efx), state->packet_count);
 
+		rc = efx_test_loopback(efx, tx_queue, lb_tests);
 		if (rc) {
 			/* Wait a while to ensure there are no packets
-			 * floating around after a failure. */
-			schedule_timeout_uninterruptible(HZ / 10);
+			 * floating around after a failure.
+			 */
+			schedule_timeout_uninterruptible(HZ / 5);
 			return rc;
 		}
 	}
 
-	EFX_LOG(efx, "TX queue %d passed %s loopback test with a burst length "
-		"of %d packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
-		state->packet_count);
+	EFX_LOG(efx, "TX queue %d passed %s loopback test "
+		"with a burst length of %d packets\n",
+		tx_queue->queue, LOOPBACK_MODE(efx), state->packet_count);
 
 	return rc;
 }
@@ -561,21 +617,25 @@ static int efx_test_loopbacks(struct efx
 	struct ethtool_cmd ecmd, ecmd_loopback;
 	struct efx_tx_queue *tx_queue;
 	enum efx_loopback_mode old_mode, mode;
-	int count, rc = 0, link_up;
-	
+	int old_powered, count, rc = 0, link_up;
+	int retry = EFX_WORKAROUND_8909(efx);
+
+	/* Get current PHY settings */
 	rc = efx_ethtool_get_settings(efx->net_dev, &ecmd);
 	if (rc) {
 		EFX_ERR(efx, "could not get GMII settings\n");
 		return rc;
 	}
 	old_mode = efx->loopback_mode;
+	old_powered = efx->phy_powered;
 
 	/* Disable autonegotiation for the purposes of loopback */
 	memcpy(&ecmd_loopback, &ecmd, sizeof(ecmd_loopback));
 	if (ecmd_loopback.autoneg == AUTONEG_ENABLE) {
 		ecmd_loopback.autoneg = AUTONEG_DISABLE;
 		ecmd_loopback.duplex = DUPLEX_FULL;
-		ecmd_loopback.speed = SPEED_10000;
+		ecmd_loopback.speed = EFX_IS10G(efx) ?
+			SPEED_10000 : SPEED_1000;
 	}
 
 	rc = efx_ethtool_set_settings(efx->net_dev, &ecmd_loopback);
@@ -593,6 +653,7 @@ static int efx_test_loopbacks(struct efx
 
 		/* Move the port into the specified loopback mode. */
 		state->flush = 1;
+		efx->phy_powered = 1;
 		efx->loopback_mode = mode;
 		efx_reconfigure_port(efx);
 
@@ -601,7 +662,7 @@ static int efx_test_loopbacks(struct efx
 		do {
 			struct efx_channel *channel = &efx->channel[0];
 
-			falcon_check_xmac(efx);
+			(void) efx->mac_op->check_hw(efx);
 			schedule_timeout_uninterruptible(HZ / 10);
 			if (channel->work_pending)
 				efx_process_channel_now(channel);
@@ -615,7 +676,7 @@ static int efx_test_loopbacks(struct efx
 			 * guarantee that the link is really, really, up.
 			 */
 			link_up = efx->link_up;
-			if (!falcon_xaui_link_ok(efx))
+			if (EFX_IS10G(efx) && !falcon_xaui_link_ok(efx))
 				link_up = 0;
 
 		} while ((++count < 20) && !link_up);
@@ -634,18 +695,42 @@ static int efx_test_loopbacks(struct efx
 
 		/* Test every TX queue */
 		efx_for_each_tx_queue(tx_queue, efx) {
-			rc |= efx_test_loopback(tx_queue,
-						&tests->loopback[mode]);
+			rc |= efx_test_loopback_safely(efx, tx_queue,
+						       &tests->loopback[mode]);
 			if (rc)
-				goto out;
+				goto fail;
 		}
+
+		continue;
+
+fail:
+		if (retry) {
+			/* Give the PHY a kick by pretending to move into
+			 * a Falcon internal loopback mode, then back out */
+			int first = ffs(efx->loopback_modes) - 1;
+
+			EFX_INFO(efx, "retrying %s loopback\n",
+				 LOOPBACK_MODE(efx));
+
+			state->flush = 1;
+			efx->loopback_mode = first;
+			efx_reconfigure_port(efx);
+
+			retry = rc = 0;
+			--mode;
+			continue;
+		}
+		break;
 	}
 
  out:
 	/* Take out of loopback and restore PHY settings */
 	state->flush = 1;
 	efx->loopback_mode = old_mode;
-	efx_ethtool_set_settings(efx->net_dev, &ecmd);
+	efx->phy_powered = old_powered;
+	/* Push the loopback change, and restore any other
+	 * settings we may have trodden on */
+	(void) efx_ethtool_set_settings(efx->net_dev, &ecmd);
 
 	return rc;
 }
@@ -657,7 +742,11 @@ static int efx_test_loopbacks(struct efx
  *************************************************************************/
 
 /* Online (i.e. non-disruptive) testing
- * This checks interrupt generation, event delivery and PHY presence. */
+ *
+ * This checks interrupt generation, event delivery and PHY presence.
+ * The caller should hold the suspend lock
+ *
+ */
 int efx_online_test(struct efx_nic *efx, struct efx_self_tests *tests)
 {
 	struct efx_channel *channel;
@@ -681,7 +770,9 @@ int efx_online_test(struct efx_nic *efx,
 }
 
 /* Offline (i.e. disruptive) testing
- * This checks MAC and PHY loopback on the specified port. */
+ * This checks MAC and PHY loopback on the specified port. The caller
+ * should hold the rtnl lock
+ */
 int efx_offline_test(struct efx_nic *efx,
 		     struct efx_self_tests *tests, unsigned int loopback_modes)
 {
@@ -702,10 +793,13 @@ int efx_offline_test(struct efx_nic *efx
 	 * "flushing" so all inflight packets are dropped */
 	BUG_ON(efx->loopback_selftest);
 	state->flush = 1;
-	efx->loopback_selftest = state;
+	efx->loopback_selftest = (void *)state;
+	wmb();
 
+	/* Test all loopback  modes */
 	rc = efx_test_loopbacks(efx, tests, loopback_modes);
 
+	/* Tidy up the port test state */
 	efx->loopback_selftest = NULL;
 	wmb();
 	kfree(state);
Index: head-2008-06-18/drivers/net/sfc/selftest.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/selftest.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/selftest.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_SELFTEST_H
Index: head-2008-06-18/drivers/net/sfc/sfe4001.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/sfe4001.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/sfe4001.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
- */
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************/
 
 /*****************************************************************************
  * Support for the SFE4001 NIC: driver code for the PCA9539 I/O expander that
@@ -18,7 +33,6 @@
 #include "boards.h"
 #include "falcon.h"
 #include "falcon_hwdefs.h"
-#include "mac.h"
 
 /**************************************************************************
  *
@@ -116,28 +130,65 @@ void sfe4001_poweroff(struct efx_nic *ef
 
 	/* Turn off all power rails */
 	out = 0xff;
-	efx_i2c_write(i2c, PCA9539, P0_OUT, &out, 1);
+	(void) efx_i2c_write(i2c, PCA9539, P0_OUT, &out, 1);
 
 	/* Disable port 1 outputs on IO expander */
 	cfg = 0xff;
-	efx_i2c_write(i2c, PCA9539, P1_CONFIG, &cfg, 1);
+	(void) efx_i2c_write(i2c, PCA9539, P1_CONFIG, &cfg, 1);
 
 	/* Disable port 0 outputs on IO expander */
 	cfg = 0xff;
-	efx_i2c_write(i2c, PCA9539, P0_CONFIG, &cfg, 1);
+	(void) efx_i2c_write(i2c, PCA9539, P0_CONFIG, &cfg, 1);
 
 	/* Clear any over-temperature alert */
-	efx_i2c_read(i2c, MAX6647, RSL, &in, 1);
+	(void) efx_i2c_read(i2c, MAX6647, RSL, &in, 1);
 }
 
-/* The P0_EN_3V3X line on SFE4001 boards (from A2 onward) is connected
- * to the FLASH_CFG_1 input on the DSP.  We must keep it high at power-
- * up to allow writing the flash (done through MDIO from userland).
- */
-unsigned int sfe4001_phy_flash_cfg;
-module_param_named(phy_flash_cfg, sfe4001_phy_flash_cfg, uint, 0444);
-MODULE_PARM_DESC(phy_flash_cfg,
-		 "Force PHY to enter flash configuration mode");
+static int sfe4001_check_hw(struct efx_nic *efx)
+{
+	struct efx_i2c_interface *i2c = &efx->i2c;
+	int rc;
+	u8 status;
+
+	/* Check the powered status of the PHY. Lack of power implies that
+	 * the MAX6647 has shut down power to it, probably due to a temp.
+	 * alarm. Reading the power status rather than the MAX6647 status
+	 * directly because the later is read-to-clear and would thus
+	 * start to power up the PHY again when polled, causing us to blip
+	 * the power undesirably */
+
+	/* If XAUI link is down, check power status. Reading
+	 * power requires a I2C byte read, which is too slow
+	 * to poll (see SFC bug 7884). */
+	if (falcon_xaui_link_ok(efx))
+		return 0;
+
+	rc = efx_i2c_read(i2c, PCA9539, P1_IN, &status, 1);
+	status &= ((1 << P1_AFE_PWD_LBN) | (1 << P1_DSP_PWD25_LBN));
+
+	/* We know we can read from the IO expander because we did
+	 * it during power-on. Assume failure now is bad news. */
+	if (rc != 0 || status == 0) {
+		sfe4001_poweroff(efx);
+
+		/* Note that the PHY is pining for the cooling fans */
+		tenxpress_set_state(efx, TENXPRESS_STATUS_OTEMP);
+
+		/* Log the info */
+		if (status == 0) {
+			EFX_ERR(efx, "%s: Temperature sensor reports "
+				"alarm! (0x%x) Shutting down PHY.\n",
+				__func__, status);
+			rc = -EIO;
+		} else {
+			EFX_ERR(efx, "%s: Failed to read PHY status!"
+				" Shutting down PHY.\n",
+				__func__);
+		}
+	}
+
+	return rc;
+}
 
 /* This board uses an I2C expander to provider power to the PHY, which needs to
  * be turned on before the PHY can be used.
@@ -163,9 +214,12 @@ int sfe4001_poweron(struct efx_nic *efx)
 			     XX_RESETB_EN, 1,
 			     XX_RSTXGXSRX_EN, 1,
 			     XX_RSTXGXSTX_EN, 1);
-	falcon_xmac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
+	efx->mac_op->mac_writel(efx, &reg, XX_PWR_RST_REG_MAC);
 	udelay(10);
 
+	efx->board_info.monitor = sfe4001_check_hw;
+	efx->board_info.fini = sfe4001_poweroff;
+
 	/* Set DSP over-temperature alert threshold */
 	EFX_INFO(efx, "DSP cut-out at %dC\n", xgphy_max_temperature);
 	rc = efx_i2c_write(i2c, MAX6647, WLHO,
@@ -212,8 +266,6 @@ int sfe4001_poweron(struct efx_nic *efx)
 		out = 0xff & ~((1 << P0_EN_1V2_LBN) | (1 << P0_EN_2V5_LBN) |
 			       (1 << P0_EN_3V3X_LBN) | (1 << P0_EN_5V_LBN) |
 			       (1 << P0_X_TRST_LBN));
-		if (sfe4001_phy_flash_cfg)
-			out |= 1 << P0_EN_3V3X_LBN;
 
 		rc = efx_i2c_write(i2c, PCA9539, P0_OUT, &out, 1);
 		if (rc)
@@ -237,9 +289,6 @@ int sfe4001_poweron(struct efx_nic *efx)
 		if (in & (1 << P1_AFE_PWD_LBN))
 			goto done;
 
-		/* DSP doesn't look powered in flash config mode */
-		if (sfe4001_phy_flash_cfg)
-			goto done;
 	} while (++count < 20);
 
 	EFX_INFO(efx, "timed out waiting for power\n");
@@ -253,14 +302,14 @@ done:
 fail3:
 	/* Turn off all power rails */
 	out = 0xff;
-	efx_i2c_write(i2c, PCA9539, P0_OUT, &out, 1);
+	(void) efx_i2c_write(i2c, PCA9539, P0_OUT, &out, 1);
 	/* Disable port 1 outputs on IO expander */
 	out = 0xff;
-	efx_i2c_write(i2c, PCA9539, P1_CONFIG, &out, 1);
+	(void) efx_i2c_write(i2c, PCA9539, P1_CONFIG, &out, 1);
 fail2:
 	/* Disable port 0 outputs on IO expander */
 	out = 0xff;
-	efx_i2c_write(i2c, PCA9539, P0_CONFIG, &out, 1);
+	(void) efx_i2c_write(i2c, PCA9539, P0_CONFIG, &out, 1);
 fail1:
 	return rc;
 }
Index: head-2008-06-18/drivers/net/sfc/spi.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/spi.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/spi.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005 Fen Systems Ltd.
- * Copyright 2006 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005:      Fen Systems Ltd.
+ * Copyright 2006:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_SPI_H
@@ -68,4 +85,102 @@
 /* Device busy flag */
 #define SPI_STATUS_NRDY 0x01
 
+/**************************************************************************
+ *
+ * Efx SPI devices
+ *
+ **************************************************************************
+ */
+
+/**
+ * struct efx_spi_device - an Efx SPI (Serial Peripheral Interface) device
+ * @device_id:		Controller's id for the device
+ * @size:		Size (in bytes)
+ * @addr_len:		Number of address bytes in read/write commands
+ * @munge_address:	Flag whether addresses should be munged.
+ *	Some devices with 9-bit addresses (e.g. AT25040A EEPROM)
+ *	use bit 3 of the command byte as address bit A8, rather
+ *	than having a two-byte address.  If this flag is set, then
+ *	commands should be munged in this way.
+ * @erase_command:	Erase command (or 0 if sector erase not needed).
+ * @erase_size:		Erase sector size (in bytes)
+ *	Erase commands affect sectors with this size and alignment.
+ *	This must be a power of two.
+ * @block_size:		Write block size (in bytes).
+ *	Write commands are limited to blocks with this size and alignment.
+ * @read:		Read function for the device
+ * @write:		Write function for the device
+ */
+struct efx_spi_device {
+	int device_id;
+	unsigned int size;
+	unsigned int addr_len;
+	unsigned int munge_address:1;
+	u8 erase_command;
+	unsigned int erase_size;
+	unsigned int block_size;
+	int (*read) (const struct efx_spi_device *spi,
+		     struct efx_nic *efx, unsigned int command,
+		     int address, void *data, unsigned int len);
+	int (*write) (const struct efx_spi_device *spi,
+		      struct efx_nic *efx, unsigned int command,
+		      int address, const void *data, unsigned int len);
+};
+
+/* Maximum length for SPI read or write through Falcon */
+#define FALCON_SPI_MAX_LEN 16U
+
+/**
+ * efx_spi_write_limit - calculate maximum permitted length for write
+ * @spi:		SPI device description
+ * @start:		Starting address
+ *
+ * Return the maximum length for a write starting at the given address
+ * in the device.
+ *
+ * SPI writes must not cross block boundaries.  Devices tend
+ * to wrap addresses at block boundaries; e.g. trying to write 5 bytes
+ * starting at offset 14 with a block size of 16 might write
+ * {14,15,0,1,2} rather than {14,15,16,17,18}.
+ */
+static inline unsigned int
+efx_spi_write_limit(const struct efx_spi_device *spi, unsigned int start)
+{
+	return min(FALCON_SPI_MAX_LEN,
+		   (spi->block_size - (start & (spi->block_size - 1))));
+}
+
+/**
+ * efx_spi_read_limit - calculate maximum permitted length for read
+ * @spi:		SPI device description
+ * @start:		Starting address
+ *
+ * Return the maximum length for a read starting at the given address
+ * in the device.
+ */
+static inline unsigned int
+efx_spi_read_limit(const struct efx_spi_device *spi __attribute__ ((unused)),
+		   unsigned int start __attribute__ ((unused)))
+{
+	return FALCON_SPI_MAX_LEN;
+}
+
+/**
+ * efx_spi_munge_command - adjust command as necessary for given address
+ * @spi:		SPI device description
+ * @command:		Normal SPI command
+ * @address:		Address for command
+ *
+ * Some devices with 9-bit addresses (e.g. AT25040A EEPROM) use bit 3
+ * of the command byte as address bit A8, rather than having a
+ * two-byte address.  This function calculates the appropriate command
+ * byte for the device, taking this munging into account.
+ */
+static inline u8 efx_spi_munge_command(const struct efx_spi_device *spi,
+					    const u8 command,
+					    const unsigned int address)
+{
+	return (command | (((address >> 8) & spi->munge_address) << 3));
+}
+
 #endif /* EFX_SPI_H */
Index: head-2008-06-18/drivers/net/sfc/tenxpress.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/tenxpress.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/tenxpress.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,22 +1,37 @@
 /****************************************************************************
  * Driver for Solarflare 802.3an compliant PHY
- * Copyright 2007 Solarflare Communications Inc.
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2007:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
- */
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************/
 
 #include <linux/delay.h>
 #include <linux/seq_file.h>
 #include "efx.h"
+#include "debugfs.h"
 #include "gmii.h"
 #include "mdio_10g.h"
 #include "falcon.h"
 #include "phy.h"
 #include "falcon_hwdefs.h"
 #include "boards.h"
-#include "mac.h"
 
 /* We expect these MMDs to be in the package */
 /* AN not here as mdio_check_mmds() requires STAT2 support */
@@ -34,15 +49,28 @@
  */
 #define MAX_BAD_LP_TRIES	(5)
 
+/* SNR operating margin register */
+#define PMA_PMD_SNR_MARGIN_0	(133)
+#define PMA_PMD_SNR_MARGIN_1	(134)
+#define PMA_PMD_SNR_MARGIN_2	(135)
+#define PMA_PMD_SNR_MARGIN_3	(136)
+
 /* Extended control register */
 #define	PMA_PMD_XCONTROL_REG 0xc000
 #define	PMA_PMD_LNPGA_POWERDOWN_LBN 8
 #define	PMA_PMD_LNPGA_POWERDOWN_WIDTH 1
+#define	PMA_PMD_AFE_POWERDOWN_LBN 9
+#define	PMA_PMD_AFE_POWERDOWN_WIDTH 1
+#define	PMA_PMD_DSP_POWERDOWN_LBN 10
+#define	PMA_PMD_DSP_POWERDOWN_WIDTH 1
+#define	PMA_PMD_PHY_POWERDOWN_LBN 11
+#define	PMA_PMD_PHY_POWERDOWN_WI
 
 /* extended status register */
 #define PMA_PMD_XSTATUS_REG 0xc001
 #define PMA_PMD_XSTAT_FLP_LBN   (12)
 
+
 /* LED control register */
 #define PMA_PMD_LED_CTRL_REG	(0xc007)
 #define PMA_PMA_LED_ACTIVITY_LBN	(3)
@@ -84,6 +112,19 @@
 #define BIST_MAX_DELAY	(1000)
 #define BIST_POLL_DELAY	(10)
 
+static const char *bist_names[] = {
+	[PMA_PMD_BIST_AFE_LBN] = "AFE communication",
+	[PMA_PMD_BIST_RXD_LBN] = "RX data path",
+	[PMA_PMD_BIST_PMA_LBN] = "PMA loopback",
+	[PMA_PMD_BIST_ENX_LBN] = "ENX"
+};
+
+/* Identifier registers: each identifier has 4 part number and 2 revision
+ * registers starting at one of these addresses */
+#define PMA_PMD_AFE_ID_REG      49174
+#define PMA_PMD_DSP_ID_REG      49180
+#define PMA_PMD_FIRMWARE_ID_REG 49186
+
 /* Misc register defines */
 #define PCS_CLOCK_CTRL_REG 0xd801
 #define PLL312_RST_N_LBN 2
@@ -106,22 +147,38 @@
 #define PCS_BOOT_PROGRESS_LBN	(1)
 #define PCS_BOOT_PROGRESS_WIDTH	(2)
 #define PCS_BOOT_COMPLETE_LBN	(3)
+
 #define PCS_BOOT_MAX_DELAY	(100)
 #define PCS_BOOT_POLL_DELAY	(10)
 
+#define TENXPRESS_ID_PN_LEN     (8)
+#define TENXPRESS_ID_REV_LEN    (4)
+#define TENXPRESS_ID_LEN        (TENXPRESS_ID_PN_LEN+1+TENXPRESS_ID_REV_LEN)
+
+static const int bist_max = ARRAY_SIZE(bist_names);
+
 /* Time to wait between powering down the LNPGA and turning off the power
  * rails */
 #define LNPGA_PDOWN_WAIT	(HZ / 5)
 
+
 static int crc_error_reset_threshold = 100;
 module_param(crc_error_reset_threshold, int, 0644);
 MODULE_PARM_DESC(crc_error_reset_threshold,
 		 "Max number of CRC errors before XAUI reset");
 
 struct tenxpress_phy_data {
+#ifdef CONFIG_SFC_DEBUGFS
+	char phy_snr[4];
+	char phy_afe_id[TENXPRESS_ID_LEN + 1];
+	char phy_dsp_id[TENXPRESS_ID_LEN + 1];
+	char phy_firmware_id[TENXPRESS_ID_LEN + 1];
+	struct efx_nic *efx;
+#endif
 	enum tenxpress_state state;
 	enum efx_loopback_mode loopback_mode;
 	atomic_t bad_crc_count;
+	int phy_powered;
 	int tx_disabled;
 	int bad_lp_tries;
 };
@@ -147,6 +204,110 @@ void tenxpress_crc_err(struct efx_nic *e
 		atomic_inc(&phy_data->bad_crc_count);
 }
 
+#ifdef CONFIG_SFC_DEBUGFS
+
+/* debugfs entries for this PHY */
+static int tenxpress_ber_read(struct seq_file *file, void *data)
+{
+	struct efx_nic *efx = *(struct efx_nic **)data;
+	int reg, ber;
+
+	reg = mdio_clause45_read(efx, efx->mii.phy_id, MDIO_MMD_PCS,
+				 MDIO_PCS_10GBT_STATUS2);
+
+	/* Extract the BER */
+	ber = (reg >> MDIO_PCS_10GBT_STATUS2_BER_LBN) &
+		((1 << MDIO_PCS_10GBT_STATUS2_BER_WIDTH) - 1);
+
+	return seq_printf(file, "%d", ber);
+}
+
+
+static int tenxpress_snr_read(struct seq_file *file, void *data)
+{
+	struct tenxpress_phy_data *phy_data = NULL;
+	struct efx_nic *efx;
+	int lane = *(char *) data;
+	int reg, snr;
+
+	EFX_BUG_ON_PARANOID(lane < 0 || lane >= 4);
+	phy_data = container_of(data, struct tenxpress_phy_data, phy_snr[lane]);
+	efx = phy_data->efx;
+
+	reg = mdio_clause45_read(efx, efx->mii.phy_id,
+				 MDIO_MMD_PMAPMD, PMA_PMD_SNR_MARGIN_0 + lane);
+
+	/* Convert from SNR margin to SNR to match phychk output */
+	snr = (reg - 0x8000 + 238);
+
+	return seq_printf(file, "%d.%d", snr / 10, snr % 10);
+}
+
+
+static struct efx_debugfs_parameter debug_entries[] = {
+	EFX_PER_LANE_PARAMETER("phy_lane", "_snr",
+			       struct tenxpress_phy_data, phy_snr, char,
+			       tenxpress_snr_read),
+	EFX_NAMED_PARAMETER(phy_ber, struct tenxpress_phy_data, efx,
+			    struct efx_nic *, tenxpress_ber_read),
+	EFX_STRING_PARAMETER(struct tenxpress_phy_data, phy_afe_id),
+	EFX_STRING_PARAMETER(struct tenxpress_phy_data, phy_dsp_id),
+	EFX_STRING_PARAMETER(struct tenxpress_phy_data, phy_firmware_id),
+	{NULL}
+};
+
+static void tenxpress_phy_get_id(struct efx_nic *efx,
+				 char *id_buf, int id_addr)
+{
+	int i, reg;
+	char ch;
+
+	for (i = TENXPRESS_ID_PN_LEN / 2 - 1; i >= 0; --i) {
+		reg = mdio_clause45_read(efx, efx->mii.phy_id,
+					 MDIO_MMD_PMAPMD, id_addr + i);
+		ch = reg & 0xFF;
+		*id_buf++ = ch ? ch : ' ';
+		ch = (reg & 0xFF00) >> 8;
+		*id_buf++ = ch ? ch : ' ';
+	}
+	*id_buf++ = ' ';
+	for (i = TENXPRESS_ID_REV_LEN / 2 - 1; i >= 0; --i) {
+		reg = mdio_clause45_read(efx, efx->mii.phy_id,
+					 MDIO_MMD_PMAPMD,
+					 id_addr + TENXPRESS_ID_PN_LEN / 2 + i);
+		ch = reg & 0xFF;
+		*id_buf++ = ch ? ch : ' ';
+		ch = (reg & 0xFF00) >> 8;
+		*id_buf++ = ch ? ch : ' ';
+	}
+}
+
+static int tenxpress_debugfs_init(struct efx_nic *efx)
+{
+	struct tenxpress_phy_data *phy_data = efx->phy_data;
+	int lane, rc;
+
+	for (lane = 0; lane < 4; lane++)
+		phy_data->phy_snr[lane] = lane;
+
+	phy_data->efx = efx;
+	rc = efx_extend_debugfs_port(efx, efx->phy_data,
+				     debug_entries);
+	if (rc < 0)
+		return rc;
+
+	tenxpress_phy_get_id(efx, phy_data->phy_afe_id,
+			     PMA_PMD_AFE_ID_REG);
+	tenxpress_phy_get_id(efx, phy_data->phy_dsp_id,
+			     PMA_PMD_DSP_ID_REG);
+	tenxpress_phy_get_id(efx, phy_data->phy_firmware_id,
+			     PMA_PMD_FIRMWARE_ID_REG);
+
+	return 0;
+}
+
+#endif /* CONFIG_SFC_DEBUGFS */
+
 /* Check that the C166 has booted successfully */
 static int tenxpress_phy_check(struct efx_nic *efx)
 {
@@ -178,6 +339,7 @@ static int tenxpress_phy_check(struct ef
 
 static void tenxpress_reset_xaui(struct efx_nic *efx);
 
+/* Initialise the part post power on reset or software special reset */
 static int tenxpress_init(struct efx_nic *efx)
 {
 	int rc, reg;
@@ -211,18 +373,15 @@ static int tenxpress_phy_init(struct efx
 	int rc = 0;
 
 	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
-	if (!phy_data)
-		return -ENOMEM;
 	efx->phy_data = phy_data;
+	phy_data->phy_powered = efx->phy_powered;
 
 	tenxpress_set_state(efx, TENXPRESS_STATUS_NORMAL);
 
-	if (!sfe4001_phy_flash_cfg) {
-		rc = mdio_clause45_wait_reset_mmds(efx,
-						   TENXPRESS_REQUIRED_DEVS);
-		if (rc < 0)
-			goto fail;
-	}
+	rc = mdio_clause45_wait_reset_mmds(efx,
+					   TENXPRESS_REQUIRED_DEVS);
+	if (rc < 0)
+		goto fail;
 
 	rc = mdio_clause45_check_mmds(efx, TENXPRESS_REQUIRED_DEVS, 0);
 	if (rc < 0)
@@ -232,6 +391,12 @@ static int tenxpress_phy_init(struct efx
 	if (rc < 0)
 		goto fail;
 
+#ifdef CONFIG_SFC_DEBUGFS
+	rc = tenxpress_debugfs_init(efx);
+	if (rc < 0)
+		goto fail;
+#endif
+
 	schedule_timeout_uninterruptible(HZ / 5); /* 200ms */
 
 	/* Let XGXS and SerDes out of reset and resets 10XPress */
@@ -376,18 +541,20 @@ static void tenxpress_phy_reconfigure(st
 	/* When coming out of transmit disable, coming out of low power
 	 * mode, or moving out of any PHY internal loopback mode,
 	 * perform a special software reset */
-	if ((phy_data->tx_disabled && !efx->tx_disabled) ||
+	if (((efx->phy_powered && !efx->tx_disabled) &&
+	     (!phy_data->phy_powered || phy_data->tx_disabled)) ||
 	    loop_change) {
-		tenxpress_special_reset(efx);
+		(void) tenxpress_special_reset(efx);
 		falcon_reset_xaui(efx);
 	}
 
-	mdio_clause45_transmit_disable(efx);
+	mdio_clause45_transmit_disable(efx, efx->tx_disabled);
 	mdio_clause45_phy_reconfigure(efx);
 	tenxpress_phyxs_loopback(efx);
 
 	phy_data->tx_disabled = efx->tx_disabled;
 	phy_data->loopback_mode = efx->loopback_mode;
+	phy_data->phy_powered = efx->phy_powered;
 	efx->link_up = tenxpress_link_ok(efx, 0);
 	efx->link_options = GM_LPA_10000FULL;
 }
@@ -403,12 +570,12 @@ static int tenxpress_phy_check_hw(struct
 {
 	struct tenxpress_phy_data *phy_data = efx->phy_data;
 	int phy_up = tenxpress_state_is(efx, TENXPRESS_STATUS_NORMAL);
-	int link_ok;
+	int link_ok, rc = 0;
 
 	link_ok = phy_up && tenxpress_link_ok(efx, 1);
 
 	if (link_ok != efx->link_up)
-		falcon_xmac_sim_phy_event(efx);
+		efx->mac_op->fake_phy_event(efx);
 
 	/* Nothing to check if we've already shut down the PHY */
 	if (!phy_up)
@@ -420,13 +587,20 @@ static int tenxpress_phy_check_hw(struct
 		atomic_set(&phy_data->bad_crc_count, 0);
 	}
 
-	return 0;
+	rc = efx->board_info.monitor(efx);
+	if (rc)
+		efx->link_up = 0;
+
+	return rc;
 }
 
 static void tenxpress_phy_fini(struct efx_nic *efx)
 {
 	int reg;
 
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_trim_debugfs_port(efx, debug_entries);
+#endif
 	/* Power down the LNPGA */
 	reg = (1 << PMA_PMD_LNPGA_POWERDOWN_LBN);
 	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PMAPMD,
@@ -507,6 +681,7 @@ static void tenxpress_reset_xaui(struct 
 	udelay(10);
 }
 
+
 struct efx_phy_operations falcon_tenxpress_phy_ops = {
 	.init             = tenxpress_phy_init,
 	.reconfigure      = tenxpress_phy_reconfigure,
@@ -516,4 +691,5 @@ struct efx_phy_operations falcon_tenxpre
 	.reset_xaui       = tenxpress_reset_xaui,
 	.mmds             = TENXPRESS_REQUIRED_DEVS,
 	.loopbacks        = TENXPRESS_LOOPBACKS,
+	.startup_loopback = LOOPBACK_PCS,
 };
Index: head-2008-06-18/drivers/net/sfc/tx.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/tx.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/tx.c	2008-06-18 15:45:25.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2005-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #include <linux/pci.h>
@@ -20,6 +37,7 @@
 #include "falcon.h"
 #include "workarounds.h"
 
+
 /*
  * TX descriptor ring full threshold
  *
@@ -29,6 +47,8 @@
 #define EFX_NETDEV_TX_THRESHOLD(_tx_queue)	\
 	(_tx_queue->efx->type->txd_ring_mask / 2u)
 
+
+
 /* We want to be able to nest calls to netif_stop_queue(), since each
  * channel can have an individual stop on the queue.
  */
@@ -82,46 +102,6 @@ static inline void efx_dequeue_buffer(st
 	}
 }
 
-/**
- * struct efx_tso_header - a DMA mapped buffer for packet headers
- * @next: Linked list of free ones.
- *	The list is protected by the TX queue lock.
- * @dma_unmap_len: Length to unmap for an oversize buffer, or 0.
- * @dma_addr: The DMA address of the header below.
- *
- * This controls the memory used for a TSO header.  Use TSOH_DATA()
- * to find the packet header data.  Use TSOH_SIZE() to calculate the
- * total size required for a given packet header length.  TSO headers
- * in the free list are exactly %TSOH_STD_SIZE bytes in size.
- */
-struct efx_tso_header {
-	union {
-		struct efx_tso_header *next;
-		size_t unmap_len;
-	};
-	dma_addr_t dma_addr;
-};
-
-static int efx_enqueue_skb_tso(struct efx_tx_queue *tx_queue,
-			       const struct sk_buff *skb);
-static void efx_fini_tso(struct efx_tx_queue *tx_queue);
-static void efx_tsoh_heap_free(struct efx_tx_queue *tx_queue,
-			       struct efx_tso_header *tsoh);
-
-static inline void efx_tsoh_free(struct efx_tx_queue *tx_queue,
-				 struct efx_tx_buffer *buffer)
-{
-	if (buffer->tsoh) {
-		if (likely(!buffer->tsoh->unmap_len)) {
-			buffer->tsoh->next = tx_queue->tso_headers_free;
-			tx_queue->tso_headers_free = buffer->tsoh;
-		} else {
-			efx_tsoh_heap_free(tx_queue, buffer->tsoh);
-		}
-		buffer->tsoh = NULL;
-	}
-}
-
 
 /*
  * Add a socket buffer to a TX queue
@@ -156,7 +136,6 @@ static inline int efx_enqueue_skb(struct
 
 	if (skb_shinfo((struct sk_buff *)skb)->gso_size)
 		return efx_enqueue_skb_tso(tx_queue, skb);
-
 	/* Get size of the initial fragment */
 	len = skb_headlen(skb);
 
@@ -273,6 +252,7 @@ static inline int efx_enqueue_skb(struct
  stop:
 	rc = NETDEV_TX_BUSY;
 
+	/* Stop the queue if it wasn't stopped before. */
 	if (tx_queue->stopped == 1)
 		efx_stop_queue(efx);
 
@@ -315,6 +295,7 @@ static inline void efx_dequeue_buffers(s
 			EFX_ERR(tx_queue->efx, "TX queue %d spurious TX "
 				"completion id %x\n", tx_queue->queue,
 				read_ptr);
+			atomic_inc(&efx->errors.spurious_tx);
 			efx_schedule_reset(efx, RESET_TYPE_TX_SKIP);
 			return;
 		}
@@ -368,7 +349,27 @@ inline int efx_xmit(struct efx_nic *efx,
 int efx_hard_start_xmit(struct sk_buff *skb, struct net_device *net_dev)
 {
 	struct efx_nic *efx = net_dev->priv;
-	return efx_xmit(efx, &efx->tx_queue[0], skb);
+	struct efx_tx_queue *tx_queue;
+	enum efx_veto veto;
+	int rc = NETDEV_TX_OK;
+
+	/* We have one TX queue. */
+	tx_queue = &efx->tx_queue[0];
+
+	/* See if driverlink wants to veto the packet. */
+	veto = EFX_DL_CALLBACK(efx, tx_packet, skb);
+	if (unlikely(veto)) {
+		EFX_LOG(efx, "TX queue %d packet vetoed by "
+			"driverlink %s driver\n", tx_queue->queue,
+			efx->dl_cb_dev.tx_packet->driver->name);
+		/* Free the skb; nothing else will do it */
+		dev_kfree_skb_any((struct sk_buff *)skb);
+		goto out;
+	}
+
+	rc = efx_xmit(efx, tx_queue, skb);
+out:
+	return rc;
 }
 
 void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index)
@@ -378,6 +379,7 @@ void efx_xmit_done(struct efx_tx_queue *
 
 	EFX_BUG_ON_PARANOID(index > efx->type->txd_ring_mask);
 
+	/* Remove buffers from TX queue */
 	efx_dequeue_buffers(tx_queue, index);
 
 	/* See if we need to restart the netif queue.  This barrier
@@ -430,6 +432,7 @@ int efx_probe_tx_queue(struct efx_tx_que
 	kfree(tx_queue->buffer);
 	tx_queue->buffer = NULL;
  fail1:
+	/* Mark queue as unused */
 	tx_queue->used = 0;
 
 	return rc;
@@ -439,6 +442,7 @@ int efx_init_tx_queue(struct efx_tx_queu
 {
 	EFX_LOG(tx_queue->efx, "initialising TX queue %d\n", tx_queue->queue);
 
+	/* Initialise fields */
 	tx_queue->insert_count = 0;
 	tx_queue->write_count = 0;
 	tx_queue->read_count = 0;
@@ -475,6 +479,7 @@ void efx_fini_tx_queue(struct efx_tx_que
 	/* Flush TX queue, remove descriptor ring */
 	falcon_fini_tx(tx_queue);
 
+	/* Release TX buffers */
 	efx_release_tx_buffers(tx_queue);
 
 	/* Free up TSO header cache */
@@ -531,27 +536,27 @@ void efx_remove_tx_queue(struct efx_tx_q
 #define SKB_TCP_OFF(skb)  PTR_DIFF(tcp_hdr(skb), (skb)->data)
 #define SKB_IPV4_OFF(skb) PTR_DIFF(ip_hdr(skb), (skb)->data)
 
-/**
- * struct tso_state - TSO state for an SKB
- * @remaining_len: Bytes of data we've yet to segment
- * @seqnum: Current sequence number
- * @packet_space: Remaining space in current packet
- * @ifc: Input fragment cursor.
- *	Where we are in the current fragment of the incoming SKB.  These
- *	values get updated in place when we split a fragment over
- *	multiple packets.
- * @p: Parameters.
- *	These values are set once at the start of the TSO send and do
- *	not get changed as the routine progresses.
+/* TSO State.
  *
  * The state used during segmentation.  It is put into this data structure
  * just to make it easy to pass into inline functions.
  */
 struct tso_state {
+	/* Bytes of data we've yet to segment */
 	unsigned remaining_len;
+
+	/* Current sequence number */
 	unsigned seqnum;
+
+	/* Remaining space in current packet */
 	unsigned packet_space;
 
+	/* Input fragment cursor.
+	 *
+	 * Where we are in the current fragment of the incoming SKB.  These
+	 * values get updated in place when we split a fragment over
+	 * multiple packets.
+	 */
 	struct {
 		/* DMA address of current position */
 		dma_addr_t dma_addr;
@@ -564,6 +569,11 @@ struct tso_state {
 		unsigned page_off;
 	} ifc;
 
+	/* Parameters.
+	 *
+	 * These values are set once at the start of the TSO send and do
+	 * not get changed as the routine progresses.
+	 */
 	struct {
 		/* The number of bytes of header */
 		unsigned int header_length;
@@ -639,12 +649,11 @@ static void efx_tsoh_block_free(struct e
 	base_dma = tsoh->dma_addr & PAGE_MASK;
 
 	p = &tx_queue->tso_headers_free;
-	while (*p != NULL) {
+	while (*p != NULL)
 		if (((unsigned long)*p & PAGE_MASK) == base_kva)
 			*p = (*p)->next;
 		else
 			p = &(*p)->next;
-	}
 
 	pci_free_consistent(pci_dev, PAGE_SIZE, (void *)base_kva, base_dma);
 }
@@ -670,7 +679,7 @@ efx_tsoh_heap_alloc(struct efx_tx_queue 
 	return tsoh;
 }
 
-static void
+void
 efx_tsoh_heap_free(struct efx_tx_queue *tx_queue, struct efx_tso_header *tsoh)
 {
 	pci_unmap_single(tx_queue->efx->pci_dev,
@@ -940,10 +949,9 @@ static inline int tso_start_new_packet(s
 
 	/* Allocate a DMA-mapped header buffer. */
 	if (likely(TSOH_SIZE(st->p.header_length) <= TSOH_STD_SIZE)) {
-		if (tx_queue->tso_headers_free == NULL) {
+		if (tx_queue->tso_headers_free == NULL)
 			if (efx_tsoh_block_alloc(tx_queue))
 				return -1;
-		}
 		EFX_BUG_ON_PARANOID(!tx_queue->tso_headers_free);
 		tsoh = tx_queue->tso_headers_free;
 		tx_queue->tso_headers_free = tsoh->next;
@@ -1003,8 +1011,8 @@ static inline int tso_start_new_packet(s
  * @skb was not enqueued.  In all cases @skb is consumed.  Return
  * %NETDEV_TX_OK or %NETDEV_TX_BUSY.
  */
-static int efx_enqueue_skb_tso(struct efx_tx_queue *tx_queue,
-			       const struct sk_buff *skb)
+int efx_enqueue_skb_tso(struct efx_tx_queue *tx_queue,
+			const struct sk_buff *skb)
 {
 	int frag_i, rc, rc2 = NETDEV_TX_OK;
 	struct tso_state state;
@@ -1104,16 +1112,17 @@ static int efx_enqueue_skb_tso(struct ef
  * routine should be called only once the tx_queue is both empty and
  * will no longer be used.
  */
-static void efx_fini_tso(struct efx_tx_queue *tx_queue)
+void efx_fini_tso(struct efx_tx_queue *tx_queue)
 {
 	unsigned i;
 
-	if (tx_queue->buffer) {
+	if (tx_queue->buffer)
 		for (i = 0; i <= tx_queue->efx->type->txd_ring_mask; ++i)
 			efx_tsoh_free(tx_queue, &tx_queue->buffer[i]);
-	}
 
 	while (tx_queue->tso_headers_free != NULL)
 		efx_tsoh_block_free(tx_queue, tx_queue->tso_headers_free,
 				    tx_queue->efx->pci_dev);
 }
+
+
Index: head-2008-06-18/drivers/net/sfc/tx.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/tx.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/tx.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,11 +1,28 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006:      Fen Systems Ltd.
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_TX_H
@@ -21,4 +38,44 @@ void efx_fini_tx_queue(struct efx_tx_que
 int efx_hard_start_xmit(struct sk_buff *skb, struct net_device *net_dev);
 void efx_release_tx_buffers(struct efx_tx_queue *tx_queue);
 
+/**
+ * struct efx_tso_header - a DMA mapped buffer for packet headers
+ * @next: Linked list of free ones.
+ *	The list is protected by the TX queue lock.
+ * @dma_unmap_len: Length to unmap for an oversize buffer, or 0.
+ * @dma_addr: The DMA address of the header below.
+ *
+ * This controls the memory used for a TSO header.  Use TSOH_DATA()
+ * to find the packet header data.  Use TSOH_SIZE() to calculate the
+ * total size required for a given packet header length.  TSO headers
+ * in the free list are exactly %TSOH_STD_SIZE bytes in size.
+ */
+struct efx_tso_header {
+	union {
+		struct efx_tso_header *next;
+		size_t unmap_len;
+	};
+	dma_addr_t dma_addr;
+};
+
+extern int efx_enqueue_skb_tso(struct efx_tx_queue *tx_queue,
+			       const struct sk_buff *skb);
+extern void efx_fini_tso(struct efx_tx_queue *tx_queue);
+extern void efx_tsoh_heap_free(struct efx_tx_queue *tx_queue,
+			       struct efx_tso_header *tsoh);
+
+static inline void efx_tsoh_free(struct efx_tx_queue *tx_queue,
+				 struct efx_tx_buffer *buffer)
+{
+	if (buffer->tsoh) {
+		if (likely(!buffer->tsoh->unmap_len)) {
+			buffer->tsoh->next = tx_queue->tso_headers_free;
+			tx_queue->tso_headers_free = buffer->tsoh;
+		} else {
+			efx_tsoh_heap_free(tx_queue, buffer->tsoh);
+		}
+		buffer->tsoh = NULL;
+	}
+}
+
 #endif /* EFX_TX_H */
Index: head-2008-06-18/drivers/net/sfc/txc43128_phy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ head-2008-06-18/drivers/net/sfc/txc43128_phy.c	2008-05-08 14:22:11.000000000 +0200
@@ -0,0 +1,724 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+/*
+ * Driver for Transwitch/Mysticom CX4 retimer
+ * see www.transwitch.com, part is TXC-43128
+ */
+
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include "efx.h"
+#include "debugfs.h"
+#include "gmii.h"
+#include "mdio_10g.h"
+#include "xenpack.h"
+#include "phy.h"
+#include "lm87_support.h"
+#include "falcon.h"
+#include "workarounds.h"
+
+/* We expect these MMDs to be in the package */
+#define TXC_REQUIRED_DEVS (MDIO_MMDREG_DEVS0_PCS |	\
+			   MDIO_MMDREG_DEVS0_PMAPMD |	\
+			   MDIO_MMDREG_DEVS0_PHYXS)
+
+#define TXC_LOOPBACKS ((1 << LOOPBACK_PCS) |		\
+		       (1 << LOOPBACK_PMAPMD) |		\
+		       (1 << LOOPBACK_NETWORK))
+
+/**************************************************************************
+ *
+ * Compile-time config
+ *
+ **************************************************************************
+ */
+#define TXCNAME "TXC43128"
+/* Total length of time we'll wait for the PHY to come out of reset */
+#define TXC_MAX_RESET_TIME 500
+/* Interval between checks */
+#define TXC_RESET_WAIT 10
+/* How long to run BIST: At 10Gbps 50 microseconds should be plenty to get
+ * some stats */
+#define TXC_BIST_DURATION (50)
+
+#define BER_INTERVAL (10 * efx_monitor_interval)
+
+/**************************************************************************
+ *
+ * Register definitions
+ *
+ **************************************************************************
+ */
+#define XAUI_NUM_LANES (4)
+
+/*** Global register bank */
+/* Silicon ID register */
+#define TXC_GLRGS_SLID		(0xc000)
+#define TXC_GLRGS_SLID_MASK	(0x1f)
+
+/* Command register */
+#define TXC_GLRGS_GLCMD		(0xc004)
+/* Useful bits in command register */
+/* Lane power-down */
+#define TXC_GLCMD_L01PD_LBN	(5)
+#define TXC_GLCMD_L23PD_LBN	(6)
+/* Limited SW reset: preserves configuration but
+ * initiates a logic reset. Self-clearing */
+#define TXC_GLCMD_LMTSWRST_LBN	(14)
+
+/* Signal Quality Control */
+#define TXC_GLRGS_GSGQLCTL	(0xc01a)
+/* Enable bit */
+#define TXC_GSGQLCT_SGQLEN_LBN	(15)
+/* Lane selection */
+#define TXC_GSGQLCT_LNSL_LBN	(13)
+#define TXC_GSGQLCT_LNSL_WIDTH	(2)
+
+/* Signal Quality Input */
+#define TXC_GLRGS_GSGQLIN	(0xc01b)
+/*  Signal Quality Grade */
+#define TXC_GLRGS_GSGQLGRD	(0xc01c)
+/* Drift sign */
+#define TXC_GSGQLGRD_DRFTSGN_LBN (15)
+/* Grade valid flag */
+#define TXC_GSGQLGRD_GRDVAL_LBN	(14)
+/* Remaining bits are the actual grade */
+#define TXC_GSGQLGRD_GRADE_LBN	(0)
+#define TXC_GSGQLGRD_GRADE_WIDTH (14)
+
+/*  Signal Quality Drift: 16-bit drift value */
+#define TXC_GLRGS_GSGQLDRFT	(0xc01d)
+
+/**** Analog register bank */
+#define TXC_ALRGS_ATXCTL	(0xc040)
+/* Lane power-down */
+#define TXC_ATXCTL_TXPD3_LBN	(15)
+#define TXC_ATXCTL_TXPD2_LBN	(14)
+#define TXC_ATXCTL_TXPD1_LBN	(13)
+#define TXC_ATXCTL_TXPD0_LBN	(12)
+
+/* Amplitude on lanes 0, 1 */
+#define  TXC_ALRGS_ATXAMP0	(0xc041)
+/* Amplitude on lanes 2, 3 */
+#define  TXC_ALRGS_ATXAMP1	(0xc042)
+/* Bit position of value for lane 0 (or 2) */
+#define TXC_ATXAMP_LANE02_LBN	(3)
+/* Bit position of value for lane 1 (or 3) */
+#define TXC_ATXAMP_LANE13_LBN	(11)
+
+#define TXC_ATXAMP_1280_mV	(0)
+#define TXC_ATXAMP_1200_mV	(8)
+#define TXC_ATXAMP_1120_mV	(12)
+#define TXC_ATXAMP_1060_mV	(14)
+#define TXC_ATXAMP_0820_mV	(25)
+#define TXC_ATXAMP_0720_mV	(26)
+#define TXC_ATXAMP_0580_mV	(27)
+#define TXC_ATXAMP_0440_mV	(28)
+
+#define TXC_ATXAMP_0820_BOTH					\
+	((TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE02_LBN)		\
+	 | (TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE13_LBN))
+
+#define TXC_ATXAMP_DEFAULT	(0x6060) /* From databook */
+
+/* Preemphasis on lanes 0, 1 */
+#define  TXC_ALRGS_ATXPRE0	(0xc043)
+/* Preemphasis on lanes 2, 3 */
+#define  TXC_ALRGS_ATXPRE1	(0xc044)
+
+#define TXC_ATXPRE_NONE (0)
+#define TXC_ATXPRE_DEFAULT	(0x1010) /* From databook */
+
+#define TXC_ALRGS_ARXCTL	(0xc045)
+/* Lane power-down */
+#define TXC_ARXCTL_RXPD3_LBN	(15)
+#define TXC_ARXCTL_RXPD2_LBN	(14)
+#define TXC_ARXCTL_RXPD1_LBN	(13)
+#define TXC_ARXCTL_RXPD0_LBN	(12)
+
+/*** receiver control registers: Bit Error Rate measurement */
+/* Per lane BER timers */
+#define TXC_RXCTL_BERTMR0	(0xc0d4)
+#define TXC_RXCTL_BERTMR1	(0xc154)
+#define TXC_RXCTL_BERTMR2	(0xc1d4)
+#define TXC_RXCTL_BERTMR3	(0xc254)
+/* Per lane BER counters */
+#define TXC_RXCTL_BERCNT0	(0xc0d5)
+#define TXC_RXCTL_BERCNT1	(0xc155)
+#define TXC_RXCTL_BERCNT2	(0xc1d5)
+#define TXC_RXCTL_BERCNT3	(0xc255)
+
+#define BER_REG_SPACING	(TXC_RXCTL_BERTMR1 - TXC_RXCTL_BERTMR0)
+
+/*** Main user-defined register set */
+/* Main control */
+#define TXC_MRGS_CTL		(0xc340)
+/* Bits in main control */
+#define TXC_MCTL_RESET_LBN	(15)	/* Self clear */
+#define TXC_MCTL_TXLED_LBN	(14)	/* 1 to show align status */
+#define TXC_MCTL_RXLED_LBN	(13)	/* 1 to show align status */
+
+/* GPIO output */
+#define TXC_GPIO_OUTPUT		(0xc346)
+#define TXC_GPIO_DIR		(0xc348)
+
+/*** Vendor-specific BIST registers */
+#define TXC_BIST_CTL		(0xc280)
+#define TXC_BIST_TXFRMCNT	(0xc281)
+#define TXC_BIST_RX0FRMCNT	(0xc282)
+#define TXC_BIST_RX1FRMCNT	(0xc283)
+#define TXC_BIST_RX2FRMCNT	(0xc284)
+#define TXC_BIST_RX3FRMCNT	(0xc285)
+#define TXC_BIST_RX0ERRCNT	(0xc286)
+#define TXC_BIST_RX1ERRCNT	(0xc287)
+#define TXC_BIST_RX2ERRCNT	(0xc288)
+#define TXC_BIST_RX3ERRCNT	(0xc289)
+
+/*** BIST control bits */
+/* BIST type (controls bit patter in test) */
+#define TXC_BIST_CTRL_TYPE_LBN	(10)
+#define	TXC_BIST_CTRL_TYPE_TSD	(0)	/* TranSwitch Deterministic */
+#define TXC_BIST_CTRL_TYPE_CRP	(1)	/* CRPAT standard */
+#define TXC_BIST_CTRL_TYPE_CJP	(2)	/* CJPAT standard */
+#define TXC_BIST_CTRL_TYPE_TSR	(3)	/* TranSwitch pseudo-random */
+/* Set this to 1 for 10 bit and 0 for 8 bit */
+#define TXC_BIST_CTRL_B10EN_LBN	(12)
+/* Enable BIST (write 0 to disable) */
+#define	TXC_BIST_CTRL_ENAB_LBN	(13)
+/*Stop BIST (self-clears when stop complete) */
+#define  TXC_BIST_CTRL_STOP_LBN	(14)
+/* Start BIST (cleared by writing 1 to STOP) */
+#define  TXC_BIST_CTRL_STRT_LBN	(15)
+
+/* Mt. Diablo test configuration */
+#define TXC_MTDIABLO_CTRL	(0xc34f)
+#define TXC_MTDIABLO_CTRL_PMA_LOOP_LBN	(10)
+
+struct txc43128_data {
+#ifdef CONFIG_SFC_DEBUGFS
+	/* BER stats update from check_hw. Note that this is in errors/second,
+	 * converting it to errors/bit is left as an exercise for user-space.
+	 */
+	unsigned phy_ber_pcs[4];
+	unsigned phy_ber_phyxs[4];
+#endif
+	unsigned bug10934_timer;
+	int phy_powered;
+	int tx_disabled;
+	enum efx_loopback_mode loopback_mode;
+};
+
+/* Perform the bug 10934 workaround every 5s */
+#define BUG10934_RESET_INTERVAL (5 * HZ)
+
+
+/* Perform a reset that doesn't clear configuration changes */
+static void txc_reset_logic(struct efx_nic *efx);
+
+/* Set the output value of a gpio */
+void txc_set_gpio_val(struct efx_nic *efx, int pin, int on)
+{
+	int outputs;
+
+	outputs = mdio_clause45_read(efx, efx->mii.phy_id,
+					MDIO_MMD_PHYXS, TXC_GPIO_OUTPUT);
+
+	outputs = (outputs & ~(1 << pin)) | (on << pin);
+
+	mdio_clause45_write(efx, efx->mii.phy_id,
+					MDIO_MMD_PHYXS, TXC_GPIO_OUTPUT,
+					outputs);
+}
+
+/* Set up the GPIO direction register */
+void txc_set_gpio_dir(struct efx_nic *efx, int pin, int dir)
+{
+	int dirs;
+
+	if (efx->board_info.minor < 3 &&
+		   efx->board_info.major == 0)
+		return;
+
+	dirs = mdio_clause45_read(efx, efx->mii.phy_id,
+			    MDIO_MMD_PHYXS, TXC_GPIO_DIR);
+	dirs = (dir & ~(1 << pin)) | (dir << pin);
+	mdio_clause45_write(efx, efx->mii.phy_id,
+			    MDIO_MMD_PHYXS, TXC_GPIO_DIR, dirs);
+
+}
+
+/* Reset the PMA/PMD MMD. The documentation is explicit that this does a
+ * global reset (it's less clear what reset of other MMDs does).*/
+static int txc_reset_phy(struct efx_nic *efx)
+{
+	int rc = mdio_clause45_reset_mmd(efx, MDIO_MMD_PMAPMD,
+					 TXC_MAX_RESET_TIME / TXC_RESET_WAIT,
+					 TXC_RESET_WAIT);
+	if (rc < 0)
+		goto fail;
+
+	/* Check that all the MMDs we expect are present and responding. We
+	 * expect faults on some if the link is down, but not on the PHY XS */
+	rc = mdio_clause45_check_mmds(efx, TXC_REQUIRED_DEVS, 0);
+	if (rc < 0)
+		goto fail;
+
+	return 0;
+
+ fail:
+	EFX_ERR(efx, TXCNAME ": reset timed out!\n");
+	return rc;
+}
+
+/* Run a single BIST on one MMD*/
+static int txc_bist_one(struct efx_nic *efx, int mmd, int test)
+{
+	int phy = efx->mii.phy_id;
+	int ctrl, bctl;
+	int lane;
+	int rc = 0;
+
+	EFX_INFO(efx, "" TXCNAME ": running BIST on %s MMD\n",
+		 mdio_clause45_mmd_name(mmd));
+
+	/* Set PMA to test into loopback using Mt Diablo reg as per app note */
+	ctrl = mdio_clause45_read(efx, phy, MDIO_MMD_PCS,
+				  TXC_MTDIABLO_CTRL);
+	ctrl |= (1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);
+	mdio_clause45_write(efx, phy, MDIO_MMD_PCS,
+			    TXC_MTDIABLO_CTRL, ctrl);
+
+
+	/* The BIST app. note lists these  as 3 distinct steps. */
+	/* Set the BIST type */
+	bctl = (test << TXC_BIST_CTRL_TYPE_LBN);
+	mdio_clause45_write(efx, phy, mmd, TXC_BIST_CTL, bctl);
+
+	/* Set the BSTEN bit in the BIST Control register to enable */
+	bctl |= (1 << TXC_BIST_CTRL_ENAB_LBN);
+	mdio_clause45_write(efx, phy, mmd, TXC_BIST_CTL, bctl);
+
+	/* Set the BSTRT bit in the BIST Control register */
+	mdio_clause45_write(efx, phy, mmd, TXC_BIST_CTL, bctl |
+			    (1 << TXC_BIST_CTRL_STRT_LBN));
+
+	/* Wait. */
+	udelay(TXC_BIST_DURATION);
+
+	/* Set the BSTOP bit in the BIST Control register */
+	bctl |= (1 << TXC_BIST_CTRL_STOP_LBN);
+	mdio_clause45_write(efx, phy, mmd, TXC_BIST_CTL, bctl);
+
+	/* The STOP bit should go off when things have stopped */
+	while (bctl & (1 << TXC_BIST_CTRL_STOP_LBN))
+		bctl = mdio_clause45_read(efx, phy, mmd, TXC_BIST_CTL);
+
+	/* Check all the error counts are 0 and all the frame counts are
+	   non-zero */
+	for (lane = 0; lane < 4; lane++) {
+		int count = mdio_clause45_read(efx, phy, mmd,
+					       TXC_BIST_RX0ERRCNT + lane);
+		if (count != 0) {
+			EFX_ERR(efx, ""TXCNAME": BIST error. "
+				"Lane %d had %d errs\n", lane, count);
+			rc = -EIO;
+		}
+		count = mdio_clause45_read(efx, phy, mmd,
+					   TXC_BIST_RX0FRMCNT + lane);
+		if (count == 0) {
+			EFX_ERR(efx, ""TXCNAME": BIST error. "
+				"Lane %d got 0 frames\n", lane);
+			rc = -EIO;
+		}
+	}
+
+	if (rc == 0)
+		EFX_INFO(efx, ""TXCNAME": BIST pass\n");
+
+	/* Disable BIST */
+	mdio_clause45_write(efx, phy, mmd, TXC_BIST_CTL, 0);
+
+	/* Turn off loopback */
+	ctrl &= ~(1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);
+	mdio_clause45_write(efx, phy, MDIO_MMD_PCS,
+			    TXC_MTDIABLO_CTRL, ctrl);
+
+	return rc;
+}
+
+/* Run all the desired BIST tests for the PHY */
+static int txc_bist(struct efx_nic *efx)
+{
+	int rc;
+	/*!\todo: experiment with running more of the BIST patterns to
+	 * see if it actually shows up more problems. */
+	rc = txc_bist_one(efx, MDIO_MMD_PCS, TXC_BIST_CTRL_TYPE_TSD);
+	return rc;
+}
+
+#ifdef CONFIG_SFC_DEBUGFS
+
+/* debugfs entries for this PHY */
+static struct efx_debugfs_parameter debug_entries[] = {
+	EFX_PER_LANE_PARAMETER("phy_ber_lane", "_pcs",
+			       struct txc43128_data, phy_ber_pcs,
+			       unsigned, efx_debugfs_read_uint),
+	EFX_PER_LANE_PARAMETER("phy_ber_lane", "_phyxs",
+			       struct txc43128_data, phy_ber_phyxs,
+			       unsigned, efx_debugfs_read_uint),
+	EFX_INT_PARAMETER(struct txc43128_data, phy_powered),
+	{NULL}
+};
+
+#endif /* CONFIG_SFC_DEBUGFS */
+
+/* Push the non-configurable defaults into the PHY. This must be
+ * done after every full reset */
+static void txc_apply_defaults(struct efx_nic *efx)
+{
+	int mctrl;
+
+	/* Turn amplitude down and preemphasis off on the host side
+	 * (PHY<->MAC) as this is believed less likely to upset Falcon
+	 * and no adverse effects have been noted. It probably also
+	 * saves a picowatt or two */
+
+	/* Turn off preemphasis */
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PHYXS,
+			    TXC_ALRGS_ATXPRE0, TXC_ATXPRE_NONE);
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PHYXS,
+			    TXC_ALRGS_ATXPRE1, TXC_ATXPRE_NONE);
+
+	/* Turn down the amplitude */
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PHYXS,
+			    TXC_ALRGS_ATXAMP0, TXC_ATXAMP_0820_BOTH);
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PHYXS,
+			    TXC_ALRGS_ATXAMP1, TXC_ATXAMP_0820_BOTH);
+
+	/* Set the line side amplitude and preemphasis to the databook
+	 * defaults as an erratum causes them to be 0 on at least some
+	 * PHY rev.s */
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PMAPMD,
+			    TXC_ALRGS_ATXPRE0, TXC_ATXPRE_DEFAULT);
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PMAPMD,
+			    TXC_ALRGS_ATXPRE1, TXC_ATXPRE_DEFAULT);
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PMAPMD,
+			    TXC_ALRGS_ATXAMP0, TXC_ATXAMP_DEFAULT);
+	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PMAPMD,
+			    TXC_ALRGS_ATXAMP1, TXC_ATXAMP_DEFAULT);
+
+	/* Set up the LEDs  */
+	mctrl = mdio_clause45_read(efx, efx->mii.phy_id,
+				   MDIO_MMD_PHYXS, TXC_MRGS_CTL);
+
+	/* Set the Green and Red LEDs to their default modes */
+	mctrl &= ~((1 << TXC_MCTL_TXLED_LBN) | (1 << TXC_MCTL_RXLED_LBN));
+	mdio_clause45_write(efx, efx->mii.phy_id,
+			    MDIO_MMD_PHYXS, TXC_MRGS_CTL, mctrl);
+
+	/* Databook recommends doing this after configuration changes */
+	txc_reset_logic(efx);
+
+	efx->board_info.init_leds(efx);
+}
+
+/* Initialisation entry point for this PHY driver */
+static int txc43128_phy_init(struct efx_nic *efx)
+{
+	u32 devid;
+	int rc = 0;
+	struct txc43128_data *phy_data;
+
+	devid = mdio_clause45_read_id(efx, MDIO_MMD_PHYXS);
+
+	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
+	efx->phy_data = phy_data;
+
+	/* This is the default after reset */
+	phy_data->phy_powered = efx->phy_powered;
+	phy_data->tx_disabled = efx->tx_disabled;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	rc = efx_extend_debugfs_port(efx, phy_data, debug_entries);
+	if (rc < 0)
+		goto fail1;
+#endif
+	EFX_INFO(efx, ""TXCNAME ": PHY ID reg %x (OUI %x model %x "
+		 "revision %x)\n", devid, MDIO_ID_OUI(devid),
+		 MDIO_ID_MODEL(devid), MDIO_ID_REV(devid));
+
+	EFX_INFO(efx, ""TXCNAME ": Silicon ID %x\n",
+		 mdio_clause45_read(efx, efx->mii.phy_id,
+				    MDIO_MMD_PHYXS, TXC_GLRGS_SLID) &
+					TXC_GLRGS_SLID_MASK);
+
+	rc = txc_reset_phy(efx);
+	if (rc < 0)
+		goto fail2;
+
+	rc = txc_bist(efx);
+	if (rc < 0)
+		goto fail2;
+
+	txc_apply_defaults(efx);
+
+	return 0;
+
+ fail2:
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_trim_debugfs_port(efx, debug_entries);
+	/* fall-thru */
+ fail1:
+#endif
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+	return rc;
+}
+
+/* Set the lane power down state in the global registers */
+static void txc_glrgs_lane_power(struct efx_nic *efx, int mmd)
+{
+	int pd = (1 << TXC_GLCMD_L01PD_LBN) | (1 << TXC_GLCMD_L23PD_LBN);
+	int ctl = mdio_clause45_read(efx, efx->mii.phy_id,
+				     mmd, TXC_GLRGS_GLCMD);
+
+	if (efx->phy_powered)
+		ctl &= ~pd;
+	else
+		ctl |= pd;
+
+	mdio_clause45_write(efx, efx->mii.phy_id,
+			    mmd, TXC_GLRGS_GLCMD, ctl);
+}
+
+/* Set the lane power down state in the analog control registers */
+static void txc_analog_lane_power(struct efx_nic *efx, int mmd)
+{
+	int txpd = (1 << TXC_ATXCTL_TXPD3_LBN) | (1 << TXC_ATXCTL_TXPD2_LBN)
+		| (1 << TXC_ATXCTL_TXPD1_LBN) | (1 << TXC_ATXCTL_TXPD0_LBN);
+
+	int rxpd = (1 << TXC_ATXCTL_TXPD3_LBN) | (1 << TXC_ATXCTL_TXPD2_LBN)
+		| (1 << TXC_ATXCTL_TXPD1_LBN) | (1 << TXC_ATXCTL_TXPD0_LBN);
+
+	int txctl = mdio_clause45_read(efx, efx->mii.phy_id,
+				       mmd, TXC_ALRGS_ATXCTL);
+	int rxctl = mdio_clause45_read(efx, efx->mii.phy_id,
+				       mmd, TXC_ALRGS_ARXCTL);
+
+	if (efx->phy_powered) {
+		txctl &= ~txpd;
+		rxctl &= ~rxpd;
+	} else {
+		txctl |= txpd;
+		rxctl |= rxpd;
+	}
+
+	mdio_clause45_write(efx, efx->mii.phy_id,
+			    mmd, TXC_ALRGS_ATXCTL, txctl);
+	mdio_clause45_write(efx, efx->mii.phy_id,
+			    mmd, TXC_ALRGS_ARXCTL, rxctl);
+}
+
+static void txc_set_power(struct efx_nic *efx)
+{
+	/* According to the data book, all the MMDs can do low power */
+	mdio_clause45_set_mmds_lpower(efx, !efx->phy_powered,
+				      TXC_REQUIRED_DEVS);
+
+	/* Global register bank is in PCS, PHY XS. These control the host
+	 * side and line side settings respectively. */
+	txc_glrgs_lane_power(efx, MDIO_MMD_PCS);
+	txc_glrgs_lane_power(efx, MDIO_MMD_PHYXS);
+
+	/* Analog register bank in PMA/PMD, PHY XS */
+	txc_analog_lane_power(efx, MDIO_MMD_PMAPMD);
+	txc_analog_lane_power(efx, MDIO_MMD_PHYXS);
+}
+
+
+static void txc_reset_logic_mmd(struct efx_nic *efx, int mmd)
+{
+	int portid = efx->mii.phy_id;
+	int val = mdio_clause45_read(efx, portid, mmd, TXC_GLRGS_GLCMD);
+	int tries = 50;
+	val |= (1 << TXC_GLCMD_LMTSWRST_LBN);
+	mdio_clause45_write(efx, portid, mmd, TXC_GLRGS_GLCMD, val);
+	while (tries--) {
+		val = mdio_clause45_read(efx, portid, mmd,
+					 TXC_GLRGS_GLCMD);
+		if (!(val & (1 << TXC_GLCMD_LMTSWRST_LBN)))
+			break;
+		udelay(1);
+	}
+	if (!tries)
+		EFX_INFO(efx, TXCNAME " Logic reset timed out!\n");
+}
+
+
+/* Perform a logic reset. This preserves the configuration registers
+ * and is needed for some configuration changes to take effect */
+static void txc_reset_logic(struct efx_nic *efx)
+{
+	/* The data sheet claims we can do the logic reset on either the
+	 * PCS or the PHYXS and the result is a reset of both host- and
+	 * line-side logic. */
+	txc_reset_logic_mmd(efx, MDIO_MMD_PCS);
+}
+
+static int txc43128_phy_read_link(struct efx_nic *efx)
+{
+	return mdio_clause45_links_ok(efx, TXC_REQUIRED_DEVS);
+}
+
+static void txc43128_phy_reconfigure(struct efx_nic *efx)
+{
+	struct txc43128_data *phy_data = efx->phy_data;
+	int power_change = (efx->phy_powered != phy_data->phy_powered);
+	int loop_change = LOOPBACK_CHANGED(phy_data, efx, TXC_LOOPBACKS);
+	int disable_change = (efx->tx_disabled != phy_data->tx_disabled);
+
+	if (!phy_data->tx_disabled && efx->tx_disabled) {
+		txc_reset_phy(efx);
+		txc_apply_defaults(efx);
+		falcon_reset_xaui(efx);
+		disable_change = 0;
+	}
+
+	mdio_clause45_transmit_disable(efx, efx->tx_disabled);
+	mdio_clause45_phy_reconfigure(efx);
+	if (power_change)
+		txc_set_power(efx);
+
+	/* The data sheet claims this is required after every reconfiguration
+	 * (note at end of 7.1), but we mustn't do it when nothing changes as
+	 * it glitches the link, and reconfigure gets called on link change,
+	 * so we get an IRQ storm on link up. */
+	if (loop_change || power_change || disable_change)
+		txc_reset_logic(efx);
+
+	phy_data->phy_powered = efx->phy_powered;
+	phy_data->loopback_mode = efx->loopback_mode;
+	phy_data->tx_disabled = efx->tx_disabled;
+	efx->link_up = txc43128_phy_read_link(efx);
+	efx->link_options = GM_LPA_10000FULL;
+}
+
+static void txc43128_phy_fini(struct efx_nic *efx)
+{
+	efx->board_info.blink(efx, 0);
+
+	/* Disable link events */
+	xenpack_disable_lasi_irqs(efx);
+
+#ifdef CONFIG_SFC_DEBUGFS
+	/* Remove the extra debug entries and free data */
+	efx_trim_debugfs_port(efx, debug_entries);
+#endif
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+}
+
+/* Periodic callback: this exists mainly to poll link status as we currently
+ * don't use LASI interrupts. Also update the BER counters and poll the lm87 */
+static int txc43128_phy_check_hw(struct efx_nic *efx)
+{
+	struct txc43128_data *data = efx->phy_data;
+#ifdef CONFIG_SFC_DEBUGFS
+	int phy = efx->mii.phy_id;
+	int timer, count, i, mmd;
+#endif
+	int rc = 0;
+	int link_up = txc43128_phy_read_link(efx);
+
+	/* Simulate a PHY event if link state has changed */
+	if (link_up != efx->link_up)
+		efx->mac_op->fake_phy_event(efx);
+	else if (EFX_WORKAROUND_10934(efx)) {
+		if (link_up || (efx->loopback_mode != LOOPBACK_NONE))
+			data->bug10934_timer = jiffies;
+		else {
+			int delta = jiffies - data->bug10934_timer;
+			if (delta >= BUG10934_RESET_INTERVAL) {
+				data->bug10934_timer = jiffies;
+				txc_reset_logic(efx);
+			}
+		}
+	}
+
+	rc = efx->board_info.monitor(efx);
+	if (rc) {
+		EFX_ERR(efx, "" TXCNAME
+			": sensor alert! Putting PHY into low power.\n");
+		efx->phy_powered = 0;
+		txc_set_power(efx);
+	}
+
+#ifdef CONFIG_SFC_DEBUGFS
+	/* There are 2 MMDs with RX BER counters: PCS and PHY XS,
+	 * which happen to be consecutively numbered */
+	for (mmd = MDIO_MMD_PCS; mmd <= MDIO_MMD_PHYXS; mmd++) {
+		for (i = 0; i < XAUI_NUM_LANES; i++) {
+			timer = mdio_clause45_read(efx, phy, mmd,
+						   TXC_RXCTL_BERTMR0 +
+						   i * BER_REG_SPACING);
+			count = mdio_clause45_read(efx, phy, mmd,
+						   TXC_RXCTL_BERCNT0 +
+						   i * BER_REG_SPACING);
+			/* The BER timer counts down in seconds. If it would
+			 * expire before the next check_hw, update the stats &
+			 * restart the timer (clears the count) */
+			if (timer * HZ < efx_monitor_interval) {
+				/* Record count, allowing for the fact that the
+				 * timer may not have reached zero */
+				unsigned ber = (count * BER_INTERVAL) /
+					(BER_INTERVAL - timer * HZ);
+				if (mmd == MDIO_MMD_PCS)
+					data->phy_ber_pcs[i] = ber;
+				else
+					data->phy_ber_phyxs[i] = ber;
+				/* Reprogram the timer */
+				mdio_clause45_write(efx, phy, mmd,
+						    TXC_RXCTL_BERTMR0 +
+						    i * BER_REG_SPACING,
+						    BER_INTERVAL / HZ);
+			}
+		}
+		mmd = (mmd == MDIO_MMD_PCS) ? MDIO_MMD_PHYXS : 0;
+	}
+#endif /* CONFIG_SFC_DEBUGFS */
+	return rc;
+}
+
+struct efx_phy_operations falcon_txc_phy_ops = {
+	.init             = txc43128_phy_init,
+	.reconfigure      = txc43128_phy_reconfigure,
+	.check_hw         = txc43128_phy_check_hw,
+	.fini             = txc43128_phy_fini,
+	.clear_interrupt  = efx_port_dummy_op_void,
+	.reset_xaui       = efx_port_dummy_op_void,
+	.mmds             = TXC_REQUIRED_DEVS,
+	.loopbacks        = TXC_LOOPBACKS,
+	.startup_loopback = LOOPBACK_PMAPMD,
+};
Index: head-2008-06-18/drivers/net/sfc/workarounds.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/workarounds.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/workarounds.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,10 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_WORKAROUNDS_H
@@ -16,14 +32,26 @@
  */
 
 #define EFX_WORKAROUND_ALWAYS(efx) 1
-#define EFX_WORKAROUND_FALCON_A(efx) (falcon_rev(efx) <= FALCON_REV_A1)
+#define EFX_WORKAROUND_FALCON_A(efx) (FALCON_REV(efx) <= FALCON_REV_A1)
+#define EFX_WORKAROUND_FALCON_B0FPGA(efx) \
+	(FALCON_REV(efx) >= FALCON_REV_B0 && !(efx)->is_asic)
 
 /* XAUI resets if link not detected */
 #define EFX_WORKAROUND_5147 EFX_WORKAROUND_ALWAYS
 /* SNAP frames have TOBE_DISC set */
 #define EFX_WORKAROUND_5475 EFX_WORKAROUND_ALWAYS
+/* PHY interrupts can go to the wrong port */
+#define EFX_WORKAROUND_6263 EFX_WORKAROUND_ALWAYS
+/* Reprog PCIe ACK timer to workaround issue in PCIe IP block */
+#define EFX_WORKAROUND_6943 EFX_WORKAROUND_ALWAYS
 /* RX PCIe double split performance issue */
 #define EFX_WORKAROUND_7575 EFX_WORKAROUND_ALWAYS
+/* Bit-bashed I2C reads cause performance drop */
+#define EFX_WORKAROUND_7884 EFX_WORKAROUND_ALWAYS
+/* Selftests need to be retried */
+#define EFX_WORKAROUND_8909 EFX_WORKAROUND_ALWAYS
+/* Queued ACKs aren't flushed before L1 entry */
+#define EFX_WORKAROUND_9096 EFX_WORKAROUND_ALWAYS
 /* TX pkt parser problem with <= 16 byte TXes */
 #define EFX_WORKAROUND_9141 EFX_WORKAROUND_ALWAYS
 /* XGXS and XAUI reset sequencing in SW */
@@ -33,19 +61,27 @@
 /* TX_EV_PKT_ERR can be caused by a dangling TX descriptor
  * or a PCIe error (bug 11028) */
 #define EFX_WORKAROUND_10727 EFX_WORKAROUND_ALWAYS
+/* CX4 retimer fails to bring link up after reset */
+#define EFX_WORKAROUND_10934 EFX_WORKAROUND_ALWAYS
 /* Transmit flow control may get disabled */
 #define EFX_WORKAROUND_11482 EFX_WORKAROUND_ALWAYS
 /* Flush events can take a very long time to appear */
 #define EFX_WORKAROUND_11557 EFX_WORKAROUND_ALWAYS
+/* 10Xpress is sensitive to unstable XAUI sync when going into loopback */
+#define EFX_WORKAROUND_11667 EFX_WORKAROUND_ALWAYS
 
 /* Spurious parity errors in TSORT buffers */
 #define EFX_WORKAROUND_5129 EFX_WORKAROUND_FALCON_A
+/* No unaligned TX over 512 byte boundaries */
+#define EFX_WORKAROUND_5391 EFX_WORKAROUND_FALCON_A
 /* iSCSI parsing errors */
 #define EFX_WORKAROUND_5583 EFX_WORKAROUND_FALCON_A
 /* RX events go missing */
 #define EFX_WORKAROUND_5676 EFX_WORKAROUND_FALCON_A
 /* RX_RESET on A1 */
 #define EFX_WORKAROUND_6555 EFX_WORKAROUND_FALCON_A
+/* Spurious duplicate RX events */
+#define EFX_WORKAROUND_7062 EFX_WORKAROUND_FALCON_A
 /* Increase filter depth to avoid RX_RESET */
 #define EFX_WORKAROUND_7244 EFX_WORKAROUND_FALCON_A
 /* Flushes may never complete */
@@ -53,4 +89,11 @@
 /* Leak overlength packets rather than free */
 #define EFX_WORKAROUND_8071 EFX_WORKAROUND_FALCON_A
 
+/* Memory needs clearing at start-of-day */
+#define EFX_WORKAROUND_8202 EFX_WORKAROUND_FALCON_B0FPGA
+/* MAC statistics are transient */
+#define EFX_WORKAROUND_8419 EFX_WORKAROUND_FALCON_B0FPGA
+/* Prefetch watchdog timer may trigger erroneously on busy systems */
+#define EFX_WORKAROUND_9008 EFX_WORKAROUND_FALCON_B0FPGA
+
 #endif /* EFX_WORKAROUNDS_H */
Index: head-2008-06-18/drivers/net/sfc/xenpack.h
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/xenpack.h	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/xenpack.h	2008-05-08 14:22:11.000000000 +0200
@@ -1,10 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006:      Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 
 #ifndef EFX_XENPACK_H
@@ -40,6 +56,7 @@ static inline void xenpack_enable_lasi_i
 	reg = mdio_clause45_read(efx, phy_id, MDIO_MMD_PMAPMD,
 				 MDIO_XP_LASI_STAT);
 
+	/* Enable LASI interrupts from PMA/PMD */
 	mdio_clause45_write(efx, phy_id, MDIO_MMD_PMAPMD,
 			    MDIO_XP_LASI_CTRL, XP_LASI_LS_ALARM);
 }
@@ -55,6 +72,7 @@ static inline int xenpack_clear_lasi_irq
 /* Turn off LASI interrupts */
 static inline void xenpack_disable_lasi_irqs(struct efx_nic *efx)
 {
+	/* Turn LASI interrupts off */
 	mdio_clause45_write(efx, efx->mii.phy_id, MDIO_MMD_PMAPMD,
 			    MDIO_XP_LASI_CTRL, 0);
 }
Index: head-2008-06-18/drivers/net/sfc/xfp_phy.c
===================================================================
--- head-2008-06-18.orig/drivers/net/sfc/xfp_phy.c	2008-06-18 14:28:29.000000000 +0200
+++ head-2008-06-18/drivers/net/sfc/xfp_phy.c	2008-05-08 14:22:11.000000000 +0200
@@ -1,10 +1,26 @@
 /****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2006-2008: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Developed by Solarflare Communications <linux-net-drivers@solarflare.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
  */
 /*
  * Driver for XFP optical PHYs (plus some support specific to the Quake 2032)
@@ -18,7 +34,6 @@
 #include "mdio_10g.h"
 #include "xenpack.h"
 #include "phy.h"
-#include "mac.h"
 
 #define XFP_REQUIRED_DEVS (MDIO_MMDREG_DEVS0_PCS |	\
 			   MDIO_MMDREG_DEVS0_PMAPMD |	\
@@ -32,6 +47,7 @@
 /* Quake-specific MDIO registers */
 #define MDIO_QUAKE_LED0_REG	(0xD006)
 
+
 void xfp_set_led(struct efx_nic *p, int led, int mode)
 {
 	int addr = MDIO_QUAKE_LED0_REG + led;
@@ -40,9 +56,11 @@ void xfp_set_led(struct efx_nic *p, int 
 }
 
 struct xfp_phy_data {
+	int phy_powered;
 	int tx_disabled;
 };
 
+
 #define XFP_MAX_RESET_TIME 500
 #define XFP_RESET_WAIT 10
 
@@ -78,6 +96,7 @@ static int xfp_reset_phy(struct efx_nic 
 	return rc;
 }
 
+
 static int xfp_phy_init(struct efx_nic *efx)
 {
 	struct xfp_phy_data *phy_data;
@@ -85,14 +104,13 @@ static int xfp_phy_init(struct efx_nic *
 	int rc;
 
 	phy_data = kzalloc(sizeof(struct xfp_phy_data), GFP_KERNEL);
-	if (!phy_data)
-		return -ENOMEM;
-	efx->phy_data = phy_data;
+	efx->phy_data = (void *) phy_data;
 
 	EFX_INFO(efx, "XFP: PHY ID reg %x (OUI %x model %x revision"
 		 " %x)\n", devid, MDIO_ID_OUI(devid), MDIO_ID_MODEL(devid),
 		 MDIO_ID_REV(devid));
 
+	phy_data->phy_powered = efx->phy_powered;
 	phy_data->tx_disabled = efx->tx_disabled;
 
 	rc = xfp_reset_phy(efx);
@@ -126,7 +144,16 @@ static int xfp_phy_check_hw(struct efx_n
 	int link_up = xfp_link_ok(efx);
 	/* Simulate a PHY event if link state has changed */
 	if (link_up != efx->link_up)
-		falcon_xmac_sim_phy_event(efx);
+		efx->mac_op->fake_phy_event(efx);
+
+	rc = efx->board_info.monitor(efx);
+	if (rc) {
+		EFX_ERR(efx, ": XFP sensor alert! Putting PHY into "
+			"low power.\n");
+		efx->phy_powered = 0;
+
+		mdio_clause45_set_mmds_lpower(efx, 1, XFP_REQUIRED_DEVS);
+	}
 
 	return rc;
 }
@@ -135,14 +162,19 @@ static void xfp_phy_reconfigure(struct e
 {
 	struct xfp_phy_data *phy_data = efx->phy_data;
 
-	/* Reset the PHY when moving from tx off to tx on */
-	if (phy_data->tx_disabled && !efx->tx_disabled)
+	/* Reset the PHY when moving from transmitter off or powered off,
+	 * to transmitter on and powered on */
+	if ((efx->phy_powered && !efx->tx_disabled) &&
+	    (!phy_data->phy_powered || phy_data->tx_disabled))
 		xfp_reset_phy(efx);
 
-	mdio_clause45_transmit_disable(efx);
+	mdio_clause45_transmit_disable(efx, efx->tx_disabled);
+	mdio_clause45_set_mmds_lpower(efx, !efx->phy_powered,
+				      XFP_REQUIRED_DEVS);
 	mdio_clause45_phy_reconfigure(efx);
 
 	phy_data->tx_disabled = efx->tx_disabled;
+	phy_data->phy_powered = efx->phy_powered;
 	efx->link_up = xfp_link_ok(efx);
 	efx->link_options = GM_LPA_10000FULL;
 }
@@ -159,12 +191,13 @@ static void xfp_phy_fini(struct efx_nic 
 }
 
 struct efx_phy_operations falcon_xfp_phy_ops = {
-	.init            = xfp_phy_init,
-	.reconfigure     = xfp_phy_reconfigure,
-	.check_hw        = xfp_phy_check_hw,
-	.fini            = xfp_phy_fini,
-	.clear_interrupt = xfp_phy_clear_interrupt,
-	.reset_xaui      = efx_port_dummy_op_void,
-	.mmds            = XFP_REQUIRED_DEVS,
-	.loopbacks       = XFP_LOOPBACKS,
+	.init             = xfp_phy_init,
+	.reconfigure      = xfp_phy_reconfigure,
+	.check_hw         = xfp_phy_check_hw,
+	.fini             = xfp_phy_fini,
+	.clear_interrupt  = xfp_phy_clear_interrupt,
+	.reset_xaui       = efx_port_dummy_op_void,
+	.mmds             = XFP_REQUIRED_DEVS,
+	.loopbacks        = XFP_LOOPBACKS,
+	.startup_loopback = LOOPBACK_PCS,
 };
