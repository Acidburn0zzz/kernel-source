---
 arch/i386/kernel/acpi/boot-xen.c          |  272 +++++++++++++-----------------
 arch/i386/kernel/cpu/common-xen.c         |    2 
 arch/i386/kernel/entry-xen.S              |    8 
 arch/i386/kernel/io_apic-xen.c            |   10 -
 arch/i386/kernel/mpparse-xen.c            |    4 
 arch/i386/kernel/process-xen.c            |    8 
 arch/i386/kernel/time-xen.c               |    4 
 arch/i386/mm/pageattr.c                   |    1 
 arch/x86_64/kernel/io_apic-xen.c          |   10 -
 drivers/xen/balloon/sysfs.c               |    1 
 drivers/xen/core/evtchn.c                 |    4 
 drivers/xen/netfront/netfront.c           |   37 +---
 include/asm-i386/mach-xen/asm/pgalloc.h   |   13 +
 include/asm-i386/mach-xen/asm/processor.h |    2 
 include/asm-i386/mach-xen/asm/ptrace.h    |    4 
 include/asm-i386/tsc.h                    |    4 
 16 files changed, 179 insertions(+), 205 deletions(-)

Index: linux-2.6.20/arch/i386/kernel/acpi/boot-xen.c
===================================================================
--- linux-2.6.20.orig/arch/i386/kernel/acpi/boot-xen.c
+++ linux-2.6.20/arch/i386/kernel/acpi/boot-xen.c
@@ -25,6 +25,7 @@
 
 #include <linux/init.h>
 #include <linux/acpi.h>
+#include <linux/acpi_pmtmr.h>
 #include <linux/efi.h>
 #include <linux/cpumask.h>
 #include <linux/module.h>
@@ -66,7 +67,7 @@ static inline int acpi_madt_oem_check(ch
 
 #define BAD_MADT_ENTRY(entry, end) (					    \
 		(!entry) || (unsigned long)entry + sizeof(*entry) > end ||  \
-		((acpi_table_entry_header *)entry)->length < sizeof(*entry))
+		((struct acpi_subtable_header *)entry)->length < sizeof(*entry))
 
 #define PREFIX			"ACPI: "
 
@@ -79,7 +80,7 @@ int acpi_ioapic;
 int acpi_strict;
 EXPORT_SYMBOL(acpi_strict);
 
-acpi_interrupt_flags acpi_sci_flags __initdata;
+u8 acpi_sci_flags __initdata;
 int acpi_sci_override_gsi __initdata;
 int acpi_skip_timer_override __initdata;
 int acpi_use_timer_override __initdata;
@@ -92,11 +93,6 @@ static u64 acpi_lapic_addr __initdata = 
 #warning ACPI uses CMPXCHG, i486 and later hardware
 #endif
 
-#define MAX_MADT_ENTRIES	256
-u8 x86_acpiid_to_apicid[MAX_MADT_ENTRIES] =
-    {[0 ... MAX_MADT_ENTRIES - 1] = 0xff };
-EXPORT_SYMBOL(x86_acpiid_to_apicid);
-
 /* --------------------------------------------------------------------------
                               Boot-time Configuration
    -------------------------------------------------------------------------- */
@@ -168,30 +164,26 @@ char *__acpi_map_table(unsigned long phy
 
 #ifdef CONFIG_PCI_MMCONFIG
 /* The physical address of the MMCONFIG aperture.  Set from ACPI tables. */
-struct acpi_table_mcfg_config *pci_mmcfg_config;
+struct acpi_mcfg_allocation *pci_mmcfg_config;
 int pci_mmcfg_config_num;
 
-int __init acpi_parse_mcfg(unsigned long phys_addr, unsigned long size)
+int __init acpi_parse_mcfg(struct acpi_table_header *header)
 {
 	struct acpi_table_mcfg *mcfg;
 	unsigned long i;
 	int config_size;
 
-	if (!phys_addr || !size)
+	if (!header)
 		return -EINVAL;
 
-	mcfg = (struct acpi_table_mcfg *)__acpi_map_table(phys_addr, size);
-	if (!mcfg) {
-		printk(KERN_WARNING PREFIX "Unable to map MCFG\n");
-		return -ENODEV;
-	}
+	mcfg = (struct acpi_table_mcfg *)header;
 
 	/* how many config structures do we have */
 	pci_mmcfg_config_num = 0;
-	i = size - sizeof(struct acpi_table_mcfg);
-	while (i >= sizeof(struct acpi_table_mcfg_config)) {
+	i = header->length - sizeof(struct acpi_table_mcfg);
+	while (i >= sizeof(struct acpi_mcfg_allocation)) {
 		++pci_mmcfg_config_num;
-		i -= sizeof(struct acpi_table_mcfg_config);
+		i -= sizeof(struct acpi_mcfg_allocation);
 	};
 	if (pci_mmcfg_config_num == 0) {
 		printk(KERN_ERR PREFIX "MMCONFIG has no entries\n");
@@ -206,9 +198,9 @@ int __init acpi_parse_mcfg(unsigned long
 		return -ENOMEM;
 	}
 
-	memcpy(pci_mmcfg_config, &mcfg->config, config_size);
+	memcpy(pci_mmcfg_config, &mcfg[1], config_size);
 	for (i = 0; i < pci_mmcfg_config_num; ++i) {
-		if (mcfg->config[i].base_reserved) {
+		if (pci_mmcfg_config[i].address > 0xFFFFFFFF) {
 			printk(KERN_ERR PREFIX
 			       "MMCONFIG not in low 4GB of memory\n");
 			kfree(pci_mmcfg_config);
@@ -222,25 +214,25 @@ int __init acpi_parse_mcfg(unsigned long
 #endif				/* CONFIG_PCI_MMCONFIG */
 
 #ifdef CONFIG_X86_LOCAL_APIC
-static int __init acpi_parse_madt(unsigned long phys_addr, unsigned long size)
+static int __init acpi_parse_madt(struct acpi_table_header *table)
 {
 	struct acpi_table_madt *madt = NULL;
 
-	if (!phys_addr || !size || !cpu_has_apic)
+	if (!cpu_has_apic)
 		return -EINVAL;
 
-	madt = (struct acpi_table_madt *)__acpi_map_table(phys_addr, size);
+	madt = (struct acpi_table_madt *)table;
 	if (!madt) {
 		printk(KERN_WARNING PREFIX "Unable to map MADT\n");
 		return -ENODEV;
 	}
 
 #ifndef CONFIG_XEN
-	if (madt->lapic_address) {
-		acpi_lapic_addr = (u64) madt->lapic_address;
+	if (madt->address) {
+		acpi_lapic_addr = (u64) madt->address;
 
 		printk(KERN_DEBUG PREFIX "Local APIC address 0x%08x\n",
-		       madt->lapic_address);
+		       madt->address);
 	}
 #endif
 
@@ -250,21 +242,17 @@ static int __init acpi_parse_madt(unsign
 }
 
 static int __init
-acpi_parse_lapic(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_lapic(struct acpi_subtable_header * header, const unsigned long end)
 {
-	struct acpi_table_lapic *processor = NULL;
+	struct acpi_madt_local_apic *processor = NULL;
 
-	processor = (struct acpi_table_lapic *)header;
+	processor = (struct acpi_madt_local_apic *)header;
 
 	if (BAD_MADT_ENTRY(processor, end))
 		return -EINVAL;
 
 	acpi_table_print_madt_entry(header);
 
-	/* Record local apic id only when enabled */
-	if (processor->flags.enabled)
-		x86_acpiid_to_apicid[processor->acpi_id] = processor->id;
-
 	/*
 	 * We need to register disabled CPU as well to permit
 	 * counting disabled CPUs. This allows us to size
@@ -273,19 +261,19 @@ acpi_parse_lapic(acpi_table_entry_header
 	 * when we use CPU hotplug.
 	 */
 	mp_register_lapic(processor->id,	/* APIC ID */
-			  processor->flags.enabled);	/* Enabled? */
+			  processor->lapic_flags & ACPI_MADT_ENABLED);	/* Enabled? */
 
 	return 0;
 }
 
 static int __init
-acpi_parse_lapic_addr_ovr(acpi_table_entry_header * header,
+acpi_parse_lapic_addr_ovr(struct acpi_subtable_header * header,
 			  const unsigned long end)
 {
 #ifndef CONFIG_XEN
-	struct acpi_table_lapic_addr_ovr *lapic_addr_ovr = NULL;
+	struct acpi_madt_local_apic_override *lapic_addr_ovr = NULL;
 
-	lapic_addr_ovr = (struct acpi_table_lapic_addr_ovr *)header;
+	lapic_addr_ovr = (struct acpi_madt_local_apic_override *)header;
 
 	if (BAD_MADT_ENTRY(lapic_addr_ovr, end))
 		return -EINVAL;
@@ -297,11 +285,11 @@ acpi_parse_lapic_addr_ovr(acpi_table_ent
 }
 
 static int __init
-acpi_parse_lapic_nmi(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_lapic_nmi(struct acpi_subtable_header * header, const unsigned long end)
 {
-	struct acpi_table_lapic_nmi *lapic_nmi = NULL;
+	struct acpi_madt_local_apic_nmi *lapic_nmi = NULL;
 
-	lapic_nmi = (struct acpi_table_lapic_nmi *)header;
+	lapic_nmi = (struct acpi_madt_local_apic_nmi *)header;
 
 	if (BAD_MADT_ENTRY(lapic_nmi, end))
 		return -EINVAL;
@@ -319,11 +307,11 @@ acpi_parse_lapic_nmi(acpi_table_entry_he
 #ifdef CONFIG_X86_IO_APIC
 
 static int __init
-acpi_parse_ioapic(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_ioapic(struct acpi_subtable_header * header, const unsigned long end)
 {
-	struct acpi_table_ioapic *ioapic = NULL;
+	struct acpi_madt_io_apic *ioapic = NULL;
 
-	ioapic = (struct acpi_table_ioapic *)header;
+	ioapic = (struct acpi_madt_io_apic *)header;
 
 	if (BAD_MADT_ENTRY(ioapic, end))
 		return -EINVAL;
@@ -348,11 +336,11 @@ static void __init acpi_sci_ioapic_setup
 		polarity = 3;
 
 	/* Command-line over-ride via acpi_sci= */
-	if (acpi_sci_flags.trigger)
-		trigger = acpi_sci_flags.trigger;
+	if (acpi_sci_flags & ACPI_MADT_TRIGGER_MASK)
+		trigger = (acpi_sci_flags & ACPI_MADT_TRIGGER_MASK) >> 2;
 
-	if (acpi_sci_flags.polarity)
-		polarity = acpi_sci_flags.polarity;
+	if (acpi_sci_flags & ACPI_MADT_POLARITY_MASK)
+		polarity = acpi_sci_flags & ACPI_MADT_POLARITY_MASK;
 
 	/*
 	 * mp_config_acpi_legacy_irqs() already setup IRQs < 16
@@ -363,51 +351,52 @@ static void __init acpi_sci_ioapic_setup
 
 	/*
 	 * stash over-ride to indicate we've been here
-	 * and for later update of acpi_fadt
+	 * and for later update of acpi_gbl_FADT
 	 */
 	acpi_sci_override_gsi = gsi;
 	return;
 }
 
 static int __init
-acpi_parse_int_src_ovr(acpi_table_entry_header * header,
+acpi_parse_int_src_ovr(struct acpi_subtable_header * header,
 		       const unsigned long end)
 {
-	struct acpi_table_int_src_ovr *intsrc = NULL;
+	struct acpi_madt_interrupt_override *intsrc = NULL;
 
-	intsrc = (struct acpi_table_int_src_ovr *)header;
+	intsrc = (struct acpi_madt_interrupt_override *)header;
 
 	if (BAD_MADT_ENTRY(intsrc, end))
 		return -EINVAL;
 
 	acpi_table_print_madt_entry(header);
 
-	if (intsrc->bus_irq == acpi_fadt.sci_int) {
+	if (intsrc->source_irq == acpi_gbl_FADT.sci_interrupt) {
 		acpi_sci_ioapic_setup(intsrc->global_irq,
-				      intsrc->flags.polarity,
-				      intsrc->flags.trigger);
+				      intsrc->inti_flags & ACPI_MADT_POLARITY_MASK,
+				      (intsrc->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2);
 		return 0;
 	}
 
 	if (acpi_skip_timer_override &&
-	    intsrc->bus_irq == 0 && intsrc->global_irq == 2) {
+	    intsrc->source_irq == 0 && intsrc->global_irq == 2) {
 		printk(PREFIX "BIOS IRQ0 pin2 override ignored.\n");
 		return 0;
 	}
 
-	mp_override_legacy_irq(intsrc->bus_irq,
-			       intsrc->flags.polarity,
-			       intsrc->flags.trigger, intsrc->global_irq);
+	mp_override_legacy_irq(intsrc->source_irq,
+				intsrc->inti_flags & ACPI_MADT_POLARITY_MASK,
+				(intsrc->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2,
+				intsrc->global_irq);
 
 	return 0;
 }
 
 static int __init
-acpi_parse_nmi_src(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_nmi_src(struct acpi_subtable_header * header, const unsigned long end)
 {
-	struct acpi_table_nmi_src *nmi_src = NULL;
+	struct acpi_madt_nmi_source *nmi_src = NULL;
 
-	nmi_src = (struct acpi_table_nmi_src *)header;
+	nmi_src = (struct acpi_madt_nmi_source *)header;
 
 	if (BAD_MADT_ENTRY(nmi_src, end))
 		return -EINVAL;
@@ -423,7 +412,7 @@ acpi_parse_nmi_src(acpi_table_entry_head
 
 /*
  * acpi_pic_sci_set_trigger()
- * 
+ *
  * use ELCR to set PIC-mode trigger type for SCI
  *
  * If a PIC-mode SCI is not recognized or gives spurious IRQ7's
@@ -517,7 +506,7 @@ int acpi_map_lsapic(acpi_handle handle, 
 {
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *obj;
-	struct acpi_table_lapic *lapic;
+	struct acpi_madt_local_apic *lapic;
 	cpumask_t tmp_map, new_map;
 	u8 physid;
 	int cpu;
@@ -535,10 +524,10 @@ int acpi_map_lsapic(acpi_handle handle, 
 		return -EINVAL;
 	}
 
-	lapic = (struct acpi_table_lapic *)obj->buffer.pointer;
+	lapic = (struct acpi_madt_local_apic *)obj->buffer.pointer;
 
-	if ((lapic->header.type != ACPI_MADT_LAPIC) ||
-	    (!lapic->flags.enabled)) {
+	if (lapic->header.type != ACPI_MADT_TYPE_LOCAL_APIC ||
+	    !(lapic->lapic_flags & ACPI_MADT_ENABLED)) {
 		kfree(buffer.pointer);
 		return -EINVAL;
 	}
@@ -550,7 +539,7 @@ int acpi_map_lsapic(acpi_handle handle, 
 	buffer.pointer = NULL;
 
 	tmp_map = cpu_present_map;
-	mp_register_lapic(physid, lapic->flags.enabled);
+	mp_register_lapic(physid, lapic->lapic_flags & ACPI_MADT_ENABLED);
 
 	/*
 	 * If mp_register_lapic successfully generates a new logical cpu
@@ -572,14 +561,6 @@ EXPORT_SYMBOL(acpi_map_lsapic);
 
 int acpi_unmap_lsapic(int cpu)
 {
-	int i;
-
-	for_each_possible_cpu(i) {
-		if (x86_acpiid_to_apicid[i] == x86_cpu_to_apicid[cpu]) {
-			x86_acpiid_to_apicid[i] = -1;
-			break;
-		}
-	}
 	x86_cpu_to_apicid[cpu] = -1;
 	cpu_clear(cpu, cpu_present_map);
 	num_processors--;
@@ -626,42 +607,37 @@ acpi_scan_rsdp(unsigned long start, unsi
 	return 0;
 }
 
-static int __init acpi_parse_sbf(unsigned long phys_addr, unsigned long size)
+static int __init acpi_parse_sbf(struct acpi_table_header *table)
 {
-	struct acpi_table_sbf *sb;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
+	struct acpi_table_boot *sb;
 
-	sb = (struct acpi_table_sbf *)__acpi_map_table(phys_addr, size);
+	sb = (struct acpi_table_boot *)table;
 	if (!sb) {
 		printk(KERN_WARNING PREFIX "Unable to map SBF\n");
 		return -ENODEV;
 	}
 
-	sbf_port = sb->sbf_cmos;	/* Save CMOS port */
+	sbf_port = sb->cmos_index;	/* Save CMOS port */
 
 	return 0;
 }
 
 #ifdef CONFIG_HPET_TIMER
+#include <asm/hpet.h>
 
-static int __init acpi_parse_hpet(unsigned long phys, unsigned long size)
+static int __init acpi_parse_hpet(struct acpi_table_header *table)
 {
 	struct acpi_table_hpet *hpet_tbl;
 	struct resource *hpet_res;
 	resource_size_t res_start;
 
-	if (!phys || !size)
-		return -EINVAL;
-
-	hpet_tbl = (struct acpi_table_hpet *)__acpi_map_table(phys, size);
+	hpet_tbl = (struct acpi_table_hpet *)table;
 	if (!hpet_tbl) {
 		printk(KERN_WARNING PREFIX "Unable to map HPET\n");
 		return -ENODEV;
 	}
 
-	if (hpet_tbl->addr.space_id != ACPI_SPACE_MEM) {
+	if (hpet_tbl->address.space_id != ACPI_SPACE_MEM) {
 		printk(KERN_WARNING PREFIX "HPET timers must be located in "
 		       "memory.\n");
 		return -1;
@@ -674,29 +650,15 @@ static int __init acpi_parse_hpet(unsign
 		hpet_res->name = (void *)&hpet_res[1];
 		hpet_res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 		snprintf((char *)hpet_res->name, HPET_RESOURCE_NAME_SIZE,
-			 "HPET %u", hpet_tbl->number);
+			 "HPET %u", hpet_tbl->sequence);
 		hpet_res->end = (1 * 1024) - 1;
 	}
 
-#ifdef	CONFIG_X86_64
-	vxtime.hpet_address = hpet_tbl->addr.addrl |
-	    ((long)hpet_tbl->addr.addrh << 32);
-
+	hpet_address = hpet_tbl->address.address;
 	printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n",
-	       hpet_tbl->id, vxtime.hpet_address);
-
-	res_start = vxtime.hpet_address;
-#else				/* X86 */
-	{
-		extern unsigned long hpet_address;
-
-		hpet_address = hpet_tbl->addr.addrl;
-		printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n",
-		       hpet_tbl->id, hpet_address);
+	       hpet_tbl->id, hpet_address);
 
-		res_start = hpet_address;
-	}
-#endif				/* X86 */
+	res_start = hpet_address;
 
 	if (hpet_res) {
 		hpet_res->start = res_start;
@@ -710,46 +672,28 @@ static int __init acpi_parse_hpet(unsign
 #define	acpi_parse_hpet	NULL
 #endif
 
-#ifdef CONFIG_X86_PM_TIMER
-extern u32 pmtmr_ioport;
-#endif
-
-static int __init acpi_parse_fadt(unsigned long phys, unsigned long size)
+static int __init acpi_parse_fadt(struct acpi_table_header *table)
 {
-	struct fadt_descriptor *fadt = NULL;
-
-	fadt = (struct fadt_descriptor *)__acpi_map_table(phys, size);
-	if (!fadt) {
-		printk(KERN_WARNING PREFIX "Unable to map FADT\n");
-		return 0;
-	}
-	/* initialize sci_int early for INT_SRC_OVR MADT parsing */
-	acpi_fadt.sci_int = fadt->sci_int;
-
-	/* initialize rev and apic_phys_dest_mode for x86_64 genapic */
-	acpi_fadt.revision = fadt->revision;
-	acpi_fadt.force_apic_physical_destination_mode =
-	    fadt->force_apic_physical_destination_mode;
 
 #if defined(CONFIG_X86_PM_TIMER) && !defined(CONFIG_XEN)
 	/* detect the location of the ACPI PM Timer */
-	if (fadt->revision >= FADT2_REVISION_ID) {
+	if (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID) {
 		/* FADT rev. 2 */
-		if (fadt->xpm_tmr_blk.address_space_id !=
+		if (acpi_gbl_FADT.xpm_timer_block.space_id !=
 		    ACPI_ADR_SPACE_SYSTEM_IO)
 			return 0;
 
-		pmtmr_ioport = fadt->xpm_tmr_blk.address;
+		pmtmr_ioport = acpi_gbl_FADT.xpm_timer_block.address;
 		/*
 		 * "X" fields are optional extensions to the original V1.0
 		 * fields, so we must selectively expand V1.0 fields if the
 		 * corresponding X field is zero.
 	 	 */
 		if (!pmtmr_ioport)
-			pmtmr_ioport = fadt->V1_pm_tmr_blk;
+			pmtmr_ioport = acpi_gbl_FADT.pm_timer_block;
 	} else {
 		/* FADT rev. 1 */
-		pmtmr_ioport = fadt->V1_pm_tmr_blk;
+		pmtmr_ioport = acpi_gbl_FADT.pm_timer_block;
 	}
 	if (pmtmr_ioport)
 		printk(KERN_INFO PREFIX "PM-Timer IO Port: %#x\n",
@@ -791,13 +735,13 @@ static int __init acpi_parse_madt_lapic_
 	if (!cpu_has_apic)
 		return -ENODEV;
 
-	/* 
+	/*
 	 * Note that the LAPIC address is obtained from the MADT (32-bit value)
 	 * and (optionally) overriden by a LAPIC_ADDR_OVR entry (64-bit value).
 	 */
 
 	count =
-	    acpi_table_parse_madt(ACPI_MADT_LAPIC_ADDR_OVR,
+	    acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE,
 				  acpi_parse_lapic_addr_ovr, 0);
 	if (count < 0) {
 		printk(KERN_ERR PREFIX
@@ -809,7 +753,7 @@ static int __init acpi_parse_madt_lapic_
 	mp_register_lapic_address(acpi_lapic_addr);
 #endif
 
-	count = acpi_table_parse_madt(ACPI_MADT_LAPIC, acpi_parse_lapic,
+	count = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC, acpi_parse_lapic,
 				      MAX_APICS);
 	if (!count) {
 		printk(KERN_ERR PREFIX "No LAPIC entries present\n");
@@ -822,7 +766,7 @@ static int __init acpi_parse_madt_lapic_
 	}
 
 	count =
-	    acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0);
+	    acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_NMI, acpi_parse_lapic_nmi, 0);
 	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing LAPIC NMI entry\n");
 		/* TBD: Cleanup to allow fallback to MPS */
@@ -851,7 +795,7 @@ static int __init acpi_parse_madt_ioapic
 		return -ENODEV;
 	}
 
-	if (!cpu_has_apic) 
+	if (!cpu_has_apic)
 		return -ENODEV;
 
 	/*
@@ -864,7 +808,7 @@ static int __init acpi_parse_madt_ioapic
 	}
 
 	count =
-	    acpi_table_parse_madt(ACPI_MADT_IOAPIC, acpi_parse_ioapic,
+	    acpi_table_parse_madt(ACPI_MADT_TYPE_IO_APIC, acpi_parse_ioapic,
 				  MAX_IO_APICS);
 	if (!count) {
 		printk(KERN_ERR PREFIX "No IOAPIC entries present\n");
@@ -875,7 +819,7 @@ static int __init acpi_parse_madt_ioapic
 	}
 
 	count =
-	    acpi_table_parse_madt(ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr,
+	    acpi_table_parse_madt(ACPI_MADT_TYPE_INTERRUPT_OVERRIDE, acpi_parse_int_src_ovr,
 				  NR_IRQ_VECTORS);
 	if (count < 0) {
 		printk(KERN_ERR PREFIX
@@ -889,13 +833,13 @@ static int __init acpi_parse_madt_ioapic
 	 * pretend we got one so we can set the SCI flags.
 	 */
 	if (!acpi_sci_override_gsi)
-		acpi_sci_ioapic_setup(acpi_fadt.sci_int, 0, 0);
+		acpi_sci_ioapic_setup(acpi_gbl_FADT.sci_interrupt, 0, 0);
 
 	/* Fill in identity legacy mapings where no override */
 	mp_config_acpi_legacy_irqs();
 
 	count =
-	    acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src,
+	    acpi_table_parse_madt(ACPI_MADT_TYPE_NMI_SOURCE, acpi_parse_nmi_src,
 				  NR_IRQ_VECTORS);
 	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing NMI SRC entry\n");
@@ -915,10 +859,9 @@ static inline int acpi_parse_madt_ioapic
 static void __init acpi_process_madt(void)
 {
 #ifdef CONFIG_X86_LOCAL_APIC
-	int count, error;
+	int error;
 
-	count = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
-	if (count >= 1) {
+	if (!acpi_table_parse(ACPI_SIG_MADT, acpi_parse_madt)) {
 
 		/*
 		 * Parse MADT LAPIC entries
@@ -1138,7 +1081,28 @@ static struct dmi_system_id __initdata a
 			       "ASUS A7V ACPI BIOS Revision 1007"),
 		     },
 	 },
-
+	{
+		/*
+		 * Latest BIOS for IBM 600E (1.16) has bad pcinum
+		 * for LPC bridge, which is needed for the PCI
+		 * interrupt links to work. DSDT fix is in bug 5966.
+		 * 2645, 2646 model numbers are shared with 600/600E/600X
+		 */
+	 .callback = disable_acpi_irq,
+	 .ident = "IBM Thinkpad 600 Series 2645",
+	 .matches = {
+		     DMI_MATCH(DMI_BOARD_VENDOR, "IBM"),
+		     DMI_MATCH(DMI_BOARD_NAME, "2645"),
+		     },
+	 },
+	{
+	 .callback = disable_acpi_irq,
+	 .ident = "IBM Thinkpad 600 Series 2646",
+	 .matches = {
+		     DMI_MATCH(DMI_BOARD_VENDOR, "IBM"),
+		     DMI_MATCH(DMI_BOARD_NAME, "2646"),
+		     },
+	 },
 	/*
 	 * Boxes that need ACPI PCI IRQ routing and PCI scan disabled
 	 */
@@ -1204,7 +1168,7 @@ int __init acpi_boot_table_init(void)
 	if (acpi_disabled && !acpi_ht)
 		return 1;
 
-	/* 
+	/*
 	 * Initialize the ACPI boot-time table parser.
 	 */
 	error = acpi_table_init();
@@ -1213,7 +1177,7 @@ int __init acpi_boot_table_init(void)
 		return error;
 	}
 
-	acpi_table_parse(ACPI_BOOT, acpi_parse_sbf);
+	acpi_table_parse(ACPI_SIG_BOOT, acpi_parse_sbf);
 
 	/*
 	 * blacklist may disable ACPI entirely
@@ -1241,19 +1205,19 @@ int __init acpi_boot_init(void)
 	if (acpi_disabled && !acpi_ht)
 		return 1;
 
-	acpi_table_parse(ACPI_BOOT, acpi_parse_sbf);
+	acpi_table_parse(ACPI_SIG_BOOT, acpi_parse_sbf);
 
 	/*
 	 * set sci_int and PM timer address
 	 */
-	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
+	acpi_table_parse(ACPI_SIG_FADT, acpi_parse_fadt);
 
 	/*
 	 * Process the Multiple APIC Description Table (MADT), if present
 	 */
 	acpi_process_madt();
 
-	acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
+	acpi_table_parse(ACPI_SIG_HPET, acpi_parse_hpet);
 
 	return 0;
 }
@@ -1324,13 +1288,17 @@ static int __init setup_acpi_sci(char *s
 	if (!s)
 		return -EINVAL;
 	if (!strcmp(s, "edge"))
-		acpi_sci_flags.trigger = 1;
+		acpi_sci_flags =  ACPI_MADT_TRIGGER_EDGE |
+			(acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);
 	else if (!strcmp(s, "level"))
-		acpi_sci_flags.trigger = 3;
+		acpi_sci_flags = ACPI_MADT_TRIGGER_LEVEL |
+			(acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);
 	else if (!strcmp(s, "high"))
-		acpi_sci_flags.polarity = 1;
+		acpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_HIGH |
+			(acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);
 	else if (!strcmp(s, "low"))
-		acpi_sci_flags.polarity = 3;
+		acpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_LOW |
+			(acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);
 	else
 		return -EINVAL;
 	return 0;
Index: linux-2.6.20/arch/i386/kernel/cpu/common-xen.c
===================================================================
--- linux-2.6.20.orig/arch/i386/kernel/cpu/common-xen.c
+++ linux-2.6.20/arch/i386/kernel/cpu/common-xen.c
@@ -610,7 +610,7 @@ void __init early_cpu_init(void)
 struct pt_regs * __devinit idle_regs(struct pt_regs *regs)
 {
 	memset(regs, 0, sizeof(struct pt_regs));
-	regs->xgs = __KERNEL_PDA;
+	regs->xfs = __KERNEL_PDA;
 	return regs;
 }
 
Index: linux-2.6.20/arch/i386/kernel/entry-xen.S
===================================================================
--- linux-2.6.20.orig/arch/i386/kernel/entry-xen.S
+++ linux-2.6.20/arch/i386/kernel/entry-xen.S
@@ -352,11 +352,11 @@ sysenter_past_esp:
 	movl PT_OLDESP(%esp), %ecx
 	xorl %ebp,%ebp
 	TRACE_IRQS_ON
-1:	mov  PT_GS(%esp), %gs
+1:	mov  PT_FS(%esp), %gs
 	ENABLE_INTERRUPTS_SYSEXIT
 	CFI_ENDPROC
 .pushsection .fixup,"ax"
-2:	movl $0,PT_GS(%esp)
+2:	movl $0,PT_FS(%esp)
 	jmp 1b
 .section __ex_table,"a"
 	.align 4
@@ -722,10 +722,10 @@ error_code:
 	popl %ecx
 	CFI_ADJUST_CFA_OFFSET -4
 	/*CFI_REGISTER es, ecx*/
-	movl PT_GS(%esp), %edi		# get the function address
+	movl PT_FS(%esp), %edi		# get the function address
 	movl PT_ORIG_EAX(%esp), %edx	# get the error code
 	movl $-1, PT_ORIG_EAX(%esp)	# no syscall to restart
-	mov  %ecx, PT_GS(%esp)
+	mov  %ecx, PT_FS(%esp)
 	/*CFI_REL_OFFSET gs, ES*/
 	movl $(__USER_DS), %ecx
 	movl %ecx, %ds
Index: linux-2.6.20/arch/i386/kernel/io_apic-xen.c
===================================================================
--- linux-2.6.20.orig/arch/i386/kernel/io_apic-xen.c
+++ linux-2.6.20/arch/i386/kernel/io_apic-xen.c
@@ -390,7 +390,7 @@ static void set_ioapic_affinity_irq(unsi
 			break;
 		entry = irq_2_pin + entry->next;
 	}
-	set_native_irq_info(irq, cpumask);
+	irq_desc[irq].affinity = cpumask;
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 }
 
@@ -1386,7 +1386,7 @@ static void __init setup_IO_APIC_irqs(vo
 		}
 		spin_lock_irqsave(&ioapic_lock, flags);
 		__ioapic_write_entry(apic, pin, entry);
-		set_native_irq_info(irq, TARGET_CPUS);
+		irq_desc[irq].affinity = TARGET_CPUS;
 		spin_unlock_irqrestore(&ioapic_lock, flags);
 	}
 	}
@@ -2646,7 +2646,7 @@ static void set_msi_irq_affinity(unsigne
 	msg.address_lo |= MSI_ADDR_DEST_ID(dest);
 
 	write_msi_msg(irq, &msg);
-	set_native_irq_info(irq, mask);
+	irq_desc[irq].affinity = mask;
 }
 #endif /* CONFIG_SMP */
 
@@ -2723,7 +2723,7 @@ static void set_ht_irq_affinity(unsigned
 	dest = cpu_mask_to_apicid(mask);
 
 	target_ht_irq(irq, dest);
-	set_native_irq_info(irq, mask);
+	irq_desc[irq].affinity = mask;
 }
 #endif
 
@@ -2931,7 +2931,7 @@ int io_apic_set_pci_routing (int ioapic,
 
 	spin_lock_irqsave(&ioapic_lock, flags);
 	__ioapic_write_entry(ioapic, pin, entry);
-	set_native_irq_info(irq, TARGET_CPUS);
+	irq_desc[irq].affinity = TARGET_CPUS;
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 
 	return 0;
Index: linux-2.6.20/arch/i386/kernel/mpparse-xen.c
===================================================================
--- linux-2.6.20.orig/arch/i386/kernel/mpparse-xen.c
+++ linux-2.6.20/arch/i386/kernel/mpparse-xen.c
@@ -1085,7 +1085,7 @@ int mp_register_gsi(u32 gsi, int trigger
 	static int		gsi_to_irq[MAX_GSI_NUM];
 
 	/* Don't set up the ACPI SCI because it's already set up */
-	if (acpi_fadt.sci_int == gsi)
+	if (acpi_gbl_FADT.sci_interrupt == gsi)
 		return gsi;
 
 	ioapic = mp_find_ioapic(gsi);
@@ -1142,7 +1142,7 @@ int mp_register_gsi(u32 gsi, int trigger
 			/*
 			 * Don't assign IRQ used by ACPI SCI
 			 */
-			if (gsi == acpi_fadt.sci_int)
+			if (gsi == acpi_gbl_FADT.sci_interrupt)
 				gsi = pci_irq++;
 			gsi_to_irq[irq] = gsi;
 		} else {
Index: linux-2.6.20/arch/i386/kernel/process-xen.c
===================================================================
--- linux-2.6.20.orig/arch/i386/kernel/process-xen.c
+++ linux-2.6.20/arch/i386/kernel/process-xen.c
@@ -253,8 +253,8 @@ void show_regs(struct pt_regs * regs)
 		regs->eax,regs->ebx,regs->ecx,regs->edx);
 	printk("ESI: %08lx EDI: %08lx EBP: %08lx",
 		regs->esi, regs->edi, regs->ebp);
-	printk(" DS: %04x ES: %04x GS: %04x\n",
-	       0xffff & regs->xds,0xffff & regs->xes, 0xffff & regs->xgs);
+	printk(" DS: %04x ES: %04x FS: %04x\n",
+	       0xffff & regs->xds,0xffff & regs->xes, 0xffff & regs->xfs);
 
 	cr0 = read_cr0();
 	cr2 = read_cr2();
@@ -285,7 +285,7 @@ int kernel_thread(int (*fn)(void *), voi
 
 	regs.xds = __USER_DS;
 	regs.xes = __USER_DS;
-	regs.xgs = __KERNEL_PDA;
+	regs.xfs = __KERNEL_PDA;
 	regs.orig_eax = -1;
 	regs.eip = (unsigned long) kernel_thread_helper;
 	regs.xcs = __KERNEL_CS | get_kernel_rpl();
@@ -439,7 +439,7 @@ void dump_thread(struct pt_regs * regs, 
 	dump->regs.ds = regs->xds;
 	dump->regs.es = regs->xes;
 	savesegment(fs,dump->regs.fs);
-	dump->regs.gs = regs->xgs;
+	dump->regs.gs = regs->xfs;
 	dump->regs.orig_eax = regs->orig_eax;
 	dump->regs.eip = regs->eip;
 	dump->regs.cs = regs->xcs;
Index: linux-2.6.20/arch/i386/kernel/time-xen.c
===================================================================
--- linux-2.6.20.orig/arch/i386/kernel/time-xen.c
+++ linux-2.6.20/arch/i386/kernel/time-xen.c
@@ -1132,7 +1132,7 @@ static struct clocksource clocksource_xe
 	.mask			= CLOCKSOURCE_MASK(64),
 	.mult			= 0, /* to be set */
 	.shift			= 22,
-	.is_continuous		= 1,
+	.flags			= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
 static int __init init_xen_clocksource(void)
@@ -1180,7 +1180,7 @@ static ctl_table xen_table[] = {
 };
 static int __init xen_sysctl_init(void)
 {
-	(void)register_sysctl_table(xen_table, 0);
+	(void)register_sysctl_table(xen_table);
 	return 0;
 }
 __initcall(xen_sysctl_init);
Index: linux-2.6.20/arch/i386/mm/pageattr.c
===================================================================
--- linux-2.6.20.orig/arch/i386/mm/pageattr.c
+++ linux-2.6.20/arch/i386/mm/pageattr.c
@@ -13,6 +13,7 @@
 #include <asm/tlbflush.h>
 #include <asm/pgalloc.h>
 #include <asm/sections.h>
+#include <asm/pgalloc.h>
 
 static DEFINE_SPINLOCK(cpa_lock);
 static struct list_head df_list = LIST_HEAD_INIT(df_list);
Index: linux-2.6.20/arch/x86_64/kernel/io_apic-xen.c
===================================================================
--- linux-2.6.20.orig/arch/x86_64/kernel/io_apic-xen.c
+++ linux-2.6.20/arch/x86_64/kernel/io_apic-xen.c
@@ -282,7 +282,7 @@ static void set_ioapic_affinity_irq(unsi
 
 	spin_lock_irqsave(&ioapic_lock, flags);
 	__target_IO_APIC_irq(irq, dest, vector);
-	set_native_irq_info(irq, mask);
+	irq_desc[irq].affinity = mask;
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 }
 #endif
@@ -815,7 +815,7 @@ static void __init setup_IO_APIC_irq(int
 	ioapic_write_entry(apic, pin, entry);
 
 	spin_lock_irqsave(&ioapic_lock, flags);
-	set_native_irq_info(irq, TARGET_CPUS);
+	irq_desc[irq].affinity = TARGET_CPUS;
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 
 }
@@ -1914,7 +1914,7 @@ static void set_msi_irq_affinity(unsigne
 	msg.address_lo |= MSI_ADDR_DEST_ID(dest);
 
 	write_msi_msg(irq, &msg);
-	set_native_irq_info(irq, mask);
+	irq_desc[irq].affinity = mask;
 }
 #endif /* CONFIG_SMP */
 
@@ -1995,7 +1995,7 @@ static void set_ht_irq_affinity(unsigned
 	dest = cpu_mask_to_apicid(tmp);
 
 	target_ht_irq(irq, dest, vector);
-	set_native_irq_info(irq, mask);
+	irq_desc[irq].affinity = mask;
 }
 #endif
 
@@ -2120,7 +2120,7 @@ int io_apic_set_pci_routing (int ioapic,
 	ioapic_write_entry(ioapic, pin, entry);
 
 	spin_lock_irqsave(&ioapic_lock, flags);
-	set_native_irq_info(irq, TARGET_CPUS);
+	irq_desc[irq].affinity = TARGET_CPUS;
 	spin_unlock_irqrestore(&ioapic_lock, flags);
 
 	return 0;
Index: linux-2.6.20/drivers/xen/balloon/sysfs.c
===================================================================
--- linux-2.6.20.orig/drivers/xen/balloon/sysfs.c
+++ linux-2.6.20/drivers/xen/balloon/sysfs.c
@@ -31,6 +31,7 @@
 #include <linux/capability.h>
 #include <linux/stat.h>
 #include <linux/sysdev.h>
+#include <linux/module.h>
 #include "common.h"
 
 #define BALLOON_CLASS_NAME "memory"
Index: linux-2.6.20/drivers/xen/core/evtchn.c
===================================================================
--- linux-2.6.20.orig/drivers/xen/core/evtchn.c
+++ linux-2.6.20/drivers/xen/core/evtchn.c
@@ -130,7 +130,7 @@ static void bind_evtchn_to_cpu(unsigned 
 	int irq = evtchn_to_irq[chn];
 
 	BUG_ON(irq == -1);
-	set_native_irq_info(irq, cpumask_of_cpu(cpu));
+	irq_desc[irq].affinity = cpumask_of_cpu(cpu);
 
 	clear_bit(chn, (unsigned long *)cpu_evtchn_mask[cpu_evtchn[chn]]);
 	set_bit(chn, (unsigned long *)cpu_evtchn_mask[cpu]);
@@ -143,7 +143,7 @@ static void init_evtchn_cpu_bindings(voi
 
 	/* By default all event channels notify CPU#0. */
 	for (i = 0; i < NR_IRQS; i++)
-		set_native_irq_info(i, cpumask_of_cpu(0));
+		irq_desc[i].affinity = cpumask_of_cpu(0);
 
 	memset(cpu_evtchn, 0, sizeof(cpu_evtchn));
 	memset(cpu_evtchn_mask[0], ~0, sizeof(cpu_evtchn_mask[0]));
Index: linux-2.6.20/drivers/xen/netfront/netfront.c
===================================================================
--- linux-2.6.20.orig/drivers/xen/netfront/netfront.c
+++ linux-2.6.20/drivers/xen/netfront/netfront.c
@@ -46,7 +46,7 @@
 #include <linux/in.h>
 #include <linux/if_ether.h>
 #include <linux/io.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 #include <net/arp.h>
@@ -1776,20 +1776,18 @@ static struct ethtool_ops network_ethtoo
 };
 
 #ifdef CONFIG_SYSFS
-static ssize_t show_rxbuf_min(struct class_device *cd, char *buf)
+static ssize_t show_rxbuf_min(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct net_device *netdev = container_of(cd, struct net_device,
-						 class_dev);
+	struct net_device *netdev = container_of(dev, struct net_device, dev);
 	struct netfront_info *info = netdev_priv(netdev);
 
 	return sprintf(buf, "%u\n", info->rx_min_target);
 }
 
-static ssize_t store_rxbuf_min(struct class_device *cd,
+static ssize_t store_rxbuf_min(struct device *dev, struct device_attribute *attr,
 			       const char *buf, size_t len)
 {
-	struct net_device *netdev = container_of(cd, struct net_device,
-						 class_dev);
+	struct net_device *netdev = container_of(dev, struct net_device, dev);
 	struct netfront_info *np = netdev_priv(netdev);
 	char *endp;
 	unsigned long target;
@@ -1819,20 +1817,17 @@ static ssize_t store_rxbuf_min(struct cl
 	return len;
 }
 
-static ssize_t show_rxbuf_max(struct class_device *cd, char *buf)
+static ssize_t show_rxbuf_max(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct net_device *netdev = container_of(cd, struct net_device,
-						 class_dev);
+	struct net_device *netdev = container_of(dev, struct net_device, dev);
 	struct netfront_info *info = netdev_priv(netdev);
 
 	return sprintf(buf, "%u\n", info->rx_max_target);
 }
 
-static ssize_t store_rxbuf_max(struct class_device *cd,
-			       const char *buf, size_t len)
+static ssize_t store_rxbuf_max(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
 {
-	struct net_device *netdev = container_of(cd, struct net_device,
-						 class_dev);
+	struct net_device *netdev = container_of(dev, struct net_device, dev);
 	struct netfront_info *np = netdev_priv(netdev);
 	char *endp;
 	unsigned long target;
@@ -1862,16 +1857,15 @@ static ssize_t store_rxbuf_max(struct cl
 	return len;
 }
 
-static ssize_t show_rxbuf_cur(struct class_device *cd, char *buf)
+static ssize_t show_rxbuf_cur(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct net_device *netdev = container_of(cd, struct net_device,
-						 class_dev);
+	struct net_device *netdev = container_of(dev, struct net_device, dev);
 	struct netfront_info *info = netdev_priv(netdev);
 
 	return sprintf(buf, "%u\n", info->rx_target);
 }
 
-static const struct class_device_attribute xennet_attrs[] = {
+static struct device_attribute xennet_attrs[] = {
 	__ATTR(rxbuf_min, S_IRUGO|S_IWUSR, show_rxbuf_min, store_rxbuf_min),
 	__ATTR(rxbuf_max, S_IRUGO|S_IWUSR, show_rxbuf_max, store_rxbuf_max),
 	__ATTR(rxbuf_cur, S_IRUGO, show_rxbuf_cur, NULL),
@@ -1883,8 +1877,7 @@ static int xennet_sysfs_addif(struct net
 	int error = 0;
 
 	for (i = 0; i < ARRAY_SIZE(xennet_attrs); i++) {
-		error = class_device_create_file(&netdev->class_dev,
-						 &xennet_attrs[i]);
+		error = device_create_file(&netdev->dev, &xennet_attrs[i]);
 		if (error)
 			goto fail;
 	}
@@ -1892,7 +1885,7 @@ static int xennet_sysfs_addif(struct net
 
  fail:
 	while (--i >= 0)
-		class_device_remove_file(&netdev->class_dev,
+		device_remove_file(&netdev->dev,
 					 &xennet_attrs[i]);
 	return error;
 }
@@ -1902,7 +1895,7 @@ static void xennet_sysfs_delif(struct ne
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(xennet_attrs); i++) {
-		class_device_remove_file(&netdev->class_dev,
+		device_remove_file(&netdev->dev,
 					 &xennet_attrs[i]);
 	}
 }
Index: linux-2.6.20/include/asm-i386/mach-xen/asm/pgalloc.h
===================================================================
--- linux-2.6.20.orig/include/asm-i386/mach-xen/asm/pgalloc.h
+++ linux-2.6.20/include/asm-i386/mach-xen/asm/pgalloc.h
@@ -56,4 +53,12 @@ extern void pte_free(struct page *pte);
 
 #define check_pgt_cache()	do { } while (0)
 
+/* FIXME */
+#define paravirt_alloc_pt(pfn) do { } while (0)
+#define paravirt_alloc_pd(pfn) do { } while (0)
+#define paravirt_alloc_pd(pfn) do { } while (0)
+#define paravirt_alloc_pd_clone(pfn, clonepfn, start, count) do { } while (0)
+#define paravirt_release_pt(pfn) do { } while (0)
+#define paravirt_release_pd(pfn) do { } while (0)
+
 #endif /* _I386_PGALLOC_H */
Index: linux-2.6.20/include/asm-i386/mach-xen/asm/processor.h
===================================================================
--- linux-2.6.20.orig/include/asm-i386/mach-xen/asm/processor.h
+++ linux-2.6.20/include/asm-i386/mach-xen/asm/processor.h
@@ -450,7 +450,7 @@ struct thread_struct {
 
 #define start_thread(regs, new_eip, new_esp) do {		\
 	__asm__("movl %0,%%fs": :"r" (0));			\
-	regs->xgs = 0;						\
+	regs->xfs = 0;						\
 	set_fs(USER_DS);					\
 	regs->xds = __USER_DS;					\
 	regs->xes = __USER_DS;					\
Index: linux-2.6.20/include/asm-i386/tsc.h
===================================================================
--- linux-2.6.20.orig/include/asm-i386/tsc.h
+++ linux-2.6.20/include/asm-i386/tsc.h
@@ -54,7 +54,11 @@ static __always_inline cycles_t get_cycl
 
 extern void tsc_init(void);
 extern void mark_tsc_unstable(void);
+#ifdef CONFIG_XEN
+static inline int unsynchronized_tsc(void) { return 0; }
+#else
 extern int unsynchronized_tsc(void);
+#endif
 extern void init_tsc_clocksource(void);
 
 /*
