Subject: xen3: 2.6.13 adaptions (i386).
From: kraxel

$subject says all.

Signed-off-by: Gerd Knorr <kraxel@suse.de>
Index: linux-2.6.12/include/asm-xen/asm-i386/pci.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-i386/pci.h
+++ linux-2.6.12/include/asm-xen/asm-i386/pci.h
@@ -26,9 +26,9 @@ extern unsigned long pci_mem_start;
 void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 
 void pcibios_set_master(struct pci_dev *dev);
-void pcibios_penalize_isa_irq(int irq);
+void pcibios_penalize_isa_irq(int irq, int active);
 struct irq_routing_table *pcibios_get_irq_routing_table(void);
 int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
 
 /* Dynamic DMA mapping stuff.
Index: linux-2.6.12/include/asm-xen/asm-i386/page.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-i386/page.h
+++ linux-2.6.12/include/asm-xen/asm-i386/page.h
@@ -153,8 +153,9 @@ static inline unsigned long pgd_val(pgd_
 #define HPAGE_SIZE	((1UL) << HPAGE_SHIFT)
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
 #define HAVE_ARCH_HUGETLB_UNMAPPED_AREA
+#define ARCH_HAS_HUGETLB_CLEAN_STALE_PGTABLE
 #endif
 
 #define pgprot_val(x)	((x).pgprot)
 
Index: linux-2.6.12/arch/xen/i386/pci/irq.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/pci/irq.c
+++ linux-2.6.12/arch/xen/i386/pci/irq.c
@@ -55,8 +55,9 @@ struct irq_router_handler {
 	int (*probe)(struct irq_router *r, struct pci_dev *router, u16 device);
 };
 
 int (*pcibios_enable_irq)(struct pci_dev *dev) = NULL;
+void (*pcibios_disable_irq)(struct pci_dev *dev) = NULL;
 
 /*
  *  Search 0xf0000 -- 0xfffff for the PCI IRQ Routing Table.
  */
@@ -1018,9 +1019,9 @@ static void pirq_penalize_isa_irq(int ir
 	if (irq < 16)
 		pirq_penalty[irq] += 100;
 }
 
-void pcibios_penalize_isa_irq(int irq)
+void pcibios_penalize_isa_irq(int irq, int active)
 {
 #ifdef CONFIG_ACPI_PCI
 	if (!acpi_noirq)
 		acpi_penalize_isa_irq(irq);
Index: linux-2.6.12/arch/xen/i386/kernel/process.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/kernel/process.c
+++ linux-2.6.12/arch/xen/i386/kernel/process.c
@@ -144,9 +144,9 @@ static inline void play_dead(void)
  * somebody to say that they'd like to reschedule)
  */
 void cpu_idle (void)
 {
-	int cpu = _smp_processor_id();
+	int cpu = raw_smp_processor_id();
 
 	/* endless idle loop with no priority at all */
 	while (1) {
 		while (!need_resched()) {
Index: linux-2.6.12/arch/xen/kernel/reboot.c
===================================================================
--- linux-2.6.12.orig/arch/xen/kernel/reboot.c
+++ linux-2.6.12/arch/xen/kernel/reboot.c
@@ -21,16 +21,21 @@
 #define SHUTDOWN_POWEROFF  0
 #define SHUTDOWN_REBOOT    1
 #define SHUTDOWN_SUSPEND   2
 
-void machine_restart(char * __unused)
+void machine_emergency_restart(void)
 {
 	/* We really want to get pending console data out before we die. */
 	extern void xencons_force_flush(void);
 	xencons_force_flush();
 	HYPERVISOR_reboot();
 }
 
+void machine_restart(char * __unused)
+{
+	machine_emergency_restart();
+}
+
 void machine_halt(void)
 {
 	machine_power_off();
 }
Index: linux-2.6.12/include/asm-xen/asm-i386/io.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-i386/io.h
+++ linux-2.6.12/include/asm-xen/asm-i386/io.h
@@ -361,9 +361,9 @@ static inline unsigned type in##bwl(int 
 }
 #endif
 
 
-#if __UNSAFE_IO__
+#ifdef __UNSAFE_IO__
 #define ____BUILDIO(bwl,bw,type) \
 static inline void out##bwl##_local(unsigned type value, int port) { \
 	__asm__ __volatile__("out" #bwl " %" #bw "0, %w1" : : "a"(value), "Nd"(port)); \
 } \
Index: linux-2.6.12/include/asm-xen/asm-i386/pgtable.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-i386/pgtable.h
+++ linux-2.6.12/include/asm-xen/asm-i386/pgtable.h
@@ -238,8 +238,9 @@ static inline pte_t pte_mkread(pte_t pte
 static inline pte_t pte_mkexec(pte_t pte)	{ (pte).pte_low |= _PAGE_USER; return pte; }
 static inline pte_t pte_mkdirty(pte_t pte)	{ (pte).pte_low |= _PAGE_DIRTY; return pte; }
 static inline pte_t pte_mkyoung(pte_t pte)	{ (pte).pte_low |= _PAGE_ACCESSED; return pte; }
 static inline pte_t pte_mkwrite(pte_t pte)	{ (pte).pte_low |= _PAGE_RW; return pte; }
+static inline pte_t pte_mkhuge(pte_t pte)      { (pte).pte_low |= _PAGE_PRESENT | _PAGE_PSE; return pte; }
 
 #ifdef CONFIG_X86_PAE
 # include <asm/pgtable-3level.h>
 #else
@@ -278,9 +279,9 @@ static inline void ptep_set_wrprotect(st
  * and a page entry and page directory to the page they refer to.
  */
 
 #define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))
-#define mk_pte_huge(entry) ((entry).pte_low |= _PAGE_PRESENT | _PAGE_PSE)
+//#define mk_pte_huge(entry) ((entry).pte_low |= _PAGE_PRESENT | _PAGE_PSE)
 
 static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
 	pte.pte_low &= _PAGE_CHG_MASK;
Index: linux-2.6.12/arch/xen/i386/kernel/time.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/kernel/time.c
+++ linux-2.6.12/arch/xen/i386/kernel/time.c
@@ -87,13 +87,9 @@ unsigned long __wall_jiffies __section_w
 struct timespec __xtime __section_xtime;
 struct timezone __sys_tz __section_sys_tz;
 #endif
 
-#if defined(__x86_64__)
 unsigned int cpu_khz;	/* Detected as we calibrate the TSC */
-#else
-unsigned long cpu_khz;	/* Detected as we calibrate the TSC */
-#endif
 
 extern unsigned long wall_jiffies;
 
 DEFINE_SPINLOCK(rtc_lock);
@@ -896,8 +892,17 @@ void local_teardown_timer_irq(void)
 	unbind_virq_from_irq(VIRQ_TIMER);
 }
 #endif
 
+int read_current_timer(unsigned long *timer_val)
+{
+	if (cur_timer->read_timer) {
+		*timer_val = cur_timer->read_timer();
+		return 0;
+	}
+	return -1;
+}
+
 /*
  * /proc/sys/xen: This really belongs in another file. It can stay here for
  * now however.
  */
Index: linux-2.6.12/arch/xen/i386/mm/init.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/mm/init.c
+++ linux-2.6.12/arch/xen/i386/mm/init.c
@@ -303,9 +303,9 @@ static void __init permanent_kmaps_init(
 void __init one_highpage_init(struct page *page, int pfn, int bad_ppro)
 {
 	if (page_is_ram(pfn) && !(bad_ppro && page_kills_ppro(pfn))) {
 		ClearPageReserved(page);
-		set_bit(PG_highmem, &page->flags);
+//		set_bit(PG_highmem, &page->flags);
 		set_page_count(page, 1);
 		if (pfn < xen_start_info.nr_pages)
 			__free_page(page);
 		totalhigh_pages++;
Index: linux-2.6.12/include/asm-xen/asm-i386/mmu_context.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-i386/mmu_context.h
+++ linux-2.6.12/include/asm-xen/asm-i386/mmu_context.h
@@ -22,11 +22,11 @@ static inline void enter_lazy_tlb(struct
 		per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_LAZY;
 #endif
 }
 
-#define prepare_arch_switch(rq,next)	__prepare_arch_switch()
-#define finish_arch_switch(rq, next)	spin_unlock_irq(&(rq)->lock)
-#define task_running(rq, p)		((rq)->curr == (p))
+#define prepare_arch_switch(next)	__prepare_arch_switch()
+//#define finish_arch_switch(rq, next)	spin_unlock_irq(&(rq)->lock)
+//#define task_running(rq, p)		((rq)->curr == (p))
 
 static inline void __prepare_arch_switch(void)
 {
 	/*
Index: linux-2.6.12/arch/xen/i386/kernel/traps.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/kernel/traps.c
+++ linux-2.6.12/arch/xen/i386/kernel/traps.c
@@ -302,9 +302,9 @@ void die(const char * str, struct pt_reg
 		.lock_owner_depth =	0
 	};
 	static int die_counter;
 
-	if (die.lock_owner != _smp_processor_id()) {
+	if (die.lock_owner != raw_smp_processor_id()) {
 		console_verbose();
 		spin_lock_irq(&die.lock);
 		die.lock_owner = smp_processor_id();
 		die.lock_owner_depth = 0;
Index: linux-2.6.12/arch/xen/i386/kernel/i386_ksyms.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/kernel/i386_ksyms.c
+++ linux-2.6.12/arch/xen/i386/kernel/i386_ksyms.c
@@ -55,9 +55,9 @@ extern void FASTCALL( __read_lock_failed
 extern struct drive_info_struct drive_info;
 EXPORT_SYMBOL(drive_info);
 #endif
 
-extern unsigned long cpu_khz;
+extern unsigned int cpu_khz;
 extern unsigned long get_cmos_time(void);
 
 /* platform dependent support */
 EXPORT_SYMBOL(boot_cpu_data);
@@ -68,9 +68,9 @@ EXPORT_SYMBOL(physnode_map);
 #ifdef CONFIG_X86_NUMAQ
 EXPORT_SYMBOL(xquad_portio);
 #endif
 EXPORT_SYMBOL(dump_thread);
-EXPORT_SYMBOL(dump_fpu);
+//EXPORT_SYMBOL(dump_fpu);
 EXPORT_SYMBOL_GPL(kernel_fpu_begin);
 EXPORT_SYMBOL(__ioremap);
 EXPORT_SYMBOL(ioremap_nocache);
 EXPORT_SYMBOL(iounmap);
@@ -119,10 +119,10 @@ EXPORT_SYMBOL(strnlen_user);
 EXPORT_SYMBOL(pci_mem_start);
 #endif
 
 #ifdef CONFIG_PCI_BIOS
-EXPORT_SYMBOL(pcibios_set_irq_routing);
-EXPORT_SYMBOL(pcibios_get_irq_routing_table);
+//EXPORT_SYMBOL(pcibios_set_irq_routing);
+//EXPORT_SYMBOL(pcibios_get_irq_routing_table);
 #endif
 
 #ifdef CONFIG_X86_USE_3DNOW
 EXPORT_SYMBOL(_mmx_memcpy);
Index: linux-2.6.12/arch/xen/i386/mm/pgtable.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/mm/pgtable.c
+++ linux-2.6.12/arch/xen/i386/mm/pgtable.c
@@ -40,9 +40,9 @@ void show_mem(void)
 	show_free_areas();
 	printk("Free swap:       %6ldkB\n", nr_swap_pages<<(PAGE_SHIFT-10));
 	for_each_pgdat(pgdat) {
 		for (i = 0; i < pgdat->node_spanned_pages; ++i) {
-			page = pgdat->node_mem_map + i;
+			page = pgdat_page_nr(pgdat, i);
 			total++;
 			if (PageHighMem(page))
 				highmem++;
 			if (PageReserved(page))
Index: linux-2.6.12/arch/xen/i386/mm/fault.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/mm/fault.c
+++ linux-2.6.12/arch/xen/i386/mm/fault.c
@@ -275,9 +275,9 @@ fastcall void do_page_fault(struct pt_re
 			      unsigned long address)
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	int write;
 	siginfo_t info;
 
 	/* Set the "privileged fault" bit to something sane. */
@@ -369,9 +369,10 @@ fastcall void do_page_fault(struct pt_re
 		 */
 		if (address + 32 < regs->esp)
 			goto bad_area;
 	}
-	if (expand_stack(vma, address))
+	find_vma_prev(current->mm, address, &prev_vma);
+	if (expand_stack(vma, address, prev_vma))
 		goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
  * we can handle it..
Index: linux-2.6.12/include/asm-xen/asm-i386/ptrace.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-i386/ptrace.h
+++ linux-2.6.12/include/asm-xen/asm-i386/ptrace.h
@@ -56,9 +56,10 @@ struct pt_regs {
 
 #ifdef __KERNEL__
 struct task_struct;
 extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code);
-#define user_mode(regs) ((VM_MASK & (regs)->eflags) || (2 & (regs)->xcs))
+#define user_mode(regs) (3 & (regs)->xcs)
+#define user_mode_vm(regs) ((VM_MASK & (regs)->eflags) || (2 & (regs)->xcs))
 #define instruction_pointer(regs) ((regs)->eip)
 #if defined(CONFIG_SMP) && defined(CONFIG_FRAME_POINTER)
 extern unsigned long profile_pc(struct pt_regs *regs);
 #else
Index: linux-2.6.12/arch/xen/i386/kernel/signal.c
===================================================================
--- linux-2.6.12.orig/arch/xen/i386/kernel/signal.c
+++ linux-2.6.12/arch/xen/i386/kernel/signal.c
@@ -601,12 +601,10 @@ int fastcall do_signal(struct pt_regs *r
 	 */
 	if ((regs->xcs & 2) != 2)
 		return 1;
 
-	if (current->flags & PF_FREEZE) {
-		refrigerator(0);
+	if (try_to_freeze())
 		goto no_signal;
-	}
 
 	if (!oldset)
 		oldset = &current->blocked;
 
Index: linux-2.6.12/drivers/xen/blktap/blktap_controlmsg.c
===================================================================
--- linux-2.6.12.orig/drivers/xen/blktap/blktap_controlmsg.c
+++ linux-2.6.12/drivers/xen/blktap/blktap_controlmsg.c
@@ -7,8 +7,9 @@
  * Copyright (c) 2004, Andrew Warfield
  *
  */
  
+#include <asm-xen/evtchn.h>
 #include "blktap.h"
 #include <asm-xen/evtchn.h>
 
 static char *blkif_state_name[] = {
Index: linux-2.6.12/arch/xen/kernel/vmlinux-i386.lds.S
===================================================================
--- /dev/null
+++ linux-2.6.12/arch/xen/kernel/vmlinux-i386.lds.S
@@ -0,0 +1,134 @@
+/* ld script to make i386 Linux kernel
+ * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
+ */
+
+#include <asm-generic/vmlinux.lds.h>
+#include <asm/thread_info.h>
+#include <asm/page.h>
+
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(startup_32)
+jiffies = jiffies_64;
+SECTIONS
+{
+  . = __PAGE_OFFSET + 0x100000;
+  /* read-only */
+  _text = .;			/* Text and read-only data */
+  .text : {
+	*(.text)
+	SCHED_TEXT
+	LOCK_TEXT
+	*(.fixup)
+	*(.gnu.warning)
+	} = 0x9090
+
+  _etext = .;			/* End of text section */
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  RODATA
+
+  /* writeable */
+  .data : {			/* Data */
+	*(.data)
+	CONSTRUCTORS
+	}
+
+  . = ALIGN(4096);
+  __nosave_begin = .;
+  .data_nosave : { *(.data.nosave) }
+  . = ALIGN(4096);
+  __nosave_end = .;
+
+  . = ALIGN(4096);
+  .data.page_aligned : { *(.data.idt) }
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
+
+  _edata = .;			/* End of data section */
+
+  . = ALIGN(THREAD_SIZE);	/* init_task */
+  .data.init_task : { *(.data.init_task) }
+
+  /* will be freed after init */
+  . = ALIGN(4096);		/* Init code and data */
+  __init_begin = .;
+  .init.text : { 
+	_sinittext = .;
+	*(.init.text)
+	_einittext = .;
+  }
+  .init.data : { *(.init.data) }
+  . = ALIGN(16);
+  __setup_start = .;
+  .init.setup : { *(.init.setup) }
+  __setup_end = .;
+  __initcall_start = .;
+  .initcall.init : {
+	*(.initcall1.init) 
+	*(.initcall2.init) 
+	*(.initcall3.init) 
+	*(.initcall4.init) 
+	*(.initcall5.init) 
+	*(.initcall6.init) 
+	*(.initcall7.init)
+  }
+  __initcall_end = .;
+  __con_initcall_start = .;
+  .con_initcall.init : { *(.con_initcall.init) }
+  __con_initcall_end = .;
+  SECURITY_INIT
+  . = ALIGN(4);
+  __alt_instructions = .;
+  .altinstructions : { *(.altinstructions) } 
+  __alt_instructions_end = .; 
+ .altinstr_replacement : { *(.altinstr_replacement) } 
+  /* .exit.text is discard at runtime, not link time, to deal with references
+     from .altinstructions and .eh_frame */
+  .exit.text : { *(.exit.text) }
+  .exit.data : { *(.exit.data) }
+  . = ALIGN(4096);
+  __initramfs_start = .;
+  .init.ramfs : { *(.init.ramfs) }
+  __initramfs_end = .;
+  . = ALIGN(32);
+  __per_cpu_start = .;
+  .data.percpu  : { *(.data.percpu) }
+  __per_cpu_end = .;
+  . = ALIGN(4096);
+  __init_end = .;
+  /* freed after init ends here */
+	
+  __bss_start = .;		/* BSS */
+  .bss : {
+	*(.bss.page_aligned)
+	*(.bss)
+  }
+  . = ALIGN(4);
+  __bss_stop = .; 
+
+  _end = . ;
+
+  /* This is where the kernel creates the early boot page tables */
+  . = ALIGN(4096);
+  pg0 = .;
+
+  /* Sections to be discarded */
+  /DISCARD/ : {
+	*(.exitcall.exit)
+	}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
Index: linux-2.6.12/arch/xen/kernel/Makefile
===================================================================
--- linux-2.6.12.orig/arch/xen/kernel/Makefile
+++ linux-2.6.12/arch/xen/kernel/Makefile
@@ -6,9 +6,9 @@ XENARCH	:= $(subst ",,$(CONFIG_XENARCH))
 
 CPPFLAGS_vmlinux.lds += -U$(XENARCH)
 
 $(obj)/vmlinux.lds.S:
-	@ln -fsn $(srctree)/arch/$(XENARCH)/kernel/vmlinux.lds.S $@
+	@ln -fsn $(srctree)/arch/xen/kernel/vmlinux-$(XENARCH).lds.S $@
 
 extra-y += vmlinux.lds
 
 obj-y   := ctrl_if.o evtchn.o fixup.o reboot.o gnttab.o devmem.o
Index: linux-2.6.12/arch/xen/Kconfig
===================================================================
--- linux-2.6.12.orig/arch/xen/Kconfig
+++ linux-2.6.12/arch/xen/Kconfig
@@ -202,8 +202,10 @@ endmenu
 endif
 
 source "fs/Kconfig"
 
+source "mm/Kconfig"
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
 
Index: linux-2.6.12/include/asm-xen/asm-i386/processor.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-i386/processor.h
+++ linux-2.6.12/include/asm-xen/asm-i386/processor.h
@@ -28,9 +28,9 @@ struct desc_struct {
 	unsigned long a,b;
 };
 
 #define desc_empty(desc) \
-		(!((desc)->a + (desc)->b))
+		(!((desc)->a | (desc)->b))
 
 #define desc_equal(desc1, desc2) \
 		(((desc1)->a == (desc2)->a) && ((desc1)->b == (desc2)->b))
 /*
Index: linux-2.6.12/include/asm-xen/asm-x86_64/processor.h
===================================================================
--- linux-2.6.12.orig/include/asm-xen/asm-x86_64/processor.h
+++ linux-2.6.12/include/asm-xen/asm-x86_64/processor.h
@@ -31,9 +31,9 @@
 #define VIP_MASK	0x00100000	/* virtual interrupt pending */
 #define ID_MASK		0x00200000
 
 #define desc_empty(desc) \
-               (!((desc)->a + (desc)->b))
+               (!((desc)->a | (desc)->b))
 
 #define desc_equal(desc1, desc2) \
                (((desc1)->a == (desc2)->a) && ((desc1)->b == (desc2)->b))
 
