From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: Update to 2.6.27-rc7
Patch-mainline: 2.6.27

 This patch contains the differences between 2.6.27-rc6 and -rc7.

Acked-by: Jeff Mahoney <jeffm@suse.com>
Automatically created from "patches.kernel.org/patch-2.6.27-rc6-rc7" by xen-port-patches.py

Index: head-2008-09-25/arch/x86/kernel/cpu/common-xen.c
===================================================================
--- head-2008-09-25.orig/arch/x86/kernel/cpu/common-xen.c	2008-09-25 14:41:22.000000000 +0200
+++ head-2008-09-25/arch/x86/kernel/cpu/common-xen.c	2008-09-25 14:44:54.000000000 +0200
@@ -351,31 +351,15 @@ static void __init early_cpu_detect(void
 
 /*
  * The NOPL instruction is supposed to exist on all CPUs with
- * family >= 6, unfortunately, that's not true in practice because
+ * family >= 6; unfortunately, that's not true in practice because
  * of early VIA chips and (more importantly) broken virtualizers that
- * are not easy to detect.  Hence, probe for it based on first
- * principles.
+ * are not easy to detect.  In the latter case it doesn't even *fail*
+ * reliably, so probing for it doesn't even work.  Disable it completely
+ * unless we can find a reliable way to detect all the broken cases.
  */
 static void __cpuinit detect_nopl(struct cpuinfo_x86 *c)
 {
-	const u32 nopl_signature = 0x888c53b1; /* Random number */
-	u32 has_nopl = nopl_signature;
-
 	clear_cpu_cap(c, X86_FEATURE_NOPL);
-	if (c->x86 >= 6) {
-		asm volatile("\n"
-			     "1:      .byte 0x0f,0x1f,0xc0\n" /* nopl %eax */
-			     "2:\n"
-			     "        .section .fixup,\"ax\"\n"
-			     "3:      xor %0,%0\n"
-			     "        jmp 2b\n"
-			     "        .previous\n"
-			     _ASM_EXTABLE(1b,3b)
-			     : "+a" (has_nopl));
-
-		if (has_nopl == nopl_signature)
-			set_cpu_cap(c, X86_FEATURE_NOPL);
-	}
 }
 
 static void __cpuinit generic_identify(struct cpuinfo_x86 *c)
Index: head-2008-09-25/arch/x86/kernel/setup-xen.c
===================================================================
--- head-2008-09-25.orig/arch/x86/kernel/setup-xen.c	2008-09-25 14:41:20.000000000 +0200
+++ head-2008-09-25/arch/x86/kernel/setup-xen.c	2008-09-25 14:44:54.000000000 +0200
@@ -793,6 +793,10 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
+#ifdef CONFIG_X86_64
+	check_efer();
+#endif
+
 #if defined(CONFIG_VMI) && defined(CONFIG_X86_32)
 	/*
 	 * Must be before kernel pagetables are setup
@@ -866,7 +870,6 @@ void __init setup_arch(char **cmdline_p)
 	num_physpages = max_pfn;
 	max_mapnr = max_pfn;
 
-	check_efer();
 
 	/* How many end-of-memory variables you have, grandma! */
 	/* need this before calling reserve_initrd */
Index: head-2008-09-25/arch/x86/mm/init_32-xen.c
===================================================================
--- head-2008-09-25.orig/arch/x86/mm/init_32-xen.c	2008-09-25 14:40:36.000000000 +0200
+++ head-2008-09-25/arch/x86/mm/init_32-xen.c	2008-09-25 14:46:43.000000000 +0200
@@ -456,11 +456,7 @@ static void __init pagetable_init(void)
 {
 	pgd_t *pgd_base = (pgd_t *)xen_start_info->pt_base;
 
-	xen_pagetable_setup_start(pgd_base);
-
 	permanent_kmaps_init(pgd_base);
-
-	xen_pagetable_setup_done(pgd_base);
 }
 
 #if defined(CONFIG_ACPI_SLEEP) && !defined(CONFIG_XEN)
