From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux 2.6.29-rc5

 This patch contains the differences between 2.6.29-rc4 and -rc5.

Acked-by: Jeff Mahoney <jeffm@suse.com>
Automatically created from "patches.kernel.org/patch-2.6.29-rc4-rc5" by xen-port-patches.py

--- head-2009-02-18.orig/arch/x86/include/mach-xen/asm/pgtable.h	2009-03-04 16:16:19.000000000 +0100
+++ head-2009-02-18/arch/x86/include/mach-xen/asm/pgtable.h	2009-02-18 15:08:18.000000000 +0100
@@ -318,41 +318,43 @@ static inline pte_t pte_mkspecial(pte_t 
 
 extern pteval_t __supported_pte_mask;
 
-static inline pte_t pfn_pte(unsigned long page_nr, pgprot_t pgprot)
+/*
+ * Mask out unsupported bits in a present pgprot.  Non-present pgprots
+ * can use those bits for other purposes, so leave them be.
+ */
+static inline pgprotval_t massage_pgprot(pgprot_t pgprot)
 {
-	pgprotval_t prot = pgprot_val(pgprot);
+	pgprotval_t protval = pgprot_val(pgprot);
 
-	if (prot & _PAGE_PRESENT)
-		prot &= __supported_pte_mask;
-	return __pte(((phys_addr_t)page_nr << PAGE_SHIFT) | prot);
+	if (protval & _PAGE_PRESENT)
+		protval &= __supported_pte_mask;
+
+	return protval;
 }
 
-static inline pte_t pfn_pte_ma(unsigned long page_nr, pgprot_t pgprot)
+static inline pte_t pfn_pte(unsigned long page_nr, pgprot_t pgprot)
 {
-	pgprotval_t prot = pgprot_val(pgprot);
+	return __pte(((phys_addr_t)page_nr << PAGE_SHIFT) |
+		     massage_pgprot(pgprot));
+}
 
-	if (prot & _PAGE_PRESENT)
-		prot &= __supported_pte_mask;
-	return __pte_ma(((phys_addr_t)page_nr << PAGE_SHIFT) | prot);
+static inline pte_t pfn_pte_ma(unsigned long page_nr, pgprot_t pgprot)
+{
+	return __pte_ma(((phys_addr_t)page_nr << PAGE_SHIFT) |
+			massage_pgprot(pgprot));
 }
 
 static inline pmd_t pfn_pmd(unsigned long page_nr, pgprot_t pgprot)
 {
-	pgprotval_t prot = pgprot_val(pgprot);
-
-	if (prot & _PAGE_PRESENT)
-		prot &= __supported_pte_mask;
-	return __pmd(((phys_addr_t)page_nr << PAGE_SHIFT) | prot);
+	return __pmd(((phys_addr_t)page_nr << PAGE_SHIFT) |
+		     massage_pgprot(pgprot));
 }
 
 static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
-	pgprotval_t prot = pgprot_val(newprot);
 	pteval_t val = pte_val(pte) & _PAGE_CHG_MASK;
 
-	if (prot & _PAGE_PRESENT)
-		prot &= __supported_pte_mask;
-	val |= prot & ~_PAGE_CHG_MASK;
+	val |= massage_pgprot(newprot) & ~_PAGE_CHG_MASK;
 
 	return __pte(val);
 }
@@ -368,9 +370,7 @@ static inline pgprot_t pgprot_modify(pgp
 
 #define pte_pgprot(x) __pgprot(pte_flags(x) & PTE_FLAGS_MASK)
 
-#define canon_pgprot(p) __pgprot(pgprot_val(p) & _PAGE_PRESENT \
-				 ? pgprot_val(p) & __supported_pte_mask \
-				 : pgprot_val(p))
+#define canon_pgprot(p) __pgprot(massage_pgprot(p))
 
 static inline int is_new_memtype_allowed(unsigned long flags,
 						unsigned long new_flags)
--- head-2009-02-18.orig/arch/x86/include/mach-xen/asm/processor.h	2009-03-04 16:16:19.000000000 +0100
+++ head-2009-02-18/arch/x86/include/mach-xen/asm/processor.h	2009-02-18 15:02:47.000000000 +0100
@@ -359,7 +359,7 @@ struct i387_soft_struct {
 	u8			no_update;
 	u8			rm;
 	u8			alimit;
-	struct info		*info;
+	struct math_emu_info	*info;
 	u32			entry_eip;
 };
 
--- head-2009-02-18.orig/arch/x86/include/mach-xen/asm/spinlock.h	2009-03-04 16:40:33.000000000 +0100
+++ head-2009-02-18/arch/x86/include/mach-xen/asm/spinlock.h	2009-02-18 15:02:47.000000000 +0100
@@ -311,6 +311,7 @@ static inline int __raw_spin_is_contende
 {
 	return __ticket_spin_is_contended(lock);
 }
+#define __raw_spin_is_contended	__raw_spin_is_contended
 
 static __always_inline void __raw_spin_lock(raw_spinlock_t *lock)
 {
--- head-2009-02-18.orig/arch/x86/kernel/io_apic-xen.c	2009-03-05 09:49:57.000000000 +0100
+++ head-2009-02-18/arch/x86/kernel/io_apic-xen.c	2009-03-05 09:50:13.000000000 +0100
@@ -3938,14 +3938,24 @@ int __init io_apic_get_redir_entries (in
 void __init probe_nr_irqs_gsi(void)
 {
 #ifndef CONFIG_XEN
-	int idx;
 	int nr = 0;
 
-	for (idx = 0; idx < nr_ioapics; idx++)
-		nr += io_apic_get_redir_entries(idx) + 1;
-
-	if (nr > nr_irqs_gsi)
+	nr = acpi_probe_gsi();
+	if (nr > nr_irqs_gsi) {
 		nr_irqs_gsi = nr;
+	} else {
+		/* for acpi=off or acpi is not compiled in */
+		int idx;
+
+		nr = 0;
+		for (idx = 0; idx < nr_ioapics; idx++)
+			nr += io_apic_get_redir_entries(idx) + 1;
+
+		if (nr > nr_irqs_gsi)
+			nr_irqs_gsi = nr;
+	}
+
+	printk(KERN_DEBUG "nr_irqs_gsi: %d\n", nr_irqs_gsi);
 #endif
 }
 
--- head-2009-02-18.orig/arch/x86/kernel/process-xen.c	2009-03-04 16:16:19.000000000 +0100
+++ head-2009-02-18/arch/x86/kernel/process-xen.c	2009-02-18 15:02:47.000000000 +0100
@@ -176,6 +176,9 @@ void mwait_idle_with_hints(unsigned long
 
 	trace_power_start(&it, POWER_CSTATE, (ax>>4)+1);
 	if (!need_resched()) {
+		if (cpu_has(&current_cpu_data, X86_FEATURE_CLFLUSH_MONITOR))
+			clflush((void *)&current_thread_info()->flags);
+
 		__monitor((void *)&current_thread_info()->flags, 0, 0);
 		smp_mb();
 		if (!need_resched())
@@ -190,6 +193,9 @@ static void mwait_idle(void)
 	struct power_trace it;
 	if (!need_resched()) {
 		trace_power_start(&it, POWER_CSTATE, 1);
+		if (cpu_has(&current_cpu_data, X86_FEATURE_CLFLUSH_MONITOR))
+			clflush((void *)&current_thread_info()->flags);
+
 		__monitor((void *)&current_thread_info()->flags, 0, 0);
 		smp_mb();
 		if (!need_resched())
--- head-2009-02-18.orig/arch/x86/kernel/process_64-xen.c	2009-03-04 16:16:19.000000000 +0100
+++ head-2009-02-18/arch/x86/kernel/process_64-xen.c	2009-02-18 15:02:47.000000000 +0100
@@ -43,6 +43,7 @@
 #include <linux/uaccess.h>
 #include <linux/io.h>
 #include <linux/ftrace.h>
+#include <linux/dmi.h>
 
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -160,14 +161,18 @@ void __show_regs(struct pt_regs *regs, i
 	unsigned long d0, d1, d2, d3, d6, d7;
 	unsigned int fsindex, gsindex;
 	unsigned int ds, cs, es;
+	const char *board;
 
 	printk("\n");
 	print_modules();
-	printk(KERN_INFO "Pid: %d, comm: %.20s %s %s %.*s\n",
+	board = dmi_get_system_info(DMI_PRODUCT_NAME);
+	if (!board)
+		board = "";
+	printk(KERN_INFO "Pid: %d, comm: %.20s %s %s %.*s %s\n",
 		current->pid, current->comm, print_tainted(),
 		init_utsname()->release,
 		(int)strcspn(init_utsname()->version, " "),
-		init_utsname()->version);
+		init_utsname()->version, board);
 	printk(KERN_INFO "RIP: %04lx:[<%016lx>] ", regs->cs & 0xffff, regs->ip);
 	printk_address(regs->ip, 1);
 	printk(KERN_INFO "RSP: %04lx:%016lx  EFLAGS: %08lx\n", regs->ss,
--- head-2009-02-18.orig/arch/x86/kernel/setup-xen.c	2009-03-04 16:16:19.000000000 +0100
+++ head-2009-02-18/arch/x86/kernel/setup-xen.c	2009-02-18 15:02:47.000000000 +0100
@@ -678,7 +678,7 @@ struct x86_quirks *x86_quirks __initdata
 static int __init dmi_low_memory_corruption(const struct dmi_system_id *d)
 {
 	printk(KERN_NOTICE
-		"%s detected: BIOS may corrupt low RAM, working it around.\n",
+		"%s detected: BIOS may corrupt low RAM, working around it.\n",
 		d->ident);
 
 	e820_update_range(0, 0x10000, E820_RAM, E820_RESERVED);
--- head-2009-02-18.orig/arch/x86/kernel/traps-xen.c	2009-03-04 16:16:19.000000000 +0100
+++ head-2009-02-18/arch/x86/kernel/traps-xen.c	2009-02-18 15:13:01.000000000 +0100
@@ -893,7 +893,7 @@ asmlinkage void math_state_restore(void)
 EXPORT_SYMBOL_GPL(math_state_restore);
 
 #ifndef CONFIG_MATH_EMULATION
-asmlinkage void math_emulate(long arg)
+void math_emulate(struct math_emu_info *info)
 {
 	printk(KERN_EMERG
 		"math-emulation not enabled and no coprocessor found.\n");
@@ -903,16 +903,19 @@ asmlinkage void math_emulate(long arg)
 }
 #endif /* CONFIG_MATH_EMULATION */
 
-dotraplinkage void __kprobes
-do_device_not_available(struct pt_regs *regs, long error)
+dotraplinkage void __kprobes do_device_not_available(struct pt_regs regs)
 {
 #if defined(CONFIG_X86_32) && !defined(CONFIG_XEN)
 	if (read_cr0() & X86_CR0_EM) {
-		conditional_sti(regs);
-		math_emulate(0);
+		struct math_emu_info info = { };
+
+		conditional_sti(&regs);
+
+		info.regs = &regs;
+		math_emulate(&info);
 	} else {
 		math_state_restore(); /* interrupts still off */
-		conditional_sti(regs);
+		conditional_sti(&regs);
 	}
 #else
 	math_state_restore();
