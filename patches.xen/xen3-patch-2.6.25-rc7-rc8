From: kernel.org
Subject: 2.6.25-rc8

## Automatically generated incremental diff
## From:   linux-2.6.25-rc7
## To:     linux-2.6.25-rc8
## Robot:  $Id: make-incremental-diff,v 1.12 2004/01/06 07:19:36 hpa Exp $

Automatically created from "patches.kernel.org/patch-2.6.25-rc7-rc8" by xen-port-patches.py
Acked-by: jbeulich@novell.com

Index: head-2008-04-02/arch/x86/kernel/setup_32-xen.c
===================================================================
--- head-2008-04-02.orig/arch/x86/kernel/setup_32-xen.c	2008-04-02 14:25:44.000000000 +0200
+++ head-2008-04-02/arch/x86/kernel/setup_32-xen.c	2008-04-02 15:13:11.000000000 +0200
@@ -446,8 +446,6 @@ static unsigned long __init setup_memory
  	min_low_pfn = PFN_UP(__pa(xen_start_info->pt_base)) +
 		xen_start_info->nr_pt_frames;
 
-	find_max_pfn();
-
 	max_low_pfn = find_max_low_pfn();
 
 #ifdef CONFIG_HIGHMEM
@@ -844,15 +842,16 @@ void __init setup_arch(char **cmdline_p)
 	if (efi_enabled)
 		efi_init();
 
-	max_low_pfn = setup_memory();
-
 	/* update e820 for memory not covered by WB MTRRs */
+	find_max_pfn();
 	mtrr_bp_init();
 #ifndef CONFIG_XEN
 	if (mtrr_trim_uncached_memory(max_pfn))
-		max_low_pfn = setup_memory();
+		find_max_pfn();
 #endif
 
+	max_low_pfn = setup_memory();
+
 #ifdef CONFIG_VMI
 	/*
 	 * Must be after max_low_pfn is determined, and before kernel
Index: head-2008-04-02/arch/x86/kernel/setup_64-xen.c
===================================================================
--- head-2008-04-02.orig/arch/x86/kernel/setup_64-xen.c	2008-04-02 14:25:44.000000000 +0200
+++ head-2008-04-02/arch/x86/kernel/setup_64-xen.c	2008-04-02 15:08:41.000000000 +0200
@@ -1052,7 +1052,7 @@ static void __cpuinit srat_detect_node(v
 	/* Don't do the funky fallback heuristics the AMD version employs
 	   for now. */
 	node = apicid_to_node[apicid];
-	if (node == NUMA_NO_NODE)
+	if (node == NUMA_NO_NODE || !node_online(node))
 		node = first_node(node_online_map);
 	numa_set_node(cpu, node);
 
Index: head-2008-04-02/arch/x86/mm/fault-xen.c
===================================================================
--- head-2008-04-02.orig/arch/x86/mm/fault-xen.c	2008-04-02 14:25:44.000000000 +0200
+++ head-2008-04-02/arch/x86/mm/fault-xen.c	2008-04-02 15:08:41.000000000 +0200
@@ -91,12 +91,10 @@ static int is_prefetch(struct pt_regs *r
 	int prefetch = 0;
 	unsigned char *max_instr;
 
-#ifdef CONFIG_X86_32
-	if (!(__supported_pte_mask & _PAGE_NX))
-		return 0;
-#endif
-
-	/* If it was a exec fault on NX page, ignore */
+	/*
+	 * If it was a exec (instruction fetch) fault on NX page, then
+	 * do not ignore the fault:
+	 */
 	if (error_code & PF_INSTR)
 		return 0;
 
Index: head-2008-04-02/arch/x86/mm/highmem_32-xen.c
===================================================================
--- head-2008-04-02.orig/arch/x86/mm/highmem_32-xen.c	2008-04-02 14:25:44.000000000 +0200
+++ head-2008-04-02/arch/x86/mm/highmem_32-xen.c	2008-04-02 15:08:41.000000000 +0200
@@ -73,15 +73,15 @@ void *kmap_atomic_prot(struct page *page
 {
 	enum fixed_addresses idx;
 	unsigned long vaddr;
-	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
-
-	debug_kmap_atomic_prot(type);
 
+	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
 	pagefault_disable();
 
 	if (!PageHighMem(page))
 		return page_address(page);
 
+	debug_kmap_atomic_prot(type);
+
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
 	BUG_ON(!pte_none(*(kmap_pte-idx)));
Index: head-2008-04-02/arch/x86/mm/ioremap-xen.c
===================================================================
--- head-2008-04-02.orig/arch/x86/mm/ioremap-xen.c	2008-04-02 15:58:11.000000000 +0200
+++ head-2008-04-02/arch/x86/mm/ioremap-xen.c	2008-04-02 15:58:17.000000000 +0200
@@ -302,7 +302,11 @@ static void __iomem *__ioremap(resource_
 	switch (mode) {
 	case IOR_MODE_UNCACHED:
 	default:
-		prot = PAGE_KERNEL_NOCACHE;
+		/*
+		 * FIXME: we will use UC MINUS for now, as video fb drivers
+		 * depend on it. Upcoming ioremap_wc() will fix this behavior.
+		 */
+		prot = PAGE_KERNEL_UC_MINUS;
 		break;
 	case IOR_MODE_CACHED:
 		prot = PAGE_KERNEL;
Index: head-2008-04-02/arch/x86/mm/pageattr-xen.c
===================================================================
--- head-2008-04-02.orig/arch/x86/mm/pageattr-xen.c	2008-04-02 14:25:44.000000000 +0200
+++ head-2008-04-02/arch/x86/mm/pageattr-xen.c	2008-04-02 15:08:41.000000000 +0200
@@ -1103,7 +1103,7 @@ static inline int change_page_attr_clear
 int set_memory_uc(unsigned long addr, int numpages)
 {
 	return change_page_attr_set(addr, numpages,
-				    __pgprot(_PAGE_PCD | _PAGE_PWT));
+				    __pgprot(_PAGE_PCD));
 }
 EXPORT_SYMBOL(set_memory_uc);
 
Index: head-2008-04-02/include/asm-x86/mach-xen/asm/pgtable.h
===================================================================
--- head-2008-04-02.orig/include/asm-x86/mach-xen/asm/pgtable.h	2008-04-02 14:47:31.000000000 +0200
+++ head-2008-04-02/include/asm-x86/mach-xen/asm/pgtable.h	2008-04-02 15:08:41.000000000 +0200
@@ -94,6 +94,7 @@ extern pteval_t __PAGE_KERNEL, __PAGE_KE
 #define __PAGE_KERNEL_RX		(__PAGE_KERNEL_EXEC & ~_PAGE_RW)
 #define __PAGE_KERNEL_EXEC_NOCACHE	(__PAGE_KERNEL_EXEC | _PAGE_PCD | _PAGE_PWT)
 #define __PAGE_KERNEL_NOCACHE		(__PAGE_KERNEL | _PAGE_PCD | _PAGE_PWT)
+#define __PAGE_KERNEL_UC_MINUS		(__PAGE_KERNEL | _PAGE_PCD)
 #define __PAGE_KERNEL_VSYSCALL		(__PAGE_KERNEL_RX | _PAGE_USER)
 #define __PAGE_KERNEL_VSYSCALL_NOCACHE	(__PAGE_KERNEL_VSYSCALL | _PAGE_PCD | _PAGE_PWT)
 #define __PAGE_KERNEL_LARGE		(__PAGE_KERNEL | _PAGE_PSE)
@@ -109,6 +110,7 @@ extern pteval_t __PAGE_KERNEL, __PAGE_KE
 #define PAGE_KERNEL_EXEC		MAKE_GLOBAL(__PAGE_KERNEL_EXEC)
 #define PAGE_KERNEL_RX			MAKE_GLOBAL(__PAGE_KERNEL_RX)
 #define PAGE_KERNEL_NOCACHE		MAKE_GLOBAL(__PAGE_KERNEL_NOCACHE)
+#define PAGE_KERNEL_UC_MINUS		MAKE_GLOBAL(__PAGE_KERNEL_UC_MINUS)
 #define PAGE_KERNEL_EXEC_NOCACHE	MAKE_GLOBAL(__PAGE_KERNEL_EXEC_NOCACHE)
 #define PAGE_KERNEL_LARGE		MAKE_GLOBAL(__PAGE_KERNEL_LARGE)
 #define PAGE_KERNEL_LARGE_EXEC		MAKE_GLOBAL(__PAGE_KERNEL_LARGE_EXEC)
