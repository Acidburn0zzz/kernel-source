From: tpmdd_devel@lists.sourceforge.net
Subject: Update of TPM drivers

The changes from xen mercurial repo rev 6610 compared to 2.6.13.

DON'T APPLY!

Signed-off-by: Kurt Garloff <garloff@suse.de>

Index: linux-2.6.13/drivers/char/tpm/tpm.c
===================================================================
--- linux-2.6.13.orig/drivers/char/tpm/tpm.c
+++ linux-2.6.13/drivers/char/tpm/tpm.c
@@ -9,36 +9,33 @@
  *
  * Maintained by: <tpmdd_devel@lists.sourceforge.net>
  *
  * Device driver for TCG/TCPA TPM (trusted platform module).
- * Specifications at www.trustedcomputinggroup.org	 
+ * Specifications at www.trustedcomputinggroup.org
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation, version 2 of the
  * License.
- * 
+ *
  * Note, the TPM chip is not interrupt driven (only polling)
  * and can have very long timeouts (minutes!). Hence the unusual
- * calls to msleep.
+ * calls to schedule_timeout.
  *
  */
 
 #include <linux/sched.h>
 #include <linux/poll.h>
 #include <linux/spinlock.h>
 #include "tpm.h"
 
-enum tpm_const {
-	TPM_MINOR = 224,	/* officially assigned */
-	TPM_BUFSIZE = 2048,
-	TPM_NUM_DEVICES = 256,
-	TPM_NUM_MASK_ENTRIES = TPM_NUM_DEVICES / (8 * sizeof(int))
-};
+#define	TPM_MINOR			224	/* officially assigned */
+
+#define	TPM_BUFSIZE			2048
 
 static LIST_HEAD(tpm_chip_list);
 static DEFINE_SPINLOCK(driver_lock);
-static int dev_mask[TPM_NUM_MASK_ENTRIES];
+static int dev_mask[32];
 
 static void user_reader_timeout(unsigned long ptr)
 {
 	struct tpm_chip *chip = (struct tpm_chip *) ptr;
@@ -48,19 +45,28 @@ static void user_reader_timeout(unsigned
 	memset(chip->data_buffer, 0, TPM_BUFSIZE);
 	up(&chip->buffer_mutex);
 }
 
+void tpm_time_expired(unsigned long ptr)
+{
+	int *exp = (int *) ptr;
+	*exp = 1;
+}
+
+EXPORT_SYMBOL_GPL(tpm_time_expired);
+
 /*
  * Internal kernel interface to transmit TPM commands
  */
 static ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,
 			    size_t bufsiz)
 {
-	ssize_t rc;
+	ssize_t len;
 	u32 count;
-	unsigned long stop;
+	__be32 *native_size;
 
-	count = be32_to_cpu(*((__be32 *) (buf + 2)));
+	native_size = (__force __be32 *) (buf + 2);
+	count = be32_to_cpu(*native_size);
 
 	if (count == 0)
 		return -ENODATA;
 	if (count > bufsiz) {
@@ -70,51 +76,55 @@ static ssize_t tpm_transmit(struct tpm_c
 	}
 
 	down(&chip->tpm_mutex);
 
-	if ((rc = chip->vendor->send(chip, (u8 *) buf, count)) < 0) {
+	if ((len = chip->vendor->send(chip, (u8 *) buf, count)) < 0) {
 		dev_err(&chip->pci_dev->dev,
-			"tpm_transmit: tpm_send: error %zd\n", rc);
-		goto out;
+			"tpm_transmit: tpm_send: error %zd\n", len);
+		return len;
 	}
 
-	stop = jiffies + 2 * 60 * HZ;
+	down(&chip->timer_manipulation_mutex);
+	chip->time_expired = 0;
+	init_timer(&chip->device_timer);
+	chip->device_timer.function = tpm_time_expired;
+	chip->device_timer.expires = jiffies + 2 * 60 * HZ;
+	chip->device_timer.data = (unsigned long) &chip->time_expired;
+	add_timer(&chip->device_timer);
+	up(&chip->timer_manipulation_mutex);
+
 	do {
 		u8 status = inb(chip->vendor->base + 1);
 		if ((status & chip->vendor->req_complete_mask) ==
 		    chip->vendor->req_complete_val) {
+			down(&chip->timer_manipulation_mutex);
+			del_singleshot_timer_sync(&chip->device_timer);
+			up(&chip->timer_manipulation_mutex);
 			goto out_recv;
 		}
-
-		if ((status == chip->vendor->req_canceled)) {
-			dev_err(&chip->pci_dev->dev, "Operation Canceled\n");
-			rc = -ECANCELED;
-			goto out;
-		}
-
-		msleep(TPM_TIMEOUT);	/* CHECK */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(TPM_TIMEOUT);
 		rmb();
-	} while (time_before(jiffies, stop));
+	} while (!chip->time_expired);
 
 
 	chip->vendor->cancel(chip);
-	dev_err(&chip->pci_dev->dev, "Operation Timed out\n");
-	rc = -ETIME;
-	goto out;
+	dev_err(&chip->pci_dev->dev, "Time expired\n");
+	up(&chip->tpm_mutex);
+	return -EIO;
 
 out_recv:
-	rc = chip->vendor->recv(chip, (u8 *) buf, bufsiz);
-	if (rc < 0)
+	len = chip->vendor->recv(chip, (u8 *) buf, bufsiz);
+	if (len < 0)
 		dev_err(&chip->pci_dev->dev,
-			"tpm_transmit: tpm_recv: error %zd\n", rc);
-out:
+			"tpm_transmit: tpm_recv: error %zd\n", len);
 	up(&chip->tpm_mutex);
-	return rc;
+	return len;
 }
 
 #define TPM_DIGEST_SIZE 20
 #define CAP_PCR_RESULT_SIZE 18
-static const u8 cap_pcr[] = {
+static u8 cap_pcr[] = {
 	0, 193,			/* TPM_TAG_RQU_COMMAND */
 	0, 0, 0, 22,		/* length */
 	0, 0, 0, 101,		/* TPM_ORD_GetCapability */
 	0, 0, 0, 5,
@@ -122,108 +132,91 @@ static const u8 cap_pcr[] = {
 	0, 0, 1, 1
 };
 
 #define READ_PCR_RESULT_SIZE 30
-static const u8 pcrread[] = {
+static u8 pcrread[] = {
 	0, 193,			/* TPM_TAG_RQU_COMMAND */
 	0, 0, 0, 14,		/* length */
 	0, 0, 0, 21,		/* TPM_ORD_PcrRead */
 	0, 0, 0, 0		/* PCR index */
 };
 
-ssize_t tpm_show_pcrs(struct device *dev, struct device_attribute *attr,
-		      char *buf)
+static ssize_t show_pcrs(struct device *dev, char *buf)
 {
 	u8 data[READ_PCR_RESULT_SIZE];
 	ssize_t len;
-	int i, j, num_pcrs;
-	__be32 index;
+	int i, j, index, num_pcrs;
 	char *str = buf;
 
 	struct tpm_chip *chip =
-	    pci_get_drvdata(to_pci_dev(dev));
+	    pci_get_drvdata(container_of(dev, struct pci_dev, dev));
 	if (chip == NULL)
 		return -ENODEV;
 
 	memcpy(data, cap_pcr, sizeof(cap_pcr));
 	if ((len = tpm_transmit(chip, data, sizeof(data)))
-	    < CAP_PCR_RESULT_SIZE) {
-		dev_dbg(&chip->pci_dev->dev, "A TPM error (%d) occurred "
-				"attempting to determine the number of PCRS\n",
-			be32_to_cpu(*((__be32 *) (data + 6))));
-		return 0;
-	}
+	    < CAP_PCR_RESULT_SIZE)
+		return len;
 
-	num_pcrs = be32_to_cpu(*((__be32 *) (data + 14)));
+	num_pcrs = be32_to_cpu(*((__force __be32 *) (data + 14)));
 
 	for (i = 0; i < num_pcrs; i++) {
 		memcpy(data, pcrread, sizeof(pcrread));
 		index = cpu_to_be32(i);
 		memcpy(data + 10, &index, 4);
 		if ((len = tpm_transmit(chip, data, sizeof(data)))
-		    < READ_PCR_RESULT_SIZE){
-			dev_dbg(&chip->pci_dev->dev, "A TPM error (%d) occurred"
-				" attempting to read PCR %d of %d\n",
-				be32_to_cpu(*((__be32 *) (data + 6))), i, num_pcrs);
-			goto out;
-		}
+		    < READ_PCR_RESULT_SIZE)
+			return len;
 		str += sprintf(str, "PCR-%02d: ", i);
 		for (j = 0; j < TPM_DIGEST_SIZE; j++)
 			str += sprintf(str, "%02X ", *(data + 10 + j));
 		str += sprintf(str, "\n");
 	}
-out:
 	return str - buf;
 }
-EXPORT_SYMBOL_GPL(tpm_show_pcrs);
+
+static DEVICE_ATTR(pcrs, S_IRUGO, show_pcrs, NULL);
 
 #define  READ_PUBEK_RESULT_SIZE 314
-static const u8 readpubek[] = {
+static u8 readpubek[] = {
 	0, 193,			/* TPM_TAG_RQU_COMMAND */
 	0, 0, 0, 30,		/* length */
 	0, 0, 0, 124,		/* TPM_ORD_ReadPubek */
 };
 
-ssize_t tpm_show_pubek(struct device *dev, struct device_attribute *attr,
-		       char *buf)
+static ssize_t show_pubek(struct device *dev, char *buf)
 {
-	u8 *data;
+	u8 data[READ_PUBEK_RESULT_SIZE];
 	ssize_t len;
-	int i, rc;
+	__be32 *native_val;
+	int i;
 	char *str = buf;
 
 	struct tpm_chip *chip =
-	    pci_get_drvdata(to_pci_dev(dev));
+	    pci_get_drvdata(container_of(dev, struct pci_dev, dev));
 	if (chip == NULL)
 		return -ENODEV;
 
-	data = kmalloc(READ_PUBEK_RESULT_SIZE, GFP_KERNEL);
-	if (!data)
-		return -ENOMEM;
-
 	memcpy(data, readpubek, sizeof(readpubek));
 	memset(data + sizeof(readpubek), 0, 20);	/* zero nonce */
 
-	if ((len = tpm_transmit(chip, data, READ_PUBEK_RESULT_SIZE)) <
-	    READ_PUBEK_RESULT_SIZE) {
-		dev_dbg(&chip->pci_dev->dev, "A TPM error (%d) occurred "
-				"attempting to read the PUBEK\n",
-			    be32_to_cpu(*((__be32 *) (data + 6))));
-		rc = 0;
-		goto out;
-	}
+	if ((len = tpm_transmit(chip, data, sizeof(data))) <
+	    READ_PUBEK_RESULT_SIZE)
+		return len;
 
-	/* 
+	/*
 	   ignore header 10 bytes
 	   algorithm 32 bits (1 == RSA )
 	   encscheme 16 bits
 	   sigscheme 16 bits
-	   parameters (RSA 12->bytes: keybit, #primes, expbit)  
+	   parameters (RSA 12->bytes: keybit, #primes, expbit)
 	   keylenbytes 32 bits
 	   256 byte modulus
 	   ignore checksum 20 bytes
 	 */
 
+	native_val = (__force __be32 *) (data + 34);
+
 	str +=
 	    sprintf(str,
 		    "Algorithm: %02X %02X %02X %02X\nEncscheme: %02X %02X\n"
 		    "Sigscheme: %02X %02X\nParameters: %02X %02X %02X %02X"
@@ -232,51 +225,48 @@ ssize_t tpm_show_pubek(struct device *de
 		    data[10], data[11], data[12], data[13], data[14],
 		    data[15], data[16], data[17], data[22], data[23],
 		    data[24], data[25], data[26], data[27], data[28],
 		    data[29], data[30], data[31], data[32], data[33],
-		    be32_to_cpu(*((__be32 *) (data + 34))));
+		    be32_to_cpu(*native_val)
+	    );
 
 	for (i = 0; i < 256; i++) {
-		str += sprintf(str, "%02X ", data[i + 38]);
+		str += sprintf(str, "%02X ", data[i + 39]);
 		if ((i + 1) % 16 == 0)
 			str += sprintf(str, "\n");
 	}
-	rc = str - buf;
-out:
-	kfree(data);
-	return rc;
+	return str - buf;
 }
 
-EXPORT_SYMBOL_GPL(tpm_show_pubek);
+static DEVICE_ATTR(pubek, S_IRUGO, show_pubek, NULL);
 
 #define CAP_VER_RESULT_SIZE 18
-static const u8 cap_version[] = {
+static u8 cap_version[] = {
 	0, 193,			/* TPM_TAG_RQU_COMMAND */
 	0, 0, 0, 18,		/* length */
 	0, 0, 0, 101,		/* TPM_ORD_GetCapability */
 	0, 0, 0, 6,
 	0, 0, 0, 0
 };
 
 #define CAP_MANUFACTURER_RESULT_SIZE 18
-static const u8 cap_manufacturer[] = {
+static u8 cap_manufacturer[] = {
 	0, 193,			/* TPM_TAG_RQU_COMMAND */
 	0, 0, 0, 22,		/* length */
 	0, 0, 0, 101,		/* TPM_ORD_GetCapability */
 	0, 0, 0, 5,
 	0, 0, 0, 4,
 	0, 0, 1, 3
 };
 
-ssize_t tpm_show_caps(struct device *dev, struct device_attribute *attr,
-		      char *buf)
+static ssize_t show_caps(struct device *dev, char *buf)
 {
-	u8 data[sizeof(cap_manufacturer)];
+	u8 data[READ_PUBEK_RESULT_SIZE];
 	ssize_t len;
 	char *str = buf;
 
 	struct tpm_chip *chip =
-	    pci_get_drvdata(to_pci_dev(dev));
+	    pci_get_drvdata(container_of(dev, struct pci_dev, dev));
 	if (chip == NULL)
 		return -ENODEV;
 
 	memcpy(data, cap_manufacturer, sizeof(cap_manufacturer));
@@ -285,9 +275,9 @@ ssize_t tpm_show_caps(struct device *dev
 	    CAP_MANUFACTURER_RESULT_SIZE)
 		return len;
 
 	str += sprintf(str, "Manufacturer: 0x%x\n",
-		       be32_to_cpu(*((__be32 *) (data + 14))));
+		       be32_to_cpu(*(data + 14)));
 
 	memcpy(data, cap_version, sizeof(cap_version));
 
 	if ((len = tpm_transmit(chip, data, sizeof(data))) <
@@ -300,22 +290,10 @@ ssize_t tpm_show_caps(struct device *dev
 		    (int) data[17]);
 
 	return str - buf;
 }
-EXPORT_SYMBOL_GPL(tpm_show_caps);
-
-ssize_t tpm_store_cancel(struct device *dev, struct device_attribute *attr,
-			const char *buf, size_t count)
-{
-	struct tpm_chip *chip = dev_get_drvdata(dev);
-	if (chip == NULL)
-		return 0;
-
-	chip->vendor->cancel(chip);
-	return count;
-}
-EXPORT_SYMBOL_GPL(tpm_store_cancel);
 
+static DEVICE_ATTR(caps, S_IRUGO, show_caps, NULL);
 
 /*
  * Device file system interface to the TPM
  */
@@ -372,16 +350,25 @@ EXPORT_SYMBOL_GPL(tpm_open);
 int tpm_release(struct inode *inode, struct file *file)
 {
 	struct tpm_chip *chip = file->private_data;
 
-	spin_lock(&driver_lock);
 	file->private_data = NULL;
+
+	spin_lock(&driver_lock);
 	chip->num_opens--;
-	del_singleshot_timer_sync(&chip->user_read_timer);
+	spin_unlock(&driver_lock);
+
+	down(&chip->timer_manipulation_mutex);
+	if (timer_pending(&chip->user_read_timer))
+		del_singleshot_timer_sync(&chip->user_read_timer);
+	else if (timer_pending(&chip->device_timer))
+		del_singleshot_timer_sync(&chip->device_timer);
+	up(&chip->timer_manipulation_mutex);
+
+	kfree(chip->data_buffer);
 	atomic_set(&chip->data_pending, 0);
+
 	pci_dev_put(chip->pci_dev);
-	kfree(chip->data_buffer);
-	spin_unlock(&driver_lock);
 	return 0;
 }
 
 EXPORT_SYMBOL_GPL(tpm_release);
@@ -393,10 +380,12 @@ ssize_t tpm_write(struct file * file, co
 	int in_size = size, out_size;
 
 	/* cannot perform a write until the read has cleared
 	   either via tpm_read or a user_read_timer timeout */
-	while (atomic_read(&chip->data_pending) != 0)
-		msleep(TPM_TIMEOUT);
+	while (atomic_read(&chip->data_pending) != 0) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(TPM_TIMEOUT);
+	}
 
 	down(&chip->buffer_mutex);
 
 	if (in_size > TPM_BUFSIZE)
@@ -411,12 +400,19 @@ ssize_t tpm_write(struct file * file, co
 	/* atomic tpm command send and result receive */
 	out_size = tpm_transmit(chip, chip->data_buffer, TPM_BUFSIZE);
 
 	atomic_set(&chip->data_pending, out_size);
+	atomic_set(&chip->data_position, 0);
 	up(&chip->buffer_mutex);
 
 	/* Set a timeout by which the reader must come claim the result */
-	mod_timer(&chip->user_read_timer, jiffies + (60 * HZ));
+	down(&chip->timer_manipulation_mutex);
+	init_timer(&chip->user_read_timer);
+	chip->user_read_timer.function = user_reader_timeout;
+	chip->user_read_timer.data = (unsigned long) chip;
+	chip->user_read_timer.expires = jiffies + (60 * HZ);
+	add_timer(&chip->user_read_timer);
+	up(&chip->timer_manipulation_mutex);
 
 	return in_size;
 }
 
@@ -425,22 +421,37 @@ EXPORT_SYMBOL_GPL(tpm_write);
 ssize_t tpm_read(struct file * file, char __user * buf,
 		 size_t size, loff_t * off)
 {
 	struct tpm_chip *chip = file->private_data;
-	int ret_size;
+	int ret_size = -ENODATA;
+	int pos, pending = 0;
 
-	del_singleshot_timer_sync(&chip->user_read_timer);
+	down(&chip->buffer_mutex);
 	ret_size = atomic_read(&chip->data_pending);
-	atomic_set(&chip->data_pending, 0);
-	if (ret_size > 0) {	/* relay data */
+	if ( ret_size > 0 ) {	/* Result available */
 		if (size < ret_size)
 			ret_size = size;
 
-		down(&chip->buffer_mutex);
-		if (copy_to_user
-		    ((void __user *) buf, chip->data_buffer, ret_size))
+		pos = atomic_read(&chip->data_position);
+
+		if (copy_to_user((void __user *) buf,
+				 &chip->data_buffer[pos], ret_size)) {
 			ret_size = -EFAULT;
-		up(&chip->buffer_mutex);
+		} else {
+			pending = atomic_read(&chip->data_pending) - ret_size;
+			if ( pending ) {
+				atomic_set( &chip->data_pending, pending );
+				atomic_set( &chip->data_position, pos+ret_size );
+			}
+		}
+	}
+	up(&chip->buffer_mutex);
+
+	if ( ret_size <= 0 || pending == 0 ) {
+		atomic_set( &chip->data_pending, 0 );
+		down(&chip->timer_manipulation_mutex);
+		del_singleshot_timer_sync(&chip->user_read_timer);
+		up(&chip->timer_manipulation_mutex);
 	}
 
 	return ret_size;
 }
@@ -463,15 +474,16 @@ void __devexit tpm_remove(struct pci_dev
 	spin_unlock(&driver_lock);
 
 	pci_set_drvdata(pci_dev, NULL);
 	misc_deregister(&chip->vendor->miscdev);
-	kfree(chip->vendor->miscdev.name);
 
-	sysfs_remove_group(&pci_dev->dev.kobj, chip->vendor->attr_group);
+	device_remove_file(&pci_dev->dev, &dev_attr_pubek);
+	device_remove_file(&pci_dev->dev, &dev_attr_pcrs);
+	device_remove_file(&pci_dev->dev, &dev_attr_caps);
 
 	pci_disable_device(pci_dev);
 
-	dev_mask[chip->dev_num / TPM_NUM_MASK_ENTRIES ] &= !(1 << (chip->dev_num % TPM_NUM_MASK_ENTRIES));
+	dev_mask[chip->dev_num / 32] &= !(1 << (chip->dev_num % 32));
 
 	kfree(chip);
 
 	pci_dev_put(pci_dev);
@@ -517,20 +529,18 @@ int tpm_pm_resume(struct pci_dev *pci_de
 
 EXPORT_SYMBOL_GPL(tpm_pm_resume);
 
 /*
- * Called from tpm_<specific>.c probe function only for devices 
+ * Called from tpm_<specific>.c probe function only for devices
  * the driver has determined it should claim.  Prior to calling
  * this function the specific probe function has called pci_enable_device
  * upon errant exit from this function specific probe function should call
  * pci_disable_device
  */
 int tpm_register_hardware(struct pci_dev *pci_dev,
 			  struct tpm_vendor_specific *entry)
 {
-#define DEVNAME_SIZE 7
-
-	char *devname;
+	char devname[7];
 	struct tpm_chip *chip;
 	int i, j;
 
 	/* Driver specific per-device data */
@@ -541,23 +551,19 @@ int tpm_register_hardware(struct pci_dev
 	memset(chip, 0, sizeof(struct tpm_chip));
 
 	init_MUTEX(&chip->buffer_mutex);
 	init_MUTEX(&chip->tpm_mutex);
+	init_MUTEX(&chip->timer_manipulation_mutex);
 	INIT_LIST_HEAD(&chip->list);
 
-	init_timer(&chip->user_read_timer);
-	chip->user_read_timer.function = user_reader_timeout;
-	chip->user_read_timer.data = (unsigned long) chip;
-
 	chip->vendor = entry;
 
 	chip->dev_num = -1;
 
-	for (i = 0; i < TPM_NUM_MASK_ENTRIES; i++)
-		for (j = 0; j < 8 * sizeof(int); j++)
+	for (i = 0; i < 32; i++)
+		for (j = 0; j < 8; j++)
 			if ((dev_mask[i] & (1 << j)) == 0) {
-				chip->dev_num =
-				    i * TPM_NUM_MASK_ENTRIES + j;
+				chip->dev_num = i * 32 + j;
 				dev_mask[i] |= 1 << j;
 				goto dev_num_search_complete;
 			}
 
@@ -571,10 +577,9 @@ dev_num_search_complete:
 		chip->vendor->miscdev.minor = TPM_MINOR;
 	else
 		chip->vendor->miscdev.minor = MISC_DYNAMIC_MINOR;
 
-	devname = kmalloc(DEVNAME_SIZE, GFP_KERNEL);
-	scnprintf(devname, DEVNAME_SIZE, "%s%d", "tpm", chip->dev_num);
+	snprintf(devname, sizeof(devname), "%s%d", "tpm", chip->dev_num);
 	chip->vendor->miscdev.name = devname;
 
 	chip->vendor->miscdev.dev = &(pci_dev->dev);
 	chip->pci_dev = pci_dev_get(pci_dev);
@@ -589,23 +594,34 @@ dev_num_search_complete:
 		dev_mask[i] &= !(1 << j);
 		return -ENODEV;
 	}
 
-	spin_lock(&driver_lock);
-
 	pci_set_drvdata(pci_dev, chip);
 
 	list_add(&chip->list, &tpm_chip_list);
 
-	spin_unlock(&driver_lock);
-
-	sysfs_create_group(&pci_dev->dev.kobj, chip->vendor->attr_group);
+	device_create_file(&pci_dev->dev, &dev_attr_pubek);
+	device_create_file(&pci_dev->dev, &dev_attr_pcrs);
+	device_create_file(&pci_dev->dev, &dev_attr_caps);
 
 	return 0;
 }
 
 EXPORT_SYMBOL_GPL(tpm_register_hardware);
 
+static int __init init_tpm(void)
+{
+	return 0;
+}
+
+static void __exit cleanup_tpm(void)
+{
+
+}
+
+module_init(init_tpm);
+module_exit(cleanup_tpm);
+
 MODULE_AUTHOR("Leendert van Doorn (leendert@watson.ibm.com)");
 MODULE_DESCRIPTION("TPM Driver");
 MODULE_VERSION("2.0");
 MODULE_LICENSE("GPL");
Index: linux-2.6.13/drivers/char/tpm/tpm.h
===================================================================
--- linux-2.6.13.orig/drivers/char/tpm/tpm.h
+++ linux-2.6.13/drivers/char/tpm/tpm.h
@@ -9,55 +9,40 @@
  *
  * Maintained by: <tpmdd_devel@lists.sourceforge.net>
  *
  * Device driver for TCG/TCPA TPM (trusted platform module).
- * Specifications at www.trustedcomputinggroup.org	 
+ * Specifications at www.trustedcomputinggroup.org
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation, version 2 of the
  * License.
- * 
+ *
  */
 #include <linux/module.h>
 #include <linux/version.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
 #include <linux/miscdevice.h>
 
-enum tpm_timeout {
-	TPM_TIMEOUT = 5,	/* msecs */
-};
+#define TPM_TIMEOUT msecs_to_jiffies(5)
 
 /* TPM addresses */
-enum tpm_addr {
-	TPM_SUPERIO_ADDR = 0x2E,
-	TPM_ADDR = 0x4E,
-};
-
-extern ssize_t tpm_show_pubek(struct device *, struct device_attribute *attr,
-				char *);
-extern ssize_t tpm_show_pcrs(struct device *, struct device_attribute *attr,
-				char *);
-extern ssize_t tpm_show_caps(struct device *, struct device_attribute *attr,
-				char *);
-extern ssize_t tpm_store_cancel(struct device *, struct device_attribute *attr,
-				const char *, size_t);
+#define	TPM_ADDR			0x4E
+#define	TPM_DATA			0x4F
 
 struct tpm_chip;
 
 struct tpm_vendor_specific {
 	u8 req_complete_mask;
 	u8 req_complete_val;
-	u8 req_canceled;
 	u16 base;		/* TPM base address */
 
 	int (*recv) (struct tpm_chip *, u8 *, size_t);
 	int (*send) (struct tpm_chip *, u8 *, size_t);
 	void (*cancel) (struct tpm_chip *);
 	struct miscdevice miscdev;
-	struct attribute_group *attr_group;
 };
 
 struct tpm_chip {
 	struct pci_dev *pci_dev;	/* PCI device stuff */
@@ -68,30 +53,34 @@ struct tpm_chip {
 
 	/* Data passed to and from the tpm via the read/write calls */
 	u8 *data_buffer;
 	atomic_t data_pending;
+	atomic_t data_position;
 	struct semaphore buffer_mutex;
 
 	struct timer_list user_read_timer;	/* user needs to claim result */
 	struct semaphore tpm_mutex;	/* tpm is processing */
+	struct timer_list device_timer;	/* tpm is processing */
+	struct semaphore timer_manipulation_mutex;
 
 	struct tpm_vendor_specific *vendor;
 
 	struct list_head list;
 };
 
-static inline int tpm_read_index(int base, int index)
+static inline int tpm_read_index(int index)
 {
-	outb(index, base);
-	return inb(base+1) & 0xFF;
+	outb(index, TPM_ADDR);
+	return inb(TPM_DATA) & 0xFF;
 }
 
-static inline void tpm_write_index(int base, int index, int value)
+static inline void tpm_write_index(int index, int value)
 {
-	outb(index, base);
-	outb(value & 0xFF, base+1);
+	outb(index, TPM_ADDR);
+	outb(value & 0xFF, TPM_DATA);
 }
 
+extern void tpm_time_expired(unsigned long);
 extern int tpm_register_hardware(struct pci_dev *,
 				 struct tpm_vendor_specific *);
 extern int tpm_open(struct inode *, struct file *);
 extern int tpm_release(struct inode *, struct file *);
Index: linux-2.6.13/drivers/char/tpm/tpm_atmel.c
===================================================================
--- linux-2.6.13.orig/drivers/char/tpm/tpm_atmel.c
+++ linux-2.6.13/drivers/char/tpm/tpm_atmel.c
@@ -9,15 +9,15 @@
  *
  * Maintained by: <tpmdd_devel@lists.sourceforge.net>
  *
  * Device driver for TCG/TCPA TPM (trusted platform module).
- * Specifications at www.trustedcomputinggroup.org	 
+ * Specifications at www.trustedcomputinggroup.org
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation, version 2 of the
  * License.
- * 
+ *
  */
 
 #include "tpm.h"
 
@@ -27,19 +27,16 @@ enum tpm_atmel_addr {
 	TPM_ATMEL_BASE_ADDR_HI = 0x09
 };
 
 /* write status bits */
-enum tpm_atmel_write_status {
-	ATML_STATUS_ABORT = 0x01,
-	ATML_STATUS_LASTBYTE = 0x04
-};
+#define	ATML_STATUS_ABORT		0x01
+#define	ATML_STATUS_LASTBYTE		0x04
+
 /* read status bits */
-enum tpm_atmel_read_status {
-	ATML_STATUS_BUSY = 0x01,
-	ATML_STATUS_DATA_AVAIL = 0x02,
-	ATML_STATUS_REWRITE = 0x04,
-	ATML_STATUS_READY = 0x08
-};
+#define	ATML_STATUS_BUSY		0x01
+#define	ATML_STATUS_DATA_AVAIL		0x02
+#define	ATML_STATUS_REWRITE		0x04
+
 
 static int tpm_atml_recv(struct tpm_chip *chip, u8 * buf, size_t count)
 {
 	u8 status, *hdr = buf;
@@ -126,31 +123,14 @@ static struct file_operations atmel_ops 
 	.write = tpm_write,
 	.release = tpm_release,
 };
 
-static DEVICE_ATTR(pubek, S_IRUGO, tpm_show_pubek, NULL);
-static DEVICE_ATTR(pcrs, S_IRUGO, tpm_show_pcrs, NULL);
-static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps, NULL);
-static DEVICE_ATTR(cancel, S_IWUSR |S_IWGRP, NULL, tpm_store_cancel);
-
-static struct attribute* atmel_attrs[] = {
-	&dev_attr_pubek.attr,
-	&dev_attr_pcrs.attr,
-	&dev_attr_caps.attr,
-	&dev_attr_cancel.attr,
-	0,
-};
-
-static struct attribute_group atmel_attr_grp = { .attrs = atmel_attrs };
-
 static struct tpm_vendor_specific tpm_atmel = {
 	.recv = tpm_atml_recv,
 	.send = tpm_atml_send,
 	.cancel = tpm_atml_cancel,
 	.req_complete_mask = ATML_STATUS_BUSY | ATML_STATUS_DATA_AVAIL,
 	.req_complete_val = ATML_STATUS_DATA_AVAIL,
-	.req_canceled = ATML_STATUS_READY,
-	.attr_group = &atmel_attr_grp,
 	.miscdev = { .fops = &atmel_ops, },
 };
 
 static int __devinit tpm_atml_init(struct pci_dev *pci_dev,
@@ -162,26 +142,26 @@ static int __devinit tpm_atml_init(struc
 
 	if (pci_enable_device(pci_dev))
 		return -EIO;
 
-	lo = tpm_read_index(TPM_ADDR, TPM_ATMEL_BASE_ADDR_LO);
-	hi = tpm_read_index(TPM_ADDR, TPM_ATMEL_BASE_ADDR_HI);
+	lo = tpm_read_index( TPM_ATMEL_BASE_ADDR_LO );
+	hi = tpm_read_index( TPM_ATMEL_BASE_ADDR_HI );
 
 	tpm_atmel.base = (hi<<8)|lo;
 	dev_dbg( &pci_dev->dev, "Operating with base: 0x%x\n", tpm_atmel.base);
 
 	/* verify that it is an Atmel part */
-	if (tpm_read_index(TPM_ADDR, 4) != 'A' || tpm_read_index(TPM_ADDR, 5) != 'T'
-	    || tpm_read_index(TPM_ADDR, 6) != 'M' || tpm_read_index(TPM_ADDR, 7) != 'L') {
+	if (tpm_read_index(4) != 'A' || tpm_read_index(5) != 'T'
+	    || tpm_read_index(6) != 'M' || tpm_read_index(7) != 'L') {
 		rc = -ENODEV;
 		goto out_err;
 	}
 
 	/* query chip for its version number */
-	if ((version[0] = tpm_read_index(TPM_ADDR, 0x00)) != 0xFF) {
-		version[1] = tpm_read_index(TPM_ADDR, 0x01);
-		version[2] = tpm_read_index(TPM_ADDR, 0x02);
-		version[3] = tpm_read_index(TPM_ADDR, 0x03);
+	if ((version[0] = tpm_read_index(0x00)) != 0xFF) {
+		version[1] = tpm_read_index(0x01);
+		version[2] = tpm_read_index(0x02);
+		version[3] = tpm_read_index(0x03);
 	} else {
 		dev_info(&pci_dev->dev, "version query failed\n");
 		rc = -ENODEV;
 		goto out_err;
@@ -206,9 +186,8 @@ static struct pci_device_id tpm_pci_tbl[
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_0)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_12)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801EB_0)},
 	{PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_LPC)},
-	{PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_CSB6LPC)},
 	{0,}
 };
 
 MODULE_DEVICE_TABLE(pci, tpm_pci_tbl);
Index: linux-2.6.13/drivers/char/tpm/tpm_nsc.c
===================================================================
--- linux-2.6.13.orig/drivers/char/tpm/tpm_nsc.c
+++ linux-2.6.13/drivers/char/tpm/tpm_nsc.c
@@ -9,89 +9,90 @@
  *
  * Maintained by: <tpmdd_devel@lists.sourceforge.net>
  *
  * Device driver for TCG/TCPA TPM (trusted platform module).
- * Specifications at www.trustedcomputinggroup.org	 
+ * Specifications at www.trustedcomputinggroup.org
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation, version 2 of the
  * License.
- * 
+ *
  */
 
 #include "tpm.h"
 
 /* National definitions */
-enum tpm_nsc_addr{
-	TPM_NSC_IRQ = 0x07,
-	TPM_NSC_BASE0_HI = 0x60,
-	TPM_NSC_BASE0_LO = 0x61,
-	TPM_NSC_BASE1_HI = 0x62,
-	TPM_NSC_BASE1_LO = 0x63
-};
-
-enum tpm_nsc_index {
-	NSC_LDN_INDEX = 0x07,
-	NSC_SID_INDEX = 0x20,
-	NSC_LDC_INDEX = 0x30,
-	NSC_DIO_INDEX = 0x60,
-	NSC_CIO_INDEX = 0x62,
-	NSC_IRQ_INDEX = 0x70,
-	NSC_ITS_INDEX = 0x71
-};
-
-enum tpm_nsc_status_loc {
-	NSC_STATUS = 0x01,
-	NSC_COMMAND = 0x01,
-	NSC_DATA = 0x00
-};
+#define	TPM_NSC_BASE			0x360
+#define	TPM_NSC_IRQ			0x07
+#define	TPM_NSC_BASE0_HI		0x60
+#define	TPM_NSC_BASE0_LO		0x61
+#define	TPM_NSC_BASE1_HI		0x62
+#define	TPM_NSC_BASE1_LO		0x63
+
+#define	NSC_LDN_INDEX			0x07
+#define	NSC_SID_INDEX			0x20
+#define	NSC_LDC_INDEX			0x30
+#define	NSC_DIO_INDEX			0x60
+#define	NSC_CIO_INDEX			0x62
+#define	NSC_IRQ_INDEX			0x70
+#define	NSC_ITS_INDEX			0x71
+
+#define	NSC_STATUS			0x01
+#define	NSC_COMMAND			0x01
+#define	NSC_DATA			0x00
 
 /* status bits */
-enum tpm_nsc_status {
-	NSC_STATUS_OBF = 0x01,	/* output buffer full */
-	NSC_STATUS_IBF = 0x02,	/* input buffer full */
-	NSC_STATUS_F0 = 0x04,	/* F0 */
-	NSC_STATUS_A2 = 0x08,	/* A2 */
-	NSC_STATUS_RDY = 0x10,	/* ready to receive command */
-	NSC_STATUS_IBR = 0x20	/* ready to receive data */
-};
+#define	NSC_STATUS_OBF			0x01	/* output buffer full */
+#define	NSC_STATUS_IBF			0x02	/* input buffer full */
+#define	NSC_STATUS_F0			0x04	/* F0 */
+#define	NSC_STATUS_A2			0x08	/* A2 */
+#define	NSC_STATUS_RDY			0x10	/* ready to receive command */
+#define	NSC_STATUS_IBR			0x20	/* ready to receive data */
 
 /* command bits */
-enum tpm_nsc_cmd_mode {
-	NSC_COMMAND_NORMAL = 0x01,	/* normal mode */
-	NSC_COMMAND_EOC = 0x03,
-	NSC_COMMAND_CANCEL = 0x22
-};
+#define	NSC_COMMAND_NORMAL		0x01	/* normal mode */
+#define	NSC_COMMAND_EOC			0x03
+#define	NSC_COMMAND_CANCEL		0x22
+
 /*
  * Wait for a certain status to appear
  */
 static int wait_for_stat(struct tpm_chip *chip, u8 mask, u8 val, u8 * data)
 {
-	unsigned long stop;
+	int expired = 0;
+	struct timer_list status_timer =
+	    TIMER_INITIALIZER(tpm_time_expired, jiffies + 10 * HZ,
+			      (unsigned long) &expired);
 
 	/* status immediately available check */
 	*data = inb(chip->vendor->base + NSC_STATUS);
 	if ((*data & mask) == val)
 		return 0;
 
 	/* wait for status */
-	stop = jiffies + 10 * HZ;
+	add_timer(&status_timer);
 	do {
-		msleep(TPM_TIMEOUT);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(TPM_TIMEOUT);
 		*data = inb(chip->vendor->base + 1);
-		if ((*data & mask) == val)
+		if ((*data & mask) == val) {
+			del_singleshot_timer_sync(&status_timer);
 			return 0;
+		}
 	}
-	while (time_before(jiffies, stop));
+	while (!expired);
 
 	return -EBUSY;
 }
 
 static int nsc_wait_for_ready(struct tpm_chip *chip)
 {
 	int status;
-	unsigned long stop;
+	int expired = 0;
+	struct timer_list status_timer =
+	    TIMER_INITIALIZER(tpm_time_expired, jiffies + 100,
+			      (unsigned long) &expired);
 
 	/* status immediately available check */
 	status = inb(chip->vendor->base + NSC_STATUS);
 	if (status & NSC_STATUS_OBF)
@@ -99,18 +100,21 @@ static int nsc_wait_for_ready(struct tpm
 	if (status & NSC_STATUS_RDY)
 		return 0;
 
 	/* wait for status */
-	stop = jiffies + 100;
+	add_timer(&status_timer);
 	do {
-		msleep(TPM_TIMEOUT);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(TPM_TIMEOUT);
 		status = inb(chip->vendor->base + NSC_STATUS);
 		if (status & NSC_STATUS_OBF)
 			status = inb(chip->vendor->base + NSC_DATA);
-		if (status & NSC_STATUS_RDY)
+		if (status & NSC_STATUS_RDY) {
+			del_singleshot_timer_sync(&status_timer);
 			return 0;
+		}
 	}
-	while (time_before(jiffies, stop));
+	while (!expired);
 
 	dev_info(&chip->pci_dev->dev, "wait for ready failed\n");
 	return -EBUSY;
 }
@@ -149,10 +153,9 @@ static int tpm_nsc_recv(struct tpm_chip 
 			break;
 		*p = inb(chip->vendor->base + NSC_DATA);
 	}
 
-	if ((data & NSC_STATUS_F0) == 0 &&
-	(wait_for_stat(chip, NSC_STATUS_F0, NSC_STATUS_F0, &data) < 0)) {
+	if ((data & NSC_STATUS_F0) == 0) {
 		dev_err(&chip->pci_dev->dev, "F0 not set\n");
 		return -EIO;
 	}
 	if ((data = inb(chip->vendor->base + NSC_DATA)) != NSC_COMMAND_EOC) {
@@ -228,97 +231,102 @@ static struct file_operations nsc_ops = 
 	.write = tpm_write,
 	.release = tpm_release,
 };
 
-static DEVICE_ATTR(pubek, S_IRUGO, tpm_show_pubek, NULL);
-static DEVICE_ATTR(pcrs, S_IRUGO, tpm_show_pcrs, NULL);
-static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps, NULL);
-static DEVICE_ATTR(cancel, S_IWUSR|S_IWGRP, NULL, tpm_store_cancel);
-
-static struct attribute * nsc_attrs[] = {
-	&dev_attr_pubek.attr,
-	&dev_attr_pcrs.attr,
-	&dev_attr_caps.attr,
-	&dev_attr_cancel.attr,
-	0,
-};
-
-static struct attribute_group nsc_attr_grp = { .attrs = nsc_attrs };
-
 static struct tpm_vendor_specific tpm_nsc = {
 	.recv = tpm_nsc_recv,
 	.send = tpm_nsc_send,
 	.cancel = tpm_nsc_cancel,
 	.req_complete_mask = NSC_STATUS_OBF,
 	.req_complete_val = NSC_STATUS_OBF,
-	.req_canceled = NSC_STATUS_RDY,
-	.attr_group = &nsc_attr_grp,
 	.miscdev = { .fops = &nsc_ops, },
+
 };
 
 static int __devinit tpm_nsc_init(struct pci_dev *pci_dev,
 				  const struct pci_device_id *pci_id)
 {
 	int rc = 0;
 	int lo, hi;
-	int nscAddrBase = TPM_ADDR;
 
+	hi = tpm_read_index(TPM_NSC_BASE0_HI);
+	lo = tpm_read_index(TPM_NSC_BASE0_LO);
+
+	tpm_nsc.base = (hi<<8) | lo;
 
 	if (pci_enable_device(pci_dev))
 		return -EIO;
 
-	/* select PM channel 1 */
-	tpm_write_index(nscAddrBase,NSC_LDN_INDEX, 0x12);
-
 	/* verify that it is a National part (SID) */
-	if (tpm_read_index(TPM_ADDR, NSC_SID_INDEX) != 0xEF) {
-		nscAddrBase = (tpm_read_index(TPM_SUPERIO_ADDR, 0x2C)<<8)|
-			(tpm_read_index(TPM_SUPERIO_ADDR, 0x2B)&0xFE);
-		if (tpm_read_index(nscAddrBase, NSC_SID_INDEX) != 0xF6) {
-			rc = -ENODEV;
-			goto out_err;
-		}
+	if (tpm_read_index(NSC_SID_INDEX) != 0xEF) {
+		rc = -ENODEV;
+		goto out_err;
 	}
 
-	hi = tpm_read_index(nscAddrBase, TPM_NSC_BASE0_HI);
-	lo = tpm_read_index(nscAddrBase, TPM_NSC_BASE0_LO);
-	tpm_nsc.base = (hi<<8) | lo;
-
 	dev_dbg(&pci_dev->dev, "NSC TPM detected\n");
 	dev_dbg(&pci_dev->dev,
 		"NSC LDN 0x%x, SID 0x%x, SRID 0x%x\n",
-		tpm_read_index(nscAddrBase,0x07), tpm_read_index(nscAddrBase,0x20),
-		tpm_read_index(nscAddrBase,0x27));
+		tpm_read_index(0x07), tpm_read_index(0x20),
+		tpm_read_index(0x27));
 	dev_dbg(&pci_dev->dev,
 		"NSC SIOCF1 0x%x SIOCF5 0x%x SIOCF6 0x%x SIOCF8 0x%x\n",
-		tpm_read_index(nscAddrBase,0x21), tpm_read_index(nscAddrBase,0x25),
-		tpm_read_index(nscAddrBase,0x26), tpm_read_index(nscAddrBase,0x28));
+		tpm_read_index(0x21), tpm_read_index(0x25),
+		tpm_read_index(0x26), tpm_read_index(0x28));
 	dev_dbg(&pci_dev->dev, "NSC IO Base0 0x%x\n",
-		(tpm_read_index(nscAddrBase,0x60) << 8) | tpm_read_index(nscAddrBase,0x61));
+		(tpm_read_index(0x60) << 8) | tpm_read_index(0x61));
 	dev_dbg(&pci_dev->dev, "NSC IO Base1 0x%x\n",
-		(tpm_read_index(nscAddrBase,0x62) << 8) | tpm_read_index(nscAddrBase,0x63));
+		(tpm_read_index(0x62) << 8) | tpm_read_index(0x63));
 	dev_dbg(&pci_dev->dev, "NSC Interrupt number and wakeup 0x%x\n",
-		tpm_read_index(nscAddrBase,0x70));
+		tpm_read_index(0x70));
 	dev_dbg(&pci_dev->dev, "NSC IRQ type select 0x%x\n",
-		tpm_read_index(nscAddrBase,0x71));
+		tpm_read_index(0x71));
 	dev_dbg(&pci_dev->dev,
 		"NSC DMA channel select0 0x%x, select1 0x%x\n",
-		tpm_read_index(nscAddrBase,0x74), tpm_read_index(nscAddrBase,0x75));
+		tpm_read_index(0x74), tpm_read_index(0x75));
 	dev_dbg(&pci_dev->dev,
 		"NSC Config "
 		"0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
-		tpm_read_index(nscAddrBase,0xF0), tpm_read_index(nscAddrBase,0xF1),
-		tpm_read_index(nscAddrBase,0xF2), tpm_read_index(nscAddrBase,0xF3),
-		tpm_read_index(nscAddrBase,0xF4), tpm_read_index(nscAddrBase,0xF5),
-		tpm_read_index(nscAddrBase,0xF6), tpm_read_index(nscAddrBase,0xF7),
-		tpm_read_index(nscAddrBase,0xF8), tpm_read_index(nscAddrBase,0xF9));
+		tpm_read_index(0xF0), tpm_read_index(0xF1),
+		tpm_read_index(0xF2), tpm_read_index(0xF3),
+		tpm_read_index(0xF4), tpm_read_index(0xF5),
+		tpm_read_index(0xF6), tpm_read_index(0xF7),
+		tpm_read_index(0xF8), tpm_read_index(0xF9));
 
 	dev_info(&pci_dev->dev,
-		 "NSC TPM revision %d\n",
-		 tpm_read_index(nscAddrBase, 0x27) & 0x1F);
+		 "NSC PC21100 TPM revision %d\n",
+		 tpm_read_index(0x27) & 0x1F);
+
+	if (tpm_read_index(NSC_LDC_INDEX) == 0)
+		dev_info(&pci_dev->dev, ": NSC TPM not active\n");
+
+	/* select PM channel 1 */
+	tpm_write_index(NSC_LDN_INDEX, 0x12);
+	tpm_read_index(NSC_LDN_INDEX);
+
+	/* disable the DPM module */
+	tpm_write_index(NSC_LDC_INDEX, 0);
+	tpm_read_index(NSC_LDC_INDEX);
+
+	/* set the data register base addresses */
+	tpm_write_index(NSC_DIO_INDEX, TPM_NSC_BASE >> 8);
+	tpm_write_index(NSC_DIO_INDEX + 1, TPM_NSC_BASE);
+	tpm_read_index(NSC_DIO_INDEX);
+	tpm_read_index(NSC_DIO_INDEX + 1);
+
+	/* set the command register base addresses */
+	tpm_write_index(NSC_CIO_INDEX, (TPM_NSC_BASE + 1) >> 8);
+	tpm_write_index(NSC_CIO_INDEX + 1, (TPM_NSC_BASE + 1));
+	tpm_read_index(NSC_DIO_INDEX);
+	tpm_read_index(NSC_DIO_INDEX + 1);
+
+	/* set the interrupt number to be used for the host interface */
+	tpm_write_index(NSC_IRQ_INDEX, TPM_NSC_IRQ);
+	tpm_write_index(NSC_ITS_INDEX, 0x00);
+	tpm_read_index(NSC_IRQ_INDEX);
 
 	/* enable the DPM module */
-	tpm_write_index(nscAddrBase, NSC_LDC_INDEX, 0x01);
+	tpm_write_index(NSC_LDC_INDEX, 0x01);
+	tpm_read_index(NSC_LDC_INDEX);
 
 	if ((rc = tpm_register_hardware(pci_dev, &tpm_nsc)) < 0)
 		goto out_err;
 
@@ -334,11 +342,8 @@ static struct pci_device_id tpm_pci_tbl[
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_12)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_0)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_12)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801EB_0)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH6_0)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH6_1)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH7_0)},
 	{PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_LPC)},
 	{0,}
 };
 
