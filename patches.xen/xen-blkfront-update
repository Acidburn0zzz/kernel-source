Subject: update block frontend driver to xen 3.0.0 release level.
From: kraxel@suse.de

Index: linux-2.6.14/drivers/xen/blkfront/blkfront.c
===================================================================
--- linux-2.6.14.orig/drivers/xen/blkfront/blkfront.c	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/drivers/xen/blkfront/blkfront.c	2005-12-06 12:06:22.000000000 +0100
@@ -32,7 +32,6 @@
  * IN THE SOFTWARE.
  */
 
-
 #if 1
 #define ASSERT(p)							   \
 	if (!(p)) { printk("Assertion '%s' failed, line %d, file %s", #p , \
@@ -41,7 +40,6 @@
 #define ASSERT(_p)
 #endif
 
-
 #include <linux/version.h>
 #include "block.h"
 #include <linux/cdrom.h>
@@ -54,16 +52,14 @@
 #include <asm-xen/gnttab.h>
 #include <asm/hypervisor.h>
 
-
 #define BLKIF_STATE_DISCONNECTED 0
 #define BLKIF_STATE_CONNECTED    1
 #define BLKIF_STATE_SUSPENDED    2
 
 #define MAXIMUM_OUTSTANDING_BLOCK_REQS \
-    (BLKIF_MAX_SEGMENTS_PER_REQUEST * BLKIF_RING_SIZE)
+    (BLKIF_MAX_SEGMENTS_PER_REQUEST * BLK_RING_SIZE)
 #define GRANT_INVALID_REF	0
 
-
 static void connect(struct blkfront_info *);
 static void blkfront_closing(struct xenbus_device *);
 static int blkfront_remove(struct xenbus_device *);
@@ -304,6 +300,10 @@ static void backend_changed(struct xenbu
 /* ** Connection ** */
 
 
+/* 
+** Invoked when the backend is finally 'ready' (and has told produced 
+** the details about the physical device - #sectors, size, etc). 
+*/
 static void connect(struct blkfront_info *info)
 {
 	unsigned long sectors, sector_size;
@@ -311,7 +311,7 @@ static void connect(struct blkfront_info
 	int err;
 
         if( (info->connected == BLKIF_STATE_CONNECTED) || 
-	    (info->connected == BLKIF_STATE_SUSPENDED) ) 
+	    (info->connected == BLKIF_STATE_SUSPENDED) )
 		return;
 
 	DPRINTK("blkfront.c:connect:%s.\n", info->xbdev->otherend);
@@ -327,20 +327,19 @@ static void connect(struct blkfront_info
 				 info->xbdev->otherend);
 		return;
 	}
-	
-        info->connected = BLKIF_STATE_CONNECTED;
+
         xlvbd_add(sectors, info->vdevice, binfo, sector_size, info);
-	
-	err = xenbus_switch_state(info->xbdev, NULL, XenbusStateConnected);
-	if (err)
-		return;
-	
+
+	(void)xenbus_switch_state(info->xbdev, NULL, XenbusStateConnected); 
+
 	/* Kick pending requests. */
 	spin_lock_irq(&blkif_io_lock);
+	info->connected = BLKIF_STATE_CONNECTED;
 	kick_pending_request_queues(info);
 	spin_unlock_irq(&blkif_io_lock);
-}
 
+	add_disk(info->gd);
+}
 
 /**
  * Handle the change of state of the backend to Closing.  We must delete our
@@ -398,8 +397,12 @@ static inline void ADD_ID_TO_FREELIST(
 
 static inline void flush_requests(struct blkfront_info *info)
 {
-	RING_PUSH_REQUESTS(&info->ring);
-	notify_remote_via_irq(info->irq);
+	int notify;
+
+	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->ring, notify);
+
+	if (notify)
+		notify_remote_via_irq(info->irq);
 }
 
 static void kick_pending_request_queues(struct blkfront_info *info)
@@ -551,8 +554,11 @@ static int blkif_queue_request(struct re
 			info->shadow[id].frame[ring_req->nr_segments] =
 				mfn_to_pfn(buffer_mfn);
 
-			ring_req->frame_and_sects[ring_req->nr_segments] =
-				blkif_fas_from_gref(ref, fsect, lsect);
+			ring_req->seg[ring_req->nr_segments] =
+				(struct blkif_request_segment) {
+					.gref       = ref,
+					.first_sect = fsect, 
+					.last_sect  = lsect };
 
 			ring_req->nr_segments++;
 		}
@@ -584,7 +590,6 @@ void do_blkif_request(request_queue_t *r
 
 	while ((req = elv_next_request(rq)) != NULL) {
 		info = req->rq_disk->private_data;
-
 		if (!blk_fs_request(req)) {
 			end_request(req, 0);
 			continue;
@@ -632,6 +637,7 @@ static irqreturn_t blkif_int(int irq, vo
 		return IRQ_HANDLED;
 	}
 
+ again:
 	rp = info->ring.sring->rsp_prod;
 	rmb(); /* Ensure we see queued responses up to 'rp'. */
 
@@ -667,6 +673,15 @@ static irqreturn_t blkif_int(int irq, vo
 
 	info->ring.rsp_cons = i;
 
+	if (i != info->ring.req_prod_pvt) {
+		int more_to_do;
+		RING_FINAL_CHECK_FOR_RESPONSES(&info->ring, more_to_do);
+		if (more_to_do)
+			goto again;
+	} else {
+		info->ring.sring->rsp_event = i + 1;
+	}
+
 	kick_pending_request_queues(info);
 
 	spin_unlock_irqrestore(&blkif_io_lock, flags);
@@ -699,8 +714,7 @@ static void blkif_completion(struct blk_
 {
 	int i;
 	for (i = 0; i < s->req.nr_segments; i++)
-		gnttab_end_foreign_access(
-			blkif_gref_from_fas(s->req.frame_and_sects[i]), 0, 0UL);
+		gnttab_end_foreign_access(s->req.seg[i].gref, 0, 0UL);
 }
 
 static void blkif_recover(struct blkfront_info *info)
@@ -740,7 +754,7 @@ static void blkif_recover(struct blkfron
 		/* Rewrite any grant references invalidated by susp/resume. */
 		for (j = 0; j < req->nr_segments; j++)
 			gnttab_grant_foreign_access_ref(
-				blkif_gref_from_fas(req->frame_and_sects[j]),
+				req->seg[j].gref,
 				info->xbdev->otherend_id,
 				pfn_to_mfn(info->shadow[req->id].frame[j]),
 				rq_data_dir(
@@ -753,14 +767,20 @@ static void blkif_recover(struct blkfron
 
 	kfree(copy);
 
-	/* info->ring->req_prod will be set when we flush_requests().*/
-	wmb();
+	(void)xenbus_switch_state(info->xbdev, NULL, XenbusStateConnected); 
+	
+	/* Now safe for us to use the shared ring */
+	spin_lock_irq(&blkif_io_lock);
+        info->connected = BLKIF_STATE_CONNECTED;
+	spin_unlock_irq(&blkif_io_lock);
 
-	/* Kicks things back into life. */
+	/* Send off requeued requests */
 	flush_requests(info);
 
-	/* Now safe to let other people use the interface. */
-	info->connected = BLKIF_STATE_CONNECTED;
+	/* Kick any other new requests queued since we resumed */
+	spin_lock_irq(&blkif_io_lock);
+	kick_pending_request_queues(info);
+	spin_unlock_irq(&blkif_io_lock);
 }
 
 
Index: linux-2.6.14/drivers/xen/blkfront/block.h
===================================================================
--- linux-2.6.14.orig/drivers/xen/blkfront/block.h	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/drivers/xen/blkfront/block.h	2005-12-06 12:06:22.000000000 +0100
@@ -146,6 +146,9 @@ extern int blkif_revalidate(dev_t dev);
 extern void do_blkif_request (request_queue_t *rq); 
 
 /* Virtual block-device subsystem. */
+/* Note that xlvbd_add doesn't call add_disk for you: you're expected
+   to call add_disk on info->gd once the disk is properly connected
+   up. */
 int xlvbd_add(blkif_sector_t capacity, int device,
 	      u16 vdisk_info, u16 sector_size, struct blkfront_info *info);
 void xlvbd_del(struct blkfront_info *info);
Index: linux-2.6.14/drivers/xen/blkfront/vbd.c
===================================================================
--- linux-2.6.14.orig/drivers/xen/blkfront/vbd.c	2005-12-05 11:49:01.000000000 +0100
+++ linux-2.6.14/drivers/xen/blkfront/vbd.c	2005-12-06 12:06:22.000000000 +0100
@@ -33,6 +33,9 @@
 #include <linux/blkdev.h>
 #include <linux/list.h>
 
+#define BLKIF_MAJOR(dev) ((dev)>>8)
+#define BLKIF_MINOR(dev) ((dev) & 0xff)
+
 /*
  * For convenience we distinguish between ide, scsi and 'other' (i.e.,
  * potentially combinations of the two) in the naming scheme and in a few other
@@ -258,7 +261,6 @@ xlvbd_alloc_gendisk(int minor, blkif_sec
 	if (vdisk_info & VDISK_CDROM)
 		gd->flags |= GENHD_FL_CD;
 
-	add_disk(gd);
 	info->gd = gd;
 
 	return 0;
