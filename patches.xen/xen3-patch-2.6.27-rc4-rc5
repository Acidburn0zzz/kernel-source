From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: Update to 2.6.27-rc5
Patch-mainline: 2.6.27-rc5

 This patch contains the differences between 2.6.27-rc4 and -rc5.

Acked-by: Jeff Mahoney <jeffm@suse.com>

Automatically created from "patches.kernel.org/patch-2.6.27-rc4-rc5" by xen-port-patches.py

Index: head-2008-09-01/arch/x86/kernel/setup-xen.c
===================================================================
--- head-2008-09-01.orig/arch/x86/kernel/setup-xen.c	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/arch/x86/kernel/setup-xen.c	2008-09-01 14:14:48.000000000 +0200
@@ -697,14 +697,6 @@ void __init setup_arch(char **cmdline_p)
 	early_cpu_init();
 	early_ioremap_init();
 
-#if defined(CONFIG_VMI) && defined(CONFIG_X86_32)
-	/*
-	 * Must be before kernel pagetables are setup
-	 * or fixmap area is touched.
-	 */
-	vmi_init();
-#endif
-
 #ifndef CONFIG_XEN
 	ROOT_DEV = old_decode_dev(boot_params.hdr.root_dev);
 	screen_info = boot_params.screen_info;
@@ -801,6 +793,14 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
+#if defined(CONFIG_VMI) && defined(CONFIG_X86_32)
+	/*
+	 * Must be before kernel pagetables are setup
+	 * or fixmap area is touched.
+	 */
+	vmi_init();
+#endif
+
 	/* after early param, so could get panic from serial */
 	reserve_early_setup_data();
 
Index: head-2008-09-01/arch/x86/mm/init_64-xen.c
===================================================================
--- head-2008-09-01.orig/arch/x86/mm/init_64-xen.c	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/arch/x86/mm/init_64-xen.c	2008-09-01 14:14:48.000000000 +0200
@@ -434,9 +434,12 @@ phys_pmd_init(pmd_t *pmd_page, unsigned 
 			break;
 
 		if (__pmd_val(*pmd)) {
-			if (!pmd_large(*pmd))
+			if (!pmd_large(*pmd)) {
+				spin_lock(&init_mm.page_table_lock);
 				last_map_addr = phys_pte_update(pmd, address,
-								 end);
+								end);
+				spin_unlock(&init_mm.page_table_lock);
+			}
 			/* Count entries we're using from level2_ident_pgt */
 			if (start == 0)
 				pages++;
@@ -445,8 +448,10 @@ phys_pmd_init(pmd_t *pmd_page, unsigned 
 
 		if (page_size_mask & (1<<PG_LEVEL_2M)) {
 			pages++;
+			spin_lock(&init_mm.page_table_lock);
 			set_pte((pte_t *)pmd,
 				pfn_pte(address >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
+			spin_unlock(&init_mm.page_table_lock);
 			last_map_addr = (address & PMD_MASK) + PMD_SIZE;
 			continue;
 		}
@@ -460,7 +465,9 @@ phys_pmd_init(pmd_t *pmd_page, unsigned 
 			*pmd = __pmd(pte_phys | _PAGE_TABLE);
 		} else {
 			make_page_readonly(pte, XENFEAT_writable_page_tables);
+			spin_lock(&init_mm.page_table_lock);
 			pmd_populate_kernel(&init_mm, pmd, __va(pte_phys));
+			spin_unlock(&init_mm.page_table_lock);
 		}
 	}
 	update_page_count(PG_LEVEL_2M, pages);
@@ -475,9 +482,7 @@ phys_pmd_update(pud_t *pud, unsigned lon
 	unsigned long last_map_addr;
 
 	BUG_ON(!after_bootmem);
-	spin_lock(&init_mm.page_table_lock);
 	last_map_addr = phys_pmd_init(pmd, address, end, page_size_mask);
-	spin_unlock(&init_mm.page_table_lock);
 	__flush_tlb_all();
 	return last_map_addr;
 }
@@ -507,17 +512,18 @@ phys_pud_init(pud_t *pud_page, unsigned 
 
 		if (page_size_mask & (1<<PG_LEVEL_1G)) {
 			pages++;
+			spin_lock(&init_mm.page_table_lock);
 			set_pte((pte_t *)pud,
 				pfn_pte(addr >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
+			spin_unlock(&init_mm.page_table_lock);
 			last_map_addr = (addr & PUD_MASK) + PUD_SIZE;
 			continue;
 		}
 
 		pmd = alloc_static_page(&pmd_phys);
-
-		spin_lock(&init_mm.page_table_lock);
 		last_map_addr = phys_pmd_init(pmd, addr, end, page_size_mask);
 		unmap_low_page(pmd);
+
 		if (!after_bootmem) {
 			early_make_page_readonly(pmd, XENFEAT_writable_page_tables);
 			if (page_size_mask & (1 << PG_LEVEL_NUM))
@@ -526,9 +532,10 @@ phys_pud_init(pud_t *pud_page, unsigned 
 				*pud = __pud(pmd_phys | _PAGE_TABLE);
 		} else {
 			make_page_readonly(pmd, XENFEAT_writable_page_tables);
+			spin_lock(&init_mm.page_table_lock);
 			pud_populate(&init_mm, pud, __va(pmd_phys));
+			spin_unlock(&init_mm.page_table_lock);
 		}
-		spin_unlock(&init_mm.page_table_lock);
 	}
 	__flush_tlb_all();
 	update_page_count(PG_LEVEL_1G, pages);
@@ -807,16 +814,18 @@ static unsigned long __init kernel_physi
 		}
 
 		pud = alloc_static_page(&pud_phys);
-
 		last_map_addr = phys_pud_init(pud, __pa(start), __pa(next),
 						 page_size_mask);
 		unmap_low_page(pud);
+
 		if(!after_bootmem) {
 			early_make_page_readonly(pud, XENFEAT_writable_page_tables);
 			xen_l4_entry_update(pgd, __pgd(pud_phys | _PAGE_TABLE));
 		} else {
 			make_page_readonly(pud, XENFEAT_writable_page_tables);
+			spin_lock(&init_mm.page_table_lock);
 			pgd_populate(&init_mm, pgd, __va(pud_phys));
+			spin_unlock(&init_mm.page_table_lock);
 		}
 	}
 
Index: head-2008-09-01/arch/x86/mm/ioremap-xen.c
===================================================================
--- head-2008-09-01.orig/arch/x86/mm/ioremap-xen.c	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/arch/x86/mm/ioremap-xen.c	2008-09-01 14:14:48.000000000 +0200
@@ -723,13 +723,11 @@ static int __init check_early_ioremap_le
 {
 	if (!early_ioremap_nested)
 		return 0;
-
-	printk(KERN_WARNING
+	WARN(1, KERN_WARNING
 	       "Debug warning: early ioremap leak of %d areas detected.\n",
-	       early_ioremap_nested);
+		early_ioremap_nested);
 	printk(KERN_WARNING
-	       "please boot with early_ioremap_debug and report the dmesg.\n");
-	WARN_ON(1);
+		"please boot with early_ioremap_debug and report the dmesg.\n");
 
 	return 1;
 }
Index: head-2008-09-01/arch/x86/mm/pageattr-xen.c
===================================================================
--- head-2008-09-01.orig/arch/x86/mm/pageattr-xen.c	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/arch/x86/mm/pageattr-xen.c	2008-09-01 14:14:48.000000000 +0200
@@ -869,7 +869,7 @@ int set_memory_uc(unsigned long addr, in
 	/*
 	 * for now UC MINUS. see comments in ioremap_nocache()
 	 */
-	if (reserve_memtype(addr, addr + numpages * PAGE_SIZE,
+	if (reserve_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE,
 			    _PAGE_CACHE_UC_MINUS, NULL))
 		return -EINVAL;
 
@@ -888,7 +888,7 @@ int set_memory_wc(unsigned long addr, in
 	if (!pat_enabled)
 		return set_memory_uc(addr, numpages);
 
-	if (reserve_memtype(addr, addr + numpages * PAGE_SIZE,
+	if (reserve_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE,
 		_PAGE_CACHE_WC, NULL))
 		return -EINVAL;
 
@@ -904,7 +904,7 @@ int _set_memory_wb(unsigned long addr, i
 
 int set_memory_wb(unsigned long addr, int numpages)
 {
-	free_memtype(addr, addr + numpages * PAGE_SIZE);
+	free_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE);
 
 	return _set_memory_wb(addr, numpages);
 }
Index: head-2008-09-01/arch/x86/mm/pat-xen.c
===================================================================
--- head-2008-09-01.orig/arch/x86/mm/pat-xen.c	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/arch/x86/mm/pat-xen.c	2008-09-01 16:37:42.000000000 +0200
@@ -219,6 +219,9 @@ static int chk_conflict(struct memtype *
 	return -EBUSY;
 }
 
+static struct memtype *cached_entry;
+static u64 cached_start;
+
 /*
  * req_type typically has one of the:
  * - _PAGE_CACHE_WB
@@ -292,11 +295,17 @@ int reserve_memtype(u64 start, u64 end, 
 
 	spin_lock(&memtype_lock);
 
+	if (cached_entry && start >= cached_start)
+		entry = cached_entry;
+	else
+		entry = list_entry(&memtype_list, struct memtype, nd);
+
 	/* Search for existing mapping that overlaps the current range */
 	where = NULL;
-	list_for_each_entry(entry, &memtype_list, nd) {
+	list_for_each_entry_continue(entry, &memtype_list, nd) {
 		if (end <= entry->start) {
 			where = entry->nd.prev;
+			cached_entry = list_entry(where, struct memtype, nd);
 			break;
 		} else if (start <= entry->start) { /* end > entry->start */
 			err = chk_conflict(new, entry, new_type);
@@ -304,6 +313,8 @@ int reserve_memtype(u64 start, u64 end, 
 				dprintk("Overlap at 0x%Lx-0x%Lx\n",
 					entry->start, entry->end);
 				where = entry->nd.prev;
+				cached_entry = list_entry(where,
+							struct memtype, nd);
 			}
 			break;
 		} else if (start < entry->end) { /* start > entry->start */
@@ -311,7 +322,20 @@ int reserve_memtype(u64 start, u64 end, 
 			if (!err) {
 				dprintk("Overlap at 0x%Lx-0x%Lx\n",
 					entry->start, entry->end);
-				where = &entry->nd;
+				cached_entry = list_entry(entry->nd.prev,
+							struct memtype, nd);
+
+				/*
+				 * Move to right position in the linked
+				 * list to add this new entry
+				 */
+				list_for_each_entry_continue(entry,
+							&memtype_list, nd) {
+					if (start <= entry->start) {
+						where = entry->nd.prev;
+						break;
+					}
+				}
 			}
 			break;
 		}
@@ -326,6 +350,8 @@ int reserve_memtype(u64 start, u64 end, 
 		return err;
 	}
 
+	cached_start = start;
+
 	if (where)
 		list_add(&new->nd, where);
 	else
@@ -355,6 +381,9 @@ int free_memtype(u64 start, u64 end)
 	spin_lock(&memtype_lock);
 	list_for_each_entry(entry, &memtype_list, nd) {
 		if (entry->start == start && entry->end == end) {
+			if (cached_entry == entry || cached_start == start)
+				cached_entry = NULL;
+
 			list_del(&entry->nd);
 			kfree(entry);
 			err = 0;
@@ -373,14 +402,6 @@ int free_memtype(u64 start, u64 end)
 }
 
 
-/*
- * /dev/mem mmap interface. The memtype used for mapping varies:
- * - Use UC for mappings with O_SYNC flag
- * - Without O_SYNC flag, if there is any conflict in reserve_memtype,
- *   inherit the memtype from existing mapping.
- * - Else use UC_MINUS memtype (for backward compatibility with existing
- *   X drivers.
- */
 pgprot_t phys_mem_access_prot(struct file *file, unsigned long mfn,
 				unsigned long size, pgprot_t vma_prot)
 {
@@ -418,14 +439,14 @@ int phys_mem_access_prot_allowed(struct 
 				unsigned long size, pgprot_t *vma_prot)
 {
 	u64 addr = (u64)mfn << PAGE_SHIFT;
-	unsigned long sz, flags = _PAGE_CACHE_UC_MINUS;
+	unsigned long sz, flags = -1;
 	int retval;
 
 	if (!range_is_allowed(mfn, size))
 		return 0;
 
 	if (file->f_flags & O_SYNC) {
-		flags = _PAGE_CACHE_UC;
+		flags = _PAGE_CACHE_UC_MINUS;
 	}
 
 #ifndef CONFIG_X86_32
@@ -450,13 +471,14 @@ int phys_mem_access_prot_allowed(struct 
 #endif
 
 	/*
-	 * With O_SYNC, we can only take UC mapping. Fail if we cannot.
+	 * With O_SYNC, we can only take UC_MINUS mapping. Fail if we cannot.
+	 *
 	 * Without O_SYNC, we want to get
 	 * - WB for WB-able memory and no other conflicting mappings
 	 * - UC_MINUS for non-WB-able memory with no other conflicting mappings
 	 * - Inherit from confliting mappings otherwise
 	 */
-	if (flags != _PAGE_CACHE_UC_MINUS) {
+	if (flags != -1) {
 		retval = reserve_memtype(addr, addr + size, flags, NULL);
 	} else {
 		retval = reserve_memtype(addr, addr + size, -1, &flags);
Index: head-2008-09-01/drivers/xen/netfront/accel.c
===================================================================
--- head-2008-09-01.orig/drivers/xen/netfront/accel.c	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/drivers/xen/netfront/accel.c	2008-09-01 17:14:02.000000000 +0200
@@ -28,6 +28,7 @@
  * IN THE SOFTWARE.
  */
 
+#include <linux/version.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
 #include <linux/list.h>
Index: head-2008-09-01/drivers/xen/sfc_netfront/accel.h
===================================================================
--- head-2008-09-01.orig/drivers/xen/sfc_netfront/accel.h	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/drivers/xen/sfc_netfront/accel.h	2008-09-01 17:17:07.000000000 +0200
@@ -35,6 +35,7 @@
 #include <xen/evtchn.h>
 
 #include <linux/kernel.h>
+#include <linux/version.h>
 #include <linux/list.h>
 
 enum netfront_accel_post_status {
Index: head-2008-09-01/drivers/xen/sfc_netback/accel.h
===================================================================
--- head-2008-09-01.orig/drivers/xen/sfc_netback/accel.h	2008-02-26 10:54:11.000000000 +0100
+++ head-2008-09-01/drivers/xen/sfc_netback/accel.h	2008-09-01 17:19:22.000000000 +0200
@@ -25,6 +25,7 @@
 #ifndef NETBACK_ACCEL_H
 #define NETBACK_ACCEL_H
 
+#include <linux/version.h>
 #include <linux/slab.h>
 #include <linux/ip.h>
 #include <linux/tcp.h>
Index: head-2008-09-01/drivers/xen/xenbus/xenbus_probe.c
===================================================================
--- head-2008-09-01.orig/drivers/xen/xenbus/xenbus_probe.c	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/drivers/xen/xenbus/xenbus_probe.c	2008-09-01 16:47:36.000000000 +0200
@@ -36,6 +36,7 @@
 		 __FUNCTION__, __LINE__, ##args)
 
 #include <linux/kernel.h>
+#include <linux/version.h>
 #include <linux/err.h>
 #include <linux/string.h>
 #include <linux/ctype.h>
Index: head-2008-09-01/include/asm-x86/mach-xen/asm/hypervisor.h
===================================================================
--- head-2008-09-01.orig/include/asm-x86/mach-xen/asm/hypervisor.h	2008-09-01 17:18:49.000000000 +0200
+++ head-2008-09-01/include/asm-x86/mach-xen/asm/hypervisor.h	2008-09-01 16:46:23.000000000 +0200
@@ -35,7 +35,6 @@
 
 #include <linux/types.h>
 #include <linux/kernel.h>
-#include <linux/version.h>
 #include <linux/errno.h>
 #include <xen/interface/xen.h>
 #include <xen/interface/platform.h>
