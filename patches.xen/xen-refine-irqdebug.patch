From: jbeulich@novell.com
Subject: replace forced noirqdebug on 32-bit Xen kernel

It wasn't similarly forced on 64-bits, and it prevented determining spurious
interrupt issues.

Index: head-2006-04-24/arch/i386/kernel/setup-xen.c
===================================================================
--- head-2006-04-24.orig/arch/i386/kernel/setup-xen.c	2006-04-27 17:08:50.000000000 +0200
+++ head-2006-04-24/arch/i386/kernel/setup-xen.c	2006-04-27 17:09:29.000000000 +0200
@@ -1934,10 +1934,6 @@ void __init setup_arch(char **cmdline_p)
 		get_smp_config();
 #endif
 
-	/* XXX Disable irqdebug until we have a way to avoid interrupt
-	 * conflicts. */
-	noirqdebug_setup("");
-
 	register_memory();
 
 	if (xen_start_info->flags & SIF_INITDOMAIN) {
Index: head-2006-04-24/include/xen/interface/xen.h
===================================================================
--- head-2006-04-24.orig/include/xen/interface/xen.h	2006-04-27 17:06:29.000000000 +0200
+++ head-2006-04-24/include/xen/interface/xen.h	2006-04-27 17:10:29.000000000 +0200
@@ -370,6 +370,14 @@ typedef struct shared_info {
 
     arch_shared_info_t arch;
 
+    /*
+     * Indicator which PIRQs are shared with other domains, allowing the guest
+     * to not consider respective interrupts spurious even if no handler claims
+     * them, while still being able to detect spurious occurrences of un-shared
+     * interrupts.
+     */
+    unsigned long pirq_shared[256 / (8 * sizeof(unsigned long))];
+
 } shared_info_t;
 
 /*
Index: head-2006-04-24/kernel/irq/handle.c
===================================================================
--- head-2006-04-24.orig/kernel/irq/handle.c	2006-04-27 16:57:58.000000000 +0200
+++ head-2006-04-24/kernel/irq/handle.c	2006-04-27 10:16:35.000000000 +0200
@@ -12,6 +12,10 @@
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
 
+#ifdef CONFIG_XEN
+#include <asm/hypervisor.h>
+#endif
+
 #include "internals.h"
 
 /*
@@ -76,10 +80,19 @@ irqreturn_t no_action(int cpl, void *dev
 /*
  * Have got an event to handle:
  */
-fastcall int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
+fastcall /*irqreturn_t*/int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
 				struct irqaction *action)
 {
-	int ret, retval = 0, status = 0;
+	irqreturn_t ret, retval = IRQ_NONE;
+	unsigned int status = 0;
+
+#ifdef CONFIG_XEN
+	unsigned int pirq = irq_to_pirq(irq);
+
+	BUILD_BUG_ON(BITS_TO_LONGS(NR_PIRQS) > sizeof(((shared_info_t *)0)->pirq_shared));
+	if (pirq < NR_PIRQS && test_bit(pirq, HYPERVISOR_shared_info->pirq_shared))
+		retval = IRQ_HANDLED;
+#endif
 
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
