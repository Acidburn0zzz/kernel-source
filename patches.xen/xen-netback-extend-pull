From: Ian Campbell <ian.campbell@citrix.com>
Subject: xen/netback: Always pull through PKT_PROT_LEN bytes into the linear part of an skb
Patch-mainline: n/a

Previously PKT_PROT_LEN would only have an effect on the first
fragment.

Signed-off-by: Ian Campbell <ian.campbell@citrix.com>

From: Steven Smith <ssmith@xensource.com>
Subject: xen/netback: try to pull a minimum of 72 bytes into the skb data area

... when receiving a packet into netback.  The previous number, 64,
tended to place a fragment boundary in the middle of the TCP header
options and led to unnecessary fragmentation in Windows <-> Windows
networking.

Acked-by: jbeulich@novell.com

--- head-2010-10-11.orig/drivers/xen/netback/netback.c	2010-10-18 16:25:18.000000000 +0200
+++ head-2010-10-11/drivers/xen/netback/netback.c	2010-10-18 16:25:23.000000000 +0200
@@ -112,7 +112,13 @@ static inline unsigned int netif_page_in
 	return ext.e.idx;
 }
 
-#define PKT_PROT_LEN 64
+/*
+ * This is the amount of packet we copy rather than map, so that the
+ * guest can't fiddle with the contents of the headers while we do
+ * packet processing on them (netfilter, routing, etc). 72 is enough
+ * to cover TCP+IP headers including options.
+ */
+#define PKT_PROT_LEN 72
 
 #define MASK_PEND_IDX(_i) ((_i)&(MAX_PENDING_REQS-1))
 
@@ -1511,6 +1517,16 @@ static void net_tx_action(unsigned long 
 
 		netbk_fill_frags(netbk, skb);
 
+		/*
+		 * If the initial fragment was < PKT_PROT_LEN then
+		 * pull through some bytes from the other fragments to
+		 * increase the linear region to PKT_PROT_LEN bytes.
+		 */
+		if (skb_headlen(skb) < PKT_PROT_LEN && skb_is_nonlinear(skb)) {
+			int target = min_t(int, skb->len, PKT_PROT_LEN);
+			__pskb_pull_tail(skb, target - skb_headlen(skb));
+		}
+
 		skb->dev      = netif->dev;
 		skb->protocol = eth_type_trans(skb, skb->dev);
 
