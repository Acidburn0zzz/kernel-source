From: garloff@suse.de

Subject: Workaround

On HP Proliant DL740 G1 / DL760 G2, the timer IRQ is sent to all CPUs,
but should only be sent to one. This causes time warps.
Probably it's a bug in the MP-BIOS as well as the ACPI tables, but we
can work around ...

Automatically created from "patches.suse/apic-timer-irq-delivery-dl760" by xen-port-patches.py

diff -uNrp linux-2.6.5/arch/i386/kernel/io_apic-xen.c linux-2.6.5.Proliant/arch/i386/kernel/io_apic-xen.c
--- linux-2.6.5/arch/i386/kernel/io_apic-xen.c	2004-06-11 21:33:02.000000000 +0200
+++ linux-2.6.5.Proliant/arch/i386/kernel/io_apic-xen.c	2004-06-11 21:47:16.000000000 +0200
@@ -61,6 +61,9 @@ int sis_apic_bug = -1;
  */
 int nr_ioapic_registers[MAX_IO_APICS];
 
+/* Set by dmi_scan */
+extern int need_timer_irq_tweak;
+
 /*
  * Rough estimation of how many shared IRQs there are, can
  * be changed anytime.
@@ -1282,6 +1285,12 @@ void __init setup_IO_APIC_irqs(void)
 			if (!apic && (irq < 16))
 				disable_8259A_irq(irq);
 		}
+		/* Timer interrupt */
+		if (need_timer_irq_tweak && irq == 0) {
+			entry.delivery_mode = 0;
+			entry.dest_mode = 0;
+			printk("Timer IRQ delivery and dest mode set to 0\n");
+		}
 		spin_lock_irqsave(&ioapic_lock, flags);
 		io_apic_write(apic, 0x11+2*pin, *(((int *)&entry)+1));
 		io_apic_write(apic, 0x10+2*pin, *(((int *)&entry)+0));
@@ -1320,6 +1329,12 @@ void __init setup_ExtINT_IRQ0_pin(unsign
 	entry.trigger = 0;
 	entry.vector = vector;
 
+	if (need_timer_irq_tweak) {
+		entry.delivery_mode = 0;
+		entry.dest_mode = 0;
+		printk("ExtINT_IRQ0_pin: delivery and dest mode set to 0\n");
+	}
+
 	/*
 	 * The timer IRQ doesn't have to know that behind the
 	 * scene we have a 8259A-master in AEOI mode ...
