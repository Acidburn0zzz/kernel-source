Subject: xen3 arch-x86_64
From: http://xenbits.xensource.com/linux-2.6.18-xen.hg (tip 268:709db80c03c3)
Patch-mainline: obsolete
Acked-by: jbeulich@novell.com

Index: head-2007-10-23/arch/x86_64/Makefile
===================================================================
--- head-2007-10-23.orig/arch/x86_64/Makefile	2007-10-19 12:37:13.000000000 +0200
+++ head-2007-10-23/arch/x86_64/Makefile	2007-10-15 16:41:19.000000000 +0200
@@ -36,6 +36,10 @@ cflags-$(CONFIG_MCORE2) += \
 	$(call cc-option,-march=core2,$(call cc-option,-mtune=generic))
 cflags-$(CONFIG_GENERIC_CPU) += $(call cc-option,-mtune=generic)
 
+cppflags-$(CONFIG_XEN) += \
+	-D__XEN_INTERFACE_VERSION__=$(CONFIG_XEN_INTERFACE_VERSION)
+CPPFLAGS += $(cppflags-y)
+
 cflags-y += -m64
 cflags-y += -mno-red-zone
 cflags-y += -mcmodel=kernel
@@ -85,9 +89,21 @@ drivers-$(CONFIG_KDB)			+= arch/x86_64/k
 
 boot := arch/x86_64/boot
 
-PHONY += bzImage bzlilo install archmrproper \
+PHONY += bzImage bzlilo vmlinuz install archmrproper \
 	 fdimage fdimage144 fdimage288 isoimage archclean
 
+ifdef CONFIG_XEN
+CPPFLAGS := -Iinclude$(if $(KBUILD_SRC),2)/asm/mach-xen $(CPPFLAGS)
+LDFLAGS_vmlinux := -e startup_64
+#Default target when executing "make"
+all: vmlinuz
+
+BOOTIMAGE                     := $(boot)/vmlinuz
+KBUILD_IMAGE                  := $(BOOTIMAGE)
+
+vmlinuz: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(BOOTIMAGE)
+else
 #Default target when executing "make"
 all: bzImage
 
@@ -105,6 +121,7 @@ bzdisk: vmlinux
 
 fdimage fdimage144 fdimage288 isoimage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(BOOTIMAGE) $@
+endif
 
 install:
 	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(BOOTIMAGE) $@ 
Index: head-2007-10-23/arch/x86_64/ia32/Makefile
===================================================================
--- head-2007-10-23.orig/arch/x86_64/ia32/Makefile	2006-09-20 05:42:06.000000000 +0200
+++ head-2007-10-23/arch/x86_64/ia32/Makefile	2007-10-15 16:41:19.000000000 +0200
@@ -27,9 +27,18 @@ quiet_cmd_syscall = SYSCALL $@
 			   -Wl,-soname=linux-gate.so.1 -o $@ \
 			   -Wl,-T,$(filter-out FORCE,$^)
 
+$(obj)/vsyscall-int80.so \
 $(obj)/vsyscall-sysenter.so $(obj)/vsyscall-syscall.so: \
 $(obj)/vsyscall-%.so: $(src)/vsyscall.lds $(obj)/vsyscall-%.o FORCE
 	$(call if_changed,syscall)
 
-AFLAGS_vsyscall-sysenter.o = -m32 -Wa,-32
-AFLAGS_vsyscall-syscall.o = -m32 -Wa,-32
+AFLAGS_vsyscall-sysenter.o = -m32 -Wa,-32 -Iarch/i386/kernel
+AFLAGS_vsyscall-syscall.o = -m32 -Wa,-32 -Iarch/i386/kernel
+
+ifdef CONFIG_XEN
+AFLAGS_vsyscall-int80.o = -m32 -Wa,-32 -Iarch/i386/kernel
+CFLAGS_syscall32.o += -DUSE_INT80
+AFLAGS_syscall32_syscall.o += -DUSE_INT80
+
+$(obj)/syscall32_syscall.o: $(obj)/vsyscall-int80.so
+endif
Index: head-2007-10-23/arch/x86_64/ia32/vsyscall-sigreturn.S
===================================================================
--- head-2007-10-23.orig/arch/x86_64/ia32/vsyscall-sigreturn.S	2006-09-20 05:42:06.000000000 +0200
+++ head-2007-10-23/arch/x86_64/ia32/vsyscall-sigreturn.S	2007-10-15 16:41:19.000000000 +0200
@@ -139,5 +139,5 @@ __kernel_rt_sigreturn:
 	.align 4
 .LENDFDE3:
 
-#include "../../i386/kernel/vsyscall-note.S"
+#include <vsyscall-note.S>
 
Index: head-2007-10-23/arch/x86_64/kernel/Makefile
===================================================================
--- head-2007-10-23.orig/arch/x86_64/kernel/Makefile	2007-10-09 22:31:38.000000000 +0200
+++ head-2007-10-23/arch/x86_64/kernel/Makefile	2007-10-15 16:43:26.000000000 +0200
@@ -22,10 +22,12 @@ obj-$(CONFIG_MICROCODE)		+= microcode.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
 obj-$(CONFIG_SMP)		+= smp.o smpboot.o trampoline.o tsc_sync.o
 obj-y				+= apic.o  nmi.o
+obj-$(CONFIG_X86_XEN_GENAPIC)	+= genapic.o genapic_xen.o
 obj-y				+= io_apic.o mpparse.o genapic.o genapic_flat.o
 obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o crash.o
 obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
-obj-$(CONFIG_PM)		+= suspend.o
+obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend.o
+obj-$(CONFIG_ACPI_SLEEP)	+= suspend.o
 obj-$(CONFIG_HIBERNATION)	+= suspend_asm.o
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
@@ -61,3 +63,9 @@ msr-$(subst m,y,$(CONFIG_X86_MSR))  += .
 alternative-y			+= ../../i386/kernel/alternative.o
 pcspeaker-y			+= ../../i386/kernel/pcspeaker.o
 perfctr-watchdog-y		+= ../../i386/kernel/cpu/perfctr-watchdog.o
+
+time-$(CONFIG_XEN)		+= ../../i386/kernel/time.o
+pci-dma-$(CONFIG_XEN)		+= ../../i386/kernel/pci-dma.o
+
+disabled-obj-$(CONFIG_XEN)	:= i8259.o reboot.o smpboot.o trampoline.o
+%/head.o %/head.s: $(if $(CONFIG_XEN),EXTRA_AFLAGS,dummy) :=
Index: head-2007-10-23/arch/x86_64/kernel/asm-offsets.c
===================================================================
--- head-2007-10-23.orig/arch/x86_64/kernel/asm-offsets.c	2007-07-09 01:32:17.000000000 +0200
+++ head-2007-10-23/arch/x86_64/kernel/asm-offsets.c	2007-10-15 16:41:19.000000000 +0200
@@ -75,8 +75,10 @@ int main(void)
 	DEFINE(pbe_address, offsetof(struct pbe, address));
 	DEFINE(pbe_orig_address, offsetof(struct pbe, orig_address));
 	DEFINE(pbe_next, offsetof(struct pbe, next));
+#ifndef CONFIG_X86_NO_TSS
 	BLANK();
 	DEFINE(TSS_ist, offsetof(struct tss_struct, ist));
+#endif
 	BLANK();
 	DEFINE(crypto_tfm_ctx_offset, offsetof(struct crypto_tfm, __crt_ctx));
 	BLANK();
Index: head-2007-10-23/arch/x86_64/kernel/crash.c
===================================================================
--- head-2007-10-23.orig/arch/x86_64/kernel/crash.c	2007-07-09 01:32:17.000000000 +0200
+++ head-2007-10-23/arch/x86_64/kernel/crash.c	2007-10-15 16:44:14.000000000 +0200
@@ -28,6 +28,7 @@
 /* This keeps a track of which one is crashing cpu. */
 static int crashing_cpu;
 
+#ifndef CONFIG_XEN
 #ifdef CONFIG_SMP
 static atomic_t waiting_for_crash_ipi;
 
@@ -107,6 +108,7 @@ static void nmi_shootdown_cpus(void)
 	/* There are no cpus to shootdown */
 }
 #endif
+#endif /* CONFIG_XEN */
 
 void machine_crash_shutdown(struct pt_regs *regs)
 {
@@ -124,12 +126,15 @@ void machine_crash_shutdown(struct pt_re
 
 	/* Make a note of crashing cpu. Will be used in NMI callback.*/
 	crashing_cpu = smp_processor_id();
+
+#ifndef CONFIG_XEN
 	nmi_shootdown_cpus();
 
 	if(cpu_has_apic)
 		 disable_local_APIC();
 
 	disable_IO_APIC();
+#endif /* CONFIG_XEN */
 
 	crash_save_cpu(regs, smp_processor_id());
 }
Index: head-2007-10-23/arch/x86_64/kernel/init_task.c
===================================================================
--- head-2007-10-23.orig/arch/x86_64/kernel/init_task.c	2007-10-09 22:31:38.000000000 +0200
+++ head-2007-10-23/arch/x86_64/kernel/init_task.c	2007-10-15 16:41:19.000000000 +0200
@@ -37,6 +37,8 @@ union thread_union init_thread_union 
 struct task_struct init_task = INIT_TASK(init_task);
 
 EXPORT_SYMBOL(init_task);
+
+#ifndef CONFIG_X86_NO_TSS
 /*
  * per-CPU TSS segments. Threads are completely 'soft' on Linux,
  * no more per-task TSS's. The TSS size is kept cacheline-aligned
@@ -50,5 +52,6 @@ DEFINE_PER_CPU_SHARED_ALIGNED(struct tss
  * debugging, no special alignment required.
  */
 DEFINE_PER_CPU(struct orig_ist, orig_ist);
+#endif
 
 #define ALIGN_TO_4K __attribute__((section(".data.init_task")))
Index: head-2007-10-23/arch/x86_64/kernel/machine_kexec.c
===================================================================
--- head-2007-10-23.orig/arch/x86_64/kernel/machine_kexec.c	2007-10-23 10:49:29.000000000 +0200
+++ head-2007-10-23/arch/x86_64/kernel/machine_kexec.c	2007-10-15 16:41:19.000000000 +0200
@@ -24,6 +24,104 @@ static u64 kexec_pud1[512] PAGE_ALIGNED;
 static u64 kexec_pmd1[512] PAGE_ALIGNED;
 static u64 kexec_pte1[512] PAGE_ALIGNED;
 
+#ifdef CONFIG_XEN
+
+/* In the case of Xen, override hypervisor functions to be able to create
+ * a regular identity mapping page table...
+ */
+
+#include <xen/interface/kexec.h>
+#include <xen/interface/memory.h>
+
+#define x__pmd(x) ((pmd_t) { (x) } )
+#define x__pud(x) ((pud_t) { (x) } )
+#define x__pgd(x) ((pgd_t) { (x) } )
+
+#define x_pmd_val(x)   ((x).pmd)
+#define x_pud_val(x)   ((x).pud)
+#define x_pgd_val(x)   ((x).pgd)
+
+static inline void x_set_pmd(pmd_t *dst, pmd_t val)
+{
+	x_pmd_val(*dst) = x_pmd_val(val);
+}
+
+static inline void x_set_pud(pud_t *dst, pud_t val)
+{
+	x_pud_val(*dst) = phys_to_machine(x_pud_val(val));
+}
+
+static inline void x_pud_clear (pud_t *pud)
+{
+	x_pud_val(*pud) = 0;
+}
+
+static inline void x_set_pgd(pgd_t *dst, pgd_t val)
+{
+	x_pgd_val(*dst) = phys_to_machine(x_pgd_val(val));
+}
+
+static inline void x_pgd_clear (pgd_t * pgd)
+{
+	x_pgd_val(*pgd) = 0;
+}
+
+#define X__PAGE_KERNEL_LARGE_EXEC \
+         _PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_PSE
+#define X_KERNPG_TABLE _PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED | _PAGE_DIRTY
+
+#define __ma(x) (pfn_to_mfn(__pa((x)) >> PAGE_SHIFT) << PAGE_SHIFT)
+
+#if PAGES_NR > KEXEC_XEN_NO_PAGES
+#error PAGES_NR is greater than KEXEC_XEN_NO_PAGES - Xen support will break
+#endif
+
+#if PA_CONTROL_PAGE != 0
+#error PA_CONTROL_PAGE is non zero - Xen support will break
+#endif
+
+void machine_kexec_setup_load_arg(xen_kexec_image_t *xki, struct kimage *image)
+{
+	void *control_page;
+	void *table_page;
+
+	memset(xki->page_list, 0, sizeof(xki->page_list));
+
+	control_page = page_address(image->control_code_page) + PAGE_SIZE;
+	memcpy(control_page, relocate_kernel, PAGE_SIZE);
+
+	table_page = page_address(image->control_code_page);
+
+	xki->page_list[PA_CONTROL_PAGE] = __ma(control_page);
+	xki->page_list[PA_TABLE_PAGE] = __ma(table_page);
+
+	xki->page_list[PA_PGD] = __ma(kexec_pgd);
+	xki->page_list[PA_PUD_0] = __ma(kexec_pud0);
+	xki->page_list[PA_PUD_1] = __ma(kexec_pud1);
+	xki->page_list[PA_PMD_0] = __ma(kexec_pmd0);
+	xki->page_list[PA_PMD_1] = __ma(kexec_pmd1);
+	xki->page_list[PA_PTE_0] = __ma(kexec_pte0);
+	xki->page_list[PA_PTE_1] = __ma(kexec_pte1);
+}
+
+#else /* CONFIG_XEN */
+
+#define x__pmd(x) __pmd(x)
+#define x__pud(x) __pud(x)
+#define x__pgd(x) __pgd(x)
+
+#define x_set_pmd(x, y) set_pmd(x, y)
+#define x_set_pud(x, y) set_pud(x, y)
+#define x_set_pgd(x, y) set_pgd(x, y)
+
+#define x_pud_clear(x) pud_clear(x)
+#define x_pgd_clear(x) pgd_clear(x)
+
+#define X__PAGE_KERNEL_LARGE_EXEC __PAGE_KERNEL_LARGE_EXEC
+#define X_KERNPG_TABLE _KERNPG_TABLE
+
+#endif /* CONFIG_XEN */
+
 static void init_level2_page(pmd_t *level2p, unsigned long addr)
 {
 	unsigned long end_addr;
@@ -31,7 +129,7 @@ static void init_level2_page(pmd_t *leve
 	addr &= PAGE_MASK;
 	end_addr = addr + PUD_SIZE;
 	while (addr < end_addr) {
-		set_pmd(level2p++, __pmd(addr | __PAGE_KERNEL_LARGE_EXEC));
+		x_set_pmd(level2p++, x__pmd(addr | X__PAGE_KERNEL_LARGE_EXEC));
 		addr += PMD_SIZE;
 	}
 }
@@ -56,12 +154,12 @@ static int init_level3_page(struct kimag
 		}
 		level2p = (pmd_t *)page_address(page);
 		init_level2_page(level2p, addr);
-		set_pud(level3p++, __pud(__pa(level2p) | _KERNPG_TABLE));
+		x_set_pud(level3p++, x__pud(__pa(level2p) | X_KERNPG_TABLE));
 		addr += PUD_SIZE;
 	}
 	/* clear the unused entries */
 	while (addr < end_addr) {
-		pud_clear(level3p++);
+		x_pud_clear(level3p++);
 		addr += PUD_SIZE;
 	}
 out:
@@ -92,12 +190,12 @@ static int init_level4_page(struct kimag
 		if (result) {
 			goto out;
 		}
-		set_pgd(level4p++, __pgd(__pa(level3p) | _KERNPG_TABLE));
+		x_set_pgd(level4p++, x__pgd(__pa(level3p) | X_KERNPG_TABLE));
 		addr += PGDIR_SIZE;
 	}
 	/* clear the unused entries */
 	while (addr < end_addr) {
-		pgd_clear(level4p++);
+		x_pgd_clear(level4p++);
 		addr += PGDIR_SIZE;
 	}
 out:
@@ -108,8 +206,14 @@ out:
 static int init_pgtable(struct kimage *image, unsigned long start_pgtable)
 {
 	pgd_t *level4p;
+	unsigned long x_end_pfn = end_pfn;
+
+#ifdef CONFIG_XEN
+	x_end_pfn = HYPERVISOR_memory_op(XENMEM_maximum_ram_page, NULL);
+#endif
+
 	level4p = (pgd_t *)__va(start_pgtable);
- 	return init_level4_page(image, level4p, 0, end_pfn << PAGE_SHIFT);
+ 	return init_level4_page(image, level4p, 0, x_end_pfn << PAGE_SHIFT);
 }
 
 int machine_kexec_prepare(struct kimage *image)
@@ -133,6 +237,7 @@ void machine_kexec_cleanup(struct kimage
 	return;
 }
 
+#ifndef CONFIG_XEN
 /*
  * Do not allocate memory (or fail in any way) in machine_kexec().
  * We are past the point of no return, committed to rebooting now.
@@ -171,6 +276,7 @@ NORET_TYPE void machine_kexec(struct kim
 	relocate_kernel((unsigned long)image->head, (unsigned long)page_list,
 			image->start);
 }
+#endif
 
 /* crashkernel=size@addr specifies the location to reserve for
  * a crash kernel.  By reserving this memory we guarantee
Index: head-2007-10-23/arch/x86_64/kernel/suspend.c
===================================================================
--- head-2007-10-23.orig/arch/x86_64/kernel/suspend.c	2007-10-09 22:31:38.000000000 +0200
+++ head-2007-10-23/arch/x86_64/kernel/suspend.c	2007-10-15 16:41:19.000000000 +0200
@@ -120,12 +120,14 @@ void restore_processor_state(void)
 
 void fix_processor_context(void)
 {
+#ifndef CONFIG_X86_NO_TSS    
 	int cpu = smp_processor_id();
 	struct tss_struct *t = &per_cpu(init_tss, cpu);
 
 	set_tss_desc(cpu,t);	/* This just modifies memory; should not be neccessary. But... This is neccessary, because 386 hardware has concept of busy TSS or some similar stupidity. */
 
 	cpu_gdt(cpu)[GDT_ENTRY_TSS].type = 9;
+#endif
 
 	syscall_init();                         /* This sets MSR_*STAR and related */
 	load_TR_desc();				/* This does ltr */
Index: head-2007-10-23/arch/x86_64/mm/Makefile
===================================================================
--- head-2007-10-23.orig/arch/x86_64/mm/Makefile	2006-03-20 06:53:29.000000000 +0100
+++ head-2007-10-23/arch/x86_64/mm/Makefile	2007-10-15 16:41:19.000000000 +0200
@@ -7,5 +7,8 @@ obj-$(CONFIG_HUGETLB_PAGE) += hugetlbpag
 obj-$(CONFIG_NUMA) += numa.o
 obj-$(CONFIG_K8_NUMA) += k8topology.o
 obj-$(CONFIG_ACPI_NUMA) += srat.o
+obj-$(CONFIG_XEN) += hypervisor.o
 
 hugetlbpage-y = ../../i386/mm/hugetlbpage.o
+ioremap-$(CONFIG_XEN) := ../../i386/mm/ioremap.o
+hypervisor-y := ../../i386/mm/hypervisor.o
Index: head-2007-10-23/arch/x86_64/oprofile/Makefile
===================================================================
--- head-2007-10-23.orig/arch/x86_64/oprofile/Makefile	2006-03-20 06:53:29.000000000 +0100
+++ head-2007-10-23/arch/x86_64/oprofile/Makefile	2007-10-15 16:41:19.000000000 +0200
@@ -11,9 +11,15 @@ DRIVER_OBJS = $(addprefix ../../../drive
 	oprofilefs.o oprofile_stats.o \
 	timer_int.o )
 
+ifdef CONFIG_XEN
+XENOPROF_COMMON_OBJS = $(addprefix ../../../drivers/xen/xenoprof/, \
+			 xenoprofile.o)
+OPROFILE-y := xenoprof.o
+else
 OPROFILE-y := init.o backtrace.o
 OPROFILE-$(CONFIG_X86_LOCAL_APIC) += nmi_int.o op_model_athlon.o op_model_p4.o \
 				     op_model_ppro.o
 OPROFILE-$(CONFIG_X86_IO_APIC)    += nmi_timer_int.o 
-
-oprofile-y = $(DRIVER_OBJS) $(addprefix ../../i386/oprofile/, $(OPROFILE-y))
+endif
+oprofile-y = $(DRIVER_OBJS) $(XENOPROF_COMMON_OBJS) \
+	     $(addprefix ../../i386/oprofile/, $(OPROFILE-y))
Index: head-2007-10-23/arch/x86_64/pci/Makefile
===================================================================
--- head-2007-10-23.orig/arch/x86_64/pci/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ head-2007-10-23/arch/x86_64/pci/Makefile	2007-10-15 16:41:19.000000000 +0200
@@ -15,8 +15,13 @@ obj-$(CONFIG_PCI_MMCONFIG) += mmconfig.o
 
 obj-$(CONFIG_NUMA)	+= k8-bus.o
 
+# pcifront should be after mmconfig.o and direct.o as it should only
+# take over if direct access to the PCI bus is unavailable
+obj-$(CONFIG_XEN_PCIDEV_FRONTEND)	+= pcifront.o
+
 direct-y += ../../i386/pci/direct.o
 acpi-y   += ../../i386/pci/acpi.o
+pcifront-y += ../../i386/pci/pcifront.o
 legacy-y += ../../i386/pci/legacy.o
 irq-y    += ../../i386/pci/irq.o
 common-y += ../../i386/pci/common.o
Index: head-2007-10-23/include/asm-x86_64/acpi.h
===================================================================
--- head-2007-10-23.orig/include/asm-x86_64/acpi.h	2007-10-09 22:31:38.000000000 +0200
+++ head-2007-10-23/include/asm-x86_64/acpi.h	2007-10-15 16:44:51.000000000 +0200
@@ -117,6 +117,11 @@ extern unsigned long acpi_wakeup_address
 /* early initialization routine */
 extern void acpi_reserve_bootmem(void);
 
+#ifdef CONFIG_ACPI_PV_SLEEP
+extern int acpi_notify_hypervisor_state(u8 sleep_state,
+	u32 pm1a_cnt, u32 pm1b_cnt);
+#endif /* CONFIG_ACPI_PV_SLEEP */
+
 #else	/* !CONFIG_ACPI */
 
 #define acpi_lapic 0
Index: head-2007-10-23/include/asm-x86_64/apic.h
===================================================================
--- head-2007-10-23.orig/include/asm-x86_64/apic.h	2007-10-09 22:31:38.000000000 +0200
+++ head-2007-10-23/include/asm-x86_64/apic.h	2007-10-15 16:41:19.000000000 +0200
@@ -95,11 +95,13 @@ extern int apic_is_clustered_box(void);
 #define K8_APIC_EXT_INT_MSG_EXT 0x7
 #define K8_APIC_EXT_LVT_ENTRY_THRESHOLD    0
 
+#ifndef CONFIG_XEN
 void smp_send_timer_broadcast_ipi(void);
 void switch_APIC_timer_to_ipi(void *cpumask);
 void switch_ipi_to_APIC_timer(void *cpumask);
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
+#endif
 
 extern unsigned boot_cpu_id;
 extern int local_apic_timer_c2_ok;
Index: head-2007-10-23/include/asm-x86_64/kexec.h
===================================================================
--- head-2007-10-23.orig/include/asm-x86_64/kexec.h	2007-07-09 01:32:17.000000000 +0200
+++ head-2007-10-23/include/asm-x86_64/kexec.h	2007-10-15 16:41:19.000000000 +0200
@@ -89,6 +89,19 @@ relocate_kernel(unsigned long indirectio
 		unsigned long page_list,
 		unsigned long start_address) ATTRIB_NORET;
 
+/* Under Xen we need to work with machine addresses. These macros give the
+ * machine address of a certain page to the generic kexec code instead of 
+ * the pseudo physical address which would be given by the default macros.
+ */
+
+#ifdef CONFIG_XEN
+#define KEXEC_ARCH_HAS_PAGE_MACROS
+#define kexec_page_to_pfn(page)  pfn_to_mfn(page_to_pfn(page))
+#define kexec_pfn_to_page(pfn)   pfn_to_page(mfn_to_pfn(pfn))
+#define kexec_virt_to_phys(addr) virt_to_machine(addr)
+#define kexec_phys_to_virt(addr) phys_to_virt(machine_to_phys(addr))
+#endif
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _X86_64_KEXEC_H */
