Subject: xen3 arch-x86_64
From: http://xenbits.xensource.com/linux-2.6.18-xen.hg (tip 372:61c96456a3e1)
Patch-mainline: obsolete
Acked-by: jbeulich@novell.com

Index: head-2008-01-08/arch/x86/Makefile_64
===================================================================
--- head-2008-01-08.orig/arch/x86/Makefile_64	2008-01-08 11:43:38.000000000 +0100
+++ head-2008-01-08/arch/x86/Makefile_64	2008-01-08 12:02:55.000000000 +0100
@@ -93,9 +93,22 @@ drivers-$(CONFIG_KDB)			+= arch/x86/kdb/
 
 boot := arch/x86/boot
 
-PHONY += bzImage bzlilo install archmrproper \
+PHONY += bzImage bzlilo vmlinuz install archmrproper \
 	 fdimage fdimage144 fdimage288 isoimage archclean
 
+ifdef CONFIG_XEN
+CPPFLAGS := -D__XEN_INTERFACE_VERSION__=$(CONFIG_XEN_INTERFACE_VERSION) \
+	-Iinclude$(if $(KBUILD_SRC),2)/asm/mach-xen $(CPPFLAGS)
+LDFLAGS_vmlinux := -e startup_64
+#Default target when executing "make"
+all: vmlinuz
+
+BOOTIMAGE                     := $(boot)/vmlinuz
+KBUILD_IMAGE                  := $(BOOTIMAGE)
+
+vmlinuz: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(BOOTIMAGE)
+else
 #Default target when executing "make"
 all: bzImage
 
@@ -115,6 +128,7 @@ bzdisk: vmlinux
 
 fdimage fdimage144 fdimage288 isoimage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(BOOTIMAGE) $@
+endif
 
 install: vdso_install
 	$(Q)$(MAKE) $(build)=$(boot) BOOTIMAGE=$(BOOTIMAGE) $@ 
Index: head-2008-01-08/arch/x86/ia32/Makefile
===================================================================
--- head-2008-01-08.orig/arch/x86/ia32/Makefile	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/arch/x86/ia32/Makefile	2008-01-08 12:02:55.000000000 +0100
@@ -14,11 +14,14 @@ obj-$(CONFIG_IA32_AOUT) += ia32_aout.o
 audit-class-$(CONFIG_AUDIT) := audit.o
 obj-$(CONFIG_IA32_EMULATION) += $(audit-class-y)
 
+syscall32-types-y := sysenter syscall
+syscall32-types-$(subst 1,$(CONFIG_XEN),$(shell expr $(CONFIG_XEN_COMPAT)0 '<' 0x0302000)) += int80
+
 $(obj)/syscall32_syscall.o: \
-	$(foreach F,sysenter syscall,$(obj)/vsyscall-$F.so)
+	$(foreach F,$(syscall32-types-y),$(obj)/vsyscall-$F.so)
 
 # Teach kbuild about targets
-targets := $(foreach F,$(addprefix vsyscall-,sysenter syscall),\
+targets := $(foreach F,$(addprefix vsyscall-,$(syscall32-types-y)),\
 		     $F.o $F.so $F.so.dbg)
 
 # The DSO images are built using a special linker script
@@ -32,12 +35,13 @@ $(obj)/%.so: OBJCOPYFLAGS := -S
 $(obj)/%.so: $(obj)/%.so.dbg FORCE
 	$(call if_changed,objcopy)
 
-$(obj)/vsyscall-sysenter.so.dbg $(obj)/vsyscall-syscall.so.dbg: \
+$(foreach F,$(syscall32-types-y),$(obj)/vsyscall-$F.so.dbg): \
 $(obj)/vsyscall-%.so.dbg: $(src)/vsyscall.lds $(obj)/vsyscall-%.o FORCE
 	$(call if_changed,syscall)
 
 AFLAGS_vsyscall-sysenter.o = -m32 -Wa,-32
 AFLAGS_vsyscall-syscall.o = -m32 -Wa,-32
+AFLAGS_vsyscall-int80.o = -m32 -Wa,-32
 
 vdsos := vdso32-sysenter.so vdso32-syscall.so
 
Index: head-2008-01-08/arch/x86/kernel/Makefile_64
===================================================================
--- head-2008-01-08.orig/arch/x86/kernel/Makefile_64	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/arch/x86/kernel/Makefile_64	2008-01-08 12:02:55.000000000 +0100
@@ -21,10 +21,12 @@ obj-$(CONFIG_MICROCODE)		+= microcode.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
 obj-$(CONFIG_SMP)		+= smp_64.o smpboot_64.o trampoline_64.o tsc_sync.o
 obj-y				+= apic_64.o  nmi_64.o
+obj-$(CONFIG_X86_XEN_GENAPIC)	+= genapic_64.o genapic_xen_64.o
 obj-y				+= io_apic_64.o mpparse_64.o genapic_64.o genapic_flat_64.o
 obj-$(CONFIG_KEXEC)		+= machine_kexec_64.o relocate_kernel_64.o crash.o
 obj-$(CONFIG_CRASH_DUMP)	+= crash_dump_64.o
-obj-$(CONFIG_PM)		+= suspend_64.o
+obj-$(CONFIG_SOFTWARE_SUSPEND)	+= suspend_64.o
+obj-$(CONFIG_ACPI_SLEEP)	+= suspend_64.o
 obj-$(CONFIG_HIBERNATION)	+= suspend_asm_64.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_GART_IOMMU)	+= pci-gart_64.o aperture_64.o
@@ -43,3 +45,9 @@ obj-y				+= topology.o
 obj-y				+= pcspeaker.o
 
 CFLAGS_vsyscall_64.o		:= $(PROFILING) -g0
+
+time-$(CONFIG_XEN)		+= ../../i386/kernel/time.o
+pci-dma-$(CONFIG_XEN)		+= ../../i386/kernel/pci-dma.o
+
+disabled-obj-$(CONFIG_XEN)	:= i8259.o reboot.o smpboot.o trampoline.o
+%/head.o %/head.s: $(if $(CONFIG_XEN),EXTRA_AFLAGS,dummy) :=
Index: head-2008-01-08/arch/x86/kernel/asm-offsets_64.c
===================================================================
--- head-2008-01-08.orig/arch/x86/kernel/asm-offsets_64.c	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/arch/x86/kernel/asm-offsets_64.c	2008-01-08 12:02:55.000000000 +0100
@@ -108,8 +108,10 @@ int main(void)
 	ENTRY(cr8);
 	BLANK();
 #undef ENTRY
+#ifndef CONFIG_X86_NO_TSS
 	DEFINE(TSS_ist, offsetof(struct tss_struct, ist));
 	BLANK();
+#endif
 	DEFINE(crypto_tfm_ctx_offset, offsetof(struct crypto_tfm, __crt_ctx));
 	BLANK();
 	DEFINE(__NR_syscall_max, sizeof(syscalls) - 1);
Index: head-2008-01-08/arch/x86/kernel/init_task.c
===================================================================
--- head-2008-01-08.orig/arch/x86/kernel/init_task.c	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/arch/x86/kernel/init_task.c	2008-01-08 12:02:55.000000000 +0100
@@ -36,6 +36,7 @@ union thread_union init_thread_union
 struct task_struct init_task = INIT_TASK(init_task);
 EXPORT_SYMBOL(init_task);
 
+
 /*
  * per-CPU TSS segments. Threads are completely 'soft' on Linux,
  * no more per-task TSS's. The TSS size is kept cacheline-aligned
@@ -44,4 +45,3 @@ EXPORT_SYMBOL(init_task);
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */
 DEFINE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss) = INIT_TSS;
-
Index: head-2008-01-08/arch/x86/kernel/machine_kexec_64.c
===================================================================
--- head-2008-01-08.orig/arch/x86/kernel/machine_kexec_64.c	2008-01-08 11:45:10.000000000 +0100
+++ head-2008-01-08/arch/x86/kernel/machine_kexec_64.c	2008-01-08 12:02:55.000000000 +0100
@@ -25,6 +25,104 @@ static u64 kexec_pud1[512] PAGE_ALIGNED;
 static u64 kexec_pmd1[512] PAGE_ALIGNED;
 static u64 kexec_pte1[512] PAGE_ALIGNED;
 
+#ifdef CONFIG_XEN
+
+/* In the case of Xen, override hypervisor functions to be able to create
+ * a regular identity mapping page table...
+ */
+
+#include <xen/interface/kexec.h>
+#include <xen/interface/memory.h>
+
+#define x__pmd(x) ((pmd_t) { (x) } )
+#define x__pud(x) ((pud_t) { (x) } )
+#define x__pgd(x) ((pgd_t) { (x) } )
+
+#define x_pmd_val(x)   ((x).pmd)
+#define x_pud_val(x)   ((x).pud)
+#define x_pgd_val(x)   ((x).pgd)
+
+static inline void x_set_pmd(pmd_t *dst, pmd_t val)
+{
+	x_pmd_val(*dst) = x_pmd_val(val);
+}
+
+static inline void x_set_pud(pud_t *dst, pud_t val)
+{
+	x_pud_val(*dst) = phys_to_machine(x_pud_val(val));
+}
+
+static inline void x_pud_clear (pud_t *pud)
+{
+	x_pud_val(*pud) = 0;
+}
+
+static inline void x_set_pgd(pgd_t *dst, pgd_t val)
+{
+	x_pgd_val(*dst) = phys_to_machine(x_pgd_val(val));
+}
+
+static inline void x_pgd_clear (pgd_t * pgd)
+{
+	x_pgd_val(*pgd) = 0;
+}
+
+#define X__PAGE_KERNEL_LARGE_EXEC \
+         _PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_PSE
+#define X_KERNPG_TABLE _PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED | _PAGE_DIRTY
+
+#define __ma(x) (pfn_to_mfn(__pa((x)) >> PAGE_SHIFT) << PAGE_SHIFT)
+
+#if PAGES_NR > KEXEC_XEN_NO_PAGES
+#error PAGES_NR is greater than KEXEC_XEN_NO_PAGES - Xen support will break
+#endif
+
+#if PA_CONTROL_PAGE != 0
+#error PA_CONTROL_PAGE is non zero - Xen support will break
+#endif
+
+void machine_kexec_setup_load_arg(xen_kexec_image_t *xki, struct kimage *image)
+{
+	void *control_page;
+	void *table_page;
+
+	memset(xki->page_list, 0, sizeof(xki->page_list));
+
+	control_page = page_address(image->control_code_page) + PAGE_SIZE;
+	memcpy(control_page, relocate_kernel, PAGE_SIZE);
+
+	table_page = page_address(image->control_code_page);
+
+	xki->page_list[PA_CONTROL_PAGE] = __ma(control_page);
+	xki->page_list[PA_TABLE_PAGE] = __ma(table_page);
+
+	xki->page_list[PA_PGD] = __ma(kexec_pgd);
+	xki->page_list[PA_PUD_0] = __ma(kexec_pud0);
+	xki->page_list[PA_PUD_1] = __ma(kexec_pud1);
+	xki->page_list[PA_PMD_0] = __ma(kexec_pmd0);
+	xki->page_list[PA_PMD_1] = __ma(kexec_pmd1);
+	xki->page_list[PA_PTE_0] = __ma(kexec_pte0);
+	xki->page_list[PA_PTE_1] = __ma(kexec_pte1);
+}
+
+#else /* CONFIG_XEN */
+
+#define x__pmd(x) __pmd(x)
+#define x__pud(x) __pud(x)
+#define x__pgd(x) __pgd(x)
+
+#define x_set_pmd(x, y) set_pmd(x, y)
+#define x_set_pud(x, y) set_pud(x, y)
+#define x_set_pgd(x, y) set_pgd(x, y)
+
+#define x_pud_clear(x) pud_clear(x)
+#define x_pgd_clear(x) pgd_clear(x)
+
+#define X__PAGE_KERNEL_LARGE_EXEC __PAGE_KERNEL_LARGE_EXEC
+#define X_KERNPG_TABLE _KERNPG_TABLE
+
+#endif /* CONFIG_XEN */
+
 static void init_level2_page(pmd_t *level2p, unsigned long addr)
 {
 	unsigned long end_addr;
@@ -32,7 +130,7 @@ static void init_level2_page(pmd_t *leve
 	addr &= PAGE_MASK;
 	end_addr = addr + PUD_SIZE;
 	while (addr < end_addr) {
-		set_pmd(level2p++, __pmd(addr | __PAGE_KERNEL_LARGE_EXEC));
+		x_set_pmd(level2p++, x__pmd(addr | X__PAGE_KERNEL_LARGE_EXEC));
 		addr += PMD_SIZE;
 	}
 }
@@ -57,12 +155,12 @@ static int init_level3_page(struct kimag
 		}
 		level2p = (pmd_t *)page_address(page);
 		init_level2_page(level2p, addr);
-		set_pud(level3p++, __pud(__pa(level2p) | _KERNPG_TABLE));
+		x_set_pud(level3p++, x__pud(__pa(level2p) | X_KERNPG_TABLE));
 		addr += PUD_SIZE;
 	}
 	/* clear the unused entries */
 	while (addr < end_addr) {
-		pud_clear(level3p++);
+		x_pud_clear(level3p++);
 		addr += PUD_SIZE;
 	}
 out:
@@ -93,12 +191,12 @@ static int init_level4_page(struct kimag
 		if (result) {
 			goto out;
 		}
-		set_pgd(level4p++, __pgd(__pa(level3p) | _KERNPG_TABLE));
+		x_set_pgd(level4p++, x__pgd(__pa(level3p) | X_KERNPG_TABLE));
 		addr += PGDIR_SIZE;
 	}
 	/* clear the unused entries */
 	while (addr < end_addr) {
-		pgd_clear(level4p++);
+		x_pgd_clear(level4p++);
 		addr += PGDIR_SIZE;
 	}
 out:
@@ -109,8 +207,14 @@ out:
 static int init_pgtable(struct kimage *image, unsigned long start_pgtable)
 {
 	pgd_t *level4p;
+	unsigned long x_end_pfn = end_pfn;
+
+#ifdef CONFIG_XEN
+	x_end_pfn = HYPERVISOR_memory_op(XENMEM_maximum_ram_page, NULL);
+#endif
+
 	level4p = (pgd_t *)__va(start_pgtable);
- 	return init_level4_page(image, level4p, 0, end_pfn << PAGE_SHIFT);
+ 	return init_level4_page(image, level4p, 0, x_end_pfn << PAGE_SHIFT);
 }
 
 int machine_kexec_prepare(struct kimage *image)
@@ -134,6 +238,7 @@ void machine_kexec_cleanup(struct kimage
 	return;
 }
 
+#ifndef CONFIG_XEN
 /*
  * Do not allocate memory (or fail in any way) in machine_kexec().
  * We are past the point of no return, committed to rebooting now.
@@ -172,6 +277,7 @@ NORET_TYPE void machine_kexec(struct kim
 	relocate_kernel((unsigned long)image->head, (unsigned long)page_list,
 			image->start);
 }
+#endif
 
 void arch_crash_save_vmcoreinfo(void)
 {
Index: head-2008-01-08/arch/x86/kernel/suspend_64.c
===================================================================
--- head-2008-01-08.orig/arch/x86/kernel/suspend_64.c	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/arch/x86/kernel/suspend_64.c	2008-01-08 12:02:55.000000000 +0100
@@ -115,12 +115,14 @@ void restore_processor_state(void)
 
 void fix_processor_context(void)
 {
+#ifndef CONFIG_X86_NO_TSS    
 	int cpu = smp_processor_id();
 	struct tss_struct *t = &per_cpu(init_tss, cpu);
 
 	set_tss_desc(cpu,t);	/* This just modifies memory; should not be necessary. But... This is necessary, because 386 hardware has concept of busy TSS or some similar stupidity. */
 
 	cpu_gdt(cpu)[GDT_ENTRY_TSS].type = 9;
+#endif
 
 	syscall_init();                         /* This sets MSR_*STAR and related */
 	load_TR_desc();				/* This does ltr */
Index: head-2008-01-08/arch/x86/mm/Makefile_64
===================================================================
--- head-2008-01-08.orig/arch/x86/mm/Makefile_64	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/arch/x86/mm/Makefile_64	2008-01-08 12:02:55.000000000 +0100
@@ -7,4 +7,7 @@ obj-$(CONFIG_HUGETLB_PAGE) += hugetlbpag
 obj-$(CONFIG_NUMA) += numa_64.o
 obj-$(CONFIG_K8_NUMA) += k8topology_64.o
 obj-$(CONFIG_ACPI_NUMA) += srat_64.o
+obj-$(CONFIG_XEN) += hypervisor.o
 
+ioremap-$(CONFIG_XEN) := ../../i386/mm/ioremap.o
+hypervisor-y := ../../i386/mm/hypervisor.o
Index: head-2008-01-08/arch/x86/pci/Makefile_64
===================================================================
--- head-2008-01-08.orig/arch/x86/pci/Makefile_64	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/arch/x86/pci/Makefile_64	2008-01-08 12:02:55.000000000 +0100
@@ -15,3 +15,7 @@ obj-$(CONFIG_PCI_MMCONFIG) += mmconfig_6
 
 obj-$(CONFIG_NUMA)	+= k8-bus_64.o
 
+# pcifront should be after mmconfig.o and direct.o as it should only
+# take over if direct access to the PCI bus is unavailable
+obj-$(CONFIG_XEN_PCIDEV_FRONTEND)	+= pcifront.o
+
Index: head-2008-01-08/include/asm-x86/acpi_64.h
===================================================================
--- head-2008-01-08.orig/include/asm-x86/acpi_64.h	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/include/asm-x86/acpi_64.h	2008-01-08 12:02:55.000000000 +0100
@@ -117,6 +117,11 @@ extern unsigned long acpi_wakeup_address
 /* early initialization routine */
 extern void acpi_reserve_bootmem(void);
 
+#ifdef CONFIG_ACPI_PV_SLEEP
+extern int acpi_notify_hypervisor_state(u8 sleep_state,
+	u32 pm1a_cnt, u32 pm1b_cnt);
+#endif /* CONFIG_ACPI_PV_SLEEP */
+
 #else	/* !CONFIG_ACPI */
 
 #define acpi_lapic 0
@@ -133,7 +138,9 @@ extern int acpi_scan_nodes(unsigned long
 extern int acpi_disabled;
 extern int acpi_pci_disabled;
 
+#ifndef CONFIG_XEN
 #define ARCH_HAS_POWER_INIT 1
+#endif
 
 extern int acpi_skip_timer_override;
 extern int acpi_use_timer_override;
Index: head-2008-01-08/include/asm-x86/apic_64.h
===================================================================
--- head-2008-01-08.orig/include/asm-x86/apic_64.h	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/include/asm-x86/apic_64.h	2008-01-08 12:02:55.000000000 +0100
@@ -94,7 +94,9 @@ extern int apic_is_clustered_box(void);
 #define K8_APIC_EXT_INT_MSG_EXT 0x7
 #define K8_APIC_EXT_LVT_ENTRY_THRESHOLD    0
 
+#ifndef CONFIG_XEN
 #define ARCH_APICTIMER_STOPS_ON_C3	1
+#endif
 
 extern unsigned boot_cpu_id;
 extern int local_apic_timer_c2_ok;
Index: head-2008-01-08/include/asm-x86/kexec_64.h
===================================================================
--- head-2008-01-08.orig/include/asm-x86/kexec_64.h	2008-01-08 11:43:15.000000000 +0100
+++ head-2008-01-08/include/asm-x86/kexec_64.h	2008-01-08 12:02:55.000000000 +0100
@@ -89,6 +89,19 @@ relocate_kernel(unsigned long indirectio
 		unsigned long page_list,
 		unsigned long start_address) ATTRIB_NORET;
 
+/* Under Xen we need to work with machine addresses. These macros give the
+ * machine address of a certain page to the generic kexec code instead of 
+ * the pseudo physical address which would be given by the default macros.
+ */
+
+#ifdef CONFIG_XEN
+#define KEXEC_ARCH_HAS_PAGE_MACROS
+#define kexec_page_to_pfn(page)  pfn_to_mfn(page_to_pfn(page))
+#define kexec_pfn_to_page(pfn)   pfn_to_page(mfn_to_pfn(pfn))
+#define kexec_virt_to_phys(addr) virt_to_machine(addr)
+#define kexec_phys_to_virt(addr) phys_to_virt(machine_to_phys(addr))
+#endif
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _X86_64_KEXEC_H */
