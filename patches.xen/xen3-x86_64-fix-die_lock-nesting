Subject: fix die_lock nesting
From: Corey Minyard <minyard@acm.org>
Acked-by: ak@suse.de
Patch-mainline: hopefully 2.6.17

I noticed this when poking around in this area.

The oops_begin() function in x86_64 would only conditionally claim
the die_lock if the call is nested, but oops_end() would always
release the spinlock. This patch adds a nest count for the die lock
so that the release of the lock is only done on the final oops_end().

Signed-off-by: Corey Minyard <minyard@acm.org>
Signed-off-by: Andi Kleen <ak@suse.de>

Automatically created from "patches.arch/x86_64-fix-die_lock-nesting" by xen-port-patches.py

Index: head-2006-05-03/arch/x86_64/kernel/traps-xen.c
===================================================================
--- head-2006-05-03.orig/arch/x86_64/kernel/traps-xen.c	2006-05-08 17:08:32.000000000 +0200
+++ head-2006-05-03/arch/x86_64/kernel/traps-xen.c	2006-05-08 17:09:30.000000000 +0200
@@ -389,6 +389,7 @@ void out_of_line_bug(void)
 
 static DEFINE_SPINLOCK(die_lock);
 static int die_owner = -1;
+static unsigned int die_nest_count;
 
 unsigned __kprobes long oops_begin(void)
 {
@@ -403,6 +404,7 @@ unsigned __kprobes long oops_begin(void)
 		else
 			spin_lock(&die_lock);
 	}
+	die_nest_count++;
 	die_owner = cpu;
 	console_verbose();
 	bust_spinlocks(1);
@@ -413,7 +415,13 @@ void __kprobes oops_end(unsigned long fl
 { 
 	die_owner = -1;
 	bust_spinlocks(0);
-	spin_unlock_irqrestore(&die_lock, flags);
+	die_nest_count--;
+	if (die_nest_count)
+		/* We still own the lock */
+		local_irq_restore(flags);
+	else
+		/* Nest count reaches zero, release the lock. */
+		spin_unlock_irqrestore(&die_lock, flags);
 	if (panic_on_oops)
 		panic("Oops");
 }
