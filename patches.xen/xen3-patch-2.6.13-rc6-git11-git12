Subject: patch-2.6.13-rc6-git12
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

Automatically created from "patches.fixes/patch-2.6.13-rc6-git11-git12" by xen-port-patches.py

Index: linux-2.6.12/arch/xen/x86_64/kernel/smpboot.c
===================================================================
--- linux-2.6.12.orig/arch/xen/x86_64/kernel/smpboot.c
+++ linux-2.6.12/arch/xen/x86_64/kernel/smpboot.c
@@ -547,8 +547,18 @@ void __cpuinit start_secondary(void)
 	 * this cpu
 	 */
 	set_cpu_sibling_map(smp_processor_id());
 
+#ifndef CONFIG_XEN
+	/* 
+  	 * Wait for TSC sync to not schedule things before.
+	 * We still process interrupts, which could see an inconsistent
+	 * time in that window unfortunately. 
+	 * Do this here because TSC sync has global unprotected state.
+ 	 */
+	tsc_sync_wait();
+#endif
+
 	/*
 	 * We need to hold call_lock, so there is no inconsistency
 	 * between the time smp_call_function() determines number of
 	 * IPI receipients, and the time when the determination is made
@@ -564,17 +574,8 @@ void __cpuinit start_secondary(void)
 	cpu_set(smp_processor_id(), cpu_online_map);
 	per_cpu(cpu_state, smp_processor_id()) = CPU_ONLINE;
 	unlock_ipi_call_lock();
 
-	mb();
-
-#ifndef CONFIG_XEN
-	/* Wait for TSC sync to not schedule things before.
-	   We still process interrupts, which could see an inconsistent
-	   time in that window unfortunately. */
-	tsc_sync_wait();
-#endif
-
 	cpu_idle();
 }
 
 extern volatile unsigned long init_rsp;
Index: linux-2.6.12/arch/xen/x86_64/mm/fault.c
===================================================================
--- linux-2.6.12.orig/arch/xen/x86_64/mm/fault.c
+++ linux-2.6.12/arch/xen/x86_64/mm/fault.c
@@ -212,11 +212,9 @@ static int is_errata93(struct pt_regs *r
 int unhandled_signal(struct task_struct *tsk, int sig)
 {
 	if (tsk->pid == 1)
 		return 1;
-	/* Warn for strace, but not for gdb */
-	if (!test_ti_thread_flag(tsk->thread_info, TIF_SYSCALL_TRACE) &&
-	    (tsk->ptrace & PT_PTRACED))
+	if (tsk->ptrace & PT_PTRACED)
 		return 0;
 	return (tsk->sighand->action[sig-1].sa.sa_handler == SIG_IGN) ||
 		(tsk->sighand->action[sig-1].sa.sa_handler == SIG_DFL);
 }
