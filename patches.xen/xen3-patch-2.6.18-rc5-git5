Patch-mainline: 2.6.18-rc5-git3
From: Linus Torvalds <torvalds@osdl.org>

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

Automatically created from "patches.kernel.org/patch-2.6.18-rc5-git3" by xen-port-patches.py

Index: head-2006-09-01/arch/i386/kernel/head-xen.S
===================================================================
--- head-2006-09-01.orig/arch/i386/kernel/head-xen.S	2006-08-28 10:47:57.000000000 +0200
+++ head-2006-09-01/arch/i386/kernel/head-xen.S	2006-09-01 09:52:20.000000000 +0200
@@ -61,10 +61,8 @@ ENTRY(startup_32)
 	movl %eax,%gs
 	cld			# gcc2 wants the direction flag cleared at all times
 
-	call start_kernel
-L6:
-	jmp L6			# main should never return here, but
-				# just in case, we know what happens.
+	pushl %eax		# fake return address
+	jmp start_kernel
 
 #define HYPERCALL_PAGE_OFFSET 0x1000
 .org HYPERCALL_PAGE_OFFSET
Index: head-2006-09-01/arch/i386/kernel/irq-xen.c
===================================================================
--- head-2006-09-01.orig/arch/i386/kernel/irq-xen.c	2006-08-28 10:46:28.000000000 +0200
+++ head-2006-09-01/arch/i386/kernel/irq-xen.c	2006-09-01 09:52:20.000000000 +0200
@@ -82,10 +82,6 @@ fastcall unsigned int do_IRQ(struct pt_r
 	}
 #endif
 
-	if (!irq_desc[irq].handle_irq) {
-		__do_IRQ(irq, regs);
-		goto out_exit;
-	}
 #ifdef CONFIG_4KSTACKS
 
 	curctx = (union irq_ctx *) current_thread_info();
@@ -125,7 +121,6 @@ fastcall unsigned int do_IRQ(struct pt_r
 #endif
 		__do_IRQ(irq, regs);
 
-out_exit:
 	irq_exit();
 
 	return 1;
Index: head-2006-09-01/arch/i386/kernel/setup-xen.c
===================================================================
--- head-2006-09-01.orig/arch/i386/kernel/setup-xen.c	2006-08-28 10:46:28.000000000 +0200
+++ head-2006-09-01/arch/i386/kernel/setup-xen.c	2006-09-01 11:13:58.000000000 +0200
@@ -1009,52 +1009,6 @@ efi_memory_present_wrapper(unsigned long
 	return 0;
 }
 
-#ifdef CONFIG_XEN
-static struct e820entry *__initdata machine_e820;
-static unsigned __initdata machine_e820_count;
-#endif
-
- /*
-  * This function checks if the entire range <start,end> is mapped with type.
-  *
-  * Note: this function only works correct if the e820 table is sorted and
-  * not-overlapping, which is the case
-  */
-int __init
-e820_all_mapped(unsigned long s, unsigned long e, unsigned type)
-{
-	u64 start = s;
-	u64 end = e;
-	int i;
-
-#ifndef CONFIG_XEN
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
-#else
-	if (!is_initial_xendomain())
-		return 0;
-	WARN_ON(!machine_e820);
-	for (i = 0; i < machine_e820_count; ++i) {
-		const struct e820entry *ei = &machine_e820[i];
-#endif
-		if (type && ei->type != type)
-			continue;
-		/* is the region (part) in overlap with the current region ?*/
-		if (ei->addr >= end || ei->addr + ei->size <= start)
-			continue;
-		/* if the region is at the beginning of <start,end> we move
-		 * start to the end of the region since it's ok until there
-		 */
-		if (ei->addr <= start)
-			start = ei->addr + ei->size;
-		/* if start is now at or beyond end, we're done, full
-		 * coverage */
-		if (start >= end)
-			return 1; /* we're done */
-	}
-	return 0;
-}
-
 /*
  * Find the highest page frame number we have available
  */
@@ -1488,6 +1442,11 @@ e820_setup_gap(struct e820entry *e820, i
 		pci_mem_start, gapstart, gapsize);
 }
 
+#ifdef CONFIG_XEN
+static struct e820entry *__initdata machine_e820;
+static unsigned __initdata machine_e820_count;
+#endif
+
 /*
  * Request address space for all standard resources
  *
@@ -1507,9 +1466,13 @@ static int __init request_standard_resou
 	}
 
 #ifdef CONFIG_XEN
-	if (is_initial_xendomain())
+	if (is_initial_xendomain()) {
 		legacy_init_iomem_resources(machine_e820, machine_e820_count,
 					    &code_resource, &data_resource);
+		free_init_pages("machine memory map",
+		                (unsigned long)machine_e820,
+		                (unsigned long)machine_e820 + PAGE_SIZE);
+	}
 	else
 #endif
 	if (efi_enabled)
Index: head-2006-09-01/arch/i386/kernel/traps-xen.c
===================================================================
--- head-2006-09-01.orig/arch/i386/kernel/traps-xen.c	2006-08-28 10:49:12.000000000 +0200
+++ head-2006-09-01/arch/i386/kernel/traps-xen.c	2006-09-01 11:13:59.000000000 +0200
@@ -98,7 +98,11 @@ asmlinkage void fixup_4gb_segment(void);
 asmlinkage void machine_check(void);
 
 static int kstack_depth_to_print = 24;
+#ifdef CONFIG_STACK_UNWIND
 static int call_trace = 1;
+#else
+#define call_trace (-1)
+#endif
 ATOMIC_NOTIFIER_HEAD(i386die_chain);
 
 int register_die_notifier(struct notifier_block *nb)
@@ -193,22 +197,21 @@ static void show_trace_log_lvl(struct ta
 			if (unwind_init_blocked(&info, task) == 0)
 				unw_ret = show_trace_unwind(&info, log_lvl);
 		}
-		if (unw_ret > 0 && !arch_unw_user_mode(&info)) {
-#ifdef CONFIG_STACK_UNWIND
-			print_symbol("DWARF2 unwinder stuck at %s\n",
-				     UNW_PC(&info));
-			if (call_trace == 1) {
-				printk("Leftover inexact backtrace:\n");
-				if (UNW_SP(&info))
+		if (unw_ret > 0) {
+			if (call_trace == 1 && !arch_unw_user_mode(&info)) {
+				print_symbol("DWARF2 unwinder stuck at %s\n",
+					     UNW_PC(&info));
+				if (UNW_SP(&info) >= PAGE_OFFSET) {
+					printk("Leftover inexact backtrace:\n");
 					stack = (void *)UNW_SP(&info);
-			} else if (call_trace > 1)
+				} else
+					printk("Full inexact backtrace again:\n");
+			} else if (call_trace >= 1)
 				return;
 			else
 				printk("Full inexact backtrace again:\n");
-#else
+		} else
 			printk("Inexact backtrace:\n");
-#endif
-		}
 	}
 
 	if (task == current) {
@@ -1166,6 +1169,7 @@ static int __init kstack_setup(char *s)
 }
 __setup("kstack=", kstack_setup);
 
+#ifdef CONFIG_STACK_UNWIND
 static int __init call_trace_setup(char *s)
 {
 	if (strcmp(s, "old") == 0)
@@ -1179,3 +1183,4 @@ static int __init call_trace_setup(char 
 	return 1;
 }
 __setup("call_trace=", call_trace_setup);
+#endif
Index: head-2006-09-01/arch/x86_64/kernel/e820-xen.c
===================================================================
--- head-2006-09-01.orig/arch/x86_64/kernel/e820-xen.c	2006-08-28 10:46:28.000000000 +0200
+++ head-2006-09-01/arch/x86_64/kernel/e820-xen.c	2006-09-01 11:14:26.000000000 +0200
@@ -73,7 +73,11 @@ static inline int bad_addr(unsigned long
 #endif
 	/* kernel code + 640k memory hole (later should not be needed, but 
 	   be paranoid for now) */
-	if (last >= 640*1024 && addr < __pa_symbol(&_end)) { 
+	if (last >= 640*1024 && addr < 1024*1024) {
+		*addrp = 1024*1024;
+		return 1;
+	}
+	if (last >= __pa_symbol(&_text) && last < __pa_symbol(&_end)) {
 		*addrp = __pa_symbol(&_end);
 		return 1;
 	}
@@ -114,50 +118,6 @@ e820_any_mapped(unsigned long start, uns
 }
 #endif
 
-#ifdef CONFIG_XEN
-static struct e820entry *__initdata machine_e820;
-static unsigned __initdata machine_e820_count;
-#endif
-
-/*
- * This function checks if the entire range <start,end> is mapped with type.
- *
- * Note: this function only works correct if the e820 table is sorted and
- * not-overlapping, which is the case
- */
-int __init e820_all_mapped(unsigned long start, unsigned long end, unsigned type)
-{
-	int i;
-
-#ifndef CONFIG_XEN
-	for (i = 0; i < e820.nr_map; i++) {
-		struct e820entry *ei = &e820.map[i];
-#else
-	if (!is_initial_xendomain())
-		return 0;
-	WARN_ON(!machine_e820);
-	for (i = 0; i < machine_e820_count; i++) {
-		const struct e820entry *ei = &machine_e820[i];
-#endif
-
-		if (type && ei->type != type)
-			continue;
-		/* is the region (part) in overlap with the current region ?*/
-		if (ei->addr >= end || ei->addr + ei->size <= start)
-			continue;
-
-		/* if the region is at the beginning of <start,end> we move
-		 * start to the end of the region since it's ok until there
-		 */
-		if (ei->addr <= start)
-			start = ei->addr + ei->size;
-		/* if start is now at or beyond end, we're done, full coverage */
-		if (start >= end)
-			return 1; /* we're done */
-	}
-	return 0;
-}
-
 /* 
  * Find a free area in a specific range. 
  */ 
@@ -284,6 +244,11 @@ e820_hole_size(unsigned long start_pfn, 
 	return ((end - start) - ram) >> PAGE_SHIFT;
 }
 
+#ifdef CONFIG_XEN
+static struct e820entry *__initdata machine_e820;
+static unsigned __initdata machine_e820_count;
+#endif
+
 /*
  * Mark e820 reserved areas as busy for the resource manager.
  */
@@ -769,6 +734,11 @@ __init void e820_setup_gap(struct e820en
 			last = start;
 	}
 
+#ifdef CONFIG_XEN
+	if (is_initial_xendomain())
+		free_bootmem(__pa(machine_e820), PAGE_SIZE);
+#endif
+
 	if (!found) {
 		gapstart = (end_pfn << PAGE_SHIFT) + 1024*1024;
 		printk(KERN_ERR "PCI: Warning: Cannot find a gap in the 32bit address range\n"
Index: head-2006-09-01/arch/x86_64/kernel/entry-xen.S
===================================================================
--- head-2006-09-01.orig/arch/x86_64/kernel/entry-xen.S	2006-08-28 10:48:54.000000000 +0200
+++ head-2006-09-01/arch/x86_64/kernel/entry-xen.S	2006-09-01 09:52:20.000000000 +0200
@@ -1075,6 +1075,8 @@ ENTRY(kernel_thread)
 ENDPROC(kernel_thread)
 	
 child_rip:
+	pushq $0		# fake return address
+	CFI_STARTPROC
 	/*
 	 * Here we are in the child and the registers are set as they were
 	 * at kernel_thread() invocation in the parent.
@@ -1085,6 +1087,7 @@ child_rip:
 	# exit
 	xorl %edi, %edi
 	call do_exit
+	CFI_ENDPROC
 ENDPROC(child_rip)
 
 /*
Index: head-2006-09-01/arch/x86_64/kernel/head-xen.S
===================================================================
--- head-2006-09-01.orig/arch/x86_64/kernel/head-xen.S	2006-09-01 10:54:18.000000000 +0200
+++ head-2006-09-01/arch/x86_64/kernel/head-xen.S	2006-09-01 10:55:18.000000000 +0200
@@ -40,6 +40,7 @@ ENTRY(_start)
 	/* rsi is pointer to startup info structure.
 	   pass it to C */
 	movq %rsi,%rdi
+	pushq $0		# fake return address
 	jmp x86_64_start_kernel
 
 ENTRY(stext)
Index: head-2006-09-01/arch/x86_64/kernel/init_task.c
===================================================================
--- head-2006-09-01.orig/arch/x86_64/kernel/init_task.c	2006-09-01 10:53:58.000000000 +0200
+++ head-2006-09-01/arch/x86_64/kernel/init_task.c	2006-09-01 09:52:20.000000000 +0200
@@ -47,11 +47,11 @@ EXPORT_SYMBOL(init_task);
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */ 
 DEFINE_PER_CPU(struct tss_struct, init_tss) ____cacheline_internodealigned_in_smp = INIT_TSS;
-#endif
 
 /* Copies of the original ist values from the tss are only accessed during
  * debugging, no special alignment required.
  */
 DEFINE_PER_CPU(struct orig_ist, orig_ist);
+#endif
 
 #define ALIGN_TO_4K __attribute__((section(".data.init_task")))
Index: head-2006-09-01/arch/x86_64/kernel/setup-xen.c
===================================================================
--- head-2006-09-01.orig/arch/x86_64/kernel/setup-xen.c	2006-08-28 10:46:28.000000000 +0200
+++ head-2006-09-01/arch/x86_64/kernel/setup-xen.c	2006-09-01 11:13:58.000000000 +0200
@@ -573,14 +573,11 @@ static void discover_ebda(void)
 
 void __init setup_arch(char **cmdline_p)
 {
-	unsigned long kernel_end;
-
 #ifdef CONFIG_XEN
 	/* Register a call for panic conditions. */
 	notifier_chain_register(&panic_notifier_list, &xen_panic_block);
 
  	ROOT_DEV = MKDEV(RAMDISK_MAJOR,0); 
-	kernel_end = 0;		/* dummy */
  	screen_info = SCREEN_INFO;
 
 	if (is_initial_xendomain()) {
@@ -703,18 +700,19 @@ void __init setup_arch(char **cmdline_p)
 	contig_initmem_init(0, end_pfn);
 #endif
 
+#ifdef CONFIG_XEN
+	/* reserve kernel, physmap, start info and initial page tables */
+	reserve_bootmem_generic(__pa_symbol(&_text),
+	                        (table_end << PAGE_SHIFT) - __pa_symbol(&_text));
+#else
 	/* Reserve direct mapping */
 	reserve_bootmem_generic(table_start << PAGE_SHIFT, 
 				(table_end - table_start) << PAGE_SHIFT);
 
 	/* reserve kernel */
-	kernel_end = round_up(__pa_symbol(&_end),PAGE_SIZE);
-	reserve_bootmem_generic(HIGH_MEMORY, kernel_end - HIGH_MEMORY);
+	reserve_bootmem_generic(__pa_symbol(&_text),
+				__pa_symbol(&_end) - __pa_symbol(&_text));
 
-#ifdef CONFIG_XEN
-	/* reserve physmap, start info and initial page tables */
-	reserve_bootmem(kernel_end, (table_start<<PAGE_SHIFT)-kernel_end);
-#else
 	/*
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
 	 * enabling clean reboots, SMP operation, laptop functions.
Index: head-2006-09-01/arch/x86_64/kernel/setup64-xen.c
===================================================================
--- head-2006-09-01.orig/arch/x86_64/kernel/setup64-xen.c	2006-08-28 10:46:28.000000000 +0200
+++ head-2006-09-01/arch/x86_64/kernel/setup64-xen.c	2006-09-01 09:52:20.000000000 +0200
@@ -246,6 +246,7 @@ void __cpuinit cpu_init (void)
 	int cpu = stack_smp_processor_id();
 #ifndef CONFIG_X86_NO_TSS
 	struct tss_struct *t = &per_cpu(init_tss, cpu);
+	struct orig_ist *orig_ist = &per_cpu(orig_ist, cpu);
 	unsigned long v; 
 	char *estacks = NULL; 
 	unsigned i;
@@ -319,7 +320,7 @@ void __cpuinit cpu_init (void)
 			estacks += EXCEPTION_STKSZ;
 			break;
 		}
-		t->ist[v] = (unsigned long)estacks;
+		orig_ist->ist[v] = t->ist[v] = (unsigned long)estacks;
 	}
 
 	t->io_bitmap_base = offsetof(struct tss_struct, io_bitmap);
Index: head-2006-09-01/arch/x86_64/kernel/traps-xen.c
===================================================================
--- head-2006-09-01.orig/arch/x86_64/kernel/traps-xen.c	2006-08-28 10:49:12.000000000 +0200
+++ head-2006-09-01/arch/x86_64/kernel/traps-xen.c	2006-09-01 11:13:59.000000000 +0200
@@ -107,7 +107,11 @@ static inline void preempt_conditional_c
 }
 
 static int kstack_depth_to_print = 12;
+#ifdef CONFIG_STACK_UNWIND
 static int call_trace = 1;
+#else
+#define call_trace (-1)
+#endif
 
 #ifdef CONFIG_KALLSYMS
 # include <linux/kallsyms.h>
@@ -175,7 +179,7 @@ static unsigned long *in_exception_stack
 			break;
 #endif
 		default:
-			end = per_cpu(init_tss, cpu).ist[k];
+			end = per_cpu(orig_ist, cpu).ist[k];
 			break;
 		}
 		/*
@@ -276,21 +280,21 @@ void show_trace(struct task_struct *tsk,
 			if (unwind_init_blocked(&info, tsk) == 0)
 				unw_ret = show_trace_unwind(&info, NULL);
 		}
-		if (unw_ret > 0 && !arch_unw_user_mode(&info)) {
-#ifdef CONFIG_STACK_UNWIND
-			unsigned long rip = info.regs.rip;
-			print_symbol("DWARF2 unwinder stuck at %s\n", rip);
-			if (call_trace == 1) {
-				printk("Leftover inexact backtrace:\n");
-				stack = (unsigned long *)info.regs.rsp;
-			} else if (call_trace > 1)
+		if (unw_ret > 0) {
+			if (call_trace == 1 && !arch_unw_user_mode(&info)) {
+				print_symbol("DWARF2 unwinder stuck at %s\n",
+					     UNW_PC(&info));
+				if ((long)UNW_SP(&info) < 0) {
+					printk("Leftover inexact backtrace:\n");
+					stack = (unsigned long *)UNW_SP(&info);
+				} else
+					printk("Full inexact backtrace again:\n");
+			} else if (call_trace >= 1)
 				return;
 			else
 				printk("Full inexact backtrace again:\n");
-#else
+		} else
 			printk("Inexact backtrace:\n");
-#endif
-		}
 	}
 
 	/*
@@ -1154,6 +1158,7 @@ static int __init kstack_setup(char *s)
 }
 __setup("kstack=", kstack_setup);
 
+#ifdef CONFIG_STACK_UNWIND
 static int __init call_trace_setup(char *s)
 {
 	if (strcmp(s, "old") == 0)
@@ -1167,3 +1172,4 @@ static int __init call_trace_setup(char 
 	return 1;
 }
 __setup("call_trace=", call_trace_setup);
+#endif
Index: head-2006-09-01/include/asm-i386/mach-xen/asm/spinlock.h
===================================================================
--- head-2006-09-01.orig/include/asm-i386/mach-xen/asm/spinlock.h	2006-08-28 10:46:28.000000000 +0200
+++ head-2006-09-01/include/asm-i386/mach-xen/asm/spinlock.h	2006-09-01 11:04:28.000000000 +0200
@@ -22,7 +22,7 @@
 
 #define __raw_spin_lock_string \
 	"\n1:\n" \
-	"lock decb %0\n\t" \
+	LOCK_PREFIX " decb %0\n\t" \
 	"jns 3f\n" \
 	"2:\t" \
 	"rep;nop\n\t" \
@@ -38,7 +38,7 @@
  */
 #define __raw_spin_lock_string_flags \
 	"\n1:\n" \
-	"lock decb %0\n\t" \
+	LOCK_PREFIX " decb %0\n\t" \
 	"jns 5f\n" \
 	"2:\t" \
 	"testl $0x200, %1\n\t" \
@@ -57,15 +57,9 @@
 	"jmp 4b\n" \
 	"5:\n\t"
 
-#define __raw_spin_lock_string_up \
-	"\n\tdecb %0"
-
 static inline void __raw_spin_lock(raw_spinlock_t *lock)
 {
-	alternative_smp(
-		__raw_spin_lock_string,
-		__raw_spin_lock_string_up,
-		"+m" (lock->slock) : : "memory");
+	asm(__raw_spin_lock_string : "+m" (lock->slock) : : "memory");
 }
 
 /*
@@ -76,10 +70,7 @@ static inline void __raw_spin_lock(raw_s
 #ifndef CONFIG_PROVE_LOCKING
 static inline void __raw_spin_lock_flags(raw_spinlock_t *lock, unsigned long flags)
 {
-	alternative_smp(
-		__raw_spin_lock_string_flags,
-		__raw_spin_lock_string_up,
-		"+m" (lock->slock) : "r" (flags) : "memory");
+	asm(__raw_spin_lock_string_flags : "+m" (lock->slock) : "r" (flags) : "memory");
 }
 #endif
 
Index: head-2006-09-01/include/asm-x86_64/mach-xen/asm/processor.h
===================================================================
--- head-2006-09-01.orig/include/asm-x86_64/mach-xen/asm/processor.h	2006-08-28 10:46:28.000000000 +0200
+++ head-2006-09-01/include/asm-x86_64/mach-xen/asm/processor.h	2006-09-01 11:13:56.000000000 +0200
@@ -242,6 +242,11 @@ struct tss_struct {
 } __attribute__((packed)) ____cacheline_aligned;
 
 DECLARE_PER_CPU(struct tss_struct,init_tss);
+/* Save the original ist values for checking stack pointers during debugging */
+struct orig_ist {
+	unsigned long ist[7];
+};
+DECLARE_PER_CPU(struct orig_ist, orig_ist);
 #endif
 
 extern struct cpuinfo_x86 boot_cpu_data;
