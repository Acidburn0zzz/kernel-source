From: ksrinivasan@novell.com
Subject: Don't allow ballooning down a domain below a reasonable limit.
References: 172482

Reasonable is hard to judge; we don't want to disallow small domains.
But the system needs a reasonable amount of memory to perform its
duties, set up tables, etc. If on the other hand, the admin is able
to set up and boot up correctly a very small domain, there's no point
in forcing it to be larger.
We end up with some kind of logarithmic function, approximated.

Memory changes are logged, so making domains too small should at least
result in a trace.

Signed-off-by: Kurt Garloff <garloff@suse.de>

Index: head-2006-08-08/drivers/xen/balloon/balloon.c
===================================================================
--- head-2006-08-08.orig/drivers/xen/balloon/balloon.c	2006-08-09 11:46:12.000000000 +0200
+++ head-2006-08-08/drivers/xen/balloon/balloon.c	2006-08-09 11:59:42.000000000 +0200
@@ -372,11 +372,49 @@ static struct xenbus_watch target_watch 
 	.node = "memory/target"
 };
 
+/*
+ * Compute the minimum value this domain can be ballooned down to
+ * (in kilo bytes).
+ */
+static unsigned long  min_target(void)
+{
+	unsigned long	min_kib;
+	unsigned long	curr_kib = current_target() << (PAGE_SHIFT - 10);
+	const unsigned long	max_kib = max_pfn << (PAGE_SHIFT - 10);
+
+	/* Simple continuous piecewiese linear function:
+	 *  max	MB -> min MB	gradient
+	 *       0	   0
+	 *      16	  16
+	 *      32	  24
+	 *     128	  72	(1/2)
+	 *     512 	 168	(1/4)
+	 *    2048	 360	(1/8)
+	 *    8192	 552	(1/32)
+	 *   32768	1320
+	 *   65536	2344
+	 */
+	if (max_kib < 131072UL)
+		min_kib = 8192UL + (max_kib >> 1);
+	else if (max_kib < 524288UL)
+		min_kib = 40960UL + (max_kib >> 2);
+	else if (max_kib < 2097152UL)
+		min_kib = 106496UL + (max_kib >> 3);
+	else
+		min_kib = 303104UL + (max_kib >> 5);
+
+	if (min_kib > curr_kib)
+		min_kib = curr_kib;	/* Don't enforce growth */
+
+	return min_kib;
+}
+
 /* React to a change in the target key */
 static void watch_target(struct xenbus_watch *watch,
 			 const char **vec, unsigned int len)
 {
 	unsigned long long new_target;
+	unsigned long min_value = min_target();
 	int err;
 
 	err = xenbus_scanf(XBT_NIL, "memory", "target", "%llu", &new_target);
@@ -387,7 +425,13 @@ static void watch_target(struct xenbus_w
 
 	/* The given memory/target value is in KiB, so it needs converting to
 	 * pages. PAGE_SHIFT converts bytes to pages, hence PAGE_SHIFT - 10.
+	 * But first make sure that we are not lowering the value below the
+	 * "minimum".
 	 */
+	if (new_target < min_value)
+		new_target = min_value;
+
+	printk(KERN_INFO "Setting mem allocation to %llu kiB\n", new_target);
 	set_new_target(new_target >> (PAGE_SHIFT - 10));
 }
 
