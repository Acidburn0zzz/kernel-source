Subject: xen3 softlockup - no-idle-hz interaction fix
From: http://xenbits.xensource.com/xen-unstable.hg (tip 14422)
Acked-by: jbeulich@novell.com

Index: head-2007-03-19/include/linux/sched.h
===================================================================
--- head-2007-03-19.orig/include/linux/sched.h	2007-03-19 14:16:17.000000000 +0100
+++ head-2007-03-19/include/linux/sched.h	2007-03-19 14:40:43.000000000 +0100
@@ -223,10 +223,15 @@ extern void update_process_times(int use
 extern void scheduler_tick(void);
 
 #ifdef CONFIG_DETECT_SOFTLOCKUP
+extern unsigned long softlockup_get_next_event(void);
 extern void softlockup_tick(void);
 extern void spawn_softlockup_task(void);
 extern void touch_softlockup_watchdog(void);
 #else
+static inline unsigned long softlockup_get_next_event(void)
+{
+	return MAX_JIFFY_OFFSET;
+}
 static inline void softlockup_tick(void)
 {
 }
Index: head-2007-03-19/kernel/softlockup.c
===================================================================
--- head-2007-03-19.orig/kernel/softlockup.c	2007-02-04 19:44:54.000000000 +0100
+++ head-2007-03-19/kernel/softlockup.c	2007-03-19 14:40:43.000000000 +0100
@@ -40,6 +40,19 @@ void touch_softlockup_watchdog(void)
 }
 EXPORT_SYMBOL(touch_softlockup_watchdog);
 
+unsigned long softlockup_get_next_event(void)
+{
+	int this_cpu = smp_processor_id();
+	unsigned long touch_timestamp = per_cpu(touch_timestamp, this_cpu);
+
+	if (per_cpu(print_timestamp, this_cpu) == touch_timestamp ||
+		did_panic ||
+			!per_cpu(watchdog_task, this_cpu))
+		return MAX_JIFFY_OFFSET;
+
+	return max_t(long, 0, touch_timestamp + HZ - jiffies);
+}
+
 /*
  * This callback runs from the timer interrupt, and checks
  * whether the watchdog thread has hung or not:
Index: head-2007-03-19/kernel/timer.c
===================================================================
--- head-2007-03-19.orig/kernel/timer.c	2007-03-19 14:16:18.000000000 +0100
+++ head-2007-03-19/kernel/timer.c	2007-03-19 14:53:38.000000000 +0100
@@ -716,7 +716,7 @@ static unsigned long cmp_next_hrtimer_ev
 unsigned long get_next_timer_interrupt(unsigned long now)
 {
 	tvec_base_t *base = __get_cpu_var(tvec_bases);
-	unsigned long expires;
+	unsigned long expires, sl_next;
 
 	spin_lock(&base->lock);
 	expires = __next_timer_interrupt(base);
@@ -725,7 +725,11 @@ unsigned long get_next_timer_interrupt(u
 	if (time_before_eq(expires, now))
 		return now;
 
-	return cmp_next_hrtimer_event(now, expires);
+	expires = cmp_next_hrtimer_event(now, expires);
+	sl_next = softlockup_get_next_event();
+
+	return expires <= now || expires - now < sl_next
+	       ? expires : now + sl_next;
 }
 
 #ifdef CONFIG_NO_IDLE_HZ
