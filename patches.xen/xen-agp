From: Ian.Pratt@cl.cam.ac.uk
Subject: Introduce phys_to_gart/gart_to_phys and use in AGP code

The agp drivers had confused bus and phys addresses, crashing Xen 
badly. This introduces the concept of gart addresses.

Acked-by: garloff@suse.de

Index: linux-2.6.11/include/asm-alpha/agp.h
===================================================================
--- linux-2.6.11.orig/include/asm-alpha/agp.h
+++ linux-2.6.11/include/asm-alpha/agp.h
@@ -9,5 +9,15 @@
 #define unmap_page_from_agp(page) 
 #define flush_agp_mappings() 
 #define flush_agp_cache() mb()
 
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) (x)
+#define gart_to_phys(x) (x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)		\
+	((char *)__get_free_pages(GFP_KERNEL, (order)))
+#define free_gatt_pages(table, order)	\
+	free_pages((unsigned long)(table), (order))
+
 #endif
Index: linux-2.6.11/drivers/char/agp/uninorth-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/uninorth-agp.c
+++ linux-2.6.11/drivers/char/agp/uninorth-agp.c
@@ -199,9 +199,9 @@ static int uninorth_create_gatt_table(vo
 		SetPageReserved(page);
 
 	agp_bridge->gatt_table_real = (u32 *) table;
 	agp_bridge->gatt_table = (u32 *)table;
-	agp_bridge->gatt_bus_addr = virt_to_phys(table);
+	agp_bridge->gatt_bus_addr = virt_to_gart(table);
 
 	for (i = 0; i < num_entries; i++) {
 		agp_bridge->gatt_table[i] =
 		    (unsigned long) agp_bridge->scratch_page;
Index: linux-2.6.11/drivers/char/agp/efficeon-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/efficeon-agp.c
+++ linux-2.6.11/drivers/char/agp/efficeon-agp.c
@@ -218,9 +218,9 @@ static int efficeon_create_gatt_table(vo
 			asm volatile("clflush %0" : : "m" (*(char *)(page+offset)));
 
 		efficeon_private.l1_table[index] = page;
 
-		value = __pa(page) | pati | present | index;
+		value = virt_to_gart(page) | pati | present | index;
 
 		pci_write_config_dword(agp_bridge->dev,
 			EFFICEON_ATTPAGE, value);
 	}
Index: linux-2.6.11/drivers/char/agp/sworks-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/sworks-agp.c
+++ linux-2.6.11/drivers/char/agp/sworks-agp.c
@@ -50,9 +50,9 @@ static int serverworks_create_page_map(s
 		return -ENOMEM;
 	}
 	SetPageReserved(virt_to_page(page_map->real));
 	global_cache_flush();
-	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real), 
+	page_map->remapped = ioremap_nocache(virt_to_gart(page_map->real), 
 					    PAGE_SIZE);
 	if (page_map->remapped == NULL) {
 		ClearPageReserved(virt_to_page(page_map->real));
 		free_page((unsigned long) page_map->real);
@@ -161,9 +161,9 @@ static int serverworks_create_gatt_table
 	}
 	/* Create a fake scratch directory */
 	for(i = 0; i < 1024; i++) {
 		writel(agp_bridge->scratch_page, serverworks_private.scratch_dir.remapped+i);
-		writel(virt_to_phys(serverworks_private.scratch_dir.real) | 1, page_dir.remapped+i);
+		writel(virt_to_gart(serverworks_private.scratch_dir.real) | 1, page_dir.remapped+i);
 	}
 
 	retval = serverworks_create_gatt_pages(value->num_entries / 1024);
 	if (retval != 0) {
@@ -173,9 +173,9 @@ static int serverworks_create_gatt_table
 	}
 
 	agp_bridge->gatt_table_real = (u32 *)page_dir.real;
 	agp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;
-	agp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);
+	agp_bridge->gatt_bus_addr = virt_to_gart(page_dir.real);
 
 	/* Get the address for the gart region.
 	 * This is a bus address even on the alpha, b/c its
 	 * used to program the agp master not the cpu
@@ -186,9 +186,9 @@ static int serverworks_create_gatt_table
 
 	/* Calculate the agp offset */	
 
 	for(i = 0; i < value->num_entries / 1024; i++)
-		writel(virt_to_phys(serverworks_private.gatt_pages[i]->real)|1, page_dir.remapped+i);
+		writel(virt_to_gart(serverworks_private.gatt_pages[i]->real)|1, page_dir.remapped+i);
 
 	return 0;
 }
 
Index: linux-2.6.11/include/asm-x86_64/agp.h
===================================================================
--- linux-2.6.11.orig/include/asm-x86_64/agp.h
+++ linux-2.6.11/include/asm-x86_64/agp.h
@@ -18,5 +18,15 @@ int unmap_page_from_agp(struct page *pag
    need to be called for each cacheline of the whole page so it may not be 
    worth it. Would need a page for it. */
 #define flush_agp_cache() asm volatile("wbinvd":::"memory")
 
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) (x)
+#define gart_to_phys(x) (x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)		\
+	((char *)__get_free_pages(GFP_KERNEL, (order)))
+#define free_gatt_pages(table, order)	\
+	free_pages((unsigned long)(table), (order))
+
 #endif
Index: linux-2.6.11/drivers/char/agp/ali-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/ali-agp.c
+++ linux-2.6.11/drivers/char/agp/ali-agp.c
@@ -149,9 +149,9 @@ static void *m1541_alloc_page(void)
 	
 	pci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);
 	pci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,
 			(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |
-			  virt_to_phys(addr)) | ALI_CACHE_FLUSH_EN ));
+			  virt_to_gart(addr)) | ALI_CACHE_FLUSH_EN ));
 	return addr;
 }
 
 static void ali_destroy_page(void * addr)
@@ -173,9 +173,9 @@ static void m1541_destroy_page(void * ad
 
 	pci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);
 	pci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,
 			(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |
-			  virt_to_phys(addr)) | ALI_CACHE_FLUSH_EN));
+			  virt_to_gart(addr)) | ALI_CACHE_FLUSH_EN));
 	agp_generic_destroy_page(addr);
 }
 
 
Index: linux-2.6.11/drivers/char/agp/i460-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/i460-agp.c
+++ linux-2.6.11/drivers/char/agp/i460-agp.c
@@ -370,9 +370,9 @@ static int i460_alloc_large_page (struct
 		return -ENOMEM;
 	}
 	memset(lp->alloced_map, 0, map_size);
 
-	lp->paddr = virt_to_phys(lpage);
+	lp->paddr = virt_to_gart(lpage);
 	lp->refcount = 0;
 	atomic_add(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);
 	return 0;
 }
@@ -381,9 +381,9 @@ static void i460_free_large_page (struct
 {
 	kfree(lp->alloced_map);
 	lp->alloced_map = NULL;
 
-	free_pages((unsigned long) phys_to_virt(lp->paddr), I460_IO_PAGE_SHIFT - PAGE_SHIFT);
+	free_pages((unsigned long) gart_to_virt(lp->paddr), I460_IO_PAGE_SHIFT - PAGE_SHIFT);
 	atomic_sub(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);
 }
 
 static int i460_insert_memory_large_io_page (struct agp_memory *mem,
Index: linux-2.6.11/drivers/char/agp/generic.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/generic.c
+++ linux-2.6.11/drivers/char/agp/generic.c
@@ -150,9 +150,9 @@ void agp_free_memory(struct agp_memory *
 		return;
 	}
 	if (curr->page_count != 0) {
 		for (i = 0; i < curr->page_count; i++) {
-			agp_bridge->driver->agp_destroy_page(phys_to_virt(curr->memory[i]));
+			agp_bridge->driver->agp_destroy_page(gart_to_virt(curr->memory[i]));
 		}
 	}
 	agp_free_key(curr->key);
 	vfree(curr->memory);
@@ -203,9 +203,9 @@ struct agp_memory *agp_allocate_memory(s
 		if (addr == NULL) {
 			agp_free_memory(new);
 			return NULL;
 		}
-		new->memory[i] = virt_to_phys(addr);
+		new->memory[i] = virt_to_gart(addr);
 		new->page_count++;
 	}
 
 	flush_agp_mappings();
@@ -696,10 +696,9 @@ int agp_generic_create_gatt_table(void)
 				size = page_order = num_entries = 0;
 				break;
 			}
 
-			table = (char *) __get_free_pages(GFP_KERNEL,
-							  page_order);
+			table = alloc_gatt_pages(page_order);
 
 			if (table == NULL) {
 				i++;
 				switch (agp_bridge->driver->size_type) {
@@ -728,9 +727,9 @@ int agp_generic_create_gatt_table(void)
 	} else {
 		size = ((struct aper_size_info_fixed *) temp)->size;
 		page_order = ((struct aper_size_info_fixed *) temp)->page_order;
 		num_entries = ((struct aper_size_info_fixed *) temp)->num_entries;
-		table = (char *) __get_free_pages(GFP_KERNEL, page_order);
+		table = alloc_gatt_pages(page_order);
 	}
 
 	if (table == NULL)
 		return -ENOMEM;
@@ -743,21 +742,21 @@ int agp_generic_create_gatt_table(void)
 	agp_bridge->gatt_table_real = (u32 *) table;
 	agp_gatt_table = (void *)table;
 
 	agp_bridge->driver->cache_flush();
-	agp_bridge->gatt_table = ioremap_nocache(virt_to_phys(table),
+	agp_bridge->gatt_table = ioremap_nocache(virt_to_gart(table),
 					(PAGE_SIZE * (1 << page_order)));
 	agp_bridge->driver->cache_flush();
 
 	if (agp_bridge->gatt_table == NULL) {
 		for (page = virt_to_page(table); page <= virt_to_page(table_end); page++)
 			ClearPageReserved(page);
 
-		free_pages((unsigned long) table, page_order);
+		free_gatt_pages(table, page_order);
 
 		return -ENOMEM;
 	}
-	agp_bridge->gatt_bus_addr = virt_to_phys(agp_bridge->gatt_table_real);
+	agp_bridge->gatt_bus_addr = virt_to_gart(agp_bridge->gatt_table_real);
 
 	/* AK: bogus, should encode addresses > 4GB */
 	for (i = 0; i < num_entries; i++) {
 		writel(agp_bridge->scratch_page, agp_bridge->gatt_table+i);
@@ -809,9 +808,9 @@ int agp_generic_free_gatt_table(void)
 
 	for (page = virt_to_page(table); page <= virt_to_page(table_end); page++)
 		ClearPageReserved(page);
 
-	free_pages((unsigned long) agp_bridge->gatt_table_real, page_order);
+	free_gatt_pages(agp_bridge->gatt_table_real, page_order);
 
 	agp_gatt_table = NULL;
 	agp_bridge->gatt_table = NULL;
 	agp_bridge->gatt_table_real = NULL;
Index: linux-2.6.11/include/asm-sparc64/agp.h
===================================================================
--- linux-2.6.11.orig/include/asm-sparc64/agp.h
+++ linux-2.6.11/include/asm-sparc64/agp.h
@@ -7,5 +7,15 @@
 #define unmap_page_from_agp(page) 
 #define flush_agp_mappings() 
 #define flush_agp_cache() mb()
 
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) (x)
+#define gart_to_phys(x) (x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)		\
+	((char *)__get_free_pages(GFP_KERNEL, (order)))
+#define free_gatt_pages(table, order)	\
+	free_pages((unsigned long)(table), (order))
+
 #endif
Index: linux-2.6.11/include/asm-ia64/agp.h
===================================================================
--- linux-2.6.11.orig/include/asm-ia64/agp.h
+++ linux-2.6.11/include/asm-ia64/agp.h
@@ -17,5 +17,15 @@
 #define unmap_page_from_agp(page)	/* nothing */
 #define flush_agp_mappings()		/* nothing */
 #define flush_agp_cache()		mb()
 
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) (x)
+#define gart_to_phys(x) (x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)		\
+	((char *)__get_free_pages(GFP_KERNEL, (order)))
+#define free_gatt_pages(table, order)	\
+	free_pages((unsigned long)(table), (order))
+
 #endif /* _ASM_IA64_AGP_H */
Index: linux-2.6.11/drivers/char/agp/intel-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/intel-agp.c
+++ linux-2.6.11/drivers/char/agp/intel-agp.c
@@ -284,9 +284,9 @@ static struct agp_memory *alloc_agpphysm
 	new = agp_create_memory(pg_count);
 	if (new == NULL)
 		return NULL;
 
-	new->memory[0] = virt_to_phys(addr);
+	new->memory[0] = virt_to_gart(addr);
 	if (pg_count == 4) {
 		/* kludge to get 4 physical pages for ARGB cursor */
 		new->memory[1] = new->memory[0] + PAGE_SIZE;
 		new->memory[2] = new->memory[1] + PAGE_SIZE;
@@ -327,12 +327,12 @@ static void intel_i810_free_by_type(stru
 {
 	agp_free_key(curr->key);
 	if(curr->type == AGP_PHYS_MEMORY) {
 		if (curr->page_count == 4)
-			i8xx_destroy_pages(phys_to_virt(curr->memory[0]));
+			i8xx_destroy_pages(gart_to_virt(curr->memory[0]));
 		else
 			agp_bridge->driver->agp_destroy_page(
-				 phys_to_virt(curr->memory[0]));
+				 gart_to_virt(curr->memory[0]));
 		vfree(curr->memory);
 	}
 	kfree(curr);
 }
Index: linux-2.6.11/drivers/char/agp/hp-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/hp-agp.c
+++ linux-2.6.11/drivers/char/agp/hp-agp.c
@@ -109,9 +109,9 @@ static int __init hp_zx1_ioc_shared(void
 
 	hp->gart_size = HP_ZX1_GART_SIZE;
 	hp->gatt_entries = hp->gart_size / hp->io_page_size;
 
-	hp->io_pdir = phys_to_virt(readq(hp->ioc_regs+HP_ZX1_PDIR_BASE));
+	hp->io_pdir = gart_to_virt(readq(hp->ioc_regs+HP_ZX1_PDIR_BASE));
 	hp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];
 
 	if (hp->gatt[0] != HP_ZX1_SBA_IOMMU_COOKIE) {
 		/* Normal case when no AGP device in system */
@@ -247,9 +247,9 @@ hp_zx1_configure (void)
 	agp_bridge->capndx = hp->lba_cap_offset;
 	agp_bridge->mode = readl(hp->lba_regs+hp->lba_cap_offset+PCI_AGP_STATUS);
 
 	if (hp->io_pdir_owner) {
-		writel(virt_to_phys(hp->io_pdir), hp->ioc_regs+HP_ZX1_PDIR_BASE);
+		writel(virt_to_gart(hp->io_pdir), hp->ioc_regs+HP_ZX1_PDIR_BASE);
 		readl(hp->ioc_regs+HP_ZX1_PDIR_BASE);
 		writel(hp->io_tlb_ps, hp->ioc_regs+HP_ZX1_TCNFG);
 		readl(hp->ioc_regs+HP_ZX1_TCNFG);
 		writel(~(HP_ZX1_IOVA_SIZE-1), hp->ioc_regs+HP_ZX1_IMASK);
Index: linux-2.6.11/drivers/char/agp/backend.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/backend.c
+++ linux-2.6.11/drivers/char/agp/backend.c
@@ -141,9 +141,9 @@ static int agp_backend_initialize(struct
 			printk(KERN_ERR PFX "unable to get memory for scratch page.\n");
 			return -ENOMEM;
 		}
 
-		bridge->scratch_page_real = virt_to_phys(addr);
+		bridge->scratch_page_real = virt_to_gart(addr);
 		bridge->scratch_page =
 		    bridge->driver->mask_memory(bridge->scratch_page_real, 0);
 	}
 
@@ -185,9 +185,9 @@ static int agp_backend_initialize(struct
 
 err_out:
 	if (bridge->driver->needs_scratch_page)
 		bridge->driver->agp_destroy_page(
-				phys_to_virt(bridge->scratch_page_real));
+				gart_to_virt(bridge->scratch_page_real));
 	if (got_gatt)
 		bridge->driver->free_gatt_table();
 	if (got_keylist) {
 		vfree(bridge->key_list);
@@ -210,9 +210,9 @@ static void agp_backend_cleanup(struct a
 
 	if (bridge->driver->agp_destroy_page &&
 	    bridge->driver->needs_scratch_page)
 		bridge->driver->agp_destroy_page(
-				phys_to_virt(bridge->scratch_page_real));
+				gart_to_virt(bridge->scratch_page_real));
 }
 
 /* XXX Kludge alert: agpgart isn't ready for multiple bridges yet */
 struct agp_bridge_data *agp_alloc_bridge(void)
Index: linux-2.6.11/drivers/char/agp/intel-mch-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/intel-mch-agp.c
+++ linux-2.6.11/drivers/char/agp/intel-mch-agp.c
@@ -50,9 +50,9 @@ static struct agp_memory *alloc_agpphysm
 	new = agp_create_memory(1);
 	if (new == NULL)
 		return NULL;
 
-	new->memory[0] = virt_to_phys(addr);
+	new->memory[0] = virt_to_gart(addr);
 	new->page_count = 1;
 	new->num_scratch_pages = 1;
 	new->type = AGP_PHYS_MEMORY;
 	new->physical = new->memory[0];
@@ -62,9 +62,9 @@ static struct agp_memory *alloc_agpphysm
 static void intel_i810_free_by_type(struct agp_memory *curr)
 {
 	agp_free_key(curr->key);
 	if(curr->type == AGP_PHYS_MEMORY) {
-		agp_bridge->driver->agp_destroy_page(phys_to_virt(curr->memory[0]));
+		agp_bridge->driver->agp_destroy_page(gart_to_virt(curr->memory[0]));
 		vfree(curr->memory);
 	}
 	kfree(curr);
 }
Index: linux-2.6.11/drivers/char/agp/agp.h
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/agp.h
+++ linux-2.6.11/drivers/char/agp/agp.h
@@ -271,8 +271,10 @@ void agp3_generic_cleanup(void);
 /* aperture sizes have been standardised since v3 */
 #define AGP_GENERIC_SIZES_ENTRIES 11
 extern struct aper_size_info_16 agp3_generic_sizes[];
 
+#define virt_to_gart(x) (phys_to_gart(virt_to_phys(x)))
+#define gart_to_virt(x) (phys_to_virt(gart_to_phys(x)))
 
 extern int agp_off;
 extern int agp_try_unsupported_boot;
 
Index: linux-2.6.11/include/asm-i386/agp.h
===================================================================
--- linux-2.6.11.orig/include/asm-i386/agp.h
+++ linux-2.6.11/include/asm-i386/agp.h
@@ -20,5 +20,15 @@ int unmap_page_from_agp(struct page *pag
    need to be called for each cacheline of the whole page so it may not be 
    worth it. Would need a page for it. */
 #define flush_agp_cache() asm volatile("wbinvd":::"memory")
 
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) (x)
+#define gart_to_phys(x) (x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)		\
+	((char *)__get_free_pages(GFP_KERNEL, (order)))
+#define free_gatt_pages(table, order)	\
+	free_pages((unsigned long)(table), (order))
+
 #endif
Index: linux-2.6.11/include/asm-ppc/agp.h
===================================================================
--- linux-2.6.11.orig/include/asm-ppc/agp.h
+++ linux-2.6.11/include/asm-ppc/agp.h
@@ -9,5 +9,15 @@
 #define unmap_page_from_agp(page)
 #define flush_agp_mappings()
 #define flush_agp_cache() mb()
 
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) (x)
+#define gart_to_phys(x) (x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)		\
+	((char *)__get_free_pages(GFP_KERNEL, (order)))
+#define free_gatt_pages(table, order)	\
+	free_pages((unsigned long)(table), (order))
+
 #endif
Index: linux-2.6.11/drivers/char/agp/amd64-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/amd64-agp.c
+++ linux-2.6.11/drivers/char/agp/amd64-agp.c
@@ -217,9 +217,9 @@ static struct aper_size_info_32 amd_8151
 };
 
 static int amd_8151_configure(void)
 {
-	unsigned long gatt_bus = virt_to_phys(agp_bridge->gatt_table_real);
+	unsigned long gatt_bus = virt_to_gart(agp_bridge->gatt_table_real);
 
 	/* Configure AGP regs in each x86-64 host bridge. */
 	for_each_nb() {
 		agp_bridge->gart_bus_addr =
@@ -589,9 +589,9 @@ static int __devinit agp_amd64_probe(str
 static void __devexit agp_amd64_remove(struct pci_dev *pdev)
 {
 	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
 
-	release_mem_region(virt_to_phys(bridge->gatt_table_real),
+	release_mem_region(virt_to_gart(bridge->gatt_table_real),
 			   amd64_aperture_sizes[bridge->aperture_size_idx].size);
 	agp_remove_bridge(bridge);
 	agp_put_bridge(bridge);
 }
Index: linux-2.6.11/drivers/char/agp/ati-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/ati-agp.c
+++ linux-2.6.11/drivers/char/agp/ati-agp.c
@@ -60,9 +60,9 @@ static int ati_create_page_map(ati_page_
 		return -ENOMEM;
 
 	SetPageReserved(virt_to_page(page_map->real));
 	err = map_page_into_agp(virt_to_page(page_map->real));
-	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real),
+	page_map->remapped = ioremap_nocache(virt_to_gart(page_map->real),
 					    PAGE_SIZE);
 	if (page_map->remapped == NULL || err) {
 		ClearPageReserved(virt_to_page(page_map->real));
 		free_page((unsigned long) page_map->real);
Index: linux-2.6.11/drivers/char/agp/amd-k7-agp.c
===================================================================
--- linux-2.6.11.orig/drivers/char/agp/amd-k7-agp.c
+++ linux-2.6.11/drivers/char/agp/amd-k7-agp.c
@@ -42,9 +42,9 @@ static int amd_create_page_map(struct am
 		return -ENOMEM;
 
 	SetPageReserved(virt_to_page(page_map->real));
 	global_cache_flush();
-	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real),
+	page_map->remapped = ioremap_nocache(virt_to_gart(page_map->real),
 					    PAGE_SIZE);
 	if (page_map->remapped == NULL) {
 		ClearPageReserved(virt_to_page(page_map->real));
 		free_page((unsigned long) page_map->real);
@@ -153,9 +153,9 @@ static int amd_create_gatt_table(void)
 	}
 
 	agp_bridge->gatt_table_real = (u32 *)page_dir.real;
 	agp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;
-	agp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);
+	agp_bridge->gatt_bus_addr = virt_to_gart(page_dir.real);
 
 	/* Get the address for the gart region.
 	 * This is a bus address even on the alpha, b/c its
 	 * used to program the agp master not the cpu
@@ -166,9 +166,9 @@ static int amd_create_gatt_table(void)
 	agp_bridge->gart_bus_addr = addr;
 
 	/* Calculate the agp offset */
 	for (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {
-		writel(virt_to_phys(amd_irongate_private.gatt_pages[i]->real) | 1,
+		writel(virt_to_gart(amd_irongate_private.gatt_pages[i]->real) | 1,
 			page_dir.remapped+GET_PAGE_DIR_OFF(addr));
 		readl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));	/* PCI Posting. */
 	}
 
Index: linux-2.6.11/include/asm-xen/asm-i386/agp.h
===================================================================
--- /dev/null
+++ linux-2.6.11/include/asm-xen/asm-i386/agp.h
@@ -0,0 +1,37 @@
+#ifndef AGP_H
+#define AGP_H 1
+
+#include <asm/pgtable.h>
+#include <asm/cacheflush.h>
+#include <asm/system.h>
+
+/* 
+ * Functions to keep the agpgart mappings coherent with the MMU.
+ * The GART gives the CPU a physical alias of pages in memory. The alias region is
+ * mapped uncacheable. Make sure there are no conflicting mappings
+ * with different cachability attributes for the same page. This avoids
+ * data corruption on some CPUs.
+ */
+
+int map_page_into_agp(struct page *page);
+int unmap_page_from_agp(struct page *page);
+#define flush_agp_mappings() global_flush_tlb()
+
+/* Could use CLFLUSH here if the cpu supports it. But then it would
+   need to be called for each cacheline of the whole page so it may not be 
+   worth it. Would need a page for it. */
+#define flush_agp_cache() wbinvd()
+
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) phys_to_machine(x)
+#define gart_to_phys(x) machine_to_phys(x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)	({                                          \
+	char *_t; dma_addr_t _d;                                            \
+	_t = dma_alloc_coherent(NULL,PAGE_SIZE<<(order),&_d,GFP_KERNEL);    \
+	_t; })
+#define free_gatt_pages(table, order)	\
+	dma_free_coherent(NULL,PAGE_SIZE<<(order),(table),virt_to_bus(table))
+
+#endif
