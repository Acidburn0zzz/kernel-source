From: riel@redhat.com
Subject: 4lvl pgtable support for xen

This patch adds the 'pud' level to Xen page table handling, making
it compile with the 4 level page table code that's in the latest 
 2.6 kernel tree.  This will be needed once Xen moves to 2.6.11.

The only uglies are overriding pmd_val and __pmd, but the code is
now using the asm-generic headers.

This corresponds to the upstream changesets:
 	nickpiggin@yahoo.com.au[torvalds]|ChangeSet|20050101220015|18900
 	ak@suse.de[torvalds]|ChangeSet|20050101220139|54188

Rediffed and 
Acked-by: garloff@suse.de
Signed-off-by: Rik van Riel <riel@redhat.com>

Index: linux-2.6.10/arch/xen/i386/kernel/pci-dma.c
===================================================================
--- linux-2.6.10.orig/arch/xen/i386/kernel/pci-dma.c	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/arch/xen/i386/kernel/pci-dma.c	2005-02-22 12:55:49.000000000 +0100
@@ -36,6 +36,7 @@
 	 * hypercalls reduced.
 	 */
 	pgd_t         *pgd; 
+	pud_t         *pud; 
 	pmd_t         *pmd;
 	pte_t         *pte;
 	unsigned long  pfn, i, flags;
@@ -47,7 +48,8 @@
 	/* 1. Zap current PTEs, giving away the underlying pages. */
 	for (i = 0; i < (1<<order); i++) {
 		pgd = pgd_offset_k(   (vstart + (i*PAGE_SIZE)));
-		pmd = pmd_offset(pgd, (vstart + (i*PAGE_SIZE)));
+		pud = pud_offset(pgd, (vstart + (i*PAGE_SIZE)));
+		pmd = pmd_offset(pud, (vstart + (i*PAGE_SIZE)));
 		pte = pte_offset_kernel(pmd, (vstart + (i*PAGE_SIZE)));
 		pfn = pte->pte_low >> PAGE_SHIFT;
 		queue_l1_entry_update(pte, 0);
@@ -63,7 +65,8 @@
 	/* 3. Map the new extent in place of old pages. */
 	for (i = 0; i < (1<<order); i++) {
 		pgd = pgd_offset_k(   (vstart + (i*PAGE_SIZE)));
-		pmd = pmd_offset(pgd, (vstart + (i*PAGE_SIZE)));
+		pud = pud_offset(pgd, (vstart + (i*PAGE_SIZE)));
+		pmd = pmd_offset(pud, (vstart + (i*PAGE_SIZE)));
 		pte = pte_offset_kernel(pmd, (vstart + (i*PAGE_SIZE)));
 		queue_l1_entry_update(
 			pte, ((pfn+i)<<PAGE_SHIFT)|__PAGE_KERNEL);
Index: linux-2.6.10/arch/xen/i386/mm/fault.c
===================================================================
--- linux-2.6.10.orig/arch/xen/i386/mm/fault.c	2005-02-22 12:48:09.000000000 +0100
+++ linux-2.6.10/arch/xen/i386/mm/fault.c	2005-02-22 12:55:49.000000000 +0100
@@ -527,6 +527,7 @@
 		 */
 		int index = pgd_index(address);
 		pgd_t *pgd, *pgd_k;
+		pud_t *pud, *pud_k;
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 
@@ -538,11 +539,17 @@
 
 		/*
 		 * set_pgd(pgd, *pgd_k); here would be useless on PAE
-		 * and redundant with the set_pmd() on non-PAE.
+		 * and redundant with the set_pmd() on non-PAE. As would
+		 * set_pud.
 		 */
 
-		pmd = pmd_offset(pgd, address);
-		pmd_k = pmd_offset(pgd_k, address);
+		pud = pud_offset(pgd, address);
+		pud_k = pud_offset(pgd_k, address);
+		if (!pud_present(*pud_k))
+			goto no_context;
+
+		pmd = pmd_offset(pud, address);
+		pmd_k = pmd_offset(pud_k, address);
 		if (!pmd_present(*pmd_k))
 			goto no_context;
 		set_pmd(pmd, *pmd_k);
Index: linux-2.6.10/arch/xen/i386/mm/hypervisor.c
===================================================================
--- linux-2.6.10.orig/arch/xen/i386/mm/hypervisor.c	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/arch/xen/i386/mm/hypervisor.c	2005-02-22 12:55:49.000000000 +0100
@@ -348,6 +348,7 @@
 unsigned long allocate_empty_lowmem_region(unsigned long pages)
 {
     pgd_t         *pgd; 
+    pud_t         *pud; 
     pmd_t         *pmd;
     pte_t         *pte;
     unsigned long *pfn_array;
@@ -368,7 +369,8 @@
     for ( i = 0; i < (1<<order); i++ )
     {
         pgd = pgd_offset_k(   (vstart + (i*PAGE_SIZE)));
-        pmd = pmd_offset(pgd, (vstart + (i*PAGE_SIZE)));
+        pud = pud_offset(pgd, (vstart + (i*PAGE_SIZE)));
+        pmd = pmd_offset(pud, (vstart + (i*PAGE_SIZE)));
         pte = pte_offset_kernel(pmd, (vstart + (i*PAGE_SIZE))); 
         pfn_array[i] = pte->pte_low >> PAGE_SHIFT;
         queue_l1_entry_update(pte, 0);
Index: linux-2.6.10/arch/xen/i386/mm/init.c
===================================================================
--- linux-2.6.10.orig/arch/xen/i386/mm/init.c	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/arch/xen/i386/mm/init.c	2005-02-22 12:55:49.000000000 +0100
@@ -55,15 +55,18 @@
  */
 static pmd_t * __init one_md_table_init(pgd_t *pgd)
 {
+	pud_t *pud;
 	pmd_t *pmd_table;
 		
 #ifdef CONFIG_X86_PAE
 	pmd_table = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
 	set_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));
-	if (pmd_table != pmd_offset(pgd, 0)) 
+	pud = pud_offset(pgd, 0);
+	if (pmd_table != pud_offset(pud, 0))
 		BUG();
 #else
-	pmd_table = pmd_offset(pgd, 0);
+	pud = pud_offset(pgd, 0);
+	pmd_table = pmd_offset(pud, 0);
 #endif
 
 	return pmd_table;
@@ -102,6 +105,7 @@
 static void __init page_table_range_init (unsigned long start, unsigned long end, pgd_t *pgd_base)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	int pgd_idx, pmd_idx;
 	unsigned long vaddr;
@@ -115,7 +119,8 @@
 		if (pgd_none(*pgd)) 
 			one_md_table_init(pgd);
 
-		pmd = pmd_offset(pgd, vaddr);
+		pud = pud_offset(pgd, vaddr);
+		pmd = pmd_offset(pud, vaddr);
 		for (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end); pmd++, pmd_idx++) {
 			if (pmd_none(*pmd)) 
 				one_page_table_init(pmd);
@@ -249,7 +254,7 @@
 EXPORT_SYMBOL(kmap_pte);
 
 #define kmap_get_fixmap_pte(vaddr)					\
-	pte_offset_kernel(pmd_offset(pgd_offset_k(vaddr), (vaddr)), (vaddr))
+	pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k(vaddr), (vaddr)), (vaddr)), (vaddr))
 
 void __init kmap_init(void)
 {
@@ -265,6 +270,7 @@
 void __init permanent_kmaps_init(pgd_t *pgd_base)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	unsigned long vaddr;
@@ -273,7 +279,8 @@
 	page_table_range_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base);
 
 	pgd = swapper_pg_dir + pgd_index(vaddr);
-	pmd = pmd_offset(pgd, vaddr);
+	pud = pud_offset(pgd, vaddr);
+	pmd = pmd_offset(pud, vaddr);
 	pte = pte_offset_kernel(pmd, vaddr);
 	pkmap_page_table = pte;	
 }
Index: linux-2.6.10/arch/xen/i386/mm/ioremap.c
===================================================================
--- linux-2.6.10.orig/arch/xen/i386/mm/ioremap.c	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/arch/xen/i386/mm/ioremap.c	2005-02-22 12:55:49.000000000 +0100
@@ -360,7 +360,11 @@
 		BUG();
 	spin_lock(&mm->page_table_lock);
 	do {
-		pmd_t *pmd = pmd_alloc(mm, dir, address);
+		pud_t *pud = pud_alloc(mm, dir, address);
+		pmd_t *pmd;
+		if (!pud)
+			return -ENOMEM;
+		pmd = pmd_alloc(mm, pud, address);
 		if (!pmd)
 			return -ENOMEM;
 		direct_remap_area_pmd(mm, pmd, address, end - address, &v);
Index: linux-2.6.10/arch/xen/i386/mm/pageattr.c
===================================================================
--- linux-2.6.10.orig/arch/xen/i386/mm/pageattr.c	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/arch/xen/i386/mm/pageattr.c	2005-02-22 12:55:49.000000000 +0100
@@ -20,10 +20,14 @@
 pte_t *lookup_address(unsigned long address) 
 { 
 	pgd_t *pgd = pgd_offset_k(address); 
+	pud_t *pud;
 	pmd_t *pmd;
 	if (pgd_none(*pgd))
 		return NULL;
-	pmd = pmd_offset(pgd, address); 	       
+	pud = pud_offset(pgd, address); 	       
+	if (pud_none(*pud))
+		return NULL;
+	pmd = pmd_offset(pud, address); 	       
 	if (pmd_none(*pmd))
 		return NULL;
 	if (pmd_large(*pmd))
@@ -77,9 +81,11 @@
 	spin_lock_irqsave(&pgd_lock, flags);
 	for (page = pgd_list; page; page = (struct page *)page->index) {
 		pgd_t *pgd;
+		pud_t *pud;
 		pmd_t *pmd;
 		pgd = (pgd_t *)page_address(page) + pgd_index(address);
-		pmd = pmd_offset(pgd, address);
+		pud = pud_offset(pgd, address);
+		pmd = pmd_offset(pud, address);
 		set_pte_atomic((pte_t *)pmd, pte);
 	}
 	spin_unlock_irqrestore(&pgd_lock, flags);
@@ -92,7 +98,7 @@
 static inline void revert_page(struct page *kpte_page, unsigned long address)
 {
 	pte_t *linear = (pte_t *) 
-		pmd_offset(pgd_offset(&init_mm, address), address);
+		pmd_offset(pud_offset(pgd_offset(&init_mm, address), address), address);
 	set_pmd_pte(linear,  address,
 		    pfn_pte((__pa(address) & LARGE_PAGE_MASK) >> PAGE_SHIFT,
 			    PAGE_KERNEL_LARGE));
Index: linux-2.6.10/arch/xen/i386/mm/pgtable.c
===================================================================
--- linux-2.6.10.orig/arch/xen/i386/mm/pgtable.c	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/arch/xen/i386/mm/pgtable.c	2005-02-22 12:55:49.000000000 +0100
@@ -65,6 +65,7 @@
 static void set_pte_pfn(unsigned long vaddr, unsigned long pfn, pgprot_t flags)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 
@@ -73,7 +74,12 @@
 		BUG();
 		return;
 	}
-	pmd = pmd_offset(pgd, vaddr);
+	pud = pud_offset(pgd, vaddr);
+	if (pud_none(*pud)) {
+		BUG();
+		return;
+	}
+	pmd = pmd_offset(pud, vaddr);
 	if (pmd_none(*pmd)) {
 		BUG();
 		return;
@@ -97,6 +103,7 @@
 			   pgprot_t flags)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 
@@ -105,7 +112,12 @@
 		BUG();
 		return;
 	}
-	pmd = pmd_offset(pgd, vaddr);
+	pud = pud_offset(pgd, vaddr);
+	if (pud_none(*pud)) {
+		BUG();
+		return;
+	}
+	pmd = pmd_offset(pud, vaddr);
 	if (pmd_none(*pmd)) {
 		BUG();
 		return;
@@ -130,6 +142,7 @@
 void set_pmd_pfn(unsigned long vaddr, unsigned long pfn, pgprot_t flags)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 
 	if (vaddr & (PMD_SIZE-1)) {		/* vaddr is misaligned */
@@ -145,7 +158,8 @@
 		printk ("set_pmd_pfn: pgd_none\n");
 		return; /* BUG(); */
 	}
-	pmd = pmd_offset(pgd, vaddr);
+	pud = pud_offset(pgd, vaddr);
+	pmd = pmd_offset(pud, vaddr);
 	set_pmd(pmd, pfn_pmd(pfn, flags));
 	/*
 	 * It's enough to flush this one mapping.
@@ -364,7 +378,8 @@
 void make_lowmem_page_readonly(void *va)
 {
 	pgd_t *pgd = pgd_offset_k((unsigned long)va);
-	pmd_t *pmd = pmd_offset(pgd, (unsigned long)va);
+	pud_t *pud = pud_offset(pgd, (unsigned long)va);
+	pmd_t *pmd = pmd_offset(pud, (unsigned long)va);
 	pte_t *pte = pte_offset_kernel(pmd, (unsigned long)va);
 	queue_l1_entry_update(pte, (*(unsigned long *)pte)&~_PAGE_RW);
 }
@@ -372,7 +387,8 @@
 void make_lowmem_page_writable(void *va)
 {
 	pgd_t *pgd = pgd_offset_k((unsigned long)va);
-	pmd_t *pmd = pmd_offset(pgd, (unsigned long)va);
+	pud_t *pud = pud_offset(pgd, (unsigned long)va);
+	pmd_t *pmd = pmd_offset(pud, (unsigned long)va);
 	pte_t *pte = pte_offset_kernel(pmd, (unsigned long)va);
 	queue_l1_entry_update(pte, (*(unsigned long *)pte)|_PAGE_RW);
 }
@@ -380,7 +396,8 @@
 void make_page_readonly(void *va)
 {
 	pgd_t *pgd = pgd_offset_k((unsigned long)va);
-	pmd_t *pmd = pmd_offset(pgd, (unsigned long)va);
+	pud_t *pud = pud_offset(pgd, (unsigned long)va);
+	pmd_t *pmd = pmd_offset(pud, (unsigned long)va);
 	pte_t *pte = pte_offset_kernel(pmd, (unsigned long)va);
 	queue_l1_entry_update(pte, (*(unsigned long *)pte)&~_PAGE_RW);
 	if ( (unsigned long)va >= (unsigned long)high_memory )
@@ -397,7 +414,8 @@
 void make_page_writable(void *va)
 {
 	pgd_t *pgd = pgd_offset_k((unsigned long)va);
-	pmd_t *pmd = pmd_offset(pgd, (unsigned long)va);
+	pud_t *pud = pud_offset(pgd, (unsigned long)va);
+	pmd_t *pmd = pmd_offset(pud, (unsigned long)va);
 	pte_t *pte = pte_offset_kernel(pmd, (unsigned long)va);
 	queue_l1_entry_update(pte, (*(unsigned long *)pte)|_PAGE_RW);
 	if ( (unsigned long)va >= (unsigned long)high_memory )
Index: linux-2.6.10/drivers/xen/balloon/balloon.c
===================================================================
--- linux-2.6.10.orig/drivers/xen/balloon/balloon.c	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/drivers/xen/balloon/balloon.c	2005-02-22 12:55:49.000000000 +0100
@@ -137,12 +137,16 @@
 static inline pte_t *get_ptep(unsigned long addr)
 {
     pgd_t *pgd;
+    pud_t *pud;
     pmd_t *pmd;
 
     pgd = pgd_offset_k(addr);
     if ( pgd_none(*pgd) || pgd_bad(*pgd) ) BUG();
 
-    pmd = pmd_offset(pgd, addr);
+    pud = pud_offset(pgd, addr);
+    if ( pud_none(*pud) || pud_bad(*pud) ) BUG();
+
+    pmd = pmd_offset(pud, addr);
     if ( pmd_none(*pmd) || pmd_bad(*pmd) ) BUG();
 
     return pte_offset_kernel(pmd, addr);
Index: linux-2.6.10/include/asm-xen/asm-i386/page.h
===================================================================
--- linux-2.6.10.orig/include/asm-xen/asm-i386/page.h	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/include/asm-xen/asm-i386/page.h	2005-02-22 12:55:49.000000000 +0100
@@ -85,7 +85,6 @@
 #define HPAGE_SHIFT	21
 #else
 typedef struct { unsigned long pte_low; } pte_t;
-typedef struct { unsigned long pmd; } pmd_t;
 typedef struct { unsigned long pgd; } pgd_t;
 typedef struct { unsigned long pgprot; } pgprot_t;
 #define boot_pte_t pte_t /* or would you rather have a typedef */
@@ -93,6 +92,7 @@
 			 (x).pte_low)
 #define pte_val_ma(x)	((x).pte_low)
 #define HPAGE_SHIFT	22
+#include <asm-generic/pgtable-nopmd.h>
 #endif
 #define PTE_MASK	PAGE_MASK
 
@@ -103,15 +103,19 @@
 #define HAVE_ARCH_HUGETLB_UNMAPPED_AREA
 #endif
 
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+#define __pgd(x)	((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
 
+/* Yes, this is ugly... */
+#undef pmd_val
 static inline unsigned long pmd_val(pmd_t x)
 {
-	unsigned long ret = x.pmd;
+	unsigned long ret = pud_val(x.pud);
 	if (ret) ret = machine_to_phys(ret);
 	return ret;
 }
-#define pgd_val(x)	({ BUG(); (unsigned long)0; })
-#define pgprot_val(x)	((x).pgprot)
 
 static inline pte_t __pte(unsigned long x)
 {
@@ -119,13 +123,12 @@
 	return ((pte_t) { (x) });
 }
 #define __pte_ma(x)	((pte_t) { (x) } )
+#undef __pmd
 static inline pmd_t __pmd(unsigned long x)
 {
 	if ((x & 1)) x = phys_to_machine(x);
-	return ((pmd_t) { (x) });
+	return ((pmd_t) { __pud(x) });
 }
-#define __pgd(x)	({ BUG(); (pgprot_t) { 0 }; })
-#define __pgprot(x)	((pgprot_t) { (x) } )
 
 #endif /* !__ASSEMBLY__ */
 
Index: linux-2.6.10/include/asm-xen/asm-i386/pgalloc.h
===================================================================
--- linux-2.6.10.orig/include/asm-xen/asm-i386/pgalloc.h	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/include/asm-xen/asm-i386/pgalloc.h	2005-02-22 12:55:49.000000000 +0100
@@ -39,16 +39,15 @@
 
 #define __pte_free_tlb(tlb,pte) tlb_remove_page((tlb),(pte))
 
+#ifdef CONFIG_PAE
 /*
- * allocating and freeing a pmd is trivial: the 1-entry pmd is
- * inside the pgd, so has no extra memory associated with it.
- * (In the PAE case we free the pmds as part of the pgd.)
+ * In the PAE case we free the pmds as part of the pgd.
  */
-
 #define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
 #define pmd_free(x)			do { } while (0)
 #define __pmd_free_tlb(tlb,x)		do { } while (0)
-#define pgd_populate(mm, pmd, pte)	BUG()
+#define pud_populate(mm, pmd, pte)	BUG()
+#endif
 
 #define check_pgt_cache()	do { } while (0)
 
Index: linux-2.6.10/include/asm-xen/asm-i386/pgtable-2level-defs.h
===================================================================
--- linux-2.6.10.orig/include/asm-xen/asm-i386/pgtable-2level-defs.h	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/include/asm-xen/asm-i386/pgtable-2level-defs.h	2005-02-22 12:55:49.000000000 +0100
@@ -9,13 +9,6 @@
 #define PTRS_PER_PGD	1024
 #define PTRS_PER_PGD_NO_HV	(HYPERVISOR_VIRT_START >> PGDIR_SHIFT)
 
-/*
- * the i386 is two-level, so we don't really have any
- * PMD directory physically.
- */
-#define PMD_SHIFT	22
-#define PTRS_PER_PMD	1
-
 #define PTRS_PER_PTE	1024
 
 #endif /* _I386_PGTABLE_2LEVEL_DEFS_H */
Index: linux-2.6.10/include/asm-xen/asm-i386/pgtable-2level.h
===================================================================
--- linux-2.6.10.orig/include/asm-xen/asm-i386/pgtable-2level.h	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/include/asm-xen/asm-i386/pgtable-2level.h	2005-02-22 12:55:49.000000000 +0100
@@ -1,24 +1,14 @@
 #ifndef _I386_PGTABLE_2LEVEL_H
 #define _I386_PGTABLE_2LEVEL_H
 
+#include <asm-generic/pgtable-nopmd.h>
+
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, (e).pte_low)
-#define pmd_ERROR(e) \
-	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
 
 /*
- * The "pgd_xxx()" functions here are trivial for a folded two-level
- * setup: the pgd is never bad, and a pmd always exists (as it's folded
- * into the pgd entry)
- */
-static inline int pgd_none(pgd_t pgd)		{ return 0; }
-static inline int pgd_bad(pgd_t pgd)		{ return 0; }
-static inline int pgd_present(pgd_t pgd)	{ return 1; }
-#define pgd_clear(xp)				do { } while (0)
-
-/*
  * Certain architectures need to do special things when PTEs
  * within a page table are directly modified.  Thus, the following
  * hook is made available.
@@ -31,16 +21,7 @@
  * (pmds are folded into pgds so this doesn't get actually called,
  * but the define is needed for a generic inline function.)
  */
-#define set_pmd(pmdptr, pmdval) xen_l2_entry_update((pmdptr), (pmdval).pmd)
-#define set_pgd(pgdptr, pgdval) ((void)0)
-
-#define pgd_page(pgd) \
-((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
-
-static inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
-{
-	return (pmd_t *) dir;
-}
+#define set_pmd(pmdptr, pmdval) xen_l2_entry_update((pmdptr), pud_val((pmdval).pud))
 
 /*
  * A note on implementation of this atomic 'get-and-clear' operation.
@@ -98,6 +79,9 @@
 #define pfn_pte_ma(pfn, prot)	__pte_ma(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 
+#define pmd_page(pmd) (pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
+#define pmd_page_kernel(pmd) ((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
+
 /*
  * All present user pages are user-executable:
  */
Index: linux-2.6.10/include/asm-xen/asm-i386/pgtable.h
===================================================================
--- linux-2.6.10.orig/include/asm-xen/asm-i386/pgtable.h	2005-02-22 12:44:19.000000000 +0100
+++ linux-2.6.10/include/asm-xen/asm-i386/pgtable.h	2005-02-22 12:55:49.000000000 +0100
@@ -54,12 +54,12 @@
  */
 #ifdef CONFIG_X86_PAE
 # include <asm/pgtable-3level-defs.h>
+# define PMD_SIZE	(1UL << PMD_SHIFT)
+# define PMD_MASK	(~(PMD_SIZE-1))
 #else
 # include <asm/pgtable-2level-defs.h>
 #endif
 
-#define PMD_SIZE	(1UL << PMD_SHIFT)
-#define PMD_MASK	(~(PMD_SIZE-1))
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
@@ -316,18 +316,11 @@
 
 #define page_pte(page) page_pte_prot(page, __pgprot(0))
 
-#define pmd_page_kernel(pmd) \
-((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
-
 #define pmd_clear(xp)	do {					\
 	set_pmd(xp, __pmd(0));					\
 	xen_flush_page_update_queue();				\
 } while (0)
 
-#ifndef CONFIG_DISCONTIGMEM
-#define pmd_page(pmd) (pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
-#endif /* !CONFIG_DISCONTIGMEM */
-
 #define pmd_large(pmd) \
 	((pmd_val(pmd) & (_PAGE_PSE|_PAGE_PRESENT)) == (_PAGE_PSE|_PAGE_PRESENT))
 
@@ -338,6 +331,7 @@
  * control the given virtual address
  */
 #define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pgd_index_k(addr) pgd_index(addr)
 
 /*
  * pgd_offset() returns a (pgd_t *)
@@ -463,7 +457,8 @@
 #define arbitrary_virt_to_machine(__va)					\
 ({									\
 	pgd_t *__pgd = pgd_offset_k((unsigned long)(__va));		\
-	pmd_t *__pmd = pmd_offset(__pgd, (unsigned long)(__va));	\
+	pud_t *__pud = pud_offset(__pgd, (unsigned long)(__va));	\
+	pmd_t *__pmd = pmd_offset(__pud, (unsigned long)(__va));	\
 	pte_t *__pte = pte_offset_kernel(__pmd, (unsigned long)(__va));	\
 	unsigned long __pa = (*(unsigned long *)__pte) & PAGE_MASK;	\
 	__pa | ((unsigned long)(__va) & (PAGE_SIZE-1));			\
