From: jbeulich@novell.com
Subject: balloon: don't fail reservation changes with -ENOMEM
References: 172482

Add fallback code so that e.g. a domain ballooned too far down can still
(slowly) recover.

Index: head-2006-06-13/drivers/xen/balloon/balloon.c
===================================================================
--- head-2006-06-13.orig/drivers/xen/balloon/balloon.c	2006-06-14 10:14:07.000000000 +0200
+++ head-2006-06-13/drivers/xen/balloon/balloon.c	2006-06-14 10:14:15.000000000 +0200
@@ -170,7 +170,7 @@ static unsigned long current_target(void
 
 static int increase_reservation(unsigned long nr_pages)
 {
-	unsigned long *frame_list, pfn, i, flags;
+	unsigned long *frame_list, frame, pfn, i, flags;
 	struct page   *page;
 	long           rc;
 	struct xen_memory_reservation reservation = {
@@ -183,8 +183,11 @@ static int increase_reservation(unsigned
 		nr_pages = PAGE_SIZE / sizeof(unsigned long);
 
 	frame_list = (unsigned long *)__get_free_page(GFP_KERNEL);
-	if (frame_list == NULL)
-		return -ENOMEM;
+	if (frame_list == NULL) {
+		frame_list = &frame;
+		if (nr_pages > 1)
+			nr_pages = 1;
+	}
 
 	balloon_lock(flags);
 
@@ -200,14 +203,17 @@ static int increase_reservation(unsigned
 	rc = HYPERVISOR_memory_op(
 		XENMEM_populate_physmap, &reservation);
 	if (rc < nr_pages) {
-		int ret;
-		/* We hit the Xen hard limit: reprobe. */
-		reservation.extent_start = frame_list;
-		reservation.nr_extents   = rc;
-		ret = HYPERVISOR_memory_op(XENMEM_decrease_reservation,
-				&reservation);
-		BUG_ON(ret != rc);
-		hard_limit = current_pages + rc - driver_pages;
+		if (rc > 0) {
+			int ret;
+
+			/* We hit the Xen hard limit: reprobe. */
+			reservation.nr_extents = rc;
+			ret = HYPERVISOR_memory_op(XENMEM_decrease_reservation,
+					&reservation);
+			BUG_ON(ret != rc);
+		}
+		if (rc >= 0)
+			hard_limit = current_pages + rc - driver_pages;
 		goto out;
 	}
 
@@ -244,14 +250,15 @@ static int increase_reservation(unsigned
  out:
 	balloon_unlock(flags);
 
-	free_page((unsigned long)frame_list);
+	if (frame_list != &frame)
+		free_page((unsigned long)frame_list);
 
 	return 0;
 }
 
 static int decrease_reservation(unsigned long nr_pages)
 {
-	unsigned long *frame_list, pfn, i, flags;
+	unsigned long *frame_list, frame, pfn, i, flags;
 	struct page   *page;
 	void          *v;
 	int            need_sleep = 0;
@@ -266,8 +273,11 @@ static int decrease_reservation(unsigned
 		nr_pages = PAGE_SIZE / sizeof(unsigned long);
 
 	frame_list = (unsigned long *)__get_free_page(GFP_KERNEL);
-	if (frame_list == NULL)
-		return -ENOMEM;
+	if (frame_list == NULL) {
+		frame_list = &frame;
+		if (nr_pages > 1)
+			nr_pages = 1;
+	}
 
 	for (i = 0; i < nr_pages; i++) {
 		if ((page = alloc_page(GFP_HIGHUSER)) == NULL) {
@@ -318,7 +328,8 @@ static int decrease_reservation(unsigned
 
 	balloon_unlock(flags);
 
-	free_page((unsigned long)frame_list);
+	if (frame_list != &frame)
+		free_page((unsigned long)frame_list);
 
 	return need_sleep;
 }
