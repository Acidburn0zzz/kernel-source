# HG changeset 8933 patch
# User Ian.Campbell@xensource.com
# Node ID 697fac283c9e565b4c9697c70a5529d06a488df9
# Parent  f1c75df46b46cf2b71d949b63f988d8b781302b0
From: Ian Campbell <Ian.Campbell@XenSource.com>
Subject: Add feature flag allowing guest kernel to run in domain 0.

To support this we give kernel GDT entries DPL=0 and use kernel
segment selectors with RPL=0. Xen will crunch these to ring 1 when
they are passed in. When a segment selector is used directly or placed
in a stack frame the guest OS is reponsible for crunching the RPL.

Signed-off-by: Ian Campbell <Ian.Campbell@XenSource.com>

# HG changeset 8941 patch
# User kaf24@firebug.cl.cam.ac.uk
# Node ID 4f4625f805288891106421ea185a02f95dd9c530
# Parent  ef31d088adeb7b7f203fba70ef91542019064706
From: Keir Fraser <keir@xensource.com>
Rename XENFEAT_ring0_kernel to slightly more generic XENFEAT_supervisor_mode_kernel.
Add comments in public header version.h to explain what all the different
feature flags mean. Add a new flag XENFEAT_pae_pgdir_above_4gb to inform the guest
that its PAE page directories do not need to conform to the usual hardware
restriction.

Signed-off-by: Keir Fraser <keir@xensource.com>

Acked-by: Jan Beulich <jbeulich@novell.com>

Index: head-2006-03-02/arch/i386/kernel/head-xen.S
===================================================================
--- head-2006-03-02.orig/arch/i386/kernel/head-xen.S	2006-03-02 11:24:01.000000000 +0100
+++ head-2006-03-02/arch/i386/kernel/head-xen.S	2006-03-02 11:24:38.000000000 +0100
@@ -134,8 +134,8 @@ ENTRY(cpu_gdt_table)
 	.quad 0x0000000000000000	/* 0x53 reserved */
 	.quad 0x0000000000000000	/* 0x5b reserved */
 
-	.quad 0x00cfba000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
-	.quad 0x00cfb2000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
+	.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
 	.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */
 	.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */
 
@@ -187,6 +187,7 @@ ENTRY(cpu_gdt_table)
 	.ascii  ",FEATURES=writable_page_tables"
 	.ascii	         "|writable_descriptor_tables"
 	.ascii	         "|auto_translated_physmap"
+	.ascii	         "|supervisor_mode_kernel"
 #ifdef CONFIG_X86_PAE
 	.ascii	",PAE=yes"
 #else
Index: head-2006-03-02/arch/i386/mm/pgtable-xen.c
===================================================================
--- head-2006-03-02.orig/arch/i386/mm/pgtable-xen.c	2006-03-02 11:08:47.000000000 +0100
+++ head-2006-03-02/arch/i386/mm/pgtable-xen.c	2006-03-02 11:24:06.000000000 +0100
@@ -290,10 +290,11 @@ void pgd_ctor(void *pgd, kmem_cache_t *c
 	unsigned long flags;
 
 	if (PTRS_PER_PMD > 1) {
-		/* Ensure pgd resides below 4GB. */
-		int rc = xen_create_contiguous_region(
-			(unsigned long)pgd, 0, 32);
-		BUG_ON(rc);
+		if (!xen_feature(XENFEAT_pae_pgdir_above_4gb)) {
+			int rc = xen_create_contiguous_region(
+				(unsigned long)pgd, 0, 32);
+			BUG_ON(rc);
+		}
 		if (HAVE_SHARED_KERNEL_PMD)
 			memcpy((pgd_t *)pgd + USER_PTRS_PER_PGD,
 			       swapper_pg_dir + USER_PTRS_PER_PGD,
Index: head-2006-03-02/arch/i386/kernel/process-xen.c
===================================================================
--- head-2006-03-02.orig/arch/i386/kernel/process-xen.c	2006-03-02 11:08:47.000000000 +0100
+++ head-2006-03-02/arch/i386/kernel/process-xen.c	2006-03-02 11:24:06.000000000 +0100
@@ -272,7 +272,7 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.xes = __USER_DS;
 	regs.orig_eax = -1;
 	regs.eip = (unsigned long) kernel_thread_helper;
-	regs.xcs = __KERNEL_CS;
+	regs.xcs = GET_KERNEL_CS();
 	regs.eflags = X86_EFLAGS_IF | X86_EFLAGS_SF | X86_EFLAGS_PF | 0x2;
 
 	/* Ok, create the new process.. */
Index: head-2006-03-02/arch/i386/mm/fault-xen.c
===================================================================
--- head-2006-03-02.orig/arch/i386/mm/fault-xen.c	2006-03-02 11:22:30.000000000 +0100
+++ head-2006-03-02/arch/i386/mm/fault-xen.c	2006-03-02 11:24:06.000000000 +0100
@@ -85,7 +85,7 @@ static inline unsigned long get_segment_
 		return eip + (seg << 4);
 	
 	/* By far the most common cases. */
-	if (likely(seg == __USER_CS || seg == __KERNEL_CS))
+	if (likely(seg == __USER_CS || seg == GET_KERNEL_CS()))
 		return eip;
 
 	/* Check the segment exists, is within the current LDT/GDT size,
@@ -396,7 +396,7 @@ good_area:
 	switch (error_code & 3) {
 		default:	/* 3: write, present */
 #ifdef TEST_VERIFY_AREA
-			if (regs->cs == KERNEL_CS)
+			if (regs->cs == GET_KERNEL_CS())
 				printk("WP fault at %08lx\n", regs->eip);
 #endif
 			/* fall through */
Index: head-2006-03-02/include/asm-i386/mach-xen/asm/segment.h
===================================================================
--- head-2006-03-02.orig/include/asm-i386/mach-xen/asm/segment.h	2006-03-02 11:22:53.000000000 +0100
+++ head-2006-03-02/include/asm-i386/mach-xen/asm/segment.h	2006-03-02 11:24:06.000000000 +0100
@@ -60,10 +60,12 @@
 #define GDT_ENTRY_KERNEL_BASE	12
 
 #define GDT_ENTRY_KERNEL_CS		(GDT_ENTRY_KERNEL_BASE + 0)
-#define __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8 + 1)
+#define __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)
+#define GET_KERNEL_CS() (__KERNEL_CS | (xen_feature(XENFEAT_supervisor_mode_kernel)?0:1) )
 
 #define GDT_ENTRY_KERNEL_DS		(GDT_ENTRY_KERNEL_BASE + 1)
-#define __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8 + 1)
+#define __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)
+#define GET_KERNEL_DS() (__KERNEL_DS | (xen_feature(XENFEAT_supervisor_mode_kernel)?0:1) )
 
 #define GDT_ENTRY_TSS			(GDT_ENTRY_KERNEL_BASE + 4)
 #define GDT_ENTRY_LDT			(GDT_ENTRY_KERNEL_BASE + 5)
