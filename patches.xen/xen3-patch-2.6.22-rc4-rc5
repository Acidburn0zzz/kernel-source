From: www.kernel.org
Subject: Update to 2.6.22-rc5
Patch-mainline: 2.6.22-rc5

Automatically created from "patches.kernel.org/patch-2.6.22-rc4-rc5" by xen-port-patches.py

Acked-by: jbeulich@novell.com

Index: head-2007-06-21/arch/i386/mm/fault-xen.c
===================================================================
--- head-2007-06-21.orig/arch/i386/mm/fault-xen.c	2007-06-21 09:11:18.000000000 +0200
+++ head-2007-06-21/arch/i386/mm/fault-xen.c	2007-06-21 09:11:28.000000000 +0200
@@ -577,6 +577,11 @@ bad_area:
 bad_area_nosemaphore:
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & 4) {
+		/*
+		 * It's possible to have interrupts off here.
+		 */
+		local_irq_enable();
+
 		/* 
 		 * Valid to do another page fault here because this one came 
 		 * from user space.
Index: head-2007-06-21/arch/x86_64/kernel/traps-xen.c
===================================================================
--- head-2007-06-21.orig/arch/x86_64/kernel/traps-xen.c	2007-06-21 09:11:18.000000000 +0200
+++ head-2007-06-21/arch/x86_64/kernel/traps-xen.c	2007-06-21 09:11:28.000000000 +0200
@@ -467,13 +467,14 @@ static unsigned int die_nest_count;
 
 unsigned __kprobes long oops_begin(void)
 {
-	int cpu = smp_processor_id();
+	int cpu;
 	unsigned long flags;
 
 	oops_enter();
 
 	/* racy, but better than risking deadlock. */
 	local_irq_save(flags);
+	cpu = smp_processor_id();
 	if (!spin_trylock(&die_lock)) { 
 		if (cpu == die_owner) 
 			/* nested oops. should stop eventually */;
Index: head-2007-06-21/arch/x86_64/mm/fault-xen.c
===================================================================
--- head-2007-06-21.orig/arch/x86_64/mm/fault-xen.c	2007-06-21 09:11:18.000000000 +0200
+++ head-2007-06-21/arch/x86_64/mm/fault-xen.c	2007-06-21 09:11:28.000000000 +0200
@@ -537,6 +537,12 @@ bad_area:
 bad_area_nosemaphore:
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & PF_USER) {
+
+		/*
+		 * It's possible to have interrupts off here.
+		 */
+		local_irq_enable();
+
 		if (is_prefetch(regs, address, error_code))
 			return;
 
Index: head-2007-06-21/arch/x86_64/mm/init-xen.c
===================================================================
--- head-2007-06-21.orig/arch/x86_64/mm/init-xen.c	2007-06-21 09:11:24.000000000 +0200
+++ head-2007-06-21/arch/x86_64/mm/init-xen.c	2007-06-21 09:11:28.000000000 +0200
@@ -196,6 +196,8 @@ void show_mem(void)
 			if (unlikely(i % MAX_ORDER_NR_PAGES == 0)) {
 				touch_nmi_watchdog();
 			}
+			if (!pfn_valid(pgdat->node_start_pfn + i))
+				continue;
 			page = pfn_to_page(pgdat->node_start_pfn + i);
 			total++;
 			if (PageReserved(page))
Index: head-2007-06-21/include/asm-i386/mach-xen/asm/pgtable.h
===================================================================
--- head-2007-06-21.orig/include/asm-i386/mach-xen/asm/pgtable.h	2007-06-21 09:11:18.000000000 +0200
+++ head-2007-06-21/include/asm-i386/mach-xen/asm/pgtable.h	2007-06-21 09:19:40.000000000 +0200
@@ -289,29 +289,33 @@ static inline pte_t xen_local_ptep_get_a
  */
 #define  __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS
 #define ptep_set_access_flags(vma, address, ptep, entry, dirty)		\
-do {									\
-	if (dirty)							\
+({									\
+	int __changed = !pte_same(*(ptep), entry);			\
+	if (__changed && (dirty))					\
 		ptep_establish(vma, address, ptep, entry);		\
-} while (0)
+	__changed;							\
+})
 
 #define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_DIRTY
 #define ptep_test_and_clear_dirty(vma, addr, ptep) ({			\
-	int ret = 0;							\
-	if (pte_dirty(*ptep))						\
-		ret = test_and_clear_bit(_PAGE_BIT_DIRTY, &ptep->pte_low); \
-	if (ret)							\
-		pte_update_defer(vma->vm_mm, addr, ptep);		\
-	ret;								\
+	int __ret = 0;							\
+	if (pte_dirty(*(ptep)))						\
+		__ret = test_and_clear_bit(_PAGE_BIT_DIRTY,		\
+						&(ptep)->pte_low);	\
+	if (__ret)							\
+		pte_update((vma)->vm_mm, addr, ptep);			\
+	__ret;								\
 })
 
 #define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG
 #define ptep_test_and_clear_young(vma, addr, ptep) ({			\
-	int ret = 0;							\
-	if (pte_young(*ptep))						\
-		ret = test_and_clear_bit(_PAGE_BIT_ACCESSED, &ptep->pte_low); \
-	if (ret)							\
-		pte_update_defer(vma->vm_mm, addr, ptep);		\
-	ret;								\
+	int __ret = 0;							\
+	if (pte_young(*(ptep)))						\
+		__ret = test_and_clear_bit(_PAGE_BIT_ACCESSED,		\
+						&(ptep)->pte_low);	\
+	if (__ret)							\
+		pte_update((vma)->vm_mm, addr, ptep);			\
+	__ret;								\
 })
 
 /*
@@ -339,7 +343,7 @@ do {									\
 	int __dirty = pte_dirty(__pte);					\
 	__pte = pte_mkclean(__pte);					\
 	if (test_bit(PG_pinned, &virt_to_page((vma)->vm_mm->pgd)->flags)) \
-		ptep_set_access_flags(vma, address, ptep, __pte, __dirty); \
+		(void)ptep_set_access_flags(vma, address, ptep, __pte, __dirty); \
 	else if (__dirty)						\
 		(ptep)->pte_low = __pte.pte_low;			\
 	__dirty;							\
@@ -352,7 +356,7 @@ do {									\
 	int __young = pte_young(__pte);					\
 	__pte = pte_mkold(__pte);					\
 	if (test_bit(PG_pinned, &virt_to_page((vma)->vm_mm->pgd)->flags)) \
-		ptep_set_access_flags(vma, address, ptep, __pte, __young); \
+		(void)ptep_set_access_flags(vma, address, ptep, __pte, __young); \
 	else if (__young)						\
 		(ptep)->pte_low = __pte.pte_low;			\
 	__young;							\
Index: head-2007-06-21/include/asm-x86_64/mach-xen/asm/pgtable.h
===================================================================
--- head-2007-06-21.orig/include/asm-x86_64/mach-xen/asm/pgtable.h	2007-06-21 09:11:18.000000000 +0200
+++ head-2007-06-21/include/asm-x86_64/mach-xen/asm/pgtable.h	2007-06-21 09:19:19.000000000 +0200
@@ -486,10 +486,12 @@ static inline pte_t pte_modify(pte_t pte
  * bit at the same time. */
 #define  __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS
 #define ptep_set_access_flags(vma, address, ptep, entry, dirty)		\
-	do {								\
-		if (dirty)						\
-			ptep_establish(vma, address, ptep, entry);	\
-	} while (0)
+({									\
+	int __changed = !pte_same(*(ptep), entry);			\
+	if (__changed && (dirty))					\
+		ptep_establish(vma, address, ptep, entry);		\
+	__changed;							\
+})
 
 #define __HAVE_ARCH_PTEP_CLEAR_DIRTY_FLUSH
 #define ptep_clear_flush_dirty(vma, address, ptep)			\
@@ -498,7 +500,7 @@ static inline pte_t pte_modify(pte_t pte
 	int __dirty = pte_dirty(__pte);					\
 	__pte = pte_mkclean(__pte);					\
 	if ((vma)->vm_mm->context.pinned)				\
-		ptep_set_access_flags(vma, address, ptep, __pte, __dirty); \
+		(void)ptep_set_access_flags(vma, address, ptep, __pte, __dirty); \
 	else if (__dirty)						\
 		set_pte(ptep, __pte);					\
 	__dirty;							\
@@ -511,7 +513,7 @@ static inline pte_t pte_modify(pte_t pte
 	int __young = pte_young(__pte);					\
 	__pte = pte_mkold(__pte);					\
 	if ((vma)->vm_mm->context.pinned)				\
-		ptep_set_access_flags(vma, address, ptep, __pte, __young); \
+		(void)ptep_set_access_flags(vma, address, ptep, __pte, __young); \
 	else if (__young)						\
 		set_pte(ptep, __pte);					\
 	__young;							\
