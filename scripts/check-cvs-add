#! /bin/bash

#
# Check if all files referenced by series.conf are in the CVS.
#

. ${0%/*}/wd-functions.sh

export LANG=C

patches="$(scripts/guards --list < series.conf | sort -u)"

if $using_cvs; then
    not_in_cvs="$(
        (   for dir in $(echo "$patches" | sed -e 's,[^/]*$,,' | sort -u); do
                [ -e ${dir}CVS/Entries ] || continue
                # Print each active file in the CVS twice
                while IFS=/ read type file rev timestamp flags; do
                    [ -n "$type" -o -z "$file" ] && continue
                    # Croak files have not yet been committed to the CVS?
                    #[ "$rev" = 0 ] && continue
                    # Croak files are marked for deletion?
                    [ "${rev:0:1}" = - ] && continue

                    echo ${dir}$file
                    echo ${dir}$file
                done < ${dir}CVS/Entries
            done
            # Print the patches once, so that each patch that is not in the
            # CVS ends up as a unique entry
            echo "$patches"
        ) | sort | uniq -u)"
else
    if [ "$1" = "--committed" ]; then
        # check if patches and kabi files are committed
        added="$(git ls-tree -r --name-only HEAD | grep '^patches\..*/' |
	         sort -u)"
        not_in_cvs="$(join -v1 <(echo "$patches") <(echo "$added"))
                    $(git ls-files -d -o -m --exclude-standard kabi/ | sort -u)"
    else
        # only if the patches are added
        added="$(git ls-files --cached | grep '^patches\..*/' | sort -u)"
        not_in_cvs="$(join -v1 <(echo "$patches") <(echo "$added"))"
    fi

fi
    
if [ -n "$not_in_cvs" ]; then
    for patch in $not_in_cvs; do
	if [ -e "$patch" ]; then
	    echo "Not in $scm: $patch" >&2
	    status=1
	else
	    echo "Missing: $patch" >&2
	    status=1
	fi
    done
    exit $status
fi
