#! /bin/bash

# Read a list of filenames from standard input and compute a
# running md5sum (e.g., cat f1 | md5sum f1, cat f1 f2 | md5sum,
# cat f1 f2 f3 | md5sum).
running_md5sum() {
    perl -w -e '
	use Digest::MD5;
	use FileHandle;

	my $md5 = new Digest::MD5;
	while (<>) {
	    my $fh = new FileHandle("<$_")
		or die "$_: $!\n";
	    $md5->addfile($fh);
	    print $md5->clone->hexdigest, "  $_\n";
	}'
}

usage() {
    echo >&2 \
"Usage: ${0##*/} [--generate] [--clean] [--dir dir] {--cache dir}

Read a list of patches from standard input, and either compute aggregate
patches in the --cache directory (--generate), or replace patches
with their precomputed aggregates in this list before writing the new
list to standard output.

--cache dir
	Output directory in which to store the cache files.
--generate
	Generate cache in the specified cache directory.
--clean
	Don't use the cache when regenerating it.
--dir dir
	Scratch directory to use."
    exit $1
}

options=`getopt -o hd: --long help,generate,clean,cache:,dir: -- "$@"`

if [ $? -ne 0 ]; then
    usage 1
fi

eval set -- "$options"

while :; do
    case "$1" in
    -d|--dir)
	SCRATCH_AREA=$2
	shift
	;;
    --generate)
    	opt_generate=1
	;;
    --clean)
	opt_clean=1
	;;
    --cache)
	cachedir=$2
	shift
	;;
    -h|--help)
    	usage 0
	;;
    --)
    	shift
	break
	;;
    esac
    shift
done

if [ -z "$cachedir" -o -z "$SCRATCH_AREA" -o $# -ne 0 ]; then
    usage 1
fi

source $(dirname $0)/config.sh
ORIG_DIR=$SCRATCH_AREA/linux-$SRCVERSION.orig
if ! [ -d $ORIG_DIR ]; then
    echo "$ORIG_DIR not found" >&2
    exit 1
fi

IFS=$'\n' md5sums=( $(running_md5sum) )
if [ -n "$opt_generate" ]; then
    mkdir -p $cachedir
    tmpdir=$(mktemp -d $SCRATCH_AREA/${0##*/}.XXXXXX)
    tmpcachedir=$(mktemp -d $cachedir/${0##*/}.XXXXXX)
    trap "rm -rf $tmpdir $tmpcachedir" EXIT

    if [ -n "$opt_clean" ]; then
	rm -f $cachedir/*.gz
    fi

    cp -rld $ORIG_DIR $tmpdir/a
    pos=0
    # Use an exponentially declining number of patches in each
    # successive combined patch.
    for ((half = ${#md5sums[@]} >> 1; half >= 16; half >>= 1)); do
	((end += half))
	patches=()
	while ((pos < end)); do
	    eval set -- "${md5sums[pos]}"
	    patches[${#patches[@]}]=$2
	    ((pos++))
	done
	md5sum=$1

	printf '%s (%d%%) .' "$md5sum.gz" $((100*$pos/${#md5sums[@]}))

	if [ -e $cachedir/$md5sum.gz ]; then
	    ln $cachedir/$md5sum.gz $tmpcachedir/
	    zcat $tmpcachedir/$md5sum.gz \
	    | patch -s -p1 -E -d $tmpdir/a -f --no-backup-if-mismatch \
		|| break
	    echo ..
	    continue
	fi

	cp -rld $tmpdir/a $tmpdir/b
	for patch in "${patches[@]}"; do
	    patch -s -p1 -E -d $tmpdir/b -f --no-backup-if-mismatch < $patch \
		|| break 2
	done
	echo -n .
	(cd $tmpdir && diff -Nr -U0 a b) \
	| sed -e '/^diff/d' -e '/^\(---\|+++\) /s/'$'\t''.*//' \
	| gzip -9 > $tmpcachedir/$md5sum.gz
	echo -n .
	rm -rf $tmpdir/a
	mv $tmpdir/b $tmpdir/a
	echo
    done

    rm -f $cachedir/*.gz
    mv $tmpcachedir/*.gz $cachedir/
else
    patches=()
    for ((pos = 0; pos < ${#md5sums[@]}; pos++)); do
	eval set -- "${md5sums[pos]}"
	if [ -e $cachedir/$1.gz ]; then
	    echo $cachedir/$1.gz
	    patches=()
	    continue
	fi
	patches[${#patches[@]}]=$2
    done
    ( IFS=$'\n'; echo "${patches[*]}" )
fi

# vim:shiftwidth=4 softtabstop=4
