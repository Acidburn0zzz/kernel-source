#!/usr/bin/perl
#
# patch-tag is meant to maintain a set of metadata tags in a diff.  Multiple
# files can be specified on the command line and all options can be
# given more than once.
#
# All options can be abbreviated.  --print is the same as -p
#
# All tags are changed so the first letter is uppercase and the rest are
# lowercase.
#
# Example usage:
#
# patch-tag file
#	print the entire header before the diff starts
#
# patch-tag -e filename
#	Runs $EDITOR on filename.  If there are no tags in the file yet
#	a default set of tags is filled in.  See $default_comment for the
#	list.
#
# patch-tag -p Author -p Subject file
#	print the author and subject tags only
#
# --print forces everything into readonly mode.  If you specify --tag 
# along with --print, the file won't be changed although the output on stdout
# will.
#
# patch-tag -t author=Mason -t subject="a patch to fix an oops"
#	Add or modify the author and subject tags.  If more than one
#	author tag is already present in the comment, only the first will
#	be changed.
#
# patch-tag -a author -a Subject=patch
#	Add an empty author tag and Subject: patch tag to the patch,
#	but don't overwrite any existing values if these tags were present
#	already.
#
# patch-tag -a filename
#	Read in a list of tags for -a from filename
#
# patch-tag -A works the same as -a, but always adds the new tag, even
#	if one is already present.
#
# patch-tag -c filename
#	Read a whole new comment block from stdin for filename.
#
# The template files for -a can have comments starting with #.  Only lines
# starting with string: will be used as tags.  The tags may have default
# values.
#
use strict;
use Getopt::Long qw(:config no_ignore_case);
use File::Temp;
use IO::File;

my $VERSION = "0.3";

my $default_comment = "from:subject:patch-mainline:suse-bugzilla:signed-off-by:";

# command line options
my %tags;	  # hash of tags to be replaced
my %print_tags;   # hash of tags for printing to stdout
my %add_tags;	  # hash of tags to be added if not already present
my %always_add_tags; # hash of tags to be added no matter what
my $new_comment;  # boolean, replace comment with data read from stdin
my $edit;         # invoke $EDITOR when done

# globals
my $output_comment; # the finished comment as printed
my @output_tags;   # hash used to do final tag output
my %replaced_tags; # copy of %tags so we can detect which ones are found
my $replace = 0;   # should we overwrite the patch file?
my $outfh;	   # current output file handle (could be a temp file)
my $infh;	   # current input file handle
my @files; 	   # list of all the files to be read
my $input; 	   # the current patch file we're reading
my $ret;

sub print_usage() {
    print STDERR "patch-tag version $VERSION\n";
    print STDERR "usage: patch-tag.pl [-ce ] [-aAtp tag=val] patch ...\n";
    print STDERR "\t--print a given tag\n";
    print STDERR "\t--comment replace the comment block with text from stdin\n";
    print STDERR "\t--edit invoke \$EDITOR on each file after processing\n";
    print STDERR "\t--tag tag[=value] Replace or add a given tag\n";
    print STDERR "\t--add tag[=value] Add a tag if not already present\n";
    print STDERR "\t--Add tag[=value] Unconditionally add a tag\n";
    print STDERR "\t--add filename containing template of tags to add\n";
    print STDERR "\nAll options can be specified more than once, example\n";
    print STDERR "usage and additional docs at the top of this script\n";
    exit(1);
}

# we want the hashes of tags in lower case, normalize whatever
# crud the user sent us
#
sub lc_hash(%) {
    my (%h) = (@_);
    my %lch;
    my $tag;
    my $value;
    foreach my $k (keys(%h)) {
	$tag = lc($k);
	$value = $h{$k};
	# did they use --opt "tag: value"? If so, turn it into a tag value pair
	if (($tag =~ m/(.+[^:]):\s*(.+)/) && $value eq "") {
	    $tag = $1;
	    $value = $2;
	}
	# strip off any : in the tag
	$tag =~ s/://g;
        $lch{$tag} = $value;
    }
    return %lch;
}

# look for any tags that we were asked to print or replace from
# the command line.  Build the array of tags found in the comment
sub check_tags($) {
    my ($line) = @_;
    my $t;
    my $value;
    my $filespec = "";

    if ($line =~ m/(^[^:\s#]*):\s*(.*)/) {
    	$t = lc($1);
	$value = $2;
	# only do replacement on the first tag with a given key
	if (defined($tags{$t}) && defined($replaced_tags{$t})) {
	    $value = $tags{$t};
	    push @output_tags, ucfirst($t) . ": $value";
	} elsif (defined($print_tags{$t})) {
	    push @output_tags, ucfirst($t) . ": $value";
	} elsif (!%print_tags) {
	    push @output_tags, ucfirst($t) . ": $value";
	}
	delete $replaced_tags{$t};
    } elsif (!%print_tags) {
    	$output_comment .= $_;
    }
}

# print the array of tags found in the comment
sub print_output_tags($) {
    my ($input_file) = @_;
    my $filespec = "";

    if (scalar(@files) > 1 && %print_tags) {
        $filespec = "$input_file: ";
    }
    foreach my $s (@output_tags) {
	print $outfh "${filespec}$s\n";
    }
    if (!%print_tags && scalar(@output_tags) && 
        !($output_comment =~ m/^\s*\n/)) {
        print $outfh "\n";
    }
}

# for -a and -A, look for a filename as an arg instead of a tag.  If found
# fill in the hash with the contents of the file
#
sub fill_hash_from_file($) {
    my ($h) = @_;
    # look for tags to add either from the command line or template files
    if (%$h && keys(%$h) <= 1) {
	my ($k, $v) = each %$h;
	my $source;
	if (defined($k) && (!defined($v) || $v eq "")) {
	    if (-f $k) {
		delete($h->{$k});
		$source = $k;
	    }
	}
	if (defined($source)) {
	    print STDERR "Using $source as tag template source\n";
	    # delete($$h{$k});
	    my $template = new IO::File;
	    $template->open("<$source") || die "Unable to open $source for reading";
	    while(<$template>) {
		chomp;
		# eat comments
		s/#.*//;
		# eat ws at the start of the line
		s/^\s//;
    		if (m/(^[^:\s#]*):\s*(.*)/) {
		    $h->{lc($1)} = $2;
		}
	    }
	    $template->close();
	}
    }
}

sub add_output_tag ($$) {
    my ($tag, $h) = @_;
    if (defined($$h{$tag})) {
        push @output_tags, ucfirst($tag) . ": $$h{$tag}";
	delete($$h{$tag});
    }
}

$ret = GetOptions("add:s%" => \%add_tags,
		  "Add:s%" => \%always_add_tags,
		  "edit" => \$edit,
		  "tag:s%" => \%tags,
		  "print:s" => \%print_tags,
		  "comment" => \$new_comment,
		  ) || print_usage();

@files = @ARGV;

if (scalar(@ARGV) < 1) {
    print_usage();
}

if ($new_comment && scalar(@ARGV) > 1) {
    print STDERR "error: --comment can only be used on one file at a time\n";
    print_usage();
}

fill_hash_from_file(\%add_tags);
fill_hash_from_file(\%always_add_tags);

# never overwrite the original when --print is used
#
if ((%add_tags || %always_add_tags || %tags || $new_comment || $edit) && 
    !%print_tags) {
    $replace = 1;
}

%tags = lc_hash(%tags);
%print_tags = lc_hash(%print_tags);
%add_tags = lc_hash(%add_tags);
%always_add_tags = lc_hash(%always_add_tags);

# if we're editing setup the default tags
if ($edit) {
    my @words = split /:/, $default_comment;
    foreach my $w (@words) {
        $add_tags{$w} = "";
    }
}

foreach $input (@files) {
    my $state = "comment";
    my $last = "";
    
    $infh = new IO::File;
    $infh->open("<$input") || die "Unable to open $input for reading";
    %replaced_tags = (%tags, %add_tags);
    @output_tags = ();
    $output_comment = "";

    if ($replace) {
	$outfh = new File::Temp(TEMPLATE => "$input.XXXXXX", UNLINK => 0) || 
		 die "Unable to create temp file";
    } else {
	$outfh = new IO::File;
	$outfh->open(">-") || die "Unable to open stdout";
    }

    # loop through until the start of the diff.
    while(<$infh>) {
	# bk uses this: ===== fs/reiserfs/inode.c 1.49 vs 1.50 ===== 
	if (m/^Index:/ || m/^=====.*vs.*=====$/) {
	    $state = "index";
	    $last = $_;
	} elsif (m/^=================/ && $state eq "index") {
	    $state = "print";
	    $last .= $_;
	    last;
	} elsif (m/^diff/) {
	    $state = "diff";
	    $last = $_;
	} elsif (m/^---/ || m/^\+\+\+/) {
	    $state = "print";
	    $last .= $_;
	    last;
	} elsif ($state ne "comment") {
	    if ($state eq "index" || $state eq "diff") {
		check_tags($last);
	    }
	    $state = "comment";
	    $last = "";
	    check_tags($_);
	} else {
	    check_tags($_);
	}
    }
    # add any new tags left over, but do From and Subject first
    add_output_tag('from', \%replaced_tags);
    add_output_tag('subject', \%replaced_tags);
    foreach my $h (sort(keys(%replaced_tags))) {
        push @output_tags, ucfirst($h) . ": $replaced_tags{$h}";
    }
    # add any of the tags from -A 
    foreach my $h (sort(keys(%always_add_tags))) {
        push @output_tags, ucfirst($h) . ": $always_add_tags{$h}";
    }
    # replace the comment entirely for -c
    if ($new_comment) {
        while(<STDIN>) {
	    print $outfh $_;
	}
    } else {
        print_output_tags($input);
        print $outfh $output_comment;
    }
    # in replace mode, copy our temp file over the original.
    if ($replace) {
	# $last has some leftover lines with the start of the diff
	# make sure to print it
	if ($state eq "print") {
	    print $outfh $last;
	}
	while(<$infh>) {
	    print $outfh $_;
	}
	unlink "$input" || die "Unable to unlink $input";
	rename $outfh->filename, $input || 
	       die "Unable to rename $outfh->filename to $input";
    }
    if ($edit) {
	my $editor = "vi";
	if (defined($ENV{'EDITOR'})) {
	    $editor = $ENV{'EDITOR'};
	}
        $ret = system("$editor $input");
	if ($ret) {
	    $ret = $ret >> 8;
	    print STDERR "warning $editor exited with $ret\n";
	}
    }
    $infh->close();
    $outfh->close();
}
