From: Lee Duncan
Date: Wed, 17 Jul 2019 09:11:08 +0530
Subject: SCSI: cxgbi: KABI: fix handle completion etc
Patch-mainline: never, kabi
References: jsc#SLE-4678 bsc#1136342

This patch fixes the kabi issuse for the patch

> patches.drivers/scsi-cxgb4i-add-wait_for_completion

Which adds a "completion" member to struct cxgbi_device, and
it also removes one argument each from the two methods
in struct cxgbi_sock.

Signed-off-by: Lee Duncan <lduncan@suse.com>
---
 drivers/scsi/cxgbi/cxgb3i/cxgb3i.c |   10 +--
 drivers/scsi/cxgbi/cxgb4i/cxgb4i.c |   10 +--
 drivers/scsi/cxgbi/libcxgbi.c      |  121 +++++++++++++++++++++++++++++--------
 drivers/scsi/cxgbi/libcxgbi.h      |   20 +++++-
 4 files changed, 124 insertions(+), 37 deletions(-)

--- a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
+++ b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
@@ -116,12 +116,12 @@ static struct iscsi_transport cxgb3i_isc
 	.get_session_param = iscsi_session_get_param,
 	/* connection management */
 	.create_conn	= cxgbi_create_conn,
-	.bind_conn	= cxgbi_bind_conn,
+	.bind_conn	= __cxgbi_bind_conn,
 	.destroy_conn	= iscsi_tcp_conn_teardown,
 	.start_conn	= iscsi_conn_start,
 	.stop_conn	= iscsi_conn_stop,
 	.get_conn_param	= iscsi_conn_get_param,
-	.set_param	= cxgbi_set_conn_param,
+	.set_param	= __cxgbi_set_conn_param,
 	.get_stats	= cxgbi_get_conn_stats,
 	/* pdu xmit req from user space */
 	.send_pdu	= iscsi_conn_send_pdu,
@@ -136,7 +136,7 @@ static struct iscsi_transport cxgb3i_isc
 	.parse_pdu_itt	= cxgbi_parse_pdu_itt,
 	/* TCP connect/disconnect */
 	.get_ep_param	= cxgbi_get_ep_param,
-	.ep_connect	= cxgbi_ep_connect,
+	.ep_connect	= __cxgbi_ep_connect,
 	.ep_poll	= cxgbi_ep_poll,
 	.ep_disconnect	= cxgbi_ep_disconnect,
 	/* Error recovery timeout call */
@@ -1258,8 +1258,8 @@ static int cxgb3i_ddp_init(struct cxgbi_
 		err = 0;
 	}
 
-	cdev->csk_ddp_setup_digest = ddp_setup_conn_digest;
-	cdev->csk_ddp_setup_pgidx = ddp_setup_conn_pgidx;
+	cdev->__csk_ddp_setup_digest = ddp_setup_conn_digest;
+	cdev->__csk_ddp_setup_pgidx = ddp_setup_conn_pgidx;
 	cdev->csk_ddp_set_map = ddp_set_map;
 	cdev->csk_ddp_clear_map = ddp_clear_map;
 	cdev->cdev2ppm = cdev2ppm;
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -133,12 +133,12 @@ static struct iscsi_transport cxgb4i_isc
 	.get_session_param = iscsi_session_get_param,
 	/* connection management */
 	.create_conn	= cxgbi_create_conn,
-	.bind_conn		= cxgbi_bind_conn,
+	.bind_conn		= __cxgbi_bind_conn,
 	.destroy_conn	= iscsi_tcp_conn_teardown,
 	.start_conn		= iscsi_conn_start,
 	.stop_conn		= iscsi_conn_stop,
 	.get_conn_param	= iscsi_conn_get_param,
-	.set_param	= cxgbi_set_conn_param,
+	.set_param	= __cxgbi_set_conn_param,
 	.get_stats	= cxgbi_get_conn_stats,
 	/* pdu xmit req from user space */
 	.send_pdu	= iscsi_conn_send_pdu,
@@ -153,7 +153,7 @@ static struct iscsi_transport cxgb4i_isc
 	.parse_pdu_itt	= cxgbi_parse_pdu_itt,
 	/* TCP connect/disconnect */
 	.get_ep_param	= cxgbi_get_ep_param,
-	.ep_connect	= cxgbi_ep_connect,
+	.ep_connect	= __cxgbi_ep_connect,
 	.ep_poll	= cxgbi_ep_poll,
 	.ep_disconnect	= cxgbi_ep_disconnect,
 	/* Error recovery timeout call */
@@ -2088,8 +2088,8 @@ static int cxgb4i_ddp_init(struct cxgbi_
 	cxgbi_ddp_ppm_setup(lldi->iscsi_ppm, cdev, &tformat, ppmax,
 			    lldi->iscsi_llimit, lldi->vr->iscsi.start, 2);
 
-	cdev->csk_ddp_setup_digest = ddp_setup_conn_digest;
-	cdev->csk_ddp_setup_pgidx = ddp_setup_conn_pgidx;
+	cdev->__csk_ddp_setup_digest = ddp_setup_conn_digest;
+	cdev->__csk_ddp_setup_pgidx = ddp_setup_conn_pgidx;
 	cdev->csk_ddp_set_map = ddp_set_map;
 	cdev->tx_max_size = min_t(unsigned int, ULP2_MAX_PDU_PAYLOAD,
 				  lldi->iscsi_iolen - ISCSI_PDU_NONPAYLOAD_LEN);
--- a/drivers/scsi/cxgbi/libcxgbi.c
+++ b/drivers/scsi/cxgbi/libcxgbi.c
@@ -551,7 +551,7 @@ void cxgbi_sock_free_cpl_skbs(struct cxg
 }
 EXPORT_SYMBOL_GPL(cxgbi_sock_free_cpl_skbs);
 
-static struct cxgbi_sock *cxgbi_sock_create(struct cxgbi_device *cdev)
+static struct cxgbi_sock *cxgbi_sock_create(struct cxgbi_device *cdev, bool kabi_supports_completion)
 {
 	struct cxgbi_sock *csk = kzalloc(sizeof(*csk), GFP_NOIO);
 
@@ -571,7 +571,8 @@ static struct cxgbi_sock *cxgbi_sock_cre
 	skb_queue_head_init(&csk->receive_queue);
 	skb_queue_head_init(&csk->write_queue);
 	timer_setup(&csk->retry_timer, NULL, 0);
-	init_completion(&csk->cmpl);
+	if (kabi_supports_completion)
+		init_completion(&csk->cmpl);
 	rwlock_init(&csk->callback_lock);
 	csk->cdev = cdev;
 	csk->flags = 0;
@@ -598,7 +599,7 @@ static struct rtable *find_route_ipv4(st
 }
 
 static struct cxgbi_sock *
-cxgbi_check_route(struct sockaddr *dst_addr, int ifindex)
+cxgbi_check_route(struct sockaddr *dst_addr, int ifindex, bool kabi_supports_completion)
 {
 	struct sockaddr_in *daddr = (struct sockaddr_in *)dst_addr;
 	struct dst_entry *dst;
@@ -664,7 +665,7 @@ cxgbi_check_route(struct sockaddr *dst_a
 		&daddr->sin_addr.s_addr, ntohs(daddr->sin_port),
 			   port, ndev->name, cdev);
 
-	csk = cxgbi_sock_create(cdev);
+	csk = cxgbi_sock_create(cdev, kabi_supports_completion);
 	if (!csk) {
 		err = -ENOMEM;
 		goto rel_neigh;
@@ -710,7 +711,7 @@ static struct rt6_info *find_route_ipv6(
 }
 
 static struct cxgbi_sock *
-cxgbi_check_route6(struct sockaddr *dst_addr, int ifindex)
+cxgbi_check_route6(struct sockaddr *dst_addr, int ifindex, bool kabi_supports_completion)
 {
 	struct sockaddr_in6 *daddr6 = (struct sockaddr_in6 *)dst_addr;
 	struct dst_entry *dst;
@@ -775,7 +776,7 @@ cxgbi_check_route6(struct sockaddr *dst_
 		  daddr6->sin6_addr.s6_addr, ntohs(daddr6->sin6_port), port,
 		  ndev->name, cdev);
 
-	csk = cxgbi_sock_create(cdev);
+	csk = cxgbi_sock_create(cdev, kabi_supports_completion);
 	if (!csk) {
 		err = -ENOMEM;
 		goto rel_rt;
@@ -2234,8 +2235,9 @@ static int cxgbi_conn_max_recv_dlength(s
 	return 0;
 }
 
-int cxgbi_set_conn_param(struct iscsi_cls_conn *cls_conn,
-			enum iscsi_param param, char *buf, int buflen)
+static int cxgbi_set_conn_param_internal(struct iscsi_cls_conn *cls_conn,
+			enum iscsi_param param, char *buf, int buflen,
+			bool does_not_need_reply_arg)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
@@ -2250,17 +2252,29 @@ int cxgbi_set_conn_param(struct iscsi_cl
 	switch (param) {
 	case ISCSI_PARAM_HDRDGST_EN:
 		err = iscsi_set_param(cls_conn, param, buf, buflen);
-		if (!err && conn->hdrdgst_en)
-			err = csk->cdev->csk_ddp_setup_digest(csk, csk->tid,
-							conn->hdrdgst_en,
-							conn->datadgst_en);
+		if (!err && conn->hdrdgst_en) {
+			if (does_not_need_reply_arg)
+				err = csk->cdev->__csk_ddp_setup_digest(csk, csk->tid,
+								conn->hdrdgst_en,
+								conn->datadgst_en);
+			else
+				err = csk->cdev->csk_ddp_setup_digest(csk, csk->tid,
+								conn->hdrdgst_en,
+								conn->datadgst_en, 0);
+		}
 		break;
 	case ISCSI_PARAM_DATADGST_EN:
 		err = iscsi_set_param(cls_conn, param, buf, buflen);
-		if (!err && conn->datadgst_en)
-			err = csk->cdev->csk_ddp_setup_digest(csk, csk->tid,
-							conn->hdrdgst_en,
-							conn->datadgst_en);
+		if (!err && conn->datadgst_en) {
+			if (does_not_need_reply_arg)
+				err = csk->cdev->__csk_ddp_setup_digest(csk, csk->tid,
+								conn->hdrdgst_en,
+								conn->datadgst_en);
+			else
+				err = csk->cdev->csk_ddp_setup_digest(csk, csk->tid,
+								conn->hdrdgst_en,
+								conn->datadgst_en, 0);
+		}
 		break;
 	case ISCSI_PARAM_MAX_R2T:
 		return iscsi_tcp_set_max_r2t(conn, buf);
@@ -2279,8 +2293,21 @@ int cxgbi_set_conn_param(struct iscsi_cl
 	}
 	return err;
 }
+
+int cxgbi_set_conn_param(struct iscsi_cls_conn *cls_conn,
+			enum iscsi_param param, char *buf, int buflen)
+{
+	return cxgbi_set_conn_param_internal(cls_conn, param, buf, buflen, 0);
+}
 EXPORT_SYMBOL_GPL(cxgbi_set_conn_param);
 
+int __cxgbi_set_conn_param(struct iscsi_cls_conn *cls_conn,
+			enum iscsi_param param, char *buf, int buflen)
+{
+	return cxgbi_set_conn_param_internal(cls_conn, param, buf, buflen, 1);
+}
+EXPORT_SYMBOL_GPL(__cxgbi_set_conn_param);
+
 static inline int csk_print_port(struct cxgbi_sock *csk, char *buf)
 {
 	int len;
@@ -2362,9 +2389,10 @@ cxgbi_create_conn(struct iscsi_cls_sessi
 }
 EXPORT_SYMBOL_GPL(cxgbi_create_conn);
 
-int cxgbi_bind_conn(struct iscsi_cls_session *cls_session,
+int cxgbi_bind_conn_internal(struct iscsi_cls_session *cls_session,
 				struct iscsi_cls_conn *cls_conn,
-				u64 transport_eph, int is_leading)
+				u64 transport_eph, int is_leading,
+				bool does_not_need_reply_arg)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
@@ -2384,8 +2412,12 @@ int cxgbi_bind_conn(struct iscsi_cls_ses
 	csk = cep->csk;
 
 	ppm = csk->cdev->cdev2ppm(csk->cdev);
-	err = csk->cdev->csk_ddp_setup_pgidx(csk, csk->tid,
-					     ppm->tformat.pgsz_idx_dflt);
+	if (does_not_need_reply_arg)
+		err = csk->cdev->__csk_ddp_setup_pgidx(csk, csk->tid,
+						     ppm->tformat.pgsz_idx_dflt);
+	else
+		err = csk->cdev->csk_ddp_setup_pgidx(csk, csk->tid,
+						     ppm->tformat.pgsz_idx_dflt, 0);
 	if (err < 0)
 		return err;
 
@@ -2414,8 +2446,25 @@ int cxgbi_bind_conn(struct iscsi_cls_ses
 
 	return 0;
 }
+
+int cxgbi_bind_conn(struct iscsi_cls_session *cls_session,
+				struct iscsi_cls_conn *cls_conn,
+				u64 transport_eph, int is_leading)
+{
+	return cxgbi_bind_conn_internal(cls_session, cls_conn, transport_eph,
+			is_leading, 0);
+}
 EXPORT_SYMBOL_GPL(cxgbi_bind_conn);
 
+int __cxgbi_bind_conn(struct iscsi_cls_session *cls_session,
+				struct iscsi_cls_conn *cls_conn,
+				u64 transport_eph, int is_leading)
+{
+	return cxgbi_bind_conn_internal(cls_session, cls_conn, transport_eph,
+			is_leading, 1);
+}
+EXPORT_SYMBOL_GPL(__cxgbi_bind_conn);
+
 struct iscsi_cls_session *cxgbi_create_session(struct iscsi_endpoint *ep,
 						u16 cmds_max, u16 qdepth,
 						u32 initial_cmdsn)
@@ -2545,9 +2594,9 @@ int cxgbi_get_host_param(struct Scsi_Hos
 }
 EXPORT_SYMBOL_GPL(cxgbi_get_host_param);
 
-struct iscsi_endpoint *cxgbi_ep_connect(struct Scsi_Host *shost,
+static struct iscsi_endpoint *cxgbi_ep_connect_internal(struct Scsi_Host *shost,
 					struct sockaddr *dst_addr,
-					int non_blocking)
+					int non_blocking, bool kabi_supports_completion)
 {
 	struct iscsi_endpoint *ep;
 	struct cxgbi_endpoint *cep;
@@ -2570,10 +2619,10 @@ struct iscsi_endpoint *cxgbi_ep_connect(
 
 check_route:
 	if (dst_addr->sa_family == AF_INET) {
-		csk = cxgbi_check_route(dst_addr, ifindex);
+		csk = cxgbi_check_route(dst_addr, ifindex, kabi_supports_completion);
 #if IS_ENABLED(CONFIG_IPV6)
 	} else if (dst_addr->sa_family == AF_INET6) {
-		csk = cxgbi_check_route6(dst_addr, ifindex);
+		csk = cxgbi_check_route6(dst_addr, ifindex, kabi_supports_completion);
 #endif
 	} else {
 		pr_info("address family 0x%x NOT supported.\n",
@@ -2641,8 +2690,32 @@ release_conn:
 err_out:
 	return ERR_PTR(err);
 }
+
+
+struct iscsi_endpoint *cxgbi_ep_connect(struct Scsi_Host *shost,
+					struct sockaddr *dst_addr,
+					int non_blocking)
+{
+	/*
+	 * this uses the original KABI, which uses NOT completion, and
+	 * for external drivers expecting the original KABI
+	 */
+	return cxgbi_ep_connect_internal(shost, dst_addr, non_blocking, false);
+}
 EXPORT_SYMBOL_GPL(cxgbi_ep_connect);
 
+struct iscsi_endpoint *__cxgbi_ep_connect(struct Scsi_Host *shost,
+					struct sockaddr *dst_addr,
+					int non_blocking)
+{
+	/*
+	 * this uses the new KABI, which uses completion, and is
+	 * used by our updated cxgb3i and cxgb4i drivers
+	 */
+	return cxgbi_ep_connect_internal(shost, dst_addr, non_blocking, true);
+}
+EXPORT_SYMBOL_GPL(__cxgbi_ep_connect);
+
 int cxgbi_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)
 {
 	struct cxgbi_endpoint *cep = ep->dd_data;
--- a/drivers/scsi/cxgbi/libcxgbi.h
+++ b/drivers/scsi/cxgbi/libcxgbi.h
@@ -149,7 +149,6 @@ struct cxgbi_sock {
 	struct sk_buff_head receive_queue;
 	struct sk_buff_head write_queue;
 	struct timer_list retry_timer;
-	struct completion cmpl;
 	int err;
 	rwlock_t callback_lock;
 	void *user_data;
@@ -162,6 +161,9 @@ struct cxgbi_sock {
 	u32 write_seq;
 	u32 snd_win;
 	u32 rcv_win;
+#ifndef	__GENKSYMS__
+	struct completion cmpl;
+#endif
 };
 
 /*
@@ -491,9 +493,9 @@ struct cxgbi_device {
 				  struct cxgbi_ppm *,
 				  struct cxgbi_task_tag_info *);
 	int (*csk_ddp_setup_digest)(struct cxgbi_sock *,
-				    unsigned int, int, int);
+				unsigned int, int, int, int);
 	int (*csk_ddp_setup_pgidx)(struct cxgbi_sock *,
-				   unsigned int, int);
+				unsigned int, int, bool);
 
 	void (*csk_release_offload_resources)(struct cxgbi_sock *);
 	int (*csk_rx_pdu_ready)(struct cxgbi_sock *, struct sk_buff *);
@@ -505,6 +507,12 @@ struct cxgbi_device {
 	int (*csk_init_act_open)(struct cxgbi_sock *);
 
 	void *dd_data;
+#ifndef	__GENKSYMS__
+	int (*__csk_ddp_setup_digest)(struct cxgbi_sock *,
+				    unsigned int, int, int);
+	int (*__csk_ddp_setup_pgidx)(struct cxgbi_sock *,
+				   unsigned int, int);
+#endif
 };
 #define cxgbi_cdev_priv(cdev)	((cdev)->dd_data)
 
@@ -590,10 +598,14 @@ umode_t cxgbi_attr_is_visible(int param_
 void cxgbi_get_conn_stats(struct iscsi_cls_conn *, struct iscsi_stats *);
 int cxgbi_set_conn_param(struct iscsi_cls_conn *,
 			enum iscsi_param, char *, int);
+int __cxgbi_set_conn_param(struct iscsi_cls_conn *,
+			enum iscsi_param, char *, int);
 int cxgbi_get_ep_param(struct iscsi_endpoint *ep, enum iscsi_param, char *);
 struct iscsi_cls_conn *cxgbi_create_conn(struct iscsi_cls_session *, u32);
 int cxgbi_bind_conn(struct iscsi_cls_session *,
 			struct iscsi_cls_conn *, u64, int);
+int __cxgbi_bind_conn(struct iscsi_cls_session *,
+			struct iscsi_cls_conn *, u64, int);
 void cxgbi_destroy_session(struct iscsi_cls_session *);
 struct iscsi_cls_session *cxgbi_create_session(struct iscsi_endpoint *,
 			u16, u16, u32);
@@ -602,6 +614,8 @@ int cxgbi_set_host_param(struct Scsi_Hos
 int cxgbi_get_host_param(struct Scsi_Host *, enum iscsi_host_param, char *);
 struct iscsi_endpoint *cxgbi_ep_connect(struct Scsi_Host *,
 			struct sockaddr *, int);
+struct iscsi_endpoint *__cxgbi_ep_connect(struct Scsi_Host *,
+			struct sockaddr *, int);
 int cxgbi_ep_poll(struct iscsi_endpoint *, int);
 void cxgbi_ep_disconnect(struct iscsi_endpoint *);
 
