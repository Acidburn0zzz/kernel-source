#! /usr/bin/perl -w

#  This script is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.
#
#  Copyright 2006 Andreas Gruenbacher <agruen@suse.de>


use File::Temp qw(mktemp tempdir);
use File::Basename;
use FileHandle;
use Getopt::Long qw(:config gnu_getopt);
use strict;

my $check_for_duplicate_symbols;
my $ignore_undefined_symbols;
my $report_matching_symbols;
my $keep_silent;
my $kernel_version;

my $tmpdir;
my %modver;
my %where;
my $status = 0;

sub filetype($) {
    my ($file) = @_;
    stat $file
        or die "$file: $!\n";
    return `file -b --dereference "$file"`;
}

sub expand($) {
    my ($file) = @_;
    if (filetype($file) =~ /^gzip /) {
	my $tmp = mktemp("$tmpdir/" . basename($file) . ".XXXXXX");
	system("gzip -cd $file > $tmp");
	exit(1) if $?;
	return $tmp;
    } else {
	return $file;
    }
}

sub obj_26_exported_symbols($) {
    my ($obj) = @_;
    my @exported_symbols = map {
	    /^(?:00000000)?([0-9a-f]+) A __crc_(.*)/
	        ? ["0x$1", $2] : ();
	} `nm "$obj"`;
    exit(1) if $?;
    return @exported_symbols;
}

sub obj_26_imported_symbols($) {
    my ($obj) = @_;
    my @imported_symbols = map {
	    /^(0x[0-9a-f]+)\s+(.*)/
	        ? [$1, $2] : ();
	} `/sbin/modprobe --dump-modversions "$obj"`;
    exit(1) if $?;
    return @imported_symbols;
}

sub vmlinux_24_exported_symbols($) {
    my ($obj) = @_;

    my @exported_symbols = map {
	(/^(.*)_R([0-9a-f]+)$/)
	    ? ["0x$2", $1] : ();
	} split /\0+/, `objcopy -j .kstrtab -O binary $obj /dev/stdout`;
    return @exported_symbols;
}

sub obj_24_exported_symbols($) {
    my ($obj) = @_;
    my @exported_symbols = map {
	/^(?:[0-9a-f]+) R __kstrtab_(.*)_R([0-9a-f]+)/
	    ? ["0x$2", $1] : ();
	} `nm "$obj"`;
    exit(1) if $?;
    return @exported_symbols;
}

sub obj_24_imported_symbols($) {
    my ($obj) = @_;
    my @imported_symbols = map {
	(/^\s+U (.*)_R([0-9a-f]+)/ && $1 ne "__this_module")
	    ? ["0x$2", $1] : ();
        } `nm "$obj"`;
    return @imported_symbols;
}

sub version_check($) {
    my ($obj) = @_;
    unless (defined $kernel_version) {
	if (`/sbin/get_kernel_version $obj` =~ /\b2\.4\b/ ||
	    `/sbin/modinfo -F kernel_version $obj` =~ /\b2\.4\b/) {
	    $kernel_version = "2.4";
	} else {
	    $kernel_version = "2.6";
	}
    }
    return $kernel_version;
}

sub obj_exported_symbols($) {
    my ($obj) = @_;
    if (version_check($obj) eq "2.4") {
	return obj_24_exported_symbols($obj);
    } else {
	return obj_26_exported_symbols($obj);
    }
}

sub obj_imported_symbols($) {
    my ($obj) = @_;
    if (version_check($obj) eq "2.4") {
	return obj_24_imported_symbols($obj);
    } else {
	return obj_26_imported_symbols($obj);
    }
}

sub check_exports(@) {
    my (@exports) = @_;
    my %seen;

    for (my $n = 0; $n < @exports; $n++) {
	my ($modver, $symbol, $where) = @{$exports[$n]};
	$modver =~ s/^0x0*//;
	if (exists $modver{$symbol}) {
	    if ($modver ne $modver{$symbol}) {
		print "$where: $symbol($modver) conflicts with " .
		      "$symbol($modver{$symbol}) from $where{$symbol}\n"
		    unless $keep_silent;
		$status = 1;
	    } else {
		if ($check_for_duplicate_symbols) {
		    print "$where: $symbol($modver) redefined, " .
			  "previous definition in $where{$symbol}\n"
			unless $keep_silent;
		    $status = 1;
		}
	    }
	}
	$modver{$symbol} = $modver;
	$where{$symbol} = "$where";
	$seen{$symbol} = 1;
    }
}

sub check_imports($@) {
    my ($filename, @imports) = @_;
    my $basename = basename($filename);

    for (my $n = 0; $n < @imports; $n++) {
	my ($modver, $symbol) = @{$imports[$n]};
	$modver =~ s/^0x0*//;
	if (exists $modver{$symbol}) {
	    if ($modver ne $modver{$symbol}) {
		print "$basename: $symbol($modver) mismatch with $symbol" .
		      "($modver{$symbol}) from $where{$symbol}\n"
		    unless $keep_silent;
		$status = 1;
	    } elsif ($report_matching_symbols) {
		print "$basename: $symbol($modver) matches\n";
	    }
	} elsif (!$ignore_undefined_symbols) {
	    print "$basename: $symbol($modver) undefined\n"
		unless $keep_silent;
	    $status = 1;
	}
    }
}

sub check_kernel($) {
    my ($filename) = @_;
    my $file = expand($filename);
    my $filetype = filetype($file);
    if ($filetype =~ /^ELF/) {
	# Assume this is vmlinux
	check_exports
	    map { [$_->[0], $_->[1], basename $filename] }
		(version_check($file) eq "2.4"
		    ? vmlinux_24_exported_symbols($file) :
		      obj_exported_symbols($file));
	return;
    } elsif ($filetype =~ /^RPM/) {
	# Assume this is a kernel-$flavor.rpm file
	system("rpm2cpio $file | " .
	       "(cd $tmpdir; " .
	       " cpio -dim --quiet './boot/symvers-*.gz' 'boot/symvers-*.gz')");
	my @symvers = glob("$tmpdir/boot/*");
	unless (@symvers == 1) {
	    print STDERR "Failed to extract /boot/symvers-*.gz from " .
		  "$filename\n";
	    exit 1;
	}
	$file = expand($symvers[0]);
	# now we have a symvers dump file...
    }
    # Assume this is a symvers dump file
    my $fh = new FileHandle("sed -e '/^#/d' -e 's/\t+/\t/' \"$file\" |")
	or die "$file: $!\n";
    check_exports
	map { [$_->[0], $_->[1], basename($filename) .
			         (defined $_->[2] ? ":$_->[2]" : "")] }
	    map { [split(/\s+/, $_)] } <$fh>;
}

sub usage($) {
    my ($status) = @_;

    print <<EOF;
Usage: $0 {kernel symbols} {module symbols} ...
       $0 --dump-modversions {module binary}

Check a kernel's exported symbols against a set of modules, or create
a module symbol dump file (--dump-modversions). The kernel symbols can
be given as a kernel rpm, symvers dump, or vmlinux binary (with 2.6
kernels). Module symbols can either be given as a module binary or a
module symbol dump file as produced by the --dump-modversions option.

Supports checking a set of modules against a kernel: in this case,
internal dependencies between those modules are resolved as well.

--ignore-undefined-symbols
    Ignore symbols the module uses which are undefined. This is useful
    when checking a single module against a kernel and this module uses
    symbols from other modules that are not part of the kernel.

--check-for-duplicate-symbols
    Report when multiple modules define the same symbols.

--report-matching-symbols
    Report matching symbols that are found as well.

--silent
    Do not report ABI changes; only set the exit status accordingly.

EOF

    exit $status;
}

my $dump_modversions;

GetOptions(
    "d|dump-modversions" => \$dump_modversions,
    "u|ignore-undefined-symbols" => \$ignore_undefined_symbols,
    "D|check-for-duplicate-symbols" => \$check_for_duplicate_symbols,
    "report-matching-symbols" => \$report_matching_symbols,
    "silent" => \$keep_silent,
    "h|help" => sub { usage(0); },

) or usage(1);

if ($dump_modversions) {
    usage(1) if @ARGV != 1;
} else {
    usage(1) if @ARGV < 1;
}

$tmpdir = tempdir(CLEANUP => 1);

if ($dump_modversions) {
    map { print "$_->[0]\t+$_->[1]\n" } obj_exported_symbols($ARGV[0]);
    map { print "$_->[0]\t$_->[1]\n" } obj_imported_symbols($ARGV[0]);
} else {
    my @file;
    my @filetype;
    for (my $n = 1; $n < @ARGV; $n++) {
	$file[$n] = expand($ARGV[$n]);
	$filetype[$n] = filetype($file[$n]);
    }

    # Grab all the symbols the kernel exports
    check_kernel $ARGV[0];

    # Module pass 1: exported symbols
    for (my $n = 1; $n < @ARGV; $n++) {
	if ($filetype[$n] =~ /^ELF/) {
	    # Assume a *.ko file
	    check_exports
		map { [$_->[0], $_->[1], basename $ARGV[$n]] }
		    obj_exported_symbols($file[$n]);
	} else {
	    # Assume a ``--dump-modversions'' file
	    my $fh = new FileHandle("sed -n -e '/^#/d' -e 's/\t+/\t/p' " .
				    "\"$file[$n]\" |")
	        or die "$file[$n]: $!\n";
	    check_exports
		map { [split(/\s+/, $_), basename $ARGV[$n]] } <$fh>;
	}
    }
    # Module pass 2: imported symbols
    for (my $n = 1; $n < @ARGV; $n++) {
	if ($filetype[$n] =~ /^ELF/) {
	    # Assume a *.ko file
	    check_imports $ARGV[$n],
		obj_imported_symbols($file[$n]);
	} else {
	    # Assume a ``--dump-modversions'' file
	    my $fh = new FileHandle("sed -e '/^#/d' -e '/\t+/d' " .
				    "\"$file[$n]\" |")
	        or die "$file[$n]: $!\n";
	    check_imports $ARGV[$n], map { [split(/\s+/, $_)] } <$fh>;
	}
    }
}

exit $status;

# vim:shiftwidth=4 softtabstop=4
