#! /usr/bin/perl -w

use File::Temp qw(mktemp tempdir);
use File::Basename;
use FileHandle;
use Getopt::Long qw(:config no_ignore_case bundling);
use strict;

my $check_for_duplicate_symbols;
my $ignore_undefined_symbols;
my $report_matching_symbols;
my $report_new_symbols;
my $report_removed_symbols;

my $tmpdir;
my %modver;
my %where;
my $status = 0;

sub filetype($) {
    my ($file) = @_;
    stat $file
        or die "$file: $!\n";
    return `file -b "$file"`;
}

sub expand($) {
    my ($file) = @_;
    if (filetype($file) =~ /^gzip /) {
	my $tmp = mktemp("$tmpdir/" . basename($file) . ".XXXXXX");
	system("gzip -cd $file > $tmp");
	exit(1) if $?;
	return $tmp;
    } else {
	return $file;
    }
}

sub obj_exported_symbols($) {
    my ($obj) = @_;
    my @exported_symbols = map {
	    /^(?:00000000)?([0-9a-f]+) A __crc_(.*)/
	        ? ["0x$1", $2] : ();
	} `nm "$obj"`;
    exit(1) if $?;
    return @exported_symbols;
}

sub obj_imported_symbols($) {
    my ($obj) = @_;
    my @imported_symbols = map {
	    /^(0x[0-9a-f]+)\s+(.*)/
	        ? [$1, $2] : ();
	} `/sbin/modprobe --dump-modversions "$obj"`;
    exit(1) if $?;
    return @imported_symbols;
}

sub check_exports(@) {
    my (@exports) = @_;
    my %seen;

    for (my $n = 0; $n < @exports; $n++) {
	my ($modver, $symbol, $where) = @{$exports[$n]};
	$modver =~ s/^0x0*//;
	if (exists $modver{$symbol}) {
	    if ($modver ne $modver{$symbol}) {
		print "$where: $symbol($modver) conflicts with " .
		      "$symbol($modver{$symbol}) from $where{$symbol}\n";
		$status = 1;
	    } else {
		if ($check_for_duplicate_symbols) {
		    print "$where: $symbol($modver) redefined, " .
			  "previous definition in $where{$symbol}\n";
		    $status = 1;
		}
	    }
	} else {
	    if ($report_new_symbols) {
		print "$where: $symbol($modver) added\n";
		$status = 1;
	    }
	}
	$modver{$symbol} = $modver;
	$where{$symbol} = "$where";
	$seen{$symbol} = 1;
    }

    if ($report_removed_symbols) {
	foreach my $symbol (keys %modver) {
	    next if exists $seen{$symbol};
	    print "$where{$symbol}: $symbol($modver{$symbol}) removed\n";
	}
    }
}

sub check_imports($@) {
    my ($filename, @imports) = @_;
    my $basename = basename($filename);

    for (my $n = 0; $n < @imports; $n++) {
	my ($modver, $symbol) = @{$imports[$n]};
	$modver =~ s/^0x0*//;
	if (exists $modver{$symbol}) {
	    if ($modver ne $modver{$symbol}) {
		print "$basename: $symbol($modver) mismatch with $symbol" .
		      "($modver{$symbol}) from $where{$symbol}\n";
		$status = 1;
	    } elsif ($report_matching_symbols) {
		print "$basename: $symbol($modver) matches\n";
	    }
	} elsif (!$ignore_undefined_symbols) {
	    print "$basename: $symbol($modver) undefined\n";
	    $status = 1;
	}
    }
}

sub check_kernel($) {
    my ($filename) = @_;
    my $basename = basename($filename);
    my $file = expand($filename);
    my $filetype = filetype($file);
    if ($filetype =~ /^ELF/) {
	# Assume this is vmlinux
	check_exports
	    map { [$_->[0], $_->[1], $basename] }
		obj_exported_symbols($file);
    } elsif ($filetype =~ /^RPM/) {
	# Assume this is a kernel-$flavor.rpm file
	print STDERR "Reading symvers from an rpm package not implemented\n";
	exit 1;
    } else {
	# Assume this is a symvers dump file
	my $fh = new FileHandle("sed -e 's/\t+/\t/' \"$file\" |")
	    or die "$file: $!\n";
	check_exports
	    map { [$_->[0], $_->[1], "$basename:$_->[2]"] }
		map { [split(/\s+/, $_)] } <$fh>;
    }
}

sub usage($) {
    my ($status) = @_;

    exit $status;
}

my $compare_kernels;
my $dump_modversions;

GetOptions(
    "d|dump-modversions" => \$dump_modversions,
    "u|ignore-undefined-symbols" => \$ignore_undefined_symbols,
    "D|check-for-duplicate-symbols" => \$check_for_duplicate_symbols,
    "report-matching-symbols" => \$report_matching_symbols,
    "compare-kernels" => \$compare_kernels,
    "h|help" => sub { usage(0); },

) or usage(1);

if ($dump_modversions) {
    usage(1) if @ARGV != 1;
} elsif ($compare_kernels) {
    usage(1) if @ARGV != 2;
} else {
    usage(1) if @ARGV < 1;
}

$tmpdir = tempdir(CLEANUP => 1);

check_kernel $ARGV[0];

if ($dump_modversions) {
    map { print "$_->[0]\t+$_->[1]\n" } obj_exported_symbols($ARGV[0]);
    map { print "$_->[0]\t$_->[1]\n" } obj_imported_symbols($ARGV[0]);
} elsif ($compare_kernels) {
    $report_new_symbols = 1;
    $report_removed_symbols = 1;
    # we cannot also check for identical duplicates in the second kernel
    $check_for_duplicate_symbols = 0;
    check_kernel $ARGV[1];
} else {
    my @file;
    my @filetype;
    for (my $n = 1; $n < @ARGV; $n++) {
	$file[$n] = expand($ARGV[$n]);
	$filetype[$n] = filetype($file[$n]);
    }

    # Module pass 1: exported symbols
    for (my $n = 1; $n < @ARGV; $n++) {
	if ($filetype[$n] =~ /^ELF/) {
	    # Assume a *.ko file
	    check_exports
		map { [$_->[0], $_->[1], $ARGV[$n]] }
		    obj_exported_symbols($file[$n]);
	} else {
	    # Assume a ``--dump-modversions'' file
	    my $fh = new FileHandle("sed -ne 's/\t+/\t/p' \"$file[$n]\" |")
	        or die "$file[$n]: $!\n";
	    check_exports
		map { [split(/\s+/, $_), $ARGV[$n]] } <$fh>;
	}
    }
    # Module pass 2: imported symbols
    for (my $n = 1; $n < @ARGV; $n++) {
	if ($filetype[$n] =~ /^ELF/) {
	    # Assume a *.ko file
	    check_imports $ARGV[$n],
		obj_imported_symbols($file[$n]);
	} else {
	    # Assume a ``--dump-modversions'' file
	    my $fh = new FileHandle("sed -e '/\t+/d' \"$file[$n]\" |")
	        or die "$file[$n]: $!\n";
	    check_imports $ARGV[$n], map { [split(/\s+/, $_)] } <$fh>;
	}
    }
}

exit $status;

# vim:shiftwidth=4 softtabstop=4
