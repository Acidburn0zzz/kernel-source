#! /bin/sh

set -e
shopt -s nullglob

COMMITS_DIR=$HOME/COMMITS
FLAGS_DIR=$HOME/NEEDS_REBUILD
CVS_DIR=$HOME/CVS
LOGFILE=$HOME/kbuild.log
LOCKFILE=/tmp/${0##*/}.lock
LOCK_TIMEOUT=$((30*60))  # seconds

MBUILD_TOBUILD_DIR=/work/built/mbuild/tobuild
MBUILD_DIR=/work/built/mbuild
MBUILD=/work/src/bin/mbuild
SKIP_DIR=/work/SRC/DOESNOTBUILD
MBUILD_SETS=/work/cd/lib/mbuild/sets

JOBS_HOST=$(hostname)
JOBS_LOGNAME=$(whoami)

export CVS_RSH=ssh

export RSYNC_PASSWORD=kerneltest
RSYNC_DEST=kerneltest@dist::kerneltest

# ========================================================

declare -a exit_handlers

add_exit_handler() {
    exit_handlers=( "${exit_handlers[@]}" "$1" )
}

remove_exit_handler() {
    declare -a handlers
    local h
    for h in "${exit_handlers[@]}"; do
	[ "$h" = "$1" ] && continue
	handlers=( "${handlers[@]}" "$h" )
    done
    exit_handlers=( "${handlers[@]}" )
}

run_exit_handlers() {
    local h
    for h in "${exit_handlers[@]}"; do
	eval $h
    done
}

trap run_exit_handlers EXIT

# ========================================================

usage() {
    echo "Usage: ${0##*/} [...] {update|start|finalize|resmail to-addr}"
    exit 1
}

log() {
    local msg=$1 date=$(date "+%Y-%m-%d %H:%M:%S")

    echo "$date $msg" >> $LOGFILE
}

archs_for_package() {
    local package=$1
    local arch archs

    if [ -n "$include_archs" ]; then
	archs=$include_archs
    else
	archs=$(cat $MBUILD_SETS/${dist_base:-stable} \
		| sed -e "s/^$dist_base-//")
    fi

    for arch in $archs; do
	case " $exclude_archs " in
	    *" $arch "*) continue ;;
	esac

	[ -e $SKIP_DIR/${dist_base:+$dist_base-}$arch/$package ] \
	    || echo $arch
    done
}

dist_base_for_repo() {
    local repository=$1 branch=$2

    case $repository/$branch in
	kernel-source-26/SLES9_GA_BRANCH | \
	kernel-source-26/SLES9_SP1_BRANCH)
	    echo sles9 ;;
	kernel-source-26/HEAD)
	    ;;
	*)
	    echo "No distribution defined for branch $branch" >&2
	    exit 1 ;;
    esac
}

branch_of_job() {
    local jobid=$1

    (   unset CVS_BRANCH
	source $MBUILD_DIR/$jobid/get_release_number.sh > /dev/null
	echo $CVS_BRANCH
    )
}

cvs_update() {
    local repository=$1 branch=$2
    local messages

    if [ -n "$dry_run" ]; then
	echo "cvs update -d -P"
	return
    fi

    messages=$(
	cd $CVS_DIR/$repository/$branch
	log "cvs update"
	cvs update -d -P 2>&1
    )
    echo -n "$messages" 2>&1 | grep -q -v -e '^cvs server:' -e '^?'
}

tar_up() {
    local repository=$1 branch=$2

    if [ -n "$dry_run" ]; then
	echo scripts/tar-up.sh
	return
    fi

    if [ -d $CVS_DIR/$repository/$branch ]; then
	pushd $CVS_DIR/$repository/$branch > /dev/null
	log "tar-up"
	scripts/tar-up.sh < /dev/null > /dev/null
	ts=$(tr -dc '[0-9]' < kernel-source/build-source-timestamp)

	cat > kernel-source/get_release_number.sh <<-EOF
		#! /bin/sh
		CVS_BRANCH=$branch
		[ \$CVS_BRANCH != HEAD ] && echo -n \${CVS_BRANCH}_
		echo $ts
		EOF
	chmod +x kernel-source/get_release_number.sh
	popd > /dev/null
    fi
}

update_flags() {
    local repository=$1 branch=$2
    local spec

    for spec in $CVS_DIR/$repository/$branch/kernel-source/*.spec; do
	package=${spec##*/}
	package=${package%.spec}

	if [ -n "$include_packages" ]; then
	    case " $include_packages " in
		*" $package "*) ;;
		*)      continue ;;
	    esac
	fi

	if [ -n "$exclude_packages" ]; then
	    case " $exclude_packages " in
		*" $package "*) continue ;;
	    esac
	fi

	dist_base=$(dist_base_for_repo $repository $branch)
	for arch in $(archs_for_package $package); do
	    file=$FLAGS_DIR/$repository/$branch/$arch/$package
	    mkdir -p ${file%/*}
	    if [ -n "$dry_run" ]; then
		echo \
		touch $file
	    else
		log "flag $branch $arch $package"
		touch $file
	    fi
	done
    done
}

update_sources() {
    local updated
    for commit in $COMMITS_DIR/*/*; do
	set -- $(IFS=/ ; echo ${commit#$COMMITS_DIR/})
	repository=$1
	branch=$2

	[ -d $CVS_DIR/$repository/$branch ] || continue

	cvs_update $repository $branch && updated=1
	tar_up $repository $branch
	update_flags $repository $branch
	[ -z "$dry_run" ] && rm -f $commit
    done

    [ -z updated ] && exit 1
}

package_build_status() {
    local package=$1 dist=$2 branch=$3
    local job jobid
    
    for job in $MBUILD_DIR/$JOBS_HOST-$JOBS_LOGNAME-*; do
	jobid=${job#$MBUILD_DIR/}

	unset MBUILD_PACKAGE_NAME MBUILD_DISTS
	source $MBUILD_DIR/$jobid/.mbuildinfo

	[ $package = "$MBUILD_PACKAGE_NAME" -a \
	  $branch = "$(branch_of_job $jobid)" ] \
	    || continue
	case " $MBUILD_DISTS " in
	    *" $dist "*) ;;
	    *) continue ;;
	esac

	if [ -f $job/$dist/lock ]; then
	    echo building
	    return
	elif [ -f $job/$dist/lastrun ]; then
	    if [ -f $job/$dist/.mbuild_aborted ]; then
		echo aborted
		return
	    elif [ -f $job/$dist/.mbuild_failed ]; then
		echo failed
		return
	    else
		echo succeeded
		return
	    fi
	else
	    if [ -f $MBUILD_TOBUILD_DIR/$dist/$jobid ]; then
		echo queued
		return
	    else
		echo aborted
		return
	    fi
	fi
	break  # we don't start more than one job at once...
    done
    echo none
}

queue_job() {
    local repository=$1 branch=$2 arch=$3 package=$4
    local dist=${dist_base:+$dist_base-}$arch

    (   cd $CVS_DIR/$repository/$branch/kernel-source
	if [ -z "$dry_run" ]; then
	    message="$(
		    sudo $MBUILD --logname $JOBS_LOGNAME --dist $dist $package.spec
	    )"
	    jobid=$(echo "$message" | sed -ne "s/.*jobid is '\\(.*\\)'.*/\1/p")
	    log "queue $jobid $branch $dist $package"
	else
	    echo \
	    sudo $MBUILD --logname $JOBS_LOGNAME --dist $dist $package.spec
	fi
    )
}

start_jobs() {
    for job in $FLAGS_DIR/*/*/*/*; do
	set -- $(IFS=/ ; echo ${job#$FLAGS_DIR/})

	repository=$1
	branch=$2
	arch=$3
	package=$4

	if [ -n "$include_archs" ]; then
	    case " $include_archs " in
		*" $arch "*) ;;
		*) continue ;;
	    esac
	fi

	if [ -n "$exclude_archs" ]; then
	    case " $exclude_archs " in
		*" $arch "*) continue ;;
	    esac
	fi

	if [ -n "$include_packages" ]; then
	    case " $include_packages " in
		*" $package "*) ;;
		*)	continue ;;
	    esac
	fi

	if [ -n "$exclude_packages" ]; then
	    case " $exclude_packages " in
		*" $package "*) continue ;;
	    esac
	fi

	if [ -n "$BRANCHES" ]; then
	    case " $BRANCHES " in
		*" $branch "*) ;;
		*) continue ;;
	    esac
	fi

	dist_base=$(dist_base_for_repo $repository $branch)
	dist=${dist_base:+$dist_base-}$arch
	status=$(package_build_status $package $dist $branch)
	case "$status" in
	    none)   queue_job $repository $branch $arch $package
		    status=queuing ;;
	    *)	    continue ;;
	esac
	#echo "[$branch] ${dist_base:+$dist_base-}$arch $package: $status"

	if [ -z "$dry_run" ]; then
	    rm -f $job
	fi
    done
}

finalize_job() {
    local jobid=$1 package=$2 arch=$3 branch=$4
    local dist=${dist_base:+$dist_base-}$arch
    local status pkg ext base

    status=$(package_build_status $package $dist $branch)
    log "finalize $jobid $branch $dist $package"
    case "$status" in
	succeeded)
	    # sync logfile and resulting packages to repository
	    tmpdir=$(mktemp -d /tmp/${0##*/}.XXXXXX)
	    add_exit_handler "rm -rf $tmpdir"
	    pushd $tmpdir > /dev/null
	    mkdir -p $dist/$branch
	    for pkg in $MBUILD_DIR/$jobid/$dist/$package-*.rpm; do
		ext=$(IFS=.; set -- $pkg; shift $(($#-2)); echo "$*")
		base=${pkg%.$ext}
		cp -p $pkg $dist/$branch/
		ln -s ${pkg##*/} $dist/$branch/$package.$ext
	    done
	    if [ -n "$base" ]; then
		gzip -c9 $MBUILD_DIR/$jobid/$dist/Logfile.$package.spec \
		    > $dist/$branch/${base##*/}.log.gz
	    fi
	    if [ -n "$dry_run" ]; then
		echo \
		rsync -rR4a $dist $RSYNC_DEST
		echo \
		sudo $MBUILD -r $jobid
	    else	
		rsync -rR4a $dist $RSYNC_DEST
		sudo $MBUILD -r $jobid
	    fi
	    popd > /dev/null
	    remove_exit_handler "rm -rf $tmpdir"
	    rm -rf $tmpdir
	    ;;
    esac
}

finalize_jobs() {
    for job in $MBUILD_DIR/$JOBS_HOST-$JOBS_LOGNAME-*; do
	jobid=${job#$MBUILD_DIR/}

	unset MBUILD_PACKAGE_NAME MBUILD_DISTS
	source $MBUILD_DIR/$jobid/.mbuildinfo

	package=$MBUILD_PACKAGE_NAME
	branch=$(branch_of_job $jobid)

	for dist in $MBUILD_DISTS; do
	    case $dist in
		*-*)    arch=${dist##*-}
			dist_base=${dist%-*} ;;
		*)	    arch=$dist
			dist_base= ;;
	    esac
	    
	    if [ -n "$include_archs" ]; then
		case " $include_archs " in
		    *" $arch "*) ;;
		    *) continue ;;
		esac
	    fi

	    if [ -n "$exclude_archs" ]; then
		case " $exclude_archs " in
		    *" $arch "*) continue ;;
		esac
	    fi

	    if [ -n "$include_packages" ]; then
		case " $include_packages " in
		    *" $package "*) ;;
		    *)  continue ;;
		esac
	    fi

	    if [ -n "$exclude_packages" ]; then
		case " $exclude_packages " in
		    *" $package "*) continue ;;
		esac
	    fi

	    if [ -n "$BRANCHES" ]; then
		case " $BRANCHES " in
		    *" $branch "*) ;;
		    *) continue ;;
		esac
	    fi

	    finalize_job $jobid $package $arch $branch
	done
    done
}

result_mail() {
    local to=$1 tmp subject jobid branch

    tmp=$(mktemp /tmp/${0##*/})
    add_exit_handler "rm -f $tmp"
    cat > $tmp

    subject="$(formail -cx Subject < $tmp)"
    subject=${subject# }
    jobid=$(echo "$subject" | sed -e 's/^\[mbuild //' -e 's/\].*//')
    branch=$(branch_of_job $jobid)

    subject=$(echo "$subject" | sed -e 's/\[.*\]/\[cvs build\] '"$branch"'/')
    formail -I "Subject: $subject" -I "To:" \
	-I "From: $JOBS_LOGNAME@$(hostname -d) (Kernel Build Daemon)" \
	-I "To: $to" < $tmp
    rm -f $tmp
    remove_exit_handler "rm -f $tmp"
}

lock() {
    local status pid hostname

    if [ -e $LOCKFILE ]; then
	IFS=@ read pid hostname < $LOCKFILE
	if [ "$hostname" = $(hostname) -a ! -d /proc/$pid ]; then
	    echo "Removing stale lockfile $LOCKFILE" >&2
	    rm -f $LOCKFILE
	fi
    fi

    set -o noclobber
    echo $$@$(hostname) 2> /dev/null > $LOCKFILE
    status=$?
    set +o noclobber
    return $status
}

unlock() {
    rm -f $LOCKFILE
}

options=`getopt -o n --long dry-run,include-arch:,exclude-arch:,branch: \
		     --long include:,exclude:,trace -- "$@"`

if [ $? -ne 0 ]
then
    usage
fi

eval set -- "$options"

while true; do
    case "$1" in
	--trace)
	    set -x ;;
	--dry-run|-n)
	    dry_run=1 ;;
	--include-arch)
	    include_archs="$include_archs $2"
	    shift ;;
	--exclude-arch)
	    exclude_archs="$exclude_archs $2"
	    shift ;;
	--branch)
	    BRANCHES="$BRANCHES $2"
	    shift ;;
	--include)
	    include_packages="$include_packages $2"
	    shift ;;
	--exclude)
	    exclude_packages="$exclude_packages $2"
	    shift ;;
	--)
	    shift
	    break ;;
	*)
	    usage ;;
    esac
    shift
done

if [ $# -eq 0 ]
then
    usage
fi

case "$1" in
    update|start|finalize)
	start_ts=$(date "+%s")
	while ! lock; do
	    elapsed=$(( $(date "+%s") - $start_ts ))
	    if [ $elapsed -gt $LOCK_TIMEOUT ]; then
		echo "lock contention -- giving up" >&2
		exit 1
	    fi
	    sleep 1
	done
	add_exit_handler "unlock"
esac

while [ $# -gt 0 ]; do
    case "$1" in
	update)		update_sources ;;
	start)		start_jobs ;;
	finalize)	finalize_jobs ;;
	resmail)	[ $# -gt 1 ] || usage
			result_mail "$2"
			shift ;;
	*)		usage ;;
    esac
    shift
done

