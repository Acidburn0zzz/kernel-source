From slert-devel-bounces+sdietrich=novell.com@suse.de Fri Feb 15 18:52:37 2008
Return-path: <slert-devel-bounces+sdietrich=novell.com@suse.de>
Received: from Relay1.suse.de ([149.44.160.87]) by emea5-mh.id5.novell.com
	with ESMTP (TLS encrypted); Fri, 15 Feb 2008 18:52:37 +0100
Received: from Fourier.suse.de (fourier.suse.de [149.44.160.40]) by
	Relay1.suse.de (Postfix) with ESMTP id A7FE21C052AE for
	<sdietrich@novell.com>; Fri, 15 Feb 2008 18:52:37 +0100 (CET)
Received: from fourier.suse.de (localhost [127.0.0.1]) by Fourier.suse.de
	(Postfix) with ESMTP id A36631E4276D for <sdietrich@novell.com>; Fri, 15
	Feb 2008 18:52:37 +0100 (CET)
Received: from Relay1.suse.de (relay1.suse.de [149.44.160.87]) by
	Fourier.suse.de (Postfix) with ESMTP id E14971E4276D for
	<slert-devel@mailman.suse.de>; Fri, 15 Feb 2008 18:52:36 +0100 (CET)
Received: by Relay1.suse.de (Postfix) id DF4E71C052AA; Fri, 15 Feb 2008
	18:52:36 +0100 (CET)
Received: from relay1.suse.de (localhost [127.0.0.1]) by Relay1.suse.de
	(Postfix) with ESMTP id D457B1C052A9 for <slert-devel@suse.de>; Fri, 15 Feb
	2008 18:52:36 +0100 (CET)
X-Virus-Scanned: by amavisd-new at relay1.suse.de
X-Spam-Score: -2.499
X-Spam-Level: 
X-Spam-Status: No, score=-2.499 tagged_above=-20 required=5
	tests=[BAYES_00=-2.599, RDNS_DYNAMIC=0.1]
Received: from mx1.suse.de ([195.135.220.2]) by relay1.suse.de
	(relay1.suse.de [149.44.160.87]) (amavisd-new, port 10025) with ESMTP id
	CxbahoXlQ1IP for <slert-devel@suse.de>; Fri, 15 Feb 2008 18:52:30 +0100
	(CET)
Received: from novell1.haskins.net (75-130-111-13.dhcp.oxfr.ma.charter.com
	[75.130.111.13]) by mx1.suse.de (Postfix) with ESMTP id 5FC5E2D513 for
	<slert-devel@suse.de>; Fri, 15 Feb 2008 18:52:30 +0100 (CET)
Received: from novell1.haskins.net (localhost [127.0.0.1]) by
	novell1.haskins.net (Postfix) with ESMTP id 94C733FC1DD for
	<slert-devel@suse.de>; Fri, 15 Feb 2008 12:25:43 -0500 (EST)
From: Gregory Haskins <ghaskins@novell.com>
To: slert-devel@suse.de
Date: Fri, 15 Feb 2008 12:25:43 -0500
Message-ID: <20080215172543.25573.49705.stgit@novell1.haskins.net>
In-Reply-To: <20080215172421.25573.85164.stgit@novell1.haskins.net>
References: <20080215172421.25573.85164.stgit@novell1.haskins.net>
User-Agent: StGIT/0.12.1
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Subject: [slert-devel] [PATCH 02/10] rearrange rtspinlock sleep
X-BeenThere: slert-devel@suse.de
X-Mailman-Version: 2.1.4
Precedence: list
List-Id: All things slert <slert-devel.suse.de>
List-Unsubscribe: <https://mailman.suse.de/mailman/listinfo/slert-devel>,
	<mailto:slert-devel-request@suse.de?subject=unsubscribe>
List-Archive: <https://mailman.suse.de/mailman/private/slert-devel>
List-Post: <mailto:slert-devel@suse.de>
List-Help: <mailto:slert-devel-request@suse.de?subject=help>
List-Subscribe: <https://mailman.suse.de/mailman/listinfo/slert-devel>,
	<mailto:slert-devel-request@suse.de?subject=subscribe>
Sender: slert-devel-bounces+sdietrich=novell.com@suse.de
Errors-To: slert-devel-bounces+sdietrich=novell.com@suse.de
X-Evolution-Source: imap://sdietrich@prv1-3.novell.com/
Content-Transfer-Encoding: 8bit

The current logic makes rather coarse adjustments to current->state since
it is planning on sleeping anyway.  We want to eventually move to an
adaptive (e.g. optional sleep) algorithm, so we tighten the scope of the
adjustments to bracket the schedule().  This should yield correct behavior
with or without the adaptive features that are added later in the series.
We add it here as a separate patch for greater review clarity on smaller
changes.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---

 kernel/rtmutex.c |   20 +++++++++++++++-----
 1 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index a2b00cc..15fc6e6 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -661,6 +661,14 @@ rt_spin_lock_fastunlock(struct rt_mutex *lock,
 		slowfn(lock);
 }
 
+static inline void
+update_current(unsigned long new_state, unsigned long *saved_state)
+{
+	unsigned long state = xchg(&current->state, new_state);
+	if (unlikely(state == TASK_RUNNING))
+		*saved_state = TASK_RUNNING;
+}
+
 /*
  * Slow path lock function spin_lock style: this variant is very
  * careful not to miss any non-lock wakeups.
@@ -700,7 +708,8 @@ rt_spin_lock_slowlock(struct rt_mutex *lock)
 	 * saved_state accordingly. If we did not get a real wakeup
 	 * then we return with the saved state.
 	 */
-	saved_state = xchg(&current->state, TASK_UNINTERRUPTIBLE);
+	saved_state = current->state;
+	smp_mb();
 
 	for (;;) {
 		unsigned long saved_flags;
@@ -732,14 +741,15 @@ rt_spin_lock_slowlock(struct rt_mutex *lock)
 
 		debug_rt_mutex_print_deadlock(&waiter);
 
-		schedule_rt_mutex(lock);
+		update_current(TASK_UNINTERRUPTIBLE, &saved_state);
+		if (waiter.task)
+			schedule_rt_mutex(lock);
+		else
+			update_current(TASK_RUNNING_MUTEX, &saved_state);
 
 		spin_lock_irqsave(&lock->wait_lock, flags);
 		current->flags |= saved_flags;
 		current->lock_depth = saved_lock_depth;
-		state = xchg(&current->state, TASK_UNINTERRUPTIBLE);
-		if (unlikely(state == TASK_RUNNING))
-			saved_state = TASK_RUNNING;
 	}
 
 	state = xchg(&current->state, saved_state);

