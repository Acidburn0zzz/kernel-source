From ghaskins@novell.com Wed Feb 13 16:37:13 2008
Return-path: <ghaskins@novell.com>
Received: from adonis.novell.com (adonis.provo.novell.com [130.57.1.97]) by
	sinclair.provo.novell.com with ESMTP; Wed, 13 Feb 2008 16:37:13 -0700
Received: from novell1.haskins.net (75-130-111-13.dhcp.oxfr.ma.charter.com
	[75.130.111.13]) by adonis.novell.com (TMA SMTPRS 4.4.568.30) with ESMTP id
	<C0131301049@adonis.novell.com>; Wed, 13 Feb 2008 16:37:06 -0700
Received-SPF: none (adonis.novell.com: domain of ghaskins@novell.com does
	not designate any permitted senders)
X-IADB2: None
X-Bonded-Senders: None
X-Habeas: None
X-Cloudmark-Rating: 0 <127.0.50.0>
X-IDDB: None
X-Modus-ReverseDNS: OK
X-Modus-BlackList: 75.130.111.13=OK;ghaskins@novell.com=OK
X-Modus-RBL: 75.130.111.13=OK
X-Modus-Trusted: 75.130.111.13=NO
X-Modus-Audit: FALSE;0;0;0
Received: from novell1.haskins.net (localhost [127.0.0.1]) by
	novell1.haskins.net (Postfix) with ESMTP id 3B4583FC1D7; Wed, 13 Feb 2008
	18:10:51 -0500 (EST)
From: Gregory Haskins <ghaskins@novell.com>
Subject: [PATCH 1/9] cleanup rtspinlock sleep
To: pmorreale@novell.com, sdietrich@novell.com
Cc: ghaskins@novell.com
Date: Wed, 13 Feb 2008 18:10:51 -0500
Message-ID: <20080213231050.4771.91822.stgit@novell1.haskins.net>
In-Reply-To: <20080213230912.4771.22530.stgit@novell1.haskins.net>
References: <20080213230912.4771.22530.stgit@novell1.haskins.net>
User-Agent: StGIT/0.12.1
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
X-Evolution-Source: imap://sdietrich@prv1-3.novell.com/
Content-Transfer-Encoding: 8bit

In preparation of adaptive locking later in the series

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---

 kernel/rtmutex.c |   20 +++++++++++++++-----
 1 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index a2b00cc..15fc6e6 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -661,6 +661,14 @@ rt_spin_lock_fastunlock(struct rt_mutex *lock,
 		slowfn(lock);
 }
 
+static inline void
+update_current(unsigned long new_state, unsigned long *saved_state)
+{
+	unsigned long state = xchg(&current->state, new_state);
+	if (unlikely(state == TASK_RUNNING))
+		*saved_state = TASK_RUNNING;
+}
+
 /*
  * Slow path lock function spin_lock style: this variant is very
  * careful not to miss any non-lock wakeups.
@@ -700,7 +708,8 @@ rt_spin_lock_slowlock(struct rt_mutex *lock)
 	 * saved_state accordingly. If we did not get a real wakeup
 	 * then we return with the saved state.
 	 */
-	saved_state = xchg(&current->state, TASK_UNINTERRUPTIBLE);
+	saved_state = current->state;
+	smp_mb();
 
 	for (;;) {
 		unsigned long saved_flags;
@@ -732,14 +741,15 @@ rt_spin_lock_slowlock(struct rt_mutex *lock)
 
 		debug_rt_mutex_print_deadlock(&waiter);
 
-		schedule_rt_mutex(lock);
+		update_current(TASK_UNINTERRUPTIBLE, &saved_state);
+		if (waiter.task)
+			schedule_rt_mutex(lock);
+		else
+			update_current(TASK_RUNNING_MUTEX, &saved_state);
 
 		spin_lock_irqsave(&lock->wait_lock, flags);
 		current->flags |= saved_flags;
 		current->lock_depth = saved_lock_depth;
-		state = xchg(&current->state, TASK_UNINTERRUPTIBLE);
-		if (unlikely(state == TASK_RUNNING))
-			saved_state = TASK_RUNNING;
 	}
 
 	state = xchg(&current->state, saved_state);

