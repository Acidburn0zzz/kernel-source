Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
Subject: This patch should solve some of the bug messages.

From: Chirag Jog <chirag@linux.vnet.ibm.com>

It does two things:
1. Change rt_runtime_lock to be a raw spinlock as the comment above it
says: it is nested inside the rq lock.

2. Change mnt_writers to be a per_cpu locked variable.
This eliminates the need for the codepath to disable preemption and
then potentially sleep, leading to the BUG messages

Signed-Off-By: Chirag <chirag@linux.vnet.ibm.com>
Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---

 fs/namespace.c |   22 +++++++++++-----------
 kernel/sched.c |    4 ++--
 2 files changed, 13 insertions(+), 13 deletions(-)


diff --git a/fs/namespace.c b/fs/namespace.c
index 4fc302c..89d63a3 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -178,13 +178,13 @@ struct mnt_writer {
 	unsigned long count;
 	struct vfsmount *mnt;
 } ____cacheline_aligned_in_smp;
-static DEFINE_PER_CPU(struct mnt_writer, mnt_writers);
+static DEFINE_PER_CPU_LOCKED(struct mnt_writer, mnt_writers);
 
 static int __init init_mnt_writers(void)
 {
 	int cpu;
 	for_each_possible_cpu(cpu) {
-		struct mnt_writer *writer = &per_cpu(mnt_writers, cpu);
+		struct mnt_writer *writer = &per_cpu_var_locked(mnt_writers, cpu);
 		spin_lock_init(&writer->lock);
 		lockdep_set_class(&writer->lock, &writer->lock_class);
 		writer->count = 0;
@@ -199,7 +199,7 @@ static void unlock_mnt_writers(void)
 	struct mnt_writer *cpu_writer;
 
 	for_each_possible_cpu(cpu) {
-		cpu_writer = &per_cpu(mnt_writers, cpu);
+		cpu_writer = &per_cpu_var_locked(mnt_writers, cpu);
 		spin_unlock(&cpu_writer->lock);
 	}
 }
@@ -251,8 +251,8 @@ int mnt_want_write(struct vfsmount *mnt)
 {
 	int ret = 0;
 	struct mnt_writer *cpu_writer;
-
-	cpu_writer = &get_cpu_var(mnt_writers);
+	int cpu = 0;
+	cpu_writer = &get_cpu_var_locked(mnt_writers, &cpu);
 	spin_lock(&cpu_writer->lock);
 	if (__mnt_is_readonly(mnt)) {
 		ret = -EROFS;
@@ -262,7 +262,7 @@ int mnt_want_write(struct vfsmount *mnt)
 	cpu_writer->count++;
 out:
 	spin_unlock(&cpu_writer->lock);
-	put_cpu_var(mnt_writers);
+	put_cpu_var_locked(mnt_writers, cpu);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(mnt_want_write);
@@ -273,7 +273,7 @@ static void lock_mnt_writers(void)
 	struct mnt_writer *cpu_writer;
 
 	for_each_possible_cpu(cpu) {
-		cpu_writer = &per_cpu(mnt_writers, cpu);
+		cpu_writer = &per_cpu_var_locked(mnt_writers, cpu);
 		spin_lock(&cpu_writer->lock);
 		__clear_mnt_count(cpu_writer);
 		cpu_writer->mnt = NULL;
@@ -332,8 +332,8 @@ void mnt_drop_write(struct vfsmount *mnt)
 {
 	int must_check_underflow = 0;
 	struct mnt_writer *cpu_writer;
-
-	cpu_writer = &get_cpu_var(mnt_writers);
+	int cpu = 0;
+	cpu_writer = &get_cpu_var_locked(mnt_writers, &cpu);
 	spin_lock(&cpu_writer->lock);
 
 	use_cpu_writer_for_mount(cpu_writer, mnt);
@@ -360,7 +360,7 @@ void mnt_drop_write(struct vfsmount *mnt)
 	 * __mnt_writers can underflow.  Without it,
 	 * we could theoretically wrap __mnt_writers.
 	 */
-	put_cpu_var(mnt_writers);
+	put_cpu_var_locked(mnt_writers, cpu);
 }
 EXPORT_SYMBOL_GPL(mnt_drop_write);
 
@@ -612,7 +612,7 @@ static inline void __mntput(struct vfsmount *mnt)
 	 * can come in.
 	 */
 	for_each_possible_cpu(cpu) {
-		struct mnt_writer *cpu_writer = &per_cpu(mnt_writers, cpu);
+		struct mnt_writer *cpu_writer = &per_cpu_var_locked(mnt_writers, cpu);
 		if (cpu_writer->mnt != mnt)
 			continue;
 		spin_lock(&cpu_writer->lock);
diff --git a/kernel/sched.c b/kernel/sched.c
index 0b84467..54ea580 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -208,7 +208,7 @@ struct rt_prio_array {
 
 struct rt_bandwidth {
 	/* nests inside the rq lock: */
-	spinlock_t		rt_runtime_lock;
+	raw_spinlock_t		rt_runtime_lock;
 	ktime_t			rt_period;
 	u64			rt_runtime;
 	struct hrtimer		rt_period_timer;
@@ -472,7 +472,7 @@ struct rt_rq {
 	u64 rt_time;
 	u64 rt_runtime;
 	/* Nests inside the rq lock: */
-	spinlock_t rt_runtime_lock;
+	raw_spinlock_t rt_runtime_lock;
 
 #ifdef CONFIG_RT_GROUP_SCHED
 	unsigned long rt_nr_boosted;
