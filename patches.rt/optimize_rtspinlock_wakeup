From ghaskins@novell.com Wed Feb 13 16:37:18 2008
Return-path: <ghaskins@novell.com>
Received: from AMPHION.novell.com ([130.57.1.22]) by
	sinclair.provo.novell.com with ESMTP; Wed, 13 Feb 2008 16:37:18 -0700
Received: from novell1.haskins.net (75-130-111-13.dhcp.oxfr.ma.charter.com
	[75.130.111.13]) by AMPHION.novell.com (TMA SMTPRS 4.4.568.54) with ESMTP
	id <D0131823762@AMPHION.novell.com>; Wed, 13 Feb 2008 16:37:04 -0700
Received-SPF: none (AMPHION.novell.com: domain of ghaskins@novell.com does
	not designate any permitted senders)
X-IADB2: None
X-Bonded-Senders: None
X-Habeas: None
X-Cloudmark-Rating: 0 <127.0.50.0>
X-IDDB: None
X-Modus-ReverseDNS: OK
X-Modus-BlackList: 75.130.111.13=OK;ghaskins@novell.com=OK
X-Modus-RBL: 75.130.111.13=OK
X-Modus-Trusted: 75.130.111.13=NO
X-Modus-Audit: FALSE;0;0;0
Received: from novell1.haskins.net (localhost [127.0.0.1]) by
	novell1.haskins.net (Postfix) with ESMTP id 88A8D3FC1D7; Wed, 13 Feb 2008
	18:10:56 -0500 (EST)
From: Gregory Haskins <ghaskins@novell.com>
Subject: [PATCH 2/9] optimize rtspinlock wakeup
To: pmorreale@novell.com, sdietrich@novell.com
Cc: ghaskins@novell.com
Date: Wed, 13 Feb 2008 18:10:56 -0500
Message-ID: <20080213231056.4771.72151.stgit@novell1.haskins.net>
In-Reply-To: <20080213230912.4771.22530.stgit@novell1.haskins.net>
References: <20080213230912.4771.22530.stgit@novell1.haskins.net>
User-Agent: StGIT/0.12.1
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
X-Evolution-Source: imap://sdietrich@prv1-3.novell.com/
Content-Transfer-Encoding: 8bit

It is redundant to wake the grantee task if it is already running

Credit goes to Peter for the general idea.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
Signed-off-by: Peter Morreale <pmorreale@novell.com>
---

 kernel/rtmutex.c |   23 ++++++++++++++++++-----
 1 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index 15fc6e6..cb27b08 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -511,6 +511,24 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 	pendowner = waiter->task;
 	waiter->task = NULL;
 
+	/*
+	 * Do the wakeup before the ownership change to give any spinning
+	 * waiter grantees a headstart over the other threads that will
+	 * trigger once owner changes.
+	 */
+	if (!savestate)
+		wake_up_process(pendowner);
+	else {
+		smp_mb();
+		/*
+		 * This may appear to be a race, but the barriers close the
+		 * window.
+		 */
+		if ((pendowner->state != TASK_RUNNING)
+		    && (pendowner->state != TASK_RUNNING_MUTEX))
+			wake_up_process_mutex(pendowner);
+	}
+
 	rt_mutex_set_owner(lock, pendowner, RT_MUTEX_OWNER_PENDING);
 
 	spin_unlock(&current->pi_lock);
@@ -537,11 +555,6 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 		plist_add(&next->pi_list_entry, &pendowner->pi_waiters);
 	}
 	spin_unlock(&pendowner->pi_lock);
-
-	if (savestate)
-		wake_up_process_mutex(pendowner);
-	else
-		wake_up_process(pendowner);
 }
 
 /*

