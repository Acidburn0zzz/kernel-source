From slert-devel-bounces+sdietrich=novell.com@suse.de Fri Feb 15 18:52:49 2008
Return-path: <slert-devel-bounces+sdietrich=novell.com@suse.de>
Received: from Relay1.suse.de ([149.44.160.87]) by emea5-mh.id5.novell.com
	with ESMTP (TLS encrypted); Fri, 15 Feb 2008 18:52:49 +0100
Received: from Fourier.suse.de (fourier.suse.de [149.44.160.40]) by
	Relay1.suse.de (Postfix) with ESMTP id 789611C052A8 for
	<sdietrich@novell.com>; Fri, 15 Feb 2008 18:52:49 +0100 (CET)
Received: from fourier.suse.de (localhost [127.0.0.1]) by Fourier.suse.de
	(Postfix) with ESMTP id 6FEED1E42776 for <sdietrich@novell.com>; Fri, 15
	Feb 2008 18:52:49 +0100 (CET)
Received: from Relay2.suse.de (relay2.suse.de [149.44.160.89]) by
	Fourier.suse.de (Postfix) with ESMTP id 960131E4277C for
	<slert-devel@mailman.suse.de>; Fri, 15 Feb 2008 18:52:48 +0100 (CET)
Received: by Relay2.suse.de (Postfix) id 939CD1C4C34D; Fri, 15 Feb 2008
	18:52:48 +0100 (CET)
Received: from relay2.suse.de (localhost [127.0.0.1]) by Relay2.suse.de
	(Postfix) with ESMTP id 88E2E1C4C34A for <slert-devel@suse.de>; Fri, 15 Feb
	2008 18:52:48 +0100 (CET)
X-Virus-Scanned: by amavisd-new at relay2.suse.de
X-Spam-Score: -2.499
X-Spam-Level: 
X-Spam-Status: No, score=-2.499 tagged_above=-20 required=5
	tests=[BAYES_00=-2.599, RDNS_DYNAMIC=0.1]
Received: from mx2.suse.de ([195.135.220.15]) by relay2.suse.de
	(relay2.suse.de [149.44.160.89]) (amavisd-new, port 10025) with ESMTP id
	7d6Tstww3Mex for <slert-devel@suse.de>; Fri, 15 Feb 2008 18:52:41 +0100
	(CET)
Received: from novell1.haskins.net (75-130-111-13.dhcp.oxfr.ma.charter.com
	[75.130.111.13]) by mx2.suse.de (Postfix) with ESMTP id B094A35708 for
	<slert-devel@suse.de>; Fri, 15 Feb 2008 18:52:41 +0100 (CET)
Received: from novell1.haskins.net (localhost [127.0.0.1]) by
	novell1.haskins.net (Postfix) with ESMTP id D3AAE3FC1EE for
	<slert-devel@suse.de>; Fri, 15 Feb 2008 12:25:48 -0500 (EST)
From: Gregory Haskins <ghaskins@novell.com>
To: slert-devel@suse.de
Date: Fri, 15 Feb 2008 12:25:48 -0500
Message-ID: <20080215172548.25573.18333.stgit@novell1.haskins.net>
In-Reply-To: <20080215172421.25573.85164.stgit@novell1.haskins.net>
References: <20080215172421.25573.85164.stgit@novell1.haskins.net>
User-Agent: StGIT/0.12.1
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Subject: [slert-devel] [PATCH 03/10] optimize rtspinlock wakeup
X-BeenThere: slert-devel@suse.de
X-Mailman-Version: 2.1.4
Precedence: list
List-Id: All things slert <slert-devel.suse.de>
List-Unsubscribe: <https://mailman.suse.de/mailman/listinfo/slert-devel>,
	<mailto:slert-devel-request@suse.de?subject=unsubscribe>
List-Archive: <https://mailman.suse.de/mailman/private/slert-devel>
List-Post: <mailto:slert-devel@suse.de>
List-Help: <mailto:slert-devel-request@suse.de?subject=help>
List-Subscribe: <https://mailman.suse.de/mailman/listinfo/slert-devel>,
	<mailto:slert-devel-request@suse.de?subject=subscribe>
Sender: slert-devel-bounces+sdietrich=novell.com@suse.de
Errors-To: slert-devel-bounces+sdietrich=novell.com@suse.de
X-Evolution-Source: imap://sdietrich@prv1-3.novell.com/
Content-Transfer-Encoding: 8bit

It is redundant to wake the grantee task if it is already running

Credit goes to Peter for the general idea.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
Signed-off-by: Peter Morreale <pmorreale@novell.com>
---

 kernel/rtmutex.c |   23 ++++++++++++++++++-----
 1 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index 15fc6e6..cb27b08 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -511,6 +511,24 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 	pendowner = waiter->task;
 	waiter->task = NULL;
 
+	/*
+	 * Do the wakeup before the ownership change to give any spinning
+	 * waiter grantees a headstart over the other threads that will
+	 * trigger once owner changes.
+	 */
+	if (!savestate)
+		wake_up_process(pendowner);
+	else {
+		smp_mb();
+		/*
+		 * This may appear to be a race, but the barriers close the
+		 * window.
+		 */
+		if ((pendowner->state != TASK_RUNNING)
+		    && (pendowner->state != TASK_RUNNING_MUTEX))
+			wake_up_process_mutex(pendowner);
+	}
+
 	rt_mutex_set_owner(lock, pendowner, RT_MUTEX_OWNER_PENDING);
 
 	spin_unlock(&current->pi_lock);
@@ -537,11 +555,6 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 		plist_add(&next->pi_list_entry, &pendowner->pi_waiters);
 	}
 	spin_unlock(&pendowner->pi_lock);
-
-	if (savestate)
-		wake_up_process_mutex(pendowner);
-	else
-		wake_up_process(pendowner);
 }
 
 /*

