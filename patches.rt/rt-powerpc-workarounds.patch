Subject: Linux-RT 2.6.24-rc2-rt1
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
From paulmck@linux.vnet.ibm.com Mon Oct 29 15:03:22 2007
Date: Mon, 29 Oct 2007 11:50:44 -0700
From: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
To: linux-kernel@vger.kernel.org
Cc: tony@bakeyournoodle.com, paulus@samba.org, benh@kernel.crashing.org,
     dino@in.ibm.com, tytso@us.ibm.com, dvhltc@us.ibm.com, antonb@us.ibm.com,
     rostedt@goodmis.org
Subject: [PATCH, RFC] hacks to allow -rt to run kernbench on POWER

Hello!

A few random patches that permit POWER to pass kernbench on -rt.
Many of these have more focus on expediency than care for correctness,
so might best be thought of as workarounds than as complete solutions.
There are still issues not addressed by this patch, including:

o	kmem_cache_alloc() from non-preemptible context during
	bootup (xics_startup() building the irq_radix_revmap()).

o	unmap_vmas() freeing pages with preemption disabled.
	Might be able to address this by linking the pages together,
	then freeing them en masse after preemption has been re-enabled,
	but there is likely a better approach.

Thoughts?

Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
---

 arch/powerpc/kernel/prom.c           |    2 +-
 arch/powerpc/mm/fault.c              |    3 +++
 arch/powerpc/mm/tlb_64.c             |    8 ++++++--
 arch/powerpc/platforms/pseries/eeh.c |    2 +-
 drivers/of/base.c                    |    2 +-
 include/asm-powerpc/tlb.h            |    5 ++++-
 include/asm-powerpc/tlbflush.h       |    5 ++++-
 mm/memory.c                          |    2 ++
 8 files changed, 22 insertions(+), 7 deletions(-)

Index: linux-2.6.23.1-rt6/arch/powerpc/kernel/prom.c
===================================================================
--- linux-2.6.23.1-rt6.orig/arch/powerpc/kernel/prom.c
+++ linux-2.6.23.1-rt6/arch/powerpc/kernel/prom.c
@@ -80,7 +80,7 @@ struct boot_param_header *initial_boot_p
 
 extern struct device_node *allnodes;	/* temporary while merging */
 
-extern rwlock_t devtree_lock;	/* temporary while merging */
+extern raw_rwlock_t devtree_lock;	/* temporary while merging */
 
 /* export that to outside world */
 struct device_node *of_chosen;
Index: linux-2.6.23.1-rt6/arch/powerpc/mm/fault.c
===================================================================
--- linux-2.6.23.1-rt6.orig/arch/powerpc/mm/fault.c
+++ linux-2.6.23.1-rt6/arch/powerpc/mm/fault.c
@@ -301,6 +301,7 @@ good_area:
 		if (get_pteptr(mm, address, &ptep, &pmdp)) {
 			spinlock_t *ptl = pte_lockptr(mm, pmdp);
 			spin_lock(ptl);
+			preempt_disable();
 			if (pte_present(*ptep)) {
 				struct page *page = pte_page(*ptep);
 
@@ -310,10 +311,12 @@ good_area:
 				}
 				pte_update(ptep, 0, _PAGE_HWEXEC);
 				_tlbie(address);
+				preempt_enable();
 				pte_unmap_unlock(ptep, ptl);
 				up_read(&mm->mmap_sem);
 				return 0;
 			}
+			preempt_enable();
 			pte_unmap_unlock(ptep, ptl);
 		}
 #endif
Index: linux-2.6.23.1-rt6/arch/powerpc/mm/tlb_64.c
===================================================================
--- linux-2.6.23.1-rt6.orig/arch/powerpc/mm/tlb_64.c
+++ linux-2.6.23.1-rt6/arch/powerpc/mm/tlb_64.c
@@ -194,7 +194,9 @@ void hpte_need_flush(struct mm_struct *m
 	 * batch
 	 */
 	if (i != 0 && (mm != batch->mm || batch->psize != psize)) {
+		preempt_disable();
 		__flush_tlb_pending(batch);
+		preempt_enable();
 		i = 0;
 	}
 	if (i == 0) {
@@ -211,7 +213,9 @@ void hpte_need_flush(struct mm_struct *m
 	 * always flush it on RT to reduce scheduling latency.
 	 */
 	if (machine_is(celleb)) {
+		preempt_disable();
 		__flush_tlb_pending(batch);
+		preempt_enable();
 		return;
 	}
 #endif /* CONFIG_PREEMPT_RT */
@@ -292,7 +296,7 @@ void __flush_hash_table_range(struct mm_
 	 * to being hashed). This is not the most performance oriented
 	 * way to do things but is fine for our needs here.
 	 */
-	local_irq_save(flags);
+	raw_local_irq_save(flags);
 	arch_enter_lazy_mmu_mode();
 	for (; start < end; start += PAGE_SIZE) {
 		pte_t *ptep = find_linux_pte(mm->pgd, start);
@@ -306,7 +310,7 @@ void __flush_hash_table_range(struct mm_
 		hpte_need_flush(mm, start, ptep, pte, 0);
 	}
 	arch_leave_lazy_mmu_mode();
-	local_irq_restore(flags);
+	raw_local_irq_restore(flags);
 }
 
 #endif /* CONFIG_HOTPLUG */
Index: linux-2.6.23.1-rt6/arch/powerpc/platforms/pseries/eeh.c
===================================================================
--- linux-2.6.23.1-rt6.orig/arch/powerpc/platforms/pseries/eeh.c
+++ linux-2.6.23.1-rt6/arch/powerpc/platforms/pseries/eeh.c
@@ -97,7 +97,7 @@ int eeh_subsystem_enabled;
 EXPORT_SYMBOL(eeh_subsystem_enabled);
 
 /* Lock to avoid races due to multiple reports of an error */
-static DEFINE_SPINLOCK(confirm_error_lock);
+static DEFINE_RAW_SPINLOCK(confirm_error_lock);
 
 /* Buffer for reporting slot-error-detail rtas calls. Its here
  * in BSS, and not dynamically alloced, so that it ends up in
Index: linux-2.6.23.1-rt6/drivers/of/base.c
===================================================================
--- linux-2.6.23.1-rt6.orig/drivers/of/base.c
+++ linux-2.6.23.1-rt6/drivers/of/base.c
@@ -25,7 +25,7 @@ struct device_node *allnodes;
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.
  */
-DEFINE_RWLOCK(devtree_lock);
+DEFINE_RAW_RWLOCK(devtree_lock);
 
 int of_n_addr_cells(struct device_node *np)
 {
Index: linux-2.6.23.1-rt6/include/asm-powerpc/tlbflush.h
===================================================================
--- linux-2.6.23.1-rt6.orig/include/asm-powerpc/tlbflush.h
+++ linux-2.6.23.1-rt6/include/asm-powerpc/tlbflush.h
@@ -118,8 +118,11 @@ static inline void arch_leave_lazy_mmu_m
 {
 	struct ppc64_tlb_batch *batch = &__get_cpu_var(ppc64_tlb_batch);
 
-	if (batch->index)
+	if (batch->index) {
+		preempt_disable();
 		__flush_tlb_pending(batch);
+		preempt_enable();
+	}
 	batch->active = 0;
 }
 
Index: linux-2.6.23.1-rt6/include/asm-powerpc/tlb.h
===================================================================
--- linux-2.6.23.1-rt6.orig/include/asm-powerpc/tlb.h
+++ linux-2.6.23.1-rt6/include/asm-powerpc/tlb.h
@@ -44,8 +44,11 @@ static inline void tlb_flush(struct mmu_
 	 * pages are going to be freed and we really don't want to have a CPU
 	 * access a freed page because it has a stale TLB
 	 */
-	if (tlbbatch->index)
+	if (tlbbatch->index) {
+		preempt_disable();
 		__flush_tlb_pending(tlbbatch);
+		preempt_enable();
+	}
 
 	pte_free_finish();
 }
Index: linux-2.6.23.1-rt6/mm/memory.c
===================================================================
--- linux-2.6.23.1-rt6.orig/mm/memory.c
+++ linux-2.6.23.1-rt6/mm/memory.c
@@ -664,6 +664,7 @@ static unsigned long zap_pte_range(struc
 	int anon_rss = 0;
 
 	pte = pte_offset_map_lock(mm, pmd, addr, &ptl);
+	preempt_disable();
 	arch_enter_lazy_mmu_mode();
 	do {
 		pte_t ptent = *pte;
@@ -732,6 +733,7 @@ static unsigned long zap_pte_range(struc
 
 	add_mm_rss(mm, file_rss, anon_rss);
 	arch_leave_lazy_mmu_mode();
+	preempt_enable();
 	pte_unmap_unlock(pte - 1, ptl);
 
 	return addr;
