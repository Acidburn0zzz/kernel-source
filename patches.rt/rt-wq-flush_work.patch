Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Tony Jones <tonyj@suse.de>
add priority support to flush_work()

The priority support for workqueues was added prior to flush_work()
existing (which was added in db70089).  The search for the barrier
insertion location used to look for the previous node, but with
plist/priority, you no longer specify an insertion point for a barrier.

---
 kernel/workqueue.c |   13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -515,8 +515,8 @@ EXPORT_SYMBOL_GPL(flush_workqueue);
 int flush_work(struct work_struct *work)
 {
 	struct cpu_workqueue_struct *cwq;
-	struct list_head *prev;
 	struct wq_barrier barr;
+	int found = 0;
 
 	might_sleep();
 	cwq = get_wq_data(work);
@@ -526,9 +526,8 @@ int flush_work(struct work_struct *work)
 	lock_map_acquire(&cwq->wq->lockdep_map);
 	lock_map_release(&cwq->wq->lockdep_map);
 
-	prev = NULL;
 	spin_lock_irq(&cwq->lock);
-	if (!list_empty(&work->entry)) {
+	if (!plist_node_empty(&work->entry)) {
 		/*
 		 * See the comment near try_to_grab_pending()->smp_rmb().
 		 * If it was re-queued under us we are not going to wait.
@@ -536,16 +535,16 @@ int flush_work(struct work_struct *work)
 		smp_rmb();
 		if (unlikely(cwq != get_wq_data(work)))
 			goto out;
-		prev = &work->entry;
+		found = 1;
 	} else {
 		if (cwq->current_work != work)
 			goto out;
-		prev = &cwq->worklist;
+		found = 1;
 	}
-	insert_wq_barrier(cwq, &barr, prev->next);
+	insert_wq_barrier(cwq, &barr);
 out:
 	spin_unlock_irq(&cwq->lock);
-	if (!prev)
+	if (!found)
 		return 0;
 
 	wait_for_completion(&barr.done);
