Subject: Linux-RT 2.6.25.4-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
---
 kernel/sched.c       |   21 ---------------------
 kernel/sched_clock.c |   22 +++++++++++++++-------
 2 files changed, 15 insertions(+), 28 deletions(-)

Index: linux-2.6.25.4-rt4/kernel/sched.c
===================================================================
--- linux-2.6.25.4-rt4.orig/kernel/sched.c	2008-05-29 09:46:06.000000000 -0400
+++ linux-2.6.25.4-rt4/kernel/sched.c	2008-05-29 09:46:06.000000000 -0400
@@ -600,27 +600,6 @@ int sysctl_sched_rt_runtime = 950000;
  */
 #define RUNTIME_INF	((u64)~0ULL)
 
-/*
- * For kernel-internal use: high-speed (but slightly incorrect) per-cpu
- * clock constructed from sched_clock():
- */
-unsigned long long notrace cpu_clock(int cpu)
-{
-	unsigned long long now;
-
-	/*
-	 * Only call sched_clock() if the scheduler has already been
-	 * initialized (some code might call cpu_clock() very early):
-	 */
-	if (unlikely(!scheduler_running))
-		return 0;
-
-	now = sched_clock_cpu(cpu);
-
-	return now;
-}
-EXPORT_SYMBOL_GPL(cpu_clock);
-
 #ifndef prepare_arch_switch
 # define prepare_arch_switch(next)	do { } while (0)
 #endif
Index: linux-2.6.25.4-rt4/kernel/sched_clock.c
===================================================================
--- linux-2.6.25.4-rt4.orig/kernel/sched_clock.c	2008-05-29 09:46:06.000000000 -0400
+++ linux-2.6.25.4-rt4/kernel/sched_clock.c	2008-05-29 09:46:06.000000000 -0400
@@ -59,21 +59,23 @@ static inline struct sched_clock_data *c
 	return &per_cpu(sched_clock_data, cpu);
 }
 
+static __read_mostly u64 ktime_offset;
+
 void sched_clock_init(void)
 {
-	u64 ktime_now = ktime_to_ns(ktime_get());
-	u64 now = 0;
 	int cpu;
 
+	ktime_offset = ktime_to_ns(ktime_get());
+
 	for_each_possible_cpu(cpu) {
 		struct sched_clock_data *scd = cpu_sdc(cpu);
 
 		scd->lock = (raw_spinlock_t)__RAW_SPIN_LOCK_UNLOCKED;
 		scd->prev_jiffies = jiffies;
-		scd->prev_raw = now;
-		scd->tick_raw = now;
-		scd->tick_gtod = ktime_now;
-		scd->clock = ktime_now;
+		scd->prev_raw = 0;
+		scd->tick_raw = 0;
+		scd->tick_gtod = 0;
+		scd->clock = 0;
 	}
 }
 
@@ -177,7 +179,7 @@ void sched_clock_tick(void)
 	WARN_ON_ONCE(!irqs_disabled());
 
 	now = sched_clock();
-	now_gtod = ktime_to_ns(ktime_get());
+	now_gtod = ktime_to_ns(ktime_get()) - ktime_offset;
 
 	__raw_spin_lock(&scd->lock);
 	__update_sched_clock(scd, now);
@@ -234,3 +236,9 @@ unsigned long long __attribute__((weak))
 {
 	return (unsigned long long)jiffies * (NSEC_PER_SEC / HZ);
 }
+
+unsigned long long cpu_clock(int cpu)
+{
+	return sched_clock_cpu(cpu);
+}
+EXPORT_SYMBOL_GPL(cpu_clock);
