Subject: Linux-RT 2.6.25.4-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
Subject: Linux-RT 2.6.25.4-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
Subject: Linux-RT 2.6.25-rt
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
From: Steven Rostedt <srostedt@redhat.com>
Subject: ftrace: fix updates to max trace

This patch fixes some bugs to the updating of the max trace that
was caused by implementing the new buffering.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 kernel/trace/trace.c         |    6 +++++-
 kernel/trace/trace_irqsoff.c |   27 +++++++++++++++------------
 2 files changed, 20 insertions(+), 13 deletions(-)

Index: linux-2.6.24.4-rt4/kernel/trace/trace_irqsoff.c
===================================================================
--- linux-2.6.24.4-rt4.orig/kernel/trace/trace_irqsoff.c	2008-03-24 19:05:46.000000000 -0400
+++ linux-2.6.24.4-rt4/kernel/trace/trace_irqsoff.c	2008-03-24 19:05:47.000000000 -0400
@@ -23,6 +23,8 @@ static int				tracer_enabled __read_most
 
 static DEFINE_PER_CPU(int, tracing_cpu);
 
+static DEFINE_SPINLOCK(max_trace_lock);
+
 enum {
 	TRACER_IRQS_OFF		= (1 << 1),
 	TRACER_PREEMPT_OFF	= (1 << 2),
@@ -126,7 +128,7 @@ check_critical_timing(struct trace_array
 		      int cpu)
 {
 	unsigned long latency, t0, t1;
-	cycle_t T0, T1, T2, delta;
+	cycle_t T0, T1, delta;
 	unsigned long flags;
 
 	/*
@@ -142,20 +144,18 @@ check_critical_timing(struct trace_array
 	if (!report_latency(delta))
 		goto out;
 
-	ftrace(tr, data, CALLER_ADDR0, parent_ip, flags);
-	/*
-	 * Update the timestamp, because the trace entry above
-	 * might change it (it can only get larger so the latency
-	 * is fair to be reported):
-	 */
-	T2 = now(cpu);
+	spin_lock(&max_trace_lock);
 
-	delta = T2-T0;
+	/* check if we are still the max latency */
+	if (!report_latency(delta))
+		goto out_unlock;
+
+	ftrace(tr, data, CALLER_ADDR0, parent_ip, flags);
 
 	latency = nsecs_to_usecs(delta);
 
 	if (data->critical_sequence != max_sequence)
-		goto out;
+		goto out_unlock;
 
 	tracing_max_latency = delta;
 	t0 = nsecs_to_usecs(T0);
@@ -189,6 +189,9 @@ check_critical_timing(struct trace_array
 
 	max_sequence++;
 
+out_unlock:
+	spin_unlock(&max_trace_lock);
+
 out:
 	data->critical_sequence = max_sequence;
 	data->preempt_timestamp = now(cpu);
@@ -366,14 +369,14 @@ void notrace trace_preempt_off(unsigned 
 
 static void start_irqsoff_tracer(struct trace_array *tr)
 {
-	tracer_enabled = 1;
 	register_ftrace_function(&trace_ops);
+	tracer_enabled = 1;
 }
 
 static void stop_irqsoff_tracer(struct trace_array *tr)
 {
-	unregister_ftrace_function(&trace_ops);
 	tracer_enabled = 0;
+	unregister_ftrace_function(&trace_ops);
 }
 
 static void __irqsoff_tracer_init(struct trace_array *tr)
Index: linux-2.6.24.4-rt4/kernel/trace/trace.c
===================================================================
--- linux-2.6.24.4-rt4.orig/kernel/trace/trace.c	2008-03-24 19:05:47.000000000 -0400
+++ linux-2.6.24.4-rt4/kernel/trace/trace.c	2008-03-24 19:05:47.000000000 -0400
@@ -153,6 +153,7 @@ update_max_tr(struct trace_array *tr, st
 		memcpy(max_tr.data[i], data, sizeof(*data));
 		data->trace = save_trace;
 		data->trace_pages = save_pages;
+		tracing_reset(data);
 	}
 
 	__update_max_tr(tr, tsk, cpu);
@@ -183,6 +184,7 @@ update_max_tr_single(struct trace_array 
 	memcpy(max_tr.data[cpu], data, sizeof(*data));
 	data->trace = save_trace;
 	data->trace_pages = save_pages;
+	tracing_reset(data);
 
 	__update_max_tr(tr, tsk, cpu);
 	spin_unlock(&ftrace_max_lock);
@@ -877,6 +879,8 @@ print_lat_fmt(struct seq_file *m, struct
 			   entry->ctx.next_prio,
 			   comm);
 		break;
+	default:
+		seq_printf(m, "Unknown type %d\n", entry->type);
 	}
 }
 
@@ -1625,7 +1629,6 @@ __init static int tracer_alloc_buffers(v
 	 * round up a bit.
 	 */
 	global_trace.entries = ENTRIES_PER_PAGE;
-	max_tr.entries = global_trace.entries;
 	pages++;
 
 	while (global_trace.entries < trace_nr_entries) {
@@ -1633,6 +1636,7 @@ __init static int tracer_alloc_buffers(v
 			break;
 		pages++;
 	}
+	max_tr.entries = global_trace.entries;
 
 	pr_info("tracer: %d pages allocated for %ld",
 		pages, trace_nr_entries);
