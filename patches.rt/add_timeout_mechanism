From ghaskins@novell.com Wed Feb 13 16:37:27 2008
Return-path: <ghaskins@novell.com>
Received: from Leto.novell.com (leto.provo.novell.com [130.57.1.24]) by
	sinclair.provo.novell.com with ESMTP; Wed, 13 Feb 2008 16:37:27 -0700
Received: from novell1.haskins.net (75-130-111-13.dhcp.oxfr.ma.charter.com
	[75.130.111.13]) by Leto.novell.com (TMA SMTPRS 4.4.568.30) with ESMTP id
	<C0135449986@Leto.novell.com>; Wed, 13 Feb 2008 15:36:25 -0800
Received-SPF: none (Leto.novell.com: domain of ghaskins@novell.com does not
	designate any permitted senders)
X-IADB2: None
X-Bonded-Senders: None
X-Habeas: None
X-Cloudmark-Rating: 0 <127.0.50.0>
X-IDDB: None
X-Modus-ReverseDNS: OK
X-Modus-BlackList: 75.130.111.13=OK;ghaskins@novell.com=OK
X-Modus-RBL: 75.130.111.13=OK
X-Modus-Trusted: 75.130.111.13=NO
X-Modus-Audit: FALSE;0;0;0
Received: from novell1.haskins.net (localhost [127.0.0.1]) by
	novell1.haskins.net (Postfix) with ESMTP id 9E25A3FC1D7; Wed, 13 Feb 2008
	18:11:07 -0500 (EST)
From: Gregory Haskins <ghaskins@novell.com>
Subject: [PATCH 4/9] add a loop counter based timeout mechanism
To: pmorreale@novell.com, sdietrich@novell.com
Cc: ghaskins@novell.com
Date: Wed, 13 Feb 2008 18:11:07 -0500
Message-ID: <20080213231107.4771.12418.stgit@novell1.haskins.net>
In-Reply-To: <20080213230912.4771.22530.stgit@novell1.haskins.net>
References: <20080213230912.4771.22530.stgit@novell1.haskins.net>
User-Agent: StGIT/0.12.1
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
X-Evolution-Source: imap://sdietrich@prv1-3.novell.com/
Content-Transfer-Encoding: 8bit

From: Sven Dietrich <sdietrich@novell.com>

Signed-off-by: Sven Dietrich <sdietrich@novell.com>
---

 kernel/Kconfig.preempt    |   11 +++++++++++
 kernel/rtmutex_adaptive.c |    7 ++++++-
 kernel/rtmutex_adaptive.h |    6 +++++-
 kernel/sysctl.c           |   12 ++++++++++++
 4 files changed, 34 insertions(+), 2 deletions(-)

diff --git a/kernel/Kconfig.preempt b/kernel/Kconfig.preempt
index 1c2a396..ac5e9fb 100644
--- a/kernel/Kconfig.preempt
+++ b/kernel/Kconfig.preempt
@@ -205,6 +205,17 @@ config ADAPTIVE_RTSPINLOCK
 
 	 If unsure, say Y
 
+config RTSPINLOCK_DELAY
+	int "Default delay (in loops) for adaptive spinlocks"
+	range 0 1000000000
+	depends on PREEMPT_RT && ADAPTIVE_RTSPINLOCK
+	default "10000"
+        help
+         This allows you to specify the delay between spin attempts for
+         rtspinlocks.  Larger values will allow the system to have higher
+         throughput at the expense of longer latencies for deadlock
+         avoidance.  The value is tunable at runtime via a sysctl.
+
 config SPINLOCK_BKL
 	bool "Old-Style Big Kernel Lock"
 	depends on (PREEMPT || SMP) && !PREEMPT_RT
diff --git a/kernel/rtmutex_adaptive.c b/kernel/rtmutex_adaptive.c
index b92df1a..4998d2e 100644
--- a/kernel/rtmutex_adaptive.c
+++ b/kernel/rtmutex_adaptive.c
@@ -33,6 +33,8 @@
 #include <linux/sched.h>
 #include "rtmutex_adaptive.h"
 
+int rtspin_timeout __read_mostly = CONFIG_RTSPINLOCK_DELAY;
+
 /*
  * Adaptive-spinlocks will busywait when possible, and sleep only if
  * necessary. Note that the busyloop looks racy, and it is....but we do
@@ -45,7 +47,7 @@ adaptive_wait(struct rt_mutex *lock, struct rt_mutex_waiter *waiter,
 {
 	int sleep = 0;
 
-	for (;;) {
+	for (; adaptive->timeout > 0; adaptive->timeout--) {
 		/*
 		 * If the task was re-awoken, break out completely so we can
 		 * reloop through the lock-acquisition code.
@@ -79,6 +81,9 @@ adaptive_wait(struct rt_mutex *lock, struct rt_mutex_waiter *waiter,
 		cpu_relax();
 	}
 
+	if (adaptive->timeout <= 0)
+		sleep = 1;
+
 	put_task_struct(adaptive->owner);
 
 	return sleep;
diff --git a/kernel/rtmutex_adaptive.h b/kernel/rtmutex_adaptive.h
index a136571..ee6ec08 100644
--- a/kernel/rtmutex_adaptive.h
+++ b/kernel/rtmutex_adaptive.h
@@ -15,6 +15,7 @@
 #ifdef CONFIG_ADAPTIVE_RTSPINLOCK
 struct adaptive_waiter {
 	struct task_struct *owner;
+	int timeout;
 };
 
 /*
@@ -35,8 +36,11 @@ prepare_adaptive_wait(struct rt_mutex *lock, struct adaptive_waiter *adaptive)
 	get_task_struct(adaptive->owner);
 }
 
+extern int rtspin_timeout;
+
 #define DECLARE_ADAPTIVE_WAITER(name) \
-     struct adaptive_waiter name = { .owner = NULL, }
+     struct adaptive_waiter name = { .owner = NULL,               \
+                                     .timeout = rtspin_timeout, }
 
 #else
 
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 541aa9f..7f95167 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -58,6 +58,8 @@
 #include <asm/stacktrace.h>
 #endif
 
+#include "rtmutex_adaptive.h"
+
 static int deprecated_sysctl_warning(struct __sysctl_args *args);
 
 #if defined(CONFIG_SYSCTL)
@@ -964,6 +966,16 @@ static struct ctl_table kern_table[] = {
 		.proc_handler	= &proc_dointvec,
 	},
 #endif
+#ifdef CONFIG_ADAPTIVE_RTSPINLOCK
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "rtspin_timeout",
+		.data		= &rtspin_timeout,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 #ifdef CONFIG_PROC_FS
 	{
 		.ctl_name       = CTL_UNNUMBERED,

