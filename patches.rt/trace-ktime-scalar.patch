Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
Subject: ftrace: print ktime values in readable form
From: Thomas Gleixner <tglx@linutronix.de>
Date: Sat, 26 Jul 2008 23:01:37 +0200

Printing the tv64 member of the ktime_t expiry/timestamp is unreadable
on 32bit machines which don't have KTIME_SCALAR set.

Convert the ktime_t value to a timespec instead and print sec.nsec
value, which makes the time values much easier to read also on those
machines which use the 64bit scalar nsec storage.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 kernel/trace/trace.c |   40 ++++++++++++++++++++++++----------------
 1 file changed, 24 insertions(+), 16 deletions(-)

Index: linux-2.6.26.3-rt6/kernel/trace/trace.c
===================================================================
--- linux-2.6.26.3-rt6.orig/kernel/trace/trace.c	2008-09-05 00:22:26.000000000 -0400
+++ linux-2.6.26.3-rt6/kernel/trace/trace.c	2008-09-05 00:22:26.000000000 -0400
@@ -1611,6 +1611,13 @@ extern unsigned long ia32_sys_call_table
 # define IA32_NR_syscalls (ia32_syscall_end - ia32_sys_call_table)
 #endif
 
+static void trace_print_ktime(struct trace_seq *s, ktime_t t)
+{
+	struct timespec ts = ktime_to_timespec(t);
+
+	trace_seq_printf(s, " (%ld.%09ld)", ts.tv_sec, ts.tv_nsec);
+}
+
 static void print_lat_help_header(struct seq_file *m)
 {
 	seq_puts(m, "#                  _------=> CPU#            \n");
@@ -1886,23 +1893,23 @@ print_lat_fmt(struct trace_iterator *ite
 		break;
 	case TRACE_TIMER_SET:
 		seq_print_ip_sym(s, entry->timer.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld) (%p)\n",
-			   entry->timer.expire, entry->timer.timer);
+		trace_print_ktime(s, entry->timer.expire);
+		trace_seq_printf(s, " (%p)\n", entry->timer.timer);
 		break;
 	case TRACE_TIMER_TRIG:
 		seq_print_ip_sym(s, entry->timer.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld) (%p)\n",
-			   entry->timer.expire, entry->timer.timer);
+		trace_print_ktime(s, entry->timer.expire);
+		trace_seq_printf(s, " (%p)\n", entry->timer.timer);
 		break;
 	case TRACE_TIMESTAMP:
 		seq_print_ip_sym(s, entry->timestamp.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld)\n",
-			   entry->timestamp.now.tv64);
+		trace_print_ktime(s, entry->timestamp.now);
+		trace_seq_puts(s, "\n");
 		break;
 	case TRACE_PROGRAM_EVENT:
 		seq_print_ip_sym(s, entry->program.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld) (%Ld)\n",
-			   entry->program.expire, entry->program.delta);
+		trace_print_ktime(s, entry->program.expire);
+		trace_seq_printf(s, " (%Ld)\n", entry->program.delta);
 		break;
 	case TRACE_TASK_ACT:
 		seq_print_ip_sym(s, entry->task.ip, sym_flags);
@@ -1986,6 +1993,7 @@ static int print_trace_fmt(struct trace_
 	ret = trace_seq_printf(s, "[%03d] ", iter->cpu);
 	if (!ret)
 		return 0;
+
 	ret = trace_seq_printf(s, "%5lu.%06lu: ", secs, usec_rem);
 	if (!ret)
 		return 0;
@@ -2083,23 +2091,23 @@ static int print_trace_fmt(struct trace_
 		break;
 	case TRACE_TIMER_SET:
 		seq_print_ip_sym(s, entry->timer.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld) (%p)\n",
-			   entry->timer.expire, entry->timer.timer);
+		trace_print_ktime(s, entry->timer.expire);
+		trace_seq_printf(s, " (%p)\n", entry->timer.timer);
 		break;
 	case TRACE_TIMER_TRIG:
 		seq_print_ip_sym(s, entry->timer.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld) (%p)\n",
-			   entry->timer.expire, entry->timer.timer);
+		trace_print_ktime(s, entry->timer.expire);
+		trace_seq_printf(s, " (%p)\n", entry->timer.timer);
 		break;
 	case TRACE_TIMESTAMP:
 		seq_print_ip_sym(s, entry->timestamp.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld)\n",
-			   entry->timestamp.now.tv64);
+		trace_print_ktime(s, entry->timestamp.now);
+		trace_seq_puts(s, "\n");
 		break;
 	case TRACE_PROGRAM_EVENT:
 		seq_print_ip_sym(s, entry->program.ip, sym_flags);
-		trace_seq_printf(s, " (%Ld) (%Ld)\n",
-			   entry->program.expire, entry->program.delta);
+		trace_print_ktime(s, entry->program.expire);
+		trace_seq_printf(s, " (%Ld)\n", entry->program.delta);
 		break;
 	case TRACE_TASK_ACT:
 		seq_print_ip_sym(s, entry->task.ip, sym_flags);
