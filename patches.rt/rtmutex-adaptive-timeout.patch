Subject: add a loop counter based timeout mechanism

From: Sven Dietrich <sdietrich@novell.com>

Signed-off-by: Sven Dietrich <sdietrich@novell.com>
---

 kernel/Kconfig.preempt    |   12 ++++++++++++
 kernel/rtmutex.c          |    4 ++++
 kernel/rtmutex_adaptive.h |   11 +++++++++--
 kernel/sysctl.c           |   12 ++++++++++++
 4 files changed, 37 insertions(+), 2 deletions(-)

Index: linux-2.6.24-RT/kernel/Kconfig.preempt
===================================================================
--- linux-2.6.24-RT.orig/kernel/Kconfig.preempt
+++ linux-2.6.24-RT/kernel/Kconfig.preempt
@@ -165,3 +165,15 @@ config ADAPTIVE_RTLOCK
 	 high-throughput and low-latency.
 
 	 If unsure, say Y
+
+config RTLOCK_DELAY
+	int "Default delay (in loops) for adaptive rtlocks"
+	range 0 1000000000
+	depends on PREEMPT_RT && ADAPTIVE_RTLOCK
+	default "10000"
+        help
+         This allows you to specify the maximum attempts a task will spin
+	 attempting to acquire an rtlock before sleeping.  The value is
+	 tunable at runtime via a sysctl.  A setting of 0 (zero) disables
+	 the adaptive algorithm entirely.
+
Index: linux-2.6.24-RT/kernel/rtmutex.c
===================================================================
--- linux-2.6.24-RT.orig/kernel/rtmutex.c
+++ linux-2.6.24-RT/kernel/rtmutex.c
@@ -19,6 +19,10 @@
 #include "rtmutex_common.h"
 #include "rtmutex_adaptive.h"
 
+#ifdef CONFIG_ADAPTIVE_RTLOCK
+int rtlock_timeout __read_mostly = CONFIG_RTLOCK_DELAY;
+#endif
+
 /*
  * lock->owner state tracking:
  *
Index: linux-2.6.24-RT/kernel/rtmutex_adaptive.h
===================================================================
--- linux-2.6.24-RT.orig/kernel/rtmutex_adaptive.h
+++ linux-2.6.24-RT/kernel/rtmutex_adaptive.h
@@ -39,6 +39,7 @@
 #ifdef CONFIG_ADAPTIVE_RTLOCK
 struct adaptive_waiter {
 	struct task_struct *owner;
+	int timeout;
 };
 
 /*
@@ -60,7 +61,7 @@ adaptive_wait(struct rt_mutex *lock, str
 {
 	int sleep = 0;
 
-	for (;;) {
+	for (; adaptive->timeout > 0; adaptive->timeout--) {
 		/*
 		 * If the task was re-awoken, break out completely so we can
 		 * reloop through the lock-acquisition code.
@@ -101,6 +102,9 @@ adaptive_wait(struct rt_mutex *lock, str
 		cpu_relax();
 	}
 
+	if (adaptive->timeout <= 0)
+		sleep = 1;
+
 	put_task_struct(adaptive->owner);
 
 	return sleep;
@@ -118,8 +122,11 @@ prepare_adaptive_wait(struct rt_mutex *l
 	get_task_struct(adaptive->owner);
 }
 
+extern int rtlock_timeout;
+
 #define DECLARE_ADAPTIVE_WAITER(name) \
-     struct adaptive_waiter name = { .owner = NULL, }
+     struct adaptive_waiter name = { .owner = NULL,               \
+                                     .timeout = rtlock_timeout, }
 
 #else
 
Index: linux-2.6.24-RT/kernel/sysctl.c
===================================================================
--- linux-2.6.24-RT.orig/kernel/sysctl.c
+++ linux-2.6.24-RT/kernel/sysctl.c
@@ -58,6 +58,8 @@
 #include <asm/stacktrace.h>
 #endif
 
+#include "rtmutex_adaptive.h"
+
 static int deprecated_sysctl_warning(struct __sysctl_args *args);
 
 #if defined(CONFIG_SYSCTL)
@@ -915,6 +917,16 @@ static struct ctl_table kern_table[] = {
 		.proc_handler	= &proc_dointvec,
 	},
 #endif
+#ifdef CONFIG_ADAPTIVE_RTLOCK
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "rtlock_timeout",
+		.data		= &rtlock_timeout,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 #ifdef CONFIG_PROC_FS
 	{
 		.ctl_name       = CTL_UNNUMBERED,
