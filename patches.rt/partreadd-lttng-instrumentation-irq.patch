Subject: readd RT compatible version of lttng-instrumentation-irq
From: Tony Jones <tonyj@suse.de>
Upstream: never

Re-add portions of patches.trace/lttng-instrumentation-irq.patch removed
by patches.rt/partrevert-lttng-instrumentation-irq.patch

---
 kernel/irq/handle.c |    6 ++++++
 kernel/softirq.c    |   11 ++++++++---
 2 files changed, 14 insertions(+), 3 deletions(-)

Index: linux-2.6.27-RT/kernel/irq/handle.c
===================================================================
--- linux-2.6.27-RT.orig/kernel/irq/handle.c
+++ linux-2.6.27-RT/kernel/irq/handle.c
@@ -133,6 +133,9 @@ irqreturn_t handle_IRQ_event(unsigned in
 {
 	irqreturn_t ret, retval = IRQ_NONE;
 	unsigned int status = 0;
+	struct pt_regs *regs = get_irq_regs();
+
+	trace_irq_entry(irq, regs);
 
 #ifdef __i386__
 	if (debug_direct_keyboard && irq == 1)
@@ -174,6 +177,9 @@ irqreturn_t handle_IRQ_event(unsigned in
 	if (debug_direct_keyboard && irq == 1)
 		lockdep_on();
 #endif
+
+	trace_irq_exit(retval);
+
 	return retval;
 }
 
Index: linux-2.6.27-RT/kernel/softirq.c
===================================================================
--- linux-2.6.27-RT.orig/kernel/softirq.c
+++ linux-2.6.27-RT/kernel/softirq.c
@@ -289,7 +289,9 @@ restart:
 			per_cpu(softirq_running, cpu) |= softirq_mask;
 			local_irq_enable();
 
+			trace_irq_softirq_entry(h, softirq_vec);
 			h->action(h);
+			trace_irq_softirq_exit(h, softirq_vec);
 			if (preempt_count != preempt_count()) {
 				print_symbol("BUG: softirq exited %s with wrong preemption count!\n", (unsigned long) h->action);
 				printk("entered with %08x, exited with %08x.\n", preempt_count, preempt_count());
@@ -433,6 +435,7 @@ void irq_exit(void)
  */
 inline void raise_softirq_irqoff(unsigned int nr)
 {
+	trace_irq_softirq_raise(nr);
 	__do_raise_softirq_irqoff(nr);
 
 #ifdef CONFIG_PREEMPT_SOFTIRQS
@@ -540,7 +543,7 @@ void  tasklet_hi_enable(struct tasklet_s
 EXPORT_SYMBOL(tasklet_hi_enable);
 
 static void
-__tasklet_action(struct softirq_action *a, struct tasklet_struct *list)
+__tasklet_action(struct softirq_action *a, struct tasklet_struct *list, unsigned hilow)
 {
 	int loops = 1000000;
 
@@ -585,7 +588,9 @@ out_disabled:
 			WARN_ON(1);
 
 again:
+		hilow ? trace_irq_tasklet_high_entry(t) : trace_irq_tasklet_low_entry(t);
 		t->func(t->data);
+		hilow ? trace_irq_tasklet_high_exit(t) : trace_irq_tasklet_low_exit(t);
 
 		/*
 		 * Try to unlock the tasklet. We must use cmpxchg, because
@@ -624,7 +629,7 @@ static void tasklet_action(struct softir
 	__get_cpu_var(tasklet_vec).tail = &__get_cpu_var(tasklet_vec).head;
 	local_irq_enable();
 
-	__tasklet_action(a, list);
+	__tasklet_action(a, list, 0);
 }
 
 static void tasklet_hi_action(struct softirq_action *a)
@@ -637,7 +642,7 @@ static void tasklet_hi_action(struct sof
 	__get_cpu_var(tasklet_hi_vec).tail = &__get_cpu_var(tasklet_vec).head;
 	local_irq_enable();
 
-	__tasklet_action(a, list);
+	__tasklet_action(a, list, 1);
 }
 
 
