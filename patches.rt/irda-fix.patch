This was found around the 2.6.10 timeframe when testing with the -rt patch
and I believe is still is an issue. irttp_dup() does a memcpy() of the tsap_cb 
structure causing the spinlock protecting various fields in the structure to be 
duped.  This works OK in the non-RT case but in the RT case we end up with two 
mutexes pointing to the same wait_list and leading to an OOPS. Fix is to simply
initialize the spinlock after the memcpy().

Signed-off-by: Deepak Saxena <dsaxena@mvista.com>

---
 net/irda/irttp.c |    1 +
 1 file changed, 1 insertion(+)

Index: linux-2.6.22/net/irda/irttp.c
===================================================================
--- linux-2.6.22.orig/net/irda/irttp.c	2007-07-24 08:56:01.000000000 +0200
+++ linux-2.6.22/net/irda/irttp.c	2007-07-24 08:57:41.000000000 +0200
@@ -1441,6 +1441,7 @@ struct tsap_cb *irttp_dup(struct tsap_cb
 	}
 	/* Dup */
 	memcpy(new, orig, sizeof(struct tsap_cb));
+	spin_lock_init(&new->lock);
 
 	/* We don't need the old instance any more */
 	spin_unlock_irqrestore(&irttp->tsaps->hb_spinlock, flags);
