From slert-devel-bounces+sdietrich=novell.com@suse.de Fri Feb 15 18:53:03 2008
Return-path: <slert-devel-bounces+sdietrich=novell.com@suse.de>
Received: from Relay2.suse.de ([149.44.160.89]) by emea5-mh.id5.novell.com
	with ESMTP (TLS encrypted); Fri, 15 Feb 2008 18:53:03 +0100
Received: from Fourier.suse.de (fourier.suse.de [149.44.160.40]) by
	Relay2.suse.de (Postfix) with ESMTP id CFCC81C4C355 for
	<sdietrich@novell.com>; Fri, 15 Feb 2008 18:53:02 +0100 (CET)
Received: from fourier.suse.de (localhost [127.0.0.1]) by Fourier.suse.de
	(Postfix) with ESMTP id CB1A81E4278C for <sdietrich@novell.com>; Fri, 15
	Feb 2008 18:53:02 +0100 (CET)
Received: from Relay2.suse.de (relay2.suse.de [149.44.160.89]) by
	Fourier.suse.de (Postfix) with ESMTP id 483AC1E42776 for
	<slert-devel@mailman.suse.de>; Fri, 15 Feb 2008 18:53:01 +0100 (CET)
Received: by Relay2.suse.de (Postfix) id 45B7A1C4C353; Fri, 15 Feb 2008
	18:53:01 +0100 (CET)
Received: from relay2.suse.de (localhost [127.0.0.1]) by Relay2.suse.de
	(Postfix) with ESMTP id 3AB841C4C34D for <slert-devel@suse.de>; Fri, 15 Feb
	2008 18:53:01 +0100 (CET)
X-Virus-Scanned: by amavisd-new at relay2.suse.de
X-Spam-Score: -2.499
X-Spam-Level: 
X-Spam-Status: No, score=-2.499 tagged_above=-20 required=5
	tests=[BAYES_00=-2.599, RDNS_DYNAMIC=0.1]
Received: from mx2.suse.de ([195.135.220.15]) by relay2.suse.de
	(relay2.suse.de [149.44.160.89]) (amavisd-new, port 10025) with ESMTP id
	xVD3GN6qUJuF for <slert-devel@suse.de>; Fri, 15 Feb 2008 18:52:59 +0100
	(CET)
Received: from novell1.haskins.net (75-130-111-13.dhcp.oxfr.ma.charter.com
	[75.130.111.13]) by mx2.suse.de (Postfix) with ESMTP id 47A4A35703 for
	<slert-devel@suse.de>; Fri, 15 Feb 2008 18:52:59 +0100 (CET)
Received: from novell1.haskins.net (localhost [127.0.0.1]) by
	novell1.haskins.net (Postfix) with ESMTP id E480F3FC1DD for
	<slert-devel@suse.de>; Fri, 15 Feb 2008 12:26:10 -0500 (EST)
From: Gregory Haskins <ghaskins@novell.com>
To: slert-devel@suse.de
Date: Fri, 15 Feb 2008 12:26:10 -0500
Message-ID: <20080215172610.25573.11805.stgit@novell1.haskins.net>
In-Reply-To: <20080215172421.25573.85164.stgit@novell1.haskins.net>
References: <20080215172421.25573.85164.stgit@novell1.haskins.net>
User-Agent: StGIT/0.12.1
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Subject: [slert-devel] [PATCH 07/10] Adjust pi_lock usage in wakeup
X-BeenThere: slert-devel@suse.de
X-Mailman-Version: 2.1.4
Precedence: list
List-Id: All things slert <slert-devel.suse.de>
List-Unsubscribe: <https://mailman.suse.de/mailman/listinfo/slert-devel>,
	<mailto:slert-devel-request@suse.de?subject=unsubscribe>
List-Archive: <https://mailman.suse.de/mailman/private/slert-devel>
List-Post: <mailto:slert-devel@suse.de>
List-Help: <mailto:slert-devel-request@suse.de?subject=help>
List-Subscribe: <https://mailman.suse.de/mailman/listinfo/slert-devel>,
	<mailto:slert-devel-request@suse.de?subject=subscribe>
Sender: slert-devel-bounces+sdietrich=novell.com@suse.de
Errors-To: slert-devel-bounces+sdietrich=novell.com@suse.de
X-Evolution-Source: imap://sdietrich@prv1-3.novell.com/
Content-Transfer-Encoding: 8bit

From: Peter W.Morreale <pmorreale@novell.com>

In wakeup_next_waiter(), we take the pi_lock, and then find out whether
we have another waiter to add to the pending owner.  We can reduce
contention on the pi_lock for the pending owner if we first obtain the
pointer to the next waiter outside of the pi_lock.

This patch adds a measureable increase in throughput.

Signed-off-by: Peter W. Morreale <pmorreale@novell.com>
---

 kernel/rtmutex.c |   14 +++++++++-----
 1 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index 64003fc..10215f9 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -497,6 +497,7 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 {
 	struct rt_mutex_waiter *waiter;
 	struct task_struct *pendowner;
+	struct rt_mutex_waiter *next;
 
 	spin_lock(&current->pi_lock);
 
@@ -541,6 +542,12 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 	 * waiter with higher priority than pending-owner->normal_prio
 	 * is blocked on the unboosted (pending) owner.
 	 */
+
+	if (rt_mutex_has_waiters(lock))
+		next = rt_mutex_top_waiter(lock);
+	else
+		next = NULL;
+
 	spin_lock(&pendowner->pi_lock);
 
 	WARN_ON(!pendowner->pi_blocked_on);
@@ -549,12 +556,9 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 
 	pendowner->pi_blocked_on = NULL;
 
-	if (rt_mutex_has_waiters(lock)) {
-		struct rt_mutex_waiter *next;
-
-		next = rt_mutex_top_waiter(lock);
+	if (next)
 		plist_add(&next->pi_list_entry, &pendowner->pi_waiters);
-	}
+
 	spin_unlock(&pendowner->pi_lock);
 }
 

