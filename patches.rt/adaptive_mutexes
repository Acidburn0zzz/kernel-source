From ghaskins@novell.com Wed Feb 13 16:37:34 2008
Return-path: <ghaskins@novell.com>
Received: from adonis.novell.com (adonis.provo.novell.com [130.57.1.97]) by
	sinclair.provo.novell.com with ESMTP; Wed, 13 Feb 2008 16:37:34 -0700
Received: from novell1.haskins.net (75-130-111-13.dhcp.oxfr.ma.charter.com
	[75.130.111.13]) by adonis.novell.com (TMA SMTPRS 4.4.568.30) with ESMTP id
	<C0131301060@adonis.novell.com>; Wed, 13 Feb 2008 16:37:27 -0700
Received-SPF: none (adonis.novell.com: domain of ghaskins@novell.com does
	not designate any permitted senders)
X-IADB2: None
X-Bonded-Senders: None
X-Habeas: None
X-Cloudmark-Rating: 0 <127.0.50.0>
X-IDDB: None
X-Modus-ReverseDNS: OK
X-Modus-BlackList: 75.130.111.13=OK;ghaskins@novell.com=OK
X-Modus-RBL: 75.130.111.13=OK
X-Modus-Trusted: 75.130.111.13=NO
X-Modus-Audit: FALSE;0;0;0
Received: from novell1.haskins.net (localhost [127.0.0.1]) by
	novell1.haskins.net (Postfix) with ESMTP id 2D5053FC1D7; Wed, 13 Feb 2008
	18:11:13 -0500 (EST)
From: Gregory Haskins <ghaskins@novell.com>
Subject: [PATCH 5/9] adaptive mutexes
To: pmorreale@novell.com, sdietrich@novell.com
Cc: ghaskins@novell.com
Date: Wed, 13 Feb 2008 18:11:13 -0500
Message-ID: <20080213231112.4771.11214.stgit@novell1.haskins.net>
In-Reply-To: <20080213230912.4771.22530.stgit@novell1.haskins.net>
References: <20080213230912.4771.22530.stgit@novell1.haskins.net>
User-Agent: StGIT/0.12.1
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
X-Evolution-Source: imap://sdietrich@prv1-3.novell.com/
Content-Transfer-Encoding: 8bit

From: Peter W.Morreale <pmorreale@novell.com>

This patch adds the adaptive spin lock busywait to rtmutexes.  It adds
a new tunable: rtmutex_timeout, which is the companion to the
rtspin_timeout tunable.

Signed-off-by: Peter W. Morreale <pmorreale@novell.com>
---

 kernel/Kconfig.preempt    |   49 +++++++++++++++++++++++++++++++++++++++++----
 kernel/rtmutex.c          |   40 ++++++++++++++++++++-----------------
 kernel/rtmutex_adaptive.c |   13 +++++++++++-
 kernel/rtmutex_adaptive.h |   24 ++++++++++++++++++++--
 kernel/sysctl.c           |   10 +++++++++
 5 files changed, 111 insertions(+), 25 deletions(-)

diff --git a/kernel/Kconfig.preempt b/kernel/Kconfig.preempt
index ac5e9fb..ba25b3f 100644
--- a/kernel/Kconfig.preempt
+++ b/kernel/Kconfig.preempt
@@ -211,10 +211,51 @@ config RTSPINLOCK_DELAY
 	depends on PREEMPT_RT && ADAPTIVE_RTSPINLOCK
 	default "10000"
         help
-         This allows you to specify the delay between spin attempts for
-         rtspinlocks.  Larger values will allow the system to have higher
-         throughput at the expense of longer latencies for deadlock
-         avoidance.  The value is tunable at runtime via a sysctl.
+         This allows you to specify the maximum delay a task will use
+	 to wait for a rt spinlock before going to sleep.  Note that that
+	 although the delay is implemented as a preemptable loop, tasks
+	 of like priority cannot preempt each other and this setting can
+	 result in increased latencies.
+	 
+         The value is tunable at runtime via a sysctl.  A setting of 0
+	 (zero) disables the adaptive algorithm entirely.
+
+config ADAPTIVE_RTMUTEX
+        bool "Adaptive real-time mutexes"
+        default y
+        depends on ADAPTIVE_RTSPINLOCK
+        help
+         This option adds the rtspinlock spin/sleep algorithm to
+         rtmutexes.  In rtspinlocks, a significant gain in throughput
+         can be seen by allowing rtspinlocks to spin for a distinct
+         amount of time prior to going to sleep for deadlock avoidence.
+ 
+         Typically, mutexes are used when a critical section may need to
+         sleep due to a blocking operation.  In the event the critical 
+	 section does not need to sleep, an additional gain in throughput 
+	 can be seen by avoiding the extra overhead of sleeping.
+ 
+         This option alters the rtmutex code to use an adaptive
+         spin/sleep algorithm.  It will spin unless it determines it must
+         sleep to avoid deadlock.  This offers a best of both worlds
+         solution since we achieve both high-throughput and low-latency.
+ 
+         If unsure, say Y
+ 
+config RTMUTEX_DELAY
+        int "Default delay (in nanoseconds) for adaptive mutexes"
+        range 0 10000000
+        depends on ADAPTIVE_RTMUTEX
+        default "3000"
+        help
+         This allows you to specify the maximum delay a task will use
+	 to wait for a rt mutex before going to sleep.  Note that that
+	 although the delay is implemented as a preemptable loop, tasks
+	 of like priority cannot preempt each other and this setting can
+	 result in increased latencies.
+	 
+         The value is tunable at runtime via a sysctl.  A setting of 0
+	 (zero) disables the adaptive algorithm entirely.
 
 config SPINLOCK_BKL
 	bool "Old-Style Big Kernel Lock"
diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index feb938f..64003fc 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -517,17 +517,16 @@ static void wakeup_next_waiter(struct rt_mutex *lock, int savestate)
 	 * Do the wakeup before the ownership change to give any spinning
 	 * waiter grantees a headstart over the other threads that will
 	 * trigger once owner changes.
+	 *
+	 * This may appear to be a race, but the barriers close the
+	 * window.
 	 */
-	if (!savestate)
-		wake_up_process(pendowner);
-	else {
-		smp_mb();
-		/*
-		 * This may appear to be a race, but the barriers close the
-		 * window.
-		 */
-		if ((pendowner->state != TASK_RUNNING)
-		    && (pendowner->state != TASK_RUNNING_MUTEX))
+	smp_mb();
+	if ((pendowner->state != TASK_RUNNING)
+	    && (pendowner->state != TASK_RUNNING_MUTEX)) {
+		if (!savestate)
+			wake_up_process(pendowner);
+		else
 			wake_up_process_mutex(pendowner);
 	}
 
@@ -760,7 +759,7 @@ rt_spin_lock_slowlock(struct rt_mutex *lock)
 		debug_rt_mutex_print_deadlock(&waiter);
 
 		/* adaptive_wait() returns 1 if we need to sleep */
-		if (adaptive_wait(lock, &waiter, &adaptive)) {
+		if (adaptive_wait(lock, 0, &waiter, &adaptive)) {
 			update_current(TASK_UNINTERRUPTIBLE, &saved_state);
 			if (waiter.task)
 				schedule_rt_mutex(lock);
@@ -971,6 +970,7 @@ rt_mutex_slowlock(struct rt_mutex *lock, int state,
 	int ret = 0, saved_lock_depth = -1;
 	struct rt_mutex_waiter waiter;
 	unsigned long flags;
+	DECLARE_ADAPTIVE_MUTEX_WAITER(adaptive);
 
 	debug_rt_mutex_init_waiter(&waiter);
 	waiter.task = NULL;
@@ -991,8 +991,6 @@ rt_mutex_slowlock(struct rt_mutex *lock, int state,
 	if (unlikely(current->lock_depth >= 0))
 		saved_lock_depth = rt_release_bkl(lock, flags);
 
-	set_current_state(state);
-
 	/* Setup the timer, when timeout != NULL */
 	if (unlikely(timeout))
 		hrtimer_start(&timeout->timer, timeout->timer.expires,
@@ -1045,6 +1043,9 @@ rt_mutex_slowlock(struct rt_mutex *lock, int state,
 			if (unlikely(ret))
 				break;
 		}
+
+		mutex_prepare_adaptive_wait(lock, &adaptive);
+
 		saved_flags = current->flags & PF_NOSCHED;
 		current->flags &= ~PF_NOSCHED;
 
@@ -1052,17 +1053,20 @@ rt_mutex_slowlock(struct rt_mutex *lock, int state,
 
 		debug_rt_mutex_print_deadlock(&waiter);
 
-		if (waiter.task)
-			schedule_rt_mutex(lock);
+		if (mutex_adaptive_wait(lock,
+					(state == TASK_INTERRUPTIBLE),
+					&waiter, &adaptive)) {
+			set_current_state(state);
+			if (waiter.task)
+				schedule_rt_mutex(lock);
+			set_current_state(TASK_RUNNING);
+		}
 
 		spin_lock_irq(&lock->wait_lock);
 
 		current->flags |= saved_flags;
-		set_current_state(state);
 	}
 
-	set_current_state(TASK_RUNNING);
-
 	if (unlikely(waiter.task))
 		remove_waiter(lock, &waiter, flags);
 
diff --git a/kernel/rtmutex_adaptive.c b/kernel/rtmutex_adaptive.c
index 4998d2e..e7ce814 100644
--- a/kernel/rtmutex_adaptive.c
+++ b/kernel/rtmutex_adaptive.c
@@ -34,6 +34,9 @@
 #include "rtmutex_adaptive.h"
 
 int rtspin_timeout __read_mostly = CONFIG_RTSPINLOCK_DELAY;
+#ifdef CONFIG_ADAPTIVE_RTMUTEX
+int rtmutex_timeout __read_mostly = CONFIG_RTMUTEX_DELAY;
+#endif
 
 /*
  * Adaptive-spinlocks will busywait when possible, and sleep only if
@@ -42,7 +45,8 @@ int rtspin_timeout __read_mostly = CONFIG_RTSPINLOCK_DELAY;
  * time before seeing that we need to break-out on the next iteration.
  */
 int
-adaptive_wait(struct rt_mutex *lock, struct rt_mutex_waiter *waiter,
+adaptive_wait(struct rt_mutex *lock, int interruptible,
+	      struct rt_mutex_waiter *waiter,
 	      struct adaptive_waiter *adaptive)
 {
 	int sleep = 0;
@@ -63,6 +67,13 @@ adaptive_wait(struct rt_mutex *lock, struct rt_mutex_waiter *waiter,
 		if (adaptive->owner != rt_mutex_owner(lock))
 			break;
 
+#ifdef CONFIG_ADAPTIVE_RTMUTEX
+		/*
+		 * Mutexes may need to check for signals...
+		 */
+		if (interruptible && signal_pending(current))
+			break;
+#endif
 		/*
 		 * If we got here, presumably the lock ownership is still
 		 * current.  So sleep if the owner is not running, is running
diff --git a/kernel/rtmutex_adaptive.h b/kernel/rtmutex_adaptive.h
index ee6ec08..2d6ce8d 100644
--- a/kernel/rtmutex_adaptive.h
+++ b/kernel/rtmutex_adaptive.h
@@ -21,7 +21,8 @@ struct adaptive_waiter {
 /*
  * Returns 1 if we should sleep
  */
-int adaptive_wait(struct rt_mutex *lock, struct rt_mutex_waiter *waiter,
+int adaptive_wait(struct rt_mutex *lock, int interruptible,
+		  struct rt_mutex_waiter *waiter,
 		  struct adaptive_waiter *adative);
 
 static inline void
@@ -46,10 +47,29 @@ extern int rtspin_timeout;
 
 #define DECLARE_ADAPTIVE_WAITER(name) {}
 
-#define adaptive_wait(lock, waiter, busy) 1
+#define adaptive_wait(lock, intr, waiter, busy) 1
 #define prepare_adaptive_wait(lock, busy) {}
 
 #endif /* CONFIG_ADAPTIVE_RTSPINLOCK */
 
+#ifdef CONFIG_ADAPTIVE_RTMUTEX
+
+#define mutex_adaptive_wait         adaptive_wait
+#define mutex_prepare_adaptive_wait prepare_adaptive_wait
+
+extern int rtmutex_timeout;
+
+#define DECLARE_ADAPTIVE_MUTEX_WAITER(name) \
+     struct adaptive_waiter name = { .owner = NULL,               \
+                                     .timeout = rtmutex_timeout, }
+
+#else
+
+#define DECLARE_ADAPTIVE_MUTEX_WAITER(name) {}
+
+#define mutex_adaptive_wait(lock, intr, waiter, busy) 1
+#define mutex_prepare_adaptive_wait(lock, busy) {}
+
+#endif /* CONFIG_ADAPTIVE_RTMUTEX */
 
 #endif /* __KERNEL_RTMUTEX_ADAPTIVE_H */
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 7f95167..f9c4321 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -975,6 +975,16 @@ static struct ctl_table kern_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#ifdef CONFIG_ADAPTIVE_RTMUTEX
+	{
+		.ctl_name       = CTL_UNNUMBERED,
+		.procname       = "rtmutex_timeout",
+		.data           = &rtmutex_timeout,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = &proc_dointvec,
+       },
+#endif
 #endif
 #ifdef CONFIG_PROC_FS
 	{

