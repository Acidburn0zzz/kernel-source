From: "Beauchemin, Mark" <Mark.Beauchemin@sycamorenet.com>
To: "Ingo Molnar" <mingo@elte.hu>
Cc: "Thomas Gleixner" <tglx@linutronix.de>, <linux-kernel@vger.kernel.org>, "David Miller" <davem@davemloft.net>
X-OriginalArrivalTime: 07 Aug 2007 19:41:41.0634 (UTC)
	FILETIME=[FA684620:01C7D92A]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List:	linux-kernel@vger.kernel.org
X-Evolution-Source: imap://sven@sx.thebigcorporation.com/
Content-Transfer-Encoding: 8bit

Thomas,

        I think I've gotten to the heart of the problem.  Here's an excerpt
from the latest -rt patch:  net/core/dev.c in the function dev_queue_xmit


           Either shot noqueue qdisc, it is even simpler 8)
         */
        if (dev->flags & IFF_UP) {
-               int cpu = smp_processor_id(); /* ok because BHs are off */
+               /*
+                * No need to check for recursion with threaded interrupts:
+                */
+#ifdef CONFIG_PREEMPT_RT
+               if (1) {
+#else
+               int cpu = raw_smp_processor_id(); /* ok because BHs are off */
 
                if (dev->xmit_lock_owner != cpu) {
-
-                       HARD_TX_LOCK(dev, cpu);
+#endif
+                       HARD_TX_LOCK(dev);
 
                        if (!netif_queue_stopped(dev) &&
                            !netif_subqueue_stopped(dev, skb->queue_mapping)) {


I'm not sure why the check for recursion has been removed.  
In the backtrace below, I think it would be caught by this check and 
not recursively call the spinlock code.

> Call Trace: 
> [D010BB40] [C01C7BA8] rt_spin_lock_slowlock+0x44/0x1f8 (unreliable) 
> [D010BB90] [C0153464] dev_queue_xmit+0x298/0x2a0         Tunnel2 
> [D010BBB0] [C0176398] ip_output+0x288/0x2dc 
> [D010BBE0] [C01AC078] ipip_tunnel_xmit+0x508/0x698 
> [D010BC60] [C0150DF4] dev_hard_start_xmit+0x1b4/0x2a4 
> [D010BC80] [C0153430] dev_queue_xmit+0x264/0x2a0         Tunnel4 
> [D010BCA0] [C0176398] ip_output+0x288/0x2dc 
> [D010BCD0] [C01AC078] ipip_tunnel_xmit+0x508/0x698 
> [D010BD50] [C0150DF4] dev_hard_start_xmit+0x1b4/0x2a4 
> [D010BD70] [C0153430] dev_queue_xmit+0x264/0x2a0         Tunnel2 
> [D010BD90] [C0176398] ip_output+0x288/0x2dc 
> [D010BDC0] [C017685C] ip_queue_xmit+0x1ac/0x4e4 
> [D010BE30] [C018762C] tcp_transmit_skb+0x390/0x810 
> [D010BE70] [C018882C] tcp_retransmit_skb+0x160/0x638 
> [D010BEA0] [C018BA5C] tcp_write_timer+0x274/0x6c0
> [D010BED0] [C0024314] run_timer_softirq+0x2d0/0xedc 
> [D010BF80] [C001F1C4] ksoftirqd+0xf8/0x1b0 
> [D010BFC0] [C0031588] kthread+0xc0/0xfc 
> [D010BFF0] [C000471C] kernel_thread+0x44/0x60                                                                         



I found one other place in the code which appears to do the same thing.
Although it is written to handle smp collisions, I think it should also
handle the error case above.

> could you please change this to use 'current' (instead of the CPU 
> number) as the xmit_lock_owner unconditionally? That results in much 
> fewer #ifdefs and far cleaner code.
> 
> 	Ingo

Ingo,

	Here's the new patch.  Please check me on the non-rt portion.  
I think the check is still functionally the same.  

Thanks,
	Mark  


Index: linux-2.6.22/include/linux/netdevice.h
===================================================================
--- linux-2.6.22.orig/include/linux/netdevice.h
+++ linux-2.6.22/include/linux/netdevice.h
@@ -446,7 +446,7 @@ struct net_device
 	/* cpu id of processor entered to hard_start_xmit or -1,
 	   if nobody entered there.
 	 */
-	int			xmit_lock_owner;
+	void *			xmit_lock_owner;
 	void			*priv;	/* pointer to private data	*/
 	int			(*hard_start_xmit) (struct sk_buff *skb,
 						    struct net_device *dev);
@@ -951,32 +951,34 @@ static inline void netif_poll_enable(str
 static inline void netif_tx_lock(struct net_device *dev)
 {
 	spin_lock(&dev->_xmit_lock);
-	dev->xmit_lock_owner = raw_smp_processor_id();
+ 	dev->xmit_lock_owner = (void *)current;
 }
 
 static inline void netif_tx_lock_bh(struct net_device *dev)
 {
 	spin_lock_bh(&dev->_xmit_lock);
-	dev->xmit_lock_owner = raw_smp_processor_id();
+ 	dev->xmit_lock_owner = (void *)current;
 }
 
 static inline int netif_tx_trylock(struct net_device *dev)
 {
 	int ok = spin_trylock(&dev->_xmit_lock);
 	if (likely(ok))
-		dev->xmit_lock_owner = raw_smp_processor_id();
+	{
+     	dev->xmit_lock_owner = (void *)current;
+    }
 	return ok;
 }
 
 static inline void netif_tx_unlock(struct net_device *dev)
 {
-	dev->xmit_lock_owner = -1;
+	dev->xmit_lock_owner = (void *)-1;
 	spin_unlock(&dev->_xmit_lock);
 }
 
 static inline void netif_tx_unlock_bh(struct net_device *dev)
 {
-	dev->xmit_lock_owner = -1;
+	dev->xmit_lock_owner = (void *)-1;
 	spin_unlock_bh(&dev->_xmit_lock);
 }
 
Index: linux-2.6.22/net/core/dev.c
===================================================================
--- linux-2.6.22.orig/net/core/dev.c
+++ linux-2.6.22/net/core/dev.c
@@ -1568,16 +1568,7 @@ gso:
 	   Either shot noqueue qdisc, it is even simpler 8)
 	 */
 	if (dev->flags & IFF_UP) {
-		/*
-		 * No need to check for recursion with threaded interrupts:
-		 */
-#ifdef CONFIG_PREEMPT_RT
-		if (1) {
-#else
-		int cpu = raw_smp_processor_id(); /* ok because BHs are off */
-
-		if (dev->xmit_lock_owner != cpu) {
-#endif
+		if (dev->xmit_lock_owner != (void *)current) {
 			HARD_TX_LOCK(dev);
 
 			if (!netif_queue_stopped(dev)) {
@@ -3105,7 +3096,7 @@ int register_netdevice(struct net_device
 	spin_lock_init(&dev->queue_lock);
 	spin_lock_init(&dev->_xmit_lock);
 	netdev_set_lockdep_class(&dev->_xmit_lock, dev->type);
-	dev->xmit_lock_owner = -1;
+	dev->xmit_lock_owner = (void *)-1;
 	spin_lock_init(&dev->ingress_lock);
 
 	dev->iflink = -1;
Index: linux-2.6.22/net/mac80211/ieee80211.c
===================================================================
--- linux-2.6.22.orig/net/mac80211/ieee80211.c
+++ linux-2.6.22/net/mac80211/ieee80211.c
@@ -2185,7 +2185,7 @@ enum netif_tx_lock_class {
 static inline void netif_tx_lock_nested(struct net_device *dev, int subclass)
 {
 	spin_lock_nested(&dev->_xmit_lock, subclass);
-	dev->xmit_lock_owner = smp_processor_id();
+	dev->xmit_lock_owner = (void *)current;
 }
 
 static void ieee80211_set_multicast_list(struct net_device *dev)
Index: linux-2.6.22/net/sched/sch_generic.c
===================================================================
--- linux-2.6.22.orig/net/sched/sch_generic.c
+++ linux-2.6.22/net/sched/sch_generic.c
@@ -102,7 +102,13 @@ static inline int qdisc_restart(struct n
 		 */
 		if (!nolock) {
 #ifdef CONFIG_PREEMPT_RT
-			netif_tx_lock(dev);
+        if (dev->xmit_lock_owner == (void *)current) {
+            kfree_skb(skb);
+            if (net_ratelimit())
+                printk(KERN_DEBUG "Dead loop on netdevice %s, fix it urgently!\n", dev->name);
+            return -1;
+        }
+        netif_tx_lock(dev);
 #else
 			if (!netif_tx_trylock(dev)) {
 				/* So, someone grabbed the driver. */
@@ -112,7 +118,7 @@ static inline int qdisc_restart(struct n
 				   it by checking xmit owner and drop the
 				   packet when deadloop is detected.
 				*/
-				if (dev->xmit_lock_owner == raw_smp_processor_id()) {
+				if (dev->xmit_lock_owner == (void *)current) {
 					kfree_skb(skb);
 					if (net_ratelimit())
 						printk(KERN_DEBUG "Dead loop on netdevice %s, fix it urgently!\n", dev->name);
