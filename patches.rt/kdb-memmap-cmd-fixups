From: Joe Korty <joe.korty@ccur.com>
Subject: KDB compile fix for i386 and x86_64
Patch-Mainline: never

This patch is required to get kdb to compile under i386 and x86_64.

Make kdb's memmap command work with CONFIG_DISCONTIGMEM.

Updated the kdbm_memmap() 'memmap' command routine so that
it now works when CONFIG_DISCONTIGMEM is enabled.

When CONFIG_DISCONTIGMEM is enabled this routine outputs
information for all pages in the system unless a 'node id'
parameter is specifed, in which case the information for
just that node's pages is output.

Also changed this routine so that it can handle pages
count values of -1.  This was causing it to blow up,
even when CONFIG_DISCONTIGMEM was disabled.

Acked-by: Sven-Thorsten Dietrich <sdietrich@novell.com>

Index: linux-2.6.22/kdb/modules/kdbm_pg.c
===================================================================
--- linux-2.6.22.orig/kdb/modules/kdbm_pg.c	2007-07-13 16:48:05.000000000 -0400
+++ linux-2.6.22/kdb/modules/kdbm_pg.c	2007-07-13 16:57:01.000000000 -0400
@@ -538,7 +538,7 @@
 
 
 
-#if defined(CONFIG_X86) && !defined(CONFIG_X86_64)
+#ifdef CONFIG_X86
 /* According to Steve Lord, this code is ix86 specific.  Patches to extend it to
  * other architectures will be greatefully accepted.
  */
@@ -550,19 +550,44 @@
 	int slab_count = 0;
 	int dirty_count = 0;
 	int locked_count = 0;
-	int page_counts[9];
+	int page_counts[10];	/* [8] = large counts, [9] = -1 counts */
 	int buffered_count = 0;
 #ifdef buffer_delay
 	int delay_count = 0;
 #endif
 	int diag;
 	unsigned long addr;
+#ifdef CONFIG_DISCONTIGMEM
+	int node_id = -1, found_node = 0;
+	int tot_page_count = 0;
+	unsigned long unode_id;
+	pg_data_t *pgdat;
+
+	if (argc == 1) {		/* node_id was specified */
+	    diag = kdbgetularg(argv[argc], &unode_id);
+	    if (diag)
+		return diag;
+	    node_id = (int)unode_id;
+	}
+	else if (argc)
+	    return KDB_ARGCOUNT;
 
-	addr = (unsigned long)mem_map;
-	page_count = max_mapnr;
+	tot_page_count = 0;
 	memset(page_counts, 0, sizeof(page_counts));
 
-	for (i = 0; i < page_count; i++) {
+	for_each_online_pgdat(pgdat) {
+	    if ((node_id != -1) && (pgdat->node_id != node_id))
+		continue;
+	    found_node = 1;
+	    addr = (unsigned long)pgdat->node_mem_map;
+	    page_count = pgdat->node_spanned_pages;
+	    tot_page_count += page_count;
+#else
+	    addr = (unsigned long)mem_map;
+	    page_count = max_mapnr;
+	    memset(page_counts, 0, sizeof(page_counts));
+#endif
+	    for (i = 0; i < page_count; i++) {
 		if ((diag = kdb_getarea(page, addr)))
 			return(diag);
 		addr += sizeof(page);
@@ -573,7 +598,9 @@
 			dirty_count++;
 		if (PageLocked(&page))
 			locked_count++;
-		if (page._count.counter < 8)
+		if (page._count.counter == -1)
+                        page_counts[9]++;
+		else if (page._count.counter < 8)
 			page_counts[page._count.counter]++;
 		else
 			page_counts[8]++;
@@ -584,9 +611,18 @@
 				delay_count++;
 #endif
 		}
-
+	    }
+#ifdef CONFIG_DISCONTIGMEM
 	}
-
+	page_count = tot_page_count;
+	if (node_id != -1) {
+	    if (!found_node) {
+		kdb_printf("Node %d does not exist.\n", node_id);
+		return 0;
+	    }
+	    kdb_printf("Node %d pages:\n", node_id);
+	}
+#endif
 	kdb_printf("  Total pages:      %6d\n", page_count);
 	kdb_printf("  Slab pages:       %6d\n", slab_count);
 	kdb_printf("  Dirty pages:      %6d\n", dirty_count);
@@ -595,6 +631,7 @@
 #ifdef buffer_delay
 	kdb_printf("  Delalloc pages:   %6d\n", delay_count);
 #endif
+	kdb_printf(" -1 page count:     %6d\n", page_counts[9]);
 	for (i = 0; i < 8; i++) {
 		kdb_printf("  %d page count:     %6d\n",
 			i, page_counts[i]);
@@ -602,7 +639,7 @@
 	kdb_printf("  high page count:  %6d\n", page_counts[8]);
 	return 0;
 }
-#endif /* CONFIG_X86 && !CONFIG_X86_64 */
+#endif /* CONFIG_X86 */
 
 static int __init kdbm_pg_init(void)
 {
@@ -616,8 +653,12 @@
 	kdb_register("inode_pages", kdbm_inode_pages, "<inode *>", "Display pages in an inode", 0);
 	kdb_register("req", kdbm_request, "<vaddr>", "dump request struct", 0);
 	kdb_register("rqueue", kdbm_rqueue, "<vaddr>", "dump request queue", 0);
-#if defined(CONFIG_X86) && !defined(CONFIG_X86_64)
+#ifdef CONFIG_X86
+#ifndef CONFIG_DISCONTIGMEM
 	kdb_register("memmap", kdbm_memmap, "", "page table summary", 0);
+#else
+	kdb_register("memmap", kdbm_memmap, "<nodeid>", "page table summary", 0);
+#endif
 #endif
 
 	return 0;
@@ -636,7 +677,7 @@
 	kdb_unregister("inode_pages");
 	kdb_unregister("req");
 	kdb_unregister("rqueue");
-#if defined(CONFIG_X86) && !defined(CONFIG_X86_64)
+#ifdef CONFIG_X86
 	kdb_unregister("memmap");
 #endif
 }
