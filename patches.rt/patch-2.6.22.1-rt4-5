Subject: Big -rt patchset update


---
 Makefile                   |    2 +-
 arch/i386/Makefile         |    4 ++--
 arch/i386/kernel/hpet.c    |    1 -
 arch/i386/kernel/process.c |    1 -
 include/asm-generic/bug.h  |   12 ------------
 include/linux/quicklist.h  |   19 +++++++++++++++----
 kernel/sched.c             |    2 --
 kernel/softirq.c           |    2 --
 mm/quicklist.c             |    9 +++++----
 9 files changed, 23 insertions(+), 29 deletions(-)

--- linux-2.6.22.orig/arch/i386/kernel/hpet.c
+++ linux-2.6.22/arch/i386/kernel/hpet.c
@@ -9,7 +9,6 @@
 #include <linux/pm.h>
 
 #include <asm/fixmap.h>
-#include <asm/i8253.h>
 #include <asm/hpet.h>
 #include <asm/i8253.h>
 #include <asm/io.h>
--- linux-2.6.22.orig/arch/i386/kernel/process.c
+++ linux-2.6.22/arch/i386/kernel/process.c
@@ -189,7 +189,6 @@ void cpu_idle(void)
 
 			tick_nohz_stop_sched_tick();
 
-			check_pgt_cache();
 			rmb();
 			idle = pm_idle;
 
--- linux-2.6.22.orig/arch/i386/Makefile
+++ linux-2.6.22/arch/i386/Makefile
@@ -31,7 +31,7 @@ LDFLAGS_vmlinux := --emit-relocs
 endif
 CHECKFLAGS	+= -D__i386__
 
-CFLAGS += -pipe -msoft-float
+CFLAGS += -pipe -msoft-float -freg-struct-return
 
 # prevent gcc from keeping the stack 16 byte aligned
 CFLAGS += $(call cc-option,-mpreferred-stack-boundary=2)
@@ -39,7 +39,7 @@ CFLAGS += $(call cc-option,-mpreferred-s
 # CPU-specific tuning. Anything which can be shared with UML should go here.
 include $(srctree)/arch/i386/Makefile.cpu
 
-cflags-$(CONFIG_REGPARM) += -mregparm=3 -freg-struct-return
+cflags-$(CONFIG_REGPARM) += -mregparm=3
 
 # temporary until string.h is fixed
 cflags-y += -ffreestanding
--- linux-2.6.22.orig/include/asm-generic/bug.h
+++ linux-2.6.22/include/asm-generic/bug.h
@@ -92,16 +92,4 @@ struct bug_entry {
 # define WARN_ON_NONRT(condition)	WARN_ON(condition)
 #endif
 
-#ifdef CONFIG_PREEMPT_RT
-# define BUG_ON_RT(c)			BUG_ON(c)
-# define BUG_ON_NONRT(c)		do { } while (0)
-# define WARN_ON_RT(condition)		WARN_ON(condition)
-# define WARN_ON_NONRT(condition)	do { } while (0)
-#else
-# define BUG_ON_RT(c)			do { } while (0)
-# define BUG_ON_NONRT(c)		BUG_ON(c)
-# define WARN_ON_RT(condition)		do { } while (0)
-# define WARN_ON_NONRT(condition)	WARN_ON(condition)
-#endif
-
 #endif
--- linux-2.6.22.orig/include/linux/quicklist.h
+++ linux-2.6.22/include/linux/quicklist.h
@@ -18,7 +18,7 @@ struct quicklist {
 	int nr_pages;
 };
 
-DECLARE_PER_CPU(struct quicklist, quicklist)[CONFIG_NR_QUICK];
+DECLARE_PER_CPU_LOCKED(struct quicklist, quicklist)[CONFIG_NR_QUICK];
 
 /*
  * The two key functions quicklist_alloc and quicklist_free are inline so
@@ -30,19 +30,30 @@ DECLARE_PER_CPU(struct quicklist, quickl
  * The fast patch in quicklist_alloc touched only a per cpu cacheline and
  * the first cacheline of the page itself. There is minmal overhead involved.
  */
-static inline void *quicklist_alloc(int nr, gfp_t flags, void (*ctor)(void *))
+static inline void *__quicklist_alloc(int cpu, int nr, gfp_t flags, void (*ctor)(void *))
 {
 	struct quicklist *q;
 	void **p = NULL;
 
-	q =&get_cpu_var(quicklist)[nr];
+	q = &__get_cpu_var_locked(quicklist, cpu)[nr];
 	p = q->page;
 	if (likely(p)) {
 		q->page = p[0];
 		p[0] = NULL;
 		q->nr_pages--;
 	}
-	put_cpu_var(quicklist);
+	return p;
+}
+
+static inline void *quicklist_alloc(int nr, gfp_t flags, void (*ctor)(void *))
+{
+	struct quicklist *q;
+	void **p = NULL;
+	int cpu;
+
+	(void)get_cpu_var_locked(quicklist, &cpu)[nr];
+	p = __quicklist_alloc(cpu, nr, flags, ctor);
+	put_cpu_var_locked(quicklist, cpu);
 	if (likely(p))
 		return p;
 
--- linux-2.6.22.orig/kernel/sched.c
+++ linux-2.6.22/kernel/sched.c
@@ -4924,7 +4924,6 @@ asmlinkage long sys_sched_yield(void)
 	 * no need to preempt or enable interrupts:
 	 */
 	spin_unlock_no_resched(&rq->lock);
-	rcu_read_unlock();
 
 	__schedule();
 
@@ -6699,7 +6698,6 @@ static void detach_destroy_domains(const
 
 	for_each_cpu_mask(i, *cpu_map)
 		cpu_attach_domain(NULL, i);
-	synchronize_sched();
 	arch_destroy_sched_domains(cpu_map);
 }
 
--- linux-2.6.22.orig/kernel/softirq.c
+++ linux-2.6.22/kernel/softirq.c
@@ -102,7 +102,6 @@ static void wakeup_softirqd(int softirq)
 
 	if (unlikely(!tsk))
 		return;
-#if 1
 #if defined(CONFIG_PREEMPT_SOFTIRQS) && defined(CONFIG_PREEMPT_HARDIRQS)
 	/*
 	 * Optimization: if we are in a hardirq thread context, and
@@ -117,7 +116,6 @@ static void wakeup_softirqd(int softirq)
 			(tsk->normal_prio == current->normal_prio))
 		return;
 #endif
-#endif
 	/*
 	 * Wake up the softirq task:
 	 */
--- linux-2.6.22.orig/Makefile
+++ linux-2.6.22/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 22
-EXTRAVERSION = .3-rc4
+EXTRAVERSION = .3-rc5
 NAME = Holy Dancing Manatees, Batman!
 
 # *DOCUMENTATION*
--- linux-2.6.22.orig/mm/quicklist.c
+++ linux-2.6.22/mm/quicklist.c
@@ -19,7 +19,7 @@
 #include <linux/module.h>
 #include <linux/quicklist.h>
 
-DEFINE_PER_CPU(struct quicklist, quicklist)[CONFIG_NR_QUICK];
+DEFINE_PER_CPU_LOCKED(struct quicklist, quicklist)[CONFIG_NR_QUICK];
 
 #define FRACTION_OF_NODE_MEM	16
 
@@ -51,8 +51,9 @@ void quicklist_trim(int nr, void (*dtor)
 {
 	long pages_to_free;
 	struct quicklist *q;
+	int cpu;
 
-	q = &get_cpu_var(quicklist)[nr];
+	q = &get_cpu_var_locked(quicklist, &cpu)[nr];
 	if (q->nr_pages > min_pages) {
 		pages_to_free = min_pages_to_free(q, min_pages, max_free);
 
@@ -61,7 +62,7 @@ void quicklist_trim(int nr, void (*dtor)
 			 * We pass a gfp_t of 0 to quicklist_alloc here
 			 * because we will never call into the page allocator.
 			 */
-			void *p = quicklist_alloc(nr, 0, NULL);
+			void *p = __quicklist_alloc(cpu, nr, 0, NULL);
 
 			if (dtor)
 				dtor(p);
@@ -69,7 +70,7 @@ void quicklist_trim(int nr, void (*dtor)
 			pages_to_free--;
 		}
 	}
-	put_cpu_var(quicklist);
+	put_cpu_var_locked(quicklist, cpu);
 }
 
 unsigned long quicklist_total_size(void)
