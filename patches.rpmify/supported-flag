From: Andreas Gruenbacher <agruen@suse.de>
Subject: Novell/external support flag in modules

Upon module load, check if a module is supported, and set the
U (TAINT_NO_SUPPORT) or X (TAINT_EXTERNAL_SUPPORT) tail flags
for unsupported or externally suported modules.

Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

 Documentation/kernel-parameters.txt |    6 +++
 Documentation/sysctl/kernel.txt     |   11 +++++
 Makefile                            |    5 ++
 include/linux/kernel.h              |    3 +
 include/linux/sysctl.h              |    1 
 kernel/module.c                     |   38 +++++++++++++++++++
 kernel/panic.c                      |    8 +++-
 kernel/sysctl.c                     |   10 +++++
 scripts/Makefile.modpost            |    2 +
 scripts/mod/modpost.c               |   70 +++++++++++++++++++++++++++++++++++-
 10 files changed, 150 insertions(+), 4 deletions(-)

Index: linux-2.6.15/Documentation/kernel-parameters.txt
===================================================================
--- linux-2.6.15.orig/Documentation/kernel-parameters.txt
+++ linux-2.6.15/Documentation/kernel-parameters.txt
@@ -1483,6 +1483,12 @@ running once the system is up.
 	stifb=		[HW]
 			Format: bpp:<bpp1>[:<bpp2>[:<bpp3>...]]
 
+	unsupported	Allow loading of unsupported kernel modules:
+			0 = only allow supported modules,
+			1 = warn when loading unsupported modules,
+			2 = don't warn.
+			
+
 	swiotlb=	[IA-64] Number of I/O TLB slabs
 
 	switches=	[HW,M68k]
Index: linux-2.6.15/Documentation/sysctl/kernel.txt
===================================================================
--- linux-2.6.15.orig/Documentation/sysctl/kernel.txt
+++ linux-2.6.15/Documentation/sysctl/kernel.txt
@@ -331,4 +331,15 @@ can be ORed together:
   2 - A module was force loaded by insmod -f.
       Set by modutils >= 2.4.9 and module-init-tools.
   4 - Unsafe SMP processors: SMP with CPUs not designed for SMP.
+ 64 - An unsupported kernel module was loaded.
+
+==============================================================
+
+unsupported:
+
+Allow to load unsupported kernel modules:
+
+  0 - refuse to load unsupported modules,
+  1 - warn when loading unsupported modules,
+  2 - don't warn.
 
Index: linux-2.6.15/include/linux/kernel.h
===================================================================
--- linux-2.6.15.orig/include/linux/kernel.h
+++ linux-2.6.15/include/linux/kernel.h
@@ -175,6 +175,7 @@ extern int oops_in_progress;		/* If set,
 extern __deprecated_for_modules int panic_timeout;
 extern int panic_on_oops;
 extern int tainted;
+extern int unsupported;
 extern const char *print_tainted(void);
 extern void add_taint(unsigned);
 
@@ -193,6 +194,8 @@ extern enum system_states {
 #define TAINT_FORCED_RMMOD		(1<<3)
 #define TAINT_MACHINE_CHECK		(1<<4)
 #define TAINT_BAD_PAGE			(1<<5)
+#define TAINT_NO_SUPPORT		(1<<6)
+#define TAINT_EXTERNAL_SUPPORT		(1<<7)
 
 extern void dump_stack(void);
 
Index: linux-2.6.15/include/linux/sysctl.h
===================================================================
--- linux-2.6.15.orig/include/linux/sysctl.h
+++ linux-2.6.15/include/linux/sysctl.h
@@ -146,6 +146,7 @@ enum
 	KERN_RANDOMIZE=68, /* int: randomize virtual address space */
 	KERN_SETUID_DUMPABLE=69, /* int: behaviour of dumps for setuid core */
 	KERN_SPIN_RETRY=70,	/* int: number of spinlock retries */
+	KERN_UNSUPPORTED=71,	/* int: allow loading of unsupported modules */
 };
 
 
Index: linux-2.6.15/kernel/module.c
===================================================================
--- linux-2.6.15.orig/kernel/module.c
+++ linux-2.6.15/kernel/module.c
@@ -56,6 +56,20 @@
 /* If this is set, the section belongs in the init part of the module */
 #define INIT_OFFSET_MASK (1UL << (BITS_PER_LONG-1))
 
+/* Allow unsupported modules switch. */ 
+#ifdef UNSUPPORTED_MODULES
+int unsupported = UNSUPPORTED_MODULES;
+#else
+int unsupported = 2;  /* don't warn when loading unsupported modules. */
+#endif
+
+static int __init unsupported_setup(char *str)
+{
+	get_option(&str, &unsupported);
+	return 1;
+}
+__setup("unsupported=", unsupported_setup);
+
 /* Protects module list */
 static DEFINE_SPINLOCK(modlist_lock);
 
@@ -1534,7 +1548,7 @@ static struct module *load_module(void _
 {
 	Elf_Ehdr *hdr;
 	Elf_Shdr *sechdrs;
-	char *secstrings, *args, *modmagic, *strtab = NULL;
+	char *secstrings, *args, *modmagic, *strtab = NULL, *supported;
 	unsigned int i, symindex = 0, strindex = 0, setupindex, exindex,
 		exportindex, modindex, obsparmindex, infoindex, gplindex,
 		crcindex, gplcrcindex, versindex, pcpuindex;
@@ -1654,6 +1668,28 @@ static struct module *load_module(void _
 		goto free_hdr;
 	}
 
+	supported = get_modinfo(sechdrs, infoindex, "supported");
+	if (supported) {
+		if (!strcmp(supported, "external"))
+			tainted |= TAINT_EXTERNAL_SUPPORT;
+		else if (strcmp(supported, "yes"))
+			supported = NULL;
+	}
+	if (!supported) {
+		if (unsupported == 0) {
+			printk(KERN_WARNING "%s: module not supported by "
+			       "Novell, refusing to load. To override, echo "
+			       "1 > /proc/sys/kernel/unsupported\n", mod->name);
+			err = -ENOEXEC;
+			goto free_hdr;
+		}
+		tainted |= TAINT_NO_SUPPORT;
+		if (unsupported == 1) {
+			printk(KERN_WARNING "%s: module not supported by "
+			       "Novell, setting U taint flag.\n", mod->name);
+		}
+	}
+
 	/* Now copy in args */
 	arglen = strlen_user(uargs);
 	if (!arglen) {
Index: linux-2.6.15/kernel/panic.c
===================================================================
--- linux-2.6.15.orig/kernel/panic.c
+++ linux-2.6.15/kernel/panic.c
@@ -147,6 +147,8 @@ EXPORT_SYMBOL(panic);
  *  'R' - User forced a module unload.
  *  'M' - Machine had a machine check experience.
  *  'B' - System has hit bad_page.
+ *  'U' - Unsuported modules loaded.
+ *  'X' - Modules with external support loaded.
  *
  *	The string is overwritten by the next call to print_taint().
  */
@@ -155,13 +157,15 @@ const char *print_tainted(void)
 {
 	static char buf[20];
 	if (tainted) {
-		snprintf(buf, sizeof(buf), "Tainted: %c%c%c%c%c%c",
+		snprintf(buf, sizeof(buf), "Tainted: %c%c%c%c%c%c%c",
 			tainted & TAINT_PROPRIETARY_MODULE ? 'P' : 'G',
 			tainted & TAINT_FORCED_MODULE ? 'F' : ' ',
 			tainted & TAINT_UNSAFE_SMP ? 'S' : ' ',
 			tainted & TAINT_FORCED_RMMOD ? 'R' : ' ',
  			tainted & TAINT_MACHINE_CHECK ? 'M' : ' ',
-			tainted & TAINT_BAD_PAGE ? 'B' : ' ');
+			tainted & TAINT_BAD_PAGE ? 'B' : ' ',
+			tainted & TAINT_NO_SUPPORT ? 'U' :
+				(tainted & TAINT_EXTERNAL_SUPPORT ? 'X' : ' '));
 	}
 	else
 		snprintf(buf, sizeof(buf), "Not tainted");
Index: linux-2.6.15/kernel/sysctl.c
===================================================================
--- linux-2.6.15.orig/kernel/sysctl.c
+++ linux-2.6.15/kernel/sysctl.c
@@ -305,6 +305,16 @@ static ctl_table kern_table[] = {
 		.mode		= 0444,
 		.proc_handler	= &proc_dointvec,
 	},
+#ifdef CONFIG_MODULES
+	{
+		.ctl_name	= KERN_UNSUPPORTED,
+		.procname	= "unsupported",
+		.data		= &unsupported,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 	{
 		.ctl_name	= KERN_CAP_BSET,
 		.procname	= "cap-bound",
Index: linux-2.6.15/Makefile
===================================================================
--- linux-2.6.15.orig/Makefile
+++ linux-2.6.15/Makefile
@@ -336,6 +336,11 @@ CFLAGS 		:= -Wall -Wundef -Wstrict-proto
 		   -ffreestanding
 AFLAGS		:= -D__ASSEMBLY__
 
+# Warn about unsupported modules in kernels built inside Autobuild
+ifneq ($(wildcard /.buildenv),)
+CFLAGS		+= -DUNSUPPORTED_MODULES=1
+endif
+
 ifneq ($(wildcard $(srctree)/rpm-release),)
 RPM_RELEASE := -$(shell cat $(srctree)/rpm-release)
 endif
Index: linux-2.6.15/scripts/Makefile.modpost
===================================================================
--- linux-2.6.15.orig/scripts/Makefile.modpost
+++ linux-2.6.15/scripts/Makefile.modpost
@@ -55,6 +55,8 @@ quiet_cmd_modpost = MODPOST
         $(if $(CONFIG_MODVERSIONS),-m)             \
 	$(if $(CONFIG_MODULE_SRCVERSION_ALL),-a,)  \
 	$(if $(KBUILD_EXTMOD),-i,-o) $(symverfile) \
+	-s $(firstword $(wildcard $(dir $(MODVERDIR))/Module.supported \
+				  $(objtree)/Module.supported /dev/null)) \
 	$(filter-out FORCE,$^)
 
 .PHONY: __modpost
Index: linux-2.6.15/scripts/mod/modpost.c
===================================================================
--- linux-2.6.15.orig/scripts/mod/modpost.c
+++ linux-2.6.15/scripts/mod/modpost.c
@@ -446,6 +446,50 @@ static char *get_modinfo(void *modinfo, 
 	return NULL;
 }
 
+static struct {
+	void *file;
+	unsigned long size;
+} supp;
+
+const char *
+supported(struct module *mod)
+{
+	unsigned long pos = 0;
+	char *line;
+
+	/* In a first shot, do a simple linear scan. */
+	while ((line = get_next_line(&pos, supp.file, supp.size))) {
+		const char *basename, *how = "yes";
+		char *l = line;
+
+		/* optional type-of-support flag */
+		for (l = line; *l != '\0'; l++) {
+			if (*l == ' ' || *l == '\t') {
+				*l = '\0';
+				how = l + 1;
+				break;
+			}
+		}
+
+		/* skip directory components */
+		if ((l = strrchr(line, '/')))
+			line = l + 1;
+		/* strip .ko extension */
+		l = line + strlen(line);
+		if (l - line > 3 && !strcmp(l-3, ".ko"))
+			*(l-3) = '\0';
+
+		/* skip directory components */
+		if ((basename = strrchr(mod->name, '/')))
+			basename++;
+		else
+			basename = mod->name;
+		if (!strcmp(basename, line))
+			return how;
+	}
+	return NULL;
+}
+
 void
 read_symbols(char *modname)
 {
@@ -551,6 +595,14 @@ add_header(struct buffer *b, struct modu
 	buf_printf(b, "};\n");
 }
 
+void
+add_supported_flag(struct buffer *b, struct module *mod)
+{
+	const char *how = supported(mod);
+	if (how)
+		buf_printf(b, "\nMODULE_INFO(supported, \"%s\");\n", how);
+}
+
 /* Record CRCs for unresolved symbols */
 
 void
@@ -682,6 +734,14 @@ write_if_changed(struct buffer *b, const
 }
 
 void
+read_supported(const char *fname)
+{
+	supp.file = grab_file(fname, &supp.size);
+	if (!supp.file)
+		; /* ignore error */
+}
+
+void
 read_dump(const char *fname)
 {
 	unsigned long size, pos = 0;
@@ -755,9 +815,10 @@ main(int argc, char **argv)
 	struct buffer buf = { };
 	char fname[SZ];
 	char *dump_read = NULL, *dump_write = NULL;
+	char *supp = NULL;
 	int opt;
 
-	while ((opt = getopt(argc, argv, "i:mo:a")) != -1) {
+	while ((opt = getopt(argc, argv, "i:mo:as:")) != -1) {
 		switch(opt) {
 			case 'i':
 				dump_read = optarg;
@@ -771,11 +832,17 @@ main(int argc, char **argv)
 			case 'a':
 				all_versions = 1;
 				break;
+			case 's':
+				supp = optarg;
+				break;
 			default:
 				exit(1);
 		}
 	}
 
+	if (supp)
+		read_supported(supp);
+
 	if (dump_read)
 		read_dump(dump_read);
 
@@ -790,6 +857,7 @@ main(int argc, char **argv)
 		buf.pos = 0;
 
 		add_header(&buf, mod);
+		add_supported_flag(&buf, mod);
 		add_versions(&buf, mod);
 		add_depends(&buf, mod, modules);
 		add_moddevtable(&buf, mod);
