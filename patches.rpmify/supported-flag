Index: linux-2.6.5/kernel/module.c
===================================================================
--- linux-2.6.5.orig/kernel/module.c
+++ linux-2.6.5/kernel/module.c
@@ -1269,7 +1269,7 @@ static struct module *load_module(void _
 {
 	Elf_Ehdr *hdr;
 	Elf_Shdr *sechdrs;
-	char *secstrings, *args, *modmagic, *strtab = NULL;
+	char *secstrings, *args, *modmagic, *strtab = NULL, *supported;
 	unsigned int i, symindex = 0, strindex = 0, setupindex, exindex,
 		exportindex, modindex, obsparmindex, infoindex, gplindex,
 		crcindex, gplcrcindex, versindex, pcpuindex;
@@ -1384,6 +1384,13 @@ static struct module *load_module(void _
 		goto free_hdr;
 	}
 
+	supported = get_modinfo(sechdrs, infoindex, "supported");
+	if (!supported || strcmp(supported, "yes")) {
+		tainted |= TAINT_FORCED_MODULE;
+		printk(KERN_WARNING "%s: unsupported module, tainting "
+		       "kernel.\n", mod->name);
+	}
+
 	/* Now copy in args */
 	arglen = strlen_user(uargs);
 	if (!arglen) {
Index: linux-2.6.5/scripts/Makefile.modpost
===================================================================
--- linux-2.6.5.orig/scripts/Makefile.modpost
+++ linux-2.6.5/scripts/Makefile.modpost
@@ -52,6 +52,7 @@ _modpost: $(modules)
 quiet_cmd_modpost = MODPOST
       cmd_modpost = scripts/modpost \
 	$(if $(KBUILD_EXTMOD),-i,-o) $(symverfile) \
+	-s $(objtree)/Module.supported \
 	$(filter-out FORCE,$^)
 
 .PHONY: __modpost
Index: linux-2.6.5/scripts/modpost.c
===================================================================
--- linux-2.6.5.orig/scripts/modpost.c
+++ linux-2.6.5/scripts/modpost.c
@@ -392,6 +392,31 @@ is_vmlinux(const char *modname)
 	return strcmp(myname, "vmlinux") == 0;
 }
 
+static struct {
+	void *file;
+	unsigned long size;
+} supp;
+
+int
+supported(struct module *mod)
+{
+	unsigned long pos = 0;
+	char *line, *basename;
+
+	/* In a first shot, do a simple linear scan. */
+	while ((line = get_next_line(&pos, supp.file,
+				     supp.size))) {
+		basename = strrchr(mod->name, '/');
+		if (!basename)
+			basename = line;
+		else
+			basename++;
+		if (!strcmp(basename, line))
+			return 1;
+	}
+	return 0;
+}
+
 void
 read_symbols(char *modname)
 {
@@ -496,6 +521,13 @@ add_header(struct buffer *b)
 	buf_printf(b, "};\n");
 }
 
+void
+add_supported_flag(struct buffer *b, struct module *mod)
+{
+	if (supported(mod))
+		buf_printf(b, "\nMODULE_INFO(supported, \"yes\");\n");
+}
+
 /* Record CRCs for unresolved symbols */
 
 void
@@ -617,6 +649,14 @@ write_if_changed(struct buffer *b, const
 }
 
 void
+read_supported(const char *fname)
+{
+	supp.file = grab_file(fname, &supp.size);
+	if (!supp.file)
+		; /* ignore error */
+}
+
+void
 read_dump(const char *fname)
 {
 	unsigned long size, pos = 0;
@@ -691,9 +733,10 @@ main(int argc, char **argv)
 	struct buffer buf = { };
 	char fname[SZ];
 	char *dump_read = NULL, *dump_write = NULL;
+	char *supp = NULL;
 	int opt;
 
-	while ((opt = getopt(argc, argv, "i:o:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:o:s:")) != -1) {
 		switch(opt) {
 			case 'i':
 				dump_read = optarg;
@@ -701,11 +744,17 @@ main(int argc, char **argv)
 			case 'o':
 				dump_write = optarg;
 				break;
+			case 's':
+				supp = optarg;
+				break;
 			default:
 				exit(1);
 		}
 	}
 
+	if (supp)
+		read_supported(supp);
+
 	if (dump_read)
 		read_dump(dump_read);
 
@@ -720,6 +769,7 @@ main(int argc, char **argv)
 		buf.pos = 0;
 
 		add_header(&buf);
+		add_supported_flag(&buf, mod);
 		add_versions(&buf, mod);
 		add_depends(&buf, mod, modules);
 		add_moddevtable(&buf, mod);
