Index: linux-2.6.0-test11/Makefile
===================================================================
--- linux-2.6.0-test11.orig/Makefile	2003-12-16 16:03:49.000000000 +0100
+++ linux-2.6.0-test11/Makefile	2003-12-16 23:28:03.702097153 +0100
@@ -592,7 +592,6 @@
 ifdef KBUILD_MODULES
 ifeq ($(origin SUBDIRS),file)
 	$(Q)rm -rf $(MODVERDIR)
-	$(if $(CONFIG_MODULES),$(Q)mkdir -p $(MODVERDIR))
 else
 	@echo '*** Warning: Overriding SUBDIRS on the command line can cause'
 	@echo '***          inconsistencies'
Index: linux-2.6.0-test11/scripts/modpost.c
===================================================================
--- linux-2.6.0-test11.orig/scripts/modpost.c	2003-12-16 18:15:14.000000000 +0100
+++ linux-2.6.0-test11/scripts/modpost.c	2003-12-17 01:31:07.561857319 +0100
@@ -14,9 +14,9 @@
 #include "modpost.h"
 
 /* Are we using CONFIG_MODVERSIONS? */
-int modversions = 0;
-/* Do we have vmlinux? */
-int have_vmlinux = 0;
+int modversions_enabled = 0;
+/* Warn about undefined symbols? */
+int report_undefined_symbols = 0;
 
 void
 fatal(const char *fmt, ...)
@@ -60,6 +60,17 @@
 static struct module *modules;
 
 struct module *
+find_module(char *modname)
+{
+	struct module *mod;
+
+	for (mod = modules; mod; mod = mod->next)
+		if (strcmp(mod->name, modname) == 0)
+			break;
+	return mod;
+}
+
+struct module *
 new_module(char *modname)
 {
 	struct module *mod;
@@ -165,7 +176,7 @@
 	struct symbol *s = find_symbol(name);
 
 	if (!s) {
-		new_symbol(name, modules, crc);
+		new_symbol(name, module, crc);
 		return;
 	}
 	if (crc) {
@@ -286,7 +297,7 @@
 			crc = (unsigned int) sym->st_value;
 			add_exported_symbol(symname + strlen(CRC_PFX),
 					    mod, &crc);
-			modversions = 1;
+			modversions_enabled = 1;
 		}
 		break;
 	case SHN_UNDEF:
@@ -333,15 +344,17 @@
 	struct symbol *s;
 	Elf_Sym *sym;
 
-	/* When there's no vmlinux, don't print warnings about
-	 * unresolved symbols (since there'll be too many ;) */
-	if (strcmp(modname, "vmlinux") == 0)
-		have_vmlinux = 1;
-
 	parse_elf(&info, modname);
 
 	mod = new_module(modname);
 
+	/* When we have vmlinux, print warnings about unresolved
+	 * symbols. (Otherwise, there might be too many). */
+	if (strcmp(modname, "vmlinux") == 0) {
+		report_undefined_symbols = 1;
+		mod->skip = 1;
+	}
+
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
 		symname = info.strtab + sym->st_name;
 
@@ -354,7 +367,7 @@
 	 * never passed as an argument to an exported function, so
 	 * the automatic versioning doesn't pick it up, but it's really
 	 * important anyhow */
-	if (modversions) {
+	if (modversions_enabled) {
 		s = alloc_symbol("struct_module");
 		/* add to list */
 		s->next = mod->unres;
@@ -419,7 +432,7 @@
 	for (s = mod->unres; s; s = s->next) {
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
-			if (have_vmlinux)
+			if (report_undefined_symbols)
 				fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
 				"undefined!\n",	s->name, mod->name);
 			continue;
@@ -429,7 +442,7 @@
 		s->crc = exp->crc;
 	}
 
-	if (!modversions)
+	if (!modversions_enabled)
 		return;
 
 	buf_printf(b, "\n");
@@ -531,19 +544,91 @@
 	fclose(file);
 }
 
+void
+read_dump(FILE *file)
+{
+	unsigned int crc;
+	char symname[128], modname[4096];
+
+	while (fscanf(file, "%x %128s %4096s", &crc, symname, modname) == 3) {
+		struct module *mod;
+		if (!(mod = find_module(modname))) {
+			mod = new_module(NOFAIL(strdup(modname)));
+			mod->skip = 1;
+		}
+		add_exported_symbol(symname, mod, &crc);
+	}
+	if (!feof(file)) {
+		fatal("parse error in symbol dump file\n");
+	}
+}
+
+void
+write_dump(FILE *file)
+{
+	struct symbol *symbol;
+	int n;
+
+	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
+		symbol = symbolhash[n];
+		while (symbol) {
+			symbol = symbol->next;
+		}
+	}
+
+	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
+		symbol = symbolhash[n];
+		while (symbol) {
+			fprintf(file, "0x%08x\t%s\t%s\n", symbol->crc,
+				symbol->name, symbol->module->name);
+			symbol = symbol->next;
+		}
+	}
+}
+
 int
 main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
 	char fname[SZ];
+	char *read_dumpfile = NULL, *write_dumpfile = NULL;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "i:o:")) != -1) {
+		switch(opt) {
+			case 'i':
+				read_dumpfile = optarg;
+				modversions_enabled = 1;
+				report_undefined_symbols = 1;
+				break;
+			case 'o':
+				write_dumpfile = optarg;
+				break;
+			default:
+				exit(1);
+		}
+	}
+
+	if (read_dumpfile) {
+		FILE *file = fopen(read_dumpfile, "r");
+		if (!file) {
+			perror(fname);
+			exit(1);
+		}
+		read_dump(file);
+		if (fclose(file) != 0) {
+			perror(fname);
+			exit(1);
+		}
+	}
 
-	for (; argv[1]; argv++) {
-		read_symbols(argv[1]);
+	while (optind < argc) {
+		read_symbols(argv[optind++]);
 	}
 
 	for (mod = modules; mod; mod = mod->next) {
-		if (strcmp(mod->name, "vmlinux") == 0)
+		if (mod->skip)
 			continue;
 
 		buf.pos = 0;
@@ -556,6 +641,20 @@
 		sprintf(fname, "%s.mod.c", mod->name);
 		write_if_changed(&buf, fname);
 	}
+
+	if (write_dumpfile) {
+		FILE *file = fopen(write_dumpfile, "w");
+		if (!file) {
+			perror(fname);
+			exit(1);
+		}
+		write_dump(file);
+		if (fclose(file) != 0) {
+			perror(fname);
+			exit(1);
+		}
+	}
+
 	return 0;
 }
 
Index: linux-2.6.0-test11/scripts/modpost.h
===================================================================
--- linux-2.6.0-test11.orig/scripts/modpost.h	2003-11-26 21:42:38.000000000 +0100
+++ linux-2.6.0-test11/scripts/modpost.h	2003-12-17 00:49:41.695105429 +0100
@@ -70,6 +70,7 @@
 	const char *name;
 	struct symbol *unres;
 	int seen;
+	int skip;
 	struct buffer dev_table_buf;
 };
 
Index: linux-2.6.0-test11/scripts/Makefile.modpost
===================================================================
--- linux-2.6.0-test11.orig/scripts/Makefile.modpost	2003-11-26 21:44:20.000000000 +0100
+++ linux-2.6.0-test11/scripts/Makefile.modpost	2003-12-17 01:32:39.760880982 +0100
@@ -52,9 +52,21 @@
 # Extract all checksums for all exported symbols
 
 quiet_cmd_modpost = MODPOST
+ifeq ($(origin SUBDIRS),file)
       cmd_modpost = scripts/modpost $(filter-out FORCE,$^)
+else
+define cmd_modpost
+	if test -e modversions; then					\
+	    scripts/modpost $(if $(CONFIG_MODVERSIONS),-i modversions)	\
+			    $(filter-out FORCE,$^);			\
+	else								\
+	    scripts/modpost $(filter-out FORCE,$^);			\
+	fi
+endef
+endif
 
 __modpost: $(wildcard vmlinux) $(modules:.ko=.o) FORCE
+	$(Q)mkdir -p $(MODVERDIR)
 	$(call if_changed,modpost)
 
 targets += __modpost
