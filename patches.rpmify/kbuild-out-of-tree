Index: linux-2.6.0-0.build/Makefile
===================================================================
--- linux-2.6.0-0.build.orig/Makefile	2003-12-19 01:13:38.000000000 +0000
+++ linux-2.6.0-0.build/Makefile	2003-12-19 01:14:09.000000000 +0000
@@ -293,7 +293,10 @@
 export CFLAGS CFLAGS_KERNEL CFLAGS_MODULE 
 export AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
 
-export MODVERDIR := .tmp_versions
+# When compiling out-of-tree modules, put MODVERDIR in the module source
+# tree rather than in the kernel source tree. The kernel source tree might
+# even be read-only.
+export MODVERDIR := $(shell D="$(firstword $(SUBDIRS))"; test "$${D:0:1}" = / -a "$${D\#$$PWD}" = "$$D" && echo "$$D/").tmp_versions
 
 # The temporary file to save gcc -MD generated dependencies must not
 # contain a comma
@@ -1036,12 +1039,13 @@
 	@set -e;				\
 	echo '  CHK     $@';			\
 	mkdir -p $(dir $@);			\
-	$(filechk_$(1)) < $< > $@.tmp;		\
-	if [ -r $@ ] && cmp -s $@ $@.tmp; then	\
-		rm -f $@.tmp;			\
+	tmp=$$(/bin/mktemp /tmp/kbuild.XXXXXX);	\
+	$(filechk_$(1)) < $< > $$tmp;		\
+	if [ -r $@ ] && cmp -s $@ $$tmp; then	\
+		rm -f $$tmp;			\
 	else					\
 		echo '  UPD     $@';		\
-		mv -f $@.tmp $@;		\
+		mv -f $$tmp $@;		\
 	fi
 endef
 
Index: linux-2.6.0-0.build/scripts/modpost.c
===================================================================
--- linux-2.6.0-0.build.orig/scripts/modpost.c	2003-12-18 22:10:32.000000000 +0000
+++ linux-2.6.0-0.build/scripts/modpost.c	2003-12-19 01:13:51.000000000 +0000
@@ -14,9 +14,9 @@
 #include "modpost.h"
 
 /* Are we using CONFIG_MODVERSIONS? */
-int modversions = 0;
-/* Do we have vmlinux? */
-int have_vmlinux = 0;
+int modversions_enabled = 0;
+/* Warn about undefined symbols? */
+int report_undefined_symbols = 0;
 
 void
 fatal(const char *fmt, ...)
@@ -60,6 +60,17 @@
 static struct module *modules;
 
 struct module *
+find_module(char *modname)
+{
+	struct module *mod;
+
+	for (mod = modules; mod; mod = mod->next)
+		if (strcmp(mod->name, modname) == 0)
+			break;
+	return mod;
+}
+
+struct module *
 new_module(char *modname)
 {
 	struct module *mod;
@@ -165,7 +176,7 @@
 	struct symbol *s = find_symbol(name);
 
 	if (!s) {
-		new_symbol(name, modules, crc);
+		new_symbol(name, module, crc);
 		return;
 	}
 	if (crc) {
@@ -286,7 +297,7 @@
 			crc = (unsigned int) sym->st_value;
 			add_exported_symbol(symname + strlen(CRC_PFX),
 					    mod, &crc);
-			modversions = 1;
+			modversions_enabled = 1;
 		}
 		break;
 	case SHN_UNDEF:
@@ -333,15 +344,17 @@
 	struct symbol *s;
 	Elf_Sym *sym;
 
-	/* When there's no vmlinux, don't print warnings about
-	 * unresolved symbols (since there'll be too many ;) */
-	if (strcmp(modname, "vmlinux") == 0)
-		have_vmlinux = 1;
-
 	parse_elf(&info, modname);
 
 	mod = new_module(modname);
 
+	/* When we have vmlinux, print warnings about unresolved
+	 * symbols. (Otherwise, there might be too many). */
+	if (strcmp(modname, "vmlinux") == 0) {
+		report_undefined_symbols = 1;
+		mod->skip = 1;
+	}
+
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
 		symname = info.strtab + sym->st_name;
 
@@ -354,7 +367,7 @@
 	 * never passed as an argument to an exported function, so
 	 * the automatic versioning doesn't pick it up, but it's really
 	 * important anyhow */
-	if (modversions) {
+	if (modversions_enabled) {
 		s = alloc_symbol("struct_module");
 		/* add to list */
 		s->next = mod->unres;
@@ -419,7 +432,7 @@
 	for (s = mod->unres; s; s = s->next) {
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
-			if (have_vmlinux)
+			if (report_undefined_symbols)
 				fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
 				"undefined!\n",	s->name, mod->name);
 			continue;
@@ -429,7 +442,7 @@
 		s->crc = exp->crc;
 	}
 
-	if (!modversions)
+	if (!modversions_enabled)
 		return;
 
 	buf_printf(b, "\n");
@@ -531,19 +544,91 @@
 	fclose(file);
 }
 
+void
+read_dump(FILE *file)
+{
+	unsigned int crc;
+	char symname[128], modname[4096];
+
+	while (fscanf(file, "%x %128s %4096s", &crc, symname, modname) == 3) {
+		struct module *mod;
+		if (!(mod = find_module(modname))) {
+			mod = new_module(NOFAIL(strdup(modname)));
+			mod->skip = 1;
+		}
+		add_exported_symbol(symname, mod, &crc);
+	}
+	if (!feof(file)) {
+		fatal("parse error in symbol dump file\n");
+	}
+}
+
+void
+write_dump(FILE *file)
+{
+	struct symbol *symbol;
+	int n;
+
+	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
+		symbol = symbolhash[n];
+		while (symbol) {
+			symbol = symbol->next;
+		}
+	}
+
+	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
+		symbol = symbolhash[n];
+		while (symbol) {
+			fprintf(file, "0x%08x\t%s\t%s\n", symbol->crc,
+				symbol->name, symbol->module->name);
+			symbol = symbol->next;
+		}
+	}
+}
+
 int
 main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
 	char fname[SZ];
+	char *read_dumpfile = NULL, *write_dumpfile = NULL;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "i:o:")) != -1) {
+		switch(opt) {
+			case 'i':
+				read_dumpfile = optarg;
+				modversions_enabled = 1;
+				report_undefined_symbols = 1;
+				break;
+			case 'o':
+				write_dumpfile = optarg;
+				break;
+			default:
+				exit(1);
+		}
+	}
+
+	if (read_dumpfile) {
+		FILE *file = fopen(read_dumpfile, "r");
+		if (!file) {
+			perror(read_dumpfile);
+			exit(1);
+		}
+		read_dump(file);
+		if (fclose(file) != 0) {
+			perror(read_dumpfile);
+			exit(1);
+		}
+	}
 
-	for (; argv[1]; argv++) {
-		read_symbols(argv[1]);
+	while (optind < argc) {
+		read_symbols(argv[optind++]);
 	}
 
 	for (mod = modules; mod; mod = mod->next) {
-		if (strcmp(mod->name, "vmlinux") == 0)
+		if (mod->skip)
 			continue;
 
 		buf.pos = 0;
@@ -556,6 +641,20 @@
 		sprintf(fname, "%s.mod.c", mod->name);
 		write_if_changed(&buf, fname);
 	}
+
+	if (write_dumpfile) {
+		FILE *file = fopen(write_dumpfile, "w");
+		if (!file) {
+			perror(write_dumpfile);
+			exit(1);
+		}
+		write_dump(file);
+		if (fclose(file) != 0) {
+			perror(write_dumpfile);
+			exit(1);
+		}
+	}
+
 	return 0;
 }
 
Index: linux-2.6.0-0.build/scripts/modpost.h
===================================================================
--- linux-2.6.0-0.build.orig/scripts/modpost.h	2003-12-18 22:10:32.000000000 +0000
+++ linux-2.6.0-0.build/scripts/modpost.h	2003-12-19 01:13:51.000000000 +0000
@@ -70,6 +70,7 @@
 	const char *name;
 	struct symbol *unres;
 	int seen;
+	int skip;
 	struct buffer dev_table_buf;
 };
 
Index: linux-2.6.0-0.build/scripts/Makefile.modpost
===================================================================
--- linux-2.6.0-0.build.orig/scripts/Makefile.modpost	2003-12-18 22:10:32.000000000 +0000
+++ linux-2.6.0-0.build/scripts/Makefile.modpost	2003-12-19 01:13:51.000000000 +0000
@@ -52,10 +52,16 @@
 # Extract all checksums for all exported symbols
 
 quiet_cmd_modpost = MODPOST
-      cmd_modpost = scripts/modpost $(filter-out FORCE,$^)
-
+ifeq ($(origin SUBDIRS),command line)
+      cmd_modpost = scripts/modpost $(filter-out FORCE,$^) \
+				    $(if $(wildcard modversions),-i modversions)
+__modpost: $(modules:.ko=.o)
+	$(call exec_cmd,modpost)
+else
+      cmd_modpost = scripts/modpost $(filter-out FORCE,$^) -o modversions
 __modpost: $(wildcard vmlinux) $(modules:.ko=.o) FORCE
 	$(call if_changed,modpost)
+endif
 
 targets += __modpost
 
Index: linux-2.6.0-0.build/scripts/Makefile.lib
===================================================================
--- linux-2.6.0-0.build.orig/scripts/Makefile.lib	2003-12-18 21:34:13.000000000 +0000
+++ linux-2.6.0-0.build/scripts/Makefile.lib	2003-12-19 01:13:51.000000000 +0000
@@ -228,15 +228,16 @@
 # >'< substitution is for echo to work, >$< substitution to preserve $ when reloading .cmd file
 # note: when using inline perl scripts [perl -e '...$$t=1;...'] in $(cmd_xxx) double $$ your perl vars
 
+exec_cmd = @set -e; \
+	$(if $($(quiet)cmd_$(1)),echo '  $(subst ','\'',$($(quiet)cmd_$(1)))';) \
+	$(cmd_$(1))
+
 if_changed = $(if $(strip $? \
 		          $(filter-out $(cmd_$(1)),$(cmd_$@))\
 			  $(filter-out $(cmd_$@),$(cmd_$(1)))),\
-	@set -e; \
-	$(if $($(quiet)cmd_$(1)),echo '  $(subst ','\'',$($(quiet)cmd_$(1)))';) \
-	$(cmd_$(1)); \
+	$(call exec_cmd,$(1)); \
 	echo 'cmd_$@ := $(subst $$,$$$$,$(subst ','\'',$(cmd_$(1))))' > $(@D)/.$(@F).cmd)
 
-
 # execute the command and also postprocess generated .d dependencies
 # file
 
