From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 2.6.30-rc3

 This patch contains the differences between 2.6.30-rc2 and -rc3.

Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 .gitignore                                          |    1 
 Documentation/block/biodoc.txt                      |   19 
 Documentation/driver-model/platform.txt             |   59 +
 Documentation/filesystems/pohmelfs/design_notes.txt |    5 
 Documentation/filesystems/pohmelfs/info.txt         |   21 
 Documentation/filesystems/vfs.txt                   |    3 
 Documentation/kbuild/makefiles.txt                  |   10 
 Documentation/kernel-parameters.txt                 |   78 -
 Documentation/lguest/.gitignore                     |    1 
 Documentation/lguest/lguest.txt                     |   11 
 Documentation/networking/bonding.txt                |    2 
 Documentation/powerpc/dts-bindings/fsl/i2c.txt      |   46 
 Documentation/sound/alsa/HD-Audio.txt               |    4 
 Documentation/spi/spi-summary                       |    6 
 MAINTAINERS                                         |  114 +
 Makefile                                            |    4 
 arch/alpha/include/asm/percpu.h                     |    2 
 arch/arm/common/vic.c                               |    9 
 arch/arm/configs/imx27ads_defconfig                 |  826 --------------
 arch/arm/configs/mx1_defconfig                      | 1105 ++++++++++++++++++
 arch/arm/configs/mx27_defconfig                     | 1174 ++++++++++++++++++++
 arch/arm/configs/mx31ads_defconfig                  |  839 --------------
 arch/arm/configs/mx31litekit_defconfig              | 1100 ------------------
 arch/arm/configs/mx3_defconfig                      | 1125 +++++++++++++++++++
 arch/arm/configs/pcm037_defconfig                   |  769 -------------
 arch/arm/configs/pcm038_defconfig                   | 1008 -----------------
 arch/arm/configs/s3c2410_defconfig                  | 1112 +++++++++++++++---
 arch/arm/include/asm/tlb.h                          |   25 
 arch/arm/kernel/sys_oabi-compat.c                   |   20 
 arch/arm/mach-at91/at91rm9200_time.c                |    2 
 arch/arm/mach-at91/at91sam926x_time.c               |    2 
 arch/arm/mach-davinci/time.c                        |    2 
 arch/arm/mach-ep93xx/core.c                         |    2 
 arch/arm/mach-imx/time.c                            |    2 
 arch/arm/mach-ixp4xx/common.c                       |    2 
 arch/arm/mach-msm/timer.c                           |    4 
 arch/arm/mach-mx1/mx1ads.c                          |    6 
 arch/arm/mach-mx2/clock_imx21.c                     |    8 
 arch/arm/mach-mx3/Kconfig                           |    2 
 arch/arm/mach-mx3/mx31ads.c                         |    4 
 arch/arm/mach-mx3/pcm037.c                          |    4 
 arch/arm/mach-mx3/qong.c                            |   28 
 arch/arm/mach-netx/time.c                           |    2 
 arch/arm/mach-ns9xxx/time-ns9360.c                  |    2 
 arch/arm/mach-omap1/time.c                          |    2 
 arch/arm/mach-omap2/timer-gp.c                      |    2 
 arch/arm/mach-pxa/em-x270.c                         |    6 
 arch/arm/mach-pxa/generic.h                         |    3 
 arch/arm/mach-pxa/include/mach/colibri.h            |    4 
 arch/arm/mach-pxa/include/mach/palmt5.h             |    1 
 arch/arm/mach-pxa/include/mach/palmtx.h             |    1 
 arch/arm/mach-pxa/palmt5.c                          |   11 
 arch/arm/mach-pxa/palmtx.c                          |   11 
 arch/arm/mach-pxa/time.c                            |    2 
 arch/arm/mach-realview/core.c                       |    2 
 arch/arm/mach-s3c2412/mach-jive.c                   |    5 
 arch/arm/mach-s3c2440/mach-anubis.c                 |    2 
 arch/arm/mach-s3c2440/mach-osiris.c                 |    1 
 arch/arm/mach-s3c6410/mach-smdk6410.c               |    4 
 arch/arm/mach-versatile/core.c                      |    2 
 arch/arm/plat-mxc/include/mach/imx-uart.h           |    2 
 arch/arm/plat-mxc/include/mach/iomux-mx3.h          |   48 
 arch/arm/plat-mxc/include/mach/irqs.h               |    2 
 arch/arm/plat-mxc/include/mach/mx21.h               |    3 
 arch/arm/plat-mxc/irq.c                             |   14 
 arch/arm/plat-mxc/time.c                            |    2 
 arch/arm/plat-omap/common.c                         |    4 
 arch/arm/plat-orion/time.c                          |    2 
 arch/arm/plat-s3c/gpio-config.c                     |    3 
 arch/arm/plat-s3c/include/plat/devs.h               |    1 
 arch/arm/plat-s3c24xx/adc.c                         |   19 
 arch/arm/plat-s3c24xx/gpiolib.c                     |    2 
 arch/avr32/kernel/time.c                            |    2 
 arch/blackfin/kernel/time-ts.c                      |   12 
 arch/frv/kernel/setup.c                             |    1 
 arch/frv/mb93090-mb00/pci-vdk.c                     |   65 -
 arch/h8300/include/asm/timer.h                      |   25 
 arch/ia64/include/asm/paravirt_privop.h             |    2 
 arch/ia64/include/asm/smp.h                         |    2 
 arch/ia64/kernel/cyclone.c                          |    2 
 arch/ia64/kernel/smp.c                              |   14 
 arch/ia64/kernel/time.c                             |    4 
 arch/ia64/sn/kernel/sn2/timer.c                     |    2 
 arch/m32r/include/asm/Kbuild                        |    1 
 arch/m32r/include/asm/addrspace.h                   |   57 
 arch/m32r/include/asm/assembler.h                   |  229 +++
 arch/m32r/include/asm/atomic.h                      |  318 +++++
 arch/m32r/include/asm/auxvec.h                      |    4 
 arch/m32r/include/asm/bitops.h                      |  275 ++++
 arch/m32r/include/asm/bug.h                         |    4 
 arch/m32r/include/asm/bugs.h                        |   19 
 arch/m32r/include/asm/byteorder.h                   |   10 
 arch/m32r/include/asm/cache.h                       |    8 
 arch/m32r/include/asm/cachectl.h                    |   26 
 arch/m32r/include/asm/cacheflush.h                  |   69 +
 arch/m32r/include/asm/checksum.h                    |  204 +++
 arch/m32r/include/asm/cputime.h                     |    6 
 arch/m32r/include/asm/current.h                     |   15 
 arch/m32r/include/asm/delay.h                       |   26 
 arch/m32r/include/asm/device.h                      |    7 
 arch/m32r/include/asm/div64.h                       |    1 
 arch/m32r/include/asm/dma.h                         |   12 
 arch/m32r/include/asm/elf.h                         |  134 ++
 arch/m32r/include/asm/emergency-restart.h           |    6 
 arch/m32r/include/asm/errno.h                       |    6 
 arch/m32r/include/asm/fb.h                          |   19 
 arch/m32r/include/asm/fcntl.h                       |    1 
 arch/m32r/include/asm/flat.h                        |  146 ++
 arch/m32r/include/asm/ftrace.h                      |    1 
 arch/m32r/include/asm/futex.h                       |    6 
 arch/m32r/include/asm/hardirq.h                     |   36 
 arch/m32r/include/asm/hw_irq.h                      |    4 
 arch/m32r/include/asm/io.h                          |  200 +++
 arch/m32r/include/asm/ioctl.h                       |    1 
 arch/m32r/include/asm/ioctls.h                      |   87 +
 arch/m32r/include/asm/ipcbuf.h                      |   29 
 arch/m32r/include/asm/irq.h                         |   90 +
 arch/m32r/include/asm/irq_regs.h                    |    1 
 arch/m32r/include/asm/kdebug.h                      |    1 
 arch/m32r/include/asm/kmap_types.h                  |   29 
 arch/m32r/include/asm/linkage.h                     |    7 
 arch/m32r/include/asm/local.h                       |  366 ++++++
 arch/m32r/include/asm/m32102.h                      |  314 +++++
 arch/m32r/include/asm/m32104ut/m32104ut_pld.h       |  161 ++
 arch/m32r/include/asm/m32700ut/m32700ut_lan.h       |  103 +
 arch/m32r/include/asm/m32700ut/m32700ut_lcd.h       |   55 
 arch/m32r/include/asm/m32700ut/m32700ut_pld.h       |  259 ++++
 arch/m32r/include/asm/m32r.h                        |  160 ++
 arch/m32r/include/asm/m32r_mp_fpga.h                |  313 +++++
 arch/m32r/include/asm/mappi2/mappi2_pld.h           |  150 ++
 arch/m32r/include/asm/mappi3/mappi3_pld.h           |  142 ++
 arch/m32r/include/asm/mc146818rtc.h                 |   29 
 arch/m32r/include/asm/mman.h                        |   17 
 arch/m32r/include/asm/mmu.h                         |   21 
 arch/m32r/include/asm/mmu_context.h                 |  164 ++
 arch/m32r/include/asm/mmzone.h                      |   59 +
 arch/m32r/include/asm/module.h                      |   10 
 arch/m32r/include/asm/msgbuf.h                      |   31 
 arch/m32r/include/asm/mutex.h                       |    9 
 arch/m32r/include/asm/opsput/opsput_lan.h           |   52 
 arch/m32r/include/asm/opsput/opsput_lcd.h           |   55 
 arch/m32r/include/asm/opsput/opsput_pld.h           |  255 ++++
 arch/m32r/include/asm/page.h                        |   87 +
 arch/m32r/include/asm/param.h                       |   23 
 arch/m32r/include/asm/pci.h                         |    8 
 arch/m32r/include/asm/percpu.h                      |    6 
 arch/m32r/include/asm/pgalloc.h                     |   76 +
 arch/m32r/include/asm/pgtable-2level.h              |   78 +
 arch/m32r/include/asm/pgtable.h                     |  363 ++++++
 arch/m32r/include/asm/poll.h                        |    1 
 arch/m32r/include/asm/posix_types.h                 |  118 ++
 arch/m32r/include/asm/processor.h                   |  147 ++
 arch/m32r/include/asm/ptrace.h                      |  148 ++
 arch/m32r/include/asm/resource.h                    |    6 
 arch/m32r/include/asm/rtc.h                         |   65 +
 arch/m32r/include/asm/s1d13806.h                    |  199 +++
 arch/m32r/include/asm/scatterlist.h                 |   21 
 arch/m32r/include/asm/sections.h                    |    7 
 arch/m32r/include/asm/segment.h                     |   10 
 arch/m32r/include/asm/sembuf.h                      |   25 
 arch/m32r/include/asm/serial.h                      |    9 
 arch/m32r/include/asm/setup.h                       |   38 
 arch/m32r/include/asm/shmbuf.h                      |   42 
 arch/m32r/include/asm/shmparam.h                    |    6 
 arch/m32r/include/asm/sigcontext.h                  |   39 
 arch/m32r/include/asm/siginfo.h                     |    6 
 arch/m32r/include/asm/signal.h                      |  166 ++
 arch/m32r/include/asm/smp.h                         |  119 ++
 arch/m32r/include/asm/socket.h                      |   60 +
 arch/m32r/include/asm/sockios.h                     |   13 
 arch/m32r/include/asm/spinlock.h                    |  326 +++++
 arch/m32r/include/asm/spinlock_types.h              |   23 
 arch/m32r/include/asm/stat.h                        |   87 +
 arch/m32r/include/asm/statfs.h                      |    6 
 arch/m32r/include/asm/string.h                      |   13 
 arch/m32r/include/asm/swab.h                        |   10 
 arch/m32r/include/asm/syscall.h                     |    8 
 arch/m32r/include/asm/system.h                      |  431 +++++++
 arch/m32r/include/asm/termbits.h                    |  199 +++
 arch/m32r/include/asm/termios.h                     |   91 +
 arch/m32r/include/asm/thread_info.h                 |  184 +++
 arch/m32r/include/asm/timex.h                       |   27 
 arch/m32r/include/asm/tlb.h                         |   20 
 arch/m32r/include/asm/tlbflush.h                    |   97 +
 arch/m32r/include/asm/topology.h                    |    6 
 arch/m32r/include/asm/types.h                       |   30 
 arch/m32r/include/asm/uaccess.h                     |  693 +++++++++++
 arch/m32r/include/asm/ucontext.h                    |   12 
 arch/m32r/include/asm/unaligned.h                   |   18 
 arch/m32r/include/asm/unistd.h                      |  389 ++++++
 arch/m32r/include/asm/user.h                        |   52 
 arch/m32r/include/asm/vga.h                         |   20 
 arch/m32r/include/asm/xor.h                         |    6 
 arch/m68knommu/platform/68328/timers.c              |    2 
 arch/m68knommu/platform/coldfire/dma_timer.c        |    2 
 arch/m68knommu/platform/coldfire/pit.c              |    2 
 arch/m68knommu/platform/coldfire/timers.c           |    2 
 arch/mips/kernel/cevt-txx9.c                        |    2 
 arch/mips/kernel/csrc-bcm1480.c                     |    2 
 arch/mips/kernel/csrc-ioasic.c                      |    6 
 arch/mips/kernel/csrc-r4k.c                         |    2 
 arch/mips/kernel/csrc-sb1250.c                      |    2 
 arch/mips/kernel/i8253.c                            |    2 
 arch/mips/nxp/pnx8550/common/time.c                 |    2 
 arch/mips/sgi-ip27/ip27-timer.c                     |    2 
 arch/mn10300/include/asm/bug.h                      |   10 
 arch/mn10300/include/asm/unistd.h                   |    2 
 arch/mn10300/kernel/entry.S                         |    2 
 arch/mn10300/kernel/setup.c                         |    4 
 arch/powerpc/Kconfig                                |    2 
 arch/powerpc/boot/dts/tqm8540.dts                   |    4 
 arch/powerpc/boot/dts/tqm8541.dts                   |    4 
 arch/powerpc/boot/dts/tqm8548-bigflash.dts          |    8 
 arch/powerpc/boot/dts/tqm8548.dts                   |    8 
 arch/powerpc/boot/dts/tqm8555.dts                   |    4 
 arch/powerpc/boot/dts/tqm8560.dts                   |    4 
 arch/powerpc/configs/85xx/tqm8548_defconfig         |  160 --
 arch/powerpc/include/asm/futex.h                    |   12 
 arch/powerpc/include/asm/mmu.h                      |    6 
 arch/powerpc/include/asm/ppc-opcode.h               |   13 
 arch/powerpc/kernel/cputable.c                      |    2 
 arch/powerpc/kernel/time.c                          |    8 
 arch/powerpc/mm/tlb_nohash.c                        |    1 
 arch/powerpc/mm/tlb_nohash_low.S                    |   14 
 arch/powerpc/platforms/pseries/dtl.c                |    1 
 arch/powerpc/platforms/pseries/eeh_driver.c         |    2 
 arch/s390/appldata/appldata_base.c                  |    2 
 arch/s390/include/asm/cpuid.h                       |   25 
 arch/s390/include/asm/kvm_host.h                    |    1 
 arch/s390/include/asm/lowcore.h                     |   12 
 arch/s390/include/asm/processor.h                   |   17 
 arch/s390/include/asm/ptrace.h                      |    2 
 arch/s390/include/asm/setup.h                       |   24 
 arch/s390/include/asm/thread_info.h                 |    3 
 arch/s390/include/asm/timer.h                       |    1 
 arch/s390/include/asm/timex.h                       |    5 
 arch/s390/include/asm/unistd.h                      |    4 
 arch/s390/kernel/asm-offsets.c                      |    2 
 arch/s390/kernel/compat_linux.c                     |   18 
 arch/s390/kernel/compat_wrapper.S                   |   18 
 arch/s390/kernel/early.c                            |   19 
 arch/s390/kernel/entry.S                            |   13 
 arch/s390/kernel/entry64.S                          |   13 
 arch/s390/kernel/head.S                             |   15 
 arch/s390/kernel/nmi.c                              |    5 
 arch/s390/kernel/setup.c                            |   12 
 arch/s390/kernel/smp.c                              |    4 
 arch/s390/kernel/syscalls.S                         |    2 
 arch/s390/kernel/time.c                             |   79 -
 arch/s390/kernel/vtime.c                            |   67 -
 arch/sh/kernel/cpu/sh4a/setup-sh7722.c              |    1 
 arch/sh/kernel/cpu/sh4a/setup-sh7723.c              |    1 
 arch/sh/kernel/sys_sh.c                             |    9 
 arch/sh/kernel/time_32.c                            |    2 
 arch/sh/kernel/timers/timer-tmu.c                   |    2 
 arch/sparc/include/asm/atomic_32.h                  |    2 
 arch/sparc/kernel/ldc.c                             |    6 
 arch/sparc/kernel/smp_64.c                          |    4 
 arch/sparc/kernel/sys_sparc32.c                     |   19 
 arch/sparc/kernel/time_64.c                         |    7 
 arch/um/Kconfig.rest                                |    2 
 arch/um/kernel/time.c                               |    2 
 arch/x86/Kconfig                                    |    1 
 arch/x86/Kconfig.cpu                                |    1 
 arch/x86/ia32/sys_ia32.c                            |   19 
 arch/x86/include/asm/desc.h                         |    2 
 arch/x86/include/asm/hardirq.h                      |    2 
 arch/x86/include/asm/lguest_hcall.h                 |    2 
 arch/x86/include/asm/pat.h                          |    4 
 arch/x86/include/asm/processor.h                    |    6 
 arch/x86/include/asm/tlbflush.h                     |    2 
 arch/x86/include/asm/uv/uv_mmrs.h                   |    5 
 arch/x86/kernel/apic/x2apic_uv_x.c                  |   16 
 arch/x86/kernel/bios_uv.c                           |    3 
 arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c          |    6 
 arch/x86/kernel/hpet.c                              |    6 
 arch/x86/kernel/i8253.c                             |    2 
 arch/x86/kernel/kvmclock.c                          |    7 
 arch/x86/kernel/microcode_core.c                    |    2 
 arch/x86/kernel/pci-swiotlb.c                       |    2 
 arch/x86/kernel/tlb_uv.c                            |  189 ++-
 arch/x86/kernel/tsc.c                               |    2 
 arch/x86/kernel/uv_sysfs.c                          |    4 
 arch/x86/kernel/vmiclock_32.c                       |    2 
 arch/x86/lguest/boot.c                              |   18 
 arch/x86/mm/ioremap.c                               |   10 
 arch/x86/mm/pageattr.c                              |  125 +-
 arch/x86/mm/pat.c                                   |  189 ---
 arch/x86/xen/time.c                                 |    7 
 block/as-iosched.c                                  |  116 -
 block/blk-barrier.c                                 |    3 
 block/blk-sysfs.c                                   |    4 
 block/blk.h                                         |    4 
 block/cfq-iosched.c                                 |  270 +++-
 block/elevator.c                                    |    8 
 block/ioctl.c                                       |    2 
 block/scsi_ioctl.c                                  |    6 
 drivers/acpi/sleep.c                                |    8 
 drivers/ata/libata-core.c                           |   25 
 drivers/ata/libata-scsi.c                           |   30 
 drivers/ata/libata-sff.c                            |   27 
 drivers/ata/pata_hpt37x.c                           |   22 
 drivers/ata/pata_legacy.c                           |   37 
 drivers/ata/pata_ninja32.c                          |    4 
 drivers/ata/pata_via.c                              |   76 +
 drivers/ata/sata_mv.c                               |   58 
 drivers/base/base.h                                 |    2 
 drivers/base/core.c                                 |    6 
 drivers/base/dd.c                                   |    1 
 drivers/base/platform.c                             |  239 ++++
 drivers/block/brd.c                                 |    5 
 drivers/block/ub.c                                  |   20 
 drivers/char/agp/generic.c                          |    4 
 drivers/char/hpet.c                                 |    2 
 drivers/char/ipmi/ipmi_msghandler.c                 |  211 +++
 drivers/char/ipmi/ipmi_si_intf.c                    |  150 ++
 drivers/char/mem.c                                  |   27 
 drivers/char/vt.c                                   |    2 
 drivers/clocksource/acpi_pm.c                       |   12 
 drivers/clocksource/cyclone.c                       |    2 
 drivers/clocksource/scx200_hrt.c                    |    2 
 drivers/clocksource/tcb_clksrc.c                    |    2 
 drivers/edac/mpc85xx_edac.c                         |    2 
 drivers/gpu/drm/drm_stub.c                          |   11 
 drivers/gpu/drm/drm_sysfs.c                         |    1 
 drivers/gpu/drm/via/via_dma.c                       |   12 
 drivers/ide/cs5536.c                                |    1 
 drivers/ide/hpt366.c                                |   14 
 drivers/ide/ide-io.c                                |   11 
 drivers/ide/pmac.c                                  |    2 
 drivers/input/gameport/gameport.c                   |   14 
 drivers/input/input.c                               |    1 
 drivers/input/keyboard/atkbd.c                      |   20 
 drivers/input/keyboard/bf54x-keys.c                 |    2 
 drivers/input/misc/Kconfig                          |    2 
 drivers/input/mouse/pc110pad.c                      |    1 
 drivers/input/serio/hp_sdc.c                        |   24 
 drivers/input/serio/i8042-x86ia64io.h               |   28 
 drivers/input/serio/i8042.c                         |   37 
 drivers/input/touchscreen/ad7877.c                  |    4 
 drivers/input/touchscreen/ad7879.c                  |    3 
 drivers/input/touchscreen/ads7846.c                 |   12 
 drivers/input/touchscreen/da9034-ts.c               |   29 
 drivers/input/touchscreen/mainstone-wm97xx.c        |    7 
 drivers/input/touchscreen/wm97xx-core.c             |    3 
 drivers/isdn/hisax/st5481_usb.c                     |    9 
 drivers/lguest/lg.h                                 |    3 
 drivers/lguest/segments.c                           |   13 
 drivers/lguest/x86/core.c                           |    9 
 drivers/md/bitmap.c                                 |    7 
 drivers/md/dm-bio-list.h                            |  117 -
 drivers/md/dm-delay.c                               |    2 
 drivers/md/dm-mpath.c                               |    1 
 drivers/md/dm-raid1.c                               |    1 
 drivers/md/dm-region-hash.c                         |    1 
 drivers/md/dm-snap.c                                |    1 
 drivers/md/dm.c                                     |    1 
 drivers/md/md.c                                     |   41 
 drivers/md/md.h                                     |   19 
 drivers/md/raid1.c                                  |    1 
 drivers/md/raid10.c                                 |    1 
 drivers/md/raid5.c                                  |    7 
 drivers/media/video/pvrusb2/pvrusb2-hdw.c           |    1 
 drivers/message/fusion/mptbase.c                    |    2 
 drivers/misc/sgi-gru/grufile.c                      |    2 
 drivers/misc/sgi-xp/xp_main.c                       |   12 
 drivers/net/a2065.c                                 |   17 
 drivers/net/ariadne.c                               |   19 
 drivers/net/arm/am79c961a.c                         |   24 
 drivers/net/arm/at91_ether.c                        |   32 
 drivers/net/arm/ep93xx_eth.c                        |   21 
 drivers/net/arm/ether1.c                            |   19 
 drivers/net/arm/ether3.c                            |   19 
 drivers/net/atarilance.c                            |   18 
 drivers/net/au1000_eth.c                            |   23 
 drivers/net/benet/be_ethtool.c                      |    4 
 drivers/net/bfin_mac.c                              |   24 
 drivers/net/bonding/bond_alb.c                      |    2 
 drivers/net/bonding/bond_main.c                     |    5 
 drivers/net/bonding/bond_sysfs.c                    |   14 
 drivers/net/cris/eth_v10.c                          |   30 
 drivers/net/declance.c                              |   17 
 drivers/net/e1000/e1000_main.c                      |   48 
 drivers/net/e1000e/netdev.c                         |   61 -
 drivers/net/ehea/ehea_main.c                        |    4 
 drivers/net/forcedeth.c                             |    4 
 drivers/net/fs_enet/fs_enet-main.c                  |   27 
 drivers/net/gianfar.c                               |    2 
 drivers/net/ibm_newemac/core.c                      |   41 
 drivers/net/igb/e1000_mac.c                         |    2 
 drivers/net/igb/e1000_mac.h                         |    1 
 drivers/net/igb/e1000_mbx.c                         |   17 
 drivers/net/igb/e1000_mbx.h                         |    2 
 drivers/net/igb/igb_main.c                          |   37 
 drivers/net/igbvf/igbvf.h                           |    3 
 drivers/net/igbvf/netdev.c                          |    9 
 drivers/net/igbvf/vf.c                              |    2 
 drivers/net/igbvf/vf.h                              |    1 
 drivers/net/ioc3-eth.c                              |   22 
 drivers/net/isa-skeleton.c                          |   20 
 drivers/net/ixgbe/ixgbe_82598.c                     |   59 -
 drivers/net/ixgbe/ixgbe_82599.c                     |   40 
 drivers/net/ixgbe/ixgbe_common.c                    |   55 
 drivers/net/ixgbe/ixgbe_common.h                    |    3 
 drivers/net/ixgbe/ixgbe_ethtool.c                   |   24 
 drivers/net/ixgbe/ixgbe_main.c                      |   57 
 drivers/net/mac89x0.c                               |   18 
 drivers/net/macb.c                                  |   19 
 drivers/net/macsonic.c                              |   19 
 drivers/net/myri10ge/myri10ge.c                     |    1 
 drivers/net/phy/fixed.c                             |    5 
 drivers/net/phy/marvell.c                           |   54 
 drivers/net/phy/phy.c                               |   14 
 drivers/net/sfc/efx.c                               |    7 
 drivers/net/sfc/falcon.c                            |    4 
 drivers/net/sh_eth.c                                |   21 
 drivers/net/skge.c                                  |    4 
 drivers/net/sun3_82586.c                            |   19 
 drivers/net/tc35815.c                               |   27 
 drivers/net/tg3.c                                   |    9 
 drivers/net/tsi108_eth.c                            |   20 
 drivers/net/tun.c                                   |    5 
 drivers/net/via-velocity.c                          |    4 
 drivers/net/xtsonic.c                               |   19 
 drivers/rtc/Kconfig                                 |    2 
 drivers/rtc/rtc-cmos.c                              |   20 
 drivers/rtc/rtc-sh.c                                |   67 -
 drivers/s390/block/dasd.c                           |   37 
 drivers/s390/block/dasd_eckd.c                      |   16 
 drivers/s390/cio/qdio_main.c                        |   43 
 drivers/sbus/char/jsflash.c                         |   15 
 drivers/sbus/char/uctrl.c                           |    7 
 drivers/scsi/scsi_scan.c                            |    2 
 drivers/scsi/scsi_wait_scan.c                       |   11 
 drivers/serial/bfin_5xx.c                           |    6 
 drivers/serial/samsung.c                            |    4 
 drivers/spi/pxa2xx_spi.c                            |   15 
 drivers/staging/android/binder.c                    |  201 ++-
 drivers/staging/at76_usb/at76_usb.c                 |   20 
 drivers/staging/epl/VirtualEthernetLinux.c          |   17 
 drivers/staging/et131x/et131x_netdev.c              |   23 
 drivers/staging/go7007/go7007-driver.c              |   26 
 drivers/staging/go7007/go7007-i2c.c                 |   83 -
 drivers/staging/go7007/go7007-priv.h                |    1 
 drivers/staging/go7007/go7007-usb.c                 |   14 
 drivers/staging/go7007/s2250-board.c                |   71 -
 drivers/staging/go7007/wis-i2c.h                    |    9 
 drivers/staging/go7007/wis-ov7640.c                 |   54 
 drivers/staging/go7007/wis-saa7113.c                |   60 -
 drivers/staging/go7007/wis-saa7115.c                |   60 -
 drivers/staging/go7007/wis-sony-tuner.c             |   62 -
 drivers/staging/go7007/wis-tw2804.c                 |   57 
 drivers/staging/go7007/wis-tw9903.c                 |   60 -
 drivers/staging/go7007/wis-uda1342.c                |   52 
 drivers/staging/line6/audio.c                       |    9 
 drivers/staging/otus/usbdrv.c                       |   47 
 drivers/staging/otus/zdusb.c                        |    3 
 drivers/staging/otus/zdusb.h                        |    4 
 drivers/staging/pohmelfs/config.c                   |   61 -
 drivers/staging/pohmelfs/dir.c                      |   24 
 drivers/staging/pohmelfs/inode.c                    |  137 +-
 drivers/staging/pohmelfs/lock.c                     |    3 
 drivers/staging/pohmelfs/net.c                      |   72 -
 drivers/staging/pohmelfs/netfs.h                    |   21 
 drivers/staging/pohmelfs/trans.c                    |   33 
 drivers/staging/rt2860/rt_main_dev.c                |   25 
 drivers/staging/rt2870/rt2870.h                     |    1 
 drivers/staging/rt2870/rt_main_dev.c                |   28 
 drivers/staging/rt3070/rt_main_dev.c                |   29 
 drivers/staging/slicoss/README                      |   31 
 drivers/staging/slicoss/slicoss.c                   |   25 
 drivers/staging/stlc45xx/Kconfig                    |    2 
 drivers/staging/sxg/sxg.c                           |  127 +-
 drivers/staging/uc2322/aten2011.c                   |   28 
 drivers/staging/wlan-ng/p80211netdev.c              |   20 
 drivers/uio/uio_cif.c                               |    1 
 drivers/usb/class/cdc-wdm.c                         |    2 
 drivers/usb/core/devio.c                            |    2 
 drivers/usb/core/hcd.c                              |   26 
 drivers/usb/core/hcd.h                              |   14 
 drivers/usb/core/message.c                          |   58 
 drivers/usb/core/usb.c                              |    2 
 drivers/usb/gadget/u_ether.c                        |    8 
 drivers/usb/host/whci/asl.c                         |   15 
 drivers/usb/host/whci/hcd.c                         |   23 
 drivers/usb/host/whci/pzl.c                         |   16 
 drivers/usb/host/whci/qset.c                        |   24 
 drivers/usb/host/whci/whcd.h                        |    1 
 drivers/usb/host/whci/whci-hc.h                     |    1 
 drivers/usb/musb/cppi_dma.c                         |   23 
 drivers/usb/musb/musb_core.c                        |   12 
 drivers/usb/musb/musb_gadget.c                      |   33 
 drivers/usb/musb/musb_host.c                        |  406 +++---
 drivers/usb/musb/musbhsdma.c                        |   64 -
 drivers/usb/serial/ftdi_sio.c                       |    1 
 drivers/usb/serial/ftdi_sio.h                       |    7 
 drivers/usb/serial/moto_modem.c                     |    1 
 drivers/usb/serial/option.c                         |    5 
 drivers/usb/serial/qcserial.c                       |   21 
 drivers/usb/storage/Makefile                        |    3 
 drivers/usb/storage/transport.c                     |    4 
 drivers/usb/storage/unusual_devs.h                  |   14 
 drivers/usb/wusbcore/devconnect.c                   |   21 
 drivers/usb/wusbcore/wusbhc.c                       |   32 
 drivers/video/asiliantfb.c                          |    1 
 drivers/video/pxafb.c                               |   16 
 drivers/virtio/virtio_balloon.c                     |    3 
 fs/afs/file.c                                       |    2 
 fs/autofs/dirhash.c                                 |   34 
 fs/autofs4/dev-ioctl.c                              |   12 
 fs/bio.c                                            |   18 
 fs/btrfs/async-thread.c                             |   60 -
 fs/btrfs/async-thread.h                             |    2 
 fs/btrfs/ctree.c                                    |   17 
 fs/btrfs/disk-io.c                                  |    9 
 fs/btrfs/extent_io.c                                |   86 +
 fs/btrfs/file.c                                     |    6 
 fs/btrfs/inode.c                                    |   36 
 fs/btrfs/ioctl.c                                    |   49 
 fs/btrfs/ordered-data.c                             |    2 
 fs/btrfs/super.c                                    |   13 
 fs/btrfs/volumes.c                                  |  124 +-
 fs/btrfs/volumes.h                                  |   13 
 fs/buffer.c                                         |   56 
 fs/cifs/CHANGES                                     |    3 
 fs/cifs/cifs_spnego.c                               |    2 
 fs/cifs/cifsfs.c                                    |   48 
 fs/cifs/cifsglob.h                                  |    3 
 fs/cifs/cifspdu.h                                   |    8 
 fs/cifs/cifssmb.c                                   |    6 
 fs/cifs/connect.c                                   |  205 ++-
 fs/cifs/dir.c                                       |  145 +-
 fs/cifs/dns_resolve.c                               |    2 
 fs/cifs/file.c                                      |  123 +-
 fs/cifs/inode.c                                     |   77 -
 fs/cifs/readdir.c                                   |    6 
 fs/cifs/sess.c                                      |   47 
 fs/compat.c                                         |   37 
 fs/compat_ioctl.c                                   |    7 
 fs/dcache.c                                         |    1 
 fs/direct-io.c                                      |    2 
 fs/ecryptfs/miscdev.c                               |   15 
 fs/ext4/extents.c                                   |    2 
 fs/fat/Kconfig                                      |    3 
 fs/filesystems.c                                    |    2 
 fs/gfs2/glock.c                                     |   10 
 fs/gfs2/glops.c                                     |    6 
 fs/gfs2/inode.c                                     |    8 
 fs/gfs2/inode.h                                     |   14 
 fs/gfs2/ops_file.c                                  |   12 
 fs/gfs2/ops_fstype.c                                |    5 
 fs/gfs2/ops_inode.c                                 |    1 
 fs/gfs2/quota.c                                     |    4 
 fs/hugetlbfs/inode.c                                |    3 
 fs/inode.c                                          |   36 
 fs/namei.c                                          |    2 
 fs/namespace.c                                      |    7 
 fs/ncpfs/ioctl.c                                    |   21 
 fs/nfs/nfs3xdr.c                                    |    3 
 fs/nfsd/nfs4recover.c                               |   46 
 fs/nfsd/vfs.c                                       |   34 
 fs/ocfs2/file.c                                     |   96 +
 fs/pipe.c                                           |   42 
 fs/proc/base.c                                      |    4 
 fs/splice.c                                         |  378 +++---
 fs/stat.c                                           |  137 --
 fs/sysfs/bin.c                                      |   13 
 fs/sysfs/file.c                                     |   16 
 fs/xattr.c                                          |   10 
 fs/xfs/linux-2.6/xfs_ioctl.c                        |   23 
 fs/xfs/linux-2.6/xfs_ioctl32.c                      |   12 
 include/asm-arm/.gitignore                          |    2 
 include/asm-generic/bug.h                           |    2 
 include/asm-generic/percpu.h                        |   35 
 include/asm-h8300/timer.h                           |   25 
 include/asm-m32r/Kbuild                             |    1 
 include/asm-m32r/addrspace.h                        |   57 
 include/asm-m32r/assembler.h                        |  229 ---
 include/asm-m32r/atomic.h                           |  318 -----
 include/asm-m32r/auxvec.h                           |    4 
 include/asm-m32r/bitops.h                           |  275 ----
 include/asm-m32r/bug.h                              |    4 
 include/asm-m32r/bugs.h                             |   19 
 include/asm-m32r/byteorder.h                        |   10 
 include/asm-m32r/cache.h                            |    8 
 include/asm-m32r/cachectl.h                         |   26 
 include/asm-m32r/cacheflush.h                       |   69 -
 include/asm-m32r/checksum.h                         |  204 ---
 include/asm-m32r/cputime.h                          |    6 
 include/asm-m32r/current.h                          |   15 
 include/asm-m32r/delay.h                            |   26 
 include/asm-m32r/device.h                           |    7 
 include/asm-m32r/div64.h                            |    1 
 include/asm-m32r/dma.h                              |   12 
 include/asm-m32r/elf.h                              |  134 --
 include/asm-m32r/emergency-restart.h                |    6 
 include/asm-m32r/errno.h                            |    6 
 include/asm-m32r/fb.h                               |   19 
 include/asm-m32r/fcntl.h                            |    1 
 include/asm-m32r/flat.h                             |  146 --
 include/asm-m32r/ftrace.h                           |    1 
 include/asm-m32r/futex.h                            |    6 
 include/asm-m32r/hardirq.h                          |   36 
 include/asm-m32r/hw_irq.h                           |    4 
 include/asm-m32r/io.h                               |  200 ---
 include/asm-m32r/ioctl.h                            |    1 
 include/asm-m32r/ioctls.h                           |   87 -
 include/asm-m32r/ipcbuf.h                           |   29 
 include/asm-m32r/irq.h                              |   90 -
 include/asm-m32r/irq_regs.h                         |    1 
 include/asm-m32r/kdebug.h                           |    1 
 include/asm-m32r/kmap_types.h                       |   29 
 include/asm-m32r/linkage.h                          |    7 
 include/asm-m32r/local.h                            |  366 ------
 include/asm-m32r/m32102.h                           |  314 -----
 include/asm-m32r/m32104ut/m32104ut_pld.h            |  161 --
 include/asm-m32r/m32700ut/m32700ut_lan.h            |  103 -
 include/asm-m32r/m32700ut/m32700ut_lcd.h            |   55 
 include/asm-m32r/m32700ut/m32700ut_pld.h            |  259 ----
 include/asm-m32r/m32r.h                             |  160 --
 include/asm-m32r/m32r_mp_fpga.h                     |  313 -----
 include/asm-m32r/mappi2/mappi2_pld.h                |  150 --
 include/asm-m32r/mappi3/mappi3_pld.h                |  142 --
 include/asm-m32r/mc146818rtc.h                      |   29 
 include/asm-m32r/mman.h                             |   17 
 include/asm-m32r/mmu.h                              |   21 
 include/asm-m32r/mmu_context.h                      |  164 --
 include/asm-m32r/mmzone.h                           |   59 -
 include/asm-m32r/module.h                           |   10 
 include/asm-m32r/msgbuf.h                           |   31 
 include/asm-m32r/mutex.h                            |    9 
 include/asm-m32r/opsput/opsput_lan.h                |   52 
 include/asm-m32r/opsput/opsput_lcd.h                |   55 
 include/asm-m32r/opsput/opsput_pld.h                |  255 ----
 include/asm-m32r/page.h                             |   87 -
 include/asm-m32r/param.h                            |   23 
 include/asm-m32r/pci.h                              |    8 
 include/asm-m32r/percpu.h                           |    6 
 include/asm-m32r/pgalloc.h                          |   76 -
 include/asm-m32r/pgtable-2level.h                   |   78 -
 include/asm-m32r/pgtable.h                          |  363 ------
 include/asm-m32r/poll.h                             |    1 
 include/asm-m32r/posix_types.h                      |  118 --
 include/asm-m32r/processor.h                        |  147 --
 include/asm-m32r/ptrace.h                           |  148 --
 include/asm-m32r/resource.h                         |    6 
 include/asm-m32r/rtc.h                              |   65 -
 include/asm-m32r/s1d13806.h                         |  199 ---
 include/asm-m32r/scatterlist.h                      |   21 
 include/asm-m32r/sections.h                         |    7 
 include/asm-m32r/segment.h                          |   10 
 include/asm-m32r/sembuf.h                           |   25 
 include/asm-m32r/serial.h                           |    9 
 include/asm-m32r/setup.h                            |   38 
 include/asm-m32r/shmbuf.h                           |   42 
 include/asm-m32r/shmparam.h                         |    6 
 include/asm-m32r/sigcontext.h                       |   39 
 include/asm-m32r/siginfo.h                          |    6 
 include/asm-m32r/signal.h                           |  166 --
 include/asm-m32r/smp.h                              |  119 --
 include/asm-m32r/socket.h                           |   60 -
 include/asm-m32r/sockios.h                          |   13 
 include/asm-m32r/spinlock.h                         |  326 -----
 include/asm-m32r/spinlock_types.h                   |   23 
 include/asm-m32r/stat.h                             |   87 -
 include/asm-m32r/statfs.h                           |    6 
 include/asm-m32r/string.h                           |   13 
 include/asm-m32r/swab.h                             |   10 
 include/asm-m32r/syscall.h                          |    8 
 include/asm-m32r/system.h                           |  431 -------
 include/asm-m32r/termbits.h                         |  199 ---
 include/asm-m32r/termios.h                          |   91 -
 include/asm-m32r/thread_info.h                      |  184 ---
 include/asm-m32r/timex.h                            |   27 
 include/asm-m32r/tlb.h                              |   20 
 include/asm-m32r/tlbflush.h                         |   97 -
 include/asm-m32r/topology.h                         |    6 
 include/asm-m32r/types.h                            |   30 
 include/asm-m32r/uaccess.h                          |  693 -----------
 include/asm-m32r/ucontext.h                         |   12 
 include/asm-m32r/unaligned.h                        |   18 
 include/asm-m32r/unistd.h                           |  389 ------
 include/asm-m32r/user.h                             |   52 
 include/asm-m32r/vga.h                              |   20 
 include/asm-m32r/xor.h                              |    6 
 include/linux/bio.h                                 |  109 +
 include/linux/buffer_head.h                         |    3 
 include/linux/clocksource.h                         |   37 
 include/linux/device.h                              |    1 
 include/linux/dynamic_debug.h                       |    2 
 include/linux/fs.h                                  |   69 +
 include/linux/fsl_devices.h                         |    4 
 include/linux/init.h                                |    1 
 include/linux/ipmi.h                                |    2 
 include/linux/ipmi_msgdefs.h                        |    8 
 include/linux/kernel.h                              |    9 
 include/linux/libata.h                              |    8 
 include/linux/memcontrol.h                          |    2 
 include/linux/percpu-defs.h                         |   84 +
 include/linux/percpu.h                              |   44 
 include/linux/phy.h                                 |    6 
 include/linux/pipe_fs_i.h                           |    5 
 include/linux/platform_device.h                     |   42 
 include/linux/rcutree.h                             |    3 
 include/linux/reiserfs_fs_sb.h                      |    2 
 include/linux/seccomp.h                             |    2 
 include/linux/slow-work.h                           |    2 
 include/linux/spi/ads7846.h                         |    1 
 include/linux/spi/spi.h                             |    7 
 include/linux/splice.h                              |   12 
 include/linux/suspend.h                             |   36 
 include/linux/syscalls.h                            |    2 
 include/linux/usb.h                                 |    9 
 include/net/udp.h                                   |    2 
 include/sound/jack.h                                |    2 
 include/sound/pcm.h                                 |    3 
 init/main.c                                         |    7 
 kernel/audit_tree.c                                 |    3 
 kernel/power/main.c                                 |   24 
 kernel/power/swap.c                                 |    2 
 kernel/rcupdate.c                                   |   18 
 kernel/rcutree.c                                    |   19 
 kernel/rcutree_trace.c                              |   14 
 kernel/resource.c                                   |   48 
 kernel/sched.c                                      |   10 
 kernel/softirq.c                                    |    4 
 kernel/time/clocksource.c                           |    8 
 kernel/time/jiffies.c                               |    2 
 kernel/time/timekeeping.c                           |   12 
 kernel/trace/trace_branch.c                         |    8 
 kernel/trace/trace_power.c                          |    7 
 lib/kobject.c                                       |    3 
 lib/kobject_uevent.c                                |    4 
 mm/filemap.c                                        |    1 
 mm/mmap.c                                           |    2 
 mm/vmscan.c                                         |   17 
 net/802/tr.c                                        |    3 
 net/8021q/vlan_core.c                               |    4 
 net/core/dev.c                                      |    9 
 net/ipv4/tcp_input.c                                |    3 
 net/ipv4/udp.c                                      |    3 
 net/ipv6/ipv6_sockglue.c                            |    4 
 net/ipv6/udp.c                                      |    6 
 net/packet/af_packet.c                              |    5 
 net/rds/rds.h                                       |    2 
 net/rose/af_rose.c                                  |   10 
 net/sched/em_meta.c                                 |    6 
 scripts/Makefile.build                              |    3 
 scripts/Makefile.lib                                |    9 
 security/smack/smack_lsm.c                          |   11 
 sound/core/control.c                                |   35 
 sound/core/jack.c                                   |    3 
 sound/core/pcm_compat.c                             |   11 
 sound/core/pcm_lib.c                                |   47 
 sound/core/pcm_native.c                             |   93 -
 sound/core/seq/seq_compat.c                         |    9 
 sound/core/timer.c                                  |   11 
 sound/isa/sb/sb16_csp.c                             |   19 
 sound/isa/wavefront/wavefront_fx.c                  |   14 
 sound/isa/wavefront/wavefront_synth.c               |   11 
 sound/pci/emu10k1/emufx.c                           |   41 
 sound/pci/emu10k1/io.c                              |    2 
 sound/pci/hda/hda_codec.c                           |   14 
 sound/pci/hda/hda_intel.c                           |   39 
 sound/pci/hda/patch_analog.c                        |    8 
 sound/pci/hda/patch_conexant.c                      |   21 
 sound/pci/hda/patch_realtek.c                       |    5 
 sound/pci/hda/patch_sigmatel.c                      |   37 
 sound/pci/intel8x0.c                                |  103 +
 sound/soc/omap/omap-mcbsp.c                         |    7 
 sound/soc/omap/osk5912.c                            |    4 
 sound/soc/pxa/magician.c                            |    2 
 sound/soc/pxa/pxa-ssp.c                             |    1 
 sound/soc/s3c24xx/Kconfig                           |    6 
 sound/soc/s3c24xx/jive_wm8750.c                     |   12 
 sound/soc/s3c24xx/s3c-i2s-v2.c                      |   18 
 sound/soc/s3c24xx/s3c2412-i2s.c                     |    2 
 sound/usb/caiaq/Makefile                            |    4 
 sound/usb/caiaq/audio.c                             |  700 +++++++++++
 sound/usb/caiaq/audio.h                             |    7 
 sound/usb/caiaq/caiaq-audio.c                       |  706 ------------
 sound/usb/caiaq/caiaq-audio.h                       |    7 
 sound/usb/caiaq/caiaq-control.c                     |  336 -----
 sound/usb/caiaq/caiaq-control.h                     |    6 
 sound/usb/caiaq/caiaq-device.c                      |  528 --------
 sound/usb/caiaq/caiaq-device.h                      |  131 --
 sound/usb/caiaq/caiaq-input.c                       |  363 ------
 sound/usb/caiaq/caiaq-input.h                       |    8 
 sound/usb/caiaq/caiaq-midi.c                        |  180 ---
 sound/usb/caiaq/caiaq-midi.h                        |    8 
 sound/usb/caiaq/control.c                           |  332 +++++
 sound/usb/caiaq/control.h                           |    6 
 sound/usb/caiaq/device.c                            |  521 ++++++++
 sound/usb/caiaq/device.h                            |  131 ++
 sound/usb/caiaq/input.c                             |  358 ++++++
 sound/usb/caiaq/input.h                             |    8 
 sound/usb/caiaq/midi.c                              |  173 ++
 sound/usb/caiaq/midi.h                              |    8 
 sound/usb/usx2y/us122l.c                            |   10 
 sound/usb/usx2y/usX2Yhwdep.c                        |   13 
 800 files changed, 23083 insertions(+), 20941 deletions(-)

diff -urN linux-2.6.30-rc2/.gitignore linux-2.6.30-rc3/.gitignore
--- linux-2.6.30-rc2/.gitignore	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/.gitignore	2009-04-22 03:29:15.968931301 +0000
@@ -49,6 +49,7 @@
 include/linux/version.h
 include/linux/utsrelease.h
 include/linux/bounds.h
+include/generated
 
 # stgit generated dirs
 patches-*
diff -urN linux-2.6.30-rc2/Documentation/block/biodoc.txt linux-2.6.30-rc3/Documentation/block/biodoc.txt
--- linux-2.6.30-rc2/Documentation/block/biodoc.txt	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/block/biodoc.txt	2009-04-22 03:29:15.977815383 +0000
@@ -1040,23 +1040,21 @@
 iii. Plugging the queue to batch requests in anticipation of opportunities for
      merge/sort optimizations
 
-This is just the same as in 2.4 so far, though per-device unplugging
-support is anticipated for 2.5. Also with a priority-based i/o scheduler,
-such decisions could be based on request priorities.
-
 Plugging is an approach that the current i/o scheduling algorithm resorts to so
 that it collects up enough requests in the queue to be able to take
 advantage of the sorting/merging logic in the elevator. If the
 queue is empty when a request comes in, then it plugs the request queue
-(sort of like plugging the bottom of a vessel to get fluid to build up)
+(sort of like plugging the bath tub of a vessel to get fluid to build up)
 till it fills up with a few more requests, before starting to service
 the requests. This provides an opportunity to merge/sort the requests before
 passing them down to the device. There are various conditions when the queue is
 unplugged (to open up the flow again), either through a scheduled task or
 could be on demand. For example wait_on_buffer sets the unplugging going
-(by running tq_disk) so the read gets satisfied soon. So in the read case,
-the queue gets explicitly unplugged as part of waiting for completion,
-in fact all queues get unplugged as a side-effect.
+through sync_buffer() running blk_run_address_space(mapping). Or the caller
+can do it explicity through blk_unplug(bdev). So in the read case,
+the queue gets explicitly unplugged as part of waiting for completion on that
+buffer. For page driven IO, the address space ->sync_page() takes care of
+doing the blk_run_address_space().
 
 Aside:
   This is kind of controversial territory, as it's not clear if plugging is
@@ -1067,11 +1065,6 @@
   multi-page bios being queued in one shot, we may not need to wait to merge
   a big request from the broken up pieces coming by.
 
-  Per-queue granularity unplugging (still a Todo) may help reduce some of the
-  concerns with just a single tq_disk flush approach. Something like
-  blk_kick_queue() to unplug a specific queue (right away ?)
-  or optionally, all queues, is in the plan.
-
 4.4 I/O contexts
 I/O contexts provide a dynamically allocated per process data area. They may
 be used in I/O schedulers, and in the block layer (could be used for IO statis,
diff -urN linux-2.6.30-rc2/Documentation/driver-model/platform.txt linux-2.6.30-rc3/Documentation/driver-model/platform.txt
--- linux-2.6.30-rc2/Documentation/driver-model/platform.txt	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/driver-model/platform.txt	2009-04-22 03:29:15.982757364 +0000
@@ -169,3 +169,62 @@
       be probed later if another device registers.  (Which is OK, since
       this interface is only for use with non-hotpluggable devices.)
 
+
+Early Platform Devices and Drivers
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The early platform interfaces provide platform data to platform device
+drivers early on during the system boot. The code is built on top of the
+early_param() command line parsing and can be executed very early on.
+
+Example: "earlyprintk" class early serial console in 6 steps
+
+1. Registering early platform device data
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The architecture code registers platform device data using the function
+early_platform_add_devices(). In the case of early serial console this
+should be hardware configuration for the serial port. Devices registered
+at this point will later on be matched against early platform drivers.
+
+2. Parsing kernel command line
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The architecture code calls parse_early_param() to parse the kernel
+command line. This will execute all matching early_param() callbacks.
+User specified early platform devices will be registered at this point.
+For the early serial console case the user can specify port on the
+kernel command line as "earlyprintk=serial.0" where "earlyprintk" is
+the class string, "serial" is the name of the platfrom driver and
+0 is the platform device id. If the id is -1 then the dot and the
+id can be omitted.
+
+3. Installing early platform drivers belonging to a certain class
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The architecture code may optionally force registration of all early
+platform drivers belonging to a certain class using the function
+early_platform_driver_register_all(). User specified devices from
+step 2 have priority over these. This step is omitted by the serial
+driver example since the early serial driver code should be disabled
+unless the user has specified port on the kernel command line.
+
+4. Early platform driver registration
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Compiled-in platform drivers making use of early_platform_init() are
+automatically registered during step 2 or 3. The serial driver example
+should use early_platform_init("earlyprintk", &platform_driver).
+
+5. Probing of early platform drivers belonging to a certain class
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The architecture code calls early_platform_driver_probe() to match
+registered early platform devices associated with a certain class with
+registered early platform drivers. Matched devices will get probed().
+This step can be executed at any point during the early boot. As soon
+as possible may be good for the serial port case.
+
+6. Inside the early platform driver probe()
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The driver code needs to take special care during early boot, especially
+when it comes to memory allocation and interrupt registration. The code
+in the probe() function can use is_early_platform_device() to check if
+it is called at early platform device or at the regular platform device
+time. The early serial driver performs register_console() at this point.
+
+For further information, see <linux/platform_device.h>.
diff -urN linux-2.6.30-rc2/Documentation/filesystems/pohmelfs/design_notes.txt linux-2.6.30-rc3/Documentation/filesystems/pohmelfs/design_notes.txt
--- linux-2.6.30-rc2/Documentation/filesystems/pohmelfs/design_notes.txt	2009-04-22 03:29:10.043931388 +0000
+++ linux-2.6.30-rc3/Documentation/filesystems/pohmelfs/design_notes.txt	2009-04-22 03:29:15.990932227 +0000
@@ -56,9 +56,10 @@
 data transfers.
 
 POHMELFS clients operate with a working set of servers and are capable of balancing read-only
-operations (like lookups or directory listings) between them.
+operations (like lookups or directory listings) between them according to IO priorities.
 Administrators can add or remove servers from the set at run-time via special commands (described
-in Documentation/pohmelfs/info.txt file). Writes are replicated to all servers.
+in Documentation/pohmelfs/info.txt file). Writes are replicated to all servers, which are connected
+with write permission turned on. IO priority and permissions can be changed in run-time.
 
 POHMELFS is capable of full data channel encryption and/or strong crypto hashing.
 One can select any kernel supported cipher, encryption mode, hash type and operation mode
diff -urN linux-2.6.30-rc2/Documentation/filesystems/pohmelfs/info.txt linux-2.6.30-rc3/Documentation/filesystems/pohmelfs/info.txt
--- linux-2.6.30-rc2/Documentation/filesystems/pohmelfs/info.txt	2009-04-22 03:29:10.043931388 +0000
+++ linux-2.6.30-rc3/Documentation/filesystems/pohmelfs/info.txt	2009-04-22 03:29:15.990932227 +0000
@@ -1,6 +1,8 @@
 POHMELFS usage information.
 
-Mount options:
+Mount options.
+All but index, number of crypto threads and maximum IO size can changed via remount.
+
 idx=%u
  Each mountpoint is associated with a special index via this option.
  Administrator can add or remove servers from the given index, so all mounts,
@@ -52,16 +54,27 @@
 
 Usage examples.
 
-Add (or remove if it already exists) server server1.net:1025 into the working set with index $idx
+Add server server1.net:1025 into the working set with index $idx
 with appropriate hash algorithm and key file and cipher algorithm, mode and key file:
-$cfg -a server1.net -p 1025 -i $idx -K $hash_key -k $cipher_key
+$cfg A add -a server1.net -p 1025 -i $idx -K $hash_key -k $cipher_key
 
 Mount filesystem with given index $idx to /mnt mountpoint.
 Client will connect to all servers specified in the working set via previous command:
 mount -t pohmel -o idx=$idx q /mnt
 
-One can add or remove servers from working set after mounting too.
+Change permissions to read-only (-I 1 option, '-I 2' - write-only, 3 - rw):
+$cfg A modify -a server1.net -p 1025 -i $idx -I 1
+
+Change IO priority to 123 (node with the highest priority gets read requests).
+$cfg A modify -a server1.net -p 1025 -i $idx -P 123
 
+One can check currect status of all connections in the mountstats file:
+# cat /proc/$PID/mountstats
+...
+device none mounted on /mnt with fstype pohmel
+idx addr(:port) socket_type protocol active priority permissions
+0 server1.net:1026 1 6 1 250 1
+0 server2.net:1025 1 6 1 123 3
 
 Server installation.
 
diff -urN linux-2.6.30-rc2/Documentation/filesystems/vfs.txt linux-2.6.30-rc3/Documentation/filesystems/vfs.txt
--- linux-2.6.30-rc2/Documentation/filesystems/vfs.txt	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/filesystems/vfs.txt	2009-04-22 03:29:15.993931692 +0000
@@ -277,8 +277,7 @@
   unfreeze_fs: called when VFS is unlocking a filesystem and making it writable
   	again.
 
-  statfs: called when the VFS needs to get filesystem statistics. This
-	is called with the kernel lock held
+  statfs: called when the VFS needs to get filesystem statistics.
 
   remount_fs: called when the filesystem is remounted. This is called
 	with the kernel lock held
diff -urN linux-2.6.30-rc2/Documentation/kbuild/makefiles.txt linux-2.6.30-rc3/Documentation/kbuild/makefiles.txt
--- linux-2.6.30-rc2/Documentation/kbuild/makefiles.txt	2009-04-22 03:29:10.048931429 +0000
+++ linux-2.6.30-rc3/Documentation/kbuild/makefiles.txt	2009-04-22 03:29:15.998931914 +0000
@@ -316,6 +316,16 @@
 		#arch/m68k/fpsp040/Makefile
 		ldflags-y := -x
 
+    subdir-ccflags-y, subdir-asflags-y
+	The two flags listed above are similar to ccflags-y and as-falgs-y.
+	The difference is that the subdir- variants has effect for the kbuild
+	file where tey are present and all subdirectories.
+	Options specified using subdir-* are added to the commandline before
+	the options specified using the non-subdir variants.
+
+	Example:
+		subdir-ccflags-y := -Werror
+
     CFLAGS_$@, AFLAGS_$@
 
 	CFLAGS_$@ and AFLAGS_$@ only apply to commands in current
diff -urN linux-2.6.30-rc2/Documentation/kernel-parameters.txt linux-2.6.30-rc3/Documentation/kernel-parameters.txt
--- linux-2.6.30-rc2/Documentation/kernel-parameters.txt	2009-04-22 03:29:10.049931473 +0000
+++ linux-2.6.30-rc3/Documentation/kernel-parameters.txt	2009-04-22 03:29:16.000931810 +0000
@@ -134,7 +134,7 @@
 ./include/asm/setup.h as COMMAND_LINE_SIZE.
 
 
-	acpi=		[HW,ACPI,X86-64,i386]
+	acpi=		[HW,ACPI,X86]
 			Advanced Configuration and Power Interface
 			Format: { force | off | ht | strict | noirq | rsdt }
 			force -- enable ACPI if default was off
@@ -218,7 +218,7 @@
 			acpi_osi="!string2"	# remove built-in string2
 			acpi_osi=		# disable all strings
 
-	acpi_pm_good	[X86-32,X86-64]
+	acpi_pm_good	[X86]
 			Override the pmtimer bug detection: force the kernel
 			to assume that this machine's pmtimer latches its value
 			and always returns good values.
@@ -231,6 +231,35 @@
  			power state again in power transition.
  			1 : disable the power state check
 
+	acpi_sci=	[HW,ACPI] ACPI System Control Interrupt trigger mode
+			Format: { level | edge | high | low }
+
+	acpi_serialize	[HW,ACPI] force serialization of AML methods
+
+	acpi_skip_timer_override [HW,ACPI]
+			Recognize and ignore IRQ0/pin2 Interrupt Override.
+			For broken nForce2 BIOS resulting in XT-PIC timer.
+
+	acpi_sleep=	[HW,ACPI] Sleep options
+			Format: { s3_bios, s3_mode, s3_beep, s4_nohwsig,
+				  old_ordering, s4_nonvs }
+			See Documentation/power/video.txt for information on
+			s3_bios and s3_mode.
+			s3_beep is for debugging; it makes the PC's speaker beep
+			as soon as the kernel's real-mode entry point is called.
+			s4_nohwsig prevents ACPI hardware signature from being
+			used during resume from hibernation.
+			old_ordering causes the ACPI 1.0 ordering of the _PTS
+			control method, with respect to putting devices into
+			low power states, to be enforced (the ACPI 2.0 ordering
+			of _PTS is used by default).
+			s4_nonvs prevents the kernel from saving/restoring the
+			ACPI NVS memory during hibernation.
+
+	acpi_use_timer_override [HW,ACPI]
+			Use timer override. For some broken Nvidia NF5 boards
+			that require a timer override, but don't have HPET
+
 	acpi_enforce_resources=	[ACPI]
 			{ strict | lax | no }
 			Check for resource conflicts between native drivers
@@ -250,6 +279,9 @@
 	ad1848=		[HW,OSS]
 			Format: <io>,<irq>,<dma>,<dma2>,<type>
 
+	add_efi_memmap	[EFI; X86] Include EFI memory map in
+			kernel's map of available physical RAM.
+
 	advansys=	[HW,SCSI]
 			See header of drivers/scsi/advansys.c.
 
@@ -459,7 +491,7 @@
 			Also note the kernel might malfunction if you disable
 			some critical bits.
 
-	code_bytes	[IA32/X86_64] How many bytes of object code to print
+	code_bytes	[X86] How many bytes of object code to print
 			in an oops report.
 			Range: 0 - 8192
 			Default: 64
@@ -592,7 +624,7 @@
 			MTRR settings.  This parameter disables that behavior,
 			possibly causing your machine to run very slowly.
 
-	disable_timer_pin_1 [i386,x86-64]
+	disable_timer_pin_1 [X86]
 			Disable PIN 1 of APIC timer
 			Can be useful to work around chipset bugs.
 
@@ -624,7 +656,7 @@
 			UART at the specified I/O port or MMIO address.
 			The options are the same as for ttyS, above.
 
-	earlyprintk=	[X86-32,X86-64,SH,BLACKFIN]
+	earlyprintk=	[X86,SH,BLACKFIN]
 			earlyprintk=vga
 			earlyprintk=serial[,ttySn[,baudrate]]
 			earlyprintk=dbgp
@@ -659,7 +691,7 @@
 			See Documentation/block/as-iosched.txt and
 			Documentation/block/deadline-iosched.txt for details.
 
-	elfcorehdr=	[IA64,PPC,SH,X86-32,X86_64]
+	elfcorehdr=	[IA64,PPC,SH,X86]
 			Specifies physical address of start of kernel core
 			image elf header. Generally kexec loader will
 			pass this option to capture kernel.
@@ -938,7 +970,7 @@
 			See comment before marvel_specify_io7 in
 			arch/alpha/kernel/core_marvel.c.
 
-	io_delay=	[X86-32,X86-64] I/O delay method
+	io_delay=	[X86] I/O delay method
 		0x80
 			Standard port 0x80 based delay
 		0xed
@@ -1000,7 +1032,7 @@
 
 	keepinitrd	[HW,ARM]
 
-	kernelcore=nn[KMG]	[KNL,X86-32,IA-64,PPC,X86-64] This parameter
+	kernelcore=nn[KMG]	[KNL,X86,IA-64,PPC] This parameter
 			specifies the amount of memory usable by the kernel
 			for non-movable allocations.  The requested amount is
 			spread evenly throughout all nodes in the system. The
@@ -1034,7 +1066,7 @@
 			Configure the RouterBoard 532 series on-chip
 			Ethernet adapter MAC address.
 
-	kstack=N	[X86-32,X86-64] Print N words from the kernel stack
+	kstack=N	[X86] Print N words from the kernel stack
 			in oops dumps.
 
 	l2cr=		[PPC]
@@ -1044,7 +1076,7 @@
 	lapic		[X86-32,APIC] Enable the local APIC even if BIOS
 			disabled it.
 
-	lapic_timer_c2_ok	[X86-32,x86-64,APIC] trust the local apic timer
+	lapic_timer_c2_ok	[X86,APIC] trust the local apic timer
 			in C2 power state.
 
 	libata.dma=	[LIBATA] DMA control
@@ -1229,7 +1261,7 @@
 			[KNL,SH] Allow user to override the default size for
 			per-device physically contiguous DMA buffers.
 
-	memmap=exactmap	[KNL,X86-32,X86_64] Enable setting of an exact
+	memmap=exactmap	[KNL,X86] Enable setting of an exact
 			E820 memory map, as specified by the user.
 			Such memmap=exactmap lines can be constructed based on
 			BIOS output or other requirements. See the memmap=nn@ss
@@ -1320,7 +1352,7 @@
 	mousedev.yres=	[MOUSE] Vertical screen resolution, used for devices
 			reporting absolute coordinates, such as tablets
 
-	movablecore=nn[KMG]	[KNL,X86-32,IA-64,PPC,X86-64] This parameter
+	movablecore=nn[KMG]	[KNL,X86,IA-64,PPC] This parameter
 			is similar to kernelcore except it specifies the
 			amount of memory used for migratable allocations.
 			If both kernelcore and movablecore is specified,
@@ -1422,7 +1454,7 @@
 			when a NMI is triggered.
 			Format: [state][,regs][,debounce][,die]
 
-	nmi_watchdog=	[KNL,BUGS=X86-32,X86-64] Debugging features for SMP kernels
+	nmi_watchdog=	[KNL,BUGS=X86] Debugging features for SMP kernels
 			Format: [panic,][num]
 			Valid num: 0,1,2
 			0 - turn nmi_watchdog off
@@ -1475,11 +1507,11 @@
 
 	nodsp		[SH] Disable hardware DSP at boot time.
 
-	noefi		[X86-32,X86-64] Disable EFI runtime services support.
+	noefi		[X86] Disable EFI runtime services support.
 
 	noexec		[IA-64]
 
-	noexec		[X86-32,X86-64]
+	noexec		[X86]
 			On X86-32 available only on PAE configured kernels.
 			noexec=on: enable non-executable mappings (default)
 			noexec=off: disable non-executable mappings
@@ -1525,7 +1557,7 @@
 	noirqdebug	[X86-32] Disables the code which attempts to detect and
 			disable unhandled interrupt sources.
 
-	no_timer_check	[X86-32,X86_64,APIC] Disables the code which tests for
+	no_timer_check	[X86,APIC] Disables the code which tests for
 			broken timer IRQ sources.
 
 	noisapnp	[ISAPNP] Disables ISA PnP code.
@@ -1689,7 +1721,7 @@
 				disable the use of PCIE advanced error reporting.
 		nodomains	[PCI] Disable support for multiple PCI
 				root domains (aka PCI segments, in ACPI-speak).
-		nommconf	[X86-32,X86_64] Disable use of MMCONFIG for PCI
+		nommconf	[X86] Disable use of MMCONFIG for PCI
 				Configuration
 		nomsi		[MSI] If the PCI_MSI kernel config parameter is
 				enabled, this kernel boot option can be used to
@@ -1838,6 +1870,12 @@
 			autoconfiguration.
 			Ranges are in pairs (memory base and size).
 
+	ports=		[IP_VS_FTP] IPVS ftp helper module
+			Default is 21.
+			Up to 8 (IP_VS_APP_MAX_PORTS) ports
+			may be specified.
+			Format: <port>,<port>....
+
 	print-fatal-signals=
 			[KNL] debug: print fatal signals
 			print-fatal-signals=1: print segfault info to
@@ -2380,7 +2418,7 @@
 			reported either.
 
 	unknown_nmi_panic
-			[X86-32,X86-64]
+			[X86]
 			Set unknown_nmi_panic=1 early on boot.
 
 	usbcore.autosuspend=
@@ -2447,12 +2485,12 @@
 					medium is write-protected).
 			Example: quirks=0419:aaf5:rl,0421:0433:rc
 
-	vdso=		[X86-32,SH,x86-64]
+	vdso=		[X86,SH]
 			vdso=2: enable compat VDSO (default with COMPAT_VDSO)
 			vdso=1: enable VDSO (default)
 			vdso=0: disable VDSO mapping
 
-	vdso32=		[X86-32,X86-64]
+	vdso32=		[X86]
 			vdso32=2: enable compat VDSO (default with COMPAT_VDSO)
 			vdso32=1: enable 32-bit VDSO (default)
 			vdso32=0: disable 32-bit VDSO mapping
diff -urN linux-2.6.30-rc2/Documentation/lguest/.gitignore linux-2.6.30-rc3/Documentation/lguest/.gitignore
--- linux-2.6.30-rc2/Documentation/lguest/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/lguest/.gitignore	2009-04-22 03:29:16.001931730 +0000
@@ -0,0 +1 @@
+lguest
diff -urN linux-2.6.30-rc2/Documentation/lguest/lguest.txt linux-2.6.30-rc3/Documentation/lguest/lguest.txt
--- linux-2.6.30-rc2/Documentation/lguest/lguest.txt	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/lguest/lguest.txt	2009-04-22 03:29:16.002931702 +0000
@@ -3,11 +3,11 @@
  /,    /`      - or, A Young Coder's Illustrated Hypervisor
  \\"--\\    http://lguest.ozlabs.org
 
-Lguest is designed to be a minimal hypervisor for the Linux kernel, for
-Linux developers and users to experiment with virtualization with the
-minimum of complexity.  Nonetheless, it should have sufficient
-features to make it useful for specific tasks, and, of course, you are
-encouraged to fork and enhance it (see drivers/lguest/README).
+Lguest is designed to be a minimal 32-bit x86 hypervisor for the Linux kernel,
+for Linux developers and users to experiment with virtualization with the
+minimum of complexity.  Nonetheless, it should have sufficient features to
+make it useful for specific tasks, and, of course, you are encouraged to fork
+and enhance it (see drivers/lguest/README).
 
 Features:
 
@@ -37,6 +37,7 @@
      "Paravirtualized guest support" = Y
         "Lguest guest support" = Y
      "High Memory Support" = off/4GB
+     "PAE (Physical Address Extension) Support" = N
      "Alignment value to which kernel should be aligned" = 0x100000
         (CONFIG_PARAVIRT=y, CONFIG_LGUEST_GUEST=y, CONFIG_HIGHMEM64G=n and
          CONFIG_PHYSICAL_ALIGN=0x100000)
diff -urN linux-2.6.30-rc2/Documentation/networking/bonding.txt linux-2.6.30-rc3/Documentation/networking/bonding.txt
--- linux-2.6.30-rc2/Documentation/networking/bonding.txt	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/networking/bonding.txt	2009-04-22 03:29:16.004931946 +0000
@@ -1242,7 +1242,7 @@
 To add ARP targets:
 # echo +192.168.0.100 > /sys/class/net/bond0/bonding/arp_ip_target
 # echo +192.168.0.101 > /sys/class/net/bond0/bonding/arp_ip_target
-	NOTE:  up to 10 target addresses may be specified.
+	NOTE:  up to 16 target addresses may be specified.
 
 To remove an ARP target:
 # echo -192.168.0.100 > /sys/class/net/bond0/bonding/arp_ip_target
diff -urN linux-2.6.30-rc2/Documentation/powerpc/dts-bindings/fsl/i2c.txt linux-2.6.30-rc3/Documentation/powerpc/dts-bindings/fsl/i2c.txt
--- linux-2.6.30-rc2/Documentation/powerpc/dts-bindings/fsl/i2c.txt	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/powerpc/dts-bindings/fsl/i2c.txt	2009-04-22 03:29:16.007931815 +0000
@@ -7,8 +7,10 @@
 
 Recommended properties :
 
- - compatible : Should be "fsl-i2c" for parts compatible with
-   Freescale I2C specifications.
+ - compatible : compatibility list with 2 entries, the first should
+   be "fsl,CHIP-i2c" where CHIP is the name of a compatible processor,
+   e.g. mpc8313, mpc8543, mpc8544, mpc5200 or mpc5200b. The second one
+   should be "fsl-i2c".
  - interrupts : <a b> where a is the interrupt number and b is a
    field that represents an encoding of the sense and level
    information for the interrupt.  This should be encoded based on
@@ -16,17 +18,31 @@
    controller you have.
  - interrupt-parent : the phandle for the interrupt controller that
    services interrupts for this device.
- - dfsrr : boolean; if defined, indicates that this I2C device has
-   a digital filter sampling rate register
- - fsl5200-clocking : boolean; if defined, indicated that this device
-   uses the FSL 5200 clocking mechanism.
-
-Example :
-	i2c@3000 {
-		interrupt-parent = <40000>;
-		interrupts = <1b 3>;
-		reg = <3000 18>;
-		device_type = "i2c";
-		compatible  = "fsl-i2c";
-		dfsrr;
+ - fsl,preserve-clocking : boolean; if defined, the clock settings
+   from the bootloader are preserved (not touched).
+ - clock-frequency : desired I2C bus clock frequency in Hz.
+
+Examples :
+
+	i2c@3d00 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "fsl,mpc5200b-i2c","fsl,mpc5200-i2c","fsl-i2c";
+		cell-index = <0>;
+		reg = <0x3d00 0x40>;
+		interrupts = <2 15 0>;
+		interrupt-parent = <&mpc5200_pic>;
+		fsl,preserve-clocking;
 	};
+
+	i2c@3100 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		cell-index = <1>;
+		compatible = "fsl,mpc8544-i2c", "fsl-i2c";
+		reg = <0x3100 0x100>;
+		interrupts = <43 2>;
+		interrupt-parent = <&mpic>;
+		clock-frequency = <400000>;
+	};
+
diff -urN linux-2.6.30-rc2/Documentation/sound/alsa/HD-Audio.txt linux-2.6.30-rc3/Documentation/sound/alsa/HD-Audio.txt
--- linux-2.6.30-rc2/Documentation/sound/alsa/HD-Audio.txt	2009-04-22 03:29:10.060935668 +0000
+++ linux-2.6.30-rc3/Documentation/sound/alsa/HD-Audio.txt	2009-04-22 03:29:16.017931728 +0000
@@ -169,7 +169,7 @@
 What `model` option values are available depends on the codec chip.
 Check your codec chip from the codec proc file (see "Codec Proc-File"
 section below).  It will show the vendor/product name of your codec
-chip.  Then, see Documentation/sound/alsa/HD-Audio-Modelstxt file,
+chip.  Then, see Documentation/sound/alsa/HD-Audio-Models.txt file,
 the section of HD-audio driver.  You can find a list of codecs
 and `model` options belonging to each codec.  For example, for Realtek
 ALC262 codec chip, pass `model=ultra` for devices that are compatible
@@ -177,7 +177,7 @@
 
 Thus, the first thing you can do for any brand-new, unsupported and
 non-working HD-audio hardware is to check HD-audio codec and several
-different `model` option values.  If you have a luck, some of them
+different `model` option values.  If you have any luck, some of them
 might suit with your device well.
 
 Some codecs such as ALC880 have a special model option `model=test`.
diff -urN linux-2.6.30-rc2/Documentation/spi/spi-summary linux-2.6.30-rc3/Documentation/spi/spi-summary
--- linux-2.6.30-rc2/Documentation/spi/spi-summary	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/Documentation/spi/spi-summary	2009-04-22 03:29:16.018931688 +0000
@@ -511,10 +511,16 @@
 	This sets up the device clock rate, SPI mode, and word sizes.
 	Drivers may change the defaults provided by board_info, and then
 	call spi_setup(spi) to invoke this routine.  It may sleep.
+
 	Unless each SPI slave has its own configuration registers, don't
 	change them right away ... otherwise drivers could corrupt I/O
 	that's in progress for other SPI devices.
 
+		** BUG ALERT:  for some reason the first version of
+		** many spi_master drivers seems to get this wrong.
+		** When you code setup(), ASSUME that the controller
+		** is actively processing transfers for another device.
+
     master->transfer(struct spi_device *spi, struct spi_message *message)
     	This must not sleep.  Its responsibility is arrange that the
 	transfer happens and its complete() callback is issued.  The two
diff -urN linux-2.6.30-rc2/MAINTAINERS linux-2.6.30-rc3/MAINTAINERS
--- linux-2.6.30-rc2/MAINTAINERS	2009-04-22 03:29:10.071931226 +0000
+++ linux-2.6.30-rc3/MAINTAINERS	2009-04-22 03:29:16.034931479 +0000
@@ -543,6 +543,14 @@
 F:	arch/arm/lib/floppydma.S
 F:	arch/arm/include/asm/floppy.h
 
+ARM PORT
+P:	Russell King
+M:	linux@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
+W:	http://www.arm.linux.org.uk/
+S:	Maintained
+F:	arch/arm/
+
 ARM PRIMECELL MMCI PL180/1 DRIVER
 S:	Orphan
 F:	drivers/mmc/host/mmci.*
@@ -592,6 +600,13 @@
 L:	linux-arm-kernel@lists.arm.linux.org.uk (subscribers-only)
 S:	Maintained
 
+ARM/CLKDEV SUPPORT
+P:	Russell King
+M:	linux@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
+F:	arch/arm/common/clkdev.c
+F:	arch/arm/include/asm/clkdev.h
+
 ARM/COMPULAB CM-X270/EM-X270 and CM-X300 MACHINE SUPPORT
 P:	Mike Rapoport
 M:	mike@compulab.co.il
@@ -610,6 +625,15 @@
 T:	git git://gitorious.org/linux-gemini/mainline.git
 S:	Maintained
 
+ARM/EBSA110 MACHINE SUPPORT
+P:	Russell King
+M:	linux@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
+W:	http://www.arm.linux.org.uk/
+S:	Maintained
+F:	arch/arm/mach-ebsa110/
+F:	drivers/net/arm/am79c961a.*
+
 ARM/EZX SMARTPHONES (A780, A910, A1200, E680, ROKR E2 and ROKR E6)
 P:	Daniel Ribeiro
 M:	drwyrm@gmail.com
@@ -627,6 +651,15 @@
 L:	linux-arm-kernel@lists.arm.linux.org.uk (subscribers-only)
 S:	Maintained
 
+ARM/FOOTBRIDGE ARCHITECTURE
+P:	Russell King
+M:	linux@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
+W:	http://www.arm.linux.org.uk/
+S:	Maintained
+F:	arch/arm/include/asm/hardware/dec21285.h
+F:	arch/arm/mach-footbridge/
+
 ARM/FREESCALE IMX / MXC ARM ARCHITECTURE
 P:	Sascha Hauer
 M:	kernel@pengutronix.de
@@ -767,19 +800,27 @@
 L:	linux-arm-kernel@lists.arm.linux.org.uk (subscribers-only)
 S:	Maintained
 
+ARM/RISCPC ARCHITECTURE
+P:	Russell King
+M:	linux@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
+W:	http://www.arm.linux.org.uk/
+S:	Maintained
+F:	arch/arm/common/time-acorn.c
+F:	arch/arm/include/asm/hardware/entry-macro-iomd.S
+F:	arch/arm/include/asm/hardware/ioc.h
+F:	arch/arm/include/asm/hardware/iomd.h
+F:	arch/arm/include/asm/hardware/memc.h
+F:	arch/arm/mach-rpc/
+F:	drivers/net/arm/ether*
+F:	drivers/scsi/arm/
+
 ARM/SHARK MACHINE SUPPORT
 P:	Alexander Schulz
 M:	alex@shark-linux.de
 W:	http://www.shark-linux.de/shark.html
 S:	Maintained
 
-ARM/STRONGARM110 PORT
-P:	Russell King
-M:	rmk@arm.linux.org.uk
-L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
-W:	http://www.arm.linux.org.uk/
-S:	Maintained
-
 ARM/S3C2410 ARM ARCHITECTURE
 P:	Ben Dooks
 M:	ben-linux@fluff.org
@@ -813,6 +854,14 @@
 W:	http://www.mcuos.com
 S:	Maintained
 
+ARM/VFP SUPPORT
+P:	Russell King
+M:	linux@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
+W:	http://www.arm.linux.org.uk/
+S:	Maintained
+F:	arch/arm/vfp/
+
 ARPD SUPPORT
 P:	Jonathan Layes
 L:	netdev@vger.kernel.org
@@ -1238,6 +1287,14 @@
 F:	Documentation/video4linux/bttv/
 F:	drivers/media/video/bt8xx/bttv*
 
+CACHEFILES: FS-CACHE BACKEND FOR CACHING ON MOUNTED FILESYSTEMS
+P:	David Howells
+M:	dhowells@redhat.com
+L:	linux-cachefs@redhat.com
+S:	Supported
+F:	Documentation/filesystems/caching/cachefiles.txt
+F:	fs/cachefiles/
+
 CAFE CMOS INTEGRATED CAMERA CONTROLLER DRIVER
 P:	Jonathan Corbet
 M:	corbet@lwn.net
@@ -1372,6 +1429,11 @@
 F:	Documentation/input/cs461x.txt
 F:	sound/pci/cs46xx/
 
+CLK API
+P:	Russell King
+M:	linux@arm.linux.org.uk
+F:	include/linux/clk.h
+
 CODA FILE SYSTEM
 P:	Jan Harkes
 M:	jaharkes@cs.cmu.edu
@@ -1576,7 +1638,8 @@
 
 CYBERPRO FB DRIVER
 P:	Russell King
-M:	rmk@arm.linux.org.uk
+M:	linux@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
 W:	http://www.arm.linux.org.uk/
 S:	Maintained
 F:	drivers/video/cyber2000fb.*
@@ -2002,6 +2065,8 @@
 EMBEDDED LINUX
 P:	Paul Gortmaker
 M:	paul.gortmaker@windriver.com
+P:	Matt Mackall
+M:	mpm@selenic.com
 P:	David Woodhouse
 M:	dwmw2@infradead.org
 L:	linux-embedded@vger.kernel.org
@@ -2270,6 +2335,15 @@
 F:	include/linux/freezer.h
 F:	kernel/freezer.c
 
+FS-CACHE: LOCAL CACHING FOR NETWORK FILESYSTEMS
+P:	David Howells
+M:	dhowells@redhat.com
+L:	linux-cachefs@redhat.com
+S:	Supported
+F:	Documentation/filesystems/caching/
+F:	fs/fscache/
+F:	include/linux/fscache*.h
+
 FTRACE
 P:	Steven Rostedt
 M:	rostedt@goodmis.org
@@ -2490,7 +2564,6 @@
 F:	include/linux/suspend.h
 F:	include/linux/freezer.h
 F:	include/linux/pm.h
-F:	include/asm-*/suspend*.h
 F:	arch/*/include/asm/suspend*.h
 
 HID CORE LAYER
@@ -3268,7 +3341,7 @@
 M:	eduard.munteanu@linux360.ro
 L:	linux-kernel@vger.kernel.org
 S:	Maintained
-F:	Documentation/vm/kmemtrace.txt
+F:	Documentation/trace/kmemtrace.txt
 F:	include/trace/kmemtrace.h
 F:	kernel/trace/kmemtrace.c
 
@@ -3917,19 +3990,12 @@
 F:	drivers/block/nbd.c
 F:	include/linux/nbd.h
 
-NETWORK DEVICE DRIVERS
-P:	Jeff Garzik
-M:	jgarzik@pobox.com
-L:	netdev@vger.kernel.org
-T:	git git://git.kernel.org/pub/scm/linux/kernel/git/jgarzik/netdev-2.6.git
-S:	Maintained
-F:	drivers/net/
-
 NETWORKING [GENERAL]
-P:	Networking Team
-M:	netdev@vger.kernel.org
+P:	David S. Miller
+M:	davem@davemloft.net
 L:	netdev@vger.kernel.org
 W:	http://linux-net.osdl.org/
+T:	git kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6.git
 S:	Maintained
 F:	net/
 F:	include/net/
@@ -5187,7 +5253,12 @@
 P:	Takashi Iwai
 M:	tiwai@suse.de
 L:	alsa-devel@alsa-project.org (subscribers-only)
+W:	http://www.alsa-project.org/
+T:	git git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6.git
+T:	git git://git.alsa-project.org/alsa-kernel.git
 S:	Maintained
+F:	Documentation/sound/
+F:	include/sound/
 F:	sound/
 
 SOUND - SOC LAYER / DYNAMIC AUDIO POWER MANAGEMENT (ASoC)
@@ -5334,7 +5405,6 @@
 F:	include/linux/suspend.h
 F:	include/linux/freezer.h
 F:	include/linux/pm.h
-F:	include/asm-*/suspend.h
 
 SVGA HANDLING
 P:	Martin Mares
@@ -5568,7 +5638,7 @@
 S:	Maintained
 F:	arch/m68knommu/
 
-UCLINUX FOR RENESAS H8/300
+UCLINUX FOR RENESAS H8/300 (H8300)
 P:	Yoshinori Sato
 M:	ysato@users.sourceforge.jp
 W:	http://uclinux-h8.sourceforge.jp/
diff -urN linux-2.6.30-rc2/Makefile linux-2.6.30-rc3/Makefile
--- linux-2.6.30-rc2/Makefile	2009-04-22 03:29:10.072931189 +0000
+++ linux-2.6.30-rc3/Makefile	2009-04-22 03:29:16.035931309 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 30
-EXTRAVERSION = -rc2
+EXTRAVERSION = -rc3
 NAME = Temporary Tasmanian Devil
 
 # *DOCUMENTATION*
@@ -1200,7 +1200,7 @@
                 .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map
 
 # Directories & files removed with 'make mrproper'
-MRPROPER_DIRS  += include/config include2 usr/include
+MRPROPER_DIRS  += include/config include2 usr/include include/generated
 MRPROPER_FILES += .config .config.old include/asm .version .old_version \
                   include/linux/autoconf.h include/linux/version.h      \
                   include/linux/utsrelease.h                            \
diff -urN linux-2.6.30-rc2/arch/alpha/include/asm/percpu.h linux-2.6.30-rc3/arch/alpha/include/asm/percpu.h
--- linux-2.6.30-rc2/arch/alpha/include/asm/percpu.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/alpha/include/asm/percpu.h	2009-04-22 03:29:16.036931689 +0000
@@ -73,6 +73,6 @@
 
 #endif /* SMP */
 
-#define DECLARE_PER_CPU(type, name) extern __typeof__(type) per_cpu_var(name)
+#include <asm-generic/percpu.h>
 
 #endif /* __ALPHA_PERCPU_H */
diff -urN linux-2.6.30-rc2/arch/arm/common/vic.c linux-2.6.30-rc3/arch/arm/common/vic.c
--- linux-2.6.30-rc2/arch/arm/common/vic.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/common/vic.c	2009-04-22 03:29:16.047806673 +0000
@@ -85,12 +85,11 @@
 	writel(32, base + VIC_PL190_DEF_VECT_ADDR);
 
 	for (i = 0; i < 32; i++) {
-		unsigned int irq = irq_start + i;
-
-		set_irq_chip(irq, &vic_chip);
-		set_irq_chip_data(irq, base);
-
 		if (vic_sources & (1 << i)) {
+			unsigned int irq = irq_start + i;
+
+			set_irq_chip(irq, &vic_chip);
+			set_irq_chip_data(irq, base);
 			set_irq_handler(irq, handle_level_irq);
 			set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 		}
diff -urN linux-2.6.30-rc2/arch/arm/configs/imx27ads_defconfig linux-2.6.30-rc3/arch/arm/configs/imx27ads_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/imx27ads_defconfig	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/imx27ads_defconfig	1970-01-01 00:00:00.000000000 +0000
@@ -1,826 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.26-rc6
-# Fri Jun 20 16:29:34 2008
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
-CONFIG_ARCH_MTD_XIP=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-CONFIG_POSIX_MQUEUE=y
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-# CONFIG_IKCONFIG is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CGROUPS is not set
-# CONFIG_GROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_BLK_DEV_INITRD is not set
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SYSCTL=y
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-CONFIG_SYSCTL_SYSCALL=y
-CONFIG_SYSCTL_SYSCALL_CHECK=y
-CONFIG_KALLSYMS=y
-CONFIG_KALLSYMS_EXTRA_PASS=y
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_COMPAT_BRK=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-# CONFIG_MARKERS is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-# CONFIG_HAVE_DMA_ATTRS is not set
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-# CONFIG_TINY_SHMEM is not set
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-# CONFIG_KMOD is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_LSF is not set
-# CONFIG_BLK_DEV_BSG is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IOSCHED_AS is not set
-# CONFIG_IOSCHED_DEADLINE is not set
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-# CONFIG_DEFAULT_DEADLINE is not set
-# CONFIG_DEFAULT_CFQ is not set
-CONFIG_DEFAULT_NOOP=y
-CONFIG_DEFAULT_IOSCHED="noop"
-CONFIG_CLASSIC_RCU=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS7500 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-CONFIG_ARCH_MXC=y
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_MSM7X00A is not set
-
-#
-# Boot options
-#
-
-#
-# Power management
-#
-
-#
-# Freescale MXC Implementations
-#
-CONFIG_ARCH_MX2=y
-# CONFIG_ARCH_MX3 is not set
-
-#
-# MX2 family CPU support
-#
-CONFIG_MACH_MX27=y
-
-#
-# MX2 Platforms
-#
-CONFIG_MACH_MX27ADS=y
-# CONFIG_MACH_PCM038 is not set
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_ARM926T=y
-CONFIG_CPU_32v5=y
-CONFIG_CPU_ABRT_EV5TJ=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_VIVT=y
-CONFIG_CPU_COPY_V4WB=y
-CONFIG_CPU_TLB_V4WBI=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
-# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4096
-# CONFIG_RESOURCES_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-CONFIG_VIRT_TO_BUS=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE=""
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-# CONFIG_VFP is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-# CONFIG_PM is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-
-#
-# Networking
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-
-#
-# Wireless
-#
-# CONFIG_CFG80211 is not set
-# CONFIG_WIRELESS_EXT is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_IEEE80211 is not set
-# CONFIG_RFKILL is not set
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-# CONFIG_MTD_CFI_I2 is not set
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_OTP is not set
-CONFIG_MTD_CFI_INTELEXT=y
-# CONFIG_MTD_CFI_AMDSTD is not set
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_XIP is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_PHYSMAP_START=0x00000000
-CONFIG_MTD_PHYSMAP_LEN=0x0
-CONFIG_MTD_PHYSMAP_BANKWIDTH=2
-# CONFIG_MTD_ARM_INTEGRATOR is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_MISC_DEVICES is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-# CONFIG_MD is not set
-CONFIG_NETDEVICES=y
-# CONFIG_NETDEVICES_MULTIQUEUE is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
-# CONFIG_AX88796 is not set
-# CONFIG_SMC91X is not set
-# CONFIG_DM9000 is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_B44 is not set
-# CONFIG_FEC_OLD is not set
-# CONFIG_NETDEV_1000 is not set
-# CONFIG_NETDEV_10000 is not set
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-# CONFIG_WAN is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_UCB1400 is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-CONFIG_DEVKMEM=y
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_IMX is not set
-CONFIG_UNIX98_PTYS=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_NVRAM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_I2C is not set
-# CONFIG_SPI is not set
-CONFIG_HAVE_GPIO_LIB=y
-
-#
-# GPIO Support
-#
-
-#
-# I2C GPIO expanders:
-#
-
-#
-# SPI GPIO expanders:
-#
-# CONFIG_W1 is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_HWMON is not set
-# CONFIG_WATCHDOG is not set
-
-#
-# Sonics Silicon Backplane
-#
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_HTC_EGPIO is not set
-# CONFIG_HTC_PASIC3 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-# CONFIG_VIDEO_DEV is not set
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
-
-#
-# Multimedia drivers
-#
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-# CONFIG_HID_SUPPORT is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_MMC is not set
-# CONFIG_NEW_LEDS is not set
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_CLASS is not set
-# CONFIG_UIO is not set
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4DEV_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_INOTIFY is not set
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_BIND34 is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=m
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-CONFIG_NLS_CODEPAGE_850=m
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-CONFIG_NLS_ISO8859_15=m
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_PRINTK_TIME is not set
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_FS is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_KERNEL is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_SAMPLES is not set
-# CONFIG_DEBUG_USER is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-# CONFIG_GENERIC_FIND_FIRST_BIT is not set
-# CONFIG_GENERIC_FIND_NEXT_BIT is not set
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/mx1_defconfig linux-2.6.30-rc3/arch/arm/configs/mx1_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/mx1_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/mx1_defconfig	2009-04-22 03:29:16.061931793 +0000
@@ -0,0 +1,1105 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.30-rc1
+# Wed Apr  8 11:11:33 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_USER_SCHED=y
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+CONFIG_ARCH_MX1ADS=y
+
+#
+# Freescale MXC Implementations
+#
+CONFIG_ARCH_MX1=y
+# CONFIG_ARCH_MX2 is not set
+# CONFIG_ARCH_MX3 is not set
+
+#
+# MX1 platforms:
+#
+CONFIG_MACH_MXLADS=y
+CONFIG_MACH_SCB9328=y
+CONFIG_MXC_IRQ_PRIOR=y
+# CONFIG_MXC_PWM is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4T=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_VERBOSE is not set
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+CONFIG_COMPAT_NET_DEV_OPS=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+CONFIG_DM9000_DEBUGLEVEL=4
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_IMX=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+CONFIG_W1=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=y
+# CONFIG_W1_MASTER_GPIO is not set
+
+#
+# 1-wire Slaves
+#
+CONFIG_W1_SLAVE_THERM=y
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+CONFIG_USB_GADGET_IMX=y
+CONFIG_USB_IMX=y
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=y
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MXC=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_EVENT_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/mx27_defconfig linux-2.6.30-rc3/arch/arm/configs/mx27_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/mx27_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/mx27_defconfig	2009-04-22 03:29:16.062931686 +0000
@@ -0,0 +1,1174 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.30-rc1
+# Wed Apr  8 10:18:06 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_USER_SCHED=y
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX1 is not set
+CONFIG_ARCH_MX2=y
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_MACH_MX21 is not set
+CONFIG_MACH_MX27=y
+
+#
+# MX2 platforms:
+#
+CONFIG_MACH_MX27ADS=y
+CONFIG_MACH_PCM038=y
+CONFIG_MACH_PCM970_BASEBOARD=y
+CONFIG_MXC_IRQ_PRIOR=y
+CONFIG_MXC_PWM=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_VERBOSE is not set
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+CONFIG_COMPAT_NET_DEV_OPS=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+CONFIG_FEC=y
+# CONFIG_FEC2 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_IMX=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+CONFIG_W1=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=y
+# CONFIG_W1_MASTER_GPIO is not set
+
+#
+# 1-wire Slaves
+#
+CONFIG_W1_SLAVE_THERM=y
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_IMX=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MXC=y
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+CONFIG_RTC_DRV_PCF8563=y
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+# CONFIG_PROC_PAGE_MONITOR is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=m
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=m
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_EVENT_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/mx31ads_defconfig linux-2.6.30-rc3/arch/arm/configs/mx31ads_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/mx31ads_defconfig	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/mx31ads_defconfig	1970-01-01 00:00:00.000000000 +0000
@@ -1,839 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.26-rc6
-# Fri Jun 20 16:21:11 2008
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
-CONFIG_ARCH_MTD_XIP=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CGROUPS is not set
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-# CONFIG_RT_GROUP_SCHED is not set
-CONFIG_USER_SCHED=y
-# CONFIG_CGROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_BLK_DEV_INITRD is not set
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-CONFIG_SYSCTL_SYSCALL=y
-CONFIG_SYSCTL_SYSCALL_CHECK=y
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_COMPAT_BRK=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-# CONFIG_MARKERS is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-# CONFIG_HAVE_DMA_ATTRS is not set
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-# CONFIG_TINY_SHMEM is not set
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_KMOD=y
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_LSF is not set
-# CONFIG_BLK_DEV_BSG is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_DEFAULT_AS is not set
-# CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-CONFIG_CLASSIC_RCU=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS7500 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-CONFIG_ARCH_MXC=y
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_MSM7X00A is not set
-
-#
-# Boot options
-#
-
-#
-# Power management
-#
-
-#
-# Freescale MXC Implementations
-#
-# CONFIG_ARCH_MX2 is not set
-CONFIG_ARCH_MX3=y
-
-#
-# MX3 Options
-#
-CONFIG_MACH_MX31ADS=y
-# CONFIG_MACH_PCM037 is not set
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_RESOURCES_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-CONFIG_VIRT_TO_BUS=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-# CONFIG_PM is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-
-#
-# Networking
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
-# CONFIG_INET_LRO is not set
-CONFIG_INET_DIAG=y
-CONFIG_INET_TCP_DIAG=y
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-
-#
-# Wireless
-#
-# CONFIG_CFG80211 is not set
-# CONFIG_WIRELESS_EXT is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_IEEE80211 is not set
-# CONFIG_RFKILL is not set
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=m
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-CONFIG_MTD_REDBOOT_PARTS=y
-CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
-# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
-# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-# CONFIG_MTD_CFI_I2 is not set
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_OTP is not set
-# CONFIG_MTD_CFI_INTELEXT is not set
-CONFIG_MTD_CFI_AMDSTD=y
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-CONFIG_MTD_RAM=y
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_XIP is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PHYSMAP is not set
-# CONFIG_MTD_ARM_INTEGRATOR is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-CONFIG_MTD_NAND=y
-# CONFIG_MTD_NAND_VERIFY_WRITE is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
-# CONFIG_MTD_NAND_MUSEUM_IDS is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND_DISKONCHIP is not set
-# CONFIG_MTD_NAND_NANDSIM is not set
-# CONFIG_MTD_NAND_PLATFORM is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-# CONFIG_BLK_DEV is not set
-# CONFIG_MISC_DEVICES is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-# CONFIG_MD is not set
-CONFIG_NETDEVICES=y
-# CONFIG_NETDEVICES_MULTIQUEUE is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-# CONFIG_SMC91X is not set
-# CONFIG_DM9000 is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_B44 is not set
-# CONFIG_NETDEV_1000 is not set
-# CONFIG_NETDEV_10000 is not set
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-# CONFIG_WAN is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-# CONFIG_INPUT is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-CONFIG_DEVKMEM=y
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_IMX=y
-CONFIG_SERIAL_IMX_CONSOLE=y
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_NVRAM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_I2C is not set
-# CONFIG_SPI is not set
-CONFIG_HAVE_GPIO_LIB=y
-
-#
-# GPIO Support
-#
-
-#
-# I2C GPIO expanders:
-#
-
-#
-# SPI GPIO expanders:
-#
-# CONFIG_W1 is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_HWMON is not set
-# CONFIG_WATCHDOG is not set
-
-#
-# Sonics Silicon Backplane
-#
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_HTC_EGPIO is not set
-# CONFIG_HTC_PASIC3 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-# CONFIG_VIDEO_DEV is not set
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
-
-#
-# Multimedia drivers
-#
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_MMC is not set
-# CONFIG_NEW_LEDS is not set
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_CLASS is not set
-# CONFIG_UIO is not set
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4DEV_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-CONFIG_CRAMFS=y
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-# CONFIG_NFS_V3 is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_BIND34 is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_NLS is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_FS is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_KERNEL is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_SAMPLES is not set
-# CONFIG_DEBUG_USER is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_MANAGER is not set
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-# CONFIG_CRYPTO_CBC is not set
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-# CONFIG_CRYPTO_HMAC is not set
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-# CONFIG_CRYPTO_AES is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-# CONFIG_CRYPTO_HW is not set
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-# CONFIG_GENERIC_FIND_FIRST_BIT is not set
-# CONFIG_GENERIC_FIND_NEXT_BIT is not set
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/mx31litekit_defconfig linux-2.6.30-rc3/arch/arm/configs/mx31litekit_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/mx31litekit_defconfig	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/mx31litekit_defconfig	1970-01-01 00:00:00.000000000 +0000
@@ -1,1100 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.26-rc5
-# Fri Jun 13 14:23:39 2008
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-# CONFIG_GENERIC_GPIO is not set
-# CONFIG_GENERIC_TIME is not set
-# CONFIG_GENERIC_CLOCKEVENTS is not set
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
-CONFIG_ARCH_MTD_XIP=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CGROUPS is not set
-# CONFIG_GROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_BLK_DEV_INITRD is not set
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-CONFIG_SYSCTL_SYSCALL=y
-CONFIG_SYSCTL_SYSCALL_CHECK=y
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_COMPAT_BRK=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-# CONFIG_MARKERS is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-# CONFIG_HAVE_DMA_ATTRS is not set
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-# CONFIG_TINY_SHMEM is not set
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_KMOD=y
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_LSF is not set
-# CONFIG_BLK_DEV_BSG is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_DEFAULT_AS is not set
-# CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-CONFIG_CLASSIC_RCU=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS7500 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-CONFIG_ARCH_MXC=y
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_MSM7X00A is not set
-
-#
-# Boot options
-#
-
-#
-# Power management
-#
-
-#
-# Freescale MXC Implementations
-#
-CONFIG_ARCH_MX3=y
-
-#
-# MX3 Options
-#
-# CONFIG_MACH_MX31ADS is not set
-CONFIG_MACH_MX31LITE=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-CONFIG_PCCARD=m
-# CONFIG_PCMCIA_DEBUG is not set
-# CONFIG_PCMCIA is not set
-
-#
-# PC-card bridges
-#
-
-#
-# Kernel Features
-#
-# CONFIG_TICK_ONESHOT is not set
-CONFIG_PREEMPT=y
-# CONFIG_NO_IDLE_HZ is not set
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_RESOURCES_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-CONFIG_VIRT_TO_BUS=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_BINFMT_AOUT=y
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-# CONFIG_SUSPEND is not set
-# CONFIG_APM_EMULATION is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-
-#
-# Networking
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
-# CONFIG_INET_LRO is not set
-CONFIG_INET_DIAG=y
-CONFIG_INET_TCP_DIAG=y
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-
-#
-# Wireless
-#
-# CONFIG_CFG80211 is not set
-# CONFIG_WIRELESS_EXT is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_IEEE80211 is not set
-# CONFIG_RFKILL is not set
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=m
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-CONFIG_MTD_REDBOOT_PARTS=y
-CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
-# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
-# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-# CONFIG_MTD_CFI_I2 is not set
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_OTP is not set
-# CONFIG_MTD_CFI_INTELEXT is not set
-CONFIG_MTD_CFI_AMDSTD=y
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-CONFIG_MTD_RAM=y
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_XIP is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PHYSMAP is not set
-# CONFIG_MTD_ARM_INTEGRATOR is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-CONFIG_MTD_NAND=y
-# CONFIG_MTD_NAND_VERIFY_WRITE is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
-# CONFIG_MTD_NAND_MUSEUM_IDS is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND_DISKONCHIP is not set
-# CONFIG_MTD_NAND_NANDSIM is not set
-# CONFIG_MTD_NAND_PLATFORM is not set
-# CONFIG_MTD_ALAUDA is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-# CONFIG_BLK_DEV is not set
-# CONFIG_MISC_DEVICES is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=y
-CONFIG_SCSI_DMA=y
-# CONFIG_SCSI_TGT is not set
-# CONFIG_SCSI_NETLINK is not set
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_SCH is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-# CONFIG_SCSI_SCAN_ASYNC is not set
-CONFIG_SCSI_WAIT_SCAN=m
-
-#
-# SCSI Transports
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-CONFIG_SCSI_LOWLEVEL=y
-# CONFIG_ISCSI_TCP is not set
-# CONFIG_SCSI_DEBUG is not set
-# CONFIG_ATA is not set
-# CONFIG_MD is not set
-CONFIG_NETDEVICES=y
-# CONFIG_NETDEVICES_MULTIQUEUE is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-# CONFIG_SMC91X is not set
-# CONFIG_DM9000 is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_B44 is not set
-# CONFIG_NETDEV_1000 is not set
-# CONFIG_NETDEV_10000 is not set
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_USBNET is not set
-# CONFIG_WAN is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input Device Drivers
-#
-CONFIG_INPUT_KEYBOARD=y
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_LKKBD is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-# CONFIG_KEYBOARD_STOWAWAY is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_UCB1400 is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-# CONFIG_VT_HW_CONSOLE_BINDING is not set
-CONFIG_DEVKMEM=y
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_UNIX98_PTYS=y
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=256
-# CONFIG_IPMI_HANDLER is not set
-CONFIG_HW_RANDOM=y
-# CONFIG_NVRAM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_I2C is not set
-# CONFIG_SPI is not set
-# CONFIG_W1 is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_HWMON is not set
-CONFIG_WATCHDOG=y
-CONFIG_WATCHDOG_NOWAYOUT=y
-
-#
-# Watchdog Device Drivers
-#
-# CONFIG_SOFT_WATCHDOG is not set
-
-#
-# USB-based Watchdog Cards
-#
-# CONFIG_USBPCWATCHDOG is not set
-
-#
-# Sonics Silicon Backplane
-#
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_HTC_PASIC3 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-CONFIG_VIDEO_ALLOW_V4L1=y
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-CONFIG_VIDEO_MEDIA=y
-
-#
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-CONFIG_VIDEO_V4L2=y
-CONFIG_VIDEO_V4L1=y
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-# CONFIG_VIDEO_ADV_DEBUG is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_CPIA is not set
-# CONFIG_VIDEO_CPIA2 is not set
-CONFIG_V4L_USB_DRIVERS=y
-# CONFIG_USB_VICAM is not set
-# CONFIG_USB_IBMCAM is not set
-# CONFIG_USB_KONICAWC is not set
-# CONFIG_USB_QUICKCAM_MESSENGER is not set
-# CONFIG_USB_ET61X251 is not set
-# CONFIG_USB_OV511 is not set
-# CONFIG_USB_SE401 is not set
-# CONFIG_USB_SN9C102 is not set
-# CONFIG_USB_STV680 is not set
-# CONFIG_USB_ZC0301 is not set
-# CONFIG_USB_PWC is not set
-# CONFIG_USB_ZR364XX is not set
-# CONFIG_USB_STKWEBCAM is not set
-# CONFIG_SOC_CAMERA is not set
-CONFIG_RADIO_ADAPTERS=y
-# CONFIG_USB_DSBR is not set
-# CONFIG_USB_SI470X is not set
-CONFIG_DAB=y
-# CONFIG_USB_DABUSB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_CFB_FILLRECT is not set
-# CONFIG_FB_CFB_COPYAREA is not set
-# CONFIG_FB_CFB_IMAGEBLIT is not set
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-
-#
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
-# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
-# CONFIG_FONTS is not set
-CONFIG_FONT_8x8=y
-CONFIG_FONT_8x16=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-CONFIG_LOGO_LINUX_CLUT224=y
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-# CONFIG_HID_SUPPORT is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-CONFIG_USB=y
-# CONFIG_USB_DEBUG is not set
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
-
-#
-# Miscellaneous USB options
-#
-# CONFIG_USB_DEVICEFS is not set
-CONFIG_USB_DEVICE_CLASS=y
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_SUSPEND is not set
-# CONFIG_USB_OTG is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# USB Host Controller Drivers
-#
-# CONFIG_USB_C67X00_HCD is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_R8A66597_HCD is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_WDM is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
-#
-
-#
-# may also be needed; see USB_STORAGE Help for more information
-#
-# CONFIG_USB_STORAGE is not set
-# CONFIG_USB_LIBUSUAL is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-CONFIG_USB_MON=y
-
-#
-# USB port drivers
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_ADUTUX is not set
-# CONFIG_USB_AUERSWALD is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_BERRY_CHARGE is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_PHIDGET is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_GADGET is not set
-# CONFIG_MMC is not set
-# CONFIG_NEW_LEDS is not set
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_CLASS is not set
-# CONFIG_UIO is not set
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4DEV_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-CONFIG_CRAMFS=y
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-# CONFIG_NFS_V3 is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_BIND34 is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_NLS is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_FS is not set
-# CONFIG_HEADERS_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-CONFIG_SCHED_DEBUG=y
-# CONFIG_SCHEDSTATS is not set
-# CONFIG_TIMER_STATS is not set
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-CONFIG_DEBUG_BUGVERBOSE=y
-# CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_VM is not set
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_LIST is not set
-# CONFIG_DEBUG_SG is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_SAMPLES is not set
-# CONFIG_DEBUG_USER is not set
-CONFIG_DEBUG_ERRORS=y
-# CONFIG_DEBUG_STACK_USAGE is not set
-CONFIG_DEBUG_LL=y
-# CONFIG_DEBUG_ICEDCC is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_MANAGER is not set
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-# CONFIG_CRYPTO_CBC is not set
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-# CONFIG_CRYPTO_HMAC is not set
-# CONFIG_CRYPTO_XCBC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-# CONFIG_CRYPTO_AES is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_LZO is not set
-CONFIG_CRYPTO_HW=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-# CONFIG_GENERIC_FIND_FIRST_BIT is not set
-# CONFIG_GENERIC_FIND_NEXT_BIT is not set
-CONFIG_CRC_CCITT=m
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/mx3_defconfig linux-2.6.30-rc3/arch/arm/configs/mx3_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/mx3_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/mx3_defconfig	2009-04-22 03:29:16.065931700 +0000
@@ -0,0 +1,1125 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.30-rc1
+# Wed Apr  8 11:06:37 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_USER_SCHED=y
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX1 is not set
+# CONFIG_ARCH_MX2 is not set
+CONFIG_ARCH_MX3=y
+CONFIG_ARCH_MX31=y
+
+#
+# MX3 platforms:
+#
+CONFIG_MACH_MX31ADS=y
+CONFIG_MACH_MX31ADS_WM1133_EV1=y
+CONFIG_MACH_PCM037=y
+CONFIG_MACH_MX31LITE=y
+CONFIG_MACH_MX31_3DS=y
+CONFIG_MACH_MX31MOBOARD=y
+CONFIG_MACH_QONG=y
+CONFIG_MXC_IRQ_PRIOR=y
+CONFIG_MXC_PWM=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_VERBOSE is not set
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+CONFIG_COMPAT_NET_DEV_OPS=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+CONFIG_SMSC911X=y
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_NONISA_IRQ=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_IMX=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+CONFIG_W1=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=y
+# CONFIG_W1_MASTER_GPIO is not set
+
+#
+# 1-wire Slaves
+#
+CONFIG_W1_SLAVE_THERM=y
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+CONFIG_MFD_WM8350=y
+CONFIG_MFD_WM8350_CONFIG_MODE_0=y
+CONFIG_MFD_WM8352_CONFIG_MODE_0=y
+CONFIG_MFD_WM8350_I2C=y
+# CONFIG_MFD_PCF50633 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_MT9M001=y
+CONFIG_SOC_CAMERA_MT9M111=y
+CONFIG_SOC_CAMERA_MT9T031=y
+CONFIG_SOC_CAMERA_MT9V022=y
+CONFIG_SOC_CAMERA_TW9910=y
+# CONFIG_SOC_CAMERA_PLATFORM is not set
+# CONFIG_SOC_CAMERA_OV772X is not set
+CONFIG_VIDEO_MX3=y
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_FB_MX3=y
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MXC=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_MX3_IPU=y
+CONFIG_MX3_IPU_IRQS=4
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+CONFIG_REGULATOR_WM8350=y
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_EVENT_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/pcm037_defconfig linux-2.6.30-rc3/arch/arm/configs/pcm037_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/pcm037_defconfig	2009-04-22 03:29:10.091931369 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/pcm037_defconfig	1970-01-01 00:00:00.000000000 +0000
@@ -1,769 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.26-rc6
-# Wed Jun 25 11:52:42 2008
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
-CONFIG_ARCH_MTD_XIP=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CGROUPS is not set
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-# CONFIG_RT_GROUP_SCHED is not set
-CONFIG_USER_SCHED=y
-# CONFIG_CGROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_BLK_DEV_INITRD is not set
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-CONFIG_SYSCTL_SYSCALL=y
-CONFIG_SYSCTL_SYSCALL_CHECK=y
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_COMPAT_BRK=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
-# CONFIG_MARKERS is not set
-CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-# CONFIG_HAVE_DMA_ATTRS is not set
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-# CONFIG_TINY_SHMEM is not set
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_KMOD=y
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_LSF is not set
-# CONFIG_BLK_DEV_BSG is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_DEFAULT_AS is not set
-# CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-CONFIG_CLASSIC_RCU=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS7500 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-CONFIG_ARCH_MXC=y
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_MSM7X00A is not set
-
-#
-# Boot options
-#
-
-#
-# Power management
-#
-
-#
-# Freescale MXC Implementations
-#
-CONFIG_ARCH_MX3=y
-
-#
-# MX3 Options
-#
-# CONFIG_MACH_MX31ADS is not set
-CONFIG_MACH_PCM037=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_V6=y
-# CONFIG_CPU_32v6K is not set
-CONFIG_CPU_32v6=y
-CONFIG_CPU_ABRT_EV6=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_V6=y
-CONFIG_CPU_CACHE_VIPT=y
-CONFIG_CPU_COPY_V6=y
-CONFIG_CPU_TLB_V6=y
-CONFIG_CPU_HAS_ASID=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_BPREDICT_DISABLE is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_RESOURCES_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-CONFIG_VIRT_TO_BUS=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw ip=off"
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-CONFIG_VFP=y
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-# CONFIG_PM is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-
-#
-# Networking
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-
-#
-# Wireless
-#
-# CONFIG_CFG80211 is not set
-# CONFIG_WIRELESS_EXT is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_IEEE80211 is not set
-# CONFIG_RFKILL is not set
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=m
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
-# CONFIG_MTD_CFI_ADV_OPTIONS is not set
-# CONFIG_MTD_CFI_NOSWAP is not set
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_CFI_INTELEXT is not set
-# CONFIG_MTD_CFI_AMDSTD is not set
-# CONFIG_MTD_CFI_STAA is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_PHYSMAP_START=0x0
-CONFIG_MTD_PHYSMAP_LEN=0
-CONFIG_MTD_PHYSMAP_BANKWIDTH=2
-# CONFIG_MTD_ARM_INTEGRATOR is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-# CONFIG_BLK_DEV is not set
-# CONFIG_MISC_DEVICES is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-# CONFIG_MD is not set
-CONFIG_NETDEVICES=y
-# CONFIG_NETDEVICES_MULTIQUEUE is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-CONFIG_PHYLIB=y
-
-#
-# MII PHY device drivers
-#
-# CONFIG_MARVELL_PHY is not set
-# CONFIG_DAVICOM_PHY is not set
-# CONFIG_QSEMI_PHY is not set
-# CONFIG_LXT_PHY is not set
-# CONFIG_CICADA_PHY is not set
-# CONFIG_VITESSE_PHY is not set
-CONFIG_SMSC_PHY=y
-# CONFIG_BROADCOM_PHY is not set
-# CONFIG_ICPLUS_PHY is not set
-# CONFIG_REALTEK_PHY is not set
-# CONFIG_NATIONAL_PHY is not set
-# CONFIG_STE10XP is not set
-# CONFIG_LSI_ET1011C_PHY is not set
-# CONFIG_FIXED_PHY is not set
-# CONFIG_MDIO_BITBANG is not set
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_AX88796 is not set
-CONFIG_SMC91X=y
-# CONFIG_DM9000 is not set
-# CONFIG_SMC911X is not set
-CONFIG_SMSC911X=y
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_B44 is not set
-# CONFIG_NETDEV_1000 is not set
-# CONFIG_NETDEV_10000 is not set
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-# CONFIG_WAN is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-# CONFIG_INPUT is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-CONFIG_DEVKMEM=y
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_IMX=y
-CONFIG_SERIAL_IMX_CONSOLE=y
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_NVRAM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_I2C is not set
-# CONFIG_SPI is not set
-CONFIG_HAVE_GPIO_LIB=y
-
-#
-# GPIO Support
-#
-
-#
-# I2C GPIO expanders:
-#
-
-#
-# SPI GPIO expanders:
-#
-# CONFIG_W1 is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_HWMON is not set
-# CONFIG_WATCHDOG is not set
-
-#
-# Sonics Silicon Backplane
-#
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_HTC_EGPIO is not set
-# CONFIG_HTC_PASIC3 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-# CONFIG_VIDEO_DEV is not set
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
-
-#
-# Multimedia drivers
-#
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_MMC is not set
-# CONFIG_NEW_LEDS is not set
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_CLASS is not set
-# CONFIG_UIO is not set
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4DEV_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_INOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-# CONFIG_NFS_V3 is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_BIND34 is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_NLS is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_PRINTK_TIME is not set
-# CONFIG_ENABLE_WARN_DEPRECATED is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_FRAME_WARN=1024
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_FS is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_KERNEL is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_SAMPLES is not set
-# CONFIG_DEBUG_USER is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-# CONFIG_GENERIC_FIND_FIRST_BIT is not set
-# CONFIG_GENERIC_FIND_NEXT_BIT is not set
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/pcm038_defconfig linux-2.6.30-rc3/arch/arm/configs/pcm038_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/pcm038_defconfig	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/pcm038_defconfig	1970-01-01 00:00:00.000000000 +0000
@@ -1,1008 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.26-rc6
-# Fri Jun 20 16:38:36 2008
-#
-CONFIG_ARM=y
-CONFIG_SYS_SUPPORTS_APM_EMULATION=y
-CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_MMU=y
-# CONFIG_NO_IOPORT is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_ARCH_HAS_ILOG2_U32 is not set
-# CONFIG_ARCH_HAS_ILOG2_U64 is not set
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
-CONFIG_ARCH_MTD_XIP=y
-CONFIG_VECTORS_BASE=0xffff0000
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-
-#
-# General setup
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-CONFIG_POSIX_MQUEUE=y
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-# CONFIG_AUDIT is not set
-# CONFIG_IKCONFIG is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CGROUPS is not set
-CONFIG_GROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-CONFIG_USER_SCHED=y
-# CONFIG_CGROUP_SCHED is not set
-# CONFIG_SYSFS_DEPRECATED_V2 is not set
-# CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_BLK_DEV_INITRD is not set
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SYSCTL=y
-CONFIG_EMBEDDED=y
-CONFIG_UID16=y
-CONFIG_SYSCTL_SYSCALL=y
-CONFIG_SYSCTL_SYSCALL_CHECK=y
-CONFIG_KALLSYMS=y
-CONFIG_KALLSYMS_EXTRA_PASS=y
-CONFIG_HOTPLUG=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-# CONFIG_COMPAT_BRK is not set
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
-# CONFIG_SLOB is not set
-CONFIG_PROFILING=y
-CONFIG_MARKERS=y
-CONFIG_OPROFILE=y
-CONFIG_HAVE_OPROFILE=y
-CONFIG_KPROBES=y
-CONFIG_KRETPROBES=y
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-# CONFIG_HAVE_DMA_ATTRS is not set
-# CONFIG_PROC_PAGE_MONITOR is not set
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-# CONFIG_TINY_SHMEM is not set
-CONFIG_BASE_SMALL=0
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-# CONFIG_KMOD is not set
-CONFIG_BLOCK=y
-# CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_LSF is not set
-# CONFIG_BLK_DEV_BSG is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IOSCHED_AS is not set
-# CONFIG_IOSCHED_DEADLINE is not set
-# CONFIG_IOSCHED_CFQ is not set
-# CONFIG_DEFAULT_AS is not set
-# CONFIG_DEFAULT_DEADLINE is not set
-# CONFIG_DEFAULT_CFQ is not set
-CONFIG_DEFAULT_NOOP=y
-CONFIG_DEFAULT_IOSCHED="noop"
-CONFIG_CLASSIC_RCU=y
-
-#
-# System Type
-#
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS7500 is not set
-# CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_ARCH_EP93XX is not set
-# CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_NETX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_IOP13XX is not set
-# CONFIG_ARCH_IOP32X is not set
-# CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
-# CONFIG_ARCH_KS8695 is not set
-# CONFIG_ARCH_NS9XXX is not set
-CONFIG_ARCH_MXC=y
-# CONFIG_ARCH_ORION5X is not set
-# CONFIG_ARCH_PNX4008 is not set
-# CONFIG_ARCH_PXA is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_S3C2410 is not set
-# CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
-# CONFIG_ARCH_DAVINCI is not set
-# CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_MSM7X00A is not set
-
-#
-# Boot options
-#
-
-#
-# Power management
-#
-
-#
-# Freescale MXC Implementations
-#
-CONFIG_ARCH_MX2=y
-# CONFIG_ARCH_MX3 is not set
-
-#
-# MX2 family CPU support
-#
-CONFIG_MACH_MX27=y
-
-#
-# MX2 Platforms
-#
-# CONFIG_MACH_MX27ADS is not set
-CONFIG_MACH_PCM038=y
-CONFIG_MACH_PCM970_BASEBOARD=y
-
-#
-# Processor Type
-#
-CONFIG_CPU_32=y
-CONFIG_CPU_ARM926T=y
-CONFIG_CPU_32v5=y
-CONFIG_CPU_ABRT_EV5TJ=y
-CONFIG_CPU_PABRT_NOIFAR=y
-CONFIG_CPU_CACHE_VIVT=y
-CONFIG_CPU_COPY_V4WB=y
-CONFIG_CPU_TLB_V4WBI=y
-CONFIG_CPU_CP15=y
-CONFIG_CPU_CP15_MMU=y
-
-#
-# Processor Features
-#
-CONFIG_ARM_THUMB=y
-# CONFIG_CPU_ICACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
-# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
-# CONFIG_OUTER_CACHE is not set
-
-#
-# Bus support
-#
-# CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
-# CONFIG_PCCARD is not set
-
-#
-# Kernel Features
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_PREEMPT=y
-CONFIG_HZ=100
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4096
-# CONFIG_RESOURCES_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-CONFIG_VIRT_TO_BUS=y
-CONFIG_ALIGNMENT_TRAP=y
-
-#
-# Boot options
-#
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE=""
-# CONFIG_XIP_KERNEL is not set
-# CONFIG_KEXEC is not set
-
-#
-# Floating point emulation
-#
-
-#
-# At least one emulation must be selected
-#
-# CONFIG_VFP is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Power management options
-#
-# CONFIG_PM is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-
-#
-# Networking
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NET_TCPPROBE is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-
-#
-# Wireless
-#
-# CONFIG_CFG80211 is not set
-# CONFIG_WIRELESS_EXT is not set
-# CONFIG_MAC80211 is not set
-# CONFIG_IEEE80211 is not set
-# CONFIG_RFKILL is not set
-# CONFIG_NET_9P is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_REDBOOT_PARTS is not set
-CONFIG_MTD_CMDLINE_PARTS=y
-# CONFIG_MTD_AFS_PARTS is not set
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_MTD_OOPS is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-# CONFIG_MTD_CFI_I2 is not set
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_OTP is not set
-CONFIG_MTD_CFI_INTELEXT=y
-# CONFIG_MTD_CFI_AMDSTD is not set
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_CFI_UTIL=y
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_XIP is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_PHYSMAP_START=0x00000000
-CONFIG_MTD_PHYSMAP_LEN=0x0
-CONFIG_MTD_PHYSMAP_BANKWIDTH=2
-# CONFIG_MTD_ARM_INTEGRATOR is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_DATAFLASH is not set
-# CONFIG_MTD_M25P80 is not set
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# UBI - Unsorted block images
-#
-# CONFIG_MTD_UBI is not set
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_MISC_DEVICES is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SCSI_NETLINK is not set
-# CONFIG_ATA is not set
-# CONFIG_MD is not set
-CONFIG_NETDEVICES=y
-# CONFIG_NETDEVICES_MULTIQUEUE is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_PHYLIB is not set
-CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
-# CONFIG_AX88796 is not set
-# CONFIG_SMC91X is not set
-# CONFIG_DM9000 is not set
-# CONFIG_ENC28J60 is not set
-# CONFIG_IBM_NEW_EMAC_ZMII is not set
-# CONFIG_IBM_NEW_EMAC_RGMII is not set
-# CONFIG_IBM_NEW_EMAC_TAH is not set
-# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
-# CONFIG_B44 is not set
-CONFIG_FEC_OLD=y
-# CONFIG_NETDEV_1000 is not set
-# CONFIG_NETDEV_10000 is not set
-
-#
-# Wireless LAN
-#
-# CONFIG_WLAN_PRE80211 is not set
-# CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
-# CONFIG_WAN is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_ADS7846 is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_UCB1400 is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-# CONFIG_VT_HW_CONSOLE_BINDING is not set
-CONFIG_DEVKMEM=y
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_IMX=y
-CONFIG_SERIAL_IMX_CONSOLE=y
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_UNIX98_PTYS=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_NVRAM is not set
-# CONFIG_R3964 is not set
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_CHARDEV is not set
-
-#
-# I2C Hardware Bus support
-#
-# CONFIG_I2C_GPIO is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_STUB is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-
-#
-# Miscellaneous I2C Chip support
-#
-# CONFIG_DS1682 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_SENSORS_PCF8574 is not set
-# CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_I2C_DEBUG_CHIP is not set
-CONFIG_SPI=y
-CONFIG_SPI_MASTER=y
-
-#
-# SPI Master Controller Drivers
-#
-CONFIG_SPI_BITBANG=y
-
-#
-# SPI Protocol Masters
-#
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_TLE62X0 is not set
-CONFIG_HAVE_GPIO_LIB=y
-
-#
-# GPIO Support
-#
-
-#
-# I2C GPIO expanders:
-#
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-
-#
-# SPI GPIO expanders:
-#
-# CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_W1 is not set
-# CONFIG_POWER_SUPPLY is not set
-# CONFIG_HWMON is not set
-# CONFIG_WATCHDOG is not set
-
-#
-# Sonics Silicon Backplane
-#
-CONFIG_SSB_POSSIBLE=y
-# CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_ASIC3 is not set
-# CONFIG_HTC_EGPIO is not set
-# CONFIG_HTC_PASIC3 is not set
-
-#
-# Multimedia devices
-#
-
-#
-# Multimedia core support
-#
-CONFIG_VIDEO_DEV=y
-CONFIG_VIDEO_V4L2_COMMON=y
-CONFIG_VIDEO_ALLOW_V4L1=y
-CONFIG_VIDEO_V4L1_COMPAT=y
-# CONFIG_DVB_CORE is not set
-CONFIG_VIDEO_MEDIA=y
-
-#
-# Multimedia drivers
-#
-# CONFIG_MEDIA_ATTACH is not set
-CONFIG_MEDIA_TUNER=y
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=y
-CONFIG_MEDIA_TUNER_TDA8290=y
-CONFIG_MEDIA_TUNER_TDA9887=y
-CONFIG_MEDIA_TUNER_TEA5761=y
-CONFIG_MEDIA_TUNER_TEA5767=y
-CONFIG_MEDIA_TUNER_MT20XX=y
-CONFIG_MEDIA_TUNER_XC2028=y
-CONFIG_MEDIA_TUNER_XC5000=y
-CONFIG_VIDEO_V4L2=y
-CONFIG_VIDEO_V4L1=y
-CONFIG_VIDEO_CAPTURE_DRIVERS=y
-# CONFIG_VIDEO_ADV_DEBUG is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-# CONFIG_VIDEO_VIVI is not set
-# CONFIG_VIDEO_CPIA is not set
-# CONFIG_VIDEO_SAA5246A is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_TUNER_3036 is not set
-# CONFIG_SOC_CAMERA is not set
-# CONFIG_RADIO_ADAPTERS is not set
-# CONFIG_DAB is not set
-
-#
-# Graphics support
-#
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_CFB_FILLRECT is not set
-# CONFIG_FB_CFB_COPYAREA is not set
-# CONFIG_FB_CFB_IMAGEBLIT is not set
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Display device support
-#
-# CONFIG_DISPLAY_SUPPORT is not set
-
-#
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
-# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
-CONFIG_FONTS=y
-CONFIG_FONT_8x8=y
-# CONFIG_FONT_8x16 is not set
-# CONFIG_FONT_6x11 is not set
-# CONFIG_FONT_7x14 is not set
-# CONFIG_FONT_PEARL_8x8 is not set
-# CONFIG_FONT_ACORN_8x8 is not set
-# CONFIG_FONT_MINI_4x6 is not set
-# CONFIG_FONT_SUN8x16 is not set
-# CONFIG_FONT_SUN12x22 is not set
-# CONFIG_FONT_10x18 is not set
-# CONFIG_LOGO is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-# CONFIG_HID_SUPPORT is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_MMC is not set
-# CONFIG_NEW_LEDS is not set
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-CONFIG_RTC_INTF_SYSFS=y
-CONFIG_RTC_INTF_PROC=y
-CONFIG_RTC_INTF_DEV=y
-# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-CONFIG_RTC_DRV_PCF8563=y
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-
-#
-# SPI RTC drivers
-#
-# CONFIG_RTC_DRV_MAX6902 is not set
-# CONFIG_RTC_DRV_R9701 is not set
-# CONFIG_RTC_DRV_RS5C348 is not set
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_CMOS is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-
-#
-# on-CPU RTC drivers
-#
-# CONFIG_UIO is not set
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4DEV_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_INOTIFY is not set
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-CONFIG_JFFS2_FS_WRITEBUFFER=y
-# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
-# CONFIG_JFFS2_SUMMARY is not set
-# CONFIG_JFFS2_FS_XATTR is not set
-# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
-CONFIG_JFFS2_ZLIB=y
-# CONFIG_JFFS2_LZO is not set
-CONFIG_JFFS2_RTIME=y
-# CONFIG_JFFS2_RUBIN is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_BIND34 is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=m
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-CONFIG_NLS_CODEPAGE_850=m
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-CONFIG_NLS_ISO8859_15=m
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
-# CONFIG_DLM is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_PRINTK_TIME is not set
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1024
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_FS is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_KERNEL is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_SAMPLES is not set
-# CONFIG_DEBUG_USER is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-# CONFIG_SECURITY_FILE_CAPABILITIES is not set
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-# CONFIG_GENERIC_FIND_FIRST_BIT is not set
-# CONFIG_GENERIC_FIND_NEXT_BIT is not set
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC16 is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_PLIST=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
diff -urN linux-2.6.30-rc2/arch/arm/configs/s3c2410_defconfig linux-2.6.30-rc3/arch/arm/configs/s3c2410_defconfig
--- linux-2.6.30-rc2/arch/arm/configs/s3c2410_defconfig	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/configs/s3c2410_defconfig	2009-04-22 03:29:16.074931311 +0000
@@ -1,9 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.26-rc8
-# Mon Jul  7 16:59:23 2008
+# Linux kernel version: 2.6.30-rc2
 #
 CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_GENERIC_GPIO=y
 # CONFIG_GENERIC_TIME is not set
@@ -12,6 +12,7 @@
 CONFIG_NO_IOPORT=y
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
 CONFIG_LOCKDEP_SUPPORT=y
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
@@ -21,8 +22,7 @@
 # CONFIG_ARCH_HAS_ILOG2_U64 is not set
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_SUPPORTS_AOUT=y
-CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
@@ -41,11 +41,20 @@
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
 CONFIG_IKCONFIG=m
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=16
-# CONFIG_CGROUPS is not set
 # CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
 CONFIG_SYSFS_DEPRECATED=y
 CONFIG_SYSFS_DEPRECATED_V2=y
 # CONFIG_RELAY is not set
@@ -54,31 +63,36 @@
 # CONFIG_IPC_NS is not set
 # CONFIG_USER_NS is not set
 # CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
 # CONFIG_EMBEDDED is not set
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
-CONFIG_SYSCTL_SYSCALL_CHECK=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+# CONFIG_STRIP_ASM_SYMS is not set
 CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
-CONFIG_COMPAT_BRK=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
 CONFIG_SIGNALFD=y
 CONFIG_TIMERFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
+CONFIG_AIO=y
 CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
 CONFIG_SLAB=y
 # CONFIG_SLUB is not set
 # CONFIG_SLOB is not set
@@ -88,11 +102,11 @@
 # CONFIG_KPROBES is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
-# CONFIG_HAVE_DMA_ATTRS is not set
-CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_HAVE_CLK=y
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
-# CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
 CONFIG_MODULES=y
 # CONFIG_MODULE_FORCE_LOAD is not set
@@ -100,12 +114,10 @@
 # CONFIG_MODULE_FORCE_UNLOAD is not set
 # CONFIG_MODVERSIONS is not set
 # CONFIG_MODULE_SRCVERSION_ALL is not set
-CONFIG_KMOD=y
 CONFIG_BLOCK=y
 # CONFIG_LBD is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_LSF is not set
 # CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
 
 #
 # IO Schedulers
@@ -119,7 +131,7 @@
 # CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_IOSCHED="anticipatory"
-CONFIG_CLASSIC_RCU=y
+CONFIG_FREEZER=y
 
 #
 # System Type
@@ -129,11 +141,10 @@
 # CONFIG_ARCH_REALVIEW is not set
 # CONFIG_ARCH_VERSATILE is not set
 # CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_CLPS7500 is not set
 # CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_GEMINI is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
 # CONFIG_ARCH_NETX is not set
 # CONFIG_ARCH_H720X is not set
@@ -145,26 +156,38 @@
 # CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
 # CONFIG_ARCH_KS8695 is not set
 # CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
 # CONFIG_ARCH_MXC is not set
 # CONFIG_ARCH_ORION5X is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MMP is not set
 # CONFIG_ARCH_RPC is not set
 # CONFIG_ARCH_SA1100 is not set
 CONFIG_ARCH_S3C2410=y
+# CONFIG_ARCH_S3C64XX is not set
 # CONFIG_ARCH_SHARK is not set
 # CONFIG_ARCH_LH7A40X is not set
 # CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_MSM7X00A is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
 CONFIG_PLAT_S3C24XX=y
+CONFIG_S3C2410_CLOCK=y
+CONFIG_S3C24XX_DCLK=y
 CONFIG_CPU_S3C244X=y
-# CONFIG_S3C24XX_PWM is not set
+CONFIG_S3C24XX_PWM=y
+CONFIG_S3C24XX_GPIO_EXTRA=128
+CONFIG_S3C24XX_GPIO_EXTRA64=y
+CONFIG_S3C24XX_GPIO_EXTRA128=y
 CONFIG_PM_SIMTEC=y
 CONFIG_S3C2410_DMA=y
 # CONFIG_S3C2410_DMA_DEBUG is not set
+CONFIG_S3C24XX_ADC=y
 CONFIG_MACH_SMDK=y
 CONFIG_PLAT_S3C=y
 CONFIG_CPU_LLSERIAL_S3C2410=y
@@ -174,7 +197,8 @@
 # Boot options
 #
 # CONFIG_S3C_BOOT_WATCHDOG is not set
-# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_ERROR_RESET=y
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
 
 #
 # Power management
@@ -182,6 +206,8 @@
 # CONFIG_S3C2410_PM_DEBUG is not set
 # CONFIG_S3C2410_PM_CHECK is not set
 CONFIG_S3C_LOWLEVEL_UART_PORT=0
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_DEV_HSMMC=y
 
 #
 # S3C2400 Machines
@@ -190,7 +216,6 @@
 CONFIG_CPU_S3C2410_DMA=y
 CONFIG_S3C2410_PM=y
 CONFIG_S3C2410_GPIO=y
-CONFIG_S3C2410_CLOCK=y
 CONFIG_SIMTEC_NOR=y
 CONFIG_MACH_BAST_IDE=y
 
@@ -205,7 +230,7 @@
 CONFIG_MACH_OTOM=y
 CONFIG_MACH_AML_M5900=y
 CONFIG_BAST_PC104_IRQ=y
-# CONFIG_MACH_TCT_HAMMER is not set
+CONFIG_MACH_TCT_HAMMER=y
 CONFIG_MACH_VR1000=y
 CONFIG_MACH_QT2410=y
 CONFIG_CPU_S3C2412=y
@@ -215,10 +240,11 @@
 #
 # S3C2412 Machines
 #
-# CONFIG_MACH_JIVE is not set
+CONFIG_MACH_JIVE=y
+# CONFIG_MACH_JIVE_SHOW_BOOTLOADER is not set
 CONFIG_MACH_SMDK2413=y
 CONFIG_MACH_S3C2413=y
-# CONFIG_MACH_SMDK2412 is not set
+CONFIG_MACH_SMDK2412=y
 CONFIG_MACH_VSTMS=y
 CONFIG_CPU_S3C2440=y
 CONFIG_S3C2440_DMA=y
@@ -232,7 +258,7 @@
 CONFIG_ARCH_S3C2440=y
 CONFIG_MACH_NEXCODER_2440=y
 CONFIG_SMDK2440_CPU2440=y
-# CONFIG_MACH_AT2440EVB is not set
+CONFIG_MACH_AT2440EVB=y
 CONFIG_CPU_S3C2442=y
 
 #
@@ -286,25 +312,31 @@
 #
 # Kernel Features
 #
-# CONFIG_TICK_ONESHOT is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
 # CONFIG_PREEMPT is not set
 CONFIG_HZ=200
 # CONFIG_AEABI is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
 CONFIG_SELECT_MEMORY_MODEL=y
 CONFIG_FLATMEM_MANUAL=y
 # CONFIG_DISCONTIGMEM_MANUAL is not set
 # CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
 CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=4096
-# CONFIG_RESOURCES_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
 CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
 CONFIG_ALIGNMENT_TRAP=y
 
 #
@@ -317,6 +349,11 @@
 # CONFIG_KEXEC is not set
 
 #
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
 # Floating point emulation
 #
 
@@ -332,6 +369,8 @@
 # Userspace binary formats
 #
 CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
 CONFIG_BINFMT_AOUT=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_ARTHUR is not set
@@ -346,10 +385,6 @@
 CONFIG_SUSPEND_FREEZER=y
 CONFIG_APM_EMULATION=m
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
-
-#
-# Networking
-#
 CONFIG_NET=y
 
 #
@@ -359,11 +394,13 @@
 # CONFIG_PACKET_MMAP is not set
 CONFIG_UNIX=y
 CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_USER=m
 # CONFIG_XFRM_SUB_POLICY is not set
 # CONFIG_XFRM_MIGRATE is not set
 # CONFIG_XFRM_STATISTICS is not set
-# CONFIG_NET_KEY is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
@@ -372,15 +409,16 @@
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+# CONFIG_NET_IPGRE_BROADCAST is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
 CONFIG_INET_TUNNEL=m
 CONFIG_INET_XFRM_MODE_TRANSPORT=y
 CONFIG_INET_XFRM_MODE_TUNNEL=y
@@ -388,8 +426,25 @@
 # CONFIG_INET_LRO is not set
 CONFIG_INET_DIAG=y
 CONFIG_INET_TCP_DIAG=y
-# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
 CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
 CONFIG_IPV6=m
@@ -413,12 +468,181 @@
 # CONFIG_IPV6_MULTIPLE_TABLES is not set
 # CONFIG_IPV6_MROUTE is not set
 # CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETFILTER is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+# CONFIG_NETFILTER_XT_MATCH_RECENT_PROC_COMPAT is not set
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS application helper
+#
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_NF_NAT_PROTO_DCCP=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
 # CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
@@ -428,8 +652,10 @@
 # CONFIG_LAPB is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
 # CONFIG_NET_SCHED is not set
-CONFIG_NET_SCH_FIFO=y
+CONFIG_NET_CLS_ROUTE=y
+# CONFIG_DCB is not set
 
 #
 # Network testing
@@ -451,8 +677,8 @@
 #
 # Bluetooth device drivers
 #
-CONFIG_BT_HCIUSB=m
-CONFIG_BT_HCIUSB_SCO=y
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
 CONFIG_BT_HCIUART=m
 CONFIG_BT_HCIUART_H4=y
 CONFIG_BT_HCIUART_BCSP=y
@@ -462,35 +688,26 @@
 CONFIG_BT_HCIBFUSB=m
 CONFIG_BT_HCIVHCI=m
 # CONFIG_AF_RXRPC is not set
-
-#
-# Wireless
-#
+CONFIG_WIRELESS=y
 CONFIG_CFG80211=m
-CONFIG_NL80211=y
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
 CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
 CONFIG_MAC80211=m
 
 #
 # Rate control algorithm selection
 #
-CONFIG_MAC80211_RC_DEFAULT_PID=y
-# CONFIG_MAC80211_RC_DEFAULT_NONE is not set
-
-#
-# Selecting 'y' for an algorithm will
-#
-
-#
-# build the algorithm into mac80211.
-#
-CONFIG_MAC80211_RC_DEFAULT="pid"
-CONFIG_MAC80211_RC_PID=y
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
 CONFIG_MAC80211_MESH=y
 CONFIG_MAC80211_LEDS=y
-# CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT is not set
-# CONFIG_MAC80211_DEBUG is not set
-# CONFIG_IEEE80211 is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
 
@@ -504,7 +721,9 @@
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=m
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
@@ -513,6 +732,7 @@
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_CONCAT is not set
 CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
 CONFIG_MTD_REDBOOT_PARTS=y
 CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
 CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
@@ -545,7 +765,7 @@
 CONFIG_MTD_MAP_BANK_WIDTH_2=y
 CONFIG_MTD_MAP_BANK_WIDTH_4=y
 # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-CONFIG_MTD_MAP_BANK_WIDTH_16=y
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
 # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
 CONFIG_MTD_CFI_I1=y
 CONFIG_MTD_CFI_I2=y
@@ -566,8 +786,6 @@
 # CONFIG_MTD_PHYSMAP is not set
 # CONFIG_MTD_ARM_INTEGRATOR is not set
 # CONFIG_MTD_IMPA7 is not set
-CONFIG_MTD_BAST=y
-CONFIG_MTD_BAST_MAXSIZE=4
 # CONFIG_MTD_PLATRAM is not set
 
 #
@@ -590,6 +808,7 @@
 # CONFIG_MTD_NAND_VERIFY_WRITE is not set
 # CONFIG_MTD_NAND_ECC_SMC is not set
 # CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
 CONFIG_MTD_NAND_IDS=y
 CONFIG_MTD_NAND_S3C2410=y
 # CONFIG_MTD_NAND_S3C2410_DEBUG is not set
@@ -602,6 +821,11 @@
 # CONFIG_MTD_ONENAND is not set
 
 #
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
 # UBI - Unsorted block images
 #
 # CONFIG_MTD_UBI is not set
@@ -620,7 +844,7 @@
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_NBD=m
-# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_UB=m
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
@@ -628,32 +852,40 @@
 # CONFIG_CDROM_PKTCDVD is not set
 CONFIG_ATA_OVER_ETH=m
 CONFIG_MISC_DEVICES=y
-# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
 # CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=m
+CONFIG_EEPROM_AT25=m
+CONFIG_EEPROM_LEGACY=m
+CONFIG_EEPROM_93CX6=m
 CONFIG_HAVE_IDE=y
 CONFIG_IDE=y
-CONFIG_BLK_DEV_IDE=y
 
 #
 # Please see Documentation/ide/ide.txt for help/info on IDE drives
 #
+CONFIG_IDE_ATAPI=y
 # CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_IDE_GD=y
+CONFIG_IDE_GD_ATA=y
+# CONFIG_IDE_GD_ATAPI is not set
 CONFIG_BLK_DEV_IDECD=y
 CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
 CONFIG_BLK_DEV_IDETAPE=m
-CONFIG_BLK_DEV_IDEFLOPPY=m
-# CONFIG_BLK_DEV_IDESCSI is not set
 # CONFIG_IDE_TASK_IOCTL is not set
 CONFIG_IDE_PROC_FS=y
 
 #
 # IDE chipset support/bugfixes
 #
-# CONFIG_BLK_DEV_PLATFORM is not set
+CONFIG_BLK_DEV_PLATFORM=y
 # CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_BLK_DEV_HD is not set
 
 #
 # SCSI device support
@@ -699,6 +931,8 @@
 # CONFIG_SCSI_AIC7XXX_OLD is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_IN2000 is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
 # CONFIG_SCSI_DTC3280 is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GENERIC_NCR5380 is not set
@@ -711,11 +945,13 @@
 # CONFIG_SCSI_SYM53C416 is not set
 # CONFIG_SCSI_T128 is not set
 # CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
 CONFIG_HAVE_PATA_PLATFORM=y
 # CONFIG_MD is not set
 CONFIG_NETDEVICES=y
-# CONFIG_NETDEVICES_MULTIQUEUE is not set
+CONFIG_COMPAT_NET_DEV_OPS=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_MACVLAN is not set
@@ -731,9 +967,14 @@
 # CONFIG_NET_VENDOR_SMC is not set
 # CONFIG_SMC91X is not set
 CONFIG_DM9000=y
-# CONFIG_ENC28J60 is not set
 CONFIG_DM9000_DEBUGLEVEL=4
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
 # CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_DNET is not set
 # CONFIG_AT1700 is not set
 # CONFIG_DEPCA is not set
 # CONFIG_HP100 is not set
@@ -742,11 +983,14 @@
 # CONFIG_IBM_NEW_EMAC_RGMII is not set
 # CONFIG_IBM_NEW_EMAC_TAH is not set
 # CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
 # CONFIG_NET_PCI is not set
 # CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
 # CONFIG_NET_POCKET is not set
 CONFIG_NETDEV_1000=y
-# CONFIG_E1000E_ENABLED is not set
 CONFIG_NETDEV_10000=y
 # CONFIG_TR is not set
 
@@ -755,7 +999,10 @@
 #
 # CONFIG_WLAN_PRE80211 is not set
 # CONFIG_WLAN_80211 is not set
-# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
 
 #
 # USB Network Adapters
@@ -778,7 +1025,7 @@
 # Input device support
 #
 CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_FF_MEMLESS=m
 # CONFIG_INPUT_POLLDEV is not set
 
 #
@@ -789,7 +1036,7 @@
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_EVDEV is not set
+CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
@@ -808,20 +1055,88 @@
 CONFIG_MOUSE_PS2_ALPS=y
 CONFIG_MOUSE_PS2_LOGIPS2PP=y
 CONFIG_MOUSE_PS2_SYNAPTICS=y
-CONFIG_MOUSE_PS2_LIFEBOOK=y
 CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
 # CONFIG_MOUSE_PS2_TOUCHKIT is not set
 # CONFIG_MOUSE_SERIAL is not set
-# CONFIG_MOUSE_APPLETOUCH is not set
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_BCM5974=m
 # CONFIG_MOUSE_INPORT is not set
 # CONFIG_MOUSE_LOGIBM is not set
 # CONFIG_MOUSE_PC110PAD is not set
 # CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_MOUSE_GPIO is not set
-# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_ANALOG=m
+CONFIG_JOYSTICK_A3D=m
+CONFIG_JOYSTICK_ADI=m
+CONFIG_JOYSTICK_COBRA=m
+CONFIG_JOYSTICK_GF2K=m
+CONFIG_JOYSTICK_GRIP=m
+CONFIG_JOYSTICK_GRIP_MP=m
+CONFIG_JOYSTICK_GUILLEMOT=m
+CONFIG_JOYSTICK_INTERACT=m
+CONFIG_JOYSTICK_SIDEWINDER=m
+CONFIG_JOYSTICK_TMDC=m
+CONFIG_JOYSTICK_IFORCE=m
+# CONFIG_JOYSTICK_IFORCE_USB is not set
+# CONFIG_JOYSTICK_IFORCE_232 is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+CONFIG_JOYSTICK_MAGELLAN=m
+CONFIG_JOYSTICK_SPACEORB=m
+CONFIG_JOYSTICK_SPACEBALL=m
+CONFIG_JOYSTICK_STINGER=m
+CONFIG_JOYSTICK_TWIDJOY=m
+CONFIG_JOYSTICK_ZHENHUA=m
+CONFIG_JOYSTICK_DB9=m
+CONFIG_JOYSTICK_GAMECON=m
+CONFIG_JOYSTICK_TURBOGRAFX=m
+CONFIG_JOYSTICK_JOYDUMP=m
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
 # CONFIG_INPUT_TABLET is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_HTCPEN is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_USB_EGALAX=y
+CONFIG_TOUCHSCREEN_USB_PANJIT=y
+CONFIG_TOUCHSCREEN_USB_3M=y
+CONFIG_TOUCHSCREEN_USB_ITM=y
+CONFIG_TOUCHSCREEN_USB_ETURBO=y
+CONFIG_TOUCHSCREEN_USB_GUNZE=y
+CONFIG_TOUCHSCREEN_USB_DMC_TSC10=y
+CONFIG_TOUCHSCREEN_USB_IRTOUCH=y
+CONFIG_TOUCHSCREEN_USB_IDEALTEK=y
+CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=y
+CONFIG_TOUCHSCREEN_USB_GOTOP=y
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_ATI_REMOTE=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
 
 #
 # Hardware I/O ports
@@ -831,12 +1146,15 @@
 # CONFIG_SERIO_PARKBD is not set
 CONFIG_SERIO_LIBPS2=y
 # CONFIG_SERIO_RAW is not set
-# CONFIG_GAMEPORT is not set
+CONFIG_GAMEPORT=m
+# CONFIG_GAMEPORT_NS558 is not set
+# CONFIG_GAMEPORT_L4 is not set
 
 #
 # Character devices
 #
 CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
 # CONFIG_VT_HW_CONSOLE_BINDING is not set
@@ -877,14 +1195,17 @@
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
 # CONFIG_SERIAL_SAMSUNG_DEBUG is not set
 CONFIG_SERIAL_SAMSUNG_CONSOLE=y
 CONFIG_SERIAL_S3C2410=y
 CONFIG_SERIAL_S3C2412=y
 CONFIG_SERIAL_S3C2440=y
+# CONFIG_SERIAL_MAX3100 is not set
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
 CONFIG_PRINTER=y
@@ -892,7 +1213,7 @@
 CONFIG_PPDEV=y
 # CONFIG_IPMI_HANDLER is not set
 CONFIG_HW_RANDOM=y
-# CONFIG_NVRAM is not set
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_RAW_DRIVER is not set
@@ -901,33 +1222,44 @@
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_HELPER_AUTO=y
 CONFIG_I2C_ALGOBIT=y
 
 #
 # I2C Hardware Bus support
 #
-# CONFIG_I2C_ELEKTOR is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
 # CONFIG_I2C_GPIO is not set
 # CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_PARPORT is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
 CONFIG_I2C_S3C2410=y
 CONFIG_I2C_SIMTEC=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_STUB is not set
 # CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_ELEKTOR is not set
 # CONFIG_I2C_PCA_ISA is not set
 # CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
 
 #
 # Miscellaneous I2C Chip support
 #
 # CONFIG_DS1682 is not set
-CONFIG_EEPROM_LEGACY=m
 # CONFIG_SENSORS_PCF8574 is not set
 # CONFIG_PCF8575 is not set
-# CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_TPS65010 is not set
+# CONFIG_SENSORS_PCA9539 is not set
 # CONFIG_SENSORS_MAX6875 is not set
 # CONFIG_SENSORS_TSL2550 is not set
 # CONFIG_I2C_DEBUG_CORE is not set
@@ -943,6 +1275,7 @@
 #
 CONFIG_SPI_BITBANG=m
 # CONFIG_SPI_BUTTERFLY is not set
+CONFIG_SPI_GPIO=m
 # CONFIG_SPI_LM70_LLP is not set
 CONFIG_SPI_S3C24XX=m
 CONFIG_SPI_S3C24XX_GPIO=m
@@ -950,44 +1283,56 @@
 #
 # SPI Protocol Masters
 #
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_TLE62X0 is not set
-CONFIG_HAVE_GPIO_LIB=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPI_TLE62X0=m
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
 
 #
-# GPIO Support
+# Memory mapped GPIO expanders:
 #
-# CONFIG_DEBUG_GPIO is not set
 
 #
 # I2C GPIO expanders:
 #
+# CONFIG_GPIO_MAX732X is not set
 # CONFIG_GPIO_PCA953X is not set
 # CONFIG_GPIO_PCF857X is not set
 
 #
+# PCI GPIO expanders:
+#
+
+#
 # SPI GPIO expanders:
 #
+# CONFIG_GPIO_MAX7301 is not set
 # CONFIG_GPIO_MCP23S08 is not set
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 CONFIG_HWMON=y
 CONFIG_HWMON_VID=m
+# CONFIG_SENSORS_AD7414 is not set
 # CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
 # CONFIG_SENSORS_ADM1021 is not set
 # CONFIG_SENSORS_ADM1025 is not set
 # CONFIG_SENSORS_ADM1026 is not set
 # CONFIG_SENSORS_ADM1029 is not set
 # CONFIG_SENSORS_ADM1031 is not set
 # CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
 # CONFIG_SENSORS_ADT7470 is not set
 # CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
 # CONFIG_SENSORS_ATXP1 is not set
 # CONFIG_SENSORS_DS1621 is not set
 # CONFIG_SENSORS_F71805F is not set
 # CONFIG_SENSORS_F71882FG is not set
 # CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
 # CONFIG_SENSORS_GL518SM is not set
 # CONFIG_SENSORS_GL520SM is not set
 # CONFIG_SENSORS_IT87 is not set
@@ -1003,10 +1348,16 @@
 # CONFIG_SENSORS_LM90 is not set
 # CONFIG_SENSORS_LM92 is not set
 # CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
 # CONFIG_SENSORS_MAX1619 is not set
 # CONFIG_SENSORS_MAX6650 is not set
 # CONFIG_SENSORS_PC87360 is not set
 # CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
 # CONFIG_SENSORS_DME1737 is not set
 # CONFIG_SENSORS_SMSC47M1 is not set
 # CONFIG_SENSORS_SMSC47M192 is not set
@@ -1022,7 +1373,10 @@
 # CONFIG_SENSORS_W83L786NG is not set
 # CONFIG_SENSORS_W83627HF is not set
 # CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
 # CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
 CONFIG_WATCHDOG=y
 # CONFIG_WATCHDOG_NOWAYOUT is not set
 
@@ -1043,20 +1397,33 @@
 # USB-based Watchdog Cards
 #
 # CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
 
 #
 # Sonics Silicon Backplane
 #
-CONFIG_SSB_POSSIBLE=y
 # CONFIG_SSB is not set
 
 #
 # Multifunction device drivers
 #
+# CONFIG_MFD_CORE is not set
 CONFIG_MFD_SM501=y
+# CONFIG_MFD_SM501_GPIO is not set
 # CONFIG_MFD_ASIC3 is not set
 # CONFIG_HTC_EGPIO is not set
 # CONFIG_HTC_PASIC3 is not set
+# CONFIG_UCB1400_CORE is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
 
 #
 # Multimedia devices
@@ -1065,14 +1432,189 @@
 #
 # Multimedia core support
 #
-# CONFIG_VIDEO_DEV is not set
-# CONFIG_DVB_CORE is not set
-# CONFIG_VIDEO_MEDIA is not set
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_DVB_CORE=m
+CONFIG_VIDEO_MEDIA=m
 
 #
 # Multimedia drivers
 #
-# CONFIG_DAB is not set
+CONFIG_MEDIA_ATTACH=y
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEO_V4L1=m
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_VMALLOC=m
+CONFIG_VIDEO_TVEEPROM=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_VIVI=m
+CONFIG_VIDEO_PMS=m
+CONFIG_VIDEO_BWQCAM=m
+CONFIG_VIDEO_CQCAM=m
+CONFIG_VIDEO_W9966=m
+CONFIG_VIDEO_CPIA=m
+CONFIG_VIDEO_CPIA_PP=m
+CONFIG_VIDEO_CPIA_USB=m
+CONFIG_VIDEO_CPIA2=m
+CONFIG_VIDEO_SAA5246A=m
+CONFIG_VIDEO_SAA5249=m
+CONFIG_VIDEO_AU0828=m
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+CONFIG_RADIO_CADET=m
+CONFIG_RADIO_RTRACK=m
+CONFIG_RADIO_RTRACK2=m
+CONFIG_RADIO_AZTECH=m
+CONFIG_RADIO_GEMTEK=m
+CONFIG_RADIO_SF16FMI=m
+CONFIG_RADIO_SF16FMR2=m
+CONFIG_RADIO_TERRATEC=m
+CONFIG_RADIO_TRUST=m
+CONFIG_RADIO_TYPHOON=m
+CONFIG_RADIO_TYPHOON_PROC_FS=y
+CONFIG_RADIO_ZOLTRIX=m
+CONFIG_USB_DSBR=m
+CONFIG_USB_SI470X=m
+CONFIG_USB_MR800=m
+CONFIG_RADIO_TEA5764=m
+CONFIG_DVB_DYNAMIC_MINORS=y
+CONFIG_DVB_CAPTURE_DRIVERS=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Supported USB Adapters
+#
+CONFIG_DVB_USB=m
+# CONFIG_DVB_USB_DEBUG is not set
+# CONFIG_DVB_USB_A800 is not set
+CONFIG_DVB_USB_DIBUSB_MB=m
+# CONFIG_DVB_USB_DIBUSB_MB_FAULTY is not set
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+# CONFIG_DVB_USB_GL861 is not set
+# CONFIG_DVB_USB_AU6610 is not set
+# CONFIG_DVB_USB_DIGITV is not set
+# CONFIG_DVB_USB_VP7045 is not set
+# CONFIG_DVB_USB_VP702X is not set
+# CONFIG_DVB_USB_GP8PSK is not set
+# CONFIG_DVB_USB_NOVA_T_USB2 is not set
+# CONFIG_DVB_USB_TTUSB2 is not set
+# CONFIG_DVB_USB_DTT200U is not set
+# CONFIG_DVB_USB_OPERA1 is not set
+CONFIG_DVB_USB_AF9005=m
+# CONFIG_DVB_USB_AF9005_REMOTE is not set
+# CONFIG_DVB_USB_DW2102 is not set
+# CONFIG_DVB_USB_CINERGY_T2 is not set
+# CONFIG_DVB_USB_ANYSEE is not set
+# CONFIG_DVB_USB_DTV5100 is not set
+# CONFIG_DVB_USB_AF9015 is not set
+# CONFIG_DVB_USB_CE6230 is not set
+# CONFIG_DVB_SIANO_SMS1XXX is not set
+
+#
+# Supported FlexCopII (B2C2) Adapters
+#
+# CONFIG_DVB_B2C2_FLEXCOP is not set
+
+#
+# Supported DVB Frontends
+#
+# CONFIG_DVB_FE_CUSTOMISE is not set
+CONFIG_DVB_CX22702=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_DVB_MT352=m
+CONFIG_DVB_ZL10353=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_AU8522=m
+CONFIG_DVB_S5H1411=m
+CONFIG_DVB_PLL=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_DVB_LGS8GL5=m
+CONFIG_DAB=y
+CONFIG_USB_DABUSB=m
 
 #
 # Graphics support
@@ -1082,6 +1624,7 @@
 CONFIG_FB=y
 CONFIG_FIRMWARE_EDID=y
 # CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
@@ -1105,7 +1648,19 @@
 # CONFIG_FB_S3C2410_DEBUG is not set
 CONFIG_FB_SM501=y
 # CONFIG_FB_VIRTUAL is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=m
+CONFIG_BACKLIGHT_GENERIC=m
+CONFIG_BACKLIGHT_PWM=m
 
 #
 # Display device support
@@ -1125,11 +1680,54 @@
 CONFIG_FONT_8x8=y
 CONFIG_FONT_8x16=y
 # CONFIG_LOGO is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=m
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_AC97_CODEC=m
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_CAIAQ=m
+# CONFIG_SND_USB_CAIAQ_INPUT is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_AC97_BUS=y
+CONFIG_SND_S3C24XX_SOC=y
+CONFIG_SND_S3C24XX_SOC_I2S=m
+CONFIG_SND_S3C_I2SV2_SOC=m
+CONFIG_SND_S3C2412_SOC_I2S=m
+CONFIG_SND_S3C2443_SOC_AC97=m
+CONFIG_SND_S3C24XX_SOC_JIVE_WM8750=m
+CONFIG_SND_S3C24XX_SOC_SMDK2443_WM9710=m
+CONFIG_SND_S3C24XX_SOC_LN2440SBC_ALC650=m
+CONFIG_SND_S3C24XX_SOC_S3C24XX_UDA134X=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_AC97_CODEC=m
+CONFIG_SND_SOC_L3=m
+CONFIG_SND_SOC_UDA134X=m
+CONFIG_SND_SOC_WM8750=m
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=y
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=y
 # CONFIG_HID_DEBUG is not set
@@ -1139,12 +1737,12 @@
 # USB Input Devices
 #
 # CONFIG_USB_HID is not set
+# CONFIG_HID_PID is not set
 
 #
-# USB HID Boot Protocol drivers
+# Special HID drivers
 #
-# CONFIG_USB_KBD is not set
-# CONFIG_USB_MOUSE is not set
+CONFIG_HID_APPLE=m
 CONFIG_USB_SUPPORT=y
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
@@ -1161,19 +1759,26 @@
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_SUSPEND is not set
 # CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
 
 #
 # USB Host Controller Drivers
 #
 # CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
 # CONFIG_USB_ISP116X_HCD is not set
 # CONFIG_USB_ISP1760_HCD is not set
 CONFIG_USB_OHCI_HCD=y
 # CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
 # CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
 CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_U132_HCD is not set
 # CONFIG_USB_SL811_HCD is not set
 # CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
 
 #
 # USB Device Class drivers
@@ -1181,53 +1786,51 @@
 CONFIG_USB_ACM=m
 CONFIG_USB_PRINTER=m
 CONFIG_USB_WDM=m
+# CONFIG_USB_TMC is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
 #
 
 #
-# may also be needed; see USB_STORAGE Help for more information
+# also be needed; see USB_STORAGE Help for more info
 #
 CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_DPCM is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
 CONFIG_USB_LIBUSUAL=y
 
 #
 # USB Imaging devices
 #
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-CONFIG_USB_MON=y
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
 
 #
 # USB port drivers
 #
-# CONFIG_USB_USS720 is not set
+CONFIG_USB_USS720=m
 CONFIG_USB_SERIAL=y
 # CONFIG_USB_SERIAL_CONSOLE is not set
 # CONFIG_USB_EZUSB is not set
 CONFIG_USB_SERIAL_GENERIC=y
 # CONFIG_USB_SERIAL_AIRCABLE is not set
-# CONFIG_USB_SERIAL_AIRPRIME is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
 # CONFIG_USB_SERIAL_CH341 is not set
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CP210X is not set
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
 CONFIG_USB_SERIAL_FTDI_SIO=y
@@ -1251,42 +1854,71 @@
 CONFIG_USB_SERIAL_NAVMAN=m
 CONFIG_USB_SERIAL_PL2303=y
 # CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
 # CONFIG_USB_SERIAL_SPCP8X5 is not set
 # CONFIG_USB_SERIAL_HP4X is not set
 # CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
 # CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
 # CONFIG_USB_SERIAL_TI is not set
 # CONFIG_USB_SERIAL_CYBERJACK is not set
 # CONFIG_USB_SERIAL_XIRCOM is not set
 CONFIG_USB_SERIAL_OPTION=m
 # CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
 # CONFIG_USB_SERIAL_DEBUG is not set
 
 #
 # USB Miscellaneous drivers
 #
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_ADUTUX is not set
-# CONFIG_USB_AUERSWALD is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_BERRY_CHARGE is not set
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_BERRY_CHARGE=m
 CONFIG_USB_LED=m
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_PHIDGET is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_APPLEDISPLAY is not set
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
 CONFIG_USB_LD=m
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_TEST is not set
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_TEST=m
 # CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
 # CONFIG_USB_GADGET is not set
-# CONFIG_MMC is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_SDIO_UART=m
+CONFIG_MMC_TEST=m
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_SPI=m
+CONFIG_MMC_S3C=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
 CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=m
 
@@ -1295,7 +1927,14 @@
 #
 CONFIG_LEDS_S3C24XX=m
 CONFIG_LEDS_H1940=m
-# CONFIG_LEDS_GPIO is not set
+CONFIG_LEDS_PCA9532=m
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_GPIO_PLATFORM=y
+CONFIG_LEDS_LP5521=m
+CONFIG_LEDS_PCA955X=m
+CONFIG_LEDS_DAC124S085=m
+CONFIG_LEDS_PWM=m
+CONFIG_LEDS_BD2802=m
 
 #
 # LED Triggers
@@ -1304,7 +1943,13 @@
 CONFIG_LEDS_TRIGGER_TIMER=m
 # CONFIG_LEDS_TRIGGER_IDE_DISK is not set
 CONFIG_LEDS_TRIGGER_HEARTBEAT=m
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+CONFIG_LEDS_TRIGGER_BACKLIGHT=m
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=m
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_HCTOSYS=y
@@ -1335,31 +1980,43 @@
 # CONFIG_RTC_DRV_M41T80 is not set
 # CONFIG_RTC_DRV_S35390A is not set
 # CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
 
 #
 # SPI RTC drivers
 #
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
 # CONFIG_RTC_DRV_MAX6902 is not set
 # CONFIG_RTC_DRV_R9701 is not set
 # CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
 
 #
 # Platform RTC drivers
 #
 # CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
 # CONFIG_RTC_DRV_DS1511 is not set
 # CONFIG_RTC_DRV_DS1553 is not set
 # CONFIG_RTC_DRV_DS1742 is not set
 # CONFIG_RTC_DRV_STK17TA8 is not set
 # CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
 # CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
 # CONFIG_RTC_DRV_V3020 is not set
 
 #
 # on-CPU RTC drivers
 #
 CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
 # CONFIG_UIO is not set
+# CONFIG_STAGING is not set
 
 #
 # File systems
@@ -1370,27 +2027,40 @@
 CONFIG_EXT2_FS_SECURITY=y
 # CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
 # CONFIG_EXT3_FS_SECURITY is not set
-# CONFIG_EXT4DEV_FS is not set
+CONFIG_EXT4_FS=m
+# CONFIG_EXT4DEV_COMPAT is not set
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+# CONFIG_EXT4_FS_SECURITY is not set
 CONFIG_JBD=y
+CONFIG_JBD2=m
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
 # CONFIG_XFS_FS is not set
 # CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
 CONFIG_DNOTIFY=y
 CONFIG_INOTIFY=y
 CONFIG_INOTIFY_USER=y
 # CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
+CONFIG_AUTOFS_FS=m
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 CONFIG_GENERIC_ACL=y
 
 #
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
 # CD-ROM/DVD Filesystems
 #
 CONFIG_ISO9660_FS=y
@@ -1416,15 +2086,13 @@
 #
 CONFIG_PROC_FS=y
 CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
 CONFIG_SYSFS=y
 CONFIG_TMPFS=y
 CONFIG_TMPFS_POSIX_ACL=y
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_CONFIGFS_FS=m
-
-#
-# Miscellaneous filesystems
-#
+CONFIG_MISC_FILESYSTEMS=y
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
@@ -1444,27 +2112,49 @@
 CONFIG_JFFS2_RTIME=y
 # CONFIG_JFFS2_RUBIN is not set
 CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=m
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
 # CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
 CONFIG_ROMFS_FS=y
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+# CONFIG_ROMFS_BACKED_BY_MTD is not set
+# CONFIG_ROMFS_BACKED_BY_BOTH is not set
+CONFIG_ROMFS_ON_BLOCK=y
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
-# CONFIG_NFS_V3 is not set
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
 # CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
 CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_ACL_SUPPORT=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_BIND34 is not set
-# CONFIG_RPCSEC_GSS_KRB5 is not set
+CONFIG_SUNRPC_GSS=m
+CONFIG_RPCSEC_GSS_KRB5=m
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
@@ -1546,6 +2236,11 @@
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
 CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
 CONFIG_SCHED_DEBUG=y
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_TIMER_STATS is not set
@@ -1565,14 +2260,39 @@
 CONFIG_DEBUG_INFO=y
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
 # CONFIG_DEBUG_LIST is not set
 # CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
 CONFIG_FRAME_POINTER=y
 # CONFIG_BOOT_PRINTK_DELAY is not set
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
 # CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
 # CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_EVENT_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
 # CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
 CONFIG_DEBUG_USER=y
 CONFIG_DEBUG_ERRORS=y
 # CONFIG_DEBUG_STACK_USAGE is not set
@@ -1586,19 +2306,29 @@
 #
 # CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
 # CONFIG_SECURITY_FILE_CAPABILITIES is not set
 CONFIG_CRYPTO=y
 
 #
 # Crypto core or helper
 #
+# CONFIG_CRYPTO_FIPS is not set
 CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_ALGAPI2=m
 CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=m
 CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=m
 CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_HASH2=m
+CONFIG_CRYPTO_RNG2=m
+CONFIG_CRYPTO_PCOMP=m
 CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_MANAGER2=m
 # CONFIG_CRYPTO_GF128MUL is not set
 # CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=m
 # CONFIG_CRYPTO_CRYPTD is not set
 CONFIG_CRYPTO_AUTHENC=m
 # CONFIG_CRYPTO_TEST is not set
@@ -1630,10 +2360,14 @@
 #
 # Digest
 #
-# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=m
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
 CONFIG_CRYPTO_SHA1=m
 # CONFIG_CRYPTO_SHA256 is not set
 # CONFIG_CRYPTO_SHA512 is not set
@@ -1663,23 +2397,37 @@
 # Compression
 #
 CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
 # CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
 CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
 
 #
 # Library routines
 #
 CONFIG_BITREVERSE=y
-# CONFIG_GENERIC_FIND_FIRST_BIT is not set
-# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+CONFIG_GENERIC_FIND_LAST_BIT=y
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC16 is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_T10DIF is not set
 CONFIG_CRC_ITU_T=m
 CONFIG_CRC32=y
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
-CONFIG_PLIST=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -urN linux-2.6.30-rc2/arch/arm/include/asm/tlb.h linux-2.6.30-rc3/arch/arm/include/asm/tlb.h
--- linux-2.6.30-rc2/arch/arm/include/asm/tlb.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/include/asm/tlb.h	2009-04-22 03:29:16.082829423 +0000
@@ -36,6 +36,8 @@
 struct mmu_gather {
 	struct mm_struct	*mm;
 	unsigned int		fullmm;
+	unsigned long		range_start;
+	unsigned long		range_end;
 };
 
 DECLARE_PER_CPU(struct mmu_gather, mmu_gathers);
@@ -63,7 +65,19 @@
 	put_cpu_var(mmu_gathers);
 }
 
-#define tlb_remove_tlb_entry(tlb,ptep,address)	do { } while (0)
+/*
+ * Memorize the range for the TLB flush.
+ */
+static inline void
+tlb_remove_tlb_entry(struct mmu_gather *tlb, pte_t *ptep, unsigned long addr)
+{
+	if (!tlb->fullmm) {
+		if (addr < tlb->range_start)
+			tlb->range_start = addr;
+		if (addr + PAGE_SIZE > tlb->range_end)
+			tlb->range_end = addr + PAGE_SIZE;
+	}
+}
 
 /*
  * In the case of tlb vma handling, we can optimise these away in the
@@ -73,15 +87,18 @@
 static inline void
 tlb_start_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
 {
-	if (!tlb->fullmm)
+	if (!tlb->fullmm) {
 		flush_cache_range(vma, vma->vm_start, vma->vm_end);
+		tlb->range_start = TASK_SIZE;
+		tlb->range_end = 0;
+	}
 }
 
 static inline void
 tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
 {
-	if (!tlb->fullmm)
-		flush_tlb_range(vma, vma->vm_start, vma->vm_end);
+	if (!tlb->fullmm && tlb->range_end > 0)
+		flush_tlb_range(vma, tlb->range_start, tlb->range_end);
 }
 
 #define tlb_remove_page(tlb,page)	free_page_and_swap_cache(page)
diff -urN linux-2.6.30-rc2/arch/arm/kernel/sys_oabi-compat.c linux-2.6.30-rc3/arch/arm/kernel/sys_oabi-compat.c
--- linux-2.6.30-rc2/arch/arm/kernel/sys_oabi-compat.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/kernel/sys_oabi-compat.c	2009-04-22 03:29:16.087556618 +0000
@@ -83,6 +83,7 @@
 #include <linux/net.h>
 #include <linux/ipc.h>
 #include <linux/uaccess.h>
+#include <linux/slab.h>
 
 struct oldabi_stat64 {
 	unsigned long long st_dev;
@@ -176,21 +177,12 @@
 				   int flag)
 {
 	struct kstat stat;
-	int error = -EINVAL;
+	int error;
 
-	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
-		goto out;
-
-	if (flag & AT_SYMLINK_NOFOLLOW)
-		error = vfs_lstat_fd(dfd, filename, &stat);
-	else
-		error = vfs_stat_fd(dfd, filename, &stat);
-
-	if (!error)
-	error = cp_oldabi_stat64(&stat, statbuf);
-
-out:
-	return error;
+	error = vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_oldabi_stat64(&stat, statbuf);
 }
 
 struct oabi_flock64 {
diff -urN linux-2.6.30-rc2/arch/arm/mach-at91/at91rm9200_time.c linux-2.6.30-rc3/arch/arm/mach-at91/at91rm9200_time.c
--- linux-2.6.30-rc2/arch/arm/mach-at91/at91rm9200_time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-at91/at91rm9200_time.c	2009-04-22 03:29:16.088931714 +0000
@@ -85,7 +85,7 @@
 	.handler	= at91rm9200_timer_interrupt
 };
 
-static cycle_t read_clk32k(void)
+static cycle_t read_clk32k(struct clocksource *cs)
 {
 	return read_CRTR();
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-at91/at91sam926x_time.c linux-2.6.30-rc3/arch/arm/mach-at91/at91sam926x_time.c
--- linux-2.6.30-rc2/arch/arm/mach-at91/at91sam926x_time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-at91/at91sam926x_time.c	2009-04-22 03:29:16.088931714 +0000
@@ -31,7 +31,7 @@
  * Clocksource:  just a monotonic counter of MCK/16 cycles.
  * We don't care whether or not PIT irqs are enabled.
  */
-static cycle_t read_pit_clk(void)
+static cycle_t read_pit_clk(struct clocksource *cs)
 {
 	unsigned long flags;
 	u32 elapsed;
diff -urN linux-2.6.30-rc2/arch/arm/mach-davinci/time.c linux-2.6.30-rc3/arch/arm/mach-davinci/time.c
--- linux-2.6.30-rc2/arch/arm/mach-davinci/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-davinci/time.c	2009-04-22 03:29:16.091564293 +0000
@@ -238,7 +238,7 @@
 /*
  * clocksource
  */
-static cycle_t read_cycles(void)
+static cycle_t read_cycles(struct clocksource *cs)
 {
 	struct timer_s *t = &timers[TID_CLOCKSOURCE];
 
diff -urN linux-2.6.30-rc2/arch/arm/mach-ep93xx/core.c linux-2.6.30-rc3/arch/arm/mach-ep93xx/core.c
--- linux-2.6.30-rc2/arch/arm/mach-ep93xx/core.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-ep93xx/core.c	2009-04-22 03:29:16.091564293 +0000
@@ -100,7 +100,7 @@
 
 #define TIMER4_TICKS_PER_JIFFY		((CLOCK_TICK_RATE + (HZ/2)) / HZ)
 
-static int ep93xx_timer_interrupt(int irq, void *dev_id)
+static irqreturn_t ep93xx_timer_interrupt(int irq, void *dev_id)
 {
 	__raw_writel(1, EP93XX_TIMER1_CLEAR);
 	while ((signed long)
diff -urN linux-2.6.30-rc2/arch/arm/mach-imx/time.c linux-2.6.30-rc3/arch/arm/mach-imx/time.c
--- linux-2.6.30-rc2/arch/arm/mach-imx/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-imx/time.c	2009-04-22 03:29:16.097931732 +0000
@@ -73,7 +73,7 @@
 	IMX_TCTL(TIMER_BASE) = TCTL_FRR | TCTL_CLK_PCLK1 | TCTL_TEN;
 }
 
-cycle_t imx_get_cycles(void)
+cycle_t imx_get_cycles(struct clocksource *cs)
 {
 	return IMX_TCN(TIMER_BASE);
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-ixp4xx/common.c linux-2.6.30-rc3/arch/arm/mach-ixp4xx/common.c
--- linux-2.6.30-rc2/arch/arm/mach-ixp4xx/common.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-ixp4xx/common.c	2009-04-22 03:29:16.099931763 +0000
@@ -401,7 +401,7 @@
 /*
  * clocksource
  */
-cycle_t ixp4xx_get_cycles(void)
+cycle_t ixp4xx_get_cycles(struct clocksource *cs)
 {
 	return *IXP4XX_OSTS;
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-msm/timer.c linux-2.6.30-rc3/arch/arm/mach-msm/timer.c
--- linux-2.6.30-rc2/arch/arm/mach-msm/timer.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-msm/timer.c	2009-04-22 03:29:16.110931761 +0000
@@ -57,12 +57,12 @@
 	return IRQ_HANDLED;
 }
 
-static cycle_t msm_gpt_read(void)
+static cycle_t msm_gpt_read(struct clocksource *cs)
 {
 	return readl(MSM_GPT_BASE + TIMER_COUNT_VAL);
 }
 
-static cycle_t msm_dgt_read(void)
+static cycle_t msm_dgt_read(struct clocksource *cs)
 {
 	return readl(MSM_DGT_BASE + TIMER_COUNT_VAL) >> MSM_DGT_SHIFT;
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-mx1/mx1ads.c linux-2.6.30-rc3/arch/arm/mach-mx1/mx1ads.c
--- linux-2.6.30-rc2/arch/arm/mach-mx1/mx1ads.c	2009-04-22 03:29:10.118931677 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-mx1/mx1ads.c	2009-04-22 03:29:16.113931697 +0000
@@ -28,9 +28,7 @@
 #include <mach/common.h>
 #include <mach/imx-uart.h>
 #include <mach/irqs.h>
-#ifdef CONFIG_I2C_IMX
 #include <mach/i2c.h>
-#endif
 #include <mach/iomux.h>
 #include "devices.h"
 
@@ -114,7 +112,6 @@
  * I2C
  */
 
-#ifdef CONFIG_I2C_IMX
 static int i2c_pins[] = {
 	PA15_PF_I2C_SDA,
 	PA16_PF_I2C_SCL,
@@ -157,7 +154,6 @@
 		.platform_data = &pcf857x_data[1],
 	},
 };
-#endif
 
 /*
  * Board init
@@ -172,12 +168,10 @@
 	mxc_register_device(&flash_device, &mx1ads_flash_data);
 
 	/* I2C */
-#ifdef CONFIG_I2C_IMX
 	i2c_register_board_info(0, mx1ads_i2c_devices,
 				ARRAY_SIZE(mx1ads_i2c_devices));
 
 	mxc_register_device(&imx_i2c_device, &mx1ads_i2c_data);
-#endif
 }
 
 static void __init mx1ads_timer_init(void)
diff -urN linux-2.6.30-rc2/arch/arm/mach-mx2/clock_imx21.c linux-2.6.30-rc3/arch/arm/mach-mx2/clock_imx21.c
--- linux-2.6.30-rc2/arch/arm/mach-mx2/clock_imx21.c	2009-04-22 03:29:10.119931511 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-mx2/clock_imx21.c	2009-04-22 03:29:16.114615234 +0000
@@ -919,19 +919,19 @@
 	_REGISTER_CLOCK(NULL, "cspi1", cspi_clk[0])
 	_REGISTER_CLOCK(NULL, "cspi2", cspi_clk[1])
 	_REGISTER_CLOCK(NULL, "cspi3", cspi_clk[2])
-	_REGISTER_CLOCK(NULL, "lcdc", lcdc_clk[0])
+	_REGISTER_CLOCK("imx-fb.0", NULL, lcdc_clk[0])
 	_REGISTER_CLOCK(NULL, "csi", csi_clk[0])
 	_REGISTER_CLOCK(NULL, "usb", usb_clk[0])
 	_REGISTER_CLOCK(NULL, "ssi1", ssi_clk[0])
 	_REGISTER_CLOCK(NULL, "ssi2", ssi_clk[1])
-	_REGISTER_CLOCK(NULL, "nfc", nfc_clk)
+	_REGISTER_CLOCK("mxc_nand.0", NULL, nfc_clk)
 	_REGISTER_CLOCK(NULL, "dma", dma_clk[0])
 	_REGISTER_CLOCK(NULL, "brom", brom_clk)
 	_REGISTER_CLOCK(NULL, "emma", emma_clk[0])
 	_REGISTER_CLOCK(NULL, "slcdc", slcdc_clk[0])
-	_REGISTER_CLOCK(NULL, "wdog", wdog_clk)
+	_REGISTER_CLOCK("imx-wdt.0", NULL, wdog_clk)
 	_REGISTER_CLOCK(NULL, "gpio", gpio_clk)
-	_REGISTER_CLOCK(NULL, "i2c", i2c_clk)
+	_REGISTER_CLOCK("imx-i2c.0", NULL, i2c_clk)
 	_REGISTER_CLOCK("mxc-keypad", NULL, kpp_clk)
 	_REGISTER_CLOCK(NULL, "owire", owire_clk)
 	_REGISTER_CLOCK(NULL, "rtc", rtc_clk)
diff -urN linux-2.6.30-rc2/arch/arm/mach-mx3/Kconfig linux-2.6.30-rc3/arch/arm/mach-mx3/Kconfig
--- linux-2.6.30-rc2/arch/arm/mach-mx3/Kconfig	2009-04-22 03:29:10.122931384 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-mx3/Kconfig	2009-04-22 03:29:16.119931923 +0000
@@ -19,6 +19,8 @@
 config MACH_MX31ADS_WM1133_EV1
 	bool "Support Wolfson Microelectronics 1133-EV1 module"
 	depends on MACH_MX31ADS
+	depends on MFD_WM8350_I2C
+	depends on REGULATOR_WM8350
 	select MFD_WM8350_CONFIG_MODE_0
 	select MFD_WM8352_CONFIG_MODE_0
 	help
diff -urN linux-2.6.30-rc2/arch/arm/mach-mx3/mx31ads.c linux-2.6.30-rc3/arch/arm/mach-mx3/mx31ads.c
--- linux-2.6.30-rc2/arch/arm/mach-mx3/mx31ads.c	2009-04-22 03:29:10.125931410 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-mx3/mx31ads.c	2009-04-22 03:29:16.122931854 +0000
@@ -102,7 +102,7 @@
 	.flags = IMXUART_HAVE_RTSCTS,
 };
 
-static int uart_pins[] = {
+static unsigned int uart_pins[] = {
 	MX31_PIN_CTS1__CTS1,
 	MX31_PIN_RTS1__RTS1,
 	MX31_PIN_TXD1__TXD1,
@@ -452,6 +452,8 @@
 
 	wm8350->codec.platform_data = &imx32ads_wm8350_setup;
 
+	regulator_has_full_constraints();
+
 	return 0;
 }
 
diff -urN linux-2.6.30-rc2/arch/arm/mach-mx3/pcm037.c linux-2.6.30-rc3/arch/arm/mach-mx3/pcm037.c
--- linux-2.6.30-rc2/arch/arm/mach-mx3/pcm037.c	2009-04-22 03:29:10.125931410 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-mx3/pcm037.c	2009-04-22 03:29:16.123931978 +0000
@@ -226,10 +226,10 @@
 	mxc_iomux_setup_pin(MX31_PIN_BATT_LINE__OWIRE, "batt-0wire");
 	mxc_register_device(&mxc_w1_master_device, NULL);
 
-	/* SMSC9215 IRQ pin */
+	/* LAN9217 IRQ pin */
 	if (!mxc_iomux_setup_pin(IOMUX_MODE(MX31_PIN_GPIO3_1, IOMUX_CONFIG_GPIO),
 				"pcm037-eth"))
-		gpio_direction_input(MX31_PIN_GPIO3_1);
+		gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_GPIO3_1));
 
 #ifdef CONFIG_I2C_IMX
 	i2c_register_board_info(1, pcm037_i2c_devices,
diff -urN linux-2.6.30-rc2/arch/arm/mach-mx3/qong.c linux-2.6.30-rc3/arch/arm/mach-mx3/qong.c
--- linux-2.6.30-rc2/arch/arm/mach-mx3/qong.c	2009-04-22 03:29:10.126931421 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-mx3/qong.c	2009-04-22 03:29:16.123931978 +0000
@@ -251,32 +251,6 @@
 }
 
 /*
- * This structure defines the MX31 memory map.
- */
-static struct map_desc qong_io_desc[] __initdata = {
-	{
-		.virtual = AIPS1_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
-		.length = AIPS1_SIZE,
-		.type = MT_DEVICE_NONSHARED
-	}, {
-		.virtual = AIPS2_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
-		.length = AIPS2_SIZE,
-		.type = MT_DEVICE_NONSHARED
-	}
-};
-
-/*
- * Set up static virtual mappings.
- */
-static void __init qong_map_io(void)
-{
-	mxc_map_io();
-	iotable_init(qong_io_desc, ARRAY_SIZE(qong_io_desc));
-}
-
-/*
  * Board specific initialization.
  */
 static void __init mxc_board_init(void)
@@ -305,7 +279,7 @@
 	.phys_io        = AIPS1_BASE_ADDR,
 	.io_pg_offst    = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
 	.boot_params    = PHYS_OFFSET + 0x100,
-	.map_io         = qong_map_io,
+	.map_io         = mxc_map_io,
 	.init_irq       = mxc_init_irq,
 	.init_machine   = mxc_board_init,
 	.timer          = &qong_timer,
diff -urN linux-2.6.30-rc2/arch/arm/mach-netx/time.c linux-2.6.30-rc3/arch/arm/mach-netx/time.c
--- linux-2.6.30-rc2/arch/arm/mach-netx/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-netx/time.c	2009-04-22 03:29:16.124931947 +0000
@@ -104,7 +104,7 @@
 	.handler	= netx_timer_interrupt,
 };
 
-cycle_t netx_get_cycles(void)
+cycle_t netx_get_cycles(struct clocksource *cs)
 {
 	return readl(NETX_GPIO_COUNTER_CURRENT(TIMER_CLOCKSOURCE));
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-ns9xxx/time-ns9360.c linux-2.6.30-rc3/arch/arm/mach-ns9xxx/time-ns9360.c
--- linux-2.6.30-rc2/arch/arm/mach-ns9xxx/time-ns9360.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-ns9xxx/time-ns9360.c	2009-04-22 03:29:16.124931947 +0000
@@ -25,7 +25,7 @@
 #define TIMER_CLOCKEVENT 1
 static u32 latch;
 
-static cycle_t ns9360_clocksource_read(void)
+static cycle_t ns9360_clocksource_read(struct clocksource *cs)
 {
 	return __raw_readl(SYS_TR(TIMER_CLOCKSOURCE));
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-omap1/time.c linux-2.6.30-rc3/arch/arm/mach-omap1/time.c
--- linux-2.6.30-rc2/arch/arm/mach-omap1/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-omap1/time.c	2009-04-22 03:29:16.131931782 +0000
@@ -198,7 +198,7 @@
 	.handler	= omap_mpu_timer2_interrupt,
 };
 
-static cycle_t mpu_read(void)
+static cycle_t mpu_read(struct clocksource *cs)
 {
 	return ~omap_mpu_timer_read(1);
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-omap2/timer-gp.c linux-2.6.30-rc3/arch/arm/mach-omap2/timer-gp.c
--- linux-2.6.30-rc2/arch/arm/mach-omap2/timer-gp.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-omap2/timer-gp.c	2009-04-22 03:29:16.150924637 +0000
@@ -138,7 +138,7 @@
  * clocksource
  */
 static struct omap_dm_timer *gpt_clocksource;
-static cycle_t clocksource_read_cycles(void)
+static cycle_t clocksource_read_cycles(struct clocksource *cs)
 {
 	return (cycle_t)omap_dm_timer_read_counter(gpt_clocksource);
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/em-x270.c linux-2.6.30-rc3/arch/arm/mach-pxa/em-x270.c
--- linux-2.6.30-rc2/arch/arm/mach-pxa/em-x270.c	2009-04-22 03:29:10.150931424 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/em-x270.c	2009-04-22 03:29:16.158931469 +0000
@@ -28,7 +28,6 @@
 #include <linux/spi/libertas_spi.h>
 #include <linux/power_supply.h>
 #include <linux/apm-emulation.h>
-#include <linux/delay.h>
 
 #include <media/soc_camera.h>
 
@@ -644,8 +643,9 @@
 };
 
 static struct pxa2xx_spi_chip em_x270_tdo24m_chip = {
-	.rx_threshold = 1,
-	.tx_threshold = 1,
+	.rx_threshold	= 1,
+	.tx_threshold	= 1,
+	.gpio_cs	= -1,
 };
 
 static struct tdo24m_platform_data em_x270_tdo24m_pdata = {
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/generic.h linux-2.6.30-rc3/arch/arm/mach-pxa/generic.h
--- linux-2.6.30-rc2/arch/arm/mach-pxa/generic.h	2009-04-22 03:29:10.151901021 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/generic.h	2009-04-22 03:29:16.159931630 +0000
@@ -15,6 +15,9 @@
 extern void __init pxa_init_irq(int irq_nr,
 				int (*set_wake)(unsigned int, unsigned int));
 extern void __init pxa25x_init_irq(void);
+#ifdef CONFIG_CPU_PXA26x
+extern void __init pxa26x_init_irq(void);
+#endif
 extern void __init pxa27x_init_irq(void);
 extern void __init pxa3xx_init_irq(void);
 extern void __init pxa_map_io(void);
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/include/mach/colibri.h linux-2.6.30-rc3/arch/arm/mach-pxa/include/mach/colibri.h
--- linux-2.6.30-rc2/arch/arm/mach-pxa/include/mach/colibri.h	2009-04-22 03:29:10.152931424 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/include/mach/colibri.h	2009-04-22 03:29:16.160931467 +0000
@@ -10,13 +10,13 @@
 #if defined(CONFIG_MMC_PXA) || defined(CONFIG_MMC_PXA_MODULE)
 extern void colibri_pxa3xx_init_mmc(mfp_cfg_t *pins, int len, int detect_pin);
 #else
-static inline void colibri_pxa3xx_init_mmc(mfp_cfg_t *, int, int) {}
+static inline void colibri_pxa3xx_init_mmc(mfp_cfg_t *pins, int len, int detect_pin) {}
 #endif
 
 #if defined(CONFIG_FB_PXA) || defined(CONFIG_FB_PXA_MODULE)
 extern void colibri_pxa3xx_init_lcd(int bl_pin);
 #else
-static inline void colibri_pxa3xx_init_lcd(int) {}
+static inline void colibri_pxa3xx_init_lcd(int bl_pin) {}
 #endif
 
 #if defined(CONFIG_AX88796)
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/include/mach/palmt5.h linux-2.6.30-rc3/arch/arm/mach-pxa/include/mach/palmt5.h
--- linux-2.6.30-rc2/arch/arm/mach-pxa/include/mach/palmt5.h	2009-04-22 03:29:10.154931404 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/include/mach/palmt5.h	2009-04-22 03:29:16.162931482 +0000
@@ -37,7 +37,6 @@
 
 /* USB */
 #define GPIO_NR_PALMT5_USB_DETECT_N		15
-#define GPIO_NR_PALMT5_USB_POWER		95
 #define GPIO_NR_PALMT5_USB_PULLUP		93
 
 /* LCD/BACKLIGHT */
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/include/mach/palmtx.h linux-2.6.30-rc3/arch/arm/mach-pxa/include/mach/palmtx.h
--- linux-2.6.30-rc2/arch/arm/mach-pxa/include/mach/palmtx.h	2009-04-22 03:29:10.154931404 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/include/mach/palmtx.h	2009-04-22 03:29:16.162931482 +0000
@@ -38,7 +38,6 @@
 
 /* USB */
 #define GPIO_NR_PALMTX_USB_DETECT_N		13
-#define GPIO_NR_PALMTX_USB_POWER		95
 #define GPIO_NR_PALMTX_USB_PULLUP		93
 
 /* LCD/BACKLIGHT */
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/palmt5.c linux-2.6.30-rc3/arch/arm/mach-pxa/palmt5.c
--- linux-2.6.30-rc2/arch/arm/mach-pxa/palmt5.c	2009-04-22 03:29:10.159931497 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/palmt5.c	2009-04-22 03:29:16.167931560 +0000
@@ -64,6 +64,7 @@
 	GPIO29_AC97_SDATA_IN_0,
 	GPIO30_AC97_SDATA_OUT,
 	GPIO31_AC97_SYNC,
+	GPIO95_AC97_nRESET,
 
 	/* IrDA */
 	GPIO40_GPIO,	/* ir disable */
@@ -72,7 +73,7 @@
 
 	/* USB */
 	GPIO15_GPIO,	/* usb detect */
-	GPIO95_GPIO,	/* usb power */
+	GPIO93_GPIO,	/* usb power */
 
 	/* MATRIX KEYPAD */
 	GPIO100_KP_MKIN_0 | WAKEUP_ON_LEVEL_HIGH,
@@ -344,7 +345,7 @@
 static struct pxa2xx_udc_mach_info palmt5_udc_info __initdata = {
 	.gpio_vbus		= GPIO_NR_PALMT5_USB_DETECT_N,
 	.gpio_vbus_inverted	= 1,
-	.gpio_pullup		= GPIO_NR_PALMT5_USB_POWER,
+	.gpio_pullup		= GPIO_NR_PALMT5_USB_PULLUP,
 	.gpio_pullup_inverted	= 0,
 };
 
@@ -490,9 +491,9 @@
 /* setup udc GPIOs initial state */
 static void __init palmt5_udc_init(void)
 {
-	if (!gpio_request(GPIO_NR_PALMT5_USB_POWER, "UDC Vbus")) {
-		gpio_direction_output(GPIO_NR_PALMT5_USB_POWER, 1);
-		gpio_free(GPIO_NR_PALMT5_USB_POWER);
+	if (!gpio_request(GPIO_NR_PALMT5_USB_PULLUP, "UDC Vbus")) {
+		gpio_direction_output(GPIO_NR_PALMT5_USB_PULLUP, 1);
+		gpio_free(GPIO_NR_PALMT5_USB_PULLUP);
 	}
 }
 
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/palmtx.c linux-2.6.30-rc3/arch/arm/mach-pxa/palmtx.c
--- linux-2.6.30-rc2/arch/arm/mach-pxa/palmtx.c	2009-04-22 03:29:10.159931497 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/palmtx.c	2009-04-22 03:29:16.168931433 +0000
@@ -64,6 +64,7 @@
 	GPIO29_AC97_SDATA_IN_0,
 	GPIO30_AC97_SDATA_OUT,
 	GPIO31_AC97_SYNC,
+	GPIO95_AC97_nRESET,
 
 	/* IrDA */
 	GPIO40_GPIO,	/* ir disable */
@@ -75,7 +76,7 @@
 
 	/* USB */
 	GPIO13_GPIO,	/* usb detect */
-	GPIO95_GPIO,	/* usb power */
+	GPIO93_GPIO,	/* usb power */
 
 	/* PCMCIA */
 	GPIO48_nPOE,
@@ -359,7 +360,7 @@
 static struct pxa2xx_udc_mach_info palmtx_udc_info __initdata = {
 	.gpio_vbus		= GPIO_NR_PALMTX_USB_DETECT_N,
 	.gpio_vbus_inverted	= 1,
-	.gpio_pullup		= GPIO_NR_PALMTX_USB_POWER,
+	.gpio_pullup		= GPIO_NR_PALMTX_USB_PULLUP,
 	.gpio_pullup_inverted	= 0,
 };
 
@@ -514,9 +515,9 @@
 /* setup udc GPIOs initial state */
 static void __init palmtx_udc_init(void)
 {
-	if (!gpio_request(GPIO_NR_PALMTX_USB_POWER, "UDC Vbus")) {
-		gpio_direction_output(GPIO_NR_PALMTX_USB_POWER, 1);
-		gpio_free(GPIO_NR_PALMTX_USB_POWER);
+	if (!gpio_request(GPIO_NR_PALMTX_USB_PULLUP, "UDC Vbus")) {
+		gpio_direction_output(GPIO_NR_PALMTX_USB_PULLUP, 1);
+		gpio_free(GPIO_NR_PALMTX_USB_PULLUP);
 	}
 }
 
diff -urN linux-2.6.30-rc2/arch/arm/mach-pxa/time.c linux-2.6.30-rc3/arch/arm/mach-pxa/time.c
--- linux-2.6.30-rc2/arch/arm/mach-pxa/time.c	2009-04-22 03:29:10.162931397 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-pxa/time.c	2009-04-22 03:29:16.171931486 +0000
@@ -125,7 +125,7 @@
 	.set_mode	= pxa_osmr0_set_mode,
 };
 
-static cycle_t pxa_read_oscr(void)
+static cycle_t pxa_read_oscr(struct clocksource *cs)
 {
 	return OSCR;
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-realview/core.c linux-2.6.30-rc3/arch/arm/mach-realview/core.c
--- linux-2.6.30-rc2/arch/arm/mach-realview/core.c	2009-04-22 03:29:10.163931318 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-realview/core.c	2009-04-22 03:29:16.172931575 +0000
@@ -715,7 +715,7 @@
 	.handler	= realview_timer_interrupt,
 };
 
-static cycle_t realview_get_cycles(void)
+static cycle_t realview_get_cycles(struct clocksource *cs)
 {
 	return ~readl(timer3_va_base + TIMER_VALUE);
 }
diff -urN linux-2.6.30-rc2/arch/arm/mach-s3c2412/mach-jive.c linux-2.6.30-rc3/arch/arm/mach-s3c2412/mach-jive.c
--- linux-2.6.30-rc2/arch/arm/mach-s3c2412/mach-jive.c	2009-04-22 03:29:10.167931438 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-s3c2412/mach-jive.c	2009-04-22 03:29:16.176931495 +0000
@@ -52,7 +52,6 @@
 #include <plat/cpu.h>
 #include <plat/pm.h>
 #include <plat/udc.h>
-#include <plat/iic.h>
 
 static struct map_desc jive_iodesc[] __initdata = {
 };
@@ -278,7 +277,7 @@
 #define LCD_HTOT (LCD_HSYNC + LCD_LEFT_MARGIN + LCD_XRES + LCD_RIGHT_MARGIN)
 #define LCD_VTOT (LCD_VSYNC + LCD_LOWER_MARGIN + LCD_YRES + LCD_UPPER_MARGIN)
 
-struct s3c2410fb_display jive_vgg2432a4_display[] = {
+static struct s3c2410fb_display jive_vgg2432a4_display[] = {
 	[0] = {
 		.width		= LCD_XRES,
 		.height		= LCD_YRES,
@@ -311,7 +310,7 @@
 #define S3C2410_GPCCON_MASK(x)	(3 << ((x) * 2))
 #define S3C2410_GPDCON_MASK(x)	(3 << ((x) * 2))
 
-struct s3c2410fb_mach_info jive_lcd_config = {
+static struct s3c2410fb_mach_info jive_lcd_config = {
 	.displays	 = jive_vgg2432a4_display,
 	.num_displays	 = ARRAY_SIZE(jive_vgg2432a4_display),
 	.default_display = 0,
diff -urN linux-2.6.30-rc2/arch/arm/mach-s3c2440/mach-anubis.c linux-2.6.30-rc3/arch/arm/mach-s3c2440/mach-anubis.c
--- linux-2.6.30-rc2/arch/arm/mach-s3c2440/mach-anubis.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-s3c2440/mach-anubis.c	2009-04-22 03:29:16.176931495 +0000
@@ -243,7 +243,7 @@
 
 /* IDE channels */
 
-struct pata_platform_info anubis_ide_platdata = {
+static struct pata_platform_info anubis_ide_platdata = {
 	.ioport_shift	= 5,
 };
 
diff -urN linux-2.6.30-rc2/arch/arm/mach-s3c2440/mach-osiris.c linux-2.6.30-rc3/arch/arm/mach-s3c2440/mach-osiris.c
--- linux-2.6.30-rc2/arch/arm/mach-s3c2440/mach-osiris.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-s3c2440/mach-osiris.c	2009-04-22 03:29:16.177875874 +0000
@@ -413,7 +413,6 @@
 	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
 	.boot_params	= S3C2410_SDRAM_PA + 0x100,
 	.map_io		= osiris_map_io,
-	.init_machine	= osiris_init,
 	.init_irq	= s3c24xx_init_irq,
 	.init_machine	= osiris_init,
 	.timer		= &s3c24xx_timer,
diff -urN linux-2.6.30-rc2/arch/arm/mach-s3c6410/mach-smdk6410.c linux-2.6.30-rc3/arch/arm/mach-s3c6410/mach-smdk6410.c
--- linux-2.6.30-rc2/arch/arm/mach-s3c6410/mach-smdk6410.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-s3c6410/mach-smdk6410.c	2009-04-22 03:29:16.177875874 +0000
@@ -166,6 +166,10 @@
 	s3c_i2c1_set_platdata(NULL);
 	s3c_fb_set_platdata(&smdk6410_lcd_pdata);
 
+	gpio_request(S3C64XX_GPN(5), "LCD power");
+	gpio_request(S3C64XX_GPF(13), "LCD power");
+	gpio_request(S3C64XX_GPF(15), "LCD power");
+
 	i2c_register_board_info(0, i2c_devs0, ARRAY_SIZE(i2c_devs0));
 	i2c_register_board_info(1, i2c_devs1, ARRAY_SIZE(i2c_devs1));
 
diff -urN linux-2.6.30-rc2/arch/arm/mach-versatile/core.c linux-2.6.30-rc3/arch/arm/mach-versatile/core.c
--- linux-2.6.30-rc2/arch/arm/mach-versatile/core.c	2009-04-22 03:29:10.171931574 +0000
+++ linux-2.6.30-rc3/arch/arm/mach-versatile/core.c	2009-04-22 03:29:16.180931478 +0000
@@ -948,7 +948,7 @@
 	.handler	= versatile_timer_interrupt,
 };
 
-static cycle_t versatile_get_cycles(void)
+static cycle_t versatile_get_cycles(struct clocksource *cs)
 {
 	return ~readl(TIMER3_VA_BASE + TIMER_VALUE);
 }
diff -urN linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/imx-uart.h linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/imx-uart.h
--- linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/imx-uart.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/imx-uart.h	2009-04-22 03:29:16.186931425 +0000
@@ -27,6 +27,4 @@
 	unsigned int flags;
 };
 
-int __init imx_init_uart(int uart_no, struct imxuart_platform_data *pdata);
-
 #endif
diff -urN linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/iomux-mx3.h linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/iomux-mx3.h
--- linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/iomux-mx3.h	2009-04-22 03:29:10.179931414 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/iomux-mx3.h	2009-04-22 03:29:16.188931423 +0000
@@ -518,6 +518,8 @@
  */
 #define MX31_PIN_CSPI3_MOSI__RXD3	IOMUX_MODE(MX31_PIN_CSPI3_MOSI, IOMUX_CONFIG_ALT1)
 #define MX31_PIN_CSPI3_MISO__TXD3	IOMUX_MODE(MX31_PIN_CSPI3_MISO, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_CSPI3_SCLK__RTS3	IOMUX_MODE(MX31_PIN_CSPI3_SCLK, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_CSPI3_SPI_RDY__CTS3	IOMUX_MODE(MX31_PIN_CSPI3_SPI_RDY, IOMUX_CONFIG_ALT1)
 #define MX31_PIN_CTS1__CTS1		IOMUX_MODE(MX31_PIN_CTS1, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_RTS1__RTS1		IOMUX_MODE(MX31_PIN_RTS1, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_TXD1__TXD1		IOMUX_MODE(MX31_PIN_TXD1, IOMUX_CONFIG_FUNC)
@@ -558,6 +560,16 @@
 #define MX31_PIN_SD1_DATA0__SD1_DATA0	IOMUX_MODE(MX31_PIN_SD1_DATA0, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_SD1_CLK__SD1_CLK	IOMUX_MODE(MX31_PIN_SD1_CLK, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_SD1_CMD__SD1_CMD	IOMUX_MODE(MX31_PIN_SD1_CMD, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_ATA_CS0__GPIO3_26	IOMUX_MODE(MX31_PIN_ATA_CS0, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_ATA_CS1__GPIO3_27	IOMUX_MODE(MX31_PIN_ATA_CS1, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_PC_PWRON__SD2_DATA3	IOMUX_MODE(MX31_PIN_PC_PWRON, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_PC_VS1__SD2_DATA2	IOMUX_MODE(MX31_PIN_PC_VS1, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_PC_READY__SD2_DATA1	IOMUX_MODE(MX31_PIN_PC_READY, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_PC_WAIT_B__SD2_DATA0	IOMUX_MODE(MX31_PIN_PC_WAIT_B, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_PC_CD2_B__SD2_CLK	IOMUX_MODE(MX31_PIN_PC_CD2_B, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_PC_CD1_B__SD2_CMD	IOMUX_MODE(MX31_PIN_PC_CD1_B, IOMUX_CONFIG_ALT1)
+#define MX31_PIN_ATA_DIOR__GPIO3_28	IOMUX_MODE(MX31_PIN_ATA_DIOR, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_ATA_DIOW__GPIO3_29	IOMUX_MODE(MX31_PIN_ATA_DIOW, IOMUX_CONFIG_GPIO)
 #define MX31_PIN_LD0__LD0		IOMUX_MODE(MX31_PIN_LD0, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_LD1__LD1		IOMUX_MODE(MX31_PIN_LD1, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_LD2__LD2		IOMUX_MODE(MX31_PIN_LD2, IOMUX_CONFIG_FUNC)
@@ -585,6 +597,42 @@
 #define MX31_PIN_D3_SPL__D3_SPL		IOMUX_MODE(MX31_PIN_D3_SPL, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_D3_CLS__D3_CLS		IOMUX_MODE(MX31_PIN_D3_CLS, IOMUX_CONFIG_FUNC)
 #define MX31_PIN_LCS0__GPI03_23		IOMUX_MODE(MX31_PIN_LCS0, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_GPIO1_1__GPIO          IOMUX_MODE(MX31_PIN_GPIO1_1, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_I2C_CLK__SCL		IOMUX_MODE(MX31_PIN_I2C_CLK, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_I2C_DAT__SDA		IOMUX_MODE(MX31_PIN_I2C_DAT, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_DCD_DTE1__I2C2_SDA	IOMUX_MODE(MX31_PIN_DCD_DTE1, IOMUX_CONFIG_ALT2)
+#define MX31_PIN_RI_DTE1__I2C2_SCL	IOMUX_MODE(MX31_PIN_RI_DTE1, IOMUX_CONFIG_ALT2)
+#define MX31_PIN_CSI_D4__CSI_D4		IOMUX_MODE(MX31_PIN_CSI_D4, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D5__CSI_D5		IOMUX_MODE(MX31_PIN_CSI_D5, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D6__CSI_D6		IOMUX_MODE(MX31_PIN_CSI_D6, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D7__CSI_D7		IOMUX_MODE(MX31_PIN_CSI_D7, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D8__CSI_D8		IOMUX_MODE(MX31_PIN_CSI_D8, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D9__CSI_D9		IOMUX_MODE(MX31_PIN_CSI_D9, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D10__CSI_D10	IOMUX_MODE(MX31_PIN_CSI_D10, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D11__CSI_D11	IOMUX_MODE(MX31_PIN_CSI_D11, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D12__CSI_D12	IOMUX_MODE(MX31_PIN_CSI_D12, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D13__CSI_D13	IOMUX_MODE(MX31_PIN_CSI_D13, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D14__CSI_D14	IOMUX_MODE(MX31_PIN_CSI_D14, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_D15__CSI_D15	IOMUX_MODE(MX31_PIN_CSI_D15, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_HSYNC__CSI_HSYNC	IOMUX_MODE(MX31_PIN_CSI_HSYNC, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_MCLK__CSI_MCLK	IOMUX_MODE(MX31_PIN_CSI_MCLK, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_PIXCLK__CSI_PIXCLK	IOMUX_MODE(MX31_PIN_CSI_PIXCLK, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_CSI_VSYNC__CSI_VSYNC	IOMUX_MODE(MX31_PIN_CSI_VSYNC, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_GPIO3_0__GPIO3_0	IOMUX_MODE(MX31_PIN_GPIO3_0, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_GPIO3_1__GPIO3_1	IOMUX_MODE(MX31_PIN_GPIO3_1, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_TXD2__GPIO1_28		IOMUX_MODE(MX31_PIN_TXD2, IOMUX_CONFIG_GPIO)
+#define MX31_PIN_USBOTG_DATA0__USBOTG_DATA0    IOMUX_MODE(MX31_PIN_USBOTG_DATA0, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DATA1__USBOTG_DATA1    IOMUX_MODE(MX31_PIN_USBOTG_DATA1, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DATA2__USBOTG_DATA2    IOMUX_MODE(MX31_PIN_USBOTG_DATA2, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DATA3__USBOTG_DATA3    IOMUX_MODE(MX31_PIN_USBOTG_DATA3, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DATA4__USBOTG_DATA4    IOMUX_MODE(MX31_PIN_USBOTG_DATA4, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DATA5__USBOTG_DATA5    IOMUX_MODE(MX31_PIN_USBOTG_DATA5, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DATA6__USBOTG_DATA6    IOMUX_MODE(MX31_PIN_USBOTG_DATA6, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DATA7__USBOTG_DATA7    IOMUX_MODE(MX31_PIN_USBOTG_DATA7, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_CLK__USBOTG_CLK        IOMUX_MODE(MX31_PIN_USBOTG_CLK, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_DIR__USBOTG_DIR        IOMUX_MODE(MX31_PIN_USBOTG_DIR, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_NXT__USBOTG_NXT        IOMUX_MODE(MX31_PIN_USBOTG_NXT, IOMUX_CONFIG_FUNC)
+#define MX31_PIN_USBOTG_STP__USBOTG_STP        IOMUX_MODE(MX31_PIN_USBOTG_STP, IOMUX_CONFIG_FUNC)
 
 /*XXX: The SS0, SS1, SS2, SS3 lines of spi3 are multiplexed by cspi2_ss0, cspi2_ss1, cspi1_ss0
  * cspi1_ss1*/
diff -urN linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/irqs.h linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/irqs.h
--- linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/irqs.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/irqs.h	2009-04-22 03:29:16.188931423 +0000
@@ -45,7 +45,7 @@
 
 #define NR_IRQS			(MXC_IPU_IRQ_START + MX3_IPU_IRQS)
 
-extern void imx_irq_set_priority(unsigned char irq, unsigned char prio);
+extern int imx_irq_set_priority(unsigned char irq, unsigned char prio);
 
 /* all normal IRQs can be FIQs */
 #define FIQ_START	0
diff -urN linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/mx21.h linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/mx21.h
--- linux-2.6.30-rc2/arch/arm/plat-mxc/include/mach/mx21.h	2009-04-22 03:29:10.179931414 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-mxc/include/mach/mx21.h	2009-04-22 03:29:16.188931423 +0000
@@ -54,9 +54,6 @@
 
 #define IRAM_BASE_ADDR          0xFFFFE800	/* internal ram */
 
-/* this CPU supports up to 192 GPIOs (don't forget the baseboard!) */
-#define ARCH_NR_GPIOS		(6*32 + 16)
-
 /* fixed interrupt numbers */
 #define MXC_INT_USBCTRL         58
 #define MXC_INT_USBCTRL         58
diff -urN linux-2.6.30-rc2/arch/arm/plat-mxc/irq.c linux-2.6.30-rc3/arch/arm/plat-mxc/irq.c
--- linux-2.6.30-rc2/arch/arm/plat-mxc/irq.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-mxc/irq.c	2009-04-22 03:29:16.190931696 +0000
@@ -50,23 +50,27 @@
 #define IIM_PROD_REV_SH		3
 #define IIM_PROD_REV_LEN	5
 
-#ifdef CONFIG_MXC_IRQ_PRIOR
-void imx_irq_set_priority(unsigned char irq, unsigned char prio)
+int imx_irq_set_priority(unsigned char irq, unsigned char prio)
 {
+#ifdef CONFIG_MXC_IRQ_PRIOR
 	unsigned int temp;
 	unsigned int mask = 0x0F << irq % 8 * 4;
 
-	if (irq > 63)
-		return;
+	if (irq >= MXC_INTERNAL_IRQS)
+		return -EINVAL;;
 
 	temp = __raw_readl(AVIC_NIPRIORITY(irq / 8));
 	temp &= ~mask;
 	temp |= prio & mask;
 
 	__raw_writel(temp, AVIC_NIPRIORITY(irq / 8));
+
+	return 0;
+#else
+	return -ENOSYS;
+#endif
 }
 EXPORT_SYMBOL(imx_irq_set_priority);
-#endif
 
 #ifdef CONFIG_FIQ
 int mxc_set_irq_fiq(unsigned int irq, unsigned int type)
diff -urN linux-2.6.30-rc2/arch/arm/plat-mxc/time.c linux-2.6.30-rc3/arch/arm/plat-mxc/time.c
--- linux-2.6.30-rc2/arch/arm/plat-mxc/time.c	2009-04-22 03:29:10.181931403 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-mxc/time.c	2009-04-22 03:29:16.191931476 +0000
@@ -36,7 +36,7 @@
 
 /* clock source */
 
-static cycle_t mxc_get_cycles(void)
+static cycle_t mxc_get_cycles(struct clocksource *cs)
 {
 	return __raw_readl(TIMER_BASE + MXC_TCN);
 }
diff -urN linux-2.6.30-rc2/arch/arm/plat-omap/common.c linux-2.6.30-rc3/arch/arm/plat-omap/common.c
--- linux-2.6.30-rc2/arch/arm/plat-omap/common.c	2009-04-22 03:29:10.181931403 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-omap/common.c	2009-04-22 03:29:16.191931476 +0000
@@ -185,7 +185,7 @@
 
 #include <linux/clocksource.h>
 
-static cycle_t omap_32k_read(void)
+static cycle_t omap_32k_read(struct clocksource *cs)
 {
 	return omap_readl(TIMER_32K_SYNCHRONIZED);
 }
@@ -207,7 +207,7 @@
 {
 	unsigned long long ret;
 
-	ret = (unsigned long long)omap_32k_read();
+	ret = (unsigned long long)omap_32k_read(&clocksource_32k);
 	ret = (ret * clocksource_32k.mult_orig) >> clocksource_32k.shift;
 	return ret;
 }
diff -urN linux-2.6.30-rc2/arch/arm/plat-orion/time.c linux-2.6.30-rc3/arch/arm/plat-orion/time.c
--- linux-2.6.30-rc2/arch/arm/plat-orion/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-orion/time.c	2009-04-22 03:29:16.201931613 +0000
@@ -41,7 +41,7 @@
 /*
  * Clocksource handling.
  */
-static cycle_t orion_clksrc_read(void)
+static cycle_t orion_clksrc_read(struct clocksource *cs)
 {
 	return 0xffffffff - readl(TIMER0_VAL);
 }
diff -urN linux-2.6.30-rc2/arch/arm/plat-s3c/gpio-config.c linux-2.6.30-rc3/arch/arm/plat-s3c/gpio-config.c
--- linux-2.6.30-rc2/arch/arm/plat-s3c/gpio-config.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-s3c/gpio-config.c	2009-04-22 03:29:16.203931653 +0000
@@ -13,6 +13,7 @@
 */
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/gpio.h>
 #include <linux/io.h>
 
@@ -38,6 +39,7 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(s3c_gpio_cfgpin);
 
 int s3c_gpio_setpull(unsigned int pin, s3c_gpio_pull_t pull)
 {
@@ -56,6 +58,7 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(s3c_gpio_setpull);
 
 #ifdef CONFIG_S3C_GPIO_CFG_S3C24XX
 int s3c_gpio_setcfg_s3c24xx_banka(struct s3c_gpio_chip *chip,
diff -urN linux-2.6.30-rc2/arch/arm/plat-s3c/include/plat/devs.h linux-2.6.30-rc3/arch/arm/plat-s3c/include/plat/devs.h
--- linux-2.6.30-rc2/arch/arm/plat-s3c/include/plat/devs.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-s3c/include/plat/devs.h	2009-04-22 03:29:16.203931653 +0000
@@ -34,6 +34,7 @@
 extern struct platform_device s3c_device_rtc;
 extern struct platform_device s3c_device_adc;
 extern struct platform_device s3c_device_sdi;
+extern struct platform_device s3c_device_hwmon;
 extern struct platform_device s3c_device_hsmmc0;
 extern struct platform_device s3c_device_hsmmc1;
 extern struct platform_device s3c_device_hsmmc2;
diff -urN linux-2.6.30-rc2/arch/arm/plat-s3c24xx/adc.c linux-2.6.30-rc3/arch/arm/plat-s3c24xx/adc.c
--- linux-2.6.30-rc2/arch/arm/plat-s3c24xx/adc.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-s3c24xx/adc.c	2009-04-22 03:29:16.204931447 +0000
@@ -100,7 +100,7 @@
 		readl(adc->regs + S3C2410_ADCDLY));
 }
 
-void s3c_adc_try(struct adc_device *adc)
+static void s3c_adc_try(struct adc_device *adc)
 {
 	struct s3c_adc_client *next = adc->ts_pend;
 
@@ -190,6 +190,23 @@
 void s3c_adc_release(struct s3c_adc_client *client)
 {
 	/* We should really check that nothing is in progress. */
+	if (adc_dev->cur == client)
+		adc_dev->cur = NULL;
+	if (adc_dev->ts_pend == client)
+		adc_dev->ts_pend = NULL;
+	else {
+		struct list_head *p, *n;
+		struct s3c_adc_client *tmp;
+
+		list_for_each_safe(p, n, &adc_pending) {
+			tmp = list_entry(p, struct s3c_adc_client, pend);
+			if (tmp == client)
+				list_del(&tmp->pend);
+		}
+	}
+
+	if (adc_dev->cur == NULL)
+		s3c_adc_try(adc_dev);
 	kfree(client);
 }
 EXPORT_SYMBOL_GPL(s3c_adc_release);
diff -urN linux-2.6.30-rc2/arch/arm/plat-s3c24xx/gpiolib.c linux-2.6.30-rc3/arch/arm/plat-s3c24xx/gpiolib.c
--- linux-2.6.30-rc2/arch/arm/plat-s3c24xx/gpiolib.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/arm/plat-s3c24xx/gpiolib.c	2009-04-22 03:29:16.204931447 +0000
@@ -19,7 +19,7 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 
-#include <plat/gpio-core.h>
+#include <mach/gpio-core.h>
 #include <mach/hardware.h>
 #include <asm/irq.h>
 
diff -urN linux-2.6.30-rc2/arch/avr32/kernel/time.c linux-2.6.30-rc3/arch/avr32/kernel/time.c
--- linux-2.6.30-rc2/arch/avr32/kernel/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/avr32/kernel/time.c	2009-04-22 03:29:16.212931434 +0000
@@ -18,7 +18,7 @@
 #include <mach/pm.h>
 
 
-static cycle_t read_cycle_count(void)
+static cycle_t read_cycle_count(struct clocksource *cs)
 {
 	return (cycle_t)sysreg_read(COUNT);
 }
diff -urN linux-2.6.30-rc2/arch/blackfin/kernel/time-ts.c linux-2.6.30-rc3/arch/blackfin/kernel/time-ts.c
--- linux-2.6.30-rc2/arch/blackfin/kernel/time-ts.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/blackfin/kernel/time-ts.c	2009-04-22 03:29:16.222931422 +0000
@@ -58,16 +58,11 @@
 	return (cyc * cyc2ns_scale) >> CYC2NS_SCALE_FACTOR;
 }
 
-static cycle_t read_cycles(void)
+static cycle_t read_cycles(struct clocksource *cs)
 {
 	return __bfin_cycles_off + (get_cycles() << __bfin_cycles_mod);
 }
 
-unsigned long long sched_clock(void)
-{
-	return cycles_2_ns(read_cycles());
-}
-
 static struct clocksource clocksource_bfin = {
 	.name		= "bfin_cycles",
 	.rating		= 350,
@@ -77,6 +72,11 @@
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
+unsigned long long sched_clock(void)
+{
+	return cycles_2_ns(read_cycles(&clocksource_bfin));
+}
+
 static int __init bfin_clocksource_init(void)
 {
 	set_cyc2ns_scale(get_cclk() / 1000);
diff -urN linux-2.6.30-rc2/arch/frv/kernel/setup.c linux-2.6.30-rc3/arch/frv/kernel/setup.c
--- linux-2.6.30-rc2/arch/frv/kernel/setup.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/frv/kernel/setup.c	2009-04-22 03:29:16.241931680 +0000
@@ -46,7 +46,6 @@
 #include <asm/io.h>
 
 #ifdef CONFIG_BLK_DEV_INITRD
-#include <linux/blk.h>
 #include <asm/pgtable.h>
 #endif
 
diff -urN linux-2.6.30-rc2/arch/frv/mb93090-mb00/pci-vdk.c linux-2.6.30-rc3/arch/frv/mb93090-mb00/pci-vdk.c
--- linux-2.6.30-rc2/arch/frv/mb93090-mb00/pci-vdk.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/frv/mb93090-mb00/pci-vdk.c	2009-04-22 03:29:16.241931680 +0000
@@ -31,6 +31,29 @@
 struct pci_ops *__nongpreldata pci_root_ops;
 
 /*
+ * The accessible PCI window does not cover the entire CPU address space, but
+ * there are devices we want to access outside of that window, so we need to
+ * insert specific PCI bus resources instead of using the platform-level bus
+ * resources directly for the PCI root bus.
+ *
+ * These are configured and inserted by pcibios_init() and are attached to the
+ * root bus by pcibios_fixup_bus().
+ */
+static struct resource pci_ioport_resource = {
+	.name	= "PCI IO",
+	.start	= 0,
+	.end	= IO_SPACE_LIMIT,
+	.flags	= IORESOURCE_IO,
+};
+
+static struct resource pci_iomem_resource = {
+	.name	= "PCI mem",
+	.start	= 0,
+	.end	= -1,
+	.flags	= IORESOURCE_MEM,
+};
+
+/*
  * Functions for accessing PCI configuration space
  */
 
@@ -304,6 +327,12 @@
 #if 0
 	printk("### PCIBIOS_FIXUP_BUS(%d)\n",bus->number);
 #endif
+
+	if (bus->number == 0) {
+		bus->resource[0] = &pci_ioport_resource;
+		bus->resource[1] = &pci_iomem_resource;
+	}
+
 	pci_read_bridge_bases(bus);
 
 	if (bus->number == 0) {
@@ -350,28 +379,36 @@
 	/* enable PCI arbitration */
 	__reg_MB86943_pci_arbiter	= MB86943_PCIARB_EN;
 
-	ioport_resource.start	= (__reg_MB86943_sl_pci_io_base << 9) & 0xfffffc00;
-	ioport_resource.end	= (__reg_MB86943_sl_pci_io_range << 9) | 0x3ff;
-	ioport_resource.end	+= ioport_resource.start;
+	pci_ioport_resource.start	= (__reg_MB86943_sl_pci_io_base << 9) & 0xfffffc00;
+	pci_ioport_resource.end		= (__reg_MB86943_sl_pci_io_range << 9) | 0x3ff;
+	pci_ioport_resource.end		+= pci_ioport_resource.start;
 
 	printk("PCI IO window:  %08llx-%08llx\n",
-	       (unsigned long long) ioport_resource.start,
-	       (unsigned long long) ioport_resource.end);
-
-	iomem_resource.start	= (__reg_MB86943_sl_pci_mem_base << 9) & 0xfffffc00;
+	       (unsigned long long) pci_ioport_resource.start,
+	       (unsigned long long) pci_ioport_resource.end);
 
-	/* Reserve somewhere to write to flush posted writes. */
-	iomem_resource.start += 0x400;
-
-	iomem_resource.end	= (__reg_MB86943_sl_pci_mem_range << 9) | 0x3ff;
-	iomem_resource.end	+= iomem_resource.start;
+	pci_iomem_resource.start	= (__reg_MB86943_sl_pci_mem_base << 9) & 0xfffffc00;
+	pci_iomem_resource.end		= (__reg_MB86943_sl_pci_mem_range << 9) | 0x3ff;
+	pci_iomem_resource.end		+= pci_iomem_resource.start;
+
+	/* Reserve somewhere to write to flush posted writes.  This is used by
+	 * __flush_PCI_writes() from asm/io.h to force the write FIFO in the
+	 * CPU-PCI bridge to flush as this doesn't happen automatically when a
+	 * read is performed on the MB93090 development kit motherboard.
+	 */
+	pci_iomem_resource.start	+= 0x400;
 
 	printk("PCI MEM window: %08llx-%08llx\n",
-	       (unsigned long long) iomem_resource.start,
-	       (unsigned long long) iomem_resource.end);
+	       (unsigned long long) pci_iomem_resource.start,
+	       (unsigned long long) pci_iomem_resource.end);
 	printk("PCI DMA memory: %08lx-%08lx\n",
 	       dma_coherent_mem_start, dma_coherent_mem_end);
 
+	if (insert_resource(&iomem_resource, &pci_iomem_resource) < 0)
+		panic("Unable to insert PCI IOMEM resource\n");
+	if (insert_resource(&ioport_resource, &pci_ioport_resource) < 0)
+		panic("Unable to insert PCI IOPORT resource\n");
+
 	if (!pci_probe)
 		return -ENXIO;
 
diff -urN linux-2.6.30-rc2/arch/h8300/include/asm/timer.h linux-2.6.30-rc3/arch/h8300/include/asm/timer.h
--- linux-2.6.30-rc2/arch/h8300/include/asm/timer.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/h8300/include/asm/timer.h	2009-04-22 03:29:16.241931680 +0000
@@ -0,0 +1,25 @@
+#ifndef __H8300_TIMER_H
+#define __H8300_TIMER_H
+
+void h8300_timer_tick(void);
+void h8300_timer_setup(void);
+void h8300_gettod(unsigned int *year, unsigned int *mon, unsigned int *day,
+		   unsigned int *hour, unsigned int *min, unsigned int *sec);
+
+#define TIMER_FREQ (CONFIG_CPU_CLOCK*10000) /* Timer input freq. */
+
+#define calc_param(cnt, div, rate, limit)			\
+do {								\
+	cnt = TIMER_FREQ / HZ;					\
+	for (div = 0; div < ARRAY_SIZE(divide_rate); div++) {	\
+		if (rate[div] == 0)				\
+			continue;				\
+		if ((cnt / rate[div]) > limit)			\
+			break;					\
+	}							\
+	if (div == ARRAY_SIZE(divide_rate))			\
+		panic("Timer counter overflow");		\
+	cnt /= divide_rate[div];				\
+} while(0)
+
+#endif
diff -urN linux-2.6.30-rc2/arch/ia64/include/asm/paravirt_privop.h linux-2.6.30-rc3/arch/ia64/include/asm/paravirt_privop.h
--- linux-2.6.30-rc2/arch/ia64/include/asm/paravirt_privop.h	2009-04-22 03:29:10.237931407 +0000
+++ linux-2.6.30-rc3/arch/ia64/include/asm/paravirt_privop.h	2009-04-22 03:29:16.248931470 +0000
@@ -445,7 +445,6 @@
 		register unsigned long ia64_intri_res asm ("r8");	\
 		register unsigned long __reg asm ("r8") = (reg);	\
 									\
-		BUILD_BUG_ON(!__builtin_constant_p(reg));		\
 		asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\
 						  PARAVIRT_TYPE(GETREG) \
 						  + (reg))		\
@@ -464,7 +463,6 @@
 		register unsigned long ia64_clobber1 asm ("r8");	\
 		register unsigned long ia64_clobber2 asm ("r9");	\
 									\
-		BUILD_BUG_ON(!__builtin_constant_p(reg));		\
 		asm volatile (paravirt_alt_bundle(__PARAVIRT_BR,	\
 						  PARAVIRT_TYPE(SETREG) \
 						  + (reg))		\
diff -urN linux-2.6.30-rc2/arch/ia64/include/asm/smp.h linux-2.6.30-rc3/arch/ia64/include/asm/smp.h
--- linux-2.6.30-rc2/arch/ia64/include/asm/smp.h	2009-04-22 03:29:10.237931407 +0000
+++ linux-2.6.30-rc3/arch/ia64/include/asm/smp.h	2009-04-22 03:29:16.248931470 +0000
@@ -58,7 +58,7 @@
 extern char no_int_routing __devinitdata;
 
 extern cpumask_t cpu_core_map[NR_CPUS];
-DECLARE_PER_CPU(cpumask_t, cpu_sibling_map);
+DECLARE_PER_CPU_SHARED_ALIGNED(cpumask_t, cpu_sibling_map);
 extern int smp_num_siblings;
 extern void __iomem *ipi_base_addr;
 extern unsigned char smp_int_redirect;
diff -urN linux-2.6.30-rc2/arch/ia64/kernel/cyclone.c linux-2.6.30-rc3/arch/ia64/kernel/cyclone.c
--- linux-2.6.30-rc2/arch/ia64/kernel/cyclone.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/ia64/kernel/cyclone.c	2009-04-22 03:29:16.251931634 +0000
@@ -21,7 +21,7 @@
 
 static void __iomem *cyclone_mc;
 
-static cycle_t read_cyclone(void)
+static cycle_t read_cyclone(struct clocksource *cs)
 {
 	return (cycle_t)readq((void __iomem *)cyclone_mc);
 }
diff -urN linux-2.6.30-rc2/arch/ia64/kernel/smp.c linux-2.6.30-rc3/arch/ia64/kernel/smp.c
--- linux-2.6.30-rc2/arch/ia64/kernel/smp.c	2009-04-22 03:29:10.247931221 +0000
+++ linux-2.6.30-rc3/arch/ia64/kernel/smp.c	2009-04-22 03:29:16.258931388 +0000
@@ -225,6 +225,7 @@
 {
 	platform_send_ipi(cpu, IA64_IPI_RESCHEDULE, IA64_IPI_DM_INT, 0);
 }
+EXPORT_SYMBOL_GPL(smp_send_reschedule);
 
 /*
  * Called with preemption disabled.
@@ -300,15 +301,12 @@
 		return;
 	}
 
+	smp_call_function_mask(mm->cpu_vm_mask,
+		(void (*)(void *))local_finish_flush_tlb_mm, mm, 1);
+	local_irq_disable();
+	local_finish_flush_tlb_mm(mm);
+	local_irq_enable();
 	preempt_enable();
-	/*
-	 * We could optimize this further by using mm->cpu_vm_mask to track which CPUs
-	 * have been running in the address space.  It's not clear that this is worth the
-	 * trouble though: to avoid races, we have to raise the IPI on the target CPU
-	 * anyhow, and once a CPU is interrupted, the cost of local_flush_tlb_all() is
-	 * rather trivial.
-	 */
-	on_each_cpu((void (*)(void *))local_finish_flush_tlb_mm, mm, 1);
 }
 
 void arch_send_call_function_single_ipi(int cpu)
diff -urN linux-2.6.30-rc2/arch/ia64/kernel/time.c linux-2.6.30-rc3/arch/ia64/kernel/time.c
--- linux-2.6.30-rc2/arch/ia64/kernel/time.c	2009-04-22 03:29:10.248931415 +0000
+++ linux-2.6.30-rc3/arch/ia64/kernel/time.c	2009-04-22 03:29:16.259931420 +0000
@@ -33,7 +33,7 @@
 
 #include "fsyscall_gtod_data.h"
 
-static cycle_t itc_get_cycles(void);
+static cycle_t itc_get_cycles(struct clocksource *cs);
 
 struct fsyscall_gtod_data_t fsyscall_gtod_data = {
 	.lock = SEQLOCK_UNLOCKED,
@@ -383,7 +383,7 @@
 	}
 }
 
-static cycle_t itc_get_cycles(void)
+static cycle_t itc_get_cycles(struct clocksource *cs)
 {
 	u64 lcycle, now, ret;
 
diff -urN linux-2.6.30-rc2/arch/ia64/sn/kernel/sn2/timer.c linux-2.6.30-rc3/arch/ia64/sn/kernel/sn2/timer.c
--- linux-2.6.30-rc2/arch/ia64/sn/kernel/sn2/timer.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/ia64/sn/kernel/sn2/timer.c	2009-04-22 03:29:16.263931493 +0000
@@ -23,7 +23,7 @@
 
 extern unsigned long sn_rtc_cycles_per_second;
 
-static cycle_t read_sn2(void)
+static cycle_t read_sn2(struct clocksource *cs)
 {
 	return (cycle_t)readq(RTC_COUNTER_ADDR);
 }
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/Kbuild linux-2.6.30-rc3/arch/m32r/include/asm/Kbuild
--- linux-2.6.30-rc2/arch/m32r/include/asm/Kbuild	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/Kbuild	2009-04-22 03:29:16.264931414 +0000
@@ -0,0 +1 @@
+include include/asm-generic/Kbuild.asm
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/addrspace.h linux-2.6.30-rc3/arch/m32r/include/asm/addrspace.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/addrspace.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/addrspace.h	2009-04-22 03:29:16.264931414 +0000
@@ -0,0 +1,57 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 by Hiroyuki Kondo
+ *
+ * Defitions for the address spaces of the M32R CPUs.
+ */
+#ifndef __ASM_M32R_ADDRSPACE_H
+#define __ASM_M32R_ADDRSPACE_H
+
+/*
+ * Memory segments (32bit kernel mode addresses)
+ */
+#define KUSEG                   0x00000000
+#define KSEG0                   0x80000000
+#define KSEG1                   0xa0000000
+#define KSEG2                   0xc0000000
+#define KSEG3                   0xe0000000
+
+#define K0BASE  KSEG0
+
+/*
+ * Returns the kernel segment base of a given address
+ */
+#ifndef __ASSEMBLY__
+#define KSEGX(a)                (((unsigned long)(a)) & 0xe0000000)
+#else
+#define KSEGX(a)                ((a) & 0xe0000000)
+#endif
+
+/*
+ * Returns the physical address of a KSEG0/KSEG1 address
+ */
+#ifndef __ASSEMBLY__
+#define PHYSADDR(a)		(((unsigned long)(a)) & 0x1fffffff)
+#else
+#define PHYSADDR(a)		((a) & 0x1fffffff)
+#endif
+
+/*
+ * Map an address to a certain kernel segment
+ */
+#ifndef __ASSEMBLY__
+#define KSEG0ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG0))
+#define KSEG1ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG1))
+#define KSEG2ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG2))
+#define KSEG3ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG3))
+#else
+#define KSEG0ADDR(a)		(((a) & 0x1fffffff) | KSEG0)
+#define KSEG1ADDR(a)		(((a) & 0x1fffffff) | KSEG1)
+#define KSEG2ADDR(a)		(((a) & 0x1fffffff) | KSEG2)
+#define KSEG3ADDR(a)		(((a) & 0x1fffffff) | KSEG3)
+#endif
+
+#endif /* __ASM_M32R_ADDRSPACE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/assembler.h linux-2.6.30-rc3/arch/m32r/include/asm/assembler.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/assembler.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/assembler.h	2009-04-22 03:29:16.264931414 +0000
@@ -0,0 +1,229 @@
+#ifndef _ASM_M32R_ASSEMBLER_H
+#define _ASM_M32R_ASSEMBLER_H
+
+/*
+ * linux/asm-m32r/assembler.h
+ *
+ * Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ *
+ * This file contains M32R architecture specific macro definitions.
+ */
+
+
+#ifndef __STR
+#ifdef __ASSEMBLY__
+#define __STR(x) x
+#else
+#define __STR(x) #x
+#endif
+#endif /* __STR */
+
+#ifdef CONFIG_SMP
+#define M32R_LOCK	__STR(lock)
+#define M32R_UNLOCK	__STR(unlock)
+#else
+#define M32R_LOCK	__STR(ld)
+#define M32R_UNLOCK	__STR(st)
+#endif
+
+#ifdef __ASSEMBLY__
+#undef ENTRY
+#define ENTRY(name) ENTRY_M name
+	.macro  ENTRY_M name
+	.global \name
+	ALIGN
+\name:
+	.endm
+#endif
+
+
+/**
+ * LDIMM - load immediate value
+ * STI - enable interruption
+ * CLI - disable interruption
+ */
+
+#ifdef __ASSEMBLY__
+
+#define LDIMM(reg,x) LDIMM reg x
+	.macro LDIMM reg x
+	seth	\reg, #high(\x)
+	or3	\reg, \reg, #low(\x)
+	.endm
+
+#if !(defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_M32104))
+#define ENABLE_INTERRUPTS(reg) ENABLE_INTERRUPTS reg
+	.macro ENABLE_INTERRUPTS reg
+	setpsw  #0x40	    ->	nop
+	; WORKAROUND: "-> nop" is a workaround for the M32700(TS1).
+	.endm
+
+#define DISABLE_INTERRUPTS(reg) DISABLE_INTERRUPTS reg
+	.macro DISABLE_INTERRUPTS reg
+	clrpsw  #0x40	    ->	nop
+	; WORKAROUND: "-> nop" is a workaround for the M32700(TS1).
+	.endm
+#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
+#define ENABLE_INTERRUPTS(reg) ENABLE_INTERRUPTS reg
+	.macro ENABLE_INTERRUPTS reg
+	mvfc	\reg, psw
+	or3	\reg, \reg, #0x0040
+	mvtc	\reg, psw
+	.endm
+
+#define DISABLE_INTERRUPTS(reg) DISABLE_INTERRUPTS reg
+	.macro DISABLE_INTERRUPTS reg
+	mvfc	\reg, psw
+	and3	\reg, \reg, #0xffbf
+	mvtc	\reg, psw
+	.endm
+#endif	/* CONFIG_CHIP_M32102 */
+
+	.macro	SAVE_ALL
+	push	r0		; orig_r0
+	push	sp		; spi (r15)
+	push	lr		; r14
+	push	r13
+	mvfc	r13, cr3	; spu
+	push	r13
+	mvfc	r13, bbpc
+	push	r13
+	mvfc	r13, bbpsw
+	push	r13
+	mvfc	r13, bpc
+	push	r13
+	mvfc	r13, psw
+	push	r13
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	mvfaclo	r13, a1
+	push	r13
+	mvfachi r13, a1
+	push	r13
+	mvfaclo	r13, a0
+	push	r13
+	mvfachi	r13, a0
+	push	r13
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	mvfaclo	r13
+	push	r13
+	mvfachi	r13
+	push	r13
+	ldi	r13, #0
+	push	r13		; dummy push acc1h
+	push	r13		; dummy push acc1l
+#else
+#error unknown isa configuration
+#endif
+	ldi	r13, #-1
+	push	r13		; syscall_nr (default: -1)
+	push	r12
+	push	r11
+	push	r10
+	push	r9
+	push	r8
+	push	r7
+	push	r3
+	push	r2
+	push	r1
+	push	r0
+	addi	sp, #-4		; room for implicit pt_regs parameter
+	push	r6
+	push	r5
+	push	r4
+	.endm
+
+	.macro	RESTORE_ALL
+	pop	r4
+	pop	r5
+	pop	r6
+	addi	sp, #4
+	pop	r0
+	pop	r1
+	pop	r2
+	pop	r3
+	pop	r7
+	pop	r8
+	pop	r9
+	pop	r10
+	pop	r11
+	pop	r12
+	addi	r15, #4		; Skip syscall number
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	pop	r13
+	mvtachi	r13, a0
+	pop	r13
+	mvtaclo	r13, a0
+	pop	r13
+	mvtachi	r13, a1
+	pop	r13
+	mvtaclo	r13, a1
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	pop	r13		; dummy pop acc1h
+	pop	r13		; dummy pop acc1l
+	pop	r13
+	mvtachi	r13
+	pop	r13
+	mvtaclo	r13
+#else
+#error unknown isa configuration
+#endif
+	pop	r14
+	mvtc	r14, psw
+	pop	r14
+	mvtc	r14, bpc
+	addi	sp, #8		; Skip bbpsw, bbpc
+	pop	r14
+	mvtc	r14, cr3	; spu
+	pop	r13
+	pop	lr		; r14
+	pop	sp		; spi (r15)
+	addi	sp, #4		; Skip orig_r0
+	.fillinsn
+1:	rte
+	.section .fixup,"ax"
+2:	bl	do_exit
+	.previous
+	.section __ex_table,"a"
+	ALIGN
+	.long	1b, 2b
+	.previous
+	.endm
+
+#define GET_CURRENT(reg)  get_current reg
+	.macro get_current reg
+	ldi  \reg, #-8192
+	and  \reg, sp
+	.endm
+
+#if !(defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_M32104))
+	.macro	SWITCH_TO_KERNEL_STACK
+	; switch to kernel stack (spi)
+	clrpsw	#0x80	    ->	nop
+	.endm
+#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
+	.macro	SWITCH_TO_KERNEL_STACK
+	push	r0		; save r0 for working
+	mvfc	r0, psw
+	and3	r0, r0, #0x00ff7f
+	mvtc	r0, psw
+	slli	r0, #16
+	bltz	r0, 1f		; check BSM-bit
+;
+	;; called from kernel context: previous stack = spi
+	pop	r0		; retrieve r0
+	bra	2f
+	.fillinsn
+1:
+	;; called from user context: previous stack = spu
+	mvfc	r0, cr3		; spu
+	addi	r0, #4
+	mvtc	r0, cr3		; spu
+	ld	r0, @(-4,r0)	; retrieve r0
+	.fillinsn
+2:
+	.endm
+#endif	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
+
+#endif	/* __ASSEMBLY__ */
+
+#endif	/* _ASM_M32R_ASSEMBLER_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/atomic.h linux-2.6.30-rc3/arch/m32r/include/asm/atomic.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/atomic.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/atomic.h	2009-04-22 03:29:16.265931446 +0000
@@ -0,0 +1,318 @@
+#ifndef _ASM_M32R_ATOMIC_H
+#define _ASM_M32R_ATOMIC_H
+
+/*
+ *  linux/include/asm-m32r/atomic.h
+ *
+ *  M32R version:
+ *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
+ *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#include <linux/types.h>
+#include <asm/assembler.h>
+#include <asm/system.h>
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ */
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+/**
+ * atomic_read - read atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically reads the value of @v.
+ */
+#define atomic_read(v)	((v)->counter)
+
+/**
+ * atomic_set - set atomic variable
+ * @v: pointer of type atomic_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.
+ */
+#define atomic_set(v,i)	(((v)->counter) = (i))
+
+/**
+ * atomic_add_return - add integer to atomic variable and return it
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ *
+ * Atomically adds @i to @v and return (@i + @v).
+ */
+static __inline__ int atomic_add_return(int i, atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_add_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"add	%0, %2;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter), "r" (i)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * atomic_sub_return - subtract integer from atomic variable and return it
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ *
+ * Atomically subtracts @i from @v and return (@v - @i).
+ */
+static __inline__ int atomic_sub_return(int i, atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_sub_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"sub	%0, %2;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter), "r" (i)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * atomic_add - add integer to atomic variable
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ *
+ * Atomically adds @i to @v.
+ */
+#define atomic_add(i,v) ((void) atomic_add_return((i), (v)))
+
+/**
+ * atomic_sub - subtract the atomic variable
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ *
+ * Atomically subtracts @i from @v.
+ */
+#define atomic_sub(i,v) ((void) atomic_sub_return((i), (v)))
+
+/**
+ * atomic_sub_and_test - subtract value from variable and test result
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ *
+ * Atomically subtracts @i from @v and returns
+ * true if the result is zero, or false for all
+ * other cases.
+ */
+#define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
+
+/**
+ * atomic_inc_return - increment atomic variable and return it
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1 and returns the result.
+ */
+static __inline__ int atomic_inc_return(atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_inc_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"addi	%0, #1;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * atomic_dec_return - decrement atomic variable and return it
+ * @v: pointer of type atomic_t
+ *
+ * Atomically decrements @v by 1 and returns the result.
+ */
+static __inline__ int atomic_dec_return(atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_dec_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"addi	%0, #-1;		\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * atomic_inc - increment atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1.
+ */
+#define atomic_inc(v) ((void)atomic_inc_return(v))
+
+/**
+ * atomic_dec - decrement atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically decrements @v by 1.
+ */
+#define atomic_dec(v) ((void)atomic_dec_return(v))
+
+/**
+ * atomic_inc_and_test - increment and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+#define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)
+
+/**
+ * atomic_dec_and_test - decrement and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically decrements @v by 1 and
+ * returns true if the result is 0, or false for all
+ * other cases.
+ */
+#define atomic_dec_and_test(v) (atomic_dec_return(v) == 0)
+
+/**
+ * atomic_add_negative - add and test if negative
+ * @v: pointer of type atomic_t
+ * @i: integer value to add
+ *
+ * Atomically adds @i to @v and returns true
+ * if the result is negative, or false when
+ * result is greater than or equal to zero.
+ */
+#define atomic_add_negative(i,v) (atomic_add_return((i), (v)) < 0)
+
+#define atomic_cmpxchg(v, o, n) ((int)cmpxchg(&((v)->counter), (o), (n)))
+#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
+
+/**
+ * atomic_add_unless - add unless the number is a given value
+ * @v: pointer of type atomic_t
+ * @a: the amount to add to v...
+ * @u: ...unless v is equal to u.
+ *
+ * Atomically adds @a to @v, so long as it was not @u.
+ * Returns non-zero if @v was not @u, and zero otherwise.
+ */
+static __inline__ int atomic_add_unless(atomic_t *v, int a, int u)
+{
+	int c, old;
+	c = atomic_read(v);
+	for (;;) {
+		if (unlikely(c == (u)))
+			break;
+		old = atomic_cmpxchg((v), c, c + (a));
+		if (likely(old == c))
+			break;
+		c = old;
+	}
+	return c != (u);
+}
+
+#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+
+static __inline__ void atomic_clear_mask(unsigned long  mask, atomic_t *addr)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_clear_mask		\n\t"
+		DCACHE_CLEAR("%0", "r5", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"and	%0, %2;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (tmp)
+		: "r" (addr), "r" (~mask)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+static __inline__ void atomic_set_mask(unsigned long  mask, atomic_t *addr)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_set_mask		\n\t"
+		DCACHE_CLEAR("%0", "r5", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"or	%0, %2;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (tmp)
+		: "r" (addr), "r" (mask)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/* Atomic operations are already serializing on m32r */
+#define smp_mb__before_atomic_dec()	barrier()
+#define smp_mb__after_atomic_dec()	barrier()
+#define smp_mb__before_atomic_inc()	barrier()
+#define smp_mb__after_atomic_inc()	barrier()
+
+#include <asm-generic/atomic.h>
+#endif	/* _ASM_M32R_ATOMIC_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/auxvec.h linux-2.6.30-rc3/arch/m32r/include/asm/auxvec.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/auxvec.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/auxvec.h	2009-04-22 03:29:16.265931446 +0000
@@ -0,0 +1,4 @@
+#ifndef _ASM_M32R__AUXVEC_H
+#define _ASM_M32R__AUXVEC_H
+
+#endif  /* _ASM_M32R__AUXVEC_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/bitops.h linux-2.6.30-rc3/arch/m32r/include/asm/bitops.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/bitops.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/bitops.h	2009-04-22 03:29:16.265931446 +0000
@@ -0,0 +1,275 @@
+#ifndef _ASM_M32R_BITOPS_H
+#define _ASM_M32R_BITOPS_H
+
+/*
+ *  linux/include/asm-m32r/bitops.h
+ *
+ *  Copyright 1992, Linus Torvalds.
+ *
+ *  M32R version:
+ *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
+ *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#ifndef _LINUX_BITOPS_H
+#error only <linux/bitops.h> can be included directly
+#endif
+
+#include <linux/compiler.h>
+#include <asm/assembler.h>
+#include <asm/system.h>
+#include <asm/byteorder.h>
+#include <asm/types.h>
+
+/*
+ * These have to be done with inline assembly: that way the bit-setting
+ * is guaranteed to be atomic. All bit operations return 0 if the bit
+ * was cleared before the operation and != 0 if it was not.
+ *
+ * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
+ */
+
+/**
+ * set_bit - Atomically set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * This function is atomic and may not be reordered.  See __set_bit()
+ * if you do not require the atomic guarantees.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void set_bit(int nr, volatile void * addr)
+{
+	__u32 mask;
+	volatile __u32 *a = addr;
+	unsigned long flags;
+	unsigned long tmp;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "r6", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"or	%0, %2;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (tmp)
+		: "r" (a), "r" (mask)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * clear_bit - Clears a bit in memory
+ * @nr: Bit to clear
+ * @addr: Address to start counting from
+ *
+ * clear_bit() is atomic and may not be reordered.  However, it does
+ * not contain a memory barrier, so if it is used for locking purposes,
+ * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
+ * in order to ensure changes are visible on other processors.
+ */
+static __inline__ void clear_bit(int nr, volatile void * addr)
+{
+	__u32 mask;
+	volatile __u32 *a = addr;
+	unsigned long flags;
+	unsigned long tmp;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "r6", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"and	%0, %2;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (tmp)
+		: "r" (a), "r" (~mask)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+/**
+ * change_bit - Toggle a bit in memory
+ * @nr: Bit to clear
+ * @addr: Address to start counting from
+ *
+ * change_bit() is atomic and may not be reordered.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void change_bit(int nr, volatile void * addr)
+{
+	__u32  mask;
+	volatile __u32  *a = addr;
+	unsigned long flags;
+	unsigned long tmp;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "r6", "%1")
+		M32R_LOCK" %0, @%1;		\n\t"
+		"xor	%0, %2;			\n\t"
+		M32R_UNLOCK" %0, @%1;		\n\t"
+		: "=&r" (tmp)
+		: "r" (a), "r" (mask)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_set_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+	unsigned long flags;
+	unsigned long tmp;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "%1", "%2")
+		M32R_LOCK" %0, @%2;		\n\t"
+		"mv	%1, %0;			\n\t"
+		"and	%0, %3;			\n\t"
+		"or	%1, %3;			\n\t"
+		M32R_UNLOCK" %1, @%2;		\n\t"
+		: "=&r" (oldbit), "=&r" (tmp)
+		: "r" (a), "r" (mask)
+		: "memory"
+	);
+	local_irq_restore(flags);
+
+	return (oldbit != 0);
+}
+
+/**
+ * test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_clear_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+	unsigned long flags;
+	unsigned long tmp;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "%1", "%3")
+		M32R_LOCK" %0, @%3;		\n\t"
+		"mv	%1, %0;			\n\t"
+		"and	%0, %2;			\n\t"
+		"not	%2, %2;			\n\t"
+		"and	%1, %2;			\n\t"
+		M32R_UNLOCK" %1, @%3;		\n\t"
+		: "=&r" (oldbit), "=&r" (tmp), "+r" (mask)
+		: "r" (a)
+		: "memory"
+	);
+	local_irq_restore(flags);
+
+	return (oldbit != 0);
+}
+
+/**
+ * test_and_change_bit - Change a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_change_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+	unsigned long flags;
+	unsigned long tmp;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "%1", "%2")
+		M32R_LOCK" %0, @%2;		\n\t"
+		"mv	%1, %0;			\n\t"
+		"and	%0, %3;			\n\t"
+		"xor	%1, %3;			\n\t"
+		M32R_UNLOCK" %1, @%2;		\n\t"
+		: "=&r" (oldbit), "=&r" (tmp)
+		: "r" (a), "r" (mask)
+		: "memory"
+	);
+	local_irq_restore(flags);
+
+	return (oldbit != 0);
+}
+
+#include <asm-generic/bitops/non-atomic.h>
+#include <asm-generic/bitops/ffz.h>
+#include <asm-generic/bitops/__ffs.h>
+#include <asm-generic/bitops/fls.h>
+#include <asm-generic/bitops/__fls.h>
+#include <asm-generic/bitops/fls64.h>
+
+#ifdef __KERNEL__
+
+#include <asm-generic/bitops/sched.h>
+#include <asm-generic/bitops/find.h>
+#include <asm-generic/bitops/ffs.h>
+#include <asm-generic/bitops/hweight.h>
+#include <asm-generic/bitops/lock.h>
+
+#endif /* __KERNEL__ */
+
+#ifdef __KERNEL__
+
+#include <asm-generic/bitops/ext2-non-atomic.h>
+#include <asm-generic/bitops/ext2-atomic.h>
+#include <asm-generic/bitops/minix.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_M32R_BITOPS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/bug.h linux-2.6.30-rc3/arch/m32r/include/asm/bug.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/bug.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/bug.h	2009-04-22 03:29:16.265931446 +0000
@@ -0,0 +1,4 @@
+#ifndef _M32R_BUG_H
+#define _M32R_BUG_H
+#include <asm-generic/bug.h>
+#endif
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/bugs.h linux-2.6.30-rc3/arch/m32r/include/asm/bugs.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/bugs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/bugs.h	2009-04-22 03:29:16.265931446 +0000
@@ -0,0 +1,19 @@
+#ifndef _ASM_M32R_BUGS_H
+#define _ASM_M32R_BUGS_H
+
+/*
+ * This is included by init/main.c to check for architecture-dependent bugs.
+ *
+ * Needs:
+ *     void check_bugs(void);
+ */
+#include <asm/processor.h>
+
+static void __init check_bugs(void)
+{
+	extern unsigned long loops_per_jiffy;
+
+	current_cpu_data.loops_per_jiffy = loops_per_jiffy;
+}
+
+#endif  /* _ASM_M32R_BUGS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/byteorder.h linux-2.6.30-rc3/arch/m32r/include/asm/byteorder.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/byteorder.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/byteorder.h	2009-04-22 03:29:16.265931446 +0000
@@ -0,0 +1,10 @@
+#ifndef _ASM_M32R_BYTEORDER_H
+#define _ASM_M32R_BYTEORDER_H
+
+#if defined(__LITTLE_ENDIAN__)
+#  include <linux/byteorder/little_endian.h>
+#else
+#  include <linux/byteorder/big_endian.h>
+#endif
+
+#endif /* _ASM_M32R_BYTEORDER_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/cache.h linux-2.6.30-rc3/arch/m32r/include/asm/cache.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/cache.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/cache.h	2009-04-22 03:29:16.265931446 +0000
@@ -0,0 +1,8 @@
+#ifndef _ASM_M32R_CACHE_H
+#define _ASM_M32R_CACHE_H
+
+/* L1 cache line size */
+#define L1_CACHE_SHIFT		4
+#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
+
+#endif  /* _ASM_M32R_CACHE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/cachectl.h linux-2.6.30-rc3/arch/m32r/include/asm/cachectl.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/cachectl.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/cachectl.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,26 @@
+/*
+ * cachectl.h -- defines for M32R cache control system calls
+ *
+ * Copyright (C) 2003 by Kazuhiro Inaoka
+ */
+#ifndef	__ASM_M32R_CACHECTL
+#define	__ASM_M32R_CACHECTL
+
+/*
+ * Options for cacheflush system call
+ *
+ * cacheflush() is currently fluch_cache_all().
+ */
+#define	ICACHE	(1<<0)		/* flush instruction cache        */
+#define	DCACHE	(1<<1)		/* writeback and flush data cache */
+#define	BCACHE	(ICACHE|DCACHE)	/* flush both caches              */
+
+/*
+ * Caching modes for the cachectl(2) call
+ *
+ * cachectl(2) is currently not supported and returns ENOSYS.
+ */
+#define CACHEABLE	0	/* make pages cacheable */
+#define UNCACHEABLE	1	/* make pages uncacheable */
+
+#endif	/* __ASM_M32R_CACHECTL */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/cacheflush.h linux-2.6.30-rc3/arch/m32r/include/asm/cacheflush.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/cacheflush.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/cacheflush.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,69 @@
+#ifndef _ASM_M32R_CACHEFLUSH_H
+#define _ASM_M32R_CACHEFLUSH_H
+
+#include <linux/mm.h>
+
+extern void _flush_cache_all(void);
+extern void _flush_cache_copyback_all(void);
+
+#if defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_OPSP) || defined(CONFIG_CHIP_M32104)
+#define flush_cache_all()			do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_dup_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#ifndef CONFIG_SMP
+#define flush_icache_range(start, end)		_flush_cache_copyback_all()
+#define flush_icache_page(vma,pg)		_flush_cache_copyback_all()
+#define flush_icache_user_range(vma,pg,adr,len)	_flush_cache_copyback_all()
+#define flush_cache_sigtramp(addr)		_flush_cache_copyback_all()
+#else	/* CONFIG_SMP */
+extern void smp_flush_cache_all(void);
+#define flush_icache_range(start, end)		smp_flush_cache_all()
+#define flush_icache_page(vma,pg)		smp_flush_cache_all()
+#define flush_icache_user_range(vma,pg,adr,len)	smp_flush_cache_all()
+#define flush_cache_sigtramp(addr)		_flush_cache_copyback_all()
+#endif	/* CONFIG_SMP */
+#elif defined(CONFIG_CHIP_M32102)
+#define flush_cache_all()			do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_dup_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#define flush_icache_range(start, end)		_flush_cache_all()
+#define flush_icache_page(vma,pg)		_flush_cache_all()
+#define flush_icache_user_range(vma,pg,adr,len)	_flush_cache_all()
+#define flush_cache_sigtramp(addr)		_flush_cache_all()
+#else
+#define flush_cache_all()			do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_dup_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#define flush_icache_range(start, end)		do { } while (0)
+#define flush_icache_page(vma,pg)		do { } while (0)
+#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
+#define flush_cache_sigtramp(addr)		do { } while (0)
+#endif	/* CONFIG_CHIP_* */
+
+#define flush_cache_vmap(start, end)	do { } while (0)
+#define flush_cache_vunmap(start, end)	do { } while (0)
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len)	\
+do {								\
+	memcpy(dst, src, len);					\
+	flush_icache_user_range(vma, page, vaddr, len);		\
+} while (0)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len)	\
+	memcpy(dst, src, len)
+
+#endif /* _ASM_M32R_CACHEFLUSH_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/checksum.h linux-2.6.30-rc3/arch/m32r/include/asm/checksum.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/checksum.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/checksum.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,204 @@
+#ifdef __KERNEL__
+#ifndef _ASM_M32R_CHECKSUM_H
+#define _ASM_M32R_CHECKSUM_H
+
+/*
+ * include/asm-m32r/checksum.h
+ *
+ * IP/TCP/UDP checksum routines
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Some code taken from mips and parisc architecture.
+ *
+ *    Copyright (C) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata
+ *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#include <linux/in6.h>
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+asmlinkage __wsum csum_partial(const void *buff, int len, __wsum sum);
+
+/*
+ * The same as csum_partial, but copies from src while it checksums.
+ *
+ * Here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+extern __wsum csum_partial_copy_nocheck(const void *src, void *dst,
+                                              int len, __wsum sum);
+
+/*
+ * This is a new version of the above that records errors it finds in *errp,
+ * but continues and zeros thre rest of the buffer.
+ */
+extern __wsum csum_partial_copy_from_user(const void __user *src, void *dst,
+                                                int len, __wsum sum,
+                                                int *err_ptr);
+
+/*
+ *	Fold a partial checksum
+ */
+
+static inline __sum16 csum_fold(__wsum sum)
+{
+	unsigned long tmpreg;
+	__asm__(
+		"	sll3	%1, %0, #16 \n"
+		"	cmp	%0, %0 \n"
+		"	addx	%0, %1 \n"
+		"	ldi	%1, #0 \n"
+		"	srli	%0, #16 \n"
+		"	addx	%0, %1 \n"
+		"	xor3	%0, %0, #0x0000ffff \n"
+		: "=r" (sum), "=&r" (tmpreg)
+		: "0"  (sum)
+		: "cbit"
+	);
+	return (__force __sum16)sum;
+}
+
+/*
+ * This is a version of ip_compute_csum() optimized for IP headers,
+ * which always checksum on 4 octet boundaries.
+ */
+static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+{
+	unsigned long tmpreg0, tmpreg1;
+	__wsum sum;
+
+	__asm__ __volatile__(
+		"	ld	%0, @%1+ \n"
+		"	addi	%2, #-4 \n"
+		"#	bgez	%2, 2f \n"
+		"	cmp	%0, %0 \n"
+		"	ld	%3, @%1+ \n"
+		"	ld	%4, @%1+ \n"
+		"	addx	%0, %3 \n"
+		"	ld	%3, @%1+ \n"
+		"	addx	%0, %4 \n"
+		"	addx	%0, %3 \n"
+		"	.fillinsn\n"
+		"1: \n"
+		"	ld	%4, @%1+ \n"
+		"	addi	%2, #-1 \n"
+		"	addx	%0, %4 \n"
+		"	bgtz	%2, 1b \n"
+		"\n"
+		"	ldi	%3, #0 \n"
+		"	addx	%0, %3 \n"
+		"	.fillinsn\n"
+		"2: \n"
+	/* Since the input registers which are loaded with iph and ihl
+	   are modified, we must also specify them as outputs, or gcc
+	   will assume they contain their original values. */
+	: "=&r" (sum), "=r" (iph), "=r" (ihl), "=&r" (tmpreg0), "=&r" (tmpreg1)
+	: "1" (iph), "2" (ihl)
+	: "cbit", "memory");
+
+	return csum_fold(sum);
+}
+
+static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
+					       unsigned short len,
+					       unsigned short proto,
+					       __wsum sum)
+{
+#if defined(__LITTLE_ENDIAN)
+	unsigned long len_proto = (proto + len) << 8;
+#else
+	unsigned long len_proto = proto + len;
+#endif
+	unsigned long tmpreg;
+
+	__asm__(
+		"	cmp	%0, %0 \n"
+		"	addx	%0, %2 \n"
+		"	addx	%0, %3 \n"
+		"	addx	%0, %4 \n"
+		"	ldi	%1, #0 \n"
+		"	addx	%0, %1 \n"
+		: "=r" (sum), "=&r" (tmpreg)
+		: "r" (daddr), "r" (saddr), "r" (len_proto), "0" (sum)
+		: "cbit"
+	);
+
+	return sum;
+}
+
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
+						   unsigned short len,
+						   unsigned short proto,
+						   __wsum sum)
+{
+	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+
+static inline __sum16 ip_compute_csum(const void *buff, int len)
+{
+	return csum_fold (csum_partial(buff, len, 0));
+}
+
+#define _HAVE_ARCH_IPV6_CSUM
+static inline __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
+				      const struct in6_addr *daddr,
+				      __u32 len, unsigned short proto,
+				      __wsum sum)
+{
+	unsigned long tmpreg0, tmpreg1, tmpreg2, tmpreg3;
+	__asm__(
+		"	ld	%1, @(%5) \n"
+		"	ld	%2, @(4,%5) \n"
+		"	ld	%3, @(8,%5) \n"
+		"	ld	%4, @(12,%5) \n"
+		"	add	%0, %1 \n"
+		"	addx	%0, %2 \n"
+		"	addx	%0, %3 \n"
+		"	addx	%0, %4 \n"
+		"	ld	%1, @(%6) \n"
+		"	ld	%2, @(4,%6) \n"
+		"	ld	%3, @(8,%6) \n"
+		"	ld	%4, @(12,%6) \n"
+		"	addx	%0, %1 \n"
+		"	addx	%0, %2 \n"
+		"	addx	%0, %3 \n"
+		"	addx	%0, %4 \n"
+		"	addx	%0, %7 \n"
+		"	addx	%0, %8 \n"
+		"	ldi	%1, #0 \n"
+		"	addx	%0, %1 \n"
+		: "=&r" (sum), "=&r" (tmpreg0), "=&r" (tmpreg1),
+		  "=&r" (tmpreg2), "=&r" (tmpreg3)
+		: "r" (saddr), "r" (daddr),
+		  "r" (htonl(len)), "r" (htonl(proto)), "0" (sum)
+		: "cbit"
+	);
+
+	return csum_fold(sum);
+}
+
+#endif /* _ASM_M32R_CHECKSUM_H */
+#endif /* __KERNEL__ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/cputime.h linux-2.6.30-rc3/arch/m32r/include/asm/cputime.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/cputime.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/cputime.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,6 @@
+#ifndef __M32R_CPUTIME_H
+#define __M32R_CPUTIME_H
+
+#include <asm-generic/cputime.h>
+
+#endif /* __M32R_CPUTIME_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/current.h linux-2.6.30-rc3/arch/m32r/include/asm/current.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/current.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/current.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,15 @@
+#ifndef _ASM_M32R_CURRENT_H
+#define _ASM_M32R_CURRENT_H
+
+#include <linux/thread_info.h>
+
+struct task_struct;
+
+static __inline__ struct task_struct *get_current(void)
+{
+	return current_thread_info()->task;
+}
+
+#define current	(get_current())
+
+#endif	/* _ASM_M32R_CURRENT_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/delay.h linux-2.6.30-rc3/arch/m32r/include/asm/delay.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/delay.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/delay.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,26 @@
+#ifndef _ASM_M32R_DELAY_H
+#define _ASM_M32R_DELAY_H
+
+/*
+ * Copyright (C) 1993 Linus Torvalds
+ *
+ * Delay routines calling functions in arch/m32r/lib/delay.c
+ */
+
+extern void __bad_udelay(void);
+extern void __bad_ndelay(void);
+
+extern void __udelay(unsigned long usecs);
+extern void __ndelay(unsigned long nsecs);
+extern void __const_udelay(unsigned long xloops);
+extern void __delay(unsigned long loops);
+
+#define udelay(n) (__builtin_constant_p(n) ? \
+	((n) > 20000 ? __bad_udelay() : __const_udelay((n) * 0x10c7ul)) : \
+	__udelay(n))
+
+#define ndelay(n) (__builtin_constant_p(n) ? \
+	((n) > 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
+	__ndelay(n))
+
+#endif /* _ASM_M32R_DELAY_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/device.h linux-2.6.30-rc3/arch/m32r/include/asm/device.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/device.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/device.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,7 @@
+/*
+ * Arch specific extensions to struct device
+ *
+ * This file is released under the GPLv2
+ */
+#include <asm-generic/device.h>
+
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/div64.h linux-2.6.30-rc3/arch/m32r/include/asm/div64.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/div64.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/div64.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1 @@
+#include <asm-generic/div64.h>
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/dma.h linux-2.6.30-rc3/arch/m32r/include/asm/dma.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/dma.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/dma.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,12 @@
+#ifndef _ASM_M32R_DMA_H
+#define _ASM_M32R_DMA_H
+
+#include <asm/io.h>
+
+/*
+ * The maximum address that we can perform a DMA transfer
+ * to on this platform
+ */
+#define MAX_DMA_ADDRESS      (PAGE_OFFSET+0x20000000)
+
+#endif /* _ASM_M32R_DMA_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/elf.h linux-2.6.30-rc3/arch/m32r/include/asm/elf.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/elf.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/elf.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,134 @@
+#ifndef _ASM_M32R__ELF_H
+#define _ASM_M32R__ELF_H
+
+/*
+ * ELF-specific definitions.
+ *
+ * Copyright (C) 1999-2004, Renesas Technology Corp.
+ *      Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#include <asm/ptrace.h>
+#include <asm/user.h>
+#include <asm/page.h>
+
+/* M32R relocation types  */
+#define	R_M32R_NONE		0
+#define	R_M32R_16		1
+#define	R_M32R_32		2
+#define	R_M32R_24		3
+#define	R_M32R_10_PCREL		4
+#define	R_M32R_18_PCREL		5
+#define	R_M32R_26_PCREL		6
+#define	R_M32R_HI16_ULO		7
+#define	R_M32R_HI16_SLO		8
+#define	R_M32R_LO16		9
+#define	R_M32R_SDA16		10
+#define	R_M32R_GNU_VTINHERIT	11
+#define	R_M32R_GNU_VTENTRY	12
+
+#define R_M32R_16_RELA		33
+#define R_M32R_32_RELA		34
+#define R_M32R_24_RELA		35
+#define R_M32R_10_PCREL_RELA	36
+#define R_M32R_18_PCREL_RELA	37
+#define R_M32R_26_PCREL_RELA	38
+#define R_M32R_HI16_ULO_RELA	39
+#define R_M32R_HI16_SLO_RELA	40
+#define R_M32R_LO16_RELA	41
+#define R_M32R_SDA16_RELA	42
+#define	R_M32R_RELA_GNU_VTINHERIT	43
+#define	R_M32R_RELA_GNU_VTENTRY	44
+
+#define R_M32R_GOT24		48
+#define R_M32R_26_PLTREL	49
+#define R_M32R_COPY		50
+#define R_M32R_GLOB_DAT		51
+#define R_M32R_JMP_SLOT		52
+#define R_M32R_RELATIVE		53
+#define R_M32R_GOTOFF		54
+#define R_M32R_GOTPC24		55
+#define R_M32R_GOT16_HI_ULO	56
+#define R_M32R_GOT16_HI_SLO	57
+#define R_M32R_GOT16_LO		58
+#define R_M32R_GOTPC_HI_ULO	59
+#define R_M32R_GOTPC_HI_SLO	60
+#define R_M32R_GOTPC_LO		61
+#define R_M32R_GOTOFF_HI_ULO	62
+#define R_M32R_GOTOFF_HI_SLO	63
+#define R_M32R_GOTOFF_LO	64
+
+#define R_M32R_NUM		256
+
+/*
+ * ELF register definitions..
+ */
+#define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))
+
+typedef unsigned long elf_greg_t;
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* We have no FP mumumu.  */
+typedef double elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t;
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) \
+	(((x)->e_machine == EM_M32R) || ((x)->e_machine == EM_CYGNUS_M32R))
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#if defined(__LITTLE_ENDIAN)
+#define ELF_DATA	ELFDATA2LSB
+#elif defined(__BIG_ENDIAN)
+#define ELF_DATA	ELFDATA2MSB
+#else
+#error no endian defined
+#endif
+#define ELF_ARCH	EM_M32R
+
+/* r0 is set by ld.so to a pointer to a function which might be
+ * registered using 'atexit'.  This provides a mean for the dynamic
+ * linker to call DT_FINI functions for shared libraries that have
+ * been loaded before the code runs.
+ *
+ * So that we can use the same startup file with static executables,
+ * we start programs with a value of 0 to indicate that there is no
+ * such function.
+ */
+#define ELF_PLAT_INIT(_r, load_addr)	(_r)->r0 = 0
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	PAGE_SIZE
+
+/*
+ * This is the location that an ET_DYN program is loaded if exec'ed.
+ * Typical use of this is to invoke "./ld.so someprog" to test out a
+ * new version of the loader.  We need to make sure that it is out of
+ * the way of the program that it will "exec", and that there is
+ * sufficient room for the brk.
+ */
+#define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+
+/* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
+   now struct_user_regs, they are different) */
+
+#define ELF_CORE_COPY_REGS(pr_reg, regs)  \
+	memcpy((char *)pr_reg, (char *)regs, sizeof (struct pt_regs));
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this CPU supports.  */
+#define ELF_HWCAP	(0)
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.  */
+#define ELF_PLATFORM	(NULL)
+
+#define SET_PERSONALITY(ex) set_personality(PER_LINUX)
+
+#endif  /* _ASM_M32R__ELF_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/emergency-restart.h linux-2.6.30-rc3/arch/m32r/include/asm/emergency-restart.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/emergency-restart.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/emergency-restart.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_EMERGENCY_RESTART_H
+#define _ASM_EMERGENCY_RESTART_H
+
+#include <asm-generic/emergency-restart.h>
+
+#endif /* _ASM_EMERGENCY_RESTART_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/errno.h linux-2.6.30-rc3/arch/m32r/include/asm/errno.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/errno.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/errno.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_M32R_ERRNO_H
+#define _ASM_M32R_ERRNO_H
+
+#include <asm-generic/errno.h>
+
+#endif /* _ASM_M32R_ERRNO_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/fb.h linux-2.6.30-rc3/arch/m32r/include/asm/fb.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/fb.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/fb.h	2009-04-22 03:29:16.266723428 +0000
@@ -0,0 +1,19 @@
+#ifndef _ASM_FB_H_
+#define _ASM_FB_H_
+
+#include <linux/fb.h>
+#include <linux/fs.h>
+#include <asm/page.h>
+
+static inline void fb_pgprotect(struct file *file, struct vm_area_struct *vma,
+				unsigned long off)
+{
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+}
+
+static inline int fb_is_primary_device(struct fb_info *info)
+{
+	return 0;
+}
+
+#endif /* _ASM_FB_H_ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/fcntl.h linux-2.6.30-rc3/arch/m32r/include/asm/fcntl.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/fcntl.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/fcntl.h	2009-04-22 03:29:16.267931548 +0000
@@ -0,0 +1 @@
+#include <asm-generic/fcntl.h>
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/flat.h linux-2.6.30-rc3/arch/m32r/include/asm/flat.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/flat.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/flat.h	2009-04-22 03:29:16.267931548 +0000
@@ -0,0 +1,146 @@
+/*
+ * include/asm-m32r/flat.h
+ *
+ * uClinux flat-format executables
+ *
+ * Copyright (C) 2004  Kazuhiro Inaoka
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive for
+ * more details.
+ */
+#ifndef __ASM_M32R_FLAT_H
+#define __ASM_M32R_FLAT_H
+
+#define	flat_stack_align(sp)		(*sp += (*sp & 3 ? (4 - (*sp & 3)): 0))
+#define	flat_argvp_envp_on_stack()		0
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_set_persistent(relval, p)		0
+#define	flat_reloc_valid(reloc, size)		\
+	(((reloc) - textlen_for_m32r_lo16_data) <= (size))
+#define flat_get_addr_from_rp(rp, relval, flags, persistent) \
+	m32r_flat_get_addr_from_rp(rp, relval, (text_len) )
+
+#define flat_put_addr_at_rp(rp, addr, relval) \
+	m32r_flat_put_addr_at_rp(rp, addr, relval)
+
+/* Convert a relocation entry into an address.  */
+static inline unsigned long
+flat_get_relocate_addr (unsigned long relval)
+{
+        return relval & 0x00ffffff; /* Mask out top 8-bits */
+}
+
+#define	flat_m32r_get_reloc_type(relval)	((relval) >> 24)
+
+#define M32R_SETH_OPCODE	0xd0c00000 /* SETH instruction code */
+
+#define FLAT_M32R_32		0x00	/* 32bits reloc */
+#define FLAT_M32R_24		0x01	/* unsigned 24bits reloc */
+#define FLAT_M32R_16		0x02	/* 16bits reloc */
+#define FLAT_M32R_LO16		0x03	/* signed low 16bits reloc (low()) */
+#define FLAT_M32R_LO16_DATA	0x04	/* signed low 16bits reloc (low())
+					   for a symbol in .data section */
+					/* High 16bits of an address used
+					   when the lower 16bbits are treated
+					   as unsigned.
+                                           To create SETH instruction only.
+					   0x1X: X means a number of register.
+					   0x10 - 0x3F are reserved. */
+#define FLAT_M32R_HI16_ULO	0x10	/* reloc for SETH Rn,#high(imm16) */
+					/* High 16bits of an address used
+					   when the lower 16bbits are treated
+					   as signed.
+                                           To create SETH instruction only.
+					   0x2X: X means a number of register.
+					   0x20 - 0x4F are reserved. */
+#define FLAT_M32R_HI16_SLO	0x20	/* reloc for SETH Rn,#shigh(imm16) */
+
+static unsigned long textlen_for_m32r_lo16_data = 0;
+
+static inline unsigned long m32r_flat_get_addr_from_rp (unsigned long *rp,
+                                                        unsigned long relval,
+						        unsigned long textlen)
+{
+        unsigned int reloc = flat_m32r_get_reloc_type (relval);
+	textlen_for_m32r_lo16_data = 0;
+	if (reloc & 0xf0) {
+		unsigned long addr = htonl(*rp);
+		switch (reloc & 0xf0)
+		{
+		case FLAT_M32R_HI16_ULO:
+		case FLAT_M32R_HI16_SLO:
+			if (addr == 0) {
+				/* put "seth Rn,#0x0" instead of 0 (addr). */
+				*rp = (M32R_SETH_OPCODE | ((reloc & 0x0f)<<24));
+			}
+			return addr;
+		default:
+			break;
+		}
+	} else {
+		switch (reloc)
+		{
+		case FLAT_M32R_LO16:
+			return htonl(*rp) & 0xFFFF;
+		case FLAT_M32R_LO16_DATA:
+                        /* FIXME: The return value will decrease by textlen
+			   at m32r_flat_put_addr_at_rp () */
+			textlen_for_m32r_lo16_data = textlen;
+			return (htonl(*rp) & 0xFFFF) + textlen;
+		case FLAT_M32R_16:
+			return htons(*(unsigned short *)rp) & 0xFFFF;
+		case FLAT_M32R_24:
+			return htonl(*rp) & 0xFFFFFF;
+		case FLAT_M32R_32:
+			return htonl(*rp);
+		default:
+			break;
+		}
+	}
+	return ~0;      /* bogus value */
+}
+
+static inline void m32r_flat_put_addr_at_rp (unsigned long *rp,
+					     unsigned long addr,
+                                             unsigned long relval)
+{
+        unsigned int reloc = flat_m32r_get_reloc_type (relval);
+	if (reloc & 0xf0) {
+		unsigned long Rn = reloc & 0x0f; /* get a number of register */
+		Rn <<= 24; /* 0x0R000000 */
+		reloc &= 0xf0;
+		switch (reloc)
+		{
+		case FLAT_M32R_HI16_ULO: /* To create SETH Rn,#high(imm16) */
+			*rp = (M32R_SETH_OPCODE | Rn
+			       | ((addr >> 16) & 0xFFFF));
+			break;
+		case FLAT_M32R_HI16_SLO: /* To create SETH Rn,#shigh(imm16) */
+			*rp = (M32R_SETH_OPCODE | Rn
+			       | (((addr >> 16) + ((addr & 0x8000) ? 1 : 0))
+				  & 0xFFFF));
+			break;
+		}
+	} else {
+		switch (reloc) {
+		case FLAT_M32R_LO16_DATA:
+			addr -= textlen_for_m32r_lo16_data;
+			textlen_for_m32r_lo16_data = 0;
+		case FLAT_M32R_LO16:
+			*rp = (htonl(*rp) & 0xFFFF0000) | (addr & 0xFFFF);
+			break;
+		case FLAT_M32R_16:
+			*(unsigned short *)rp = addr & 0xFFFF;
+			break;
+		case FLAT_M32R_24:
+			*rp = (htonl(*rp) & 0xFF000000) | (addr & 0xFFFFFF);
+			break;
+		case FLAT_M32R_32:
+			*rp = addr;
+			break;
+		}
+	}
+}
+
+#endif /* __ASM_M32R_FLAT_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/ftrace.h linux-2.6.30-rc3/arch/m32r/include/asm/ftrace.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/ftrace.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/ftrace.h	2009-04-22 03:29:16.267931548 +0000
@@ -0,0 +1 @@
+/* empty */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/futex.h linux-2.6.30-rc3/arch/m32r/include/asm/futex.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/futex.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/futex.h	2009-04-22 03:29:16.267931548 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_FUTEX_H
+#define _ASM_FUTEX_H
+
+#include <asm-generic/futex.h>
+
+#endif
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/hardirq.h linux-2.6.30-rc3/arch/m32r/include/asm/hardirq.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/hardirq.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/hardirq.h	2009-04-22 03:29:16.267931548 +0000
@@ -0,0 +1,36 @@
+#ifdef __KERNEL__
+#ifndef __ASM_HARDIRQ_H
+#define __ASM_HARDIRQ_H
+
+#include <linux/threads.h>
+#include <linux/irq.h>
+
+typedef struct {
+	unsigned int __softirq_pending;
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+#if NR_IRQS > 256
+#define HARDIRQ_BITS	9
+#else
+#define HARDIRQ_BITS	8
+#endif
+
+/*
+ * The hardirq mask has to be large enough to have
+ * space for potentially all IRQ sources in the system
+ * nesting on a single CPU:
+ */
+#if (1 << HARDIRQ_BITS) < NR_IRQS
+# error HARDIRQ_BITS is too low!
+#endif
+
+static inline void ack_bad_irq(int irq)
+{
+	printk(KERN_CRIT "unexpected IRQ trap at vector %02x\n", irq);
+	BUG();
+}
+
+#endif /* __ASM_HARDIRQ_H */
+#endif /* __KERNEL__ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/hw_irq.h linux-2.6.30-rc3/arch/m32r/include/asm/hw_irq.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/hw_irq.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/hw_irq.h	2009-04-22 03:29:16.267931548 +0000
@@ -0,0 +1,4 @@
+#ifndef _ASM_M32R_HW_IRQ_H
+#define _ASM_M32R_HW_IRQ_H
+
+#endif /* _ASM_M32R_HW_IRQ_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/io.h linux-2.6.30-rc3/arch/m32r/include/asm/io.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/io.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/io.h	2009-04-22 03:29:16.267931548 +0000
@@ -0,0 +1,200 @@
+#ifndef _ASM_M32R_IO_H
+#define _ASM_M32R_IO_H
+
+#include <linux/string.h>
+#include <linux/compiler.h>
+#include <asm/page.h>  /* __va */
+
+#ifdef __KERNEL__
+
+#define IO_SPACE_LIMIT  0xFFFFFFFF
+
+/**
+ *	virt_to_phys	-	map virtual addresses to physical
+ *	@address: address to remap
+ *
+ *	The returned physical address is the physical (CPU) mapping for
+ *	the memory address given. It is only valid to use this function on
+ *	addresses directly mapped or allocated via kmalloc.
+ *
+ *	This function does not give bus mappings for DMA transfers. In
+ *	almost all conceivable cases a device driver should not be using
+ *	this function
+ */
+
+static inline unsigned long virt_to_phys(volatile void * address)
+{
+	return __pa(address);
+}
+
+/**
+ *	phys_to_virt	-	map physical address to virtual
+ *	@address: address to remap
+ *
+ *	The returned virtual address is a current CPU mapping for
+ *	the memory address given. It is only valid to use this function on
+ *	addresses that have a kernel mapping
+ *
+ *	This function does not handle bus mappings for DMA transfers. In
+ *	almost all conceivable cases a device driver should not be using
+ *	this function
+ */
+
+static inline void *phys_to_virt(unsigned long address)
+{
+	return __va(address);
+}
+
+extern void __iomem *
+__ioremap(unsigned long offset, unsigned long size, unsigned long flags);
+
+/**
+ *	ioremap		-	map bus memory into CPU space
+ *	@offset:	bus address of the memory
+ *	@size:		size of the resource to map
+ *
+ *	ioremap performs a platform specific sequence of operations to
+ *	make bus memory CPU accessible via the readb/readw/readl/writeb/
+ *	writew/writel functions and the other mmio helpers. The returned
+ *	address is not guaranteed to be usable directly as a virtual
+ *	address.
+ */
+
+static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, 0);
+}
+
+extern void iounmap(volatile void __iomem *addr);
+#define ioremap_nocache(off,size) ioremap(off,size)
+
+/*
+ * IO bus memory addresses are also 1:1 with the physical address
+ */
+#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
+#define page_to_bus	page_to_phys
+#define virt_to_bus	virt_to_phys
+
+extern unsigned char _inb(unsigned long);
+extern unsigned short _inw(unsigned long);
+extern unsigned long _inl(unsigned long);
+extern unsigned char _inb_p(unsigned long);
+extern unsigned short _inw_p(unsigned long);
+extern unsigned long _inl_p(unsigned long);
+extern void _outb(unsigned char, unsigned long);
+extern void _outw(unsigned short, unsigned long);
+extern void _outl(unsigned long, unsigned long);
+extern void _outb_p(unsigned char, unsigned long);
+extern void _outw_p(unsigned short, unsigned long);
+extern void _outl_p(unsigned long, unsigned long);
+extern void _insb(unsigned int, void *, unsigned long);
+extern void _insw(unsigned int, void *, unsigned long);
+extern void _insl(unsigned int, void *, unsigned long);
+extern void _outsb(unsigned int, const void *, unsigned long);
+extern void _outsw(unsigned int, const void *, unsigned long);
+extern void _outsl(unsigned int, const void *, unsigned long);
+
+static inline unsigned char _readb(unsigned long addr)
+{
+	return *(volatile unsigned char __force *)addr;
+}
+
+static inline unsigned short _readw(unsigned long addr)
+{
+	return *(volatile unsigned short __force *)addr;
+}
+
+static inline unsigned long _readl(unsigned long addr)
+{
+	return *(volatile unsigned long __force *)addr;
+}
+
+static inline void _writeb(unsigned char b, unsigned long addr)
+{
+	*(volatile unsigned char __force *)addr = b;
+}
+
+static inline void _writew(unsigned short w, unsigned long addr)
+{
+	*(volatile unsigned short __force *)addr = w;
+}
+
+static inline void _writel(unsigned long l, unsigned long addr)
+{
+	*(volatile unsigned long __force *)addr = l;
+}
+
+#define inb     _inb
+#define inw     _inw
+#define inl     _inl
+#define outb    _outb
+#define outw    _outw
+#define outl    _outl
+
+#define inb_p   _inb_p
+#define inw_p   _inw_p
+#define inl_p   _inl_p
+#define outb_p  _outb_p
+#define outw_p  _outw_p
+#define outl_p  _outl_p
+
+#define insb    _insb
+#define insw    _insw
+#define insl    _insl
+#define outsb   _outsb
+#define outsw   _outsw
+#define outsl   _outsl
+
+#define readb(addr)   _readb((unsigned long)(addr))
+#define readw(addr)   _readw((unsigned long)(addr))
+#define readl(addr)   _readl((unsigned long)(addr))
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+#define readb_relaxed readb
+#define readw_relaxed readw
+#define readl_relaxed readl
+
+#define writeb(val, addr)  _writeb((val), (unsigned long)(addr))
+#define writew(val, addr)  _writew((val), (unsigned long)(addr))
+#define writel(val, addr)  _writel((val), (unsigned long)(addr))
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+
+#define mmiowb()
+
+#define flush_write_buffers() do { } while (0)  /* M32R_FIXME */
+
+static inline void
+memset_io(volatile void __iomem *addr, unsigned char val, int count)
+{
+	memset((void __force *) addr, val, count);
+}
+
+static inline void
+memcpy_fromio(void *dst, volatile void __iomem *src, int count)
+{
+	memcpy(dst, (void __force *) src, count);
+}
+
+static inline void
+memcpy_toio(volatile void __iomem *dst, const void *src, int count)
+{
+	memcpy((void __force *) dst, src, count);
+}
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+#endif  /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_IO_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/ioctl.h linux-2.6.30-rc3/arch/m32r/include/asm/ioctl.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/ioctl.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/ioctl.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1 @@
+#include <asm-generic/ioctl.h>
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/ioctls.h linux-2.6.30-rc3/arch/m32r/include/asm/ioctls.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/ioctls.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/ioctls.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1,87 @@
+#ifndef __ARCH_M32R_IOCTLS_H__
+#define __ARCH_M32R_IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402 /* Clashes with SNDCTL_TMR_START sound ioctl */
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+/* #define TIOCTTYGSTRUCT 0x5426 - Former debugging-only ioctl */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TCGETS2		_IOR('T',0x2A, struct termios2)
+#define TCSETS2		_IOW('T',0x2B, struct termios2)
+#define TCSETSW2	_IOW('T',0x2C, struct termios2)
+#define TCSETSF2	_IOW('T',0x2D, struct termios2)
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define TIOCGHAYESESP   0x545E  /* Get Hayes ESP configuration */
+#define TIOCSHAYESESP   0x545F  /* Set Hayes ESP configuration */
+#define FIOQSIZE	0x5460
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+#endif /* __ARCH_M32R_IOCTLS_H__ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/ipcbuf.h linux-2.6.30-rc3/arch/m32r/include/asm/ipcbuf.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/ipcbuf.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/ipcbuf.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1,29 @@
+#ifndef _ASM_M32R_IPCBUF_H
+#define _ASM_M32R_IPCBUF_H
+
+/*
+ * The ipc64_perm structure for m32r architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t and seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm
+{
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+	unsigned short		__pad1;
+	unsigned short		seq;
+	unsigned short		__pad2;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* _ASM_M32R_IPCBUF_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/irq.h linux-2.6.30-rc3/arch/m32r/include/asm/irq.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/irq.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/irq.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1,90 @@
+#ifdef __KERNEL__
+#ifndef _ASM_M32R_IRQ_H
+#define _ASM_M32R_IRQ_H
+
+
+#if defined(CONFIG_PLAT_USRV)
+/*
+ * IRQ definitions for M32700UT
+ *  M32700 Chip: 64 interrupts
+ *  ICU of M32700UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
+ */
+#define	M32700UT_NUM_CPU_IRQ	(64)
+#define M32700UT_NUM_PLD_IRQ	(32)
+#define M32700UT_IRQ_BASE	0
+#define M32700UT_CPU_IRQ_BASE	M32700UT_IRQ_BASE
+#define M32700UT_PLD_IRQ_BASE	(M32700UT_CPU_IRQ_BASE + M32700UT_NUM_CPU_IRQ)
+
+#define NR_IRQS	(M32700UT_NUM_CPU_IRQ + M32700UT_NUM_PLD_IRQ)
+#elif defined(CONFIG_PLAT_M32700UT)
+/*
+ * IRQ definitions for M32700UT(Rev.C) + M32R-LAN
+ *  M32700 Chip: 64 interrupts
+ *  ICU of M32700UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
+ *  ICU of M32R-LCD-on-board PLD: 32 interrupts cascaded to INT2# chip pin
+ *  ICU of M32R-LAN-on-board PLD: 32 interrupts cascaded to INT0# chip pin
+ */
+#define M32700UT_NUM_CPU_IRQ		(64)
+#define M32700UT_NUM_PLD_IRQ		(32)
+#define M32700UT_NUM_LCD_PLD_IRQ	(32)
+#define M32700UT_NUM_LAN_PLD_IRQ	(32)
+#define M32700UT_IRQ_BASE		0
+#define M32700UT_CPU_IRQ_BASE		(M32700UT_IRQ_BASE)
+#define M32700UT_PLD_IRQ_BASE \
+	(M32700UT_CPU_IRQ_BASE + M32700UT_NUM_CPU_IRQ)
+#define M32700UT_LCD_PLD_IRQ_BASE \
+	(M32700UT_PLD_IRQ_BASE + M32700UT_NUM_PLD_IRQ)
+#define M32700UT_LAN_PLD_IRQ_BASE \
+	(M32700UT_LCD_PLD_IRQ_BASE + M32700UT_NUM_LCD_PLD_IRQ)
+
+#define NR_IRQS \
+	(M32700UT_NUM_CPU_IRQ + M32700UT_NUM_PLD_IRQ \
+	+ M32700UT_NUM_LCD_PLD_IRQ + M32700UT_NUM_LAN_PLD_IRQ)
+#elif defined(CONFIG_PLAT_OPSPUT)
+/*
+ * IRQ definitions for OPSPUT + M32R-LAN
+ *  OPSP Chip: 64 interrupts
+ *  ICU of OPSPUT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
+ *  ICU of M32R-LCD-on-board PLD: 32 interrupts cascaded to INT2# chip pin
+ *  ICU of M32R-LAN-on-board PLD: 32 interrupts cascaded to INT0# chip pin
+ */
+#define OPSPUT_NUM_CPU_IRQ		(64)
+#define OPSPUT_NUM_PLD_IRQ		(32)
+#define OPSPUT_NUM_LCD_PLD_IRQ	(32)
+#define OPSPUT_NUM_LAN_PLD_IRQ	(32)
+#define OPSPUT_IRQ_BASE		0
+#define OPSPUT_CPU_IRQ_BASE		(OPSPUT_IRQ_BASE)
+#define OPSPUT_PLD_IRQ_BASE \
+	(OPSPUT_CPU_IRQ_BASE + OPSPUT_NUM_CPU_IRQ)
+#define OPSPUT_LCD_PLD_IRQ_BASE \
+	(OPSPUT_PLD_IRQ_BASE + OPSPUT_NUM_PLD_IRQ)
+#define OPSPUT_LAN_PLD_IRQ_BASE \
+	(OPSPUT_LCD_PLD_IRQ_BASE + OPSPUT_NUM_LCD_PLD_IRQ)
+
+#define NR_IRQS \
+	(OPSPUT_NUM_CPU_IRQ + OPSPUT_NUM_PLD_IRQ \
+	+ OPSPUT_NUM_LCD_PLD_IRQ + OPSPUT_NUM_LAN_PLD_IRQ)
+
+#elif defined(CONFIG_PLAT_M32104UT)
+/*
+ * IRQ definitions for M32104UT
+ *  M32104 Chip: 64 interrupts
+ *  ICU of M32104UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
+ */
+#define	M32104UT_NUM_CPU_IRQ	(64)
+#define M32104UT_NUM_PLD_IRQ	(32)
+#define M32104UT_IRQ_BASE	0
+#define M32104UT_CPU_IRQ_BASE	M32104UT_IRQ_BASE
+#define M32104UT_PLD_IRQ_BASE	(M32104UT_CPU_IRQ_BASE + M32104UT_NUM_CPU_IRQ)
+
+#define NR_IRQS	\
+    (M32104UT_NUM_CPU_IRQ + M32104UT_NUM_PLD_IRQ)
+
+#else
+#define NR_IRQS	64
+#endif
+
+#define irq_canonicalize(irq)	(irq)
+
+#endif /* _ASM_M32R_IRQ_H */
+#endif /* __KERNEL__ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/irq_regs.h linux-2.6.30-rc3/arch/m32r/include/asm/irq_regs.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/irq_regs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/irq_regs.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1 @@
+#include <asm-generic/irq_regs.h>
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/kdebug.h linux-2.6.30-rc3/arch/m32r/include/asm/kdebug.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/kdebug.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/kdebug.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1 @@
+#include <asm-generic/kdebug.h>
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/kmap_types.h linux-2.6.30-rc3/arch/m32r/include/asm/kmap_types.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/kmap_types.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/kmap_types.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1,29 @@
+#ifndef __M32R_KMAP_TYPES_H
+#define __M32R_KMAP_TYPES_H
+
+#ifdef CONFIG_DEBUG_HIGHMEM
+# define D(n) __KM_FENCE_##n ,
+#else
+# define D(n)
+#endif
+
+enum km_type {
+D(0)	KM_BOUNCE_READ,
+D(1)	KM_SKB_SUNRPC_DATA,
+D(2)	KM_SKB_DATA_SOFTIRQ,
+D(3)	KM_USER0,
+D(4)	KM_USER1,
+D(5)	KM_BIO_SRC_IRQ,
+D(6)	KM_BIO_DST_IRQ,
+D(7)	KM_PTE0,
+D(8)	KM_PTE1,
+D(9)	KM_IRQ0,
+D(10)	KM_IRQ1,
+D(11)	KM_SOFTIRQ0,
+D(12)	KM_SOFTIRQ1,
+D(13)	KM_TYPE_NR
+};
+
+#undef D
+
+#endif /* __M32R_KMAP_TYPES_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/linkage.h linux-2.6.30-rc3/arch/m32r/include/asm/linkage.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/linkage.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/linkage.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1,7 @@
+#ifndef __ASM_LINKAGE_H
+#define __ASM_LINKAGE_H
+
+#define __ALIGN		.balign 4
+#define __ALIGN_STR	".balign 4"
+
+#endif /* __ASM_LINKAGE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/local.h linux-2.6.30-rc3/arch/m32r/include/asm/local.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/local.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/local.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1,366 @@
+#ifndef __M32R_LOCAL_H
+#define __M32R_LOCAL_H
+
+/*
+ *  linux/include/asm-m32r/local.h
+ *
+ *  M32R version:
+ *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
+ *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ *    Copyright (C) 2007  Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ */
+
+#include <linux/percpu.h>
+#include <asm/assembler.h>
+#include <asm/system.h>
+#include <asm/local.h>
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ */
+
+/*
+ * Make sure gcc doesn't try to be clever and move things around
+ * on us. We need to use _exactly_ the address the user gave us,
+ * not some alias that contains the same information.
+ */
+typedef struct { volatile int counter; } local_t;
+
+#define LOCAL_INIT(i)	{ (i) }
+
+/**
+ * local_read - read local variable
+ * @l: pointer of type local_t
+ *
+ * Atomically reads the value of @l.
+ */
+#define local_read(l)	((l)->counter)
+
+/**
+ * local_set - set local variable
+ * @l: pointer of type local_t
+ * @i: required value
+ *
+ * Atomically sets the value of @l to @i.
+ */
+#define local_set(l, i)	(((l)->counter) = (i))
+
+/**
+ * local_add_return - add long to local variable and return it
+ * @i: long value to add
+ * @l: pointer of type local_t
+ *
+ * Atomically adds @i to @l and return (@i + @l).
+ */
+static inline long local_add_return(long i, local_t *l)
+{
+	unsigned long flags;
+	long result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# local_add_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		"ld %0, @%1;			\n\t"
+		"add	%0, %2;			\n\t"
+		"st %0, @%1;			\n\t"
+		: "=&r" (result)
+		: "r" (&l->counter), "r" (i)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * local_sub_return - subtract long from local variable and return it
+ * @i: long value to subtract
+ * @l: pointer of type local_t
+ *
+ * Atomically subtracts @i from @l and return (@l - @i).
+ */
+static inline long local_sub_return(long i, local_t *l)
+{
+	unsigned long flags;
+	long result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# local_sub_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		"ld %0, @%1;			\n\t"
+		"sub	%0, %2;			\n\t"
+		"st %0, @%1;			\n\t"
+		: "=&r" (result)
+		: "r" (&l->counter), "r" (i)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * local_add - add long to local variable
+ * @i: long value to add
+ * @l: pointer of type local_t
+ *
+ * Atomically adds @i to @l.
+ */
+#define local_add(i, l) ((void) local_add_return((i), (l)))
+
+/**
+ * local_sub - subtract the local variable
+ * @i: long value to subtract
+ * @l: pointer of type local_t
+ *
+ * Atomically subtracts @i from @l.
+ */
+#define local_sub(i, l) ((void) local_sub_return((i), (l)))
+
+/**
+ * local_sub_and_test - subtract value from variable and test result
+ * @i: integer value to subtract
+ * @l: pointer of type local_t
+ *
+ * Atomically subtracts @i from @l and returns
+ * true if the result is zero, or false for all
+ * other cases.
+ */
+#define local_sub_and_test(i, l) (local_sub_return((i), (l)) == 0)
+
+/**
+ * local_inc_return - increment local variable and return it
+ * @l: pointer of type local_t
+ *
+ * Atomically increments @l by 1 and returns the result.
+ */
+static inline long local_inc_return(local_t *l)
+{
+	unsigned long flags;
+	long result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# local_inc_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		"ld %0, @%1;			\n\t"
+		"addi	%0, #1;			\n\t"
+		"st %0, @%1;			\n\t"
+		: "=&r" (result)
+		: "r" (&l->counter)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * local_dec_return - decrement local variable and return it
+ * @l: pointer of type local_t
+ *
+ * Atomically decrements @l by 1 and returns the result.
+ */
+static inline long local_dec_return(local_t *l)
+{
+	unsigned long flags;
+	long result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# local_dec_return		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		"ld %0, @%1;			\n\t"
+		"addi	%0, #-1;		\n\t"
+		"st %0, @%1;			\n\t"
+		: "=&r" (result)
+		: "r" (&l->counter)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return result;
+}
+
+/**
+ * local_inc - increment local variable
+ * @l: pointer of type local_t
+ *
+ * Atomically increments @l by 1.
+ */
+#define local_inc(l) ((void)local_inc_return(l))
+
+/**
+ * local_dec - decrement local variable
+ * @l: pointer of type local_t
+ *
+ * Atomically decrements @l by 1.
+ */
+#define local_dec(l) ((void)local_dec_return(l))
+
+/**
+ * local_inc_and_test - increment and test
+ * @l: pointer of type local_t
+ *
+ * Atomically increments @l by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+#define local_inc_and_test(l) (local_inc_return(l) == 0)
+
+/**
+ * local_dec_and_test - decrement and test
+ * @l: pointer of type local_t
+ *
+ * Atomically decrements @l by 1 and
+ * returns true if the result is 0, or false for all
+ * other cases.
+ */
+#define local_dec_and_test(l) (local_dec_return(l) == 0)
+
+/**
+ * local_add_negative - add and test if negative
+ * @l: pointer of type local_t
+ * @i: integer value to add
+ *
+ * Atomically adds @i to @l and returns true
+ * if the result is negative, or false when
+ * result is greater than or equal to zero.
+ */
+#define local_add_negative(i, l) (local_add_return((i), (l)) < 0)
+
+#define local_cmpxchg(l, o, n) (cmpxchg_local(&((l)->counter), (o), (n)))
+#define local_xchg(v, new) (xchg_local(&((l)->counter), new))
+
+/**
+ * local_add_unless - add unless the number is a given value
+ * @l: pointer of type local_t
+ * @a: the amount to add to l...
+ * @u: ...unless l is equal to u.
+ *
+ * Atomically adds @a to @l, so long as it was not @u.
+ * Returns non-zero if @l was not @u, and zero otherwise.
+ */
+static inline int local_add_unless(local_t *l, long a, long u)
+{
+	long c, old;
+	c = local_read(l);
+	for (;;) {
+		if (unlikely(c == (u)))
+			break;
+		old = local_cmpxchg((l), c, c + (a));
+		if (likely(old == c))
+			break;
+		c = old;
+	}
+	return c != (u);
+}
+
+#define local_inc_not_zero(l) local_add_unless((l), 1, 0)
+
+static inline void local_clear_mask(unsigned long  mask, local_t *addr)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# local_clear_mask		\n\t"
+		DCACHE_CLEAR("%0", "r5", "%1")
+		"ld %0, @%1;			\n\t"
+		"and	%0, %2;			\n\t"
+		"st %0, @%1;			\n\t"
+		: "=&r" (tmp)
+		: "r" (addr), "r" (~mask)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+static inline void local_set_mask(unsigned long  mask, local_t *addr)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# local_set_mask		\n\t"
+		DCACHE_CLEAR("%0", "r5", "%1")
+		"ld %0, @%1;			\n\t"
+		"or	%0, %2;			\n\t"
+		"st %0, @%1;			\n\t"
+		: "=&r" (tmp)
+		: "r" (addr), "r" (mask)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/* Atomic operations are already serializing on m32r */
+#define smp_mb__before_local_dec()	barrier()
+#define smp_mb__after_local_dec()	barrier()
+#define smp_mb__before_local_inc()	barrier()
+#define smp_mb__after_local_inc()	barrier()
+
+/* Use these for per-cpu local_t variables: on some archs they are
+ * much more efficient than these naive implementations.  Note they take
+ * a variable, not an address.
+ */
+
+#define __local_inc(l)		((l)->a.counter++)
+#define __local_dec(l)		((l)->a.counter++)
+#define __local_add(i, l)	((l)->a.counter += (i))
+#define __local_sub(i, l)	((l)->a.counter -= (i))
+
+/* Use these for per-cpu local_t variables: on some archs they are
+ * much more efficient than these naive implementations.  Note they take
+ * a variable, not an address.
+ */
+
+/* Need to disable preemption for the cpu local counters otherwise we could
+   still access a variable of a previous CPU in a non local way. */
+#define cpu_local_wrap_v(l)	 	\
+	({ local_t res__;		\
+	   preempt_disable(); 		\
+	   res__ = (l);			\
+	   preempt_enable();		\
+	   res__; })
+#define cpu_local_wrap(l)		\
+	({ preempt_disable();		\
+	   l;				\
+	   preempt_enable(); })		\
+
+#define cpu_local_read(l)    cpu_local_wrap_v(local_read(&__get_cpu_var(l)))
+#define cpu_local_set(l, i)  cpu_local_wrap(local_set(&__get_cpu_var(l), (i)))
+#define cpu_local_inc(l)     cpu_local_wrap(local_inc(&__get_cpu_var(l)))
+#define cpu_local_dec(l)     cpu_local_wrap(local_dec(&__get_cpu_var(l)))
+#define cpu_local_add(i, l)  cpu_local_wrap(local_add((i), &__get_cpu_var(l)))
+#define cpu_local_sub(i, l)  cpu_local_wrap(local_sub((i), &__get_cpu_var(l)))
+
+#define __cpu_local_inc(l)	cpu_local_inc(l)
+#define __cpu_local_dec(l)	cpu_local_dec(l)
+#define __cpu_local_add(i, l)	cpu_local_add((i), (l))
+#define __cpu_local_sub(i, l)	cpu_local_sub((i), (l))
+
+#endif /* __M32R_LOCAL_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/m32102.h linux-2.6.30-rc3/arch/m32r/include/asm/m32102.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/m32102.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/m32102.h	2009-04-22 03:29:16.268640383 +0000
@@ -0,0 +1,314 @@
+#ifndef _M32102_H_
+#define _M32102_H_
+
+/*
+ * Renesas M32R 32102 group
+ *
+ * Copyright (c) 2001  Hitoshi Yamamoto
+ * Copyright (c) 2003, 2004  Renesas Technology Corp.
+ */
+
+/*======================================================================*
+ * Special Function Register
+ *======================================================================*/
+#if !defined(CONFIG_CHIP_M32104)
+#define M32R_SFR_OFFSET  (0x00E00000)  /* 0x00E00000-0x00EFFFFF 1[MB] */
+#else
+#define M32R_SFR_OFFSET  (0x00700000)  /* 0x00700000-0x007FFFFF 1[MB] */
+#endif
+
+/*
+ * Clock and Power Management registers.
+ */
+#define M32R_CPM_OFFSET          (0x000F4000+M32R_SFR_OFFSET)
+
+#define M32R_CPM_CPUCLKCR_PORTL  (0x00+M32R_CPM_OFFSET)
+#define M32R_CPM_CLKMOD_PORTL    (0x04+M32R_CPM_OFFSET)
+#define M32R_CPM_PLLCR_PORTL     (0x08+M32R_CPM_OFFSET)
+
+/*
+ * DMA Controller registers.
+ */
+#define M32R_DMA_OFFSET		(0x000F8000+M32R_SFR_OFFSET)
+
+#define M32R_DMAEN_PORTL	(0x000+M32R_DMA_OFFSET)
+#define M32R_DMAISTS_PORTL	(0x004+M32R_DMA_OFFSET)
+#define M32R_DMAEDET_PORTL	(0x008+M32R_DMA_OFFSET)
+#define M32R_DMAASTS_PORTL	(0x00c+M32R_DMA_OFFSET)
+
+#define M32R_DMA0CR0_PORTL	(0x100+M32R_DMA_OFFSET)
+#define M32R_DMA0CR1_PORTL	(0x104+M32R_DMA_OFFSET)
+#define M32R_DMA0CSA_PORTL	(0x108+M32R_DMA_OFFSET)
+#define M32R_DMA0RSA_PORTL	(0x10c+M32R_DMA_OFFSET)
+#define M32R_DMA0CDA_PORTL	(0x110+M32R_DMA_OFFSET)
+#define M32R_DMA0RDA_PORTL	(0x114+M32R_DMA_OFFSET)
+#define M32R_DMA0CBCUT_PORTL	(0x118+M32R_DMA_OFFSET)
+#define M32R_DMA0RBCUT_PORTL	(0x11c+M32R_DMA_OFFSET)
+
+#define M32R_DMA1CR0_PORTL	(0x200+M32R_DMA_OFFSET)
+#define M32R_DMA1CR1_PORTL	(0x204+M32R_DMA_OFFSET)
+#define M32R_DMA1CSA_PORTL	(0x208+M32R_DMA_OFFSET)
+#define M32R_DMA1RSA_PORTL	(0x20c+M32R_DMA_OFFSET)
+#define M32R_DMA1CDA_PORTL	(0x210+M32R_DMA_OFFSET)
+#define M32R_DMA1RDA_PORTL	(0x214+M32R_DMA_OFFSET)
+#define M32R_DMA1CBCUT_PORTL	(0x218+M32R_DMA_OFFSET)
+#define M32R_DMA1RBCUT_PORTL	(0x21c+M32R_DMA_OFFSET)
+
+/*
+ * Multi Function Timer registers.
+ */
+#define M32R_MFT_OFFSET        (0x000FC000+M32R_SFR_OFFSET)
+
+#define M32R_MFTCR_PORTL       (0x000+M32R_MFT_OFFSET)  /* MFT control */
+#define M32R_MFTRPR_PORTL      (0x004+M32R_MFT_OFFSET)  /* MFT real port */
+
+#define M32R_MFT0_OFFSET       (0x100+M32R_MFT_OFFSET)
+#define M32R_MFT0MOD_PORTL     (0x00+M32R_MFT0_OFFSET)  /* MFT0 mode */
+#define M32R_MFT0BOS_PORTL     (0x04+M32R_MFT0_OFFSET)  /* MFT0 b-port output status */
+#define M32R_MFT0CUT_PORTL     (0x08+M32R_MFT0_OFFSET)  /* MFT0 count */
+#define M32R_MFT0RLD_PORTL     (0x0C+M32R_MFT0_OFFSET)  /* MFT0 reload */
+#define M32R_MFT0CMPRLD_PORTL  (0x10+M32R_MFT0_OFFSET)  /* MFT0 compare reload */
+
+#define M32R_MFT1_OFFSET       (0x200+M32R_MFT_OFFSET)
+#define M32R_MFT1MOD_PORTL     (0x00+M32R_MFT1_OFFSET)  /* MFT1 mode */
+#define M32R_MFT1BOS_PORTL     (0x04+M32R_MFT1_OFFSET)  /* MFT1 b-port output status */
+#define M32R_MFT1CUT_PORTL     (0x08+M32R_MFT1_OFFSET)  /* MFT1 count */
+#define M32R_MFT1RLD_PORTL     (0x0C+M32R_MFT1_OFFSET)  /* MFT1 reload */
+#define M32R_MFT1CMPRLD_PORTL  (0x10+M32R_MFT1_OFFSET)  /* MFT1 compare reload */
+
+#define M32R_MFT2_OFFSET       (0x300+M32R_MFT_OFFSET)
+#define M32R_MFT2MOD_PORTL     (0x00+M32R_MFT2_OFFSET)  /* MFT2 mode */
+#define M32R_MFT2BOS_PORTL     (0x04+M32R_MFT2_OFFSET)  /* MFT2 b-port output status */
+#define M32R_MFT2CUT_PORTL     (0x08+M32R_MFT2_OFFSET)  /* MFT2 count */
+#define M32R_MFT2RLD_PORTL     (0x0C+M32R_MFT2_OFFSET)  /* MFT2 reload */
+#define M32R_MFT2CMPRLD_PORTL  (0x10+M32R_MFT2_OFFSET)  /* MFT2 compare reload */
+
+#define M32R_MFT3_OFFSET       (0x400+M32R_MFT_OFFSET)
+#define M32R_MFT3MOD_PORTL     (0x00+M32R_MFT3_OFFSET)  /* MFT3 mode */
+#define M32R_MFT3BOS_PORTL     (0x04+M32R_MFT3_OFFSET)  /* MFT3 b-port output status */
+#define M32R_MFT3CUT_PORTL     (0x08+M32R_MFT3_OFFSET)  /* MFT3 count */
+#define M32R_MFT3RLD_PORTL     (0x0C+M32R_MFT3_OFFSET)  /* MFT3 reload */
+#define M32R_MFT3CMPRLD_PORTL  (0x10+M32R_MFT3_OFFSET)  /* MFT3 compare reload */
+
+#define M32R_MFT4_OFFSET       (0x500+M32R_MFT_OFFSET)
+#define M32R_MFT4MOD_PORTL     (0x00+M32R_MFT4_OFFSET)  /* MFT4 mode */
+#define M32R_MFT4BOS_PORTL     (0x04+M32R_MFT4_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT4CUT_PORTL     (0x08+M32R_MFT4_OFFSET)  /* MFT4 count */
+#define M32R_MFT4RLD_PORTL     (0x0C+M32R_MFT4_OFFSET)  /* MFT4 reload */
+#define M32R_MFT4CMPRLD_PORTL  (0x10+M32R_MFT4_OFFSET)  /* MFT4 compare reload */
+
+#define M32R_MFT5_OFFSET       (0x600+M32R_MFT_OFFSET)
+#define M32R_MFT5MOD_PORTL     (0x00+M32R_MFT5_OFFSET)  /* MFT4 mode */
+#define M32R_MFT5BOS_PORTL     (0x04+M32R_MFT5_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT5CUT_PORTL     (0x08+M32R_MFT5_OFFSET)  /* MFT4 count */
+#define M32R_MFT5RLD_PORTL     (0x0C+M32R_MFT5_OFFSET)  /* MFT4 reload */
+#define M32R_MFT5CMPRLD_PORTL  (0x10+M32R_MFT5_OFFSET)  /* MFT4 compare reload */
+
+#if (defined(CONFIG_CHIP_M32700) && !defined(CONFIG_PLAT_MAPPI2)) \
+	|| defined(CONFIG_CHIP_M32104)
+#define M32R_MFTCR_MFT0MSK  (1UL<<31)  /* b0 */
+#define M32R_MFTCR_MFT1MSK  (1UL<<30)  /* b1 */
+#define M32R_MFTCR_MFT2MSK  (1UL<<29)  /* b2 */
+#define M32R_MFTCR_MFT3MSK  (1UL<<28)  /* b3 */
+#define M32R_MFTCR_MFT4MSK  (1UL<<27)  /* b4 */
+#define M32R_MFTCR_MFT5MSK  (1UL<<26)  /* b5 */
+#define M32R_MFTCR_MFT0EN   (1UL<<23)  /* b8 */
+#define M32R_MFTCR_MFT1EN   (1UL<<22)  /* b9 */
+#define M32R_MFTCR_MFT2EN   (1UL<<21)  /* b10 */
+#define M32R_MFTCR_MFT3EN   (1UL<<20)  /* b11 */
+#define M32R_MFTCR_MFT4EN   (1UL<<19)  /* b12 */
+#define M32R_MFTCR_MFT5EN   (1UL<<18)  /* b13 */
+#else
+#define M32R_MFTCR_MFT0MSK  (1UL<<15)  /* b16 */
+#define M32R_MFTCR_MFT1MSK  (1UL<<14)  /* b17 */
+#define M32R_MFTCR_MFT2MSK  (1UL<<13)  /* b18 */
+#define M32R_MFTCR_MFT3MSK  (1UL<<12)  /* b19 */
+#define M32R_MFTCR_MFT4MSK  (1UL<<11)  /* b20 */
+#define M32R_MFTCR_MFT5MSK  (1UL<<10)  /* b21 */
+#define M32R_MFTCR_MFT0EN   (1UL<<7)   /* b24 */
+#define M32R_MFTCR_MFT1EN   (1UL<<6)   /* b25 */
+#define M32R_MFTCR_MFT2EN   (1UL<<5)   /* b26 */
+#define M32R_MFTCR_MFT3EN   (1UL<<4)   /* b27 */
+#define M32R_MFTCR_MFT4EN   (1UL<<3)   /* b28 */
+#define M32R_MFTCR_MFT5EN   (1UL<<2)   /* b29 */
+#endif
+
+#define M32R_MFTMOD_CC_MASK    (1UL<<15)  /* b16 */
+#define M32R_MFTMOD_TCCR       (1UL<<13)  /* b18 */
+#define M32R_MFTMOD_GTSEL000   (0UL<<8)   /* b21-23 : 000 */
+#define M32R_MFTMOD_GTSEL001   (1UL<<8)   /* b21-23 : 001 */
+#define M32R_MFTMOD_GTSEL010   (2UL<<8)   /* b21-23 : 010 */
+#define M32R_MFTMOD_GTSEL011   (3UL<<8)   /* b21-23 : 011 */
+#define M32R_MFTMOD_GTSEL110   (6UL<<8)   /* b21-23 : 110 */
+#define M32R_MFTMOD_GTSEL111   (7UL<<8)   /* b21-23 : 111 */
+#define M32R_MFTMOD_CMSEL      (1UL<<3)   /* b28 */
+#define M32R_MFTMOD_CSSEL000   (0UL<<0)   /* b29-b31 : 000 */
+#define M32R_MFTMOD_CSSEL001   (1UL<<0)   /* b29-b31 : 001 */
+#define M32R_MFTMOD_CSSEL010   (2UL<<0)   /* b29-b31 : 010 */
+#define M32R_MFTMOD_CSSEL011   (3UL<<0)   /* b29-b31 : 011 */
+#define M32R_MFTMOD_CSSEL100   (4UL<<0)   /* b29-b31 : 100 */
+#define M32R_MFTMOD_CSSEL110   (6UL<<0)   /* b29-b31 : 110 */
+
+/*
+ * Serial I/O registers.
+ */
+#define M32R_SIO_OFFSET  (0x000FD000+M32R_SFR_OFFSET)
+
+#define M32R_SIO0_CR_PORTL    (0x000+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD0_PORTL  (0x004+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD1_PORTL  (0x008+M32R_SIO_OFFSET)
+#define M32R_SIO0_STS_PORTL   (0x00C+M32R_SIO_OFFSET)
+#define M32R_SIO0_TRCR_PORTL  (0x010+M32R_SIO_OFFSET)
+#define M32R_SIO0_BAUR_PORTL  (0x014+M32R_SIO_OFFSET)
+#define M32R_SIO0_RBAUR_PORTL (0x018+M32R_SIO_OFFSET)
+#define M32R_SIO0_TXB_PORTL   (0x01C+M32R_SIO_OFFSET)
+#define M32R_SIO0_RXB_PORTL   (0x020+M32R_SIO_OFFSET)
+
+/*
+ * Interrupt Control Unit registers.
+ */
+#define M32R_ICU_OFFSET       (0x000FF000+M32R_SFR_OFFSET)
+#define M32R_ICU_ISTS_PORTL   (0x004+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ0_PORTL  (0x008+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ1_PORTL  (0x00C+M32R_ICU_OFFSET)
+#define M32R_ICU_SBICR_PORTL  (0x018+M32R_ICU_OFFSET)
+#define M32R_ICU_IMASK_PORTL  (0x01C+M32R_ICU_OFFSET)
+#define M32R_ICU_CR1_PORTL    (0x200+M32R_ICU_OFFSET)  /* INT0 */
+#define M32R_ICU_CR2_PORTL    (0x204+M32R_ICU_OFFSET)  /* INT1 */
+#define M32R_ICU_CR3_PORTL    (0x208+M32R_ICU_OFFSET)  /* INT2 */
+#define M32R_ICU_CR4_PORTL    (0x20C+M32R_ICU_OFFSET)  /* INT3 */
+#define M32R_ICU_CR5_PORTL    (0x210+M32R_ICU_OFFSET)  /* INT4 */
+#define M32R_ICU_CR6_PORTL    (0x214+M32R_ICU_OFFSET)  /* INT5 */
+#define M32R_ICU_CR7_PORTL    (0x218+M32R_ICU_OFFSET)  /* INT6 */
+#define M32R_ICU_CR8_PORTL    (0x219+M32R_ICU_OFFSET)  /* INT7 */
+#define M32R_ICU_CR16_PORTL   (0x23C+M32R_ICU_OFFSET)  /* MFT0 */
+#define M32R_ICU_CR17_PORTL   (0x240+M32R_ICU_OFFSET)  /* MFT1 */
+#define M32R_ICU_CR18_PORTL   (0x244+M32R_ICU_OFFSET)  /* MFT2 */
+#define M32R_ICU_CR19_PORTL   (0x248+M32R_ICU_OFFSET)  /* MFT3 */
+#define M32R_ICU_CR20_PORTL   (0x24C+M32R_ICU_OFFSET)  /* MFT4 */
+#define M32R_ICU_CR21_PORTL   (0x250+M32R_ICU_OFFSET)  /* MFT5 */
+#define M32R_ICU_CR32_PORTL   (0x27C+M32R_ICU_OFFSET)  /* DMA0 */
+#define M32R_ICU_CR33_PORTL   (0x280+M32R_ICU_OFFSET)  /* DMA1 */
+#define M32R_ICU_CR48_PORTL   (0x2BC+M32R_ICU_OFFSET)  /* SIO0 */
+#define M32R_ICU_CR49_PORTL   (0x2C0+M32R_ICU_OFFSET)  /* SIO0 */
+#define M32R_ICU_CR50_PORTL   (0x2C4+M32R_ICU_OFFSET)  /* SIO1 */
+#define M32R_ICU_CR51_PORTL   (0x2C8+M32R_ICU_OFFSET)  /* SIO1 */
+#define M32R_ICU_CR52_PORTL   (0x2CC+M32R_ICU_OFFSET)  /* SIO2 */
+#define M32R_ICU_CR53_PORTL   (0x2D0+M32R_ICU_OFFSET)  /* SIO2 */
+#define M32R_ICU_CR54_PORTL   (0x2D4+M32R_ICU_OFFSET)  /* SIO3 */
+#define M32R_ICU_CR55_PORTL   (0x2D8+M32R_ICU_OFFSET)  /* SIO3 */
+#define M32R_ICU_CR56_PORTL   (0x2DC+M32R_ICU_OFFSET)  /* SIO4 */
+#define M32R_ICU_CR57_PORTL   (0x2E0+M32R_ICU_OFFSET)  /* SIO4 */
+
+#ifdef CONFIG_SMP
+#define M32R_ICU_IPICR0_PORTL (0x2dc+M32R_ICU_OFFSET)  /* IPI0 */
+#define M32R_ICU_IPICR1_PORTL (0x2e0+M32R_ICU_OFFSET)  /* IPI1 */
+#define M32R_ICU_IPICR2_PORTL (0x2e4+M32R_ICU_OFFSET)  /* IPI2 */
+#define M32R_ICU_IPICR3_PORTL (0x2e8+M32R_ICU_OFFSET)  /* IPI3 */
+#define M32R_ICU_IPICR4_PORTL (0x2ec+M32R_ICU_OFFSET)  /* IPI4 */
+#define M32R_ICU_IPICR5_PORTL (0x2f0+M32R_ICU_OFFSET)  /* IPI5 */
+#define M32R_ICU_IPICR6_PORTL (0x2f4+M32R_ICU_OFFSET)  /* IPI6 */
+#define M32R_ICU_IPICR7_PORTL (0x2f8+M32R_ICU_OFFSET)  /* IPI7 */
+#endif /* CONFIG_SMP */
+
+#define M32R_ICUIMASK_IMSK0  (0UL<<16)  /* b13-b15: Disable interrupt */
+#define M32R_ICUIMASK_IMSK1  (1UL<<16)  /* b13-b15: Enable level 0 interrupt */
+#define M32R_ICUIMASK_IMSK2  (2UL<<16)  /* b13-b15: Enable level 0,1 interrupt */
+#define M32R_ICUIMASK_IMSK3  (3UL<<16)  /* b13-b15: Enable level 0-2 interrupt */
+#define M32R_ICUIMASK_IMSK4  (4UL<<16)  /* b13-b15: Enable level 0-3 interrupt */
+#define M32R_ICUIMASK_IMSK5  (5UL<<16)  /* b13-b15: Enable level 0-4 interrupt */
+#define M32R_ICUIMASK_IMSK6  (6UL<<16)  /* b13-b15: Enable level 0-5 interrupt */
+#define M32R_ICUIMASK_IMSK7  (7UL<<16)  /* b13-b15: Enable level 0-6 interrupt */
+
+#define M32R_ICUCR_IEN      (1UL<<12)  /* b19: Interrupt enable */
+#define M32R_ICUCR_IRQ      (1UL<<8)   /* b23: Interrupt request */
+#define M32R_ICUCR_ISMOD00  (0UL<<4)   /* b26-b27: Interrupt sense mode Edge HtoL */
+#define M32R_ICUCR_ISMOD01  (1UL<<4)   /* b26-b27: Interrupt sense mode Level L */
+#define M32R_ICUCR_ISMOD10  (2UL<<4)   /* b26-b27: Interrupt sense mode Edge LtoH*/
+#define M32R_ICUCR_ISMOD11  (3UL<<4)   /* b26-b27: Interrupt sense mode Level H */
+#define M32R_ICUCR_ILEVEL0  (0UL<<0)   /* b29-b31: Interrupt priority level 0 */
+#define M32R_ICUCR_ILEVEL1  (1UL<<0)   /* b29-b31: Interrupt priority level 1 */
+#define M32R_ICUCR_ILEVEL2  (2UL<<0)   /* b29-b31: Interrupt priority level 2 */
+#define M32R_ICUCR_ILEVEL3  (3UL<<0)   /* b29-b31: Interrupt priority level 3 */
+#define M32R_ICUCR_ILEVEL4  (4UL<<0)   /* b29-b31: Interrupt priority level 4 */
+#define M32R_ICUCR_ILEVEL5  (5UL<<0)   /* b29-b31: Interrupt priority level 5 */
+#define M32R_ICUCR_ILEVEL6  (6UL<<0)   /* b29-b31: Interrupt priority level 6 */
+#define M32R_ICUCR_ILEVEL7  (7UL<<0)   /* b29-b31: Disable interrupt */
+
+#define M32R_IRQ_INT0    (1)   /* INT0 */
+#define M32R_IRQ_INT1    (2)   /* INT1 */
+#define M32R_IRQ_INT2    (3)   /* INT2 */
+#define M32R_IRQ_INT3    (4)   /* INT3 */
+#define M32R_IRQ_INT4    (5)   /* INT4 */
+#define M32R_IRQ_INT5    (6)   /* INT5 */
+#define M32R_IRQ_INT6    (7)   /* INT6 */
+#define M32R_IRQ_MFT0    (16)  /* MFT0 */
+#define M32R_IRQ_MFT1    (17)  /* MFT1 */
+#define M32R_IRQ_MFT2    (18)  /* MFT2 */
+#define M32R_IRQ_MFT3    (19)  /* MFT3 */
+#ifdef CONFIG_CHIP_M32104
+#define M32R_IRQ_MFTX0   (24)  /* MFTX0 */
+#define M32R_IRQ_MFTX1   (25)  /* MFTX1 */
+#define M32R_IRQ_DMA0    (32)  /* DMA0 */
+#define M32R_IRQ_DMA1    (33)  /* DMA1 */
+#define M32R_IRQ_DMA2    (34)  /* DMA2 */
+#define M32R_IRQ_DMA3    (35)  /* DMA3 */
+#define M32R_IRQ_SIO0_R  (40)  /* SIO0 send    */
+#define M32R_IRQ_SIO0_S  (41)  /* SIO0 receive */
+#define M32R_IRQ_SIO1_R  (42)  /* SIO1 send    */
+#define M32R_IRQ_SIO1_S  (43)  /* SIO1 receive */
+#define M32R_IRQ_SIO2_R  (44)  /* SIO2 send    */
+#define M32R_IRQ_SIO2_S  (45)  /* SIO2 receive */
+#define M32R_IRQ_SIO3_R  (46)  /* SIO3 send    */
+#define M32R_IRQ_SIO3_S  (47)  /* SIO3 receive */
+#define M32R_IRQ_ADC     (56)  /* ADC */
+#define M32R_IRQ_PC      (57)  /* PC */
+#else /* ! M32104 */
+#define M32R_IRQ_DMA0    (32)  /* DMA0 */
+#define M32R_IRQ_DMA1    (33)  /* DMA1 */
+#define M32R_IRQ_SIO0_R  (48)  /* SIO0 send    */
+#define M32R_IRQ_SIO0_S  (49)  /* SIO0 receive */
+#define M32R_IRQ_SIO1_R  (50)  /* SIO1 send    */
+#define M32R_IRQ_SIO1_S  (51)  /* SIO1 receive */
+#define M32R_IRQ_SIO2_R  (52)  /* SIO2 send    */
+#define M32R_IRQ_SIO2_S  (53)  /* SIO2 receive */
+#define M32R_IRQ_SIO3_R  (54)  /* SIO3 send    */
+#define M32R_IRQ_SIO3_S  (55)  /* SIO3 receive */
+#define M32R_IRQ_SIO4_R  (56)  /* SIO4 send    */
+#define M32R_IRQ_SIO4_S  (57)  /* SIO4 receive */
+#endif /* ! M32104 */
+
+#ifdef CONFIG_SMP
+#define M32R_IRQ_IPI0    (56)
+#define M32R_IRQ_IPI1    (57)
+#define M32R_IRQ_IPI2    (58)
+#define M32R_IRQ_IPI3    (59)
+#define M32R_IRQ_IPI4    (60)
+#define M32R_IRQ_IPI5    (61)
+#define M32R_IRQ_IPI6    (62)
+#define M32R_IRQ_IPI7    (63)
+#define M32R_CPUID_PORTL (0xffffffe0)
+
+#define M32R_FPGA_TOP (0x000F0000+M32R_SFR_OFFSET)
+
+#define M32R_FPGA_NUM_OF_CPUS_PORTL (0x00+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME0_PORTL   (0x10+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME1_PORTL   (0x14+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME2_PORTL   (0x18+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME3_PORTL   (0x1c+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID0_PORTL   (0x20+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID1_PORTL   (0x24+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID2_PORTL   (0x28+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID3_PORTL   (0x2c+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION0_PORTL    (0x30+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION1_PORTL    (0x34+M32R_FPGA_TOP)
+
+#endif /* CONFIG_SMP */
+
+#ifndef __ASSEMBLY__
+typedef struct {
+	unsigned long icucr;	/* ICU Control Register */
+} icu_data_t;
+#endif
+
+#endif /* _M32102_H_ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/m32104ut/m32104ut_pld.h linux-2.6.30-rc3/arch/m32r/include/asm/m32104ut/m32104ut_pld.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/m32104ut/m32104ut_pld.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/m32104ut/m32104ut_pld.h	2009-04-22 03:29:16.269931444 +0000
@@ -0,0 +1,161 @@
+#ifndef _M32104UT_M32104UT_PLD_H
+#define _M32104UT_M32104UT_PLD_H
+
+/*
+ * include/asm-m32r/m32104ut/m32104ut_pld.h
+ *
+ * Definitions for Programable Logic Device(PLD) on M32104UT board.
+ * Based on m32700ut_pld.h
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ * Copyright (c) 2005	Naoto Sugai
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#if defined(CONFIG_PLAT_M32104UT)
+#define PLD_PLAT_BASE		0x02c00000
+#else
+#error "no platform configuration"
+#endif
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif /* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ */
+
+#define PLD_IRQ_INT0		(M32104UT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_CFIREQ		(M32104UT_PLD_IRQ_BASE + 3)	/* CF IREQ */
+#define PLD_IRQ_CFC_INSERT	(M32104UT_PLD_IRQ_BASE + 4)	/* CF Insert */
+#define PLD_IRQ_CFC_EJECT	(M32104UT_PLD_IRQ_BASE + 5)	/* CF Eject */
+#define PLD_IRQ_EXINT		(M32104UT_PLD_IRQ_BASE + 6)	/* EXINT */
+#define PLD_IRQ_MMCCARD		(M32104UT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
+#define PLD_IRQ_SC_ERROR	(M32104UT_PLD_IRQ_BASE + 13)	/* SC error */
+#define PLD_IRQ_SC_RCV		(M32104UT_PLD_IRQ_BASE + 14)	/* SC receive */
+#define PLD_IRQ_SC_SND		(M32104UT_PLD_IRQ_BASE + 15)	/* SC send */
+
+#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
+#define PLD_ICUISTS_VECB_MASK	(0xf000)
+#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
+#define PLD_ICUISTS_ISN_MASK	(0x07c0)
+#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
+#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
+#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
+#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
+#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
+#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
+#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
+#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
+#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
+#define PLD_ICUCR_IEN		(0x1000)
+#define PLD_ICUCR_IREQ		(0x0100)
+#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
+#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
+#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
+#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
+#define PLD_ICUCR_ILEVEL0	(0x0000)
+#define PLD_ICUCR_ILEVEL1	(0x0001)
+#define PLD_ICUCR_ILEVEL2	(0x0002)
+#define PLD_ICUCR_ILEVEL3	(0x0003)
+#define PLD_ICUCR_ILEVEL4	(0x0004)
+#define PLD_ICUCR_ILEVEL5	(0x0005)
+#define PLD_ICUCR_ILEVEL6	(0x0006)
+#define PLD_ICUCR_ILEVEL7	(0x0007)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+#define PLD_CPCR_CDP		0x0001
+
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif /* _M32104UT_M32104UT_PLD_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/m32700ut/m32700ut_lan.h linux-2.6.30-rc3/arch/m32r/include/asm/m32700ut/m32700ut_lan.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/m32700ut/m32700ut_lan.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/m32700ut/m32700ut_lan.h	2009-04-22 03:29:16.269931444 +0000
@@ -0,0 +1,103 @@
+#ifndef _M32700UT_M32700UT_LAN_H
+#define _M32700UT_M32700UT_LAN_H
+
+/*
+ * include/asm-m32r/m32700ut/m32700ut_lan.h
+ *
+ * M32700UT-LAN board
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define M32700UT_LAN_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define M32700UT_LAN_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif /* __ASSEMBLY__ */
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#define M32700UT_LAN_IRQ_LAN	(M32700UT_LAN_PLD_IRQ_BASE + 1)	/* LAN */
+#define M32700UT_LAN_IRQ_I2C	(M32700UT_LAN_PLD_IRQ_BASE + 3)	/* I2C */
+
+#define M32700UT_LAN_ICUISTS	__reg16(M32700UT_LAN_BASE + 0xc0002)
+#define M32700UT_LAN_ICUISTS_VECB_MASK	(0xf000)
+#define M32700UT_LAN_VECB(x)	((x) & M32700UT_LAN_ICUISTS_VECB_MASK)
+#define M32700UT_LAN_ICUISTS_ISN_MASK	(0x07c0)
+#define M32700UT_LAN_ICUISTS_ISN(x)	((x) & M32700UT_LAN_ICUISTS_ISN_MASK)
+#define M32700UT_LAN_ICUIREQ0	__reg16(M32700UT_LAN_BASE + 0xc0004)
+#define M32700UT_LAN_ICUCR1	__reg16(M32700UT_LAN_BASE + 0xc0010)
+#define M32700UT_LAN_ICUCR3	__reg16(M32700UT_LAN_BASE + 0xc0014)
+
+/*
+ * AR register on PLD
+ */
+#define ARVCR0		__reg32(M32700UT_LAN_BASE + 0x40000)
+#define ARVCR0_VDS		0x00080000
+#define ARVCR0_RST		0x00010000
+#define ARVCR1		__reg32(M32700UT_LAN_BASE + 0x40004)
+#define ARVCR1_QVGA		0x02000000
+#define ARVCR1_NORMAL		0x01000000
+#define ARVCR1_HIEN		0x00010000
+#define ARVHCOUNT	__reg32(M32700UT_LAN_BASE + 0x40008)
+#define ARDATA		__reg32(M32700UT_LAN_BASE + 0x40010)
+#define ARINTSEL	__reg32(M32700UT_LAN_BASE + 0x40014)
+#define ARINTSEL_INT3		0x10000000	/* CPU INT3 */
+#define ARDATA32	__reg32(M32700UT_LAN_BASE + 0x04040010)	// Block 5
+/*
+#define ARINTSEL_SEL2		0x00002000
+#define ARINTSEL_SEL3		0x00001000
+#define ARINTSEL_SEL6		0x00000200
+#define ARINTSEL_SEL7		0x00000100
+#define ARINTSEL_SEL9		0x00000040
+#define ARINTSEL_SEL10		0x00000020
+#define ARINTSEL_SEL11		0x00000010
+#define ARINTSEL_SEL12		0x00000008
+*/
+
+/*
+ * I2C register on PLD
+ */
+#define PLDI2CCR	__reg32(M32700UT_LAN_BASE + 0x40040)
+#define	PLDI2CCR_ES0		0x00000001	/* enable I2C interface */
+#define PLDI2CMOD	__reg32(M32700UT_LAN_BASE + 0x40044)
+#define PLDI2CMOD_ACKCLK	0x00000200
+#define PLDI2CMOD_DTWD		0x00000100
+#define PLDI2CMOD_10BT		0x00000004
+#define PLDI2CMOD_ATM_NORMAL	0x00000000
+#define PLDI2CMOD_ATM_AUTO	0x00000003
+#define PLDI2CACK	__reg32(M32700UT_LAN_BASE + 0x40048)
+#define PLDI2CACK_ACK		0x00000001
+#define PLDI2CFREQ	__reg32(M32700UT_LAN_BASE + 0x4004c)
+#define PLDI2CCND	__reg32(M32700UT_LAN_BASE + 0x40050)
+#define PLDI2CCND_START		0x00000001
+#define PLDI2CCND_STOP		0x00000002
+#define PLDI2CSTEN	__reg32(M32700UT_LAN_BASE + 0x40054)
+#define PLDI2CSTEN_STEN		0x00000001
+#define PLDI2CDATA	__reg32(M32700UT_LAN_BASE + 0x40060)
+#define PLDI2CSTS	__reg32(M32700UT_LAN_BASE + 0x40064)
+#define PLDI2CSTS_TRX		0x00000020
+#define PLDI2CSTS_BB		0x00000010
+#define PLDI2CSTS_NOACK		0x00000001	/* 0:ack, 1:noack */
+
+#endif /* _M32700UT_M32700UT_LAN_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/m32700ut/m32700ut_lcd.h linux-2.6.30-rc3/arch/m32r/include/asm/m32700ut/m32700ut_lcd.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/m32700ut/m32700ut_lcd.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/m32700ut/m32700ut_lcd.h	2009-04-22 03:29:16.269931444 +0000
@@ -0,0 +1,55 @@
+#ifndef _M32700UT_M32700UT_LCD_H
+#define _M32700UT_M32700UT_LCD_H
+
+/*
+ * include/asm-m32r/m32700ut/m32700ut_lcd.h
+ *
+ * M32700UT-LCD board
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define M32700UT_LCD_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define M32700UT_LCD_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif /* __ASSEMBLY__ */
+
+/*
+ * ICU
+ */
+#define M32700UT_LCD_IRQ_BAT_INT	(M32700UT_LCD_PLD_IRQ_BASE + 1)
+#define M32700UT_LCD_IRQ_USB_INT1	(M32700UT_LCD_PLD_IRQ_BASE + 2)
+#define M32700UT_LCD_IRQ_AUDT0		(M32700UT_LCD_PLD_IRQ_BASE + 3)
+#define M32700UT_LCD_IRQ_AUDT2		(M32700UT_LCD_PLD_IRQ_BASE + 4)
+#define M32700UT_LCD_IRQ_BATSIO_RCV	(M32700UT_LCD_PLD_IRQ_BASE + 16)
+#define M32700UT_LCD_IRQ_BATSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 17)
+#define M32700UT_LCD_IRQ_ASNDSIO_RCV	(M32700UT_LCD_PLD_IRQ_BASE + 18)
+#define M32700UT_LCD_IRQ_ASNDSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 19)
+#define M32700UT_LCD_IRQ_ACNLSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 21)
+
+#define M32700UT_LCD_ICUISTS	__reg16(M32700UT_LCD_BASE + 0x300002)
+#define M32700UT_LCD_ICUISTS_VECB_MASK	(0xf000)
+#define M32700UT_LCD_VECB(x)	((x) & M32700UT_LCD_ICUISTS_VECB_MASK)
+#define M32700UT_LCD_ICUISTS_ISN_MASK	(0x07c0)
+#define M32700UT_LCD_ICUISTS_ISN(x)	((x) & M32700UT_LCD_ICUISTS_ISN_MASK)
+#define M32700UT_LCD_ICUIREQ0	__reg16(M32700UT_LCD_BASE + 0x300004)
+#define M32700UT_LCD_ICUIREQ1	__reg16(M32700UT_LCD_BASE + 0x300006)
+#define M32700UT_LCD_ICUCR1	__reg16(M32700UT_LCD_BASE + 0x300020)
+#define M32700UT_LCD_ICUCR2	__reg16(M32700UT_LCD_BASE + 0x300022)
+#define M32700UT_LCD_ICUCR3	__reg16(M32700UT_LCD_BASE + 0x300024)
+#define M32700UT_LCD_ICUCR4	__reg16(M32700UT_LCD_BASE + 0x300026)
+#define M32700UT_LCD_ICUCR16	__reg16(M32700UT_LCD_BASE + 0x300030)
+#define M32700UT_LCD_ICUCR17	__reg16(M32700UT_LCD_BASE + 0x300032)
+#define M32700UT_LCD_ICUCR18	__reg16(M32700UT_LCD_BASE + 0x300034)
+#define M32700UT_LCD_ICUCR19	__reg16(M32700UT_LCD_BASE + 0x300036)
+#define M32700UT_LCD_ICUCR21	__reg16(M32700UT_LCD_BASE + 0x30003a)
+
+#endif /* _M32700UT_M32700UT_LCD_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/m32700ut/m32700ut_pld.h linux-2.6.30-rc3/arch/m32r/include/asm/m32700ut/m32700ut_pld.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/m32700ut/m32700ut_pld.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/m32700ut/m32700ut_pld.h	2009-04-22 03:29:16.269931444 +0000
@@ -0,0 +1,259 @@
+#ifndef _M32700UT_M32700UT_PLD_H
+#define _M32700UT_M32700UT_PLD_H
+
+/*
+ * include/asm-m32r/m32700ut/m32700ut_pld.h
+ *
+ * Definitions for Programable Logic Device(PLD) on M32700UT board.
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV)
+#define PLD_PLAT_BASE		0x04c00000
+#else
+#error "no platform configuration"
+#endif
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif /* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+#define PLD_CFVENCR		__reg16(PLD_BASE + 0x0008)
+#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
+#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
+#define PLD_IDERSTCR		__reg16(PLD_BASE + 0x0010)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#if !defined(CONFIG_PLAT_USRV)
+#define PLD_IRQ_INT0		(M32700UT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(M32700UT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(M32700UT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CFIREQ		(M32700UT_PLD_IRQ_BASE + 3)	/* CF IREQ */
+#define PLD_IRQ_CFC_INSERT	(M32700UT_PLD_IRQ_BASE + 4)	/* CF Insert */
+#define PLD_IRQ_CFC_EJECT	(M32700UT_PLD_IRQ_BASE + 5)	/* CF Eject */
+#define PLD_IRQ_EXINT		(M32700UT_PLD_IRQ_BASE + 6)	/* EXINT */
+#define PLD_IRQ_INT7		(M32700UT_PLD_IRQ_BASE + 7)	/* reserved */
+#define PLD_IRQ_INT8		(M32700UT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(M32700UT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(M32700UT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_MMCCARD		(M32700UT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
+#define PLD_IRQ_INT12		(M32700UT_PLD_IRQ_BASE + 12)	/* reserved */
+#define PLD_IRQ_SC_ERROR	(M32700UT_PLD_IRQ_BASE + 13)	/* SC error */
+#define PLD_IRQ_SC_RCV		(M32700UT_PLD_IRQ_BASE + 14)	/* SC receive */
+#define PLD_IRQ_SC_SND		(M32700UT_PLD_IRQ_BASE + 15)	/* SC send */
+#define PLD_IRQ_SIO0_RCV	(M32700UT_PLD_IRQ_BASE + 16)	/* SIO receive */
+#define PLD_IRQ_SIO0_SND	(M32700UT_PLD_IRQ_BASE + 17)	/* SIO send */
+#define PLD_IRQ_INT18		(M32700UT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(M32700UT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(M32700UT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(M32700UT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(M32700UT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(M32700UT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(M32700UT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(M32700UT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(M32700UT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(M32700UT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(M32700UT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(M32700UT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(M32700UT_PLD_IRQ_BASE + 30)	/* reserved */
+#define PLD_IRQ_INT31		(M32700UT_PLD_IRQ_BASE + 31)	/* reserved */
+
+#else	/* CONFIG_PLAT_USRV */
+
+#define PLD_IRQ_INT0		(M32700UT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(M32700UT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(M32700UT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CF0		(M32700UT_PLD_IRQ_BASE + 3)	/* CF0# */
+#define PLD_IRQ_CF1		(M32700UT_PLD_IRQ_BASE + 4)	/* CF1# */
+#define PLD_IRQ_CF2		(M32700UT_PLD_IRQ_BASE + 5)	/* CF2# */
+#define PLD_IRQ_CF3		(M32700UT_PLD_IRQ_BASE + 6)	/* CF3# */
+#define PLD_IRQ_CF4		(M32700UT_PLD_IRQ_BASE + 7)	/* CF4# */
+#define PLD_IRQ_INT8		(M32700UT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(M32700UT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(M32700UT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_INT11		(M32700UT_PLD_IRQ_BASE + 11)	/* reserved */
+#define PLD_IRQ_UART0		(M32700UT_PLD_IRQ_BASE + 12)	/* UARTIRQ0 */
+#define PLD_IRQ_UART1		(M32700UT_PLD_IRQ_BASE + 13)	/* UARTIRQ1 */
+#define PLD_IRQ_INT14		(M32700UT_PLD_IRQ_BASE + 14)	/* reserved */
+#define PLD_IRQ_INT15		(M32700UT_PLD_IRQ_BASE + 15)	/* reserved */
+#define PLD_IRQ_SNDINT		(M32700UT_PLD_IRQ_BASE + 16)	/* SNDINT# */
+#define PLD_IRQ_INT17		(M32700UT_PLD_IRQ_BASE + 17)	/* reserved */
+#define PLD_IRQ_INT18		(M32700UT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(M32700UT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(M32700UT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(M32700UT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(M32700UT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(M32700UT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(M32700UT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(M32700UT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(M32700UT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(M32700UT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(M32700UT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(M32700UT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(M32700UT_PLD_IRQ_BASE + 30)	/* reserved */
+
+#endif	/* CONFIG_PLAT_USRV */
+
+#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
+#define PLD_ICUISTS_VECB_MASK	(0xf000)
+#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
+#define PLD_ICUISTS_ISN_MASK	(0x07c0)
+#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
+#define PLD_ICUIREQ0		__reg16(PLD_BASE + 0x8004)
+#define PLD_ICUIREQ1		__reg16(PLD_BASE + 0x8006)
+#define PLD_ICUCR1		__reg16(PLD_BASE + 0x8100)
+#define PLD_ICUCR2		__reg16(PLD_BASE + 0x8102)
+#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
+#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
+#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
+#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
+#define PLD_ICUCR7		__reg16(PLD_BASE + 0x810c)
+#define PLD_ICUCR8		__reg16(PLD_BASE + 0x810e)
+#define PLD_ICUCR9		__reg16(PLD_BASE + 0x8110)
+#define PLD_ICUCR10		__reg16(PLD_BASE + 0x8112)
+#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
+#define PLD_ICUCR12		__reg16(PLD_BASE + 0x8116)
+#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
+#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
+#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
+#define PLD_ICUCR16		__reg16(PLD_BASE + 0x811e)
+#define PLD_ICUCR17		__reg16(PLD_BASE + 0x8120)
+#define PLD_ICUCR_IEN		(0x1000)
+#define PLD_ICUCR_IREQ		(0x0100)
+#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
+#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
+#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
+#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
+#define PLD_ICUCR_ILEVEL0	(0x0000)
+#define PLD_ICUCR_ILEVEL1	(0x0001)
+#define PLD_ICUCR_ILEVEL2	(0x0002)
+#define PLD_ICUCR_ILEVEL3	(0x0003)
+#define PLD_ICUCR_ILEVEL4	(0x0004)
+#define PLD_ICUCR_ILEVEL5	(0x0005)
+#define PLD_ICUCR_ILEVEL6	(0x0006)
+#define PLD_ICUCR_ILEVEL7	(0x0007)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+#define PLD_CPCR_CF		0x0001
+#define PLD_CPCR_MMC		0x0002
+
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIO0 */
+#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
+#define	PLD_ESIO0CR_TXEN	0x0001
+#define	PLD_ESIO0CR_RXEN	0x0002
+#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
+#define	PLD_ESIO0MOD0_CTSS	0x0040
+#define	PLD_ESIO0MOD0_RTSS	0x0080
+#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
+#define	PLD_ESIO0MOD1_LMFS	0x0010
+#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
+#define	PLD_ESIO0STS_TEMP	0x0001
+#define	PLD_ESIO0STS_TXCP	0x0002
+#define	PLD_ESIO0STS_RXCP	0x0004
+#define	PLD_ESIO0STS_TXSC	0x0100
+#define	PLD_ESIO0STS_RXSC	0x0200
+#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
+#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
+#define	PLD_ESIO0INTCR_TXIEN	0x0002
+#define	PLD_ESIO0INTCR_RXCEN	0x0004
+#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
+#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
+#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif /* _M32700UT_M32700UT_PLD.H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/m32r.h linux-2.6.30-rc3/arch/m32r/include/asm/m32r.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/m32r.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/m32r.h	2009-04-22 03:29:16.270556925 +0000
@@ -0,0 +1,160 @@
+#ifndef _ASM_M32R_M32R_H_
+#define _ASM_M32R_M32R_H_
+
+/*
+ * Renesas M32R processor
+ *
+ * Copyright (C) 2003, 2004  Renesas Technology Corp.
+ */
+
+
+/* Chip type */
+#if defined(CONFIG_CHIP_XNUX_MP) || defined(CONFIG_CHIP_XNUX2_MP)
+#include <asm/m32r_mp_fpga.h>
+#elif defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_XNUX2) \
+	|| defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_M32102) \
+        || defined(CONFIG_CHIP_OPSP) || defined(CONFIG_CHIP_M32104)
+#include <asm/m32102.h>
+#endif
+
+/* Platform type */
+#if defined(CONFIG_PLAT_M32700UT)
+#include <asm/m32700ut/m32700ut_pld.h>
+#include <asm/m32700ut/m32700ut_lan.h>
+#include <asm/m32700ut/m32700ut_lcd.h>
+/* for ei_handler:linux/arch/m32r/kernel/entry.S */
+#define M32R_INT1ICU_ISTS	PLD_ICUISTS
+#define M32R_INT1ICU_IRQ_BASE	M32700UT_PLD_IRQ_BASE
+#define M32R_INT0ICU_ISTS	M32700UT_LAN_ICUISTS
+#define M32R_INT0ICU_IRQ_BASE	M32700UT_LAN_PLD_IRQ_BASE
+#define M32R_INT2ICU_ISTS	M32700UT_LCD_ICUISTS
+#define M32R_INT2ICU_IRQ_BASE	M32700UT_LCD_PLD_IRQ_BASE
+#endif  /* CONFIG_PLAT_M32700UT */
+
+#if defined(CONFIG_PLAT_OPSPUT)
+#include <asm/opsput/opsput_pld.h>
+#include <asm/opsput/opsput_lan.h>
+#include <asm/opsput/opsput_lcd.h>
+/* for ei_handler:linux/arch/m32r/kernel/entry.S */
+#define M32R_INT1ICU_ISTS	PLD_ICUISTS
+#define M32R_INT1ICU_IRQ_BASE	OPSPUT_PLD_IRQ_BASE
+#define M32R_INT0ICU_ISTS	OPSPUT_LAN_ICUISTS
+#define M32R_INT0ICU_IRQ_BASE	OPSPUT_LAN_PLD_IRQ_BASE
+#define M32R_INT2ICU_ISTS	OPSPUT_LCD_ICUISTS
+#define M32R_INT2ICU_IRQ_BASE	OPSPUT_LCD_PLD_IRQ_BASE
+#endif  /* CONFIG_PLAT_OPSPUT */
+
+#if defined(CONFIG_PLAT_MAPPI2)
+#include <asm/mappi2/mappi2_pld.h>
+#endif	/* CONFIG_PLAT_MAPPI2 */
+
+#if defined(CONFIG_PLAT_MAPPI3)
+#include <asm/mappi3/mappi3_pld.h>
+#endif	/* CONFIG_PLAT_MAPPI3 */
+
+#if defined(CONFIG_PLAT_USRV)
+#include <asm/m32700ut/m32700ut_pld.h>
+/* for ei_handler:linux/arch/m32r/kernel/entry.S */
+#define M32R_INT1ICU_ISTS	PLD_ICUISTS
+#define M32R_INT1ICU_IRQ_BASE	M32700UT_PLD_IRQ_BASE
+#endif
+
+#if defined(CONFIG_PLAT_M32104UT)
+#include <asm/m32104ut/m32104ut_pld.h>
+/* for ei_handler:linux/arch/m32r/kernel/entry.S */
+#define M32R_INT1ICU_ISTS	PLD_ICUISTS
+#define M32R_INT1ICU_IRQ_BASE	M32104UT_PLD_IRQ_BASE
+#endif  /* CONFIG_PLAT_M32104 */
+
+/*
+ * M32R Register
+ */
+
+/*
+ * MMU Register
+ */
+
+#define MMU_REG_BASE	(0xffff0000)
+#define ITLB_BASE	(0xfe000000)
+#define DTLB_BASE	(0xfe000800)
+
+#define NR_TLB_ENTRIES	CONFIG_TLB_ENTRIES
+
+#define MATM	MMU_REG_BASE		/* MMU Address Translation Mode
+					   Register */
+#define MPSZ	(0x04 + MMU_REG_BASE)	/* MMU Page Size Designation Register */
+#define MASID	(0x08 + MMU_REG_BASE)	/* MMU Address Space ID Register */
+#define MESTS	(0x0c + MMU_REG_BASE)	/* MMU Exception Status Register */
+#define MDEVA	(0x10 + MMU_REG_BASE)	/* MMU Operand Exception Virtual
+					   Address Register */
+#define MDEVP	(0x14 + MMU_REG_BASE)	/* MMU Operand Exception Virtual Page
+					   Number Register */
+#define MPTB	(0x18 + MMU_REG_BASE)	/* MMU Page Table Base Register */
+#define MSVA	(0x20 + MMU_REG_BASE)	/* MMU Search Virtual Address
+					   Register */
+#define MTOP	(0x24 + MMU_REG_BASE)	/* MMU TLB Operation Register */
+#define MIDXI	(0x28 + MMU_REG_BASE)	/* MMU Index Register for
+					   Instruciton */
+#define MIDXD	(0x2c + MMU_REG_BASE)	/* MMU Index Register for Operand */
+
+#define MATM_offset	(MATM - MMU_REG_BASE)
+#define MPSZ_offset	(MPSZ - MMU_REG_BASE)
+#define MASID_offset	(MASID - MMU_REG_BASE)
+#define MESTS_offset	(MESTS - MMU_REG_BASE)
+#define MDEVA_offset	(MDEVA - MMU_REG_BASE)
+#define MDEVP_offset	(MDEVP - MMU_REG_BASE)
+#define MPTB_offset	(MPTB - MMU_REG_BASE)
+#define MSVA_offset	(MSVA - MMU_REG_BASE)
+#define MTOP_offset	(MTOP - MMU_REG_BASE)
+#define MIDXI_offset	(MIDXI - MMU_REG_BASE)
+#define MIDXD_offset	(MIDXD - MMU_REG_BASE)
+
+#define MESTS_IT	(1 << 0)	/* Instruction TLB miss */
+#define MESTS_IA	(1 << 1)	/* Instruction Access Exception */
+#define MESTS_DT	(1 << 4)	/* Operand TLB miss */
+#define MESTS_DA	(1 << 5)	/* Operand Access Exception */
+#define MESTS_DRW	(1 << 6)	/* Operand Write Exception Flag */
+
+/*
+ * PSW (Processor Status Word)
+ */
+
+/* PSW bit */
+#define M32R_PSW_BIT_SM   (7)    /* Stack Mode */
+#define M32R_PSW_BIT_IE   (6)    /* Interrupt Enable */
+#define M32R_PSW_BIT_PM   (3)    /* Processor Mode [0:Supervisor,1:User] */
+#define M32R_PSW_BIT_C    (0)    /* Condition */
+#define M32R_PSW_BIT_BSM  (7+8)  /* Backup Stack Mode */
+#define M32R_PSW_BIT_BIE  (6+8)  /* Backup Interrupt Enable */
+#define M32R_PSW_BIT_BPM  (3+8)  /* Backup Processor Mode */
+#define M32R_PSW_BIT_BC   (0+8)  /* Backup Condition */
+
+/* PSW bit map */
+#define M32R_PSW_SM   (1UL<< M32R_PSW_BIT_SM)   /* Stack Mode */
+#define M32R_PSW_IE   (1UL<< M32R_PSW_BIT_IE)   /* Interrupt Enable */
+#define M32R_PSW_PM   (1UL<< M32R_PSW_BIT_PM)   /* Processor Mode */
+#define M32R_PSW_C    (1UL<< M32R_PSW_BIT_C)    /* Condition */
+#define M32R_PSW_BSM  (1UL<< M32R_PSW_BIT_BSM)  /* Backup Stack Mode */
+#define M32R_PSW_BIE  (1UL<< M32R_PSW_BIT_BIE)  /* Backup Interrupt Enable */
+#define M32R_PSW_BPM  (1UL<< M32R_PSW_BIT_BPM)  /* Backup Processor Mode */
+#define M32R_PSW_BC   (1UL<< M32R_PSW_BIT_BC)   /* Backup Condition */
+
+/*
+ * Direct address to SFR
+ */
+
+#include <asm/page.h>
+#ifdef CONFIG_MMU
+#define NONCACHE_OFFSET  (__PAGE_OFFSET + 0x20000000)
+#else
+#define NONCACHE_OFFSET  __PAGE_OFFSET
+#endif /* CONFIG_MMU */
+
+#define M32R_ICU_ISTS_ADDR  M32R_ICU_ISTS_PORTL+NONCACHE_OFFSET
+#define M32R_ICU_IPICR_ADDR  M32R_ICU_IPICR0_PORTL+NONCACHE_OFFSET
+#define M32R_ICU_IMASK_ADDR  M32R_ICU_IMASK_PORTL+NONCACHE_OFFSET
+#define M32R_FPGA_CPU_NAME_ADDR  M32R_FPGA_CPU_NAME0_PORTL+NONCACHE_OFFSET
+#define M32R_FPGA_MODEL_ID_ADDR  M32R_FPGA_MODEL_ID0_PORTL+NONCACHE_OFFSET
+#define M32R_FPGA_VERSION_ADDR   M32R_FPGA_VERSION0_PORTL+NONCACHE_OFFSET
+
+#endif /* _ASM_M32R_M32R_H_ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/m32r_mp_fpga.h linux-2.6.30-rc3/arch/m32r/include/asm/m32r_mp_fpga.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/m32r_mp_fpga.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/m32r_mp_fpga.h	2009-04-22 03:29:16.270556925 +0000
@@ -0,0 +1,313 @@
+#ifndef _ASM_M32R_M32R_MP_FPGA_
+#define _ASM_M32R_M32R_MP_FPGA_
+
+/*
+ * Renesas M32R-MP-FPGA
+ *
+ * Copyright (c) 2002  Hitoshi Yamamoto
+ * Copyright (c) 2003, 2004  Renesas Technology Corp.
+ */
+
+/*
+ * ========================================================
+ * M32R-MP-FPGA Memory Map
+ * ========================================================
+ * 0x00000000 : Block#0 : 64[MB]
+ *              0x03E00000 : SFR
+ *                           0x03E00000 : reserved
+ *                           0x03EF0000 : FPGA
+ *                           0x03EF1000 : reserved
+ *                           0x03EF4000 : CKM
+ *                           0x03EF4000 : BSELC
+ *                           0x03EF5000 : reserved
+ *                           0x03EFC000 : MFT
+ *                           0x03EFD000 : SIO
+ *                           0x03EFE000 : reserved
+ *                           0x03EFF000 : ICU
+ *              0x03F00000 : Internal SRAM 64[KB]
+ *              0x03F10000 : reserved
+ * --------------------------------------------------------
+ * 0x04000000 : Block#1 : 64[MB]
+ *              0x04000000 : Debug board SRAM 4[MB]
+ *              0x04400000 : reserved
+ * --------------------------------------------------------
+ * 0x08000000 : Block#2 : 64[MB]
+ * --------------------------------------------------------
+ * 0x0C000000 : Block#3 : 64[MB]
+ * --------------------------------------------------------
+ * 0x10000000 : Block#4 : 64[MB]
+ * --------------------------------------------------------
+ * 0x14000000 : Block#5 : 64[MB]
+ * --------------------------------------------------------
+ * 0x18000000 : Block#6 : 64[MB]
+ * --------------------------------------------------------
+ * 0x1C000000 : Block#7 : 64[MB]
+ * --------------------------------------------------------
+ * 0xFE000000 : TLB
+ *              0xFE000000 : ITLB
+ *              0xFE000080 : reserved
+ *              0xFE000800 : DTLB
+ *              0xFE000880 : reserved
+ * --------------------------------------------------------
+ * 0xFF000000 : System area
+ *              0xFFFF0000 : MMU
+ *              0xFFFF0030 : reserved
+ *              0xFFFF8000 : Debug function
+ *              0xFFFFA000 : reserved
+ *              0xFFFFC000 : CPU control
+ * 0xFFFFFFFF
+ * ========================================================
+ */
+
+/*======================================================================*
+ * Special Function Register
+ *======================================================================*/
+#define M32R_SFR_OFFSET  (0x00E00000)  /* 0x03E00000-0x03EFFFFF 1[MB] */
+
+/*
+ * FPGA registers.
+ */
+#define M32R_FPGA_TOP  (0x000F0000+M32R_SFR_OFFSET)
+
+#define M32R_FPGA_NUM_OF_CPUS_PORTL  (0x00+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME0_PORTL    (0x10+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME1_PORTL    (0x14+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME2_PORTL    (0x18+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME3_PORTL    (0x1C+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID0_PORTL    (0x20+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID1_PORTL    (0x24+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID2_PORTL    (0x28+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID3_PORTL    (0x2C+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION0_PORTL     (0x30+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION1_PORTL     (0x34+M32R_FPGA_TOP)
+
+/*
+ * Clock and Power Manager registers.
+ */
+#define M32R_CPM_OFFSET  (0x000F4000+M32R_SFR_OFFSET)
+
+#define M32R_CPM_CPUCLKCR_PORTL  (0x00+M32R_CPM_OFFSET)
+#define M32R_CPM_CLKMOD_PORTL    (0x04+M32R_CPM_OFFSET)
+#define M32R_CPM_PLLCR_PORTL     (0x08+M32R_CPM_OFFSET)
+
+/*
+ * Block SELect Controller registers.
+ */
+#define M32R_BSELC_OFFSET  (0x000F5000+M32R_SFR_OFFSET)
+
+#define M32R_BSEL0_CR0_PORTL  (0x000+M32R_BSELC_OFFSET)
+#define M32R_BSEL0_CR1_PORTL  (0x004+M32R_BSELC_OFFSET)
+#define M32R_BSEL1_CR0_PORTL  (0x100+M32R_BSELC_OFFSET)
+#define M32R_BSEL1_CR1_PORTL  (0x104+M32R_BSELC_OFFSET)
+#define M32R_BSEL2_CR0_PORTL  (0x200+M32R_BSELC_OFFSET)
+#define M32R_BSEL2_CR1_PORTL  (0x204+M32R_BSELC_OFFSET)
+#define M32R_BSEL3_CR0_PORTL  (0x300+M32R_BSELC_OFFSET)
+#define M32R_BSEL3_CR1_PORTL  (0x304+M32R_BSELC_OFFSET)
+#define M32R_BSEL4_CR0_PORTL  (0x400+M32R_BSELC_OFFSET)
+#define M32R_BSEL4_CR1_PORTL  (0x404+M32R_BSELC_OFFSET)
+#define M32R_BSEL5_CR0_PORTL  (0x500+M32R_BSELC_OFFSET)
+#define M32R_BSEL5_CR1_PORTL  (0x504+M32R_BSELC_OFFSET)
+#define M32R_BSEL6_CR0_PORTL  (0x600+M32R_BSELC_OFFSET)
+#define M32R_BSEL6_CR1_PORTL  (0x604+M32R_BSELC_OFFSET)
+#define M32R_BSEL7_CR0_PORTL  (0x700+M32R_BSELC_OFFSET)
+#define M32R_BSEL7_CR1_PORTL  (0x704+M32R_BSELC_OFFSET)
+
+/*
+ * Multi Function Timer registers.
+ */
+#define M32R_MFT_OFFSET        (0x000FC000+M32R_SFR_OFFSET)
+
+#define M32R_MFTCR_PORTL       (0x000+M32R_MFT_OFFSET)  /* MFT control */
+#define M32R_MFTRPR_PORTL      (0x004+M32R_MFT_OFFSET)  /* MFT real port */
+
+#define M32R_MFT0_OFFSET       (0x100+M32R_MFT_OFFSET)
+#define M32R_MFT0MOD_PORTL     (0x00+M32R_MFT0_OFFSET)  /* MFT0 mode */
+#define M32R_MFT0BOS_PORTL     (0x04+M32R_MFT0_OFFSET)  /* MFT0 b-port output status */
+#define M32R_MFT0CUT_PORTL     (0x08+M32R_MFT0_OFFSET)  /* MFT0 count */
+#define M32R_MFT0RLD_PORTL     (0x0C+M32R_MFT0_OFFSET)  /* MFT0 reload */
+#define M32R_MFT0CMPRLD_PORTL  (0x10+M32R_MFT0_OFFSET)  /* MFT0 compare reload */
+
+#define M32R_MFT1_OFFSET       (0x200+M32R_MFT_OFFSET)
+#define M32R_MFT1MOD_PORTL     (0x00+M32R_MFT1_OFFSET)  /* MFT1 mode */
+#define M32R_MFT1BOS_PORTL     (0x04+M32R_MFT1_OFFSET)  /* MFT1 b-port output status */
+#define M32R_MFT1CUT_PORTL     (0x08+M32R_MFT1_OFFSET)  /* MFT1 count */
+#define M32R_MFT1RLD_PORTL     (0x0C+M32R_MFT1_OFFSET)  /* MFT1 reload */
+#define M32R_MFT1CMPRLD_PORTL  (0x10+M32R_MFT1_OFFSET)  /* MFT1 compare reload */
+
+#define M32R_MFT2_OFFSET       (0x300+M32R_MFT_OFFSET)
+#define M32R_MFT2MOD_PORTL     (0x00+M32R_MFT2_OFFSET)  /* MFT2 mode */
+#define M32R_MFT2BOS_PORTL     (0x04+M32R_MFT2_OFFSET)  /* MFT2 b-port output status */
+#define M32R_MFT2CUT_PORTL     (0x08+M32R_MFT2_OFFSET)  /* MFT2 count */
+#define M32R_MFT2RLD_PORTL     (0x0C+M32R_MFT2_OFFSET)  /* MFT2 reload */
+#define M32R_MFT2CMPRLD_PORTL  (0x10+M32R_MFT2_OFFSET)  /* MFT2 compare reload */
+
+#define M32R_MFT3_OFFSET       (0x400+M32R_MFT_OFFSET)
+#define M32R_MFT3MOD_PORTL     (0x00+M32R_MFT3_OFFSET)  /* MFT3 mode */
+#define M32R_MFT3BOS_PORTL     (0x04+M32R_MFT3_OFFSET)  /* MFT3 b-port output status */
+#define M32R_MFT3CUT_PORTL     (0x08+M32R_MFT3_OFFSET)  /* MFT3 count */
+#define M32R_MFT3RLD_PORTL     (0x0C+M32R_MFT3_OFFSET)  /* MFT3 reload */
+#define M32R_MFT3CMPRLD_PORTL  (0x10+M32R_MFT3_OFFSET)  /* MFT3 compare reload */
+
+#define M32R_MFT4_OFFSET       (0x500+M32R_MFT_OFFSET)
+#define M32R_MFT4MOD_PORTL     (0x00+M32R_MFT4_OFFSET)  /* MFT4 mode */
+#define M32R_MFT4BOS_PORTL     (0x04+M32R_MFT4_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT4CUT_PORTL     (0x08+M32R_MFT4_OFFSET)  /* MFT4 count */
+#define M32R_MFT4RLD_PORTL     (0x0C+M32R_MFT4_OFFSET)  /* MFT4 reload */
+#define M32R_MFT4CMPRLD_PORTL  (0x10+M32R_MFT4_OFFSET)  /* MFT4 compare reload */
+
+#define M32R_MFT5_OFFSET       (0x600+M32R_MFT_OFFSET)
+#define M32R_MFT5MOD_PORTL     (0x00+M32R_MFT5_OFFSET)  /* MFT4 mode */
+#define M32R_MFT5BOS_PORTL     (0x04+M32R_MFT5_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT5CUT_PORTL     (0x08+M32R_MFT5_OFFSET)  /* MFT4 count */
+#define M32R_MFT5RLD_PORTL     (0x0C+M32R_MFT5_OFFSET)  /* MFT4 reload */
+#define M32R_MFT5CMPRLD_PORTL  (0x10+M32R_MFT5_OFFSET)  /* MFT4 compare reload */
+
+#define M32R_MFTCR_MFT0MSK  (1UL<<15)  /* b16 */
+#define M32R_MFTCR_MFT1MSK  (1UL<<14)  /* b17 */
+#define M32R_MFTCR_MFT2MSK  (1UL<<13)  /* b18 */
+#define M32R_MFTCR_MFT3MSK  (1UL<<12)  /* b19 */
+#define M32R_MFTCR_MFT4MSK  (1UL<<11)  /* b20 */
+#define M32R_MFTCR_MFT5MSK  (1UL<<10)  /* b21 */
+#define M32R_MFTCR_MFT0EN   (1UL<<7)   /* b24 */
+#define M32R_MFTCR_MFT1EN   (1UL<<6)   /* b25 */
+#define M32R_MFTCR_MFT2EN   (1UL<<5)   /* b26 */
+#define M32R_MFTCR_MFT3EN   (1UL<<4)   /* b27 */
+#define M32R_MFTCR_MFT4EN   (1UL<<3)   /* b28 */
+#define M32R_MFTCR_MFT5EN   (1UL<<2)   /* b29 */
+
+#define M32R_MFTMOD_CC_MASK    (1UL<<15)  /* b16 */
+#define M32R_MFTMOD_TCCR       (1UL<<13)  /* b18 */
+#define M32R_MFTMOD_GTSEL000   (0UL<<8)   /* b21-23 : 000 */
+#define M32R_MFTMOD_GTSEL001   (1UL<<8)   /* b21-23 : 001 */
+#define M32R_MFTMOD_GTSEL010   (2UL<<8)   /* b21-23 : 010 */
+#define M32R_MFTMOD_GTSEL011   (3UL<<8)   /* b21-23 : 011 */
+#define M32R_MFTMOD_GTSEL110   (6UL<<8)   /* b21-23 : 110 */
+#define M32R_MFTMOD_GTSEL111   (7UL<<8)   /* b21-23 : 111 */
+#define M32R_MFTMOD_CMSEL      (1UL<<3)   /* b28 */
+#define M32R_MFTMOD_CSSEL000   (0UL<<0)   /* b29-b31 : 000 */
+#define M32R_MFTMOD_CSSEL001   (1UL<<0)   /* b29-b31 : 001 */
+#define M32R_MFTMOD_CSSEL010   (2UL<<0)   /* b29-b31 : 010 */
+#define M32R_MFTMOD_CSSEL011   (3UL<<0)   /* b29-b31 : 011 */
+#define M32R_MFTMOD_CSSEL100   (4UL<<0)   /* b29-b31 : 100 */
+#define M32R_MFTMOD_CSSEL110   (6UL<<0)   /* b29-b31 : 110 */
+
+/*
+ * Serial I/O registers.
+ */
+#define M32R_SIO_OFFSET  (0x000FD000+M32R_SFR_OFFSET)
+
+#define M32R_SIO0_CR_PORTL     (0x000+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD0_PORTL   (0x004+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD1_PORTL   (0x008+M32R_SIO_OFFSET)
+#define M32R_SIO0_STS_PORTL    (0x00C+M32R_SIO_OFFSET)
+#define M32R_SIO0_TRCR_PORTL   (0x010+M32R_SIO_OFFSET)
+#define M32R_SIO0_BAUR_PORTL   (0x014+M32R_SIO_OFFSET)
+#define M32R_SIO0_RBAUR_PORTL  (0x018+M32R_SIO_OFFSET)
+#define M32R_SIO0_TXB_PORTL    (0x01C+M32R_SIO_OFFSET)
+#define M32R_SIO0_RXB_PORTL    (0x020+M32R_SIO_OFFSET)
+
+/*
+ * Interrupt Control Unit registers.
+ */
+#define M32R_ICU_OFFSET  (0x000FF000+M32R_SFR_OFFSET)
+
+#define M32R_ICU_ISTS_PORTL     (0x004+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ0_PORTL    (0x008+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ1_PORTL    (0x00C+M32R_ICU_OFFSET)
+#define M32R_ICU_SBICR_PORTL    (0x018+M32R_ICU_OFFSET)
+#define M32R_ICU_IMASK_PORTL    (0x01C+M32R_ICU_OFFSET)
+#define M32R_ICU_CR1_PORTL      (0x200+M32R_ICU_OFFSET)  /* INT0 */
+#define M32R_ICU_CR2_PORTL      (0x204+M32R_ICU_OFFSET)  /* INT1 */
+#define M32R_ICU_CR3_PORTL      (0x208+M32R_ICU_OFFSET)  /* INT2 */
+#define M32R_ICU_CR4_PORTL      (0x20C+M32R_ICU_OFFSET)  /* INT3 */
+#define M32R_ICU_CR5_PORTL      (0x210+M32R_ICU_OFFSET)  /* INT4 */
+#define M32R_ICU_CR6_PORTL      (0x214+M32R_ICU_OFFSET)  /* INT5 */
+#define M32R_ICU_CR7_PORTL      (0x218+M32R_ICU_OFFSET)  /* INT6 */
+#define M32R_ICU_CR8_PORTL      (0x218+M32R_ICU_OFFSET)  /* INT7 */
+#define M32R_ICU_CR32_PORTL     (0x27C+M32R_ICU_OFFSET)  /* SIO0 RX */
+#define M32R_ICU_CR33_PORTL     (0x280+M32R_ICU_OFFSET)  /* SIO0 TX */
+#define M32R_ICU_CR40_PORTL     (0x29C+M32R_ICU_OFFSET)  /* DMAC0 */
+#define M32R_ICU_CR41_PORTL     (0x2A0+M32R_ICU_OFFSET)  /* DMAC1 */
+#define M32R_ICU_CR48_PORTL     (0x2BC+M32R_ICU_OFFSET)  /* MFT0 */
+#define M32R_ICU_CR49_PORTL     (0x2C0+M32R_ICU_OFFSET)  /* MFT1 */
+#define M32R_ICU_CR50_PORTL     (0x2C4+M32R_ICU_OFFSET)  /* MFT2 */
+#define M32R_ICU_CR51_PORTL     (0x2C8+M32R_ICU_OFFSET)  /* MFT3 */
+#define M32R_ICU_CR52_PORTL     (0x2CC+M32R_ICU_OFFSET)  /* MFT4 */
+#define M32R_ICU_CR53_PORTL     (0x2D0+M32R_ICU_OFFSET)  /* MFT5 */
+#define M32R_ICU_IPICR0_PORTL   (0x2DC+M32R_ICU_OFFSET)  /* IPI0 */
+#define M32R_ICU_IPICR1_PORTL   (0x2E0+M32R_ICU_OFFSET)  /* IPI1 */
+#define M32R_ICU_IPICR2_PORTL   (0x2E4+M32R_ICU_OFFSET)  /* IPI2 */
+#define M32R_ICU_IPICR3_PORTL   (0x2E8+M32R_ICU_OFFSET)  /* IPI3 */
+#define M32R_ICU_IPICR4_PORTL   (0x2EC+M32R_ICU_OFFSET)  /* IPI4 */
+#define M32R_ICU_IPICR5_PORTL   (0x2F0+M32R_ICU_OFFSET)  /* IPI5 */
+#define M32R_ICU_IPICR6_PORTL   (0x2F4+M32R_ICU_OFFSET)  /* IPI6 */
+#define M32R_ICU_IPICR7_PORTL   (0x2FC+M32R_ICU_OFFSET)  /* IPI7 */
+
+#define M32R_ICUISTS_VECB(val)  ((val>>28) & 0xF)
+#define M32R_ICUISTS_ISN(val)   ((val>>22) & 0x3F)
+#define M32R_ICUISTS_PIML(val)  ((val>>16) & 0x7)
+
+#define M32R_ICUIMASK_IMSK0  (0UL<<16)  /* b13-b15: Disable interrupt */
+#define M32R_ICUIMASK_IMSK1  (1UL<<16)  /* b13-b15: Enable level 0 interrupt */
+#define M32R_ICUIMASK_IMSK2  (2UL<<16)  /* b13-b15: Enable level 0,1 interrupt */
+#define M32R_ICUIMASK_IMSK3  (3UL<<16)  /* b13-b15: Enable level 0-2 interrupt */
+#define M32R_ICUIMASK_IMSK4  (4UL<<16)  /* b13-b15: Enable level 0-3 interrupt */
+#define M32R_ICUIMASK_IMSK5  (5UL<<16)  /* b13-b15: Enable level 0-4 interrupt */
+#define M32R_ICUIMASK_IMSK6  (6UL<<16)  /* b13-b15: Enable level 0-5 interrupt */
+#define M32R_ICUIMASK_IMSK7  (7UL<<16)  /* b13-b15: Enable level 0-6 interrupt */
+
+#define M32R_ICUCR_IEN      (1UL<<12)  /* b19: Interrupt enable */
+#define M32R_ICUCR_IRQ      (1UL<<8)   /* b23: Interrupt request */
+#define M32R_ICUCR_ISMOD00  (0UL<<4)   /* b26-b27: Interrupt sense mode Edge HtoL */
+#define M32R_ICUCR_ISMOD01  (1UL<<4)   /* b26-b27: Interrupt sense mode Level L */
+#define M32R_ICUCR_ISMOD10  (2UL<<4)   /* b26-b27: Interrupt sense mode Edge LtoH*/
+#define M32R_ICUCR_ISMOD11  (3UL<<4)   /* b26-b27: Interrupt sense mode Level H */
+#define M32R_ICUCR_ILEVEL0  (0UL<<0)   /* b29-b31: Interrupt priority level 0 */
+#define M32R_ICUCR_ILEVEL1  (1UL<<0)   /* b29-b31: Interrupt priority level 1 */
+#define M32R_ICUCR_ILEVEL2  (2UL<<0)   /* b29-b31: Interrupt priority level 2 */
+#define M32R_ICUCR_ILEVEL3  (3UL<<0)   /* b29-b31: Interrupt priority level 3 */
+#define M32R_ICUCR_ILEVEL4  (4UL<<0)   /* b29-b31: Interrupt priority level 4 */
+#define M32R_ICUCR_ILEVEL5  (5UL<<0)   /* b29-b31: Interrupt priority level 5 */
+#define M32R_ICUCR_ILEVEL6  (6UL<<0)   /* b29-b31: Interrupt priority level 6 */
+#define M32R_ICUCR_ILEVEL7  (7UL<<0)   /* b29-b31: Disable interrupt */
+#define M32R_ICUCR_ILEVEL_MASK  (7UL)
+
+#define M32R_IRQ_INT0    (1)   /* INT0 */
+#define M32R_IRQ_INT1    (2)   /* INT1 */
+#define M32R_IRQ_INT2    (3)   /* INT2 */
+#define M32R_IRQ_INT3    (4)   /* INT3 */
+#define M32R_IRQ_INT4    (5)   /* INT4 */
+#define M32R_IRQ_INT5    (6)   /* INT5 */
+#define M32R_IRQ_INT6    (7)   /* INT6 */
+#define M32R_IRQ_INT7    (8)   /* INT7 */
+#define M32R_IRQ_MFT0    (16)  /* MFT0 */
+#define M32R_IRQ_MFT1    (17)  /* MFT1 */
+#define M32R_IRQ_MFT2    (18)  /* MFT2 */
+#define M32R_IRQ_MFT3    (19)  /* MFT3 */
+#define M32R_IRQ_MFT4    (20)  /* MFT4 */
+#define M32R_IRQ_MFT5    (21)  /* MFT5 */
+#define M32R_IRQ_DMAC0   (32)  /* DMAC0 */
+#define M32R_IRQ_DMAC1   (33)  /* DMAC1 */
+#define M32R_IRQ_SIO0_R  (48)  /* SIO0 receive */
+#define M32R_IRQ_SIO0_S  (49)  /* SIO0 send    */
+#define M32R_IRQ_SIO1_R  (50)  /* SIO1 send    */
+#define M32R_IRQ_SIO1_S  (51)  /* SIO1 receive */
+#define M32R_IRQ_IPI0    (56)  /* IPI0 */
+#define M32R_IRQ_IPI1    (57)  /* IPI1 */
+#define M32R_IRQ_IPI2    (58)  /* IPI2 */
+#define M32R_IRQ_IPI3    (59)  /* IPI3 */
+#define M32R_IRQ_IPI4    (60)  /* IPI4 */
+#define M32R_IRQ_IPI5    (61)  /* IPI5 */
+#define M32R_IRQ_IPI6    (62)  /* IPI6 */
+#define M32R_IRQ_IPI7    (63)  /* IPI7 */
+
+/*======================================================================*
+ * CPU
+ *======================================================================*/
+
+#define M32R_CPUID_PORTL   (0xFFFFFFE0)
+#define M32R_MCICAR_PORTL  (0xFFFFFFF0)
+#define M32R_MCDCAR_PORTL  (0xFFFFFFF4)
+#define M32R_MCCR_PORTL    (0xFFFFFFFC)
+
+#endif  /* _ASM_M32R_M32R_MP_FPGA_ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mappi2/mappi2_pld.h linux-2.6.30-rc3/arch/m32r/include/asm/mappi2/mappi2_pld.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mappi2/mappi2_pld.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mappi2/mappi2_pld.h	2009-04-22 03:29:16.270556925 +0000
@@ -0,0 +1,150 @@
+#ifndef _MAPPI2_PLD_H
+#define _MAPPI2_PLD_H
+
+/*
+ * include/asm-m32r/mappi2/mappi2_pld.h
+ *
+ * Definitions for Extended IO Logic on MAPPI2 board.
+ *  based on m32700ut_pld.h
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#ifndef __ASSEMBLY__
+/* FIXME:
+ * Some C functions use non-cache address, so can't define non-cache address.
+ */
+#define PLD_BASE		(0x10c00000 /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(0x10c00000 + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif /* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
+#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+
+
+/*==== ICU ====*/
+#define  M32R_IRQ_PC104        (5)   /* INT4(PC/104) */
+#define  M32R_IRQ_I2C          (28)  /* I2C-BUS     */
+#if 1
+#define  PLD_IRQ_CFIREQ       (40)  /* CFC Card Interrupt */
+#define  PLD_IRQ_CFC_INSERT   (41)  /* CFC Card Insert */
+#define  PLD_IRQ_CFC_EJECT    (42)  /* CFC Card Eject */
+#define  PLD_IRQ_MMCCARD      (43)  /* MMC Card Insert */
+#define  PLD_IRQ_MMCIRQ       (44)  /* MMC Transfer Done */
+#else
+#define  PLD_IRQ_CFIREQ       (34)  /* CFC Card Interrupt */
+#define  PLD_IRQ_CFC_INSERT   (35)  /* CFC Card Insert */
+#define  PLD_IRQ_CFC_EJECT    (36)  /* CFC Card Eject */
+#define  PLD_IRQ_MMCCARD      (37)  /* MMC Card Insert */
+#define  PLD_IRQ_MMCIRQ       (38)  /* MMC Transfer Done */
+#endif
+
+
+#if 0
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+#endif
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+
+#if 0
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIO0 */
+#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
+#define	PLD_ESIO0CR_TXEN	0x0001
+#define	PLD_ESIO0CR_RXEN	0x0002
+#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
+#define	PLD_ESIO0MOD0_CTSS	0x0040
+#define	PLD_ESIO0MOD0_RTSS	0x0080
+#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
+#define	PLD_ESIO0MOD1_LMFS	0x0010
+#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
+#define	PLD_ESIO0STS_TEMP	0x0001
+#define	PLD_ESIO0STS_TXCP	0x0002
+#define	PLD_ESIO0STS_RXCP	0x0004
+#define	PLD_ESIO0STS_TXSC	0x0100
+#define	PLD_ESIO0STS_RXSC	0x0200
+#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
+#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
+#define	PLD_ESIO0INTCR_TXIEN	0x0002
+#define	PLD_ESIO0INTCR_RXCEN	0x0004
+#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
+#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
+#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif
+
+#endif /* _MAPPI2_PLD.H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mappi3/mappi3_pld.h linux-2.6.30-rc3/arch/m32r/include/asm/mappi3/mappi3_pld.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mappi3/mappi3_pld.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mappi3/mappi3_pld.h	2009-04-22 03:29:16.270556925 +0000
@@ -0,0 +1,142 @@
+#ifndef _MAPPI3_PLD_H
+#define _MAPPI3_PLD_H
+
+/*
+ * include/asm-m32r/mappi3/mappi3_pld.h
+ *
+ * Definitions for Extended IO Logic on MAPPI3 board.
+ *  based on m32700ut_pld.h
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#ifndef __ASSEMBLY__
+/* FIXME:
+ * Some C functions use non-cache address, so can't define non-cache address.
+ */
+#define PLD_BASE		(0x1c000000 /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(0x1c000000 + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif /* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
+#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+
+/* ICU */
+#define M32R_IRQ_PC104		(5)	/* INT4(PC/104) */
+#define M32R_IRQ_I2C		(28)	/* I2C-BUS */
+#define PLD_IRQ_CFIREQ		(6)	/* INT5 CFC Card Interrupt */
+#define PLD_IRQ_CFC_INSERT	(7)	/* INT6 CFC Card Insert & Eject */
+#define PLD_IRQ_IDEIREQ		(8)	/* INT7 IDE Interrupt */
+#define PLD_IRQ_MMCCARD		(43)	/* MMC Card Insert */
+#define PLD_IRQ_MMCIRQ		(44)	/* MMC Transfer Done */
+
+#if 0
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+#endif
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+#if 0
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIO0 */
+#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
+#define	PLD_ESIO0CR_TXEN	0x0001
+#define	PLD_ESIO0CR_RXEN	0x0002
+#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
+#define	PLD_ESIO0MOD0_CTSS	0x0040
+#define	PLD_ESIO0MOD0_RTSS	0x0080
+#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
+#define	PLD_ESIO0MOD1_LMFS	0x0010
+#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
+#define	PLD_ESIO0STS_TEMP	0x0001
+#define	PLD_ESIO0STS_TXCP	0x0002
+#define	PLD_ESIO0STS_RXCP	0x0004
+#define	PLD_ESIO0STS_TXSC	0x0100
+#define	PLD_ESIO0STS_RXSC	0x0200
+#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
+#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
+#define	PLD_ESIO0INTCR_TXIEN	0x0002
+#define	PLD_ESIO0INTCR_RXCEN	0x0004
+#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
+#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
+#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif
+
+/* Reset Control */
+#define PLD_REBOOT		__reg16(PLD_BASE + 0x38000)
+
+#endif /* _MAPPI3_PLD.H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mc146818rtc.h linux-2.6.30-rc3/arch/m32r/include/asm/mc146818rtc.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mc146818rtc.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mc146818rtc.h	2009-04-22 03:29:16.270556925 +0000
@@ -0,0 +1,29 @@
+/*
+ * Machine dependent access functions for RTC registers.
+ */
+#ifndef _ASM_MC146818RTC_H
+#define _ASM_MC146818RTC_H
+
+#include <asm/io.h>
+
+#ifndef RTC_PORT
+#define RTC_PORT(x)	((x))
+#define RTC_ALWAYS_BCD	1	/* RTC operates in binary mode */
+#endif
+
+/*
+ * The yet supported machines all access the RTC index register via
+ * an ISA port access but the way to access the date register differs ...
+ */
+#define CMOS_READ(addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+inb_p(RTC_PORT(1)); \
+})
+#define CMOS_WRITE(val, addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+outb_p((val),RTC_PORT(1)); \
+})
+
+#define RTC_IRQ 8
+
+#endif /* _ASM_MC146818RTC_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mman.h linux-2.6.30-rc3/arch/m32r/include/asm/mman.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mman.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mman.h	2009-04-22 03:29:16.270556925 +0000
@@ -0,0 +1,17 @@
+#ifndef __M32R_MMAN_H__
+#define __M32R_MMAN_H__
+
+#include <asm-generic/mman.h>
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+#define MAP_NORESERVE	0x4000		/* don't check for reservations */
+#define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x10000		/* do not block on IO */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#endif /* __M32R_MMAN_H__ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mmu.h linux-2.6.30-rc3/arch/m32r/include/asm/mmu.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mmu.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mmu.h	2009-04-22 03:29:16.270556925 +0000
@@ -0,0 +1,21 @@
+#ifndef _ASM_M32R_MMU_H
+#define _ASM_M32R_MMU_H
+
+#if !defined(CONFIG_MMU)
+
+typedef struct {
+	unsigned long		end_brk;
+} mm_context_t;
+
+#else /* CONFIG_MMU */
+
+/* Default "unsigned long" context */
+#ifndef CONFIG_SMP
+typedef unsigned long mm_context_t;
+#else
+typedef unsigned long mm_context_t[NR_CPUS];
+#endif
+
+#endif /* CONFIG_MMU */
+
+#endif /* _ASM_M32R_MMU_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mmu_context.h linux-2.6.30-rc3/arch/m32r/include/asm/mmu_context.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mmu_context.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mmu_context.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,164 @@
+#ifndef _ASM_M32R_MMU_CONTEXT_H
+#define _ASM_M32R_MMU_CONTEXT_H
+#ifdef __KERNEL__
+
+#include <asm/m32r.h>
+
+#define MMU_CONTEXT_ASID_MASK      (0x000000FF)
+#define MMU_CONTEXT_VERSION_MASK   (0xFFFFFF00)
+#define MMU_CONTEXT_FIRST_VERSION  (0x00000100)
+#define NO_CONTEXT                 (0x00000000)
+
+#ifndef __ASSEMBLY__
+
+#include <asm/atomic.h>
+#include <asm/pgalloc.h>
+#include <asm/mmu.h>
+#include <asm/tlbflush.h>
+#include <asm-generic/mm_hooks.h>
+
+/*
+ * Cache of MMU context last used.
+ */
+#ifndef CONFIG_SMP
+extern unsigned long mmu_context_cache_dat;
+#define mmu_context_cache	mmu_context_cache_dat
+#define mm_context(mm)		mm->context
+#else /* not CONFIG_SMP */
+extern unsigned long mmu_context_cache_dat[];
+#define mmu_context_cache	mmu_context_cache_dat[smp_processor_id()]
+#define mm_context(mm)		mm->context[smp_processor_id()]
+#endif /* not CONFIG_SMP */
+
+#define set_tlb_tag(entry, tag)		(*entry = (tag & PAGE_MASK)|get_asid())
+#define set_tlb_data(entry, data)	(*entry = (data | _PAGE_PRESENT))
+
+#ifdef CONFIG_MMU
+#define enter_lazy_tlb(mm, tsk)	do { } while (0)
+
+static inline void get_new_mmu_context(struct mm_struct *mm)
+{
+	unsigned long mc = ++mmu_context_cache;
+
+	if (!(mc & MMU_CONTEXT_ASID_MASK)) {
+		/* We exhaust ASID of this version.
+		   Flush all TLB and start new cycle. */
+		local_flush_tlb_all();
+		/* Fix version if needed.
+		   Note that we avoid version #0 to distingush NO_CONTEXT. */
+		if (!mc)
+			mmu_context_cache = mc = MMU_CONTEXT_FIRST_VERSION;
+	}
+	mm_context(mm) = mc;
+}
+
+/*
+ * Get MMU context if needed.
+ */
+static inline void get_mmu_context(struct mm_struct *mm)
+{
+	if (mm) {
+		unsigned long mc = mmu_context_cache;
+
+		/* Check if we have old version of context.
+		   If it's old, we need to get new context with new version. */
+		if ((mm_context(mm) ^ mc) & MMU_CONTEXT_VERSION_MASK)
+			get_new_mmu_context(mm);
+	}
+}
+
+/*
+ * Initialize the context related info for a new mm_struct
+ * instance.
+ */
+static inline int init_new_context(struct task_struct *tsk,
+	struct mm_struct *mm)
+{
+#ifndef CONFIG_SMP
+	mm->context = NO_CONTEXT;
+#else /* CONFIG_SMP */
+	int num_cpus = num_online_cpus();
+	int i;
+
+	for (i = 0 ; i < num_cpus ; i++)
+		mm->context[i] = NO_CONTEXT;
+#endif /* CONFIG_SMP */
+
+	return 0;
+}
+
+/*
+ * Destroy context related info for an mm_struct that is about
+ * to be put to rest.
+ */
+#define destroy_context(mm)	do { } while (0)
+
+static inline void set_asid(unsigned long asid)
+{
+	*(volatile unsigned long *)MASID = (asid & MMU_CONTEXT_ASID_MASK);
+}
+
+static inline unsigned long get_asid(void)
+{
+	unsigned long asid;
+
+	asid = *(volatile long *)MASID;
+	asid &= MMU_CONTEXT_ASID_MASK;
+
+	return asid;
+}
+
+/*
+ * After we have set current->mm to a new value, this activates
+ * the context for the new mm so we see the new mappings.
+ */
+static inline void activate_context(struct mm_struct *mm)
+{
+	get_mmu_context(mm);
+	set_asid(mm_context(mm) & MMU_CONTEXT_ASID_MASK);
+}
+
+static inline void switch_mm(struct mm_struct *prev,
+	struct mm_struct *next, struct task_struct *tsk)
+{
+#ifdef CONFIG_SMP
+	int cpu = smp_processor_id();
+#endif	/* CONFIG_SMP */
+
+	if (prev != next) {
+#ifdef CONFIG_SMP
+		cpu_set(cpu, next->cpu_vm_mask);
+#endif /* CONFIG_SMP */
+		/* Set MPTB = next->pgd */
+		*(volatile unsigned long *)MPTB = (unsigned long)next->pgd;
+		activate_context(next);
+	}
+#ifdef CONFIG_SMP
+	else
+		if (!cpu_test_and_set(cpu, next->cpu_vm_mask))
+			activate_context(next);
+#endif /* CONFIG_SMP */
+}
+
+#define deactivate_mm(tsk, mm)	do { } while (0)
+
+#define activate_mm(prev, next)	\
+	switch_mm((prev), (next), NULL)
+
+#else /* not CONFIG_MMU */
+#define get_mmu_context(mm)             do { } while (0)
+#define init_new_context(tsk,mm)        (0)
+#define destroy_context(mm)             do { } while (0)
+#define set_asid(asid)                  do { } while (0)
+#define get_asid()                      (0)
+#define activate_context(mm)            do { } while (0)
+#define switch_mm(prev,next,tsk)        do { } while (0)
+#define deactivate_mm(mm,tsk)           do { } while (0)
+#define activate_mm(prev,next)          do { } while (0)
+#define enter_lazy_tlb(mm,tsk)          do { } while (0)
+#endif /* not CONFIG_MMU */
+
+#endif /* not __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+#endif /* _ASM_M32R_MMU_CONTEXT_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mmzone.h linux-2.6.30-rc3/arch/m32r/include/asm/mmzone.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mmzone.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mmzone.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,59 @@
+/*
+ * Written by Pat Gaughen (gone@us.ibm.com) Mar 2002
+ *
+ */
+
+#ifndef _ASM_MMZONE_H_
+#define _ASM_MMZONE_H_
+
+#include <asm/smp.h>
+
+#ifdef CONFIG_DISCONTIGMEM
+
+extern struct pglist_data *node_data[];
+#define NODE_DATA(nid)		(node_data[nid])
+
+#define node_localnr(pfn, nid)	((pfn) - NODE_DATA(nid)->node_start_pfn)
+#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
+#define node_end_pfn(nid)						\
+({									\
+	pg_data_t *__pgdat = NODE_DATA(nid);				\
+	__pgdat->node_start_pfn + __pgdat->node_spanned_pages - 1;	\
+})
+
+#define pmd_page(pmd)		(pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
+/*
+ * pfn_valid should be made as fast as possible, and the current definition
+ * is valid for machines that are NUMA, but still contiguous, which is what
+ * is currently supported. A more generalised, but slower definition would
+ * be something like this - mbligh:
+ * ( pfn_to_pgdat(pfn) && ((pfn) < node_end_pfn(pfn_to_nid(pfn))) )
+ */
+#if 1	/* M32R_FIXME */
+#define pfn_valid(pfn)	(1)
+#else
+#define pfn_valid(pfn)	((pfn) < num_physpages)
+#endif
+
+/*
+ * generic node memory support, the following assumptions apply:
+ */
+
+static __inline__ int pfn_to_nid(unsigned long pfn)
+{
+	int node;
+
+	for (node = 0 ; node < MAX_NUMNODES ; node++)
+		if (pfn >= node_start_pfn(node) && pfn <= node_end_pfn(node))
+			break;
+
+	return node;
+}
+
+static __inline__ struct pglist_data *pfn_to_pgdat(unsigned long pfn)
+{
+	return(NODE_DATA(pfn_to_nid(pfn)));
+}
+
+#endif /* CONFIG_DISCONTIGMEM */
+#endif /* _ASM_MMZONE_H_ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/module.h linux-2.6.30-rc3/arch/m32r/include/asm/module.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/module.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/module.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,10 @@
+#ifndef _ASM_M32R_MODULE_H
+#define _ASM_M32R_MODULE_H
+
+struct mod_arch_specific { };
+
+#define Elf_Shdr	Elf32_Shdr
+#define Elf_Sym		Elf32_Sym
+#define Elf_Ehdr	Elf32_Ehdr
+
+#endif /* _ASM_M32R_MODULE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/msgbuf.h linux-2.6.30-rc3/arch/m32r/include/asm/msgbuf.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/msgbuf.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/msgbuf.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,31 @@
+#ifndef _ASM_M32R_MSGBUF_H
+#define _ASM_M32R_MSGBUF_H
+
+/*
+ * The msqid64_ds structure for m32r architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long	__unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long	__unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long	__unused3;
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif /* _ASM_M32R_MSGBUF_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/mutex.h linux-2.6.30-rc3/arch/m32r/include/asm/mutex.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/mutex.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/mutex.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,9 @@
+/*
+ * Pull in the generic implementation for the mutex fastpath.
+ *
+ * TODO: implement optimized primitives instead, or leave the generic
+ * implementation in place, or pick the atomic_xchg() based generic
+ * implementation. (see asm-generic/mutex-xchg.h for details)
+ */
+
+#include <asm-generic/mutex-dec.h>
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/opsput/opsput_lan.h linux-2.6.30-rc3/arch/m32r/include/asm/opsput/opsput_lan.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/opsput/opsput_lan.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/opsput/opsput_lan.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,52 @@
+#ifndef _OPSPUT_OPSPUT_LAN_H
+#define _OPSPUT_OPSPUT_LAN_H
+
+/*
+ * include/asm-m32r/opsput/opsput_lan.h
+ *
+ * OPSPUT-LAN board
+ *
+ * Copyright (c) 2002-2004	Takeo Takahashi, Mamoru Sakugawa
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define OPSPUT_LAN_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define OPSPUT_LAN_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif /* __ASSEMBLY__ */
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#define OPSPUT_LAN_IRQ_LAN	(OPSPUT_LAN_PLD_IRQ_BASE + 1)	/* LAN */
+#define OPSPUT_LAN_IRQ_I2C	(OPSPUT_LAN_PLD_IRQ_BASE + 3)	/* I2C */
+
+#define OPSPUT_LAN_ICUISTS	__reg16(OPSPUT_LAN_BASE + 0xc0002)
+#define OPSPUT_LAN_ICUISTS_VECB_MASK	(0xf000)
+#define OPSPUT_LAN_VECB(x)	((x) & OPSPUT_LAN_ICUISTS_VECB_MASK)
+#define OPSPUT_LAN_ICUISTS_ISN_MASK	(0x07c0)
+#define OPSPUT_LAN_ICUISTS_ISN(x)	((x) & OPSPUT_LAN_ICUISTS_ISN_MASK)
+#define OPSPUT_LAN_ICUIREQ0	__reg16(OPSPUT_LAN_BASE + 0xc0004)
+#define OPSPUT_LAN_ICUCR1	__reg16(OPSPUT_LAN_BASE + 0xc0010)
+#define OPSPUT_LAN_ICUCR3	__reg16(OPSPUT_LAN_BASE + 0xc0014)
+
+#endif /* _OPSPUT_OPSPUT_LAN_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/opsput/opsput_lcd.h linux-2.6.30-rc3/arch/m32r/include/asm/opsput/opsput_lcd.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/opsput/opsput_lcd.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/opsput/opsput_lcd.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,55 @@
+#ifndef _OPSPUT_OPSPUT_LCD_H
+#define _OPSPUT_OPSPUT_LCD_H
+
+/*
+ * include/asm-m32r/opsput/opsput_lcd.h
+ *
+ * OPSPUT-LCD board
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define OPSPUT_LCD_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define OPSPUT_LCD_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif /* __ASSEMBLY__ */
+
+/*
+ * ICU
+ */
+#define OPSPUT_LCD_IRQ_BAT_INT	(OPSPUT_LCD_PLD_IRQ_BASE + 1)
+#define OPSPUT_LCD_IRQ_USB_INT1	(OPSPUT_LCD_PLD_IRQ_BASE + 2)
+#define OPSPUT_LCD_IRQ_AUDT0		(OPSPUT_LCD_PLD_IRQ_BASE + 3)
+#define OPSPUT_LCD_IRQ_AUDT2		(OPSPUT_LCD_PLD_IRQ_BASE + 4)
+#define OPSPUT_LCD_IRQ_BATSIO_RCV	(OPSPUT_LCD_PLD_IRQ_BASE + 16)
+#define OPSPUT_LCD_IRQ_BATSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 17)
+#define OPSPUT_LCD_IRQ_ASNDSIO_RCV	(OPSPUT_LCD_PLD_IRQ_BASE + 18)
+#define OPSPUT_LCD_IRQ_ASNDSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 19)
+#define OPSPUT_LCD_IRQ_ACNLSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 21)
+
+#define OPSPUT_LCD_ICUISTS	__reg16(OPSPUT_LCD_BASE + 0x300002)
+#define OPSPUT_LCD_ICUISTS_VECB_MASK	(0xf000)
+#define OPSPUT_LCD_VECB(x)	((x) & OPSPUT_LCD_ICUISTS_VECB_MASK)
+#define OPSPUT_LCD_ICUISTS_ISN_MASK	(0x07c0)
+#define OPSPUT_LCD_ICUISTS_ISN(x)	((x) & OPSPUT_LCD_ICUISTS_ISN_MASK)
+#define OPSPUT_LCD_ICUIREQ0	__reg16(OPSPUT_LCD_BASE + 0x300004)
+#define OPSPUT_LCD_ICUIREQ1	__reg16(OPSPUT_LCD_BASE + 0x300006)
+#define OPSPUT_LCD_ICUCR1	__reg16(OPSPUT_LCD_BASE + 0x300020)
+#define OPSPUT_LCD_ICUCR2	__reg16(OPSPUT_LCD_BASE + 0x300022)
+#define OPSPUT_LCD_ICUCR3	__reg16(OPSPUT_LCD_BASE + 0x300024)
+#define OPSPUT_LCD_ICUCR4	__reg16(OPSPUT_LCD_BASE + 0x300026)
+#define OPSPUT_LCD_ICUCR16	__reg16(OPSPUT_LCD_BASE + 0x300030)
+#define OPSPUT_LCD_ICUCR17	__reg16(OPSPUT_LCD_BASE + 0x300032)
+#define OPSPUT_LCD_ICUCR18	__reg16(OPSPUT_LCD_BASE + 0x300034)
+#define OPSPUT_LCD_ICUCR19	__reg16(OPSPUT_LCD_BASE + 0x300036)
+#define OPSPUT_LCD_ICUCR21	__reg16(OPSPUT_LCD_BASE + 0x30003a)
+
+#endif /* _OPSPUT_OPSPUT_LCD_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/opsput/opsput_pld.h linux-2.6.30-rc3/arch/m32r/include/asm/opsput/opsput_pld.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/opsput/opsput_pld.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/opsput/opsput_pld.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,255 @@
+#ifndef _OPSPUT_OPSPUT_PLD_H
+#define _OPSPUT_OPSPUT_PLD_H
+
+/*
+ * include/asm-m32r/opsput/opsput_pld.h
+ *
+ * Definitions for Programable Logic Device(PLD) on OPSPUT board.
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of
+ * this archive for more details.
+ */
+
+#define PLD_PLAT_BASE		0x1cc00000
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif /* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+#define PLD_CFVENCR		__reg16(PLD_BASE + 0x0008)
+#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
+#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
+#define PLD_IDERSTCR		__reg16(PLD_BASE + 0x0010)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#if !defined(CONFIG_PLAT_USRV)
+#define PLD_IRQ_INT0		(OPSPUT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(OPSPUT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(OPSPUT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CFIREQ		(OPSPUT_PLD_IRQ_BASE + 3)	/* CF IREQ */
+#define PLD_IRQ_CFC_INSERT	(OPSPUT_PLD_IRQ_BASE + 4)	/* CF Insert */
+#define PLD_IRQ_CFC_EJECT	(OPSPUT_PLD_IRQ_BASE + 5)	/* CF Eject */
+#define PLD_IRQ_EXINT		(OPSPUT_PLD_IRQ_BASE + 6)	/* EXINT */
+#define PLD_IRQ_INT7		(OPSPUT_PLD_IRQ_BASE + 7)	/* reserved */
+#define PLD_IRQ_INT8		(OPSPUT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(OPSPUT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(OPSPUT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_MMCCARD		(OPSPUT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
+#define PLD_IRQ_INT12		(OPSPUT_PLD_IRQ_BASE + 12)	/* reserved */
+#define PLD_IRQ_SC_ERROR	(OPSPUT_PLD_IRQ_BASE + 13)	/* SC error */
+#define PLD_IRQ_SC_RCV		(OPSPUT_PLD_IRQ_BASE + 14)	/* SC receive */
+#define PLD_IRQ_SC_SND		(OPSPUT_PLD_IRQ_BASE + 15)	/* SC send */
+#define PLD_IRQ_SIO0_RCV	(OPSPUT_PLD_IRQ_BASE + 16)	/* SIO receive */
+#define PLD_IRQ_SIO0_SND	(OPSPUT_PLD_IRQ_BASE + 17)	/* SIO send */
+#define PLD_IRQ_INT18		(OPSPUT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(OPSPUT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(OPSPUT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(OPSPUT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(OPSPUT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(OPSPUT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(OPSPUT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(OPSPUT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(OPSPUT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(OPSPUT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(OPSPUT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(OPSPUT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(OPSPUT_PLD_IRQ_BASE + 30)	/* reserved */
+#define PLD_IRQ_INT31		(OPSPUT_PLD_IRQ_BASE + 31)	/* reserved */
+
+#else	/* CONFIG_PLAT_USRV */
+
+#define PLD_IRQ_INT0		(OPSPUT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(OPSPUT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(OPSPUT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CF0		(OPSPUT_PLD_IRQ_BASE + 3)	/* CF0# */
+#define PLD_IRQ_CF1		(OPSPUT_PLD_IRQ_BASE + 4)	/* CF1# */
+#define PLD_IRQ_CF2		(OPSPUT_PLD_IRQ_BASE + 5)	/* CF2# */
+#define PLD_IRQ_CF3		(OPSPUT_PLD_IRQ_BASE + 6)	/* CF3# */
+#define PLD_IRQ_CF4		(OPSPUT_PLD_IRQ_BASE + 7)	/* CF4# */
+#define PLD_IRQ_INT8		(OPSPUT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(OPSPUT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(OPSPUT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_INT11		(OPSPUT_PLD_IRQ_BASE + 11)	/* reserved */
+#define PLD_IRQ_UART0		(OPSPUT_PLD_IRQ_BASE + 12)	/* UARTIRQ0 */
+#define PLD_IRQ_UART1		(OPSPUT_PLD_IRQ_BASE + 13)	/* UARTIRQ1 */
+#define PLD_IRQ_INT14		(OPSPUT_PLD_IRQ_BASE + 14)	/* reserved */
+#define PLD_IRQ_INT15		(OPSPUT_PLD_IRQ_BASE + 15)	/* reserved */
+#define PLD_IRQ_SNDINT		(OPSPUT_PLD_IRQ_BASE + 16)	/* SNDINT# */
+#define PLD_IRQ_INT17		(OPSPUT_PLD_IRQ_BASE + 17)	/* reserved */
+#define PLD_IRQ_INT18		(OPSPUT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(OPSPUT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(OPSPUT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(OPSPUT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(OPSPUT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(OPSPUT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(OPSPUT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(OPSPUT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(OPSPUT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(OPSPUT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(OPSPUT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(OPSPUT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(OPSPUT_PLD_IRQ_BASE + 30)	/* reserved */
+
+#endif	/* CONFIG_PLAT_USRV */
+
+#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
+#define PLD_ICUISTS_VECB_MASK	(0xf000)
+#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
+#define PLD_ICUISTS_ISN_MASK	(0x07c0)
+#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
+#define PLD_ICUIREQ0		__reg16(PLD_BASE + 0x8004)
+#define PLD_ICUIREQ1		__reg16(PLD_BASE + 0x8006)
+#define PLD_ICUCR1		__reg16(PLD_BASE + 0x8100)
+#define PLD_ICUCR2		__reg16(PLD_BASE + 0x8102)
+#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
+#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
+#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
+#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
+#define PLD_ICUCR7		__reg16(PLD_BASE + 0x810c)
+#define PLD_ICUCR8		__reg16(PLD_BASE + 0x810e)
+#define PLD_ICUCR9		__reg16(PLD_BASE + 0x8110)
+#define PLD_ICUCR10		__reg16(PLD_BASE + 0x8112)
+#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
+#define PLD_ICUCR12		__reg16(PLD_BASE + 0x8116)
+#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
+#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
+#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
+#define PLD_ICUCR16		__reg16(PLD_BASE + 0x811e)
+#define PLD_ICUCR17		__reg16(PLD_BASE + 0x8120)
+#define PLD_ICUCR_IEN		(0x1000)
+#define PLD_ICUCR_IREQ		(0x0100)
+#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
+#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
+#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
+#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
+#define PLD_ICUCR_ILEVEL0	(0x0000)
+#define PLD_ICUCR_ILEVEL1	(0x0001)
+#define PLD_ICUCR_ILEVEL2	(0x0002)
+#define PLD_ICUCR_ILEVEL3	(0x0003)
+#define PLD_ICUCR_ILEVEL4	(0x0004)
+#define PLD_ICUCR_ILEVEL5	(0x0005)
+#define PLD_ICUCR_ILEVEL6	(0x0006)
+#define PLD_ICUCR_ILEVEL7	(0x0007)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+#define PLD_CPCR_CF		0x0001
+#define PLD_CPCR_MMC		0x0002
+
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIO0 */
+#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
+#define	PLD_ESIO0CR_TXEN	0x0001
+#define	PLD_ESIO0CR_RXEN	0x0002
+#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
+#define	PLD_ESIO0MOD0_CTSS	0x0040
+#define	PLD_ESIO0MOD0_RTSS	0x0080
+#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
+#define	PLD_ESIO0MOD1_LMFS	0x0010
+#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
+#define	PLD_ESIO0STS_TEMP	0x0001
+#define	PLD_ESIO0STS_TXCP	0x0002
+#define	PLD_ESIO0STS_RXCP	0x0004
+#define	PLD_ESIO0STS_TXSC	0x0100
+#define	PLD_ESIO0STS_RXSC	0x0200
+#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
+#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
+#define	PLD_ESIO0INTCR_TXIEN	0x0002
+#define	PLD_ESIO0INTCR_RXCEN	0x0004
+#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
+#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
+#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif /* _OPSPUT_OPSPUT_PLD.H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/page.h linux-2.6.30-rc3/arch/m32r/include/asm/page.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/page.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/page.h	2009-04-22 03:29:16.271556267 +0000
@@ -0,0 +1,87 @@
+#ifndef _ASM_M32R_PAGE_H
+#define _ASM_M32R_PAGE_H
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#ifndef __ASSEMBLY__
+
+extern void clear_page(void *to);
+extern void copy_page(void *to, void *from);
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+#define __alloc_zeroed_user_highpage(movableflags, vma, vaddr) \
+	alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+#define pte_val(x)	((x).pte)
+#define PTE_MASK	PAGE_MASK
+
+typedef struct { unsigned long pgprot; } pgprot_t;
+typedef struct page *pgtable_t;
+
+#define pmd_val(x)	((x).pmd)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x) ((pte_t) { (x) } )
+#define __pmd(x) ((pmd_t) { (x) } )
+#define __pgd(x) ((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+#endif /* !__ASSEMBLY__ */
+
+/*
+ * This handles the memory map.. We could make this a config
+ * option, but too many people screw it up, and too few need
+ * it.
+ *
+ * A __PAGE_OFFSET of 0xC0000000 means that the kernel has
+ * a virtual address space of one gigabyte, which limits the
+ * amount of physical memory you can use to about 950MB.
+ *
+ * If you want more physical memory than this then see the CONFIG_HIGHMEM4G
+ * and CONFIG_HIGHMEM64G options in the kernel configuration.
+ */
+
+#define __MEMORY_START  CONFIG_MEMORY_START
+#define __MEMORY_SIZE   CONFIG_MEMORY_SIZE
+
+#ifdef CONFIG_MMU
+#define __PAGE_OFFSET  (0x80000000)
+#else
+#define __PAGE_OFFSET  (0x00000000)
+#endif
+
+#define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
+#define __pa(x)			((unsigned long)(x) - PAGE_OFFSET)
+#define __va(x)			((void *)((unsigned long)(x) + PAGE_OFFSET))
+
+#ifndef CONFIG_DISCONTIGMEM
+#define PFN_BASE		(CONFIG_MEMORY_START >> PAGE_SHIFT)
+#define ARCH_PFN_OFFSET		PFN_BASE
+#define pfn_valid(pfn)		(((pfn) - PFN_BASE) < max_mapnr)
+#endif  /* !CONFIG_DISCONTIGMEM */
+
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC )
+
+#define devmem_is_allowed(x) 1
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/page.h>
+
+#endif /* _ASM_M32R_PAGE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/param.h linux-2.6.30-rc3/arch/m32r/include/asm/param.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/param.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/param.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,23 @@
+#ifndef _ASM_M32R_PARAM_H
+#define _ASM_M32R_PARAM_H
+
+#ifdef __KERNEL__
+# define HZ		CONFIG_HZ	/* Internal kernel timer frequency */
+# define USER_HZ	100		/* .. some user interfaces are in "ticks" */
+# define CLOCKS_PER_SEC	(USER_HZ)	/* like times() */
+#endif
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#define EXEC_PAGESIZE	4096
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* _ASM_M32R_PARAM_H */
+
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/pci.h linux-2.6.30-rc3/arch/m32r/include/asm/pci.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/pci.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/pci.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,8 @@
+#ifndef _ASM_M32R_PCI_H
+#define _ASM_M32R_PCI_H
+
+#include <asm-generic/pci.h>
+
+#define PCI_DMA_BUS_IS_PHYS	(1)
+
+#endif /* _ASM_M32R_PCI_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/percpu.h linux-2.6.30-rc3/arch/m32r/include/asm/percpu.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/percpu.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/percpu.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,6 @@
+#ifndef __ARCH_M32R_PERCPU__
+#define __ARCH_M32R_PERCPU__
+
+#include <asm-generic/percpu.h>
+
+#endif /* __ARCH_M32R_PERCPU__ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/pgalloc.h linux-2.6.30-rc3/arch/m32r/include/asm/pgalloc.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/pgalloc.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/pgalloc.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,76 @@
+#ifndef _ASM_M32R_PGALLOC_H
+#define _ASM_M32R_PGALLOC_H
+
+#include <linux/mm.h>
+
+#include <asm/io.h>
+
+#define pmd_populate_kernel(mm, pmd, pte)	\
+	set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+
+static __inline__ void pmd_populate(struct mm_struct *mm, pmd_t *pmd,
+	pgtable_t pte)
+{
+	set_pmd(pmd, __pmd(_PAGE_TABLE + page_to_phys(pte)));
+}
+#define pmd_pgtable(pmd) pmd_page(pmd)
+
+/*
+ * Allocate and free page tables.
+ */
+static __inline__ pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	pgd_t *pgd = (pgd_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
+
+	return pgd;
+}
+
+static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
+{
+	free_page((unsigned long)pgd);
+}
+
+static __inline__ pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
+	unsigned long address)
+{
+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
+
+	return pte;
+}
+
+static __inline__ pgtable_t pte_alloc_one(struct mm_struct *mm,
+	unsigned long address)
+{
+	struct page *pte = alloc_page(GFP_KERNEL|__GFP_ZERO);
+
+	pgtable_page_ctor(pte);
+	return pte;
+}
+
+static inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
+{
+	free_page((unsigned long)pte);
+}
+
+static inline void pte_free(struct mm_struct *mm, pgtable_t pte)
+{
+	pgtable_page_dtor(pte);
+	__free_page(pte);
+}
+
+#define __pte_free_tlb(tlb, pte)	pte_free((tlb)->mm, (pte))
+
+/*
+ * allocating and freeing a pmd is trivial: the 1-entry pmd is
+ * inside the pgd, so has no extra memory associated with it.
+ * (In the PAE case we free the pmds as part of the pgd.)
+ */
+
+#define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
+#define pmd_free(mm, x)			do { } while (0)
+#define __pmd_free_tlb(tlb, x)		do { } while (0)
+#define pgd_populate(mm, pmd, pte)	BUG()
+
+#define check_pgt_cache()	do { } while (0)
+
+#endif /* _ASM_M32R_PGALLOC_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/pgtable-2level.h linux-2.6.30-rc3/arch/m32r/include/asm/pgtable-2level.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/pgtable-2level.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/pgtable-2level.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,78 @@
+#ifndef _ASM_M32R_PGTABLE_2LEVEL_H
+#define _ASM_M32R_PGTABLE_2LEVEL_H
+#ifdef __KERNEL__
+
+/*
+ * traditional M32R two-level paging structure:
+ */
+
+#define PGDIR_SHIFT	22
+#define PTRS_PER_PGD	1024
+
+/*
+ * the M32R is two-level, so we don't really have any
+ * PMD directory physically.
+ */
+#define PMD_SHIFT	22
+#define PTRS_PER_PMD	1
+
+#define PTRS_PER_PTE	1024
+
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
+#define pmd_ERROR(e) \
+	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
+#define pgd_ERROR(e) \
+	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
+
+/*
+ * The "pgd_xxx()" functions here are trivial for a folded two-level
+ * setup: the pgd is never bad, and a pmd always exists (as it's folded
+ * into the pgd entry)
+ */
+static inline int pgd_none(pgd_t pgd)	{ return 0; }
+static inline int pgd_bad(pgd_t pgd)	{ return 0; }
+static inline int pgd_present(pgd_t pgd)	{ return 1; }
+#define pgd_clear(xp)				do { } while (0)
+
+/*
+ * Certain architectures need to do special things when PTEs
+ * within a page table are directly modified.  Thus, the following
+ * hook is made available.
+ */
+#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
+#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
+
+/*
+ * (pmds are folded into pgds so this doesnt get actually called,
+ * but the define is needed for a generic inline function.)
+ */
+#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
+#define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
+
+#define pgd_page_vaddr(pgd) \
+((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
+
+#ifndef CONFIG_DISCONTIGMEM
+#define pgd_page(pgd)	(mem_map + ((pgd_val(pgd) >> PAGE_SHIFT) - PFN_BASE))
+#endif /* !CONFIG_DISCONTIGMEM */
+
+static inline pmd_t *pmd_offset(pgd_t * dir, unsigned long address)
+{
+	return (pmd_t *) dir;
+}
+
+#define ptep_get_and_clear(mm,addr,xp)	__pte(xchg(&(xp)->pte, 0))
+#define pte_same(a, b)		(pte_val(a) == pte_val(b))
+#define pte_page(x)		pfn_to_page(pte_pfn(x))
+#define pte_none(x)		(!pte_val(x))
+#define pte_pfn(x)		(pte_val(x) >> PAGE_SHIFT)
+#define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
+#define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
+
+#define PTE_FILE_MAX_BITS	29
+#define pte_to_pgoff(pte)	(((pte_val(pte) >> 2) & 0x7f) | (((pte_val(pte) >> 10)) << 7))
+#define pgoff_to_pte(off)	((pte_t) { (((off) & 0x7f) << 2) | (((off) >> 7) << 10) | _PAGE_FILE })
+
+#endif /* __KERNEL__ */
+#endif /* _ASM_M32R_PGTABLE_2LEVEL_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/pgtable.h linux-2.6.30-rc3/arch/m32r/include/asm/pgtable.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/pgtable.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/pgtable.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,363 @@
+#ifndef _ASM_M32R_PGTABLE_H
+#define _ASM_M32R_PGTABLE_H
+
+#include <asm-generic/4level-fixup.h>
+
+#ifdef __KERNEL__
+/*
+ * The Linux memory management assumes a three-level page table setup. On
+ * the M32R, we use that, but "fold" the mid level into the top-level page
+ * table, so that we physically have the same two-level page table as the
+ * M32R mmu expects.
+ *
+ * This file contains the functions and defines necessary to modify and use
+ * the M32R page table tree.
+ */
+
+/* CAUTION!: If you change macro definitions in this file, you might have to
+ * change arch/m32r/mmu.S manually.
+ */
+
+#ifndef __ASSEMBLY__
+
+#include <linux/threads.h>
+#include <linux/bitops.h>
+#include <asm/processor.h>
+#include <asm/addrspace.h>
+#include <asm/page.h>
+
+struct mm_struct;
+struct vm_area_struct;
+
+extern pgd_t swapper_pg_dir[1024];
+extern void paging_init(void);
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+extern unsigned long empty_zero_page[1024];
+#define ZERO_PAGE(vaddr)	(virt_to_page(empty_zero_page))
+
+#endif /* !__ASSEMBLY__ */
+
+#ifndef __ASSEMBLY__
+#include <asm/pgtable-2level.h>
+#endif
+
+#define pgtable_cache_init()	do { } while (0)
+
+#define PMD_SIZE	(1UL << PMD_SHIFT)
+#define PMD_MASK	(~(PMD_SIZE - 1))
+#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE - 1))
+
+#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
+#define FIRST_USER_ADDRESS	0
+
+#ifndef __ASSEMBLY__
+/* Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_START		KSEG2
+#define VMALLOC_END		KSEG3
+
+/*
+ *     M32R TLB format
+ *
+ *     [0]    [1:19]           [20:23]       [24:31]
+ *     +-----------------------+----+-------------+
+ *     |          VPN          |0000|    ASID     |
+ *     +-----------------------+----+-------------+
+ *     +-+---------------------+----+-+---+-+-+-+-+
+ *     |0         PPN          |0000|N|AC |L|G|V| |
+ *     +-+---------------------+----+-+---+-+-+-+-+
+ *                                     RWX
+ */
+
+#define _PAGE_BIT_DIRTY		0	/* software: page changed */
+#define _PAGE_BIT_FILE		0	/* when !present: nonlinear file
+					   mapping */
+#define _PAGE_BIT_PRESENT	1	/* Valid: page is valid */
+#define _PAGE_BIT_GLOBAL	2	/* Global */
+#define _PAGE_BIT_LARGE		3	/* Large */
+#define _PAGE_BIT_EXEC		4	/* Execute */
+#define _PAGE_BIT_WRITE		5	/* Write */
+#define _PAGE_BIT_READ		6	/* Read */
+#define _PAGE_BIT_NONCACHABLE	7	/* Non cachable */
+#define _PAGE_BIT_ACCESSED	8	/* software: page referenced */
+#define _PAGE_BIT_PROTNONE	9	/* software: if not present */
+
+#define _PAGE_DIRTY		(1UL << _PAGE_BIT_DIRTY)
+#define _PAGE_FILE		(1UL << _PAGE_BIT_FILE)
+#define _PAGE_PRESENT		(1UL << _PAGE_BIT_PRESENT)
+#define _PAGE_GLOBAL		(1UL << _PAGE_BIT_GLOBAL)
+#define _PAGE_LARGE		(1UL << _PAGE_BIT_LARGE)
+#define _PAGE_EXEC		(1UL << _PAGE_BIT_EXEC)
+#define _PAGE_WRITE		(1UL << _PAGE_BIT_WRITE)
+#define _PAGE_READ		(1UL << _PAGE_BIT_READ)
+#define _PAGE_NONCACHABLE	(1UL << _PAGE_BIT_NONCACHABLE)
+#define _PAGE_ACCESSED		(1UL << _PAGE_BIT_ACCESSED)
+#define _PAGE_PROTNONE		(1UL << _PAGE_BIT_PROTNONE)
+
+#define _PAGE_TABLE	\
+	( _PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_ACCESSED \
+	| _PAGE_DIRTY )
+#define _KERNPG_TABLE	\
+	( _PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_ACCESSED \
+	| _PAGE_DIRTY )
+#define _PAGE_CHG_MASK	\
+	( PTE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY )
+
+#ifdef CONFIG_MMU
+#define PAGE_NONE	\
+	__pgprot(_PAGE_PROTNONE | _PAGE_ACCESSED)
+#define PAGE_SHARED	\
+	__pgprot(_PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_ACCESSED)
+#define PAGE_SHARED_EXEC \
+	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_WRITE | _PAGE_READ \
+		| _PAGE_ACCESSED)
+#define PAGE_COPY	\
+	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_ACCESSED)
+#define PAGE_COPY_EXEC	\
+	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_ACCESSED)
+#define PAGE_READONLY	\
+	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_ACCESSED)
+#define PAGE_READONLY_EXEC \
+	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_ACCESSED)
+
+#define __PAGE_KERNEL	\
+	( _PAGE_PRESENT | _PAGE_EXEC | _PAGE_WRITE | _PAGE_READ | _PAGE_DIRTY \
+	| _PAGE_ACCESSED )
+#define __PAGE_KERNEL_RO	( __PAGE_KERNEL & ~_PAGE_WRITE )
+#define __PAGE_KERNEL_NOCACHE	( __PAGE_KERNEL | _PAGE_NONCACHABLE)
+
+#define MAKE_GLOBAL(x)	__pgprot((x) | _PAGE_GLOBAL)
+
+#define PAGE_KERNEL		MAKE_GLOBAL(__PAGE_KERNEL)
+#define PAGE_KERNEL_RO		MAKE_GLOBAL(__PAGE_KERNEL_RO)
+#define PAGE_KERNEL_NOCACHE	MAKE_GLOBAL(__PAGE_KERNEL_NOCACHE)
+
+#else
+#define PAGE_NONE		__pgprot(0)
+#define PAGE_SHARED		__pgprot(0)
+#define PAGE_SHARED_EXEC	__pgprot(0)
+#define PAGE_COPY		__pgprot(0)
+#define PAGE_COPY_EXEC		__pgprot(0)
+#define PAGE_READONLY		__pgprot(0)
+#define PAGE_READONLY_EXEC	__pgprot(0)
+
+#define PAGE_KERNEL		__pgprot(0)
+#define PAGE_KERNEL_RO		__pgprot(0)
+#define PAGE_KERNEL_NOCACHE	__pgprot(0)
+#endif /* CONFIG_MMU */
+
+	/* xwr */
+#define __P000	PAGE_NONE
+#define __P001	PAGE_READONLY
+#define __P010	PAGE_COPY
+#define __P011	PAGE_COPY
+#define __P100	PAGE_READONLY_EXEC
+#define __P101	PAGE_READONLY_EXEC
+#define __P110	PAGE_COPY_EXEC
+#define __P111	PAGE_COPY_EXEC
+
+#define __S000	PAGE_NONE
+#define __S001	PAGE_READONLY
+#define __S010	PAGE_SHARED
+#define __S011	PAGE_SHARED
+#define __S100	PAGE_READONLY_EXEC
+#define __S101	PAGE_READONLY_EXEC
+#define __S110	PAGE_SHARED_EXEC
+#define __S111	PAGE_SHARED_EXEC
+
+/* page table for 0-4MB for everybody */
+
+#define pte_present(x)	(pte_val(x) & (_PAGE_PRESENT | _PAGE_PROTNONE))
+#define pte_clear(mm,addr,xp)	do { set_pte_at(mm, addr, xp, __pte(0)); } while (0)
+
+#define pmd_none(x)	(!pmd_val(x))
+#define pmd_present(x)	(pmd_val(x) & _PAGE_PRESENT)
+#define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)
+#define	pmd_bad(x)	((pmd_val(x) & ~PAGE_MASK) != _KERNPG_TABLE)
+
+#define pages_to_mb(x)	((x) >> (20 - PAGE_SHIFT))
+
+/*
+ * The following only work if pte_present() is true.
+ * Undefined behaviour if not..
+ */
+static inline int pte_dirty(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_DIRTY;
+}
+
+static inline int pte_young(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_ACCESSED;
+}
+
+static inline int pte_write(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_WRITE;
+}
+
+/*
+ * The following only works if pte_present() is not true.
+ */
+static inline int pte_file(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_FILE;
+}
+
+static inline int pte_special(pte_t pte)
+{
+	return 0;
+}
+
+static inline pte_t pte_mkclean(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_DIRTY;
+	return pte;
+}
+
+static inline pte_t pte_mkold(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_ACCESSED;
+	return pte;
+}
+
+static inline pte_t pte_wrprotect(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_WRITE;
+	return pte;
+}
+
+static inline pte_t pte_mkdirty(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_DIRTY;
+	return pte;
+}
+
+static inline pte_t pte_mkyoung(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_ACCESSED;
+	return pte;
+}
+
+static inline pte_t pte_mkwrite(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_WRITE;
+	return pte;
+}
+
+static inline pte_t pte_mkspecial(pte_t pte)
+{
+	return pte;
+}
+
+static inline  int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned long addr, pte_t *ptep)
+{
+	return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep);
+}
+
+static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
+{
+	clear_bit(_PAGE_BIT_WRITE, ptep);
+}
+
+/*
+ * Macro and implementation to make a page protection as uncachable.
+ */
+static inline pgprot_t pgprot_noncached(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot |= _PAGE_NONCACHABLE;
+	return __pgprot(prot);
+}
+
+#define pgprot_writecombine(prot) pgprot_noncached(prot)
+
+/*
+ * Conversion functions: convert a page and protection to a page entry,
+ * and a page entry and page directory to the page they refer to.
+ */
+#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), pgprot)
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	set_pte(&pte, __pte((pte_val(pte) & _PAGE_CHG_MASK) \
+		| pgprot_val(newprot)));
+
+	return pte;
+}
+
+/*
+ * Conversion functions: convert a page and protection to a page entry,
+ * and a page entry and page directory to the page they refer to.
+ */
+
+static inline void pmd_set(pmd_t * pmdp, pte_t * ptep)
+{
+	pmd_val(*pmdp) = (((unsigned long) ptep) & PAGE_MASK);
+}
+
+#define pmd_page_vaddr(pmd)	\
+	((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
+
+#ifndef CONFIG_DISCONTIGMEM
+#define pmd_page(pmd)	(mem_map + ((pmd_val(pmd) >> PAGE_SHIFT) - PFN_BASE))
+#endif /* !CONFIG_DISCONTIGMEM */
+
+/* to find an entry in a page-table-directory. */
+#define pgd_index(address)	\
+	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
+
+#define pgd_offset(mm, address)	((mm)->pgd + pgd_index(address))
+
+/* to find an entry in a kernel page-table-directory */
+#define pgd_offset_k(address)	pgd_offset(&init_mm, address)
+
+#define pmd_index(address)	\
+	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD - 1))
+
+#define pte_index(address)	\
+	(((address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
+#define pte_offset_kernel(dir, address)	\
+	((pte_t *)pmd_page_vaddr(*(dir)) + pte_index(address))
+#define pte_offset_map(dir, address)	\
+	((pte_t *)page_address(pmd_page(*(dir))) + pte_index(address))
+#define pte_offset_map_nested(dir, address)	pte_offset_map(dir, address)
+#define pte_unmap(pte)		do { } while (0)
+#define pte_unmap_nested(pte)	do { } while (0)
+
+/* Encode and de-code a swap entry */
+#define __swp_type(x)			(((x).val >> 2) & 0x1f)
+#define __swp_offset(x)			((x).val >> 10)
+#define __swp_entry(type, offset)	\
+	((swp_entry_t) { ((type) << 2) | ((offset) << 10) })
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val })
+
+#endif /* !__ASSEMBLY__ */
+
+/* Needs to be defined here and not in linux/mm.h, as it is arch dependent */
+#define kern_addr_valid(addr)	(1)
+
+#define io_remap_pfn_range(vma, vaddr, pfn, size, prot)	\
+		remap_pfn_range(vma, vaddr, pfn, size, prot)
+
+#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG
+#define __HAVE_ARCH_PTEP_GET_AND_CLEAR
+#define __HAVE_ARCH_PTEP_SET_WRPROTECT
+#define __HAVE_ARCH_PTE_SAME
+#include <asm-generic/pgtable.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_M32R_PGTABLE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/poll.h linux-2.6.30-rc3/arch/m32r/include/asm/poll.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/poll.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/poll.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1 @@
+#include <asm-generic/poll.h>
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/posix_types.h linux-2.6.30-rc3/arch/m32r/include/asm/posix_types.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/posix_types.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/posix_types.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,118 @@
+#ifndef _ASM_M32R_POSIX_TYPES_H
+#define _ASM_M32R_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+	int	val[2];
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__)
+
+#undef	__FD_SET
+static __inline__ void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
+}
+
+#undef	__FD_CLR
+static __inline__ void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
+}
+
+
+#undef	__FD_ISSET
+static __inline__ int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__p)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant case (8 ints,
+ * for a 256-bit fd_set)
+ */
+#undef	__FD_ZERO
+static __inline__ void __FD_ZERO(__kernel_fd_set *__p)
+{
+	unsigned long *__tmp = __p->fds_bits;
+	int __i;
+
+	if (__builtin_constant_p(__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+		case 16:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			__tmp[ 4] = 0; __tmp[ 5] = 0;
+			__tmp[ 6] = 0; __tmp[ 7] = 0;
+			__tmp[ 8] = 0; __tmp[ 9] = 0;
+			__tmp[10] = 0; __tmp[11] = 0;
+			__tmp[12] = 0; __tmp[13] = 0;
+			__tmp[14] = 0; __tmp[15] = 0;
+			return;
+
+		case 8:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			__tmp[ 4] = 0; __tmp[ 5] = 0;
+			__tmp[ 6] = 0; __tmp[ 7] = 0;
+			return;
+
+		case 4:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			return;
+		}
+	}
+	__i = __FDSET_LONGS;
+	while (__i) {
+		__i--;
+		*__tmp = 0;
+		__tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) */
+
+#endif  /* _ASM_M32R_POSIX_TYPES_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/processor.h linux-2.6.30-rc3/arch/m32r/include/asm/processor.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/processor.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/processor.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,147 @@
+#ifndef _ASM_M32R_PROCESSOR_H
+#define _ASM_M32R_PROCESSOR_H
+
+/*
+ * include/asm-m32r/processor.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994  Linus Torvalds
+ * Copyright (C) 2001  Hiroyuki Kondo, Hirokazu Takata, and Hitoshi Yamamoto
+ * Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#include <linux/kernel.h>
+#include <asm/cache.h>
+#include <asm/ptrace.h>  /* pt_regs */
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l; })
+
+/*
+ *  CPU type and hardware bug flags. Kept separately for each CPU.
+ *  Members of this structure are referenced in head.S, so think twice
+ *  before touching them. [mj]
+ */
+
+struct cpuinfo_m32r {
+	unsigned long pgtable_cache_sz;
+	unsigned long cpu_clock;
+	unsigned long bus_clock;
+	unsigned long timer_divide;
+	unsigned long loops_per_jiffy;
+};
+
+/*
+ * capabilities of CPUs
+ */
+
+extern struct cpuinfo_m32r boot_cpu_data;
+
+#ifdef CONFIG_SMP
+extern struct cpuinfo_m32r cpu_data[];
+#define current_cpu_data cpu_data[smp_processor_id()]
+#else
+#define cpu_data (&boot_cpu_data)
+#define current_cpu_data boot_cpu_data
+#endif
+
+/*
+ * User space process size: 2GB (default).
+ */
+#ifdef CONFIG_MMU
+#define TASK_SIZE  (0x80000000UL)
+#else
+#define TASK_SIZE  (0x00400000UL)
+#endif
+
+#ifdef __KERNEL__
+#define STACK_TOP	TASK_SIZE
+#define STACK_TOP_MAX	STACK_TOP
+#endif
+
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
+
+typedef struct {
+	unsigned long seg;
+} mm_segment_t;
+
+#define MAX_TRAPS 10
+
+struct debug_trap {
+	int nr_trap;
+	unsigned long	addr[MAX_TRAPS];
+	unsigned long	insn[MAX_TRAPS];
+};
+
+struct thread_struct {
+	unsigned long address;
+	unsigned long trap_no;		/* Trap number  */
+	unsigned long error_code;	/* Error code of trap */
+	unsigned long lr;		/* saved pc */
+	unsigned long sp;		/* user stack pointer */
+	struct debug_trap debug_trap;
+};
+
+#define INIT_SP	(sizeof(init_stack) + (unsigned long) &init_stack)
+
+#define INIT_THREAD	{	\
+	.sp = INIT_SP,		\
+}
+
+/*
+ * Do necessary setup to start up a newly executed thread.
+ */
+
+/* User process Backup PSW */
+#define USERPS_BPSW (M32R_PSW_BSM|M32R_PSW_BIE|M32R_PSW_BPM)
+
+#define start_thread(regs, new_pc, new_spu) 				\
+	do {								\
+		set_fs(USER_DS); 					\
+		regs->psw = (regs->psw | USERPS_BPSW) & 0x0000FFFFUL;	\
+		regs->bpc = new_pc;					\
+		regs->spu = new_spu;					\
+	} while (0)
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+struct mm_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+#define prepare_to_copy(tsk)	do { } while (0)
+
+/*
+ * create a kernel thread without removing it from tasklists
+ */
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/* Copy and release all segment info associated with a VM */
+extern void copy_segments(struct task_struct *p, struct mm_struct * mm);
+extern void release_segments(struct mm_struct * mm);
+
+extern unsigned long thread_saved_pc(struct task_struct *);
+
+/* Copy and release all segment info associated with a VM */
+#define copy_segments(p, mm)  do { } while (0)
+#define release_segments(mm)  do { } while (0)
+
+unsigned long get_wchan(struct task_struct *p);
+#define KSTK_EIP(tsk)  ((tsk)->thread.lr)
+#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
+
+#define THREAD_SIZE (2*PAGE_SIZE)
+
+#define cpu_relax()	barrier()
+
+#endif /* _ASM_M32R_PROCESSOR_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/ptrace.h linux-2.6.30-rc3/arch/m32r/include/asm/ptrace.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/ptrace.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/ptrace.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,148 @@
+#ifndef _ASM_M32R_PTRACE_H
+#define _ASM_M32R_PTRACE_H
+
+/*
+ * linux/include/asm-m32r/ptrace.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * M32R version:
+ *   Copyright (C) 2001-2002, 2004  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+/* 0 - 13 are integer registers (general purpose registers).  */
+#define PT_R4		0
+#define PT_R5		1
+#define PT_R6		2
+#define PT_REGS 	3
+#define PT_R0		4
+#define PT_R1		5
+#define PT_R2		6
+#define PT_R3		7
+#define PT_R7		8
+#define PT_R8		9
+#define PT_R9		10
+#define PT_R10		11
+#define PT_R11		12
+#define PT_R12		13
+#define PT_SYSCNR	14
+#define PT_R13		PT_FP
+#define PT_R14		PT_LR
+#define PT_R15		PT_SP
+
+/* processor status and miscellaneous context registers.  */
+#define PT_ACC0H	15
+#define PT_ACC0L	16
+#define PT_ACC1H	17	/* ISA_DSP_LEVEL2 only */
+#define PT_ACC1L	18	/* ISA_DSP_LEVEL2 only */
+#define PT_PSW		19
+#define PT_BPC		20
+#define PT_BBPSW	21
+#define PT_BBPC		22
+#define PT_SPU		23
+#define PT_FP		24
+#define PT_LR		25
+#define PT_SPI		26
+#define PT_ORIGR0	27
+
+/* virtual pt_reg entry for gdb */
+#define PT_PC		30
+#define PT_CBR		31
+#define PT_EVB		32
+
+
+/* Control registers.  */
+#define SPR_CR0 PT_PSW
+#define SPR_CR1 PT_CBR		/* read only */
+#define SPR_CR2 PT_SPI
+#define SPR_CR3 PT_SPU
+#define SPR_CR4
+#define SPR_CR5 PT_EVB		/* part of M32R/E, M32R/I core only */
+#define SPR_CR6 PT_BPC
+#define SPR_CR7
+#define SPR_CR8 PT_BBPSW
+#define SPR_CR9
+#define SPR_CR10
+#define SPR_CR11
+#define SPR_CR12
+#define SPR_CR13 PT_WR
+#define SPR_CR14 PT_BBPC
+#define SPR_CR15
+
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+struct pt_regs {
+	/* Saved main processor registers. */
+	unsigned long r4;
+	unsigned long r5;
+	unsigned long r6;
+	struct pt_regs *pt_regs;
+	unsigned long r0;
+	unsigned long r1;
+	unsigned long r2;
+	unsigned long r3;
+	unsigned long r7;
+	unsigned long r8;
+	unsigned long r9;
+	unsigned long r10;
+	unsigned long r11;
+	unsigned long r12;
+	long syscall_nr;
+
+	/* Saved main processor status and miscellaneous context registers. */
+	unsigned long acc0h;
+	unsigned long acc0l;
+	unsigned long acc1h;	/* ISA_DSP_LEVEL2 only */
+	unsigned long acc1l;	/* ISA_DSP_LEVEL2 only */
+	unsigned long psw;
+	unsigned long bpc;		/* saved PC for TRAP syscalls */
+	unsigned long bbpsw;
+	unsigned long bbpc;
+	unsigned long spu;		/* saved user stack */
+	unsigned long fp;
+	unsigned long lr;		/* saved PC for JL syscalls */
+	unsigned long spi;		/* saved kernel stack */
+	unsigned long orig_r0;
+};
+
+/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+
+#define PTRACE_OLDSETOPTIONS	21
+
+/* options set using PTRACE_SETOPTIONS */
+#define PTRACE_O_TRACESYSGOOD	0x00000001
+
+#ifdef __KERNEL__
+
+#include <asm/m32r.h>		/* M32R_PSW_BSM, M32R_PSW_BPM */
+
+struct task_struct;
+extern void init_debug_traps(struct task_struct *);
+#define arch_ptrace_attach(child) \
+	init_debug_traps(child)
+
+#if defined(CONFIG_ISA_M32R2) || defined(CONFIG_CHIP_VDEC2)
+#define user_mode(regs) ((M32R_PSW_BPM & (regs)->psw) != 0)
+#elif defined(CONFIG_ISA_M32R)
+#define user_mode(regs) ((M32R_PSW_BSM & (regs)->psw) != 0)
+#else
+#error unknown isa configuration
+#endif
+
+#define instruction_pointer(regs) ((regs)->bpc)
+#define profile_pc(regs) instruction_pointer(regs)
+
+extern void show_regs(struct pt_regs *);
+
+extern void withdraw_debug_trap(struct pt_regs *regs);
+
+#define task_pt_regs(task) \
+        ((struct pt_regs *)(task_stack_page(task) + THREAD_SIZE) - 1)
+
+#endif /* __KERNEL */
+
+#endif /* _ASM_M32R_PTRACE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/resource.h linux-2.6.30-rc3/arch/m32r/include/asm/resource.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/resource.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/resource.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_M32R_RESOURCE_H
+#define _ASM_M32R_RESOURCE_H
+
+#include <asm-generic/resource.h>
+
+#endif  /* _ASM_M32R_RESOURCE_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/rtc.h linux-2.6.30-rc3/arch/m32r/include/asm/rtc.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/rtc.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/rtc.h	2009-04-22 03:29:16.272556137 +0000
@@ -0,0 +1,65 @@
+#ifndef __RTC_H__
+#define __RTC_H__
+
+   /* Dallas DS1302 clock/calendar register numbers. */
+#  define RTC_SECONDS      0
+#  define RTC_MINUTES      1
+#  define RTC_HOURS        2
+#  define RTC_DAY_OF_MONTH 3
+#  define RTC_MONTH        4
+#  define RTC_WEEKDAY      5
+#  define RTC_YEAR         6
+#  define RTC_CONTROL      7
+
+   /* Bits in CONTROL register. */
+#  define RTC_CONTROL_WRITEPROTECT 	0x80
+#  define RTC_TRICKLECHARGER 		8
+
+  /* Bits in TRICKLECHARGER register TCS TCS TCS TCS DS DS RS RS. */
+#  define RTC_TCR_PATTERN 	0xA0	/* 1010xxxx */
+#  define RTC_TCR_1DIOD 	0x04	/* xxxx01xx */
+#  define RTC_TCR_2DIOD 	0x08	/* xxxx10xx */
+#  define RTC_TCR_DISABLED 	0x00	/* xxxxxx00 Disabled */
+#  define RTC_TCR_2KOHM 	0x01	/* xxxxxx01 2KOhm */
+#  define RTC_TCR_4KOHM 	0x02	/* xxxxxx10 4kOhm */
+#  define RTC_TCR_8KOHM 	0x03	/* xxxxxx11 8kOhm */
+
+#ifdef CONFIG_DS1302
+extern unsigned char ds1302_readreg(int reg);
+extern void ds1302_writereg(int reg, unsigned char val);
+extern int ds1302_init(void);
+#  define CMOS_READ(x) ds1302_readreg(x)
+#  define CMOS_WRITE(val,reg) ds1302_writereg(reg,val)
+#  define RTC_INIT() ds1302_init()
+#else
+  /* No RTC configured so we shouldn't try to access any. */
+#  define CMOS_READ(x) 42
+#  define CMOS_WRITE(x,y)
+#  define RTC_INIT() (-1)
+#endif
+
+/*
+ * The struct used to pass data via the following ioctl. Similar to the
+ * struct tm in <time.h>, but it needs to be here so that the kernel
+ * source is self contained, allowing cross-compiles, etc. etc.
+ */
+struct rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;
+	int tm_yday;
+	int tm_isdst;
+};
+
+/* ioctl() calls that are permitted to the /dev/rtc interface. */
+#define RTC_MAGIC 'p'
+#define RTC_RD_TIME		_IOR(RTC_MAGIC, 0x09, struct rtc_time)	/* Read RTC time. */
+#define RTC_SET_TIME		_IOW(RTC_MAGIC, 0x0a, struct rtc_time)	/* Set RTC time. */
+#define RTC_SET_CHARGE  	_IOW(RTC_MAGIC, 0x0b, int)
+#define RTC_MAX_IOCTL 0x0b
+
+#endif /* __RTC_H__ */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/s1d13806.h linux-2.6.30-rc3/arch/m32r/include/asm/s1d13806.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/s1d13806.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/s1d13806.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,199 @@
+//----------------------------------------------------------------------------
+//
+//  File generated by S1D13806CFG.EXE
+//
+//  Copyright (c) 2000,2001 Epson Research and Development, Inc.
+//  All rights reserved.
+//
+//----------------------------------------------------------------------------
+
+// Panel:  (active)  640x480 77Hz STN Single 8-bit (PCLK=CLKI=25.175MHz)
+// Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=33.333MHz)
+
+#define SWIVEL_VIEW		0	/* 0:none, 1:90 not completed */
+
+static struct s1d13xxxfb_regval s1d13xxxfb_initregs[] = {
+
+    {0x0001,0x00},   // Miscellaneous Register
+    {0x01FC,0x00},   // Display Mode Register
+#if defined(CONFIG_PLAT_MAPPI)
+    {0x0004,0x00},   // General IO Pins Configuration Register 0
+    {0x0005,0x00},   // General IO Pins Configuration Register 1
+    {0x0008,0x00},   // General IO Pins Control Register 0
+    {0x0009,0x00},   // General IO Pins Control Register 1
+    {0x0010,0x00},   // Memory Clock Configuration Register
+    {0x0014,0x00},   // LCD Pixel Clock Configuration Register
+    {0x0018,0x00},   // CRT/TV Pixel Clock Configuration Register
+    {0x001C,0x00},   // MediaPlug Clock Configuration Register
+/*
+ * .. 10MHz: 0x00
+ * .. 30MHz: 0x01
+ * 30MHz ..: 0x02
+ */
+    {0x001E,0x02},   // CPU To Memory Wait State Select Register
+    {0x0021,0x02},   // DRAM Refresh Rate Register
+    {0x002A,0x11},   // DRAM Timings Control Register 0
+    {0x002B,0x13},   // DRAM Timings Control Register 1
+    {0x0020,0x80},   // Memory Configuration Register
+    {0x0030,0x25},   // Panel Type Register
+    {0x0031,0x00},   // MOD Rate Register
+    {0x0032,0x4F},   // LCD Horizontal Display Width Register
+    {0x0034,0x12},   // LCD Horizontal Non-Display Period Register
+    {0x0035,0x01},   // TFT FPLINE Start Position Register
+    {0x0036,0x0B},   // TFT FPLINE Pulse Width Register
+    {0x0038,0xDF},   // LCD Vertical Display Height Register 0
+    {0x0039,0x01},   // LCD Vertical Display Height Register 1
+    {0x003A,0x2C},   // LCD Vertical Non-Display Period Register
+    {0x003B,0x0A},   // TFT FPFRAME Start Position Register
+    {0x003C,0x01},   // TFT FPFRAME Pulse Width Register
+
+    {0x0041,0x00},   // LCD Miscellaneous Register
+    {0x0042,0x00},   // LCD Display Start Address Register 0
+    {0x0043,0x00},   // LCD Display Start Address Register 1
+    {0x0044,0x00},   // LCD Display Start Address Register 2
+
+#elif defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)
+    {0x0004,0x07},   // GPIO[0:7] direction
+    {0x0005,0x00},   // GPIO[8:12] direction
+    {0x0008,0x00},   // GPIO[0:7] data
+    {0x0009,0x00},   // GPIO[8:12] data
+    {0x0008,0x04},   // LCD panel Vcc on
+    {0x0008,0x05},   // LCD panel reset
+    {0x0010,0x01},   // Memory Clock Configuration Register
+    {0x0014,0x30},   // LCD Pixel Clock Configuration Register (CLKI 22MHz/4)
+    {0x0018,0x00},   // CRT/TV Pixel Clock Configuration Register
+    {0x001C,0x00},   // MediaPlug Clock Configuration Register(10MHz)
+    {0x001E,0x00},   // CPU To Memory Wait State Select Register
+    {0x0020,0x80},   // Memory Configuration Register
+    {0x0021,0x03},   // DRAM Refresh Rate Register
+    {0x002A,0x00},   // DRAM Timings Control Register 0
+    {0x002B,0x01},   // DRAM Timings Control Register 1
+    {0x0030,0x25},   // Panel Type Register
+    {0x0031,0x00},   // MOD Rate Register
+    {0x0032,0x1d},   // LCD Horizontal Display Width Register
+    {0x0034,0x05},   // LCD Horizontal Non-Display Period Register
+    {0x0035,0x01},   // TFT FPLINE Start Position Register
+    {0x0036,0x01},   // TFT FPLINE Pulse Width Register
+    {0x0038,0x3F},   // LCD Vertical Display Height Register 0
+    {0x0039,0x01},   // LCD Vertical Display Height Register 1
+    {0x003A,0x0b},   // LCD Vertical Non-Display Period Register
+    {0x003B,0x07},   // TFT FPFRAME Start Position Register
+    {0x003C,0x02},   // TFT FPFRAME Pulse Width Register
+
+    {0x0041,0x00},   // LCD Miscellaneous Register
+#if (SWIVEL_VIEW == 0)
+    {0x0042,0x00},   // LCD Display Start Address Register 0
+    {0x0043,0x00},   // LCD Display Start Address Register 1
+    {0x0044,0x00},   // LCD Display Start Address Register 2
+
+#elif (SWIVEL_VIEW == 1)
+    // 1024 - W(320) = 0x2C0
+    {0x0042,0xC0},   // LCD Display Start Address Register 0
+    {0x0043,0x02},   // LCD Display Start Address Register 1
+    {0x0044,0x00},   // LCD Display Start Address Register 2
+    // 1024
+    {0x0046,0x00},   // LCD Memory Address Offset Register 0
+    {0x0047,0x02},   // LCD Memory Address Offset Register 1
+#else
+#error unsupported SWIVEL_VIEW mode
+#endif
+#else
+#error no platform configuration
+#endif  /* CONFIG_PLAT_XXX */
+
+    {0x0048,0x00},   // LCD Pixel Panning Register
+    {0x004A,0x00},   // LCD Display FIFO High Threshold Control Register
+    {0x004B,0x00},   // LCD Display FIFO Low Threshold Control Register
+    {0x0050,0x4F},   // CRT/TV Horizontal Display Width Register
+    {0x0052,0x13},   // CRT/TV Horizontal Non-Display Period Register
+    {0x0053,0x01},   // CRT/TV HRTC Start Position Register
+    {0x0054,0x0B},   // CRT/TV HRTC Pulse Width Register
+    {0x0056,0xDF},   // CRT/TV Vertical Display Height Register 0
+    {0x0057,0x01},   // CRT/TV Vertical Display Height Register 1
+    {0x0058,0x2B},   // CRT/TV Vertical Non-Display Period Register
+    {0x0059,0x09},   // CRT/TV VRTC Start Position Register
+    {0x005A,0x01},   // CRT/TV VRTC Pulse Width Register
+    {0x005B,0x10},   // TV Output Control Register
+
+    {0x0062,0x00},   // CRT/TV Display Start Address Register 0
+    {0x0063,0x00},   // CRT/TV Display Start Address Register 1
+    {0x0064,0x00},   // CRT/TV Display Start Address Register 2
+
+    {0x0068,0x00},   // CRT/TV Pixel Panning Register
+    {0x006A,0x00},   // CRT/TV Display FIFO High Threshold Control Register
+    {0x006B,0x00},   // CRT/TV Display FIFO Low Threshold Control Register
+    {0x0070,0x00},   // LCD Ink/Cursor Control Register
+    {0x0071,0x01},   // LCD Ink/Cursor Start Address Register
+    {0x0072,0x00},   // LCD Cursor X Position Register 0
+    {0x0073,0x00},   // LCD Cursor X Position Register 1
+    {0x0074,0x00},   // LCD Cursor Y Position Register 0
+    {0x0075,0x00},   // LCD Cursor Y Position Register 1
+    {0x0076,0x00},   // LCD Ink/Cursor Blue Color 0 Register
+    {0x0077,0x00},   // LCD Ink/Cursor Green Color 0 Register
+    {0x0078,0x00},   // LCD Ink/Cursor Red Color 0 Register
+    {0x007A,0x1F},   // LCD Ink/Cursor Blue Color 1 Register
+    {0x007B,0x3F},   // LCD Ink/Cursor Green Color 1 Register
+    {0x007C,0x1F},   // LCD Ink/Cursor Red Color 1 Register
+    {0x007E,0x00},   // LCD Ink/Cursor FIFO Threshold Register
+    {0x0080,0x00},   // CRT/TV Ink/Cursor Control Register
+    {0x0081,0x01},   // CRT/TV Ink/Cursor Start Address Register
+    {0x0082,0x00},   // CRT/TV Cursor X Position Register 0
+    {0x0083,0x00},   // CRT/TV Cursor X Position Register 1
+    {0x0084,0x00},   // CRT/TV Cursor Y Position Register 0
+    {0x0085,0x00},   // CRT/TV Cursor Y Position Register 1
+    {0x0086,0x00},   // CRT/TV Ink/Cursor Blue Color 0 Register
+    {0x0087,0x00},   // CRT/TV Ink/Cursor Green Color 0 Register
+    {0x0088,0x00},   // CRT/TV Ink/Cursor Red Color 0 Register
+    {0x008A,0x1F},   // CRT/TV Ink/Cursor Blue Color 1 Register
+    {0x008B,0x3F},   // CRT/TV Ink/Cursor Green Color 1 Register
+    {0x008C,0x1F},   // CRT/TV Ink/Cursor Red Color 1 Register
+    {0x008E,0x00},   // CRT/TV Ink/Cursor FIFO Threshold Register
+    {0x0100,0x00},   // BitBlt Control Register 0
+    {0x0101,0x00},   // BitBlt Control Register 1
+    {0x0102,0x00},   // BitBlt ROP Code/Color Expansion Register
+    {0x0103,0x00},   // BitBlt Operation Register
+    {0x0104,0x00},   // BitBlt Source Start Address Register 0
+    {0x0105,0x00},   // BitBlt Source Start Address Register 1
+    {0x0106,0x00},   // BitBlt Source Start Address Register 2
+    {0x0108,0x00},   // BitBlt Destination Start Address Register 0
+    {0x0109,0x00},   // BitBlt Destination Start Address Register 1
+    {0x010A,0x00},   // BitBlt Destination Start Address Register 2
+    {0x010C,0x00},   // BitBlt Memory Address Offset Register 0
+    {0x010D,0x00},   // BitBlt Memory Address Offset Register 1
+    {0x0110,0x00},   // BitBlt Width Register 0
+    {0x0111,0x00},   // BitBlt Width Register 1
+    {0x0112,0x00},   // BitBlt Height Register 0
+    {0x0113,0x00},   // BitBlt Height Register 1
+    {0x0114,0x00},   // BitBlt Background Color Register 0
+    {0x0115,0x00},   // BitBlt Background Color Register 1
+    {0x0118,0x00},   // BitBlt Foreground Color Register 0
+    {0x0119,0x00},   // BitBlt Foreground Color Register 1
+    {0x01E0,0x00},   // Look-Up Table Mode Register
+    {0x01E2,0x00},   // Look-Up Table Address Register
+    {0x01F0,0x10},   // Power Save Configuration Register
+    {0x01F1,0x00},   // Power Save Status Register
+    {0x01F4,0x00},   // CPU-to-Memory Access Watchdog Timer Register
+#if (SWIVEL_VIEW == 0)
+    {0x01FC,0x01},   // Display Mode Register(0x01:LCD, 0x02:CRT, 0x03:LCD&CRT)
+#elif (SWIVEL_VIEW == 1)
+    {0x01FC,0x41},   // Display Mode Register(0x01:LCD, 0x02:CRT, 0x03:LCD&CRT)
+#else
+#error unsupported SWIVEL_VIEW mode
+#endif  /* SWIVEL_VIEW */
+
+#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)
+    {0x0008,0x07},   // LCD panel Vdd & Vg on
+#endif
+
+    {0x0040,0x05},   // LCD Display Mode Register (2:4bpp,3:8bpp,5:16bpp)
+#if defined(CONFIG_PLAT_MAPPI)
+    {0x0046,0x80},   // LCD Memory Address Offset Register 0
+    {0x0047,0x02},   // LCD Memory Address Offset Register 1
+#elif defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)
+    {0x0046,0xf0},   // LCD Memory Address Offset Register 0
+    {0x0047,0x00},   // LCD Memory Address Offset Register 1
+#endif
+    {0x0060,0x05},   // CRT/TV Display Mode Register (2:4bpp,3:8bpp,5:16bpp)
+    {0x0066,0x80},   // CRT/TV Memory Address Offset Register 0	// takeo
+    {0x0067,0x02},   // CRT/TV Memory Address Offset Register 1
+};
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/scatterlist.h linux-2.6.30-rc3/arch/m32r/include/asm/scatterlist.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/scatterlist.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/scatterlist.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,21 @@
+#ifndef _ASM_M32R_SCATTERLIST_H
+#define _ASM_M32R_SCATTERLIST_H
+
+#include <asm/types.h>
+
+struct scatterlist {
+#ifdef CONFIG_DEBUG_SG
+    unsigned long sg_magic;
+#endif
+    char *  address;    /* Location data is to be transferred to, NULL for
+                         * highmem page */
+    unsigned long page_link;
+    unsigned int offset;/* for highmem, page offset */
+
+    dma_addr_t dma_address;
+    unsigned int length;
+};
+
+#define ISA_DMA_THRESHOLD (0x1fffffff)
+
+#endif /* _ASM_M32R_SCATTERLIST_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/sections.h linux-2.6.30-rc3/arch/m32r/include/asm/sections.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/sections.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/sections.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,7 @@
+#ifndef _M32R_SECTIONS_H
+#define _M32R_SECTIONS_H
+
+/* nothing to see, move along */
+#include <asm-generic/sections.h>
+
+#endif	/* _M32R_SECTIONS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/segment.h linux-2.6.30-rc3/arch/m32r/include/asm/segment.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/segment.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/segment.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,10 @@
+#ifndef _ASM_M32R_SEGMENT_H
+#define _ASM_M32R_SEGMENT_H
+
+#define __KERNEL_CS	0x10
+#define __KERNEL_DS	0x18
+
+#define __USER_CS	0x23
+#define __USER_DS	0x2B
+
+#endif  /* _ASM_M32R_SEGMENT_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/sembuf.h linux-2.6.30-rc3/arch/m32r/include/asm/sembuf.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/sembuf.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/sembuf.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,25 @@
+#ifndef _ASM_M32R_SEMBUF_H
+#define _ASM_M32R_SEMBUF_H
+
+/*
+ * The semid64_ds structure for m32r architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;		/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;		/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_M32R_SEMBUF_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/serial.h linux-2.6.30-rc3/arch/m32r/include/asm/serial.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/serial.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/serial.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,9 @@
+#ifndef _ASM_M32R_SERIAL_H
+#define _ASM_M32R_SERIAL_H
+
+/* include/asm-m32r/serial.h */
+
+
+#define BASE_BAUD	115200
+
+#endif  /* _ASM_M32R_SERIAL_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/setup.h linux-2.6.30-rc3/arch/m32r/include/asm/setup.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/setup.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/setup.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,38 @@
+#ifndef _ASM_M32R_SETUP_H
+#define _ASM_M32R_SETUP_H
+
+/*
+ * This is set up by the setup-routine at boot-time
+ */
+
+#define COMMAND_LINE_SIZE       512
+
+#ifdef __KERNEL__
+
+#define PARAM			((unsigned char *)empty_zero_page)
+
+#define MOUNT_ROOT_RDONLY	(*(unsigned long *) (PARAM+0x000))
+#define RAMDISK_FLAGS		(*(unsigned long *) (PARAM+0x004))
+#define ORIG_ROOT_DEV		(*(unsigned long *) (PARAM+0x008))
+#define LOADER_TYPE		(*(unsigned long *) (PARAM+0x00c))
+#define INITRD_START		(*(unsigned long *) (PARAM+0x010))
+#define INITRD_SIZE		(*(unsigned long *) (PARAM+0x014))
+
+#define M32R_CPUCLK		(*(unsigned long *) (PARAM+0x018))
+#define M32R_BUSCLK		(*(unsigned long *) (PARAM+0x01c))
+#define M32R_TIMER_DIVIDE	(*(unsigned long *) (PARAM+0x020))
+
+#define COMMAND_LINE		((char *) (PARAM+0x100))
+
+#define SCREEN_INFO		(*(struct screen_info *) (PARAM+0x200))
+
+#define RAMDISK_IMAGE_START_MASK	(0x07FF)
+#define RAMDISK_PROMPT_FLAG		(0x8000)
+#define RAMDISK_LOAD_FLAG		(0x4000)
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
+#endif  /*  __KERNEL__  */
+
+#endif /* _ASM_M32R_SETUP_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/shmbuf.h linux-2.6.30-rc3/arch/m32r/include/asm/shmbuf.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/shmbuf.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/shmbuf.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,42 @@
+#ifndef _ASM_M32R_SHMBUF_H
+#define _ASM_M32R_SHMBUF_H
+
+/*
+ * The shmid64_ds structure for M32R architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	unsigned long		__unused1;
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	unsigned long		__unused2;
+	__kernel_time_t		shm_ctime;	/* last change time */
+	unsigned long		__unused3;
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_M32R_SHMBUF_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/shmparam.h linux-2.6.30-rc3/arch/m32r/include/asm/shmparam.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/shmparam.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/shmparam.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_M32R_SHMPARAM_H
+#define _ASM_M32R_SHMPARAM_H
+
+#define	SHMLBA PAGE_SIZE		 /* attach addr a multiple of this */
+
+#endif /* _ASM_M32R_SHMPARAM_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/sigcontext.h linux-2.6.30-rc3/arch/m32r/include/asm/sigcontext.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/sigcontext.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/sigcontext.h	2009-04-22 03:29:16.273931460 +0000
@@ -0,0 +1,39 @@
+#ifndef _ASM_M32R_SIGCONTEXT_H
+#define _ASM_M32R_SIGCONTEXT_H
+
+struct sigcontext {
+	/* CPU registers */
+	/* Saved main processor registers. */
+	unsigned long sc_r4;
+	unsigned long sc_r5;
+	unsigned long sc_r6;
+	struct pt_regs *sc_pt_regs;
+	unsigned long sc_r0;
+	unsigned long sc_r1;
+	unsigned long sc_r2;
+	unsigned long sc_r3;
+	unsigned long sc_r7;
+	unsigned long sc_r8;
+	unsigned long sc_r9;
+	unsigned long sc_r10;
+	unsigned long sc_r11;
+	unsigned long sc_r12;
+
+	/* Saved main processor status and miscellaneous context registers. */
+	unsigned long sc_acc0h;
+	unsigned long sc_acc0l;
+	unsigned long sc_acc1h;	/* ISA_DSP_LEVEL2 only */
+	unsigned long sc_acc1l;	/* ISA_DSP_LEVEL2 only */
+	unsigned long sc_psw;
+	unsigned long sc_bpc;		/* saved PC for TRAP syscalls */
+	unsigned long sc_bbpsw;
+	unsigned long sc_bbpc;
+	unsigned long sc_spu;		/* saved user stack */
+	unsigned long sc_fp;
+	unsigned long sc_lr;		/* saved PC for JL syscalls */
+	unsigned long sc_spi;		/* saved kernel stack */
+
+	unsigned long	oldmask;
+};
+
+#endif  /* _ASM_M32R_SIGCONTEXT_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/siginfo.h linux-2.6.30-rc3/arch/m32r/include/asm/siginfo.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/siginfo.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/siginfo.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,6 @@
+#ifndef _M32R_SIGINFO_H
+#define _M32R_SIGINFO_H
+
+#include <asm-generic/siginfo.h>
+
+#endif /* _M32R_SIGINFO_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/signal.h linux-2.6.30-rc3/arch/m32r/include/asm/signal.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/signal.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/signal.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,166 @@
+#ifndef _ASM_M32R_SIGNAL_H
+#define _ASM_M32R_SIGNAL_H
+
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/compiler.h>
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+#ifdef __KERNEL__
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
+#define _NSIG		64
+#define _NSIG_BPW	32
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+typedef unsigned long old_sigset_t;		/* at least 32 bits */
+
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif /* __KERNEL__ */
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001u
+#define SA_NOCLDWAIT	0x00000002u
+#define SA_SIGINFO	0x00000004u
+#define SA_ONSTACK	0x08000000u
+#define SA_RESTART	0x10000000u
+#define SA_NODEFER	0x40000000u
+#define SA_RESETHAND	0x80000000u
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+#define SA_RESTORER	0x04000000
+
+/*
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#include <asm-generic/signal.h>
+
+#ifdef __KERNEL__
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	unsigned long sa_flags;
+	__sigrestore_t sa_restorer;
+};
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	__sigrestore_t sa_restorer;
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+struct sigaction {
+	union {
+	  __sighandler_t _sa_handler;
+	  void (*_sa_sigaction)(int, struct siginfo *, void *);
+	} _u;
+	sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+};
+
+#define sa_handler	_u._sa_handler
+#define sa_sigaction	_u._sa_sigaction
+
+#endif /* __KERNEL__ */
+
+typedef struct sigaltstack {
+	void __user *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#ifdef __KERNEL__
+#include <asm/sigcontext.h>
+
+#undef __HAVE_ARCH_SIG_BITOPS
+
+struct pt_regs;
+extern int do_signal(struct pt_regs *regs, sigset_t *oldset);
+
+#define ptrace_signal_deliver(regs, cookie)	do { } while (0)
+
+#endif /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_SIGNAL_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/smp.h linux-2.6.30-rc3/arch/m32r/include/asm/smp.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/smp.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/smp.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,119 @@
+#ifndef _ASM_M32R_SMP_H
+#define _ASM_M32R_SMP_H
+
+#ifdef CONFIG_SMP
+#ifndef __ASSEMBLY__
+
+#include <linux/cpumask.h>
+#include <linux/spinlock.h>
+#include <linux/threads.h>
+#include <asm/m32r.h>
+
+#define PHYSID_ARRAY_SIZE       1
+
+struct physid_mask
+{
+	unsigned long mask[PHYSID_ARRAY_SIZE];
+};
+
+typedef struct physid_mask physid_mask_t;
+
+#define physid_set(physid, map)                 set_bit(physid, (map).mask)
+#define physid_clear(physid, map)               clear_bit(physid, (map).mask)
+#define physid_isset(physid, map)               test_bit(physid, (map).mask)
+#define physid_test_and_set(physid, map)        test_and_set_bit(physid, (map).mask)
+
+#define physids_and(dst, src1, src2)            bitmap_and((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
+#define physids_or(dst, src1, src2)             bitmap_or((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
+#define physids_clear(map)                      bitmap_zero((map).mask, MAX_APICS)
+#define physids_complement(dst, src)            bitmap_complement((dst).mask,(src).mask, MAX_APICS)
+#define physids_empty(map)                      bitmap_empty((map).mask, MAX_APICS)
+#define physids_equal(map1, map2)               bitmap_equal((map1).mask, (map2).mask, MAX_APICS)
+#define physids_weight(map)                     bitmap_weight((map).mask, MAX_APICS)
+#define physids_shift_right(d, s, n)            bitmap_shift_right((d).mask, (s).mask, n, MAX_APICS)
+#define physids_shift_left(d, s, n)             bitmap_shift_left((d).mask, (s).mask, n, MAX_APICS)
+#define physids_coerce(map)                     ((map).mask[0])
+
+#define physids_promote(physids)					\
+	({								\
+		physid_mask_t __physid_mask = PHYSID_MASK_NONE;		\
+		__physid_mask.mask[0] = physids;			\
+		__physid_mask;						\
+	})
+
+#define physid_mask_of_physid(physid)					\
+	({								\
+		physid_mask_t __physid_mask = PHYSID_MASK_NONE;		\
+		physid_set(physid, __physid_mask);			\
+		__physid_mask;						\
+	})
+
+#define PHYSID_MASK_ALL         { {[0 ... PHYSID_ARRAY_SIZE-1] = ~0UL} }
+#define PHYSID_MASK_NONE        { {[0 ... PHYSID_ARRAY_SIZE-1] = 0UL} }
+
+extern physid_mask_t phys_cpu_present_map;
+
+/*
+ * Some lowlevel functions might want to know about
+ * the real CPU ID <-> CPU # mapping.
+ */
+extern volatile int cpu_2_physid[NR_CPUS];
+#define cpu_to_physid(cpu_id)	cpu_2_physid[cpu_id]
+
+#define raw_smp_processor_id()	(current_thread_info()->cpu)
+
+extern cpumask_t cpu_callout_map;
+
+static __inline__ int hard_smp_processor_id(void)
+{
+	return (int)*(volatile long *)M32R_CPUID_PORTL;
+}
+
+static __inline__ int cpu_logical_map(int cpu)
+{
+	return cpu;
+}
+
+static __inline__ int cpu_number_map(int cpu)
+{
+	return cpu;
+}
+
+static __inline__ unsigned int num_booting_cpus(void)
+{
+	return cpus_weight(cpu_callout_map);
+}
+
+extern void smp_send_timer(void);
+extern unsigned long send_IPI_mask_phys(cpumask_t, int, int);
+
+extern void arch_send_call_function_single_ipi(int cpu);
+extern void arch_send_call_function_ipi(cpumask_t mask);
+
+#endif	/* not __ASSEMBLY__ */
+
+#define NO_PROC_ID (0xff)	/* No processor magic marker */
+
+#define PROC_CHANGE_PENALTY	(15)	/* Schedule penalty */
+
+/*
+ * M32R-mp IPI
+ */
+#define RESCHEDULE_IPI		(M32R_IRQ_IPI0-M32R_IRQ_IPI0)
+#define INVALIDATE_TLB_IPI	(M32R_IRQ_IPI1-M32R_IRQ_IPI0)
+#define CALL_FUNCTION_IPI	(M32R_IRQ_IPI2-M32R_IRQ_IPI0)
+#define LOCAL_TIMER_IPI		(M32R_IRQ_IPI3-M32R_IRQ_IPI0)
+#define INVALIDATE_CACHE_IPI	(M32R_IRQ_IPI4-M32R_IRQ_IPI0)
+#define CPU_BOOT_IPI		(M32R_IRQ_IPI5-M32R_IRQ_IPI0)
+#define CALL_FUNC_SINGLE_IPI	(M32R_IRQ_IPI6-M32R_IRQ_IPI0)
+
+#define IPI_SHIFT	(0)
+#define NR_IPIS		(8)
+
+#else	/* CONFIG_SMP */
+
+#define hard_smp_processor_id()		0
+
+#endif /* CONFIG_SMP */
+
+#endif	/* _ASM_M32R_SMP_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/socket.h linux-2.6.30-rc3/arch/m32r/include/asm/socket.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/socket.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/socket.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,60 @@
+#ifndef _ASM_M32R_SOCKET_H
+#define _ASM_M32R_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockoptions(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME		28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+
+#define SO_PEERSEC		31
+#define SO_PASSSEC		34
+#define SO_TIMESTAMPNS		35
+#define SCM_TIMESTAMPNS		SO_TIMESTAMPNS
+
+#define SO_MARK			36
+
+#define SO_TIMESTAMPING		37
+#define SCM_TIMESTAMPING	SO_TIMESTAMPING
+
+#endif /* _ASM_M32R_SOCKET_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/sockios.h linux-2.6.30-rc3/arch/m32r/include/asm/sockios.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/sockios.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/sockios.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,13 @@
+#ifndef _ASM_M32R_SOCKIOS_H
+#define _ASM_M32R_SOCKIOS_H
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN 	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906		/* Get stamp (timeval) */
+#define SIOCGSTAMPNS	0x8907		/* Get stamp (timespec) */
+
+#endif  /* _ASM_M32R_SOCKIOS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/spinlock.h linux-2.6.30-rc3/arch/m32r/include/asm/spinlock.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/spinlock.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/spinlock.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,326 @@
+#ifndef _ASM_M32R_SPINLOCK_H
+#define _ASM_M32R_SPINLOCK_H
+
+/*
+ *  linux/include/asm-m32r/spinlock.h
+ *
+ *  M32R version:
+ *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
+ *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#include <linux/compiler.h>
+#include <asm/atomic.h>
+#include <asm/page.h>
+
+/*
+ * Your basic SMP spinlocks, allowing only a single CPU anywhere
+ *
+ * (the type definitions are in asm/spinlock_types.h)
+ *
+ * Simple spin lock operations.  There are two variants, one clears IRQ's
+ * on the local processor, one does not.
+ *
+ * We make no fairness assumptions. They have a cost.
+ */
+
+#define __raw_spin_is_locked(x)		(*(volatile int *)(&(x)->slock) <= 0)
+#define __raw_spin_lock_flags(lock, flags) __raw_spin_lock(lock)
+#define __raw_spin_unlock_wait(x) \
+		do { cpu_relax(); } while (__raw_spin_is_locked(x))
+
+/**
+ * __raw_spin_trylock - Try spin lock and return a result
+ * @lock: Pointer to the lock variable
+ *
+ * __raw_spin_trylock() tries to get the lock and returns a result.
+ * On the m32r, the result value is 1 (= Success) or 0 (= Failure).
+ */
+static inline int __raw_spin_trylock(raw_spinlock_t *lock)
+{
+	int oldval;
+	unsigned long tmp1, tmp2;
+
+	/*
+	 * lock->slock :  =1 : unlock
+	 *             : <=0 : lock
+	 * {
+	 *   oldval = lock->slock; <--+ need atomic operation
+	 *   lock->slock = 0;      <--+
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# __raw_spin_trylock		\n\t"
+		"ldi	%1, #0;			\n\t"
+		"mvfc	%2, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("%0", "r6", "%3")
+		"lock	%0, @%3;		\n\t"
+		"unlock	%1, @%3;		\n\t"
+		"mvtc	%2, psw;		\n\t"
+		: "=&r" (oldval), "=&r" (tmp1), "=&r" (tmp2)
+		: "r" (&lock->slock)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+
+	return (oldval > 0);
+}
+
+static inline void __raw_spin_lock(raw_spinlock_t *lock)
+{
+	unsigned long tmp0, tmp1;
+
+	/*
+	 * lock->slock :  =1 : unlock
+	 *             : <=0 : lock
+	 *
+	 * for ( ; ; ) {
+	 *   lock->slock -= 1;  <-- need atomic operation
+	 *   if (lock->slock == 0) break;
+	 *   for ( ; lock->slock <= 0 ; );
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# __raw_spin_lock		\n\t"
+		".fillinsn			\n"
+		"1:				\n\t"
+		"mvfc	%1, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("%0", "r6", "%2")
+		"lock	%0, @%2;		\n\t"
+		"addi	%0, #-1;		\n\t"
+		"unlock	%0, @%2;		\n\t"
+		"mvtc	%1, psw;		\n\t"
+		"bltz	%0, 2f;			\n\t"
+		LOCK_SECTION_START(".balign 4 \n\t")
+		".fillinsn			\n"
+		"2:				\n\t"
+		"ld	%0, @%2;		\n\t"
+		"bgtz	%0, 1b;			\n\t"
+		"bra	2b;			\n\t"
+		LOCK_SECTION_END
+		: "=&r" (tmp0), "=&r" (tmp1)
+		: "r" (&lock->slock)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static inline void __raw_spin_unlock(raw_spinlock_t *lock)
+{
+	mb();
+	lock->slock = 1;
+}
+
+/*
+ * Read-write spinlocks, allowing multiple readers
+ * but only one writer.
+ *
+ * NOTE! it is quite common to have readers in interrupts
+ * but no interrupt writers. For those circumstances we
+ * can "mix" irq-safe locks - any writer needs to get a
+ * irq-safe write-lock, but readers can get non-irqsafe
+ * read-locks.
+ *
+ * On x86, we implement read-write locks as a 32-bit counter
+ * with the high bit (sign) being the "contended" bit.
+ *
+ * The inline assembly is non-obvious. Think about it.
+ *
+ * Changed to use the same technique as rw semaphores.  See
+ * semaphore.h for details.  -ben
+ */
+
+/**
+ * read_can_lock - would read_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define __raw_read_can_lock(x) ((int)(x)->lock > 0)
+
+/**
+ * write_can_lock - would write_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define __raw_write_can_lock(x) ((x)->lock == RW_LOCK_BIAS)
+
+static inline void __raw_read_lock(raw_rwlock_t *rw)
+{
+	unsigned long tmp0, tmp1;
+
+	/*
+	 * rw->lock :  >0 : unlock
+	 *          : <=0 : lock
+	 *
+	 * for ( ; ; ) {
+	 *   rw->lock -= 1;  <-- need atomic operation
+	 *   if (rw->lock >= 0) break;
+	 *   rw->lock += 1;  <-- need atomic operation
+	 *   for ( ; rw->lock <= 0 ; );
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# read_lock			\n\t"
+		".fillinsn			\n"
+		"1:				\n\t"
+		"mvfc	%1, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("%0", "r6", "%2")
+		"lock	%0, @%2;		\n\t"
+		"addi	%0, #-1;		\n\t"
+		"unlock	%0, @%2;		\n\t"
+		"mvtc	%1, psw;		\n\t"
+		"bltz	%0, 2f;			\n\t"
+		LOCK_SECTION_START(".balign 4 \n\t")
+		".fillinsn			\n"
+		"2:				\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("%0", "r6", "%2")
+		"lock	%0, @%2;		\n\t"
+		"addi	%0, #1;			\n\t"
+		"unlock	%0, @%2;		\n\t"
+		"mvtc	%1, psw;		\n\t"
+		".fillinsn			\n"
+		"3:				\n\t"
+		"ld	%0, @%2;		\n\t"
+		"bgtz	%0, 1b;			\n\t"
+		"bra	3b;			\n\t"
+		LOCK_SECTION_END
+		: "=&r" (tmp0), "=&r" (tmp1)
+		: "r" (&rw->lock)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static inline void __raw_write_lock(raw_rwlock_t *rw)
+{
+	unsigned long tmp0, tmp1, tmp2;
+
+	/*
+	 * rw->lock :  =RW_LOCK_BIAS_STR : unlock
+	 *          : !=RW_LOCK_BIAS_STR : lock
+	 *
+	 * for ( ; ; ) {
+	 *   rw->lock -= RW_LOCK_BIAS_STR;  <-- need atomic operation
+	 *   if (rw->lock == 0) break;
+	 *   rw->lock += RW_LOCK_BIAS_STR;  <-- need atomic operation
+	 *   for ( ; rw->lock != RW_LOCK_BIAS_STR ; ) ;
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# write_lock					\n\t"
+		"seth	%1, #high(" RW_LOCK_BIAS_STR ");	\n\t"
+		"or3	%1, %1, #low(" RW_LOCK_BIAS_STR ");	\n\t"
+		".fillinsn					\n"
+		"1:						\n\t"
+		"mvfc	%2, psw;				\n\t"
+		"clrpsw	#0x40 -> nop;				\n\t"
+		DCACHE_CLEAR("%0", "r7", "%3")
+		"lock	%0, @%3;				\n\t"
+		"sub	%0, %1;					\n\t"
+		"unlock	%0, @%3;				\n\t"
+		"mvtc	%2, psw;				\n\t"
+		"bnez	%0, 2f;					\n\t"
+		LOCK_SECTION_START(".balign 4 \n\t")
+		".fillinsn					\n"
+		"2:						\n\t"
+		"clrpsw	#0x40 -> nop;				\n\t"
+		DCACHE_CLEAR("%0", "r7", "%3")
+		"lock	%0, @%3;				\n\t"
+		"add	%0, %1;					\n\t"
+		"unlock	%0, @%3;				\n\t"
+		"mvtc	%2, psw;				\n\t"
+		".fillinsn					\n"
+		"3:						\n\t"
+		"ld	%0, @%3;				\n\t"
+		"beq	%0, %1, 1b;				\n\t"
+		"bra	3b;					\n\t"
+		LOCK_SECTION_END
+		: "=&r" (tmp0), "=&r" (tmp1), "=&r" (tmp2)
+		: "r" (&rw->lock)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r7"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static inline void __raw_read_unlock(raw_rwlock_t *rw)
+{
+	unsigned long tmp0, tmp1;
+
+	__asm__ __volatile__ (
+		"# read_unlock			\n\t"
+		"mvfc	%1, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("%0", "r6", "%2")
+		"lock	%0, @%2;		\n\t"
+		"addi	%0, #1;			\n\t"
+		"unlock	%0, @%2;		\n\t"
+		"mvtc	%1, psw;		\n\t"
+		: "=&r" (tmp0), "=&r" (tmp1)
+		: "r" (&rw->lock)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static inline void __raw_write_unlock(raw_rwlock_t *rw)
+{
+	unsigned long tmp0, tmp1, tmp2;
+
+	__asm__ __volatile__ (
+		"# write_unlock					\n\t"
+		"seth	%1, #high(" RW_LOCK_BIAS_STR ");	\n\t"
+		"or3	%1, %1, #low(" RW_LOCK_BIAS_STR ");	\n\t"
+		"mvfc	%2, psw;				\n\t"
+		"clrpsw	#0x40 -> nop;				\n\t"
+		DCACHE_CLEAR("%0", "r7", "%3")
+		"lock	%0, @%3;				\n\t"
+		"add	%0, %1;					\n\t"
+		"unlock	%0, @%3;				\n\t"
+		"mvtc	%2, psw;				\n\t"
+		: "=&r" (tmp0), "=&r" (tmp1), "=&r" (tmp2)
+		: "r" (&rw->lock)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r7"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static inline int __raw_read_trylock(raw_rwlock_t *lock)
+{
+	atomic_t *count = (atomic_t*)lock;
+	if (atomic_dec_return(count) >= 0)
+		return 1;
+	atomic_inc(count);
+	return 0;
+}
+
+static inline int __raw_write_trylock(raw_rwlock_t *lock)
+{
+	atomic_t *count = (atomic_t *)lock;
+	if (atomic_sub_and_test(RW_LOCK_BIAS, count))
+		return 1;
+	atomic_add(RW_LOCK_BIAS, count);
+	return 0;
+}
+
+#define __raw_read_lock_flags(lock, flags) __raw_read_lock(lock)
+#define __raw_write_lock_flags(lock, flags) __raw_write_lock(lock)
+
+#define _raw_spin_relax(lock)	cpu_relax()
+#define _raw_read_relax(lock)	cpu_relax()
+#define _raw_write_relax(lock)	cpu_relax()
+
+#endif	/* _ASM_M32R_SPINLOCK_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/spinlock_types.h linux-2.6.30-rc3/arch/m32r/include/asm/spinlock_types.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/spinlock_types.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/spinlock_types.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,23 @@
+#ifndef _ASM_M32R_SPINLOCK_TYPES_H
+#define _ASM_M32R_SPINLOCK_TYPES_H
+
+#ifndef __LINUX_SPINLOCK_TYPES_H
+# error "please don't include this file directly"
+#endif
+
+typedef struct {
+	volatile int slock;
+} raw_spinlock_t;
+
+#define __RAW_SPIN_LOCK_UNLOCKED	{ 1 }
+
+typedef struct {
+	volatile int lock;
+} raw_rwlock_t;
+
+#define RW_LOCK_BIAS			0x01000000
+#define RW_LOCK_BIAS_STR		"0x01000000"
+
+#define __RAW_RW_LOCK_UNLOCKED		{ RW_LOCK_BIAS }
+
+#endif /* _ASM_M32R_SPINLOCK_TYPES_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/stat.h linux-2.6.30-rc3/arch/m32r/include/asm/stat.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/stat.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/stat.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,87 @@
+#ifndef _ASM_M32R_STAT_H
+#define _ASM_M32R_STAT_H
+
+#include <asm/byteorder.h>
+
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned long  st_size;
+	unsigned long  st_atime;
+	unsigned long  st_mtime;
+	unsigned long  st_ctime;
+};
+
+#define STAT_HAVE_NSEC	1
+
+struct stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long  st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+	unsigned long  st_atime_nsec;
+	unsigned long  st_mtime;
+	unsigned long  st_mtime_nsec;
+	unsigned long  st_ctime;
+	unsigned long  st_ctime_nsec;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned long long	st_dev;
+	unsigned char	__pad0[4];
+#define STAT64_HAS_BROKEN_ST_INO
+	unsigned long	__st_ino;
+
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long	st_rdev;
+	unsigned char	__pad3[4];
+
+	long long	st_size;
+	unsigned long	st_blksize;
+
+#if defined(__BIG_ENDIAN)
+	unsigned long	__pad4;		/* future possible st_blocks high bits */
+	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
+#elif defined(__LITTLE_ENDIAN)
+	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
+	unsigned long	__pad4;		/* future possible st_blocks high bits */
+#else
+#error no endian defined
+#endif
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long long	st_ino;
+};
+
+#endif  /* _ASM_M32R_STAT_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/statfs.h linux-2.6.30-rc3/arch/m32r/include/asm/statfs.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/statfs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/statfs.h	2009-04-22 03:29:16.274931605 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_M32R_STATFS_H
+#define _ASM_M32R_STATFS_H
+
+#include <asm-generic/statfs.h>
+
+#endif  /* _ASM_M32R_STATFS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/string.h linux-2.6.30-rc3/arch/m32r/include/asm/string.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/string.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/string.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,13 @@
+#ifndef _ASM_M32R_STRING_H
+#define _ASM_M32R_STRING_H
+
+#define  __HAVE_ARCH_STRLEN
+extern size_t strlen(const char * s);
+
+#define  __HAVE_ARCH_MEMCPY
+extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
+
+#define  __HAVE_ARCH_MEMSET
+extern void *memset(void *__s, int __c, size_t __count);
+
+#endif  /* _ASM_M32R_STRING_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/swab.h linux-2.6.30-rc3/arch/m32r/include/asm/swab.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/swab.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/swab.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,10 @@
+#ifndef _ASM_M32R_SWAB_H
+#define _ASM_M32R_SWAB_H
+
+#include <linux/types.h>
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __SWAB_64_THRU_32__
+#endif
+
+#endif /* _ASM_M32R_SWAB_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/syscall.h linux-2.6.30-rc3/arch/m32r/include/asm/syscall.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/syscall.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/syscall.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,8 @@
+#ifndef _ASM_M32R_SYSCALL_H
+#define _ASM_M32R_SYSCALL_H
+
+/* Definitions for the system call vector.  */
+#define SYSCALL_VECTOR          "2"
+#define SYSCALL_VECTOR_ADDRESS  "0xa0"
+
+#endif /* _ASM_M32R_SYSCALL_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/system.h linux-2.6.30-rc3/arch/m32r/include/asm/system.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/system.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/system.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,431 @@
+#ifndef _ASM_M32R_SYSTEM_H
+#define _ASM_M32R_SYSTEM_H
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001  Hiroyuki Kondo, Hirokazu Takata, and Hitoshi Yamamoto
+ * Copyright (C) 2004, 2006  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#include <linux/compiler.h>
+#include <asm/assembler.h>
+
+#ifdef __KERNEL__
+
+/*
+ * switch_to(prev, next) should switch from task `prev' to `next'
+ * `prev' will never be the same as `next'.
+ *
+ * `next' and `prev' should be struct task_struct, but it isn't always defined
+ */
+
+#if defined(CONFIG_FRAME_POINTER) || \
+	!defined(CONFIG_SCHED_OMIT_FRAME_POINTER)
+#define M32R_PUSH_FP "	push fp\n"
+#define M32R_POP_FP  "	pop  fp\n"
+#else
+#define M32R_PUSH_FP ""
+#define M32R_POP_FP  ""
+#endif
+
+#define switch_to(prev, next, last)  do { \
+	__asm__ __volatile__ ( \
+		"	seth	lr, #high(1f)				\n" \
+		"	or3	lr, lr, #low(1f)			\n" \
+		"	st	lr, @%4  ; store old LR			\n" \
+		"	ld	lr, @%5  ; load new LR			\n" \
+			M32R_PUSH_FP \
+		"	st	sp, @%2  ; store old SP			\n" \
+		"	ld	sp, @%3  ; load new SP			\n" \
+		"	push	%1  ; store `prev' on new stack		\n" \
+		"	jmp	lr					\n" \
+		"	.fillinsn					\n" \
+		"1:							\n" \
+		"	pop	%0  ; restore `__last' from new stack	\n" \
+			M32R_POP_FP \
+		: "=r" (last) \
+		: "0" (prev), \
+		  "r" (&(prev->thread.sp)), "r" (&(next->thread.sp)), \
+		  "r" (&(prev->thread.lr)), "r" (&(next->thread.lr)) \
+		: "memory", "lr" \
+	); \
+} while(0)
+
+/* Interrupt Control */
+#if !defined(CONFIG_CHIP_M32102) && !defined(CONFIG_CHIP_M32104)
+#define local_irq_enable() \
+	__asm__ __volatile__ ("setpsw #0x40 -> nop": : :"memory")
+#define local_irq_disable() \
+	__asm__ __volatile__ ("clrpsw #0x40 -> nop": : :"memory")
+#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
+static inline void local_irq_enable(void)
+{
+	unsigned long tmpreg;
+	__asm__ __volatile__(
+		"mvfc	%0, psw;		\n\t"
+		"or3	%0, %0, #0x0040;	\n\t"
+		"mvtc	%0, psw;		\n\t"
+	: "=&r" (tmpreg) : : "cbit", "memory");
+}
+
+static inline void local_irq_disable(void)
+{
+	unsigned long tmpreg0, tmpreg1;
+	__asm__ __volatile__(
+		"ld24	%0, #0	; Use 32-bit insn. \n\t"
+		"mvfc	%1, psw	; No interrupt can be accepted here. \n\t"
+		"mvtc	%0, psw	\n\t"
+		"and3	%0, %1, #0xffbf	\n\t"
+		"mvtc	%0, psw	\n\t"
+	: "=&r" (tmpreg0), "=&r" (tmpreg1) : : "cbit", "memory");
+}
+#endif	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
+
+#define local_save_flags(x) \
+	__asm__ __volatile__("mvfc %0,psw" : "=r"(x) : /* no input */)
+
+#define local_irq_restore(x) \
+	__asm__ __volatile__("mvtc %0,psw" : /* no outputs */ \
+		: "r" (x) : "cbit", "memory")
+
+#if !(defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_M32104))
+#define local_irq_save(x)				\
+	__asm__ __volatile__(				\
+  		"mvfc	%0, psw;		\n\t"	\
+	  	"clrpsw	#0x40 -> nop;		\n\t"	\
+  		: "=r" (x) : /* no input */ : "memory")
+#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
+#define local_irq_save(x) 				\
+	({						\
+		unsigned long tmpreg;			\
+		__asm__ __volatile__( 			\
+			"ld24	%1, #0 \n\t" 		\
+			"mvfc	%0, psw \n\t"		\
+			"mvtc	%1, psw \n\t"		\
+			"and3	%1, %0, #0xffbf \n\t"	\
+			"mvtc	%1, psw \n\t" 		\
+			: "=r" (x), "=&r" (tmpreg)	\
+			: : "cbit", "memory");		\
+	})
+#endif	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
+
+#define irqs_disabled()					\
+	({						\
+		unsigned long flags;			\
+		local_save_flags(flags);		\
+		!(flags & 0x40);			\
+	})
+
+#define nop()	__asm__ __volatile__ ("nop" : : )
+
+#define xchg(ptr, x)							\
+	((__typeof__(*(ptr)))__xchg((unsigned long)(x), (ptr), sizeof(*(ptr))))
+#define xchg_local(ptr, x)						\
+	((__typeof__(*(ptr)))__xchg_local((unsigned long)(x), (ptr),	\
+			sizeof(*(ptr))))
+
+extern void  __xchg_called_with_bad_pointer(void);
+
+#ifdef CONFIG_CHIP_M32700_TS1
+#define DCACHE_CLEAR(reg0, reg1, addr)				\
+	"seth	"reg1", #high(dcache_dummy);		\n\t"	\
+	"or3	"reg1", "reg1", #low(dcache_dummy);	\n\t"	\
+	"lock	"reg0", @"reg1";			\n\t"	\
+	"add3	"reg0", "addr", #0x1000;		\n\t"	\
+	"ld	"reg0", @"reg0";			\n\t"	\
+	"add3	"reg0", "addr", #0x2000;		\n\t"	\
+	"ld	"reg0", @"reg0";			\n\t"	\
+	"unlock	"reg0", @"reg1";			\n\t"
+	/* FIXME: This workaround code cannot handle kernel modules
+	 * correctly under SMP environment.
+	 */
+#else	/* CONFIG_CHIP_M32700_TS1 */
+#define DCACHE_CLEAR(reg0, reg1, addr)
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+
+static __always_inline unsigned long
+__xchg(unsigned long x, volatile void *ptr, int size)
+{
+	unsigned long flags;
+	unsigned long tmp = 0;
+
+	local_irq_save(flags);
+
+	switch (size) {
+#ifndef CONFIG_SMP
+	case 1:
+		__asm__ __volatile__ (
+			"ldb	%0, @%2 \n\t"
+			"stb	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+	case 2:
+		__asm__ __volatile__ (
+			"ldh	%0, @%2 \n\t"
+			"sth	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+	case 4:
+		__asm__ __volatile__ (
+			"ld	%0, @%2 \n\t"
+			"st	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+#else  /* CONFIG_SMP */
+	case 4:
+		__asm__ __volatile__ (
+			DCACHE_CLEAR("%0", "r4", "%2")
+			"lock	%0, @%2;	\n\t"
+			"unlock	%1, @%2;	\n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr)
+			: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+			, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+		);
+		break;
+#endif  /* CONFIG_SMP */
+	default:
+		__xchg_called_with_bad_pointer();
+	}
+
+	local_irq_restore(flags);
+
+	return (tmp);
+}
+
+static __always_inline unsigned long
+__xchg_local(unsigned long x, volatile void *ptr, int size)
+{
+	unsigned long flags;
+	unsigned long tmp = 0;
+
+	local_irq_save(flags);
+
+	switch (size) {
+	case 1:
+		__asm__ __volatile__ (
+			"ldb	%0, @%2 \n\t"
+			"stb	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+	case 2:
+		__asm__ __volatile__ (
+			"ldh	%0, @%2 \n\t"
+			"sth	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+	case 4:
+		__asm__ __volatile__ (
+			"ld	%0, @%2 \n\t"
+			"st	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+	default:
+		__xchg_called_with_bad_pointer();
+	}
+
+	local_irq_restore(flags);
+
+	return (tmp);
+}
+
+#define __HAVE_ARCH_CMPXCHG	1
+
+static inline unsigned long
+__cmpxchg_u32(volatile unsigned int *p, unsigned int old, unsigned int new)
+{
+	unsigned long flags;
+	unsigned int retval;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+			DCACHE_CLEAR("%0", "r4", "%1")
+			M32R_LOCK" %0, @%1;	\n"
+		"	bne	%0, %2, 1f;	\n"
+			M32R_UNLOCK" %3, @%1;	\n"
+		"	bra	2f;		\n"
+                "       .fillinsn		\n"
+		"1:"
+			M32R_UNLOCK" %0, @%1;	\n"
+                "       .fillinsn		\n"
+		"2:"
+			: "=&r" (retval)
+			: "r" (p), "r" (old), "r" (new)
+			: "cbit", "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+			, "r4"
+#endif  /* CONFIG_CHIP_M32700_TS1 */
+		);
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+static inline unsigned long
+__cmpxchg_local_u32(volatile unsigned int *p, unsigned int old,
+			unsigned int new)
+{
+	unsigned long flags;
+	unsigned int retval;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+			DCACHE_CLEAR("%0", "r4", "%1")
+			"ld %0, @%1;		\n"
+		"	bne	%0, %2, 1f;	\n"
+			"st %3, @%1;		\n"
+		"	bra	2f;		\n"
+		"       .fillinsn		\n"
+		"1:"
+			"st %0, @%1;		\n"
+		"       .fillinsn		\n"
+		"2:"
+			: "=&r" (retval)
+			: "r" (p), "r" (old), "r" (new)
+			: "cbit", "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+			, "r4"
+#endif  /* CONFIG_CHIP_M32700_TS1 */
+		);
+	local_irq_restore(flags);
+
+	return retval;
+}
+
+/* This function doesn't exist, so you'll get a linker error
+   if something tries to do an invalid cmpxchg().  */
+extern void __cmpxchg_called_with_bad_pointer(void);
+
+static inline unsigned long
+__cmpxchg(volatile void *ptr, unsigned long old, unsigned long new, int size)
+{
+	switch (size) {
+	case 4:
+		return __cmpxchg_u32(ptr, old, new);
+#if 0	/* we don't have __cmpxchg_u64 */
+	case 8:
+		return __cmpxchg_u64(ptr, old, new);
+#endif /* 0 */
+	}
+	__cmpxchg_called_with_bad_pointer();
+	return old;
+}
+
+#define cmpxchg(ptr, o, n)						 \
+	((__typeof__(*(ptr))) __cmpxchg((ptr), (unsigned long)(o),	 \
+			(unsigned long)(n), sizeof(*(ptr))))
+
+#include <asm-generic/cmpxchg-local.h>
+
+static inline unsigned long __cmpxchg_local(volatile void *ptr,
+				      unsigned long old,
+				      unsigned long new, int size)
+{
+	switch (size) {
+	case 4:
+		return __cmpxchg_local_u32(ptr, old, new);
+	default:
+		return __cmpxchg_local_generic(ptr, old, new, size);
+	}
+
+	return old;
+}
+
+/*
+ * cmpxchg_local and cmpxchg64_local are atomic wrt current CPU. Always make
+ * them available.
+ */
+#define cmpxchg_local(ptr, o, n)				  	    \
+	((__typeof__(*(ptr)))__cmpxchg_local((ptr), (unsigned long)(o),	    \
+			(unsigned long)(n), sizeof(*(ptr))))
+#define cmpxchg64_local(ptr, o, n) __cmpxchg64_local_generic((ptr), (o), (n))
+
+#endif  /* __KERNEL__ */
+
+/*
+ * Memory barrier.
+ *
+ * mb() prevents loads and stores being reordered across this point.
+ * rmb() prevents loads being reordered across this point.
+ * wmb() prevents stores being reordered across this point.
+ */
+#define mb()   barrier()
+#define rmb()  mb()
+#define wmb()  mb()
+
+/**
+ * read_barrier_depends - Flush all pending reads that subsequents reads
+ * depend on.
+ *
+ * No data-dependent reads from memory-like regions are ever reordered
+ * over this barrier.  All reads preceding this primitive are guaranteed
+ * to access memory (but not necessarily other CPUs' caches) before any
+ * reads following this primitive that depend on the data return by
+ * any of the preceding reads.  This primitive is much lighter weight than
+ * rmb() on most CPUs, and is never heavier weight than is
+ * rmb().
+ *
+ * These ordering constraints are respected by both the local CPU
+ * and the compiler.
+ *
+ * Ordering is not guaranteed by anything other than these primitives,
+ * not even by data dependencies.  See the documentation for
+ * memory_barrier() for examples and URLs to more information.
+ *
+ * For example, the following code would force ordering (the initial
+ * value of "a" is zero, "b" is one, and "p" is "&a"):
+ *
+ * <programlisting>
+ *      CPU 0                           CPU 1
+ *
+ *      b = 2;
+ *      memory_barrier();
+ *      p = &b;                         q = p;
+ *                                      read_barrier_depends();
+ *                                      d = *q;
+ * </programlisting>
+ *
+ *
+ * because the read of "*q" depends on the read of "p" and these
+ * two reads are separated by a read_barrier_depends().  However,
+ * the following code, with the same initial values for "a" and "b":
+ *
+ * <programlisting>
+ *      CPU 0                           CPU 1
+ *
+ *      a = 2;
+ *      memory_barrier();
+ *      b = 3;                          y = b;
+ *                                      read_barrier_depends();
+ *                                      x = a;
+ * </programlisting>
+ *
+ * does not enforce ordering, since there is no data dependency between
+ * the read of "a" and the read of "b".  Therefore, on some CPUs, such
+ * as Alpha, "y" could be set to 3 and "x" to 0.  Use rmb()
+ * in cases like this where there are no data dependencies.
+ **/
+
+#define read_barrier_depends()	do { } while (0)
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#define smp_read_barrier_depends()	read_barrier_depends()
+#define set_mb(var, value) do { (void) xchg(&var, value); } while (0)
+#else
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#define smp_read_barrier_depends()	do { } while (0)
+#define set_mb(var, value) do { var = value; barrier(); } while (0)
+#endif
+
+#define arch_align_stack(x) (x)
+
+#endif /* _ASM_M32R_SYSTEM_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/termbits.h linux-2.6.30-rc3/arch/m32r/include/asm/termbits.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/termbits.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/termbits.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,199 @@
+#ifndef _ASM_M32R_TERMBITS_H
+#define _ASM_M32R_TERMBITS_H
+
+#include <linux/posix_types.h>
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+};
+
+struct termios2 {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+struct ktermios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8   0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    BOTHER 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000		/** input baud rate */
+#define CTVB	  004000000000		/* VisioBraille Terminal flow control */
+#define CMSPAR	  010000000000		/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000		/* flow control */
+
+#define	IBSHIFT	16			/* Shift from CBAUD to CIBAUD */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif /* _ASM_M32R_TERMBITS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/termios.h linux-2.6.30-rc3/arch/m32r/include/asm/termios.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/termios.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/termios.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,91 @@
+#ifndef _M32R_TERMIOS_H
+#define _M32R_TERMIOS_H
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+#ifdef __KERNEL__
+#include <linux/module.h>
+
+/*	intr=^C		quit=^\		erase=del	kill=^U
+	eof=^D		vtime=\0	vmin=\1		sxtc=\0
+	start=^Q	stop=^S		susp=^Z		eol=\0
+	reprint=^R	discard=^U	werase=^W	lnext=^V
+	eol2=\0
+*/
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
+
+/*
+ * Translate a "termio" structure into a "termios". Ugh.
+ */
+#define SET_LOW_TERMIOS_BITS(termios, termio, x) { \
+	unsigned short __tmp; \
+	get_user(__tmp,&(termio)->x); \
+	*(unsigned short *) &(termios)->x = __tmp; \
+}
+
+#define user_termio_to_kernel_termios(termios, termio) \
+({ \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_iflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_oflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_cflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_lflag); \
+	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
+})
+
+/*
+ * Translate a "termios" structure into a "termio". Ugh.
+ */
+#define kernel_termios_to_user_termio(termio, termios) \
+({ \
+	put_user((termios)->c_iflag, &(termio)->c_iflag); \
+	put_user((termios)->c_oflag, &(termio)->c_oflag); \
+	put_user((termios)->c_cflag, &(termio)->c_cflag); \
+	put_user((termios)->c_lflag, &(termio)->c_lflag); \
+	put_user((termios)->c_line,  &(termio)->c_line); \
+	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
+})
+
+#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios2))
+#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios2))
+#define user_termios_to_kernel_termios_1(k, u) copy_from_user(k, u, sizeof(struct termios))
+#define kernel_termios_to_user_termios_1(u, k) copy_to_user(u, k, sizeof(struct termios))
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _M32R_TERMIOS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/thread_info.h linux-2.6.30-rc3/arch/m32r/include/asm/thread_info.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/thread_info.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/thread_info.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,184 @@
+#ifndef _ASM_M32R_THREAD_INFO_H
+#define _ASM_M32R_THREAD_INFO_H
+
+/* thread_info.h: m32r low-level thread information
+ *
+ * Copyright (C) 2002  David Howells (dhowells@redhat.com)
+ * - Incorporating suggestions made by Linus Torvalds and Dave Miller
+ * Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+#include <asm/processor.h>
+#endif
+
+/*
+ * low level task data that entry.S needs immediate access to
+ * - this struct should fit entirely inside of one cache line
+ * - this struct shares the supervisor stack pages
+ * - if the contents of this structure are changed, the assembly constants must also be changed
+ */
+#ifndef __ASSEMBLY__
+
+struct thread_info {
+	struct task_struct	*task;		/* main task structure */
+	struct exec_domain	*exec_domain;	/* execution domain */
+	unsigned long		flags;		/* low level flags */
+	unsigned long		status;		/* thread-synchronous flags */
+	__u32			cpu;		/* current CPU */
+	int			preempt_count;	/* 0 => preemptable, <0 => BUG */
+
+	mm_segment_t		addr_limit;	/* thread address space:
+					 	   0-0xBFFFFFFF for user-thread
+						   0-0xFFFFFFFF for kernel-thread
+						*/
+	struct restart_block    restart_block;
+
+	__u8			supervisor_stack[0];
+};
+
+#else /* !__ASSEMBLY__ */
+
+/* offsets into the thread_info struct for assembly code access */
+#define TI_TASK		0x00000000
+#define TI_EXEC_DOMAIN	0x00000004
+#define TI_FLAGS	0x00000008
+#define TI_STATUS	0x0000000C
+#define TI_CPU		0x00000010
+#define TI_PRE_COUNT	0x00000014
+#define TI_ADDR_LIMIT	0x00000018
+#define TI_RESTART_BLOCK 0x000001C
+
+#endif
+
+#define PREEMPT_ACTIVE		0x10000000
+
+/*
+ * macros/functions for gaining access to the thread information structure
+ *
+ * preempt_count needs to be 1 initially, until the scheduler is functional.
+ */
+#ifndef __ASSEMBLY__
+
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.task		= &tsk,			\
+	.exec_domain	= &default_exec_domain,	\
+	.flags		= 0,			\
+	.cpu		= 0,			\
+	.preempt_count	= 1,			\
+	.addr_limit	= KERNEL_DS,		\
+	.restart_block = {			\
+		.fn = do_no_restart_syscall,	\
+	},					\
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+#define THREAD_SIZE (2*PAGE_SIZE)
+
+/* how to get the thread information struct from C */
+static inline struct thread_info *current_thread_info(void)
+{
+	struct thread_info *ti;
+
+	__asm__ __volatile__ (
+		"ldi	%0, #%1			\n\t"
+		"and	%0, sp			\n\t"
+		: "=r" (ti) : "i" (~(THREAD_SIZE - 1))
+	);
+
+	return ti;
+}
+
+#define __HAVE_ARCH_THREAD_INFO_ALLOCATOR
+
+/* thread information allocation */
+#ifdef CONFIG_DEBUG_STACK_USAGE
+#define alloc_thread_info(tsk)					\
+	({							\
+		struct thread_info *ret;			\
+	 							\
+	 	ret = kzalloc(THREAD_SIZE, GFP_KERNEL);		\
+								\
+	 	ret;						\
+	 })
+#else
+#define alloc_thread_info(tsk) kmalloc(THREAD_SIZE, GFP_KERNEL)
+#endif
+
+#define free_thread_info(info) kfree(info)
+
+#define TI_FLAG_FAULT_CODE_SHIFT	28
+
+static inline void set_thread_fault_code(unsigned int val)
+{
+	struct thread_info *ti = current_thread_info();
+	ti->flags = (ti->flags & (~0 >> (32 - TI_FLAG_FAULT_CODE_SHIFT)))
+		| (val << TI_FLAG_FAULT_CODE_SHIFT);
+}
+
+static inline unsigned int get_thread_fault_code(void)
+{
+	struct thread_info *ti = current_thread_info();
+	return ti->flags >> TI_FLAG_FAULT_CODE_SHIFT;
+}
+
+#else /* !__ASSEMBLY__ */
+
+#define THREAD_SIZE	8192
+
+/* how to get the thread information struct from ASM */
+#define GET_THREAD_INFO(reg)	GET_THREAD_INFO reg
+	.macro GET_THREAD_INFO reg
+	ldi	\reg, #-THREAD_SIZE
+	and	\reg, sp
+	.endm
+
+#endif
+
+/*
+ * thread information flags
+ * - these are process state flags that various assembly files may need to access
+ * - pending work-to-be-done flags are in LSW
+ * - other flags in MSW
+ */
+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
+#define TIF_SIGPENDING		1	/* signal pending */
+#define TIF_NEED_RESCHED	2	/* rescheduling necessary */
+#define TIF_SINGLESTEP		3	/* restore singlestep on return to user mode */
+#define TIF_IRET		4	/* return with iret */
+#define TIF_RESTORE_SIGMASK	8	/* restore signal mask in do_signal() */
+#define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
+#define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		18	/* OOM killer killed process */
+#define TIF_FREEZE		19	/* is freezing for suspend */
+
+#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
+#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_SINGLESTEP		(1<<TIF_SINGLESTEP)
+#define _TIF_IRET		(1<<TIF_IRET)
+#define _TIF_RESTORE_SIGMASK	(1<<TIF_RESTORE_SIGMASK)
+#define _TIF_USEDFPU		(1<<TIF_USEDFPU)
+#define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+#define _TIF_FREEZE		(1<<TIF_FREEZE)
+
+#define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
+#define _TIF_ALLWORK_MASK	0x0000FFFF	/* work to do on any return to u-space */
+
+/*
+ * Thread-synchronous status.
+ *
+ * This is different from the flags in that nobody else
+ * ever touches our thread-synchronous status, so we don't
+ * have to worry about atomic accesses.
+ */
+#define TS_USEDFPU		0x0001	/* FPU was used by this task this quantum (SMP) */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_M32R_THREAD_INFO_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/timex.h linux-2.6.30-rc3/arch/m32r/include/asm/timex.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/timex.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/timex.h	2009-04-22 03:29:16.275931415 +0000
@@ -0,0 +1,27 @@
+#ifndef _ASM_M32R_TIMEX_H
+#define _ASM_M32R_TIMEX_H
+
+/*
+ * linux/include/asm-m32r/timex.h
+ *
+ * m32r architecture timex specifications
+ */
+
+#define CLOCK_TICK_RATE	(CONFIG_BUS_CLOCK / CONFIG_TIMER_DIVIDE)
+#define CLOCK_TICK_FACTOR	20	/* Factor of both 1000000 and CLOCK_TICK_RATE */
+
+#ifdef __KERNEL__
+/*
+ * Standard way to access the cycle counter.
+ * Currently only used on SMP.
+ */
+
+typedef unsigned long long cycles_t;
+
+static __inline__ cycles_t get_cycles (void)
+{
+	return 0;
+}
+#endif  /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_TIMEX_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/tlb.h linux-2.6.30-rc3/arch/m32r/include/asm/tlb.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/tlb.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/tlb.h	2009-04-22 03:29:16.276931432 +0000
@@ -0,0 +1,20 @@
+#ifndef _M32R_TLB_H
+#define _M32R_TLB_H
+
+/*
+ * x86 doesn't need any special per-pte or
+ * per-vma handling..
+ */
+#define tlb_start_vma(tlb, vma) do { } while (0)
+#define tlb_end_vma(tlb, vma) do { } while (0)
+#define __tlb_remove_tlb_entry(tlb, pte, address) do { } while (0)
+
+/*
+ * .. because we flush the whole mm when it
+ * fills up.
+ */
+#define tlb_flush(tlb) flush_tlb_mm((tlb)->mm)
+
+#include <asm-generic/tlb.h>
+
+#endif /* _M32R_TLB_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/tlbflush.h linux-2.6.30-rc3/arch/m32r/include/asm/tlbflush.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/tlbflush.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/tlbflush.h	2009-04-22 03:29:16.276931432 +0000
@@ -0,0 +1,97 @@
+#ifndef _ASM_M32R_TLBFLUSH_H
+#define _ASM_M32R_TLBFLUSH_H
+
+#include <asm/m32r.h>
+
+/*
+ * TLB flushing:
+ *
+ *  - flush_tlb() flushes the current mm struct TLBs
+ *  - flush_tlb_all() flushes all processes TLBs
+ *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
+ *  - flush_tlb_page(vma, vmaddr) flushes one page
+ *  - flush_tlb_range(vma, start, end) flushes a range of pages
+ *  - flush_tlb_kernel_range(start, end) flushes a range of kernel pages
+ */
+
+extern void local_flush_tlb_all(void);
+extern void local_flush_tlb_mm(struct mm_struct *);
+extern void local_flush_tlb_page(struct vm_area_struct *, unsigned long);
+extern void local_flush_tlb_range(struct vm_area_struct *, unsigned long,
+	unsigned long);
+
+#ifndef CONFIG_SMP
+#ifdef CONFIG_MMU
+#define flush_tlb_all()			local_flush_tlb_all()
+#define flush_tlb_mm(mm)		local_flush_tlb_mm(mm)
+#define flush_tlb_page(vma, page)	local_flush_tlb_page(vma, page)
+#define flush_tlb_range(vma, start, end)	\
+	local_flush_tlb_range(vma, start, end)
+#define flush_tlb_kernel_range(start, end)	local_flush_tlb_all()
+#else	/* CONFIG_MMU */
+#define flush_tlb_all()			do { } while (0)
+#define flush_tlb_mm(mm)		do { } while (0)
+#define flush_tlb_page(vma, vmaddr)	do { } while (0)
+#define flush_tlb_range(vma, start, end)	do { } while (0)
+#endif	/* CONFIG_MMU */
+#else	/* CONFIG_SMP */
+extern void smp_flush_tlb_all(void);
+extern void smp_flush_tlb_mm(struct mm_struct *);
+extern void smp_flush_tlb_page(struct vm_area_struct *, unsigned long);
+extern void smp_flush_tlb_range(struct vm_area_struct *, unsigned long,
+	unsigned long);
+
+#define flush_tlb_all()			smp_flush_tlb_all()
+#define flush_tlb_mm(mm)		smp_flush_tlb_mm(mm)
+#define flush_tlb_page(vma, page)	smp_flush_tlb_page(vma, page)
+#define flush_tlb_range(vma, start, end)	\
+	smp_flush_tlb_range(vma, start, end)
+#define flush_tlb_kernel_range(start, end)	smp_flush_tlb_all()
+#endif	/* CONFIG_SMP */
+
+static __inline__ void __flush_tlb_page(unsigned long page)
+{
+	unsigned int tmpreg0, tmpreg1, tmpreg2;
+
+	__asm__ __volatile__ (
+		"seth	%0, #high(%4)	\n\t"
+		"st	%3, @(%5, %0)	\n\t"
+		"ldi	%1, #1		\n\t"
+		"st	%1, @(%6, %0)	\n\t"
+		"add3	%1, %0, %7	\n\t"
+		".fillinsn		\n"
+		"1:			\n\t"
+		"ld	%2, @(%6, %0)	\n\t"
+		"bnez	%2, 1b		\n\t"
+		"ld	%0, @%1+	\n\t"
+		"ld	%1, @%1		\n\t"
+		"st	%2, @+%0	\n\t"
+		"st	%2, @+%1	\n\t"
+		: "=&r" (tmpreg0), "=&r" (tmpreg1), "=&r" (tmpreg2)
+		: "r" (page), "i" (MMU_REG_BASE), "i" (MSVA_offset),
+		"i" (MTOP_offset), "i" (MIDXI_offset)
+		: "memory"
+	);
+}
+
+static __inline__ void __flush_tlb_all(void)
+{
+	unsigned int tmpreg0, tmpreg1;
+
+	__asm__ __volatile__ (
+		"seth	%0, #high(%2)		\n\t"
+		"or3	%0, %0, #low(%2)	\n\t"
+		"ldi	%1, #0xc		\n\t"
+		"st	%1, @%0			\n\t"
+		".fillinsn			\n"
+		"1:				\n\t"
+		"ld	%1, @%0			\n\t"
+		"bnez	%1, 1b			\n\t"
+		: "=&r" (tmpreg0), "=&r" (tmpreg1)
+		: "i" (MTOP) : "memory"
+	);
+}
+
+extern void update_mmu_cache(struct vm_area_struct *, unsigned long, pte_t);
+
+#endif	/* _ASM_M32R_TLBFLUSH_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/topology.h linux-2.6.30-rc3/arch/m32r/include/asm/topology.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/topology.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/topology.h	2009-04-22 03:29:16.276931432 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_M32R_TOPOLOGY_H
+#define _ASM_M32R_TOPOLOGY_H
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_M32R_TOPOLOGY_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/types.h linux-2.6.30-rc3/arch/m32r/include/asm/types.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/types.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/types.h	2009-04-22 03:29:16.276931432 +0000
@@ -0,0 +1,30 @@
+#ifndef _ASM_M32R_TYPES_H
+#define _ASM_M32R_TYPES_H
+
+#include <asm-generic/int-ll64.h>
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+/* DMA addresses are 32-bits wide.  */
+
+typedef u32 dma_addr_t;
+typedef u64 dma64_addr_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_M32R_TYPES_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/uaccess.h linux-2.6.30-rc3/arch/m32r/include/asm/uaccess.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/uaccess.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/uaccess.h	2009-04-22 03:29:16.276931432 +0000
@@ -0,0 +1,693 @@
+#ifndef _ASM_M32R_UACCESS_H
+#define _ASM_M32R_UACCESS_H
+
+/*
+ *  linux/include/asm-m32r/uaccess.h
+ *
+ *  M32R version.
+ *    Copyright (C) 2004, 2006  Hirokazu Takata <takata at linux-m32r.org>
+ */
+
+/*
+ * User space memory access functions
+ */
+#include <linux/errno.h>
+#include <linux/thread_info.h>
+#include <asm/page.h>
+#include <asm/setup.h>
+
+#define VERIFY_READ 0
+#define VERIFY_WRITE 1
+
+/*
+ * The fs value determines whether argument validity checking should be
+ * performed or not.  If get_fs() == USER_DS, checking is performed, with
+ * get_fs() == KERNEL_DS, checking is bypassed.
+ *
+ * For historical reasons, these macros are grossly misnamed.
+ */
+
+#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
+
+#ifdef CONFIG_MMU
+
+#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFF)
+#define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
+#define get_ds()	(KERNEL_DS)
+#define get_fs()	(current_thread_info()->addr_limit)
+#define set_fs(x)	(current_thread_info()->addr_limit = (x))
+
+#else /* not CONFIG_MMU */
+
+#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFF)
+#define USER_DS		MAKE_MM_SEG(0xFFFFFFFF)
+#define get_ds()	(KERNEL_DS)
+
+static inline mm_segment_t get_fs(void)
+{
+	return USER_DS;
+}
+
+static inline void set_fs(mm_segment_t s)
+{
+}
+
+#endif /* not CONFIG_MMU */
+
+#define segment_eq(a,b)	((a).seg == (b).seg)
+
+#define __addr_ok(addr) \
+	((unsigned long)(addr) < (current_thread_info()->addr_limit.seg))
+
+/*
+ * Test whether a block of memory is a valid user space address.
+ * Returns 0 if the range is valid, nonzero otherwise.
+ *
+ * This is equivalent to the following test:
+ * (u33)addr + (u33)size >= (u33)current->addr_limit.seg
+ *
+ * This needs 33-bit arithmetic. We have a carry...
+ */
+#define __range_ok(addr,size) ({					\
+	unsigned long flag, roksum; 					\
+	__chk_user_ptr(addr);						\
+	asm ( 								\
+		"	cmpu	%1, %1    ; clear cbit\n"		\
+		"	addx	%1, %3    ; set cbit if overflow\n"	\
+		"	subx	%0, %0\n"				\
+		"	cmpu	%4, %1\n"				\
+		"	subx	%0, %5\n"				\
+		: "=&r" (flag), "=r" (roksum)				\
+		: "1" (addr), "r" ((int)(size)), 			\
+		  "r" (current_thread_info()->addr_limit.seg), "r" (0)	\
+		: "cbit" );						\
+	flag; })
+
+/**
+ * access_ok: - Checks if a user space pointer is valid
+ * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE.  Note that
+ *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
+ *        to write to a block, it is always safe to read from it.
+ * @addr: User space pointer to start of block to check
+ * @size: Size of block to check
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Checks if a pointer to a block of memory in user space is valid.
+ *
+ * Returns true (nonzero) if the memory block may be valid, false (zero)
+ * if it is definitely invalid.
+ *
+ * Note that, depending on architecture, this function probably just
+ * checks that the pointer is in the user space range - after calling
+ * this function, memory access functions may still return -EFAULT.
+ */
+#ifdef CONFIG_MMU
+#define access_ok(type,addr,size) (likely(__range_ok(addr,size) == 0))
+#else
+static inline int access_ok(int type, const void *addr, unsigned long size)
+{
+	unsigned long val = (unsigned long)addr;
+
+	return ((val >= memory_start) && ((val + size) < memory_end));
+}
+#endif /* CONFIG_MMU */
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+extern int fixup_exception(struct pt_regs *regs);
+
+/*
+ * These are the main single-value transfer routines.  They automatically
+ * use the right size if we just have the right pointer type.
+ *
+ * This gets kind of ugly. We want to return _two_ values in "get_user()"
+ * and yet we don't want to do any pointers, because that is too much
+ * of a performance impact. Thus we have a few rather ugly macros here,
+ * and hide all the uglyness from the user.
+ *
+ * The "__xxx" versions of the user access functions are versions that
+ * do not verify the address space, that must have been done previously
+ * with a separate "access_ok()" call (this is used when we do multiple
+ * accesses to the same area of user memory).
+ */
+
+/* Careful: we have to cast the result to the type of the pointer for sign
+   reasons */
+/**
+ * get_user: - Get a simple variable from user space.
+ * @x:   Variable to store result.
+ * @ptr: Source address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple variable from user space to kernel
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and the result of
+ * dereferencing @ptr must be assignable to @x without a cast.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ * On error, the variable @x is set to zero.
+ */
+#define get_user(x,ptr)							\
+	__get_user_check((x),(ptr),sizeof(*(ptr)))
+
+/**
+ * put_user: - Write a simple value into user space.
+ * @x:   Value to copy to user space.
+ * @ptr: Destination address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple value from kernel space to user
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and @x must be assignable
+ * to the result of dereferencing @ptr.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ */
+#define put_user(x,ptr)							\
+	__put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+
+/**
+ * __get_user: - Get a simple variable from user space, with less checking.
+ * @x:   Variable to store result.
+ * @ptr: Source address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple variable from user space to kernel
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and the result of
+ * dereferencing @ptr must be assignable to @x without a cast.
+ *
+ * Caller must check the pointer with access_ok() before calling this
+ * function.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ * On error, the variable @x is set to zero.
+ */
+#define __get_user(x,ptr) \
+	__get_user_nocheck((x),(ptr),sizeof(*(ptr)))
+
+#define __get_user_nocheck(x,ptr,size)					\
+({									\
+	long __gu_err = 0;						\
+	unsigned long __gu_val;						\
+	might_sleep();							\
+	__get_user_size(__gu_val,(ptr),(size),__gu_err);		\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_check(x,ptr,size)					\
+({									\
+	long __gu_err = -EFAULT;					\
+	unsigned long __gu_val = 0;					\
+	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);		\
+	might_sleep();							\
+	if (access_ok(VERIFY_READ,__gu_addr,size))			\
+		__get_user_size(__gu_val,__gu_addr,(size),__gu_err);	\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+	__gu_err;							\
+})
+
+extern long __get_user_bad(void);
+
+#define __get_user_size(x,ptr,size,retval)				\
+do {									\
+	retval = 0;							\
+	__chk_user_ptr(ptr);						\
+	switch (size) {							\
+	  case 1: __get_user_asm(x,ptr,retval,"ub"); break;		\
+	  case 2: __get_user_asm(x,ptr,retval,"uh"); break;		\
+	  case 4: __get_user_asm(x,ptr,retval,""); break;		\
+	  default: (x) = __get_user_bad();				\
+	}								\
+} while (0)
+
+#define __get_user_asm(x, addr, err, itype)				\
+	__asm__ __volatile__(						\
+		"	.fillinsn\n"					\
+		"1:	ld"itype" %1,@%2\n"				\
+		"	.fillinsn\n"					\
+		"2:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"3:	ldi %0,%3\n"					\
+		"	seth r14,#high(2b)\n"				\
+		"	or3 r14,r14,#low(2b)\n"				\
+		"	jmp r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 1b,3b\n"					\
+		".previous"						\
+		: "=&r" (err), "=&r" (x)				\
+		: "r" (addr), "i" (-EFAULT), "0" (err)			\
+		: "r14", "memory")
+
+/**
+ * __put_user: - Write a simple value into user space, with less checking.
+ * @x:   Value to copy to user space.
+ * @ptr: Destination address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple value from kernel space to user
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and @x must be assignable
+ * to the result of dereferencing @ptr.
+ *
+ * Caller must check the pointer with access_ok() before calling this
+ * function.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ */
+#define __put_user(x,ptr) \
+	__put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+
+
+#define __put_user_nocheck(x,ptr,size)					\
+({									\
+	long __pu_err;							\
+	might_sleep();							\
+	__put_user_size((x),(ptr),(size),__pu_err);			\
+	__pu_err;							\
+})
+
+
+#define __put_user_check(x,ptr,size)					\
+({									\
+	long __pu_err = -EFAULT;					\
+	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\
+	might_sleep();							\
+	if (access_ok(VERIFY_WRITE,__pu_addr,size))			\
+		__put_user_size((x),__pu_addr,(size),__pu_err);		\
+	__pu_err;							\
+})
+
+#if defined(__LITTLE_ENDIAN__)
+#define __put_user_u64(x, addr, err)					\
+        __asm__ __volatile__(						\
+                "       .fillinsn\n"					\
+                "1:     st %L1,@%2\n"					\
+                "       .fillinsn\n"					\
+                "2:     st %H1,@(4,%2)\n"				\
+                "       .fillinsn\n"					\
+                "3:\n"							\
+                ".section .fixup,\"ax\"\n"				\
+                "       .balign 4\n"					\
+                "4:     ldi %0,%3\n"					\
+                "       seth r14,#high(3b)\n"				\
+                "       or3 r14,r14,#low(3b)\n"				\
+                "       jmp r14\n"					\
+                ".previous\n"						\
+                ".section __ex_table,\"a\"\n"				\
+                "       .balign 4\n"					\
+                "       .long 1b,4b\n"					\
+                "       .long 2b,4b\n"					\
+                ".previous"						\
+                : "=&r" (err)						\
+                : "r" (x), "r" (addr), "i" (-EFAULT), "0" (err)		\
+                : "r14", "memory")
+
+#elif defined(__BIG_ENDIAN__)
+#define __put_user_u64(x, addr, err)					\
+	__asm__ __volatile__(						\
+		"	.fillinsn\n"					\
+		"1:	st %H1,@%2\n"					\
+		"	.fillinsn\n"					\
+		"2:	st %L1,@(4,%2)\n"				\
+		"	.fillinsn\n"					\
+		"3:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"4:	ldi %0,%3\n"					\
+		"	seth r14,#high(3b)\n"				\
+		"	or3 r14,r14,#low(3b)\n"				\
+		"	jmp r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 1b,4b\n"					\
+		"	.long 2b,4b\n"					\
+		".previous"						\
+		: "=&r" (err)						\
+		: "r" (x), "r" (addr), "i" (-EFAULT), "0" (err)		\
+		: "r14", "memory")
+#else
+#error no endian defined
+#endif
+
+extern void __put_user_bad(void);
+
+#define __put_user_size(x,ptr,size,retval)				\
+do {									\
+	retval = 0;							\
+	__chk_user_ptr(ptr);						\
+	switch (size) {							\
+	  case 1: __put_user_asm(x,ptr,retval,"b"); break;		\
+	  case 2: __put_user_asm(x,ptr,retval,"h"); break;		\
+	  case 4: __put_user_asm(x,ptr,retval,""); break;		\
+	  case 8: __put_user_u64((__typeof__(*ptr))(x),ptr,retval); break;\
+	  default: __put_user_bad();					\
+	}								\
+} while (0)
+
+struct __large_struct { unsigned long buf[100]; };
+#define __m(x) (*(struct __large_struct *)(x))
+
+/*
+ * Tell gcc we read from memory instead of writing: this is because
+ * we do not write to any memory gcc knows about, so there are no
+ * aliasing issues.
+ */
+#define __put_user_asm(x, addr, err, itype)				\
+	__asm__ __volatile__(						\
+		"	.fillinsn\n"					\
+		"1:	st"itype" %1,@%2\n"				\
+		"	.fillinsn\n"					\
+		"2:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"3:	ldi %0,%3\n"					\
+		"	seth r14,#high(2b)\n"				\
+		"	or3 r14,r14,#low(2b)\n"				\
+		"	jmp r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 1b,3b\n"					\
+		".previous"						\
+		: "=&r" (err)						\
+		: "r" (x), "r" (addr), "i" (-EFAULT), "0" (err)		\
+		: "r14", "memory")
+
+/*
+ * Here we special-case 1, 2 and 4-byte copy_*_user invocations.  On a fault
+ * we return the initial request size (1, 2 or 4), as copy_*_user should do.
+ * If a store crosses a page boundary and gets a fault, the m32r will not write
+ * anything, so this is accurate.
+ */
+
+/*
+ * Copy To/From Userspace
+ */
+
+/* Generic arbitrary sized copy.  */
+/* Return the number of bytes NOT copied.  */
+#define __copy_user(to,from,size)					\
+do {									\
+	unsigned long __dst, __src, __c;				\
+	__asm__ __volatile__ (						\
+		"	mv	r14, %0\n"				\
+		"	or	r14, %1\n"				\
+		"	beq	%0, %1, 9f\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	and3	r14, r14, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	%2, %2, #3\n"				\
+		"	beqz	%3, 2f\n"				\
+		"	addi	%0, #-4		; word_copy \n"		\
+		"	.fillinsn\n"					\
+		"0:	ld	r14, @%1+\n"				\
+		"	addi	%3, #-1\n"				\
+		"	.fillinsn\n"					\
+		"1:	st	r14, @+%0\n"				\
+		"	bnez	%3, 0b\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"2:	ldb	r14, @%1	; byte_copy \n"		\
+		"	.fillinsn\n"					\
+		"3:	stb	r14, @%0\n"				\
+		"	addi	%1, #1\n"				\
+		"	addi	%2, #-1\n"				\
+		"	addi	%0, #1\n"				\
+		"	bnez	%2, 2b\n"				\
+		"	.fillinsn\n"					\
+		"9:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"5:	addi	%3, #1\n"				\
+		"	addi	%1, #-4\n"				\
+		"	.fillinsn\n"					\
+		"6:	slli	%3, #2\n"				\
+		"	add	%2, %3\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"7:	seth	r14, #high(9b)\n"			\
+		"	or3	r14, r14, #low(9b)\n"			\
+		"	jmp	r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,6b\n"					\
+		"	.long 1b,5b\n"					\
+		"	.long 2b,9b\n"					\
+		"	.long 3b,9b\n"					\
+		".previous\n"						\
+		: "=&r" (__dst), "=&r" (__src), "=&r" (size),		\
+		  "=&r" (__c)						\
+		: "0" (to), "1" (from), "2" (size), "3" (size / 4)	\
+		: "r14", "memory");					\
+} while (0)
+
+#define __copy_user_zeroing(to,from,size)				\
+do {									\
+	unsigned long __dst, __src, __c;				\
+	__asm__ __volatile__ (						\
+		"	mv	r14, %0\n"				\
+		"	or	r14, %1\n"				\
+		"	beq	%0, %1, 9f\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	and3	r14, r14, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	%2, %2, #3\n"				\
+		"	beqz	%3, 2f\n"				\
+		"	addi	%0, #-4		; word_copy \n"		\
+		"	.fillinsn\n"					\
+		"0:	ld	r14, @%1+\n"				\
+		"	addi	%3, #-1\n"				\
+		"	.fillinsn\n"					\
+		"1:	st	r14, @+%0\n"				\
+		"	bnez	%3, 0b\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"2:	ldb	r14, @%1	; byte_copy \n"		\
+		"	.fillinsn\n"					\
+		"3:	stb	r14, @%0\n"				\
+		"	addi	%1, #1\n"				\
+		"	addi	%2, #-1\n"				\
+		"	addi	%0, #1\n"				\
+		"	bnez	%2, 2b\n"				\
+		"	.fillinsn\n"					\
+		"9:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"5:	addi	%3, #1\n"				\
+		"	addi	%1, #-4\n"				\
+		"	.fillinsn\n"					\
+		"6:	slli	%3, #2\n"				\
+		"	add	%2, %3\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"7:	ldi	r14, #0		; store zero \n"	\
+		"	.fillinsn\n"					\
+		"8:	addi	%2, #-1\n"				\
+		"	stb	r14, @%0	; ACE? \n"		\
+		"	addi	%0, #1\n"				\
+		"	bnez	%2, 8b\n"				\
+		"	seth	r14, #high(9b)\n"			\
+		"	or3	r14, r14, #low(9b)\n"			\
+		"	jmp	r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,6b\n"					\
+		"	.long 1b,5b\n"					\
+		"	.long 2b,7b\n"					\
+		"	.long 3b,7b\n"					\
+		".previous\n"						\
+		: "=&r" (__dst), "=&r" (__src), "=&r" (size),		\
+		  "=&r" (__c)						\
+		: "0" (to), "1" (from), "2" (size), "3" (size / 4)	\
+		: "r14", "memory");					\
+} while (0)
+
+
+/* We let the __ versions of copy_from/to_user inline, because they're often
+ * used in fast paths and have only a small space overhead.
+ */
+static inline unsigned long __generic_copy_from_user_nocheck(void *to,
+	const void __user *from, unsigned long n)
+{
+	__copy_user_zeroing(to,from,n);
+	return n;
+}
+
+static inline unsigned long __generic_copy_to_user_nocheck(void __user *to,
+	const void *from, unsigned long n)
+{
+	__copy_user(to,from,n);
+	return n;
+}
+
+unsigned long __generic_copy_to_user(void __user *, const void *, unsigned long);
+unsigned long __generic_copy_from_user(void *, const void __user *, unsigned long);
+
+/**
+ * __copy_to_user: - Copy a block of data into user space, with less checking.
+ * @to:   Destination address, in user space.
+ * @from: Source address, in kernel space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from kernel space to user space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ */
+#define __copy_to_user(to,from,n)			\
+	__generic_copy_to_user_nocheck((to),(from),(n))
+
+#define __copy_to_user_inatomic __copy_to_user
+#define __copy_from_user_inatomic __copy_from_user
+
+/**
+ * copy_to_user: - Copy a block of data into user space.
+ * @to:   Destination address, in user space.
+ * @from: Source address, in kernel space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from kernel space to user space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ */
+#define copy_to_user(to,from,n)				\
+({							\
+	might_sleep();					\
+	__generic_copy_to_user((to),(from),(n));	\
+})
+
+/**
+ * __copy_from_user: - Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
+ * @from: Source address, in user space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from user space to kernel space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ *
+ * If some data could not be copied, this function will pad the copied
+ * data to the requested size using zero bytes.
+ */
+#define __copy_from_user(to,from,n)			\
+	__generic_copy_from_user_nocheck((to),(from),(n))
+
+/**
+ * copy_from_user: - Copy a block of data from user space.
+ * @to:   Destination address, in kernel space.
+ * @from: Source address, in user space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from user space to kernel space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ *
+ * If some data could not be copied, this function will pad the copied
+ * data to the requested size using zero bytes.
+ */
+#define copy_from_user(to,from,n)			\
+({							\
+	might_sleep();					\
+	__generic_copy_from_user((to),(from),(n));	\
+})
+
+long __must_check strncpy_from_user(char *dst, const char __user *src,
+				long count);
+long __must_check __strncpy_from_user(char *dst,
+				const char __user *src, long count);
+
+/**
+ * __clear_user: - Zero a block of memory in user space, with less checking.
+ * @to:   Destination address, in user space.
+ * @n:    Number of bytes to zero.
+ *
+ * Zero a block of memory in user space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be cleared.
+ * On success, this will be zero.
+ */
+unsigned long __clear_user(void __user *mem, unsigned long len);
+
+/**
+ * clear_user: - Zero a block of memory in user space.
+ * @to:   Destination address, in user space.
+ * @n:    Number of bytes to zero.
+ *
+ * Zero a block of memory in user space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be cleared.
+ * On success, this will be zero.
+ */
+unsigned long clear_user(void __user *mem, unsigned long len);
+
+/**
+ * strlen_user: - Get the size of a string in user space.
+ * @str: The string to measure.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Get the size of a NUL-terminated string in user space.
+ *
+ * Returns the size of the string INCLUDING the terminating NUL.
+ * On exception, returns 0.
+ *
+ * If there is a limit on the length of a valid string, you may wish to
+ * consider using strnlen_user() instead.
+ */
+#define strlen_user(str) strnlen_user(str, ~0UL >> 1)
+long strnlen_user(const char __user *str, long n);
+
+#endif /* _ASM_M32R_UACCESS_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/ucontext.h linux-2.6.30-rc3/arch/m32r/include/asm/ucontext.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/ucontext.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/ucontext.h	2009-04-22 03:29:16.276931432 +0000
@@ -0,0 +1,12 @@
+#ifndef _ASM_M32R_UCONTEXT_H
+#define _ASM_M32R_UCONTEXT_H
+
+struct ucontext {
+	unsigned long	  uc_flags;
+	struct ucontext  *uc_link;
+	stack_t		  uc_stack;
+	struct sigcontext uc_mcontext;
+	sigset_t	  uc_sigmask;	/* mask last for extensibility */
+};
+
+#endif /* _ASM_M32R_UCONTEXT_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/unaligned.h linux-2.6.30-rc3/arch/m32r/include/asm/unaligned.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/unaligned.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/unaligned.h	2009-04-22 03:29:16.277780857 +0000
@@ -0,0 +1,18 @@
+#ifndef _ASM_M32R_UNALIGNED_H
+#define _ASM_M32R_UNALIGNED_H
+
+#if defined(__LITTLE_ENDIAN__)
+# include <linux/unaligned/le_memmove.h>
+# include <linux/unaligned/be_byteshift.h>
+# include <linux/unaligned/generic.h>
+# define get_unaligned	__get_unaligned_le
+# define put_unaligned	__put_unaligned_le
+#else
+# include <linux/unaligned/be_memmove.h>
+# include <linux/unaligned/le_byteshift.h>
+# include <linux/unaligned/generic.h>
+# define get_unaligned	__get_unaligned_be
+# define put_unaligned	__put_unaligned_be
+#endif
+
+#endif /* _ASM_M32R_UNALIGNED_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/unistd.h linux-2.6.30-rc3/arch/m32r/include/asm/unistd.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/unistd.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/unistd.h	2009-04-22 03:29:16.277780857 +0000
@@ -0,0 +1,389 @@
+#ifndef _ASM_M32R_UNISTD_H
+#define _ASM_M32R_UNISTD_H
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_restart_syscall	  0
+#define __NR_exit		  1
+#define __NR_fork		  2
+#define __NR_read		  3
+#define __NR_write		  4
+#define __NR_open		  5
+#define __NR_close		  6
+#define __NR_waitpid		  7
+#define __NR_creat		  8
+#define __NR_link		  9
+#define __NR_unlink		 10
+#define __NR_execve		 11
+#define __NR_chdir		 12
+#define __NR_time		 13
+#define __NR_mknod		 14
+#define __NR_chmod		 15
+/* 16 is unused */
+/* 17 is unused */
+/* 18 is unused */
+#define __NR_lseek		 19
+#define __NR_getpid		 20
+#define __NR_mount		 21
+#define __NR_umount		 22
+/* 23 is unused */
+/* 24 is unused */
+#define __NR_stime		 25
+#define __NR_ptrace		 26
+#define __NR_alarm		 27
+/* 28 is unused */
+#define __NR_pause		 29
+#define __NR_utime		 30
+/* 31 is unused */
+#define __NR_cachectl		 32 /* old #define __NR_gtty		 32*/
+#define __NR_access		 33
+/* 34 is unused */
+/* 35 is unused */
+#define __NR_sync		 36
+#define __NR_kill		 37
+#define __NR_rename		 38
+#define __NR_mkdir		 39
+#define __NR_rmdir		 40
+#define __NR_dup		 41
+#define __NR_pipe		 42
+#define __NR_times		 43
+/* 44 is unused */
+#define __NR_brk		 45
+/* 46 is unused */
+/* 47 is unused (getgid16) */
+/* 48 is unused */
+/* 49 is unused */
+/* 50 is unused */
+#define __NR_acct		 51
+#define __NR_umount2		 52
+/* 53 is unused */
+#define __NR_ioctl		 54
+/* 55 is unused (fcntl) */
+/* 56 is unused */
+#define __NR_setpgid		 57
+/* 58 is unused */
+/* 59 is unused */
+#define __NR_umask		 60
+#define __NR_chroot		 61
+#define __NR_ustat		 62
+#define __NR_dup2		 63
+#define __NR_getppid		 64
+#define __NR_getpgrp		 65
+#define __NR_setsid		 66
+/* 67 is unused */
+/* 68 is unused*/
+/* 69 is unused*/
+/* 70 is unused */
+/* 71 is unused */
+/* 72 is unused */
+/* 73 is unused */
+#define __NR_sethostname	 74
+#define __NR_setrlimit		 75
+/* 76 is unused (old getrlimit) */
+#define __NR_getrusage		 77
+#define __NR_gettimeofday	 78
+#define __NR_settimeofday	 79
+/* 80 is unused */
+/* 81 is unused */
+/* 82 is unused */
+#define __NR_symlink		 83
+/* 84 is unused */
+#define __NR_readlink		 85
+#define __NR_uselib		 86
+#define __NR_swapon		 87
+#define __NR_reboot		 88
+/* 89 is unused */
+/* 90 is unused */
+#define __NR_munmap		 91
+#define __NR_truncate		 92
+#define __NR_ftruncate		 93
+#define __NR_fchmod		 94
+/* 95 is unused */
+#define __NR_getpriority	 96
+#define __NR_setpriority	 97
+/* 98 is unused */
+#define __NR_statfs		 99
+#define __NR_fstatfs		100
+/* 101 is unused */
+#define __NR_socketcall		102
+#define __NR_syslog		103
+#define __NR_setitimer		104
+#define __NR_getitimer		105
+#define __NR_stat		106
+#define __NR_lstat		107
+#define __NR_fstat		108
+/* 109 is unused */
+/* 110 is unused */
+#define __NR_vhangup		111
+/* 112 is unused */
+/* 113 is unused */
+#define __NR_wait4		114
+#define __NR_swapoff		115
+#define __NR_sysinfo		116
+#define __NR_ipc		117
+#define __NR_fsync		118
+/* 119 is unused */
+#define __NR_clone		120
+#define __NR_setdomainname	121
+#define __NR_uname		122
+/* 123 is unused */
+#define __NR_adjtimex		124
+#define __NR_mprotect		125
+/* 126 is unused */
+/* 127 is unused */
+#define __NR_init_module	128
+#define __NR_delete_module	129
+/* 130 is unused */
+#define __NR_quotactl		131
+#define __NR_getpgid		132
+#define __NR_fchdir		133
+#define __NR_bdflush		134
+#define __NR_sysfs		135
+#define __NR_personality	136
+/* 137 is unused */
+/* 138 is unused */
+/* 139 is unused */
+#define __NR__llseek		140
+#define __NR_getdents		141
+#define __NR__newselect		142
+#define __NR_flock		143
+#define __NR_msync		144
+#define __NR_readv		145
+#define __NR_writev		146
+#define __NR_getsid		147
+#define __NR_fdatasync		148
+#define __NR__sysctl		149
+#define __NR_mlock		150
+#define __NR_munlock		151
+#define __NR_mlockall		152
+#define __NR_munlockall		153
+#define __NR_sched_setparam		154
+#define __NR_sched_getparam		155
+#define __NR_sched_setscheduler		156
+#define __NR_sched_getscheduler		157
+#define __NR_sched_yield		158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep		162
+#define __NR_mremap		163
+/* 164 is unused */
+/* 165 is unused */
+#define __NR_tas		166
+/* 167 is unused */
+#define __NR_poll		168
+#define __NR_nfsservctl		169
+/* 170 is unused */
+/* 171 is unused */
+#define __NR_prctl              172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread64		180
+#define __NR_pwrite64		181
+/* 182 is unused */
+#define __NR_getcwd		183
+#define __NR_capget		184
+#define __NR_capset		185
+#define __NR_sigaltstack	186
+#define __NR_sendfile		187
+/* 188 is unused */
+/* 189 is unused */
+#define __NR_vfork		190
+#define __NR_ugetrlimit		191	/* SuS compliant getrlimit */
+#define __NR_mmap2		192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_lchown32		198
+#define __NR_getuid32		199
+#define __NR_getgid32		200
+#define __NR_geteuid32		201
+#define __NR_getegid32		202
+#define __NR_setreuid32		203
+#define __NR_setregid32		204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32		207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_chown32		212
+#define __NR_setuid32		213
+#define __NR_setgid32		214
+#define __NR_setfsuid32		215
+#define __NR_setfsgid32		216
+#define __NR_pivot_root		217
+#define __NR_mincore		218
+#define __NR_madvise		219
+#define __NR_getdents64		220
+#define __NR_fcntl64		221
+/* 222 is unused */
+/* 223 is unused */
+#define __NR_gettid		224
+#define __NR_readahead		225
+#define __NR_setxattr		226
+#define __NR_lsetxattr		227
+#define __NR_fsetxattr		228
+#define __NR_getxattr		229
+#define __NR_lgetxattr		230
+#define __NR_fgetxattr		231
+#define __NR_listxattr		232
+#define __NR_llistxattr		233
+#define __NR_flistxattr		234
+#define __NR_removexattr	235
+#define __NR_lremovexattr	236
+#define __NR_fremovexattr	237
+#define __NR_tkill		238
+#define __NR_sendfile64		239
+#define __NR_futex		240
+#define __NR_sched_setaffinity	241
+#define __NR_sched_getaffinity	242
+#define __NR_set_thread_area	243
+#define __NR_get_thread_area	244
+#define __NR_io_setup		245
+#define __NR_io_destroy		246
+#define __NR_io_getevents	247
+#define __NR_io_submit		248
+#define __NR_io_cancel		249
+#define __NR_fadvise64		250
+/* 251 is unused */
+#define __NR_exit_group		252
+#define __NR_lookup_dcookie	253
+#define __NR_epoll_create	254
+#define __NR_epoll_ctl		255
+#define __NR_epoll_wait		256
+#define __NR_remap_file_pages	257
+#define __NR_set_tid_address	258
+#define __NR_timer_create	259
+#define __NR_timer_settime	(__NR_timer_create+1)
+#define __NR_timer_gettime	(__NR_timer_create+2)
+#define __NR_timer_getoverrun	(__NR_timer_create+3)
+#define __NR_timer_delete	(__NR_timer_create+4)
+#define __NR_clock_settime	(__NR_timer_create+5)
+#define __NR_clock_gettime	(__NR_timer_create+6)
+#define __NR_clock_getres	(__NR_timer_create+7)
+#define __NR_clock_nanosleep	(__NR_timer_create+8)
+#define __NR_statfs64		268
+#define __NR_fstatfs64		269
+#define __NR_tgkill		270
+#define __NR_utimes		271
+#define __NR_fadvise64_64	272
+#define __NR_vserver		273
+#define __NR_mbind		274
+#define __NR_get_mempolicy	275
+#define __NR_set_mempolicy	276
+#define __NR_mq_open		277
+#define __NR_mq_unlink		(__NR_mq_open+1)
+#define __NR_mq_timedsend	(__NR_mq_open+2)
+#define __NR_mq_timedreceive	(__NR_mq_open+3)
+#define __NR_mq_notify		(__NR_mq_open+4)
+#define __NR_mq_getsetattr	(__NR_mq_open+5)
+#define __NR_kexec_load		283
+#define __NR_waitid		284
+/* 285 is unused */
+#define __NR_add_key		286
+#define __NR_request_key	287
+#define __NR_keyctl		288
+#define __NR_ioprio_set		289
+#define __NR_ioprio_get		290
+#define __NR_inotify_init	291
+#define __NR_inotify_add_watch	292
+#define __NR_inotify_rm_watch	293
+#define __NR_migrate_pages	294
+#define __NR_openat		295
+#define __NR_mkdirat		296
+#define __NR_mknodat		297
+#define __NR_fchownat		298
+#define __NR_futimesat		299
+#define __NR_fstatat64		300
+#define __NR_unlinkat		301
+#define __NR_renameat		302
+#define __NR_linkat		303
+#define __NR_symlinkat		304
+#define __NR_readlinkat		305
+#define __NR_fchmodat		306
+#define __NR_faccessat		307
+#define __NR_pselect6		308
+#define __NR_ppoll		309
+#define __NR_unshare		310
+#define __NR_set_robust_list	311
+#define __NR_get_robust_list	312
+#define __NR_splice		313
+#define __NR_sync_file_range	314
+#define __NR_tee		315
+#define __NR_vmsplice		316
+#define __NR_move_pages		317
+#define __NR_getcpu		318
+#define __NR_epoll_pwait	319
+#define __NR_utimensat		320
+#define __NR_signalfd		321
+/* #define __NR_timerfd		322 removed */
+#define __NR_eventfd		323
+#define __NR_fallocate		324
+
+#ifdef __KERNEL__
+
+#define NR_syscalls 325
+
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_WAITPID
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT /*will be unused*/
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_RT_SIGACTION
+
+#define __IGNORE_lchown
+#define __IGNORE_setuid
+#define __IGNORE_getuid
+#define __IGNORE_setgid
+#define __IGNORE_getgid
+#define __IGNORE_geteuid
+#define __IGNORE_getegid
+#define __IGNORE_fcntl
+#define __IGNORE_setreuid
+#define __IGNORE_setregid
+#define __IGNORE_getrlimit
+#define __IGNORE_getgroups
+#define __IGNORE_setgroups
+#define __IGNORE_select
+#define __IGNORE_mmap
+#define __IGNORE_fchown
+#define __IGNORE_setfsuid
+#define __IGNORE_setfsgid
+#define __IGNORE_setresuid
+#define __IGNORE_getresuid
+#define __IGNORE_setresgid
+#define __IGNORE_getresgid
+#define __IGNORE_chown
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#ifndef cond_syscall
+#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* _ASM_M32R_UNISTD_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/user.h linux-2.6.30-rc3/arch/m32r/include/asm/user.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/user.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/user.h	2009-04-22 03:29:16.277780857 +0000
@@ -0,0 +1,52 @@
+#ifndef _ASM_M32R_USER_H
+#define _ASM_M32R_USER_H
+
+#include <linux/types.h>
+#include <asm/ptrace.h>
+#include <asm/page.h>
+
+/*
+ * Core file format: The core file is written in such a way that gdb
+ * can understand it and provide useful information to the user (under
+ * linux we use the `trad-core' bfd).
+ *
+ * The actual file contents are as follows:
+ * UPAGE: 1 page consisting of a user struct that tells gdb
+ *	what is present in the file.  Directly after this is a
+ *	copy of the task_struct, which is currently not used by gdb,
+ *	but it may come in handy at some point.  All of the registers
+ *	are stored as part of the upage.  The upage should always be
+ *	only one page.
+ * DATA: The data area is stored.  We use current->end_text to
+ *	current->brk to pick up all of the user variables, plus any memory
+ *	that may have been sbrk'ed.  No attempt is made to determine if a
+ *	page is demand-zero or if a page is totally unused, we just cover
+ *	the entire range.  All of the addresses are rounded in such a way
+ *	that an integral number of pages is written.
+ * STACK: We need the stack information in order to get a meaningful
+ *	backtrace.  We need to write the data from usp to
+ *	current->start_stack, so we round each of these off in order to be
+ *	able to write an integer number of pages.
+ */
+
+struct user {
+	struct pt_regs	regs;			/* entire machine state */
+	size_t		u_tsize;		/* text size (pages) */
+	size_t		u_dsize;		/* data size (pages) */
+	size_t		u_ssize;		/* stack size (pages) */
+	unsigned long	start_code;		/* text starting address */
+	unsigned long	start_data;		/* data starting address */
+	unsigned long	start_stack;		/* stack starting address */
+	long int	signal;			/* signal causing core dump */
+	unsigned long	u_ar0;			/* help gdb find registers */
+	unsigned long	magic;			/* identifies a core file */
+	char		u_comm[32];		/* user command name */
+};
+
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif /* _ASM_M32R_USER_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/vga.h linux-2.6.30-rc3/arch/m32r/include/asm/vga.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/vga.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/vga.h	2009-04-22 03:29:16.277780857 +0000
@@ -0,0 +1,20 @@
+#ifndef _ASM_M32R_VGA_H
+#define _ASM_M32R_VGA_H
+
+/*
+ *	Access to VGA videoram
+ *
+ *	(c) 1998 Martin Mares <mj@ucw.cz>
+ */
+
+/*
+ *	On the PC, we can just recalculate addresses and then
+ *	access the videoram directly without any black magic.
+ */
+
+#define VGA_MAP_MEM(x,s) (unsigned long)phys_to_virt(x)
+
+#define vga_readb(x) (*(x))
+#define vga_writeb(x,y) (*(y) = (x))
+
+#endif /* _ASM_M32R_VGA_H */
diff -urN linux-2.6.30-rc2/arch/m32r/include/asm/xor.h linux-2.6.30-rc3/arch/m32r/include/asm/xor.h
--- linux-2.6.30-rc2/arch/m32r/include/asm/xor.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/m32r/include/asm/xor.h	2009-04-22 03:29:16.277780857 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_M32R_XOR_H
+#define _ASM_M32R_XOR_H
+
+#include <asm-generic/xor.h>
+
+#endif  /* _ASM_M32R_XOR_H */
diff -urN linux-2.6.30-rc2/arch/m68knommu/platform/68328/timers.c linux-2.6.30-rc3/arch/m68knommu/platform/68328/timers.c
--- linux-2.6.30-rc2/arch/m68knommu/platform/68328/timers.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/m68knommu/platform/68328/timers.c	2009-04-22 03:29:16.294931493 +0000
@@ -75,7 +75,7 @@
 
 /***************************************************************************/
 
-static cycle_t m68328_read_clk(void)
+static cycle_t m68328_read_clk(struct clocksource *cs)
 {
 	unsigned long flags;
 	u32 cycles;
diff -urN linux-2.6.30-rc2/arch/m68knommu/platform/coldfire/dma_timer.c linux-2.6.30-rc3/arch/m68knommu/platform/coldfire/dma_timer.c
--- linux-2.6.30-rc2/arch/m68knommu/platform/coldfire/dma_timer.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/m68knommu/platform/coldfire/dma_timer.c	2009-04-22 03:29:16.294931493 +0000
@@ -34,7 +34,7 @@
 #define DMA_DTMR_CLK_DIV_16	(2 << 1)
 #define DMA_DTMR_ENABLE		(1 << 0)
 
-static cycle_t cf_dt_get_cycles(void)
+static cycle_t cf_dt_get_cycles(struct clocksource *cs)
 {
 	return __raw_readl(DTCN0);
 }
diff -urN linux-2.6.30-rc2/arch/m68knommu/platform/coldfire/pit.c linux-2.6.30-rc3/arch/m68knommu/platform/coldfire/pit.c
--- linux-2.6.30-rc2/arch/m68knommu/platform/coldfire/pit.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/m68knommu/platform/coldfire/pit.c	2009-04-22 03:29:16.294931493 +0000
@@ -125,7 +125,7 @@
 
 /***************************************************************************/
 
-static cycle_t pit_read_clk(void)
+static cycle_t pit_read_clk(struct clocksource *cs)
 {
 	unsigned long flags;
 	u32 cycles;
diff -urN linux-2.6.30-rc2/arch/m68knommu/platform/coldfire/timers.c linux-2.6.30-rc3/arch/m68knommu/platform/coldfire/timers.c
--- linux-2.6.30-rc2/arch/m68knommu/platform/coldfire/timers.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/m68knommu/platform/coldfire/timers.c	2009-04-22 03:29:16.294931493 +0000
@@ -78,7 +78,7 @@
 
 /***************************************************************************/
 
-static cycle_t mcftmr_read_clk(void)
+static cycle_t mcftmr_read_clk(struct clocksource *cs)
 {
 	unsigned long flags;
 	u32 cycles;
diff -urN linux-2.6.30-rc2/arch/mips/kernel/cevt-txx9.c linux-2.6.30-rc3/arch/mips/kernel/cevt-txx9.c
--- linux-2.6.30-rc2/arch/mips/kernel/cevt-txx9.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/mips/kernel/cevt-txx9.c	2009-04-22 03:29:16.319931597 +0000
@@ -22,7 +22,7 @@
 
 static struct txx9_tmr_reg __iomem *txx9_cs_tmrptr;
 
-static cycle_t txx9_cs_read(void)
+static cycle_t txx9_cs_read(struct clocksource *cs)
 {
 	return __raw_readl(&txx9_cs_tmrptr->trr);
 }
diff -urN linux-2.6.30-rc2/arch/mips/kernel/csrc-bcm1480.c linux-2.6.30-rc3/arch/mips/kernel/csrc-bcm1480.c
--- linux-2.6.30-rc2/arch/mips/kernel/csrc-bcm1480.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/mips/kernel/csrc-bcm1480.c	2009-04-22 03:29:16.319931597 +0000
@@ -28,7 +28,7 @@
 
 #include <asm/sibyte/sb1250.h>
 
-static cycle_t bcm1480_hpt_read(void)
+static cycle_t bcm1480_hpt_read(struct clocksource *cs)
 {
 	return (cycle_t) __raw_readq(IOADDR(A_SCD_ZBBUS_CYCLE_COUNT));
 }
diff -urN linux-2.6.30-rc2/arch/mips/kernel/csrc-ioasic.c linux-2.6.30-rc3/arch/mips/kernel/csrc-ioasic.c
--- linux-2.6.30-rc2/arch/mips/kernel/csrc-ioasic.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/mips/kernel/csrc-ioasic.c	2009-04-22 03:29:16.319931597 +0000
@@ -25,7 +25,7 @@
 #include <asm/dec/ioasic.h>
 #include <asm/dec/ioasic_addrs.h>
 
-static cycle_t dec_ioasic_hpt_read(void)
+static cycle_t dec_ioasic_hpt_read(struct clocksource *cs)
 {
 	return ioasic_read(IO_REG_FCTR);
 }
@@ -47,13 +47,13 @@
 	while (!ds1287_timer_state())
 		;
 
-	start = dec_ioasic_hpt_read();
+	start = dec_ioasic_hpt_read(&clocksource_dec);
 
 	while (i--)
 		while (!ds1287_timer_state())
 			;
 
-	end = dec_ioasic_hpt_read();
+	end = dec_ioasic_hpt_read(&clocksource_dec);
 
 	freq = (end - start) * 10;
 	printk(KERN_INFO "I/O ASIC clock frequency %dHz\n", freq);
diff -urN linux-2.6.30-rc2/arch/mips/kernel/csrc-r4k.c linux-2.6.30-rc3/arch/mips/kernel/csrc-r4k.c
--- linux-2.6.30-rc2/arch/mips/kernel/csrc-r4k.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/mips/kernel/csrc-r4k.c	2009-04-22 03:29:16.319931597 +0000
@@ -10,7 +10,7 @@
 
 #include <asm/time.h>
 
-static cycle_t c0_hpt_read(void)
+static cycle_t c0_hpt_read(struct clocksource *cs)
 {
 	return read_c0_count();
 }
diff -urN linux-2.6.30-rc2/arch/mips/kernel/csrc-sb1250.c linux-2.6.30-rc3/arch/mips/kernel/csrc-sb1250.c
--- linux-2.6.30-rc2/arch/mips/kernel/csrc-sb1250.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/mips/kernel/csrc-sb1250.c	2009-04-22 03:29:16.319931597 +0000
@@ -33,7 +33,7 @@
  * The HPT is free running from SB1250_HPT_VALUE down to 0 then starts over
  * again.
  */
-static cycle_t sb1250_hpt_read(void)
+static cycle_t sb1250_hpt_read(struct clocksource *cs)
 {
 	unsigned int count;
 
diff -urN linux-2.6.30-rc2/arch/mips/kernel/i8253.c linux-2.6.30-rc3/arch/mips/kernel/i8253.c
--- linux-2.6.30-rc2/arch/mips/kernel/i8253.c	2009-04-22 03:29:10.294866681 +0000
+++ linux-2.6.30-rc3/arch/mips/kernel/i8253.c	2009-04-22 03:29:16.320931448 +0000
@@ -128,7 +128,7 @@
  * to just read by itself. So use jiffies to emulate a free
  * running counter:
  */
-static cycle_t pit_read(void)
+static cycle_t pit_read(struct clocksource *cs)
 {
 	unsigned long flags;
 	int count;
diff -urN linux-2.6.30-rc2/arch/mips/nxp/pnx8550/common/time.c linux-2.6.30-rc3/arch/mips/nxp/pnx8550/common/time.c
--- linux-2.6.30-rc2/arch/mips/nxp/pnx8550/common/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/mips/nxp/pnx8550/common/time.c	2009-04-22 03:29:16.324931485 +0000
@@ -35,7 +35,7 @@
 
 static unsigned long cpj;
 
-static cycle_t hpt_read(void)
+static cycle_t hpt_read(struct clocksource *cs)
 {
 	return read_c0_count2();
 }
diff -urN linux-2.6.30-rc2/arch/mips/sgi-ip27/ip27-timer.c linux-2.6.30-rc3/arch/mips/sgi-ip27/ip27-timer.c
--- linux-2.6.30-rc2/arch/mips/sgi-ip27/ip27-timer.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/mips/sgi-ip27/ip27-timer.c	2009-04-22 03:29:16.325796489 +0000
@@ -159,7 +159,7 @@
 	setup_irq(irq, &hub_rt_irqaction);
 }
 
-static cycle_t hub_rt_read(void)
+static cycle_t hub_rt_read(struct clocksource *cs)
 {
 	return REMOTE_HUB_L(cputonasid(0), PI_RT_COUNT);
 }
diff -urN linux-2.6.30-rc2/arch/mn10300/include/asm/bug.h linux-2.6.30-rc3/arch/mn10300/include/asm/bug.h
--- linux-2.6.30-rc2/arch/mn10300/include/asm/bug.h	2009-04-22 03:29:10.302931383 +0000
+++ linux-2.6.30-rc3/arch/mn10300/include/asm/bug.h	2009-04-22 03:29:16.328931615 +0000
@@ -11,10 +11,12 @@
 #ifndef _ASM_BUG_H
 #define _ASM_BUG_H
 
+#ifdef CONFIG_BUG
+
 /*
  * Tell the user there is some problem.
  */
-#define _debug_bug_trap()					\
+#define BUG()							\
 do {								\
 	asm volatile(						\
 		"	syscall 15			\n"	\
@@ -25,11 +27,11 @@
 		:						\
 		: "i"(__FILE__), "i"(__LINE__)			\
 		);						\
-} while (0)
-
-#define BUG() _debug_bug_trap()
+} while (1)
 
 #define HAVE_ARCH_BUG
+#endif /* CONFIG_BUG */
+
 #include <asm-generic/bug.h>
 
 #endif /* _ASM_BUG_H */
diff -urN linux-2.6.30-rc2/arch/mn10300/include/asm/unistd.h linux-2.6.30-rc3/arch/mn10300/include/asm/unistd.h
--- linux-2.6.30-rc2/arch/mn10300/include/asm/unistd.h	2009-04-22 03:29:10.313931393 +0000
+++ linux-2.6.30-rc3/arch/mn10300/include/asm/unistd.h	2009-04-22 03:29:16.340931576 +0000
@@ -344,6 +344,8 @@
 #define __NR_dup3		331
 #define __NR_pipe2		332
 #define __NR_inotify_init1	333
+#define __NR_preadv		334
+#define __NR_pwritev		335
 
 #ifdef __KERNEL__
 
diff -urN linux-2.6.30-rc2/arch/mn10300/kernel/entry.S linux-2.6.30-rc3/arch/mn10300/kernel/entry.S
--- linux-2.6.30-rc2/arch/mn10300/kernel/entry.S	2009-04-22 03:29:10.313931393 +0000
+++ linux-2.6.30-rc3/arch/mn10300/kernel/entry.S	2009-04-22 03:29:16.340931576 +0000
@@ -723,6 +723,8 @@
 	.long sys_dup3
 	.long sys_pipe2
 	.long sys_inotify_init1
+	.long sys_preadv
+	.long sys_pwritev		/* 335 */
 
 
 nr_syscalls=(.-sys_call_table)/4
diff -urN linux-2.6.30-rc2/arch/mn10300/kernel/setup.c linux-2.6.30-rc3/arch/mn10300/kernel/setup.c
--- linux-2.6.30-rc2/arch/mn10300/kernel/setup.c	2009-04-22 03:29:10.315931432 +0000
+++ linux-2.6.30-rc3/arch/mn10300/kernel/setup.c	2009-04-22 03:29:16.342931403 +0000
@@ -136,10 +136,6 @@
 	data_resource.start = virt_to_bus(&_etext);
 	data_resource.end = virt_to_bus(&_edata)-1;
 
-#define PFN_UP(x)	(((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
-#define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
-#define PFN_PHYS(x)	((x) << PAGE_SHIFT)
-
 	start_pfn = (CONFIG_KERNEL_RAM_BASE_ADDRESS >> PAGE_SHIFT);
 	kstart_pfn = PFN_UP(__pa(&_text));
 	free_pfn = PFN_UP(__pa(&_end));
diff -urN linux-2.6.30-rc2/arch/powerpc/Kconfig linux-2.6.30-rc3/arch/powerpc/Kconfig
--- linux-2.6.30-rc2/arch/powerpc/Kconfig	2009-04-22 03:29:10.323931374 +0000
+++ linux-2.6.30-rc3/arch/powerpc/Kconfig	2009-04-22 03:29:16.350931393 +0000
@@ -462,7 +462,7 @@
 
 config PPC_256K_PAGES
 	bool "256k page size" if 44x
-	depends on !STDBINUTILS && (!SHMEM || BROKEN)
+	depends on !STDBINUTILS
 	help
 	  Make the page size 256k.
 
diff -urN linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8540.dts linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8540.dts
--- linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8540.dts	2009-04-22 03:29:10.334556351 +0000
+++ linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8540.dts	2009-04-22 03:29:16.361556301 +0000
@@ -84,9 +84,9 @@
 			interrupt-parent = <&mpic>;
 			dfsrr;
 
-			dtt@50 {
+			dtt@48 {
 				compatible = "national,lm75";
-				reg = <0x50>;
+				reg = <0x48>;
 			};
 
 			rtc@68 {
diff -urN linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8541.dts linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8541.dts
--- linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8541.dts	2009-04-22 03:29:10.334556351 +0000
+++ linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8541.dts	2009-04-22 03:29:16.361556301 +0000
@@ -83,9 +83,9 @@
 			interrupt-parent = <&mpic>;
 			dfsrr;
 
-			dtt@50 {
+			dtt@48 {
 				compatible = "national,lm75";
-				reg = <0x50>;
+				reg = <0x48>;
 			};
 
 			rtc@68 {
diff -urN linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8548-bigflash.dts linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8548-bigflash.dts
--- linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8548-bigflash.dts	2009-04-22 03:29:10.334556351 +0000
+++ linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8548-bigflash.dts	2009-04-22 03:29:16.361556301 +0000
@@ -85,9 +85,9 @@
 			interrupt-parent = <&mpic>;
 			dfsrr;
 
-			dtt@50 {
+			dtt@48 {
 				compatible = "national,lm75";
-				reg = <0x50>;
+				reg = <0x48>;
 			};
 
 			rtc@68 {
@@ -247,7 +247,7 @@
 			interrupts = <31 2 32 2 33 2>;
 			interrupt-parent = <&mpic>;
 			tbi-handle = <&tbi2>;
-			phy-handle = <&phy3>;
+			phy-handle = <&phy4>;
 
 			mdio@520 {
 				#address-cells = <1>;
@@ -275,7 +275,7 @@
 			interrupts = <37 2 38 2 39 2>;
 			interrupt-parent = <&mpic>;
 			tbi-handle = <&tbi3>;
-			phy-handle = <&phy4>;
+			phy-handle = <&phy5>;
 
 			mdio@520 {
 				#address-cells = <1>;
diff -urN linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8548.dts linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8548.dts
--- linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8548.dts	2009-04-22 03:29:10.335931425 +0000
+++ linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8548.dts	2009-04-22 03:29:16.362931450 +0000
@@ -85,9 +85,9 @@
 			interrupt-parent = <&mpic>;
 			dfsrr;
 
-			dtt@50 {
+			dtt@48 {
 				compatible = "national,lm75";
-				reg = <0x50>;
+				reg = <0x48>;
 			};
 
 			rtc@68 {
@@ -247,7 +247,7 @@
 			interrupts = <31 2 32 2 33 2>;
 			interrupt-parent = <&mpic>;
 			tbi-handle = <&tbi2>;
-			phy-handle = <&phy3>;
+			phy-handle = <&phy4>;
 
 			mdio@520 {
 				#address-cells = <1>;
@@ -275,7 +275,7 @@
 			interrupts = <37 2 38 2 39 2>;
 			interrupt-parent = <&mpic>;
 			tbi-handle = <&tbi3>;
-			phy-handle = <&phy4>;
+			phy-handle = <&phy5>;
 
 			mdio@520 {
 				#address-cells = <1>;
diff -urN linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8555.dts linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8555.dts
--- linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8555.dts	2009-04-22 03:29:10.335931425 +0000
+++ linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8555.dts	2009-04-22 03:29:16.362931450 +0000
@@ -83,9 +83,9 @@
 			interrupt-parent = <&mpic>;
 			dfsrr;
 
-			dtt@50 {
+			dtt@48 {
 				compatible = "national,lm75";
-				reg = <0x50>;
+				reg = <0x48>;
 			};
 
 			rtc@68 {
diff -urN linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8560.dts linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8560.dts
--- linux-2.6.30-rc2/arch/powerpc/boot/dts/tqm8560.dts	2009-04-22 03:29:10.335931425 +0000
+++ linux-2.6.30-rc3/arch/powerpc/boot/dts/tqm8560.dts	2009-04-22 03:29:16.362931450 +0000
@@ -85,9 +85,9 @@
 			interrupt-parent = <&mpic>;
 			dfsrr;
 
-			dtt@50 {
+			dtt@48 {
 				compatible = "national,lm75";
-				reg = <0x50>;
+				reg = <0x48>;
 			};
 
 			rtc@68 {
diff -urN linux-2.6.30-rc2/arch/powerpc/configs/85xx/tqm8548_defconfig linux-2.6.30-rc3/arch/powerpc/configs/85xx/tqm8548_defconfig
--- linux-2.6.30-rc2/arch/powerpc/configs/85xx/tqm8548_defconfig	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/powerpc/configs/85xx/tqm8548_defconfig	2009-04-22 03:29:16.365931395 +0000
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29-rc2
-# Mon Jan 26 15:36:20 2009
+# Linux kernel version: 2.6.29-rc7
+# Mon Mar 16 09:03:28 2009
 #
 # CONFIG_PPC64 is not set
 
@@ -22,6 +22,7 @@
 # CONFIG_PHYS_64BIT is not set
 CONFIG_SPE=y
 CONFIG_PPC_MMU_NOHASH=y
+CONFIG_PPC_BOOK3E_MMU=y
 # CONFIG_PPC_MM_SLICES is not set
 # CONFIG_SMP is not set
 CONFIG_PPC32=y
@@ -75,6 +76,15 @@
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 CONFIG_GROUP_SCHED=y
@@ -152,11 +162,6 @@
 # CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_IOSCHED="anticipatory"
-CONFIG_CLASSIC_RCU=y
-# CONFIG_TREE_RCU is not set
-# CONFIG_PREEMPT_RCU is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_PREEMPT_RCU_TRACE is not set
 # CONFIG_FREEZER is not set
 
 #
@@ -202,7 +207,7 @@
 #
 # Kernel options
 #
-# CONFIG_HIGHMEM is not set
+CONFIG_HIGHMEM=y
 CONFIG_TICK_ONESHOT=y
 CONFIG_NO_HZ=y
 CONFIG_HIGH_RES_TIMERS=y
@@ -244,6 +249,7 @@
 CONFIG_PPC_4K_PAGES=y
 # CONFIG_PPC_16K_PAGES is not set
 # CONFIG_PPC_64K_PAGES is not set
+# CONFIG_PPC_256K_PAGES is not set
 CONFIG_FORCE_MAX_ZONEORDER=11
 CONFIG_PROC_DEVICETREE=y
 # CONFIG_CMDLINE_BOOL is not set
@@ -259,6 +265,7 @@
 CONFIG_PPC_INDIRECT_PCI=y
 CONFIG_FSL_SOC=y
 CONFIG_FSL_PCI=y
+CONFIG_FSL_LBC=y
 CONFIG_PPC_PCI_CHOICE=y
 CONFIG_PCI=y
 CONFIG_PCI_DOMAINS=y
@@ -284,10 +291,11 @@
 # Default settings for advanced configuration options are used
 #
 CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_LOWMEM_CAM_NUM=3
 CONFIG_PAGE_OFFSET=0xc0000000
 CONFIG_KERNEL_START=0xc0000000
 CONFIG_PHYSICAL_START=0x00000000
-CONFIG_PHYSICAL_ALIGN=0x10000000
+CONFIG_PHYSICAL_ALIGN=0x04000000
 CONFIG_TASK_SIZE=0xc0000000
 CONFIG_NET=y
 
@@ -363,12 +371,7 @@
 # CONFIG_BT is not set
 # CONFIG_AF_RXRPC is not set
 # CONFIG_PHONET is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-CONFIG_WIRELESS_OLD_REGULATORY=y
-# CONFIG_WIRELESS_EXT is not set
-# CONFIG_LIB80211 is not set
-# CONFIG_MAC80211 is not set
+# CONFIG_WIRELESS is not set
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
@@ -471,27 +474,18 @@
 # CONFIG_MTD_NAND_NANDSIM is not set
 # CONFIG_MTD_NAND_PLATFORM is not set
 # CONFIG_MTD_NAND_FSL_ELBC is not set
-# CONFIG_MTD_NAND_FSL_UPM is not set
+CONFIG_MTD_NAND_FSL_UPM=y
 # CONFIG_MTD_ONENAND is not set
 
 #
 # LPDDR flash memory drivers
 #
 # CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_QINFO_PROBE is not set
 
 #
 # UBI - Unsorted block images
 #
-CONFIG_MTD_UBI=m
-CONFIG_MTD_UBI_WL_THRESHOLD=4096
-CONFIG_MTD_UBI_BEB_RESERVE=1
-# CONFIG_MTD_UBI_GLUEBI is not set
-
-#
-# UBI debugging options
-#
-# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_MTD_UBI is not set
 CONFIG_OF_DEVICE=y
 CONFIG_OF_I2C=y
 # CONFIG_PARPORT is not set
@@ -515,69 +509,21 @@
 # CONFIG_BLK_DEV_HD is not set
 CONFIG_MISC_DEVICES=y
 # CONFIG_PHANTOM is not set
-# CONFIG_EEPROM_93CX6 is not set
 # CONFIG_SGI_IOC4 is not set
 # CONFIG_TIFM_CORE is not set
 # CONFIG_ICS932S401 is not set
 # CONFIG_ENCLOSURE_SERVICES is not set
 # CONFIG_HP_ILO is not set
 # CONFIG_C2PORT is not set
-CONFIG_HAVE_IDE=y
-CONFIG_IDE=y
 
 #
-# Please see Documentation/ide/ide.txt for help/info on IDE drives
+# EEPROM support
 #
-CONFIG_IDE_TIMINGS=y
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_IDE_GD=y
-CONFIG_IDE_GD_ATA=y
-# CONFIG_IDE_GD_ATAPI is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-CONFIG_IDE_PROC_FS=y
-
-#
-# IDE chipset support/bugfixes
-#
-# CONFIG_BLK_DEV_PLATFORM is not set
-CONFIG_BLK_DEV_IDEDMA_SFF=y
-
-#
-# PCI IDE chipsets support
-#
-CONFIG_BLK_DEV_IDEPCI=y
-CONFIG_IDEPCI_PCIBUS_ORDER=y
-# CONFIG_BLK_DEV_OFFBOARD is not set
-CONFIG_BLK_DEV_GENERIC=y
-# CONFIG_BLK_DEV_OPTI621 is not set
-CONFIG_BLK_DEV_IDEDMA_PCI=y
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-# CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_BLK_DEV_TRIFLEX is not set
-# CONFIG_BLK_DEV_CS5520 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_BLK_DEV_JMICRON is not set
-# CONFIG_BLK_DEV_SC1200 is not set
-# CONFIG_BLK_DEV_PIIX is not set
-# CONFIG_BLK_DEV_IT8172 is not set
-# CONFIG_BLK_DEV_IT8213 is not set
-# CONFIG_BLK_DEV_IT821X is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-# CONFIG_BLK_DEV_PDC202XX_NEW is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-# CONFIG_BLK_DEV_SIIMAGE is not set
-# CONFIG_BLK_DEV_SL82C105 is not set
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-CONFIG_BLK_DEV_VIA82CXXX=y
-# CONFIG_BLK_DEV_TC86C001 is not set
-CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
@@ -650,7 +596,7 @@
 CONFIG_NETDEV_1000=y
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
-CONFIG_E1000=y
+# CONFIG_E1000 is not set
 # CONFIG_E1000E is not set
 # CONFIG_IP1000 is not set
 # CONFIG_IGB is not set
@@ -668,6 +614,7 @@
 # CONFIG_QLA3XXX is not set
 # CONFIG_ATL1 is not set
 # CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
 # CONFIG_JME is not set
 CONFIG_NETDEV_10000=y
 # CONFIG_CHELSIO_T1 is not set
@@ -835,8 +782,6 @@
 # Miscellaneous I2C Chip support
 #
 # CONFIG_DS1682 is not set
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_LEGACY is not set
 # CONFIG_SENSORS_PCF8574 is not set
 # CONFIG_PCF8575 is not set
 # CONFIG_SENSORS_PCA9539 is not set
@@ -975,26 +920,7 @@
 # Special HID drivers
 #
 CONFIG_HID_COMPAT=y
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARCH_HAS_OHCI=y
-CONFIG_USB_ARCH_HAS_EHCI=y
-# CONFIG_USB is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-
-#
-# Enable Host or Gadget support to see Inventra options
-#
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# OTG and related infrastructure
-#
+# CONFIG_USB_SUPPORT is not set
 # CONFIG_UWB is not set
 # CONFIG_MMC is not set
 # CONFIG_MEMSTICK is not set
@@ -1064,16 +990,9 @@
 #
 # File systems
 #
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT2_FS_XIP is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-# CONFIG_EXT3_FS_POSIX_ACL is not set
-# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
 # CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_FS_POSIX_ACL is not set
@@ -1122,8 +1041,17 @@
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-# CONFIG_JFFS2_FS is not set
-# CONFIG_UBIFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
 # CONFIG_CRAMFS is not set
 # CONFIG_SQUASHFS is not set
 # CONFIG_VXFS_FS is not set
@@ -1184,6 +1112,8 @@
 CONFIG_CRC32=y
 # CONFIG_CRC7 is not set
 # CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
 CONFIG_PLIST=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
@@ -1219,6 +1149,7 @@
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
 # CONFIG_DEBUG_BUGVERBOSE is not set
 # CONFIG_DEBUG_INFO is not set
 # CONFIG_DEBUG_VM is not set
@@ -1236,6 +1167,7 @@
 # CONFIG_LATENCYTOP is not set
 CONFIG_SYSCTL_SYSCALL_CHECK=y
 CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
 CONFIG_HAVE_DYNAMIC_FTRACE=y
 CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
 
diff -urN linux-2.6.30-rc2/arch/powerpc/include/asm/futex.h linux-2.6.30-rc3/arch/powerpc/include/asm/futex.h
--- linux-2.6.30-rc2/arch/powerpc/include/asm/futex.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/powerpc/include/asm/futex.h	2009-04-22 03:29:16.369931417 +0000
@@ -27,7 +27,7 @@
 	PPC_LONG "1b,4b,2b,4b\n" \
 	".previous" \
 	: "=&r" (oldval), "=&r" (ret) \
-	: "b" (uaddr), "i" (-EFAULT), "1" (oparg) \
+	: "b" (uaddr), "i" (-EFAULT), "r" (oparg) \
 	: "cr0", "memory")
 
 static inline int futex_atomic_op_inuser (int encoded_op, int __user *uaddr)
@@ -47,19 +47,19 @@
 
 	switch (op) {
 	case FUTEX_OP_SET:
-		__futex_atomic_op("", ret, oldval, uaddr, oparg);
+		__futex_atomic_op("mr %1,%4\n", ret, oldval, uaddr, oparg);
 		break;
 	case FUTEX_OP_ADD:
-		__futex_atomic_op("add %1,%0,%1\n", ret, oldval, uaddr, oparg);
+		__futex_atomic_op("add %1,%0,%4\n", ret, oldval, uaddr, oparg);
 		break;
 	case FUTEX_OP_OR:
-		__futex_atomic_op("or %1,%0,%1\n", ret, oldval, uaddr, oparg);
+		__futex_atomic_op("or %1,%0,%4\n", ret, oldval, uaddr, oparg);
 		break;
 	case FUTEX_OP_ANDN:
-		__futex_atomic_op("andc %1,%0,%1\n", ret, oldval, uaddr, oparg);
+		__futex_atomic_op("andc %1,%0,%4\n", ret, oldval, uaddr, oparg);
 		break;
 	case FUTEX_OP_XOR:
-		__futex_atomic_op("xor %1,%0,%1\n", ret, oldval, uaddr, oparg);
+		__futex_atomic_op("xor %1,%0,%4\n", ret, oldval, uaddr, oparg);
 		break;
 	default:
 		ret = -ENOSYS;
diff -urN linux-2.6.30-rc2/arch/powerpc/include/asm/mmu.h linux-2.6.30-rc3/arch/powerpc/include/asm/mmu.h
--- linux-2.6.30-rc2/arch/powerpc/include/asm/mmu.h	2009-04-22 03:29:10.344931552 +0000
+++ linux-2.6.30-rc3/arch/powerpc/include/asm/mmu.h	2009-04-22 03:29:16.372869698 +0000
@@ -52,6 +52,12 @@
  */
 #define MMU_FTR_NEED_DTLB_SW_LRU	ASM_CONST(0x00200000)
 
+/* This indicates that the processor uses the wrong opcode for tlbilx
+ * instructions.  During the ISA 2.06 development the opcode for tlbilx
+ * changed and some early implementations used to old opcode
+ */
+#define MMU_FTR_TLBILX_EARLY_OPCODE	ASM_CONST(0x00400000)
+
 #ifndef __ASSEMBLY__
 #include <asm/cputable.h>
 
diff -urN linux-2.6.30-rc2/arch/powerpc/include/asm/ppc-opcode.h linux-2.6.30-rc3/arch/powerpc/include/asm/ppc-opcode.h
--- linux-2.6.30-rc2/arch/powerpc/include/asm/ppc-opcode.h	2009-04-22 03:29:10.347931401 +0000
+++ linux-2.6.30-rc3/arch/powerpc/include/asm/ppc-opcode.h	2009-04-22 03:29:16.375931436 +0000
@@ -43,7 +43,8 @@
 
 #define PPC_INST_STSWI			0x7c0005aa
 #define PPC_INST_STSWX			0x7c00052a
-#define PPC_INST_TLBILX			0x7c000626
+#define PPC_INST_TLBILX			0x7c000024
+#define PPC_INST_TLBILX_EARLY		0x7c000626
 #define PPC_INST_WAIT			0x7c00007c
 
 /* macros to insert fields into opcodes */
@@ -63,10 +64,18 @@
 #define PPC_RFDI		stringify_in_c(.long PPC_INST_RFDI)
 #define PPC_RFMCI		stringify_in_c(.long PPC_INST_RFMCI)
 #define PPC_TLBILX(t, a, b)	stringify_in_c(.long PPC_INST_TLBILX | \
-					__PPC_T_TLB(t) | __PPC_RA(a) | __PPC_RB(b))
+					__PPC_T_TLB(t) | \
+					__PPC_RA(a) | __PPC_RB(b))
 #define PPC_TLBILX_ALL(a, b)	PPC_TLBILX(0, a, b)
 #define PPC_TLBILX_PID(a, b)	PPC_TLBILX(1, a, b)
 #define PPC_TLBILX_VA(a, b)	PPC_TLBILX(3, a, b)
+
+#define PPC_TLBILX_EARLY(t, a, b) stringify_in_c(.long PPC_INST_TLBILX_EARLY | \
+						__PPC_T_TLB(t) | \
+						__PPC_RA(a) | __PPC_RB(b))
+#define PPC_TLBILX_ALL_EARLY(a, b)	PPC_TLBILX_EARLY(0, a, b)
+#define PPC_TLBILX_PID_EARLY(a, b)	PPC_TLBILX_EARLY(1, a, b)
+#define PPC_TLBILX_VA_EARLY(a, b)	PPC_TLBILX_EARLY(3, a, b)
 #define PPC_WAIT(w)		stringify_in_c(.long PPC_INST_WAIT | \
 					__PPC_WC(w))
 
diff -urN linux-2.6.30-rc2/arch/powerpc/kernel/cputable.c linux-2.6.30-rc3/arch/powerpc/kernel/cputable.c
--- linux-2.6.30-rc2/arch/powerpc/kernel/cputable.c	2009-04-22 03:29:10.352931395 +0000
+++ linux-2.6.30-rc3/arch/powerpc/kernel/cputable.c	2009-04-22 03:29:16.380931475 +0000
@@ -1766,7 +1766,7 @@
 		.cpu_features		= CPU_FTRS_E500MC,
 		.cpu_user_features	= COMMON_USER_BOOKE | PPC_FEATURE_HAS_FPU,
 		.mmu_features		= MMU_FTR_TYPE_FSL_E | MMU_FTR_BIG_PHYS |
-			MMU_FTR_USE_TLBILX,
+			MMU_FTR_USE_TLBILX | MMU_FTR_TLBILX_EARLY_OPCODE,
 		.icache_bsize		= 64,
 		.dcache_bsize		= 64,
 		.num_pmcs		= 4,
diff -urN linux-2.6.30-rc2/arch/powerpc/kernel/time.c linux-2.6.30-rc3/arch/powerpc/kernel/time.c
--- linux-2.6.30-rc2/arch/powerpc/kernel/time.c	2009-04-22 03:29:10.360931375 +0000
+++ linux-2.6.30-rc3/arch/powerpc/kernel/time.c	2009-04-22 03:29:16.388931528 +0000
@@ -77,7 +77,7 @@
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
 
-static cycle_t rtc_read(void);
+static cycle_t rtc_read(struct clocksource *);
 static struct clocksource clocksource_rtc = {
 	.name         = "rtc",
 	.rating       = 400,
@@ -88,7 +88,7 @@
 	.read         = rtc_read,
 };
 
-static cycle_t timebase_read(void);
+static cycle_t timebase_read(struct clocksource *);
 static struct clocksource clocksource_timebase = {
 	.name         = "timebase",
 	.rating       = 400,
@@ -766,12 +766,12 @@
 }
 
 /* clocksource code */
-static cycle_t rtc_read(void)
+static cycle_t rtc_read(struct clocksource *cs)
 {
 	return (cycle_t)get_rtc();
 }
 
-static cycle_t timebase_read(void)
+static cycle_t timebase_read(struct clocksource *cs)
 {
 	return (cycle_t)get_tb();
 }
diff -urN linux-2.6.30-rc2/arch/powerpc/mm/tlb_nohash.c linux-2.6.30-rc3/arch/powerpc/mm/tlb_nohash.c
--- linux-2.6.30-rc2/arch/powerpc/mm/tlb_nohash.c	2009-04-22 03:29:10.368931365 +0000
+++ linux-2.6.30-rc3/arch/powerpc/mm/tlb_nohash.c	2009-04-22 03:29:16.396931575 +0000
@@ -125,7 +125,6 @@
 
 void flush_tlb_mm(struct mm_struct *mm)
 {
-	cpumask_t cpu_mask;
 	unsigned int pid;
 
 	preempt_disable();
diff -urN linux-2.6.30-rc2/arch/powerpc/mm/tlb_nohash_low.S linux-2.6.30-rc3/arch/powerpc/mm/tlb_nohash_low.S
--- linux-2.6.30-rc2/arch/powerpc/mm/tlb_nohash_low.S	2009-04-22 03:29:10.368931365 +0000
+++ linux-2.6.30-rc3/arch/powerpc/mm/tlb_nohash_low.S	2009-04-22 03:29:16.396931575 +0000
@@ -138,7 +138,11 @@
 	andi.	r3,r3,MMUCSR0_TLBFI@l
 	bne	1b
 MMU_FTR_SECTION_ELSE
-	PPC_TLBILX_ALL(0,0)
+  BEGIN_MMU_FTR_SECTION_NESTED(96)
+	PPC_TLBILX_ALL(0,r3)
+  MMU_FTR_SECTION_ELSE_NESTED(96)
+	PPC_TLBILX_ALL_EARLY(0,r3)
+  ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(MMU_FTR_TLBILX_EARLY_OPCODE, 96)
 ALT_MMU_FTR_SECTION_END_IFCLR(MMU_FTR_USE_TLBILX)
 	msync
 	isync
@@ -151,7 +155,11 @@
 	wrteei	0
 	mfspr	r4,SPRN_MAS6	/* save MAS6 */
 	mtspr	SPRN_MAS6,r3
+  BEGIN_MMU_FTR_SECTION_NESTED(96)
 	PPC_TLBILX_PID(0,0)
+  MMU_FTR_SECTION_ELSE_NESTED(96)
+	PPC_TLBILX_PID_EARLY(0,0)
+  ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(MMU_FTR_TLBILX_EARLY_OPCODE, 96)
 	mtspr	SPRN_MAS6,r4	/* restore MAS6 */
 	wrtee	r10
 MMU_FTR_SECTION_ELSE
@@ -185,7 +193,11 @@
 	mtspr	SPRN_MAS1,r4
 	tlbwe
 MMU_FTR_SECTION_ELSE
+  BEGIN_MMU_FTR_SECTION_NESTED(96)
 	PPC_TLBILX_VA(0,r3)
+  MMU_FTR_SECTION_ELSE_NESTED(96)
+	PPC_TLBILX_VA_EARLY(0,r3)
+  ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(MMU_FTR_TLBILX_EARLY_OPCODE, 96)
 ALT_MMU_FTR_SECTION_END_IFCLR(MMU_FTR_USE_TLBILX)
 	msync
 	isync
diff -urN linux-2.6.30-rc2/arch/powerpc/platforms/pseries/dtl.c linux-2.6.30-rc3/arch/powerpc/platforms/pseries/dtl.c
--- linux-2.6.30-rc2/arch/powerpc/platforms/pseries/dtl.c	2009-04-22 03:29:10.381931865 +0000
+++ linux-2.6.30-rc3/arch/powerpc/platforms/pseries/dtl.c	2009-04-22 03:29:16.409931444 +0000
@@ -25,6 +25,7 @@
 #include <asm/smp.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
+#include <asm/firmware.h>
 
 #include "plpar_wrappers.h"
 
diff -urN linux-2.6.30-rc2/arch/powerpc/platforms/pseries/eeh_driver.c linux-2.6.30-rc3/arch/powerpc/platforms/pseries/eeh_driver.c
--- linux-2.6.30-rc2/arch/powerpc/platforms/pseries/eeh_driver.c	2009-04-22 03:29:10.381931865 +0000
+++ linux-2.6.30-rc3/arch/powerpc/platforms/pseries/eeh_driver.c	2009-04-22 03:29:16.409931444 +0000
@@ -182,6 +182,8 @@
 	if (!driver)
 		return;
 
+	dev->error_state = pci_channel_io_normal;
+
 	eeh_enable_irq(dev);
 
 	if (!driver->err_handler ||
diff -urN linux-2.6.30-rc2/arch/s390/appldata/appldata_base.c linux-2.6.30-rc3/arch/s390/appldata/appldata_base.c
--- linux-2.6.30-rc2/arch/s390/appldata/appldata_base.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/appldata/appldata_base.c	2009-04-22 03:29:16.413931502 +0000
@@ -176,7 +176,7 @@
 		struct vtimer_list *timer;
 		u64    expires;
 	} *args = p;
-	mod_virt_timer(args->timer, args->expires);
+	mod_virt_timer_periodic(args->timer, args->expires);
 }
 
 #define APPLDATA_ADD_TIMER	0
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/cpuid.h linux-2.6.30-rc3/arch/s390/include/asm/cpuid.h
--- linux-2.6.30-rc2/arch/s390/include/asm/cpuid.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/cpuid.h	2009-04-22 03:29:16.414931441 +0000
@@ -0,0 +1,25 @@
+/*
+ *    Copyright IBM Corp. 2000,2009
+ *    Author(s): Hartmut Penner <hp@de.ibm.com>,
+ *		 Martin Schwidefsky <schwidefsky@de.ibm.com>
+ *		 Christian Ehrhardt <ehrhardt@de.ibm.com>
+ */
+
+#ifndef _ASM_S390_CPUID_H_
+#define _ASM_S390_CPUID_H_
+
+/*
+ *  CPU type and hardware bug flags. Kept separately for each CPU.
+ *  Members of this structure are referenced in head.S, so think twice
+ *  before touching them. [mj]
+ */
+
+typedef struct
+{
+	unsigned int version :	8;
+	unsigned int ident   : 24;
+	unsigned int machine : 16;
+	unsigned int unused  : 16;
+} __attribute__ ((packed)) cpuid_t;
+
+#endif /* _ASM_S390_CPUID_H_ */
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/kvm_host.h linux-2.6.30-rc3/arch/s390/include/asm/kvm_host.h
--- linux-2.6.30-rc2/arch/s390/include/asm/kvm_host.h	2009-04-22 03:29:10.387556413 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/kvm_host.h	2009-04-22 03:29:16.415931410 +0000
@@ -15,6 +15,7 @@
 #define ASM_KVM_HOST_H
 #include <linux/kvm_host.h>
 #include <asm/debug.h>
+#include <asm/cpuid.h>
 
 #define KVM_MAX_VCPUS 64
 #define KVM_MEMORY_SLOTS 32
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/lowcore.h linux-2.6.30-rc3/arch/s390/include/asm/lowcore.h
--- linux-2.6.30-rc2/arch/s390/include/asm/lowcore.h	2009-04-22 03:29:10.388556334 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/lowcore.h	2009-04-22 03:29:16.415931410 +0000
@@ -66,6 +66,7 @@
 #define __LC_USER_EXEC_ASCE		0x02ac
 #define __LC_CPUID			0x02b0
 #define __LC_INT_CLOCK			0x02c8
+#define __LC_MACHINE_FLAGS		0x02d8
 #define __LC_IRB			0x0300
 #define __LC_PFAULT_INTPARM		0x0080
 #define __LC_CPU_TIMER_SAVE_AREA	0x00d8
@@ -110,6 +111,7 @@
 #define __LC_CPUID			0x0320
 #define __LC_INT_CLOCK			0x0340
 #define __LC_VDSO_PER_CPU		0x0350
+#define __LC_MACHINE_FLAGS		0x0358
 #define __LC_IRB			0x0380
 #define __LC_PASTE			0x03c0
 #define __LC_PFAULT_INTPARM		0x11b8
@@ -127,9 +129,9 @@
 
 #ifndef __ASSEMBLY__
 
-#include <asm/processor.h>
+#include <asm/cpuid.h>
+#include <asm/ptrace.h>
 #include <linux/types.h>
-#include <asm/sigp.h>
 
 void restart_int_handler(void);
 void ext_int_handler(void);
@@ -277,7 +279,8 @@
 	__u32	ext_call_fast;			/* 0x02c4 */
 	__u64	int_clock;			/* 0x02c8 */
 	__u64	clock_comparator;		/* 0x02d0 */
-	__u8	pad_0x02d8[0x0300-0x02d8];	/* 0x02d8 */
+	__u32	machine_flags;			/* 0x02d8 */
+	__u8	pad_0x02dc[0x0300-0x02dc];	/* 0x02dc */
 
 	/* Interrupt response block */
 	__u8	irb[64];			/* 0x0300 */
@@ -381,7 +384,8 @@
 	__u64	int_clock;			/* 0x0340 */
 	__u64	clock_comparator;		/* 0x0348 */
 	__u64	vdso_per_cpu_data;		/* 0x0350 */
-	__u8	pad_0x0358[0x0380-0x0358];	/* 0x0358 */
+	__u64	machine_flags;			/* 0x0358 */
+	__u8	pad_0x0360[0x0380-0x0360];	/* 0x0360 */
 
 	/* Interrupt response block. */
 	__u8	irb[64];			/* 0x0380 */
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/processor.h linux-2.6.30-rc3/arch/s390/include/asm/processor.h
--- linux-2.6.30-rc2/arch/s390/include/asm/processor.h	2009-04-22 03:29:10.388556334 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/processor.h	2009-04-22 03:29:16.415931410 +0000
@@ -14,7 +14,10 @@
 #define __ASM_S390_PROCESSOR_H
 
 #include <linux/linkage.h>
+#include <asm/cpuid.h>
+#include <asm/page.h>
 #include <asm/ptrace.h>
+#include <asm/setup.h>
 
 #ifdef __KERNEL__
 /*
@@ -23,20 +26,6 @@
  */
 #define current_text_addr() ({ void *pc; asm("basr %0,0" : "=a" (pc)); pc; })
 
-/*
- *  CPU type and hardware bug flags. Kept separately for each CPU.
- *  Members of this structure are referenced in head.S, so think twice
- *  before touching them. [mj]
- */
-
-typedef struct
-{
-        unsigned int version :  8;
-        unsigned int ident   : 24;
-        unsigned int machine : 16;
-        unsigned int unused  : 16;
-} __attribute__ ((packed)) cpuid_t;
-
 static inline void get_cpu_id(cpuid_t *ptr)
 {
 	asm volatile("stidp 0(%1)" : "=m" (*ptr) : "a" (ptr));
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/ptrace.h linux-2.6.30-rc3/arch/s390/include/asm/ptrace.h
--- linux-2.6.30-rc2/arch/s390/include/asm/ptrace.h	2009-04-22 03:29:10.388556334 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/ptrace.h	2009-04-22 03:29:16.416931436 +0000
@@ -313,8 +313,6 @@
 
 
 #ifdef __KERNEL__
-#include <asm/setup.h>
-#include <asm/page.h>
 
 /*
  * The pt_regs struct defines the way the registers are stored on
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/setup.h linux-2.6.30-rc3/arch/s390/include/asm/setup.h
--- linux-2.6.30-rc2/arch/s390/include/asm/setup.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/setup.h	2009-04-22 03:29:16.416931436 +0000
@@ -14,6 +14,7 @@
 
 #ifdef __KERNEL__
 
+#include <asm/lowcore.h>
 #include <asm/types.h>
 
 #define PARMAREA		0x10400
@@ -63,7 +64,6 @@
 /*
  * Machine features detected in head.S
  */
-extern unsigned long machine_flags;
 
 #define MACHINE_FLAG_VM		(1UL << 0)
 #define MACHINE_FLAG_IEEE	(1UL << 1)
@@ -77,28 +77,28 @@
 #define MACHINE_FLAG_HPAGE	(1UL << 10)
 #define MACHINE_FLAG_PFMF	(1UL << 11)
 
-#define MACHINE_IS_VM		(machine_flags & MACHINE_FLAG_VM)
-#define MACHINE_IS_KVM		(machine_flags & MACHINE_FLAG_KVM)
-#define MACHINE_HAS_DIAG9C	(machine_flags & MACHINE_FLAG_DIAG9C)
+#define MACHINE_IS_VM		(S390_lowcore.machine_flags & MACHINE_FLAG_VM)
+#define MACHINE_IS_KVM		(S390_lowcore.machine_flags & MACHINE_FLAG_KVM)
+#define MACHINE_HAS_DIAG9C	(S390_lowcore.machine_flags & MACHINE_FLAG_DIAG9C)
 
 #ifndef __s390x__
-#define MACHINE_HAS_IEEE	(machine_flags & MACHINE_FLAG_IEEE)
-#define MACHINE_HAS_CSP		(machine_flags & MACHINE_FLAG_CSP)
+#define MACHINE_HAS_IEEE	(S390_lowcore.machine_flags & MACHINE_FLAG_IEEE)
+#define MACHINE_HAS_CSP		(S390_lowcore.machine_flags & MACHINE_FLAG_CSP)
 #define MACHINE_HAS_IDTE	(0)
 #define MACHINE_HAS_DIAG44	(1)
-#define MACHINE_HAS_MVPG	(machine_flags & MACHINE_FLAG_MVPG)
+#define MACHINE_HAS_MVPG	(S390_lowcore.machine_flags & MACHINE_FLAG_MVPG)
 #define MACHINE_HAS_MVCOS	(0)
 #define MACHINE_HAS_HPAGE	(0)
 #define MACHINE_HAS_PFMF	(0)
 #else /* __s390x__ */
 #define MACHINE_HAS_IEEE	(1)
 #define MACHINE_HAS_CSP		(1)
-#define MACHINE_HAS_IDTE	(machine_flags & MACHINE_FLAG_IDTE)
-#define MACHINE_HAS_DIAG44	(machine_flags & MACHINE_FLAG_DIAG44)
+#define MACHINE_HAS_IDTE	(S390_lowcore.machine_flags & MACHINE_FLAG_IDTE)
+#define MACHINE_HAS_DIAG44	(S390_lowcore.machine_flags & MACHINE_FLAG_DIAG44)
 #define MACHINE_HAS_MVPG	(1)
-#define MACHINE_HAS_MVCOS	(machine_flags & MACHINE_FLAG_MVCOS)
-#define MACHINE_HAS_HPAGE	(machine_flags & MACHINE_FLAG_HPAGE)
-#define MACHINE_HAS_PFMF	(machine_flags & MACHINE_FLAG_PFMF)
+#define MACHINE_HAS_MVCOS	(S390_lowcore.machine_flags & MACHINE_FLAG_MVCOS)
+#define MACHINE_HAS_HPAGE	(S390_lowcore.machine_flags & MACHINE_FLAG_HPAGE)
+#define MACHINE_HAS_PFMF	(S390_lowcore.machine_flags & MACHINE_FLAG_PFMF)
 #endif /* __s390x__ */
 
 #define ZFCPDUMP_HSA_SIZE	(32UL<<20)
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/thread_info.h linux-2.6.30-rc3/arch/s390/include/asm/thread_info.h
--- linux-2.6.30-rc2/arch/s390/include/asm/thread_info.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/thread_info.h	2009-04-22 03:29:16.416931436 +0000
@@ -31,8 +31,9 @@
 #define ASYNC_SIZE  (PAGE_SIZE << ASYNC_ORDER)
 
 #ifndef __ASSEMBLY__
-#include <asm/processor.h>
 #include <asm/lowcore.h>
+#include <asm/page.h>
+#include <asm/processor.h>
 
 /*
  * low level task data that entry.S needs immediate access to
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/timer.h linux-2.6.30-rc3/arch/s390/include/asm/timer.h
--- linux-2.6.30-rc2/arch/s390/include/asm/timer.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/timer.h	2009-04-22 03:29:16.417931596 +0000
@@ -41,6 +41,7 @@
 extern void add_virt_timer(void *new);
 extern void add_virt_timer_periodic(void *new);
 extern int mod_virt_timer(struct vtimer_list *timer, __u64 expires);
+extern int mod_virt_timer_periodic(struct vtimer_list *timer, __u64 expires);
 extern int del_virt_timer(struct vtimer_list *timer);
 
 extern void init_cpu_vtimer(void);
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/timex.h linux-2.6.30-rc3/arch/s390/include/asm/timex.h
--- linux-2.6.30-rc2/arch/s390/include/asm/timex.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/timex.h	2009-04-22 03:29:16.417931596 +0000
@@ -11,6 +11,9 @@
 #ifndef _ASM_S390_TIMEX_H
 #define _ASM_S390_TIMEX_H
 
+/* The value of the TOD clock for 1.1.1970. */
+#define TOD_UNIX_EPOCH 0x7d91048bca000000ULL
+
 /* Inline functions for clock register access. */
 static inline int set_clock(__u64 time)
 {
@@ -85,4 +88,6 @@
 void init_cpu_timer(void);
 unsigned long long monotonic_clock(void);
 
+extern u64 sched_clock_base_cc;
+
 #endif
diff -urN linux-2.6.30-rc2/arch/s390/include/asm/unistd.h linux-2.6.30-rc3/arch/s390/include/asm/unistd.h
--- linux-2.6.30-rc2/arch/s390/include/asm/unistd.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/include/asm/unistd.h	2009-04-22 03:29:16.417931596 +0000
@@ -265,7 +265,9 @@
 #define __NR_pipe2		325
 #define __NR_dup3		326
 #define __NR_epoll_create1	327
-#define NR_syscalls 328
+#define	__NR_preadv		328
+#define	__NR_pwritev		329
+#define NR_syscalls 330
 
 /* 
  * There are some system calls that are not present on 64 bit, some
diff -urN linux-2.6.30-rc2/arch/s390/kernel/asm-offsets.c linux-2.6.30-rc3/arch/s390/kernel/asm-offsets.c
--- linux-2.6.30-rc2/arch/s390/kernel/asm-offsets.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/asm-offsets.c	2009-04-22 03:29:16.417931596 +0000
@@ -27,6 +27,8 @@
 	DEFINE(__TI_flags, offsetof(struct thread_info, flags));
 	DEFINE(__TI_cpu, offsetof(struct thread_info, cpu));
 	DEFINE(__TI_precount, offsetof(struct thread_info, preempt_count));
+	DEFINE(__TI_user_timer, offsetof(struct thread_info, user_timer));
+	DEFINE(__TI_system_timer, offsetof(struct thread_info, system_timer));
 	BLANK();
 	DEFINE(__PT_ARGS, offsetof(struct pt_regs, args));
 	DEFINE(__PT_PSW, offsetof(struct pt_regs, psw));
diff -urN linux-2.6.30-rc2/arch/s390/kernel/compat_linux.c linux-2.6.30-rc3/arch/s390/kernel/compat_linux.c
--- linux-2.6.30-rc2/arch/s390/kernel/compat_linux.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/compat_linux.c	2009-04-22 03:29:16.418931460 +0000
@@ -702,20 +702,12 @@
 				struct stat64_emu31 __user* statbuf, int flag)
 {
 	struct kstat stat;
-	int error = -EINVAL;
+	int error;
 
-	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
-		goto out;
-
-	if (flag & AT_SYMLINK_NOFOLLOW)
-		error = vfs_lstat_fd(dfd, filename, &stat);
-	else
-		error = vfs_stat_fd(dfd, filename, &stat);
-
-	if (!error)
-		error = cp_stat64(statbuf, &stat);
-out:
-	return error;
+	error = vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_stat64(statbuf, &stat);
 }
 
 /*
diff -urN linux-2.6.30-rc2/arch/s390/kernel/compat_wrapper.S linux-2.6.30-rc3/arch/s390/kernel/compat_wrapper.S
--- linux-2.6.30-rc2/arch/s390/kernel/compat_wrapper.S	2009-04-22 03:29:10.390931431 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/compat_wrapper.S	2009-04-22 03:29:16.419931492 +0000
@@ -1805,3 +1805,21 @@
 	llgfr	%r5,%r5			# u32
 	llgfr	%r6,%r6			# u32
 	jg	compat_sys_keyctl	# branch to system call
+
+	.globl	compat_sys_preadv_wrapper
+compat_sys_preadv_wrapper:
+	llgfr	%r2,%r2			# unsigned long
+	llgtr	%r3,%r3			# compat_iovec *
+	llgfr	%r4,%r4			# unsigned long
+	llgfr	%r5,%r5			# u32
+	llgfr	%r6,%r6			# u32
+	jg	compat_sys_preadv	# branch to system call
+
+	.globl	compat_sys_pwritev_wrapper
+compat_sys_pwritev_wrapper:
+	llgfr	%r2,%r2			# unsigned long
+	llgtr	%r3,%r3			# compat_iovec *
+	llgfr	%r4,%r4			# unsigned long
+	llgfr	%r5,%r5			# u32
+	llgfr	%r6,%r6			# u32
+	jg	compat_sys_pwritev	# branch to system call
diff -urN linux-2.6.30-rc2/arch/s390/kernel/early.c linux-2.6.30-rc3/arch/s390/kernel/early.c
--- linux-2.6.30-rc2/arch/s390/kernel/early.c	2009-04-22 03:29:10.390931431 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/early.c	2009-04-22 03:29:16.419931492 +0000
@@ -34,8 +34,25 @@
 
 char kernel_nss_name[NSS_NAME_SIZE + 1];
 
+static unsigned long machine_flags;
+
 static void __init setup_boot_command_line(void);
 
+/*
+ * Get the TOD clock running.
+ */
+static void __init reset_tod_clock(void)
+{
+	u64 time;
+
+	if (store_clock(&time) == 0)
+		return;
+	/* TOD clock not running. Set the clock to Unix Epoch. */
+	if (set_clock(TOD_UNIX_EPOCH) != 0 || store_clock(&time) != 0)
+		disabled_wait(0);
+
+	sched_clock_base_cc = TOD_UNIX_EPOCH;
+}
 
 #ifdef CONFIG_SHARED_KERNEL
 int __init savesys_ipl_nss(char *cmd, const int cmdlen);
@@ -370,6 +387,7 @@
  */
 void __init startup_init(void)
 {
+	reset_tod_clock();
 	ipl_save_parameters();
 	rescue_initrd();
 	clear_bss_section();
@@ -391,5 +409,6 @@
 	setup_hpage();
 	sclp_facilities_detect();
 	detect_memory_layout(memory_chunk);
+	S390_lowcore.machine_flags = machine_flags;
 	lockdep_on();
 }
diff -urN linux-2.6.30-rc2/arch/s390/kernel/entry.S linux-2.6.30-rc3/arch/s390/kernel/entry.S
--- linux-2.6.30-rc2/arch/s390/kernel/entry.S	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/entry.S	2009-04-22 03:29:16.419931492 +0000
@@ -837,16 +837,29 @@
 	__CPUINIT
 	.globl restart_int_handler
 restart_int_handler:
+	basr	%r1,0
+restart_base:
+	spt	restart_vtime-restart_base(%r1)
+	stck	__LC_LAST_UPDATE_CLOCK
+	mvc	__LC_LAST_UPDATE_TIMER(8),restart_vtime-restart_base(%r1)
+	mvc	__LC_EXIT_TIMER(8),restart_vtime-restart_base(%r1)
 	l	%r15,__LC_SAVE_AREA+60	# load ksp
 	lctl	%c0,%c15,__LC_CREGS_SAVE_AREA # get new ctl regs
 	lam	%a0,%a15,__LC_AREGS_SAVE_AREA
 	lm	%r6,%r15,__SF_GPRS(%r15) # load registers from clone
+	l	%r1,__LC_THREAD_INFO
+	mvc	__LC_USER_TIMER(8),__TI_user_timer(%r1)
+	mvc	__LC_SYSTEM_TIMER(8),__TI_system_timer(%r1)
+	xc	__LC_STEAL_TIMER(8),__LC_STEAL_TIMER
 	stosm	__SF_EMPTY(%r15),0x04	# now we can turn dat on
 	basr	%r14,0
 	l	%r14,restart_addr-.(%r14)
 	br	%r14			# branch to start_secondary
 restart_addr:
 	.long	start_secondary
+	.align	8
+restart_vtime:
+	.long	0x7fffffff,0xffffffff
 	.previous
 #else
 /*
diff -urN linux-2.6.30-rc2/arch/s390/kernel/entry64.S linux-2.6.30-rc3/arch/s390/kernel/entry64.S
--- linux-2.6.30-rc2/arch/s390/kernel/entry64.S	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/entry64.S	2009-04-22 03:29:16.420931419 +0000
@@ -831,14 +831,27 @@
 	__CPUINIT
 	.globl restart_int_handler
 restart_int_handler:
+	basr	%r1,0
+restart_base:
+	spt	restart_vtime-restart_base(%r1)
+	stck	__LC_LAST_UPDATE_CLOCK
+	mvc	__LC_LAST_UPDATE_TIMER(8),restart_vtime-restart_base(%r1)
+	mvc	__LC_EXIT_TIMER(8),restart_vtime-restart_base(%r1)
 	lg	%r15,__LC_SAVE_AREA+120 # load ksp
 	lghi	%r10,__LC_CREGS_SAVE_AREA
 	lctlg	%c0,%c15,0(%r10) # get new ctl regs
 	lghi	%r10,__LC_AREGS_SAVE_AREA
 	lam	%a0,%a15,0(%r10)
 	lmg	%r6,%r15,__SF_GPRS(%r15) # load registers from clone
+	lg	%r1,__LC_THREAD_INFO
+	mvc	__LC_USER_TIMER(8),__TI_user_timer(%r1)
+	mvc	__LC_SYSTEM_TIMER(8),__TI_system_timer(%r1)
+	xc	__LC_STEAL_TIMER(8),__LC_STEAL_TIMER
 	stosm	__SF_EMPTY(%r15),0x04	# now we can turn dat on
 	jg	start_secondary
+	.align	8
+restart_vtime:
+	.long	0x7fffffff,0xffffffff
 	.previous
 #else
 /*
diff -urN linux-2.6.30-rc2/arch/s390/kernel/head.S linux-2.6.30-rc3/arch/s390/kernel/head.S
--- linux-2.6.30-rc2/arch/s390/kernel/head.S	2009-04-22 03:29:10.390931431 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/head.S	2009-04-22 03:29:16.420931419 +0000
@@ -471,7 +471,12 @@
 .LPG0:
 	xc	0x200(256),0x200	# partially clear lowcore
 	xc	0x300(256),0x300
-
+	l	%r1,5f-.LPG0(%r13)
+	stck	0(%r1)
+	spt	6f-.LPG0(%r13)
+	mvc	__LC_LAST_UPDATE_CLOCK(8),0(%r1)
+	mvc	__LC_LAST_UPDATE_TIMER(8),6f-.LPG0(%r13)
+	mvc	__LC_EXIT_TIMER(8),5f-.LPG0(%r13)
 #ifndef CONFIG_MARCH_G5
 	# check processor version against MARCH_{G5,Z900,Z990,Z9_109,Z10}
 	stidp	__LC_CPUID		# store cpuid
@@ -496,9 +501,13 @@
 	brct	%r0,0b
 #endif
 
-	l	%r13,0f-.LPG0(%r13)
+	l	%r13,4f-.LPG0(%r13)
 	b	0(%r13)
-0:	.long	startup_continue
+	.align	4
+4:	.long	startup_continue
+5:	.long	sched_clock_base_cc
+	.align	8
+6:	.long	0x7fffffff,0xffffffff
 
 #
 # params at 10400 (setup.h)
diff -urN linux-2.6.30-rc2/arch/s390/kernel/nmi.c linux-2.6.30-rc3/arch/s390/kernel/nmi.c
--- linux-2.6.30-rc2/arch/s390/kernel/nmi.c	2009-04-22 03:29:10.391931462 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/nmi.c	2009-04-22 03:29:16.421561373 +0000
@@ -10,6 +10,7 @@
 
 #include <linux/init.h>
 #include <linux/errno.h>
+#include <linux/hardirq.h>
 #include <linux/time.h>
 #include <linux/module.h>
 #include <asm/lowcore.h>
@@ -253,7 +254,7 @@
 	struct mci *mci;
 	int umode;
 
-	lockdep_off();
+	nmi_enter();
 	s390_idle_check();
 
 	mci = (struct mci *) &S390_lowcore.mcck_interruption_code;
@@ -363,7 +364,7 @@
 		mcck->warning = 1;
 		set_thread_flag(TIF_MCCK_PENDING);
 	}
-	lockdep_on();
+	nmi_exit();
 }
 
 static int __init machine_check_init(void)
diff -urN linux-2.6.30-rc2/arch/s390/kernel/setup.c linux-2.6.30-rc3/arch/s390/kernel/setup.c
--- linux-2.6.30-rc2/arch/s390/kernel/setup.c	2009-04-22 03:29:10.392931437 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/setup.c	2009-04-22 03:29:16.422931461 +0000
@@ -82,9 +82,6 @@
 unsigned int console_irq = -1;
 EXPORT_SYMBOL(console_irq);
 
-unsigned long machine_flags;
-EXPORT_SYMBOL(machine_flags);
-
 unsigned long elf_hwcap = 0;
 char elf_platform[ELF_PLATFORM_SIZE];
 
@@ -426,6 +423,7 @@
 		__alloc_bootmem(PAGE_SIZE, PAGE_SIZE, 0) + PAGE_SIZE;
 	lc->current_task = (unsigned long) init_thread_union.thread_info.task;
 	lc->thread_info = (unsigned long) &init_thread_union;
+	lc->machine_flags = S390_lowcore.machine_flags;
 #ifndef CONFIG_64BIT
 	if (MACHINE_HAS_IEEE) {
 		lc->extended_save_area_addr = (__u32)
@@ -436,6 +434,14 @@
 #else
 	lc->vdso_per_cpu_data = (unsigned long) &lc->paste[0];
 #endif
+	lc->sync_enter_timer = S390_lowcore.sync_enter_timer;
+	lc->async_enter_timer = S390_lowcore.async_enter_timer;
+	lc->exit_timer = S390_lowcore.exit_timer;
+	lc->user_timer = S390_lowcore.user_timer;
+	lc->system_timer = S390_lowcore.system_timer;
+	lc->steal_timer = S390_lowcore.steal_timer;
+	lc->last_update_timer = S390_lowcore.last_update_timer;
+	lc->last_update_clock = S390_lowcore.last_update_clock;
 	set_prefix((u32)(unsigned long) lc);
 	lowcore_ptr[0] = lc;
 }
diff -urN linux-2.6.30-rc2/arch/s390/kernel/smp.c linux-2.6.30-rc3/arch/s390/kernel/smp.c
--- linux-2.6.30-rc2/arch/s390/kernel/smp.c	2009-04-22 03:29:10.393931394 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/smp.c	2009-04-22 03:29:16.422931461 +0000
@@ -571,6 +571,7 @@
 	cpu_lowcore->current_task = (unsigned long) idle;
 	cpu_lowcore->cpu_nr = cpu;
 	cpu_lowcore->kernel_asce = S390_lowcore.kernel_asce;
+	cpu_lowcore->machine_flags = S390_lowcore.machine_flags;
 	eieio();
 
 	while (signal_processor(cpu, sigp_restart) == sigp_busy)
@@ -590,7 +591,8 @@
 	int pcpus, cpu;
 
 	pcpus = simple_strtoul(s, NULL, 0);
-	for (cpu = 0; cpu < pcpus && cpu < nr_cpu_ids; cpu++)
+	init_cpu_possible(cpumask_of(0));
+	for (cpu = 1; cpu < pcpus && cpu < nr_cpu_ids; cpu++)
 		set_cpu_possible(cpu, true);
 	return 0;
 }
diff -urN linux-2.6.30-rc2/arch/s390/kernel/syscalls.S linux-2.6.30-rc3/arch/s390/kernel/syscalls.S
--- linux-2.6.30-rc2/arch/s390/kernel/syscalls.S	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/syscalls.S	2009-04-22 03:29:16.422931461 +0000
@@ -336,3 +336,5 @@
 SYSCALL(sys_pipe2,sys_pipe2,sys_pipe2_wrapper) /* 325 */
 SYSCALL(sys_dup3,sys_dup3,sys_dup3_wrapper)
 SYSCALL(sys_epoll_create1,sys_epoll_create1,sys_epoll_create1_wrapper)
+SYSCALL(sys_preadv,sys_preadv,compat_sys_preadv_wrapper)
+SYSCALL(sys_pwritev,sys_pwritev,compat_sys_pwritev_wrapper)
diff -urN linux-2.6.30-rc2/arch/s390/kernel/time.c linux-2.6.30-rc3/arch/s390/kernel/time.c
--- linux-2.6.30-rc2/arch/s390/kernel/time.c	2009-04-22 03:29:10.393931394 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/time.c	2009-04-22 03:29:16.423931532 +0000
@@ -52,9 +52,6 @@
 #define USECS_PER_JIFFY     ((unsigned long) 1000000/HZ)
 #define CLK_TICKS_PER_JIFFY ((unsigned long) USECS_PER_JIFFY << 12)
 
-/* The value of the TOD clock for 1.1.1970. */
-#define TOD_UNIX_EPOCH 0x7d91048bca000000ULL
-
 /*
  * Create a small time difference between the timer interrupts
  * on the different cpus to avoid lock contention.
@@ -63,9 +60,10 @@
 
 #define TICK_SIZE tick
 
+u64 sched_clock_base_cc = -1;	/* Force to data section. */
+
 static ext_int_info_t ext_int_info_cc;
 static ext_int_info_t ext_int_etr_cc;
-static u64 sched_clock_base_cc;
 
 static DEFINE_PER_CPU(struct clock_event_device, comparators);
 
@@ -195,25 +193,15 @@
 static void etr_reset(void);
 static void stp_reset(void);
 
-/*
- * Get the TOD clock running.
- */
-static u64 __init reset_tod_clock(void)
+unsigned long read_persistent_clock(void)
 {
-	u64 time;
-
-	etr_reset();
-	stp_reset();
-	if (store_clock(&time) == 0)
-		return time;
-	/* TOD clock not running. Set the clock to Unix Epoch. */
-	if (set_clock(TOD_UNIX_EPOCH) != 0 || store_clock(&time) != 0)
-		panic("TOD clock not operational.");
+	struct timespec ts;
 
-	return TOD_UNIX_EPOCH;
+	tod_to_timeval(get_clock() - TOD_UNIX_EPOCH, &ts);
+	return ts.tv_sec;
 }
 
-static cycle_t read_tod_clock(void)
+static cycle_t read_tod_clock(struct clocksource *cs)
 {
 	return get_clock();
 }
@@ -265,12 +253,13 @@
  */
 void __init time_init(void)
 {
-	sched_clock_base_cc = reset_tod_clock();
+	struct timespec ts;
+	unsigned long flags;
+	cycle_t now;
 
-	/* set xtime */
-	tod_to_timeval(sched_clock_base_cc - TOD_UNIX_EPOCH, &xtime);
-        set_normalized_timespec(&wall_to_monotonic,
-                                -xtime.tv_sec, -xtime.tv_nsec);
+	/* Reset time synchronization interfaces. */
+	etr_reset();
+	stp_reset();
 
 	/* request the clock comparator external interrupt */
 	if (register_early_external_interrupt(0x1004,
@@ -278,17 +267,38 @@
 					      &ext_int_info_cc) != 0)
                 panic("Couldn't request external interrupt 0x1004");
 
-	if (clocksource_register(&clocksource_tod) != 0)
-		panic("Could not register TOD clock source");
-
 	/* request the timing alert external interrupt */
 	if (register_early_external_interrupt(0x1406,
 					      timing_alert_interrupt,
 					      &ext_int_etr_cc) != 0)
 		panic("Couldn't request external interrupt 0x1406");
 
+	if (clocksource_register(&clocksource_tod) != 0)
+		panic("Could not register TOD clock source");
+
+	/*
+	 * The TOD clock is an accurate clock. The xtime should be
+	 * initialized in a way that the difference between TOD and
+	 * xtime is reasonably small. Too bad that timekeeping_init
+	 * sets xtime.tv_nsec to zero. In addition the clock source
+	 * change from the jiffies clock source to the TOD clock
+	 * source add another error of up to 1/HZ second. The same
+	 * function sets wall_to_monotonic to a value that is too
+	 * small for /proc/uptime to be accurate.
+	 * Reset xtime and wall_to_monotonic to sane values.
+	 */
+	write_seqlock_irqsave(&xtime_lock, flags);
+	now = get_clock();
+	tod_to_timeval(now - TOD_UNIX_EPOCH, &xtime);
+	clocksource_tod.cycle_last = now;
+	clocksource_tod.raw_time = xtime;
+	tod_to_timeval(sched_clock_base_cc - TOD_UNIX_EPOCH, &ts);
+	set_normalized_timespec(&wall_to_monotonic, -ts.tv_sec, -ts.tv_nsec);
+	write_sequnlock_irqrestore(&xtime_lock, flags);
+
 	/* Enable TOD clock interrupts on the boot cpu. */
 	init_cpu_timer();
+
 	/* Enable cpu timer interrupts on the boot cpu. */
 	vtime_init();
 }
@@ -1423,6 +1433,7 @@
 static void stp_work_fn(struct work_struct *work);
 static DEFINE_MUTEX(stp_work_mutex);
 static DECLARE_WORK(stp_work, stp_work_fn);
+static struct timer_list stp_timer;
 
 static int __init early_parse_stp(char *p)
 {
@@ -1454,10 +1465,16 @@
 	}
 }
 
+static void stp_timeout(unsigned long dummy)
+{
+	queue_work(time_sync_wq, &stp_work);
+}
+
 static int __init stp_init(void)
 {
 	if (!test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags))
 		return 0;
+	setup_timer(&stp_timer, stp_timeout, 0UL);
 	time_init_wq();
 	if (!stp_online)
 		return 0;
@@ -1565,6 +1582,7 @@
 
 	if (!stp_online) {
 		chsc_sstpc(stp_page, STP_OP_CTRL, 0x0000);
+		del_timer_sync(&stp_timer);
 		goto out_unlock;
 	}
 
@@ -1586,6 +1604,13 @@
 	stop_machine(stp_sync_clock, &stp_sync, &cpu_online_map);
 	put_online_cpus();
 
+	if (!check_sync_clock())
+		/*
+		 * There is a usable clock but the synchonization failed.
+		 * Retry after a second.
+		 */
+		mod_timer(&stp_timer, jiffies + HZ);
+
 out_unlock:
 	mutex_unlock(&stp_work_mutex);
 }
diff -urN linux-2.6.30-rc2/arch/s390/kernel/vtime.c linux-2.6.30-rc3/arch/s390/kernel/vtime.c
--- linux-2.6.30-rc2/arch/s390/kernel/vtime.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/s390/kernel/vtime.c	2009-04-22 03:29:16.424931566 +0000
@@ -134,6 +134,8 @@
 	/* Account time spent with enabled wait psw loaded as idle time. */
 	idle_time = S390_lowcore.int_clock - idle->idle_enter;
 	account_idle_time(idle_time);
+	S390_lowcore.steal_timer +=
+		idle->idle_enter - S390_lowcore.last_update_clock;
 	S390_lowcore.last_update_clock = S390_lowcore.int_clock;
 
 	/* Account system time spent going idle. */
@@ -425,17 +427,7 @@
 }
 EXPORT_SYMBOL(add_virt_timer_periodic);
 
-/*
- * If we change a pending timer the function must be called on the CPU
- * where the timer is running on, e.g. by smp_call_function_single()
- *
- * The original mod_timer adds the timer if it is not pending. For
- * compatibility we do the same. The timer will be added on the current
- * CPU as a oneshot timer.
- *
- * returns whether it has modified a pending timer (1) or not (0)
- */
-int mod_virt_timer(struct vtimer_list *timer, __u64 expires)
+int __mod_vtimer(struct vtimer_list *timer, __u64 expires, int periodic)
 {
 	struct vtimer_queue *vq;
 	unsigned long flags;
@@ -444,39 +436,35 @@
 	BUG_ON(!timer->function);
 	BUG_ON(!expires || expires > VTIMER_MAX_SLICE);
 
-	/*
-	 * This is a common optimization triggered by the
-	 * networking code - if the timer is re-modified
-	 * to be the same thing then just return:
-	 */
 	if (timer->expires == expires && vtimer_pending(timer))
 		return 1;
 
 	cpu = get_cpu();
 	vq = &per_cpu(virt_cpu_timer, cpu);
 
-	/* check if we run on the right CPU */
-	BUG_ON(timer->cpu != cpu);
-
 	/* disable interrupts before test if timer is pending */
 	spin_lock_irqsave(&vq->lock, flags);
 
 	/* if timer isn't pending add it on the current CPU */
 	if (!vtimer_pending(timer)) {
 		spin_unlock_irqrestore(&vq->lock, flags);
-		/* we do not activate an interval timer with mod_virt_timer */
-		timer->interval = 0;
+
+		if (periodic)
+			timer->interval = expires;
+		else
+			timer->interval = 0;
 		timer->expires = expires;
 		timer->cpu = cpu;
 		internal_add_vtimer(timer);
 		return 0;
 	}
 
+	/* check if we run on the right CPU */
+	BUG_ON(timer->cpu != cpu);
+
 	list_del_init(&timer->entry);
 	timer->expires = expires;
-
-	/* also change the interval if we have an interval timer */
-	if (timer->interval)
+	if (periodic)
 		timer->interval = expires;
 
 	/* the timer can't expire anymore so we can release the lock */
@@ -484,9 +472,32 @@
 	internal_add_vtimer(timer);
 	return 1;
 }
+
+/*
+ * If we change a pending timer the function must be called on the CPU
+ * where the timer is running on.
+ *
+ * returns whether it has modified a pending timer (1) or not (0)
+ */
+int mod_virt_timer(struct vtimer_list *timer, __u64 expires)
+{
+	return __mod_vtimer(timer, expires, 0);
+}
 EXPORT_SYMBOL(mod_virt_timer);
 
 /*
+ * If we change a pending timer the function must be called on the CPU
+ * where the timer is running on.
+ *
+ * returns whether it has modified a pending timer (1) or not (0)
+ */
+int mod_virt_timer_periodic(struct vtimer_list *timer, __u64 expires)
+{
+	return __mod_vtimer(timer, expires, 1);
+}
+EXPORT_SYMBOL(mod_virt_timer_periodic);
+
+/*
  * delete a virtual timer
  *
  * returns whether the deleted timer was pending (1) or not (0)
@@ -516,16 +527,8 @@
  */
 void init_cpu_vtimer(void)
 {
-	struct thread_info *ti = current_thread_info();
 	struct vtimer_queue *vq;
 
-	S390_lowcore.user_timer = ti->user_timer;
-	S390_lowcore.system_timer = ti->system_timer;
-
-	/* kick the virtual timer */
-	asm volatile ("STCK %0" : "=m" (S390_lowcore.last_update_clock));
-	asm volatile ("STPT %0" : "=m" (S390_lowcore.last_update_timer));
-
 	/* initialize per cpu vtimer structure */
 	vq = &__get_cpu_var(virt_cpu_timer);
 	INIT_LIST_HEAD(&vq->list);
diff -urN linux-2.6.30-rc2/arch/sh/kernel/cpu/sh4a/setup-sh7722.c linux-2.6.30-rc3/arch/sh/kernel/cpu/sh4a/setup-sh7722.c
--- linux-2.6.30-rc2/arch/sh/kernel/cpu/sh4a/setup-sh7722.c	2009-04-22 03:29:10.427931405 +0000
+++ linux-2.6.30-rc3/arch/sh/kernel/cpu/sh4a/setup-sh7722.c	2009-04-22 03:29:16.458931548 +0000
@@ -256,7 +256,6 @@
 {
 	clk_always_enable("uram0"); /* URAM */
 	clk_always_enable("xymem0"); /* XYMEM */
-	clk_always_enable("rtc0"); /* RTC */
 	clk_always_enable("veu0"); /* VEU */
 	clk_always_enable("vpu0"); /* VPU */
 	clk_always_enable("jpu0"); /* JPU */
diff -urN linux-2.6.30-rc2/arch/sh/kernel/cpu/sh4a/setup-sh7723.c linux-2.6.30-rc3/arch/sh/kernel/cpu/sh4a/setup-sh7723.c
--- linux-2.6.30-rc2/arch/sh/kernel/cpu/sh4a/setup-sh7723.c	2009-04-22 03:29:10.428931446 +0000
+++ linux-2.6.30-rc3/arch/sh/kernel/cpu/sh4a/setup-sh7723.c	2009-04-22 03:29:16.458931548 +0000
@@ -267,7 +267,6 @@
 static int __init sh7723_devices_setup(void)
 {
 	clk_always_enable("meram0"); /* MERAM */
-	clk_always_enable("rtc0"); /* RTC */
 	clk_always_enable("veu1"); /* VEU2H1 */
 	clk_always_enable("veu0"); /* VEU2H0 */
 	clk_always_enable("vpu0"); /* VPU */
diff -urN linux-2.6.30-rc2/arch/sh/kernel/sys_sh.c linux-2.6.30-rc3/arch/sh/kernel/sys_sh.c
--- linux-2.6.30-rc2/arch/sh/kernel/sys_sh.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/sh/kernel/sys_sh.c	2009-04-22 03:29:16.462559461 +0000
@@ -63,6 +63,15 @@
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
+	/*
+	 * The shift for mmap2 is constant, regardless of PAGE_SIZE
+	 * setting.
+	 */
+	if (pgoff & ((1 << (PAGE_SHIFT - 12)) - 1))
+		return -EINVAL;
+
+	pgoff >>= PAGE_SHIFT - 12;
+
 	return do_mmap2(addr, len, prot, flags, fd, pgoff);
 }
 
diff -urN linux-2.6.30-rc2/arch/sh/kernel/time_32.c linux-2.6.30-rc3/arch/sh/kernel/time_32.c
--- linux-2.6.30-rc2/arch/sh/kernel/time_32.c	2009-04-22 03:29:10.431931406 +0000
+++ linux-2.6.30-rc3/arch/sh/kernel/time_32.c	2009-04-22 03:29:16.462559461 +0000
@@ -208,7 +208,7 @@
 	if (!clocksource_sh.rating)
 		return (unsigned long long)jiffies * (NSEC_PER_SEC / HZ);
 
-	cycles = clocksource_sh.read();
+	cycles = clocksource_sh.read(&clocksource_sh);
 	return cyc2ns(&clocksource_sh, cycles);
 }
 #endif
diff -urN linux-2.6.30-rc2/arch/sh/kernel/timers/timer-tmu.c linux-2.6.30-rc3/arch/sh/kernel/timers/timer-tmu.c
--- linux-2.6.30-rc2/arch/sh/kernel/timers/timer-tmu.c	2009-04-22 03:29:10.432931429 +0000
+++ linux-2.6.30-rc3/arch/sh/kernel/timers/timer-tmu.c	2009-04-22 03:29:16.463931529 +0000
@@ -81,7 +81,7 @@
  */
 static int tmus_are_scaled;
 
-static cycle_t tmu_timer_read(void)
+static cycle_t tmu_timer_read(struct clocksource *cs)
 {
 	return ((cycle_t)(~_tmu_read(TMU1)))<<tmus_are_scaled;
 }
diff -urN linux-2.6.30-rc2/arch/sparc/include/asm/atomic_32.h linux-2.6.30-rc3/arch/sparc/include/asm/atomic_32.h
--- linux-2.6.30-rc2/arch/sparc/include/asm/atomic_32.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/sparc/include/asm/atomic_32.h	2009-04-22 03:29:16.464931399 +0000
@@ -15,6 +15,8 @@
 
 #ifdef __KERNEL__
 
+#include <asm/system.h>
+
 #define ATOMIC_INIT(i)  { (i) }
 
 extern int __atomic_add_return(int, atomic_t *);
diff -urN linux-2.6.30-rc2/arch/sparc/kernel/ldc.c linux-2.6.30-rc3/arch/sparc/kernel/ldc.c
--- linux-2.6.30-rc2/arch/sparc/kernel/ldc.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/sparc/kernel/ldc.c	2009-04-22 03:29:16.467931695 +0000
@@ -1183,8 +1183,7 @@
 	free_queue(lp->tx_num_entries, lp->tx_base);
 
 out_free_mssbuf:
-	if (mssbuf)
-		kfree(mssbuf);
+	kfree(mssbuf);
 
 out_free_iommu:
 	ldc_iommu_release(lp);
@@ -1217,8 +1216,7 @@
 
 	hlist_del(&lp->list);
 
-	if (lp->mssbuf)
-		kfree(lp->mssbuf);
+	kfree(lp->mssbuf);
 
 	ldc_iommu_release(lp);
 
diff -urN linux-2.6.30-rc2/arch/sparc/kernel/smp_64.c linux-2.6.30-rc3/arch/sparc/kernel/smp_64.c
--- linux-2.6.30-rc2/arch/sparc/kernel/smp_64.c	2009-04-22 03:29:10.438556337 +0000
+++ linux-2.6.30-rc3/arch/sparc/kernel/smp_64.c	2009-04-22 03:29:16.470931410 +0000
@@ -118,9 +118,9 @@
 	while (!cpu_isset(cpuid, smp_commenced_mask))
 		rmb();
 
-	ipi_call_lock();
+	ipi_call_lock_irq();
 	cpu_set(cpuid, cpu_online_map);
-	ipi_call_unlock();
+	ipi_call_unlock_irq();
 
 	/* idle thread is expected to have preempt disabled */
 	preempt_disable();
diff -urN linux-2.6.30-rc2/arch/sparc/kernel/sys_sparc32.c linux-2.6.30-rc3/arch/sparc/kernel/sys_sparc32.c
--- linux-2.6.30-rc2/arch/sparc/kernel/sys_sparc32.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/sparc/kernel/sys_sparc32.c	2009-04-22 03:29:16.470931410 +0000
@@ -206,21 +206,12 @@
 		struct compat_stat64 __user * statbuf, int flag)
 {
 	struct kstat stat;
-	int error = -EINVAL;
-
-	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
-		goto out;
-
-	if (flag & AT_SYMLINK_NOFOLLOW)
-		error = vfs_lstat_fd(dfd, filename, &stat);
-	else
-		error = vfs_stat_fd(dfd, filename, &stat);
-
-	if (!error)
-		error = cp_compat_stat64(&stat, statbuf);
+	int error;
 
-out:
-	return error;
+	error = vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_compat_stat64(&stat, statbuf);
 }
 
 asmlinkage long compat_sys_sysfs(int option, u32 arg1, u32 arg2)
diff -urN linux-2.6.30-rc2/arch/sparc/kernel/time_64.c linux-2.6.30-rc3/arch/sparc/kernel/time_64.c
--- linux-2.6.30-rc2/arch/sparc/kernel/time_64.c	2009-04-22 03:29:10.439556321 +0000
+++ linux-2.6.30-rc3/arch/sparc/kernel/time_64.c	2009-04-22 03:29:16.471931411 +0000
@@ -814,6 +814,11 @@
 }
 EXPORT_SYMBOL(udelay);
 
+static cycle_t clocksource_tick_read(struct clocksource *cs)
+{
+	return tick_ops->get_tick();
+}
+
 void __init time_init(void)
 {
 	unsigned long freq = sparc64_init_timers();
@@ -827,7 +832,7 @@
 	clocksource_tick.mult =
 		clocksource_hz2mult(freq,
 				    clocksource_tick.shift);
-	clocksource_tick.read = tick_ops->get_tick;
+	clocksource_tick.read = clocksource_tick_read;
 
 	printk("clocksource: mult[%x] shift[%d]\n",
 	       clocksource_tick.mult, clocksource_tick.shift);
diff -urN linux-2.6.30-rc2/arch/um/Kconfig.rest linux-2.6.30-rc3/arch/um/Kconfig.rest
--- linux-2.6.30-rc2/arch/um/Kconfig.rest	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/um/Kconfig.rest	2009-04-22 03:29:16.472931665 +0000
@@ -36,7 +36,7 @@
 
 #This is just to shut up some Kconfig warnings, so no prompt.
 config INPUT
-	bool
+	tristate
 	default n
 
 source "arch/um/Kconfig.debug"
diff -urN linux-2.6.30-rc2/arch/um/kernel/time.c linux-2.6.30-rc3/arch/um/kernel/time.c
--- linux-2.6.30-rc2/arch/um/kernel/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/um/kernel/time.c	2009-04-22 03:29:16.474556356 +0000
@@ -65,7 +65,7 @@
 	return IRQ_HANDLED;
 }
 
-static cycle_t itimer_read(void)
+static cycle_t itimer_read(struct clocksource *cs)
 {
 	return os_nsecs() / 1000;
 }
diff -urN linux-2.6.30-rc2/arch/x86/Kconfig linux-2.6.30-rc3/arch/x86/Kconfig
--- linux-2.6.30-rc2/arch/x86/Kconfig	2009-04-22 03:29:10.445931496 +0000
+++ linux-2.6.30-rc3/arch/x86/Kconfig	2009-04-22 03:29:16.477931449 +0000
@@ -353,6 +353,7 @@
 	bool "SGI Ultraviolet"
 	depends on X86_64
 	depends on X86_EXTENDED_PLATFORM
+	depends on NUMA
 	select X86_X2APIC
 	---help---
 	  This option is needed in order to support SGI Ultraviolet systems.
diff -urN linux-2.6.30-rc2/arch/x86/Kconfig.cpu linux-2.6.30-rc3/arch/x86/Kconfig.cpu
--- linux-2.6.30-rc2/arch/x86/Kconfig.cpu	2009-04-22 03:29:10.446931420 +0000
+++ linux-2.6.30-rc3/arch/x86/Kconfig.cpu	2009-04-22 03:29:16.477931449 +0000
@@ -506,6 +506,7 @@
 	bool "Branch Trace Store"
 	default y
 	depends on X86_DEBUGCTLMSR
+	depends on BROKEN
 	---help---
 	  This adds a ptrace interface to the hardware's branch trace store.
 
diff -urN linux-2.6.30-rc2/arch/x86/ia32/sys_ia32.c linux-2.6.30-rc3/arch/x86/ia32/sys_ia32.c
--- linux-2.6.30-rc2/arch/x86/ia32/sys_ia32.c	2009-04-22 03:29:10.453931381 +0000
+++ linux-2.6.30-rc3/arch/x86/ia32/sys_ia32.c	2009-04-22 03:29:16.485931415 +0000
@@ -129,21 +129,12 @@
 			      struct stat64 __user *statbuf, int flag)
 {
 	struct kstat stat;
-	int error = -EINVAL;
+	int error;
 
-	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
-		goto out;
-
-	if (flag & AT_SYMLINK_NOFOLLOW)
-		error = vfs_lstat_fd(dfd, filename, &stat);
-	else
-		error = vfs_stat_fd(dfd, filename, &stat);
-
-	if (!error)
-		error = cp_stat64(statbuf, &stat);
-
-out:
-	return error;
+	error = vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_stat64(statbuf, &stat);
 }
 
 /*
diff -urN linux-2.6.30-rc2/arch/x86/include/asm/desc.h linux-2.6.30-rc3/arch/x86/include/asm/desc.h
--- linux-2.6.30-rc2/arch/x86/include/asm/desc.h	2009-04-22 03:29:10.456931402 +0000
+++ linux-2.6.30-rc3/arch/x86/include/asm/desc.h	2009-04-22 03:29:16.488931480 +0000
@@ -37,7 +37,7 @@
 struct gdt_page {
 	struct desc_struct gdt[GDT_ENTRIES];
 } __attribute__((aligned(PAGE_SIZE)));
-DECLARE_PER_CPU(struct gdt_page, gdt_page);
+DECLARE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page);
 
 static inline struct desc_struct *get_cpu_gdt_table(unsigned int cpu)
 {
diff -urN linux-2.6.30-rc2/arch/x86/include/asm/hardirq.h linux-2.6.30-rc3/arch/x86/include/asm/hardirq.h
--- linux-2.6.30-rc2/arch/x86/include/asm/hardirq.h	2009-04-22 03:29:10.459931419 +0000
+++ linux-2.6.30-rc3/arch/x86/include/asm/hardirq.h	2009-04-22 03:29:16.491931221 +0000
@@ -26,7 +26,7 @@
 #endif
 } ____cacheline_aligned irq_cpustat_t;
 
-DECLARE_PER_CPU(irq_cpustat_t, irq_stat);
+DECLARE_PER_CPU_SHARED_ALIGNED(irq_cpustat_t, irq_stat);
 
 /* We can have at most NR_VECTORS irqs routed to a cpu at a time */
 #define MAX_HARDIRQS_PER_CPU NR_VECTORS
diff -urN linux-2.6.30-rc2/arch/x86/include/asm/lguest_hcall.h linux-2.6.30-rc3/arch/x86/include/asm/lguest_hcall.h
--- linux-2.6.30-rc2/arch/x86/include/asm/lguest_hcall.h	2009-04-22 03:29:10.463658163 +0000
+++ linux-2.6.30-rc3/arch/x86/include/asm/lguest_hcall.h	2009-04-22 03:29:16.494931421 +0000
@@ -5,7 +5,6 @@
 #define LHCALL_FLUSH_ASYNC	0
 #define LHCALL_LGUEST_INIT	1
 #define LHCALL_SHUTDOWN		2
-#define LHCALL_LOAD_GDT		3
 #define LHCALL_NEW_PGTABLE	4
 #define LHCALL_FLUSH_TLB	5
 #define LHCALL_LOAD_IDT_ENTRY	6
@@ -17,6 +16,7 @@
 #define LHCALL_SET_PMD		15
 #define LHCALL_LOAD_TLS		16
 #define LHCALL_NOTIFY		17
+#define LHCALL_LOAD_GDT_ENTRY	18
 
 #define LGUEST_TRAP_ENTRY 0x1F
 
diff -urN linux-2.6.30-rc2/arch/x86/include/asm/pat.h linux-2.6.30-rc3/arch/x86/include/asm/pat.h
--- linux-2.6.30-rc2/arch/x86/include/asm/pat.h	2009-04-22 03:29:10.471931515 +0000
+++ linux-2.6.30-rc3/arch/x86/include/asm/pat.h	2009-04-22 03:29:16.504931475 +0000
@@ -18,9 +18,5 @@
 
 extern int kernel_map_sync_memtype(u64 base, unsigned long size,
 		unsigned long flag);
-extern void map_devmem(unsigned long pfn, unsigned long size,
-		       struct pgprot vma_prot);
-extern void unmap_devmem(unsigned long pfn, unsigned long size,
-			 struct pgprot vma_prot);
 
 #endif /* _ASM_X86_PAT_H */
diff -urN linux-2.6.30-rc2/arch/x86/include/asm/processor.h linux-2.6.30-rc3/arch/x86/include/asm/processor.h
--- linux-2.6.30-rc2/arch/x86/include/asm/processor.h	2009-04-22 03:29:10.475556413 +0000
+++ linux-2.6.30-rc3/arch/x86/include/asm/processor.h	2009-04-22 03:29:16.507931552 +0000
@@ -138,7 +138,7 @@
 extern __u32			cleared_cpu_caps[NCAPINTS];
 
 #ifdef CONFIG_SMP
-DECLARE_PER_CPU(struct cpuinfo_x86, cpu_info);
+DECLARE_PER_CPU_SHARED_ALIGNED(struct cpuinfo_x86, cpu_info);
 #define cpu_data(cpu)		per_cpu(cpu_info, cpu)
 #define current_cpu_data	__get_cpu_var(cpu_info)
 #else
@@ -270,7 +270,7 @@
 
 } ____cacheline_aligned;
 
-DECLARE_PER_CPU(struct tss_struct, init_tss);
+DECLARE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss);
 
 /*
  * Save the original ist values for checking stack pointers during debugging
@@ -393,7 +393,7 @@
 	};
 };
 
-DECLARE_PER_CPU(union irq_stack_union, irq_stack_union);
+DECLARE_PER_CPU_FIRST(union irq_stack_union, irq_stack_union);
 DECLARE_INIT_PER_CPU(irq_stack_union);
 
 DECLARE_PER_CPU(char *, irq_stack_ptr);
diff -urN linux-2.6.30-rc2/arch/x86/include/asm/tlbflush.h linux-2.6.30-rc3/arch/x86/include/asm/tlbflush.h
--- linux-2.6.30-rc2/arch/x86/include/asm/tlbflush.h	2009-04-22 03:29:10.478931581 +0000
+++ linux-2.6.30-rc3/arch/x86/include/asm/tlbflush.h	2009-04-22 03:29:16.511931415 +0000
@@ -152,7 +152,7 @@
 	struct mm_struct *active_mm;
 	int state;
 };
-DECLARE_PER_CPU(struct tlb_state, cpu_tlbstate);
+DECLARE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate);
 
 static inline void reset_lazy_tlbstate(void)
 {
diff -urN linux-2.6.30-rc2/arch/x86/include/asm/uv/uv_mmrs.h linux-2.6.30-rc3/arch/x86/include/asm/uv/uv_mmrs.h
--- linux-2.6.30-rc2/arch/x86/include/asm/uv/uv_mmrs.h	2009-04-22 03:29:10.480931422 +0000
+++ linux-2.6.30-rc3/arch/x86/include/asm/uv/uv_mmrs.h	2009-04-22 03:29:16.513931490 +0000
@@ -17,6 +17,11 @@
 /* ========================================================================= */
 /*                           UVH_BAU_DATA_CONFIG                             */
 /* ========================================================================= */
+#define UVH_LB_BAU_MISC_CONTROL 0x320170UL
+#define UV_ENABLE_INTD_SOFT_ACK_MODE_SHIFT 15
+#define UV_INTD_SOFT_ACK_TIMEOUT_PERIOD_SHIFT 16
+#define UV_INTD_SOFT_ACK_TIMEOUT_PERIOD 0x000000000bUL
+/* 1011 timebase 7 (168millisec) * 3 ticks -> 500ms */
 #define UVH_BAU_DATA_CONFIG 0x61680UL
 #define UVH_BAU_DATA_CONFIG_32 0x0438
 
diff -urN linux-2.6.30-rc2/arch/x86/kernel/apic/x2apic_uv_x.c linux-2.6.30-rc3/arch/x86/kernel/apic/x2apic_uv_x.c
--- linux-2.6.30-rc2/arch/x86/kernel/apic/x2apic_uv_x.c	2009-04-22 03:29:10.491931454 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/apic/x2apic_uv_x.c	2009-04-22 03:29:16.523931433 +0000
@@ -549,7 +549,8 @@
 	unsigned long gnode_upper, lowmem_redir_base, lowmem_redir_size;
 	int bytes, nid, cpu, lcpu, pnode, blade, i, j, m_val, n_val;
 	int max_pnode = 0;
-	unsigned long mmr_base, present;
+	unsigned long mmr_base, present, paddr;
+	unsigned short pnode_mask;
 
 	map_low_mmrs();
 
@@ -592,6 +593,7 @@
 		}
 	}
 
+	pnode_mask = (1 << n_val) - 1;
 	node_id.v = uv_read_local_mmr(UVH_NODE_ID);
 	gnode_upper = (((unsigned long)node_id.s.node_id) &
 		       ~((1 << n_val) - 1)) << m_val;
@@ -615,7 +617,7 @@
 		uv_cpu_hub_info(cpu)->numa_blade_id = blade;
 		uv_cpu_hub_info(cpu)->blade_processor_id = lcpu;
 		uv_cpu_hub_info(cpu)->pnode = pnode;
-		uv_cpu_hub_info(cpu)->pnode_mask = (1 << n_val) - 1;
+		uv_cpu_hub_info(cpu)->pnode_mask = pnode_mask;
 		uv_cpu_hub_info(cpu)->gpa_mask = (1 << (m_val + n_val)) - 1;
 		uv_cpu_hub_info(cpu)->gnode_upper = gnode_upper;
 		uv_cpu_hub_info(cpu)->global_mmr_base = mmr_base;
@@ -631,6 +633,16 @@
 			lcpu, blade);
 	}
 
+	/* Add blade/pnode info for nodes without cpus */
+	for_each_online_node(nid) {
+		if (uv_node_to_blade[nid] >= 0)
+			continue;
+		paddr = node_start_pfn(nid) << PAGE_SHIFT;
+		pnode = (paddr >> m_val) & pnode_mask;
+		blade = boot_pnode_to_blade(pnode);
+		uv_node_to_blade[nid] = blade;
+	}
+
 	map_gru_high(max_pnode);
 	map_mmr_high(max_pnode);
 	map_config_high(max_pnode);
diff -urN linux-2.6.30-rc2/arch/x86/kernel/bios_uv.c linux-2.6.30-rc3/arch/x86/kernel/bios_uv.c
--- linux-2.6.30-rc2/arch/x86/kernel/bios_uv.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/bios_uv.c	2009-04-22 03:29:16.525931205 +0000
@@ -182,7 +182,8 @@
 	memcpy(&uv_systab, tab, sizeof(struct uv_systab));
 	iounmap(tab);
 
-	printk(KERN_INFO "EFI UV System Table Revision %d\n", tab->revision);
+	printk(KERN_INFO "EFI UV System Table Revision %d\n",
+					uv_systab.revision);
 }
 #else	/* !CONFIG_EFI */
 
diff -urN linux-2.6.30-rc2/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c linux-2.6.30-rc3/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c
--- linux-2.6.30-rc2/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c	2009-04-22 03:29:10.495931395 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c	2009-04-22 03:29:16.528579721 +0000
@@ -204,7 +204,13 @@
 
 static void drv_write(struct drv_cmd *cmd)
 {
+	int this_cpu;
+
+	this_cpu = get_cpu();
+	if (cpumask_test_cpu(this_cpu, cmd->mask))
+		do_drv_write(cmd);
 	smp_call_function_many(cmd->mask, do_drv_write, cmd, 1);
+	put_cpu();
 }
 
 static u32 get_cur_val(const struct cpumask *mask)
diff -urN linux-2.6.30-rc2/arch/x86/kernel/hpet.c linux-2.6.30-rc3/arch/x86/kernel/hpet.c
--- linux-2.6.30-rc2/arch/x86/kernel/hpet.c	2009-04-22 03:29:10.511931390 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/hpet.c	2009-04-22 03:29:16.544931250 +0000
@@ -722,7 +722,7 @@
 /*
  * Clock source related code
  */
-static cycle_t read_hpet(void)
+static cycle_t read_hpet(struct clocksource *cs)
 {
 	return (cycle_t)hpet_readl(HPET_COUNTER);
 }
@@ -756,7 +756,7 @@
 	hpet_restart_counter();
 
 	/* Verify whether hpet counter works */
-	t1 = read_hpet();
+	t1 = hpet_readl(HPET_COUNTER);
 	rdtscll(start);
 
 	/*
@@ -770,7 +770,7 @@
 		rdtscll(now);
 	} while ((now - start) < 200000UL);
 
-	if (t1 == read_hpet()) {
+	if (t1 == hpet_readl(HPET_COUNTER)) {
 		printk(KERN_WARNING
 		       "HPET counter not counting. HPET disabled\n");
 		return -ENODEV;
diff -urN linux-2.6.30-rc2/arch/x86/kernel/i8253.c linux-2.6.30-rc3/arch/x86/kernel/i8253.c
--- linux-2.6.30-rc2/arch/x86/kernel/i8253.c	2009-04-22 03:29:10.511931390 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/i8253.c	2009-04-22 03:29:16.544931250 +0000
@@ -129,7 +129,7 @@
  * to just read by itself. So use jiffies to emulate a free
  * running counter:
  */
-static cycle_t pit_read(void)
+static cycle_t pit_read(struct clocksource *cs)
 {
 	static int old_count;
 	static u32 old_jifs;
diff -urN linux-2.6.30-rc2/arch/x86/kernel/kvmclock.c linux-2.6.30-rc3/arch/x86/kernel/kvmclock.c
--- linux-2.6.30-rc2/arch/x86/kernel/kvmclock.c	2009-04-22 03:29:10.516931417 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/kvmclock.c	2009-04-22 03:29:16.549931241 +0000
@@ -77,6 +77,11 @@
 	return ret;
 }
 
+static cycle_t kvm_clock_get_cycles(struct clocksource *cs)
+{
+	return kvm_clock_read();
+}
+
 /*
  * If we don't do that, there is the possibility that the guest
  * will calibrate under heavy load - thus, getting a lower lpj -
@@ -107,7 +112,7 @@
 
 static struct clocksource kvm_clock = {
 	.name = "kvm-clock",
-	.read = kvm_clock_read,
+	.read = kvm_clock_get_cycles,
 	.rating = 400,
 	.mask = CLOCKSOURCE_MASK(64),
 	.mult = 1 << KVM_SCALE,
diff -urN linux-2.6.30-rc2/arch/x86/kernel/microcode_core.c linux-2.6.30-rc3/arch/x86/kernel/microcode_core.c
--- linux-2.6.30-rc2/arch/x86/kernel/microcode_core.c	2009-04-22 03:29:10.517931437 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/microcode_core.c	2009-04-22 03:29:16.550931447 +0000
@@ -380,8 +380,6 @@
 		return err;
 
 	err = microcode_init_cpu(cpu);
-	if (err)
-		sysfs_remove_group(&sys_dev->kobj, &mc_attr_group);
 
 	return err;
 }
diff -urN linux-2.6.30-rc2/arch/x86/kernel/pci-swiotlb.c linux-2.6.30-rc3/arch/x86/kernel/pci-swiotlb.c
--- linux-2.6.30-rc2/arch/x86/kernel/pci-swiotlb.c	2009-04-22 03:29:10.521931432 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/pci-swiotlb.c	2009-04-22 03:29:16.554894701 +0000
@@ -50,7 +50,7 @@
 	return swiotlb_alloc_coherent(hwdev, size, dma_handle, flags);
 }
 
-struct dma_map_ops swiotlb_dma_ops = {
+static struct dma_map_ops swiotlb_dma_ops = {
 	.mapping_error = swiotlb_dma_mapping_error,
 	.alloc_coherent = x86_swiotlb_alloc_coherent,
 	.free_coherent = swiotlb_free_coherent,
diff -urN linux-2.6.30-rc2/arch/x86/kernel/tlb_uv.c linux-2.6.30-rc3/arch/x86/kernel/tlb_uv.c
--- linux-2.6.30-rc2/arch/x86/kernel/tlb_uv.c	2009-04-22 03:29:10.527556562 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/tlb_uv.c	2009-04-22 03:29:16.561912146 +0000
@@ -25,6 +25,8 @@
 
 /* position of pnode (which is nasid>>1): */
 static int			uv_nshift __read_mostly;
+/* base pnode in this partition */
+static int			uv_partition_base_pnode __read_mostly;
 
 static unsigned long		uv_mmask __read_mostly;
 
@@ -32,6 +34,34 @@
 static DEFINE_PER_CPU(struct bau_control, bau_control);
 
 /*
+ * Determine the first node on a blade.
+ */
+static int __init blade_to_first_node(int blade)
+{
+	int node, b;
+
+	for_each_online_node(node) {
+		b = uv_node_to_blade_id(node);
+		if (blade == b)
+			return node;
+	}
+	return -1; /* shouldn't happen */
+}
+
+/*
+ * Determine the apicid of the first cpu on a blade.
+ */
+static int __init blade_to_first_apicid(int blade)
+{
+	int cpu;
+
+	for_each_present_cpu(cpu)
+		if (blade == uv_cpu_to_blade_id(cpu))
+			return per_cpu(x86_cpu_to_apicid, cpu);
+	return -1;
+}
+
+/*
  * Free a software acknowledge hardware resource by clearing its Pending
  * bit. This will return a reply to the sender.
  * If the message has timed out, a reply has already been sent by the
@@ -67,7 +97,7 @@
 	msp = __get_cpu_var(bau_control).msg_statuses + msg_slot;
 	cpu = uv_blade_processor_id();
 	msg->number_of_cpus =
-	    uv_blade_nr_online_cpus(uv_node_to_blade_id(numa_node_id()));
+		uv_blade_nr_online_cpus(uv_node_to_blade_id(numa_node_id()));
 	this_cpu_mask = 1UL << cpu;
 	if (msp->seen_by.bits & this_cpu_mask)
 		return;
@@ -215,14 +245,14 @@
  * Returns @flush_mask if some remote flushing remains to be done. The
  * mask will have some bits still set.
  */
-const struct cpumask *uv_flush_send_and_wait(int cpu, int this_blade,
+const struct cpumask *uv_flush_send_and_wait(int cpu, int this_pnode,
 					     struct bau_desc *bau_desc,
 					     struct cpumask *flush_mask)
 {
 	int completion_status = 0;
 	int right_shift;
 	int tries = 0;
-	int blade;
+	int pnode;
 	int bit;
 	unsigned long mmr_offset;
 	unsigned long index;
@@ -265,8 +295,8 @@
 	 * use the IPI method of shootdown on them.
 	 */
 	for_each_cpu(bit, flush_mask) {
-		blade = uv_cpu_to_blade_id(bit);
-		if (blade == this_blade)
+		pnode = uv_cpu_to_pnode(bit);
+		if (pnode == this_pnode)
 			continue;
 		cpumask_clear_cpu(bit, flush_mask);
 	}
@@ -309,16 +339,16 @@
 	struct cpumask *flush_mask = __get_cpu_var(uv_flush_tlb_mask);
 	int i;
 	int bit;
-	int blade;
+	int pnode;
 	int uv_cpu;
-	int this_blade;
+	int this_pnode;
 	int locals = 0;
 	struct bau_desc *bau_desc;
 
 	cpumask_andnot(flush_mask, cpumask, cpumask_of(cpu));
 
 	uv_cpu = uv_blade_processor_id();
-	this_blade = uv_numa_blade_id();
+	this_pnode = uv_hub_info->pnode;
 	bau_desc = __get_cpu_var(bau_control).descriptor_base;
 	bau_desc += UV_ITEMS_PER_DESCRIPTOR * uv_cpu;
 
@@ -326,13 +356,14 @@
 
 	i = 0;
 	for_each_cpu(bit, flush_mask) {
-		blade = uv_cpu_to_blade_id(bit);
-		BUG_ON(blade > (UV_DISTRIBUTION_SIZE - 1));
-		if (blade == this_blade) {
+		pnode = uv_cpu_to_pnode(bit);
+		BUG_ON(pnode > (UV_DISTRIBUTION_SIZE - 1));
+		if (pnode == this_pnode) {
 			locals++;
 			continue;
 		}
-		bau_node_set(blade, &bau_desc->distribution);
+		bau_node_set(pnode - uv_partition_base_pnode,
+				&bau_desc->distribution);
 		i++;
 	}
 	if (i == 0) {
@@ -350,7 +381,7 @@
 	bau_desc->payload.address = va;
 	bau_desc->payload.sending_cpu = cpu;
 
-	return uv_flush_send_and_wait(uv_cpu, this_blade, bau_desc, flush_mask);
+	return uv_flush_send_and_wait(uv_cpu, this_pnode, bau_desc, flush_mask);
 }
 
 /*
@@ -418,24 +449,58 @@
 	set_irq_regs(old_regs);
 }
 
+/*
+ * uv_enable_timeouts
+ *
+ * Each target blade (i.e. blades that have cpu's) needs to have
+ * shootdown message timeouts enabled.  The timeout does not cause
+ * an interrupt, but causes an error message to be returned to
+ * the sender.
+ */
 static void uv_enable_timeouts(void)
 {
-	int i;
 	int blade;
-	int last_blade;
+	int nblades;
 	int pnode;
-	int cur_cpu = 0;
-	unsigned long apicid;
+	unsigned long mmr_image;
 
-	last_blade = -1;
-	for_each_online_node(i) {
-		blade = uv_node_to_blade_id(i);
-		if (blade == last_blade)
+	nblades = uv_num_possible_blades();
+
+	for (blade = 0; blade < nblades; blade++) {
+		if (!uv_blade_nr_possible_cpus(blade))
 			continue;
-		last_blade = blade;
-		apicid = per_cpu(x86_cpu_to_apicid, cur_cpu);
+
 		pnode = uv_blade_to_pnode(blade);
-		cur_cpu += uv_blade_nr_possible_cpus(i);
+		mmr_image =
+		    uv_read_global_mmr64(pnode, UVH_LB_BAU_MISC_CONTROL);
+		/*
+		 * Set the timeout period and then lock it in, in three
+		 * steps; captures and locks in the period.
+		 *
+		 * To program the period, the SOFT_ACK_MODE must be off.
+		 */
+		mmr_image &= ~((unsigned long)1 <<
+			       UV_ENABLE_INTD_SOFT_ACK_MODE_SHIFT);
+		uv_write_global_mmr64
+		    (pnode, UVH_LB_BAU_MISC_CONTROL, mmr_image);
+		/*
+		 * Set the 4-bit period.
+		 */
+		mmr_image &= ~((unsigned long)0xf <<
+			UV_INTD_SOFT_ACK_TIMEOUT_PERIOD_SHIFT);
+		mmr_image |= (UV_INTD_SOFT_ACK_TIMEOUT_PERIOD <<
+			     UV_INTD_SOFT_ACK_TIMEOUT_PERIOD_SHIFT);
+		uv_write_global_mmr64
+		    (pnode, UVH_LB_BAU_MISC_CONTROL, mmr_image);
+		/*
+		 * Subsequent reversals of the timebase bit (3) cause an
+		 * immediate timeout of one or all INTD resources as
+		 * indicated in bits 2:0 (7 causes all of them to timeout).
+		 */
+		mmr_image |= ((unsigned long)1 <<
+			      UV_ENABLE_INTD_SOFT_ACK_MODE_SHIFT);
+		uv_write_global_mmr64
+		    (pnode, UVH_LB_BAU_MISC_CONTROL, mmr_image);
 	}
 }
 
@@ -482,8 +547,7 @@
 			   stat->requestee, stat->onetlb, stat->alltlb,
 			   stat->s_retry, stat->d_retry, stat->ptc_i);
 		seq_printf(file, "%lx %ld %ld %ld %ld %ld %ld\n",
-			   uv_read_global_mmr64(uv_blade_to_pnode
-					(uv_cpu_to_blade_id(cpu)),
+			   uv_read_global_mmr64(uv_cpu_to_pnode(cpu),
 					UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE),
 			   stat->sflush, stat->dflush,
 			   stat->retriesok, stat->nomsg,
@@ -617,16 +681,18 @@
  * finish the initialization of the per-blade control structures
  */
 static void __init
-uv_table_bases_finish(int blade, int node, int cur_cpu,
+uv_table_bases_finish(int blade,
 		      struct bau_control *bau_tablesp,
 		      struct bau_desc *adp)
 {
 	struct bau_control *bcp;
-	int i;
+	int cpu;
 
-	for (i = cur_cpu; i < cur_cpu + uv_blade_nr_possible_cpus(blade); i++) {
-		bcp = (struct bau_control *)&per_cpu(bau_control, i);
+	for_each_present_cpu(cpu) {
+		if (blade != uv_cpu_to_blade_id(cpu))
+			continue;
 
+		bcp = (struct bau_control *)&per_cpu(bau_control, cpu);
 		bcp->bau_msg_head	= bau_tablesp->va_queue_first;
 		bcp->va_queue_first	= bau_tablesp->va_queue_first;
 		bcp->va_queue_last	= bau_tablesp->va_queue_last;
@@ -649,11 +715,10 @@
 	struct bau_desc *adp;
 	struct bau_desc *ad2;
 
-	adp = (struct bau_desc *)
-	    kmalloc_node(16384, GFP_KERNEL, node);
+	adp = (struct bau_desc *)kmalloc_node(16384, GFP_KERNEL, node);
 	BUG_ON(!adp);
 
-	pa = __pa((unsigned long)adp);
+	pa = uv_gpa(adp); /* need the real nasid*/
 	n = pa >> uv_nshift;
 	m = pa & uv_mmask;
 
@@ -667,8 +732,12 @@
 	for (i = 0, ad2 = adp; i < UV_ACTIVATION_DESCRIPTOR_SIZE; i++, ad2++) {
 		memset(ad2, 0, sizeof(struct bau_desc));
 		ad2->header.sw_ack_flag = 1;
-		ad2->header.base_dest_nodeid =
-		    uv_blade_to_pnode(uv_cpu_to_blade_id(0));
+		/*
+		 * base_dest_nodeid is the first node in the partition, so
+		 * the bit map will indicate partition-relative node numbers.
+		 * note that base_dest_nodeid is actually a nasid.
+		 */
+		ad2->header.base_dest_nodeid = uv_partition_base_pnode << 1;
 		ad2->header.command = UV_NET_ENDPOINT_INTD;
 		ad2->header.int_both = 1;
 		/*
@@ -686,6 +755,8 @@
 uv_payload_queue_init(int node, int pnode, struct bau_control *bau_tablesp)
 {
 	struct bau_payload_queue_entry *pqp;
+	unsigned long pa;
+	int pn;
 	char *cp;
 
 	pqp = (struct bau_payload_queue_entry *) kmalloc_node(
@@ -696,10 +767,14 @@
 	cp = (char *)pqp + 31;
 	pqp = (struct bau_payload_queue_entry *)(((unsigned long)cp >> 5) << 5);
 	bau_tablesp->va_queue_first = pqp;
+	/*
+	 * need the pnode of where the memory was really allocated
+	 */
+	pa = uv_gpa(pqp);
+	pn = pa >> uv_nshift;
 	uv_write_global_mmr64(pnode,
 			      UVH_LB_BAU_INTD_PAYLOAD_QUEUE_FIRST,
-			      ((unsigned long)pnode <<
-			       UV_PAYLOADQ_PNODE_SHIFT) |
+			      ((unsigned long)pn << UV_PAYLOADQ_PNODE_SHIFT) |
 			      uv_physnodeaddr(pqp));
 	uv_write_global_mmr64(pnode, UVH_LB_BAU_INTD_PAYLOAD_QUEUE_TAIL,
 			      uv_physnodeaddr(pqp));
@@ -715,8 +790,9 @@
 /*
  * Initialization of each UV blade's structures
  */
-static int __init uv_init_blade(int blade, int node, int cur_cpu)
+static int __init uv_init_blade(int blade)
 {
+	int node;
 	int pnode;
 	unsigned long pa;
 	unsigned long apicid;
@@ -724,16 +800,17 @@
 	struct bau_payload_queue_entry *pqp;
 	struct bau_control *bau_tablesp;
 
+	node = blade_to_first_node(blade);
 	bau_tablesp = uv_table_bases_init(blade, node);
 	pnode = uv_blade_to_pnode(blade);
 	adp = uv_activation_descriptor_init(node, pnode);
 	pqp = uv_payload_queue_init(node, pnode, bau_tablesp);
-	uv_table_bases_finish(blade, node, cur_cpu, bau_tablesp, adp);
+	uv_table_bases_finish(blade, bau_tablesp, adp);
 	/*
 	 * the below initialization can't be in firmware because the
 	 * messaging IRQ will be determined by the OS
 	 */
-	apicid = per_cpu(x86_cpu_to_apicid, cur_cpu);
+	apicid = blade_to_first_apicid(blade);
 	pa = uv_read_global_mmr64(pnode, UVH_BAU_DATA_CONFIG);
 	if ((pa & 0xff) != UV_BAU_MESSAGE) {
 		uv_write_global_mmr64(pnode, UVH_BAU_DATA_CONFIG,
@@ -748,9 +825,7 @@
 static int __init uv_bau_init(void)
 {
 	int blade;
-	int node;
 	int nblades;
-	int last_blade;
 	int cur_cpu;
 
 	if (!is_uv_system())
@@ -763,29 +838,21 @@
 	uv_bau_retry_limit = 1;
 	uv_nshift = uv_hub_info->n_val;
 	uv_mmask = (1UL << uv_hub_info->n_val) - 1;
-	nblades = 0;
-	last_blade = -1;
-	cur_cpu = 0;
-	for_each_online_node(node) {
-		blade = uv_node_to_blade_id(node);
-		if (blade == last_blade)
-			continue;
-		last_blade = blade;
-		nblades++;
-	}
+	nblades = uv_num_possible_blades();
+
 	uv_bau_table_bases = (struct bau_control **)
 	    kmalloc(nblades * sizeof(struct bau_control *), GFP_KERNEL);
 	BUG_ON(!uv_bau_table_bases);
 
-	last_blade = -1;
-	for_each_online_node(node) {
-		blade = uv_node_to_blade_id(node);
-		if (blade == last_blade)
-			continue;
-		last_blade = blade;
-		uv_init_blade(blade, node, cur_cpu);
-		cur_cpu += uv_blade_nr_possible_cpus(blade);
-	}
+	uv_partition_base_pnode = 0x7fffffff;
+	for (blade = 0; blade < nblades; blade++)
+		if (uv_blade_nr_possible_cpus(blade) &&
+			(uv_blade_to_pnode(blade) < uv_partition_base_pnode))
+			uv_partition_base_pnode = uv_blade_to_pnode(blade);
+	for (blade = 0; blade < nblades; blade++)
+		if (uv_blade_nr_possible_cpus(blade))
+			uv_init_blade(blade);
+
 	alloc_intr_gate(UV_BAU_MESSAGE, uv_bau_message_intr1);
 	uv_enable_timeouts();
 
diff -urN linux-2.6.30-rc2/arch/x86/kernel/tsc.c linux-2.6.30-rc3/arch/x86/kernel/tsc.c
--- linux-2.6.30-rc2/arch/x86/kernel/tsc.c	2009-04-22 03:29:10.528931453 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/tsc.c	2009-04-22 03:29:16.562931467 +0000
@@ -699,7 +699,7 @@
  * code, which is necessary to support wrapping clocksources like pm
  * timer.
  */
-static cycle_t read_tsc(void)
+static cycle_t read_tsc(struct clocksource *cs)
 {
 	cycle_t ret = (cycle_t)get_cycles();
 
diff -urN linux-2.6.30-rc2/arch/x86/kernel/uv_sysfs.c linux-2.6.30-rc3/arch/x86/kernel/uv_sysfs.c
--- linux-2.6.30-rc2/arch/x86/kernel/uv_sysfs.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/uv_sysfs.c	2009-04-22 03:29:16.562931467 +0000
@@ -21,6 +21,7 @@
 
 #include <linux/sysdev.h>
 #include <asm/uv/bios.h>
+#include <asm/uv/uv.h>
 
 struct kobject *sgi_uv_kobj;
 
@@ -47,6 +48,9 @@
 {
 	unsigned long ret;
 
+	if (!is_uv_system())
+		return -ENODEV;
+
 	if (!sgi_uv_kobj)
 		sgi_uv_kobj = kobject_create_and_add("sgi_uv", firmware_kobj);
 	if (!sgi_uv_kobj) {
diff -urN linux-2.6.30-rc2/arch/x86/kernel/vmiclock_32.c linux-2.6.30-rc3/arch/x86/kernel/vmiclock_32.c
--- linux-2.6.30-rc2/arch/x86/kernel/vmiclock_32.c	2009-04-22 03:29:10.529931571 +0000
+++ linux-2.6.30-rc3/arch/x86/kernel/vmiclock_32.c	2009-04-22 03:29:16.563931406 +0000
@@ -283,7 +283,7 @@
 /** vmi clocksource */
 static struct clocksource clocksource_vmi;
 
-static cycle_t read_real_cycles(void)
+static cycle_t read_real_cycles(struct clocksource *cs)
 {
 	cycle_t ret = (cycle_t)vmi_timer_ops.get_cycle_counter(VMI_CYCLES_REAL);
 	return max(ret, clocksource_vmi.cycle_last);
diff -urN linux-2.6.30-rc2/arch/x86/lguest/boot.c linux-2.6.30-rc3/arch/x86/lguest/boot.c
--- linux-2.6.30-rc2/arch/x86/lguest/boot.c	2009-04-22 03:29:10.536931296 +0000
+++ linux-2.6.30-rc3/arch/x86/lguest/boot.c	2009-04-22 03:29:16.570931421 +0000
@@ -273,15 +273,15 @@
  * controls the entire thing and the Guest asks it to make changes using the
  * LOAD_GDT hypercall.
  *
- * This is the opposite of the IDT code where we have a LOAD_IDT_ENTRY
- * hypercall and use that repeatedly to load a new IDT.  I don't think it
- * really matters, but wouldn't it be nice if they were the same?  Wouldn't
- * it be even better if you were the one to send the patch to fix it?
+ * This is the exactly like the IDT code.
  */
 static void lguest_load_gdt(const struct desc_ptr *desc)
 {
-	BUG_ON((desc->size + 1) / 8 != GDT_ENTRIES);
-	kvm_hypercall2(LHCALL_LOAD_GDT, __pa(desc->address), GDT_ENTRIES);
+	unsigned int i;
+	struct desc_struct *gdt = (void *)desc->address;
+
+	for (i = 0; i < (desc->size+1)/8; i++)
+		kvm_hypercall3(LHCALL_LOAD_GDT_ENTRY, i, gdt[i].a, gdt[i].b);
 }
 
 /* For a single GDT entry which changes, we do the lazy thing: alter our GDT,
@@ -291,7 +291,9 @@
 				   const void *desc, int type)
 {
 	native_write_gdt_entry(dt, entrynum, desc, type);
-	kvm_hypercall2(LHCALL_LOAD_GDT, __pa(dt), GDT_ENTRIES);
+	/* Tell Host about this new entry. */
+	kvm_hypercall3(LHCALL_LOAD_GDT_ENTRY, entrynum,
+		       dt[entrynum].a, dt[entrynum].b);
 }
 
 /* OK, I lied.  There are three "thread local storage" GDT entries which change
@@ -661,7 +663,7 @@
 
 /* If we can't use the TSC, the kernel falls back to our lower-priority
  * "lguest_clock", where we read the time value given to us by the Host. */
-static cycle_t lguest_clock_read(void)
+static cycle_t lguest_clock_read(struct clocksource *cs)
 {
 	unsigned long sec, nsec;
 
diff -urN linux-2.6.30-rc2/arch/x86/mm/ioremap.c linux-2.6.30-rc3/arch/x86/mm/ioremap.c
--- linux-2.6.30-rc2/arch/x86/mm/ioremap.c	2009-04-22 03:29:10.545931416 +0000
+++ linux-2.6.30-rc3/arch/x86/mm/ioremap.c	2009-04-22 03:29:16.580931265 +0000
@@ -280,15 +280,16 @@
 		return NULL;
 	area->phys_addr = phys_addr;
 	vaddr = (unsigned long) area->addr;
-	if (ioremap_page_range(vaddr, vaddr + size, phys_addr, prot)) {
+
+	if (kernel_map_sync_memtype(phys_addr, size, prot_val)) {
 		free_memtype(phys_addr, phys_addr + size);
 		free_vm_area(area);
 		return NULL;
 	}
 
-	if (ioremap_change_attr(vaddr, size, prot_val) < 0) {
+	if (ioremap_page_range(vaddr, vaddr + size, phys_addr, prot)) {
 		free_memtype(phys_addr, phys_addr + size);
-		vunmap(area->addr);
+		free_vm_area(area);
 		return NULL;
 	}
 
@@ -374,7 +375,8 @@
 	 * - UC_MINUS for non-WB-able memory with no other conflicting mappings
 	 * - Inherit from confliting mappings otherwise
 	 */
-	err = reserve_memtype(phys_addr, phys_addr + size, -1, &flags);
+	err = reserve_memtype(phys_addr, phys_addr + size,
+				_PAGE_CACHE_WB, &flags);
 	if (err < 0)
 		return NULL;
 
diff -urN linux-2.6.30-rc2/arch/x86/mm/pageattr.c linux-2.6.30-rc3/arch/x86/mm/pageattr.c
--- linux-2.6.30-rc2/arch/x86/mm/pageattr.c	2009-04-22 03:29:10.547931480 +0000
+++ linux-2.6.30-rc3/arch/x86/mm/pageattr.c	2009-04-22 03:29:16.581931450 +0000
@@ -945,71 +945,94 @@
 
 int set_memory_uc(unsigned long addr, int numpages)
 {
+	int ret;
+
 	/*
 	 * for now UC MINUS. see comments in ioremap_nocache()
 	 */
-	if (reserve_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE,
-			    _PAGE_CACHE_UC_MINUS, NULL))
-		return -EINVAL;
+	ret = reserve_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE,
+			    _PAGE_CACHE_UC_MINUS, NULL);
+	if (ret)
+		goto out_err;
+
+	ret = _set_memory_uc(addr, numpages);
+	if (ret)
+		goto out_free;
+
+	return 0;
 
-	return _set_memory_uc(addr, numpages);
+out_free:
+	free_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE);
+out_err:
+	return ret;
 }
 EXPORT_SYMBOL(set_memory_uc);
 
 int set_memory_array_uc(unsigned long *addr, int addrinarray)
 {
-	unsigned long start;
-	unsigned long end;
-	int i;
+	int i, j;
+	int ret;
+
 	/*
 	 * for now UC MINUS. see comments in ioremap_nocache()
 	 */
 	for (i = 0; i < addrinarray; i++) {
-		start = __pa(addr[i]);
-		for (end = start + PAGE_SIZE; i < addrinarray - 1; end += PAGE_SIZE) {
-			if (end != __pa(addr[i + 1]))
-				break;
-			i++;
-		}
-		if (reserve_memtype(start, end, _PAGE_CACHE_UC_MINUS, NULL))
-			goto out;
+		ret = reserve_memtype(__pa(addr[i]), __pa(addr[i]) + PAGE_SIZE,
+					_PAGE_CACHE_UC_MINUS, NULL);
+		if (ret)
+			goto out_free;
 	}
 
-	return change_page_attr_set(addr, addrinarray,
+	ret = change_page_attr_set(addr, addrinarray,
 				    __pgprot(_PAGE_CACHE_UC_MINUS), 1);
-out:
-	for (i = 0; i < addrinarray; i++) {
-		unsigned long tmp = __pa(addr[i]);
+	if (ret)
+		goto out_free;
 
-		if (tmp == start)
-			break;
-		for (end = tmp + PAGE_SIZE; i < addrinarray - 1; end += PAGE_SIZE) {
-			if (end != __pa(addr[i + 1]))
-				break;
-			i++;
-		}
-		free_memtype(tmp, end);
-	}
-	return -EINVAL;
+	return 0;
+
+out_free:
+	for (j = 0; j < i; j++)
+		free_memtype(__pa(addr[j]), __pa(addr[j]) + PAGE_SIZE);
+
+	return ret;
 }
 EXPORT_SYMBOL(set_memory_array_uc);
 
 int _set_memory_wc(unsigned long addr, int numpages)
 {
-	return change_page_attr_set(&addr, numpages,
+	int ret;
+	ret = change_page_attr_set(&addr, numpages,
+				    __pgprot(_PAGE_CACHE_UC_MINUS), 0);
+
+	if (!ret) {
+		ret = change_page_attr_set(&addr, numpages,
 				    __pgprot(_PAGE_CACHE_WC), 0);
+	}
+	return ret;
 }
 
 int set_memory_wc(unsigned long addr, int numpages)
 {
+	int ret;
+
 	if (!pat_enabled)
 		return set_memory_uc(addr, numpages);
 
-	if (reserve_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE,
-		_PAGE_CACHE_WC, NULL))
-		return -EINVAL;
+	ret = reserve_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE,
+		_PAGE_CACHE_WC, NULL);
+	if (ret)
+		goto out_err;
+
+	ret = _set_memory_wc(addr, numpages);
+	if (ret)
+		goto out_free;
 
-	return _set_memory_wc(addr, numpages);
+	return 0;
+
+out_free:
+	free_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE);
+out_err:
+	return ret;
 }
 EXPORT_SYMBOL(set_memory_wc);
 
@@ -1021,29 +1044,31 @@
 
 int set_memory_wb(unsigned long addr, int numpages)
 {
-	free_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE);
+	int ret;
+
+	ret = _set_memory_wb(addr, numpages);
+	if (ret)
+		return ret;
 
-	return _set_memory_wb(addr, numpages);
+	free_memtype(__pa(addr), __pa(addr) + numpages * PAGE_SIZE);
+	return 0;
 }
 EXPORT_SYMBOL(set_memory_wb);
 
 int set_memory_array_wb(unsigned long *addr, int addrinarray)
 {
 	int i;
+	int ret;
 
-	for (i = 0; i < addrinarray; i++) {
-		unsigned long start = __pa(addr[i]);
-		unsigned long end;
-
-		for (end = start + PAGE_SIZE; i < addrinarray - 1; end += PAGE_SIZE) {
-			if (end != __pa(addr[i + 1]))
-				break;
-			i++;
-		}
-		free_memtype(start, end);
-	}
-	return change_page_attr_clear(addr, addrinarray,
+	ret = change_page_attr_clear(addr, addrinarray,
 				      __pgprot(_PAGE_CACHE_MASK), 1);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < addrinarray; i++)
+		free_memtype(__pa(addr[i]), __pa(addr[i]) + PAGE_SIZE);
+
+	return 0;
 }
 EXPORT_SYMBOL(set_memory_array_wb);
 
@@ -1136,6 +1161,8 @@
 
 	retval = cpa_clear_pages_array(pages, addrinarray,
 			__pgprot(_PAGE_CACHE_MASK));
+	if (retval)
+		return retval;
 
 	for (i = 0; i < addrinarray; i++) {
 		start = (unsigned long)page_address(pages[i]);
@@ -1143,7 +1170,7 @@
 		free_memtype(start, end);
 	}
 
-	return retval;
+	return 0;
 }
 EXPORT_SYMBOL(set_pages_array_wb);
 
diff -urN linux-2.6.30-rc2/arch/x86/mm/pat.c linux-2.6.30-rc3/arch/x86/mm/pat.c
--- linux-2.6.30-rc2/arch/x86/mm/pat.c	2009-04-22 03:29:10.547931480 +0000
+++ linux-2.6.30-rc3/arch/x86/mm/pat.c	2009-04-22 03:29:16.582931418 +0000
@@ -182,10 +182,10 @@
 		u8 mtrr_type;
 
 		mtrr_type = mtrr_type_lookup(start, end);
-		if (mtrr_type == MTRR_TYPE_UNCACHABLE)
-			return _PAGE_CACHE_UC;
-		if (mtrr_type == MTRR_TYPE_WRCOMB)
-			return _PAGE_CACHE_WC;
+		if (mtrr_type != MTRR_TYPE_WRBACK)
+			return _PAGE_CACHE_UC_MINUS;
+
+		return _PAGE_CACHE_WB;
 	}
 
 	return req_type;
@@ -352,23 +352,13 @@
 		return 0;
 	}
 
-	if (req_type == -1) {
-		/*
-		 * Call mtrr_lookup to get the type hint. This is an
-		 * optimization for /dev/mem mmap'ers into WB memory (BIOS
-		 * tools and ACPI tools). Use WB request for WB memory and use
-		 * UC_MINUS otherwise.
-		 */
-		u8 mtrr_type = mtrr_type_lookup(start, end);
-
-		if (mtrr_type == MTRR_TYPE_WRBACK)
-			actual_type = _PAGE_CACHE_WB;
-		else
-			actual_type = _PAGE_CACHE_UC_MINUS;
-	} else {
-		actual_type = pat_x_mtrr_type(start, end,
-					      req_type & _PAGE_CACHE_MASK);
-	}
+	/*
+	 * Call mtrr_lookup to get the type hint. This is an
+	 * optimization for /dev/mem mmap'ers into WB memory (BIOS
+	 * tools and ACPI tools). Use WB request for WB memory and use
+	 * UC_MINUS otherwise.
+	 */
+	actual_type = pat_x_mtrr_type(start, end, req_type & _PAGE_CACHE_MASK);
 
 	if (new_type)
 		*new_type = actual_type;
@@ -546,9 +536,7 @@
 int phys_mem_access_prot_allowed(struct file *file, unsigned long pfn,
 				unsigned long size, pgprot_t *vma_prot)
 {
-	u64 offset = ((u64) pfn) << PAGE_SHIFT;
-	unsigned long flags = -1;
-	int retval;
+	unsigned long flags = _PAGE_CACHE_WB;
 
 	if (!range_is_allowed(pfn, size))
 		return 0;
@@ -576,64 +564,11 @@
 	}
 #endif
 
-	/*
-	 * With O_SYNC, we can only take UC_MINUS mapping. Fail if we cannot.
-	 *
-	 * Without O_SYNC, we want to get
-	 * - WB for WB-able memory and no other conflicting mappings
-	 * - UC_MINUS for non-WB-able memory with no other conflicting mappings
-	 * - Inherit from confliting mappings otherwise
-	 */
-	if (flags != -1) {
-		retval = reserve_memtype(offset, offset + size, flags, NULL);
-	} else {
-		retval = reserve_memtype(offset, offset + size, -1, &flags);
-	}
-
-	if (retval < 0)
-		return 0;
-
-	if (((pfn < max_low_pfn_mapped) ||
-	     (pfn >= (1UL<<(32 - PAGE_SHIFT)) && pfn < max_pfn_mapped)) &&
-	    ioremap_change_attr((unsigned long)__va(offset), size, flags) < 0) {
-		free_memtype(offset, offset + size);
-		printk(KERN_INFO
-		"%s:%d /dev/mem ioremap_change_attr failed %s for %Lx-%Lx\n",
-			current->comm, current->pid,
-			cattr_name(flags),
-			offset, (unsigned long long)(offset + size));
-		return 0;
-	}
-
 	*vma_prot = __pgprot((pgprot_val(*vma_prot) & ~_PAGE_CACHE_MASK) |
 			     flags);
 	return 1;
 }
 
-void map_devmem(unsigned long pfn, unsigned long size, pgprot_t vma_prot)
-{
-	unsigned long want_flags = (pgprot_val(vma_prot) & _PAGE_CACHE_MASK);
-	u64 addr = (u64)pfn << PAGE_SHIFT;
-	unsigned long flags;
-
-	reserve_memtype(addr, addr + size, want_flags, &flags);
-	if (flags != want_flags) {
-		printk(KERN_INFO
-		"%s:%d /dev/mem expected mapping type %s for %Lx-%Lx, got %s\n",
-			current->comm, current->pid,
-			cattr_name(want_flags),
-			addr, (unsigned long long)(addr + size),
-			cattr_name(flags));
-	}
-}
-
-void unmap_devmem(unsigned long pfn, unsigned long size, pgprot_t vma_prot)
-{
-	u64 addr = (u64)pfn << PAGE_SHIFT;
-
-	free_memtype(addr, addr + size);
-}
-
 /*
  * Change the memory type for the physial address range in kernel identity
  * mapping space if that range is a part of identity map.
@@ -671,8 +606,8 @@
 {
 	int is_ram = 0;
 	int ret;
-	unsigned long flags;
 	unsigned long want_flags = (pgprot_val(*vma_prot) & _PAGE_CACHE_MASK);
+	unsigned long flags = want_flags;
 
 	is_ram = pat_pagerange_is_ram(paddr, paddr + size);
 
@@ -734,29 +669,28 @@
  *
  * If the vma has a linear pfn mapping for the entire range, we get the prot
  * from pte and reserve the entire vma range with single reserve_pfn_range call.
- * Otherwise, we reserve the entire vma range, my ging through the PTEs page
- * by page to get physical address and protection.
  */
 int track_pfn_vma_copy(struct vm_area_struct *vma)
 {
-	int retval = 0;
-	unsigned long i, j;
 	resource_size_t paddr;
 	unsigned long prot;
-	unsigned long vma_start = vma->vm_start;
-	unsigned long vma_end = vma->vm_end;
-	unsigned long vma_size = vma_end - vma_start;
+	unsigned long vma_size = vma->vm_end - vma->vm_start;
 	pgprot_t pgprot;
 
 	if (!pat_enabled)
 		return 0;
 
+	/*
+	 * For now, only handle remap_pfn_range() vmas where
+	 * is_linear_pfn_mapping() == TRUE. Handling of
+	 * vm_insert_pfn() is TBD.
+	 */
 	if (is_linear_pfn_mapping(vma)) {
 		/*
 		 * reserve the whole chunk covered by vma. We need the
 		 * starting address and protection from pte.
 		 */
-		if (follow_phys(vma, vma_start, 0, &prot, &paddr)) {
+		if (follow_phys(vma, vma->vm_start, 0, &prot, &paddr)) {
 			WARN_ON_ONCE(1);
 			return -EINVAL;
 		}
@@ -764,28 +698,7 @@
 		return reserve_pfn_range(paddr, vma_size, &pgprot, 1);
 	}
 
-	/* reserve entire vma page by page, using pfn and prot from pte */
-	for (i = 0; i < vma_size; i += PAGE_SIZE) {
-		if (follow_phys(vma, vma_start + i, 0, &prot, &paddr))
-			continue;
-
-		pgprot = __pgprot(prot);
-		retval = reserve_pfn_range(paddr, PAGE_SIZE, &pgprot, 1);
-		if (retval)
-			goto cleanup_ret;
-	}
 	return 0;
-
-cleanup_ret:
-	/* Reserve error: Cleanup partial reservation and return error */
-	for (j = 0; j < i; j += PAGE_SIZE) {
-		if (follow_phys(vma, vma_start + j, 0, &prot, &paddr))
-			continue;
-
-		free_pfn_range(paddr, PAGE_SIZE);
-	}
-
-	return retval;
 }
 
 /*
@@ -795,50 +708,28 @@
  * prot is passed in as a parameter for the new mapping. If the vma has a
  * linear pfn mapping for the entire range reserve the entire vma range with
  * single reserve_pfn_range call.
- * Otherwise, we look t the pfn and size and reserve only the specified range
- * page by page.
- *
- * Note that this function can be called with caller trying to map only a
- * subrange/page inside the vma.
  */
 int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,
 			unsigned long pfn, unsigned long size)
 {
-	int retval = 0;
-	unsigned long i, j;
-	resource_size_t base_paddr;
 	resource_size_t paddr;
-	unsigned long vma_start = vma->vm_start;
-	unsigned long vma_end = vma->vm_end;
-	unsigned long vma_size = vma_end - vma_start;
+	unsigned long vma_size = vma->vm_end - vma->vm_start;
 
 	if (!pat_enabled)
 		return 0;
 
+	/*
+	 * For now, only handle remap_pfn_range() vmas where
+	 * is_linear_pfn_mapping() == TRUE. Handling of
+	 * vm_insert_pfn() is TBD.
+	 */
 	if (is_linear_pfn_mapping(vma)) {
 		/* reserve the whole chunk starting from vm_pgoff */
 		paddr = (resource_size_t)vma->vm_pgoff << PAGE_SHIFT;
 		return reserve_pfn_range(paddr, vma_size, prot, 0);
 	}
 
-	/* reserve page by page using pfn and size */
-	base_paddr = (resource_size_t)pfn << PAGE_SHIFT;
-	for (i = 0; i < size; i += PAGE_SIZE) {
-		paddr = base_paddr + i;
-		retval = reserve_pfn_range(paddr, PAGE_SIZE, prot, 0);
-		if (retval)
-			goto cleanup_ret;
-	}
 	return 0;
-
-cleanup_ret:
-	/* Reserve error: Cleanup partial reservation and return error */
-	for (j = 0; j < i; j += PAGE_SIZE) {
-		paddr = base_paddr + j;
-		free_pfn_range(paddr, PAGE_SIZE);
-	}
-
-	return retval;
 }
 
 /*
@@ -849,39 +740,23 @@
 void untrack_pfn_vma(struct vm_area_struct *vma, unsigned long pfn,
 			unsigned long size)
 {
-	unsigned long i;
 	resource_size_t paddr;
-	unsigned long prot;
-	unsigned long vma_start = vma->vm_start;
-	unsigned long vma_end = vma->vm_end;
-	unsigned long vma_size = vma_end - vma_start;
+	unsigned long vma_size = vma->vm_end - vma->vm_start;
 
 	if (!pat_enabled)
 		return;
 
+	/*
+	 * For now, only handle remap_pfn_range() vmas where
+	 * is_linear_pfn_mapping() == TRUE. Handling of
+	 * vm_insert_pfn() is TBD.
+	 */
 	if (is_linear_pfn_mapping(vma)) {
 		/* free the whole chunk starting from vm_pgoff */
 		paddr = (resource_size_t)vma->vm_pgoff << PAGE_SHIFT;
 		free_pfn_range(paddr, vma_size);
 		return;
 	}
-
-	if (size != 0 && size != vma_size) {
-		/* free page by page, using pfn and size */
-		paddr = (resource_size_t)pfn << PAGE_SHIFT;
-		for (i = 0; i < size; i += PAGE_SIZE) {
-			paddr = paddr + i;
-			free_pfn_range(paddr, PAGE_SIZE);
-		}
-	} else {
-		/* free entire vma, page by page, using the pfn from pte */
-		for (i = 0; i < vma_size; i += PAGE_SIZE) {
-			if (follow_phys(vma, vma_start + i, 0, &prot, &paddr))
-				continue;
-
-			free_pfn_range(paddr, PAGE_SIZE);
-		}
-	}
 }
 
 pgprot_t pgprot_writecombine(pgprot_t prot)
diff -urN linux-2.6.30-rc2/arch/x86/xen/time.c linux-2.6.30-rc3/arch/x86/xen/time.c
--- linux-2.6.30-rc2/arch/x86/xen/time.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/arch/x86/xen/time.c	2009-04-22 03:29:16.587931475 +0000
@@ -213,6 +213,11 @@
 	return ret;
 }
 
+static cycle_t xen_clocksource_get_cycles(struct clocksource *cs)
+{
+	return xen_clocksource_read();
+}
+
 static void xen_read_wallclock(struct timespec *ts)
 {
 	struct shared_info *s = HYPERVISOR_shared_info;
@@ -241,7 +246,7 @@
 static struct clocksource xen_clocksource __read_mostly = {
 	.name = "xen",
 	.rating = 400,
-	.read = xen_clocksource_read,
+	.read = xen_clocksource_get_cycles,
 	.mask = ~0,
 	.mult = 1<<XEN_SHIFT,		/* time directly in nanoseconds */
 	.shift = XEN_SHIFT,
diff -urN linux-2.6.30-rc2/block/as-iosched.c linux-2.6.30-rc3/block/as-iosched.c
--- linux-2.6.30-rc2/block/as-iosched.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/block/as-iosched.c	2009-04-22 03:29:16.595931396 +0000
@@ -17,9 +17,6 @@
 #include <linux/rbtree.h>
 #include <linux/interrupt.h>
 
-#define REQ_SYNC	1
-#define REQ_ASYNC	0
-
 /*
  * See Documentation/block/as-iosched.txt
  */
@@ -93,7 +90,7 @@
 	struct list_head fifo_list[2];
 
 	struct request *next_rq[2];	/* next in sort order */
-	sector_t last_sector[2];	/* last REQ_SYNC & REQ_ASYNC sectors */
+	sector_t last_sector[2];	/* last SYNC & ASYNC sectors */
 
 	unsigned long exit_prob;	/* probability a task will exit while
 					   being waited on */
@@ -109,7 +106,7 @@
 	unsigned long last_check_fifo[2];
 	int changed_batch;		/* 1: waiting for old batch to end */
 	int new_batch;			/* 1: waiting on first read complete */
-	int batch_data_dir;		/* current batch REQ_SYNC / REQ_ASYNC */
+	int batch_data_dir;		/* current batch SYNC / ASYNC */
 	int write_batch_count;		/* max # of reqs in a write batch */
 	int current_write_count;	/* how many requests left this batch */
 	int write_batch_idled;		/* has the write batch gone idle? */
@@ -554,7 +551,7 @@
 	if (aic == NULL)
 		return;
 
-	if (data_dir == REQ_SYNC) {
+	if (data_dir == BLK_RW_SYNC) {
 		unsigned long in_flight = atomic_read(&aic->nr_queued)
 					+ atomic_read(&aic->nr_dispatched);
 		spin_lock(&aic->lock);
@@ -811,7 +808,7 @@
  */
 static void update_write_batch(struct as_data *ad)
 {
-	unsigned long batch = ad->batch_expire[REQ_ASYNC];
+	unsigned long batch = ad->batch_expire[BLK_RW_ASYNC];
 	long write_time;
 
 	write_time = (jiffies - ad->current_batch_expires) + batch;
@@ -855,7 +852,7 @@
 		kblockd_schedule_work(q, &ad->antic_work);
 		ad->changed_batch = 0;
 
-		if (ad->batch_data_dir == REQ_SYNC)
+		if (ad->batch_data_dir == BLK_RW_SYNC)
 			ad->new_batch = 1;
 	}
 	WARN_ON(ad->nr_dispatched == 0);
@@ -869,7 +866,7 @@
 	if (ad->new_batch && ad->batch_data_dir == rq_is_sync(rq)) {
 		update_write_batch(ad);
 		ad->current_batch_expires = jiffies +
-				ad->batch_expire[REQ_SYNC];
+				ad->batch_expire[BLK_RW_SYNC];
 		ad->new_batch = 0;
 	}
 
@@ -960,7 +957,7 @@
 	if (ad->changed_batch || ad->new_batch)
 		return 0;
 
-	if (ad->batch_data_dir == REQ_SYNC)
+	if (ad->batch_data_dir == BLK_RW_SYNC)
 		/* TODO! add a check so a complete fifo gets written? */
 		return time_after(jiffies, ad->current_batch_expires);
 
@@ -986,7 +983,7 @@
 	 */
 	ad->last_sector[data_dir] = rq->sector + rq->nr_sectors;
 
-	if (data_dir == REQ_SYNC) {
+	if (data_dir == BLK_RW_SYNC) {
 		struct io_context *ioc = RQ_IOC(rq);
 		/* In case we have to anticipate after this */
 		copy_io_context(&ad->io_context, &ioc);
@@ -1025,41 +1022,41 @@
 static int as_dispatch_request(struct request_queue *q, int force)
 {
 	struct as_data *ad = q->elevator->elevator_data;
-	const int reads = !list_empty(&ad->fifo_list[REQ_SYNC]);
-	const int writes = !list_empty(&ad->fifo_list[REQ_ASYNC]);
+	const int reads = !list_empty(&ad->fifo_list[BLK_RW_SYNC]);
+	const int writes = !list_empty(&ad->fifo_list[BLK_RW_ASYNC]);
 	struct request *rq;
 
 	if (unlikely(force)) {
 		/*
 		 * Forced dispatch, accounting is useless.  Reset
 		 * accounting states and dump fifo_lists.  Note that
-		 * batch_data_dir is reset to REQ_SYNC to avoid
+		 * batch_data_dir is reset to BLK_RW_SYNC to avoid
 		 * screwing write batch accounting as write batch
 		 * accounting occurs on W->R transition.
 		 */
 		int dispatched = 0;
 
-		ad->batch_data_dir = REQ_SYNC;
+		ad->batch_data_dir = BLK_RW_SYNC;
 		ad->changed_batch = 0;
 		ad->new_batch = 0;
 
-		while (ad->next_rq[REQ_SYNC]) {
-			as_move_to_dispatch(ad, ad->next_rq[REQ_SYNC]);
+		while (ad->next_rq[BLK_RW_SYNC]) {
+			as_move_to_dispatch(ad, ad->next_rq[BLK_RW_SYNC]);
 			dispatched++;
 		}
-		ad->last_check_fifo[REQ_SYNC] = jiffies;
+		ad->last_check_fifo[BLK_RW_SYNC] = jiffies;
 
-		while (ad->next_rq[REQ_ASYNC]) {
-			as_move_to_dispatch(ad, ad->next_rq[REQ_ASYNC]);
+		while (ad->next_rq[BLK_RW_ASYNC]) {
+			as_move_to_dispatch(ad, ad->next_rq[BLK_RW_ASYNC]);
 			dispatched++;
 		}
-		ad->last_check_fifo[REQ_ASYNC] = jiffies;
+		ad->last_check_fifo[BLK_RW_ASYNC] = jiffies;
 
 		return dispatched;
 	}
 
 	/* Signal that the write batch was uncontended, so we can't time it */
-	if (ad->batch_data_dir == REQ_ASYNC && !reads) {
+	if (ad->batch_data_dir == BLK_RW_ASYNC && !reads) {
 		if (ad->current_write_count == 0 || !writes)
 			ad->write_batch_idled = 1;
 	}
@@ -1076,8 +1073,8 @@
 		 */
 		rq = ad->next_rq[ad->batch_data_dir];
 
-		if (ad->batch_data_dir == REQ_SYNC && ad->antic_expire) {
-			if (as_fifo_expired(ad, REQ_SYNC))
+		if (ad->batch_data_dir == BLK_RW_SYNC && ad->antic_expire) {
+			if (as_fifo_expired(ad, BLK_RW_SYNC))
 				goto fifo_expired;
 
 			if (as_can_anticipate(ad, rq)) {
@@ -1090,7 +1087,7 @@
 			/* we have a "next request" */
 			if (reads && !writes)
 				ad->current_batch_expires =
-					jiffies + ad->batch_expire[REQ_SYNC];
+					jiffies + ad->batch_expire[BLK_RW_SYNC];
 			goto dispatch_request;
 		}
 	}
@@ -1101,20 +1098,20 @@
 	 */
 
 	if (reads) {
-		BUG_ON(RB_EMPTY_ROOT(&ad->sort_list[REQ_SYNC]));
+		BUG_ON(RB_EMPTY_ROOT(&ad->sort_list[BLK_RW_SYNC]));
 
-		if (writes && ad->batch_data_dir == REQ_SYNC)
+		if (writes && ad->batch_data_dir == BLK_RW_SYNC)
 			/*
 			 * Last batch was a read, switch to writes
 			 */
 			goto dispatch_writes;
 
-		if (ad->batch_data_dir == REQ_ASYNC) {
+		if (ad->batch_data_dir == BLK_RW_ASYNC) {
 			WARN_ON(ad->new_batch);
 			ad->changed_batch = 1;
 		}
-		ad->batch_data_dir = REQ_SYNC;
-		rq = rq_entry_fifo(ad->fifo_list[REQ_SYNC].next);
+		ad->batch_data_dir = BLK_RW_SYNC;
+		rq = rq_entry_fifo(ad->fifo_list[BLK_RW_SYNC].next);
 		ad->last_check_fifo[ad->batch_data_dir] = jiffies;
 		goto dispatch_request;
 	}
@@ -1125,9 +1122,9 @@
 
 	if (writes) {
 dispatch_writes:
-		BUG_ON(RB_EMPTY_ROOT(&ad->sort_list[REQ_ASYNC]));
+		BUG_ON(RB_EMPTY_ROOT(&ad->sort_list[BLK_RW_ASYNC]));
 
-		if (ad->batch_data_dir == REQ_SYNC) {
+		if (ad->batch_data_dir == BLK_RW_SYNC) {
 			ad->changed_batch = 1;
 
 			/*
@@ -1137,11 +1134,11 @@
 			 */
 			ad->new_batch = 0;
 		}
-		ad->batch_data_dir = REQ_ASYNC;
+		ad->batch_data_dir = BLK_RW_ASYNC;
 		ad->current_write_count = ad->write_batch_count;
 		ad->write_batch_idled = 0;
-		rq = rq_entry_fifo(ad->fifo_list[REQ_ASYNC].next);
-		ad->last_check_fifo[REQ_ASYNC] = jiffies;
+		rq = rq_entry_fifo(ad->fifo_list[BLK_RW_ASYNC].next);
+		ad->last_check_fifo[BLK_RW_ASYNC] = jiffies;
 		goto dispatch_request;
 	}
 
@@ -1164,9 +1161,9 @@
 		if (ad->nr_dispatched)
 			return 0;
 
-		if (ad->batch_data_dir == REQ_ASYNC)
+		if (ad->batch_data_dir == BLK_RW_ASYNC)
 			ad->current_batch_expires = jiffies +
-					ad->batch_expire[REQ_ASYNC];
+					ad->batch_expire[BLK_RW_ASYNC];
 		else
 			ad->new_batch = 1;
 
@@ -1238,8 +1235,8 @@
 {
 	struct as_data *ad = q->elevator->elevator_data;
 
-	return list_empty(&ad->fifo_list[REQ_ASYNC])
-		&& list_empty(&ad->fifo_list[REQ_SYNC]);
+	return list_empty(&ad->fifo_list[BLK_RW_ASYNC])
+		&& list_empty(&ad->fifo_list[BLK_RW_SYNC]);
 }
 
 static int
@@ -1346,8 +1343,8 @@
 	del_timer_sync(&ad->antic_timer);
 	cancel_work_sync(&ad->antic_work);
 
-	BUG_ON(!list_empty(&ad->fifo_list[REQ_SYNC]));
-	BUG_ON(!list_empty(&ad->fifo_list[REQ_ASYNC]));
+	BUG_ON(!list_empty(&ad->fifo_list[BLK_RW_SYNC]));
+	BUG_ON(!list_empty(&ad->fifo_list[BLK_RW_ASYNC]));
 
 	put_io_context(ad->io_context);
 	kfree(ad);
@@ -1372,18 +1369,18 @@
 	init_timer(&ad->antic_timer);
 	INIT_WORK(&ad->antic_work, as_work_handler);
 
-	INIT_LIST_HEAD(&ad->fifo_list[REQ_SYNC]);
-	INIT_LIST_HEAD(&ad->fifo_list[REQ_ASYNC]);
-	ad->sort_list[REQ_SYNC] = RB_ROOT;
-	ad->sort_list[REQ_ASYNC] = RB_ROOT;
-	ad->fifo_expire[REQ_SYNC] = default_read_expire;
-	ad->fifo_expire[REQ_ASYNC] = default_write_expire;
+	INIT_LIST_HEAD(&ad->fifo_list[BLK_RW_SYNC]);
+	INIT_LIST_HEAD(&ad->fifo_list[BLK_RW_ASYNC]);
+	ad->sort_list[BLK_RW_SYNC] = RB_ROOT;
+	ad->sort_list[BLK_RW_ASYNC] = RB_ROOT;
+	ad->fifo_expire[BLK_RW_SYNC] = default_read_expire;
+	ad->fifo_expire[BLK_RW_ASYNC] = default_write_expire;
 	ad->antic_expire = default_antic_expire;
-	ad->batch_expire[REQ_SYNC] = default_read_batch_expire;
-	ad->batch_expire[REQ_ASYNC] = default_write_batch_expire;
+	ad->batch_expire[BLK_RW_SYNC] = default_read_batch_expire;
+	ad->batch_expire[BLK_RW_ASYNC] = default_write_batch_expire;
 
-	ad->current_batch_expires = jiffies + ad->batch_expire[REQ_SYNC];
-	ad->write_batch_count = ad->batch_expire[REQ_ASYNC] / 10;
+	ad->current_batch_expires = jiffies + ad->batch_expire[BLK_RW_SYNC];
+	ad->write_batch_count = ad->batch_expire[BLK_RW_ASYNC] / 10;
 	if (ad->write_batch_count < 2)
 		ad->write_batch_count = 2;
 
@@ -1432,11 +1429,11 @@
 	struct as_data *ad = e->elevator_data;			\
 	return as_var_show(jiffies_to_msecs((__VAR)), (page));	\
 }
-SHOW_FUNCTION(as_read_expire_show, ad->fifo_expire[REQ_SYNC]);
-SHOW_FUNCTION(as_write_expire_show, ad->fifo_expire[REQ_ASYNC]);
+SHOW_FUNCTION(as_read_expire_show, ad->fifo_expire[BLK_RW_SYNC]);
+SHOW_FUNCTION(as_write_expire_show, ad->fifo_expire[BLK_RW_ASYNC]);
 SHOW_FUNCTION(as_antic_expire_show, ad->antic_expire);
-SHOW_FUNCTION(as_read_batch_expire_show, ad->batch_expire[REQ_SYNC]);
-SHOW_FUNCTION(as_write_batch_expire_show, ad->batch_expire[REQ_ASYNC]);
+SHOW_FUNCTION(as_read_batch_expire_show, ad->batch_expire[BLK_RW_SYNC]);
+SHOW_FUNCTION(as_write_batch_expire_show, ad->batch_expire[BLK_RW_ASYNC]);
 #undef SHOW_FUNCTION
 
 #define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX)				\
@@ -1451,13 +1448,14 @@
 	*(__PTR) = msecs_to_jiffies(*(__PTR));				\
 	return ret;							\
 }
-STORE_FUNCTION(as_read_expire_store, &ad->fifo_expire[REQ_SYNC], 0, INT_MAX);
-STORE_FUNCTION(as_write_expire_store, &ad->fifo_expire[REQ_ASYNC], 0, INT_MAX);
+STORE_FUNCTION(as_read_expire_store, &ad->fifo_expire[BLK_RW_SYNC], 0, INT_MAX);
+STORE_FUNCTION(as_write_expire_store,
+			&ad->fifo_expire[BLK_RW_ASYNC], 0, INT_MAX);
 STORE_FUNCTION(as_antic_expire_store, &ad->antic_expire, 0, INT_MAX);
 STORE_FUNCTION(as_read_batch_expire_store,
-			&ad->batch_expire[REQ_SYNC], 0, INT_MAX);
+			&ad->batch_expire[BLK_RW_SYNC], 0, INT_MAX);
 STORE_FUNCTION(as_write_batch_expire_store,
-			&ad->batch_expire[REQ_ASYNC], 0, INT_MAX);
+			&ad->batch_expire[BLK_RW_ASYNC], 0, INT_MAX);
 #undef STORE_FUNCTION
 
 #define AS_ATTR(name) \
diff -urN linux-2.6.30-rc2/block/blk-barrier.c linux-2.6.30-rc3/block/blk-barrier.c
--- linux-2.6.30-rc2/block/blk-barrier.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/block/blk-barrier.c	2009-04-22 03:29:16.596931629 +0000
@@ -319,9 +319,6 @@
 		return -ENXIO;
 
 	bio = bio_alloc(GFP_KERNEL, 0);
-	if (!bio)
-		return -ENOMEM;
-
 	bio->bi_end_io = bio_end_empty_barrier;
 	bio->bi_private = &wait;
 	bio->bi_bdev = bdev;
diff -urN linux-2.6.30-rc2/block/blk-sysfs.c linux-2.6.30-rc3/block/blk-sysfs.c
--- linux-2.6.30-rc2/block/blk-sysfs.c	2009-04-22 03:29:10.561931387 +0000
+++ linux-2.6.30-rc3/block/blk-sysfs.c	2009-04-22 03:29:16.597931405 +0000
@@ -209,14 +209,14 @@
 	ssize_t ret = queue_var_store(&stats, page, count);
 
 	spin_lock_irq(q->queue_lock);
-	elv_quisce_start(q);
+	elv_quiesce_start(q);
 
 	if (stats)
 		queue_flag_set(QUEUE_FLAG_IO_STAT, q);
 	else
 		queue_flag_clear(QUEUE_FLAG_IO_STAT, q);
 
-	elv_quisce_end(q);
+	elv_quiesce_end(q);
 	spin_unlock_irq(q->queue_lock);
 
 	return ret;
diff -urN linux-2.6.30-rc2/block/blk.h linux-2.6.30-rc3/block/blk.h
--- linux-2.6.30-rc2/block/blk.h	2009-04-22 03:29:10.561931387 +0000
+++ linux-2.6.30-rc3/block/blk.h	2009-04-22 03:29:16.597931405 +0000
@@ -70,8 +70,8 @@
 
 int blk_dev_init(void);
 
-void elv_quisce_start(struct request_queue *q);
-void elv_quisce_end(struct request_queue *q);
+void elv_quiesce_start(struct request_queue *q);
+void elv_quiesce_end(struct request_queue *q);
 
 
 /*
diff -urN linux-2.6.30-rc2/block/cfq-iosched.c linux-2.6.30-rc3/block/cfq-iosched.c
--- linux-2.6.30-rc2/block/cfq-iosched.c	2009-04-22 03:29:10.563931403 +0000
+++ linux-2.6.30-rc3/block/cfq-iosched.c	2009-04-22 03:29:16.598931395 +0000
@@ -56,9 +56,6 @@
 #define cfq_class_idle(cfqq)	((cfqq)->ioprio_class == IOPRIO_CLASS_IDLE)
 #define cfq_class_rt(cfqq)	((cfqq)->ioprio_class == IOPRIO_CLASS_RT)
 
-#define ASYNC			(0)
-#define SYNC			(1)
-
 #define sample_valid(samples)	((samples) > 80)
 
 /*
@@ -83,6 +80,14 @@
 	 * rr list of queues with requests and the count of them
 	 */
 	struct cfq_rb_root service_tree;
+
+	/*
+	 * Each priority tree is sorted by next_request position.  These
+	 * trees are used when determining if two or more queues are
+	 * interleaving requests (see cfq_close_cooperator).
+	 */
+	struct rb_root prio_trees[CFQ_PRIO_LISTS];
+
 	unsigned int busy_queues;
 	/*
 	 * Used to track any pending rt requests so we can pre-empt current
@@ -147,6 +152,8 @@
 	struct rb_node rb_node;
 	/* service_tree key */
 	unsigned long rb_key;
+	/* prio tree member */
+	struct rb_node p_node;
 	/* sorted list of pending requests */
 	struct rb_root sort_list;
 	/* if fifo isn't expired, next request to serve */
@@ -185,6 +192,7 @@
 	CFQ_CFQQ_FLAG_prio_changed,	/* task priority has changed */
 	CFQ_CFQQ_FLAG_slice_new,	/* no requests dispatched in slice */
 	CFQ_CFQQ_FLAG_sync,		/* synchronous queue */
+	CFQ_CFQQ_FLAG_coop,		/* has done a coop jump of the queue */
 };
 
 #define CFQ_CFQQ_FNS(name)						\
@@ -211,6 +219,7 @@
 CFQ_CFQQ_FNS(prio_changed);
 CFQ_CFQQ_FNS(slice_new);
 CFQ_CFQQ_FNS(sync);
+CFQ_CFQQ_FNS(coop);
 #undef CFQ_CFQQ_FNS
 
 #define cfq_log_cfqq(cfqd, cfqq, fmt, args...)	\
@@ -419,13 +428,17 @@
 	return NULL;
 }
 
+static void rb_erase_init(struct rb_node *n, struct rb_root *root)
+{
+	rb_erase(n, root);
+	RB_CLEAR_NODE(n);
+}
+
 static void cfq_rb_erase(struct rb_node *n, struct cfq_rb_root *root)
 {
 	if (root->left == n)
 		root->left = NULL;
-
-	rb_erase(n, &root->rb);
-	RB_CLEAR_NODE(n);
+	rb_erase_init(n, &root->rb);
 }
 
 /*
@@ -470,8 +483,8 @@
  * requests waiting to be processed. It is sorted in the order that
  * we will service the queues.
  */
-static void cfq_service_tree_add(struct cfq_data *cfqd,
-				    struct cfq_queue *cfqq, int add_front)
+static void cfq_service_tree_add(struct cfq_data *cfqd, struct cfq_queue *cfqq,
+				 int add_front)
 {
 	struct rb_node **p, *parent;
 	struct cfq_queue *__cfqq;
@@ -544,6 +557,63 @@
 	rb_insert_color(&cfqq->rb_node, &cfqd->service_tree.rb);
 }
 
+static struct cfq_queue *
+cfq_prio_tree_lookup(struct cfq_data *cfqd, int ioprio, sector_t sector,
+		     struct rb_node **ret_parent, struct rb_node ***rb_link)
+{
+	struct rb_root *root = &cfqd->prio_trees[ioprio];
+	struct rb_node **p, *parent;
+	struct cfq_queue *cfqq = NULL;
+
+	parent = NULL;
+	p = &root->rb_node;
+	while (*p) {
+		struct rb_node **n;
+
+		parent = *p;
+		cfqq = rb_entry(parent, struct cfq_queue, p_node);
+
+		/*
+		 * Sort strictly based on sector.  Smallest to the left,
+		 * largest to the right.
+		 */
+		if (sector > cfqq->next_rq->sector)
+			n = &(*p)->rb_right;
+		else if (sector < cfqq->next_rq->sector)
+			n = &(*p)->rb_left;
+		else
+			break;
+		p = n;
+	}
+
+	*ret_parent = parent;
+	if (rb_link)
+		*rb_link = p;
+	return NULL;
+}
+
+static void cfq_prio_tree_add(struct cfq_data *cfqd, struct cfq_queue *cfqq)
+{
+	struct rb_root *root = &cfqd->prio_trees[cfqq->ioprio];
+	struct rb_node **p, *parent;
+	struct cfq_queue *__cfqq;
+
+	if (!RB_EMPTY_NODE(&cfqq->p_node))
+		rb_erase_init(&cfqq->p_node, root);
+
+	if (cfq_class_idle(cfqq))
+		return;
+	if (!cfqq->next_rq)
+		return;
+
+	__cfqq = cfq_prio_tree_lookup(cfqd, cfqq->ioprio, cfqq->next_rq->sector,
+					 &parent, &p);
+	BUG_ON(__cfqq);
+
+	rb_link_node(&cfqq->p_node, parent, p);
+	rb_insert_color(&cfqq->p_node, root);
+}
+
 /*
  * Update cfqq's position in the service tree.
  */
@@ -552,8 +622,10 @@
 	/*
 	 * Resorting requires the cfqq to be on the RR list already.
 	 */
-	if (cfq_cfqq_on_rr(cfqq))
+	if (cfq_cfqq_on_rr(cfqq)) {
 		cfq_service_tree_add(cfqd, cfqq, 0);
+		cfq_prio_tree_add(cfqd, cfqq);
+	}
 }
 
 /*
@@ -584,6 +656,8 @@
 
 	if (!RB_EMPTY_NODE(&cfqq->rb_node))
 		cfq_rb_erase(&cfqq->rb_node, &cfqd->service_tree);
+	if (!RB_EMPTY_NODE(&cfqq->p_node))
+		rb_erase_init(&cfqq->p_node, &cfqd->prio_trees[cfqq->ioprio]);
 
 	BUG_ON(!cfqd->busy_queues);
 	cfqd->busy_queues--;
@@ -613,7 +687,7 @@
 {
 	struct cfq_queue *cfqq = RQ_CFQQ(rq);
 	struct cfq_data *cfqd = cfqq->cfqd;
-	struct request *__alias;
+	struct request *__alias, *prev;
 
 	cfqq->queued[rq_is_sync(rq)]++;
 
@@ -630,7 +704,15 @@
 	/*
 	 * check if this request is a better next-serve candidate
 	 */
+	prev = cfqq->next_rq;
 	cfqq->next_rq = cfq_choose_req(cfqd, cfqq->next_rq, rq);
+
+	/*
+	 * adjust priority tree position, if ->next_rq changes
+	 */
+	if (prev != cfqq->next_rq)
+		cfq_prio_tree_add(cfqd, cfqq);
+
 	BUG_ON(!cfqq->next_rq);
 }
 
@@ -843,11 +925,15 @@
 /*
  * Get and set a new active queue for service.
  */
-static struct cfq_queue *cfq_set_active_queue(struct cfq_data *cfqd)
+static struct cfq_queue *cfq_set_active_queue(struct cfq_data *cfqd,
+					      struct cfq_queue *cfqq)
 {
-	struct cfq_queue *cfqq;
+	if (!cfqq) {
+		cfqq = cfq_get_next_queue(cfqd);
+		if (cfqq)
+			cfq_clear_cfqq_coop(cfqq);
+	}
 
-	cfqq = cfq_get_next_queue(cfqd);
 	__cfq_set_active_queue(cfqd, cfqq);
 	return cfqq;
 }
@@ -871,17 +957,89 @@
 	return cfq_dist_from_last(cfqd, rq) <= cic->seek_mean;
 }
 
-static int cfq_close_cooperator(struct cfq_data *cfq_data,
-				struct cfq_queue *cfqq)
+static struct cfq_queue *cfqq_close(struct cfq_data *cfqd,
+				    struct cfq_queue *cur_cfqq)
 {
+	struct rb_root *root = &cfqd->prio_trees[cur_cfqq->ioprio];
+	struct rb_node *parent, *node;
+	struct cfq_queue *__cfqq;
+	sector_t sector = cfqd->last_position;
+
+	if (RB_EMPTY_ROOT(root))
+		return NULL;
+
+	/*
+	 * First, if we find a request starting at the end of the last
+	 * request, choose it.
+	 */
+	__cfqq = cfq_prio_tree_lookup(cfqd, cur_cfqq->ioprio,
+				      sector, &parent, NULL);
+	if (__cfqq)
+		return __cfqq;
+
+	/*
+	 * If the exact sector wasn't found, the parent of the NULL leaf
+	 * will contain the closest sector.
+	 */
+	__cfqq = rb_entry(parent, struct cfq_queue, p_node);
+	if (cfq_rq_close(cfqd, __cfqq->next_rq))
+		return __cfqq;
+
+	if (__cfqq->next_rq->sector < sector)
+		node = rb_next(&__cfqq->p_node);
+	else
+		node = rb_prev(&__cfqq->p_node);
+	if (!node)
+		return NULL;
+
+	__cfqq = rb_entry(node, struct cfq_queue, p_node);
+	if (cfq_rq_close(cfqd, __cfqq->next_rq))
+		return __cfqq;
+
+	return NULL;
+}
+
+/*
+ * cfqd - obvious
+ * cur_cfqq - passed in so that we don't decide that the current queue is
+ * 	      closely cooperating with itself.
+ *
+ * So, basically we're assuming that that cur_cfqq has dispatched at least
+ * one request, and that cfqd->last_position reflects a position on the disk
+ * associated with the I/O issued by cur_cfqq.  I'm not sure this is a valid
+ * assumption.
+ */
+static struct cfq_queue *cfq_close_cooperator(struct cfq_data *cfqd,
+					      struct cfq_queue *cur_cfqq,
+					      int probe)
+{
+	struct cfq_queue *cfqq;
+
+	/*
+	 * A valid cfq_io_context is necessary to compare requests against
+	 * the seek_mean of the current cfqq.
+	 */
+	if (!cfqd->active_cic)
+		return NULL;
+
 	/*
 	 * We should notice if some of the queues are cooperating, eg
 	 * working closely on the same area of the disk. In that case,
 	 * we can group them together and don't waste time idling.
 	 */
-	return 0;
+	cfqq = cfqq_close(cfqd, cur_cfqq);
+	if (!cfqq)
+		return NULL;
+
+	if (cfq_cfqq_coop(cfqq))
+		return NULL;
+
+	if (!probe)
+		cfq_mark_cfqq_coop(cfqq);
+	return cfqq;
 }
 
+
 #define CIC_SEEKY(cic) ((cic)->seek_mean > (8 * 1024))
 
 static void cfq_arm_slice_timer(struct cfq_data *cfqd)
@@ -920,13 +1078,6 @@
 	if (!cic || !atomic_read(&cic->ioc->nr_tasks))
 		return;
 
-	/*
-	 * See if this prio level has a good candidate
-	 */
-	if (cfq_close_cooperator(cfqd, cfqq) &&
-	    (sample_valid(cic->ttime_samples) && cic->ttime_mean > 2))
-		return;
-
 	cfq_mark_cfqq_wait_request(cfqq);
 
 	/*
@@ -939,7 +1090,7 @@
 		sl = min(sl, msecs_to_jiffies(CFQ_MIN_TT));
 
 	mod_timer(&cfqd->idle_slice_timer, jiffies + sl);
-	cfq_log(cfqd, "arm_idle: %lu", sl);
+	cfq_log_cfqq(cfqd, cfqq, "arm_idle: %lu", sl);
 }
 
 /*
@@ -1003,7 +1154,7 @@
  */
 static struct cfq_queue *cfq_select_queue(struct cfq_data *cfqd)
 {
-	struct cfq_queue *cfqq;
+	struct cfq_queue *cfqq, *new_cfqq = NULL;
 
 	cfqq = cfqd->active_queue;
 	if (!cfqq)
@@ -1037,6 +1188,16 @@
 		goto keep_queue;
 
 	/*
+	 * If another queue has a request waiting within our mean seek
+	 * distance, let it run.  The expire code will check for close
+	 * cooperators and put the close queue at the front of the service
+	 * tree.
+	 */
+	new_cfqq = cfq_close_cooperator(cfqd, cfqq, 0);
+	if (new_cfqq)
+		goto expire;
+
+	/*
 	 * No requests pending. If the active queue still has requests in
 	 * flight or is idling for a new request, allow either of these
 	 * conditions to happen (or time out) before selecting a new queue.
@@ -1050,7 +1211,7 @@
 expire:
 	cfq_slice_expired(cfqd, 0);
 new_queue:
-	cfqq = cfq_set_active_queue(cfqd);
+	cfqq = cfq_set_active_queue(cfqd, new_cfqq);
 keep_queue:
 	return cfqq;
 }
@@ -1333,14 +1494,14 @@
 	if (ioc->ioc_data == cic)
 		rcu_assign_pointer(ioc->ioc_data, NULL);
 
-	if (cic->cfqq[ASYNC]) {
-		cfq_exit_cfqq(cfqd, cic->cfqq[ASYNC]);
-		cic->cfqq[ASYNC] = NULL;
+	if (cic->cfqq[BLK_RW_ASYNC]) {
+		cfq_exit_cfqq(cfqd, cic->cfqq[BLK_RW_ASYNC]);
+		cic->cfqq[BLK_RW_ASYNC] = NULL;
 	}
 
-	if (cic->cfqq[SYNC]) {
-		cfq_exit_cfqq(cfqd, cic->cfqq[SYNC]);
-		cic->cfqq[SYNC] = NULL;
+	if (cic->cfqq[BLK_RW_SYNC]) {
+		cfq_exit_cfqq(cfqd, cic->cfqq[BLK_RW_SYNC]);
+		cic->cfqq[BLK_RW_SYNC] = NULL;
 	}
 }
 
@@ -1449,17 +1610,18 @@
 
 	spin_lock_irqsave(cfqd->queue->queue_lock, flags);
 
-	cfqq = cic->cfqq[ASYNC];
+	cfqq = cic->cfqq[BLK_RW_ASYNC];
 	if (cfqq) {
 		struct cfq_queue *new_cfqq;
-		new_cfqq = cfq_get_queue(cfqd, ASYNC, cic->ioc, GFP_ATOMIC);
+		new_cfqq = cfq_get_queue(cfqd, BLK_RW_ASYNC, cic->ioc,
+						GFP_ATOMIC);
 		if (new_cfqq) {
-			cic->cfqq[ASYNC] = new_cfqq;
+			cic->cfqq[BLK_RW_ASYNC] = new_cfqq;
 			cfq_put_queue(cfqq);
 		}
 	}
 
-	cfqq = cic->cfqq[SYNC];
+	cfqq = cic->cfqq[BLK_RW_SYNC];
 	if (cfqq)
 		cfq_mark_cfqq_prio_changed(cfqq);
 
@@ -1510,6 +1672,7 @@
 		}
 
 		RB_CLEAR_NODE(&cfqq->rb_node);
+		RB_CLEAR_NODE(&cfqq->p_node);
 		INIT_LIST_HEAD(&cfqq->fifo);
 
 		atomic_set(&cfqq->ref, 0);
@@ -1905,10 +2068,20 @@
 		 * Remember that we saw a request from this process, but
 		 * don't start queuing just yet. Otherwise we risk seeing lots
 		 * of tiny requests, because we disrupt the normal plugging
-		 * and merging.
+		 * and merging. If the request is already larger than a single
+		 * page, let it rip immediately. For that case we assume that
+		 * merging is already done. Ditto for a busy system that
+		 * has other work pending, don't risk delaying until the
+		 * idle timer unplug to continue working.
 		 */
-		if (cfq_cfqq_wait_request(cfqq))
+		if (cfq_cfqq_wait_request(cfqq)) {
+			if (blk_rq_bytes(rq) > PAGE_CACHE_SIZE ||
+			    cfqd->busy_queues > 1) {
+				del_timer(&cfqd->idle_slice_timer);
+				blk_start_queueing(cfqd->queue);
+			}
 			cfq_mark_cfqq_must_dispatch(cfqq);
+		}
 	} else if (cfq_should_preempt(cfqd, cfqq, rq)) {
 		/*
 		 * not the active queue - expire current slice if it is
@@ -1992,16 +2165,24 @@
 	 * or if we want to idle in case it has no pending requests.
 	 */
 	if (cfqd->active_queue == cfqq) {
+		const bool cfqq_empty = RB_EMPTY_ROOT(&cfqq->sort_list);
+
 		if (cfq_cfqq_slice_new(cfqq)) {
 			cfq_set_prio_slice(cfqd, cfqq);
 			cfq_clear_cfqq_slice_new(cfqq);
 		}
+		/*
+		 * If there are no requests waiting in this queue, and
+		 * there are other queues ready to issue requests, AND
+		 * those other queues are issuing requests within our
+		 * mean seek distance, give them a chance to run instead
+		 * of idling.
+		 */
 		if (cfq_slice_used(cfqq) || cfq_class_idle(cfqq))
 			cfq_slice_expired(cfqd, 1);
-		else if (sync && !rq_noidle(rq) &&
-			 RB_EMPTY_ROOT(&cfqq->sort_list)) {
+		else if (cfqq_empty && !cfq_close_cooperator(cfqd, cfqq, 1) &&
+			 sync && !rq_noidle(rq))
 			cfq_arm_slice_timer(cfqd);
-		}
 	}
 
 	if (!cfqd->rq_in_driver)
@@ -2062,7 +2243,7 @@
 	if (!cic)
 		return ELV_MQUEUE_MAY;
 
-	cfqq = cic_to_cfqq(cic, rw & REQ_RW_SYNC);
+	cfqq = cic_to_cfqq(cic, rw_is_sync(rw));
 	if (cfqq) {
 		cfq_init_prio_data(cfqq, cic->ioc);
 		cfq_prio_boost(cfqq);
@@ -2152,11 +2333,10 @@
 	struct cfq_data *cfqd =
 		container_of(work, struct cfq_data, unplug_work);
 	struct request_queue *q = cfqd->queue;
-	unsigned long flags;
 
-	spin_lock_irqsave(q->queue_lock, flags);
+	spin_lock_irq(q->queue_lock);
 	blk_start_queueing(q);
-	spin_unlock_irqrestore(q->queue_lock, flags);
+	spin_unlock_irq(q->queue_lock);
 }
 
 /*
diff -urN linux-2.6.30-rc2/block/elevator.c linux-2.6.30-rc3/block/elevator.c
--- linux-2.6.30-rc2/block/elevator.c	2009-04-22 03:29:10.563931403 +0000
+++ linux-2.6.30-rc3/block/elevator.c	2009-04-22 03:29:16.599928550 +0000
@@ -590,7 +590,7 @@
 /*
  * Call with queue lock held, interrupts disabled
  */
-void elv_quisce_start(struct request_queue *q)
+void elv_quiesce_start(struct request_queue *q)
 {
 	queue_flag_set(QUEUE_FLAG_ELVSWITCH, q);
 
@@ -607,7 +607,7 @@
 	}
 }
 
-void elv_quisce_end(struct request_queue *q)
+void elv_quiesce_end(struct request_queue *q)
 {
 	queue_flag_clear(QUEUE_FLAG_ELVSWITCH, q);
 }
@@ -1126,7 +1126,7 @@
 	 * Turn on BYPASS and drain all requests w/ elevator private data
 	 */
 	spin_lock_irq(q->queue_lock);
-	elv_quisce_start(q);
+	elv_quiesce_start(q);
 
 	/*
 	 * Remember old elevator.
@@ -1150,7 +1150,7 @@
 	 */
 	elevator_exit(old_elevator);
 	spin_lock_irq(q->queue_lock);
-	elv_quisce_end(q);
+	elv_quiesce_end(q);
 	spin_unlock_irq(q->queue_lock);
 
 	blk_add_trace_msg(q, "elv switch: %s", e->elevator_type->elevator_name);
diff -urN linux-2.6.30-rc2/block/ioctl.c linux-2.6.30-rc3/block/ioctl.c
--- linux-2.6.30-rc2/block/ioctl.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/block/ioctl.c	2009-04-22 03:29:16.599928550 +0000
@@ -146,8 +146,6 @@
 		struct bio *bio;
 
 		bio = bio_alloc(GFP_KERNEL, 0);
-		if (!bio)
-			return -ENOMEM;
 
 		bio->bi_end_io = blk_ioc_discard_endio;
 		bio->bi_bdev = bdev;
diff -urN linux-2.6.30-rc2/block/scsi_ioctl.c linux-2.6.30-rc3/block/scsi_ioctl.c
--- linux-2.6.30-rc2/block/scsi_ioctl.c	2009-04-22 03:29:10.563931403 +0000
+++ linux-2.6.30-rc3/block/scsi_ioctl.c	2009-04-22 03:29:16.599928550 +0000
@@ -217,7 +217,7 @@
 static int blk_complete_sghdr_rq(struct request *rq, struct sg_io_hdr *hdr,
 				 struct bio *bio)
 {
-	int ret = 0;
+	int r, ret = 0;
 
 	/*
 	 * fill in all the output members
@@ -242,7 +242,9 @@
 			ret = -EFAULT;
 	}
 
-	blk_rq_unmap_user(bio);
+	r = blk_rq_unmap_user(bio);
+	if (!ret)
+		ret = r;
 	blk_put_request(rq);
 
 	return ret;
diff -urN linux-2.6.30-rc2/drivers/acpi/sleep.c linux-2.6.30-rc3/drivers/acpi/sleep.c
--- linux-2.6.30-rc2/drivers/acpi/sleep.c	2009-04-22 03:29:10.592931420 +0000
+++ linux-2.6.30-rc3/drivers/acpi/sleep.c	2009-04-22 03:29:16.628931435 +0000
@@ -300,9 +300,9 @@
 static struct platform_suspend_ops acpi_suspend_ops = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin,
-	.prepare = acpi_pm_prepare,
+	.prepare_late = acpi_pm_prepare,
 	.enter = acpi_suspend_enter,
-	.finish = acpi_pm_finish,
+	.wake = acpi_pm_finish,
 	.end = acpi_pm_end,
 };
 
@@ -328,9 +328,9 @@
 static struct platform_suspend_ops acpi_suspend_ops_old = {
 	.valid = acpi_suspend_state_valid,
 	.begin = acpi_suspend_begin_old,
-	.prepare = acpi_pm_disable_gpes,
+	.prepare_late = acpi_pm_disable_gpes,
 	.enter = acpi_suspend_enter,
-	.finish = acpi_pm_finish,
+	.wake = acpi_pm_finish,
 	.end = acpi_pm_end,
 	.recover = acpi_pm_finish,
 };
diff -urN linux-2.6.30-rc2/drivers/ata/libata-core.c linux-2.6.30-rc3/drivers/ata/libata-core.c
--- linux-2.6.30-rc2/drivers/ata/libata-core.c	2009-04-22 03:29:10.597931390 +0000
+++ linux-2.6.30-rc3/drivers/ata/libata-core.c	2009-04-22 03:29:16.633931207 +0000
@@ -1231,6 +1231,9 @@
 	 *
 	 * We follow the current spec and consider that 0x69/0x96
 	 * identifies a port multiplier and 0x3c/0xc3 a SEMB device.
+	 * Unfortunately, WDC WD1600JS-62MHB5 (a hard drive) reports
+	 * SEMB signature.  This is worked around in
+	 * ata_dev_read_id().
 	 */
 	if ((tf->lbam == 0) && (tf->lbah == 0)) {
 		DPRINTK("found ATA device by sig\n");
@@ -1248,8 +1251,8 @@
 	}
 
 	if ((tf->lbam == 0x3c) && (tf->lbah == 0xc3)) {
-		printk(KERN_INFO "ata: SEMB device ignored\n");
-		return ATA_DEV_SEMB_UNSUP; /* not yet */
+		DPRINTK("found SEMB device by sig (could be ATA device)\n");
+		return ATA_DEV_SEMB;
 	}
 
 	DPRINTK("unknown device\n");
@@ -1653,8 +1656,8 @@
 		/*
 		 *	Process compact flash extended modes
 		 */
-		int pio = id[163] & 0x7;
-		int dma = (id[163] >> 3) & 7;
+		int pio = (id[ATA_ID_CFA_MODES] >> 0) & 0x7;
+		int dma = (id[ATA_ID_CFA_MODES] >> 3) & 0x7;
 
 		if (pio)
 			pio_mask |= (1 << 5);
@@ -2080,6 +2083,7 @@
 	struct ata_taskfile tf;
 	unsigned int err_mask = 0;
 	const char *reason;
+	bool is_semb = class == ATA_DEV_SEMB;
 	int may_fallback = 1, tried_spinup = 0;
 	int rc;
 
@@ -2090,6 +2094,8 @@
 	ata_tf_init(dev, &tf);
 
 	switch (class) {
+	case ATA_DEV_SEMB:
+		class = ATA_DEV_ATA;	/* some hard drives report SEMB sig */
 	case ATA_DEV_ATA:
 		tf.command = ATA_CMD_ID_ATA;
 		break;
@@ -2126,6 +2132,14 @@
 			return -ENOENT;
 		}
 
+		if (is_semb) {
+			ata_dev_printk(dev, KERN_INFO, "IDENTIFY failed on "
+				       "device w/ SEMB sig, disabled\n");
+			/* SEMB is not supported yet */
+			*p_class = ATA_DEV_SEMB_UNSUP;
+			return 0;
+		}
+
 		if ((err_mask == AC_ERR_DEV) && (tf.feature & ATA_ABORTED)) {
 			/* Device or controller might have reported
 			 * the wrong device class.  Give a shot at the
@@ -2412,7 +2426,8 @@
 	/* ATA-specific feature tests */
 	if (dev->class == ATA_DEV_ATA) {
 		if (ata_id_is_cfa(id)) {
-			if (id[162] & 1) /* CPRM may make this media unusable */
+			/* CPRM may make this media unusable */
+			if (id[ATA_ID_CFA_KEY_MGMT] & 1)
 				ata_dev_printk(dev, KERN_WARNING,
 					       "supports DRM functions and may "
 					       "not be fully accessable.\n");
diff -urN linux-2.6.30-rc2/drivers/ata/libata-scsi.c linux-2.6.30-rc3/drivers/ata/libata-scsi.c
--- linux-2.6.30-rc2/drivers/ata/libata-scsi.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/ata/libata-scsi.c	2009-04-22 03:29:16.634931386 +0000
@@ -647,23 +647,45 @@
 	return rc;
 }
 
+static int ata_ioc32(struct ata_port *ap)
+{
+	if (ap->flags & ATA_FLAG_PIO_DMA)
+		return 1;
+	if (ap->pflags & ATA_PFLAG_PIO32)
+		return 1;
+	return 0;
+}
+
 int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *scsidev,
 		     int cmd, void __user *arg)
 {
 	int val = -EINVAL, rc = -EINVAL;
+	unsigned long flags;
 
 	switch (cmd) {
 	case ATA_IOC_GET_IO32:
-		val = 0;
+		spin_lock_irqsave(ap->lock, flags);
+		val = ata_ioc32(ap);
+		spin_unlock_irqrestore(ap->lock, flags);
 		if (copy_to_user(arg, &val, 1))
 			return -EFAULT;
 		return 0;
 
 	case ATA_IOC_SET_IO32:
 		val = (unsigned long) arg;
-		if (val != 0)
-			return -EINVAL;
-		return 0;
+		rc = 0;
+		spin_lock_irqsave(ap->lock, flags);
+		if (ap->pflags & ATA_PFLAG_PIO32CHANGE) {
+			if (val)
+				ap->pflags |= ATA_PFLAG_PIO32;
+			else
+				ap->pflags &= ~ATA_PFLAG_PIO32;
+		} else {
+			if (val != ata_ioc32(ap))
+				rc = -EINVAL;
+		}
+		spin_unlock_irqrestore(ap->lock, flags);
+		return rc;
 
 	case HDIO_GET_IDENTITY:
 		return ata_get_identity(ap, scsidev, arg);
diff -urN linux-2.6.30-rc2/drivers/ata/libata-sff.c linux-2.6.30-rc3/drivers/ata/libata-sff.c
--- linux-2.6.30-rc2/drivers/ata/libata-sff.c	2009-04-22 03:29:10.598931491 +0000
+++ linux-2.6.30-rc3/drivers/ata/libata-sff.c	2009-04-22 03:29:16.635931454 +0000
@@ -87,6 +87,7 @@
 	.inherits		= &ata_bmdma_port_ops,
 
 	.sff_data_xfer		= ata_sff_data_xfer32,
+	.port_start		= ata_sff_port_start32,
 };
 EXPORT_SYMBOL_GPL(ata_bmdma32_port_ops);
 
@@ -769,6 +770,9 @@
 	void __iomem *data_addr = ap->ioaddr.data_addr;
 	unsigned int words = buflen >> 2;
 	int slop = buflen & 3;
+	
+	if (!(ap->pflags & ATA_PFLAG_PIO32))
+		return ata_sff_data_xfer(dev, buf, buflen, rw);
 
 	/* Transfer multiple of 4 bytes */
 	if (rw == READ)
@@ -2402,6 +2406,29 @@
 EXPORT_SYMBOL_GPL(ata_sff_port_start);
 
 /**
+ *	ata_sff_port_start32 - Set port up for dma.
+ *	@ap: Port to initialize
+ *
+ *	Called just after data structures for each port are
+ *	initialized.  Allocates space for PRD table if the device
+ *	is DMA capable SFF.
+ *
+ *	May be used as the port_start() entry in ata_port_operations for
+ *	devices that are capable of 32bit PIO.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+int ata_sff_port_start32(struct ata_port *ap)
+{
+	ap->pflags |= ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE;
+	if (ap->ioaddr.bmdma_addr)
+		return ata_port_start(ap);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ata_sff_port_start32);
+
+/**
  *	ata_sff_std_ports - initialize ioaddr with standard port offsets.
  *	@ioaddr: IO address structure to be initialized
  *
diff -urN linux-2.6.30-rc2/drivers/ata/pata_hpt37x.c linux-2.6.30-rc3/drivers/ata/pata_hpt37x.c
--- linux-2.6.30-rc2/drivers/ata/pata_hpt37x.c	2009-04-22 03:29:10.601931379 +0000
+++ linux-2.6.30-rc3/drivers/ata/pata_hpt37x.c	2009-04-22 03:29:16.638931414 +0000
@@ -8,7 +8,7 @@
  * Copyright (C) 1999-2003		Andre Hedrick <andre@linux-ide.org>
  * Portions Copyright (C) 2001	        Sun Microsystems, Inc.
  * Portions Copyright (C) 2003		Red Hat Inc
- * Portions Copyright (C) 2005-2007	MontaVista Software, Inc.
+ * Portions Copyright (C) 2005-2009	MontaVista Software, Inc.
  *
  * TODO
  *	Look into engine reset on timeout errors. Should not be	required.
@@ -24,7 +24,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_hpt37x"
-#define DRV_VERSION	"0.6.11"
+#define DRV_VERSION	"0.6.12"
 
 struct hpt_clock {
 	u8	xfer_speed;
@@ -445,23 +445,6 @@
 }
 
 /**
- *	hpt370_bmdma_start		-	DMA engine begin
- *	@qc: ATA command
- *
- *	The 370 and 370A want us to reset the DMA engine each time we
- *	use it. The 372 and later are fine.
- */
-
-static void hpt370_bmdma_start(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
-	pci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);
-	udelay(10);
-	ata_bmdma_start(qc);
-}
-
-/**
  *	hpt370_bmdma_end		-	DMA engine stop
  *	@qc: ATA command
  *
@@ -598,7 +581,6 @@
 static struct ata_port_operations hpt370_port_ops = {
 	.inherits	= &ata_bmdma_port_ops,
 
-	.bmdma_start 	= hpt370_bmdma_start,
 	.bmdma_stop	= hpt370_bmdma_stop,
 
 	.mode_filter	= hpt370_filter,
diff -urN linux-2.6.30-rc2/drivers/ata/pata_legacy.c linux-2.6.30-rc3/drivers/ata/pata_legacy.c
--- linux-2.6.30-rc2/drivers/ata/pata_legacy.c	2009-04-22 03:29:10.602931417 +0000
+++ linux-2.6.30-rc3/drivers/ata/pata_legacy.c	2009-04-22 03:29:16.640931495 +0000
@@ -108,6 +108,7 @@
 	struct ata_port_operations *ops;
 	unsigned int pio_mask;
 	unsigned int flags;
+	unsigned int pflags;
 	int (*setup)(struct platform_device *, struct legacy_probe *probe,
 		struct legacy_data *data);
 };
@@ -284,9 +285,11 @@
 			unsigned char *buf, unsigned int buflen, int rw)
 {
 	int slop = buflen & 3;
+	struct ata_port *ap = dev->link->ap;
+
 	/* 32bit I/O capable *and* we need to write a whole number of dwords */
-	if (ata_id_has_dword_io(dev->id) && (slop == 0 || slop == 3)) {
-		struct ata_port *ap = dev->link->ap;
+	if (ata_id_has_dword_io(dev->id) && (slop == 0 || slop == 3)
+					&& (ap->pflags & ATA_PFLAG_PIO32)) {
 		unsigned long flags;
 
 		local_irq_save(flags);
@@ -736,7 +739,8 @@
 	struct ata_port *ap = adev->link->ap;
 	int slop = buflen & 3;
 
-	if (ata_id_has_dword_io(adev->id) && (slop == 0 || slop == 3)) {
+	if (ata_id_has_dword_io(adev->id) && (slop == 0 || slop == 3)
+					&& (ap->pflags & ATA_PFLAG_PIO32)) {
 		if (rw == WRITE)
 			iowrite32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);
 		else
@@ -858,27 +862,30 @@
 
 static struct legacy_controller controllers[] = {
 	{"BIOS",	&legacy_port_ops, 	0x1F,
-						ATA_FLAG_NO_IORDY,	NULL },
+			ATA_FLAG_NO_IORDY,	0,			NULL },
 	{"Snooping", 	&simple_port_ops, 	0x1F,
-						0	       ,	NULL },
+			0,			0,			NULL },
 	{"PDC20230",	&pdc20230_port_ops,	0x7,
-						ATA_FLAG_NO_IORDY,	NULL },
+			ATA_FLAG_NO_IORDY,
+			ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE,	NULL },
 	{"HT6560A",	&ht6560a_port_ops,	0x07,
-						ATA_FLAG_NO_IORDY,	NULL },
+			ATA_FLAG_NO_IORDY,	0,			NULL },
 	{"HT6560B",	&ht6560b_port_ops,	0x1F,
-						ATA_FLAG_NO_IORDY,	NULL },
+			ATA_FLAG_NO_IORDY,	0,			NULL },
 	{"OPTI82C611A",	&opti82c611a_port_ops,	0x0F,
-						0	       ,	NULL },
+			0,			0,			NULL },
 	{"OPTI82C46X",	&opti82c46x_port_ops,	0x0F,
-						0	       ,	NULL },
+			0,			0,			NULL },
 	{"QDI6500",	&qdi6500_port_ops,	0x07,
-					ATA_FLAG_NO_IORDY,	qdi_port },
+			ATA_FLAG_NO_IORDY,
+			ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE,    qdi_port },
 	{"QDI6580",	&qdi6580_port_ops,	0x1F,
-					0	       ,	qdi_port },
+			0, ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE, qdi_port },
 	{"QDI6580DP",	&qdi6580dp_port_ops,	0x1F,
-					0	       ,	qdi_port },
+			0, ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE, qdi_port },
 	{"W83759A",	&winbond_port_ops,	0x1F,
-					0	       ,	winbond_port }
+			0, ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE,
+								winbond_port }
 };
 
 /**
@@ -1008,6 +1015,7 @@
 	ap->ops = ops;
 	ap->pio_mask = pio_modes;
 	ap->flags |= ATA_FLAG_SLAVE_POSS | iordy;
+	ap->pflags |= controller->pflags;
 	ap->ioaddr.cmd_addr = io_addr;
 	ap->ioaddr.altstatus_addr = ctrl_addr;
 	ap->ioaddr.ctl_addr = ctrl_addr;
@@ -1032,6 +1040,7 @@
 			return 0;
 		}
 	}
+	ata_host_detach(host);
 fail:
 	platform_device_unregister(pdev);
 	return ret;
diff -urN linux-2.6.30-rc2/drivers/ata/pata_ninja32.c linux-2.6.30-rc3/drivers/ata/pata_ninja32.c
--- linux-2.6.30-rc2/drivers/ata/pata_ninja32.c	2009-04-22 03:29:10.603931457 +0000
+++ linux-2.6.30-rc3/drivers/ata/pata_ninja32.c	2009-04-22 03:29:16.640931495 +0000
@@ -44,7 +44,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "pata_ninja32"
-#define DRV_VERSION "0.1.3"
+#define DRV_VERSION "0.1.5"
 
 
 /**
@@ -86,6 +86,7 @@
 	.sff_dev_select = ninja32_dev_select,
 	.cable_detect	= ata_cable_40wire,
 	.set_piomode	= ninja32_set_piomode,
+	.sff_data_xfer	= ata_sff_data_xfer32
 };
 
 static void ninja32_program(void __iomem *base)
@@ -144,6 +145,7 @@
 	ap->ioaddr.altstatus_addr = base + 0x1E;
 	ap->ioaddr.bmdma_addr = base;
 	ata_sff_std_ports(&ap->ioaddr);
+	ap->pflags = ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE;
 
 	ninja32_program(base);
 	/* FIXME: Should we disable them at remove ? */
diff -urN linux-2.6.30-rc2/drivers/ata/pata_via.c linux-2.6.30-rc3/drivers/ata/pata_via.c
--- linux-2.6.30-rc2/drivers/ata/pata_via.c	2009-04-22 03:29:10.607931461 +0000
+++ linux-2.6.30-rc3/drivers/ata/pata_via.c	2009-04-22 03:29:16.644931613 +0000
@@ -62,7 +62,7 @@
 #include <linux/dmi.h>
 
 #define DRV_NAME "pata_via"
-#define DRV_VERSION "0.3.3"
+#define DRV_VERSION "0.3.4"
 
 /*
  *	The following comes directly from Vojtech Pavlik's ide/pci/via82cxxx
@@ -136,6 +136,9 @@
 	{ NULL }
 };
 
+struct via_port {
+	u8 cached_device;
+};
 
 /*
  *	Cable special cases
@@ -346,14 +349,70 @@
  */
 static void via_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)
 {
-	struct ata_taskfile tmp_tf;
-
-	if (ap->ctl != ap->last_ctl && !(tf->flags & ATA_TFLAG_DEVICE)) {
-		tmp_tf = *tf;
-		tmp_tf.flags |= ATA_TFLAG_DEVICE;
-		tf = &tmp_tf;
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	struct via_port *vp = ap->private_data;
+	unsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;
+	int newctl = 0;
+
+	if (tf->ctl != ap->last_ctl) {
+		iowrite8(tf->ctl, ioaddr->ctl_addr);
+		ap->last_ctl = tf->ctl;
+		ata_wait_idle(ap);
+		newctl = 1;
+	}
+
+	if (tf->flags & ATA_TFLAG_DEVICE) {
+		iowrite8(tf->device, ioaddr->device_addr);
+		vp->cached_device = tf->device;
+	} else if (newctl)
+		iowrite8(vp->cached_device, ioaddr->device_addr);
+
+	if (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {
+		WARN_ON_ONCE(!ioaddr->ctl_addr);
+		iowrite8(tf->hob_feature, ioaddr->feature_addr);
+		iowrite8(tf->hob_nsect, ioaddr->nsect_addr);
+		iowrite8(tf->hob_lbal, ioaddr->lbal_addr);
+		iowrite8(tf->hob_lbam, ioaddr->lbam_addr);
+		iowrite8(tf->hob_lbah, ioaddr->lbah_addr);
+		VPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",
+			tf->hob_feature,
+			tf->hob_nsect,
+			tf->hob_lbal,
+			tf->hob_lbam,
+			tf->hob_lbah);
+	}
+
+	if (is_addr) {
+		iowrite8(tf->feature, ioaddr->feature_addr);
+		iowrite8(tf->nsect, ioaddr->nsect_addr);
+		iowrite8(tf->lbal, ioaddr->lbal_addr);
+		iowrite8(tf->lbam, ioaddr->lbam_addr);
+		iowrite8(tf->lbah, ioaddr->lbah_addr);
+		VPRINTK("feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X\n",
+			tf->feature,
+			tf->nsect,
+			tf->lbal,
+			tf->lbam,
+			tf->lbah);
 	}
-	ata_sff_tf_load(ap, tf);
+
+	ata_wait_idle(ap);
+}
+
+static int via_port_start(struct ata_port *ap)
+{
+	struct via_port *vp;
+	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
+
+	int ret = ata_sff_port_start(ap);
+	if (ret < 0)
+		return ret;
+
+	vp = devm_kzalloc(&pdev->dev, sizeof(struct via_port), GFP_KERNEL);
+	if (vp == NULL)
+		return -ENOMEM;
+	ap->private_data = vp;
+	return 0;
 }
 
 static struct scsi_host_template via_sht = {
@@ -367,6 +426,7 @@
 	.set_dmamode	= via_set_dmamode,
 	.prereset	= via_pre_reset,
 	.sff_tf_load	= via_tf_load,
+	.port_start	= via_port_start,
 };
 
 static struct ata_port_operations via_port_ops_noirq = {
diff -urN linux-2.6.30-rc2/drivers/ata/sata_mv.c linux-2.6.30-rc3/drivers/ata/sata_mv.c
--- linux-2.6.30-rc2/drivers/ata/sata_mv.c	2009-04-22 03:29:10.609931279 +0000
+++ linux-2.6.30-rc3/drivers/ata/sata_mv.c	2009-04-22 03:29:16.646931479 +0000
@@ -1881,6 +1881,39 @@
 	return status;
 }
 
+static void mv_rw_multi_errata_sata24(struct ata_queued_cmd *qc)
+{
+	struct ata_taskfile *tf = &qc->tf;
+	/*
+	 * Workaround for 88SX60x1 FEr SATA#24.
+	 *
+	 * Chip may corrupt WRITEs if multi_count >= 4kB.
+	 * Note that READs are unaffected.
+	 *
+	 * It's not clear if this errata really means "4K bytes",
+	 * or if it always happens for multi_count > 7
+	 * regardless of device sector_size.
+	 *
+	 * So, for safety, any write with multi_count > 7
+	 * gets converted here into a regular PIO write instead:
+	 */
+	if ((tf->flags & ATA_TFLAG_WRITE) && is_multi_taskfile(tf)) {
+		if (qc->dev->multi_count > 7) {
+			switch (tf->command) {
+			case ATA_CMD_WRITE_MULTI:
+				tf->command = ATA_CMD_PIO_WRITE;
+				break;
+			case ATA_CMD_WRITE_MULTI_FUA_EXT:
+				tf->flags &= ~ATA_TFLAG_FUA; /* ugh */
+				/* fall through */
+			case ATA_CMD_WRITE_MULTI_EXT:
+				tf->command = ATA_CMD_PIO_WRITE_EXT;
+				break;
+			}
+		}
+	}
+}
+
 /**
  *      mv_qc_prep - Host specific command preparation.
  *      @qc: queued command to prepare
@@ -1898,17 +1931,24 @@
 	struct ata_port *ap = qc->ap;
 	struct mv_port_priv *pp = ap->private_data;
 	__le16 *cw;
-	struct ata_taskfile *tf;
+	struct ata_taskfile *tf = &qc->tf;
 	u16 flags = 0;
 	unsigned in_index;
 
-	if ((qc->tf.protocol != ATA_PROT_DMA) &&
-	    (qc->tf.protocol != ATA_PROT_NCQ))
+	switch (tf->protocol) {
+	case ATA_PROT_DMA:
+	case ATA_PROT_NCQ:
+		break;	/* continue below */
+	case ATA_PROT_PIO:
+		mv_rw_multi_errata_sata24(qc);
+		return;
+	default:
 		return;
+	}
 
 	/* Fill in command request block
 	 */
-	if (!(qc->tf.flags & ATA_TFLAG_WRITE))
+	if (!(tf->flags & ATA_TFLAG_WRITE))
 		flags |= CRQB_FLAG_READ;
 	WARN_ON(MV_MAX_Q_DEPTH <= qc->tag);
 	flags |= qc->tag << CRQB_TAG_SHIFT;
@@ -1924,7 +1964,6 @@
 	pp->crqb[in_index].ctrl_flags = cpu_to_le16(flags);
 
 	cw = &pp->crqb[in_index].ata_cmd[0];
-	tf = &qc->tf;
 
 	/* Sadly, the CRQB cannot accomodate all registers--there are
 	 * only 11 bytes...so we must pick and choose required
@@ -1990,16 +2029,16 @@
 	struct ata_port *ap = qc->ap;
 	struct mv_port_priv *pp = ap->private_data;
 	struct mv_crqb_iie *crqb;
-	struct ata_taskfile *tf;
+	struct ata_taskfile *tf = &qc->tf;
 	unsigned in_index;
 	u32 flags = 0;
 
-	if ((qc->tf.protocol != ATA_PROT_DMA) &&
-	    (qc->tf.protocol != ATA_PROT_NCQ))
+	if ((tf->protocol != ATA_PROT_DMA) &&
+	    (tf->protocol != ATA_PROT_NCQ))
 		return;
 
 	/* Fill in Gen IIE command request block */
-	if (!(qc->tf.flags & ATA_TFLAG_WRITE))
+	if (!(tf->flags & ATA_TFLAG_WRITE))
 		flags |= CRQB_FLAG_READ;
 
 	WARN_ON(MV_MAX_Q_DEPTH <= qc->tag);
@@ -2015,7 +2054,6 @@
 	crqb->addr_hi = cpu_to_le32((pp->sg_tbl_dma[qc->tag] >> 16) >> 16);
 	crqb->flags = cpu_to_le32(flags);
 
-	tf = &qc->tf;
 	crqb->ata_cmd[0] = cpu_to_le32(
 			(tf->command << 16) |
 			(tf->feature << 24)
diff -urN linux-2.6.30-rc2/drivers/base/base.h linux-2.6.30-rc3/drivers/base/base.h
--- linux-2.6.30-rc2/drivers/base/base.h	2009-04-22 03:29:10.615931403 +0000
+++ linux-2.6.30-rc3/drivers/base/base.h	2009-04-22 03:29:16.652931588 +0000
@@ -115,7 +115,7 @@
 static inline int driver_match_device(struct device_driver *drv,
 				      struct device *dev)
 {
-	return drv->bus->match && drv->bus->match(dev, drv);
+	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
 }
 
 extern void sysdev_shutdown(void);
diff -urN linux-2.6.30-rc2/drivers/base/core.c linux-2.6.30-rc3/drivers/base/core.c
--- linux-2.6.30-rc2/drivers/base/core.c	2009-04-22 03:29:10.616931423 +0000
+++ linux-2.6.30-rc3/drivers/base/core.c	2009-04-22 03:29:16.653931752 +0000
@@ -891,7 +891,8 @@
 		set_dev_node(dev, dev_to_node(parent));
 
 	/* first, register with generic layer. */
-	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev_name(dev));
+	/* we require the name to be set before, and pass NULL */
+	error = kobject_add(&dev->kobj, dev->kobj.parent, NULL);
 	if (error)
 		goto Error;
 
@@ -1142,6 +1143,9 @@
 	struct device *child;
 	int error = 0;
 
+	if (!parent->p)
+		return 0;
+
 	klist_iter_init(&parent->p->klist_children, &i);
 	while ((child = next_device(&i)) && !error)
 		error = fn(child, data);
diff -urN linux-2.6.30-rc2/drivers/base/dd.c linux-2.6.30-rc3/drivers/base/dd.c
--- linux-2.6.30-rc2/drivers/base/dd.c	2009-04-22 03:29:10.616931423 +0000
+++ linux-2.6.30-rc3/drivers/base/dd.c	2009-04-22 03:29:16.654830259 +0000
@@ -179,6 +179,7 @@
 	wait_event(probe_waitqueue, atomic_read(&probe_count) == 0);
 	async_synchronize_full();
 }
+EXPORT_SYMBOL_GPL(wait_for_device_probe);
 
 /**
  * driver_probe_device - attempt to bind device & driver together
diff -urN linux-2.6.30-rc2/drivers/base/platform.c linux-2.6.30-rc3/drivers/base/platform.c
--- linux-2.6.30-rc2/drivers/base/platform.c	2009-04-22 03:29:10.617931401 +0000
+++ linux-2.6.30-rc3/drivers/base/platform.c	2009-04-22 03:29:16.655931614 +0000
@@ -990,6 +990,8 @@
 {
 	int error;
 
+	early_platform_cleanup();
+
 	error = device_register(&platform_bus);
 	if (error)
 		return error;
@@ -1020,3 +1022,240 @@
 }
 EXPORT_SYMBOL_GPL(dma_get_required_mask);
 #endif
+
+static __initdata LIST_HEAD(early_platform_driver_list);
+static __initdata LIST_HEAD(early_platform_device_list);
+
+/**
+ * early_platform_driver_register
+ * @edrv: early_platform driver structure
+ * @buf: string passed from early_param()
+ */
+int __init early_platform_driver_register(struct early_platform_driver *epdrv,
+					  char *buf)
+{
+	unsigned long index;
+	int n;
+
+	/* Simply add the driver to the end of the global list.
+	 * Drivers will by default be put on the list in compiled-in order.
+	 */
+	if (!epdrv->list.next) {
+		INIT_LIST_HEAD(&epdrv->list);
+		list_add_tail(&epdrv->list, &early_platform_driver_list);
+	}
+
+	/* If the user has specified device then make sure the driver
+	 * gets prioritized. The driver of the last device specified on
+	 * command line will be put first on the list.
+	 */
+	n = strlen(epdrv->pdrv->driver.name);
+	if (buf && !strncmp(buf, epdrv->pdrv->driver.name, n)) {
+		list_move(&epdrv->list, &early_platform_driver_list);
+
+		if (!strcmp(buf, epdrv->pdrv->driver.name))
+			epdrv->requested_id = -1;
+		else if (buf[n] == '.' && strict_strtoul(&buf[n + 1], 10,
+							 &index) == 0)
+			epdrv->requested_id = index;
+		else
+			epdrv->requested_id = EARLY_PLATFORM_ID_ERROR;
+	}
+
+	return 0;
+}
+
+/**
+ * early_platform_add_devices - add a numbers of early platform devices
+ * @devs: array of early platform devices to add
+ * @num: number of early platform devices in array
+ */
+void __init early_platform_add_devices(struct platform_device **devs, int num)
+{
+	struct device *dev;
+	int i;
+
+	/* simply add the devices to list */
+	for (i = 0; i < num; i++) {
+		dev = &devs[i]->dev;
+
+		if (!dev->devres_head.next) {
+			INIT_LIST_HEAD(&dev->devres_head);
+			list_add_tail(&dev->devres_head,
+				      &early_platform_device_list);
+		}
+	}
+}
+
+/**
+ * early_platform_driver_register_all
+ * @class_str: string to identify early platform driver class
+ */
+void __init early_platform_driver_register_all(char *class_str)
+{
+	/* The "class_str" parameter may or may not be present on the kernel
+	 * command line. If it is present then there may be more than one
+	 * matching parameter.
+	 *
+	 * Since we register our early platform drivers using early_param()
+	 * we need to make sure that they also get registered in the case
+	 * when the parameter is missing from the kernel command line.
+	 *
+	 * We use parse_early_options() to make sure the early_param() gets
+	 * called at least once. The early_param() may be called more than
+	 * once since the name of the preferred device may be specified on
+	 * the kernel command line. early_platform_driver_register() handles
+	 * this case for us.
+	 */
+	parse_early_options(class_str);
+}
+
+/**
+ * early_platform_match
+ * @edrv: early platform driver structure
+ * @id: id to match against
+ */
+static  __init struct platform_device *
+early_platform_match(struct early_platform_driver *epdrv, int id)
+{
+	struct platform_device *pd;
+
+	list_for_each_entry(pd, &early_platform_device_list, dev.devres_head)
+		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
+			if (pd->id == id)
+				return pd;
+
+	return NULL;
+}
+
+/**
+ * early_platform_left
+ * @edrv: early platform driver structure
+ * @id: return true if id or above exists
+ */
+static  __init int early_platform_left(struct early_platform_driver *epdrv,
+				       int id)
+{
+	struct platform_device *pd;
+
+	list_for_each_entry(pd, &early_platform_device_list, dev.devres_head)
+		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
+			if (pd->id >= id)
+				return 1;
+
+	return 0;
+}
+
+/**
+ * early_platform_driver_probe_id
+ * @class_str: string to identify early platform driver class
+ * @id: id to match against
+ * @nr_probe: number of platform devices to successfully probe before exiting
+ */
+static int __init early_platform_driver_probe_id(char *class_str,
+						 int id,
+						 int nr_probe)
+{
+	struct early_platform_driver *epdrv;
+	struct platform_device *match;
+	int match_id;
+	int n = 0;
+	int left = 0;
+
+	list_for_each_entry(epdrv, &early_platform_driver_list, list) {
+		/* only use drivers matching our class_str */
+		if (strcmp(class_str, epdrv->class_str))
+			continue;
+
+		if (id == -2) {
+			match_id = epdrv->requested_id;
+			left = 1;
+
+		} else {
+			match_id = id;
+			left += early_platform_left(epdrv, id);
+
+			/* skip requested id */
+			switch (epdrv->requested_id) {
+			case EARLY_PLATFORM_ID_ERROR:
+			case EARLY_PLATFORM_ID_UNSET:
+				break;
+			default:
+				if (epdrv->requested_id == id)
+					match_id = EARLY_PLATFORM_ID_UNSET;
+			}
+		}
+
+		switch (match_id) {
+		case EARLY_PLATFORM_ID_ERROR:
+			pr_warning("%s: unable to parse %s parameter\n",
+				   class_str, epdrv->pdrv->driver.name);
+			/* fall-through */
+		case EARLY_PLATFORM_ID_UNSET:
+			match = NULL;
+			break;
+		default:
+			match = early_platform_match(epdrv, match_id);
+		}
+
+		if (match) {
+			if (epdrv->pdrv->probe(match))
+				pr_warning("%s: unable to probe %s early.\n",
+					   class_str, match->name);
+			else
+				n++;
+		}
+
+		if (n >= nr_probe)
+			break;
+	}
+
+	if (left)
+		return n;
+	else
+		return -ENODEV;
+}
+
+/**
+ * early_platform_driver_probe
+ * @class_str: string to identify early platform driver class
+ * @nr_probe: number of platform devices to successfully probe before exiting
+ * @user_only: only probe user specified early platform devices
+ */
+int __init early_platform_driver_probe(char *class_str,
+				       int nr_probe,
+				       int user_only)
+{
+	int k, n, i;
+
+	n = 0;
+	for (i = -2; n < nr_probe; i++) {
+		k = early_platform_driver_probe_id(class_str, i, nr_probe - n);
+
+		if (k < 0)
+			break;
+
+		n += k;
+
+		if (user_only)
+			break;
+	}
+
+	return n;
+}
+
+/**
+ * early_platform_cleanup - clean up early platform code
+ */
+void __init early_platform_cleanup(void)
+{
+	struct platform_device *pd, *pd2;
+
+	/* clean up the devres list used to chain devices */
+	list_for_each_entry_safe(pd, pd2, &early_platform_device_list,
+				 dev.devres_head) {
+		list_del(&pd->dev.devres_head);
+		memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
+	}
+}
+
diff -urN linux-2.6.30-rc2/drivers/block/brd.c linux-2.6.30-rc3/drivers/block/brd.c
--- linux-2.6.30-rc2/drivers/block/brd.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/block/brd.c	2009-04-22 03:29:16.658931422 +0000
@@ -275,8 +275,10 @@
 	if (rw == READ) {
 		copy_from_brd(mem + off, brd, sector, len);
 		flush_dcache_page(page);
-	} else
+	} else {
+		flush_dcache_page(page);
 		copy_to_brd(brd, mem + off, sector, len);
+	}
 	kunmap_atomic(mem, KM_USER0);
 
 out:
@@ -436,6 +438,7 @@
 	if (!brd->brd_queue)
 		goto out_free_dev;
 	blk_queue_make_request(brd->brd_queue, brd_make_request);
+	blk_queue_ordered(brd->brd_queue, QUEUE_ORDERED_TAG, NULL);
 	blk_queue_max_sectors(brd->brd_queue, 1024);
 	blk_queue_bounce_limit(brd->brd_queue, BLK_BOUNCE_ANY);
 
diff -urN linux-2.6.30-rc2/drivers/block/ub.c linux-2.6.30-rc3/drivers/block/ub.c
--- linux-2.6.30-rc2/drivers/block/ub.c	2009-04-22 03:29:10.626931386 +0000
+++ linux-2.6.30-rc3/drivers/block/ub.c	2009-04-22 03:29:16.663931430 +0000
@@ -1025,6 +1025,7 @@
 {
 	struct urb *urb = &sc->work_urb;
 	struct bulk_cs_wrap *bcs;
+	int endp;
 	int len;
 	int rc;
 
@@ -1033,6 +1034,10 @@
 		return;
 	}
 
+	endp = usb_pipeendpoint(sc->last_pipe);
+	if (usb_pipein(sc->last_pipe))
+		endp |= USB_DIR_IN;
+
 	if (cmd->state == UB_CMDST_CLEAR) {
 		if (urb->status == -EPIPE) {
 			/*
@@ -1048,9 +1053,7 @@
 		 * We ignore the result for the halt clear.
 		 */
 
-		/* reset the endpoint toggle */
-		usb_settoggle(sc->dev, usb_pipeendpoint(sc->last_pipe),
-			usb_pipeout(sc->last_pipe), 0);
+		usb_reset_endpoint(sc->dev, endp);
 
 		ub_state_sense(sc, cmd);
 
@@ -1065,9 +1068,7 @@
 		 * We ignore the result for the halt clear.
 		 */
 
-		/* reset the endpoint toggle */
-		usb_settoggle(sc->dev, usb_pipeendpoint(sc->last_pipe),
-			usb_pipeout(sc->last_pipe), 0);
+		usb_reset_endpoint(sc->dev, endp);
 
 		ub_state_stat(sc, cmd);
 
@@ -1082,9 +1083,7 @@
 		 * We ignore the result for the halt clear.
 		 */
 
-		/* reset the endpoint toggle */
-		usb_settoggle(sc->dev, usb_pipeendpoint(sc->last_pipe),
-			usb_pipeout(sc->last_pipe), 0);
+		usb_reset_endpoint(sc->dev, endp);
 
 		ub_state_stat_counted(sc, cmd);
 
@@ -2119,8 +2118,7 @@
 	del_timer_sync(&timer);
 	usb_kill_urb(&sc->work_urb);
 
-	/* reset the endpoint toggle */
-	usb_settoggle(sc->dev, endp, usb_pipeout(sc->last_pipe), 0);
+	usb_reset_endpoint(sc->dev, endp);
 
 	return 0;
 }
diff -urN linux-2.6.30-rc2/drivers/char/agp/generic.c linux-2.6.30-rc3/drivers/char/agp/generic.c
--- linux-2.6.30-rc2/drivers/char/agp/generic.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/char/agp/generic.c	2009-04-22 03:29:16.665931431 +0000
@@ -1226,7 +1226,7 @@
 	int i, ret = -ENOMEM;
 
 	for (i = 0; i < num_pages; i++) {
-		page = alloc_page(GFP_KERNEL | GFP_DMA32);
+		page = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);
 		/* agp_free_memory() needs gart address */
 		if (page == NULL)
 			goto out;
@@ -1257,7 +1257,7 @@
 {
 	struct page * page;
 
-	page = alloc_page(GFP_KERNEL | GFP_DMA32);
+	page = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);
 	if (page == NULL)
 		return NULL;
 
diff -urN linux-2.6.30-rc2/drivers/char/hpet.c linux-2.6.30-rc3/drivers/char/hpet.c
--- linux-2.6.30-rc2/drivers/char/hpet.c	2009-04-22 03:29:10.630931411 +0000
+++ linux-2.6.30-rc3/drivers/char/hpet.c	2009-04-22 03:29:16.668931271 +0000
@@ -72,7 +72,7 @@
 #ifdef CONFIG_IA64
 static void __iomem *hpet_mctr;
 
-static cycle_t read_hpet(void)
+static cycle_t read_hpet(struct clocksource *cs)
 {
 	return (cycle_t)read_counter((void __iomem *)hpet_mctr);
 }
diff -urN linux-2.6.30-rc2/drivers/char/ipmi/ipmi_msghandler.c linux-2.6.30-rc3/drivers/char/ipmi/ipmi_msghandler.c
--- linux-2.6.30-rc2/drivers/char/ipmi/ipmi_msghandler.c	2009-04-22 03:29:10.633556377 +0000
+++ linux-2.6.30-rc3/drivers/char/ipmi/ipmi_msghandler.c	2009-04-22 03:29:16.671931333 +0000
@@ -285,6 +285,11 @@
 	/* Events that were received with the proper format. */
 	IPMI_STAT_events,
 
+	/* Retransmissions on IPMB that failed. */
+	IPMI_STAT_dropped_rexmit_ipmb_commands,
+
+	/* Retransmissions on LAN that failed. */
+	IPMI_STAT_dropped_rexmit_lan_commands,
 
 	/* This *must* remain last, add new values above this. */
 	IPMI_NUM_STATS
@@ -445,6 +450,20 @@
 #define ipmi_get_stat(intf, stat) \
 	((unsigned int) atomic_read(&(intf)->stats[IPMI_STAT_ ## stat]))
 
+static int is_lan_addr(struct ipmi_addr *addr)
+{
+	return addr->addr_type == IPMI_LAN_ADDR_TYPE;
+}
+
+static int is_ipmb_addr(struct ipmi_addr *addr)
+{
+	return addr->addr_type == IPMI_IPMB_ADDR_TYPE;
+}
+
+static int is_ipmb_bcast_addr(struct ipmi_addr *addr)
+{
+	return addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE;
+}
 
 static void free_recv_msg_list(struct list_head *q)
 {
@@ -601,8 +620,7 @@
 		return (smi_addr1->lun == smi_addr2->lun);
 	}
 
-	if ((addr1->addr_type == IPMI_IPMB_ADDR_TYPE)
-	    || (addr1->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE)) {
+	if (is_ipmb_addr(addr1) || is_ipmb_bcast_addr(addr1)) {
 		struct ipmi_ipmb_addr *ipmb_addr1
 		    = (struct ipmi_ipmb_addr *) addr1;
 		struct ipmi_ipmb_addr *ipmb_addr2
@@ -612,7 +630,7 @@
 			&& (ipmb_addr1->lun == ipmb_addr2->lun));
 	}
 
-	if (addr1->addr_type == IPMI_LAN_ADDR_TYPE) {
+	if (is_lan_addr(addr1)) {
 		struct ipmi_lan_addr *lan_addr1
 			= (struct ipmi_lan_addr *) addr1;
 		struct ipmi_lan_addr *lan_addr2
@@ -644,14 +662,13 @@
 	    || (addr->channel < 0))
 		return -EINVAL;
 
-	if ((addr->addr_type == IPMI_IPMB_ADDR_TYPE)
-	    || (addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE)) {
+	if (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {
 		if (len < sizeof(struct ipmi_ipmb_addr))
 			return -EINVAL;
 		return 0;
 	}
 
-	if (addr->addr_type == IPMI_LAN_ADDR_TYPE) {
+	if (is_lan_addr(addr)) {
 		if (len < sizeof(struct ipmi_lan_addr))
 			return -EINVAL;
 		return 0;
@@ -1503,8 +1520,7 @@
 			memcpy(&(smi_msg->data[2]), msg->data, msg->data_len);
 		smi_msg->data_size = msg->data_len + 2;
 		ipmi_inc_stat(intf, sent_local_commands);
-	} else if ((addr->addr_type == IPMI_IPMB_ADDR_TYPE)
-		   || (addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE)) {
+	} else if (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {
 		struct ipmi_ipmb_addr *ipmb_addr;
 		unsigned char         ipmb_seq;
 		long                  seqid;
@@ -1583,8 +1599,6 @@
 
 			spin_lock_irqsave(&(intf->seq_lock), flags);
 
-			ipmi_inc_stat(intf, sent_ipmb_commands);
-
 			/*
 			 * Create a sequence number with a 1 second
 			 * timeout and 4 retries.
@@ -1606,6 +1620,8 @@
 				goto out_err;
 			}
 
+			ipmi_inc_stat(intf, sent_ipmb_commands);
+
 			/*
 			 * Store the sequence number in the message,
 			 * so that when the send message response
@@ -1635,7 +1651,7 @@
 			 */
 			spin_unlock_irqrestore(&(intf->seq_lock), flags);
 		}
-	} else if (addr->addr_type == IPMI_LAN_ADDR_TYPE) {
+	} else if (is_lan_addr(addr)) {
 		struct ipmi_lan_addr  *lan_addr;
 		unsigned char         ipmb_seq;
 		long                  seqid;
@@ -1696,8 +1712,6 @@
 
 			spin_lock_irqsave(&(intf->seq_lock), flags);
 
-			ipmi_inc_stat(intf, sent_lan_commands);
-
 			/*
 			 * Create a sequence number with a 1 second
 			 * timeout and 4 retries.
@@ -1719,6 +1733,8 @@
 				goto out_err;
 			}
 
+			ipmi_inc_stat(intf, sent_lan_commands);
+
 			/*
 			 * Store the sequence number in the message,
 			 * so that when the send message response
@@ -1937,6 +1953,10 @@
 		       ipmi_get_stat(intf, invalid_events));
 	out += sprintf(out, "events:                      %u\n",
 		       ipmi_get_stat(intf, events));
+	out += sprintf(out, "failed rexmit LAN msgs:      %u\n",
+		       ipmi_get_stat(intf, dropped_rexmit_lan_commands));
+	out += sprintf(out, "failed rexmit IPMB msgs:     %u\n",
+		       ipmi_get_stat(intf, dropped_rexmit_ipmb_commands));
 
 	return (out - ((char *) page));
 }
@@ -3264,6 +3284,114 @@
 	return rv;
 }
 
+/*
+ * This routine will handle "Get Message" command responses with
+ * channels that use an OEM Medium. The message format belongs to
+ * the OEM.  See IPMI 2.0 specification, Chapter 6 and
+ * Chapter 22, sections 22.6 and 22.24 for more details.
+ */
+static int handle_oem_get_msg_cmd(ipmi_smi_t          intf,
+				  struct ipmi_smi_msg *msg)
+{
+	struct cmd_rcvr       *rcvr;
+	int                   rv = 0;
+	unsigned char         netfn;
+	unsigned char         cmd;
+	unsigned char         chan;
+	ipmi_user_t           user = NULL;
+	struct ipmi_system_interface_addr *smi_addr;
+	struct ipmi_recv_msg  *recv_msg;
+
+	/*
+	 * We expect the OEM SW to perform error checking
+	 * so we just do some basic sanity checks
+	 */
+	if (msg->rsp_size < 4) {
+		/* Message not big enough, just ignore it. */
+		ipmi_inc_stat(intf, invalid_commands);
+		return 0;
+	}
+
+	if (msg->rsp[2] != 0) {
+		/* An error getting the response, just ignore it. */
+		return 0;
+	}
+
+	/*
+	 * This is an OEM Message so the OEM needs to know how
+	 * handle the message. We do no interpretation.
+	 */
+	netfn = msg->rsp[0] >> 2;
+	cmd = msg->rsp[1];
+	chan = msg->rsp[3] & 0xf;
+
+	rcu_read_lock();
+	rcvr = find_cmd_rcvr(intf, netfn, cmd, chan);
+	if (rcvr) {
+		user = rcvr->user;
+		kref_get(&user->refcount);
+	} else
+		user = NULL;
+	rcu_read_unlock();
+
+	if (user == NULL) {
+		/* We didn't find a user, just give up. */
+		ipmi_inc_stat(intf, unhandled_commands);
+
+		/*
+		 * Don't do anything with these messages, just allow
+		 * them to be freed.
+		 */
+
+		rv = 0;
+	} else {
+		/* Deliver the message to the user. */
+		ipmi_inc_stat(intf, handled_commands);
+
+		recv_msg = ipmi_alloc_recv_msg();
+		if (!recv_msg) {
+			/*
+			 * We couldn't allocate memory for the
+			 * message, so requeue it for handling
+			 * later.
+			 */
+			rv = 1;
+			kref_put(&user->refcount, free_user);
+		} else {
+			/*
+			 * OEM Messages are expected to be delivered via
+			 * the system interface to SMS software.  We might
+			 * need to visit this again depending on OEM
+			 * requirements
+			 */
+			smi_addr = ((struct ipmi_system_interface_addr *)
+				    &(recv_msg->addr));
+			smi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;
+			smi_addr->channel = IPMI_BMC_CHANNEL;
+			smi_addr->lun = msg->rsp[0] & 3;
+
+			recv_msg->user = user;
+			recv_msg->user_msg_data = NULL;
+			recv_msg->recv_type = IPMI_OEM_RECV_TYPE;
+			recv_msg->msg.netfn = msg->rsp[0] >> 2;
+			recv_msg->msg.cmd = msg->rsp[1];
+			recv_msg->msg.data = recv_msg->msg_data;
+
+			/*
+			 * The message starts at byte 4 which follows the
+			 * the Channel Byte in the "GET MESSAGE" command
+			 */
+			recv_msg->msg.data_len = msg->rsp_size - 4;
+			memcpy(recv_msg->msg_data,
+			       &(msg->rsp[4]),
+			       msg->rsp_size - 4);
+			deliver_response(recv_msg);
+		}
+	}
+
+	return rv;
+}
+
 static void copy_event_into_recv_msg(struct ipmi_recv_msg *recv_msg,
 				     struct ipmi_smi_msg  *msg)
 {
@@ -3519,6 +3647,17 @@
 			goto out;
 		}
 
+		/*
+		** We need to make sure the channels have been initialized.
+		** The channel_handler routine will set the "curr_channel"
+		** equal to or greater than IPMI_MAX_CHANNELS when all the
+		** channels for this interface have been initialized.
+		*/
+		if (intf->curr_channel < IPMI_MAX_CHANNELS) {
+			requeue = 1;     /* Just put the message back for now */
+			goto out;
+		}
+
 		switch (intf->channels[chan].medium) {
 		case IPMI_CHANNEL_MEDIUM_IPMB:
 			if (msg->rsp[4] & 0x04) {
@@ -3554,11 +3693,20 @@
 			break;
 
 		default:
-			/*
-			 * We don't handle the channel type, so just
-			 * free the message.
-			 */
-			requeue = 0;
+			/* Check for OEM Channels.  Clients had better
+			   register for these commands. */
+			if ((intf->channels[chan].medium
+			     >= IPMI_CHANNEL_MEDIUM_OEM_MIN)
+			    && (intf->channels[chan].medium
+				<= IPMI_CHANNEL_MEDIUM_OEM_MAX)) {
+				requeue = handle_oem_get_msg_cmd(intf, msg);
+			} else {
+				/*
+				 * We don't handle the channel type, so just
+				 * free the message.
+				 */
+				requeue = 0;
+			}
 		}
 
 	} else if ((msg->rsp[0] == ((IPMI_NETFN_APP_REQUEST|1) << 2))
@@ -3730,7 +3878,7 @@
 		list_add_tail(&msg->link, timeouts);
 		if (ent->broadcast)
 			ipmi_inc_stat(intf, timed_out_ipmb_broadcasts);
-		else if (ent->recv_msg->addr.addr_type == IPMI_LAN_ADDR_TYPE)
+		else if (is_lan_addr(&ent->recv_msg->addr))
 			ipmi_inc_stat(intf, timed_out_lan_commands);
 		else
 			ipmi_inc_stat(intf, timed_out_ipmb_commands);
@@ -3744,15 +3892,17 @@
 		 */
 		ent->timeout = MAX_MSG_TIMEOUT;
 		ent->retries_left--;
-		if (ent->recv_msg->addr.addr_type == IPMI_LAN_ADDR_TYPE)
-			ipmi_inc_stat(intf, retransmitted_lan_commands);
-		else
-			ipmi_inc_stat(intf, retransmitted_ipmb_commands);
-
 		smi_msg = smi_from_recv_msg(intf, ent->recv_msg, slot,
 					    ent->seqid);
-		if (!smi_msg)
+		if (!smi_msg) {
+			if (is_lan_addr(&ent->recv_msg->addr))
+				ipmi_inc_stat(intf,
+					      dropped_rexmit_lan_commands);
+			else
+				ipmi_inc_stat(intf,
+					      dropped_rexmit_ipmb_commands);
 			return;
+		}
 
 		spin_unlock_irqrestore(&intf->seq_lock, *flags);
 
@@ -3764,10 +3914,17 @@
 		 * resent.
 		 */
 		handlers = intf->handlers;
-		if (handlers)
+		if (handlers) {
+			if (is_lan_addr(&ent->recv_msg->addr))
+				ipmi_inc_stat(intf,
+					      retransmitted_lan_commands);
+			else
+				ipmi_inc_stat(intf,
+					      retransmitted_ipmb_commands);
+
 			intf->handlers->sender(intf->send_info,
 					       smi_msg, 0);
-		else
+		} else
 			ipmi_free_smi_msg(smi_msg);
 
 		spin_lock_irqsave(&intf->seq_lock, *flags);
diff -urN linux-2.6.30-rc2/drivers/char/ipmi/ipmi_si_intf.c linux-2.6.30-rc3/drivers/char/ipmi/ipmi_si_intf.c
--- linux-2.6.30-rc2/drivers/char/ipmi/ipmi_si_intf.c	2009-04-22 03:29:10.634556343 +0000
+++ linux-2.6.30-rc3/drivers/char/ipmi/ipmi_si_intf.c	2009-04-22 03:29:16.671931333 +0000
@@ -82,12 +82,6 @@
 #define SI_SHORT_TIMEOUT_USEC  250 /* .25ms when the SM request a
 				      short timeout */
 
-/* Bit for BMC global enables. */
-#define IPMI_BMC_RCV_MSG_INTR     0x01
-#define IPMI_BMC_EVT_MSG_INTR     0x02
-#define IPMI_BMC_EVT_MSG_BUFF     0x04
-#define IPMI_BMC_SYS_LOG          0x08
-
 enum si_intf_state {
 	SI_NORMAL,
 	SI_GETTING_FLAGS,
@@ -220,6 +214,9 @@
 			     OEM2_DATA_AVAIL)
 	unsigned char       msg_flags;
 
+	/* Does the BMC have an event buffer? */
+	char		    has_event_buffer;
+
 	/*
 	 * If set to true, this will request events the next time the
 	 * state machine is idle.
@@ -968,7 +965,8 @@
 {
 	struct smi_info *smi_info = send_info;
 
-	if (atomic_read(&smi_info->stop_operation))
+	if (atomic_read(&smi_info->stop_operation) ||
+				!smi_info->has_event_buffer)
 		return;
 
 	atomic_set(&smi_info->req_events, 1);
@@ -2407,26 +2405,9 @@
 };
 #endif /* CONFIG_PPC_OF */
 
-
-static int try_get_dev_id(struct smi_info *smi_info)
+static int wait_for_msg_done(struct smi_info *smi_info)
 {
-	unsigned char         msg[2];
-	unsigned char         *resp;
-	unsigned long         resp_len;
 	enum si_sm_result     smi_result;
-	int                   rv = 0;
-
-	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
-	if (!resp)
-		return -ENOMEM;
-
-	/*
-	 * Do a Get Device ID command, since it comes back with some
-	 * useful info.
-	 */
-	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
-	msg[1] = IPMI_GET_DEVICE_ID_CMD;
-	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);
 
 	smi_result = smi_info->handlers->event(smi_info->si_sm, 0);
 	for (;;) {
@@ -2441,16 +2422,39 @@
 		} else
 			break;
 	}
-	if (smi_result == SI_SM_HOSED) {
+	if (smi_result == SI_SM_HOSED)
 		/*
 		 * We couldn't get the state machine to run, so whatever's at
 		 * the port is probably not an IPMI SMI interface.
 		 */
-		rv = -ENODEV;
+		return -ENODEV;
+
+	return 0;
+}
+
+static int try_get_dev_id(struct smi_info *smi_info)
+{
+	unsigned char         msg[2];
+	unsigned char         *resp;
+	unsigned long         resp_len;
+	int                   rv = 0;
+
+	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
+	if (!resp)
+		return -ENOMEM;
+
+	/*
+	 * Do a Get Device ID command, since it comes back with some
+	 * useful info.
+	 */
+	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
+	msg[1] = IPMI_GET_DEVICE_ID_CMD;
+	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);
+
+	rv = wait_for_msg_done(smi_info);
+	if (rv)
 		goto out;
-	}
 
-	/* Otherwise, we got some data. */
 	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
 						  resp, IPMI_MAX_MSG_LENGTH);
 
@@ -2462,6 +2466,88 @@
 	return rv;
 }
 
+static int try_enable_event_buffer(struct smi_info *smi_info)
+{
+	unsigned char         msg[3];
+	unsigned char         *resp;
+	unsigned long         resp_len;
+	int                   rv = 0;
+
+	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
+	if (!resp)
+		return -ENOMEM;
+
+	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
+	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
+	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);
+
+	rv = wait_for_msg_done(smi_info);
+	if (rv) {
+		printk(KERN_WARNING
+		       "ipmi_si: Error getting response from get global,"
+		       " enables command, the event buffer is not"
+		       " enabled.\n");
+		goto out;
+	}
+
+	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
+						  resp, IPMI_MAX_MSG_LENGTH);
+
+	if (resp_len < 4 ||
+			resp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||
+			resp[1] != IPMI_GET_BMC_GLOBAL_ENABLES_CMD   ||
+			resp[2] != 0) {
+		printk(KERN_WARNING
+		       "ipmi_si: Invalid return from get global"
+		       " enables command, cannot enable the event"
+		       " buffer.\n");
+		rv = -EINVAL;
+		goto out;
+	}
+
+	if (resp[3] & IPMI_BMC_EVT_MSG_BUFF)
+		/* buffer is already enabled, nothing to do. */
+		goto out;
+
+	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
+	msg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;
+	msg[2] = resp[3] | IPMI_BMC_EVT_MSG_BUFF;
+	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 3);
+
+	rv = wait_for_msg_done(smi_info);
+	if (rv) {
+		printk(KERN_WARNING
+		       "ipmi_si: Error getting response from set global,"
+		       " enables command, the event buffer is not"
+		       " enabled.\n");
+		goto out;
+	}
+
+	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
+						  resp, IPMI_MAX_MSG_LENGTH);
+
+	if (resp_len < 3 ||
+			resp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||
+			resp[1] != IPMI_SET_BMC_GLOBAL_ENABLES_CMD) {
+		printk(KERN_WARNING
+		       "ipmi_si: Invalid return from get global,"
+		       "enables command, not enable the event"
+		       " buffer.\n");
+		rv = -EINVAL;
+		goto out;
+	}
+
+	if (resp[2] != 0)
+		/*
+		 * An error when setting the event buffer bit means
+		 * that the event buffer is not supported.
+		 */
+		rv = -ENOENT;
+ out:
+	kfree(resp);
+	return rv;
+}
+
 static int type_file_read_proc(char *page, char **start, off_t off,
 			       int count, int *eof, void *data)
 {
@@ -2847,6 +2933,10 @@
 	new_smi->intf_num = smi_num;
 	smi_num++;
 
+	rv = try_enable_event_buffer(new_smi);
+	if (rv == 0)
+		new_smi->has_event_buffer = 1;
+
 	/*
 	 * Start clearing the flags before we enable interrupts or the
 	 * timer to avoid racing with the timer.
@@ -2863,7 +2953,7 @@
 		 */
 		new_smi->pdev = platform_device_alloc("ipmi_si",
 						      new_smi->intf_num);
-		if (rv) {
+		if (!new_smi->pdev) {
 			printk(KERN_ERR
 			       "ipmi_si_intf:"
 			       " Unable to allocate platform device\n");
diff -urN linux-2.6.30-rc2/drivers/char/mem.c linux-2.6.30-rc3/drivers/char/mem.c
--- linux-2.6.30-rc2/drivers/char/mem.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/char/mem.c	2009-04-22 03:29:16.673931253 +0000
@@ -301,33 +301,7 @@
 }
 #endif
 
-void __attribute__((weak))
-map_devmem(unsigned long pfn, unsigned long len, pgprot_t prot)
-{
-	/* nothing. architectures can override. */
-}
-
-void __attribute__((weak))
-unmap_devmem(unsigned long pfn, unsigned long len, pgprot_t prot)
-{
-	/* nothing. architectures can override. */
-}
-
-static void mmap_mem_open(struct vm_area_struct *vma)
-{
-	map_devmem(vma->vm_pgoff,  vma->vm_end - vma->vm_start,
-			vma->vm_page_prot);
-}
-
-static void mmap_mem_close(struct vm_area_struct *vma)
-{
-	unmap_devmem(vma->vm_pgoff,  vma->vm_end - vma->vm_start,
-			vma->vm_page_prot);
-}
-
 static struct vm_operations_struct mmap_mem_ops = {
-	.open  = mmap_mem_open,
-	.close = mmap_mem_close,
 #ifdef CONFIG_HAVE_IOREMAP_PROT
 	.access = generic_access_phys
 #endif
@@ -362,7 +336,6 @@
 			    vma->vm_pgoff,
 			    size,
 			    vma->vm_page_prot)) {
-		unmap_devmem(vma->vm_pgoff, size, vma->vm_page_prot);
 		return -EAGAIN;
 	}
 	return 0;
diff -urN linux-2.6.30-rc2/drivers/char/vt.c linux-2.6.30-rc3/drivers/char/vt.c
--- linux-2.6.30-rc2/drivers/char/vt.c	2009-04-22 03:29:10.646931412 +0000
+++ linux-2.6.30-rc3/drivers/char/vt.c	2009-04-22 03:29:16.684928365 +0000
@@ -2274,7 +2274,7 @@
 				    continue; /* nothing to display */
 				}
 				/* Glyph not found */
-				if ((!(vc->vc_utf && !vc->vc_disp_ctrl) && c < 128) && !(c & ~charmask)) {
+				if ((!(vc->vc_utf && !vc->vc_disp_ctrl) || c < 128) && !(c & ~charmask)) {
 				    /* In legacy mode use the glyph we get by a 1:1 mapping.
 				       This would make absolutely no sense with Unicode in mind,
 				       but do this for ASCII characters since a font may lack
diff -urN linux-2.6.30-rc2/drivers/clocksource/acpi_pm.c linux-2.6.30-rc3/drivers/clocksource/acpi_pm.c
--- linux-2.6.30-rc2/drivers/clocksource/acpi_pm.c	2009-04-22 03:29:10.646931412 +0000
+++ linux-2.6.30-rc3/drivers/clocksource/acpi_pm.c	2009-04-22 03:29:16.684928365 +0000
@@ -57,7 +57,7 @@
 	return v2;
 }
 
-static cycle_t acpi_pm_read(void)
+static cycle_t acpi_pm_read(struct clocksource *cs)
 {
 	return (cycle_t)read_pmtmr();
 }
@@ -83,7 +83,7 @@
 }
 __setup("acpi_pm_good", acpi_pm_good_setup);
 
-static cycle_t acpi_pm_read_slow(void)
+static cycle_t acpi_pm_read_slow(struct clocksource *cs)
 {
 	return (cycle_t)acpi_pm_read_verified();
 }
@@ -156,9 +156,9 @@
 	unsigned long count, delta;
 
 	mach_prepare_counter();
-	value1 = clocksource_acpi_pm.read();
+	value1 = clocksource_acpi_pm.read(&clocksource_acpi_pm);
 	mach_countup(&count);
-	value2 = clocksource_acpi_pm.read();
+	value2 = clocksource_acpi_pm.read(&clocksource_acpi_pm);
 	delta = (value2 - value1) & ACPI_PM_MASK;
 
 	/* Check that the PMTMR delta is within 5% of what we expect */
@@ -195,9 +195,9 @@
 	/* "verify" this timing source: */
 	for (j = 0; j < ACPI_PM_MONOTONICITY_CHECKS; j++) {
 		udelay(100 * j);
-		value1 = clocksource_acpi_pm.read();
+		value1 = clocksource_acpi_pm.read(&clocksource_acpi_pm);
 		for (i = 0; i < ACPI_PM_READ_CHECKS; i++) {
-			value2 = clocksource_acpi_pm.read();
+			value2 = clocksource_acpi_pm.read(&clocksource_acpi_pm);
 			if (value2 == value1)
 				continue;
 			if (value2 > value1)
diff -urN linux-2.6.30-rc2/drivers/clocksource/cyclone.c linux-2.6.30-rc3/drivers/clocksource/cyclone.c
--- linux-2.6.30-rc2/drivers/clocksource/cyclone.c	2009-04-22 03:29:10.646931412 +0000
+++ linux-2.6.30-rc3/drivers/clocksource/cyclone.c	2009-04-22 03:29:16.685931586 +0000
@@ -19,7 +19,7 @@
 int use_cyclone = 0;
 static void __iomem *cyclone_ptr;
 
-static cycle_t read_cyclone(void)
+static cycle_t read_cyclone(struct clocksource *cs)
 {
 	return (cycle_t)readl(cyclone_ptr);
 }
diff -urN linux-2.6.30-rc2/drivers/clocksource/scx200_hrt.c linux-2.6.30-rc3/drivers/clocksource/scx200_hrt.c
--- linux-2.6.30-rc2/drivers/clocksource/scx200_hrt.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/clocksource/scx200_hrt.c	2009-04-22 03:29:16.685931586 +0000
@@ -43,7 +43,7 @@
 /* The base timer frequency, * 27 if selected */
 #define HRT_FREQ   1000000
 
-static cycle_t read_hrt(void)
+static cycle_t read_hrt(struct clocksource *cs)
 {
 	/* Read the timer value */
 	return (cycle_t) inl(scx200_cb_base + SCx200_TIMER_OFFSET);
diff -urN linux-2.6.30-rc2/drivers/clocksource/tcb_clksrc.c linux-2.6.30-rc3/drivers/clocksource/tcb_clksrc.c
--- linux-2.6.30-rc2/drivers/clocksource/tcb_clksrc.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/clocksource/tcb_clksrc.c	2009-04-22 03:29:16.685931586 +0000
@@ -39,7 +39,7 @@
 
 static void __iomem *tcaddr;
 
-static cycle_t tc_get_cycles(void)
+static cycle_t tc_get_cycles(struct clocksource *cs)
 {
 	unsigned long	flags;
 	u32		lower, upper;
diff -urN linux-2.6.30-rc2/drivers/edac/mpc85xx_edac.c linux-2.6.30-rc3/drivers/edac/mpc85xx_edac.c
--- linux-2.6.30-rc2/drivers/edac/mpc85xx_edac.c	2009-04-22 03:29:10.657931389 +0000
+++ linux-2.6.30-rc3/drivers/edac/mpc85xx_edac.c	2009-04-22 03:29:16.697931684 +0000
@@ -674,7 +674,7 @@
 	int row_index;
 
 	err_detect = in_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DETECT);
-	if (err_detect)
+	if (!err_detect)
 		return;
 
 	mpc85xx_mc_printk(mci, KERN_ERR, "Err Detect Register: %#8.8x\n",
diff -urN linux-2.6.30-rc2/drivers/gpu/drm/drm_stub.c linux-2.6.30-rc3/drivers/gpu/drm/drm_stub.c
--- linux-2.6.30-rc2/drivers/gpu/drm/drm_stub.c	2009-04-22 03:29:10.668931390 +0000
+++ linux-2.6.30-rc3/drivers/gpu/drm/drm_stub.c	2009-04-22 03:29:16.707931429 +0000
@@ -159,6 +159,9 @@
 int drm_setmaster_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv)
 {
+	if (file_priv->is_master)
+		return 0;
+
 	if (file_priv->minor->master && file_priv->minor->master != file_priv->master)
 		return -EINVAL;
 
@@ -169,6 +172,7 @@
 	    file_priv->minor->master != file_priv->master) {
 		mutex_lock(&dev->struct_mutex);
 		file_priv->minor->master = drm_master_get(file_priv->master);
+		file_priv->is_master = 1;
 		mutex_unlock(&dev->struct_mutex);
 	}
 
@@ -178,10 +182,15 @@
 int drm_dropmaster_ioctl(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv)
 {
-	if (!file_priv->master)
+	if (!file_priv->is_master)
 		return -EINVAL;
+
+	if (!file_priv->minor->master)
+		return -EINVAL;
+
 	mutex_lock(&dev->struct_mutex);
 	drm_master_put(&file_priv->minor->master);
+	file_priv->is_master = 0;
 	mutex_unlock(&dev->struct_mutex);
 	return 0;
 }
diff -urN linux-2.6.30-rc2/drivers/gpu/drm/drm_sysfs.c linux-2.6.30-rc3/drivers/gpu/drm/drm_sysfs.c
--- linux-2.6.30-rc2/drivers/gpu/drm/drm_sysfs.c	2009-04-22 03:29:10.668931390 +0000
+++ linux-2.6.30-rc3/drivers/gpu/drm/drm_sysfs.c	2009-04-22 03:29:16.708931446 +0000
@@ -132,6 +132,7 @@
  */
 static void drm_sysfs_device_release(struct device *dev)
 {
+	memset(dev, 0, sizeof(struct device));
 	return;
 }
 
diff -urN linux-2.6.30-rc2/drivers/gpu/drm/via/via_dma.c linux-2.6.30-rc3/drivers/gpu/drm/via/via_dma.c
--- linux-2.6.30-rc2/drivers/gpu/drm/via/via_dma.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/gpu/drm/via/via_dma.c	2009-04-22 03:29:16.732931301 +0000
@@ -481,11 +481,13 @@
 {
 	int count = 10000000;
 
-	while (!(VIA_READ(VIA_REG_STATUS) & VIA_VR_QUEUE_BUSY) && count--);
+	while (!(VIA_READ(VIA_REG_STATUS) & VIA_VR_QUEUE_BUSY) && --count)
+		;
 
-	while (count-- && (VIA_READ(VIA_REG_STATUS) &
+	while (count && (VIA_READ(VIA_REG_STATUS) &
 			   (VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY |
-			    VIA_3D_ENG_BUSY))) ;
+			    VIA_3D_ENG_BUSY)))
+		--count;
 	return count;
 }
 
@@ -705,7 +707,7 @@
 	switch (d_siz->func) {
 	case VIA_CMDBUF_SPACE:
 		while (((tmp_size = via_cmdbuf_space(dev_priv)) < d_siz->size)
-		       && count--) {
+		       && --count) {
 			if (!d_siz->wait) {
 				break;
 			}
@@ -717,7 +719,7 @@
 		break;
 	case VIA_CMDBUF_LAG:
 		while (((tmp_size = via_cmdbuf_lag(dev_priv)) > d_siz->size)
-		       && count--) {
+		       && --count) {
 			if (!d_siz->wait) {
 				break;
 			}
diff -urN linux-2.6.30-rc2/drivers/ide/cs5536.c linux-2.6.30-rc3/drivers/ide/cs5536.c
--- linux-2.6.30-rc2/drivers/ide/cs5536.c	2009-04-22 03:29:10.712931416 +0000
+++ linux-2.6.30-rc3/drivers/ide/cs5536.c	2009-04-22 03:29:16.751641734 +0000
@@ -236,6 +236,7 @@
 	.dma_test_irq		= ide_dma_test_irq,
 	.dma_lost_irq		= ide_dma_lost_irq,
 	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
+	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
 static const struct ide_port_info cs5536_info = {
diff -urN linux-2.6.30-rc2/drivers/ide/hpt366.c linux-2.6.30-rc3/drivers/ide/hpt366.c
--- linux-2.6.30-rc2/drivers/ide/hpt366.c	2009-04-22 03:29:10.713931388 +0000
+++ linux-2.6.30-rc3/drivers/ide/hpt366.c	2009-04-22 03:29:16.752931441 +0000
@@ -3,7 +3,7 @@
  * Portions Copyright (C) 2001	        Sun Microsystems, Inc.
  * Portions Copyright (C) 2003		Red Hat Inc
  * Portions Copyright (C) 2007		Bartlomiej Zolnierkiewicz
- * Portions Copyright (C) 2005-2008	MontaVista Software, Inc.
+ * Portions Copyright (C) 2005-2009	MontaVista Software, Inc.
  *
  * Thanks to HighPoint Technologies for their assistance, and hardware.
  * Special Thanks to Jon Burchmore in SanDiego for the deep pockets, his
@@ -114,6 +114,8 @@
  *   the register setting lists into the table indexed by the clock selected
  * - set the correct hwif->ultra_mask for each individual chip
  * - add Ultra and MW DMA mode filtering for the HPT37[24] based SATA cards
+ * - stop resetting HPT370's state machine before each DMA transfer as that has
+ *   caused more harm than good
  *	Sergei Shtylyov, <sshtylyov@ru.mvista.com> or <source@mvista.com>
  */
 
@@ -133,7 +135,7 @@
 #define DRV_NAME "hpt366"
 
 /* various tuning parameters */
-#define HPT_RESET_STATE_ENGINE
+#undef	HPT_RESET_STATE_ENGINE
 #undef	HPT_DELAY_INTERRUPT
 
 static const char *quirk_drives[] = {
@@ -808,7 +810,7 @@
 	/* get DMA command mode */
 	dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
 	/* stop DMA */
-	outb(dma_cmd & ~0x1, hwif->dma_base + ATA_DMA_CMD);
+	outb(dma_cmd & ~ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);
 	hpt370_clear_engine(drive);
 }
 
@@ -825,11 +827,11 @@
 	ide_hwif_t *hwif	= drive->hwif;
 	u8  dma_stat		= inb(hwif->dma_base + ATA_DMA_STATUS);
 
-	if (dma_stat & 0x01) {
+	if (dma_stat & ATA_DMA_ACTIVE) {
 		/* wait a little */
 		udelay(20);
 		dma_stat = inb(hwif->dma_base + ATA_DMA_STATUS);
-		if (dma_stat & 0x01)
+		if (dma_stat & ATA_DMA_ACTIVE)
 			hpt370_irq_timeout(drive);
 	}
 	return ide_dma_end(drive);
@@ -851,7 +853,7 @@
 
 	dma_stat = inb(hwif->dma_base + ATA_DMA_STATUS);
 	/* return 1 if INTR asserted */
-	if (dma_stat & 4)
+	if (dma_stat & ATA_DMA_INTR)
 		return 1;
 
 	return 0;
diff -urN linux-2.6.30-rc2/drivers/ide/ide-io.c linux-2.6.30-rc3/drivers/ide/ide-io.c
--- linux-2.6.30-rc2/drivers/ide/ide-io.c	2009-04-22 03:29:10.719931389 +0000
+++ linux-2.6.30-rc3/drivers/ide/ide-io.c	2009-04-22 03:29:16.758931512 +0000
@@ -102,11 +102,14 @@
 			drive->dev_flags |= IDE_DFLAG_PARKED;
 	}
 
-	if (rq && rq->cmd_type == REQ_TYPE_ATA_TASKFILE)
-		memcpy(rq->special, cmd, sizeof(*cmd));
+	if (rq && rq->cmd_type == REQ_TYPE_ATA_TASKFILE) {
+		struct ide_cmd *orig_cmd = rq->special;
 
-	if (cmd->tf_flags & IDE_TFLAG_DYN)
-		kfree(cmd);
+		if (cmd->tf_flags & IDE_TFLAG_DYN)
+			kfree(orig_cmd);
+		else
+			memcpy(orig_cmd, cmd, sizeof(*cmd));
+	}
 }
 
 /* obsolete, blk_rq_bytes() should be used instead */
diff -urN linux-2.6.30-rc2/drivers/ide/pmac.c linux-2.6.30-rc3/drivers/ide/pmac.c
--- linux-2.6.30-rc2/drivers/ide/pmac.c	2009-04-22 03:29:10.726931437 +0000
+++ linux-2.6.30-rc3/drivers/ide/pmac.c	2009-04-22 03:29:16.765931479 +0000
@@ -1682,7 +1682,7 @@
 	 * The +2 is +1 for the stop command and +1 to allow for
 	 * aligning the start address to a multiple of 16 bytes.
 	 */
-	pmif->dma_table_cpu = (struct dbdma_cmd*)pci_alloc_consistent(
+	pmif->dma_table_cpu = pci_alloc_consistent(
 		dev,
 		(MAX_DCMDS + 2) * sizeof(struct dbdma_cmd),
 		&hwif->dmatable_dma);
diff -urN linux-2.6.30-rc2/drivers/input/gameport/gameport.c linux-2.6.30-rc3/drivers/input/gameport/gameport.c
--- linux-2.6.30-rc2/drivers/input/gameport/gameport.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/input/gameport/gameport.c	2009-04-22 03:29:16.790931525 +0000
@@ -50,9 +50,8 @@
 
 static struct bus_type gameport_bus;
 
-static void gameport_add_driver(struct gameport_driver *drv);
 static void gameport_add_port(struct gameport *gameport);
-static void gameport_destroy_port(struct gameport *gameport);
+static void gameport_attach_driver(struct gameport_driver *drv);
 static void gameport_reconnect_port(struct gameport *gameport);
 static void gameport_disconnect_port(struct gameport *gameport);
 
@@ -230,7 +229,6 @@
 
 enum gameport_event_type {
 	GAMEPORT_REGISTER_PORT,
-	GAMEPORT_REGISTER_DRIVER,
 	GAMEPORT_ATTACH_DRIVER,
 };
 
@@ -374,8 +372,8 @@
 				gameport_add_port(event->object);
 				break;
 
-			case GAMEPORT_REGISTER_DRIVER:
-				gameport_add_driver(event->object);
+			case GAMEPORT_ATTACH_DRIVER:
+				gameport_attach_driver(event->object);
 				break;
 
 			default:
@@ -706,14 +704,14 @@
 	return 0;
 }
 
-static void gameport_add_driver(struct gameport_driver *drv)
+static void gameport_attach_driver(struct gameport_driver *drv)
 {
 	int error;
 
-	error = driver_register(&drv->driver);
+	error = driver_attach(&drv->driver);
 	if (error)
 		printk(KERN_ERR
-			"gameport: driver_register() failed for %s, error: %d\n",
+			"gameport: driver_attach() failed for %s, error: %d\n",
 			drv->driver.name, error);
 }
 
diff -urN linux-2.6.30-rc2/drivers/input/input.c linux-2.6.30-rc3/drivers/input/input.c
--- linux-2.6.30-rc2/drivers/input/input.c	2009-04-22 03:29:10.751931442 +0000
+++ linux-2.6.30-rc3/drivers/input/input.c	2009-04-22 03:29:16.790931525 +0000
@@ -1549,7 +1549,6 @@
 		return error;
 	list_add_tail_rcu(&handle->d_node, &dev->h_list);
 	mutex_unlock(&dev->mutex);
-	synchronize_rcu();
 
 	/*
 	 * Since we are supposed to be called from ->connect()
diff -urN linux-2.6.30-rc2/drivers/input/keyboard/atkbd.c linux-2.6.30-rc3/drivers/input/keyboard/atkbd.c
--- linux-2.6.30-rc2/drivers/input/keyboard/atkbd.c	2009-04-22 03:29:10.752931393 +0000
+++ linux-2.6.30-rc3/drivers/input/keyboard/atkbd.c	2009-04-22 03:29:16.791931635 +0000
@@ -880,7 +880,7 @@
 };
 
 /*
- * Samsung NC10 with Fn+F? key release not working
+ * Samsung NC10,NC20 with Fn+F? key release not working
  */
 static unsigned int atkbd_samsung_forced_release_keys[] = {
 	0x82, 0x83, 0x84, 0x86, 0x88, 0x89, 0xb3, 0xf7, 0xf9, -1U
@@ -1534,6 +1534,24 @@
 		.driver_data = atkbd_samsung_forced_release_keys,
 	},
 	{
+		.ident = "Samsung NC20",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG ELECTRONICS CO., LTD."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "NC20"),
+		},
+		.callback = atkbd_setup_forced_release,
+		.driver_data = atkbd_samsung_forced_release_keys,
+	},
+	{
+		.ident = "Samsung SQ45S70S",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG ELECTRONICS CO., LTD."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "SQ45S70S"),
+		},
+		.callback = atkbd_setup_forced_release,
+		.driver_data = atkbd_samsung_forced_release_keys,
+	},
+	{
 		.ident = "Fujitsu Amilo PA 1510",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
diff -urN linux-2.6.30-rc2/drivers/input/keyboard/bf54x-keys.c linux-2.6.30-rc3/drivers/input/keyboard/bf54x-keys.c
--- linux-2.6.30-rc2/drivers/input/keyboard/bf54x-keys.c	2009-04-22 03:29:10.752931393 +0000
+++ linux-2.6.30-rc3/drivers/input/keyboard/bf54x-keys.c	2009-04-22 03:29:16.791931635 +0000
@@ -252,7 +252,7 @@
 	}
 
 	error = request_irq(bf54x_kpad->irq, bfin_kpad_isr,
-				 IRQF_SAMPLE_RANDOM, DRV_NAME, pdev);
+				0, DRV_NAME, pdev);
 	if (error) {
 		printk(KERN_ERR DRV_NAME
 			": unable to claim irq %d; error %d\n",
diff -urN linux-2.6.30-rc2/drivers/input/misc/Kconfig linux-2.6.30-rc3/drivers/input/misc/Kconfig
--- linux-2.6.30-rc2/drivers/input/misc/Kconfig	2009-04-22 03:29:10.753931433 +0000
+++ linux-2.6.30-rc3/drivers/input/misc/Kconfig	2009-04-22 03:29:16.792931511 +0000
@@ -214,7 +214,7 @@
 
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
-	depends on GSC || HP300
+	depends on (GSC || HP300) && SERIO
 	select HP_SDC
 	help
 	  Say Y here if you want to support the built-in real time clock
diff -urN linux-2.6.30-rc2/drivers/input/mouse/pc110pad.c linux-2.6.30-rc3/drivers/input/mouse/pc110pad.c
--- linux-2.6.30-rc2/drivers/input/mouse/pc110pad.c	2009-04-22 03:29:10.756101309 +0000
+++ linux-2.6.30-rc3/drivers/input/mouse/pc110pad.c	2009-04-22 03:29:16.794931421 +0000
@@ -108,7 +108,6 @@
  */
 static int __init pc110pad_init(void)
 {
-	struct pci_dev *dev;
 	int err;
 
 	if (!no_pci_devices())
diff -urN linux-2.6.30-rc2/drivers/input/serio/hp_sdc.c linux-2.6.30-rc3/drivers/input/serio/hp_sdc.c
--- linux-2.6.30-rc2/drivers/input/serio/hp_sdc.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/input/serio/hp_sdc.c	2009-04-22 03:29:16.795931585 +0000
@@ -819,6 +819,7 @@
 MODULE_DEVICE_TABLE(parisc, hp_sdc_tbl);
 
 static int __init hp_sdc_init_hppa(struct parisc_device *d);
+static struct delayed_work moduleloader_work;
 
 static struct parisc_driver hp_sdc_driver = {
 	.name =		"hp_sdc",
@@ -930,8 +931,15 @@
 
 #if defined(__hppa__)
 
+static void request_module_delayed(struct work_struct *work)
+{
+	request_module("hp_sdc_mlc");
+}
+
 static int __init hp_sdc_init_hppa(struct parisc_device *d)
 {
+	int ret;
+
 	if (!d)
 		return 1;
 	if (hp_sdc.dev != NULL)
@@ -944,13 +952,26 @@
 	hp_sdc.data_io		= d->hpa.start + 0x800;
 	hp_sdc.status_io	= d->hpa.start + 0x801;
 
-	return hp_sdc_init();
+	INIT_DELAYED_WORK(&moduleloader_work, request_module_delayed);
+
+	ret = hp_sdc_init();
+	/* after sucessfull initialization give SDC some time to settle
+	 * and then load the hp_sdc_mlc upper layer driver */
+	if (!ret)
+		schedule_delayed_work(&moduleloader_work,
+			msecs_to_jiffies(2000));
+
+	return ret;
 }
 
 #endif /* __hppa__ */
 
 static void hp_sdc_exit(void)
 {
+	/* do nothing if we don't have a SDC */
+	if (!hp_sdc.dev)
+		return;
+
 	write_lock_irq(&hp_sdc.lock);
 
 	/* Turn off all maskable "sub-function" irq's. */
@@ -969,6 +990,7 @@
 	tasklet_kill(&hp_sdc.task);
 
 #if defined(__hppa__)
+	cancel_delayed_work_sync(&moduleloader_work);
 	if (unregister_parisc_driver(&hp_sdc_driver))
 		printk(KERN_WARNING PREFIX "Error unregistering HP SDC");
 #endif
diff -urN linux-2.6.30-rc2/drivers/input/serio/i8042-x86ia64io.h linux-2.6.30-rc3/drivers/input/serio/i8042-x86ia64io.h
--- linux-2.6.30-rc2/drivers/input/serio/i8042-x86ia64io.h	2009-04-22 03:29:10.756101309 +0000
+++ linux-2.6.30-rc3/drivers/input/serio/i8042-x86ia64io.h	2009-04-22 03:29:16.795931585 +0000
@@ -377,6 +377,24 @@
 	{ }
 };
 
+static struct dmi_system_id __initdata i8042_dmi_reset_table[] = {
+	{
+		.ident = "MSI Wind U-100",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "U-100"),
+			DMI_MATCH(DMI_BOARD_VENDOR, "MICRO-STAR INTERNATIONAL CO., LTD"),
+		},
+	},
+	{
+		.ident = "LG Electronics X110",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "X110"),
+			DMI_MATCH(DMI_BOARD_VENDOR, "LG Electronics Inc."),
+		},
+	},
+	{ }
+};
+
 #ifdef CONFIG_PNP
 static struct dmi_system_id __initdata i8042_dmi_nopnp_table[] = {
 	{
@@ -386,6 +404,13 @@
 			DMI_MATCH(DMI_BOARD_VENDOR, "Intel Corporation"),
 		},
 	},
+	{
+		.ident = "MSI Wind U-100",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "U-100"),
+			DMI_MATCH(DMI_BOARD_VENDOR, "MICRO-STAR INTERNATIONAL CO., LTD"),
+		},
+	},
 	{ }
 };
 #endif
@@ -698,6 +723,9 @@
 #endif
 
 #ifdef CONFIG_X86
+	if (dmi_check_system(i8042_dmi_reset_table))
+		i8042_reset = 1;
+
 	if (dmi_check_system(i8042_dmi_noloop_table))
 		i8042_noloop = 1;
 
diff -urN linux-2.6.30-rc2/drivers/input/serio/i8042.c linux-2.6.30-rc3/drivers/input/serio/i8042.c
--- linux-2.6.30-rc2/drivers/input/serio/i8042.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/input/serio/i8042.c	2009-04-22 03:29:16.795931585 +0000
@@ -712,22 +712,43 @@
 static int i8042_controller_selftest(void)
 {
 	unsigned char param;
+	int i = 0;
 
 	if (!i8042_reset)
 		return 0;
 
-	if (i8042_command(&param, I8042_CMD_CTL_TEST)) {
-		printk(KERN_ERR "i8042.c: i8042 controller self test timeout.\n");
-		return -ENODEV;
-	}
+	/*
+	 * We try this 5 times; on some really fragile systems this does not
+	 * take the first time...
+	 */
+	do {
+
+		if (i8042_command(&param, I8042_CMD_CTL_TEST)) {
+			printk(KERN_ERR "i8042.c: i8042 controller self test timeout.\n");
+			return -ENODEV;
+		}
+
+		if (param == I8042_RET_CTL_TEST)
+			return 0;
 
-	if (param != I8042_RET_CTL_TEST) {
 		printk(KERN_ERR "i8042.c: i8042 controller selftest failed. (%#x != %#x)\n",
-			 param, I8042_RET_CTL_TEST);
-		return -EIO;
-	}
+			param, I8042_RET_CTL_TEST);
+		msleep(50);
+	} while (i++ < 5);
 
+#ifdef CONFIG_X86
+	/*
+	 * On x86, we don't fail entire i8042 initialization if controller
+	 * reset fails in hopes that keyboard port will still be functional
+	 * and user will still get a working keyboard. This is especially
+	 * important on netbooks. On other arches we trust hardware more.
+	 */
+	printk(KERN_INFO
+		"i8042: giving up on controller selftest, continuing anyway...\n");
 	return 0;
+#else
+	return -EIO;
+#endif
 }
 
 /*
diff -urN linux-2.6.30-rc2/drivers/input/touchscreen/ad7877.c linux-2.6.30-rc3/drivers/input/touchscreen/ad7877.c
--- linux-2.6.30-rc2/drivers/input/touchscreen/ad7877.c	2009-04-22 03:29:10.757556743 +0000
+++ linux-2.6.30-rc3/drivers/input/touchscreen/ad7877.c	2009-04-22 03:29:16.796931338 +0000
@@ -736,8 +736,8 @@
 
 	/* Request AD7877 /DAV GPIO interrupt */
 
-	err = request_irq(spi->irq, ad7877_irq, IRQF_TRIGGER_FALLING |
-			IRQF_SAMPLE_RANDOM, spi->dev.driver->name, ts);
+	err = request_irq(spi->irq, ad7877_irq, IRQF_TRIGGER_FALLING,
+			spi->dev.driver->name, ts);
 	if (err) {
 		dev_dbg(&spi->dev, "irq %d busy?\n", spi->irq);
 		goto err_free_mem;
diff -urN linux-2.6.30-rc2/drivers/input/touchscreen/ad7879.c linux-2.6.30-rc3/drivers/input/touchscreen/ad7879.c
--- linux-2.6.30-rc2/drivers/input/touchscreen/ad7879.c	2009-04-22 03:29:10.757556743 +0000
+++ linux-2.6.30-rc3/drivers/input/touchscreen/ad7879.c	2009-04-22 03:29:16.796931338 +0000
@@ -448,8 +448,7 @@
 	ad7879_setup(ts);
 
 	err = request_irq(bus->irq, ad7879_irq,
-			  IRQF_TRIGGER_FALLING | IRQF_SAMPLE_RANDOM,
-			  bus->dev.driver->name, ts);
+			  IRQF_TRIGGER_FALLING, bus->dev.driver->name, ts);
 
 	if (err) {
 		dev_err(&bus->dev, "irq %d busy?\n", bus->irq);
diff -urN linux-2.6.30-rc2/drivers/input/touchscreen/ads7846.c linux-2.6.30-rc3/drivers/input/touchscreen/ads7846.c
--- linux-2.6.30-rc2/drivers/input/touchscreen/ads7846.c	2009-04-22 03:29:10.757556743 +0000
+++ linux-2.6.30-rc3/drivers/input/touchscreen/ads7846.c	2009-04-22 03:29:16.797931448 +0000
@@ -127,6 +127,8 @@
 	void			(*filter_cleanup)(void *data);
 	int			(*get_pendown_state)(void);
 	int			gpio_pendown;
+
+	void			(*wait_for_sync)(void);
 };
 
 /* leave chip selected when we're done, for quicker re-select? */
@@ -511,6 +513,10 @@
 	return !gpio_get_value(ts->gpio_pendown);
 }
 
+static void null_wait_for_sync(void)
+{
+}
+
 /*
  * PENIRQ only kicks the timer.  The timer only reissues the SPI transfer,
  * to retrieve touchscreen status.
@@ -686,6 +692,7 @@
 	default:
 		BUG();
 	}
+	ts->wait_for_sync();
 	status = spi_async(ts->spi, m);
 	if (status)
 		dev_err(&ts->spi->dev, "spi_async --> %d\n",
@@ -723,6 +730,7 @@
 	} else {
 		/* pen is still down, continue with the measurement */
 		ts->msg_idx = 0;
+		ts->wait_for_sync();
 		status = spi_async(ts->spi, &ts->msg[0]);
 		if (status)
 			dev_err(&ts->spi->dev, "spi_async --> %d\n", status);
@@ -746,7 +754,7 @@
 			 * that here.  (The "generic irq" framework may help...)
 			 */
 			ts->irq_disabled = 1;
-			disable_irq(ts->spi->irq);
+			disable_irq_nosync(ts->spi->irq);
 			ts->pending = 1;
 			hrtimer_start(&ts->timer, ktime_set(0, TS_POLL_DELAY),
 					HRTIMER_MODE_REL);
@@ -947,6 +955,8 @@
 		ts->penirq_recheck_delay_usecs =
 				pdata->penirq_recheck_delay_usecs;
 
+	ts->wait_for_sync = pdata->wait_for_sync ? : null_wait_for_sync;
+
 	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&spi->dev));
 
 	input_dev->name = "ADS784x Touchscreen";
diff -urN linux-2.6.30-rc2/drivers/input/touchscreen/da9034-ts.c linux-2.6.30-rc3/drivers/input/touchscreen/da9034-ts.c
--- linux-2.6.30-rc2/drivers/input/touchscreen/da9034-ts.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/input/touchscreen/da9034-ts.c	2009-04-22 03:29:16.797931448 +0000
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2006-2008 Marvell International Ltd.
  *	Fengwei Yin <fengwei.yin@marvell.com>
+ *	Bin Yang  <bin.yang@marvell.com>
  *	Eric Miao <eric.miao@marvell.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -175,6 +176,16 @@
 			goto err_reset;
 
 		touch->state = STATE_STOP;
+
+		/* FIXME: PEN_{UP/DOWN} events are expected to be
+		 * available by stopping TSI, but this is found not
+		 * always true, delay and simulate such an event
+		 * here is more reliable
+		 */
+		mdelay(1);
+		da9034_event_handler(touch,
+				     is_pen_down(touch) ? EVENT_PEN_DOWN :
+							  EVENT_PEN_UP);
 		break;
 
 	case STATE_STOP:
@@ -189,8 +200,6 @@
 			report_pen_up(touch);
 			touch->state = STATE_IDLE;
 		}
-
-		input_sync(touch->input_dev);
 		break;
 
 	case STATE_WAIT:
@@ -200,8 +209,10 @@
 		if (is_pen_down(touch)) {
 			start_tsi(touch);
 			touch->state = STATE_BUSY;
-		} else
+		} else {
+			report_pen_up(touch);
 			touch->state = STATE_IDLE;
+		}
 		break;
 	}
 	return;
@@ -226,16 +237,12 @@
 	struct da9034_touch *touch =
 		container_of(nb, struct da9034_touch, notifier);
 
-	if (event & DA9034_EVENT_PEN_DOWN) {
-		if (is_pen_down(touch))
-			da9034_event_handler(touch, EVENT_PEN_DOWN);
-		else
-			da9034_event_handler(touch, EVENT_PEN_UP);
-	}
-
 	if (event & DA9034_EVENT_TSI_READY)
 		da9034_event_handler(touch, EVENT_TSI_READY);
 
+	if ((event & DA9034_EVENT_PEN_DOWN) && touch->state == STATE_IDLE)
+		da9034_event_handler(touch, EVENT_PEN_DOWN);
+
 	return 0;
 }
 
@@ -385,6 +392,6 @@
 module_exit(da9034_touch_exit);
 
 MODULE_DESCRIPTION("Touchscreen driver for Dialog Semiconductor DA9034");
-MODULE_AUTHOR("Eric Miao <eric.miao@marvell.com>");
+MODULE_AUTHOR("Eric Miao <eric.miao@marvell.com>, Bin Yang <bin.yang@marvell.com>");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:da9034-touch");
diff -urN linux-2.6.30-rc2/drivers/input/touchscreen/mainstone-wm97xx.c linux-2.6.30-rc3/drivers/input/touchscreen/mainstone-wm97xx.c
--- linux-2.6.30-rc2/drivers/input/touchscreen/mainstone-wm97xx.c	2009-04-22 03:29:10.757556743 +0000
+++ linux-2.6.30-rc3/drivers/input/touchscreen/mainstone-wm97xx.c	2009-04-22 03:29:16.797931448 +0000
@@ -111,13 +111,12 @@
 #else
 static void wm97xx_acc_pen_up(struct wm97xx *wm)
 {
-	int count = 16;
+	unsigned int count;
+
 	schedule_timeout_uninterruptible(1);
 
-	while (count < 16) {
+	for (count = 0; count < 16; count++)
 		MODR;
-		count--;
-	}
 }
 #endif
 
diff -urN linux-2.6.30-rc2/drivers/input/touchscreen/wm97xx-core.c linux-2.6.30-rc3/drivers/input/touchscreen/wm97xx-core.c
--- linux-2.6.30-rc2/drivers/input/touchscreen/wm97xx-core.c	2009-04-22 03:29:10.758931442 +0000
+++ linux-2.6.30-rc3/drivers/input/touchscreen/wm97xx-core.c	2009-04-22 03:29:16.798931635 +0000
@@ -370,8 +370,7 @@
 	 * provided. */
 	BUG_ON(!wm->mach_ops->irq_enable);
 
-	if (request_irq(wm->pen_irq, wm97xx_pen_interrupt,
-			IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+	if (request_irq(wm->pen_irq, wm97xx_pen_interrupt, IRQF_SHARED,
 			"wm97xx-pen", wm)) {
 		dev_err(wm->dev,
 			"Failed to register pen down interrupt, polling");
diff -urN linux-2.6.30-rc2/drivers/isdn/hisax/st5481_usb.c linux-2.6.30-rc3/drivers/isdn/hisax/st5481_usb.c
--- linux-2.6.30-rc2/drivers/isdn/hisax/st5481_usb.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/isdn/hisax/st5481_usb.c	2009-04-22 03:29:16.806931721 +0000
@@ -149,14 +149,7 @@
 	if (ctrl_msg->dr.bRequest == USB_REQ_CLEAR_FEATURE) {
 	        /* Special case handling for pipe reset */
 		le16_to_cpus(&ctrl_msg->dr.wIndex);
-
-		/* toggle is reset on clear */
-		usb_settoggle(adapter->usb_dev, 
-			      ctrl_msg->dr.wIndex & ~USB_DIR_IN, 
-			      (ctrl_msg->dr.wIndex & USB_DIR_IN) == 0,
-			      0);
-
-
+		usb_reset_endpoint(adapter->usb_dev, ctrl_msg->dr.wIndex);
 	}
 	
 	if (ctrl_msg->complete)
diff -urN linux-2.6.30-rc2/drivers/lguest/lg.h linux-2.6.30-rc3/drivers/lguest/lg.h
--- linux-2.6.30-rc2/drivers/lguest/lg.h	2009-04-22 03:29:10.770931433 +0000
+++ linux-2.6.30-rc3/drivers/lguest/lg.h	2009-04-22 03:29:16.810931479 +0000
@@ -158,7 +158,8 @@
 /* segments.c: */
 void setup_default_gdt_entries(struct lguest_ro_state *state);
 void setup_guest_gdt(struct lg_cpu *cpu);
-void load_guest_gdt(struct lg_cpu *cpu, unsigned long table, u32 num);
+void load_guest_gdt_entry(struct lg_cpu *cpu, unsigned int i,
+			  u32 low, u32 hi);
 void guest_load_tls(struct lg_cpu *cpu, unsigned long tls_array);
 void copy_gdt(const struct lg_cpu *cpu, struct desc_struct *gdt);
 void copy_gdt_tls(const struct lg_cpu *cpu, struct desc_struct *gdt);
diff -urN linux-2.6.30-rc2/drivers/lguest/segments.c linux-2.6.30-rc3/drivers/lguest/segments.c
--- linux-2.6.30-rc2/drivers/lguest/segments.c	2009-04-22 03:29:10.771931396 +0000
+++ linux-2.6.30-rc3/drivers/lguest/segments.c	2009-04-22 03:29:16.811722714 +0000
@@ -144,18 +144,19 @@
 			gdt[i] = cpu->arch.gdt[i];
 }
 
-/*H:620 This is where the Guest asks us to load a new GDT (LHCALL_LOAD_GDT).
- * We copy it from the Guest and tweak the entries. */
-void load_guest_gdt(struct lg_cpu *cpu, unsigned long table, u32 num)
+/*H:620 This is where the Guest asks us to load a new GDT entry
+ * (LHCALL_LOAD_GDT_ENTRY).  We tweak the entry and copy it in. */
+void load_guest_gdt_entry(struct lg_cpu *cpu, u32 num, u32 lo, u32 hi)
 {
 	/* We assume the Guest has the same number of GDT entries as the
 	 * Host, otherwise we'd have to dynamically allocate the Guest GDT. */
 	if (num > ARRAY_SIZE(cpu->arch.gdt))
 		kill_guest(cpu, "too many gdt entries %i", num);
 
-	/* We read the whole thing in, then fix it up. */
-	__lgread(cpu, cpu->arch.gdt, table, num * sizeof(cpu->arch.gdt[0]));
-	fixup_gdt_table(cpu, 0, ARRAY_SIZE(cpu->arch.gdt));
+	/* Set it up, then fix it. */
+	cpu->arch.gdt[num].a = lo;
+	cpu->arch.gdt[num].b = hi;
+	fixup_gdt_table(cpu, num, num+1);
 	/* Mark that the GDT changed so the core knows it has to copy it again,
 	 * even if the Guest is run on the same CPU. */
 	cpu->changed |= CHANGED_GDT;
diff -urN linux-2.6.30-rc2/drivers/lguest/x86/core.c linux-2.6.30-rc3/drivers/lguest/x86/core.c
--- linux-2.6.30-rc2/drivers/lguest/x86/core.c	2009-04-22 03:29:10.771931396 +0000
+++ linux-2.6.30-rc3/drivers/lguest/x86/core.c	2009-04-22 03:29:16.811722714 +0000
@@ -324,6 +324,11 @@
 	u8 insn[3] = {0xcd, 0x1f, 0x90};
 
 	__lgwrite(cpu, guest_pa(cpu, cpu->regs->eip), insn, sizeof(insn));
+	/* The above write might have caused a copy of that page to be made
+	 * (if it was read-only).  We need to make sure the Guest has
+	 * up-to-date pagetables.  As this doesn't happen often, we can just
+	 * drop them all. */
+	guest_pagetable_clear_all(cpu);
 }
 
 static bool is_hypercall(struct lg_cpu *cpu)
@@ -563,8 +568,8 @@
 int lguest_arch_do_hcall(struct lg_cpu *cpu, struct hcall_args *args)
 {
 	switch (args->arg0) {
-	case LHCALL_LOAD_GDT:
-		load_guest_gdt(cpu, args->arg1, args->arg2);
+	case LHCALL_LOAD_GDT_ENTRY:
+		load_guest_gdt_entry(cpu, args->arg1, args->arg2, args->arg3);
 		break;
 	case LHCALL_LOAD_IDT_ENTRY:
 		load_guest_idt_entry(cpu, args->arg1, args->arg2, args->arg3);
diff -urN linux-2.6.30-rc2/drivers/md/bitmap.c linux-2.6.30-rc3/drivers/md/bitmap.c
--- linux-2.6.30-rc2/drivers/md/bitmap.c	2009-04-22 03:29:10.772931410 +0000
+++ linux-2.6.30-rc3/drivers/md/bitmap.c	2009-04-22 03:29:16.812931510 +0000
@@ -1479,6 +1479,7 @@
 		s += blocks;
 	}
 	bitmap->last_end_sync = jiffies;
+	sysfs_notify(&bitmap->mddev->kobj, NULL, "sync_completed");
 }
 
 static void bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset, int needed)
@@ -1589,7 +1590,7 @@
 int bitmap_create(mddev_t *mddev)
 {
 	struct bitmap *bitmap;
-	unsigned long blocks = mddev->resync_max_sectors;
+	sector_t blocks = mddev->resync_max_sectors;
 	unsigned long chunks;
 	unsigned long pages;
 	struct file *file = mddev->bitmap_file;
@@ -1631,8 +1632,8 @@
 	bitmap->chunkshift = ffz(~bitmap->chunksize);
 
 	/* now that chunksize and chunkshift are set, we can use these macros */
- 	chunks = (blocks + CHUNK_BLOCK_RATIO(bitmap) - 1) /
-			CHUNK_BLOCK_RATIO(bitmap);
+ 	chunks = (blocks + CHUNK_BLOCK_RATIO(bitmap) - 1) >>
+			CHUNK_BLOCK_SHIFT(bitmap);
  	pages = (chunks + PAGE_COUNTER_RATIO - 1) / PAGE_COUNTER_RATIO;
 
 	BUG_ON(!pages);
diff -urN linux-2.6.30-rc2/drivers/md/dm-bio-list.h linux-2.6.30-rc3/drivers/md/dm-bio-list.h
--- linux-2.6.30-rc2/drivers/md/dm-bio-list.h	2009-04-22 03:29:10.772931410 +0000
+++ linux-2.6.30-rc3/drivers/md/dm-bio-list.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2004 Red Hat UK Ltd.
- *
- * This file is released under the GPL.
- */
-
-#ifndef DM_BIO_LIST_H
-#define DM_BIO_LIST_H
-
-#include <linux/bio.h>
-
-#ifdef CONFIG_BLOCK
-
-struct bio_list {
-	struct bio *head;
-	struct bio *tail;
-};
-
-static inline int bio_list_empty(const struct bio_list *bl)
-{
-	return bl->head == NULL;
-}
-
-static inline void bio_list_init(struct bio_list *bl)
-{
-	bl->head = bl->tail = NULL;
-}
-
-#define bio_list_for_each(bio, bl) \
-	for (bio = (bl)->head; bio; bio = bio->bi_next)
-
-static inline unsigned bio_list_size(const struct bio_list *bl)
-{
-	unsigned sz = 0;
-	struct bio *bio;
-
-	bio_list_for_each(bio, bl)
-		sz++;
-
-	return sz;
-}
-
-static inline void bio_list_add(struct bio_list *bl, struct bio *bio)
-{
-	bio->bi_next = NULL;
-
-	if (bl->tail)
-		bl->tail->bi_next = bio;
-	else
-		bl->head = bio;
-
-	bl->tail = bio;
-}
-
-static inline void bio_list_add_head(struct bio_list *bl, struct bio *bio)
-{
-	bio->bi_next = bl->head;
-
-	bl->head = bio;
-
-	if (!bl->tail)
-		bl->tail = bio;
-}
-
-static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
-{
-	if (!bl2->head)
-		return;
-
-	if (bl->tail)
-		bl->tail->bi_next = bl2->head;
-	else
-		bl->head = bl2->head;
-
-	bl->tail = bl2->tail;
-}
-
-static inline void bio_list_merge_head(struct bio_list *bl,
-				       struct bio_list *bl2)
-{
-	if (!bl2->head)
-		return;
-
-	if (bl->head)
-		bl2->tail->bi_next = bl->head;
-	else
-		bl->tail = bl2->tail;
-
-	bl->head = bl2->head;
-}
-
-static inline struct bio *bio_list_pop(struct bio_list *bl)
-{
-	struct bio *bio = bl->head;
-
-	if (bio) {
-		bl->head = bl->head->bi_next;
-		if (!bl->head)
-			bl->tail = NULL;
-
-		bio->bi_next = NULL;
-	}
-
-	return bio;
-}
-
-static inline struct bio *bio_list_get(struct bio_list *bl)
-{
-	struct bio *bio = bl->head;
-
-	bl->head = bl->tail = NULL;
-
-	return bio;
-}
-
-#endif /* CONFIG_BLOCK */
-#endif
diff -urN linux-2.6.30-rc2/drivers/md/dm-delay.c linux-2.6.30-rc3/drivers/md/dm-delay.c
--- linux-2.6.30-rc2/drivers/md/dm-delay.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/md/dm-delay.c	2009-04-22 03:29:16.813931553 +0000
@@ -15,8 +15,6 @@
 
 #include <linux/device-mapper.h>
 
-#include "dm-bio-list.h"
-
 #define DM_MSG_PREFIX "delay"
 
 struct delay_c {
diff -urN linux-2.6.30-rc2/drivers/md/dm-mpath.c linux-2.6.30-rc3/drivers/md/dm-mpath.c
--- linux-2.6.30-rc2/drivers/md/dm-mpath.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/md/dm-mpath.c	2009-04-22 03:29:16.815869434 +0000
@@ -8,7 +8,6 @@
 #include <linux/device-mapper.h>
 
 #include "dm-path-selector.h"
-#include "dm-bio-list.h"
 #include "dm-bio-record.h"
 #include "dm-uevent.h"
 
diff -urN linux-2.6.30-rc2/drivers/md/dm-raid1.c linux-2.6.30-rc3/drivers/md/dm-raid1.c
--- linux-2.6.30-rc2/drivers/md/dm-raid1.c	2009-04-22 03:29:10.774931410 +0000
+++ linux-2.6.30-rc3/drivers/md/dm-raid1.c	2009-04-22 03:29:16.815869434 +0000
@@ -5,7 +5,6 @@
  * This file is released under the GPL.
  */
 
-#include "dm-bio-list.h"
 #include "dm-bio-record.h"
 
 #include <linux/init.h>
diff -urN linux-2.6.30-rc2/drivers/md/dm-region-hash.c linux-2.6.30-rc3/drivers/md/dm-region-hash.c
--- linux-2.6.30-rc2/drivers/md/dm-region-hash.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/md/dm-region-hash.c	2009-04-22 03:29:16.816931418 +0000
@@ -14,7 +14,6 @@
 #include <linux/vmalloc.h>
 
 #include "dm.h"
-#include "dm-bio-list.h"
 
 #define	DM_MSG_PREFIX	"region hash"
 
diff -urN linux-2.6.30-rc2/drivers/md/dm-snap.c linux-2.6.30-rc3/drivers/md/dm-snap.c
--- linux-2.6.30-rc2/drivers/md/dm-snap.c	2009-04-22 03:29:10.776931410 +0000
+++ linux-2.6.30-rc3/drivers/md/dm-snap.c	2009-04-22 03:29:16.817931419 +0000
@@ -22,7 +22,6 @@
 #include <linux/workqueue.h>
 
 #include "dm-exception-store.h"
-#include "dm-bio-list.h"
 
 #define DM_MSG_PREFIX "snapshots"
 
diff -urN linux-2.6.30-rc2/drivers/md/dm.c linux-2.6.30-rc3/drivers/md/dm.c
--- linux-2.6.30-rc2/drivers/md/dm.c	2009-04-22 03:29:10.777931418 +0000
+++ linux-2.6.30-rc3/drivers/md/dm.c	2009-04-22 03:29:16.818931439 +0000
@@ -6,7 +6,6 @@
  */
 
 #include "dm.h"
-#include "dm-bio-list.h"
 #include "dm-uevent.h"
 
 #include <linux/init.h>
diff -urN linux-2.6.30-rc2/drivers/md/md.c linux-2.6.30-rc3/drivers/md/md.c
--- linux-2.6.30-rc2/drivers/md/md.c	2009-04-22 03:29:10.780931183 +0000
+++ linux-2.6.30-rc3/drivers/md/md.c	2009-04-22 03:29:16.820931524 +0000
@@ -2017,6 +2017,8 @@
 	clear_bit(MD_CHANGE_PENDING, &mddev->flags);
 	spin_unlock_irq(&mddev->write_lock);
 	wake_up(&mddev->sb_wait);
+	if (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))
+		sysfs_notify(&mddev->kobj, NULL, "sync_completed");
 
 }
 
@@ -2086,6 +2088,7 @@
 	 *  -writemostly - clears write_mostly
 	 *  blocked - sets the Blocked flag
 	 *  -blocked - clears the Blocked flag
+	 *  insync - sets Insync providing device isn't active
 	 */
 	int err = -EINVAL;
 	if (cmd_match(buf, "faulty") && rdev->mddev->pers) {
@@ -2118,6 +2121,9 @@
 		md_wakeup_thread(rdev->mddev->thread);
 
 		err = 0;
+	} else if (cmd_match(buf, "insync") && rdev->raid_disk == -1) {
+		set_bit(In_sync, &rdev->flags);
+		err = 0;
 	}
 	if (!err && rdev->sysfs_state)
 		sysfs_notify_dirent(rdev->sysfs_state);
@@ -2190,7 +2196,7 @@
 	} else if (rdev->mddev->pers) {
 		mdk_rdev_t *rdev2;
 		/* Activating a spare .. or possibly reactivating
-		 * if we every get bitmaps working here.
+		 * if we ever get bitmaps working here.
 		 */
 
 		if (rdev->raid_disk != -1)
@@ -3482,12 +3488,15 @@
 {
 	unsigned long max_sectors, resync;
 
+	if (!test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))
+		return sprintf(page, "none\n");
+
 	if (test_bit(MD_RECOVERY_SYNC, &mddev->recovery))
 		max_sectors = mddev->resync_max_sectors;
 	else
 		max_sectors = mddev->dev_sectors;
 
-	resync = (mddev->curr_resync - atomic_read(&mddev->recovery_active));
+	resync = mddev->curr_resync_completed;
 	return sprintf(page, "%lu / %lu\n", resync, max_sectors);
 }
 
@@ -6334,18 +6343,13 @@
 		sector_t sectors;
 
 		skipped = 0;
-		if (j >= mddev->resync_max) {
-			sysfs_notify(&mddev->kobj, NULL, "sync_completed");
-			wait_event(mddev->recovery_wait,
-				   mddev->resync_max > j
-				   || kthread_should_stop());
-		}
-		if (kthread_should_stop())
-			goto interrupted;
 
-		if (mddev->curr_resync > mddev->curr_resync_completed &&
-		    (mddev->curr_resync - mddev->curr_resync_completed)
-		    > (max_sectors >> 4)) {
+		if ((mddev->curr_resync > mddev->curr_resync_completed &&
+		     (mddev->curr_resync - mddev->curr_resync_completed)
+		    > (max_sectors >> 4)) ||
+		    (j - mddev->curr_resync_completed)*2
+		    >= mddev->resync_max - mddev->curr_resync_completed
+			) {
 			/* time to update curr_resync_completed */
 			blk_unplug(mddev->queue);
 			wait_event(mddev->recovery_wait,
@@ -6353,7 +6357,17 @@
 			mddev->curr_resync_completed =
 				mddev->curr_resync;
 			set_bit(MD_CHANGE_CLEAN, &mddev->flags);
+			sysfs_notify(&mddev->kobj, NULL, "sync_completed");
 		}
+
+		if (j >= mddev->resync_max)
+			wait_event(mddev->recovery_wait,
+				   mddev->resync_max > j
+				   || kthread_should_stop());
+
+		if (kthread_should_stop())
+			goto interrupted;
+
 		sectors = mddev->pers->sync_request(mddev, j, &skipped,
 						  currspeed < speed_min(mddev));
 		if (sectors == 0) {
@@ -6461,6 +6475,7 @@
 
  skip:
 	mddev->curr_resync = 0;
+	mddev->curr_resync_completed = 0;
 	mddev->resync_min = 0;
 	mddev->resync_max = MaxSector;
 	sysfs_notify(&mddev->kobj, NULL, "sync_completed");
diff -urN linux-2.6.30-rc2/drivers/md/md.h linux-2.6.30-rc3/drivers/md/md.h
--- linux-2.6.30-rc2/drivers/md/md.h	2009-04-22 03:29:10.780931183 +0000
+++ linux-2.6.30-rc3/drivers/md/md.h	2009-04-22 03:29:16.821931402 +0000
@@ -12,10 +12,17 @@
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
 */
 
-#ifndef _MD_K_H
-#define _MD_K_H
+#ifndef _MD_MD_H
+#define _MD_MD_H
 
-#ifdef CONFIG_BLOCK
+#include <linux/blkdev.h>
+#include <linux/kobject.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
 
 #define MaxSector (~(sector_t)0)
 
@@ -408,10 +415,6 @@
 	if (p) put_page(p);
 }
 
-#endif /* CONFIG_BLOCK */
-#endif
-
-
 extern int register_md_personality(struct mdk_personality *p);
 extern int unregister_md_personality(struct mdk_personality *p);
 extern mdk_thread_t * md_register_thread(void (*run) (mddev_t *mddev),
@@ -434,3 +437,5 @@
 extern int md_allow_write(mddev_t *mddev);
 extern void md_wait_for_blocked_rdev(mdk_rdev_t *rdev, mddev_t *mddev);
 extern void md_set_array_sectors(mddev_t *mddev, sector_t array_sectors);
+
+#endif /* _MD_MD_H */
diff -urN linux-2.6.30-rc2/drivers/md/raid1.c linux-2.6.30-rc3/drivers/md/raid1.c
--- linux-2.6.30-rc2/drivers/md/raid1.c	2009-04-22 03:29:10.781813146 +0000
+++ linux-2.6.30-rc3/drivers/md/raid1.c	2009-04-22 03:29:16.822931428 +0000
@@ -35,7 +35,6 @@
 #include <linux/blkdev.h>
 #include <linux/seq_file.h>
 #include "md.h"
-#include "dm-bio-list.h"
 #include "raid1.h"
 #include "bitmap.h"
 
diff -urN linux-2.6.30-rc2/drivers/md/raid10.c linux-2.6.30-rc3/drivers/md/raid10.c
--- linux-2.6.30-rc2/drivers/md/raid10.c	2009-04-22 03:29:10.782931412 +0000
+++ linux-2.6.30-rc3/drivers/md/raid10.c	2009-04-22 03:29:16.823931232 +0000
@@ -22,7 +22,6 @@
 #include <linux/blkdev.h>
 #include <linux/seq_file.h>
 #include "md.h"
-#include "dm-bio-list.h"
 #include "raid10.h"
 #include "bitmap.h"
 
diff -urN linux-2.6.30-rc2/drivers/md/raid5.c linux-2.6.30-rc3/drivers/md/raid5.c
--- linux-2.6.30-rc2/drivers/md/raid5.c	2009-04-22 03:29:10.784931196 +0000
+++ linux-2.6.30-rc3/drivers/md/raid5.c	2009-04-22 03:29:16.825931226 +0000
@@ -3845,6 +3845,7 @@
 		wait_event(conf->wait_for_overlap,
 			   atomic_read(&conf->reshape_stripes)==0);
 		mddev->reshape_position = conf->reshape_progress;
+		mddev->curr_resync_completed = mddev->curr_resync;
 		conf->reshape_checkpoint = jiffies;
 		set_bit(MD_CHANGE_DEVS, &mddev->flags);
 		md_wakeup_thread(mddev->thread);
@@ -3854,6 +3855,7 @@
 		conf->reshape_safe = mddev->reshape_position;
 		spin_unlock_irq(&conf->device_lock);
 		wake_up(&conf->wait_for_overlap);
+		sysfs_notify(&mddev->kobj, NULL, "sync_completed");
 	}
 
 	if (mddev->delta_disks < 0) {
@@ -3938,11 +3940,13 @@
 	 * then we need to write out the superblock.
 	 */
 	sector_nr += reshape_sectors;
-	if (sector_nr >= mddev->resync_max) {
+	if ((sector_nr - mddev->curr_resync_completed) * 2
+	    >= mddev->resync_max - mddev->curr_resync_completed) {
 		/* Cannot proceed until we've updated the superblock... */
 		wait_event(conf->wait_for_overlap,
 			   atomic_read(&conf->reshape_stripes) == 0);
 		mddev->reshape_position = conf->reshape_progress;
+		mddev->curr_resync_completed = mddev->curr_resync;
 		conf->reshape_checkpoint = jiffies;
 		set_bit(MD_CHANGE_DEVS, &mddev->flags);
 		md_wakeup_thread(mddev->thread);
@@ -3953,6 +3957,7 @@
 		conf->reshape_safe = mddev->reshape_position;
 		spin_unlock_irq(&conf->device_lock);
 		wake_up(&conf->wait_for_overlap);
+		sysfs_notify(&mddev->kobj, NULL, "sync_completed");
 	}
 	return reshape_sectors;
 }
diff -urN linux-2.6.30-rc2/drivers/media/video/pvrusb2/pvrusb2-hdw.c linux-2.6.30-rc3/drivers/media/video/pvrusb2/pvrusb2-hdw.c
--- linux-2.6.30-rc2/drivers/media/video/pvrusb2/pvrusb2-hdw.c	2009-04-22 03:29:10.902931285 +0000
+++ linux-2.6.30-rc3/drivers/media/video/pvrusb2/pvrusb2-hdw.c	2009-04-22 03:29:16.942556025 +0000
@@ -1461,7 +1461,6 @@
 		return ret;
 	}
 
-	usb_settoggle(hdw->usb_dev, 0 & 0xf, !(0 & USB_DIR_IN), 0);
 	usb_clear_halt(hdw->usb_dev, usb_sndbulkpipe(hdw->usb_dev, 0 & 0x7f));
 
 	pipe = usb_sndctrlpipe(hdw->usb_dev, 0);
diff -urN linux-2.6.30-rc2/drivers/message/fusion/mptbase.c linux-2.6.30-rc3/drivers/message/fusion/mptbase.c
--- linux-2.6.30-rc2/drivers/message/fusion/mptbase.c	2009-04-22 03:29:10.943931344 +0000
+++ linux-2.6.30-rc3/drivers/message/fusion/mptbase.c	2009-04-22 03:29:16.983931630 +0000
@@ -5934,7 +5934,7 @@
 
 	/* Initalize the timer
 	 */
-	init_timer(&pCfg->timer);
+	init_timer_on_stack(&pCfg->timer);
 	pCfg->timer.data = (unsigned long) ioc;
 	pCfg->timer.function = mpt_timer_expired;
 	pCfg->wait_done = 0;
diff -urN linux-2.6.30-rc2/drivers/misc/sgi-gru/grufile.c linux-2.6.30-rc3/drivers/misc/sgi-gru/grufile.c
--- linux-2.6.30-rc2/drivers/misc/sgi-gru/grufile.c	2009-04-22 03:29:10.948931428 +0000
+++ linux-2.6.30-rc3/drivers/misc/sgi-gru/grufile.c	2009-04-22 03:29:16.988931426 +0000
@@ -375,7 +375,7 @@
 	void *gru_start_vaddr;
 
 	if (!is_uv_system())
-		return -ENODEV;
+		return 0;
 
 #if defined CONFIG_IA64
 	gru_start_paddr = 0xd000000000UL; /* ZZZZZZZZZZZZZZZZZZZ fixme */
diff -urN linux-2.6.30-rc2/drivers/misc/sgi-xp/xp_main.c linux-2.6.30-rc3/drivers/misc/sgi-xp/xp_main.c
--- linux-2.6.30-rc2/drivers/misc/sgi-xp/xp_main.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/misc/sgi-xp/xp_main.c	2009-04-22 03:29:16.991931575 +0000
@@ -248,19 +248,19 @@
 	enum xp_retval ret;
 	int ch_number;
 
+	/* initialize the connection registration mutex */
+	for (ch_number = 0; ch_number < XPC_MAX_NCHANNELS; ch_number++)
+		mutex_init(&xpc_registrations[ch_number].mutex);
+
 	if (is_shub())
 		ret = xp_init_sn2();
 	else if (is_uv())
 		ret = xp_init_uv();
 	else
-		ret = xpUnsupported;
+		ret = 0;
 
 	if (ret != xpSuccess)
-		return -ENODEV;
-
-	/* initialize the connection registration mutex */
-	for (ch_number = 0; ch_number < XPC_MAX_NCHANNELS; ch_number++)
-		mutex_init(&xpc_registrations[ch_number].mutex);
+		return ret;
 
 	return 0;
 }
diff -urN linux-2.6.30-rc2/drivers/net/a2065.c linux-2.6.30-rc3/drivers/net/a2065.c
--- linux-2.6.30-rc2/drivers/net/a2065.c	2009-04-22 03:29:10.980931421 +0000
+++ linux-2.6.30-rc3/drivers/net/a2065.c	2009-04-22 03:29:17.021582631 +0000
@@ -692,6 +692,17 @@
 	.remove		= __devexit_p(a2065_remove_one),
 };
 
+static const struct net_device_ops lance_netdev_ops = {
+	.ndo_open		= lance_open,
+	.ndo_stop		= lance_close,
+	.ndo_start_xmit		= lance_start_xmit,
+	.ndo_tx_timeout		= lance_tx_timeout,
+	.ndo_set_multicast_list	= lance_set_multicast,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __devinit a2065_init_one(struct zorro_dev *z,
 				    const struct zorro_device_id *ent)
 {
@@ -753,12 +764,8 @@
 	priv->rx_ring_mod_mask = RX_RING_MOD_MASK;
 	priv->tx_ring_mod_mask = TX_RING_MOD_MASK;
 
-	dev->open = &lance_open;
-	dev->stop = &lance_close;
-	dev->hard_start_xmit = &lance_start_xmit;
-	dev->tx_timeout = &lance_tx_timeout;
+	dev->netdev_ops = &lance_netdev_ops;
 	dev->watchdog_timeo = 5*HZ;
-	dev->set_multicast_list = &lance_set_multicast;
 	dev->dma = 0;
 
 	init_timer(&priv->multicast_timer);
diff -urN linux-2.6.30-rc2/drivers/net/ariadne.c linux-2.6.30-rc3/drivers/net/ariadne.c
--- linux-2.6.30-rc2/drivers/net/ariadne.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/ariadne.c	2009-04-22 03:29:17.024931459 +0000
@@ -155,6 +155,18 @@
     .remove	= __devexit_p(ariadne_remove_one),
 };
 
+static const struct net_device_ops ariadne_netdev_ops = {
+	.ndo_open		= ariadne_open,
+	.ndo_stop		= ariadne_close,
+	.ndo_start_xmit		= ariadne_start_xmit,
+	.ndo_tx_timeout		= ariadne_tx_timeout,
+	.ndo_get_stats		= ariadne_get_stats,
+	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __devinit ariadne_init_one(struct zorro_dev *z,
 				      const struct zorro_device_id *ent)
 {
@@ -197,13 +209,8 @@
     dev->mem_start = ZTWO_VADDR(mem_start);
     dev->mem_end = dev->mem_start+ARIADNE_RAM_SIZE;
 
-    dev->open = &ariadne_open;
-    dev->stop = &ariadne_close;
-    dev->hard_start_xmit = &ariadne_start_xmit;
-    dev->tx_timeout = &ariadne_tx_timeout;
+    dev->netdev_ops = &ariadne_netdev_ops;
     dev->watchdog_timeo = 5*HZ;
-    dev->get_stats = &ariadne_get_stats;
-    dev->set_multicast_list = &set_multicast_list;
 
     err = register_netdev(dev);
     if (err) {
diff -urN linux-2.6.30-rc2/drivers/net/arm/am79c961a.c linux-2.6.30-rc3/drivers/net/arm/am79c961a.c
--- linux-2.6.30-rc2/drivers/net/arm/am79c961a.c	2009-04-22 03:29:10.984631675 +0000
+++ linux-2.6.30-rc3/drivers/net/arm/am79c961a.c	2009-04-22 03:29:17.024931459 +0000
@@ -665,6 +665,20 @@
 	if (net_debug && version_printed++ == 0)
 		printk(KERN_INFO "%s", version);
 }
+static const struct net_device_ops am79c961_netdev_ops = {
+	.ndo_open		= am79c961_open,
+	.ndo_stop		= am79c961_close,
+	.ndo_start_xmit		= am79c961_sendpacket,
+	.ndo_get_stats		= am79c961_getstats,
+	.ndo_set_multicast_list	= am79c961_setmulticastlist,
+	.ndo_tx_timeout		= am79c961_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= am79c961_poll_controller,
+#endif
+};
 
 static int __init am79c961_probe(struct platform_device *pdev)
 {
@@ -732,15 +746,7 @@
 	if (am79c961_hw_init(dev))
 		goto release;
 
-	dev->open		= am79c961_open;
-	dev->stop		= am79c961_close;
-	dev->hard_start_xmit	= am79c961_sendpacket;
-	dev->get_stats		= am79c961_getstats;
-	dev->set_multicast_list	= am79c961_setmulticastlist;
-	dev->tx_timeout		= am79c961_timeout;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	dev->poll_controller	= am79c961_poll_controller;
-#endif
+	dev->netdev_ops = &am79c961_netdev_ops;
 
 	ret = register_netdev(dev);
 	if (ret == 0) {
diff -urN linux-2.6.30-rc2/drivers/net/arm/at91_ether.c linux-2.6.30-rc3/drivers/net/arm/at91_ether.c
--- linux-2.6.30-rc2/drivers/net/arm/at91_ether.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/arm/at91_ether.c	2009-04-22 03:29:17.024931459 +0000
@@ -577,7 +577,7 @@
 /*
  * Enable/Disable promiscuous and multicast modes.
  */
-static void at91ether_set_rx_mode(struct net_device *dev)
+static void at91ether_set_multicast_list(struct net_device *dev)
 {
 	unsigned long cfg;
 
@@ -808,7 +808,7 @@
 /*
  * Transmit packet.
  */
-static int at91ether_tx(struct sk_buff *skb, struct net_device *dev)
+static int at91ether_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct at91_private *lp = netdev_priv(dev);
 
@@ -828,7 +828,7 @@
 
 		dev->trans_start = jiffies;
 	} else {
-		printk(KERN_ERR "at91_ether.c: at91ether_tx() called, but device is busy!\n");
+		printk(KERN_ERR "at91_ether.c: at91ether_start_xmit() called, but device is busy!\n");
 		return 1;	/* if we return anything but zero, dev.c:1055 calls kfree_skb(skb)
 				on this skb, he also reports -ENETDOWN and printk's, so either
 				we free and return(0) or don't free and return 1 */
@@ -965,6 +965,21 @@
 }
 #endif
 
+static const struct net_device_ops at91ether_netdev_ops = {
+	.ndo_open		= at91ether_open,
+	.ndo_stop		= at91ether_close,
+	.ndo_start_xmit		= at91ether_start_xmit,
+	.ndo_get_stats		= at91ether_stats,
+	.ndo_set_multicast_list	= at91ether_set_multicast_list,
+	.ndo_set_mac_address	= set_mac_address,
+	.ndo_do_ioctl		= at91ether_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= at91ether_poll_controller,
+#endif
+};
+
 /*
  * Initialize the ethernet interface
  */
@@ -1005,17 +1020,8 @@
 	spin_lock_init(&lp->lock);
 
 	ether_setup(dev);
-	dev->open = at91ether_open;
-	dev->stop = at91ether_close;
-	dev->hard_start_xmit = at91ether_tx;
-	dev->get_stats = at91ether_stats;
-	dev->set_multicast_list = at91ether_set_rx_mode;
-	dev->set_mac_address = set_mac_address;
+	dev->netdev_ops = &at91ether_netdev_ops;
 	dev->ethtool_ops = &at91ether_ethtool_ops;
-	dev->do_ioctl = at91ether_ioctl;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	dev->poll_controller = at91ether_poll_controller;
-#endif
 
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
diff -urN linux-2.6.30-rc2/drivers/net/arm/ep93xx_eth.c linux-2.6.30-rc3/drivers/net/arm/ep93xx_eth.c
--- linux-2.6.30-rc2/drivers/net/arm/ep93xx_eth.c	2009-04-22 03:29:10.984631675 +0000
+++ linux-2.6.30-rc3/drivers/net/arm/ep93xx_eth.c	2009-04-22 03:29:17.024931459 +0000
@@ -153,7 +153,7 @@
 struct ep93xx_priv
 {
 	struct resource		*res;
-	void			*base_addr;
+	void __iomem		*base_addr;
 	int			irq;
 
 	struct ep93xx_descs	*descs;
@@ -770,7 +770,18 @@
 	.get_link		= ep93xx_get_link,
 };
 
-struct net_device *ep93xx_dev_alloc(struct ep93xx_eth_data *data)
+static const struct net_device_ops ep93xx_netdev_ops = {
+	.ndo_open		= ep93xx_open,
+	.ndo_stop		= ep93xx_close,
+	.ndo_start_xmit		= ep93xx_xmit,
+	.ndo_get_stats		= ep93xx_get_stats,
+	.ndo_do_ioctl		= ep93xx_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
+static struct net_device *ep93xx_dev_alloc(struct ep93xx_eth_data *data)
 {
 	struct net_device *dev;
 
@@ -780,12 +791,8 @@
 
 	memcpy(dev->dev_addr, data->dev_addr, ETH_ALEN);
 
-	dev->get_stats = ep93xx_get_stats;
 	dev->ethtool_ops = &ep93xx_ethtool_ops;
-	dev->hard_start_xmit = ep93xx_xmit;
-	dev->open = ep93xx_open;
-	dev->stop = ep93xx_close;
-	dev->do_ioctl = ep93xx_ioctl;
+	dev->netdev_ops = &ep93xx_netdev_ops;
 
 	dev->features |= NETIF_F_SG | NETIF_F_HW_CSUM;
 
diff -urN linux-2.6.30-rc2/drivers/net/arm/ether1.c linux-2.6.30-rc3/drivers/net/arm/ether1.c
--- linux-2.6.30-rc2/drivers/net/arm/ether1.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/arm/ether1.c	2009-04-22 03:29:17.025931442 +0000
@@ -991,6 +991,18 @@
 		printk(KERN_INFO "%s", version);
 }
 
+static const struct net_device_ops ether1_netdev_ops = {
+	.ndo_open		= ether1_open,
+	.ndo_stop		= ether1_close,
+	.ndo_start_xmit		= ether1_sendpacket,
+	.ndo_get_stats		= ether1_getstats,
+	.ndo_set_multicast_list	= ether1_setmulticastlist,
+	.ndo_tx_timeout		= ether1_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __devinit
 ether1_probe(struct expansion_card *ec, const struct ecard_id *id)
 {
@@ -1031,12 +1043,7 @@
 		goto free;
 	}
 
-	dev->open		= ether1_open;
-	dev->stop		= ether1_close;
-	dev->hard_start_xmit    = ether1_sendpacket;
-	dev->get_stats		= ether1_getstats;
-	dev->set_multicast_list = ether1_setmulticastlist;
-	dev->tx_timeout		= ether1_timeout;
+	dev->netdev_ops		= &ether1_netdev_ops;
 	dev->watchdog_timeo	= 5 * HZ / 100;
 
 	ret = register_netdev(dev);
diff -urN linux-2.6.30-rc2/drivers/net/arm/ether3.c linux-2.6.30-rc3/drivers/net/arm/ether3.c
--- linux-2.6.30-rc2/drivers/net/arm/ether3.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/arm/ether3.c	2009-04-22 03:29:17.025931442 +0000
@@ -770,6 +770,18 @@
 		printk(KERN_INFO "%s", version);
 }
 
+static const struct net_device_ops ether3_netdev_ops = {
+	.ndo_open		= ether3_open,
+	.ndo_stop		= ether3_close,
+	.ndo_start_xmit		= ether3_sendpacket,
+	.ndo_get_stats		= ether3_getstats,
+	.ndo_set_multicast_list	= ether3_setmulticastlist,
+	.ndo_tx_timeout		= ether3_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __devinit
 ether3_probe(struct expansion_card *ec, const struct ecard_id *id)
 {
@@ -846,12 +858,7 @@
 		goto free;
 	}
 
-	dev->open		= ether3_open;
-	dev->stop		= ether3_close;
-	dev->hard_start_xmit	= ether3_sendpacket;
-	dev->get_stats		= ether3_getstats;
-	dev->set_multicast_list	= ether3_setmulticastlist;
-	dev->tx_timeout		= ether3_timeout;
+	dev->netdev_ops		= &ether3_netdev_ops;
 	dev->watchdog_timeo	= 5 * HZ / 100;
 
 	ret = register_netdev(dev);
diff -urN linux-2.6.30-rc2/drivers/net/atarilance.c linux-2.6.30-rc3/drivers/net/atarilance.c
--- linux-2.6.30-rc2/drivers/net/atarilance.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/atarilance.c	2009-04-22 03:29:17.026931429 +0000
@@ -453,6 +453,16 @@
 	return( ret );
 }
 
+static const struct net_device_ops lance_netdev_ops = {
+	.ndo_open		= lance_open,
+	.ndo_stop		= lance_close,
+	.ndo_start_xmit		= lance_start_xmit,
+	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_set_mac_address	= lance_set_mac_address,
+	.ndo_tx_timeout		= lance_tx_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
 
 static unsigned long __init lance_probe1( struct net_device *dev,
 					   struct lance_addr *init_rec )
@@ -623,15 +633,9 @@
 	if (did_version++ == 0)
 		DPRINTK( 1, ( version ));
 
-	/* The LANCE-specific entries in the device structure. */
-	dev->open = &lance_open;
-	dev->hard_start_xmit = &lance_start_xmit;
-	dev->stop = &lance_close;
-	dev->set_multicast_list = &set_multicast_list;
-	dev->set_mac_address = &lance_set_mac_address;
+	dev->netdev_ops = &lance_netdev_ops;
 
 	/* XXX MSch */
-	dev->tx_timeout = lance_tx_timeout;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
 	return( 1 );
diff -urN linux-2.6.30-rc2/drivers/net/au1000_eth.c linux-2.6.30-rc3/drivers/net/au1000_eth.c
--- linux-2.6.30-rc2/drivers/net/au1000_eth.c	2009-04-22 03:29:10.988931501 +0000
+++ linux-2.6.30-rc3/drivers/net/au1000_eth.c	2009-04-22 03:29:17.030931289 +0000
@@ -1004,12 +1004,12 @@
 	netif_wake_queue(dev);
 }
 
-static void set_rx_mode(struct net_device *dev)
+static void au1000_multicast_list(struct net_device *dev)
 {
 	struct au1000_private *aup = netdev_priv(dev);
 
 	if (au1000_debug > 4)
-		printk("%s: set_rx_mode: flags=%x\n", dev->name, dev->flags);
+		printk("%s: au1000_multicast_list: flags=%x\n", dev->name, dev->flags);
 
 	if (dev->flags & IFF_PROMISC) {			/* Set promiscuous. */
 		aup->mac->control |= MAC_PROMISCUOUS;
@@ -1047,6 +1047,18 @@
 	return phy_mii_ioctl(aup->phy_dev, if_mii(rq), cmd);
 }
 
+static const struct net_device_ops au1000_netdev_ops = {
+	.ndo_open		= au1000_open,
+	.ndo_stop		= au1000_close,
+	.ndo_start_xmit		= au1000_tx,
+	.ndo_set_multicast_list	= au1000_multicast_list,
+	.ndo_do_ioctl		= au1000_ioctl,
+	.ndo_tx_timeout		= au1000_tx_timeout,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 static struct net_device * au1000_probe(int port_num)
 {
 	static unsigned version_printed = 0;
@@ -1197,13 +1209,8 @@
 
 	dev->base_addr = base;
 	dev->irq = irq;
-	dev->open = au1000_open;
-	dev->hard_start_xmit = au1000_tx;
-	dev->stop = au1000_close;
-	dev->set_multicast_list = &set_rx_mode;
-	dev->do_ioctl = &au1000_ioctl;
+	dev->netdev_ops = &au1000_netdev_ops;
 	SET_ETHTOOL_OPS(dev, &au1000_ethtool_ops);
-	dev->tx_timeout = au1000_tx_timeout;
 	dev->watchdog_timeo = ETH_TX_TIMEOUT;
 
 	/*
diff -urN linux-2.6.30-rc2/drivers/net/benet/be_ethtool.c linux-2.6.30-rc3/drivers/net/benet/be_ethtool.c
--- linux-2.6.30-rc2/drivers/net/benet/be_ethtool.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/benet/be_ethtool.c	2009-04-22 03:29:17.031931468 +0000
@@ -319,7 +319,7 @@
 
 	be_cmd_get_flow_control(&adapter->ctrl, &ecmd->tx_pause,
 		&ecmd->rx_pause);
-	ecmd->autoneg = AUTONEG_ENABLE;
+	ecmd->autoneg = 0;
 }
 
 static int
@@ -328,7 +328,7 @@
 	struct be_adapter *adapter = netdev_priv(netdev);
 	int status;
 
-	if (ecmd->autoneg != AUTONEG_ENABLE)
+	if (ecmd->autoneg != 0)
 		return -EINVAL;
 
 	status = be_cmd_set_flow_control(&adapter->ctrl, ecmd->tx_pause,
diff -urN linux-2.6.30-rc2/drivers/net/bfin_mac.c linux-2.6.30-rc3/drivers/net/bfin_mac.c
--- linux-2.6.30-rc2/drivers/net/bfin_mac.c	2009-04-22 03:29:10.990931417 +0000
+++ linux-2.6.30-rc3/drivers/net/bfin_mac.c	2009-04-22 03:29:17.032931451 +0000
@@ -979,6 +979,20 @@
 	return 0;
 }
 
+static const struct net_device_ops bfin_mac_netdev_ops = {
+	.ndo_open		= bfin_mac_open,
+	.ndo_stop		= bfin_mac_close,
+	.ndo_start_xmit		= bfin_mac_hard_start_xmit,
+	.ndo_set_mac_address	= bfin_mac_set_mac_address,
+	.ndo_tx_timeout		= bfin_mac_timeout,
+	.ndo_set_multicast_list	= bfin_mac_set_multicast_list,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= bfin_mac_poll,
+#endif
+};
+
 /*
  *
  * this makes the board clean up everything that it can
@@ -1086,15 +1100,7 @@
 	/* Fill in the fields of the device structure with ethernet values. */
 	ether_setup(ndev);
 
-	ndev->open = bfin_mac_open;
-	ndev->stop = bfin_mac_close;
-	ndev->hard_start_xmit = bfin_mac_hard_start_xmit;
-	ndev->set_mac_address = bfin_mac_set_mac_address;
-	ndev->tx_timeout = bfin_mac_timeout;
-	ndev->set_multicast_list = bfin_mac_set_multicast_list;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	ndev->poll_controller = bfin_mac_poll;
-#endif
+	ndev->netdev_ops = &bfin_mac_netdev_ops;
 	ndev->ethtool_ops = &bfin_mac_ethtool_ops;
 
 	spin_lock_init(&lp->lock);
diff -urN linux-2.6.30-rc2/drivers/net/bonding/bond_alb.c linux-2.6.30-rc3/drivers/net/bonding/bond_alb.c
--- linux-2.6.30-rc2/drivers/net/bonding/bond_alb.c	2009-04-22 03:29:11.045931213 +0000
+++ linux-2.6.30-rc3/drivers/net/bonding/bond_alb.c	2009-04-22 03:29:17.087555905 +0000
@@ -370,8 +370,6 @@
 
 	if (arp->op_code == htons(ARPOP_REPLY)) {
 		/* update rx hash table for this ARP */
-		printk("rar: update orig %s bond_dev %s\n", orig_dev->name,
-		       bond_dev->name);
 		bond = netdev_priv(bond_dev);
 		rlb_update_entry_from_arp(bond, arp);
 		pr_debug("Server received an ARP Reply from client\n");
diff -urN linux-2.6.30-rc2/drivers/net/bonding/bond_main.c linux-2.6.30-rc3/drivers/net/bonding/bond_main.c
--- linux-2.6.30-rc2/drivers/net/bonding/bond_main.c	2009-04-22 03:29:11.046931406 +0000
+++ linux-2.6.30-rc3/drivers/net/bonding/bond_main.c	2009-04-22 03:29:17.087555905 +0000
@@ -2570,7 +2570,7 @@
 
 	for (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {
 		if (!targets[i])
-			continue;
+			break;
 		pr_debug("basa: target %x\n", targets[i]);
 		if (list_empty(&bond->vlan_list)) {
 			pr_debug("basa: empty vlan: arp_send\n");
@@ -2677,7 +2677,6 @@
 	int i;
 	__be32 *targets = bond->params.arp_targets;
 
-	targets = bond->params.arp_targets;
 	for (i = 0; (i < BOND_MAX_ARP_TARGETS) && targets[i]; i++) {
 		pr_debug("bva: sip %pI4 tip %pI4 t[%d] %pI4 bhti(tip) %d\n",
 			&sip, &tip, i, &targets[i], bond_has_this_ip(bond, tip));
@@ -3303,7 +3302,7 @@
 
 		for(i = 0; (i < BOND_MAX_ARP_TARGETS) ;i++) {
 			if (!bond->params.arp_targets[i])
-				continue;
+				break;
 			if (printed)
 				seq_printf(seq, ",");
 			seq_printf(seq, " %pI4", &bond->params.arp_targets[i]);
diff -urN linux-2.6.30-rc2/drivers/net/bonding/bond_sysfs.c linux-2.6.30-rc3/drivers/net/bonding/bond_sysfs.c
--- linux-2.6.30-rc2/drivers/net/bonding/bond_sysfs.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/bonding/bond_sysfs.c	2009-04-22 03:29:17.088931282 +0000
@@ -684,17 +684,15 @@
 			goto out;
 		}
 		/* look for an empty slot to put the target in, and check for dupes */
-		for (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {
+		for (i = 0; (i < BOND_MAX_ARP_TARGETS) && !done; i++) {
 			if (targets[i] == newtarget) { /* duplicate */
 				printk(KERN_ERR DRV_NAME
 				       ": %s: ARP target %pI4 is already present\n",
 				       bond->dev->name, &newtarget);
-				if (done)
-					targets[i] = 0;
 				ret = -EINVAL;
 				goto out;
 			}
-			if (targets[i] == 0 && !done) {
+			if (targets[i] == 0) {
 				printk(KERN_INFO DRV_NAME
 				       ": %s: adding ARP target %pI4.\n",
 				       bond->dev->name, &newtarget);
@@ -720,12 +718,16 @@
 			goto out;
 		}
 
-		for (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {
+		for (i = 0; (i < BOND_MAX_ARP_TARGETS) && !done; i++) {
 			if (targets[i] == newtarget) {
+				int j;
 				printk(KERN_INFO DRV_NAME
 				       ": %s: removing ARP target %pI4.\n",
 				       bond->dev->name, &newtarget);
-				targets[i] = 0;
+				for (j = i; (j < (BOND_MAX_ARP_TARGETS-1)) && targets[j+1]; j++)
+					targets[j] = targets[j+1];
+
+				targets[j] = 0;
 				done = 1;
 			}
 		}
diff -urN linux-2.6.30-rc2/drivers/net/cris/eth_v10.c linux-2.6.30-rc3/drivers/net/cris/eth_v10.c
--- linux-2.6.30-rc2/drivers/net/cris/eth_v10.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/cris/eth_v10.c	2009-04-22 03:29:17.090931405 +0000
@@ -257,6 +257,23 @@
 
 struct transceiver_ops* transceiver = &transceivers[0];
 
+static const struct net_device_ops e100_netdev_ops = {
+	.ndo_open		= e100_open,
+	.ndo_stop		= e100_close,
+	.ndo_start_xmit		= e100_send_packet,
+	.ndo_tx_timeout		= e100_tx_timeout,
+	.ndo_get_stats		= e100_get_stats,
+	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_do_ioctl		= e100_ioctl,
+	.ndo_set_mac_address	= e100_set_mac_address,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_config		= e100_set_config,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= e100_netpoll,
+#endif
+};
+
 #define tx_done(dev) (*R_DMA_CH0_CMD == 0)
 
 /*
@@ -300,19 +317,8 @@
 
 	/* fill in our handlers so the network layer can talk to us in the future */
 
-	dev->open               = e100_open;
-	dev->hard_start_xmit    = e100_send_packet;
-	dev->stop               = e100_close;
-	dev->get_stats          = e100_get_stats;
-	dev->set_multicast_list = set_multicast_list;
-	dev->set_mac_address    = e100_set_mac_address;
 	dev->ethtool_ops	= &e100_ethtool_ops;
-	dev->do_ioctl           = e100_ioctl;
-	dev->set_config		= e100_set_config;
-	dev->tx_timeout         = e100_tx_timeout;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	dev->poll_controller = e100_netpoll;
-#endif
+	dev->netdev_ops		= &e100_netdev_ops;
 
 	spin_lock_init(&np->lock);
 	spin_lock_init(&np->led_lock);
diff -urN linux-2.6.30-rc2/drivers/net/declance.c linux-2.6.30-rc3/drivers/net/declance.c
--- linux-2.6.30-rc2/drivers/net/declance.c	2009-04-22 03:29:11.054931396 +0000
+++ linux-2.6.30-rc3/drivers/net/declance.c	2009-04-22 03:29:17.096931437 +0000
@@ -1010,6 +1010,17 @@
 	lance_set_multicast(dev);
 }
 
+static const struct net_device_ops lance_netdev_ops = {
+	.ndo_open		= lance_open,
+	.ndo_stop		= lance_close,
+	.ndo_start_xmit		= lance_start_xmit,
+	.ndo_tx_timeout		= lance_tx_timeout,
+	.ndo_set_multicast_list	= lance_set_multicast,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __init dec_lance_probe(struct device *bdev, const int type)
 {
 	static unsigned version_printed;
@@ -1223,12 +1234,8 @@
 
 	printk(", addr = %pM, irq = %d\n", dev->dev_addr, dev->irq);
 
-	dev->open = &lance_open;
-	dev->stop = &lance_close;
-	dev->hard_start_xmit = &lance_start_xmit;
-	dev->tx_timeout = &lance_tx_timeout;
+	dev->netdev_ops = &lance_netdev_ops;
 	dev->watchdog_timeo = 5*HZ;
-	dev->set_multicast_list = &lance_set_multicast;
 
 	/* lp->ll is the location of the registers for lance card */
 	lp->ll = ll;
diff -urN linux-2.6.30-rc2/drivers/net/e1000/e1000_main.c linux-2.6.30-rc3/drivers/net/e1000/e1000_main.c
--- linux-2.6.30-rc2/drivers/net/e1000/e1000_main.c	2009-04-22 03:29:11.058931268 +0000
+++ linux-2.6.30-rc3/drivers/net/e1000/e1000_main.c	2009-04-22 03:29:17.101014714 +0000
@@ -156,8 +156,8 @@
 static void e1000_vlan_rx_kill_vid(struct net_device *netdev, u16 vid);
 static void e1000_restore_vlan(struct e1000_adapter *adapter);
 
-static int e1000_suspend(struct pci_dev *pdev, pm_message_t state);
 #ifdef CONFIG_PM
+static int e1000_suspend(struct pci_dev *pdev, pm_message_t state);
 static int e1000_resume(struct pci_dev *pdev);
 #endif
 static void e1000_shutdown(struct pci_dev *pdev);
@@ -3834,7 +3834,7 @@
 	struct e1000_buffer *buffer_info;
 	unsigned int i, eop;
 	unsigned int count = 0;
-	bool cleaned;
+	bool cleaned = false;
 	unsigned int total_tx_bytes=0, total_tx_packets=0;
 
 	i = tx_ring->next_to_clean;
@@ -4601,7 +4601,7 @@
 	return 0;
 }
 
-static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
+static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
 {
 	struct net_device *netdev = pci_get_drvdata(pdev);
 	struct e1000_adapter *adapter = netdev_priv(netdev);
@@ -4664,22 +4664,18 @@
 
 		ew32(WUC, E1000_WUC_PME_EN);
 		ew32(WUFC, wufc);
-		pci_enable_wake(pdev, PCI_D3hot, 1);
-		pci_enable_wake(pdev, PCI_D3cold, 1);
 	} else {
 		ew32(WUC, 0);
 		ew32(WUFC, 0);
-		pci_enable_wake(pdev, PCI_D3hot, 0);
-		pci_enable_wake(pdev, PCI_D3cold, 0);
 	}
 
 	e1000_release_manageability(adapter);
 
+	*enable_wake = !!wufc;
+
 	/* make sure adapter isn't asleep if manageability is enabled */
-	if (adapter->en_mng_pt) {
-		pci_enable_wake(pdev, PCI_D3hot, 1);
-		pci_enable_wake(pdev, PCI_D3cold, 1);
-	}
+	if (adapter->en_mng_pt)
+		*enable_wake = true;
 
 	if (hw->phy_type == e1000_phy_igp_3)
 		e1000_phy_powerdown_workaround(hw);
@@ -4693,12 +4689,29 @@
 
 	pci_disable_device(pdev);
 
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
-
 	return 0;
 }
 
 #ifdef CONFIG_PM
+static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	int retval;
+	bool wake;
+
+	retval = __e1000_shutdown(pdev, &wake);
+	if (retval)
+		return retval;
+
+	if (wake) {
+		pci_prepare_to_sleep(pdev);
+	} else {
+		pci_wake_from_d3(pdev, false);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
+
+	return 0;
+}
+
 static int e1000_resume(struct pci_dev *pdev)
 {
 	struct net_device *netdev = pci_get_drvdata(pdev);
@@ -4753,7 +4766,14 @@
 
 static void e1000_shutdown(struct pci_dev *pdev)
 {
-	e1000_suspend(pdev, PMSG_SUSPEND);
+	bool wake;
+
+	__e1000_shutdown(pdev, &wake);
+
+	if (system_state == SYSTEM_POWER_OFF) {
+		pci_wake_from_d3(pdev, wake);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
diff -urN linux-2.6.30-rc2/drivers/net/e1000e/netdev.c linux-2.6.30-rc3/drivers/net/e1000e/netdev.c
--- linux-2.6.30-rc2/drivers/net/e1000e/netdev.c	2009-04-22 03:29:11.062931200 +0000
+++ linux-2.6.30-rc3/drivers/net/e1000e/netdev.c	2009-04-22 03:29:17.104931511 +0000
@@ -621,7 +621,7 @@
 	struct e1000_buffer *buffer_info;
 	unsigned int i, eop;
 	unsigned int count = 0;
-	bool cleaned;
+	bool cleaned = false;
 	unsigned int total_tx_bytes = 0, total_tx_packets = 0;
 
 	i = tx_ring->next_to_clean;
@@ -4346,7 +4346,7 @@
 	}
 }
 
-static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
+static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
 {
 	struct net_device *netdev = pci_get_drvdata(pdev);
 	struct e1000_adapter *adapter = netdev_priv(netdev);
@@ -4409,20 +4409,16 @@
 
 		ew32(WUC, E1000_WUC_PME_EN);
 		ew32(WUFC, wufc);
-		pci_enable_wake(pdev, PCI_D3hot, 1);
-		pci_enable_wake(pdev, PCI_D3cold, 1);
 	} else {
 		ew32(WUC, 0);
 		ew32(WUFC, 0);
-		pci_enable_wake(pdev, PCI_D3hot, 0);
-		pci_enable_wake(pdev, PCI_D3cold, 0);
 	}
 
+	*enable_wake = !!wufc;
+
 	/* make sure adapter isn't asleep if manageability is enabled */
-	if (adapter->flags & FLAG_MNG_PT_ENABLED) {
-		pci_enable_wake(pdev, PCI_D3hot, 1);
-		pci_enable_wake(pdev, PCI_D3cold, 1);
-	}
+	if (adapter->flags & FLAG_MNG_PT_ENABLED)
+		*enable_wake = true;
 
 	if (adapter->hw.phy.type == e1000_phy_igp_3)
 		e1000e_igp3_phy_powerdown_workaround_ich8lan(&adapter->hw);
@@ -4435,6 +4431,26 @@
 
 	pci_disable_device(pdev);
 
+	return 0;
+}
+
+static void e1000_power_off(struct pci_dev *pdev, bool sleep, bool wake)
+{
+	if (sleep && wake) {
+		pci_prepare_to_sleep(pdev);
+		return;
+	}
+
+	pci_wake_from_d3(pdev, wake);
+	pci_set_power_state(pdev, PCI_D3hot);
+}
+
+static void e1000_complete_shutdown(struct pci_dev *pdev, bool sleep,
+                                    bool wake)
+{
+	struct net_device *netdev = pci_get_drvdata(pdev);
+	struct e1000_adapter *adapter = netdev_priv(netdev);
+
 	/*
 	 * The pci-e switch on some quad port adapters will report a
 	 * correctable error when the MAC transitions from D0 to D3.  To
@@ -4450,14 +4466,12 @@
 		pci_write_config_word(us_dev, pos + PCI_EXP_DEVCTL,
 		                      (devctl & ~PCI_EXP_DEVCTL_CERE));
 
-		pci_set_power_state(pdev, pci_choose_state(pdev, state));
+		e1000_power_off(pdev, sleep, wake);
 
 		pci_write_config_word(us_dev, pos + PCI_EXP_DEVCTL, devctl);
 	} else {
-		pci_set_power_state(pdev, pci_choose_state(pdev, state));
+		e1000_power_off(pdev, sleep, wake);
 	}
-
-	return 0;
 }
 
 static void e1000e_disable_l1aspm(struct pci_dev *pdev)
@@ -4486,6 +4500,18 @@
 }
 
 #ifdef CONFIG_PM
+static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	int retval;
+	bool wake;
+
+	retval = __e1000_shutdown(pdev, &wake);
+	if (!retval)
+		e1000_complete_shutdown(pdev, true, wake);
+
+	return retval;
+}
+
 static int e1000_resume(struct pci_dev *pdev)
 {
 	struct net_device *netdev = pci_get_drvdata(pdev);
@@ -4549,7 +4575,12 @@
 
 static void e1000_shutdown(struct pci_dev *pdev)
 {
-	e1000_suspend(pdev, PMSG_SUSPEND);
+	bool wake = false;
+
+	__e1000_shutdown(pdev, &wake);
+
+	if (system_state == SYSTEM_POWER_OFF)
+		e1000_complete_shutdown(pdev, false, wake);
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
diff -urN linux-2.6.30-rc2/drivers/net/ehea/ehea_main.c linux-2.6.30-rc3/drivers/net/ehea/ehea_main.c
--- linux-2.6.30-rc2/drivers/net/ehea/ehea_main.c	2009-04-22 03:29:11.064931417 +0000
+++ linux-2.6.30-rc3/drivers/net/ehea/ehea_main.c	2009-04-22 03:29:17.106931460 +0000
@@ -3080,7 +3080,8 @@
 	.ndo_change_mtu		= ehea_change_mtu,
 	.ndo_vlan_rx_register	= ehea_vlan_rx_register,
 	.ndo_vlan_rx_add_vid	= ehea_vlan_rx_add_vid,
-	.ndo_vlan_rx_kill_vid	= ehea_vlan_rx_kill_vid
+	.ndo_vlan_rx_kill_vid	= ehea_vlan_rx_kill_vid,
+	.ndo_tx_timeout		= ehea_tx_watchdog,
 };
 
 struct ehea_port *ehea_setup_single_port(struct ehea_adapter *adapter,
@@ -3142,7 +3143,6 @@
 		      | NETIF_F_HIGHDMA | NETIF_F_IP_CSUM | NETIF_F_HW_VLAN_TX
 		      | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER
 		      | NETIF_F_LLTX;
-	dev->tx_timeout = &ehea_tx_watchdog;
 	dev->watchdog_timeo = EHEA_WATCH_DOG_TIMEOUT;
 
 	INIT_WORK(&port->reset_task, ehea_reset_port);
diff -urN linux-2.6.30-rc2/drivers/net/forcedeth.c linux-2.6.30-rc3/drivers/net/forcedeth.c
--- linux-2.6.30-rc2/drivers/net/forcedeth.c	2009-04-22 03:29:11.071931186 +0000
+++ linux-2.6.30-rc3/drivers/net/forcedeth.c	2009-04-22 03:29:17.114931291 +0000
@@ -3745,14 +3745,14 @@
 			mod_timer(&np->nic_poll, jiffies + POLL_WAIT);
 		}
 		spin_unlock_irqrestore(&np->lock, flags);
-		__napi_complete(napi);
+		napi_complete(napi);
 		return rx_work;
 	}
 
 	if (rx_work < budget) {
 		/* re-enable interrupts
 		   (msix not enabled in napi) */
-		__napi_complete(napi);
+		napi_complete(napi);
 
 		writel(np->irqmask, base + NvRegIrqMask);
 	}
diff -urN linux-2.6.30-rc2/drivers/net/fs_enet/fs_enet-main.c linux-2.6.30-rc3/drivers/net/fs_enet/fs_enet-main.c
--- linux-2.6.30-rc2/drivers/net/fs_enet/fs_enet-main.c	2009-04-22 03:29:11.071931186 +0000
+++ linux-2.6.30-rc3/drivers/net/fs_enet/fs_enet-main.c	2009-04-22 03:29:17.114931291 +0000
@@ -1019,6 +1019,22 @@
 #define IS_FEC(match) 0
 #endif
 
+static const struct net_device_ops fs_enet_netdev_ops = {
+	.ndo_open		= fs_enet_open,
+	.ndo_stop		= fs_enet_close,
+	.ndo_get_stats		= fs_enet_get_stats,
+	.ndo_start_xmit		= fs_enet_start_xmit,
+	.ndo_tx_timeout		= fs_timeout,
+	.ndo_set_multicast_list	= fs_set_multicast_list,
+	.ndo_do_ioctl		= fs_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= fs_enet_netpoll,
+#endif
+};
+
 static int __devinit fs_enet_probe(struct of_device *ofdev,
                                    const struct of_device_id *match)
 {
@@ -1093,22 +1109,13 @@
 	fep->tx_ring = fpi->tx_ring;
 	fep->rx_ring = fpi->rx_ring;
 
-	ndev->open = fs_enet_open;
-	ndev->hard_start_xmit = fs_enet_start_xmit;
-	ndev->tx_timeout = fs_timeout;
+	ndev->netdev_ops = &fs_enet_netdev_ops;
 	ndev->watchdog_timeo = 2 * HZ;
-	ndev->stop = fs_enet_close;
-	ndev->get_stats = fs_enet_get_stats;
-	ndev->set_multicast_list = fs_set_multicast_list;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	ndev->poll_controller = fs_enet_netpoll;
-#endif
 	if (fpi->use_napi)
 		netif_napi_add(ndev, &fep->napi, fs_enet_rx_napi,
 		               fpi->napi_weight);
 
 	ndev->ethtool_ops = &fs_ethtool_ops;
-	ndev->do_ioctl = fs_ioctl;
 
 	init_timer(&fep->phy_timer_list);
 
diff -urN linux-2.6.30-rc2/drivers/net/gianfar.c linux-2.6.30-rc3/drivers/net/gianfar.c
--- linux-2.6.30-rc2/drivers/net/gianfar.c	2009-04-22 03:29:11.072931380 +0000
+++ linux-2.6.30-rc3/drivers/net/gianfar.c	2009-04-22 03:29:17.115931422 +0000
@@ -1583,8 +1583,10 @@
 	struct net_device *dev = priv->ndev;
 
 	if (dev->flags & IFF_UP) {
+		netif_stop_queue(dev);
 		stop_gfar(dev);
 		startup_gfar(dev);
+		netif_start_queue(dev);
 	}
 
 	netif_tx_schedule_all(dev);
diff -urN linux-2.6.30-rc2/drivers/net/ibm_newemac/core.c linux-2.6.30-rc3/drivers/net/ibm_newemac/core.c
--- linux-2.6.30-rc2/drivers/net/ibm_newemac/core.c	2009-04-22 03:29:11.079931401 +0000
+++ linux-2.6.30-rc3/drivers/net/ibm_newemac/core.c	2009-04-22 03:29:17.122931458 +0000
@@ -2686,6 +2686,32 @@
 	return 0;
 }
 
+static const struct net_device_ops emac_netdev_ops = {
+	.ndo_open		= emac_open,
+	.ndo_stop		= emac_close,
+	.ndo_get_stats		= emac_stats,
+	.ndo_set_multicast_list	= emac_set_multicast_list,
+	.ndo_do_ioctl		= emac_ioctl,
+	.ndo_tx_timeout		= emac_tx_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_start_xmit		= emac_start_xmit,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
+static const struct net_device_ops emac_gige_netdev_ops = {
+	.ndo_open		= emac_open,
+	.ndo_stop		= emac_close,
+	.ndo_get_stats		= emac_stats,
+	.ndo_set_multicast_list	= emac_set_multicast_list,
+	.ndo_do_ioctl		= emac_ioctl,
+	.ndo_tx_timeout		= emac_tx_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_start_xmit		= emac_start_xmit_sg,
+	.ndo_change_mtu		= emac_change_mtu,
+};
+
 static int __devinit emac_probe(struct of_device *ofdev,
 				const struct of_device_id *match)
 {
@@ -2827,23 +2853,14 @@
 	if (err != 0)
 		goto err_detach_tah;
 
-	/* Fill in the driver function table */
-	ndev->open = &emac_open;
 	if (dev->tah_dev)
 		ndev->features |= NETIF_F_IP_CSUM | NETIF_F_SG;
-	ndev->tx_timeout = &emac_tx_timeout;
 	ndev->watchdog_timeo = 5 * HZ;
-	ndev->stop = &emac_close;
-	ndev->get_stats = &emac_stats;
-	ndev->set_multicast_list = &emac_set_multicast_list;
-	ndev->do_ioctl = &emac_ioctl;
 	if (emac_phy_supports_gige(dev->phy_mode)) {
-		ndev->hard_start_xmit = &emac_start_xmit_sg;
-		ndev->change_mtu = &emac_change_mtu;
+		ndev->netdev_ops = &emac_gige_netdev_ops;
 		dev->commac.ops = &emac_commac_sg_ops;
-	} else {
-		ndev->hard_start_xmit = &emac_start_xmit;
-	}
+	} else
+		ndev->netdev_ops = &emac_netdev_ops;
 	SET_ETHTOOL_OPS(ndev, &emac_ethtool_ops);
 
 	netif_carrier_off(ndev);
diff -urN linux-2.6.30-rc2/drivers/net/igb/e1000_mac.c linux-2.6.30-rc3/drivers/net/igb/e1000_mac.c
--- linux-2.6.30-rc2/drivers/net/igb/e1000_mac.c	2009-04-22 03:29:11.082931427 +0000
+++ linux-2.6.30-rc3/drivers/net/igb/e1000_mac.c	2009-04-22 03:29:17.125589268 +0000
@@ -111,7 +111,7 @@
  *  Writes value at the given offset in the register array which stores
  *  the VLAN filter table.
  **/
-void igb_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)
+static void igb_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)
 {
 	array_wr32(E1000_VFTA, offset, value);
 	wrfl();
diff -urN linux-2.6.30-rc2/drivers/net/igb/e1000_mac.h linux-2.6.30-rc3/drivers/net/igb/e1000_mac.h
--- linux-2.6.30-rc2/drivers/net/igb/e1000_mac.h	2009-04-22 03:29:11.082931427 +0000
+++ linux-2.6.30-rc3/drivers/net/igb/e1000_mac.h	2009-04-22 03:29:17.125589268 +0000
@@ -66,7 +66,6 @@
 s32  igb_check_alt_mac_addr(struct e1000_hw *hw);
 void igb_reset_adaptive(struct e1000_hw *hw);
 void igb_update_adaptive(struct e1000_hw *hw);
-void igb_write_vfta(struct e1000_hw *hw, u32 offset, u32 value);
 
 bool igb_enable_mng_pass_thru(struct e1000_hw *hw);
 
diff -urN linux-2.6.30-rc2/drivers/net/igb/e1000_mbx.c linux-2.6.30-rc3/drivers/net/igb/e1000_mbx.c
--- linux-2.6.30-rc2/drivers/net/igb/e1000_mbx.c	2009-04-22 03:29:11.082931427 +0000
+++ linux-2.6.30-rc3/drivers/net/igb/e1000_mbx.c	2009-04-22 03:29:17.125589268 +0000
@@ -188,7 +188,7 @@
  *  returns SUCCESS if it successfully received a message notification and
  *  copied it into the receive buffer.
  **/
-s32 igb_read_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)
+static s32 igb_read_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)
 {
 	struct e1000_mbx_info *mbx = &hw->mbx;
 	s32 ret_val = -E1000_ERR_MBX;
@@ -214,7 +214,7 @@
  *  returns SUCCESS if it successfully copied message into the buffer and
  *  received an ack to that message within delay * timeout period
  **/
-s32 igb_write_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)
+static s32 igb_write_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)
 {
 	struct e1000_mbx_info *mbx = &hw->mbx;
 	s32 ret_val = 0;
@@ -232,19 +232,6 @@
 	return ret_val;
 }
 
-/**
- *  e1000_init_mbx_ops_generic - Initialize NVM function pointers
- *  @hw: pointer to the HW structure
- *
- *  Setups up the function pointers to no-op functions
- **/
-void e1000_init_mbx_ops_generic(struct e1000_hw *hw)
-{
-	struct e1000_mbx_info *mbx = &hw->mbx;
-	mbx->ops.read_posted = igb_read_posted_mbx;
-	mbx->ops.write_posted = igb_write_posted_mbx;
-}
-
 static s32 igb_check_for_bit_pf(struct e1000_hw *hw, u32 mask)
 {
 	u32 mbvficr = rd32(E1000_MBVFICR);
diff -urN linux-2.6.30-rc2/drivers/net/igb/e1000_mbx.h linux-2.6.30-rc3/drivers/net/igb/e1000_mbx.h
--- linux-2.6.30-rc2/drivers/net/igb/e1000_mbx.h	2009-04-22 03:29:11.082931427 +0000
+++ linux-2.6.30-rc3/drivers/net/igb/e1000_mbx.h	2009-04-22 03:29:17.125589268 +0000
@@ -67,8 +67,6 @@
 
 s32 igb_read_mbx(struct e1000_hw *, u32 *, u16, u16);
 s32 igb_write_mbx(struct e1000_hw *, u32 *, u16, u16);
-s32 igb_read_posted_mbx(struct e1000_hw *, u32 *, u16, u16);
-s32 igb_write_posted_mbx(struct e1000_hw *, u32 *, u16, u16);
 s32 igb_check_for_msg(struct e1000_hw *, u16);
 s32 igb_check_for_ack(struct e1000_hw *, u16);
 s32 igb_check_for_rst(struct e1000_hw *, u16);
diff -urN linux-2.6.30-rc2/drivers/net/igb/igb_main.c linux-2.6.30-rc3/drivers/net/igb/igb_main.c
--- linux-2.6.30-rc2/drivers/net/igb/igb_main.c	2009-04-22 03:29:11.087555976 +0000
+++ linux-2.6.30-rc3/drivers/net/igb/igb_main.c	2009-04-22 03:29:17.130931559 +0000
@@ -1261,25 +1261,32 @@
 		int i;
 		unsigned char mac_addr[ETH_ALEN];
 
-		if (num_vfs)
+		if (num_vfs) {
 			adapter->vf_data = kcalloc(num_vfs,
 						sizeof(struct vf_data_storage),
 						GFP_KERNEL);
-		if (!adapter->vf_data) {
-			dev_err(&pdev->dev, "Could not allocate VF private "
-				"data - IOV enable failed\n");
-		} else {
-			err = pci_enable_sriov(pdev, num_vfs);
-			if (!err) {
-				adapter->vfs_allocated_count = num_vfs;
-				dev_info(&pdev->dev, "%d vfs allocated\n", num_vfs);
-				for (i = 0; i < adapter->vfs_allocated_count; i++) {
-					random_ether_addr(mac_addr);
-					igb_set_vf_mac(adapter, i, mac_addr);
-				}
+			if (!adapter->vf_data) {
+				dev_err(&pdev->dev,
+				        "Could not allocate VF private data - "
+					"IOV enable failed\n");
 			} else {
-				kfree(adapter->vf_data);
-				adapter->vf_data = NULL;
+				err = pci_enable_sriov(pdev, num_vfs);
+				if (!err) {
+					adapter->vfs_allocated_count = num_vfs;
+					dev_info(&pdev->dev,
+					         "%d vfs allocated\n",
+					         num_vfs);
+					for (i = 0;
+					     i < adapter->vfs_allocated_count;
+					     i++) {
+						random_ether_addr(mac_addr);
+						igb_set_vf_mac(adapter, i,
+						               mac_addr);
+					}
+				} else {
+					kfree(adapter->vf_data);
+					adapter->vf_data = NULL;
+				}
 			}
 		}
 	}
diff -urN linux-2.6.30-rc2/drivers/net/igbvf/igbvf.h linux-2.6.30-rc3/drivers/net/igbvf/igbvf.h
--- linux-2.6.30-rc2/drivers/net/igbvf/igbvf.h	2009-04-22 03:29:11.088931305 +0000
+++ linux-2.6.30-rc3/drivers/net/igbvf/igbvf.h	2009-04-22 03:29:17.131931261 +0000
@@ -321,14 +321,11 @@
 extern int igbvf_up(struct igbvf_adapter *);
 extern void igbvf_down(struct igbvf_adapter *);
 extern void igbvf_reinit_locked(struct igbvf_adapter *);
-extern void igbvf_reset(struct igbvf_adapter *);
 extern int igbvf_setup_rx_resources(struct igbvf_adapter *, struct igbvf_ring *);
 extern int igbvf_setup_tx_resources(struct igbvf_adapter *, struct igbvf_ring *);
 extern void igbvf_free_rx_resources(struct igbvf_ring *);
 extern void igbvf_free_tx_resources(struct igbvf_ring *);
 extern void igbvf_update_stats(struct igbvf_adapter *);
-extern void igbvf_set_interrupt_capability(struct igbvf_adapter *);
-extern void igbvf_reset_interrupt_capability(struct igbvf_adapter *);
 
 extern unsigned int copybreak;
 
diff -urN linux-2.6.30-rc2/drivers/net/igbvf/netdev.c linux-2.6.30-rc3/drivers/net/igbvf/netdev.c
--- linux-2.6.30-rc2/drivers/net/igbvf/netdev.c	2009-04-22 03:29:11.090931459 +0000
+++ linux-2.6.30-rc3/drivers/net/igbvf/netdev.c	2009-04-22 03:29:17.133931195 +0000
@@ -52,6 +52,9 @@
 static const char igbvf_copyright[] = "Copyright (c) 2009 Intel Corporation.";
 
 static int igbvf_poll(struct napi_struct *napi, int budget);
+static void igbvf_reset(struct igbvf_adapter *);
+static void igbvf_set_interrupt_capability(struct igbvf_adapter *);
+static void igbvf_reset_interrupt_capability(struct igbvf_adapter *);
 
 static struct igbvf_info igbvf_vf_info = {
 	.mac                    = e1000_vfadapt,
@@ -990,7 +993,7 @@
 	e1e_flush();
 }
 
-void igbvf_reset_interrupt_capability(struct igbvf_adapter *adapter)
+static void igbvf_reset_interrupt_capability(struct igbvf_adapter *adapter)
 {
 	if (adapter->msix_entries) {
 		pci_disable_msix(adapter->pdev);
@@ -1005,7 +1008,7 @@
  * Attempt to configure interrupts using the best available
  * capabilities of the hardware and kernel.
  **/
-void igbvf_set_interrupt_capability(struct igbvf_adapter *adapter)
+static void igbvf_set_interrupt_capability(struct igbvf_adapter *adapter)
 {
 	int err = -ENOMEM;
 	int i;
@@ -1447,7 +1450,7 @@
  * set/changed during runtime. After reset the device needs to be
  * properly configured for Rx, Tx etc.
  */
-void igbvf_reset(struct igbvf_adapter *adapter)
+static void igbvf_reset(struct igbvf_adapter *adapter)
 {
 	struct e1000_mac_info *mac = &adapter->hw.mac;
 	struct net_device *netdev = adapter->netdev;
diff -urN linux-2.6.30-rc2/drivers/net/igbvf/vf.c linux-2.6.30-rc3/drivers/net/igbvf/vf.c
--- linux-2.6.30-rc2/drivers/net/igbvf/vf.c	2009-04-22 03:29:11.090931459 +0000
+++ linux-2.6.30-rc3/drivers/net/igbvf/vf.c	2009-04-22 03:29:17.133931195 +0000
@@ -44,7 +44,7 @@
  *  e1000_init_mac_params_vf - Inits MAC params
  *  @hw: pointer to the HW structure
  **/
-s32 e1000_init_mac_params_vf(struct e1000_hw *hw)
+static s32 e1000_init_mac_params_vf(struct e1000_hw *hw)
 {
 	struct e1000_mac_info *mac = &hw->mac;
 
diff -urN linux-2.6.30-rc2/drivers/net/igbvf/vf.h linux-2.6.30-rc3/drivers/net/igbvf/vf.h
--- linux-2.6.30-rc2/drivers/net/igbvf/vf.h	2009-04-22 03:29:11.091931404 +0000
+++ linux-2.6.30-rc3/drivers/net/igbvf/vf.h	2009-04-22 03:29:17.133931195 +0000
@@ -259,7 +259,6 @@
 /* These functions must be implemented by drivers */
 void e1000_rlpml_set_vf(struct e1000_hw *, u16);
 void e1000_init_function_pointers_vf(struct e1000_hw *hw);
-s32  e1000_init_mac_params_vf(struct e1000_hw *hw);
 
 
 #endif /* _E1000_VF_H_ */
diff -urN linux-2.6.30-rc2/drivers/net/ioc3-eth.c linux-2.6.30-rc3/drivers/net/ioc3-eth.c
--- linux-2.6.30-rc2/drivers/net/ioc3-eth.c	2009-04-22 03:29:11.091931404 +0000
+++ linux-2.6.30-rc3/drivers/net/ioc3-eth.c	2009-04-22 03:29:17.134931431 +0000
@@ -1214,6 +1214,19 @@
 }
 #endif
 
+static const struct net_device_ops ioc3_netdev_ops = {
+	.ndo_open		= ioc3_open,
+	.ndo_stop		= ioc3_close,
+	.ndo_start_xmit		= ioc3_start_xmit,
+	.ndo_tx_timeout		= ioc3_timeout,
+	.ndo_get_stats		= ioc3_get_stats,
+	.ndo_set_multicast_list	= ioc3_set_multicast_list,
+	.ndo_do_ioctl		= ioc3_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= ioc3_set_mac_address,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 static int __devinit ioc3_probe(struct pci_dev *pdev,
 	const struct pci_device_id *ent)
 {
@@ -1310,15 +1323,8 @@
 	ioc3_get_eaddr(ip);
 
 	/* The IOC3-specific entries in the device structure. */
-	dev->open		= ioc3_open;
-	dev->hard_start_xmit	= ioc3_start_xmit;
-	dev->tx_timeout		= ioc3_timeout;
 	dev->watchdog_timeo	= 5 * HZ;
-	dev->stop		= ioc3_close;
-	dev->get_stats		= ioc3_get_stats;
-	dev->do_ioctl		= ioc3_ioctl;
-	dev->set_multicast_list	= ioc3_set_multicast_list;
-	dev->set_mac_address	= ioc3_set_mac_address;
+	dev->netdev_ops		= &ioc3_netdev_ops;
 	dev->ethtool_ops	= &ioc3_ethtool_ops;
 	dev->features		= NETIF_F_IP_CSUM;
 
diff -urN linux-2.6.30-rc2/drivers/net/isa-skeleton.c linux-2.6.30-rc3/drivers/net/isa-skeleton.c
--- linux-2.6.30-rc2/drivers/net/isa-skeleton.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/isa-skeleton.c	2009-04-22 03:29:17.139555926 +0000
@@ -181,6 +181,18 @@
 }
 #endif
 
+static const struct net_device_ops netcard_netdev_ops = {
+	.ndo_open		= net_open,
+	.ndo_stop		= net_close,
+	.ndo_start_xmit		= net_send_packet,
+	.ndo_get_stats		= net_get_stats,
+	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_tx_timeout		= net_tx_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 /*
  * This is the real probe routine. Linux has a history of friendly device
  * probes on the ISA bus. A good device probes avoids doing writes, and
@@ -303,13 +315,7 @@
 	np = netdev_priv(dev);
 	spin_lock_init(&np->lock);
 
-	dev->open		= net_open;
-	dev->stop		= net_close;
-	dev->hard_start_xmit	= net_send_packet;
-	dev->get_stats		= net_get_stats;
-	dev->set_multicast_list = &set_multicast_list;
-
-        dev->tx_timeout		= &net_tx_timeout;
+        dev->netdev_ops		= &netcard_netdev_ops;
         dev->watchdog_timeo	= MY_TX_TIMEOUT;
 
 	err = register_netdev(dev);
diff -urN linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_82598.c linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_82598.c
--- linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_82598.c	2009-04-22 03:29:11.098931392 +0000
+++ linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_82598.c	2009-04-22 03:29:17.141931404 +0000
@@ -885,61 +885,6 @@
 }
 
 /**
- *  ixgbe_blink_led_start_82598 - Blink LED based on index.
- *  @hw: pointer to hardware structure
- *  @index: led number to blink
- **/
-static s32 ixgbe_blink_led_start_82598(struct ixgbe_hw *hw, u32 index)
-{
-	ixgbe_link_speed speed = 0;
-	bool link_up = 0;
-	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
-	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
-
-	/*
-	 * Link must be up to auto-blink the LEDs on the 82598EB MAC;
-	 * force it if link is down.
-	 */
-	hw->mac.ops.check_link(hw, &speed, &link_up, false);
-
-	if (!link_up) {
-		autoc_reg |= IXGBE_AUTOC_FLU;
-		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
-		msleep(10);
-	}
-
-	led_reg &= ~IXGBE_LED_MODE_MASK(index);
-	led_reg |= IXGBE_LED_BLINK(index);
-	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
-	IXGBE_WRITE_FLUSH(hw);
-
-	return 0;
-}
-
-/**
- *  ixgbe_blink_led_stop_82598 - Stop blinking LED based on index.
- *  @hw: pointer to hardware structure
- *  @index: led number to stop blinking
- **/
-static s32 ixgbe_blink_led_stop_82598(struct ixgbe_hw *hw, u32 index)
-{
-	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
-	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
-
-	autoc_reg &= ~IXGBE_AUTOC_FLU;
-	autoc_reg |= IXGBE_AUTOC_AN_RESTART;
-	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
-
-	led_reg &= ~IXGBE_LED_MODE_MASK(index);
-	led_reg &= ~IXGBE_LED_BLINK(index);
-	led_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);
-	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
-	IXGBE_WRITE_FLUSH(hw);
-
-	return 0;
-}
-
-/**
  *  ixgbe_read_analog_reg8_82598 - Reads 8 bit Atlas analog register
  *  @hw: pointer to hardware structure
  *  @reg: analog register to read
@@ -1128,8 +1073,8 @@
 	.get_link_capabilities	= &ixgbe_get_link_capabilities_82598,
 	.led_on			= &ixgbe_led_on_generic,
 	.led_off		= &ixgbe_led_off_generic,
-	.blink_led_start	= &ixgbe_blink_led_start_82598,
-	.blink_led_stop		= &ixgbe_blink_led_stop_82598,
+	.blink_led_start	= &ixgbe_blink_led_start_generic,
+	.blink_led_stop		= &ixgbe_blink_led_stop_generic,
 	.set_rar		= &ixgbe_set_rar_generic,
 	.clear_rar		= &ixgbe_clear_rar_generic,
 	.set_vmdq		= &ixgbe_set_vmdq_82598,
diff -urN linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_82599.c linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_82599.c
--- linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_82599.c	2009-04-22 03:29:11.099931205 +0000
+++ linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_82599.c	2009-04-22 03:29:17.141931404 +0000
@@ -68,8 +68,6 @@
 s32 ixgbe_set_vfta_82599(struct ixgbe_hw *hw, u32 vlan,
                          u32 vind, bool vlan_on);
 s32 ixgbe_clear_vfta_82599(struct ixgbe_hw *hw);
-s32 ixgbe_blink_led_stop_82599(struct ixgbe_hw *hw, u32 index);
-s32 ixgbe_blink_led_start_82599(struct ixgbe_hw *hw, u32 index);
 s32 ixgbe_init_uta_tables_82599(struct ixgbe_hw *hw);
 s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val);
 s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val);
@@ -991,40 +989,6 @@
 }
 
 /**
- *  ixgbe_blink_led_start_82599 - Blink LED based on index.
- *  @hw: pointer to hardware structure
- *  @index: led number to blink
- **/
-s32 ixgbe_blink_led_start_82599(struct ixgbe_hw *hw, u32 index)
-{
-	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
-
-	led_reg &= ~IXGBE_LED_MODE_MASK(index);
-	led_reg |= IXGBE_LED_BLINK(index);
-	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
-	IXGBE_WRITE_FLUSH(hw);
-
-	return 0;
-}
-
-/**
- *  ixgbe_blink_led_stop_82599 - Stop blinking LED based on index.
- *  @hw: pointer to hardware structure
- *  @index: led number to stop blinking
- **/
-s32 ixgbe_blink_led_stop_82599(struct ixgbe_hw *hw, u32 index)
-{
-	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
-
-	led_reg &= ~IXGBE_LED_MODE_MASK(index);
-	led_reg &= ~IXGBE_LED_BLINK(index);
-	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
-	IXGBE_WRITE_FLUSH(hw);
-
-	return 0;
-}
-
-/**
  *  ixgbe_init_uta_tables_82599 - Initialize the Unicast Table Array
  *  @hw: pointer to hardware structure
  **/
@@ -1243,8 +1207,8 @@
 	.get_link_capabilities  = &ixgbe_get_link_capabilities_82599,
 	.led_on                 = &ixgbe_led_on_generic,
 	.led_off                = &ixgbe_led_off_generic,
-	.blink_led_start        = &ixgbe_blink_led_start_82599,
-	.blink_led_stop         = &ixgbe_blink_led_stop_82599,
+	.blink_led_start        = &ixgbe_blink_led_start_generic,
+	.blink_led_stop         = &ixgbe_blink_led_stop_generic,
 	.set_rar                = &ixgbe_set_rar_generic,
 	.clear_rar              = &ixgbe_clear_rar_generic,
 	.set_vmdq               = &ixgbe_set_vmdq_82599,
diff -urN linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_common.c linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_common.c
--- linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_common.c	2009-04-22 03:29:11.099931205 +0000
+++ linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_common.c	2009-04-22 03:29:17.142931394 +0000
@@ -2071,3 +2071,58 @@
 
 	return 0;
 }
+
+/**
+ *  ixgbe_blink_led_start_generic - Blink LED based on index.
+ *  @hw: pointer to hardware structure
+ *  @index: led number to blink
+ **/
+s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)
+{
+	ixgbe_link_speed speed = 0;
+	bool link_up = 0;
+	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
+
+	/*
+	 * Link must be up to auto-blink the LEDs;
+	 * Force it if link is down.
+	 */
+	hw->mac.ops.check_link(hw, &speed, &link_up, false);
+
+	if (!link_up) {
+		autoc_reg |= IXGBE_AUTOC_FLU;
+		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
+		msleep(10);
+	}
+
+	led_reg &= ~IXGBE_LED_MODE_MASK(index);
+	led_reg |= IXGBE_LED_BLINK(index);
+	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
+	IXGBE_WRITE_FLUSH(hw);
+
+	return 0;
+}
+
+/**
+ *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.
+ *  @hw: pointer to hardware structure
+ *  @index: led number to stop blinking
+ **/
+s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index)
+{
+	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
+
+	autoc_reg &= ~IXGBE_AUTOC_FLU;
+	autoc_reg |= IXGBE_AUTOC_AN_RESTART;
+	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
+
+	led_reg &= ~IXGBE_LED_MODE_MASK(index);
+	led_reg &= ~IXGBE_LED_BLINK(index);
+	led_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);
+	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
+	IXGBE_WRITE_FLUSH(hw);
+
+	return 0;
+}
diff -urN linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_common.h linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_common.h
--- linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_common.h	2009-04-22 03:29:11.100931443 +0000
+++ linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_common.h	2009-04-22 03:29:17.142931394 +0000
@@ -76,6 +76,9 @@
 s32 ixgbe_read_analog_reg8_generic(struct ixgbe_hw *hw, u32 reg, u8 *val);
 s32 ixgbe_write_analog_reg8_generic(struct ixgbe_hw *hw, u32 reg, u8 val);
 
+s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index);
+
 #define IXGBE_WRITE_REG(a, reg, value) writel((value), ((a)->hw_addr + (reg)))
 
 #ifndef writeq
diff -urN linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_ethtool.c linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_ethtool.c
--- linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_ethtool.c	2009-04-22 03:29:11.101931595 +0000
+++ linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_ethtool.c	2009-04-22 03:29:17.144931427 +0000
@@ -943,6 +943,24 @@
 }
 
 
+static int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter,
+                               struct ethtool_wolinfo *wol)
+{
+	struct ixgbe_hw *hw = &adapter->hw;
+	int retval = 1;
+
+	switch(hw->device_id) {
+	case IXGBE_DEV_ID_82599_KX4:
+		retval = 0;
+		break;
+	default:
+		wol->supported = 0;
+		retval = 0;
+	}
+
+	return retval;
+}
+
 static void ixgbe_get_wol(struct net_device *netdev,
                           struct ethtool_wolinfo *wol)
 {
@@ -952,7 +970,8 @@
 	                 WAKE_BCAST | WAKE_MAGIC;
 	wol->wolopts = 0;
 
-	if (!device_can_wakeup(&adapter->pdev->dev))
+	if (ixgbe_wol_exclusion(adapter, wol) ||
+	    !device_can_wakeup(&adapter->pdev->dev))
 		return;
 
 	if (adapter->wol & IXGBE_WUFC_EX)
@@ -974,6 +993,9 @@
 	if (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
 		return -EOPNOTSUPP;
 
+	if (ixgbe_wol_exclusion(adapter, wol))
+		return wol->wolopts ? -EOPNOTSUPP : 0;
+
 	adapter->wol = 0;
 
 	if (wol->wolopts & WAKE_UCAST)
diff -urN linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_main.c linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_main.c
--- linux-2.6.30-rc2/drivers/net/ixgbe/ixgbe_main.c	2009-04-22 03:29:11.104931234 +0000
+++ linux-2.6.30-rc3/drivers/net/ixgbe/ixgbe_main.c	2009-04-22 03:29:17.146931239 +0000
@@ -2723,17 +2723,21 @@
  **/
 static void ixgbe_set_num_queues(struct ixgbe_adapter *adapter)
 {
-	/* Start with base case */
-	adapter->num_rx_queues = 1;
-	adapter->num_tx_queues = 1;
-
 #ifdef CONFIG_IXGBE_DCB
 	if (ixgbe_set_dcb_queues(adapter))
-		return;
+		goto done;
 
 #endif
 	if (ixgbe_set_rss_queues(adapter))
-		return;
+		goto done;
+
+	/* fallback to base case */
+	adapter->num_rx_queues = 1;
+	adapter->num_tx_queues = 1;
+
+done:
+	/* Notify the stack of the (possibly) reduced Tx Queue count. */
+	adapter->netdev->real_num_tx_queues = adapter->num_tx_queues;
 }
 
 static void ixgbe_acquire_msix_vectors(struct ixgbe_adapter *adapter,
@@ -2992,9 +2996,6 @@
 	}
 
 out:
-	/* Notify the stack of the (possibly) reduced Tx Queue count. */
-	adapter->netdev->real_num_tx_queues = adapter->num_tx_queues;
-
 	return err;
 }
 
@@ -3611,9 +3612,9 @@
 
 	return 0;
 }
-
 #endif /* CONFIG_PM */
-static int ixgbe_suspend(struct pci_dev *pdev, pm_message_t state)
+
+static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
 {
 	struct net_device *netdev = pci_get_drvdata(pdev);
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
@@ -3672,18 +3673,46 @@
 		pci_enable_wake(pdev, PCI_D3cold, 0);
 	}
 
+	*enable_wake = !!wufc;
+
 	ixgbe_release_hw_control(adapter);
 
 	pci_disable_device(pdev);
 
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ixgbe_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	int retval;
+	bool wake;
+
+	retval = __ixgbe_shutdown(pdev, &wake);
+	if (retval)
+		return retval;
+
+	if (wake) {
+		pci_prepare_to_sleep(pdev);
+	} else {
+		pci_wake_from_d3(pdev, false);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
 
 	return 0;
 }
+#endif /* CONFIG_PM */
 
 static void ixgbe_shutdown(struct pci_dev *pdev)
 {
-	ixgbe_suspend(pdev, PMSG_SUSPEND);
+	bool wake;
+
+	__ixgbe_shutdown(pdev, &wake);
+
+	if (system_state == SYSTEM_POWER_OFF) {
+		pci_wake_from_d3(pdev, wake);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
 }
 
 /**
@@ -4342,7 +4371,7 @@
 	int count = 0;
 	unsigned int f;
 
-	r_idx = (adapter->num_tx_queues - 1) & skb->queue_mapping;
+	r_idx = skb->queue_mapping;
 	tx_ring = &adapter->tx_ring[r_idx];
 
 	if (adapter->vlgrp && vlan_tx_tag_present(skb)) {
diff -urN linux-2.6.30-rc2/drivers/net/mac89x0.c linux-2.6.30-rc3/drivers/net/mac89x0.c
--- linux-2.6.30-rc2/drivers/net/mac89x0.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/mac89x0.c	2009-04-22 03:29:17.151931434 +0000
@@ -168,6 +168,17 @@
 	nubus_writew(swab16(value), dev->mem_start + portno);
 }
 
+static const struct net_device_ops mac89x0_netdev_ops = {
+	.ndo_open		= net_open,
+	.ndo_stop		= net_close,
+	.ndo_start_xmit		= net_send_packet,
+	.ndo_get_stats		= net_get_stats,
+	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_set_mac_address	= set_mac_address,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 /* Probe for the CS8900 card in slot E.  We won't bother looking
    anywhere else until we have a really good reason to do so. */
 struct net_device * __init mac89x0_probe(int unit)
@@ -280,12 +291,7 @@
 
 	printk(" IRQ %d ADDR %pM\n", dev->irq, dev->dev_addr);
 
-	dev->open		= net_open;
-	dev->stop		= net_close;
-	dev->hard_start_xmit = net_send_packet;
-	dev->get_stats	= net_get_stats;
-	dev->set_multicast_list = &set_multicast_list;
-	dev->set_mac_address = &set_mac_address;
+	dev->netdev_ops		= &mac89x0_netdev_ops;
 
 	err = register_netdev(dev);
 	if (err)
diff -urN linux-2.6.30-rc2/drivers/net/macb.c linux-2.6.30-rc3/drivers/net/macb.c
--- linux-2.6.30-rc2/drivers/net/macb.c	2009-04-22 03:29:11.108931439 +0000
+++ linux-2.6.30-rc3/drivers/net/macb.c	2009-04-22 03:29:17.151931434 +0000
@@ -1100,6 +1100,18 @@
 	return phy_mii_ioctl(phydev, if_mii(rq), cmd);
 }
 
+static const struct net_device_ops macb_netdev_ops = {
+	.ndo_open		= macb_open,
+	.ndo_stop		= macb_close,
+	.ndo_start_xmit		= macb_start_xmit,
+	.ndo_set_multicast_list	= macb_set_rx_mode,
+	.ndo_get_stats		= macb_get_stats,
+	.ndo_do_ioctl		= macb_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __init macb_probe(struct platform_device *pdev)
 {
 	struct eth_platform_data *pdata;
@@ -1175,12 +1187,7 @@
 		goto err_out_iounmap;
 	}
 
-	dev->open = macb_open;
-	dev->stop = macb_close;
-	dev->hard_start_xmit = macb_start_xmit;
-	dev->get_stats = macb_get_stats;
-	dev->set_multicast_list = macb_set_rx_mode;
-	dev->do_ioctl = macb_ioctl;
+	dev->netdev_ops = &macb_netdev_ops;
 	netif_napi_add(dev, &bp->napi, macb_poll, 64);
 	dev->ethtool_ops = &macb_ethtool_ops;
 
diff -urN linux-2.6.30-rc2/drivers/net/macsonic.c linux-2.6.30-rc3/drivers/net/macsonic.c
--- linux-2.6.30-rc2/drivers/net/macsonic.c	2009-04-22 03:29:11.108931439 +0000
+++ linux-2.6.30-rc3/drivers/net/macsonic.c	2009-04-22 03:29:17.151931434 +0000
@@ -167,6 +167,18 @@
 	return err;
 }
 
+static const struct net_device_ops macsonic_netdev_ops = {
+	.ndo_open		= macsonic_open,
+	.ndo_stop		= macsonic_close,
+	.ndo_start_xmit		= sonic_send_packet,
+	.ndo_set_multicast_list	= sonic_multicast_list,
+	.ndo_tx_timeout		= sonic_tx_timeout,
+	.ndo_get_stats		= sonic_get_stats,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __init macsonic_init(struct net_device *dev)
 {
 	struct sonic_local* lp = netdev_priv(dev);
@@ -198,12 +210,7 @@
 	lp->rra_laddr = lp->rda_laddr + (SIZEOF_SONIC_RD * SONIC_NUM_RDS
 	                     * SONIC_BUS_SCALE(lp->dma_bitmode));
 
-	dev->open = macsonic_open;
-	dev->stop = macsonic_close;
-	dev->hard_start_xmit = sonic_send_packet;
-	dev->get_stats = sonic_get_stats;
-	dev->set_multicast_list = &sonic_multicast_list;
-	dev->tx_timeout = sonic_tx_timeout;
+	dev->netdev_ops = &macsonic_netdev_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
 	/*
diff -urN linux-2.6.30-rc2/drivers/net/myri10ge/myri10ge.c linux-2.6.30-rc3/drivers/net/myri10ge/myri10ge.c
--- linux-2.6.30-rc2/drivers/net/myri10ge/myri10ge.c	2009-04-22 03:29:11.112931407 +0000
+++ linux-2.6.30-rc3/drivers/net/myri10ge/myri10ge.c	2009-04-22 03:29:17.155931438 +0000
@@ -2447,6 +2447,7 @@
 		lro_mgr->lro_arr = ss->rx_done.lro_desc;
 		lro_mgr->get_frag_header = myri10ge_get_frag_header;
 		lro_mgr->max_aggr = myri10ge_lro_max_pkts;
+		lro_mgr->frag_align_pad = 2;
 		if (lro_mgr->max_aggr > MAX_SKB_FRAGS)
 			lro_mgr->max_aggr = MAX_SKB_FRAGS;
 
diff -urN linux-2.6.30-rc2/drivers/net/phy/fixed.c linux-2.6.30-rc3/drivers/net/phy/fixed.c
--- linux-2.6.30-rc2/drivers/net/phy/fixed.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/phy/fixed.c	2009-04-22 03:29:17.178931220 +0000
@@ -19,6 +19,7 @@
 #include <linux/mii.h>
 #include <linux/phy.h>
 #include <linux/phy_fixed.h>
+#include <linux/err.h>
 
 #define MII_REGS_NUM 29
 
@@ -207,8 +208,8 @@
 	int ret;
 
 	pdev = platform_device_register_simple("Fixed MDIO bus", 0, NULL, 0);
-	if (!pdev) {
-		ret = -ENOMEM;
+	if (IS_ERR(pdev)) {
+		ret = PTR_ERR(pdev);
 		goto err_pdev;
 	}
 
diff -urN linux-2.6.30-rc2/drivers/net/phy/marvell.c linux-2.6.30-rc3/drivers/net/phy/marvell.c
--- linux-2.6.30-rc2/drivers/net/phy/marvell.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/phy/marvell.c	2009-04-22 03:29:17.179931392 +0000
@@ -69,6 +69,11 @@
 #define MII_M1111_COPPER		0
 #define MII_M1111_FIBER			1
 
+#define MII_88E1121_PHY_LED_CTRL	16
+#define MII_88E1121_PHY_LED_PAGE	3
+#define MII_88E1121_PHY_LED_DEF		0x0030
+#define MII_88E1121_PHY_PAGE		22
+
 #define MII_M1011_PHY_STATUS		0x11
 #define MII_M1011_PHY_STATUS_1000	0x8000
 #define MII_M1011_PHY_STATUS_100	0x4000
@@ -154,6 +159,30 @@
 	return err;
 }
 
+static int m88e1121_config_aneg(struct phy_device *phydev)
+{
+	int err, temp;
+
+	err = phy_write(phydev, MII_BMCR, BMCR_RESET);
+	if (err < 0)
+		return err;
+
+	err = phy_write(phydev, MII_M1011_PHY_SCR,
+			MII_M1011_PHY_SCR_AUTO_CROSS);
+	if (err < 0)
+		return err;
+
+	temp = phy_read(phydev, MII_88E1121_PHY_PAGE);
+
+	phy_write(phydev, MII_88E1121_PHY_PAGE, MII_88E1121_PHY_LED_PAGE);
+	phy_write(phydev, MII_88E1121_PHY_LED_CTRL, MII_88E1121_PHY_LED_DEF);
+	phy_write(phydev, MII_88E1121_PHY_PAGE, temp);
+
+	err = genphy_config_aneg(phydev);
+
+	return err;
+}
+
 static int m88e1111_config_init(struct phy_device *phydev)
 {
 	int err;
@@ -429,6 +458,18 @@
 	return 0;
 }
 
+static int m88e1121_did_interrupt(struct phy_device *phydev)
+{
+	int imask;
+
+	imask = phy_read(phydev, MII_M1011_IEVENT);
+
+	if (imask & MII_M1011_IMASK_INIT)
+		return 1;
+
+	return 0;
+}
+
 static struct phy_driver marvell_drivers[] = {
 	{
 		.phy_id = 0x01410c60,
@@ -482,6 +523,19 @@
 		.driver = {.owner = THIS_MODULE,},
 	},
 	{
+		.phy_id = 0x01410cb0,
+		.phy_id_mask = 0xfffffff0,
+		.name = "Marvell 88E1121R",
+		.features = PHY_GBIT_FEATURES,
+		.flags = PHY_HAS_INTERRUPT,
+		.config_aneg = &m88e1121_config_aneg,
+		.read_status = &marvell_read_status,
+		.ack_interrupt = &marvell_ack_interrupt,
+		.config_intr = &marvell_config_intr,
+		.did_interrupt = &m88e1121_did_interrupt,
+		.driver = { .owner = THIS_MODULE },
+	},
+	{
 		.phy_id = 0x01410cd0,
 		.phy_id_mask = 0xfffffff0,
 		.name = "Marvell 88E1145",
diff -urN linux-2.6.30-rc2/drivers/net/phy/phy.c linux-2.6.30-rc3/drivers/net/phy/phy.c
--- linux-2.6.30-rc2/drivers/net/phy/phy.c	2009-04-22 03:29:11.136931260 +0000
+++ linux-2.6.30-rc3/drivers/net/phy/phy.c	2009-04-22 03:29:17.179931392 +0000
@@ -434,7 +434,7 @@
 	phydev->adjust_state = handler;
 
 	INIT_DELAYED_WORK(&phydev->state_queue, phy_state_machine);
-	schedule_delayed_work(&phydev->state_queue, jiffies + HZ);
+	schedule_delayed_work(&phydev->state_queue, HZ);
 }
 
 /**
@@ -655,6 +655,10 @@
 	struct phy_device *phydev =
 		container_of(work, struct phy_device, phy_queue);
 
+	if (phydev->drv->did_interrupt &&
+	    !phydev->drv->did_interrupt(phydev))
+		goto ignore;
+
 	err = phy_disable_interrupts(phydev);
 
 	if (err)
@@ -681,6 +685,11 @@
 
 	return;
 
+ignore:
+	atomic_dec(&phydev->irq_disable);
+	enable_irq(phydev->irq);
+	return;
+
 irq_enable_err:
 	disable_irq(phydev->irq);
 	atomic_inc(&phydev->irq_disable);
@@ -937,6 +946,5 @@
 	if (err < 0)
 		phy_error(phydev);
 
-	schedule_delayed_work(&phydev->state_queue,
-				jiffies + PHY_STATE_TIME * HZ);
+	schedule_delayed_work(&phydev->state_queue, PHY_STATE_TIME * HZ);
 }
diff -urN linux-2.6.30-rc2/drivers/net/sfc/efx.c linux-2.6.30-rc3/drivers/net/sfc/efx.c
--- linux-2.6.30-rc2/drivers/net/sfc/efx.c	2009-04-22 03:29:11.149931415 +0000
+++ linux-2.6.30-rc3/drivers/net/sfc/efx.c	2009-04-22 03:29:17.192931412 +0000
@@ -448,9 +448,6 @@
 
 		WARN_ON(channel->rx_pkt != NULL);
 		efx_rx_strategy(channel);
-
-		netif_napi_add(channel->napi_dev, &channel->napi_str,
-			       efx_poll, napi_weight);
 	}
 }
 
@@ -1321,6 +1318,8 @@
 
 	efx_for_each_channel(channel, efx) {
 		channel->napi_dev = efx->net_dev;
+		netif_napi_add(channel->napi_dev, &channel->napi_str,
+			       efx_poll, napi_weight);
 	}
 	return 0;
 }
@@ -1330,6 +1329,8 @@
 	struct efx_channel *channel;
 
 	efx_for_each_channel(channel, efx) {
+		if (channel->napi_dev)
+			netif_napi_del(&channel->napi_str);
 		channel->napi_dev = NULL;
 	}
 }
diff -urN linux-2.6.30-rc2/drivers/net/sfc/falcon.c linux-2.6.30-rc3/drivers/net/sfc/falcon.c
--- linux-2.6.30-rc2/drivers/net/sfc/falcon.c	2009-04-22 03:29:11.150931410 +0000
+++ linux-2.6.30-rc3/drivers/net/sfc/falcon.c	2009-04-22 03:29:17.193931402 +0000
@@ -1176,9 +1176,9 @@
 
 	EFX_POPULATE_QWORD_1(phy_event, EV_CODE, GLOBAL_EV_DECODE);
 	if (EFX_IS10G(efx))
-		EFX_SET_OWORD_FIELD(phy_event, XG_PHY_INTR, 1);
+		EFX_SET_QWORD_FIELD(phy_event, XG_PHY_INTR, 1);
 	else
-		EFX_SET_OWORD_FIELD(phy_event, G_PHY0_INTR, 1);
+		EFX_SET_QWORD_FIELD(phy_event, G_PHY0_INTR, 1);
 
 	falcon_generate_event(&efx->channel[0], &phy_event);
 }
diff -urN linux-2.6.30-rc2/drivers/net/sh_eth.c linux-2.6.30-rc3/drivers/net/sh_eth.c
--- linux-2.6.30-rc2/drivers/net/sh_eth.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/sh_eth.c	2009-04-22 03:29:17.196931422 +0000
@@ -1188,6 +1188,19 @@
 	return ret;
 }
 
+static const struct net_device_ops sh_eth_netdev_ops = {
+	.ndo_open		= sh_eth_open,
+	.ndo_stop		= sh_eth_close,
+	.ndo_start_xmit		= sh_eth_start_xmit,
+	.ndo_get_stats		= sh_eth_get_stats,
+	.ndo_set_multicast_list	= sh_eth_set_multicast_list,
+	.ndo_tx_timeout		= sh_eth_tx_timeout,
+	.ndo_do_ioctl		= sh_eth_do_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 static int sh_eth_drv_probe(struct platform_device *pdev)
 {
 	int ret, i, devno = 0;
@@ -1240,13 +1253,7 @@
 	mdp->edmac_endian = pd->edmac_endian;
 
 	/* set function */
-	ndev->open = sh_eth_open;
-	ndev->hard_start_xmit = sh_eth_start_xmit;
-	ndev->stop = sh_eth_close;
-	ndev->get_stats = sh_eth_get_stats;
-	ndev->set_multicast_list = sh_eth_set_multicast_list;
-	ndev->do_ioctl = sh_eth_do_ioctl;
-	ndev->tx_timeout = sh_eth_tx_timeout;
+	ndev->netdev_ops = &sh_eth_netdev_ops;
 	ndev->watchdog_timeo = TX_TIMEOUT;
 
 	mdp->post_rx = POST_RX >> (devno << 1);
diff -urN linux-2.6.30-rc2/drivers/net/skge.c linux-2.6.30-rc3/drivers/net/skge.c
--- linux-2.6.30-rc2/drivers/net/skge.c	2009-04-22 03:29:11.156931190 +0000
+++ linux-2.6.30-rc3/drivers/net/skge.c	2009-04-22 03:29:17.199931523 +0000
@@ -2674,7 +2674,7 @@
 	if (netif_msg_ifdown(skge))
 		printk(KERN_INFO PFX "%s: disabling interface\n", dev->name);
 
-	netif_stop_queue(dev);
+	netif_tx_disable(dev);
 
 	if (hw->chip_id == CHIP_ID_GENESIS && hw->phy_type == SK_PHY_XMAC)
 		del_timer_sync(&skge->link_timer);
@@ -2881,7 +2881,6 @@
 	}
 
 	skge->tx_ring.to_clean = e;
-	netif_wake_queue(dev);
 }
 
 static void skge_tx_timeout(struct net_device *dev)
@@ -2893,6 +2892,7 @@
 
 	skge_write8(skge->hw, Q_ADDR(txqaddr[skge->port], Q_CSR), CSR_STOP);
 	skge_tx_clean(dev);
+	netif_wake_queue(dev);
 }
 
 static int skge_change_mtu(struct net_device *dev, int new_mtu)
diff -urN linux-2.6.30-rc2/drivers/net/sun3_82586.c linux-2.6.30-rc3/drivers/net/sun3_82586.c
--- linux-2.6.30-rc2/drivers/net/sun3_82586.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/sun3_82586.c	2009-04-22 03:29:17.205931528 +0000
@@ -331,6 +331,18 @@
 	return ERR_PTR(err);
 }
 
+static const struct net_device_ops sun3_82586_netdev_ops = {
+	.ndo_open		= sun3_82586_open,
+	.ndo_stop		= sun3_82586_close,
+	.ndo_start_xmit		= sun3_82586_send_packet,
+	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_tx_timeout		= sun3_82586_timeout,
+	.ndo_get_stats		= sun3_82586_get_stats,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 static int __init sun3_82586_probe1(struct net_device *dev,int ioaddr)
 {
 	int i, size, retval;
@@ -381,13 +393,8 @@
 
 	printk("Memaddr: 0x%lx, Memsize: %d, IRQ %d\n",dev->mem_start,size, dev->irq);
 
-	dev->open		= sun3_82586_open;
-	dev->stop		= sun3_82586_close;
-	dev->get_stats		= sun3_82586_get_stats;
-	dev->tx_timeout 	= sun3_82586_timeout;
+	dev->netdev_ops		= &sun3_82586_netdev_ops;
 	dev->watchdog_timeo	= HZ/20;
-	dev->hard_start_xmit 	= sun3_82586_send_packet;
-	dev->set_multicast_list = set_multicast_list;
 
 	dev->if_port 		= 0;
 	return 0;
diff -urN linux-2.6.30-rc2/drivers/net/tc35815.c linux-2.6.30-rc3/drivers/net/tc35815.c
--- linux-2.6.30-rc2/drivers/net/tc35815.c	2009-04-22 03:29:11.164931408 +0000
+++ linux-2.6.30-rc3/drivers/net/tc35815.c	2009-04-22 03:29:17.208931431 +0000
@@ -862,6 +862,22 @@
 	return 0;
 }
 
+static const struct net_device_ops tc35815_netdev_ops = {
+	.ndo_open		= tc35815_open,
+	.ndo_stop		= tc35815_close,
+	.ndo_start_xmit		= tc35815_send_packet,
+	.ndo_get_stats		= tc35815_get_stats,
+	.ndo_set_multicast_list	= tc35815_set_multicast_list,
+	.ndo_tx_timeout		= tc35815_tx_timeout,
+	.ndo_do_ioctl		= tc35815_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= tc35815_poll_controller,
+#endif
+};
+
 static int __devinit tc35815_init_one(struct pci_dev *pdev,
 				      const struct pci_device_id *ent)
 {
@@ -904,21 +920,12 @@
 	ioaddr = pcim_iomap_table(pdev)[1];
 
 	/* Initialize the device structure. */
-	dev->open = tc35815_open;
-	dev->hard_start_xmit = tc35815_send_packet;
-	dev->stop = tc35815_close;
-	dev->get_stats = tc35815_get_stats;
-	dev->set_multicast_list = tc35815_set_multicast_list;
-	dev->do_ioctl = tc35815_ioctl;
+	dev->netdev_ops = &tc35815_netdev_ops;
 	dev->ethtool_ops = &tc35815_ethtool_ops;
-	dev->tx_timeout = tc35815_tx_timeout;
 	dev->watchdog_timeo = TC35815_TX_TIMEOUT;
 #ifdef TC35815_NAPI
 	netif_napi_add(dev, &lp->napi, tc35815_poll, NAPI_WEIGHT);
 #endif
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	dev->poll_controller = tc35815_poll_controller;
-#endif
 
 	dev->irq = pdev->irq;
 	dev->base_addr = (unsigned long)ioaddr;
diff -urN linux-2.6.30-rc2/drivers/net/tg3.c linux-2.6.30-rc3/drivers/net/tg3.c
--- linux-2.6.30-rc2/drivers/net/tg3.c	2009-04-22 03:29:11.171931201 +0000
+++ linux-2.6.30-rc3/drivers/net/tg3.c	2009-04-22 03:29:17.215931227 +0000
@@ -12443,8 +12443,13 @@
 		/* Next, try NVRAM. */
 		if (!tg3_nvram_read_be32(tp, mac_offset + 0, &hi) &&
 		    !tg3_nvram_read_be32(tp, mac_offset + 4, &lo)) {
-			memcpy(&dev->dev_addr[0], ((char *)&hi) + 2, 2);
-			memcpy(&dev->dev_addr[2], (char *)&lo, sizeof(lo));
+			dev->dev_addr[0] = ((hi >> 16) & 0xff);
+			dev->dev_addr[1] = ((hi >> 24) & 0xff);
+			dev->dev_addr[2] = ((lo >>  0) & 0xff);
+			dev->dev_addr[3] = ((lo >>  8) & 0xff);
+			dev->dev_addr[4] = ((lo >> 16) & 0xff);
+			dev->dev_addr[5] = ((lo >> 24) & 0xff);
+
 		}
 		/* Finally just fetch it out of the MAC control regs. */
 		else {
diff -urN linux-2.6.30-rc2/drivers/net/tsi108_eth.c linux-2.6.30-rc3/drivers/net/tsi108_eth.c
--- linux-2.6.30-rc2/drivers/net/tsi108_eth.c	2009-04-22 03:29:11.181931380 +0000
+++ linux-2.6.30-rc3/drivers/net/tsi108_eth.c	2009-04-22 03:29:17.224931429 +0000
@@ -1561,6 +1561,18 @@
 	.set_settings	= tsi108_set_settings,
 };
 
+static const struct net_device_ops tsi108_netdev_ops = {
+	.ndo_open		= tsi108_open,
+	.ndo_stop		= tsi108_close,
+	.ndo_start_xmit		= tsi108_send_packet,
+	.ndo_set_multicast_list	= tsi108_set_rx_mode,
+	.ndo_get_stats		= tsi108_get_stats,
+	.ndo_do_ioctl		= tsi108_do_ioctl,
+	.ndo_set_mac_address	= tsi108_set_mac,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 static int
 tsi108_init_one(struct platform_device *pdev)
 {
@@ -1616,14 +1628,8 @@
 	data->phy_type = einfo->phy_type;
 	data->irq_num = einfo->irq_num;
 	data->id = pdev->id;
-	dev->open = tsi108_open;
-	dev->stop = tsi108_close;
-	dev->hard_start_xmit = tsi108_send_packet;
-	dev->set_mac_address = tsi108_set_mac;
-	dev->set_multicast_list = tsi108_set_rx_mode;
-	dev->get_stats = tsi108_get_stats;
 	netif_napi_add(dev, &data->napi, tsi108_poll, 64);
-	dev->do_ioctl = tsi108_do_ioctl;
+	dev->netdev_ops = &tsi108_netdev_ops;
 	dev->ethtool_ops = &tsi108_ethtool_ops;
 
 	/* Apparently, the Linux networking code won't use scatter-gather
diff -urN linux-2.6.30-rc2/drivers/net/tun.c linux-2.6.30-rc3/drivers/net/tun.c
--- linux-2.6.30-rc2/drivers/net/tun.c	2009-04-22 03:29:11.184931416 +0000
+++ linux-2.6.30-rc3/drivers/net/tun.c	2009-04-22 03:29:17.228931385 +0000
@@ -518,7 +518,7 @@
 	int err;
 
 	/* Under a page?  Don't bother with paged skb. */
-	if (prepad + len < PAGE_SIZE)
+	if (prepad + len < PAGE_SIZE || !linear)
 		linear = len;
 
 	skb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,
@@ -565,7 +565,8 @@
 
 	if ((tun->flags & TUN_TYPE_MASK) == TUN_TAP_DEV) {
 		align = NET_IP_ALIGN;
-		if (unlikely(len < ETH_HLEN))
+		if (unlikely(len < ETH_HLEN ||
+			     (gso.hdr_len && gso.hdr_len < ETH_HLEN)))
 			return -EINVAL;
 	}
 
diff -urN linux-2.6.30-rc2/drivers/net/via-velocity.c linux-2.6.30-rc3/drivers/net/via-velocity.c
--- linux-2.6.30-rc2/drivers/net/via-velocity.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/net/via-velocity.c	2009-04-22 03:29:17.240931382 +0000
@@ -377,7 +377,7 @@
 static int velocity_open(struct net_device *dev);
 static int velocity_change_mtu(struct net_device *dev, int mtu);
 static int velocity_xmit(struct sk_buff *skb, struct net_device *dev);
-static int velocity_intr(int irq, void *dev_instance);
+static irqreturn_t velocity_intr(int irq, void *dev_instance);
 static void velocity_set_multi(struct net_device *dev);
 static struct net_device_stats *velocity_get_stats(struct net_device *dev);
 static int velocity_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
@@ -2215,7 +2215,7 @@
  *	efficiently as possible.
  */
 
-static int velocity_intr(int irq, void *dev_instance)
+static irqreturn_t velocity_intr(int irq, void *dev_instance)
 {
 	struct net_device *dev = dev_instance;
 	struct velocity_info *vptr = netdev_priv(dev);
diff -urN linux-2.6.30-rc2/drivers/net/xtsonic.c linux-2.6.30-rc3/drivers/net/xtsonic.c
--- linux-2.6.30-rc2/drivers/net/xtsonic.c	2009-04-22 03:29:11.353932094 +0000
+++ linux-2.6.30-rc3/drivers/net/xtsonic.c	2009-04-22 03:29:17.397931583 +0000
@@ -108,6 +108,18 @@
 	return err;
 }
 
+static const struct net_device_ops xtsonic_netdev_ops = {
+	.ndo_open		= xtsonic_open,
+	.ndo_stop		= xtsonic_close,
+	.ndo_start_xmit		= sonic_send_packet,
+	.ndo_get_stats		= sonic_get_stats,
+	.ndo_set_multicast_list	= sonic_multicast_list,
+	.ndo_tx_timeout		= sonic_tx_timeout,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
 static int __init sonic_probe1(struct net_device *dev)
 {
 	static unsigned version_printed = 0;
@@ -205,12 +217,7 @@
 	lp->rra_laddr = lp->rda_laddr + (SIZEOF_SONIC_RD * SONIC_NUM_RDS
 					 * SONIC_BUS_SCALE(lp->dma_bitmode));
 
-	dev->open = xtsonic_open;
-	dev->stop = xtsonic_close;
-	dev->hard_start_xmit	= sonic_send_packet;
-	dev->get_stats		= sonic_get_stats;
-	dev->set_multicast_list	= &sonic_multicast_list;
-	dev->tx_timeout		= sonic_tx_timeout;
+	dev->netdev_ops		= &xtsonic_netdev_ops;
 	dev->watchdog_timeo	= TX_TIMEOUT;
 
 	/*
diff -urN linux-2.6.30-rc2/drivers/rtc/Kconfig linux-2.6.30-rc3/drivers/rtc/Kconfig
--- linux-2.6.30-rc2/drivers/rtc/Kconfig	2009-04-22 03:29:11.381931404 +0000
+++ linux-2.6.30-rc3/drivers/rtc/Kconfig	2009-04-22 03:29:17.425931425 +0000
@@ -573,7 +573,7 @@
 
 config RTC_DRV_SH
 	tristate "SuperH On-Chip RTC"
-	depends on RTC_CLASS && SUPERH
+	depends on RTC_CLASS && SUPERH && HAVE_CLK
 	help
 	  Say Y here to enable support for the on-chip RTC found in
 	  most SuperH processors.
diff -urN linux-2.6.30-rc2/drivers/rtc/rtc-cmos.c linux-2.6.30-rc3/drivers/rtc/rtc-cmos.c
--- linux-2.6.30-rc2/drivers/rtc/rtc-cmos.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/rtc/rtc-cmos.c	2009-04-22 03:29:17.426931579 +0000
@@ -797,17 +797,15 @@
 		goto cleanup2;
 	}
 
-	pr_info("%s: alarms up to one %s%s, %zd bytes nvram%s\n",
-			dev_name(&cmos_rtc.rtc->dev),
-			is_valid_irq(rtc_irq)
-				?  (cmos_rtc.mon_alrm
-					? "year"
-					: (cmos_rtc.day_alrm
-						? "month" : "day"))
-				: "no",
-			cmos_rtc.century ? ", y3k" : "",
-			nvram.size,
-			is_hpet_enabled() ? ", hpet irqs" : "");
+	pr_info("%s: %s%s, %zd bytes nvram%s\n",
+		dev_name(&cmos_rtc.rtc->dev),
+		!is_valid_irq(rtc_irq) ? "no alarms" :
+			cmos_rtc.mon_alrm ? "alarms up to one year" :
+			cmos_rtc.day_alrm ? "alarms up to one month" :
+			"alarms up to one day",
+		cmos_rtc.century ? ", y3k" : "",
+		nvram.size,
+		is_hpet_enabled() ? ", hpet irqs" : "");
 
 	return 0;
 
diff -urN linux-2.6.30-rc2/drivers/rtc/rtc-sh.c linux-2.6.30-rc3/drivers/rtc/rtc-sh.c
--- linux-2.6.30-rc2/drivers/rtc/rtc-sh.c	2009-04-22 03:29:11.385555955 +0000
+++ linux-2.6.30-rc3/drivers/rtc/rtc-sh.c	2009-04-22 03:29:17.429931423 +0000
@@ -1,7 +1,7 @@
 /*
  * SuperH On-Chip RTC Support
  *
- * Copyright (C) 2006, 2007, 2008  Paul Mundt
+ * Copyright (C) 2006 - 2009  Paul Mundt
  * Copyright (C) 2006  Jamie Lenehan
  * Copyright (C) 2008  Angelo Castello
  *
@@ -25,10 +25,11 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/log2.h>
+#include <linux/clk.h>
 #include <asm/rtc.h>
 
 #define DRV_NAME	"sh-rtc"
-#define DRV_VERSION	"0.2.1"
+#define DRV_VERSION	"0.2.2"
 
 #define RTC_REG(r)	((r) * rtc_reg_size)
 
@@ -87,16 +88,17 @@
 #define RCR2_START	0x01	/* Start bit               */
 
 struct sh_rtc {
-	void __iomem *regbase;
-	unsigned long regsize;
-	struct resource *res;
-	int alarm_irq;
-	int periodic_irq;
-	int carry_irq;
-	struct rtc_device *rtc_dev;
-	spinlock_t lock;
-	unsigned long capabilities;	/* See asm-sh/rtc.h for cap bits */
-	unsigned short periodic_freq;
+	void __iomem		*regbase;
+	unsigned long		regsize;
+	struct resource		*res;
+	int			alarm_irq;
+	int			periodic_irq;
+	int			carry_irq;
+	struct clk		*clk;
+	struct rtc_device	*rtc_dev;
+	spinlock_t		lock;
+	unsigned long		capabilities;	/* See asm/rtc.h for cap bits */
+	unsigned short		periodic_freq;
 };
 
 static int __sh_rtc_interrupt(struct sh_rtc *rtc)
@@ -294,10 +296,10 @@
 
 	tmp = readb(rtc->regbase + RCR1);
 
-	if (!enable)
-		tmp &= ~RCR1_AIE;
-	else
+	if (enable)
 		tmp |= RCR1_AIE;
+	else
+		tmp &= ~RCR1_AIE;
 
 	writeb(tmp, rtc->regbase + RCR1);
 
@@ -618,6 +620,7 @@
 {
 	if (!is_power_of_2(freq))
 		return -EINVAL;
+
 	return sh_rtc_ioctl(dev, RTC_IRQP_SET, freq);
 }
 
@@ -637,7 +640,8 @@
 	struct sh_rtc *rtc;
 	struct resource *res;
 	struct rtc_time r;
-	int ret;
+	char clk_name[6];
+	int clk_id, ret;
 
 	rtc = kzalloc(sizeof(struct sh_rtc), GFP_KERNEL);
 	if (unlikely(!rtc))
@@ -652,6 +656,7 @@
 		dev_err(&pdev->dev, "No IRQ resource\n");
 		goto err_badres;
 	}
+
 	rtc->periodic_irq = ret;
 	rtc->carry_irq = platform_get_irq(pdev, 1);
 	rtc->alarm_irq = platform_get_irq(pdev, 2);
@@ -663,7 +668,7 @@
 		goto err_badres;
 	}
 
-	rtc->regsize = res->end - res->start + 1;
+	rtc->regsize = resource_size(res);
 
 	rtc->res = request_mem_region(res->start, rtc->regsize, pdev->name);
 	if (unlikely(!rtc->res)) {
@@ -677,6 +682,26 @@
 		goto err_badmap;
 	}
 
+	clk_id = pdev->id;
+	/* With a single device, the clock id is still "rtc0" */
+	if (clk_id < 0)
+		clk_id = 0;
+
+	snprintf(clk_name, sizeof(clk_name), "rtc%d", clk_id);
+
+	rtc->clk = clk_get(&pdev->dev, clk_name);
+	if (IS_ERR(rtc->clk)) {
+		/*
+		 * No error handling for rtc->clk intentionally, not all
+		 * platforms will have a unique clock for the RTC, and
+		 * the clk API can handle the struct clk pointer being
+		 * NULL.
+		 */
+		rtc->clk = NULL;
+	}
+
+	clk_enable(rtc->clk);
+
 	rtc->rtc_dev = rtc_device_register("sh", &pdev->dev,
 					   &sh_rtc_ops, THIS_MODULE);
 	if (IS_ERR(rtc->rtc_dev)) {
@@ -759,6 +784,8 @@
 	return 0;
 
 err_unmap:
+	clk_disable(rtc->clk);
+	clk_put(rtc->clk);
 	iounmap(rtc->regbase);
 err_badmap:
 	release_resource(rtc->res);
@@ -780,6 +807,7 @@
 	sh_rtc_setcie(&pdev->dev, 0);
 
 	free_irq(rtc->periodic_irq, rtc);
+
 	if (rtc->carry_irq > 0) {
 		free_irq(rtc->carry_irq, rtc);
 		free_irq(rtc->alarm_irq, rtc);
@@ -789,6 +817,9 @@
 
 	iounmap(rtc->regbase);
 
+	clk_disable(rtc->clk);
+	clk_put(rtc->clk);
+
 	platform_set_drvdata(pdev, NULL);
 
 	kfree(rtc);
@@ -802,11 +833,11 @@
 	struct sh_rtc *rtc = platform_get_drvdata(pdev);
 
 	set_irq_wake(rtc->periodic_irq, enabled);
+
 	if (rtc->carry_irq > 0) {
 		set_irq_wake(rtc->carry_irq, enabled);
 		set_irq_wake(rtc->alarm_irq, enabled);
 	}
-
 }
 
 static int sh_rtc_suspend(struct device *dev)
diff -urN linux-2.6.30-rc2/drivers/s390/block/dasd.c linux-2.6.30-rc3/drivers/s390/block/dasd.c
--- linux-2.6.30-rc2/drivers/s390/block/dasd.c	2009-04-22 03:29:11.386556089 +0000
+++ linux-2.6.30-rc3/drivers/s390/block/dasd.c	2009-04-22 03:29:17.430931439 +0000
@@ -20,6 +20,7 @@
 #include <linux/slab.h>
 #include <linux/buffer_head.h>
 #include <linux/hdreg.h>
+#include <linux/async.h>
 
 #include <asm/ccwdev.h>
 #include <asm/ebcdic.h>
@@ -480,8 +481,10 @@
         if (rc && rc != -EAGAIN)
                 device->target = device->state;
 
-	if (device->state == device->target)
+	if (device->state == device->target) {
 		wake_up(&dasd_init_waitq);
+		dasd_put_device(device);
+	}
 
 	/* let user-space know that the device status changed */
 	kobject_uevent(&device->cdev->dev.kobj, KOBJ_CHANGE);
@@ -513,12 +516,15 @@
  */
 void dasd_set_target_state(struct dasd_device *device, int target)
 {
+	dasd_get_device(device);
 	/* If we are in probeonly mode stop at DASD_STATE_READY. */
 	if (dasd_probeonly && target > DASD_STATE_READY)
 		target = DASD_STATE_READY;
 	if (device->target != target) {
-                if (device->state == target)
+		if (device->state == target) {
 			wake_up(&dasd_init_waitq);
+			dasd_put_device(device);
+		}
 		device->target = target;
 	}
 	if (device->state != device->target)
@@ -2148,6 +2154,22 @@
  * SECTION: common functions for ccw_driver use
  */
 
+static void dasd_generic_auto_online(void *data, async_cookie_t cookie)
+{
+	struct ccw_device *cdev = data;
+	int ret;
+
+	ret = ccw_device_set_online(cdev);
+	if (ret)
+		pr_warning("%s: Setting the DASD online failed with rc=%d\n",
+			   dev_name(&cdev->dev), ret);
+	else {
+		struct dasd_device *device = dasd_device_from_cdev(cdev);
+		wait_event(dasd_init_waitq, _wait_for_device(device));
+		dasd_put_device(device);
+	}
+}
+
 /*
  * Initial attempt at a probe function. this can be simplified once
  * the other detection code is gone.
@@ -2180,10 +2202,7 @@
 	 */
 	if ((dasd_get_feature(cdev, DASD_FEATURE_INITIAL_ONLINE) > 0 ) ||
 	    (dasd_autodetect && dasd_busid_known(dev_name(&cdev->dev)) != 0))
-		ret = ccw_device_set_online(cdev);
-	if (ret)
-		pr_warning("%s: Setting the DASD online failed with rc=%d\n",
-		       dev_name(&cdev->dev), ret);
+		async_schedule(dasd_generic_auto_online, cdev);
 	return 0;
 }
 
@@ -2290,13 +2309,7 @@
 	} else
 		pr_debug("dasd_generic device %s found\n",
 				dev_name(&cdev->dev));
-
-	/* FIXME: we have to wait for the root device but we don't want
-	 * to wait for each single device but for all at once. */
-	wait_event(dasd_init_waitq, _wait_for_device(device));
-
 	dasd_put_device(device);
-
 	return rc;
 }
 
diff -urN linux-2.6.30-rc2/drivers/s390/block/dasd_eckd.c linux-2.6.30-rc3/drivers/s390/block/dasd_eckd.c
--- linux-2.6.30-rc2/drivers/s390/block/dasd_eckd.c	2009-04-22 03:29:11.390931210 +0000
+++ linux-2.6.30-rc3/drivers/s390/block/dasd_eckd.c	2009-04-22 03:29:17.434931317 +0000
@@ -2019,15 +2019,23 @@
 				ccw++;
 				recid += count;
 				new_track = 0;
+				/* first idaw for a ccw may start anywhere */
+				if (!idaw_dst)
+					idaw_dst = dst;
 			}
-			/* If we start a new idaw, everything is fine and the
-			 * start of the new idaw is the start of this segment.
+			/* If we start a new idaw, we must make sure that it
+			 * starts on an IDA_BLOCK_SIZE boundary.
 			 * If we continue an idaw, we must make sure that the
 			 * current segment begins where the so far accumulated
 			 * idaw ends
 			 */
-			if (!idaw_dst)
-				idaw_dst = dst;
+			if (!idaw_dst) {
+				if (__pa(dst) & (IDA_BLOCK_SIZE-1)) {
+					dasd_sfree_request(cqr, startdev);
+					return ERR_PTR(-ERANGE);
+				} else
+					idaw_dst = dst;
+			}
 			if ((idaw_dst + idaw_len) != dst) {
 				dasd_sfree_request(cqr, startdev);
 				return ERR_PTR(-ERANGE);
diff -urN linux-2.6.30-rc2/drivers/s390/cio/qdio_main.c linux-2.6.30-rc3/drivers/s390/cio/qdio_main.c
--- linux-2.6.30-rc2/drivers/s390/cio/qdio_main.c	2009-04-22 03:29:11.398556401 +0000
+++ linux-2.6.30-rc3/drivers/s390/cio/qdio_main.c	2009-04-22 03:29:17.443932032 +0000
@@ -881,42 +881,6 @@
 	qdio_set_state(irq_ptr, QDIO_IRQ_STATE_STOPPED);
 }
 
-static void qdio_call_shutdown(struct work_struct *work)
-{
-	struct ccw_device_private *priv;
-	struct ccw_device *cdev;
-
-	priv = container_of(work, struct ccw_device_private, kick_work);
-	cdev = priv->cdev;
-	qdio_shutdown(cdev, QDIO_FLAG_CLEANUP_USING_CLEAR);
-	put_device(&cdev->dev);
-}
-
-static void qdio_int_error(struct ccw_device *cdev)
-{
-	struct qdio_irq *irq_ptr = cdev->private->qdio_data;
-
-	switch (irq_ptr->state) {
-	case QDIO_IRQ_STATE_INACTIVE:
-	case QDIO_IRQ_STATE_CLEANUP:
-		qdio_set_state(irq_ptr, QDIO_IRQ_STATE_ERR);
-		break;
-	case QDIO_IRQ_STATE_ESTABLISHED:
-	case QDIO_IRQ_STATE_ACTIVE:
-		qdio_set_state(irq_ptr, QDIO_IRQ_STATE_STOPPED);
-		if (get_device(&cdev->dev)) {
-			/* Can't call shutdown from interrupt context. */
-			PREPARE_WORK(&cdev->private->kick_work,
-				     qdio_call_shutdown);
-			queue_work(ccw_device_work, &cdev->private->kick_work);
-		}
-		break;
-	default:
-		WARN_ON(1);
-	}
-	wake_up(&cdev->private->wait_q);
-}
-
 static int qdio_establish_check_errors(struct ccw_device *cdev, int cstat,
 				       int dstat)
 {
@@ -973,10 +937,8 @@
 		switch (PTR_ERR(irb)) {
 		case -EIO:
 			DBF_ERROR("%4x IO error", irq_ptr->schid.sch_no);
-			return;
-		case -ETIMEDOUT:
-			DBF_ERROR("%4x IO timeout", irq_ptr->schid.sch_no);
-			qdio_int_error(cdev);
+			qdio_set_state(irq_ptr, QDIO_IRQ_STATE_ERR);
+			wake_up(&cdev->private->wait_q);
 			return;
 		default:
 			WARN_ON(1);
@@ -1001,7 +963,6 @@
 	case QDIO_IRQ_STATE_ACTIVE:
 		if (cstat & SCHN_STAT_PCI) {
 			qdio_int_handler_pci(irq_ptr);
-			/* no state change so no need to wake up wait_q */
 			return;
 		}
 		if ((cstat & ~SCHN_STAT_PCI) || dstat) {
diff -urN linux-2.6.30-rc2/drivers/sbus/char/jsflash.c linux-2.6.30-rc3/drivers/sbus/char/jsflash.c
--- linux-2.6.30-rc2/drivers/sbus/char/jsflash.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/sbus/char/jsflash.c	2009-04-22 03:29:17.457931504 +0000
@@ -383,18 +383,22 @@
 	return 0;
 }
 
-static int jsf_ioctl(struct inode *inode, struct file *f, unsigned int cmd,
-    unsigned long arg)
+static long jsf_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
 {
+	lock_kernel();
 	int error = -ENOTTY;
 	void __user *argp = (void __user *)arg;
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN)) {
+		unlock_kernel();
 		return -EPERM;
+	}
 	switch (cmd) {
 	case JSFLASH_IDENT:
-		if (copy_to_user(argp, &jsf0.id, JSFIDSZ))
+		if (copy_to_user(argp, &jsf0.id, JSFIDSZ)) {
+			unlock_kernel();
 			return -EFAULT;
+		}
 		break;
 	case JSFLASH_ERASE:
 		error = jsf_ioctl_erase(arg);
@@ -404,6 +408,7 @@
 		break;
 	}
 
+	unlock_kernel();
 	return error;
 }
 
@@ -439,7 +444,7 @@
 	.llseek =	jsf_lseek,
 	.read =		jsf_read,
 	.write =	jsf_write,
-	.ioctl =	jsf_ioctl,
+	.unlocked_ioctl =	jsf_ioctl,
 	.mmap =		jsf_mmap,
 	.open =		jsf_open,
 	.release =	jsf_release,
diff -urN linux-2.6.30-rc2/drivers/sbus/char/uctrl.c linux-2.6.30-rc3/drivers/sbus/char/uctrl.c
--- linux-2.6.30-rc2/drivers/sbus/char/uctrl.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/sbus/char/uctrl.c	2009-04-22 03:29:17.457931504 +0000
@@ -197,9 +197,8 @@
 static void uctrl_get_event_status(struct uctrl_driver *);
 static void uctrl_get_external_status(struct uctrl_driver *);
 
-static int
-uctrl_ioctl(struct inode *inode, struct file *file,
-	      unsigned int cmd, unsigned long arg)
+static long
+uctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	switch (cmd) {
 		default:
@@ -226,7 +225,7 @@
 static const struct file_operations uctrl_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
-	.ioctl =	uctrl_ioctl,
+	.unlocked_ioctl =	uctrl_ioctl,
 	.open =		uctrl_open,
 };
 
diff -urN linux-2.6.30-rc2/drivers/scsi/scsi_scan.c linux-2.6.30-rc3/drivers/scsi/scsi_scan.c
--- linux-2.6.30-rc2/drivers/scsi/scsi_scan.c	2009-04-22 03:29:11.487931304 +0000
+++ linux-2.6.30-rc3/drivers/scsi/scsi_scan.c	2009-04-22 03:29:17.531931724 +0000
@@ -180,8 +180,6 @@
 	spin_unlock(&async_scan_lock);
 
 	kfree(data);
-	/* Synchronize async operations globally */
-	async_synchronize_full();
 	return 0;
 }
 
diff -urN linux-2.6.30-rc2/drivers/scsi/scsi_wait_scan.c linux-2.6.30-rc3/drivers/scsi/scsi_wait_scan.c
--- linux-2.6.30-rc2/drivers/scsi/scsi_wait_scan.c	2009-04-22 03:29:11.488931414 +0000
+++ linux-2.6.30-rc3/drivers/scsi/scsi_wait_scan.c	2009-04-22 03:29:17.532931402 +0000
@@ -11,10 +11,21 @@
  */
 
 #include <linux/module.h>
+#include <linux/device.h>
 #include <scsi/scsi_scan.h>
 
 static int __init wait_scan_init(void)
 {
+	/*
+	 * First we need to wait for device probing to finish;
+	 * the drivers we just loaded might just still be probing
+	 * and might not yet have reached the scsi async scanning
+	 */
+	wait_for_device_probe();
+	/*
+	 * and then we wait for the actual asynchronous scsi scan
+	 * to finish.
+	 */
 	scsi_complete_async_scans();
 	return 0;
 }
diff -urN linux-2.6.30-rc2/drivers/serial/bfin_5xx.c linux-2.6.30-rc3/drivers/serial/bfin_5xx.c
--- linux-2.6.30-rc2/drivers/serial/bfin_5xx.c	2009-04-22 03:29:11.497931423 +0000
+++ linux-2.6.30-rc3/drivers/serial/bfin_5xx.c	2009-04-22 03:29:17.541931444 +0000
@@ -166,7 +166,7 @@
 	struct tty_struct *tty = uart->port.info->port.tty;
 
 #ifdef CONFIG_SERIAL_BFIN_HARD_CTSRTS
-	if (uart->scts && (!bfin_serial_get_mctrl(&uart->port)&TIOCM_CTS)) {
+	if (uart->scts && !(bfin_serial_get_mctrl(&uart->port) & TIOCM_CTS)) {
 		uart->scts = 0;
 		uart_handle_cts_change(&uart->port, uart->scts);
 	}
@@ -368,7 +368,7 @@
 	struct bfin_serial_port *uart = dev_id;
 
 #ifdef CONFIG_SERIAL_BFIN_HARD_CTSRTS
-	if (uart->scts && (!bfin_serial_get_mctrl(&uart->port)&TIOCM_CTS)) {
+	if (uart->scts && !(bfin_serial_get_mctrl(&uart->port) & TIOCM_CTS)) {
 		uart->scts = 0;
 		uart_handle_cts_change(&uart->port, uart->scts);
 	}
@@ -504,7 +504,7 @@
 	struct circ_buf *xmit = &uart->port.info->xmit;
 
 #ifdef CONFIG_SERIAL_BFIN_HARD_CTSRTS
-	if (uart->scts && (!bfin_serial_get_mctrl(&uart->port)&TIOCM_CTS)) {
+	if (uart->scts && !(bfin_serial_get_mctrl(&uart->port)&TIOCM_CTS)) {
 		uart->scts = 0;
 		uart_handle_cts_change(&uart->port, uart->scts);
 	}
diff -urN linux-2.6.30-rc2/drivers/serial/samsung.c linux-2.6.30-rc3/drivers/serial/samsung.c
--- linux-2.6.30-rc2/drivers/serial/samsung.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/serial/samsung.c	2009-04-22 03:29:17.546555529 +0000
@@ -127,7 +127,7 @@
 	struct s3c24xx_uart_port *ourport = to_ourport(port);
 
 	if (tx_enabled(port)) {
-		disable_irq(ourport->tx_irq);
+		disable_irq_nosync(ourport->tx_irq);
 		tx_enabled(port) = 0;
 		if (port->flags & UPF_CONS_FLOW)
 			s3c24xx_serial_rx_enable(port);
@@ -154,7 +154,7 @@
 
 	if (rx_enabled(port)) {
 		dbg("s3c24xx_serial_stop_rx: port=%p\n", port);
-		disable_irq(ourport->rx_irq);
+		disable_irq_nosync(ourport->rx_irq);
 		rx_enabled(port) = 0;
 	}
 }
diff -urN linux-2.6.30-rc2/drivers/spi/pxa2xx_spi.c linux-2.6.30-rc3/drivers/spi/pxa2xx_spi.c
--- linux-2.6.30-rc2/drivers/spi/pxa2xx_spi.c	2009-04-22 03:29:11.506931412 +0000
+++ linux-2.6.30-rc3/drivers/spi/pxa2xx_spi.c	2009-04-22 03:29:17.551931519 +0000
@@ -195,7 +195,7 @@
 	struct chip_data *chip = drv_data->cur_chip;
 
 	if (chip->cs_control) {
-		chip->cs_control(PXA2XX_CS_ASSERT);
+		chip->cs_control(PXA2XX_CS_DEASSERT);
 		return;
 	}
 
@@ -213,7 +213,7 @@
 		while (read_SSSR(reg) & SSSR_RNE) {
 			read_SSDR(reg);
 		}
-	} while ((read_SSSR(reg) & SSSR_BSY) && limit--);
+	} while ((read_SSSR(reg) & SSSR_BSY) && --limit);
 	write_SSSR(SSSR_ROR, reg);
 
 	return limit;
@@ -484,7 +484,7 @@
 {
 	unsigned long limit = loops_per_jiffy << 1;
 
-	while ((read_SSSR(ioaddr) & SSSR_BSY) && limit--)
+	while ((read_SSSR(ioaddr) & SSSR_BSY) && --limit)
 		cpu_relax();
 
 	return limit;
@@ -494,7 +494,7 @@
 {
 	unsigned long limit = loops_per_jiffy << 1;
 
-	while (!(DCSR(channel) & DCSR_STOPSTATE) && limit--)
+	while (!(DCSR(channel) & DCSR_STOPSTATE) && --limit)
 		cpu_relax();
 
 	return limit;
@@ -1700,6 +1700,13 @@
 	struct ssp_device *ssp = drv_data->ssp;
 	int status = 0;
 
+	if (drv_data->rx_channel != -1)
+		DRCMR(drv_data->ssp->drcmr_rx) =
+			DRCMR_MAPVLD | drv_data->rx_channel;
+	if (drv_data->tx_channel != -1)
+		DRCMR(drv_data->ssp->drcmr_tx) =
+			DRCMR_MAPVLD | drv_data->tx_channel;
+
 	/* Enable the SSP clock */
 	clk_enable(ssp->clk);
 
diff -urN linux-2.6.30-rc2/drivers/staging/android/binder.c linux-2.6.30-rc3/drivers/staging/android/binder.c
--- linux-2.6.30-rc2/drivers/staging/android/binder.c	2009-04-22 03:29:11.514931495 +0000
+++ linux-2.6.30-rc3/drivers/staging/android/binder.c	2009-04-22 03:29:17.559931437 +0000
@@ -41,6 +41,8 @@
 static struct proc_dir_entry *binder_proc_dir_entry_root;
 static struct proc_dir_entry *binder_proc_dir_entry_proc;
 static struct hlist_head binder_dead_nodes;
+static HLIST_HEAD(binder_deferred_list);
+static DEFINE_MUTEX(binder_deferred_lock);
 
 static int binder_read_proc_proc(
 	char *page, char **start, off_t off, int count, int *eof, void *data);
@@ -54,11 +56,7 @@
 #define SZ_4M                               0x400000
 #endif
 
-#ifndef __i386__
-#define FORBIDDEN_MMAP_FLAGS                (VM_WRITE | VM_EXEC)
-#else
 #define FORBIDDEN_MMAP_FLAGS                (VM_WRITE)
-#endif
 
 #define BINDER_SMALL_BUF_SIZE (PAGE_SIZE * 64)
 
@@ -236,6 +234,12 @@
 	uint8_t data[0];
 };
 
+enum {
+	BINDER_DEFERRED_PUT_FILES    = 0x01,
+	BINDER_DEFERRED_FLUSH        = 0x02,
+	BINDER_DEFERRED_RELEASE      = 0x04,
+};
+
 struct binder_proc {
 	struct hlist_node proc_node;
 	struct rb_root threads;
@@ -245,8 +249,11 @@
 	int pid;
 	struct vm_area_struct *vma;
 	struct task_struct *tsk;
+	struct files_struct *files;
+	struct hlist_node deferred_work_node;
+	int deferred_work;
 	void *buffer;
-	size_t user_buffer_offset;
+	ptrdiff_t user_buffer_offset;
 
 	struct list_head buffers;
 	struct rb_root free_buffers;
@@ -310,12 +317,14 @@
 	uid_t	sender_euid;
 };
 
+static void binder_defer_work(struct binder_proc *proc, int defer);
+
 /*
  * copied from get_unused_fd_flags
  */
-int task_get_unused_fd_flags(struct task_struct *tsk, int flags)
+int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
 {
-	struct files_struct *files = get_files_struct(tsk);
+	struct files_struct *files = proc->files;
 	int fd, error;
 	struct fdtable *fdt;
 	unsigned long rlim_cur;
@@ -337,9 +346,9 @@
 	 * will limit the total number of files that can be opened.
 	 */
 	rlim_cur = 0;
-	if (lock_task_sighand(tsk, &irqs)) {
-		rlim_cur = tsk->signal->rlim[RLIMIT_NOFILE].rlim_cur;
-		unlock_task_sighand(tsk, &irqs);
+	if (lock_task_sighand(proc->tsk, &irqs)) {
+		rlim_cur = proc->tsk->signal->rlim[RLIMIT_NOFILE].rlim_cur;
+		unlock_task_sighand(proc->tsk, &irqs);
 	}
 	if (fd >= rlim_cur)
 		goto out;
@@ -375,7 +384,6 @@
 
 out:
 	spin_unlock(&files->file_lock);
-	put_files_struct(files);
 	return error;
 }
 
@@ -383,9 +391,9 @@
  * copied from fd_install
  */
 static void task_fd_install(
-	struct task_struct *tsk, unsigned int fd, struct file *file)
+	struct binder_proc *proc, unsigned int fd, struct file *file)
 {
-	struct files_struct *files = get_files_struct(tsk);
+	struct files_struct *files = proc->files;
 	struct fdtable *fdt;
 
 	if (files == NULL)
@@ -396,7 +404,6 @@
 	BUG_ON(fdt->fd[fd] != NULL);
 	rcu_assign_pointer(fdt->fd[fd], file);
 	spin_unlock(&files->file_lock);
-	put_files_struct(files);
 }
 
 /*
@@ -413,10 +420,10 @@
 /*
  * copied from sys_close
  */
-static long task_close_fd(struct task_struct *tsk, unsigned int fd)
+static long task_close_fd(struct binder_proc *proc, unsigned int fd)
 {
 	struct file *filp;
-	struct files_struct *files = get_files_struct(tsk);
+	struct files_struct *files = proc->files;
 	struct fdtable *fdt;
 	int retval;
 
@@ -443,12 +450,10 @@
 		     retval == -ERESTART_RESTARTBLOCK))
 		retval = -EINTR;
 
-	put_files_struct(files);
 	return retval;
 
 out_unlock:
 	spin_unlock(&files->file_lock);
-	put_files_struct(files);
 	return -EBADF;
 }
 
@@ -618,7 +623,8 @@
 			       proc->pid, page_addr);
 			goto err_map_kernel_failed;
 		}
-		user_page_addr = (size_t)page_addr + proc->user_buffer_offset;
+		user_page_addr =
+			(uintptr_t)page_addr + proc->user_buffer_offset;
 		ret = vm_insert_page(vma, user_page_addr, page[0]);
 		if (ret) {
 			printk(KERN_ERR "binder: %d: binder_alloc_buf failed "
@@ -639,7 +645,7 @@
 	     page_addr -= PAGE_SIZE) {
 		page = &proc->pages[(page_addr - proc->buffer) / PAGE_SIZE];
 		if (vma)
-			zap_page_range(vma, (size_t)page_addr +
+			zap_page_range(vma, (uintptr_t)page_addr +
 				proc->user_buffer_offset, PAGE_SIZE, NULL);
 err_vm_insert_page_failed:
 		unmap_kernel_range((unsigned long)page_addr, PAGE_SIZE);
@@ -720,18 +726,19 @@
 		       "er %p size %zd\n", proc->pid, size, buffer, buffer_size);
 
 	has_page_addr =
-		(void *)(((size_t)buffer->data + buffer_size) & PAGE_MASK);
+		(void *)(((uintptr_t)buffer->data + buffer_size) & PAGE_MASK);
 	if (n == NULL) {
 		if (size + sizeof(struct binder_buffer) + 4 >= buffer_size)
 			buffer_size = size; /* no room for other buffers */
 		else
 			buffer_size = size + sizeof(struct binder_buffer);
 	}
-	end_page_addr = (void *)PAGE_ALIGN((size_t)buffer->data + buffer_size);
+	end_page_addr =
+		(void *)PAGE_ALIGN((uintptr_t)buffer->data + buffer_size);
 	if (end_page_addr > has_page_addr)
 		end_page_addr = has_page_addr;
 	if (binder_update_page_range(proc, 1,
-	    (void *)PAGE_ALIGN((size_t)buffer->data), end_page_addr, NULL))
+	    (void *)PAGE_ALIGN((uintptr_t)buffer->data), end_page_addr, NULL))
 		return NULL;
 
 	rb_erase(best_fit, &proc->free_buffers);
@@ -762,12 +769,12 @@
 
 static void *buffer_start_page(struct binder_buffer *buffer)
 {
-	return (void *)((size_t)buffer & PAGE_MASK);
+	return (void *)((uintptr_t)buffer & PAGE_MASK);
 }
 
 static void *buffer_end_page(struct binder_buffer *buffer)
 {
-	return (void *)(((size_t)(buffer + 1) - 1) & PAGE_MASK);
+	return (void *)(((uintptr_t)(buffer + 1) - 1) & PAGE_MASK);
 }
 
 static void binder_delete_free_buffer(
@@ -845,8 +852,8 @@
 	}
 
 	binder_update_page_range(proc, 0,
-		(void *)PAGE_ALIGN((size_t)buffer->data),
-		(void *)(((size_t)buffer->data + buffer_size) & PAGE_MASK),
+		(void *)PAGE_ALIGN((uintptr_t)buffer->data),
+		(void *)(((uintptr_t)buffer->data + buffer_size) & PAGE_MASK),
 		NULL);
 	rb_erase(&buffer->rb_node, &proc->allocated_buffers);
 	buffer->free = 1;
@@ -1345,6 +1352,17 @@
 		if (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {
 			struct binder_transaction *tmp;
 			tmp = thread->transaction_stack;
+			if (tmp->to_thread != thread) {
+				binder_user_error("binder: %d:%d got new "
+					"transaction with bad transaction stack"
+					", transaction %d has target %d:%d\n",
+					proc->pid, thread->pid, tmp->debug_id,
+					tmp->to_proc ? tmp->to_proc->pid : 0,
+					tmp->to_thread ?
+					tmp->to_thread->pid : 0);
+				return_error = BR_FAILED_REPLY;
+				goto err_bad_call_stack;
+			}
 			while (tmp) {
 				if (tmp->from && tmp->from->proc == target_proc)
 					target_thread = tmp->from;
@@ -1434,10 +1452,19 @@
 		return_error = BR_FAILED_REPLY;
 		goto err_copy_data_failed;
 	}
+	if (!IS_ALIGNED(tr->offsets_size, sizeof(size_t))) {
+		binder_user_error("binder: %d:%d got transaction with "
+			"invalid offsets size, %zd\n",
+			proc->pid, thread->pid, tr->offsets_size);
+		return_error = BR_FAILED_REPLY;
+		goto err_bad_offset;
+	}
 	off_end = (void *)offp + tr->offsets_size;
 	for (; offp < off_end; offp++) {
 		struct flat_binder_object *fp;
-		if (*offp > t->buffer->data_size - sizeof(*fp)) {
+		if (*offp > t->buffer->data_size - sizeof(*fp) ||
+		    t->buffer->data_size < sizeof(*fp) ||
+		    !IS_ALIGNED(*offp, sizeof(void *))) {
 			binder_user_error("binder: %d:%d got transaction with "
 				"invalid offset, %zd\n",
 				proc->pid, thread->pid, *offp);
@@ -1544,13 +1571,13 @@
 				return_error = BR_FAILED_REPLY;
 				goto err_fget_failed;
 			}
-			target_fd = task_get_unused_fd_flags(target_proc->tsk, O_CLOEXEC);
+			target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);
 			if (target_fd < 0) {
 				fput(file);
 				return_error = BR_FAILED_REPLY;
 				goto err_get_unused_fd_failed;
 			}
-			task_fd_install(target_proc->tsk, target_fd, file);
+			task_fd_install(target_proc, target_fd, file);
 			if (binder_debug_mask & BINDER_DEBUG_TRANSACTION)
 				printk(KERN_INFO "        fd %ld -> %d\n", fp->handle, target_fd);
 			/* TODO: fput? */
@@ -1655,7 +1682,9 @@
 		off_end = (void *)offp + buffer->offsets_size;
 	for (; offp < off_end; offp++) {
 		struct flat_binder_object *fp;
-		if (*offp > buffer->data_size - sizeof(*fp)) {
+		if (*offp > buffer->data_size - sizeof(*fp) ||
+		    buffer->data_size < sizeof(*fp) ||
+		    !IS_ALIGNED(*offp, sizeof(void *))) {
 			printk(KERN_ERR "binder: transaction release %d bad"
 					"offset %zd, size %zd\n", debug_id, *offp, buffer->data_size);
 			continue;
@@ -1691,7 +1720,7 @@
 			if (binder_debug_mask & BINDER_DEBUG_TRANSACTION)
 				printk(KERN_INFO "        fd %ld\n", fp->handle);
 			if (failed_at)
-				task_close_fd(proc->tsk, fp->handle);
+				task_close_fd(proc, fp->handle);
 			break;
 
 		default:
@@ -2340,7 +2369,7 @@
 
 		tr.data_size = t->buffer->data_size;
 		tr.offsets_size = t->buffer->offsets_size;
-		tr.data.ptr.buffer = (void *)((void *)t->buffer->data + proc->user_buffer_offset);
+		tr.data.ptr.buffer = (void *)t->buffer->data + proc->user_buffer_offset;
 		tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t->buffer->data_size, sizeof(void *));
 
 		if (put_user(cmd, (uint32_t __user *)ptr))
@@ -2656,6 +2685,7 @@
 			(unsigned long)pgprot_val(vma->vm_page_prot));
 	dump_stack();
 }
+
 static void binder_vma_close(struct vm_area_struct *vma)
 {
 	struct binder_proc *proc = vma->vm_private_data;
@@ -2666,6 +2696,7 @@
 			(vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,
 			(unsigned long)pgprot_val(vma->vm_page_prot));
 	proc->vma = NULL;
+	binder_defer_work(proc, BINDER_DEFERRED_PUT_FILES);
 }
 
 static struct vm_operations_struct binder_vm_ops = {
@@ -2698,6 +2729,12 @@
 	}
 	vma->vm_flags = (vma->vm_flags | VM_DONTCOPY) & ~VM_MAYWRITE;
 
+	if (proc->buffer) {
+		ret = -EBUSY;
+		failure_string = "already mapped";
+		goto err_already_mapped;
+	}
+
 	area = get_vm_area(vma->vm_end - vma->vm_start, VM_IOREMAP);
 	if (area == NULL) {
 		ret = -ENOMEM;
@@ -2705,7 +2742,7 @@
 		goto err_get_vm_area_failed;
 	}
 	proc->buffer = area->addr;
-	proc->user_buffer_offset = vma->vm_start - (size_t)proc->buffer;
+	proc->user_buffer_offset = vma->vm_start - (uintptr_t)proc->buffer;
 
 #ifdef CONFIG_CPU_CACHE_VIPT
 	if (cache_is_vipt_aliasing()) {
@@ -2738,6 +2775,7 @@
 	binder_insert_free_buffer(proc, buffer);
 	proc->free_async_space = proc->buffer_size / 2;
 	barrier();
+	proc->files = get_files_struct(current);
 	proc->vma = vma;
 
 	/*printk(KERN_INFO "binder_mmap: %d %lx-%lx maps %p\n", proc->pid, vma->vm_start, vma->vm_end, proc->buffer);*/
@@ -2745,10 +2783,12 @@
 
 err_alloc_small_buf_failed:
 	kfree(proc->pages);
+	proc->pages = NULL;
 err_alloc_pages_failed:
 	vfree(proc->buffer);
+	proc->buffer = NULL;
 err_get_vm_area_failed:
-	mutex_unlock(&binder_lock);
+err_already_mapped:
 err_bad_arg:
 	printk(KERN_ERR "binder_mmap: %d %lx-%lx %s failed %d\n", proc->pid, vma->vm_start, vma->vm_end, failure_string, ret);
 	return ret;
@@ -2780,6 +2820,7 @@
 	if (binder_proc_dir_entry_proc) {
 		char strbuf[11];
 		snprintf(strbuf, sizeof(strbuf), "%u", proc->pid);
+		remove_proc_entry(strbuf, binder_proc_dir_entry_proc);
 		create_proc_read_entry(strbuf, S_IRUGO, binder_proc_dir_entry_proc, binder_read_proc_proc, proc);
 	}
 
@@ -2788,11 +2829,17 @@
 
 static int binder_flush(struct file *filp, fl_owner_t id)
 {
-	struct rb_node *n;
 	struct binder_proc *proc = filp->private_data;
-	int wake_count = 0;
 
-	mutex_lock(&binder_lock);
+	binder_defer_work(proc, BINDER_DEFERRED_FLUSH);
+
+	return 0;
+}
+
+static void binder_deferred_flush(struct binder_proc *proc)
+{
+	struct rb_node *n;
+	int wake_count = 0;
 	for (n = rb_first(&proc->threads); n != NULL; n = rb_next(n)) {
 		struct binder_thread *thread = rb_entry(n, struct binder_thread, rb_node);
 		thread->looper |= BINDER_LOOPER_STATE_NEED_RETURN;
@@ -2802,28 +2849,35 @@
 		}
 	}
 	wake_up_interruptible_all(&proc->wait);
-	mutex_unlock(&binder_lock);
 
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
 		printk(KERN_INFO "binder_flush: %d woke %d threads\n", proc->pid, wake_count);
-
-	return 0;
 }
 
 static int binder_release(struct inode *nodp, struct file *filp)
 {
-	struct hlist_node *pos;
-	struct binder_transaction *t;
-	struct rb_node *n;
 	struct binder_proc *proc = filp->private_data;
-	int threads, nodes, incoming_refs, outgoing_refs, buffers, active_transactions, page_count;
-
 	if (binder_proc_dir_entry_proc) {
 		char strbuf[11];
 		snprintf(strbuf, sizeof(strbuf), "%u", proc->pid);
 		remove_proc_entry(strbuf, binder_proc_dir_entry_proc);
 	}
-	mutex_lock(&binder_lock);
+
+	binder_defer_work(proc, BINDER_DEFERRED_RELEASE);
+
+	return 0;
+}
+
+static void binder_deferred_release(struct binder_proc *proc)
+{
+	struct hlist_node *pos;
+	struct binder_transaction *t;
+	struct rb_node *n;
+	int threads, nodes, incoming_refs, outgoing_refs, buffers, active_transactions, page_count;
+
+	BUG_ON(proc->vma);
+	BUG_ON(proc->files);
+
 	hlist_del(&proc->proc_node);
 	if (binder_context_mgr_node && binder_context_mgr_node->proc == proc) {
 		if (binder_debug_mask & BINDER_DEBUG_DEAD_BINDER)
@@ -2897,7 +2951,6 @@
 	}
 
 	binder_stats.obj_deleted[BINDER_STAT_PROC]++;
-	mutex_unlock(&binder_lock);
 
 	page_count = 0;
 	if (proc->pages) {
@@ -2921,7 +2974,57 @@
 		       proc->pid, threads, nodes, incoming_refs, outgoing_refs, active_transactions, buffers, page_count);
 
 	kfree(proc);
-	return 0;
+}
+
+static void binder_deferred_func(struct work_struct *work)
+{
+	struct binder_proc *proc;
+	struct files_struct *files;
+
+	int defer;
+	do {
+		mutex_lock(&binder_lock);
+		mutex_lock(&binder_deferred_lock);
+		if (!hlist_empty(&binder_deferred_list)) {
+			proc = hlist_entry(binder_deferred_list.first,
+					struct binder_proc, deferred_work_node);
+			hlist_del_init(&proc->deferred_work_node);
+			defer = proc->deferred_work;
+			proc->deferred_work = 0;
+		} else {
+			proc = NULL;
+			defer = 0;
+		}
+		mutex_unlock(&binder_deferred_lock);
+
+		files = NULL;
+		if (defer & BINDER_DEFERRED_PUT_FILES)
+			if ((files = proc->files))
+				proc->files = NULL;
+
+		if (defer & BINDER_DEFERRED_FLUSH)
+			binder_deferred_flush(proc);
+
+		if (defer & BINDER_DEFERRED_RELEASE)
+			binder_deferred_release(proc); /* frees proc */
+
+		mutex_unlock(&binder_lock);
+		if (files)
+			put_files_struct(files);
+	} while (proc);
+}
+static DECLARE_WORK(binder_deferred_work, binder_deferred_func);
+
+static void binder_defer_work(struct binder_proc *proc, int defer)
+{
+	mutex_lock(&binder_deferred_lock);
+	proc->deferred_work |= defer;
+	if (hlist_unhashed(&proc->deferred_work_node)) {
+		hlist_add_head(&proc->deferred_work_node,
+				&binder_deferred_list);
+		schedule_work(&binder_deferred_work);
+	}
+	mutex_unlock(&binder_deferred_lock);
 }
 
 static char *print_binder_transaction(char *buf, char *end, const char *prefix, struct binder_transaction *t)
diff -urN linux-2.6.30-rc2/drivers/staging/at76_usb/at76_usb.c linux-2.6.30-rc3/drivers/staging/at76_usb/at76_usb.c
--- linux-2.6.30-rc2/drivers/staging/at76_usb/at76_usb.c	2009-04-22 03:29:11.515931403 +0000
+++ linux-2.6.30-rc3/drivers/staging/at76_usb/at76_usb.c	2009-04-22 03:29:17.560931435 +0000
@@ -5259,6 +5259,18 @@
 	return 0;
 }
 
+static const struct net_device_ops at76_netdev_ops = {
+	.ndo_open		= at76_open,
+	.ndo_stop		= at76_stop,
+	.ndo_get_stats		= at76_get_stats,
+	.ndo_start_xmit		= at76_tx,
+	.ndo_tx_timeout		= at76_tx_timeout,
+	.ndo_set_multicast_list	= at76_set_multicast,
+	.ndo_set_mac_address	= at76_set_mac_address,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 /* Register network device and initialize the hardware */
 static int at76_init_new_device(struct at76_priv *priv,
 				struct usb_interface *interface)
@@ -5303,21 +5315,15 @@
 	priv->scan_mode = SCAN_TYPE_ACTIVE;
 
 	netdev->flags &= ~IFF_MULTICAST;	/* not yet or never */
-	netdev->open = at76_open;
-	netdev->stop = at76_stop;
-	netdev->get_stats = at76_get_stats;
+	netdev->netdev_ops = &at76_netdev_ops;
 	netdev->ethtool_ops = &at76_ethtool_ops;
 
 	/* Add pointers to enable iwspy support. */
 	priv->wireless_data.spy_data = &priv->spy_data;
 	netdev->wireless_data = &priv->wireless_data;
 
-	netdev->hard_start_xmit = at76_tx;
-	netdev->tx_timeout = at76_tx_timeout;
 	netdev->watchdog_timeo = 2 * HZ;
 	netdev->wireless_handlers = &at76_handler_def;
-	netdev->set_multicast_list = at76_set_multicast;
-	netdev->set_mac_address = at76_set_mac_address;
 	dev_alloc_name(netdev, "wlan%d");
 
 	ret = register_netdev(priv->netdev);
diff -urN linux-2.6.30-rc2/drivers/staging/epl/VirtualEthernetLinux.c linux-2.6.30-rc3/drivers/staging/epl/VirtualEthernetLinux.c
--- linux-2.6.30-rc2/drivers/staging/epl/VirtualEthernetLinux.c	2009-04-22 03:29:11.634556310 +0000
+++ linux-2.6.30-rc3/drivers/staging/epl/VirtualEthernetLinux.c	2009-04-22 03:29:17.679931328 +0000
@@ -284,6 +284,17 @@
 	return Ret;
 }
 
+static const struct net_device_ops epl_netdev_ops = {
+	.ndo_open		= VEthOpen,
+	.ndo_stop		= VEthClose,
+	.ndo_get_stats		= VEthGetStats,
+	.ndo_start_xmit		= VEthXmit,
+	.ndo_tx_timeout		= VEthTimeout,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
 tEplKernel VEthAddInstance(tEplDllkInitParam *pInitParam_p)
 {
 	tEplKernel Ret = kEplSuccessful;
@@ -299,11 +310,7 @@
 		goto Exit;
 	}
 
-	pVEthNetDevice_g->open = VEthOpen;
-	pVEthNetDevice_g->stop = VEthClose;
-	pVEthNetDevice_g->get_stats = VEthGetStats;
-	pVEthNetDevice_g->hard_start_xmit = VEthXmit;
-	pVEthNetDevice_g->tx_timeout = VEthTimeout;
+	pVEthNetDevice_g->netdev_ops = &epl_netdev_ops;
 	pVEthNetDevice_g->watchdog_timeo = EPL_VETH_TX_TIMEOUT;
 	pVEthNetDevice_g->destructor = free_netdev;
 
diff -urN linux-2.6.30-rc2/drivers/staging/et131x/et131x_netdev.c linux-2.6.30-rc3/drivers/staging/et131x/et131x_netdev.c
--- linux-2.6.30-rc2/drivers/staging/et131x/et131x_netdev.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/et131x/et131x_netdev.c	2009-04-22 03:29:17.686931439 +0000
@@ -112,6 +112,19 @@
 void et131x_vlan_rx_add_vid(struct net_device *netdev, uint16_t vid);
 void et131x_vlan_rx_kill_vid(struct net_device *netdev, uint16_t vid);
 
+static const struct net_device_ops et131x_netdev_ops = {
+	.ndo_open		= et131x_open,
+	.ndo_stop		= et131x_close,
+	.ndo_start_xmit		= et131x_tx,
+	.ndo_set_multicast_list	= et131x_multicast,
+	.ndo_tx_timeout		= et131x_tx_timeout,
+	.ndo_change_mtu		= et131x_change_mtu,
+	.ndo_set_mac_address	= et131x_set_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_get_stats		= et131x_stats,
+	.ndo_do_ioctl		= et131x_ioctl,
+};
+
 /**
  * et131x_device_alloc
  *
@@ -142,16 +155,8 @@
 	 */
 	//netdev->init               = &et131x_init;
 	//netdev->set_config = &et131x_config;
-	netdev->get_stats = &et131x_stats;
-	netdev->open = &et131x_open;
-	netdev->stop = &et131x_close;
-	netdev->do_ioctl = &et131x_ioctl;
-	netdev->set_multicast_list = &et131x_multicast;
-	netdev->hard_start_xmit = &et131x_tx;
-	netdev->tx_timeout = &et131x_tx_timeout;
 	netdev->watchdog_timeo = ET131X_TX_TIMEOUT;
-	netdev->change_mtu = &et131x_change_mtu;
-	netdev->set_mac_address = &et131x_set_mac_addr;
+	netdev->netdev_ops = &et131x_netdev_ops;
 
 	//netdev->ethtool_ops        = &et131x_ethtool_ops;
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/go7007-driver.c linux-2.6.30-rc3/drivers/staging/go7007/go7007-driver.c
--- linux-2.6.30-rc2/drivers/staging/go7007/go7007-driver.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/go7007-driver.c	2009-04-22 03:29:17.688931427 +0000
@@ -191,8 +191,10 @@
 /*
  * Attempt to instantiate an I2C client by ID, probably loading a module.
  */
-static int init_i2c_module(struct i2c_adapter *adapter, int id, int addr)
+static int init_i2c_module(struct i2c_adapter *adapter, const char *type,
+			   int id, int addr)
 {
+	struct i2c_board_info info;
 	char *modname;
 
 	switch (id) {
@@ -226,7 +228,11 @@
 	}
 	if (modname != NULL)
 		request_module(modname);
-	if (wis_i2c_probe_device(adapter, id, addr) == 1)
+
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	info.addr = addr;
+	strlcpy(info.type, type, I2C_NAME_SIZE);
+	if (!i2c_new_device(adapter, &info))
 		return 0;
 	if (modname != NULL)
 		printk(KERN_INFO
@@ -266,23 +272,9 @@
 	if (go->i2c_adapter_online) {
 		for (i = 0; i < go->board_info->num_i2c_devs; ++i)
 			init_i2c_module(&go->i2c_adapter,
+					go->board_info->i2c_devs[i].type,
 					go->board_info->i2c_devs[i].id,
 					go->board_info->i2c_devs[i].addr);
-#ifdef TUNER_SET_TYPE_ADDR
-		if (go->tuner_type >= 0) {
-			struct tuner_setup tun_setup = {
-				.mode_mask	= T_ANALOG_TV,
-				.addr		= ADDR_UNSET,
-				.type		= go->tuner_type
-			};
-			i2c_clients_command(&go->i2c_adapter,
-				TUNER_SET_TYPE_ADDR, &tun_setup);
-		}
-#else
-		if (go->tuner_type >= 0)
-			i2c_clients_command(&go->i2c_adapter,
-				TUNER_SET_TYPE, &go->tuner_type);
-#endif
 		if (go->board_id == GO7007_BOARDID_ADLINK_MPG24)
 			i2c_clients_command(&go->i2c_adapter,
 				DECODER_SET_CHANNEL, &go->channel_number);
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/go7007-i2c.c linux-2.6.30-rc3/drivers/staging/go7007/go7007-i2c.c
--- linux-2.6.30-rc2/drivers/staging/go7007/go7007-i2c.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/go7007-i2c.c	2009-04-22 03:29:17.689931426 +0000
@@ -31,87 +31,6 @@
 #include "go7007-priv.h"
 #include "wis-i2c.h"
 
-/************** Registration interface for I2C client drivers **************/
-
-/* Since there's no way to auto-probe the I2C devices connected to the I2C
- * bus on the go7007, we have this silly little registration system that
- * client drivers can use to register their I2C driver ID and their
- * detect_client function (the one that's normally passed to i2c_probe).
- *
- * When a new go7007 device is connected, we can look up in a board info
- * table by the USB or PCI vendor/product/revision ID to determine
- * which I2C client module to load.  The client driver module will register
- * itself here, and then we can call the registered detect_client function
- * to force-load a new client at the address listed in the board info table.
- *
- * Really the I2C subsystem should have a way to force-load I2C client
- * drivers when we have a priori knowledge of what's on the bus, especially
- * since the existing I2C auto-probe mechanism is so hokey, but we'll use
- * our own mechanism for the time being. */
-
-struct wis_i2c_client_driver {
-	unsigned int id;
-	found_proc found_proc;
-	struct list_head list;
-};
-
-static LIST_HEAD(i2c_client_drivers);
-static DECLARE_MUTEX(i2c_client_driver_list_lock);
-
-/* Client drivers register here by their I2C driver ID */
-int wis_i2c_add_driver(unsigned int id, found_proc found_proc)
-{
-	struct wis_i2c_client_driver *driver;
-
-	driver = kmalloc(sizeof(struct wis_i2c_client_driver), GFP_KERNEL);
-	if (driver == NULL)
-		return -ENOMEM;
-	driver->id = id;
-	driver->found_proc = found_proc;
-
-	down(&i2c_client_driver_list_lock);
-	list_add_tail(&driver->list, &i2c_client_drivers);
-	up(&i2c_client_driver_list_lock);
-
-	return 0;
-}
-EXPORT_SYMBOL(wis_i2c_add_driver);
-
-void wis_i2c_del_driver(found_proc found_proc)
-{
-	struct wis_i2c_client_driver *driver, *next;
-
-	down(&i2c_client_driver_list_lock);
-	list_for_each_entry_safe(driver, next, &i2c_client_drivers, list)
-		if (driver->found_proc == found_proc) {
-			list_del(&driver->list);
-			kfree(driver);
-		}
-	up(&i2c_client_driver_list_lock);
-}
-EXPORT_SYMBOL(wis_i2c_del_driver);
-
-/* The main go7007 driver calls this to instantiate a client by driver
- * ID and bus address, which are both stored in the board info table */
-int wis_i2c_probe_device(struct i2c_adapter *adapter,
-				unsigned int id, int addr)
-{
-	struct wis_i2c_client_driver *driver;
-	int found = 0;
-
-	if (addr < 0 || addr > 0x7f)
-		return -1;
-	down(&i2c_client_driver_list_lock);
-	list_for_each_entry(driver, &i2c_client_drivers, list)
-		if (driver->id == id) {
-			if (driver->found_proc(adapter, addr, 0) == 0)
-				found = 1;
-			break;
-		}
-	up(&i2c_client_driver_list_lock);
-	return found;
-}
-
 /********************* Driver for on-board I2C adapter *********************/
 
 /* #define GO7007_I2C_DEBUG */
@@ -287,9 +206,7 @@
 
 static struct i2c_adapter go7007_adap_templ = {
 	.owner			= THIS_MODULE,
-	.class			= I2C_CLASS_TV_ANALOG,
 	.name			= "WIS GO7007SB",
-	.id			= I2C_ALGO_GO7007,
 	.algo			= &go7007_algo,
 };
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/go7007-priv.h linux-2.6.30-rc3/drivers/staging/go7007/go7007-priv.h
--- linux-2.6.30-rc2/drivers/staging/go7007/go7007-priv.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/go7007-priv.h	2009-04-22 03:29:17.689931426 +0000
@@ -87,6 +87,7 @@
 	int audio_main_div;
 	int num_i2c_devs;
 	struct {
+		const char *type;
 		int id;
 		int addr;
 	} i2c_devs[4];
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/go7007-usb.c linux-2.6.30-rc3/drivers/staging/go7007/go7007-usb.c
--- linux-2.6.30-rc2/drivers/staging/go7007/go7007-usb.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/go7007-usb.c	2009-04-22 03:29:17.689931426 +0000
@@ -91,6 +91,7 @@
 		.num_i2c_devs	 = 1,
 		.i2c_devs	 = {
 			{
+				.type	= "wis_saa7115",
 				.id	= I2C_DRIVERID_WIS_SAA7115,
 				.addr	= 0x20,
 			},
@@ -127,6 +128,7 @@
 		.num_i2c_devs	 = 1,
 		.i2c_devs	 = {
 			{
+				.type	= "wis_saa7113",
 				.id	= I2C_DRIVERID_WIS_SAA7113,
 				.addr	= 0x25,
 			},
@@ -164,6 +166,7 @@
 		.num_i2c_devs	 = 1,
 		.i2c_devs	 = {
 			{
+				.type	= "wis_saa7115",
 				.id	= I2C_DRIVERID_WIS_SAA7115,
 				.addr	= 0x20,
 			},
@@ -209,14 +212,17 @@
 		.num_i2c_devs	 = 3,
 		.i2c_devs	 = {
 			{
+				.type	= "wis_saa7115",
 				.id	= I2C_DRIVERID_WIS_SAA7115,
 				.addr	= 0x20,
 			},
 			{
+				.type	= "wis_uda1342",
 				.id	= I2C_DRIVERID_WIS_UDA1342,
 				.addr	= 0x1a,
 			},
 			{
+				.type	= "wis_sony_tuner",
 				.id	= I2C_DRIVERID_WIS_SONY_TUNER,
 				.addr	= 0x60,
 			},
@@ -264,6 +270,7 @@
 		.num_i2c_devs	  = 1,
 		.i2c_devs	  = {
 			{
+				.type	= "wis_ov7640",
 				.id	= I2C_DRIVERID_WIS_OV7640,
 				.addr	= 0x21,
 			},
@@ -296,6 +303,7 @@
 		.num_i2c_devs	 = 1,
 		.i2c_devs	 = {
 			{
+				.type	= "wis_tw9903",
 				.id	= I2C_DRIVERID_WIS_TW9903,
 				.addr	= 0x44,
 			},
@@ -385,6 +393,7 @@
 		.num_i2c_devs	 = 1,
 		.i2c_devs	 = {
 			{
+				.type	= "wis_twTW2804",
 				.id	= I2C_DRIVERID_WIS_TW2804,
 				.addr	= 0x00, /* yes, really */
 			},
@@ -415,8 +424,9 @@
 		.num_i2c_devs	 = 1,
 		.i2c_devs	 = {
 			{
+				.type	= "s2250_board",
 				.id	= I2C_DRIVERID_S2250,
-				.addr	= 0x34,
+				.addr	= 0x43,
 			},
 		},
 		.num_inputs	 = 2,
@@ -943,9 +953,7 @@
 
 static struct i2c_adapter go7007_usb_adap_templ = {
 	.owner			= THIS_MODULE,
-	.class			= I2C_CLASS_TV_ANALOG,
 	.name			= "WIS GO7007SB EZ-USB",
-	.id			= I2C_ALGO_GO7007_USB,
 	.algo			= &go7007_usb_algo,
 };
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/s2250-board.c linux-2.6.30-rc3/drivers/staging/go7007/s2250-board.c
--- linux-2.6.30-rc2/drivers/staging/go7007/s2250-board.c	2009-04-22 03:29:11.644931448 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/s2250-board.c	2009-04-22 03:29:17.690931473 +0000
@@ -28,7 +28,6 @@
 extern void s2250loader_cleanup(void);
 
 #define TLV320_ADDRESS      0x34
-#define S2250_VIDDEC        0x86
 #define VPX322_ADDR_ANALOGCONTROL1	0x02
 #define VPX322_ADDR_BRIGHTNESS0		0x0127
 #define VPX322_ADDR_BRIGHTNESS1		0x0131
@@ -123,6 +122,7 @@
 	int hue;
 	int reg12b_val;
 	int audio_input;
+	struct i2c_client *audio;
 };
 
 /* from go7007-usb.c which is Copyright (C) 2005-2006 Micronas USA Inc.*/
@@ -452,16 +452,15 @@
 	{
 		struct v4l2_audio *audio = arg;
 
-		client->addr = TLV320_ADDRESS;
 		switch (audio->index) {
 		case 0:
-			write_reg(client, 0x08, 0x02); /* Line In */
+			write_reg(dec->audio, 0x08, 0x02); /* Line In */
 			break;
 		case 1:
-			write_reg(client, 0x08, 0x04); /* Mic */
+			write_reg(dec->audio, 0x08, 0x04); /* Mic */
 			break;
 		case 2:
-			write_reg(client, 0x08, 0x05); /* Mic Boost */
+			write_reg(dec->audio, 0x08, 0x05); /* Mic Boost */
 			break;
 		default:
 			return -EINVAL;
@@ -477,31 +476,23 @@
 	return 0;
 }
 
-static struct i2c_driver s2250_driver;
-
-static struct i2c_client s2250_client_templ = {
-	.name		= "Sensoray 2250",
-	.driver		= &s2250_driver,
-};
-
-static int s2250_detect(struct i2c_adapter *adapter, int addr, int kind)
+static int s2250_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_client *audio;
+	struct i2c_adapter *adapter = client->adapter;
 	struct s2250 *dec;
 	u8 *data;
 	struct go7007 *go = i2c_get_adapdata(adapter);
 	struct go7007_usb *usb = go->hpi_context;
 
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
+	audio = i2c_new_dummy(adapter, TLV320_ADDRESS >> 1);
+	if (audio == NULL)
 		return -ENOMEM;
-	memcpy(client, &s2250_client_templ,
-	       sizeof(s2250_client_templ));
-	client->adapter = adapter;
 
 	dec = kmalloc(sizeof(struct s2250), GFP_KERNEL);
 	if (dec == NULL) {
-		kfree(client);
+		i2c_unregister_device(audio);
 		return -ENOMEM;
 	}
 
@@ -510,7 +501,7 @@
 	dec->contrast = 50;
 	dec->saturation = 50;
 	dec->hue = 0;
-	client->addr = TLV320_ADDRESS;
+	dec->audio = audio;
 	i2c_set_clientdata(client, dec);
 
 	printk(KERN_DEBUG
@@ -518,28 +509,25 @@
 	       adapter->name);
 
 	/* initialize the audio */
-	client->addr = TLV320_ADDRESS;
-	if (write_regs(client, aud_regs) < 0) {
+	if (write_regs(audio, aud_regs) < 0) {
 		printk(KERN_ERR
 		       "s2250: error initializing audio\n");
-		kfree(client);
+		i2c_unregister_device(audio);
 		kfree(dec);
 		return 0;
 	}
-	client->addr = S2250_VIDDEC;
-	i2c_set_clientdata(client, dec);
 
 	if (write_regs(client, vid_regs) < 0) {
 		printk(KERN_ERR
 		       "s2250: error initializing decoder\n");
-		kfree(client);
+		i2c_unregister_device(audio);
 		kfree(dec);
 		return 0;
 	}
 	if (write_regs_fp(client, vid_regs_fp) < 0) {
 		printk(KERN_ERR
 		       "s2250: error initializing decoder\n");
-		kfree(client);
+		i2c_unregister_device(audio);
 		kfree(dec);
 		return 0;
 	}
@@ -575,32 +563,33 @@
 		up(&usb->i2c_lock);
 	}
 
-	i2c_attach_client(client);
 	printk("s2250: initialized successfully\n");
 	return 0;
 }
 
-static int s2250_detach(struct i2c_client *client)
+static int s2250_remove(struct i2c_client *client)
 {
 	struct s2250 *dec = i2c_get_clientdata(client);
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
 
-	kfree(client);
+	i2c_set_clientdata(client, NULL);
+	i2c_unregister_device(dec->audio);
 	kfree(dec);
 	return 0;
 }
 
+static struct i2c_device_id s2250_id[] = {
+	{ "s2250_board", 0 },
+	{ }
+};
+
 static struct i2c_driver s2250_driver = {
 	.driver = {
 		.name	= "Sensoray 2250 board driver",
 	},
-	.id		= I2C_DRIVERID_S2250,
-	.detach_client	= s2250_detach,
+	.probe		= s2250_probe,
+	.remove		= s2250_remove,
 	.command	= s2250_command,
+	.id_table	= s2250_id,
 };
 
 static int __init s2250_init(void)
@@ -613,13 +602,13 @@
 
 	r = i2c_add_driver(&s2250_driver);
 	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(s2250_driver.id, s2250_detect);
+		s2250loader_cleanup();
+
+	return r;
 }
 
 static void __exit s2250_cleanup(void)
 {
-	wis_i2c_del_driver(s2250_detect);
 	i2c_del_driver(&s2250_driver);
 
 	s2250loader_cleanup();
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-i2c.h linux-2.6.30-rc3/drivers/staging/go7007/wis-i2c.h
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-i2c.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-i2c.h	2009-04-22 03:29:17.690931473 +0000
@@ -24,21 +24,12 @@
 #define	I2C_DRIVERID_WIS_OV7640		0xf0f5
 #define	I2C_DRIVERID_WIS_TW2804		0xf0f6
 #define	I2C_DRIVERID_S2250		0xf0f7
-#define	I2C_ALGO_GO7007			0xf00000
-#define	I2C_ALGO_GO7007_USB		0xf10000
 
 /* Flag to indicate that the client needs to be accessed with SCCB semantics */
 /* We re-use the I2C_M_TEN value so the flag passes through the masks in the
  * core I2C code.  Major kludge, but the I2C layer ain't exactly flexible. */
 #define	I2C_CLIENT_SCCB			0x10
 
-typedef int (*found_proc) (struct i2c_adapter *, int, int);
-int wis_i2c_add_driver(unsigned int id, found_proc found_proc);
-void wis_i2c_del_driver(found_proc found_proc);
-
-int wis_i2c_probe_device(struct i2c_adapter *adapter,
-				unsigned int id, int addr);
-
 /* Definitions for new video decoder commands */
 
 struct video_decoder_resolution {
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-ov7640.c linux-2.6.30-rc3/drivers/staging/go7007/wis-ov7640.c
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-ov7640.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-ov7640.c	2009-04-22 03:29:17.690931473 +0000
@@ -50,76 +50,54 @@
 	return 0;
 }
 
-static struct i2c_driver wis_ov7640_driver;
-
-static struct i2c_client wis_ov7640_client_templ = {
-	.name		= "OV7640 (WIS)",
-	.driver		= &wis_ov7640_driver,
-};
-
-static int wis_ov7640_detect(struct i2c_adapter *adapter, int addr, int kind)
+static int wis_ov7640_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_adapter *adapter = client->adapter;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
-		return 0;
+		return -ENODEV;
 
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-	memcpy(client, &wis_ov7640_client_templ,
-			sizeof(wis_ov7640_client_templ));
-	client->adapter = adapter;
-	client->addr = addr;
 	client->flags = I2C_CLIENT_SCCB;
 
 	printk(KERN_DEBUG
 		"wis-ov7640: initializing OV7640 at address %d on %s\n",
-		addr, adapter->name);
+		client->addr, adapter->name);
 
 	if (write_regs(client, initial_registers) < 0) {
 		printk(KERN_ERR "wis-ov7640: error initializing OV7640\n");
-		kfree(client);
-		return 0;
+		return -ENODEV;
 	}
 
-	i2c_attach_client(client);
 	return 0;
 }
 
-static int wis_ov7640_detach(struct i2c_client *client)
+static int wis_ov7640_remove(struct i2c_client *client)
 {
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
-
-	kfree(client);
 	return 0;
 }
 
+static struct i2c_device_id wis_ov7640_id[] = {
+	{ "wis_ov7640", 0 },
+	{ }
+};
+
 static struct i2c_driver wis_ov7640_driver = {
 	.driver = {
 		.name	= "WIS OV7640 I2C driver",
 	},
-	.id		= I2C_DRIVERID_WIS_OV7640,
-	.detach_client	= wis_ov7640_detach,
+	.probe		= wis_ov7640_probe,
+	.remove		= wis_ov7640_remove,
+	.id_table	= wis_ov7640_id,
 };
 
 static int __init wis_ov7640_init(void)
 {
-	int r;
-
-	r = i2c_add_driver(&wis_ov7640_driver);
-	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(wis_ov7640_driver.id, wis_ov7640_detect);
+	return i2c_add_driver(&wis_ov7640_driver);
 }
 
 static void __exit wis_ov7640_cleanup(void)
 {
-	wis_i2c_del_driver(wis_ov7640_detect);
 	i2c_del_driver(&wis_ov7640_driver);
 }
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-saa7113.c linux-2.6.30-rc3/drivers/staging/go7007/wis-saa7113.c
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-saa7113.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-saa7113.c	2009-04-22 03:29:17.690931473 +0000
@@ -261,34 +261,19 @@
 	return 0;
 }
 
-static struct i2c_driver wis_saa7113_driver;
-
-static struct i2c_client wis_saa7113_client_templ = {
-	.name		= "SAA7113 (WIS)",
-	.driver		= &wis_saa7113_driver,
-};
-
-static int wis_saa7113_detect(struct i2c_adapter *adapter, int addr, int kind)
+static int wis_saa7113_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_adapter *adapter = client->adapter;
 	struct wis_saa7113 *dec;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
-		return 0;
-
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-	memcpy(client, &wis_saa7113_client_templ,
-			sizeof(wis_saa7113_client_templ));
-	client->adapter = adapter;
-	client->addr = addr;
+		return -ENODEV;
 
 	dec = kmalloc(sizeof(struct wis_saa7113), GFP_KERNEL);
-	if (dec == NULL) {
-		kfree(client);
+	if (dec == NULL)
 		return -ENOMEM;
-	}
+
 	dec->norm = V4L2_STD_NTSC;
 	dec->brightness = 128;
 	dec->contrast = 71;
@@ -298,56 +283,49 @@
 
 	printk(KERN_DEBUG
 		"wis-saa7113: initializing SAA7113 at address %d on %s\n",
-		addr, adapter->name);
+		client->addr, adapter->name);
 
 	if (write_regs(client, initial_registers) < 0) {
 		printk(KERN_ERR
 			"wis-saa7113: error initializing SAA7113\n");
-		kfree(client);
 		kfree(dec);
-		return 0;
+		return -ENODEV;
 	}
 
-	i2c_attach_client(client);
 	return 0;
 }
 
-static int wis_saa7113_detach(struct i2c_client *client)
+static int wis_saa7113_remove(struct i2c_client *client)
 {
 	struct wis_saa7113 *dec = i2c_get_clientdata(client);
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
 
-	kfree(client);
+	i2c_set_clientdata(client, NULL);
 	kfree(dec);
 	return 0;
 }
 
+static struct i2c_device_id wis_saa7113_id[] = {
+	{ "wis_saa7113", 0 },
+	{ }
+};
+
 static struct i2c_driver wis_saa7113_driver = {
 	.driver = {
 		.name	= "WIS SAA7113 I2C driver",
 	},
-	.id		= I2C_DRIVERID_WIS_SAA7113,
-	.detach_client	= wis_saa7113_detach,
+	.probe		= wis_saa7113_probe,
+	.remove		= wis_saa7113_remove,
 	.command	= wis_saa7113_command,
+	.id_table	= wis_saa7113_id,
 };
 
 static int __init wis_saa7113_init(void)
 {
-	int r;
-
-	r = i2c_add_driver(&wis_saa7113_driver);
-	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(wis_saa7113_driver.id, wis_saa7113_detect);
+	return i2c_add_driver(&wis_saa7113_driver);
 }
 
 static void __exit wis_saa7113_cleanup(void)
 {
-	wis_i2c_del_driver(wis_saa7113_detect);
 	i2c_del_driver(&wis_saa7113_driver);
 }
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-saa7115.c linux-2.6.30-rc3/drivers/staging/go7007/wis-saa7115.c
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-saa7115.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-saa7115.c	2009-04-22 03:29:17.690931473 +0000
@@ -394,34 +394,19 @@
 	return 0;
 }
 
-static struct i2c_driver wis_saa7115_driver;
-
-static struct i2c_client wis_saa7115_client_templ = {
-	.name		= "SAA7115 (WIS)",
-	.driver		= &wis_saa7115_driver,
-};
-
-static int wis_saa7115_detect(struct i2c_adapter *adapter, int addr, int kind)
+static int wis_saa7115_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_adapter *adapter = client->adapter;
 	struct wis_saa7115 *dec;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
-		return 0;
-
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-	memcpy(client, &wis_saa7115_client_templ,
-			sizeof(wis_saa7115_client_templ));
-	client->adapter = adapter;
-	client->addr = addr;
+		return -ENODEV;
 
 	dec = kmalloc(sizeof(struct wis_saa7115), GFP_KERNEL);
-	if (dec == NULL) {
-		kfree(client);
+	if (dec == NULL)
 		return -ENOMEM;
-	}
+
 	dec->norm = V4L2_STD_NTSC;
 	dec->brightness = 128;
 	dec->contrast = 64;
@@ -431,56 +416,49 @@
 
 	printk(KERN_DEBUG
 		"wis-saa7115: initializing SAA7115 at address %d on %s\n",
-		addr, adapter->name);
+		client->addr, adapter->name);
 
 	if (write_regs(client, initial_registers) < 0) {
 		printk(KERN_ERR
 			"wis-saa7115: error initializing SAA7115\n");
-		kfree(client);
 		kfree(dec);
-		return 0;
+		return -ENODEV;
 	}
 
-	i2c_attach_client(client);
 	return 0;
 }
 
-static int wis_saa7115_detach(struct i2c_client *client)
+static int wis_saa7115_remove(struct i2c_client *client)
 {
 	struct wis_saa7115 *dec = i2c_get_clientdata(client);
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
 
-	kfree(client);
+	i2c_set_clientdata(client, NULL);
 	kfree(dec);
 	return 0;
 }
 
+static struct i2c_device_id wis_saa7115_id[] = {
+	{ "wis_saa7115", 0 },
+	{ }
+};
+
 static struct i2c_driver wis_saa7115_driver = {
 	.driver = {
 		.name	= "WIS SAA7115 I2C driver",
 	},
-	.id		= I2C_DRIVERID_WIS_SAA7115,
-	.detach_client	= wis_saa7115_detach,
+	.probe		= wis_saa7115_probe,
+	.remove		= wis_saa7115_remove,
 	.command	= wis_saa7115_command,
+	.id_table	= wis_saa7115_id,
 };
 
 static int __init wis_saa7115_init(void)
 {
-	int r;
-
-	r = i2c_add_driver(&wis_saa7115_driver);
-	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(wis_saa7115_driver.id, wis_saa7115_detect);
+	return i2c_add_driver(&wis_saa7115_driver);
 }
 
 static void __exit wis_saa7115_cleanup(void)
 {
-	wis_i2c_del_driver(wis_saa7115_detect);
 	i2c_del_driver(&wis_saa7115_driver);
 }
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-sony-tuner.c linux-2.6.30-rc3/drivers/staging/go7007/wis-sony-tuner.c
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-sony-tuner.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-sony-tuner.c	2009-04-22 03:29:17.691931453 +0000
@@ -386,6 +386,7 @@
 	struct wis_sony_tuner *t = i2c_get_clientdata(client);
 
 	switch (cmd) {
+#if 0
 #ifdef TUNER_SET_TYPE_ADDR
 	case TUNER_SET_TYPE_ADDR:
 	{
@@ -463,6 +464,7 @@
 				t->type, sony_tuners[t->type - 200].name);
 		break;
 	}
+#endif
 	case VIDIOC_G_FREQUENCY:
 	{
 		struct v4l2_frequency *f = arg;
@@ -651,35 +653,19 @@
 	return 0;
 }
 
-static struct i2c_driver wis_sony_tuner_driver;
-
-static struct i2c_client wis_sony_tuner_client_templ = {
-	.name		= "Sony TV Tuner (WIS)",
-	.driver		= &wis_sony_tuner_driver,
-};
-
-static int wis_sony_tuner_detect(struct i2c_adapter *adapter,
-					int addr, int kind)
+static int wis_sony_tuner_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_adapter *adapter = client->adapter;
 	struct wis_sony_tuner *t;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK))
-		return 0;
-
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-	memcpy(client, &wis_sony_tuner_client_templ,
-			sizeof(wis_sony_tuner_client_templ));
-	client->adapter = adapter;
-	client->addr = addr;
+		return -ENODEV;
 
 	t = kmalloc(sizeof(struct wis_sony_tuner), GFP_KERNEL);
-	if (t == NULL) {
-		kfree(client);
+	if (t == NULL)
 		return -ENOMEM;
-	}
+
 	t->type = -1;
 	t->freq = 0;
 	t->mpxmode = 0;
@@ -688,50 +674,42 @@
 
 	printk(KERN_DEBUG
 		"wis-sony-tuner: initializing tuner at address %d on %s\n",
-		addr, adapter->name);
-
-	i2c_attach_client(client);
+		client->addr, adapter->name);
 
 	return 0;
 }
 
-static int wis_sony_tuner_detach(struct i2c_client *client)
+static int wis_sony_tuner_remove(struct i2c_client *client)
 {
 	struct wis_sony_tuner *t = i2c_get_clientdata(client);
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
 
+	i2c_set_clientdata(client, NULL);
 	kfree(t);
-	kfree(client);
 	return 0;
 }
 
+static struct i2c_device_id wis_sony_tuner_id[] = {
+	{ "wis_sony_tuner", 0 },
+	{ }
+};
+
 static struct i2c_driver wis_sony_tuner_driver = {
 	.driver = {
 		.name	= "WIS Sony TV Tuner I2C driver",
 	},
-	.id		= I2C_DRIVERID_WIS_SONY_TUNER,
-	.detach_client	= wis_sony_tuner_detach,
+	.probe		= wis_sony_tuner_probe,
+	.remove		= wis_sony_tuner_remove,
 	.command	= tuner_command,
+	.id_table	= wis_sony_tuner_id,
 };
 
 static int __init wis_sony_tuner_init(void)
 {
-	int r;
-
-	r = i2c_add_driver(&wis_sony_tuner_driver);
-	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(wis_sony_tuner_driver.id,
-					wis_sony_tuner_detect);
+	return i2c_add_driver(&wis_sony_tuner_driver);
 }
 
 static void __exit wis_sony_tuner_cleanup(void)
 {
-	wis_i2c_del_driver(wis_sony_tuner_detect);
 	i2c_del_driver(&wis_sony_tuner_driver);
 }
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-tw2804.c linux-2.6.30-rc3/drivers/staging/go7007/wis-tw2804.c
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-tw2804.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-tw2804.c	2009-04-22 03:29:17.691931453 +0000
@@ -291,34 +291,19 @@
 	return 0;
 }
 
-static struct i2c_driver wis_tw2804_driver;
-
-static struct i2c_client wis_tw2804_client_templ = {
-	.name		= "TW2804 (WIS)",
-	.driver		= &wis_tw2804_driver,
-};
-
-static int wis_tw2804_detect(struct i2c_adapter *adapter, int addr, int kind)
+static int wis_tw2804_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_adapter *adapter = client->adapter;
 	struct wis_tw2804 *dec;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
-		return 0;
-
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-	memcpy(client, &wis_tw2804_client_templ,
-			sizeof(wis_tw2804_client_templ));
-	client->adapter = adapter;
-	client->addr = addr;
+		return -ENODEV;
 
 	dec = kmalloc(sizeof(struct wis_tw2804), GFP_KERNEL);
-	if (dec == NULL) {
-		kfree(client);
+	if (dec == NULL)
 		return -ENOMEM;
-	}
+
 	dec->channel = -1;
 	dec->norm = V4L2_STD_NTSC;
 	dec->brightness = 128;
@@ -328,48 +313,42 @@
 	i2c_set_clientdata(client, dec);
 
 	printk(KERN_DEBUG "wis-tw2804: creating TW2804 at address %d on %s\n",
-		addr, adapter->name);
+		client->addr, adapter->name);
 
-	i2c_attach_client(client);
 	return 0;
 }
 
-static int wis_tw2804_detach(struct i2c_client *client)
+static int wis_tw2804_remove(struct i2c_client *client)
 {
 	struct wis_tw2804 *dec = i2c_get_clientdata(client);
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
 
-	kfree(client);
+	i2c_set_clientdata(client, NULL);
 	kfree(dec);
 	return 0;
 }
 
+static struct i2c_device_id wis_tw2804_id[] = {
+	{ "wis_tw2804", 0 },
+	{ }
+};
+
 static struct i2c_driver wis_tw2804_driver = {
 	.driver = {
 		.name	= "WIS TW2804 I2C driver",
 	},
-	.id		= I2C_DRIVERID_WIS_TW2804,
-	.detach_client	= wis_tw2804_detach,
+	.probe		= wis_tw2804_probe,
+	.remove		= wis_tw2804_remove,
 	.command	= wis_tw2804_command,
+	.id_table	= wis_tw2804_id,
 };
 
 static int __init wis_tw2804_init(void)
 {
-	int r;
-
-	r = i2c_add_driver(&wis_tw2804_driver);
-	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(wis_tw2804_driver.id, wis_tw2804_detect);
+	return i2c_add_driver(&wis_tw2804_driver);
 }
 
 static void __exit wis_tw2804_cleanup(void)
 {
-	wis_i2c_del_driver(wis_tw2804_detect);
 	i2c_del_driver(&wis_tw2804_driver);
 }
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-tw9903.c linux-2.6.30-rc3/drivers/staging/go7007/wis-tw9903.c
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-tw9903.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-tw9903.c	2009-04-22 03:29:17.691931453 +0000
@@ -267,34 +267,19 @@
 	return 0;
 }
 
-static struct i2c_driver wis_tw9903_driver;
-
-static struct i2c_client wis_tw9903_client_templ = {
-	.name		= "TW9903 (WIS)",
-	.driver		= &wis_tw9903_driver,
-};
-
-static int wis_tw9903_detect(struct i2c_adapter *adapter, int addr, int kind)
+static int wis_tw9903_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_adapter *adapter = client->adapter;
 	struct wis_tw9903 *dec;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
-		return 0;
-
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-	memcpy(client, &wis_tw9903_client_templ,
-			sizeof(wis_tw9903_client_templ));
-	client->adapter = adapter;
-	client->addr = addr;
+		return -ENODEV;
 
 	dec = kmalloc(sizeof(struct wis_tw9903), GFP_KERNEL);
-	if (dec == NULL) {
-		kfree(client);
+	if (dec == NULL)
 		return -ENOMEM;
-	}
+
 	dec->norm = V4L2_STD_NTSC;
 	dec->brightness = 0;
 	dec->contrast = 0x60;
@@ -303,55 +288,48 @@
 
 	printk(KERN_DEBUG
 		"wis-tw9903: initializing TW9903 at address %d on %s\n",
-		addr, adapter->name);
+		client->addr, adapter->name);
 
 	if (write_regs(client, initial_registers) < 0) {
 		printk(KERN_ERR "wis-tw9903: error initializing TW9903\n");
-		kfree(client);
 		kfree(dec);
-		return 0;
+		return -ENODEV;
 	}
 
-	i2c_attach_client(client);
 	return 0;
 }
 
-static int wis_tw9903_detach(struct i2c_client *client)
+static int wis_tw9903_remove(struct i2c_client *client)
 {
 	struct wis_tw9903 *dec = i2c_get_clientdata(client);
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
 
-	kfree(client);
+	i2c_set_clientdata(client, NULL);
 	kfree(dec);
 	return 0;
 }
 
+static struct i2c_device_id wis_tw9903_id[] = {
+	{ "wis_tw9903", 0 },
+	{ }
+};
+
 static struct i2c_driver wis_tw9903_driver = {
 	.driver = {
 		.name	= "WIS TW9903 I2C driver",
 	},
-	.id		= I2C_DRIVERID_WIS_TW9903,
-	.detach_client	= wis_tw9903_detach,
+	.probe		= wis_tw9903_probe,
+	.remove		= wis_tw9903_remove,
 	.command	= wis_tw9903_command,
+	.id_table	= wis_tw9903_id,
 };
 
 static int __init wis_tw9903_init(void)
 {
-	int r;
-
-	r = i2c_add_driver(&wis_tw9903_driver);
-	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(wis_tw9903_driver.id, wis_tw9903_detect);
+	return i2c_add_driver(&wis_tw9903_driver);
 }
 
 static void __exit wis_tw9903_cleanup(void)
 {
-	wis_i2c_del_driver(wis_tw9903_detect);
 	i2c_del_driver(&wis_tw9903_driver);
 }
 
diff -urN linux-2.6.30-rc2/drivers/staging/go7007/wis-uda1342.c linux-2.6.30-rc3/drivers/staging/go7007/wis-uda1342.c
--- linux-2.6.30-rc2/drivers/staging/go7007/wis-uda1342.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/go7007/wis-uda1342.c	2009-04-22 03:29:17.691931453 +0000
@@ -59,73 +59,51 @@
 	return 0;
 }
 
-static struct i2c_driver wis_uda1342_driver;
-
-static struct i2c_client wis_uda1342_client_templ = {
-	.name		= "UDA1342 (WIS)",
-	.driver		= &wis_uda1342_driver,
-};
-
-static int wis_uda1342_detect(struct i2c_adapter *adapter, int addr, int kind)
+static int wis_uda1342_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
 {
-	struct i2c_client *client;
+	struct i2c_adapter *adapter = client->adapter;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))
-		return 0;
-
-	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-	memcpy(client, &wis_uda1342_client_templ,
-			sizeof(wis_uda1342_client_templ));
-	client->adapter = adapter;
-	client->addr = addr;
+		return -ENODEV;
 
 	printk(KERN_DEBUG
 		"wis-uda1342: initializing UDA1342 at address %d on %s\n",
-		addr, adapter->name);
+		client->addr, adapter->name);
 
 	write_reg(client, 0x00, 0x8000); /* reset registers */
 	write_reg(client, 0x00, 0x1241); /* select input 1 */
 
-	i2c_attach_client(client);
 	return 0;
 }
 
-static int wis_uda1342_detach(struct i2c_client *client)
+static int wis_uda1342_remove(struct i2c_client *client)
 {
-	int r;
-
-	r = i2c_detach_client(client);
-	if (r < 0)
-		return r;
-
-	kfree(client);
 	return 0;
 }
 
+static struct i2c_device_id wis_uda1342_id[] = {
+	{ "wis_uda1342", 0 },
+	{ }
+};
+
 static struct i2c_driver wis_uda1342_driver = {
 	.driver = {
 		.name	= "WIS UDA1342 I2C driver",
 	},
-	.id		= I2C_DRIVERID_WIS_UDA1342,
-	.detach_client	= wis_uda1342_detach,
+	.probe		= wis_uda1342_probe,
+	.remove		= wis_uda1342_remove,
 	.command	= wis_uda1342_command,
+	.id_table	= wis_uda1342_id,
 };
 
 static int __init wis_uda1342_init(void)
 {
-	int r;
-
-	r = i2c_add_driver(&wis_uda1342_driver);
-	if (r < 0)
-		return r;
-	return wis_i2c_add_driver(wis_uda1342_driver.id, wis_uda1342_detect);
+	return i2c_add_driver(&wis_uda1342_driver);
 }
 
 static void __exit wis_uda1342_cleanup(void)
 {
-	wis_i2c_del_driver(wis_uda1342_detect);
 	i2c_del_driver(&wis_uda1342_driver);
 }
 
diff -urN linux-2.6.30-rc2/drivers/staging/line6/audio.c linux-2.6.30-rc3/drivers/staging/line6/audio.c
--- linux-2.6.30-rc2/drivers/staging/line6/audio.c	2009-04-22 03:29:11.648931398 +0000
+++ linux-2.6.30-rc3/drivers/staging/line6/audio.c	2009-04-22 03:29:17.695931556 +0000
@@ -27,11 +27,12 @@
 {
 	static int dev;
 	struct snd_card *card;
+	int err;
 
-	card = snd_card_new(line6_index[dev], line6_id[dev], THIS_MODULE, 0);
-
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(line6_index[dev], line6_id[dev], THIS_MODULE, 0,
+			      &card);
+	if (err < 0)
+		return err;
 
 	line6->card = card;
 
diff -urN linux-2.6.30-rc2/drivers/staging/otus/usbdrv.c linux-2.6.30-rc3/drivers/staging/otus/usbdrv.c
--- linux-2.6.30-rc2/drivers/staging/otus/usbdrv.c	2009-04-22 03:29:11.674931236 +0000
+++ linux-2.6.30-rc3/drivers/staging/otus/usbdrv.c	2009-04-22 03:29:17.721931200 +0000
@@ -822,6 +822,21 @@
     return 0;
 }
 
+static const struct net_device_ops vap_netdev_ops = {
+	.ndo_open		= zfLnxVapOpen,
+	.ndo_stop		= zfLnxVapClose,
+	.ndo_start_xmit		= zfLnxVapXmitFrame,
+	.ndo_get_stats		= usbdrv_get_stats,
+	.ndo_change_mtu		= usbdrv_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+#ifdef ZM_HOSTAPD_SUPPORT
+	.ndo_do_ioctl		= usbdrv_ioctl,
+#else
+	.ndo_do_ioctl		= NULL,
+#endif
+};
+
 int zfLnxRegisterVapDev(struct net_device* parentDev, u16_t vapId)
 {
     /* Allocate net device structure */
@@ -846,16 +861,7 @@
     vap[vapId].dev->ml_priv = parentDev->ml_priv;
 
     //dev->hard_start_xmit = &zd1212_wds_xmit_frame;
-    vap[vapId].dev->hard_start_xmit = &zfLnxVapXmitFrame;
-    vap[vapId].dev->open = &zfLnxVapOpen;
-    vap[vapId].dev->stop = &zfLnxVapClose;
-    vap[vapId].dev->get_stats = &usbdrv_get_stats;
-    vap[vapId].dev->change_mtu = &usbdrv_change_mtu;
-#ifdef ZM_HOSTAPD_SUPPORT
-    vap[vapId].dev->do_ioctl = usbdrv_ioctl;
-#else
-    vap[vapId].dev->do_ioctl = NULL;
-#endif
+    vap[vapId].dev->netdev_ops = &vap_netdev_ops;
     vap[vapId].dev->destructor = free_netdev;
 
     vap[vapId].dev->tx_queue_len = 0;
@@ -1068,6 +1074,18 @@
     usb_unlink_urb(macp->RegInUrb);
 }
 
+static const struct net_device_ops otus_netdev_ops = {
+	.ndo_open		= usbdrv_open,
+	.ndo_stop		= usbdrv_close,
+	.ndo_start_xmit		= usbdrv_xmit_frame,
+	.ndo_change_mtu		= usbdrv_change_mtu,
+	.ndo_get_stats		= usbdrv_get_stats,
+	.ndo_set_multicast_list	= usbdrv_set_multi,
+	.ndo_set_mac_address	= usbdrv_set_mac,
+	.ndo_do_ioctl		= usbdrv_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
 u8_t zfLnxInitSetup(struct net_device *dev, struct usbdrv_private *macp)
 {
     //unsigned char addr[6];
@@ -1092,14 +1110,7 @@
     dev->wireless_handlers = (struct iw_handler_def *)&p80211wext_handler_def;
 #endif
 
-    dev->open = usbdrv_open;
-    dev->hard_start_xmit = usbdrv_xmit_frame;
-    dev->stop = usbdrv_close;
-    dev->change_mtu = &usbdrv_change_mtu;
-    dev->get_stats = usbdrv_get_stats;
-    dev->set_multicast_list = usbdrv_set_multi;
-    dev->set_mac_address = usbdrv_set_mac;
-    dev->do_ioctl = usbdrv_ioctl;
+    dev->netdev_ops = &otus_netdev_ops;
 
     dev->flags |= IFF_MULTICAST;
 
diff -urN linux-2.6.30-rc2/drivers/staging/otus/zdusb.c linux-2.6.30-rc3/drivers/staging/otus/zdusb.c
--- linux-2.6.30-rc2/drivers/staging/otus/zdusb.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/otus/zdusb.c	2009-04-22 03:29:17.722931471 +0000
@@ -48,7 +48,8 @@
 static struct usb_device_id zd1221_ids [] = {
 	{ USB_DEVICE(VENDOR_ATHR, PRODUCT_AR9170) },
         { USB_DEVICE(VENDOR_DLINK, PRODUCT_DWA160A) },
-	{ USB_DEVICE(0x0846, 0x9010) },
+	{ USB_DEVICE(VENDOR_NETGEAR, PRODUCT_WNDA3100) },
+	{ USB_DEVICE(VENDOR_NETGEAR, PRODUCT_WN111v2) },
 	{ }					/* Terminating entry */
 };
 
diff -urN linux-2.6.30-rc2/drivers/staging/otus/zdusb.h linux-2.6.30-rc3/drivers/staging/otus/zdusb.h
--- linux-2.6.30-rc2/drivers/staging/otus/zdusb.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/otus/zdusb.h	2009-04-22 03:29:17.722931471 +0000
@@ -40,4 +40,8 @@
 #define VENDOR_DLINK            0x07D1  //Dlink
 #define PRODUCT_DWA160A         0x3C10
 
+#define	VENDOR_NETGEAR		0x0846	/* NetGear */
+#define	PRODUCT_WNDA3100	0x9010
+#define	PRODUCT_WN111v2		0x9001
+
 #endif
diff -urN linux-2.6.30-rc2/drivers/staging/pohmelfs/config.c linux-2.6.30-rc3/drivers/staging/pohmelfs/config.c
--- linux-2.6.30-rc2/drivers/staging/pohmelfs/config.c	2009-04-22 03:29:11.676931384 +0000
+++ linux-2.6.30-rc3/drivers/staging/pohmelfs/config.c	2009-04-22 03:29:17.724556199 +0000
@@ -81,6 +81,45 @@
 	return g;
 }
 
+static inline void pohmelfs_insert_config_entry(struct pohmelfs_sb *psb, struct pohmelfs_config *dst)
+{
+	struct pohmelfs_config *tmp;
+
+	INIT_LIST_HEAD(&dst->config_entry);
+
+	list_for_each_entry(tmp, &psb->state_list, config_entry) {
+		if (dst->state.ctl.prio > tmp->state.ctl.prio)
+			list_add_tail(&dst->config_entry, &tmp->config_entry);
+	}
+	if (list_empty(&dst->config_entry))
+		list_add_tail(&dst->config_entry, &psb->state_list);
+}
+
+static int pohmelfs_move_config_entry(struct pohmelfs_sb *psb,
+		struct pohmelfs_config *dst, struct pohmelfs_config *new)
+{
+	if ((dst->state.ctl.prio == new->state.ctl.prio) &&
+		(dst->state.ctl.perm == new->state.ctl.perm))
+		return 0;
+
+	dprintk("%s: dst: prio: %d, perm: %x, new: prio: %d, perm: %d.\n",
+			__func__, dst->state.ctl.prio, dst->state.ctl.perm,
+			new->state.ctl.prio, new->state.ctl.perm);
+	dst->state.ctl.prio = new->state.ctl.prio;
+	dst->state.ctl.perm = new->state.ctl.perm;
+
+	list_del_init(&dst->config_entry);
+	pohmelfs_insert_config_entry(psb, dst);
+	return 0;
+}
+
+/*
+ * pohmelfs_copy_config() is used to copy new state configs from the
+ * config group (controlled by the netlink messages) into the superblock.
+ * This happens either at startup time where no transactions can access
+ * the list of the configs (and thus list of the network states), or at
+ * run-time, where it is protected by the psb->state_lock.
+ */
 int pohmelfs_copy_config(struct pohmelfs_sb *psb)
 {
 	struct pohmelfs_config_group *g;
@@ -103,7 +142,9 @@
 		err = 0;
 		list_for_each_entry(dst, &psb->state_list, config_entry) {
 			if (pohmelfs_config_eql(&dst->state.ctl, &c->state.ctl)) {
-				err = -EEXIST;
+				err = pohmelfs_move_config_entry(psb, dst, c);
+				if (!err)
+					err = -EEXIST;
 				break;
 			}
 		}
@@ -119,7 +160,7 @@
 
 		memcpy(&dst->state.ctl, &c->state.ctl, sizeof(struct pohmelfs_ctl));
 
-		list_add_tail(&dst->config_entry, &psb->state_list);
+		pohmelfs_insert_config_entry(psb, dst);
 
 		err = pohmelfs_state_init_one(psb, dst);
 		if (err) {
@@ -248,6 +289,13 @@
         return err;
 }
 
+static int pohmelfs_modify_config(struct pohmelfs_ctl *old, struct pohmelfs_ctl *new)
+{
+	old->perm = new->perm;
+	old->prio = new->prio;
+	return 0;
+}
+
 static int pohmelfs_cn_ctl(struct cn_msg *msg, int action)
 {
 	struct pohmelfs_config_group *g;
@@ -278,6 +326,9 @@
 				g->num_entry--;
 				kfree(c);
 				goto out_unlock;
+			} else if (action == POHMELFS_FLAGS_MODIFY) {
+				err = pohmelfs_modify_config(sc, ctl);
+				goto out_unlock;
 			} else {
 				err = -EEXIST;
 				goto out_unlock;
@@ -296,6 +347,7 @@
 	}
 	memcpy(&c->state.ctl, ctl, sizeof(struct pohmelfs_ctl));
 	g->num_entry++;
+
 	list_add_tail(&c->config_entry, &g->config_list);
 
 out_unlock:
@@ -401,10 +453,9 @@
 
 	switch (msg->flags) {
 		case POHMELFS_FLAGS_ADD:
-			err = pohmelfs_cn_ctl(msg, POHMELFS_FLAGS_ADD);
-			break;
 		case POHMELFS_FLAGS_DEL:
-			err = pohmelfs_cn_ctl(msg, POHMELFS_FLAGS_DEL);
+		case POHMELFS_FLAGS_MODIFY:
+			err = pohmelfs_cn_ctl(msg, msg->flags);
 			break;
 		case POHMELFS_FLAGS_SHOW:
 			err = pohmelfs_cn_disp(msg);
diff -urN linux-2.6.30-rc2/drivers/staging/pohmelfs/dir.c linux-2.6.30-rc3/drivers/staging/pohmelfs/dir.c
--- linux-2.6.30-rc2/drivers/staging/pohmelfs/dir.c	2009-04-22 03:29:11.677931437 +0000
+++ linux-2.6.30-rc3/drivers/staging/pohmelfs/dir.c	2009-04-22 03:29:17.724556199 +0000
@@ -328,7 +328,7 @@
 {
 	struct inode *inode = &pi->vfs_inode;
 	struct pohmelfs_sb *psb = POHMELFS_SB(inode->i_sb);
-	long ret = msecs_to_jiffies(25000);
+	long ret = psb->wait_on_page_timeout;
 	int err;
 
 	dprintk("%s: dir: %llu, state: %lx: remote_synced: %d.\n",
@@ -389,11 +389,11 @@
 	dprintk("%s: parent: %llu, fpos: %llu, hash: %08lx.\n",
 			__func__, pi->ino, (u64)file->f_pos,
 			(unsigned long)file->private_data);
-
+#if 0
 	err = pohmelfs_data_lock(pi, 0, ~0, POHMELFS_READ_LOCK);
 	if (err)
 		return err;
-
+#endif
 	err = pohmelfs_sync_remote_dir(pi);
 	if (err)
 		return err;
@@ -513,10 +513,6 @@
 
 	need_lock = pohmelfs_need_lock(parent, lock_type);
 
-	err = pohmelfs_data_lock(parent, 0, ~0, lock_type);
-	if (err)
-		goto out;
-
 	str.hash = jhash(dentry->d_name.name, dentry->d_name.len, 0);
 
 	mutex_lock(&parent->offset_lock);
@@ -525,8 +521,8 @@
 		ino = n->ino;
 	mutex_unlock(&parent->offset_lock);
 
-	dprintk("%s: 1 ino: %lu, inode: %p, name: '%s', hash: %x, parent_state: %lx.\n",
-			__func__, ino, inode, str.name, str.hash, parent->state);
+	dprintk("%s: start ino: %lu, inode: %p, name: '%s', hash: %x, parent_state: %lx, need_lock: %d.\n",
+			__func__, ino, inode, str.name, str.hash, parent->state, need_lock);
 
 	if (ino) {
 		inode = ilookup(dir->i_sb, ino);
@@ -534,7 +530,7 @@
 			goto out;
 	}
 
-	dprintk("%s: dir: %p, dir_ino: %llu, name: '%s', len: %u, dir_state: %lx, ino: %lu.\n",
+	dprintk("%s: no inode dir: %p, dir_ino: %llu, name: '%s', len: %u, dir_state: %lx, ino: %lu.\n",
 			__func__, dir, parent->ino,
 			str.name, str.len, parent->state, ino);
 
@@ -543,6 +539,10 @@
 			goto out;
 	}
 
+	err = pohmelfs_data_lock(parent, 0, ~0, lock_type);
+	if (err)
+		goto out;
+
 	err = pohmelfs_lookup_single(parent, &str, ino);
 	if (err)
 		goto out;
@@ -557,10 +557,10 @@
 
 	if (ino) {
 		inode = ilookup(dir->i_sb, ino);
-		printk("%s: second lookup ino: %lu, inode: %p, name: '%s', hash: %x.\n",
+		dprintk("%s: second lookup ino: %lu, inode: %p, name: '%s', hash: %x.\n",
 				__func__, ino, inode, str.name, str.hash);
 		if (!inode) {
-			printk("%s: No inode for ino: %lu, name: '%s', hash: %x.\n",
+			dprintk("%s: No inode for ino: %lu, name: '%s', hash: %x.\n",
 				__func__, ino, str.name, str.hash);
 			//return NULL;
 			return ERR_PTR(-EACCES);
diff -urN linux-2.6.30-rc2/drivers/staging/pohmelfs/inode.c linux-2.6.30-rc3/drivers/staging/pohmelfs/inode.c
--- linux-2.6.30-rc2/drivers/staging/pohmelfs/inode.c	2009-04-22 03:29:11.677931437 +0000
+++ linux-2.6.30-rc3/drivers/staging/pohmelfs/inode.c	2009-04-22 03:29:17.725931270 +0000
@@ -1169,16 +1169,17 @@
 static int pohmelfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct inode *inode = dentry->d_inode;
+#if 0
 	struct pohmelfs_inode *pi = POHMELFS_I(inode);
 	int err;
 
 	err = pohmelfs_data_lock(pi, 0, ~0, POHMELFS_READ_LOCK);
 	if (err)
 		return err;
-
 	dprintk("%s: ino: %llu, mode: %o, uid: %u, gid: %u, size: %llu.\n",
 			__func__, pi->ino, inode->i_mode, inode->i_uid,
 			inode->i_gid, inode->i_size);
+#endif
 
 	generic_fillattr(inode, stat);
 	return 0;
@@ -1342,14 +1343,6 @@
 
 	kfree(psb);
 	sb->s_fs_info = NULL;
-
-	pohmelfs_ftrans_exit();
-}
-
-static int pohmelfs_remount(struct super_block *sb, int *flags, char *data)
-{
-	*flags |= MS_RDONLY;
-	return 0;
 }
 
 static int pohmelfs_statfs(struct dentry *dentry, struct kstatfs *buf)
@@ -1394,42 +1387,33 @@
 	return 0;
 }
 
-static const struct super_operations pohmelfs_sb_ops = {
-	.alloc_inode	= pohmelfs_alloc_inode,
-	.destroy_inode	= pohmelfs_destroy_inode,
-	.drop_inode	= pohmelfs_drop_inode,
-	.write_inode	= pohmelfs_write_inode,
-	.put_super	= pohmelfs_put_super,
-	.remount_fs	= pohmelfs_remount,
-	.statfs		= pohmelfs_statfs,
-	.show_options	= pohmelfs_show_options,
-};
-
 enum {
 	pohmelfs_opt_idx,
+	pohmelfs_opt_crypto_thread_num,
+	pohmelfs_opt_trans_max_pages,
+	pohmelfs_opt_crypto_fail_unsupported,
+
+	/* Remountable options */
 	pohmelfs_opt_trans_scan_timeout,
 	pohmelfs_opt_drop_scan_timeout,
 	pohmelfs_opt_wait_on_page_timeout,
 	pohmelfs_opt_trans_retries,
-	pohmelfs_opt_crypto_thread_num,
-	pohmelfs_opt_trans_max_pages,
-	pohmelfs_opt_crypto_fail_unsupported,
 	pohmelfs_opt_mcache_timeout,
 };
 
 static struct match_token pohmelfs_tokens[] = {
 	{pohmelfs_opt_idx, "idx=%u"},
+	{pohmelfs_opt_crypto_thread_num, "crypto_thread_num=%u"},
+	{pohmelfs_opt_trans_max_pages, "trans_max_pages=%u"},
+	{pohmelfs_opt_crypto_fail_unsupported, "crypto_fail_unsupported"},
 	{pohmelfs_opt_trans_scan_timeout, "trans_scan_timeout=%u"},
 	{pohmelfs_opt_drop_scan_timeout, "drop_scan_timeout=%u"},
 	{pohmelfs_opt_wait_on_page_timeout, "wait_on_page_timeout=%u"},
 	{pohmelfs_opt_trans_retries, "trans_retries=%u"},
-	{pohmelfs_opt_crypto_thread_num, "crypto_thread_num=%u"},
-	{pohmelfs_opt_trans_max_pages, "trans_max_pages=%u"},
-	{pohmelfs_opt_crypto_fail_unsupported, "crypto_fail_unsupported"},
 	{pohmelfs_opt_mcache_timeout, "mcache_timeout=%u"},
 };
 
-static int pohmelfs_parse_options(char *options, struct pohmelfs_sb *psb)
+static int pohmelfs_parse_options(char *options, struct pohmelfs_sb *psb, int remount)
 {
 	char *p;
 	substring_t args[MAX_OPT_ARGS];
@@ -1449,6 +1433,9 @@
 		if (err)
 			return err;
 
+		if (remount && token <= pohmelfs_opt_crypto_fail_unsupported)
+			continue;
+
 		switch (token) {
 			case pohmelfs_opt_idx:
 				psb->idx = option;
@@ -1485,6 +1472,25 @@
 	return 0;
 }
 
+static int pohmelfs_remount(struct super_block *sb, int *flags, char *data)
+{
+	int err;
+	struct pohmelfs_sb *psb = POHMELFS_SB(sb);
+	unsigned long old_sb_flags = sb->s_flags;
+
+	err = pohmelfs_parse_options(data, psb, 1);
+	if (err)
+		goto err_out_restore;
+
+	if (!(*flags & MS_RDONLY))
+		sb->s_flags &= ~MS_RDONLY;
+	return 0;
+
+err_out_restore:
+	sb->s_flags = old_sb_flags;
+	return err;
+}
+
 static void pohmelfs_flush_inode(struct pohmelfs_inode *pi, unsigned int count)
 {
 	struct inode *inode = &pi->vfs_inode;
@@ -1753,6 +1759,57 @@
 	return err;
 }
 
+static int pohmelfs_show_stats(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct netfs_state *st;
+	struct pohmelfs_ctl *ctl;
+	struct pohmelfs_sb *psb = POHMELFS_SB(mnt->mnt_sb);
+	struct pohmelfs_config *c;
+
+	mutex_lock(&psb->state_lock);
+
+	seq_printf(m, "\nidx addr(:port) socket_type protocol active priority permissions\n");
+
+	list_for_each_entry(c, &psb->state_list, config_entry) {
+		st = &c->state;
+		ctl = &st->ctl;
+
+		seq_printf(m, "%u ", ctl->idx);
+		if (ctl->addr.sa_family == AF_INET) {
+			struct sockaddr_in *sin = (struct sockaddr_in *)&st->ctl.addr;
+			//seq_printf(m, "%pi4:%u", &sin->sin_addr.s_addr, ntohs(sin->sin_port));
+			seq_printf(m, "%u.%u.%u.%u:%u", NIPQUAD(sin->sin_addr.s_addr), ntohs(sin->sin_port));
+		} else if (ctl->addr.sa_family == AF_INET6) {
+			struct sockaddr_in6 *sin = (struct sockaddr_in6 *)&st->ctl.addr;
+			seq_printf(m, "%pi6:%u", &sin->sin6_addr, ntohs(sin->sin6_port));
+		} else {
+			unsigned int i;
+			for (i=0; i<ctl->addrlen; ++i)
+				seq_printf(m, "%02x.", ctl->addr.addr[i]);
+		}
+
+		seq_printf(m, " %u %u %d %u %x\n",
+				ctl->type, ctl->proto,
+				st->socket != NULL,
+				ctl->prio, ctl->perm);
+	}
+	mutex_unlock(&psb->state_lock);
+
+	return 0;
+}
+
+static const struct super_operations pohmelfs_sb_ops = {
+	.alloc_inode	= pohmelfs_alloc_inode,
+	.destroy_inode	= pohmelfs_destroy_inode,
+	.drop_inode	= pohmelfs_drop_inode,
+	.write_inode	= pohmelfs_write_inode,
+	.put_super	= pohmelfs_put_super,
+	.remount_fs	= pohmelfs_remount,
+	.statfs		= pohmelfs_statfs,
+	.show_options	= pohmelfs_show_options,
+	.show_stats	= pohmelfs_show_stats,
+};
+
 /*
  * Allocate private superblock and create root dir.
  */
@@ -1764,8 +1821,6 @@
 	struct pohmelfs_inode *npi;
 	struct qstr str;
 
-	pohmelfs_ftrans_init();
-
 	psb = kzalloc(sizeof(struct pohmelfs_sb), GFP_KERNEL);
 	if (!psb)
 		goto err_out_exit;
@@ -1816,7 +1871,7 @@
 	mutex_init(&psb->state_lock);
 	INIT_LIST_HEAD(&psb->state_list);
 
-	err = pohmelfs_parse_options((char *) data, psb);
+	err = pohmelfs_parse_options((char *) data, psb, 0);
 	if (err)
 		goto err_out_free_sb;
 
@@ -1845,6 +1900,8 @@
 		err = PTR_ERR(npi);
 		goto err_out_crypto_exit;
 	}
+	set_bit(NETFS_INODE_REMOTE_SYNCED, &npi->state);
+	clear_bit(NETFS_INODE_OWNED, &npi->state);
 
 	root = &npi->vfs_inode;
 
@@ -1887,11 +1944,29 @@
 				mnt);
 }
 
+/*
+ * We need this to sync all inodes earlier, since when writeback
+ * is invoked from the umount/mntput path dcache is already shrunk,
+ * see generic_shutdown_super(), and no inodes can access the path.
+ */
+static void pohmelfs_kill_super(struct super_block *sb)
+{
+	struct writeback_control wbc = {
+		.sync_mode	= WB_SYNC_ALL,
+		.range_start	= 0,
+		.range_end	= LLONG_MAX,
+		.nr_to_write	= LONG_MAX,
+	};
+	generic_sync_sb_inodes(sb, &wbc);
+
+	kill_anon_super(sb);
+}
+
 static struct file_system_type pohmel_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "pohmel",
 	.get_sb		= pohmelfs_get_sb,
-	.kill_sb 	= kill_anon_super,
+	.kill_sb 	= pohmelfs_kill_super,
 };
 
 /*
diff -urN linux-2.6.30-rc2/drivers/staging/pohmelfs/lock.c linux-2.6.30-rc3/drivers/staging/pohmelfs/lock.c
--- linux-2.6.30-rc2/drivers/staging/pohmelfs/lock.c	2009-04-22 03:29:11.678931222 +0000
+++ linux-2.6.30-rc3/drivers/staging/pohmelfs/lock.c	2009-04-22 03:29:17.725931270 +0000
@@ -41,7 +41,8 @@
 	path_len = err;
 
 	err = -ENOMEM;
-	t = netfs_trans_alloc(psb, path_len + sizeof(struct netfs_lock) + isize, 0, 0);
+	t = netfs_trans_alloc(psb, path_len + sizeof(struct netfs_lock) + isize,
+			NETFS_TRANS_SINGLE_DST, 0);
 	if (!t)
 		goto err_out_exit;
 
diff -urN linux-2.6.30-rc2/drivers/staging/pohmelfs/net.c linux-2.6.30-rc3/drivers/staging/pohmelfs/net.c
--- linux-2.6.30-rc2/drivers/staging/pohmelfs/net.c	2009-04-22 03:29:11.678931222 +0000
+++ linux-2.6.30-rc3/drivers/staging/pohmelfs/net.c	2009-04-22 03:29:17.726931418 +0000
@@ -26,55 +26,6 @@
 
 #include "netfs.h"
 
-static int pohmelfs_ftrans_size = 10240;
-static u32 *pohmelfs_ftrans;
-
-int pohmelfs_ftrans_init(void)
-{
-	pohmelfs_ftrans = vmalloc(pohmelfs_ftrans_size * 4);
-	if (!pohmelfs_ftrans)
-		return -ENOMEM;
-
-	return 0;
-}
-
-void pohmelfs_ftrans_exit(void)
-{
-	vfree(pohmelfs_ftrans);
-}
-
-void pohmelfs_ftrans_clean(u64 id)
-{
-	if (pohmelfs_ftrans) {
-		u32 i = id & 0xffffffff;
-		int idx = i % pohmelfs_ftrans_size;
-
-		pohmelfs_ftrans[idx] = 0;
-	}
-}
-
-void pohmelfs_ftrans_update(u64 id)
-{
-	if (pohmelfs_ftrans) {
-		u32 i = id & 0xffffffff;
-		int idx = i % pohmelfs_ftrans_size;
-
-		pohmelfs_ftrans[idx] = i;
-	}
-}
-
-int pohmelfs_ftrans_check(u64 id)
-{
-	if (pohmelfs_ftrans) {
-		u32 i = id & 0xffffffff;
-		int idx = i % pohmelfs_ftrans_size;
-
-		return (pohmelfs_ftrans[idx] == i);
-	}
-
-	return -1;
-}
-
 /*
  * Async machinery lives here.
  * All commands being sent to server do _not_ require sync reply,
@@ -450,8 +401,24 @@
 			if (err != -EEXIST)
 				goto err_out_put;
 		} else {
+			struct dentry *dentry, *alias, *pd;
+
 			set_bit(NETFS_INODE_REMOTE_SYNCED, &npi->state);
 			clear_bit(NETFS_INODE_OWNED, &npi->state);
+
+			pd = d_find_alias(&parent->vfs_inode);
+			if (pd) {
+				str.hash = full_name_hash(str.name, str.len);
+				dentry = d_alloc(pd, &str);
+				if (dentry) {
+					alias = d_materialise_unique(dentry, &npi->vfs_inode);
+					if (alias)
+						dput(dentry);
+				}
+
+				dput(dentry);
+				dput(pd);
+			}
 		}
 	}
 out:
@@ -638,15 +605,12 @@
 	if (dst) {
 		netfs_trans_remove_nolock(dst, st);
 		t = dst->trans;
-
-		pohmelfs_ftrans_update(cmd->start);
 	}
 	mutex_unlock(&st->trans_lock);
 
 	if (!t) {
-		int check = pohmelfs_ftrans_check(cmd->start);
-		printk("%s: failed to find transaction: start: %llu: id: %llu, size: %u, ext: %u, double: %d.\n",
-				__func__, cmd->start, cmd->id, cmd->size, cmd->ext, check);
+		printk("%s: failed to find transaction: start: %llu: id: %llu, size: %u, ext: %u.\n",
+				__func__, cmd->start, cmd->id, cmd->size, cmd->ext);
 		err = -EINVAL;
 		goto out;
 	}
diff -urN linux-2.6.30-rc2/drivers/staging/pohmelfs/netfs.h linux-2.6.30-rc3/drivers/staging/pohmelfs/netfs.h
--- linux-2.6.30-rc2/drivers/staging/pohmelfs/netfs.h	2009-04-22 03:29:11.679837796 +0000
+++ linux-2.6.30-rc3/drivers/staging/pohmelfs/netfs.h	2009-04-22 03:29:17.726931418 +0000
@@ -87,6 +87,7 @@
 	POHMELFS_FLAGS_DEL,     /* Network state control message for DEL */
 	POHMELFS_FLAGS_SHOW,    /* Network state control message for SHOW */
 	POHMELFS_FLAGS_CRYPTO,	/* Crypto data control message */
+	POHMELFS_FLAGS_MODIFY,	/* Network state modification message */
 };
 
 /*
@@ -116,16 +117,20 @@
 	unsigned char		data[0];	/* Algorithm string, key and IV */
 };
 
+#define POHMELFS_IO_PERM_READ		(1<<0)
+#define POHMELFS_IO_PERM_WRITE		(1<<1)
+
 /*
  * Configuration command used to create table of different remote servers.
  */
 struct pohmelfs_ctl
 {
-	unsigned int		idx;		/* Config index */
-	unsigned int		type;		/* Socket type */
-	unsigned int		proto;		/* Socket protocol */
-	unsigned int		addrlen;	/* Size of the address */
-	unsigned short		unused;		/* Align structure by 4 bytes */
+	__u32			idx;		/* Config index */
+	__u32			type;		/* Socket type */
+	__u32			proto;		/* Socket protocol */
+	__u16			addrlen;	/* Size of the address */
+	__u16			perm;		/* IO permission */
+	__u16			prio;		/* IO priority */
 	struct saddr		addr;		/* Remote server address */
 };
 
@@ -921,12 +926,6 @@
 		pohmelfs_mcache_free(psb, m);
 }
 
-int pohmelfs_ftrans_init(void);
-void pohmelfs_ftrans_exit(void);
-void pohmelfs_ftrans_update(u64 id);
-int pohmelfs_ftrans_check(u64 id);
-void pohmelfs_ftrans_clean(u64 id);
-
 #endif /* __KERNEL__*/
 
 #endif /* __NETFS_H */
diff -urN linux-2.6.30-rc2/drivers/staging/pohmelfs/trans.c linux-2.6.30-rc3/drivers/staging/pohmelfs/trans.c
--- linux-2.6.30-rc2/drivers/staging/pohmelfs/trans.c	2009-04-22 03:29:11.679837796 +0000
+++ linux-2.6.30-rc3/drivers/staging/pohmelfs/trans.c	2009-04-22 03:29:17.727931411 +0000
@@ -456,34 +456,25 @@
 		__func__, t, t->gen, t->iovec.iov_len, t->page_num, psb->active_state);
 #endif
 	mutex_lock(&psb->state_lock);
+	list_for_each_entry(c, &psb->state_list, config_entry) {
+		st = &c->state;
 
-	if ((t->flags & NETFS_TRANS_SINGLE_DST) && psb->active_state) {
-		st = &psb->active_state->state;
-
-		err = -EPIPE;
-		if (netfs_state_poll(st) & POLLOUT) {
-			err = netfs_trans_push_dst(t, st);
-			if (!err) {
-				err = netfs_trans_send(t, st);
-				if (err) {
-					netfs_trans_drop_last(t, st);
-				} else {
-					pohmelfs_switch_active(psb);
-					goto out;
-				}
-			}
+		if (t->flags & NETFS_TRANS_SINGLE_DST) {
+			if (!(st->ctl.perm & POHMELFS_IO_PERM_READ))
+				continue;
+		} else {
+			if (!(st->ctl.perm & POHMELFS_IO_PERM_WRITE))
+				continue;
 		}
-		pohmelfs_switch_active(psb);
-	}
 
-	list_for_each_entry(c, &psb->state_list, config_entry) {
-		st = &c->state;
+		if (psb->active_state && (psb->active_state->state.ctl.prio >= st->ctl.prio))
+			st = &psb->active_state->state;
 
 		err = netfs_trans_push(t, st);
 		if (!err && (t->flags & NETFS_TRANS_SINGLE_DST))
 			break;
 	}
-out:
+
 	mutex_unlock(&psb->state_lock);
 #if 0
 	dprintk("%s: fully sent t: %p, gen: %u, size: %u, page_num: %u, err: %d.\n",
@@ -501,8 +492,6 @@
 
 	t->gen = atomic_inc_return(&psb->trans_gen);
 
-	pohmelfs_ftrans_clean(t->gen);
-
 	cmd->size = t->iovec.iov_len - sizeof(struct netfs_cmd) +
 		t->attached_size + t->attached_pages * sizeof(struct netfs_cmd);
 	cmd->cmd = NETFS_TRANS;
diff -urN linux-2.6.30-rc2/drivers/staging/rt2860/rt_main_dev.c linux-2.6.30-rc3/drivers/staging/rt2860/rt_main_dev.c
--- linux-2.6.30-rc2/drivers/staging/rt2860/rt_main_dev.c	2009-04-22 03:29:11.689931385 +0000
+++ linux-2.6.30-rc3/drivers/staging/rt2860/rt_main_dev.c	2009-04-22 03:29:17.737931423 +0000
@@ -722,6 +722,20 @@
 	return (-1);
 } /* End of rt28xx_open */
 
+static const struct net_device_ops rt2860_netdev_ops = {
+	.ndo_open		= MainVirtualIF_open,
+	.ndo_stop		= MainVirtualIF_close,
+	.ndo_do_ioctl		= rt28xx_ioctl,
+	.ndo_get_stats		= RT28xx_get_ether_stats,
+	.ndo_validate_addr	= NULL,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef IKANOS_VX_1X0
+	.ndo_start_xmit		= IKANOS_DataFramesTx,
+#else
+	.ndo_start_xmit		= rt28xx_send_packets,
+#endif
+};
 
 /* Must not be called for mdev and apdev */
 static NDIS_STATUS rt_ieee80211_if_setup(struct net_device *dev, PRTMP_ADAPTER pAd)
@@ -733,11 +747,6 @@
 
 
 	//ether_setup(dev);
-	dev->hard_start_xmit = rt28xx_send_packets;
-
-#ifdef IKANOS_VX_1X0
-	dev->hard_start_xmit = IKANOS_DataFramesTx;
-#endif // IKANOS_VX_1X0 //
 
 #ifdef CONFIG_STA_SUPPORT
 #if WIRELESS_EXT >= 12
@@ -760,12 +769,8 @@
 #if WIRELESS_EXT < 21
 		dev->get_wireless_stats = rt28xx_get_wireless_stats;
 #endif
-	dev->get_stats = RT28xx_get_ether_stats;
-	dev->open = MainVirtualIF_open; //rt28xx_open;
-	dev->stop = MainVirtualIF_close; //rt28xx_close;
 	dev->priv_flags = INT_MAIN;
-	dev->do_ioctl = rt28xx_ioctl;
-	dev->validate_addr = NULL;
+	dev->netdev_ops = &rt2860_netdev_ops;
 	// find available device name
 	for (i = 0; i < 8; i++)
 	{
diff -urN linux-2.6.30-rc2/drivers/staging/rt2870/rt2870.h linux-2.6.30-rc3/drivers/staging/rt2870/rt2870.h
--- linux-2.6.30-rc2/drivers/staging/rt2870/rt2870.h	2009-04-22 03:29:11.699931460 +0000
+++ linux-2.6.30-rc3/drivers/staging/rt2870/rt2870.h	2009-04-22 03:29:17.747931506 +0000
@@ -96,6 +96,7 @@
 	{USB_DEVICE(0x0DF6,0x002B)}, /* Sitecom */		\
 	{USB_DEVICE(0x0DF6,0x002C)}, /* Sitecom */		\
 	{USB_DEVICE(0x0DF6,0x002D)}, /* Sitecom */		\
+	{USB_DEVICE(0x0DF6,0x0039)}, /* Sitecom */		\
 	{USB_DEVICE(0x14B2,0x3C06)}, /* Conceptronic */		\
 	{USB_DEVICE(0x14B2,0x3C28)}, /* Conceptronic */		\
 	{USB_DEVICE(0x2019,0xED06)}, /* Planex Communications, Inc. */		\
diff -urN linux-2.6.30-rc2/drivers/staging/rt2870/rt_main_dev.c linux-2.6.30-rc3/drivers/staging/rt2870/rt_main_dev.c
--- linux-2.6.30-rc2/drivers/staging/rt2870/rt_main_dev.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/rt2870/rt_main_dev.c	2009-04-22 03:29:17.748931454 +0000
@@ -855,6 +855,20 @@
 	return (-1);
 } /* End of rt28xx_open */
 
+static const struct net_device_ops rt2870_netdev_ops = {
+	.ndo_open		= MainVirtualIF_open,
+	.ndo_stop		= MainVirtualIF_close,
+	.ndo_do_ioctl		= rt28xx_ioctl,
+	.ndo_get_stats		= RT28xx_get_ether_stats,
+	.ndo_validate_addr	= NULL,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef IKANOS_VX_1X0
+	.ndo_start_xmit		= IKANOS_DataFramesTx,
+#else
+	.ndo_start_xmit		= rt28xx_send_packets,
+#endif
+};
 
 /* Must not be called for mdev and apdev */
 static NDIS_STATUS rt_ieee80211_if_setup(struct net_device *dev, PRTMP_ADAPTER pAd)
@@ -866,12 +880,6 @@
 
 
 	//ether_setup(dev);
-	dev->hard_start_xmit = rt28xx_send_packets;
-
-#ifdef IKANOS_VX_1X0
-	dev->hard_start_xmit = IKANOS_DataFramesTx;
-#endif // IKANOS_VX_1X0 //
-
 //	dev->set_multicast_list = ieee80211_set_multicast_list;
 //	dev->change_mtu = ieee80211_change_mtu;
 #ifdef CONFIG_STA_SUPPORT
@@ -895,16 +903,10 @@
 #if WIRELESS_EXT < 21
 		dev->get_wireless_stats = rt28xx_get_wireless_stats;
 #endif
-	dev->get_stats = RT28xx_get_ether_stats;
-	dev->open = MainVirtualIF_open; //rt28xx_open;
-	dev->stop = MainVirtualIF_close; //rt28xx_close;
 //	dev->uninit = ieee80211_if_reinit;
 //	dev->destructor = ieee80211_if_free;
 	dev->priv_flags = INT_MAIN;
-	dev->do_ioctl = rt28xx_ioctl;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
-    dev->validate_addr = NULL;
-#endif
+	dev->netdev_ops = &rt2870_netdev_ops;
 	// find available device name
 	for (i = 0; i < 8; i++)
 	{
diff -urN linux-2.6.30-rc2/drivers/staging/rt3070/rt_main_dev.c linux-2.6.30-rc3/drivers/staging/rt3070/rt_main_dev.c
--- linux-2.6.30-rc2/drivers/staging/rt3070/rt_main_dev.c	2009-04-22 03:29:11.734556463 +0000
+++ linux-2.6.30-rc3/drivers/staging/rt3070/rt_main_dev.c	2009-04-22 03:29:17.781931463 +0000
@@ -436,7 +436,6 @@
 //    OID_SET_HT_PHYMODE		SetHT;
 //	WPDMA_GLO_CFG_STRUC     GloCfg;
 	UINT32 		MacCsr0 = 0;
-	UINT32		MacValue = 0;
 
 #ifdef RT2870
 #ifdef INF_AMAZON_SE
@@ -849,6 +848,20 @@
 	return (-1);
 } /* End of rt28xx_open */
 
+static const struct net_device_ops rt3070_netdev_ops = {
+	.ndo_open		= MainVirtualIF_open,
+	.ndo_stop		= MainVirtualIF_close,
+	.ndo_do_ioctl		= rt28xx_ioctl,
+	.ndo_get_stats		= RT28xx_get_ether_stats,
+	.ndo_validate_addr	= NULL,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef IKANOS_VX_1X0
+	.ndo_start_xmit		= IKANOS_DataFramesTx,
+#else
+	.ndo_start_xmit		= rt28xx_send_packets,
+#endif
+};
 
 /* Must not be called for mdev and apdev */
 static NDIS_STATUS rt_ieee80211_if_setup(struct net_device *dev, PRTMP_ADAPTER pAd)
@@ -860,12 +873,6 @@
 
 
 	//ether_setup(dev);
-	dev->hard_start_xmit = rt28xx_send_packets;
-
-#ifdef IKANOS_VX_1X0
-	dev->hard_start_xmit = IKANOS_DataFramesTx;
-#endif // IKANOS_VX_1X0 //
-
 //	dev->set_multicast_list = ieee80211_set_multicast_list;
 //	dev->change_mtu = ieee80211_change_mtu;
 #ifdef CONFIG_STA_SUPPORT
@@ -889,16 +896,10 @@
 #if WIRELESS_EXT < 21
 		dev->get_wireless_stats = rt28xx_get_wireless_stats;
 #endif
-	dev->get_stats = RT28xx_get_ether_stats;
-	dev->open = MainVirtualIF_open; //rt28xx_open;
-	dev->stop = MainVirtualIF_close; //rt28xx_close;
 //	dev->uninit = ieee80211_if_reinit;
 //	dev->destructor = ieee80211_if_free;
 	dev->priv_flags = INT_MAIN;
-	dev->do_ioctl = rt28xx_ioctl;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
-    dev->validate_addr = NULL;
-#endif
+	dev->netdev_ops = &rt3070_netdev_ops;
 	// find available device name
 	for (i = 0; i < 8; i++)
 	{
diff -urN linux-2.6.30-rc2/drivers/staging/slicoss/README linux-2.6.30-rc3/drivers/staging/slicoss/README
--- linux-2.6.30-rc2/drivers/staging/slicoss/README	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/staging/slicoss/README	2009-04-22 03:29:17.808931435 +0000
@@ -10,7 +10,36 @@
 	- move firmware loading to request_firmware()
 	- remove direct memory access of structures
 	- any remaining sparse and checkpatch.pl warnings
-	- any netdev recommended changes
+
+	- use net_device_ops
+	- use dev->stats rather than adapter->stats
+	- don't cast netdev_priv it is already void
+	- use compare_ether_addr
+	- GET RID OF MACROS
+	- work on all architectures
+	   - without CONFIG_X86_64 confusion
+	   - do 64 bit correctly
+	   - don't depend on order of union
+	- get rid of ASSERT(), use BUG() instead but only where necessary
+	  looks like most aren't really useful
+	- no new SIOCDEVPRIVATE ioctl allowed
+	- don't use module_param for configuring interrupt mitigation
+	  use ethtool instead
+	- reorder code to elminate use of forward declarations
+	- don't keep private linked list of drivers.
+	- remove all the gratiutous debug infrastructure
+	- use PCI_DEVICE()
+	- do ethtool correctly using ethtool_ops
+	- NAPI?
+	- wasted overhead of extra stats
+	- state variables for things that are
+	  easily availble and shouldn't be kept in card structure, cardnum, ...
+	  slotnumber, events, ...
+	- get rid of slic_spinlock wrapper
+	- volatile == bad design => bad code
+	- locking too fine grained, not designed just throw more locks
+	  at problem
+
 
 Please send patches to:
         Greg Kroah-Hartman <gregkh@suse.de>
diff -urN linux-2.6.30-rc2/drivers/staging/slicoss/slicoss.c linux-2.6.30-rc3/drivers/staging/slicoss/slicoss.c
--- linux-2.6.30-rc2/drivers/staging/slicoss/slicoss.c	2009-04-22 03:29:11.791931236 +0000
+++ linux-2.6.30-rc3/drivers/staging/slicoss/slicoss.c	2009-04-22 03:29:17.838931370 +0000
@@ -345,6 +345,19 @@
 	return;
 }
 
+static const struct net_device_ops slic_netdev_ops = {
+	.ndo_open		= slic_entry_open,
+	.ndo_stop		= slic_entry_halt,
+	.ndo_start_xmit		= slic_xmit_start,
+	.ndo_do_ioctl		= slic_ioctl,
+	.ndo_set_mac_address	= slic_mac_set_address,
+	.ndo_get_stats		= slic_get_stats,
+	.ndo_set_multicast_list	= slic_mcast_set_list,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
 static int __devinit slic_entry_probe(struct pci_dev *pcidev,
 			       const struct pci_device_id *pci_tbl_entry)
 {
@@ -442,13 +455,7 @@
 
 	netdev->base_addr = (unsigned long)adapter->memorybase;
 	netdev->irq = adapter->irq;
-	netdev->open = slic_entry_open;
-	netdev->stop = slic_entry_halt;
-	netdev->hard_start_xmit = slic_xmit_start;
-	netdev->do_ioctl = slic_ioctl;
-	netdev->set_mac_address = slic_mac_set_address;
-	netdev->get_stats = slic_get_stats;
-	netdev->set_multicast_list = slic_mcast_set_list;
+	netdev->netdev_ops = &slic_netdev_ops;
 
 	slic_debug_adapter_create(adapter);
 
@@ -1260,7 +1267,7 @@
 	}
 
 	/* Doesn't already exist.  Allocate a structure to hold it */
-	mcaddr = kmalloc(sizeof(struct mcast_address), GFP_KERNEL);
+	mcaddr = kmalloc(sizeof(struct mcast_address), GFP_ATOMIC);
 	if (mcaddr == NULL)
 		return 1;
 
@@ -2284,7 +2291,7 @@
 	}
 	if (!physcard) {
 		/* no structure allocated for this physical card yet */
-		physcard = kzalloc(sizeof(struct physcard), GFP_KERNEL);
+		physcard = kzalloc(sizeof(struct physcard), GFP_ATOMIC);
 		ASSERT(physcard);
 
 		physcard->next = slic_global.phys_card;
diff -urN linux-2.6.30-rc2/drivers/staging/stlc45xx/Kconfig linux-2.6.30-rc3/drivers/staging/stlc45xx/Kconfig
--- linux-2.6.30-rc2/drivers/staging/stlc45xx/Kconfig	2009-04-22 03:29:11.791931236 +0000
+++ linux-2.6.30-rc3/drivers/staging/stlc45xx/Kconfig	2009-04-22 03:29:17.838931370 +0000
@@ -1,6 +1,6 @@
 config STLC45XX
 	tristate "stlc4550/4560 support"
-	depends on MAC80211 && WLAN_80211 && SPI_MASTER
+	depends on MAC80211 && WLAN_80211 && SPI_MASTER && GENERIC_HARDIRQS
 	---help---
 	  This is a driver for stlc4550 and stlc4560 chipsets.
 
diff -urN linux-2.6.30-rc2/drivers/staging/sxg/sxg.c linux-2.6.30-rc3/drivers/staging/sxg/sxg.c
--- linux-2.6.30-rc2/drivers/staging/sxg/sxg.c	2009-04-22 03:29:11.802931240 +0000
+++ linux-2.6.30-rc3/drivers/staging/sxg/sxg.c	2009-04-22 03:29:17.849931300 +0000
@@ -322,6 +322,8 @@
 	int ret,i;
 
 	if (!adapter->intrregistered) {
+		spin_unlock_irqrestore(&sxg_global.driver_lock,
+					sxg_global.flags);
 		for (i=0; i<adapter->nr_msix_entries; i++) {
 			ret = request_irq (adapter->msi_entries[i].vector,
 					sxg_isr,
@@ -329,6 +331,8 @@
 					adapter->netdev->name,
 					adapter->netdev);
 			if (ret) {
+				spin_lock_irqsave(&sxg_global.driver_lock,
+						 sxg_global.flags);
 				DBG_ERROR("sxg: MSI-X request_irq (%s) "
 					"FAILED [%x]\n", adapter->netdev->name,
 					 ret);
@@ -336,6 +340,7 @@
 			}
 		}
 	}
+	spin_lock_irqsave(&sxg_global.driver_lock, sxg_global.flags);
 	adapter->msi_enabled = TRUE;
 	adapter->intrregistered = 1;
 	adapter->IntRegistered = TRUE;
@@ -896,6 +901,22 @@
 	return status;
 }
 
+static const struct net_device_ops sxg_netdev_ops = {
+	.ndo_open		= sxg_entry_open,
+	.ndo_stop		= sxg_entry_halt,
+	.ndo_start_xmit		= sxg_send_packets,
+	.ndo_do_ioctl		= sxg_ioctl,
+	.ndo_change_mtu		= sxg_change_mtu,
+	.ndo_get_stats		= sxg_get_stats,
+	.ndo_set_multicast_list	= sxg_mcast_set_list,
+	.ndo_validate_addr	= eth_validate_addr,
+#if XXXTODO
+	.ndo_set_mac_address	= sxg_mac_set_address,
+#else
+	.ndo_set_mac_address	= eth_mac_addr,
+#endif
+};
+
 static int sxg_entry_probe(struct pci_dev *pcidev,
 			   const struct pci_device_id *pci_tbl_entry)
 {
@@ -1095,16 +1116,7 @@
 
 	netdev->base_addr = (unsigned long)adapter->base_addr;
 	netdev->irq = adapter->irq;
-	netdev->open = sxg_entry_open;
-	netdev->stop = sxg_entry_halt;
-	netdev->hard_start_xmit = sxg_send_packets;
-	netdev->do_ioctl = sxg_ioctl;
-	netdev->change_mtu = sxg_change_mtu;
-#if XXXTODO
-	netdev->set_mac_address = sxg_mac_set_address;
-#endif
-	netdev->get_stats = sxg_get_stats;
-	netdev->set_multicast_list = sxg_mcast_set_list;
+	netdev->netdev_ops = &sxg_netdev_ops;
 	SET_ETHTOOL_OPS(netdev, &sxg_nic_ethtool_ops);
  	netdev->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 	err = sxg_set_interrupt_capability(adapter);
@@ -2247,6 +2259,8 @@
 	DBG_ERROR("sxg: %s EXIT\n", __func__);
 
 	spin_unlock_irqrestore(&sxg_global.driver_lock, sxg_global.flags);
+	mod_timer(&adapter->watchdog_timer, jiffies);
+
 	return STATUS_SUCCESS;
 }
 
@@ -2568,6 +2582,7 @@
 	u64 phys_addr;
 	unsigned long flags;
 	unsigned long queue_id=0;
+	int offload_cksum = 0;
 
 	SXG_TRACE(TRACE_SXG, SxgTraceBuffer, TRACE_NOISY, "DumbSgl",
 		  pSgl, SxgSgl, 0, 0);
@@ -2606,7 +2621,11 @@
                 struct iphdr *ip;
 
                 ip = ip_hdr(skb);
-		if ((ip->protocol == IPPROTO_TCP)&&(DataLength >= sizeof(
+		if (ip->protocol == IPPROTO_TCP)
+			offload_cksum = 1;
+		if (!offload_cksum || !tcp_hdr(skb))
+			queue_id = 0;
+		else if (offload_cksum && (DataLength >= sizeof(
 							struct tcphdr))){
 			queue_id = ((ntohs(tcp_hdr(skb)->dest) == ISCSI_PORT) ?
 					(ntohs (tcp_hdr(skb)->source) &
@@ -2615,8 +2634,11 @@
 						SXG_LARGE_SEND_QUEUE_MASK));
 		}
 	} else if (skb->protocol == htons(ETH_P_IPV6)) {
-		if ((ipv6_hdr(skb)->nexthdr == IPPROTO_TCP) && (DataLength >=
-						 sizeof(struct tcphdr)) ) {
+		if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
+			offload_cksum = 1;
+		if (!offload_cksum || !tcp_hdr(skb))
+			queue_id = 0;
+		else if (offload_cksum && (DataLength>=sizeof(struct tcphdr))){
 			queue_id = ((ntohs(tcp_hdr(skb)->dest) == ISCSI_PORT) ?
 					(ntohs (tcp_hdr(skb)->source) &
 					SXG_LARGE_SEND_QUEUE_MASK):
@@ -2645,23 +2667,38 @@
 	}
 	SXG_TRACE(TRACE_SXG, SxgTraceBuffer, TRACE_NOISY, "DumbCmd",
 		  XmtCmd, XmtRingInfo->Head, XmtRingInfo->Tail, 0);
-	/* Update stats */
-	adapter->stats.tx_packets++;
-	adapter->stats.tx_bytes += DataLength;
-#if XXXTODO			/* Stats stuff */
-	if (SXG_MULTICAST_PACKET(EtherHdr)) {
-		if (SXG_BROADCAST_PACKET(EtherHdr)) {
-			adapter->Stats.DumbXmtBcastPkts++;
-			adapter->Stats.DumbXmtBcastBytes += DataLength;
+	memset(XmtCmd, '\0', sizeof(*XmtCmd));
+	XmtCmd->SgEntries = 1;
+	XmtCmd->Flags = 0;
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		/*
+		 * We need to set the Checkum in IP  header to 0. This is
+		 * required by hardware.
+		 */
+		if (offload_cksum) {
+			ip_hdr(skb)->check = 0x0;
+			XmtCmd->CsumFlags.Flags |= SXG_SLOWCMD_CSUM_IP;
+			XmtCmd->CsumFlags.Flags |= SXG_SLOWCMD_CSUM_TCP;
+			/*
+			 * Dont know if length will require a change in
+			 * case of VLAN
+			 */
+			XmtCmd->CsumFlags.MacLen = ETH_HLEN;
+			XmtCmd->CsumFlags.IpHl = skb_network_header_len(skb) >>
+							SXG_NW_HDR_LEN_SHIFT;
 		} else {
-			adapter->Stats.DumbXmtMcastPkts++;
-			adapter->Stats.DumbXmtMcastBytes += DataLength;
+			if (skb_checksum_help(skb)){
+				printk(KERN_EMERG "Dropped UDP packet for"
+					" incorrect checksum calculation\n");
+				if (XmtCmd)
+					SXG_ABORT_CMD(XmtRingInfo);
+				spin_unlock_irqrestore(&adapter->XmtZeroLock,
+							 flags);
+				return STATUS_SUCCESS;
+			}
 		}
-	} else {
-		adapter->Stats.DumbXmtUcastPkts++;
-		adapter->Stats.DumbXmtUcastBytes += DataLength;
 	}
-#endif
+
 	/*
 	 * Fill in the command
 	 * Copy out the first SGE to the command and adjust for offset
@@ -2679,31 +2716,17 @@
 		(SXG_INVALID_SGL(phys_addr,skb->data_len)))
 	{
 		spin_unlock_irqrestore(&adapter->XmtZeroLock, flags);
+		if (XmtCmd)
+			SXG_ABORT_CMD(XmtRingInfo);
 		/* Silently drop this packet */
 		printk(KERN_EMERG"Dropped a packet for 64k boundary problem\n");
 		return STATUS_SUCCESS;
 	}
-	memset(XmtCmd, '\0', sizeof(*XmtCmd));
 	XmtCmd->Buffer.FirstSgeAddress = phys_addr;
 	XmtCmd->Buffer.FirstSgeLength = DataLength;
 	XmtCmd->Buffer.SgeOffset = 0;
 	XmtCmd->Buffer.TotalLength = DataLength;
-	XmtCmd->SgEntries = 1;
-	XmtCmd->Flags = 0;
 
-	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-		/*
-		 * We need to set the Checkum in IP  header to 0. This is
-		 * required by hardware.
-		 */
-		ip_hdr(skb)->check = 0x0;
-		XmtCmd->CsumFlags.Flags |= SXG_SLOWCMD_CSUM_IP;
-		XmtCmd->CsumFlags.Flags |= SXG_SLOWCMD_CSUM_TCP;
-		/* Dont know if length will require a change in case of VLAN */
-		XmtCmd->CsumFlags.MacLen = ETH_HLEN;
-		XmtCmd->CsumFlags.IpHl = skb_network_header_len(skb) >>
-							SXG_NW_HDR_LEN_SHIFT;
-	}
 	/*
 	 * Advance transmit cmd descripter by 1.
 	 * NOTE - See comments in SxgTcpOutput where we write
@@ -2715,6 +2738,24 @@
 	ASSERT((queue_id & ~SXG_LARGE_SEND_QUEUE_MASK) == 0);
 	WRITE_REG(adapter->UcodeRegs[0].XmtCmd, ((queue_id << 16) | 1), TRUE);
 	adapter->Stats.XmtQLen++;	/* Stats within lock */
+	/* Update stats */
+	adapter->stats.tx_packets++;
+	adapter->stats.tx_bytes += DataLength;
+#if XXXTODO			/* Stats stuff */
+	if (SXG_MULTICAST_PACKET(EtherHdr)) {
+		if (SXG_BROADCAST_PACKET(EtherHdr)) {
+			adapter->Stats.DumbXmtBcastPkts++;
+			adapter->Stats.DumbXmtBcastBytes += DataLength;
+		} else {
+			adapter->Stats.DumbXmtMcastPkts++;
+			adapter->Stats.DumbXmtMcastBytes += DataLength;
+		}
+	} else {
+		adapter->Stats.DumbXmtUcastPkts++;
+		adapter->Stats.DumbXmtUcastBytes += DataLength;
+	}
+#endif
+
 	spin_unlock_irqrestore(&adapter->XmtZeroLock, flags);
 	SXG_TRACE(TRACE_SXG, SxgTraceBuffer, TRACE_NOISY, "XDumSgl2",
 		  XmtCmd, pSgl, SxgSgl, 0);
diff -urN linux-2.6.30-rc2/drivers/staging/uc2322/aten2011.c linux-2.6.30-rc3/drivers/staging/uc2322/aten2011.c
--- linux-2.6.30-rc2/drivers/staging/uc2322/aten2011.c	2009-04-22 03:29:11.808931431 +0000
+++ linux-2.6.30-rc3/drivers/staging/uc2322/aten2011.c	2009-04-22 03:29:17.855931577 +0000
@@ -603,10 +603,9 @@
 
 	tty = tty_port_tty_get(&ATEN2011_port->port->port);
 
-	if (tty && ATEN2011_port->open) {
+	if (tty && ATEN2011_port->open)
 		/* tell the tty driver that something has changed */
-		wake_up_interruptible(&tty->write_wait);
-	}
+		tty_wakeup(tty);
 
 	/* schedule_work(&ATEN2011_port->port->work); */
 	tty_kref_put(tty);
@@ -825,12 +824,6 @@
 	status = 0;
 	status = set_reg_sync(port, ATEN2011_port->ControlRegOffset, Data);
 
-	/* force low_latency on so that our tty_push actually forces *
-	 * the data through,otherwise it is scheduled, and with      *
-	 * high data rates (like with OHCI) data can get lost.       */
-
-	if (tty)
-		tty->low_latency = 1;
 	/*
 	 * Check to see if we've set up our endpoint info yet
 	 * (can't set it up in ATEN2011_startup as the structures
@@ -1473,22 +1466,7 @@
 
 	cflag = tty->termios->c_cflag;
 
-	if (!cflag) {
-		dbg("%s %s", __func__, "cflag is NULL");
-		return;
-	}
-
-	/* check that they really want us to change something */
-	if (old_termios) {
-		if ((cflag == old_termios->c_cflag) &&
-		    (RELEVANT_IFLAG(tty->termios->c_iflag) ==
-		     RELEVANT_IFLAG(old_termios->c_iflag))) {
-			dbg("%s", "Nothing to change");
-			return;
-		}
-	}
-
-	dbg("%s - clfag %08x iflag %08x", __func__,
+	dbg("%s - cflag %08x iflag %08x", __func__,
 	    tty->termios->c_cflag, RELEVANT_IFLAG(tty->termios->c_iflag));
 
 	if (old_termios) {
diff -urN linux-2.6.30-rc2/drivers/staging/wlan-ng/p80211netdev.c linux-2.6.30-rc3/drivers/staging/wlan-ng/p80211netdev.c
--- linux-2.6.30-rc2/drivers/staging/wlan-ng/p80211netdev.c	2009-04-22 03:29:11.824931404 +0000
+++ linux-2.6.30-rc3/drivers/staging/wlan-ng/p80211netdev.c	2009-04-22 03:29:17.871931284 +0000
@@ -711,6 +711,20 @@
 	return 0;
 }
 
+static const struct net_device_ops p80211_netdev_ops = {
+	.ndo_init		= p80211knetdev_init,
+	.ndo_open		= p80211knetdev_open,
+	.ndo_stop		= p80211knetdev_stop,
+	.ndo_get_stats		= p80211knetdev_get_stats,
+	.ndo_start_xmit		= p80211knetdev_hard_start_xmit,
+	.ndo_set_multicast_list	= p80211knetdev_set_multicast_list,
+	.ndo_do_ioctl		= p80211knetdev_do_ioctl,
+	.ndo_set_mac_address	= p80211knetdev_set_mac_address,
+	.ndo_tx_timeout		= p80211knetdev_tx_timeout,
+	.ndo_change_mtu		= wlan_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
 /*----------------------------------------------------------------
 * wlan_setup
 *
@@ -756,11 +770,7 @@
 	} else {
 		wlandev->netdev = dev;
 		dev->ml_priv = wlandev;
-		dev->hard_start_xmit = p80211knetdev_hard_start_xmit;
-		dev->get_stats = p80211knetdev_get_stats;
-		dev->init = p80211knetdev_init;
-		dev->open = p80211knetdev_open;
-		dev->stop = p80211knetdev_stop;
+		dev->netdev_ops = &p80211_netdev_ops;
 
 		mutex_init(&wlandev->ioctl_lock);
 		/* block ioctls until fully initialised. Don't forget to call
diff -urN linux-2.6.30-rc2/drivers/uio/uio_cif.c linux-2.6.30-rc3/drivers/uio/uio_cif.c
--- linux-2.6.30-rc2/drivers/uio/uio_cif.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/uio/uio_cif.c	2009-04-22 03:29:17.879931427 +0000
@@ -147,5 +147,6 @@
 module_init(hilscher_init_module);
 module_exit(hilscher_exit_module);
 
+MODULE_DEVICE_TABLE(pci, hilscher_pci_ids);
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Hans J. Koch, Benedikt Spranger");
diff -urN linux-2.6.30-rc2/drivers/usb/class/cdc-wdm.c linux-2.6.30-rc3/drivers/usb/class/cdc-wdm.c
--- linux-2.6.30-rc2/drivers/usb/class/cdc-wdm.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/class/cdc-wdm.c	2009-04-22 03:29:17.881931442 +0000
@@ -652,7 +652,7 @@
 
 	iface = &intf->altsetting[0];
 	ep = &iface->endpoint[0].desc;
-	if (!usb_endpoint_is_int_in(ep)) {
+	if (!ep || !usb_endpoint_is_int_in(ep)) {
 		rv = -EINVAL;
 		goto err;
 	}
diff -urN linux-2.6.30-rc2/drivers/usb/core/devio.c linux-2.6.30-rc3/drivers/usb/core/devio.c
--- linux-2.6.30-rc2/drivers/usb/core/devio.c	2009-04-22 03:29:11.835556369 +0000
+++ linux-2.6.30-rc3/drivers/usb/core/devio.c	2009-04-22 03:29:17.881931442 +0000
@@ -841,7 +841,7 @@
 	ret = checkintf(ps, ret);
 	if (ret)
 		return ret;
-	usb_settoggle(ps->dev, ep & 0xf, !(ep & USB_DIR_IN), 0);
+	usb_reset_endpoint(ps->dev, ep);
 	return 0;
 }
 
diff -urN linux-2.6.30-rc2/drivers/usb/core/hcd.c linux-2.6.30-rc3/drivers/usb/core/hcd.c
--- linux-2.6.30-rc2/drivers/usb/core/hcd.c	2009-04-22 03:29:11.836931275 +0000
+++ linux-2.6.30-rc3/drivers/usb/core/hcd.c	2009-04-22 03:29:17.882931414 +0000
@@ -1539,6 +1539,32 @@
 		hcd->driver->endpoint_disable(hcd, ep);
 }
 
+/**
+ * usb_hcd_reset_endpoint - reset host endpoint state
+ * @udev: USB device.
+ * @ep:   the endpoint to reset.
+ *
+ * Resets any host endpoint state such as the toggle bit, sequence
+ * number and current window.
+ */
+void usb_hcd_reset_endpoint(struct usb_device *udev,
+			    struct usb_host_endpoint *ep)
+{
+	struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+
+	if (hcd->driver->endpoint_reset)
+		hcd->driver->endpoint_reset(hcd, ep);
+	else {
+		int epnum = usb_endpoint_num(&ep->desc);
+		int is_out = usb_endpoint_dir_out(&ep->desc);
+		int is_control = usb_endpoint_xfer_control(&ep->desc);
+
+		usb_settoggle(udev, epnum, is_out, 0);
+		if (is_control)
+			usb_settoggle(udev, epnum, !is_out, 0);
+	}
+}
+
 /* Protect against drivers that try to unlink URBs after the device
  * is gone, by waiting until all unlinks for @udev are finished.
  * Since we don't currently track URBs by device, simply wait until
diff -urN linux-2.6.30-rc2/drivers/usb/core/hcd.h linux-2.6.30-rc3/drivers/usb/core/hcd.h
--- linux-2.6.30-rc2/drivers/usb/core/hcd.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/core/hcd.h	2009-04-22 03:29:17.882931414 +0000
@@ -206,6 +206,11 @@
 	void 	(*endpoint_disable)(struct usb_hcd *hcd,
 			struct usb_host_endpoint *ep);
 
+	/* (optional) reset any endpoint state such as sequence number
+	   and current window */
+	void 	(*endpoint_reset)(struct usb_hcd *hcd,
+			struct usb_host_endpoint *ep);
+
 	/* root hub support */
 	int	(*hub_status_data) (struct usb_hcd *hcd, char *buf);
 	int	(*hub_control) (struct usb_hcd *hcd,
@@ -234,6 +239,8 @@
 		struct usb_host_endpoint *ep);
 extern void usb_hcd_disable_endpoint(struct usb_device *udev,
 		struct usb_host_endpoint *ep);
+extern void usb_hcd_reset_endpoint(struct usb_device *udev,
+		struct usb_host_endpoint *ep);
 extern void usb_hcd_synchronize_unlinks(struct usb_device *udev);
 extern int usb_hcd_get_frame_number(struct usb_device *udev);
 
@@ -279,6 +286,13 @@
 extern void usb_hc_died(struct usb_hcd *hcd);
 extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
 
+/* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
+#define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
+#define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
+#define usb_settoggle(dev, ep, out, bit) \
+		((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | \
+		 ((bit) << (ep)))
+
 /* -------------------------------------------------------------------------- */
 
 /* Enumeration is only for the hub driver, or HCD virtual root hubs */
diff -urN linux-2.6.30-rc2/drivers/usb/core/message.c linux-2.6.30-rc3/drivers/usb/core/message.c
--- linux-2.6.30-rc2/drivers/usb/core/message.c	2009-04-22 03:29:11.837931523 +0000
+++ linux-2.6.30-rc3/drivers/usb/core/message.c	2009-04-22 03:29:17.883931410 +0000
@@ -1002,8 +1002,7 @@
 	 * the copy in usb-storage, for as long as we need two copies.
 	 */
 
-	/* toggle was reset by the clear */
-	usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 0);
+	usb_reset_endpoint(dev, endp);
 
 	return 0;
 }
@@ -1076,6 +1075,30 @@
 }
 
 /**
+ * usb_reset_endpoint - Reset an endpoint's state.
+ * @dev: the device whose endpoint is to be reset
+ * @epaddr: the endpoint's address.  Endpoint number for output,
+ *	endpoint number + USB_DIR_IN for input
+ *
+ * Resets any host-side endpoint state such as the toggle bit,
+ * sequence number or current window.
+ */
+void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr)
+{
+	unsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;
+	struct usb_host_endpoint *ep;
+
+	if (usb_endpoint_out(epaddr))
+		ep = dev->ep_out[epnum];
+	else
+		ep = dev->ep_in[epnum];
+	if (ep)
+		usb_hcd_reset_endpoint(dev, ep);
+}
+EXPORT_SYMBOL_GPL(usb_reset_endpoint);
+
+
+/**
  * usb_disable_interface -- Disable all endpoints for an interface
  * @dev: the device whose interface is being disabled
  * @intf: pointer to the interface descriptor
@@ -1117,7 +1140,6 @@
 		usb_disable_endpoint(dev, i, true);
 		usb_disable_endpoint(dev, i + USB_DIR_IN, true);
 	}
-	dev->toggle[0] = dev->toggle[1] = 0;
 
 	/* getting rid of interfaces will disconnect
 	 * any drivers bound to them (a key side effect)
@@ -1154,28 +1176,24 @@
  * usb_enable_endpoint - Enable an endpoint for USB communications
  * @dev: the device whose interface is being enabled
  * @ep: the endpoint
- * @reset_toggle: flag to set the endpoint's toggle back to 0
+ * @reset_ep: flag to reset the endpoint state
  *
- * Resets the endpoint toggle if asked, and sets dev->ep_{in,out} pointers.
+ * Resets the endpoint state if asked, and sets dev->ep_{in,out} pointers.
  * For control endpoints, both the input and output sides are handled.
  */
 void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep,
-		bool reset_toggle)
+		bool reset_ep)
 {
 	int epnum = usb_endpoint_num(&ep->desc);
 	int is_out = usb_endpoint_dir_out(&ep->desc);
 	int is_control = usb_endpoint_xfer_control(&ep->desc);
 
-	if (is_out || is_control) {
-		if (reset_toggle)
-			usb_settoggle(dev, epnum, 1, 0);
+	if (reset_ep)
+		usb_hcd_reset_endpoint(dev, ep);
+	if (is_out || is_control)
 		dev->ep_out[epnum] = ep;
-	}
-	if (!is_out || is_control) {
-		if (reset_toggle)
-			usb_settoggle(dev, epnum, 0, 0);
+	if (!is_out || is_control)
 		dev->ep_in[epnum] = ep;
-	}
 	ep->enabled = 1;
 }
 
@@ -1183,18 +1201,18 @@
  * usb_enable_interface - Enable all the endpoints for an interface
  * @dev: the device whose interface is being enabled
  * @intf: pointer to the interface descriptor
- * @reset_toggles: flag to set the endpoints' toggles back to 0
+ * @reset_eps: flag to reset the endpoints' state
  *
  * Enables all the endpoints for the interface's current altsetting.
  */
 void usb_enable_interface(struct usb_device *dev,
-		struct usb_interface *intf, bool reset_toggles)
+		struct usb_interface *intf, bool reset_eps)
 {
 	struct usb_host_interface *alt = intf->cur_altsetting;
 	int i;
 
 	for (i = 0; i < alt->desc.bNumEndpoints; ++i)
-		usb_enable_endpoint(dev, &alt->endpoint[i], reset_toggles);
+		usb_enable_endpoint(dev, &alt->endpoint[i], reset_eps);
 }
 
 /**
@@ -1335,7 +1353,7 @@
  * This issues a standard SET_CONFIGURATION request to the device using
  * the current configuration.  The effect is to reset most USB-related
  * state in the device, including interface altsettings (reset to zero),
- * endpoint halts (cleared), and data toggle (only for bulk and interrupt
+ * endpoint halts (cleared), and endpoint state (only for bulk and interrupt
  * endpoints).  Other usbcore state is unchanged, including bindings of
  * usb device drivers to interfaces.
  *
@@ -1343,7 +1361,7 @@
  * (multi-interface) devices.  Instead, the driver for each interface may
  * use usb_set_interface() on the interfaces it claims.  Be careful though;
  * some devices don't support the SET_INTERFACE request, and others won't
- * reset all the interface state (notably data toggles).  Resetting the whole
+ * reset all the interface state (notably endpoint state).  Resetting the whole
  * configuration would affect other drivers' interfaces.
  *
  * The caller must own the device lock.
@@ -1376,8 +1394,6 @@
 	if (retval < 0)
 		return retval;
 
-	dev->toggle[0] = dev->toggle[1] = 0;
-
 	/* re-init hc/hcd interface/endpoint state */
 	for (i = 0; i < config->desc.bNumInterfaces; i++) {
 		struct usb_interface *intf = config->interface[i];
diff -urN linux-2.6.30-rc2/drivers/usb/core/usb.c linux-2.6.30-rc3/drivers/usb/core/usb.c
--- linux-2.6.30-rc2/drivers/usb/core/usb.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/core/usb.c	2009-04-22 03:29:17.884931486 +0000
@@ -362,7 +362,7 @@
 	dev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev->ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
 	/* ep0 maxpacket comes later, from device descriptor */
-	usb_enable_endpoint(dev, &dev->ep0, true);
+	usb_enable_endpoint(dev, &dev->ep0, false);
 	dev->can_submit = 1;
 
 	/* Save readable and stable topology id, distinguishing devices
diff -urN linux-2.6.30-rc2/drivers/usb/gadget/u_ether.c linux-2.6.30-rc3/drivers/usb/gadget/u_ether.c
--- linux-2.6.30-rc2/drivers/usb/gadget/u_ether.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/gadget/u_ether.c	2009-04-22 03:29:17.895931473 +0000
@@ -175,12 +175,6 @@
 	strlcpy(p->bus_info, dev_name(&dev->gadget->dev), sizeof p->bus_info);
 }
 
-static u32 eth_get_link(struct net_device *net)
-{
-	struct eth_dev	*dev = netdev_priv(net);
-	return dev->gadget->speed != USB_SPEED_UNKNOWN;
-}
-
 /* REVISIT can also support:
  *   - WOL (by tracking suspends and issuing remote wakeup)
  *   - msglevel (implies updated messaging)
@@ -189,7 +183,7 @@
 
 static struct ethtool_ops ops = {
 	.get_drvinfo = eth_get_drvinfo,
-	.get_link = eth_get_link
+	.get_link = ethtool_op_get_link,
 };
 
 static void defer_kevent(struct eth_dev *dev, int flag)
diff -urN linux-2.6.30-rc2/drivers/usb/host/whci/asl.c linux-2.6.30-rc3/drivers/usb/host/whci/asl.c
--- linux-2.6.30-rc2/drivers/usb/host/whci/asl.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/host/whci/asl.c	2009-04-22 03:29:17.903931421 +0000
@@ -122,7 +122,8 @@
 		process_inactive_qtd(whc, qset, td);
 	}
 
-	update |= qset_add_qtds(whc, qset);
+	if (!qset->remove)
+		update |= qset_add_qtds(whc, qset);
 
 done:
 	/*
@@ -254,23 +255,29 @@
 
 	spin_lock_irqsave(&whc->lock, flags);
 
+	err = usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
+	if (err < 0) {
+		spin_unlock_irqrestore(&whc->lock, flags);
+		return err;
+	}
+
 	qset = get_qset(whc, urb, GFP_ATOMIC);
 	if (qset == NULL)
 		err = -ENOMEM;
 	else
 		err = qset_add_urb(whc, qset, urb, GFP_ATOMIC);
 	if (!err) {
-		usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
 		if (!qset->in_sw_list)
 			asl_qset_insert_begin(whc, qset);
-	}
+	} else
+		usb_hcd_unlink_urb_from_ep(&whc->wusbhc.usb_hcd, urb);
 
 	spin_unlock_irqrestore(&whc->lock, flags);
 
 	if (!err)
 		queue_work(whc->workqueue, &whc->async_work);
 
-	return 0;
+	return err;
 }
 
 /**
diff -urN linux-2.6.30-rc2/drivers/usb/host/whci/hcd.c linux-2.6.30-rc3/drivers/usb/host/whci/hcd.c
--- linux-2.6.30-rc2/drivers/usb/host/whci/hcd.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/host/whci/hcd.c	2009-04-22 03:29:17.903931421 +0000
@@ -186,6 +186,28 @@
 	}
 }
 
+static void whc_endpoint_reset(struct usb_hcd *usb_hcd,
+			       struct usb_host_endpoint *ep)
+{
+	struct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);
+	struct whc *whc = wusbhc_to_whc(wusbhc);
+	struct whc_qset *qset;
+
+	qset = ep->hcpriv;
+	if (qset) {
+		qset->remove = 1;
+
+		if (usb_endpoint_xfer_bulk(&ep->desc)
+		    || usb_endpoint_xfer_control(&ep->desc))
+			queue_work(whc->workqueue, &whc->async_work);
+		else
+			queue_work(whc->workqueue, &whc->periodic_work);
+
+		qset_reset(whc, qset);
+	}
+}
+
+
 static struct hc_driver whc_hc_driver = {
 	.description = "whci-hcd",
 	.product_desc = "Wireless host controller",
@@ -200,6 +222,7 @@
 	.urb_enqueue = whc_urb_enqueue,
 	.urb_dequeue = whc_urb_dequeue,
 	.endpoint_disable = whc_endpoint_disable,
+	.endpoint_reset = whc_endpoint_reset,
 
 	.hub_status_data = wusbhc_rh_status_data,
 	.hub_control = wusbhc_rh_control,
diff -urN linux-2.6.30-rc2/drivers/usb/host/whci/pzl.c linux-2.6.30-rc3/drivers/usb/host/whci/pzl.c
--- linux-2.6.30-rc2/drivers/usb/host/whci/pzl.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/host/whci/pzl.c	2009-04-22 03:29:17.903931421 +0000
@@ -128,7 +128,8 @@
 		process_inactive_qtd(whc, qset, td);
 	}
 
-	update |= qset_add_qtds(whc, qset);
+	if (!qset->remove)
+		update |= qset_add_qtds(whc, qset);
 
 done:
 	/*
@@ -282,23 +283,29 @@
 
 	spin_lock_irqsave(&whc->lock, flags);
 
+	err = usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
+	if (err < 0) {
+		spin_unlock_irqrestore(&whc->lock, flags);
+		return err;
+	}
+
 	qset = get_qset(whc, urb, GFP_ATOMIC);
 	if (qset == NULL)
 		err = -ENOMEM;
 	else
 		err = qset_add_urb(whc, qset, urb, GFP_ATOMIC);
 	if (!err) {
-		usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
 		if (!qset->in_sw_list)
 			qset_insert_in_sw_list(whc, qset);
-	}
+	} else
+		usb_hcd_unlink_urb_from_ep(&whc->wusbhc.usb_hcd, urb);
 
 	spin_unlock_irqrestore(&whc->lock, flags);
 
 	if (!err)
 		queue_work(whc->workqueue, &whc->periodic_work);
 
-	return 0;
+	return err;
 }
 
 /**
@@ -353,7 +360,6 @@
 	qset_delete(whc, qset);
 }
 
-
 /**
  * pzl_init - initialize the periodic zone list
  * @whc: the WHCI host controller
diff -urN linux-2.6.30-rc2/drivers/usb/host/whci/qset.c linux-2.6.30-rc3/drivers/usb/host/whci/qset.c
--- linux-2.6.30-rc2/drivers/usb/host/whci/qset.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/host/whci/qset.c	2009-04-22 03:29:17.904931464 +0000
@@ -89,11 +89,16 @@
 		QH_INFO3_TX_RATE_53_3
 		| QH_INFO3_TX_PWR(0) /* 0 == max power */
 		);
+
+	qset->qh.cur_window = cpu_to_le32((1 << qset->max_burst) - 1);
 }
 
 /**
  * qset_clear - clear fields in a qset so it may be reinserted into a
- * schedule
+ * schedule.
+ *
+ * The sequence number and current window are not cleared (see
+ * qset_reset()).
  */
 void qset_clear(struct whc *whc, struct whc_qset *qset)
 {
@@ -101,9 +106,8 @@
 	qset->remove = 0;
 
 	qset->qh.link = cpu_to_le32(QH_LINK_NTDS(8) | QH_LINK_T);
-	qset->qh.status = cpu_to_le16(QH_STATUS_ICUR(qset->td_start));
+	qset->qh.status = qset->qh.status & QH_STATUS_SEQ_MASK;
 	qset->qh.err_count = 0;
-	qset->qh.cur_window = cpu_to_le32((1 << qset->max_burst) - 1);
 	qset->qh.scratch[0] = 0;
 	qset->qh.scratch[1] = 0;
 	qset->qh.scratch[2] = 0;
@@ -114,6 +118,20 @@
 }
 
 /**
+ * qset_reset - reset endpoint state in a qset.
+ *
+ * Clears the sequence number and current window.  This qset must not
+ * be in the ASL or PZL.
+ */
+void qset_reset(struct whc *whc, struct whc_qset *qset)
+{
+	wait_for_completion(&qset->remove_complete);
+
+	qset->qh.status &= ~QH_STATUS_SEQ_MASK;
+	qset->qh.cur_window = cpu_to_le32((1 << qset->max_burst) - 1);
+}
+
+/**
  * get_qset - get the qset for an async endpoint
  *
  * A new qset is created if one does not already exist.
diff -urN linux-2.6.30-rc2/drivers/usb/host/whci/whcd.h linux-2.6.30-rc3/drivers/usb/host/whci/whcd.h
--- linux-2.6.30-rc2/drivers/usb/host/whci/whcd.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/host/whci/whcd.h	2009-04-22 03:29:17.904931464 +0000
@@ -184,6 +184,7 @@
 struct whc_qset *get_qset(struct whc *whc, struct urb *urb, gfp_t mem_flags);
 void qset_delete(struct whc *whc, struct whc_qset *qset);
 void qset_clear(struct whc *whc, struct whc_qset *qset);
+void qset_reset(struct whc *whc, struct whc_qset *qset);
 int qset_add_urb(struct whc *whc, struct whc_qset *qset, struct urb *urb,
 		 gfp_t mem_flags);
 void qset_free_std(struct whc *whc, struct whc_std *std);
diff -urN linux-2.6.30-rc2/drivers/usb/host/whci/whci-hc.h linux-2.6.30-rc3/drivers/usb/host/whci/whci-hc.h
--- linux-2.6.30-rc2/drivers/usb/host/whci/whci-hc.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/host/whci/whci-hc.h	2009-04-22 03:29:17.904931464 +0000
@@ -185,6 +185,7 @@
 #define QH_STATUS_FLOW_CTRL      (1 << 15)
 #define QH_STATUS_ICUR(i)        ((i) << 5)
 #define QH_STATUS_TO_ICUR(s)     (((s) >> 5) & 0x7)
+#define QH_STATUS_SEQ_MASK       0x1f
 
 /**
  * usb_pipe_to_qh_type - USB core pipe type to QH transfer type
diff -urN linux-2.6.30-rc2/drivers/usb/musb/cppi_dma.c linux-2.6.30-rc3/drivers/usb/musb/cppi_dma.c
--- linux-2.6.30-rc2/drivers/usb/musb/cppi_dma.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/musb/cppi_dma.c	2009-04-22 03:29:17.908931486 +0000
@@ -579,6 +579,7 @@
 	 * trigger the "send a ZLP?" confusion.
 	 */
 	rndis = (maxpacket & 0x3f) == 0
+		&& length > maxpacket
 		&& length < 0xffff
 		&& (length % maxpacket) != 0;
 
@@ -1228,27 +1229,7 @@
 
 				hw_ep = tx_ch->hw_ep;
 
-				/* Peripheral role never repurposes the
-				 * endpoint, so immediate completion is
-				 * safe.  Host role waits for the fifo
-				 * to empty (TXPKTRDY irq) before going
-				 * to the next queued bulk transfer.
-				 */
-				if (is_host_active(cppi->musb)) {
-#if 0
-					/* WORKAROUND because we may
-					 * not always get TXKPTRDY ...
-					 */
-					int	csr;
-
-					csr = musb_readw(hw_ep->regs,
-						MUSB_TXCSR);
-					if (csr & MUSB_TXCSR_TXPKTRDY)
-#endif
-						completed = false;
-				}
-				if (completed)
-					musb_dma_completion(musb, index + 1, 1);
+				musb_dma_completion(musb, index + 1, 1);
 
 			} else {
 				/* Bigger transfer than we could fit in
diff -urN linux-2.6.30-rc2/drivers/usb/musb/musb_core.c linux-2.6.30-rc3/drivers/usb/musb/musb_core.c
--- linux-2.6.30-rc2/drivers/usb/musb/musb_core.c	2009-04-22 03:29:11.860931356 +0000
+++ linux-2.6.30-rc3/drivers/usb/musb/musb_core.c	2009-04-22 03:29:17.909931392 +0000
@@ -2170,26 +2170,22 @@
 	return 0;
 }
 
-static int musb_resume(struct platform_device *pdev)
+static int musb_resume_early(struct platform_device *pdev)
 {
-	unsigned long	flags;
 	struct musb	*musb = dev_to_musb(&pdev->dev);
 
 	if (!musb->clock)
 		return 0;
 
-	spin_lock_irqsave(&musb->lock, flags);
-
 	if (musb->set_clock)
 		musb->set_clock(musb->clock, 1);
 	else
 		clk_enable(musb->clock);
 
 	/* for static cmos like DaVinci, register values were preserved
-	 * unless for some reason the whole soc powered down and we're
-	 * not treating that as a whole-system restart (e.g. swsusp)
+	 * unless for some reason the whole soc powered down or the USB
+	 * module got reset through the PSC (vs just being disabled).
 	 */
-	spin_unlock_irqrestore(&musb->lock, flags);
 	return 0;
 }
 
@@ -2207,7 +2203,7 @@
 	.remove		= __devexit_p(musb_remove),
 	.shutdown	= musb_shutdown,
 	.suspend	= musb_suspend,
-	.resume		= musb_resume,
+	.resume_early	= musb_resume_early,
 };
 
 /*-------------------------------------------------------------------------*/
diff -urN linux-2.6.30-rc2/drivers/usb/musb/musb_gadget.c linux-2.6.30-rc3/drivers/usb/musb/musb_gadget.c
--- linux-2.6.30-rc2/drivers/usb/musb/musb_gadget.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/musb/musb_gadget.c	2009-04-22 03:29:17.909931392 +0000
@@ -165,9 +165,15 @@
 	if (is_dma_capable() && ep->dma) {
 		struct dma_controller	*c = ep->musb->dma_controller;
 		int value;
+
 		if (ep->is_in) {
+			/*
+			 * The programming guide says that we must not clear
+			 * the DMAMODE bit before DMAENAB, so we only
+			 * clear it in the second write...
+			 */
 			musb_writew(epio, MUSB_TXCSR,
-					0 | MUSB_TXCSR_FLUSHFIFO);
+				    MUSB_TXCSR_DMAMODE | MUSB_TXCSR_FLUSHFIFO);
 			musb_writew(epio, MUSB_TXCSR,
 					0 | MUSB_TXCSR_FLUSHFIFO);
 		} else {
@@ -230,7 +236,7 @@
 		  |	IN token(s) are recd from Host.
 		  |		-> DMA interrupt on completion
 		  |		   calls TxAvail.
-		  |		      -> stop DMA, ~DmaEenab,
+		  |		      -> stop DMA, ~DMAENAB,
 		  |		      -> set TxPktRdy for last short pkt or zlp
 		  |		      -> Complete Request
 		  |		      -> Continue next request (call txstate)
@@ -315,9 +321,17 @@
 					request->dma, request_size);
 			if (use_dma) {
 				if (musb_ep->dma->desired_mode == 0) {
-					/* ASSERT: DMAENAB is clear */
-					csr &= ~(MUSB_TXCSR_AUTOSET |
-							MUSB_TXCSR_DMAMODE);
+					/*
+					 * We must not clear the DMAMODE bit
+					 * before the DMAENAB bit -- and the
+					 * latter doesn't always get cleared
+					 * before we get here...
+					 */
+					csr &= ~(MUSB_TXCSR_AUTOSET
+						| MUSB_TXCSR_DMAENAB);
+					musb_writew(epio, MUSB_TXCSR, csr
+						| MUSB_TXCSR_P_WZC_BITS);
+					csr &= ~MUSB_TXCSR_DMAMODE;
 					csr |= (MUSB_TXCSR_DMAENAB |
 							MUSB_TXCSR_MODE);
 					/* against programming guide */
@@ -334,10 +348,7 @@
 
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
 		/* program endpoint CSR first, then setup DMA */
-		csr &= ~(MUSB_TXCSR_AUTOSET
-				| MUSB_TXCSR_DMAMODE
-				| MUSB_TXCSR_P_UNDERRUN
-				| MUSB_TXCSR_TXPKTRDY);
+		csr &= ~(MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_TXPKTRDY);
 		csr |= MUSB_TXCSR_MODE | MUSB_TXCSR_DMAENAB;
 		musb_writew(epio, MUSB_TXCSR,
 			(MUSB_TXCSR_P_WZC_BITS & ~MUSB_TXCSR_P_UNDERRUN)
@@ -364,8 +375,8 @@
 		if (!use_dma) {
 			c->channel_release(musb_ep->dma);
 			musb_ep->dma = NULL;
-			/* ASSERT: DMAENAB clear */
-			csr &= ~(MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);
+			csr &= ~MUSB_TXCSR_DMAENAB;
+			musb_writew(epio, MUSB_TXCSR, csr);
 			/* invariant: prequest->buf is non-null */
 		}
 #elif defined(CONFIG_USB_TUSB_OMAP_DMA)
diff -urN linux-2.6.30-rc2/drivers/usb/musb/musb_host.c linux-2.6.30-rc3/drivers/usb/musb/musb_host.c
--- linux-2.6.30-rc2/drivers/usb/musb/musb_host.c	2009-04-22 03:29:11.861931541 +0000
+++ linux-2.6.30-rc3/drivers/usb/musb/musb_host.c	2009-04-22 03:29:17.911931263 +0000
@@ -4,6 +4,7 @@
  * Copyright 2005 Mentor Graphics Corporation
  * Copyright (C) 2005-2006 by Texas Instruments
  * Copyright (C) 2006-2007 Nokia Corporation
+ * Copyright (C) 2008-2009 MontaVista Software, Inc. <source@mvista.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -96,8 +97,8 @@
 
 
 static void musb_ep_program(struct musb *musb, u8 epnum,
-			struct urb *urb, unsigned int nOut,
-			u8 *buf, u32 len);
+			struct urb *urb, int is_out,
+			u8 *buf, u32 offset, u32 len);
 
 /*
  * Clear TX fifo. Needed to avoid BABBLE errors.
@@ -125,6 +126,29 @@
 	}
 }
 
+static void musb_h_ep0_flush_fifo(struct musb_hw_ep *ep)
+{
+	void __iomem	*epio = ep->regs;
+	u16		csr;
+	int		retries = 5;
+
+	/* scrub any data left in the fifo */
+	do {
+		csr = musb_readw(epio, MUSB_TXCSR);
+		if (!(csr & (MUSB_CSR0_TXPKTRDY | MUSB_CSR0_RXPKTRDY)))
+			break;
+		musb_writew(epio, MUSB_TXCSR, MUSB_CSR0_FLUSHFIFO);
+		csr = musb_readw(epio, MUSB_TXCSR);
+		udelay(10);
+	} while (--retries);
+
+	WARN(!retries, "Could not flush host TX%d fifo: csr: %04x\n",
+			ep->epnum, csr);
+
+	/* and reset for the next transfer */
+	musb_writew(epio, MUSB_TXCSR, 0);
+}
+
 /*
  * Start transmit. Caller is responsible for locking shared resources.
  * musb must be locked.
@@ -145,13 +169,15 @@
 
 }
 
-static inline void cppi_host_txdma_start(struct musb_hw_ep *ep)
+static inline void musb_h_tx_dma_start(struct musb_hw_ep *ep)
 {
 	u16	txcsr;
 
 	/* NOTE: no locks here; caller should lock and select EP */
 	txcsr = musb_readw(ep->regs, MUSB_TXCSR);
 	txcsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_H_WZC_BITS;
+	if (is_cppi_enabled())
+		txcsr |= MUSB_TXCSR_DMAMODE;
 	musb_writew(ep->regs, MUSB_TXCSR, txcsr);
 }
 
@@ -166,9 +192,10 @@
 {
 	u16			frame;
 	u32			len;
-	void			*buf;
 	void __iomem		*mbase =  musb->mregs;
 	struct urb		*urb = next_urb(qh);
+	void			*buf = urb->transfer_buffer;
+	u32			offset = 0;
 	struct musb_hw_ep	*hw_ep = qh->hw_ep;
 	unsigned		pipe = urb->pipe;
 	u8			address = usb_pipedevice(pipe);
@@ -191,7 +218,7 @@
 	case USB_ENDPOINT_XFER_ISOC:
 		qh->iso_idx = 0;
 		qh->frame = 0;
-		buf = urb->transfer_buffer + urb->iso_frame_desc[0].offset;
+		offset = urb->iso_frame_desc[0].offset;
 		len = urb->iso_frame_desc[0].length;
 		break;
 	default:		/* bulk, interrupt */
@@ -209,14 +236,14 @@
 			case USB_ENDPOINT_XFER_ISOC:	s = "-iso"; break;
 			default:			s = "-intr"; break;
 			}; s; }),
-			epnum, buf, len);
+			epnum, buf + offset, len);
 
 	/* Configure endpoint */
 	if (is_in || hw_ep->is_shared_fifo)
 		hw_ep->in_qh = qh;
 	else
 		hw_ep->out_qh = qh;
-	musb_ep_program(musb, epnum, urb, !is_in, buf, len);
+	musb_ep_program(musb, epnum, urb, !is_in, buf, offset, len);
 
 	/* transmit may have more work: start it when it is time */
 	if (is_in)
@@ -227,7 +254,6 @@
 	case USB_ENDPOINT_XFER_ISOC:
 	case USB_ENDPOINT_XFER_INT:
 		DBG(3, "check whether there's still time for periodic Tx\n");
-		qh->iso_idx = 0;
 		frame = musb_readw(mbase, MUSB_FRAME);
 		/* FIXME this doesn't implement that scheduling policy ...
 		 * or handle framecounter wrapping
@@ -256,7 +282,7 @@
 		if (!hw_ep->tx_channel)
 			musb_h_tx_start(hw_ep);
 		else if (is_cppi_enabled() || tusb_dma_omap())
-			cppi_host_txdma_start(hw_ep);
+			musb_h_tx_dma_start(hw_ep);
 	}
 }
 
@@ -567,10 +593,17 @@
 		csr = musb_readw(ep->regs, MUSB_TXCSR);
 		if (csr & MUSB_TXCSR_MODE) {
 			musb_h_tx_flush_fifo(ep);
+			csr = musb_readw(ep->regs, MUSB_TXCSR);
 			musb_writew(ep->regs, MUSB_TXCSR,
-					MUSB_TXCSR_FRCDATATOG);
+				    csr | MUSB_TXCSR_FRCDATATOG);
 		}
-		/* clear mode (and everything else) to enable Rx */
+
+		/*
+		 * Clear the MODE bit (and everything else) to enable Rx.
+		 * NOTE: we mustn't clear the DMAMODE bit before DMAENAB.
+		 */
+		if (csr & MUSB_TXCSR_DMAMODE)
+			musb_writew(ep->regs, MUSB_TXCSR, MUSB_TXCSR_DMAMODE);
 		musb_writew(ep->regs, MUSB_TXCSR, 0);
 
 	/* scrub all previous state, clearing toggle */
@@ -601,14 +634,68 @@
 	ep->rx_reinit = 0;
 }
 
+static bool musb_tx_dma_program(struct dma_controller *dma,
+		struct musb_hw_ep *hw_ep, struct musb_qh *qh,
+		struct urb *urb, u32 offset, u32 length)
+{
+	struct dma_channel	*channel = hw_ep->tx_channel;
+	void __iomem		*epio = hw_ep->regs;
+	u16			pkt_size = qh->maxpacket;
+	u16			csr;
+	u8			mode;
+
+#ifdef	CONFIG_USB_INVENTRA_DMA
+	if (length > channel->max_len)
+		length = channel->max_len;
+
+	csr = musb_readw(epio, MUSB_TXCSR);
+	if (length > pkt_size) {
+		mode = 1;
+		csr |= MUSB_TXCSR_AUTOSET
+			| MUSB_TXCSR_DMAMODE
+			| MUSB_TXCSR_DMAENAB;
+	} else {
+		mode = 0;
+		csr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAMODE);
+		csr |= MUSB_TXCSR_DMAENAB; /* against programmer's guide */
+	}
+	channel->desired_mode = mode;
+	musb_writew(epio, MUSB_TXCSR, csr);
+#else
+	if (!is_cppi_enabled() && !tusb_dma_omap())
+		return false;
+
+	channel->actual_len = 0;
+
+	/*
+	 * TX uses "RNDIS" mode automatically but needs help
+	 * to identify the zero-length-final-packet case.
+	 */
+	mode = (urb->transfer_flags & URB_ZERO_PACKET) ? 1 : 0;
+#endif
+
+	qh->segsize = length;
+
+	if (!dma->channel_program(channel, pkt_size, mode,
+			urb->transfer_dma + offset, length)) {
+		dma->channel_release(channel);
+		hw_ep->tx_channel = NULL;
+
+		csr = musb_readw(epio, MUSB_TXCSR);
+		csr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB);
+		musb_writew(epio, MUSB_TXCSR, csr | MUSB_TXCSR_H_WZC_BITS);
+		return false;
+	}
+	return true;
+}
 
 /*
  * Program an HDRC endpoint as per the given URB
  * Context: irqs blocked, controller lock held
  */
 static void musb_ep_program(struct musb *musb, u8 epnum,
-			struct urb *urb, unsigned int is_out,
-			u8 *buf, u32 len)
+			struct urb *urb, int is_out,
+			u8 *buf, u32 offset, u32 len)
 {
 	struct dma_controller	*dma_controller;
 	struct dma_channel	*dma_channel;
@@ -667,12 +754,17 @@
 
 		/* general endpoint setup */
 		if (epnum) {
-			/* ASSERT:  TXCSR_DMAENAB was already cleared */
-
 			/* flush all old state, set default */
 			musb_h_tx_flush_fifo(hw_ep);
+
+			/*
+			 * We must not clear the DMAMODE bit before or in
+			 * the same cycle with the DMAENAB bit, so we clear
+			 * the latter first...
+			 */
 			csr &= ~(MUSB_TXCSR_H_NAKTIMEOUT
-					| MUSB_TXCSR_DMAMODE
+					| MUSB_TXCSR_AUTOSET
+					| MUSB_TXCSR_DMAENAB
 					| MUSB_TXCSR_FRCDATATOG
 					| MUSB_TXCSR_H_RXSTALL
 					| MUSB_TXCSR_H_ERROR
@@ -680,24 +772,20 @@
 					);
 			csr |= MUSB_TXCSR_MODE;
 
-			if (usb_gettoggle(urb->dev,
-					qh->epnum, 1))
+			if (usb_gettoggle(urb->dev, qh->epnum, 1))
 				csr |= MUSB_TXCSR_H_WR_DATATOGGLE
 					| MUSB_TXCSR_H_DATATOGGLE;
 			else
 				csr |= MUSB_TXCSR_CLRDATATOG;
 
-			/* twice in case of double packet buffering */
 			musb_writew(epio, MUSB_TXCSR, csr);
 			/* REVISIT may need to clear FLUSHFIFO ... */
+			csr &= ~MUSB_TXCSR_DMAMODE;
 			musb_writew(epio, MUSB_TXCSR, csr);
 			csr = musb_readw(epio, MUSB_TXCSR);
 		} else {
 			/* endpoint 0: just flush */
-			musb_writew(epio, MUSB_CSR0,
-				csr | MUSB_CSR0_FLUSHFIFO);
-			musb_writew(epio, MUSB_CSR0,
-				csr | MUSB_CSR0_FLUSHFIFO);
+			musb_h_ep0_flush_fifo(hw_ep);
 		}
 
 		/* target addr and (for multipoint) hub addr/port */
@@ -734,113 +822,14 @@
 		else
 			load_count = min((u32) packet_sz, len);
 
-#ifdef CONFIG_USB_INVENTRA_DMA
-		if (dma_channel) {
-
-			/* clear previous state */
-			csr = musb_readw(epio, MUSB_TXCSR);
-			csr &= ~(MUSB_TXCSR_AUTOSET
-				| MUSB_TXCSR_DMAMODE
-				| MUSB_TXCSR_DMAENAB);
-			csr |= MUSB_TXCSR_MODE;
-			musb_writew(epio, MUSB_TXCSR,
-				csr | MUSB_TXCSR_MODE);
-
-			qh->segsize = min(len, dma_channel->max_len);
-
-			if (qh->segsize <= packet_sz)
-				dma_channel->desired_mode = 0;
-			else
-				dma_channel->desired_mode = 1;
-
-
-			if (dma_channel->desired_mode == 0) {
-				csr &= ~(MUSB_TXCSR_AUTOSET
-					| MUSB_TXCSR_DMAMODE);
-				csr |= (MUSB_TXCSR_DMAENAB);
-					/* against programming guide */
-			} else
-				csr |= (MUSB_TXCSR_AUTOSET
-					| MUSB_TXCSR_DMAENAB
-					| MUSB_TXCSR_DMAMODE);
-
-			musb_writew(epio, MUSB_TXCSR, csr);
-
-			dma_ok = dma_controller->channel_program(
-					dma_channel, packet_sz,
-					dma_channel->desired_mode,
-					urb->transfer_dma,
-					qh->segsize);
-			if (dma_ok) {
-				load_count = 0;
-			} else {
-				dma_controller->channel_release(dma_channel);
-				if (is_out)
-					hw_ep->tx_channel = NULL;
-				else
-					hw_ep->rx_channel = NULL;
-				dma_channel = NULL;
-			}
-		}
-#endif
-
-		/* candidate for DMA */
-		if ((is_cppi_enabled() || tusb_dma_omap()) && dma_channel) {
-
-			/* program endpoint CSRs first, then setup DMA.
-			 * assume CPPI setup succeeds.
-			 * defer enabling dma.
-			 */
-			csr = musb_readw(epio, MUSB_TXCSR);
-			csr &= ~(MUSB_TXCSR_AUTOSET
-					| MUSB_TXCSR_DMAMODE
-					| MUSB_TXCSR_DMAENAB);
-			csr |= MUSB_TXCSR_MODE;
-			musb_writew(epio, MUSB_TXCSR,
-				csr | MUSB_TXCSR_MODE);
-
-			dma_channel->actual_len = 0L;
-			qh->segsize = len;
-
-			/* TX uses "rndis" mode automatically, but needs help
-			 * to identify the zero-length-final-packet case.
-			 */
-			dma_ok = dma_controller->channel_program(
-					dma_channel, packet_sz,
-					(urb->transfer_flags
-							& URB_ZERO_PACKET)
-						== URB_ZERO_PACKET,
-					urb->transfer_dma,
-					qh->segsize);
-			if (dma_ok) {
-				load_count = 0;
-			} else {
-				dma_controller->channel_release(dma_channel);
-				hw_ep->tx_channel = NULL;
-				dma_channel = NULL;
-
-				/* REVISIT there's an error path here that
-				 * needs handling:  can't do dma, but
-				 * there's no pio buffer address...
-				 */
-			}
-		}
+		if (dma_channel && musb_tx_dma_program(dma_controller,
+					hw_ep, qh, urb, offset, len))
+			load_count = 0;
 
 		if (load_count) {
-			/* ASSERT:  TXCSR_DMAENAB was already cleared */
-
 			/* PIO to load FIFO */
 			qh->segsize = load_count;
 			musb_write_fifo(hw_ep, load_count, buf);
-			csr = musb_readw(epio, MUSB_TXCSR);
-			csr &= ~(MUSB_TXCSR_DMAENAB
-				| MUSB_TXCSR_DMAMODE
-				| MUSB_TXCSR_AUTOSET);
-			/* write CSR */
-			csr |= MUSB_TXCSR_MODE;
-
-			if (epnum)
-				musb_writew(epio, MUSB_TXCSR, csr);
 		}
 
 		/* re-enable interrupt */
@@ -895,7 +884,7 @@
 						dma_channel, packet_sz,
 						!(urb->transfer_flags
 							& URB_SHORT_NOT_OK),
-						urb->transfer_dma,
+						urb->transfer_dma + offset,
 						qh->segsize);
 				if (!dma_ok) {
 					dma_controller->channel_release(
@@ -1063,11 +1052,7 @@
 			csr &= ~MUSB_CSR0_H_NAKTIMEOUT;
 			musb_writew(epio, MUSB_CSR0, csr);
 		} else {
-			csr |= MUSB_CSR0_FLUSHFIFO;
-			musb_writew(epio, MUSB_CSR0, csr);
-			musb_writew(epio, MUSB_CSR0, csr);
-			csr &= ~MUSB_CSR0_H_NAKTIMEOUT;
-			musb_writew(epio, MUSB_CSR0, csr);
+			musb_h_ep0_flush_fifo(hw_ep);
 		}
 
 		musb_writeb(epio, MUSB_NAKLIMIT0, 0);
@@ -1081,10 +1066,7 @@
 		 * SHOULD NEVER HAPPEN! */
 		ERR("no URB for end 0\n");
 
-		musb_writew(epio, MUSB_CSR0, MUSB_CSR0_FLUSHFIFO);
-		musb_writew(epio, MUSB_CSR0, MUSB_CSR0_FLUSHFIFO);
-		musb_writew(epio, MUSB_CSR0, 0);
-
+		musb_h_ep0_flush_fifo(hw_ep);
 		goto done;
 	}
 
@@ -1145,8 +1127,8 @@
 	int			pipe;
 	bool			done = false;
 	u16			tx_csr;
-	size_t			wLength = 0;
-	u8			*buf = NULL;
+	size_t			length = 0;
+	size_t			offset = 0;
 	struct urb		*urb;
 	struct musb_hw_ep	*hw_ep = musb->endpoints + epnum;
 	void __iomem		*epio = hw_ep->regs;
@@ -1164,7 +1146,7 @@
 	/* with CPPI, DMA sometimes triggers "extra" irqs */
 	if (!urb) {
 		DBG(4, "extra TX%d ready, csr %04x\n", epnum, tx_csr);
-		goto finish;
+		return;
 	}
 
 	pipe = urb->pipe;
@@ -1201,7 +1183,7 @@
 		musb_writew(epio, MUSB_TXCSR,
 				MUSB_TXCSR_H_WZC_BITS
 				| MUSB_TXCSR_TXPKTRDY);
-		goto finish;
+		return;
 	}
 
 	if (status) {
@@ -1233,29 +1215,89 @@
 	/* second cppi case */
 	if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
 		DBG(4, "extra TX%d ready, csr %04x\n", epnum, tx_csr);
-		goto finish;
+		return;
+	}
+
+	if (is_dma_capable() && dma && !status) {
+		/*
+		 * DMA has completed.  But if we're using DMA mode 1 (multi
+		 * packet DMA), we need a terminal TXPKTRDY interrupt before
+		 * we can consider this transfer completed, lest we trash
+		 * its last packet when writing the next URB's data.  So we
+		 * switch back to mode 0 to get that interrupt; we'll come
+		 * back here once it happens.
+		 */
+		if (tx_csr & MUSB_TXCSR_DMAMODE) {
+			/*
+			 * We shouldn't clear DMAMODE with DMAENAB set; so
+			 * clear them in a safe order.  That should be OK
+			 * once TXPKTRDY has been set (and I've never seen
+			 * it being 0 at this moment -- DMA interrupt latency
+			 * is significant) but if it hasn't been then we have
+			 * no choice but to stop being polite and ignore the
+			 * programmer's guide... :-)
+			 *
+			 * Note that we must write TXCSR with TXPKTRDY cleared
+			 * in order not to re-trigger the packet send (this bit
+			 * can't be cleared by CPU), and there's another caveat:
+			 * TXPKTRDY may be set shortly and then cleared in the
+			 * double-buffered FIFO mode, so we do an extra TXCSR
+			 * read for debouncing...
+			 */
+			tx_csr &= musb_readw(epio, MUSB_TXCSR);
+			if (tx_csr & MUSB_TXCSR_TXPKTRDY) {
+				tx_csr &= ~(MUSB_TXCSR_DMAENAB |
+					    MUSB_TXCSR_TXPKTRDY);
+				musb_writew(epio, MUSB_TXCSR,
+					    tx_csr | MUSB_TXCSR_H_WZC_BITS);
+			}
+			tx_csr &= ~(MUSB_TXCSR_DMAMODE |
+				    MUSB_TXCSR_TXPKTRDY);
+			musb_writew(epio, MUSB_TXCSR,
+				    tx_csr | MUSB_TXCSR_H_WZC_BITS);
+
+			/*
+			 * There is no guarantee that we'll get an interrupt
+			 * after clearing DMAMODE as we might have done this
+			 * too late (after TXPKTRDY was cleared by controller).
+			 * Re-read TXCSR as we have spoiled its previous value.
+			 */
+			tx_csr = musb_readw(epio, MUSB_TXCSR);
+		}
 
+		/*
+		 * We may get here from a DMA completion or TXPKTRDY interrupt.
+		 * In any case, we must check the FIFO status here and bail out
+		 * only if the FIFO still has data -- that should prevent the
+		 * "missed" TXPKTRDY interrupts and deal with double-buffered
+		 * FIFO mode too...
+		 */
+		if (tx_csr & (MUSB_TXCSR_FIFONOTEMPTY | MUSB_TXCSR_TXPKTRDY)) {
+			DBG(2, "DMA complete but packet still in FIFO, "
+			    "CSR %04x\n", tx_csr);
+			return;
+		}
 	}
 
-	/* REVISIT this looks wrong... */
 	if (!status || dma || usb_pipeisoc(pipe)) {
 		if (dma)
-			wLength = dma->actual_len;
+			length = dma->actual_len;
 		else
-			wLength = qh->segsize;
-		qh->offset += wLength;
+			length = qh->segsize;
+		qh->offset += length;
 
 		if (usb_pipeisoc(pipe)) {
 			struct usb_iso_packet_descriptor	*d;
 
 			d = urb->iso_frame_desc + qh->iso_idx;
-			d->actual_length = qh->segsize;
+			d->actual_length = length;
+			d->status = status;
 			if (++qh->iso_idx >= urb->number_of_packets) {
 				done = true;
 			} else {
 				d++;
-				buf = urb->transfer_buffer + d->offset;
-				wLength = d->length;
+				offset = d->offset;
+				length = d->length;
 			}
 		} else if (dma) {
 			done = true;
@@ -1268,10 +1310,8 @@
 						& URB_ZERO_PACKET))
 				done = true;
 			if (!done) {
-				buf = urb->transfer_buffer
-						+ qh->offset;
-				wLength = urb->transfer_buffer_length
-						- qh->offset;
+				offset = qh->offset;
+				length = urb->transfer_buffer_length - offset;
 			}
 		}
 	}
@@ -1290,28 +1330,31 @@
 		urb->status = status;
 		urb->actual_length = qh->offset;
 		musb_advance_schedule(musb, urb, hw_ep, USB_DIR_OUT);
+		return;
+	} else	if (usb_pipeisoc(pipe) && dma) {
+		if (musb_tx_dma_program(musb->dma_controller, hw_ep, qh, urb,
+				offset, length))
+			return;
+	} else	if (tx_csr & MUSB_TXCSR_DMAENAB) {
+		DBG(1, "not complete, but DMA enabled?\n");
+		return;
+	}
 
-	} else if (!(tx_csr & MUSB_TXCSR_DMAENAB)) {
-		/* WARN_ON(!buf); */
-
-		/* REVISIT:  some docs say that when hw_ep->tx_double_buffered,
-		 * (and presumably, fifo is not half-full) we should write TWO
-		 * packets before updating TXCSR ... other docs disagree ...
-		 */
-		/* PIO:  start next packet in this URB */
-		if (wLength > qh->maxpacket)
-			wLength = qh->maxpacket;
-		musb_write_fifo(hw_ep, wLength, buf);
-		qh->segsize = wLength;
-
-		musb_ep_select(mbase, epnum);
-		musb_writew(epio, MUSB_TXCSR,
-				MUSB_TXCSR_H_WZC_BITS | MUSB_TXCSR_TXPKTRDY);
-	} else
-		DBG(1, "not complete, but dma enabled?\n");
+	/*
+	 * PIO: start next packet in this URB.
+	 *
+	 * REVISIT: some docs say that when hw_ep->tx_double_buffered,
+	 * (and presumably, FIFO is not half-full) we should write *two*
+	 * packets before updating TXCSR; other docs disagree...
+	 */
+	if (length > qh->maxpacket)
+		length = qh->maxpacket;
+	musb_write_fifo(hw_ep, length, urb->transfer_buffer + offset);
+	qh->segsize = length;
 
-finish:
-	return;
+	musb_ep_select(mbase, epnum);
+	musb_writew(epio, MUSB_TXCSR,
+			MUSB_TXCSR_H_WZC_BITS | MUSB_TXCSR_TXPKTRDY);
 }
 
 
@@ -1841,7 +1884,7 @@
 	unsigned long			flags;
 	struct musb			*musb = hcd_to_musb(hcd);
 	struct usb_host_endpoint	*hep = urb->ep;
-	struct musb_qh			*qh = hep->hcpriv;
+	struct musb_qh			*qh;
 	struct usb_endpoint_descriptor	*epd = &hep->desc;
 	int				ret;
 	unsigned			type_reg;
@@ -1853,22 +1896,21 @@
 
 	spin_lock_irqsave(&musb->lock, flags);
 	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	qh = ret ? NULL : hep->hcpriv;
+	if (qh)
+		urb->hcpriv = qh;
 	spin_unlock_irqrestore(&musb->lock, flags);
-	if (ret)
-		return ret;
 
 	/* DMA mapping was already done, if needed, and this urb is on
-	 * hep->urb_list ... so there's little to do unless hep wasn't
-	 * yet scheduled onto a live qh.
+	 * hep->urb_list now ... so we're done, unless hep wasn't yet
+	 * scheduled onto a live qh.
 	 *
 	 * REVISIT best to keep hep->hcpriv valid until the endpoint gets
 	 * disabled, testing for empty qh->ring and avoiding qh setup costs
 	 * except for the first urb queued after a config change.
 	 */
-	if (qh) {
-		urb->hcpriv = qh;
-		return 0;
-	}
+	if (qh || ret)
+		return ret;
 
 	/* Allocate and initialize qh, minimizing the work done each time
 	 * hw_ep gets reprogrammed, or with irqs blocked.  Then schedule it.
@@ -2044,7 +2086,7 @@
 		 * endpoint's irq status here to avoid bogus irqs.
 		 * clearing that status is platform-specific...
 		 */
-	} else {
+	} else if (ep->epnum) {
 		musb_h_tx_flush_fifo(ep);
 		csr = musb_readw(epio, MUSB_TXCSR);
 		csr &= ~(MUSB_TXCSR_AUTOSET
@@ -2058,6 +2100,8 @@
 		musb_writew(epio, MUSB_TXCSR, csr);
 		/* flush cpu writebuffer */
 		csr = musb_readw(epio, MUSB_TXCSR);
+	} else  {
+		musb_h_ep0_flush_fifo(ep);
 	}
 	if (status == 0)
 		musb_advance_schedule(ep->musb, urb, ep, is_in);
diff -urN linux-2.6.30-rc2/drivers/usb/musb/musbhsdma.c linux-2.6.30-rc3/drivers/usb/musb/musbhsdma.c
--- linux-2.6.30-rc2/drivers/usb/musb/musbhsdma.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/musb/musbhsdma.c	2009-04-22 03:29:17.911931263 +0000
@@ -195,30 +195,32 @@
 	void __iomem *mbase = musb_channel->controller->base;
 
 	u8 bchannel = musb_channel->idx;
+	int offset;
 	u16 csr;
 
 	if (channel->status == MUSB_DMA_STATUS_BUSY) {
 		if (musb_channel->transmit) {
+			offset = MUSB_EP_OFFSET(musb_channel->epnum,
+						MUSB_TXCSR);
 
-			csr = musb_readw(mbase,
-				MUSB_EP_OFFSET(musb_channel->epnum,
-						MUSB_TXCSR));
-			csr &= ~(MUSB_TXCSR_AUTOSET |
-				 MUSB_TXCSR_DMAENAB |
-				 MUSB_TXCSR_DMAMODE);
-			musb_writew(mbase,
-				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_TXCSR),
-				csr);
+			/*
+			 * The programming guide says that we must clear
+			 * the DMAENAB bit before the DMAMODE bit...
+			 */
+			csr = musb_readw(mbase, offset);
+			csr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB);
+			musb_writew(mbase, offset, csr);
+			csr &= ~MUSB_TXCSR_DMAMODE;
+			musb_writew(mbase, offset, csr);
 		} else {
-			csr = musb_readw(mbase,
-				MUSB_EP_OFFSET(musb_channel->epnum,
-						MUSB_RXCSR));
+			offset = MUSB_EP_OFFSET(musb_channel->epnum,
+						MUSB_RXCSR);
+
+			csr = musb_readw(mbase, offset);
 			csr &= ~(MUSB_RXCSR_AUTOCLEAR |
 				 MUSB_RXCSR_DMAENAB |
 				 MUSB_RXCSR_DMAMODE);
-			musb_writew(mbase,
-				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_RXCSR),
-				csr);
+			musb_writew(mbase, offset, csr);
 		}
 
 		musb_writew(mbase,
@@ -296,20 +298,28 @@
 					&& ((channel->desired_mode == 0)
 					    || (channel->actual_len &
 					    (musb_channel->max_packet_sz - 1)))
-					 ) {
+				    ) {
+					u8  epnum  = musb_channel->epnum;
+					int offset = MUSB_EP_OFFSET(epnum,
+								    MUSB_TXCSR);
+					u16 txcsr;
+
+					/*
+					 * The programming guide says that we
+					 * must clear DMAENAB before DMAMODE.
+					 */
+					musb_ep_select(mbase, epnum);
+					txcsr = musb_readw(mbase, offset);
+					txcsr &= ~(MUSB_TXCSR_DMAENAB
+							| MUSB_TXCSR_AUTOSET);
+					musb_writew(mbase, offset, txcsr);
 					/* Send out the packet */
-					musb_ep_select(mbase,
-						musb_channel->epnum);
-					musb_writew(mbase, MUSB_EP_OFFSET(
-							musb_channel->epnum,
-							MUSB_TXCSR),
-						MUSB_TXCSR_TXPKTRDY);
-				} else {
-					musb_dma_completion(
-						musb,
-						musb_channel->epnum,
-						musb_channel->transmit);
+					txcsr &= ~MUSB_TXCSR_DMAMODE;
+					txcsr |=  MUSB_TXCSR_TXPKTRDY;
+					musb_writew(mbase, offset, txcsr);
 				}
+				musb_dma_completion(musb, musb_channel->epnum,
+						    musb_channel->transmit);
 			}
 		}
 	}
diff -urN linux-2.6.30-rc2/drivers/usb/serial/ftdi_sio.c linux-2.6.30-rc3/drivers/usb/serial/ftdi_sio.c
--- linux-2.6.30-rc2/drivers/usb/serial/ftdi_sio.c	2009-04-22 03:29:11.864931378 +0000
+++ linux-2.6.30-rc3/drivers/usb/serial/ftdi_sio.c	2009-04-22 03:29:17.914931206 +0000
@@ -668,6 +668,7 @@
 	{ USB_DEVICE(DE_VID, WHT_PID) },
 	{ USB_DEVICE(ADI_VID, ADI_GNICE_PID),
 		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
+	{ USB_DEVICE(JETI_VID, JETI_SPC1201_PID) },
 	{ },					/* Optional parameter entry */
 	{ }					/* Terminating entry */
 };
diff -urN linux-2.6.30-rc2/drivers/usb/serial/ftdi_sio.h linux-2.6.30-rc3/drivers/usb/serial/ftdi_sio.h
--- linux-2.6.30-rc2/drivers/usb/serial/ftdi_sio.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/serial/ftdi_sio.h	2009-04-22 03:29:17.914931206 +0000
@@ -913,6 +913,13 @@
 #define ADI_GNICE_PID 		0xF000
 
 /*
+ * JETI SPECTROMETER SPECBOS 1201
+ * http://www.jeti.com/products/sys/scb/scb1201.php
+ */
+#define JETI_VID		0x0c6c
+#define JETI_SPC1201_PID	0x04b2
+
+/*
  *   BmRequestType:  1100 0000b
  *   bRequest:       FTDI_E2_READ
  *   wValue:         0
diff -urN linux-2.6.30-rc2/drivers/usb/serial/moto_modem.c linux-2.6.30-rc3/drivers/usb/serial/moto_modem.c
--- linux-2.6.30-rc2/drivers/usb/serial/moto_modem.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/serial/moto_modem.c	2009-04-22 03:29:17.916931524 +0000
@@ -25,6 +25,7 @@
 	{ USB_DEVICE(0x05c6, 0x3197) },	/* unknown Motorola phone */
 	{ USB_DEVICE(0x0c44, 0x0022) },	/* unknown Mororola phone */
 	{ USB_DEVICE(0x22b8, 0x2a64) },	/* Motorola KRZR K1m */
+	{ USB_DEVICE(0x22b8, 0x2c64) }, /* Motorola V950 phone */
 	{ },
 };
 MODULE_DEVICE_TABLE(usb, id_table);
diff -urN linux-2.6.30-rc2/drivers/usb/serial/option.c linux-2.6.30-rc3/drivers/usb/serial/option.c
--- linux-2.6.30-rc2/drivers/usb/serial/option.c	2009-04-22 03:29:11.866931442 +0000
+++ linux-2.6.30-rc3/drivers/usb/serial/option.c	2009-04-22 03:29:17.916931524 +0000
@@ -300,6 +300,10 @@
 #define BENQ_VENDOR_ID				0x04a5
 #define BENQ_PRODUCT_H10			0x4068
 
+#define DLINK_VENDOR_ID				0x1186
+#define DLINK_PRODUCT_DWM_652			0x3e04
+
+
 static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
@@ -516,6 +520,7 @@
 	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_MF628) },
 	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH) },
 	{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_H10) },
+	{ USB_DEVICE(DLINK_VENDOR_ID, DLINK_PRODUCT_DWM_652) },
 	{ USB_DEVICE(0x1da5, 0x4515) }, /* BenQ H20 */
 	{ } /* Terminating entry */
 };
diff -urN linux-2.6.30-rc2/drivers/usb/serial/qcserial.c linux-2.6.30-rc3/drivers/usb/serial/qcserial.c
--- linux-2.6.30-rc2/drivers/usb/serial/qcserial.c	2009-04-22 03:29:11.867931395 +0000
+++ linux-2.6.30-rc3/drivers/usb/serial/qcserial.c	2009-04-22 03:29:17.917931361 +0000
@@ -26,6 +26,27 @@
 	{USB_DEVICE(0x05c6, 0x9212)},	/* Acer Gobi Modem Device */
 	{USB_DEVICE(0x03f0, 0x1f1d)},	/* HP un2400 Gobi Modem Device */
 	{USB_DEVICE(0x03f0, 0x201d)},	/* HP un2400 Gobi QDL Device */
+	{USB_DEVICE(0x04da, 0x250d)},	/* Panasonic Gobi Modem device */
+	{USB_DEVICE(0x04da, 0x250c)},	/* Panasonic Gobi QDL device */
+	{USB_DEVICE(0x413c, 0x8172)},	/* Dell Gobi Modem device */
+	{USB_DEVICE(0x413c, 0x8171)},	/* Dell Gobi QDL device */
+	{USB_DEVICE(0x1410, 0xa001)},	/* Novatel Gobi Modem device */
+	{USB_DEVICE(0x1410, 0xa008)},	/* Novatel Gobi QDL device */
+	{USB_DEVICE(0x0b05, 0x1776)},	/* Asus Gobi Modem device */
+	{USB_DEVICE(0x0b05, 0x1774)},	/* Asus Gobi QDL device */
+	{USB_DEVICE(0x19d2, 0xfff3)},	/* ONDA Gobi Modem device */
+	{USB_DEVICE(0x19d2, 0xfff2)},	/* ONDA Gobi QDL device */
+	{USB_DEVICE(0x1557, 0x0a80)},	/* OQO Gobi QDL device */
+	{USB_DEVICE(0x05c6, 0x9001)},   /* Generic Gobi Modem device */
+	{USB_DEVICE(0x05c6, 0x9002)},	/* Generic Gobi Modem device */
+	{USB_DEVICE(0x05c6, 0x9202)},	/* Generic Gobi Modem device */
+	{USB_DEVICE(0x05c6, 0x9203)},	/* Generic Gobi Modem device */
+	{USB_DEVICE(0x05c6, 0x9222)},	/* Generic Gobi Modem device */
+	{USB_DEVICE(0x05c6, 0x9008)},	/* Generic Gobi QDL device */
+	{USB_DEVICE(0x05c6, 0x9201)},	/* Generic Gobi QDL device */
+	{USB_DEVICE(0x05c6, 0x9221)},	/* Generic Gobi QDL device */
+	{USB_DEVICE(0x05c6, 0x9231)},	/* Generic Gobi QDL device */
+	{USB_DEVICE(0x1f45, 0x0001)},	/* Unknown Gobi QDL device */
 	{ }				/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, id_table);
diff -urN linux-2.6.30-rc2/drivers/usb/storage/Makefile linux-2.6.30-rc3/drivers/usb/storage/Makefile
--- linux-2.6.30-rc2/drivers/usb/storage/Makefile	2009-04-22 03:29:11.868931301 +0000
+++ linux-2.6.30-rc3/drivers/usb/storage/Makefile	2009-04-22 03:29:17.918931435 +0000
@@ -17,7 +17,8 @@
 ifeq ($(CONFIG_USB_LIBUSUAL),)
 	usb-storage-objs	+= usual-tables.o
 else
-	obj-$(CONFIG_USB)	+= libusual.o usual-tables.o
+	obj-$(CONFIG_USB)	+= usb-libusual.o
+	usb-libusual-objs	:= libusual.o usual-tables.o
 endif
 
 obj-$(CONFIG_USB_STORAGE_ALAUDA)	+= ums-alauda.o
diff -urN linux-2.6.30-rc2/drivers/usb/storage/transport.c linux-2.6.30-rc3/drivers/usb/storage/transport.c
--- linux-2.6.30-rc2/drivers/usb/storage/transport.c	2009-04-22 03:29:11.874931405 +0000
+++ linux-2.6.30-rc3/drivers/usb/storage/transport.c	2009-04-22 03:29:17.924931520 +0000
@@ -247,10 +247,8 @@
 		USB_ENDPOINT_HALT, endp,
 		NULL, 0, 3*HZ);
 
-	/* reset the endpoint toggle */
 	if (result >= 0)
-		usb_settoggle(us->pusb_dev, usb_pipeendpoint(pipe),
-				usb_pipeout(pipe), 0);
+		usb_reset_endpoint(us->pusb_dev, endp);
 
 	US_DEBUGP("%s: result = %d\n", __func__, result);
 	return result;
diff -urN linux-2.6.30-rc2/drivers/usb/storage/unusual_devs.h linux-2.6.30-rc3/drivers/usb/storage/unusual_devs.h
--- linux-2.6.30-rc2/drivers/usb/storage/unusual_devs.h	2009-04-22 03:29:11.875931472 +0000
+++ linux-2.6.30-rc3/drivers/usb/storage/unusual_devs.h	2009-04-22 03:29:17.925931432 +0000
@@ -975,12 +975,14 @@
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY | US_FL_FIX_CAPACITY ),
 
-/* Reported by Rauch Wolke <rauchwolke@gmx.net> */
+/* Reported by Rauch Wolke <rauchwolke@gmx.net>
+ * and augmented by binbin <binbinsh@gmail.com> (Bugzilla #12882)
+ */
 UNUSUAL_DEV(  0x07c4, 0xa4a5, 0x0000, 0xffff,
 		"Simple Tech/Datafab",
 		"CF+SM Reader",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_IGNORE_RESIDUE ),
+		US_FL_IGNORE_RESIDUE | US_FL_MAX_SECTORS_64 ),
 
 /* Casio QV 2x00/3x00/4000/8000 digital still cameras are not conformant
  * to the USB storage specification in two ways:
@@ -1376,6 +1378,14 @@
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		0),
 
+/* Reported by Pascal Terjan <pterjan@mandriva.com>
+ * Ignore driver CD mode and force into modem mode by default.
+ */
+UNUSUAL_DEV(  0x1186, 0x3e04, 0x0000, 0x0000,
+           "D-Link",
+           "USB Mass Storage",
+           US_SC_DEVICE, US_PR_DEVICE, option_ms_init, 0),
+
 /* Reported by Kevin Lloyd <linux@sierrawireless.com>
  * Entry is needed for the initializer function override,
  * which instructs the device to load as a modem
diff -urN linux-2.6.30-rc2/drivers/usb/wusbcore/devconnect.c linux-2.6.30-rc3/drivers/usb/wusbcore/devconnect.c
--- linux-2.6.30-rc2/drivers/usb/wusbcore/devconnect.c	2009-04-22 03:29:11.877931578 +0000
+++ linux-2.6.30-rc3/drivers/usb/wusbcore/devconnect.c	2009-04-22 03:29:17.927931603 +0000
@@ -267,6 +267,8 @@
 	mutex_lock(&wusbhc->mutex);
 	wusbhc_devconnect_acked(wusbhc, wusb_dev);
 	mutex_unlock(&wusbhc->mutex);
+
+	wusb_dev_put(wusb_dev);
 }
 
 /*
@@ -396,7 +398,8 @@
 
 	/* After a device disconnects, change the GTK (see [WUSB]
 	 * section 6.2.11.2). */
-	wusbhc_gtk_rekey(wusbhc);
+	if (wusbhc->active)
+		wusbhc_gtk_rekey(wusbhc);
 
 	/* The Wireless USB part has forgotten about the device already; now
 	 * khubd's timer will pick up the disconnection and remove the USB
@@ -1084,15 +1087,21 @@
  * wusbhc_devconnect_stop - stop managing connected devices
  * @wusbhc: the WUSB HC
  *
- * Removes the Host Info IE and stops the keep alives.
- *
- * FIXME: should this disconnect all devices?
+ * Disconnects any devices still connected, stops the keep alives and
+ * removes the Host Info IE.
  */
 void wusbhc_devconnect_stop(struct wusbhc *wusbhc)
 {
-	cancel_delayed_work_sync(&wusbhc->keep_alive_timer);
-	WARN_ON(!list_empty(&wusbhc->cack_list));
+	int i;
 
+	mutex_lock(&wusbhc->mutex);
+	for (i = 0; i < wusbhc->ports_max; i++) {
+		if (wusbhc->port[i].wusb_dev)
+			__wusbhc_dev_disconnect(wusbhc, &wusbhc->port[i]);
+	}
+	mutex_unlock(&wusbhc->mutex);
+
+	cancel_delayed_work_sync(&wusbhc->keep_alive_timer);
 	wusbhc_mmcie_rm(wusbhc, &wusbhc->wuie_host_info->hdr);
 	kfree(wusbhc->wuie_host_info);
 	wusbhc->wuie_host_info = NULL;
diff -urN linux-2.6.30-rc2/drivers/usb/wusbcore/wusbhc.c linux-2.6.30-rc3/drivers/usb/wusbcore/wusbhc.c
--- linux-2.6.30-rc2/drivers/usb/wusbcore/wusbhc.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/usb/wusbcore/wusbhc.c	2009-04-22 03:29:17.927931603 +0000
@@ -88,33 +88,31 @@
 					     wusb_trust_timeout_store);
 
 /*
- * Show & store the current WUSB CHID
+ * Show the current WUSB CHID.
  */
 static ssize_t wusb_chid_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
 	struct wusbhc *wusbhc = usbhc_dev_to_wusbhc(dev);
+	const struct wusb_ckhdid *chid;
 	ssize_t result = 0;
 
 	if (wusbhc->wuie_host_info != NULL)
-		result += ckhdid_printf(buf, PAGE_SIZE,
-					&wusbhc->wuie_host_info->CHID);
+		chid = &wusbhc->wuie_host_info->CHID;
+	else
+		chid = &wusb_ckhdid_zero;
+
+	result += ckhdid_printf(buf, PAGE_SIZE, chid);
+	result += sprintf(buf + result, "\n");
+
 	return result;
 }
 
 /*
- * Store a new CHID
- *
- * This will (FIXME) trigger many changes.
+ * Store a new CHID.
  *
- * - Send an all zeros CHID and it will stop the controller
- * - Send a non-zero CHID and it will start it
- *   (unless it was started, it will just change the CHID,
- *   diconnecting all devices first).
- *
- * So first we scan the MMC we are sent and then we act on it.  We
- * read it in the same format as we print it, an ASCII string of 16
- * hex bytes.
+ * - Write an all zeros CHID and it will stop the controller
+ * - Write a non-zero CHID and it will start it.
  *
  * See wusbhc_chid_set() for more info.
  */
@@ -339,13 +337,15 @@
 {
 	struct wusb_dev *wusb_dev = __wusb_dev_get_by_usb_dev(wusbhc, urb->dev);
 
-	if (status == 0) {
+	if (status == 0 && wusb_dev) {
 		wusb_dev->entry_ts = jiffies;
 
-		/* wusbhc_devconnect_acked() can't be called from from
+		/* wusbhc_devconnect_acked() can't be called from
 		   atomic context so defer it to a work queue. */
 		if (!list_empty(&wusb_dev->cack_node))
 			queue_work(wusbd, &wusb_dev->devconnect_acked_work);
+		else
+			wusb_dev_put(wusb_dev);
 	}
 
 	usb_hcd_giveback_urb(&wusbhc->usb_hcd, urb, status);
diff -urN linux-2.6.30-rc2/drivers/video/asiliantfb.c linux-2.6.30-rc3/drivers/video/asiliantfb.c
--- linux-2.6.30-rc2/drivers/video/asiliantfb.c	2009-04-22 03:29:11.880931259 +0000
+++ linux-2.6.30-rc3/drivers/video/asiliantfb.c	2009-04-22 03:29:17.930931552 +0000
@@ -533,6 +533,7 @@
 
 	writeb(0xff, mmio_base + 0x78c);
 	chips_hw_init(p);
+	return 0;
 }
 
 static int __devinit
diff -urN linux-2.6.30-rc2/drivers/video/pxafb.c linux-2.6.30-rc3/drivers/video/pxafb.c
--- linux-2.6.30-rc2/drivers/video/pxafb.c	2009-04-22 03:29:11.894931436 +0000
+++ linux-2.6.30-rc3/drivers/video/pxafb.c	2009-04-22 03:29:17.944931411 +0000
@@ -1439,7 +1439,7 @@
 static irqreturn_t pxafb_handle_irq(int irq, void *dev_id)
 {
 	struct pxafb_info *fbi = dev_id;
-	unsigned int lccr0, lcsr, lcsr1;
+	unsigned int lccr0, lcsr;
 
 	lcsr = lcd_readl(fbi, LCSR);
 	if (lcsr & LCSR_LDD) {
@@ -1455,14 +1455,16 @@
 	lcd_writel(fbi, LCSR, lcsr);
 
 #ifdef CONFIG_FB_PXA_OVERLAY
-	lcsr1 = lcd_readl(fbi, LCSR1);
-	if (lcsr1 & LCSR1_BS(1))
-		complete(&fbi->overlay[0].branch_done);
+	{
+		unsigned int lcsr1 = lcd_readl(fbi, LCSR1);
+		if (lcsr1 & LCSR1_BS(1))
+			complete(&fbi->overlay[0].branch_done);
 
-	if (lcsr1 & LCSR1_BS(2))
-		complete(&fbi->overlay[1].branch_done);
+		if (lcsr1 & LCSR1_BS(2))
+			complete(&fbi->overlay[1].branch_done);
 
-	lcd_writel(fbi, LCSR1, lcsr1);
+		lcd_writel(fbi, LCSR1, lcsr1);
+	}
 #endif
 	return IRQ_HANDLED;
 }
diff -urN linux-2.6.30-rc2/drivers/virtio/virtio_balloon.c linux-2.6.30-rc3/drivers/virtio/virtio_balloon.c
--- linux-2.6.30-rc2/drivers/virtio/virtio_balloon.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/drivers/virtio/virtio_balloon.c	2009-04-22 03:29:17.952931710 +0000
@@ -190,7 +190,8 @@
 		try_to_freeze();
 		wait_event_interruptible(vb->config_change,
 					 (diff = towards_target(vb)) != 0
-					 || kthread_should_stop());
+					 || kthread_should_stop()
+					 || freezing(current));
 		if (diff > 0)
 			fill_balloon(vb, diff);
 		else if (diff < 0)
diff -urN linux-2.6.30-rc2/fs/afs/file.c linux-2.6.30-rc3/fs/afs/file.c
--- linux-2.6.30-rc2/fs/afs/file.c	2009-04-22 03:29:11.941931425 +0000
+++ linux-2.6.30-rc3/fs/afs/file.c	2009-04-22 03:29:17.991931178 +0000
@@ -102,6 +102,7 @@
 	return 0;
 }
 
+#ifdef CONFIG_AFS_FSCACHE
 /*
  * deal with notification that a page was read from the cache
  */
@@ -117,6 +118,7 @@
 		SetPageUptodate(page);
 	unlock_page(page);
 }
+#endif
 
 /*
  * AFS read page from file, directory or symlink
diff -urN linux-2.6.30-rc2/fs/autofs/dirhash.c linux-2.6.30-rc3/fs/autofs/dirhash.c
--- linux-2.6.30-rc2/fs/autofs/dirhash.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/autofs/dirhash.c	2009-04-22 03:29:17.993931091 +0000
@@ -39,10 +39,12 @@
 {
 	struct autofs_dirhash *dh = &sbi->dirhash;
 	struct autofs_dir_ent *ent;
-	struct dentry *dentry;
 	unsigned long timeout = sbi->exp_timeout;
 
 	while (1) {
+		struct path path;
+		int umount_ok;
+
 		if ( list_empty(&dh->expiry_head) || sbi->catatonic )
 			return NULL;	/* No entries */
 		/* We keep the list sorted by last_usage and want old stuff */
@@ -57,17 +59,17 @@
 			return ent; /* Symlinks are always expirable */
 
 		/* Get the dentry for the autofs subdirectory */
-		dentry = ent->dentry;
+		path.dentry = ent->dentry;
 
-		if ( !dentry ) {
+		if (!path.dentry) {
 			/* Should only happen in catatonic mode */
 			printk("autofs: dentry == NULL but inode range is directory, entry %s\n", ent->name);
 			autofs_delete_usage(ent);
 			continue;
 		}
 
-		if ( !dentry->d_inode ) {
-			dput(dentry);
+		if (!path.dentry->d_inode) {
+			dput(path.dentry);
 			printk("autofs: negative dentry on expiry queue: %s\n",
 			       ent->name);
 			autofs_delete_usage(ent);
@@ -76,29 +78,29 @@
 
 		/* Make sure entry is mounted and unused; note that dentry will
 		   point to the mounted-on-top root. */
-		if (!S_ISDIR(dentry->d_inode->i_mode)||!d_mountpoint(dentry)) {
+		if (!S_ISDIR(path.dentry->d_inode->i_mode) ||
+		    !d_mountpoint(path.dentry)) {
 			DPRINTK(("autofs: not expirable (not a mounted directory): %s\n", ent->name));
 			continue;
 		}
-		mntget(mnt);
-		dget(dentry);
-		if (!follow_down(&mnt, &dentry)) {
-			dput(dentry);
-			mntput(mnt);
+		path.mnt = mnt;
+		path_get(&path);
+		if (!follow_down(&path.mnt, &path.dentry)) {
+			path_put(&path);
 			DPRINTK(("autofs: not expirable (not a mounted directory): %s\n", ent->name));
 			continue;
 		}
-		while (d_mountpoint(dentry) && follow_down(&mnt, &dentry))
+		while (d_mountpoint(path.dentry) &&
+		       follow_down(&path.mnt, &path.dentry))
 			;
-		dput(dentry);
+		umount_ok = may_umount(path.mnt);
+		path_put(&path);
 
-		if ( may_umount(mnt) ) {
-			mntput(mnt);
+		if (umount_ok) {
 			DPRINTK(("autofs: signaling expire on %s\n", ent->name));
 			return ent; /* Expirable! */
 		}
 		DPRINTK(("autofs: didn't expire due to may_umount: %s\n", ent->name));
-		mntput(mnt);
 	}
 	return NULL;		/* No expirable entries */
 }
diff -urN linux-2.6.30-rc2/fs/autofs4/dev-ioctl.c linux-2.6.30-rc3/fs/autofs4/dev-ioctl.c
--- linux-2.6.30-rc2/fs/autofs4/dev-ioctl.c	2009-04-22 03:29:11.943931393 +0000
+++ linux-2.6.30-rc3/fs/autofs4/dev-ioctl.c	2009-04-22 03:29:17.994931108 +0000
@@ -54,11 +54,10 @@
  * Check a string doesn't overrun the chunk of
  * memory we copied from user land.
  */
-static int invalid_str(char *str, void *end)
+static int invalid_str(char *str, size_t size)
 {
-	while ((void *) str <= end)
-		if (!*str++)
-			return 0;
+	if (memchr(str, 0, size))
+		return 0;
 	return -EINVAL;
 }
 
@@ -138,8 +137,7 @@
 	}
 
 	if (param->size > sizeof(*param)) {
-		err = invalid_str(param->path,
-				 (void *) ((size_t) param + param->size));
+		err = invalid_str(param->path, param->size - sizeof(*param));
 		if (err) {
 			AUTOFS_WARN(
 			  "path string terminator missing for cmd(0x%08x)",
@@ -488,7 +486,7 @@
 	}
 
 	path = param->path;
-	devid = sbi->sb->s_dev;
+	devid = new_encode_dev(sbi->sb->s_dev);
 
 	param->requester.uid = param->requester.gid = -1;
 
diff -urN linux-2.6.30-rc2/fs/bio.c linux-2.6.30-rc3/fs/bio.c
--- linux-2.6.30-rc2/fs/bio.c	2009-04-22 03:29:11.946931494 +0000
+++ linux-2.6.30-rc3/fs/bio.c	2009-04-22 03:29:17.996931048 +0000
@@ -348,6 +348,24 @@
 	return NULL;
 }
 
+/**
+ * bio_alloc - allocate a bio for I/O
+ * @gfp_mask:   the GFP_ mask given to the slab allocator
+ * @nr_iovecs:	number of iovecs to pre-allocate
+ *
+ * Description:
+ *   bio_alloc will allocate a bio and associated bio_vec array that can hold
+ *   at least @nr_iovecs entries. Allocations will be done from the
+ *   fs_bio_set. Also see @bio_alloc_bioset.
+ *
+ *   If %__GFP_WAIT is set, then bio_alloc will always be able to allocate
+ *   a bio. This is due to the mempool guarantees. To make this work, callers
+ *   must never allocate more than 1 bio at the time from this pool. Callers
+ *   that need to allocate more than 1 bio must always submit the previously
+ *   allocate bio for IO before attempting to allocate a new one. Failure to
+ *   do so can cause livelocks under memory pressure.
+ *
+ **/
 struct bio *bio_alloc(gfp_t gfp_mask, int nr_iovecs)
 {
 	struct bio *bio = bio_alloc_bioset(gfp_mask, nr_iovecs, fs_bio_set);
diff -urN linux-2.6.30-rc2/fs/btrfs/async-thread.c linux-2.6.30-rc3/fs/btrfs/async-thread.c
--- linux-2.6.30-rc2/fs/btrfs/async-thread.c	2009-04-22 03:29:11.946931494 +0000
+++ linux-2.6.30-rc3/fs/btrfs/async-thread.c	2009-04-22 03:29:17.997931071 +0000
@@ -25,6 +25,7 @@
 #define WORK_QUEUED_BIT 0
 #define WORK_DONE_BIT 1
 #define WORK_ORDER_DONE_BIT 2
+#define WORK_HIGH_PRIO_BIT 3
 
 /*
  * container for the kthread task pointer and the list of pending work
@@ -36,6 +37,7 @@
 
 	/* list of struct btrfs_work that are waiting for service */
 	struct list_head pending;
+	struct list_head prio_pending;
 
 	/* list of worker threads from struct btrfs_workers */
 	struct list_head worker_list;
@@ -103,10 +105,16 @@
 
 	spin_lock_irqsave(&workers->lock, flags);
 
-	while (!list_empty(&workers->order_list)) {
-		work = list_entry(workers->order_list.next,
-				  struct btrfs_work, order_list);
-
+	while (1) {
+		if (!list_empty(&workers->prio_order_list)) {
+			work = list_entry(workers->prio_order_list.next,
+					  struct btrfs_work, order_list);
+		} else if (!list_empty(&workers->order_list)) {
+			work = list_entry(workers->order_list.next,
+					  struct btrfs_work, order_list);
+		} else {
+			break;
+		}
 		if (!test_bit(WORK_DONE_BIT, &work->flags))
 			break;
 
@@ -143,8 +151,14 @@
 	do {
 		spin_lock_irq(&worker->lock);
 again_locked:
-		while (!list_empty(&worker->pending)) {
-			cur = worker->pending.next;
+		while (1) {
+			if (!list_empty(&worker->prio_pending))
+				cur = worker->prio_pending.next;
+			else if (!list_empty(&worker->pending))
+				cur = worker->pending.next;
+			else
+				break;
+
 			work = list_entry(cur, struct btrfs_work, list);
 			list_del(&work->list);
 			clear_bit(WORK_QUEUED_BIT, &work->flags);
@@ -163,7 +177,6 @@
 
 			spin_lock_irq(&worker->lock);
 			check_idle_worker(worker);
-
 		}
 		if (freezing(current)) {
 			worker->working = 0;
@@ -178,7 +191,8 @@
 				 * jump_in?
 				 */
 				smp_mb();
-				if (!list_empty(&worker->pending))
+				if (!list_empty(&worker->pending) ||
+				    !list_empty(&worker->prio_pending))
 					continue;
 
 				/*
@@ -191,7 +205,8 @@
 				 */
 				schedule_timeout(1);
 				smp_mb();
-				if (!list_empty(&worker->pending))
+				if (!list_empty(&worker->pending) ||
+				    !list_empty(&worker->prio_pending))
 					continue;
 
 				if (kthread_should_stop())
@@ -200,7 +215,8 @@
 				/* still no more work?, sleep for real */
 				spin_lock_irq(&worker->lock);
 				set_current_state(TASK_INTERRUPTIBLE);
-				if (!list_empty(&worker->pending))
+				if (!list_empty(&worker->pending) ||
+				    !list_empty(&worker->prio_pending))
 					goto again_locked;
 
 				/*
@@ -248,6 +264,7 @@
 	INIT_LIST_HEAD(&workers->worker_list);
 	INIT_LIST_HEAD(&workers->idle_list);
 	INIT_LIST_HEAD(&workers->order_list);
+	INIT_LIST_HEAD(&workers->prio_order_list);
 	spin_lock_init(&workers->lock);
 	workers->max_workers = max;
 	workers->idle_thresh = 32;
@@ -273,6 +290,7 @@
 		}
 
 		INIT_LIST_HEAD(&worker->pending);
+		INIT_LIST_HEAD(&worker->prio_pending);
 		INIT_LIST_HEAD(&worker->worker_list);
 		spin_lock_init(&worker->lock);
 		atomic_set(&worker->num_pending, 0);
@@ -396,7 +414,10 @@
 		goto out;
 
 	spin_lock_irqsave(&worker->lock, flags);
-	list_add_tail(&work->list, &worker->pending);
+	if (test_bit(WORK_HIGH_PRIO_BIT, &work->flags))
+		list_add_tail(&work->list, &worker->prio_pending);
+	else
+		list_add_tail(&work->list, &worker->pending);
 	atomic_inc(&worker->num_pending);
 
 	/* by definition we're busy, take ourselves off the idle
@@ -422,6 +443,11 @@
 	return 0;
 }
 
+void btrfs_set_work_high_prio(struct btrfs_work *work)
+{
+	set_bit(WORK_HIGH_PRIO_BIT, &work->flags);
+}
+
 /*
  * places a struct btrfs_work into the pending queue of one of the kthreads
  */
@@ -438,7 +464,12 @@
 	worker = find_worker(workers);
 	if (workers->ordered) {
 		spin_lock_irqsave(&workers->lock, flags);
-		list_add_tail(&work->order_list, &workers->order_list);
+		if (test_bit(WORK_HIGH_PRIO_BIT, &work->flags)) {
+			list_add_tail(&work->order_list,
+				      &workers->prio_order_list);
+		} else {
+			list_add_tail(&work->order_list, &workers->order_list);
+		}
 		spin_unlock_irqrestore(&workers->lock, flags);
 	} else {
 		INIT_LIST_HEAD(&work->order_list);
@@ -446,7 +477,10 @@
 
 	spin_lock_irqsave(&worker->lock, flags);
 
-	list_add_tail(&work->list, &worker->pending);
+	if (test_bit(WORK_HIGH_PRIO_BIT, &work->flags))
+		list_add_tail(&work->list, &worker->prio_pending);
+	else
+		list_add_tail(&work->list, &worker->pending);
 	atomic_inc(&worker->num_pending);
 	check_busy_worker(worker);
 
diff -urN linux-2.6.30-rc2/fs/btrfs/async-thread.h linux-2.6.30-rc3/fs/btrfs/async-thread.h
--- linux-2.6.30-rc2/fs/btrfs/async-thread.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/btrfs/async-thread.h	2009-04-22 03:29:17.997931071 +0000
@@ -85,6 +85,7 @@
 	 * of work items waiting for completion
 	 */
 	struct list_head order_list;
+	struct list_head prio_order_list;
 
 	/* lock for finding the next worker thread to queue on */
 	spinlock_t lock;
@@ -98,4 +99,5 @@
 int btrfs_stop_workers(struct btrfs_workers *workers);
 void btrfs_init_workers(struct btrfs_workers *workers, char *name, int max);
 int btrfs_requeue_work(struct btrfs_work *work);
+void btrfs_set_work_high_prio(struct btrfs_work *work);
 #endif
diff -urN linux-2.6.30-rc2/fs/btrfs/ctree.c linux-2.6.30-rc3/fs/btrfs/ctree.c
--- linux-2.6.30-rc2/fs/btrfs/ctree.c	2009-04-22 03:29:11.948931200 +0000
+++ linux-2.6.30-rc3/fs/btrfs/ctree.c	2009-04-22 03:29:17.999931087 +0000
@@ -1325,12 +1325,12 @@
 	int ret = 0;
 	int blocksize;
 
-	parent = path->nodes[level - 1];
+	parent = path->nodes[level + 1];
 	if (!parent)
 		return 0;
 
 	nritems = btrfs_header_nritems(parent);
-	slot = path->slots[level];
+	slot = path->slots[level + 1];
 	blocksize = btrfs_level_size(root, level);
 
 	if (slot > 0) {
@@ -1341,7 +1341,7 @@
 			block1 = 0;
 		free_extent_buffer(eb);
 	}
-	if (slot < nritems) {
+	if (slot + 1 < nritems) {
 		block2 = btrfs_node_blockptr(parent, slot + 1);
 		gen = btrfs_node_ptr_generation(parent, slot + 1);
 		eb = btrfs_find_tree_block(root, block2, blocksize);
@@ -1351,7 +1351,11 @@
 	}
 	if (block1 || block2) {
 		ret = -EAGAIN;
+
+		/* release the whole path */
 		btrfs_release_path(root, path);
+
+		/* read the blocks */
 		if (block1)
 			readahead_tree_block(root, block1, blocksize, 0);
 		if (block2)
@@ -1361,7 +1365,7 @@
 			eb = read_tree_block(root, block1, blocksize, 0);
 			free_extent_buffer(eb);
 		}
-		if (block1) {
+		if (block2) {
 			eb = read_tree_block(root, block2, blocksize, 0);
 			free_extent_buffer(eb);
 		}
@@ -1481,12 +1485,15 @@
 	 * of the btree by dropping locks before
 	 * we read.
 	 */
-	btrfs_release_path(NULL, p);
+	btrfs_unlock_up_safe(p, level + 1);
+	btrfs_set_path_blocking(p);
+
 	if (tmp)
 		free_extent_buffer(tmp);
 	if (p->reada)
 		reada_for_search(root, p, level, slot, key->objectid);
 
+	btrfs_release_path(NULL, p);
 	tmp = read_tree_block(root, blocknr, blocksize, gen);
 	if (tmp)
 		free_extent_buffer(tmp);
diff -urN linux-2.6.30-rc2/fs/btrfs/disk-io.c linux-2.6.30-rc3/fs/btrfs/disk-io.c
--- linux-2.6.30-rc2/fs/btrfs/disk-io.c	2009-04-22 03:29:11.950931408 +0000
+++ linux-2.6.30-rc3/fs/btrfs/disk-io.c	2009-04-22 03:29:18.001931135 +0000
@@ -579,6 +579,10 @@
 	async->bio_flags = bio_flags;
 
 	atomic_inc(&fs_info->nr_async_submits);
+
+	if (rw & (1 << BIO_RW_SYNCIO))
+		btrfs_set_work_high_prio(&async->work);
+
 	btrfs_queue_worker(&fs_info->workers, &async->work);
 #if 0
 	int limit = btrfs_async_submit_limit(fs_info);
@@ -656,6 +660,7 @@
 		return btrfs_map_bio(BTRFS_I(inode)->root, rw, bio,
 				     mirror_num, 0);
 	}
+
 	/*
 	 * kthread helpers are used to submit writes so that checksumming
 	 * can happen in parallel across all CPUs
@@ -2095,10 +2100,10 @@
 				device->barriers = 0;
 				get_bh(bh);
 				lock_buffer(bh);
-				ret = submit_bh(WRITE, bh);
+				ret = submit_bh(WRITE_SYNC, bh);
 			}
 		} else {
-			ret = submit_bh(WRITE, bh);
+			ret = submit_bh(WRITE_SYNC, bh);
 		}
 
 		if (!ret && wait) {
diff -urN linux-2.6.30-rc2/fs/btrfs/extent_io.c linux-2.6.30-rc3/fs/btrfs/extent_io.c
--- linux-2.6.30-rc2/fs/btrfs/extent_io.c	2009-04-22 03:29:11.954556106 +0000
+++ linux-2.6.30-rc3/fs/btrfs/extent_io.c	2009-04-22 03:29:18.004931632 +0000
@@ -50,7 +50,10 @@
 	/* tells writepage not to lock the state bits for this range
 	 * it still does the unlocking
 	 */
-	int extent_locked;
+	unsigned int extent_locked:1;
+
+	/* tells the submit_bio code to use a WRITE_SYNC */
+	unsigned int sync_io:1;
 };
 
 int __init extent_io_init(void)
@@ -2101,6 +2104,16 @@
 	return ret;
 }
 
+static noinline void update_nr_written(struct page *page,
+				      struct writeback_control *wbc,
+				      unsigned long nr_written)
+{
+	wbc->nr_to_write -= nr_written;
+	if (wbc->range_cyclic || (wbc->nr_to_write > 0 &&
+	    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))
+		page->mapping->writeback_index = page->index + nr_written;
+}
+
 /*
  * the writepage semantics are similar to regular writepage.  extent
  * records are inserted to lock ranges in the tree, and as dirty areas
@@ -2136,8 +2149,14 @@
 	u64 delalloc_end;
 	int page_started;
 	int compressed;
+	int write_flags;
 	unsigned long nr_written = 0;
 
+	if (wbc->sync_mode == WB_SYNC_ALL)
+		write_flags = WRITE_SYNC_PLUG;
+	else
+		write_flags = WRITE;
+
 	WARN_ON(!PageLocked(page));
 	pg_offset = i_size & (PAGE_CACHE_SIZE - 1);
 	if (page->index > end_index ||
@@ -2164,6 +2183,12 @@
 	delalloc_end = 0;
 	page_started = 0;
 	if (!epd->extent_locked) {
+		/*
+		 * make sure the wbc mapping index is at least updated
+		 * to this page.
+		 */
+		update_nr_written(page, wbc, 0);
+
 		while (delalloc_end < page_end) {
 			nr_delalloc = find_lock_delalloc_range(inode, tree,
 						       page,
@@ -2185,7 +2210,13 @@
 		 */
 		if (page_started) {
 			ret = 0;
-			goto update_nr_written;
+			/*
+			 * we've unlocked the page, so we can't update
+			 * the mapping's writeback index, just update
+			 * nr_to_write.
+			 */
+			wbc->nr_to_write -= nr_written;
+			goto done_unlocked;
 		}
 	}
 	lock_extent(tree, start, page_end, GFP_NOFS);
@@ -2198,13 +2229,18 @@
 		if (ret == -EAGAIN) {
 			unlock_extent(tree, start, page_end, GFP_NOFS);
 			redirty_page_for_writepage(wbc, page);
+			update_nr_written(page, wbc, nr_written);
 			unlock_page(page);
 			ret = 0;
-			goto update_nr_written;
+			goto done_unlocked;
 		}
 	}
 
-	nr_written++;
+	/*
+	 * we don't want to touch the inode after unlocking the page,
+	 * so we update the mapping writeback index now
+	 */
+	update_nr_written(page, wbc, nr_written + 1);
 
 	end = page_end;
 	if (test_range_bit(tree, start, page_end, EXTENT_DELALLOC, 0))
@@ -2314,9 +2350,9 @@
 				       (unsigned long long)end);
 			}
 
-			ret = submit_extent_page(WRITE, tree, page, sector,
-						 iosize, pg_offset, bdev,
-						 &epd->bio, max_nr,
+			ret = submit_extent_page(write_flags, tree, page,
+						 sector, iosize, pg_offset,
+						 bdev, &epd->bio, max_nr,
 						 end_bio_extent_writepage,
 						 0, 0, 0);
 			if (ret)
@@ -2336,11 +2372,8 @@
 		unlock_extent(tree, unlock_start, page_end, GFP_NOFS);
 	unlock_page(page);
 
-update_nr_written:
-	wbc->nr_to_write -= nr_written;
-	if (wbc->range_cyclic || (wbc->nr_to_write > 0 &&
-	    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))
-		page->mapping->writeback_index = page->index + nr_written;
+done_unlocked:
+
 	return 0;
 }
 
@@ -2460,15 +2493,23 @@
 	return ret;
 }
 
-static noinline void flush_write_bio(void *data)
+static void flush_epd_write_bio(struct extent_page_data *epd)
 {
-	struct extent_page_data *epd = data;
 	if (epd->bio) {
-		submit_one_bio(WRITE, epd->bio, 0, 0);
+		if (epd->sync_io)
+			submit_one_bio(WRITE_SYNC, epd->bio, 0, 0);
+		else
+			submit_one_bio(WRITE, epd->bio, 0, 0);
 		epd->bio = NULL;
 	}
 }
 
+static noinline void flush_write_bio(void *data)
+{
+	struct extent_page_data *epd = data;
+	flush_epd_write_bio(epd);
+}
+
 int extent_write_full_page(struct extent_io_tree *tree, struct page *page,
 			  get_extent_t *get_extent,
 			  struct writeback_control *wbc)
@@ -2480,23 +2521,22 @@
 		.tree = tree,
 		.get_extent = get_extent,
 		.extent_locked = 0,
+		.sync_io = wbc->sync_mode == WB_SYNC_ALL,
 	};
 	struct writeback_control wbc_writepages = {
 		.bdi		= wbc->bdi,
-		.sync_mode	= WB_SYNC_NONE,
+		.sync_mode	= wbc->sync_mode,
 		.older_than_this = NULL,
 		.nr_to_write	= 64,
 		.range_start	= page_offset(page) + PAGE_CACHE_SIZE,
 		.range_end	= (loff_t)-1,
 	};
 
-
 	ret = __extent_writepage(page, wbc, &epd);
 
 	extent_write_cache_pages(tree, mapping, &wbc_writepages,
 				 __extent_writepage, &epd, flush_write_bio);
-	if (epd.bio)
-		submit_one_bio(WRITE, epd.bio, 0, 0);
+	flush_epd_write_bio(&epd);
 	return ret;
 }
 
@@ -2515,6 +2555,7 @@
 		.tree = tree,
 		.get_extent = get_extent,
 		.extent_locked = 1,
+		.sync_io = mode == WB_SYNC_ALL,
 	};
 	struct writeback_control wbc_writepages = {
 		.bdi		= inode->i_mapping->backing_dev_info,
@@ -2540,8 +2581,7 @@
 		start += PAGE_CACHE_SIZE;
 	}
 
-	if (epd.bio)
-		submit_one_bio(WRITE, epd.bio, 0, 0);
+	flush_epd_write_bio(&epd);
 	return ret;
 }
 
@@ -2556,13 +2596,13 @@
 		.tree = tree,
 		.get_extent = get_extent,
 		.extent_locked = 0,
+		.sync_io = wbc->sync_mode == WB_SYNC_ALL,
 	};
 
 	ret = extent_write_cache_pages(tree, mapping, wbc,
 				       __extent_writepage, &epd,
 				       flush_write_bio);
-	if (epd.bio)
-		submit_one_bio(WRITE, epd.bio, 0, 0);
+	flush_epd_write_bio(&epd);
 	return ret;
 }
 
diff -urN linux-2.6.30-rc2/fs/btrfs/file.c linux-2.6.30-rc3/fs/btrfs/file.c
--- linux-2.6.30-rc2/fs/btrfs/file.c	2009-04-22 03:29:11.954556106 +0000
+++ linux-2.6.30-rc3/fs/btrfs/file.c	2009-04-22 03:29:18.005931532 +0000
@@ -830,7 +830,7 @@
 
 		ret = btrfs_del_items(trans, root, path, del_slot, del_nr);
 		BUG_ON(ret);
-		goto done;
+		goto release;
 	} else if (split == start) {
 		if (locked_end < extent_end) {
 			ret = try_lock_extent(&BTRFS_I(inode)->io_tree,
@@ -926,6 +926,8 @@
 	}
 done:
 	btrfs_mark_buffer_dirty(leaf);
+
+release:
 	btrfs_release_path(root, path);
 	if (split_end && split == start) {
 		split = end;
@@ -1131,7 +1133,7 @@
 		if (will_write) {
 			btrfs_fdatawrite_range(inode->i_mapping, pos,
 					       pos + write_bytes - 1,
-					       WB_SYNC_NONE);
+					       WB_SYNC_ALL);
 		} else {
 			balance_dirty_pages_ratelimited_nr(inode->i_mapping,
 							   num_pages);
diff -urN linux-2.6.30-rc2/fs/btrfs/inode.c linux-2.6.30-rc3/fs/btrfs/inode.c
--- linux-2.6.30-rc2/fs/btrfs/inode.c	2009-04-22 03:29:11.956931382 +0000
+++ linux-2.6.30-rc3/fs/btrfs/inode.c	2009-04-22 03:29:18.007931515 +0000
@@ -4970,10 +4970,10 @@
 	return err;
 }
 
-static int prealloc_file_range(struct inode *inode, u64 start, u64 end,
+static int prealloc_file_range(struct btrfs_trans_handle *trans,
+			       struct inode *inode, u64 start, u64 end,
 			       u64 alloc_hint, int mode)
 {
-	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_key ins;
 	u64 alloc_size;
@@ -4981,10 +4981,6 @@
 	u64 num_bytes = end - start;
 	int ret = 0;
 
-	trans = btrfs_join_transaction(root, 1);
-	BUG_ON(!trans);
-	btrfs_set_trans_block_group(trans, inode);
-
 	while (num_bytes > 0) {
 		alloc_size = min(num_bytes, root->fs_info->max_extent);
 		ret = btrfs_reserve_extent(trans, root, alloc_size,
@@ -5015,7 +5011,6 @@
 		BUG_ON(ret);
 	}
 
-	btrfs_end_transaction(trans, root);
 	return ret;
 }
 
@@ -5029,11 +5024,18 @@
 	u64 alloc_hint = 0;
 	u64 mask = BTRFS_I(inode)->root->sectorsize - 1;
 	struct extent_map *em;
+	struct btrfs_trans_handle *trans;
 	int ret;
 
 	alloc_start = offset & ~mask;
 	alloc_end =  (offset + len + mask) & ~mask;
 
+	/*
+	 * wait for ordered IO before we have any locks.  We'll loop again
+	 * below with the locks held.
+	 */
+	btrfs_wait_ordered_range(inode, alloc_start, alloc_end - alloc_start);
+
 	mutex_lock(&inode->i_mutex);
 	if (alloc_start > inode->i_size) {
 		ret = btrfs_cont_expand(inode, alloc_start);
@@ -5043,6 +5045,16 @@
 
 	while (1) {
 		struct btrfs_ordered_extent *ordered;
+
+		trans = btrfs_start_transaction(BTRFS_I(inode)->root, 1);
+		if (!trans) {
+			ret = -EIO;
+			goto out;
+		}
+
+		/* the extent lock is ordered inside the running
+		 * transaction
+		 */
 		lock_extent(&BTRFS_I(inode)->io_tree, alloc_start,
 			    alloc_end - 1, GFP_NOFS);
 		ordered = btrfs_lookup_first_ordered_extent(inode,
@@ -5053,6 +5065,12 @@
 			btrfs_put_ordered_extent(ordered);
 			unlock_extent(&BTRFS_I(inode)->io_tree,
 				      alloc_start, alloc_end - 1, GFP_NOFS);
+			btrfs_end_transaction(trans, BTRFS_I(inode)->root);
+
+			/*
+			 * we can't wait on the range with the transaction
+			 * running or with the extent lock held
+			 */
 			btrfs_wait_ordered_range(inode, alloc_start,
 						 alloc_end - alloc_start);
 		} else {
@@ -5070,7 +5088,7 @@
 		last_byte = min(extent_map_end(em), alloc_end);
 		last_byte = (last_byte + mask) & ~mask;
 		if (em->block_start == EXTENT_MAP_HOLE) {
-			ret = prealloc_file_range(inode, cur_offset,
+			ret = prealloc_file_range(trans, inode, cur_offset,
 					last_byte, alloc_hint, mode);
 			if (ret < 0) {
 				free_extent_map(em);
@@ -5089,6 +5107,8 @@
 	}
 	unlock_extent(&BTRFS_I(inode)->io_tree, alloc_start, alloc_end - 1,
 		      GFP_NOFS);
+
+	btrfs_end_transaction(trans, BTRFS_I(inode)->root);
 out:
 	mutex_unlock(&inode->i_mutex);
 	return ret;
diff -urN linux-2.6.30-rc2/fs/btrfs/ioctl.c linux-2.6.30-rc3/fs/btrfs/ioctl.c
--- linux-2.6.30-rc2/fs/btrfs/ioctl.c	2009-04-22 03:29:11.956931382 +0000
+++ linux-2.6.30-rc3/fs/btrfs/ioctl.c	2009-04-22 03:29:18.007931515 +0000
@@ -461,15 +461,9 @@
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	vol_args = kmalloc(sizeof(*vol_args), GFP_NOFS);
-
-	if (!vol_args)
-		return -ENOMEM;
-
-	if (copy_from_user(vol_args, arg, sizeof(*vol_args))) {
-		ret = -EFAULT;
-		goto out;
-	}
+	vol_args = memdup_user(arg, sizeof(*vol_args));
+	if (IS_ERR(vol_args))
+		return PTR_ERR(vol_args);
 
 	vol_args->name[BTRFS_PATH_NAME_MAX] = '\0';
 	namelen = strlen(vol_args->name);
@@ -545,7 +539,6 @@
 
 out_unlock:
 	mutex_unlock(&root->fs_info->volume_mutex);
-out:
 	kfree(vol_args);
 	return ret;
 }
@@ -565,15 +558,9 @@
 	if (root->fs_info->sb->s_flags & MS_RDONLY)
 		return -EROFS;
 
-	vol_args = kmalloc(sizeof(*vol_args), GFP_NOFS);
-
-	if (!vol_args)
-		return -ENOMEM;
-
-	if (copy_from_user(vol_args, arg, sizeof(*vol_args))) {
-		ret = -EFAULT;
-		goto out;
-	}
+	vol_args = memdup_user(arg, sizeof(*vol_args));
+	if (IS_ERR(vol_args))
+		return PTR_ERR(vol_args);
 
 	vol_args->name[BTRFS_PATH_NAME_MAX] = '\0';
 	namelen = strlen(vol_args->name);
@@ -675,19 +662,13 @@
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	vol_args = kmalloc(sizeof(*vol_args), GFP_NOFS);
+	vol_args = memdup_user(arg, sizeof(*vol_args));
+	if (IS_ERR(vol_args))
+		return PTR_ERR(vol_args);
 
-	if (!vol_args)
-		return -ENOMEM;
-
-	if (copy_from_user(vol_args, arg, sizeof(*vol_args))) {
-		ret = -EFAULT;
-		goto out;
-	}
 	vol_args->name[BTRFS_PATH_NAME_MAX] = '\0';
 	ret = btrfs_init_new_device(root, vol_args->name);
 
-out:
 	kfree(vol_args);
 	return ret;
 }
@@ -703,19 +684,13 @@
 	if (root->fs_info->sb->s_flags & MS_RDONLY)
 		return -EROFS;
 
-	vol_args = kmalloc(sizeof(*vol_args), GFP_NOFS);
+	vol_args = memdup_user(arg, sizeof(*vol_args));
+	if (IS_ERR(vol_args))
+		return PTR_ERR(vol_args);
 
-	if (!vol_args)
-		return -ENOMEM;
-
-	if (copy_from_user(vol_args, arg, sizeof(*vol_args))) {
-		ret = -EFAULT;
-		goto out;
-	}
 	vol_args->name[BTRFS_PATH_NAME_MAX] = '\0';
 	ret = btrfs_rm_device(root, vol_args->name);
 
-out:
 	kfree(vol_args);
 	return ret;
 }
diff -urN linux-2.6.30-rc2/fs/btrfs/ordered-data.c linux-2.6.30-rc3/fs/btrfs/ordered-data.c
--- linux-2.6.30-rc2/fs/btrfs/ordered-data.c	2009-04-22 03:29:11.957931645 +0000
+++ linux-2.6.30-rc3/fs/btrfs/ordered-data.c	2009-04-22 03:29:18.008931518 +0000
@@ -489,7 +489,7 @@
 	/* start IO across the range first to instantiate any delalloc
 	 * extents
 	 */
-	btrfs_fdatawrite_range(inode->i_mapping, start, orig_end, WB_SYNC_NONE);
+	btrfs_fdatawrite_range(inode->i_mapping, start, orig_end, WB_SYNC_ALL);
 
 	/* The compression code will leave pages locked but return from
 	 * writepage without setting the page writeback.  Starting again
diff -urN linux-2.6.30-rc2/fs/btrfs/super.c linux-2.6.30-rc3/fs/btrfs/super.c
--- linux-2.6.30-rc2/fs/btrfs/super.c	2009-04-22 03:29:11.957931645 +0000
+++ linux-2.6.30-rc3/fs/btrfs/super.c	2009-04-22 03:29:18.008931518 +0000
@@ -635,14 +635,9 @@
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	vol = kmalloc(sizeof(*vol), GFP_KERNEL);
-	if (!vol)
-		return -ENOMEM;
-
-	if (copy_from_user(vol, (void __user *)arg, sizeof(*vol))) {
-		ret = -EFAULT;
-		goto out;
-	}
+	vol = memdup_user((void __user *)arg, sizeof(*vol));
+	if (IS_ERR(vol))
+		return PTR_ERR(vol);
 
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:
@@ -650,7 +645,7 @@
 					    &btrfs_fs_type, &fs_devices);
 		break;
 	}
-out:
+
 	kfree(vol);
 	return ret;
 }
diff -urN linux-2.6.30-rc2/fs/btrfs/volumes.c linux-2.6.30-rc3/fs/btrfs/volumes.c
--- linux-2.6.30-rc2/fs/btrfs/volumes.c	2009-04-22 03:29:11.959931408 +0000
+++ linux-2.6.30-rc3/fs/btrfs/volumes.c	2009-04-22 03:29:18.011931396 +0000
@@ -125,6 +125,20 @@
 	return NULL;
 }
 
+static void requeue_list(struct btrfs_pending_bios *pending_bios,
+			struct bio *head, struct bio *tail)
+{
+
+	struct bio *old_head;
+
+	old_head = pending_bios->head;
+	pending_bios->head = head;
+	if (pending_bios->tail)
+		tail->bi_next = old_head;
+	else
+		pending_bios->tail = tail;
+}
+
 /*
  * we try to collect pending bios for a device so we don't get a large
  * number of procs sending bios down to the same device.  This greatly
@@ -141,10 +155,12 @@
 	struct bio *pending;
 	struct backing_dev_info *bdi;
 	struct btrfs_fs_info *fs_info;
+	struct btrfs_pending_bios *pending_bios;
 	struct bio *tail;
 	struct bio *cur;
 	int again = 0;
-	unsigned long num_run = 0;
+	unsigned long num_run;
+	unsigned long num_sync_run;
 	unsigned long limit;
 	unsigned long last_waited = 0;
 
@@ -153,20 +169,30 @@
 	limit = btrfs_async_submit_limit(fs_info);
 	limit = limit * 2 / 3;
 
+	/* we want to make sure that every time we switch from the sync
+	 * list to the normal list, we unplug
+	 */
+	num_sync_run = 0;
+
 loop:
 	spin_lock(&device->io_lock);
+	num_run = 0;
 
 loop_lock:
+
 	/* take all the bios off the list at once and process them
 	 * later on (without the lock held).  But, remember the
 	 * tail and other pointers so the bios can be properly reinserted
 	 * into the list if we hit congestion
 	 */
-	pending = device->pending_bios;
-	tail = device->pending_bio_tail;
+	if (device->pending_sync_bios.head)
+		pending_bios = &device->pending_sync_bios;
+	else
+		pending_bios = &device->pending_bios;
+
+	pending = pending_bios->head;
+	tail = pending_bios->tail;
 	WARN_ON(pending && !tail);
-	device->pending_bios = NULL;
-	device->pending_bio_tail = NULL;
 
 	/*
 	 * if pending was null this time around, no bios need processing
@@ -176,16 +202,41 @@
 	 * device->running_pending is used to synchronize with the
 	 * schedule_bio code.
 	 */
-	if (pending) {
-		again = 1;
-		device->running_pending = 1;
-	} else {
+	if (device->pending_sync_bios.head == NULL &&
+	    device->pending_bios.head == NULL) {
 		again = 0;
 		device->running_pending = 0;
+	} else {
+		again = 1;
+		device->running_pending = 1;
 	}
+
+	pending_bios->head = NULL;
+	pending_bios->tail = NULL;
+
 	spin_unlock(&device->io_lock);
 
+	/*
+	 * if we're doing the regular priority list, make sure we unplug
+	 * for any high prio bios we've sent down
+	 */
+	if (pending_bios == &device->pending_bios && num_sync_run > 0) {
+		num_sync_run = 0;
+		blk_run_backing_dev(bdi, NULL);
+	}
+
 	while (pending) {
+
+		rmb();
+		if (pending_bios != &device->pending_sync_bios &&
+		    device->pending_sync_bios.head &&
+		    num_run > 16) {
+			cond_resched();
+			spin_lock(&device->io_lock);
+			requeue_list(pending_bios, pending, tail);
+			goto loop_lock;
+		}
+
 		cur = pending;
 		pending = pending->bi_next;
 		cur->bi_next = NULL;
@@ -196,10 +247,18 @@
 			wake_up(&fs_info->async_submit_wait);
 
 		BUG_ON(atomic_read(&cur->bi_cnt) == 0);
-		bio_get(cur);
 		submit_bio(cur->bi_rw, cur);
-		bio_put(cur);
 		num_run++;
+		if (bio_sync(cur))
+			num_sync_run++;
+
+		if (need_resched()) {
+			if (num_sync_run) {
+				blk_run_backing_dev(bdi, NULL);
+				num_sync_run = 0;
+			}
+			cond_resched();
+		}
 
 		/*
 		 * we made progress, there is more work to do and the bdi
@@ -208,7 +267,6 @@
 		 */
 		if (pending && bdi_write_congested(bdi) && num_run > 16 &&
 		    fs_info->fs_devices->open_devices > 1) {
-			struct bio *old_head;
 			struct io_context *ioc;
 
 			ioc = current->io_context;
@@ -233,17 +291,17 @@
 				 * against it before looping
 				 */
 				last_waited = ioc->last_waited;
+				if (need_resched()) {
+					if (num_sync_run) {
+						blk_run_backing_dev(bdi, NULL);
+						num_sync_run = 0;
+					}
+					cond_resched();
+				}
 				continue;
 			}
 			spin_lock(&device->io_lock);
-
-			old_head = device->pending_bios;
-			device->pending_bios = pending;
-			if (device->pending_bio_tail)
-				tail->bi_next = old_head;
-			else
-				device->pending_bio_tail = tail;
-
+			requeue_list(pending_bios, pending, tail);
 			device->running_pending = 1;
 
 			spin_unlock(&device->io_lock);
@@ -251,11 +309,18 @@
 			goto done;
 		}
 	}
+
+	if (num_sync_run) {
+		num_sync_run = 0;
+		blk_run_backing_dev(bdi, NULL);
+	}
+
+	cond_resched();
 	if (again)
 		goto loop;
 
 	spin_lock(&device->io_lock);
-	if (device->pending_bios)
+	if (device->pending_bios.head || device->pending_sync_bios.head)
 		goto loop_lock;
 	spin_unlock(&device->io_lock);
 
@@ -2497,7 +2562,7 @@
 			max_errors = 1;
 		}
 	}
-	if (multi_ret && rw == WRITE &&
+	if (multi_ret && (rw & (1 << BIO_RW)) &&
 	    stripes_allocated < stripes_required) {
 		stripes_allocated = map->num_stripes;
 		free_extent_map(em);
@@ -2762,6 +2827,7 @@
 				 int rw, struct bio *bio)
 {
 	int should_queue = 1;
+	struct btrfs_pending_bios *pending_bios;
 
 	/* don't bother with additional async steps for reads, right now */
 	if (!(rw & (1 << BIO_RW))) {
@@ -2783,13 +2849,17 @@
 	bio->bi_rw |= rw;
 
 	spin_lock(&device->io_lock);
+	if (bio_sync(bio))
+		pending_bios = &device->pending_sync_bios;
+	else
+		pending_bios = &device->pending_bios;
 
-	if (device->pending_bio_tail)
-		device->pending_bio_tail->bi_next = bio;
+	if (pending_bios->tail)
+		pending_bios->tail->bi_next = bio;
 
-	device->pending_bio_tail = bio;
-	if (!device->pending_bios)
-		device->pending_bios = bio;
+	pending_bios->tail = bio;
+	if (!pending_bios->head)
+		pending_bios->head = bio;
 	if (device->running_pending)
 		should_queue = 0;
 
diff -urN linux-2.6.30-rc2/fs/btrfs/volumes.h linux-2.6.30-rc3/fs/btrfs/volumes.h
--- linux-2.6.30-rc2/fs/btrfs/volumes.h	2009-04-22 03:29:11.960839495 +0000
+++ linux-2.6.30-rc3/fs/btrfs/volumes.h	2009-04-22 03:29:18.011931396 +0000
@@ -23,13 +23,22 @@
 #include "async-thread.h"
 
 struct buffer_head;
+struct btrfs_pending_bios {
+	struct bio *head;
+	struct bio *tail;
+};
+
 struct btrfs_device {
 	struct list_head dev_list;
 	struct list_head dev_alloc_list;
 	struct btrfs_fs_devices *fs_devices;
 	struct btrfs_root *dev_root;
-	struct bio *pending_bios;
-	struct bio *pending_bio_tail;
+
+	/* regular prio bios */
+	struct btrfs_pending_bios pending_bios;
+	/* WRITE_SYNC bios */
+	struct btrfs_pending_bios pending_sync_bios;
+
 	int running_pending;
 	u64 generation;
 
diff -urN linux-2.6.30-rc2/fs/buffer.c linux-2.6.30-rc3/fs/buffer.c
--- linux-2.6.30-rc2/fs/buffer.c	2009-04-22 03:29:11.960839495 +0000
+++ linux-2.6.30-rc3/fs/buffer.c	2009-04-22 03:29:18.012931395 +0000
@@ -360,7 +360,7 @@
  * Completion handler for block_write_full_page() - pages which are unlocked
  * during I/O, and which have PageWriteback cleared upon I/O completion.
  */
-static void end_buffer_async_write(struct buffer_head *bh, int uptodate)
+void end_buffer_async_write(struct buffer_head *bh, int uptodate)
 {
 	char b[BDEVNAME_SIZE];
 	unsigned long flags;
@@ -438,11 +438,17 @@
 	set_buffer_async_read(bh);
 }
 
-void mark_buffer_async_write(struct buffer_head *bh)
+void mark_buffer_async_write_endio(struct buffer_head *bh,
+				   bh_end_io_t *handler)
 {
-	bh->b_end_io = end_buffer_async_write;
+	bh->b_end_io = handler;
 	set_buffer_async_write(bh);
 }
+
+void mark_buffer_async_write(struct buffer_head *bh)
+{
+	mark_buffer_async_write_endio(bh, end_buffer_async_write);
+}
 EXPORT_SYMBOL(mark_buffer_async_write);
 
 
@@ -547,7 +553,7 @@
 	return err;
 }
 
-void do_thaw_all(unsigned long unused)
+void do_thaw_all(struct work_struct *work)
 {
 	struct super_block *sb;
 	char b[BDEVNAME_SIZE];
@@ -567,6 +573,7 @@
 			goto restart;
 	}
 	spin_unlock(&sb_lock);
+	kfree(work);
 	printk(KERN_WARNING "Emergency Thaw complete\n");
 }
 
@@ -577,7 +584,13 @@
  */
 void emergency_thaw_all(void)
 {
-	pdflush_operation(do_thaw_all, 0);
+	struct work_struct *work;
+
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK(work, do_thaw_all);
+		schedule_work(work);
+	}
 }
 
 /**
@@ -1608,7 +1621,8 @@
  * unplugging the device queue.
  */
 static int __block_write_full_page(struct inode *inode, struct page *page,
-			get_block_t *get_block, struct writeback_control *wbc)
+			get_block_t *get_block, struct writeback_control *wbc,
+			bh_end_io_t *handler)
 {
 	int err;
 	sector_t block;
@@ -1693,7 +1707,7 @@
 			continue;
 		}
 		if (test_clear_buffer_dirty(bh)) {
-			mark_buffer_async_write(bh);
+			mark_buffer_async_write_endio(bh, handler);
 		} else {
 			unlock_buffer(bh);
 		}
@@ -1746,7 +1760,7 @@
 		if (buffer_mapped(bh) && buffer_dirty(bh) &&
 		    !buffer_delay(bh)) {
 			lock_buffer(bh);
-			mark_buffer_async_write(bh);
+			mark_buffer_async_write_endio(bh, handler);
 		} else {
 			/*
 			 * The buffer may have been set dirty during
@@ -2672,7 +2686,8 @@
 out:
 	ret = mpage_writepage(page, get_block, wbc);
 	if (ret == -EAGAIN)
-		ret = __block_write_full_page(inode, page, get_block, wbc);
+		ret = __block_write_full_page(inode, page, get_block, wbc,
+					      end_buffer_async_write);
 	return ret;
 }
 EXPORT_SYMBOL(nobh_writepage);
@@ -2830,9 +2845,10 @@
 
 /*
  * The generic ->writepage function for buffer-backed address_spaces
+ * this form passes in the end_io handler used to finish the IO.
  */
-int block_write_full_page(struct page *page, get_block_t *get_block,
-			struct writeback_control *wbc)
+int block_write_full_page_endio(struct page *page, get_block_t *get_block,
+			struct writeback_control *wbc, bh_end_io_t *handler)
 {
 	struct inode * const inode = page->mapping->host;
 	loff_t i_size = i_size_read(inode);
@@ -2841,7 +2857,8 @@
 
 	/* Is the page fully inside i_size? */
 	if (page->index < end_index)
-		return __block_write_full_page(inode, page, get_block, wbc);
+		return __block_write_full_page(inode, page, get_block, wbc,
+					       handler);
 
 	/* Is the page fully outside i_size? (truncate in progress) */
 	offset = i_size & (PAGE_CACHE_SIZE-1);
@@ -2864,9 +2881,20 @@
 	 * writes to that region are not written out to the file."
 	 */
 	zero_user_segment(page, offset, PAGE_CACHE_SIZE);
-	return __block_write_full_page(inode, page, get_block, wbc);
+	return __block_write_full_page(inode, page, get_block, wbc, handler);
 }
 
+/*
+ * The generic ->writepage function for buffer-backed address_spaces
+ */
+int block_write_full_page(struct page *page, get_block_t *get_block,
+			struct writeback_control *wbc)
+{
+	return block_write_full_page_endio(page, get_block, wbc,
+					   end_buffer_async_write);
+}
+
+
 sector_t generic_block_bmap(struct address_space *mapping, sector_t block,
 			    get_block_t *get_block)
 {
@@ -3335,9 +3363,11 @@
 EXPORT_SYMBOL(block_sync_page);
 EXPORT_SYMBOL(block_truncate_page);
 EXPORT_SYMBOL(block_write_full_page);
+EXPORT_SYMBOL(block_write_full_page_endio);
 EXPORT_SYMBOL(cont_write_begin);
 EXPORT_SYMBOL(end_buffer_read_sync);
 EXPORT_SYMBOL(end_buffer_write_sync);
+EXPORT_SYMBOL(end_buffer_async_write);
 EXPORT_SYMBOL(file_fsync);
 EXPORT_SYMBOL(generic_block_bmap);
 EXPORT_SYMBOL(generic_cont_expand_simple);
diff -urN linux-2.6.30-rc2/fs/cifs/CHANGES linux-2.6.30-rc3/fs/cifs/CHANGES
--- linux-2.6.30-rc2/fs/cifs/CHANGES	2009-04-22 03:29:11.963931496 +0000
+++ linux-2.6.30-rc3/fs/cifs/CHANGES	2009-04-22 03:29:18.015931418 +0000
@@ -15,7 +15,8 @@
 fails to support it properly, as with Samba server versions prior to 3.3.2)
 Fix "redzone overwritten" bug in cifs_put_tcon (CIFSTcon may allocate too
 little memory for the "nativeFileSystem" field returned by the server
-during mount). 
+during mount).  Endian convert inode numbers if necessary (makes it easier
+to compare inode numbers on network files from big endian systems). 
 
 Version 1.56
 ------------
diff -urN linux-2.6.30-rc2/fs/cifs/cifs_spnego.c linux-2.6.30-rc3/fs/cifs/cifs_spnego.c
--- linux-2.6.30-rc2/fs/cifs/cifs_spnego.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/cifs/cifs_spnego.c	2009-04-22 03:29:18.016931495 +0000
@@ -41,7 +41,7 @@
 
 	/* attach the data */
 	memcpy(payload, data, datalen);
-	rcu_assign_pointer(key->payload.data, payload);
+	key->payload.data = payload;
 	ret = 0;
 
 error:
diff -urN linux-2.6.30-rc2/fs/cifs/cifsfs.c linux-2.6.30-rc3/fs/cifs/cifsfs.c
--- linux-2.6.30-rc2/fs/cifs/cifsfs.c	2009-04-22 03:29:11.964931375 +0000
+++ linux-2.6.30-rc3/fs/cifs/cifsfs.c	2009-04-22 03:29:18.016931495 +0000
@@ -66,9 +66,6 @@
 extern struct task_struct *oplockThread; /* remove sparse warning */
 struct task_struct *oplockThread = NULL;
 /* extern struct task_struct * dnotifyThread; remove sparse warning */
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-static struct task_struct *dnotifyThread = NULL;
-#endif
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
@@ -316,6 +313,7 @@
 	cifs_inode->clientCanCacheAll = false;
 	cifs_inode->delete_pending = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
+	cifs_inode->server_eof = 0;
 
 	/* Can not set i_flags here - they get immediately overwritten
 	   to zero by the VFS */
@@ -1040,34 +1038,6 @@
 	return 0;
 }
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-static int cifs_dnotify_thread(void *dummyarg)
-{
-	struct list_head *tmp;
-	struct TCP_Server_Info *server;
-
-	do {
-		if (try_to_freeze())
-			continue;
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(15*HZ);
-		/* check if any stuck requests that need
-		   to be woken up and wakeq so the
-		   thread can wake up and error out */
-		read_lock(&cifs_tcp_ses_lock);
-		list_for_each(tmp, &cifs_tcp_ses_list) {
-			server = list_entry(tmp, struct TCP_Server_Info,
-					 tcp_ses_list);
-			if (atomic_read(&server->inFlight))
-				wake_up_all(&server->response_q);
-		}
-		read_unlock(&cifs_tcp_ses_lock);
-	} while (!kthread_should_stop());
-
-	return 0;
-}
-#endif
-
 static int __init
 init_cifs(void)
 {
@@ -1144,21 +1114,8 @@
 		goto out_unregister_dfs_key_type;
 	}
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-	dnotifyThread = kthread_run(cifs_dnotify_thread, NULL, "cifsdnotifyd");
-	if (IS_ERR(dnotifyThread)) {
-		rc = PTR_ERR(dnotifyThread);
-		cERROR(1, ("error %d create dnotify thread", rc));
-		goto out_stop_oplock_thread;
-	}
-#endif
-
 	return 0;
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
- out_stop_oplock_thread:
-#endif
-	kthread_stop(oplockThread);
  out_unregister_dfs_key_type:
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	unregister_key_type(&key_type_dns_resolver);
@@ -1196,9 +1153,6 @@
 	cifs_destroy_inodecache();
 	cifs_destroy_mids();
 	cifs_destroy_request_bufs();
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-	kthread_stop(dnotifyThread);
-#endif
 	kthread_stop(oplockThread);
 }
 
diff -urN linux-2.6.30-rc2/fs/cifs/cifsglob.h linux-2.6.30-rc3/fs/cifs/cifsglob.h
--- linux-2.6.30-rc2/fs/cifs/cifsglob.h	2009-04-22 03:29:11.965931380 +0000
+++ linux-2.6.30-rc3/fs/cifs/cifsglob.h	2009-04-22 03:29:18.016931495 +0000
@@ -350,7 +350,7 @@
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool messageMode:1;	/* for pipes: message vs byte mode */
 	atomic_t wrtPending;   /* handle in use - defer close */
-	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
+	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 };
 
@@ -370,6 +370,7 @@
 	bool clientCanCacheAll:1;	/* read and writebehind oplock */
 	bool oplockPending:1;
 	bool delete_pending:1;		/* DELETE_ON_CLOSE is set */
+	u64  server_eof;		/* current file size on server */
 	struct inode vfs_inode;
 };
 
diff -urN linux-2.6.30-rc2/fs/cifs/cifspdu.h linux-2.6.30-rc3/fs/cifs/cifspdu.h
--- linux-2.6.30-rc2/fs/cifs/cifspdu.h	2009-04-22 03:29:11.965931380 +0000
+++ linux-2.6.30-rc3/fs/cifs/cifspdu.h	2009-04-22 03:29:18.017931423 +0000
@@ -2163,7 +2163,7 @@
 	__le32 Type;
 	__le64 DevMajor;
 	__le64 DevMinor;
-	__u64 UniqueId;
+	__le64 UniqueId;
 	__le64 Permissions;
 	__le64 Nlinks;
 } __attribute__((packed)) FILE_UNIX_BASIC_INFO;	/* level 0x200 QPathInfo */
@@ -2308,7 +2308,7 @@
 } __attribute__((packed));
 
 struct file_internal_info {
-	__u64  UniqueId; /* inode number */
+	__le64  UniqueId; /* inode number */
 } __attribute__((packed));      /* level 0x3ee */
 
 struct file_mode_info {
@@ -2338,7 +2338,7 @@
 	__le32 Type;
 	__le64 DevMajor;
 	__le64 DevMinor;
-	__u64 UniqueId;
+	__le64 UniqueId;
 	__le64 Permissions;
 	__le64 Nlinks;
 	char FileName[1];
@@ -2386,7 +2386,7 @@
 	__le32 FileNameLength;
 	__le32 EaSize; /* EA size */
 	__le32 Reserved;
-	__u64 UniqueId; /* inode num - le since Samba puts ino in low 32 bit*/
+	__le64 UniqueId; /* inode num - le since Samba puts ino in low 32 bit*/
 	char FileName[1];
 } __attribute__((packed)) SEARCH_ID_FULL_DIR_INFO; /* level 0x105 FF rsp data */
 
diff -urN linux-2.6.30-rc2/fs/cifs/cifssmb.c linux-2.6.30-rc3/fs/cifs/cifssmb.c
--- linux-2.6.30-rc2/fs/cifs/cifssmb.c	2009-04-22 03:29:11.966931463 +0000
+++ linux-2.6.30-rc3/fs/cifs/cifssmb.c	2009-04-22 03:29:18.018931398 +0000
@@ -1626,6 +1626,8 @@
 	int smb_hdr_len;
 	int resp_buf_type = 0;
 
+	*nbytes = 0;
+
 	cFYI(1, ("write2 at %lld %d bytes", (long long)offset, count));
 
 	if (tcon->ses->capabilities & CAP_LARGE_FILES) {
@@ -1682,11 +1684,9 @@
 	cifs_stats_inc(&tcon->num_writes);
 	if (rc) {
 		cFYI(1, ("Send error Write2 = %d", rc));
-		*nbytes = 0;
 	} else if (resp_buf_type == 0) {
 		/* presumably this can not happen, but best to be safe */
 		rc = -EIO;
-		*nbytes = 0;
 	} else {
 		WRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;
 		*nbytes = le16_to_cpu(pSMBr->CountHigh);
@@ -3918,7 +3918,7 @@
 			}
 			pfinfo = (struct file_internal_info *)
 				(data_offset + (char *) &pSMBr->hdr.Protocol);
-			*inode_number = pfinfo->UniqueId;
+			*inode_number = le64_to_cpu(pfinfo->UniqueId);
 		}
 	}
 GetInodeNumOut:
diff -urN linux-2.6.30-rc2/fs/cifs/connect.c linux-2.6.30-rc3/fs/cifs/connect.c
--- linux-2.6.30-rc2/fs/cifs/connect.c	2009-04-22 03:29:11.967931224 +0000
+++ linux-2.6.30-rc3/fs/cifs/connect.c	2009-04-22 03:29:18.019931404 +0000
@@ -2214,9 +2214,58 @@
 	return rc;
 }
 
+static void
+cleanup_volume_info(struct smb_vol **pvolume_info)
+{
+	struct smb_vol *volume_info;
+
+	if (!pvolume_info && !*pvolume_info)
+		return;
+
+	volume_info = *pvolume_info;
+	kzfree(volume_info->password);
+	kfree(volume_info->UNC);
+	kfree(volume_info->prepath);
+	kfree(volume_info);
+	*pvolume_info = NULL;
+	return;
+}
+
+#ifdef CONFIG_CIFS_DFS_UPCALL
+/* build_path_to_root returns full path to root when
+ * we do not have an exiting connection (tcon) */
+static char *
+build_unc_path_to_root(const struct smb_vol *volume_info,
+		const struct cifs_sb_info *cifs_sb)
+{
+	char *full_path;
+
+	int unc_len = strnlen(volume_info->UNC, MAX_TREE_SIZE + 1);
+	full_path = kmalloc(unc_len + cifs_sb->prepathlen + 1, GFP_KERNEL);
+	if (full_path == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	strncpy(full_path, volume_info->UNC, unc_len);
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {
+		int i;
+		for (i = 0; i < unc_len; i++) {
+			if (full_path[i] == '\\')
+				full_path[i] = '/';
+		}
+	}
+
+	if (cifs_sb->prepathlen)
+		strncpy(full_path + unc_len, cifs_sb->prepath,
+				cifs_sb->prepathlen);
+
+	full_path[unc_len + cifs_sb->prepathlen] = 0; /* add trailing null */
+	return full_path;
+}
+#endif
+
 int
 cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
-	   char *mount_data, const char *devname)
+		char *mount_data_global, const char *devname)
 {
 	int rc = 0;
 	int xid;
@@ -2225,6 +2274,13 @@
 	struct cifsTconInfo *tcon = NULL;
 	struct TCP_Server_Info *srvTcp = NULL;
 	char   *full_path;
+	char *mount_data = mount_data_global;
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	struct dfs_info3_param *referrals = NULL;
+	unsigned int num_referrals = 0;
+try_mount_again:
+#endif
+	full_path = NULL;
 
 	xid = GetXid();
 
@@ -2371,11 +2427,9 @@
 				}
 			}
 
-			/* check for null share name ie connect to dfs root */
 			if ((strchr(volume_info->UNC + 3, '\\') == NULL)
 			    && (strchr(volume_info->UNC + 3, '/') == NULL)) {
-				/* rc = connect_to_dfs_path(...) */
-				cFYI(1, ("DFS root not supported"));
+				cERROR(1, ("Missing share name"));
 				rc = -ENODEV;
 				goto mount_fail_check;
 			} else {
@@ -2392,7 +2446,7 @@
 				}
 			}
 			if (rc)
-				goto mount_fail_check;
+				goto remote_path_check;
 			tcon->seal = volume_info->seal;
 			write_lock(&cifs_tcp_ses_lock);
 			list_add(&tcon->tcon_list, &pSesInfo->tcon_list);
@@ -2417,19 +2471,9 @@
 	/* BB FIXME fix time_gran to be larger for LANMAN sessions */
 	sb->s_time_gran = 100;
 
-mount_fail_check:
-	/* on error free sesinfo and tcon struct if needed */
-	if (rc) {
-		/* If find_unc succeeded then rc == 0 so we can not end */
-		/* up accidently freeing someone elses tcon struct */
-		if (tcon)
-			cifs_put_tcon(tcon);
-		else if (pSesInfo)
-			cifs_put_smb_ses(pSesInfo);
-		else
-			cifs_put_tcp_session(srvTcp);
-		goto out;
-	}
+	if (rc)
+		goto remote_path_check;
+
 	cifs_sb->tcon = tcon;
 
 	/* do not care if following two calls succeed - informational */
@@ -2461,7 +2505,9 @@
 		cifs_sb->rsize = min(cifs_sb->rsize,
 			       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));
 
-	if (!rc && cifs_sb->prepathlen) {
+remote_path_check:
+	/* check if a whole path (including prepath) is not remote */
+	if (!rc && cifs_sb->prepathlen && tcon) {
 		/* build_path_to_root works only when we have a valid tcon */
 		full_path = cifs_build_path_to_root(cifs_sb);
 		if (full_path == NULL) {
@@ -2469,31 +2515,79 @@
 			goto mount_fail_check;
 		}
 		rc = is_path_accessible(xid, tcon, cifs_sb, full_path);
-		if (rc) {
-			cERROR(1, ("Path %s in not accessible: %d",
-						full_path, rc));
+		if (rc != -EREMOTE) {
 			kfree(full_path);
 			goto mount_fail_check;
 		}
 		kfree(full_path);
 	}
 
+	/* get referral if needed */
+	if (rc == -EREMOTE) {
+#ifdef CONFIG_CIFS_DFS_UPCALL
+		/* convert forward to back slashes in prepath here if needed */
+		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)
+			convert_delimiter(cifs_sb->prepath,
+					CIFS_DIR_SEP(cifs_sb));
+		full_path = build_unc_path_to_root(volume_info, cifs_sb);
+		if (IS_ERR(full_path)) {
+			rc = PTR_ERR(full_path);
+			goto mount_fail_check;
+		}
+
+		cFYI(1, ("Getting referral for: %s", full_path));
+		rc = get_dfs_path(xid, pSesInfo , full_path + 1,
+			cifs_sb->local_nls, &num_referrals, &referrals,
+			cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
+		if (!rc && num_referrals > 0) {
+			char *fake_devname = NULL;
+
+			if (mount_data != mount_data_global)
+				kfree(mount_data);
+			mount_data = cifs_compose_mount_options(
+					cifs_sb->mountdata, full_path + 1,
+					referrals, &fake_devname);
+			kfree(fake_devname);
+			free_dfs_info_array(referrals, num_referrals);
+
+			if (tcon)
+				cifs_put_tcon(tcon);
+			else if (pSesInfo)
+				cifs_put_smb_ses(pSesInfo);
+
+			cleanup_volume_info(&volume_info);
+			FreeXid(xid);
+			kfree(full_path);
+			goto try_mount_again;
+		}
+#else /* No DFS support, return error on mount */
+		rc = -EOPNOTSUPP;
+#endif
+	}
+
+mount_fail_check:
+	/* on error free sesinfo and tcon struct if needed */
+	if (rc) {
+		if (mount_data != mount_data_global)
+			kfree(mount_data);
+		/* If find_unc succeeded then rc == 0 so we can not end */
+		/* up accidently freeing someone elses tcon struct */
+		if (tcon)
+			cifs_put_tcon(tcon);
+		else if (pSesInfo)
+			cifs_put_smb_ses(pSesInfo);
+		else
+			cifs_put_tcp_session(srvTcp);
+		goto out;
+	}
+
 	/* volume_info->password is freed above when existing session found
 	(in which case it is not needed anymore) but when new sesion is created
 	the password ptr is put in the new session structure (in which case the
 	password will be freed at unmount time) */
 out:
 	/* zero out password before freeing */
-	if (volume_info) {
-		if (volume_info->password != NULL) {
-			memset(volume_info->password, 0,
-				strlen(volume_info->password));
-			kfree(volume_info->password);
-		}
-		kfree(volume_info->UNC);
-		kfree(volume_info->prepath);
-		kfree(volume_info);
-	}
+	cleanup_volume_info(&volume_info);
 	FreeXid(xid);
 	return rc;
 }
@@ -2673,8 +2767,7 @@
 /* We look for obvious messed up bcc or strings in response so we do not go off
    the end since (at least) WIN2K and Windows XP have a major bug in not null
    terminating last Unicode string in response  */
-				if (ses->serverOS)
-					kfree(ses->serverOS);
+				kfree(ses->serverOS);
 				ses->serverOS = kzalloc(2 * (len + 1),
 							GFP_KERNEL);
 				if (ses->serverOS == NULL)
@@ -2710,8 +2803,7 @@
 						len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
 				/* last string is not always null terminated
 				   (for e.g. for Windows XP & 2000) */
-						if (ses->serverDomain)
-							kfree(ses->serverDomain);
+						kfree(ses->serverDomain);
 						ses->serverDomain =
 						    kzalloc(2*(len+1),
 							    GFP_KERNEL);
@@ -2725,8 +2817,7 @@
 						ses->serverDomain[1+(2*len)] = 0;
 					} else { /* else no more room so create
 						  dummy domain string */
-						if (ses->serverDomain)
-							kfree(ses->serverDomain);
+						kfree(ses->serverDomain);
 						ses->serverDomain =
 							kzalloc(2, GFP_KERNEL);
 					}
@@ -2772,8 +2863,7 @@
 					bcc_ptr++;
 
 					len = strnlen(bcc_ptr, 1024);
-					if (ses->serverDomain)
-						kfree(ses->serverDomain);
+					kfree(ses->serverDomain);
 					ses->serverDomain = kzalloc(len + 1,
 								    GFP_KERNEL);
 					if (ses->serverDomain == NULL)
@@ -3013,8 +3103,7 @@
 /* We look for obvious messed up bcc or strings in response so we do not go off
    the end since (at least) WIN2K and Windows XP have a major bug in not null
    terminating last Unicode string in response  */
-					if (ses->serverOS)
-						kfree(ses->serverOS);
+					kfree(ses->serverOS);
 					ses->serverOS =
 					    kzalloc(2 * (len + 1), GFP_KERNEL);
 					cifs_strfromUCS_le(ses->serverOS,
@@ -3086,8 +3175,7 @@
 					if (((long) bcc_ptr + len) - (long)
 					    pByteArea(smb_buffer_response)
 					    <= BCC(smb_buffer_response)) {
-						if (ses->serverOS)
-							kfree(ses->serverOS);
+						kfree(ses->serverOS);
 						ses->serverOS =
 						    kzalloc(len + 1,
 							    GFP_KERNEL);
@@ -3414,8 +3502,7 @@
 /* We look for obvious messed up bcc or strings in response so we do not go off
   the end since (at least) WIN2K and Windows XP have a major bug in not null
   terminating last Unicode string in response  */
-					if (ses->serverOS)
-						kfree(ses->serverOS);
+					kfree(ses->serverOS);
 					ses->serverOS =
 					    kzalloc(2 * (len + 1), GFP_KERNEL);
 					cifs_strfromUCS_le(ses->serverOS,
@@ -3448,8 +3535,7 @@
 						if (remaining_words > 0) {
 							len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
      /* last string not always null terminated (e.g. for Windows XP & 2000) */
-							if (ses->serverDomain)
-								kfree(ses->serverDomain);
+							kfree(ses->serverDomain);
 							ses->serverDomain =
 							    kzalloc(2 *
 								    (len +
@@ -3476,13 +3562,11 @@
 							    = 0;
 						} /* else no more room so create dummy domain string */
 						else {
-							if (ses->serverDomain)
-								kfree(ses->serverDomain);
+							kfree(ses->serverDomain);
 							ses->serverDomain = kzalloc(2,GFP_KERNEL);
 						}
 					} else {  /* no room so create dummy domain and NOS string */
-						if (ses->serverDomain)
-							kfree(ses->serverDomain);
+						kfree(ses->serverDomain);
 						ses->serverDomain = kzalloc(2, GFP_KERNEL);
 						kfree(ses->serverNOS);
 						ses->serverNOS = kzalloc(2, GFP_KERNEL);
@@ -3492,8 +3576,7 @@
 					if (((long) bcc_ptr + len) -
 					   (long) pByteArea(smb_buffer_response)
 						<= BCC(smb_buffer_response)) {
-						if (ses->serverOS)
-							kfree(ses->serverOS);
+						kfree(ses->serverOS);
 						ses->serverOS = kzalloc(len + 1, GFP_KERNEL);
 						strncpy(ses->serverOS,bcc_ptr, len);
 
@@ -3512,8 +3595,7 @@
 						bcc_ptr++;
 
 						len = strnlen(bcc_ptr, 1024);
-						if (ses->serverDomain)
-							kfree(ses->serverDomain);
+						kfree(ses->serverDomain);
 						ses->serverDomain =
 								kzalloc(len+1,
 								    GFP_KERNEL);
@@ -3674,16 +3756,15 @@
 			    BCC(smb_buffer_response)) {
 				kfree(tcon->nativeFileSystem);
 				tcon->nativeFileSystem =
-				    kzalloc(2*(length + 1), GFP_KERNEL);
-				if (tcon->nativeFileSystem)
+				    kzalloc((4 * length) + 2, GFP_KERNEL);
+				if (tcon->nativeFileSystem) {
 					cifs_strfromUCS_le(
 						tcon->nativeFileSystem,
 						(__le16 *) bcc_ptr,
 						length, nls_codepage);
-				bcc_ptr += 2 * length;
-				bcc_ptr[0] = 0;	/* null terminate the string */
-				bcc_ptr[1] = 0;
-				bcc_ptr += 2;
+					cFYI(1, ("nativeFileSystem=%s",
+						tcon->nativeFileSystem));
+				}
 			}
 			/* else do not bother copying these information fields*/
 		} else {
diff -urN linux-2.6.30-rc2/fs/cifs/dir.c linux-2.6.30-rc3/fs/cifs/dir.c
--- linux-2.6.30-rc2/fs/cifs/dir.c	2009-04-22 03:29:11.968931427 +0000
+++ linux-2.6.30-rc3/fs/cifs/dir.c	2009-04-22 03:29:18.019931404 +0000
@@ -129,12 +129,62 @@
 	return full_path;
 }
 
+static void
+cifs_fill_fileinfo(struct inode *newinode, __u16 fileHandle,
+			struct cifsTconInfo *tcon, bool write_only)
+{
+	int oplock = 0;
+	struct cifsFileInfo *pCifsFile;
+	struct cifsInodeInfo *pCifsInode;
+
+	pCifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);
+
+	if (pCifsFile == NULL)
+		return;
+
+	if (oplockEnabled)
+		oplock = REQ_OPLOCK;
+
+	pCifsFile->netfid = fileHandle;
+	pCifsFile->pid = current->tgid;
+	pCifsFile->pInode = newinode;
+	pCifsFile->invalidHandle = false;
+	pCifsFile->closePend = false;
+	mutex_init(&pCifsFile->fh_mutex);
+	mutex_init(&pCifsFile->lock_mutex);
+	INIT_LIST_HEAD(&pCifsFile->llist);
+	atomic_set(&pCifsFile->wrtPending, 0);
+
+	/* set the following in open now
+			pCifsFile->pfile = file; */
+	write_lock(&GlobalSMBSeslock);
+	list_add(&pCifsFile->tlist, &tcon->openFileList);
+	pCifsInode = CIFS_I(newinode);
+	if (pCifsInode) {
+		/* if readable file instance put first in list*/
+		if (write_only)
+			list_add_tail(&pCifsFile->flist,
+				      &pCifsInode->openFileList);
+		else
+			list_add(&pCifsFile->flist, &pCifsInode->openFileList);
+
+		if ((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
+			pCifsInode->clientCanCacheAll = true;
+			pCifsInode->clientCanCacheRead = true;
+			cFYI(1, ("Exclusive Oplock inode %p", newinode));
+		} else if ((oplock & 0xF) == OPLOCK_READ)
+				pCifsInode->clientCanCacheRead = true;
+	}
+	write_unlock(&GlobalSMBSeslock);
+}
+
 int cifs_posix_open(char *full_path, struct inode **pinode,
 		    struct super_block *sb, int mode, int oflags,
 		    int *poplock, __u16 *pnetfid, int xid)
 {
 	int rc;
 	__u32 oplock;
+	bool write_only = false;
 	FILE_UNIX_BASIC_INFO *presp_data;
 	__u32 posix_flags = 0;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
@@ -172,6 +222,8 @@
 	if (oflags & O_DIRECT)
 		posix_flags |= SMB_O_DIRECT;
 
+	if (!(oflags & FMODE_READ))
+		write_only = true;
 
 	rc = CIFSPOSIXCreate(xid, cifs_sb->tcon, posix_flags, mode,
 			pnetfid, presp_data, &oplock, full_path,
@@ -187,8 +239,10 @@
 	if (!pinode)
 		goto posix_open_ret; /* caller does not need info */
 
-	if (*pinode == NULL)
-		*pinode = cifs_new_inode(sb, &presp_data->UniqueId);
+	if (*pinode == NULL) {
+		__u64 unique_id = le64_to_cpu(presp_data->UniqueId);
+		*pinode = cifs_new_inode(sb, &unique_id);
+	}
 	/* else an inode was passed in. Update its info, don't create one */
 
 	/* We do not need to close the file if new_inode fails since
@@ -198,6 +252,8 @@
 
 	posix_fill_in_inode(*pinode, presp_data, 1);
 
+	cifs_fill_fileinfo(*pinode, *pnetfid, cifs_sb->tcon, write_only);
+
 posix_open_ret:
 	kfree(presp_data);
 	return rc;
@@ -239,7 +295,6 @@
 	char *full_path = NULL;
 	FILE_ALL_INFO *buf = NULL;
 	struct inode *newinode = NULL;
-	struct cifsInodeInfo *pCifsInode;
 	int disposition = FILE_OVERWRITE_IF;
 	bool write_only = false;
 
@@ -410,44 +465,8 @@
 		/* mknod case - do not leave file open */
 		CIFSSMBClose(xid, tcon, fileHandle);
 	} else if (newinode) {
-		struct cifsFileInfo *pCifsFile =
-			kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);
-
-		if (pCifsFile == NULL)
-			goto cifs_create_out;
-		pCifsFile->netfid = fileHandle;
-		pCifsFile->pid = current->tgid;
-		pCifsFile->pInode = newinode;
-		pCifsFile->invalidHandle = false;
-		pCifsFile->closePend     = false;
-		init_MUTEX(&pCifsFile->fh_sem);
-		mutex_init(&pCifsFile->lock_mutex);
-		INIT_LIST_HEAD(&pCifsFile->llist);
-		atomic_set(&pCifsFile->wrtPending, 0);
-
-		/* set the following in open now
-				pCifsFile->pfile = file; */
-		write_lock(&GlobalSMBSeslock);
-		list_add(&pCifsFile->tlist, &tcon->openFileList);
-		pCifsInode = CIFS_I(newinode);
-		if (pCifsInode) {
-			/* if readable file instance put first in list*/
-			if (write_only) {
-				list_add_tail(&pCifsFile->flist,
-					      &pCifsInode->openFileList);
-			} else {
-				list_add(&pCifsFile->flist,
-					 &pCifsInode->openFileList);
-			}
-			if ((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
-				pCifsInode->clientCanCacheAll = true;
-				pCifsInode->clientCanCacheRead = true;
-				cFYI(1, ("Exclusive Oplock inode %p",
-					newinode));
-			} else if ((oplock & 0xF) == OPLOCK_READ)
-				pCifsInode->clientCanCacheRead = true;
-		}
-		write_unlock(&GlobalSMBSeslock);
+			cifs_fill_fileinfo(newinode, fileHandle,
+					cifs_sb->tcon, write_only);
 	}
 cifs_create_out:
 	kfree(buf);
@@ -580,17 +599,21 @@
 	return rc;
 }
 
-
 struct dentry *
 cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
 	    struct nameidata *nd)
 {
 	int xid;
 	int rc = 0; /* to get around spurious gcc warning, set to zero here */
+	int oplock = 0;
+	int mode;
+	__u16 fileHandle = 0;
+	bool posix_open = false;
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *pTcon;
 	struct inode *newInode = NULL;
 	char *full_path = NULL;
+	struct file *filp;
 
 	xid = GetXid();
 
@@ -632,12 +655,37 @@
 	}
 	cFYI(1, ("Full path: %s inode = 0x%p", full_path, direntry->d_inode));
 
-	if (pTcon->unix_ext)
-		rc = cifs_get_inode_info_unix(&newInode, full_path,
-					      parent_dir_inode->i_sb, xid);
-	else
+	if (pTcon->unix_ext) {
+		if (!(nd->flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY)) &&
+				(nd->flags & LOOKUP_OPEN)) {
+			if (!((nd->intent.open.flags & O_CREAT) &&
+					(nd->intent.open.flags & O_EXCL))) {
+				mode = nd->intent.open.create_mode &
+						~current_umask();
+				rc = cifs_posix_open(full_path, &newInode,
+					parent_dir_inode->i_sb, mode,
+					nd->intent.open.flags, &oplock,
+					&fileHandle, xid);
+				/*
+				 * This code works around a bug in
+				 * samba posix open in samba versions 3.3.1
+				 * and earlier where create works
+				 * but open fails with invalid parameter.
+				 * If either of these error codes are
+				 * returned, follow the normal lookup.
+				 * Otherwise, the error during posix open
+				 * is handled.
+				 */
+				if ((rc != -EINVAL) && (rc != -EOPNOTSUPP))
+					posix_open = true;
+			}
+		}
+		if (!posix_open)
+			rc = cifs_get_inode_info_unix(&newInode, full_path,
+						parent_dir_inode->i_sb, xid);
+	} else
 		rc = cifs_get_inode_info(&newInode, full_path, NULL,
-					 parent_dir_inode->i_sb, xid, NULL);
+				parent_dir_inode->i_sb, xid, NULL);
 
 	if ((rc == 0) && (newInode != NULL)) {
 		if (pTcon->nocase)
@@ -645,7 +693,8 @@
 		else
 			direntry->d_op = &cifs_dentry_ops;
 		d_add(direntry, newInode);
-
+		if (posix_open)
+			filp = lookup_instantiate_filp(nd, direntry, NULL);
 		/* since paths are not looked up by component - the parent
 		   directories are presumed to be good here */
 		renew_parental_timestamps(direntry);
diff -urN linux-2.6.30-rc2/fs/cifs/dns_resolve.c linux-2.6.30-rc3/fs/cifs/dns_resolve.c
--- linux-2.6.30-rc2/fs/cifs/dns_resolve.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/cifs/dns_resolve.c	2009-04-22 03:29:18.020931451 +0000
@@ -78,7 +78,7 @@
 	}
 
 	key->type_data.x[0] = datalen;
-	rcu_assign_pointer(key->payload.data, ip);
+	key->payload.data = ip;
 
 	return rc;
 }
diff -urN linux-2.6.30-rc2/fs/cifs/file.c linux-2.6.30-rc3/fs/cifs/file.c
--- linux-2.6.30-rc2/fs/cifs/file.c	2009-04-22 03:29:11.968931427 +0000
+++ linux-2.6.30-rc3/fs/cifs/file.c	2009-04-22 03:29:18.020931451 +0000
@@ -46,7 +46,7 @@
 	memset(private_data, 0, sizeof(struct cifsFileInfo));
 	private_data->netfid = netfid;
 	private_data->pid = current->tgid;
-	init_MUTEX(&private_data->fh_sem);
+	mutex_init(&private_data->fh_mutex);
 	mutex_init(&private_data->lock_mutex);
 	INIT_LIST_HEAD(&private_data->llist);
 	private_data->pfile = file; /* needed for writepage */
@@ -284,35 +284,32 @@
 	cifs_sb = CIFS_SB(inode->i_sb);
 	tcon = cifs_sb->tcon;
 
-	if (file->f_flags & O_CREAT) {
-		/* search inode for this file and fill in file->private_data */
-		pCifsInode = CIFS_I(file->f_path.dentry->d_inode);
-		read_lock(&GlobalSMBSeslock);
-		list_for_each(tmp, &pCifsInode->openFileList) {
-			pCifsFile = list_entry(tmp, struct cifsFileInfo,
-					       flist);
-			if ((pCifsFile->pfile == NULL) &&
-			    (pCifsFile->pid == current->tgid)) {
-				/* mode set in cifs_create */
+	/* search inode for this file and fill in file->private_data */
+	pCifsInode = CIFS_I(file->f_path.dentry->d_inode);
+	read_lock(&GlobalSMBSeslock);
+	list_for_each(tmp, &pCifsInode->openFileList) {
+		pCifsFile = list_entry(tmp, struct cifsFileInfo,
+				       flist);
+		if ((pCifsFile->pfile == NULL) &&
+		    (pCifsFile->pid == current->tgid)) {
+			/* mode set in cifs_create */
 
-				/* needed for writepage */
-				pCifsFile->pfile = file;
+			/* needed for writepage */
+			pCifsFile->pfile = file;
 
-				file->private_data = pCifsFile;
-				break;
-			}
-		}
-		read_unlock(&GlobalSMBSeslock);
-		if (file->private_data != NULL) {
-			rc = 0;
-			FreeXid(xid);
-			return rc;
-		} else {
-			if (file->f_flags & O_EXCL)
-				cERROR(1, ("could not find file instance for "
-					   "new file %p", file));
+			file->private_data = pCifsFile;
+			break;
 		}
 	}
+	read_unlock(&GlobalSMBSeslock);
+
+	if (file->private_data != NULL) {
+		rc = 0;
+		FreeXid(xid);
+		return rc;
+	} else if ((file->f_flags & O_CREAT) && (file->f_flags & O_EXCL))
+			cERROR(1, ("could not find file instance for "
+				   "new file %p", file));
 
 	full_path = build_path_from_dentry(file->f_path.dentry);
 	if (full_path == NULL) {
@@ -500,9 +497,9 @@
 		return -EBADF;
 
 	xid = GetXid();
-	down(&pCifsFile->fh_sem);
+	mutex_unlock(&pCifsFile->fh_mutex);
 	if (!pCifsFile->invalidHandle) {
-		up(&pCifsFile->fh_sem);
+		mutex_lock(&pCifsFile->fh_mutex);
 		FreeXid(xid);
 		return 0;
 	}
@@ -533,7 +530,7 @@
 	if (full_path == NULL) {
 		rc = -ENOMEM;
 reopen_error_exit:
-		up(&pCifsFile->fh_sem);
+		mutex_lock(&pCifsFile->fh_mutex);
 		FreeXid(xid);
 		return rc;
 	}
@@ -575,14 +572,14 @@
 			 cifs_sb->local_nls, cifs_sb->mnt_cifs_flags &
 				CIFS_MOUNT_MAP_SPECIAL_CHR);
 	if (rc) {
-		up(&pCifsFile->fh_sem);
+		mutex_lock(&pCifsFile->fh_mutex);
 		cFYI(1, ("cifs_open returned 0x%x", rc));
 		cFYI(1, ("oplock: %d", oplock));
 	} else {
 reopen_success:
 		pCifsFile->netfid = netfid;
 		pCifsFile->invalidHandle = false;
-		up(&pCifsFile->fh_sem);
+		mutex_lock(&pCifsFile->fh_mutex);
 		pCifsInode = CIFS_I(inode);
 		if (pCifsInode) {
 			if (can_flush) {
@@ -971,6 +968,40 @@
 	return rc;
 }
 
+/*
+ * Set the timeout on write requests past EOF. For some servers (Windows)
+ * these calls can be very long.
+ *
+ * If we're writing >10M past the EOF we give a 180s timeout. Anything less
+ * than that gets a 45s timeout. Writes not past EOF get 15s timeouts.
+ * The 10M cutoff is totally arbitrary. A better scheme for this would be
+ * welcome if someone wants to suggest one.
+ *
+ * We may be able to do a better job with this if there were some way to
+ * declare that a file should be sparse.
+ */
+static int
+cifs_write_timeout(struct cifsInodeInfo *cifsi, loff_t offset)
+{
+	if (offset <= cifsi->server_eof)
+		return CIFS_STD_OP;
+	else if (offset > (cifsi->server_eof + (10 * 1024 * 1024)))
+		return CIFS_VLONG_OP;
+	else
+		return CIFS_LONG_OP;
+}
+
+/* update the file size (if needed) after a write */
+static void
+cifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,
+		      unsigned int bytes_written)
+{
+	loff_t end_of_write = offset + bytes_written;
+
+	if (end_of_write > cifsi->server_eof)
+		cifsi->server_eof = end_of_write;
+}
+
 ssize_t cifs_user_write(struct file *file, const char __user *write_data,
 	size_t write_size, loff_t *poffset)
 {
@@ -981,6 +1012,7 @@
 	struct cifsTconInfo *pTcon;
 	int xid, long_op;
 	struct cifsFileInfo *open_file;
+	struct cifsInodeInfo *cifsi = CIFS_I(file->f_path.dentry->d_inode);
 
 	cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);
 
@@ -1000,11 +1032,7 @@
 
 	xid = GetXid();
 
-	if (*poffset > file->f_path.dentry->d_inode->i_size)
-		long_op = CIFS_VLONG_OP; /* writes past EOF take long time */
-	else
-		long_op = CIFS_LONG_OP;
-
+	long_op = cifs_write_timeout(cifsi, *poffset);
 	for (total_written = 0; write_size > total_written;
 	     total_written += bytes_written) {
 		rc = -EAGAIN;
@@ -1048,8 +1076,10 @@
 				FreeXid(xid);
 				return rc;
 			}
-		} else
+		} else {
+			cifs_update_eof(cifsi, *poffset, bytes_written);
 			*poffset += bytes_written;
+		}
 		long_op = CIFS_STD_OP; /* subsequent writes fast -
 				    15 seconds is plenty */
 	}
@@ -1085,6 +1115,7 @@
 	struct cifsTconInfo *pTcon;
 	int xid, long_op;
 	struct cifsFileInfo *open_file;
+	struct cifsInodeInfo *cifsi = CIFS_I(file->f_path.dentry->d_inode);
 
 	cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);
 
@@ -1099,11 +1130,7 @@
 
 	xid = GetXid();
 
-	if (*poffset > file->f_path.dentry->d_inode->i_size)
-		long_op = CIFS_VLONG_OP; /* writes past EOF can be slow */
-	else
-		long_op = CIFS_LONG_OP;
-
+	long_op = cifs_write_timeout(cifsi, *poffset);
 	for (total_written = 0; write_size > total_written;
 	     total_written += bytes_written) {
 		rc = -EAGAIN;
@@ -1166,8 +1193,10 @@
 				FreeXid(xid);
 				return rc;
 			}
-		} else
+		} else {
+			cifs_update_eof(cifsi, *poffset, bytes_written);
 			*poffset += bytes_written;
+		}
 		long_op = CIFS_STD_OP; /* subsequent writes fast -
 				    15 seconds is plenty */
 	}
@@ -1380,11 +1409,12 @@
 	int nr_pages;
 	__u64 offset = 0;
 	struct cifsFileInfo *open_file;
+	struct cifsInodeInfo *cifsi = CIFS_I(mapping->host);
 	struct page *page;
 	struct pagevec pvec;
 	int rc = 0;
 	int scanned = 0;
-	int xid;
+	int xid, long_op;
 
 	cifs_sb = CIFS_SB(mapping->host->i_sb);
 
@@ -1528,12 +1558,15 @@
 				cERROR(1, ("No writable handles for inode"));
 				rc = -EBADF;
 			} else {
+				long_op = cifs_write_timeout(cifsi, offset);
 				rc = CIFSSMBWrite2(xid, cifs_sb->tcon,
 						   open_file->netfid,
 						   bytes_to_write, offset,
 						   &bytes_written, iov, n_iov,
-						   CIFS_LONG_OP);
+						   long_op);
 				atomic_dec(&open_file->wrtPending);
+				cifs_update_eof(cifsi, offset, bytes_written);
+
 				if (rc || bytes_written < bytes_to_write) {
 					cERROR(1, ("Write2 ret %d, wrote %d",
 						  rc, bytes_written));
diff -urN linux-2.6.30-rc2/fs/cifs/inode.c linux-2.6.30-rc3/fs/cifs/inode.c
--- linux-2.6.30-rc2/fs/cifs/inode.c	2009-04-22 03:29:11.969931417 +0000
+++ linux-2.6.30-rc3/fs/cifs/inode.c	2009-04-22 03:29:18.021931420 +0000
@@ -143,6 +143,7 @@
 
 	inode->i_nlink = le64_to_cpu(info->Nlinks);
 
+	cifsInfo->server_eof = end_of_file;
 	spin_lock(&inode->i_lock);
 	if (is_size_safe_to_change(cifsInfo, end_of_file)) {
 		/*
@@ -276,7 +277,8 @@
 
 	/* get new inode */
 	if (*pinode == NULL) {
-		*pinode = cifs_new_inode(sb, &find_data.UniqueId);
+		__u64 unique_id = le64_to_cpu(find_data.UniqueId);
+		*pinode = cifs_new_inode(sb, &unique_id);
 		if (*pinode == NULL) {
 			rc = -ENOMEM;
 			goto cgiiu_exit;
@@ -605,12 +607,12 @@
 			inode->i_mode |= S_IFREG;
 	}
 
+	cifsInfo->server_eof = le64_to_cpu(pfindData->EndOfFile);
 	spin_lock(&inode->i_lock);
-	if (is_size_safe_to_change(cifsInfo,
-				   le64_to_cpu(pfindData->EndOfFile))) {
+	if (is_size_safe_to_change(cifsInfo, cifsInfo->server_eof)) {
 		/* can not safely shrink the file size here if the
 		   client is writing to it due to potential races */
-		i_size_write(inode, le64_to_cpu(pfindData->EndOfFile));
+		i_size_write(inode, cifsInfo->server_eof);
 
 		/* 512 bytes (2**9) is the fake blocksize that must be
 		   used for this calculation */
@@ -1138,6 +1140,7 @@
 			cFYI(1, ("posix mkdir returned 0x%x", rc));
 			d_drop(direntry);
 		} else {
+			__u64 unique_id;
 			if (pInfo->Type == cpu_to_le32(-1)) {
 				/* no return info, go query for it */
 				kfree(pInfo);
@@ -1151,8 +1154,8 @@
 			else
 				direntry->d_op = &cifs_dentry_ops;
 
-			newinode = cifs_new_inode(inode->i_sb,
-						  &pInfo->UniqueId);
+			unique_id = le64_to_cpu(pInfo->UniqueId);
+			newinode = cifs_new_inode(inode->i_sb, &unique_id);
 			if (newinode == NULL) {
 				kfree(pInfo);
 				goto mkdir_get_info;
@@ -1450,7 +1453,8 @@
 		     checking the UniqueId via FILE_INTERNAL_INFO */
 
 unlink_target:
-	if ((rc == -EACCES) || (rc == -EEXIST)) {
+	/* Try unlinking the target dentry if it's not negative */
+	if (target_dentry->d_inode && (rc == -EACCES || rc == -EEXIST)) {
 		tmprc = cifs_unlink(target_dir, target_dentry);
 		if (tmprc)
 			goto cifs_rename_exit;
@@ -1753,6 +1757,7 @@
 	}
 
 	if (rc == 0) {
+		cifsInode->server_eof = attrs->ia_size;
 		rc = cifs_vmtruncate(inode, attrs->ia_size);
 		cifs_truncate_page(inode->i_mapping, inode->i_size);
 	}
@@ -1792,20 +1797,21 @@
 		goto out;
 	}
 
-	if ((attrs->ia_valid & ATTR_MTIME) || (attrs->ia_valid & ATTR_SIZE)) {
-		/*
-		   Flush data before changing file size or changing the last
-		   write time of the file on the server. If the
-		   flush returns error, store it to report later and continue.
-		   BB: This should be smarter. Why bother flushing pages that
-		   will be truncated anyway? Also, should we error out here if
-		   the flush returns error?
-		 */
-		rc = filemap_write_and_wait(inode->i_mapping);
-		if (rc != 0) {
-			cifsInode->write_behind_rc = rc;
-			rc = 0;
-		}
+	/*
+	 * Attempt to flush data before changing attributes. We need to do
+	 * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the
+	 * ownership or mode then we may also need to do this. Here, we take
+	 * the safe way out and just do the flush on all setattr requests. If
+	 * the flush returns error, store it to report later and continue.
+	 *
+	 * BB: This should be smarter. Why bother flushing pages that
+	 * will be truncated anyway? Also, should we error out here if
+	 * the flush returns error?
+	 */
+	rc = filemap_write_and_wait(inode->i_mapping);
+	if (rc != 0) {
+		cifsInode->write_behind_rc = rc;
+		rc = 0;
 	}
 
 	if (attrs->ia_valid & ATTR_SIZE) {
@@ -1903,20 +1909,21 @@
 		return -ENOMEM;
 	}
 
-	if ((attrs->ia_valid & ATTR_MTIME) || (attrs->ia_valid & ATTR_SIZE)) {
-		/*
-		   Flush data before changing file size or changing the last
-		   write time of the file on the server. If the
-		   flush returns error, store it to report later and continue.
-		   BB: This should be smarter. Why bother flushing pages that
-		   will be truncated anyway? Also, should we error out here if
-		   the flush returns error?
-		 */
-		rc = filemap_write_and_wait(inode->i_mapping);
-		if (rc != 0) {
-			cifsInode->write_behind_rc = rc;
-			rc = 0;
-		}
+	/*
+	 * Attempt to flush data before changing attributes. We need to do
+	 * this for ATTR_SIZE and ATTR_MTIME for sure, and if we change the
+	 * ownership or mode then we may also need to do this. Here, we take
+	 * the safe way out and just do the flush on all setattr requests. If
+	 * the flush returns error, store it to report later and continue.
+	 *
+	 * BB: This should be smarter. Why bother flushing pages that
+	 * will be truncated anyway? Also, should we error out here if
+	 * the flush returns error?
+	 */
+	rc = filemap_write_and_wait(inode->i_mapping);
+	if (rc != 0) {
+		cifsInode->write_behind_rc = rc;
+		rc = 0;
 	}
 
 	if (attrs->ia_valid & ATTR_SIZE) {
diff -urN linux-2.6.30-rc2/fs/cifs/readdir.c linux-2.6.30-rc3/fs/cifs/readdir.c
--- linux-2.6.30-rc2/fs/cifs/readdir.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/cifs/readdir.c	2009-04-22 03:29:18.021931420 +0000
@@ -239,6 +239,7 @@
 	if (atomic_read(&cifsInfo->inUse) == 0)
 		atomic_set(&cifsInfo->inUse, 1);
 
+	cifsInfo->server_eof = end_of_file;
 	spin_lock(&tmp_inode->i_lock);
 	if (is_size_safe_to_change(cifsInfo, end_of_file)) {
 		/* can not safely change the file size here if the
@@ -375,6 +376,7 @@
 		tmp_inode->i_gid = le64_to_cpu(pfindData->Gid);
 	tmp_inode->i_nlink = le64_to_cpu(pfindData->Nlinks);
 
+	cifsInfo->server_eof = end_of_file;
 	spin_lock(&tmp_inode->i_lock);
 	if (is_size_safe_to_change(cifsInfo, end_of_file)) {
 		/* can not safely change the file size here if the
@@ -840,7 +842,7 @@
 			len = strnlen(filename, PATH_MAX);
 		}
 
-		*pinum = pFindData->UniqueId;
+		*pinum = le64_to_cpu(pFindData->UniqueId);
 	} else if (level == SMB_FIND_FILE_DIRECTORY_INFO) {
 		FILE_DIRECTORY_INFO *pFindData =
 			(FILE_DIRECTORY_INFO *)current_entry;
@@ -856,7 +858,7 @@
 			(SEARCH_ID_FULL_DIR_INFO *)current_entry;
 		filename = &pFindData->FileName[0];
 		len = le32_to_cpu(pFindData->FileNameLength);
-		*pinum = pFindData->UniqueId;
+		*pinum = le64_to_cpu(pFindData->UniqueId);
 	} else if (level == SMB_FIND_FILE_BOTH_DIRECTORY_INFO) {
 		FILE_BOTH_DIRECTORY_INFO *pFindData =
 			(FILE_BOTH_DIRECTORY_INFO *)current_entry;
diff -urN linux-2.6.30-rc2/fs/cifs/sess.c linux-2.6.30-rc3/fs/cifs/sess.c
--- linux-2.6.30-rc2/fs/cifs/sess.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/cifs/sess.c	2009-04-22 03:29:18.021931420 +0000
@@ -285,35 +285,36 @@
 	int words_left, len;
 	char *data = *pbcc_area;
 
-
-
 	cFYI(1, ("bleft %d", bleft));
 
-
-	/* SMB header is unaligned, so cifs servers word align start of
-	   Unicode strings */
-	data++;
-	bleft--; /* Windows servers do not always double null terminate
-		    their final Unicode string - in which case we
-		    now will not attempt to decode the byte of junk
-		    which follows it */
+	/*
+	 * Windows servers do not always double null terminate their final
+	 * Unicode string. Check to see if there are an uneven number of bytes
+	 * left. If so, then add an extra NULL pad byte to the end of the
+	 * response.
+	 *
+	 * See section 2.7.2 in "Implementing CIFS" for details
+	 */
+	if (bleft % 2) {
+		data[bleft] = 0;
+		++bleft;
+	}
 
 	words_left = bleft / 2;
 
 	/* save off server operating system */
 	len = UniStrnlen((wchar_t *) data, words_left);
 
-/* We look for obvious messed up bcc or strings in response so we do not go off
-   the end since (at least) WIN2K and Windows XP have a major bug in not null
-   terminating last Unicode string in response  */
 	if (len >= words_left)
 		return rc;
 
 	kfree(ses->serverOS);
 	/* UTF-8 string will not grow more than four times as big as UCS-16 */
 	ses->serverOS = kzalloc((4 * len) + 2 /* trailing null */, GFP_KERNEL);
-	if (ses->serverOS != NULL)
+	if (ses->serverOS != NULL) {
 		cifs_strfromUCS_le(ses->serverOS, (__le16 *)data, len, nls_cp);
+		cFYI(1, ("serverOS=%s", ses->serverOS));
+	}
 	data += 2 * (len + 1);
 	words_left -= len + 1;
 
@@ -328,6 +329,7 @@
 	if (ses->serverNOS != NULL) {
 		cifs_strfromUCS_le(ses->serverNOS, (__le16 *)data, len,
 				   nls_cp);
+		cFYI(1, ("serverNOS=%s", ses->serverNOS));
 		if (strncmp(ses->serverNOS, "NT LAN Manager 4", 16) == 0) {
 			cFYI(1, ("NT4 server"));
 			ses->flags |= CIFS_SES_NT4;
@@ -343,12 +345,11 @@
 		return rc;
 
 	kfree(ses->serverDomain);
-	ses->serverDomain = kzalloc(2 * (len + 1), GFP_KERNEL); /* BB FIXME wrong length */
+	ses->serverDomain = kzalloc((4 * len) + 2, GFP_KERNEL);
 	if (ses->serverDomain != NULL) {
 		cifs_strfromUCS_le(ses->serverDomain, (__le16 *)data, len,
 				   nls_cp);
-		ses->serverDomain[2*len] = 0;
-		ses->serverDomain[(2*len) + 1] = 0;
+		cFYI(1, ("serverDomain=%s", ses->serverDomain));
 	}
 	data += 2 * (len + 1);
 	words_left -= len + 1;
@@ -702,12 +703,18 @@
 	}
 
 	/* BB check if Unicode and decode strings */
-	if (smb_buf->Flags2 & SMBFLG2_UNICODE)
+	if (smb_buf->Flags2 & SMBFLG2_UNICODE) {
+		/* unicode string area must be word-aligned */
+		if (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {
+			++bcc_ptr;
+			--bytes_remaining;
+		}
 		rc = decode_unicode_ssetup(&bcc_ptr, bytes_remaining,
-						   ses, nls_cp);
-	else
+					   ses, nls_cp);
+	} else {
 		rc = decode_ascii_ssetup(&bcc_ptr, bytes_remaining,
 					 ses, nls_cp);
+	}
 
 ssetup_exit:
 	if (spnego_key) {
diff -urN linux-2.6.30-rc2/fs/compat.c linux-2.6.30-rc3/fs/compat.c
--- linux-2.6.30-rc2/fs/compat.c	2009-04-22 03:29:11.971176365 +0000
+++ linux-2.6.30-rc3/fs/compat.c	2009-04-22 03:29:18.022931402 +0000
@@ -181,22 +181,24 @@
 		struct compat_stat __user *statbuf)
 {
 	struct kstat stat;
-	int error = vfs_stat_fd(AT_FDCWD, filename, &stat);
+	int error;
 
-	if (!error)
-		error = cp_compat_stat(&stat, statbuf);
-	return error;
+	error = vfs_stat(filename, &stat);
+	if (error)
+		return error;
+	return cp_compat_stat(&stat, statbuf);
 }
 
 asmlinkage long compat_sys_newlstat(char __user * filename,
 		struct compat_stat __user *statbuf)
 {
 	struct kstat stat;
-	int error = vfs_lstat_fd(AT_FDCWD, filename, &stat);
+	int error;
 
-	if (!error)
-		error = cp_compat_stat(&stat, statbuf);
-	return error;
+	error = vfs_lstat(filename, &stat);
+	if (error)
+		return error;
+	return cp_compat_stat(&stat, statbuf);
 }
 
 #ifndef __ARCH_WANT_STAT64
@@ -204,21 +206,12 @@
 		struct compat_stat __user *statbuf, int flag)
 {
 	struct kstat stat;
-	int error = -EINVAL;
-
-	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
-		goto out;
-
-	if (flag & AT_SYMLINK_NOFOLLOW)
-		error = vfs_lstat_fd(dfd, filename, &stat);
-	else
-		error = vfs_stat_fd(dfd, filename, &stat);
-
-	if (!error)
-		error = cp_compat_stat(&stat, statbuf);
+	int error;
 
-out:
-	return error;
+	error = vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_compat_stat(&stat, statbuf);
 }
 #endif
 
diff -urN linux-2.6.30-rc2/fs/compat_ioctl.c linux-2.6.30-rc3/fs/compat_ioctl.c
--- linux-2.6.30-rc2/fs/compat_ioctl.c	2009-04-22 03:29:11.971176365 +0000
+++ linux-2.6.30-rc3/fs/compat_ioctl.c	2009-04-22 03:29:18.023931503 +0000
@@ -58,7 +58,6 @@
 #include <linux/i2c.h>
 #include <linux/i2c-dev.h>
 #include <linux/atalk.h>
-#include <linux/loop.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci.h>
@@ -68,6 +67,7 @@
 #include <linux/gigaset_dev.h>
 
 #ifdef CONFIG_BLOCK
+#include <linux/loop.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_ioctl.h>
 #include <scsi/sg.h>
@@ -2660,6 +2660,8 @@
 HANDLE_IOCTL(SONET_GETFRSENSE, do_atm_ioctl)
 /* block stuff */
 #ifdef CONFIG_BLOCK
+/* loop */
+IGNORE_IOCTL(LOOP_CLR_FD)
 /* Raw devices */
 HANDLE_IOCTL(RAW_SETBIND, raw_ioctl)
 HANDLE_IOCTL(RAW_GETBIND, raw_ioctl)
@@ -2728,9 +2730,6 @@
 IGNORE_IOCTL(VFAT_IOCTL_READDIR_BOTH32)
 IGNORE_IOCTL(VFAT_IOCTL_READDIR_SHORT32)
 
-/* loop */
-IGNORE_IOCTL(LOOP_CLR_FD)
-
 #ifdef CONFIG_SPARC
 /* Sparc framebuffers, handled in sbusfb_compat_ioctl() */
 IGNORE_IOCTL(FBIOGTYPE)
diff -urN linux-2.6.30-rc2/fs/dcache.c linux-2.6.30-rc3/fs/dcache.c
--- linux-2.6.30-rc2/fs/dcache.c	2009-04-22 03:29:11.972931374 +0000
+++ linux-2.6.30-rc3/fs/dcache.c	2009-04-22 03:29:18.024931536 +0000
@@ -2149,7 +2149,6 @@
 	int result;
 	unsigned long seq;
 
-	/* FIXME: This is old behavior, needed? Please check callers. */
 	if (new_dentry == old_dentry)
 		return 1;
 
diff -urN linux-2.6.30-rc2/fs/direct-io.c linux-2.6.30-rc3/fs/direct-io.c
--- linux-2.6.30-rc2/fs/direct-io.c	2009-04-22 03:29:11.972931374 +0000
+++ linux-2.6.30-rc3/fs/direct-io.c	2009-04-22 03:29:18.025931397 +0000
@@ -307,8 +307,6 @@
 	struct bio *bio;
 
 	bio = bio_alloc(GFP_KERNEL, nr_vecs);
-	if (bio == NULL)
-		return -ENOMEM;
 
 	bio->bi_bdev = bdev;
 	bio->bi_sector = first_sector;
diff -urN linux-2.6.30-rc2/fs/ecryptfs/miscdev.c linux-2.6.30-rc3/fs/ecryptfs/miscdev.c
--- linux-2.6.30-rc2/fs/ecryptfs/miscdev.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/ecryptfs/miscdev.c	2009-04-22 03:29:18.030931206 +0000
@@ -418,18 +418,13 @@
 
 	if (count == 0)
 		goto out;
-	data = kmalloc(count, GFP_KERNEL);
-	if (!data) {
-		printk(KERN_ERR "%s: Out of memory whilst attempting to "
-		       "kmalloc([%zd], GFP_KERNEL)\n", __func__, count);
+
+	data = memdup_user(buf, count);
+	if (IS_ERR(data)) {
+		printk(KERN_ERR "%s: memdup_user returned error [%ld]\n",
+		       __func__, PTR_ERR(data));
 		goto out;
 	}
-	rc = copy_from_user(data, buf, count);
-	if (rc) {
-		printk(KERN_ERR "%s: copy_from_user returned error [%d]\n",
-		       __func__, rc);
-		goto out_free;
-	}
 	sz = count;
 	i = 0;
 	switch (data[i++]) {
diff -urN linux-2.6.30-rc2/fs/ext4/extents.c linux-2.6.30-rc3/fs/ext4/extents.c
--- linux-2.6.30-rc2/fs/ext4/extents.c	2009-04-22 03:29:11.988931414 +0000
+++ linux-2.6.30-rc3/fs/ext4/extents.c	2009-04-22 03:29:18.041556310 +0000
@@ -2416,8 +2416,6 @@
 			len = ee_len;
 
 		bio = bio_alloc(GFP_NOIO, len);
-		if (!bio)
-			return -ENOMEM;
 		bio->bi_sector = ee_pblock;
 		bio->bi_bdev   = inode->i_sb->s_bdev;
 
diff -urN linux-2.6.30-rc2/fs/fat/Kconfig linux-2.6.30-rc3/fs/fat/Kconfig
--- linux-2.6.30-rc2/fs/fat/Kconfig	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/fat/Kconfig	2009-04-22 03:29:18.048931418 +0000
@@ -95,3 +95,6 @@
 	  Note that "utf8" is not recommended for FAT filesystems.
 	  If unsure, you shouldn't set "utf8" here.
 	  See <file:Documentation/filesystems/vfat.txt> for more information.
+
+	  Enable any character sets you need in File Systems/Native Language
+	  Support.
diff -urN linux-2.6.30-rc2/fs/filesystems.c linux-2.6.30-rc3/fs/filesystems.c
--- linux-2.6.30-rc2/fs/filesystems.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/filesystems.c	2009-04-22 03:29:18.049756916 +0000
@@ -199,7 +199,7 @@
 	return retval;
 }
 
-int get_filesystem_list(char * buf)
+int __init get_filesystem_list(char *buf)
 {
 	int len = 0;
 	struct file_system_type * tmp;
diff -urN linux-2.6.30-rc2/fs/gfs2/glock.c linux-2.6.30-rc3/fs/gfs2/glock.c
--- linux-2.6.30-rc2/fs/gfs2/glock.c	2009-04-22 03:29:12.002931420 +0000
+++ linux-2.6.30-rc3/fs/gfs2/glock.c	2009-04-22 03:29:18.055781041 +0000
@@ -597,7 +597,6 @@
 
 	GLOCK_BUG_ON(gl, test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags));
 
-	down_read(&gfs2_umount_flush_sem);
 	if (test_bit(GLF_DEMOTE, &gl->gl_flags) &&
 	    gl->gl_demote_state != gl->gl_state) {
 		if (find_first_holder(gl))
@@ -614,15 +613,14 @@
 		if (ret == 0)
 			goto out_unlock;
 		if (ret == 2)
-			goto out_sem;
+			goto out;
 		gh = find_first_waiter(gl);
 		gl->gl_target = gh->gh_state;
 		if (!(gh->gh_flags & (LM_FLAG_TRY | LM_FLAG_TRY_1CB)))
 			do_error(gl, 0); /* Fail queued try locks */
 	}
 	do_xmote(gl, gh, gl->gl_target);
-out_sem:
-	up_read(&gfs2_umount_flush_sem);
+out:
 	return;
 
 out_sched:
@@ -631,7 +629,7 @@
 		gfs2_glock_put(gl);
 out_unlock:
 	clear_bit(GLF_LOCK, &gl->gl_flags);
-	goto out_sem;
+	goto out;
 }
 
 static void glock_work_func(struct work_struct *work)
@@ -641,6 +639,7 @@
 
 	if (test_and_clear_bit(GLF_REPLY_PENDING, &gl->gl_flags))
 		finish_xmote(gl, gl->gl_reply);
+	down_read(&gfs2_umount_flush_sem);
 	spin_lock(&gl->gl_spin);
 	if (test_and_clear_bit(GLF_PENDING_DEMOTE, &gl->gl_flags) &&
 	    gl->gl_state != LM_ST_UNLOCKED &&
@@ -653,6 +652,7 @@
 	}
 	run_queue(gl, 0);
 	spin_unlock(&gl->gl_spin);
+	up_read(&gfs2_umount_flush_sem);
 	if (!delay ||
 	    queue_delayed_work(glock_workqueue, &gl->gl_work, delay) == 0)
 		gfs2_glock_put(gl);
diff -urN linux-2.6.30-rc2/fs/gfs2/glops.c linux-2.6.30-rc3/fs/gfs2/glops.c
--- linux-2.6.30-rc2/fs/gfs2/glops.c	2009-04-22 03:29:12.002931420 +0000
+++ linux-2.6.30-rc3/fs/gfs2/glops.c	2009-04-22 03:29:18.056931434 +0000
@@ -156,6 +156,12 @@
 	error = filemap_fdatawait(metamapping);
 	mapping_set_error(metamapping, error);
 	gfs2_ail_empty_gl(gl);
+	/*
+	 * Writeback of the data mapping may cause the dirty flag to be set
+	 * so we have to clear it again here.
+	 */
+	smp_mb__before_clear_bit();
+	clear_bit(GLF_DIRTY, &gl->gl_flags);
 }
 
 /**
diff -urN linux-2.6.30-rc2/fs/gfs2/inode.c linux-2.6.30-rc3/fs/gfs2/inode.c
--- linux-2.6.30-rc2/fs/gfs2/inode.c	2009-04-22 03:29:12.003931491 +0000
+++ linux-2.6.30-rc3/fs/gfs2/inode.c	2009-04-22 03:29:18.056931434 +0000
@@ -137,15 +137,15 @@
 	if (S_ISREG(mode)) {
 		inode->i_op = &gfs2_file_iops;
 		if (gfs2_localflocks(sdp))
-			inode->i_fop = gfs2_file_fops_nolock;
+			inode->i_fop = &gfs2_file_fops_nolock;
 		else
-			inode->i_fop = gfs2_file_fops;
+			inode->i_fop = &gfs2_file_fops;
 	} else if (S_ISDIR(mode)) {
 		inode->i_op = &gfs2_dir_iops;
 		if (gfs2_localflocks(sdp))
-			inode->i_fop = gfs2_dir_fops_nolock;
+			inode->i_fop = &gfs2_dir_fops_nolock;
 		else
-			inode->i_fop = gfs2_dir_fops;
+			inode->i_fop = &gfs2_dir_fops;
 	} else if (S_ISLNK(mode)) {
 		inode->i_op = &gfs2_symlink_iops;
 	} else {
diff -urN linux-2.6.30-rc2/fs/gfs2/inode.h linux-2.6.30-rc3/fs/gfs2/inode.h
--- linux-2.6.30-rc2/fs/gfs2/inode.h	2009-04-22 03:29:12.003931491 +0000
+++ linux-2.6.30-rc3/fs/gfs2/inode.h	2009-04-22 03:29:18.057931392 +0000
@@ -101,21 +101,23 @@
 extern const struct inode_operations gfs2_file_iops;
 extern const struct inode_operations gfs2_dir_iops;
 extern const struct inode_operations gfs2_symlink_iops;
-extern const struct file_operations *gfs2_file_fops_nolock;
-extern const struct file_operations *gfs2_dir_fops_nolock;
+extern const struct file_operations gfs2_file_fops_nolock;
+extern const struct file_operations gfs2_dir_fops_nolock;
 
 extern void gfs2_set_inode_flags(struct inode *inode);
  
 #ifdef CONFIG_GFS2_FS_LOCKING_DLM
-extern const struct file_operations *gfs2_file_fops;
-extern const struct file_operations *gfs2_dir_fops;
+extern const struct file_operations gfs2_file_fops;
+extern const struct file_operations gfs2_dir_fops;
+
 static inline int gfs2_localflocks(const struct gfs2_sbd *sdp)
 {
 	return sdp->sd_args.ar_localflocks;
 }
 #else /* Single node only */
-#define gfs2_file_fops NULL
-#define gfs2_dir_fops NULL
+#define gfs2_file_fops gfs2_file_fops_nolock
+#define gfs2_dir_fops gfs2_dir_fops_nolock
+
 static inline int gfs2_localflocks(const struct gfs2_sbd *sdp)
 {
 	return 1;
diff -urN linux-2.6.30-rc2/fs/gfs2/ops_file.c linux-2.6.30-rc3/fs/gfs2/ops_file.c
--- linux-2.6.30-rc2/fs/gfs2/ops_file.c	2009-04-22 03:29:12.006931436 +0000
+++ linux-2.6.30-rc3/fs/gfs2/ops_file.c	2009-04-22 03:29:18.060931603 +0000
@@ -413,7 +413,9 @@
 	gfs2_glock_dq(&gh);
 out:
 	gfs2_holder_uninit(&gh);
-	if (ret)
+	if (ret == -ENOMEM)
+		ret = VM_FAULT_OOM;
+	else if (ret)
 		ret = VM_FAULT_SIGBUS;
 	return ret;
 }
@@ -705,7 +707,7 @@
 	}
 }
 
-const struct file_operations *gfs2_file_fops = &(const struct file_operations){
+const struct file_operations gfs2_file_fops = {
 	.llseek		= gfs2_llseek,
 	.read		= do_sync_read,
 	.aio_read	= generic_file_aio_read,
@@ -723,7 +725,7 @@
 	.setlease	= gfs2_setlease,
 };
 
-const struct file_operations *gfs2_dir_fops = &(const struct file_operations){
+const struct file_operations gfs2_dir_fops = {
 	.readdir	= gfs2_readdir,
 	.unlocked_ioctl	= gfs2_ioctl,
 	.open		= gfs2_open,
@@ -735,7 +737,7 @@
 
 #endif /* CONFIG_GFS2_FS_LOCKING_DLM */
 
-const struct file_operations *gfs2_file_fops_nolock = &(const struct file_operations){
+const struct file_operations gfs2_file_fops_nolock = {
 	.llseek		= gfs2_llseek,
 	.read		= do_sync_read,
 	.aio_read	= generic_file_aio_read,
@@ -751,7 +753,7 @@
 	.setlease	= generic_setlease,
 };
 
-const struct file_operations *gfs2_dir_fops_nolock = &(const struct file_operations){
+const struct file_operations gfs2_dir_fops_nolock = {
 	.readdir	= gfs2_readdir,
 	.unlocked_ioctl	= gfs2_ioctl,
 	.open		= gfs2_open,
diff -urN linux-2.6.30-rc2/fs/gfs2/ops_fstype.c linux-2.6.30-rc3/fs/gfs2/ops_fstype.c
--- linux-2.6.30-rc2/fs/gfs2/ops_fstype.c	2009-04-22 03:29:12.007931579 +0000
+++ linux-2.6.30-rc3/fs/gfs2/ops_fstype.c	2009-04-22 03:29:18.060931603 +0000
@@ -272,11 +272,6 @@
 	lock_page(page);
 
 	bio = bio_alloc(GFP_NOFS, 1);
-	if (unlikely(!bio)) {
-		__free_page(page);
-		return -ENOBUFS;
-	}
-
 	bio->bi_sector = sector * (sb->s_blocksize >> 9);
 	bio->bi_bdev = sb->s_bdev;
 	bio_add_page(bio, page, PAGE_SIZE, 0);
diff -urN linux-2.6.30-rc2/fs/gfs2/ops_inode.c linux-2.6.30-rc3/fs/gfs2/ops_inode.c
--- linux-2.6.30-rc2/fs/gfs2/ops_inode.c	2009-04-22 03:29:12.007931579 +0000
+++ linux-2.6.30-rc3/fs/gfs2/ops_inode.c	2009-04-22 03:29:18.061931432 +0000
@@ -371,6 +371,7 @@
 	ip = ghs[1].gh_gl->gl_object;
 
 	ip->i_disksize = size;
+	i_size_write(inode, size);
 
 	error = gfs2_meta_inode_buffer(ip, &dibh);
 
diff -urN linux-2.6.30-rc2/fs/gfs2/quota.c linux-2.6.30-rc3/fs/gfs2/quota.c
--- linux-2.6.30-rc2/fs/gfs2/quota.c	2009-04-22 03:29:12.008931521 +0000
+++ linux-2.6.30-rc3/fs/gfs2/quota.c	2009-04-22 03:29:18.061931432 +0000
@@ -81,7 +81,7 @@
 
 static LIST_HEAD(qd_lru_list);
 static atomic_t qd_lru_count = ATOMIC_INIT(0);
-static spinlock_t qd_lru_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(qd_lru_lock);
 
 int gfs2_shrink_qd_memory(int nr, gfp_t gfp_mask)
 {
@@ -1364,7 +1364,7 @@
 			refrigerator();
 		t = min(quotad_timeo, statfs_timeo);
 
-		prepare_to_wait(&sdp->sd_quota_wait, &wait, TASK_UNINTERRUPTIBLE);
+		prepare_to_wait(&sdp->sd_quota_wait, &wait, TASK_INTERRUPTIBLE);
 		spin_lock(&sdp->sd_trunc_lock);
 		empty = list_empty(&sdp->sd_trunc_list);
 		spin_unlock(&sdp->sd_trunc_lock);
diff -urN linux-2.6.30-rc2/fs/hugetlbfs/inode.c linux-2.6.30-rc3/fs/hugetlbfs/inode.c
--- linux-2.6.30-rc2/fs/hugetlbfs/inode.c	2009-04-22 03:29:12.011931385 +0000
+++ linux-2.6.30-rc3/fs/hugetlbfs/inode.c	2009-04-22 03:29:18.065931442 +0000
@@ -26,7 +26,6 @@
 #include <linux/pagevec.h>
 #include <linux/parser.h>
 #include <linux/mman.h>
-#include <linux/quotaops.h>
 #include <linux/slab.h>
 #include <linux/dnotify.h>
 #include <linux/statfs.h>
@@ -842,7 +841,7 @@
 bad_val:
  	printk(KERN_ERR "hugetlbfs: Bad value '%s' for mount option '%s'\n",
 	       args[0].from, p);
- 	return 1;
+ 	return -EINVAL;
 }
 
 static int
diff -urN linux-2.6.30-rc2/fs/inode.c linux-2.6.30-rc3/fs/inode.c
--- linux-2.6.30-rc2/fs/inode.c	2009-04-22 03:29:12.012931413 +0000
+++ linux-2.6.30-rc3/fs/inode.c	2009-04-22 03:29:18.065931442 +0000
@@ -1470,42 +1470,6 @@
 	spin_lock(&inode_lock);
 }
 
-/*
- * We rarely want to lock two inodes that do not have a parent/child
- * relationship (such as directory, child inode) simultaneously. The
- * vast majority of file systems should be able to get along fine
- * without this. Do not use these functions except as a last resort.
- */
-void inode_double_lock(struct inode *inode1, struct inode *inode2)
-{
-	if (inode1 == NULL || inode2 == NULL || inode1 == inode2) {
-		if (inode1)
-			mutex_lock(&inode1->i_mutex);
-		else if (inode2)
-			mutex_lock(&inode2->i_mutex);
-		return;
-	}
-
-	if (inode1 < inode2) {
-		mutex_lock_nested(&inode1->i_mutex, I_MUTEX_PARENT);
-		mutex_lock_nested(&inode2->i_mutex, I_MUTEX_CHILD);
-	} else {
-		mutex_lock_nested(&inode2->i_mutex, I_MUTEX_PARENT);
-		mutex_lock_nested(&inode1->i_mutex, I_MUTEX_CHILD);
-	}
-}
-EXPORT_SYMBOL(inode_double_lock);
-
-void inode_double_unlock(struct inode *inode1, struct inode *inode2)
-{
-	if (inode1)
-		mutex_unlock(&inode1->i_mutex);
-
-	if (inode2 && inode2 != inode1)
-		mutex_unlock(&inode2->i_mutex);
-}
-EXPORT_SYMBOL(inode_double_unlock);
-
 static __initdata unsigned long ihash_entries;
 static int __init set_ihash_entries(char *str)
 {
diff -urN linux-2.6.30-rc2/fs/namei.c linux-2.6.30-rc3/fs/namei.c
--- linux-2.6.30-rc2/fs/namei.c	2009-04-22 03:29:12.021931471 +0000
+++ linux-2.6.30-rc3/fs/namei.c	2009-04-22 03:29:18.075931400 +0000
@@ -1248,6 +1248,8 @@
 	int err;
 	struct qstr this;
 
+	WARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));
+
 	err = __lookup_one_len(name, &this, base, len);
 	if (err)
 		return ERR_PTR(err);
diff -urN linux-2.6.30-rc2/fs/namespace.c linux-2.6.30-rc3/fs/namespace.c
--- linux-2.6.30-rc2/fs/namespace.c	2009-04-22 03:29:12.022931203 +0000
+++ linux-2.6.30-rc3/fs/namespace.c	2009-04-22 03:29:18.076931457 +0000
@@ -1377,7 +1377,7 @@
 	if (parent_path) {
 		detach_mnt(source_mnt, parent_path);
 		attach_mnt(source_mnt, path);
-		touch_mnt_namespace(current->nsproxy->mnt_ns);
+		touch_mnt_namespace(parent_path->mnt->mnt_ns);
 	} else {
 		mnt_set_mountpoint(dest_mnt, dest_dentry, source_mnt);
 		commit_tree(source_mnt);
@@ -1920,8 +1920,9 @@
 	if (data_page)
 		((char *)data_page)[PAGE_SIZE - 1] = 0;
 
-	/* Default to relatime */
-	mnt_flags |= MNT_RELATIME;
+	/* Default to relatime unless overriden */
+	if (!(flags & MS_NOATIME))
+		mnt_flags |= MNT_RELATIME;
 
 	/* Separate the per-mountpoint flags */
 	if (flags & MS_NOSUID)
diff -urN linux-2.6.30-rc2/fs/ncpfs/ioctl.c linux-2.6.30-rc3/fs/ncpfs/ioctl.c
--- linux-2.6.30-rc2/fs/ncpfs/ioctl.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/ncpfs/ioctl.c	2009-04-22 03:29:18.076931457 +0000
@@ -660,13 +660,10 @@
 			if (user.object_name_len > NCP_OBJECT_NAME_MAX_LEN)
 				return -ENOMEM;
 			if (user.object_name_len) {
-				newname = kmalloc(user.object_name_len, GFP_USER);
-				if (!newname)
-					return -ENOMEM;
-				if (copy_from_user(newname, user.object_name, user.object_name_len)) {
-					kfree(newname);
-					return -EFAULT;
-				}
+				newname = memdup_user(user.object_name,
+						      user.object_name_len);
+				if (IS_ERR(newname))
+					return PTR_ERR(newname);
 			} else {
 				newname = NULL;
 			}
@@ -760,13 +757,9 @@
 			if (user.len > NCP_PRIVATE_DATA_MAX_LEN)
 				return -ENOMEM;
 			if (user.len) {
-				new = kmalloc(user.len, GFP_USER);
-				if (!new)
-					return -ENOMEM;
-				if (copy_from_user(new, user.data, user.len)) {
-					kfree(new);
-					return -EFAULT;
-				}
+				new = memdup_user(user.data, user.len);
+				if (IS_ERR(new))
+					return PTR_ERR(new);
 			} else {
 				new = NULL;
 			}
diff -urN linux-2.6.30-rc2/fs/nfs/nfs3xdr.c linux-2.6.30-rc3/fs/nfs/nfs3xdr.c
--- linux-2.6.30-rc2/fs/nfs/nfs3xdr.c	2009-04-22 03:29:12.026862760 +0000
+++ linux-2.6.30-rc3/fs/nfs/nfs3xdr.c	2009-04-22 03:29:18.080567839 +0000
@@ -713,7 +713,8 @@
 	if (args->npages != 0)
 		xdr_encode_pages(buf, args->pages, 0, args->len);
 	else
-		req->rq_slen += args->len;
+		req->rq_slen = xdr_adjust_iovec(req->rq_svec,
+				p + XDR_QUADLEN(args->len));
 
 	err = nfsacl_encode(buf, base, args->inode,
 			    (args->mask & NFS_ACL) ?
diff -urN linux-2.6.30-rc2/fs/nfsd/nfs4recover.c linux-2.6.30-rc3/fs/nfsd/nfs4recover.c
--- linux-2.6.30-rc2/fs/nfsd/nfs4recover.c	2009-04-22 03:29:12.031931432 +0000
+++ linux-2.6.30-rc3/fs/nfsd/nfs4recover.c	2009-04-22 03:29:18.085931419 +0000
@@ -229,21 +229,23 @@
 		goto out;
 	status = vfs_readdir(filp, nfsd4_build_namelist, &names);
 	fput(filp);
+	mutex_lock(&dir->d_inode->i_mutex);
 	while (!list_empty(&names)) {
 		entry = list_entry(names.next, struct name_list, list);
 
 		dentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);
 		if (IS_ERR(dentry)) {
 			status = PTR_ERR(dentry);
-			goto out;
+			break;
 		}
 		status = f(dir, dentry);
 		dput(dentry);
 		if (status)
-			goto out;
+			break;
 		list_del(&entry->list);
 		kfree(entry);
 	}
+	mutex_unlock(&dir->d_inode->i_mutex);
 out:
 	while (!list_empty(&names)) {
 		entry = list_entry(names.next, struct name_list, list);
@@ -255,36 +257,6 @@
 }
 
 static int
-nfsd4_remove_clid_file(struct dentry *dir, struct dentry *dentry)
-{
-	int status;
-
-	if (!S_ISREG(dir->d_inode->i_mode)) {
-		printk("nfsd4: non-file found in client recovery directory\n");
-		return -EINVAL;
-	}
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
-	status = vfs_unlink(dir->d_inode, dentry);
-	mutex_unlock(&dir->d_inode->i_mutex);
-	return status;
-}
-
-static int
-nfsd4_clear_clid_dir(struct dentry *dir, struct dentry *dentry)
-{
-	int status;
-
-	/* For now this directory should already be empty, but we empty it of
-	 * any regular files anyway, just in case the directory was created by
-	 * a kernel from the future.... */
-	nfsd4_list_rec_dir(dentry, nfsd4_remove_clid_file);
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
-	status = vfs_rmdir(dir->d_inode, dentry);
-	mutex_unlock(&dir->d_inode->i_mutex);
-	return status;
-}
-
-static int
 nfsd4_unlink_clid_dir(char *name, int namlen)
 {
 	struct dentry *dentry;
@@ -294,18 +266,18 @@
 
 	mutex_lock(&rec_dir.dentry->d_inode->i_mutex);
 	dentry = lookup_one_len(name, rec_dir.dentry, namlen);
-	mutex_unlock(&rec_dir.dentry->d_inode->i_mutex);
 	if (IS_ERR(dentry)) {
 		status = PTR_ERR(dentry);
-		return status;
+		goto out_unlock;
 	}
 	status = -ENOENT;
 	if (!dentry->d_inode)
 		goto out;
-
-	status = nfsd4_clear_clid_dir(rec_dir.dentry, dentry);
+	status = vfs_rmdir(rec_dir.dentry->d_inode, dentry);
 out:
 	dput(dentry);
+out_unlock:
+	mutex_unlock(&rec_dir.dentry->d_inode->i_mutex);
 	return status;
 }
 
@@ -348,7 +320,7 @@
 	if (nfs4_has_reclaimed_state(child->d_name.name, false))
 		return 0;
 
-	status = nfsd4_clear_clid_dir(parent, child);
+	status = vfs_rmdir(parent->d_inode, child);
 	if (status)
 		printk("failed to remove client recovery directory %s\n",
 				child->d_name.name);
diff -urN linux-2.6.30-rc2/fs/nfsd/vfs.c linux-2.6.30-rc3/fs/nfsd/vfs.c
--- linux-2.6.30-rc2/fs/nfsd/vfs.c	2009-04-22 03:29:12.035556429 +0000
+++ linux-2.6.30-rc3/fs/nfsd/vfs.c	2009-04-22 03:29:18.089931468 +0000
@@ -116,10 +116,15 @@
 	}
 	if ((exp->ex_flags & NFSEXP_CROSSMOUNT) || EX_NOHIDE(exp2)) {
 		/* successfully crossed mount point */
-		exp_put(exp);
-		*expp = exp2;
+		/*
+		 * This is subtle: dentry is *not* under mnt at this point.
+		 * The only reason we are safe is that original mnt is pinned
+		 * down by exp, so we should dput before putting exp.
+		 */
 		dput(dentry);
 		*dpp = mounts;
+		exp_put(exp);
+		*expp = exp2;
 	} else {
 		exp_put(exp2);
 		dput(mounts);
@@ -1885,8 +1890,8 @@
 	return 0;
 }
 
-static int nfsd_buffered_readdir(struct file *file, filldir_t func,
-				 struct readdir_cd *cdp, loff_t *offsetp)
+static __be32 nfsd_buffered_readdir(struct file *file, filldir_t func,
+				    struct readdir_cd *cdp, loff_t *offsetp)
 {
 	struct readdir_data buf;
 	struct buffered_dirent *de;
@@ -1896,11 +1901,12 @@
 
 	buf.dirent = (void *)__get_free_page(GFP_KERNEL);
 	if (!buf.dirent)
-		return -ENOMEM;
+		return nfserrno(-ENOMEM);
 
 	offset = *offsetp;
 
 	while (1) {
+		struct inode *dir_inode = file->f_path.dentry->d_inode;
 		unsigned int reclen;
 
 		cdp->err = nfserr_eof; /* will be cleared on successful read */
@@ -1919,26 +1925,38 @@
 		if (!size)
 			break;
 
+		/*
+		 * Various filldir functions may end up calling back into
+		 * lookup_one_len() and the file system's ->lookup() method.
+		 * These expect i_mutex to be held, as it would within readdir.
+		 */
+		host_err = mutex_lock_killable(&dir_inode->i_mutex);
+		if (host_err)
+			break;
+
 		de = (struct buffered_dirent *)buf.dirent;
 		while (size > 0) {
 			offset = de->offset;
 
 			if (func(cdp, de->name, de->namlen, de->offset,
 				 de->ino, de->d_type))
-				goto done;
+				break;
 
 			if (cdp->err != nfs_ok)
-				goto done;
+				break;
 
 			reclen = ALIGN(sizeof(*de) + de->namlen,
 				       sizeof(u64));
 			size -= reclen;
 			de = (struct buffered_dirent *)((char *)de + reclen);
 		}
+		mutex_unlock(&dir_inode->i_mutex);
+		if (size > 0) /* We bailed out early */
+			break;
+
 		offset = vfs_llseek(file, 0, SEEK_CUR);
 	}
 
- done:
 	free_page((unsigned long)(buf.dirent));
 
 	if (host_err)
diff -urN linux-2.6.30-rc2/fs/ocfs2/file.c linux-2.6.30-rc3/fs/ocfs2/file.c
--- linux-2.6.30-rc2/fs/ocfs2/file.c	2009-04-22 03:29:12.059931627 +0000
+++ linux-2.6.30-rc3/fs/ocfs2/file.c	2009-04-22 03:29:18.113931475 +0000
@@ -1912,6 +1912,22 @@
 	return written ? written : ret;
 }
 
+static int ocfs2_splice_to_file(struct pipe_inode_info *pipe,
+				struct file *out,
+				struct splice_desc *sd)
+{
+	int ret;
+
+	ret = ocfs2_prepare_inode_for_write(out->f_path.dentry,	&sd->pos,
+					    sd->total_len, 0, NULL);
+	if (ret < 0) {
+		mlog_errno(ret);
+		return ret;
+	}
+
+	return splice_from_pipe_feed(pipe, sd, pipe_to_file);
+}
+
 static ssize_t ocfs2_file_splice_write(struct pipe_inode_info *pipe,
 				       struct file *out,
 				       loff_t *ppos,
@@ -1919,38 +1935,76 @@
 				       unsigned int flags)
 {
 	int ret;
-	struct inode *inode = out->f_path.dentry->d_inode;
+	struct address_space *mapping = out->f_mapping;
+	struct inode *inode = mapping->host;
+	struct splice_desc sd = {
+		.total_len = len,
+		.flags = flags,
+		.pos = *ppos,
+		.u.file = out,
+	};
 
 	mlog_entry("(0x%p, 0x%p, %u, '%.*s')\n", out, pipe,
 		   (unsigned int)len,
 		   out->f_path.dentry->d_name.len,
 		   out->f_path.dentry->d_name.name);
 
-	mutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);
-
-	ret = ocfs2_rw_lock(inode, 1);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out;
-	}
+	if (pipe->inode)
+		mutex_lock_nested(&pipe->inode->i_mutex, I_MUTEX_PARENT);
 
-	ret = ocfs2_prepare_inode_for_write(out->f_path.dentry, ppos, len, 0,
-					    NULL);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out_unlock;
-	}
+	splice_from_pipe_begin(&sd);
+	do {
+		ret = splice_from_pipe_next(pipe, &sd);
+		if (ret <= 0)
+			break;
+
+		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
+		ret = ocfs2_rw_lock(inode, 1);
+		if (ret < 0)
+			mlog_errno(ret);
+		else {
+			ret = ocfs2_splice_to_file(pipe, out, &sd);
+			ocfs2_rw_unlock(inode, 1);
+		}
+		mutex_unlock(&inode->i_mutex);
+	} while (ret > 0);
+	splice_from_pipe_end(pipe, &sd);
 
 	if (pipe->inode)
-		mutex_lock_nested(&pipe->inode->i_mutex, I_MUTEX_CHILD);
-	ret = generic_file_splice_write_nolock(pipe, out, ppos, len, flags);
-	if (pipe->inode)
 		mutex_unlock(&pipe->inode->i_mutex);
 
-out_unlock:
-	ocfs2_rw_unlock(inode, 1);
-out:
-	mutex_unlock(&inode->i_mutex);
+	if (sd.num_spliced)
+		ret = sd.num_spliced;
+
+	if (ret > 0) {
+		unsigned long nr_pages;
+
+		*ppos += ret;
+		nr_pages = (ret + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+
+		/*
+		 * If file or inode is SYNC and we actually wrote some data,
+		 * sync it.
+		 */
+		if (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {
+			int err;
+
+			mutex_lock(&inode->i_mutex);
+			err = ocfs2_rw_lock(inode, 1);
+			if (err < 0) {
+				mlog_errno(err);
+			} else {
+				err = generic_osync_inode(inode, mapping,
+						  OSYNC_METADATA|OSYNC_DATA);
+				ocfs2_rw_unlock(inode, 1);
+			}
+			mutex_unlock(&inode->i_mutex);
+
+			if (err)
+				ret = err;
+		}
+		balance_dirty_pages_ratelimited_nr(mapping, nr_pages);
+	}
 
 	mlog_exit(ret);
 	return ret;
diff -urN linux-2.6.30-rc2/fs/pipe.c linux-2.6.30-rc3/fs/pipe.c
--- linux-2.6.30-rc2/fs/pipe.c	2009-04-22 03:29:12.066931417 +0000
+++ linux-2.6.30-rc3/fs/pipe.c	2009-04-22 03:29:18.120931436 +0000
@@ -37,6 +37,42 @@
  * -- Manfred Spraul <manfred@colorfullife.com> 2002-05-09
  */
 
+static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)
+{
+	if (pipe->inode)
+		mutex_lock_nested(&pipe->inode->i_mutex, subclass);
+}
+
+void pipe_lock(struct pipe_inode_info *pipe)
+{
+	/*
+	 * pipe_lock() nests non-pipe inode locks (for writing to a file)
+	 */
+	pipe_lock_nested(pipe, I_MUTEX_PARENT);
+}
+EXPORT_SYMBOL(pipe_lock);
+
+void pipe_unlock(struct pipe_inode_info *pipe)
+{
+	if (pipe->inode)
+		mutex_unlock(&pipe->inode->i_mutex);
+}
+EXPORT_SYMBOL(pipe_unlock);
+
+void pipe_double_lock(struct pipe_inode_info *pipe1,
+		      struct pipe_inode_info *pipe2)
+{
+	BUG_ON(pipe1 == pipe2);
+
+	if (pipe1 < pipe2) {
+		pipe_lock_nested(pipe1, I_MUTEX_PARENT);
+		pipe_lock_nested(pipe2, I_MUTEX_CHILD);
+	} else {
+		pipe_lock_nested(pipe2, I_MUTEX_CHILD);
+		pipe_lock_nested(pipe1, I_MUTEX_PARENT);
+	}
+}
+
 /* Drop the inode semaphore and wait for a pipe event, atomically */
 void pipe_wait(struct pipe_inode_info *pipe)
 {
@@ -47,12 +83,10 @@
 	 * is considered a noninteractive wait:
 	 */
 	prepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);
-	if (pipe->inode)
-		mutex_unlock(&pipe->inode->i_mutex);
+	pipe_unlock(pipe);
 	schedule();
 	finish_wait(&pipe->wait, &wait);
-	if (pipe->inode)
-		mutex_lock(&pipe->inode->i_mutex);
+	pipe_lock(pipe);
 }
 
 static int
diff -urN linux-2.6.30-rc2/fs/proc/base.c linux-2.6.30-rc3/fs/proc/base.c
--- linux-2.6.30-rc2/fs/proc/base.c	2009-04-22 03:29:12.066931417 +0000
+++ linux-2.6.30-rc3/fs/proc/base.c	2009-04-22 03:29:18.120931436 +0000
@@ -648,14 +648,14 @@
 {
 	struct proc_mounts *p = file->private_data;
 	struct mnt_namespace *ns = p->ns;
-	unsigned res = 0;
+	unsigned res = POLLIN | POLLRDNORM;
 
 	poll_wait(file, &ns->poll, wait);
 
 	spin_lock(&vfsmount_lock);
 	if (p->event != ns->event) {
 		p->event = ns->event;
-		res = POLLERR;
+		res |= POLLERR | POLLPRI;
 	}
 	spin_unlock(&vfsmount_lock);
 
diff -urN linux-2.6.30-rc2/fs/splice.c linux-2.6.30-rc3/fs/splice.c
--- linux-2.6.30-rc2/fs/splice.c	2009-04-22 03:29:12.089931434 +0000
+++ linux-2.6.30-rc3/fs/splice.c	2009-04-22 03:29:18.144931453 +0000
@@ -182,8 +182,7 @@
 	do_wakeup = 0;
 	page_nr = 0;
 
-	if (pipe->inode)
-		mutex_lock(&pipe->inode->i_mutex);
+	pipe_lock(pipe);
 
 	for (;;) {
 		if (!pipe->readers) {
@@ -245,15 +244,13 @@
 		pipe->waiting_writers--;
 	}
 
-	if (pipe->inode) {
-		mutex_unlock(&pipe->inode->i_mutex);
+	pipe_unlock(pipe);
 
-		if (do_wakeup) {
-			smp_mb();
-			if (waitqueue_active(&pipe->wait))
-				wake_up_interruptible(&pipe->wait);
-			kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
-		}
+	if (do_wakeup) {
+		smp_mb();
+		if (waitqueue_active(&pipe->wait))
+			wake_up_interruptible(&pipe->wait);
+		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
 	}
 
 	while (page_nr < spd_pages)
@@ -555,8 +552,8 @@
  * SPLICE_F_MOVE isn't set, or we cannot move the page, we simply create
  * a new page in the output file page cache and fill/dirty that.
  */
-static int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
-			struct splice_desc *sd)
+int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
+		 struct splice_desc *sd)
 {
 	struct file *file = sd->u.file;
 	struct address_space *mapping = file->f_mapping;
@@ -600,108 +597,177 @@
 out:
 	return ret;
 }
+EXPORT_SYMBOL(pipe_to_file);
+
+static void wakeup_pipe_writers(struct pipe_inode_info *pipe)
+{
+	smp_mb();
+	if (waitqueue_active(&pipe->wait))
+		wake_up_interruptible(&pipe->wait);
+	kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
+}
 
 /**
- * __splice_from_pipe - splice data from a pipe to given actor
+ * splice_from_pipe_feed - feed available data from a pipe to a file
  * @pipe:	pipe to splice from
  * @sd:		information to @actor
  * @actor:	handler that splices the data
  *
  * Description:
- *    This function does little more than loop over the pipe and call
- *    @actor to do the actual moving of a single struct pipe_buffer to
- *    the desired destination. See pipe_to_file, pipe_to_sendpage, or
- *    pipe_to_user.
- *
+ *    This function loops over the pipe and calls @actor to do the
+ *    actual moving of a single struct pipe_buffer to the desired
+ *    destination.  It returns when there's no more buffers left in
+ *    the pipe or if the requested number of bytes (@sd->total_len)
+ *    have been copied.  It returns a positive number (one) if the
+ *    pipe needs to be filled with more data, zero if the required
+ *    number of bytes have been copied and -errno on error.
+ *
+ *    This, together with splice_from_pipe_{begin,end,next}, may be
+ *    used to implement the functionality of __splice_from_pipe() when
+ *    locking is required around copying the pipe buffers to the
+ *    destination.
  */
-ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,
-			   splice_actor *actor)
+int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,
+			  splice_actor *actor)
 {
-	int ret, do_wakeup, err;
-
-	ret = 0;
-	do_wakeup = 0;
-
-	for (;;) {
-		if (pipe->nrbufs) {
-			struct pipe_buffer *buf = pipe->bufs + pipe->curbuf;
-			const struct pipe_buf_operations *ops = buf->ops;
-
-			sd->len = buf->len;
-			if (sd->len > sd->total_len)
-				sd->len = sd->total_len;
-
-			err = actor(pipe, buf, sd);
-			if (err <= 0) {
-				if (!ret && err != -ENODATA)
-					ret = err;
+	int ret;
 
-				break;
-			}
+	while (pipe->nrbufs) {
+		struct pipe_buffer *buf = pipe->bufs + pipe->curbuf;
+		const struct pipe_buf_operations *ops = buf->ops;
+
+		sd->len = buf->len;
+		if (sd->len > sd->total_len)
+			sd->len = sd->total_len;
+
+		ret = actor(pipe, buf, sd);
+		if (ret <= 0) {
+			if (ret == -ENODATA)
+				ret = 0;
+			return ret;
+		}
+		buf->offset += ret;
+		buf->len -= ret;
+
+		sd->num_spliced += ret;
+		sd->len -= ret;
+		sd->pos += ret;
+		sd->total_len -= ret;
 
-			ret += err;
-			buf->offset += err;
-			buf->len -= err;
-
-			sd->len -= err;
-			sd->pos += err;
-			sd->total_len -= err;
-			if (sd->len)
-				continue;
+		if (!buf->len) {
+			buf->ops = NULL;
+			ops->release(pipe, buf);
+			pipe->curbuf = (pipe->curbuf + 1) & (PIPE_BUFFERS - 1);
+			pipe->nrbufs--;
+			if (pipe->inode)
+				sd->need_wakeup = true;
+		}
 
-			if (!buf->len) {
-				buf->ops = NULL;
-				ops->release(pipe, buf);
-				pipe->curbuf = (pipe->curbuf + 1) & (PIPE_BUFFERS - 1);
-				pipe->nrbufs--;
-				if (pipe->inode)
-					do_wakeup = 1;
-			}
+		if (!sd->total_len)
+			return 0;
+	}
 
-			if (!sd->total_len)
-				break;
-		}
+	return 1;
+}
+EXPORT_SYMBOL(splice_from_pipe_feed);
 
-		if (pipe->nrbufs)
-			continue;
+/**
+ * splice_from_pipe_next - wait for some data to splice from
+ * @pipe:	pipe to splice from
+ * @sd:		information about the splice operation
+ *
+ * Description:
+ *    This function will wait for some data and return a positive
+ *    value (one) if pipe buffers are available.  It will return zero
+ *    or -errno if no more data needs to be spliced.
+ */
+int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)
+{
+	while (!pipe->nrbufs) {
 		if (!pipe->writers)
-			break;
-		if (!pipe->waiting_writers) {
-			if (ret)
-				break;
-		}
+			return 0;
 
-		if (sd->flags & SPLICE_F_NONBLOCK) {
-			if (!ret)
-				ret = -EAGAIN;
-			break;
-		}
+		if (!pipe->waiting_writers && sd->num_spliced)
+			return 0;
 
-		if (signal_pending(current)) {
-			if (!ret)
-				ret = -ERESTARTSYS;
-			break;
-		}
+		if (sd->flags & SPLICE_F_NONBLOCK)
+			return -EAGAIN;
 
-		if (do_wakeup) {
-			smp_mb();
-			if (waitqueue_active(&pipe->wait))
-				wake_up_interruptible_sync(&pipe->wait);
-			kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
-			do_wakeup = 0;
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+
+		if (sd->need_wakeup) {
+			wakeup_pipe_writers(pipe);
+			sd->need_wakeup = false;
 		}
 
 		pipe_wait(pipe);
 	}
 
-	if (do_wakeup) {
-		smp_mb();
-		if (waitqueue_active(&pipe->wait))
-			wake_up_interruptible(&pipe->wait);
-		kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
-	}
+	return 1;
+}
+EXPORT_SYMBOL(splice_from_pipe_next);
 
-	return ret;
+/**
+ * splice_from_pipe_begin - start splicing from pipe
+ * @sd:		information about the splice operation
+ *
+ * Description:
+ *    This function should be called before a loop containing
+ *    splice_from_pipe_next() and splice_from_pipe_feed() to
+ *    initialize the necessary fields of @sd.
+ */
+void splice_from_pipe_begin(struct splice_desc *sd)
+{
+	sd->num_spliced = 0;
+	sd->need_wakeup = false;
+}
+EXPORT_SYMBOL(splice_from_pipe_begin);
+
+/**
+ * splice_from_pipe_end - finish splicing from pipe
+ * @pipe:	pipe to splice from
+ * @sd:		information about the splice operation
+ *
+ * Description:
+ *    This function will wake up pipe writers if necessary.  It should
+ *    be called after a loop containing splice_from_pipe_next() and
+ *    splice_from_pipe_feed().
+ */
+void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)
+{
+	if (sd->need_wakeup)
+		wakeup_pipe_writers(pipe);
+}
+EXPORT_SYMBOL(splice_from_pipe_end);
+
+/**
+ * __splice_from_pipe - splice data from a pipe to given actor
+ * @pipe:	pipe to splice from
+ * @sd:		information to @actor
+ * @actor:	handler that splices the data
+ *
+ * Description:
+ *    This function does little more than loop over the pipe and call
+ *    @actor to do the actual moving of a single struct pipe_buffer to
+ *    the desired destination. See pipe_to_file, pipe_to_sendpage, or
+ *    pipe_to_user.
+ *
+ */
+ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,
+			   splice_actor *actor)
+{
+	int ret;
+
+	splice_from_pipe_begin(sd);
+	do {
+		ret = splice_from_pipe_next(pipe, sd);
+		if (ret > 0)
+			ret = splice_from_pipe_feed(pipe, sd, actor);
+	} while (ret > 0);
+	splice_from_pipe_end(pipe, sd);
+
+	return sd->num_spliced ? sd->num_spliced : ret;
 }
 EXPORT_SYMBOL(__splice_from_pipe);
 
@@ -715,7 +781,7 @@
  * @actor:	handler that splices the data
  *
  * Description:
- *    See __splice_from_pipe. This function locks the input and output inodes,
+ *    See __splice_from_pipe. This function locks the pipe inode,
  *    otherwise it's identical to __splice_from_pipe().
  *
  */
@@ -724,7 +790,6 @@
 			 splice_actor *actor)
 {
 	ssize_t ret;
-	struct inode *inode = out->f_mapping->host;
 	struct splice_desc sd = {
 		.total_len = len,
 		.flags = flags,
@@ -732,30 +797,15 @@
 		.u.file = out,
 	};
 
-	/*
-	 * The actor worker might be calling ->write_begin and
-	 * ->write_end. Most of the time, these expect i_mutex to
-	 * be held. Since this may result in an ABBA deadlock with
-	 * pipe->inode, we have to order lock acquiry here.
-	 *
-	 * Outer lock must be inode->i_mutex, as pipe_wait() will
-	 * release and reacquire pipe->inode->i_mutex, AND inode must
-	 * never be a pipe.
-	 */
-	WARN_ON(S_ISFIFO(inode->i_mode));
-	mutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);
-	if (pipe->inode)
-		mutex_lock_nested(&pipe->inode->i_mutex, I_MUTEX_CHILD);
+	pipe_lock(pipe);
 	ret = __splice_from_pipe(pipe, &sd, actor);
-	if (pipe->inode)
-		mutex_unlock(&pipe->inode->i_mutex);
-	mutex_unlock(&inode->i_mutex);
+	pipe_unlock(pipe);
 
 	return ret;
 }
 
 /**
- * generic_file_splice_write_nolock - generic_file_splice_write without mutexes
+ * generic_file_splice_write - splice data from a pipe to a file
  * @pipe:	pipe info
  * @out:	file to write to
  * @ppos:	position in @out
@@ -764,13 +814,12 @@
  *
  * Description:
  *    Will either move or copy pages (determined by @flags options) from
- *    the given pipe inode to the given file. The caller is responsible
- *    for acquiring i_mutex on both inodes.
+ *    the given pipe inode to the given file.
  *
  */
 ssize_t
-generic_file_splice_write_nolock(struct pipe_inode_info *pipe, struct file *out,
-				 loff_t *ppos, size_t len, unsigned int flags)
+generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
+			  loff_t *ppos, size_t len, unsigned int flags)
 {
 	struct address_space *mapping = out->f_mapping;
 	struct inode *inode = mapping->host;
@@ -781,76 +830,28 @@
 		.u.file = out,
 	};
 	ssize_t ret;
-	int err;
 
-	err = file_remove_suid(out);
-	if (unlikely(err))
-		return err;
+	pipe_lock(pipe);
 
-	ret = __splice_from_pipe(pipe, &sd, pipe_to_file);
-	if (ret > 0) {
-		unsigned long nr_pages;
-
-		*ppos += ret;
-		nr_pages = (ret + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-
-		/*
-		 * If file or inode is SYNC and we actually wrote some data,
-		 * sync it.
-		 */
-		if (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {
-			err = generic_osync_inode(inode, mapping,
-						  OSYNC_METADATA|OSYNC_DATA);
-
-			if (err)
-				ret = err;
-		}
-		balance_dirty_pages_ratelimited_nr(mapping, nr_pages);
-	}
+	splice_from_pipe_begin(&sd);
+	do {
+		ret = splice_from_pipe_next(pipe, &sd);
+		if (ret <= 0)
+			break;
 
-	return ret;
-}
+		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
+		ret = file_remove_suid(out);
+		if (!ret)
+			ret = splice_from_pipe_feed(pipe, &sd, pipe_to_file);
+		mutex_unlock(&inode->i_mutex);
+	} while (ret > 0);
+	splice_from_pipe_end(pipe, &sd);
 
-EXPORT_SYMBOL(generic_file_splice_write_nolock);
+	pipe_unlock(pipe);
 
-/**
- * generic_file_splice_write - splice data from a pipe to a file
- * @pipe:	pipe info
- * @out:	file to write to
- * @ppos:	position in @out
- * @len:	number of bytes to splice
- * @flags:	splice modifier flags
- *
- * Description:
- *    Will either move or copy pages (determined by @flags options) from
- *    the given pipe inode to the given file.
- *
- */
-ssize_t
-generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
-			  loff_t *ppos, size_t len, unsigned int flags)
-{
-	struct address_space *mapping = out->f_mapping;
-	struct inode *inode = mapping->host;
-	struct splice_desc sd = {
-		.total_len = len,
-		.flags = flags,
-		.pos = *ppos,
-		.u.file = out,
-	};
-	ssize_t ret;
+	if (sd.num_spliced)
+		ret = sd.num_spliced;
 
-	WARN_ON(S_ISFIFO(inode->i_mode));
-	mutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);
-	ret = file_remove_suid(out);
-	if (likely(!ret)) {
-		if (pipe->inode)
-			mutex_lock_nested(&pipe->inode->i_mutex, I_MUTEX_CHILD);
-		ret = __splice_from_pipe(pipe, &sd, pipe_to_file);
-		if (pipe->inode)
-			mutex_unlock(&pipe->inode->i_mutex);
-	}
-	mutex_unlock(&inode->i_mutex);
 	if (ret > 0) {
 		unsigned long nr_pages;
 
@@ -1339,8 +1340,7 @@
 	if (!pipe)
 		return -EBADF;
 
-	if (pipe->inode)
-		mutex_lock(&pipe->inode->i_mutex);
+	pipe_lock(pipe);
 
 	error = ret = 0;
 	while (nr_segs) {
@@ -1395,8 +1395,7 @@
 		iov++;
 	}
 
-	if (pipe->inode)
-		mutex_unlock(&pipe->inode->i_mutex);
+	pipe_unlock(pipe);
 
 	if (!ret)
 		ret = error;
@@ -1524,7 +1523,7 @@
 		return 0;
 
 	ret = 0;
-	mutex_lock(&pipe->inode->i_mutex);
+	pipe_lock(pipe);
 
 	while (!pipe->nrbufs) {
 		if (signal_pending(current)) {
@@ -1542,7 +1541,7 @@
 		pipe_wait(pipe);
 	}
 
-	mutex_unlock(&pipe->inode->i_mutex);
+	pipe_unlock(pipe);
 	return ret;
 }
 
@@ -1562,7 +1561,7 @@
 		return 0;
 
 	ret = 0;
-	mutex_lock(&pipe->inode->i_mutex);
+	pipe_lock(pipe);
 
 	while (pipe->nrbufs >= PIPE_BUFFERS) {
 		if (!pipe->readers) {
@@ -1583,7 +1582,7 @@
 		pipe->waiting_writers--;
 	}
 
-	mutex_unlock(&pipe->inode->i_mutex);
+	pipe_unlock(pipe);
 	return ret;
 }
 
@@ -1599,10 +1598,10 @@
 
 	/*
 	 * Potential ABBA deadlock, work around it by ordering lock
-	 * grabbing by inode address. Otherwise two different processes
+	 * grabbing by pipe info address. Otherwise two different processes
 	 * could deadlock (one doing tee from A -> B, the other from B -> A).
 	 */
-	inode_double_lock(ipipe->inode, opipe->inode);
+	pipe_double_lock(ipipe, opipe);
 
 	do {
 		if (!opipe->readers) {
@@ -1653,7 +1652,8 @@
 	if (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))
 		ret = -EAGAIN;
 
-	inode_double_unlock(ipipe->inode, opipe->inode);
+	pipe_unlock(ipipe);
+	pipe_unlock(opipe);
 
 	/*
 	 * If we put data in the output pipe, wakeup any potential readers.
diff -urN linux-2.6.30-rc2/fs/stat.c linux-2.6.30-rc3/fs/stat.c
--- linux-2.6.30-rc2/fs/stat.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/stat.c	2009-04-22 03:29:18.144931453 +0000
@@ -55,59 +55,54 @@
 
 EXPORT_SYMBOL(vfs_getattr);
 
-int vfs_stat_fd(int dfd, char __user *name, struct kstat *stat)
+int vfs_fstat(unsigned int fd, struct kstat *stat)
 {
-	struct path path;
-	int error;
+	struct file *f = fget(fd);
+	int error = -EBADF;
 
-	error = user_path_at(dfd, name, LOOKUP_FOLLOW, &path);
-	if (!error) {
-		error = vfs_getattr(path.mnt, path.dentry, stat);
-		path_put(&path);
+	if (f) {
+		error = vfs_getattr(f->f_path.mnt, f->f_path.dentry, stat);
+		fput(f);
 	}
 	return error;
 }
+EXPORT_SYMBOL(vfs_fstat);
 
-int vfs_stat(char __user *name, struct kstat *stat)
+int vfs_fstatat(int dfd, char __user *filename, struct kstat *stat, int flag)
 {
-	return vfs_stat_fd(AT_FDCWD, name, stat);
-}
+	struct path path;
+	int error = -EINVAL;
+	int lookup_flags = 0;
 
-EXPORT_SYMBOL(vfs_stat);
+	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
+		goto out;
 
-int vfs_lstat_fd(int dfd, char __user *name, struct kstat *stat)
-{
-	struct path path;
-	int error;
+	if (!(flag & AT_SYMLINK_NOFOLLOW))
+		lookup_flags |= LOOKUP_FOLLOW;
 
-	error = user_path_at(dfd, name, 0, &path);
-	if (!error) {
-		error = vfs_getattr(path.mnt, path.dentry, stat);
-		path_put(&path);
-	}
+	error = user_path_at(dfd, filename, lookup_flags, &path);
+	if (error)
+		goto out;
+
+	error = vfs_getattr(path.mnt, path.dentry, stat);
+	path_put(&path);
+out:
 	return error;
 }
+EXPORT_SYMBOL(vfs_fstatat);
 
-int vfs_lstat(char __user *name, struct kstat *stat)
+int vfs_stat(char __user *name, struct kstat *stat)
 {
-	return vfs_lstat_fd(AT_FDCWD, name, stat);
+	return vfs_fstatat(AT_FDCWD, name, stat, 0);
 }
+EXPORT_SYMBOL(vfs_stat);
 
-EXPORT_SYMBOL(vfs_lstat);
-
-int vfs_fstat(unsigned int fd, struct kstat *stat)
+int vfs_lstat(char __user *name, struct kstat *stat)
 {
-	struct file *f = fget(fd);
-	int error = -EBADF;
-
-	if (f) {
-		error = vfs_getattr(f->f_path.mnt, f->f_path.dentry, stat);
-		fput(f);
-	}
-	return error;
+	return vfs_fstatat(AT_FDCWD, name, stat, AT_SYMLINK_NOFOLLOW);
 }
+EXPORT_SYMBOL(vfs_lstat);
 
-EXPORT_SYMBOL(vfs_fstat);
 
 #ifdef __ARCH_WANT_OLD_STAT
 
@@ -155,23 +150,25 @@
 SYSCALL_DEFINE2(stat, char __user *, filename, struct __old_kernel_stat __user *, statbuf)
 {
 	struct kstat stat;
-	int error = vfs_stat_fd(AT_FDCWD, filename, &stat);
+	int error;
 
-	if (!error)
-		error = cp_old_stat(&stat, statbuf);
+	error = vfs_stat(filename, &stat);
+	if (error)
+		return error;
 
-	return error;
+	return cp_old_stat(&stat, statbuf);
 }
 
 SYSCALL_DEFINE2(lstat, char __user *, filename, struct __old_kernel_stat __user *, statbuf)
 {
 	struct kstat stat;
-	int error = vfs_lstat_fd(AT_FDCWD, filename, &stat);
+	int error;
 
-	if (!error)
-		error = cp_old_stat(&stat, statbuf);
+	error = vfs_lstat(filename, &stat);
+	if (error)
+		return error;
 
-	return error;
+	return cp_old_stat(&stat, statbuf);
 }
 
 SYSCALL_DEFINE2(fstat, unsigned int, fd, struct __old_kernel_stat __user *, statbuf)
@@ -240,23 +237,23 @@
 SYSCALL_DEFINE2(newstat, char __user *, filename, struct stat __user *, statbuf)
 {
 	struct kstat stat;
-	int error = vfs_stat_fd(AT_FDCWD, filename, &stat);
-
-	if (!error)
-		error = cp_new_stat(&stat, statbuf);
+	int error = vfs_stat(filename, &stat);
 
-	return error;
+	if (error)
+		return error;
+	return cp_new_stat(&stat, statbuf);
 }
 
 SYSCALL_DEFINE2(newlstat, char __user *, filename, struct stat __user *, statbuf)
 {
 	struct kstat stat;
-	int error = vfs_lstat_fd(AT_FDCWD, filename, &stat);
+	int error;
 
-	if (!error)
-		error = cp_new_stat(&stat, statbuf);
+	error = vfs_lstat(filename, &stat);
+	if (error)
+		return error;
 
-	return error;
+	return cp_new_stat(&stat, statbuf);
 }
 
 #if !defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_SYS_NEWFSTATAT)
@@ -264,21 +261,12 @@
 		struct stat __user *, statbuf, int, flag)
 {
 	struct kstat stat;
-	int error = -EINVAL;
-
-	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
-		goto out;
-
-	if (flag & AT_SYMLINK_NOFOLLOW)
-		error = vfs_lstat_fd(dfd, filename, &stat);
-	else
-		error = vfs_stat_fd(dfd, filename, &stat);
-
-	if (!error)
-		error = cp_new_stat(&stat, statbuf);
+	int error;
 
-out:
-	return error;
+	error = vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_new_stat(&stat, statbuf);
 }
 #endif
 
@@ -404,21 +392,12 @@
 		struct stat64 __user *, statbuf, int, flag)
 {
 	struct kstat stat;
-	int error = -EINVAL;
-
-	if ((flag & ~AT_SYMLINK_NOFOLLOW) != 0)
-		goto out;
-
-	if (flag & AT_SYMLINK_NOFOLLOW)
-		error = vfs_lstat_fd(dfd, filename, &stat);
-	else
-		error = vfs_stat_fd(dfd, filename, &stat);
-
-	if (!error)
-		error = cp_new_stat64(&stat, statbuf);
+	int error;
 
-out:
-	return error;
+	error = vfs_fstatat(dfd, filename, &stat, flag);
+	if (error)
+		return error;
+	return cp_new_stat64(&stat, statbuf);
 }
 #endif /* __ARCH_WANT_STAT64 */
 
diff -urN linux-2.6.30-rc2/fs/sysfs/bin.c linux-2.6.30-rc3/fs/sysfs/bin.c
--- linux-2.6.30-rc2/fs/sysfs/bin.c	2009-04-22 03:29:12.090931369 +0000
+++ linux-2.6.30-rc3/fs/sysfs/bin.c	2009-04-22 03:29:18.145931437 +0000
@@ -157,14 +157,9 @@
 			count = size - offs;
 	}
 
-	temp = kmalloc(count, GFP_KERNEL);
-	if (!temp)
-		return -ENOMEM;
-
-	if (copy_from_user(temp, userbuf, count)) {
-		count = -EFAULT;
-		goto out_free;
-	}
+	temp = memdup_user(userbuf, count);
+	if (IS_ERR(temp))
+		return PTR_ERR(temp);
 
 	mutex_lock(&bb->mutex);
 
@@ -176,8 +171,6 @@
 	if (count > 0)
 		*off = offs + count;
 
-out_free:
-	kfree(temp);
 	return count;
 }
 
diff -urN linux-2.6.30-rc2/fs/sysfs/file.c linux-2.6.30-rc3/fs/sysfs/file.c
--- linux-2.6.30-rc2/fs/sysfs/file.c	2009-04-22 03:29:12.091931374 +0000
+++ linux-2.6.30-rc3/fs/sysfs/file.c	2009-04-22 03:29:18.145931437 +0000
@@ -446,11 +446,11 @@
 	if (buffer->event != atomic_read(&od->event))
 		goto trigger;
 
-	return 0;
+	return DEFAULT_POLLMASK;
 
  trigger:
 	buffer->needs_read_fill = 1;
-	return POLLERR|POLLPRI;
+	return DEFAULT_POLLMASK|POLLERR|POLLPRI;
 }
 
 void sysfs_notify_dirent(struct sysfs_dirent *sd)
@@ -667,6 +667,7 @@
 	struct work_struct	work;
 };
 
+static struct workqueue_struct *sysfs_workqueue;
 static DEFINE_MUTEX(sysfs_workq_mutex);
 static LIST_HEAD(sysfs_workq);
 static void sysfs_schedule_callback_work(struct work_struct *work)
@@ -715,11 +716,20 @@
 	mutex_lock(&sysfs_workq_mutex);
 	list_for_each_entry_safe(ss, tmp, &sysfs_workq, workq_list)
 		if (ss->kobj == kobj) {
+			module_put(owner);
 			mutex_unlock(&sysfs_workq_mutex);
 			return -EAGAIN;
 		}
 	mutex_unlock(&sysfs_workq_mutex);
 
+	if (sysfs_workqueue == NULL) {
+		sysfs_workqueue = create_workqueue("sysfsd");
+		if (sysfs_workqueue == NULL) {
+			module_put(owner);
+			return -ENOMEM;
+		}
+	}
+
 	ss = kmalloc(sizeof(*ss), GFP_KERNEL);
 	if (!ss) {
 		module_put(owner);
@@ -735,7 +745,7 @@
 	mutex_lock(&sysfs_workq_mutex);
 	list_add_tail(&ss->workq_list, &sysfs_workq);
 	mutex_unlock(&sysfs_workq_mutex);
-	schedule_work(&ss->work);
+	queue_work(sysfs_workqueue, &ss->work);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(sysfs_schedule_callback);
diff -urN linux-2.6.30-rc2/fs/xattr.c linux-2.6.30-rc3/fs/xattr.c
--- linux-2.6.30-rc2/fs/xattr.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/xattr.c	2009-04-22 03:29:18.159931456 +0000
@@ -237,13 +237,9 @@
 	if (size) {
 		if (size > XATTR_SIZE_MAX)
 			return -E2BIG;
-		kvalue = kmalloc(size, GFP_KERNEL);
-		if (!kvalue)
-			return -ENOMEM;
-		if (copy_from_user(kvalue, value, size)) {
-			kfree(kvalue);
-			return -EFAULT;
-		}
+		kvalue = memdup_user(value, size);
+		if (IS_ERR(kvalue))
+			return PTR_ERR(kvalue);
 	}
 
 	error = vfs_setxattr(d, kname, kvalue, size, flags);
diff -urN linux-2.6.30-rc2/fs/xfs/linux-2.6/xfs_ioctl.c linux-2.6.30-rc3/fs/xfs/linux-2.6/xfs_ioctl.c
--- linux-2.6.30-rc2/fs/xfs/linux-2.6/xfs_ioctl.c	2009-04-22 03:29:12.107556282 +0000
+++ linux-2.6.30-rc3/fs/xfs/linux-2.6/xfs_ioctl.c	2009-04-22 03:29:18.160931420 +0000
@@ -489,17 +489,12 @@
 	if (len > XATTR_SIZE_MAX)
 		return EINVAL;
 
-	kbuf = kmalloc(len, GFP_KERNEL);
-	if (!kbuf)
-		return ENOMEM;
-
-	if (copy_from_user(kbuf, ubuf, len))
-		goto out_kfree;
+	kbuf = memdup_user(ubuf, len);
+	if (IS_ERR(kbuf))
+		return PTR_ERR(kbuf);
 
 	error = xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);
 
- out_kfree:
-	kfree(kbuf);
 	return error;
 }
 
@@ -540,20 +535,16 @@
 	if (!size || size > 16 * PAGE_SIZE)
 		goto out_dput;
 
-	error = ENOMEM;
-	ops = kmalloc(size, GFP_KERNEL);
-	if (!ops)
+	ops = memdup_user(am_hreq.ops, size);
+	if (IS_ERR(ops)) {
+		error = PTR_ERR(ops);
 		goto out_dput;
-
-	error = EFAULT;
-	if (copy_from_user(ops, am_hreq.ops, size))
-		goto out_kfree_ops;
+	}
 
 	attr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);
 	if (!attr_name)
 		goto out_kfree_ops;
 
-
 	error = 0;
 	for (i = 0; i < am_hreq.opcount; i++) {
 		ops[i].am_error = strncpy_from_user(attr_name,
diff -urN linux-2.6.30-rc2/fs/xfs/linux-2.6/xfs_ioctl32.c linux-2.6.30-rc3/fs/xfs/linux-2.6/xfs_ioctl32.c
--- linux-2.6.30-rc2/fs/xfs/linux-2.6/xfs_ioctl32.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/fs/xfs/linux-2.6/xfs_ioctl32.c	2009-04-22 03:29:18.161931611 +0000
@@ -427,20 +427,16 @@
 	if (!size || size > 16 * PAGE_SIZE)
 		goto out_dput;
 
-	error = ENOMEM;
-	ops = kmalloc(size, GFP_KERNEL);
-	if (!ops)
+	ops = memdup_user(compat_ptr(am_hreq.ops), size);
+	if (IS_ERR(ops)) {
+		error = PTR_ERR(ops);
 		goto out_dput;
-
-	error = EFAULT;
-	if (copy_from_user(ops, compat_ptr(am_hreq.ops), size))
-		goto out_kfree_ops;
+	}
 
 	attr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);
 	if (!attr_name)
 		goto out_kfree_ops;
 
-
 	error = 0;
 	for (i = 0; i < am_hreq.opcount; i++) {
 		ops[i].am_error = strncpy_from_user(attr_name,
diff -urN linux-2.6.30-rc2/include/asm-arm/.gitignore linux-2.6.30-rc3/include/asm-arm/.gitignore
--- linux-2.6.30-rc2/include/asm-arm/.gitignore	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-arm/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,2 +0,0 @@
-arch
-mach-types.h
diff -urN linux-2.6.30-rc2/include/asm-generic/bug.h linux-2.6.30-rc3/include/asm-generic/bug.h
--- linux-2.6.30-rc2/include/asm-generic/bug.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-generic/bug.h	2009-04-22 03:29:18.194931464 +0000
@@ -88,7 +88,7 @@
 
 #else /* !CONFIG_BUG */
 #ifndef HAVE_ARCH_BUG
-#define BUG()
+#define BUG() do {} while(0)
 #endif
 
 #ifndef HAVE_ARCH_BUG_ON
diff -urN linux-2.6.30-rc2/include/asm-generic/percpu.h linux-2.6.30-rc3/include/asm-generic/percpu.h
--- linux-2.6.30-rc2/include/asm-generic/percpu.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-generic/percpu.h	2009-04-22 03:29:18.195931431 +0000
@@ -1,13 +1,9 @@
 #ifndef _ASM_GENERIC_PERCPU_H_
 #define _ASM_GENERIC_PERCPU_H_
+
 #include <linux/compiler.h>
 #include <linux/threads.h>
-
-/*
- * Determine the real variable name from the name visible in the
- * kernel sources.
- */
-#define per_cpu_var(var) per_cpu__##var
+#include <linux/percpu-defs.h>
 
 #ifdef CONFIG_SMP
 
@@ -73,11 +69,32 @@
 
 #endif	/* SMP */
 
+#ifndef PER_CPU_BASE_SECTION
+#ifdef CONFIG_SMP
+#define PER_CPU_BASE_SECTION ".data.percpu"
+#else
+#define PER_CPU_BASE_SECTION ".data"
+#endif
+#endif
+
+#ifdef CONFIG_SMP
+
+#ifdef MODULE
+#define PER_CPU_SHARED_ALIGNED_SECTION ""
+#else
+#define PER_CPU_SHARED_ALIGNED_SECTION ".shared_aligned"
+#endif
+#define PER_CPU_FIRST_SECTION ".first"
+
+#else
+
+#define PER_CPU_SHARED_ALIGNED_SECTION ""
+#define PER_CPU_FIRST_SECTION ""
+
+#endif
+
 #ifndef PER_CPU_ATTRIBUTES
 #define PER_CPU_ATTRIBUTES
 #endif
 
-#define DECLARE_PER_CPU(type, name) extern PER_CPU_ATTRIBUTES \
-					__typeof__(type) per_cpu_var(name)
-
 #endif /* _ASM_GENERIC_PERCPU_H_ */
diff -urN linux-2.6.30-rc2/include/asm-h8300/timer.h linux-2.6.30-rc3/include/asm-h8300/timer.h
--- linux-2.6.30-rc2/include/asm-h8300/timer.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-h8300/timer.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,25 +0,0 @@
-#ifndef __H8300_TIMER_H
-#define __H8300_TIMER_H
-
-void h8300_timer_tick(void);
-void h8300_timer_setup(void);
-void h8300_gettod(unsigned int *year, unsigned int *mon, unsigned int *day,
-		   unsigned int *hour, unsigned int *min, unsigned int *sec);
-
-#define TIMER_FREQ (CONFIG_CPU_CLOCK*10000) /* Timer input freq. */
-
-#define calc_param(cnt, div, rate, limit)			\
-do {								\
-	cnt = TIMER_FREQ / HZ;					\
-	for (div = 0; div < ARRAY_SIZE(divide_rate); div++) {	\
-		if (rate[div] == 0)				\
-			continue;				\
-		if ((cnt / rate[div]) > limit)			\
-			break;					\
-	}							\
-	if (div == ARRAY_SIZE(divide_rate))			\
-		panic("Timer counter overflow");		\
-	cnt /= divide_rate[div];				\
-} while(0)
-
-#endif
diff -urN linux-2.6.30-rc2/include/asm-m32r/Kbuild linux-2.6.30-rc3/include/asm-m32r/Kbuild
--- linux-2.6.30-rc2/include/asm-m32r/Kbuild	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/Kbuild	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-include include/asm-generic/Kbuild.asm
diff -urN linux-2.6.30-rc2/include/asm-m32r/addrspace.h linux-2.6.30-rc3/include/asm-m32r/addrspace.h
--- linux-2.6.30-rc2/include/asm-m32r/addrspace.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/addrspace.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,57 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2001 by Hiroyuki Kondo
- *
- * Defitions for the address spaces of the M32R CPUs.
- */
-#ifndef __ASM_M32R_ADDRSPACE_H
-#define __ASM_M32R_ADDRSPACE_H
-
-/*
- * Memory segments (32bit kernel mode addresses)
- */
-#define KUSEG                   0x00000000
-#define KSEG0                   0x80000000
-#define KSEG1                   0xa0000000
-#define KSEG2                   0xc0000000
-#define KSEG3                   0xe0000000
-
-#define K0BASE  KSEG0
-
-/*
- * Returns the kernel segment base of a given address
- */
-#ifndef __ASSEMBLY__
-#define KSEGX(a)                (((unsigned long)(a)) & 0xe0000000)
-#else
-#define KSEGX(a)                ((a) & 0xe0000000)
-#endif
-
-/*
- * Returns the physical address of a KSEG0/KSEG1 address
- */
-#ifndef __ASSEMBLY__
-#define PHYSADDR(a)		(((unsigned long)(a)) & 0x1fffffff)
-#else
-#define PHYSADDR(a)		((a) & 0x1fffffff)
-#endif
-
-/*
- * Map an address to a certain kernel segment
- */
-#ifndef __ASSEMBLY__
-#define KSEG0ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG0))
-#define KSEG1ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG1))
-#define KSEG2ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG2))
-#define KSEG3ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG3))
-#else
-#define KSEG0ADDR(a)		(((a) & 0x1fffffff) | KSEG0)
-#define KSEG1ADDR(a)		(((a) & 0x1fffffff) | KSEG1)
-#define KSEG2ADDR(a)		(((a) & 0x1fffffff) | KSEG2)
-#define KSEG3ADDR(a)		(((a) & 0x1fffffff) | KSEG3)
-#endif
-
-#endif /* __ASM_M32R_ADDRSPACE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/assembler.h linux-2.6.30-rc3/include/asm-m32r/assembler.h
--- linux-2.6.30-rc2/include/asm-m32r/assembler.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/assembler.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,229 +0,0 @@
-#ifndef _ASM_M32R_ASSEMBLER_H
-#define _ASM_M32R_ASSEMBLER_H
-
-/*
- * linux/asm-m32r/assembler.h
- *
- * Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- *
- * This file contains M32R architecture specific macro definitions.
- */
-
-
-#ifndef __STR
-#ifdef __ASSEMBLY__
-#define __STR(x) x
-#else
-#define __STR(x) #x
-#endif
-#endif /* __STR */
-
-#ifdef CONFIG_SMP
-#define M32R_LOCK	__STR(lock)
-#define M32R_UNLOCK	__STR(unlock)
-#else
-#define M32R_LOCK	__STR(ld)
-#define M32R_UNLOCK	__STR(st)
-#endif
-
-#ifdef __ASSEMBLY__
-#undef ENTRY
-#define ENTRY(name) ENTRY_M name
-	.macro  ENTRY_M name
-	.global \name
-	ALIGN
-\name:
-	.endm
-#endif
-
-
-/**
- * LDIMM - load immediate value
- * STI - enable interruption
- * CLI - disable interruption
- */
-
-#ifdef __ASSEMBLY__
-
-#define LDIMM(reg,x) LDIMM reg x
-	.macro LDIMM reg x
-	seth	\reg, #high(\x)
-	or3	\reg, \reg, #low(\x)
-	.endm
-
-#if !(defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_M32104))
-#define ENABLE_INTERRUPTS(reg) ENABLE_INTERRUPTS reg
-	.macro ENABLE_INTERRUPTS reg
-	setpsw  #0x40	    ->	nop
-	; WORKAROUND: "-> nop" is a workaround for the M32700(TS1).
-	.endm
-
-#define DISABLE_INTERRUPTS(reg) DISABLE_INTERRUPTS reg
-	.macro DISABLE_INTERRUPTS reg
-	clrpsw  #0x40	    ->	nop
-	; WORKAROUND: "-> nop" is a workaround for the M32700(TS1).
-	.endm
-#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
-#define ENABLE_INTERRUPTS(reg) ENABLE_INTERRUPTS reg
-	.macro ENABLE_INTERRUPTS reg
-	mvfc	\reg, psw
-	or3	\reg, \reg, #0x0040
-	mvtc	\reg, psw
-	.endm
-
-#define DISABLE_INTERRUPTS(reg) DISABLE_INTERRUPTS reg
-	.macro DISABLE_INTERRUPTS reg
-	mvfc	\reg, psw
-	and3	\reg, \reg, #0xffbf
-	mvtc	\reg, psw
-	.endm
-#endif	/* CONFIG_CHIP_M32102 */
-
-	.macro	SAVE_ALL
-	push	r0		; orig_r0
-	push	sp		; spi (r15)
-	push	lr		; r14
-	push	r13
-	mvfc	r13, cr3	; spu
-	push	r13
-	mvfc	r13, bbpc
-	push	r13
-	mvfc	r13, bbpsw
-	push	r13
-	mvfc	r13, bpc
-	push	r13
-	mvfc	r13, psw
-	push	r13
-#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
-	mvfaclo	r13, a1
-	push	r13
-	mvfachi r13, a1
-	push	r13
-	mvfaclo	r13, a0
-	push	r13
-	mvfachi	r13, a0
-	push	r13
-#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
-	mvfaclo	r13
-	push	r13
-	mvfachi	r13
-	push	r13
-	ldi	r13, #0
-	push	r13		; dummy push acc1h
-	push	r13		; dummy push acc1l
-#else
-#error unknown isa configuration
-#endif
-	ldi	r13, #-1
-	push	r13		; syscall_nr (default: -1)
-	push	r12
-	push	r11
-	push	r10
-	push	r9
-	push	r8
-	push	r7
-	push	r3
-	push	r2
-	push	r1
-	push	r0
-	addi	sp, #-4		; room for implicit pt_regs parameter
-	push	r6
-	push	r5
-	push	r4
-	.endm
-
-	.macro	RESTORE_ALL
-	pop	r4
-	pop	r5
-	pop	r6
-	addi	sp, #4
-	pop	r0
-	pop	r1
-	pop	r2
-	pop	r3
-	pop	r7
-	pop	r8
-	pop	r9
-	pop	r10
-	pop	r11
-	pop	r12
-	addi	r15, #4		; Skip syscall number
-#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
-	pop	r13
-	mvtachi	r13, a0
-	pop	r13
-	mvtaclo	r13, a0
-	pop	r13
-	mvtachi	r13, a1
-	pop	r13
-	mvtaclo	r13, a1
-#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
-	pop	r13		; dummy pop acc1h
-	pop	r13		; dummy pop acc1l
-	pop	r13
-	mvtachi	r13
-	pop	r13
-	mvtaclo	r13
-#else
-#error unknown isa configuration
-#endif
-	pop	r14
-	mvtc	r14, psw
-	pop	r14
-	mvtc	r14, bpc
-	addi	sp, #8		; Skip bbpsw, bbpc
-	pop	r14
-	mvtc	r14, cr3	; spu
-	pop	r13
-	pop	lr		; r14
-	pop	sp		; spi (r15)
-	addi	sp, #4		; Skip orig_r0
-	.fillinsn
-1:	rte
-	.section .fixup,"ax"
-2:	bl	do_exit
-	.previous
-	.section __ex_table,"a"
-	ALIGN
-	.long	1b, 2b
-	.previous
-	.endm
-
-#define GET_CURRENT(reg)  get_current reg
-	.macro get_current reg
-	ldi  \reg, #-8192
-	and  \reg, sp
-	.endm
-
-#if !(defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_M32104))
-	.macro	SWITCH_TO_KERNEL_STACK
-	; switch to kernel stack (spi)
-	clrpsw	#0x80	    ->	nop
-	.endm
-#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
-	.macro	SWITCH_TO_KERNEL_STACK
-	push	r0		; save r0 for working
-	mvfc	r0, psw
-	and3	r0, r0, #0x00ff7f
-	mvtc	r0, psw
-	slli	r0, #16
-	bltz	r0, 1f		; check BSM-bit
-;
-	;; called from kernel context: previous stack = spi
-	pop	r0		; retrieve r0
-	bra	2f
-	.fillinsn
-1:
-	;; called from user context: previous stack = spu
-	mvfc	r0, cr3		; spu
-	addi	r0, #4
-	mvtc	r0, cr3		; spu
-	ld	r0, @(-4,r0)	; retrieve r0
-	.fillinsn
-2:
-	.endm
-#endif	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
-
-#endif	/* __ASSEMBLY__ */
-
-#endif	/* _ASM_M32R_ASSEMBLER_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/atomic.h linux-2.6.30-rc3/include/asm-m32r/atomic.h
--- linux-2.6.30-rc2/include/asm-m32r/atomic.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/atomic.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,318 +0,0 @@
-#ifndef _ASM_M32R_ATOMIC_H
-#define _ASM_M32R_ATOMIC_H
-
-/*
- *  linux/include/asm-m32r/atomic.h
- *
- *  M32R version:
- *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
- *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#include <linux/types.h>
-#include <asm/assembler.h>
-#include <asm/system.h>
-
-/*
- * Atomic operations that C can't guarantee us.  Useful for
- * resource counting etc..
- */
-
-#define ATOMIC_INIT(i)	{ (i) }
-
-/**
- * atomic_read - read atomic variable
- * @v: pointer of type atomic_t
- *
- * Atomically reads the value of @v.
- */
-#define atomic_read(v)	((v)->counter)
-
-/**
- * atomic_set - set atomic variable
- * @v: pointer of type atomic_t
- * @i: required value
- *
- * Atomically sets the value of @v to @i.
- */
-#define atomic_set(v,i)	(((v)->counter) = (i))
-
-/**
- * atomic_add_return - add integer to atomic variable and return it
- * @i: integer value to add
- * @v: pointer of type atomic_t
- *
- * Atomically adds @i to @v and return (@i + @v).
- */
-static __inline__ int atomic_add_return(int i, atomic_t *v)
-{
-	unsigned long flags;
-	int result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# atomic_add_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"add	%0, %2;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (result)
-		: "r" (&v->counter), "r" (i)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * atomic_sub_return - subtract integer from atomic variable and return it
- * @i: integer value to subtract
- * @v: pointer of type atomic_t
- *
- * Atomically subtracts @i from @v and return (@v - @i).
- */
-static __inline__ int atomic_sub_return(int i, atomic_t *v)
-{
-	unsigned long flags;
-	int result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# atomic_sub_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"sub	%0, %2;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (result)
-		: "r" (&v->counter), "r" (i)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * atomic_add - add integer to atomic variable
- * @i: integer value to add
- * @v: pointer of type atomic_t
- *
- * Atomically adds @i to @v.
- */
-#define atomic_add(i,v) ((void) atomic_add_return((i), (v)))
-
-/**
- * atomic_sub - subtract the atomic variable
- * @i: integer value to subtract
- * @v: pointer of type atomic_t
- *
- * Atomically subtracts @i from @v.
- */
-#define atomic_sub(i,v) ((void) atomic_sub_return((i), (v)))
-
-/**
- * atomic_sub_and_test - subtract value from variable and test result
- * @i: integer value to subtract
- * @v: pointer of type atomic_t
- *
- * Atomically subtracts @i from @v and returns
- * true if the result is zero, or false for all
- * other cases.
- */
-#define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
-
-/**
- * atomic_inc_return - increment atomic variable and return it
- * @v: pointer of type atomic_t
- *
- * Atomically increments @v by 1 and returns the result.
- */
-static __inline__ int atomic_inc_return(atomic_t *v)
-{
-	unsigned long flags;
-	int result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# atomic_inc_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"addi	%0, #1;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (result)
-		: "r" (&v->counter)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * atomic_dec_return - decrement atomic variable and return it
- * @v: pointer of type atomic_t
- *
- * Atomically decrements @v by 1 and returns the result.
- */
-static __inline__ int atomic_dec_return(atomic_t *v)
-{
-	unsigned long flags;
-	int result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# atomic_dec_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"addi	%0, #-1;		\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (result)
-		: "r" (&v->counter)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * atomic_inc - increment atomic variable
- * @v: pointer of type atomic_t
- *
- * Atomically increments @v by 1.
- */
-#define atomic_inc(v) ((void)atomic_inc_return(v))
-
-/**
- * atomic_dec - decrement atomic variable
- * @v: pointer of type atomic_t
- *
- * Atomically decrements @v by 1.
- */
-#define atomic_dec(v) ((void)atomic_dec_return(v))
-
-/**
- * atomic_inc_and_test - increment and test
- * @v: pointer of type atomic_t
- *
- * Atomically increments @v by 1
- * and returns true if the result is zero, or false for all
- * other cases.
- */
-#define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)
-
-/**
- * atomic_dec_and_test - decrement and test
- * @v: pointer of type atomic_t
- *
- * Atomically decrements @v by 1 and
- * returns true if the result is 0, or false for all
- * other cases.
- */
-#define atomic_dec_and_test(v) (atomic_dec_return(v) == 0)
-
-/**
- * atomic_add_negative - add and test if negative
- * @v: pointer of type atomic_t
- * @i: integer value to add
- *
- * Atomically adds @i to @v and returns true
- * if the result is negative, or false when
- * result is greater than or equal to zero.
- */
-#define atomic_add_negative(i,v) (atomic_add_return((i), (v)) < 0)
-
-#define atomic_cmpxchg(v, o, n) ((int)cmpxchg(&((v)->counter), (o), (n)))
-#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
-
-/**
- * atomic_add_unless - add unless the number is a given value
- * @v: pointer of type atomic_t
- * @a: the amount to add to v...
- * @u: ...unless v is equal to u.
- *
- * Atomically adds @a to @v, so long as it was not @u.
- * Returns non-zero if @v was not @u, and zero otherwise.
- */
-static __inline__ int atomic_add_unless(atomic_t *v, int a, int u)
-{
-	int c, old;
-	c = atomic_read(v);
-	for (;;) {
-		if (unlikely(c == (u)))
-			break;
-		old = atomic_cmpxchg((v), c, c + (a));
-		if (likely(old == c))
-			break;
-		c = old;
-	}
-	return c != (u);
-}
-
-#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
-
-static __inline__ void atomic_clear_mask(unsigned long  mask, atomic_t *addr)
-{
-	unsigned long flags;
-	unsigned long tmp;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# atomic_clear_mask		\n\t"
-		DCACHE_CLEAR("%0", "r5", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"and	%0, %2;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (tmp)
-		: "r" (addr), "r" (~mask)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r5"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-}
-
-static __inline__ void atomic_set_mask(unsigned long  mask, atomic_t *addr)
-{
-	unsigned long flags;
-	unsigned long tmp;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# atomic_set_mask		\n\t"
-		DCACHE_CLEAR("%0", "r5", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"or	%0, %2;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (tmp)
-		: "r" (addr), "r" (mask)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r5"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-}
-
-/* Atomic operations are already serializing on m32r */
-#define smp_mb__before_atomic_dec()	barrier()
-#define smp_mb__after_atomic_dec()	barrier()
-#define smp_mb__before_atomic_inc()	barrier()
-#define smp_mb__after_atomic_inc()	barrier()
-
-#include <asm-generic/atomic.h>
-#endif	/* _ASM_M32R_ATOMIC_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/auxvec.h linux-2.6.30-rc3/include/asm-m32r/auxvec.h
--- linux-2.6.30-rc2/include/asm-m32r/auxvec.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/auxvec.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-#ifndef _ASM_M32R__AUXVEC_H
-#define _ASM_M32R__AUXVEC_H
-
-#endif  /* _ASM_M32R__AUXVEC_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/bitops.h linux-2.6.30-rc3/include/asm-m32r/bitops.h
--- linux-2.6.30-rc2/include/asm-m32r/bitops.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/bitops.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,275 +0,0 @@
-#ifndef _ASM_M32R_BITOPS_H
-#define _ASM_M32R_BITOPS_H
-
-/*
- *  linux/include/asm-m32r/bitops.h
- *
- *  Copyright 1992, Linus Torvalds.
- *
- *  M32R version:
- *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
- *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#ifndef _LINUX_BITOPS_H
-#error only <linux/bitops.h> can be included directly
-#endif
-
-#include <linux/compiler.h>
-#include <asm/assembler.h>
-#include <asm/system.h>
-#include <asm/byteorder.h>
-#include <asm/types.h>
-
-/*
- * These have to be done with inline assembly: that way the bit-setting
- * is guaranteed to be atomic. All bit operations return 0 if the bit
- * was cleared before the operation and != 0 if it was not.
- *
- * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
- */
-
-/**
- * set_bit - Atomically set a bit in memory
- * @nr: the bit to set
- * @addr: the address to start counting from
- *
- * This function is atomic and may not be reordered.  See __set_bit()
- * if you do not require the atomic guarantees.
- * Note that @nr may be almost arbitrarily large; this function is not
- * restricted to acting on a single-word quantity.
- */
-static __inline__ void set_bit(int nr, volatile void * addr)
-{
-	__u32 mask;
-	volatile __u32 *a = addr;
-	unsigned long flags;
-	unsigned long tmp;
-
-	a += (nr >> 5);
-	mask = (1 << (nr & 0x1F));
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		DCACHE_CLEAR("%0", "r6", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"or	%0, %2;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (tmp)
-		: "r" (a), "r" (mask)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r6"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-}
-
-/**
- * clear_bit - Clears a bit in memory
- * @nr: Bit to clear
- * @addr: Address to start counting from
- *
- * clear_bit() is atomic and may not be reordered.  However, it does
- * not contain a memory barrier, so if it is used for locking purposes,
- * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
- * in order to ensure changes are visible on other processors.
- */
-static __inline__ void clear_bit(int nr, volatile void * addr)
-{
-	__u32 mask;
-	volatile __u32 *a = addr;
-	unsigned long flags;
-	unsigned long tmp;
-
-	a += (nr >> 5);
-	mask = (1 << (nr & 0x1F));
-
-	local_irq_save(flags);
-
-	__asm__ __volatile__ (
-		DCACHE_CLEAR("%0", "r6", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"and	%0, %2;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (tmp)
-		: "r" (a), "r" (~mask)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r6"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-}
-
-#define smp_mb__before_clear_bit()	barrier()
-#define smp_mb__after_clear_bit()	barrier()
-
-/**
- * change_bit - Toggle a bit in memory
- * @nr: Bit to clear
- * @addr: Address to start counting from
- *
- * change_bit() is atomic and may not be reordered.
- * Note that @nr may be almost arbitrarily large; this function is not
- * restricted to acting on a single-word quantity.
- */
-static __inline__ void change_bit(int nr, volatile void * addr)
-{
-	__u32  mask;
-	volatile __u32  *a = addr;
-	unsigned long flags;
-	unsigned long tmp;
-
-	a += (nr >> 5);
-	mask = (1 << (nr & 0x1F));
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		DCACHE_CLEAR("%0", "r6", "%1")
-		M32R_LOCK" %0, @%1;		\n\t"
-		"xor	%0, %2;			\n\t"
-		M32R_UNLOCK" %0, @%1;		\n\t"
-		: "=&r" (tmp)
-		: "r" (a), "r" (mask)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r6"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-}
-
-/**
- * test_and_set_bit - Set a bit and return its old value
- * @nr: Bit to set
- * @addr: Address to count from
- *
- * This operation is atomic and cannot be reordered.
- * It also implies a memory barrier.
- */
-static __inline__ int test_and_set_bit(int nr, volatile void * addr)
-{
-	__u32 mask, oldbit;
-	volatile __u32 *a = addr;
-	unsigned long flags;
-	unsigned long tmp;
-
-	a += (nr >> 5);
-	mask = (1 << (nr & 0x1F));
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		DCACHE_CLEAR("%0", "%1", "%2")
-		M32R_LOCK" %0, @%2;		\n\t"
-		"mv	%1, %0;			\n\t"
-		"and	%0, %3;			\n\t"
-		"or	%1, %3;			\n\t"
-		M32R_UNLOCK" %1, @%2;		\n\t"
-		: "=&r" (oldbit), "=&r" (tmp)
-		: "r" (a), "r" (mask)
-		: "memory"
-	);
-	local_irq_restore(flags);
-
-	return (oldbit != 0);
-}
-
-/**
- * test_and_clear_bit - Clear a bit and return its old value
- * @nr: Bit to set
- * @addr: Address to count from
- *
- * This operation is atomic and cannot be reordered.
- * It also implies a memory barrier.
- */
-static __inline__ int test_and_clear_bit(int nr, volatile void * addr)
-{
-	__u32 mask, oldbit;
-	volatile __u32 *a = addr;
-	unsigned long flags;
-	unsigned long tmp;
-
-	a += (nr >> 5);
-	mask = (1 << (nr & 0x1F));
-
-	local_irq_save(flags);
-
-	__asm__ __volatile__ (
-		DCACHE_CLEAR("%0", "%1", "%3")
-		M32R_LOCK" %0, @%3;		\n\t"
-		"mv	%1, %0;			\n\t"
-		"and	%0, %2;			\n\t"
-		"not	%2, %2;			\n\t"
-		"and	%1, %2;			\n\t"
-		M32R_UNLOCK" %1, @%3;		\n\t"
-		: "=&r" (oldbit), "=&r" (tmp), "+r" (mask)
-		: "r" (a)
-		: "memory"
-	);
-	local_irq_restore(flags);
-
-	return (oldbit != 0);
-}
-
-/**
- * test_and_change_bit - Change a bit and return its old value
- * @nr: Bit to set
- * @addr: Address to count from
- *
- * This operation is atomic and cannot be reordered.
- * It also implies a memory barrier.
- */
-static __inline__ int test_and_change_bit(int nr, volatile void * addr)
-{
-	__u32 mask, oldbit;
-	volatile __u32 *a = addr;
-	unsigned long flags;
-	unsigned long tmp;
-
-	a += (nr >> 5);
-	mask = (1 << (nr & 0x1F));
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		DCACHE_CLEAR("%0", "%1", "%2")
-		M32R_LOCK" %0, @%2;		\n\t"
-		"mv	%1, %0;			\n\t"
-		"and	%0, %3;			\n\t"
-		"xor	%1, %3;			\n\t"
-		M32R_UNLOCK" %1, @%2;		\n\t"
-		: "=&r" (oldbit), "=&r" (tmp)
-		: "r" (a), "r" (mask)
-		: "memory"
-	);
-	local_irq_restore(flags);
-
-	return (oldbit != 0);
-}
-
-#include <asm-generic/bitops/non-atomic.h>
-#include <asm-generic/bitops/ffz.h>
-#include <asm-generic/bitops/__ffs.h>
-#include <asm-generic/bitops/fls.h>
-#include <asm-generic/bitops/__fls.h>
-#include <asm-generic/bitops/fls64.h>
-
-#ifdef __KERNEL__
-
-#include <asm-generic/bitops/sched.h>
-#include <asm-generic/bitops/find.h>
-#include <asm-generic/bitops/ffs.h>
-#include <asm-generic/bitops/hweight.h>
-#include <asm-generic/bitops/lock.h>
-
-#endif /* __KERNEL__ */
-
-#ifdef __KERNEL__
-
-#include <asm-generic/bitops/ext2-non-atomic.h>
-#include <asm-generic/bitops/ext2-atomic.h>
-#include <asm-generic/bitops/minix.h>
-
-#endif /* __KERNEL__ */
-
-#endif /* _ASM_M32R_BITOPS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/bug.h linux-2.6.30-rc3/include/asm-m32r/bug.h
--- linux-2.6.30-rc2/include/asm-m32r/bug.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/bug.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-#ifndef _M32R_BUG_H
-#define _M32R_BUG_H
-#include <asm-generic/bug.h>
-#endif
diff -urN linux-2.6.30-rc2/include/asm-m32r/bugs.h linux-2.6.30-rc3/include/asm-m32r/bugs.h
--- linux-2.6.30-rc2/include/asm-m32r/bugs.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/bugs.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-#ifndef _ASM_M32R_BUGS_H
-#define _ASM_M32R_BUGS_H
-
-/*
- * This is included by init/main.c to check for architecture-dependent bugs.
- *
- * Needs:
- *     void check_bugs(void);
- */
-#include <asm/processor.h>
-
-static void __init check_bugs(void)
-{
-	extern unsigned long loops_per_jiffy;
-
-	current_cpu_data.loops_per_jiffy = loops_per_jiffy;
-}
-
-#endif  /* _ASM_M32R_BUGS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/byteorder.h linux-2.6.30-rc3/include/asm-m32r/byteorder.h
--- linux-2.6.30-rc2/include/asm-m32r/byteorder.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/byteorder.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,10 +0,0 @@
-#ifndef _ASM_M32R_BYTEORDER_H
-#define _ASM_M32R_BYTEORDER_H
-
-#if defined(__LITTLE_ENDIAN__)
-#  include <linux/byteorder/little_endian.h>
-#else
-#  include <linux/byteorder/big_endian.h>
-#endif
-
-#endif /* _ASM_M32R_BYTEORDER_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/cache.h linux-2.6.30-rc3/include/asm-m32r/cache.h
--- linux-2.6.30-rc2/include/asm-m32r/cache.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/cache.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-#ifndef _ASM_M32R_CACHE_H
-#define _ASM_M32R_CACHE_H
-
-/* L1 cache line size */
-#define L1_CACHE_SHIFT		4
-#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
-
-#endif  /* _ASM_M32R_CACHE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/cachectl.h linux-2.6.30-rc3/include/asm-m32r/cachectl.h
--- linux-2.6.30-rc2/include/asm-m32r/cachectl.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/cachectl.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,26 +0,0 @@
-/*
- * cachectl.h -- defines for M32R cache control system calls
- *
- * Copyright (C) 2003 by Kazuhiro Inaoka
- */
-#ifndef	__ASM_M32R_CACHECTL
-#define	__ASM_M32R_CACHECTL
-
-/*
- * Options for cacheflush system call
- *
- * cacheflush() is currently fluch_cache_all().
- */
-#define	ICACHE	(1<<0)		/* flush instruction cache        */
-#define	DCACHE	(1<<1)		/* writeback and flush data cache */
-#define	BCACHE	(ICACHE|DCACHE)	/* flush both caches              */
-
-/*
- * Caching modes for the cachectl(2) call
- *
- * cachectl(2) is currently not supported and returns ENOSYS.
- */
-#define CACHEABLE	0	/* make pages cacheable */
-#define UNCACHEABLE	1	/* make pages uncacheable */
-
-#endif	/* __ASM_M32R_CACHECTL */
diff -urN linux-2.6.30-rc2/include/asm-m32r/cacheflush.h linux-2.6.30-rc3/include/asm-m32r/cacheflush.h
--- linux-2.6.30-rc2/include/asm-m32r/cacheflush.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/cacheflush.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,69 +0,0 @@
-#ifndef _ASM_M32R_CACHEFLUSH_H
-#define _ASM_M32R_CACHEFLUSH_H
-
-#include <linux/mm.h>
-
-extern void _flush_cache_all(void);
-extern void _flush_cache_copyback_all(void);
-
-#if defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_OPSP) || defined(CONFIG_CHIP_M32104)
-#define flush_cache_all()			do { } while (0)
-#define flush_cache_mm(mm)			do { } while (0)
-#define flush_cache_dup_mm(mm)			do { } while (0)
-#define flush_cache_range(vma, start, end)	do { } while (0)
-#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
-#define flush_dcache_page(page)			do { } while (0)
-#define flush_dcache_mmap_lock(mapping)		do { } while (0)
-#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
-#ifndef CONFIG_SMP
-#define flush_icache_range(start, end)		_flush_cache_copyback_all()
-#define flush_icache_page(vma,pg)		_flush_cache_copyback_all()
-#define flush_icache_user_range(vma,pg,adr,len)	_flush_cache_copyback_all()
-#define flush_cache_sigtramp(addr)		_flush_cache_copyback_all()
-#else	/* CONFIG_SMP */
-extern void smp_flush_cache_all(void);
-#define flush_icache_range(start, end)		smp_flush_cache_all()
-#define flush_icache_page(vma,pg)		smp_flush_cache_all()
-#define flush_icache_user_range(vma,pg,adr,len)	smp_flush_cache_all()
-#define flush_cache_sigtramp(addr)		_flush_cache_copyback_all()
-#endif	/* CONFIG_SMP */
-#elif defined(CONFIG_CHIP_M32102)
-#define flush_cache_all()			do { } while (0)
-#define flush_cache_mm(mm)			do { } while (0)
-#define flush_cache_dup_mm(mm)			do { } while (0)
-#define flush_cache_range(vma, start, end)	do { } while (0)
-#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
-#define flush_dcache_page(page)			do { } while (0)
-#define flush_dcache_mmap_lock(mapping)		do { } while (0)
-#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
-#define flush_icache_range(start, end)		_flush_cache_all()
-#define flush_icache_page(vma,pg)		_flush_cache_all()
-#define flush_icache_user_range(vma,pg,adr,len)	_flush_cache_all()
-#define flush_cache_sigtramp(addr)		_flush_cache_all()
-#else
-#define flush_cache_all()			do { } while (0)
-#define flush_cache_mm(mm)			do { } while (0)
-#define flush_cache_dup_mm(mm)			do { } while (0)
-#define flush_cache_range(vma, start, end)	do { } while (0)
-#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
-#define flush_dcache_page(page)			do { } while (0)
-#define flush_dcache_mmap_lock(mapping)		do { } while (0)
-#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
-#define flush_icache_range(start, end)		do { } while (0)
-#define flush_icache_page(vma,pg)		do { } while (0)
-#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
-#define flush_cache_sigtramp(addr)		do { } while (0)
-#endif	/* CONFIG_CHIP_* */
-
-#define flush_cache_vmap(start, end)	do { } while (0)
-#define flush_cache_vunmap(start, end)	do { } while (0)
-
-#define copy_to_user_page(vma, page, vaddr, dst, src, len)	\
-do {								\
-	memcpy(dst, src, len);					\
-	flush_icache_user_range(vma, page, vaddr, len);		\
-} while (0)
-#define copy_from_user_page(vma, page, vaddr, dst, src, len)	\
-	memcpy(dst, src, len)
-
-#endif /* _ASM_M32R_CACHEFLUSH_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/checksum.h linux-2.6.30-rc3/include/asm-m32r/checksum.h
--- linux-2.6.30-rc2/include/asm-m32r/checksum.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/checksum.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,204 +0,0 @@
-#ifdef __KERNEL__
-#ifndef _ASM_M32R_CHECKSUM_H
-#define _ASM_M32R_CHECKSUM_H
-
-/*
- * include/asm-m32r/checksum.h
- *
- * IP/TCP/UDP checksum routines
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Some code taken from mips and parisc architecture.
- *
- *    Copyright (C) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata
- *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#include <linux/in6.h>
-
-/*
- * computes the checksum of a memory block at buff, length len,
- * and adds in "sum" (32-bit)
- *
- * returns a 32-bit number suitable for feeding into itself
- * or csum_tcpudp_magic
- *
- * this function must be called with even lengths, except
- * for the last fragment, which may be odd
- *
- * it's best to have buff aligned on a 32-bit boundary
- */
-asmlinkage __wsum csum_partial(const void *buff, int len, __wsum sum);
-
-/*
- * The same as csum_partial, but copies from src while it checksums.
- *
- * Here even more important to align src and dst on a 32-bit (or even
- * better 64-bit) boundary
- */
-extern __wsum csum_partial_copy_nocheck(const void *src, void *dst,
-                                              int len, __wsum sum);
-
-/*
- * This is a new version of the above that records errors it finds in *errp,
- * but continues and zeros thre rest of the buffer.
- */
-extern __wsum csum_partial_copy_from_user(const void __user *src, void *dst,
-                                                int len, __wsum sum,
-                                                int *err_ptr);
-
-/*
- *	Fold a partial checksum
- */
-
-static inline __sum16 csum_fold(__wsum sum)
-{
-	unsigned long tmpreg;
-	__asm__(
-		"	sll3	%1, %0, #16 \n"
-		"	cmp	%0, %0 \n"
-		"	addx	%0, %1 \n"
-		"	ldi	%1, #0 \n"
-		"	srli	%0, #16 \n"
-		"	addx	%0, %1 \n"
-		"	xor3	%0, %0, #0x0000ffff \n"
-		: "=r" (sum), "=&r" (tmpreg)
-		: "0"  (sum)
-		: "cbit"
-	);
-	return (__force __sum16)sum;
-}
-
-/*
- * This is a version of ip_compute_csum() optimized for IP headers,
- * which always checksum on 4 octet boundaries.
- */
-static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
-{
-	unsigned long tmpreg0, tmpreg1;
-	__wsum sum;
-
-	__asm__ __volatile__(
-		"	ld	%0, @%1+ \n"
-		"	addi	%2, #-4 \n"
-		"#	bgez	%2, 2f \n"
-		"	cmp	%0, %0 \n"
-		"	ld	%3, @%1+ \n"
-		"	ld	%4, @%1+ \n"
-		"	addx	%0, %3 \n"
-		"	ld	%3, @%1+ \n"
-		"	addx	%0, %4 \n"
-		"	addx	%0, %3 \n"
-		"	.fillinsn\n"
-		"1: \n"
-		"	ld	%4, @%1+ \n"
-		"	addi	%2, #-1 \n"
-		"	addx	%0, %4 \n"
-		"	bgtz	%2, 1b \n"
-		"\n"
-		"	ldi	%3, #0 \n"
-		"	addx	%0, %3 \n"
-		"	.fillinsn\n"
-		"2: \n"
-	/* Since the input registers which are loaded with iph and ihl
-	   are modified, we must also specify them as outputs, or gcc
-	   will assume they contain their original values. */
-	: "=&r" (sum), "=r" (iph), "=r" (ihl), "=&r" (tmpreg0), "=&r" (tmpreg1)
-	: "1" (iph), "2" (ihl)
-	: "cbit", "memory");
-
-	return csum_fold(sum);
-}
-
-static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
-					       unsigned short len,
-					       unsigned short proto,
-					       __wsum sum)
-{
-#if defined(__LITTLE_ENDIAN)
-	unsigned long len_proto = (proto + len) << 8;
-#else
-	unsigned long len_proto = proto + len;
-#endif
-	unsigned long tmpreg;
-
-	__asm__(
-		"	cmp	%0, %0 \n"
-		"	addx	%0, %2 \n"
-		"	addx	%0, %3 \n"
-		"	addx	%0, %4 \n"
-		"	ldi	%1, #0 \n"
-		"	addx	%0, %1 \n"
-		: "=r" (sum), "=&r" (tmpreg)
-		: "r" (daddr), "r" (saddr), "r" (len_proto), "0" (sum)
-		: "cbit"
-	);
-
-	return sum;
-}
-
-/*
- * computes the checksum of the TCP/UDP pseudo-header
- * returns a 16-bit checksum, already complemented
- */
-static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
-						   unsigned short len,
-						   unsigned short proto,
-						   __wsum sum)
-{
-	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
-}
-
-/*
- * this routine is used for miscellaneous IP-like checksums, mainly
- * in icmp.c
- */
-
-static inline __sum16 ip_compute_csum(const void *buff, int len)
-{
-	return csum_fold (csum_partial(buff, len, 0));
-}
-
-#define _HAVE_ARCH_IPV6_CSUM
-static inline __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
-				      const struct in6_addr *daddr,
-				      __u32 len, unsigned short proto,
-				      __wsum sum)
-{
-	unsigned long tmpreg0, tmpreg1, tmpreg2, tmpreg3;
-	__asm__(
-		"	ld	%1, @(%5) \n"
-		"	ld	%2, @(4,%5) \n"
-		"	ld	%3, @(8,%5) \n"
-		"	ld	%4, @(12,%5) \n"
-		"	add	%0, %1 \n"
-		"	addx	%0, %2 \n"
-		"	addx	%0, %3 \n"
-		"	addx	%0, %4 \n"
-		"	ld	%1, @(%6) \n"
-		"	ld	%2, @(4,%6) \n"
-		"	ld	%3, @(8,%6) \n"
-		"	ld	%4, @(12,%6) \n"
-		"	addx	%0, %1 \n"
-		"	addx	%0, %2 \n"
-		"	addx	%0, %3 \n"
-		"	addx	%0, %4 \n"
-		"	addx	%0, %7 \n"
-		"	addx	%0, %8 \n"
-		"	ldi	%1, #0 \n"
-		"	addx	%0, %1 \n"
-		: "=&r" (sum), "=&r" (tmpreg0), "=&r" (tmpreg1),
-		  "=&r" (tmpreg2), "=&r" (tmpreg3)
-		: "r" (saddr), "r" (daddr),
-		  "r" (htonl(len)), "r" (htonl(proto)), "0" (sum)
-		: "cbit"
-	);
-
-	return csum_fold(sum);
-}
-
-#endif /* _ASM_M32R_CHECKSUM_H */
-#endif /* __KERNEL__ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/cputime.h linux-2.6.30-rc3/include/asm-m32r/cputime.h
--- linux-2.6.30-rc2/include/asm-m32r/cputime.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/cputime.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef __M32R_CPUTIME_H
-#define __M32R_CPUTIME_H
-
-#include <asm-generic/cputime.h>
-
-#endif /* __M32R_CPUTIME_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/current.h linux-2.6.30-rc3/include/asm-m32r/current.h
--- linux-2.6.30-rc2/include/asm-m32r/current.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/current.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,15 +0,0 @@
-#ifndef _ASM_M32R_CURRENT_H
-#define _ASM_M32R_CURRENT_H
-
-#include <linux/thread_info.h>
-
-struct task_struct;
-
-static __inline__ struct task_struct *get_current(void)
-{
-	return current_thread_info()->task;
-}
-
-#define current	(get_current())
-
-#endif	/* _ASM_M32R_CURRENT_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/delay.h linux-2.6.30-rc3/include/asm-m32r/delay.h
--- linux-2.6.30-rc2/include/asm-m32r/delay.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/delay.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,26 +0,0 @@
-#ifndef _ASM_M32R_DELAY_H
-#define _ASM_M32R_DELAY_H
-
-/*
- * Copyright (C) 1993 Linus Torvalds
- *
- * Delay routines calling functions in arch/m32r/lib/delay.c
- */
-
-extern void __bad_udelay(void);
-extern void __bad_ndelay(void);
-
-extern void __udelay(unsigned long usecs);
-extern void __ndelay(unsigned long nsecs);
-extern void __const_udelay(unsigned long xloops);
-extern void __delay(unsigned long loops);
-
-#define udelay(n) (__builtin_constant_p(n) ? \
-	((n) > 20000 ? __bad_udelay() : __const_udelay((n) * 0x10c7ul)) : \
-	__udelay(n))
-
-#define ndelay(n) (__builtin_constant_p(n) ? \
-	((n) > 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
-	__ndelay(n))
-
-#endif /* _ASM_M32R_DELAY_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/device.h linux-2.6.30-rc3/include/asm-m32r/device.h
--- linux-2.6.30-rc2/include/asm-m32r/device.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/device.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-/*
- * Arch specific extensions to struct device
- *
- * This file is released under the GPLv2
- */
-#include <asm-generic/device.h>
-
diff -urN linux-2.6.30-rc2/include/asm-m32r/div64.h linux-2.6.30-rc3/include/asm-m32r/div64.h
--- linux-2.6.30-rc2/include/asm-m32r/div64.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/div64.h	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-#include <asm-generic/div64.h>
diff -urN linux-2.6.30-rc2/include/asm-m32r/dma.h linux-2.6.30-rc3/include/asm-m32r/dma.h
--- linux-2.6.30-rc2/include/asm-m32r/dma.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/dma.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,12 +0,0 @@
-#ifndef _ASM_M32R_DMA_H
-#define _ASM_M32R_DMA_H
-
-#include <asm/io.h>
-
-/*
- * The maximum address that we can perform a DMA transfer
- * to on this platform
- */
-#define MAX_DMA_ADDRESS      (PAGE_OFFSET+0x20000000)
-
-#endif /* _ASM_M32R_DMA_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/elf.h linux-2.6.30-rc3/include/asm-m32r/elf.h
--- linux-2.6.30-rc2/include/asm-m32r/elf.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/elf.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,134 +0,0 @@
-#ifndef _ASM_M32R__ELF_H
-#define _ASM_M32R__ELF_H
-
-/*
- * ELF-specific definitions.
- *
- * Copyright (C) 1999-2004, Renesas Technology Corp.
- *      Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#include <asm/ptrace.h>
-#include <asm/user.h>
-#include <asm/page.h>
-
-/* M32R relocation types  */
-#define	R_M32R_NONE		0
-#define	R_M32R_16		1
-#define	R_M32R_32		2
-#define	R_M32R_24		3
-#define	R_M32R_10_PCREL		4
-#define	R_M32R_18_PCREL		5
-#define	R_M32R_26_PCREL		6
-#define	R_M32R_HI16_ULO		7
-#define	R_M32R_HI16_SLO		8
-#define	R_M32R_LO16		9
-#define	R_M32R_SDA16		10
-#define	R_M32R_GNU_VTINHERIT	11
-#define	R_M32R_GNU_VTENTRY	12
-
-#define R_M32R_16_RELA		33
-#define R_M32R_32_RELA		34
-#define R_M32R_24_RELA		35
-#define R_M32R_10_PCREL_RELA	36
-#define R_M32R_18_PCREL_RELA	37
-#define R_M32R_26_PCREL_RELA	38
-#define R_M32R_HI16_ULO_RELA	39
-#define R_M32R_HI16_SLO_RELA	40
-#define R_M32R_LO16_RELA	41
-#define R_M32R_SDA16_RELA	42
-#define	R_M32R_RELA_GNU_VTINHERIT	43
-#define	R_M32R_RELA_GNU_VTENTRY	44
-
-#define R_M32R_GOT24		48
-#define R_M32R_26_PLTREL	49
-#define R_M32R_COPY		50
-#define R_M32R_GLOB_DAT		51
-#define R_M32R_JMP_SLOT		52
-#define R_M32R_RELATIVE		53
-#define R_M32R_GOTOFF		54
-#define R_M32R_GOTPC24		55
-#define R_M32R_GOT16_HI_ULO	56
-#define R_M32R_GOT16_HI_SLO	57
-#define R_M32R_GOT16_LO		58
-#define R_M32R_GOTPC_HI_ULO	59
-#define R_M32R_GOTPC_HI_SLO	60
-#define R_M32R_GOTPC_LO		61
-#define R_M32R_GOTOFF_HI_ULO	62
-#define R_M32R_GOTOFF_HI_SLO	63
-#define R_M32R_GOTOFF_LO	64
-
-#define R_M32R_NUM		256
-
-/*
- * ELF register definitions..
- */
-#define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))
-
-typedef unsigned long elf_greg_t;
-typedef elf_greg_t elf_gregset_t[ELF_NGREG];
-
-/* We have no FP mumumu.  */
-typedef double elf_fpreg_t;
-typedef elf_fpreg_t elf_fpregset_t;
-
-/*
- * This is used to ensure we don't load something for the wrong architecture.
- */
-#define elf_check_arch(x) \
-	(((x)->e_machine == EM_M32R) || ((x)->e_machine == EM_CYGNUS_M32R))
-
-/*
- * These are used to set parameters in the core dumps.
- */
-#define ELF_CLASS	ELFCLASS32
-#if defined(__LITTLE_ENDIAN)
-#define ELF_DATA	ELFDATA2LSB
-#elif defined(__BIG_ENDIAN)
-#define ELF_DATA	ELFDATA2MSB
-#else
-#error no endian defined
-#endif
-#define ELF_ARCH	EM_M32R
-
-/* r0 is set by ld.so to a pointer to a function which might be
- * registered using 'atexit'.  This provides a mean for the dynamic
- * linker to call DT_FINI functions for shared libraries that have
- * been loaded before the code runs.
- *
- * So that we can use the same startup file with static executables,
- * we start programs with a value of 0 to indicate that there is no
- * such function.
- */
-#define ELF_PLAT_INIT(_r, load_addr)	(_r)->r0 = 0
-
-#define USE_ELF_CORE_DUMP
-#define ELF_EXEC_PAGESIZE	PAGE_SIZE
-
-/*
- * This is the location that an ET_DYN program is loaded if exec'ed.
- * Typical use of this is to invoke "./ld.so someprog" to test out a
- * new version of the loader.  We need to make sure that it is out of
- * the way of the program that it will "exec", and that there is
- * sufficient room for the brk.
- */
-#define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
-
-/* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
-   now struct_user_regs, they are different) */
-
-#define ELF_CORE_COPY_REGS(pr_reg, regs)  \
-	memcpy((char *)pr_reg, (char *)regs, sizeof (struct pt_regs));
-
-/* This yields a mask that user programs can use to figure out what
-   instruction set this CPU supports.  */
-#define ELF_HWCAP	(0)
-
-/* This yields a string that ld.so will use to load implementation
-   specific libraries for optimization.  This is more specific in
-   intent than poking at uname or /proc/cpuinfo.  */
-#define ELF_PLATFORM	(NULL)
-
-#define SET_PERSONALITY(ex) set_personality(PER_LINUX)
-
-#endif  /* _ASM_M32R__ELF_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/emergency-restart.h linux-2.6.30-rc3/include/asm-m32r/emergency-restart.h
--- linux-2.6.30-rc2/include/asm-m32r/emergency-restart.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/emergency-restart.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_EMERGENCY_RESTART_H
-#define _ASM_EMERGENCY_RESTART_H
-
-#include <asm-generic/emergency-restart.h>
-
-#endif /* _ASM_EMERGENCY_RESTART_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/errno.h linux-2.6.30-rc3/include/asm-m32r/errno.h
--- linux-2.6.30-rc2/include/asm-m32r/errno.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/errno.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_M32R_ERRNO_H
-#define _ASM_M32R_ERRNO_H
-
-#include <asm-generic/errno.h>
-
-#endif /* _ASM_M32R_ERRNO_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/fb.h linux-2.6.30-rc3/include/asm-m32r/fb.h
--- linux-2.6.30-rc2/include/asm-m32r/fb.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/fb.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-#ifndef _ASM_FB_H_
-#define _ASM_FB_H_
-
-#include <linux/fb.h>
-#include <linux/fs.h>
-#include <asm/page.h>
-
-static inline void fb_pgprotect(struct file *file, struct vm_area_struct *vma,
-				unsigned long off)
-{
-	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-}
-
-static inline int fb_is_primary_device(struct fb_info *info)
-{
-	return 0;
-}
-
-#endif /* _ASM_FB_H_ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/fcntl.h linux-2.6.30-rc3/include/asm-m32r/fcntl.h
--- linux-2.6.30-rc2/include/asm-m32r/fcntl.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/fcntl.h	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-#include <asm-generic/fcntl.h>
diff -urN linux-2.6.30-rc2/include/asm-m32r/flat.h linux-2.6.30-rc3/include/asm-m32r/flat.h
--- linux-2.6.30-rc2/include/asm-m32r/flat.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/flat.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,146 +0,0 @@
-/*
- * include/asm-m32r/flat.h
- *
- * uClinux flat-format executables
- *
- * Copyright (C) 2004  Kazuhiro Inaoka
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive for
- * more details.
- */
-#ifndef __ASM_M32R_FLAT_H
-#define __ASM_M32R_FLAT_H
-
-#define	flat_stack_align(sp)		(*sp += (*sp & 3 ? (4 - (*sp & 3)): 0))
-#define	flat_argvp_envp_on_stack()		0
-#define	flat_old_ram_flag(flags)		(flags)
-#define	flat_set_persistent(relval, p)		0
-#define	flat_reloc_valid(reloc, size)		\
-	(((reloc) - textlen_for_m32r_lo16_data) <= (size))
-#define flat_get_addr_from_rp(rp, relval, flags, persistent) \
-	m32r_flat_get_addr_from_rp(rp, relval, (text_len) )
-
-#define flat_put_addr_at_rp(rp, addr, relval) \
-	m32r_flat_put_addr_at_rp(rp, addr, relval)
-
-/* Convert a relocation entry into an address.  */
-static inline unsigned long
-flat_get_relocate_addr (unsigned long relval)
-{
-        return relval & 0x00ffffff; /* Mask out top 8-bits */
-}
-
-#define	flat_m32r_get_reloc_type(relval)	((relval) >> 24)
-
-#define M32R_SETH_OPCODE	0xd0c00000 /* SETH instruction code */
-
-#define FLAT_M32R_32		0x00	/* 32bits reloc */
-#define FLAT_M32R_24		0x01	/* unsigned 24bits reloc */
-#define FLAT_M32R_16		0x02	/* 16bits reloc */
-#define FLAT_M32R_LO16		0x03	/* signed low 16bits reloc (low()) */
-#define FLAT_M32R_LO16_DATA	0x04	/* signed low 16bits reloc (low())
-					   for a symbol in .data section */
-					/* High 16bits of an address used
-					   when the lower 16bbits are treated
-					   as unsigned.
-                                           To create SETH instruction only.
-					   0x1X: X means a number of register.
-					   0x10 - 0x3F are reserved. */
-#define FLAT_M32R_HI16_ULO	0x10	/* reloc for SETH Rn,#high(imm16) */
-					/* High 16bits of an address used
-					   when the lower 16bbits are treated
-					   as signed.
-                                           To create SETH instruction only.
-					   0x2X: X means a number of register.
-					   0x20 - 0x4F are reserved. */
-#define FLAT_M32R_HI16_SLO	0x20	/* reloc for SETH Rn,#shigh(imm16) */
-
-static unsigned long textlen_for_m32r_lo16_data = 0;
-
-static inline unsigned long m32r_flat_get_addr_from_rp (unsigned long *rp,
-                                                        unsigned long relval,
-						        unsigned long textlen)
-{
-        unsigned int reloc = flat_m32r_get_reloc_type (relval);
-	textlen_for_m32r_lo16_data = 0;
-	if (reloc & 0xf0) {
-		unsigned long addr = htonl(*rp);
-		switch (reloc & 0xf0)
-		{
-		case FLAT_M32R_HI16_ULO:
-		case FLAT_M32R_HI16_SLO:
-			if (addr == 0) {
-				/* put "seth Rn,#0x0" instead of 0 (addr). */
-				*rp = (M32R_SETH_OPCODE | ((reloc & 0x0f)<<24));
-			}
-			return addr;
-		default:
-			break;
-		}
-	} else {
-		switch (reloc)
-		{
-		case FLAT_M32R_LO16:
-			return htonl(*rp) & 0xFFFF;
-		case FLAT_M32R_LO16_DATA:
-                        /* FIXME: The return value will decrease by textlen
-			   at m32r_flat_put_addr_at_rp () */
-			textlen_for_m32r_lo16_data = textlen;
-			return (htonl(*rp) & 0xFFFF) + textlen;
-		case FLAT_M32R_16:
-			return htons(*(unsigned short *)rp) & 0xFFFF;
-		case FLAT_M32R_24:
-			return htonl(*rp) & 0xFFFFFF;
-		case FLAT_M32R_32:
-			return htonl(*rp);
-		default:
-			break;
-		}
-	}
-	return ~0;      /* bogus value */
-}
-
-static inline void m32r_flat_put_addr_at_rp (unsigned long *rp,
-					     unsigned long addr,
-                                             unsigned long relval)
-{
-        unsigned int reloc = flat_m32r_get_reloc_type (relval);
-	if (reloc & 0xf0) {
-		unsigned long Rn = reloc & 0x0f; /* get a number of register */
-		Rn <<= 24; /* 0x0R000000 */
-		reloc &= 0xf0;
-		switch (reloc)
-		{
-		case FLAT_M32R_HI16_ULO: /* To create SETH Rn,#high(imm16) */
-			*rp = (M32R_SETH_OPCODE | Rn
-			       | ((addr >> 16) & 0xFFFF));
-			break;
-		case FLAT_M32R_HI16_SLO: /* To create SETH Rn,#shigh(imm16) */
-			*rp = (M32R_SETH_OPCODE | Rn
-			       | (((addr >> 16) + ((addr & 0x8000) ? 1 : 0))
-				  & 0xFFFF));
-			break;
-		}
-	} else {
-		switch (reloc) {
-		case FLAT_M32R_LO16_DATA:
-			addr -= textlen_for_m32r_lo16_data;
-			textlen_for_m32r_lo16_data = 0;
-		case FLAT_M32R_LO16:
-			*rp = (htonl(*rp) & 0xFFFF0000) | (addr & 0xFFFF);
-			break;
-		case FLAT_M32R_16:
-			*(unsigned short *)rp = addr & 0xFFFF;
-			break;
-		case FLAT_M32R_24:
-			*rp = (htonl(*rp) & 0xFF000000) | (addr & 0xFFFFFF);
-			break;
-		case FLAT_M32R_32:
-			*rp = addr;
-			break;
-		}
-	}
-}
-
-#endif /* __ASM_M32R_FLAT_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/ftrace.h linux-2.6.30-rc3/include/asm-m32r/ftrace.h
--- linux-2.6.30-rc2/include/asm-m32r/ftrace.h	2009-04-22 03:29:12.140931408 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/ftrace.h	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-/* empty */
diff -urN linux-2.6.30-rc2/include/asm-m32r/futex.h linux-2.6.30-rc3/include/asm-m32r/futex.h
--- linux-2.6.30-rc2/include/asm-m32r/futex.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/futex.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_FUTEX_H
-#define _ASM_FUTEX_H
-
-#include <asm-generic/futex.h>
-
-#endif
diff -urN linux-2.6.30-rc2/include/asm-m32r/hardirq.h linux-2.6.30-rc3/include/asm-m32r/hardirq.h
--- linux-2.6.30-rc2/include/asm-m32r/hardirq.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/hardirq.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,36 +0,0 @@
-#ifdef __KERNEL__
-#ifndef __ASM_HARDIRQ_H
-#define __ASM_HARDIRQ_H
-
-#include <linux/threads.h>
-#include <linux/irq.h>
-
-typedef struct {
-	unsigned int __softirq_pending;
-} ____cacheline_aligned irq_cpustat_t;
-
-#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
-
-#if NR_IRQS > 256
-#define HARDIRQ_BITS	9
-#else
-#define HARDIRQ_BITS	8
-#endif
-
-/*
- * The hardirq mask has to be large enough to have
- * space for potentially all IRQ sources in the system
- * nesting on a single CPU:
- */
-#if (1 << HARDIRQ_BITS) < NR_IRQS
-# error HARDIRQ_BITS is too low!
-#endif
-
-static inline void ack_bad_irq(int irq)
-{
-	printk(KERN_CRIT "unexpected IRQ trap at vector %02x\n", irq);
-	BUG();
-}
-
-#endif /* __ASM_HARDIRQ_H */
-#endif /* __KERNEL__ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/hw_irq.h linux-2.6.30-rc3/include/asm-m32r/hw_irq.h
--- linux-2.6.30-rc2/include/asm-m32r/hw_irq.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/hw_irq.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-#ifndef _ASM_M32R_HW_IRQ_H
-#define _ASM_M32R_HW_IRQ_H
-
-#endif /* _ASM_M32R_HW_IRQ_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/io.h linux-2.6.30-rc3/include/asm-m32r/io.h
--- linux-2.6.30-rc2/include/asm-m32r/io.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/io.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,200 +0,0 @@
-#ifndef _ASM_M32R_IO_H
-#define _ASM_M32R_IO_H
-
-#include <linux/string.h>
-#include <linux/compiler.h>
-#include <asm/page.h>  /* __va */
-
-#ifdef __KERNEL__
-
-#define IO_SPACE_LIMIT  0xFFFFFFFF
-
-/**
- *	virt_to_phys	-	map virtual addresses to physical
- *	@address: address to remap
- *
- *	The returned physical address is the physical (CPU) mapping for
- *	the memory address given. It is only valid to use this function on
- *	addresses directly mapped or allocated via kmalloc.
- *
- *	This function does not give bus mappings for DMA transfers. In
- *	almost all conceivable cases a device driver should not be using
- *	this function
- */
-
-static inline unsigned long virt_to_phys(volatile void * address)
-{
-	return __pa(address);
-}
-
-/**
- *	phys_to_virt	-	map physical address to virtual
- *	@address: address to remap
- *
- *	The returned virtual address is a current CPU mapping for
- *	the memory address given. It is only valid to use this function on
- *	addresses that have a kernel mapping
- *
- *	This function does not handle bus mappings for DMA transfers. In
- *	almost all conceivable cases a device driver should not be using
- *	this function
- */
-
-static inline void *phys_to_virt(unsigned long address)
-{
-	return __va(address);
-}
-
-extern void __iomem *
-__ioremap(unsigned long offset, unsigned long size, unsigned long flags);
-
-/**
- *	ioremap		-	map bus memory into CPU space
- *	@offset:	bus address of the memory
- *	@size:		size of the resource to map
- *
- *	ioremap performs a platform specific sequence of operations to
- *	make bus memory CPU accessible via the readb/readw/readl/writeb/
- *	writew/writel functions and the other mmio helpers. The returned
- *	address is not guaranteed to be usable directly as a virtual
- *	address.
- */
-
-static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
-{
-	return __ioremap(offset, size, 0);
-}
-
-extern void iounmap(volatile void __iomem *addr);
-#define ioremap_nocache(off,size) ioremap(off,size)
-
-/*
- * IO bus memory addresses are also 1:1 with the physical address
- */
-#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
-#define page_to_bus	page_to_phys
-#define virt_to_bus	virt_to_phys
-
-extern unsigned char _inb(unsigned long);
-extern unsigned short _inw(unsigned long);
-extern unsigned long _inl(unsigned long);
-extern unsigned char _inb_p(unsigned long);
-extern unsigned short _inw_p(unsigned long);
-extern unsigned long _inl_p(unsigned long);
-extern void _outb(unsigned char, unsigned long);
-extern void _outw(unsigned short, unsigned long);
-extern void _outl(unsigned long, unsigned long);
-extern void _outb_p(unsigned char, unsigned long);
-extern void _outw_p(unsigned short, unsigned long);
-extern void _outl_p(unsigned long, unsigned long);
-extern void _insb(unsigned int, void *, unsigned long);
-extern void _insw(unsigned int, void *, unsigned long);
-extern void _insl(unsigned int, void *, unsigned long);
-extern void _outsb(unsigned int, const void *, unsigned long);
-extern void _outsw(unsigned int, const void *, unsigned long);
-extern void _outsl(unsigned int, const void *, unsigned long);
-
-static inline unsigned char _readb(unsigned long addr)
-{
-	return *(volatile unsigned char __force *)addr;
-}
-
-static inline unsigned short _readw(unsigned long addr)
-{
-	return *(volatile unsigned short __force *)addr;
-}
-
-static inline unsigned long _readl(unsigned long addr)
-{
-	return *(volatile unsigned long __force *)addr;
-}
-
-static inline void _writeb(unsigned char b, unsigned long addr)
-{
-	*(volatile unsigned char __force *)addr = b;
-}
-
-static inline void _writew(unsigned short w, unsigned long addr)
-{
-	*(volatile unsigned short __force *)addr = w;
-}
-
-static inline void _writel(unsigned long l, unsigned long addr)
-{
-	*(volatile unsigned long __force *)addr = l;
-}
-
-#define inb     _inb
-#define inw     _inw
-#define inl     _inl
-#define outb    _outb
-#define outw    _outw
-#define outl    _outl
-
-#define inb_p   _inb_p
-#define inw_p   _inw_p
-#define inl_p   _inl_p
-#define outb_p  _outb_p
-#define outw_p  _outw_p
-#define outl_p  _outl_p
-
-#define insb    _insb
-#define insw    _insw
-#define insl    _insl
-#define outsb   _outsb
-#define outsw   _outsw
-#define outsl   _outsl
-
-#define readb(addr)   _readb((unsigned long)(addr))
-#define readw(addr)   _readw((unsigned long)(addr))
-#define readl(addr)   _readl((unsigned long)(addr))
-#define __raw_readb readb
-#define __raw_readw readw
-#define __raw_readl readl
-#define readb_relaxed readb
-#define readw_relaxed readw
-#define readl_relaxed readl
-
-#define writeb(val, addr)  _writeb((val), (unsigned long)(addr))
-#define writew(val, addr)  _writew((val), (unsigned long)(addr))
-#define writel(val, addr)  _writel((val), (unsigned long)(addr))
-#define __raw_writeb writeb
-#define __raw_writew writew
-#define __raw_writel writel
-
-#define mmiowb()
-
-#define flush_write_buffers() do { } while (0)  /* M32R_FIXME */
-
-static inline void
-memset_io(volatile void __iomem *addr, unsigned char val, int count)
-{
-	memset((void __force *) addr, val, count);
-}
-
-static inline void
-memcpy_fromio(void *dst, volatile void __iomem *src, int count)
-{
-	memcpy(dst, (void __force *) src, count);
-}
-
-static inline void
-memcpy_toio(volatile void __iomem *dst, const void *src, int count)
-{
-	memcpy((void __force *) dst, src, count);
-}
-
-/*
- * Convert a physical pointer to a virtual kernel pointer for /dev/mem
- * access
- */
-#define xlate_dev_mem_ptr(p)	__va(p)
-
-/*
- * Convert a virtual cached pointer to an uncached pointer
- */
-#define xlate_dev_kmem_ptr(p)	p
-
-#endif  /* __KERNEL__ */
-
-#endif  /* _ASM_M32R_IO_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/ioctl.h linux-2.6.30-rc3/include/asm-m32r/ioctl.h
--- linux-2.6.30-rc2/include/asm-m32r/ioctl.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/ioctl.h	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-#include <asm-generic/ioctl.h>
diff -urN linux-2.6.30-rc2/include/asm-m32r/ioctls.h linux-2.6.30-rc3/include/asm-m32r/ioctls.h
--- linux-2.6.30-rc2/include/asm-m32r/ioctls.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/ioctls.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,87 +0,0 @@
-#ifndef __ARCH_M32R_IOCTLS_H__
-#define __ARCH_M32R_IOCTLS_H__
-
-#include <asm/ioctl.h>
-
-/* 0x54 is just a magic number to make these relatively unique ('T') */
-
-#define TCGETS		0x5401
-#define TCSETS		0x5402 /* Clashes with SNDCTL_TMR_START sound ioctl */
-#define TCSETSW		0x5403
-#define TCSETSF		0x5404
-#define TCGETA		0x5405
-#define TCSETA		0x5406
-#define TCSETAW		0x5407
-#define TCSETAF		0x5408
-#define TCSBRK		0x5409
-#define TCXONC		0x540A
-#define TCFLSH		0x540B
-#define TIOCEXCL	0x540C
-#define TIOCNXCL	0x540D
-#define TIOCSCTTY	0x540E
-#define TIOCGPGRP	0x540F
-#define TIOCSPGRP	0x5410
-#define TIOCOUTQ	0x5411
-#define TIOCSTI		0x5412
-#define TIOCGWINSZ	0x5413
-#define TIOCSWINSZ	0x5414
-#define TIOCMGET	0x5415
-#define TIOCMBIS	0x5416
-#define TIOCMBIC	0x5417
-#define TIOCMSET	0x5418
-#define TIOCGSOFTCAR	0x5419
-#define TIOCSSOFTCAR	0x541A
-#define FIONREAD	0x541B
-#define TIOCINQ		FIONREAD
-#define TIOCLINUX	0x541C
-#define TIOCCONS	0x541D
-#define TIOCGSERIAL	0x541E
-#define TIOCSSERIAL	0x541F
-#define TIOCPKT		0x5420
-#define FIONBIO		0x5421
-#define TIOCNOTTY	0x5422
-#define TIOCSETD	0x5423
-#define TIOCGETD	0x5424
-#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
-/* #define TIOCTTYGSTRUCT 0x5426 - Former debugging-only ioctl */
-#define TIOCSBRK	0x5427  /* BSD compatibility */
-#define TIOCCBRK	0x5428  /* BSD compatibility */
-#define TIOCGSID	0x5429  /* Return the session ID of FD */
-#define TCGETS2		_IOR('T',0x2A, struct termios2)
-#define TCSETS2		_IOW('T',0x2B, struct termios2)
-#define TCSETSW2	_IOW('T',0x2C, struct termios2)
-#define TCSETSF2	_IOW('T',0x2D, struct termios2)
-#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
-#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
-
-#define FIONCLEX	0x5450
-#define FIOCLEX		0x5451
-#define FIOASYNC	0x5452
-#define TIOCSERCONFIG	0x5453
-#define TIOCSERGWILD	0x5454
-#define TIOCSERSWILD	0x5455
-#define TIOCGLCKTRMIOS	0x5456
-#define TIOCSLCKTRMIOS	0x5457
-#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
-#define TIOCSERGETLSR   0x5459 /* Get line status register */
-#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
-#define TIOCSERSETMULTI 0x545B /* Set multiport config */
-
-#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
-#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
-#define TIOCGHAYESESP   0x545E  /* Get Hayes ESP configuration */
-#define TIOCSHAYESESP   0x545F  /* Set Hayes ESP configuration */
-#define FIOQSIZE	0x5460
-
-/* Used for packet mode */
-#define TIOCPKT_DATA		 0
-#define TIOCPKT_FLUSHREAD	 1
-#define TIOCPKT_FLUSHWRITE	 2
-#define TIOCPKT_STOP		 4
-#define TIOCPKT_START		 8
-#define TIOCPKT_NOSTOP		16
-#define TIOCPKT_DOSTOP		32
-
-#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
-
-#endif /* __ARCH_M32R_IOCTLS_H__ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/ipcbuf.h linux-2.6.30-rc3/include/asm-m32r/ipcbuf.h
--- linux-2.6.30-rc2/include/asm-m32r/ipcbuf.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/ipcbuf.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,29 +0,0 @@
-#ifndef _ASM_M32R_IPCBUF_H
-#define _ASM_M32R_IPCBUF_H
-
-/*
- * The ipc64_perm structure for m32r architecture.
- * Note extra padding because this structure is passed back and forth
- * between kernel and user space.
- *
- * Pad space is left for:
- * - 32-bit mode_t and seq
- * - 2 miscellaneous 32-bit values
- */
-
-struct ipc64_perm
-{
-	__kernel_key_t		key;
-	__kernel_uid32_t	uid;
-	__kernel_gid32_t	gid;
-	__kernel_uid32_t	cuid;
-	__kernel_gid32_t	cgid;
-	__kernel_mode_t		mode;
-	unsigned short		__pad1;
-	unsigned short		seq;
-	unsigned short		__pad2;
-	unsigned long		__unused1;
-	unsigned long		__unused2;
-};
-
-#endif /* _ASM_M32R_IPCBUF_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/irq.h linux-2.6.30-rc3/include/asm-m32r/irq.h
--- linux-2.6.30-rc2/include/asm-m32r/irq.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/irq.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,90 +0,0 @@
-#ifdef __KERNEL__
-#ifndef _ASM_M32R_IRQ_H
-#define _ASM_M32R_IRQ_H
-
-
-#if defined(CONFIG_PLAT_USRV)
-/*
- * IRQ definitions for M32700UT
- *  M32700 Chip: 64 interrupts
- *  ICU of M32700UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
- */
-#define	M32700UT_NUM_CPU_IRQ	(64)
-#define M32700UT_NUM_PLD_IRQ	(32)
-#define M32700UT_IRQ_BASE	0
-#define M32700UT_CPU_IRQ_BASE	M32700UT_IRQ_BASE
-#define M32700UT_PLD_IRQ_BASE	(M32700UT_CPU_IRQ_BASE + M32700UT_NUM_CPU_IRQ)
-
-#define NR_IRQS	(M32700UT_NUM_CPU_IRQ + M32700UT_NUM_PLD_IRQ)
-#elif defined(CONFIG_PLAT_M32700UT)
-/*
- * IRQ definitions for M32700UT(Rev.C) + M32R-LAN
- *  M32700 Chip: 64 interrupts
- *  ICU of M32700UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
- *  ICU of M32R-LCD-on-board PLD: 32 interrupts cascaded to INT2# chip pin
- *  ICU of M32R-LAN-on-board PLD: 32 interrupts cascaded to INT0# chip pin
- */
-#define M32700UT_NUM_CPU_IRQ		(64)
-#define M32700UT_NUM_PLD_IRQ		(32)
-#define M32700UT_NUM_LCD_PLD_IRQ	(32)
-#define M32700UT_NUM_LAN_PLD_IRQ	(32)
-#define M32700UT_IRQ_BASE		0
-#define M32700UT_CPU_IRQ_BASE		(M32700UT_IRQ_BASE)
-#define M32700UT_PLD_IRQ_BASE \
-	(M32700UT_CPU_IRQ_BASE + M32700UT_NUM_CPU_IRQ)
-#define M32700UT_LCD_PLD_IRQ_BASE \
-	(M32700UT_PLD_IRQ_BASE + M32700UT_NUM_PLD_IRQ)
-#define M32700UT_LAN_PLD_IRQ_BASE \
-	(M32700UT_LCD_PLD_IRQ_BASE + M32700UT_NUM_LCD_PLD_IRQ)
-
-#define NR_IRQS \
-	(M32700UT_NUM_CPU_IRQ + M32700UT_NUM_PLD_IRQ \
-	+ M32700UT_NUM_LCD_PLD_IRQ + M32700UT_NUM_LAN_PLD_IRQ)
-#elif defined(CONFIG_PLAT_OPSPUT)
-/*
- * IRQ definitions for OPSPUT + M32R-LAN
- *  OPSP Chip: 64 interrupts
- *  ICU of OPSPUT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
- *  ICU of M32R-LCD-on-board PLD: 32 interrupts cascaded to INT2# chip pin
- *  ICU of M32R-LAN-on-board PLD: 32 interrupts cascaded to INT0# chip pin
- */
-#define OPSPUT_NUM_CPU_IRQ		(64)
-#define OPSPUT_NUM_PLD_IRQ		(32)
-#define OPSPUT_NUM_LCD_PLD_IRQ	(32)
-#define OPSPUT_NUM_LAN_PLD_IRQ	(32)
-#define OPSPUT_IRQ_BASE		0
-#define OPSPUT_CPU_IRQ_BASE		(OPSPUT_IRQ_BASE)
-#define OPSPUT_PLD_IRQ_BASE \
-	(OPSPUT_CPU_IRQ_BASE + OPSPUT_NUM_CPU_IRQ)
-#define OPSPUT_LCD_PLD_IRQ_BASE \
-	(OPSPUT_PLD_IRQ_BASE + OPSPUT_NUM_PLD_IRQ)
-#define OPSPUT_LAN_PLD_IRQ_BASE \
-	(OPSPUT_LCD_PLD_IRQ_BASE + OPSPUT_NUM_LCD_PLD_IRQ)
-
-#define NR_IRQS \
-	(OPSPUT_NUM_CPU_IRQ + OPSPUT_NUM_PLD_IRQ \
-	+ OPSPUT_NUM_LCD_PLD_IRQ + OPSPUT_NUM_LAN_PLD_IRQ)
-
-#elif defined(CONFIG_PLAT_M32104UT)
-/*
- * IRQ definitions for M32104UT
- *  M32104 Chip: 64 interrupts
- *  ICU of M32104UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
- */
-#define	M32104UT_NUM_CPU_IRQ	(64)
-#define M32104UT_NUM_PLD_IRQ	(32)
-#define M32104UT_IRQ_BASE	0
-#define M32104UT_CPU_IRQ_BASE	M32104UT_IRQ_BASE
-#define M32104UT_PLD_IRQ_BASE	(M32104UT_CPU_IRQ_BASE + M32104UT_NUM_CPU_IRQ)
-
-#define NR_IRQS	\
-    (M32104UT_NUM_CPU_IRQ + M32104UT_NUM_PLD_IRQ)
-
-#else
-#define NR_IRQS	64
-#endif
-
-#define irq_canonicalize(irq)	(irq)
-
-#endif /* _ASM_M32R_IRQ_H */
-#endif /* __KERNEL__ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/irq_regs.h linux-2.6.30-rc3/include/asm-m32r/irq_regs.h
--- linux-2.6.30-rc2/include/asm-m32r/irq_regs.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/irq_regs.h	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-#include <asm-generic/irq_regs.h>
diff -urN linux-2.6.30-rc2/include/asm-m32r/kdebug.h linux-2.6.30-rc3/include/asm-m32r/kdebug.h
--- linux-2.6.30-rc2/include/asm-m32r/kdebug.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/kdebug.h	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-#include <asm-generic/kdebug.h>
diff -urN linux-2.6.30-rc2/include/asm-m32r/kmap_types.h linux-2.6.30-rc3/include/asm-m32r/kmap_types.h
--- linux-2.6.30-rc2/include/asm-m32r/kmap_types.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/kmap_types.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,29 +0,0 @@
-#ifndef __M32R_KMAP_TYPES_H
-#define __M32R_KMAP_TYPES_H
-
-#ifdef CONFIG_DEBUG_HIGHMEM
-# define D(n) __KM_FENCE_##n ,
-#else
-# define D(n)
-#endif
-
-enum km_type {
-D(0)	KM_BOUNCE_READ,
-D(1)	KM_SKB_SUNRPC_DATA,
-D(2)	KM_SKB_DATA_SOFTIRQ,
-D(3)	KM_USER0,
-D(4)	KM_USER1,
-D(5)	KM_BIO_SRC_IRQ,
-D(6)	KM_BIO_DST_IRQ,
-D(7)	KM_PTE0,
-D(8)	KM_PTE1,
-D(9)	KM_IRQ0,
-D(10)	KM_IRQ1,
-D(11)	KM_SOFTIRQ0,
-D(12)	KM_SOFTIRQ1,
-D(13)	KM_TYPE_NR
-};
-
-#undef D
-
-#endif /* __M32R_KMAP_TYPES_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/linkage.h linux-2.6.30-rc3/include/asm-m32r/linkage.h
--- linux-2.6.30-rc2/include/asm-m32r/linkage.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/linkage.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-#ifndef __ASM_LINKAGE_H
-#define __ASM_LINKAGE_H
-
-#define __ALIGN		.balign 4
-#define __ALIGN_STR	".balign 4"
-
-#endif /* __ASM_LINKAGE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/local.h linux-2.6.30-rc3/include/asm-m32r/local.h
--- linux-2.6.30-rc2/include/asm-m32r/local.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/local.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,366 +0,0 @@
-#ifndef __M32R_LOCAL_H
-#define __M32R_LOCAL_H
-
-/*
- *  linux/include/asm-m32r/local.h
- *
- *  M32R version:
- *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
- *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- *    Copyright (C) 2007  Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- */
-
-#include <linux/percpu.h>
-#include <asm/assembler.h>
-#include <asm/system.h>
-#include <asm/local.h>
-
-/*
- * Atomic operations that C can't guarantee us.  Useful for
- * resource counting etc..
- */
-
-/*
- * Make sure gcc doesn't try to be clever and move things around
- * on us. We need to use _exactly_ the address the user gave us,
- * not some alias that contains the same information.
- */
-typedef struct { volatile int counter; } local_t;
-
-#define LOCAL_INIT(i)	{ (i) }
-
-/**
- * local_read - read local variable
- * @l: pointer of type local_t
- *
- * Atomically reads the value of @l.
- */
-#define local_read(l)	((l)->counter)
-
-/**
- * local_set - set local variable
- * @l: pointer of type local_t
- * @i: required value
- *
- * Atomically sets the value of @l to @i.
- */
-#define local_set(l, i)	(((l)->counter) = (i))
-
-/**
- * local_add_return - add long to local variable and return it
- * @i: long value to add
- * @l: pointer of type local_t
- *
- * Atomically adds @i to @l and return (@i + @l).
- */
-static inline long local_add_return(long i, local_t *l)
-{
-	unsigned long flags;
-	long result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# local_add_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		"ld %0, @%1;			\n\t"
-		"add	%0, %2;			\n\t"
-		"st %0, @%1;			\n\t"
-		: "=&r" (result)
-		: "r" (&l->counter), "r" (i)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * local_sub_return - subtract long from local variable and return it
- * @i: long value to subtract
- * @l: pointer of type local_t
- *
- * Atomically subtracts @i from @l and return (@l - @i).
- */
-static inline long local_sub_return(long i, local_t *l)
-{
-	unsigned long flags;
-	long result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# local_sub_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		"ld %0, @%1;			\n\t"
-		"sub	%0, %2;			\n\t"
-		"st %0, @%1;			\n\t"
-		: "=&r" (result)
-		: "r" (&l->counter), "r" (i)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * local_add - add long to local variable
- * @i: long value to add
- * @l: pointer of type local_t
- *
- * Atomically adds @i to @l.
- */
-#define local_add(i, l) ((void) local_add_return((i), (l)))
-
-/**
- * local_sub - subtract the local variable
- * @i: long value to subtract
- * @l: pointer of type local_t
- *
- * Atomically subtracts @i from @l.
- */
-#define local_sub(i, l) ((void) local_sub_return((i), (l)))
-
-/**
- * local_sub_and_test - subtract value from variable and test result
- * @i: integer value to subtract
- * @l: pointer of type local_t
- *
- * Atomically subtracts @i from @l and returns
- * true if the result is zero, or false for all
- * other cases.
- */
-#define local_sub_and_test(i, l) (local_sub_return((i), (l)) == 0)
-
-/**
- * local_inc_return - increment local variable and return it
- * @l: pointer of type local_t
- *
- * Atomically increments @l by 1 and returns the result.
- */
-static inline long local_inc_return(local_t *l)
-{
-	unsigned long flags;
-	long result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# local_inc_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		"ld %0, @%1;			\n\t"
-		"addi	%0, #1;			\n\t"
-		"st %0, @%1;			\n\t"
-		: "=&r" (result)
-		: "r" (&l->counter)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * local_dec_return - decrement local variable and return it
- * @l: pointer of type local_t
- *
- * Atomically decrements @l by 1 and returns the result.
- */
-static inline long local_dec_return(local_t *l)
-{
-	unsigned long flags;
-	long result;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# local_dec_return		\n\t"
-		DCACHE_CLEAR("%0", "r4", "%1")
-		"ld %0, @%1;			\n\t"
-		"addi	%0, #-1;		\n\t"
-		"st %0, @%1;			\n\t"
-		: "=&r" (result)
-		: "r" (&l->counter)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-
-	return result;
-}
-
-/**
- * local_inc - increment local variable
- * @l: pointer of type local_t
- *
- * Atomically increments @l by 1.
- */
-#define local_inc(l) ((void)local_inc_return(l))
-
-/**
- * local_dec - decrement local variable
- * @l: pointer of type local_t
- *
- * Atomically decrements @l by 1.
- */
-#define local_dec(l) ((void)local_dec_return(l))
-
-/**
- * local_inc_and_test - increment and test
- * @l: pointer of type local_t
- *
- * Atomically increments @l by 1
- * and returns true if the result is zero, or false for all
- * other cases.
- */
-#define local_inc_and_test(l) (local_inc_return(l) == 0)
-
-/**
- * local_dec_and_test - decrement and test
- * @l: pointer of type local_t
- *
- * Atomically decrements @l by 1 and
- * returns true if the result is 0, or false for all
- * other cases.
- */
-#define local_dec_and_test(l) (local_dec_return(l) == 0)
-
-/**
- * local_add_negative - add and test if negative
- * @l: pointer of type local_t
- * @i: integer value to add
- *
- * Atomically adds @i to @l and returns true
- * if the result is negative, or false when
- * result is greater than or equal to zero.
- */
-#define local_add_negative(i, l) (local_add_return((i), (l)) < 0)
-
-#define local_cmpxchg(l, o, n) (cmpxchg_local(&((l)->counter), (o), (n)))
-#define local_xchg(v, new) (xchg_local(&((l)->counter), new))
-
-/**
- * local_add_unless - add unless the number is a given value
- * @l: pointer of type local_t
- * @a: the amount to add to l...
- * @u: ...unless l is equal to u.
- *
- * Atomically adds @a to @l, so long as it was not @u.
- * Returns non-zero if @l was not @u, and zero otherwise.
- */
-static inline int local_add_unless(local_t *l, long a, long u)
-{
-	long c, old;
-	c = local_read(l);
-	for (;;) {
-		if (unlikely(c == (u)))
-			break;
-		old = local_cmpxchg((l), c, c + (a));
-		if (likely(old == c))
-			break;
-		c = old;
-	}
-	return c != (u);
-}
-
-#define local_inc_not_zero(l) local_add_unless((l), 1, 0)
-
-static inline void local_clear_mask(unsigned long  mask, local_t *addr)
-{
-	unsigned long flags;
-	unsigned long tmp;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# local_clear_mask		\n\t"
-		DCACHE_CLEAR("%0", "r5", "%1")
-		"ld %0, @%1;			\n\t"
-		"and	%0, %2;			\n\t"
-		"st %0, @%1;			\n\t"
-		: "=&r" (tmp)
-		: "r" (addr), "r" (~mask)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r5"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-}
-
-static inline void local_set_mask(unsigned long  mask, local_t *addr)
-{
-	unsigned long flags;
-	unsigned long tmp;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-		"# local_set_mask		\n\t"
-		DCACHE_CLEAR("%0", "r5", "%1")
-		"ld %0, @%1;			\n\t"
-		"or	%0, %2;			\n\t"
-		"st %0, @%1;			\n\t"
-		: "=&r" (tmp)
-		: "r" (addr), "r" (mask)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r5"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-	local_irq_restore(flags);
-}
-
-/* Atomic operations are already serializing on m32r */
-#define smp_mb__before_local_dec()	barrier()
-#define smp_mb__after_local_dec()	barrier()
-#define smp_mb__before_local_inc()	barrier()
-#define smp_mb__after_local_inc()	barrier()
-
-/* Use these for per-cpu local_t variables: on some archs they are
- * much more efficient than these naive implementations.  Note they take
- * a variable, not an address.
- */
-
-#define __local_inc(l)		((l)->a.counter++)
-#define __local_dec(l)		((l)->a.counter++)
-#define __local_add(i, l)	((l)->a.counter += (i))
-#define __local_sub(i, l)	((l)->a.counter -= (i))
-
-/* Use these for per-cpu local_t variables: on some archs they are
- * much more efficient than these naive implementations.  Note they take
- * a variable, not an address.
- */
-
-/* Need to disable preemption for the cpu local counters otherwise we could
-   still access a variable of a previous CPU in a non local way. */
-#define cpu_local_wrap_v(l)	 	\
-	({ local_t res__;		\
-	   preempt_disable(); 		\
-	   res__ = (l);			\
-	   preempt_enable();		\
-	   res__; })
-#define cpu_local_wrap(l)		\
-	({ preempt_disable();		\
-	   l;				\
-	   preempt_enable(); })		\
-
-#define cpu_local_read(l)    cpu_local_wrap_v(local_read(&__get_cpu_var(l)))
-#define cpu_local_set(l, i)  cpu_local_wrap(local_set(&__get_cpu_var(l), (i)))
-#define cpu_local_inc(l)     cpu_local_wrap(local_inc(&__get_cpu_var(l)))
-#define cpu_local_dec(l)     cpu_local_wrap(local_dec(&__get_cpu_var(l)))
-#define cpu_local_add(i, l)  cpu_local_wrap(local_add((i), &__get_cpu_var(l)))
-#define cpu_local_sub(i, l)  cpu_local_wrap(local_sub((i), &__get_cpu_var(l)))
-
-#define __cpu_local_inc(l)	cpu_local_inc(l)
-#define __cpu_local_dec(l)	cpu_local_dec(l)
-#define __cpu_local_add(i, l)	cpu_local_add((i), (l))
-#define __cpu_local_sub(i, l)	cpu_local_sub((i), (l))
-
-#endif /* __M32R_LOCAL_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/m32102.h linux-2.6.30-rc3/include/asm-m32r/m32102.h
--- linux-2.6.30-rc2/include/asm-m32r/m32102.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/m32102.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,314 +0,0 @@
-#ifndef _M32102_H_
-#define _M32102_H_
-
-/*
- * Renesas M32R 32102 group
- *
- * Copyright (c) 2001  Hitoshi Yamamoto
- * Copyright (c) 2003, 2004  Renesas Technology Corp.
- */
-
-/*======================================================================*
- * Special Function Register
- *======================================================================*/
-#if !defined(CONFIG_CHIP_M32104)
-#define M32R_SFR_OFFSET  (0x00E00000)  /* 0x00E00000-0x00EFFFFF 1[MB] */
-#else
-#define M32R_SFR_OFFSET  (0x00700000)  /* 0x00700000-0x007FFFFF 1[MB] */
-#endif
-
-/*
- * Clock and Power Management registers.
- */
-#define M32R_CPM_OFFSET          (0x000F4000+M32R_SFR_OFFSET)
-
-#define M32R_CPM_CPUCLKCR_PORTL  (0x00+M32R_CPM_OFFSET)
-#define M32R_CPM_CLKMOD_PORTL    (0x04+M32R_CPM_OFFSET)
-#define M32R_CPM_PLLCR_PORTL     (0x08+M32R_CPM_OFFSET)
-
-/*
- * DMA Controller registers.
- */
-#define M32R_DMA_OFFSET		(0x000F8000+M32R_SFR_OFFSET)
-
-#define M32R_DMAEN_PORTL	(0x000+M32R_DMA_OFFSET)
-#define M32R_DMAISTS_PORTL	(0x004+M32R_DMA_OFFSET)
-#define M32R_DMAEDET_PORTL	(0x008+M32R_DMA_OFFSET)
-#define M32R_DMAASTS_PORTL	(0x00c+M32R_DMA_OFFSET)
-
-#define M32R_DMA0CR0_PORTL	(0x100+M32R_DMA_OFFSET)
-#define M32R_DMA0CR1_PORTL	(0x104+M32R_DMA_OFFSET)
-#define M32R_DMA0CSA_PORTL	(0x108+M32R_DMA_OFFSET)
-#define M32R_DMA0RSA_PORTL	(0x10c+M32R_DMA_OFFSET)
-#define M32R_DMA0CDA_PORTL	(0x110+M32R_DMA_OFFSET)
-#define M32R_DMA0RDA_PORTL	(0x114+M32R_DMA_OFFSET)
-#define M32R_DMA0CBCUT_PORTL	(0x118+M32R_DMA_OFFSET)
-#define M32R_DMA0RBCUT_PORTL	(0x11c+M32R_DMA_OFFSET)
-
-#define M32R_DMA1CR0_PORTL	(0x200+M32R_DMA_OFFSET)
-#define M32R_DMA1CR1_PORTL	(0x204+M32R_DMA_OFFSET)
-#define M32R_DMA1CSA_PORTL	(0x208+M32R_DMA_OFFSET)
-#define M32R_DMA1RSA_PORTL	(0x20c+M32R_DMA_OFFSET)
-#define M32R_DMA1CDA_PORTL	(0x210+M32R_DMA_OFFSET)
-#define M32R_DMA1RDA_PORTL	(0x214+M32R_DMA_OFFSET)
-#define M32R_DMA1CBCUT_PORTL	(0x218+M32R_DMA_OFFSET)
-#define M32R_DMA1RBCUT_PORTL	(0x21c+M32R_DMA_OFFSET)
-
-/*
- * Multi Function Timer registers.
- */
-#define M32R_MFT_OFFSET        (0x000FC000+M32R_SFR_OFFSET)
-
-#define M32R_MFTCR_PORTL       (0x000+M32R_MFT_OFFSET)  /* MFT control */
-#define M32R_MFTRPR_PORTL      (0x004+M32R_MFT_OFFSET)  /* MFT real port */
-
-#define M32R_MFT0_OFFSET       (0x100+M32R_MFT_OFFSET)
-#define M32R_MFT0MOD_PORTL     (0x00+M32R_MFT0_OFFSET)  /* MFT0 mode */
-#define M32R_MFT0BOS_PORTL     (0x04+M32R_MFT0_OFFSET)  /* MFT0 b-port output status */
-#define M32R_MFT0CUT_PORTL     (0x08+M32R_MFT0_OFFSET)  /* MFT0 count */
-#define M32R_MFT0RLD_PORTL     (0x0C+M32R_MFT0_OFFSET)  /* MFT0 reload */
-#define M32R_MFT0CMPRLD_PORTL  (0x10+M32R_MFT0_OFFSET)  /* MFT0 compare reload */
-
-#define M32R_MFT1_OFFSET       (0x200+M32R_MFT_OFFSET)
-#define M32R_MFT1MOD_PORTL     (0x00+M32R_MFT1_OFFSET)  /* MFT1 mode */
-#define M32R_MFT1BOS_PORTL     (0x04+M32R_MFT1_OFFSET)  /* MFT1 b-port output status */
-#define M32R_MFT1CUT_PORTL     (0x08+M32R_MFT1_OFFSET)  /* MFT1 count */
-#define M32R_MFT1RLD_PORTL     (0x0C+M32R_MFT1_OFFSET)  /* MFT1 reload */
-#define M32R_MFT1CMPRLD_PORTL  (0x10+M32R_MFT1_OFFSET)  /* MFT1 compare reload */
-
-#define M32R_MFT2_OFFSET       (0x300+M32R_MFT_OFFSET)
-#define M32R_MFT2MOD_PORTL     (0x00+M32R_MFT2_OFFSET)  /* MFT2 mode */
-#define M32R_MFT2BOS_PORTL     (0x04+M32R_MFT2_OFFSET)  /* MFT2 b-port output status */
-#define M32R_MFT2CUT_PORTL     (0x08+M32R_MFT2_OFFSET)  /* MFT2 count */
-#define M32R_MFT2RLD_PORTL     (0x0C+M32R_MFT2_OFFSET)  /* MFT2 reload */
-#define M32R_MFT2CMPRLD_PORTL  (0x10+M32R_MFT2_OFFSET)  /* MFT2 compare reload */
-
-#define M32R_MFT3_OFFSET       (0x400+M32R_MFT_OFFSET)
-#define M32R_MFT3MOD_PORTL     (0x00+M32R_MFT3_OFFSET)  /* MFT3 mode */
-#define M32R_MFT3BOS_PORTL     (0x04+M32R_MFT3_OFFSET)  /* MFT3 b-port output status */
-#define M32R_MFT3CUT_PORTL     (0x08+M32R_MFT3_OFFSET)  /* MFT3 count */
-#define M32R_MFT3RLD_PORTL     (0x0C+M32R_MFT3_OFFSET)  /* MFT3 reload */
-#define M32R_MFT3CMPRLD_PORTL  (0x10+M32R_MFT3_OFFSET)  /* MFT3 compare reload */
-
-#define M32R_MFT4_OFFSET       (0x500+M32R_MFT_OFFSET)
-#define M32R_MFT4MOD_PORTL     (0x00+M32R_MFT4_OFFSET)  /* MFT4 mode */
-#define M32R_MFT4BOS_PORTL     (0x04+M32R_MFT4_OFFSET)  /* MFT4 b-port output status */
-#define M32R_MFT4CUT_PORTL     (0x08+M32R_MFT4_OFFSET)  /* MFT4 count */
-#define M32R_MFT4RLD_PORTL     (0x0C+M32R_MFT4_OFFSET)  /* MFT4 reload */
-#define M32R_MFT4CMPRLD_PORTL  (0x10+M32R_MFT4_OFFSET)  /* MFT4 compare reload */
-
-#define M32R_MFT5_OFFSET       (0x600+M32R_MFT_OFFSET)
-#define M32R_MFT5MOD_PORTL     (0x00+M32R_MFT5_OFFSET)  /* MFT4 mode */
-#define M32R_MFT5BOS_PORTL     (0x04+M32R_MFT5_OFFSET)  /* MFT4 b-port output status */
-#define M32R_MFT5CUT_PORTL     (0x08+M32R_MFT5_OFFSET)  /* MFT4 count */
-#define M32R_MFT5RLD_PORTL     (0x0C+M32R_MFT5_OFFSET)  /* MFT4 reload */
-#define M32R_MFT5CMPRLD_PORTL  (0x10+M32R_MFT5_OFFSET)  /* MFT4 compare reload */
-
-#if (defined(CONFIG_CHIP_M32700) && !defined(CONFIG_PLAT_MAPPI2)) \
-	|| defined(CONFIG_CHIP_M32104)
-#define M32R_MFTCR_MFT0MSK  (1UL<<31)  /* b0 */
-#define M32R_MFTCR_MFT1MSK  (1UL<<30)  /* b1 */
-#define M32R_MFTCR_MFT2MSK  (1UL<<29)  /* b2 */
-#define M32R_MFTCR_MFT3MSK  (1UL<<28)  /* b3 */
-#define M32R_MFTCR_MFT4MSK  (1UL<<27)  /* b4 */
-#define M32R_MFTCR_MFT5MSK  (1UL<<26)  /* b5 */
-#define M32R_MFTCR_MFT0EN   (1UL<<23)  /* b8 */
-#define M32R_MFTCR_MFT1EN   (1UL<<22)  /* b9 */
-#define M32R_MFTCR_MFT2EN   (1UL<<21)  /* b10 */
-#define M32R_MFTCR_MFT3EN   (1UL<<20)  /* b11 */
-#define M32R_MFTCR_MFT4EN   (1UL<<19)  /* b12 */
-#define M32R_MFTCR_MFT5EN   (1UL<<18)  /* b13 */
-#else
-#define M32R_MFTCR_MFT0MSK  (1UL<<15)  /* b16 */
-#define M32R_MFTCR_MFT1MSK  (1UL<<14)  /* b17 */
-#define M32R_MFTCR_MFT2MSK  (1UL<<13)  /* b18 */
-#define M32R_MFTCR_MFT3MSK  (1UL<<12)  /* b19 */
-#define M32R_MFTCR_MFT4MSK  (1UL<<11)  /* b20 */
-#define M32R_MFTCR_MFT5MSK  (1UL<<10)  /* b21 */
-#define M32R_MFTCR_MFT0EN   (1UL<<7)   /* b24 */
-#define M32R_MFTCR_MFT1EN   (1UL<<6)   /* b25 */
-#define M32R_MFTCR_MFT2EN   (1UL<<5)   /* b26 */
-#define M32R_MFTCR_MFT3EN   (1UL<<4)   /* b27 */
-#define M32R_MFTCR_MFT4EN   (1UL<<3)   /* b28 */
-#define M32R_MFTCR_MFT5EN   (1UL<<2)   /* b29 */
-#endif
-
-#define M32R_MFTMOD_CC_MASK    (1UL<<15)  /* b16 */
-#define M32R_MFTMOD_TCCR       (1UL<<13)  /* b18 */
-#define M32R_MFTMOD_GTSEL000   (0UL<<8)   /* b21-23 : 000 */
-#define M32R_MFTMOD_GTSEL001   (1UL<<8)   /* b21-23 : 001 */
-#define M32R_MFTMOD_GTSEL010   (2UL<<8)   /* b21-23 : 010 */
-#define M32R_MFTMOD_GTSEL011   (3UL<<8)   /* b21-23 : 011 */
-#define M32R_MFTMOD_GTSEL110   (6UL<<8)   /* b21-23 : 110 */
-#define M32R_MFTMOD_GTSEL111   (7UL<<8)   /* b21-23 : 111 */
-#define M32R_MFTMOD_CMSEL      (1UL<<3)   /* b28 */
-#define M32R_MFTMOD_CSSEL000   (0UL<<0)   /* b29-b31 : 000 */
-#define M32R_MFTMOD_CSSEL001   (1UL<<0)   /* b29-b31 : 001 */
-#define M32R_MFTMOD_CSSEL010   (2UL<<0)   /* b29-b31 : 010 */
-#define M32R_MFTMOD_CSSEL011   (3UL<<0)   /* b29-b31 : 011 */
-#define M32R_MFTMOD_CSSEL100   (4UL<<0)   /* b29-b31 : 100 */
-#define M32R_MFTMOD_CSSEL110   (6UL<<0)   /* b29-b31 : 110 */
-
-/*
- * Serial I/O registers.
- */
-#define M32R_SIO_OFFSET  (0x000FD000+M32R_SFR_OFFSET)
-
-#define M32R_SIO0_CR_PORTL    (0x000+M32R_SIO_OFFSET)
-#define M32R_SIO0_MOD0_PORTL  (0x004+M32R_SIO_OFFSET)
-#define M32R_SIO0_MOD1_PORTL  (0x008+M32R_SIO_OFFSET)
-#define M32R_SIO0_STS_PORTL   (0x00C+M32R_SIO_OFFSET)
-#define M32R_SIO0_TRCR_PORTL  (0x010+M32R_SIO_OFFSET)
-#define M32R_SIO0_BAUR_PORTL  (0x014+M32R_SIO_OFFSET)
-#define M32R_SIO0_RBAUR_PORTL (0x018+M32R_SIO_OFFSET)
-#define M32R_SIO0_TXB_PORTL   (0x01C+M32R_SIO_OFFSET)
-#define M32R_SIO0_RXB_PORTL   (0x020+M32R_SIO_OFFSET)
-
-/*
- * Interrupt Control Unit registers.
- */
-#define M32R_ICU_OFFSET       (0x000FF000+M32R_SFR_OFFSET)
-#define M32R_ICU_ISTS_PORTL   (0x004+M32R_ICU_OFFSET)
-#define M32R_ICU_IREQ0_PORTL  (0x008+M32R_ICU_OFFSET)
-#define M32R_ICU_IREQ1_PORTL  (0x00C+M32R_ICU_OFFSET)
-#define M32R_ICU_SBICR_PORTL  (0x018+M32R_ICU_OFFSET)
-#define M32R_ICU_IMASK_PORTL  (0x01C+M32R_ICU_OFFSET)
-#define M32R_ICU_CR1_PORTL    (0x200+M32R_ICU_OFFSET)  /* INT0 */
-#define M32R_ICU_CR2_PORTL    (0x204+M32R_ICU_OFFSET)  /* INT1 */
-#define M32R_ICU_CR3_PORTL    (0x208+M32R_ICU_OFFSET)  /* INT2 */
-#define M32R_ICU_CR4_PORTL    (0x20C+M32R_ICU_OFFSET)  /* INT3 */
-#define M32R_ICU_CR5_PORTL    (0x210+M32R_ICU_OFFSET)  /* INT4 */
-#define M32R_ICU_CR6_PORTL    (0x214+M32R_ICU_OFFSET)  /* INT5 */
-#define M32R_ICU_CR7_PORTL    (0x218+M32R_ICU_OFFSET)  /* INT6 */
-#define M32R_ICU_CR8_PORTL    (0x219+M32R_ICU_OFFSET)  /* INT7 */
-#define M32R_ICU_CR16_PORTL   (0x23C+M32R_ICU_OFFSET)  /* MFT0 */
-#define M32R_ICU_CR17_PORTL   (0x240+M32R_ICU_OFFSET)  /* MFT1 */
-#define M32R_ICU_CR18_PORTL   (0x244+M32R_ICU_OFFSET)  /* MFT2 */
-#define M32R_ICU_CR19_PORTL   (0x248+M32R_ICU_OFFSET)  /* MFT3 */
-#define M32R_ICU_CR20_PORTL   (0x24C+M32R_ICU_OFFSET)  /* MFT4 */
-#define M32R_ICU_CR21_PORTL   (0x250+M32R_ICU_OFFSET)  /* MFT5 */
-#define M32R_ICU_CR32_PORTL   (0x27C+M32R_ICU_OFFSET)  /* DMA0 */
-#define M32R_ICU_CR33_PORTL   (0x280+M32R_ICU_OFFSET)  /* DMA1 */
-#define M32R_ICU_CR48_PORTL   (0x2BC+M32R_ICU_OFFSET)  /* SIO0 */
-#define M32R_ICU_CR49_PORTL   (0x2C0+M32R_ICU_OFFSET)  /* SIO0 */
-#define M32R_ICU_CR50_PORTL   (0x2C4+M32R_ICU_OFFSET)  /* SIO1 */
-#define M32R_ICU_CR51_PORTL   (0x2C8+M32R_ICU_OFFSET)  /* SIO1 */
-#define M32R_ICU_CR52_PORTL   (0x2CC+M32R_ICU_OFFSET)  /* SIO2 */
-#define M32R_ICU_CR53_PORTL   (0x2D0+M32R_ICU_OFFSET)  /* SIO2 */
-#define M32R_ICU_CR54_PORTL   (0x2D4+M32R_ICU_OFFSET)  /* SIO3 */
-#define M32R_ICU_CR55_PORTL   (0x2D8+M32R_ICU_OFFSET)  /* SIO3 */
-#define M32R_ICU_CR56_PORTL   (0x2DC+M32R_ICU_OFFSET)  /* SIO4 */
-#define M32R_ICU_CR57_PORTL   (0x2E0+M32R_ICU_OFFSET)  /* SIO4 */
-
-#ifdef CONFIG_SMP
-#define M32R_ICU_IPICR0_PORTL (0x2dc+M32R_ICU_OFFSET)  /* IPI0 */
-#define M32R_ICU_IPICR1_PORTL (0x2e0+M32R_ICU_OFFSET)  /* IPI1 */
-#define M32R_ICU_IPICR2_PORTL (0x2e4+M32R_ICU_OFFSET)  /* IPI2 */
-#define M32R_ICU_IPICR3_PORTL (0x2e8+M32R_ICU_OFFSET)  /* IPI3 */
-#define M32R_ICU_IPICR4_PORTL (0x2ec+M32R_ICU_OFFSET)  /* IPI4 */
-#define M32R_ICU_IPICR5_PORTL (0x2f0+M32R_ICU_OFFSET)  /* IPI5 */
-#define M32R_ICU_IPICR6_PORTL (0x2f4+M32R_ICU_OFFSET)  /* IPI6 */
-#define M32R_ICU_IPICR7_PORTL (0x2f8+M32R_ICU_OFFSET)  /* IPI7 */
-#endif /* CONFIG_SMP */
-
-#define M32R_ICUIMASK_IMSK0  (0UL<<16)  /* b13-b15: Disable interrupt */
-#define M32R_ICUIMASK_IMSK1  (1UL<<16)  /* b13-b15: Enable level 0 interrupt */
-#define M32R_ICUIMASK_IMSK2  (2UL<<16)  /* b13-b15: Enable level 0,1 interrupt */
-#define M32R_ICUIMASK_IMSK3  (3UL<<16)  /* b13-b15: Enable level 0-2 interrupt */
-#define M32R_ICUIMASK_IMSK4  (4UL<<16)  /* b13-b15: Enable level 0-3 interrupt */
-#define M32R_ICUIMASK_IMSK5  (5UL<<16)  /* b13-b15: Enable level 0-4 interrupt */
-#define M32R_ICUIMASK_IMSK6  (6UL<<16)  /* b13-b15: Enable level 0-5 interrupt */
-#define M32R_ICUIMASK_IMSK7  (7UL<<16)  /* b13-b15: Enable level 0-6 interrupt */
-
-#define M32R_ICUCR_IEN      (1UL<<12)  /* b19: Interrupt enable */
-#define M32R_ICUCR_IRQ      (1UL<<8)   /* b23: Interrupt request */
-#define M32R_ICUCR_ISMOD00  (0UL<<4)   /* b26-b27: Interrupt sense mode Edge HtoL */
-#define M32R_ICUCR_ISMOD01  (1UL<<4)   /* b26-b27: Interrupt sense mode Level L */
-#define M32R_ICUCR_ISMOD10  (2UL<<4)   /* b26-b27: Interrupt sense mode Edge LtoH*/
-#define M32R_ICUCR_ISMOD11  (3UL<<4)   /* b26-b27: Interrupt sense mode Level H */
-#define M32R_ICUCR_ILEVEL0  (0UL<<0)   /* b29-b31: Interrupt priority level 0 */
-#define M32R_ICUCR_ILEVEL1  (1UL<<0)   /* b29-b31: Interrupt priority level 1 */
-#define M32R_ICUCR_ILEVEL2  (2UL<<0)   /* b29-b31: Interrupt priority level 2 */
-#define M32R_ICUCR_ILEVEL3  (3UL<<0)   /* b29-b31: Interrupt priority level 3 */
-#define M32R_ICUCR_ILEVEL4  (4UL<<0)   /* b29-b31: Interrupt priority level 4 */
-#define M32R_ICUCR_ILEVEL5  (5UL<<0)   /* b29-b31: Interrupt priority level 5 */
-#define M32R_ICUCR_ILEVEL6  (6UL<<0)   /* b29-b31: Interrupt priority level 6 */
-#define M32R_ICUCR_ILEVEL7  (7UL<<0)   /* b29-b31: Disable interrupt */
-
-#define M32R_IRQ_INT0    (1)   /* INT0 */
-#define M32R_IRQ_INT1    (2)   /* INT1 */
-#define M32R_IRQ_INT2    (3)   /* INT2 */
-#define M32R_IRQ_INT3    (4)   /* INT3 */
-#define M32R_IRQ_INT4    (5)   /* INT4 */
-#define M32R_IRQ_INT5    (6)   /* INT5 */
-#define M32R_IRQ_INT6    (7)   /* INT6 */
-#define M32R_IRQ_MFT0    (16)  /* MFT0 */
-#define M32R_IRQ_MFT1    (17)  /* MFT1 */
-#define M32R_IRQ_MFT2    (18)  /* MFT2 */
-#define M32R_IRQ_MFT3    (19)  /* MFT3 */
-#ifdef CONFIG_CHIP_M32104
-#define M32R_IRQ_MFTX0   (24)  /* MFTX0 */
-#define M32R_IRQ_MFTX1   (25)  /* MFTX1 */
-#define M32R_IRQ_DMA0    (32)  /* DMA0 */
-#define M32R_IRQ_DMA1    (33)  /* DMA1 */
-#define M32R_IRQ_DMA2    (34)  /* DMA2 */
-#define M32R_IRQ_DMA3    (35)  /* DMA3 */
-#define M32R_IRQ_SIO0_R  (40)  /* SIO0 send    */
-#define M32R_IRQ_SIO0_S  (41)  /* SIO0 receive */
-#define M32R_IRQ_SIO1_R  (42)  /* SIO1 send    */
-#define M32R_IRQ_SIO1_S  (43)  /* SIO1 receive */
-#define M32R_IRQ_SIO2_R  (44)  /* SIO2 send    */
-#define M32R_IRQ_SIO2_S  (45)  /* SIO2 receive */
-#define M32R_IRQ_SIO3_R  (46)  /* SIO3 send    */
-#define M32R_IRQ_SIO3_S  (47)  /* SIO3 receive */
-#define M32R_IRQ_ADC     (56)  /* ADC */
-#define M32R_IRQ_PC      (57)  /* PC */
-#else /* ! M32104 */
-#define M32R_IRQ_DMA0    (32)  /* DMA0 */
-#define M32R_IRQ_DMA1    (33)  /* DMA1 */
-#define M32R_IRQ_SIO0_R  (48)  /* SIO0 send    */
-#define M32R_IRQ_SIO0_S  (49)  /* SIO0 receive */
-#define M32R_IRQ_SIO1_R  (50)  /* SIO1 send    */
-#define M32R_IRQ_SIO1_S  (51)  /* SIO1 receive */
-#define M32R_IRQ_SIO2_R  (52)  /* SIO2 send    */
-#define M32R_IRQ_SIO2_S  (53)  /* SIO2 receive */
-#define M32R_IRQ_SIO3_R  (54)  /* SIO3 send    */
-#define M32R_IRQ_SIO3_S  (55)  /* SIO3 receive */
-#define M32R_IRQ_SIO4_R  (56)  /* SIO4 send    */
-#define M32R_IRQ_SIO4_S  (57)  /* SIO4 receive */
-#endif /* ! M32104 */
-
-#ifdef CONFIG_SMP
-#define M32R_IRQ_IPI0    (56)
-#define M32R_IRQ_IPI1    (57)
-#define M32R_IRQ_IPI2    (58)
-#define M32R_IRQ_IPI3    (59)
-#define M32R_IRQ_IPI4    (60)
-#define M32R_IRQ_IPI5    (61)
-#define M32R_IRQ_IPI6    (62)
-#define M32R_IRQ_IPI7    (63)
-#define M32R_CPUID_PORTL (0xffffffe0)
-
-#define M32R_FPGA_TOP (0x000F0000+M32R_SFR_OFFSET)
-
-#define M32R_FPGA_NUM_OF_CPUS_PORTL (0x00+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME0_PORTL   (0x10+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME1_PORTL   (0x14+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME2_PORTL   (0x18+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME3_PORTL   (0x1c+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID0_PORTL   (0x20+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID1_PORTL   (0x24+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID2_PORTL   (0x28+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID3_PORTL   (0x2c+M32R_FPGA_TOP)
-#define M32R_FPGA_VERSION0_PORTL    (0x30+M32R_FPGA_TOP)
-#define M32R_FPGA_VERSION1_PORTL    (0x34+M32R_FPGA_TOP)
-
-#endif /* CONFIG_SMP */
-
-#ifndef __ASSEMBLY__
-typedef struct {
-	unsigned long icucr;	/* ICU Control Register */
-} icu_data_t;
-#endif
-
-#endif /* _M32102_H_ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/m32104ut/m32104ut_pld.h linux-2.6.30-rc3/include/asm-m32r/m32104ut/m32104ut_pld.h
--- linux-2.6.30-rc2/include/asm-m32r/m32104ut/m32104ut_pld.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/m32104ut/m32104ut_pld.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,161 +0,0 @@
-#ifndef _M32104UT_M32104UT_PLD_H
-#define _M32104UT_M32104UT_PLD_H
-
-/*
- * include/asm-m32r/m32104ut/m32104ut_pld.h
- *
- * Definitions for Programable Logic Device(PLD) on M32104UT board.
- * Based on m32700ut_pld.h
- *
- * Copyright (c) 2002	Takeo Takahashi
- * Copyright (c) 2005	Naoto Sugai
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#if defined(CONFIG_PLAT_M32104UT)
-#define PLD_PLAT_BASE		0x02c00000
-#else
-#error "no platform configuration"
-#endif
-
-#ifndef __ASSEMBLY__
-/*
- * C functions use non-cache address.
- */
-#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
-#define __reg8			(volatile unsigned char *)
-#define __reg16			(volatile unsigned short *)
-#define __reg32			(volatile unsigned int *)
-#else
-#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
-#define __reg8
-#define __reg16
-#define __reg32
-#endif /* __ASSEMBLY__ */
-
-/* CFC */
-#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
-#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
-#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
-#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
-
-/* MMC */
-#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
-#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
-#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
-#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
-#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
-#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
-#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
-#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
-#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
-#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
-#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
-#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
-
-/* ICU
- *  ICUISTS:	status register
- *  ICUIREQ0: 	request register
- *  ICUIREQ1: 	request register
- *  ICUCR3:	control register for CFIREQ# interrupt
- *  ICUCR4:	control register for CFC Card insert interrupt
- *  ICUCR5:	control register for CFC Card eject interrupt
- *  ICUCR6:	control register for external interrupt
- *  ICUCR11:	control register for MMC Card insert/eject interrupt
- *  ICUCR13:	control register for SC error interrupt
- *  ICUCR14:	control register for SC receive interrupt
- *  ICUCR15:	control register for SC send interrupt
- */
-
-#define PLD_IRQ_INT0		(M32104UT_PLD_IRQ_BASE + 0)	/* None */
-#define PLD_IRQ_CFIREQ		(M32104UT_PLD_IRQ_BASE + 3)	/* CF IREQ */
-#define PLD_IRQ_CFC_INSERT	(M32104UT_PLD_IRQ_BASE + 4)	/* CF Insert */
-#define PLD_IRQ_CFC_EJECT	(M32104UT_PLD_IRQ_BASE + 5)	/* CF Eject */
-#define PLD_IRQ_EXINT		(M32104UT_PLD_IRQ_BASE + 6)	/* EXINT */
-#define PLD_IRQ_MMCCARD		(M32104UT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
-#define PLD_IRQ_SC_ERROR	(M32104UT_PLD_IRQ_BASE + 13)	/* SC error */
-#define PLD_IRQ_SC_RCV		(M32104UT_PLD_IRQ_BASE + 14)	/* SC receive */
-#define PLD_IRQ_SC_SND		(M32104UT_PLD_IRQ_BASE + 15)	/* SC send */
-
-#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
-#define PLD_ICUISTS_VECB_MASK	(0xf000)
-#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
-#define PLD_ICUISTS_ISN_MASK	(0x07c0)
-#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
-#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
-#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
-#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
-#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
-#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
-#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
-#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
-#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
-#define PLD_ICUCR_IEN		(0x1000)
-#define PLD_ICUCR_IREQ		(0x0100)
-#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
-#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
-#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
-#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
-#define PLD_ICUCR_ILEVEL0	(0x0000)
-#define PLD_ICUCR_ILEVEL1	(0x0001)
-#define PLD_ICUCR_ILEVEL2	(0x0002)
-#define PLD_ICUCR_ILEVEL3	(0x0003)
-#define PLD_ICUCR_ILEVEL4	(0x0004)
-#define PLD_ICUCR_ILEVEL5	(0x0005)
-#define PLD_ICUCR_ILEVEL6	(0x0006)
-#define PLD_ICUCR_ILEVEL7	(0x0007)
-
-/* Power Control of MMC and CF */
-#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
-#define PLD_CPCR_CDP		0x0001
-
-/* LED Control
- *
- * 1: DIP swich side
- * 2: Reset switch side
- */
-#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
-#define PLD_IOLED_1_ON		0x001
-#define PLD_IOLED_1_OFF		0x000
-#define PLD_IOLED_2_ON		0x002
-#define PLD_IOLED_2_OFF		0x000
-
-/* DIP Switch
- *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
- *  1: -
- *  2: -
- *  3: -
- */
-#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
-#define	PLD_IOSWSTS_IOSW2	0x0200
-#define	PLD_IOSWSTS_IOSW1	0x0100
-#define	PLD_IOSWSTS_IOWP0	0x0001
-
-/* CRC */
-#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
-#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
-#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
-#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
-#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
-#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
-
-/* RTC */
-#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
-#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
-#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
-#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
-#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
-
-/* SIM Card */
-#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
-#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
-#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
-#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
-#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
-#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
-#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
-
-#endif /* _M32104UT_M32104UT_PLD_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/m32700ut/m32700ut_lan.h linux-2.6.30-rc3/include/asm-m32r/m32700ut/m32700ut_lan.h
--- linux-2.6.30-rc2/include/asm-m32r/m32700ut/m32700ut_lan.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/m32700ut/m32700ut_lan.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,103 +0,0 @@
-#ifndef _M32700UT_M32700UT_LAN_H
-#define _M32700UT_M32700UT_LAN_H
-
-/*
- * include/asm-m32r/m32700ut/m32700ut_lan.h
- *
- * M32700UT-LAN board
- *
- * Copyright (c) 2002	Takeo Takahashi
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#ifndef __ASSEMBLY__
-/*
- * C functions use non-cache address.
- */
-#define M32700UT_LAN_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
-#else
-#define M32700UT_LAN_BASE	(0x10000000 + NONCACHE_OFFSET)
-#endif /* __ASSEMBLY__ */
-
-/* ICU
- *  ICUISTS:	status register
- *  ICUIREQ0: 	request register
- *  ICUIREQ1: 	request register
- *  ICUCR3:	control register for CFIREQ# interrupt
- *  ICUCR4:	control register for CFC Card insert interrupt
- *  ICUCR5:	control register for CFC Card eject interrupt
- *  ICUCR6:	control register for external interrupt
- *  ICUCR11:	control register for MMC Card insert/eject interrupt
- *  ICUCR13:	control register for SC error interrupt
- *  ICUCR14:	control register for SC receive interrupt
- *  ICUCR15:	control register for SC send interrupt
- *  ICUCR16:	control register for SIO0 receive interrupt
- *  ICUCR17:	control register for SIO0 send interrupt
- */
-#define M32700UT_LAN_IRQ_LAN	(M32700UT_LAN_PLD_IRQ_BASE + 1)	/* LAN */
-#define M32700UT_LAN_IRQ_I2C	(M32700UT_LAN_PLD_IRQ_BASE + 3)	/* I2C */
-
-#define M32700UT_LAN_ICUISTS	__reg16(M32700UT_LAN_BASE + 0xc0002)
-#define M32700UT_LAN_ICUISTS_VECB_MASK	(0xf000)
-#define M32700UT_LAN_VECB(x)	((x) & M32700UT_LAN_ICUISTS_VECB_MASK)
-#define M32700UT_LAN_ICUISTS_ISN_MASK	(0x07c0)
-#define M32700UT_LAN_ICUISTS_ISN(x)	((x) & M32700UT_LAN_ICUISTS_ISN_MASK)
-#define M32700UT_LAN_ICUIREQ0	__reg16(M32700UT_LAN_BASE + 0xc0004)
-#define M32700UT_LAN_ICUCR1	__reg16(M32700UT_LAN_BASE + 0xc0010)
-#define M32700UT_LAN_ICUCR3	__reg16(M32700UT_LAN_BASE + 0xc0014)
-
-/*
- * AR register on PLD
- */
-#define ARVCR0		__reg32(M32700UT_LAN_BASE + 0x40000)
-#define ARVCR0_VDS		0x00080000
-#define ARVCR0_RST		0x00010000
-#define ARVCR1		__reg32(M32700UT_LAN_BASE + 0x40004)
-#define ARVCR1_QVGA		0x02000000
-#define ARVCR1_NORMAL		0x01000000
-#define ARVCR1_HIEN		0x00010000
-#define ARVHCOUNT	__reg32(M32700UT_LAN_BASE + 0x40008)
-#define ARDATA		__reg32(M32700UT_LAN_BASE + 0x40010)
-#define ARINTSEL	__reg32(M32700UT_LAN_BASE + 0x40014)
-#define ARINTSEL_INT3		0x10000000	/* CPU INT3 */
-#define ARDATA32	__reg32(M32700UT_LAN_BASE + 0x04040010)	// Block 5
-/*
-#define ARINTSEL_SEL2		0x00002000
-#define ARINTSEL_SEL3		0x00001000
-#define ARINTSEL_SEL6		0x00000200
-#define ARINTSEL_SEL7		0x00000100
-#define ARINTSEL_SEL9		0x00000040
-#define ARINTSEL_SEL10		0x00000020
-#define ARINTSEL_SEL11		0x00000010
-#define ARINTSEL_SEL12		0x00000008
-*/
-
-/*
- * I2C register on PLD
- */
-#define PLDI2CCR	__reg32(M32700UT_LAN_BASE + 0x40040)
-#define	PLDI2CCR_ES0		0x00000001	/* enable I2C interface */
-#define PLDI2CMOD	__reg32(M32700UT_LAN_BASE + 0x40044)
-#define PLDI2CMOD_ACKCLK	0x00000200
-#define PLDI2CMOD_DTWD		0x00000100
-#define PLDI2CMOD_10BT		0x00000004
-#define PLDI2CMOD_ATM_NORMAL	0x00000000
-#define PLDI2CMOD_ATM_AUTO	0x00000003
-#define PLDI2CACK	__reg32(M32700UT_LAN_BASE + 0x40048)
-#define PLDI2CACK_ACK		0x00000001
-#define PLDI2CFREQ	__reg32(M32700UT_LAN_BASE + 0x4004c)
-#define PLDI2CCND	__reg32(M32700UT_LAN_BASE + 0x40050)
-#define PLDI2CCND_START		0x00000001
-#define PLDI2CCND_STOP		0x00000002
-#define PLDI2CSTEN	__reg32(M32700UT_LAN_BASE + 0x40054)
-#define PLDI2CSTEN_STEN		0x00000001
-#define PLDI2CDATA	__reg32(M32700UT_LAN_BASE + 0x40060)
-#define PLDI2CSTS	__reg32(M32700UT_LAN_BASE + 0x40064)
-#define PLDI2CSTS_TRX		0x00000020
-#define PLDI2CSTS_BB		0x00000010
-#define PLDI2CSTS_NOACK		0x00000001	/* 0:ack, 1:noack */
-
-#endif /* _M32700UT_M32700UT_LAN_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/m32700ut/m32700ut_lcd.h linux-2.6.30-rc3/include/asm-m32r/m32700ut/m32700ut_lcd.h
--- linux-2.6.30-rc2/include/asm-m32r/m32700ut/m32700ut_lcd.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/m32700ut/m32700ut_lcd.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,55 +0,0 @@
-#ifndef _M32700UT_M32700UT_LCD_H
-#define _M32700UT_M32700UT_LCD_H
-
-/*
- * include/asm-m32r/m32700ut/m32700ut_lcd.h
- *
- * M32700UT-LCD board
- *
- * Copyright (c) 2002	Takeo Takahashi
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#ifndef __ASSEMBLY__
-/*
- * C functions use non-cache address.
- */
-#define M32700UT_LCD_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
-#else
-#define M32700UT_LCD_BASE	(0x10000000 + NONCACHE_OFFSET)
-#endif /* __ASSEMBLY__ */
-
-/*
- * ICU
- */
-#define M32700UT_LCD_IRQ_BAT_INT	(M32700UT_LCD_PLD_IRQ_BASE + 1)
-#define M32700UT_LCD_IRQ_USB_INT1	(M32700UT_LCD_PLD_IRQ_BASE + 2)
-#define M32700UT_LCD_IRQ_AUDT0		(M32700UT_LCD_PLD_IRQ_BASE + 3)
-#define M32700UT_LCD_IRQ_AUDT2		(M32700UT_LCD_PLD_IRQ_BASE + 4)
-#define M32700UT_LCD_IRQ_BATSIO_RCV	(M32700UT_LCD_PLD_IRQ_BASE + 16)
-#define M32700UT_LCD_IRQ_BATSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 17)
-#define M32700UT_LCD_IRQ_ASNDSIO_RCV	(M32700UT_LCD_PLD_IRQ_BASE + 18)
-#define M32700UT_LCD_IRQ_ASNDSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 19)
-#define M32700UT_LCD_IRQ_ACNLSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 21)
-
-#define M32700UT_LCD_ICUISTS	__reg16(M32700UT_LCD_BASE + 0x300002)
-#define M32700UT_LCD_ICUISTS_VECB_MASK	(0xf000)
-#define M32700UT_LCD_VECB(x)	((x) & M32700UT_LCD_ICUISTS_VECB_MASK)
-#define M32700UT_LCD_ICUISTS_ISN_MASK	(0x07c0)
-#define M32700UT_LCD_ICUISTS_ISN(x)	((x) & M32700UT_LCD_ICUISTS_ISN_MASK)
-#define M32700UT_LCD_ICUIREQ0	__reg16(M32700UT_LCD_BASE + 0x300004)
-#define M32700UT_LCD_ICUIREQ1	__reg16(M32700UT_LCD_BASE + 0x300006)
-#define M32700UT_LCD_ICUCR1	__reg16(M32700UT_LCD_BASE + 0x300020)
-#define M32700UT_LCD_ICUCR2	__reg16(M32700UT_LCD_BASE + 0x300022)
-#define M32700UT_LCD_ICUCR3	__reg16(M32700UT_LCD_BASE + 0x300024)
-#define M32700UT_LCD_ICUCR4	__reg16(M32700UT_LCD_BASE + 0x300026)
-#define M32700UT_LCD_ICUCR16	__reg16(M32700UT_LCD_BASE + 0x300030)
-#define M32700UT_LCD_ICUCR17	__reg16(M32700UT_LCD_BASE + 0x300032)
-#define M32700UT_LCD_ICUCR18	__reg16(M32700UT_LCD_BASE + 0x300034)
-#define M32700UT_LCD_ICUCR19	__reg16(M32700UT_LCD_BASE + 0x300036)
-#define M32700UT_LCD_ICUCR21	__reg16(M32700UT_LCD_BASE + 0x30003a)
-
-#endif /* _M32700UT_M32700UT_LCD_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/m32700ut/m32700ut_pld.h linux-2.6.30-rc3/include/asm-m32r/m32700ut/m32700ut_pld.h
--- linux-2.6.30-rc2/include/asm-m32r/m32700ut/m32700ut_pld.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/m32700ut/m32700ut_pld.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,259 +0,0 @@
-#ifndef _M32700UT_M32700UT_PLD_H
-#define _M32700UT_M32700UT_PLD_H
-
-/*
- * include/asm-m32r/m32700ut/m32700ut_pld.h
- *
- * Definitions for Programable Logic Device(PLD) on M32700UT board.
- *
- * Copyright (c) 2002	Takeo Takahashi
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV)
-#define PLD_PLAT_BASE		0x04c00000
-#else
-#error "no platform configuration"
-#endif
-
-#ifndef __ASSEMBLY__
-/*
- * C functions use non-cache address.
- */
-#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
-#define __reg8			(volatile unsigned char *)
-#define __reg16			(volatile unsigned short *)
-#define __reg32			(volatile unsigned int *)
-#else
-#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
-#define __reg8
-#define __reg16
-#define __reg32
-#endif /* __ASSEMBLY__ */
-
-/* CFC */
-#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
-#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
-#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
-#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
-#define PLD_CFVENCR		__reg16(PLD_BASE + 0x0008)
-#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
-#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
-#define PLD_IDERSTCR		__reg16(PLD_BASE + 0x0010)
-
-/* MMC */
-#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
-#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
-#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
-#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
-#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
-#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
-#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
-#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
-#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
-#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
-#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
-#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
-
-/* ICU
- *  ICUISTS:	status register
- *  ICUIREQ0: 	request register
- *  ICUIREQ1: 	request register
- *  ICUCR3:	control register for CFIREQ# interrupt
- *  ICUCR4:	control register for CFC Card insert interrupt
- *  ICUCR5:	control register for CFC Card eject interrupt
- *  ICUCR6:	control register for external interrupt
- *  ICUCR11:	control register for MMC Card insert/eject interrupt
- *  ICUCR13:	control register for SC error interrupt
- *  ICUCR14:	control register for SC receive interrupt
- *  ICUCR15:	control register for SC send interrupt
- *  ICUCR16:	control register for SIO0 receive interrupt
- *  ICUCR17:	control register for SIO0 send interrupt
- */
-#if !defined(CONFIG_PLAT_USRV)
-#define PLD_IRQ_INT0		(M32700UT_PLD_IRQ_BASE + 0)	/* None */
-#define PLD_IRQ_INT1		(M32700UT_PLD_IRQ_BASE + 1)	/* reserved */
-#define PLD_IRQ_INT2		(M32700UT_PLD_IRQ_BASE + 2)	/* reserved */
-#define PLD_IRQ_CFIREQ		(M32700UT_PLD_IRQ_BASE + 3)	/* CF IREQ */
-#define PLD_IRQ_CFC_INSERT	(M32700UT_PLD_IRQ_BASE + 4)	/* CF Insert */
-#define PLD_IRQ_CFC_EJECT	(M32700UT_PLD_IRQ_BASE + 5)	/* CF Eject */
-#define PLD_IRQ_EXINT		(M32700UT_PLD_IRQ_BASE + 6)	/* EXINT */
-#define PLD_IRQ_INT7		(M32700UT_PLD_IRQ_BASE + 7)	/* reserved */
-#define PLD_IRQ_INT8		(M32700UT_PLD_IRQ_BASE + 8)	/* reserved */
-#define PLD_IRQ_INT9		(M32700UT_PLD_IRQ_BASE + 9)	/* reserved */
-#define PLD_IRQ_INT10		(M32700UT_PLD_IRQ_BASE + 10)	/* reserved */
-#define PLD_IRQ_MMCCARD		(M32700UT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
-#define PLD_IRQ_INT12		(M32700UT_PLD_IRQ_BASE + 12)	/* reserved */
-#define PLD_IRQ_SC_ERROR	(M32700UT_PLD_IRQ_BASE + 13)	/* SC error */
-#define PLD_IRQ_SC_RCV		(M32700UT_PLD_IRQ_BASE + 14)	/* SC receive */
-#define PLD_IRQ_SC_SND		(M32700UT_PLD_IRQ_BASE + 15)	/* SC send */
-#define PLD_IRQ_SIO0_RCV	(M32700UT_PLD_IRQ_BASE + 16)	/* SIO receive */
-#define PLD_IRQ_SIO0_SND	(M32700UT_PLD_IRQ_BASE + 17)	/* SIO send */
-#define PLD_IRQ_INT18		(M32700UT_PLD_IRQ_BASE + 18)	/* reserved */
-#define PLD_IRQ_INT19		(M32700UT_PLD_IRQ_BASE + 19)	/* reserved */
-#define PLD_IRQ_INT20		(M32700UT_PLD_IRQ_BASE + 20)	/* reserved */
-#define PLD_IRQ_INT21		(M32700UT_PLD_IRQ_BASE + 21)	/* reserved */
-#define PLD_IRQ_INT22		(M32700UT_PLD_IRQ_BASE + 22)	/* reserved */
-#define PLD_IRQ_INT23		(M32700UT_PLD_IRQ_BASE + 23)	/* reserved */
-#define PLD_IRQ_INT24		(M32700UT_PLD_IRQ_BASE + 24)	/* reserved */
-#define PLD_IRQ_INT25		(M32700UT_PLD_IRQ_BASE + 25)	/* reserved */
-#define PLD_IRQ_INT26		(M32700UT_PLD_IRQ_BASE + 26)	/* reserved */
-#define PLD_IRQ_INT27		(M32700UT_PLD_IRQ_BASE + 27)	/* reserved */
-#define PLD_IRQ_INT28		(M32700UT_PLD_IRQ_BASE + 28)	/* reserved */
-#define PLD_IRQ_INT29		(M32700UT_PLD_IRQ_BASE + 29)	/* reserved */
-#define PLD_IRQ_INT30		(M32700UT_PLD_IRQ_BASE + 30)	/* reserved */
-#define PLD_IRQ_INT31		(M32700UT_PLD_IRQ_BASE + 31)	/* reserved */
-
-#else	/* CONFIG_PLAT_USRV */
-
-#define PLD_IRQ_INT0		(M32700UT_PLD_IRQ_BASE + 0)	/* None */
-#define PLD_IRQ_INT1		(M32700UT_PLD_IRQ_BASE + 1)	/* reserved */
-#define PLD_IRQ_INT2		(M32700UT_PLD_IRQ_BASE + 2)	/* reserved */
-#define PLD_IRQ_CF0		(M32700UT_PLD_IRQ_BASE + 3)	/* CF0# */
-#define PLD_IRQ_CF1		(M32700UT_PLD_IRQ_BASE + 4)	/* CF1# */
-#define PLD_IRQ_CF2		(M32700UT_PLD_IRQ_BASE + 5)	/* CF2# */
-#define PLD_IRQ_CF3		(M32700UT_PLD_IRQ_BASE + 6)	/* CF3# */
-#define PLD_IRQ_CF4		(M32700UT_PLD_IRQ_BASE + 7)	/* CF4# */
-#define PLD_IRQ_INT8		(M32700UT_PLD_IRQ_BASE + 8)	/* reserved */
-#define PLD_IRQ_INT9		(M32700UT_PLD_IRQ_BASE + 9)	/* reserved */
-#define PLD_IRQ_INT10		(M32700UT_PLD_IRQ_BASE + 10)	/* reserved */
-#define PLD_IRQ_INT11		(M32700UT_PLD_IRQ_BASE + 11)	/* reserved */
-#define PLD_IRQ_UART0		(M32700UT_PLD_IRQ_BASE + 12)	/* UARTIRQ0 */
-#define PLD_IRQ_UART1		(M32700UT_PLD_IRQ_BASE + 13)	/* UARTIRQ1 */
-#define PLD_IRQ_INT14		(M32700UT_PLD_IRQ_BASE + 14)	/* reserved */
-#define PLD_IRQ_INT15		(M32700UT_PLD_IRQ_BASE + 15)	/* reserved */
-#define PLD_IRQ_SNDINT		(M32700UT_PLD_IRQ_BASE + 16)	/* SNDINT# */
-#define PLD_IRQ_INT17		(M32700UT_PLD_IRQ_BASE + 17)	/* reserved */
-#define PLD_IRQ_INT18		(M32700UT_PLD_IRQ_BASE + 18)	/* reserved */
-#define PLD_IRQ_INT19		(M32700UT_PLD_IRQ_BASE + 19)	/* reserved */
-#define PLD_IRQ_INT20		(M32700UT_PLD_IRQ_BASE + 20)	/* reserved */
-#define PLD_IRQ_INT21		(M32700UT_PLD_IRQ_BASE + 21)	/* reserved */
-#define PLD_IRQ_INT22		(M32700UT_PLD_IRQ_BASE + 22)	/* reserved */
-#define PLD_IRQ_INT23		(M32700UT_PLD_IRQ_BASE + 23)	/* reserved */
-#define PLD_IRQ_INT24		(M32700UT_PLD_IRQ_BASE + 24)	/* reserved */
-#define PLD_IRQ_INT25		(M32700UT_PLD_IRQ_BASE + 25)	/* reserved */
-#define PLD_IRQ_INT26		(M32700UT_PLD_IRQ_BASE + 26)	/* reserved */
-#define PLD_IRQ_INT27		(M32700UT_PLD_IRQ_BASE + 27)	/* reserved */
-#define PLD_IRQ_INT28		(M32700UT_PLD_IRQ_BASE + 28)	/* reserved */
-#define PLD_IRQ_INT29		(M32700UT_PLD_IRQ_BASE + 29)	/* reserved */
-#define PLD_IRQ_INT30		(M32700UT_PLD_IRQ_BASE + 30)	/* reserved */
-
-#endif	/* CONFIG_PLAT_USRV */
-
-#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
-#define PLD_ICUISTS_VECB_MASK	(0xf000)
-#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
-#define PLD_ICUISTS_ISN_MASK	(0x07c0)
-#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
-#define PLD_ICUIREQ0		__reg16(PLD_BASE + 0x8004)
-#define PLD_ICUIREQ1		__reg16(PLD_BASE + 0x8006)
-#define PLD_ICUCR1		__reg16(PLD_BASE + 0x8100)
-#define PLD_ICUCR2		__reg16(PLD_BASE + 0x8102)
-#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
-#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
-#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
-#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
-#define PLD_ICUCR7		__reg16(PLD_BASE + 0x810c)
-#define PLD_ICUCR8		__reg16(PLD_BASE + 0x810e)
-#define PLD_ICUCR9		__reg16(PLD_BASE + 0x8110)
-#define PLD_ICUCR10		__reg16(PLD_BASE + 0x8112)
-#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
-#define PLD_ICUCR12		__reg16(PLD_BASE + 0x8116)
-#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
-#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
-#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
-#define PLD_ICUCR16		__reg16(PLD_BASE + 0x811e)
-#define PLD_ICUCR17		__reg16(PLD_BASE + 0x8120)
-#define PLD_ICUCR_IEN		(0x1000)
-#define PLD_ICUCR_IREQ		(0x0100)
-#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
-#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
-#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
-#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
-#define PLD_ICUCR_ILEVEL0	(0x0000)
-#define PLD_ICUCR_ILEVEL1	(0x0001)
-#define PLD_ICUCR_ILEVEL2	(0x0002)
-#define PLD_ICUCR_ILEVEL3	(0x0003)
-#define PLD_ICUCR_ILEVEL4	(0x0004)
-#define PLD_ICUCR_ILEVEL5	(0x0005)
-#define PLD_ICUCR_ILEVEL6	(0x0006)
-#define PLD_ICUCR_ILEVEL7	(0x0007)
-
-/* Power Control of MMC and CF */
-#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
-#define PLD_CPCR_CF		0x0001
-#define PLD_CPCR_MMC		0x0002
-
-/* LED Control
- *
- * 1: DIP swich side
- * 2: Reset switch side
- */
-#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
-#define PLD_IOLED_1_ON		0x001
-#define PLD_IOLED_1_OFF		0x000
-#define PLD_IOLED_2_ON		0x002
-#define PLD_IOLED_2_OFF		0x000
-
-/* DIP Switch
- *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
- *  1: -
- *  2: -
- *  3: -
- */
-#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
-#define	PLD_IOSWSTS_IOSW2	0x0200
-#define	PLD_IOSWSTS_IOSW1	0x0100
-#define	PLD_IOSWSTS_IOWP0	0x0001
-
-/* CRC */
-#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
-#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
-#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
-#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
-#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
-#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
-
-/* RTC */
-#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
-#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
-#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
-#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
-#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
-
-/* SIO0 */
-#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
-#define	PLD_ESIO0CR_TXEN	0x0001
-#define	PLD_ESIO0CR_RXEN	0x0002
-#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
-#define	PLD_ESIO0MOD0_CTSS	0x0040
-#define	PLD_ESIO0MOD0_RTSS	0x0080
-#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
-#define	PLD_ESIO0MOD1_LMFS	0x0010
-#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
-#define	PLD_ESIO0STS_TEMP	0x0001
-#define	PLD_ESIO0STS_TXCP	0x0002
-#define	PLD_ESIO0STS_RXCP	0x0004
-#define	PLD_ESIO0STS_TXSC	0x0100
-#define	PLD_ESIO0STS_RXSC	0x0200
-#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
-#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
-#define	PLD_ESIO0INTCR_TXIEN	0x0002
-#define	PLD_ESIO0INTCR_RXCEN	0x0004
-#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
-#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
-#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
-
-/* SIM Card */
-#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
-#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
-#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
-#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
-#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
-#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
-#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
-
-#endif /* _M32700UT_M32700UT_PLD.H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/m32r.h linux-2.6.30-rc3/include/asm-m32r/m32r.h
--- linux-2.6.30-rc2/include/asm-m32r/m32r.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/m32r.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,160 +0,0 @@
-#ifndef _ASM_M32R_M32R_H_
-#define _ASM_M32R_M32R_H_
-
-/*
- * Renesas M32R processor
- *
- * Copyright (C) 2003, 2004  Renesas Technology Corp.
- */
-
-
-/* Chip type */
-#if defined(CONFIG_CHIP_XNUX_MP) || defined(CONFIG_CHIP_XNUX2_MP)
-#include <asm/m32r_mp_fpga.h>
-#elif defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_XNUX2) \
-	|| defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_M32102) \
-        || defined(CONFIG_CHIP_OPSP) || defined(CONFIG_CHIP_M32104)
-#include <asm/m32102.h>
-#endif
-
-/* Platform type */
-#if defined(CONFIG_PLAT_M32700UT)
-#include <asm/m32700ut/m32700ut_pld.h>
-#include <asm/m32700ut/m32700ut_lan.h>
-#include <asm/m32700ut/m32700ut_lcd.h>
-/* for ei_handler:linux/arch/m32r/kernel/entry.S */
-#define M32R_INT1ICU_ISTS	PLD_ICUISTS
-#define M32R_INT1ICU_IRQ_BASE	M32700UT_PLD_IRQ_BASE
-#define M32R_INT0ICU_ISTS	M32700UT_LAN_ICUISTS
-#define M32R_INT0ICU_IRQ_BASE	M32700UT_LAN_PLD_IRQ_BASE
-#define M32R_INT2ICU_ISTS	M32700UT_LCD_ICUISTS
-#define M32R_INT2ICU_IRQ_BASE	M32700UT_LCD_PLD_IRQ_BASE
-#endif  /* CONFIG_PLAT_M32700UT */
-
-#if defined(CONFIG_PLAT_OPSPUT)
-#include <asm/opsput/opsput_pld.h>
-#include <asm/opsput/opsput_lan.h>
-#include <asm/opsput/opsput_lcd.h>
-/* for ei_handler:linux/arch/m32r/kernel/entry.S */
-#define M32R_INT1ICU_ISTS	PLD_ICUISTS
-#define M32R_INT1ICU_IRQ_BASE	OPSPUT_PLD_IRQ_BASE
-#define M32R_INT0ICU_ISTS	OPSPUT_LAN_ICUISTS
-#define M32R_INT0ICU_IRQ_BASE	OPSPUT_LAN_PLD_IRQ_BASE
-#define M32R_INT2ICU_ISTS	OPSPUT_LCD_ICUISTS
-#define M32R_INT2ICU_IRQ_BASE	OPSPUT_LCD_PLD_IRQ_BASE
-#endif  /* CONFIG_PLAT_OPSPUT */
-
-#if defined(CONFIG_PLAT_MAPPI2)
-#include <asm/mappi2/mappi2_pld.h>
-#endif	/* CONFIG_PLAT_MAPPI2 */
-
-#if defined(CONFIG_PLAT_MAPPI3)
-#include <asm/mappi3/mappi3_pld.h>
-#endif	/* CONFIG_PLAT_MAPPI3 */
-
-#if defined(CONFIG_PLAT_USRV)
-#include <asm/m32700ut/m32700ut_pld.h>
-/* for ei_handler:linux/arch/m32r/kernel/entry.S */
-#define M32R_INT1ICU_ISTS	PLD_ICUISTS
-#define M32R_INT1ICU_IRQ_BASE	M32700UT_PLD_IRQ_BASE
-#endif
-
-#if defined(CONFIG_PLAT_M32104UT)
-#include <asm/m32104ut/m32104ut_pld.h>
-/* for ei_handler:linux/arch/m32r/kernel/entry.S */
-#define M32R_INT1ICU_ISTS	PLD_ICUISTS
-#define M32R_INT1ICU_IRQ_BASE	M32104UT_PLD_IRQ_BASE
-#endif  /* CONFIG_PLAT_M32104 */
-
-/*
- * M32R Register
- */
-
-/*
- * MMU Register
- */
-
-#define MMU_REG_BASE	(0xffff0000)
-#define ITLB_BASE	(0xfe000000)
-#define DTLB_BASE	(0xfe000800)
-
-#define NR_TLB_ENTRIES	CONFIG_TLB_ENTRIES
-
-#define MATM	MMU_REG_BASE		/* MMU Address Translation Mode
-					   Register */
-#define MPSZ	(0x04 + MMU_REG_BASE)	/* MMU Page Size Designation Register */
-#define MASID	(0x08 + MMU_REG_BASE)	/* MMU Address Space ID Register */
-#define MESTS	(0x0c + MMU_REG_BASE)	/* MMU Exception Status Register */
-#define MDEVA	(0x10 + MMU_REG_BASE)	/* MMU Operand Exception Virtual
-					   Address Register */
-#define MDEVP	(0x14 + MMU_REG_BASE)	/* MMU Operand Exception Virtual Page
-					   Number Register */
-#define MPTB	(0x18 + MMU_REG_BASE)	/* MMU Page Table Base Register */
-#define MSVA	(0x20 + MMU_REG_BASE)	/* MMU Search Virtual Address
-					   Register */
-#define MTOP	(0x24 + MMU_REG_BASE)	/* MMU TLB Operation Register */
-#define MIDXI	(0x28 + MMU_REG_BASE)	/* MMU Index Register for
-					   Instruciton */
-#define MIDXD	(0x2c + MMU_REG_BASE)	/* MMU Index Register for Operand */
-
-#define MATM_offset	(MATM - MMU_REG_BASE)
-#define MPSZ_offset	(MPSZ - MMU_REG_BASE)
-#define MASID_offset	(MASID - MMU_REG_BASE)
-#define MESTS_offset	(MESTS - MMU_REG_BASE)
-#define MDEVA_offset	(MDEVA - MMU_REG_BASE)
-#define MDEVP_offset	(MDEVP - MMU_REG_BASE)
-#define MPTB_offset	(MPTB - MMU_REG_BASE)
-#define MSVA_offset	(MSVA - MMU_REG_BASE)
-#define MTOP_offset	(MTOP - MMU_REG_BASE)
-#define MIDXI_offset	(MIDXI - MMU_REG_BASE)
-#define MIDXD_offset	(MIDXD - MMU_REG_BASE)
-
-#define MESTS_IT	(1 << 0)	/* Instruction TLB miss */
-#define MESTS_IA	(1 << 1)	/* Instruction Access Exception */
-#define MESTS_DT	(1 << 4)	/* Operand TLB miss */
-#define MESTS_DA	(1 << 5)	/* Operand Access Exception */
-#define MESTS_DRW	(1 << 6)	/* Operand Write Exception Flag */
-
-/*
- * PSW (Processor Status Word)
- */
-
-/* PSW bit */
-#define M32R_PSW_BIT_SM   (7)    /* Stack Mode */
-#define M32R_PSW_BIT_IE   (6)    /* Interrupt Enable */
-#define M32R_PSW_BIT_PM   (3)    /* Processor Mode [0:Supervisor,1:User] */
-#define M32R_PSW_BIT_C    (0)    /* Condition */
-#define M32R_PSW_BIT_BSM  (7+8)  /* Backup Stack Mode */
-#define M32R_PSW_BIT_BIE  (6+8)  /* Backup Interrupt Enable */
-#define M32R_PSW_BIT_BPM  (3+8)  /* Backup Processor Mode */
-#define M32R_PSW_BIT_BC   (0+8)  /* Backup Condition */
-
-/* PSW bit map */
-#define M32R_PSW_SM   (1UL<< M32R_PSW_BIT_SM)   /* Stack Mode */
-#define M32R_PSW_IE   (1UL<< M32R_PSW_BIT_IE)   /* Interrupt Enable */
-#define M32R_PSW_PM   (1UL<< M32R_PSW_BIT_PM)   /* Processor Mode */
-#define M32R_PSW_C    (1UL<< M32R_PSW_BIT_C)    /* Condition */
-#define M32R_PSW_BSM  (1UL<< M32R_PSW_BIT_BSM)  /* Backup Stack Mode */
-#define M32R_PSW_BIE  (1UL<< M32R_PSW_BIT_BIE)  /* Backup Interrupt Enable */
-#define M32R_PSW_BPM  (1UL<< M32R_PSW_BIT_BPM)  /* Backup Processor Mode */
-#define M32R_PSW_BC   (1UL<< M32R_PSW_BIT_BC)   /* Backup Condition */
-
-/*
- * Direct address to SFR
- */
-
-#include <asm/page.h>
-#ifdef CONFIG_MMU
-#define NONCACHE_OFFSET  (__PAGE_OFFSET + 0x20000000)
-#else
-#define NONCACHE_OFFSET  __PAGE_OFFSET
-#endif /* CONFIG_MMU */
-
-#define M32R_ICU_ISTS_ADDR  M32R_ICU_ISTS_PORTL+NONCACHE_OFFSET
-#define M32R_ICU_IPICR_ADDR  M32R_ICU_IPICR0_PORTL+NONCACHE_OFFSET
-#define M32R_ICU_IMASK_ADDR  M32R_ICU_IMASK_PORTL+NONCACHE_OFFSET
-#define M32R_FPGA_CPU_NAME_ADDR  M32R_FPGA_CPU_NAME0_PORTL+NONCACHE_OFFSET
-#define M32R_FPGA_MODEL_ID_ADDR  M32R_FPGA_MODEL_ID0_PORTL+NONCACHE_OFFSET
-#define M32R_FPGA_VERSION_ADDR   M32R_FPGA_VERSION0_PORTL+NONCACHE_OFFSET
-
-#endif /* _ASM_M32R_M32R_H_ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/m32r_mp_fpga.h linux-2.6.30-rc3/include/asm-m32r/m32r_mp_fpga.h
--- linux-2.6.30-rc2/include/asm-m32r/m32r_mp_fpga.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/m32r_mp_fpga.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,313 +0,0 @@
-#ifndef _ASM_M32R_M32R_MP_FPGA_
-#define _ASM_M32R_M32R_MP_FPGA_
-
-/*
- * Renesas M32R-MP-FPGA
- *
- * Copyright (c) 2002  Hitoshi Yamamoto
- * Copyright (c) 2003, 2004  Renesas Technology Corp.
- */
-
-/*
- * ========================================================
- * M32R-MP-FPGA Memory Map
- * ========================================================
- * 0x00000000 : Block#0 : 64[MB]
- *              0x03E00000 : SFR
- *                           0x03E00000 : reserved
- *                           0x03EF0000 : FPGA
- *                           0x03EF1000 : reserved
- *                           0x03EF4000 : CKM
- *                           0x03EF4000 : BSELC
- *                           0x03EF5000 : reserved
- *                           0x03EFC000 : MFT
- *                           0x03EFD000 : SIO
- *                           0x03EFE000 : reserved
- *                           0x03EFF000 : ICU
- *              0x03F00000 : Internal SRAM 64[KB]
- *              0x03F10000 : reserved
- * --------------------------------------------------------
- * 0x04000000 : Block#1 : 64[MB]
- *              0x04000000 : Debug board SRAM 4[MB]
- *              0x04400000 : reserved
- * --------------------------------------------------------
- * 0x08000000 : Block#2 : 64[MB]
- * --------------------------------------------------------
- * 0x0C000000 : Block#3 : 64[MB]
- * --------------------------------------------------------
- * 0x10000000 : Block#4 : 64[MB]
- * --------------------------------------------------------
- * 0x14000000 : Block#5 : 64[MB]
- * --------------------------------------------------------
- * 0x18000000 : Block#6 : 64[MB]
- * --------------------------------------------------------
- * 0x1C000000 : Block#7 : 64[MB]
- * --------------------------------------------------------
- * 0xFE000000 : TLB
- *              0xFE000000 : ITLB
- *              0xFE000080 : reserved
- *              0xFE000800 : DTLB
- *              0xFE000880 : reserved
- * --------------------------------------------------------
- * 0xFF000000 : System area
- *              0xFFFF0000 : MMU
- *              0xFFFF0030 : reserved
- *              0xFFFF8000 : Debug function
- *              0xFFFFA000 : reserved
- *              0xFFFFC000 : CPU control
- * 0xFFFFFFFF
- * ========================================================
- */
-
-/*======================================================================*
- * Special Function Register
- *======================================================================*/
-#define M32R_SFR_OFFSET  (0x00E00000)  /* 0x03E00000-0x03EFFFFF 1[MB] */
-
-/*
- * FPGA registers.
- */
-#define M32R_FPGA_TOP  (0x000F0000+M32R_SFR_OFFSET)
-
-#define M32R_FPGA_NUM_OF_CPUS_PORTL  (0x00+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME0_PORTL    (0x10+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME1_PORTL    (0x14+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME2_PORTL    (0x18+M32R_FPGA_TOP)
-#define M32R_FPGA_CPU_NAME3_PORTL    (0x1C+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID0_PORTL    (0x20+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID1_PORTL    (0x24+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID2_PORTL    (0x28+M32R_FPGA_TOP)
-#define M32R_FPGA_MODEL_ID3_PORTL    (0x2C+M32R_FPGA_TOP)
-#define M32R_FPGA_VERSION0_PORTL     (0x30+M32R_FPGA_TOP)
-#define M32R_FPGA_VERSION1_PORTL     (0x34+M32R_FPGA_TOP)
-
-/*
- * Clock and Power Manager registers.
- */
-#define M32R_CPM_OFFSET  (0x000F4000+M32R_SFR_OFFSET)
-
-#define M32R_CPM_CPUCLKCR_PORTL  (0x00+M32R_CPM_OFFSET)
-#define M32R_CPM_CLKMOD_PORTL    (0x04+M32R_CPM_OFFSET)
-#define M32R_CPM_PLLCR_PORTL     (0x08+M32R_CPM_OFFSET)
-
-/*
- * Block SELect Controller registers.
- */
-#define M32R_BSELC_OFFSET  (0x000F5000+M32R_SFR_OFFSET)
-
-#define M32R_BSEL0_CR0_PORTL  (0x000+M32R_BSELC_OFFSET)
-#define M32R_BSEL0_CR1_PORTL  (0x004+M32R_BSELC_OFFSET)
-#define M32R_BSEL1_CR0_PORTL  (0x100+M32R_BSELC_OFFSET)
-#define M32R_BSEL1_CR1_PORTL  (0x104+M32R_BSELC_OFFSET)
-#define M32R_BSEL2_CR0_PORTL  (0x200+M32R_BSELC_OFFSET)
-#define M32R_BSEL2_CR1_PORTL  (0x204+M32R_BSELC_OFFSET)
-#define M32R_BSEL3_CR0_PORTL  (0x300+M32R_BSELC_OFFSET)
-#define M32R_BSEL3_CR1_PORTL  (0x304+M32R_BSELC_OFFSET)
-#define M32R_BSEL4_CR0_PORTL  (0x400+M32R_BSELC_OFFSET)
-#define M32R_BSEL4_CR1_PORTL  (0x404+M32R_BSELC_OFFSET)
-#define M32R_BSEL5_CR0_PORTL  (0x500+M32R_BSELC_OFFSET)
-#define M32R_BSEL5_CR1_PORTL  (0x504+M32R_BSELC_OFFSET)
-#define M32R_BSEL6_CR0_PORTL  (0x600+M32R_BSELC_OFFSET)
-#define M32R_BSEL6_CR1_PORTL  (0x604+M32R_BSELC_OFFSET)
-#define M32R_BSEL7_CR0_PORTL  (0x700+M32R_BSELC_OFFSET)
-#define M32R_BSEL7_CR1_PORTL  (0x704+M32R_BSELC_OFFSET)
-
-/*
- * Multi Function Timer registers.
- */
-#define M32R_MFT_OFFSET        (0x000FC000+M32R_SFR_OFFSET)
-
-#define M32R_MFTCR_PORTL       (0x000+M32R_MFT_OFFSET)  /* MFT control */
-#define M32R_MFTRPR_PORTL      (0x004+M32R_MFT_OFFSET)  /* MFT real port */
-
-#define M32R_MFT0_OFFSET       (0x100+M32R_MFT_OFFSET)
-#define M32R_MFT0MOD_PORTL     (0x00+M32R_MFT0_OFFSET)  /* MFT0 mode */
-#define M32R_MFT0BOS_PORTL     (0x04+M32R_MFT0_OFFSET)  /* MFT0 b-port output status */
-#define M32R_MFT0CUT_PORTL     (0x08+M32R_MFT0_OFFSET)  /* MFT0 count */
-#define M32R_MFT0RLD_PORTL     (0x0C+M32R_MFT0_OFFSET)  /* MFT0 reload */
-#define M32R_MFT0CMPRLD_PORTL  (0x10+M32R_MFT0_OFFSET)  /* MFT0 compare reload */
-
-#define M32R_MFT1_OFFSET       (0x200+M32R_MFT_OFFSET)
-#define M32R_MFT1MOD_PORTL     (0x00+M32R_MFT1_OFFSET)  /* MFT1 mode */
-#define M32R_MFT1BOS_PORTL     (0x04+M32R_MFT1_OFFSET)  /* MFT1 b-port output status */
-#define M32R_MFT1CUT_PORTL     (0x08+M32R_MFT1_OFFSET)  /* MFT1 count */
-#define M32R_MFT1RLD_PORTL     (0x0C+M32R_MFT1_OFFSET)  /* MFT1 reload */
-#define M32R_MFT1CMPRLD_PORTL  (0x10+M32R_MFT1_OFFSET)  /* MFT1 compare reload */
-
-#define M32R_MFT2_OFFSET       (0x300+M32R_MFT_OFFSET)
-#define M32R_MFT2MOD_PORTL     (0x00+M32R_MFT2_OFFSET)  /* MFT2 mode */
-#define M32R_MFT2BOS_PORTL     (0x04+M32R_MFT2_OFFSET)  /* MFT2 b-port output status */
-#define M32R_MFT2CUT_PORTL     (0x08+M32R_MFT2_OFFSET)  /* MFT2 count */
-#define M32R_MFT2RLD_PORTL     (0x0C+M32R_MFT2_OFFSET)  /* MFT2 reload */
-#define M32R_MFT2CMPRLD_PORTL  (0x10+M32R_MFT2_OFFSET)  /* MFT2 compare reload */
-
-#define M32R_MFT3_OFFSET       (0x400+M32R_MFT_OFFSET)
-#define M32R_MFT3MOD_PORTL     (0x00+M32R_MFT3_OFFSET)  /* MFT3 mode */
-#define M32R_MFT3BOS_PORTL     (0x04+M32R_MFT3_OFFSET)  /* MFT3 b-port output status */
-#define M32R_MFT3CUT_PORTL     (0x08+M32R_MFT3_OFFSET)  /* MFT3 count */
-#define M32R_MFT3RLD_PORTL     (0x0C+M32R_MFT3_OFFSET)  /* MFT3 reload */
-#define M32R_MFT3CMPRLD_PORTL  (0x10+M32R_MFT3_OFFSET)  /* MFT3 compare reload */
-
-#define M32R_MFT4_OFFSET       (0x500+M32R_MFT_OFFSET)
-#define M32R_MFT4MOD_PORTL     (0x00+M32R_MFT4_OFFSET)  /* MFT4 mode */
-#define M32R_MFT4BOS_PORTL     (0x04+M32R_MFT4_OFFSET)  /* MFT4 b-port output status */
-#define M32R_MFT4CUT_PORTL     (0x08+M32R_MFT4_OFFSET)  /* MFT4 count */
-#define M32R_MFT4RLD_PORTL     (0x0C+M32R_MFT4_OFFSET)  /* MFT4 reload */
-#define M32R_MFT4CMPRLD_PORTL  (0x10+M32R_MFT4_OFFSET)  /* MFT4 compare reload */
-
-#define M32R_MFT5_OFFSET       (0x600+M32R_MFT_OFFSET)
-#define M32R_MFT5MOD_PORTL     (0x00+M32R_MFT5_OFFSET)  /* MFT4 mode */
-#define M32R_MFT5BOS_PORTL     (0x04+M32R_MFT5_OFFSET)  /* MFT4 b-port output status */
-#define M32R_MFT5CUT_PORTL     (0x08+M32R_MFT5_OFFSET)  /* MFT4 count */
-#define M32R_MFT5RLD_PORTL     (0x0C+M32R_MFT5_OFFSET)  /* MFT4 reload */
-#define M32R_MFT5CMPRLD_PORTL  (0x10+M32R_MFT5_OFFSET)  /* MFT4 compare reload */
-
-#define M32R_MFTCR_MFT0MSK  (1UL<<15)  /* b16 */
-#define M32R_MFTCR_MFT1MSK  (1UL<<14)  /* b17 */
-#define M32R_MFTCR_MFT2MSK  (1UL<<13)  /* b18 */
-#define M32R_MFTCR_MFT3MSK  (1UL<<12)  /* b19 */
-#define M32R_MFTCR_MFT4MSK  (1UL<<11)  /* b20 */
-#define M32R_MFTCR_MFT5MSK  (1UL<<10)  /* b21 */
-#define M32R_MFTCR_MFT0EN   (1UL<<7)   /* b24 */
-#define M32R_MFTCR_MFT1EN   (1UL<<6)   /* b25 */
-#define M32R_MFTCR_MFT2EN   (1UL<<5)   /* b26 */
-#define M32R_MFTCR_MFT3EN   (1UL<<4)   /* b27 */
-#define M32R_MFTCR_MFT4EN   (1UL<<3)   /* b28 */
-#define M32R_MFTCR_MFT5EN   (1UL<<2)   /* b29 */
-
-#define M32R_MFTMOD_CC_MASK    (1UL<<15)  /* b16 */
-#define M32R_MFTMOD_TCCR       (1UL<<13)  /* b18 */
-#define M32R_MFTMOD_GTSEL000   (0UL<<8)   /* b21-23 : 000 */
-#define M32R_MFTMOD_GTSEL001   (1UL<<8)   /* b21-23 : 001 */
-#define M32R_MFTMOD_GTSEL010   (2UL<<8)   /* b21-23 : 010 */
-#define M32R_MFTMOD_GTSEL011   (3UL<<8)   /* b21-23 : 011 */
-#define M32R_MFTMOD_GTSEL110   (6UL<<8)   /* b21-23 : 110 */
-#define M32R_MFTMOD_GTSEL111   (7UL<<8)   /* b21-23 : 111 */
-#define M32R_MFTMOD_CMSEL      (1UL<<3)   /* b28 */
-#define M32R_MFTMOD_CSSEL000   (0UL<<0)   /* b29-b31 : 000 */
-#define M32R_MFTMOD_CSSEL001   (1UL<<0)   /* b29-b31 : 001 */
-#define M32R_MFTMOD_CSSEL010   (2UL<<0)   /* b29-b31 : 010 */
-#define M32R_MFTMOD_CSSEL011   (3UL<<0)   /* b29-b31 : 011 */
-#define M32R_MFTMOD_CSSEL100   (4UL<<0)   /* b29-b31 : 100 */
-#define M32R_MFTMOD_CSSEL110   (6UL<<0)   /* b29-b31 : 110 */
-
-/*
- * Serial I/O registers.
- */
-#define M32R_SIO_OFFSET  (0x000FD000+M32R_SFR_OFFSET)
-
-#define M32R_SIO0_CR_PORTL     (0x000+M32R_SIO_OFFSET)
-#define M32R_SIO0_MOD0_PORTL   (0x004+M32R_SIO_OFFSET)
-#define M32R_SIO0_MOD1_PORTL   (0x008+M32R_SIO_OFFSET)
-#define M32R_SIO0_STS_PORTL    (0x00C+M32R_SIO_OFFSET)
-#define M32R_SIO0_TRCR_PORTL   (0x010+M32R_SIO_OFFSET)
-#define M32R_SIO0_BAUR_PORTL   (0x014+M32R_SIO_OFFSET)
-#define M32R_SIO0_RBAUR_PORTL  (0x018+M32R_SIO_OFFSET)
-#define M32R_SIO0_TXB_PORTL    (0x01C+M32R_SIO_OFFSET)
-#define M32R_SIO0_RXB_PORTL    (0x020+M32R_SIO_OFFSET)
-
-/*
- * Interrupt Control Unit registers.
- */
-#define M32R_ICU_OFFSET  (0x000FF000+M32R_SFR_OFFSET)
-
-#define M32R_ICU_ISTS_PORTL     (0x004+M32R_ICU_OFFSET)
-#define M32R_ICU_IREQ0_PORTL    (0x008+M32R_ICU_OFFSET)
-#define M32R_ICU_IREQ1_PORTL    (0x00C+M32R_ICU_OFFSET)
-#define M32R_ICU_SBICR_PORTL    (0x018+M32R_ICU_OFFSET)
-#define M32R_ICU_IMASK_PORTL    (0x01C+M32R_ICU_OFFSET)
-#define M32R_ICU_CR1_PORTL      (0x200+M32R_ICU_OFFSET)  /* INT0 */
-#define M32R_ICU_CR2_PORTL      (0x204+M32R_ICU_OFFSET)  /* INT1 */
-#define M32R_ICU_CR3_PORTL      (0x208+M32R_ICU_OFFSET)  /* INT2 */
-#define M32R_ICU_CR4_PORTL      (0x20C+M32R_ICU_OFFSET)  /* INT3 */
-#define M32R_ICU_CR5_PORTL      (0x210+M32R_ICU_OFFSET)  /* INT4 */
-#define M32R_ICU_CR6_PORTL      (0x214+M32R_ICU_OFFSET)  /* INT5 */
-#define M32R_ICU_CR7_PORTL      (0x218+M32R_ICU_OFFSET)  /* INT6 */
-#define M32R_ICU_CR8_PORTL      (0x218+M32R_ICU_OFFSET)  /* INT7 */
-#define M32R_ICU_CR32_PORTL     (0x27C+M32R_ICU_OFFSET)  /* SIO0 RX */
-#define M32R_ICU_CR33_PORTL     (0x280+M32R_ICU_OFFSET)  /* SIO0 TX */
-#define M32R_ICU_CR40_PORTL     (0x29C+M32R_ICU_OFFSET)  /* DMAC0 */
-#define M32R_ICU_CR41_PORTL     (0x2A0+M32R_ICU_OFFSET)  /* DMAC1 */
-#define M32R_ICU_CR48_PORTL     (0x2BC+M32R_ICU_OFFSET)  /* MFT0 */
-#define M32R_ICU_CR49_PORTL     (0x2C0+M32R_ICU_OFFSET)  /* MFT1 */
-#define M32R_ICU_CR50_PORTL     (0x2C4+M32R_ICU_OFFSET)  /* MFT2 */
-#define M32R_ICU_CR51_PORTL     (0x2C8+M32R_ICU_OFFSET)  /* MFT3 */
-#define M32R_ICU_CR52_PORTL     (0x2CC+M32R_ICU_OFFSET)  /* MFT4 */
-#define M32R_ICU_CR53_PORTL     (0x2D0+M32R_ICU_OFFSET)  /* MFT5 */
-#define M32R_ICU_IPICR0_PORTL   (0x2DC+M32R_ICU_OFFSET)  /* IPI0 */
-#define M32R_ICU_IPICR1_PORTL   (0x2E0+M32R_ICU_OFFSET)  /* IPI1 */
-#define M32R_ICU_IPICR2_PORTL   (0x2E4+M32R_ICU_OFFSET)  /* IPI2 */
-#define M32R_ICU_IPICR3_PORTL   (0x2E8+M32R_ICU_OFFSET)  /* IPI3 */
-#define M32R_ICU_IPICR4_PORTL   (0x2EC+M32R_ICU_OFFSET)  /* IPI4 */
-#define M32R_ICU_IPICR5_PORTL   (0x2F0+M32R_ICU_OFFSET)  /* IPI5 */
-#define M32R_ICU_IPICR6_PORTL   (0x2F4+M32R_ICU_OFFSET)  /* IPI6 */
-#define M32R_ICU_IPICR7_PORTL   (0x2FC+M32R_ICU_OFFSET)  /* IPI7 */
-
-#define M32R_ICUISTS_VECB(val)  ((val>>28) & 0xF)
-#define M32R_ICUISTS_ISN(val)   ((val>>22) & 0x3F)
-#define M32R_ICUISTS_PIML(val)  ((val>>16) & 0x7)
-
-#define M32R_ICUIMASK_IMSK0  (0UL<<16)  /* b13-b15: Disable interrupt */
-#define M32R_ICUIMASK_IMSK1  (1UL<<16)  /* b13-b15: Enable level 0 interrupt */
-#define M32R_ICUIMASK_IMSK2  (2UL<<16)  /* b13-b15: Enable level 0,1 interrupt */
-#define M32R_ICUIMASK_IMSK3  (3UL<<16)  /* b13-b15: Enable level 0-2 interrupt */
-#define M32R_ICUIMASK_IMSK4  (4UL<<16)  /* b13-b15: Enable level 0-3 interrupt */
-#define M32R_ICUIMASK_IMSK5  (5UL<<16)  /* b13-b15: Enable level 0-4 interrupt */
-#define M32R_ICUIMASK_IMSK6  (6UL<<16)  /* b13-b15: Enable level 0-5 interrupt */
-#define M32R_ICUIMASK_IMSK7  (7UL<<16)  /* b13-b15: Enable level 0-6 interrupt */
-
-#define M32R_ICUCR_IEN      (1UL<<12)  /* b19: Interrupt enable */
-#define M32R_ICUCR_IRQ      (1UL<<8)   /* b23: Interrupt request */
-#define M32R_ICUCR_ISMOD00  (0UL<<4)   /* b26-b27: Interrupt sense mode Edge HtoL */
-#define M32R_ICUCR_ISMOD01  (1UL<<4)   /* b26-b27: Interrupt sense mode Level L */
-#define M32R_ICUCR_ISMOD10  (2UL<<4)   /* b26-b27: Interrupt sense mode Edge LtoH*/
-#define M32R_ICUCR_ISMOD11  (3UL<<4)   /* b26-b27: Interrupt sense mode Level H */
-#define M32R_ICUCR_ILEVEL0  (0UL<<0)   /* b29-b31: Interrupt priority level 0 */
-#define M32R_ICUCR_ILEVEL1  (1UL<<0)   /* b29-b31: Interrupt priority level 1 */
-#define M32R_ICUCR_ILEVEL2  (2UL<<0)   /* b29-b31: Interrupt priority level 2 */
-#define M32R_ICUCR_ILEVEL3  (3UL<<0)   /* b29-b31: Interrupt priority level 3 */
-#define M32R_ICUCR_ILEVEL4  (4UL<<0)   /* b29-b31: Interrupt priority level 4 */
-#define M32R_ICUCR_ILEVEL5  (5UL<<0)   /* b29-b31: Interrupt priority level 5 */
-#define M32R_ICUCR_ILEVEL6  (6UL<<0)   /* b29-b31: Interrupt priority level 6 */
-#define M32R_ICUCR_ILEVEL7  (7UL<<0)   /* b29-b31: Disable interrupt */
-#define M32R_ICUCR_ILEVEL_MASK  (7UL)
-
-#define M32R_IRQ_INT0    (1)   /* INT0 */
-#define M32R_IRQ_INT1    (2)   /* INT1 */
-#define M32R_IRQ_INT2    (3)   /* INT2 */
-#define M32R_IRQ_INT3    (4)   /* INT3 */
-#define M32R_IRQ_INT4    (5)   /* INT4 */
-#define M32R_IRQ_INT5    (6)   /* INT5 */
-#define M32R_IRQ_INT6    (7)   /* INT6 */
-#define M32R_IRQ_INT7    (8)   /* INT7 */
-#define M32R_IRQ_MFT0    (16)  /* MFT0 */
-#define M32R_IRQ_MFT1    (17)  /* MFT1 */
-#define M32R_IRQ_MFT2    (18)  /* MFT2 */
-#define M32R_IRQ_MFT3    (19)  /* MFT3 */
-#define M32R_IRQ_MFT4    (20)  /* MFT4 */
-#define M32R_IRQ_MFT5    (21)  /* MFT5 */
-#define M32R_IRQ_DMAC0   (32)  /* DMAC0 */
-#define M32R_IRQ_DMAC1   (33)  /* DMAC1 */
-#define M32R_IRQ_SIO0_R  (48)  /* SIO0 receive */
-#define M32R_IRQ_SIO0_S  (49)  /* SIO0 send    */
-#define M32R_IRQ_SIO1_R  (50)  /* SIO1 send    */
-#define M32R_IRQ_SIO1_S  (51)  /* SIO1 receive */
-#define M32R_IRQ_IPI0    (56)  /* IPI0 */
-#define M32R_IRQ_IPI1    (57)  /* IPI1 */
-#define M32R_IRQ_IPI2    (58)  /* IPI2 */
-#define M32R_IRQ_IPI3    (59)  /* IPI3 */
-#define M32R_IRQ_IPI4    (60)  /* IPI4 */
-#define M32R_IRQ_IPI5    (61)  /* IPI5 */
-#define M32R_IRQ_IPI6    (62)  /* IPI6 */
-#define M32R_IRQ_IPI7    (63)  /* IPI7 */
-
-/*======================================================================*
- * CPU
- *======================================================================*/
-
-#define M32R_CPUID_PORTL   (0xFFFFFFE0)
-#define M32R_MCICAR_PORTL  (0xFFFFFFF0)
-#define M32R_MCDCAR_PORTL  (0xFFFFFFF4)
-#define M32R_MCCR_PORTL    (0xFFFFFFFC)
-
-#endif  /* _ASM_M32R_M32R_MP_FPGA_ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mappi2/mappi2_pld.h linux-2.6.30-rc3/include/asm-m32r/mappi2/mappi2_pld.h
--- linux-2.6.30-rc2/include/asm-m32r/mappi2/mappi2_pld.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mappi2/mappi2_pld.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,150 +0,0 @@
-#ifndef _MAPPI2_PLD_H
-#define _MAPPI2_PLD_H
-
-/*
- * include/asm-m32r/mappi2/mappi2_pld.h
- *
- * Definitions for Extended IO Logic on MAPPI2 board.
- *  based on m32700ut_pld.h
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#ifndef __ASSEMBLY__
-/* FIXME:
- * Some C functions use non-cache address, so can't define non-cache address.
- */
-#define PLD_BASE		(0x10c00000 /* + NONCACHE_OFFSET */)
-#define __reg8			(volatile unsigned char *)
-#define __reg16			(volatile unsigned short *)
-#define __reg32			(volatile unsigned int *)
-#else
-#define PLD_BASE		(0x10c00000 + NONCACHE_OFFSET)
-#define __reg8
-#define __reg16
-#define __reg32
-#endif /* __ASSEMBLY__ */
-
-/* CFC */
-#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
-#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
-#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
-#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
-#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
-#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
-
-/* MMC */
-#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
-#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
-#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
-#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
-#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
-#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
-#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
-#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
-#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
-#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
-#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
-#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
-
-/* Power Control of MMC and CF */
-#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
-
-
-/*==== ICU ====*/
-#define  M32R_IRQ_PC104        (5)   /* INT4(PC/104) */
-#define  M32R_IRQ_I2C          (28)  /* I2C-BUS     */
-#if 1
-#define  PLD_IRQ_CFIREQ       (40)  /* CFC Card Interrupt */
-#define  PLD_IRQ_CFC_INSERT   (41)  /* CFC Card Insert */
-#define  PLD_IRQ_CFC_EJECT    (42)  /* CFC Card Eject */
-#define  PLD_IRQ_MMCCARD      (43)  /* MMC Card Insert */
-#define  PLD_IRQ_MMCIRQ       (44)  /* MMC Transfer Done */
-#else
-#define  PLD_IRQ_CFIREQ       (34)  /* CFC Card Interrupt */
-#define  PLD_IRQ_CFC_INSERT   (35)  /* CFC Card Insert */
-#define  PLD_IRQ_CFC_EJECT    (36)  /* CFC Card Eject */
-#define  PLD_IRQ_MMCCARD      (37)  /* MMC Card Insert */
-#define  PLD_IRQ_MMCIRQ       (38)  /* MMC Transfer Done */
-#endif
-
-
-#if 0
-/* LED Control
- *
- * 1: DIP swich side
- * 2: Reset switch side
- */
-#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
-#define PLD_IOLED_1_ON		0x001
-#define PLD_IOLED_1_OFF		0x000
-#define PLD_IOLED_2_ON		0x002
-#define PLD_IOLED_2_OFF		0x000
-
-/* DIP Switch
- *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
- *  1: -
- *  2: -
- *  3: -
- */
-#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
-#define	PLD_IOSWSTS_IOSW2	0x0200
-#define	PLD_IOSWSTS_IOSW1	0x0100
-#define	PLD_IOSWSTS_IOWP0	0x0001
-
-#endif
-
-/* CRC */
-#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
-#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
-#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
-#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
-#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
-#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
-
-
-#if 0
-/* RTC */
-#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
-#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
-#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
-#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
-#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
-
-/* SIO0 */
-#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
-#define	PLD_ESIO0CR_TXEN	0x0001
-#define	PLD_ESIO0CR_RXEN	0x0002
-#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
-#define	PLD_ESIO0MOD0_CTSS	0x0040
-#define	PLD_ESIO0MOD0_RTSS	0x0080
-#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
-#define	PLD_ESIO0MOD1_LMFS	0x0010
-#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
-#define	PLD_ESIO0STS_TEMP	0x0001
-#define	PLD_ESIO0STS_TXCP	0x0002
-#define	PLD_ESIO0STS_RXCP	0x0004
-#define	PLD_ESIO0STS_TXSC	0x0100
-#define	PLD_ESIO0STS_RXSC	0x0200
-#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
-#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
-#define	PLD_ESIO0INTCR_TXIEN	0x0002
-#define	PLD_ESIO0INTCR_RXCEN	0x0004
-#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
-#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
-#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
-
-/* SIM Card */
-#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
-#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
-#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
-#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
-#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
-#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
-#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
-
-#endif
-
-#endif /* _MAPPI2_PLD.H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mappi3/mappi3_pld.h linux-2.6.30-rc3/include/asm-m32r/mappi3/mappi3_pld.h
--- linux-2.6.30-rc2/include/asm-m32r/mappi3/mappi3_pld.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mappi3/mappi3_pld.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,142 +0,0 @@
-#ifndef _MAPPI3_PLD_H
-#define _MAPPI3_PLD_H
-
-/*
- * include/asm-m32r/mappi3/mappi3_pld.h
- *
- * Definitions for Extended IO Logic on MAPPI3 board.
- *  based on m32700ut_pld.h
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#ifndef __ASSEMBLY__
-/* FIXME:
- * Some C functions use non-cache address, so can't define non-cache address.
- */
-#define PLD_BASE		(0x1c000000 /* + NONCACHE_OFFSET */)
-#define __reg8			(volatile unsigned char *)
-#define __reg16			(volatile unsigned short *)
-#define __reg32			(volatile unsigned int *)
-#else
-#define PLD_BASE		(0x1c000000 + NONCACHE_OFFSET)
-#define __reg8
-#define __reg16
-#define __reg32
-#endif /* __ASSEMBLY__ */
-
-/* CFC */
-#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
-#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
-#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
-#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
-#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
-#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
-
-/* MMC */
-#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
-#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
-#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
-#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
-#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
-#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
-#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
-#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
-#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
-#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
-#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
-#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
-
-/* Power Control of MMC and CF */
-#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
-
-/* ICU */
-#define M32R_IRQ_PC104		(5)	/* INT4(PC/104) */
-#define M32R_IRQ_I2C		(28)	/* I2C-BUS */
-#define PLD_IRQ_CFIREQ		(6)	/* INT5 CFC Card Interrupt */
-#define PLD_IRQ_CFC_INSERT	(7)	/* INT6 CFC Card Insert & Eject */
-#define PLD_IRQ_IDEIREQ		(8)	/* INT7 IDE Interrupt */
-#define PLD_IRQ_MMCCARD		(43)	/* MMC Card Insert */
-#define PLD_IRQ_MMCIRQ		(44)	/* MMC Transfer Done */
-
-#if 0
-/* LED Control
- *
- * 1: DIP swich side
- * 2: Reset switch side
- */
-#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
-#define PLD_IOLED_1_ON		0x001
-#define PLD_IOLED_1_OFF		0x000
-#define PLD_IOLED_2_ON		0x002
-#define PLD_IOLED_2_OFF		0x000
-
-/* DIP Switch
- *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
- *  1: -
- *  2: -
- *  3: -
- */
-#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
-#define	PLD_IOSWSTS_IOSW2	0x0200
-#define	PLD_IOSWSTS_IOSW1	0x0100
-#define	PLD_IOSWSTS_IOWP0	0x0001
-
-#endif
-
-/* CRC */
-#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
-#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
-#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
-#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
-#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
-#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
-
-#if 0
-/* RTC */
-#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
-#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
-#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
-#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
-#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
-
-/* SIO0 */
-#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
-#define	PLD_ESIO0CR_TXEN	0x0001
-#define	PLD_ESIO0CR_RXEN	0x0002
-#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
-#define	PLD_ESIO0MOD0_CTSS	0x0040
-#define	PLD_ESIO0MOD0_RTSS	0x0080
-#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
-#define	PLD_ESIO0MOD1_LMFS	0x0010
-#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
-#define	PLD_ESIO0STS_TEMP	0x0001
-#define	PLD_ESIO0STS_TXCP	0x0002
-#define	PLD_ESIO0STS_RXCP	0x0004
-#define	PLD_ESIO0STS_TXSC	0x0100
-#define	PLD_ESIO0STS_RXSC	0x0200
-#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
-#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
-#define	PLD_ESIO0INTCR_TXIEN	0x0002
-#define	PLD_ESIO0INTCR_RXCEN	0x0004
-#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
-#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
-#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
-
-/* SIM Card */
-#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
-#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
-#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
-#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
-#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
-#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
-#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
-
-#endif
-
-/* Reset Control */
-#define PLD_REBOOT		__reg16(PLD_BASE + 0x38000)
-
-#endif /* _MAPPI3_PLD.H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mc146818rtc.h linux-2.6.30-rc3/include/asm-m32r/mc146818rtc.h
--- linux-2.6.30-rc2/include/asm-m32r/mc146818rtc.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mc146818rtc.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,29 +0,0 @@
-/*
- * Machine dependent access functions for RTC registers.
- */
-#ifndef _ASM_MC146818RTC_H
-#define _ASM_MC146818RTC_H
-
-#include <asm/io.h>
-
-#ifndef RTC_PORT
-#define RTC_PORT(x)	((x))
-#define RTC_ALWAYS_BCD	1	/* RTC operates in binary mode */
-#endif
-
-/*
- * The yet supported machines all access the RTC index register via
- * an ISA port access but the way to access the date register differs ...
- */
-#define CMOS_READ(addr) ({ \
-outb_p((addr),RTC_PORT(0)); \
-inb_p(RTC_PORT(1)); \
-})
-#define CMOS_WRITE(val, addr) ({ \
-outb_p((addr),RTC_PORT(0)); \
-outb_p((val),RTC_PORT(1)); \
-})
-
-#define RTC_IRQ 8
-
-#endif /* _ASM_MC146818RTC_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mman.h linux-2.6.30-rc3/include/asm-m32r/mman.h
--- linux-2.6.30-rc2/include/asm-m32r/mman.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mman.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,17 +0,0 @@
-#ifndef __M32R_MMAN_H__
-#define __M32R_MMAN_H__
-
-#include <asm-generic/mman.h>
-
-#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
-#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
-#define MAP_LOCKED	0x2000		/* pages are locked */
-#define MAP_NORESERVE	0x4000		/* don't check for reservations */
-#define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
-#define MAP_NONBLOCK	0x10000		/* do not block on IO */
-
-#define MCL_CURRENT	1		/* lock all current mappings */
-#define MCL_FUTURE	2		/* lock all future mappings */
-
-#endif /* __M32R_MMAN_H__ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mmu.h linux-2.6.30-rc3/include/asm-m32r/mmu.h
--- linux-2.6.30-rc2/include/asm-m32r/mmu.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mmu.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,21 +0,0 @@
-#ifndef _ASM_M32R_MMU_H
-#define _ASM_M32R_MMU_H
-
-#if !defined(CONFIG_MMU)
-
-typedef struct {
-	unsigned long		end_brk;
-} mm_context_t;
-
-#else /* CONFIG_MMU */
-
-/* Default "unsigned long" context */
-#ifndef CONFIG_SMP
-typedef unsigned long mm_context_t;
-#else
-typedef unsigned long mm_context_t[NR_CPUS];
-#endif
-
-#endif /* CONFIG_MMU */
-
-#endif /* _ASM_M32R_MMU_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mmu_context.h linux-2.6.30-rc3/include/asm-m32r/mmu_context.h
--- linux-2.6.30-rc2/include/asm-m32r/mmu_context.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mmu_context.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,164 +0,0 @@
-#ifndef _ASM_M32R_MMU_CONTEXT_H
-#define _ASM_M32R_MMU_CONTEXT_H
-#ifdef __KERNEL__
-
-#include <asm/m32r.h>
-
-#define MMU_CONTEXT_ASID_MASK      (0x000000FF)
-#define MMU_CONTEXT_VERSION_MASK   (0xFFFFFF00)
-#define MMU_CONTEXT_FIRST_VERSION  (0x00000100)
-#define NO_CONTEXT                 (0x00000000)
-
-#ifndef __ASSEMBLY__
-
-#include <asm/atomic.h>
-#include <asm/pgalloc.h>
-#include <asm/mmu.h>
-#include <asm/tlbflush.h>
-#include <asm-generic/mm_hooks.h>
-
-/*
- * Cache of MMU context last used.
- */
-#ifndef CONFIG_SMP
-extern unsigned long mmu_context_cache_dat;
-#define mmu_context_cache	mmu_context_cache_dat
-#define mm_context(mm)		mm->context
-#else /* not CONFIG_SMP */
-extern unsigned long mmu_context_cache_dat[];
-#define mmu_context_cache	mmu_context_cache_dat[smp_processor_id()]
-#define mm_context(mm)		mm->context[smp_processor_id()]
-#endif /* not CONFIG_SMP */
-
-#define set_tlb_tag(entry, tag)		(*entry = (tag & PAGE_MASK)|get_asid())
-#define set_tlb_data(entry, data)	(*entry = (data | _PAGE_PRESENT))
-
-#ifdef CONFIG_MMU
-#define enter_lazy_tlb(mm, tsk)	do { } while (0)
-
-static inline void get_new_mmu_context(struct mm_struct *mm)
-{
-	unsigned long mc = ++mmu_context_cache;
-
-	if (!(mc & MMU_CONTEXT_ASID_MASK)) {
-		/* We exhaust ASID of this version.
-		   Flush all TLB and start new cycle. */
-		local_flush_tlb_all();
-		/* Fix version if needed.
-		   Note that we avoid version #0 to distingush NO_CONTEXT. */
-		if (!mc)
-			mmu_context_cache = mc = MMU_CONTEXT_FIRST_VERSION;
-	}
-	mm_context(mm) = mc;
-}
-
-/*
- * Get MMU context if needed.
- */
-static inline void get_mmu_context(struct mm_struct *mm)
-{
-	if (mm) {
-		unsigned long mc = mmu_context_cache;
-
-		/* Check if we have old version of context.
-		   If it's old, we need to get new context with new version. */
-		if ((mm_context(mm) ^ mc) & MMU_CONTEXT_VERSION_MASK)
-			get_new_mmu_context(mm);
-	}
-}
-
-/*
- * Initialize the context related info for a new mm_struct
- * instance.
- */
-static inline int init_new_context(struct task_struct *tsk,
-	struct mm_struct *mm)
-{
-#ifndef CONFIG_SMP
-	mm->context = NO_CONTEXT;
-#else /* CONFIG_SMP */
-	int num_cpus = num_online_cpus();
-	int i;
-
-	for (i = 0 ; i < num_cpus ; i++)
-		mm->context[i] = NO_CONTEXT;
-#endif /* CONFIG_SMP */
-
-	return 0;
-}
-
-/*
- * Destroy context related info for an mm_struct that is about
- * to be put to rest.
- */
-#define destroy_context(mm)	do { } while (0)
-
-static inline void set_asid(unsigned long asid)
-{
-	*(volatile unsigned long *)MASID = (asid & MMU_CONTEXT_ASID_MASK);
-}
-
-static inline unsigned long get_asid(void)
-{
-	unsigned long asid;
-
-	asid = *(volatile long *)MASID;
-	asid &= MMU_CONTEXT_ASID_MASK;
-
-	return asid;
-}
-
-/*
- * After we have set current->mm to a new value, this activates
- * the context for the new mm so we see the new mappings.
- */
-static inline void activate_context(struct mm_struct *mm)
-{
-	get_mmu_context(mm);
-	set_asid(mm_context(mm) & MMU_CONTEXT_ASID_MASK);
-}
-
-static inline void switch_mm(struct mm_struct *prev,
-	struct mm_struct *next, struct task_struct *tsk)
-{
-#ifdef CONFIG_SMP
-	int cpu = smp_processor_id();
-#endif	/* CONFIG_SMP */
-
-	if (prev != next) {
-#ifdef CONFIG_SMP
-		cpu_set(cpu, next->cpu_vm_mask);
-#endif /* CONFIG_SMP */
-		/* Set MPTB = next->pgd */
-		*(volatile unsigned long *)MPTB = (unsigned long)next->pgd;
-		activate_context(next);
-	}
-#ifdef CONFIG_SMP
-	else
-		if (!cpu_test_and_set(cpu, next->cpu_vm_mask))
-			activate_context(next);
-#endif /* CONFIG_SMP */
-}
-
-#define deactivate_mm(tsk, mm)	do { } while (0)
-
-#define activate_mm(prev, next)	\
-	switch_mm((prev), (next), NULL)
-
-#else /* not CONFIG_MMU */
-#define get_mmu_context(mm)             do { } while (0)
-#define init_new_context(tsk,mm)        (0)
-#define destroy_context(mm)             do { } while (0)
-#define set_asid(asid)                  do { } while (0)
-#define get_asid()                      (0)
-#define activate_context(mm)            do { } while (0)
-#define switch_mm(prev,next,tsk)        do { } while (0)
-#define deactivate_mm(mm,tsk)           do { } while (0)
-#define activate_mm(prev,next)          do { } while (0)
-#define enter_lazy_tlb(mm,tsk)          do { } while (0)
-#endif /* not CONFIG_MMU */
-
-#endif /* not __ASSEMBLY__ */
-
-#endif /* __KERNEL__ */
-#endif /* _ASM_M32R_MMU_CONTEXT_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mmzone.h linux-2.6.30-rc3/include/asm-m32r/mmzone.h
--- linux-2.6.30-rc2/include/asm-m32r/mmzone.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mmzone.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,59 +0,0 @@
-/*
- * Written by Pat Gaughen (gone@us.ibm.com) Mar 2002
- *
- */
-
-#ifndef _ASM_MMZONE_H_
-#define _ASM_MMZONE_H_
-
-#include <asm/smp.h>
-
-#ifdef CONFIG_DISCONTIGMEM
-
-extern struct pglist_data *node_data[];
-#define NODE_DATA(nid)		(node_data[nid])
-
-#define node_localnr(pfn, nid)	((pfn) - NODE_DATA(nid)->node_start_pfn)
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)						\
-({									\
-	pg_data_t *__pgdat = NODE_DATA(nid);				\
-	__pgdat->node_start_pfn + __pgdat->node_spanned_pages - 1;	\
-})
-
-#define pmd_page(pmd)		(pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
-/*
- * pfn_valid should be made as fast as possible, and the current definition
- * is valid for machines that are NUMA, but still contiguous, which is what
- * is currently supported. A more generalised, but slower definition would
- * be something like this - mbligh:
- * ( pfn_to_pgdat(pfn) && ((pfn) < node_end_pfn(pfn_to_nid(pfn))) )
- */
-#if 1	/* M32R_FIXME */
-#define pfn_valid(pfn)	(1)
-#else
-#define pfn_valid(pfn)	((pfn) < num_physpages)
-#endif
-
-/*
- * generic node memory support, the following assumptions apply:
- */
-
-static __inline__ int pfn_to_nid(unsigned long pfn)
-{
-	int node;
-
-	for (node = 0 ; node < MAX_NUMNODES ; node++)
-		if (pfn >= node_start_pfn(node) && pfn <= node_end_pfn(node))
-			break;
-
-	return node;
-}
-
-static __inline__ struct pglist_data *pfn_to_pgdat(unsigned long pfn)
-{
-	return(NODE_DATA(pfn_to_nid(pfn)));
-}
-
-#endif /* CONFIG_DISCONTIGMEM */
-#endif /* _ASM_MMZONE_H_ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/module.h linux-2.6.30-rc3/include/asm-m32r/module.h
--- linux-2.6.30-rc2/include/asm-m32r/module.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/module.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,10 +0,0 @@
-#ifndef _ASM_M32R_MODULE_H
-#define _ASM_M32R_MODULE_H
-
-struct mod_arch_specific { };
-
-#define Elf_Shdr	Elf32_Shdr
-#define Elf_Sym		Elf32_Sym
-#define Elf_Ehdr	Elf32_Ehdr
-
-#endif /* _ASM_M32R_MODULE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/msgbuf.h linux-2.6.30-rc3/include/asm-m32r/msgbuf.h
--- linux-2.6.30-rc2/include/asm-m32r/msgbuf.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/msgbuf.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,31 +0,0 @@
-#ifndef _ASM_M32R_MSGBUF_H
-#define _ASM_M32R_MSGBUF_H
-
-/*
- * The msqid64_ds structure for m32r architecture.
- * Note extra padding because this structure is passed back and forth
- * between kernel and user space.
- *
- * Pad space is left for:
- * - 64-bit time_t to solve y2038 problem
- * - 2 miscellaneous 32-bit values
- */
-
-struct msqid64_ds {
-	struct ipc64_perm msg_perm;
-	__kernel_time_t msg_stime;	/* last msgsnd time */
-	unsigned long	__unused1;
-	__kernel_time_t msg_rtime;	/* last msgrcv time */
-	unsigned long	__unused2;
-	__kernel_time_t msg_ctime;	/* last change time */
-	unsigned long	__unused3;
-	unsigned long  msg_cbytes;	/* current number of bytes on queue */
-	unsigned long  msg_qnum;	/* number of messages in queue */
-	unsigned long  msg_qbytes;	/* max number of bytes on queue */
-	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
-	__kernel_pid_t msg_lrpid;	/* last receive pid */
-	unsigned long  __unused4;
-	unsigned long  __unused5;
-};
-
-#endif /* _ASM_M32R_MSGBUF_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/mutex.h linux-2.6.30-rc3/include/asm-m32r/mutex.h
--- linux-2.6.30-rc2/include/asm-m32r/mutex.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/mutex.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,9 +0,0 @@
-/*
- * Pull in the generic implementation for the mutex fastpath.
- *
- * TODO: implement optimized primitives instead, or leave the generic
- * implementation in place, or pick the atomic_xchg() based generic
- * implementation. (see asm-generic/mutex-xchg.h for details)
- */
-
-#include <asm-generic/mutex-dec.h>
diff -urN linux-2.6.30-rc2/include/asm-m32r/opsput/opsput_lan.h linux-2.6.30-rc3/include/asm-m32r/opsput/opsput_lan.h
--- linux-2.6.30-rc2/include/asm-m32r/opsput/opsput_lan.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/opsput/opsput_lan.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-#ifndef _OPSPUT_OPSPUT_LAN_H
-#define _OPSPUT_OPSPUT_LAN_H
-
-/*
- * include/asm-m32r/opsput/opsput_lan.h
- *
- * OPSPUT-LAN board
- *
- * Copyright (c) 2002-2004	Takeo Takahashi, Mamoru Sakugawa
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#ifndef __ASSEMBLY__
-/*
- * C functions use non-cache address.
- */
-#define OPSPUT_LAN_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
-#else
-#define OPSPUT_LAN_BASE	(0x10000000 + NONCACHE_OFFSET)
-#endif /* __ASSEMBLY__ */
-
-/* ICU
- *  ICUISTS:	status register
- *  ICUIREQ0: 	request register
- *  ICUIREQ1: 	request register
- *  ICUCR3:	control register for CFIREQ# interrupt
- *  ICUCR4:	control register for CFC Card insert interrupt
- *  ICUCR5:	control register for CFC Card eject interrupt
- *  ICUCR6:	control register for external interrupt
- *  ICUCR11:	control register for MMC Card insert/eject interrupt
- *  ICUCR13:	control register for SC error interrupt
- *  ICUCR14:	control register for SC receive interrupt
- *  ICUCR15:	control register for SC send interrupt
- *  ICUCR16:	control register for SIO0 receive interrupt
- *  ICUCR17:	control register for SIO0 send interrupt
- */
-#define OPSPUT_LAN_IRQ_LAN	(OPSPUT_LAN_PLD_IRQ_BASE + 1)	/* LAN */
-#define OPSPUT_LAN_IRQ_I2C	(OPSPUT_LAN_PLD_IRQ_BASE + 3)	/* I2C */
-
-#define OPSPUT_LAN_ICUISTS	__reg16(OPSPUT_LAN_BASE + 0xc0002)
-#define OPSPUT_LAN_ICUISTS_VECB_MASK	(0xf000)
-#define OPSPUT_LAN_VECB(x)	((x) & OPSPUT_LAN_ICUISTS_VECB_MASK)
-#define OPSPUT_LAN_ICUISTS_ISN_MASK	(0x07c0)
-#define OPSPUT_LAN_ICUISTS_ISN(x)	((x) & OPSPUT_LAN_ICUISTS_ISN_MASK)
-#define OPSPUT_LAN_ICUIREQ0	__reg16(OPSPUT_LAN_BASE + 0xc0004)
-#define OPSPUT_LAN_ICUCR1	__reg16(OPSPUT_LAN_BASE + 0xc0010)
-#define OPSPUT_LAN_ICUCR3	__reg16(OPSPUT_LAN_BASE + 0xc0014)
-
-#endif /* _OPSPUT_OPSPUT_LAN_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/opsput/opsput_lcd.h linux-2.6.30-rc3/include/asm-m32r/opsput/opsput_lcd.h
--- linux-2.6.30-rc2/include/asm-m32r/opsput/opsput_lcd.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/opsput/opsput_lcd.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,55 +0,0 @@
-#ifndef _OPSPUT_OPSPUT_LCD_H
-#define _OPSPUT_OPSPUT_LCD_H
-
-/*
- * include/asm-m32r/opsput/opsput_lcd.h
- *
- * OPSPUT-LCD board
- *
- * Copyright (c) 2002	Takeo Takahashi
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#ifndef __ASSEMBLY__
-/*
- * C functions use non-cache address.
- */
-#define OPSPUT_LCD_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
-#else
-#define OPSPUT_LCD_BASE	(0x10000000 + NONCACHE_OFFSET)
-#endif /* __ASSEMBLY__ */
-
-/*
- * ICU
- */
-#define OPSPUT_LCD_IRQ_BAT_INT	(OPSPUT_LCD_PLD_IRQ_BASE + 1)
-#define OPSPUT_LCD_IRQ_USB_INT1	(OPSPUT_LCD_PLD_IRQ_BASE + 2)
-#define OPSPUT_LCD_IRQ_AUDT0		(OPSPUT_LCD_PLD_IRQ_BASE + 3)
-#define OPSPUT_LCD_IRQ_AUDT2		(OPSPUT_LCD_PLD_IRQ_BASE + 4)
-#define OPSPUT_LCD_IRQ_BATSIO_RCV	(OPSPUT_LCD_PLD_IRQ_BASE + 16)
-#define OPSPUT_LCD_IRQ_BATSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 17)
-#define OPSPUT_LCD_IRQ_ASNDSIO_RCV	(OPSPUT_LCD_PLD_IRQ_BASE + 18)
-#define OPSPUT_LCD_IRQ_ASNDSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 19)
-#define OPSPUT_LCD_IRQ_ACNLSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 21)
-
-#define OPSPUT_LCD_ICUISTS	__reg16(OPSPUT_LCD_BASE + 0x300002)
-#define OPSPUT_LCD_ICUISTS_VECB_MASK	(0xf000)
-#define OPSPUT_LCD_VECB(x)	((x) & OPSPUT_LCD_ICUISTS_VECB_MASK)
-#define OPSPUT_LCD_ICUISTS_ISN_MASK	(0x07c0)
-#define OPSPUT_LCD_ICUISTS_ISN(x)	((x) & OPSPUT_LCD_ICUISTS_ISN_MASK)
-#define OPSPUT_LCD_ICUIREQ0	__reg16(OPSPUT_LCD_BASE + 0x300004)
-#define OPSPUT_LCD_ICUIREQ1	__reg16(OPSPUT_LCD_BASE + 0x300006)
-#define OPSPUT_LCD_ICUCR1	__reg16(OPSPUT_LCD_BASE + 0x300020)
-#define OPSPUT_LCD_ICUCR2	__reg16(OPSPUT_LCD_BASE + 0x300022)
-#define OPSPUT_LCD_ICUCR3	__reg16(OPSPUT_LCD_BASE + 0x300024)
-#define OPSPUT_LCD_ICUCR4	__reg16(OPSPUT_LCD_BASE + 0x300026)
-#define OPSPUT_LCD_ICUCR16	__reg16(OPSPUT_LCD_BASE + 0x300030)
-#define OPSPUT_LCD_ICUCR17	__reg16(OPSPUT_LCD_BASE + 0x300032)
-#define OPSPUT_LCD_ICUCR18	__reg16(OPSPUT_LCD_BASE + 0x300034)
-#define OPSPUT_LCD_ICUCR19	__reg16(OPSPUT_LCD_BASE + 0x300036)
-#define OPSPUT_LCD_ICUCR21	__reg16(OPSPUT_LCD_BASE + 0x30003a)
-
-#endif /* _OPSPUT_OPSPUT_LCD_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/opsput/opsput_pld.h linux-2.6.30-rc3/include/asm-m32r/opsput/opsput_pld.h
--- linux-2.6.30-rc2/include/asm-m32r/opsput/opsput_pld.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/opsput/opsput_pld.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,255 +0,0 @@
-#ifndef _OPSPUT_OPSPUT_PLD_H
-#define _OPSPUT_OPSPUT_PLD_H
-
-/*
- * include/asm-m32r/opsput/opsput_pld.h
- *
- * Definitions for Programable Logic Device(PLD) on OPSPUT board.
- *
- * Copyright (c) 2002	Takeo Takahashi
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License.  See the file "COPYING" in the main directory of
- * this archive for more details.
- */
-
-#define PLD_PLAT_BASE		0x1cc00000
-
-#ifndef __ASSEMBLY__
-/*
- * C functions use non-cache address.
- */
-#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
-#define __reg8			(volatile unsigned char *)
-#define __reg16			(volatile unsigned short *)
-#define __reg32			(volatile unsigned int *)
-#else
-#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
-#define __reg8
-#define __reg16
-#define __reg32
-#endif /* __ASSEMBLY__ */
-
-/* CFC */
-#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
-#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
-#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
-#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
-#define PLD_CFVENCR		__reg16(PLD_BASE + 0x0008)
-#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
-#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
-#define PLD_IDERSTCR		__reg16(PLD_BASE + 0x0010)
-
-/* MMC */
-#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
-#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
-#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
-#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
-#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
-#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
-#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
-#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
-#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
-#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
-#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
-#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
-
-/* ICU
- *  ICUISTS:	status register
- *  ICUIREQ0: 	request register
- *  ICUIREQ1: 	request register
- *  ICUCR3:	control register for CFIREQ# interrupt
- *  ICUCR4:	control register for CFC Card insert interrupt
- *  ICUCR5:	control register for CFC Card eject interrupt
- *  ICUCR6:	control register for external interrupt
- *  ICUCR11:	control register for MMC Card insert/eject interrupt
- *  ICUCR13:	control register for SC error interrupt
- *  ICUCR14:	control register for SC receive interrupt
- *  ICUCR15:	control register for SC send interrupt
- *  ICUCR16:	control register for SIO0 receive interrupt
- *  ICUCR17:	control register for SIO0 send interrupt
- */
-#if !defined(CONFIG_PLAT_USRV)
-#define PLD_IRQ_INT0		(OPSPUT_PLD_IRQ_BASE + 0)	/* None */
-#define PLD_IRQ_INT1		(OPSPUT_PLD_IRQ_BASE + 1)	/* reserved */
-#define PLD_IRQ_INT2		(OPSPUT_PLD_IRQ_BASE + 2)	/* reserved */
-#define PLD_IRQ_CFIREQ		(OPSPUT_PLD_IRQ_BASE + 3)	/* CF IREQ */
-#define PLD_IRQ_CFC_INSERT	(OPSPUT_PLD_IRQ_BASE + 4)	/* CF Insert */
-#define PLD_IRQ_CFC_EJECT	(OPSPUT_PLD_IRQ_BASE + 5)	/* CF Eject */
-#define PLD_IRQ_EXINT		(OPSPUT_PLD_IRQ_BASE + 6)	/* EXINT */
-#define PLD_IRQ_INT7		(OPSPUT_PLD_IRQ_BASE + 7)	/* reserved */
-#define PLD_IRQ_INT8		(OPSPUT_PLD_IRQ_BASE + 8)	/* reserved */
-#define PLD_IRQ_INT9		(OPSPUT_PLD_IRQ_BASE + 9)	/* reserved */
-#define PLD_IRQ_INT10		(OPSPUT_PLD_IRQ_BASE + 10)	/* reserved */
-#define PLD_IRQ_MMCCARD		(OPSPUT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
-#define PLD_IRQ_INT12		(OPSPUT_PLD_IRQ_BASE + 12)	/* reserved */
-#define PLD_IRQ_SC_ERROR	(OPSPUT_PLD_IRQ_BASE + 13)	/* SC error */
-#define PLD_IRQ_SC_RCV		(OPSPUT_PLD_IRQ_BASE + 14)	/* SC receive */
-#define PLD_IRQ_SC_SND		(OPSPUT_PLD_IRQ_BASE + 15)	/* SC send */
-#define PLD_IRQ_SIO0_RCV	(OPSPUT_PLD_IRQ_BASE + 16)	/* SIO receive */
-#define PLD_IRQ_SIO0_SND	(OPSPUT_PLD_IRQ_BASE + 17)	/* SIO send */
-#define PLD_IRQ_INT18		(OPSPUT_PLD_IRQ_BASE + 18)	/* reserved */
-#define PLD_IRQ_INT19		(OPSPUT_PLD_IRQ_BASE + 19)	/* reserved */
-#define PLD_IRQ_INT20		(OPSPUT_PLD_IRQ_BASE + 20)	/* reserved */
-#define PLD_IRQ_INT21		(OPSPUT_PLD_IRQ_BASE + 21)	/* reserved */
-#define PLD_IRQ_INT22		(OPSPUT_PLD_IRQ_BASE + 22)	/* reserved */
-#define PLD_IRQ_INT23		(OPSPUT_PLD_IRQ_BASE + 23)	/* reserved */
-#define PLD_IRQ_INT24		(OPSPUT_PLD_IRQ_BASE + 24)	/* reserved */
-#define PLD_IRQ_INT25		(OPSPUT_PLD_IRQ_BASE + 25)	/* reserved */
-#define PLD_IRQ_INT26		(OPSPUT_PLD_IRQ_BASE + 26)	/* reserved */
-#define PLD_IRQ_INT27		(OPSPUT_PLD_IRQ_BASE + 27)	/* reserved */
-#define PLD_IRQ_INT28		(OPSPUT_PLD_IRQ_BASE + 28)	/* reserved */
-#define PLD_IRQ_INT29		(OPSPUT_PLD_IRQ_BASE + 29)	/* reserved */
-#define PLD_IRQ_INT30		(OPSPUT_PLD_IRQ_BASE + 30)	/* reserved */
-#define PLD_IRQ_INT31		(OPSPUT_PLD_IRQ_BASE + 31)	/* reserved */
-
-#else	/* CONFIG_PLAT_USRV */
-
-#define PLD_IRQ_INT0		(OPSPUT_PLD_IRQ_BASE + 0)	/* None */
-#define PLD_IRQ_INT1		(OPSPUT_PLD_IRQ_BASE + 1)	/* reserved */
-#define PLD_IRQ_INT2		(OPSPUT_PLD_IRQ_BASE + 2)	/* reserved */
-#define PLD_IRQ_CF0		(OPSPUT_PLD_IRQ_BASE + 3)	/* CF0# */
-#define PLD_IRQ_CF1		(OPSPUT_PLD_IRQ_BASE + 4)	/* CF1# */
-#define PLD_IRQ_CF2		(OPSPUT_PLD_IRQ_BASE + 5)	/* CF2# */
-#define PLD_IRQ_CF3		(OPSPUT_PLD_IRQ_BASE + 6)	/* CF3# */
-#define PLD_IRQ_CF4		(OPSPUT_PLD_IRQ_BASE + 7)	/* CF4# */
-#define PLD_IRQ_INT8		(OPSPUT_PLD_IRQ_BASE + 8)	/* reserved */
-#define PLD_IRQ_INT9		(OPSPUT_PLD_IRQ_BASE + 9)	/* reserved */
-#define PLD_IRQ_INT10		(OPSPUT_PLD_IRQ_BASE + 10)	/* reserved */
-#define PLD_IRQ_INT11		(OPSPUT_PLD_IRQ_BASE + 11)	/* reserved */
-#define PLD_IRQ_UART0		(OPSPUT_PLD_IRQ_BASE + 12)	/* UARTIRQ0 */
-#define PLD_IRQ_UART1		(OPSPUT_PLD_IRQ_BASE + 13)	/* UARTIRQ1 */
-#define PLD_IRQ_INT14		(OPSPUT_PLD_IRQ_BASE + 14)	/* reserved */
-#define PLD_IRQ_INT15		(OPSPUT_PLD_IRQ_BASE + 15)	/* reserved */
-#define PLD_IRQ_SNDINT		(OPSPUT_PLD_IRQ_BASE + 16)	/* SNDINT# */
-#define PLD_IRQ_INT17		(OPSPUT_PLD_IRQ_BASE + 17)	/* reserved */
-#define PLD_IRQ_INT18		(OPSPUT_PLD_IRQ_BASE + 18)	/* reserved */
-#define PLD_IRQ_INT19		(OPSPUT_PLD_IRQ_BASE + 19)	/* reserved */
-#define PLD_IRQ_INT20		(OPSPUT_PLD_IRQ_BASE + 20)	/* reserved */
-#define PLD_IRQ_INT21		(OPSPUT_PLD_IRQ_BASE + 21)	/* reserved */
-#define PLD_IRQ_INT22		(OPSPUT_PLD_IRQ_BASE + 22)	/* reserved */
-#define PLD_IRQ_INT23		(OPSPUT_PLD_IRQ_BASE + 23)	/* reserved */
-#define PLD_IRQ_INT24		(OPSPUT_PLD_IRQ_BASE + 24)	/* reserved */
-#define PLD_IRQ_INT25		(OPSPUT_PLD_IRQ_BASE + 25)	/* reserved */
-#define PLD_IRQ_INT26		(OPSPUT_PLD_IRQ_BASE + 26)	/* reserved */
-#define PLD_IRQ_INT27		(OPSPUT_PLD_IRQ_BASE + 27)	/* reserved */
-#define PLD_IRQ_INT28		(OPSPUT_PLD_IRQ_BASE + 28)	/* reserved */
-#define PLD_IRQ_INT29		(OPSPUT_PLD_IRQ_BASE + 29)	/* reserved */
-#define PLD_IRQ_INT30		(OPSPUT_PLD_IRQ_BASE + 30)	/* reserved */
-
-#endif	/* CONFIG_PLAT_USRV */
-
-#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
-#define PLD_ICUISTS_VECB_MASK	(0xf000)
-#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
-#define PLD_ICUISTS_ISN_MASK	(0x07c0)
-#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
-#define PLD_ICUIREQ0		__reg16(PLD_BASE + 0x8004)
-#define PLD_ICUIREQ1		__reg16(PLD_BASE + 0x8006)
-#define PLD_ICUCR1		__reg16(PLD_BASE + 0x8100)
-#define PLD_ICUCR2		__reg16(PLD_BASE + 0x8102)
-#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
-#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
-#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
-#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
-#define PLD_ICUCR7		__reg16(PLD_BASE + 0x810c)
-#define PLD_ICUCR8		__reg16(PLD_BASE + 0x810e)
-#define PLD_ICUCR9		__reg16(PLD_BASE + 0x8110)
-#define PLD_ICUCR10		__reg16(PLD_BASE + 0x8112)
-#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
-#define PLD_ICUCR12		__reg16(PLD_BASE + 0x8116)
-#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
-#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
-#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
-#define PLD_ICUCR16		__reg16(PLD_BASE + 0x811e)
-#define PLD_ICUCR17		__reg16(PLD_BASE + 0x8120)
-#define PLD_ICUCR_IEN		(0x1000)
-#define PLD_ICUCR_IREQ		(0x0100)
-#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
-#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
-#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
-#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
-#define PLD_ICUCR_ILEVEL0	(0x0000)
-#define PLD_ICUCR_ILEVEL1	(0x0001)
-#define PLD_ICUCR_ILEVEL2	(0x0002)
-#define PLD_ICUCR_ILEVEL3	(0x0003)
-#define PLD_ICUCR_ILEVEL4	(0x0004)
-#define PLD_ICUCR_ILEVEL5	(0x0005)
-#define PLD_ICUCR_ILEVEL6	(0x0006)
-#define PLD_ICUCR_ILEVEL7	(0x0007)
-
-/* Power Control of MMC and CF */
-#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
-#define PLD_CPCR_CF		0x0001
-#define PLD_CPCR_MMC		0x0002
-
-/* LED Control
- *
- * 1: DIP swich side
- * 2: Reset switch side
- */
-#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
-#define PLD_IOLED_1_ON		0x001
-#define PLD_IOLED_1_OFF		0x000
-#define PLD_IOLED_2_ON		0x002
-#define PLD_IOLED_2_OFF		0x000
-
-/* DIP Switch
- *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
- *  1: -
- *  2: -
- *  3: -
- */
-#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
-#define	PLD_IOSWSTS_IOSW2	0x0200
-#define	PLD_IOSWSTS_IOSW1	0x0100
-#define	PLD_IOSWSTS_IOWP0	0x0001
-
-/* CRC */
-#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
-#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
-#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
-#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
-#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
-#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
-
-/* RTC */
-#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
-#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
-#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
-#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
-#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
-
-/* SIO0 */
-#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
-#define	PLD_ESIO0CR_TXEN	0x0001
-#define	PLD_ESIO0CR_RXEN	0x0002
-#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
-#define	PLD_ESIO0MOD0_CTSS	0x0040
-#define	PLD_ESIO0MOD0_RTSS	0x0080
-#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
-#define	PLD_ESIO0MOD1_LMFS	0x0010
-#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
-#define	PLD_ESIO0STS_TEMP	0x0001
-#define	PLD_ESIO0STS_TXCP	0x0002
-#define	PLD_ESIO0STS_RXCP	0x0004
-#define	PLD_ESIO0STS_TXSC	0x0100
-#define	PLD_ESIO0STS_RXSC	0x0200
-#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
-#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
-#define	PLD_ESIO0INTCR_TXIEN	0x0002
-#define	PLD_ESIO0INTCR_RXCEN	0x0004
-#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
-#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
-#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
-
-/* SIM Card */
-#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
-#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
-#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
-#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
-#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
-#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
-#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
-
-#endif /* _OPSPUT_OPSPUT_PLD.H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/page.h linux-2.6.30-rc3/include/asm-m32r/page.h
--- linux-2.6.30-rc2/include/asm-m32r/page.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/page.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,87 +0,0 @@
-#ifndef _ASM_M32R_PAGE_H
-#define _ASM_M32R_PAGE_H
-
-/* PAGE_SHIFT determines the page size */
-#define PAGE_SHIFT	12
-#define PAGE_SIZE	(1UL << PAGE_SHIFT)
-#define PAGE_MASK	(~(PAGE_SIZE-1))
-
-#ifndef __ASSEMBLY__
-
-extern void clear_page(void *to);
-extern void copy_page(void *to, void *from);
-
-#define clear_user_page(page, vaddr, pg)	clear_page(page)
-#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
-
-#define __alloc_zeroed_user_highpage(movableflags, vma, vaddr) \
-	alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr)
-#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
-
-/*
- * These are used to make use of C type-checking..
- */
-typedef struct { unsigned long pte; } pte_t;
-typedef struct { unsigned long pmd; } pmd_t;
-typedef struct { unsigned long pgd; } pgd_t;
-#define pte_val(x)	((x).pte)
-#define PTE_MASK	PAGE_MASK
-
-typedef struct { unsigned long pgprot; } pgprot_t;
-typedef struct page *pgtable_t;
-
-#define pmd_val(x)	((x).pmd)
-#define pgd_val(x)	((x).pgd)
-#define pgprot_val(x)	((x).pgprot)
-
-#define __pte(x) ((pte_t) { (x) } )
-#define __pmd(x) ((pmd_t) { (x) } )
-#define __pgd(x) ((pgd_t) { (x) } )
-#define __pgprot(x)	((pgprot_t) { (x) } )
-
-#endif /* !__ASSEMBLY__ */
-
-/*
- * This handles the memory map.. We could make this a config
- * option, but too many people screw it up, and too few need
- * it.
- *
- * A __PAGE_OFFSET of 0xC0000000 means that the kernel has
- * a virtual address space of one gigabyte, which limits the
- * amount of physical memory you can use to about 950MB.
- *
- * If you want more physical memory than this then see the CONFIG_HIGHMEM4G
- * and CONFIG_HIGHMEM64G options in the kernel configuration.
- */
-
-#define __MEMORY_START  CONFIG_MEMORY_START
-#define __MEMORY_SIZE   CONFIG_MEMORY_SIZE
-
-#ifdef CONFIG_MMU
-#define __PAGE_OFFSET  (0x80000000)
-#else
-#define __PAGE_OFFSET  (0x00000000)
-#endif
-
-#define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
-#define __pa(x)			((unsigned long)(x) - PAGE_OFFSET)
-#define __va(x)			((void *)((unsigned long)(x) + PAGE_OFFSET))
-
-#ifndef CONFIG_DISCONTIGMEM
-#define PFN_BASE		(CONFIG_MEMORY_START >> PAGE_SHIFT)
-#define ARCH_PFN_OFFSET		PFN_BASE
-#define pfn_valid(pfn)		(((pfn) - PFN_BASE) < max_mapnr)
-#endif  /* !CONFIG_DISCONTIGMEM */
-
-#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
-#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
-
-#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
-				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC )
-
-#define devmem_is_allowed(x) 1
-
-#include <asm-generic/memory_model.h>
-#include <asm-generic/page.h>
-
-#endif /* _ASM_M32R_PAGE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/param.h linux-2.6.30-rc3/include/asm-m32r/param.h
--- linux-2.6.30-rc2/include/asm-m32r/param.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/param.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,23 +0,0 @@
-#ifndef _ASM_M32R_PARAM_H
-#define _ASM_M32R_PARAM_H
-
-#ifdef __KERNEL__
-# define HZ		CONFIG_HZ	/* Internal kernel timer frequency */
-# define USER_HZ	100		/* .. some user interfaces are in "ticks" */
-# define CLOCKS_PER_SEC	(USER_HZ)	/* like times() */
-#endif
-
-#ifndef HZ
-#define HZ 100
-#endif
-
-#define EXEC_PAGESIZE	4096
-
-#ifndef NOGROUP
-#define NOGROUP		(-1)
-#endif
-
-#define MAXHOSTNAMELEN	64	/* max length of hostname */
-
-#endif /* _ASM_M32R_PARAM_H */
-
diff -urN linux-2.6.30-rc2/include/asm-m32r/pci.h linux-2.6.30-rc3/include/asm-m32r/pci.h
--- linux-2.6.30-rc2/include/asm-m32r/pci.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/pci.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-#ifndef _ASM_M32R_PCI_H
-#define _ASM_M32R_PCI_H
-
-#include <asm-generic/pci.h>
-
-#define PCI_DMA_BUS_IS_PHYS	(1)
-
-#endif /* _ASM_M32R_PCI_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/percpu.h linux-2.6.30-rc3/include/asm-m32r/percpu.h
--- linux-2.6.30-rc2/include/asm-m32r/percpu.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/percpu.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef __ARCH_M32R_PERCPU__
-#define __ARCH_M32R_PERCPU__
-
-#include <asm-generic/percpu.h>
-
-#endif /* __ARCH_M32R_PERCPU__ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/pgalloc.h linux-2.6.30-rc3/include/asm-m32r/pgalloc.h
--- linux-2.6.30-rc2/include/asm-m32r/pgalloc.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/pgalloc.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,76 +0,0 @@
-#ifndef _ASM_M32R_PGALLOC_H
-#define _ASM_M32R_PGALLOC_H
-
-#include <linux/mm.h>
-
-#include <asm/io.h>
-
-#define pmd_populate_kernel(mm, pmd, pte)	\
-	set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
-
-static __inline__ void pmd_populate(struct mm_struct *mm, pmd_t *pmd,
-	pgtable_t pte)
-{
-	set_pmd(pmd, __pmd(_PAGE_TABLE + page_to_phys(pte)));
-}
-#define pmd_pgtable(pmd) pmd_page(pmd)
-
-/*
- * Allocate and free page tables.
- */
-static __inline__ pgd_t *pgd_alloc(struct mm_struct *mm)
-{
-	pgd_t *pgd = (pgd_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
-
-	return pgd;
-}
-
-static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
-{
-	free_page((unsigned long)pgd);
-}
-
-static __inline__ pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
-	unsigned long address)
-{
-	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
-
-	return pte;
-}
-
-static __inline__ pgtable_t pte_alloc_one(struct mm_struct *mm,
-	unsigned long address)
-{
-	struct page *pte = alloc_page(GFP_KERNEL|__GFP_ZERO);
-
-	pgtable_page_ctor(pte);
-	return pte;
-}
-
-static inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
-{
-	free_page((unsigned long)pte);
-}
-
-static inline void pte_free(struct mm_struct *mm, pgtable_t pte)
-{
-	pgtable_page_dtor(pte);
-	__free_page(pte);
-}
-
-#define __pte_free_tlb(tlb, pte)	pte_free((tlb)->mm, (pte))
-
-/*
- * allocating and freeing a pmd is trivial: the 1-entry pmd is
- * inside the pgd, so has no extra memory associated with it.
- * (In the PAE case we free the pmds as part of the pgd.)
- */
-
-#define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
-#define pmd_free(mm, x)			do { } while (0)
-#define __pmd_free_tlb(tlb, x)		do { } while (0)
-#define pgd_populate(mm, pmd, pte)	BUG()
-
-#define check_pgt_cache()	do { } while (0)
-
-#endif /* _ASM_M32R_PGALLOC_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/pgtable-2level.h linux-2.6.30-rc3/include/asm-m32r/pgtable-2level.h
--- linux-2.6.30-rc2/include/asm-m32r/pgtable-2level.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/pgtable-2level.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,78 +0,0 @@
-#ifndef _ASM_M32R_PGTABLE_2LEVEL_H
-#define _ASM_M32R_PGTABLE_2LEVEL_H
-#ifdef __KERNEL__
-
-/*
- * traditional M32R two-level paging structure:
- */
-
-#define PGDIR_SHIFT	22
-#define PTRS_PER_PGD	1024
-
-/*
- * the M32R is two-level, so we don't really have any
- * PMD directory physically.
- */
-#define PMD_SHIFT	22
-#define PTRS_PER_PMD	1
-
-#define PTRS_PER_PTE	1024
-
-#define pte_ERROR(e) \
-	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
-#define pmd_ERROR(e) \
-	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
-#define pgd_ERROR(e) \
-	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
-
-/*
- * The "pgd_xxx()" functions here are trivial for a folded two-level
- * setup: the pgd is never bad, and a pmd always exists (as it's folded
- * into the pgd entry)
- */
-static inline int pgd_none(pgd_t pgd)	{ return 0; }
-static inline int pgd_bad(pgd_t pgd)	{ return 0; }
-static inline int pgd_present(pgd_t pgd)	{ return 1; }
-#define pgd_clear(xp)				do { } while (0)
-
-/*
- * Certain architectures need to do special things when PTEs
- * within a page table are directly modified.  Thus, the following
- * hook is made available.
- */
-#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
-#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
-
-/*
- * (pmds are folded into pgds so this doesnt get actually called,
- * but the define is needed for a generic inline function.)
- */
-#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
-#define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
-
-#define pgd_page_vaddr(pgd) \
-((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
-
-#ifndef CONFIG_DISCONTIGMEM
-#define pgd_page(pgd)	(mem_map + ((pgd_val(pgd) >> PAGE_SHIFT) - PFN_BASE))
-#endif /* !CONFIG_DISCONTIGMEM */
-
-static inline pmd_t *pmd_offset(pgd_t * dir, unsigned long address)
-{
-	return (pmd_t *) dir;
-}
-
-#define ptep_get_and_clear(mm,addr,xp)	__pte(xchg(&(xp)->pte, 0))
-#define pte_same(a, b)		(pte_val(a) == pte_val(b))
-#define pte_page(x)		pfn_to_page(pte_pfn(x))
-#define pte_none(x)		(!pte_val(x))
-#define pte_pfn(x)		(pte_val(x) >> PAGE_SHIFT)
-#define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
-#define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
-
-#define PTE_FILE_MAX_BITS	29
-#define pte_to_pgoff(pte)	(((pte_val(pte) >> 2) & 0x7f) | (((pte_val(pte) >> 10)) << 7))
-#define pgoff_to_pte(off)	((pte_t) { (((off) & 0x7f) << 2) | (((off) >> 7) << 10) | _PAGE_FILE })
-
-#endif /* __KERNEL__ */
-#endif /* _ASM_M32R_PGTABLE_2LEVEL_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/pgtable.h linux-2.6.30-rc3/include/asm-m32r/pgtable.h
--- linux-2.6.30-rc2/include/asm-m32r/pgtable.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/pgtable.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,363 +0,0 @@
-#ifndef _ASM_M32R_PGTABLE_H
-#define _ASM_M32R_PGTABLE_H
-
-#include <asm-generic/4level-fixup.h>
-
-#ifdef __KERNEL__
-/*
- * The Linux memory management assumes a three-level page table setup. On
- * the M32R, we use that, but "fold" the mid level into the top-level page
- * table, so that we physically have the same two-level page table as the
- * M32R mmu expects.
- *
- * This file contains the functions and defines necessary to modify and use
- * the M32R page table tree.
- */
-
-/* CAUTION!: If you change macro definitions in this file, you might have to
- * change arch/m32r/mmu.S manually.
- */
-
-#ifndef __ASSEMBLY__
-
-#include <linux/threads.h>
-#include <linux/bitops.h>
-#include <asm/processor.h>
-#include <asm/addrspace.h>
-#include <asm/page.h>
-
-struct mm_struct;
-struct vm_area_struct;
-
-extern pgd_t swapper_pg_dir[1024];
-extern void paging_init(void);
-
-/*
- * ZERO_PAGE is a global shared page that is always zero: used
- * for zero-mapped memory areas etc..
- */
-extern unsigned long empty_zero_page[1024];
-#define ZERO_PAGE(vaddr)	(virt_to_page(empty_zero_page))
-
-#endif /* !__ASSEMBLY__ */
-
-#ifndef __ASSEMBLY__
-#include <asm/pgtable-2level.h>
-#endif
-
-#define pgtable_cache_init()	do { } while (0)
-
-#define PMD_SIZE	(1UL << PMD_SHIFT)
-#define PMD_MASK	(~(PMD_SIZE - 1))
-#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
-#define PGDIR_MASK	(~(PGDIR_SIZE - 1))
-
-#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
-#define FIRST_USER_ADDRESS	0
-
-#ifndef __ASSEMBLY__
-/* Just any arbitrary offset to the start of the vmalloc VM area: the
- * current 8MB value just means that there will be a 8MB "hole" after the
- * physical memory until the kernel virtual memory starts.  That means that
- * any out-of-bounds memory accesses will hopefully be caught.
- * The vmalloc() routines leaves a hole of 4kB between each vmalloced
- * area for the same reason. ;)
- */
-#define VMALLOC_START		KSEG2
-#define VMALLOC_END		KSEG3
-
-/*
- *     M32R TLB format
- *
- *     [0]    [1:19]           [20:23]       [24:31]
- *     +-----------------------+----+-------------+
- *     |          VPN          |0000|    ASID     |
- *     +-----------------------+----+-------------+
- *     +-+---------------------+----+-+---+-+-+-+-+
- *     |0         PPN          |0000|N|AC |L|G|V| |
- *     +-+---------------------+----+-+---+-+-+-+-+
- *                                     RWX
- */
-
-#define _PAGE_BIT_DIRTY		0	/* software: page changed */
-#define _PAGE_BIT_FILE		0	/* when !present: nonlinear file
-					   mapping */
-#define _PAGE_BIT_PRESENT	1	/* Valid: page is valid */
-#define _PAGE_BIT_GLOBAL	2	/* Global */
-#define _PAGE_BIT_LARGE		3	/* Large */
-#define _PAGE_BIT_EXEC		4	/* Execute */
-#define _PAGE_BIT_WRITE		5	/* Write */
-#define _PAGE_BIT_READ		6	/* Read */
-#define _PAGE_BIT_NONCACHABLE	7	/* Non cachable */
-#define _PAGE_BIT_ACCESSED	8	/* software: page referenced */
-#define _PAGE_BIT_PROTNONE	9	/* software: if not present */
-
-#define _PAGE_DIRTY		(1UL << _PAGE_BIT_DIRTY)
-#define _PAGE_FILE		(1UL << _PAGE_BIT_FILE)
-#define _PAGE_PRESENT		(1UL << _PAGE_BIT_PRESENT)
-#define _PAGE_GLOBAL		(1UL << _PAGE_BIT_GLOBAL)
-#define _PAGE_LARGE		(1UL << _PAGE_BIT_LARGE)
-#define _PAGE_EXEC		(1UL << _PAGE_BIT_EXEC)
-#define _PAGE_WRITE		(1UL << _PAGE_BIT_WRITE)
-#define _PAGE_READ		(1UL << _PAGE_BIT_READ)
-#define _PAGE_NONCACHABLE	(1UL << _PAGE_BIT_NONCACHABLE)
-#define _PAGE_ACCESSED		(1UL << _PAGE_BIT_ACCESSED)
-#define _PAGE_PROTNONE		(1UL << _PAGE_BIT_PROTNONE)
-
-#define _PAGE_TABLE	\
-	( _PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_ACCESSED \
-	| _PAGE_DIRTY )
-#define _KERNPG_TABLE	\
-	( _PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_ACCESSED \
-	| _PAGE_DIRTY )
-#define _PAGE_CHG_MASK	\
-	( PTE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY )
-
-#ifdef CONFIG_MMU
-#define PAGE_NONE	\
-	__pgprot(_PAGE_PROTNONE | _PAGE_ACCESSED)
-#define PAGE_SHARED	\
-	__pgprot(_PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_ACCESSED)
-#define PAGE_SHARED_EXEC \
-	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_WRITE | _PAGE_READ \
-		| _PAGE_ACCESSED)
-#define PAGE_COPY	\
-	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_ACCESSED)
-#define PAGE_COPY_EXEC	\
-	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_ACCESSED)
-#define PAGE_READONLY	\
-	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_ACCESSED)
-#define PAGE_READONLY_EXEC \
-	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_ACCESSED)
-
-#define __PAGE_KERNEL	\
-	( _PAGE_PRESENT | _PAGE_EXEC | _PAGE_WRITE | _PAGE_READ | _PAGE_DIRTY \
-	| _PAGE_ACCESSED )
-#define __PAGE_KERNEL_RO	( __PAGE_KERNEL & ~_PAGE_WRITE )
-#define __PAGE_KERNEL_NOCACHE	( __PAGE_KERNEL | _PAGE_NONCACHABLE)
-
-#define MAKE_GLOBAL(x)	__pgprot((x) | _PAGE_GLOBAL)
-
-#define PAGE_KERNEL		MAKE_GLOBAL(__PAGE_KERNEL)
-#define PAGE_KERNEL_RO		MAKE_GLOBAL(__PAGE_KERNEL_RO)
-#define PAGE_KERNEL_NOCACHE	MAKE_GLOBAL(__PAGE_KERNEL_NOCACHE)
-
-#else
-#define PAGE_NONE		__pgprot(0)
-#define PAGE_SHARED		__pgprot(0)
-#define PAGE_SHARED_EXEC	__pgprot(0)
-#define PAGE_COPY		__pgprot(0)
-#define PAGE_COPY_EXEC		__pgprot(0)
-#define PAGE_READONLY		__pgprot(0)
-#define PAGE_READONLY_EXEC	__pgprot(0)
-
-#define PAGE_KERNEL		__pgprot(0)
-#define PAGE_KERNEL_RO		__pgprot(0)
-#define PAGE_KERNEL_NOCACHE	__pgprot(0)
-#endif /* CONFIG_MMU */
-
-	/* xwr */
-#define __P000	PAGE_NONE
-#define __P001	PAGE_READONLY
-#define __P010	PAGE_COPY
-#define __P011	PAGE_COPY
-#define __P100	PAGE_READONLY_EXEC
-#define __P101	PAGE_READONLY_EXEC
-#define __P110	PAGE_COPY_EXEC
-#define __P111	PAGE_COPY_EXEC
-
-#define __S000	PAGE_NONE
-#define __S001	PAGE_READONLY
-#define __S010	PAGE_SHARED
-#define __S011	PAGE_SHARED
-#define __S100	PAGE_READONLY_EXEC
-#define __S101	PAGE_READONLY_EXEC
-#define __S110	PAGE_SHARED_EXEC
-#define __S111	PAGE_SHARED_EXEC
-
-/* page table for 0-4MB for everybody */
-
-#define pte_present(x)	(pte_val(x) & (_PAGE_PRESENT | _PAGE_PROTNONE))
-#define pte_clear(mm,addr,xp)	do { set_pte_at(mm, addr, xp, __pte(0)); } while (0)
-
-#define pmd_none(x)	(!pmd_val(x))
-#define pmd_present(x)	(pmd_val(x) & _PAGE_PRESENT)
-#define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)
-#define	pmd_bad(x)	((pmd_val(x) & ~PAGE_MASK) != _KERNPG_TABLE)
-
-#define pages_to_mb(x)	((x) >> (20 - PAGE_SHIFT))
-
-/*
- * The following only work if pte_present() is true.
- * Undefined behaviour if not..
- */
-static inline int pte_dirty(pte_t pte)
-{
-	return pte_val(pte) & _PAGE_DIRTY;
-}
-
-static inline int pte_young(pte_t pte)
-{
-	return pte_val(pte) & _PAGE_ACCESSED;
-}
-
-static inline int pte_write(pte_t pte)
-{
-	return pte_val(pte) & _PAGE_WRITE;
-}
-
-/*
- * The following only works if pte_present() is not true.
- */
-static inline int pte_file(pte_t pte)
-{
-	return pte_val(pte) & _PAGE_FILE;
-}
-
-static inline int pte_special(pte_t pte)
-{
-	return 0;
-}
-
-static inline pte_t pte_mkclean(pte_t pte)
-{
-	pte_val(pte) &= ~_PAGE_DIRTY;
-	return pte;
-}
-
-static inline pte_t pte_mkold(pte_t pte)
-{
-	pte_val(pte) &= ~_PAGE_ACCESSED;
-	return pte;
-}
-
-static inline pte_t pte_wrprotect(pte_t pte)
-{
-	pte_val(pte) &= ~_PAGE_WRITE;
-	return pte;
-}
-
-static inline pte_t pte_mkdirty(pte_t pte)
-{
-	pte_val(pte) |= _PAGE_DIRTY;
-	return pte;
-}
-
-static inline pte_t pte_mkyoung(pte_t pte)
-{
-	pte_val(pte) |= _PAGE_ACCESSED;
-	return pte;
-}
-
-static inline pte_t pte_mkwrite(pte_t pte)
-{
-	pte_val(pte) |= _PAGE_WRITE;
-	return pte;
-}
-
-static inline pte_t pte_mkspecial(pte_t pte)
-{
-	return pte;
-}
-
-static inline  int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned long addr, pte_t *ptep)
-{
-	return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep);
-}
-
-static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
-{
-	clear_bit(_PAGE_BIT_WRITE, ptep);
-}
-
-/*
- * Macro and implementation to make a page protection as uncachable.
- */
-static inline pgprot_t pgprot_noncached(pgprot_t _prot)
-{
-	unsigned long prot = pgprot_val(_prot);
-
-	prot |= _PAGE_NONCACHABLE;
-	return __pgprot(prot);
-}
-
-#define pgprot_writecombine(prot) pgprot_noncached(prot)
-
-/*
- * Conversion functions: convert a page and protection to a page entry,
- * and a page entry and page directory to the page they refer to.
- */
-#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), pgprot)
-
-static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
-{
-	set_pte(&pte, __pte((pte_val(pte) & _PAGE_CHG_MASK) \
-		| pgprot_val(newprot)));
-
-	return pte;
-}
-
-/*
- * Conversion functions: convert a page and protection to a page entry,
- * and a page entry and page directory to the page they refer to.
- */
-
-static inline void pmd_set(pmd_t * pmdp, pte_t * ptep)
-{
-	pmd_val(*pmdp) = (((unsigned long) ptep) & PAGE_MASK);
-}
-
-#define pmd_page_vaddr(pmd)	\
-	((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
-
-#ifndef CONFIG_DISCONTIGMEM
-#define pmd_page(pmd)	(mem_map + ((pmd_val(pmd) >> PAGE_SHIFT) - PFN_BASE))
-#endif /* !CONFIG_DISCONTIGMEM */
-
-/* to find an entry in a page-table-directory. */
-#define pgd_index(address)	\
-	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
-
-#define pgd_offset(mm, address)	((mm)->pgd + pgd_index(address))
-
-/* to find an entry in a kernel page-table-directory */
-#define pgd_offset_k(address)	pgd_offset(&init_mm, address)
-
-#define pmd_index(address)	\
-	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD - 1))
-
-#define pte_index(address)	\
-	(((address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
-#define pte_offset_kernel(dir, address)	\
-	((pte_t *)pmd_page_vaddr(*(dir)) + pte_index(address))
-#define pte_offset_map(dir, address)	\
-	((pte_t *)page_address(pmd_page(*(dir))) + pte_index(address))
-#define pte_offset_map_nested(dir, address)	pte_offset_map(dir, address)
-#define pte_unmap(pte)		do { } while (0)
-#define pte_unmap_nested(pte)	do { } while (0)
-
-/* Encode and de-code a swap entry */
-#define __swp_type(x)			(((x).val >> 2) & 0x1f)
-#define __swp_offset(x)			((x).val >> 10)
-#define __swp_entry(type, offset)	\
-	((swp_entry_t) { ((type) << 2) | ((offset) << 10) })
-#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })
-#define __swp_entry_to_pte(x)		((pte_t) { (x).val })
-
-#endif /* !__ASSEMBLY__ */
-
-/* Needs to be defined here and not in linux/mm.h, as it is arch dependent */
-#define kern_addr_valid(addr)	(1)
-
-#define io_remap_pfn_range(vma, vaddr, pfn, size, prot)	\
-		remap_pfn_range(vma, vaddr, pfn, size, prot)
-
-#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG
-#define __HAVE_ARCH_PTEP_GET_AND_CLEAR
-#define __HAVE_ARCH_PTEP_SET_WRPROTECT
-#define __HAVE_ARCH_PTE_SAME
-#include <asm-generic/pgtable.h>
-
-#endif /* __KERNEL__ */
-
-#endif /* _ASM_M32R_PGTABLE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/poll.h linux-2.6.30-rc3/include/asm-m32r/poll.h
--- linux-2.6.30-rc2/include/asm-m32r/poll.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/poll.h	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-#include <asm-generic/poll.h>
diff -urN linux-2.6.30-rc2/include/asm-m32r/posix_types.h linux-2.6.30-rc3/include/asm-m32r/posix_types.h
--- linux-2.6.30-rc2/include/asm-m32r/posix_types.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/posix_types.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,118 +0,0 @@
-#ifndef _ASM_M32R_POSIX_TYPES_H
-#define _ASM_M32R_POSIX_TYPES_H
-
-/*
- * This file is generally used by user-level software, so you need to
- * be a little careful about namespace pollution etc.  Also, we cannot
- * assume GCC is being used.
- */
-
-typedef unsigned long	__kernel_ino_t;
-typedef unsigned short	__kernel_mode_t;
-typedef unsigned short	__kernel_nlink_t;
-typedef long		__kernel_off_t;
-typedef int		__kernel_pid_t;
-typedef unsigned short	__kernel_ipc_pid_t;
-typedef unsigned short	__kernel_uid_t;
-typedef unsigned short	__kernel_gid_t;
-typedef unsigned int	__kernel_size_t;
-typedef int		__kernel_ssize_t;
-typedef int		__kernel_ptrdiff_t;
-typedef long		__kernel_time_t;
-typedef long		__kernel_suseconds_t;
-typedef long		__kernel_clock_t;
-typedef int		__kernel_timer_t;
-typedef int		__kernel_clockid_t;
-typedef int		__kernel_daddr_t;
-typedef char *		__kernel_caddr_t;
-typedef unsigned short	__kernel_uid16_t;
-typedef unsigned short	__kernel_gid16_t;
-typedef unsigned int	__kernel_uid32_t;
-typedef unsigned int	__kernel_gid32_t;
-
-typedef unsigned short	__kernel_old_uid_t;
-typedef unsigned short	__kernel_old_gid_t;
-typedef unsigned short	__kernel_old_dev_t;
-
-#ifdef __GNUC__
-typedef long long	__kernel_loff_t;
-#endif
-
-typedef struct {
-	int	val[2];
-} __kernel_fsid_t;
-
-#if defined(__KERNEL__)
-
-#undef	__FD_SET
-static __inline__ void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
-{
-	unsigned long __tmp = __fd / __NFDBITS;
-	unsigned long __rem = __fd % __NFDBITS;
-	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
-}
-
-#undef	__FD_CLR
-static __inline__ void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
-{
-	unsigned long __tmp = __fd / __NFDBITS;
-	unsigned long __rem = __fd % __NFDBITS;
-	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
-}
-
-
-#undef	__FD_ISSET
-static __inline__ int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__p)
-{
-	unsigned long __tmp = __fd / __NFDBITS;
-	unsigned long __rem = __fd % __NFDBITS;
-	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
-}
-
-/*
- * This will unroll the loop for the normal constant case (8 ints,
- * for a 256-bit fd_set)
- */
-#undef	__FD_ZERO
-static __inline__ void __FD_ZERO(__kernel_fd_set *__p)
-{
-	unsigned long *__tmp = __p->fds_bits;
-	int __i;
-
-	if (__builtin_constant_p(__FDSET_LONGS)) {
-		switch (__FDSET_LONGS) {
-		case 16:
-			__tmp[ 0] = 0; __tmp[ 1] = 0;
-			__tmp[ 2] = 0; __tmp[ 3] = 0;
-			__tmp[ 4] = 0; __tmp[ 5] = 0;
-			__tmp[ 6] = 0; __tmp[ 7] = 0;
-			__tmp[ 8] = 0; __tmp[ 9] = 0;
-			__tmp[10] = 0; __tmp[11] = 0;
-			__tmp[12] = 0; __tmp[13] = 0;
-			__tmp[14] = 0; __tmp[15] = 0;
-			return;
-
-		case 8:
-			__tmp[ 0] = 0; __tmp[ 1] = 0;
-			__tmp[ 2] = 0; __tmp[ 3] = 0;
-			__tmp[ 4] = 0; __tmp[ 5] = 0;
-			__tmp[ 6] = 0; __tmp[ 7] = 0;
-			return;
-
-		case 4:
-			__tmp[ 0] = 0; __tmp[ 1] = 0;
-			__tmp[ 2] = 0; __tmp[ 3] = 0;
-			return;
-		}
-	}
-	__i = __FDSET_LONGS;
-	while (__i) {
-		__i--;
-		*__tmp = 0;
-		__tmp++;
-	}
-}
-
-#endif /* defined(__KERNEL__) */
-
-#endif  /* _ASM_M32R_POSIX_TYPES_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/processor.h linux-2.6.30-rc3/include/asm-m32r/processor.h
--- linux-2.6.30-rc2/include/asm-m32r/processor.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/processor.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,147 +0,0 @@
-#ifndef _ASM_M32R_PROCESSOR_H
-#define _ASM_M32R_PROCESSOR_H
-
-/*
- * include/asm-m32r/processor.h
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1994  Linus Torvalds
- * Copyright (C) 2001  Hiroyuki Kondo, Hirokazu Takata, and Hitoshi Yamamoto
- * Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#include <linux/kernel.h>
-#include <asm/cache.h>
-#include <asm/ptrace.h>  /* pt_regs */
-
-/*
- * Default implementation of macro that returns current
- * instruction pointer ("program counter").
- */
-#define current_text_addr() ({ __label__ _l; _l: &&_l; })
-
-/*
- *  CPU type and hardware bug flags. Kept separately for each CPU.
- *  Members of this structure are referenced in head.S, so think twice
- *  before touching them. [mj]
- */
-
-struct cpuinfo_m32r {
-	unsigned long pgtable_cache_sz;
-	unsigned long cpu_clock;
-	unsigned long bus_clock;
-	unsigned long timer_divide;
-	unsigned long loops_per_jiffy;
-};
-
-/*
- * capabilities of CPUs
- */
-
-extern struct cpuinfo_m32r boot_cpu_data;
-
-#ifdef CONFIG_SMP
-extern struct cpuinfo_m32r cpu_data[];
-#define current_cpu_data cpu_data[smp_processor_id()]
-#else
-#define cpu_data (&boot_cpu_data)
-#define current_cpu_data boot_cpu_data
-#endif
-
-/*
- * User space process size: 2GB (default).
- */
-#ifdef CONFIG_MMU
-#define TASK_SIZE  (0x80000000UL)
-#else
-#define TASK_SIZE  (0x00400000UL)
-#endif
-
-#ifdef __KERNEL__
-#define STACK_TOP	TASK_SIZE
-#define STACK_TOP_MAX	STACK_TOP
-#endif
-
-/* This decides where the kernel will search for a free chunk of vm
- * space during mmap's.
- */
-#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
-
-typedef struct {
-	unsigned long seg;
-} mm_segment_t;
-
-#define MAX_TRAPS 10
-
-struct debug_trap {
-	int nr_trap;
-	unsigned long	addr[MAX_TRAPS];
-	unsigned long	insn[MAX_TRAPS];
-};
-
-struct thread_struct {
-	unsigned long address;
-	unsigned long trap_no;		/* Trap number  */
-	unsigned long error_code;	/* Error code of trap */
-	unsigned long lr;		/* saved pc */
-	unsigned long sp;		/* user stack pointer */
-	struct debug_trap debug_trap;
-};
-
-#define INIT_SP	(sizeof(init_stack) + (unsigned long) &init_stack)
-
-#define INIT_THREAD	{	\
-	.sp = INIT_SP,		\
-}
-
-/*
- * Do necessary setup to start up a newly executed thread.
- */
-
-/* User process Backup PSW */
-#define USERPS_BPSW (M32R_PSW_BSM|M32R_PSW_BIE|M32R_PSW_BPM)
-
-#define start_thread(regs, new_pc, new_spu) 				\
-	do {								\
-		set_fs(USER_DS); 					\
-		regs->psw = (regs->psw | USERPS_BPSW) & 0x0000FFFFUL;	\
-		regs->bpc = new_pc;					\
-		regs->spu = new_spu;					\
-	} while (0)
-
-/* Forward declaration, a strange C thing */
-struct task_struct;
-struct mm_struct;
-
-/* Free all resources held by a thread. */
-extern void release_thread(struct task_struct *);
-
-#define prepare_to_copy(tsk)	do { } while (0)
-
-/*
- * create a kernel thread without removing it from tasklists
- */
-extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
-
-/* Copy and release all segment info associated with a VM */
-extern void copy_segments(struct task_struct *p, struct mm_struct * mm);
-extern void release_segments(struct mm_struct * mm);
-
-extern unsigned long thread_saved_pc(struct task_struct *);
-
-/* Copy and release all segment info associated with a VM */
-#define copy_segments(p, mm)  do { } while (0)
-#define release_segments(mm)  do { } while (0)
-
-unsigned long get_wchan(struct task_struct *p);
-#define KSTK_EIP(tsk)  ((tsk)->thread.lr)
-#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
-
-#define THREAD_SIZE (2*PAGE_SIZE)
-
-#define cpu_relax()	barrier()
-
-#endif /* _ASM_M32R_PROCESSOR_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/ptrace.h linux-2.6.30-rc3/include/asm-m32r/ptrace.h
--- linux-2.6.30-rc2/include/asm-m32r/ptrace.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/ptrace.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,148 +0,0 @@
-#ifndef _ASM_M32R_PTRACE_H
-#define _ASM_M32R_PTRACE_H
-
-/*
- * linux/include/asm-m32r/ptrace.h
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * M32R version:
- *   Copyright (C) 2001-2002, 2004  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-/* 0 - 13 are integer registers (general purpose registers).  */
-#define PT_R4		0
-#define PT_R5		1
-#define PT_R6		2
-#define PT_REGS 	3
-#define PT_R0		4
-#define PT_R1		5
-#define PT_R2		6
-#define PT_R3		7
-#define PT_R7		8
-#define PT_R8		9
-#define PT_R9		10
-#define PT_R10		11
-#define PT_R11		12
-#define PT_R12		13
-#define PT_SYSCNR	14
-#define PT_R13		PT_FP
-#define PT_R14		PT_LR
-#define PT_R15		PT_SP
-
-/* processor status and miscellaneous context registers.  */
-#define PT_ACC0H	15
-#define PT_ACC0L	16
-#define PT_ACC1H	17	/* ISA_DSP_LEVEL2 only */
-#define PT_ACC1L	18	/* ISA_DSP_LEVEL2 only */
-#define PT_PSW		19
-#define PT_BPC		20
-#define PT_BBPSW	21
-#define PT_BBPC		22
-#define PT_SPU		23
-#define PT_FP		24
-#define PT_LR		25
-#define PT_SPI		26
-#define PT_ORIGR0	27
-
-/* virtual pt_reg entry for gdb */
-#define PT_PC		30
-#define PT_CBR		31
-#define PT_EVB		32
-
-
-/* Control registers.  */
-#define SPR_CR0 PT_PSW
-#define SPR_CR1 PT_CBR		/* read only */
-#define SPR_CR2 PT_SPI
-#define SPR_CR3 PT_SPU
-#define SPR_CR4
-#define SPR_CR5 PT_EVB		/* part of M32R/E, M32R/I core only */
-#define SPR_CR6 PT_BPC
-#define SPR_CR7
-#define SPR_CR8 PT_BBPSW
-#define SPR_CR9
-#define SPR_CR10
-#define SPR_CR11
-#define SPR_CR12
-#define SPR_CR13 PT_WR
-#define SPR_CR14 PT_BBPC
-#define SPR_CR15
-
-/* this struct defines the way the registers are stored on the
-   stack during a system call. */
-struct pt_regs {
-	/* Saved main processor registers. */
-	unsigned long r4;
-	unsigned long r5;
-	unsigned long r6;
-	struct pt_regs *pt_regs;
-	unsigned long r0;
-	unsigned long r1;
-	unsigned long r2;
-	unsigned long r3;
-	unsigned long r7;
-	unsigned long r8;
-	unsigned long r9;
-	unsigned long r10;
-	unsigned long r11;
-	unsigned long r12;
-	long syscall_nr;
-
-	/* Saved main processor status and miscellaneous context registers. */
-	unsigned long acc0h;
-	unsigned long acc0l;
-	unsigned long acc1h;	/* ISA_DSP_LEVEL2 only */
-	unsigned long acc1l;	/* ISA_DSP_LEVEL2 only */
-	unsigned long psw;
-	unsigned long bpc;		/* saved PC for TRAP syscalls */
-	unsigned long bbpsw;
-	unsigned long bbpc;
-	unsigned long spu;		/* saved user stack */
-	unsigned long fp;
-	unsigned long lr;		/* saved PC for JL syscalls */
-	unsigned long spi;		/* saved kernel stack */
-	unsigned long orig_r0;
-};
-
-/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
-#define PTRACE_GETREGS		12
-#define PTRACE_SETREGS		13
-
-#define PTRACE_OLDSETOPTIONS	21
-
-/* options set using PTRACE_SETOPTIONS */
-#define PTRACE_O_TRACESYSGOOD	0x00000001
-
-#ifdef __KERNEL__
-
-#include <asm/m32r.h>		/* M32R_PSW_BSM, M32R_PSW_BPM */
-
-struct task_struct;
-extern void init_debug_traps(struct task_struct *);
-#define arch_ptrace_attach(child) \
-	init_debug_traps(child)
-
-#if defined(CONFIG_ISA_M32R2) || defined(CONFIG_CHIP_VDEC2)
-#define user_mode(regs) ((M32R_PSW_BPM & (regs)->psw) != 0)
-#elif defined(CONFIG_ISA_M32R)
-#define user_mode(regs) ((M32R_PSW_BSM & (regs)->psw) != 0)
-#else
-#error unknown isa configuration
-#endif
-
-#define instruction_pointer(regs) ((regs)->bpc)
-#define profile_pc(regs) instruction_pointer(regs)
-
-extern void show_regs(struct pt_regs *);
-
-extern void withdraw_debug_trap(struct pt_regs *regs);
-
-#define task_pt_regs(task) \
-        ((struct pt_regs *)(task_stack_page(task) + THREAD_SIZE) - 1)
-
-#endif /* __KERNEL */
-
-#endif /* _ASM_M32R_PTRACE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/resource.h linux-2.6.30-rc3/include/asm-m32r/resource.h
--- linux-2.6.30-rc2/include/asm-m32r/resource.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/resource.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_M32R_RESOURCE_H
-#define _ASM_M32R_RESOURCE_H
-
-#include <asm-generic/resource.h>
-
-#endif  /* _ASM_M32R_RESOURCE_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/rtc.h linux-2.6.30-rc3/include/asm-m32r/rtc.h
--- linux-2.6.30-rc2/include/asm-m32r/rtc.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/rtc.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,65 +0,0 @@
-#ifndef __RTC_H__
-#define __RTC_H__
-
-   /* Dallas DS1302 clock/calendar register numbers. */
-#  define RTC_SECONDS      0
-#  define RTC_MINUTES      1
-#  define RTC_HOURS        2
-#  define RTC_DAY_OF_MONTH 3
-#  define RTC_MONTH        4
-#  define RTC_WEEKDAY      5
-#  define RTC_YEAR         6
-#  define RTC_CONTROL      7
-
-   /* Bits in CONTROL register. */
-#  define RTC_CONTROL_WRITEPROTECT 	0x80
-#  define RTC_TRICKLECHARGER 		8
-
-  /* Bits in TRICKLECHARGER register TCS TCS TCS TCS DS DS RS RS. */
-#  define RTC_TCR_PATTERN 	0xA0	/* 1010xxxx */
-#  define RTC_TCR_1DIOD 	0x04	/* xxxx01xx */
-#  define RTC_TCR_2DIOD 	0x08	/* xxxx10xx */
-#  define RTC_TCR_DISABLED 	0x00	/* xxxxxx00 Disabled */
-#  define RTC_TCR_2KOHM 	0x01	/* xxxxxx01 2KOhm */
-#  define RTC_TCR_4KOHM 	0x02	/* xxxxxx10 4kOhm */
-#  define RTC_TCR_8KOHM 	0x03	/* xxxxxx11 8kOhm */
-
-#ifdef CONFIG_DS1302
-extern unsigned char ds1302_readreg(int reg);
-extern void ds1302_writereg(int reg, unsigned char val);
-extern int ds1302_init(void);
-#  define CMOS_READ(x) ds1302_readreg(x)
-#  define CMOS_WRITE(val,reg) ds1302_writereg(reg,val)
-#  define RTC_INIT() ds1302_init()
-#else
-  /* No RTC configured so we shouldn't try to access any. */
-#  define CMOS_READ(x) 42
-#  define CMOS_WRITE(x,y)
-#  define RTC_INIT() (-1)
-#endif
-
-/*
- * The struct used to pass data via the following ioctl. Similar to the
- * struct tm in <time.h>, but it needs to be here so that the kernel
- * source is self contained, allowing cross-compiles, etc. etc.
- */
-struct rtc_time {
-	int tm_sec;
-	int tm_min;
-	int tm_hour;
-	int tm_mday;
-	int tm_mon;
-	int tm_year;
-	int tm_wday;
-	int tm_yday;
-	int tm_isdst;
-};
-
-/* ioctl() calls that are permitted to the /dev/rtc interface. */
-#define RTC_MAGIC 'p'
-#define RTC_RD_TIME		_IOR(RTC_MAGIC, 0x09, struct rtc_time)	/* Read RTC time. */
-#define RTC_SET_TIME		_IOW(RTC_MAGIC, 0x0a, struct rtc_time)	/* Set RTC time. */
-#define RTC_SET_CHARGE  	_IOW(RTC_MAGIC, 0x0b, int)
-#define RTC_MAX_IOCTL 0x0b
-
-#endif /* __RTC_H__ */
diff -urN linux-2.6.30-rc2/include/asm-m32r/s1d13806.h linux-2.6.30-rc3/include/asm-m32r/s1d13806.h
--- linux-2.6.30-rc2/include/asm-m32r/s1d13806.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/s1d13806.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,199 +0,0 @@
-//----------------------------------------------------------------------------
-//
-//  File generated by S1D13806CFG.EXE
-//
-//  Copyright (c) 2000,2001 Epson Research and Development, Inc.
-//  All rights reserved.
-//
-//----------------------------------------------------------------------------
-
-// Panel:  (active)  640x480 77Hz STN Single 8-bit (PCLK=CLKI=25.175MHz)
-// Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=33.333MHz)
-
-#define SWIVEL_VIEW		0	/* 0:none, 1:90 not completed */
-
-static struct s1d13xxxfb_regval s1d13xxxfb_initregs[] = {
-
-    {0x0001,0x00},   // Miscellaneous Register
-    {0x01FC,0x00},   // Display Mode Register
-#if defined(CONFIG_PLAT_MAPPI)
-    {0x0004,0x00},   // General IO Pins Configuration Register 0
-    {0x0005,0x00},   // General IO Pins Configuration Register 1
-    {0x0008,0x00},   // General IO Pins Control Register 0
-    {0x0009,0x00},   // General IO Pins Control Register 1
-    {0x0010,0x00},   // Memory Clock Configuration Register
-    {0x0014,0x00},   // LCD Pixel Clock Configuration Register
-    {0x0018,0x00},   // CRT/TV Pixel Clock Configuration Register
-    {0x001C,0x00},   // MediaPlug Clock Configuration Register
-/*
- * .. 10MHz: 0x00
- * .. 30MHz: 0x01
- * 30MHz ..: 0x02
- */
-    {0x001E,0x02},   // CPU To Memory Wait State Select Register
-    {0x0021,0x02},   // DRAM Refresh Rate Register
-    {0x002A,0x11},   // DRAM Timings Control Register 0
-    {0x002B,0x13},   // DRAM Timings Control Register 1
-    {0x0020,0x80},   // Memory Configuration Register
-    {0x0030,0x25},   // Panel Type Register
-    {0x0031,0x00},   // MOD Rate Register
-    {0x0032,0x4F},   // LCD Horizontal Display Width Register
-    {0x0034,0x12},   // LCD Horizontal Non-Display Period Register
-    {0x0035,0x01},   // TFT FPLINE Start Position Register
-    {0x0036,0x0B},   // TFT FPLINE Pulse Width Register
-    {0x0038,0xDF},   // LCD Vertical Display Height Register 0
-    {0x0039,0x01},   // LCD Vertical Display Height Register 1
-    {0x003A,0x2C},   // LCD Vertical Non-Display Period Register
-    {0x003B,0x0A},   // TFT FPFRAME Start Position Register
-    {0x003C,0x01},   // TFT FPFRAME Pulse Width Register
-
-    {0x0041,0x00},   // LCD Miscellaneous Register
-    {0x0042,0x00},   // LCD Display Start Address Register 0
-    {0x0043,0x00},   // LCD Display Start Address Register 1
-    {0x0044,0x00},   // LCD Display Start Address Register 2
-
-#elif defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)
-    {0x0004,0x07},   // GPIO[0:7] direction
-    {0x0005,0x00},   // GPIO[8:12] direction
-    {0x0008,0x00},   // GPIO[0:7] data
-    {0x0009,0x00},   // GPIO[8:12] data
-    {0x0008,0x04},   // LCD panel Vcc on
-    {0x0008,0x05},   // LCD panel reset
-    {0x0010,0x01},   // Memory Clock Configuration Register
-    {0x0014,0x30},   // LCD Pixel Clock Configuration Register (CLKI 22MHz/4)
-    {0x0018,0x00},   // CRT/TV Pixel Clock Configuration Register
-    {0x001C,0x00},   // MediaPlug Clock Configuration Register(10MHz)
-    {0x001E,0x00},   // CPU To Memory Wait State Select Register
-    {0x0020,0x80},   // Memory Configuration Register
-    {0x0021,0x03},   // DRAM Refresh Rate Register
-    {0x002A,0x00},   // DRAM Timings Control Register 0
-    {0x002B,0x01},   // DRAM Timings Control Register 1
-    {0x0030,0x25},   // Panel Type Register
-    {0x0031,0x00},   // MOD Rate Register
-    {0x0032,0x1d},   // LCD Horizontal Display Width Register
-    {0x0034,0x05},   // LCD Horizontal Non-Display Period Register
-    {0x0035,0x01},   // TFT FPLINE Start Position Register
-    {0x0036,0x01},   // TFT FPLINE Pulse Width Register
-    {0x0038,0x3F},   // LCD Vertical Display Height Register 0
-    {0x0039,0x01},   // LCD Vertical Display Height Register 1
-    {0x003A,0x0b},   // LCD Vertical Non-Display Period Register
-    {0x003B,0x07},   // TFT FPFRAME Start Position Register
-    {0x003C,0x02},   // TFT FPFRAME Pulse Width Register
-
-    {0x0041,0x00},   // LCD Miscellaneous Register
-#if (SWIVEL_VIEW == 0)
-    {0x0042,0x00},   // LCD Display Start Address Register 0
-    {0x0043,0x00},   // LCD Display Start Address Register 1
-    {0x0044,0x00},   // LCD Display Start Address Register 2
-
-#elif (SWIVEL_VIEW == 1)
-    // 1024 - W(320) = 0x2C0
-    {0x0042,0xC0},   // LCD Display Start Address Register 0
-    {0x0043,0x02},   // LCD Display Start Address Register 1
-    {0x0044,0x00},   // LCD Display Start Address Register 2
-    // 1024
-    {0x0046,0x00},   // LCD Memory Address Offset Register 0
-    {0x0047,0x02},   // LCD Memory Address Offset Register 1
-#else
-#error unsupported SWIVEL_VIEW mode
-#endif
-#else
-#error no platform configuration
-#endif  /* CONFIG_PLAT_XXX */
-
-    {0x0048,0x00},   // LCD Pixel Panning Register
-    {0x004A,0x00},   // LCD Display FIFO High Threshold Control Register
-    {0x004B,0x00},   // LCD Display FIFO Low Threshold Control Register
-    {0x0050,0x4F},   // CRT/TV Horizontal Display Width Register
-    {0x0052,0x13},   // CRT/TV Horizontal Non-Display Period Register
-    {0x0053,0x01},   // CRT/TV HRTC Start Position Register
-    {0x0054,0x0B},   // CRT/TV HRTC Pulse Width Register
-    {0x0056,0xDF},   // CRT/TV Vertical Display Height Register 0
-    {0x0057,0x01},   // CRT/TV Vertical Display Height Register 1
-    {0x0058,0x2B},   // CRT/TV Vertical Non-Display Period Register
-    {0x0059,0x09},   // CRT/TV VRTC Start Position Register
-    {0x005A,0x01},   // CRT/TV VRTC Pulse Width Register
-    {0x005B,0x10},   // TV Output Control Register
-
-    {0x0062,0x00},   // CRT/TV Display Start Address Register 0
-    {0x0063,0x00},   // CRT/TV Display Start Address Register 1
-    {0x0064,0x00},   // CRT/TV Display Start Address Register 2
-
-    {0x0068,0x00},   // CRT/TV Pixel Panning Register
-    {0x006A,0x00},   // CRT/TV Display FIFO High Threshold Control Register
-    {0x006B,0x00},   // CRT/TV Display FIFO Low Threshold Control Register
-    {0x0070,0x00},   // LCD Ink/Cursor Control Register
-    {0x0071,0x01},   // LCD Ink/Cursor Start Address Register
-    {0x0072,0x00},   // LCD Cursor X Position Register 0
-    {0x0073,0x00},   // LCD Cursor X Position Register 1
-    {0x0074,0x00},   // LCD Cursor Y Position Register 0
-    {0x0075,0x00},   // LCD Cursor Y Position Register 1
-    {0x0076,0x00},   // LCD Ink/Cursor Blue Color 0 Register
-    {0x0077,0x00},   // LCD Ink/Cursor Green Color 0 Register
-    {0x0078,0x00},   // LCD Ink/Cursor Red Color 0 Register
-    {0x007A,0x1F},   // LCD Ink/Cursor Blue Color 1 Register
-    {0x007B,0x3F},   // LCD Ink/Cursor Green Color 1 Register
-    {0x007C,0x1F},   // LCD Ink/Cursor Red Color 1 Register
-    {0x007E,0x00},   // LCD Ink/Cursor FIFO Threshold Register
-    {0x0080,0x00},   // CRT/TV Ink/Cursor Control Register
-    {0x0081,0x01},   // CRT/TV Ink/Cursor Start Address Register
-    {0x0082,0x00},   // CRT/TV Cursor X Position Register 0
-    {0x0083,0x00},   // CRT/TV Cursor X Position Register 1
-    {0x0084,0x00},   // CRT/TV Cursor Y Position Register 0
-    {0x0085,0x00},   // CRT/TV Cursor Y Position Register 1
-    {0x0086,0x00},   // CRT/TV Ink/Cursor Blue Color 0 Register
-    {0x0087,0x00},   // CRT/TV Ink/Cursor Green Color 0 Register
-    {0x0088,0x00},   // CRT/TV Ink/Cursor Red Color 0 Register
-    {0x008A,0x1F},   // CRT/TV Ink/Cursor Blue Color 1 Register
-    {0x008B,0x3F},   // CRT/TV Ink/Cursor Green Color 1 Register
-    {0x008C,0x1F},   // CRT/TV Ink/Cursor Red Color 1 Register
-    {0x008E,0x00},   // CRT/TV Ink/Cursor FIFO Threshold Register
-    {0x0100,0x00},   // BitBlt Control Register 0
-    {0x0101,0x00},   // BitBlt Control Register 1
-    {0x0102,0x00},   // BitBlt ROP Code/Color Expansion Register
-    {0x0103,0x00},   // BitBlt Operation Register
-    {0x0104,0x00},   // BitBlt Source Start Address Register 0
-    {0x0105,0x00},   // BitBlt Source Start Address Register 1
-    {0x0106,0x00},   // BitBlt Source Start Address Register 2
-    {0x0108,0x00},   // BitBlt Destination Start Address Register 0
-    {0x0109,0x00},   // BitBlt Destination Start Address Register 1
-    {0x010A,0x00},   // BitBlt Destination Start Address Register 2
-    {0x010C,0x00},   // BitBlt Memory Address Offset Register 0
-    {0x010D,0x00},   // BitBlt Memory Address Offset Register 1
-    {0x0110,0x00},   // BitBlt Width Register 0
-    {0x0111,0x00},   // BitBlt Width Register 1
-    {0x0112,0x00},   // BitBlt Height Register 0
-    {0x0113,0x00},   // BitBlt Height Register 1
-    {0x0114,0x00},   // BitBlt Background Color Register 0
-    {0x0115,0x00},   // BitBlt Background Color Register 1
-    {0x0118,0x00},   // BitBlt Foreground Color Register 0
-    {0x0119,0x00},   // BitBlt Foreground Color Register 1
-    {0x01E0,0x00},   // Look-Up Table Mode Register
-    {0x01E2,0x00},   // Look-Up Table Address Register
-    {0x01F0,0x10},   // Power Save Configuration Register
-    {0x01F1,0x00},   // Power Save Status Register
-    {0x01F4,0x00},   // CPU-to-Memory Access Watchdog Timer Register
-#if (SWIVEL_VIEW == 0)
-    {0x01FC,0x01},   // Display Mode Register(0x01:LCD, 0x02:CRT, 0x03:LCD&CRT)
-#elif (SWIVEL_VIEW == 1)
-    {0x01FC,0x41},   // Display Mode Register(0x01:LCD, 0x02:CRT, 0x03:LCD&CRT)
-#else
-#error unsupported SWIVEL_VIEW mode
-#endif  /* SWIVEL_VIEW */
-
-#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)
-    {0x0008,0x07},   // LCD panel Vdd & Vg on
-#endif
-
-    {0x0040,0x05},   // LCD Display Mode Register (2:4bpp,3:8bpp,5:16bpp)
-#if defined(CONFIG_PLAT_MAPPI)
-    {0x0046,0x80},   // LCD Memory Address Offset Register 0
-    {0x0047,0x02},   // LCD Memory Address Offset Register 1
-#elif defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI3)
-    {0x0046,0xf0},   // LCD Memory Address Offset Register 0
-    {0x0047,0x00},   // LCD Memory Address Offset Register 1
-#endif
-    {0x0060,0x05},   // CRT/TV Display Mode Register (2:4bpp,3:8bpp,5:16bpp)
-    {0x0066,0x80},   // CRT/TV Memory Address Offset Register 0	// takeo
-    {0x0067,0x02},   // CRT/TV Memory Address Offset Register 1
-};
diff -urN linux-2.6.30-rc2/include/asm-m32r/scatterlist.h linux-2.6.30-rc3/include/asm-m32r/scatterlist.h
--- linux-2.6.30-rc2/include/asm-m32r/scatterlist.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/scatterlist.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,21 +0,0 @@
-#ifndef _ASM_M32R_SCATTERLIST_H
-#define _ASM_M32R_SCATTERLIST_H
-
-#include <asm/types.h>
-
-struct scatterlist {
-#ifdef CONFIG_DEBUG_SG
-    unsigned long sg_magic;
-#endif
-    char *  address;    /* Location data is to be transferred to, NULL for
-                         * highmem page */
-    unsigned long page_link;
-    unsigned int offset;/* for highmem, page offset */
-
-    dma_addr_t dma_address;
-    unsigned int length;
-};
-
-#define ISA_DMA_THRESHOLD (0x1fffffff)
-
-#endif /* _ASM_M32R_SCATTERLIST_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/sections.h linux-2.6.30-rc3/include/asm-m32r/sections.h
--- linux-2.6.30-rc2/include/asm-m32r/sections.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/sections.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-#ifndef _M32R_SECTIONS_H
-#define _M32R_SECTIONS_H
-
-/* nothing to see, move along */
-#include <asm-generic/sections.h>
-
-#endif	/* _M32R_SECTIONS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/segment.h linux-2.6.30-rc3/include/asm-m32r/segment.h
--- linux-2.6.30-rc2/include/asm-m32r/segment.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/segment.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,10 +0,0 @@
-#ifndef _ASM_M32R_SEGMENT_H
-#define _ASM_M32R_SEGMENT_H
-
-#define __KERNEL_CS	0x10
-#define __KERNEL_DS	0x18
-
-#define __USER_CS	0x23
-#define __USER_DS	0x2B
-
-#endif  /* _ASM_M32R_SEGMENT_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/sembuf.h linux-2.6.30-rc3/include/asm-m32r/sembuf.h
--- linux-2.6.30-rc2/include/asm-m32r/sembuf.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/sembuf.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,25 +0,0 @@
-#ifndef _ASM_M32R_SEMBUF_H
-#define _ASM_M32R_SEMBUF_H
-
-/*
- * The semid64_ds structure for m32r architecture.
- * Note extra padding because this structure is passed back and forth
- * between kernel and user space.
- *
- * Pad space is left for:
- * - 64-bit time_t to solve y2038 problem
- * - 2 miscellaneous 32-bit values
- */
-
-struct semid64_ds {
-	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
-	__kernel_time_t	sem_otime;		/* last semop time */
-	unsigned long	__unused1;
-	__kernel_time_t	sem_ctime;		/* last change time */
-	unsigned long	__unused2;
-	unsigned long	sem_nsems;		/* no. of semaphores in array */
-	unsigned long	__unused3;
-	unsigned long	__unused4;
-};
-
-#endif /* _ASM_M32R_SEMBUF_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/serial.h linux-2.6.30-rc3/include/asm-m32r/serial.h
--- linux-2.6.30-rc2/include/asm-m32r/serial.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/serial.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,9 +0,0 @@
-#ifndef _ASM_M32R_SERIAL_H
-#define _ASM_M32R_SERIAL_H
-
-/* include/asm-m32r/serial.h */
-
-
-#define BASE_BAUD	115200
-
-#endif  /* _ASM_M32R_SERIAL_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/setup.h linux-2.6.30-rc3/include/asm-m32r/setup.h
--- linux-2.6.30-rc2/include/asm-m32r/setup.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/setup.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,38 +0,0 @@
-#ifndef _ASM_M32R_SETUP_H
-#define _ASM_M32R_SETUP_H
-
-/*
- * This is set up by the setup-routine at boot-time
- */
-
-#define COMMAND_LINE_SIZE       512
-
-#ifdef __KERNEL__
-
-#define PARAM			((unsigned char *)empty_zero_page)
-
-#define MOUNT_ROOT_RDONLY	(*(unsigned long *) (PARAM+0x000))
-#define RAMDISK_FLAGS		(*(unsigned long *) (PARAM+0x004))
-#define ORIG_ROOT_DEV		(*(unsigned long *) (PARAM+0x008))
-#define LOADER_TYPE		(*(unsigned long *) (PARAM+0x00c))
-#define INITRD_START		(*(unsigned long *) (PARAM+0x010))
-#define INITRD_SIZE		(*(unsigned long *) (PARAM+0x014))
-
-#define M32R_CPUCLK		(*(unsigned long *) (PARAM+0x018))
-#define M32R_BUSCLK		(*(unsigned long *) (PARAM+0x01c))
-#define M32R_TIMER_DIVIDE	(*(unsigned long *) (PARAM+0x020))
-
-#define COMMAND_LINE		((char *) (PARAM+0x100))
-
-#define SCREEN_INFO		(*(struct screen_info *) (PARAM+0x200))
-
-#define RAMDISK_IMAGE_START_MASK	(0x07FF)
-#define RAMDISK_PROMPT_FLAG		(0x8000)
-#define RAMDISK_LOAD_FLAG		(0x4000)
-
-extern unsigned long memory_start;
-extern unsigned long memory_end;
-
-#endif  /*  __KERNEL__  */
-
-#endif /* _ASM_M32R_SETUP_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/shmbuf.h linux-2.6.30-rc3/include/asm-m32r/shmbuf.h
--- linux-2.6.30-rc2/include/asm-m32r/shmbuf.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/shmbuf.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,42 +0,0 @@
-#ifndef _ASM_M32R_SHMBUF_H
-#define _ASM_M32R_SHMBUF_H
-
-/*
- * The shmid64_ds structure for M32R architecture.
- * Note extra padding because this structure is passed back and forth
- * between kernel and user space.
- *
- * Pad space is left for:
- * - 64-bit time_t to solve y2038 problem
- * - 2 miscellaneous 32-bit values
- */
-
-struct shmid64_ds {
-	struct ipc64_perm	shm_perm;	/* operation perms */
-	size_t			shm_segsz;	/* size of segment (bytes) */
-	__kernel_time_t		shm_atime;	/* last attach time */
-	unsigned long		__unused1;
-	__kernel_time_t		shm_dtime;	/* last detach time */
-	unsigned long		__unused2;
-	__kernel_time_t		shm_ctime;	/* last change time */
-	unsigned long		__unused3;
-	__kernel_pid_t		shm_cpid;	/* pid of creator */
-	__kernel_pid_t		shm_lpid;	/* pid of last operator */
-	unsigned long		shm_nattch;	/* no. of current attaches */
-	unsigned long		__unused4;
-	unsigned long		__unused5;
-};
-
-struct shminfo64 {
-	unsigned long	shmmax;
-	unsigned long	shmmin;
-	unsigned long	shmmni;
-	unsigned long	shmseg;
-	unsigned long	shmall;
-	unsigned long	__unused1;
-	unsigned long	__unused2;
-	unsigned long	__unused3;
-	unsigned long	__unused4;
-};
-
-#endif /* _ASM_M32R_SHMBUF_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/shmparam.h linux-2.6.30-rc3/include/asm-m32r/shmparam.h
--- linux-2.6.30-rc2/include/asm-m32r/shmparam.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/shmparam.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_M32R_SHMPARAM_H
-#define _ASM_M32R_SHMPARAM_H
-
-#define	SHMLBA PAGE_SIZE		 /* attach addr a multiple of this */
-
-#endif /* _ASM_M32R_SHMPARAM_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/sigcontext.h linux-2.6.30-rc3/include/asm-m32r/sigcontext.h
--- linux-2.6.30-rc2/include/asm-m32r/sigcontext.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/sigcontext.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,39 +0,0 @@
-#ifndef _ASM_M32R_SIGCONTEXT_H
-#define _ASM_M32R_SIGCONTEXT_H
-
-struct sigcontext {
-	/* CPU registers */
-	/* Saved main processor registers. */
-	unsigned long sc_r4;
-	unsigned long sc_r5;
-	unsigned long sc_r6;
-	struct pt_regs *sc_pt_regs;
-	unsigned long sc_r0;
-	unsigned long sc_r1;
-	unsigned long sc_r2;
-	unsigned long sc_r3;
-	unsigned long sc_r7;
-	unsigned long sc_r8;
-	unsigned long sc_r9;
-	unsigned long sc_r10;
-	unsigned long sc_r11;
-	unsigned long sc_r12;
-
-	/* Saved main processor status and miscellaneous context registers. */
-	unsigned long sc_acc0h;
-	unsigned long sc_acc0l;
-	unsigned long sc_acc1h;	/* ISA_DSP_LEVEL2 only */
-	unsigned long sc_acc1l;	/* ISA_DSP_LEVEL2 only */
-	unsigned long sc_psw;
-	unsigned long sc_bpc;		/* saved PC for TRAP syscalls */
-	unsigned long sc_bbpsw;
-	unsigned long sc_bbpc;
-	unsigned long sc_spu;		/* saved user stack */
-	unsigned long sc_fp;
-	unsigned long sc_lr;		/* saved PC for JL syscalls */
-	unsigned long sc_spi;		/* saved kernel stack */
-
-	unsigned long	oldmask;
-};
-
-#endif  /* _ASM_M32R_SIGCONTEXT_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/siginfo.h linux-2.6.30-rc3/include/asm-m32r/siginfo.h
--- linux-2.6.30-rc2/include/asm-m32r/siginfo.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/siginfo.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _M32R_SIGINFO_H
-#define _M32R_SIGINFO_H
-
-#include <asm-generic/siginfo.h>
-
-#endif /* _M32R_SIGINFO_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/signal.h linux-2.6.30-rc3/include/asm-m32r/signal.h
--- linux-2.6.30-rc2/include/asm-m32r/signal.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/signal.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,166 +0,0 @@
-#ifndef _ASM_M32R_SIGNAL_H
-#define _ASM_M32R_SIGNAL_H
-
-#include <linux/types.h>
-#include <linux/time.h>
-#include <linux/compiler.h>
-
-/* Avoid too many header ordering problems.  */
-struct siginfo;
-
-#ifdef __KERNEL__
-/* Most things should be clean enough to redefine this at will, if care
-   is taken to make libc match.  */
-
-#define _NSIG		64
-#define _NSIG_BPW	32
-#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
-
-typedef unsigned long old_sigset_t;		/* at least 32 bits */
-
-typedef struct {
-	unsigned long sig[_NSIG_WORDS];
-} sigset_t;
-
-#else
-/* Here we must cater to libcs that poke about in kernel headers.  */
-
-#define NSIG		32
-typedef unsigned long sigset_t;
-
-#endif /* __KERNEL__ */
-
-#define SIGHUP		 1
-#define SIGINT		 2
-#define SIGQUIT		 3
-#define SIGILL		 4
-#define SIGTRAP		 5
-#define SIGABRT		 6
-#define SIGIOT		 6
-#define SIGBUS		 7
-#define SIGFPE		 8
-#define SIGKILL		 9
-#define SIGUSR1		10
-#define SIGSEGV		11
-#define SIGUSR2		12
-#define SIGPIPE		13
-#define SIGALRM		14
-#define SIGTERM		15
-#define SIGSTKFLT	16
-#define SIGCHLD		17
-#define SIGCONT		18
-#define SIGSTOP		19
-#define SIGTSTP		20
-#define SIGTTIN		21
-#define SIGTTOU		22
-#define SIGURG		23
-#define SIGXCPU		24
-#define SIGXFSZ		25
-#define SIGVTALRM	26
-#define SIGPROF		27
-#define SIGWINCH	28
-#define SIGIO		29
-#define SIGPOLL		SIGIO
-/*
-#define SIGLOST		29
-*/
-#define SIGPWR		30
-#define SIGSYS		31
-#define	SIGUNUSED	31
-
-/* These should not be considered constants from userland.  */
-#define SIGRTMIN	32
-#define SIGRTMAX	_NSIG
-
-/*
- * SA_FLAGS values:
- *
- * SA_ONSTACK indicates that a registered stack_t will be used.
- * SA_RESTART flag to get restarting signals (which were the default long ago)
- * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
- * SA_RESETHAND clears the handler when the signal is delivered.
- * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
- * SA_NODEFER prevents the current signal from being masked in the handler.
- *
- * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
- * Unix names RESETHAND and NODEFER respectively.
- */
-#define SA_NOCLDSTOP	0x00000001u
-#define SA_NOCLDWAIT	0x00000002u
-#define SA_SIGINFO	0x00000004u
-#define SA_ONSTACK	0x08000000u
-#define SA_RESTART	0x10000000u
-#define SA_NODEFER	0x40000000u
-#define SA_RESETHAND	0x80000000u
-
-#define SA_NOMASK	SA_NODEFER
-#define SA_ONESHOT	SA_RESETHAND
-
-#define SA_RESTORER	0x04000000
-
-/*
- * sigaltstack controls
- */
-#define SS_ONSTACK	1
-#define SS_DISABLE	2
-
-#define MINSIGSTKSZ	2048
-#define SIGSTKSZ	8192
-
-#include <asm-generic/signal.h>
-
-#ifdef __KERNEL__
-struct old_sigaction {
-	__sighandler_t sa_handler;
-	old_sigset_t sa_mask;
-	unsigned long sa_flags;
-	__sigrestore_t sa_restorer;
-};
-
-struct sigaction {
-	__sighandler_t sa_handler;
-	unsigned long sa_flags;
-	__sigrestore_t sa_restorer;
-	sigset_t sa_mask;		/* mask last for extensibility */
-};
-
-struct k_sigaction {
-	struct sigaction sa;
-};
-#else
-/* Here we must cater to libcs that poke about in kernel headers.  */
-
-struct sigaction {
-	union {
-	  __sighandler_t _sa_handler;
-	  void (*_sa_sigaction)(int, struct siginfo *, void *);
-	} _u;
-	sigset_t sa_mask;
-	unsigned long sa_flags;
-	void (*sa_restorer)(void);
-};
-
-#define sa_handler	_u._sa_handler
-#define sa_sigaction	_u._sa_sigaction
-
-#endif /* __KERNEL__ */
-
-typedef struct sigaltstack {
-	void __user *ss_sp;
-	int ss_flags;
-	size_t ss_size;
-} stack_t;
-
-#ifdef __KERNEL__
-#include <asm/sigcontext.h>
-
-#undef __HAVE_ARCH_SIG_BITOPS
-
-struct pt_regs;
-extern int do_signal(struct pt_regs *regs, sigset_t *oldset);
-
-#define ptrace_signal_deliver(regs, cookie)	do { } while (0)
-
-#endif /* __KERNEL__ */
-
-#endif  /* _ASM_M32R_SIGNAL_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/smp.h linux-2.6.30-rc3/include/asm-m32r/smp.h
--- linux-2.6.30-rc2/include/asm-m32r/smp.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/smp.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,119 +0,0 @@
-#ifndef _ASM_M32R_SMP_H
-#define _ASM_M32R_SMP_H
-
-#ifdef CONFIG_SMP
-#ifndef __ASSEMBLY__
-
-#include <linux/cpumask.h>
-#include <linux/spinlock.h>
-#include <linux/threads.h>
-#include <asm/m32r.h>
-
-#define PHYSID_ARRAY_SIZE       1
-
-struct physid_mask
-{
-	unsigned long mask[PHYSID_ARRAY_SIZE];
-};
-
-typedef struct physid_mask physid_mask_t;
-
-#define physid_set(physid, map)                 set_bit(physid, (map).mask)
-#define physid_clear(physid, map)               clear_bit(physid, (map).mask)
-#define physid_isset(physid, map)               test_bit(physid, (map).mask)
-#define physid_test_and_set(physid, map)        test_and_set_bit(physid, (map).mask)
-
-#define physids_and(dst, src1, src2)            bitmap_and((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
-#define physids_or(dst, src1, src2)             bitmap_or((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
-#define physids_clear(map)                      bitmap_zero((map).mask, MAX_APICS)
-#define physids_complement(dst, src)            bitmap_complement((dst).mask,(src).mask, MAX_APICS)
-#define physids_empty(map)                      bitmap_empty((map).mask, MAX_APICS)
-#define physids_equal(map1, map2)               bitmap_equal((map1).mask, (map2).mask, MAX_APICS)
-#define physids_weight(map)                     bitmap_weight((map).mask, MAX_APICS)
-#define physids_shift_right(d, s, n)            bitmap_shift_right((d).mask, (s).mask, n, MAX_APICS)
-#define physids_shift_left(d, s, n)             bitmap_shift_left((d).mask, (s).mask, n, MAX_APICS)
-#define physids_coerce(map)                     ((map).mask[0])
-
-#define physids_promote(physids)					\
-	({								\
-		physid_mask_t __physid_mask = PHYSID_MASK_NONE;		\
-		__physid_mask.mask[0] = physids;			\
-		__physid_mask;						\
-	})
-
-#define physid_mask_of_physid(physid)					\
-	({								\
-		physid_mask_t __physid_mask = PHYSID_MASK_NONE;		\
-		physid_set(physid, __physid_mask);			\
-		__physid_mask;						\
-	})
-
-#define PHYSID_MASK_ALL         { {[0 ... PHYSID_ARRAY_SIZE-1] = ~0UL} }
-#define PHYSID_MASK_NONE        { {[0 ... PHYSID_ARRAY_SIZE-1] = 0UL} }
-
-extern physid_mask_t phys_cpu_present_map;
-
-/*
- * Some lowlevel functions might want to know about
- * the real CPU ID <-> CPU # mapping.
- */
-extern volatile int cpu_2_physid[NR_CPUS];
-#define cpu_to_physid(cpu_id)	cpu_2_physid[cpu_id]
-
-#define raw_smp_processor_id()	(current_thread_info()->cpu)
-
-extern cpumask_t cpu_callout_map;
-
-static __inline__ int hard_smp_processor_id(void)
-{
-	return (int)*(volatile long *)M32R_CPUID_PORTL;
-}
-
-static __inline__ int cpu_logical_map(int cpu)
-{
-	return cpu;
-}
-
-static __inline__ int cpu_number_map(int cpu)
-{
-	return cpu;
-}
-
-static __inline__ unsigned int num_booting_cpus(void)
-{
-	return cpus_weight(cpu_callout_map);
-}
-
-extern void smp_send_timer(void);
-extern unsigned long send_IPI_mask_phys(cpumask_t, int, int);
-
-extern void arch_send_call_function_single_ipi(int cpu);
-extern void arch_send_call_function_ipi(cpumask_t mask);
-
-#endif	/* not __ASSEMBLY__ */
-
-#define NO_PROC_ID (0xff)	/* No processor magic marker */
-
-#define PROC_CHANGE_PENALTY	(15)	/* Schedule penalty */
-
-/*
- * M32R-mp IPI
- */
-#define RESCHEDULE_IPI		(M32R_IRQ_IPI0-M32R_IRQ_IPI0)
-#define INVALIDATE_TLB_IPI	(M32R_IRQ_IPI1-M32R_IRQ_IPI0)
-#define CALL_FUNCTION_IPI	(M32R_IRQ_IPI2-M32R_IRQ_IPI0)
-#define LOCAL_TIMER_IPI		(M32R_IRQ_IPI3-M32R_IRQ_IPI0)
-#define INVALIDATE_CACHE_IPI	(M32R_IRQ_IPI4-M32R_IRQ_IPI0)
-#define CPU_BOOT_IPI		(M32R_IRQ_IPI5-M32R_IRQ_IPI0)
-#define CALL_FUNC_SINGLE_IPI	(M32R_IRQ_IPI6-M32R_IRQ_IPI0)
-
-#define IPI_SHIFT	(0)
-#define NR_IPIS		(8)
-
-#else	/* CONFIG_SMP */
-
-#define hard_smp_processor_id()		0
-
-#endif /* CONFIG_SMP */
-
-#endif	/* _ASM_M32R_SMP_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/socket.h linux-2.6.30-rc3/include/asm-m32r/socket.h
--- linux-2.6.30-rc2/include/asm-m32r/socket.h	2009-04-22 03:29:12.141931410 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/socket.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,60 +0,0 @@
-#ifndef _ASM_M32R_SOCKET_H
-#define _ASM_M32R_SOCKET_H
-
-#include <asm/sockios.h>
-
-/* For setsockoptions(2) */
-#define SOL_SOCKET	1
-
-#define SO_DEBUG	1
-#define SO_REUSEADDR	2
-#define SO_TYPE		3
-#define SO_ERROR	4
-#define SO_DONTROUTE	5
-#define SO_BROADCAST	6
-#define SO_SNDBUF	7
-#define SO_RCVBUF	8
-#define SO_SNDBUFFORCE	32
-#define SO_RCVBUFFORCE	33
-#define SO_KEEPALIVE	9
-#define SO_OOBINLINE	10
-#define SO_NO_CHECK	11
-#define SO_PRIORITY	12
-#define SO_LINGER	13
-#define SO_BSDCOMPAT	14
-/* To add :#define SO_REUSEPORT 15 */
-#define SO_PASSCRED	16
-#define SO_PEERCRED	17
-#define SO_RCVLOWAT	18
-#define SO_SNDLOWAT	19
-#define SO_RCVTIMEO	20
-#define SO_SNDTIMEO	21
-
-/* Security levels - as per NRL IPv6 - don't actually do anything */
-#define SO_SECURITY_AUTHENTICATION		22
-#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
-#define SO_SECURITY_ENCRYPTION_NETWORK		24
-
-#define SO_BINDTODEVICE	25
-
-/* Socket filtering */
-#define SO_ATTACH_FILTER        26
-#define SO_DETACH_FILTER        27
-
-#define SO_PEERNAME		28
-#define SO_TIMESTAMP		29
-#define SCM_TIMESTAMP		SO_TIMESTAMP
-
-#define SO_ACCEPTCONN		30
-
-#define SO_PEERSEC		31
-#define SO_PASSSEC		34
-#define SO_TIMESTAMPNS		35
-#define SCM_TIMESTAMPNS		SO_TIMESTAMPNS
-
-#define SO_MARK			36
-
-#define SO_TIMESTAMPING		37
-#define SCM_TIMESTAMPING	SO_TIMESTAMPING
-
-#endif /* _ASM_M32R_SOCKET_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/sockios.h linux-2.6.30-rc3/include/asm-m32r/sockios.h
--- linux-2.6.30-rc2/include/asm-m32r/sockios.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/sockios.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,13 +0,0 @@
-#ifndef _ASM_M32R_SOCKIOS_H
-#define _ASM_M32R_SOCKIOS_H
-
-/* Socket-level I/O control calls. */
-#define FIOSETOWN 	0x8901
-#define SIOCSPGRP	0x8902
-#define FIOGETOWN	0x8903
-#define SIOCGPGRP	0x8904
-#define SIOCATMARK	0x8905
-#define SIOCGSTAMP	0x8906		/* Get stamp (timeval) */
-#define SIOCGSTAMPNS	0x8907		/* Get stamp (timespec) */
-
-#endif  /* _ASM_M32R_SOCKIOS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/spinlock.h linux-2.6.30-rc3/include/asm-m32r/spinlock.h
--- linux-2.6.30-rc2/include/asm-m32r/spinlock.h	2009-04-22 03:29:12.141931410 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/spinlock.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,326 +0,0 @@
-#ifndef _ASM_M32R_SPINLOCK_H
-#define _ASM_M32R_SPINLOCK_H
-
-/*
- *  linux/include/asm-m32r/spinlock.h
- *
- *  M32R version:
- *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
- *    Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#include <linux/compiler.h>
-#include <asm/atomic.h>
-#include <asm/page.h>
-
-/*
- * Your basic SMP spinlocks, allowing only a single CPU anywhere
- *
- * (the type definitions are in asm/spinlock_types.h)
- *
- * Simple spin lock operations.  There are two variants, one clears IRQ's
- * on the local processor, one does not.
- *
- * We make no fairness assumptions. They have a cost.
- */
-
-#define __raw_spin_is_locked(x)		(*(volatile int *)(&(x)->slock) <= 0)
-#define __raw_spin_lock_flags(lock, flags) __raw_spin_lock(lock)
-#define __raw_spin_unlock_wait(x) \
-		do { cpu_relax(); } while (__raw_spin_is_locked(x))
-
-/**
- * __raw_spin_trylock - Try spin lock and return a result
- * @lock: Pointer to the lock variable
- *
- * __raw_spin_trylock() tries to get the lock and returns a result.
- * On the m32r, the result value is 1 (= Success) or 0 (= Failure).
- */
-static inline int __raw_spin_trylock(raw_spinlock_t *lock)
-{
-	int oldval;
-	unsigned long tmp1, tmp2;
-
-	/*
-	 * lock->slock :  =1 : unlock
-	 *             : <=0 : lock
-	 * {
-	 *   oldval = lock->slock; <--+ need atomic operation
-	 *   lock->slock = 0;      <--+
-	 * }
-	 */
-	__asm__ __volatile__ (
-		"# __raw_spin_trylock		\n\t"
-		"ldi	%1, #0;			\n\t"
-		"mvfc	%2, psw;		\n\t"
-		"clrpsw	#0x40 -> nop;		\n\t"
-		DCACHE_CLEAR("%0", "r6", "%3")
-		"lock	%0, @%3;		\n\t"
-		"unlock	%1, @%3;		\n\t"
-		"mvtc	%2, psw;		\n\t"
-		: "=&r" (oldval), "=&r" (tmp1), "=&r" (tmp2)
-		: "r" (&lock->slock)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r6"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-
-	return (oldval > 0);
-}
-
-static inline void __raw_spin_lock(raw_spinlock_t *lock)
-{
-	unsigned long tmp0, tmp1;
-
-	/*
-	 * lock->slock :  =1 : unlock
-	 *             : <=0 : lock
-	 *
-	 * for ( ; ; ) {
-	 *   lock->slock -= 1;  <-- need atomic operation
-	 *   if (lock->slock == 0) break;
-	 *   for ( ; lock->slock <= 0 ; );
-	 * }
-	 */
-	__asm__ __volatile__ (
-		"# __raw_spin_lock		\n\t"
-		".fillinsn			\n"
-		"1:				\n\t"
-		"mvfc	%1, psw;		\n\t"
-		"clrpsw	#0x40 -> nop;		\n\t"
-		DCACHE_CLEAR("%0", "r6", "%2")
-		"lock	%0, @%2;		\n\t"
-		"addi	%0, #-1;		\n\t"
-		"unlock	%0, @%2;		\n\t"
-		"mvtc	%1, psw;		\n\t"
-		"bltz	%0, 2f;			\n\t"
-		LOCK_SECTION_START(".balign 4 \n\t")
-		".fillinsn			\n"
-		"2:				\n\t"
-		"ld	%0, @%2;		\n\t"
-		"bgtz	%0, 1b;			\n\t"
-		"bra	2b;			\n\t"
-		LOCK_SECTION_END
-		: "=&r" (tmp0), "=&r" (tmp1)
-		: "r" (&lock->slock)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r6"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-}
-
-static inline void __raw_spin_unlock(raw_spinlock_t *lock)
-{
-	mb();
-	lock->slock = 1;
-}
-
-/*
- * Read-write spinlocks, allowing multiple readers
- * but only one writer.
- *
- * NOTE! it is quite common to have readers in interrupts
- * but no interrupt writers. For those circumstances we
- * can "mix" irq-safe locks - any writer needs to get a
- * irq-safe write-lock, but readers can get non-irqsafe
- * read-locks.
- *
- * On x86, we implement read-write locks as a 32-bit counter
- * with the high bit (sign) being the "contended" bit.
- *
- * The inline assembly is non-obvious. Think about it.
- *
- * Changed to use the same technique as rw semaphores.  See
- * semaphore.h for details.  -ben
- */
-
-/**
- * read_can_lock - would read_trylock() succeed?
- * @lock: the rwlock in question.
- */
-#define __raw_read_can_lock(x) ((int)(x)->lock > 0)
-
-/**
- * write_can_lock - would write_trylock() succeed?
- * @lock: the rwlock in question.
- */
-#define __raw_write_can_lock(x) ((x)->lock == RW_LOCK_BIAS)
-
-static inline void __raw_read_lock(raw_rwlock_t *rw)
-{
-	unsigned long tmp0, tmp1;
-
-	/*
-	 * rw->lock :  >0 : unlock
-	 *          : <=0 : lock
-	 *
-	 * for ( ; ; ) {
-	 *   rw->lock -= 1;  <-- need atomic operation
-	 *   if (rw->lock >= 0) break;
-	 *   rw->lock += 1;  <-- need atomic operation
-	 *   for ( ; rw->lock <= 0 ; );
-	 * }
-	 */
-	__asm__ __volatile__ (
-		"# read_lock			\n\t"
-		".fillinsn			\n"
-		"1:				\n\t"
-		"mvfc	%1, psw;		\n\t"
-		"clrpsw	#0x40 -> nop;		\n\t"
-		DCACHE_CLEAR("%0", "r6", "%2")
-		"lock	%0, @%2;		\n\t"
-		"addi	%0, #-1;		\n\t"
-		"unlock	%0, @%2;		\n\t"
-		"mvtc	%1, psw;		\n\t"
-		"bltz	%0, 2f;			\n\t"
-		LOCK_SECTION_START(".balign 4 \n\t")
-		".fillinsn			\n"
-		"2:				\n\t"
-		"clrpsw	#0x40 -> nop;		\n\t"
-		DCACHE_CLEAR("%0", "r6", "%2")
-		"lock	%0, @%2;		\n\t"
-		"addi	%0, #1;			\n\t"
-		"unlock	%0, @%2;		\n\t"
-		"mvtc	%1, psw;		\n\t"
-		".fillinsn			\n"
-		"3:				\n\t"
-		"ld	%0, @%2;		\n\t"
-		"bgtz	%0, 1b;			\n\t"
-		"bra	3b;			\n\t"
-		LOCK_SECTION_END
-		: "=&r" (tmp0), "=&r" (tmp1)
-		: "r" (&rw->lock)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r6"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-}
-
-static inline void __raw_write_lock(raw_rwlock_t *rw)
-{
-	unsigned long tmp0, tmp1, tmp2;
-
-	/*
-	 * rw->lock :  =RW_LOCK_BIAS_STR : unlock
-	 *          : !=RW_LOCK_BIAS_STR : lock
-	 *
-	 * for ( ; ; ) {
-	 *   rw->lock -= RW_LOCK_BIAS_STR;  <-- need atomic operation
-	 *   if (rw->lock == 0) break;
-	 *   rw->lock += RW_LOCK_BIAS_STR;  <-- need atomic operation
-	 *   for ( ; rw->lock != RW_LOCK_BIAS_STR ; ) ;
-	 * }
-	 */
-	__asm__ __volatile__ (
-		"# write_lock					\n\t"
-		"seth	%1, #high(" RW_LOCK_BIAS_STR ");	\n\t"
-		"or3	%1, %1, #low(" RW_LOCK_BIAS_STR ");	\n\t"
-		".fillinsn					\n"
-		"1:						\n\t"
-		"mvfc	%2, psw;				\n\t"
-		"clrpsw	#0x40 -> nop;				\n\t"
-		DCACHE_CLEAR("%0", "r7", "%3")
-		"lock	%0, @%3;				\n\t"
-		"sub	%0, %1;					\n\t"
-		"unlock	%0, @%3;				\n\t"
-		"mvtc	%2, psw;				\n\t"
-		"bnez	%0, 2f;					\n\t"
-		LOCK_SECTION_START(".balign 4 \n\t")
-		".fillinsn					\n"
-		"2:						\n\t"
-		"clrpsw	#0x40 -> nop;				\n\t"
-		DCACHE_CLEAR("%0", "r7", "%3")
-		"lock	%0, @%3;				\n\t"
-		"add	%0, %1;					\n\t"
-		"unlock	%0, @%3;				\n\t"
-		"mvtc	%2, psw;				\n\t"
-		".fillinsn					\n"
-		"3:						\n\t"
-		"ld	%0, @%3;				\n\t"
-		"beq	%0, %1, 1b;				\n\t"
-		"bra	3b;					\n\t"
-		LOCK_SECTION_END
-		: "=&r" (tmp0), "=&r" (tmp1), "=&r" (tmp2)
-		: "r" (&rw->lock)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r7"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-}
-
-static inline void __raw_read_unlock(raw_rwlock_t *rw)
-{
-	unsigned long tmp0, tmp1;
-
-	__asm__ __volatile__ (
-		"# read_unlock			\n\t"
-		"mvfc	%1, psw;		\n\t"
-		"clrpsw	#0x40 -> nop;		\n\t"
-		DCACHE_CLEAR("%0", "r6", "%2")
-		"lock	%0, @%2;		\n\t"
-		"addi	%0, #1;			\n\t"
-		"unlock	%0, @%2;		\n\t"
-		"mvtc	%1, psw;		\n\t"
-		: "=&r" (tmp0), "=&r" (tmp1)
-		: "r" (&rw->lock)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r6"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-}
-
-static inline void __raw_write_unlock(raw_rwlock_t *rw)
-{
-	unsigned long tmp0, tmp1, tmp2;
-
-	__asm__ __volatile__ (
-		"# write_unlock					\n\t"
-		"seth	%1, #high(" RW_LOCK_BIAS_STR ");	\n\t"
-		"or3	%1, %1, #low(" RW_LOCK_BIAS_STR ");	\n\t"
-		"mvfc	%2, psw;				\n\t"
-		"clrpsw	#0x40 -> nop;				\n\t"
-		DCACHE_CLEAR("%0", "r7", "%3")
-		"lock	%0, @%3;				\n\t"
-		"add	%0, %1;					\n\t"
-		"unlock	%0, @%3;				\n\t"
-		"mvtc	%2, psw;				\n\t"
-		: "=&r" (tmp0), "=&r" (tmp1), "=&r" (tmp2)
-		: "r" (&rw->lock)
-		: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r7"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-	);
-}
-
-static inline int __raw_read_trylock(raw_rwlock_t *lock)
-{
-	atomic_t *count = (atomic_t*)lock;
-	if (atomic_dec_return(count) >= 0)
-		return 1;
-	atomic_inc(count);
-	return 0;
-}
-
-static inline int __raw_write_trylock(raw_rwlock_t *lock)
-{
-	atomic_t *count = (atomic_t *)lock;
-	if (atomic_sub_and_test(RW_LOCK_BIAS, count))
-		return 1;
-	atomic_add(RW_LOCK_BIAS, count);
-	return 0;
-}
-
-#define __raw_read_lock_flags(lock, flags) __raw_read_lock(lock)
-#define __raw_write_lock_flags(lock, flags) __raw_write_lock(lock)
-
-#define _raw_spin_relax(lock)	cpu_relax()
-#define _raw_read_relax(lock)	cpu_relax()
-#define _raw_write_relax(lock)	cpu_relax()
-
-#endif	/* _ASM_M32R_SPINLOCK_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/spinlock_types.h linux-2.6.30-rc3/include/asm-m32r/spinlock_types.h
--- linux-2.6.30-rc2/include/asm-m32r/spinlock_types.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/spinlock_types.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,23 +0,0 @@
-#ifndef _ASM_M32R_SPINLOCK_TYPES_H
-#define _ASM_M32R_SPINLOCK_TYPES_H
-
-#ifndef __LINUX_SPINLOCK_TYPES_H
-# error "please don't include this file directly"
-#endif
-
-typedef struct {
-	volatile int slock;
-} raw_spinlock_t;
-
-#define __RAW_SPIN_LOCK_UNLOCKED	{ 1 }
-
-typedef struct {
-	volatile int lock;
-} raw_rwlock_t;
-
-#define RW_LOCK_BIAS			0x01000000
-#define RW_LOCK_BIAS_STR		"0x01000000"
-
-#define __RAW_RW_LOCK_UNLOCKED		{ RW_LOCK_BIAS }
-
-#endif /* _ASM_M32R_SPINLOCK_TYPES_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/stat.h linux-2.6.30-rc3/include/asm-m32r/stat.h
--- linux-2.6.30-rc2/include/asm-m32r/stat.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/stat.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,87 +0,0 @@
-#ifndef _ASM_M32R_STAT_H
-#define _ASM_M32R_STAT_H
-
-#include <asm/byteorder.h>
-
-struct __old_kernel_stat {
-	unsigned short st_dev;
-	unsigned short st_ino;
-	unsigned short st_mode;
-	unsigned short st_nlink;
-	unsigned short st_uid;
-	unsigned short st_gid;
-	unsigned short st_rdev;
-	unsigned long  st_size;
-	unsigned long  st_atime;
-	unsigned long  st_mtime;
-	unsigned long  st_ctime;
-};
-
-#define STAT_HAVE_NSEC	1
-
-struct stat {
-	unsigned short st_dev;
-	unsigned short __pad1;
-	unsigned long  st_ino;
-	unsigned short st_mode;
-	unsigned short st_nlink;
-	unsigned short st_uid;
-	unsigned short st_gid;
-	unsigned short st_rdev;
-	unsigned short __pad2;
-	unsigned long  st_size;
-	unsigned long  st_blksize;
-	unsigned long  st_blocks;
-	unsigned long  st_atime;
-	unsigned long  st_atime_nsec;
-	unsigned long  st_mtime;
-	unsigned long  st_mtime_nsec;
-	unsigned long  st_ctime;
-	unsigned long  st_ctime_nsec;
-	unsigned long  __unused4;
-	unsigned long  __unused5;
-};
-
-/* This matches struct stat64 in glibc2.1, hence the absolutely
- * insane amounts of padding around dev_t's.
- */
-struct stat64 {
-	unsigned long long	st_dev;
-	unsigned char	__pad0[4];
-#define STAT64_HAS_BROKEN_ST_INO
-	unsigned long	__st_ino;
-
-	unsigned int	st_mode;
-	unsigned int	st_nlink;
-
-	unsigned long	st_uid;
-	unsigned long	st_gid;
-
-	unsigned long long	st_rdev;
-	unsigned char	__pad3[4];
-
-	long long	st_size;
-	unsigned long	st_blksize;
-
-#if defined(__BIG_ENDIAN)
-	unsigned long	__pad4;		/* future possible st_blocks high bits */
-	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
-#elif defined(__LITTLE_ENDIAN)
-	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
-	unsigned long	__pad4;		/* future possible st_blocks high bits */
-#else
-#error no endian defined
-#endif
-	unsigned long	st_atime;
-	unsigned long	st_atime_nsec;
-
-	unsigned long	st_mtime;
-	unsigned long	st_mtime_nsec;
-
-	unsigned long	st_ctime;
-	unsigned long	st_ctime_nsec;
-
-	unsigned long long	st_ino;
-};
-
-#endif  /* _ASM_M32R_STAT_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/statfs.h linux-2.6.30-rc3/include/asm-m32r/statfs.h
--- linux-2.6.30-rc2/include/asm-m32r/statfs.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/statfs.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_M32R_STATFS_H
-#define _ASM_M32R_STATFS_H
-
-#include <asm-generic/statfs.h>
-
-#endif  /* _ASM_M32R_STATFS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/string.h linux-2.6.30-rc3/include/asm-m32r/string.h
--- linux-2.6.30-rc2/include/asm-m32r/string.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/string.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,13 +0,0 @@
-#ifndef _ASM_M32R_STRING_H
-#define _ASM_M32R_STRING_H
-
-#define  __HAVE_ARCH_STRLEN
-extern size_t strlen(const char * s);
-
-#define  __HAVE_ARCH_MEMCPY
-extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
-
-#define  __HAVE_ARCH_MEMSET
-extern void *memset(void *__s, int __c, size_t __count);
-
-#endif  /* _ASM_M32R_STRING_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/swab.h linux-2.6.30-rc3/include/asm-m32r/swab.h
--- linux-2.6.30-rc2/include/asm-m32r/swab.h	2009-04-22 03:29:12.141931410 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/swab.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,10 +0,0 @@
-#ifndef _ASM_M32R_SWAB_H
-#define _ASM_M32R_SWAB_H
-
-#include <linux/types.h>
-
-#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
-#  define __SWAB_64_THRU_32__
-#endif
-
-#endif /* _ASM_M32R_SWAB_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/syscall.h linux-2.6.30-rc3/include/asm-m32r/syscall.h
--- linux-2.6.30-rc2/include/asm-m32r/syscall.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/syscall.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-#ifndef _ASM_M32R_SYSCALL_H
-#define _ASM_M32R_SYSCALL_H
-
-/* Definitions for the system call vector.  */
-#define SYSCALL_VECTOR          "2"
-#define SYSCALL_VECTOR_ADDRESS  "0xa0"
-
-#endif /* _ASM_M32R_SYSCALL_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/system.h linux-2.6.30-rc3/include/asm-m32r/system.h
--- linux-2.6.30-rc2/include/asm-m32r/system.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/system.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,431 +0,0 @@
-#ifndef _ASM_M32R_SYSTEM_H
-#define _ASM_M32R_SYSTEM_H
-
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2001  Hiroyuki Kondo, Hirokazu Takata, and Hitoshi Yamamoto
- * Copyright (C) 2004, 2006  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#include <linux/compiler.h>
-#include <asm/assembler.h>
-
-#ifdef __KERNEL__
-
-/*
- * switch_to(prev, next) should switch from task `prev' to `next'
- * `prev' will never be the same as `next'.
- *
- * `next' and `prev' should be struct task_struct, but it isn't always defined
- */
-
-#if defined(CONFIG_FRAME_POINTER) || \
-	!defined(CONFIG_SCHED_OMIT_FRAME_POINTER)
-#define M32R_PUSH_FP "	push fp\n"
-#define M32R_POP_FP  "	pop  fp\n"
-#else
-#define M32R_PUSH_FP ""
-#define M32R_POP_FP  ""
-#endif
-
-#define switch_to(prev, next, last)  do { \
-	__asm__ __volatile__ ( \
-		"	seth	lr, #high(1f)				\n" \
-		"	or3	lr, lr, #low(1f)			\n" \
-		"	st	lr, @%4  ; store old LR			\n" \
-		"	ld	lr, @%5  ; load new LR			\n" \
-			M32R_PUSH_FP \
-		"	st	sp, @%2  ; store old SP			\n" \
-		"	ld	sp, @%3  ; load new SP			\n" \
-		"	push	%1  ; store `prev' on new stack		\n" \
-		"	jmp	lr					\n" \
-		"	.fillinsn					\n" \
-		"1:							\n" \
-		"	pop	%0  ; restore `__last' from new stack	\n" \
-			M32R_POP_FP \
-		: "=r" (last) \
-		: "0" (prev), \
-		  "r" (&(prev->thread.sp)), "r" (&(next->thread.sp)), \
-		  "r" (&(prev->thread.lr)), "r" (&(next->thread.lr)) \
-		: "memory", "lr" \
-	); \
-} while(0)
-
-/* Interrupt Control */
-#if !defined(CONFIG_CHIP_M32102) && !defined(CONFIG_CHIP_M32104)
-#define local_irq_enable() \
-	__asm__ __volatile__ ("setpsw #0x40 -> nop": : :"memory")
-#define local_irq_disable() \
-	__asm__ __volatile__ ("clrpsw #0x40 -> nop": : :"memory")
-#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
-static inline void local_irq_enable(void)
-{
-	unsigned long tmpreg;
-	__asm__ __volatile__(
-		"mvfc	%0, psw;		\n\t"
-		"or3	%0, %0, #0x0040;	\n\t"
-		"mvtc	%0, psw;		\n\t"
-	: "=&r" (tmpreg) : : "cbit", "memory");
-}
-
-static inline void local_irq_disable(void)
-{
-	unsigned long tmpreg0, tmpreg1;
-	__asm__ __volatile__(
-		"ld24	%0, #0	; Use 32-bit insn. \n\t"
-		"mvfc	%1, psw	; No interrupt can be accepted here. \n\t"
-		"mvtc	%0, psw	\n\t"
-		"and3	%0, %1, #0xffbf	\n\t"
-		"mvtc	%0, psw	\n\t"
-	: "=&r" (tmpreg0), "=&r" (tmpreg1) : : "cbit", "memory");
-}
-#endif	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
-
-#define local_save_flags(x) \
-	__asm__ __volatile__("mvfc %0,psw" : "=r"(x) : /* no input */)
-
-#define local_irq_restore(x) \
-	__asm__ __volatile__("mvtc %0,psw" : /* no outputs */ \
-		: "r" (x) : "cbit", "memory")
-
-#if !(defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_M32104))
-#define local_irq_save(x)				\
-	__asm__ __volatile__(				\
-  		"mvfc	%0, psw;		\n\t"	\
-	  	"clrpsw	#0x40 -> nop;		\n\t"	\
-  		: "=r" (x) : /* no input */ : "memory")
-#else	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
-#define local_irq_save(x) 				\
-	({						\
-		unsigned long tmpreg;			\
-		__asm__ __volatile__( 			\
-			"ld24	%1, #0 \n\t" 		\
-			"mvfc	%0, psw \n\t"		\
-			"mvtc	%1, psw \n\t"		\
-			"and3	%1, %0, #0xffbf \n\t"	\
-			"mvtc	%1, psw \n\t" 		\
-			: "=r" (x), "=&r" (tmpreg)	\
-			: : "cbit", "memory");		\
-	})
-#endif	/* CONFIG_CHIP_M32102 || CONFIG_CHIP_M32104 */
-
-#define irqs_disabled()					\
-	({						\
-		unsigned long flags;			\
-		local_save_flags(flags);		\
-		!(flags & 0x40);			\
-	})
-
-#define nop()	__asm__ __volatile__ ("nop" : : )
-
-#define xchg(ptr, x)							\
-	((__typeof__(*(ptr)))__xchg((unsigned long)(x), (ptr), sizeof(*(ptr))))
-#define xchg_local(ptr, x)						\
-	((__typeof__(*(ptr)))__xchg_local((unsigned long)(x), (ptr),	\
-			sizeof(*(ptr))))
-
-extern void  __xchg_called_with_bad_pointer(void);
-
-#ifdef CONFIG_CHIP_M32700_TS1
-#define DCACHE_CLEAR(reg0, reg1, addr)				\
-	"seth	"reg1", #high(dcache_dummy);		\n\t"	\
-	"or3	"reg1", "reg1", #low(dcache_dummy);	\n\t"	\
-	"lock	"reg0", @"reg1";			\n\t"	\
-	"add3	"reg0", "addr", #0x1000;		\n\t"	\
-	"ld	"reg0", @"reg0";			\n\t"	\
-	"add3	"reg0", "addr", #0x2000;		\n\t"	\
-	"ld	"reg0", @"reg0";			\n\t"	\
-	"unlock	"reg0", @"reg1";			\n\t"
-	/* FIXME: This workaround code cannot handle kernel modules
-	 * correctly under SMP environment.
-	 */
-#else	/* CONFIG_CHIP_M32700_TS1 */
-#define DCACHE_CLEAR(reg0, reg1, addr)
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-
-static __always_inline unsigned long
-__xchg(unsigned long x, volatile void *ptr, int size)
-{
-	unsigned long flags;
-	unsigned long tmp = 0;
-
-	local_irq_save(flags);
-
-	switch (size) {
-#ifndef CONFIG_SMP
-	case 1:
-		__asm__ __volatile__ (
-			"ldb	%0, @%2 \n\t"
-			"stb	%1, @%2 \n\t"
-			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
-		break;
-	case 2:
-		__asm__ __volatile__ (
-			"ldh	%0, @%2 \n\t"
-			"sth	%1, @%2 \n\t"
-			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
-		break;
-	case 4:
-		__asm__ __volatile__ (
-			"ld	%0, @%2 \n\t"
-			"st	%1, @%2 \n\t"
-			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
-		break;
-#else  /* CONFIG_SMP */
-	case 4:
-		__asm__ __volatile__ (
-			DCACHE_CLEAR("%0", "r4", "%2")
-			"lock	%0, @%2;	\n\t"
-			"unlock	%1, @%2;	\n\t"
-			: "=&r" (tmp) : "r" (x), "r" (ptr)
-			: "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-			, "r4"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
-		);
-		break;
-#endif  /* CONFIG_SMP */
-	default:
-		__xchg_called_with_bad_pointer();
-	}
-
-	local_irq_restore(flags);
-
-	return (tmp);
-}
-
-static __always_inline unsigned long
-__xchg_local(unsigned long x, volatile void *ptr, int size)
-{
-	unsigned long flags;
-	unsigned long tmp = 0;
-
-	local_irq_save(flags);
-
-	switch (size) {
-	case 1:
-		__asm__ __volatile__ (
-			"ldb	%0, @%2 \n\t"
-			"stb	%1, @%2 \n\t"
-			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
-		break;
-	case 2:
-		__asm__ __volatile__ (
-			"ldh	%0, @%2 \n\t"
-			"sth	%1, @%2 \n\t"
-			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
-		break;
-	case 4:
-		__asm__ __volatile__ (
-			"ld	%0, @%2 \n\t"
-			"st	%1, @%2 \n\t"
-			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
-		break;
-	default:
-		__xchg_called_with_bad_pointer();
-	}
-
-	local_irq_restore(flags);
-
-	return (tmp);
-}
-
-#define __HAVE_ARCH_CMPXCHG	1
-
-static inline unsigned long
-__cmpxchg_u32(volatile unsigned int *p, unsigned int old, unsigned int new)
-{
-	unsigned long flags;
-	unsigned int retval;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-			DCACHE_CLEAR("%0", "r4", "%1")
-			M32R_LOCK" %0, @%1;	\n"
-		"	bne	%0, %2, 1f;	\n"
-			M32R_UNLOCK" %3, @%1;	\n"
-		"	bra	2f;		\n"
-                "       .fillinsn		\n"
-		"1:"
-			M32R_UNLOCK" %0, @%1;	\n"
-                "       .fillinsn		\n"
-		"2:"
-			: "=&r" (retval)
-			: "r" (p), "r" (old), "r" (new)
-			: "cbit", "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-			, "r4"
-#endif  /* CONFIG_CHIP_M32700_TS1 */
-		);
-	local_irq_restore(flags);
-
-	return retval;
-}
-
-static inline unsigned long
-__cmpxchg_local_u32(volatile unsigned int *p, unsigned int old,
-			unsigned int new)
-{
-	unsigned long flags;
-	unsigned int retval;
-
-	local_irq_save(flags);
-	__asm__ __volatile__ (
-			DCACHE_CLEAR("%0", "r4", "%1")
-			"ld %0, @%1;		\n"
-		"	bne	%0, %2, 1f;	\n"
-			"st %3, @%1;		\n"
-		"	bra	2f;		\n"
-		"       .fillinsn		\n"
-		"1:"
-			"st %0, @%1;		\n"
-		"       .fillinsn		\n"
-		"2:"
-			: "=&r" (retval)
-			: "r" (p), "r" (old), "r" (new)
-			: "cbit", "memory"
-#ifdef CONFIG_CHIP_M32700_TS1
-			, "r4"
-#endif  /* CONFIG_CHIP_M32700_TS1 */
-		);
-	local_irq_restore(flags);
-
-	return retval;
-}
-
-/* This function doesn't exist, so you'll get a linker error
-   if something tries to do an invalid cmpxchg().  */
-extern void __cmpxchg_called_with_bad_pointer(void);
-
-static inline unsigned long
-__cmpxchg(volatile void *ptr, unsigned long old, unsigned long new, int size)
-{
-	switch (size) {
-	case 4:
-		return __cmpxchg_u32(ptr, old, new);
-#if 0	/* we don't have __cmpxchg_u64 */
-	case 8:
-		return __cmpxchg_u64(ptr, old, new);
-#endif /* 0 */
-	}
-	__cmpxchg_called_with_bad_pointer();
-	return old;
-}
-
-#define cmpxchg(ptr, o, n)						 \
-	((__typeof__(*(ptr))) __cmpxchg((ptr), (unsigned long)(o),	 \
-			(unsigned long)(n), sizeof(*(ptr))))
-
-#include <asm-generic/cmpxchg-local.h>
-
-static inline unsigned long __cmpxchg_local(volatile void *ptr,
-				      unsigned long old,
-				      unsigned long new, int size)
-{
-	switch (size) {
-	case 4:
-		return __cmpxchg_local_u32(ptr, old, new);
-	default:
-		return __cmpxchg_local_generic(ptr, old, new, size);
-	}
-
-	return old;
-}
-
-/*
- * cmpxchg_local and cmpxchg64_local are atomic wrt current CPU. Always make
- * them available.
- */
-#define cmpxchg_local(ptr, o, n)				  	    \
-	((__typeof__(*(ptr)))__cmpxchg_local((ptr), (unsigned long)(o),	    \
-			(unsigned long)(n), sizeof(*(ptr))))
-#define cmpxchg64_local(ptr, o, n) __cmpxchg64_local_generic((ptr), (o), (n))
-
-#endif  /* __KERNEL__ */
-
-/*
- * Memory barrier.
- *
- * mb() prevents loads and stores being reordered across this point.
- * rmb() prevents loads being reordered across this point.
- * wmb() prevents stores being reordered across this point.
- */
-#define mb()   barrier()
-#define rmb()  mb()
-#define wmb()  mb()
-
-/**
- * read_barrier_depends - Flush all pending reads that subsequents reads
- * depend on.
- *
- * No data-dependent reads from memory-like regions are ever reordered
- * over this barrier.  All reads preceding this primitive are guaranteed
- * to access memory (but not necessarily other CPUs' caches) before any
- * reads following this primitive that depend on the data return by
- * any of the preceding reads.  This primitive is much lighter weight than
- * rmb() on most CPUs, and is never heavier weight than is
- * rmb().
- *
- * These ordering constraints are respected by both the local CPU
- * and the compiler.
- *
- * Ordering is not guaranteed by anything other than these primitives,
- * not even by data dependencies.  See the documentation for
- * memory_barrier() for examples and URLs to more information.
- *
- * For example, the following code would force ordering (the initial
- * value of "a" is zero, "b" is one, and "p" is "&a"):
- *
- * <programlisting>
- *      CPU 0                           CPU 1
- *
- *      b = 2;
- *      memory_barrier();
- *      p = &b;                         q = p;
- *                                      read_barrier_depends();
- *                                      d = *q;
- * </programlisting>
- *
- *
- * because the read of "*q" depends on the read of "p" and these
- * two reads are separated by a read_barrier_depends().  However,
- * the following code, with the same initial values for "a" and "b":
- *
- * <programlisting>
- *      CPU 0                           CPU 1
- *
- *      a = 2;
- *      memory_barrier();
- *      b = 3;                          y = b;
- *                                      read_barrier_depends();
- *                                      x = a;
- * </programlisting>
- *
- * does not enforce ordering, since there is no data dependency between
- * the read of "a" and the read of "b".  Therefore, on some CPUs, such
- * as Alpha, "y" could be set to 3 and "x" to 0.  Use rmb()
- * in cases like this where there are no data dependencies.
- **/
-
-#define read_barrier_depends()	do { } while (0)
-
-#ifdef CONFIG_SMP
-#define smp_mb()	mb()
-#define smp_rmb()	rmb()
-#define smp_wmb()	wmb()
-#define smp_read_barrier_depends()	read_barrier_depends()
-#define set_mb(var, value) do { (void) xchg(&var, value); } while (0)
-#else
-#define smp_mb()	barrier()
-#define smp_rmb()	barrier()
-#define smp_wmb()	barrier()
-#define smp_read_barrier_depends()	do { } while (0)
-#define set_mb(var, value) do { var = value; barrier(); } while (0)
-#endif
-
-#define arch_align_stack(x) (x)
-
-#endif /* _ASM_M32R_SYSTEM_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/termbits.h linux-2.6.30-rc3/include/asm-m32r/termbits.h
--- linux-2.6.30-rc2/include/asm-m32r/termbits.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/termbits.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,199 +0,0 @@
-#ifndef _ASM_M32R_TERMBITS_H
-#define _ASM_M32R_TERMBITS_H
-
-#include <linux/posix_types.h>
-
-typedef unsigned char	cc_t;
-typedef unsigned int	speed_t;
-typedef unsigned int	tcflag_t;
-
-#define NCCS 19
-struct termios {
-	tcflag_t c_iflag;		/* input mode flags */
-	tcflag_t c_oflag;		/* output mode flags */
-	tcflag_t c_cflag;		/* control mode flags */
-	tcflag_t c_lflag;		/* local mode flags */
-	cc_t c_line;			/* line discipline */
-	cc_t c_cc[NCCS];		/* control characters */
-};
-
-struct termios2 {
-	tcflag_t c_iflag;		/* input mode flags */
-	tcflag_t c_oflag;		/* output mode flags */
-	tcflag_t c_cflag;		/* control mode flags */
-	tcflag_t c_lflag;		/* local mode flags */
-	cc_t c_line;			/* line discipline */
-	cc_t c_cc[NCCS];		/* control characters */
-	speed_t c_ispeed;		/* input speed */
-	speed_t c_ospeed;		/* output speed */
-};
-
-struct ktermios {
-	tcflag_t c_iflag;		/* input mode flags */
-	tcflag_t c_oflag;		/* output mode flags */
-	tcflag_t c_cflag;		/* control mode flags */
-	tcflag_t c_lflag;		/* local mode flags */
-	cc_t c_line;			/* line discipline */
-	cc_t c_cc[NCCS];		/* control characters */
-	speed_t c_ispeed;		/* input speed */
-	speed_t c_ospeed;		/* output speed */
-};
-
-/* c_cc characters */
-#define VINTR 0
-#define VQUIT 1
-#define VERASE 2
-#define VKILL 3
-#define VEOF 4
-#define VTIME 5
-#define VMIN 6
-#define VSWTC 7
-#define VSTART 8
-#define VSTOP 9
-#define VSUSP 10
-#define VEOL 11
-#define VREPRINT 12
-#define VDISCARD 13
-#define VWERASE 14
-#define VLNEXT 15
-#define VEOL2 16
-
-/* c_iflag bits */
-#define IGNBRK	0000001
-#define BRKINT	0000002
-#define IGNPAR	0000004
-#define PARMRK	0000010
-#define INPCK	0000020
-#define ISTRIP	0000040
-#define INLCR	0000100
-#define IGNCR	0000200
-#define ICRNL	0000400
-#define IUCLC	0001000
-#define IXON	0002000
-#define IXANY	0004000
-#define IXOFF	0010000
-#define IMAXBEL	0020000
-#define IUTF8   0040000
-
-/* c_oflag bits */
-#define OPOST	0000001
-#define OLCUC	0000002
-#define ONLCR	0000004
-#define OCRNL	0000010
-#define ONOCR	0000020
-#define ONLRET	0000040
-#define OFILL	0000100
-#define OFDEL	0000200
-#define NLDLY	0000400
-#define   NL0	0000000
-#define   NL1	0000400
-#define CRDLY	0003000
-#define   CR0	0000000
-#define   CR1	0001000
-#define   CR2	0002000
-#define   CR3	0003000
-#define TABDLY	0014000
-#define   TAB0	0000000
-#define   TAB1	0004000
-#define   TAB2	0010000
-#define   TAB3	0014000
-#define   XTABS	0014000
-#define BSDLY	0020000
-#define   BS0	0000000
-#define   BS1	0020000
-#define VTDLY	0040000
-#define   VT0	0000000
-#define   VT1	0040000
-#define FFDLY	0100000
-#define   FF0	0000000
-#define   FF1	0100000
-
-/* c_cflag bit meaning */
-#define CBAUD	0010017
-#define  B0	0000000		/* hang up */
-#define  B50	0000001
-#define  B75	0000002
-#define  B110	0000003
-#define  B134	0000004
-#define  B150	0000005
-#define  B200	0000006
-#define  B300	0000007
-#define  B600	0000010
-#define  B1200	0000011
-#define  B1800	0000012
-#define  B2400	0000013
-#define  B4800	0000014
-#define  B9600	0000015
-#define  B19200	0000016
-#define  B38400	0000017
-#define EXTA B19200
-#define EXTB B38400
-#define CSIZE	0000060
-#define   CS5	0000000
-#define   CS6	0000020
-#define   CS7	0000040
-#define   CS8	0000060
-#define CSTOPB	0000100
-#define CREAD	0000200
-#define PARENB	0000400
-#define PARODD	0001000
-#define HUPCL	0002000
-#define CLOCAL	0004000
-#define CBAUDEX 0010000
-#define    BOTHER 0010000
-#define    B57600 0010001
-#define   B115200 0010002
-#define   B230400 0010003
-#define   B460800 0010004
-#define   B500000 0010005
-#define   B576000 0010006
-#define   B921600 0010007
-#define  B1000000 0010010
-#define  B1152000 0010011
-#define  B1500000 0010012
-#define  B2000000 0010013
-#define  B2500000 0010014
-#define  B3000000 0010015
-#define  B3500000 0010016
-#define  B4000000 0010017
-#define CIBAUD	  002003600000		/** input baud rate */
-#define CTVB	  004000000000		/* VisioBraille Terminal flow control */
-#define CMSPAR	  010000000000		/* mark or space (stick) parity */
-#define CRTSCTS	  020000000000		/* flow control */
-
-#define	IBSHIFT	16			/* Shift from CBAUD to CIBAUD */
-
-/* c_lflag bits */
-#define ISIG	0000001
-#define ICANON	0000002
-#define XCASE	0000004
-#define ECHO	0000010
-#define ECHOE	0000020
-#define ECHOK	0000040
-#define ECHONL	0000100
-#define NOFLSH	0000200
-#define TOSTOP	0000400
-#define ECHOCTL	0001000
-#define ECHOPRT	0002000
-#define ECHOKE	0004000
-#define FLUSHO	0010000
-#define PENDIN	0040000
-#define IEXTEN	0100000
-
-/* tcflow() and TCXONC use these */
-#define	TCOOFF		0
-#define	TCOON		1
-#define	TCIOFF		2
-#define	TCION		3
-
-/* tcflush() and TCFLSH use these */
-#define	TCIFLUSH	0
-#define	TCOFLUSH	1
-#define	TCIOFLUSH	2
-
-/* tcsetattr uses these */
-#define	TCSANOW		0
-#define	TCSADRAIN	1
-#define	TCSAFLUSH	2
-
-#endif /* _ASM_M32R_TERMBITS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/termios.h linux-2.6.30-rc3/include/asm-m32r/termios.h
--- linux-2.6.30-rc2/include/asm-m32r/termios.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/termios.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,91 +0,0 @@
-#ifndef _M32R_TERMIOS_H
-#define _M32R_TERMIOS_H
-
-#include <asm/termbits.h>
-#include <asm/ioctls.h>
-
-struct winsize {
-	unsigned short ws_row;
-	unsigned short ws_col;
-	unsigned short ws_xpixel;
-	unsigned short ws_ypixel;
-};
-
-#define NCC 8
-struct termio {
-	unsigned short c_iflag;		/* input mode flags */
-	unsigned short c_oflag;		/* output mode flags */
-	unsigned short c_cflag;		/* control mode flags */
-	unsigned short c_lflag;		/* local mode flags */
-	unsigned char c_line;		/* line discipline */
-	unsigned char c_cc[NCC];	/* control characters */
-};
-
-/* modem lines */
-#define TIOCM_LE	0x001
-#define TIOCM_DTR	0x002
-#define TIOCM_RTS	0x004
-#define TIOCM_ST	0x008
-#define TIOCM_SR	0x010
-#define TIOCM_CTS	0x020
-#define TIOCM_CAR	0x040
-#define TIOCM_RNG	0x080
-#define TIOCM_DSR	0x100
-#define TIOCM_CD	TIOCM_CAR
-#define TIOCM_RI	TIOCM_RNG
-#define TIOCM_OUT1	0x2000
-#define TIOCM_OUT2	0x4000
-#define TIOCM_LOOP	0x8000
-
-/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
-
-#ifdef __KERNEL__
-#include <linux/module.h>
-
-/*	intr=^C		quit=^\		erase=del	kill=^U
-	eof=^D		vtime=\0	vmin=\1		sxtc=\0
-	start=^Q	stop=^S		susp=^Z		eol=\0
-	reprint=^R	discard=^U	werase=^W	lnext=^V
-	eol2=\0
-*/
-#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
-
-/*
- * Translate a "termio" structure into a "termios". Ugh.
- */
-#define SET_LOW_TERMIOS_BITS(termios, termio, x) { \
-	unsigned short __tmp; \
-	get_user(__tmp,&(termio)->x); \
-	*(unsigned short *) &(termios)->x = __tmp; \
-}
-
-#define user_termio_to_kernel_termios(termios, termio) \
-({ \
-	SET_LOW_TERMIOS_BITS(termios, termio, c_iflag); \
-	SET_LOW_TERMIOS_BITS(termios, termio, c_oflag); \
-	SET_LOW_TERMIOS_BITS(termios, termio, c_cflag); \
-	SET_LOW_TERMIOS_BITS(termios, termio, c_lflag); \
-	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
-})
-
-/*
- * Translate a "termios" structure into a "termio". Ugh.
- */
-#define kernel_termios_to_user_termio(termio, termios) \
-({ \
-	put_user((termios)->c_iflag, &(termio)->c_iflag); \
-	put_user((termios)->c_oflag, &(termio)->c_oflag); \
-	put_user((termios)->c_cflag, &(termio)->c_cflag); \
-	put_user((termios)->c_lflag, &(termio)->c_lflag); \
-	put_user((termios)->c_line,  &(termio)->c_line); \
-	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
-})
-
-#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios2))
-#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios2))
-#define user_termios_to_kernel_termios_1(k, u) copy_from_user(k, u, sizeof(struct termios))
-#define kernel_termios_to_user_termios_1(u, k) copy_to_user(u, k, sizeof(struct termios))
-
-#endif	/* __KERNEL__ */
-
-#endif	/* _M32R_TERMIOS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/thread_info.h linux-2.6.30-rc3/include/asm-m32r/thread_info.h
--- linux-2.6.30-rc2/include/asm-m32r/thread_info.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/thread_info.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,184 +0,0 @@
-#ifndef _ASM_M32R_THREAD_INFO_H
-#define _ASM_M32R_THREAD_INFO_H
-
-/* thread_info.h: m32r low-level thread information
- *
- * Copyright (C) 2002  David Howells (dhowells@redhat.com)
- * - Incorporating suggestions made by Linus Torvalds and Dave Miller
- * Copyright (C) 2004  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-#ifdef __KERNEL__
-
-#ifndef __ASSEMBLY__
-#include <asm/processor.h>
-#endif
-
-/*
- * low level task data that entry.S needs immediate access to
- * - this struct should fit entirely inside of one cache line
- * - this struct shares the supervisor stack pages
- * - if the contents of this structure are changed, the assembly constants must also be changed
- */
-#ifndef __ASSEMBLY__
-
-struct thread_info {
-	struct task_struct	*task;		/* main task structure */
-	struct exec_domain	*exec_domain;	/* execution domain */
-	unsigned long		flags;		/* low level flags */
-	unsigned long		status;		/* thread-synchronous flags */
-	__u32			cpu;		/* current CPU */
-	int			preempt_count;	/* 0 => preemptable, <0 => BUG */
-
-	mm_segment_t		addr_limit;	/* thread address space:
-					 	   0-0xBFFFFFFF for user-thread
-						   0-0xFFFFFFFF for kernel-thread
-						*/
-	struct restart_block    restart_block;
-
-	__u8			supervisor_stack[0];
-};
-
-#else /* !__ASSEMBLY__ */
-
-/* offsets into the thread_info struct for assembly code access */
-#define TI_TASK		0x00000000
-#define TI_EXEC_DOMAIN	0x00000004
-#define TI_FLAGS	0x00000008
-#define TI_STATUS	0x0000000C
-#define TI_CPU		0x00000010
-#define TI_PRE_COUNT	0x00000014
-#define TI_ADDR_LIMIT	0x00000018
-#define TI_RESTART_BLOCK 0x000001C
-
-#endif
-
-#define PREEMPT_ACTIVE		0x10000000
-
-/*
- * macros/functions for gaining access to the thread information structure
- *
- * preempt_count needs to be 1 initially, until the scheduler is functional.
- */
-#ifndef __ASSEMBLY__
-
-#define INIT_THREAD_INFO(tsk)			\
-{						\
-	.task		= &tsk,			\
-	.exec_domain	= &default_exec_domain,	\
-	.flags		= 0,			\
-	.cpu		= 0,			\
-	.preempt_count	= 1,			\
-	.addr_limit	= KERNEL_DS,		\
-	.restart_block = {			\
-		.fn = do_no_restart_syscall,	\
-	},					\
-}
-
-#define init_thread_info	(init_thread_union.thread_info)
-#define init_stack		(init_thread_union.stack)
-
-#define THREAD_SIZE (2*PAGE_SIZE)
-
-/* how to get the thread information struct from C */
-static inline struct thread_info *current_thread_info(void)
-{
-	struct thread_info *ti;
-
-	__asm__ __volatile__ (
-		"ldi	%0, #%1			\n\t"
-		"and	%0, sp			\n\t"
-		: "=r" (ti) : "i" (~(THREAD_SIZE - 1))
-	);
-
-	return ti;
-}
-
-#define __HAVE_ARCH_THREAD_INFO_ALLOCATOR
-
-/* thread information allocation */
-#ifdef CONFIG_DEBUG_STACK_USAGE
-#define alloc_thread_info(tsk)					\
-	({							\
-		struct thread_info *ret;			\
-	 							\
-	 	ret = kzalloc(THREAD_SIZE, GFP_KERNEL);		\
-								\
-	 	ret;						\
-	 })
-#else
-#define alloc_thread_info(tsk) kmalloc(THREAD_SIZE, GFP_KERNEL)
-#endif
-
-#define free_thread_info(info) kfree(info)
-
-#define TI_FLAG_FAULT_CODE_SHIFT	28
-
-static inline void set_thread_fault_code(unsigned int val)
-{
-	struct thread_info *ti = current_thread_info();
-	ti->flags = (ti->flags & (~0 >> (32 - TI_FLAG_FAULT_CODE_SHIFT)))
-		| (val << TI_FLAG_FAULT_CODE_SHIFT);
-}
-
-static inline unsigned int get_thread_fault_code(void)
-{
-	struct thread_info *ti = current_thread_info();
-	return ti->flags >> TI_FLAG_FAULT_CODE_SHIFT;
-}
-
-#else /* !__ASSEMBLY__ */
-
-#define THREAD_SIZE	8192
-
-/* how to get the thread information struct from ASM */
-#define GET_THREAD_INFO(reg)	GET_THREAD_INFO reg
-	.macro GET_THREAD_INFO reg
-	ldi	\reg, #-THREAD_SIZE
-	and	\reg, sp
-	.endm
-
-#endif
-
-/*
- * thread information flags
- * - these are process state flags that various assembly files may need to access
- * - pending work-to-be-done flags are in LSW
- * - other flags in MSW
- */
-#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
-#define TIF_SIGPENDING		1	/* signal pending */
-#define TIF_NEED_RESCHED	2	/* rescheduling necessary */
-#define TIF_SINGLESTEP		3	/* restore singlestep on return to user mode */
-#define TIF_IRET		4	/* return with iret */
-#define TIF_RESTORE_SIGMASK	8	/* restore signal mask in do_signal() */
-#define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
-#define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
-#define TIF_MEMDIE		18	/* OOM killer killed process */
-#define TIF_FREEZE		19	/* is freezing for suspend */
-
-#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
-#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
-#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
-#define _TIF_SINGLESTEP		(1<<TIF_SINGLESTEP)
-#define _TIF_IRET		(1<<TIF_IRET)
-#define _TIF_RESTORE_SIGMASK	(1<<TIF_RESTORE_SIGMASK)
-#define _TIF_USEDFPU		(1<<TIF_USEDFPU)
-#define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
-#define _TIF_FREEZE		(1<<TIF_FREEZE)
-
-#define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
-#define _TIF_ALLWORK_MASK	0x0000FFFF	/* work to do on any return to u-space */
-
-/*
- * Thread-synchronous status.
- *
- * This is different from the flags in that nobody else
- * ever touches our thread-synchronous status, so we don't
- * have to worry about atomic accesses.
- */
-#define TS_USEDFPU		0x0001	/* FPU was used by this task this quantum (SMP) */
-
-#endif /* __KERNEL__ */
-
-#endif /* _ASM_M32R_THREAD_INFO_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/timex.h linux-2.6.30-rc3/include/asm-m32r/timex.h
--- linux-2.6.30-rc2/include/asm-m32r/timex.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/timex.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,27 +0,0 @@
-#ifndef _ASM_M32R_TIMEX_H
-#define _ASM_M32R_TIMEX_H
-
-/*
- * linux/include/asm-m32r/timex.h
- *
- * m32r architecture timex specifications
- */
-
-#define CLOCK_TICK_RATE	(CONFIG_BUS_CLOCK / CONFIG_TIMER_DIVIDE)
-#define CLOCK_TICK_FACTOR	20	/* Factor of both 1000000 and CLOCK_TICK_RATE */
-
-#ifdef __KERNEL__
-/*
- * Standard way to access the cycle counter.
- * Currently only used on SMP.
- */
-
-typedef unsigned long long cycles_t;
-
-static __inline__ cycles_t get_cycles (void)
-{
-	return 0;
-}
-#endif  /* __KERNEL__ */
-
-#endif  /* _ASM_M32R_TIMEX_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/tlb.h linux-2.6.30-rc3/include/asm-m32r/tlb.h
--- linux-2.6.30-rc2/include/asm-m32r/tlb.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/tlb.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-#ifndef _M32R_TLB_H
-#define _M32R_TLB_H
-
-/*
- * x86 doesn't need any special per-pte or
- * per-vma handling..
- */
-#define tlb_start_vma(tlb, vma) do { } while (0)
-#define tlb_end_vma(tlb, vma) do { } while (0)
-#define __tlb_remove_tlb_entry(tlb, pte, address) do { } while (0)
-
-/*
- * .. because we flush the whole mm when it
- * fills up.
- */
-#define tlb_flush(tlb) flush_tlb_mm((tlb)->mm)
-
-#include <asm-generic/tlb.h>
-
-#endif /* _M32R_TLB_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/tlbflush.h linux-2.6.30-rc3/include/asm-m32r/tlbflush.h
--- linux-2.6.30-rc2/include/asm-m32r/tlbflush.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/tlbflush.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,97 +0,0 @@
-#ifndef _ASM_M32R_TLBFLUSH_H
-#define _ASM_M32R_TLBFLUSH_H
-
-#include <asm/m32r.h>
-
-/*
- * TLB flushing:
- *
- *  - flush_tlb() flushes the current mm struct TLBs
- *  - flush_tlb_all() flushes all processes TLBs
- *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
- *  - flush_tlb_page(vma, vmaddr) flushes one page
- *  - flush_tlb_range(vma, start, end) flushes a range of pages
- *  - flush_tlb_kernel_range(start, end) flushes a range of kernel pages
- */
-
-extern void local_flush_tlb_all(void);
-extern void local_flush_tlb_mm(struct mm_struct *);
-extern void local_flush_tlb_page(struct vm_area_struct *, unsigned long);
-extern void local_flush_tlb_range(struct vm_area_struct *, unsigned long,
-	unsigned long);
-
-#ifndef CONFIG_SMP
-#ifdef CONFIG_MMU
-#define flush_tlb_all()			local_flush_tlb_all()
-#define flush_tlb_mm(mm)		local_flush_tlb_mm(mm)
-#define flush_tlb_page(vma, page)	local_flush_tlb_page(vma, page)
-#define flush_tlb_range(vma, start, end)	\
-	local_flush_tlb_range(vma, start, end)
-#define flush_tlb_kernel_range(start, end)	local_flush_tlb_all()
-#else	/* CONFIG_MMU */
-#define flush_tlb_all()			do { } while (0)
-#define flush_tlb_mm(mm)		do { } while (0)
-#define flush_tlb_page(vma, vmaddr)	do { } while (0)
-#define flush_tlb_range(vma, start, end)	do { } while (0)
-#endif	/* CONFIG_MMU */
-#else	/* CONFIG_SMP */
-extern void smp_flush_tlb_all(void);
-extern void smp_flush_tlb_mm(struct mm_struct *);
-extern void smp_flush_tlb_page(struct vm_area_struct *, unsigned long);
-extern void smp_flush_tlb_range(struct vm_area_struct *, unsigned long,
-	unsigned long);
-
-#define flush_tlb_all()			smp_flush_tlb_all()
-#define flush_tlb_mm(mm)		smp_flush_tlb_mm(mm)
-#define flush_tlb_page(vma, page)	smp_flush_tlb_page(vma, page)
-#define flush_tlb_range(vma, start, end)	\
-	smp_flush_tlb_range(vma, start, end)
-#define flush_tlb_kernel_range(start, end)	smp_flush_tlb_all()
-#endif	/* CONFIG_SMP */
-
-static __inline__ void __flush_tlb_page(unsigned long page)
-{
-	unsigned int tmpreg0, tmpreg1, tmpreg2;
-
-	__asm__ __volatile__ (
-		"seth	%0, #high(%4)	\n\t"
-		"st	%3, @(%5, %0)	\n\t"
-		"ldi	%1, #1		\n\t"
-		"st	%1, @(%6, %0)	\n\t"
-		"add3	%1, %0, %7	\n\t"
-		".fillinsn		\n"
-		"1:			\n\t"
-		"ld	%2, @(%6, %0)	\n\t"
-		"bnez	%2, 1b		\n\t"
-		"ld	%0, @%1+	\n\t"
-		"ld	%1, @%1		\n\t"
-		"st	%2, @+%0	\n\t"
-		"st	%2, @+%1	\n\t"
-		: "=&r" (tmpreg0), "=&r" (tmpreg1), "=&r" (tmpreg2)
-		: "r" (page), "i" (MMU_REG_BASE), "i" (MSVA_offset),
-		"i" (MTOP_offset), "i" (MIDXI_offset)
-		: "memory"
-	);
-}
-
-static __inline__ void __flush_tlb_all(void)
-{
-	unsigned int tmpreg0, tmpreg1;
-
-	__asm__ __volatile__ (
-		"seth	%0, #high(%2)		\n\t"
-		"or3	%0, %0, #low(%2)	\n\t"
-		"ldi	%1, #0xc		\n\t"
-		"st	%1, @%0			\n\t"
-		".fillinsn			\n"
-		"1:				\n\t"
-		"ld	%1, @%0			\n\t"
-		"bnez	%1, 1b			\n\t"
-		: "=&r" (tmpreg0), "=&r" (tmpreg1)
-		: "i" (MTOP) : "memory"
-	);
-}
-
-extern void update_mmu_cache(struct vm_area_struct *, unsigned long, pte_t);
-
-#endif	/* _ASM_M32R_TLBFLUSH_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/topology.h linux-2.6.30-rc3/include/asm-m32r/topology.h
--- linux-2.6.30-rc2/include/asm-m32r/topology.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/topology.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_M32R_TOPOLOGY_H
-#define _ASM_M32R_TOPOLOGY_H
-
-#include <asm-generic/topology.h>
-
-#endif /* _ASM_M32R_TOPOLOGY_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/types.h linux-2.6.30-rc3/include/asm-m32r/types.h
--- linux-2.6.30-rc2/include/asm-m32r/types.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/types.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,30 +0,0 @@
-#ifndef _ASM_M32R_TYPES_H
-#define _ASM_M32R_TYPES_H
-
-#include <asm-generic/int-ll64.h>
-
-#ifndef __ASSEMBLY__
-
-typedef unsigned short umode_t;
-
-#endif /* __ASSEMBLY__ */
-
-/*
- * These aren't exported outside the kernel to avoid name space clashes
- */
-#ifdef __KERNEL__
-
-#define BITS_PER_LONG 32
-
-#ifndef __ASSEMBLY__
-
-/* DMA addresses are 32-bits wide.  */
-
-typedef u32 dma_addr_t;
-typedef u64 dma64_addr_t;
-
-#endif /* __ASSEMBLY__ */
-
-#endif /* __KERNEL__ */
-
-#endif /* _ASM_M32R_TYPES_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/uaccess.h linux-2.6.30-rc3/include/asm-m32r/uaccess.h
--- linux-2.6.30-rc2/include/asm-m32r/uaccess.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/uaccess.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,693 +0,0 @@
-#ifndef _ASM_M32R_UACCESS_H
-#define _ASM_M32R_UACCESS_H
-
-/*
- *  linux/include/asm-m32r/uaccess.h
- *
- *  M32R version.
- *    Copyright (C) 2004, 2006  Hirokazu Takata <takata at linux-m32r.org>
- */
-
-/*
- * User space memory access functions
- */
-#include <linux/errno.h>
-#include <linux/thread_info.h>
-#include <asm/page.h>
-#include <asm/setup.h>
-
-#define VERIFY_READ 0
-#define VERIFY_WRITE 1
-
-/*
- * The fs value determines whether argument validity checking should be
- * performed or not.  If get_fs() == USER_DS, checking is performed, with
- * get_fs() == KERNEL_DS, checking is bypassed.
- *
- * For historical reasons, these macros are grossly misnamed.
- */
-
-#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
-
-#ifdef CONFIG_MMU
-
-#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFF)
-#define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
-#define get_ds()	(KERNEL_DS)
-#define get_fs()	(current_thread_info()->addr_limit)
-#define set_fs(x)	(current_thread_info()->addr_limit = (x))
-
-#else /* not CONFIG_MMU */
-
-#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFF)
-#define USER_DS		MAKE_MM_SEG(0xFFFFFFFF)
-#define get_ds()	(KERNEL_DS)
-
-static inline mm_segment_t get_fs(void)
-{
-	return USER_DS;
-}
-
-static inline void set_fs(mm_segment_t s)
-{
-}
-
-#endif /* not CONFIG_MMU */
-
-#define segment_eq(a,b)	((a).seg == (b).seg)
-
-#define __addr_ok(addr) \
-	((unsigned long)(addr) < (current_thread_info()->addr_limit.seg))
-
-/*
- * Test whether a block of memory is a valid user space address.
- * Returns 0 if the range is valid, nonzero otherwise.
- *
- * This is equivalent to the following test:
- * (u33)addr + (u33)size >= (u33)current->addr_limit.seg
- *
- * This needs 33-bit arithmetic. We have a carry...
- */
-#define __range_ok(addr,size) ({					\
-	unsigned long flag, roksum; 					\
-	__chk_user_ptr(addr);						\
-	asm ( 								\
-		"	cmpu	%1, %1    ; clear cbit\n"		\
-		"	addx	%1, %3    ; set cbit if overflow\n"	\
-		"	subx	%0, %0\n"				\
-		"	cmpu	%4, %1\n"				\
-		"	subx	%0, %5\n"				\
-		: "=&r" (flag), "=r" (roksum)				\
-		: "1" (addr), "r" ((int)(size)), 			\
-		  "r" (current_thread_info()->addr_limit.seg), "r" (0)	\
-		: "cbit" );						\
-	flag; })
-
-/**
- * access_ok: - Checks if a user space pointer is valid
- * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE.  Note that
- *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
- *        to write to a block, it is always safe to read from it.
- * @addr: User space pointer to start of block to check
- * @size: Size of block to check
- *
- * Context: User context only.  This function may sleep.
- *
- * Checks if a pointer to a block of memory in user space is valid.
- *
- * Returns true (nonzero) if the memory block may be valid, false (zero)
- * if it is definitely invalid.
- *
- * Note that, depending on architecture, this function probably just
- * checks that the pointer is in the user space range - after calling
- * this function, memory access functions may still return -EFAULT.
- */
-#ifdef CONFIG_MMU
-#define access_ok(type,addr,size) (likely(__range_ok(addr,size) == 0))
-#else
-static inline int access_ok(int type, const void *addr, unsigned long size)
-{
-	unsigned long val = (unsigned long)addr;
-
-	return ((val >= memory_start) && ((val + size) < memory_end));
-}
-#endif /* CONFIG_MMU */
-
-/*
- * The exception table consists of pairs of addresses: the first is the
- * address of an instruction that is allowed to fault, and the second is
- * the address at which the program should continue.  No registers are
- * modified, so it is entirely up to the continuation code to figure out
- * what to do.
- *
- * All the routines below use bits of fixup code that are out of line
- * with the main instruction path.  This means when everything is well,
- * we don't even have to jump over them.  Further, they do not intrude
- * on our cache or tlb entries.
- */
-
-struct exception_table_entry
-{
-	unsigned long insn, fixup;
-};
-
-extern int fixup_exception(struct pt_regs *regs);
-
-/*
- * These are the main single-value transfer routines.  They automatically
- * use the right size if we just have the right pointer type.
- *
- * This gets kind of ugly. We want to return _two_ values in "get_user()"
- * and yet we don't want to do any pointers, because that is too much
- * of a performance impact. Thus we have a few rather ugly macros here,
- * and hide all the uglyness from the user.
- *
- * The "__xxx" versions of the user access functions are versions that
- * do not verify the address space, that must have been done previously
- * with a separate "access_ok()" call (this is used when we do multiple
- * accesses to the same area of user memory).
- */
-
-/* Careful: we have to cast the result to the type of the pointer for sign
-   reasons */
-/**
- * get_user: - Get a simple variable from user space.
- * @x:   Variable to store result.
- * @ptr: Source address, in user space.
- *
- * Context: User context only.  This function may sleep.
- *
- * This macro copies a single simple variable from user space to kernel
- * space.  It supports simple types like char and int, but not larger
- * data types like structures or arrays.
- *
- * @ptr must have pointer-to-simple-variable type, and the result of
- * dereferencing @ptr must be assignable to @x without a cast.
- *
- * Returns zero on success, or -EFAULT on error.
- * On error, the variable @x is set to zero.
- */
-#define get_user(x,ptr)							\
-	__get_user_check((x),(ptr),sizeof(*(ptr)))
-
-/**
- * put_user: - Write a simple value into user space.
- * @x:   Value to copy to user space.
- * @ptr: Destination address, in user space.
- *
- * Context: User context only.  This function may sleep.
- *
- * This macro copies a single simple value from kernel space to user
- * space.  It supports simple types like char and int, but not larger
- * data types like structures or arrays.
- *
- * @ptr must have pointer-to-simple-variable type, and @x must be assignable
- * to the result of dereferencing @ptr.
- *
- * Returns zero on success, or -EFAULT on error.
- */
-#define put_user(x,ptr)							\
-	__put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
-
-/**
- * __get_user: - Get a simple variable from user space, with less checking.
- * @x:   Variable to store result.
- * @ptr: Source address, in user space.
- *
- * Context: User context only.  This function may sleep.
- *
- * This macro copies a single simple variable from user space to kernel
- * space.  It supports simple types like char and int, but not larger
- * data types like structures or arrays.
- *
- * @ptr must have pointer-to-simple-variable type, and the result of
- * dereferencing @ptr must be assignable to @x without a cast.
- *
- * Caller must check the pointer with access_ok() before calling this
- * function.
- *
- * Returns zero on success, or -EFAULT on error.
- * On error, the variable @x is set to zero.
- */
-#define __get_user(x,ptr) \
-	__get_user_nocheck((x),(ptr),sizeof(*(ptr)))
-
-#define __get_user_nocheck(x,ptr,size)					\
-({									\
-	long __gu_err = 0;						\
-	unsigned long __gu_val;						\
-	might_sleep();							\
-	__get_user_size(__gu_val,(ptr),(size),__gu_err);		\
-	(x) = (__typeof__(*(ptr)))__gu_val;				\
-	__gu_err;							\
-})
-
-#define __get_user_check(x,ptr,size)					\
-({									\
-	long __gu_err = -EFAULT;					\
-	unsigned long __gu_val = 0;					\
-	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);		\
-	might_sleep();							\
-	if (access_ok(VERIFY_READ,__gu_addr,size))			\
-		__get_user_size(__gu_val,__gu_addr,(size),__gu_err);	\
-	(x) = (__typeof__(*(ptr)))__gu_val;				\
-	__gu_err;							\
-})
-
-extern long __get_user_bad(void);
-
-#define __get_user_size(x,ptr,size,retval)				\
-do {									\
-	retval = 0;							\
-	__chk_user_ptr(ptr);						\
-	switch (size) {							\
-	  case 1: __get_user_asm(x,ptr,retval,"ub"); break;		\
-	  case 2: __get_user_asm(x,ptr,retval,"uh"); break;		\
-	  case 4: __get_user_asm(x,ptr,retval,""); break;		\
-	  default: (x) = __get_user_bad();				\
-	}								\
-} while (0)
-
-#define __get_user_asm(x, addr, err, itype)				\
-	__asm__ __volatile__(						\
-		"	.fillinsn\n"					\
-		"1:	ld"itype" %1,@%2\n"				\
-		"	.fillinsn\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"	.balign 4\n"					\
-		"3:	ldi %0,%3\n"					\
-		"	seth r14,#high(2b)\n"				\
-		"	or3 r14,r14,#low(2b)\n"				\
-		"	jmp r14\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.balign 4\n"					\
-		"	.long 1b,3b\n"					\
-		".previous"						\
-		: "=&r" (err), "=&r" (x)				\
-		: "r" (addr), "i" (-EFAULT), "0" (err)			\
-		: "r14", "memory")
-
-/**
- * __put_user: - Write a simple value into user space, with less checking.
- * @x:   Value to copy to user space.
- * @ptr: Destination address, in user space.
- *
- * Context: User context only.  This function may sleep.
- *
- * This macro copies a single simple value from kernel space to user
- * space.  It supports simple types like char and int, but not larger
- * data types like structures or arrays.
- *
- * @ptr must have pointer-to-simple-variable type, and @x must be assignable
- * to the result of dereferencing @ptr.
- *
- * Caller must check the pointer with access_ok() before calling this
- * function.
- *
- * Returns zero on success, or -EFAULT on error.
- */
-#define __put_user(x,ptr) \
-	__put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
-
-
-#define __put_user_nocheck(x,ptr,size)					\
-({									\
-	long __pu_err;							\
-	might_sleep();							\
-	__put_user_size((x),(ptr),(size),__pu_err);			\
-	__pu_err;							\
-})
-
-
-#define __put_user_check(x,ptr,size)					\
-({									\
-	long __pu_err = -EFAULT;					\
-	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\
-	might_sleep();							\
-	if (access_ok(VERIFY_WRITE,__pu_addr,size))			\
-		__put_user_size((x),__pu_addr,(size),__pu_err);		\
-	__pu_err;							\
-})
-
-#if defined(__LITTLE_ENDIAN__)
-#define __put_user_u64(x, addr, err)					\
-        __asm__ __volatile__(						\
-                "       .fillinsn\n"					\
-                "1:     st %L1,@%2\n"					\
-                "       .fillinsn\n"					\
-                "2:     st %H1,@(4,%2)\n"				\
-                "       .fillinsn\n"					\
-                "3:\n"							\
-                ".section .fixup,\"ax\"\n"				\
-                "       .balign 4\n"					\
-                "4:     ldi %0,%3\n"					\
-                "       seth r14,#high(3b)\n"				\
-                "       or3 r14,r14,#low(3b)\n"				\
-                "       jmp r14\n"					\
-                ".previous\n"						\
-                ".section __ex_table,\"a\"\n"				\
-                "       .balign 4\n"					\
-                "       .long 1b,4b\n"					\
-                "       .long 2b,4b\n"					\
-                ".previous"						\
-                : "=&r" (err)						\
-                : "r" (x), "r" (addr), "i" (-EFAULT), "0" (err)		\
-                : "r14", "memory")
-
-#elif defined(__BIG_ENDIAN__)
-#define __put_user_u64(x, addr, err)					\
-	__asm__ __volatile__(						\
-		"	.fillinsn\n"					\
-		"1:	st %H1,@%2\n"					\
-		"	.fillinsn\n"					\
-		"2:	st %L1,@(4,%2)\n"				\
-		"	.fillinsn\n"					\
-		"3:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"	.balign 4\n"					\
-		"4:	ldi %0,%3\n"					\
-		"	seth r14,#high(3b)\n"				\
-		"	or3 r14,r14,#low(3b)\n"				\
-		"	jmp r14\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.balign 4\n"					\
-		"	.long 1b,4b\n"					\
-		"	.long 2b,4b\n"					\
-		".previous"						\
-		: "=&r" (err)						\
-		: "r" (x), "r" (addr), "i" (-EFAULT), "0" (err)		\
-		: "r14", "memory")
-#else
-#error no endian defined
-#endif
-
-extern void __put_user_bad(void);
-
-#define __put_user_size(x,ptr,size,retval)				\
-do {									\
-	retval = 0;							\
-	__chk_user_ptr(ptr);						\
-	switch (size) {							\
-	  case 1: __put_user_asm(x,ptr,retval,"b"); break;		\
-	  case 2: __put_user_asm(x,ptr,retval,"h"); break;		\
-	  case 4: __put_user_asm(x,ptr,retval,""); break;		\
-	  case 8: __put_user_u64((__typeof__(*ptr))(x),ptr,retval); break;\
-	  default: __put_user_bad();					\
-	}								\
-} while (0)
-
-struct __large_struct { unsigned long buf[100]; };
-#define __m(x) (*(struct __large_struct *)(x))
-
-/*
- * Tell gcc we read from memory instead of writing: this is because
- * we do not write to any memory gcc knows about, so there are no
- * aliasing issues.
- */
-#define __put_user_asm(x, addr, err, itype)				\
-	__asm__ __volatile__(						\
-		"	.fillinsn\n"					\
-		"1:	st"itype" %1,@%2\n"				\
-		"	.fillinsn\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"	.balign 4\n"					\
-		"3:	ldi %0,%3\n"					\
-		"	seth r14,#high(2b)\n"				\
-		"	or3 r14,r14,#low(2b)\n"				\
-		"	jmp r14\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.balign 4\n"					\
-		"	.long 1b,3b\n"					\
-		".previous"						\
-		: "=&r" (err)						\
-		: "r" (x), "r" (addr), "i" (-EFAULT), "0" (err)		\
-		: "r14", "memory")
-
-/*
- * Here we special-case 1, 2 and 4-byte copy_*_user invocations.  On a fault
- * we return the initial request size (1, 2 or 4), as copy_*_user should do.
- * If a store crosses a page boundary and gets a fault, the m32r will not write
- * anything, so this is accurate.
- */
-
-/*
- * Copy To/From Userspace
- */
-
-/* Generic arbitrary sized copy.  */
-/* Return the number of bytes NOT copied.  */
-#define __copy_user(to,from,size)					\
-do {									\
-	unsigned long __dst, __src, __c;				\
-	__asm__ __volatile__ (						\
-		"	mv	r14, %0\n"				\
-		"	or	r14, %1\n"				\
-		"	beq	%0, %1, 9f\n"				\
-		"	beqz	%2, 9f\n"				\
-		"	and3	r14, r14, #3\n"				\
-		"	bnez	r14, 2f\n"				\
-		"	and3	%2, %2, #3\n"				\
-		"	beqz	%3, 2f\n"				\
-		"	addi	%0, #-4		; word_copy \n"		\
-		"	.fillinsn\n"					\
-		"0:	ld	r14, @%1+\n"				\
-		"	addi	%3, #-1\n"				\
-		"	.fillinsn\n"					\
-		"1:	st	r14, @+%0\n"				\
-		"	bnez	%3, 0b\n"				\
-		"	beqz	%2, 9f\n"				\
-		"	addi	%0, #4\n"				\
-		"	.fillinsn\n"					\
-		"2:	ldb	r14, @%1	; byte_copy \n"		\
-		"	.fillinsn\n"					\
-		"3:	stb	r14, @%0\n"				\
-		"	addi	%1, #1\n"				\
-		"	addi	%2, #-1\n"				\
-		"	addi	%0, #1\n"				\
-		"	bnez	%2, 2b\n"				\
-		"	.fillinsn\n"					\
-		"9:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"	.balign 4\n"					\
-		"5:	addi	%3, #1\n"				\
-		"	addi	%1, #-4\n"				\
-		"	.fillinsn\n"					\
-		"6:	slli	%3, #2\n"				\
-		"	add	%2, %3\n"				\
-		"	addi	%0, #4\n"				\
-		"	.fillinsn\n"					\
-		"7:	seth	r14, #high(9b)\n"			\
-		"	or3	r14, r14, #low(9b)\n"			\
-		"	jmp	r14\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.balign 4\n"					\
-		"	.long 0b,6b\n"					\
-		"	.long 1b,5b\n"					\
-		"	.long 2b,9b\n"					\
-		"	.long 3b,9b\n"					\
-		".previous\n"						\
-		: "=&r" (__dst), "=&r" (__src), "=&r" (size),		\
-		  "=&r" (__c)						\
-		: "0" (to), "1" (from), "2" (size), "3" (size / 4)	\
-		: "r14", "memory");					\
-} while (0)
-
-#define __copy_user_zeroing(to,from,size)				\
-do {									\
-	unsigned long __dst, __src, __c;				\
-	__asm__ __volatile__ (						\
-		"	mv	r14, %0\n"				\
-		"	or	r14, %1\n"				\
-		"	beq	%0, %1, 9f\n"				\
-		"	beqz	%2, 9f\n"				\
-		"	and3	r14, r14, #3\n"				\
-		"	bnez	r14, 2f\n"				\
-		"	and3	%2, %2, #3\n"				\
-		"	beqz	%3, 2f\n"				\
-		"	addi	%0, #-4		; word_copy \n"		\
-		"	.fillinsn\n"					\
-		"0:	ld	r14, @%1+\n"				\
-		"	addi	%3, #-1\n"				\
-		"	.fillinsn\n"					\
-		"1:	st	r14, @+%0\n"				\
-		"	bnez	%3, 0b\n"				\
-		"	beqz	%2, 9f\n"				\
-		"	addi	%0, #4\n"				\
-		"	.fillinsn\n"					\
-		"2:	ldb	r14, @%1	; byte_copy \n"		\
-		"	.fillinsn\n"					\
-		"3:	stb	r14, @%0\n"				\
-		"	addi	%1, #1\n"				\
-		"	addi	%2, #-1\n"				\
-		"	addi	%0, #1\n"				\
-		"	bnez	%2, 2b\n"				\
-		"	.fillinsn\n"					\
-		"9:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"	.balign 4\n"					\
-		"5:	addi	%3, #1\n"				\
-		"	addi	%1, #-4\n"				\
-		"	.fillinsn\n"					\
-		"6:	slli	%3, #2\n"				\
-		"	add	%2, %3\n"				\
-		"	addi	%0, #4\n"				\
-		"	.fillinsn\n"					\
-		"7:	ldi	r14, #0		; store zero \n"	\
-		"	.fillinsn\n"					\
-		"8:	addi	%2, #-1\n"				\
-		"	stb	r14, @%0	; ACE? \n"		\
-		"	addi	%0, #1\n"				\
-		"	bnez	%2, 8b\n"				\
-		"	seth	r14, #high(9b)\n"			\
-		"	or3	r14, r14, #low(9b)\n"			\
-		"	jmp	r14\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.balign 4\n"					\
-		"	.long 0b,6b\n"					\
-		"	.long 1b,5b\n"					\
-		"	.long 2b,7b\n"					\
-		"	.long 3b,7b\n"					\
-		".previous\n"						\
-		: "=&r" (__dst), "=&r" (__src), "=&r" (size),		\
-		  "=&r" (__c)						\
-		: "0" (to), "1" (from), "2" (size), "3" (size / 4)	\
-		: "r14", "memory");					\
-} while (0)
-
-
-/* We let the __ versions of copy_from/to_user inline, because they're often
- * used in fast paths and have only a small space overhead.
- */
-static inline unsigned long __generic_copy_from_user_nocheck(void *to,
-	const void __user *from, unsigned long n)
-{
-	__copy_user_zeroing(to,from,n);
-	return n;
-}
-
-static inline unsigned long __generic_copy_to_user_nocheck(void __user *to,
-	const void *from, unsigned long n)
-{
-	__copy_user(to,from,n);
-	return n;
-}
-
-unsigned long __generic_copy_to_user(void __user *, const void *, unsigned long);
-unsigned long __generic_copy_from_user(void *, const void __user *, unsigned long);
-
-/**
- * __copy_to_user: - Copy a block of data into user space, with less checking.
- * @to:   Destination address, in user space.
- * @from: Source address, in kernel space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from kernel space to user space.  Caller must check
- * the specified block with access_ok() before calling this function.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- */
-#define __copy_to_user(to,from,n)			\
-	__generic_copy_to_user_nocheck((to),(from),(n))
-
-#define __copy_to_user_inatomic __copy_to_user
-#define __copy_from_user_inatomic __copy_from_user
-
-/**
- * copy_to_user: - Copy a block of data into user space.
- * @to:   Destination address, in user space.
- * @from: Source address, in kernel space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from kernel space to user space.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- */
-#define copy_to_user(to,from,n)				\
-({							\
-	might_sleep();					\
-	__generic_copy_to_user((to),(from),(n));	\
-})
-
-/**
- * __copy_from_user: - Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
- * @from: Source address, in user space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from user space to kernel space.  Caller must check
- * the specified block with access_ok() before calling this function.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- *
- * If some data could not be copied, this function will pad the copied
- * data to the requested size using zero bytes.
- */
-#define __copy_from_user(to,from,n)			\
-	__generic_copy_from_user_nocheck((to),(from),(n))
-
-/**
- * copy_from_user: - Copy a block of data from user space.
- * @to:   Destination address, in kernel space.
- * @from: Source address, in user space.
- * @n:    Number of bytes to copy.
- *
- * Context: User context only.  This function may sleep.
- *
- * Copy data from user space to kernel space.
- *
- * Returns number of bytes that could not be copied.
- * On success, this will be zero.
- *
- * If some data could not be copied, this function will pad the copied
- * data to the requested size using zero bytes.
- */
-#define copy_from_user(to,from,n)			\
-({							\
-	might_sleep();					\
-	__generic_copy_from_user((to),(from),(n));	\
-})
-
-long __must_check strncpy_from_user(char *dst, const char __user *src,
-				long count);
-long __must_check __strncpy_from_user(char *dst,
-				const char __user *src, long count);
-
-/**
- * __clear_user: - Zero a block of memory in user space, with less checking.
- * @to:   Destination address, in user space.
- * @n:    Number of bytes to zero.
- *
- * Zero a block of memory in user space.  Caller must check
- * the specified block with access_ok() before calling this function.
- *
- * Returns number of bytes that could not be cleared.
- * On success, this will be zero.
- */
-unsigned long __clear_user(void __user *mem, unsigned long len);
-
-/**
- * clear_user: - Zero a block of memory in user space.
- * @to:   Destination address, in user space.
- * @n:    Number of bytes to zero.
- *
- * Zero a block of memory in user space.  Caller must check
- * the specified block with access_ok() before calling this function.
- *
- * Returns number of bytes that could not be cleared.
- * On success, this will be zero.
- */
-unsigned long clear_user(void __user *mem, unsigned long len);
-
-/**
- * strlen_user: - Get the size of a string in user space.
- * @str: The string to measure.
- *
- * Context: User context only.  This function may sleep.
- *
- * Get the size of a NUL-terminated string in user space.
- *
- * Returns the size of the string INCLUDING the terminating NUL.
- * On exception, returns 0.
- *
- * If there is a limit on the length of a valid string, you may wish to
- * consider using strnlen_user() instead.
- */
-#define strlen_user(str) strnlen_user(str, ~0UL >> 1)
-long strnlen_user(const char __user *str, long n);
-
-#endif /* _ASM_M32R_UACCESS_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/ucontext.h linux-2.6.30-rc3/include/asm-m32r/ucontext.h
--- linux-2.6.30-rc2/include/asm-m32r/ucontext.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/ucontext.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,12 +0,0 @@
-#ifndef _ASM_M32R_UCONTEXT_H
-#define _ASM_M32R_UCONTEXT_H
-
-struct ucontext {
-	unsigned long	  uc_flags;
-	struct ucontext  *uc_link;
-	stack_t		  uc_stack;
-	struct sigcontext uc_mcontext;
-	sigset_t	  uc_sigmask;	/* mask last for extensibility */
-};
-
-#endif /* _ASM_M32R_UCONTEXT_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/unaligned.h linux-2.6.30-rc3/include/asm-m32r/unaligned.h
--- linux-2.6.30-rc2/include/asm-m32r/unaligned.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/unaligned.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,18 +0,0 @@
-#ifndef _ASM_M32R_UNALIGNED_H
-#define _ASM_M32R_UNALIGNED_H
-
-#if defined(__LITTLE_ENDIAN__)
-# include <linux/unaligned/le_memmove.h>
-# include <linux/unaligned/be_byteshift.h>
-# include <linux/unaligned/generic.h>
-# define get_unaligned	__get_unaligned_le
-# define put_unaligned	__put_unaligned_le
-#else
-# include <linux/unaligned/be_memmove.h>
-# include <linux/unaligned/le_byteshift.h>
-# include <linux/unaligned/generic.h>
-# define get_unaligned	__get_unaligned_be
-# define put_unaligned	__put_unaligned_be
-#endif
-
-#endif /* _ASM_M32R_UNALIGNED_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/unistd.h linux-2.6.30-rc3/include/asm-m32r/unistd.h
--- linux-2.6.30-rc2/include/asm-m32r/unistd.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/unistd.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,389 +0,0 @@
-#ifndef _ASM_M32R_UNISTD_H
-#define _ASM_M32R_UNISTD_H
-
-/*
- * This file contains the system call numbers.
- */
-
-#define __NR_restart_syscall	  0
-#define __NR_exit		  1
-#define __NR_fork		  2
-#define __NR_read		  3
-#define __NR_write		  4
-#define __NR_open		  5
-#define __NR_close		  6
-#define __NR_waitpid		  7
-#define __NR_creat		  8
-#define __NR_link		  9
-#define __NR_unlink		 10
-#define __NR_execve		 11
-#define __NR_chdir		 12
-#define __NR_time		 13
-#define __NR_mknod		 14
-#define __NR_chmod		 15
-/* 16 is unused */
-/* 17 is unused */
-/* 18 is unused */
-#define __NR_lseek		 19
-#define __NR_getpid		 20
-#define __NR_mount		 21
-#define __NR_umount		 22
-/* 23 is unused */
-/* 24 is unused */
-#define __NR_stime		 25
-#define __NR_ptrace		 26
-#define __NR_alarm		 27
-/* 28 is unused */
-#define __NR_pause		 29
-#define __NR_utime		 30
-/* 31 is unused */
-#define __NR_cachectl		 32 /* old #define __NR_gtty		 32*/
-#define __NR_access		 33
-/* 34 is unused */
-/* 35 is unused */
-#define __NR_sync		 36
-#define __NR_kill		 37
-#define __NR_rename		 38
-#define __NR_mkdir		 39
-#define __NR_rmdir		 40
-#define __NR_dup		 41
-#define __NR_pipe		 42
-#define __NR_times		 43
-/* 44 is unused */
-#define __NR_brk		 45
-/* 46 is unused */
-/* 47 is unused (getgid16) */
-/* 48 is unused */
-/* 49 is unused */
-/* 50 is unused */
-#define __NR_acct		 51
-#define __NR_umount2		 52
-/* 53 is unused */
-#define __NR_ioctl		 54
-/* 55 is unused (fcntl) */
-/* 56 is unused */
-#define __NR_setpgid		 57
-/* 58 is unused */
-/* 59 is unused */
-#define __NR_umask		 60
-#define __NR_chroot		 61
-#define __NR_ustat		 62
-#define __NR_dup2		 63
-#define __NR_getppid		 64
-#define __NR_getpgrp		 65
-#define __NR_setsid		 66
-/* 67 is unused */
-/* 68 is unused*/
-/* 69 is unused*/
-/* 70 is unused */
-/* 71 is unused */
-/* 72 is unused */
-/* 73 is unused */
-#define __NR_sethostname	 74
-#define __NR_setrlimit		 75
-/* 76 is unused (old getrlimit) */
-#define __NR_getrusage		 77
-#define __NR_gettimeofday	 78
-#define __NR_settimeofday	 79
-/* 80 is unused */
-/* 81 is unused */
-/* 82 is unused */
-#define __NR_symlink		 83
-/* 84 is unused */
-#define __NR_readlink		 85
-#define __NR_uselib		 86
-#define __NR_swapon		 87
-#define __NR_reboot		 88
-/* 89 is unused */
-/* 90 is unused */
-#define __NR_munmap		 91
-#define __NR_truncate		 92
-#define __NR_ftruncate		 93
-#define __NR_fchmod		 94
-/* 95 is unused */
-#define __NR_getpriority	 96
-#define __NR_setpriority	 97
-/* 98 is unused */
-#define __NR_statfs		 99
-#define __NR_fstatfs		100
-/* 101 is unused */
-#define __NR_socketcall		102
-#define __NR_syslog		103
-#define __NR_setitimer		104
-#define __NR_getitimer		105
-#define __NR_stat		106
-#define __NR_lstat		107
-#define __NR_fstat		108
-/* 109 is unused */
-/* 110 is unused */
-#define __NR_vhangup		111
-/* 112 is unused */
-/* 113 is unused */
-#define __NR_wait4		114
-#define __NR_swapoff		115
-#define __NR_sysinfo		116
-#define __NR_ipc		117
-#define __NR_fsync		118
-/* 119 is unused */
-#define __NR_clone		120
-#define __NR_setdomainname	121
-#define __NR_uname		122
-/* 123 is unused */
-#define __NR_adjtimex		124
-#define __NR_mprotect		125
-/* 126 is unused */
-/* 127 is unused */
-#define __NR_init_module	128
-#define __NR_delete_module	129
-/* 130 is unused */
-#define __NR_quotactl		131
-#define __NR_getpgid		132
-#define __NR_fchdir		133
-#define __NR_bdflush		134
-#define __NR_sysfs		135
-#define __NR_personality	136
-/* 137 is unused */
-/* 138 is unused */
-/* 139 is unused */
-#define __NR__llseek		140
-#define __NR_getdents		141
-#define __NR__newselect		142
-#define __NR_flock		143
-#define __NR_msync		144
-#define __NR_readv		145
-#define __NR_writev		146
-#define __NR_getsid		147
-#define __NR_fdatasync		148
-#define __NR__sysctl		149
-#define __NR_mlock		150
-#define __NR_munlock		151
-#define __NR_mlockall		152
-#define __NR_munlockall		153
-#define __NR_sched_setparam		154
-#define __NR_sched_getparam		155
-#define __NR_sched_setscheduler		156
-#define __NR_sched_getscheduler		157
-#define __NR_sched_yield		158
-#define __NR_sched_get_priority_max	159
-#define __NR_sched_get_priority_min	160
-#define __NR_sched_rr_get_interval	161
-#define __NR_nanosleep		162
-#define __NR_mremap		163
-/* 164 is unused */
-/* 165 is unused */
-#define __NR_tas		166
-/* 167 is unused */
-#define __NR_poll		168
-#define __NR_nfsservctl		169
-/* 170 is unused */
-/* 171 is unused */
-#define __NR_prctl              172
-#define __NR_rt_sigreturn	173
-#define __NR_rt_sigaction	174
-#define __NR_rt_sigprocmask	175
-#define __NR_rt_sigpending	176
-#define __NR_rt_sigtimedwait	177
-#define __NR_rt_sigqueueinfo	178
-#define __NR_rt_sigsuspend	179
-#define __NR_pread64		180
-#define __NR_pwrite64		181
-/* 182 is unused */
-#define __NR_getcwd		183
-#define __NR_capget		184
-#define __NR_capset		185
-#define __NR_sigaltstack	186
-#define __NR_sendfile		187
-/* 188 is unused */
-/* 189 is unused */
-#define __NR_vfork		190
-#define __NR_ugetrlimit		191	/* SuS compliant getrlimit */
-#define __NR_mmap2		192
-#define __NR_truncate64		193
-#define __NR_ftruncate64	194
-#define __NR_stat64		195
-#define __NR_lstat64		196
-#define __NR_fstat64		197
-#define __NR_lchown32		198
-#define __NR_getuid32		199
-#define __NR_getgid32		200
-#define __NR_geteuid32		201
-#define __NR_getegid32		202
-#define __NR_setreuid32		203
-#define __NR_setregid32		204
-#define __NR_getgroups32	205
-#define __NR_setgroups32	206
-#define __NR_fchown32		207
-#define __NR_setresuid32	208
-#define __NR_getresuid32	209
-#define __NR_setresgid32	210
-#define __NR_getresgid32	211
-#define __NR_chown32		212
-#define __NR_setuid32		213
-#define __NR_setgid32		214
-#define __NR_setfsuid32		215
-#define __NR_setfsgid32		216
-#define __NR_pivot_root		217
-#define __NR_mincore		218
-#define __NR_madvise		219
-#define __NR_getdents64		220
-#define __NR_fcntl64		221
-/* 222 is unused */
-/* 223 is unused */
-#define __NR_gettid		224
-#define __NR_readahead		225
-#define __NR_setxattr		226
-#define __NR_lsetxattr		227
-#define __NR_fsetxattr		228
-#define __NR_getxattr		229
-#define __NR_lgetxattr		230
-#define __NR_fgetxattr		231
-#define __NR_listxattr		232
-#define __NR_llistxattr		233
-#define __NR_flistxattr		234
-#define __NR_removexattr	235
-#define __NR_lremovexattr	236
-#define __NR_fremovexattr	237
-#define __NR_tkill		238
-#define __NR_sendfile64		239
-#define __NR_futex		240
-#define __NR_sched_setaffinity	241
-#define __NR_sched_getaffinity	242
-#define __NR_set_thread_area	243
-#define __NR_get_thread_area	244
-#define __NR_io_setup		245
-#define __NR_io_destroy		246
-#define __NR_io_getevents	247
-#define __NR_io_submit		248
-#define __NR_io_cancel		249
-#define __NR_fadvise64		250
-/* 251 is unused */
-#define __NR_exit_group		252
-#define __NR_lookup_dcookie	253
-#define __NR_epoll_create	254
-#define __NR_epoll_ctl		255
-#define __NR_epoll_wait		256
-#define __NR_remap_file_pages	257
-#define __NR_set_tid_address	258
-#define __NR_timer_create	259
-#define __NR_timer_settime	(__NR_timer_create+1)
-#define __NR_timer_gettime	(__NR_timer_create+2)
-#define __NR_timer_getoverrun	(__NR_timer_create+3)
-#define __NR_timer_delete	(__NR_timer_create+4)
-#define __NR_clock_settime	(__NR_timer_create+5)
-#define __NR_clock_gettime	(__NR_timer_create+6)
-#define __NR_clock_getres	(__NR_timer_create+7)
-#define __NR_clock_nanosleep	(__NR_timer_create+8)
-#define __NR_statfs64		268
-#define __NR_fstatfs64		269
-#define __NR_tgkill		270
-#define __NR_utimes		271
-#define __NR_fadvise64_64	272
-#define __NR_vserver		273
-#define __NR_mbind		274
-#define __NR_get_mempolicy	275
-#define __NR_set_mempolicy	276
-#define __NR_mq_open		277
-#define __NR_mq_unlink		(__NR_mq_open+1)
-#define __NR_mq_timedsend	(__NR_mq_open+2)
-#define __NR_mq_timedreceive	(__NR_mq_open+3)
-#define __NR_mq_notify		(__NR_mq_open+4)
-#define __NR_mq_getsetattr	(__NR_mq_open+5)
-#define __NR_kexec_load		283
-#define __NR_waitid		284
-/* 285 is unused */
-#define __NR_add_key		286
-#define __NR_request_key	287
-#define __NR_keyctl		288
-#define __NR_ioprio_set		289
-#define __NR_ioprio_get		290
-#define __NR_inotify_init	291
-#define __NR_inotify_add_watch	292
-#define __NR_inotify_rm_watch	293
-#define __NR_migrate_pages	294
-#define __NR_openat		295
-#define __NR_mkdirat		296
-#define __NR_mknodat		297
-#define __NR_fchownat		298
-#define __NR_futimesat		299
-#define __NR_fstatat64		300
-#define __NR_unlinkat		301
-#define __NR_renameat		302
-#define __NR_linkat		303
-#define __NR_symlinkat		304
-#define __NR_readlinkat		305
-#define __NR_fchmodat		306
-#define __NR_faccessat		307
-#define __NR_pselect6		308
-#define __NR_ppoll		309
-#define __NR_unshare		310
-#define __NR_set_robust_list	311
-#define __NR_get_robust_list	312
-#define __NR_splice		313
-#define __NR_sync_file_range	314
-#define __NR_tee		315
-#define __NR_vmsplice		316
-#define __NR_move_pages		317
-#define __NR_getcpu		318
-#define __NR_epoll_pwait	319
-#define __NR_utimensat		320
-#define __NR_signalfd		321
-/* #define __NR_timerfd		322 removed */
-#define __NR_eventfd		323
-#define __NR_fallocate		324
-
-#ifdef __KERNEL__
-
-#define NR_syscalls 325
-
-#define __ARCH_WANT_IPC_PARSE_VERSION
-#define __ARCH_WANT_STAT64
-#define __ARCH_WANT_SYS_ALARM
-#define __ARCH_WANT_SYS_GETHOSTNAME
-#define __ARCH_WANT_SYS_PAUSE
-#define __ARCH_WANT_SYS_TIME
-#define __ARCH_WANT_SYS_UTIME
-#define __ARCH_WANT_SYS_WAITPID
-#define __ARCH_WANT_SYS_SOCKETCALL
-#define __ARCH_WANT_SYS_FADVISE64
-#define __ARCH_WANT_SYS_GETPGRP
-#define __ARCH_WANT_SYS_LLSEEK
-#define __ARCH_WANT_SYS_OLD_GETRLIMIT /*will be unused*/
-#define __ARCH_WANT_SYS_OLDUMOUNT
-#define __ARCH_WANT_SYS_RT_SIGACTION
-
-#define __IGNORE_lchown
-#define __IGNORE_setuid
-#define __IGNORE_getuid
-#define __IGNORE_setgid
-#define __IGNORE_getgid
-#define __IGNORE_geteuid
-#define __IGNORE_getegid
-#define __IGNORE_fcntl
-#define __IGNORE_setreuid
-#define __IGNORE_setregid
-#define __IGNORE_getrlimit
-#define __IGNORE_getgroups
-#define __IGNORE_setgroups
-#define __IGNORE_select
-#define __IGNORE_mmap
-#define __IGNORE_fchown
-#define __IGNORE_setfsuid
-#define __IGNORE_setfsgid
-#define __IGNORE_setresuid
-#define __IGNORE_getresuid
-#define __IGNORE_setresgid
-#define __IGNORE_getresgid
-#define __IGNORE_chown
-
-/*
- * "Conditional" syscalls
- *
- * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
- * but it doesn't work on all toolchains, so we just do it by hand
- */
-#ifndef cond_syscall
-#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
-#endif
-
-#endif /* __KERNEL__ */
-#endif /* _ASM_M32R_UNISTD_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/user.h linux-2.6.30-rc3/include/asm-m32r/user.h
--- linux-2.6.30-rc2/include/asm-m32r/user.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/user.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-#ifndef _ASM_M32R_USER_H
-#define _ASM_M32R_USER_H
-
-#include <linux/types.h>
-#include <asm/ptrace.h>
-#include <asm/page.h>
-
-/*
- * Core file format: The core file is written in such a way that gdb
- * can understand it and provide useful information to the user (under
- * linux we use the `trad-core' bfd).
- *
- * The actual file contents are as follows:
- * UPAGE: 1 page consisting of a user struct that tells gdb
- *	what is present in the file.  Directly after this is a
- *	copy of the task_struct, which is currently not used by gdb,
- *	but it may come in handy at some point.  All of the registers
- *	are stored as part of the upage.  The upage should always be
- *	only one page.
- * DATA: The data area is stored.  We use current->end_text to
- *	current->brk to pick up all of the user variables, plus any memory
- *	that may have been sbrk'ed.  No attempt is made to determine if a
- *	page is demand-zero or if a page is totally unused, we just cover
- *	the entire range.  All of the addresses are rounded in such a way
- *	that an integral number of pages is written.
- * STACK: We need the stack information in order to get a meaningful
- *	backtrace.  We need to write the data from usp to
- *	current->start_stack, so we round each of these off in order to be
- *	able to write an integer number of pages.
- */
-
-struct user {
-	struct pt_regs	regs;			/* entire machine state */
-	size_t		u_tsize;		/* text size (pages) */
-	size_t		u_dsize;		/* data size (pages) */
-	size_t		u_ssize;		/* stack size (pages) */
-	unsigned long	start_code;		/* text starting address */
-	unsigned long	start_data;		/* data starting address */
-	unsigned long	start_stack;		/* stack starting address */
-	long int	signal;			/* signal causing core dump */
-	unsigned long	u_ar0;			/* help gdb find registers */
-	unsigned long	magic;			/* identifies a core file */
-	char		u_comm[32];		/* user command name */
-};
-
-#define NBPG			PAGE_SIZE
-#define UPAGES			1
-#define HOST_TEXT_START_ADDR	(u.start_code)
-#define HOST_DATA_START_ADDR	(u.start_data)
-#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
-
-#endif /* _ASM_M32R_USER_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/vga.h linux-2.6.30-rc3/include/asm-m32r/vga.h
--- linux-2.6.30-rc2/include/asm-m32r/vga.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/vga.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-#ifndef _ASM_M32R_VGA_H
-#define _ASM_M32R_VGA_H
-
-/*
- *	Access to VGA videoram
- *
- *	(c) 1998 Martin Mares <mj@ucw.cz>
- */
-
-/*
- *	On the PC, we can just recalculate addresses and then
- *	access the videoram directly without any black magic.
- */
-
-#define VGA_MAP_MEM(x,s) (unsigned long)phys_to_virt(x)
-
-#define vga_readb(x) (*(x))
-#define vga_writeb(x,y) (*(y) = (x))
-
-#endif /* _ASM_M32R_VGA_H */
diff -urN linux-2.6.30-rc2/include/asm-m32r/xor.h linux-2.6.30-rc3/include/asm-m32r/xor.h
--- linux-2.6.30-rc2/include/asm-m32r/xor.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/asm-m32r/xor.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef _ASM_M32R_XOR_H
-#define _ASM_M32R_XOR_H
-
-#include <asm-generic/xor.h>
-
-#endif  /* _ASM_M32R_XOR_H */
diff -urN linux-2.6.30-rc2/include/linux/bio.h linux-2.6.30-rc3/include/linux/bio.h
--- linux-2.6.30-rc2/include/linux/bio.h	2009-04-22 03:29:12.159931378 +0000
+++ linux-2.6.30-rc3/include/linux/bio.h	2009-04-22 03:29:18.226931435 +0000
@@ -504,6 +504,115 @@
 	return bio && bio->bi_io_vec != NULL;
 }
 
+/*
+ * BIO list managment for use by remapping drivers (e.g. DM or MD).
+ *
+ * A bio_list anchors a singly-linked list of bios chained through the bi_next
+ * member of the bio.  The bio_list also caches the last list member to allow
+ * fast access to the tail.
+ */
+struct bio_list {
+	struct bio *head;
+	struct bio *tail;
+};
+
+static inline int bio_list_empty(const struct bio_list *bl)
+{
+	return bl->head == NULL;
+}
+
+static inline void bio_list_init(struct bio_list *bl)
+{
+	bl->head = bl->tail = NULL;
+}
+
+#define bio_list_for_each(bio, bl) \
+	for (bio = (bl)->head; bio; bio = bio->bi_next)
+
+static inline unsigned bio_list_size(const struct bio_list *bl)
+{
+	unsigned sz = 0;
+	struct bio *bio;
+
+	bio_list_for_each(bio, bl)
+		sz++;
+
+	return sz;
+}
+
+static inline void bio_list_add(struct bio_list *bl, struct bio *bio)
+{
+	bio->bi_next = NULL;
+
+	if (bl->tail)
+		bl->tail->bi_next = bio;
+	else
+		bl->head = bio;
+
+	bl->tail = bio;
+}
+
+static inline void bio_list_add_head(struct bio_list *bl, struct bio *bio)
+{
+	bio->bi_next = bl->head;
+
+	bl->head = bio;
+
+	if (!bl->tail)
+		bl->tail = bio;
+}
+
+static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
+{
+	if (!bl2->head)
+		return;
+
+	if (bl->tail)
+		bl->tail->bi_next = bl2->head;
+	else
+		bl->head = bl2->head;
+
+	bl->tail = bl2->tail;
+}
+
+static inline void bio_list_merge_head(struct bio_list *bl,
+				       struct bio_list *bl2)
+{
+	if (!bl2->head)
+		return;
+
+	if (bl->head)
+		bl2->tail->bi_next = bl->head;
+	else
+		bl->tail = bl2->tail;
+
+	bl->head = bl2->head;
+}
+
+static inline struct bio *bio_list_pop(struct bio_list *bl)
+{
+	struct bio *bio = bl->head;
+
+	if (bio) {
+		bl->head = bl->head->bi_next;
+		if (!bl->head)
+			bl->tail = NULL;
+
+		bio->bi_next = NULL;
+	}
+
+	return bio;
+}
+
+static inline struct bio *bio_list_get(struct bio_list *bl)
+{
+	struct bio *bio = bl->head;
+
+	bl->head = bl->tail = NULL;
+
+	return bio;
+}
+
 #if defined(CONFIG_BLK_DEV_INTEGRITY)
 
 #define bip_vec_idx(bip, idx)	(&(bip->bip_vec[(idx)]))
diff -urN linux-2.6.30-rc2/include/linux/buffer_head.h linux-2.6.30-rc3/include/linux/buffer_head.h
--- linux-2.6.30-rc2/include/linux/buffer_head.h	2009-04-22 03:29:12.160931401 +0000
+++ linux-2.6.30-rc3/include/linux/buffer_head.h	2009-04-22 03:29:18.227931434 +0000
@@ -155,6 +155,7 @@
 			unsigned long b_state);
 void end_buffer_read_sync(struct buffer_head *bh, int uptodate);
 void end_buffer_write_sync(struct buffer_head *bh, int uptodate);
+void end_buffer_async_write(struct buffer_head *bh, int uptodate);
 
 /* Things to do with buffers at mapping->private_list */
 void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode);
@@ -197,6 +198,8 @@
 void block_invalidatepage(struct page *page, unsigned long offset);
 int block_write_full_page(struct page *page, get_block_t *get_block,
 				struct writeback_control *wbc);
+int block_write_full_page_endio(struct page *page, get_block_t *get_block,
+			struct writeback_control *wbc, bh_end_io_t *handler);
 int block_read_full_page(struct page*, get_block_t*);
 int block_is_partially_uptodate(struct page *page, read_descriptor_t *desc,
 				unsigned long from);
diff -urN linux-2.6.30-rc2/include/linux/clocksource.h linux-2.6.30-rc3/include/linux/clocksource.h
--- linux-2.6.30-rc2/include/linux/clocksource.h	2009-04-22 03:29:12.161931568 +0000
+++ linux-2.6.30-rc3/include/linux/clocksource.h	2009-04-22 03:29:18.228931419 +0000
@@ -143,7 +143,9 @@
  *			400-499: Perfect
  *				The ideal clocksource. A must-use where
  *				available.
- * @read:		returns a cycle value
+ * @read:		returns a cycle value, passes clocksource as argument
+ * @enable:		optional function to enable the clocksource
+ * @disable:		optional function to disable the clocksource
  * @mask:		bitmask for two's complement
  *			subtraction of non 64 bit counters
  * @mult:		cycle to nanosecond multiplier (adjusted by NTP)
@@ -162,7 +164,9 @@
 	char *name;
 	struct list_head list;
 	int rating;
-	cycle_t (*read)(void);
+	cycle_t (*read)(struct clocksource *cs);
+	int (*enable)(struct clocksource *cs);
+	void (*disable)(struct clocksource *cs);
 	cycle_t mask;
 	u32 mult;
 	u32 mult_orig;
@@ -271,7 +275,34 @@
  */
 static inline cycle_t clocksource_read(struct clocksource *cs)
 {
-	return cs->read();
+	return cs->read(cs);
+}
+
+/**
+ * clocksource_enable: - enable clocksource
+ * @cs:		pointer to clocksource
+ *
+ * Enables the specified clocksource. The clocksource callback
+ * function should start up the hardware and setup mult and field
+ * members of struct clocksource to reflect hardware capabilities.
+ */
+static inline int clocksource_enable(struct clocksource *cs)
+{
+	return cs->enable ? cs->enable(cs) : 0;
+}
+
+/**
+ * clocksource_disable: - disable clocksource
+ * @cs:		pointer to clocksource
+ *
+ * Disables the specified clocksource. The clocksource callback
+ * function should power down the now unused hardware block to
+ * save power.
+ */
+static inline void clocksource_disable(struct clocksource *cs)
+{
+	if (cs->disable)
+		cs->disable(cs);
 }
 
 /**
diff -urN linux-2.6.30-rc2/include/linux/device.h linux-2.6.30-rc3/include/linux/device.h
--- linux-2.6.30-rc2/include/linux/device.h	2009-04-22 03:29:12.164931426 +0000
+++ linux-2.6.30-rc3/include/linux/device.h	2009-04-22 03:29:18.231700193 +0000
@@ -551,6 +551,7 @@
 extern struct device *get_device(struct device *dev);
 extern void put_device(struct device *dev);
 
+extern void wait_for_device_probe(void);
 
 /* drivers/base/power/shutdown.c */
 extern void device_shutdown(void);
diff -urN linux-2.6.30-rc2/include/linux/dynamic_debug.h linux-2.6.30-rc3/include/linux/dynamic_debug.h
--- linux-2.6.30-rc2/include/linux/dynamic_debug.h	2009-04-22 03:29:12.166931409 +0000
+++ linux-2.6.30-rc3/include/linux/dynamic_debug.h	2009-04-22 03:29:18.233931491 +0000
@@ -70,7 +70,7 @@
 		DEBUG_HASH2, __LINE__, _DPRINTK_FLAGS_DEFAULT };	\
 	if (__dynamic_dbg_enabled(descriptor))				\
 			dev_printk(KERN_DEBUG, dev,			\
-					KBUILD_MODNAME ": " pr_fmt(fmt),\
+					KBUILD_MODNAME ": " fmt,	\
 					##__VA_ARGS__);			\
 	} while (0)
 
diff -urN linux-2.6.30-rc2/include/linux/fs.h linux-2.6.30-rc3/include/linux/fs.h
--- linux-2.6.30-rc2/include/linux/fs.h	2009-04-22 03:29:12.169931417 +0000
+++ linux-2.6.30-rc3/include/linux/fs.h	2009-04-22 03:29:18.236931406 +0000
@@ -87,6 +87,60 @@
  */
 #define FMODE_NOCMTIME		((__force fmode_t)2048)
 
+/*
+ * The below are the various read and write types that we support. Some of
+ * them include behavioral modifiers that send information down to the
+ * block layer and IO scheduler. Terminology:
+ *
+ *	The block layer uses device plugging to defer IO a little bit, in
+ *	the hope that we will see more IO very shortly. This increases
+ *	coalescing of adjacent IO and thus reduces the number of IOs we
+ *	have to send to the device. It also allows for better queuing,
+ *	if the IO isn't mergeable. If the caller is going to be waiting
+ *	for the IO, then he must ensure that the device is unplugged so
+ *	that the IO is dispatched to the driver.
+ *
+ *	All IO is handled async in Linux. This is fine for background
+ *	writes, but for reads or writes that someone waits for completion
+ *	on, we want to notify the block layer and IO scheduler so that they
+ *	know about it. That allows them to make better scheduling
+ *	decisions. So when the below references 'sync' and 'async', it
+ *	is referencing this priority hint.
+ *
+ * With that in mind, the available types are:
+ *
+ * READ			A normal read operation. Device will be plugged.
+ * READ_SYNC		A synchronous read. Device is not plugged, caller can
+ *			immediately wait on this read without caring about
+ *			unplugging.
+ * READA		Used for read-ahead operations. Lower priority, and the
+ *			 block layer could (in theory) choose to ignore this
+ *			request if it runs into resource problems.
+ * WRITE		A normal async write. Device will be plugged.
+ * SWRITE		Like WRITE, but a special case for ll_rw_block() that
+ *			tells it to lock the buffer first. Normally a buffer
+ *			must be locked before doing IO.
+ * WRITE_SYNC_PLUG	Synchronous write. Identical to WRITE, but passes down
+ *			the hint that someone will be waiting on this IO
+ *			shortly. The device must still be unplugged explicitly,
+ *			WRITE_SYNC_PLUG does not do this as we could be
+ *			submitting more writes before we actually wait on any
+ *			of them.
+ * WRITE_SYNC		Like WRITE_SYNC_PLUG, but also unplugs the device
+ *			immediately after submission. The write equivalent
+ *			of READ_SYNC.
+ * WRITE_ODIRECT	Special case write for O_DIRECT only.
+ * SWRITE_SYNC
+ * SWRITE_SYNC_PLUG	Like WRITE_SYNC/WRITE_SYNC_PLUG, but locks the buffer.
+ *			See SWRITE.
+ * WRITE_BARRIER	Like WRITE, but tells the block layer that all
+ *			previously submitted writes must be safely on storage
+ *			before this one is started. Also guarantees that when
+ *			this write is complete, it itself is also safely on
+ *			storage. Prevents reordering of writes on both sides
+ *			of this IO.
+ *
+ */
 #define RW_MASK		1
 #define RWA_MASK	2
 #define READ 0
@@ -102,6 +156,11 @@
 			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
 #define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
+
+/*
+ * These aren't really reads or writes, they pass down information about
+ * parts of device that are now unused by the file system.
+ */
 #define DISCARD_NOBARRIER (1 << BIO_RW_DISCARD)
 #define DISCARD_BARRIER ((1 << BIO_RW_DISCARD) | (1 << BIO_RW_BARRIER))
 
@@ -738,9 +797,6 @@
 	I_MUTEX_QUOTA
 };
 
-extern void inode_double_lock(struct inode *inode1, struct inode *inode2);
-extern void inode_double_unlock(struct inode *inode1, struct inode *inode2);
-
 /*
  * NOTE: in a 32bit arch with a preemptable kernel and
  * an UP compile the i_size_read/write must be atomic
@@ -2150,8 +2206,6 @@
 		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
-extern ssize_t generic_file_splice_write_nolock(struct pipe_inode_info *,
-		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
 		struct file *out, loff_t *, size_t len, unsigned int flags);
 extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
@@ -2245,9 +2299,8 @@
 
 extern int vfs_stat(char __user *, struct kstat *);
 extern int vfs_lstat(char __user *, struct kstat *);
-extern int vfs_stat_fd(int dfd, char __user *, struct kstat *);
-extern int vfs_lstat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
+extern int vfs_fstatat(int , char __user *, struct kstat *, int);
 
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
@@ -2395,7 +2448,7 @@
 int proc_nr_files(struct ctl_table *table, int write, struct file *filp,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
 
-int get_filesystem_list(char * buf);
+int __init get_filesystem_list(char *buf);
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */
diff -urN linux-2.6.30-rc2/include/linux/fsl_devices.h linux-2.6.30-rc3/include/linux/fsl_devices.h
--- linux-2.6.30-rc2/include/linux/fsl_devices.h	2009-04-22 03:29:12.170931419 +0000
+++ linux-2.6.30-rc3/include/linux/fsl_devices.h	2009-04-22 03:29:18.237931597 +0000
@@ -43,10 +43,6 @@
  *
  */
 
-/* Flags related to I2C device features */
-#define FSL_I2C_DEV_SEPARATE_DFSRR	0x00000001
-#define FSL_I2C_DEV_CLOCK_5200		0x00000002
-
 enum fsl_usb2_operating_modes {
 	FSL_USB2_MPH_HOST,
 	FSL_USB2_DR_HOST,
diff -urN linux-2.6.30-rc2/include/linux/init.h linux-2.6.30-rc3/include/linux/init.h
--- linux-2.6.30-rc2/include/linux/init.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/init.h	2009-04-22 03:29:18.243931549 +0000
@@ -247,6 +247,7 @@
 
 /* Relies on boot_command_line being set */
 void __init parse_early_param(void);
+void __init parse_early_options(char *cmdline);
 #endif /* __ASSEMBLY__ */
 
 /**
diff -urN linux-2.6.30-rc2/include/linux/ipmi.h linux-2.6.30-rc3/include/linux/ipmi.h
--- linux-2.6.30-rc2/include/linux/ipmi.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/ipmi.h	2009-04-22 03:29:18.244931506 +0000
@@ -198,6 +198,8 @@
 					      response.  When you send a
 					      response message, this will
 					      be returned. */
+#define IPMI_OEM_RECV_TYPE		5 /* The response for OEM Channels */
+
 /* Note that async events and received commands do not have a completion
    code as the first byte of the incoming data, unlike a response. */
 
diff -urN linux-2.6.30-rc2/include/linux/ipmi_msgdefs.h linux-2.6.30-rc3/include/linux/ipmi_msgdefs.h
--- linux-2.6.30-rc2/include/linux/ipmi_msgdefs.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/ipmi_msgdefs.h	2009-04-22 03:29:18.244931506 +0000
@@ -58,6 +58,12 @@
 #define IPMI_READ_EVENT_MSG_BUFFER_CMD	0x35
 #define IPMI_GET_CHANNEL_INFO_CMD	0x42
 
+/* Bit for BMC global enables. */
+#define IPMI_BMC_RCV_MSG_INTR     0x01
+#define IPMI_BMC_EVT_MSG_INTR     0x02
+#define IPMI_BMC_EVT_MSG_BUFF     0x04
+#define IPMI_BMC_SYS_LOG          0x08
+
 #define IPMI_NETFN_STORAGE_REQUEST		0x0a
 #define IPMI_NETFN_STORAGE_RESPONSE		0x0b
 #define IPMI_ADD_SEL_ENTRY_CMD		0x44
@@ -109,5 +115,7 @@
 #define IPMI_CHANNEL_MEDIUM_USB1	10
 #define IPMI_CHANNEL_MEDIUM_USB2	11
 #define IPMI_CHANNEL_MEDIUM_SYSINTF	12
+#define IPMI_CHANNEL_MEDIUM_OEM_MIN	0x60
+#define IPMI_CHANNEL_MEDIUM_OEM_MAX	0x7f
 
 #endif /* __LINUX_IPMI_MSGDEFS_H */
diff -urN linux-2.6.30-rc2/include/linux/kernel.h linux-2.6.30-rc3/include/linux/kernel.h
--- linux-2.6.30-rc2/include/linux/kernel.h	2009-04-22 03:29:12.178931432 +0000
+++ linux-2.6.30-rc3/include/linux/kernel.h	2009-04-22 03:29:18.246931511 +0000
@@ -377,6 +377,15 @@
 #define pr_cont(fmt, ...) \
 	printk(KERN_CONT fmt, ##__VA_ARGS__)
 
+/* pr_devel() should produce zero code unless DEBUG is defined */
+#ifdef DEBUG
+#define pr_devel(fmt, ...) \
+	printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
+#else
+#define pr_devel(fmt, ...) \
+	({ if (0) printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__); 0; })
+#endif
+
 /* If you are writing a driver, please use dev_dbg instead */
 #if defined(DEBUG)
 #define pr_debug(fmt, ...) \
diff -urN linux-2.6.30-rc2/include/linux/libata.h linux-2.6.30-rc3/include/linux/libata.h
--- linux-2.6.30-rc2/include/linux/libata.h	2009-04-22 03:29:12.180931427 +0000
+++ linux-2.6.30-rc3/include/linux/libata.h	2009-04-22 03:29:18.248931420 +0000
@@ -209,6 +209,7 @@
 
 	/* bits 24:31 of ap->flags are reserved for LLD specific flags */
 
+
 	/* struct ata_port pflags */
 	ATA_PFLAG_EH_PENDING	= (1 << 0), /* EH pending */
 	ATA_PFLAG_EH_IN_PROGRESS = (1 << 1), /* EH in progress */
@@ -225,6 +226,9 @@
 	ATA_PFLAG_PM_PENDING	= (1 << 18), /* PM operation pending */
 	ATA_PFLAG_INIT_GTM_VALID = (1 << 19), /* initial gtm data valid */
 
+	ATA_PFLAG_PIO32		= (1 << 20),  /* 32bit PIO */
+	ATA_PFLAG_PIO32CHANGE	= (1 << 21),  /* 32bit PIO can be turned on/off */
+
 	/* struct ata_queued_cmd flags */
 	ATA_QCFLAG_ACTIVE	= (1 << 0), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_DMAMAP	= (1 << 1), /* SG table is DMA mapped */
@@ -689,7 +693,10 @@
 	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
 	struct ata_port_operations *ops;
 	spinlock_t		*lock;
+	/* Flags owned by the EH context. Only EH should touch these once the
+	   port is active */
 	unsigned long		flags;	/* ATA_FLAG_xxx */
+	/* Flags that change dynamically, protected by ap->lock */
 	unsigned int		pflags; /* ATA_PFLAG_xxx */
 	unsigned int		print_id; /* user visible unique port ID */
 	unsigned int		port_no; /* 0 based port no. inside the host */
@@ -1595,6 +1602,7 @@
 extern void ata_sff_error_handler(struct ata_port *ap);
 extern void ata_sff_post_internal_cmd(struct ata_queued_cmd *qc);
 extern int ata_sff_port_start(struct ata_port *ap);
+extern int ata_sff_port_start32(struct ata_port *ap);
 extern void ata_sff_std_ports(struct ata_ioports *ioaddr);
 extern unsigned long ata_bmdma_mode_filter(struct ata_device *dev,
 					   unsigned long xfer_mask);
diff -urN linux-2.6.30-rc2/include/linux/memcontrol.h linux-2.6.30-rc3/include/linux/memcontrol.h
--- linux-2.6.30-rc2/include/linux/memcontrol.h	2009-04-22 03:29:12.182931367 +0000
+++ linux-2.6.30-rc3/include/linux/memcontrol.h	2009-04-22 03:29:18.249931432 +0000
@@ -75,7 +75,7 @@
 {
 	struct mem_cgroup *mem;
 	rcu_read_lock();
-	mem = mem_cgroup_from_task((mm)->owner);
+	mem = mem_cgroup_from_task(rcu_dereference((mm)->owner));
 	rcu_read_unlock();
 	return cgroup == mem;
 }
diff -urN linux-2.6.30-rc2/include/linux/percpu-defs.h linux-2.6.30-rc3/include/linux/percpu-defs.h
--- linux-2.6.30-rc2/include/linux/percpu-defs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/percpu-defs.h	2009-04-22 03:29:18.265931420 +0000
@@ -0,0 +1,84 @@
+#ifndef _LINUX_PERCPU_DEFS_H
+#define _LINUX_PERCPU_DEFS_H
+
+/*
+ * Determine the real variable name from the name visible in the
+ * kernel sources.
+ */
+#define per_cpu_var(var) per_cpu__##var
+
+/*
+ * Base implementations of per-CPU variable declarations and definitions, where
+ * the section in which the variable is to be placed is provided by the
+ * 'section' argument.  This may be used to affect the parameters governing the
+ * variable's storage.
+ *
+ * NOTE!  The sections for the DECLARE and for the DEFINE must match, lest
+ * linkage errors occur due the compiler generating the wrong code to access
+ * that section.
+ */
+#define DECLARE_PER_CPU_SECTION(type, name, section)			\
+	extern								\
+	__attribute__((__section__(PER_CPU_BASE_SECTION section)))	\
+	PER_CPU_ATTRIBUTES __typeof__(type) per_cpu__##name
+
+#define DEFINE_PER_CPU_SECTION(type, name, section)			\
+	__attribute__((__section__(PER_CPU_BASE_SECTION section)))	\
+	PER_CPU_ATTRIBUTES __typeof__(type) per_cpu__##name
+
+/*
+ * Variant on the per-CPU variable declaration/definition theme used for
+ * ordinary per-CPU variables.
+ */
+#define DECLARE_PER_CPU(type, name)					\
+	DECLARE_PER_CPU_SECTION(type, name, "")
+
+#define DEFINE_PER_CPU(type, name)					\
+	DEFINE_PER_CPU_SECTION(type, name, "")
+
+/*
+ * Declaration/definition used for per-CPU variables that must come first in
+ * the set of variables.
+ */
+#define DECLARE_PER_CPU_FIRST(type, name)				\
+	DECLARE_PER_CPU_SECTION(type, name, PER_CPU_FIRST_SECTION)
+
+#define DEFINE_PER_CPU_FIRST(type, name)				\
+	DEFINE_PER_CPU_SECTION(type, name, PER_CPU_FIRST_SECTION)
+
+/*
+ * Declaration/definition used for per-CPU variables that must be cacheline
+ * aligned under SMP conditions so that, whilst a particular instance of the
+ * data corresponds to a particular CPU, inefficiencies due to direct access by
+ * other CPUs are reduced by preventing the data from unnecessarily spanning
+ * cachelines.
+ *
+ * An example of this would be statistical data, where each CPU's set of data
+ * is updated by that CPU alone, but the data from across all CPUs is collated
+ * by a CPU processing a read from a proc file.
+ */
+#define DECLARE_PER_CPU_SHARED_ALIGNED(type, name)			\
+	DECLARE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \
+	____cacheline_aligned_in_smp
+
+#define DEFINE_PER_CPU_SHARED_ALIGNED(type, name)			\
+	DEFINE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \
+	____cacheline_aligned_in_smp
+
+/*
+ * Declaration/definition used for per-CPU variables that must be page aligned.
+ */
+#define DECLARE_PER_CPU_PAGE_ALIGNED(type, name)				\
+	DECLARE_PER_CPU_SECTION(type, name, ".page_aligned")
+
+#define DEFINE_PER_CPU_PAGE_ALIGNED(type, name)				\
+	DEFINE_PER_CPU_SECTION(type, name, ".page_aligned")
+
+/*
+ * Intermodule exports for per-CPU variables.
+ */
+#define EXPORT_PER_CPU_SYMBOL(var) EXPORT_SYMBOL(per_cpu__##var)
+#define EXPORT_PER_CPU_SYMBOL_GPL(var) EXPORT_SYMBOL_GPL(per_cpu__##var)
+
+
+#endif /* _LINUX_PERCPU_DEFS_H */
diff -urN linux-2.6.30-rc2/include/linux/percpu.h linux-2.6.30-rc3/include/linux/percpu.h
--- linux-2.6.30-rc2/include/linux/percpu.h	2009-04-22 03:29:12.197931301 +0000
+++ linux-2.6.30-rc3/include/linux/percpu.h	2009-04-22 03:29:18.265931420 +0000
@@ -9,50 +9,6 @@
 
 #include <asm/percpu.h>
 
-#ifndef PER_CPU_BASE_SECTION
-#ifdef CONFIG_SMP
-#define PER_CPU_BASE_SECTION ".data.percpu"
-#else
-#define PER_CPU_BASE_SECTION ".data"
-#endif
-#endif
-
-#ifdef CONFIG_SMP
-
-#ifdef MODULE
-#define PER_CPU_SHARED_ALIGNED_SECTION ""
-#else
-#define PER_CPU_SHARED_ALIGNED_SECTION ".shared_aligned"
-#endif
-#define PER_CPU_FIRST_SECTION ".first"
-
-#else
-
-#define PER_CPU_SHARED_ALIGNED_SECTION ""
-#define PER_CPU_FIRST_SECTION ""
-
-#endif
-
-#define DEFINE_PER_CPU_SECTION(type, name, section)			\
-	__attribute__((__section__(PER_CPU_BASE_SECTION section)))	\
-	PER_CPU_ATTRIBUTES __typeof__(type) per_cpu__##name
-
-#define DEFINE_PER_CPU(type, name)					\
-	DEFINE_PER_CPU_SECTION(type, name, "")
-
-#define DEFINE_PER_CPU_SHARED_ALIGNED(type, name)			\
-	DEFINE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \
-	____cacheline_aligned_in_smp
-
-#define DEFINE_PER_CPU_PAGE_ALIGNED(type, name)				\
-	DEFINE_PER_CPU_SECTION(type, name, ".page_aligned")
-
-#define DEFINE_PER_CPU_FIRST(type, name)				\
-	DEFINE_PER_CPU_SECTION(type, name, PER_CPU_FIRST_SECTION)
-
-#define EXPORT_PER_CPU_SYMBOL(var) EXPORT_SYMBOL(per_cpu__##var)
-#define EXPORT_PER_CPU_SYMBOL_GPL(var) EXPORT_SYMBOL_GPL(per_cpu__##var)
-
 /* enough to cover all DEFINE_PER_CPUs in modules */
 #ifdef CONFIG_MODULES
 #define PERCPU_MODULE_RESERVE		(8 << 10)
diff -urN linux-2.6.30-rc2/include/linux/phy.h linux-2.6.30-rc3/include/linux/phy.h
--- linux-2.6.30-rc2/include/linux/phy.h	2009-04-22 03:29:12.198906532 +0000
+++ linux-2.6.30-rc3/include/linux/phy.h	2009-04-22 03:29:18.266931422 +0000
@@ -388,6 +388,12 @@
 	/* Enables or disables interrupts */
 	int (*config_intr)(struct phy_device *phydev);
 
+	/*
+	 * Checks if the PHY generated an interrupt.
+	 * For multi-PHY devices with shared PHY interrupt pin
+	 */
+	int (*did_interrupt)(struct phy_device *phydev);
+
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);
 
diff -urN linux-2.6.30-rc2/include/linux/pipe_fs_i.h linux-2.6.30-rc3/include/linux/pipe_fs_i.h
--- linux-2.6.30-rc2/include/linux/pipe_fs_i.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/pipe_fs_i.h	2009-04-22 03:29:18.266931422 +0000
@@ -134,6 +134,11 @@
    memory allocation, whereas PIPE_BUF makes atomicity guarantees.  */
 #define PIPE_SIZE		PAGE_SIZE
 
+/* Pipe lock and unlock operations */
+void pipe_lock(struct pipe_inode_info *);
+void pipe_unlock(struct pipe_inode_info *);
+void pipe_double_lock(struct pipe_inode_info *, struct pipe_inode_info *);
+
 /* Drop the inode semaphore and wait for a pipe event, atomically */
 void pipe_wait(struct pipe_inode_info *pipe);
 
diff -urN linux-2.6.30-rc2/include/linux/platform_device.h linux-2.6.30-rc3/include/linux/platform_device.h
--- linux-2.6.30-rc2/include/linux/platform_device.h	2009-04-22 03:29:12.198906532 +0000
+++ linux-2.6.30-rc3/include/linux/platform_device.h	2009-04-22 03:29:18.266931422 +0000
@@ -77,4 +77,46 @@
 #define platform_get_drvdata(_dev)	dev_get_drvdata(&(_dev)->dev)
 #define platform_set_drvdata(_dev,data)	dev_set_drvdata(&(_dev)->dev, (data))
 
+/* early platform driver interface */
+struct early_platform_driver {
+	const char *class_str;
+	struct platform_driver *pdrv;
+	struct list_head list;
+	int requested_id;
+};
+
+#define EARLY_PLATFORM_ID_UNSET -2
+#define EARLY_PLATFORM_ID_ERROR -3
+
+extern int early_platform_driver_register(struct early_platform_driver *epdrv,
+					  char *buf);
+extern void early_platform_add_devices(struct platform_device **devs, int num);
+
+static inline int is_early_platform_device(struct platform_device *pdev)
+{
+	return !pdev->dev.driver;
+}
+
+extern void early_platform_driver_register_all(char *class_str);
+extern int early_platform_driver_probe(char *class_str,
+				       int nr_probe, int user_only);
+extern void early_platform_cleanup(void);
+
+
+#ifndef MODULE
+#define early_platform_init(class_string, platform_driver)		\
+static __initdata struct early_platform_driver early_driver = {		\
+	.class_str = class_string,					\
+	.pdrv = platform_driver,					\
+	.requested_id = EARLY_PLATFORM_ID_UNSET,			\
+};									\
+static int __init early_platform_driver_setup_func(char *buf)		\
+{									\
+	return early_platform_driver_register(&early_driver, buf);	\
+}									\
+early_param(class_string, early_platform_driver_setup_func)
+#else /* MODULE */
+#define early_platform_init(class_string, platform_driver)
+#endif /* MODULE */
+
 #endif /* _PLATFORM_DEVICE_H_ */
diff -urN linux-2.6.30-rc2/include/linux/rcutree.h linux-2.6.30-rc3/include/linux/rcutree.h
--- linux-2.6.30-rc2/include/linux/rcutree.h	2009-04-22 03:29:12.202931219 +0000
+++ linux-2.6.30-rc3/include/linux/rcutree.h	2009-04-22 03:29:18.270556393 +0000
@@ -161,9 +161,8 @@
 	unsigned long offline_fqs;	/* Kicked due to being offline. */
 	unsigned long resched_ipi;	/* Sent a resched IPI. */
 
-	/* 5) state to allow this CPU to force_quiescent_state on others */
+	/* 5) For future __rcu_pending statistics. */
 	long n_rcu_pending;		/* rcu_pending() calls since boot. */
-	long n_rcu_pending_force_qs;	/* when to force quiescent states. */
 
 	int cpu;
 };
diff -urN linux-2.6.30-rc2/include/linux/reiserfs_fs_sb.h linux-2.6.30-rc3/include/linux/reiserfs_fs_sb.h
--- linux-2.6.30-rc2/include/linux/reiserfs_fs_sb.h	2009-04-22 03:29:12.204931529 +0000
+++ linux-2.6.30-rc3/include/linux/reiserfs_fs_sb.h	2009-04-22 03:29:18.272556388 +0000
@@ -193,7 +193,7 @@
 	atomic_t j_wcount;	/* count of writers for current commit */
 	unsigned long j_bcount;	/* batch count. allows turning X transactions into 1 */
 	unsigned long j_first_unflushed_offset;	/* first unflushed transactions offset */
-	unsigned long j_last_flush_trans_id;	/* last fully flushed journal timestamp */
+	unsigned j_last_flush_trans_id;	/* last fully flushed journal timestamp */
 	struct buffer_head *j_header_bh;
 
 	time_t j_trans_start_time;	/* time this transaction started */
diff -urN linux-2.6.30-rc2/include/linux/seccomp.h linux-2.6.30-rc3/include/linux/seccomp.h
--- linux-2.6.30-rc2/include/linux/seccomp.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/seccomp.h	2009-04-22 03:29:18.274931481 +0000
@@ -21,6 +21,8 @@
 
 #else /* CONFIG_SECCOMP */
 
+#include <linux/errno.h>
+
 typedef struct { } seccomp_t;
 
 #define secure_computing(x) do { } while (0)
diff -urN linux-2.6.30-rc2/include/linux/slow-work.h linux-2.6.30-rc3/include/linux/slow-work.h
--- linux-2.6.30-rc2/include/linux/slow-work.h	2009-04-22 03:29:12.208931395 +0000
+++ linux-2.6.30-rc3/include/linux/slow-work.h	2009-04-22 03:29:18.276931456 +0000
@@ -67,7 +67,7 @@
 }
 
 /**
- * slow_work_init - Initialise a very slow work item
+ * vslow_work_init - Initialise a very slow work item
  * @work: The work item to initialise
  * @ops: The operations to use to handle the slow work item
  *
diff -urN linux-2.6.30-rc2/include/linux/spi/ads7846.h linux-2.6.30-rc3/include/linux/spi/ads7846.h
--- linux-2.6.30-rc2/include/linux/spi/ads7846.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/spi/ads7846.h	2009-04-22 03:29:18.277931446 +0000
@@ -51,5 +51,6 @@
 				 void **filter_data);
 	int	(*filter)	(void *filter_data, int data_idx, int *val);
 	void	(*filter_cleanup)(void *filter_data);
+	void	(*wait_for_sync)(void);
 };
 
diff -urN linux-2.6.30-rc2/include/linux/spi/spi.h linux-2.6.30-rc3/include/linux/spi/spi.h
--- linux-2.6.30-rc2/include/linux/spi/spi.h	2009-04-22 03:29:12.209931420 +0000
+++ linux-2.6.30-rc3/include/linux/spi/spi.h	2009-04-22 03:29:18.278820081 +0000
@@ -245,7 +245,12 @@
 	 */
 	u16			dma_alignment;
 
-	/* setup mode and clock, etc (spi driver may call many times) */
+	/* Setup mode and clock, etc (spi driver may call many times).
+	 *
+	 * IMPORTANT:  this may be called when transfers to another
+	 * device are active.  DO NOT UPDATE SHARED REGISTERS in ways
+	 * which could break those transfers.
+	 */
 	int			(*setup)(struct spi_device *spi);
 
 	/* bidirectional bulk transfers
diff -urN linux-2.6.30-rc2/include/linux/splice.h linux-2.6.30-rc3/include/linux/splice.h
--- linux-2.6.30-rc2/include/linux/splice.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/include/linux/splice.h	2009-04-22 03:29:18.278820081 +0000
@@ -36,6 +36,8 @@
 		void *data;		/* cookie */
 	} u;
 	loff_t pos;			/* file position */
+	size_t num_spliced;		/* number of bytes already spliced */
+	bool need_wakeup;		/* need to wake up writer */
 };
 
 struct partial_page {
@@ -66,6 +68,16 @@
 				splice_actor *);
 extern ssize_t __splice_from_pipe(struct pipe_inode_info *,
 				  struct splice_desc *, splice_actor *);
+extern int splice_from_pipe_feed(struct pipe_inode_info *, struct splice_desc *,
+				 splice_actor *);
+extern int splice_from_pipe_next(struct pipe_inode_info *,
+				 struct splice_desc *);
+extern void splice_from_pipe_begin(struct splice_desc *);
+extern void splice_from_pipe_end(struct pipe_inode_info *,
+				 struct splice_desc *);
+extern int pipe_to_file(struct pipe_inode_info *, struct pipe_buffer *,
+			struct splice_desc *);
+
 extern ssize_t splice_to_pipe(struct pipe_inode_info *,
 			      struct splice_pipe_desc *);
 extern ssize_t splice_direct_to_actor(struct file *, struct splice_desc *,
diff -urN linux-2.6.30-rc2/include/linux/suspend.h linux-2.6.30-rc3/include/linux/suspend.h
--- linux-2.6.30-rc2/include/linux/suspend.h	2009-04-22 03:29:12.211931400 +0000
+++ linux-2.6.30-rc3/include/linux/suspend.h	2009-04-22 03:29:18.280931448 +0000
@@ -58,10 +58,17 @@
  *	by @begin().
  *	@prepare() is called right after devices have been suspended (ie. the
  *	appropriate .suspend() method has been executed for each device) and
- *	before the nonboot CPUs are disabled (it is executed with IRQs enabled).
- *	This callback is optional.  It returns 0 on success or a negative
- *	error code otherwise, in which case the system cannot enter the desired
- *	sleep state (@enter() and @finish() will not be called in that case).
+ *	before device drivers' late suspend callbacks are executed.  It returns
+ *	0 on success or a negative error code otherwise, in which case the
+ *	system cannot enter the desired sleep state (@prepare_late(), @enter(),
+ *	@wake(), and @finish() will not be called in that case).
+ *
+ * @prepare_late: Finish preparing the platform for entering the system sleep
+ *	state indicated by @begin().
+ *	@prepare_late is called before disabling nonboot CPUs and after
+ *	device drivers' late suspend callbacks have been executed.  It returns
+ *	0 on success or a negative error code otherwise, in which case the
+ *	system cannot enter the desired sleep state (@enter() and @wake()).
  *
  * @enter: Enter the system sleep state indicated by @begin() or represented by
  *	the argument if @begin() is not implemented.
@@ -69,19 +76,26 @@
  *	error code otherwise, in which case the system cannot enter the desired
  *	sleep state.
  *
- * @finish: Called when the system has just left a sleep state, right after
- *	the nonboot CPUs have been enabled and before devices are resumed (it is
- *	executed with IRQs enabled).
+ * @wake: Called when the system has just left a sleep state, right after
+ *	the nonboot CPUs have been enabled and before device drivers' early
+ *	resume callbacks are executed.
+ *	This callback is optional, but should be implemented by the platforms
+ *	that implement @prepare_late().  If implemented, it is always called
+ *	after @enter(), even if @enter() fails.
+ *
+ * @finish: Finish wake-up of the platform.
+ *	@finish is called right prior to calling device drivers' regular suspend
+ *	callbacks.
  *	This callback is optional, but should be implemented by the platforms
  *	that implement @prepare().  If implemented, it is always called after
- *	@enter() (even if @enter() fails).
+ *	@enter() and @wake(), if implemented, even if any of them fails.
  *
  * @end: Called by the PM core right after resuming devices, to indicate to
  *	the platform that the system has returned to the working state or
  *	the transition to the sleep state has been aborted.
  *	This callback is optional, but should be implemented by the platforms
- *	that implement @begin(), but platforms implementing @begin() should
- *	also provide a @end() which cleans up transitions aborted before
+ *	that implement @begin().  Accordingly, platforms implementing @begin()
+ *	should also provide a @end() which cleans up transitions aborted before
  *	@enter().
  *
  * @recover: Recover the platform from a suspend failure.
@@ -93,7 +107,9 @@
 	int (*valid)(suspend_state_t state);
 	int (*begin)(suspend_state_t state);
 	int (*prepare)(void);
+	int (*prepare_late)(void);
 	int (*enter)(suspend_state_t state);
+	void (*wake)(void);
 	void (*finish)(void);
 	void (*end)(void);
 	void (*recover)(void);
diff -urN linux-2.6.30-rc2/include/linux/syscalls.h linux-2.6.30-rc3/include/linux/syscalls.h
--- linux-2.6.30-rc2/include/linux/syscalls.h	2009-04-22 03:29:12.212931387 +0000
+++ linux-2.6.30-rc3/include/linux/syscalls.h	2009-04-22 03:29:18.281931444 +0000
@@ -148,7 +148,7 @@
 	asm ("\t.globl " #alias "\n\t.set " #alias ", " #name "\n"	\
 	     "\t.globl ." #alias "\n\t.set ." #alias ", ." #name)
 #else
-#ifdef CONFIG_ALPHA
+#if defined(CONFIG_ALPHA) || defined(CONFIG_MIPS)
 #define SYSCALL_ALIAS(alias, name)					\
 	asm ( #alias " = " #name "\n\t.globl " #alias)
 #else
diff -urN linux-2.6.30-rc2/include/linux/usb.h linux-2.6.30-rc3/include/linux/usb.h
--- linux-2.6.30-rc2/include/linux/usb.h	2009-04-22 03:29:12.215931413 +0000
+++ linux-2.6.30-rc3/include/linux/usb.h	2009-04-22 03:29:18.283931434 +0000
@@ -1387,6 +1387,7 @@
 extern int usb_clear_halt(struct usb_device *dev, int pipe);
 extern int usb_reset_configuration(struct usb_device *dev);
 extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
+extern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);
 
 /* this request isn't really synchronous, but it belongs with the others */
 extern int usb_driver_set_configuration(struct usb_device *udev, int config);
@@ -1491,14 +1492,6 @@
 #define usb_pipecontrol(pipe)	(usb_pipetype((pipe)) == PIPE_CONTROL)
 #define usb_pipebulk(pipe)	(usb_pipetype((pipe)) == PIPE_BULK)
 
-/* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
-#define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
-#define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
-#define usb_settoggle(dev, ep, out, bit) \
-		((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | \
-		 ((bit) << (ep)))
-
-
 static inline unsigned int __create_pipe(struct usb_device *dev,
 		unsigned int endpoint)
 {
diff -urN linux-2.6.30-rc2/include/net/udp.h linux-2.6.30-rc3/include/net/udp.h
--- linux-2.6.30-rc2/include/net/udp.h	2009-04-22 03:29:12.231931396 +0000
+++ linux-2.6.30-rc3/include/net/udp.h	2009-03-23 23:12:14.000000000 +0000
@@ -124,8 +124,6 @@
 	sk_common_release(sk);
 }
 
-extern int	ipv4_rcv_saddr_equal(const struct sock *sk1,
-				    const struct sock *sk2);
 extern int	udp_lib_get_port(struct sock *sk, unsigned short snum,
 		int (*)(const struct sock*,const struct sock*));
 
diff -urN linux-2.6.30-rc2/include/sound/jack.h linux-2.6.30-rc3/include/sound/jack.h
--- linux-2.6.30-rc2/include/sound/jack.h	2009-04-22 03:29:12.237931403 +0000
+++ linux-2.6.30-rc3/include/sound/jack.h	2009-04-22 03:29:18.305931617 +0000
@@ -50,6 +50,8 @@
 	int type;
 	const char *id;
 	char name[100];
+	void *private_data;
+	void (*private_free)(struct snd_jack *);
 };
 
 #ifdef CONFIG_SND_JACK
diff -urN linux-2.6.30-rc2/include/sound/pcm.h linux-2.6.30-rc3/include/sound/pcm.h
--- linux-2.6.30-rc2/include/sound/pcm.h	2009-04-22 03:29:12.237931403 +0000
+++ linux-2.6.30-rc3/include/sound/pcm.h	2009-04-22 03:29:18.306931434 +0000
@@ -268,7 +268,8 @@
 	int overrange;
 	snd_pcm_uframes_t avail_max;
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
-	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/
+	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
+	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
 
 	/* -- HW params -- */
 	snd_pcm_access_t access;	/* access mode */
diff -urN linux-2.6.30-rc2/init/main.c linux-2.6.30-rc3/init/main.c
--- linux-2.6.30-rc2/init/main.c	2009-04-22 03:29:12.244931388 +0000
+++ linux-2.6.30-rc3/init/main.c	2009-04-22 03:29:18.312931442 +0000
@@ -492,6 +492,11 @@
 	return 0;
 }
 
+void __init parse_early_options(char *cmdline)
+{
+	parse_args("early options", cmdline, NULL, 0, do_early_param);
+}
+
 /* Arch code calls this early on, or if not, just before other parsing. */
 void __init parse_early_param(void)
 {
@@ -503,7 +508,7 @@
 
 	/* All fall through to do_early_param. */
 	strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);
-	parse_args("early options", tmp_cmdline, NULL, 0, do_early_param);
+	parse_early_options(tmp_cmdline);
 	done = 1;
 }
 
diff -urN linux-2.6.30-rc2/kernel/audit_tree.c linux-2.6.30-rc3/kernel/audit_tree.c
--- linux-2.6.30-rc2/kernel/audit_tree.c	2009-04-22 03:29:12.246931410 +0000
+++ linux-2.6.30-rc3/kernel/audit_tree.c	2009-04-22 03:29:18.316000707 +0000
@@ -734,9 +734,6 @@
 	dentry = dget(path.dentry);
 	path_put(&path);
 
-	if (dentry == tagged->mnt_root && dentry == mnt->mnt_root)
-		follow_up(&mnt, &dentry);
-
 	list_add_tail(&list, &tagged->mnt_list);
 
 	mutex_lock(&audit_filter_mutex);
diff -urN linux-2.6.30-rc2/kernel/power/main.c linux-2.6.30-rc3/kernel/power/main.c
--- linux-2.6.30-rc2/kernel/power/main.c	2009-04-22 03:29:12.260931407 +0000
+++ linux-2.6.30-rc3/kernel/power/main.c	2009-04-22 03:29:18.328931692 +0000
@@ -291,20 +291,26 @@
 
 	device_pm_lock();
 
+	if (suspend_ops->prepare) {
+		error = suspend_ops->prepare();
+		if (error)
+			goto Done;
+	}
+
 	error = device_power_down(PMSG_SUSPEND);
 	if (error) {
 		printk(KERN_ERR "PM: Some devices failed to power down\n");
-		goto Done;
+		goto Platfrom_finish;
 	}
 
-	if (suspend_ops->prepare) {
-		error = suspend_ops->prepare();
+	if (suspend_ops->prepare_late) {
+		error = suspend_ops->prepare_late();
 		if (error)
 			goto Power_up_devices;
 	}
 
 	if (suspend_test(TEST_PLATFORM))
-		goto Platfrom_finish;
+		goto Platform_wake;
 
 	error = disable_nonboot_cpus();
 	if (error || suspend_test(TEST_CPUS))
@@ -326,13 +332,17 @@
  Enable_cpus:
 	enable_nonboot_cpus();
 
- Platfrom_finish:
-	if (suspend_ops->finish)
-		suspend_ops->finish();
+ Platform_wake:
+	if (suspend_ops->wake)
+		suspend_ops->wake();
 
  Power_up_devices:
 	device_power_up(PMSG_RESUME);
 
+ Platfrom_finish:
+	if (suspend_ops->finish)
+		suspend_ops->finish();
+
  Done:
 	device_pm_unlock();
 
diff -urN linux-2.6.30-rc2/kernel/power/swap.c linux-2.6.30-rc3/kernel/power/swap.c
--- linux-2.6.30-rc2/kernel/power/swap.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/kernel/power/swap.c	2009-04-22 03:29:18.329931424 +0000
@@ -64,8 +64,6 @@
 	struct bio *bio;
 
 	bio = bio_alloc(__GFP_WAIT | __GFP_HIGH, 1);
-	if (!bio)
-		return -ENOMEM;
 	bio->bi_sector = page_off * (PAGE_SIZE >> 9);
 	bio->bi_bdev = resume_bdev;
 	bio->bi_end_io = end_swap_bio_read;
diff -urN linux-2.6.30-rc2/kernel/rcupdate.c linux-2.6.30-rc3/kernel/rcupdate.c
--- linux-2.6.30-rc2/kernel/rcupdate.c	2009-04-22 03:29:12.261931457 +0000
+++ linux-2.6.30-rc3/kernel/rcupdate.c	2009-04-22 03:29:18.330931408 +0000
@@ -58,6 +58,10 @@
 static struct completion rcu_barrier_completion;
 int rcu_scheduler_active __read_mostly;
 
+static atomic_t rcu_migrate_type_count = ATOMIC_INIT(0);
+static struct rcu_head rcu_migrate_head[3];
+static DECLARE_WAIT_QUEUE_HEAD(rcu_migrate_wq);
+
 /*
  * Awaken the corresponding synchronize_rcu() instance now that a
  * grace period has elapsed.
@@ -122,7 +126,10 @@
 	}
 }
 
-static inline void wait_migrated_callbacks(void);
+static inline void wait_migrated_callbacks(void)
+{
+	wait_event(rcu_migrate_wq, !atomic_read(&rcu_migrate_type_count));
+}
 
 /*
  * Orchestrate the specified type of RCU barrier, waiting for all
@@ -179,21 +186,12 @@
 }
 EXPORT_SYMBOL_GPL(rcu_barrier_sched);
 
-static atomic_t rcu_migrate_type_count = ATOMIC_INIT(0);
-static struct rcu_head rcu_migrate_head[3];
-static DECLARE_WAIT_QUEUE_HEAD(rcu_migrate_wq);
-
 static void rcu_migrate_callback(struct rcu_head *notused)
 {
 	if (atomic_dec_and_test(&rcu_migrate_type_count))
 		wake_up(&rcu_migrate_wq);
 }
 
-static inline void wait_migrated_callbacks(void)
-{
-	wait_event(rcu_migrate_wq, !atomic_read(&rcu_migrate_type_count));
-}
-
 static int __cpuinit rcu_barrier_cpu_hotplug(struct notifier_block *self,
 		unsigned long action, void *hcpu)
 {
diff -urN linux-2.6.30-rc2/kernel/rcutree.c linux-2.6.30-rc3/kernel/rcutree.c
--- linux-2.6.30-rc2/kernel/rcutree.c	2009-04-22 03:29:12.262931396 +0000
+++ linux-2.6.30-rc3/kernel/rcutree.c	2009-04-22 03:29:18.331931414 +0000
@@ -530,8 +530,6 @@
 	rdp->qs_pending = 1;
 	rdp->passed_quiesc = 0;
 	rdp->gpnum = rsp->gpnum;
-	rdp->n_rcu_pending_force_qs = rdp->n_rcu_pending +
-				      RCU_JIFFIES_TILL_FORCE_QS;
 }
 
 /*
@@ -578,8 +576,6 @@
 	rsp->gpnum++;
 	rsp->signaled = RCU_GP_INIT; /* Hold off force_quiescent_state. */
 	rsp->jiffies_force_qs = jiffies + RCU_JIFFIES_TILL_FORCE_QS;
-	rdp->n_rcu_pending_force_qs = rdp->n_rcu_pending +
-				      RCU_JIFFIES_TILL_FORCE_QS;
 	record_gp_stall_check_time(rsp);
 	dyntick_record_completed(rsp, rsp->completed - 1);
 	note_new_gpnum(rsp, rdp);
@@ -1055,7 +1051,6 @@
 {
 	unsigned long flags;
 	long lastcomp;
-	struct rcu_data *rdp = rsp->rda[smp_processor_id()];
 	struct rcu_node *rnp = rcu_get_root(rsp);
 	u8 signaled;
 
@@ -1066,16 +1061,13 @@
 		return;	/* Someone else is already on the job. */
 	}
 	if (relaxed &&
-	    (long)(rsp->jiffies_force_qs - jiffies) >= 0 &&
-	    (rdp->n_rcu_pending_force_qs - rdp->n_rcu_pending) >= 0)
+	    (long)(rsp->jiffies_force_qs - jiffies) >= 0)
 		goto unlock_ret; /* no emergency and done recently. */
 	rsp->n_force_qs++;
 	spin_lock(&rnp->lock);
 	lastcomp = rsp->completed;
 	signaled = rsp->signaled;
 	rsp->jiffies_force_qs = jiffies + RCU_JIFFIES_TILL_FORCE_QS;
-	rdp->n_rcu_pending_force_qs = rdp->n_rcu_pending +
-				      RCU_JIFFIES_TILL_FORCE_QS;
 	if (lastcomp == rsp->gpnum) {
 		rsp->n_force_qs_ngp++;
 		spin_unlock(&rnp->lock);
@@ -1144,8 +1136,7 @@
 	 * If an RCU GP has gone long enough, go check for dyntick
 	 * idle CPUs and, if needed, send resched IPIs.
 	 */
-	if ((long)(ACCESS_ONCE(rsp->jiffies_force_qs) - jiffies) < 0 ||
-	    (rdp->n_rcu_pending_force_qs - rdp->n_rcu_pending) < 0)
+	if ((long)(ACCESS_ONCE(rsp->jiffies_force_qs) - jiffies) < 0)
 		force_quiescent_state(rsp, 1);
 
 	/*
@@ -1230,8 +1221,7 @@
 	if (unlikely(++rdp->qlen > qhimark)) {
 		rdp->blimit = LONG_MAX;
 		force_quiescent_state(rsp, 0);
-	} else if ((long)(ACCESS_ONCE(rsp->jiffies_force_qs) - jiffies) < 0 ||
-		   (rdp->n_rcu_pending_force_qs - rdp->n_rcu_pending) < 0)
+	} else if ((long)(ACCESS_ONCE(rsp->jiffies_force_qs) - jiffies) < 0)
 		force_quiescent_state(rsp, 1);
 	local_irq_restore(flags);
 }
@@ -1290,8 +1280,7 @@
 
 	/* Has an RCU GP gone long enough to send resched IPIs &c? */
 	if (ACCESS_ONCE(rsp->completed) != ACCESS_ONCE(rsp->gpnum) &&
-	    ((long)(ACCESS_ONCE(rsp->jiffies_force_qs) - jiffies) < 0 ||
-	     (rdp->n_rcu_pending_force_qs - rdp->n_rcu_pending) < 0))
+	    ((long)(ACCESS_ONCE(rsp->jiffies_force_qs) - jiffies) < 0))
 		return 1;
 
 	/* nothing to do */
diff -urN linux-2.6.30-rc2/kernel/rcutree_trace.c linux-2.6.30-rc3/kernel/rcutree_trace.c
--- linux-2.6.30-rc2/kernel/rcutree_trace.c	2009-04-22 03:29:12.263931538 +0000
+++ linux-2.6.30-rc3/kernel/rcutree_trace.c	2009-04-22 03:29:18.331931414 +0000
@@ -49,14 +49,12 @@
 {
 	if (!rdp->beenonline)
 		return;
-	seq_printf(m, "%3d%cc=%ld g=%ld pq=%d pqc=%ld qp=%d rpfq=%ld rp=%x",
+	seq_printf(m, "%3d%cc=%ld g=%ld pq=%d pqc=%ld qp=%d",
 		   rdp->cpu,
 		   cpu_is_offline(rdp->cpu) ? '!' : ' ',
 		   rdp->completed, rdp->gpnum,
 		   rdp->passed_quiesc, rdp->passed_quiesc_completed,
-		   rdp->qs_pending,
-		   rdp->n_rcu_pending_force_qs - rdp->n_rcu_pending,
-		   (int)(rdp->n_rcu_pending & 0xffff));
+		   rdp->qs_pending);
 #ifdef CONFIG_NO_HZ
 	seq_printf(m, " dt=%d/%d dn=%d df=%lu",
 		   rdp->dynticks->dynticks,
@@ -102,14 +100,12 @@
 {
 	if (!rdp->beenonline)
 		return;
-	seq_printf(m, "%d,%s,%ld,%ld,%d,%ld,%d,%ld,%ld",
+	seq_printf(m, "%d,%s,%ld,%ld,%d,%ld,%d",
 		   rdp->cpu,
 		   cpu_is_offline(rdp->cpu) ? "\"Y\"" : "\"N\"",
 		   rdp->completed, rdp->gpnum,
 		   rdp->passed_quiesc, rdp->passed_quiesc_completed,
-		   rdp->qs_pending,
-		   rdp->n_rcu_pending_force_qs - rdp->n_rcu_pending,
-		   rdp->n_rcu_pending);
+		   rdp->qs_pending);
 #ifdef CONFIG_NO_HZ
 	seq_printf(m, ",%d,%d,%d,%lu",
 		   rdp->dynticks->dynticks,
@@ -123,7 +119,7 @@
 
 static int show_rcudata_csv(struct seq_file *m, void *unused)
 {
-	seq_puts(m, "\"CPU\",\"Online?\",\"c\",\"g\",\"pq\",\"pqc\",\"pq\",\"rpfq\",\"rp\",");
+	seq_puts(m, "\"CPU\",\"Online?\",\"c\",\"g\",\"pq\",\"pqc\",\"pq\",");
 #ifdef CONFIG_NO_HZ
 	seq_puts(m, "\"dt\",\"dt nesting\",\"dn\",\"df\",");
 #endif /* #ifdef CONFIG_NO_HZ */
diff -urN linux-2.6.30-rc2/kernel/resource.c linux-2.6.30-rc3/kernel/resource.c
--- linux-2.6.30-rc2/kernel/resource.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/kernel/resource.c	2009-04-22 03:29:18.332931410 +0000
@@ -533,43 +533,21 @@
 	res->end = end;
 	res->flags = IORESOURCE_BUSY;
 
-	for (;;) {
-		conflict = __request_resource(parent, res);
-		if (!conflict)
-			break;
-		if (conflict != parent) {
-			parent = conflict;
-			if (!(conflict->flags & IORESOURCE_BUSY))
-				continue;
-		}
+	conflict = __request_resource(parent, res);
+	if (!conflict)
+		return;
 
-		/* Uhhuh, that didn't work out.. */
-		kfree(res);
-		res = NULL;
-		break;
-	}
-
-	if (!res) {
-		/* failed, split and try again */
-
-		/* conflict covered whole area */
-		if (conflict->start <= start && conflict->end >= end)
-			return;
-
-		if (conflict->start > start)
-			__reserve_region_with_split(root, start, conflict->start-1, name);
-		if (!(conflict->flags & IORESOURCE_BUSY)) {
-			resource_size_t common_start, common_end;
-
-			common_start = max(conflict->start, start);
-			common_end = min(conflict->end, end);
-			if (common_start < common_end)
-				__reserve_region_with_split(root, common_start, common_end, name);
-		}
-		if (conflict->end < end)
-			__reserve_region_with_split(root, conflict->end+1, end, name);
-	}
+	/* failed, split and try again */
+	kfree(res);
 
+	/* conflict covered whole area */
+	if (conflict->start <= start && conflict->end >= end)
+		return;
+
+	if (conflict->start > start)
+		__reserve_region_with_split(root, start, conflict->start-1, name);
+	if (conflict->end < end)
+		__reserve_region_with_split(root, conflict->end+1, end, name);
 }
 
 void __init reserve_region_with_split(struct resource *root,
diff -urN linux-2.6.30-rc2/kernel/sched.c linux-2.6.30-rc3/kernel/sched.c
--- linux-2.6.30-rc2/kernel/sched.c	2009-04-22 03:29:12.266931196 +0000
+++ linux-2.6.30-rc3/kernel/sched.c	2009-04-22 03:29:18.335931232 +0000
@@ -4846,7 +4846,7 @@
 #endif
 }
 
-unsigned long get_parent_ip(unsigned long addr)
+notrace unsigned long get_parent_ip(unsigned long addr)
 {
 	if (in_lock_functions(addr)) {
 		addr = CALLER_ADDR2;
@@ -7367,8 +7367,12 @@
 		cpumask_or(groupmask, groupmask, sched_group_cpus(group));
 
 		cpulist_scnprintf(str, sizeof(str), sched_group_cpus(group));
-		printk(KERN_CONT " %s (__cpu_power = %d)", str,
-						group->__cpu_power);
+
+		printk(KERN_CONT " %s", str);
+		if (group->__cpu_power != SCHED_LOAD_SCALE) {
+			printk(KERN_CONT " (__cpu_power = %d)",
+				group->__cpu_power);
+		}
 
 		group = group->next;
 	} while (group != sd->groups);
diff -urN linux-2.6.30-rc2/kernel/softirq.c linux-2.6.30-rc3/kernel/softirq.c
--- linux-2.6.30-rc2/kernel/softirq.c	2009-04-22 03:29:12.269931420 +0000
+++ linux-2.6.30-rc3/kernel/softirq.c	2009-04-22 03:29:18.338667588 +0000
@@ -472,9 +472,9 @@
 		printk("Attempt to kill tasklet from interrupt\n");
 
 	while (test_and_set_bit(TASKLET_STATE_SCHED, &t->state)) {
-		do
+		do {
 			yield();
-		while (test_bit(TASKLET_STATE_SCHED, &t->state));
+		} while (test_bit(TASKLET_STATE_SCHED, &t->state));
 	}
 	tasklet_unlock_wait(t);
 	clear_bit(TASKLET_STATE_SCHED, &t->state);
diff -urN linux-2.6.30-rc2/kernel/time/clocksource.c linux-2.6.30-rc3/kernel/time/clocksource.c
--- linux-2.6.30-rc2/kernel/time/clocksource.c	2009-04-22 03:29:12.271931615 +0000
+++ linux-2.6.30-rc3/kernel/time/clocksource.c	2009-04-22 03:29:18.340931475 +0000
@@ -181,12 +181,12 @@
 
 	resumed = test_and_clear_bit(0, &watchdog_resumed);
 
-	wdnow = watchdog->read();
+	wdnow = watchdog->read(watchdog);
 	wd_nsec = cyc2ns(watchdog, (wdnow - watchdog_last) & watchdog->mask);
 	watchdog_last = wdnow;
 
 	list_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {
-		csnow = cs->read();
+		csnow = cs->read(cs);
 
 		if (unlikely(resumed)) {
 			cs->wd_last = csnow;
@@ -247,7 +247,7 @@
 
 		list_add(&cs->wd_list, &watchdog_list);
 		if (!started && watchdog) {
-			watchdog_last = watchdog->read();
+			watchdog_last = watchdog->read(watchdog);
 			watchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;
 			add_timer_on(&watchdog_timer,
 				     cpumask_first(cpu_online_mask));
@@ -268,7 +268,7 @@
 				cse->flags &= ~CLOCK_SOURCE_WATCHDOG;
 			/* Start if list is not empty */
 			if (!list_empty(&watchdog_list)) {
-				watchdog_last = watchdog->read();
+				watchdog_last = watchdog->read(watchdog);
 				watchdog_timer.expires =
 					jiffies + WATCHDOG_INTERVAL;
 				add_timer_on(&watchdog_timer,
diff -urN linux-2.6.30-rc2/kernel/time/jiffies.c linux-2.6.30-rc3/kernel/time/jiffies.c
--- linux-2.6.30-rc2/kernel/time/jiffies.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/kernel/time/jiffies.c	2009-04-22 03:29:18.341931447 +0000
@@ -50,7 +50,7 @@
  */
 #define JIFFIES_SHIFT	8
 
-static cycle_t jiffies_read(void)
+static cycle_t jiffies_read(struct clocksource *cs)
 {
 	return (cycle_t) jiffies;
 }
diff -urN linux-2.6.30-rc2/kernel/time/timekeeping.c linux-2.6.30-rc3/kernel/time/timekeeping.c
--- linux-2.6.30-rc2/kernel/time/timekeeping.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/kernel/time/timekeeping.c	2009-04-22 03:29:18.341931447 +0000
@@ -182,7 +182,7 @@
  */
 static void change_clocksource(void)
 {
-	struct clocksource *new;
+	struct clocksource *new, *old;
 
 	new = clocksource_get_next();
 
@@ -191,11 +191,16 @@
 
 	clocksource_forward_now();
 
-	new->raw_time = clock->raw_time;
+	if (clocksource_enable(new))
+		return;
 
+	new->raw_time = clock->raw_time;
+	old = clock;
 	clock = new;
+	clocksource_disable(old);
+
 	clock->cycle_last = 0;
-	clock->cycle_last = clocksource_read(new);
+	clock->cycle_last = clocksource_read(clock);
 	clock->error = 0;
 	clock->xtime_nsec = 0;
 	clocksource_calculate_interval(clock, NTP_INTERVAL_LENGTH);
@@ -292,6 +297,7 @@
 	ntp_init();
 
 	clock = clocksource_get_next();
+	clocksource_enable(clock);
 	clocksource_calculate_interval(clock, NTP_INTERVAL_LENGTH);
 	clock->cycle_last = clocksource_read(clock);
 
diff -urN linux-2.6.30-rc2/kernel/trace/trace_branch.c linux-2.6.30-rc3/kernel/trace/trace_branch.c
--- linux-2.6.30-rc2/kernel/trace/trace_branch.c	2009-04-22 03:29:12.280931439 +0000
+++ linux-2.6.30-rc3/kernel/trace/trace_branch.c	2009-04-22 03:29:18.349931461 +0000
@@ -155,6 +155,13 @@
 	return TRACE_TYPE_HANDLED;
 }
 
+static void branch_print_header(struct seq_file *s)
+{
+	seq_puts(s, "#           TASK-PID    CPU#    TIMESTAMP  CORRECT"
+		"  FUNC:FILE:LINE\n");
+	seq_puts(s, "#              | |       |          |         |   "
+		"    |\n");
+}
 
 static struct trace_event trace_branch_event = {
 	.type		= TRACE_BRANCH,
@@ -169,6 +176,7 @@
 #ifdef CONFIG_FTRACE_SELFTEST
 	.selftest	= trace_selftest_startup_branch,
 #endif /* CONFIG_FTRACE_SELFTEST */
+	.print_header	= branch_print_header,
 };
 
 __init static int init_branch_tracer(void)
diff -urN linux-2.6.30-rc2/kernel/trace/trace_power.c linux-2.6.30-rc3/kernel/trace/trace_power.c
--- linux-2.6.30-rc2/kernel/trace/trace_power.c	2009-04-22 03:29:12.284931413 +0000
+++ linux-2.6.30-rc3/kernel/trace/trace_power.c	2009-04-22 03:29:18.353931507 +0000
@@ -186,6 +186,12 @@
 	return TRACE_TYPE_UNHANDLED;
 }
 
+static void power_print_header(struct seq_file *s)
+{
+	seq_puts(s, "#   TIMESTAMP      STATE  EVENT\n");
+	seq_puts(s, "#       |            |      |\n");
+}
+
 static struct tracer power_tracer __read_mostly =
 {
 	.name		= "power",
@@ -194,6 +200,7 @@
 	.stop		= stop_power_trace,
 	.reset		= power_trace_reset,
 	.print_line	= power_print_line,
+	.print_header	= power_print_header,
 };
 
 static int init_power_trace(void)
diff -urN linux-2.6.30-rc2/lib/kobject.c linux-2.6.30-rc3/lib/kobject.c
--- linux-2.6.30-rc2/lib/kobject.c	2009-04-22 03:29:12.290931396 +0000
+++ linux-2.6.30-rc3/lib/kobject.c	2009-04-22 03:29:18.360931500 +0000
@@ -218,6 +218,9 @@
 	const char *old_name = kobj->name;
 	char *s;
 
+	if (kobj->name && !fmt)
+		return 0;
+
 	kobj->name = kvasprintf(GFP_KERNEL, fmt, vargs);
 	if (!kobj->name)
 		return -ENOMEM;
diff -urN linux-2.6.30-rc2/lib/kobject_uevent.c linux-2.6.30-rc3/lib/kobject_uevent.c
--- linux-2.6.30-rc2/lib/kobject_uevent.c	2009-04-22 03:29:12.290931396 +0000
+++ linux-2.6.30-rc3/lib/kobject_uevent.c	2009-04-22 03:29:18.360931500 +0000
@@ -258,7 +258,7 @@
 			goto exit;
 
 		retval = call_usermodehelper(argv[0], argv,
-					     env->envp, UMH_NO_WAIT);
+					     env->envp, UMH_WAIT_EXEC);
 	}
 
 exit:
@@ -328,7 +328,7 @@
 		       "kobject_uevent: unable to create netlink socket!\n");
 		return -ENODEV;
 	}
-
+	netlink_set_nonroot(NETLINK_KOBJECT_UEVENT, NL_NONROOT_RECV);
 	return 0;
 }
 
diff -urN linux-2.6.30-rc2/mm/filemap.c linux-2.6.30-rc3/mm/filemap.c
--- linux-2.6.30-rc2/mm/filemap.c	2009-04-22 03:29:12.294931424 +0000
+++ linux-2.6.30-rc3/mm/filemap.c	2009-04-22 03:29:18.364931423 +0000
@@ -441,6 +441,7 @@
 	}
 	return err;
 }
+EXPORT_SYMBOL(filemap_write_and_wait_range);
 
 /**
  * add_to_page_cache_locked - add a locked page to the pagecache
diff -urN linux-2.6.30-rc2/mm/mmap.c linux-2.6.30-rc3/mm/mmap.c
--- linux-2.6.30-rc2/mm/mmap.c	2009-04-22 03:29:12.297931205 +0000
+++ linux-2.6.30-rc3/mm/mmap.c	2009-04-22 03:29:18.367931562 +0000
@@ -1575,7 +1575,7 @@
 	 * Overcommit..  This must be the final test, as it will
 	 * update security statistics.
 	 */
-	if (security_vm_enough_memory(grow))
+	if (security_vm_enough_memory_mm(mm, grow))
 		return -ENOMEM;
 
 	/* Ok, everything looks good - let it rip */
diff -urN linux-2.6.30-rc2/mm/vmscan.c linux-2.6.30-rc3/mm/vmscan.c
--- linux-2.6.30-rc2/mm/vmscan.c	2009-04-22 03:29:12.305931390 +0000
+++ linux-2.6.30-rc3/mm/vmscan.c	2009-04-22 03:29:18.375931447 +0000
@@ -63,6 +63,9 @@
 	/* Can mapped pages be reclaimed? */
 	int may_unmap;
 
+	/* Can pages be swapped as part of reclaim? */
+	int may_swap;
+
 	/* This context's SWAP_CLUSTER_MAX. If freeing memory for
 	 * suspend, we effectively ignore SWAP_CLUSTER_MAX.
 	 * In this context, it doesn't matter that we scan the
@@ -1380,7 +1383,7 @@
 	struct zone_reclaim_stat *reclaim_stat = get_reclaim_stat(zone, sc);
 
 	/* If we have no swap space, do not bother scanning anon pages. */
-	if (nr_swap_pages <= 0) {
+	if (!sc->may_swap || (nr_swap_pages <= 0)) {
 		percent[0] = 0;
 		percent[1] = 100;
 		return;
@@ -1697,6 +1700,7 @@
 		.may_writepage = !laptop_mode,
 		.swap_cluster_max = SWAP_CLUSTER_MAX,
 		.may_unmap = 1,
+		.may_swap = 1,
 		.swappiness = vm_swappiness,
 		.order = order,
 		.mem_cgroup = NULL,
@@ -1717,6 +1721,7 @@
 	struct scan_control sc = {
 		.may_writepage = !laptop_mode,
 		.may_unmap = 1,
+		.may_swap = !noswap,
 		.swap_cluster_max = SWAP_CLUSTER_MAX,
 		.swappiness = swappiness,
 		.order = 0,
@@ -1726,9 +1731,6 @@
 	};
 	struct zonelist *zonelist;
 
-	if (noswap)
-		sc.may_unmap = 0;
-
 	sc.gfp_mask = (gfp_mask & GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK);
 	zonelist = NODE_DATA(numa_node_id())->node_zonelists;
@@ -1767,6 +1769,7 @@
 	struct scan_control sc = {
 		.gfp_mask = GFP_KERNEL,
 		.may_unmap = 1,
+		.may_swap = 1,
 		.swap_cluster_max = SWAP_CLUSTER_MAX,
 		.swappiness = vm_swappiness,
 		.order = order,
@@ -2088,13 +2091,13 @@
 				nr_reclaimed += shrink_list(l, nr_to_scan, zone,
 								sc, prio);
 				if (nr_reclaimed >= nr_pages) {
-					sc->nr_reclaimed = nr_reclaimed;
+					sc->nr_reclaimed += nr_reclaimed;
 					return;
 				}
 			}
 		}
 	}
-	sc->nr_reclaimed = nr_reclaimed;
+	sc->nr_reclaimed += nr_reclaimed;
 }
 
 /*
@@ -2115,6 +2118,7 @@
 		.may_unmap = 0,
 		.may_writepage = 1,
 		.isolate_pages = isolate_pages_global,
+		.nr_reclaimed = 0,
 	};
 
 	current->reclaim_state = &reclaim_state;
@@ -2297,6 +2301,7 @@
 	struct scan_control sc = {
 		.may_writepage = !!(zone_reclaim_mode & RECLAIM_WRITE),
 		.may_unmap = !!(zone_reclaim_mode & RECLAIM_SWAP),
+		.may_swap = 1,
 		.swap_cluster_max = max_t(unsigned long, nr_pages,
 					SWAP_CLUSTER_MAX),
 		.gfp_mask = gfp_mask,
diff -urN linux-2.6.30-rc2/net/802/tr.c linux-2.6.30-rc3/net/802/tr.c
--- linux-2.6.30-rc2/net/802/tr.c	2009-04-22 03:29:12.306931259 +0000
+++ linux-2.6.30-rc3/net/802/tr.c	2009-04-22 03:29:18.376853565 +0000
@@ -561,6 +561,9 @@
 				}
 				seq_putc(seq, '\n');
 			}
+
+		if (dev)
+			dev_put(dev);
 		}
 	return 0;
 }
diff -urN linux-2.6.30-rc2/net/8021q/vlan_core.c linux-2.6.30-rc3/net/8021q/vlan_core.c
--- linux-2.6.30-rc2/net/8021q/vlan_core.c	2009-04-22 03:29:12.306931259 +0000
+++ linux-2.6.30-rc3/net/8021q/vlan_core.c	2009-04-22 03:29:18.376853565 +0000
@@ -121,8 +121,10 @@
 	if (!skb)
 		return NET_RX_DROP;
 
-	if (netpoll_rx_on(skb))
+	if (netpoll_rx_on(skb)) {
+		skb->protocol = eth_type_trans(skb, skb->dev);
 		return vlan_hwaccel_receive_skb(skb, grp, vlan_tci);
+	}
 
 	return napi_frags_finish(napi, skb,
 				 vlan_gro_common(napi, grp, vlan_tci, skb));
diff -urN linux-2.6.30-rc2/net/core/dev.c linux-2.6.30-rc3/net/core/dev.c
--- linux-2.6.30-rc2/net/core/dev.c	2009-04-22 03:29:12.317931389 +0000
+++ linux-2.6.30-rc3/net/core/dev.c	2009-04-22 03:29:18.387556041 +0000
@@ -1430,7 +1430,7 @@
 {
 	if (test_and_clear_bit(__LINK_STATE_PRESENT, &dev->state) &&
 	    netif_running(dev)) {
-		netif_stop_queue(dev);
+		netif_tx_stop_all_queues(dev);
 	}
 }
 EXPORT_SYMBOL(netif_device_detach);
@@ -1445,7 +1445,7 @@
 {
 	if (!test_and_set_bit(__LINK_STATE_PRESENT, &dev->state) &&
 	    netif_running(dev)) {
-		netif_wake_queue(dev);
+		netif_tx_wake_all_queues(dev);
 		__netdev_watchdog_up(dev);
 	}
 }
@@ -2328,8 +2328,10 @@
 	struct list_head *head = &ptype_base[ntohs(type) & PTYPE_HASH_MASK];
 	int err = -ENOENT;
 
-	if (NAPI_GRO_CB(skb)->count == 1)
+	if (NAPI_GRO_CB(skb)->count == 1) {
+		skb_shinfo(skb)->gso_size = 0;
 		goto out;
+	}
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(ptype, head, list) {
@@ -2348,7 +2350,6 @@
 	}
 
 out:
-	skb_shinfo(skb)->gso_size = 0;
 	return netif_receive_skb(skb);
 }
 
diff -urN linux-2.6.30-rc2/net/ipv4/tcp_input.c linux-2.6.30-rc3/net/ipv4/tcp_input.c
--- linux-2.6.30-rc2/net/ipv4/tcp_input.c	2009-04-22 03:29:12.339931413 +0000
+++ linux-2.6.30-rc3/net/ipv4/tcp_input.c	2009-04-22 03:29:18.409931978 +0000
@@ -928,6 +928,8 @@
 	tcp_set_rto(sk);
 	if (inet_csk(sk)->icsk_rto < TCP_TIMEOUT_INIT && !tp->rx_opt.saw_tstamp)
 		goto reset;
+
+cwnd:
 	tp->snd_cwnd = tcp_init_cwnd(tp, dst);
 	tp->snd_cwnd_stamp = tcp_time_stamp;
 	return;
@@ -942,6 +944,7 @@
 		tp->mdev = tp->mdev_max = tp->rttvar = TCP_TIMEOUT_INIT;
 		inet_csk(sk)->icsk_rto = TCP_TIMEOUT_INIT;
 	}
+	goto cwnd;
 }
 
 static void tcp_update_reordering(struct sock *sk, const int metric,
diff -urN linux-2.6.30-rc2/net/ipv4/udp.c linux-2.6.30-rc3/net/ipv4/udp.c
--- linux-2.6.30-rc2/net/ipv4/udp.c	2009-04-22 03:29:12.342931373 +0000
+++ linux-2.6.30-rc3/net/ipv4/udp.c	2009-04-22 03:29:18.412931616 +0000
@@ -222,7 +222,7 @@
 	return error;
 }
 
-int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2)
+static int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2)
 {
 	struct inet_sock *inet1 = inet_sk(sk1), *inet2 = inet_sk(sk2);
 
@@ -1823,7 +1823,6 @@
 EXPORT_SYMBOL(udp_lib_setsockopt);
 EXPORT_SYMBOL(udp_poll);
 EXPORT_SYMBOL(udp_lib_get_port);
-EXPORT_SYMBOL(ipv4_rcv_saddr_equal);
 
 #ifdef CONFIG_PROC_FS
 EXPORT_SYMBOL(udp_proc_register);
diff -urN linux-2.6.30-rc2/net/ipv6/ipv6_sockglue.c linux-2.6.30-rc3/net/ipv6/ipv6_sockglue.c
--- linux-2.6.30-rc2/net/ipv6/ipv6_sockglue.c	2009-04-22 03:29:12.344931649 +0000
+++ linux-2.6.30-rc3/net/ipv6/ipv6_sockglue.c	2009-04-22 03:29:18.414931477 +0000
@@ -380,10 +380,6 @@
 			default:
 				goto sticky_done;
 			}
-
-			if ((rthdr->hdrlen & 1) ||
-			    (rthdr->hdrlen >> 1) != rthdr->segments_left)
-				goto sticky_done;
 		}
 
 		retv = 0;
diff -urN linux-2.6.30-rc2/net/ipv6/udp.c linux-2.6.30-rc3/net/ipv6/udp.c
--- linux-2.6.30-rc2/net/ipv6/udp.c	2009-04-22 03:29:12.347931622 +0000
+++ linux-2.6.30-rc3/net/ipv6/udp.c	2009-04-22 03:29:18.417931589 +0000
@@ -53,6 +53,8 @@
 {
 	const struct in6_addr *sk_rcv_saddr6 = &inet6_sk(sk)->rcv_saddr;
 	const struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);
+	__be32 sk_rcv_saddr = inet_sk(sk)->rcv_saddr;
+	__be32 sk2_rcv_saddr = inet_rcv_saddr(sk2);
 	int sk_ipv6only = ipv6_only_sock(sk);
 	int sk2_ipv6only = inet_v6_ipv6only(sk2);
 	int addr_type = ipv6_addr_type(sk_rcv_saddr6);
@@ -60,7 +62,9 @@
 
 	/* if both are mapped, treat as IPv4 */
 	if (addr_type == IPV6_ADDR_MAPPED && addr_type2 == IPV6_ADDR_MAPPED)
-		return ipv4_rcv_saddr_equal(sk, sk2);
+		return (!sk2_ipv6only &&
+			(!sk_rcv_saddr || !sk2_rcv_saddr ||
+			  sk_rcv_saddr == sk2_rcv_saddr));
 
 	if (addr_type2 == IPV6_ADDR_ANY &&
 	    !(sk2_ipv6only && addr_type == IPV6_ADDR_MAPPED))
diff -urN linux-2.6.30-rc2/net/packet/af_packet.c linux-2.6.30-rc3/net/packet/af_packet.c
--- linux-2.6.30-rc2/net/packet/af_packet.c	2009-04-22 03:29:12.373931457 +0000
+++ linux-2.6.30-rc3/net/packet/af_packet.c	2009-04-22 03:29:18.444931259 +0000
@@ -1758,8 +1758,9 @@
 
 static inline char *alloc_one_pg_vec_page(unsigned long order)
 {
-	return (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
-					 order);
+	gfp_t gfp_flags = GFP_KERNEL | __GFP_COMP | __GFP_ZERO | __GFP_NOWARN;
+
+	return (char *) __get_free_pages(gfp_flags, order);
 }
 
 static char **alloc_pg_vec(struct tpacket_req *req, int order)
diff -urN linux-2.6.30-rc2/net/rds/rds.h linux-2.6.30-rc3/net/rds/rds.h
--- linux-2.6.30-rc2/net/rds/rds.h	2009-04-22 03:29:12.383931495 +0000
+++ linux-2.6.30-rc3/net/rds/rds.h	2009-04-22 03:29:18.453931420 +0000
@@ -638,7 +638,7 @@
 void rds_rdma_unuse(struct rds_sock *rs, u32 r_key, int force);
 
 /* stats.c */
-DECLARE_PER_CPU(struct rds_statistics, rds_stats);
+DECLARE_PER_CPU_SHARED_ALIGNED(struct rds_statistics, rds_stats);
 #define rds_stats_inc_which(which, member) do {		\
 	per_cpu(which, get_cpu()).member++;		\
 	put_cpu();					\
diff -urN linux-2.6.30-rc2/net/rose/af_rose.c linux-2.6.30-rc3/net/rose/af_rose.c
--- linux-2.6.30-rc2/net/rose/af_rose.c	2009-04-22 03:29:12.385556628 +0000
+++ linux-2.6.30-rc3/net/rose/af_rose.c	2009-04-22 03:29:18.455931410 +0000
@@ -1072,10 +1072,6 @@
 	unsigned char *asmptr;
 	int n, size, qbit = 0;
 
-	/* ROSE empty frame has no meaning : don't send */
-	if (len == 0)
-		return 0;
-
 	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))
 		return -EINVAL;
 
@@ -1273,12 +1269,6 @@
 	skb_reset_transport_header(skb);
 	copied     = skb->len;
 
-	/* ROSE empty frame has no meaning : ignore it */
-	if (copied == 0) {
-		skb_free_datagram(sk, skb);
-		return copied;
-	}
-
 	if (copied > size) {
 		copied = size;
 		msg->msg_flags |= MSG_TRUNC;
diff -urN linux-2.6.30-rc2/net/sched/em_meta.c linux-2.6.30-rc3/net/sched/em_meta.c
--- linux-2.6.30-rc2/net/sched/em_meta.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/net/sched/em_meta.c	2009-04-22 03:29:18.455931410 +0000
@@ -176,8 +176,10 @@
 
 META_COLLECTOR(int_vlan_tag)
 {
-	unsigned short uninitialized_var(tag);
-	if (vlan_get_tag(skb, &tag) < 0)
+	unsigned short tag;
+
+	tag = vlan_tx_tag_get(skb);
+	if (!tag && __vlan_get_tag(skb, &tag))
 		*err = -1;
 	else
 		dst->value = tag;
diff -urN linux-2.6.30-rc2/scripts/Makefile.build linux-2.6.30-rc3/scripts/Makefile.build
--- linux-2.6.30-rc2/scripts/Makefile.build	2009-04-22 03:29:12.404931412 +0000
+++ linux-2.6.30-rc3/scripts/Makefile.build	2009-04-22 03:29:18.475931516 +0000
@@ -27,6 +27,9 @@
 cppflags-y :=
 ldflags-y  :=
 
+subdir-asflags-y :=
+subdir-ccflags-y :=
+
 # Read auto.conf if it exists, otherwise ignore
 -include include/config/auto.conf
 
diff -urN linux-2.6.30-rc2/scripts/Makefile.lib linux-2.6.30-rc3/scripts/Makefile.lib
--- linux-2.6.30-rc2/scripts/Makefile.lib	2009-04-22 03:29:12.405931438 +0000
+++ linux-2.6.30-rc3/scripts/Makefile.lib	2009-04-22 03:29:18.475931516 +0000
@@ -4,6 +4,11 @@
 cppflags-y += $(EXTRA_CPPFLAGS)
 ldflags-y  += $(EXTRA_LDFLAGS)
 
+#
+# flags that take effect in sub directories
+export KBUILD_SUBDIR_ASFLAGS := $(KBUILD_SUBDIR_ASFLAGS) $(subdir-asflags-y)
+export KBUILD_SUBDIR_CCFLAGS := $(KBUILD_SUBDIR_CCFLAGS) $(subdir-ccflags-y)
+
 # Figure out what we need to build from the various variables
 # ===========================================================================
 
@@ -104,10 +109,10 @@
 debug_flags =
 endif
 
-orig_c_flags   = $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS)                     \
+orig_c_flags   = $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(KBUILD_SUBDIR_CCFLAGS) \
                  $(ccflags-y) $(CFLAGS_$(basetarget).o)
 _c_flags       = $(filter-out $(CFLAGS_REMOVE_$(basetarget).o), $(orig_c_flags))
-_a_flags       = $(KBUILD_CPPFLAGS) $(KBUILD_AFLAGS)                     \
+_a_flags       = $(KBUILD_CPPFLAGS) $(KBUILD_AFLAGS) $(KBUILD_SUBDIR_ASFLAGS) \
                  $(asflags-y) $(AFLAGS_$(basetarget).o)
 _cpp_flags     = $(KBUILD_CPPFLAGS) $(cppflags-y) $(CPPFLAGS_$(@F))
 
diff -urN linux-2.6.30-rc2/security/smack/smack_lsm.c linux-2.6.30-rc3/security/smack/smack_lsm.c
--- linux-2.6.30-rc2/security/smack/smack_lsm.c	2009-04-22 03:29:12.417644039 +0000
+++ linux-2.6.30-rc3/security/smack/smack_lsm.c	2009-04-22 03:29:18.488931467 +0000
@@ -609,8 +609,12 @@
 	    strcmp(name, XATTR_NAME_SMACKIPOUT) == 0) {
 		if (!capable(CAP_MAC_ADMIN))
 			rc = -EPERM;
-		/* a label cannot be void and cannot begin with '-' */
-		if (size == 0 || (size > 0 && ((char *)value)[0] == '-'))
+		/*
+		 * check label validity here so import wont fail on
+		 * post_setxattr
+		 */
+		if (size == 0 || size >= SMK_LABELLEN ||
+		    smk_import(value, size) == NULL)
 			rc = -EINVAL;
 	} else
 		rc = cap_inode_setxattr(dentry, name, value, size, flags);
@@ -644,9 +648,6 @@
 	if (strcmp(name, XATTR_NAME_SMACK))
 		return;
 
-	if (size >= SMK_LABELLEN)
-		return;
-
 	isp = dentry->d_inode->i_security;
 
 	/*
diff -urN linux-2.6.30-rc2/sound/core/control.c linux-2.6.30-rc3/sound/core/control.c
--- linux-2.6.30-rc2/sound/core/control.c	2009-04-22 03:29:12.425931431 +0000
+++ linux-2.6.30-rc3/sound/core/control.c	2009-04-22 03:29:18.496931501 +0000
@@ -723,14 +723,11 @@
 {
 	struct snd_ctl_elem_value *control;
 	int result;
-	
-	control = kmalloc(sizeof(*control), GFP_KERNEL);
-	if (control == NULL)
-		return -ENOMEM;	
-	if (copy_from_user(control, _control, sizeof(*control))) {
-		kfree(control);
-		return -EFAULT;
-	}
+
+	control = memdup_user(_control, sizeof(*control));
+	if (IS_ERR(control))
+		return PTR_ERR(control);
+
 	snd_power_lock(card);
 	result = snd_power_wait(card, SNDRV_CTL_POWER_D0);
 	if (result >= 0)
@@ -784,13 +781,10 @@
 	struct snd_card *card;
 	int result;
 
-	control = kmalloc(sizeof(*control), GFP_KERNEL);
-	if (control == NULL)
-		return -ENOMEM;	
-	if (copy_from_user(control, _control, sizeof(*control))) {
-		kfree(control);
-		return -EFAULT;
-	}
+	control = memdup_user(_control, sizeof(*control));
+	if (IS_ERR(control))
+		return PTR_ERR(control);
+
 	card = file->card;
 	snd_power_lock(card);
 	result = snd_power_wait(card, SNDRV_CTL_POWER_D0);
@@ -916,13 +910,10 @@
 	if (op_flag > 0) {
 		if (size > 1024 * 128)	/* sane value */
 			return -EINVAL;
-		new_data = kmalloc(size, GFP_KERNEL);
-		if (new_data == NULL)
-			return -ENOMEM;
-		if (copy_from_user(new_data, tlv, size)) {
-			kfree(new_data);
-			return -EFAULT;
-		}
+
+		new_data = memdup_user(tlv, size);
+		if (IS_ERR(new_data))
+			return PTR_ERR(new_data);
 		change = ue->tlv_data_size != size;
 		if (!change)
 			change = memcmp(ue->tlv_data, new_data, size);
diff -urN linux-2.6.30-rc2/sound/core/jack.c linux-2.6.30-rc3/sound/core/jack.c
--- linux-2.6.30-rc2/sound/core/jack.c	2009-04-22 03:29:12.426931387 +0000
+++ linux-2.6.30-rc3/sound/core/jack.c	2009-04-22 03:29:18.497931438 +0000
@@ -35,6 +35,9 @@
 {
 	struct snd_jack *jack = device->device_data;
 
+	if (jack->private_free)
+		jack->private_free(jack);
+
 	/* If the input device is registered with the input subsystem
 	 * then we need to use a different deallocator. */
 	if (jack->registered)
diff -urN linux-2.6.30-rc2/sound/core/pcm_compat.c linux-2.6.30-rc3/sound/core/pcm_compat.c
--- linux-2.6.30-rc2/sound/core/pcm_compat.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/core/pcm_compat.c	2009-04-22 03:29:18.498931485 +0000
@@ -232,14 +232,11 @@
 	if (! (runtime = substream->runtime))
 		return -ENOTTY;
 
-	data = kmalloc(sizeof(*data), GFP_KERNEL);
-	if (data == NULL)
-		return -ENOMEM;
 	/* only fifo_size is different, so just copy all */
-	if (copy_from_user(data, data32, sizeof(*data32))) {
-		err = -EFAULT;
-		goto error;
-	}
+	data = memdup_user(data32, sizeof(*data32));
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
 	if (refine)
 		err = snd_pcm_hw_refine(substream, data);
 	else
diff -urN linux-2.6.30-rc2/sound/core/pcm_lib.c linux-2.6.30-rc3/sound/core/pcm_lib.c
--- linux-2.6.30-rc2/sound/core/pcm_lib.c	2009-04-22 03:29:12.428931415 +0000
+++ linux-2.6.30-rc3/sound/core/pcm_lib.c	2009-04-22 03:29:18.499931425 +0000
@@ -209,9 +209,11 @@
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;
-	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt, hw_base;
-	snd_pcm_sframes_t delta;
+	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_ptr_interrupt, hw_base;
+	snd_pcm_sframes_t hdelta, delta;
+	unsigned long jdelta;
 
+	old_hw_ptr = runtime->status->hw_ptr;
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);
@@ -247,7 +249,30 @@
 			new_hw_ptr = hw_base + pos;
 		}
 	}
-	if (delta > runtime->period_size) {
+	hdelta = new_hw_ptr - old_hw_ptr;
+	jdelta = jiffies - runtime->hw_ptr_jiffies;
+	if (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {
+		delta = jdelta /
+			(((runtime->period_size * HZ) / runtime->rate)
+								+ HZ/100);
+		hw_ptr_error(substream,
+			     "hw_ptr skipping! [Q] "
+			     "(pos=%ld, delta=%ld, period=%ld, "
+			     "jdelta=%lu/%lu/%lu)\n",
+			     (long)pos, (long)hdelta,
+			     (long)runtime->period_size, jdelta,
+			     ((hdelta * HZ) / runtime->rate), delta);
+		hw_ptr_interrupt = runtime->hw_ptr_interrupt +
+				   runtime->period_size * delta;
+		if (hw_ptr_interrupt >= runtime->boundary)
+			hw_ptr_interrupt -= runtime->boundary;
+		/* rebase to interrupt position */
+		hw_base = new_hw_ptr = hw_ptr_interrupt;
+		/* align hw_base to buffer_size */
+		hw_base -= hw_base % runtime->buffer_size;
+		delta = 0;
+	}
+	if (delta > runtime->period_size + runtime->period_size / 2) {
 		hw_ptr_error(substream,
 			     "Lost interrupts? "
 			     "(stream=%i, delta=%ld, intr_ptr=%ld)\n",
@@ -263,6 +288,7 @@
 
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
+	runtime->hw_ptr_jiffies = jiffies;
 	runtime->hw_ptr_interrupt = hw_ptr_interrupt;
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);
@@ -275,6 +301,7 @@
 	snd_pcm_uframes_t pos;
 	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
 	snd_pcm_sframes_t delta;
+	unsigned long jdelta;
 
 	old_hw_ptr = runtime->status->hw_ptr;
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
@@ -286,14 +313,15 @@
 	new_hw_ptr = hw_base + pos;
 
 	delta = new_hw_ptr - old_hw_ptr;
+	jdelta = jiffies - runtime->hw_ptr_jiffies;
 	if (delta < 0) {
 		delta += runtime->buffer_size;
 		if (delta < 0) {
 			hw_ptr_error(substream, 
 				     "Unexpected hw_pointer value [2] "
-				     "(stream=%i, pos=%ld, old_ptr=%ld)\n",
+				     "(stream=%i, pos=%ld, old_ptr=%ld, jdelta=%li)\n",
 				     substream->stream, (long)pos,
-				     (long)old_hw_ptr);
+				     (long)old_hw_ptr, jdelta);
 			return 0;
 		}
 		hw_base += runtime->buffer_size;
@@ -301,12 +329,13 @@
 			hw_base = 0;
 		new_hw_ptr = hw_base + pos;
 	}
-	if (delta > runtime->period_size && runtime->periods > 1) {
+	if (((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! "
-			     "(pos=%ld, delta=%ld, period=%ld)\n",
+			     "(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu)\n",
 			     (long)pos, (long)delta,
-			     (long)runtime->period_size);
+			     (long)runtime->period_size, jdelta,
+			     ((delta * HZ) / runtime->rate));
 		return 0;
 	}
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
@@ -315,6 +344,7 @@
 
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
+	runtime->hw_ptr_jiffies = jiffies;
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);
 }
@@ -1441,6 +1471,7 @@
 		runtime->status->hw_ptr %= runtime->buffer_size;
 	else
 		runtime->status->hw_ptr = 0;
+	runtime->hw_ptr_jiffies = jiffies;
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	return 0;
 }
diff -urN linux-2.6.30-rc2/sound/core/pcm_native.c linux-2.6.30-rc3/sound/core/pcm_native.c
--- linux-2.6.30-rc2/sound/core/pcm_native.c	2009-04-22 03:29:12.429931281 +0000
+++ linux-2.6.30-rc3/sound/core/pcm_native.c	2009-04-22 03:29:18.500931232 +0000
@@ -327,21 +327,16 @@
 	struct snd_pcm_hw_params *params;
 	int err;
 
-	params = kmalloc(sizeof(*params), GFP_KERNEL);
-	if (!params) {
-		err = -ENOMEM;
-		goto out;
-	}
-	if (copy_from_user(params, _params, sizeof(*params))) {
-		err = -EFAULT;
-		goto out;
-	}
+	params = memdup_user(_params, sizeof(*params));
+	if (IS_ERR(params))
+		return PTR_ERR(params);
+
 	err = snd_pcm_hw_refine(substream, params);
 	if (copy_to_user(_params, params, sizeof(*params))) {
 		if (!err)
 			err = -EFAULT;
 	}
-out:
+
 	kfree(params);
 	return err;
 }
@@ -465,21 +460,16 @@
 	struct snd_pcm_hw_params *params;
 	int err;
 
-	params = kmalloc(sizeof(*params), GFP_KERNEL);
-	if (!params) {
-		err = -ENOMEM;
-		goto out;
-	}
-	if (copy_from_user(params, _params, sizeof(*params))) {
-		err = -EFAULT;
-		goto out;
-	}
+	params = memdup_user(_params, sizeof(*params));
+	if (IS_ERR(params))
+		return PTR_ERR(params);
+
 	err = snd_pcm_hw_params(substream, params);
 	if (copy_to_user(_params, params, sizeof(*params))) {
 		if (!err)
 			err = -EFAULT;
 	}
-out:
+
 	kfree(params);
 	return err;
 }
@@ -2593,13 +2583,11 @@
 			return -EFAULT;
 		if (copy_from_user(&xfern, _xfern, sizeof(xfern)))
 			return -EFAULT;
-		bufs = kmalloc(sizeof(void *) * runtime->channels, GFP_KERNEL);
-		if (bufs == NULL)
-			return -ENOMEM;
-		if (copy_from_user(bufs, xfern.bufs, sizeof(void *) * runtime->channels)) {
-			kfree(bufs);
-			return -EFAULT;
-		}
+
+		bufs = memdup_user(xfern.bufs,
+				   sizeof(void *) * runtime->channels);
+		if (IS_ERR(bufs))
+			return PTR_ERR(bufs);
 		result = snd_pcm_lib_writev(substream, bufs, xfern.frames);
 		kfree(bufs);
 		__put_user(result, &_xfern->result);
@@ -2675,13 +2663,11 @@
 			return -EFAULT;
 		if (copy_from_user(&xfern, _xfern, sizeof(xfern)))
 			return -EFAULT;
-		bufs = kmalloc(sizeof(void *) * runtime->channels, GFP_KERNEL);
-		if (bufs == NULL)
-			return -ENOMEM;
-		if (copy_from_user(bufs, xfern.bufs, sizeof(void *) * runtime->channels)) {
-			kfree(bufs);
-			return -EFAULT;
-		}
+
+		bufs = memdup_user(xfern.bufs,
+				   sizeof(void *) * runtime->channels);
+		if (IS_ERR(bufs))
+			return PTR_ERR(bufs);
 		result = snd_pcm_lib_readv(substream, bufs, xfern.frames);
 		kfree(bufs);
 		__put_user(result, &_xfern->result);
@@ -3312,18 +3298,12 @@
 	int err;
 
 	params = kmalloc(sizeof(*params), GFP_KERNEL);
-	if (!params) {
-		err = -ENOMEM;
-		goto out;
-	}
-	oparams = kmalloc(sizeof(*oparams), GFP_KERNEL);
-	if (!oparams) {
-		err = -ENOMEM;
-		goto out;
-	}
+	if (!params)
+		return -ENOMEM;
 
-	if (copy_from_user(oparams, _oparams, sizeof(*oparams))) {
-		err = -EFAULT;
+	oparams = memdup_user(_oparams, sizeof(*oparams));
+	if (IS_ERR(oparams)) {
+		err = PTR_ERR(oparams);
 		goto out;
 	}
 	snd_pcm_hw_convert_from_old_params(params, oparams);
@@ -3333,9 +3313,10 @@
 		if (!err)
 			err = -EFAULT;
 	}
+
+	kfree(oparams);
 out:
 	kfree(params);
-	kfree(oparams);
 	return err;
 }
 
@@ -3347,17 +3328,12 @@
 	int err;
 
 	params = kmalloc(sizeof(*params), GFP_KERNEL);
-	if (!params) {
-		err = -ENOMEM;
-		goto out;
-	}
-	oparams = kmalloc(sizeof(*oparams), GFP_KERNEL);
-	if (!oparams) {
-		err = -ENOMEM;
-		goto out;
-	}
-	if (copy_from_user(oparams, _oparams, sizeof(*oparams))) {
-		err = -EFAULT;
+	if (!params)
+		return -ENOMEM;
+
+	oparams = memdup_user(_oparams, sizeof(*oparams));
+	if (IS_ERR(oparams)) {
+		err = PTR_ERR(oparams);
 		goto out;
 	}
 	snd_pcm_hw_convert_from_old_params(params, oparams);
@@ -3367,9 +3343,10 @@
 		if (!err)
 			err = -EFAULT;
 	}
+
+	kfree(oparams);
 out:
 	kfree(params);
-	kfree(oparams);
 	return err;
 }
 #endif /* CONFIG_SND_SUPPORT_OLD_API */
diff -urN linux-2.6.30-rc2/sound/core/seq/seq_compat.c linux-2.6.30-rc3/sound/core/seq/seq_compat.c
--- linux-2.6.30-rc2/sound/core/seq/seq_compat.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/core/seq/seq_compat.c	2009-04-22 03:29:18.501931468 +0000
@@ -48,12 +48,11 @@
 	struct snd_seq_port_info *data;
 	mm_segment_t fs;
 
-	data = kmalloc(sizeof(*data), GFP_KERNEL);
-	if (! data)
-		return -ENOMEM;
+	data = memdup_user(data32, sizeof(*data32));
+	if (IS_ERR(data))
+		return PTR_ERR(data);
 
-	if (copy_from_user(data, data32, sizeof(*data32)) ||
-	    get_user(data->flags, &data32->flags) ||
+	if (get_user(data->flags, &data32->flags) ||
 	    get_user(data->time_queue, &data32->time_queue))
 		goto error;
 	data->kernel = NULL;
diff -urN linux-2.6.30-rc2/sound/core/timer.c linux-2.6.30-rc3/sound/core/timer.c
--- linux-2.6.30-rc2/sound/core/timer.c	2009-04-22 03:29:12.430931427 +0000
+++ linux-2.6.30-rc3/sound/core/timer.c	2009-04-22 03:29:18.501931468 +0000
@@ -1395,13 +1395,10 @@
 	struct list_head *p;
 	int err = 0;
 
-	ginfo = kmalloc(sizeof(*ginfo), GFP_KERNEL);
-	if (! ginfo)
-		return -ENOMEM;
-	if (copy_from_user(ginfo, _ginfo, sizeof(*ginfo))) {
-		kfree(ginfo);
-		return -EFAULT;
-	}
+	ginfo = memdup_user(_ginfo, sizeof(*ginfo));
+	if (IS_ERR(ginfo))
+		return PTR_ERR(ginfo);
+
 	tid = ginfo->tid;
 	memset(ginfo, 0, sizeof(*ginfo));
 	ginfo->tid = tid;
diff -urN linux-2.6.30-rc2/sound/isa/sb/sb16_csp.c linux-2.6.30-rc3/sound/isa/sb/sb16_csp.c
--- linux-2.6.30-rc2/sound/isa/sb/sb16_csp.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/isa/sb/sb16_csp.c	2009-04-22 03:29:18.514931471 +0000
@@ -684,15 +684,16 @@
  
 static int snd_sb_csp_load_user(struct snd_sb_csp * p, const unsigned char __user *buf, int size, int load_flags)
 {
-	int err = -ENOMEM;
-	unsigned char *kbuf = kmalloc(size, GFP_KERNEL);
-	if (kbuf) {
-		if (copy_from_user(kbuf, buf, size))
-			err = -EFAULT;
-		else
-			err = snd_sb_csp_load(p, kbuf, size, load_flags);
-		kfree(kbuf);
-	}
+	int err;
+	unsigned char *kbuf;
+
+	kbuf = memdup_user(buf, size);
+	if (IS_ERR(kbuf))
+		return PTR_ERR(kbuf);
+
+	err = snd_sb_csp_load(p, kbuf, size, load_flags);
+
+	kfree(kbuf);
 	return err;
 }
 
diff -urN linux-2.6.30-rc2/sound/isa/wavefront/wavefront_fx.c linux-2.6.30-rc3/sound/isa/wavefront/wavefront_fx.c
--- linux-2.6.30-rc2/sound/isa/wavefront/wavefront_fx.c	2009-04-22 03:29:12.444931422 +0000
+++ linux-2.6.30-rc3/sound/isa/wavefront/wavefront_fx.c	2009-04-22 03:29:18.516931495 +0000
@@ -202,15 +202,11 @@
 					    "> 512 bytes to FX\n");
 				return -EIO;
 			}
-			page_data = kmalloc(r.data[2] * sizeof(short), GFP_KERNEL);
-			if (!page_data)
-				return -ENOMEM;
-			if (copy_from_user (page_data,
-					    (unsigned char __user *) r.data[3],
-					    r.data[2] * sizeof(short))) {
-				kfree(page_data);
-				return -EFAULT;
-			}
+			page_data = memdup_user((unsigned char __user *)
+						r.data[3],
+						r.data[2] * sizeof(short));
+			if (IS_ERR(page_data))
+				return PTR_ERR(page_data);
 			pd = page_data;
 		}
 
diff -urN linux-2.6.30-rc2/sound/isa/wavefront/wavefront_synth.c linux-2.6.30-rc3/sound/isa/wavefront/wavefront_synth.c
--- linux-2.6.30-rc2/sound/isa/wavefront/wavefront_synth.c	2009-04-22 03:29:12.445931192 +0000
+++ linux-2.6.30-rc3/sound/isa/wavefront/wavefront_synth.c	2009-04-22 03:29:18.516931495 +0000
@@ -1664,12 +1664,11 @@
 		break;
 
 	case WFCTL_WFCMD:
-		wc = kmalloc(sizeof(*wc), GFP_KERNEL);
-		if (! wc)
-			return -ENOMEM;
-		if (copy_from_user (wc, argp, sizeof (*wc)))
-			err = -EFAULT;
-		else if (wavefront_synth_control (acard, wc) < 0)
+		wc = memdup_user(argp, sizeof(*wc));
+		if (IS_ERR(wc))
+			return PTR_ERR(wc);
+
+		if (wavefront_synth_control (acard, wc) < 0)
 			err = -EIO;
 		else if (copy_to_user (argp, wc, sizeof (*wc)))
 			err = -EFAULT;
diff -urN linux-2.6.30-rc2/sound/pci/emu10k1/emufx.c linux-2.6.30-rc3/sound/pci/emu10k1/emufx.c
--- linux-2.6.30-rc2/sound/pci/emu10k1/emufx.c	2009-04-22 03:29:12.464931423 +0000
+++ linux-2.6.30-rc3/sound/pci/emu10k1/emufx.c	2009-04-22 03:29:18.543931458 +0000
@@ -2493,24 +2493,17 @@
 	case SNDRV_EMU10K1_IOCTL_CODE_POKE:
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
-		icode = kmalloc(sizeof(*icode), GFP_KERNEL);
-		if (icode == NULL)
-			return -ENOMEM;
-		if (copy_from_user(icode, argp, sizeof(*icode))) {
-			kfree(icode);
-			return -EFAULT;
-		}
+
+		icode = memdup_user(argp, sizeof(*icode));
+		if (IS_ERR(icode))
+			return PTR_ERR(icode);
 		res = snd_emu10k1_icode_poke(emu, icode);
 		kfree(icode);
 		return res;
 	case SNDRV_EMU10K1_IOCTL_CODE_PEEK:
-		icode = kmalloc(sizeof(*icode), GFP_KERNEL);
-		if (icode == NULL)
-			return -ENOMEM;
-		if (copy_from_user(icode, argp, sizeof(*icode))) {
-			kfree(icode);
-			return -EFAULT;
-		}
+		icode = memdup_user(argp, sizeof(*icode));
+		if (IS_ERR(icode))
+			return PTR_ERR(icode);
 		res = snd_emu10k1_icode_peek(emu, icode);
 		if (res == 0 && copy_to_user(argp, icode, sizeof(*icode))) {
 			kfree(icode);
@@ -2519,24 +2512,16 @@
 		kfree(icode);
 		return res;
 	case SNDRV_EMU10K1_IOCTL_PCM_POKE:
-		ipcm = kmalloc(sizeof(*ipcm), GFP_KERNEL);
-		if (ipcm == NULL)
-			return -ENOMEM;
-		if (copy_from_user(ipcm, argp, sizeof(*ipcm))) {
-			kfree(ipcm);
-			return -EFAULT;
-		}
+		ipcm = memdup_user(argp, sizeof(*ipcm));
+		if (IS_ERR(ipcm))
+			return PTR_ERR(ipcm);
 		res = snd_emu10k1_ipcm_poke(emu, ipcm);
 		kfree(ipcm);
 		return res;
 	case SNDRV_EMU10K1_IOCTL_PCM_PEEK:
-		ipcm = kzalloc(sizeof(*ipcm), GFP_KERNEL);
-		if (ipcm == NULL)
-			return -ENOMEM;
-		if (copy_from_user(ipcm, argp, sizeof(*ipcm))) {
-			kfree(ipcm);
-			return -EFAULT;
-		}
+		ipcm = memdup_user(argp, sizeof(*ipcm));
+		if (IS_ERR(ipcm))
+			return PTR_ERR(ipcm);
 		res = snd_emu10k1_ipcm_peek(emu, ipcm);
 		if (res == 0 && copy_to_user(argp, ipcm, sizeof(*ipcm))) {
 			kfree(ipcm);
diff -urN linux-2.6.30-rc2/sound/pci/emu10k1/io.c linux-2.6.30-rc3/sound/pci/emu10k1/io.c
--- linux-2.6.30-rc2/sound/pci/emu10k1/io.c	2009-04-22 03:29:12.465931383 +0000
+++ linux-2.6.30-rc3/sound/pci/emu10k1/io.c	2009-04-22 03:29:18.544854547 +0000
@@ -490,7 +490,7 @@
 			if (newtime != curtime)
 				break;
 		}
-		if (count >= 16384)
+		if (count > 16384)
 			break;
 		curtime = newtime;
 	}
diff -urN linux-2.6.30-rc2/sound/pci/hda/hda_codec.c linux-2.6.30-rc3/sound/pci/hda/hda_codec.c
--- linux-2.6.30-rc2/sound/pci/hda/hda_codec.c	2009-04-22 03:29:12.468556325 +0000
+++ linux-2.6.30-rc3/sound/pci/hda/hda_codec.c	2009-04-22 03:29:18.547856109 +0000
@@ -642,19 +642,21 @@
  */
 static void /*__devinit*/ setup_fg_nodes(struct hda_codec *codec)
 {
-	int i, total_nodes;
+	int i, total_nodes, function_id;
 	hda_nid_t nid;
 
 	total_nodes = snd_hda_get_sub_nodes(codec, AC_NODE_ROOT, &nid);
 	for (i = 0; i < total_nodes; i++, nid++) {
-		codec->function_id = snd_hda_param_read(codec, nid,
+		function_id = snd_hda_param_read(codec, nid,
 						AC_PAR_FUNCTION_TYPE) & 0xff;
-		switch (codec->function_id) {
+		switch (function_id) {
 		case AC_GRP_AUDIO_FUNCTION:
 			codec->afg = nid;
+			codec->function_id = function_id;
 			break;
 		case AC_GRP_MODEM_FUNCTION:
 			codec->mfg = nid;
+			codec->function_id = function_id;
 			break;
 		default:
 			break;
@@ -2250,7 +2252,11 @@
 	err = bus->ops.command(bus, res);
 	if (!err) {
 		struct hda_cache_head *c;
-		u32 key = build_cmd_cache_key(nid, verb);
+		u32 key;
+		/* parm may contain the verb stuff for get/set amp */
+		verb = verb | (parm >> 8);
+		parm &= 0xff;
+		key = build_cmd_cache_key(nid, verb);
 		c = get_alloc_hash(&codec->cmd_cache, key);
 		if (c)
 			c->val = parm;
diff -urN linux-2.6.30-rc2/sound/pci/hda/hda_intel.c linux-2.6.30-rc3/sound/pci/hda/hda_intel.c
--- linux-2.6.30-rc2/sound/pci/hda/hda_intel.c	2009-04-22 03:29:12.470931473 +0000
+++ linux-2.6.30-rc3/sound/pci/hda/hda_intel.c	2009-04-22 03:29:18.549931460 +0000
@@ -312,6 +312,8 @@
 	unsigned int period_bytes; /* size of the period in bytes */
 	unsigned int frags;	/* number for period in the play buffer */
 	unsigned int fifo_size;	/* FIFO size */
+	unsigned long start_jiffies;	/* start + minimum jiffies */
+	unsigned long min_jiffies;	/* minimum jiffies before position is valid */
 
 	void __iomem *sd_addr;	/* stream descriptor pointer */
 
@@ -330,7 +332,7 @@
 	unsigned int opened :1;
 	unsigned int running :1;
 	unsigned int irq_pending :1;
-	unsigned int irq_ignore :1;
+	unsigned int start_flag: 1;	/* stream full start flag */
 	/*
 	 * For VIA:
 	 *  A flag to ensure DMA position is 0
@@ -975,7 +977,7 @@
 	struct azx *chip = dev_id;
 	struct azx_dev *azx_dev;
 	u32 status;
-	int i;
+	int i, ok;
 
 	spin_lock(&chip->reg_lock);
 
@@ -991,18 +993,14 @@
 			azx_sd_writeb(azx_dev, SD_STS, SD_INT_MASK);
 			if (!azx_dev->substream || !azx_dev->running)
 				continue;
-			/* ignore the first dummy IRQ (due to pos_adj) */
-			if (azx_dev->irq_ignore) {
-				azx_dev->irq_ignore = 0;
-				continue;
-			}
 			/* check whether this IRQ is really acceptable */
-			if (azx_position_ok(chip, azx_dev)) {
+			ok = azx_position_ok(chip, azx_dev);
+			if (ok == 1) {
 				azx_dev->irq_pending = 0;
 				spin_unlock(&chip->reg_lock);
 				snd_pcm_period_elapsed(azx_dev->substream);
 				spin_lock(&chip->reg_lock);
-			} else if (chip->bus && chip->bus->workq) {
+			} else if (ok == 0 && chip->bus && chip->bus->workq) {
 				/* bogus IRQ, process it later */
 				azx_dev->irq_pending = 1;
 				queue_work(chip->bus->workq,
@@ -1088,7 +1086,6 @@
 	bdl = (u32 *)azx_dev->bdl.area;
 	ofs = 0;
 	azx_dev->frags = 0;
-	azx_dev->irq_ignore = 0;
 	pos_adj = bdl_pos_adj[chip->dev_index];
 	if (pos_adj > 0) {
 		struct snd_pcm_runtime *runtime = substream->runtime;
@@ -1109,7 +1106,6 @@
 					 &bdl, ofs, pos_adj, 1);
 			if (ofs < 0)
 				goto error;
-			azx_dev->irq_ignore = 1;
 		}
 	} else
 		pos_adj = 0;
@@ -1155,6 +1151,9 @@
 	while (((val = azx_sd_readb(azx_dev, SD_CTL)) & SD_CTL_STREAM_RESET) &&
 	       --timeout)
 		;
+
+	/* reset first position - may not be synced with hw at this time */
+	*azx_dev->posbuf = 0;
 }
 
 /*
@@ -1409,7 +1408,6 @@
 	snd_pcm_set_sync(substream);
 	mutex_unlock(&chip->open_mutex);
 
-	azx_stream_reset(chip, azx_dev);
 	return 0;
 }
 
@@ -1474,6 +1472,7 @@
 	unsigned int bufsize, period_bytes, format_val;
 	int err;
 
+	azx_stream_reset(chip, azx_dev);
 	format_val = snd_hda_calc_stream_format(runtime->rate,
 						runtime->channels,
 						runtime->format,
@@ -1502,6 +1501,8 @@
 			return err;
 	}
 
+	azx_dev->min_jiffies = (runtime->period_size * HZ) /
+						(runtime->rate * 2);
 	azx_setup_controller(chip, azx_dev);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		azx_dev->fifo_size = azx_sd_readw(azx_dev, SD_FIFOSIZE) + 1;
@@ -1518,13 +1519,14 @@
 	struct azx *chip = apcm->chip;
 	struct azx_dev *azx_dev;
 	struct snd_pcm_substream *s;
-	int start, nsync = 0, sbits = 0;
+	int rstart = 0, start, nsync = 0, sbits = 0;
 	int nwait, timeout;
 
 	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		rstart = 1;
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_START:
 		start = 1;
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
@@ -1554,6 +1556,10 @@
 		if (s->pcm->card != substream->pcm->card)
 			continue;
 		azx_dev = get_azx_dev(s);
+		if (rstart) {
+			azx_dev->start_flag = 1;
+			azx_dev->start_jiffies = jiffies + azx_dev->min_jiffies;
+		}
 		if (start)
 			azx_stream_start(chip, azx_dev);
 		else
@@ -1703,6 +1709,11 @@
 {
 	unsigned int pos;
 
+	if (azx_dev->start_flag &&
+	    time_before_eq(jiffies, azx_dev->start_jiffies))
+		return -1;	/* bogus (too early) interrupt */
+	azx_dev->start_flag = 0;
+
 	pos = azx_get_position(chip, azx_dev);
 	if (chip->position_fix == POS_FIX_AUTO) {
 		if (!pos) {
diff -urN linux-2.6.30-rc2/sound/pci/hda/patch_analog.c linux-2.6.30-rc3/sound/pci/hda/patch_analog.c
--- linux-2.6.30-rc2/sound/pci/hda/patch_analog.c	2009-04-22 03:29:12.472931242 +0000
+++ linux-2.6.30-rc3/sound/pci/hda/patch_analog.c	2009-04-22 03:29:18.551626260 +0000
@@ -3977,6 +3977,14 @@
 		spec->input_mux = &ad1884a_laptop_capture_source;
 		codec->patch_ops.unsol_event = ad1884a_hp_unsol_event;
 		codec->patch_ops.init = ad1884a_hp_init;
+		/* set the upper-limit for mixer amp to 0dB for avoiding the
+		 * possible damage by overloading
+		 */
+		snd_hda_override_amp_caps(codec, 0x20, HDA_INPUT,
+					  (0x17 << AC_AMPCAP_OFFSET_SHIFT) |
+					  (0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |
+					  (0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |
+					  (1 << AC_AMPCAP_MUTE_SHIFT));
 		break;
 	case AD1884A_MOBILE:
 		spec->mixers[0] = ad1884a_mobile_mixers;
diff -urN linux-2.6.30-rc2/sound/pci/hda/patch_conexant.c linux-2.6.30-rc3/sound/pci/hda/patch_conexant.c
--- linux-2.6.30-rc2/sound/pci/hda/patch_conexant.c	2009-04-22 03:29:12.473931442 +0000
+++ linux-2.6.30-rc3/sound/pci/hda/patch_conexant.c	2009-04-22 03:29:18.552931576 +0000
@@ -350,12 +350,20 @@
 }
 
 #ifdef CONFIG_SND_JACK
+static void conexant_free_jack_priv(struct snd_jack *jack)
+{
+	struct conexant_jack *jacks = jack->private_data;
+	jacks->nid = 0;
+	jacks->jack = NULL;
+}
+
 static int conexant_add_jack(struct hda_codec *codec,
 		hda_nid_t nid, int type)
 {
 	struct conexant_spec *spec;
 	struct conexant_jack *jack;
 	const char *name;
+	int err;
 
 	spec = codec->spec;
 	snd_array_init(&spec->jacks, sizeof(*jack), 32);
@@ -368,7 +376,12 @@
 	jack->nid = nid;
 	jack->type = type;
 
-	return snd_jack_new(codec->bus->card, name, type, &jack->jack);
+	err = snd_jack_new(codec->bus->card, name, type, &jack->jack);
+	if (err < 0)
+		return err;
+	jack->jack->private_data = jack;
+	jack->jack->private_free = conexant_free_jack_priv;
+	return 0;
 }
 
 static void conexant_report_jack(struct hda_codec *codec, hda_nid_t nid)
@@ -455,8 +468,10 @@
 	if (spec->jacks.list) {
 		struct conexant_jack *jacks = spec->jacks.list;
 		int i;
-		for (i = 0; i < spec->jacks.used; i++)
-			snd_device_free(codec->bus->card, &jacks[i].jack);
+		for (i = 0; i < spec->jacks.used; i++, jacks++) {
+			if (jacks->jack)
+				snd_device_free(codec->bus->card, jacks->jack);
+		}
 		snd_array_free(&spec->jacks);
 	}
 #endif
diff -urN linux-2.6.30-rc2/sound/pci/hda/patch_realtek.c linux-2.6.30-rc3/sound/pci/hda/patch_realtek.c
--- linux-2.6.30-rc2/sound/pci/hda/patch_realtek.c	2009-04-22 03:29:12.478556355 +0000
+++ linux-2.6.30-rc3/sound/pci/hda/patch_realtek.c	2009-04-22 03:29:18.556931610 +0000
@@ -8742,10 +8742,9 @@
 	SND_PCI_QUIRK_VENDOR(0x1558, "Clevo laptop", ALC883_LAPTOP_EAPD),
 	SND_PCI_QUIRK(0x15d9, 0x8780, "Supermicro PDSBA", ALC883_3ST_6ch),
 	SND_PCI_QUIRK(0x161f, 0x2054, "Medion laptop", ALC883_MEDION),
-	SND_PCI_QUIRK(0x1734, 0x1107, "FSC AMILO Xi2550",
+	SND_PCI_QUIRK_MASK(0x1734, 0xfff0, 0x1100, "FSC AMILO Xi/Pi25xx",
 		      ALC883_FUJITSU_PI2515),
-	SND_PCI_QUIRK(0x1734, 0x1108, "Fujitsu AMILO Pi2515", ALC883_FUJITSU_PI2515),
-	SND_PCI_QUIRK(0x1734, 0x113d, "Fujitsu AMILO Xa3530",
+	SND_PCI_QUIRK_MASK(0x1734, 0xfff0, 0x1130, "Fujitsu AMILO Xa35xx",
 		ALC888_FUJITSU_XA3530),
 	SND_PCI_QUIRK(0x17aa, 0x101e, "Lenovo 101e", ALC883_LENOVO_101E_2ch),
 	SND_PCI_QUIRK(0x17aa, 0x2085, "Lenovo NB0763", ALC883_LENOVO_NB0763),
diff -urN linux-2.6.30-rc2/sound/pci/hda/patch_sigmatel.c linux-2.6.30-rc3/sound/pci/hda/patch_sigmatel.c
--- linux-2.6.30-rc2/sound/pci/hda/patch_sigmatel.c	2009-04-22 03:29:12.480931217 +0000
+++ linux-2.6.30-rc3/sound/pci/hda/patch_sigmatel.c	2009-04-22 03:29:18.559931522 +0000
@@ -3076,6 +3076,11 @@
 	unsigned int wid_caps;
 
 	for (i = 0; i < num_outs && i < ARRAY_SIZE(chname); i++) {
+		if (type == AUTO_PIN_HP_OUT && !spec->hp_detect) {
+			wid_caps = get_wcaps(codec, pins[i]);
+			if (wid_caps & AC_WCAP_UNSOL_CAP)
+				spec->hp_detect = 1;
+		}
 		nid = dac_nids[i];
 		if (!nid)
 			continue;
@@ -3119,11 +3124,6 @@
 			err = create_controls_idx(codec, name, idx, nid, 3);
 			if (err < 0)
 				return err;
-			if (type == AUTO_PIN_HP_OUT && !spec->hp_detect) {
-				wid_caps = get_wcaps(codec, pins[i]);
-				if (wid_caps & AC_WCAP_UNSOL_CAP)
-					spec->hp_detect = 1;
-			}
 		}
 	}
 	return 0;
@@ -3851,6 +3851,15 @@
 			   AC_VERB_SET_GPIO_DATA, gpiostate); /* sync */
 }
 
+#ifdef CONFIG_SND_JACK
+static void stac92xx_free_jack_priv(struct snd_jack *jack)
+{
+	struct sigmatel_jack *jacks = jack->private_data;
+	jacks->nid = 0;
+	jacks->jack = NULL;
+}
+#endif
+
 static int stac92xx_add_jack(struct hda_codec *codec,
 		hda_nid_t nid, int type)
 {
@@ -3860,6 +3869,7 @@
 	int def_conf = snd_hda_codec_get_pincfg(codec, nid);
 	int connectivity = get_defcfg_connect(def_conf);
 	char name[32];
+	int err;
 
 	if (connectivity && connectivity != AC_JACK_PORT_FIXED)
 		return 0;
@@ -3876,10 +3886,15 @@
 		snd_hda_get_jack_connectivity(def_conf),
 		snd_hda_get_jack_location(def_conf));
 
-	return snd_jack_new(codec->bus->card, name, type, &jack->jack);
-#else
-	return 0;
+	err = snd_jack_new(codec->bus->card, name, type, &jack->jack);
+	if (err < 0) {
+		jack->nid = 0;
+		return err;
+	}
+	jack->jack->private_data = jack;
+	jack->jack->private_free = stac92xx_free_jack_priv;
 #endif
+	return 0;
 }
 
 static int stac_add_event(struct sigmatel_spec *spec, hda_nid_t nid,
@@ -4138,8 +4153,10 @@
 	if (!codec->bus->shutdown && spec->jacks.list) {
 		struct sigmatel_jack *jacks = spec->jacks.list;
 		int i;
-		for (i = 0; i < spec->jacks.used; i++)
-			snd_device_free(codec->bus->card, &jacks[i].jack);
+		for (i = 0; i < spec->jacks.used; i++, jacks++) {
+			if (jacks->jack)
+				snd_device_free(codec->bus->card, jacks->jack);
+		}
 	}
 	snd_array_free(&spec->jacks);
 #endif
diff -urN linux-2.6.30-rc2/sound/pci/intel8x0.c linux-2.6.30-rc3/sound/pci/intel8x0.c
--- linux-2.6.30-rc2/sound/pci/intel8x0.c	2009-04-22 03:29:12.483931183 +0000
+++ linux-2.6.30-rc3/sound/pci/intel8x0.c	2009-04-22 03:29:18.562931701 +0000
@@ -355,6 +355,9 @@
         unsigned int fragsize1;
         unsigned int position;
 	unsigned int pos_shift;
+	unsigned int last_pos;
+	unsigned long last_pos_jiffies;
+	unsigned int jiffy_to_bytes;
         int frags;
         int lvi;
         int lvi_frag;
@@ -838,7 +841,10 @@
 		ichdev->suspended = 0;
 		/* fallthru */
 	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		val = ICH_IOCE | ICH_STARTBM;
+		ichdev->last_pos = ichdev->position;
+		ichdev->last_pos_jiffies = jiffies;
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		ichdev->suspended = 1;
@@ -849,9 +855,6 @@
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		val = ICH_IOCE;
 		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		val = ICH_IOCE | ICH_STARTBM;
-		break;
 	default:
 		return -EINVAL;
 	}
@@ -1045,6 +1048,7 @@
 			ichdev->pos_shift = (runtime->sample_bits > 16) ? 2 : 1;
 	}
 	snd_intel8x0_setup_periods(chip, ichdev);
+	ichdev->jiffy_to_bytes = (runtime->rate * 4 * ichdev->pos_shift) / HZ;
 	return 0;
 }
 
@@ -1053,7 +1057,7 @@
 	struct intel8x0 *chip = snd_pcm_substream_chip(substream);
 	struct ichdev *ichdev = get_ichdev(substream);
 	size_t ptr1, ptr;
-	int civ, timeout = 100;
+	int civ, timeout = 10;
 	unsigned int position;
 
 	spin_lock(&chip->reg_lock);
@@ -1069,9 +1073,19 @@
 		    ptr1 == igetword(chip, ichdev->reg_offset + ichdev->roff_picb))
 			break;
 	} while (timeout--);
-	ptr1 <<= ichdev->pos_shift;
-	ptr = ichdev->fragsize1 - ptr1;
-	ptr += position;
+	if (ptr1 != 0) {
+		ptr1 <<= ichdev->pos_shift;
+		ptr = ichdev->fragsize1 - ptr1;
+		ptr += position;
+		ichdev->last_pos = ptr;
+		ichdev->last_pos_jiffies = jiffies;
+	} else {
+		ptr1 = jiffies - ichdev->last_pos_jiffies;
+		if (ptr1)
+			ptr1 -= 1;
+		ptr = ichdev->last_pos + ptr1 * ichdev->jiffy_to_bytes;
+		ptr %= ichdev->size;
+	}
 	spin_unlock(&chip->reg_lock);
 	if (ptr >= ichdev->size)
 		return 0;
@@ -1840,6 +1854,12 @@
 	},
 	{
 		.subvendor = 0x1028,
+		.subdevice = 0x016a,
+		.name = "Dell Inspiron 8600",	/* STAC9750/51 */
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
+		.subvendor = 0x1028,
 		.subdevice = 0x0186,
 		.name = "Dell Latitude D810", /* cf. Malone #41015 */
 		.type = AC97_TUNE_HP_MUTE_LED
@@ -1882,12 +1902,6 @@
 	},
 	{
 		.subvendor = 0x103c,
-		.subdevice = 0x0934,
-		.name = "HP nx8220",
-		.type = AC97_TUNE_MUTE_LED
-	},
-	{
-		.subvendor = 0x103c,
 		.subdevice = 0x129d,
 		.name = "HP xw8000",
 		.type = AC97_TUNE_HP_ONLY
@@ -2661,12 +2675,14 @@
 	struct snd_pcm_substream *subs;
 	struct ichdev *ichdev;
 	unsigned long port;
-	unsigned long pos, t;
-	struct timeval start_time, stop_time;
+	unsigned long pos, pos1, t;
+	int civ, timeout = 1000, attempt = 1;
+	struct timespec start_time, stop_time;
 
 	if (chip->ac97_bus->clock != 48000)
 		return; /* specified in module option */
 
+      __again:
 	subs = chip->pcm[0]->streams[0].substream;
 	if (! subs || subs->dma_buffer.bytes < INTEL8X0_TESTBUF_SIZE) {
 		snd_printk(KERN_WARNING "no playback buffer allocated - aborting measure ac97 clock\n");
@@ -2674,7 +2690,7 @@
 	}
 	ichdev = &chip->ichd[ICHD_PCMOUT];
 	ichdev->physbuf = subs->dma_buffer.addr;
-	ichdev->size = chip->ichd[ICHD_PCMOUT].fragsize = INTEL8X0_TESTBUF_SIZE;
+	ichdev->size = ichdev->fragsize = INTEL8X0_TESTBUF_SIZE;
 	ichdev->substream = NULL; /* don't process interrupts */
 
 	/* set rate */
@@ -2693,16 +2709,31 @@
 		iputbyte(chip, port + ICH_REG_OFF_CR, ICH_IOCE);
 		iputdword(chip, ICHREG(ALI_DMACR), 1 << ichdev->ali_slot);
 	}
-	do_gettimeofday(&start_time);
+	do_posix_clock_monotonic_gettime(&start_time);
 	spin_unlock_irq(&chip->reg_lock);
 	msleep(50);
 	spin_lock_irq(&chip->reg_lock);
 	/* check the position */
-	pos = ichdev->fragsize1;
-	pos -= igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << ichdev->pos_shift;
-	pos += ichdev->position;
+	do {
+		civ = igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV);
+		pos1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb);
+		if (pos1 == 0) {
+			udelay(10);
+			continue;
+		}
+		if (civ == igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV) &&
+		    pos1 == igetword(chip, ichdev->reg_offset + ichdev->roff_picb))
+			break;
+	} while (timeout--);
+	if (pos1 == 0) {	/* oops, this value is not reliable */
+		pos = 0;
+	} else {
+		pos = ichdev->fragsize1;
+		pos -= pos1 << ichdev->pos_shift;
+		pos += ichdev->position;
+	}
 	chip->in_measurement = 0;
-	do_gettimeofday(&stop_time);
+	do_posix_clock_monotonic_gettime(&stop_time);
 	/* stop */
 	if (chip->device_type == DEVICE_ALI) {
 		iputdword(chip, ICHREG(ALI_DMACR), 1 << (ichdev->ali_slot + 16));
@@ -2717,19 +2748,37 @@
 	iputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);
 	spin_unlock_irq(&chip->reg_lock);
 
+	if (pos == 0) {
+		snd_printk(KERN_ERR "intel8x0: measure - unreliable DMA position..\n");
+	      __retry:
+		if (attempt < 2) {
+			attempt++;
+			goto __again;
+		}
+		return;
+	}
+
+	pos /= 4;
 	t = stop_time.tv_sec - start_time.tv_sec;
 	t *= 1000000;
-	t += stop_time.tv_usec - start_time.tv_usec;
-	printk(KERN_INFO "%s: measured %lu usecs\n", __func__, t);
+	t += (stop_time.tv_nsec - start_time.tv_nsec) / 1000;
+	printk(KERN_INFO "%s: measured %lu usecs (%lu samples)\n", __func__, t, pos);
 	if (t == 0) {
-		snd_printk(KERN_ERR "?? calculation error..\n");
-		return;
+		snd_printk(KERN_ERR "intel8x0: ?? calculation error..\n");
+		goto __retry;
 	}
-	pos = (pos / 4) * 1000;
+	pos *= 1000;
 	pos = (pos / t) * 1000 + ((pos % t) * 1000) / t;
-	if (pos < 40000 || pos >= 60000) 
+	if (pos < 40000 || pos >= 60000) {
 		/* abnormal value. hw problem? */
 		printk(KERN_INFO "intel8x0: measured clock %ld rejected\n", pos);
+		goto __retry;
+	} else if (pos > 40500 && pos < 41500)
+		/* first exception - 41000Hz reference clock */
+		chip->ac97_bus->clock = 41000;
+	else if (pos > 43600 && pos < 44600)
+		/* second exception - 44100HZ reference clock */
+		chip->ac97_bus->clock = 44100;
 	else if (pos < 47500 || pos > 48500)
 		/* not 48000Hz, tuning the clock.. */
 		chip->ac97_bus->clock = (chip->ac97_bus->clock * 48000) / pos;
diff -urN linux-2.6.30-rc2/sound/soc/omap/omap-mcbsp.c linux-2.6.30-rc3/sound/soc/omap/omap-mcbsp.c
--- linux-2.6.30-rc2/sound/soc/omap/omap-mcbsp.c	2009-04-22 03:29:12.517931385 +0000
+++ linux-2.6.30-rc3/sound/soc/omap/omap-mcbsp.c	2009-04-22 03:29:18.596931437 +0000
@@ -283,7 +283,7 @@
 		break;
 	case SND_SOC_DAIFMT_DSP_B:
 		regs->srgr2	|= FPER(wlen * channels - 1);
-		regs->srgr1	|= FWID(wlen * channels - 2);
+		regs->srgr1	|= FWID(0);
 		break;
 	}
 
@@ -302,6 +302,7 @@
 {
 	struct omap_mcbsp_data *mcbsp_data = to_mcbsp(cpu_dai->private_data);
 	struct omap_mcbsp_reg_cfg *regs = &mcbsp_data->regs;
+	unsigned int temp_fmt = fmt;
 
 	if (mcbsp_data->configured)
 		return 0;
@@ -328,6 +329,8 @@
 		/* 0-bit data delay */
 		regs->rcr2      |= RDATDLY(0);
 		regs->xcr2      |= XDATDLY(0);
+		/* Invert FS polarity configuration */
+		temp_fmt ^= SND_SOC_DAIFMT_NB_IF;
 		break;
 	default:
 		/* Unsupported data format */
@@ -351,7 +354,7 @@
 	}
 
 	/* Set bit clock (CLKX/CLKR) and FS polarities */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	switch (temp_fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_NB_NF:
 		/*
 		 * Normal BCLK + FS.
diff -urN linux-2.6.30-rc2/sound/soc/omap/osk5912.c linux-2.6.30-rc3/sound/soc/omap/osk5912.c
--- linux-2.6.30-rc2/sound/soc/omap/osk5912.c	2009-04-22 03:29:12.517931385 +0000
+++ linux-2.6.30-rc3/sound/soc/omap/osk5912.c	2009-04-22 03:29:18.596931437 +0000
@@ -62,7 +62,7 @@
 	/* Set codec DAI configuration */
 	err = snd_soc_dai_set_fmt(codec_dai,
 				  SND_SOC_DAIFMT_DSP_B |
-				  SND_SOC_DAIFMT_NB_IF |
+				  SND_SOC_DAIFMT_NB_NF |
 				  SND_SOC_DAIFMT_CBM_CFM);
 	if (err < 0) {
 		printk(KERN_ERR "can't set codec DAI configuration\n");
@@ -72,7 +72,7 @@
 	/* Set cpu DAI configuration */
 	err = snd_soc_dai_set_fmt(cpu_dai,
 				  SND_SOC_DAIFMT_DSP_B |
-				  SND_SOC_DAIFMT_NB_IF |
+				  SND_SOC_DAIFMT_NB_NF |
 				  SND_SOC_DAIFMT_CBM_CFM);
 	if (err < 0) {
 		printk(KERN_ERR "can't set cpu DAI configuration\n");
diff -urN linux-2.6.30-rc2/sound/soc/pxa/magician.c linux-2.6.30-rc3/sound/soc/pxa/magician.c
--- linux-2.6.30-rc2/sound/soc/pxa/magician.c	2009-04-22 03:29:12.518931505 +0000
+++ linux-2.6.30-rc3/sound/soc/pxa/magician.c	2009-04-22 03:29:18.598931497 +0000
@@ -27,8 +27,6 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 
-#include <mach/pxa-regs.h>
-#include <mach/hardware.h>
 #include <mach/magician.h>
 #include <asm/mach-types.h>
 #include "../codecs/uda1380.h"
diff -urN linux-2.6.30-rc2/sound/soc/pxa/pxa-ssp.c linux-2.6.30-rc3/sound/soc/pxa/pxa-ssp.c
--- linux-2.6.30-rc2/sound/soc/pxa/pxa-ssp.c	2009-04-22 03:29:12.519931414 +0000
+++ linux-2.6.30-rc3/sound/soc/pxa/pxa-ssp.c	2009-04-22 03:29:18.599931427 +0000
@@ -806,6 +806,7 @@
 		goto err_priv;
 	}
 
+	priv->dai_fmt = (unsigned int) -1;
 	dai->private_data = priv;
 
 	return 0;
diff -urN linux-2.6.30-rc2/sound/soc/s3c24xx/Kconfig linux-2.6.30-rc3/sound/soc/s3c24xx/Kconfig
--- linux-2.6.30-rc2/sound/soc/s3c24xx/Kconfig	2009-04-22 03:29:12.520931408 +0000
+++ linux-2.6.30-rc3/sound/soc/s3c24xx/Kconfig	2009-04-22 03:29:18.600931446 +0000
@@ -1,10 +1,10 @@
 config SND_S3C24XX_SOC
 	tristate "SoC Audio for the Samsung S3CXXXX chips"
-	depends on ARCH_S3C2410 || ARCH_S3C64XX
+	depends on ARCH_S3C2410
 	help
 	  Say Y or M if you want to add support for codecs attached to
-	  the S3C24XX and S3C64XX AC97, I2S or SSP interface. You will
-	  also need to select the audio interfaces to support below.
+	  the S3C24XX AC97 or I2S interfaces. You will also need to
+	  select the audio interfaces to support below.
 
 config SND_S3C24XX_SOC_I2S
 	tristate
diff -urN linux-2.6.30-rc2/sound/soc/s3c24xx/jive_wm8750.c linux-2.6.30-rc3/sound/soc/s3c24xx/jive_wm8750.c
--- linux-2.6.30-rc2/sound/soc/s3c24xx/jive_wm8750.c	2009-04-22 03:29:12.521931413 +0000
+++ linux-2.6.30-rc3/sound/soc/s3c24xx/jive_wm8750.c	2009-04-22 03:29:18.600931446 +0000
@@ -69,8 +69,8 @@
 		break;
 	}
 
-	s3c_i2sv2_calc_rate(&div, NULL, params_rate(params),
-			    s3c2412_get_iisclk());
+	s3c_i2sv2_iis_calc_rate(&div, NULL, params_rate(params),
+				s3c2412_get_iisclk());
 
 	/* set codec DAI configuration */
 	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
@@ -145,8 +145,9 @@
 };
 
 /* jive audio machine driver */
-static struct snd_soc_machine snd_soc_machine_jive = {
+static struct snd_soc_card snd_soc_machine_jive = {
 	.name		= "Jive",
+	.platform	= &s3c24xx_soc_platform,
 	.dai_link	= &jive_dai,
 	.num_links	= 1,
 };
@@ -157,9 +158,8 @@
 
 /* jive audio subsystem */
 static struct snd_soc_device jive_snd_devdata = {
-	.machine	= &snd_soc_machine_jive,
-	.platform	= &s3c24xx_soc_platform,
-	.codec_dev	= &soc_codec_dev_wm8750_spi,
+	.card		= &snd_soc_machine_jive,
+	.codec_dev	= &soc_codec_dev_wm8750,
 	.codec_data	= &jive_wm8750_setup,
 };
 
diff -urN linux-2.6.30-rc2/sound/soc/s3c24xx/s3c-i2s-v2.c linux-2.6.30-rc3/sound/soc/s3c24xx/s3c-i2s-v2.c
--- linux-2.6.30-rc2/sound/soc/s3c24xx/s3c-i2s-v2.c	2009-04-22 03:29:12.521931413 +0000
+++ linux-2.6.30-rc3/sound/soc/s3c24xx/s3c-i2s-v2.c	2009-04-22 03:29:18.601931436 +0000
@@ -473,9 +473,9 @@
 /* default table of all avaialable root fs divisors */
 static unsigned int iis_fs_tab[] = { 256, 512, 384, 768 };
 
-int s3c2412_iis_calc_rate(struct s3c_i2sv2_rate_calc *info,
-			  unsigned int *fstab,
-			  unsigned int rate, struct clk *clk)
+int s3c_i2sv2_iis_calc_rate(struct s3c_i2sv2_rate_calc *info,
+			    unsigned int *fstab,
+			    unsigned int rate, struct clk *clk)
 {
 	unsigned long clkrate = clk_get_rate(clk);
 	unsigned int div;
@@ -531,7 +531,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(s3c2412_iis_calc_rate);
+EXPORT_SYMBOL_GPL(s3c_i2sv2_iis_calc_rate);
 
 int s3c_i2sv2_probe(struct platform_device *pdev,
 		    struct snd_soc_dai *dai,
@@ -624,10 +624,12 @@
 
 int s3c_i2sv2_register_dai(struct snd_soc_dai *dai)
 {
-	dai->ops.trigger = s3c2412_i2s_trigger;
-	dai->ops.hw_params = s3c2412_i2s_hw_params;
-	dai->ops.set_fmt = s3c2412_i2s_set_fmt;
-	dai->ops.set_clkdiv = s3c2412_i2s_set_clkdiv;
+	struct snd_soc_dai_ops *ops = dai->ops;
+
+	ops->trigger = s3c2412_i2s_trigger;
+	ops->hw_params = s3c2412_i2s_hw_params;
+	ops->set_fmt = s3c2412_i2s_set_fmt;
+	ops->set_clkdiv = s3c2412_i2s_set_clkdiv;
 
 	dai->suspend = s3c2412_i2s_suspend;
 	dai->resume = s3c2412_i2s_resume;
diff -urN linux-2.6.30-rc2/sound/soc/s3c24xx/s3c2412-i2s.c linux-2.6.30-rc3/sound/soc/s3c24xx/s3c2412-i2s.c
--- linux-2.6.30-rc2/sound/soc/s3c24xx/s3c2412-i2s.c	2009-04-22 03:29:12.522931386 +0000
+++ linux-2.6.30-rc3/sound/soc/s3c24xx/s3c2412-i2s.c	2009-04-22 03:29:18.601931436 +0000
@@ -33,8 +33,8 @@
 
 #include <plat/regs-s3c2412-iis.h>
 
-#include <plat/regs-gpio.h>
 #include <plat/audio.h>
+#include <mach/regs-gpio.h>
 #include <mach/dma.h>
 
 #include "s3c24xx-pcm.h"
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/Makefile linux-2.6.30-rc3/sound/usb/caiaq/Makefile
--- linux-2.6.30-rc2/sound/usb/caiaq/Makefile	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/Makefile	2009-04-22 03:29:18.607931486 +0000
@@ -1,4 +1,4 @@
-snd-usb-caiaq-y := caiaq-device.o caiaq-audio.o caiaq-midi.o caiaq-control.o
-snd-usb-caiaq-$(CONFIG_SND_USB_CAIAQ_INPUT) += caiaq-input.o
+snd-usb-caiaq-y := device.o audio.o midi.o control.o
+snd-usb-caiaq-$(CONFIG_SND_USB_CAIAQ_INPUT) += input.o
 
 obj-$(CONFIG_SND_USB_CAIAQ) += snd-usb-caiaq.o
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/audio.c linux-2.6.30-rc3/sound/usb/caiaq/audio.c
--- linux-2.6.30-rc2/sound/usb/caiaq/audio.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/audio.c	2009-04-22 03:29:18.607931486 +0000
@@ -0,0 +1,700 @@
+/*
+ *   Copyright (c) 2006-2008 Daniel Mack, Karsten Wiese
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+
+#include "device.h"
+#include "audio.h"
+
+#define N_URBS			32
+#define CLOCK_DRIFT_TOLERANCE	5
+#define FRAMES_PER_URB		8
+#define BYTES_PER_FRAME		512
+#define CHANNELS_PER_STREAM	2
+#define BYTES_PER_SAMPLE	3
+#define BYTES_PER_SAMPLE_USB	4
+#define MAX_BUFFER_SIZE		(128*1024)
+#define MAX_ENDPOINT_SIZE	512
+
+#define ENDPOINT_CAPTURE	2
+#define ENDPOINT_PLAYBACK	6
+
+#define MAKE_CHECKBYTE(dev,stream,i) \
+	(stream << 1) | (~(i / (dev->n_streams * BYTES_PER_SAMPLE_USB)) & 1)
+
+static struct snd_pcm_hardware snd_usb_caiaq_pcm_hardware = {
+	.info 		= (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | 
+			   SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats 	= SNDRV_PCM_FMTBIT_S24_3BE,
+	.rates 		= (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | 
+			   SNDRV_PCM_RATE_96000),
+	.rate_min	= 44100,
+	.rate_max	= 0, /* will overwrite later */
+	.channels_min	= CHANNELS_PER_STREAM,
+	.channels_max	= CHANNELS_PER_STREAM,
+	.buffer_bytes_max = MAX_BUFFER_SIZE,
+	.period_bytes_min = 128,
+	.period_bytes_max = MAX_BUFFER_SIZE,
+	.periods_min	= 1,
+	.periods_max	= 1024,
+};
+
+static void
+activate_substream(struct snd_usb_caiaqdev *dev,
+	           struct snd_pcm_substream *sub)
+{
+	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dev->sub_playback[sub->number] = sub;
+	else
+		dev->sub_capture[sub->number] = sub;
+}
+
+static void 
+deactivate_substream(struct snd_usb_caiaqdev *dev,
+		     struct snd_pcm_substream *sub)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dev->spinlock, flags);
+
+	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dev->sub_playback[sub->number] = NULL;
+	else
+		dev->sub_capture[sub->number] = NULL;
+
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+}
+
+static int
+all_substreams_zero(struct snd_pcm_substream **subs)
+{
+	int i;
+	for (i = 0; i < MAX_STREAMS; i++)
+		if (subs[i] != NULL)
+			return 0;
+	return 1;
+}
+
+static int stream_start(struct snd_usb_caiaqdev *dev)
+{
+	int i, ret;
+
+	debug("%s(%p)\n", __func__, dev);
+
+	if (dev->streaming)
+		return -EINVAL;
+
+	memset(dev->sub_playback, 0, sizeof(dev->sub_playback));
+	memset(dev->sub_capture, 0, sizeof(dev->sub_capture));
+	dev->input_panic = 0;
+	dev->output_panic = 0;
+	dev->first_packet = 1;
+	dev->streaming = 1;
+	dev->warned = 0;
+
+	for (i = 0; i < N_URBS; i++) {
+		ret = usb_submit_urb(dev->data_urbs_in[i], GFP_ATOMIC);
+		if (ret) {
+			log("unable to trigger read #%d! (ret %d)\n", i, ret);
+			dev->streaming = 0;
+			return -EPIPE;
+		}
+	}
+	
+	return 0;
+}
+
+static void stream_stop(struct snd_usb_caiaqdev *dev)
+{
+	int i;
+
+	debug("%s(%p)\n", __func__, dev);
+	if (!dev->streaming)
+		return;
+	
+	dev->streaming = 0;
+
+	for (i = 0; i < N_URBS; i++) {
+		usb_kill_urb(dev->data_urbs_in[i]);
+		usb_kill_urb(dev->data_urbs_out[i]);
+	}
+}
+
+static int snd_usb_caiaq_substream_open(struct snd_pcm_substream *substream)
+{
+	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);
+	debug("%s(%p)\n", __func__, substream);
+	substream->runtime->hw = dev->pcm_info;
+	snd_pcm_limit_hw_rates(substream->runtime);
+	return 0;
+}
+
+static int snd_usb_caiaq_substream_close(struct snd_pcm_substream *substream)
+{
+	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);
+
+	debug("%s(%p)\n", __func__, substream);
+	if (all_substreams_zero(dev->sub_playback) &&
+	    all_substreams_zero(dev->sub_capture)) {
+		/* when the last client has stopped streaming, 
+		 * all sample rates are allowed again */
+		stream_stop(dev);
+		dev->pcm_info.rates = dev->samplerates;
+	}
+
+	return 0;
+}
+
+static int snd_usb_caiaq_pcm_hw_params(struct snd_pcm_substream *sub,
+			     		struct snd_pcm_hw_params *hw_params)
+{
+	debug("%s(%p)\n", __func__, sub);
+	return snd_pcm_lib_malloc_pages(sub, params_buffer_bytes(hw_params));
+}
+
+static int snd_usb_caiaq_pcm_hw_free(struct snd_pcm_substream *sub)
+{
+	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);
+	debug("%s(%p)\n", __func__, sub);
+	deactivate_substream(dev, sub);
+	return snd_pcm_lib_free_pages(sub);
+}
+
+/* this should probably go upstream */
+#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_192000 != 1 << 12
+#error "Change this table"
+#endif
+
+static unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050, 32000, 44100,
+                                 48000, 64000, 88200, 96000, 176400, 192000 };
+
+static int snd_usb_caiaq_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	int bytes_per_sample, bpp, ret, i;
+	int index = substream->number;
+	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	debug("%s(%p)\n", __func__, substream);
+	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dev->audio_out_buf_pos[index] = BYTES_PER_SAMPLE + 1;
+	else
+		dev->audio_in_buf_pos[index] = BYTES_PER_SAMPLE;
+	
+	if (dev->streaming)
+		return 0;
+	
+	/* the first client that opens a stream defines the sample rate
+	 * setting for all subsequent calls, until the last client closed. */
+	for (i=0; i < ARRAY_SIZE(rates); i++)
+		if (runtime->rate == rates[i])
+			dev->pcm_info.rates = 1 << i;
+	
+	snd_pcm_limit_hw_rates(runtime);
+
+	bytes_per_sample = BYTES_PER_SAMPLE;
+	if (dev->spec.data_alignment == 2)
+		bytes_per_sample++;
+	
+	bpp = ((runtime->rate / 8000) + CLOCK_DRIFT_TOLERANCE)
+		* bytes_per_sample * CHANNELS_PER_STREAM * dev->n_streams;
+
+	if (bpp > MAX_ENDPOINT_SIZE)
+		bpp = MAX_ENDPOINT_SIZE;
+
+	ret = snd_usb_caiaq_set_audio_params(dev, runtime->rate,
+					     runtime->sample_bits, bpp);
+	if (ret)
+		return ret;
+
+	ret = stream_start(dev);
+	if (ret)
+		return ret;
+	
+	dev->output_running = 0;
+	wait_event_timeout(dev->prepare_wait_queue, dev->output_running, HZ);
+	if (!dev->output_running) {
+		stream_stop(dev);
+		return -EPIPE;
+	}
+
+	return 0;
+}
+
+static int snd_usb_caiaq_pcm_trigger(struct snd_pcm_substream *sub, int cmd)
+{
+	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		activate_substream(dev, sub);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		deactivate_substream(dev, sub);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t
+snd_usb_caiaq_pcm_pointer(struct snd_pcm_substream *sub)
+{
+	int index = sub->number;
+	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);
+
+	if (dev->input_panic || dev->output_panic)
+		return SNDRV_PCM_POS_XRUN;
+
+	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return bytes_to_frames(sub->runtime, 
+					dev->audio_out_buf_pos[index]);
+	else
+		return bytes_to_frames(sub->runtime,
+					dev->audio_in_buf_pos[index]);
+}
+
+/* operators for both playback and capture */
+static struct snd_pcm_ops snd_usb_caiaq_ops = {
+	.open =		snd_usb_caiaq_substream_open,
+	.close =	snd_usb_caiaq_substream_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_usb_caiaq_pcm_hw_params,
+	.hw_free =	snd_usb_caiaq_pcm_hw_free,
+	.prepare =	snd_usb_caiaq_pcm_prepare,
+	.trigger =	snd_usb_caiaq_pcm_trigger,
+	.pointer =	snd_usb_caiaq_pcm_pointer
+};
+	
+static void check_for_elapsed_periods(struct snd_usb_caiaqdev *dev,
+				      struct snd_pcm_substream **subs)
+{
+	int stream, pb, *cnt;
+	struct snd_pcm_substream *sub;
+
+	for (stream = 0; stream < dev->n_streams; stream++) {
+		sub = subs[stream];
+		if (!sub)
+			continue;
+
+		pb = frames_to_bytes(sub->runtime, 
+				     sub->runtime->period_size);
+		cnt = (sub->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+					&dev->period_out_count[stream] :
+					&dev->period_in_count[stream];
+
+		if (*cnt >= pb) {
+			snd_pcm_period_elapsed(sub);
+			*cnt %= pb;
+		}
+	}
+}
+
+static void read_in_urb_mode0(struct snd_usb_caiaqdev *dev,
+			      const struct urb *urb,
+			      const struct usb_iso_packet_descriptor *iso)
+{
+	unsigned char *usb_buf = urb->transfer_buffer + iso->offset;
+	struct snd_pcm_substream *sub;
+	int stream, i;
+
+	if (all_substreams_zero(dev->sub_capture))
+		return;
+
+	for (i = 0; i < iso->actual_length;) {
+		for (stream = 0; stream < dev->n_streams; stream++, i++) {
+			sub = dev->sub_capture[stream];
+			if (sub) {
+				struct snd_pcm_runtime *rt = sub->runtime;
+				char *audio_buf = rt->dma_area;
+				int sz = frames_to_bytes(rt, rt->buffer_size);
+				audio_buf[dev->audio_in_buf_pos[stream]++] 
+					= usb_buf[i];
+				dev->period_in_count[stream]++;
+				if (dev->audio_in_buf_pos[stream] == sz)
+					dev->audio_in_buf_pos[stream] = 0;
+			}
+		}
+	}
+}
+
+static void read_in_urb_mode2(struct snd_usb_caiaqdev *dev,
+			      const struct urb *urb,
+			      const struct usb_iso_packet_descriptor *iso)
+{
+	unsigned char *usb_buf = urb->transfer_buffer + iso->offset;
+	unsigned char check_byte;
+	struct snd_pcm_substream *sub;
+	int stream, i;
+
+	for (i = 0; i < iso->actual_length;) {
+		if (i % (dev->n_streams * BYTES_PER_SAMPLE_USB) == 0) {
+			for (stream = 0; 
+			     stream < dev->n_streams; 
+			     stream++, i++) {
+				if (dev->first_packet)
+					continue;
+
+				check_byte = MAKE_CHECKBYTE(dev, stream, i);
+				
+				if ((usb_buf[i] & 0x3f) != check_byte)
+					dev->input_panic = 1;
+
+				if (usb_buf[i] & 0x80)
+					dev->output_panic = 1;
+			}
+		}
+		dev->first_packet = 0;
+
+		for (stream = 0; stream < dev->n_streams; stream++, i++) {
+			sub = dev->sub_capture[stream];
+			if (dev->input_panic)
+				usb_buf[i] = 0;
+
+			if (sub) {
+				struct snd_pcm_runtime *rt = sub->runtime;
+				char *audio_buf = rt->dma_area;
+				int sz = frames_to_bytes(rt, rt->buffer_size);
+				audio_buf[dev->audio_in_buf_pos[stream]++] =
+					usb_buf[i];
+				dev->period_in_count[stream]++;
+				if (dev->audio_in_buf_pos[stream] == sz)
+					dev->audio_in_buf_pos[stream] = 0;
+			}
+		}
+	}
+}
+
+static void read_in_urb(struct snd_usb_caiaqdev *dev,
+			const struct urb *urb,
+			const struct usb_iso_packet_descriptor *iso)
+{
+	if (!dev->streaming)
+		return;
+
+	if (iso->actual_length < dev->bpp)
+		return;
+
+	switch (dev->spec.data_alignment) {
+	case 0:
+		read_in_urb_mode0(dev, urb, iso);
+		break;
+	case 2:
+		read_in_urb_mode2(dev, urb, iso);
+		break;
+	}
+
+	if ((dev->input_panic || dev->output_panic) && !dev->warned) {
+		debug("streaming error detected %s %s\n", 
+				dev->input_panic ? "(input)" : "",
+				dev->output_panic ? "(output)" : "");
+		dev->warned = 1;
+	}
+}
+
+static void fill_out_urb(struct snd_usb_caiaqdev *dev, 
+			 struct urb *urb, 
+			 const struct usb_iso_packet_descriptor *iso)
+{
+	unsigned char *usb_buf = urb->transfer_buffer + iso->offset;
+	struct snd_pcm_substream *sub;
+	int stream, i;
+	
+	for (i = 0; i < iso->length;) {
+		for (stream = 0; stream < dev->n_streams; stream++, i++) {
+			sub = dev->sub_playback[stream];
+			if (sub) {
+				struct snd_pcm_runtime *rt = sub->runtime;
+				char *audio_buf = rt->dma_area;
+				int sz = frames_to_bytes(rt, rt->buffer_size);
+				usb_buf[i] =
+					audio_buf[dev->audio_out_buf_pos[stream]];
+				dev->period_out_count[stream]++;
+				dev->audio_out_buf_pos[stream]++;
+				if (dev->audio_out_buf_pos[stream] == sz)
+					dev->audio_out_buf_pos[stream] = 0;
+			} else
+				usb_buf[i] = 0;
+		}
+
+		/* fill in the check bytes */
+		if (dev->spec.data_alignment == 2 &&
+		    i % (dev->n_streams * BYTES_PER_SAMPLE_USB) == 
+		    	(dev->n_streams * CHANNELS_PER_STREAM))
+		    for (stream = 0; stream < dev->n_streams; stream++, i++)
+		    	usb_buf[i] = MAKE_CHECKBYTE(dev, stream, i);
+	}
+}
+
+static void read_completed(struct urb *urb)
+{
+	struct snd_usb_caiaq_cb_info *info = urb->context; 
+	struct snd_usb_caiaqdev *dev;
+	struct urb *out;
+	int frame, len, send_it = 0, outframe = 0;
+
+	if (urb->status || !info)
+		return;
+
+	dev = info->dev;
+
+	if (!dev->streaming)
+		return;
+
+	out = dev->data_urbs_out[info->index];
+
+	/* read the recently received packet and send back one which has
+	 * the same layout */
+	for (frame = 0; frame < FRAMES_PER_URB; frame++) {
+		if (urb->iso_frame_desc[frame].status)
+			continue;
+
+		len = urb->iso_frame_desc[outframe].actual_length;
+		out->iso_frame_desc[outframe].length = len;
+		out->iso_frame_desc[outframe].actual_length = 0;
+		out->iso_frame_desc[outframe].offset = BYTES_PER_FRAME * frame;
+		
+		if (len > 0) {
+			spin_lock(&dev->spinlock);
+			fill_out_urb(dev, out, &out->iso_frame_desc[outframe]);
+			read_in_urb(dev, urb, &urb->iso_frame_desc[frame]);
+			spin_unlock(&dev->spinlock);
+			check_for_elapsed_periods(dev, dev->sub_playback);
+			check_for_elapsed_periods(dev, dev->sub_capture);
+			send_it = 1;
+		}
+
+		outframe++;
+	}
+
+	if (send_it) {
+		out->number_of_packets = FRAMES_PER_URB;
+		out->transfer_flags = URB_ISO_ASAP;
+		usb_submit_urb(out, GFP_ATOMIC);
+	}
+	
+	/* re-submit inbound urb */
+	for (frame = 0; frame < FRAMES_PER_URB; frame++) {
+		urb->iso_frame_desc[frame].offset = BYTES_PER_FRAME * frame;
+		urb->iso_frame_desc[frame].length = BYTES_PER_FRAME;
+		urb->iso_frame_desc[frame].actual_length = 0;
+	}
+	
+	urb->number_of_packets = FRAMES_PER_URB;
+	urb->transfer_flags = URB_ISO_ASAP;
+	usb_submit_urb(urb, GFP_ATOMIC);
+}
+
+static void write_completed(struct urb *urb)
+{
+	struct snd_usb_caiaq_cb_info *info = urb->context;
+	struct snd_usb_caiaqdev *dev = info->dev;
+
+	if (!dev->output_running) {
+		dev->output_running = 1;
+		wake_up(&dev->prepare_wait_queue);
+	}
+}
+
+static struct urb **alloc_urbs(struct snd_usb_caiaqdev *dev, int dir, int *ret)
+{
+	int i, frame;
+	struct urb **urbs;
+	struct usb_device *usb_dev = dev->chip.dev;
+	unsigned int pipe;
+
+	pipe = (dir == SNDRV_PCM_STREAM_PLAYBACK) ? 
+		usb_sndisocpipe(usb_dev, ENDPOINT_PLAYBACK) :
+		usb_rcvisocpipe(usb_dev, ENDPOINT_CAPTURE);
+
+	urbs = kmalloc(N_URBS * sizeof(*urbs), GFP_KERNEL);
+	if (!urbs) {
+		log("unable to kmalloc() urbs, OOM!?\n");
+		*ret = -ENOMEM;
+		return NULL;
+	}
+
+	for (i = 0; i < N_URBS; i++) {
+		urbs[i] = usb_alloc_urb(FRAMES_PER_URB, GFP_KERNEL);
+		if (!urbs[i]) {
+			log("unable to usb_alloc_urb(), OOM!?\n");
+			*ret = -ENOMEM;
+			return urbs;
+		}
+
+		urbs[i]->transfer_buffer = 
+			kmalloc(FRAMES_PER_URB * BYTES_PER_FRAME, GFP_KERNEL);
+		if (!urbs[i]->transfer_buffer) {
+			log("unable to kmalloc() transfer buffer, OOM!?\n");
+			*ret = -ENOMEM;
+			return urbs;
+		}
+		
+		for (frame = 0; frame < FRAMES_PER_URB; frame++) {
+			struct usb_iso_packet_descriptor *iso = 
+				&urbs[i]->iso_frame_desc[frame];
+			
+			iso->offset = BYTES_PER_FRAME * frame;
+			iso->length = BYTES_PER_FRAME;
+		}
+		
+		urbs[i]->dev = usb_dev;
+		urbs[i]->pipe = pipe;
+		urbs[i]->transfer_buffer_length = FRAMES_PER_URB 
+						* BYTES_PER_FRAME;
+		urbs[i]->context = &dev->data_cb_info[i];
+		urbs[i]->interval = 1;
+		urbs[i]->transfer_flags = URB_ISO_ASAP;
+		urbs[i]->number_of_packets = FRAMES_PER_URB;
+		urbs[i]->complete = (dir == SNDRV_PCM_STREAM_CAPTURE) ?
+					read_completed : write_completed;
+	}
+
+	*ret = 0;
+	return urbs;
+}
+
+static void free_urbs(struct urb **urbs)
+{
+	int i;
+
+	if (!urbs)
+		return;
+
+	for (i = 0; i < N_URBS; i++) {
+		if (!urbs[i])
+			continue;
+		
+		usb_kill_urb(urbs[i]);
+		kfree(urbs[i]->transfer_buffer);
+		usb_free_urb(urbs[i]);
+	}
+
+	kfree(urbs);
+}
+
+int snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *dev)
+{
+	int i, ret;
+
+	dev->n_audio_in  = max(dev->spec.num_analog_audio_in, 
+			       dev->spec.num_digital_audio_in) / 
+				CHANNELS_PER_STREAM;
+	dev->n_audio_out = max(dev->spec.num_analog_audio_out,
+			       dev->spec.num_digital_audio_out) / 
+				CHANNELS_PER_STREAM;
+	dev->n_streams = max(dev->n_audio_in, dev->n_audio_out);
+
+	debug("dev->n_audio_in = %d\n", dev->n_audio_in);
+	debug("dev->n_audio_out = %d\n", dev->n_audio_out);
+	debug("dev->n_streams = %d\n", dev->n_streams);
+
+	if (dev->n_streams > MAX_STREAMS) {
+		log("unable to initialize device, too many streams.\n");
+		return -EINVAL;
+	}
+
+	ret = snd_pcm_new(dev->chip.card, dev->product_name, 0, 
+			dev->n_audio_out, dev->n_audio_in, &dev->pcm);
+
+	if (ret < 0) {
+		log("snd_pcm_new() returned %d\n", ret);
+		return ret;
+	}
+
+	dev->pcm->private_data = dev;
+	strcpy(dev->pcm->name, dev->product_name);
+
+	memset(dev->sub_playback, 0, sizeof(dev->sub_playback));
+	memset(dev->sub_capture, 0, sizeof(dev->sub_capture));
+	
+	memcpy(&dev->pcm_info, &snd_usb_caiaq_pcm_hardware,
+			sizeof(snd_usb_caiaq_pcm_hardware));
+
+	/* setup samplerates */
+	dev->samplerates = dev->pcm_info.rates;
+	switch (dev->chip.usb_id) {
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_SESSIONIO):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_GUITARRIGMOBILE):
+		dev->samplerates |= SNDRV_PCM_RATE_192000;
+		/* fall thru */
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):
+		dev->samplerates |= SNDRV_PCM_RATE_88200;
+		break;
+	}
+
+	snd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK, 
+				&snd_usb_caiaq_ops);
+	snd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_CAPTURE, 
+				&snd_usb_caiaq_ops);
+
+	snd_pcm_lib_preallocate_pages_for_all(dev->pcm,
+					SNDRV_DMA_TYPE_CONTINUOUS,
+					snd_dma_continuous_data(GFP_KERNEL),
+					MAX_BUFFER_SIZE, MAX_BUFFER_SIZE);
+
+	dev->data_cb_info =
+		kmalloc(sizeof(struct snd_usb_caiaq_cb_info) * N_URBS, 
+					GFP_KERNEL);
+
+	if (!dev->data_cb_info)
+		return -ENOMEM;
+
+	for (i = 0; i < N_URBS; i++) {
+		dev->data_cb_info[i].dev = dev;
+		dev->data_cb_info[i].index = i;
+	}
+	
+	dev->data_urbs_in = alloc_urbs(dev, SNDRV_PCM_STREAM_CAPTURE, &ret);
+	if (ret < 0) {
+		kfree(dev->data_cb_info);
+		free_urbs(dev->data_urbs_in);
+		return ret;
+	}
+	
+	dev->data_urbs_out = alloc_urbs(dev, SNDRV_PCM_STREAM_PLAYBACK, &ret);
+	if (ret < 0) {
+		kfree(dev->data_cb_info);
+		free_urbs(dev->data_urbs_in);
+		free_urbs(dev->data_urbs_out);
+		return ret;
+	}
+
+	return 0;
+}
+
+void snd_usb_caiaq_audio_free(struct snd_usb_caiaqdev *dev)
+{
+	debug("%s(%p)\n", __func__, dev);
+	stream_stop(dev);
+	free_urbs(dev->data_urbs_in);
+	free_urbs(dev->data_urbs_out);
+	kfree(dev->data_cb_info);
+}
+
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/audio.h linux-2.6.30-rc3/sound/usb/caiaq/audio.h
--- linux-2.6.30-rc2/sound/usb/caiaq/audio.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/audio.h	2009-04-22 03:29:18.607931486 +0000
@@ -0,0 +1,7 @@
+#ifndef CAIAQ_AUDIO_H
+#define CAIAQ_AUDIO_H
+
+int snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *dev);
+void snd_usb_caiaq_audio_free(struct snd_usb_caiaqdev *dev);
+
+#endif /* CAIAQ_AUDIO_H */
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-audio.c linux-2.6.30-rc3/sound/usb/caiaq/caiaq-audio.c
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-audio.c	2009-04-22 03:29:12.528556574 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-audio.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,706 +0,0 @@
-/*
- *   Copyright (c) 2006-2008 Daniel Mack, Karsten Wiese
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/interrupt.h>
-#include <linux/usb.h>
-#include <linux/spinlock.h>
-#include <sound/core.h>
-#include <sound/initval.h>
-#include <sound/pcm.h>
-#include <sound/rawmidi.h>
-#include <linux/input.h>
-
-#include "caiaq-device.h"
-#include "caiaq-audio.h"
-
-#define N_URBS			32
-#define CLOCK_DRIFT_TOLERANCE	5
-#define FRAMES_PER_URB		8
-#define BYTES_PER_FRAME		512
-#define CHANNELS_PER_STREAM	2
-#define BYTES_PER_SAMPLE	3
-#define BYTES_PER_SAMPLE_USB	4
-#define MAX_BUFFER_SIZE		(128*1024)
-#define MAX_ENDPOINT_SIZE	512
-
-#define ENDPOINT_CAPTURE	2
-#define ENDPOINT_PLAYBACK	6
-
-#define MAKE_CHECKBYTE(dev,stream,i) \
-	(stream << 1) | (~(i / (dev->n_streams * BYTES_PER_SAMPLE_USB)) & 1)
-
-static struct snd_pcm_hardware snd_usb_caiaq_pcm_hardware = {
-	.info 		= (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | 
-			   SNDRV_PCM_INFO_BLOCK_TRANSFER),
-	.formats 	= SNDRV_PCM_FMTBIT_S24_3BE,
-	.rates 		= (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | 
-			   SNDRV_PCM_RATE_96000),
-	.rate_min	= 44100,
-	.rate_max	= 0, /* will overwrite later */
-	.channels_min	= CHANNELS_PER_STREAM,
-	.channels_max	= CHANNELS_PER_STREAM,
-	.buffer_bytes_max = MAX_BUFFER_SIZE,
-	.period_bytes_min = 128,
-	.period_bytes_max = MAX_BUFFER_SIZE,
-	.periods_min	= 1,
-	.periods_max	= 1024,
-};
-
-static void
-activate_substream(struct snd_usb_caiaqdev *dev,
-	           struct snd_pcm_substream *sub)
-{
-	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		dev->sub_playback[sub->number] = sub;
-	else
-		dev->sub_capture[sub->number] = sub;
-}
-
-static void 
-deactivate_substream(struct snd_usb_caiaqdev *dev,
-		     struct snd_pcm_substream *sub)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&dev->spinlock, flags);
-
-	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		dev->sub_playback[sub->number] = NULL;
-	else
-		dev->sub_capture[sub->number] = NULL;
-
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-}
-
-static int
-all_substreams_zero(struct snd_pcm_substream **subs)
-{
-	int i;
-	for (i = 0; i < MAX_STREAMS; i++)
-		if (subs[i] != NULL)
-			return 0;
-	return 1;
-}
-
-static int stream_start(struct snd_usb_caiaqdev *dev)
-{
-	int i, ret;
-
-	debug("%s(%p)\n", __func__, dev);
-
-	if (dev->streaming)
-		return -EINVAL;
-
-	memset(dev->sub_playback, 0, sizeof(dev->sub_playback));
-	memset(dev->sub_capture, 0, sizeof(dev->sub_capture));
-	dev->input_panic = 0;
-	dev->output_panic = 0;
-	dev->first_packet = 1;
-	dev->streaming = 1;
-	dev->warned = 0;
-
-	for (i = 0; i < N_URBS; i++) {
-		ret = usb_submit_urb(dev->data_urbs_in[i], GFP_ATOMIC);
-		if (ret) {
-			log("unable to trigger read #%d! (ret %d)\n", i, ret);
-			dev->streaming = 0;
-			return -EPIPE;
-		}
-	}
-	
-	return 0;
-}
-
-static void stream_stop(struct snd_usb_caiaqdev *dev)
-{
-	int i;
-
-	debug("%s(%p)\n", __func__, dev);
-	if (!dev->streaming)
-		return;
-	
-	dev->streaming = 0;
-
-	for (i = 0; i < N_URBS; i++) {
-		usb_kill_urb(dev->data_urbs_in[i]);
-		usb_kill_urb(dev->data_urbs_out[i]);
-	}
-}
-
-static int snd_usb_caiaq_substream_open(struct snd_pcm_substream *substream)
-{
-	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);
-	debug("%s(%p)\n", __func__, substream);
-	substream->runtime->hw = dev->pcm_info;
-	snd_pcm_limit_hw_rates(substream->runtime);
-	return 0;
-}
-
-static int snd_usb_caiaq_substream_close(struct snd_pcm_substream *substream)
-{
-	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);
-
-	debug("%s(%p)\n", __func__, substream);
-	if (all_substreams_zero(dev->sub_playback) &&
-	    all_substreams_zero(dev->sub_capture)) {
-		/* when the last client has stopped streaming, 
-		 * all sample rates are allowed again */
-		stream_stop(dev);
-		dev->pcm_info.rates = dev->samplerates;
-	}
-
-	return 0;
-}
-
-static int snd_usb_caiaq_pcm_hw_params(struct snd_pcm_substream *sub,
-			     		struct snd_pcm_hw_params *hw_params)
-{
-	debug("%s(%p)\n", __func__, sub);
-	return snd_pcm_lib_malloc_pages(sub, params_buffer_bytes(hw_params));
-}
-
-static int snd_usb_caiaq_pcm_hw_free(struct snd_pcm_substream *sub)
-{
-	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);
-	debug("%s(%p)\n", __func__, sub);
-	deactivate_substream(dev, sub);
-	return snd_pcm_lib_free_pages(sub);
-}
-
-/* this should probably go upstream */
-#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_192000 != 1 << 12
-#error "Change this table"
-#endif
-
-static unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050, 32000, 44100,
-                                 48000, 64000, 88200, 96000, 176400, 192000 };
-
-static int snd_usb_caiaq_pcm_prepare(struct snd_pcm_substream *substream)
-{
-	int bytes_per_sample, bpp, ret, i;
-	int index = substream->number;
-	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	debug("%s(%p)\n", __func__, substream);
-	
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		dev->audio_out_buf_pos[index] = BYTES_PER_SAMPLE + 1;
-	else
-		dev->audio_in_buf_pos[index] = BYTES_PER_SAMPLE;
-	
-	if (dev->streaming)
-		return 0;
-	
-	/* the first client that opens a stream defines the sample rate
-	 * setting for all subsequent calls, until the last client closed. */
-	for (i=0; i < ARRAY_SIZE(rates); i++)
-		if (runtime->rate == rates[i])
-			dev->pcm_info.rates = 1 << i;
-	
-	snd_pcm_limit_hw_rates(runtime);
-
-	bytes_per_sample = BYTES_PER_SAMPLE;
-	if (dev->spec.data_alignment == 2)
-		bytes_per_sample++;
-	
-	bpp = ((runtime->rate / 8000) + CLOCK_DRIFT_TOLERANCE)
-		* bytes_per_sample * CHANNELS_PER_STREAM * dev->n_streams;
-
-	if (bpp > MAX_ENDPOINT_SIZE)
-		bpp = MAX_ENDPOINT_SIZE;
-
-	ret = snd_usb_caiaq_set_audio_params(dev, runtime->rate,
-					     runtime->sample_bits, bpp);
-	if (ret)
-		return ret;
-
-	ret = stream_start(dev);
-	if (ret)
-		return ret;
-	
-	dev->output_running = 0;
-	wait_event_timeout(dev->prepare_wait_queue, dev->output_running, HZ);
-	if (!dev->output_running) {
-		stream_stop(dev);
-		return -EPIPE;
-	}
-
-	return 0;
-}
-
-static int snd_usb_caiaq_pcm_trigger(struct snd_pcm_substream *sub, int cmd)
-{
-	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		activate_substream(dev, sub);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		deactivate_substream(dev, sub);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static snd_pcm_uframes_t
-snd_usb_caiaq_pcm_pointer(struct snd_pcm_substream *sub)
-{
-	int index = sub->number;
-	struct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);
-
-	if (dev->input_panic || dev->output_panic)
-		return SNDRV_PCM_POS_XRUN;
-
-	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		return bytes_to_frames(sub->runtime, 
-					dev->audio_out_buf_pos[index]);
-	else
-		return bytes_to_frames(sub->runtime,
-					dev->audio_in_buf_pos[index]);
-}
-
-/* operators for both playback and capture */
-static struct snd_pcm_ops snd_usb_caiaq_ops = {
-	.open =		snd_usb_caiaq_substream_open,
-	.close =	snd_usb_caiaq_substream_close,
-	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_usb_caiaq_pcm_hw_params,
-	.hw_free =	snd_usb_caiaq_pcm_hw_free,
-	.prepare =	snd_usb_caiaq_pcm_prepare,
-	.trigger =	snd_usb_caiaq_pcm_trigger,
-	.pointer =	snd_usb_caiaq_pcm_pointer
-};
-	
-static void check_for_elapsed_periods(struct snd_usb_caiaqdev *dev,
-				      struct snd_pcm_substream **subs)
-{
-	int stream, pb, *cnt;
-	struct snd_pcm_substream *sub;
-
-	for (stream = 0; stream < dev->n_streams; stream++) {
-		sub = subs[stream];
-		if (!sub)
-			continue;
-
-		pb = frames_to_bytes(sub->runtime, 
-				     sub->runtime->period_size);
-		cnt = (sub->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
-					&dev->period_out_count[stream] :
-					&dev->period_in_count[stream];
-
-		if (*cnt >= pb) {
-			snd_pcm_period_elapsed(sub);
-			*cnt %= pb;
-		}
-	}
-}
-
-static void read_in_urb_mode0(struct snd_usb_caiaqdev *dev,
-			      const struct urb *urb,
-			      const struct usb_iso_packet_descriptor *iso)
-{
-	unsigned char *usb_buf = urb->transfer_buffer + iso->offset;
-	struct snd_pcm_substream *sub;
-	int stream, i;
-
-	if (all_substreams_zero(dev->sub_capture))
-		return;
-
-	for (i = 0; i < iso->actual_length;) {
-		for (stream = 0; stream < dev->n_streams; stream++, i++) {
-			sub = dev->sub_capture[stream];
-			if (sub) {
-				struct snd_pcm_runtime *rt = sub->runtime;
-				char *audio_buf = rt->dma_area;
-				int sz = frames_to_bytes(rt, rt->buffer_size);
-				audio_buf[dev->audio_in_buf_pos[stream]++] 
-					= usb_buf[i];
-				dev->period_in_count[stream]++;
-				if (dev->audio_in_buf_pos[stream] == sz)
-					dev->audio_in_buf_pos[stream] = 0;
-			}
-		}
-	}
-}
-
-static void read_in_urb_mode2(struct snd_usb_caiaqdev *dev,
-			      const struct urb *urb,
-			      const struct usb_iso_packet_descriptor *iso)
-{
-	unsigned char *usb_buf = urb->transfer_buffer + iso->offset;
-	unsigned char check_byte;
-	struct snd_pcm_substream *sub;
-	int stream, i;
-
-	for (i = 0; i < iso->actual_length;) {
-		if (i % (dev->n_streams * BYTES_PER_SAMPLE_USB) == 0) {
-			for (stream = 0; 
-			     stream < dev->n_streams; 
-			     stream++, i++) {
-				if (dev->first_packet)
-					continue;
-
-				check_byte = MAKE_CHECKBYTE(dev, stream, i);
-				
-				if ((usb_buf[i] & 0x3f) != check_byte)
-					dev->input_panic = 1;
-
-				if (usb_buf[i] & 0x80)
-					dev->output_panic = 1;
-			}
-		}
-		dev->first_packet = 0;
-
-		for (stream = 0; stream < dev->n_streams; stream++, i++) {
-			sub = dev->sub_capture[stream];
-			if (dev->input_panic)
-				usb_buf[i] = 0;
-
-			if (sub) {
-				struct snd_pcm_runtime *rt = sub->runtime;
-				char *audio_buf = rt->dma_area;
-				int sz = frames_to_bytes(rt, rt->buffer_size);
-				audio_buf[dev->audio_in_buf_pos[stream]++] =
-					usb_buf[i];
-				dev->period_in_count[stream]++;
-				if (dev->audio_in_buf_pos[stream] == sz)
-					dev->audio_in_buf_pos[stream] = 0;
-			}
-		}
-	}
-}
-
-static void read_in_urb(struct snd_usb_caiaqdev *dev,
-			const struct urb *urb,
-			const struct usb_iso_packet_descriptor *iso)
-{
-	if (!dev->streaming)
-		return;
-
-	if (iso->actual_length < dev->bpp)
-		return;
-
-	switch (dev->spec.data_alignment) {
-	case 0:
-		read_in_urb_mode0(dev, urb, iso);
-		break;
-	case 2:
-		read_in_urb_mode2(dev, urb, iso);
-		break;
-	}
-
-	if ((dev->input_panic || dev->output_panic) && !dev->warned) {
-		debug("streaming error detected %s %s\n", 
-				dev->input_panic ? "(input)" : "",
-				dev->output_panic ? "(output)" : "");
-		dev->warned = 1;
-	}
-}
-
-static void fill_out_urb(struct snd_usb_caiaqdev *dev, 
-			 struct urb *urb, 
-			 const struct usb_iso_packet_descriptor *iso)
-{
-	unsigned char *usb_buf = urb->transfer_buffer + iso->offset;
-	struct snd_pcm_substream *sub;
-	int stream, i;
-	
-	for (i = 0; i < iso->length;) {
-		for (stream = 0; stream < dev->n_streams; stream++, i++) {
-			sub = dev->sub_playback[stream];
-			if (sub) {
-				struct snd_pcm_runtime *rt = sub->runtime;
-				char *audio_buf = rt->dma_area;
-				int sz = frames_to_bytes(rt, rt->buffer_size);
-				usb_buf[i] =
-					audio_buf[dev->audio_out_buf_pos[stream]];
-				dev->period_out_count[stream]++;
-				dev->audio_out_buf_pos[stream]++;
-				if (dev->audio_out_buf_pos[stream] == sz)
-					dev->audio_out_buf_pos[stream] = 0;
-			} else
-				usb_buf[i] = 0;
-		}
-
-		/* fill in the check bytes */
-		if (dev->spec.data_alignment == 2 &&
-		    i % (dev->n_streams * BYTES_PER_SAMPLE_USB) == 
-		    	(dev->n_streams * CHANNELS_PER_STREAM))
-		    for (stream = 0; stream < dev->n_streams; stream++, i++)
-		    	usb_buf[i] = MAKE_CHECKBYTE(dev, stream, i);
-	}
-}
-
-static void read_completed(struct urb *urb)
-{
-	struct snd_usb_caiaq_cb_info *info = urb->context; 
-	struct snd_usb_caiaqdev *dev;
-	struct urb *out;
-	int frame, len, send_it = 0, outframe = 0;
-
-	if (urb->status || !info)
-		return;
-
-	dev = info->dev;
-
-	if (!dev->streaming)
-		return;
-
-	out = dev->data_urbs_out[info->index];
-
-	/* read the recently received packet and send back one which has
-	 * the same layout */
-	for (frame = 0; frame < FRAMES_PER_URB; frame++) {
-		if (urb->iso_frame_desc[frame].status)
-			continue;
-
-		len = urb->iso_frame_desc[outframe].actual_length;
-		out->iso_frame_desc[outframe].length = len;
-		out->iso_frame_desc[outframe].actual_length = 0;
-		out->iso_frame_desc[outframe].offset = BYTES_PER_FRAME * frame;
-		
-		if (len > 0) {
-			spin_lock(&dev->spinlock);
-			fill_out_urb(dev, out, &out->iso_frame_desc[outframe]);
-			read_in_urb(dev, urb, &urb->iso_frame_desc[frame]);
-			spin_unlock(&dev->spinlock);
-			check_for_elapsed_periods(dev, dev->sub_playback);
-			check_for_elapsed_periods(dev, dev->sub_capture);
-			send_it = 1;
-		}
-
-		outframe++;
-	}
-
-	if (send_it) {
-		out->number_of_packets = FRAMES_PER_URB;
-		out->transfer_flags = URB_ISO_ASAP;
-		usb_submit_urb(out, GFP_ATOMIC);
-	}
-	
-	/* re-submit inbound urb */
-	for (frame = 0; frame < FRAMES_PER_URB; frame++) {
-		urb->iso_frame_desc[frame].offset = BYTES_PER_FRAME * frame;
-		urb->iso_frame_desc[frame].length = BYTES_PER_FRAME;
-		urb->iso_frame_desc[frame].actual_length = 0;
-	}
-	
-	urb->number_of_packets = FRAMES_PER_URB;
-	urb->transfer_flags = URB_ISO_ASAP;
-	usb_submit_urb(urb, GFP_ATOMIC);
-}
-
-static void write_completed(struct urb *urb)
-{
-	struct snd_usb_caiaq_cb_info *info = urb->context;
-	struct snd_usb_caiaqdev *dev = info->dev;
-
-	if (!dev->output_running) {
-		dev->output_running = 1;
-		wake_up(&dev->prepare_wait_queue);
-	}
-}
-
-static struct urb **alloc_urbs(struct snd_usb_caiaqdev *dev, int dir, int *ret)
-{
-	int i, frame;
-	struct urb **urbs;
-	struct usb_device *usb_dev = dev->chip.dev;
-	unsigned int pipe;
-
-	pipe = (dir == SNDRV_PCM_STREAM_PLAYBACK) ? 
-		usb_sndisocpipe(usb_dev, ENDPOINT_PLAYBACK) :
-		usb_rcvisocpipe(usb_dev, ENDPOINT_CAPTURE);
-
-	urbs = kmalloc(N_URBS * sizeof(*urbs), GFP_KERNEL);
-	if (!urbs) {
-		log("unable to kmalloc() urbs, OOM!?\n");
-		*ret = -ENOMEM;
-		return NULL;
-	}
-
-	for (i = 0; i < N_URBS; i++) {
-		urbs[i] = usb_alloc_urb(FRAMES_PER_URB, GFP_KERNEL);
-		if (!urbs[i]) {
-			log("unable to usb_alloc_urb(), OOM!?\n");
-			*ret = -ENOMEM;
-			return urbs;
-		}
-
-		urbs[i]->transfer_buffer = 
-			kmalloc(FRAMES_PER_URB * BYTES_PER_FRAME, GFP_KERNEL);
-		if (!urbs[i]->transfer_buffer) {
-			log("unable to kmalloc() transfer buffer, OOM!?\n");
-			*ret = -ENOMEM;
-			return urbs;
-		}
-		
-		for (frame = 0; frame < FRAMES_PER_URB; frame++) {
-			struct usb_iso_packet_descriptor *iso = 
-				&urbs[i]->iso_frame_desc[frame];
-			
-			iso->offset = BYTES_PER_FRAME * frame;
-			iso->length = BYTES_PER_FRAME;
-		}
-		
-		urbs[i]->dev = usb_dev;
-		urbs[i]->pipe = pipe;
-		urbs[i]->transfer_buffer_length = FRAMES_PER_URB 
-						* BYTES_PER_FRAME;
-		urbs[i]->context = &dev->data_cb_info[i];
-		urbs[i]->interval = 1;
-		urbs[i]->transfer_flags = URB_ISO_ASAP;
-		urbs[i]->number_of_packets = FRAMES_PER_URB;
-		urbs[i]->complete = (dir == SNDRV_PCM_STREAM_CAPTURE) ?
-					read_completed : write_completed;
-	}
-
-	*ret = 0;
-	return urbs;
-}
-
-static void free_urbs(struct urb **urbs)
-{
-	int i;
-
-	if (!urbs)
-		return;
-
-	for (i = 0; i < N_URBS; i++) {
-		if (!urbs[i])
-			continue;
-		
-		usb_kill_urb(urbs[i]);
-		kfree(urbs[i]->transfer_buffer);
-		usb_free_urb(urbs[i]);
-	}
-
-	kfree(urbs);
-}
-
-int snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *dev)
-{
-	int i, ret;
-
-	dev->n_audio_in  = max(dev->spec.num_analog_audio_in, 
-			       dev->spec.num_digital_audio_in) / 
-				CHANNELS_PER_STREAM;
-	dev->n_audio_out = max(dev->spec.num_analog_audio_out,
-			       dev->spec.num_digital_audio_out) / 
-				CHANNELS_PER_STREAM;
-	dev->n_streams = max(dev->n_audio_in, dev->n_audio_out);
-
-	debug("dev->n_audio_in = %d\n", dev->n_audio_in);
-	debug("dev->n_audio_out = %d\n", dev->n_audio_out);
-	debug("dev->n_streams = %d\n", dev->n_streams);
-
-	if (dev->n_streams > MAX_STREAMS) {
-		log("unable to initialize device, too many streams.\n");
-		return -EINVAL;
-	}
-
-	ret = snd_pcm_new(dev->chip.card, dev->product_name, 0, 
-			dev->n_audio_out, dev->n_audio_in, &dev->pcm);
-
-	if (ret < 0) {
-		log("snd_pcm_new() returned %d\n", ret);
-		return ret;
-	}
-
-	dev->pcm->private_data = dev;
-	strcpy(dev->pcm->name, dev->product_name);
-
-	memset(dev->sub_playback, 0, sizeof(dev->sub_playback));
-	memset(dev->sub_capture, 0, sizeof(dev->sub_capture));
-	
-	memcpy(&dev->pcm_info, &snd_usb_caiaq_pcm_hardware,
-			sizeof(snd_usb_caiaq_pcm_hardware));
-
-	/* setup samplerates */
-	dev->samplerates = dev->pcm_info.rates;
-	switch (dev->chip.usb_id) {
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_SESSIONIO):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_GUITARRIGMOBILE):
-		dev->samplerates |= SNDRV_PCM_RATE_192000;
-		/* fall thru */
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):
-		dev->samplerates |= SNDRV_PCM_RATE_88200;
-		break;
-	}
-
-	snd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK, 
-				&snd_usb_caiaq_ops);
-	snd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_CAPTURE, 
-				&snd_usb_caiaq_ops);
-
-	snd_pcm_lib_preallocate_pages_for_all(dev->pcm,
-					SNDRV_DMA_TYPE_CONTINUOUS,
-					snd_dma_continuous_data(GFP_KERNEL),
-					MAX_BUFFER_SIZE, MAX_BUFFER_SIZE);
-
-	dev->data_cb_info =
-		kmalloc(sizeof(struct snd_usb_caiaq_cb_info) * N_URBS, 
-					GFP_KERNEL);
-
-	if (!dev->data_cb_info)
-		return -ENOMEM;
-
-	for (i = 0; i < N_URBS; i++) {
-		dev->data_cb_info[i].dev = dev;
-		dev->data_cb_info[i].index = i;
-	}
-	
-	dev->data_urbs_in = alloc_urbs(dev, SNDRV_PCM_STREAM_CAPTURE, &ret);
-	if (ret < 0) {
-		kfree(dev->data_cb_info);
-		free_urbs(dev->data_urbs_in);
-		return ret;
-	}
-	
-	dev->data_urbs_out = alloc_urbs(dev, SNDRV_PCM_STREAM_PLAYBACK, &ret);
-	if (ret < 0) {
-		kfree(dev->data_cb_info);
-		free_urbs(dev->data_urbs_in);
-		free_urbs(dev->data_urbs_out);
-		return ret;
-	}
-
-	return 0;
-}
-
-void snd_usb_caiaq_audio_free(struct snd_usb_caiaqdev *dev)
-{
-	debug("%s(%p)\n", __func__, dev);
-	stream_stop(dev);
-	free_urbs(dev->data_urbs_in);
-	free_urbs(dev->data_urbs_out);
-	kfree(dev->data_cb_info);
-}
-
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-audio.h linux-2.6.30-rc3/sound/usb/caiaq/caiaq-audio.h
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-audio.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-audio.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-#ifndef CAIAQ_AUDIO_H
-#define CAIAQ_AUDIO_H
-
-int snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *dev);
-void snd_usb_caiaq_audio_free(struct snd_usb_caiaqdev *dev);
-
-#endif /* CAIAQ_AUDIO_H */
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-control.c linux-2.6.30-rc3/sound/usb/caiaq/caiaq-control.c
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-control.c	2009-04-22 03:29:12.528556574 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-control.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,336 +0,0 @@
-/*
- *   Copyright (c) 2007 Daniel Mack
- *   friendly supported by NI.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/usb.h>
-#include <sound/core.h>
-#include <sound/initval.h>
-#include <sound/pcm.h>
-#include <sound/rawmidi.h>
-#include <sound/control.h>
-#include <linux/input.h>
-
-#include "caiaq-device.h"
-#include "caiaq-control.h"
-
-#define CNT_INTVAL 0x10000
-
-static int control_info(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_info *uinfo)
-{
-	struct snd_usb_audio *chip = snd_kcontrol_chip(kcontrol);
-	struct snd_usb_caiaqdev *dev = caiaqdev(chip->card);
-	int pos = kcontrol->private_value;
-	int is_intval = pos & CNT_INTVAL;
-	unsigned int id = dev->chip.usb_id;
-
-	uinfo->count = 1;
-	pos &= ~CNT_INTVAL;
-
-	if (id == USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ)
-		&& (pos == 0)) {
-		/* current input mode of A8DJ */
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->value.integer.min = 0;
-		uinfo->value.integer.max = 2;
-		return 0;
-	}
-
-	if (id == USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ)
-		&& (pos == 0)) {
-		/* current input mode of A4DJ */
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->value.integer.min = 0;
-		uinfo->value.integer.max = 1;
-		return 0;
-	}
-
-	if (is_intval) {
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->value.integer.min = 0;
-		uinfo->value.integer.max = 64;
-	} else {
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-		uinfo->value.integer.min = 0;
-		uinfo->value.integer.max = 1;
-	}
-
-	return 0;
-}
-
-static int control_get(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_usb_audio *chip = snd_kcontrol_chip(kcontrol);
-	struct snd_usb_caiaqdev *dev = caiaqdev(chip->card);
-	int pos = kcontrol->private_value;
-
-	if (dev->chip.usb_id ==
-		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ)) {
-		/* A4DJ has only one control */
-		/* do not expose hardware input mode 0 */
-		ucontrol->value.integer.value[0] = dev->control_state[0] - 1;
-		return 0;
-	}
-
-	if (pos & CNT_INTVAL)
-		ucontrol->value.integer.value[0]
-			= dev->control_state[pos & ~CNT_INTVAL];
-	else
-		ucontrol->value.integer.value[0]
-			= !!(dev->control_state[pos / 8] & (1 << pos % 8));
-
-	return 0;
-}
-
-static int control_put(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_usb_audio *chip = snd_kcontrol_chip(kcontrol);
-	struct snd_usb_caiaqdev *dev = caiaqdev(chip->card);
-	int pos = kcontrol->private_value;
-
-	if (dev->chip.usb_id ==
-		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ)) {
-		/* A4DJ has only one control */
-		/* do not expose hardware input mode 0 */
-		dev->control_state[0] = ucontrol->value.integer.value[0] + 1;
-		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
-				dev->control_state, sizeof(dev->control_state));
-		return 1;
-	}
-
-	if (pos & CNT_INTVAL) {
-		dev->control_state[pos & ~CNT_INTVAL]
-			= ucontrol->value.integer.value[0];
-		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
-				dev->control_state, sizeof(dev->control_state));
-	} else {
-		if (ucontrol->value.integer.value[0])
-			dev->control_state[pos / 8] |= 1 << (pos % 8);
-		else
-			dev->control_state[pos / 8] &= ~(1 << (pos % 8));
-
-		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
-				dev->control_state, sizeof(dev->control_state));
-	}
-
-	return 1;
-}
-
-static struct snd_kcontrol_new kcontrol_template __devinitdata = {
-	.iface = SNDRV_CTL_ELEM_IFACE_HWDEP,
-	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
-	.index = 0,
-	.info = control_info,
-	.get  = control_get,
-	.put  = control_put,
-	/* name and private_value filled later */
-};
-
-struct caiaq_controller {
-	char *name;
-	int index;
-};
-
-static struct caiaq_controller ak1_controller[] = {
-	{ "LED left", 	2 },
-	{ "LED middle", 1 },
-	{ "LED right", 	0 },
-	{ "LED ring", 	3 }
-};
-
-static struct caiaq_controller rk2_controller[] = {
-	{ "LED 1",		5  },
-	{ "LED 2",		4  },
-	{ "LED 3",		3  },
-	{ "LED 4",		2  },
-	{ "LED 5",		1  },
-	{ "LED 6",		0  },
-	{ "LED pedal",		6  },
-	{ "LED 7seg_1b",	8  },
-	{ "LED 7seg_1c",	9  },
-	{ "LED 7seg_2a",	10 },
-	{ "LED 7seg_2b",	11 },
-	{ "LED 7seg_2c",	12 },
-	{ "LED 7seg_2d",	13 },
-	{ "LED 7seg_2e",	14 },
-	{ "LED 7seg_2f",	15 },
-	{ "LED 7seg_2g",	16 },
-	{ "LED 7seg_3a",	17 },
-	{ "LED 7seg_3b",	18 },
-	{ "LED 7seg_3c",	19 },
-	{ "LED 7seg_3d",	20 },
-	{ "LED 7seg_3e",	21 },
-	{ "LED 7seg_3f",	22 },
-	{ "LED 7seg_3g",	23 }
-};
-
-static struct caiaq_controller rk3_controller[] = {
-	{ "LED 7seg_1a",        0 + 0 },
-	{ "LED 7seg_1b",        0 + 1 },
-	{ "LED 7seg_1c",        0 + 2 },
-	{ "LED 7seg_1d",        0 + 3 },
-	{ "LED 7seg_1e",        0 + 4 },
-	{ "LED 7seg_1f",        0 + 5 },
-	{ "LED 7seg_1g",        0 + 6 },
-	{ "LED 7seg_1p",        0 + 7 },
-
-	{ "LED 7seg_2a",        8 + 0 },
-	{ "LED 7seg_2b",        8 + 1 },
-	{ "LED 7seg_2c",        8 + 2 },
-	{ "LED 7seg_2d",        8 + 3 },
-	{ "LED 7seg_2e",        8 + 4 },
-	{ "LED 7seg_2f",        8 + 5 },
-	{ "LED 7seg_2g",        8 + 6 },
-	{ "LED 7seg_2p",        8 + 7 },
-
-	{ "LED 7seg_3a",        16 + 0 },
-	{ "LED 7seg_3b",        16 + 1 },
-	{ "LED 7seg_3c",        16 + 2 },
-	{ "LED 7seg_3d",        16 + 3 },
-	{ "LED 7seg_3e",        16 + 4 },
-	{ "LED 7seg_3f",        16 + 5 },
-	{ "LED 7seg_3g",        16 + 6 },
-	{ "LED 7seg_3p",        16 + 7 },
-
-	{ "LED 7seg_4a",        24 + 0 },
-	{ "LED 7seg_4b",        24 + 1 },
-	{ "LED 7seg_4c",        24 + 2 },
-	{ "LED 7seg_4d",        24 + 3 },
-	{ "LED 7seg_4e",        24 + 4 },
-	{ "LED 7seg_4f",        24 + 5 },
-	{ "LED 7seg_4g",        24 + 6 },
-	{ "LED 7seg_4p",        24 + 7 },
-
-	{ "LED 1",		32 + 0 },
-	{ "LED 2",		32 + 1 },
-	{ "LED 3",		32 + 2 },
-	{ "LED 4",		32 + 3 },
-	{ "LED 5",		32 + 4 },
-	{ "LED 6",		32 + 5 },
-	{ "LED 7",		32 + 6 },
-	{ "LED 8",		32 + 7 },
-	{ "LED pedal",		32 + 8 }
-};
-
-static struct caiaq_controller kore_controller[] = {
-	{ "LED F1",		8   | CNT_INTVAL },
-	{ "LED F2",		12  | CNT_INTVAL },
-	{ "LED F3",		0   | CNT_INTVAL },
-	{ "LED F4",		4   | CNT_INTVAL },
-	{ "LED F5",		11  | CNT_INTVAL },
-	{ "LED F6",		15  | CNT_INTVAL },
-	{ "LED F7",		3   | CNT_INTVAL },
-	{ "LED F8",		7   | CNT_INTVAL },
-	{ "LED touch1",	     	10  | CNT_INTVAL },
-	{ "LED touch2",	     	14  | CNT_INTVAL },
-	{ "LED touch3",	     	2   | CNT_INTVAL },
-	{ "LED touch4",	     	6   | CNT_INTVAL },
-	{ "LED touch5",	     	9   | CNT_INTVAL },
-	{ "LED touch6",	     	13  | CNT_INTVAL },
-	{ "LED touch7",	     	1   | CNT_INTVAL },
-	{ "LED touch8",	     	5   | CNT_INTVAL },
-	{ "LED left",	       	18  | CNT_INTVAL },
-	{ "LED right",	     	22  | CNT_INTVAL },
-	{ "LED up",		16  | CNT_INTVAL },
-	{ "LED down",	       	20  | CNT_INTVAL },
-	{ "LED stop",	       	23  | CNT_INTVAL },
-	{ "LED play",	       	21  | CNT_INTVAL },
-	{ "LED record",	     	19  | CNT_INTVAL },
-	{ "LED listen",		17  | CNT_INTVAL },
-	{ "LED lcd",		30  | CNT_INTVAL },
-	{ "LED menu",		28  | CNT_INTVAL },
-	{ "LED sound",	 	31  | CNT_INTVAL },
-	{ "LED esc",		29  | CNT_INTVAL },
-	{ "LED view",		27  | CNT_INTVAL },
-	{ "LED enter",		24  | CNT_INTVAL },
-	{ "LED control",	26  | CNT_INTVAL }
-};
-
-static struct caiaq_controller a8dj_controller[] = {
-	{ "Current input mode",			0 | CNT_INTVAL 	},
-	{ "GND lift for TC Vinyl mode", 	24 + 0 		},
-	{ "GND lift for TC CD/Line mode", 	24 + 1 		},
-	{ "GND lift for phono mode", 		24 + 2 		},
-	{ "Software lock", 			40 		}
-};
-
-static struct caiaq_controller a4dj_controller[] = {
-	{ "Current input mode",	0 | CNT_INTVAL 	}
-};
-
-static int __devinit add_controls(struct caiaq_controller *c, int num,
-				  struct snd_usb_caiaqdev *dev)
-{
-	int i, ret;
-	struct snd_kcontrol *kc;
-
-	for (i = 0; i < num; i++, c++) {
-		kcontrol_template.name = c->name;
-		kcontrol_template.private_value = c->index;
-		kc = snd_ctl_new1(&kcontrol_template, dev);
-		ret = snd_ctl_add(dev->chip.card, kc);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
-int __devinit snd_usb_caiaq_control_init(struct snd_usb_caiaqdev *dev)
-{
-	int ret = 0;
-
-	switch (dev->chip.usb_id) {
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
-		ret = add_controls(ak1_controller,
-			ARRAY_SIZE(ak1_controller), dev);
-		break;
-
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
-		ret = add_controls(rk2_controller,
-			ARRAY_SIZE(rk2_controller), dev);
-		break;
-
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
-		ret = add_controls(rk3_controller,
-			ARRAY_SIZE(rk3_controller), dev);
-		break;
-
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
-		ret = add_controls(kore_controller,
-			ARRAY_SIZE(kore_controller), dev);
-		break;
-
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):
-		ret = add_controls(a8dj_controller,
-			ARRAY_SIZE(a8dj_controller), dev);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):
-		ret = add_controls(a4dj_controller,
-			ARRAY_SIZE(a4dj_controller), dev);
-		break;
-	}
-
-	return ret;
-}
-
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-control.h linux-2.6.30-rc3/sound/usb/caiaq/caiaq-control.h
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-control.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-control.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#ifndef CAIAQ_CONTROL_H
-#define CAIAQ_CONTROL_H
-
-int snd_usb_caiaq_control_init(struct snd_usb_caiaqdev *dev);
-
-#endif /* CAIAQ_CONTROL_H */
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-device.c linux-2.6.30-rc3/sound/usb/caiaq/caiaq-device.c
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-device.c	2009-04-22 03:29:12.529557401 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-device.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,528 +0,0 @@
-/*
- * caiaq.c: ALSA driver for caiaq/NativeInstruments devices
- *
- *   Copyright (c) 2007 Daniel Mack <daniel@caiaq.de>
- *                      Karsten Wiese <fzu@wemgehoertderstaat.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/interrupt.h>
-#include <linux/usb.h>
-#include <linux/input.h>
-#include <linux/spinlock.h>
-#include <sound/core.h>
-#include <sound/initval.h>
-#include <sound/pcm.h>
-#include <sound/rawmidi.h>
-#include <sound/control.h>
-
-#include "caiaq-device.h"
-#include "caiaq-audio.h"
-#include "caiaq-midi.h"
-#include "caiaq-control.h"
-
-#ifdef CONFIG_SND_USB_CAIAQ_INPUT
-#include "caiaq-input.h"
-#endif
-
-MODULE_AUTHOR("Daniel Mack <daniel@caiaq.de>");
-MODULE_DESCRIPTION("caiaq USB audio, version 1.3.13");
-MODULE_LICENSE("GPL");
-MODULE_SUPPORTED_DEVICE("{{Native Instruments, RigKontrol2},"
-			 "{Native Instruments, RigKontrol3},"
-			 "{Native Instruments, Kore Controller},"
-			 "{Native Instruments, Kore Controller 2},"
-			 "{Native Instruments, Audio Kontrol 1},"
-			 "{Native Instruments, Audio 4 DJ},"
-			 "{Native Instruments, Audio 8 DJ},"
-			 "{Native Instruments, Session I/O},"
-			 "{Native Instruments, GuitarRig mobile}");
-
-static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX; /* Index 0-max */
-static char* id[SNDRV_CARDS] = SNDRV_DEFAULT_STR; /* Id for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; /* Enable this card */
-static int snd_card_used[SNDRV_CARDS];
-
-module_param_array(index, int, NULL, 0444);
-MODULE_PARM_DESC(index, "Index value for the caiaq sound device");
-module_param_array(id, charp, NULL, 0444);
-MODULE_PARM_DESC(id, "ID string for the caiaq soundcard.");
-module_param_array(enable, bool, NULL, 0444);
-MODULE_PARM_DESC(enable, "Enable the caiaq soundcard.");
-
-enum {
-	SAMPLERATE_44100	= 0,
-	SAMPLERATE_48000	= 1,
-	SAMPLERATE_96000	= 2,
-	SAMPLERATE_192000	= 3,
-	SAMPLERATE_88200	= 4,
-	SAMPLERATE_INVALID	= 0xff
-};
-
-enum {
-	DEPTH_NONE	= 0,
-	DEPTH_16	= 1,
-	DEPTH_24	= 2,
-	DEPTH_32	= 3
-};
-
-static struct usb_device_id snd_usb_id_table[] = {
-	{
-		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =	USB_PID_RIGKONTROL2 
-	},
-	{
-		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =	USB_PID_RIGKONTROL3
-	},
-	{
-		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =	USB_PID_KORECONTROLLER
-	},
-	{
-		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =	USB_PID_KORECONTROLLER2
-	},
-	{
-		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =    USB_PID_AK1
-	},
-	{
-		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =    USB_PID_AUDIO8DJ
-	},
-	{
-		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =    USB_PID_SESSIONIO
-	},
-	{
-		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =    USB_PID_GUITARRIGMOBILE
-	},
-	{
-		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
-		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
-		.idProduct =    USB_PID_AUDIO4DJ
-	},
-	{ /* terminator */ }
-};
-
-static void usb_ep1_command_reply_dispatch (struct urb* urb)
-{
-	int ret;
-	struct snd_usb_caiaqdev *dev = urb->context;
-	unsigned char *buf = urb->transfer_buffer;
-
-	if (urb->status || !dev) {
-		log("received EP1 urb->status = %i\n", urb->status);
-		return;
-	}
-
-	switch(buf[0]) {
-	case EP1_CMD_GET_DEVICE_INFO:
-	 	memcpy(&dev->spec, buf+1, sizeof(struct caiaq_device_spec));
-		dev->spec.fw_version = le16_to_cpu(dev->spec.fw_version);
-		debug("device spec (firmware %d): audio: %d in, %d out, "
-			"MIDI: %d in, %d out, data alignment %d\n",
-			dev->spec.fw_version,
-			dev->spec.num_analog_audio_in,
-			dev->spec.num_analog_audio_out,
-			dev->spec.num_midi_in,
-			dev->spec.num_midi_out,
-			dev->spec.data_alignment);
-
-		dev->spec_received++;
-		wake_up(&dev->ep1_wait_queue);
-		break;
-	case EP1_CMD_AUDIO_PARAMS:
-		dev->audio_parm_answer = buf[1];
-		wake_up(&dev->ep1_wait_queue);
-		break;
-	case EP1_CMD_MIDI_READ:
-		snd_usb_caiaq_midi_handle_input(dev, buf[1], buf + 3, buf[2]);
-		break;
-	case EP1_CMD_READ_IO:
-		if (dev->chip.usb_id ==
-			USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ)) {
-			if (urb->actual_length > sizeof(dev->control_state))
-				urb->actual_length = sizeof(dev->control_state);
-			memcpy(dev->control_state, buf + 1, urb->actual_length);
-			wake_up(&dev->ep1_wait_queue);
-			break;
-		}
-#ifdef CONFIG_SND_USB_CAIAQ_INPUT
-	case EP1_CMD_READ_ERP:
-	case EP1_CMD_READ_ANALOG:
-		snd_usb_caiaq_input_dispatch(dev, buf, urb->actual_length);
-#endif
-		break;
-	}
-
-	dev->ep1_in_urb.actual_length = 0;
-	ret = usb_submit_urb(&dev->ep1_in_urb, GFP_ATOMIC);
-	if (ret < 0)
-		log("unable to submit urb. OOM!?\n");
-}
-
-int snd_usb_caiaq_send_command(struct snd_usb_caiaqdev *dev,
-			       unsigned char command,
-			       const unsigned char *buffer,
-			       int len)
-{
-	int actual_len;
-	struct usb_device *usb_dev = dev->chip.dev;
-
-	if (!usb_dev)
-		return -EIO;
-
-	if (len > EP1_BUFSIZE - 1)
-		len = EP1_BUFSIZE - 1;
-
-	if (buffer && len > 0)
-		memcpy(dev->ep1_out_buf+1, buffer, len);
-	
-	dev->ep1_out_buf[0] = command;
-	return usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, 1),
-			   dev->ep1_out_buf, len+1, &actual_len, 200);
-}
-
-int snd_usb_caiaq_set_audio_params (struct snd_usb_caiaqdev *dev,
-		   		    int rate, int depth, int bpp)
-{
-	int ret;
-	char tmp[5];
-	
-	switch (rate) {
-	case 44100:	tmp[0] = SAMPLERATE_44100;   break;
-	case 48000:	tmp[0] = SAMPLERATE_48000;   break;
-	case 88200:	tmp[0] = SAMPLERATE_88200;   break;
-	case 96000:	tmp[0] = SAMPLERATE_96000;   break;
-	case 192000:	tmp[0] = SAMPLERATE_192000;  break;
-	default:	return -EINVAL;
-	}
-
-	switch (depth) {
-	case 16:	tmp[1] = DEPTH_16;   break;
-	case 24:	tmp[1] = DEPTH_24;   break;
-	default:	return -EINVAL;
-	}
-
-	tmp[2] = bpp & 0xff;
-	tmp[3] = bpp >> 8;
-	tmp[4] = 1; /* packets per microframe */
-
-	debug("setting audio params: %d Hz, %d bits, %d bpp\n",
-		rate, depth, bpp);
-
-	dev->audio_parm_answer = -1;
-	ret = snd_usb_caiaq_send_command(dev, EP1_CMD_AUDIO_PARAMS,
-					 tmp, sizeof(tmp));
-
-	if (ret)
-		return ret;
-	
-	if (!wait_event_timeout(dev->ep1_wait_queue, 
-	    dev->audio_parm_answer >= 0, HZ))
-		return -EPIPE;
-		
-	if (dev->audio_parm_answer != 1) 
-		debug("unable to set the device's audio params\n");
-	else
-		dev->bpp = bpp;
-
-	return dev->audio_parm_answer == 1 ? 0 : -EINVAL;
-}
-
-int snd_usb_caiaq_set_auto_msg (struct snd_usb_caiaqdev *dev, 
-				int digital, int analog, int erp)
-{
-	char tmp[3] = { digital, analog, erp };
-	return snd_usb_caiaq_send_command(dev, EP1_CMD_AUTO_MSG,
-					  tmp, sizeof(tmp));
-}
-
-static void __devinit setup_card(struct snd_usb_caiaqdev *dev)
-{
-	int ret;
-	char val[4];
-	
-	/* device-specific startup specials */
-	switch (dev->chip.usb_id) {
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
-		/* RigKontrol2 - display centered dash ('-') */
-		val[0] = 0x00;
-		val[1] = 0x00;
-		val[2] = 0x01;
-		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO, val, 3);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
-		/* RigKontrol2 - display two centered dashes ('--') */
-		val[0] = 0x00;
-		val[1] = 0x40;
-		val[2] = 0x40;
-		val[3] = 0x00;
-		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO, val, 4);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
-		/* Audio Kontrol 1 - make USB-LED stop blinking */
-		val[0] = 0x00;
-		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO, val, 1);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):
-		/* Audio 8 DJ - trigger read of current settings */
-		dev->control_state[0] = 0xff;
-		snd_usb_caiaq_set_auto_msg(dev, 1, 0, 0);
-		snd_usb_caiaq_send_command(dev, EP1_CMD_READ_IO, NULL, 0);
-
-		if (!wait_event_timeout(dev->ep1_wait_queue,
-					dev->control_state[0] != 0xff, HZ))
-			return;
-
-		/* fix up some defaults */
-		if ((dev->control_state[1] != 2) ||
-		    (dev->control_state[2] != 3) ||
-		    (dev->control_state[4] != 2)) {
-			dev->control_state[1] = 2;
-			dev->control_state[2] = 3;
-			dev->control_state[4] = 2;
-			snd_usb_caiaq_send_command(dev,
-				EP1_CMD_WRITE_IO, dev->control_state, 6);
-		}
-
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):
-		/* Audio 4 DJ - default input mode to phono */
-		dev->control_state[0] = 2;
-		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
-			dev->control_state, 1);
-		break;
-	}
-	
-	if (dev->spec.num_analog_audio_out +
-	    dev->spec.num_analog_audio_in +
-	    dev->spec.num_digital_audio_out +
-	    dev->spec.num_digital_audio_in > 0) {
-		ret = snd_usb_caiaq_audio_init(dev);
-		if (ret < 0)
-			log("Unable to set up audio system (ret=%d)\n", ret);
-	}
-	
-	if (dev->spec.num_midi_in +
-	    dev->spec.num_midi_out > 0) {
-		ret = snd_usb_caiaq_midi_init(dev);
-		if (ret < 0)
-			log("Unable to set up MIDI system (ret=%d)\n", ret);
-	}
-
-#ifdef CONFIG_SND_USB_CAIAQ_INPUT
-	ret = snd_usb_caiaq_input_init(dev);
-	if (ret < 0)
-		log("Unable to set up input system (ret=%d)\n", ret);
-#endif
-
-	/* finally, register the card and all its sub-instances */
-	ret = snd_card_register(dev->chip.card);
-	if (ret < 0) {
-		log("snd_card_register() returned %d\n", ret);
-		snd_card_free(dev->chip.card);
-	}
-
-	ret = snd_usb_caiaq_control_init(dev);
-	if (ret < 0)
-		log("Unable to set up control system (ret=%d)\n", ret);
-}
-
-static int create_card(struct usb_device* usb_dev, struct snd_card **cardp)
-{
-	int devnum;
-	int err;
-	struct snd_card *card;
-	struct snd_usb_caiaqdev *dev;
-
-	for (devnum = 0; devnum < SNDRV_CARDS; devnum++)
-		if (enable[devnum] && !snd_card_used[devnum])
-			break;
-
-	if (devnum >= SNDRV_CARDS)
-		return -ENODEV;
-
-	err = snd_card_create(index[devnum], id[devnum], THIS_MODULE, 
-			      sizeof(struct snd_usb_caiaqdev), &card);
-	if (err < 0)
-		return err;
-
-	dev = caiaqdev(card);
-	dev->chip.dev = usb_dev;
-	dev->chip.card = card;
-	dev->chip.usb_id = USB_ID(le16_to_cpu(usb_dev->descriptor.idVendor),
-				  le16_to_cpu(usb_dev->descriptor.idProduct));
-	spin_lock_init(&dev->spinlock);
-	snd_card_set_dev(card, &usb_dev->dev);
-
-	*cardp = card;
-	return 0;
-}
-
-static int __devinit init_card(struct snd_usb_caiaqdev *dev)
-{
-	char *c;
-	struct usb_device *usb_dev = dev->chip.dev;
-	struct snd_card *card = dev->chip.card;
-	int err, len;
-	
-	if (usb_set_interface(usb_dev, 0, 1) != 0) {
-		log("can't set alt interface.\n");
-		return -EIO;
-	}
-
-	usb_init_urb(&dev->ep1_in_urb);
-	usb_init_urb(&dev->midi_out_urb);
-
-	usb_fill_bulk_urb(&dev->ep1_in_urb, usb_dev, 
-			  usb_rcvbulkpipe(usb_dev, 0x1),
-			  dev->ep1_in_buf, EP1_BUFSIZE, 
-			  usb_ep1_command_reply_dispatch, dev);
-
-	usb_fill_bulk_urb(&dev->midi_out_urb, usb_dev, 
-			  usb_sndbulkpipe(usb_dev, 0x1),
-			  dev->midi_out_buf, EP1_BUFSIZE, 
-			  snd_usb_caiaq_midi_output_done, dev);
-	
-	init_waitqueue_head(&dev->ep1_wait_queue);
-	init_waitqueue_head(&dev->prepare_wait_queue);
-	
-	if (usb_submit_urb(&dev->ep1_in_urb, GFP_KERNEL) != 0)
-		return -EIO;
-
-	err = snd_usb_caiaq_send_command(dev, EP1_CMD_GET_DEVICE_INFO, NULL, 0);
-	if (err)
-		return err;
-
-	if (!wait_event_timeout(dev->ep1_wait_queue, dev->spec_received, HZ))
-		return -ENODEV;
-
-	usb_string(usb_dev, usb_dev->descriptor.iManufacturer,
-		   dev->vendor_name, CAIAQ_USB_STR_LEN);
-	
-	usb_string(usb_dev, usb_dev->descriptor.iProduct,
-		   dev->product_name, CAIAQ_USB_STR_LEN);
-	
-	usb_string(usb_dev, usb_dev->descriptor.iSerialNumber,
-		   dev->serial, CAIAQ_USB_STR_LEN);
-
-	/* terminate serial string at first white space occurence */
-	c = strchr(dev->serial, ' ');
-	if (c)
-		*c = '\0';
-	
-	strcpy(card->driver, MODNAME);
-	strcpy(card->shortname, dev->product_name);
-
-	len = snprintf(card->longname, sizeof(card->longname),
-		       "%s %s (serial %s, ",
-		       dev->vendor_name, dev->product_name, dev->serial);
-
-	if (len < sizeof(card->longname) - 2)
-		len += usb_make_path(usb_dev, card->longname + len,
-				     sizeof(card->longname) - len);
-
-	card->longname[len++] = ')';
-	card->longname[len] = '\0';
-	setup_card(dev);
-	return 0;
-}
-
-static int __devinit snd_probe(struct usb_interface *intf, 
-		     const struct usb_device_id *id)
-{
-	int ret;
-	struct snd_card *card;
-	struct usb_device *device = interface_to_usbdev(intf);
-	
-	ret = create_card(device, &card);
-	
-	if (ret < 0)
-		return ret;
-			
-	usb_set_intfdata(intf, card);
-	ret = init_card(caiaqdev(card));
-	if (ret < 0) {
-		log("unable to init card! (ret=%d)\n", ret);
-		snd_card_free(card);
-		return ret;
-	}
-	
-	return 0;
-}
-
-static void snd_disconnect(struct usb_interface *intf)
-{
-	struct snd_usb_caiaqdev *dev;
-	struct snd_card *card = usb_get_intfdata(intf);
-
-	debug("%s(%p)\n", __func__, intf);
-
-	if (!card)
-		return;
-
-	dev = caiaqdev(card);
-	snd_card_disconnect(card);
-
-#ifdef CONFIG_SND_USB_CAIAQ_INPUT
-	snd_usb_caiaq_input_free(dev);
-#endif
-	snd_usb_caiaq_audio_free(dev);
-	
-	usb_kill_urb(&dev->ep1_in_urb);
-	usb_kill_urb(&dev->midi_out_urb);
-	
-	snd_card_free(card);
-	usb_reset_device(interface_to_usbdev(intf));
-}
-
-
-MODULE_DEVICE_TABLE(usb, snd_usb_id_table);
-static struct usb_driver snd_usb_driver = {
-	.name 		= MODNAME,
-	.probe 		= snd_probe,
-	.disconnect	= snd_disconnect,
-	.id_table 	= snd_usb_id_table,
-};
-
-static int __init snd_module_init(void)
-{
-	return usb_register(&snd_usb_driver);
-}
-
-static void __exit snd_module_exit(void)
-{
-	usb_deregister(&snd_usb_driver);
-}
-
-module_init(snd_module_init)
-module_exit(snd_module_exit)
-
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-device.h linux-2.6.30-rc3/sound/usb/caiaq/caiaq-device.h
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-device.h	2009-04-22 03:29:12.529557401 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-device.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,131 +0,0 @@
-#ifndef CAIAQ_DEVICE_H
-#define CAIAQ_DEVICE_H
-
-#include "../usbaudio.h"
-
-#define USB_VID_NATIVEINSTRUMENTS 0x17cc
-
-#define USB_PID_RIGKONTROL2	0x1969
-#define USB_PID_RIGKONTROL3	0x1940
-#define USB_PID_KORECONTROLLER	0x4711
-#define USB_PID_KORECONTROLLER2	0x4712
-#define USB_PID_AK1		0x0815
-#define USB_PID_AUDIO4DJ	0x0839
-#define USB_PID_AUDIO8DJ	0x1978
-#define USB_PID_SESSIONIO	0x1915
-#define USB_PID_GUITARRIGMOBILE	0x0d8d
-
-#define EP1_BUFSIZE 64
-#define CAIAQ_USB_STR_LEN 0xff
-#define MAX_STREAMS 32
-
-//#define	SND_USB_CAIAQ_DEBUG
-
-#define MODNAME "snd-usb-caiaq"
-#define log(x...) snd_printk(KERN_WARNING MODNAME" log: " x)
-
-#ifdef SND_USB_CAIAQ_DEBUG
-#define debug(x...) snd_printk(KERN_WARNING MODNAME " debug: " x)
-#else
-#define debug(x...) do { } while(0)
-#endif
-
-#define EP1_CMD_GET_DEVICE_INFO	0x1
-#define EP1_CMD_READ_ERP	0x2
-#define EP1_CMD_READ_ANALOG	0x3
-#define EP1_CMD_READ_IO		0x4
-#define EP1_CMD_WRITE_IO	0x5
-#define EP1_CMD_MIDI_READ	0x6
-#define EP1_CMD_MIDI_WRITE	0x7
-#define EP1_CMD_AUDIO_PARAMS	0x9
-#define EP1_CMD_AUTO_MSG	0xb
-#define EP1_CMD_DIMM_LEDS       0xc
-
-struct caiaq_device_spec {
-	unsigned short fw_version;
-	unsigned char hw_subtype;
-	unsigned char num_erp;
-	unsigned char num_analog_in;
-	unsigned char num_digital_in;
-	unsigned char num_digital_out;
-	unsigned char num_analog_audio_out;
-	unsigned char num_analog_audio_in;
-	unsigned char num_digital_audio_out;
-	unsigned char num_digital_audio_in;
-	unsigned char num_midi_out;
-	unsigned char num_midi_in;
-	unsigned char data_alignment;
-} __attribute__ ((packed));
-
-struct snd_usb_caiaq_cb_info;
-
-struct snd_usb_caiaqdev {
-	struct snd_usb_audio chip;
-
-	struct urb ep1_in_urb;
-	struct urb midi_out_urb;
-	struct urb **data_urbs_in;
-	struct urb **data_urbs_out;
-	struct snd_usb_caiaq_cb_info *data_cb_info;
-
-	unsigned char ep1_in_buf[EP1_BUFSIZE];
-	unsigned char ep1_out_buf[EP1_BUFSIZE];
-	unsigned char midi_out_buf[EP1_BUFSIZE];
-
-	struct caiaq_device_spec spec;
-	spinlock_t spinlock;
-	wait_queue_head_t ep1_wait_queue;
-	wait_queue_head_t prepare_wait_queue;
-	int spec_received, audio_parm_answer;
-	int midi_out_active;
-
-	char vendor_name[CAIAQ_USB_STR_LEN];
-	char product_name[CAIAQ_USB_STR_LEN];
-	char serial[CAIAQ_USB_STR_LEN];
-
-	int n_streams, n_audio_in, n_audio_out;
-	int streaming, first_packet, output_running;
-	int audio_in_buf_pos[MAX_STREAMS];
-	int audio_out_buf_pos[MAX_STREAMS];
-	int period_in_count[MAX_STREAMS];
-	int period_out_count[MAX_STREAMS];
-	int input_panic, output_panic, warned;
-	char *audio_in_buf, *audio_out_buf;
-	unsigned int samplerates, bpp;
-
-	struct snd_pcm_substream *sub_playback[MAX_STREAMS];
-	struct snd_pcm_substream *sub_capture[MAX_STREAMS];
-
-	/* Controls */
-	unsigned char control_state[64];
-
-	/* Linux input */
-#ifdef CONFIG_SND_USB_CAIAQ_INPUT
-	struct input_dev *input_dev;
-	char phys[64];			/* physical device path */
-	unsigned short keycode[64];
-#endif
-
-	/* ALSA */
-	struct snd_pcm *pcm;
-	struct snd_pcm_hardware pcm_info;
-	struct snd_rawmidi *rmidi;
-	struct snd_rawmidi_substream *midi_receive_substream;
-	struct snd_rawmidi_substream *midi_out_substream;
-};
-
-struct snd_usb_caiaq_cb_info {
-	struct snd_usb_caiaqdev *dev;
-	int index;
-};
-
-#define caiaqdev(c) ((struct snd_usb_caiaqdev*)(c)->private_data)
-
-int snd_usb_caiaq_set_audio_params (struct snd_usb_caiaqdev *dev, int rate, int depth, int bbp);
-int snd_usb_caiaq_set_auto_msg (struct snd_usb_caiaqdev *dev, int digital, int analog, int erp);
-int snd_usb_caiaq_send_command(struct snd_usb_caiaqdev *dev,
-			       unsigned char command,
-			       const unsigned char *buffer,
-			       int len);
-
-#endif /* CAIAQ_DEVICE_H */
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-input.c linux-2.6.30-rc3/sound/usb/caiaq/caiaq-input.c
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-input.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-input.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,363 +0,0 @@
-/*
- *   Copyright (c) 2006,2007 Daniel Mack, Tim Ruetz
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/input.h>
-#include <linux/usb.h>
-#include <linux/usb/input.h>
-#include <linux/spinlock.h>
-#include <sound/core.h>
-#include <sound/rawmidi.h>
-#include <sound/pcm.h>
-#include "caiaq-device.h"
-#include "caiaq-input.h"
-
-static unsigned short keycode_ak1[] =  { KEY_C, KEY_B, KEY_A };
-static unsigned short keycode_rk2[] =  { KEY_1, KEY_2, KEY_3, KEY_4,
-					 KEY_5, KEY_6, KEY_7 };
-static unsigned short keycode_rk3[] =  { KEY_1, KEY_2, KEY_3, KEY_4,
-					 KEY_5, KEY_6, KEY_7, KEY_5, KEY_6 };
-
-static unsigned short keycode_kore[] = {
-	KEY_FN_F1,      /* "menu"               */
-	KEY_FN_F7,      /* "lcd backlight       */
-	KEY_FN_F2,      /* "control"            */
-	KEY_FN_F3,      /* "enter"              */
-	KEY_FN_F4,      /* "view"               */
-	KEY_FN_F5,      /* "esc"                */
-	KEY_FN_F6,      /* "sound"              */
-	KEY_FN_F8,      /* array spacer, never triggered. */
-	KEY_RIGHT,
-	KEY_DOWN,
-	KEY_UP,
-	KEY_LEFT,
-	KEY_SOUND,      /* "listen"             */
-	KEY_RECORD,
-	KEY_PLAYPAUSE,
-	KEY_STOP,
-	BTN_4,          /* 8 softkeys */
-	BTN_3,
-	BTN_2,
-	BTN_1,
-	BTN_8,
-	BTN_7,
-	BTN_6,
-	BTN_5,
-	KEY_BRL_DOT4,   /* touch sensitive knobs */
-	KEY_BRL_DOT3,
-	KEY_BRL_DOT2,
-	KEY_BRL_DOT1,
-	KEY_BRL_DOT8,
-	KEY_BRL_DOT7,
-	KEY_BRL_DOT6,
-	KEY_BRL_DOT5
-};
-
-#define DEG90		(range / 2)
-#define DEG180		(range)
-#define DEG270		(DEG90 + DEG180)
-#define DEG360		(DEG180 * 2)
-#define HIGH_PEAK	(268)
-#define LOW_PEAK	(-7)
-
-/* some of these devices have endless rotation potentiometers
- * built in which use two tapers, 90 degrees phase shifted.
- * this algorithm decodes them to one single value, ranging
- * from 0 to 999 */
-static unsigned int decode_erp(unsigned char a, unsigned char b)
-{
-	int weight_a, weight_b;
-	int pos_a, pos_b;
-	int ret;
-	int range = HIGH_PEAK - LOW_PEAK;
-	int mid_value = (HIGH_PEAK + LOW_PEAK) / 2;
-
-	weight_b = abs(mid_value - a) - (range / 2 - 100) / 2;
-
-	if (weight_b < 0)
-		weight_b = 0;
-
-	if (weight_b > 100)
-		weight_b = 100;
-
-	weight_a = 100 - weight_b;
-
-	if (a < mid_value) {
-		/* 0..90 and 270..360 degrees */
-		pos_b = b - LOW_PEAK + DEG270;
-		if (pos_b >= DEG360)
-			pos_b -= DEG360;
-	} else
-		/* 90..270 degrees */
-		pos_b = HIGH_PEAK - b + DEG90;
-
-
-	if (b > mid_value)
-		/* 0..180 degrees */
-		pos_a = a - LOW_PEAK;
-	else
-		/* 180..360 degrees */
-		pos_a = HIGH_PEAK - a + DEG180;
-
-	/* interpolate both slider values, depending on weight factors */
-	/* 0..99 x DEG360 */
-	ret = pos_a * weight_a + pos_b * weight_b;
-
-	/* normalize to 0..999 */
-	ret *= 10;
-	ret /= DEG360;
-
-	if (ret < 0)
-		ret += 1000;
-
-	if (ret >= 1000)
-		ret -= 1000;
-
-	return ret;
-}
-
-#undef DEG90
-#undef DEG180
-#undef DEG270
-#undef DEG360
-#undef HIGH_PEAK
-#undef LOW_PEAK
-
-
-static void snd_caiaq_input_read_analog(struct snd_usb_caiaqdev *dev,
-					const unsigned char *buf,
-					unsigned int len)
-{
-	struct input_dev *input_dev = dev->input_dev;
-
-	switch (dev->chip.usb_id) {
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
-		input_report_abs(input_dev, ABS_X, (buf[4] << 8) | buf[5]);
-		input_report_abs(input_dev, ABS_Y, (buf[0] << 8) | buf[1]);
-		input_report_abs(input_dev, ABS_Z, (buf[2] << 8) | buf[3]);
-		input_sync(input_dev);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
-		input_report_abs(input_dev, ABS_X, (buf[0] << 8) | buf[1]);
-		input_report_abs(input_dev, ABS_Y, (buf[2] << 8) | buf[3]);
-		input_report_abs(input_dev, ABS_Z, (buf[4] << 8) | buf[5]);
-		input_sync(input_dev);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
-		input_report_abs(input_dev, ABS_X, (buf[0] << 8) | buf[1]);
-		input_report_abs(input_dev, ABS_Y, (buf[2] << 8) | buf[3]);
-		input_report_abs(input_dev, ABS_Z, (buf[4] << 8) | buf[5]);
-		input_sync(input_dev);
-		break;
-	}
-}
-
-static void snd_caiaq_input_read_erp(struct snd_usb_caiaqdev *dev,
-				     const char *buf, unsigned int len)
-{
-	struct input_dev *input_dev = dev->input_dev;
-	int i;
-
-	switch (dev->chip.usb_id) {
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
-		i = decode_erp(buf[0], buf[1]);
-		input_report_abs(input_dev, ABS_X, i);
-		input_sync(input_dev);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
-		i = decode_erp(buf[7], buf[5]);
-		input_report_abs(input_dev, ABS_HAT0X, i);
-		i = decode_erp(buf[12], buf[14]);
-		input_report_abs(input_dev, ABS_HAT0Y, i);
-		i = decode_erp(buf[15], buf[13]);
-		input_report_abs(input_dev, ABS_HAT1X, i);
-		i = decode_erp(buf[0], buf[2]);
-		input_report_abs(input_dev, ABS_HAT1Y, i);
-		i = decode_erp(buf[3], buf[1]);
-		input_report_abs(input_dev, ABS_HAT2X, i);
-		i = decode_erp(buf[8], buf[10]);
-		input_report_abs(input_dev, ABS_HAT2Y, i);
-		i = decode_erp(buf[11], buf[9]);
-		input_report_abs(input_dev, ABS_HAT3X, i);
-		i = decode_erp(buf[4], buf[6]);
-		input_report_abs(input_dev, ABS_HAT3Y, i);
-		input_sync(input_dev);
-		break;
-	}
-}
-
-static void snd_caiaq_input_read_io(struct snd_usb_caiaqdev *dev,
-				    char *buf, unsigned int len)
-{
-	struct input_dev *input_dev = dev->input_dev;
-	unsigned short *keycode = input_dev->keycode;
-	int i;
-
-	if (!keycode)
-		return;
-
-	if (input_dev->id.product == USB_PID_RIGKONTROL2)
-		for (i = 0; i < len; i++)
-			buf[i] = ~buf[i];
-
-	for (i = 0; i < input_dev->keycodemax && i < len * 8; i++)
-		input_report_key(input_dev, keycode[i],
-				 buf[i / 8] & (1 << (i % 8)));
-
-	if (dev->chip.usb_id ==
-		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER) ||
-	    dev->chip.usb_id ==
-		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2))
-		input_report_abs(dev->input_dev, ABS_MISC, 255 - buf[4]);
-
-	input_sync(input_dev);
-}
-
-void snd_usb_caiaq_input_dispatch(struct snd_usb_caiaqdev *dev,
-				  char *buf,
-				  unsigned int len)
-{
-	if (!dev->input_dev || len < 1)
-		return;
-
-	switch (buf[0]) {
-	case EP1_CMD_READ_ANALOG:
-		snd_caiaq_input_read_analog(dev, buf + 1, len - 1);
-		break;
-	case EP1_CMD_READ_ERP:
-		snd_caiaq_input_read_erp(dev, buf + 1, len - 1);
-		break;
-	case EP1_CMD_READ_IO:
-		snd_caiaq_input_read_io(dev, buf + 1, len - 1);
-		break;
-	}
-}
-
-int snd_usb_caiaq_input_init(struct snd_usb_caiaqdev *dev)
-{
-	struct usb_device *usb_dev = dev->chip.dev;
-	struct input_dev *input;
-	int i, ret;
-
-	input = input_allocate_device();
-	if (!input)
-		return -ENOMEM;
-
-	usb_make_path(usb_dev, dev->phys, sizeof(dev->phys));
-	strlcat(dev->phys, "/input0", sizeof(dev->phys));
-
-	input->name = dev->product_name;
-	input->phys = dev->phys;
-	usb_to_input_id(usb_dev, &input->id);
-	input->dev.parent = &usb_dev->dev;
-
-        switch (dev->chip.usb_id) {
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
-		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-		input->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |
-			BIT_MASK(ABS_Z);
-		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_rk2));
-		memcpy(dev->keycode, keycode_rk2, sizeof(keycode_rk2));
-		input->keycodemax = ARRAY_SIZE(keycode_rk2);
-		input_set_abs_params(input, ABS_X, 0, 4096, 0, 10);
-		input_set_abs_params(input, ABS_Y, 0, 4096, 0, 10);
-		input_set_abs_params(input, ABS_Z, 0, 4096, 0, 10);
-		snd_usb_caiaq_set_auto_msg(dev, 1, 10, 0);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
-		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-		input->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |
-			BIT_MASK(ABS_Z);
-		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_rk3));
-		memcpy(dev->keycode, keycode_rk3, sizeof(keycode_rk3));
-		input->keycodemax = ARRAY_SIZE(keycode_rk3);
-		input_set_abs_params(input, ABS_X, 0, 1024, 0, 10);
-		input_set_abs_params(input, ABS_Y, 0, 1024, 0, 10);
-		input_set_abs_params(input, ABS_Z, 0, 1024, 0, 10);
-		snd_usb_caiaq_set_auto_msg(dev, 1, 10, 0);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
-		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-		input->absbit[0] = BIT_MASK(ABS_X);
-		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_ak1));
-		memcpy(dev->keycode, keycode_ak1, sizeof(keycode_ak1));
-		input->keycodemax = ARRAY_SIZE(keycode_ak1);
-		input_set_abs_params(input, ABS_X, 0, 999, 0, 10);
-		snd_usb_caiaq_set_auto_msg(dev, 1, 0, 5);
-		break;
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
-	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
-		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-		input->absbit[0] = BIT_MASK(ABS_HAT0X) | BIT_MASK(ABS_HAT0Y) |
-				   BIT_MASK(ABS_HAT1X) | BIT_MASK(ABS_HAT1Y) |
-				   BIT_MASK(ABS_HAT2X) | BIT_MASK(ABS_HAT2Y) |
-				   BIT_MASK(ABS_HAT3X) | BIT_MASK(ABS_HAT3Y) |
-				   BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |
-				   BIT_MASK(ABS_Z);
-		input->absbit[BIT_WORD(ABS_MISC)] |= BIT_MASK(ABS_MISC);
-		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_kore));
-		memcpy(dev->keycode, keycode_kore, sizeof(keycode_kore));
-		input->keycodemax = ARRAY_SIZE(keycode_kore);
-		input_set_abs_params(input, ABS_HAT0X, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_HAT0Y, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_HAT1X, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_HAT1Y, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_HAT2X, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_HAT2Y, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_HAT3X, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_HAT3Y, 0, 999, 0, 10);
-		input_set_abs_params(input, ABS_X, 0, 4096, 0, 10);
-		input_set_abs_params(input, ABS_Y, 0, 4096, 0, 10);
-		input_set_abs_params(input, ABS_Z, 0, 4096, 0, 10);
-		input_set_abs_params(input, ABS_MISC, 0, 255, 0, 1);
-		snd_usb_caiaq_set_auto_msg(dev, 1, 10, 5);
-		break;
-	default:
-		/* no input methods supported on this device */
-		input_free_device(input);
-		return 0;
-	}
-
-	input->keycode = dev->keycode;
-	input->keycodesize = sizeof(unsigned short);
-	for (i = 0; i < input->keycodemax; i++)
-		__set_bit(dev->keycode[i], input->keybit);
-
-	ret = input_register_device(input);
-	if (ret < 0) {
-		input_free_device(input);
-		return ret;
-	}
-
-	dev->input_dev = input;
-	return 0;
-}
-
-void snd_usb_caiaq_input_free(struct snd_usb_caiaqdev *dev)
-{
-	if (!dev || !dev->input_dev)
-		return;
-
-	input_unregister_device(dev->input_dev);
-	dev->input_dev = NULL;
-}
-
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-input.h linux-2.6.30-rc3/sound/usb/caiaq/caiaq-input.h
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-input.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-input.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-#ifndef CAIAQ_INPUT_H
-#define CAIAQ_INPUT_H
-
-void snd_usb_caiaq_input_dispatch(struct snd_usb_caiaqdev *dev, char *buf, unsigned int len);
-int snd_usb_caiaq_input_init(struct snd_usb_caiaqdev *dev);
-void snd_usb_caiaq_input_free(struct snd_usb_caiaqdev *dev);
-
-#endif
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-midi.c linux-2.6.30-rc3/sound/usb/caiaq/caiaq-midi.c
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-midi.c	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-midi.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,180 +0,0 @@
-/*
- *   Copyright (c) 2006,2007 Daniel Mack
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/interrupt.h>
-#include <linux/usb.h>
-#include <linux/input.h>
-#include <linux/spinlock.h>
-#include <sound/core.h>
-#include <sound/rawmidi.h>
-#include <sound/pcm.h>
-
-#include "caiaq-device.h"
-#include "caiaq-midi.h"
-
-
-static int snd_usb_caiaq_midi_input_open(struct snd_rawmidi_substream *substream)
-{
-	return 0;
-}
-
-static int snd_usb_caiaq_midi_input_close(struct snd_rawmidi_substream *substream)
-{
-	return 0;
-}
-
-static void snd_usb_caiaq_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
-{
-	struct snd_usb_caiaqdev *dev = substream->rmidi->private_data;
-
-	if (!dev)
-		return;
-	
-	dev->midi_receive_substream = up ? substream : NULL;
-}
-
-
-static int snd_usb_caiaq_midi_output_open(struct snd_rawmidi_substream *substream)
-{
-	return 0;
-}
-
-static int snd_usb_caiaq_midi_output_close(struct snd_rawmidi_substream *substream)
-{
-	struct snd_usb_caiaqdev *dev = substream->rmidi->private_data;
-	if (dev->midi_out_active) {
-		usb_kill_urb(&dev->midi_out_urb);
-		dev->midi_out_active = 0;
-	}
-	return 0;
-}
-
-static void snd_usb_caiaq_midi_send(struct snd_usb_caiaqdev *dev,
-				    struct snd_rawmidi_substream *substream)
-{
-	int len, ret;
-	
-	dev->midi_out_buf[0] = EP1_CMD_MIDI_WRITE;
-	dev->midi_out_buf[1] = 0; /* port */
-	len = snd_rawmidi_transmit(substream, dev->midi_out_buf + 3,
-				   EP1_BUFSIZE - 3);
-	
-	if (len <= 0)
-		return;
-	
-	dev->midi_out_buf[2] = len;
-	dev->midi_out_urb.transfer_buffer_length = len+3;
-	
-	ret = usb_submit_urb(&dev->midi_out_urb, GFP_ATOMIC);
-	if (ret < 0)
-		log("snd_usb_caiaq_midi_send(%p): usb_submit_urb() failed,"
-		    "ret=%d, len=%d\n",
-		    substream, ret, len);
-	else
-		dev->midi_out_active = 1;
-}
-
-static void snd_usb_caiaq_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
-{
-	struct snd_usb_caiaqdev *dev = substream->rmidi->private_data;
-	
-	if (up) {
-		dev->midi_out_substream = substream;
-		if (!dev->midi_out_active)
-			snd_usb_caiaq_midi_send(dev, substream);
-	} else {
-		dev->midi_out_substream = NULL;
-	}
-}
-
-
-static struct snd_rawmidi_ops snd_usb_caiaq_midi_output =
-{
-	.open =		snd_usb_caiaq_midi_output_open,
-	.close =	snd_usb_caiaq_midi_output_close,
-	.trigger =      snd_usb_caiaq_midi_output_trigger,
-};
-
-static struct snd_rawmidi_ops snd_usb_caiaq_midi_input =
-{
-	.open =		snd_usb_caiaq_midi_input_open,
-	.close =	snd_usb_caiaq_midi_input_close,
-	.trigger =      snd_usb_caiaq_midi_input_trigger,
-};
-
-void snd_usb_caiaq_midi_handle_input(struct snd_usb_caiaqdev *dev, 
-				     int port, const char *buf, int len)
-{
-	if (!dev->midi_receive_substream)
-		return;
-	
-	snd_rawmidi_receive(dev->midi_receive_substream, buf, len);
-}
-
-int snd_usb_caiaq_midi_init(struct snd_usb_caiaqdev *device)
-{
-	int ret;
-	struct snd_rawmidi *rmidi;
-
-	ret = snd_rawmidi_new(device->chip.card, device->product_name, 0,
-					device->spec.num_midi_out,
-					device->spec.num_midi_in,
-					&rmidi);
-
-	if (ret < 0)
-		return ret;
-
-	strcpy(rmidi->name, device->product_name);
-
-	rmidi->info_flags = SNDRV_RAWMIDI_INFO_DUPLEX;
-	rmidi->private_data = device;
-
-	if (device->spec.num_midi_out > 0) {
-		rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
-		snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, 
-				    &snd_usb_caiaq_midi_output);
-	}
-
-	if (device->spec.num_midi_in > 0) {
-		rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
-		snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, 
-				    &snd_usb_caiaq_midi_input);
-	}
-	
-	device->rmidi = rmidi;
-
-	return 0;
-}
-
-void snd_usb_caiaq_midi_output_done(struct urb* urb)
-{
-	struct snd_usb_caiaqdev *dev = urb->context;
-	
-	dev->midi_out_active = 0;
-	if (urb->status != 0)
-		return;
-
-	if (!dev->midi_out_substream)
-		return;
-
-	snd_usb_caiaq_midi_send(dev, dev->midi_out_substream);
-}
-
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/caiaq-midi.h linux-2.6.30-rc3/sound/usb/caiaq/caiaq-midi.h
--- linux-2.6.30-rc2/sound/usb/caiaq/caiaq-midi.h	2009-03-23 23:12:14.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/caiaq-midi.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-#ifndef CAIAQ_MIDI_H
-#define CAIAQ_MIDI_H
-
-int snd_usb_caiaq_midi_init(struct snd_usb_caiaqdev *dev);
-void snd_usb_caiaq_midi_handle_input(struct snd_usb_caiaqdev *dev, int port, const char *buf, int len);
-void snd_usb_caiaq_midi_output_done(struct urb* urb);
-
-#endif /* CAIAQ_MIDI_H */
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/control.c linux-2.6.30-rc3/sound/usb/caiaq/control.c
--- linux-2.6.30-rc2/sound/usb/caiaq/control.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/control.c	2009-04-22 03:29:18.610931485 +0000
@@ -0,0 +1,332 @@
+/*
+ *   Copyright (c) 2007 Daniel Mack
+ *   friendly supported by NI.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+
+#include "device.h"
+#include "control.h"
+
+#define CNT_INTVAL 0x10000
+
+static int control_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_usb_audio *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_usb_caiaqdev *dev = caiaqdev(chip->card);
+	int pos = kcontrol->private_value;
+	int is_intval = pos & CNT_INTVAL;
+	unsigned int id = dev->chip.usb_id;
+
+	uinfo->count = 1;
+	pos &= ~CNT_INTVAL;
+
+	if (id == USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ)
+		&& (pos == 0)) {
+		/* current input mode of A8DJ */
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = 2;
+		return 0;
+	}
+
+	if (id == USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ)
+		&& (pos == 0)) {
+		/* current input mode of A4DJ */
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = 1;
+		return 0;
+	}
+
+	if (is_intval) {
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = 64;
+	} else {
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = 1;
+	}
+
+	return 0;
+}
+
+static int control_get(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_usb_audio *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_usb_caiaqdev *dev = caiaqdev(chip->card);
+	int pos = kcontrol->private_value;
+
+	if (dev->chip.usb_id ==
+		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ)) {
+		/* A4DJ has only one control */
+		/* do not expose hardware input mode 0 */
+		ucontrol->value.integer.value[0] = dev->control_state[0] - 1;
+		return 0;
+	}
+
+	if (pos & CNT_INTVAL)
+		ucontrol->value.integer.value[0]
+			= dev->control_state[pos & ~CNT_INTVAL];
+	else
+		ucontrol->value.integer.value[0]
+			= !!(dev->control_state[pos / 8] & (1 << pos % 8));
+
+	return 0;
+}
+
+static int control_put(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_usb_audio *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_usb_caiaqdev *dev = caiaqdev(chip->card);
+	int pos = kcontrol->private_value;
+
+	if (dev->chip.usb_id ==
+		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ)) {
+		/* A4DJ has only one control */
+		/* do not expose hardware input mode 0 */
+		dev->control_state[0] = ucontrol->value.integer.value[0] + 1;
+		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
+				dev->control_state, sizeof(dev->control_state));
+		return 1;
+	}
+
+	if (pos & CNT_INTVAL) {
+		dev->control_state[pos & ~CNT_INTVAL]
+			= ucontrol->value.integer.value[0];
+		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
+				dev->control_state, sizeof(dev->control_state));
+	} else {
+		if (ucontrol->value.integer.value[0])
+			dev->control_state[pos / 8] |= 1 << (pos % 8);
+		else
+			dev->control_state[pos / 8] &= ~(1 << (pos % 8));
+
+		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
+				dev->control_state, sizeof(dev->control_state));
+	}
+
+	return 1;
+}
+
+static struct snd_kcontrol_new kcontrol_template __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_HWDEP,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.index = 0,
+	.info = control_info,
+	.get  = control_get,
+	.put  = control_put,
+	/* name and private_value filled later */
+};
+
+struct caiaq_controller {
+	char *name;
+	int index;
+};
+
+static struct caiaq_controller ak1_controller[] = {
+	{ "LED left", 	2 },
+	{ "LED middle", 1 },
+	{ "LED right", 	0 },
+	{ "LED ring", 	3 }
+};
+
+static struct caiaq_controller rk2_controller[] = {
+	{ "LED 1",		5  },
+	{ "LED 2",		4  },
+	{ "LED 3",		3  },
+	{ "LED 4",		2  },
+	{ "LED 5",		1  },
+	{ "LED 6",		0  },
+	{ "LED pedal",		6  },
+	{ "LED 7seg_1b",	8  },
+	{ "LED 7seg_1c",	9  },
+	{ "LED 7seg_2a",	10 },
+	{ "LED 7seg_2b",	11 },
+	{ "LED 7seg_2c",	12 },
+	{ "LED 7seg_2d",	13 },
+	{ "LED 7seg_2e",	14 },
+	{ "LED 7seg_2f",	15 },
+	{ "LED 7seg_2g",	16 },
+	{ "LED 7seg_3a",	17 },
+	{ "LED 7seg_3b",	18 },
+	{ "LED 7seg_3c",	19 },
+	{ "LED 7seg_3d",	20 },
+	{ "LED 7seg_3e",	21 },
+	{ "LED 7seg_3f",	22 },
+	{ "LED 7seg_3g",	23 }
+};
+
+static struct caiaq_controller rk3_controller[] = {
+	{ "LED 7seg_1a",        0 + 0 },
+	{ "LED 7seg_1b",        0 + 1 },
+	{ "LED 7seg_1c",        0 + 2 },
+	{ "LED 7seg_1d",        0 + 3 },
+	{ "LED 7seg_1e",        0 + 4 },
+	{ "LED 7seg_1f",        0 + 5 },
+	{ "LED 7seg_1g",        0 + 6 },
+	{ "LED 7seg_1p",        0 + 7 },
+
+	{ "LED 7seg_2a",        8 + 0 },
+	{ "LED 7seg_2b",        8 + 1 },
+	{ "LED 7seg_2c",        8 + 2 },
+	{ "LED 7seg_2d",        8 + 3 },
+	{ "LED 7seg_2e",        8 + 4 },
+	{ "LED 7seg_2f",        8 + 5 },
+	{ "LED 7seg_2g",        8 + 6 },
+	{ "LED 7seg_2p",        8 + 7 },
+
+	{ "LED 7seg_3a",        16 + 0 },
+	{ "LED 7seg_3b",        16 + 1 },
+	{ "LED 7seg_3c",        16 + 2 },
+	{ "LED 7seg_3d",        16 + 3 },
+	{ "LED 7seg_3e",        16 + 4 },
+	{ "LED 7seg_3f",        16 + 5 },
+	{ "LED 7seg_3g",        16 + 6 },
+	{ "LED 7seg_3p",        16 + 7 },
+
+	{ "LED 7seg_4a",        24 + 0 },
+	{ "LED 7seg_4b",        24 + 1 },
+	{ "LED 7seg_4c",        24 + 2 },
+	{ "LED 7seg_4d",        24 + 3 },
+	{ "LED 7seg_4e",        24 + 4 },
+	{ "LED 7seg_4f",        24 + 5 },
+	{ "LED 7seg_4g",        24 + 6 },
+	{ "LED 7seg_4p",        24 + 7 },
+
+	{ "LED 1",		32 + 0 },
+	{ "LED 2",		32 + 1 },
+	{ "LED 3",		32 + 2 },
+	{ "LED 4",		32 + 3 },
+	{ "LED 5",		32 + 4 },
+	{ "LED 6",		32 + 5 },
+	{ "LED 7",		32 + 6 },
+	{ "LED 8",		32 + 7 },
+	{ "LED pedal",		32 + 8 }
+};
+
+static struct caiaq_controller kore_controller[] = {
+	{ "LED F1",		8   | CNT_INTVAL },
+	{ "LED F2",		12  | CNT_INTVAL },
+	{ "LED F3",		0   | CNT_INTVAL },
+	{ "LED F4",		4   | CNT_INTVAL },
+	{ "LED F5",		11  | CNT_INTVAL },
+	{ "LED F6",		15  | CNT_INTVAL },
+	{ "LED F7",		3   | CNT_INTVAL },
+	{ "LED F8",		7   | CNT_INTVAL },
+	{ "LED touch1",	     	10  | CNT_INTVAL },
+	{ "LED touch2",	     	14  | CNT_INTVAL },
+	{ "LED touch3",	     	2   | CNT_INTVAL },
+	{ "LED touch4",	     	6   | CNT_INTVAL },
+	{ "LED touch5",	     	9   | CNT_INTVAL },
+	{ "LED touch6",	     	13  | CNT_INTVAL },
+	{ "LED touch7",	     	1   | CNT_INTVAL },
+	{ "LED touch8",	     	5   | CNT_INTVAL },
+	{ "LED left",	       	18  | CNT_INTVAL },
+	{ "LED right",	     	22  | CNT_INTVAL },
+	{ "LED up",		16  | CNT_INTVAL },
+	{ "LED down",	       	20  | CNT_INTVAL },
+	{ "LED stop",	       	23  | CNT_INTVAL },
+	{ "LED play",	       	21  | CNT_INTVAL },
+	{ "LED record",	     	19  | CNT_INTVAL },
+	{ "LED listen",		17  | CNT_INTVAL },
+	{ "LED lcd",		30  | CNT_INTVAL },
+	{ "LED menu",		28  | CNT_INTVAL },
+	{ "LED sound",	 	31  | CNT_INTVAL },
+	{ "LED esc",		29  | CNT_INTVAL },
+	{ "LED view",		27  | CNT_INTVAL },
+	{ "LED enter",		24  | CNT_INTVAL },
+	{ "LED control",	26  | CNT_INTVAL }
+};
+
+static struct caiaq_controller a8dj_controller[] = {
+	{ "Current input mode",			0 | CNT_INTVAL 	},
+	{ "GND lift for TC Vinyl mode", 	24 + 0 		},
+	{ "GND lift for TC CD/Line mode", 	24 + 1 		},
+	{ "GND lift for phono mode", 		24 + 2 		},
+	{ "Software lock", 			40 		}
+};
+
+static struct caiaq_controller a4dj_controller[] = {
+	{ "Current input mode",	0 | CNT_INTVAL 	}
+};
+
+static int __devinit add_controls(struct caiaq_controller *c, int num,
+				  struct snd_usb_caiaqdev *dev)
+{
+	int i, ret;
+	struct snd_kcontrol *kc;
+
+	for (i = 0; i < num; i++, c++) {
+		kcontrol_template.name = c->name;
+		kcontrol_template.private_value = c->index;
+		kc = snd_ctl_new1(&kcontrol_template, dev);
+		ret = snd_ctl_add(dev->chip.card, kc);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+int __devinit snd_usb_caiaq_control_init(struct snd_usb_caiaqdev *dev)
+{
+	int ret = 0;
+
+	switch (dev->chip.usb_id) {
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
+		ret = add_controls(ak1_controller,
+			ARRAY_SIZE(ak1_controller), dev);
+		break;
+
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
+		ret = add_controls(rk2_controller,
+			ARRAY_SIZE(rk2_controller), dev);
+		break;
+
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
+		ret = add_controls(rk3_controller,
+			ARRAY_SIZE(rk3_controller), dev);
+		break;
+
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
+		ret = add_controls(kore_controller,
+			ARRAY_SIZE(kore_controller), dev);
+		break;
+
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):
+		ret = add_controls(a8dj_controller,
+			ARRAY_SIZE(a8dj_controller), dev);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):
+		ret = add_controls(a4dj_controller,
+			ARRAY_SIZE(a4dj_controller), dev);
+		break;
+	}
+
+	return ret;
+}
+
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/control.h linux-2.6.30-rc3/sound/usb/caiaq/control.h
--- linux-2.6.30-rc2/sound/usb/caiaq/control.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/control.h	2009-04-22 03:29:18.610931485 +0000
@@ -0,0 +1,6 @@
+#ifndef CAIAQ_CONTROL_H
+#define CAIAQ_CONTROL_H
+
+int snd_usb_caiaq_control_init(struct snd_usb_caiaqdev *dev);
+
+#endif /* CAIAQ_CONTROL_H */
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/device.c linux-2.6.30-rc3/sound/usb/caiaq/device.c
--- linux-2.6.30-rc2/sound/usb/caiaq/device.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/device.c	2009-04-22 03:29:18.610931485 +0000
@@ -0,0 +1,521 @@
+/*
+ * caiaq.c: ALSA driver for caiaq/NativeInstruments devices
+ *
+ *   Copyright (c) 2007 Daniel Mack <daniel@caiaq.de>
+ *                      Karsten Wiese <fzu@wemgehoertderstaat.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <sound/initval.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+
+#include "device.h"
+#include "audio.h"
+#include "midi.h"
+#include "control.h"
+#include "input.h"
+
+MODULE_AUTHOR("Daniel Mack <daniel@caiaq.de>");
+MODULE_DESCRIPTION("caiaq USB audio, version 1.3.13");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Native Instruments, RigKontrol2},"
+			 "{Native Instruments, RigKontrol3},"
+			 "{Native Instruments, Kore Controller},"
+			 "{Native Instruments, Kore Controller 2},"
+			 "{Native Instruments, Audio Kontrol 1},"
+			 "{Native Instruments, Audio 4 DJ},"
+			 "{Native Instruments, Audio 8 DJ},"
+			 "{Native Instruments, Session I/O},"
+			 "{Native Instruments, GuitarRig mobile}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX; /* Index 0-max */
+static char* id[SNDRV_CARDS] = SNDRV_DEFAULT_STR; /* Id for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; /* Enable this card */
+static int snd_card_used[SNDRV_CARDS];
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for the caiaq sound device");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for the caiaq soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable the caiaq soundcard.");
+
+enum {
+	SAMPLERATE_44100	= 0,
+	SAMPLERATE_48000	= 1,
+	SAMPLERATE_96000	= 2,
+	SAMPLERATE_192000	= 3,
+	SAMPLERATE_88200	= 4,
+	SAMPLERATE_INVALID	= 0xff
+};
+
+enum {
+	DEPTH_NONE	= 0,
+	DEPTH_16	= 1,
+	DEPTH_24	= 2,
+	DEPTH_32	= 3
+};
+
+static struct usb_device_id snd_usb_id_table[] = {
+	{
+		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =	USB_PID_RIGKONTROL2 
+	},
+	{
+		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =	USB_PID_RIGKONTROL3
+	},
+	{
+		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =	USB_PID_KORECONTROLLER
+	},
+	{
+		.match_flags =	USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =	USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =	USB_PID_KORECONTROLLER2
+	},
+	{
+		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =    USB_PID_AK1
+	},
+	{
+		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =    USB_PID_AUDIO8DJ
+	},
+	{
+		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =    USB_PID_SESSIONIO
+	},
+	{
+		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =    USB_PID_GUITARRIGMOBILE
+	},
+	{
+		.match_flags =  USB_DEVICE_ID_MATCH_DEVICE,
+		.idVendor =     USB_VID_NATIVEINSTRUMENTS,
+		.idProduct =    USB_PID_AUDIO4DJ
+	},
+	{ /* terminator */ }
+};
+
+static void usb_ep1_command_reply_dispatch (struct urb* urb)
+{
+	int ret;
+	struct snd_usb_caiaqdev *dev = urb->context;
+	unsigned char *buf = urb->transfer_buffer;
+
+	if (urb->status || !dev) {
+		log("received EP1 urb->status = %i\n", urb->status);
+		return;
+	}
+
+	switch(buf[0]) {
+	case EP1_CMD_GET_DEVICE_INFO:
+	 	memcpy(&dev->spec, buf+1, sizeof(struct caiaq_device_spec));
+		dev->spec.fw_version = le16_to_cpu(dev->spec.fw_version);
+		debug("device spec (firmware %d): audio: %d in, %d out, "
+			"MIDI: %d in, %d out, data alignment %d\n",
+			dev->spec.fw_version,
+			dev->spec.num_analog_audio_in,
+			dev->spec.num_analog_audio_out,
+			dev->spec.num_midi_in,
+			dev->spec.num_midi_out,
+			dev->spec.data_alignment);
+
+		dev->spec_received++;
+		wake_up(&dev->ep1_wait_queue);
+		break;
+	case EP1_CMD_AUDIO_PARAMS:
+		dev->audio_parm_answer = buf[1];
+		wake_up(&dev->ep1_wait_queue);
+		break;
+	case EP1_CMD_MIDI_READ:
+		snd_usb_caiaq_midi_handle_input(dev, buf[1], buf + 3, buf[2]);
+		break;
+	case EP1_CMD_READ_IO:
+		if (dev->chip.usb_id ==
+			USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ)) {
+			if (urb->actual_length > sizeof(dev->control_state))
+				urb->actual_length = sizeof(dev->control_state);
+			memcpy(dev->control_state, buf + 1, urb->actual_length);
+			wake_up(&dev->ep1_wait_queue);
+			break;
+		}
+#ifdef CONFIG_SND_USB_CAIAQ_INPUT
+	case EP1_CMD_READ_ERP:
+	case EP1_CMD_READ_ANALOG:
+		snd_usb_caiaq_input_dispatch(dev, buf, urb->actual_length);
+#endif
+		break;
+	}
+
+	dev->ep1_in_urb.actual_length = 0;
+	ret = usb_submit_urb(&dev->ep1_in_urb, GFP_ATOMIC);
+	if (ret < 0)
+		log("unable to submit urb. OOM!?\n");
+}
+
+int snd_usb_caiaq_send_command(struct snd_usb_caiaqdev *dev,
+			       unsigned char command,
+			       const unsigned char *buffer,
+			       int len)
+{
+	int actual_len;
+	struct usb_device *usb_dev = dev->chip.dev;
+
+	if (!usb_dev)
+		return -EIO;
+
+	if (len > EP1_BUFSIZE - 1)
+		len = EP1_BUFSIZE - 1;
+
+	if (buffer && len > 0)
+		memcpy(dev->ep1_out_buf+1, buffer, len);
+	
+	dev->ep1_out_buf[0] = command;
+	return usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, 1),
+			   dev->ep1_out_buf, len+1, &actual_len, 200);
+}
+
+int snd_usb_caiaq_set_audio_params (struct snd_usb_caiaqdev *dev,
+		   		    int rate, int depth, int bpp)
+{
+	int ret;
+	char tmp[5];
+	
+	switch (rate) {
+	case 44100:	tmp[0] = SAMPLERATE_44100;   break;
+	case 48000:	tmp[0] = SAMPLERATE_48000;   break;
+	case 88200:	tmp[0] = SAMPLERATE_88200;   break;
+	case 96000:	tmp[0] = SAMPLERATE_96000;   break;
+	case 192000:	tmp[0] = SAMPLERATE_192000;  break;
+	default:	return -EINVAL;
+	}
+
+	switch (depth) {
+	case 16:	tmp[1] = DEPTH_16;   break;
+	case 24:	tmp[1] = DEPTH_24;   break;
+	default:	return -EINVAL;
+	}
+
+	tmp[2] = bpp & 0xff;
+	tmp[3] = bpp >> 8;
+	tmp[4] = 1; /* packets per microframe */
+
+	debug("setting audio params: %d Hz, %d bits, %d bpp\n",
+		rate, depth, bpp);
+
+	dev->audio_parm_answer = -1;
+	ret = snd_usb_caiaq_send_command(dev, EP1_CMD_AUDIO_PARAMS,
+					 tmp, sizeof(tmp));
+
+	if (ret)
+		return ret;
+	
+	if (!wait_event_timeout(dev->ep1_wait_queue, 
+	    dev->audio_parm_answer >= 0, HZ))
+		return -EPIPE;
+		
+	if (dev->audio_parm_answer != 1) 
+		debug("unable to set the device's audio params\n");
+	else
+		dev->bpp = bpp;
+
+	return dev->audio_parm_answer == 1 ? 0 : -EINVAL;
+}
+
+int snd_usb_caiaq_set_auto_msg (struct snd_usb_caiaqdev *dev, 
+				int digital, int analog, int erp)
+{
+	char tmp[3] = { digital, analog, erp };
+	return snd_usb_caiaq_send_command(dev, EP1_CMD_AUTO_MSG,
+					  tmp, sizeof(tmp));
+}
+
+static void __devinit setup_card(struct snd_usb_caiaqdev *dev)
+{
+	int ret;
+	char val[4];
+	
+	/* device-specific startup specials */
+	switch (dev->chip.usb_id) {
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
+		/* RigKontrol2 - display centered dash ('-') */
+		val[0] = 0x00;
+		val[1] = 0x00;
+		val[2] = 0x01;
+		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO, val, 3);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
+		/* RigKontrol2 - display two centered dashes ('--') */
+		val[0] = 0x00;
+		val[1] = 0x40;
+		val[2] = 0x40;
+		val[3] = 0x00;
+		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO, val, 4);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
+		/* Audio Kontrol 1 - make USB-LED stop blinking */
+		val[0] = 0x00;
+		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO, val, 1);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):
+		/* Audio 8 DJ - trigger read of current settings */
+		dev->control_state[0] = 0xff;
+		snd_usb_caiaq_set_auto_msg(dev, 1, 0, 0);
+		snd_usb_caiaq_send_command(dev, EP1_CMD_READ_IO, NULL, 0);
+
+		if (!wait_event_timeout(dev->ep1_wait_queue,
+					dev->control_state[0] != 0xff, HZ))
+			return;
+
+		/* fix up some defaults */
+		if ((dev->control_state[1] != 2) ||
+		    (dev->control_state[2] != 3) ||
+		    (dev->control_state[4] != 2)) {
+			dev->control_state[1] = 2;
+			dev->control_state[2] = 3;
+			dev->control_state[4] = 2;
+			snd_usb_caiaq_send_command(dev,
+				EP1_CMD_WRITE_IO, dev->control_state, 6);
+		}
+
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):
+		/* Audio 4 DJ - default input mode to phono */
+		dev->control_state[0] = 2;
+		snd_usb_caiaq_send_command(dev, EP1_CMD_WRITE_IO,
+			dev->control_state, 1);
+		break;
+	}
+	
+	if (dev->spec.num_analog_audio_out +
+	    dev->spec.num_analog_audio_in +
+	    dev->spec.num_digital_audio_out +
+	    dev->spec.num_digital_audio_in > 0) {
+		ret = snd_usb_caiaq_audio_init(dev);
+		if (ret < 0)
+			log("Unable to set up audio system (ret=%d)\n", ret);
+	}
+	
+	if (dev->spec.num_midi_in +
+	    dev->spec.num_midi_out > 0) {
+		ret = snd_usb_caiaq_midi_init(dev);
+		if (ret < 0)
+			log("Unable to set up MIDI system (ret=%d)\n", ret);
+	}
+
+#ifdef CONFIG_SND_USB_CAIAQ_INPUT
+	ret = snd_usb_caiaq_input_init(dev);
+	if (ret < 0)
+		log("Unable to set up input system (ret=%d)\n", ret);
+#endif
+
+	/* finally, register the card and all its sub-instances */
+	ret = snd_card_register(dev->chip.card);
+	if (ret < 0) {
+		log("snd_card_register() returned %d\n", ret);
+		snd_card_free(dev->chip.card);
+	}
+
+	ret = snd_usb_caiaq_control_init(dev);
+	if (ret < 0)
+		log("Unable to set up control system (ret=%d)\n", ret);
+}
+
+static int create_card(struct usb_device* usb_dev, struct snd_card **cardp)
+{
+	int devnum;
+	int err;
+	struct snd_card *card;
+	struct snd_usb_caiaqdev *dev;
+
+	for (devnum = 0; devnum < SNDRV_CARDS; devnum++)
+		if (enable[devnum] && !snd_card_used[devnum])
+			break;
+
+	if (devnum >= SNDRV_CARDS)
+		return -ENODEV;
+
+	err = snd_card_create(index[devnum], id[devnum], THIS_MODULE, 
+			      sizeof(struct snd_usb_caiaqdev), &card);
+	if (err < 0)
+		return err;
+
+	dev = caiaqdev(card);
+	dev->chip.dev = usb_dev;
+	dev->chip.card = card;
+	dev->chip.usb_id = USB_ID(le16_to_cpu(usb_dev->descriptor.idVendor),
+				  le16_to_cpu(usb_dev->descriptor.idProduct));
+	spin_lock_init(&dev->spinlock);
+	snd_card_set_dev(card, &usb_dev->dev);
+
+	*cardp = card;
+	return 0;
+}
+
+static int __devinit init_card(struct snd_usb_caiaqdev *dev)
+{
+	char *c;
+	struct usb_device *usb_dev = dev->chip.dev;
+	struct snd_card *card = dev->chip.card;
+	int err, len;
+	
+	if (usb_set_interface(usb_dev, 0, 1) != 0) {
+		log("can't set alt interface.\n");
+		return -EIO;
+	}
+
+	usb_init_urb(&dev->ep1_in_urb);
+	usb_init_urb(&dev->midi_out_urb);
+
+	usb_fill_bulk_urb(&dev->ep1_in_urb, usb_dev, 
+			  usb_rcvbulkpipe(usb_dev, 0x1),
+			  dev->ep1_in_buf, EP1_BUFSIZE, 
+			  usb_ep1_command_reply_dispatch, dev);
+
+	usb_fill_bulk_urb(&dev->midi_out_urb, usb_dev, 
+			  usb_sndbulkpipe(usb_dev, 0x1),
+			  dev->midi_out_buf, EP1_BUFSIZE, 
+			  snd_usb_caiaq_midi_output_done, dev);
+	
+	init_waitqueue_head(&dev->ep1_wait_queue);
+	init_waitqueue_head(&dev->prepare_wait_queue);
+	
+	if (usb_submit_urb(&dev->ep1_in_urb, GFP_KERNEL) != 0)
+		return -EIO;
+
+	err = snd_usb_caiaq_send_command(dev, EP1_CMD_GET_DEVICE_INFO, NULL, 0);
+	if (err)
+		return err;
+
+	if (!wait_event_timeout(dev->ep1_wait_queue, dev->spec_received, HZ))
+		return -ENODEV;
+
+	usb_string(usb_dev, usb_dev->descriptor.iManufacturer,
+		   dev->vendor_name, CAIAQ_USB_STR_LEN);
+	
+	usb_string(usb_dev, usb_dev->descriptor.iProduct,
+		   dev->product_name, CAIAQ_USB_STR_LEN);
+	
+	usb_string(usb_dev, usb_dev->descriptor.iSerialNumber,
+		   dev->serial, CAIAQ_USB_STR_LEN);
+
+	/* terminate serial string at first white space occurence */
+	c = strchr(dev->serial, ' ');
+	if (c)
+		*c = '\0';
+	
+	strcpy(card->driver, MODNAME);
+	strcpy(card->shortname, dev->product_name);
+
+	len = snprintf(card->longname, sizeof(card->longname),
+		       "%s %s (serial %s, ",
+		       dev->vendor_name, dev->product_name, dev->serial);
+
+	if (len < sizeof(card->longname) - 2)
+		len += usb_make_path(usb_dev, card->longname + len,
+				     sizeof(card->longname) - len);
+
+	card->longname[len++] = ')';
+	card->longname[len] = '\0';
+	setup_card(dev);
+	return 0;
+}
+
+static int __devinit snd_probe(struct usb_interface *intf, 
+		     const struct usb_device_id *id)
+{
+	int ret;
+	struct snd_card *card;
+	struct usb_device *device = interface_to_usbdev(intf);
+	
+	ret = create_card(device, &card);
+	
+	if (ret < 0)
+		return ret;
+			
+	usb_set_intfdata(intf, card);
+	ret = init_card(caiaqdev(card));
+	if (ret < 0) {
+		log("unable to init card! (ret=%d)\n", ret);
+		snd_card_free(card);
+		return ret;
+	}
+	
+	return 0;
+}
+
+static void snd_disconnect(struct usb_interface *intf)
+{
+	struct snd_usb_caiaqdev *dev;
+	struct snd_card *card = usb_get_intfdata(intf);
+
+	debug("%s(%p)\n", __func__, intf);
+
+	if (!card)
+		return;
+
+	dev = caiaqdev(card);
+	snd_card_disconnect(card);
+
+#ifdef CONFIG_SND_USB_CAIAQ_INPUT
+	snd_usb_caiaq_input_free(dev);
+#endif
+	snd_usb_caiaq_audio_free(dev);
+	
+	usb_kill_urb(&dev->ep1_in_urb);
+	usb_kill_urb(&dev->midi_out_urb);
+	
+	snd_card_free(card);
+	usb_reset_device(interface_to_usbdev(intf));
+}
+
+
+MODULE_DEVICE_TABLE(usb, snd_usb_id_table);
+static struct usb_driver snd_usb_driver = {
+	.name 		= MODNAME,
+	.probe 		= snd_probe,
+	.disconnect	= snd_disconnect,
+	.id_table 	= snd_usb_id_table,
+};
+
+static int __init snd_module_init(void)
+{
+	return usb_register(&snd_usb_driver);
+}
+
+static void __exit snd_module_exit(void)
+{
+	usb_deregister(&snd_usb_driver);
+}
+
+module_init(snd_module_init)
+module_exit(snd_module_exit)
+
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/device.h linux-2.6.30-rc3/sound/usb/caiaq/device.h
--- linux-2.6.30-rc2/sound/usb/caiaq/device.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/device.h	2009-04-22 03:29:18.610931485 +0000
@@ -0,0 +1,131 @@
+#ifndef CAIAQ_DEVICE_H
+#define CAIAQ_DEVICE_H
+
+#include "../usbaudio.h"
+
+#define USB_VID_NATIVEINSTRUMENTS 0x17cc
+
+#define USB_PID_RIGKONTROL2	0x1969
+#define USB_PID_RIGKONTROL3	0x1940
+#define USB_PID_KORECONTROLLER	0x4711
+#define USB_PID_KORECONTROLLER2	0x4712
+#define USB_PID_AK1		0x0815
+#define USB_PID_AUDIO4DJ	0x0839
+#define USB_PID_AUDIO8DJ	0x1978
+#define USB_PID_SESSIONIO	0x1915
+#define USB_PID_GUITARRIGMOBILE	0x0d8d
+
+#define EP1_BUFSIZE 64
+#define CAIAQ_USB_STR_LEN 0xff
+#define MAX_STREAMS 32
+
+//#define	SND_USB_CAIAQ_DEBUG
+
+#define MODNAME "snd-usb-caiaq"
+#define log(x...) snd_printk(KERN_WARNING MODNAME" log: " x)
+
+#ifdef SND_USB_CAIAQ_DEBUG
+#define debug(x...) snd_printk(KERN_WARNING MODNAME " debug: " x)
+#else
+#define debug(x...) do { } while(0)
+#endif
+
+#define EP1_CMD_GET_DEVICE_INFO	0x1
+#define EP1_CMD_READ_ERP	0x2
+#define EP1_CMD_READ_ANALOG	0x3
+#define EP1_CMD_READ_IO		0x4
+#define EP1_CMD_WRITE_IO	0x5
+#define EP1_CMD_MIDI_READ	0x6
+#define EP1_CMD_MIDI_WRITE	0x7
+#define EP1_CMD_AUDIO_PARAMS	0x9
+#define EP1_CMD_AUTO_MSG	0xb
+#define EP1_CMD_DIMM_LEDS       0xc
+
+struct caiaq_device_spec {
+	unsigned short fw_version;
+	unsigned char hw_subtype;
+	unsigned char num_erp;
+	unsigned char num_analog_in;
+	unsigned char num_digital_in;
+	unsigned char num_digital_out;
+	unsigned char num_analog_audio_out;
+	unsigned char num_analog_audio_in;
+	unsigned char num_digital_audio_out;
+	unsigned char num_digital_audio_in;
+	unsigned char num_midi_out;
+	unsigned char num_midi_in;
+	unsigned char data_alignment;
+} __attribute__ ((packed));
+
+struct snd_usb_caiaq_cb_info;
+
+struct snd_usb_caiaqdev {
+	struct snd_usb_audio chip;
+
+	struct urb ep1_in_urb;
+	struct urb midi_out_urb;
+	struct urb **data_urbs_in;
+	struct urb **data_urbs_out;
+	struct snd_usb_caiaq_cb_info *data_cb_info;
+
+	unsigned char ep1_in_buf[EP1_BUFSIZE];
+	unsigned char ep1_out_buf[EP1_BUFSIZE];
+	unsigned char midi_out_buf[EP1_BUFSIZE];
+
+	struct caiaq_device_spec spec;
+	spinlock_t spinlock;
+	wait_queue_head_t ep1_wait_queue;
+	wait_queue_head_t prepare_wait_queue;
+	int spec_received, audio_parm_answer;
+	int midi_out_active;
+
+	char vendor_name[CAIAQ_USB_STR_LEN];
+	char product_name[CAIAQ_USB_STR_LEN];
+	char serial[CAIAQ_USB_STR_LEN];
+
+	int n_streams, n_audio_in, n_audio_out;
+	int streaming, first_packet, output_running;
+	int audio_in_buf_pos[MAX_STREAMS];
+	int audio_out_buf_pos[MAX_STREAMS];
+	int period_in_count[MAX_STREAMS];
+	int period_out_count[MAX_STREAMS];
+	int input_panic, output_panic, warned;
+	char *audio_in_buf, *audio_out_buf;
+	unsigned int samplerates, bpp;
+
+	struct snd_pcm_substream *sub_playback[MAX_STREAMS];
+	struct snd_pcm_substream *sub_capture[MAX_STREAMS];
+
+	/* Controls */
+	unsigned char control_state[64];
+
+	/* Linux input */
+#ifdef CONFIG_SND_USB_CAIAQ_INPUT
+	struct input_dev *input_dev;
+	char phys[64];			/* physical device path */
+	unsigned short keycode[64];
+#endif
+
+	/* ALSA */
+	struct snd_pcm *pcm;
+	struct snd_pcm_hardware pcm_info;
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_substream *midi_receive_substream;
+	struct snd_rawmidi_substream *midi_out_substream;
+};
+
+struct snd_usb_caiaq_cb_info {
+	struct snd_usb_caiaqdev *dev;
+	int index;
+};
+
+#define caiaqdev(c) ((struct snd_usb_caiaqdev*)(c)->private_data)
+
+int snd_usb_caiaq_set_audio_params (struct snd_usb_caiaqdev *dev, int rate, int depth, int bbp);
+int snd_usb_caiaq_set_auto_msg (struct snd_usb_caiaqdev *dev, int digital, int analog, int erp);
+int snd_usb_caiaq_send_command(struct snd_usb_caiaqdev *dev,
+			       unsigned char command,
+			       const unsigned char *buffer,
+			       int len);
+
+#endif /* CAIAQ_DEVICE_H */
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/input.c linux-2.6.30-rc3/sound/usb/caiaq/input.c
--- linux-2.6.30-rc2/sound/usb/caiaq/input.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/input.c	2009-04-22 03:29:18.610931485 +0000
@@ -0,0 +1,358 @@
+/*
+ *   Copyright (c) 2006,2007 Daniel Mack, Tim Ruetz
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <sound/pcm.h>
+
+#include "device.h"
+#include "input.h"
+
+static unsigned short keycode_ak1[] =  { KEY_C, KEY_B, KEY_A };
+static unsigned short keycode_rk2[] =  { KEY_1, KEY_2, KEY_3, KEY_4,
+					 KEY_5, KEY_6, KEY_7 };
+static unsigned short keycode_rk3[] =  { KEY_1, KEY_2, KEY_3, KEY_4,
+					 KEY_5, KEY_6, KEY_7, KEY_5, KEY_6 };
+
+static unsigned short keycode_kore[] = {
+	KEY_FN_F1,      /* "menu"               */
+	KEY_FN_F7,      /* "lcd backlight       */
+	KEY_FN_F2,      /* "control"            */
+	KEY_FN_F3,      /* "enter"              */
+	KEY_FN_F4,      /* "view"               */
+	KEY_FN_F5,      /* "esc"                */
+	KEY_FN_F6,      /* "sound"              */
+	KEY_FN_F8,      /* array spacer, never triggered. */
+	KEY_RIGHT,
+	KEY_DOWN,
+	KEY_UP,
+	KEY_LEFT,
+	KEY_SOUND,      /* "listen"             */
+	KEY_RECORD,
+	KEY_PLAYPAUSE,
+	KEY_STOP,
+	BTN_4,          /* 8 softkeys */
+	BTN_3,
+	BTN_2,
+	BTN_1,
+	BTN_8,
+	BTN_7,
+	BTN_6,
+	BTN_5,
+	KEY_BRL_DOT4,   /* touch sensitive knobs */
+	KEY_BRL_DOT3,
+	KEY_BRL_DOT2,
+	KEY_BRL_DOT1,
+	KEY_BRL_DOT8,
+	KEY_BRL_DOT7,
+	KEY_BRL_DOT6,
+	KEY_BRL_DOT5
+};
+
+#define DEG90		(range / 2)
+#define DEG180		(range)
+#define DEG270		(DEG90 + DEG180)
+#define DEG360		(DEG180 * 2)
+#define HIGH_PEAK	(268)
+#define LOW_PEAK	(-7)
+
+/* some of these devices have endless rotation potentiometers
+ * built in which use two tapers, 90 degrees phase shifted.
+ * this algorithm decodes them to one single value, ranging
+ * from 0 to 999 */
+static unsigned int decode_erp(unsigned char a, unsigned char b)
+{
+	int weight_a, weight_b;
+	int pos_a, pos_b;
+	int ret;
+	int range = HIGH_PEAK - LOW_PEAK;
+	int mid_value = (HIGH_PEAK + LOW_PEAK) / 2;
+
+	weight_b = abs(mid_value - a) - (range / 2 - 100) / 2;
+
+	if (weight_b < 0)
+		weight_b = 0;
+
+	if (weight_b > 100)
+		weight_b = 100;
+
+	weight_a = 100 - weight_b;
+
+	if (a < mid_value) {
+		/* 0..90 and 270..360 degrees */
+		pos_b = b - LOW_PEAK + DEG270;
+		if (pos_b >= DEG360)
+			pos_b -= DEG360;
+	} else
+		/* 90..270 degrees */
+		pos_b = HIGH_PEAK - b + DEG90;
+
+
+	if (b > mid_value)
+		/* 0..180 degrees */
+		pos_a = a - LOW_PEAK;
+	else
+		/* 180..360 degrees */
+		pos_a = HIGH_PEAK - a + DEG180;
+
+	/* interpolate both slider values, depending on weight factors */
+	/* 0..99 x DEG360 */
+	ret = pos_a * weight_a + pos_b * weight_b;
+
+	/* normalize to 0..999 */
+	ret *= 10;
+	ret /= DEG360;
+
+	if (ret < 0)
+		ret += 1000;
+
+	if (ret >= 1000)
+		ret -= 1000;
+
+	return ret;
+}
+
+#undef DEG90
+#undef DEG180
+#undef DEG270
+#undef DEG360
+#undef HIGH_PEAK
+#undef LOW_PEAK
+
+
+static void snd_caiaq_input_read_analog(struct snd_usb_caiaqdev *dev,
+					const unsigned char *buf,
+					unsigned int len)
+{
+	struct input_dev *input_dev = dev->input_dev;
+
+	switch (dev->chip.usb_id) {
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
+		input_report_abs(input_dev, ABS_X, (buf[4] << 8) | buf[5]);
+		input_report_abs(input_dev, ABS_Y, (buf[0] << 8) | buf[1]);
+		input_report_abs(input_dev, ABS_Z, (buf[2] << 8) | buf[3]);
+		input_sync(input_dev);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
+		input_report_abs(input_dev, ABS_X, (buf[0] << 8) | buf[1]);
+		input_report_abs(input_dev, ABS_Y, (buf[2] << 8) | buf[3]);
+		input_report_abs(input_dev, ABS_Z, (buf[4] << 8) | buf[5]);
+		input_sync(input_dev);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
+		input_report_abs(input_dev, ABS_X, (buf[0] << 8) | buf[1]);
+		input_report_abs(input_dev, ABS_Y, (buf[2] << 8) | buf[3]);
+		input_report_abs(input_dev, ABS_Z, (buf[4] << 8) | buf[5]);
+		input_sync(input_dev);
+		break;
+	}
+}
+
+static void snd_caiaq_input_read_erp(struct snd_usb_caiaqdev *dev,
+				     const char *buf, unsigned int len)
+{
+	struct input_dev *input_dev = dev->input_dev;
+	int i;
+
+	switch (dev->chip.usb_id) {
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
+		i = decode_erp(buf[0], buf[1]);
+		input_report_abs(input_dev, ABS_X, i);
+		input_sync(input_dev);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
+		i = decode_erp(buf[7], buf[5]);
+		input_report_abs(input_dev, ABS_HAT0X, i);
+		i = decode_erp(buf[12], buf[14]);
+		input_report_abs(input_dev, ABS_HAT0Y, i);
+		i = decode_erp(buf[15], buf[13]);
+		input_report_abs(input_dev, ABS_HAT1X, i);
+		i = decode_erp(buf[0], buf[2]);
+		input_report_abs(input_dev, ABS_HAT1Y, i);
+		i = decode_erp(buf[3], buf[1]);
+		input_report_abs(input_dev, ABS_HAT2X, i);
+		i = decode_erp(buf[8], buf[10]);
+		input_report_abs(input_dev, ABS_HAT2Y, i);
+		i = decode_erp(buf[11], buf[9]);
+		input_report_abs(input_dev, ABS_HAT3X, i);
+		i = decode_erp(buf[4], buf[6]);
+		input_report_abs(input_dev, ABS_HAT3Y, i);
+		input_sync(input_dev);
+		break;
+	}
+}
+
+static void snd_caiaq_input_read_io(struct snd_usb_caiaqdev *dev,
+				    char *buf, unsigned int len)
+{
+	struct input_dev *input_dev = dev->input_dev;
+	unsigned short *keycode = input_dev->keycode;
+	int i;
+
+	if (!keycode)
+		return;
+
+	if (input_dev->id.product == USB_PID_RIGKONTROL2)
+		for (i = 0; i < len; i++)
+			buf[i] = ~buf[i];
+
+	for (i = 0; i < input_dev->keycodemax && i < len * 8; i++)
+		input_report_key(input_dev, keycode[i],
+				 buf[i / 8] & (1 << (i % 8)));
+
+	if (dev->chip.usb_id ==
+		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER) ||
+	    dev->chip.usb_id ==
+		USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2))
+		input_report_abs(dev->input_dev, ABS_MISC, 255 - buf[4]);
+
+	input_sync(input_dev);
+}
+
+void snd_usb_caiaq_input_dispatch(struct snd_usb_caiaqdev *dev,
+				  char *buf,
+				  unsigned int len)
+{
+	if (!dev->input_dev || len < 1)
+		return;
+
+	switch (buf[0]) {
+	case EP1_CMD_READ_ANALOG:
+		snd_caiaq_input_read_analog(dev, buf + 1, len - 1);
+		break;
+	case EP1_CMD_READ_ERP:
+		snd_caiaq_input_read_erp(dev, buf + 1, len - 1);
+		break;
+	case EP1_CMD_READ_IO:
+		snd_caiaq_input_read_io(dev, buf + 1, len - 1);
+		break;
+	}
+}
+
+int snd_usb_caiaq_input_init(struct snd_usb_caiaqdev *dev)
+{
+	struct usb_device *usb_dev = dev->chip.dev;
+	struct input_dev *input;
+	int i, ret;
+
+	input = input_allocate_device();
+	if (!input)
+		return -ENOMEM;
+
+	usb_make_path(usb_dev, dev->phys, sizeof(dev->phys));
+	strlcat(dev->phys, "/input0", sizeof(dev->phys));
+
+	input->name = dev->product_name;
+	input->phys = dev->phys;
+	usb_to_input_id(usb_dev, &input->id);
+	input->dev.parent = &usb_dev->dev;
+
+        switch (dev->chip.usb_id) {
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL2):
+		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+		input->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |
+			BIT_MASK(ABS_Z);
+		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_rk2));
+		memcpy(dev->keycode, keycode_rk2, sizeof(keycode_rk2));
+		input->keycodemax = ARRAY_SIZE(keycode_rk2);
+		input_set_abs_params(input, ABS_X, 0, 4096, 0, 10);
+		input_set_abs_params(input, ABS_Y, 0, 4096, 0, 10);
+		input_set_abs_params(input, ABS_Z, 0, 4096, 0, 10);
+		snd_usb_caiaq_set_auto_msg(dev, 1, 10, 0);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):
+		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+		input->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |
+			BIT_MASK(ABS_Z);
+		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_rk3));
+		memcpy(dev->keycode, keycode_rk3, sizeof(keycode_rk3));
+		input->keycodemax = ARRAY_SIZE(keycode_rk3);
+		input_set_abs_params(input, ABS_X, 0, 1024, 0, 10);
+		input_set_abs_params(input, ABS_Y, 0, 1024, 0, 10);
+		input_set_abs_params(input, ABS_Z, 0, 1024, 0, 10);
+		snd_usb_caiaq_set_auto_msg(dev, 1, 10, 0);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):
+		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+		input->absbit[0] = BIT_MASK(ABS_X);
+		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_ak1));
+		memcpy(dev->keycode, keycode_ak1, sizeof(keycode_ak1));
+		input->keycodemax = ARRAY_SIZE(keycode_ak1);
+		input_set_abs_params(input, ABS_X, 0, 999, 0, 10);
+		snd_usb_caiaq_set_auto_msg(dev, 1, 0, 5);
+		break;
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER):
+	case USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_KORECONTROLLER2):
+		input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+		input->absbit[0] = BIT_MASK(ABS_HAT0X) | BIT_MASK(ABS_HAT0Y) |
+				   BIT_MASK(ABS_HAT1X) | BIT_MASK(ABS_HAT1Y) |
+				   BIT_MASK(ABS_HAT2X) | BIT_MASK(ABS_HAT2Y) |
+				   BIT_MASK(ABS_HAT3X) | BIT_MASK(ABS_HAT3Y) |
+				   BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |
+				   BIT_MASK(ABS_Z);
+		input->absbit[BIT_WORD(ABS_MISC)] |= BIT_MASK(ABS_MISC);
+		BUILD_BUG_ON(sizeof(dev->keycode) < sizeof(keycode_kore));
+		memcpy(dev->keycode, keycode_kore, sizeof(keycode_kore));
+		input->keycodemax = ARRAY_SIZE(keycode_kore);
+		input_set_abs_params(input, ABS_HAT0X, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_HAT0Y, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_HAT1X, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_HAT1Y, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_HAT2X, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_HAT2Y, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_HAT3X, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_HAT3Y, 0, 999, 0, 10);
+		input_set_abs_params(input, ABS_X, 0, 4096, 0, 10);
+		input_set_abs_params(input, ABS_Y, 0, 4096, 0, 10);
+		input_set_abs_params(input, ABS_Z, 0, 4096, 0, 10);
+		input_set_abs_params(input, ABS_MISC, 0, 255, 0, 1);
+		snd_usb_caiaq_set_auto_msg(dev, 1, 10, 5);
+		break;
+	default:
+		/* no input methods supported on this device */
+		input_free_device(input);
+		return 0;
+	}
+
+	input->keycode = dev->keycode;
+	input->keycodesize = sizeof(unsigned short);
+	for (i = 0; i < input->keycodemax; i++)
+		__set_bit(dev->keycode[i], input->keybit);
+
+	ret = input_register_device(input);
+	if (ret < 0) {
+		input_free_device(input);
+		return ret;
+	}
+
+	dev->input_dev = input;
+	return 0;
+}
+
+void snd_usb_caiaq_input_free(struct snd_usb_caiaqdev *dev)
+{
+	if (!dev || !dev->input_dev)
+		return;
+
+	input_unregister_device(dev->input_dev);
+	dev->input_dev = NULL;
+}
+
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/input.h linux-2.6.30-rc3/sound/usb/caiaq/input.h
--- linux-2.6.30-rc2/sound/usb/caiaq/input.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/input.h	2009-04-22 03:29:18.610931485 +0000
@@ -0,0 +1,8 @@
+#ifndef CAIAQ_INPUT_H
+#define CAIAQ_INPUT_H
+
+void snd_usb_caiaq_input_dispatch(struct snd_usb_caiaqdev *dev, char *buf, unsigned int len);
+int snd_usb_caiaq_input_init(struct snd_usb_caiaqdev *dev);
+void snd_usb_caiaq_input_free(struct snd_usb_caiaqdev *dev);
+
+#endif
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/midi.c linux-2.6.30-rc3/sound/usb/caiaq/midi.c
--- linux-2.6.30-rc2/sound/usb/caiaq/midi.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/midi.c	2009-04-22 03:29:18.611931439 +0000
@@ -0,0 +1,173 @@
+/*
+ *   Copyright (c) 2006,2007 Daniel Mack
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+#include <linux/usb.h>
+#include <sound/rawmidi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+
+#include "device.h"
+#include "midi.h"
+
+static int snd_usb_caiaq_midi_input_open(struct snd_rawmidi_substream *substream)
+{
+	return 0;
+}
+
+static int snd_usb_caiaq_midi_input_close(struct snd_rawmidi_substream *substream)
+{
+	return 0;
+}
+
+static void snd_usb_caiaq_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
+{
+	struct snd_usb_caiaqdev *dev = substream->rmidi->private_data;
+
+	if (!dev)
+		return;
+	
+	dev->midi_receive_substream = up ? substream : NULL;
+}
+
+
+static int snd_usb_caiaq_midi_output_open(struct snd_rawmidi_substream *substream)
+{
+	return 0;
+}
+
+static int snd_usb_caiaq_midi_output_close(struct snd_rawmidi_substream *substream)
+{
+	struct snd_usb_caiaqdev *dev = substream->rmidi->private_data;
+	if (dev->midi_out_active) {
+		usb_kill_urb(&dev->midi_out_urb);
+		dev->midi_out_active = 0;
+	}
+	return 0;
+}
+
+static void snd_usb_caiaq_midi_send(struct snd_usb_caiaqdev *dev,
+				    struct snd_rawmidi_substream *substream)
+{
+	int len, ret;
+	
+	dev->midi_out_buf[0] = EP1_CMD_MIDI_WRITE;
+	dev->midi_out_buf[1] = 0; /* port */
+	len = snd_rawmidi_transmit(substream, dev->midi_out_buf + 3,
+				   EP1_BUFSIZE - 3);
+	
+	if (len <= 0)
+		return;
+	
+	dev->midi_out_buf[2] = len;
+	dev->midi_out_urb.transfer_buffer_length = len+3;
+	
+	ret = usb_submit_urb(&dev->midi_out_urb, GFP_ATOMIC);
+	if (ret < 0)
+		log("snd_usb_caiaq_midi_send(%p): usb_submit_urb() failed,"
+		    "ret=%d, len=%d\n",
+		    substream, ret, len);
+	else
+		dev->midi_out_active = 1;
+}
+
+static void snd_usb_caiaq_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
+{
+	struct snd_usb_caiaqdev *dev = substream->rmidi->private_data;
+	
+	if (up) {
+		dev->midi_out_substream = substream;
+		if (!dev->midi_out_active)
+			snd_usb_caiaq_midi_send(dev, substream);
+	} else {
+		dev->midi_out_substream = NULL;
+	}
+}
+
+
+static struct snd_rawmidi_ops snd_usb_caiaq_midi_output =
+{
+	.open =		snd_usb_caiaq_midi_output_open,
+	.close =	snd_usb_caiaq_midi_output_close,
+	.trigger =      snd_usb_caiaq_midi_output_trigger,
+};
+
+static struct snd_rawmidi_ops snd_usb_caiaq_midi_input =
+{
+	.open =		snd_usb_caiaq_midi_input_open,
+	.close =	snd_usb_caiaq_midi_input_close,
+	.trigger =      snd_usb_caiaq_midi_input_trigger,
+};
+
+void snd_usb_caiaq_midi_handle_input(struct snd_usb_caiaqdev *dev, 
+				     int port, const char *buf, int len)
+{
+	if (!dev->midi_receive_substream)
+		return;
+	
+	snd_rawmidi_receive(dev->midi_receive_substream, buf, len);
+}
+
+int snd_usb_caiaq_midi_init(struct snd_usb_caiaqdev *device)
+{
+	int ret;
+	struct snd_rawmidi *rmidi;
+
+	ret = snd_rawmidi_new(device->chip.card, device->product_name, 0,
+					device->spec.num_midi_out,
+					device->spec.num_midi_in,
+					&rmidi);
+
+	if (ret < 0)
+		return ret;
+
+	strcpy(rmidi->name, device->product_name);
+
+	rmidi->info_flags = SNDRV_RAWMIDI_INFO_DUPLEX;
+	rmidi->private_data = device;
+
+	if (device->spec.num_midi_out > 0) {
+		rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
+		snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, 
+				    &snd_usb_caiaq_midi_output);
+	}
+
+	if (device->spec.num_midi_in > 0) {
+		rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
+		snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, 
+				    &snd_usb_caiaq_midi_input);
+	}
+	
+	device->rmidi = rmidi;
+
+	return 0;
+}
+
+void snd_usb_caiaq_midi_output_done(struct urb* urb)
+{
+	struct snd_usb_caiaqdev *dev = urb->context;
+	
+	dev->midi_out_active = 0;
+	if (urb->status != 0)
+		return;
+
+	if (!dev->midi_out_substream)
+		return;
+
+	snd_usb_caiaq_midi_send(dev, dev->midi_out_substream);
+}
+
diff -urN linux-2.6.30-rc2/sound/usb/caiaq/midi.h linux-2.6.30-rc3/sound/usb/caiaq/midi.h
--- linux-2.6.30-rc2/sound/usb/caiaq/midi.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.30-rc3/sound/usb/caiaq/midi.h	2009-04-22 03:29:18.611931439 +0000
@@ -0,0 +1,8 @@
+#ifndef CAIAQ_MIDI_H
+#define CAIAQ_MIDI_H
+
+int snd_usb_caiaq_midi_init(struct snd_usb_caiaqdev *dev);
+void snd_usb_caiaq_midi_handle_input(struct snd_usb_caiaqdev *dev, int port, const char *buf, int len);
+void snd_usb_caiaq_midi_output_done(struct urb* urb);
+
+#endif /* CAIAQ_MIDI_H */
diff -urN linux-2.6.30-rc2/sound/usb/usx2y/us122l.c linux-2.6.30-rc3/sound/usb/usx2y/us122l.c
--- linux-2.6.30-rc2/sound/usb/usx2y/us122l.c	2009-04-22 03:29:12.531931399 +0000
+++ linux-2.6.30-rc3/sound/usb/usx2y/us122l.c	2009-04-22 03:29:18.613931514 +0000
@@ -349,14 +349,10 @@
 	if (cmd != SNDRV_USB_STREAM_IOCTL_SET_PARAMS)
 		return -ENOTTY;
 
-	cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
-	if (!cfg)
-		return -ENOMEM;
+	cfg = memdup_user((void *)arg, sizeof(*cfg));
+	if (IS_ERR(cfg))
+		return PTR_ERR(cfg);
 
-	if (copy_from_user(cfg, (void *)arg, sizeof(*cfg))) {
-		err = -EFAULT;
-		goto free;
-	}
 	if (cfg->version != USB_STREAM_INTERFACE_VERSION) {
 		err = -ENXIO;
 		goto free;
diff -urN linux-2.6.30-rc2/sound/usb/usx2y/usX2Yhwdep.c linux-2.6.30-rc3/sound/usb/usx2y/usX2Yhwdep.c
--- linux-2.6.30-rc2/sound/usb/usx2y/usX2Yhwdep.c	2009-04-22 03:29:12.531931399 +0000
+++ linux-2.6.30-rc3/sound/usb/usx2y/usX2Yhwdep.c	2009-04-22 03:29:18.613931514 +0000
@@ -203,13 +203,12 @@
 
 	if (access_ok(VERIFY_READ, dsp->image, dsp->length)) {
 		struct usb_device* dev = priv->chip.dev;
-		char *buf = kmalloc(dsp->length, GFP_KERNEL);
-		if (!buf)
-			return -ENOMEM;
-		if (copy_from_user(buf, dsp->image, dsp->length)) {
-			kfree(buf);
-			return -EFAULT;
-		}
+		char *buf;
+
+		buf = memdup_user(dsp->image, dsp->length);
+		if (IS_ERR(buf))
+			return PTR_ERR(buf);
+
 		err = usb_set_interface(dev, 0, 1);
 		if (err)
 			snd_printk(KERN_ERR "usb_set_interface error \n");
