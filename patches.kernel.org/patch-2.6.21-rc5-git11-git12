 Makefile                          |    2 -
 drivers/ata/libata-core.c         |   38 ++++++++++++++++++++++++++++++-
 drivers/ata/libata-eh.c           |   22 +++++++++---------
 drivers/ata/libata-scsi.c         |    2 -
 drivers/net/b44.c                 |    2 -
 drivers/net/cxgb3/common.h        |    9 ++++---
 drivers/net/cxgb3/cxgb3_main.c    |   35 +++++++++++++++++++---------
 drivers/net/cxgb3/cxgb3_offload.c |    4 ++-
 drivers/net/cxgb3/mc5.c           |    3 ++
 drivers/net/cxgb3/regs.h          |    4 +++
 drivers/net/cxgb3/sge.c           |    2 -
 drivers/net/cxgb3/t3_hw.c         |   24 ++++++++++++++-----
 drivers/net/cxgb3/version.h       |    5 +++-
 drivers/net/cxgb3/xgmac.c         |    1 
 drivers/net/r8169.c               |   46 ++++++++++++++++++++------------------
 drivers/s390/cio/device_status.c  |    8 ++++++
 include/linux/ata.h               |    1 
 include/linux/libata.h            |    6 +++-
 mm/rmap.c                         |    4 +--
 mm/slab.c                         |    4 +--
 net/core/dev.c                    |   11 +++------
 21 files changed, 160 insertions(+), 73 deletions(-)
diff -purN linux-2.6.21-rc5-git11/Makefile linux-2.6.21-rc5-git12/Makefile
--- linux-2.6.21-rc5-git11/Makefile	2007-04-04 22:34:42.171215386 +0200
+++ linux-2.6.21-rc5-git12/Makefile	2007-04-04 22:34:48.571225674 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 21
-EXTRAVERSION = -rc5-git11
+EXTRAVERSION = -rc5-git12
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff -purN linux-2.6.21-rc5-git11/drivers/ata/libata-core.c linux-2.6.21-rc5-git12/drivers/ata/libata-core.c
--- linux-2.6.21-rc5-git11/drivers/ata/libata-core.c	2007-04-04 22:34:42.201215435 +0200
+++ linux-2.6.21-rc5-git12/drivers/ata/libata-core.c	2007-04-04 22:34:48.601225722 +0200
@@ -1784,6 +1784,13 @@ int ata_dev_configure(struct ata_device 
 		dev->max_sectors = ATA_MAX_SECTORS;
 	}
 
+	if (ata_device_blacklisted(dev) & ATA_HORKAGE_MAX_SEC_128)
+		dev->max_sectors = min(ATA_MAX_SECTORS_128, dev->max_sectors);
+
+	/* limit ATAPI DMA to R/W commands only */
+	if (ata_device_blacklisted(dev) & ATA_HORKAGE_DMA_RW_ONLY)
+		dev->horkage |= ATA_HORKAGE_DMA_RW_ONLY;
+
 	if (ap->ops->dev_config)
 		ap->ops->dev_config(ap, dev);
 
@@ -3352,6 +3359,10 @@ static const struct ata_blacklist_entry 
 	{ "_NEC DV5800A", 	NULL,		ATA_HORKAGE_NODMA },
 	{ "SAMSUNG CD-ROM SN-124","N001",	ATA_HORKAGE_NODMA },
 
+	/* Weird ATAPI devices */
+	{ "TORiSAN DVD-ROM DRD-N216", NULL,	ATA_HORKAGE_MAX_SEC_128 |
+						ATA_HORKAGE_DMA_RW_ONLY },
+
 	/* Devices we expect to fail diagnostics */
 
 	/* Devices where NCQ should be avoided */
@@ -3363,6 +3374,11 @@ static const struct ata_blacklist_entry 
 	{ "Maxtor 6L250S0",     "BANC1G10",     ATA_HORKAGE_NONCQ },
 	/* NCQ hard hangs device under heavier load, needs hard power cycle */
 	{ "Maxtor 6B250S0",	"BANC1B70",	ATA_HORKAGE_NONCQ },
+	/* Blacklist entries taken from Silicon Image 3124/3132
+	   Windows driver .inf file - also several Linux problem reports */
+	{ "HTS541060G9SA00",    "MB3OC60D",     ATA_HORKAGE_NONCQ, },
+	{ "HTS541080G9SA00",    "MB4OC60D",     ATA_HORKAGE_NONCQ, },
+	{ "HTS541010G9SA00",    "MBZOC60D",     ATA_HORKAGE_NONCQ, },
 
 	/* Devices with NCQ limits */
 
@@ -3674,6 +3690,26 @@ int ata_check_atapi_dma(struct ata_queue
 	struct ata_port *ap = qc->ap;
 	int rc = 0; /* Assume ATAPI DMA is OK by default */
 
+	/* some drives can only do ATAPI DMA on read/write */
+	if (unlikely(qc->dev->horkage & ATA_HORKAGE_DMA_RW_ONLY)) {
+		struct scsi_cmnd *cmd = qc->scsicmd;
+		u8 *scsicmd = cmd->cmnd;
+
+		switch (scsicmd[0]) {
+		case READ_10:
+		case WRITE_10:
+		case READ_12:
+		case WRITE_12:
+		case READ_6:
+		case WRITE_6:
+			/* atapi dma maybe ok */
+			break;
+		default:
+			/* turn off atapi dma */
+			return 1;
+		}
+	}
+
 	if (ap->ops->check_atapi_dma)
 		rc = ap->ops->check_atapi_dma(qc);
 
@@ -4717,8 +4753,8 @@ static void fill_result_tf(struct ata_qu
 {
 	struct ata_port *ap = qc->ap;
 
-	ap->ops->tf_read(ap, &qc->result_tf);
 	qc->result_tf.flags = qc->tf.flags;
+	ap->ops->tf_read(ap, &qc->result_tf);
 }
 
 /**
diff -purN linux-2.6.21-rc5-git11/drivers/ata/libata-eh.c linux-2.6.21-rc5-git12/drivers/ata/libata-eh.c
--- linux-2.6.21-rc5-git11/drivers/ata/libata-eh.c	2007-04-04 22:34:42.201215435 +0200
+++ linux-2.6.21-rc5-git12/drivers/ata/libata-eh.c	2007-04-04 22:34:48.601225722 +0200
@@ -982,26 +982,27 @@ static int ata_eh_read_log_10h(struct at
  *	RETURNS:
  *	0 on success, AC_ERR_* mask on failure
  */
-static unsigned int atapi_eh_request_sense(struct ata_device *dev,
-					   unsigned char *sense_buf)
+static unsigned int atapi_eh_request_sense(struct ata_queued_cmd *qc)
 {
+	struct ata_device *dev = qc->dev;
+	unsigned char *sense_buf = qc->scsicmd->sense_buffer;
 	struct ata_port *ap = dev->ap;
 	struct ata_taskfile tf;
 	u8 cdb[ATAPI_CDB_LEN];
 
 	DPRINTK("ATAPI request sense\n");
 
-	ata_tf_init(dev, &tf);
-
 	/* FIXME: is this needed? */
 	memset(sense_buf, 0, SCSI_SENSE_BUFFERSIZE);
 
-	/* XXX: why tf_read here? */
-	ap->ops->tf_read(ap, &tf);
-
-	/* fill these in, for the case where they are -not- overwritten */
+	/* initialize sense_buf with the error register,
+	 * for the case where they are -not- overwritten
+	 */
 	sense_buf[0] = 0x70;
-	sense_buf[2] = tf.feature >> 4;
+	sense_buf[2] = qc->result_tf.feature >> 4;
+
+	/* some devices time out if garbage left in tf */ 
+	ata_tf_init(dev, &tf);
 
 	memset(cdb, 0, ATAPI_CDB_LEN);
 	cdb[0] = REQUEST_SENSE;
@@ -1165,8 +1166,7 @@ static unsigned int ata_eh_analyze_tf(st
 
 	case ATA_DEV_ATAPI:
 		if (!(qc->ap->pflags & ATA_PFLAG_FROZEN)) {
-			tmp = atapi_eh_request_sense(qc->dev,
-						     qc->scsicmd->sense_buffer);
+			tmp = atapi_eh_request_sense(qc);
 			if (!tmp) {
 				/* ATA_QCFLAG_SENSE_VALID is used to
 				 * tell atapi_qc_complete() that sense
diff -purN linux-2.6.21-rc5-git11/drivers/ata/libata-scsi.c linux-2.6.21-rc5-git12/drivers/ata/libata-scsi.c
--- linux-2.6.21-rc5-git11/drivers/ata/libata-scsi.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/ata/libata-scsi.c	2007-04-04 22:34:48.601225722 +0200
@@ -333,7 +333,7 @@ int ata_task_ioctl(struct scsi_device *s
 	scsi_cmd[8]  = args[3];
 	scsi_cmd[10] = args[4];
 	scsi_cmd[12] = args[5];
-	scsi_cmd[13] = args[6] & 0x0f;
+	scsi_cmd[13] = args[6] & 0x4f;
 	scsi_cmd[14] = args[0];
 
 	/* Good values for timeout and retries?  Values below
diff -purN linux-2.6.21-rc5-git11/drivers/net/b44.c linux-2.6.21-rc5-git12/drivers/net/b44.c
--- linux-2.6.21-rc5-git11/drivers/net/b44.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/b44.c	2007-04-04 22:34:48.651225803 +0200
@@ -1709,7 +1709,7 @@ static void __b44_set_rx_mode(struct net
 		bw32(bp, B44_RXCONFIG, val);
 	} else {
 		unsigned char zero[6] = {0, 0, 0, 0, 0, 0};
-		int i = 0;
+		int i = 1;
 
 		__b44_set_mac_addr(bp);
 
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/common.h linux-2.6.21-rc5-git12/drivers/net/cxgb3/common.h
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/common.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/common.h	2007-04-04 22:34:48.651225803 +0200
@@ -112,8 +112,7 @@ enum {
 };
 
 enum {
-	SUPPORTED_OFFLOAD = 1 << 24,
-	SUPPORTED_IRQ = 1 << 25
+	SUPPORTED_IRQ      = 1 << 24
 };
 
 enum {				/* adapter interrupt-maintained statistics */
@@ -358,6 +357,9 @@ enum {
 	MC5_MODE_72_BIT = 2
 };
 
+/* MC5 min active region size */
+enum { MC5_MIN_TIDS = 16 };
+
 struct vpd_params {
 	unsigned int cclk;
 	unsigned int mclk;
@@ -402,6 +404,7 @@ struct adapter_params {
 	unsigned int stats_update_period;	/* MAC stats accumulation period */
 	unsigned int linkpoll_period;	/* link poll period in 0.1s */
 	unsigned int rev;	/* chip revision */
+	unsigned int offload;
 };
 
 enum {					    /* chip revisions */
@@ -602,7 +605,7 @@ static inline int is_10G(const struct ad
 
 static inline int is_offload(const struct adapter *adap)
 {
-	return adapter_info(adap)->caps & SUPPORTED_OFFLOAD;
+	return adap->params.offload;
 }
 
 static inline unsigned int core_ticks_per_usec(const struct adapter *adap)
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/cxgb3_main.c linux-2.6.21-rc5-git12/drivers/net/cxgb3/cxgb3_main.c
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/cxgb3_main.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/cxgb3_main.c	2007-04-04 22:34:48.651225803 +0200
@@ -185,16 +185,26 @@ void t3_os_link_changed(struct adapter *
 			int speed, int duplex, int pause)
 {
 	struct net_device *dev = adapter->port[port_id];
+	struct port_info *pi = netdev_priv(dev);
+	struct cmac *mac = &pi->mac;
 
 	/* Skip changes from disabled ports. */
 	if (!netif_running(dev))
 		return;
 
 	if (link_stat != netif_carrier_ok(dev)) {
-		if (link_stat)
+		if (link_stat) {
+			t3_set_reg_field(adapter,
+					 A_XGM_TXFIFO_CFG + mac->offset,
+					 F_ENDROPPKT, 0);
 			netif_carrier_on(dev);
-		else
+		} else {
 			netif_carrier_off(dev);
+			t3_set_reg_field(adapter,
+					 A_XGM_TXFIFO_CFG + mac->offset,
+					 F_ENDROPPKT, F_ENDROPPKT);
+		}
+
 		link_report(dev);
 	}
 }
@@ -407,7 +417,7 @@ static void quiesce_rx(struct adapter *a
 static int setup_sge_qsets(struct adapter *adap)
 {
 	int i, j, err, irq_idx = 0, qset_idx = 0, dummy_dev_idx = 0;
-	unsigned int ntxq = is_offload(adap) ? SGE_TXQ_PER_SET : 1;
+	unsigned int ntxq = SGE_TXQ_PER_SET;
 
 	if (adap->params.rev > 0 && !(adap->flags & USING_MSI))
 		irq_idx = -1;
@@ -485,12 +495,14 @@ static ssize_t show_##name(struct device
 static ssize_t set_nfilters(struct net_device *dev, unsigned int val)
 {
 	struct adapter *adap = dev->priv;
+	int min_tids = is_offload(adap) ? MC5_MIN_TIDS : 0;
 
 	if (adap->flags & FULL_INIT_DONE)
 		return -EBUSY;
 	if (val && adap->params.rev == 0)
 		return -EINVAL;
-	if (val > t3_mc5_size(&adap->mc5) - adap->params.mc5.nservers)
+	if (val > t3_mc5_size(&adap->mc5) - adap->params.mc5.nservers -
+	    min_tids)
 		return -EINVAL;
 	adap->params.mc5.nfilters = val;
 	return 0;
@@ -508,7 +520,8 @@ static ssize_t set_nservers(struct net_d
 
 	if (adap->flags & FULL_INIT_DONE)
 		return -EBUSY;
-	if (val > t3_mc5_size(&adap->mc5) - adap->params.mc5.nfilters)
+	if (val > t3_mc5_size(&adap->mc5) - adap->params.mc5.nfilters -
+	    MC5_MIN_TIDS)
 		return -EINVAL;
 	adap->params.mc5.nservers = val;
 	return 0;
@@ -708,7 +721,7 @@ static void bind_qsets(struct adapter *a
 	}
 }
 
-#define FW_FNAME "t3fw-%d.%d.bin"
+#define FW_FNAME "t3fw-%d.%d.%d.bin"
 
 static int upgrade_fw(struct adapter *adap)
 {
@@ -718,7 +731,7 @@ static int upgrade_fw(struct adapter *ad
 	struct device *dev = &adap->pdev->dev;
 
 	snprintf(buf, sizeof(buf), FW_FNAME, FW_VERSION_MAJOR,
-		 FW_VERSION_MINOR);
+		 FW_VERSION_MINOR, FW_VERSION_MICRO);
 	ret = request_firmware(&fw, buf, dev);
 	if (ret < 0) {
 		dev_err(dev, "could not upgrade firmware: unable to load %s\n",
@@ -919,7 +932,7 @@ static int cxgb_open(struct net_device *
 		return err;
 
 	set_bit(pi->port_id, &adapter->open_device_map);
-	if (!ofld_disable) {
+	if (is_offload(adapter) && !ofld_disable) {
 		err = offload_open(dev);
 		if (err)
 			printk(KERN_WARNING
@@ -2116,7 +2129,7 @@ static void check_t3b2_mac(struct adapte
 			continue;
 
 		status = 0;
-		if (netif_running(dev))
+		if (netif_running(dev) && netif_carrier_ok(dev))
 			status = t3b2_mac_watchdog_task(&p->mac);
 		if (status == 1)
 			p->mac.stats.num_toggled++;
@@ -2267,9 +2280,9 @@ static void __devinit print_port_info(st
 
 		if (!test_bit(i, &adap->registered_device_map))
 			continue;
-		printk(KERN_INFO "%s: %s %s RNIC (rev %d) %s%s\n",
+		printk(KERN_INFO "%s: %s %s %sNIC (rev %d) %s%s\n",
 		       dev->name, ai->desc, pi->port_type->desc,
-		       adap->params.rev, buf,
+		       is_offload(adap) ? "R" : "", adap->params.rev, buf,
 		       (adap->flags & USING_MSIX) ? " MSI-X" :
 		       (adap->flags & USING_MSI) ? " MSI" : "");
 		if (adap->name == dev->name && adap->params.vpd.mclk)
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/cxgb3_offload.c linux-2.6.21-rc5-git12/drivers/net/cxgb3/cxgb3_offload.c
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/cxgb3_offload.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/cxgb3_offload.c	2007-04-04 22:34:48.651225803 +0200
@@ -553,7 +553,9 @@ int cxgb3_alloc_atid(struct t3cdev *tdev
 	struct tid_info *t = &(T3C_DATA(tdev))->tid_maps;
 
 	spin_lock_bh(&t->atid_lock);
-	if (t->afree) {
+	if (t->afree &&
+	    t->atids_in_use + atomic_read(&t->tids_in_use) + MC5_MIN_TIDS <=
+	    t->ntids) {
 		union active_open_entry *p = t->afree;
 
 		atid = (p - t->atid_tab) + t->atid_base;
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/mc5.c linux-2.6.21-rc5-git12/drivers/net/cxgb3/mc5.c
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/mc5.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/mc5.c	2007-04-04 22:34:48.651225803 +0200
@@ -328,6 +328,9 @@ int t3_mc5_init(struct mc5 *mc5, unsigne
 	unsigned int tcam_size = mc5->tcam_size;
 	struct adapter *adap = mc5->adapter;
 
+	if (!tcam_size)
+		return 0;
+
 	if (nroutes > MAX_ROUTES || nroutes + nservers + nfilters > tcam_size)
 		return -EINVAL;
 
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/regs.h linux-2.6.21-rc5-git12/drivers/net/cxgb3/regs.h
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/regs.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/regs.h	2007-04-04 22:34:48.651225803 +0200
@@ -1940,6 +1940,10 @@
 
 #define V_TXFIFOTHRESH(x) ((x) << S_TXFIFOTHRESH)
 
+#define S_ENDROPPKT    21
+#define V_ENDROPPKT(x) ((x) << S_ENDROPPKT)
+#define F_ENDROPPKT    V_ENDROPPKT(1U)
+
 #define A_XGM_SERDES_CTRL 0x890
 #define A_XGM_SERDES_CTRL0 0x8e0
 
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/sge.c linux-2.6.21-rc5-git12/drivers/net/cxgb3/sge.c
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/sge.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/sge.c	2007-04-04 22:34:48.651225803 +0200
@@ -2631,7 +2631,7 @@ int t3_sge_alloc_qset(struct adapter *ad
 	q->txq[TXQ_ETH].stop_thres = nports *
 	    flits_to_desc(sgl_len(MAX_SKB_FRAGS + 1) + 3);
 
-	if (ntxq == 1) {
+	if (!is_offload(adapter)) {
 #ifdef USE_RX_PAGE
 		q->fl[0].buf_size = RX_PAGE_SIZE;
 #else
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/t3_hw.c linux-2.6.21-rc5-git12/drivers/net/cxgb3/t3_hw.c
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/t3_hw.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/t3_hw.c	2007-04-04 22:34:48.661225819 +0200
@@ -438,23 +438,23 @@ static const struct adapter_info t3_adap
 	{2, 0, 0, 0,
 	 F_GPIO2_OEN | F_GPIO4_OEN |
 	 F_GPIO2_OUT_VAL | F_GPIO4_OUT_VAL, F_GPIO3 | F_GPIO5,
-	 SUPPORTED_OFFLOAD,
+	 0,
 	 &mi1_mdio_ops, "Chelsio PE9000"},
 	{2, 0, 0, 0,
 	 F_GPIO2_OEN | F_GPIO4_OEN |
 	 F_GPIO2_OUT_VAL | F_GPIO4_OUT_VAL, F_GPIO3 | F_GPIO5,
-	 SUPPORTED_OFFLOAD,
+	 0,
 	 &mi1_mdio_ops, "Chelsio T302"},
 	{1, 0, 0, 0,
 	 F_GPIO1_OEN | F_GPIO6_OEN | F_GPIO7_OEN | F_GPIO10_OEN |
 	 F_GPIO1_OUT_VAL | F_GPIO6_OUT_VAL | F_GPIO10_OUT_VAL, 0,
-	 SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_OFFLOAD,
+	 SUPPORTED_10000baseT_Full | SUPPORTED_AUI,
 	 &mi1_mdio_ext_ops, "Chelsio T310"},
 	{2, 0, 0, 0,
 	 F_GPIO1_OEN | F_GPIO2_OEN | F_GPIO4_OEN | F_GPIO5_OEN | F_GPIO6_OEN |
 	 F_GPIO7_OEN | F_GPIO10_OEN | F_GPIO11_OEN | F_GPIO1_OUT_VAL |
 	 F_GPIO5_OUT_VAL | F_GPIO6_OUT_VAL | F_GPIO10_OUT_VAL, 0,
-	 SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_OFFLOAD,
+	 SUPPORTED_10000baseT_Full | SUPPORTED_AUI,
 	 &mi1_mdio_ext_ops, "Chelsio T320"},
 };
 
@@ -2900,6 +2900,9 @@ static int mc7_init(struct mc7 *mc7, uns
 	struct adapter *adapter = mc7->adapter;
 	const struct mc7_timing_params *p = &mc7_timings[mem_type];
 
+	if (!mc7->size)
+		return 0;
+
 	val = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);
 	slow = val & F_SLOW;
 	width = G_WIDTH(val);
@@ -3100,8 +3103,10 @@ int t3_init_hw(struct adapter *adapter, 
 	do {			/* wait for uP to initialize */
 		msleep(20);
 	} while (t3_read_reg(adapter, A_CIM_HOST_ACC_DATA) && --attempts);
-	if (!attempts)
+	if (!attempts) {
+		CH_ERR(adapter, "uP initialization timed out\n");
 		goto out_err;
+	}
 
 	err = 0;
 out_err:
@@ -3201,7 +3206,7 @@ static void __devinit mc7_prep(struct ad
 	mc7->name = name;
 	mc7->offset = base_addr - MC7_PMRX_BASE_ADDR;
 	cfg = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);
-	mc7->size = mc7_calc_size(cfg);
+	mc7->size = mc7->size = G_DEN(cfg) == M_DEN ? 0 : mc7_calc_size(cfg);
 	mc7->width = G_WIDTH(cfg);
 }
 
@@ -3228,6 +3233,7 @@ void early_hw_init(struct adapter *adapt
 		     V_I2C_CLKDIV(adapter->params.vpd.cclk / 80 - 1));
 	t3_write_reg(adapter, A_T3DBG_GPIO_EN,
 		     ai->gpio_out | F_GPIO0_OEN | F_GPIO0_OUT_VAL);
+	t3_write_reg(adapter, A_MC5_DB_SERVER_INDEX, 0);
 
 	if (adapter->params.rev == 0 || !uses_xaui(adapter))
 		val |= F_ENRGMII;
@@ -3326,7 +3332,13 @@ int __devinit t3_prep_adapter(struct ada
 		p->tx_num_pgs = pm_num_pages(p->chan_tx_size, p->tx_pg_size);
 		p->ntimer_qs = p->cm_size >= (128 << 20) ||
 		    adapter->params.rev > 0 ? 12 : 6;
+	}
+
+	adapter->params.offload = t3_mc7_size(&adapter->pmrx) &&
+				  t3_mc7_size(&adapter->pmtx) &&
+				  t3_mc7_size(&adapter->cm);
 
+	if (is_offload(adapter)) {
 		adapter->params.mc5.nservers = DEFAULT_NSERVERS;
 		adapter->params.mc5.nfilters = adapter->params.rev > 0 ?
 		    DEFAULT_NFILTERS : 0;
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/version.h linux-2.6.21-rc5-git12/drivers/net/cxgb3/version.h
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/version.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/version.h	2007-04-04 22:34:48.661225819 +0200
@@ -36,6 +36,9 @@
 #define DRV_NAME "cxgb3"
 /* Driver version */
 #define DRV_VERSION "1.0-ko"
+
+/* Firmware version */
 #define FW_VERSION_MAJOR 3
-#define FW_VERSION_MINOR 2
+#define FW_VERSION_MINOR 3
+#define FW_VERSION_MICRO 0
 #endif				/* __CHELSIO_VERSION_H */
diff -purN linux-2.6.21-rc5-git11/drivers/net/cxgb3/xgmac.c linux-2.6.21-rc5-git12/drivers/net/cxgb3/xgmac.c
--- linux-2.6.21-rc5-git11/drivers/net/cxgb3/xgmac.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/cxgb3/xgmac.c	2007-04-04 22:34:48.661225819 +0200
@@ -471,7 +471,6 @@ const struct mac_stats *t3_mac_update_st
 	RMON_UPDATE(mac, rx_symbol_errs, RX_SYM_CODE_ERR_FRAMES);
 
 	RMON_UPDATE(mac, rx_too_long, RX_OVERSIZE_FRAMES);
-	mac->stats.rx_too_long += RMON_READ(mac, A_XGM_RX_MAX_PKT_SIZE_ERR_CNT);
 
 	v = RMON_READ(mac, A_XGM_RX_MAX_PKT_SIZE_ERR_CNT);
 	if (mac->adapter->params.rev == T3_REV_B2)
diff -purN linux-2.6.21-rc5-git11/drivers/net/r8169.c linux-2.6.21-rc5-git12/drivers/net/r8169.c
--- linux-2.6.21-rc5-git11/drivers/net/r8169.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/drivers/net/r8169.c	2007-04-04 22:34:48.671225835 +0200
@@ -66,6 +66,7 @@ VERSION 2.2LK	<2005/01/25>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
 
+#include <asm/system.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -486,6 +487,7 @@ static int rtl8169_rx_interrupt(struct n
 				void __iomem *);
 static int rtl8169_change_mtu(struct net_device *dev, int new_mtu);
 static void rtl8169_down(struct net_device *dev);
+static void rtl8169_rx_clear(struct rtl8169_private *tp);
 
 #ifdef CONFIG_R8169_NAPI
 static int rtl8169_poll(struct net_device *dev, int *budget);
@@ -1751,16 +1753,10 @@ static int rtl8169_open(struct net_devic
 {
 	struct rtl8169_private *tp = netdev_priv(dev);
 	struct pci_dev *pdev = tp->pci_dev;
-	int retval;
+	int retval = -ENOMEM;
 
-	rtl8169_set_rxbufsize(tp, dev);
-
-	retval =
-	    request_irq(dev->irq, rtl8169_interrupt, IRQF_SHARED, dev->name, dev);
-	if (retval < 0)
-		goto out;
 
-	retval = -ENOMEM;
+	rtl8169_set_rxbufsize(tp, dev);
 
 	/*
 	 * Rx and Tx desscriptors needs 256 bytes alignment.
@@ -1769,19 +1765,26 @@ static int rtl8169_open(struct net_devic
 	tp->TxDescArray = pci_alloc_consistent(pdev, R8169_TX_RING_BYTES,
 					       &tp->TxPhyAddr);
 	if (!tp->TxDescArray)
-		goto err_free_irq;
+		goto out;
 
 	tp->RxDescArray = pci_alloc_consistent(pdev, R8169_RX_RING_BYTES,
 					       &tp->RxPhyAddr);
 	if (!tp->RxDescArray)
-		goto err_free_tx;
+		goto err_free_tx_0;
 
 	retval = rtl8169_init_ring(dev);
 	if (retval < 0)
-		goto err_free_rx;
+		goto err_free_rx_1;
 
 	INIT_DELAYED_WORK(&tp->task, NULL);
 
+	smp_mb();
+
+	retval = request_irq(dev->irq, rtl8169_interrupt, IRQF_SHARED,
+			     dev->name, dev);
+	if (retval < 0)
+		goto err_release_ring_2;
+
 	rtl8169_hw_start(dev);
 
 	rtl8169_request_timer(dev);
@@ -1790,14 +1793,14 @@ static int rtl8169_open(struct net_devic
 out:
 	return retval;
 
-err_free_rx:
+err_release_ring_2:
+	rtl8169_rx_clear(tp);
+err_free_rx_1:
 	pci_free_consistent(pdev, R8169_RX_RING_BYTES, tp->RxDescArray,
 			    tp->RxPhyAddr);
-err_free_tx:
+err_free_tx_0:
 	pci_free_consistent(pdev, R8169_TX_RING_BYTES, tp->TxDescArray,
 			    tp->TxPhyAddr);
-err_free_irq:
-	free_irq(dev->irq, dev);
 	goto out;
 }
 
@@ -2887,7 +2890,7 @@ static int rtl8169_suspend(struct pci_de
 	void __iomem *ioaddr = tp->mmio_addr;
 
 	if (!netif_running(dev))
-		goto out;
+		goto out_pci_suspend;
 
 	netif_device_detach(dev);
 	netif_stop_queue(dev);
@@ -2901,10 +2904,11 @@ static int rtl8169_suspend(struct pci_de
 
 	spin_unlock_irq(&tp->lock);
 
+out_pci_suspend:
 	pci_save_state(pdev);
 	pci_enable_wake(pdev, pci_choose_state(pdev, state), tp->wol_enabled);
 	pci_set_power_state(pdev, pci_choose_state(pdev, state));
-out:
+
 	return 0;
 }
 
@@ -2912,15 +2916,15 @@ static int rtl8169_resume(struct pci_dev
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
 
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+	pci_enable_wake(pdev, PCI_D0, 0);
+
 	if (!netif_running(dev))
 		goto out;
 
 	netif_device_attach(dev);
 
-	pci_set_power_state(pdev, PCI_D0);
-	pci_restore_state(pdev);
-	pci_enable_wake(pdev, PCI_D0, 0);
-
 	rtl8169_schedule_work(dev, rtl8169_reset_task);
 out:
 	return 0;
diff -purN linux-2.6.21-rc5-git11/drivers/s390/cio/device_status.c linux-2.6.21-rc5-git12/drivers/s390/cio/device_status.c
--- linux-2.6.21-rc5-git11/drivers/s390/cio/device_status.c	2007-04-04 22:34:42.281215563 +0200
+++ linux-2.6.21-rc5-git12/drivers/s390/cio/device_status.c	2007-04-04 22:34:48.691225867 +0200
@@ -221,6 +221,14 @@ ccw_device_accumulate_irb(struct ccw_dev
 
 	cdev_irb = &cdev->private->irb;
 
+	/*
+	 * If the clear function had been performed, all formerly pending
+	 * status at the subchannel has been cleared and we must not pass
+	 * intermediate accumulated status to the device driver.
+	 */
+	if (irb->scsw.fctl & SCSW_FCTL_CLEAR_FUNC)
+		memset(&cdev->private->irb, 0, sizeof(struct irb));
+
 	/* Copy bits which are valid only for the start function. */
 	if (irb->scsw.fctl & SCSW_FCTL_START_FUNC) {
 		/* Copy key. */
diff -purN linux-2.6.21-rc5-git11/include/linux/ata.h linux-2.6.21-rc5-git12/include/linux/ata.h
--- linux-2.6.21-rc5-git11/include/linux/ata.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/include/linux/ata.h	2007-04-04 22:34:48.731225931 +0200
@@ -40,6 +40,7 @@ enum {
 	ATA_MAX_DEVICES		= 2,	/* per bus/port */
 	ATA_MAX_PRD		= 256,	/* we could make these 256/256 */
 	ATA_SECT_SIZE		= 512,
+	ATA_MAX_SECTORS_128	= 128,
 	ATA_MAX_SECTORS		= 256,
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 
diff -purN linux-2.6.21-rc5-git11/include/linux/libata.h linux-2.6.21-rc5-git12/include/linux/libata.h
--- linux-2.6.21-rc5-git11/include/linux/libata.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/include/linux/libata.h	2007-04-04 22:34:48.731225931 +0200
@@ -311,15 +311,17 @@ enum {
 	ATA_HORKAGE_DIAGNOSTIC	= (1 << 0),	/* Failed boot diag */
 	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */
 	ATA_HORKAGE_NONCQ	= (1 << 2),	/* Don't use NCQ */
+	ATA_HORKAGE_MAX_SEC_128	= (1 << 3),	/* Limit max sects to 128 */
+	ATA_HORKAGE_DMA_RW_ONLY	= (1 << 4),	/* ATAPI DMA for RW only */
 };
 
 enum hsm_task_states {
 	HSM_ST_IDLE,		/* no command on going */
+	HSM_ST_FIRST,		/* (waiting the device to)
+				   write CDB or first data block */
 	HSM_ST,			/* (waiting the device to) transfer data */
 	HSM_ST_LAST,		/* (waiting the device to) complete command */
 	HSM_ST_ERR,		/* error */
-	HSM_ST_FIRST,		/* (waiting the device to)
-				   write CDB or first data block */
 };
 
 enum ata_completion_errors {
diff -purN linux-2.6.21-rc5-git11/mm/rmap.c linux-2.6.21-rc5-git12/mm/rmap.c
--- linux-2.6.21-rc5-git11/mm/rmap.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/mm/rmap.c	2007-04-04 22:34:48.741225947 +0200
@@ -498,9 +498,9 @@ int page_mkclean(struct page *page)
 		struct address_space *mapping = page_mapping(page);
 		if (mapping)
 			ret = page_mkclean_file(mapping, page);
+		if (page_test_and_clear_dirty(page))
+			ret = 1;
 	}
-	if (page_test_and_clear_dirty(page))
-		ret = 1;
 
 	return ret;
 }
diff -purN linux-2.6.21-rc5-git11/mm/slab.c linux-2.6.21-rc5-git12/mm/slab.c
--- linux-2.6.21-rc5-git11/mm/slab.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git12/mm/slab.c	2007-04-04 22:34:48.751225964 +0200
@@ -1802,8 +1802,8 @@ static void check_poison_obj(struct kmem
 			/* Print header */
 			if (lines == 0) {
 				printk(KERN_ERR
-					"Slab corruption: start=%p, len=%d\n",
-					realobj, size);
+					"Slab corruption: %s start=%p, len=%d\n",
+					cachep->name, realobj, size);
 				print_objinfo(cachep, objp, 0);
 			}
 			/* Hexdump the affected line */
diff -purN linux-2.6.21-rc5-git11/net/core/dev.c linux-2.6.21-rc5-git12/net/core/dev.c
--- linux-2.6.21-rc5-git11/net/core/dev.c	2007-04-04 22:34:42.341215660 +0200
+++ linux-2.6.21-rc5-git12/net/core/dev.c	2007-04-04 22:34:48.751225964 +0200
@@ -751,13 +751,10 @@ int dev_change_name(struct net_device *d
 	else
 		strlcpy(dev->name, newname, IFNAMSIZ);
 
-	err = device_rename(&dev->dev, dev->name);
-	if (!err) {
-		hlist_del(&dev->name_hlist);
-		hlist_add_head(&dev->name_hlist, dev_name_hash(dev->name));
-		raw_notifier_call_chain(&netdev_chain,
-				NETDEV_CHANGENAME, dev);
-	}
+	device_rename(&dev->dev, dev->name);
+	hlist_del(&dev->name_hlist);
+	hlist_add_head(&dev->name_hlist, dev_name_hash(dev->name));
+	raw_notifier_call_chain(&netdev_chain, NETDEV_CHANGENAME, dev);
 
 	return err;
 }
