From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] kernel: Update to 2.6.24-rc3-git3.
Patch-mainline: 2.6.24-rc3-git3

 This patch contains the differences between 2.6.24-rc3-git2 and -git3.

 The corresponding commit id is: a531a141089714efe39eca89593524fdf05104f2.

Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 Makefile                                  |    2 
 arch/alpha/kernel/pci-noop.c              |   14 +++---
 arch/cris/arch-v10/drivers/Kconfig        |   39 -----------------
 arch/cris/arch-v32/drivers/Kconfig        |   12 -----
 arch/m32r/kernel/signal.c                 |   17 +++----
 arch/m32r/kernel/syscall_table.S          |   40 ++++++++++++++++++
 block/blktrace.c                          |    9 +++-
 block/genhd.c                             |    1 
 block/ll_rw_blk.c                         |   23 ----------
 drivers/char/sonypi.c                     |    8 ++-
 drivers/ide/Kconfig                       |   47 ++++++++++++++++++++-
 drivers/ide/Makefile                      |    2 
 drivers/ide/cris/ide-cris.c               |    7 +--
 drivers/ide/ide-dma.c                     |    1 
 drivers/ide/ide-iops.c                    |   13 ++++-
 drivers/ide/ide-probe.c                   |   32 ++++++++------
 drivers/ide/legacy/ali14xx.c              |    7 +--
 drivers/ide/legacy/macide.c               |    2 
 drivers/ide/legacy/q40ide.c               |    2 
 drivers/ide/pci/aec62xx.c                 |   11 ++++-
 drivers/ide/pci/alim15x3.c                |    5 ++
 drivers/ide/pci/piix.c                    |    1 
 drivers/ide/pci/siimage.c                 |   45 --------------------
 drivers/ide/pci/sis5513.c                 |    1 
 drivers/ide/pci/trm290.c                  |    3 -
 drivers/ide/ppc/pmac.c                    |    2 
 drivers/infiniband/hw/ehca/ehca_qp.c      |    4 -
 drivers/infiniband/hw/ipath/ipath_cq.c    |   19 ++++++--
 drivers/infiniband/hw/ipath/ipath_qp.c    |   15 ++++--
 drivers/infiniband/hw/ipath/ipath_srq.c   |   44 +++++++++++---------
 drivers/infiniband/hw/ipath/ipath_verbs.c |    8 ++-
 drivers/infiniband/ulp/iser/iser_memory.c |    6 +-
 drivers/input/keyboard/Kconfig            |    2 
 drivers/input/keyboard/gpio_keys.c        |   38 ++++++++++++-----
 drivers/input/serio/i8042-x86ia64io.h     |    8 +++
 drivers/kvm/kvm_main.c                    |    3 -
 drivers/kvm/svm.c                         |    1 
 drivers/kvm/x86_emulate.c                 |    6 +-
 drivers/misc/sony-laptop.c                |   10 ++--
 drivers/mmc/card/queue.c                  |    3 -
 drivers/net/mlx4/qp.c                     |    2 
 drivers/scsi/ide-scsi.c                   |   22 +++-------
 fs/Kconfig                                |    9 ++++
 fs/ocfs2/aops.c                           |    2 
 fs/ocfs2/cluster/masklog.h                |    2 
 fs/ocfs2/dcache.c                         |   20 +++++++--
 fs/ocfs2/dlm/dlmmaster.c                  |    4 -
 fs/ocfs2/file.c                           |   19 ++++++--
 fs/ocfs2/inode.c                          |    6 +-
 fs/ocfs2/localalloc.c                     |    5 +-
 fs/ocfs2/super.c                          |    6 +-
 include/asm-m32r/thread_info.h            |   11 +++--
 include/asm-m32r/unistd.h                 |   66 +++++++++++++++++++++++++++++-
 include/linux/input.h                     |    5 ++
 include/linux/scatterlist.h               |   37 +++++++++++-----
 55 files changed, 449 insertions(+), 280 deletions(-)

--- a/arch/alpha/kernel/pci-noop.c	2007-07-08 19:32:17.000000000 -0400
+++ b/arch/alpha/kernel/pci-noop.c	2007-11-28 10:15:58.000000000 -0500
@@ -12,6 +12,7 @@
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
 
 #include "proto.h"
 
@@ -172,18 +173,19 @@ dma_alloc_coherent(struct device *dev, s
 EXPORT_SYMBOL(dma_alloc_coherent);
 
 int
-dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+dma_map_sg(struct device *dev, struct scatterlist *sgl, int nents,
 	   enum dma_data_direction direction)
 {
 	int i;
+	struct scatterlist *sg;
 
-	for (i = 0; i < nents; i++ ) {
+	for_each_sg(sgl, sg, nents, i) {
 		void *va;
 
-		BUG_ON(!sg[i].page);
-		va = page_address(sg[i].page) + sg[i].offset;
-		sg_dma_address(sg + i) = (dma_addr_t)virt_to_bus(va);
-		sg_dma_len(sg + i) = sg[i].length;
+		BUG_ON(!sg_page(sg));
+		va = sg_virt(sg);
+		sg_dma_address(sg) = (dma_addr_t)virt_to_bus(va);
+		sg_dma_len(sg) = sg->length;
 	}
 
 	return nents;
--- a/arch/cris/arch-v10/drivers/Kconfig	2007-11-26 17:09:07.000000000 -0500
+++ b/arch/cris/arch-v10/drivers/Kconfig	2007-11-28 10:15:58.000000000 -0500
@@ -542,45 +542,6 @@ config ETRAX_RS485_DISABLE_RECEIVER
 	  loopback.  Not all products are able to do this in software only.
 	  Axis 2400/2401 must disable receiver.
 
-config ETRAX_IDE
-	bool "ATA/IDE support"
-	select IDE
-	select BLK_DEV_IDE
-	select BLK_DEV_IDEDISK
-	select BLK_DEV_IDECD
-	select BLK_DEV_IDEDMA
-	select IDE_GENERIC
-	help
-	  Enable this to get support for ATA/IDE.
-	  You can't use parallel ports or SCSI ports
-	  at the same time.
-
-
-config ETRAX_IDE_DELAY
-	int "Delay for drives to regain consciousness"
-	depends on ETRAX_IDE
-	default 15
-	help
-	  Number of seconds to wait for IDE drives to spin up after an IDE
-	  reset.
-choice
-	prompt "IDE reset pin"
-	depends on ETRAX_IDE
-	default ETRAX_IDE_PB7_RESET
-
-config ETRAX_IDE_PB7_RESET
-	bool "Port_PB_Bit_7"
-	help
-	  IDE reset on pin 7 on port B
-
-config ETRAX_IDE_G27_RESET
-	bool "Port_G_Bit_27"
-	help
-	  IDE reset on pin 27 on port G
-
-endchoice
-
-
 config ETRAX_USB_HOST
 	bool "USB host"
 	select USB
--- a/arch/cris/arch-v32/drivers/Kconfig	2007-11-26 17:09:07.000000000 -0500
+++ b/arch/cris/arch-v32/drivers/Kconfig	2007-11-28 10:15:58.000000000 -0500
@@ -582,18 +582,6 @@ config ETRAX_PE_CHANGEABLE_BITS
 	  that a user can change the value on using ioctl's.
 	  Bit set = changeable.
 
-config ETRAX_IDE
-	bool "ATA/IDE support"
-	depends on ETRAX_ARCH_V32
-	select IDE
-	select BLK_DEV_IDE
-	select BLK_DEV_IDEDISK
-	select BLK_DEV_IDECD
-	select BLK_DEV_IDEDMA
-	select IDE_GENERIC
-	help
-	  Enables the ETRAX IDE driver.
-
 config ETRAX_CARDBUS
         bool "Cardbus support"
         depends on ETRAX_ARCH_V32
--- a/arch/m32r/kernel/signal.c	2007-11-26 17:09:08.000000000 -0500
+++ b/arch/m32r/kernel/signal.c	2007-11-28 10:15:58.000000000 -0500
@@ -36,7 +36,7 @@ sys_rt_sigsuspend(sigset_t __user *unews
 		  unsigned long r2, unsigned long r3, unsigned long r4,
 		  unsigned long r5, unsigned long r6, struct pt_regs *regs)
 {
-	sigset_t saveset, newset;
+	sigset_t newset;
 
 	/* XXX: Don't preclude handling different sized sigset_t's.  */
 	if (sigsetsize != sizeof(sigset_t))
@@ -44,21 +44,18 @@ sys_rt_sigsuspend(sigset_t __user *unews
 
 	if (copy_from_user(&newset, unewset, sizeof(newset)))
 		return -EFAULT;
-	sigdelsetmask(&newset, ~_BLOCKABLE);
+	sigdelsetmask(&newset, sigmask(SIGKILL)|sigmask(SIGSTOP));
 
 	spin_lock_irq(&current->sighand->siglock);
-	saveset = current->blocked;
+	current->saved_sigmask = current->blocked;
 	current->blocked = newset;
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
 
-	regs->r0 = -EINTR;
-	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
-		schedule();
-		if (do_signal(regs, &saveset))
-			return regs->r0;
-	}
+	current->state = TASK_INTERRUPTIBLE;
+	schedule();
+	set_thread_flag(TIF_RESTORE_SIGMASK);
+	return -ERESTARTNOHAND;
 }
 
 asmlinkage int
--- a/arch/m32r/kernel/syscall_table.S	2007-11-07 10:27:33.000000000 -0500
+++ b/arch/m32r/kernel/syscall_table.S	2007-11-28 10:15:58.000000000 -0500
@@ -284,3 +284,43 @@ ENTRY(sys_call_table)
         .long sys_mq_getsetattr
         .long sys_ni_syscall            /* reserved for kexec */
 	.long sys_waitid
+	.long sys_ni_syscall		/* 285 */ /* available */
+	.long sys_add_key
+	.long sys_request_key
+	.long sys_keyctl
+	.long sys_ioprio_set
+	.long sys_ioprio_get		/* 290 */
+	.long sys_inotify_init
+	.long sys_inotify_add_watch
+	.long sys_inotify_rm_watch
+	.long sys_migrate_pages
+	.long sys_openat		/* 295 */
+	.long sys_mkdirat
+	.long sys_mknodat
+	.long sys_fchownat
+	.long sys_futimesat
+	.long sys_fstatat64		/* 300 */
+	.long sys_unlinkat
+	.long sys_renameat
+	.long sys_linkat
+	.long sys_symlinkat
+	.long sys_readlinkat		/* 305 */
+	.long sys_fchmodat
+	.long sys_faccessat
+	.long sys_pselect6
+	.long sys_ppoll
+	.long sys_unshare		/* 310 */
+	.long sys_set_robust_list
+	.long sys_get_robust_list
+	.long sys_splice
+	.long sys_sync_file_range
+	.long sys_tee			/* 315 */
+	.long sys_vmsplice
+	.long sys_move_pages
+	.long sys_getcpu
+	.long sys_epoll_pwait
+	.long sys_utimensat		/* 320 */
+	.long sys_signalfd
+	.long sys_timerfd
+	.long sys_eventfd
+	.long sys_fallocate
--- a/block/blktrace.c	2007-11-26 17:09:09.000000000 -0500
+++ b/block/blktrace.c	2007-11-28 10:15:59.000000000 -0500
@@ -202,6 +202,7 @@ static void blk_remove_tree(struct dentr
 static struct dentry *blk_create_tree(const char *blk_name)
 {
 	struct dentry *dir = NULL;
+	int created = 0;
 
 	mutex_lock(&blk_tree_mutex);
 
@@ -209,13 +210,17 @@ static struct dentry *blk_create_tree(co
 		blk_tree_root = debugfs_create_dir("block", NULL);
 		if (!blk_tree_root)
 			goto err;
+		created = 1;
 	}
 
 	dir = debugfs_create_dir(blk_name, blk_tree_root);
 	if (dir)
 		root_users++;
-	else
-		blk_remove_root();
+	else {
+		/* Delete root only if we created it */
+		if (created)
+			blk_remove_root();
+	}
 
 err:
 	mutex_unlock(&blk_tree_mutex);
--- a/block/genhd.c	2007-11-26 17:09:09.000000000 -0500
+++ b/block/genhd.c	2007-11-28 10:15:59.000000000 -0500
@@ -715,6 +715,7 @@ struct gendisk *alloc_disk_node(int mino
 			disk->part = kmalloc_node(size,
 				GFP_KERNEL | __GFP_ZERO, node_id);
 			if (!disk->part) {
+				free_disk_stats(disk);
 				kfree(disk);
 				return NULL;
 			}
--- a/block/ll_rw_blk.c	2007-11-26 17:09:09.000000000 -0500
+++ b/block/ll_rw_blk.c	2007-11-28 10:15:59.000000000 -0500
@@ -4080,23 +4080,7 @@ static ssize_t queue_max_hw_sectors_show
 	return queue_var_show(max_hw_sectors_kb, (page));
 }
 
-static ssize_t queue_max_segments_show(struct request_queue *q, char *page)
-{
-	return queue_var_show(q->max_phys_segments, page);
-}
-
-static ssize_t queue_max_segments_store(struct request_queue *q,
-					const char *page, size_t count)
-{
-	unsigned long segments;
-	ssize_t ret = queue_var_store(&segments, page, count);
 
-	spin_lock_irq(q->queue_lock);
-	q->max_phys_segments = segments;
-	spin_unlock_irq(q->queue_lock);
-
-	return ret;
-}
 static struct queue_sysfs_entry queue_requests_entry = {
 	.attr = {.name = "nr_requests", .mode = S_IRUGO | S_IWUSR },
 	.show = queue_requests_show,
@@ -4120,12 +4104,6 @@ static struct queue_sysfs_entry queue_ma
 	.show = queue_max_hw_sectors_show,
 };
 
-static struct queue_sysfs_entry queue_max_segments_entry = {
-	.attr = {.name = "max_segments", .mode = S_IRUGO | S_IWUSR },
-	.show = queue_max_segments_show,
-	.store = queue_max_segments_store,
-};
-
 static struct queue_sysfs_entry queue_iosched_entry = {
 	.attr = {.name = "scheduler", .mode = S_IRUGO | S_IWUSR },
 	.show = elv_iosched_show,
@@ -4137,7 +4115,6 @@ static struct attribute *default_attrs[]
 	&queue_ra_entry.attr,
 	&queue_max_hw_sectors_entry.attr,
 	&queue_max_sectors_entry.attr,
-	&queue_max_segments_entry.attr,
 	&queue_iosched_entry.attr,
 	NULL,
 };
--- a/drivers/char/sonypi.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/char/sonypi.c	2007-11-28 10:15:59.000000000 -0500
@@ -1163,7 +1163,7 @@ static struct acpi_driver sonypi_acpi_dr
 };
 #endif
 
-static int __devinit sonypi_create_input_devices(void)
+static int __devinit sonypi_create_input_devices(struct platform_device *pdev)
 {
 	struct input_dev *jog_dev;
 	struct input_dev *key_dev;
@@ -1177,6 +1177,7 @@ static int __devinit sonypi_create_input
 	jog_dev->name = "Sony Vaio Jogdial";
 	jog_dev->id.bustype = BUS_ISA;
 	jog_dev->id.vendor = PCI_VENDOR_ID_SONY;
+	jog_dev->dev.parent = &pdev->dev;
 
 	jog_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);
 	jog_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_MIDDLE);
@@ -1191,6 +1192,7 @@ static int __devinit sonypi_create_input
 	key_dev->name = "Sony Vaio Keys";
 	key_dev->id.bustype = BUS_ISA;
 	key_dev->id.vendor = PCI_VENDOR_ID_SONY;
+	key_dev->dev.parent = &pdev->dev;
 
 	/* Initialize the Input Drivers: special keys */
 	key_dev->evbit[0] = BIT_MASK(EV_KEY);
@@ -1385,7 +1387,7 @@ static int __devinit sonypi_probe(struct
 
 	if (useinput) {
 
-		error = sonypi_create_input_devices();
+		error = sonypi_create_input_devices(dev);
 		if (error) {
 			printk(KERN_ERR
 				"sonypi: failed to create input devices\n");
@@ -1432,7 +1434,7 @@ static int __devexit sonypi_remove(struc
 {
 	sonypi_disable();
 
-	synchronize_sched();  /* Allow sonypi interrupt to complete. */
+	synchronize_irq(sonypi_device.irq);
 	flush_scheduled_work();
 
 	if (useinput) {
--- a/drivers/ide/cris/ide-cris.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/cris/ide-cris.c	2007-11-28 10:15:59.000000000 -0500
@@ -773,15 +773,16 @@ init_e100_ide (void)
 	/* the IDE control register is at ATA address 6, with CS1 active instead of CS0 */
 	ide_offsets[IDE_CONTROL_OFFSET] = cris_ide_reg_addr(6, 1, 0);
 
-	/* first fill in some stuff in the ide_hwifs fields */
+	for (h = 0; h < 4; h++) {
+		ide_hwif_t *hwif = NULL;
 
-	for(h = 0; h < MAX_HWIFS; h++) {
-		ide_hwif_t *hwif = &ide_hwifs[h];
 		ide_setup_ports(&hw, cris_ide_base_address(h),
 		                ide_offsets,
 		                0, 0, cris_ide_ack_intr,
 		                ide_default_irq(0));
 		ide_register_hw(&hw, NULL, 1, &hwif);
+		if (hwif == NULL)
+			continue;
 		hwif->mmio = 1;
 		hwif->chipset = ide_etrax100;
 		hwif->set_pio_mode = &cris_set_pio_mode;
--- a/drivers/ide/ide-dma.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/ide-dma.c	2007-11-28 10:15:59.000000000 -0500
@@ -130,6 +130,7 @@ static const struct drive_list_entry dri
 	{ "_NEC DV5800A",               NULL            },
 	{ "SAMSUNG CD-ROM SN-124",	"N001" },
 	{ "Seagate STT20000A",		NULL  },
+	{ "CD-ROM CDR_U200",		"1.09" },
 	{ NULL			,	NULL		}
 
 };
--- a/drivers/ide/ide-iops.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/ide-iops.c	2007-11-28 10:15:59.000000000 -0500
@@ -303,9 +303,6 @@ void default_hwif_transport(ide_hwif_t *
 	hwif->atapi_output_bytes	= atapi_output_bytes;
 }
 
-/*
- * Beginning of Taskfile OPCODE Library and feature sets.
- */
 void ide_fix_driveid (struct hd_driveid *id)
 {
 #ifndef __LITTLE_ENDIAN
@@ -592,6 +589,9 @@ EXPORT_SYMBOL_GPL(ide_in_drive_list);
 static const struct drive_list_entry ivb_list[] = {
 	{ "QUANTUM FIREBALLlct10 05"	, "A03.0900"	},
 	{ "TSSTcorp CDDVDW SH-S202J"	, "SB00"	},
+	{ "TSSTcorp CDDVDW SH-S202J"	, "SB01"	},
+	{ "TSSTcorp CDDVDW SH-S202N"	, "SB00"	},
+	{ "TSSTcorp CDDVDW SH-S202N"	, "SB01"	},
 	{ NULL				, NULL		}
 };
 
@@ -756,7 +756,7 @@ int ide_driveid_update(ide_drive_t *driv
 int ide_config_drive_speed(ide_drive_t *drive, u8 speed)
 {
 	ide_hwif_t *hwif = drive->hwif;
-	int error;
+	int error = 0;
 	u8 stat;
 
 //	while (HWGROUP(drive)->busy)
@@ -767,6 +767,10 @@ int ide_config_drive_speed(ide_drive_t *
 		hwif->dma_host_off(drive);
 #endif
 
+	/* Skip setting PIO flow-control modes on pre-EIDE drives */
+	if ((speed & 0xf8) == XFER_PIO_0 && !(drive->id->capability & 0x08))
+		goto skip;
+
 	/*
 	 * Don't use ide_wait_cmd here - it will
 	 * attempt to set_geometry and recalibrate,
@@ -814,6 +818,7 @@ int ide_config_drive_speed(ide_drive_t *
 	drive->id->dma_mword &= ~0x0F00;
 	drive->id->dma_1word &= ~0x0F00;
 
+ skip:
 #ifdef CONFIG_BLK_DEV_IDEDMA
 	if (speed >= XFER_SW_DMA_0)
 		hwif->dma_host_on(drive);
--- a/drivers/ide/ide-probe.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/ide-probe.c	2007-11-28 10:15:59.000000000 -0500
@@ -644,7 +644,7 @@ static void hwif_register (ide_hwif_t *h
 
 static int wait_hwif_ready(ide_hwif_t *hwif)
 {
-	int rc;
+	int unit, rc;
 
 	printk(KERN_DEBUG "Probing IDE interface %s...\n", hwif->name);
 
@@ -661,20 +661,26 @@ static int wait_hwif_ready(ide_hwif_t *h
 		return rc;
 
 	/* Now make sure both master & slave are ready */
-	SELECT_DRIVE(&hwif->drives[0]);
-	hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
-	mdelay(2);
-	rc = ide_wait_not_busy(hwif, 35000);
-	if (rc)
-		return rc;
-	SELECT_DRIVE(&hwif->drives[1]);
-	hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
-	mdelay(2);
-	rc = ide_wait_not_busy(hwif, 35000);
+	for (unit = 0; unit < MAX_DRIVES; unit++) {
+		ide_drive_t *drive = &hwif->drives[unit];
 
+		/* Ignore disks that we will not probe for later. */
+		if (!drive->noprobe || drive->present) {
+			SELECT_DRIVE(drive);
+			hwif->OUTB(8, hwif->io_ports[IDE_CONTROL_OFFSET]);
+			mdelay(2);
+			rc = ide_wait_not_busy(hwif, 35000);
+			if (rc)
+				goto out;
+		} else
+			printk(KERN_DEBUG "%s: ide_wait_not_busy() skipped\n",
+					  drive->name);
+	}
+out:
 	/* Exit function with master reselected (let's be sane) */
-	SELECT_DRIVE(&hwif->drives[0]);
-	
+	if (unit)
+		SELECT_DRIVE(&hwif->drives[0]);
+
 	return rc;
 }
 
--- a/drivers/ide/Kconfig	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/Kconfig	2007-11-28 10:15:59.000000000 -0500
@@ -313,7 +313,6 @@ comment "IDE chipset support/bugfixes"
 
 config IDE_GENERIC
 	tristate "generic/default IDE chipset support"
-	default H8300
 	help
 	  If unsure, say N.
 
@@ -484,6 +483,7 @@ config WDC_ALI15X3
 
 config BLK_DEV_AMD74XX
 	tristate "AMD and nVidia IDE support"
+	depends on !ARM
 	select BLK_DEV_IDEDMA_PCI
 	help
 	  This driver adds explicit support for AMD-7xx and AMD-8111 chips
@@ -883,6 +883,49 @@ config BLK_DEV_IDE_BAST
 	  Say Y here if you want to support the onboard IDE channels on the
 	  Simtec BAST or the Thorcom VR1000
 
+config ETRAX_IDE
+	bool "ETRAX IDE support"
+	depends on CRIS && BROKEN
+	select BLK_DEV_IDEDMA
+	select IDE_GENERIC
+	help
+	  Enables the ETRAX IDE driver.
+
+	  You can't use parallel ports or SCSI ports at the same time.
+
+config ETRAX_IDE_DELAY
+	int "Delay for drives to regain consciousness"
+	depends on ETRAX_IDE && ETRAX_ARCH_V10
+	default 15
+	help
+	  Number of seconds to wait for IDE drives to spin up after an IDE
+	  reset.
+
+choice
+	prompt "IDE reset pin"
+	depends on ETRAX_IDE && ETRAX_ARCH_V10
+	default ETRAX_IDE_PB7_RESET
+
+config ETRAX_IDE_PB7_RESET
+	bool "Port_PB_Bit_7"
+	help
+	  IDE reset on pin 7 on port B
+
+config ETRAX_IDE_G27_RESET
+	bool "Port_G_Bit_27"
+	help
+	  IDE reset on pin 27 on port G
+
+endchoice
+
+config IDE_H8300
+	bool "H8300 IDE support"
+	depends on H8300
+	select IDE_GENERIC
+	default y
+	help
+	  Enables the H8300 IDE driver.
+
 config BLK_DEV_GAYLE
 	bool "Amiga Gayle IDE interface support"
 	depends on AMIGA
@@ -963,7 +1006,7 @@ config BLK_DEV_Q40IDE
 
 config BLK_DEV_MPC8xx_IDE
 	bool "MPC8xx IDE support"
-	depends on 8xx && IDE=y && BLK_DEV_IDE=y && !PPC_MERGE
+	depends on 8xx && (LWMON || IVMS8 || IVML24 || TQM8xxL) && IDE=y && BLK_DEV_IDE=y && !PPC_MERGE
 	select IDE_GENERIC
 	help
 	  This option provides support for IDE on Motorola MPC8xx Systems.
--- a/drivers/ide/legacy/ali14xx.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/legacy/ali14xx.c	2007-11-28 10:15:59.000000000 -0500
@@ -53,12 +53,13 @@
 
 /* port addresses for auto-detection */
 #define ALI_NUM_PORTS 4
-static int ports[ALI_NUM_PORTS] __initdata = {0x074, 0x0f4, 0x034, 0x0e4};
+static const int ports[ALI_NUM_PORTS] __initdata =
+	{ 0x074, 0x0f4, 0x034, 0x0e4 };
 
 /* register initialization data */
 typedef struct { u8 reg, data; } RegInitializer;
 
-static RegInitializer initData[] __initdata = {
+static const RegInitializer initData[] __initdata = {
 	{0x01, 0x0f}, {0x02, 0x00}, {0x03, 0x00}, {0x04, 0x00},
 	{0x05, 0x00}, {0x06, 0x00}, {0x07, 0x2b}, {0x0a, 0x0f},
 	{0x25, 0x00}, {0x26, 0x00}, {0x27, 0x00}, {0x28, 0x00},
@@ -177,7 +178,7 @@ static int __init findPort (void)
  * Initialize controller registers with default values.
  */
 static int __init initRegisters (void) {
-	RegInitializer *p;
+	const RegInitializer *p;
 	u8 t;
 	unsigned long flags;
 
--- a/drivers/ide/legacy/macide.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/legacy/macide.c	2007-11-28 10:15:59.000000000 -0500
@@ -81,7 +81,7 @@ int macide_ack_intr(ide_hwif_t* hwif)
  * Probe for a Macintosh IDE interface
  */
 
-void macide_init(void)
+void __init macide_init(void)
 {
 	hw_regs_t hw;
 	ide_hwif_t *hwif;
--- a/drivers/ide/legacy/q40ide.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/legacy/q40ide.c	2007-11-28 10:15:59.000000000 -0500
@@ -111,7 +111,7 @@ static const char *q40_ide_names[Q40IDE_
  *  Probe for Q40 IDE interfaces
  */
 
-void q40ide_init(void)
+void __init q40ide_init(void)
 {
     int i;
     ide_hwif_t *hwif;
--- a/drivers/ide/Makefile	2007-07-08 19:32:17.000000000 -0400
+++ b/drivers/ide/Makefile	2007-11-28 10:15:59.000000000 -0500
@@ -39,7 +39,7 @@ ide-core-$(CONFIG_BLK_DEV_MPC8xx_IDE)	+=
 ide-core-$(CONFIG_BLK_DEV_IDE_PMAC)	+= ppc/pmac.o
 
 # built-in only drivers from h8300/
-ide-core-$(CONFIG_H8300)		+= h8300/ide-h8300.o
+ide-core-$(CONFIG_IDE_H8300)		+= h8300/ide-h8300.o
 
 obj-$(CONFIG_BLK_DEV_IDE)		+= ide-core.o
 obj-$(CONFIG_IDE_GENERIC)		+= ide-generic.o
--- a/drivers/ide/pci/aec62xx.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/pci/aec62xx.c	2007-11-28 10:15:59.000000000 -0500
@@ -260,6 +260,11 @@ static int __devinit aec62xx_init_one(st
 {
 	struct ide_port_info d;
 	u8 idx = id->driver_data;
+	int err;
+
+	err = pci_enable_device(dev);
+	if (err)
+		return err;
 
 	d = aec62xx_chipsets[idx];
 
@@ -272,7 +277,11 @@ static int __devinit aec62xx_init_one(st
 		}
 	}
 
-	return ide_setup_pci_device(dev, &d);
+	err = ide_setup_pci_device(dev, &d);
+	if (err)
+		pci_disable_device(dev);
+
+	return err;
 }
 
 static const struct pci_device_id aec62xx_pci_tbl[] = {
--- a/drivers/ide/pci/alim15x3.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/pci/alim15x3.c	2007-11-28 10:15:59.000000000 -0500
@@ -603,6 +603,11 @@ static int ali_cable_override(struct pci
 	    pdev->subsystem_device == 0x10AF)
 		return 1;
 
+	/* Mitac 8317 (Winbook-A) and relatives */
+	if (pdev->subsystem_vendor == 0x1071 &&
+	    pdev->subsystem_device == 0x8317)
+		return 1;
+
 	/* Systems by DMI */
 	if (dmi_check_system(cable_dmi_table))
 		return 1;
--- a/drivers/ide/pci/piix.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/pci/piix.c	2007-11-28 10:15:59.000000000 -0500
@@ -306,6 +306,7 @@ static const struct ich_laptop ich_lapto
 	{ 0x27DF, 0x0005, 0x0280 },	/* ICH7 on Acer 5602WLMi */
 	{ 0x27DF, 0x1025, 0x0110 },	/* ICH7 on Acer 3682WLMi */
 	{ 0x27DF, 0x1043, 0x1267 },	/* ICH7 on Asus W5F */
+	{ 0x27DF, 0x103C, 0x30A1 },	/* ICH7 on HP Compaq nc2400 */
 	{ 0x24CA, 0x1025, 0x0061 },	/* ICH4 on Acer Aspire 2023WLMi */
 	/* end marker */
 	{ 0, }
--- a/drivers/ide/pci/siimage.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/pci/siimage.c	2007-11-28 10:15:59.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/ide/pci/siimage.c		Version 1.18	Oct 18 2007
+ * linux/drivers/ide/pci/siimage.c		Version 1.19	Nov 16 2007
  *
  * Copyright (C) 2001-2002	Andre Hedrick <andre@linux-ide.org>
  * Copyright (C) 2003		Red Hat <alan@redhat.com>
@@ -460,48 +460,6 @@ static void sil_sata_pre_reset(ide_drive
 }
 
 /**
- *	siimage_reset	-	reset a device on an siimage controller
- *	@drive: drive to reset
- *
- *	Perform a controller level reset fo the device. For
- *	SATA we must also check the PHY.
- */
- 
-static void siimage_reset (ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	u8 reset		= 0;
-	unsigned long addr	= siimage_selreg(hwif, 0);
-
-	if (hwif->mmio) {
-		reset = hwif->INB(addr);
-		hwif->OUTB((reset|0x03), addr);
-		/* FIXME:posting */
-		udelay(25);
-		hwif->OUTB(reset, addr);
-		(void) hwif->INB(addr);
-	} else {
-		pci_read_config_byte(hwif->pci_dev, addr, &reset);
-		pci_write_config_byte(hwif->pci_dev, addr, reset|0x03);
-		udelay(25);
-		pci_write_config_byte(hwif->pci_dev, addr, reset);
-		pci_read_config_byte(hwif->pci_dev, addr, &reset);
-	}
-
-	if (SATA_STATUS_REG) {
-		/* SATA_STATUS_REG is valid only when in MMIO mode */
-		u32 sata_stat = readl((void __iomem *)SATA_STATUS_REG);
-		printk(KERN_WARNING "%s: reset phy, status=0x%08x, %s\n",
-			hwif->name, sata_stat, __FUNCTION__);
-		if (!(sata_stat)) {
-			printk(KERN_WARNING "%s: reset phy dead, status=0x%08x\n",
-				hwif->name, sata_stat);
-			drive->failures++;
-		}
-	}
-}
-
-/**
  *	proc_reports_siimage		-	add siimage controller to proc
  *	@dev: PCI device
  *	@clocking: SCSC value
@@ -857,7 +815,6 @@ static void __devinit init_hwif_siimage(
 {
 	u8 sata = is_sata(hwif);
 
-	hwif->resetproc = &siimage_reset;
 	hwif->set_pio_mode = &sil_set_pio_mode;
 	hwif->set_dma_mode = &sil_set_dma_mode;
 
--- a/drivers/ide/pci/sis5513.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/pci/sis5513.c	2007-11-28 10:15:59.000000000 -0500
@@ -526,6 +526,7 @@ static const struct sis_laptop sis_lapto
 	/* devid, subvendor, subdev */
 	{ 0x5513, 0x1043, 0x1107 },	/* ASUS A6K */
 	{ 0x5513, 0x1734, 0x105f },	/* FSC Amilo A1630 */
+	{ 0x5513, 0x1071, 0x8640 },     /* EasyNote K5305 */
 	/* end marker */
 	{ 0, }
 };
--- a/drivers/ide/pci/trm290.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/pci/trm290.c	2007-11-28 10:15:59.000000000 -0500
@@ -240,9 +240,6 @@ static int trm290_ide_dma_test_irq (ide_
 	return (status == 0x00ff);
 }
 
-/*
- * Invoked from ide-dma.c at boot time.
- */
 static void __devinit init_hwif_trm290(ide_hwif_t *hwif)
 {
 	unsigned int cfgbase = 0;
--- a/drivers/ide/ppc/pmac.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/ide/ppc/pmac.c	2007-11-28 10:15:59.000000000 -0500
@@ -1513,7 +1513,7 @@ pmac_ide_build_dmatable(ide_drive_t *dri
 
 		if (pmif->broken_dma && cur_addr & (L1_CACHE_BYTES - 1)) {
 			if (pmif->broken_dma_warn == 0) {
-				printk(KERN_WARNING "%s: DMA on non aligned address,"
+				printk(KERN_WARNING "%s: DMA on non aligned address, "
 				       "switching to PIO on Ohare chipset\n", drive->name);
 				pmif->broken_dma_warn = 1;
 			}
--- a/drivers/infiniband/hw/ehca/ehca_qp.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/infiniband/hw/ehca/ehca_qp.c	2007-11-28 10:15:59.000000000 -0500
@@ -1203,7 +1203,7 @@ static int internal_modify_qp(struct ib_
 		mqpcb->service_level = attr->ah_attr.sl;
 		update_mask |= EHCA_BMASK_SET(MQPCB_MASK_SERVICE_LEVEL, 1);
 
-		if (ehca_calc_ipd(shca, my_qp->init_attr.port_num,
+		if (ehca_calc_ipd(shca, mqpcb->prim_phys_port,
 				  attr->ah_attr.static_rate,
 				  &mqpcb->max_static_rate)) {
 			ret = -EINVAL;
@@ -1302,7 +1302,7 @@ static int internal_modify_qp(struct ib_
 		mqpcb->source_path_bits_al = attr->alt_ah_attr.src_path_bits;
 		mqpcb->service_level_al = attr->alt_ah_attr.sl;
 
-		if (ehca_calc_ipd(shca, my_qp->init_attr.port_num,
+		if (ehca_calc_ipd(shca, mqpcb->alt_phys_port,
 				  attr->alt_ah_attr.static_rate,
 				  &mqpcb->max_static_rate_al)) {
 			ret = -EINVAL;
--- a/drivers/infiniband/hw/ipath/ipath_cq.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/infiniband/hw/ipath/ipath_cq.c	2007-11-28 10:15:59.000000000 -0500
@@ -395,12 +395,9 @@ int ipath_resize_cq(struct ib_cq *ibcq, 
 		goto bail;
 	}
 
-	/*
-	 * Return the address of the WC as the offset to mmap.
-	 * See ipath_mmap() for details.
-	 */
+	/* Check that we can write the offset to mmap. */
 	if (udata && udata->outlen >= sizeof(__u64)) {
-		__u64 offset = (__u64) wc;
+		__u64 offset = 0;
 
 		ret = ib_copy_to_udata(udata, &offset, sizeof(offset));
 		if (ret)
@@ -450,6 +447,18 @@ int ipath_resize_cq(struct ib_cq *ibcq, 
 		struct ipath_mmap_info *ip = cq->ip;
 
 		ipath_update_mmap_info(dev, ip, sz, wc);
+
+		/*
+		 * Return the offset to mmap.
+		 * See ipath_mmap() for details.
+		 */
+		if (udata && udata->outlen >= sizeof(__u64)) {
+			ret = ib_copy_to_udata(udata, &ip->offset,
+					       sizeof(ip->offset));
+			if (ret)
+				goto bail;
+		}
+
 		spin_lock_irq(&dev->pending_lock);
 		if (list_empty(&ip->pending_mmaps))
 			list_add(&ip->pending_mmaps, &dev->pending_mmaps);
--- a/drivers/infiniband/hw/ipath/ipath_qp.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/infiniband/hw/ipath/ipath_qp.c	2007-11-28 10:15:59.000000000 -0500
@@ -835,7 +835,8 @@ struct ib_qp *ipath_create_qp(struct ib_
 				      init_attr->qp_type);
 		if (err) {
 			ret = ERR_PTR(err);
-			goto bail_rwq;
+			vfree(qp->r_rq.wq);
+			goto bail_qp;
 		}
 		qp->ip = NULL;
 		ipath_reset_qp(qp);
@@ -863,7 +864,7 @@ struct ib_qp *ipath_create_qp(struct ib_
 					       sizeof(offset));
 			if (err) {
 				ret = ERR_PTR(err);
-				goto bail_rwq;
+				goto bail_ip;
 			}
 		} else {
 			u32 s = sizeof(struct ipath_rwq) +
@@ -875,7 +876,7 @@ struct ib_qp *ipath_create_qp(struct ib_
 						   qp->r_rq.wq);
 			if (!qp->ip) {
 				ret = ERR_PTR(-ENOMEM);
-				goto bail_rwq;
+				goto bail_ip;
 			}
 
 			err = ib_copy_to_udata(udata, &(qp->ip->offset),
@@ -907,9 +908,11 @@ struct ib_qp *ipath_create_qp(struct ib_
 	goto bail;
 
 bail_ip:
-	kfree(qp->ip);
-bail_rwq:
-	vfree(qp->r_rq.wq);
+	if (qp->ip)
+		kref_put(&qp->ip->ref, ipath_release_mmap_info);
+	else
+		vfree(qp->r_rq.wq);
+	ipath_free_qp(&dev->qp_table, qp);
 bail_qp:
 	kfree(qp);
 bail_swq:
--- a/drivers/infiniband/hw/ipath/ipath_srq.c	2007-11-07 10:27:34.000000000 -0500
+++ b/drivers/infiniband/hw/ipath/ipath_srq.c	2007-11-28 10:15:59.000000000 -0500
@@ -59,7 +59,7 @@ int ipath_post_srq_receive(struct ib_srq
 
 		if ((unsigned) wr->num_sge > srq->rq.max_sge) {
 			*bad_wr = wr;
-			ret = -ENOMEM;
+			ret = -EINVAL;
 			goto bail;
 		}
 
@@ -211,11 +211,11 @@ int ipath_modify_srq(struct ib_srq *ibsr
 		     struct ib_udata *udata)
 {
 	struct ipath_srq *srq = to_isrq(ibsrq);
+	struct ipath_rwq *wq;
 	int ret = 0;
 
 	if (attr_mask & IB_SRQ_MAX_WR) {
 		struct ipath_rwq *owq;
-		struct ipath_rwq *wq;
 		struct ipath_rwqe *p;
 		u32 sz, size, n, head, tail;
 
@@ -236,27 +236,20 @@ int ipath_modify_srq(struct ib_srq *ibsr
 			goto bail;
 		}
 
-		/*
-		 * Return the address of the RWQ as the offset to mmap.
-		 * See ipath_mmap() for details.
-		 */
+		/* Check that we can write the offset to mmap. */
 		if (udata && udata->inlen >= sizeof(__u64)) {
 			__u64 offset_addr;
-			__u64 offset = (__u64) wq;
+			__u64 offset = 0;
 
 			ret = ib_copy_from_udata(&offset_addr, udata,
 						 sizeof(offset_addr));
-			if (ret) {
-				vfree(wq);
-				goto bail;
-			}
+			if (ret)
+				goto bail_free;
 			udata->outbuf = (void __user *) offset_addr;
 			ret = ib_copy_to_udata(udata, &offset,
 					       sizeof(offset));
-			if (ret) {
-				vfree(wq);
-				goto bail;
-			}
+			if (ret)
+				goto bail_free;
 		}
 
 		spin_lock_irq(&srq->rq.lock);
@@ -277,10 +270,8 @@ int ipath_modify_srq(struct ib_srq *ibsr
 		else
 			n -= tail;
 		if (size <= n) {
-			spin_unlock_irq(&srq->rq.lock);
-			vfree(wq);
 			ret = -EINVAL;
-			goto bail;
+			goto bail_unlock;
 		}
 		n = 0;
 		p = wq->wq;
@@ -314,6 +305,18 @@ int ipath_modify_srq(struct ib_srq *ibsr
 			u32 s = sizeof(struct ipath_rwq) + size * sz;
 
 			ipath_update_mmap_info(dev, ip, s, wq);
+
+			/*
+			 * Return the offset to mmap.
+			 * See ipath_mmap() for details.
+			 */
+			if (udata && udata->inlen >= sizeof(__u64)) {
+				ret = ib_copy_to_udata(udata, &ip->offset,
+						       sizeof(ip->offset));
+				if (ret)
+					goto bail;
+			}
+
 			spin_lock_irq(&dev->pending_lock);
 			if (list_empty(&ip->pending_mmaps))
 				list_add(&ip->pending_mmaps,
@@ -328,7 +331,12 @@ int ipath_modify_srq(struct ib_srq *ibsr
 			srq->limit = attr->srq_limit;
 		spin_unlock_irq(&srq->rq.lock);
 	}
+	goto bail;
 
+bail_unlock:
+	spin_unlock_irq(&srq->rq.lock);
+bail_free:
+	vfree(wq);
 bail:
 	return ret;
 }
--- a/drivers/infiniband/hw/ipath/ipath_verbs.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/infiniband/hw/ipath/ipath_verbs.c	2007-11-28 10:15:59.000000000 -0500
@@ -302,8 +302,10 @@ static int ipath_post_one_send(struct ip
 	next = qp->s_head + 1;
 	if (next >= qp->s_size)
 		next = 0;
-	if (next == qp->s_last)
-		goto bail_inval;
+	if (next == qp->s_last) {
+		ret = -ENOMEM;
+		goto bail;
+	}
 
 	wqe = get_swqe_ptr(qp, qp->s_head);
 	wqe->wr = *wr;
@@ -404,7 +406,7 @@ static int ipath_post_receive(struct ib_
 
 		if ((unsigned) wr->num_sge > qp->r_rq.max_sge) {
 			*bad_wr = wr;
-			ret = -ENOMEM;
+			ret = -EINVAL;
 			goto bail;
 		}
 
--- a/drivers/infiniband/ulp/iser/iser_memory.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/infiniband/ulp/iser/iser_memory.c	2007-11-28 10:15:59.000000000 -0500
@@ -310,13 +310,15 @@ static unsigned int iser_data_buf_aligne
 		if (i + 1 < data->dma_nents) {
 			next_addr = ib_sg_dma_address(ibdev, sg_next(sg));
 			/* are i, i+1 fragments of the same page? */
-			if (end_addr == next_addr)
+			if (end_addr == next_addr) {
+				cnt++;
 				continue;
-			else if (!IS_4K_ALIGNED(end_addr)) {
+			} else if (!IS_4K_ALIGNED(end_addr)) {
 				ret_len = cnt + 1;
 				break;
 			}
 		}
+		cnt++;
 	}
 	if (i == data->dma_nents)
 		ret_len = cnt;	/* loop ended */
--- a/drivers/input/keyboard/gpio_keys.c	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/input/keyboard/gpio_keys.c	2007-11-28 10:15:59.000000000 -0500
@@ -75,16 +75,32 @@ static int __devinit gpio_keys_probe(str
 
 	for (i = 0; i < pdata->nbuttons; i++) {
 		struct gpio_keys_button *button = &pdata->buttons[i];
-		int irq = gpio_to_irq(button->gpio);
+		int irq;
 		unsigned int type = button->type ?: EV_KEY;
 
+		error = gpio_request(button->gpio, button->desc ?: "gpio_keys");
+		if (error < 0) {
+			pr_err("gpio-keys: failed to request GPIO %d,"
+				" error %d\n", button->gpio, error);
+			goto fail;
+		}
+
+		error = gpio_direction_input(button->gpio);
+		if (error < 0) {
+			pr_err("gpio-keys: failed to configure input"
+				" direction for GPIO %d, error %d\n",
+				button->gpio, error);
+			gpio_free(button->gpio);
+			goto fail;
+		}
+
+		irq = gpio_to_irq(button->gpio);
 		if (irq < 0) {
 			error = irq;
-			printk(KERN_ERR
-				"gpio-keys: "
-				"Unable to get irq number for GPIO %d,"
-				"error %d\n",
+			pr_err("gpio-keys: Unable to get irq number"
+				" for GPIO %d, error %d\n",
 				button->gpio, error);
+			gpio_free(button->gpio);
 			goto fail;
 		}
 
@@ -94,9 +110,9 @@ static int __devinit gpio_keys_probe(str
 				    button->desc ? button->desc : "gpio_keys",
 				    pdev);
 		if (error) {
-			printk(KERN_ERR
-				"gpio-keys: Unable to claim irq %d; error %d\n",
+			pr_err("gpio-keys: Unable to claim irq %d; error %d\n",
 				irq, error);
+			gpio_free(button->gpio);
 			goto fail;
 		}
 
@@ -108,8 +124,7 @@ static int __devinit gpio_keys_probe(str
 
 	error = input_register_device(input);
 	if (error) {
-		printk(KERN_ERR
-			"gpio-keys: Unable to register input device, "
+		pr_err("gpio-keys: Unable to register input device, "
 			"error: %d\n", error);
 		goto fail;
 	}
@@ -119,8 +134,10 @@ static int __devinit gpio_keys_probe(str
 	return 0;
 
  fail:
-	while (--i >= 0)
+	while (--i >= 0) {
 		free_irq(gpio_to_irq(pdata->buttons[i].gpio), pdev);
+		gpio_free(pdata->buttons[i].gpio);
+	}
 
 	platform_set_drvdata(pdev, NULL);
 	input_free_device(input);
@@ -139,6 +156,7 @@ static int __devexit gpio_keys_remove(st
 	for (i = 0; i < pdata->nbuttons; i++) {
 		int irq = gpio_to_irq(pdata->buttons[i].gpio);
 		free_irq(irq, pdev);
+		gpio_free(pdata->buttons[i].gpio);
 	}
 
 	input_unregister_device(input);
--- a/drivers/input/keyboard/Kconfig	2007-11-26 17:09:10.000000000 -0500
+++ b/drivers/input/keyboard/Kconfig	2007-11-28 10:15:59.000000000 -0500
@@ -286,7 +286,7 @@ config KEYBOARD_MAPLE
 
 config KEYBOARD_BFIN
 	tristate "Blackfin BF54x keypad support"
-	depends on BF54x
+	depends on (BF54x && !BF544)
 	help
 	  Say Y here if you want to use the BF54x keypad.
 
--- a/drivers/input/serio/i8042-x86ia64io.h	2007-11-07 10:27:34.000000000 -0500
+++ b/drivers/input/serio/i8042-x86ia64io.h	2007-11-28 10:15:59.000000000 -0500
@@ -110,6 +110,14 @@ static struct dmi_system_id __initdata i
 			DMI_MATCH(DMI_PRODUCT_VERSION, "5a"),
 		},
 	},
+	{
+		.ident = "Microsoft Virtual Machine",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Virtual Machine"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "VS2005R2"),
+		},
+	},
 	{ }
 };
 
--- a/drivers/kvm/kvm_main.c	2007-11-26 17:09:11.000000000 -0500
+++ b/drivers/kvm/kvm_main.c	2007-11-28 10:15:59.000000000 -0500
@@ -1188,8 +1188,7 @@ int emulate_invlpg(struct kvm_vcpu *vcpu
 
 int emulate_clts(struct kvm_vcpu *vcpu)
 {
-	vcpu->cr0 &= ~X86_CR0_TS;
-	kvm_x86_ops->set_cr0(vcpu, vcpu->cr0);
+	kvm_x86_ops->set_cr0(vcpu, vcpu->cr0 & ~X86_CR0_TS);
 	return X86EMUL_CONTINUE;
 }
 
--- a/drivers/kvm/svm.c	2007-11-26 17:09:11.000000000 -0500
+++ b/drivers/kvm/svm.c	2007-11-28 10:15:59.000000000 -0500
@@ -663,6 +663,7 @@ static void svm_vcpu_put(struct kvm_vcpu
 		wrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);
 
 	rdtscll(vcpu->host_tsc);
+	kvm_put_guest_fpu(vcpu);
 }
 
 static void svm_vcpu_decache(struct kvm_vcpu *vcpu)
--- a/drivers/kvm/x86_emulate.c	2007-11-26 17:09:11.000000000 -0500
+++ b/drivers/kvm/x86_emulate.c	2007-11-28 10:15:59.000000000 -0500
@@ -448,8 +448,7 @@ struct operand {
 
 #define JMP_REL(rel) 							\
 	do {								\
-		_eip += (int)(rel);					\
-		_eip = ((op_bytes == 2) ? (uint16_t)_eip : (uint32_t)_eip); \
+		register_address_increment(_eip, rel);			\
 	} while (0)
 
 /*
@@ -1147,7 +1146,7 @@ done_prefixes:
 			}
 			register_address_increment(_regs[VCPU_REGS_RSP],
 						   -dst.bytes);
-			if ((rc = ops->write_std(
+			if ((rc = ops->write_emulated(
 				     register_address(ctxt->ss_base,
 						      _regs[VCPU_REGS_RSP]),
 				     &dst.val, dst.bytes, ctxt->vcpu)) != 0)
@@ -1359,6 +1358,7 @@ special_insn:
 		}
 		src.val = (unsigned long) _eip;
 		JMP_REL(rel);
+		op_bytes = ad_bytes;
 		goto push;
 	}
 	case 0xe9: /* jmp rel */
--- a/drivers/misc/sony-laptop.c	2007-11-26 17:09:11.000000000 -0500
+++ b/drivers/misc/sony-laptop.c	2007-11-28 10:15:59.000000000 -0500
@@ -338,7 +338,7 @@ static void sony_laptop_report_input_eve
 		dprintk("unknown input event %.2x\n", event);
 }
 
-static int sony_laptop_setup_input(void)
+static int sony_laptop_setup_input(struct acpi_device *acpi_device)
 {
 	struct input_dev *jog_dev;
 	struct input_dev *key_dev;
@@ -379,6 +379,7 @@ static int sony_laptop_setup_input(void)
 	key_dev->name = "Sony Vaio Keys";
 	key_dev->id.bustype = BUS_ISA;
 	key_dev->id.vendor = PCI_VENDOR_ID_SONY;
+	key_dev->dev.parent = &acpi_device->dev;
 
 	/* Initialize the Input Drivers: special keys */
 	set_bit(EV_KEY, key_dev->evbit);
@@ -410,6 +411,7 @@ static int sony_laptop_setup_input(void)
 	jog_dev->name = "Sony Vaio Jogdial";
 	jog_dev->id.bustype = BUS_ISA;
 	jog_dev->id.vendor = PCI_VENDOR_ID_SONY;
+	key_dev->dev.parent = &acpi_device->dev;
 
 	jog_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);
 	jog_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_MIDDLE);
@@ -1006,7 +1008,7 @@ static int sony_nc_add(struct acpi_devic
 	}
 
 	/* setup input devices and helper fifo */
-	result = sony_laptop_setup_input();
+	result = sony_laptop_setup_input(device);
 	if (result) {
 		printk(KERN_ERR DRV_PFX
 				"Unabe to create input devices.\n");
@@ -1034,7 +1036,7 @@ static int sony_nc_add(struct acpi_devic
 			sony_backlight_device->props.brightness =
 			    sony_backlight_get_brightness
 			    (sony_backlight_device);
-			sony_backlight_device->props.max_brightness = 
+			sony_backlight_device->props.max_brightness =
 			    SONY_MAX_BRIGHTNESS - 1;
 		}
 
@@ -2453,7 +2455,7 @@ static int sony_pic_add(struct acpi_devi
 	}
 
 	/* setup input devices and helper fifo */
-	result = sony_laptop_setup_input();
+	result = sony_laptop_setup_input(device);
 	if (result) {
 		printk(KERN_ERR DRV_PFX
 				"Unabe to create input devices.\n");
--- a/drivers/mmc/card/queue.c	2007-11-26 17:09:11.000000000 -0500
+++ b/drivers/mmc/card/queue.c	2007-11-28 10:15:59.000000000 -0500
@@ -180,12 +180,13 @@ int mmc_init_queue(struct mmc_queue *mq,
 		blk_queue_max_hw_segments(mq->queue, host->max_hw_segs);
 		blk_queue_max_segment_size(mq->queue, host->max_seg_size);
 
-		mq->sg = kzalloc(sizeof(struct scatterlist) *
+		mq->sg = kmalloc(sizeof(struct scatterlist) *
 			host->max_phys_segs, GFP_KERNEL);
 		if (!mq->sg) {
 			ret = -ENOMEM;
 			goto cleanup_queue;
 		}
+		sg_init_table(mq->sg, host->max_phys_segs);
 	}
 
 	init_MUTEX(&mq->thread_sem);
--- a/drivers/net/mlx4/qp.c	2007-11-26 17:09:12.000000000 -0500
+++ b/drivers/net/mlx4/qp.c	2007-11-28 10:15:59.000000000 -0500
@@ -113,7 +113,7 @@ int mlx4_qp_modify(struct mlx4_dev *dev,
 	struct mlx4_cmd_mailbox *mailbox;
 	int ret = 0;
 
-	if (cur_state >= MLX4_QP_NUM_STATE || cur_state >= MLX4_QP_NUM_STATE ||
+	if (cur_state >= MLX4_QP_NUM_STATE || new_state >= MLX4_QP_NUM_STATE ||
 	    !op[cur_state][new_state])
 		return -EINVAL;
 
--- a/drivers/scsi/ide-scsi.c	2007-11-26 17:09:28.000000000 -0500
+++ b/drivers/scsi/ide-scsi.c	2007-11-28 10:15:59.000000000 -0500
@@ -242,16 +242,6 @@ static void idescsi_output_buffers (ide_
 	}
 }
 
-static void hexdump(u8 *x, int len)
-{
-	int i;
-
-	printk("[ ");
-	for (i = 0; i < len; i++)
-		printk("%x ", x[i]);
-	printk("]\n");
-}
-
 static int idescsi_check_condition(ide_drive_t *drive, struct request *failed_command)
 {
 	idescsi_scsi_t *scsi = drive_to_idescsi(drive);
@@ -282,7 +272,8 @@ static int idescsi_check_condition(ide_d
 	pc->scsi_cmd = ((idescsi_pc_t *) failed_command->special)->scsi_cmd;
 	if (test_bit(IDESCSI_LOG_CMD, &scsi->log)) {
 		printk ("ide-scsi: %s: queue cmd = ", drive->name);
-		hexdump(pc->c, 6);
+		print_hex_dump(KERN_CONT, "", DUMP_PREFIX_NONE, 16, 1, pc->c,
+			       6, 0);
 	}
 	rq->rq_disk = scsi->disk;
 	return ide_do_drive_cmd(drive, rq, ide_preempt);
@@ -337,7 +328,8 @@ static int idescsi_end_request (ide_driv
 		idescsi_pc_t *opc = (idescsi_pc_t *) rq->buffer;
 		if (log) {
 			printk ("ide-scsi: %s: wrap up check %lu, rst = ", drive->name, opc->scsi_cmd->serial_number);
-			hexdump(pc->buffer,16);
+			print_hex_dump(KERN_CONT, "", DUMP_PREFIX_NONE, 16, 1,
+				       pc->buffer, 16, 0);
 		}
 		memcpy((void *) opc->scsi_cmd->sense_buffer, pc->buffer, SCSI_SENSE_BUFFERSIZE);
 		kfree(pc->buffer);
@@ -816,10 +808,12 @@ static int idescsi_queue (struct scsi_cm
 
 	if (test_bit(IDESCSI_LOG_CMD, &scsi->log)) {
 		printk ("ide-scsi: %s: que %lu, cmd = ", drive->name, cmd->serial_number);
-		hexdump(cmd->cmnd, cmd->cmd_len);
+		print_hex_dump(KERN_CONT, "", DUMP_PREFIX_NONE, 16, 1,
+			       cmd->cmnd, cmd->cmd_len, 0);
 		if (memcmp(pc->c, cmd->cmnd, cmd->cmd_len)) {
 			printk ("ide-scsi: %s: que %lu, tsl = ", drive->name, cmd->serial_number);
-			hexdump(pc->c, 12);
+			print_hex_dump(KERN_CONT, "", DUMP_PREFIX_NONE, 16, 1,
+				       pc->c, 12, 0);
 		}
 	}
 
--- a/fs/Kconfig	2007-11-26 17:09:40.000000000 -0500
+++ b/fs/Kconfig	2007-11-28 10:15:59.000000000 -0500
@@ -459,6 +459,15 @@ config OCFS2_DEBUG_MASKLOG
 	  This option will enlarge your kernel, but it allows debugging of
 	  ocfs2 filesystem issues.
 
+config OCFS2_DEBUG_FS
+	bool "OCFS2 expensive checks"
+	depends on OCFS2_FS
+	default n
+	help
+	  This option will enable expensive consistency checks. Enable
+	  this option for debugging only as it is likely to decrease
+	  performance of the filesystem.
+
 config MINIX_FS
 	tristate "Minix fs support"
 	help
--- a/fs/ocfs2/aops.c	2007-11-26 17:09:46.000000000 -0500
+++ b/fs/ocfs2/aops.c	2007-11-28 10:15:59.000000000 -0500
@@ -1514,7 +1514,7 @@ int ocfs2_size_fits_inline_data(struct b
 {
 	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
 
-	if (new_size < le16_to_cpu(di->id2.i_data.id_count))
+	if (new_size <= le16_to_cpu(di->id2.i_data.id_count))
 		return 1;
 	return 0;
 }
--- a/fs/ocfs2/cluster/masklog.h	2007-11-26 17:09:46.000000000 -0500
+++ b/fs/ocfs2/cluster/masklog.h	2007-11-28 10:15:59.000000000 -0500
@@ -212,7 +212,7 @@ extern struct mlog_bits mlog_and_bits, m
 #define mlog_errno(st) do {						\
 	int _st = (st);							\
 	if (_st != -ERESTARTSYS && _st != -EINTR &&			\
-	    _st != AOP_TRUNCATED_PAGE)					\
+	    _st != AOP_TRUNCATED_PAGE && _st != -ENOSPC)		\
 		mlog(ML_ERROR, "status = %lld\n", (long long)_st);	\
 } while (0)
 
--- a/fs/ocfs2/dcache.c	2007-11-26 17:09:46.000000000 -0500
+++ b/fs/ocfs2/dcache.c	2007-11-28 10:15:59.000000000 -0500
@@ -344,12 +344,24 @@ static void ocfs2_dentry_iput(struct den
 {
 	struct ocfs2_dentry_lock *dl = dentry->d_fsdata;
 
-	mlog_bug_on_msg(!dl && !(dentry->d_flags & DCACHE_DISCONNECTED),
-			"dentry: %.*s\n", dentry->d_name.len,
-			dentry->d_name.name);
+	if (!dl) {
+		/*
+		 * No dentry lock is ok if we're disconnected or
+		 * unhashed.
+		 */
+		if (!(dentry->d_flags & DCACHE_DISCONNECTED) &&
+		    !d_unhashed(dentry)) {
+			unsigned long long ino = 0ULL;
+			if (inode)
+				ino = (unsigned long long)OCFS2_I(inode)->ip_blkno;
+			mlog(ML_ERROR, "Dentry is missing cluster lock. "
+			     "inode: %llu, d_flags: 0x%x, d_name: %.*s\n",
+			     ino, dentry->d_flags, dentry->d_name.len,
+			     dentry->d_name.name);
+		}
 
-	if (!dl)
 		goto out;
+	}
 
 	mlog_bug_on_msg(dl->dl_count == 0, "dentry: %.*s, count: %u\n",
 			dentry->d_name.len, dentry->d_name.name,
--- a/fs/ocfs2/dlm/dlmmaster.c	2007-11-07 10:27:37.000000000 -0500
+++ b/fs/ocfs2/dlm/dlmmaster.c	2007-11-28 10:15:59.000000000 -0500
@@ -908,7 +908,7 @@ lookup:
 		 * but they might own this lockres.  wait on them. */
 		bit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);
 		if (bit < O2NM_MAX_NODES) {
-			mlog(ML_NOTICE, "%s:%.*s: at least one node (%d) to"
+			mlog(ML_NOTICE, "%s:%.*s: at least one node (%d) to "
 			     "recover before lock mastery can begin\n",
 			     dlm->name, namelen, (char *)lockid, bit);
 			wait_on_recovery = 1;
@@ -962,7 +962,7 @@ redo_request:
 		spin_lock(&dlm->spinlock);
 		bit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);
 		if (bit < O2NM_MAX_NODES) {
-			mlog(ML_NOTICE, "%s:%.*s: at least one node (%d) to"
+			mlog(ML_NOTICE, "%s:%.*s: at least one node (%d) to "
 			     "recover before lock mastery can begin\n",
 			     dlm->name, namelen, (char *)lockid, bit);
 			wait_on_recovery = 1;
--- a/fs/ocfs2/file.c	2007-11-26 17:09:48.000000000 -0500
+++ b/fs/ocfs2/file.c	2007-11-28 10:15:59.000000000 -0500
@@ -399,7 +399,7 @@ static int ocfs2_truncate_file(struct in
 
 	if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {
 		status = ocfs2_truncate_inline(inode, di_bh, new_i_size,
-					       i_size_read(inode), 0);
+					       i_size_read(inode), 1);
 		if (status)
 			mlog_errno(status);
 
@@ -1521,6 +1521,7 @@ static int ocfs2_remove_inode_range(stru
 	u32 trunc_start, trunc_len, cpos, phys_cpos, alloc_size;
 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
 	struct ocfs2_cached_dealloc_ctxt dealloc;
+	struct address_space *mapping = inode->i_mapping;
 
 	ocfs2_init_dealloc_ctxt(&dealloc);
 
@@ -1529,10 +1530,20 @@ static int ocfs2_remove_inode_range(stru
 
 	if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {
 		ret = ocfs2_truncate_inline(inode, di_bh, byte_start,
-					    byte_start + byte_len, 1);
-		if (ret)
+					    byte_start + byte_len, 0);
+		if (ret) {
 			mlog_errno(ret);
-		return ret;
+			goto out;
+		}
+		/*
+		 * There's no need to get fancy with the page cache
+		 * truncate of an inline-data inode. We're talking
+		 * about less than a page here, which will be cached
+		 * in the dinode buffer anyway.
+		 */
+		unmap_mapping_range(mapping, 0, 0, 0);
+		truncate_inode_pages(mapping, 0);
+		goto out;
 	}
 
 	trunc_start = ocfs2_clusters_for_bytes(osb->sb, byte_start);
--- a/fs/ocfs2/inode.c	2007-11-26 17:09:48.000000000 -0500
+++ b/fs/ocfs2/inode.c	2007-11-28 10:15:59.000000000 -0500
@@ -455,8 +455,8 @@ static int ocfs2_read_locked_inode(struc
 	status = -EINVAL;
 	fe = (struct ocfs2_dinode *) bh->b_data;
 	if (!OCFS2_IS_VALID_DINODE(fe)) {
-		mlog(ML_ERROR, "Invalid dinode #%llu: signature = %.*s\n",
-		     (unsigned long long)le64_to_cpu(fe->i_blkno), 7,
+		mlog(0, "Invalid dinode #%llu: signature = %.*s\n",
+		     (unsigned long long)args->fi_blkno, 7,
 		     fe->i_signature);
 		goto bail;
 	}
@@ -863,7 +863,7 @@ static int ocfs2_query_inode_wipe(struct
 	status = ocfs2_try_open_lock(inode, 1);
 	if (status == -EAGAIN) {
 		status = 0;
-		mlog(0, "Skipping delete of %llu because it is in use on"
+		mlog(0, "Skipping delete of %llu because it is in use on "
 		     "other nodes\n", (unsigned long long)oi->ip_blkno);
 		goto bail;
 	}
--- a/fs/ocfs2/localalloc.c	2007-11-07 10:27:37.000000000 -0500
+++ b/fs/ocfs2/localalloc.c	2007-11-28 10:15:59.000000000 -0500
@@ -484,6 +484,7 @@ int ocfs2_reserve_local_alloc_bits(struc
 
 	alloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;
 
+#ifdef OCFS2_DEBUG_FS
 	if (le32_to_cpu(alloc->id1.bitmap1.i_used) !=
 	    ocfs2_local_alloc_count_bits(alloc)) {
 		ocfs2_error(osb->sb, "local alloc inode %llu says it has "
@@ -494,6 +495,7 @@ int ocfs2_reserve_local_alloc_bits(struc
 		status = -EIO;
 		goto bail;
 	}
+#endif
 
 	free_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -
 		le32_to_cpu(alloc->id1.bitmap1.i_used);
@@ -712,9 +714,8 @@ static int ocfs2_sync_local_to_main(stru
 	void *bitmap;
 	struct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);
 
-	mlog_entry("total = %u, COUNT = %u, used = %u\n",
+	mlog_entry("total = %u, used = %u\n",
 		   le32_to_cpu(alloc->id1.bitmap1.i_total),
-		   ocfs2_local_alloc_count_bits(alloc),
 		   le32_to_cpu(alloc->id1.bitmap1.i_used));
 
 	if (!alloc->id1.bitmap1.i_total) {
--- a/fs/ocfs2/super.c	2007-11-26 17:09:48.000000000 -0500
+++ b/fs/ocfs2/super.c	2007-11-28 10:15:59.000000000 -0500
@@ -438,14 +438,14 @@ unlock_osb:
 	}
 
 	if (!ret) {
-		if (!ocfs2_is_hard_readonly(osb))
-			ocfs2_set_journal_params(osb);
-
 		/* Only save off the new mount options in case of a successful
 		 * remount. */
 		osb->s_mount_opt = parsed_options.mount_opt;
 		osb->s_atime_quantum = parsed_options.atime_quantum;
 		osb->preferred_slot = parsed_options.slot;
+
+		if (!ocfs2_is_hard_readonly(osb))
+			ocfs2_set_journal_params(osb);
 	}
 out:
 	return ret;
--- a/include/asm-m32r/thread_info.h	2007-11-26 17:09:56.000000000 -0500
+++ b/include/asm-m32r/thread_info.h	2007-11-28 10:15:59.000000000 -0500
@@ -149,16 +149,21 @@ static inline unsigned int get_thread_fa
 #define TIF_NEED_RESCHED	2	/* rescheduling necessary */
 #define TIF_SINGLESTEP		3	/* restore singlestep on return to user mode */
 #define TIF_IRET		4	/* return with iret */
-#define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
-					/* 31..28 fault code */
-#define TIF_MEMDIE		17
+#define TIF_RESTORE_SIGMASK	8	/* restore signal mask in do_signal() */
+#define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
+#define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		18	/* OOM killer killed process */
+#define TIF_FREEZE		19	/* is freezing for suspend */
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
 #define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
 #define _TIF_SINGLESTEP		(1<<TIF_SINGLESTEP)
 #define _TIF_IRET		(1<<TIF_IRET)
+#define _TIF_RESTORE_SIGMASK	(1<<TIF_RESTORE_SIGMASK)
+#define _TIF_USEDFPU		(1<<TIF_USEDFPU)
 #define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+#define _TIF_FREEZE		(1<<TIF_FREEZE)
 
 #define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
 #define _TIF_ALLWORK_MASK	0x0000FFFF	/* work to do on any return to u-space */
--- a/include/asm-m32r/unistd.h	2007-07-08 19:32:17.000000000 -0400
+++ b/include/asm-m32r/unistd.h	2007-11-28 10:15:59.000000000 -0500
@@ -290,10 +290,50 @@
 #define __NR_mq_getsetattr	(__NR_mq_open+5)
 #define __NR_kexec_load		283
 #define __NR_waitid		284
+/* 285 is unused */
+#define __NR_add_key		286
+#define __NR_request_key	287
+#define __NR_keyctl		288
+#define __NR_ioprio_set		289
+#define __NR_ioprio_get		290
+#define __NR_inotify_init	291
+#define __NR_inotify_add_watch	292
+#define __NR_inotify_rm_watch	293
+#define __NR_migrate_pages	294
+#define __NR_openat		295
+#define __NR_mkdirat		296
+#define __NR_mknodat		297
+#define __NR_fchownat		298
+#define __NR_futimesat		299
+#define __NR_fstatat64		300
+#define __NR_unlinkat		301
+#define __NR_renameat		302
+#define __NR_linkat		303
+#define __NR_symlinkat		304
+#define __NR_readlinkat		305
+#define __NR_fchmodat		306
+#define __NR_faccessat		307
+#define __NR_pselect6		308
+#define __NR_ppoll		309
+#define __NR_unshare		310
+#define __NR_set_robust_list	311
+#define __NR_get_robust_list	312
+#define __NR_splice		313
+#define __NR_sync_file_range	314
+#define __NR_tee		315
+#define __NR_vmsplice		316
+#define __NR_move_pages		317
+#define __NR_getcpu		318
+#define __NR_epoll_pwait	319
+#define __NR_utimensat		320
+#define __NR_signalfd		321
+#define __NR_timerfd		322
+#define __NR_eventfd		323
+#define __NR_fallocate		324
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 285
+#define NR_syscalls 325
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_STAT64
@@ -311,6 +351,30 @@
 #define __ARCH_WANT_SYS_OLDUMOUNT
 #define __ARCH_WANT_SYS_RT_SIGACTION
 
+#define __IGNORE_lchown
+#define __IGNORE_setuid
+#define __IGNORE_getuid
+#define __IGNORE_setgid
+#define __IGNORE_getgid
+#define __IGNORE_geteuid
+#define __IGNORE_getegid
+#define __IGNORE_fcntl
+#define __IGNORE_setreuid
+#define __IGNORE_setregid
+#define __IGNORE_getrlimit
+#define __IGNORE_getgroups
+#define __IGNORE_setgroups
+#define __IGNORE_select
+#define __IGNORE_mmap
+#define __IGNORE_fchown
+#define __IGNORE_setfsuid
+#define __IGNORE_setfsgid
+#define __IGNORE_setresuid
+#define __IGNORE_getresuid
+#define __IGNORE_setresgid
+#define __IGNORE_getresgid
+#define __IGNORE_chown
+
 /*
  * "Conditional" syscalls
  *
--- a/include/linux/input.h	2007-11-26 17:09:58.000000000 -0500
+++ b/include/linux/input.h	2007-11-28 10:15:59.000000000 -0500
@@ -530,6 +530,11 @@ struct input_absinfo {
 #define KEY_DOLLAR		0x1b2
 #define KEY_EURO		0x1b3
 
+#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
+#define KEY_FRAMEFORWARD	0x1b5
+
+#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
+
 #define KEY_DEL_EOL		0x1c0
 #define KEY_DEL_EOS		0x1c1
 #define KEY_INS_LINE		0x1c2
--- a/include/linux/scatterlist.h	2007-11-26 17:09:58.000000000 -0500
+++ b/include/linux/scatterlist.h	2007-11-28 10:15:59.000000000 -0500
@@ -26,6 +26,16 @@
 
 #define SG_MAGIC	0x87654321
 
+/*
+ * We overload the LSB of the page pointer to indicate whether it's
+ * a valid sg entry, or whether it points to the start of a new scatterlist.
+ * Those low bits are there for everyone! (thanks mason :-)
+ */
+#define sg_is_chain(sg)		((sg)->page_link & 0x01)
+#define sg_is_last(sg)		((sg)->page_link & 0x02)
+#define sg_chain_ptr(sg)	\
+	((struct scatterlist *) ((sg)->page_link & ~0x03))
+
 /**
  * sg_assign_page - Assign a given page to an SG entry
  * @sg:		    SG entry
@@ -47,6 +57,7 @@ static inline void sg_assign_page(struct
 	BUG_ON((unsigned long) page & 0x03);
 #ifdef CONFIG_DEBUG_SG
 	BUG_ON(sg->sg_magic != SG_MAGIC);
+	BUG_ON(sg_is_chain(sg));
 #endif
 	sg->page_link = page_link | (unsigned long) page;
 }
@@ -73,7 +84,14 @@ static inline void sg_set_page(struct sc
 	sg->length = len;
 }
 
-#define sg_page(sg)	((struct page *) ((sg)->page_link & ~0x3))
+static inline struct page *sg_page(struct scatterlist *sg)
+{
+#ifdef CONFIG_DEBUG_SG
+	BUG_ON(sg->sg_magic != SG_MAGIC);
+	BUG_ON(sg_is_chain(sg));
+#endif
+	return (struct page *)((sg)->page_link & ~0x3);
+}
 
 /**
  * sg_set_buf - Set sg entry to point at given data
@@ -88,16 +106,6 @@ static inline void sg_set_buf(struct sca
 	sg_set_page(sg, virt_to_page(buf), buflen, offset_in_page(buf));
 }
 
-/*
- * We overload the LSB of the page pointer to indicate whether it's
- * a valid sg entry, or whether it points to the start of a new scatterlist.
- * Those low bits are there for everyone! (thanks mason :-)
- */
-#define sg_is_chain(sg)		((sg)->page_link & 0x01)
-#define sg_is_last(sg)		((sg)->page_link & 0x02)
-#define sg_chain_ptr(sg)	\
-	((struct scatterlist *) ((sg)->page_link & ~0x03))
-
 /**
  * sg_next - return the next scatterlist entry in a list
  * @sg:		The current sg entry
@@ -179,6 +187,13 @@ static inline void sg_chain(struct scatt
 #ifndef ARCH_HAS_SG_CHAIN
 	BUG();
 #endif
+
+	/*
+	 * offset and length are unused for chain entry.  Clear them.
+	 */
+	prv->offset = 0;
+	prv->length = 0;
+
 	/*
 	 * Set lowest bit to indicate a link pointer, and make sure to clear
 	 * the termination bit if it happens to be set.
--- a/Makefile	2007-11-27 11:55:14.000000000 -0500
+++ b/Makefile	2007-11-28 10:15:58.000000000 -0500
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 24
-EXTRAVERSION = -rc3-git2
+EXTRAVERSION = -rc3-git3
 NAME = Arr Matey! A Hairy Bilge Rat!
 
 # *DOCUMENTATION*
