From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 2.6.37-rc3
Patch-mainline: 2.6.37-rc3

 This patch contains the differences between 2.6.37-rc2 and -rc3.

Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 Documentation/DocBook/uio-howto.tmpl                           |    6 
 Documentation/development-process/2.Process                    |   31 
 Documentation/filesystems/configfs/configfs_example_explicit.c |    2 
 Documentation/gpio.txt                                         |   10 
 Documentation/hwmon/lm93                                       |    2 
 Documentation/hwmon/max6650                                    |    2 
 Documentation/power/opp.txt                                    |    3 
 MAINTAINERS                                                    |    9 
 Makefile                                                       |    2 
 arch/blackfin/kernel/process.c                                 |    1 
 arch/frv/kernel/process.c                                      |    1 
 arch/h8300/kernel/process.c                                    |    1 
 arch/ia64/hp/sim/simscsi.c                                     |    4 
 arch/m68k/kernel/process.c                                     |    1 
 arch/m68knommu/kernel/process.c                                |    1 
 arch/mn10300/kernel/process.c                                  |    1 
 arch/parisc/hpux/sys_hpux.c                                    |    1 
 arch/parisc/kernel/sys_parisc32.c                              |    1 
 arch/powerpc/Kconfig                                           |    4 
 arch/powerpc/boot/div64.S                                      |    3 
 arch/powerpc/kernel/kgdb.c                                     |    4 
 arch/powerpc/kernel/setup_64.c                                 |    5 
 arch/powerpc/kernel/sys_ppc32.c                                |    1 
 arch/powerpc/mm/hash_utils_64.c                                |    2 
 arch/powerpc/mm/tlb_low_64e.S                                  |    5 
 arch/powerpc/mm/tlb_nohash.c                                   |    2 
 arch/powerpc/platforms/pseries/Kconfig                         |    6 
 arch/powerpc/platforms/pseries/eeh.c                           |    2 
 arch/powerpc/platforms/pseries/pci_dlpar.c                     |    2 
 arch/s390/Kconfig.debug                                        |   12 
 arch/s390/include/asm/page.h                                   |    5 
 arch/s390/kernel/compat_linux.c                                |    1 
 arch/s390/kernel/kprobes.c                                     |   70 +
 arch/s390/mm/gup.c                                             |    7 
 arch/sparc/kernel/leon_smp.c                                   |    1 
 arch/sparc/kernel/sys_sparc32.c                                |    1 
 arch/sparc/kernel/sys_sparc_32.c                               |    1 
 arch/sparc/kernel/unaligned_32.c                               |    1 
 arch/sparc/kernel/windows.c                                    |    1 
 arch/tile/kernel/compat.c                                      |    1 
 arch/tile/kernel/compat_signal.c                               |    1 
 arch/tile/kernel/signal.c                                      |    1 
 arch/tile/kernel/smpboot.c                                     |    1 
 arch/tile/kernel/sys.c                                         |    1 
 arch/tile/mm/fault.c                                           |    1 
 arch/tile/mm/hugetlbpage.c                                     |    1 
 arch/um/kernel/exec.c                                          |    1 
 arch/x86/ia32/sys_ia32.c                                       |    1 
 arch/x86/kernel/cpuid.c                                        |    1 
 arch/x86/kernel/kgdb.c                                         |   12 
 arch/x86/kernel/msr.c                                          |    1 
 arch/x86/kvm/svm.c                                             |    2 
 arch/x86/kvm/vmx.c                                             |   19 
 block/compat_ioctl.c                                           |    1 
 block/ioctl.c                                                  |    1 
 drivers/ata/libata-scsi.c                                      |   19 
 drivers/ata/sata_via.c                                         |    9 
 drivers/base/power/main.c                                      |   34 
 drivers/block/cciss_scsi.c                                     |    8 
 drivers/block/drbd/drbd_receiver.c                             |    1 
 drivers/block/drbd/drbd_worker.c                               |    1 
 drivers/char/agp/frontend.c                                    |    1 
 drivers/char/amiserial.c                                       |    1 
 drivers/char/briq_panel.c                                      |    1 
 drivers/char/hpet.c                                            |    1 
 drivers/char/hw_random/core.c                                  |    1 
 drivers/char/istallion.c                                       |    1 
 drivers/char/serial167.c                                       |    1 
 drivers/char/specialix.c                                       |    1 
 drivers/char/stallion.c                                        |    1 
 drivers/char/sx.c                                              |    1 
 drivers/char/uv_mmtimer.c                                      |    1 
 drivers/firewire/sbp2.c                                        |    4 
 drivers/gpu/drm/drm_fops.c                                     |    1 
 drivers/gpu/drm/i915/i915_drv.c                                |    3 
 drivers/gpu/drm/i915/i915_drv.h                                |    2 
 drivers/gpu/drm/i915/i915_gem.c                                |   77 +-
 drivers/gpu/drm/i915/intel_crt.c                               |  157 ++--
 drivers/gpu/drm/i915/intel_display.c                           |   12 
 drivers/gpu/drm/i915/intel_i2c.c                               |   11 
 drivers/gpu/drm/nouveau/nouveau_backlight.c                    |    9 
 drivers/gpu/drm/nouveau/nouveau_bios.c                         |    2 
 drivers/gpu/drm/nouveau/nouveau_bo.c                           |   43 +
 drivers/gpu/drm/nouveau/nouveau_connector.c                    |   77 --
 drivers/gpu/drm/nouveau/nouveau_connector.h                    |    3 
 drivers/gpu/drm/nouveau/nouveau_drv.h                          |   55 -
 drivers/gpu/drm/nouveau/nouveau_fence.c                        |    7 
 drivers/gpu/drm/nouveau/nouveau_gem.c                          |   36 -
 drivers/gpu/drm/nouveau/nouveau_hw.c                           |    8 
 drivers/gpu/drm/nouveau/nouveau_hw.h                           |   19 
 drivers/gpu/drm/nouveau/nouveau_i2c.c                          |    2 
 drivers/gpu/drm/nouveau/nouveau_irq.c                          |   42 -
 drivers/gpu/drm/nouveau/nouveau_mem.c                          |   49 -
 drivers/gpu/drm/nouveau/nouveau_object.c                       |    2 
 drivers/gpu/drm/nouveau/nouveau_pm.c                           |    7 
 drivers/gpu/drm/nouveau/nouveau_ramht.c                        |   71 +-
 drivers/gpu/drm/nouveau/nouveau_sgdma.c                        |   14 
 drivers/gpu/drm/nouveau/nouveau_state.c                        |   17 
 drivers/gpu/drm/nouveau/nouveau_temp.c                         |    2 
 drivers/gpu/drm/nouveau/nv04_crtc.c                            |    7 
 drivers/gpu/drm/nouveau/nv04_dfp.c                             |   13 
 drivers/gpu/drm/nouveau/nv04_pm.c                              |    9 
 drivers/gpu/drm/nouveau/nv50_calc.c                            |   16 
 drivers/gpu/drm/nouveau/nv50_crtc.c                            |    4 
 drivers/gpu/drm/nouveau/nv50_display.c                         |   35 
 drivers/gpu/drm/nouveau/nv50_fifo.c                            |    5 
 drivers/gpu/drm/nouveau/nv50_graph.c                           |   52 +
 drivers/gpu/drm/nouveau/nv50_instmem.c                         |    1 
 drivers/gpu/drm/radeon/evergreen.c                             |   31 
 drivers/gpu/drm/radeon/evergreen_blit_kms.c                    |    2 
 drivers/gpu/drm/radeon/r600.c                                  |    2 
 drivers/gpu/drm/radeon/r600_blit_kms.c                         |    2 
 drivers/gpu/drm/radeon/r600_cs.c                               |  311 +++++---
 drivers/gpu/drm/radeon/r600d.h                                 |    6 
 drivers/gpu/drm/radeon/radeon.h                                |    4 
 drivers/gpu/drm/radeon/radeon_benchmark.c                      |    4 
 drivers/gpu/drm/radeon/radeon_combios.c                        |   13 
 drivers/gpu/drm/radeon/radeon_connectors.c                     |   18 
 drivers/gpu/drm/radeon/radeon_device.c                         |    2 
 drivers/gpu/drm/radeon/radeon_encoders.c                       |  354 ++++++++--
 drivers/gpu/drm/radeon/radeon_gart.c                           |    4 
 drivers/gpu/drm/radeon/radeon_gem.c                            |    2 
 drivers/gpu/drm/radeon/radeon_i2c.c                            |    8 
 drivers/gpu/drm/radeon/radeon_irq.c                            |    4 
 drivers/gpu/drm/radeon/radeon_legacy_encoders.c                |    2 
 drivers/gpu/drm/radeon/radeon_mode.h                           |    5 
 drivers/gpu/drm/radeon/radeon_object.c                         |    7 
 drivers/gpu/drm/radeon/radeon_object.h                         |    7 
 drivers/gpu/drm/radeon/radeon_ring.c                           |    6 
 drivers/gpu/drm/radeon/radeon_test.c                           |    4 
 drivers/gpu/drm/radeon/radeon_ttm.c                            |    2 
 drivers/gpu/drm/radeon/rv770.c                                 |    4 
 drivers/gpu/drm/ttm/ttm_bo.c                                   |   11 
 drivers/gpu/drm/vmwgfx/vmwgfx_resource.c                       |   14 
 drivers/hid/hidraw.c                                           |    1 
 drivers/hid/usbhid/hiddev.c                                    |    1 
 drivers/infiniband/hw/ipath/ipath_file_ops.c                   |    1 
 drivers/infiniband/ulp/srp/ib_srp.c                            |    4 
 drivers/input/input.c                                          |    3 
 drivers/input/serio/serio_raw.c                                |    1 
 drivers/input/tablet/aiptek.c                                  |   28 
 drivers/media/dvb/dvb-core/dvb_ca_en50221.c                    |    1 
 drivers/media/dvb/dvb-core/dvb_frontend.c                      |    1 
 drivers/media/dvb/ngene/ngene-core.c                           |    1 
 drivers/media/dvb/ngene/ngene-dvb.c                            |    1 
 drivers/media/dvb/ngene/ngene-i2c.c                            |    1 
 drivers/media/radio/radio-mr800.c                              |    1 
 drivers/media/radio/si470x/radio-si470x.h                      |    1 
 drivers/media/video/bt8xx/bttv-driver.c                        |    1 
 drivers/media/video/cx88/cx88-blackbird.c                      |    1 
 drivers/media/video/cx88/cx88-video.c                          |    1 
 drivers/media/video/pwc/pwc-if.c                               |    1 
 drivers/media/video/s2255drv.c                                 |    1 
 drivers/media/video/saa7134/saa7134-empress.c                  |    1 
 drivers/media/video/saa7164/saa7164.h                          |    1 
 drivers/media/video/usbvision/usbvision-video.c                |    1 
 drivers/media/video/v4l2-compat-ioctl32.c                      |    1 
 drivers/message/fusion/mptfc.c                                 |    7 
 drivers/message/fusion/mptsas.c                                |    4 
 drivers/message/fusion/mptspi.c                                |    4 
 drivers/message/i2o/i2o_scsi.c                                 |    6 
 drivers/net/3c59x.c                                            |    6 
 drivers/net/8139cp.c                                           |   10 
 drivers/net/benet/be_main.c                                    |    6 
 drivers/net/bnx2x/bnx2x_main.c                                 |    2 
 drivers/net/bonding/bond_main.c                                |    2 
 drivers/net/caif/caif_spi.c                                    |    4 
 drivers/net/gianfar.c                                          |    7 
 drivers/net/ipg.c                                              |    6 
 drivers/net/r8169.c                                            |    3 
 drivers/net/wireless/ath/ath9k/eeprom_9287.c                   |    2 
 drivers/net/wireless/ath/ath9k/hif_usb.c                       |    9 
 drivers/net/wireless/ath/ath9k/htc_drv_init.c                  |    2 
 drivers/net/wireless/ath/ath9k/htc_drv_txrx.c                  |    2 
 drivers/net/wireless/ath/ath9k/init.c                          |    3 
 drivers/net/wireless/ath/ath9k/reg.h                           |    8 
 drivers/net/wireless/ath/carl9170/usb.c                        |    4 
 drivers/net/wireless/orinoco/orinoco_usb.c                     |    1 
 drivers/parisc/eisa_eeprom.c                                   |    1 
 drivers/pci/pci-sysfs.c                                        |    2 
 drivers/pci/proc.c                                             |    1 
 drivers/pnp/isapnp/proc.c                                      |    1 
 drivers/s390/block/dasd_eer.c                                  |    1 
 drivers/s390/char/fs3270.c                                     |    1 
 drivers/s390/char/tape_char.c                                  |    1 
 drivers/s390/char/tape_core.c                                  |   68 +
 drivers/s390/char/vmlogrdr.c                                   |   37 -
 drivers/s390/char/vmur.c                                       |    1 
 drivers/s390/cio/device.c                                      |   11 
 drivers/s390/crypto/zcrypt_api.c                               |    1 
 drivers/s390/scsi/zfcp_scsi.c                                  |    4 
 drivers/scsi/3w-9xxx.c                                         |    4 
 drivers/scsi/3w-sas.c                                          |    4 
 drivers/scsi/3w-xxxx.c                                         |    4 
 drivers/scsi/53c700.c                                          |    8 
 drivers/scsi/BusLogic.c                                        |    3 
 drivers/scsi/BusLogic.h                                        |    2 
 drivers/scsi/NCR5380.c                                         |    3 
 drivers/scsi/NCR5380.h                                         |    2 
 drivers/scsi/NCR53c406a.c                                      |    4 
 drivers/scsi/a100u2w.c                                         |    4 
 drivers/scsi/aacraid/linit.c                                   |    4 
 drivers/scsi/advansys.c                                        |    4 
 drivers/scsi/aha152x.c                                         |    4 
 drivers/scsi/aha1542.c                                         |    4 
 drivers/scsi/aha1542.h                                         |    2 
 drivers/scsi/aha1740.c                                         |    4 
 drivers/scsi/aic7xxx/aic79xx_osm.c                             |    4 
 drivers/scsi/aic7xxx/aic7xxx_osm.c                             |    4 
 drivers/scsi/aic7xxx_old.c                                     |    4 
 drivers/scsi/arcmsr/arcmsr_hba.c                               |    7 
 drivers/scsi/arm/acornscsi.c                                   |    4 
 drivers/scsi/arm/fas216.c                                      |   10 
 drivers/scsi/arm/fas216.h                                      |   18 
 drivers/scsi/atari_NCR5380.c                                   |    4 
 drivers/scsi/atari_scsi.c                                      |   17 
 drivers/scsi/atp870u.c                                         |    4 
 drivers/scsi/bfa/bfad_im.c                                     |    7 
 drivers/scsi/dc395x.c                                          |    3 
 drivers/scsi/dpt_i2o.c                                         |    4 
 drivers/scsi/dpti.h                                            |    2 
 drivers/scsi/dtc.h                                             |    2 
 drivers/scsi/eata.c                                            |    7 
 drivers/scsi/eata_pio.c                                        |    4 
 drivers/scsi/esp_scsi.c                                        |    4 
 drivers/scsi/fd_mcs.c                                          |    4 
 drivers/scsi/fdomain.c                                         |    4 
 drivers/scsi/fnic/fnic.h                                       |    2 
 drivers/scsi/fnic/fnic_scsi.c                                  |    4 
 drivers/scsi/g_NCR5380.h                                       |    2 
 drivers/scsi/gdth.c                                            |    6 
 drivers/scsi/hpsa.c                                            |    8 
 drivers/scsi/hptiop.c                                          |    4 
 drivers/scsi/ibmmca.c                                          |    6 
 drivers/scsi/ibmvscsi/ibmvfc.c                                 |    4 
 drivers/scsi/ibmvscsi/ibmvscsi.c                               |    4 
 drivers/scsi/imm.c                                             |    4 
 drivers/scsi/in2000.c                                          |    4 
 drivers/scsi/in2000.h                                          |    2 
 drivers/scsi/initio.c                                          |    4 
 drivers/scsi/ipr.c                                             |    4 
 drivers/scsi/ips.c                                             |    6 
 drivers/scsi/libfc/fc_fcp.c                                    |    4 
 drivers/scsi/libiscsi.c                                        |    4 
 drivers/scsi/libsas/sas_scsi_host.c                            |    4 
 drivers/scsi/lpfc/lpfc_scsi.c                                  |    4 
 drivers/scsi/mac53c94.c                                        |    4 
 drivers/scsi/megaraid.c                                        |    6 
 drivers/scsi/megaraid.h                                        |    2 
 drivers/scsi/megaraid/megaraid_mbox.c                          |    7 
 drivers/scsi/megaraid/megaraid_sas.c                           |    4 
 drivers/scsi/mesh.c                                            |    4 
 drivers/scsi/mpt2sas/mpt2sas_scsih.c                           |    4 
 drivers/scsi/ncr53c8xx.c                                       |    4 
 drivers/scsi/nsp32.c                                           |    7 
 drivers/scsi/pas16.h                                           |    2 
 drivers/scsi/pcmcia/nsp_cs.c                                   |    4 
 drivers/scsi/pcmcia/nsp_cs.h                                   |    3 
 drivers/scsi/pcmcia/sym53c500_cs.c                             |    4 
 drivers/scsi/pm8001/pm8001_sas.h                               |    1 
 drivers/scsi/pmcraid.c                                         |    4 
 drivers/scsi/ppa.c                                             |    4 
 drivers/scsi/ps3rom.c                                          |    4 
 drivers/scsi/qla1280.c                                         |    4 
 drivers/scsi/qla2xxx/qla_os.c                                  |    7 
 drivers/scsi/qla4xxx/ql4_os.c                                  |    7 
 drivers/scsi/qlogicfas408.c                                    |    4 
 drivers/scsi/qlogicfas408.h                                    |    3 
 drivers/scsi/qlogicpti.c                                       |    4 
 drivers/scsi/scsi.c                                            |   18 
 drivers/scsi/scsi_debug.c                                      |    4 
 drivers/scsi/scsi_error.c                                      |    6 
 drivers/scsi/sd.c                                              |    1 
 drivers/scsi/stex.c                                            |    4 
 drivers/scsi/sun3_NCR5380.c                                    |    4 
 drivers/scsi/sun3_scsi.h                                       |    3 
 drivers/scsi/sym53c416.c                                       |    4 
 drivers/scsi/sym53c416.h                                       |    2 
 drivers/scsi/sym53c8xx_2/sym_glue.c                            |    4 
 drivers/scsi/t128.h                                            |    3 
 drivers/scsi/tmscsim.c                                         |    4 
 drivers/scsi/u14-34f.c                                         |    6 
 drivers/scsi/ultrastor.c                                       |    4 
 drivers/scsi/ultrastor.h                                       |    3 
 drivers/scsi/vmw_pvscsi.c                                      |    4 
 drivers/scsi/wd33c93.c                                         |    6 
 drivers/scsi/wd33c93.h                                         |    3 
 drivers/scsi/wd7000.c                                          |    4 
 drivers/serial/crisv10.c                                       |    1 
 drivers/serial/serial_core.c                                   |    1 
 drivers/staging/easycap/easycap.h                              |    1 
 drivers/staging/hv/storvsc_drv.c                               |    7 
 drivers/staging/intel_sst/intel_sst_app_interface.c            |    1 
 drivers/staging/keucr/scsiglue.c                               |    4 
 drivers/staging/rtl8712/osdep_service.h                        |    1 
 drivers/staging/speakup/buffers.c                              |    1 
 drivers/staging/stradis/Kconfig                                |    2 
 drivers/tty/sysrq.c                                            |  171 +++-
 drivers/usb/core/devices.c                                     |    1 
 drivers/usb/core/devio.c                                       |    1 
 drivers/usb/core/file.c                                        |    1 
 drivers/usb/core/inode.c                                       |    1 
 drivers/usb/gadget/f_fs.c                                      |    1 
 drivers/usb/gadget/f_hid.c                                     |    1 
 drivers/usb/host/isp1362-hcd.c                                 |    1 
 drivers/usb/host/uhci-debug.c                                  |    1 
 drivers/usb/image/microtek.c                                   |    6 
 drivers/usb/mon/mon_bin.c                                      |    1 
 drivers/usb/mon/mon_stat.c                                     |    1 
 drivers/usb/serial/usb-serial.c                                |    1 
 drivers/usb/storage/scsiglue.c                                 |    4 
 drivers/usb/storage/uas.c                                      |    4 
 drivers/video/console/vgacon.c                                 |    1 
 drivers/xen/xenfs/privcmd.c                                    |    1 
 drivers/zorro/proc.c                                           |    1 
 fs/block_dev.c                                                 |    1 
 fs/ceph/addr.c                                                 |    6 
 fs/ceph/caps.c                                                 |   17 
 fs/ceph/dir.c                                                  |   16 
 fs/ceph/file.c                                                 |   52 -
 fs/ceph/inode.c                                                |   50 -
 fs/ceph/mds_client.c                                           |    8 
 fs/ceph/mds_client.h                                           |    2 
 fs/ceph/super.h                                                |    4 
 fs/compat_ioctl.c                                              |    1 
 fs/ecryptfs/super.c                                            |    1 
 fs/ext3/super.c                                                |    1 
 fs/ext4/ioctl.c                                                |   24 
 fs/ext4/page-io.c                                              |    4 
 fs/ext4/super.c                                                |    9 
 fs/ioctl.c                                                     |   40 -
 fs/jbd2/journal.c                                              |   16 
 fs/lockd/clntlock.c                                            |    1 
 fs/lockd/clntproc.c                                            |    1 
 fs/lockd/host.c                                                |   11 
 fs/lockd/svc4proc.c                                            |    1 
 fs/lockd/svclock.c                                             |    1 
 fs/lockd/svcproc.c                                             |    1 
 fs/locks.c                                                     |    1 
 fs/namespace.c                                                 |    1 
 fs/ncpfs/dir.c                                                 |    1 
 fs/ncpfs/file.c                                                |    1 
 fs/ncpfs/inode.c                                               |    1 
 fs/ncpfs/ioctl.c                                               |    1 
 fs/nfs/callback.c                                              |    1 
 fs/nfs/delegation.c                                            |    1 
 fs/nfs/dir.c                                                   |  100 +-
 fs/nfs/nfs2xdr.c                                               |    4 
 fs/nfs/nfs3xdr.c                                               |    4 
 fs/nfs/nfs4proc.c                                              |    4 
 fs/nfs/nfs4xdr.c                                               |    2 
 fs/nfs/super.c                                                 |    9 
 fs/nfsd/nfs4state.c                                            |    8 
 fs/ocfs2/super.c                                               |    1 
 fs/proc/inode.c                                                |    1 
 fs/read_write.c                                                |    1 
 fs/reiserfs/inode.c                                            |    1 
 fs/reiserfs/ioctl.c                                            |    1 
 fs/reiserfs/journal.c                                          |    1 
 fs/reiserfs/super.c                                            |    1 
 include/drm/nouveau_drm.h                                      |    7 
 include/linux/ceph/libceph.h                                   |    3 
 include/linux/ceph/messenger.h                                 |    1 
 include/linux/ceph/osd_client.h                                |    7 
 include/linux/fs.h                                             |    1 
 include/linux/hardirq.h                                        |    6 
 include/linux/libata.h                                         |    2 
 include/linux/lockd/lockd.h                                    |    1 
 include/linux/nfs_fs.h                                         |    6 
 include/linux/reiserfs_fs.h                                    |    1 
 include/linux/rtnetlink.h                                      |    2 
 include/linux/sched.h                                          |    1 
 include/linux/smp_lock.h                                       |    3 
 include/linux/tty.h                                            |    1 
 include/net/cfg80211.h                                         |    2 
 include/net/neighbour.h                                        |    2 
 include/scsi/libfc.h                                           |    3 
 include/scsi/libiscsi.h                                        |    3 
 include/scsi/libsas.h                                          |    3 
 include/scsi/scsi_host.h                                       |   23 
 init/main.c                                                    |    1 
 kernel/debug/kdb/kdb_main.c                                    |   21 
 kernel/futex.c                                                 |    3 
 kernel/futex_compat.c                                          |    3 
 kernel/pm_qos_params.c                                         |    4 
 kernel/power/Kconfig                                           |    4 
 kernel/sched.c                                                 |   39 -
 kernel/sched_fair.c                                            |   40 -
 kernel/sched_stoptask.c                                        |    4 
 kernel/sysctl.c                                                |    2 
 kernel/trace/Kconfig                                           |    2 
 kernel/trace/trace.c                                           |    1 
 net/ceph/messenger.c                                           |   13 
 net/ceph/osd_client.c                                          |   25 
 net/ceph/pagevec.c                                             |    3 
 net/core/filter.c                                              |    2 
 net/core/net-sysfs.c                                           |   10 
 net/ipv4/icmp.c                                                |    3 
 net/ipv6/addrconf.c                                            |   28 
 net/irda/af_irda.c                                             |    1 
 net/irda/irnet/irnet_ppp.c                                     |    1 
 net/irda/irttp.c                                               |   30 
 net/netfilter/ipvs/Kconfig                                     |    1 
 net/rds/rdma.c                                                 |    2 
 net/sunrpc/stats.c                                             |    4 
 net/sunrpc/svc_xprt.c                                          |    1 
 net/wireless/chan.c                                            |   54 +
 scripts/kernel-doc                                             |   12 
 sound/core/info.c                                              |    1 
 sound/core/pcm_native.c                                        |    1 
 sound/core/sound.c                                             |    1 
 sound/sound_core.c                                             |    1 
 412 files changed, 2472 insertions(+), 1327 deletions(-)

diff -urN linux-2.6.37-rc2/Documentation/DocBook/uio-howto.tmpl linux-2.6.37-rc3/Documentation/DocBook/uio-howto.tmpl
--- linux-2.6.37-rc2/Documentation/DocBook/uio-howto.tmpl	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/Documentation/DocBook/uio-howto.tmpl	2010-11-21 23:40:15.982238415 +0000
@@ -16,7 +16,7 @@
 	</orgname>
 
 	<address>
-	   <email>hjk@linutronix.de</email>
+	   <email>hjk@hansjkoch.de</email>
 	</address>
     </affiliation>
 </author>
@@ -114,7 +114,7 @@
 
 <para>If you know of any translations for this document, or you are
 interested in translating it, please email me
-<email>hjk@linutronix.de</email>.
+<email>hjk@hansjkoch.de</email>.
 </para>
 </sect1>
 
@@ -171,7 +171,7 @@
 <title>Feedback</title>
 	<para>Find something wrong with this document? (Or perhaps something
 	right?) I would love to hear from you. Please email me at
-	<email>hjk@linutronix.de</email>.</para>
+	<email>hjk@hansjkoch.de</email>.</para>
 </sect1>
 </chapter>
 
diff -urN linux-2.6.37-rc2/Documentation/development-process/2.Process linux-2.6.37-rc3/Documentation/development-process/2.Process
--- linux-2.6.37-rc2/Documentation/development-process/2.Process	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/Documentation/development-process/2.Process	2010-11-21 23:40:15.990260914 +0000
@@ -154,7 +154,7 @@
    inclusion, it should be accepted by a relevant subsystem maintainer -
    though this acceptance is not a guarantee that the patch will make it
    all the way to the mainline.  The patch will show up in the maintainer's
-   subsystem tree and into the staging trees (described below).  When the
+   subsystem tree and into the -next trees (described below).  When the
    process works, this step leads to more extensive review of the patch and
    the discovery of any problems resulting from the integration of this
    patch with work being done by others.
@@ -236,7 +236,7 @@
 normally the right way to go.
 
 
-2.4: STAGING TREES
+2.4: NEXT TREES
 
 The chain of subsystem trees guides the flow of patches into the kernel,
 but it also raises an interesting question: what if somebody wants to look
@@ -250,7 +250,7 @@
 the interesting subsystem trees, but that would be a big and error-prone
 job.
 
-The answer comes in the form of staging trees, where subsystem trees are
+The answer comes in the form of -next trees, where subsystem trees are
 collected for testing and review.  The older of these trees, maintained by
 Andrew Morton, is called "-mm" (for memory management, which is how it got
 started).  The -mm tree integrates patches from a long list of subsystem
@@ -275,7 +275,7 @@
 Use of the MMOTM tree is likely to be a frustrating experience, though;
 there is a definite chance that it will not even compile.
 
-The other staging tree, started more recently, is linux-next, maintained by
+The other -next tree, started more recently, is linux-next, maintained by
 Stephen Rothwell.  The linux-next tree is, by design, a snapshot of what
 the mainline is expected to look like after the next merge window closes.
 Linux-next trees are announced on the linux-kernel and linux-next mailing
@@ -303,12 +303,25 @@
 See http://lwn.net/Articles/289013/ for more information on this topic, and
 stay tuned; much is still in flux where linux-next is involved.
 
-Besides the mmotm and linux-next trees, the kernel source tree now contains
-the drivers/staging/ directory and many sub-directories for drivers or
-filesystems that are on their way to being added to the kernel tree
-proper, but they remain in drivers/staging/ while they still need more
-work.
+2.4.1: STAGING TREES
 
+The kernel source tree now contains the drivers/staging/ directory, where
+many sub-directories for drivers or filesystems that are on their way to
+being added to the kernel tree live.  They remain in drivers/staging while
+they still need more work; once complete, they can be moved into the
+kernel proper.  This is a way to keep track of drivers that aren't
+up to Linux kernel coding or quality standards, but people may want to use
+them and track development.
+
+Greg Kroah-Hartman currently (as of 2.6.36) maintains the staging tree.
+Drivers that still need work are sent to him, with each driver having
+its own subdirectory in drivers/staging/.  Along with the driver source
+files, a TODO file should be present in the directory as well.  The TODO
+file lists the pending work that the driver needs for acceptance into
+the kernel proper, as well as a list of people that should be Cc'd for any
+patches to the driver.  Staging drivers that don't currently build should
+have their config entries depend upon CONFIG_BROKEN.  Once they can
+be successfully built without outside patches, CONFIG_BROKEN can be removed.
 
 2.5: TOOLS
 
diff -urN linux-2.6.37-rc2/Documentation/filesystems/configfs/configfs_example_explicit.c linux-2.6.37-rc3/Documentation/filesystems/configfs/configfs_example_explicit.c
--- linux-2.6.37-rc2/Documentation/filesystems/configfs/configfs_example_explicit.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/Documentation/filesystems/configfs/configfs_example_explicit.c	2010-11-21 23:40:15.993204559 +0000
@@ -89,7 +89,7 @@
 	char *p = (char *) page;
 
 	tmp = simple_strtoul(p, &p, 10);
-	if (!p || (*p && (*p != '\n')))
+	if ((*p != '\0') && (*p != '\n'))
 		return -EINVAL;
 
 	if (tmp > INT_MAX)
diff -urN linux-2.6.37-rc2/Documentation/gpio.txt linux-2.6.37-rc3/Documentation/gpio.txt
--- linux-2.6.37-rc2/Documentation/gpio.txt	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/Documentation/gpio.txt	2010-11-21 23:40:15.996211531 +0000
@@ -617,6 +617,16 @@
 		is configured as an output, this value may be written;
 		any nonzero value is treated as high.
 
+		If the pin can be configured as interrupt-generating interrupt
+		and if it has been configured to generate interrupts (see the
+		description of "edge"), you can poll(2) on that file and
+		poll(2) will return whenever the interrupt was triggered. If
+		you use poll(2), set the events POLLPRI and POLLERR. If you
+		use select(2), set the file descriptor in exceptfds. After
+		poll(2) returns, either lseek(2) to the beginning of the sysfs
+		file and read the new value or close the file and re-open it
+		to read the value.
+
 	"edge" ... reads as either "none", "rising", "falling", or
 		"both". Write these strings to select the signal edge(s)
 		that will make poll(2) on the "value" file return.
diff -urN linux-2.6.37-rc2/Documentation/hwmon/lm93 linux-2.6.37-rc3/Documentation/hwmon/lm93
--- linux-2.6.37-rc2/Documentation/hwmon/lm93	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/Documentation/hwmon/lm93	2010-11-21 23:40:15.996211531 +0000
@@ -11,7 +11,7 @@
 	Mark M. Hoffman <mhoffman@lightlink.com>
 	Ported to 2.6 by Eric J. Bowersox <ericb@aspsys.com>
 	Adapted to 2.6.20 by Carsten Emde <ce@osadl.org>
-	Modified for mainline integration by Hans J. Koch <hjk@linutronix.de>
+	Modified for mainline integration by Hans J. Koch <hjk@hansjkoch.de>
 
 Module Parameters
 -----------------
diff -urN linux-2.6.37-rc2/Documentation/hwmon/max6650 linux-2.6.37-rc3/Documentation/hwmon/max6650
--- linux-2.6.37-rc2/Documentation/hwmon/max6650	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/Documentation/hwmon/max6650	2010-11-21 23:40:15.997212414 +0000
@@ -8,7 +8,7 @@
     Datasheet: http://pdfserv.maxim-ic.com/en/ds/MAX6650-MAX6651.pdf
 
 Authors:
-    Hans J. Koch <hjk@linutronix.de>
+    Hans J. Koch <hjk@hansjkoch.de>
     John Morris <john.morris@spirentcom.com>
     Claus Gindhart <claus.gindhart@kontron.com>
 
diff -urN linux-2.6.37-rc2/Documentation/power/opp.txt linux-2.6.37-rc3/Documentation/power/opp.txt
--- linux-2.6.37-rc2/Documentation/power/opp.txt	2010-11-21 23:40:10.231076309 +0000
+++ linux-2.6.37-rc3/Documentation/power/opp.txt	2010-11-21 23:40:16.006086162 +0000
@@ -37,6 +37,9 @@
 SoC framework	-> modifies on required cases certain OPPs	-> OPP layer
 		-> queries to search/retrieve information	->
 
+Architectures that provide a SoC framework for OPP should select ARCH_HAS_OPP
+to make the OPP layer available.
+
 OPP layer expects each domain to be represented by a unique device pointer. SoC
 framework registers a set of initial OPPs per device with the OPP layer. This
 list is expected to be an optimally small number typically around 5 per device.
diff -urN linux-2.6.37-rc2/MAINTAINERS linux-2.6.37-rc3/MAINTAINERS
--- linux-2.6.37-rc2/MAINTAINERS	2010-11-21 23:40:10.236078960 +0000
+++ linux-2.6.37-rc3/MAINTAINERS	2010-11-21 23:40:16.015086533 +0000
@@ -1829,6 +1829,13 @@
 S:	Supported
 F:	drivers/net/cxgb4vf/
 
+STMMAC ETHERNET DRIVER
+M:	Giuseppe Cavallaro <peppe.cavallaro@st.com>
+L:	netdev@vger.kernel.org
+W:	http://www.stlinux.com
+S:	Supported
+F:	drivers/net/stmmac/
+
 CYBERPRO FB DRIVER
 M:	Russell King <linux@arm.linux.org.uk>
 L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
@@ -2008,6 +2015,7 @@
 DOCBOOK FOR DOCUMENTATION
 M:	Randy Dunlap <rdunlap@xenotime.net>
 S:	Maintained
+F:	scripts/kernel-doc
 
 DOCKING STATION DRIVER
 M:	Shaohua Li <shaohua.li@intel.com>
@@ -2018,6 +2026,7 @@
 DOCUMENTATION
 M:	Randy Dunlap <rdunlap@xenotime.net>
 L:	linux-doc@vger.kernel.org
+T:	quilt oss.oracle.com/~rdunlap/kernel-doc-patches/current/
 S:	Maintained
 F:	Documentation/
 
diff -urN linux-2.6.37-rc2/Makefile linux-2.6.37-rc3/Makefile
--- linux-2.6.37-rc2/Makefile	2010-11-21 23:40:10.236078960 +0000
+++ linux-2.6.37-rc3/Makefile	2010-11-21 23:40:16.016087525 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 37
-EXTRAVERSION = -rc2
+EXTRAVERSION = -rc3
 NAME = Flesh-Eating Bats with Fangs
 
 # *DOCUMENTATION*
diff -urN linux-2.6.37-rc2/arch/blackfin/kernel/process.c linux-2.6.37-rc3/arch/blackfin/kernel/process.c
--- linux-2.6.37-rc2/arch/blackfin/kernel/process.c	2010-11-21 23:40:10.496090182 +0000
+++ linux-2.6.37-rc3/arch/blackfin/kernel/process.c	2010-11-21 23:40:16.277062103 +0000
@@ -7,7 +7,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/smp_lock.h>
 #include <linux/unistd.h>
 #include <linux/user.h>
 #include <linux/uaccess.h>
diff -urN linux-2.6.37-rc2/arch/frv/kernel/process.c linux-2.6.37-rc3/arch/frv/kernel/process.c
--- linux-2.6.37-rc2/arch/frv/kernel/process.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/frv/kernel/process.c	2010-11-21 23:40:16.295062662 +0000
@@ -16,7 +16,6 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
diff -urN linux-2.6.37-rc2/arch/h8300/kernel/process.c linux-2.6.37-rc3/arch/h8300/kernel/process.c
--- linux-2.6.37-rc2/arch/h8300/kernel/process.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/h8300/kernel/process.c	2010-11-21 23:40:16.296062259 +0000
@@ -28,7 +28,6 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
diff -urN linux-2.6.37-rc2/arch/ia64/hp/sim/simscsi.c linux-2.6.37-rc3/arch/ia64/hp/sim/simscsi.c
--- linux-2.6.37-rc2/arch/ia64/hp/sim/simscsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/ia64/hp/sim/simscsi.c	2010-11-21 23:40:16.296062259 +0000
@@ -202,7 +202,7 @@
 }
 
 static int
-simscsi_queuecommand (struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
+simscsi_queuecommand_lck (struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 {
 	unsigned int target_id = sc->device->id;
 	char fname[MAX_ROOT_LEN+16];
@@ -326,6 +326,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(simscsi_queuecommand)
+
 static int
 simscsi_host_reset (struct scsi_cmnd *sc)
 {
diff -urN linux-2.6.37-rc2/arch/m68k/kernel/process.c linux-2.6.37-rc3/arch/m68k/kernel/process.c
--- linux-2.6.37-rc2/arch/m68k/kernel/process.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/m68k/kernel/process.c	2010-11-21 23:40:16.308069569 +0000
@@ -18,7 +18,6 @@
 #include <linux/slab.h>
 #include <linux/fs.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
diff -urN linux-2.6.37-rc2/arch/m68knommu/kernel/process.c linux-2.6.37-rc3/arch/m68knommu/kernel/process.c
--- linux-2.6.37-rc2/arch/m68knommu/kernel/process.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/m68knommu/kernel/process.c	2010-11-21 23:40:16.309059188 +0000
@@ -19,7 +19,6 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
diff -urN linux-2.6.37-rc2/arch/mn10300/kernel/process.c linux-2.6.37-rc3/arch/mn10300/kernel/process.c
--- linux-2.6.37-rc2/arch/mn10300/kernel/process.c	2010-11-21 23:40:10.629106033 +0000
+++ linux-2.6.37-rc3/arch/mn10300/kernel/process.c	2010-11-21 23:40:16.348220925 +0000
@@ -14,7 +14,6 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
diff -urN linux-2.6.37-rc2/arch/parisc/hpux/sys_hpux.c linux-2.6.37-rc3/arch/parisc/hpux/sys_hpux.c
--- linux-2.6.37-rc2/arch/parisc/hpux/sys_hpux.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/parisc/hpux/sys_hpux.c	2010-11-21 23:40:16.357221679 +0000
@@ -28,7 +28,6 @@
 #include <linux/namei.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/syscalls.h>
 #include <linux/utsname.h>
 #include <linux/vfs.h>
diff -urN linux-2.6.37-rc2/arch/parisc/kernel/sys_parisc32.c linux-2.6.37-rc3/arch/parisc/kernel/sys_parisc32.c
--- linux-2.6.37-rc2/arch/parisc/kernel/sys_parisc32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/parisc/kernel/sys_parisc32.c	2010-11-21 23:40:16.358221582 +0000
@@ -20,7 +20,6 @@
 #include <linux/times.h>
 #include <linux/time.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/sem.h>
 #include <linux/msg.h>
 #include <linux/shm.h>
diff -urN linux-2.6.37-rc2/arch/powerpc/Kconfig linux-2.6.37-rc3/arch/powerpc/Kconfig
--- linux-2.6.37-rc2/arch/powerpc/Kconfig	2010-11-21 23:40:10.647102506 +0000
+++ linux-2.6.37-rc3/arch/powerpc/Kconfig	2010-11-21 23:40:16.359118980 +0000
@@ -4,6 +4,10 @@
 	bool
 	default y if !PPC64
 
+config 32BIT
+	bool
+	default y if PPC32
+
 config 64BIT
 	bool
 	default y if PPC64
diff -urN linux-2.6.37-rc2/arch/powerpc/boot/div64.S linux-2.6.37-rc3/arch/powerpc/boot/div64.S
--- linux-2.6.37-rc2/arch/powerpc/boot/div64.S	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/powerpc/boot/div64.S	2010-11-21 23:40:16.359118980 +0000
@@ -33,9 +33,10 @@
 	cntlzw	r0,r5		# we are shifting the dividend right
 	li	r10,-1		# to make it < 2^32, and shifting
 	srw	r10,r10,r0	# the divisor right the same amount,
-	add	r9,r4,r10	# rounding up (so the estimate cannot
+	addc	r9,r4,r10	# rounding up (so the estimate cannot
 	andc	r11,r6,r10	# ever be too large, only too small)
 	andc	r9,r9,r10
+	addze	r9,r9
 	or	r11,r5,r11
 	rotlw	r9,r9,r0
 	rotlw	r11,r11,r0
diff -urN linux-2.6.37-rc2/arch/powerpc/kernel/kgdb.c linux-2.6.37-rc3/arch/powerpc/kernel/kgdb.c
--- linux-2.6.37-rc2/arch/powerpc/kernel/kgdb.c	2010-11-21 23:40:10.662105487 +0000
+++ linux-2.6.37-rc3/arch/powerpc/kernel/kgdb.c	2010-11-21 23:40:16.367111244 +0000
@@ -337,7 +337,7 @@
 		/* FP registers 32 -> 63 */
 #if defined(CONFIG_FSL_BOOKE) && defined(CONFIG_SPE)
 		if (current)
-			memcpy(mem, current->thread.evr[regno-32],
+			memcpy(mem, &current->thread.evr[regno-32],
 					dbg_reg_def[regno].size);
 #else
 		/* fp registers not used by kernel, leave zero */
@@ -362,7 +362,7 @@
 	if (regno >= 32 && regno < 64) {
 		/* FP registers 32 -> 63 */
 #if defined(CONFIG_FSL_BOOKE) && defined(CONFIG_SPE)
-		memcpy(current->thread.evr[regno-32], mem,
+		memcpy(&current->thread.evr[regno-32], mem,
 				dbg_reg_def[regno].size);
 #else
 		/* fp registers not used by kernel, leave zero */
diff -urN linux-2.6.37-rc2/arch/powerpc/kernel/setup_64.c linux-2.6.37-rc3/arch/powerpc/kernel/setup_64.c
--- linux-2.6.37-rc2/arch/powerpc/kernel/setup_64.c	2010-11-21 23:40:10.669103362 +0000
+++ linux-2.6.37-rc3/arch/powerpc/kernel/setup_64.c	2010-11-21 23:40:16.370178812 +0000
@@ -497,9 +497,8 @@
 }
 
 /*
- * Called into from start_kernel, after lock_kernel has been called.
- * Initializes bootmem, which is unsed to manage page allocation until
- * mem_init is called.
+ * Called into from start_kernel this initializes bootmem, which is used
+ * to manage page allocation until mem_init is called.
  */
 void __init setup_arch(char **cmdline_p)
 {
diff -urN linux-2.6.37-rc2/arch/powerpc/kernel/sys_ppc32.c linux-2.6.37-rc3/arch/powerpc/kernel/sys_ppc32.c
--- linux-2.6.37-rc2/arch/powerpc/kernel/sys_ppc32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/powerpc/kernel/sys_ppc32.c	2010-11-21 23:40:16.371107968 +0000
@@ -23,7 +23,6 @@
 #include <linux/resource.h>
 #include <linux/times.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/sem.h>
 #include <linux/msg.h>
 #include <linux/shm.h>
diff -urN linux-2.6.37-rc2/arch/powerpc/mm/hash_utils_64.c linux-2.6.37-rc3/arch/powerpc/mm/hash_utils_64.c
--- linux-2.6.37-rc2/arch/powerpc/mm/hash_utils_64.c	2010-11-21 23:40:10.682102578 +0000
+++ linux-2.6.37-rc3/arch/powerpc/mm/hash_utils_64.c	2010-11-21 23:40:16.377224478 +0000
@@ -1123,7 +1123,7 @@
 	else
 #endif /* CONFIG_PPC_HAS_HASH_64K */
 		rc = __hash_page_4K(ea, access, vsid, ptep, trap, local, ssize,
-				    subpage_protection(pgdir, ea));
+				    subpage_protection(mm, ea));
 
 	/* Dump some info in case of hash insertion failure, they should
 	 * never happen so it is really useful to know if/when they do
diff -urN linux-2.6.37-rc2/arch/powerpc/mm/tlb_low_64e.S linux-2.6.37-rc3/arch/powerpc/mm/tlb_low_64e.S
--- linux-2.6.37-rc2/arch/powerpc/mm/tlb_low_64e.S	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/powerpc/mm/tlb_low_64e.S	2010-11-21 23:40:16.378221812 +0000
@@ -138,8 +138,11 @@
 	cmpldi	cr0,r15,0			/* Check for user region */
 	std	r14,EX_TLB_ESR(r12)		/* write crazy -1 to frame */
 	beq	normal_tlb_miss
+
+	li	r11,_PAGE_PRESENT|_PAGE_BAP_SX	/* Base perm */
+	oris	r11,r11,_PAGE_ACCESSED@h
 	/* XXX replace the RMW cycles with immediate loads + writes */
-1:	mfspr	r10,SPRN_MAS1
+	mfspr	r10,SPRN_MAS1
 	cmpldi	cr0,r15,8			/* Check for vmalloc region */
 	rlwinm	r10,r10,0,16,1			/* Clear TID */
 	mtspr	SPRN_MAS1,r10
diff -urN linux-2.6.37-rc2/arch/powerpc/mm/tlb_nohash.c linux-2.6.37-rc3/arch/powerpc/mm/tlb_nohash.c
--- linux-2.6.37-rc2/arch/powerpc/mm/tlb_nohash.c	2010-11-21 23:40:10.684056620 +0000
+++ linux-2.6.37-rc3/arch/powerpc/mm/tlb_nohash.c	2010-11-21 23:40:16.378221812 +0000
@@ -585,6 +585,6 @@
 	ppc64_rma_size = min_t(u64, first_memblock_size, 0x40000000);
 
 	/* Finally limit subsequent allocations */
-	memblock_set_current_limit(ppc64_memblock_base + ppc64_rma_size);
+	memblock_set_current_limit(first_memblock_base + ppc64_rma_size);
 }
 #endif /* CONFIG_PPC64 */
diff -urN linux-2.6.37-rc2/arch/powerpc/platforms/pseries/Kconfig linux-2.6.37-rc3/arch/powerpc/platforms/pseries/Kconfig
--- linux-2.6.37-rc2/arch/powerpc/platforms/pseries/Kconfig	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/powerpc/platforms/pseries/Kconfig	2010-11-21 23:40:16.381221328 +0000
@@ -47,6 +47,12 @@
 config PPC_PSERIES_DEBUG
 	depends on PPC_PSERIES && PPC_EARLY_DEBUG
 	bool "Enable extra debug logging in platforms/pseries"
+        help
+	  Say Y here if you want the pseries core to produce a bunch of
+	  debug messages to the system log. Select this if you are having a
+	  problem with the pseries core and want to see more of what is
+	  going on. This does not enable debugging in lpar.c, which must
+	  be manually done due to its verbosity.
 	default y
 
 config PPC_SMLPAR
diff -urN linux-2.6.37-rc2/arch/powerpc/platforms/pseries/eeh.c linux-2.6.37-rc3/arch/powerpc/platforms/pseries/eeh.c
--- linux-2.6.37-rc2/arch/powerpc/platforms/pseries/eeh.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/powerpc/platforms/pseries/eeh.c	2010-11-21 23:40:16.382189092 +0000
@@ -21,8 +21,6 @@
  * Please address comments and feedback to Linas Vepstas <linas@austin.ibm.com>
  */
 
-#undef DEBUG
-
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/list.h>
diff -urN linux-2.6.37-rc2/arch/powerpc/platforms/pseries/pci_dlpar.c linux-2.6.37-rc3/arch/powerpc/platforms/pseries/pci_dlpar.c
--- linux-2.6.37-rc2/arch/powerpc/platforms/pseries/pci_dlpar.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/powerpc/platforms/pseries/pci_dlpar.c	2010-11-21 23:40:16.382189092 +0000
@@ -25,8 +25,6 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#undef DEBUG
-
 #include <linux/pci.h>
 #include <asm/pci-bridge.h>
 #include <asm/ppc-pci.h>
diff -urN linux-2.6.37-rc2/arch/s390/Kconfig.debug linux-2.6.37-rc3/arch/s390/Kconfig.debug
--- linux-2.6.37-rc2/arch/s390/Kconfig.debug	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/s390/Kconfig.debug	2010-11-21 23:40:16.385237481 +0000
@@ -6,6 +6,18 @@
 
 source "lib/Kconfig.debug"
 
+config STRICT_DEVMEM
+	def_bool y
+	prompt "Filter access to /dev/mem"
+	---help---
+	  This option restricts access to /dev/mem.  If this option is
+	  disabled, you allow userspace access to all memory, including
+	  kernel and userspace memory. Accidental memory access is likely
+	  to be disastrous.
+	  Memory access is required for experts who want to debug the kernel.
+
+	  If you are unsure, say Y.
+
 config DEBUG_STRICT_USER_COPY_CHECKS
 	bool "Strict user copy size checks"
 	---help---
diff -urN linux-2.6.37-rc2/arch/s390/include/asm/page.h linux-2.6.37-rc3/arch/s390/include/asm/page.h
--- linux-2.6.37-rc2/arch/s390/include/asm/page.h	2010-11-21 23:40:10.699079631 +0000
+++ linux-2.6.37-rc3/arch/s390/include/asm/page.h	2010-11-21 23:40:16.386236074 +0000
@@ -130,6 +130,11 @@
 void arch_free_page(struct page *page, int order);
 void arch_alloc_page(struct page *page, int order);
 
+static inline int devmem_is_allowed(unsigned long pfn)
+{
+	return 0;
+}
+
 #define HAVE_ARCH_FREE_PAGE
 #define HAVE_ARCH_ALLOC_PAGE
 
diff -urN linux-2.6.37-rc2/arch/s390/kernel/compat_linux.c linux-2.6.37-rc3/arch/s390/kernel/compat_linux.c
--- linux-2.6.37-rc2/arch/s390/kernel/compat_linux.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/s390/kernel/compat_linux.c	2010-11-21 23:40:16.388237481 +0000
@@ -25,7 +25,6 @@
 #include <linux/resource.h>
 #include <linux/times.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/sem.h>
 #include <linux/msg.h>
 #include <linux/shm.h>
diff -urN linux-2.6.37-rc2/arch/s390/kernel/kprobes.c linux-2.6.37-rc3/arch/s390/kernel/kprobes.c
--- linux-2.6.37-rc2/arch/s390/kernel/kprobes.c	2010-11-21 23:40:10.705105425 +0000
+++ linux-2.6.37-rc3/arch/s390/kernel/kprobes.c	2010-11-21 23:40:16.390189258 +0000
@@ -30,6 +30,7 @@
 #include <asm/sections.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/hardirq.h>
 
 DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;
 DEFINE_PER_CPU(struct kprobe_ctlblk, kprobe_ctlblk);
@@ -212,7 +213,7 @@
 	/* Set the PER control regs, turns on single step for this address */
 	__ctl_load(kprobe_per_regs, 9, 11);
 	regs->psw.mask |= PSW_MASK_PER;
-	regs->psw.mask &= ~(PSW_MASK_IO | PSW_MASK_EXT | PSW_MASK_MCHECK);
+	regs->psw.mask &= ~(PSW_MASK_IO | PSW_MASK_EXT);
 }
 
 static void __kprobes save_previous_kprobe(struct kprobe_ctlblk *kcb)
@@ -239,7 +240,7 @@
 	__get_cpu_var(current_kprobe) = p;
 	/* Save the interrupt and per flags */
 	kcb->kprobe_saved_imask = regs->psw.mask &
-	    (PSW_MASK_PER | PSW_MASK_IO | PSW_MASK_EXT | PSW_MASK_MCHECK);
+		(PSW_MASK_PER | PSW_MASK_IO | PSW_MASK_EXT);
 	/* Save the control regs that govern PER */
 	__ctl_store(kcb->kprobe_saved_ctl, 9, 11);
 }
@@ -316,8 +317,6 @@
 		return 1;
 
 ss_probe:
-	if (regs->psw.mask & (PSW_MASK_PER | PSW_MASK_IO))
-		local_irq_disable();
 	prepare_singlestep(p, regs);
 	kcb->kprobe_status = KPROBE_HIT_SS;
 	return 1;
@@ -350,6 +349,7 @@
 	struct hlist_node *node, *tmp;
 	unsigned long flags, orig_ret_address = 0;
 	unsigned long trampoline_address = (unsigned long)&kretprobe_trampoline;
+	kprobe_opcode_t *correct_ret_addr = NULL;
 
 	INIT_HLIST_HEAD(&empty_rp);
 	kretprobe_hash_lock(current, &head, &flags);
@@ -372,10 +372,32 @@
 			/* another task is sharing our hash bucket */
 			continue;
 
-		if (ri->rp && ri->rp->handler)
-			ri->rp->handler(ri, regs);
+		orig_ret_address = (unsigned long)ri->ret_addr;
+
+		if (orig_ret_address != trampoline_address)
+			/*
+			 * This is the real return address. Any other
+			 * instances associated with this task are for
+			 * other calls deeper on the call stack
+			 */
+			break;
+	}
+
+	kretprobe_assert(ri, orig_ret_address, trampoline_address);
+
+	correct_ret_addr = ri->ret_addr;
+	hlist_for_each_entry_safe(ri, node, tmp, head, hlist) {
+		if (ri->task != current)
+			/* another task is sharing our hash bucket */
+			continue;
 
 		orig_ret_address = (unsigned long)ri->ret_addr;
+
+		if (ri->rp && ri->rp->handler) {
+			ri->ret_addr = correct_ret_addr;
+			ri->rp->handler(ri, regs);
+		}
+
 		recycle_rp_inst(ri, &empty_rp);
 
 		if (orig_ret_address != trampoline_address) {
@@ -387,7 +409,7 @@
 			break;
 		}
 	}
-	kretprobe_assert(ri, orig_ret_address, trampoline_address);
+
 	regs->psw.addr = orig_ret_address | PSW_ADDR_AMODE;
 
 	reset_current_kprobe();
@@ -465,8 +487,6 @@
 		goto out;
 	}
 	reset_current_kprobe();
-	if (regs->psw.mask & (PSW_MASK_PER | PSW_MASK_IO))
-		local_irq_enable();
 out:
 	preempt_enable_no_resched();
 
@@ -482,7 +502,7 @@
 	return 1;
 }
 
-int __kprobes kprobe_fault_handler(struct pt_regs *regs, int trapnr)
+static int __kprobes kprobe_trap_handler(struct pt_regs *regs, int trapnr)
 {
 	struct kprobe *cur = kprobe_running();
 	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
@@ -508,8 +528,6 @@
 			restore_previous_kprobe(kcb);
 		else {
 			reset_current_kprobe();
-			if (regs->psw.mask & (PSW_MASK_PER | PSW_MASK_IO))
-				local_irq_enable();
 		}
 		preempt_enable_no_resched();
 		break;
@@ -553,6 +571,18 @@
 	return 0;
 }
 
+int __kprobes kprobe_fault_handler(struct pt_regs *regs, int trapnr)
+{
+	int ret;
+
+	if (regs->psw.mask & (PSW_MASK_IO | PSW_MASK_EXT))
+		local_irq_disable();
+	ret = kprobe_trap_handler(regs, trapnr);
+	if (regs->psw.mask & (PSW_MASK_IO | PSW_MASK_EXT))
+		local_irq_restore(regs->psw.mask & ~PSW_MASK_PER);
+	return ret;
+}
+
 /*
  * Wrapper routine to for handling exceptions.
  */
@@ -560,8 +590,12 @@
 				       unsigned long val, void *data)
 {
 	struct die_args *args = (struct die_args *)data;
+	struct pt_regs *regs = args->regs;
 	int ret = NOTIFY_DONE;
 
+	if (regs->psw.mask & (PSW_MASK_IO | PSW_MASK_EXT))
+		local_irq_disable();
+
 	switch (val) {
 	case DIE_BPT:
 		if (kprobe_handler(args->regs))
@@ -572,16 +606,17 @@
 			ret = NOTIFY_STOP;
 		break;
 	case DIE_TRAP:
-		/* kprobe_running() needs smp_processor_id() */
-		preempt_disable();
-		if (kprobe_running() &&
-		    kprobe_fault_handler(args->regs, args->trapnr))
+		if (!preemptible() && kprobe_running() &&
+		    kprobe_trap_handler(args->regs, args->trapnr))
 			ret = NOTIFY_STOP;
-		preempt_enable();
 		break;
 	default:
 		break;
 	}
+
+	if (regs->psw.mask & (PSW_MASK_IO | PSW_MASK_EXT))
+		local_irq_restore(regs->psw.mask & ~PSW_MASK_PER);
+
 	return ret;
 }
 
@@ -595,6 +630,7 @@
 
 	/* setup return addr to the jprobe handler routine */
 	regs->psw.addr = (unsigned long)(jp->entry) | PSW_ADDR_AMODE;
+	regs->psw.mask &= ~(PSW_MASK_IO | PSW_MASK_EXT);
 
 	/* r14 is the function return address */
 	kcb->jprobe_saved_r14 = (unsigned long)regs->gprs[14];
diff -urN linux-2.6.37-rc2/arch/s390/mm/gup.c linux-2.6.37-rc3/arch/s390/mm/gup.c
--- linux-2.6.37-rc2/arch/s390/mm/gup.c	2010-11-21 23:40:10.710105505 +0000
+++ linux-2.6.37-rc3/arch/s390/mm/gup.c	2010-11-21 23:40:16.392189818 +0000
@@ -20,18 +20,17 @@
 static inline int gup_pte_range(pmd_t *pmdp, pmd_t pmd, unsigned long addr,
 		unsigned long end, int write, struct page **pages, int *nr)
 {
-	unsigned long mask, result;
+	unsigned long mask;
 	pte_t *ptep, pte;
 	struct page *page;
 
-	result = write ? 0 : _PAGE_RO;
-	mask = result | _PAGE_INVALID | _PAGE_SPECIAL;
+	mask = (write ? _PAGE_RO : 0) | _PAGE_INVALID | _PAGE_SPECIAL;
 
 	ptep = ((pte_t *) pmd_deref(pmd)) + pte_index(addr);
 	do {
 		pte = *ptep;
 		barrier();
-		if ((pte_val(pte) & mask) != result)
+		if ((pte_val(pte) & mask) != 0)
 			return 0;
 		VM_BUG_ON(!pfn_valid(pte_pfn(pte)));
 		page = pte_page(pte);
diff -urN linux-2.6.37-rc2/arch/sparc/kernel/leon_smp.c linux-2.6.37-rc3/arch/sparc/kernel/leon_smp.c
--- linux-2.6.37-rc2/arch/sparc/kernel/leon_smp.c	2010-11-21 23:40:10.754040407 +0000
+++ linux-2.6.37-rc3/arch/sparc/kernel/leon_smp.c	2010-11-21 23:40:16.421245140 +0000
@@ -12,7 +12,6 @@
 #include <linux/sched.h>
 #include <linux/threads.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
 #include <linux/init.h>
diff -urN linux-2.6.37-rc2/arch/sparc/kernel/sys_sparc32.c linux-2.6.37-rc3/arch/sparc/kernel/sys_sparc32.c
--- linux-2.6.37-rc2/arch/sparc/kernel/sys_sparc32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/sparc/kernel/sys_sparc32.c	2010-11-21 23:40:16.423250070 +0000
@@ -17,7 +17,6 @@
 #include <linux/resource.h>
 #include <linux/times.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/sem.h>
 #include <linux/msg.h>
 #include <linux/shm.h>
diff -urN linux-2.6.37-rc2/arch/sparc/kernel/sys_sparc_32.c linux-2.6.37-rc3/arch/sparc/kernel/sys_sparc_32.c
--- linux-2.6.37-rc2/arch/sparc/kernel/sys_sparc_32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/sparc/kernel/sys_sparc_32.c	2010-11-21 23:40:16.423250070 +0000
@@ -19,7 +19,6 @@
 #include <linux/mman.h>
 #include <linux/utsname.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/ipc.h>
 
 #include <asm/uaccess.h>
diff -urN linux-2.6.37-rc2/arch/sparc/kernel/unaligned_32.c linux-2.6.37-rc3/arch/sparc/kernel/unaligned_32.c
--- linux-2.6.37-rc2/arch/sparc/kernel/unaligned_32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/sparc/kernel/unaligned_32.c	2010-11-21 23:40:16.423250070 +0000
@@ -16,7 +16,6 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/perf_event.h>
 
 enum direction {
diff -urN linux-2.6.37-rc2/arch/sparc/kernel/windows.c linux-2.6.37-rc3/arch/sparc/kernel/windows.c
--- linux-2.6.37-rc2/arch/sparc/kernel/windows.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/sparc/kernel/windows.c	2010-11-21 23:40:16.423250070 +0000
@@ -9,7 +9,6 @@
 #include <linux/string.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 
 #include <asm/uaccess.h>
 
diff -urN linux-2.6.37-rc2/arch/tile/kernel/compat.c linux-2.6.37-rc3/arch/tile/kernel/compat.c
--- linux-2.6.37-rc2/arch/tile/kernel/compat.c	2010-11-21 23:40:10.762086869 +0000
+++ linux-2.6.37-rc3/arch/tile/kernel/compat.c	2010-11-21 23:40:16.429113161 +0000
@@ -21,7 +21,6 @@
 #include <linux/kdev_t.h>
 #include <linux/fs.h>
 #include <linux/fcntl.h>
-#include <linux/smp_lock.h>
 #include <linux/uaccess.h>
 #include <linux/signal.h>
 #include <asm/syscalls.h>
diff -urN linux-2.6.37-rc2/arch/tile/kernel/compat_signal.c linux-2.6.37-rc3/arch/tile/kernel/compat_signal.c
--- linux-2.6.37-rc2/arch/tile/kernel/compat_signal.c	2010-11-21 23:40:10.762086869 +0000
+++ linux-2.6.37-rc3/arch/tile/kernel/compat_signal.c	2010-11-21 23:40:16.429113161 +0000
@@ -15,7 +15,6 @@
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/kernel.h>
 #include <linux/signal.h>
 #include <linux/errno.h>
diff -urN linux-2.6.37-rc2/arch/tile/kernel/signal.c linux-2.6.37-rc3/arch/tile/kernel/signal.c
--- linux-2.6.37-rc2/arch/tile/kernel/signal.c	2010-11-21 23:40:10.764040353 +0000
+++ linux-2.6.37-rc3/arch/tile/kernel/signal.c	2010-11-21 23:40:16.431222365 +0000
@@ -16,7 +16,6 @@
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/kernel.h>
 #include <linux/signal.h>
 #include <linux/errno.h>
diff -urN linux-2.6.37-rc2/arch/tile/kernel/smpboot.c linux-2.6.37-rc3/arch/tile/kernel/smpboot.c
--- linux-2.6.37-rc2/arch/tile/kernel/smpboot.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/tile/kernel/smpboot.c	2010-11-21 23:40:16.431222365 +0000
@@ -18,7 +18,6 @@
 #include <linux/mm.h>
 #include <linux/sched.h>
 #include <linux/kernel_stat.h>
-#include <linux/smp_lock.h>
 #include <linux/bootmem.h>
 #include <linux/notifier.h>
 #include <linux/cpu.h>
diff -urN linux-2.6.37-rc2/arch/tile/kernel/sys.c linux-2.6.37-rc3/arch/tile/kernel/sys.c
--- linux-2.6.37-rc2/arch/tile/kernel/sys.c	2010-11-21 23:40:10.764040353 +0000
+++ linux-2.6.37-rc3/arch/tile/kernel/sys.c	2010-11-21 23:40:16.431222365 +0000
@@ -20,7 +20,6 @@
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/syscalls.h>
 #include <linux/mman.h>
 #include <linux/file.h>
diff -urN linux-2.6.37-rc2/arch/tile/mm/fault.c linux-2.6.37-rc3/arch/tile/mm/fault.c
--- linux-2.6.37-rc2/arch/tile/mm/fault.c	2010-11-21 23:40:10.767087410 +0000
+++ linux-2.6.37-rc3/arch/tile/mm/fault.c	2010-11-21 23:40:16.433220705 +0000
@@ -24,7 +24,6 @@
 #include <linux/mman.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/tty.h>
diff -urN linux-2.6.37-rc2/arch/tile/mm/hugetlbpage.c linux-2.6.37-rc3/arch/tile/mm/hugetlbpage.c
--- linux-2.6.37-rc2/arch/tile/mm/hugetlbpage.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/tile/mm/hugetlbpage.c	2010-11-21 23:40:16.433220705 +0000
@@ -21,7 +21,6 @@
 #include <linux/mm.h>
 #include <linux/hugetlb.h>
 #include <linux/pagemap.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/sysctl.h>
diff -urN linux-2.6.37-rc2/arch/um/kernel/exec.c linux-2.6.37-rc3/arch/um/kernel/exec.c
--- linux-2.6.37-rc2/arch/um/kernel/exec.c	2010-11-21 23:40:10.769087490 +0000
+++ linux-2.6.37-rc3/arch/um/kernel/exec.c	2010-11-21 23:40:16.435225215 +0000
@@ -5,7 +5,6 @@
 
 #include "linux/stddef.h"
 #include "linux/fs.h"
-#include "linux/smp_lock.h"
 #include "linux/ptrace.h"
 #include "linux/sched.h"
 #include "linux/slab.h"
diff -urN linux-2.6.37-rc2/arch/x86/ia32/sys_ia32.c linux-2.6.37-rc3/arch/x86/ia32/sys_ia32.c
--- linux-2.6.37-rc2/arch/x86/ia32/sys_ia32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/x86/ia32/sys_ia32.c	2010-11-21 23:40:16.437136344 +0000
@@ -28,7 +28,6 @@
 #include <linux/syscalls.h>
 #include <linux/times.h>
 #include <linux/utsname.h>
-#include <linux/smp_lock.h>
 #include <linux/mm.h>
 #include <linux/uio.h>
 #include <linux/poll.h>
diff -urN linux-2.6.37-rc2/arch/x86/kernel/cpuid.c linux-2.6.37-rc3/arch/x86/kernel/cpuid.c
--- linux-2.6.37-rc2/arch/x86/kernel/cpuid.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/x86/kernel/cpuid.c	2010-11-21 23:40:16.453223766 +0000
@@ -33,7 +33,6 @@
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/major.h>
 #include <linux/fs.h>
 #include <linux/device.h>
diff -urN linux-2.6.37-rc2/arch/x86/kernel/kgdb.c linux-2.6.37-rc3/arch/x86/kernel/kgdb.c
--- linux-2.6.37-rc2/arch/x86/kernel/kgdb.c	2010-11-21 23:40:10.794040815 +0000
+++ linux-2.6.37-rc3/arch/x86/kernel/kgdb.c	2010-11-21 23:40:16.459118341 +0000
@@ -315,14 +315,18 @@
 		if (!breakinfo[i].enabled)
 			continue;
 		bp = *per_cpu_ptr(breakinfo[i].pev, cpu);
-		if (bp->attr.disabled == 1)
+		if (!bp->attr.disabled) {
+			arch_uninstall_hw_breakpoint(bp);
+			bp->attr.disabled = 1;
 			continue;
+		}
 		if (dbg_is_early)
 			early_dr7 &= ~encode_dr7(i, breakinfo[i].len,
 						 breakinfo[i].type);
-		else
-			arch_uninstall_hw_breakpoint(bp);
-		bp->attr.disabled = 1;
+		else if (hw_break_release_slot(i))
+			printk(KERN_ERR "KGDB: hw bpt remove failed %lx\n",
+			       breakinfo[i].addr);
+		breakinfo[i].enabled = 0;
 	}
 }
 
diff -urN linux-2.6.37-rc2/arch/x86/kernel/msr.c linux-2.6.37-rc3/arch/x86/kernel/msr.c
--- linux-2.6.37-rc2/arch/x86/kernel/msr.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/arch/x86/kernel/msr.c	2010-11-21 23:40:16.460220131 +0000
@@ -30,7 +30,6 @@
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/major.h>
 #include <linux/fs.h>
 #include <linux/device.h>
diff -urN linux-2.6.37-rc2/arch/x86/kvm/svm.c linux-2.6.37-rc3/arch/x86/kvm/svm.c
--- linux-2.6.37-rc2/arch/x86/kvm/svm.c	2010-11-21 23:40:10.809087837 +0000
+++ linux-2.6.37-rc3/arch/x86/kvm/svm.c	2010-11-21 23:40:16.474220075 +0000
@@ -3395,6 +3395,7 @@
 	vcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;
 
 	load_host_msrs(vcpu);
+	kvm_load_ldt(ldt_selector);
 	loadsegment(fs, fs_selector);
 #ifdef CONFIG_X86_64
 	load_gs_index(gs_selector);
@@ -3402,7 +3403,6 @@
 #else
 	loadsegment(gs, gs_selector);
 #endif
-	kvm_load_ldt(ldt_selector);
 
 	reload_tss(vcpu);
 
diff -urN linux-2.6.37-rc2/arch/x86/kvm/vmx.c linux-2.6.37-rc3/arch/x86/kvm/vmx.c
--- linux-2.6.37-rc2/arch/x86/kvm/vmx.c	2010-11-21 23:40:10.810087692 +0000
+++ linux-2.6.37-rc3/arch/x86/kvm/vmx.c	2010-11-21 23:40:16.475220210 +0000
@@ -821,10 +821,9 @@
 #endif
 
 #ifdef CONFIG_X86_64
-	if (is_long_mode(&vmx->vcpu)) {
-		rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
+	rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
+	if (is_long_mode(&vmx->vcpu))
 		wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);
-	}
 #endif
 	for (i = 0; i < vmx->save_nmsrs; ++i)
 		kvm_set_shared_msr(vmx->guest_msrs[i].index,
@@ -839,23 +838,23 @@
 
 	++vmx->vcpu.stat.host_state_reload;
 	vmx->host_state.loaded = 0;
-	if (vmx->host_state.fs_reload_needed)
-		loadsegment(fs, vmx->host_state.fs_sel);
+#ifdef CONFIG_X86_64
+	if (is_long_mode(&vmx->vcpu))
+		rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);
+#endif
 	if (vmx->host_state.gs_ldt_reload_needed) {
 		kvm_load_ldt(vmx->host_state.ldt_sel);
 #ifdef CONFIG_X86_64
 		load_gs_index(vmx->host_state.gs_sel);
-		wrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);
 #else
 		loadsegment(gs, vmx->host_state.gs_sel);
 #endif
 	}
+	if (vmx->host_state.fs_reload_needed)
+		loadsegment(fs, vmx->host_state.fs_sel);
 	reload_tss();
 #ifdef CONFIG_X86_64
-	if (is_long_mode(&vmx->vcpu)) {
-		rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);
-		wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
-	}
+	wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);
 #endif
 	if (current_thread_info()->status & TS_USEDFPU)
 		clts();
diff -urN linux-2.6.37-rc2/block/compat_ioctl.c linux-2.6.37-rc3/block/compat_ioctl.c
--- linux-2.6.37-rc2/block/compat_ioctl.c	2010-11-21 23:40:10.826040899 +0000
+++ linux-2.6.37-rc3/block/compat_ioctl.c	2010-11-21 23:40:16.491224391 +0000
@@ -8,7 +8,6 @@
 #include <linux/hdreg.h>
 #include <linux/slab.h>
 #include <linux/syscalls.h>
-#include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/uaccess.h>
 
diff -urN linux-2.6.37-rc2/block/ioctl.c linux-2.6.37-rc3/block/ioctl.c
--- linux-2.6.37-rc2/block/ioctl.c	2010-11-21 23:40:10.827087702 +0000
+++ linux-2.6.37-rc3/block/ioctl.c	2010-11-21 23:40:16.491224391 +0000
@@ -5,7 +5,6 @@
 #include <linux/hdreg.h>
 #include <linux/backing-dev.h>
 #include <linux/buffer_head.h>
-#include <linux/smp_lock.h>
 #include <linux/blktrace_api.h>
 #include <asm/uaccess.h>
 
diff -urN linux-2.6.37-rc2/drivers/ata/libata-scsi.c linux-2.6.37-rc3/drivers/ata/libata-scsi.c
--- linux-2.6.37-rc2/drivers/ata/libata-scsi.c	2010-11-21 23:40:10.846113390 +0000
+++ linux-2.6.37-rc3/drivers/ata/libata-scsi.c	2010-11-21 23:40:16.507232811 +0000
@@ -3166,8 +3166,8 @@
 
 /**
  *	ata_scsi_queuecmd - Issue SCSI cdb to libata-managed device
+ *	@shost: SCSI host of command to be sent
  *	@cmd: SCSI command to be sent
- *	@done: Completion function, called when command is complete
  *
  *	In some cases, this function translates SCSI commands into
  *	ATA taskfiles, and queues the taskfiles to be sent to
@@ -3177,37 +3177,36 @@
  *	ATA and ATAPI devices appearing as SCSI devices.
  *
  *	LOCKING:
- *	Releases scsi-layer-held lock, and obtains host lock.
+ *	ATA host lock
  *
  *	RETURNS:
  *	Return value from __ata_scsi_queuecmd() if @cmd can be queued,
  *	0 otherwise.
  */
-int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+int ata_scsi_queuecmd(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
 {
 	struct ata_port *ap;
 	struct ata_device *dev;
 	struct scsi_device *scsidev = cmd->device;
-	struct Scsi_Host *shost = scsidev->host;
 	int rc = 0;
+	unsigned long irq_flags;
 
 	ap = ata_shost_to_port(shost);
 
-	spin_unlock(shost->host_lock);
-	spin_lock(ap->lock);
+	spin_lock_irqsave(ap->lock, irq_flags);
 
 	ata_scsi_dump_cdb(ap, cmd);
 
 	dev = ata_scsi_find_dev(ap, scsidev);
 	if (likely(dev))
-		rc = __ata_scsi_queuecmd(cmd, done, dev);
+		rc = __ata_scsi_queuecmd(cmd, cmd->scsi_done, dev);
 	else {
 		cmd->result = (DID_BAD_TARGET << 16);
-		done(cmd);
+		cmd->scsi_done(cmd);
 	}
 
-	spin_unlock(ap->lock);
-	spin_lock(shost->host_lock);
+	spin_unlock_irqrestore(ap->lock, irq_flags);
+
 	return rc;
 }
 
diff -urN linux-2.6.37-rc2/drivers/ata/sata_via.c linux-2.6.37-rc3/drivers/ata/sata_via.c
--- linux-2.6.37-rc2/drivers/ata/sata_via.c	2010-11-21 23:40:10.854225527 +0000
+++ linux-2.6.37-rc3/drivers/ata/sata_via.c	2010-11-21 23:40:16.511269825 +0000
@@ -538,7 +538,7 @@
 	return 0;
 }
 
-static void svia_configure(struct pci_dev *pdev)
+static void svia_configure(struct pci_dev *pdev, int board_id)
 {
 	u8 tmp8;
 
@@ -577,7 +577,7 @@
 	}
 
 	/*
-	 * vt6421 has problems talking to some drives.  The following
+	 * vt6420/1 has problems talking to some drives.  The following
 	 * is the fix from Joseph Chan <JosephChan@via.com.tw>.
 	 *
 	 * When host issues HOLD, device may send up to 20DW of data
@@ -596,8 +596,9 @@
 	 *
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=15173
 	 * http://article.gmane.org/gmane.linux.ide/46352
+	 * http://thread.gmane.org/gmane.linux.kernel/1062139
 	 */
-	if (pdev->device == 0x3249) {
+	if (board_id == vt6420 || board_id == vt6421) {
 		pci_read_config_byte(pdev, 0x52, &tmp8);
 		tmp8 |= 1 << 2;
 		pci_write_config_byte(pdev, 0x52, tmp8);
@@ -652,7 +653,7 @@
 	if (rc)
 		return rc;
 
-	svia_configure(pdev);
+	svia_configure(pdev, board_id);
 
 	pci_set_master(pdev);
 	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
diff -urN linux-2.6.37-rc2/drivers/base/power/main.c linux-2.6.37-rc3/drivers/base/power/main.c
--- linux-2.6.37-rc2/drivers/base/power/main.c	2010-11-21 23:40:10.862166175 +0000
+++ linux-2.6.37-rc3/drivers/base/power/main.c	2010-11-21 23:40:16.515100170 +0000
@@ -475,20 +475,33 @@
  */
 void dpm_resume_noirq(pm_message_t state)
 {
-	struct device *dev;
+	struct list_head list;
 	ktime_t starttime = ktime_get();
 
+	INIT_LIST_HEAD(&list);
 	mutex_lock(&dpm_list_mtx);
 	transition_started = false;
-	list_for_each_entry(dev, &dpm_list, power.entry)
+	while (!list_empty(&dpm_list)) {
+		struct device *dev = to_device(dpm_list.next);
+
+		get_device(dev);
 		if (dev->power.status > DPM_OFF) {
 			int error;
 
 			dev->power.status = DPM_OFF;
+			mutex_unlock(&dpm_list_mtx);
+
 			error = device_resume_noirq(dev, state);
+
+			mutex_lock(&dpm_list_mtx);
 			if (error)
 				pm_dev_err(dev, state, " early", error);
 		}
+		if (!list_empty(&dev->power.entry))
+			list_move_tail(&dev->power.entry, &list);
+		put_device(dev);
+	}
+	list_splice(&list, &dpm_list);
 	mutex_unlock(&dpm_list_mtx);
 	dpm_show_time(starttime, state, "early");
 	resume_device_irqs();
@@ -789,20 +802,33 @@
  */
 int dpm_suspend_noirq(pm_message_t state)
 {
-	struct device *dev;
+	struct list_head list;
 	ktime_t starttime = ktime_get();
 	int error = 0;
 
+	INIT_LIST_HEAD(&list);
 	suspend_device_irqs();
 	mutex_lock(&dpm_list_mtx);
-	list_for_each_entry_reverse(dev, &dpm_list, power.entry) {
+	while (!list_empty(&dpm_list)) {
+		struct device *dev = to_device(dpm_list.prev);
+
+		get_device(dev);
+		mutex_unlock(&dpm_list_mtx);
+
 		error = device_suspend_noirq(dev, state);
+
+		mutex_lock(&dpm_list_mtx);
 		if (error) {
 			pm_dev_err(dev, state, " late", error);
+			put_device(dev);
 			break;
 		}
 		dev->power.status = DPM_OFF_IRQ;
+		if (!list_empty(&dev->power.entry))
+			list_move(&dev->power.entry, &list);
+		put_device(dev);
 	}
+	list_splice_tail(&list, &dpm_list);
 	mutex_unlock(&dpm_list_mtx);
 	if (error)
 		dpm_resume_noirq(resume_event(state));
diff -urN linux-2.6.37-rc2/drivers/block/cciss_scsi.c linux-2.6.37-rc3/drivers/block/cciss_scsi.c
--- linux-2.6.37-rc2/drivers/block/cciss_scsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/block/cciss_scsi.c	2010-11-21 23:40:16.521079063 +0000
@@ -62,8 +62,8 @@
 		int length, 	   /* length of data in buffer */
 		int func);	   /* 0 == read, 1 == write */
 
-static int cciss_scsi_queue_command (struct scsi_cmnd *cmd,
-		void (* done)(struct scsi_cmnd *));
+static int cciss_scsi_queue_command (struct Scsi_Host *h,
+				     struct scsi_cmnd *cmd);
 static int cciss_eh_device_reset_handler(struct scsi_cmnd *);
 static int cciss_eh_abort_handler(struct scsi_cmnd *);
 
@@ -1406,7 +1406,7 @@
 
 
 static int
-cciss_scsi_queue_command (struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
+cciss_scsi_queue_command_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	ctlr_info_t *h;
 	int rc;
@@ -1504,6 +1504,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(cciss_scsi_queue_command)
+
 static void cciss_unregister_scsi(ctlr_info_t *h)
 {
 	struct cciss_scsi_adapter_data_t *sa;
diff -urN linux-2.6.37-rc2/drivers/block/drbd/drbd_receiver.c linux-2.6.37-rc3/drivers/block/drbd/drbd_receiver.c
--- linux-2.6.37-rc2/drivers/block/drbd/drbd_receiver.c	2010-11-21 23:40:10.883180779 +0000
+++ linux-2.6.37-rc3/drivers/block/drbd/drbd_receiver.c	2010-11-21 23:40:16.526056624 +0000
@@ -36,7 +36,6 @@
 #include <linux/memcontrol.h>
 #include <linux/mm_inline.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/pkt_sched.h>
 #define __KERNEL_SYSCALLS__
 #include <linux/unistd.h>
diff -urN linux-2.6.37-rc2/drivers/block/drbd/drbd_worker.c linux-2.6.37-rc3/drivers/block/drbd/drbd_worker.c
--- linux-2.6.37-rc2/drivers/block/drbd/drbd_worker.c	2010-11-21 23:40:10.885181301 +0000
+++ linux-2.6.37-rc3/drivers/block/drbd/drbd_worker.c	2010-11-21 23:40:16.527055962 +0000
@@ -26,7 +26,6 @@
 #include <linux/module.h>
 #include <linux/drbd.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <linux/wait.h>
 #include <linux/mm.h>
 #include <linux/memcontrol.h>
diff -urN linux-2.6.37-rc2/drivers/char/agp/frontend.c linux-2.6.37-rc3/drivers/char/agp/frontend.c
--- linux-2.6.37-rc2/drivers/char/agp/frontend.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/char/agp/frontend.c	2010-11-21 23:40:16.536056347 +0000
@@ -39,7 +39,6 @@
 #include <linux/mm.h>
 #include <linux/fs.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include "agp.h"
diff -urN linux-2.6.37-rc2/drivers/char/amiserial.c linux-2.6.37-rc3/drivers/char/amiserial.c
--- linux-2.6.37-rc2/drivers/char/amiserial.c	2010-11-21 23:40:10.907220630 +0000
+++ linux-2.6.37-rc3/drivers/char/amiserial.c	2010-11-21 23:40:16.538056565 +0000
@@ -81,7 +81,6 @@
 #include <linux/mm.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/bitops.h>
 #include <linux/platform_device.h>
diff -urN linux-2.6.37-rc2/drivers/char/briq_panel.c linux-2.6.37-rc3/drivers/char/briq_panel.c
--- linux-2.6.37-rc2/drivers/char/briq_panel.c	2010-11-21 23:40:10.908234475 +0000
+++ linux-2.6.37-rc3/drivers/char/briq_panel.c	2010-11-21 23:40:16.538056565 +0000
@@ -6,7 +6,6 @@
 
 #include <linux/module.h>
 
-#include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/tty.h>
diff -urN linux-2.6.37-rc2/drivers/char/hpet.c linux-2.6.37-rc3/drivers/char/hpet.c
--- linux-2.6.37-rc2/drivers/char/hpet.c	2010-11-21 23:40:10.914091894 +0000
+++ linux-2.6.37-rc3/drivers/char/hpet.c	2010-11-21 23:40:16.541100799 +0000
@@ -14,7 +14,6 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/miscdevice.h>
 #include <linux/major.h>
diff -urN linux-2.6.37-rc2/drivers/char/hw_random/core.c linux-2.6.37-rc3/drivers/char/hw_random/core.c
--- linux-2.6.37-rc2/drivers/char/hw_random/core.c	2010-11-21 23:40:10.916097174 +0000
+++ linux-2.6.37-rc3/drivers/char/hw_random/core.c	2010-11-21 23:40:16.542077719 +0000
@@ -37,7 +37,6 @@
 #include <linux/kernel.h>
 #include <linux/fs.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/miscdevice.h>
 #include <linux/delay.h>
diff -urN linux-2.6.37-rc2/drivers/char/istallion.c linux-2.6.37-rc3/drivers/char/istallion.c
--- linux-2.6.37-rc2/drivers/char/istallion.c	2010-11-21 23:40:10.921181281 +0000
+++ linux-2.6.37-rc3/drivers/char/istallion.c	2010-11-21 23:40:16.545055998 +0000
@@ -21,7 +21,6 @@
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
diff -urN linux-2.6.37-rc2/drivers/char/serial167.c linux-2.6.37-rc3/drivers/char/serial167.c
--- linux-2.6.37-rc2/drivers/char/serial167.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/char/serial167.c	2010-11-21 23:40:16.556074364 +0000
@@ -52,7 +52,6 @@
 #include <linux/interrupt.h>
 #include <linux/serial.h>
 #include <linux/serialP.h>
-#include <linux/smp_lock.h>
 #include <linux/string.h>
 #include <linux/fcntl.h>
 #include <linux/ptrace.h>
diff -urN linux-2.6.37-rc2/drivers/char/specialix.c linux-2.6.37-rc3/drivers/char/specialix.c
--- linux-2.6.37-rc2/drivers/char/specialix.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/char/specialix.c	2010-11-21 23:40:16.556074364 +0000
@@ -87,7 +87,6 @@
 #include <linux/tty_flip.h>
 #include <linux/mm.h>
 #include <linux/serial.h>
-#include <linux/smp_lock.h>
 #include <linux/fcntl.h>
 #include <linux/major.h>
 #include <linux/delay.h>
diff -urN linux-2.6.37-rc2/drivers/char/stallion.c linux-2.6.37-rc3/drivers/char/stallion.c
--- linux-2.6.37-rc2/drivers/char/stallion.c	2010-11-21 23:40:10.944225344 +0000
+++ linux-2.6.37-rc3/drivers/char/stallion.c	2010-11-21 23:40:16.557076498 +0000
@@ -40,7 +40,6 @@
 #include <linux/stallion.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/device.h>
 #include <linux/delay.h>
 #include <linux/ctype.h>
diff -urN linux-2.6.37-rc2/drivers/char/sx.c linux-2.6.37-rc3/drivers/char/sx.c
--- linux-2.6.37-rc2/drivers/char/sx.c	2010-11-21 23:40:10.945181208 +0000
+++ linux-2.6.37-rc3/drivers/char/sx.c	2010-11-21 23:40:16.557076498 +0000
@@ -216,7 +216,6 @@
 #include <linux/eisa.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/miscdevice.h>
 #include <linux/bitops.h>
diff -urN linux-2.6.37-rc2/drivers/char/uv_mmtimer.c linux-2.6.37-rc3/drivers/char/uv_mmtimer.c
--- linux-2.6.37-rc2/drivers/char/uv_mmtimer.c	2010-11-21 23:40:10.961091364 +0000
+++ linux-2.6.37-rc3/drivers/char/uv_mmtimer.c	2010-11-21 23:40:16.565056129 +0000
@@ -23,7 +23,6 @@
 #include <linux/interrupt.h>
 #include <linux/time.h>
 #include <linux/math64.h>
-#include <linux/smp_lock.h>
 
 #include <asm/genapic.h>
 #include <asm/uv/uv_hub.h>
diff -urN linux-2.6.37-rc2/drivers/firewire/sbp2.c linux-2.6.37-rc3/drivers/firewire/sbp2.c
--- linux-2.6.37-rc2/drivers/firewire/sbp2.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/firewire/sbp2.c	2010-11-21 23:40:16.583072670 +0000
@@ -1468,7 +1468,7 @@
 
 /* SCSI stack integration */
 
-static int sbp2_scsi_queuecommand(struct scsi_cmnd *cmd, scsi_done_fn_t done)
+static int sbp2_scsi_queuecommand_lck(struct scsi_cmnd *cmd, scsi_done_fn_t done)
 {
 	struct sbp2_logical_unit *lu = cmd->device->hostdata;
 	struct fw_device *device = target_device(lu->tgt);
@@ -1534,6 +1534,8 @@
 	return retval;
 }
 
+static DEF_SCSI_QCMD(sbp2_scsi_queuecommand)
+
 static int sbp2_scsi_slave_alloc(struct scsi_device *sdev)
 {
 	struct sbp2_logical_unit *lu = sdev->hostdata;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/drm_fops.c linux-2.6.37-rc3/drivers/gpu/drm/drm_fops.c
--- linux-2.6.37-rc2/drivers/gpu/drm/drm_fops.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/drm_fops.c	2010-11-21 23:40:16.587078683 +0000
@@ -37,7 +37,6 @@
 #include "drmP.h"
 #include <linux/poll.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 
 /* from BKL pushdown: note that nothing else serializes idr_find() */
 DEFINE_MUTEX(drm_global_mutex);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/i915/i915_drv.c linux-2.6.37-rc3/drivers/gpu/drm/i915/i915_drv.c
--- linux-2.6.37-rc2/drivers/gpu/drm/i915/i915_drv.c	2010-11-21 23:40:11.013170405 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/i915/i915_drv.c	2010-11-21 23:40:16.590056479 +0000
@@ -150,7 +150,8 @@
 
 static const struct intel_device_info intel_ironlake_m_info = {
 	.gen = 5, .is_mobile = 1,
-	.need_gfx_hws = 1, .has_fbc = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.need_gfx_hws = 1, .has_rc6 = 1, .has_hotplug = 1,
+	.has_fbc = 0, /* disabled due to buggy hardware */
 	.has_bsd_ring = 1,
 };
 
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/i915/i915_drv.h linux-2.6.37-rc3/drivers/gpu/drm/i915/i915_drv.h
--- linux-2.6.37-rc2/drivers/gpu/drm/i915/i915_drv.h	2010-11-21 23:40:11.014103700 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/i915/i915_drv.h	2010-11-21 23:40:16.591078326 +0000
@@ -1045,6 +1045,8 @@
 int i915_gem_object_set_domain(struct drm_gem_object *obj,
 			       uint32_t read_domains,
 			       uint32_t write_domain);
+int i915_gem_object_flush_gpu(struct drm_i915_gem_object *obj,
+			      bool interruptible);
 int i915_gem_init_ringbuffer(struct drm_device *dev);
 void i915_gem_cleanup_ringbuffer(struct drm_device *dev);
 int i915_gem_do_init(struct drm_device *dev, unsigned long start,
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/i915/i915_gem.c linux-2.6.37-rc3/drivers/gpu/drm/i915/i915_gem.c
--- linux-2.6.37-rc2/drivers/gpu/drm/i915/i915_gem.c	2010-11-21 23:40:11.017168474 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/i915/i915_gem.c	2010-11-21 23:40:16.593069280 +0000
@@ -547,6 +547,19 @@
 	struct drm_i915_gem_object *obj_priv;
 	int ret = 0;
 
+	if (args->size == 0)
+		return 0;
+
+	if (!access_ok(VERIFY_WRITE,
+		       (char __user *)(uintptr_t)args->data_ptr,
+		       args->size))
+		return -EFAULT;
+
+	ret = fault_in_pages_writeable((char __user *)(uintptr_t)args->data_ptr,
+				       args->size);
+	if (ret)
+		return -EFAULT;
+
 	ret = i915_mutex_lock_interruptible(dev);
 	if (ret)
 		return ret;
@@ -564,23 +577,6 @@
 		goto out;
 	}
 
-	if (args->size == 0)
-		goto out;
-
-	if (!access_ok(VERIFY_WRITE,
-		       (char __user *)(uintptr_t)args->data_ptr,
-		       args->size)) {
-		ret = -EFAULT;
-		goto out;
-	}
-
-	ret = fault_in_pages_writeable((char __user *)(uintptr_t)args->data_ptr,
-				       args->size);
-	if (ret) {
-		ret = -EFAULT;
-		goto out;
-	}
-
 	ret = i915_gem_object_get_pages_or_evict(obj);
 	if (ret)
 		goto out;
@@ -981,7 +977,20 @@
 	struct drm_i915_gem_pwrite *args = data;
 	struct drm_gem_object *obj;
 	struct drm_i915_gem_object *obj_priv;
-	int ret = 0;
+	int ret;
+
+	if (args->size == 0)
+		return 0;
+
+	if (!access_ok(VERIFY_READ,
+		       (char __user *)(uintptr_t)args->data_ptr,
+		       args->size))
+		return -EFAULT;
+
+	ret = fault_in_pages_readable((char __user *)(uintptr_t)args->data_ptr,
+				      args->size);
+	if (ret)
+		return -EFAULT;
 
 	ret = i915_mutex_lock_interruptible(dev);
 	if (ret)
@@ -994,30 +1003,12 @@
 	}
 	obj_priv = to_intel_bo(obj);
 
-
 	/* Bounds check destination. */
 	if (args->offset > obj->size || args->size > obj->size - args->offset) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	if (args->size == 0)
-		goto out;
-
-	if (!access_ok(VERIFY_READ,
-		       (char __user *)(uintptr_t)args->data_ptr,
-		       args->size)) {
-		ret = -EFAULT;
-		goto out;
-	}
-
-	ret = fault_in_pages_readable((char __user *)(uintptr_t)args->data_ptr,
-				      args->size);
-	if (ret) {
-		ret = -EFAULT;
-		goto out;
-	}
-
 	/* We can only do the GTT pwrite on untiled buffers, as otherwise
 	 * it would end up going through the fenced access, and we'll get
 	 * different detiling behavior between reading and writing.
@@ -2907,6 +2898,20 @@
 	return 0;
 }
 
+int
+i915_gem_object_flush_gpu(struct drm_i915_gem_object *obj,
+			  bool interruptible)
+{
+	if (!obj->active)
+		return 0;
+
+	if (obj->base.write_domain & I915_GEM_GPU_DOMAINS)
+		i915_gem_flush_ring(obj->base.dev, NULL, obj->ring,
+				    0, obj->base.write_domain);
+
+	return i915_gem_object_wait_rendering(&obj->base, interruptible);
+}
+
 /**
  * Moves a single object to the CPU read, and possibly write domain.
  *
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/i915/intel_crt.c linux-2.6.37-rc3/drivers/gpu/drm/i915/intel_crt.c
--- linux-2.6.37-rc2/drivers/gpu/drm/i915/intel_crt.c	2010-11-21 23:40:11.020168720 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/i915/intel_crt.c	2010-11-21 23:40:16.596087880 +0000
@@ -34,6 +34,25 @@
 #include "i915_drm.h"
 #include "i915_drv.h"
 
+/* Here's the desired hotplug mode */
+#define ADPA_HOTPLUG_BITS (ADPA_CRT_HOTPLUG_PERIOD_128 |		\
+			   ADPA_CRT_HOTPLUG_WARMUP_10MS |		\
+			   ADPA_CRT_HOTPLUG_SAMPLE_4S |			\
+			   ADPA_CRT_HOTPLUG_VOLTAGE_50 |		\
+			   ADPA_CRT_HOTPLUG_VOLREF_325MV |		\
+			   ADPA_CRT_HOTPLUG_ENABLE)
+
+struct intel_crt {
+	struct intel_encoder base;
+	bool force_hotplug_required;
+};
+
+static struct intel_crt *intel_attached_crt(struct drm_connector *connector)
+{
+	return container_of(intel_attached_encoder(connector),
+			    struct intel_crt, base);
+}
+
 static void intel_crt_dpms(struct drm_encoder *encoder, int mode)
 {
 	struct drm_device *dev = encoder->dev;
@@ -129,7 +148,7 @@
 			   dpll_md & ~DPLL_MD_UDI_MULTIPLIER_MASK);
 	}
 
-	adpa = 0;
+	adpa = ADPA_HOTPLUG_BITS;
 	if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
 		adpa |= ADPA_HSYNC_ACTIVE_HIGH;
 	if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
@@ -157,53 +176,44 @@
 static bool intel_ironlake_crt_detect_hotplug(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
+	struct intel_crt *crt = intel_attached_crt(connector);
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	u32 adpa, temp;
+	u32 adpa;
 	bool ret;
-	bool turn_off_dac = false;
 
-	temp = adpa = I915_READ(PCH_ADPA);
+	/* The first time through, trigger an explicit detection cycle */
+	if (crt->force_hotplug_required) {
+		bool turn_off_dac = HAS_PCH_SPLIT(dev);
+		u32 save_adpa;
 
-	if (HAS_PCH_SPLIT(dev))
-		turn_off_dac = true;
+		crt->force_hotplug_required = 0;
+
+		save_adpa = adpa = I915_READ(PCH_ADPA);
+		DRM_DEBUG_KMS("trigger hotplug detect cycle: adpa=0x%x\n", adpa);
+
+		adpa |= ADPA_CRT_HOTPLUG_FORCE_TRIGGER;
+		if (turn_off_dac)
+			adpa &= ~ADPA_DAC_ENABLE;
 
-	adpa &= ~ADPA_CRT_HOTPLUG_MASK;
-	if (turn_off_dac)
-		adpa &= ~ADPA_DAC_ENABLE;
-
-	/* disable HPD first */
-	I915_WRITE(PCH_ADPA, adpa);
-	(void)I915_READ(PCH_ADPA);
-
-	adpa |= (ADPA_CRT_HOTPLUG_PERIOD_128 |
-			ADPA_CRT_HOTPLUG_WARMUP_10MS |
-			ADPA_CRT_HOTPLUG_SAMPLE_4S |
-			ADPA_CRT_HOTPLUG_VOLTAGE_50 | /* default */
-			ADPA_CRT_HOTPLUG_VOLREF_325MV |
-			ADPA_CRT_HOTPLUG_ENABLE |
-			ADPA_CRT_HOTPLUG_FORCE_TRIGGER);
-
-	DRM_DEBUG_KMS("pch crt adpa 0x%x", adpa);
-	I915_WRITE(PCH_ADPA, adpa);
-
-	if (wait_for((I915_READ(PCH_ADPA) & ADPA_CRT_HOTPLUG_FORCE_TRIGGER) == 0,
-		     1000))
-		DRM_DEBUG_KMS("timed out waiting for FORCE_TRIGGER");
-
-	if (turn_off_dac) {
-		/* Make sure hotplug is enabled */
-		I915_WRITE(PCH_ADPA, temp | ADPA_CRT_HOTPLUG_ENABLE);
-		(void)I915_READ(PCH_ADPA);
+		I915_WRITE(PCH_ADPA, adpa);
+
+		if (wait_for((I915_READ(PCH_ADPA) & ADPA_CRT_HOTPLUG_FORCE_TRIGGER) == 0,
+			     1000))
+			DRM_DEBUG_KMS("timed out waiting for FORCE_TRIGGER");
+
+		if (turn_off_dac) {
+			I915_WRITE(PCH_ADPA, save_adpa);
+			POSTING_READ(PCH_ADPA);
+		}
 	}
 
 	/* Check the status to see if both blue and green are on now */
 	adpa = I915_READ(PCH_ADPA);
-	adpa &= ADPA_CRT_HOTPLUG_MONITOR_MASK;
-	if ((adpa == ADPA_CRT_HOTPLUG_MONITOR_COLOR) ||
-		(adpa == ADPA_CRT_HOTPLUG_MONITOR_MONO))
+	if ((adpa & ADPA_CRT_HOTPLUG_MONITOR_MASK) != 0)
 		ret = true;
 	else
 		ret = false;
+	DRM_DEBUG_KMS("ironlake hotplug adpa=0x%x, result %d\n", adpa, ret);
 
 	return ret;
 }
@@ -277,13 +287,12 @@
 	return i2c_transfer(&dev_priv->gmbus[ddc_bus].adapter, msgs, 1) == 1;
 }
 
-static bool intel_crt_detect_ddc(struct drm_encoder *encoder)
+static bool intel_crt_detect_ddc(struct intel_crt *crt)
 {
-	struct intel_encoder *intel_encoder = to_intel_encoder(encoder);
-	struct drm_i915_private *dev_priv = encoder->dev->dev_private;
+	struct drm_i915_private *dev_priv = crt->base.base.dev->dev_private;
 
 	/* CRT should always be at 0, but check anyway */
-	if (intel_encoder->type != INTEL_OUTPUT_ANALOG)
+	if (crt->base.type != INTEL_OUTPUT_ANALOG)
 		return false;
 
 	if (intel_crt_ddc_probe(dev_priv, dev_priv->crt_ddc_pin)) {
@@ -291,7 +300,7 @@
 		return true;
 	}
 
-	if (intel_ddc_probe(intel_encoder, dev_priv->crt_ddc_pin)) {
+	if (intel_ddc_probe(&crt->base, dev_priv->crt_ddc_pin)) {
 		DRM_DEBUG_KMS("CRT detected via DDC:0x50 [EDID]\n");
 		return true;
 	}
@@ -300,9 +309,9 @@
 }
 
 static enum drm_connector_status
-intel_crt_load_detect(struct drm_crtc *crtc, struct intel_encoder *intel_encoder)
+intel_crt_load_detect(struct drm_crtc *crtc, struct intel_crt *crt)
 {
-	struct drm_encoder *encoder = &intel_encoder->base;
+	struct drm_encoder *encoder = &crt->base.base;
 	struct drm_device *dev = encoder->dev;
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
@@ -434,7 +443,7 @@
 intel_crt_detect(struct drm_connector *connector, bool force)
 {
 	struct drm_device *dev = connector->dev;
-	struct intel_encoder *encoder = intel_attached_encoder(connector);
+	struct intel_crt *crt = intel_attached_crt(connector);
 	struct drm_crtc *crtc;
 	int dpms_mode;
 	enum drm_connector_status status;
@@ -443,28 +452,31 @@
 		if (intel_crt_detect_hotplug(connector)) {
 			DRM_DEBUG_KMS("CRT detected via hotplug\n");
 			return connector_status_connected;
-		} else
+		} else {
+			DRM_DEBUG_KMS("CRT not detected via hotplug\n");
 			return connector_status_disconnected;
+		}
 	}
 
-	if (intel_crt_detect_ddc(&encoder->base))
+	if (intel_crt_detect_ddc(crt))
 		return connector_status_connected;
 
 	if (!force)
 		return connector->status;
 
 	/* for pre-945g platforms use load detect */
-	if (encoder->base.crtc && encoder->base.crtc->enabled) {
-		status = intel_crt_load_detect(encoder->base.crtc, encoder);
+	crtc = crt->base.base.crtc;
+	if (crtc && crtc->enabled) {
+		status = intel_crt_load_detect(crtc, crt);
 	} else {
-		crtc = intel_get_load_detect_pipe(encoder, connector,
+		crtc = intel_get_load_detect_pipe(&crt->base, connector,
 						  NULL, &dpms_mode);
 		if (crtc) {
-			if (intel_crt_detect_ddc(&encoder->base))
+			if (intel_crt_detect_ddc(crt))
 				status = connector_status_connected;
 			else
-				status = intel_crt_load_detect(crtc, encoder);
-			intel_release_load_detect_pipe(encoder,
+				status = intel_crt_load_detect(crtc, crt);
+			intel_release_load_detect_pipe(&crt->base,
 						       connector, dpms_mode);
 		} else
 			status = connector_status_unknown;
@@ -536,17 +548,17 @@
 void intel_crt_init(struct drm_device *dev)
 {
 	struct drm_connector *connector;
-	struct intel_encoder *intel_encoder;
+	struct intel_crt *crt;
 	struct intel_connector *intel_connector;
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
-	intel_encoder = kzalloc(sizeof(struct intel_encoder), GFP_KERNEL);
-	if (!intel_encoder)
+	crt = kzalloc(sizeof(struct intel_crt), GFP_KERNEL);
+	if (!crt)
 		return;
 
 	intel_connector = kzalloc(sizeof(struct intel_connector), GFP_KERNEL);
 	if (!intel_connector) {
-		kfree(intel_encoder);
+		kfree(crt);
 		return;
 	}
 
@@ -554,20 +566,20 @@
 	drm_connector_init(dev, &intel_connector->base,
 			   &intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);
 
-	drm_encoder_init(dev, &intel_encoder->base, &intel_crt_enc_funcs,
+	drm_encoder_init(dev, &crt->base.base, &intel_crt_enc_funcs,
 			 DRM_MODE_ENCODER_DAC);
 
-	intel_connector_attach_encoder(intel_connector, intel_encoder);
+	intel_connector_attach_encoder(intel_connector, &crt->base);
 
-	intel_encoder->type = INTEL_OUTPUT_ANALOG;
-	intel_encoder->clone_mask = (1 << INTEL_SDVO_NON_TV_CLONE_BIT) |
-				   (1 << INTEL_ANALOG_CLONE_BIT) |
-				   (1 << INTEL_SDVO_LVDS_CLONE_BIT);
-	intel_encoder->crtc_mask = (1 << 0) | (1 << 1);
+	crt->base.type = INTEL_OUTPUT_ANALOG;
+	crt->base.clone_mask = (1 << INTEL_SDVO_NON_TV_CLONE_BIT |
+				1 << INTEL_ANALOG_CLONE_BIT |
+				1 << INTEL_SDVO_LVDS_CLONE_BIT);
+	crt->base.crtc_mask = (1 << 0) | (1 << 1);
 	connector->interlace_allowed = 1;
 	connector->doublescan_allowed = 0;
 
-	drm_encoder_helper_add(&intel_encoder->base, &intel_crt_helper_funcs);
+	drm_encoder_helper_add(&crt->base.base, &intel_crt_helper_funcs);
 	drm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);
 
 	drm_sysfs_connector_add(connector);
@@ -577,5 +589,22 @@
 	else
 		connector->polled = DRM_CONNECTOR_POLL_CONNECT;
 
+	/*
+	 * Configure the automatic hotplug detection stuff
+	 */
+	crt->force_hotplug_required = 0;
+	if (HAS_PCH_SPLIT(dev)) {
+		u32 adpa;
+
+		adpa = I915_READ(PCH_ADPA);
+		adpa &= ~ADPA_CRT_HOTPLUG_MASK;
+		adpa |= ADPA_HOTPLUG_BITS;
+		I915_WRITE(PCH_ADPA, adpa);
+		POSTING_READ(PCH_ADPA);
+
+		DRM_DEBUG_KMS("pch crt adpa set to 0x%x\n", adpa);
+		crt->force_hotplug_required = 1;
+	}
+
 	dev_priv->hotplug_supported_mask |= CRT_HOTPLUG_INT_STATUS;
 }
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/i915/intel_display.c linux-2.6.37-rc3/drivers/gpu/drm/i915/intel_display.c
--- linux-2.6.37-rc2/drivers/gpu/drm/i915/intel_display.c	2010-11-21 23:40:11.023178603 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/i915/intel_display.c	2010-11-21 23:40:16.599053837 +0000
@@ -1611,6 +1611,18 @@
 
 		wait_event(dev_priv->pending_flip_queue,
 			   atomic_read(&obj_priv->pending_flip) == 0);
+
+		/* Big Hammer, we also need to ensure that any pending
+		 * MI_WAIT_FOR_EVENT inside a user batch buffer on the
+		 * current scanout is retired before unpinning the old
+		 * framebuffer.
+		 */
+		ret = i915_gem_object_flush_gpu(obj_priv, false);
+		if (ret) {
+			i915_gem_object_unpin(to_intel_framebuffer(crtc->fb)->obj);
+			mutex_unlock(&dev->struct_mutex);
+			return ret;
+		}
 	}
 
 	ret = intel_pipe_set_base_atomic(crtc, crtc->fb, x, y,
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/i915/intel_i2c.c linux-2.6.37-rc3/drivers/gpu/drm/i915/intel_i2c.c
--- linux-2.6.37-rc2/drivers/gpu/drm/i915/intel_i2c.c	2010-11-21 23:40:11.025178930 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/i915/intel_i2c.c	2010-11-21 23:40:16.601056285 +0000
@@ -160,7 +160,7 @@
 	};
 	struct intel_gpio *gpio;
 
-	if (pin < 1 || pin > 7)
+	if (pin >= ARRAY_SIZE(map_pin_to_reg) || !map_pin_to_reg[pin])
 		return NULL;
 
 	gpio = kzalloc(sizeof(struct intel_gpio), GFP_KERNEL);
@@ -172,7 +172,8 @@
 		gpio->reg += PCH_GPIOA - GPIOA;
 	gpio->dev_priv = dev_priv;
 
-	snprintf(gpio->adapter.name, I2C_NAME_SIZE, "GPIO%c", "?BACDEF?"[pin]);
+	snprintf(gpio->adapter.name, sizeof(gpio->adapter.name),
+		 "i915 GPIO%c", "?BACDE?F"[pin]);
 	gpio->adapter.owner = THIS_MODULE;
 	gpio->adapter.algo_data	= &gpio->algo;
 	gpio->adapter.dev.parent = &dev_priv->dev->pdev->dev;
@@ -349,7 +350,7 @@
 		"panel",
 		"dpc",
 		"dpb",
-		"reserved"
+		"reserved",
 		"dpd",
 	};
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -366,8 +367,8 @@
 		bus->adapter.owner = THIS_MODULE;
 		bus->adapter.class = I2C_CLASS_DDC;
 		snprintf(bus->adapter.name,
-			 I2C_NAME_SIZE,
-			 "gmbus %s",
+			 sizeof(bus->adapter.name),
+			 "i915 gmbus %s",
 			 names[i]);
 
 		bus->adapter.dev.parent = &dev->pdev->dev;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_backlight.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_backlight.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_backlight.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_backlight.c	2010-11-21 23:40:16.605073532 +0000
@@ -31,6 +31,7 @@
  */
 
 #include <linux/backlight.h>
+#include <linux/acpi.h>
 
 #include "drmP.h"
 #include "nouveau_drv.h"
@@ -136,6 +137,14 @@
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 
+#ifdef CONFIG_ACPI
+	if (acpi_video_backlight_support()) {
+		NV_INFO(dev, "ACPI backlight interface available, "
+			     "not registering our own\n");
+		return 0;
+	}
+#endif
+
 	switch (dev_priv->card_type) {
 	case NV_40:
 		return nouveau_nv40_backlight_init(dev);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_bios.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_bios.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_bios.c	2010-11-21 23:40:11.031179721 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_bios.c	2010-11-21 23:40:16.606070164 +0000
@@ -6829,7 +6829,7 @@
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	unsigned htotal;
 
-	if (dev_priv->chipset >= NV_50) {
+	if (dev_priv->card_type >= NV_50) {
 		if (NVReadVgaCrtc(dev, 0, 0x00) == 0 &&
 		    NVReadVgaCrtc(dev, 0, 0x1a) == 0)
 			return false;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_bo.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_bo.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_bo.c	2010-11-21 23:40:11.031179721 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_bo.c	2010-11-21 23:40:16.607074769 +0000
@@ -143,8 +143,10 @@
 	nvbo->no_vm = no_vm;
 	nvbo->tile_mode = tile_mode;
 	nvbo->tile_flags = tile_flags;
+	nvbo->bo.bdev = &dev_priv->ttm.bdev;
 
-	nouveau_bo_fixup_align(dev, tile_mode, tile_flags, &align, &size);
+	nouveau_bo_fixup_align(dev, tile_mode, nouveau_bo_tile_layout(nvbo),
+			       &align, &size);
 	align >>= PAGE_SHIFT;
 
 	nouveau_bo_placement_set(nvbo, flags, 0);
@@ -176,6 +178,31 @@
 		pl[(*n)++] = TTM_PL_FLAG_SYSTEM | flags;
 }
 
+static void
+set_placement_range(struct nouveau_bo *nvbo, uint32_t type)
+{
+	struct drm_nouveau_private *dev_priv = nouveau_bdev(nvbo->bo.bdev);
+
+	if (dev_priv->card_type == NV_10 &&
+	    nvbo->tile_mode && (type & TTM_PL_FLAG_VRAM)) {
+		/*
+		 * Make sure that the color and depth buffers are handled
+		 * by independent memory controller units. Up to a 9x
+		 * speed up when alpha-blending and depth-test are enabled
+		 * at the same time.
+		 */
+		int vram_pages = dev_priv->vram_size >> PAGE_SHIFT;
+
+		if (nvbo->tile_flags & NOUVEAU_GEM_TILE_ZETA) {
+			nvbo->placement.fpfn = vram_pages / 2;
+			nvbo->placement.lpfn = ~0;
+		} else {
+			nvbo->placement.fpfn = 0;
+			nvbo->placement.lpfn = vram_pages / 2;
+		}
+	}
+}
+
 void
 nouveau_bo_placement_set(struct nouveau_bo *nvbo, uint32_t type, uint32_t busy)
 {
@@ -190,6 +217,8 @@
 	pl->busy_placement = nvbo->busy_placements;
 	set_placement_list(nvbo->busy_placements, &pl->num_busy_placement,
 			   type | busy, flags);
+
+	set_placement_range(nvbo, type);
 }
 
 int
@@ -525,7 +554,8 @@
 		stride  = 16 * 4;
 		height  = amount / stride;
 
-		if (new_mem->mem_type == TTM_PL_VRAM && nvbo->tile_flags) {
+		if (new_mem->mem_type == TTM_PL_VRAM &&
+		    nouveau_bo_tile_layout(nvbo)) {
 			ret = RING_SPACE(chan, 8);
 			if (ret)
 				return ret;
@@ -546,7 +576,8 @@
 			BEGIN_RING(chan, NvSubM2MF, 0x0200, 1);
 			OUT_RING  (chan, 1);
 		}
-		if (old_mem->mem_type == TTM_PL_VRAM && nvbo->tile_flags) {
+		if (old_mem->mem_type == TTM_PL_VRAM &&
+		    nouveau_bo_tile_layout(nvbo)) {
 			ret = RING_SPACE(chan, 8);
 			if (ret)
 				return ret;
@@ -753,7 +784,8 @@
 	if (dev_priv->card_type == NV_50) {
 		ret = nv50_mem_vm_bind_linear(dev,
 					      offset + dev_priv->vm_vram_base,
-					      new_mem->size, nvbo->tile_flags,
+					      new_mem->size,
+					      nouveau_bo_tile_layout(nvbo),
 					      offset);
 		if (ret)
 			return ret;
@@ -894,7 +926,8 @@
 	 * nothing to do here.
 	 */
 	if (bo->mem.mem_type != TTM_PL_VRAM) {
-		if (dev_priv->card_type < NV_50 || !nvbo->tile_flags)
+		if (dev_priv->card_type < NV_50 ||
+		    !nouveau_bo_tile_layout(nvbo))
 			return 0;
 	}
 
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_connector.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_connector.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_connector.c	2010-11-21 23:40:11.032179166 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_connector.c	2010-11-21 23:40:16.607074769 +0000
@@ -281,7 +281,7 @@
 	nv_encoder = find_encoder_by_type(connector, OUTPUT_ANALOG);
 	if (!nv_encoder && !nouveau_tv_disable)
 		nv_encoder = find_encoder_by_type(connector, OUTPUT_TV);
-	if (nv_encoder) {
+	if (nv_encoder && force) {
 		struct drm_encoder *encoder = to_drm_encoder(nv_encoder);
 		struct drm_encoder_helper_funcs *helper =
 						encoder->helper_private;
@@ -641,11 +641,28 @@
 	return ret;
 }
 
+static unsigned
+get_tmds_link_bandwidth(struct drm_connector *connector)
+{
+	struct nouveau_connector *nv_connector = nouveau_connector(connector);
+	struct drm_nouveau_private *dev_priv = connector->dev->dev_private;
+	struct dcb_entry *dcb = nv_connector->detected_encoder->dcb;
+
+	if (dcb->location != DCB_LOC_ON_CHIP ||
+	    dev_priv->chipset >= 0x46)
+		return 165000;
+	else if (dev_priv->chipset >= 0x40)
+		return 155000;
+	else if (dev_priv->chipset >= 0x18)
+		return 135000;
+	else
+		return 112000;
+}
+
 static int
 nouveau_connector_mode_valid(struct drm_connector *connector,
 			     struct drm_display_mode *mode)
 {
-	struct drm_nouveau_private *dev_priv = connector->dev->dev_private;
 	struct nouveau_connector *nv_connector = nouveau_connector(connector);
 	struct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;
 	struct drm_encoder *encoder = to_drm_encoder(nv_encoder);
@@ -663,11 +680,9 @@
 		max_clock = 400000;
 		break;
 	case OUTPUT_TMDS:
-		if ((dev_priv->card_type >= NV_50 && !nouveau_duallink) ||
-		    !nv_encoder->dcb->duallink_possible)
-			max_clock = 165000;
-		else
-			max_clock = 330000;
+		max_clock = get_tmds_link_bandwidth(connector);
+		if (nouveau_duallink && nv_encoder->dcb->duallink_possible)
+			max_clock *= 2;
 		break;
 	case OUTPUT_ANALOG:
 		max_clock = nv_encoder->dcb->crtconf.maxfreq;
@@ -709,44 +724,6 @@
 	return NULL;
 }
 
-void
-nouveau_connector_set_polling(struct drm_connector *connector)
-{
-	struct drm_device *dev = connector->dev;
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct drm_crtc *crtc;
-	bool spare_crtc = false;
-
-	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
-		spare_crtc |= !crtc->enabled;
-
-	connector->polled = 0;
-
-	switch (connector->connector_type) {
-	case DRM_MODE_CONNECTOR_VGA:
-	case DRM_MODE_CONNECTOR_TV:
-		if (dev_priv->card_type >= NV_50 ||
-		    (nv_gf4_disp_arch(dev) && spare_crtc))
-			connector->polled = DRM_CONNECTOR_POLL_CONNECT;
-		break;
-
-	case DRM_MODE_CONNECTOR_DVII:
-	case DRM_MODE_CONNECTOR_DVID:
-	case DRM_MODE_CONNECTOR_HDMIA:
-	case DRM_MODE_CONNECTOR_DisplayPort:
-	case DRM_MODE_CONNECTOR_eDP:
-		if (dev_priv->card_type >= NV_50)
-			connector->polled = DRM_CONNECTOR_POLL_HPD;
-		else if (connector->connector_type == DRM_MODE_CONNECTOR_DVID ||
-			 spare_crtc)
-			connector->polled = DRM_CONNECTOR_POLL_CONNECT;
-		break;
-
-	default:
-		break;
-	}
-}
-
 static const struct drm_connector_helper_funcs
 nouveau_connector_helper_funcs = {
 	.get_modes = nouveau_connector_get_modes,
@@ -872,6 +849,7 @@
 					dev->mode_config.scaling_mode_property,
 					nv_connector->scaling_mode);
 		}
+		connector->polled = DRM_CONNECTOR_POLL_CONNECT;
 		/* fall-through */
 	case DCB_CONNECTOR_TV_0:
 	case DCB_CONNECTOR_TV_1:
@@ -888,11 +866,16 @@
 				dev->mode_config.dithering_mode_property,
 				nv_connector->use_dithering ?
 				DRM_MODE_DITHERING_ON : DRM_MODE_DITHERING_OFF);
+
+		if (dcb->type != DCB_CONNECTOR_LVDS) {
+			if (dev_priv->card_type >= NV_50)
+				connector->polled = DRM_CONNECTOR_POLL_HPD;
+			else
+				connector->polled = DRM_CONNECTOR_POLL_CONNECT;
+		}
 		break;
 	}
 
-	nouveau_connector_set_polling(connector);
-
 	drm_sysfs_connector_add(connector);
 	dcb->drm = connector;
 	return dcb->drm;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_connector.h linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_connector.h
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_connector.h	2010-11-21 23:40:11.032179166 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_connector.h	2010-11-21 23:40:16.607074769 +0000
@@ -52,9 +52,6 @@
 struct drm_connector *
 nouveau_connector_create(struct drm_device *, int index);
 
-void
-nouveau_connector_set_polling(struct drm_connector *);
-
 int
 nouveau_connector_bpp(struct drm_connector *);
 
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_drv.h linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_drv.h
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_drv.h	2010-11-21 23:40:11.033179514 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_drv.h	2010-11-21 23:40:16.608073090 +0000
@@ -100,6 +100,9 @@
 	int pin_refcnt;
 };
 
+#define nouveau_bo_tile_layout(nvbo)				\
+	((nvbo)->tile_flags & NOUVEAU_GEM_TILE_LAYOUT_MASK)
+
 static inline struct nouveau_bo *
 nouveau_bo(struct ttm_buffer_object *bo)
 {
@@ -304,6 +307,7 @@
 	void (*destroy_context)(struct nouveau_channel *);
 	int  (*load_context)(struct nouveau_channel *);
 	int  (*unload_context)(struct drm_device *);
+	void (*tlb_flush)(struct drm_device *dev);
 };
 
 struct nouveau_pgraph_object_method {
@@ -336,6 +340,7 @@
 	void (*destroy_context)(struct nouveau_channel *);
 	int  (*load_context)(struct nouveau_channel *);
 	int  (*unload_context)(struct drm_device *);
+	void (*tlb_flush)(struct drm_device *dev);
 
 	void (*set_region_tiling)(struct drm_device *dev, int i, uint32_t addr,
 				  uint32_t size, uint32_t pitch);
@@ -485,13 +490,13 @@
 };
 
 struct nv04_crtc_reg {
-	unsigned char MiscOutReg;     /* */
+	unsigned char MiscOutReg;
 	uint8_t CRTC[0xa0];
 	uint8_t CR58[0x10];
 	uint8_t Sequencer[5];
 	uint8_t Graphics[9];
 	uint8_t Attribute[21];
-	unsigned char DAC[768];       /* Internal Colorlookuptable */
+	unsigned char DAC[768];
 
 	/* PCRTC regs */
 	uint32_t fb_start;
@@ -539,43 +544,9 @@
 };
 
 struct nv04_mode_state {
-	uint32_t bpp;
-	uint32_t width;
-	uint32_t height;
-	uint32_t interlace;
-	uint32_t repaint0;
-	uint32_t repaint1;
-	uint32_t screen;
-	uint32_t scale;
-	uint32_t dither;
-	uint32_t extra;
-	uint32_t fifo;
-	uint32_t pixel;
-	uint32_t horiz;
-	int arbitration0;
-	int arbitration1;
-	uint32_t pll;
-	uint32_t pllB;
-	uint32_t vpll;
-	uint32_t vpll2;
-	uint32_t vpllB;
-	uint32_t vpll2B;
+	struct nv04_crtc_reg crtc_reg[2];
 	uint32_t pllsel;
 	uint32_t sel_clk;
-	uint32_t general;
-	uint32_t crtcOwner;
-	uint32_t head;
-	uint32_t head2;
-	uint32_t cursorConfig;
-	uint32_t cursor0;
-	uint32_t cursor1;
-	uint32_t cursor2;
-	uint32_t timingH;
-	uint32_t timingV;
-	uint32_t displayV;
-	uint32_t crtcSync;
-
-	struct nv04_crtc_reg crtc_reg[2];
 };
 
 enum nouveau_card_type {
@@ -613,6 +584,12 @@
 	struct work_struct irq_work;
 	struct work_struct hpd_work;
 
+	struct {
+		spinlock_t lock;
+		uint32_t hpd0_bits;
+		uint32_t hpd1_bits;
+	} hpd_state;
+
 	struct list_head vbl_waiting;
 
 	struct {
@@ -1045,6 +1022,7 @@
 extern void nv50_fifo_destroy_context(struct nouveau_channel *);
 extern int  nv50_fifo_load_context(struct nouveau_channel *);
 extern int  nv50_fifo_unload_context(struct drm_device *);
+extern void nv50_fifo_tlb_flush(struct drm_device *dev);
 
 /* nvc0_fifo.c */
 extern int  nvc0_fifo_init(struct drm_device *);
@@ -1122,6 +1100,8 @@
 extern int  nv50_graph_unload_context(struct drm_device *);
 extern void nv50_graph_context_switch(struct drm_device *);
 extern int  nv50_grctx_init(struct nouveau_grctx *);
+extern void nv50_graph_tlb_flush(struct drm_device *dev);
+extern void nv86_graph_tlb_flush(struct drm_device *dev);
 
 /* nvc0_graph.c */
 extern int  nvc0_graph_init(struct drm_device *);
@@ -1239,7 +1219,6 @@
 extern void nouveau_bo_wr16(struct nouveau_bo *nvbo, unsigned index, u16 val);
 extern u32 nouveau_bo_rd32(struct nouveau_bo *nvbo, unsigned index);
 extern void nouveau_bo_wr32(struct nouveau_bo *nvbo, unsigned index, u32 val);
-extern int nouveau_bo_sync_gpu(struct nouveau_bo *, struct nouveau_channel *);
 
 /* nouveau_fence.c */
 struct nouveau_fence;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_fence.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_fence.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_fence.c	2010-11-21 23:40:11.033179514 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_fence.c	2010-11-21 23:40:16.609057528 +0000
@@ -249,6 +249,7 @@
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_semaphore *sema;
+	int ret;
 
 	if (!USE_SEMA(dev))
 		return NULL;
@@ -257,10 +258,14 @@
 	if (!sema)
 		goto fail;
 
+	ret = drm_mm_pre_get(&dev_priv->fence.heap);
+	if (ret)
+		goto fail;
+
 	spin_lock(&dev_priv->fence.lock);
 	sema->mem = drm_mm_search_free(&dev_priv->fence.heap, 4, 0, 0);
 	if (sema->mem)
-		sema->mem = drm_mm_get_block(sema->mem, 4, 0);
+		sema->mem = drm_mm_get_block_atomic(sema->mem, 4, 0);
 	spin_unlock(&dev_priv->fence.lock);
 
 	if (!sema->mem)
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_gem.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_gem.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_gem.c	2010-11-21 23:40:11.033179514 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_gem.c	2010-11-21 23:40:16.609057528 +0000
@@ -107,23 +107,29 @@
 }
 
 static bool
-nouveau_gem_tile_flags_valid(struct drm_device *dev, uint32_t tile_flags) {
-	switch (tile_flags) {
-	case 0x0000:
-	case 0x1800:
-	case 0x2800:
-	case 0x4800:
-	case 0x7000:
-	case 0x7400:
-	case 0x7a00:
-	case 0xe000:
-		break;
-	default:
-		NV_ERROR(dev, "bad page flags: 0x%08x\n", tile_flags);
-		return false;
+nouveau_gem_tile_flags_valid(struct drm_device *dev, uint32_t tile_flags)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	if (dev_priv->card_type >= NV_50) {
+		switch (tile_flags & NOUVEAU_GEM_TILE_LAYOUT_MASK) {
+		case 0x0000:
+		case 0x1800:
+		case 0x2800:
+		case 0x4800:
+		case 0x7000:
+		case 0x7400:
+		case 0x7a00:
+		case 0xe000:
+			return true;
+		}
+	} else {
+		if (!(tile_flags & NOUVEAU_GEM_TILE_LAYOUT_MASK))
+			return true;
 	}
 
-	return true;
+	NV_ERROR(dev, "bad page flags: 0x%08x\n", tile_flags);
+	return false;
 }
 
 int
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_hw.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_hw.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_hw.c	2010-11-21 23:40:11.034070082 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_hw.c	2010-11-21 23:40:16.609057528 +0000
@@ -519,11 +519,11 @@
 
 	struct pll_lims pll_lim;
 	struct nouveau_pll_vals pv;
-	uint32_t pllreg = head ? NV_RAMDAC_VPLL2 : NV_PRAMDAC_VPLL_COEFF;
+	enum pll_types pll = head ? PLL_VPLL1 : PLL_VPLL0;
 
-	if (get_pll_limits(dev, pllreg, &pll_lim))
+	if (get_pll_limits(dev, pll, &pll_lim))
 		return;
-	nouveau_hw_get_pllvals(dev, pllreg, &pv);
+	nouveau_hw_get_pllvals(dev, pll, &pv);
 
 	if (pv.M1 >= pll_lim.vco1.min_m && pv.M1 <= pll_lim.vco1.max_m &&
 	    pv.N1 >= pll_lim.vco1.min_n && pv.N1 <= pll_lim.vco1.max_n &&
@@ -536,7 +536,7 @@
 	pv.M1 = pll_lim.vco1.max_m;
 	pv.N1 = pll_lim.vco1.min_n;
 	pv.log2P = pll_lim.max_usable_log2p;
-	nouveau_hw_setpll(dev, pllreg, &pv);
+	nouveau_hw_setpll(dev, pll_lim.reg, &pv);
 }
 
 /*
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_hw.h linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_hw.h
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_hw.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_hw.h	2010-11-21 23:40:16.609057528 +0000
@@ -416,6 +416,25 @@
 }
 
 static inline void
+nv_set_crtc_base(struct drm_device *dev, int head, uint32_t offset)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	NVWriteCRTC(dev, head, NV_PCRTC_START, offset);
+
+	if (dev_priv->card_type == NV_04) {
+		/*
+		 * Hilarious, the 24th bit doesn't want to stick to
+		 * PCRTC_START...
+		 */
+		int cre_heb = NVReadVgaCrtc(dev, head, NV_CIO_CRE_HEB__INDEX);
+
+		NVWriteVgaCrtc(dev, head, NV_CIO_CRE_HEB__INDEX,
+			       (cre_heb & ~0x40) | ((offset >> 18) & 0x40));
+	}
+}
+
+static inline void
 nv_show_cursor(struct drm_device *dev, int head, bool show)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_i2c.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_i2c.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_i2c.c	2010-11-21 23:40:11.034070082 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_i2c.c	2010-11-21 23:40:16.609057528 +0000
@@ -256,7 +256,7 @@
 	if (index >= DCB_MAX_NUM_I2C_ENTRIES)
 		return NULL;
 
-	if (dev_priv->chipset >= NV_50 && (i2c->entry & 0x00000100)) {
+	if (dev_priv->card_type >= NV_50 && (i2c->entry & 0x00000100)) {
 		uint32_t reg = 0xe500, val;
 
 		if (i2c->port_type == 6) {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_irq.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_irq.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_irq.c	2010-11-21 23:40:11.034070082 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_irq.c	2010-11-21 23:40:16.610073165 +0000
@@ -42,6 +42,13 @@
 #include "nouveau_connector.h"
 #include "nv50_display.h"
 
+static DEFINE_RATELIMIT_STATE(nouveau_ratelimit_state, 3 * HZ, 20);
+
+static int nouveau_ratelimit(void)
+{
+	return __ratelimit(&nouveau_ratelimit_state);
+}
+
 void
 nouveau_irq_preinstall(struct drm_device *dev)
 {
@@ -53,6 +60,7 @@
 	if (dev_priv->card_type >= NV_50) {
 		INIT_WORK(&dev_priv->irq_work, nv50_display_irq_handler_bh);
 		INIT_WORK(&dev_priv->hpd_work, nv50_display_irq_hotplug_bh);
+		spin_lock_init(&dev_priv->hpd_state.lock);
 		INIT_LIST_HEAD(&dev_priv->vbl_waiting);
 	}
 }
@@ -202,8 +210,8 @@
 		}
 
 		if (status & NV_PFIFO_INTR_DMA_PUSHER) {
-			u32 get = nv_rd32(dev, 0x003244);
-			u32 put = nv_rd32(dev, 0x003240);
+			u32 dma_get = nv_rd32(dev, 0x003244);
+			u32 dma_put = nv_rd32(dev, 0x003240);
 			u32 push = nv_rd32(dev, 0x003220);
 			u32 state = nv_rd32(dev, 0x003228);
 
@@ -213,16 +221,18 @@
 				u32 ib_get = nv_rd32(dev, 0x003334);
 				u32 ib_put = nv_rd32(dev, 0x003330);
 
-				NV_INFO(dev, "PFIFO_DMA_PUSHER - Ch %d Get 0x%02x%08x "
+				if (nouveau_ratelimit())
+					NV_INFO(dev, "PFIFO_DMA_PUSHER - Ch %d Get 0x%02x%08x "
 					     "Put 0x%02x%08x IbGet 0x%08x IbPut 0x%08x "
 					     "State 0x%08x Push 0x%08x\n",
-					chid, ho_get, get, ho_put, put, ib_get, ib_put,
-					state, push);
+						chid, ho_get, dma_get, ho_put,
+						dma_put, ib_get, ib_put, state,
+						push);
 
 				/* METHOD_COUNT, in DMA_STATE on earlier chipsets */
 				nv_wr32(dev, 0x003364, 0x00000000);
-				if (get != put || ho_get != ho_put) {
-					nv_wr32(dev, 0x003244, put);
+				if (dma_get != dma_put || ho_get != ho_put) {
+					nv_wr32(dev, 0x003244, dma_put);
 					nv_wr32(dev, 0x003328, ho_put);
 				} else
 				if (ib_get != ib_put) {
@@ -231,10 +241,10 @@
 			} else {
 				NV_INFO(dev, "PFIFO_DMA_PUSHER - Ch %d Get 0x%08x "
 					     "Put 0x%08x State 0x%08x Push 0x%08x\n",
-					chid, get, put, state, push);
+					chid, dma_get, dma_put, state, push);
 
-				if (get != put)
-					nv_wr32(dev, 0x003244, put);
+				if (dma_get != dma_put)
+					nv_wr32(dev, 0x003244, dma_put);
 			}
 
 			nv_wr32(dev, 0x003228, 0x00000000);
@@ -266,8 +276,9 @@
 		}
 
 		if (status) {
-			NV_INFO(dev, "PFIFO_INTR 0x%08x - Ch %d\n",
-				status, chid);
+			if (nouveau_ratelimit())
+				NV_INFO(dev, "PFIFO_INTR 0x%08x - Ch %d\n",
+					status, chid);
 			nv_wr32(dev, NV03_PFIFO_INTR_0, status);
 			status = 0;
 		}
@@ -544,13 +555,6 @@
 		nouveau_graph_dump_trap_info(dev, "PGRAPH_NOTIFY", &trap);
 }
 
-static DEFINE_RATELIMIT_STATE(nouveau_ratelimit_state, 3 * HZ, 20);
-
-static int nouveau_ratelimit(void)
-{
-	return __ratelimit(&nouveau_ratelimit_state);
-}
-
 
 static inline void
 nouveau_pgraph_intr_error(struct drm_device *dev, uint32_t nsource)
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_mem.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_mem.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_mem.c	2010-11-21 23:40:11.035093312 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_mem.c	2010-11-21 23:40:16.610073165 +0000
@@ -33,9 +33,9 @@
 #include "drmP.h"
 #include "drm.h"
 #include "drm_sarea.h"
-#include "nouveau_drv.h"
 
-#define MIN(a,b) a < b ? a : b
+#include "nouveau_drv.h"
+#include "nouveau_pm.h"
 
 /*
  * NV10-NV40 tiling helpers
@@ -175,11 +175,10 @@
 			}
 		}
 	}
-	dev_priv->engine.instmem.flush(dev);
 
-	nv50_vm_flush(dev, 5);
-	nv50_vm_flush(dev, 0);
-	nv50_vm_flush(dev, 4);
+	dev_priv->engine.instmem.flush(dev);
+	dev_priv->engine.fifo.tlb_flush(dev);
+	dev_priv->engine.graph.tlb_flush(dev);
 	nv50_vm_flush(dev, 6);
 	return 0;
 }
@@ -209,11 +208,10 @@
 			pte++;
 		}
 	}
-	dev_priv->engine.instmem.flush(dev);
 
-	nv50_vm_flush(dev, 5);
-	nv50_vm_flush(dev, 0);
-	nv50_vm_flush(dev, 4);
+	dev_priv->engine.instmem.flush(dev);
+	dev_priv->engine.fifo.tlb_flush(dev);
+	dev_priv->engine.graph.tlb_flush(dev);
 	nv50_vm_flush(dev, 6);
 }
 
@@ -653,6 +651,7 @@
 void
 nouveau_mem_timing_init(struct drm_device *dev)
 {
+	/* cards < NVC0 only */
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_pm_engine *pm = &dev_priv->engine.pm;
 	struct nouveau_pm_memtimings *memtimings = &pm->memtimings;
@@ -719,14 +718,14 @@
 		tUNK_19 = 1;
 		tUNK_20 = 0;
 		tUNK_21 = 0;
-		switch (MIN(recordlen,21)) {
-		case 21:
+		switch (min(recordlen, 22)) {
+		case 22:
 			tUNK_21 = entry[21];
-		case 20:
+		case 21:
 			tUNK_20 = entry[20];
-		case 19:
+		case 20:
 			tUNK_19 = entry[19];
-		case 18:
+		case 19:
 			tUNK_18 = entry[18];
 		default:
 			tUNK_0  = entry[0];
@@ -756,24 +755,30 @@
 		timing->reg_100228 = (tUNK_12 << 16 | tUNK_11 << 8 | tUNK_10);
 		if(recordlen > 19) {
 			timing->reg_100228 += (tUNK_19 - 1) << 24;
-		} else {
+		}/* I cannot back-up this else-statement right now
+			 else {
 			timing->reg_100228 += tUNK_12 << 24;
-		}
+		}*/
 
 		/* XXX: reg_10022c */
+		timing->reg_10022c = tUNK_2 - 1;
 
 		timing->reg_100230 = (tUNK_20 << 24 | tUNK_21 << 16 |
 				      tUNK_13 << 8  | tUNK_13);
 
 		/* XXX: +6? */
 		timing->reg_100234 = (tRAS << 24 | (tUNK_19 + 6) << 8 | tRC);
-		if(tUNK_10 > tUNK_11) {
-			timing->reg_100234 += tUNK_10 << 16;
-		} else {
-			timing->reg_100234 += tUNK_11 << 16;
+		timing->reg_100234 += max(tUNK_10,tUNK_11) << 16;
+
+		/* XXX; reg_100238, reg_10023c
+		 * reg: 0x00??????
+		 * reg_10023c:
+		 *      0 for pre-NV50 cards
+		 *      0x????0202 for NV50+ cards (empirical evidence) */
+		if(dev_priv->card_type >= NV_50) {
+			timing->reg_10023c = 0x202;
 		}
 
-		/* XXX; reg_100238, reg_10023c */
 		NV_DEBUG(dev, "Entry %d: 220: %08x %08x %08x %08x\n", i,
 			 timing->reg_100220, timing->reg_100224,
 			 timing->reg_100228, timing->reg_10022c);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_object.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_object.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_object.c	2010-11-21 23:40:11.035093312 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_object.c	2010-11-21 23:40:16.611056232 +0000
@@ -129,7 +129,7 @@
 			if (ramin == NULL) {
 				spin_unlock(&dev_priv->ramin_lock);
 				nouveau_gpuobj_ref(NULL, &gpuobj);
-				return ret;
+				return -ENOMEM;
 			}
 
 			ramin = drm_mm_get_block_atomic(ramin, size, align);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_pm.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_pm.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_pm.c	2010-11-21 23:40:11.036093248 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_pm.c	2010-11-21 23:40:16.611056232 +0000
@@ -284,6 +284,7 @@
 	}
 }
 
+#ifdef CONFIG_HWMON
 static ssize_t
 nouveau_hwmon_show_temp(struct device *d, struct device_attribute *a, char *buf)
 {
@@ -395,10 +396,12 @@
 static const struct attribute_group hwmon_attrgroup = {
 	.attrs = hwmon_attributes,
 };
+#endif
 
 static int
 nouveau_hwmon_init(struct drm_device *dev)
 {
+#ifdef CONFIG_HWMON
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_pm_engine *pm = &dev_priv->engine.pm;
 	struct device *hwmon_dev;
@@ -425,13 +428,14 @@
 	}
 
 	pm->hwmon = hwmon_dev;
-
+#endif
 	return 0;
 }
 
 static void
 nouveau_hwmon_fini(struct drm_device *dev)
 {
+#ifdef CONFIG_HWMON
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_pm_engine *pm = &dev_priv->engine.pm;
 
@@ -439,6 +443,7 @@
 		sysfs_remove_group(&pm->hwmon->kobj, &hwmon_attrgroup);
 		hwmon_device_unregister(pm->hwmon);
 	}
+#endif
 }
 
 int
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_ramht.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_ramht.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_ramht.c	2010-11-21 23:40:11.036093248 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_ramht.c	2010-11-21 23:40:16.611056232 +0000
@@ -153,26 +153,42 @@
 	return -ENOMEM;
 }
 
+static struct nouveau_ramht_entry *
+nouveau_ramht_remove_entry(struct nouveau_channel *chan, u32 handle)
+{
+	struct nouveau_ramht *ramht = chan ? chan->ramht : NULL;
+	struct nouveau_ramht_entry *entry;
+	unsigned long flags;
+
+	if (!ramht)
+		return NULL;
+
+	spin_lock_irqsave(&ramht->lock, flags);
+	list_for_each_entry(entry, &ramht->entries, head) {
+		if (entry->channel == chan &&
+		    (!handle || entry->handle == handle)) {
+			list_del(&entry->head);
+			spin_unlock_irqrestore(&ramht->lock, flags);
+
+			return entry;
+		}
+	}
+	spin_unlock_irqrestore(&ramht->lock, flags);
+
+	return NULL;
+}
+
 static void
-nouveau_ramht_remove_locked(struct nouveau_channel *chan, u32 handle)
+nouveau_ramht_remove_hash(struct nouveau_channel *chan, u32 handle)
 {
 	struct drm_device *dev = chan->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_instmem_engine *instmem = &dev_priv->engine.instmem;
 	struct nouveau_gpuobj *ramht = chan->ramht->gpuobj;
-	struct nouveau_ramht_entry *entry, *tmp;
+	unsigned long flags;
 	u32 co, ho;
 
-	list_for_each_entry_safe(entry, tmp, &chan->ramht->entries, head) {
-		if (entry->channel != chan || entry->handle != handle)
-			continue;
-
-		nouveau_gpuobj_ref(NULL, &entry->gpuobj);
-		list_del(&entry->head);
-		kfree(entry);
-		break;
-	}
-
+	spin_lock_irqsave(&chan->ramht->lock, flags);
 	co = ho = nouveau_ramht_hash_handle(chan, handle);
 	do {
 		if (nouveau_ramht_entry_valid(dev, ramht, co) &&
@@ -184,7 +200,7 @@
 			nv_wo32(ramht, co + 0, 0x00000000);
 			nv_wo32(ramht, co + 4, 0x00000000);
 			instmem->flush(dev);
-			return;
+			goto out;
 		}
 
 		co += 8;
@@ -194,17 +210,22 @@
 
 	NV_ERROR(dev, "RAMHT entry not found. ch=%d, handle=0x%08x\n",
 		 chan->id, handle);
+out:
+	spin_unlock_irqrestore(&chan->ramht->lock, flags);
 }
 
 void
 nouveau_ramht_remove(struct nouveau_channel *chan, u32 handle)
 {
-	struct nouveau_ramht *ramht = chan->ramht;
-	unsigned long flags;
+	struct nouveau_ramht_entry *entry;
 
-	spin_lock_irqsave(&ramht->lock, flags);
-	nouveau_ramht_remove_locked(chan, handle);
-	spin_unlock_irqrestore(&ramht->lock, flags);
+	entry = nouveau_ramht_remove_entry(chan, handle);
+	if (!entry)
+		return;
+
+	nouveau_ramht_remove_hash(chan, entry->handle);
+	nouveau_gpuobj_ref(NULL, &entry->gpuobj);
+	kfree(entry);
 }
 
 struct nouveau_gpuobj *
@@ -265,23 +286,19 @@
 nouveau_ramht_ref(struct nouveau_ramht *ref, struct nouveau_ramht **ptr,
 		  struct nouveau_channel *chan)
 {
-	struct nouveau_ramht_entry *entry, *tmp;
+	struct nouveau_ramht_entry *entry;
 	struct nouveau_ramht *ramht;
-	unsigned long flags;
 
 	if (ref)
 		kref_get(&ref->refcount);
 
 	ramht = *ptr;
 	if (ramht) {
-		spin_lock_irqsave(&ramht->lock, flags);
-		list_for_each_entry_safe(entry, tmp, &ramht->entries, head) {
-			if (entry->channel != chan)
-				continue;
-
-			nouveau_ramht_remove_locked(chan, entry->handle);
+		while ((entry = nouveau_ramht_remove_entry(chan, 0))) {
+			nouveau_ramht_remove_hash(chan, entry->handle);
+			nouveau_gpuobj_ref(NULL, &entry->gpuobj);
+			kfree(entry);
 		}
-		spin_unlock_irqrestore(&ramht->lock, flags);
 
 		kref_put(&ramht->refcount, nouveau_ramht_del);
 	}
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_sgdma.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_sgdma.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_sgdma.c	2010-11-21 23:40:11.036093248 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_sgdma.c	2010-11-21 23:40:16.612069822 +0000
@@ -120,8 +120,8 @@
 	dev_priv->engine.instmem.flush(nvbe->dev);
 
 	if (dev_priv->card_type == NV_50) {
-		nv50_vm_flush(dev, 5); /* PGRAPH */
-		nv50_vm_flush(dev, 0); /* PFIFO */
+		dev_priv->engine.fifo.tlb_flush(dev);
+		dev_priv->engine.graph.tlb_flush(dev);
 	}
 
 	nvbe->bound = true;
@@ -162,8 +162,8 @@
 	dev_priv->engine.instmem.flush(nvbe->dev);
 
 	if (dev_priv->card_type == NV_50) {
-		nv50_vm_flush(dev, 5);
-		nv50_vm_flush(dev, 0);
+		dev_priv->engine.fifo.tlb_flush(dev);
+		dev_priv->engine.graph.tlb_flush(dev);
 	}
 
 	nvbe->bound = false;
@@ -224,7 +224,11 @@
 	int i, ret;
 
 	if (dev_priv->card_type < NV_50) {
-		aper_size = (64 * 1024 * 1024);
+		if(dev_priv->ramin_rsvd_vram < 2 * 1024 * 1024)
+			aper_size = 64 * 1024 * 1024;
+		else
+			aper_size = 512 * 1024 * 1024;
+
 		obj_size  = (aper_size >> NV_CTXDMA_PAGE_SHIFT) * 4;
 		obj_size += 8; /* ctxdma header */
 	} else {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_state.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_state.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_state.c	2010-11-21 23:40:11.037178633 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_state.c	2010-11-21 23:40:16.612069822 +0000
@@ -354,6 +354,15 @@
 		engine->graph.destroy_context	= nv50_graph_destroy_context;
 		engine->graph.load_context	= nv50_graph_load_context;
 		engine->graph.unload_context	= nv50_graph_unload_context;
+		if (dev_priv->chipset != 0x86)
+			engine->graph.tlb_flush	= nv50_graph_tlb_flush;
+		else {
+			/* from what i can see nvidia do this on every
+			 * pre-NVA3 board except NVAC, but, we've only
+			 * ever seen problems on NV86
+			 */
+			engine->graph.tlb_flush	= nv86_graph_tlb_flush;
+		}
 		engine->fifo.channels		= 128;
 		engine->fifo.init		= nv50_fifo_init;
 		engine->fifo.takedown		= nv50_fifo_takedown;
@@ -365,6 +374,7 @@
 		engine->fifo.destroy_context	= nv50_fifo_destroy_context;
 		engine->fifo.load_context	= nv50_fifo_load_context;
 		engine->fifo.unload_context	= nv50_fifo_unload_context;
+		engine->fifo.tlb_flush		= nv50_fifo_tlb_flush;
 		engine->display.early_init	= nv50_display_early_init;
 		engine->display.late_takedown	= nv50_display_late_takedown;
 		engine->display.create		= nv50_display_create;
@@ -1041,6 +1051,9 @@
 	case NOUVEAU_GETPARAM_PTIMER_TIME:
 		getparam->value = dev_priv->engine.timer.read(dev);
 		break;
+	case NOUVEAU_GETPARAM_HAS_BO_USAGE:
+		getparam->value = 1;
+		break;
 	case NOUVEAU_GETPARAM_GRAPH_UNITS:
 		/* NV40 and NV50 versions are quite different, but register
 		 * address is the same. User is supposed to know the card
@@ -1051,7 +1064,7 @@
 		}
 		/* FALLTHRU */
 	default:
-		NV_ERROR(dev, "unknown parameter %lld\n", getparam->param);
+		NV_DEBUG(dev, "unknown parameter %lld\n", getparam->param);
 		return -EINVAL;
 	}
 
@@ -1066,7 +1079,7 @@
 
 	switch (setparam->param) {
 	default:
-		NV_ERROR(dev, "unknown parameter %lld\n", setparam->param);
+		NV_DEBUG(dev, "unknown parameter %lld\n", setparam->param);
 		return -EINVAL;
 	}
 
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_temp.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_temp.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nouveau_temp.c	2010-11-21 23:40:11.037178633 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nouveau_temp.c	2010-11-21 23:40:16.612069822 +0000
@@ -191,7 +191,7 @@
 	int offset = sensor->offset_mult / sensor->offset_div;
 	int core_temp;
 
-	if (dev_priv->chipset >= 0x50) {
+	if (dev_priv->card_type >= NV_50) {
 		core_temp = nv_rd32(dev, 0x20008);
 	} else {
 		core_temp = nv_rd32(dev, 0x0015b4) & 0x1fff;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv04_crtc.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv04_crtc.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv04_crtc.c	2010-11-21 23:40:11.037178633 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv04_crtc.c	2010-11-21 23:40:16.613073712 +0000
@@ -158,7 +158,6 @@
 {
 	struct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);
 	struct drm_device *dev = crtc->dev;
-	struct drm_connector *connector;
 	unsigned char seq1 = 0, crtc17 = 0;
 	unsigned char crtc1A;
 
@@ -213,10 +212,6 @@
 	NVVgaSeqReset(dev, nv_crtc->index, false);
 
 	NVWriteVgaCrtc(dev, nv_crtc->index, NV_CIO_CRE_RPC1_INDEX, crtc1A);
-
-	/* Update connector polling modes */
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
-		nouveau_connector_set_polling(connector);
 }
 
 static bool
@@ -831,7 +826,7 @@
 	/* Update the framebuffer location. */
 	regp->fb_start = nv_crtc->fb.offset & ~3;
 	regp->fb_start += (y * drm_fb->pitch) + (x * drm_fb->bits_per_pixel / 8);
-	NVWriteCRTC(dev, nv_crtc->index, NV_PCRTC_START, regp->fb_start);
+	nv_set_crtc_base(dev, nv_crtc->index, regp->fb_start);
 
 	/* Update the arbitration parameters. */
 	nouveau_calc_arb(dev, crtc->mode.clock, drm_fb->bits_per_pixel,
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv04_dfp.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv04_dfp.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv04_dfp.c	2010-11-21 23:40:11.038178975 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv04_dfp.c	2010-11-21 23:40:16.613073712 +0000
@@ -185,14 +185,15 @@
 	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
 	struct nouveau_connector *nv_connector = nouveau_encoder_connector_get(nv_encoder);
 
-	/* For internal panels and gpu scaling on DVI we need the native mode */
-	if (nv_connector->scaling_mode != DRM_MODE_SCALE_NONE) {
-		if (!nv_connector->native_mode)
-			return false;
+	if (!nv_connector->native_mode ||
+	    nv_connector->scaling_mode == DRM_MODE_SCALE_NONE ||
+	    mode->hdisplay > nv_connector->native_mode->hdisplay ||
+	    mode->vdisplay > nv_connector->native_mode->vdisplay) {
+		nv_encoder->mode = *adjusted_mode;
+
+	} else {
 		nv_encoder->mode = *nv_connector->native_mode;
 		adjusted_mode->clock = nv_connector->native_mode->clock;
-	} else {
-		nv_encoder->mode = *adjusted_mode;
 	}
 
 	return true;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv04_pm.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv04_pm.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv04_pm.c	2010-11-21 23:40:11.038178975 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv04_pm.c	2010-11-21 23:40:16.613073712 +0000
@@ -76,6 +76,15 @@
 		reg += 4;
 
 	nouveau_hw_setpll(dev, reg, &state->calc);
+
+	if (dev_priv->card_type < NV_30 && reg == NV_PRAMDAC_MPLL_COEFF) {
+		if (dev_priv->card_type == NV_20)
+			nv_mask(dev, 0x1002c4, 0, 1 << 20);
+
+		/* Reset the DLLs */
+		nv_mask(dev, 0x1002c0, 0, 1 << 8);
+	}
+
 	kfree(state);
 }
 
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_calc.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_calc.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_calc.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_calc.c	2010-11-21 23:40:16.615074355 +0000
@@ -51,24 +51,28 @@
 	       int *N, int *fN, int *M, int *P)
 {
 	fixed20_12 fb_div, a, b;
+	u32 refclk = pll->refclk / 10;
+	u32 max_vco_freq = pll->vco1.maxfreq / 10;
+	u32 max_vco_inputfreq = pll->vco1.max_inputfreq / 10;
+	clk /= 10;
 
-	*P = pll->vco1.maxfreq / clk;
+	*P = max_vco_freq / clk;
 	if (*P > pll->max_p)
 		*P = pll->max_p;
 	if (*P < pll->min_p)
 		*P = pll->min_p;
 
-	/* *M = ceil(refclk / pll->vco.max_inputfreq); */
-	a.full = dfixed_const(pll->refclk);
-	b.full = dfixed_const(pll->vco1.max_inputfreq);
+	/* *M = floor((refclk + max_vco_inputfreq) / max_vco_inputfreq); */
+	a.full = dfixed_const(refclk + max_vco_inputfreq);
+	b.full = dfixed_const(max_vco_inputfreq);
 	a.full = dfixed_div(a, b);
-	a.full = dfixed_ceil(a);
+	a.full = dfixed_floor(a);
 	*M = dfixed_trunc(a);
 
 	/* fb_div = (vco * *M) / refclk; */
 	fb_div.full = dfixed_const(clk * *P);
 	fb_div.full = dfixed_mul(fb_div, a);
-	a.full = dfixed_const(pll->refclk);
+	a.full = dfixed_const(refclk);
 	fb_div.full = dfixed_div(fb_div, a);
 
 	/* *N = floor(fb_div); */
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_crtc.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_crtc.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_crtc.c	2010-11-21 23:40:11.040192441 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_crtc.c	2010-11-21 23:40:16.615074355 +0000
@@ -546,7 +546,7 @@
 	}
 
 	nv_crtc->fb.offset = fb->nvbo->bo.offset - dev_priv->vm_vram_base;
-	nv_crtc->fb.tile_flags = fb->nvbo->tile_flags;
+	nv_crtc->fb.tile_flags = nouveau_bo_tile_layout(fb->nvbo);
 	nv_crtc->fb.cpp = drm_fb->bits_per_pixel / 8;
 	if (!nv_crtc->fb.blanked && dev_priv->chipset != 0x50) {
 		ret = RING_SPACE(evo, 2);
@@ -578,7 +578,7 @@
 				  fb->nvbo->tile_mode);
 	}
 	if (dev_priv->chipset == 0x50)
-		OUT_RING(evo, (fb->nvbo->tile_flags << 8) | format);
+		OUT_RING(evo, (nv_crtc->fb.tile_flags << 8) | format);
 	else
 		OUT_RING(evo, format);
 
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_display.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_display.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_display.c	2010-11-21 23:40:11.041179710 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_display.c	2010-11-21 23:40:16.616072297 +0000
@@ -1032,11 +1032,18 @@
 	struct drm_connector *connector;
 	const uint32_t gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };
 	uint32_t unplug_mask, plug_mask, change_mask;
-	uint32_t hpd0, hpd1 = 0;
+	uint32_t hpd0, hpd1;
 
-	hpd0 = nv_rd32(dev, 0xe054) & nv_rd32(dev, 0xe050);
+	spin_lock_irq(&dev_priv->hpd_state.lock);
+	hpd0 = dev_priv->hpd_state.hpd0_bits;
+	dev_priv->hpd_state.hpd0_bits = 0;
+	hpd1 = dev_priv->hpd_state.hpd1_bits;
+	dev_priv->hpd_state.hpd1_bits = 0;
+	spin_unlock_irq(&dev_priv->hpd_state.lock);
+
+	hpd0 &= nv_rd32(dev, 0xe050);
 	if (dev_priv->chipset >= 0x90)
-		hpd1 = nv_rd32(dev, 0xe074) & nv_rd32(dev, 0xe070);
+		hpd1 &= nv_rd32(dev, 0xe070);
 
 	plug_mask   = (hpd0 & 0x0000ffff) | (hpd1 << 16);
 	unplug_mask = (hpd0 >> 16) | (hpd1 & 0xffff0000);
@@ -1078,10 +1085,6 @@
 			helper->dpms(connector->encoder, DRM_MODE_DPMS_OFF);
 	}
 
-	nv_wr32(dev, 0xe054, nv_rd32(dev, 0xe054));
-	if (dev_priv->chipset >= 0x90)
-		nv_wr32(dev, 0xe074, nv_rd32(dev, 0xe074));
-
 	drm_helper_hpd_irq_event(dev);
 }
 
@@ -1092,8 +1095,22 @@
 	uint32_t delayed = 0;
 
 	if (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_HOTPLUG) {
-		if (!work_pending(&dev_priv->hpd_work))
-			queue_work(dev_priv->wq, &dev_priv->hpd_work);
+		uint32_t hpd0_bits, hpd1_bits = 0;
+
+		hpd0_bits = nv_rd32(dev, 0xe054);
+		nv_wr32(dev, 0xe054, hpd0_bits);
+
+		if (dev_priv->chipset >= 0x90) {
+			hpd1_bits = nv_rd32(dev, 0xe074);
+			nv_wr32(dev, 0xe074, hpd1_bits);
+		}
+
+		spin_lock(&dev_priv->hpd_state.lock);
+		dev_priv->hpd_state.hpd0_bits |= hpd0_bits;
+		dev_priv->hpd_state.hpd1_bits |= hpd1_bits;
+		spin_unlock(&dev_priv->hpd_state.lock);
+
+		queue_work(dev_priv->wq, &dev_priv->hpd_work);
 	}
 
 	while (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_DISPLAY) {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_fifo.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_fifo.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_fifo.c	2010-11-21 23:40:11.041179710 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_fifo.c	2010-11-21 23:40:16.616072297 +0000
@@ -464,3 +464,8 @@
 	return 0;
 }
 
+void
+nv50_fifo_tlb_flush(struct drm_device *dev)
+{
+	nv50_vm_flush(dev, 5);
+}
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_graph.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_graph.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_graph.c	2010-11-21 23:40:11.042179094 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_graph.c	2010-11-21 23:40:16.616072297 +0000
@@ -402,3 +402,55 @@
 	{ 0x8597, false, NULL }, /* tesla (nva3, nva5, nva8) */
 	{}
 };
+
+void
+nv50_graph_tlb_flush(struct drm_device *dev)
+{
+	nv50_vm_flush(dev, 0);
+}
+
+void
+nv86_graph_tlb_flush(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;
+	bool idle, timeout = false;
+	unsigned long flags;
+	u64 start;
+	u32 tmp;
+
+	spin_lock_irqsave(&dev_priv->context_switch_lock, flags);
+	nv_mask(dev, 0x400500, 0x00000001, 0x00000000);
+
+	start = ptimer->read(dev);
+	do {
+		idle = true;
+
+		for (tmp = nv_rd32(dev, 0x400380); tmp && idle; tmp >>= 3) {
+			if ((tmp & 7) == 1)
+				idle = false;
+		}
+
+		for (tmp = nv_rd32(dev, 0x400384); tmp && idle; tmp >>= 3) {
+			if ((tmp & 7) == 1)
+				idle = false;
+		}
+
+		for (tmp = nv_rd32(dev, 0x400388); tmp && idle; tmp >>= 3) {
+			if ((tmp & 7) == 1)
+				idle = false;
+		}
+	} while (!idle && !(timeout = ptimer->read(dev) - start > 2000000000));
+
+	if (timeout) {
+		NV_ERROR(dev, "PGRAPH TLB flush idle timeout fail: "
+			      "0x%08x 0x%08x 0x%08x 0x%08x\n",
+			 nv_rd32(dev, 0x400700), nv_rd32(dev, 0x400380),
+			 nv_rd32(dev, 0x400384), nv_rd32(dev, 0x400388));
+	}
+
+	nv50_vm_flush(dev, 0);
+
+	nv_mask(dev, 0x400500, 0x00000001, 0x00000001);
+	spin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);
+}
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_instmem.c linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_instmem.c
--- linux-2.6.37-rc2/drivers/gpu/drm/nouveau/nv50_instmem.c	2010-11-21 23:40:11.044073842 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/nouveau/nv50_instmem.c	2010-11-21 23:40:16.619060763 +0000
@@ -402,7 +402,6 @@
 	}
 	dev_priv->engine.instmem.flush(dev);
 
-	nv50_vm_flush(dev, 4);
 	nv50_vm_flush(dev, 6);
 
 	gpuobj->im_bound = 1;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/evergreen.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/evergreen.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/evergreen.c	2010-11-21 23:40:11.046092356 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/evergreen.c	2010-11-21 23:40:16.621100507 +0000
@@ -1650,7 +1650,36 @@
 		}
 	}
 
-	rdev->config.evergreen.tile_config = gb_addr_config;
+	/* setup tiling info dword.  gb_addr_config is not adequate since it does
+	 * not have bank info, so create a custom tiling dword.
+	 * bits 3:0   num_pipes
+	 * bits 7:4   num_banks
+	 * bits 11:8  group_size
+	 * bits 15:12 row_size
+	 */
+	rdev->config.evergreen.tile_config = 0;
+	switch (rdev->config.evergreen.max_tile_pipes) {
+	case 1:
+	default:
+		rdev->config.evergreen.tile_config |= (0 << 0);
+		break;
+	case 2:
+		rdev->config.evergreen.tile_config |= (1 << 0);
+		break;
+	case 4:
+		rdev->config.evergreen.tile_config |= (2 << 0);
+		break;
+	case 8:
+		rdev->config.evergreen.tile_config |= (3 << 0);
+		break;
+	}
+	rdev->config.evergreen.tile_config |=
+		((mc_arb_ramcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT) << 4;
+	rdev->config.evergreen.tile_config |=
+		((mc_arb_ramcfg & BURSTLENGTH_MASK) >> BURSTLENGTH_SHIFT) << 8;
+	rdev->config.evergreen.tile_config |=
+		((gb_addr_config & 0x30000000) >> 28) << 12;
+
 	WREG32(GB_BACKEND_MAP, gb_backend_map);
 	WREG32(GB_ADDR_CONFIG, gb_addr_config);
 	WREG32(DMIF_ADDR_CONFIG, gb_addr_config);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/evergreen_blit_kms.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/evergreen_blit_kms.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/evergreen_blit_kms.c	2010-11-21 23:40:11.047180024 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/evergreen_blit_kms.c	2010-11-21 23:40:16.621100507 +0000
@@ -459,7 +459,7 @@
 	obj_size += evergreen_ps_size * 4;
 	obj_size = ALIGN(obj_size, 256);
 
-	r = radeon_bo_create(rdev, NULL, obj_size, true, RADEON_GEM_DOMAIN_VRAM,
+	r = radeon_bo_create(rdev, NULL, obj_size, PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,
 				&rdev->r600_blit.shader_obj);
 	if (r) {
 		DRM_ERROR("evergreen failed to allocate shader\n");
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600.c	2010-11-21 23:40:11.049179067 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600.c	2010-11-21 23:40:16.623099172 +0000
@@ -2718,7 +2718,7 @@
 	/* Allocate ring buffer */
 	if (rdev->ih.ring_obj == NULL) {
 		r = radeon_bo_create(rdev, NULL, rdev->ih.ring_size,
-				     true,
+				     PAGE_SIZE, true,
 				     RADEON_GEM_DOMAIN_GTT,
 				     &rdev->ih.ring_obj);
 		if (r) {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600_blit_kms.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600_blit_kms.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600_blit_kms.c	2010-11-21 23:40:11.049179067 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600_blit_kms.c	2010-11-21 23:40:16.623099172 +0000
@@ -501,7 +501,7 @@
 	obj_size += r6xx_ps_size * 4;
 	obj_size = ALIGN(obj_size, 256);
 
-	r = radeon_bo_create(rdev, NULL, obj_size, true, RADEON_GEM_DOMAIN_VRAM,
+	r = radeon_bo_create(rdev, NULL, obj_size, PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,
 				&rdev->r600_blit.shader_obj);
 	if (r) {
 		DRM_ERROR("r600 failed to allocate shader\n");
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600_cs.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600_cs.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600_cs.c	2010-11-21 23:40:11.050179088 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600_cs.c	2010-11-21 23:40:16.624101805 +0000
@@ -50,6 +50,7 @@
 	u32			nsamples;
 	u32			cb_color_base_last[8];
 	struct radeon_bo	*cb_color_bo[8];
+	u64			cb_color_bo_mc[8];
 	u32			cb_color_bo_offset[8];
 	struct radeon_bo	*cb_color_frag_bo[8];
 	struct radeon_bo	*cb_color_tile_bo[8];
@@ -67,6 +68,7 @@
 	u32			db_depth_size;
 	u32			db_offset;
 	struct radeon_bo	*db_bo;
+	u64			db_bo_mc;
 };
 
 static inline int r600_bpe_from_format(u32 *bpe, u32 format)
@@ -140,6 +142,68 @@
 	return 0;
 }
 
+struct array_mode_checker {
+	int array_mode;
+	u32 group_size;
+	u32 nbanks;
+	u32 npipes;
+	u32 nsamples;
+	u32 bpe;
+};
+
+/* returns alignment in pixels for pitch/height/depth and bytes for base */
+static inline int r600_get_array_mode_alignment(struct array_mode_checker *values,
+						u32 *pitch_align,
+						u32 *height_align,
+						u32 *depth_align,
+						u64 *base_align)
+{
+	u32 tile_width = 8;
+	u32 tile_height = 8;
+	u32 macro_tile_width = values->nbanks;
+	u32 macro_tile_height = values->npipes;
+	u32 tile_bytes = tile_width * tile_height * values->bpe * values->nsamples;
+	u32 macro_tile_bytes = macro_tile_width * macro_tile_height * tile_bytes;
+
+	switch (values->array_mode) {
+	case ARRAY_LINEAR_GENERAL:
+		/* technically tile_width/_height for pitch/height */
+		*pitch_align = 1; /* tile_width */
+		*height_align = 1; /* tile_height */
+		*depth_align = 1;
+		*base_align = 1;
+		break;
+	case ARRAY_LINEAR_ALIGNED:
+		*pitch_align = max((u32)64, (u32)(values->group_size / values->bpe));
+		*height_align = tile_height;
+		*depth_align = 1;
+		*base_align = values->group_size;
+		break;
+	case ARRAY_1D_TILED_THIN1:
+		*pitch_align = max((u32)tile_width,
+				   (u32)(values->group_size /
+					 (tile_height * values->bpe * values->nsamples)));
+		*height_align = tile_height;
+		*depth_align = 1;
+		*base_align = values->group_size;
+		break;
+	case ARRAY_2D_TILED_THIN1:
+		*pitch_align = max((u32)macro_tile_width,
+				  (u32)(((values->group_size / tile_height) /
+					 (values->bpe * values->nsamples)) *
+					values->nbanks)) * tile_width;
+		*height_align = macro_tile_height * tile_height;
+		*depth_align = 1;
+		*base_align = max(macro_tile_bytes,
+				  (*pitch_align) * values->bpe * (*height_align) * values->nsamples);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static void r600_cs_track_init(struct r600_cs_track *track)
 {
 	int i;
@@ -153,10 +217,12 @@
 		track->cb_color_info[i] = 0;
 		track->cb_color_bo[i] = NULL;
 		track->cb_color_bo_offset[i] = 0xFFFFFFFF;
+		track->cb_color_bo_mc[i] = 0xFFFFFFFF;
 	}
 	track->cb_target_mask = 0xFFFFFFFF;
 	track->cb_shader_mask = 0xFFFFFFFF;
 	track->db_bo = NULL;
+	track->db_bo_mc = 0xFFFFFFFF;
 	/* assume the biggest format and that htile is enabled */
 	track->db_depth_info = 7 | (1 << 25);
 	track->db_depth_view = 0xFFFFC000;
@@ -168,7 +234,10 @@
 static inline int r600_cs_track_validate_cb(struct radeon_cs_parser *p, int i)
 {
 	struct r600_cs_track *track = p->track;
-	u32 bpe = 0, pitch, slice_tile_max, size, tmp, height, pitch_align;
+	u32 bpe = 0, slice_tile_max, size, tmp;
+	u32 height, height_align, pitch, pitch_align, depth_align;
+	u64 base_offset, base_align;
+	struct array_mode_checker array_check;
 	volatile u32 *ib = p->ib->ptr;
 	unsigned array_mode;
 
@@ -183,60 +252,40 @@
 			i, track->cb_color_info[i]);
 		return -EINVAL;
 	}
-	/* pitch is the number of 8x8 tiles per row */
-	pitch = G_028060_PITCH_TILE_MAX(track->cb_color_size[i]) + 1;
+	/* pitch in pixels */
+	pitch = (G_028060_PITCH_TILE_MAX(track->cb_color_size[i]) + 1) * 8;
 	slice_tile_max = G_028060_SLICE_TILE_MAX(track->cb_color_size[i]) + 1;
 	slice_tile_max *= 64;
-	height = slice_tile_max / (pitch * 8);
+	height = slice_tile_max / pitch;
 	if (height > 8192)
 		height = 8192;
 	array_mode = G_0280A0_ARRAY_MODE(track->cb_color_info[i]);
+
+	base_offset = track->cb_color_bo_mc[i] + track->cb_color_bo_offset[i];
+	array_check.array_mode = array_mode;
+	array_check.group_size = track->group_size;
+	array_check.nbanks = track->nbanks;
+	array_check.npipes = track->npipes;
+	array_check.nsamples = track->nsamples;
+	array_check.bpe = bpe;
+	if (r600_get_array_mode_alignment(&array_check,
+					  &pitch_align, &height_align, &depth_align, &base_align)) {
+		dev_warn(p->dev, "%s invalid tiling %d for %d (0x%08X)\n", __func__,
+			 G_0280A0_ARRAY_MODE(track->cb_color_info[i]), i,
+			 track->cb_color_info[i]);
+		return -EINVAL;
+	}
 	switch (array_mode) {
 	case V_0280A0_ARRAY_LINEAR_GENERAL:
-		/* technically height & 0x7 */
 		break;
 	case V_0280A0_ARRAY_LINEAR_ALIGNED:
-		pitch_align = max((u32)64, (u32)(track->group_size / bpe)) / 8;
-		if (!IS_ALIGNED(pitch, pitch_align)) {
-			dev_warn(p->dev, "%s:%d cb pitch (%d) invalid\n",
-				 __func__, __LINE__, pitch);
-			return -EINVAL;
-		}
-		if (!IS_ALIGNED(height, 8)) {
-			dev_warn(p->dev, "%s:%d cb height (%d) invalid\n",
-				 __func__, __LINE__, height);
-			return -EINVAL;
-		}
 		break;
 	case V_0280A0_ARRAY_1D_TILED_THIN1:
-		pitch_align = max((u32)8, (u32)(track->group_size / (8 * bpe * track->nsamples))) / 8;
-		if (!IS_ALIGNED(pitch, pitch_align)) {
-			dev_warn(p->dev, "%s:%d cb pitch (%d) invalid\n",
-				 __func__, __LINE__, pitch);
-			return -EINVAL;
-		}
 		/* avoid breaking userspace */
 		if (height > 7)
 			height &= ~0x7;
-		if (!IS_ALIGNED(height, 8)) {
-			dev_warn(p->dev, "%s:%d cb height (%d) invalid\n",
-				 __func__, __LINE__, height);
-			return -EINVAL;
-		}
 		break;
 	case V_0280A0_ARRAY_2D_TILED_THIN1:
-		pitch_align = max((u32)track->nbanks,
-				  (u32)(((track->group_size / 8) / (bpe * track->nsamples)) * track->nbanks)) / 8;
-		if (!IS_ALIGNED(pitch, pitch_align)) {
-			dev_warn(p->dev, "%s:%d cb pitch (%d) invalid\n",
-				__func__, __LINE__, pitch);
-			return -EINVAL;
-		}
-		if (!IS_ALIGNED((height / 8), track->npipes)) {
-			dev_warn(p->dev, "%s:%d cb height (%d) invalid\n",
-				 __func__, __LINE__, height);
-			return -EINVAL;
-		}
 		break;
 	default:
 		dev_warn(p->dev, "%s invalid tiling %d for %d (0x%08X)\n", __func__,
@@ -244,13 +293,29 @@
 			track->cb_color_info[i]);
 		return -EINVAL;
 	}
+
+	if (!IS_ALIGNED(pitch, pitch_align)) {
+		dev_warn(p->dev, "%s:%d cb pitch (%d) invalid\n",
+			 __func__, __LINE__, pitch);
+		return -EINVAL;
+	}
+	if (!IS_ALIGNED(height, height_align)) {
+		dev_warn(p->dev, "%s:%d cb height (%d) invalid\n",
+			 __func__, __LINE__, height);
+		return -EINVAL;
+	}
+	if (!IS_ALIGNED(base_offset, base_align)) {
+		dev_warn(p->dev, "%s offset[%d] 0x%llx not aligned\n", __func__, i, base_offset);
+		return -EINVAL;
+	}
+
 	/* check offset */
-	tmp = height * pitch * 8 * bpe;
+	tmp = height * pitch * bpe;
 	if ((tmp + track->cb_color_bo_offset[i]) > radeon_bo_size(track->cb_color_bo[i])) {
 		if (array_mode == V_0280A0_ARRAY_LINEAR_GENERAL) {
 			/* the initial DDX does bad things with the CB size occasionally */
 			/* it rounds up height too far for slice tile max but the BO is smaller */
-			tmp = (height - 7) * 8 * bpe;
+			tmp = (height - 7) * pitch * bpe;
 			if ((tmp + track->cb_color_bo_offset[i]) > radeon_bo_size(track->cb_color_bo[i])) {
 				dev_warn(p->dev, "%s offset[%d] %d %d %lu too big\n", __func__, i, track->cb_color_bo_offset[i], tmp, radeon_bo_size(track->cb_color_bo[i]));
 				return -EINVAL;
@@ -260,15 +325,11 @@
 			return -EINVAL;
 		}
 	}
-	if (!IS_ALIGNED(track->cb_color_bo_offset[i], track->group_size)) {
-		dev_warn(p->dev, "%s offset[%d] %d not aligned\n", __func__, i, track->cb_color_bo_offset[i]);
-		return -EINVAL;
-	}
 	/* limit max tile */
-	tmp = (height * pitch * 8) >> 6;
+	tmp = (height * pitch) >> 6;
 	if (tmp < slice_tile_max)
 		slice_tile_max = tmp;
-	tmp = S_028060_PITCH_TILE_MAX(pitch - 1) |
+	tmp = S_028060_PITCH_TILE_MAX((pitch / 8) - 1) |
 		S_028060_SLICE_TILE_MAX(slice_tile_max - 1);
 	ib[track->cb_color_size_idx[i]] = tmp;
 	return 0;
@@ -310,7 +371,12 @@
 	/* Check depth buffer */
 	if (G_028800_STENCIL_ENABLE(track->db_depth_control) ||
 		G_028800_Z_ENABLE(track->db_depth_control)) {
-		u32 nviews, bpe, ntiles, pitch, pitch_align, height, size, slice_tile_max;
+		u32 nviews, bpe, ntiles, size, slice_tile_max;
+		u32 height, height_align, pitch, pitch_align, depth_align;
+		u64 base_offset, base_align;
+		struct array_mode_checker array_check;
+		int array_mode;
+
 		if (track->db_bo == NULL) {
 			dev_warn(p->dev, "z/stencil with no depth buffer\n");
 			return -EINVAL;
@@ -353,41 +419,34 @@
 			ib[track->db_depth_size_idx] = S_028000_SLICE_TILE_MAX(tmp - 1) | (track->db_depth_size & 0x3FF);
 		} else {
 			size = radeon_bo_size(track->db_bo);
-			pitch = G_028000_PITCH_TILE_MAX(track->db_depth_size) + 1;
+			/* pitch in pixels */
+			pitch = (G_028000_PITCH_TILE_MAX(track->db_depth_size) + 1) * 8;
 			slice_tile_max = G_028000_SLICE_TILE_MAX(track->db_depth_size) + 1;
 			slice_tile_max *= 64;
-			height = slice_tile_max / (pitch * 8);
+			height = slice_tile_max / pitch;
 			if (height > 8192)
 				height = 8192;
-			switch (G_028010_ARRAY_MODE(track->db_depth_info)) {
+			base_offset = track->db_bo_mc + track->db_offset;
+			array_mode = G_028010_ARRAY_MODE(track->db_depth_info);
+			array_check.array_mode = array_mode;
+			array_check.group_size = track->group_size;
+			array_check.nbanks = track->nbanks;
+			array_check.npipes = track->npipes;
+			array_check.nsamples = track->nsamples;
+			array_check.bpe = bpe;
+			if (r600_get_array_mode_alignment(&array_check,
+							  &pitch_align, &height_align, &depth_align, &base_align)) {
+				dev_warn(p->dev, "%s invalid tiling %d (0x%08X)\n", __func__,
+					 G_028010_ARRAY_MODE(track->db_depth_info),
+					 track->db_depth_info);
+				return -EINVAL;
+			}
+			switch (array_mode) {
 			case V_028010_ARRAY_1D_TILED_THIN1:
-				pitch_align = (max((u32)8, (u32)(track->group_size / (8 * bpe))) / 8);
-				if (!IS_ALIGNED(pitch, pitch_align)) {
-					dev_warn(p->dev, "%s:%d db pitch (%d) invalid\n",
-						 __func__, __LINE__, pitch);
-					return -EINVAL;
-				}
 				/* don't break userspace */
 				height &= ~0x7;
-				if (!IS_ALIGNED(height, 8)) {
-					dev_warn(p->dev, "%s:%d db height (%d) invalid\n",
-						 __func__, __LINE__, height);
-					return -EINVAL;
-				}
 				break;
 			case V_028010_ARRAY_2D_TILED_THIN1:
-				pitch_align = max((u32)track->nbanks,
-						  (u32)(((track->group_size / 8) / bpe) * track->nbanks)) / 8;
-				if (!IS_ALIGNED(pitch, pitch_align)) {
-					dev_warn(p->dev, "%s:%d db pitch (%d) invalid\n",
-						 __func__, __LINE__, pitch);
-					return -EINVAL;
-				}
-				if (!IS_ALIGNED((height / 8), track->npipes)) {
-					dev_warn(p->dev, "%s:%d db height (%d) invalid\n",
-						 __func__, __LINE__, height);
-					return -EINVAL;
-				}
 				break;
 			default:
 				dev_warn(p->dev, "%s invalid tiling %d (0x%08X)\n", __func__,
@@ -395,15 +454,27 @@
 					 track->db_depth_info);
 				return -EINVAL;
 			}
-			if (!IS_ALIGNED(track->db_offset, track->group_size)) {
-				dev_warn(p->dev, "%s offset[%d] %d not aligned\n", __func__, i, track->db_offset);
+
+			if (!IS_ALIGNED(pitch, pitch_align)) {
+				dev_warn(p->dev, "%s:%d db pitch (%d) invalid\n",
+					 __func__, __LINE__, pitch);
+				return -EINVAL;
+			}
+			if (!IS_ALIGNED(height, height_align)) {
+				dev_warn(p->dev, "%s:%d db height (%d) invalid\n",
+					 __func__, __LINE__, height);
 				return -EINVAL;
 			}
+			if (!IS_ALIGNED(base_offset, base_align)) {
+				dev_warn(p->dev, "%s offset[%d] 0x%llx not aligned\n", __func__, i, base_offset);
+				return -EINVAL;
+			}
+
 			ntiles = G_028000_SLICE_TILE_MAX(track->db_depth_size) + 1;
 			nviews = G_028004_SLICE_MAX(track->db_depth_view) + 1;
 			tmp = ntiles * bpe * 64 * nviews;
 			if ((tmp + track->db_offset) > radeon_bo_size(track->db_bo)) {
-				dev_warn(p->dev, "z/stencil buffer too small (0x%08X %d %d %d -> %d have %ld)\n",
+				dev_warn(p->dev, "z/stencil buffer too small (0x%08X %d %d %d -> %u have %lu)\n",
 						track->db_depth_size, ntiles, nviews, bpe, tmp + track->db_offset,
 						radeon_bo_size(track->db_bo));
 				return -EINVAL;
@@ -954,6 +1025,7 @@
 		ib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);
 		track->cb_color_base_last[tmp] = ib[idx];
 		track->cb_color_bo[tmp] = reloc->robj;
+		track->cb_color_bo_mc[tmp] = reloc->lobj.gpu_offset;
 		break;
 	case DB_DEPTH_BASE:
 		r = r600_cs_packet_next_reloc(p, &reloc);
@@ -965,6 +1037,7 @@
 		track->db_offset = radeon_get_ib_value(p, idx) << 8;
 		ib[idx] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);
 		track->db_bo = reloc->robj;
+		track->db_bo_mc = reloc->lobj.gpu_offset;
 		break;
 	case DB_HTILE_DATA_BASE:
 	case SQ_PGM_START_FS:
@@ -1086,16 +1159,25 @@
 static inline int r600_check_texture_resource(struct radeon_cs_parser *p,  u32 idx,
 					      struct radeon_bo *texture,
 					      struct radeon_bo *mipmap,
+					      u64 base_offset,
+					      u64 mip_offset,
 					      u32 tiling_flags)
 {
 	struct r600_cs_track *track = p->track;
 	u32 nfaces, nlevels, blevel, w0, h0, d0, bpe = 0;
-	u32 word0, word1, l0_size, mipmap_size, pitch, pitch_align;
+	u32 word0, word1, l0_size, mipmap_size;
+	u32 height_align, pitch, pitch_align, depth_align;
+	u64 base_align;
+	struct array_mode_checker array_check;
 
 	/* on legacy kernel we don't perform advanced check */
 	if (p->rdev == NULL)
 		return 0;
 
+	/* convert to bytes */
+	base_offset <<= 8;
+	mip_offset <<= 8;
+
 	word0 = radeon_get_ib_value(p, idx + 0);
 	if (tiling_flags & RADEON_TILING_MACRO)
 		word0 |= S_038000_TILE_MODE(V_038000_ARRAY_2D_TILED_THIN1);
@@ -1128,46 +1210,38 @@
 		return -EINVAL;
 	}
 
-	pitch = G_038000_PITCH(word0) + 1;
-	switch (G_038000_TILE_MODE(word0)) {
-	case V_038000_ARRAY_LINEAR_GENERAL:
-		pitch_align = 1;
-		/* XXX check height align */
-		break;
-	case V_038000_ARRAY_LINEAR_ALIGNED:
-		pitch_align = max((u32)64, (u32)(track->group_size / bpe)) / 8;
-		if (!IS_ALIGNED(pitch, pitch_align)) {
-			dev_warn(p->dev, "%s:%d tex pitch (%d) invalid\n",
-				 __func__, __LINE__, pitch);
-			return -EINVAL;
-		}
-		/* XXX check height align */
-		break;
-	case V_038000_ARRAY_1D_TILED_THIN1:
-		pitch_align = max((u32)8, (u32)(track->group_size / (8 * bpe))) / 8;
-		if (!IS_ALIGNED(pitch, pitch_align)) {
-			dev_warn(p->dev, "%s:%d tex pitch (%d) invalid\n",
-				 __func__, __LINE__, pitch);
-			return -EINVAL;
-		}
-		/* XXX check height align */
-		break;
-	case V_038000_ARRAY_2D_TILED_THIN1:
-		pitch_align = max((u32)track->nbanks,
-				  (u32)(((track->group_size / 8) / bpe) * track->nbanks)) / 8;
-		if (!IS_ALIGNED(pitch, pitch_align)) {
-			dev_warn(p->dev, "%s:%d tex pitch (%d) invalid\n",
-				__func__, __LINE__, pitch);
-			return -EINVAL;
-		}
-		/* XXX check height align */
-		break;
-	default:
-		dev_warn(p->dev, "%s invalid tiling %d (0x%08X)\n", __func__,
-			 G_038000_TILE_MODE(word0), word0);
+	/* pitch in texels */
+	pitch = (G_038000_PITCH(word0) + 1) * 8;
+	array_check.array_mode = G_038000_TILE_MODE(word0);
+	array_check.group_size = track->group_size;
+	array_check.nbanks = track->nbanks;
+	array_check.npipes = track->npipes;
+	array_check.nsamples = 1;
+	array_check.bpe = bpe;
+	if (r600_get_array_mode_alignment(&array_check,
+					  &pitch_align, &height_align, &depth_align, &base_align)) {
+		dev_warn(p->dev, "%s:%d tex array mode (%d) invalid\n",
+			 __func__, __LINE__, G_038000_TILE_MODE(word0));
+		return -EINVAL;
+	}
+
+	/* XXX check height as well... */
+
+	if (!IS_ALIGNED(pitch, pitch_align)) {
+		dev_warn(p->dev, "%s:%d tex pitch (%d) invalid\n",
+			 __func__, __LINE__, pitch);
+		return -EINVAL;
+	}
+	if (!IS_ALIGNED(base_offset, base_align)) {
+		dev_warn(p->dev, "%s:%d tex base offset (0x%llx) invalid\n",
+			 __func__, __LINE__, base_offset);
+		return -EINVAL;
+	}
+	if (!IS_ALIGNED(mip_offset, base_align)) {
+		dev_warn(p->dev, "%s:%d tex mip offset (0x%llx) invalid\n",
+			 __func__, __LINE__, mip_offset);
 		return -EINVAL;
 	}
-	/* XXX check offset align */
 
 	word0 = radeon_get_ib_value(p, idx + 4);
 	word1 = radeon_get_ib_value(p, idx + 5);
@@ -1402,7 +1476,10 @@
 				mip_offset = (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);
 				mipmap = reloc->robj;
 				r = r600_check_texture_resource(p,  idx+(i*7)+1,
-								texture, mipmap, reloc->lobj.tiling_flags);
+								texture, mipmap,
+								base_offset + radeon_get_ib_value(p, idx+1+(i*7)+2),
+								mip_offset + radeon_get_ib_value(p, idx+1+(i*7)+3),
+								reloc->lobj.tiling_flags);
 				if (r)
 					return r;
 				ib[idx+1+(i*7)+2] += base_offset;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600d.h linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600d.h
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/r600d.h	2010-11-21 23:40:11.050179088 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/r600d.h	2010-11-21 23:40:16.624101805 +0000
@@ -51,6 +51,12 @@
 #define PTE_READABLE				(1 << 5)
 #define PTE_WRITEABLE				(1 << 6)
 
+/* tiling bits */
+#define     ARRAY_LINEAR_GENERAL              0x00000000
+#define     ARRAY_LINEAR_ALIGNED              0x00000001
+#define     ARRAY_1D_TILED_THIN1              0x00000002
+#define     ARRAY_2D_TILED_THIN1              0x00000004
+
 /* Registers */
 #define	ARB_POP						0x2418
 #define 	ENABLE_TC128					(1 << 30)
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon.h linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon.h
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon.h	2010-11-21 23:40:11.050179088 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon.h	2010-11-21 23:40:16.624101805 +0000
@@ -1262,6 +1262,10 @@
 		(rdev->family == CHIP_RS400) ||			\
 		(rdev->family == CHIP_RS480))
 #define ASIC_IS_AVIVO(rdev) ((rdev->family >= CHIP_RS600))
+#define ASIC_IS_DCE2(rdev) ((rdev->family == CHIP_RS600)  ||	\
+			    (rdev->family == CHIP_RS690)  ||	\
+			    (rdev->family == CHIP_RS740)  ||	\
+			    (rdev->family >= CHIP_R600))
 #define ASIC_IS_DCE3(rdev) ((rdev->family >= CHIP_RV620))
 #define ASIC_IS_DCE32(rdev) ((rdev->family >= CHIP_RV730))
 #define ASIC_IS_DCE4(rdev) ((rdev->family >= CHIP_CEDAR))
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_benchmark.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_benchmark.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_benchmark.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_benchmark.c	2010-11-21 23:40:16.625074310 +0000
@@ -41,7 +41,7 @@
 
 	size = bsize;
 	n = 1024;
-	r = radeon_bo_create(rdev, NULL, size, true, sdomain, &sobj);
+	r = radeon_bo_create(rdev, NULL, size, PAGE_SIZE, true, sdomain, &sobj);
 	if (r) {
 		goto out_cleanup;
 	}
@@ -53,7 +53,7 @@
 	if (r) {
 		goto out_cleanup;
 	}
-	r = radeon_bo_create(rdev, NULL, size, true, ddomain, &dobj);
+	r = radeon_bo_create(rdev, NULL, size, PAGE_SIZE, true, ddomain, &dobj);
 	if (r) {
 		goto out_cleanup;
 	}
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_combios.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_combios.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_combios.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_combios.c	2010-11-21 23:40:16.626099607 +0000
@@ -571,6 +571,7 @@
 	}
 
 	if (clk_mask && data_mask) {
+		/* system specific masks */
 		i2c.mask_clk_mask = clk_mask;
 		i2c.mask_data_mask = data_mask;
 		i2c.a_clk_mask = clk_mask;
@@ -579,7 +580,19 @@
 		i2c.en_data_mask = data_mask;
 		i2c.y_clk_mask = clk_mask;
 		i2c.y_data_mask = data_mask;
+	} else if ((ddc_line == RADEON_GPIOPAD_MASK) ||
+		   (ddc_line == RADEON_MDGPIO_MASK)) {
+		/* default gpiopad masks */
+		i2c.mask_clk_mask = (0x20 << 8);
+		i2c.mask_data_mask = 0x80;
+		i2c.a_clk_mask = (0x20 << 8);
+		i2c.a_data_mask = 0x80;
+		i2c.en_clk_mask = (0x20 << 8);
+		i2c.en_data_mask = 0x80;
+		i2c.y_clk_mask = (0x20 << 8);
+		i2c.y_data_mask = 0x80;
 	} else {
+		/* default masks for ddc pads */
 		i2c.mask_clk_mask = RADEON_GPIO_EN_1;
 		i2c.mask_data_mask = RADEON_GPIO_EN_0;
 		i2c.a_clk_mask = RADEON_GPIO_A_1;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_connectors.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_connectors.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_connectors.c	2010-11-21 23:40:11.052178476 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_connectors.c	2010-11-21 23:40:16.626099607 +0000
@@ -1008,9 +1008,21 @@
 static int radeon_dp_get_modes(struct drm_connector *connector)
 {
 	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+	struct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;
 	int ret;
 
+	if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+		if (!radeon_dig_connector->edp_on)
+			atombios_set_edp_panel_power(connector,
+						     ATOM_TRANSMITTER_ACTION_POWER_ON);
+	}
 	ret = radeon_ddc_get_modes(radeon_connector);
+	if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+		if (!radeon_dig_connector->edp_on)
+			atombios_set_edp_panel_power(connector,
+						     ATOM_TRANSMITTER_ACTION_POWER_OFF);
+	}
+
 	return ret;
 }
 
@@ -1029,8 +1041,14 @@
 	if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
 		/* eDP is always DP */
 		radeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+		if (!radeon_dig_connector->edp_on)
+			atombios_set_edp_panel_power(connector,
+						     ATOM_TRANSMITTER_ACTION_POWER_ON);
 		if (radeon_dp_getdpcd(radeon_connector))
 			ret = connector_status_connected;
+		if (!radeon_dig_connector->edp_on)
+			atombios_set_edp_panel_power(connector,
+						     ATOM_TRANSMITTER_ACTION_POWER_OFF);
 	} else {
 		radeon_dig_connector->dp_sink_type = radeon_dp_getsinktype(radeon_connector);
 		if (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_device.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_device.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_device.c	2010-11-21 23:40:11.052178476 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_device.c	2010-11-21 23:40:16.626099607 +0000
@@ -180,7 +180,7 @@
 	int r;
 
 	if (rdev->wb.wb_obj == NULL) {
-		r = radeon_bo_create(rdev, NULL, RADEON_GPU_PAGE_SIZE, true,
+		r = radeon_bo_create(rdev, NULL, RADEON_GPU_PAGE_SIZE, PAGE_SIZE, true,
 				RADEON_GEM_DOMAIN_GTT, &rdev->wb.wb_obj);
 		if (r) {
 			dev_warn(rdev->dev, "(%d) create WB bo failed\n", r);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_encoders.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_encoders.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_encoders.c	2010-11-21 23:40:11.053165423 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_encoders.c	2010-11-21 23:40:16.627096742 +0000
@@ -176,6 +176,7 @@
 		return false;
 	}
 }
+
 void
 radeon_link_encoder_connector(struct drm_device *dev)
 {
@@ -228,6 +229,27 @@
 	return NULL;
 }
 
+struct drm_encoder *radeon_atom_get_external_encoder(struct drm_encoder *encoder)
+{
+	struct drm_device *dev = encoder->dev;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct drm_encoder *other_encoder;
+	struct radeon_encoder *other_radeon_encoder;
+
+	if (radeon_encoder->is_ext_encoder)
+		return NULL;
+
+	list_for_each_entry(other_encoder, &dev->mode_config.encoder_list, head) {
+		if (other_encoder == encoder)
+			continue;
+		other_radeon_encoder = to_radeon_encoder(other_encoder);
+		if (other_radeon_encoder->is_ext_encoder &&
+		    (radeon_encoder->devices & other_radeon_encoder->devices))
+			return other_encoder;
+	}
+	return NULL;
+}
+
 void radeon_panel_mode_fixup(struct drm_encoder *encoder,
 			     struct drm_display_mode *adjusted_mode)
 {
@@ -426,52 +448,49 @@
 
 }
 
+union dvo_encoder_control {
+	ENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION ext_tmds;
+	DVO_ENCODER_CONTROL_PS_ALLOCATION dvo;
+	DVO_ENCODER_CONTROL_PS_ALLOCATION_V3 dvo_v3;
+};
+
 void
-atombios_external_tmds_setup(struct drm_encoder *encoder, int action)
+atombios_dvo_setup(struct drm_encoder *encoder, int action)
 {
 	struct drm_device *dev = encoder->dev;
 	struct radeon_device *rdev = dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-	ENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION args;
-	int index = 0;
+	union dvo_encoder_control args;
+	int index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);
 
 	memset(&args, 0, sizeof(args));
 
-	index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);
-
-	args.sXTmdsEncoder.ucEnable = action;
-
-	if (radeon_encoder->pixel_clock > 165000)
-		args.sXTmdsEncoder.ucMisc = PANEL_ENCODER_MISC_DUAL;
-
-	/*if (pScrn->rgbBits == 8)*/
-	args.sXTmdsEncoder.ucMisc |= (1 << 1);
-
-	atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
-
-}
-
-static void
-atombios_ddia_setup(struct drm_encoder *encoder, int action)
-{
-	struct drm_device *dev = encoder->dev;
-	struct radeon_device *rdev = dev->dev_private;
-	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-	DVO_ENCODER_CONTROL_PS_ALLOCATION args;
-	int index = 0;
-
-	memset(&args, 0, sizeof(args));
+	if (ASIC_IS_DCE3(rdev)) {
+		/* DCE3+ */
+		args.dvo_v3.ucAction = action;
+		args.dvo_v3.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
+		args.dvo_v3.ucDVOConfig = 0; /* XXX */
+	} else if (ASIC_IS_DCE2(rdev)) {
+		/* DCE2 (pre-DCE3 R6xx, RS600/690/740 */
+		args.dvo.sDVOEncoder.ucAction = action;
+		args.dvo.sDVOEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
+		/* DFP1, CRT1, TV1 depending on the type of port */
+		args.dvo.sDVOEncoder.ucDeviceType = ATOM_DEVICE_DFP1_INDEX;
 
-	index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);
+		if (radeon_encoder->pixel_clock > 165000)
+			args.dvo.sDVOEncoder.usDevAttr.sDigAttrib.ucAttribute |= PANEL_ENCODER_MISC_DUAL;
+	} else {
+		/* R4xx, R5xx */
+		args.ext_tmds.sXTmdsEncoder.ucEnable = action;
 
-	args.sDVOEncoder.ucAction = action;
-	args.sDVOEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
+		if (radeon_encoder->pixel_clock > 165000)
+			args.ext_tmds.sXTmdsEncoder.ucMisc |= PANEL_ENCODER_MISC_DUAL;
 
-	if (radeon_encoder->pixel_clock > 165000)
-		args.sDVOEncoder.usDevAttr.sDigAttrib.ucAttribute = PANEL_ENCODER_MISC_DUAL;
+		/*if (pScrn->rgbBits == 8)*/
+		args.ext_tmds.sXTmdsEncoder.ucMisc |= ATOM_PANEL_MISC_888RGB;
+	}
 
 	atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
-
 }
 
 union lvds_encoder_control {
@@ -532,14 +551,14 @@
 				if (dig->lcd_misc & ATOM_PANEL_MISC_DUAL)
 					args.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;
 				if (dig->lcd_misc & ATOM_PANEL_MISC_888RGB)
-					args.v1.ucMisc |= (1 << 1);
+					args.v1.ucMisc |= ATOM_PANEL_MISC_888RGB;
 			} else {
 				if (dig->linkb)
 					args.v1.ucMisc |= PANEL_ENCODER_MISC_TMDS_LINKB;
 				if (radeon_encoder->pixel_clock > 165000)
 					args.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;
 				/*if (pScrn->rgbBits == 8) */
-				args.v1.ucMisc |= (1 << 1);
+				args.v1.ucMisc |= ATOM_PANEL_MISC_888RGB;
 			}
 			break;
 		case 2:
@@ -595,6 +614,7 @@
 int
 atombios_get_encoder_mode(struct drm_encoder *encoder)
 {
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct drm_device *dev = encoder->dev;
 	struct radeon_device *rdev = dev->dev_private;
 	struct drm_connector *connector;
@@ -602,9 +622,20 @@
 	struct radeon_connector_atom_dig *dig_connector;
 
 	connector = radeon_get_connector_for_encoder(encoder);
-	if (!connector)
-		return 0;
-
+	if (!connector) {
+		switch (radeon_encoder->encoder_id) {
+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
+		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
+		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
+			return ATOM_ENCODER_MODE_DVI;
+		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
+		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
+		default:
+			return ATOM_ENCODER_MODE_CRT;
+		}
+	}
 	radeon_connector = to_radeon_connector(connector);
 
 	switch (connector->connector_type) {
@@ -834,6 +865,9 @@
 	memset(&args, 0, sizeof(args));
 
 	switch (radeon_encoder->encoder_id) {
+	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
+		index = GetIndexIntoMasterTable(COMMAND, DVOOutputControl);
+		break;
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
@@ -978,6 +1012,105 @@
 	atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
 }
 
+void
+atombios_set_edp_panel_power(struct drm_connector *connector, int action)
+{
+	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+	struct drm_device *dev = radeon_connector->base.dev;
+	struct radeon_device *rdev = dev->dev_private;
+	union dig_transmitter_control args;
+	int index = GetIndexIntoMasterTable(COMMAND, UNIPHYTransmitterControl);
+	uint8_t frev, crev;
+
+	if (connector->connector_type != DRM_MODE_CONNECTOR_eDP)
+		return;
+
+	if (!ASIC_IS_DCE4(rdev))
+		return;
+
+	if ((action != ATOM_TRANSMITTER_ACTION_POWER_ON) ||
+	    (action != ATOM_TRANSMITTER_ACTION_POWER_OFF))
+		return;
+
+	if (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))
+		return;
+
+	memset(&args, 0, sizeof(args));
+
+	args.v1.ucAction = action;
+
+	atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
+}
+
+union external_encoder_control {
+	EXTERNAL_ENCODER_CONTROL_PS_ALLOCATION v1;
+};
+
+static void
+atombios_external_encoder_setup(struct drm_encoder *encoder,
+				struct drm_encoder *ext_encoder,
+				int action)
+{
+	struct drm_device *dev = encoder->dev;
+	struct radeon_device *rdev = dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	union external_encoder_control args;
+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
+	int index = GetIndexIntoMasterTable(COMMAND, ExternalEncoderControl);
+	u8 frev, crev;
+	int dp_clock = 0;
+	int dp_lane_count = 0;
+	int connector_object_id = 0;
+
+	if (connector) {
+		struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+		struct radeon_connector_atom_dig *dig_connector =
+			radeon_connector->con_priv;
+
+		dp_clock = dig_connector->dp_clock;
+		dp_lane_count = dig_connector->dp_lane_count;
+		connector_object_id =
+			(radeon_connector->connector_object_id & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;
+	}
+
+	memset(&args, 0, sizeof(args));
+
+	if (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))
+		return;
+
+	switch (frev) {
+	case 1:
+		/* no params on frev 1 */
+		break;
+	case 2:
+		switch (crev) {
+		case 1:
+		case 2:
+			args.v1.sDigEncoder.ucAction = action;
+			args.v1.sDigEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);
+			args.v1.sDigEncoder.ucEncoderMode = atombios_get_encoder_mode(encoder);
+
+			if (args.v1.sDigEncoder.ucEncoderMode == ATOM_ENCODER_MODE_DP) {
+				if (dp_clock == 270000)
+					args.v1.sDigEncoder.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;
+				args.v1.sDigEncoder.ucLaneNum = dp_lane_count;
+			} else if (radeon_encoder->pixel_clock > 165000)
+				args.v1.sDigEncoder.ucLaneNum = 8;
+			else
+				args.v1.sDigEncoder.ucLaneNum = 4;
+			break;
+		default:
+			DRM_ERROR("Unknown table version: %d, %d\n", frev, crev);
+			return;
+		}
+		break;
+	default:
+		DRM_ERROR("Unknown table version: %d, %d\n", frev, crev);
+		return;
+	}
+	atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
+}
+
 static void
 atombios_yuv_setup(struct drm_encoder *encoder, bool enable)
 {
@@ -1021,6 +1154,7 @@
 	struct drm_device *dev = encoder->dev;
 	struct radeon_device *rdev = dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct drm_encoder *ext_encoder = radeon_atom_get_external_encoder(encoder);
 	DISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION args;
 	int index = 0;
 	bool is_dig = false;
@@ -1043,9 +1177,14 @@
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DVO1:
 	case ENCODER_OBJECT_ID_INTERNAL_DDI:
-	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
 		index = GetIndexIntoMasterTable(COMMAND, DVOOutputControl);
 		break;
+	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
+		if (ASIC_IS_DCE3(rdev))
+			is_dig = true;
+		else
+			index = GetIndexIntoMasterTable(COMMAND, DVOOutputControl);
+		break;
 	case ENCODER_OBJECT_ID_INTERNAL_LVDS:
 		index = GetIndexIntoMasterTable(COMMAND, LCD1OutputControl);
 		break;
@@ -1082,34 +1221,85 @@
 			if (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_DP) {
 				struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 
+				if (connector &&
+				    (connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {
+					struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+					struct radeon_connector_atom_dig *radeon_dig_connector =
+						radeon_connector->con_priv;
+					atombios_set_edp_panel_power(connector,
+								     ATOM_TRANSMITTER_ACTION_POWER_ON);
+					radeon_dig_connector->edp_on = true;
+				}
 				dp_link_train(encoder, connector);
 				if (ASIC_IS_DCE4(rdev))
 					atombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_ON);
 			}
+			if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
+				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLON, 0, 0);
 			break;
 		case DRM_MODE_DPMS_STANDBY:
 		case DRM_MODE_DPMS_SUSPEND:
 		case DRM_MODE_DPMS_OFF:
 			atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_DISABLE_OUTPUT, 0, 0);
 			if (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_DP) {
+				struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
+
 				if (ASIC_IS_DCE4(rdev))
 					atombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_OFF);
+				if (connector &&
+				    (connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {
+					struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+					struct radeon_connector_atom_dig *radeon_dig_connector =
+						radeon_connector->con_priv;
+					atombios_set_edp_panel_power(connector,
+								     ATOM_TRANSMITTER_ACTION_POWER_OFF);
+					radeon_dig_connector->edp_on = false;
+				}
 			}
+			if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
+				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);
 			break;
 		}
 	} else {
 		switch (mode) {
 		case DRM_MODE_DPMS_ON:
 			args.ucAction = ATOM_ENABLE;
+			atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
+			if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
+				args.ucAction = ATOM_LCD_BLON;
+				atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
+			}
 			break;
 		case DRM_MODE_DPMS_STANDBY:
 		case DRM_MODE_DPMS_SUSPEND:
 		case DRM_MODE_DPMS_OFF:
 			args.ucAction = ATOM_DISABLE;
+			atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
+			if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
+				args.ucAction = ATOM_LCD_BLOFF;
+				atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
+			}
 			break;
 		}
-		atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
 	}
+
+	if (ext_encoder) {
+		int action;
+
+		switch (mode) {
+		case DRM_MODE_DPMS_ON:
+		default:
+			action = ATOM_ENABLE;
+			break;
+		case DRM_MODE_DPMS_STANDBY:
+		case DRM_MODE_DPMS_SUSPEND:
+		case DRM_MODE_DPMS_OFF:
+			action = ATOM_DISABLE;
+			break;
+		}
+		atombios_external_encoder_setup(encoder, ext_encoder, action);
+	}
+
 	radeon_atombios_encoder_dpms_scratch_regs(encoder, (mode == DRM_MODE_DPMS_ON) ? true : false);
 
 }
@@ -1242,7 +1432,7 @@
 		break;
 	default:
 		DRM_ERROR("Unknown table version: %d, %d\n", frev, crev);
-		break;
+		return;
 	}
 
 	atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
@@ -1357,6 +1547,7 @@
 	struct drm_device *dev = encoder->dev;
 	struct radeon_device *rdev = dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct drm_encoder *ext_encoder = radeon_atom_get_external_encoder(encoder);
 
 	radeon_encoder->pixel_clock = adjusted_mode->clock;
 
@@ -1400,11 +1591,9 @@
 		}
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DDI:
-		atombios_ddia_setup(encoder, ATOM_ENABLE);
-		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DVO1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
-		atombios_external_tmds_setup(encoder, ATOM_ENABLE);
+		atombios_dvo_setup(encoder, ATOM_ENABLE);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DAC1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
@@ -1419,6 +1608,11 @@
 		}
 		break;
 	}
+
+	if (ext_encoder) {
+		atombios_external_encoder_setup(encoder, ext_encoder, ATOM_ENABLE);
+	}
+
 	atombios_apply_encoder_quirks(encoder, adjusted_mode);
 
 	if (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_HDMI) {
@@ -1595,11 +1789,9 @@
 		}
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DDI:
-		atombios_ddia_setup(encoder, ATOM_DISABLE);
-		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DVO1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
-		atombios_external_tmds_setup(encoder, ATOM_DISABLE);
+		atombios_dvo_setup(encoder, ATOM_DISABLE);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_DAC1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
@@ -1621,6 +1813,53 @@
 	radeon_encoder->active_device = 0;
 }
 
+/* these are handled by the primary encoders */
+static void radeon_atom_ext_prepare(struct drm_encoder *encoder)
+{
+
+}
+
+static void radeon_atom_ext_commit(struct drm_encoder *encoder)
+{
+
+}
+
+static void
+radeon_atom_ext_mode_set(struct drm_encoder *encoder,
+			 struct drm_display_mode *mode,
+			 struct drm_display_mode *adjusted_mode)
+{
+
+}
+
+static void radeon_atom_ext_disable(struct drm_encoder *encoder)
+{
+
+}
+
+static void
+radeon_atom_ext_dpms(struct drm_encoder *encoder, int mode)
+{
+
+}
+
+static bool radeon_atom_ext_mode_fixup(struct drm_encoder *encoder,
+				       struct drm_display_mode *mode,
+				       struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static const struct drm_encoder_helper_funcs radeon_atom_ext_helper_funcs = {
+	.dpms = radeon_atom_ext_dpms,
+	.mode_fixup = radeon_atom_ext_mode_fixup,
+	.prepare = radeon_atom_ext_prepare,
+	.mode_set = radeon_atom_ext_mode_set,
+	.commit = radeon_atom_ext_commit,
+	.disable = radeon_atom_ext_disable,
+	/* no detect for TMDS/LVDS yet */
+};
+
 static const struct drm_encoder_helper_funcs radeon_atom_dig_helper_funcs = {
 	.dpms = radeon_atom_encoder_dpms,
 	.mode_fixup = radeon_atom_mode_fixup,
@@ -1730,6 +1969,7 @@
 	radeon_encoder->devices = supported_device;
 	radeon_encoder->rmx_type = RMX_OFF;
 	radeon_encoder->underscan_type = UNDERSCAN_OFF;
+	radeon_encoder->is_ext_encoder = false;
 
 	switch (radeon_encoder->encoder_id) {
 	case ENCODER_OBJECT_ID_INTERNAL_LVDS:
@@ -1771,6 +2011,9 @@
 			radeon_encoder->rmx_type = RMX_FULL;
 			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);
 			radeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);
+		} else if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);
+			radeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);
 		} else {
 			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);
 			radeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);
@@ -1779,5 +2022,22 @@
 		}
 		drm_encoder_helper_add(encoder, &radeon_atom_dig_helper_funcs);
 		break;
+	case ENCODER_OBJECT_ID_SI170B:
+	case ENCODER_OBJECT_ID_CH7303:
+	case ENCODER_OBJECT_ID_EXTERNAL_SDVOA:
+	case ENCODER_OBJECT_ID_EXTERNAL_SDVOB:
+	case ENCODER_OBJECT_ID_TITFP513:
+	case ENCODER_OBJECT_ID_VT1623:
+	case ENCODER_OBJECT_ID_HDMI_SI1930:
+		/* these are handled by the primary encoders */
+		radeon_encoder->is_ext_encoder = true;
+		if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);
+		else if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);
+		else
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);
+		drm_encoder_helper_add(encoder, &radeon_atom_ext_helper_funcs);
+		break;
 	}
 }
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_gart.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_gart.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_gart.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_gart.c	2010-11-21 23:40:16.628071070 +0000
@@ -79,8 +79,8 @@
 
 	if (rdev->gart.table.vram.robj == NULL) {
 		r = radeon_bo_create(rdev, NULL, rdev->gart.table_size,
-					true, RADEON_GEM_DOMAIN_VRAM,
-					&rdev->gart.table.vram.robj);
+				     PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,
+				     &rdev->gart.table.vram.robj);
 		if (r) {
 			return r;
 		}
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_gem.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_gem.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_gem.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_gem.c	2010-11-21 23:40:16.628071070 +0000
@@ -67,7 +67,7 @@
 	if (alignment < PAGE_SIZE) {
 		alignment = PAGE_SIZE;
 	}
-	r = radeon_bo_create(rdev, gobj, size, kernel, initial_domain, &robj);
+	r = radeon_bo_create(rdev, gobj, size, alignment, kernel, initial_domain, &robj);
 	if (r) {
 		if (r != -ERESTARTSYS)
 			DRM_ERROR("Failed to allocate GEM object (%d, %d, %u, %d)\n",
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_i2c.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_i2c.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_i2c.c	2010-11-21 23:40:11.053165423 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_i2c.c	2010-11-21 23:40:16.628071070 +0000
@@ -896,7 +896,8 @@
 	     ((rdev->family <= CHIP_RS480) ||
 	      ((rdev->family >= CHIP_RV515) && (rdev->family <= CHIP_R580))))) {
 		/* set the radeon hw i2c adapter */
-		sprintf(i2c->adapter.name, "Radeon i2c hw bus %s", name);
+		snprintf(i2c->adapter.name, sizeof(i2c->adapter.name),
+			 "Radeon i2c hw bus %s", name);
 		i2c->adapter.algo = &radeon_i2c_algo;
 		ret = i2c_add_adapter(&i2c->adapter);
 		if (ret) {
@@ -905,7 +906,8 @@
 		}
 	} else {
 		/* set the radeon bit adapter */
-		sprintf(i2c->adapter.name, "Radeon i2c bit bus %s", name);
+		snprintf(i2c->adapter.name, sizeof(i2c->adapter.name),
+			 "Radeon i2c bit bus %s", name);
 		i2c->adapter.algo_data = &i2c->algo.bit;
 		i2c->algo.bit.pre_xfer = pre_xfer;
 		i2c->algo.bit.post_xfer = post_xfer;
@@ -946,6 +948,8 @@
 	i2c->rec = *rec;
 	i2c->adapter.owner = THIS_MODULE;
 	i2c->dev = dev;
+	snprintf(i2c->adapter.name, sizeof(i2c->adapter.name),
+		 "Radeon aux bus %s", name);
 	i2c_set_adapdata(&i2c->adapter, i2c);
 	i2c->adapter.algo_data = &i2c->algo.dp;
 	i2c->algo.dp.aux_ch = radeon_dp_i2c_aux_ch;
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_irq.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_irq.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_irq.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_irq.c	2010-11-21 23:40:16.628071070 +0000
@@ -76,7 +76,7 @@
 		default:
 			DRM_ERROR("tried to enable vblank on non-existent crtc %d\n",
 				  crtc);
-			return EINVAL;
+			return -EINVAL;
 		}
 	} else {
 		switch (crtc) {
@@ -89,7 +89,7 @@
 		default:
 			DRM_ERROR("tried to enable vblank on non-existent crtc %d\n",
 				  crtc);
-			return EINVAL;
+			return -EINVAL;
 		}
 	}
 
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_legacy_encoders.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_legacy_encoders.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_legacy_encoders.c	2010-11-21 23:40:16.629084863 +0000
@@ -670,7 +670,7 @@
 
 	if (rdev->is_atom_bios) {
 		radeon_encoder->pixel_clock = adjusted_mode->clock;
-		atombios_external_tmds_setup(encoder, ATOM_ENABLE);
+		atombios_dvo_setup(encoder, ATOM_ENABLE);
 		fp2_gen_cntl = RREG32(RADEON_FP2_GEN_CNTL);
 	} else {
 		fp2_gen_cntl = RREG32(RADEON_FP2_GEN_CNTL);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_mode.h linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_mode.h
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_mode.h	2010-11-21 23:40:11.054072143 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_mode.h	2010-11-21 23:40:16.629084863 +0000
@@ -375,6 +375,7 @@
 	int hdmi_config_offset;
 	int hdmi_audio_workaround;
 	int hdmi_buffer_status;
+	bool is_ext_encoder;
 };
 
 struct radeon_connector_atom_dig {
@@ -385,6 +386,7 @@
 	u8 dp_sink_type;
 	int dp_clock;
 	int dp_lane_count;
+	bool edp_on;
 };
 
 struct radeon_gpio_rec {
@@ -523,9 +525,10 @@
 struct drm_encoder *radeon_encoder_legacy_tv_dac_add(struct drm_device *dev, int bios_index, int with_tv);
 struct drm_encoder *radeon_encoder_legacy_tmds_int_add(struct drm_device *dev, int bios_index);
 struct drm_encoder *radeon_encoder_legacy_tmds_ext_add(struct drm_device *dev, int bios_index);
-extern void atombios_external_tmds_setup(struct drm_encoder *encoder, int action);
+extern void atombios_dvo_setup(struct drm_encoder *encoder, int action);
 extern void atombios_digital_setup(struct drm_encoder *encoder, int action);
 extern int atombios_get_encoder_mode(struct drm_encoder *encoder);
+extern void atombios_set_edp_panel_power(struct drm_connector *connector, int action);
 extern void radeon_encoder_set_active_device(struct drm_encoder *encoder);
 
 extern void radeon_crtc_load_lut(struct drm_crtc *crtc);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_object.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_object.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_object.c	2010-11-21 23:40:11.054072143 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_object.c	2010-11-21 23:40:16.629084863 +0000
@@ -86,11 +86,12 @@
 }
 
 int radeon_bo_create(struct radeon_device *rdev, struct drm_gem_object *gobj,
-			unsigned long size, bool kernel, u32 domain,
-			struct radeon_bo **bo_ptr)
+		     unsigned long size, int byte_align, bool kernel, u32 domain,
+		     struct radeon_bo **bo_ptr)
 {
 	struct radeon_bo *bo;
 	enum ttm_bo_type type;
+	int page_align = roundup(byte_align, PAGE_SIZE) >> PAGE_SHIFT;
 	int r;
 
 	if (unlikely(rdev->mman.bdev.dev_mapping == NULL)) {
@@ -115,7 +116,7 @@
 	/* Kernel allocation are uninterruptible */
 	mutex_lock(&rdev->vram_mutex);
 	r = ttm_bo_init(&rdev->mman.bdev, &bo->tbo, size, type,
-			&bo->placement, 0, 0, !kernel, NULL, size,
+			&bo->placement, page_align, 0, !kernel, NULL, size,
 			&radeon_ttm_bo_destroy);
 	mutex_unlock(&rdev->vram_mutex);
 	if (unlikely(r != 0)) {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_object.h linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_object.h
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_object.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_object.h	2010-11-21 23:40:16.629084863 +0000
@@ -137,9 +137,10 @@
 }
 
 extern int radeon_bo_create(struct radeon_device *rdev,
-				struct drm_gem_object *gobj, unsigned long size,
-				bool kernel, u32 domain,
-				struct radeon_bo **bo_ptr);
+			    struct drm_gem_object *gobj, unsigned long size,
+			    int byte_align,
+			    bool kernel, u32 domain,
+			    struct radeon_bo **bo_ptr);
 extern int radeon_bo_kmap(struct radeon_bo *bo, void **ptr);
 extern void radeon_bo_kunmap(struct radeon_bo *bo);
 extern void radeon_bo_unref(struct radeon_bo **bo);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_ring.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_ring.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_ring.c	2010-11-21 23:40:11.055178683 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_ring.c	2010-11-21 23:40:16.630100977 +0000
@@ -176,8 +176,8 @@
 	INIT_LIST_HEAD(&rdev->ib_pool.bogus_ib);
 	/* Allocate 1M object buffer */
 	r = radeon_bo_create(rdev, NULL,  RADEON_IB_POOL_SIZE*64*1024,
-				true, RADEON_GEM_DOMAIN_GTT,
-				&rdev->ib_pool.robj);
+			     PAGE_SIZE, true, RADEON_GEM_DOMAIN_GTT,
+			     &rdev->ib_pool.robj);
 	if (r) {
 		DRM_ERROR("radeon: failed to ib pool (%d).\n", r);
 		return r;
@@ -332,7 +332,7 @@
 	rdev->cp.ring_size = ring_size;
 	/* Allocate ring buffer */
 	if (rdev->cp.ring_obj == NULL) {
-		r = radeon_bo_create(rdev, NULL, rdev->cp.ring_size, true,
+		r = radeon_bo_create(rdev, NULL, rdev->cp.ring_size, PAGE_SIZE, true,
 					RADEON_GEM_DOMAIN_GTT,
 					&rdev->cp.ring_obj);
 		if (r) {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_test.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_test.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_test.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_test.c	2010-11-21 23:40:16.630100977 +0000
@@ -52,7 +52,7 @@
 		goto out_cleanup;
 	}
 
-	r = radeon_bo_create(rdev, NULL, size, true, RADEON_GEM_DOMAIN_VRAM,
+	r = radeon_bo_create(rdev, NULL, size, PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,
 				&vram_obj);
 	if (r) {
 		DRM_ERROR("Failed to create VRAM object\n");
@@ -71,7 +71,7 @@
 		void **gtt_start, **gtt_end;
 		void **vram_start, **vram_end;
 
-		r = radeon_bo_create(rdev, NULL, size, true,
+		r = radeon_bo_create(rdev, NULL, size, PAGE_SIZE, true,
 					 RADEON_GEM_DOMAIN_GTT, gtt_obj + i);
 		if (r) {
 			DRM_ERROR("Failed to create GTT object %d\n", i);
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_ttm.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_ttm.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/radeon_ttm.c	2010-11-21 23:40:11.055178683 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/radeon_ttm.c	2010-11-21 23:40:16.630100977 +0000
@@ -529,7 +529,7 @@
 		DRM_ERROR("Failed initializing VRAM heap.\n");
 		return r;
 	}
-	r = radeon_bo_create(rdev, NULL, 256 * 1024, true,
+	r = radeon_bo_create(rdev, NULL, 256 * 1024, PAGE_SIZE, true,
 				RADEON_GEM_DOMAIN_VRAM,
 				&rdev->stollen_vga_memory);
 	if (r) {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/radeon/rv770.c linux-2.6.37-rc3/drivers/gpu/drm/radeon/rv770.c
--- linux-2.6.37-rc2/drivers/gpu/drm/radeon/rv770.c	2010-11-21 23:40:11.056093733 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/radeon/rv770.c	2010-11-21 23:40:16.631100535 +0000
@@ -915,8 +915,8 @@
 
 	if (rdev->vram_scratch.robj == NULL) {
 		r = radeon_bo_create(rdev, NULL, RADEON_GPU_PAGE_SIZE,
-					true, RADEON_GEM_DOMAIN_VRAM,
-					&rdev->vram_scratch.robj);
+				     PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,
+				     &rdev->vram_scratch.robj);
 		if (r) {
 			return r;
 		}
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/ttm/ttm_bo.c linux-2.6.37-rc3/drivers/gpu/drm/ttm/ttm_bo.c
--- linux-2.6.37-rc2/drivers/gpu/drm/ttm/ttm_bo.c	2010-11-21 23:40:11.057178517 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/ttm/ttm_bo.c	2010-11-21 23:40:16.632070294 +0000
@@ -224,6 +224,9 @@
 	int ret;
 
 	while (unlikely(atomic_cmpxchg(&bo->reserved, 0, 1) != 0)) {
+		/**
+		 * Deadlock avoidance for multi-bo reserving.
+		 */
 		if (use_sequence && bo->seq_valid &&
 			(sequence - bo->val_seq < (1 << 31))) {
 			return -EAGAIN;
@@ -241,6 +244,14 @@
 	}
 
 	if (use_sequence) {
+		/**
+		 * Wake up waiters that may need to recheck for deadlock,
+		 * if we decreased the sequence number.
+		 */
+		if (unlikely((bo->val_seq - sequence < (1 << 31))
+			     || !bo->seq_valid))
+			wake_up_all(&bo->event_queue);
+
 		bo->val_seq = sequence;
 		bo->seq_valid = true;
 	} else {
diff -urN linux-2.6.37-rc2/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c linux-2.6.37-rc3/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c
--- linux-2.6.37-rc2/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c	2010-11-21 23:40:11.060178918 +0000
+++ linux-2.6.37-rc3/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c	2010-11-21 23:40:16.635070581 +0000
@@ -862,7 +862,7 @@
 			      &vmw_vram_sys_placement, true,
 			      &vmw_user_dmabuf_destroy);
 	if (unlikely(ret != 0))
-		return ret;
+		goto out_no_dmabuf;
 
 	tmp = ttm_bo_reference(&vmw_user_bo->dma.base);
 	ret = ttm_base_object_init(vmw_fpriv(file_priv)->tfile,
@@ -870,19 +870,21 @@
 				   false,
 				   ttm_buffer_type,
 				   &vmw_user_dmabuf_release, NULL);
-	if (unlikely(ret != 0)) {
-		ttm_bo_unref(&tmp);
-	} else {
+	if (unlikely(ret != 0))
+		goto out_no_base_object;
+	else {
 		rep->handle = vmw_user_bo->base.hash.key;
 		rep->map_handle = vmw_user_bo->dma.base.addr_space_offset;
 		rep->cur_gmr_id = vmw_user_bo->base.hash.key;
 		rep->cur_gmr_offset = 0;
 	}
-	ttm_bo_unref(&tmp);
 
+out_no_base_object:
+	ttm_bo_unref(&tmp);
+out_no_dmabuf:
 	ttm_read_unlock(&vmaster->lock);
 
-	return 0;
+	return ret;
 }
 
 int vmw_dmabuf_unref_ioctl(struct drm_device *dev, void *data,
diff -urN linux-2.6.37-rc2/drivers/hid/hidraw.c linux-2.6.37-rc3/drivers/hid/hidraw.c
--- linux-2.6.37-rc2/drivers/hid/hidraw.c	2010-11-21 23:40:11.066108368 +0000
+++ linux-2.6.37-rc3/drivers/hid/hidraw.c	2010-11-21 23:40:16.641071047 +0000
@@ -32,7 +32,6 @@
 #include <linux/hid.h>
 #include <linux/mutex.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 
 #include <linux/hidraw.h>
 
diff -urN linux-2.6.37-rc2/drivers/hid/usbhid/hiddev.c linux-2.6.37-rc3/drivers/hid/usbhid/hiddev.c
--- linux-2.6.37-rc2/drivers/hid/usbhid/hiddev.c	2010-11-21 23:40:11.067178226 +0000
+++ linux-2.6.37-rc3/drivers/hid/usbhid/hiddev.c	2010-11-21 23:40:16.641071047 +0000
@@ -29,7 +29,6 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/input.h>
 #include <linux/usb.h>
 #include <linux/hid.h>
diff -urN linux-2.6.37-rc2/drivers/infiniband/hw/ipath/ipath_file_ops.c linux-2.6.37-rc3/drivers/infiniband/hw/ipath/ipath_file_ops.c
--- linux-2.6.37-rc2/drivers/infiniband/hw/ipath/ipath_file_ops.c	2010-11-21 23:40:11.119168473 +0000
+++ linux-2.6.37-rc3/drivers/infiniband/hw/ipath/ipath_file_ops.c	2010-11-21 23:40:16.686089592 +0000
@@ -40,7 +40,6 @@
 #include <linux/highmem.h>
 #include <linux/io.h>
 #include <linux/jiffies.h>
-#include <linux/smp_lock.h>
 #include <asm/pgtable.h>
 
 #include "ipath_kernel.h"
diff -urN linux-2.6.37-rc2/drivers/infiniband/ulp/srp/ib_srp.c linux-2.6.37-rc3/drivers/infiniband/ulp/srp/ib_srp.c
--- linux-2.6.37-rc2/drivers/infiniband/ulp/srp/ib_srp.c	2010-11-21 23:40:11.125168906 +0000
+++ linux-2.6.37-rc3/drivers/infiniband/ulp/srp/ib_srp.c	2010-11-21 23:40:16.692064755 +0000
@@ -1123,7 +1123,7 @@
 	}
 }
 
-static int srp_queuecommand(struct scsi_cmnd *scmnd,
+static int srp_queuecommand_lck(struct scsi_cmnd *scmnd,
 			    void (*done)(struct scsi_cmnd *))
 {
 	struct srp_target_port *target = host_to_target(scmnd->device->host);
@@ -1196,6 +1196,8 @@
 	return SCSI_MLQUEUE_HOST_BUSY;
 }
 
+static DEF_SCSI_QCMD(srp_queuecommand)
+
 static int srp_alloc_iu_bufs(struct srp_target_port *target)
 {
 	int i;
diff -urN linux-2.6.37-rc2/drivers/input/input.c linux-2.6.37-rc3/drivers/input/input.c
--- linux-2.6.37-rc2/drivers/input/input.c	2010-11-21 23:40:11.126094280 +0000
+++ linux-2.6.37-rc3/drivers/input/input.c	2010-11-21 23:40:16.693064325 +0000
@@ -24,7 +24,6 @@
 #include <linux/device.h>
 #include <linux/mutex.h>
 #include <linux/rcupdate.h>
-#include <linux/smp_lock.h>
 #include "input-compat.h"
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
@@ -753,7 +752,7 @@
 	if (index >= dev->keycodemax)
 		return -EINVAL;
 
-	if (dev->keycodesize < sizeof(dev->keycode) &&
+	if (dev->keycodesize < sizeof(ke->keycode) &&
 			(ke->keycode >> (dev->keycodesize * 8)))
 		return -EINVAL;
 
diff -urN linux-2.6.37-rc2/drivers/input/serio/serio_raw.c linux-2.6.37-rc3/drivers/input/serio/serio_raw.c
--- linux-2.6.37-rc2/drivers/input/serio/serio_raw.c	2010-11-21 23:40:11.132168804 +0000
+++ linux-2.6.37-rc3/drivers/input/serio/serio_raw.c	2010-11-21 23:40:16.699065435 +0000
@@ -11,7 +11,6 @@
 
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/poll.h>
 #include <linux/module.h>
 #include <linux/serio.h>
diff -urN linux-2.6.37-rc2/drivers/input/tablet/aiptek.c linux-2.6.37-rc3/drivers/input/tablet/aiptek.c
--- linux-2.6.37-rc2/drivers/input/tablet/aiptek.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/input/tablet/aiptek.c	2010-11-21 23:40:16.699065435 +0000
@@ -1097,7 +1097,7 @@
 }
 
 static DEVICE_ATTR(pointer_mode,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletPointerMode, store_tabletPointerMode);
 
 /***********************************************************************
@@ -1134,7 +1134,7 @@
 }
 
 static DEVICE_ATTR(coordinate_mode,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletCoordinateMode, store_tabletCoordinateMode);
 
 /***********************************************************************
@@ -1176,7 +1176,7 @@
 }
 
 static DEVICE_ATTR(tool_mode,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletToolMode, store_tabletToolMode);
 
 /***********************************************************************
@@ -1219,7 +1219,7 @@
 }
 
 static DEVICE_ATTR(xtilt,
-		   S_IRUGO | S_IWUGO, show_tabletXtilt, store_tabletXtilt);
+		   S_IRUGO | S_IWUSR, show_tabletXtilt, store_tabletXtilt);
 
 /***********************************************************************
  * support routines for the 'ytilt' file. Note that this file
@@ -1261,7 +1261,7 @@
 }
 
 static DEVICE_ATTR(ytilt,
-		   S_IRUGO | S_IWUGO, show_tabletYtilt, store_tabletYtilt);
+		   S_IRUGO | S_IWUSR, show_tabletYtilt, store_tabletYtilt);
 
 /***********************************************************************
  * support routines for the 'jitter' file. Note that this file
@@ -1288,7 +1288,7 @@
 }
 
 static DEVICE_ATTR(jitter,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletJitterDelay, store_tabletJitterDelay);
 
 /***********************************************************************
@@ -1317,7 +1317,7 @@
 }
 
 static DEVICE_ATTR(delay,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletProgrammableDelay, store_tabletProgrammableDelay);
 
 /***********************************************************************
@@ -1406,7 +1406,7 @@
 }
 
 static DEVICE_ATTR(stylus_upper,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletStylusUpper, store_tabletStylusUpper);
 
 /***********************************************************************
@@ -1437,7 +1437,7 @@
 }
 
 static DEVICE_ATTR(stylus_lower,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletStylusLower, store_tabletStylusLower);
 
 /***********************************************************************
@@ -1475,7 +1475,7 @@
 }
 
 static DEVICE_ATTR(mouse_left,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletMouseLeft, store_tabletMouseLeft);
 
 /***********************************************************************
@@ -1505,7 +1505,7 @@
 }
 
 static DEVICE_ATTR(mouse_middle,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletMouseMiddle, store_tabletMouseMiddle);
 
 /***********************************************************************
@@ -1535,7 +1535,7 @@
 }
 
 static DEVICE_ATTR(mouse_right,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletMouseRight, store_tabletMouseRight);
 
 /***********************************************************************
@@ -1567,7 +1567,7 @@
 }
 
 static DEVICE_ATTR(wheel,
-		   S_IRUGO | S_IWUGO, show_tabletWheel, store_tabletWheel);
+		   S_IRUGO | S_IWUSR, show_tabletWheel, store_tabletWheel);
 
 /***********************************************************************
  * support routines for the 'execute' file. Note that this file
@@ -1600,7 +1600,7 @@
 }
 
 static DEVICE_ATTR(execute,
-		   S_IRUGO | S_IWUGO, show_tabletExecute, store_tabletExecute);
+		   S_IRUGO | S_IWUSR, show_tabletExecute, store_tabletExecute);
 
 /***********************************************************************
  * support routines for the 'odm_code' file. Note that this file
diff -urN linux-2.6.37-rc2/drivers/media/dvb/dvb-core/dvb_ca_en50221.c linux-2.6.37-rc3/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
--- linux-2.6.37-rc2/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2010-11-21 23:40:11.168285401 +0000
+++ linux-2.6.37-rc3/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2010-11-21 23:40:16.731061098 +0000
@@ -36,7 +36,6 @@
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <linux/kthread.h>
 
 #include "dvb_ca_en50221.h"
diff -urN linux-2.6.37-rc2/drivers/media/dvb/dvb-core/dvb_frontend.c linux-2.6.37-rc3/drivers/media/dvb/dvb-core/dvb_frontend.c
--- linux-2.6.37-rc2/drivers/media/dvb/dvb-core/dvb_frontend.c	2010-11-21 23:40:11.169261738 +0000
+++ linux-2.6.37-rc3/drivers/media/dvb/dvb-core/dvb_frontend.c	2010-11-21 23:40:16.731061098 +0000
@@ -36,7 +36,6 @@
 #include <linux/list.h>
 #include <linux/freezer.h>
 #include <linux/jiffies.h>
-#include <linux/smp_lock.h>
 #include <linux/kthread.h>
 #include <asm/processor.h>
 
diff -urN linux-2.6.37-rc2/drivers/media/dvb/ngene/ngene-core.c linux-2.6.37-rc3/drivers/media/dvb/ngene/ngene-core.c
--- linux-2.6.37-rc2/drivers/media/dvb/ngene/ngene-core.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/media/dvb/ngene/ngene-core.c	2010-11-21 23:40:16.740061369 +0000
@@ -34,7 +34,6 @@
 #include <linux/io.h>
 #include <asm/div64.h>
 #include <linux/pci.h>
-#include <linux/smp_lock.h>
 #include <linux/timer.h>
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
diff -urN linux-2.6.37-rc2/drivers/media/dvb/ngene/ngene-dvb.c linux-2.6.37-rc3/drivers/media/dvb/ngene/ngene-dvb.c
--- linux-2.6.37-rc2/drivers/media/dvb/ngene/ngene-dvb.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/media/dvb/ngene/ngene-dvb.c	2010-11-21 23:40:16.740061369 +0000
@@ -35,7 +35,6 @@
 #include <linux/io.h>
 #include <asm/div64.h>
 #include <linux/pci.h>
-#include <linux/smp_lock.h>
 #include <linux/timer.h>
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
diff -urN linux-2.6.37-rc2/drivers/media/dvb/ngene/ngene-i2c.c linux-2.6.37-rc3/drivers/media/dvb/ngene/ngene-i2c.c
--- linux-2.6.37-rc2/drivers/media/dvb/ngene/ngene-i2c.c	2010-11-21 23:40:11.178236011 +0000
+++ linux-2.6.37-rc3/drivers/media/dvb/ngene/ngene-i2c.c	2010-11-21 23:40:16.740061369 +0000
@@ -37,7 +37,6 @@
 #include <asm/div64.h>
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
-#include <linux/smp_lock.h>
 #include <linux/timer.h>
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
diff -urN linux-2.6.37-rc2/drivers/media/radio/radio-mr800.c linux-2.6.37-rc3/drivers/media/radio/radio-mr800.c
--- linux-2.6.37-rc2/drivers/media/radio/radio-mr800.c	2010-11-21 23:40:11.181236003 +0000
+++ linux-2.6.37-rc3/drivers/media/radio/radio-mr800.c	2010-11-21 23:40:16.743063348 +0000
@@ -58,7 +58,6 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/input.h>
 #include <linux/videodev2.h>
 #include <media/v4l2-device.h>
diff -urN linux-2.6.37-rc2/drivers/media/radio/si470x/radio-si470x.h linux-2.6.37-rc3/drivers/media/radio/si470x/radio-si470x.h
--- linux-2.6.37-rc2/drivers/media/radio/si470x/radio-si470x.h	2010-11-21 23:40:11.182236160 +0000
+++ linux-2.6.37-rc3/drivers/media/radio/si470x/radio-si470x.h	2010-11-21 23:40:16.744063591 +0000
@@ -31,7 +31,6 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/input.h>
 #include <linux/version.h>
 #include <linux/videodev2.h>
diff -urN linux-2.6.37-rc2/drivers/media/video/bt8xx/bttv-driver.c linux-2.6.37-rc3/drivers/media/video/bt8xx/bttv-driver.c
--- linux-2.6.37-rc2/drivers/media/video/bt8xx/bttv-driver.c	2010-11-21 23:40:11.186076098 +0000
+++ linux-2.6.37-rc3/drivers/media/video/bt8xx/bttv-driver.c	2010-11-21 23:40:16.747063254 +0000
@@ -42,7 +42,6 @@
 #include <linux/fs.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/kdev_t.h>
 #include "bttvp.h"
diff -urN linux-2.6.37-rc2/drivers/media/video/cx88/cx88-blackbird.c linux-2.6.37-rc3/drivers/media/video/cx88/cx88-blackbird.c
--- linux-2.6.37-rc2/drivers/media/video/cx88/cx88-blackbird.c	2010-11-21 23:40:11.204109610 +0000
+++ linux-2.6.37-rc3/drivers/media/video/cx88/cx88-blackbird.c	2010-11-21 23:40:16.763060688 +0000
@@ -33,7 +33,6 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/firmware.h>
-#include <linux/smp_lock.h>
 #include <media/v4l2-common.h>
 #include <media/v4l2-ioctl.h>
 #include <media/cx2341x.h>
diff -urN linux-2.6.37-rc2/drivers/media/video/cx88/cx88-video.c linux-2.6.37-rc3/drivers/media/video/cx88/cx88-video.c
--- linux-2.6.37-rc2/drivers/media/video/cx88/cx88-video.c	2010-11-21 23:40:11.206072997 +0000
+++ linux-2.6.37-rc3/drivers/media/video/cx88/cx88-video.c	2010-11-21 23:40:16.766061133 +0000
@@ -31,7 +31,6 @@
 #include <linux/kmod.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
diff -urN linux-2.6.37-rc2/drivers/media/video/pwc/pwc-if.c linux-2.6.37-rc3/drivers/media/video/pwc/pwc-if.c
--- linux-2.6.37-rc2/drivers/media/video/pwc/pwc-if.c	2010-11-21 23:40:11.236074374 +0000
+++ linux-2.6.37-rc3/drivers/media/video/pwc/pwc-if.c	2010-11-21 23:40:16.792060092 +0000
@@ -62,7 +62,6 @@
 #include <linux/module.h>
 #include <linux/poll.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #ifdef CONFIG_USB_PWC_INPUT_EVDEV
 #include <linux/usb/input.h>
 #endif
diff -urN linux-2.6.37-rc2/drivers/media/video/s2255drv.c linux-2.6.37-rc3/drivers/media/video/s2255drv.c
--- linux-2.6.37-rc2/drivers/media/video/s2255drv.c	2010-11-21 23:40:11.237168690 +0000
+++ linux-2.6.37-rc3/drivers/media/video/s2255drv.c	2010-11-21 23:40:16.793060257 +0000
@@ -49,7 +49,6 @@
 #include <linux/videodev2.h>
 #include <linux/version.h>
 #include <linux/mm.h>
-#include <linux/smp_lock.h>
 #include <media/videobuf-vmalloc.h>
 #include <media/v4l2-common.h>
 #include <media/v4l2-device.h>
diff -urN linux-2.6.37-rc2/drivers/media/video/saa7134/saa7134-empress.c linux-2.6.37-rc3/drivers/media/video/saa7134/saa7134-empress.c
--- linux-2.6.37-rc2/drivers/media/video/saa7134/saa7134-empress.c	2010-11-21 23:40:11.244094209 +0000
+++ linux-2.6.37-rc3/drivers/media/video/saa7134/saa7134-empress.c	2010-11-21 23:40:16.799063885 +0000
@@ -21,7 +21,6 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/smp_lock.h>
 #include <linux/delay.h>
 
 #include "saa7134-reg.h"
diff -urN linux-2.6.37-rc2/drivers/media/video/saa7164/saa7164.h linux-2.6.37-rc3/drivers/media/video/saa7164/saa7164.h
--- linux-2.6.37-rc2/drivers/media/video/saa7164/saa7164.h	2010-11-21 23:40:11.249168520 +0000
+++ linux-2.6.37-rc3/drivers/media/video/saa7164/saa7164.h	2010-11-21 23:40:16.804063912 +0000
@@ -58,7 +58,6 @@
 #include <media/tveeprom.h>
 #include <media/videobuf-dma-sg.h>
 #include <media/videobuf-dvb.h>
-#include <linux/smp_lock.h>
 #include <dvb_demux.h>
 #include <dvb_frontend.h>
 #include <dvb_net.h>
diff -urN linux-2.6.37-rc2/drivers/media/video/usbvision/usbvision-video.c linux-2.6.37-rc3/drivers/media/video/usbvision/usbvision-video.c
--- linux-2.6.37-rc2/drivers/media/video/usbvision/usbvision-video.c	2010-11-21 23:40:11.257169212 +0000
+++ linux-2.6.37-rc3/drivers/media/video/usbvision/usbvision-video.c	2010-11-21 23:40:16.811061565 +0000
@@ -50,7 +50,6 @@
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/mm.h>
 #include <linux/highmem.h>
 #include <linux/vmalloc.h>
diff -urN linux-2.6.37-rc2/drivers/media/video/v4l2-compat-ioctl32.c linux-2.6.37-rc3/drivers/media/video/v4l2-compat-ioctl32.c
--- linux-2.6.37-rc2/drivers/media/video/v4l2-compat-ioctl32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/media/video/v4l2-compat-ioctl32.c	2010-11-21 23:40:16.814062673 +0000
@@ -18,7 +18,6 @@
 #include <linux/videodev.h>
 #include <linux/videodev2.h>
 #include <linux/module.h>
-#include <linux/smp_lock.h>
 #include <media/v4l2-ioctl.h>
 
 #ifdef CONFIG_COMPAT
diff -urN linux-2.6.37-rc2/drivers/message/fusion/mptfc.c linux-2.6.37-rc3/drivers/message/fusion/mptfc.c
--- linux-2.6.37-rc2/drivers/message/fusion/mptfc.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/message/fusion/mptfc.c	2010-11-21 23:40:16.821086540 +0000
@@ -97,8 +97,7 @@
 
 static int mptfc_target_alloc(struct scsi_target *starget);
 static int mptfc_slave_alloc(struct scsi_device *sdev);
-static int mptfc_qcmd(struct scsi_cmnd *SCpnt,
-		      void (*done)(struct scsi_cmnd *));
+static int mptfc_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt);
 static void mptfc_target_destroy(struct scsi_target *starget);
 static void mptfc_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout);
 static void __devexit mptfc_remove(struct pci_dev *pdev);
@@ -650,7 +649,7 @@
 }
 
 static int
-mptfc_qcmd(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+mptfc_qcmd_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	struct mptfc_rport_info	*ri;
 	struct fc_rport	*rport = starget_to_rport(scsi_target(SCpnt->device));
@@ -681,6 +680,8 @@
 	return mptscsih_qcmd(SCpnt,done);
 }
 
+static DEF_SCSI_QCMD(mptfc_qcmd)
+
 /*
  *	mptfc_display_port_link_speed - displaying link speed
  *	@ioc: Pointer to MPT_ADAPTER structure
diff -urN linux-2.6.37-rc2/drivers/message/fusion/mptsas.c linux-2.6.37-rc3/drivers/message/fusion/mptsas.c
--- linux-2.6.37-rc2/drivers/message/fusion/mptsas.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/message/fusion/mptsas.c	2010-11-21 23:40:16.821086540 +0000
@@ -1889,7 +1889,7 @@
 }
 
 static int
-mptsas_qcmd(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+mptsas_qcmd_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	MPT_SCSI_HOST	*hd;
 	MPT_ADAPTER	*ioc;
@@ -1913,6 +1913,8 @@
 	return mptscsih_qcmd(SCpnt,done);
 }
 
+static DEF_SCSI_QCMD(mptsas_qcmd)
+
 /**
  *	mptsas_mptsas_eh_timed_out - resets the scsi_cmnd timeout
  *		if the device under question is currently in the
diff -urN linux-2.6.37-rc2/drivers/message/fusion/mptspi.c linux-2.6.37-rc3/drivers/message/fusion/mptspi.c
--- linux-2.6.37-rc2/drivers/message/fusion/mptspi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/message/fusion/mptspi.c	2010-11-21 23:40:16.822088905 +0000
@@ -780,7 +780,7 @@
 }
 
 static int
-mptspi_qcmd(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+mptspi_qcmd_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	struct _MPT_SCSI_HOST *hd = shost_priv(SCpnt->device->host);
 	VirtDevice	*vdevice = SCpnt->device->hostdata;
@@ -805,6 +805,8 @@
 	return mptscsih_qcmd(SCpnt,done);
 }
 
+static DEF_SCSI_QCMD(mptspi_qcmd)
+
 static void mptspi_slave_destroy(struct scsi_device *sdev)
 {
 	struct scsi_target *starget = scsi_target(sdev);
diff -urN linux-2.6.37-rc2/drivers/message/i2o/i2o_scsi.c linux-2.6.37-rc3/drivers/message/i2o/i2o_scsi.c
--- linux-2.6.37-rc2/drivers/message/i2o/i2o_scsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/message/i2o/i2o_scsi.c	2010-11-21 23:40:16.822088905 +0000
@@ -506,7 +506,7 @@
  *	Locks: takes the controller lock on error path only
  */
 
-static int i2o_scsi_queuecommand(struct scsi_cmnd *SCpnt,
+static int i2o_scsi_queuecommand_lck(struct scsi_cmnd *SCpnt,
 				 void (*done) (struct scsi_cmnd *))
 {
 	struct i2o_controller *c;
@@ -688,7 +688,9 @@
 
       exit:
 	return rc;
-};
+}
+
+static DEF_SCSI_QCMD(i2o_scsi_queuecommand)
 
 /**
  *	i2o_scsi_abort - abort a running command
diff -urN linux-2.6.37-rc2/drivers/net/3c59x.c linux-2.6.37-rc3/drivers/net/3c59x.c
--- linux-2.6.37-rc2/drivers/net/3c59x.c	2010-11-21 23:40:11.304070590 +0000
+++ linux-2.6.37-rc3/drivers/net/3c59x.c	2010-11-21 23:40:16.855063134 +0000
@@ -699,7 +699,8 @@
 #define DEVICE_PCI(dev) NULL
 #endif
 
-#define VORTEX_PCI(vp) (((vp)->gendev) ? DEVICE_PCI((vp)->gendev) : NULL)
+#define VORTEX_PCI(vp)							\
+	((struct pci_dev *) (((vp)->gendev) ? DEVICE_PCI((vp)->gendev) : NULL))
 
 #ifdef CONFIG_EISA
 #define DEVICE_EISA(dev) (((dev)->bus == &eisa_bus_type) ? to_eisa_device((dev)) : NULL)
@@ -707,7 +708,8 @@
 #define DEVICE_EISA(dev) NULL
 #endif
 
-#define VORTEX_EISA(vp) (((vp)->gendev) ? DEVICE_EISA((vp)->gendev) : NULL)
+#define VORTEX_EISA(vp)							\
+	((struct eisa_device *) (((vp)->gendev) ? DEVICE_EISA((vp)->gendev) : NULL))
 
 /* The action to take with a media selection timer tick.
    Note that we deviate from the 3Com order by checking 10base2 before AUI.
diff -urN linux-2.6.37-rc2/drivers/net/8139cp.c linux-2.6.37-rc3/drivers/net/8139cp.c
--- linux-2.6.37-rc2/drivers/net/8139cp.c	2010-11-21 23:40:11.305168457 +0000
+++ linux-2.6.37-rc3/drivers/net/8139cp.c	2010-11-21 23:40:16.855063134 +0000
@@ -490,13 +490,11 @@
 {
 	unsigned int protocol = (status >> 16) & 0x3;
 
-	if (likely((protocol == RxProtoTCP) && (!(status & TCPFail))))
+	if (((protocol == RxProtoTCP) && !(status & TCPFail)) ||
+	    ((protocol == RxProtoUDP) && !(status & UDPFail)))
 		return 1;
-	else if ((protocol == RxProtoUDP) && (!(status & UDPFail)))
-		return 1;
-	else if ((protocol == RxProtoIP) && (!(status & IPFail)))
-		return 1;
-	return 0;
+	else
+		return 0;
 }
 
 static int cp_rx_poll(struct napi_struct *napi, int budget)
diff -urN linux-2.6.37-rc2/drivers/net/benet/be_main.c linux-2.6.37-rc3/drivers/net/benet/be_main.c
--- linux-2.6.37-rc2/drivers/net/benet/be_main.c	2010-11-21 23:40:11.314075370 +0000
+++ linux-2.6.37-rc3/drivers/net/benet/be_main.c	2010-11-21 23:40:16.864063761 +0000
@@ -2458,6 +2458,12 @@
 	int status, i = 0, num_imgs = 0;
 	const u8 *p;
 
+	if (!netif_running(adapter->netdev)) {
+		dev_err(&adapter->pdev->dev,
+			"Firmware load not allowed (interface is down)\n");
+		return -EPERM;
+	}
+
 	strcpy(fw_file, func);
 
 	status = request_firmware(&fw, fw_file, &adapter->pdev->dev);
diff -urN linux-2.6.37-rc2/drivers/net/bnx2x/bnx2x_main.c linux-2.6.37-rc3/drivers/net/bnx2x/bnx2x_main.c
--- linux-2.6.37-rc2/drivers/net/bnx2x/bnx2x_main.c	2010-11-21 23:40:11.344234389 +0000
+++ linux-2.6.37-rc3/drivers/net/bnx2x/bnx2x_main.c	2010-11-21 23:40:16.891062501 +0000
@@ -9064,7 +9064,7 @@
 	default:
 		pr_err("Unknown board_type (%ld), aborting\n",
 			   ent->driver_data);
-		return ENODEV;
+		return -ENODEV;
 	}
 
 	cid_count += CNIC_CONTEXT_USE;
diff -urN linux-2.6.37-rc2/drivers/net/bonding/bond_main.c linux-2.6.37-rc3/drivers/net/bonding/bond_main.c
--- linux-2.6.37-rc2/drivers/net/bonding/bond_main.c	2010-11-21 23:40:11.349262674 +0000
+++ linux-2.6.37-rc3/drivers/net/bonding/bond_main.c	2010-11-21 23:40:16.894063616 +0000
@@ -878,8 +878,10 @@
 	rcu_read_lock();
 	in_dev = __in_dev_get_rcu(dev);
 	if (in_dev) {
+		read_lock(&in_dev->mc_list_lock);
 		for (im = in_dev->mc_list; im; im = im->next)
 			ip_mc_rejoin_group(im);
+		read_unlock(&in_dev->mc_list_lock);
 	}
 
 	rcu_read_unlock();
diff -urN linux-2.6.37-rc2/drivers/net/caif/caif_spi.c linux-2.6.37-rc3/drivers/net/caif/caif_spi.c
--- linux-2.6.37-rc2/drivers/net/caif/caif_spi.c	2010-11-21 23:40:11.350235236 +0000
+++ linux-2.6.37-rc3/drivers/net/caif/caif_spi.c	2010-11-21 23:40:16.896063788 +0000
@@ -635,8 +635,8 @@
 
 	ndev = alloc_netdev(sizeof(struct cfspi),
 			"cfspi%d", cfspi_setup);
-	if (!dev)
-		return -ENODEV;
+	if (!ndev)
+		return -ENOMEM;
 
 	cfspi = netdev_priv(ndev);
 	netif_stop_queue(ndev);
diff -urN linux-2.6.37-rc2/drivers/net/gianfar.c linux-2.6.37-rc3/drivers/net/gianfar.c
--- linux-2.6.37-rc2/drivers/net/gianfar.c	2010-11-21 23:40:11.379169133 +0000
+++ linux-2.6.37-rc3/drivers/net/gianfar.c	2010-11-21 23:40:16.921060453 +0000
@@ -577,11 +577,10 @@
 			irq_of_parse_and_map(np, 1);
 		priv->gfargrp[priv->num_grps].interruptError =
 			irq_of_parse_and_map(np,2);
-		if (priv->gfargrp[priv->num_grps].interruptTransmit < 0 ||
-			priv->gfargrp[priv->num_grps].interruptReceive < 0 ||
-			priv->gfargrp[priv->num_grps].interruptError < 0) {
+		if (priv->gfargrp[priv->num_grps].interruptTransmit == NO_IRQ ||
+		    priv->gfargrp[priv->num_grps].interruptReceive  == NO_IRQ ||
+		    priv->gfargrp[priv->num_grps].interruptError    == NO_IRQ)
 			return -EINVAL;
-		}
 	}
 
 	priv->gfargrp[priv->num_grps].grp_id = priv->num_grps;
diff -urN linux-2.6.37-rc2/drivers/net/ipg.c linux-2.6.37-rc3/drivers/net/ipg.c
--- linux-2.6.37-rc2/drivers/net/ipg.c	2010-11-21 23:40:11.387168544 +0000
+++ linux-2.6.37-rc3/drivers/net/ipg.c	2010-11-21 23:40:16.928061173 +0000
@@ -88,16 +88,14 @@
 	"IC PLUS IP1000 1000/100/10 based NIC",
 	"Sundance Technology ST2021 based NIC",
 	"Tamarack Microelectronics TC9020/9021 based NIC",
-	"Tamarack Microelectronics TC9020/9021 based NIC",
 	"D-Link NIC IP1000A"
 };
 
 static DEFINE_PCI_DEVICE_TABLE(ipg_pci_tbl) = {
 	{ PCI_VDEVICE(SUNDANCE,	0x1023), 0 },
 	{ PCI_VDEVICE(SUNDANCE,	0x2021), 1 },
-	{ PCI_VDEVICE(SUNDANCE,	0x1021), 2 },
-	{ PCI_VDEVICE(DLINK,	0x9021), 3 },
-	{ PCI_VDEVICE(DLINK,	0x4020), 4 },
+	{ PCI_VDEVICE(DLINK,	0x9021), 2 },
+	{ PCI_VDEVICE(DLINK,	0x4020), 3 },
 	{ 0, }
 };
 
diff -urN linux-2.6.37-rc2/drivers/net/r8169.c linux-2.6.37-rc3/drivers/net/r8169.c
--- linux-2.6.37-rc2/drivers/net/r8169.c	2010-11-21 23:40:11.429168777 +0000
+++ linux-2.6.37-rc3/drivers/net/r8169.c	2010-11-21 23:40:16.967085995 +0000
@@ -4440,8 +4440,7 @@
 	u32 status = opts1 & RxProtoMask;
 
 	if (((status == RxProtoTCP) && !(opts1 & TCPFail)) ||
-	    ((status == RxProtoUDP) && !(opts1 & UDPFail)) ||
-	    ((status == RxProtoIP) && !(opts1 & IPFail)))
+	    ((status == RxProtoUDP) && !(opts1 & UDPFail)))
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 	else
 		skb_checksum_none_assert(skb);
diff -urN linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/eeprom_9287.c linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/eeprom_9287.c
--- linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/eeprom_9287.c	2010-11-21 23:40:11.492168518 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/eeprom_9287.c	2010-11-21 23:40:17.025060754 +0000
@@ -37,7 +37,7 @@
 	int addr, eep_start_loc;
 	eep_data = (u16 *)eep;
 
-	if (ah->hw_version.devid == 0x7015)
+	if (AR9287_HTC_DEVID(ah))
 		eep_start_loc = AR9287_HTC_EEP_START_LOC;
 	else
 		eep_start_loc = AR9287_EEP_START_LOC;
diff -urN linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/hif_usb.c linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/hif_usb.c
--- linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/hif_usb.c	2010-11-21 23:40:11.493168810 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/hif_usb.c	2010-11-21 23:40:17.025060754 +0000
@@ -36,8 +36,13 @@
 	{ USB_DEVICE(0x13D3, 0x3327) }, /* Azurewave */
 	{ USB_DEVICE(0x13D3, 0x3328) }, /* Azurewave */
 	{ USB_DEVICE(0x13D3, 0x3346) }, /* IMC Networks */
+	{ USB_DEVICE(0x13D3, 0x3348) }, /* Azurewave */
+	{ USB_DEVICE(0x13D3, 0x3349) }, /* Azurewave */
+	{ USB_DEVICE(0x13D3, 0x3350) }, /* Azurewave */
 	{ USB_DEVICE(0x04CA, 0x4605) }, /* Liteon */
 	{ USB_DEVICE(0x083A, 0xA704) }, /* SMC Networks */
+	{ USB_DEVICE(0x040D, 0x3801) }, /* VIA */
+	{ USB_DEVICE(0x1668, 0x1200) }, /* Verizon */
 	{ },
 };
 
@@ -806,6 +811,8 @@
 	case 0x7010:
 	case 0x7015:
 	case 0x9018:
+	case 0xA704:
+	case 0x1200:
 		firm_offset = AR7010_FIRMWARE_TEXT;
 		break;
 	default:
@@ -928,6 +935,8 @@
 	case 0x7010:
 	case 0x7015:
 	case 0x9018:
+	case 0xA704:
+	case 0x1200:
 		if (le16_to_cpu(udev->descriptor.bcdDevice) == 0x0202)
 			hif_dev->fw_name = FIRMWARE_AR7010_1_1;
 		else
diff -urN linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/htc_drv_init.c linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/htc_drv_init.c
--- linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/htc_drv_init.c	2010-11-21 23:40:11.494169153 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/htc_drv_init.c	2010-11-21 23:40:17.026060980 +0000
@@ -249,6 +249,8 @@
 	case 0x7010:
 	case 0x7015:
 	case 0x9018:
+	case 0xA704:
+	case 0x1200:
 		priv->htc->credits = 45;
 		break;
 	default:
diff -urN linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c
--- linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c	2010-11-21 23:40:11.494169153 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c	2010-11-21 23:40:17.026060980 +0000
@@ -121,7 +121,7 @@
 			tx_hdr.data_type = ATH9K_HTC_NORMAL;
 		}
 
-		if (ieee80211_is_data(fc)) {
+		if (ieee80211_is_data_qos(fc)) {
 			qc = ieee80211_get_qos_ctl(hdr);
 			tx_hdr.tidno = qc[0] & IEEE80211_QOS_CTL_TID_MASK;
 		}
diff -urN linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/init.c linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/init.c
--- linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/init.c	2010-11-21 23:40:11.496091346 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/init.c	2010-11-21 23:40:17.028056190 +0000
@@ -817,8 +817,6 @@
 
 	ath9k_ps_wakeup(sc);
 
-	pm_qos_remove_request(&ath9k_pm_qos_req);
-
 	wiphy_rfkill_stop_polling(sc->hw->wiphy);
 	ath_deinit_leds(sc);
 
@@ -832,6 +830,7 @@
 	}
 
 	ieee80211_unregister_hw(hw);
+	pm_qos_remove_request(&ath9k_pm_qos_req);
 	ath_rx_cleanup(sc);
 	ath_tx_cleanup(sc);
 	ath9k_deinit_softc(sc);
diff -urN linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/reg.h linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/reg.h
--- linux-2.6.37-rc2/drivers/net/wireless/ath/ath9k/reg.h	2010-11-21 23:40:11.499168495 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/ath/ath9k/reg.h	2010-11-21 23:40:17.030097011 +0000
@@ -866,7 +866,13 @@
 #define AR_DEVID_7010(_ah) \
 	(((_ah)->hw_version.devid == 0x7010) || \
 	 ((_ah)->hw_version.devid == 0x7015) || \
-	 ((_ah)->hw_version.devid == 0x9018))
+	 ((_ah)->hw_version.devid == 0x9018) || \
+	 ((_ah)->hw_version.devid == 0xA704) || \
+	 ((_ah)->hw_version.devid == 0x1200))
+
+#define AR9287_HTC_DEVID(_ah) \
+	(((_ah)->hw_version.devid == 0x7015) || \
+	 ((_ah)->hw_version.devid == 0x1200))
 
 #define AR_RADIO_SREV_MAJOR                   0xf0
 #define AR_RAD5133_SREV_MAJOR                 0xc0
diff -urN linux-2.6.37-rc2/drivers/net/wireless/ath/carl9170/usb.c linux-2.6.37-rc3/drivers/net/wireless/ath/carl9170/usb.c
--- linux-2.6.37-rc2/drivers/net/wireless/ath/carl9170/usb.c	2010-11-21 23:40:11.506094476 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/ath/carl9170/usb.c	2010-11-21 23:40:17.037098524 +0000
@@ -553,12 +553,12 @@
 		usb_free_urb(urb);
 	}
 
-	ret = usb_wait_anchor_empty_timeout(&ar->tx_cmd, HZ);
+	ret = usb_wait_anchor_empty_timeout(&ar->tx_cmd, 1000);
 	if (ret == 0)
 		err = -ETIMEDOUT;
 
 	/* lets wait a while until the tx - queues are dried out */
-	ret = usb_wait_anchor_empty_timeout(&ar->tx_anch, HZ);
+	ret = usb_wait_anchor_empty_timeout(&ar->tx_anch, 1000);
 	if (ret == 0)
 		err = -ETIMEDOUT;
 
diff -urN linux-2.6.37-rc2/drivers/net/wireless/orinoco/orinoco_usb.c linux-2.6.37-rc3/drivers/net/wireless/orinoco/orinoco_usb.c
--- linux-2.6.37-rc2/drivers/net/wireless/orinoco/orinoco_usb.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/net/wireless/orinoco/orinoco_usb.c	2010-11-21 23:40:17.069089449 +0000
@@ -57,7 +57,6 @@
 #include <linux/fcntl.h>
 #include <linux/spinlock.h>
 #include <linux/list.h>
-#include <linux/smp_lock.h>
 #include <linux/usb.h>
 #include <linux/timer.h>
 
diff -urN linux-2.6.37-rc2/drivers/parisc/eisa_eeprom.c linux-2.6.37-rc3/drivers/parisc/eisa_eeprom.c
--- linux-2.6.37-rc2/drivers/parisc/eisa_eeprom.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/parisc/eisa_eeprom.c	2010-11-21 23:40:17.103101288 +0000
@@ -24,7 +24,6 @@
 #include <linux/kernel.h>
 #include <linux/miscdevice.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/fs.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
diff -urN linux-2.6.37-rc2/drivers/pci/pci-sysfs.c linux-2.6.37-rc3/drivers/pci/pci-sysfs.c
--- linux-2.6.37-rc2/drivers/pci/pci-sysfs.c	2010-11-21 23:40:11.583169265 +0000
+++ linux-2.6.37-rc3/drivers/pci/pci-sysfs.c	2010-11-21 23:40:17.107097164 +0000
@@ -715,7 +715,7 @@
 	nr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 	start = vma->vm_pgoff;
 	size = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;
-	pci_start = (mmap_api == PCI_MMAP_SYSFS) ?
+	pci_start = (mmap_api == PCI_MMAP_PROCFS) ?
 			pci_resource_start(pdev, resno) >> PAGE_SHIFT : 0;
 	if (start >= pci_start && start < pci_start + size &&
 			start + nr <= pci_start + size)
diff -urN linux-2.6.37-rc2/drivers/pci/proc.c linux-2.6.37-rc3/drivers/pci/proc.c
--- linux-2.6.37-rc2/drivers/pci/proc.c	2010-11-21 23:40:11.585102267 +0000
+++ linux-2.6.37-rc3/drivers/pci/proc.c	2010-11-21 23:40:17.108063995 +0000
@@ -10,7 +10,6 @@
 #include <linux/module.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-#include <linux/smp_lock.h>
 #include <linux/capability.h>
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
diff -urN linux-2.6.37-rc2/drivers/pnp/isapnp/proc.c linux-2.6.37-rc3/drivers/pnp/isapnp/proc.c
--- linux-2.6.37-rc2/drivers/pnp/isapnp/proc.c	2010-11-21 23:40:11.596083827 +0000
+++ linux-2.6.37-rc3/drivers/pnp/isapnp/proc.c	2010-11-21 23:40:17.119081533 +0000
@@ -21,7 +21,6 @@
 #include <linux/isapnp.h>
 #include <linux/proc_fs.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 
 extern struct pnp_protocol isapnp_protocol;
diff -urN linux-2.6.37-rc2/drivers/s390/block/dasd_eer.c linux-2.6.37-rc3/drivers/s390/block/dasd_eer.c
--- linux-2.6.37-rc2/drivers/s390/block/dasd_eer.c	2010-11-21 23:40:11.607168405 +0000
+++ linux-2.6.37-rc3/drivers/s390/block/dasd_eer.c	2010-11-21 23:40:17.129062334 +0000
@@ -17,7 +17,6 @@
 #include <linux/device.h>
 #include <linux/poll.h>
 #include <linux/mutex.h>
-#include <linux/smp_lock.h>
 #include <linux/err.h>
 #include <linux/slab.h>
 
diff -urN linux-2.6.37-rc2/drivers/s390/char/fs3270.c linux-2.6.37-rc3/drivers/s390/char/fs3270.c
--- linux-2.6.37-rc2/drivers/s390/char/fs3270.c	2010-11-21 23:40:11.607168405 +0000
+++ linux-2.6.37-rc3/drivers/s390/char/fs3270.c	2010-11-21 23:40:17.129062334 +0000
@@ -14,7 +14,6 @@
 #include <linux/list.h>
 #include <linux/slab.h>
 #include <linux/types.h>
-#include <linux/smp_lock.h>
 
 #include <asm/compat.h>
 #include <asm/ccwdev.h>
diff -urN linux-2.6.37-rc2/drivers/s390/char/tape_char.c linux-2.6.37-rc3/drivers/s390/char/tape_char.c
--- linux-2.6.37-rc2/drivers/s390/char/tape_char.c	2010-11-21 23:40:11.608168796 +0000
+++ linux-2.6.37-rc3/drivers/s390/char/tape_char.c	2010-11-21 23:40:17.130101643 +0000
@@ -17,7 +17,6 @@
 #include <linux/types.h>
 #include <linux/proc_fs.h>
 #include <linux/mtio.h>
-#include <linux/smp_lock.h>
 #include <linux/compat.h>
 
 #include <asm/uaccess.h>
diff -urN linux-2.6.37-rc2/drivers/s390/char/tape_core.c linux-2.6.37-rc3/drivers/s390/char/tape_core.c
--- linux-2.6.37-rc2/drivers/s390/char/tape_core.c	2010-11-21 23:40:11.609168430 +0000
+++ linux-2.6.37-rc3/drivers/s390/char/tape_core.c	2010-11-21 23:40:17.130101643 +0000
@@ -209,29 +209,79 @@
 	wake_up(&device->state_change_wq);
 }
 
+struct tape_med_state_work_data {
+	struct tape_device *device;
+	enum tape_medium_state state;
+	struct work_struct  work;
+};
+
+static void
+tape_med_state_work_handler(struct work_struct *work)
+{
+	static char env_state_loaded[] = "MEDIUM_STATE=LOADED";
+	static char env_state_unloaded[] = "MEDIUM_STATE=UNLOADED";
+	struct tape_med_state_work_data *p =
+		container_of(work, struct tape_med_state_work_data, work);
+	struct tape_device *device = p->device;
+	char *envp[] = { NULL, NULL };
+
+	switch (p->state) {
+	case MS_UNLOADED:
+		pr_info("%s: The tape cartridge has been successfully "
+			"unloaded\n", dev_name(&device->cdev->dev));
+		envp[0] = env_state_unloaded;
+		kobject_uevent_env(&device->cdev->dev.kobj, KOBJ_CHANGE, envp);
+		break;
+	case MS_LOADED:
+		pr_info("%s: A tape cartridge has been mounted\n",
+			dev_name(&device->cdev->dev));
+		envp[0] = env_state_loaded;
+		kobject_uevent_env(&device->cdev->dev.kobj, KOBJ_CHANGE, envp);
+		break;
+	default:
+		break;
+	}
+	tape_put_device(device);
+	kfree(p);
+}
+
+static void
+tape_med_state_work(struct tape_device *device, enum tape_medium_state state)
+{
+	struct tape_med_state_work_data *p;
+
+	p = kzalloc(sizeof(*p), GFP_ATOMIC);
+	if (p) {
+		INIT_WORK(&p->work, tape_med_state_work_handler);
+		p->device = tape_get_device(device);
+		p->state = state;
+		schedule_work(&p->work);
+	}
+}
+
 void
 tape_med_state_set(struct tape_device *device, enum tape_medium_state newstate)
 {
-	if (device->medium_state == newstate)
+	enum tape_medium_state oldstate;
+
+	oldstate = device->medium_state;
+	if (oldstate == newstate)
 		return;
+	device->medium_state = newstate;
 	switch(newstate){
 	case MS_UNLOADED:
 		device->tape_generic_status |= GMT_DR_OPEN(~0);
-		if (device->medium_state == MS_LOADED)
-			pr_info("%s: The tape cartridge has been successfully "
-				"unloaded\n", dev_name(&device->cdev->dev));
+		if (oldstate == MS_LOADED)
+			tape_med_state_work(device, MS_UNLOADED);
 		break;
 	case MS_LOADED:
 		device->tape_generic_status &= ~GMT_DR_OPEN(~0);
-		if (device->medium_state == MS_UNLOADED)
-			pr_info("%s: A tape cartridge has been mounted\n",
-				dev_name(&device->cdev->dev));
+		if (oldstate == MS_UNLOADED)
+			tape_med_state_work(device, MS_LOADED);
 		break;
 	default:
-		// print nothing
 		break;
 	}
-	device->medium_state = newstate;
 	wake_up(&device->state_change_wq);
 }
 
diff -urN linux-2.6.37-rc2/drivers/s390/char/vmlogrdr.c linux-2.6.37-rc3/drivers/s390/char/vmlogrdr.c
--- linux-2.6.37-rc2/drivers/s390/char/vmlogrdr.c	2010-11-21 23:40:11.609168430 +0000
+++ linux-2.6.37-rc3/drivers/s390/char/vmlogrdr.c	2010-11-21 23:40:17.131078116 +0000
@@ -30,7 +30,6 @@
 #include <linux/kmod.h>
 #include <linux/cdev.h>
 #include <linux/device.h>
-#include <linux/smp_lock.h>
 #include <linux/string.h>
 
 MODULE_AUTHOR
@@ -249,27 +248,25 @@
 	char cp_command[80];
 	char cp_response[160];
 	char *onoff, *qid_string;
+	int rc;
 
-	memset(cp_command, 0x00, sizeof(cp_command));
-	memset(cp_response, 0x00, sizeof(cp_response));
-
-        onoff = ((action == 1) ? "ON" : "OFF");
+	onoff = ((action == 1) ? "ON" : "OFF");
 	qid_string = ((recording_class_AB == 1) ? " QID * " : "");
 
-        /*
+	/*
 	 * The recording commands needs to be called with option QID
 	 * for guests that have previlege classes A or B.
 	 * Purging has to be done as separate step, because recording
 	 * can't be switched on as long as records are on the queue.
 	 * Doing both at the same time doesn't work.
 	 */
-
-	if (purge) {
+	if (purge && (action == 1)) {
+		memset(cp_command, 0x00, sizeof(cp_command));
+		memset(cp_response, 0x00, sizeof(cp_response));
 		snprintf(cp_command, sizeof(cp_command),
 			 "RECORDING %s PURGE %s",
 			 logptr->recording_name,
 			 qid_string);
-
 		cpcmd(cp_command, cp_response, sizeof(cp_response), NULL);
 	}
 
@@ -279,19 +276,33 @@
 		logptr->recording_name,
 		onoff,
 		qid_string);
-
 	cpcmd(cp_command, cp_response, sizeof(cp_response), NULL);
 	/* The recording command will usually answer with 'Command complete'
 	 * on success, but when the specific service was never connected
 	 * before then there might be an additional informational message
 	 * 'HCPCRC8072I Recording entry not found' before the
-         * 'Command complete'. So I use strstr rather then the strncmp.
+	 * 'Command complete'. So I use strstr rather then the strncmp.
 	 */
 	if (strstr(cp_response,"Command complete"))
-		return 0;
+		rc = 0;
 	else
-		return -EIO;
+		rc = -EIO;
+	/*
+	 * If we turn recording off, we have to purge any remaining records
+	 * afterwards, as a large number of queued records may impact z/VM
+	 * performance.
+	 */
+	if (purge && (action == 0)) {
+		memset(cp_command, 0x00, sizeof(cp_command));
+		memset(cp_response, 0x00, sizeof(cp_response));
+		snprintf(cp_command, sizeof(cp_command),
+			 "RECORDING %s PURGE %s",
+			 logptr->recording_name,
+			 qid_string);
+		cpcmd(cp_command, cp_response, sizeof(cp_response), NULL);
+	}
 
+	return rc;
 }
 
 
diff -urN linux-2.6.37-rc2/drivers/s390/char/vmur.c linux-2.6.37-rc3/drivers/s390/char/vmur.c
--- linux-2.6.37-rc2/drivers/s390/char/vmur.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/s390/char/vmur.c	2010-11-21 23:40:17.131078116 +0000
@@ -13,7 +13,6 @@
 
 #include <linux/cdev.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 
 #include <asm/uaccess.h>
 #include <asm/cio.h>
diff -urN linux-2.6.37-rc2/drivers/s390/cio/device.c linux-2.6.37-rc3/drivers/s390/cio/device.c
--- linux-2.6.37-rc2/drivers/s390/cio/device.c	2010-11-21 23:40:11.611168833 +0000
+++ linux-2.6.37-rc3/drivers/s390/cio/device.c	2010-11-21 23:40:17.133078793 +0000
@@ -1455,7 +1455,16 @@
 		break;
 	case IO_SCH_UNREG_ATTACH:
 	case IO_SCH_UNREG:
-		if (cdev)
+		if (!cdev)
+			break;
+		if (cdev->private->state == DEV_STATE_SENSE_ID) {
+			/*
+			 * Note: delayed work triggered by this event
+			 * and repeated calls to sch_event are synchronized
+			 * by the above check for work_pending(cdev).
+			 */
+			dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
+		} else
 			ccw_device_set_notoper(cdev);
 		break;
 	case IO_SCH_NOP:
diff -urN linux-2.6.37-rc2/drivers/s390/crypto/zcrypt_api.c linux-2.6.37-rc3/drivers/s390/crypto/zcrypt_api.c
--- linux-2.6.37-rc2/drivers/s390/crypto/zcrypt_api.c	2010-11-21 23:40:11.613168503 +0000
+++ linux-2.6.37-rc3/drivers/s390/crypto/zcrypt_api.c	2010-11-21 23:40:17.134075211 +0000
@@ -35,7 +35,6 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/compat.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <asm/atomic.h>
 #include <asm/uaccess.h>
diff -urN linux-2.6.37-rc2/drivers/s390/scsi/zfcp_scsi.c linux-2.6.37-rc3/drivers/s390/scsi/zfcp_scsi.c
--- linux-2.6.37-rc2/drivers/s390/scsi/zfcp_scsi.c	2010-11-21 23:40:11.619168215 +0000
+++ linux-2.6.37-rc3/drivers/s390/scsi/zfcp_scsi.c	2010-11-21 23:40:17.140079127 +0000
@@ -76,7 +76,7 @@
 	scpnt->scsi_done(scpnt);
 }
 
-static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
+static int zfcp_scsi_queuecommand_lck(struct scsi_cmnd *scpnt,
 				  void (*done) (struct scsi_cmnd *))
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
@@ -127,6 +127,8 @@
 	return ret;
 }
 
+static DEF_SCSI_QCMD(zfcp_scsi_queuecommand)
+
 static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 {
 	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));
diff -urN linux-2.6.37-rc2/drivers/scsi/3w-9xxx.c linux-2.6.37-rc3/drivers/scsi/3w-9xxx.c
--- linux-2.6.37-rc2/drivers/scsi/3w-9xxx.c	2010-11-21 23:40:11.620168115 +0000
+++ linux-2.6.37-rc3/drivers/scsi/3w-9xxx.c	2010-11-21 23:40:17.142097353 +0000
@@ -1765,7 +1765,7 @@
 } /* End twa_scsi_eh_reset() */
 
 /* This is the main scsi queue function to handle scsi opcodes */
-static int twa_scsi_queue(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+static int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	int request_id, retval;
 	TW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
@@ -1812,6 +1812,8 @@
 	return retval;
 } /* End twa_scsi_queue() */
 
+static DEF_SCSI_QCMD(twa_scsi_queue)
+
 /* This function hands scsi cdb's to the firmware */
 static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry *sglistarg)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/3w-sas.c linux-2.6.37-rc3/drivers/scsi/3w-sas.c
--- linux-2.6.37-rc2/drivers/scsi/3w-sas.c	2010-11-21 23:40:11.620168115 +0000
+++ linux-2.6.37-rc3/drivers/scsi/3w-sas.c	2010-11-21 23:40:17.142097353 +0000
@@ -1501,7 +1501,7 @@
 } /* End twl_scsi_eh_reset() */
 
 /* This is the main scsi queue function to handle scsi opcodes */
-static int twl_scsi_queue(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+static int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	int request_id, retval;
 	TW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
@@ -1536,6 +1536,8 @@
 	return retval;
 } /* End twl_scsi_queue() */
 
+static DEF_SCSI_QCMD(twl_scsi_queue)
+
 /* This function tells the controller to shut down */
 static void __twl_shutdown(TW_Device_Extension *tw_dev)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/3w-xxxx.c linux-2.6.37-rc3/drivers/scsi/3w-xxxx.c
--- linux-2.6.37-rc2/drivers/scsi/3w-xxxx.c	2010-11-21 23:40:11.621168654 +0000
+++ linux-2.6.37-rc3/drivers/scsi/3w-xxxx.c	2010-11-21 23:40:17.142097353 +0000
@@ -1947,7 +1947,7 @@
 } /* End tw_scsiop_test_unit_ready_complete() */
 
 /* This is the main scsi queue function to handle scsi opcodes */
-static int tw_scsi_queue(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *)) 
+static int tw_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	unsigned char *command = SCpnt->cmnd;
 	int request_id = 0;
@@ -2023,6 +2023,8 @@
 	return retval;
 } /* End tw_scsi_queue() */
 
+static DEF_SCSI_QCMD(tw_scsi_queue)
+
 /* This function is the interrupt service routine */
 static irqreturn_t tw_interrupt(int irq, void *dev_instance) 
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/53c700.c linux-2.6.37-rc3/drivers/scsi/53c700.c
--- linux-2.6.37-rc2/drivers/scsi/53c700.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/53c700.c	2010-11-21 23:40:17.143076584 +0000
@@ -167,7 +167,7 @@
 #include "53c700_d.h"
 
 
-STATIC int NCR_700_queuecommand(struct scsi_cmnd *, void (*done)(struct scsi_cmnd *));
+STATIC int NCR_700_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *);
 STATIC int NCR_700_abort(struct scsi_cmnd * SCpnt);
 STATIC int NCR_700_bus_reset(struct scsi_cmnd * SCpnt);
 STATIC int NCR_700_host_reset(struct scsi_cmnd * SCpnt);
@@ -1749,8 +1749,8 @@
 	return IRQ_RETVAL(handled);
 }
 
-STATIC int
-NCR_700_queuecommand(struct scsi_cmnd *SCp, void (*done)(struct scsi_cmnd *))
+static int
+NCR_700_queuecommand_lck(struct scsi_cmnd *SCp, void (*done)(struct scsi_cmnd *))
 {
 	struct NCR_700_Host_Parameters *hostdata = 
 		(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];
@@ -1904,6 +1904,8 @@
 	return 0;
 }
 
+STATIC DEF_SCSI_QCMD(NCR_700_queuecommand)
+
 STATIC int
 NCR_700_abort(struct scsi_cmnd * SCp)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/BusLogic.c linux-2.6.37-rc3/drivers/scsi/BusLogic.c
--- linux-2.6.37-rc2/drivers/scsi/BusLogic.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/BusLogic.c	2010-11-21 23:40:17.143076584 +0000
@@ -2807,7 +2807,7 @@
   Outgoing Mailbox for execution by the associated Host Adapter.
 */
 
-static int BusLogic_QueueCommand(struct scsi_cmnd *Command, void (*CompletionRoutine) (struct scsi_cmnd *))
+static int BusLogic_QueueCommand_lck(struct scsi_cmnd *Command, void (*CompletionRoutine) (struct scsi_cmnd *))
 {
 	struct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) Command->device->host->hostdata;
 	struct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[Command->device->id];
@@ -2994,6 +2994,7 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(BusLogic_QueueCommand)
 
 #if 0
 /*
diff -urN linux-2.6.37-rc2/drivers/scsi/BusLogic.h linux-2.6.37-rc3/drivers/scsi/BusLogic.h
--- linux-2.6.37-rc2/drivers/scsi/BusLogic.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/BusLogic.h	2010-11-21 23:40:17.143076584 +0000
@@ -1319,7 +1319,7 @@
 */
 
 static const char *BusLogic_DriverInfo(struct Scsi_Host *);
-static int BusLogic_QueueCommand(struct scsi_cmnd *, void (*CompletionRoutine) (struct scsi_cmnd *));
+static int BusLogic_QueueCommand(struct Scsi_Host *h, struct scsi_cmnd *);
 static int BusLogic_BIOSDiskParameters(struct scsi_device *, struct block_device *, sector_t, int *);
 static int BusLogic_ProcDirectoryInfo(struct Scsi_Host *, char *, char **, off_t, int, int);
 static int BusLogic_SlaveConfigure(struct scsi_device *);
diff -urN linux-2.6.37-rc2/drivers/scsi/NCR5380.c linux-2.6.37-rc3/drivers/scsi/NCR5380.c
--- linux-2.6.37-rc2/drivers/scsi/NCR5380.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/NCR5380.c	2010-11-21 23:40:17.144097221 +0000
@@ -952,7 +952,7 @@
  *	Locks: host lock taken by caller
  */
 
-static int NCR5380_queue_command(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *)) 
+static int NCR5380_queue_command_lck(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
 {
 	struct Scsi_Host *instance = cmd->device->host;
 	struct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;
@@ -1021,6 +1021,7 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(NCR5380_queue_command)
 
 /**
  *	NCR5380_main	-	NCR state machines
diff -urN linux-2.6.37-rc2/drivers/scsi/NCR5380.h linux-2.6.37-rc3/drivers/scsi/NCR5380.h
--- linux-2.6.37-rc2/drivers/scsi/NCR5380.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/NCR5380.h	2010-11-21 23:40:17.144097221 +0000
@@ -313,7 +313,7 @@
 #endif
 static int NCR5380_abort(Scsi_Cmnd * cmd);
 static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
-static int NCR5380_queue_command(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *));
+static int NCR5380_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static int __maybe_unused NCR5380_proc_info(struct Scsi_Host *instance,
 	char *buffer, char **start, off_t offset, int length, int inout);
 
diff -urN linux-2.6.37-rc2/drivers/scsi/NCR53c406a.c linux-2.6.37-rc3/drivers/scsi/NCR53c406a.c
--- linux-2.6.37-rc2/drivers/scsi/NCR53c406a.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/NCR53c406a.c	2010-11-21 23:40:17.144097221 +0000
@@ -693,7 +693,7 @@
 }
 #endif
 
-static int NCR53c406a_queue(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
+static int NCR53c406a_queue_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
 	int i;
 
@@ -726,6 +726,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(NCR53c406a_queue)
+
 static int NCR53c406a_host_reset(Scsi_Cmnd * SCpnt)
 {
 	DEB(printk("NCR53c406a_reset called\n"));
diff -urN linux-2.6.37-rc2/drivers/scsi/a100u2w.c linux-2.6.37-rc3/drivers/scsi/a100u2w.c
--- linux-2.6.37-rc2/drivers/scsi/a100u2w.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/a100u2w.c	2010-11-21 23:40:17.145099823 +0000
@@ -911,7 +911,7 @@
  *	queue the command down to the controller
  */
 
-static int inia100_queue(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
+static int inia100_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
 {
 	struct orc_scb *scb;
 	struct orc_host *host;		/* Point to Host adapter control block */
@@ -930,6 +930,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(inia100_queue)
+
 /*****************************************************************************
  Function name  : inia100_abort
  Description    : Abort a queued command.
diff -urN linux-2.6.37-rc2/drivers/scsi/aacraid/linit.c linux-2.6.37-rc3/drivers/scsi/aacraid/linit.c
--- linux-2.6.37-rc2/drivers/scsi/aacraid/linit.c	2010-11-21 23:40:11.622168344 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aacraid/linit.c	2010-11-21 23:40:17.145099823 +0000
@@ -248,7 +248,7 @@
  *	TODO: unify with aac_scsi_cmd().
  */
 
-static int aac_queuecommand(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+static int aac_queuecommand_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = cmd->device->host;
 	struct aac_dev *dev = (struct aac_dev *)host->hostdata;
@@ -267,6 +267,8 @@
 	return (aac_scsi_cmd(cmd) ? FAILED : 0);
 }
 
+static DEF_SCSI_QCMD(aac_queuecommand)
+
 /**
  *	aac_info		-	Returns the host adapter name
  *	@shost:		Scsi host to report on
diff -urN linux-2.6.37-rc2/drivers/scsi/advansys.c linux-2.6.37-rc3/drivers/scsi/advansys.c
--- linux-2.6.37-rc2/drivers/scsi/advansys.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/advansys.c	2010-11-21 23:40:17.147099427 +0000
@@ -9500,7 +9500,7 @@
  * in the 'scp' result field.
  */
 static int
-advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
+advansys_queuecommand_lck(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *shost = scp->device->host;
 	int asc_res, result = 0;
@@ -9525,6 +9525,8 @@
 	return result;
 }
 
+static DEF_SCSI_QCMD(advansys_queuecommand)
+
 static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
 {
 	PortAddr eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
diff -urN linux-2.6.37-rc2/drivers/scsi/aha152x.c linux-2.6.37-rc3/drivers/scsi/aha152x.c
--- linux-2.6.37-rc2/drivers/scsi/aha152x.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aha152x.c	2010-11-21 23:40:17.147099427 +0000
@@ -1056,7 +1056,7 @@
  *  queue a command
  *
  */
-static int aha152x_queue(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
+static int aha152x_queue_lck(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
 {
 #if 0
 	if(*SCpnt->cmnd == REQUEST_SENSE) {
@@ -1070,6 +1070,8 @@
 	return aha152x_internal_queue(SCpnt, NULL, 0, done);
 }
 
+static DEF_SCSI_QCMD(aha152x_queue)
+
 
 /*
  *  
diff -urN linux-2.6.37-rc2/drivers/scsi/aha1542.c linux-2.6.37-rc3/drivers/scsi/aha1542.c
--- linux-2.6.37-rc2/drivers/scsi/aha1542.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aha1542.c	2010-11-21 23:40:17.147099427 +0000
@@ -558,7 +558,7 @@
 	};
 }
 
-static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
+static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
 	unchar ahacmd = CMD_START_SCSI;
 	unchar direction;
@@ -718,6 +718,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(aha1542_queuecommand)
+
 /* Initialize mailboxes */
 static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/aha1542.h linux-2.6.37-rc3/drivers/scsi/aha1542.h
--- linux-2.6.37-rc2/drivers/scsi/aha1542.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aha1542.h	2010-11-21 23:40:17.147099427 +0000
@@ -132,7 +132,7 @@
 };
 
 static int aha1542_detect(struct scsi_host_template *);
-static int aha1542_queuecommand(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
+static int aha1542_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 static int aha1542_bus_reset(Scsi_Cmnd * SCpnt);
 static int aha1542_dev_reset(Scsi_Cmnd * SCpnt);
 static int aha1542_host_reset(Scsi_Cmnd * SCpnt);
diff -urN linux-2.6.37-rc2/drivers/scsi/aha1740.c linux-2.6.37-rc3/drivers/scsi/aha1740.c
--- linux-2.6.37-rc2/drivers/scsi/aha1740.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aha1740.c	2010-11-21 23:40:17.148097651 +0000
@@ -331,7 +331,7 @@
 	return IRQ_RETVAL(handled);
 }
 
-static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
+static int aha1740_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
 {
 	unchar direction;
 	unchar *cmd = (unchar *) SCpnt->cmnd;
@@ -503,6 +503,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(aha1740_queuecommand)
+
 /* Query the board for its irq_level and irq_type.  Nothing else matters
    in enhanced mode on an EISA bus. */
 
diff -urN linux-2.6.37-rc2/drivers/scsi/aic7xxx/aic79xx_osm.c linux-2.6.37-rc3/drivers/scsi/aic7xxx/aic79xx_osm.c
--- linux-2.6.37-rc2/drivers/scsi/aic7xxx/aic79xx_osm.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aic7xxx/aic79xx_osm.c	2010-11-21 23:40:17.148097651 +0000
@@ -573,7 +573,7 @@
  * Queue an SCB to the controller.
  */
 static int
-ahd_linux_queue(struct scsi_cmnd * cmd, void (*scsi_done) (struct scsi_cmnd *))
+ahd_linux_queue_lck(struct scsi_cmnd * cmd, void (*scsi_done) (struct scsi_cmnd *))
 {
 	struct	 ahd_softc *ahd;
 	struct	 ahd_linux_device *dev = scsi_transport_device_data(cmd->device);
@@ -588,6 +588,8 @@
 	return rtn;
 }
 
+static DEF_SCSI_QCMD(ahd_linux_queue)
+
 static struct scsi_target **
 ahd_linux_target_in_softc(struct scsi_target *starget)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/aic7xxx/aic7xxx_osm.c linux-2.6.37-rc3/drivers/scsi/aic7xxx/aic7xxx_osm.c
--- linux-2.6.37-rc2/drivers/scsi/aic7xxx/aic7xxx_osm.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aic7xxx/aic7xxx_osm.c	2010-11-21 23:40:17.148097651 +0000
@@ -528,7 +528,7 @@
  * Queue an SCB to the controller.
  */
 static int
-ahc_linux_queue(struct scsi_cmnd * cmd, void (*scsi_done) (struct scsi_cmnd *))
+ahc_linux_queue_lck(struct scsi_cmnd * cmd, void (*scsi_done) (struct scsi_cmnd *))
 {
 	struct	 ahc_softc *ahc;
 	struct	 ahc_linux_device *dev = scsi_transport_device_data(cmd->device);
@@ -548,6 +548,8 @@
 	return rtn;
 }
 
+static DEF_SCSI_QCMD(ahc_linux_queue)
+
 static inline struct scsi_target **
 ahc_linux_target_in_softc(struct scsi_target *starget)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/aic7xxx_old.c linux-2.6.37-rc3/drivers/scsi/aic7xxx_old.c
--- linux-2.6.37-rc2/drivers/scsi/aic7xxx_old.c	2010-11-21 23:40:11.623168106 +0000
+++ linux-2.6.37-rc3/drivers/scsi/aic7xxx_old.c	2010-11-21 23:40:17.150098484 +0000
@@ -10234,7 +10234,7 @@
  * Description:
  *   Queue a SCB to the controller.
  *-F*************************************************************************/
-static int aic7xxx_queue(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
+static int aic7xxx_queue_lck(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 {
   struct aic7xxx_host *p;
   struct aic7xxx_scb *scb;
@@ -10292,6 +10292,8 @@
   return (0);
 }
 
+static DEF_SCSI_QCMD(aic7xxx_queue)
+
 /*+F*************************************************************************
  * Function:
  *   aic7xxx_bus_device_reset
diff -urN linux-2.6.37-rc2/drivers/scsi/arcmsr/arcmsr_hba.c linux-2.6.37-rc3/drivers/scsi/arcmsr/arcmsr_hba.c
--- linux-2.6.37-rc2/drivers/scsi/arcmsr/arcmsr_hba.c	2010-11-21 23:40:11.624168366 +0000
+++ linux-2.6.37-rc3/drivers/scsi/arcmsr/arcmsr_hba.c	2010-11-21 23:40:17.150098484 +0000
@@ -85,8 +85,7 @@
 static int arcmsr_bus_reset(struct scsi_cmnd *);
 static int arcmsr_bios_param(struct scsi_device *sdev,
 		struct block_device *bdev, sector_t capacity, int *info);
-static int arcmsr_queue_command(struct scsi_cmnd *cmd,
-					void (*done) (struct scsi_cmnd *));
+static int arcmsr_queue_command(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 static int arcmsr_probe(struct pci_dev *pdev,
 				const struct pci_device_id *id);
 static void arcmsr_remove(struct pci_dev *pdev);
@@ -2081,7 +2080,7 @@
 	}
 }
 
-static int arcmsr_queue_command(struct scsi_cmnd *cmd,
+static int arcmsr_queue_command_lck(struct scsi_cmnd *cmd,
 	void (* done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = cmd->device->host;
@@ -2124,6 +2123,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(arcmsr_queue_command)
+
 static bool arcmsr_get_hba_config(struct AdapterControlBlock *acb)
 {
 	struct MessageUnit_A __iomem *reg = acb->pmuA;
diff -urN linux-2.6.37-rc2/drivers/scsi/arm/acornscsi.c linux-2.6.37-rc3/drivers/scsi/arm/acornscsi.c
--- linux-2.6.37-rc2/drivers/scsi/arm/acornscsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/arm/acornscsi.c	2010-11-21 23:40:17.150098484 +0000
@@ -2511,7 +2511,7 @@
  *	      done - function called on completion, with pointer to command descriptor
  * Returns  : 0, or < 0 on error.
  */
-int acornscsi_queuecmd(struct scsi_cmnd *SCpnt,
+static int acornscsi_queuecmd_lck(struct scsi_cmnd *SCpnt,
 		       void (*done)(struct scsi_cmnd *))
 {
     AS_Host *host = (AS_Host *)SCpnt->device->host->hostdata;
@@ -2561,6 +2561,8 @@
     return 0;
 }
 
+DEF_SCSI_QCMD(acornscsi_queuecmd)
+
 /*
  * Prototype: void acornscsi_reportstatus(struct scsi_cmnd **SCpntp1, struct scsi_cmnd **SCpntp2, int result)
  * Purpose  : pass a result to *SCpntp1, and check if *SCpntp1 = *SCpntp2
diff -urN linux-2.6.37-rc2/drivers/scsi/arm/fas216.c linux-2.6.37-rc3/drivers/scsi/arm/fas216.c
--- linux-2.6.37-rc2/drivers/scsi/arm/fas216.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/arm/fas216.c	2010-11-21 23:40:17.151096562 +0000
@@ -2198,7 +2198,7 @@
  * Returns: 0 on success, else error.
  * Notes: io_request_lock is held, interrupts are disabled.
  */
-int fas216_queue_command(struct scsi_cmnd *SCpnt,
+static int fas216_queue_command_lck(struct scsi_cmnd *SCpnt,
 			 void (*done)(struct scsi_cmnd *))
 {
 	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
@@ -2240,6 +2240,8 @@
 	return result;
 }
 
+DEF_SCSI_QCMD(fas216_queue_command)
+
 /**
  * fas216_internal_done - trigger restart of a waiting thread in fas216_noqueue_command
  * @SCpnt: Command to wake
@@ -2263,7 +2265,7 @@
  * Returns: scsi result code.
  * Notes: io_request_lock is held, interrupts are disabled.
  */
-int fas216_noqueue_command(struct scsi_cmnd *SCpnt,
+static int fas216_noqueue_command_lck(struct scsi_cmnd *SCpnt,
 			   void (*done)(struct scsi_cmnd *))
 {
 	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
@@ -2277,7 +2279,7 @@
 	BUG_ON(info->scsi.irq != NO_IRQ);
 
 	info->internal_done = 0;
-	fas216_queue_command(SCpnt, fas216_internal_done);
+	fas216_queue_command_lck(SCpnt, fas216_internal_done);
 
 	/*
 	 * This wastes time, since we can't return until the command is
@@ -2310,6 +2312,8 @@
 	return 0;
 }
 
+DEF_SCSI_QCMD(fas216_noqueue_command)
+
 /*
  * Error handler timeout function.  Indicate that we timed out,
  * and wake up any error handler process so it can continue.
diff -urN linux-2.6.37-rc2/drivers/scsi/arm/fas216.h linux-2.6.37-rc3/drivers/scsi/arm/fas216.h
--- linux-2.6.37-rc2/drivers/scsi/arm/fas216.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/arm/fas216.h	2010-11-21 23:40:17.151096562 +0000
@@ -331,23 +331,21 @@
  */
 extern int fas216_add (struct Scsi_Host *instance, struct device *dev);
 
-/* Function: int fas216_queue_command(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+/* Function: int fas216_queue_command(struct Scsi_Host *h, struct scsi_cmnd *SCpnt)
  * Purpose : queue a command for adapter to process.
- * Params  : SCpnt - Command to queue
- *	     done  - done function to call once command is complete
+ * Params  : h - host adapter
+ *	   : SCpnt - Command to queue
  * Returns : 0 - success, else error
  */
-extern int fas216_queue_command(struct scsi_cmnd *,
-				void (*done)(struct scsi_cmnd *));
+extern int fas216_queue_command(struct Scsi_Host *h, struct scsi_cmnd *SCpnt);
 
-/* Function: int fas216_noqueue_command(istruct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+/* Function: int fas216_noqueue_command(struct Scsi_Host *h, struct scsi_cmnd *SCpnt)
  * Purpose : queue a command for adapter to process, and process it to completion.
- * Params  : SCpnt - Command to queue
- *	     done  - done function to call once command is complete
+ * Params  : h - host adapter
+ *	   : SCpnt - Command to queue
  * Returns : 0 - success, else error
  */
-extern int fas216_noqueue_command(struct scsi_cmnd *,
-				  void (*done)(struct scsi_cmnd *));
+extern int fas216_noqueue_command(struct Scsi_Host *, struct scsi_cmnd *)
 
 /* Function: irqreturn_t fas216_intr (FAS216_Info *info)
  * Purpose : handle interrupts from the interface to progress a command
diff -urN linux-2.6.37-rc2/drivers/scsi/atari_NCR5380.c linux-2.6.37-rc3/drivers/scsi/atari_NCR5380.c
--- linux-2.6.37-rc2/drivers/scsi/atari_NCR5380.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/atari_NCR5380.c	2010-11-21 23:40:17.151096562 +0000
@@ -910,7 +910,7 @@
  *
  */
 
-static int NCR5380_queue_command(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+static int NCR5380_queue_command_lck(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
 {
 	SETUP_HOSTDATA(cmd->device->host);
 	Scsi_Cmnd *tmp;
@@ -1022,6 +1022,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(NCR5380_queue_command)
+
 /*
  * Function : NCR5380_main (void)
  *
diff -urN linux-2.6.37-rc2/drivers/scsi/atari_scsi.c linux-2.6.37-rc3/drivers/scsi/atari_scsi.c
--- linux-2.6.37-rc2/drivers/scsi/atari_scsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/atari_scsi.c	2010-11-21 23:40:17.151096562 +0000
@@ -572,23 +572,6 @@
 }
 
 
-/* This is the wrapper function for NCR5380_queue_command(). It just
- * tries to get the lock on the ST-DMA (see above) and then calls the
- * original function.
- */
-
-#if 0
-int atari_queue_command(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
-{
-	/* falcon_get_lock();
-	 * ++guenther: moved to NCR5380_queue_command() to prevent
-	 * race condition, see there for an explanation.
-	 */
-	return NCR5380_queue_command(cmd, done);
-}
-#endif
-
-
 int __init atari_scsi_detect(struct scsi_host_template *host)
 {
 	static int called = 0;
diff -urN linux-2.6.37-rc2/drivers/scsi/atp870u.c linux-2.6.37-rc3/drivers/scsi/atp870u.c
--- linux-2.6.37-rc2/drivers/scsi/atp870u.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/atp870u.c	2010-11-21 23:40:17.152076955 +0000
@@ -605,7 +605,7 @@
  *
  *	Queue a command to the ATP queue. Called with the host lock held.
  */
-static int atp870u_queuecommand(struct scsi_cmnd * req_p, 
+static int atp870u_queuecommand_lck(struct scsi_cmnd *req_p,
 			 void (*done) (struct scsi_cmnd *))
 {
 	unsigned char c;
@@ -694,6 +694,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(atp870u_queuecommand)
+
 /**
  *	send_s870	-	send a command to the controller
  *	@host: host
diff -urN linux-2.6.37-rc2/drivers/scsi/bfa/bfad_im.c linux-2.6.37-rc3/drivers/scsi/bfa/bfad_im.c
--- linux-2.6.37-rc2/drivers/scsi/bfa/bfad_im.c	2010-11-21 23:40:11.660168369 +0000
+++ linux-2.6.37-rc3/drivers/scsi/bfa/bfad_im.c	2010-11-21 23:40:17.185077437 +0000
@@ -30,8 +30,7 @@
 struct scsi_transport_template *bfad_im_scsi_transport_template;
 struct scsi_transport_template *bfad_im_scsi_vport_transport_template;
 static void bfad_im_itnim_work_handler(struct work_struct *work);
-static int bfad_im_queuecommand(struct scsi_cmnd *cmnd,
-				void (*done)(struct scsi_cmnd *));
+static int bfad_im_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *cmnd);
 static int bfad_im_slave_alloc(struct scsi_device *sdev);
 static void bfad_im_fc_rport_add(struct bfad_im_port_s  *im_port,
 				struct bfad_itnim_s *itnim);
@@ -1120,7 +1119,7 @@
  * Scsi_Host template entry, queue a SCSI command to the BFAD.
  */
 static int
-bfad_im_queuecommand(struct scsi_cmnd *cmnd, void (*done) (struct scsi_cmnd *))
+bfad_im_queuecommand_lck(struct scsi_cmnd *cmnd, void (*done) (struct scsi_cmnd *))
 {
 	struct bfad_im_port_s *im_port =
 		(struct bfad_im_port_s *) cmnd->device->host->hostdata[0];
@@ -1187,6 +1186,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(bfad_im_queuecommand)
+
 void
 bfad_os_rport_online_wait(struct bfad_s *bfad)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/dc395x.c linux-2.6.37-rc3/drivers/scsi/dc395x.c
--- linux-2.6.37-rc2/drivers/scsi/dc395x.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/dc395x.c	2010-11-21 23:40:17.237038964 +0000
@@ -1080,7 +1080,7 @@
  *        and is expected to be held on return.
  *
  **/
-static int dc395x_queue_command(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+static int dc395x_queue_command_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct DeviceCtlBlk *dcb;
 	struct ScsiReqBlk *srb;
@@ -1154,6 +1154,7 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(dc395x_queue_command)
 
 /*
  * Return the disk geometry for the given SCSI device.
diff -urN linux-2.6.37-rc2/drivers/scsi/dpt_i2o.c linux-2.6.37-rc3/drivers/scsi/dpt_i2o.c
--- linux-2.6.37-rc2/drivers/scsi/dpt_i2o.c	2010-11-21 23:40:11.717235821 +0000
+++ linux-2.6.37-rc3/drivers/scsi/dpt_i2o.c	2010-11-21 23:40:17.238097925 +0000
@@ -423,7 +423,7 @@
 	return 0;
 }
 
-static int adpt_queue(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
+static int adpt_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
 {
 	adpt_hba* pHba = NULL;
 	struct adpt_device* pDev = NULL;	/* dpt per device information */
@@ -491,6 +491,8 @@
 	return adpt_scsi_to_i2o(pHba, cmd, pDev);
 }
 
+static DEF_SCSI_QCMD(adpt_queue)
+
 static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,
 		sector_t capacity, int geom[])
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/dpti.h linux-2.6.37-rc3/drivers/scsi/dpti.h
--- linux-2.6.37-rc2/drivers/scsi/dpti.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/dpti.h	2010-11-21 23:40:17.238097925 +0000
@@ -29,7 +29,7 @@
  */
 
 static int adpt_detect(struct scsi_host_template * sht);
-static int adpt_queue(struct scsi_cmnd * cmd, void (*cmdcomplete) (struct scsi_cmnd *));
+static int adpt_queue(struct Scsi_Host *h, struct scsi_cmnd * cmd);
 static int adpt_abort(struct scsi_cmnd * cmd);
 static int adpt_reset(struct scsi_cmnd* cmd);
 static int adpt_release(struct Scsi_Host *host);
diff -urN linux-2.6.37-rc2/drivers/scsi/dtc.h linux-2.6.37-rc3/drivers/scsi/dtc.h
--- linux-2.6.37-rc2/drivers/scsi/dtc.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/dtc.h	2010-11-21 23:40:17.238097925 +0000
@@ -36,7 +36,7 @@
 static int dtc_biosparam(struct scsi_device *, struct block_device *,
 		         sector_t, int*);
 static int dtc_detect(struct scsi_host_template *);
-static int dtc_queue_command(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
+static int dtc_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static int dtc_bus_reset(Scsi_Cmnd *);
 
 #ifndef CMD_PER_LUN
diff -urN linux-2.6.37-rc2/drivers/scsi/eata.c linux-2.6.37-rc3/drivers/scsi/eata.c
--- linux-2.6.37-rc2/drivers/scsi/eata.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/eata.c	2010-11-21 23:40:17.239041219 +0000
@@ -505,8 +505,7 @@
 
 static int eata2x_detect(struct scsi_host_template *);
 static int eata2x_release(struct Scsi_Host *);
-static int eata2x_queuecommand(struct scsi_cmnd *,
-			       void (*done) (struct scsi_cmnd *));
+static int eata2x_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 static int eata2x_eh_abort(struct scsi_cmnd *);
 static int eata2x_eh_host_reset(struct scsi_cmnd *);
 static int eata2x_bios_param(struct scsi_device *, struct block_device *,
@@ -1758,7 +1757,7 @@
 
 }
 
-static int eata2x_queuecommand(struct scsi_cmnd *SCpnt,
+static int eata2x_queuecommand_lck(struct scsi_cmnd *SCpnt,
 			       void (*done) (struct scsi_cmnd *))
 {
 	struct Scsi_Host *shost = SCpnt->device->host;
@@ -1843,6 +1842,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(eata2x_queuecommand)
+
 static int eata2x_eh_abort(struct scsi_cmnd *SCarg)
 {
 	struct Scsi_Host *shost = SCarg->device->host;
diff -urN linux-2.6.37-rc2/drivers/scsi/eata_pio.c linux-2.6.37-rc3/drivers/scsi/eata_pio.c
--- linux-2.6.37-rc2/drivers/scsi/eata_pio.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/eata_pio.c	2010-11-21 23:40:17.239041219 +0000
@@ -335,7 +335,7 @@
 	return 0;
 }
 
-static int eata_pio_queue(struct scsi_cmnd *cmd,
+static int eata_pio_queue_lck(struct scsi_cmnd *cmd,
 		void (*done)(struct scsi_cmnd *))
 {
 	unsigned int x, y;
@@ -438,6 +438,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(eata_pio_queue)
+
 static int eata_pio_abort(struct scsi_cmnd *cmd)
 {
 	unsigned int loop = 100;
diff -urN linux-2.6.37-rc2/drivers/scsi/esp_scsi.c linux-2.6.37-rc3/drivers/scsi/esp_scsi.c
--- linux-2.6.37-rc2/drivers/scsi/esp_scsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/esp_scsi.c	2010-11-21 23:40:17.239041219 +0000
@@ -916,7 +916,7 @@
 	scsi_track_queue_full(dev, lp->num_tagged - 1);
 }
 
-static int esp_queuecommand(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+static int esp_queuecommand_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct scsi_device *dev = cmd->device;
 	struct esp *esp = shost_priv(dev->host);
@@ -941,6 +941,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(esp_queuecommand)
+
 static int esp_check_gross_error(struct esp *esp)
 {
 	if (esp->sreg & ESP_STAT_SPAM) {
diff -urN linux-2.6.37-rc2/drivers/scsi/fd_mcs.c linux-2.6.37-rc3/drivers/scsi/fd_mcs.c
--- linux-2.6.37-rc2/drivers/scsi/fd_mcs.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/fd_mcs.c	2010-11-21 23:40:17.240098197 +0000
@@ -1072,7 +1072,7 @@
 	return 0;
 }
 
-static int fd_mcs_queue(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
+static int fd_mcs_queue_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
 	struct Scsi_Host *shpnt = SCpnt->device->host;
 
@@ -1122,6 +1122,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(fd_mcs_queue)
+
 #if DEBUG_ABORT || DEBUG_RESET
 static void fd_mcs_print_info(Scsi_Cmnd * SCpnt)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/fdomain.c linux-2.6.37-rc3/drivers/scsi/fdomain.c
--- linux-2.6.37-rc2/drivers/scsi/fdomain.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/fdomain.c	2010-11-21 23:40:17.240098197 +0000
@@ -1419,7 +1419,7 @@
    return IRQ_HANDLED;
 }
 
-static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
+static int fdomain_16x0_queue_lck(struct scsi_cmnd *SCpnt,
 		void (*done)(struct scsi_cmnd *))
 {
    if (in_command) {
@@ -1469,6 +1469,8 @@
    return 0;
 }
 
+static DEF_SCSI_QCMD(fdomain_16x0_queue)
+
 #if DEBUG_ABORT
 static void print_info(struct scsi_cmnd *SCpnt)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/fnic/fnic.h linux-2.6.37-rc3/drivers/scsi/fnic/fnic.h
--- linux-2.6.37-rc2/drivers/scsi/fnic/fnic.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/fnic/fnic.h	2010-11-21 23:40:17.240098197 +0000
@@ -246,7 +246,7 @@
 void fnic_update_mac(struct fc_lport *, u8 *new);
 void fnic_update_mac_locked(struct fnic *, u8 *new);
 
-int fnic_queuecommand(struct scsi_cmnd *, void (*done)(struct scsi_cmnd *));
+int fnic_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 int fnic_abort_cmd(struct scsi_cmnd *);
 int fnic_device_reset(struct scsi_cmnd *);
 int fnic_host_reset(struct scsi_cmnd *);
diff -urN linux-2.6.37-rc2/drivers/scsi/fnic/fnic_scsi.c linux-2.6.37-rc3/drivers/scsi/fnic/fnic_scsi.c
--- linux-2.6.37-rc2/drivers/scsi/fnic/fnic_scsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/fnic/fnic_scsi.c	2010-11-21 23:40:17.241100054 +0000
@@ -349,7 +349,7 @@
  * Routine to send a scsi cdb
  * Called with host_lock held and interrupts disabled.
  */
-int fnic_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
+static int fnic_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 {
 	struct fc_lport *lp;
 	struct fc_rport *rport;
@@ -457,6 +457,8 @@
 	return ret;
 }
 
+DEF_SCSI_QCMD(fnic_queuecommand)
+
 /*
  * fnic_fcpio_fw_reset_cmpl_handler
  * Routine to handle fw reset completion
diff -urN linux-2.6.37-rc2/drivers/scsi/g_NCR5380.h linux-2.6.37-rc3/drivers/scsi/g_NCR5380.h
--- linux-2.6.37-rc2/drivers/scsi/g_NCR5380.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/g_NCR5380.h	2010-11-21 23:40:17.241100054 +0000
@@ -46,7 +46,7 @@
 static int generic_NCR5380_abort(Scsi_Cmnd *);
 static int generic_NCR5380_detect(struct scsi_host_template *);
 static int generic_NCR5380_release_resources(struct Scsi_Host *);
-static int generic_NCR5380_queue_command(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
+static int generic_NCR5380_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static int generic_NCR5380_bus_reset(Scsi_Cmnd *);
 static const char* generic_NCR5380_info(struct Scsi_Host *);
 
diff -urN linux-2.6.37-rc2/drivers/scsi/gdth.c linux-2.6.37-rc3/drivers/scsi/gdth.c
--- linux-2.6.37-rc2/drivers/scsi/gdth.c	2010-11-21 23:40:11.718238061 +0000
+++ linux-2.6.37-rc3/drivers/scsi/gdth.c	2010-11-21 23:40:17.241100054 +0000
@@ -185,7 +185,7 @@
 			        unsigned long arg);
 
 static void gdth_flush(gdth_ha_str *ha);
-static int gdth_queuecommand(Scsi_Cmnd *scp,void (*done)(Scsi_Cmnd *));
+static int gdth_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 static int __gdth_queuecommand(gdth_ha_str *ha, struct scsi_cmnd *scp,
 				struct gdth_cmndinfo *cmndinfo);
 static void gdth_scsi_done(struct scsi_cmnd *scp);
@@ -4004,7 +4004,7 @@
 }
 
 
-static int gdth_queuecommand(struct scsi_cmnd *scp,
+static int gdth_queuecommand_lck(struct scsi_cmnd *scp,
 				void (*done)(struct scsi_cmnd *))
 {
     gdth_ha_str *ha = shost_priv(scp->device->host);
@@ -4022,6 +4022,8 @@
     return __gdth_queuecommand(ha, scp, cmndinfo);
 }
 
+static DEF_SCSI_QCMD(gdth_queuecommand)
+
 static int __gdth_queuecommand(gdth_ha_str *ha, struct scsi_cmnd *scp,
 				struct gdth_cmndinfo *cmndinfo)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/hpsa.c linux-2.6.37-rc3/drivers/scsi/hpsa.c
--- linux-2.6.37-rc2/drivers/scsi/hpsa.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/hpsa.c	2010-11-21 23:40:17.242076158 +0000
@@ -31,7 +31,6 @@
 #include <linux/seq_file.h>
 #include <linux/init.h>
 #include <linux/spinlock.h>
-#include <linux/smp_lock.h>
 #include <linux/compat.h>
 #include <linux/blktrace_api.h>
 #include <linux/uaccess.h>
@@ -143,8 +142,7 @@
 	void *buff, size_t size, u8 page_code, unsigned char *scsi3addr,
 	int cmd_type);
 
-static int hpsa_scsi_queue_command(struct scsi_cmnd *cmd,
-		void (*done)(struct scsi_cmnd *));
+static int hpsa_scsi_queue_command(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 static void hpsa_scan_start(struct Scsi_Host *);
 static int hpsa_scan_finished(struct Scsi_Host *sh,
 	unsigned long elapsed_time);
@@ -1926,7 +1924,7 @@
 }
 
 
-static int hpsa_scsi_queue_command(struct scsi_cmnd *cmd,
+static int hpsa_scsi_queue_command_lck(struct scsi_cmnd *cmd,
 	void (*done)(struct scsi_cmnd *))
 {
 	struct ctlr_info *h;
@@ -2020,6 +2018,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(hpsa_scsi_queue_command)
+
 static void hpsa_scan_start(struct Scsi_Host *sh)
 {
 	struct ctlr_info *h = shost_to_hba(sh);
diff -urN linux-2.6.37-rc2/drivers/scsi/hptiop.c linux-2.6.37-rc3/drivers/scsi/hptiop.c
--- linux-2.6.37-rc2/drivers/scsi/hptiop.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/hptiop.c	2010-11-21 23:40:17.242076158 +0000
@@ -751,7 +751,7 @@
 		MVIOP_MU_QUEUE_ADDR_HOST_BIT | size_bit, hba);
 }
 
-static int hptiop_queuecommand(struct scsi_cmnd *scp,
+static int hptiop_queuecommand_lck(struct scsi_cmnd *scp,
 				void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = scp->device->host;
@@ -819,6 +819,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(hptiop_queuecommand)
+
 static const char *hptiop_info(struct Scsi_Host *host)
 {
 	return driver_name_long;
diff -urN linux-2.6.37-rc2/drivers/scsi/ibmmca.c linux-2.6.37-rc3/drivers/scsi/ibmmca.c
--- linux-2.6.37-rc2/drivers/scsi/ibmmca.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ibmmca.c	2010-11-21 23:40:17.243102133 +0000
@@ -39,7 +39,7 @@
 #include <scsi/scsi_host.h>
 
 /* Common forward declarations for all Linux-versions: */
-static int ibmmca_queuecommand (Scsi_Cmnd *, void (*done) (Scsi_Cmnd *));
+static int ibmmca_queuecommand (struct Scsi_Host *, struct scsi_cmnd *);
 static int ibmmca_abort (Scsi_Cmnd *);
 static int ibmmca_host_reset (Scsi_Cmnd *);
 static int ibmmca_biosparam (struct scsi_device *, struct block_device *, sector_t, int *);
@@ -1691,7 +1691,7 @@
 }
 
 /* The following routine is the SCSI command queue for the midlevel driver */
-static int ibmmca_queuecommand(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
+static int ibmmca_queuecommand_lck(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
 {
 	unsigned int ldn;
 	unsigned int scsi_cmd;
@@ -1996,6 +1996,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(ibmmca_queuecommand)
+
 static int __ibmmca_abort(Scsi_Cmnd * cmd)
 {
 	/* Abort does not work, as the adapter never generates an interrupt on
diff -urN linux-2.6.37-rc2/drivers/scsi/ibmvscsi/ibmvfc.c linux-2.6.37-rc3/drivers/scsi/ibmvscsi/ibmvfc.c
--- linux-2.6.37-rc2/drivers/scsi/ibmvscsi/ibmvfc.c	2010-11-21 23:40:11.719235742 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ibmvscsi/ibmvfc.c	2010-11-21 23:40:17.243102133 +0000
@@ -1606,7 +1606,7 @@
  * Returns:
  *	0 on success / other on failure
  **/
-static int ibmvfc_queuecommand(struct scsi_cmnd *cmnd,
+static int ibmvfc_queuecommand_lck(struct scsi_cmnd *cmnd,
 			       void (*done) (struct scsi_cmnd *))
 {
 	struct ibmvfc_host *vhost = shost_priv(cmnd->device->host);
@@ -1672,6 +1672,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(ibmvfc_queuecommand)
+
 /**
  * ibmvfc_sync_completion - Signal that a synchronous command has completed
  * @evt:	ibmvfc event struct
diff -urN linux-2.6.37-rc2/drivers/scsi/ibmvscsi/ibmvscsi.c linux-2.6.37-rc3/drivers/scsi/ibmvscsi/ibmvscsi.c
--- linux-2.6.37-rc2/drivers/scsi/ibmvscsi/ibmvscsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ibmvscsi/ibmvscsi.c	2010-11-21 23:40:17.244078465 +0000
@@ -713,7 +713,7 @@
  * @cmd:	struct scsi_cmnd to be executed
  * @done:	Callback function to be called when cmd is completed
 */
-static int ibmvscsi_queuecommand(struct scsi_cmnd *cmnd,
+static int ibmvscsi_queuecommand_lck(struct scsi_cmnd *cmnd,
 				 void (*done) (struct scsi_cmnd *))
 {
 	struct srp_cmd *srp_cmd;
@@ -766,6 +766,8 @@
 	return ibmvscsi_send_srp_event(evt_struct, hostdata, 0);
 }
 
+static DEF_SCSI_QCMD(ibmvscsi_queuecommand)
+
 /* ------------------------------------------------------------
  * Routines for driver initialization
  */
diff -urN linux-2.6.37-rc2/drivers/scsi/imm.c linux-2.6.37-rc3/drivers/scsi/imm.c
--- linux-2.6.37-rc2/drivers/scsi/imm.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/imm.c	2010-11-21 23:40:17.244078465 +0000
@@ -926,7 +926,7 @@
 	return 0;
 }
 
-static int imm_queuecommand(struct scsi_cmnd *cmd,
+static int imm_queuecommand_lck(struct scsi_cmnd *cmd,
 		void (*done)(struct scsi_cmnd *))
 {
 	imm_struct *dev = imm_dev(cmd->device->host);
@@ -949,6 +949,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(imm_queuecommand)
+
 /*
  * Apparently the disk->capacity attribute is off by 1 sector 
  * for all disk drives.  We add the one here, but it should really
diff -urN linux-2.6.37-rc2/drivers/scsi/in2000.c linux-2.6.37-rc3/drivers/scsi/in2000.c
--- linux-2.6.37-rc2/drivers/scsi/in2000.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/in2000.c	2010-11-21 23:40:17.244078465 +0000
@@ -334,7 +334,7 @@
 
 static void in2000_execute(struct Scsi_Host *instance);
 
-static int in2000_queuecommand(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
+static int in2000_queuecommand_lck(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
 {
 	struct Scsi_Host *instance;
 	struct IN2000_hostdata *hostdata;
@@ -431,6 +431,8 @@
 	    return 0;
 }
 
+static DEF_SCSI_QCMD(in2000_queuecommand)
+
 
 
 /*
diff -urN linux-2.6.37-rc2/drivers/scsi/in2000.h linux-2.6.37-rc3/drivers/scsi/in2000.h
--- linux-2.6.37-rc2/drivers/scsi/in2000.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/in2000.h	2010-11-21 23:40:17.244078465 +0000
@@ -396,7 +396,7 @@
 							   flags)
 
 static int in2000_detect(struct scsi_host_template *) in2000__INIT;
-static int in2000_queuecommand(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
+static int in2000_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 static int in2000_abort(Scsi_Cmnd *);
 static void in2000_setup(char *, int *) in2000__INIT;
 static int in2000_biosparam(struct scsi_device *, struct block_device *,
diff -urN linux-2.6.37-rc2/drivers/scsi/initio.c linux-2.6.37-rc3/drivers/scsi/initio.c
--- linux-2.6.37-rc2/drivers/scsi/initio.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/initio.c	2010-11-21 23:40:17.245075636 +0000
@@ -2639,7 +2639,7 @@
  *	will cause the mid layer to call us again later with the command)
  */
 
-static int i91u_queuecommand(struct scsi_cmnd *cmd,
+static int i91u_queuecommand_lck(struct scsi_cmnd *cmd,
 		void (*done)(struct scsi_cmnd *))
 {
 	struct initio_host *host = (struct initio_host *) cmd->device->host->hostdata;
@@ -2656,6 +2656,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(i91u_queuecommand)
+
 /**
  *	i91u_bus_reset		-	reset the SCSI bus
  *	@cmnd: Command block we want to trigger the reset for
diff -urN linux-2.6.37-rc2/drivers/scsi/ipr.c linux-2.6.37-rc3/drivers/scsi/ipr.c
--- linux-2.6.37-rc2/drivers/scsi/ipr.c	2010-11-21 23:40:11.721168104 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ipr.c	2010-11-21 23:40:17.246080424 +0000
@@ -5709,7 +5709,7 @@
  *	SCSI_MLQUEUE_DEVICE_BUSY if device is busy
  *	SCSI_MLQUEUE_HOST_BUSY if host is busy
  **/
-static int ipr_queuecommand(struct scsi_cmnd *scsi_cmd,
+static int ipr_queuecommand_lck(struct scsi_cmnd *scsi_cmd,
 			    void (*done) (struct scsi_cmnd *))
 {
 	struct ipr_ioa_cfg *ioa_cfg;
@@ -5792,6 +5792,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(ipr_queuecommand)
+
 /**
  * ipr_ioctl - IOCTL handler
  * @sdev:	scsi device struct
diff -urN linux-2.6.37-rc2/drivers/scsi/ips.c linux-2.6.37-rc3/drivers/scsi/ips.c
--- linux-2.6.37-rc2/drivers/scsi/ips.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ips.c	2010-11-21 23:40:17.247080055 +0000
@@ -232,7 +232,7 @@
 static int ips_release(struct Scsi_Host *);
 static int ips_eh_abort(struct scsi_cmnd *);
 static int ips_eh_reset(struct scsi_cmnd *);
-static int ips_queue(struct scsi_cmnd *, void (*)(struct scsi_cmnd *));
+static int ips_queue(struct Scsi_Host *, struct scsi_cmnd *);
 static const char *ips_info(struct Scsi_Host *);
 static irqreturn_t do_ipsintr(int, void *);
 static int ips_hainit(ips_ha_t *);
@@ -1046,7 +1046,7 @@
 /*    Linux obtains io_request_lock before calling this function            */
 /*                                                                          */
 /****************************************************************************/
-static int ips_queue(struct scsi_cmnd *SC, void (*done) (struct scsi_cmnd *))
+static int ips_queue_lck(struct scsi_cmnd *SC, void (*done) (struct scsi_cmnd *))
 {
 	ips_ha_t *ha;
 	ips_passthru_t *pt;
@@ -1137,6 +1137,8 @@
 	return (0);
 }
 
+static DEF_SCSI_QCMD(ips_queue)
+
 /****************************************************************************/
 /*                                                                          */
 /* Routine Name: ips_biosparam                                              */
diff -urN linux-2.6.37-rc2/drivers/scsi/libfc/fc_fcp.c linux-2.6.37-rc3/drivers/scsi/libfc/fc_fcp.c
--- linux-2.6.37-rc2/drivers/scsi/libfc/fc_fcp.c	2010-11-21 23:40:11.722172070 +0000
+++ linux-2.6.37-rc3/drivers/scsi/libfc/fc_fcp.c	2010-11-21 23:40:17.248040912 +0000
@@ -1753,7 +1753,7 @@
  * This is the i/o strategy routine, called by the SCSI layer. This routine
  * is called with the host_lock held.
  */
-int fc_queuecommand(struct scsi_cmnd *sc_cmd, void (*done)(struct scsi_cmnd *))
+static int fc_queuecommand_lck(struct scsi_cmnd *sc_cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct fc_lport *lport;
 	struct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));
@@ -1851,6 +1851,8 @@
 	spin_lock_irq(lport->host->host_lock);
 	return rc;
 }
+
+DEF_SCSI_QCMD(fc_queuecommand)
 EXPORT_SYMBOL(fc_queuecommand);
 
 /**
diff -urN linux-2.6.37-rc2/drivers/scsi/libiscsi.c linux-2.6.37-rc3/drivers/scsi/libiscsi.c
--- linux-2.6.37-rc2/drivers/scsi/libiscsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/libiscsi.c	2010-11-21 23:40:17.248040912 +0000
@@ -1599,7 +1599,7 @@
 	FAILURE_SESSION_NOT_READY,
 };
 
-int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
+static int iscsi_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 {
 	struct iscsi_cls_session *cls_session;
 	struct Scsi_Host *host;
@@ -1736,6 +1736,8 @@
 	spin_lock(host->host_lock);
 	return 0;
 }
+
+DEF_SCSI_QCMD(iscsi_queuecommand)
 EXPORT_SYMBOL_GPL(iscsi_queuecommand);
 
 int iscsi_change_queue_depth(struct scsi_device *sdev, int depth, int reason)
diff -urN linux-2.6.37-rc2/drivers/scsi/libsas/sas_scsi_host.c linux-2.6.37-rc3/drivers/scsi/libsas/sas_scsi_host.c
--- linux-2.6.37-rc2/drivers/scsi/libsas/sas_scsi_host.c	2010-11-21 23:40:11.723168423 +0000
+++ linux-2.6.37-rc3/drivers/scsi/libsas/sas_scsi_host.c	2010-11-21 23:40:17.249059576 +0000
@@ -189,7 +189,7 @@
  * Note: XXX: Remove the host unlock/lock pair when SCSI Core can
  * call us without holding an IRQ spinlock...
  */
-int sas_queuecommand(struct scsi_cmnd *cmd,
+static int sas_queuecommand_lck(struct scsi_cmnd *cmd,
 		     void (*scsi_done)(struct scsi_cmnd *))
 	__releases(host->host_lock)
 	__acquires(dev->sata_dev.ap->lock)
@@ -254,6 +254,8 @@
 	return res;
 }
 
+DEF_SCSI_QCMD(sas_queuecommand)
+
 static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)
 {
 	struct sas_task *task = TO_SAS_TASK(cmd);
diff -urN linux-2.6.37-rc2/drivers/scsi/lpfc/lpfc_scsi.c linux-2.6.37-rc3/drivers/scsi/lpfc/lpfc_scsi.c
--- linux-2.6.37-rc2/drivers/scsi/lpfc/lpfc_scsi.c	2010-11-21 23:40:11.730169847 +0000
+++ linux-2.6.37-rc3/drivers/scsi/lpfc/lpfc_scsi.c	2010-11-21 23:40:17.256080166 +0000
@@ -2899,7 +2899,7 @@
  *   SCSI_MLQUEUE_HOST_BUSY - Block all devices served by this host temporarily.
  **/
 static int
-lpfc_queuecommand(struct scsi_cmnd *cmnd, void (*done) (struct scsi_cmnd *))
+lpfc_queuecommand_lck(struct scsi_cmnd *cmnd, void (*done) (struct scsi_cmnd *))
 {
 	struct Scsi_Host  *shost = cmnd->device->host;
 	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
@@ -3060,6 +3060,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(lpfc_queuecommand)
+
 /**
  * lpfc_abort_handler - scsi_host_template eh_abort_handler entry point
  * @cmnd: Pointer to scsi_cmnd data structure.
diff -urN linux-2.6.37-rc2/drivers/scsi/mac53c94.c linux-2.6.37-rc3/drivers/scsi/mac53c94.c
--- linux-2.6.37-rc2/drivers/scsi/mac53c94.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/mac53c94.c	2010-11-21 23:40:17.258075506 +0000
@@ -66,7 +66,7 @@
 static void set_dma_cmds(struct fsc_state *, struct scsi_cmnd *);
 
 
-static int mac53c94_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+static int mac53c94_queue_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct fsc_state *state;
 
@@ -99,6 +99,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(mac53c94_queue)
+
 static int mac53c94_host_reset(struct scsi_cmnd *cmd)
 {
 	struct fsc_state *state = (struct fsc_state *) cmd->device->host->hostdata;
diff -urN linux-2.6.37-rc2/drivers/scsi/megaraid/megaraid_mbox.c linux-2.6.37-rc3/drivers/scsi/megaraid/megaraid_mbox.c
--- linux-2.6.37-rc2/drivers/scsi/megaraid/megaraid_mbox.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/megaraid/megaraid_mbox.c	2010-11-21 23:40:17.260099171 +0000
@@ -113,8 +113,7 @@
 static void megaraid_mbox_display_scb(adapter_t *, scb_t *);
 static void megaraid_mbox_setup_device_map(adapter_t *);
 
-static int megaraid_queue_command(struct scsi_cmnd *,
-		void (*)(struct scsi_cmnd *));
+static int megaraid_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static scb_t *megaraid_mbox_build_cmd(adapter_t *, struct scsi_cmnd *, int *);
 static void megaraid_mbox_runpendq(adapter_t *, scb_t *);
 static void megaraid_mbox_prepare_pthru(adapter_t *, scb_t *,
@@ -1484,7 +1483,7 @@
  * Queue entry point for mailbox based controllers.
  */
 static int
-megaraid_queue_command(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
+megaraid_queue_command_lck(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 {
 	adapter_t	*adapter;
 	scb_t		*scb;
@@ -1513,6 +1512,8 @@
 	return if_busy;
 }
 
+static DEF_SCSI_QCMD(megaraid_queue_command)
+
 /**
  * megaraid_mbox_build_cmd - transform the mid-layer scsi commands
  * @adapter	: controller's soft state
diff -urN linux-2.6.37-rc2/drivers/scsi/megaraid/megaraid_sas.c linux-2.6.37-rc3/drivers/scsi/megaraid/megaraid_sas.c
--- linux-2.6.37-rc2/drivers/scsi/megaraid/megaraid_sas.c	2010-11-21 23:40:11.735047020 +0000
+++ linux-2.6.37-rc3/drivers/scsi/megaraid/megaraid_sas.c	2010-11-21 23:40:17.261077614 +0000
@@ -1334,7 +1334,7 @@
  * @done:			Callback entry point
  */
 static int
-megasas_queue_command(struct scsi_cmnd *scmd, void (*done) (struct scsi_cmnd *))
+megasas_queue_command_lck(struct scsi_cmnd *scmd, void (*done) (struct scsi_cmnd *))
 {
 	u32 frame_count;
 	struct megasas_cmd *cmd;
@@ -1417,6 +1417,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(megasas_queue_command)
+
 static struct megasas_instance *megasas_lookup_instance(u16 host_no)
 {
 	int i;
diff -urN linux-2.6.37-rc2/drivers/scsi/megaraid.c linux-2.6.37-rc3/drivers/scsi/megaraid.c
--- linux-2.6.37-rc2/drivers/scsi/megaraid.c	2010-11-21 23:40:11.734168612 +0000
+++ linux-2.6.37-rc3/drivers/scsi/megaraid.c	2010-11-21 23:40:17.259064942 +0000
@@ -366,7 +366,7 @@
  * The command queuing entry point for the mid-layer.
  */
 static int
-megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
+megaraid_queue_lck(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
 {
 	adapter_t	*adapter;
 	scb_t	*scb;
@@ -409,6 +409,8 @@
 	return busy;
 }
 
+static DEF_SCSI_QCMD(megaraid_queue)
+
 /**
  * mega_allocate_scb()
  * @adapter - pointer to our soft state
@@ -4456,7 +4458,7 @@
 
 	scb->idx = CMDID_INT_CMDS;
 
-	megaraid_queue(scmd, mega_internal_done);
+	megaraid_queue_lck(scmd, mega_internal_done);
 
 	wait_for_completion(&adapter->int_waitq);
 
diff -urN linux-2.6.37-rc2/drivers/scsi/megaraid.h linux-2.6.37-rc3/drivers/scsi/megaraid.h
--- linux-2.6.37-rc2/drivers/scsi/megaraid.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/megaraid.h	2010-11-21 23:40:17.259064942 +0000
@@ -987,7 +987,7 @@
 static int issue_scb(adapter_t *, scb_t *);
 static int mega_setup_mailbox(adapter_t *);
 
-static int megaraid_queue (Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
+static int megaraid_queue (struct Scsi_Host *, struct scsi_cmnd *);
 static scb_t * mega_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
 static void __mega_runpendq(adapter_t *);
 static int issue_scb_block(adapter_t *, u_char *);
diff -urN linux-2.6.37-rc2/drivers/scsi/mesh.c linux-2.6.37-rc3/drivers/scsi/mesh.c
--- linux-2.6.37-rc2/drivers/scsi/mesh.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/mesh.c	2010-11-21 23:40:17.262102216 +0000
@@ -1627,7 +1627,7 @@
  * Called by midlayer with host locked to queue a new
  * request
  */
-static int mesh_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+static int mesh_queue_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct mesh_state *ms;
 
@@ -1648,6 +1648,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(mesh_queue)
+
 /*
  * Called to handle interrupts, either call by the interrupt
  * handler (do_mesh_interrupt) or by other functions in
diff -urN linux-2.6.37-rc2/drivers/scsi/mpt2sas/mpt2sas_scsih.c linux-2.6.37-rc3/drivers/scsi/mpt2sas/mpt2sas_scsih.c
--- linux-2.6.37-rc2/drivers/scsi/mpt2sas/mpt2sas_scsih.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/mpt2sas/mpt2sas_scsih.c	2010-11-21 23:40:17.263079857 +0000
@@ -3315,7 +3315,7 @@
  * SCSI_MLQUEUE_HOST_BUSY if the entire host queue is full
  */
 static int
-_scsih_qcmd(struct scsi_cmnd *scmd, void (*done)(struct scsi_cmnd *))
+_scsih_qcmd_lck(struct scsi_cmnd *scmd, void (*done)(struct scsi_cmnd *))
 {
 	struct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);
 	struct MPT2SAS_DEVICE *sas_device_priv_data;
@@ -3441,6 +3441,8 @@
 	return SCSI_MLQUEUE_HOST_BUSY;
 }
 
+static DEF_SCSI_QCMD(_scsih_qcmd)
+
 /**
  * _scsih_normalize_sense - normalize descriptor and fixed format sense data
  * @sense_buffer: sense data returned by target
diff -urN linux-2.6.37-rc2/drivers/scsi/ncr53c8xx.c linux-2.6.37-rc3/drivers/scsi/ncr53c8xx.c
--- linux-2.6.37-rc2/drivers/scsi/ncr53c8xx.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ncr53c8xx.c	2010-11-21 23:40:17.264098624 +0000
@@ -8029,7 +8029,7 @@
 	return 0;
 }
 
-static int ncr53c8xx_queue_command (struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
+static int ncr53c8xx_queue_command_lck (struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
      struct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;
      unsigned long flags;
@@ -8068,6 +8068,8 @@
      return sts;
 }
 
+static DEF_SCSI_QCMD(ncr53c8xx_queue_command)
+
 irqreturn_t ncr53c8xx_intr(int irq, void *dev_id)
 {
      unsigned long flags;
diff -urN linux-2.6.37-rc2/drivers/scsi/nsp32.c linux-2.6.37-rc3/drivers/scsi/nsp32.c
--- linux-2.6.37-rc2/drivers/scsi/nsp32.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/nsp32.c	2010-11-21 23:40:17.265076227 +0000
@@ -196,8 +196,7 @@
 static int         nsp32_proc_info   (struct Scsi_Host *, char *, char **, off_t, int, int);
 
 static int         nsp32_detect      (struct pci_dev *pdev);
-static int         nsp32_queuecommand(struct scsi_cmnd *,
-		void (*done)(struct scsi_cmnd *));
+static int         nsp32_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 static const char *nsp32_info        (struct Scsi_Host *);
 static int         nsp32_release     (struct Scsi_Host *);
 
@@ -909,7 +908,7 @@
 	return TRUE;
 }
 
-static int nsp32_queuecommand(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+static int nsp32_queuecommand_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
 	nsp32_target *target;
@@ -1050,6 +1049,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(nsp32_queuecommand)
+
 /* initialize asic */
 static int nsp32hw_init(nsp32_hw_data *data)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/pas16.h linux-2.6.37-rc3/drivers/scsi/pas16.h
--- linux-2.6.37-rc2/drivers/scsi/pas16.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/pas16.h	2010-11-21 23:40:17.266100262 +0000
@@ -118,7 +118,7 @@
 static int pas16_biosparam(struct scsi_device *, struct block_device *,
 			   sector_t, int*);
 static int pas16_detect(struct scsi_host_template *);
-static int pas16_queue_command(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
+static int pas16_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static int pas16_bus_reset(Scsi_Cmnd *);
 
 #ifndef CMD_PER_LUN
diff -urN linux-2.6.37-rc2/drivers/scsi/pcmcia/nsp_cs.c linux-2.6.37-rc3/drivers/scsi/pcmcia/nsp_cs.c
--- linux-2.6.37-rc2/drivers/scsi/pcmcia/nsp_cs.c	2010-11-21 23:40:11.739243142 +0000
+++ linux-2.6.37-rc3/drivers/scsi/pcmcia/nsp_cs.c	2010-11-21 23:40:17.267078160 +0000
@@ -184,7 +184,7 @@
 	SCpnt->scsi_done(SCpnt);
 }
 
-static int nsp_queuecommand(struct scsi_cmnd *SCpnt,
+static int nsp_queuecommand_lck(struct scsi_cmnd *SCpnt,
 			    void (*done)(struct scsi_cmnd *))
 {
 #ifdef NSP_DEBUG
@@ -264,6 +264,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(nsp_queuecommand)
+
 /*
  * setup PIO FIFO transfer mode and enable/disable to data out
  */
diff -urN linux-2.6.37-rc2/drivers/scsi/pcmcia/nsp_cs.h linux-2.6.37-rc3/drivers/scsi/pcmcia/nsp_cs.h
--- linux-2.6.37-rc2/drivers/scsi/pcmcia/nsp_cs.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/pcmcia/nsp_cs.h	2010-11-21 23:40:17.267078160 +0000
@@ -299,8 +299,7 @@
 					 off_t   offset,
 					 int     length,
 					 int     inout);
-static int nsp_queuecommand(struct scsi_cmnd *SCpnt,
-			    void (* done)(struct scsi_cmnd *SCpnt));
+static int nsp_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *SCpnt);
 
 /* Error handler */
 /*static int nsp_eh_abort       (struct scsi_cmnd *SCpnt);*/
diff -urN linux-2.6.37-rc2/drivers/scsi/pcmcia/sym53c500_cs.c linux-2.6.37-rc3/drivers/scsi/pcmcia/sym53c500_cs.c
--- linux-2.6.37-rc2/drivers/scsi/pcmcia/sym53c500_cs.c	2010-11-21 23:40:11.739243142 +0000
+++ linux-2.6.37-rc3/drivers/scsi/pcmcia/sym53c500_cs.c	2010-11-21 23:40:17.267078160 +0000
@@ -547,7 +547,7 @@
 }
 
 static int 
-SYM53C500_queue(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
+SYM53C500_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))
 {
 	int i;
 	int port_base = SCpnt->device->host->io_port;
@@ -583,6 +583,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(SYM53C500_queue)
+
 static int 
 SYM53C500_host_reset(struct scsi_cmnd *SCpnt)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/pm8001/pm8001_sas.h linux-2.6.37-rc3/drivers/scsi/pm8001/pm8001_sas.h
--- linux-2.6.37-rc2/drivers/scsi/pm8001/pm8001_sas.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/pm8001/pm8001_sas.h	2010-11-21 23:40:17.268102724 +0000
@@ -50,7 +50,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
-#include <linux/smp_lock.h>
 #include <scsi/libsas.h>
 #include <scsi/scsi_tcq.h>
 #include <scsi/sas_ata.h>
diff -urN linux-2.6.37-rc2/drivers/scsi/pmcraid.c linux-2.6.37-rc3/drivers/scsi/pmcraid.c
--- linux-2.6.37-rc2/drivers/scsi/pmcraid.c	2010-11-21 23:40:11.741239694 +0000
+++ linux-2.6.37-rc3/drivers/scsi/pmcraid.c	2010-11-21 23:40:17.269062923 +0000
@@ -3478,7 +3478,7 @@
  *	  SCSI_MLQUEUE_DEVICE_BUSY if device is busy
  *	  SCSI_MLQUEUE_HOST_BUSY if host is busy
  */
-static int pmcraid_queuecommand(
+static int pmcraid_queuecommand_lck(
 	struct scsi_cmnd *scsi_cmd,
 	void (*done) (struct scsi_cmnd *)
 )
@@ -3584,6 +3584,8 @@
 	return rc;
 }
 
+static DEF_SCSI_QCMD(pmcraid_queuecommand)
+
 /**
  * pmcraid_open -char node "open" entry, allowed only users with admin access
  */
diff -urN linux-2.6.37-rc2/drivers/scsi/ppa.c linux-2.6.37-rc3/drivers/scsi/ppa.c
--- linux-2.6.37-rc2/drivers/scsi/ppa.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ppa.c	2010-11-21 23:40:17.269062923 +0000
@@ -798,7 +798,7 @@
 	return 0;
 }
 
-static int ppa_queuecommand(struct scsi_cmnd *cmd,
+static int ppa_queuecommand_lck(struct scsi_cmnd *cmd,
 		void (*done) (struct scsi_cmnd *))
 {
 	ppa_struct *dev = ppa_dev(cmd->device->host);
@@ -821,6 +821,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(ppa_queuecommand)
+
 /*
  * Apparently the disk->capacity attribute is off by 1 sector 
  * for all disk drives.  We add the one here, but it should really
diff -urN linux-2.6.37-rc2/drivers/scsi/ps3rom.c linux-2.6.37-rc3/drivers/scsi/ps3rom.c
--- linux-2.6.37-rc2/drivers/scsi/ps3rom.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ps3rom.c	2010-11-21 23:40:17.269062923 +0000
@@ -211,7 +211,7 @@
 	return 0;
 }
 
-static int ps3rom_queuecommand(struct scsi_cmnd *cmd,
+static int ps3rom_queuecommand_lck(struct scsi_cmnd *cmd,
 			       void (*done)(struct scsi_cmnd *))
 {
 	struct ps3rom_private *priv = shost_priv(cmd->device->host);
@@ -260,6 +260,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(ps3rom_queuecommand)
+
 static int decode_lv1_status(u64 status, unsigned char *sense_key,
 			     unsigned char *asc, unsigned char *ascq)
 {
diff -urN linux-2.6.37-rc2/drivers/scsi/qla1280.c linux-2.6.37-rc3/drivers/scsi/qla1280.c
--- linux-2.6.37-rc2/drivers/scsi/qla1280.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/qla1280.c	2010-11-21 23:40:17.270097582 +0000
@@ -727,7 +727,7 @@
  * context which is a big NO! NO!.
  **************************************************************************/
 static int
-qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
+qla1280_queuecommand_lck(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = cmd->device->host;
 	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
@@ -756,6 +756,8 @@
 	return status;
 }
 
+static DEF_SCSI_QCMD(qla1280_queuecommand)
+
 enum action {
 	ABORT_COMMAND,
 	DEVICE_RESET,
diff -urN linux-2.6.37-rc2/drivers/scsi/qla2xxx/qla_os.c linux-2.6.37-rc3/drivers/scsi/qla2xxx/qla_os.c
--- linux-2.6.37-rc2/drivers/scsi/qla2xxx/qla_os.c	2010-11-21 23:40:11.747242809 +0000
+++ linux-2.6.37-rc3/drivers/scsi/qla2xxx/qla_os.c	2010-11-21 23:40:17.274102202 +0000
@@ -179,8 +179,7 @@
 static int qla2xxx_scan_finished(struct Scsi_Host *, unsigned long time);
 static void qla2xxx_scan_start(struct Scsi_Host *);
 static void qla2xxx_slave_destroy(struct scsi_device *);
-static int qla2xxx_queuecommand(struct scsi_cmnd *cmd,
-		void (*fn)(struct scsi_cmnd *));
+static int qla2xxx_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 static int qla2xxx_eh_abort(struct scsi_cmnd *);
 static int qla2xxx_eh_device_reset(struct scsi_cmnd *);
 static int qla2xxx_eh_target_reset(struct scsi_cmnd *);
@@ -535,7 +534,7 @@
 }
 
 static int
-qla2xxx_queuecommand(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+qla2xxx_queuecommand_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	scsi_qla_host_t *vha = shost_priv(cmd->device->host);
 	fc_port_t *fcport = (struct fc_port *) cmd->device->hostdata;
@@ -609,6 +608,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(qla2xxx_queuecommand)
+
 
 /*
  * qla2x00_eh_wait_on_command
diff -urN linux-2.6.37-rc2/drivers/scsi/qla4xxx/ql4_os.c linux-2.6.37-rc3/drivers/scsi/qla4xxx/ql4_os.c
--- linux-2.6.37-rc2/drivers/scsi/qla4xxx/ql4_os.c	2010-11-21 23:40:11.750168753 +0000
+++ linux-2.6.37-rc3/drivers/scsi/qla4xxx/ql4_os.c	2010-11-21 23:40:17.277077638 +0000
@@ -79,8 +79,7 @@
 /*
  * SCSI host template entry points
  */
-static int qla4xxx_queuecommand(struct scsi_cmnd *cmd,
-				void (*done) (struct scsi_cmnd *));
+static int qla4xxx_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 static int qla4xxx_eh_abort(struct scsi_cmnd *cmd);
 static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd);
 static int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd);
@@ -464,7 +463,7 @@
  * completion handling).   Unfortunely, it sometimes calls the scheduler
  * in interrupt context which is a big NO! NO!.
  **/
-static int qla4xxx_queuecommand(struct scsi_cmnd *cmd,
+static int qla4xxx_queuecommand_lck(struct scsi_cmnd *cmd,
 				void (*done)(struct scsi_cmnd *))
 {
 	struct scsi_qla_host *ha = to_qla_host(cmd->device->host);
@@ -538,6 +537,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(qla4xxx_queuecommand)
+
 /**
  * qla4xxx_mem_free - frees memory allocated to adapter
  * @ha: Pointer to host adapter structure.
diff -urN linux-2.6.37-rc2/drivers/scsi/qlogicfas408.c linux-2.6.37-rc3/drivers/scsi/qlogicfas408.c
--- linux-2.6.37-rc2/drivers/scsi/qlogicfas408.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/qlogicfas408.c	2010-11-21 23:40:17.277077638 +0000
@@ -439,7 +439,7 @@
  *	Queued command
  */
 
-int qlogicfas408_queuecommand(struct scsi_cmnd *cmd,
+static int qlogicfas408_queuecommand_lck(struct scsi_cmnd *cmd,
 			      void (*done) (struct scsi_cmnd *))
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
@@ -459,6 +459,8 @@
 	return 0;
 }
 
+DEF_SCSI_QCMD(qlogicfas408_queuecommand)
+
 /* 
  *	Return bios parameters 
  */
diff -urN linux-2.6.37-rc2/drivers/scsi/qlogicfas408.h linux-2.6.37-rc3/drivers/scsi/qlogicfas408.h
--- linux-2.6.37-rc2/drivers/scsi/qlogicfas408.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/qlogicfas408.h	2010-11-21 23:40:17.277077638 +0000
@@ -103,8 +103,7 @@
 #define get_priv_by_host(x) (struct qlogicfas408_priv *)&((x)->hostdata[0])
 
 irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id);
-int qlogicfas408_queuecommand(struct scsi_cmnd * cmd,
-			      void (*done) (struct scsi_cmnd *));
+int qlogicfas408_queuecommand(struct Scsi_Host *h, struct scsi_cmnd * cmd);
 int qlogicfas408_biosparam(struct scsi_device * disk,
 			   struct block_device *dev,
 			   sector_t capacity, int ip[]);
diff -urN linux-2.6.37-rc2/drivers/scsi/qlogicpti.c linux-2.6.37-rc3/drivers/scsi/qlogicpti.c
--- linux-2.6.37-rc2/drivers/scsi/qlogicpti.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/qlogicpti.c	2010-11-21 23:40:17.277077638 +0000
@@ -1003,7 +1003,7 @@
  *
  * "This code must fly." -davem
  */
-static int qlogicpti_queuecommand(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *))
+static int qlogicpti_queuecommand_lck(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = Cmnd->device->host;
 	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
@@ -1052,6 +1052,8 @@
 	return 1;
 }
 
+static DEF_SCSI_QCMD(qlogicpti_queuecommand)
+
 static int qlogicpti_return_status(struct Status_Entry *sts, int id)
 {
 	int host_status = DID_ERROR;
diff -urN linux-2.6.37-rc2/drivers/scsi/scsi.c linux-2.6.37-rc3/drivers/scsi/scsi.c
--- linux-2.6.37-rc2/drivers/scsi/scsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/scsi.c	2010-11-21 23:40:17.277077638 +0000
@@ -634,12 +634,13 @@
  * Description: a serial number identifies a request for error recovery
  * and debugging purposes.  Protected by the Host_Lock of host.
  */
-static inline void scsi_cmd_get_serial(struct Scsi_Host *host, struct scsi_cmnd *cmd)
+void scsi_cmd_get_serial(struct Scsi_Host *host, struct scsi_cmnd *cmd)
 {
 	cmd->serial_number = host->cmd_serial_number++;
 	if (cmd->serial_number == 0) 
 		cmd->serial_number = host->cmd_serial_number++;
 }
+EXPORT_SYMBOL(scsi_cmd_get_serial);
 
 /**
  * scsi_dispatch_command - Dispatch a command to the low-level driver.
@@ -651,7 +652,6 @@
 int scsi_dispatch_cmd(struct scsi_cmnd *cmd)
 {
 	struct Scsi_Host *host = cmd->device->host;
-	unsigned long flags = 0;
 	unsigned long timeout;
 	int rtn = 0;
 
@@ -737,23 +737,15 @@
 		goto out;
 	}
 
-	spin_lock_irqsave(host->host_lock, flags);
-	/*
-	 * AK: unlikely race here: for some reason the timer could
-	 * expire before the serial number is set up below.
-	 *
-	 * TODO: kill serial or move to blk layer
-	 */
-	scsi_cmd_get_serial(host, cmd); 
-
 	if (unlikely(host->shost_state == SHOST_DEL)) {
 		cmd->result = (DID_NO_CONNECT << 16);
 		scsi_done(cmd);
 	} else {
 		trace_scsi_dispatch_cmd_start(cmd);
-		rtn = host->hostt->queuecommand(cmd, scsi_done);
+		cmd->scsi_done = scsi_done;
+		rtn = host->hostt->queuecommand(host, cmd);
 	}
-	spin_unlock_irqrestore(host->host_lock, flags);
+
 	if (rtn) {
 		trace_scsi_dispatch_cmd_error(cmd, rtn);
 		if (rtn != SCSI_MLQUEUE_DEVICE_BUSY &&
diff -urN linux-2.6.37-rc2/drivers/scsi/scsi_debug.c linux-2.6.37-rc3/drivers/scsi/scsi_debug.c
--- linux-2.6.37-rc2/drivers/scsi/scsi_debug.c	2010-11-21 23:40:11.750168753 +0000
+++ linux-2.6.37-rc3/drivers/scsi/scsi_debug.c	2010-11-21 23:40:17.278062744 +0000
@@ -3538,7 +3538,7 @@
 }
 
 static
-int scsi_debug_queuecommand(struct scsi_cmnd *SCpnt, done_funct_t done)
+int scsi_debug_queuecommand_lck(struct scsi_cmnd *SCpnt, done_funct_t done)
 {
 	unsigned char *cmd = (unsigned char *) SCpnt->cmnd;
 	int len, k;
@@ -3884,6 +3884,8 @@
 			     (delay_override ? 0 : scsi_debug_delay));
 }
 
+static DEF_SCSI_QCMD(scsi_debug_queuecommand)
+
 static struct scsi_host_template sdebug_driver_template = {
 	.proc_info =		scsi_debug_proc_info,
 	.proc_name =		sdebug_proc_name,
diff -urN linux-2.6.37-rc2/drivers/scsi/scsi_error.c linux-2.6.37-rc3/drivers/scsi/scsi_error.c
--- linux-2.6.37-rc2/drivers/scsi/scsi_error.c	2010-11-21 23:40:11.751168757 +0000
+++ linux-2.6.37-rc3/drivers/scsi/scsi_error.c	2010-11-21 23:40:17.278062744 +0000
@@ -773,17 +773,15 @@
 	struct Scsi_Host *shost = sdev->host;
 	DECLARE_COMPLETION_ONSTACK(done);
 	unsigned long timeleft;
-	unsigned long flags;
 	struct scsi_eh_save ses;
 	int rtn;
 
 	scsi_eh_prep_cmnd(scmd, &ses, cmnd, cmnd_size, sense_bytes);
 	shost->eh_action = &done;
 
-	spin_lock_irqsave(shost->host_lock, flags);
 	scsi_log_send(scmd);
-	shost->hostt->queuecommand(scmd, scsi_eh_done);
-	spin_unlock_irqrestore(shost->host_lock, flags);
+	scmd->scsi_done = scsi_eh_done;
+	shost->hostt->queuecommand(shost, scmd);
 
 	timeleft = wait_for_completion_timeout(&done, timeout);
 
diff -urN linux-2.6.37-rc2/drivers/scsi/sd.c linux-2.6.37-rc3/drivers/scsi/sd.c
--- linux-2.6.37-rc2/drivers/scsi/sd.c	2010-11-21 23:40:11.753167972 +0000
+++ linux-2.6.37-rc3/drivers/scsi/sd.c	2010-11-21 23:40:17.280102532 +0000
@@ -46,7 +46,6 @@
 #include <linux/blkdev.h>
 #include <linux/blkpg.h>
 #include <linux/delay.h>
-#include <linux/smp_lock.h>
 #include <linux/mutex.h>
 #include <linux/string_helpers.h>
 #include <linux/async.h>
diff -urN linux-2.6.37-rc2/drivers/scsi/stex.c linux-2.6.37-rc3/drivers/scsi/stex.c
--- linux-2.6.37-rc2/drivers/scsi/stex.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/stex.c	2010-11-21 23:40:17.282100448 +0000
@@ -572,7 +572,7 @@
 }
 
 static int
-stex_queuecommand(struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
+stex_queuecommand_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct st_hba *hba;
 	struct Scsi_Host *host;
@@ -698,6 +698,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(stex_queuecommand)
+
 static void stex_scsi_done(struct st_ccb *ccb)
 {
 	struct scsi_cmnd *cmd = ccb->cmd;
diff -urN linux-2.6.37-rc2/drivers/scsi/sun3_NCR5380.c linux-2.6.37-rc3/drivers/scsi/sun3_NCR5380.c
--- linux-2.6.37-rc2/drivers/scsi/sun3_NCR5380.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/sun3_NCR5380.c	2010-11-21 23:40:17.283079448 +0000
@@ -908,7 +908,7 @@
  */
 
 /* Only make static if a wrapper function is used */
-static int NCR5380_queue_command(struct scsi_cmnd *cmd,
+static int NCR5380_queue_command_lck(struct scsi_cmnd *cmd,
 				 void (*done)(struct scsi_cmnd *))
 {
     SETUP_HOSTDATA(cmd->device->host);
@@ -1019,6 +1019,8 @@
     return 0;
 }
 
+static DEF_SCSI_QCMD(NCR5380_queue_command)
+
 /*
  * Function : NCR5380_main (void) 
  *
diff -urN linux-2.6.37-rc2/drivers/scsi/sun3_scsi.h linux-2.6.37-rc3/drivers/scsi/sun3_scsi.h
--- linux-2.6.37-rc2/drivers/scsi/sun3_scsi.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/sun3_scsi.h	2010-11-21 23:40:17.283079448 +0000
@@ -51,8 +51,7 @@
 static int sun3scsi_detect (struct scsi_host_template *);
 static const char *sun3scsi_info (struct Scsi_Host *);
 static int sun3scsi_bus_reset(struct scsi_cmnd *);
-static int sun3scsi_queue_command(struct scsi_cmnd *,
-				  void (*done)(struct scsi_cmnd *));
+static int sun3scsi_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static int sun3scsi_release (struct Scsi_Host *);
 
 #ifndef CMD_PER_LUN
diff -urN linux-2.6.37-rc2/drivers/scsi/sym53c416.c linux-2.6.37-rc3/drivers/scsi/sym53c416.c
--- linux-2.6.37-rc2/drivers/scsi/sym53c416.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/sym53c416.c	2010-11-21 23:40:17.283079448 +0000
@@ -734,7 +734,7 @@
 	return info;
 }
 
-int sym53c416_queuecommand(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
+static int sym53c416_queuecommand_lck(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
 {
 	int base;
 	unsigned long flags = 0;
@@ -761,6 +761,8 @@
 	return 0;
 }
 
+DEF_SCSI_QCMD(sym53c416_queuecommand)
+
 static int sym53c416_host_reset(Scsi_Cmnd *SCpnt)
 {
 	int base;
diff -urN linux-2.6.37-rc2/drivers/scsi/sym53c416.h linux-2.6.37-rc3/drivers/scsi/sym53c416.h
--- linux-2.6.37-rc2/drivers/scsi/sym53c416.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/sym53c416.h	2010-11-21 23:40:17.283079448 +0000
@@ -25,7 +25,7 @@
 static int sym53c416_detect(struct scsi_host_template *);
 static const char *sym53c416_info(struct Scsi_Host *);
 static int sym53c416_release(struct Scsi_Host *);
-static int sym53c416_queuecommand(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
+static int sym53c416_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 static int sym53c416_host_reset(Scsi_Cmnd *);
 static int sym53c416_bios_param(struct scsi_device *, struct block_device *,
 		sector_t, int *);
diff -urN linux-2.6.37-rc2/drivers/scsi/sym53c8xx_2/sym_glue.c linux-2.6.37-rc3/drivers/scsi/sym53c8xx_2/sym_glue.c
--- linux-2.6.37-rc2/drivers/scsi/sym53c8xx_2/sym_glue.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/sym53c8xx_2/sym_glue.c	2010-11-21 23:40:17.283079448 +0000
@@ -505,7 +505,7 @@
  * queuecommand method.  Entered with the host adapter lock held and
  * interrupts disabled.
  */
-static int sym53c8xx_queue_command(struct scsi_cmnd *cmd,
+static int sym53c8xx_queue_command_lck(struct scsi_cmnd *cmd,
 					void (*done)(struct scsi_cmnd *))
 {
 	struct sym_hcb *np = SYM_SOFTC_PTR(cmd);
@@ -536,6 +536,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(sym53c8xx_queue_command)
+
 /*
  *  Linux entry point of the interrupt handler.
  */
diff -urN linux-2.6.37-rc2/drivers/scsi/t128.h linux-2.6.37-rc3/drivers/scsi/t128.h
--- linux-2.6.37-rc2/drivers/scsi/t128.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/t128.h	2010-11-21 23:40:17.283079448 +0000
@@ -96,8 +96,7 @@
 static int t128_biosparam(struct scsi_device *, struct block_device *,
 			  sector_t, int*);
 static int t128_detect(struct scsi_host_template *);
-static int t128_queue_command(struct scsi_cmnd *,
-			      void (*done)(struct scsi_cmnd *));
+static int t128_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static int t128_bus_reset(struct scsi_cmnd *);
 
 #ifndef CMD_PER_LUN
diff -urN linux-2.6.37-rc2/drivers/scsi/tmscsim.c linux-2.6.37-rc3/drivers/scsi/tmscsim.c
--- linux-2.6.37-rc2/drivers/scsi/tmscsim.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/tmscsim.c	2010-11-21 23:40:17.284098528 +0000
@@ -1883,7 +1883,7 @@
     return;
 }
 
-static int DC390_queuecommand(struct scsi_cmnd *cmd,
+static int DC390_queuecommand_lck(struct scsi_cmnd *cmd,
 		void (*done)(struct scsi_cmnd *))
 {
 	struct scsi_device *sdev = cmd->device;
@@ -1944,6 +1944,8 @@
 	return SCSI_MLQUEUE_DEVICE_BUSY;
 }
 
+static DEF_SCSI_QCMD(DC390_queuecommand)
+
 static void dc390_dumpinfo (struct dc390_acb* pACB, struct dc390_dcb* pDCB, struct dc390_srb* pSRB)
 {
     struct pci_dev *pdev;
diff -urN linux-2.6.37-rc2/drivers/scsi/u14-34f.c linux-2.6.37-rc3/drivers/scsi/u14-34f.c
--- linux-2.6.37-rc2/drivers/scsi/u14-34f.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/u14-34f.c	2010-11-21 23:40:17.284098528 +0000
@@ -433,7 +433,7 @@
 
 static int u14_34f_detect(struct scsi_host_template *);
 static int u14_34f_release(struct Scsi_Host *);
-static int u14_34f_queuecommand(struct scsi_cmnd *, void (*done)(struct scsi_cmnd *));
+static int u14_34f_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 static int u14_34f_eh_abort(struct scsi_cmnd *);
 static int u14_34f_eh_host_reset(struct scsi_cmnd *);
 static int u14_34f_bios_param(struct scsi_device *, struct block_device *,
@@ -1248,7 +1248,7 @@
 
 }
 
-static int u14_34f_queuecommand(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *)) {
+static int u14_34f_queuecommand_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *)) {
    unsigned int i, j, k;
    struct mscp *cpp;
 
@@ -1329,6 +1329,8 @@
    return 0;
 }
 
+static DEF_SCSI_QCMD(u14_34f_queuecommand)
+
 static int u14_34f_eh_abort(struct scsi_cmnd *SCarg) {
    unsigned int i, j;
 
diff -urN linux-2.6.37-rc2/drivers/scsi/ultrastor.c linux-2.6.37-rc3/drivers/scsi/ultrastor.c
--- linux-2.6.37-rc2/drivers/scsi/ultrastor.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ultrastor.c	2010-11-21 23:40:17.284098528 +0000
@@ -700,7 +700,7 @@
 	mscp->transfer_data_length = transfer_length;
 }
 
-static int ultrastor_queuecommand(struct scsi_cmnd *SCpnt,
+static int ultrastor_queuecommand_lck(struct scsi_cmnd *SCpnt,
 				void (*done) (struct scsi_cmnd *))
 {
     struct mscp *my_mscp;
@@ -825,6 +825,8 @@
     return 0;
 }
 
+static DEF_SCSI_QCMD(ultrastor_queuecommand)
+
 /* This code must deal with 2 cases:
 
    1. The command has not been written to the OGM.  In this case, set
diff -urN linux-2.6.37-rc2/drivers/scsi/ultrastor.h linux-2.6.37-rc3/drivers/scsi/ultrastor.h
--- linux-2.6.37-rc2/drivers/scsi/ultrastor.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/ultrastor.h	2010-11-21 23:40:17.284098528 +0000
@@ -15,8 +15,7 @@
 
 static int ultrastor_detect(struct scsi_host_template *);
 static const char *ultrastor_info(struct Scsi_Host *shpnt);
-static int ultrastor_queuecommand(struct scsi_cmnd *,
-				void (*done)(struct scsi_cmnd *));
+static int ultrastor_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 static int ultrastor_abort(struct scsi_cmnd *);
 static int ultrastor_host_reset(struct scsi_cmnd *);
 static int ultrastor_biosparam(struct scsi_device *, struct block_device *,
diff -urN linux-2.6.37-rc2/drivers/scsi/vmw_pvscsi.c linux-2.6.37-rc3/drivers/scsi/vmw_pvscsi.c
--- linux-2.6.37-rc2/drivers/scsi/vmw_pvscsi.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/vmw_pvscsi.c	2010-11-21 23:40:17.284098528 +0000
@@ -690,7 +690,7 @@
 	return 0;
 }
 
-static int pvscsi_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+static int pvscsi_queue_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = cmd->device->host;
 	struct pvscsi_adapter *adapter = shost_priv(host);
@@ -719,6 +719,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(pvscsi_queue)
+
 static int pvscsi_abort(struct scsi_cmnd *cmd)
 {
 	struct pvscsi_adapter *adapter = shost_priv(cmd->device->host);
diff -urN linux-2.6.37-rc2/drivers/scsi/wd33c93.c linux-2.6.37-rc3/drivers/scsi/wd33c93.c
--- linux-2.6.37-rc2/drivers/scsi/wd33c93.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/wd33c93.c	2010-11-21 23:40:17.285080891 +0000
@@ -371,8 +371,8 @@
 	msg[1] = offset;
 }
 
-int
-wd33c93_queuecommand(struct scsi_cmnd *cmd,
+static int
+wd33c93_queuecommand_lck(struct scsi_cmnd *cmd,
 		void (*done)(struct scsi_cmnd *))
 {
 	struct WD33C93_hostdata *hostdata;
@@ -468,6 +468,8 @@
 	return 0;
 }
 
+DEF_SCSI_QCMD(wd33c93_queuecommand)
+
 /*
  * This routine attempts to start a scsi command. If the host_card is
  * already connected, we give up immediately. Otherwise, look through
diff -urN linux-2.6.37-rc2/drivers/scsi/wd33c93.h linux-2.6.37-rc3/drivers/scsi/wd33c93.h
--- linux-2.6.37-rc2/drivers/scsi/wd33c93.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/wd33c93.h	2010-11-21 23:40:17.285080891 +0000
@@ -343,8 +343,7 @@
 void wd33c93_init (struct Scsi_Host *instance, const wd33c93_regs regs,
          dma_setup_t setup, dma_stop_t stop, int clock_freq);
 int wd33c93_abort (struct scsi_cmnd *cmd);
-int wd33c93_queuecommand (struct scsi_cmnd *cmd,
-		void (*done)(struct scsi_cmnd *));
+int wd33c93_queuecommand (struct Scsi_Host *h, struct scsi_cmnd *cmd);
 void wd33c93_intr (struct Scsi_Host *instance);
 int wd33c93_proc_info(struct Scsi_Host *, char *, char **, off_t, int, int);
 int wd33c93_host_reset (struct scsi_cmnd *);
diff -urN linux-2.6.37-rc2/drivers/scsi/wd7000.c linux-2.6.37-rc3/drivers/scsi/wd7000.c
--- linux-2.6.37-rc2/drivers/scsi/wd7000.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/scsi/wd7000.c	2010-11-21 23:40:17.285080891 +0000
@@ -1082,7 +1082,7 @@
 	return IRQ_HANDLED;
 }
 
-static int wd7000_queuecommand(struct scsi_cmnd *SCpnt,
+static int wd7000_queuecommand_lck(struct scsi_cmnd *SCpnt,
 		void (*done)(struct scsi_cmnd *))
 {
 	Scb *scb;
@@ -1139,6 +1139,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(wd7000_queuecommand)
+
 static int wd7000_diagnostics(Adapter * host, int code)
 {
 	static IcbDiag icb = { ICB_OP_DIAGNOSTICS };
diff -urN linux-2.6.37-rc2/drivers/serial/crisv10.c linux-2.6.37-rc3/drivers/serial/crisv10.c
--- linux-2.6.37-rc2/drivers/serial/crisv10.c	2010-11-21 23:40:11.758168440 +0000
+++ linux-2.6.37-rc3/drivers/serial/crisv10.c	2010-11-21 23:40:17.288101193 +0000
@@ -18,7 +18,6 @@
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
 #include <linux/major.h>
-#include <linux/smp_lock.h>
 #include <linux/string.h>
 #include <linux/fcntl.h>
 #include <linux/mm.h>
diff -urN linux-2.6.37-rc2/drivers/serial/serial_core.c linux-2.6.37-rc3/drivers/serial/serial_core.c
--- linux-2.6.37-rc2/drivers/serial/serial_core.c	2010-11-21 23:40:11.761168409 +0000
+++ linux-2.6.37-rc3/drivers/serial/serial_core.c	2010-11-21 23:40:17.291078839 +0000
@@ -29,7 +29,6 @@
 #include <linux/console.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-#include <linux/smp_lock.h>
 #include <linux/device.h>
 #include <linux/serial.h> /* for serial_state and serial_icounter_struct */
 #include <linux/serial_core.h>
diff -urN linux-2.6.37-rc2/drivers/staging/easycap/easycap.h linux-2.6.37-rc3/drivers/staging/easycap/easycap.h
--- linux-2.6.37-rc2/drivers/staging/easycap/easycap.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/staging/easycap/easycap.h	2010-11-21 23:40:17.508071043 +0000
@@ -77,7 +77,6 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/kref.h>
-#include <linux/smp_lock.h>
 #include <linux/usb.h>
 #include <linux/uaccess.h>
 
diff -urN linux-2.6.37-rc2/drivers/staging/hv/storvsc_drv.c linux-2.6.37-rc3/drivers/staging/hv/storvsc_drv.c
--- linux-2.6.37-rc2/drivers/staging/hv/storvsc_drv.c	2010-11-21 23:40:12.098198865 +0000
+++ linux-2.6.37-rc3/drivers/staging/hv/storvsc_drv.c	2010-11-21 23:40:17.519085501 +0000
@@ -72,8 +72,7 @@
 
 /* Static decl */
 static int storvsc_probe(struct device *dev);
-static int storvsc_queuecommand(struct scsi_cmnd *scmnd,
-				void (*done)(struct scsi_cmnd *));
+static int storvsc_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scmnd);
 static int storvsc_device_alloc(struct scsi_device *);
 static int storvsc_device_configure(struct scsi_device *);
 static int storvsc_host_reset_handler(struct scsi_cmnd *scmnd);
@@ -595,7 +594,7 @@
 /*
  * storvsc_queuecommand - Initiate command processing
  */
-static int storvsc_queuecommand(struct scsi_cmnd *scmnd,
+static int storvsc_queuecommand_lck(struct scsi_cmnd *scmnd,
 				void (*done)(struct scsi_cmnd *))
 {
 	int ret;
@@ -783,6 +782,8 @@
 	return ret;
 }
 
+static DEF_SCSI_QCMD(storvsc_queuecommand)
+
 static int storvsc_merge_bvec(struct request_queue *q,
 			      struct bvec_merge_data *bmd, struct bio_vec *bvec)
 {
diff -urN linux-2.6.37-rc2/drivers/staging/intel_sst/intel_sst_app_interface.c linux-2.6.37-rc3/drivers/staging/intel_sst/intel_sst_app_interface.c
--- linux-2.6.37-rc2/drivers/staging/intel_sst/intel_sst_app_interface.c	2010-11-21 23:40:12.121258759 +0000
+++ linux-2.6.37-rc3/drivers/staging/intel_sst/intel_sst_app_interface.c	2010-11-21 23:40:17.531069298 +0000
@@ -34,7 +34,6 @@
 #include <linux/uaccess.h>
 #include <linux/firmware.h>
 #include <linux/ioctl.h>
-#include <linux/smp_lock.h>
 #ifdef CONFIG_MRST_RAR_HANDLER
 #include <linux/rar_register.h>
 #include "../../../drivers/staging/memrar/memrar.h"
diff -urN linux-2.6.37-rc2/drivers/staging/keucr/scsiglue.c linux-2.6.37-rc3/drivers/staging/keucr/scsiglue.c
--- linux-2.6.37-rc2/drivers/staging/keucr/scsiglue.c	2010-11-21 23:40:12.135099012 +0000
+++ linux-2.6.37-rc3/drivers/staging/keucr/scsiglue.c	2010-11-21 23:40:17.539080945 +0000
@@ -87,7 +87,7 @@
 
 /* This is always called with scsi_lock(host) held */
 //----- queuecommand() ---------------------
-static int queuecommand(struct scsi_cmnd *srb, void (*done)(struct scsi_cmnd *))
+static int queuecommand_lck(struct scsi_cmnd *srb, void (*done)(struct scsi_cmnd *))
 {
 	struct us_data *us = host_to_us(srb->device->host);
 
@@ -117,6 +117,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(queuecommand)
+
 /***********************************************************************
  * Error handling functions
  ***********************************************************************/
diff -urN linux-2.6.37-rc2/drivers/staging/rtl8712/osdep_service.h linux-2.6.37-rc3/drivers/staging/rtl8712/osdep_service.h
--- linux-2.6.37-rc2/drivers/staging/rtl8712/osdep_service.h	2010-11-21 23:40:12.312086262 +0000
+++ linux-2.6.37-rc3/drivers/staging/rtl8712/osdep_service.h	2010-11-21 23:40:17.672072214 +0000
@@ -22,7 +22,6 @@
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/kref.h>
-#include <linux/smp_lock.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
 #include <linux/usb.h>
diff -urN linux-2.6.37-rc2/drivers/staging/speakup/buffers.c linux-2.6.37-rc3/drivers/staging/speakup/buffers.c
--- linux-2.6.37-rc2/drivers/staging/speakup/buffers.c	2010-11-21 23:40:12.350118187 +0000
+++ linux-2.6.37-rc3/drivers/staging/speakup/buffers.c	2010-11-21 23:40:17.695242439 +0000
@@ -1,5 +1,4 @@
 #include <linux/console.h>
-#include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/wait.h>
 
diff -urN linux-2.6.37-rc2/drivers/staging/stradis/Kconfig linux-2.6.37-rc3/drivers/staging/stradis/Kconfig
--- linux-2.6.37-rc2/drivers/staging/stradis/Kconfig	2010-11-21 23:40:12.364233627 +0000
+++ linux-2.6.37-rc3/drivers/staging/stradis/Kconfig	2010-11-21 23:40:17.703081341 +0000
@@ -1,6 +1,6 @@
 config VIDEO_STRADIS
         tristate "Stradis 4:2:2 MPEG-2 video driver (DEPRECATED)"
-        depends on EXPERIMENTAL && PCI && VIDEO_V4L1 && VIRT_TO_BUS
+        depends on EXPERIMENTAL && PCI && VIDEO_V4L1 && VIRT_TO_BUS && BKL
         help
           Say Y here to enable support for the Stradis 4:2:2 MPEG-2 video
           driver for PCI.  There is a product page at
diff -urN linux-2.6.37-rc2/drivers/tty/sysrq.c linux-2.6.37-rc3/drivers/tty/sysrq.c
--- linux-2.6.37-rc2/drivers/tty/sysrq.c	2010-11-21 23:40:12.466086615 +0000
+++ linux-2.6.37-rc3/drivers/tty/sysrq.c	2010-11-21 23:40:17.776078843 +0000
@@ -554,7 +554,7 @@
 #ifdef CONFIG_INPUT
 
 /* Simple translation table for the SysRq keys */
-static const unsigned char sysrq_xlate[KEY_MAX + 1] =
+static const unsigned char sysrq_xlate[KEY_CNT] =
         "\000\0331234567890-=\177\t"                    /* 0x00 - 0x0f */
         "qwertyuiop[]\r\000as"                          /* 0x10 - 0x1f */
         "dfghjkl;'`\000\\zxcv"                          /* 0x20 - 0x2f */
@@ -563,53 +563,129 @@
         "230\177\000\000\213\214\000\000\000\000\000\000\000\000\000\000" /* 0x50 - 0x5f */
         "\r\000/";                                      /* 0x60 - 0x6f */
 
-static bool sysrq_down;
-static int sysrq_alt_use;
-static int sysrq_alt;
-static DEFINE_SPINLOCK(sysrq_event_lock);
+struct sysrq_state {
+	struct input_handle handle;
+	struct work_struct reinject_work;
+	unsigned long key_down[BITS_TO_LONGS(KEY_CNT)];
+	unsigned int alt;
+	unsigned int alt_use;
+	bool active;
+	bool need_reinject;
+};
 
-static bool sysrq_filter(struct input_handle *handle, unsigned int type,
-		         unsigned int code, int value)
+static void sysrq_reinject_alt_sysrq(struct work_struct *work)
 {
-	bool suppress;
+	struct sysrq_state *sysrq =
+			container_of(work, struct sysrq_state, reinject_work);
+	struct input_handle *handle = &sysrq->handle;
+	unsigned int alt_code = sysrq->alt_use;
+
+	if (sysrq->need_reinject) {
+		/* Simulate press and release of Alt + SysRq */
+		input_inject_event(handle, EV_KEY, alt_code, 1);
+		input_inject_event(handle, EV_KEY, KEY_SYSRQ, 1);
+		input_inject_event(handle, EV_SYN, SYN_REPORT, 1);
+
+		input_inject_event(handle, EV_KEY, KEY_SYSRQ, 0);
+		input_inject_event(handle, EV_KEY, alt_code, 0);
+		input_inject_event(handle, EV_SYN, SYN_REPORT, 1);
+	}
+}
 
-	/* We are called with interrupts disabled, just take the lock */
-	spin_lock(&sysrq_event_lock);
+static bool sysrq_filter(struct input_handle *handle,
+			 unsigned int type, unsigned int code, int value)
+{
+	struct sysrq_state *sysrq = handle->private;
+	bool was_active = sysrq->active;
+	bool suppress;
 
-	if (type != EV_KEY)
-		goto out;
+	switch (type) {
 
-	switch (code) {
+	case EV_SYN:
+		suppress = false;
+		break;
 
-	case KEY_LEFTALT:
-	case KEY_RIGHTALT:
-		if (value)
-			sysrq_alt = code;
-		else {
-			if (sysrq_down && code == sysrq_alt_use)
-				sysrq_down = false;
+	case EV_KEY:
+		switch (code) {
 
-			sysrq_alt = 0;
+		case KEY_LEFTALT:
+		case KEY_RIGHTALT:
+			if (!value) {
+				/* One of ALTs is being released */
+				if (sysrq->active && code == sysrq->alt_use)
+					sysrq->active = false;
+
+				sysrq->alt = KEY_RESERVED;
+
+			} else if (value != 2) {
+				sysrq->alt = code;
+				sysrq->need_reinject = false;
+			}
+			break;
+
+		case KEY_SYSRQ:
+			if (value == 1 && sysrq->alt != KEY_RESERVED) {
+				sysrq->active = true;
+				sysrq->alt_use = sysrq->alt;
+				/*
+				 * If nothing else will be pressed we'll need
+				 * to * re-inject Alt-SysRq keysroke.
+				 */
+				sysrq->need_reinject = true;
+			}
+
+			/*
+			 * Pretend that sysrq was never pressed at all. This
+			 * is needed to properly handle KGDB which will try
+			 * to release all keys after exiting debugger. If we
+			 * do not clear key bit it KGDB will end up sending
+			 * release events for Alt and SysRq, potentially
+			 * triggering print screen function.
+			 */
+			if (sysrq->active)
+				clear_bit(KEY_SYSRQ, handle->dev->key);
+
+			break;
+
+		default:
+			if (sysrq->active && value && value != 2) {
+				sysrq->need_reinject = false;
+				__handle_sysrq(sysrq_xlate[code], true);
+			}
+			break;
 		}
-		break;
 
-	case KEY_SYSRQ:
-		if (value == 1 && sysrq_alt) {
-			sysrq_down = true;
-			sysrq_alt_use = sysrq_alt;
+		suppress = sysrq->active;
+
+		if (!sysrq->active) {
+			/*
+			 * If we are not suppressing key presses keep track of
+			 * keyboard state so we can release keys that have been
+			 * pressed before entering SysRq mode.
+			 */
+			if (value)
+				set_bit(code, sysrq->key_down);
+			else
+				clear_bit(code, sysrq->key_down);
+
+			if (was_active)
+				schedule_work(&sysrq->reinject_work);
+
+		} else if (value == 0 &&
+			   test_and_clear_bit(code, sysrq->key_down)) {
+			/*
+			 * Pass on release events for keys that was pressed before
+			 * entering SysRq mode.
+			 */
+			suppress = false;
 		}
 		break;
 
 	default:
-		if (sysrq_down && value && value != 2)
-			__handle_sysrq(sysrq_xlate[code], true);
+		suppress = sysrq->active;
 		break;
 	}
 
-out:
-	suppress = sysrq_down;
-	spin_unlock(&sysrq_event_lock);
-
 	return suppress;
 }
 
@@ -617,28 +693,28 @@
 			 struct input_dev *dev,
 			 const struct input_device_id *id)
 {
-	struct input_handle *handle;
+	struct sysrq_state *sysrq;
 	int error;
 
-	sysrq_down = false;
-	sysrq_alt = 0;
-
-	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
-	if (!handle)
+	sysrq = kzalloc(sizeof(struct sysrq_state), GFP_KERNEL);
+	if (!sysrq)
 		return -ENOMEM;
 
-	handle->dev = dev;
-	handle->handler = handler;
-	handle->name = "sysrq";
+	INIT_WORK(&sysrq->reinject_work, sysrq_reinject_alt_sysrq);
 
-	error = input_register_handle(handle);
+	sysrq->handle.dev = dev;
+	sysrq->handle.handler = handler;
+	sysrq->handle.name = "sysrq";
+	sysrq->handle.private = sysrq;
+
+	error = input_register_handle(&sysrq->handle);
 	if (error) {
 		pr_err("Failed to register input sysrq handler, error %d\n",
 			error);
 		goto err_free;
 	}
 
-	error = input_open_device(handle);
+	error = input_open_device(&sysrq->handle);
 	if (error) {
 		pr_err("Failed to open input device, error %d\n", error);
 		goto err_unregister;
@@ -647,17 +723,20 @@
 	return 0;
 
  err_unregister:
-	input_unregister_handle(handle);
+	input_unregister_handle(&sysrq->handle);
  err_free:
-	kfree(handle);
+	kfree(sysrq);
 	return error;
 }
 
 static void sysrq_disconnect(struct input_handle *handle)
 {
+	struct sysrq_state *sysrq = handle->private;
+
 	input_close_device(handle);
+	cancel_work_sync(&sysrq->reinject_work);
 	input_unregister_handle(handle);
-	kfree(handle);
+	kfree(sysrq);
 }
 
 /*
diff -urN linux-2.6.37-rc2/drivers/usb/core/devices.c linux-2.6.37-rc3/drivers/usb/core/devices.c
--- linux-2.6.37-rc2/drivers/usb/core/devices.c	2010-11-21 23:40:12.478086652 +0000
+++ linux-2.6.37-rc3/drivers/usb/core/devices.c	2010-11-21 23:40:17.785077504 +0000
@@ -54,7 +54,6 @@
 #include <linux/gfp.h>
 #include <linux/poll.h>
 #include <linux/usb.h>
-#include <linux/smp_lock.h>
 #include <linux/usbdevice_fs.h>
 #include <linux/usb/hcd.h>
 #include <linux/mutex.h>
diff -urN linux-2.6.37-rc2/drivers/usb/core/devio.c linux-2.6.37-rc3/drivers/usb/core/devio.c
--- linux-2.6.37-rc2/drivers/usb/core/devio.c	2010-11-21 23:40:12.479086558 +0000
+++ linux-2.6.37-rc3/drivers/usb/core/devio.c	2010-11-21 23:40:17.785077504 +0000
@@ -37,7 +37,6 @@
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/signal.h>
 #include <linux/poll.h>
 #include <linux/module.h>
diff -urN linux-2.6.37-rc2/drivers/usb/core/file.c linux-2.6.37-rc3/drivers/usb/core/file.c
--- linux-2.6.37-rc2/drivers/usb/core/file.c	2010-11-21 23:40:12.479086558 +0000
+++ linux-2.6.37-rc3/drivers/usb/core/file.c	2010-11-21 23:40:17.786078228 +0000
@@ -19,7 +19,6 @@
 #include <linux/errno.h>
 #include <linux/rwsem.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/usb.h>
 
 #include "usb.h"
diff -urN linux-2.6.37-rc2/drivers/usb/core/inode.c linux-2.6.37-rc3/drivers/usb/core/inode.c
--- linux-2.6.37-rc2/drivers/usb/core/inode.c	2010-11-21 23:40:12.481087345 +0000
+++ linux-2.6.37-rc3/drivers/usb/core/inode.c	2010-11-21 23:40:17.787079549 +0000
@@ -39,7 +39,6 @@
 #include <linux/parser.h>
 #include <linux/notifier.h>
 #include <linux/seq_file.h>
-#include <linux/smp_lock.h>
 #include <linux/usb/hcd.h>
 #include <asm/byteorder.h>
 #include "usb.h"
diff -urN linux-2.6.37-rc2/drivers/usb/gadget/f_fs.c linux-2.6.37-rc3/drivers/usb/gadget/f_fs.c
--- linux-2.6.37-rc2/drivers/usb/gadget/f_fs.c	2010-11-21 23:40:12.486086504 +0000
+++ linux-2.6.37-rc3/drivers/usb/gadget/f_fs.c	2010-11-21 23:40:17.791077119 +0000
@@ -30,7 +30,6 @@
 #include <linux/blkdev.h>
 #include <linux/pagemap.h>
 #include <asm/unaligned.h>
-#include <linux/smp_lock.h>
 
 #include <linux/usb/composite.h>
 #include <linux/usb/functionfs.h>
diff -urN linux-2.6.37-rc2/drivers/usb/gadget/f_hid.c linux-2.6.37-rc3/drivers/usb/gadget/f_hid.c
--- linux-2.6.37-rc2/drivers/usb/gadget/f_hid.c	2010-11-21 23:40:12.487063249 +0000
+++ linux-2.6.37-rc3/drivers/usb/gadget/f_hid.c	2010-11-21 23:40:17.791077119 +0000
@@ -25,7 +25,6 @@
 #include <linux/cdev.h>
 #include <linux/mutex.h>
 #include <linux/poll.h>
-#include <linux/smp_lock.h>
 #include <linux/uaccess.h>
 #include <linux/wait.h>
 #include <linux/usb/g_hid.h>
diff -urN linux-2.6.37-rc2/drivers/usb/host/isp1362-hcd.c linux-2.6.37-rc3/drivers/usb/host/isp1362-hcd.c
--- linux-2.6.37-rc2/drivers/usb/host/isp1362-hcd.c	2010-11-21 23:40:12.504086191 +0000
+++ linux-2.6.37-rc3/drivers/usb/host/isp1362-hcd.c	2010-11-21 23:40:17.805056501 +0000
@@ -70,7 +70,6 @@
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/list.h>
diff -urN linux-2.6.37-rc2/drivers/usb/host/uhci-debug.c linux-2.6.37-rc3/drivers/usb/host/uhci-debug.c
--- linux-2.6.37-rc2/drivers/usb/host/uhci-debug.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/usb/host/uhci-debug.c	2010-11-21 23:40:17.808056646 +0000
@@ -12,7 +12,6 @@
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/debugfs.h>
-#include <linux/smp_lock.h>
 #include <asm/io.h>
 
 #include "uhci-hcd.h"
diff -urN linux-2.6.37-rc2/drivers/usb/image/microtek.c linux-2.6.37-rc3/drivers/usb/image/microtek.c
--- linux-2.6.37-rc2/drivers/usb/image/microtek.c	2010-11-21 23:40:12.510086304 +0000
+++ linux-2.6.37-rc3/drivers/usb/image/microtek.c	2010-11-21 23:40:17.811056056 +0000
@@ -364,7 +364,7 @@
 }
 
 static int
-mts_scsi_queuecommand(struct scsi_cmnd *srb, mts_scsi_cmnd_callback callback);
+mts_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *srb);
 
 static void mts_transfer_cleanup( struct urb *transfer );
 static void mts_do_sg(struct urb * transfer);
@@ -573,7 +573,7 @@
 
 
 static int
-mts_scsi_queuecommand(struct scsi_cmnd *srb, mts_scsi_cmnd_callback callback)
+mts_scsi_queuecommand_lck(struct scsi_cmnd *srb, mts_scsi_cmnd_callback callback)
 {
 	struct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);
 	int err = 0;
@@ -626,6 +626,8 @@
 	return err;
 }
 
+static DEF_SCSI_QCMD(mts_scsi_queuecommand)
+
 static struct scsi_host_template mts_scsi_host_template = {
 	.module			= THIS_MODULE,
 	.name			= "microtekX6",
diff -urN linux-2.6.37-rc2/drivers/usb/mon/mon_bin.c linux-2.6.37-rc3/drivers/usb/mon/mon_bin.c
--- linux-2.6.37-rc2/drivers/usb/mon/mon_bin.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/usb/mon/mon_bin.c	2010-11-21 23:40:17.814056149 +0000
@@ -15,7 +15,6 @@
 #include <linux/poll.h>
 #include <linux/compat.h>
 #include <linux/mm.h>
-#include <linux/smp_lock.h>
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 
diff -urN linux-2.6.37-rc2/drivers/usb/mon/mon_stat.c linux-2.6.37-rc3/drivers/usb/mon/mon_stat.c
--- linux-2.6.37-rc2/drivers/usb/mon/mon_stat.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/usb/mon/mon_stat.c	2010-11-21 23:40:17.814056149 +0000
@@ -11,7 +11,6 @@
 #include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/fs.h>
-#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 
 #include "usb_mon.h"
diff -urN linux-2.6.37-rc2/drivers/usb/serial/usb-serial.c linux-2.6.37-rc3/drivers/usb/serial/usb-serial.c
--- linux-2.6.37-rc2/drivers/usb/serial/usb-serial.c	2010-11-21 23:40:12.524086193 +0000
+++ linux-2.6.37-rc3/drivers/usb/serial/usb-serial.c	2010-11-21 23:40:17.825040967 +0000
@@ -21,7 +21,6 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
diff -urN linux-2.6.37-rc2/drivers/usb/storage/scsiglue.c linux-2.6.37-rc3/drivers/usb/storage/scsiglue.c
--- linux-2.6.37-rc2/drivers/usb/storage/scsiglue.c	2010-11-21 23:40:12.525086277 +0000
+++ linux-2.6.37-rc3/drivers/usb/storage/scsiglue.c	2010-11-21 23:40:17.826056987 +0000
@@ -285,7 +285,7 @@
 
 /* queue a command */
 /* This is always called with scsi_lock(host) held */
-static int queuecommand(struct scsi_cmnd *srb,
+static int queuecommand_lck(struct scsi_cmnd *srb,
 			void (*done)(struct scsi_cmnd *))
 {
 	struct us_data *us = host_to_us(srb->device->host);
@@ -315,6 +315,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(queuecommand)
+
 /***********************************************************************
  * Error handling functions
  ***********************************************************************/
diff -urN linux-2.6.37-rc2/drivers/usb/storage/uas.c linux-2.6.37-rc3/drivers/usb/storage/uas.c
--- linux-2.6.37-rc2/drivers/usb/storage/uas.c	2010-11-21 23:40:12.526086185 +0000
+++ linux-2.6.37-rc3/drivers/usb/storage/uas.c	2010-11-21 23:40:17.827056624 +0000
@@ -430,7 +430,7 @@
 	return 0;
 }
 
-static int uas_queuecommand(struct scsi_cmnd *cmnd,
+static int uas_queuecommand_lck(struct scsi_cmnd *cmnd,
 					void (*done)(struct scsi_cmnd *))
 {
 	struct scsi_device *sdev = cmnd->device;
@@ -488,6 +488,8 @@
 	return 0;
 }
 
+static DEF_SCSI_QCMD(uas_queuecommand)
+
 static int uas_eh_abort_handler(struct scsi_cmnd *cmnd)
 {
 	struct scsi_device *sdev = cmnd->device;
diff -urN linux-2.6.37-rc2/drivers/video/console/vgacon.c linux-2.6.37-rc3/drivers/video/console/vgacon.c
--- linux-2.6.37-rc2/drivers/video/console/vgacon.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/video/console/vgacon.c	2010-11-21 23:40:17.841056536 +0000
@@ -47,7 +47,6 @@
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/screen_info.h>
-#include <linux/smp_lock.h>
 #include <video/vga.h>
 #include <asm/io.h>
 
diff -urN linux-2.6.37-rc2/drivers/xen/xenfs/privcmd.c linux-2.6.37-rc3/drivers/xen/xenfs/privcmd.c
--- linux-2.6.37-rc2/drivers/xen/xenfs/privcmd.c	2010-11-21 23:40:12.556086302 +0000
+++ linux-2.6.37-rc3/drivers/xen/xenfs/privcmd.c	2010-11-21 23:40:17.857056859 +0000
@@ -15,7 +15,6 @@
 #include <linux/mman.h>
 #include <linux/uaccess.h>
 #include <linux/swap.h>
-#include <linux/smp_lock.h>
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
 #include <linux/seq_file.h>
diff -urN linux-2.6.37-rc2/drivers/zorro/proc.c linux-2.6.37-rc3/drivers/zorro/proc.c
--- linux-2.6.37-rc2/drivers/zorro/proc.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/drivers/zorro/proc.c	2010-11-21 23:40:17.858056912 +0000
@@ -13,7 +13,6 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <asm/amigahw.h>
 #include <asm/setup.h>
diff -urN linux-2.6.37-rc2/fs/block_dev.c linux-2.6.37-rc3/fs/block_dev.c
--- linux-2.6.37-rc2/fs/block_dev.c	2010-11-21 23:40:12.610086237 +0000
+++ linux-2.6.37-rc3/fs/block_dev.c	2010-11-21 23:40:17.912056030 +0000
@@ -11,7 +11,6 @@
 #include <linux/slab.h>
 #include <linux/kmod.h>
 #include <linux/major.h>
-#include <linux/smp_lock.h>
 #include <linux/device_cgroup.h>
 #include <linux/highmem.h>
 #include <linux/blkdev.h>
diff -urN linux-2.6.37-rc2/fs/ceph/addr.c linux-2.6.37-rc3/fs/ceph/addr.c
--- linux-2.6.37-rc2/fs/ceph/addr.c	2010-11-21 23:40:12.620086263 +0000
+++ linux-2.6.37-rc3/fs/ceph/addr.c	2010-11-21 23:40:17.922056601 +0000
@@ -204,7 +204,7 @@
 	err = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,
 				  page->index << PAGE_CACHE_SHIFT, &len,
 				  ci->i_truncate_seq, ci->i_truncate_size,
-				  &page, 1);
+				  &page, 1, 0);
 	if (err == -ENOENT)
 		err = 0;
 	if (err < 0) {
@@ -287,7 +287,7 @@
 	rc = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,
 				 offset, &len,
 				 ci->i_truncate_seq, ci->i_truncate_size,
-				 pages, nr_pages);
+				 pages, nr_pages, 0);
 	if (rc == -ENOENT)
 		rc = 0;
 	if (rc < 0)
@@ -774,7 +774,7 @@
 					    snapc, do_sync,
 					    ci->i_truncate_seq,
 					    ci->i_truncate_size,
-					    &inode->i_mtime, true, 1);
+					    &inode->i_mtime, true, 1, 0);
 				max_pages = req->r_num_pages;
 
 				alloc_page_vec(fsc, req);
diff -urN linux-2.6.37-rc2/fs/ceph/caps.c linux-2.6.37-rc3/fs/ceph/caps.c
--- linux-2.6.37-rc2/fs/ceph/caps.c	2010-11-21 23:40:12.622086177 +0000
+++ linux-2.6.37-rc3/fs/ceph/caps.c	2010-11-21 23:40:17.924056686 +0000
@@ -1430,8 +1430,8 @@
 	    invalidating_gen == ci->i_rdcache_gen) {
 		/* success. */
 		dout("try_nonblocking_invalidate %p success\n", inode);
-		ci->i_rdcache_gen = 0;
-		ci->i_rdcache_revoking = 0;
+		/* save any racing async invalidate some trouble */
+		ci->i_rdcache_revoking = ci->i_rdcache_gen - 1;
 		return 0;
 	}
 	dout("try_nonblocking_invalidate %p failed\n", inode);
@@ -2273,8 +2273,7 @@
 {
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	int mds = session->s_mds;
-	unsigned seq = le32_to_cpu(grant->seq);
-	unsigned issue_seq = le32_to_cpu(grant->issue_seq);
+	int seq = le32_to_cpu(grant->seq);
 	int newcaps = le32_to_cpu(grant->caps);
 	int issued, implemented, used, wanted, dirty;
 	u64 size = le64_to_cpu(grant->size);
@@ -2286,8 +2285,8 @@
 	int revoked_rdcache = 0;
 	int queue_invalidate = 0;
 
-	dout("handle_cap_grant inode %p cap %p mds%d seq %u/%u %s\n",
-	     inode, cap, mds, seq, issue_seq, ceph_cap_string(newcaps));
+	dout("handle_cap_grant inode %p cap %p mds%d seq %d %s\n",
+	     inode, cap, mds, seq, ceph_cap_string(newcaps));
 	dout(" size %llu max_size %llu, i_size %llu\n", size, max_size,
 		inode->i_size);
 
@@ -2383,7 +2382,6 @@
 	}
 
 	cap->seq = seq;
-	cap->issue_seq = issue_seq;
 
 	/* file layout may have changed */
 	ci->i_layout = grant->layout;
@@ -2691,6 +2689,11 @@
 		     NULL /* no caps context */);
 	try_flush_caps(inode, session, NULL);
 	up_read(&mdsc->snap_rwsem);
+
+	/* make sure we re-request max_size, if necessary */
+	spin_lock(&inode->i_lock);
+	ci->i_requested_max_size = 0;
+	spin_unlock(&inode->i_lock);
 }
 
 /*
diff -urN linux-2.6.37-rc2/fs/ceph/dir.c linux-2.6.37-rc3/fs/ceph/dir.c
--- linux-2.6.37-rc2/fs/ceph/dir.c	2010-11-21 23:40:12.625086182 +0000
+++ linux-2.6.37-rc3/fs/ceph/dir.c	2010-11-21 23:40:17.927053055 +0000
@@ -336,7 +336,10 @@
 		if (req->r_reply_info.dir_end) {
 			kfree(fi->last_name);
 			fi->last_name = NULL;
-			fi->next_offset = 2;
+			if (ceph_frag_is_rightmost(frag))
+				fi->next_offset = 2;
+			else
+				fi->next_offset = 0;
 		} else {
 			rinfo = &req->r_reply_info;
 			err = note_last_dentry(fi,
@@ -355,18 +358,22 @@
 		u64 pos = ceph_make_fpos(frag, off);
 		struct ceph_mds_reply_inode *in =
 			rinfo->dir_in[off - fi->offset].in;
+		struct ceph_vino vino;
+		ino_t ino;
+
 		dout("readdir off %d (%d/%d) -> %lld '%.*s' %p\n",
 		     off, off - fi->offset, rinfo->dir_nr, pos,
 		     rinfo->dir_dname_len[off - fi->offset],
 		     rinfo->dir_dname[off - fi->offset], in);
 		BUG_ON(!in);
 		ftype = le32_to_cpu(in->mode) >> 12;
+		vino.ino = le64_to_cpu(in->ino);
+		vino.snap = le64_to_cpu(in->snapid);
+		ino = ceph_vino_to_ino(vino);
 		if (filldir(dirent,
 			    rinfo->dir_dname[off - fi->offset],
 			    rinfo->dir_dname_len[off - fi->offset],
-			    pos,
-			    le64_to_cpu(in->ino),
-			    ftype) < 0) {
+			    pos, ino, ftype) < 0) {
 			dout("filldir stopping us...\n");
 			return 0;
 		}
@@ -414,6 +421,7 @@
 		fi->last_readdir = NULL;
 	}
 	kfree(fi->last_name);
+	fi->last_name = NULL;
 	fi->next_offset = 2;  /* compensate for . and .. */
 	if (fi->dentry) {
 		dput(fi->dentry);
diff -urN linux-2.6.37-rc2/fs/ceph/file.c linux-2.6.37-rc3/fs/ceph/file.c
--- linux-2.6.37-rc2/fs/ceph/file.c	2010-11-21 23:40:12.625086182 +0000
+++ linux-2.6.37-rc3/fs/ceph/file.c	2010-11-21 23:40:17.927053055 +0000
@@ -154,11 +154,13 @@
 	}
 
 	/*
-	 * No need to block if we have any caps.  Update wanted set
+	 * No need to block if we have caps on the auth MDS (for
+	 * write) or any MDS (for read).  Update wanted set
 	 * asynchronously.
 	 */
 	spin_lock(&inode->i_lock);
-	if (__ceph_is_any_real_caps(ci)) {
+	if (__ceph_is_any_real_caps(ci) &&
+	    (((fmode & CEPH_FILE_MODE_WR) == 0) || ci->i_auth_cap)) {
 		int mds_wanted = __ceph_caps_mds_wanted(ci);
 		int issued = __ceph_caps_issued(ci, NULL);
 
@@ -280,11 +282,12 @@
 static int striped_read(struct inode *inode,
 			u64 off, u64 len,
 			struct page **pages, int num_pages,
-			int *checkeof)
+			int *checkeof, bool align_to_pages)
 {
 	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	u64 pos, this_len;
+	int io_align, page_align;
 	int page_off = off & ~PAGE_CACHE_MASK; /* first byte's offset in page */
 	int left, pages_left;
 	int read;
@@ -300,14 +303,19 @@
 	page_pos = pages;
 	pages_left = num_pages;
 	read = 0;
+	io_align = off & ~PAGE_MASK;
 
 more:
+	if (align_to_pages)
+		page_align = (pos - io_align) & ~PAGE_MASK;
+	else
+		page_align = pos & ~PAGE_MASK;
 	this_len = left;
 	ret = ceph_osdc_readpages(&fsc->client->osdc, ceph_vino(inode),
 				  &ci->i_layout, pos, &this_len,
 				  ci->i_truncate_seq,
 				  ci->i_truncate_size,
-				  page_pos, pages_left);
+				  page_pos, pages_left, page_align);
 	hit_stripe = this_len < left;
 	was_short = ret >= 0 && ret < this_len;
 	if (ret == -ENOENT)
@@ -374,26 +382,25 @@
 	dout("sync_read on file %p %llu~%u %s\n", file, off, len,
 	     (file->f_flags & O_DIRECT) ? "O_DIRECT" : "");
 
-	if (file->f_flags & O_DIRECT) {
-		pages = ceph_get_direct_page_vector(data, num_pages, off, len);
-
-		/*
-		 * flush any page cache pages in this range.  this
-		 * will make concurrent normal and O_DIRECT io slow,
-		 * but it will at least behave sensibly when they are
-		 * in sequence.
-		 */
-	} else {
+	if (file->f_flags & O_DIRECT)
+		pages = ceph_get_direct_page_vector(data, num_pages);
+	else
 		pages = ceph_alloc_page_vector(num_pages, GFP_NOFS);
-	}
 	if (IS_ERR(pages))
 		return PTR_ERR(pages);
 
+	/*
+	 * flush any page cache pages in this range.  this
+	 * will make concurrent normal and sync io slow,
+	 * but it will at least behave sensibly when they are
+	 * in sequence.
+	 */
 	ret = filemap_write_and_wait(inode->i_mapping);
 	if (ret < 0)
 		goto done;
 
-	ret = striped_read(inode, off, len, pages, num_pages, checkeof);
+	ret = striped_read(inode, off, len, pages, num_pages, checkeof,
+			   file->f_flags & O_DIRECT);
 
 	if (ret >= 0 && (file->f_flags & O_DIRECT) == 0)
 		ret = ceph_copy_page_vector_to_user(pages, data, off, ret);
@@ -448,6 +455,7 @@
 	int flags;
 	int do_sync = 0;
 	int check_caps = 0;
+	int page_align, io_align;
 	int ret;
 	struct timespec mtime = CURRENT_TIME;
 
@@ -462,6 +470,8 @@
 	else
 		pos = *offset;
 
+	io_align = pos & ~PAGE_MASK;
+
 	ret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + left);
 	if (ret < 0)
 		return ret;
@@ -486,20 +496,26 @@
 	 */
 more:
 	len = left;
+	if (file->f_flags & O_DIRECT)
+		/* write from beginning of first page, regardless of
+		   io alignment */
+		page_align = (pos - io_align) & ~PAGE_MASK;
+	else
+		page_align = pos & ~PAGE_MASK;
 	req = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,
 				    ceph_vino(inode), pos, &len,
 				    CEPH_OSD_OP_WRITE, flags,
 				    ci->i_snap_realm->cached_context,
 				    do_sync,
 				    ci->i_truncate_seq, ci->i_truncate_size,
-				    &mtime, false, 2);
+				    &mtime, false, 2, page_align);
 	if (!req)
 		return -ENOMEM;
 
 	num_pages = calc_pages_for(pos, len);
 
 	if (file->f_flags & O_DIRECT) {
-		pages = ceph_get_direct_page_vector(data, num_pages, pos, len);
+		pages = ceph_get_direct_page_vector(data, num_pages);
 		if (IS_ERR(pages)) {
 			ret = PTR_ERR(pages);
 			goto out;
diff -urN linux-2.6.37-rc2/fs/ceph/inode.c linux-2.6.37-rc3/fs/ceph/inode.c
--- linux-2.6.37-rc2/fs/ceph/inode.c	2010-11-21 23:40:12.626088613 +0000
+++ linux-2.6.37-rc3/fs/ceph/inode.c	2010-11-21 23:40:17.928242422 +0000
@@ -2,7 +2,6 @@
 
 #include <linux/module.h>
 #include <linux/fs.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/uaccess.h>
@@ -471,7 +470,9 @@
 
 	if (issued & (CEPH_CAP_FILE_EXCL|
 		      CEPH_CAP_FILE_WR|
-		      CEPH_CAP_FILE_BUFFER)) {
+		      CEPH_CAP_FILE_BUFFER|
+		      CEPH_CAP_AUTH_EXCL|
+		      CEPH_CAP_XATTR_EXCL)) {
 		if (timespec_compare(ctime, &inode->i_ctime) > 0) {
 			dout("ctime %ld.%09ld -> %ld.%09ld inc w/ cap\n",
 			     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
@@ -511,7 +512,7 @@
 			warn = 1;
 		}
 	} else {
-		/* we have no write caps; whatever the MDS says is true */
+		/* we have no write|excl caps; whatever the MDS says is true */
 		if (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {
 			inode->i_ctime = *ctime;
 			inode->i_mtime = *mtime;
@@ -567,12 +568,17 @@
 
 	/*
 	 * provided version will be odd if inode value is projected,
-	 * even if stable.  skip the update if we have a newer info
-	 * (e.g., due to inode info racing form multiple MDSs), or if
-	 * we are getting projected (unstable) inode info.
+	 * even if stable.  skip the update if we have newer stable
+	 * info (ours>=theirs, e.g. due to racing mds replies), unless
+	 * we are getting projected (unstable) info (in which case the
+	 * version is odd, and we want ours>theirs).
+	 *   us   them
+	 *   2    2     skip
+	 *   3    2     skip
+	 *   3    3     update
 	 */
 	if (le64_to_cpu(info->version) > 0 &&
-	    (ci->i_version & ~1) > le64_to_cpu(info->version))
+	    (ci->i_version & ~1) >= le64_to_cpu(info->version))
 		goto no_change;
 
 	issued = __ceph_caps_issued(ci, &implemented);
@@ -606,7 +612,14 @@
 			    le32_to_cpu(info->time_warp_seq),
 			    &ctime, &mtime, &atime);
 
-	ci->i_max_size = le64_to_cpu(info->max_size);
+	/* only update max_size on auth cap */
+	if ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&
+	    ci->i_max_size != le64_to_cpu(info->max_size)) {
+		dout("max_size %lld -> %llu\n", ci->i_max_size,
+		     le64_to_cpu(info->max_size));
+		ci->i_max_size = le64_to_cpu(info->max_size);
+	}
+
 	ci->i_layout = info->layout;
 	inode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;
 
@@ -1055,7 +1068,8 @@
 		ininfo = rinfo->targeti.in;
 		vino.ino = le64_to_cpu(ininfo->ino);
 		vino.snap = le64_to_cpu(ininfo->snapid);
-		if (!dn->d_inode) {
+		in = dn->d_inode;
+		if (!in) {
 			in = ceph_get_inode(sb, vino);
 			if (IS_ERR(in)) {
 				pr_err("fill_trace bad get_inode "
@@ -1386,11 +1400,8 @@
 	spin_lock(&inode->i_lock);
 	dout("invalidate_pages %p gen %d revoking %d\n", inode,
 	     ci->i_rdcache_gen, ci->i_rdcache_revoking);
-	if (ci->i_rdcache_gen == 0 ||
-	    ci->i_rdcache_revoking != ci->i_rdcache_gen) {
-		BUG_ON(ci->i_rdcache_revoking > ci->i_rdcache_gen);
+	if (ci->i_rdcache_revoking != ci->i_rdcache_gen) {
 		/* nevermind! */
-		ci->i_rdcache_revoking = 0;
 		spin_unlock(&inode->i_lock);
 		goto out;
 	}
@@ -1400,15 +1411,16 @@
 	ceph_invalidate_nondirty_pages(inode->i_mapping);
 
 	spin_lock(&inode->i_lock);
-	if (orig_gen == ci->i_rdcache_gen) {
+	if (orig_gen == ci->i_rdcache_gen &&
+	    orig_gen == ci->i_rdcache_revoking) {
 		dout("invalidate_pages %p gen %d successful\n", inode,
 		     ci->i_rdcache_gen);
-		ci->i_rdcache_gen = 0;
-		ci->i_rdcache_revoking = 0;
+		ci->i_rdcache_revoking--;
 		check = 1;
 	} else {
-		dout("invalidate_pages %p gen %d raced, gen now %d\n",
-		     inode, orig_gen, ci->i_rdcache_gen);
+		dout("invalidate_pages %p gen %d raced, now %d revoking %d\n",
+		     inode, orig_gen, ci->i_rdcache_gen,
+		     ci->i_rdcache_revoking);
 	}
 	spin_unlock(&inode->i_lock);
 
@@ -1739,7 +1751,7 @@
 		return 0;
 	}
 
-	dout("do_getattr inode %p mask %s\n", inode, ceph_cap_string(mask));
+	dout("do_getattr inode %p mask %s mode 0%o\n", inode, ceph_cap_string(mask), inode->i_mode);
 	if (ceph_caps_issued_mask(ceph_inode(inode), mask, 1))
 		return 0;
 
diff -urN linux-2.6.37-rc2/fs/ceph/mds_client.c linux-2.6.37-rc3/fs/ceph/mds_client.c
--- linux-2.6.37-rc2/fs/ceph/mds_client.c	2010-11-21 23:40:12.627086226 +0000
+++ linux-2.6.37-rc3/fs/ceph/mds_client.c	2010-11-21 23:40:17.929107106 +0000
@@ -6,7 +6,6 @@
 #include <linux/sched.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
-#include <linux/smp_lock.h>
 
 #include "super.h"
 #include "mds_client.h"
@@ -529,6 +528,9 @@
 	ceph_mdsc_get_request(req);
 	__insert_request(mdsc, req);
 
+	req->r_uid = current_fsuid();
+	req->r_gid = current_fsgid();
+
 	if (dir) {
 		struct ceph_inode_info *ci = ceph_inode(dir);
 
@@ -1588,8 +1590,8 @@
 
 	head->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);
 	head->op = cpu_to_le32(req->r_op);
-	head->caller_uid = cpu_to_le32(current_fsuid());
-	head->caller_gid = cpu_to_le32(current_fsgid());
+	head->caller_uid = cpu_to_le32(req->r_uid);
+	head->caller_gid = cpu_to_le32(req->r_gid);
 	head->args = req->r_args;
 
 	ceph_encode_filepath(&p, end, ino1, path1);
diff -urN linux-2.6.37-rc2/fs/ceph/mds_client.h linux-2.6.37-rc3/fs/ceph/mds_client.h
--- linux-2.6.37-rc2/fs/ceph/mds_client.h	2010-11-21 23:40:12.627086226 +0000
+++ linux-2.6.37-rc3/fs/ceph/mds_client.h	2010-11-21 23:40:17.929107106 +0000
@@ -170,6 +170,8 @@
 
 	union ceph_mds_request_args r_args;
 	int r_fmode;        /* file mode, if expecting cap */
+	uid_t r_uid;
+	gid_t r_gid;
 
 	/* for choosing which mds to send this request to */
 	int r_direct_mode;
diff -urN linux-2.6.37-rc2/fs/ceph/super.h linux-2.6.37-rc3/fs/ceph/super.h
--- linux-2.6.37-rc2/fs/ceph/super.h	2010-11-21 23:40:12.632086381 +0000
+++ linux-2.6.37-rc3/fs/ceph/super.h	2010-11-21 23:40:17.934115827 +0000
@@ -293,9 +293,7 @@
 	int i_rd_ref, i_rdcache_ref, i_wr_ref;
 	int i_wrbuffer_ref, i_wrbuffer_ref_head;
 	u32 i_shared_gen;       /* increment each time we get FILE_SHARED */
-	u32 i_rdcache_gen;      /* we increment this each time we get
-				   FILE_CACHE.  If it's non-zero, we
-				   _may_ have cached pages. */
+	u32 i_rdcache_gen;      /* incremented each time we get FILE_CACHE. */
 	u32 i_rdcache_revoking; /* RDCACHE gen to async invalidate, if any */
 
 	struct list_head i_unsafe_writes; /* uncommitted sync writes */
diff -urN linux-2.6.37-rc2/fs/compat_ioctl.c linux-2.6.37-rc3/fs/compat_ioctl.c
--- linux-2.6.37-rc2/fs/compat_ioctl.c	2010-11-21 23:40:12.642086193 +0000
+++ linux-2.6.37-rc3/fs/compat_ioctl.c	2010-11-21 23:40:17.944218457 +0000
@@ -19,7 +19,6 @@
 #include <linux/compiler.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/ioctl.h>
 #include <linux/if.h>
 #include <linux/if_bridge.h>
diff -urN linux-2.6.37-rc2/fs/ecryptfs/super.c linux-2.6.37-rc3/fs/ecryptfs/super.c
--- linux-2.6.37-rc2/fs/ecryptfs/super.c	2010-11-21 23:40:12.646086202 +0000
+++ linux-2.6.37-rc3/fs/ecryptfs/super.c	2010-11-21 23:40:17.948242489 +0000
@@ -28,7 +28,6 @@
 #include <linux/key.h>
 #include <linux/slab.h>
 #include <linux/seq_file.h>
-#include <linux/smp_lock.h>
 #include <linux/file.h>
 #include <linux/crypto.h>
 #include "ecryptfs_kernel.h"
diff -urN linux-2.6.37-rc2/fs/ext3/super.c linux-2.6.37-rc3/fs/ext3/super.c
--- linux-2.6.37-rc2/fs/ext3/super.c	2010-11-21 23:40:12.651086269 +0000
+++ linux-2.6.37-rc3/fs/ext3/super.c	2010-11-21 23:40:17.954121741 +0000
@@ -27,7 +27,6 @@
 #include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/parser.h>
-#include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/exportfs.h>
 #include <linux/vfs.h>
diff -urN linux-2.6.37-rc2/fs/ext4/ioctl.c linux-2.6.37-rc3/fs/ext4/ioctl.c
--- linux-2.6.37-rc2/fs/ext4/ioctl.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/fs/ext4/ioctl.c	2010-11-21 23:40:17.957242492 +0000
@@ -331,6 +331,30 @@
 		return err;
 	}
 
+	case FITRIM:
+	{
+		struct super_block *sb = inode->i_sb;
+		struct fstrim_range range;
+		int ret = 0;
+
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+
+		if (copy_from_user(&range, (struct fstrim_range *)arg,
+		    sizeof(range)))
+			return -EFAULT;
+
+		ret = ext4_trim_fs(sb, &range);
+		if (ret < 0)
+			return ret;
+
+		if (copy_to_user((struct fstrim_range *)arg, &range,
+		    sizeof(range)))
+			return -EFAULT;
+
+		return 0;
+	}
+
 	default:
 		return -ENOTTY;
 	}
diff -urN linux-2.6.37-rc2/fs/ext4/page-io.c linux-2.6.37-rc3/fs/ext4/page-io.c
--- linux-2.6.37-rc2/fs/ext4/page-io.c	2010-11-21 23:40:12.657086321 +0000
+++ linux-2.6.37-rc3/fs/ext4/page-io.c	2010-11-21 23:40:17.959077717 +0000
@@ -237,8 +237,6 @@
 			} while (bh != head);
 		}
 
-		put_io_page(io_end->pages[i]);
-
 		/*
 		 * If this is a partial write which happened to make
 		 * all buffers uptodate then we can optimize away a
@@ -248,6 +246,8 @@
 		 */
 		if (!partial_write)
 			SetPageUptodate(page);
+
+		put_io_page(io_end->pages[i]);
 	}
 	io_end->num_io_pages = 0;
 	inode = io_end->inode;
diff -urN linux-2.6.37-rc2/fs/ext4/super.c linux-2.6.37-rc3/fs/ext4/super.c
--- linux-2.6.37-rc2/fs/ext4/super.c	2010-11-21 23:40:12.658086255 +0000
+++ linux-2.6.37-rc3/fs/ext4/super.c	2010-11-21 23:40:17.960242540 +0000
@@ -1197,7 +1197,6 @@
 	.quota_write	= ext4_quota_write,
 #endif
 	.bdev_try_to_free_page = bdev_try_to_free_page,
-	.trim_fs	= ext4_trim_fs
 };
 
 static const struct super_operations ext4_nojournal_sops = {
@@ -2799,9 +2798,6 @@
 	struct ext4_li_request *elr;
 
 	mutex_lock(&ext4_li_info->li_list_mtx);
-	if (list_empty(&ext4_li_info->li_request_list))
-		return;
-
 	list_for_each_safe(pos, n, &ext4_li_info->li_request_list) {
 		elr = list_entry(pos, struct ext4_li_request,
 				 lr_request);
@@ -3268,13 +3264,14 @@
 	 * Test whether we have more sectors than will fit in sector_t,
 	 * and whether the max offset is addressable by the page cache.
 	 */
-	ret = generic_check_addressable(sb->s_blocksize_bits,
+	err = generic_check_addressable(sb->s_blocksize_bits,
 					ext4_blocks_count(es));
-	if (ret) {
+	if (err) {
 		ext4_msg(sb, KERN_ERR, "filesystem"
 			 " too large to mount safely on this system");
 		if (sizeof(sector_t) < 8)
 			ext4_msg(sb, KERN_WARNING, "CONFIG_LBDAF not enabled");
+		ret = err;
 		goto failed_mount;
 	}
 
diff -urN linux-2.6.37-rc2/fs/ioctl.c linux-2.6.37-rc3/fs/ioctl.c
--- linux-2.6.37-rc2/fs/ioctl.c	2010-11-21 23:40:12.671076977 +0000
+++ linux-2.6.37-rc3/fs/ioctl.c	2010-11-21 23:40:17.974242588 +0000
@@ -6,7 +6,6 @@
 
 #include <linux/syscalls.h>
 #include <linux/mm.h>
-#include <linux/smp_lock.h>
 #include <linux/capability.h>
 #include <linux/file.h>
 #include <linux/fs.h>
@@ -530,41 +529,6 @@
 	return thaw_super(sb);
 }
 
-static int ioctl_fstrim(struct file *filp, void __user *argp)
-{
-	struct super_block *sb = filp->f_path.dentry->d_inode->i_sb;
-	struct fstrim_range range;
-	int ret = 0;
-
-	if (!capable(CAP_SYS_ADMIN))
-		return -EPERM;
-
-	/* If filesystem doesn't support trim feature, return. */
-	if (sb->s_op->trim_fs == NULL)
-		return -EOPNOTSUPP;
-
-	/* If a blockdevice-backed filesystem isn't specified, return EINVAL. */
-	if (sb->s_bdev == NULL)
-		return -EINVAL;
-
-	if (argp == NULL) {
-		range.start = 0;
-		range.len = ULLONG_MAX;
-		range.minlen = 0;
-	} else if (copy_from_user(&range, argp, sizeof(range)))
-		return -EFAULT;
-
-	ret = sb->s_op->trim_fs(sb, &range);
-	if (ret < 0)
-		return ret;
-
-	if ((argp != NULL) &&
-	    (copy_to_user(argp, &range, sizeof(range))))
-		return -EFAULT;
-
-	return 0;
-}
-
 /*
  * When you add any new common ioctls to the switches above and below
  * please update compat_sys_ioctl() too.
@@ -615,10 +579,6 @@
 		error = ioctl_fsthaw(filp);
 		break;
 
-	case FITRIM:
-		error = ioctl_fstrim(filp, argp);
-		break;
-
 	case FS_IOC_FIEMAP:
 		return ioctl_fiemap(filp, arg);
 
diff -urN linux-2.6.37-rc2/fs/jbd2/journal.c linux-2.6.37-rc3/fs/jbd2/journal.c
--- linux-2.6.37-rc2/fs/jbd2/journal.c	2010-11-21 23:40:12.674086296 +0000
+++ linux-2.6.37-rc3/fs/jbd2/journal.c	2010-11-21 23:40:17.977242547 +0000
@@ -899,6 +899,14 @@
 
 	/* journal descriptor can store up to n blocks -bzzz */
 	journal->j_blocksize = blocksize;
+	journal->j_dev = bdev;
+	journal->j_fs_dev = fs_dev;
+	journal->j_blk_offset = start;
+	journal->j_maxlen = len;
+	bdevname(journal->j_dev, journal->j_devname);
+	p = journal->j_devname;
+	while ((p = strchr(p, '/')))
+		*p = '!';
 	jbd2_stats_proc_init(journal);
 	n = journal->j_blocksize / sizeof(journal_block_tag_t);
 	journal->j_wbufsize = n;
@@ -908,14 +916,6 @@
 			__func__);
 		goto out_err;
 	}
-	journal->j_dev = bdev;
-	journal->j_fs_dev = fs_dev;
-	journal->j_blk_offset = start;
-	journal->j_maxlen = len;
-	bdevname(journal->j_dev, journal->j_devname);
-	p = journal->j_devname;
-	while ((p = strchr(p, '/')))
-		*p = '!';
 
 	bh = __getblk(journal->j_dev, start, journal->j_blocksize);
 	if (!bh) {
diff -urN linux-2.6.37-rc2/fs/lockd/clntlock.c linux-2.6.37-rc3/fs/lockd/clntlock.c
--- linux-2.6.37-rc2/fs/lockd/clntlock.c	2010-11-21 23:40:12.678086242 +0000
+++ linux-2.6.37-rc3/fs/lockd/clntlock.c	2010-11-21 23:40:17.981242485 +0000
@@ -14,7 +14,6 @@
 #include <linux/sunrpc/clnt.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/lockd/lockd.h>
-#include <linux/smp_lock.h>
 #include <linux/kthread.h>
 
 #define NLMDBG_FACILITY		NLMDBG_CLIENT
diff -urN linux-2.6.37-rc2/fs/lockd/clntproc.c linux-2.6.37-rc3/fs/lockd/clntproc.c
--- linux-2.6.37-rc2/fs/lockd/clntproc.c	2010-11-21 23:40:12.678086242 +0000
+++ linux-2.6.37-rc3/fs/lockd/clntproc.c	2010-11-21 23:40:17.981242485 +0000
@@ -7,7 +7,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/errno.h>
diff -urN linux-2.6.37-rc2/fs/lockd/host.c linux-2.6.37-rc3/fs/lockd/host.c
--- linux-2.6.37-rc2/fs/lockd/host.c	2010-11-21 23:40:12.679086255 +0000
+++ linux-2.6.37-rc3/fs/lockd/host.c	2010-11-21 23:40:17.981242485 +0000
@@ -124,7 +124,7 @@
 			continue;
 		if (host->h_server != ni->server)
 			continue;
-		if (ni->server &&
+		if (ni->server && ni->src_len != 0 &&
 		    !rpc_cmp_addr(nlm_srcaddr(host), ni->src_sap))
 			continue;
 
@@ -167,6 +167,7 @@
 	host->h_addrlen = ni->salen;
 	rpc_set_port(nlm_addr(host), 0);
 	memcpy(nlm_srcaddr(host), ni->src_sap, ni->src_len);
+	host->h_srcaddrlen = ni->src_len;
 	host->h_version    = ni->version;
 	host->h_proto      = ni->protocol;
 	host->h_rpcclnt    = NULL;
@@ -238,9 +239,6 @@
 				     const char *hostname,
 				     int noresvport)
 {
-	const struct sockaddr source = {
-		.sa_family	= AF_UNSPEC,
-	};
 	struct nlm_lookup_host_info ni = {
 		.server		= 0,
 		.sap		= sap,
@@ -249,8 +247,6 @@
 		.version	= version,
 		.hostname	= hostname,
 		.hostname_len	= strlen(hostname),
-		.src_sap	= &source,
-		.src_len	= sizeof(source),
 		.noresvport	= noresvport,
 	};
 
@@ -357,7 +353,6 @@
 			.protocol	= host->h_proto,
 			.address	= nlm_addr(host),
 			.addrsize	= host->h_addrlen,
-			.saddress	= nlm_srcaddr(host),
 			.timeout	= &timeparms,
 			.servername	= host->h_name,
 			.program	= &nlm_program,
@@ -376,6 +371,8 @@
 			args.flags |= RPC_CLNT_CREATE_HARDRTRY;
 		if (host->h_noresvport)
 			args.flags |= RPC_CLNT_CREATE_NONPRIVPORT;
+		if (host->h_srcaddrlen)
+			args.saddress = nlm_srcaddr(host);
 
 		clnt = rpc_create(&args);
 		if (!IS_ERR(clnt))
diff -urN linux-2.6.37-rc2/fs/lockd/svc4proc.c linux-2.6.37-rc3/fs/lockd/svc4proc.c
--- linux-2.6.37-rc2/fs/lockd/svc4proc.c	2010-11-21 23:40:12.679086255 +0000
+++ linux-2.6.37-rc3/fs/lockd/svc4proc.c	2010-11-21 23:40:17.982242493 +0000
@@ -9,7 +9,6 @@
 
 #include <linux/types.h>
 #include <linux/time.h>
-#include <linux/smp_lock.h>
 #include <linux/lockd/lockd.h>
 #include <linux/lockd/share.h>
 
diff -urN linux-2.6.37-rc2/fs/lockd/svclock.c linux-2.6.37-rc3/fs/lockd/svclock.c
--- linux-2.6.37-rc2/fs/lockd/svclock.c	2010-11-21 23:40:12.679086255 +0000
+++ linux-2.6.37-rc3/fs/lockd/svclock.c	2010-11-21 23:40:17.982242493 +0000
@@ -25,7 +25,6 @@
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <linux/sunrpc/clnt.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/lockd/nlm.h>
diff -urN linux-2.6.37-rc2/fs/lockd/svcproc.c linux-2.6.37-rc3/fs/lockd/svcproc.c
--- linux-2.6.37-rc2/fs/lockd/svcproc.c	2010-11-21 23:40:12.679086255 +0000
+++ linux-2.6.37-rc3/fs/lockd/svcproc.c	2010-11-21 23:40:17.982242493 +0000
@@ -9,7 +9,6 @@
 
 #include <linux/types.h>
 #include <linux/time.h>
-#include <linux/smp_lock.h>
 #include <linux/lockd/lockd.h>
 #include <linux/lockd/share.h>
 
diff -urN linux-2.6.37-rc2/fs/locks.c linux-2.6.37-rc3/fs/locks.c
--- linux-2.6.37-rc2/fs/locks.c	2010-11-21 23:40:12.680086246 +0000
+++ linux-2.6.37-rc3/fs/locks.c	2010-11-21 23:40:17.983121036 +0000
@@ -122,7 +122,6 @@
 #include <linux/module.h>
 #include <linux/security.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/syscalls.h>
 #include <linux/time.h>
 #include <linux/rcupdate.h>
diff -urN linux-2.6.37-rc2/fs/namespace.c linux-2.6.37-rc3/fs/namespace.c
--- linux-2.6.37-rc2/fs/namespace.c	2010-11-21 23:40:12.681086282 +0000
+++ linux-2.6.37-rc3/fs/namespace.c	2010-11-21 23:40:17.984242496 +0000
@@ -13,7 +13,6 @@
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/percpu.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/acct.h>
diff -urN linux-2.6.37-rc2/fs/ncpfs/dir.c linux-2.6.37-rc3/fs/ncpfs/dir.c
--- linux-2.6.37-rc2/fs/ncpfs/dir.c	2010-11-21 23:40:12.682086238 +0000
+++ linux-2.6.37-rc3/fs/ncpfs/dir.c	2010-11-21 23:40:17.985229778 +0000
@@ -19,7 +19,6 @@
 #include <linux/mm.h>
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
-#include <linux/smp_lock.h>
 
 #include <linux/ncp_fs.h>
 
diff -urN linux-2.6.37-rc2/fs/ncpfs/file.c linux-2.6.37-rc3/fs/ncpfs/file.c
--- linux-2.6.37-rc2/fs/ncpfs/file.c	2010-11-21 23:40:12.682086238 +0000
+++ linux-2.6.37-rc3/fs/ncpfs/file.c	2010-11-21 23:40:17.985229778 +0000
@@ -17,7 +17,6 @@
 #include <linux/mm.h>
 #include <linux/vmalloc.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 
 #include <linux/ncp_fs.h>
 #include "ncplib_kernel.h"
diff -urN linux-2.6.37-rc2/fs/ncpfs/inode.c linux-2.6.37-rc3/fs/ncpfs/inode.c
--- linux-2.6.37-rc2/fs/ncpfs/inode.c	2010-11-21 23:40:12.682086238 +0000
+++ linux-2.6.37-rc3/fs/ncpfs/inode.c	2010-11-21 23:40:17.985229778 +0000
@@ -26,7 +26,6 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/vfs.h>
 #include <linux/mount.h>
 #include <linux/seq_file.h>
diff -urN linux-2.6.37-rc2/fs/ncpfs/ioctl.c linux-2.6.37-rc3/fs/ncpfs/ioctl.c
--- linux-2.6.37-rc2/fs/ncpfs/ioctl.c	2010-11-21 23:40:12.683086391 +0000
+++ linux-2.6.37-rc3/fs/ncpfs/ioctl.c	2010-11-21 23:40:17.986242451 +0000
@@ -17,7 +17,6 @@
 #include <linux/mount.h>
 #include <linux/slab.h>
 #include <linux/highuid.h>
-#include <linux/smp_lock.h>
 #include <linux/vmalloc.h>
 #include <linux/sched.h>
 
diff -urN linux-2.6.37-rc2/fs/nfs/callback.c linux-2.6.37-rc3/fs/nfs/callback.c
--- linux-2.6.37-rc2/fs/nfs/callback.c	2010-11-21 23:40:12.684086285 +0000
+++ linux-2.6.37-rc3/fs/nfs/callback.c	2010-11-21 23:40:17.986242451 +0000
@@ -9,7 +9,6 @@
 #include <linux/completion.h>
 #include <linux/ip.h>
 #include <linux/module.h>
-#include <linux/smp_lock.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/sunrpc/svcsock.h>
 #include <linux/nfs_fs.h>
diff -urN linux-2.6.37-rc2/fs/nfs/delegation.c linux-2.6.37-rc3/fs/nfs/delegation.c
--- linux-2.6.37-rc2/fs/nfs/delegation.c	2010-11-21 23:40:12.684086285 +0000
+++ linux-2.6.37-rc3/fs/nfs/delegation.c	2010-11-21 23:40:17.987242517 +0000
@@ -11,7 +11,6 @@
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 
 #include <linux/nfs4.h>
diff -urN linux-2.6.37-rc2/fs/nfs/dir.c linux-2.6.37-rc3/fs/nfs/dir.c
--- linux-2.6.37-rc2/fs/nfs/dir.c	2010-11-21 23:40:12.685065134 +0000
+++ linux-2.6.37-rc3/fs/nfs/dir.c	2010-11-21 23:40:17.988242516 +0000
@@ -34,6 +34,7 @@
 #include <linux/mount.h>
 #include <linux/sched.h>
 #include <linux/vmalloc.h>
+#include <linux/kmemleak.h>
 
 #include "delegation.h"
 #include "iostat.h"
@@ -194,9 +195,13 @@
 static
 struct nfs_cache_array *nfs_readdir_get_array(struct page *page)
 {
+	void *ptr;
 	if (page == NULL)
 		return ERR_PTR(-EIO);
-	return (struct nfs_cache_array *)kmap(page);
+	ptr = kmap(page);
+	if (ptr == NULL)
+		return ERR_PTR(-ENOMEM);
+	return ptr;
 }
 
 static
@@ -213,6 +218,9 @@
 {
 	struct nfs_cache_array *array = nfs_readdir_get_array(page);
 	int i;
+
+	if (IS_ERR(array))
+		return PTR_ERR(array);
 	for (i = 0; i < array->size; i++)
 		kfree(array->array[i].string.name);
 	nfs_readdir_release_array(page);
@@ -231,6 +239,11 @@
 	string->name = kmemdup(name, len, GFP_KERNEL);
 	if (string->name == NULL)
 		return -ENOMEM;
+	/*
+	 * Avoid a kmemleak false positive. The pointer to the name is stored
+	 * in a page cache page which kmemleak does not scan.
+	 */
+	kmemleak_not_leak(string->name);
 	string->hash = full_name_hash(name, len);
 	return 0;
 }
@@ -244,7 +257,7 @@
 
 	if (IS_ERR(array))
 		return PTR_ERR(array);
-	ret = -EIO;
+	ret = -ENOSPC;
 	if (array->size >= MAX_READDIR_ARRAY)
 		goto out;
 
@@ -255,9 +268,9 @@
 	if (ret)
 		goto out;
 	array->last_cookie = entry->cookie;
+	array->size++;
 	if (entry->eof == 1)
 		array->eof_index = array->size;
-	array->size++;
 out:
 	nfs_readdir_release_array(page);
 	return ret;
@@ -272,7 +285,7 @@
 	if (diff < 0)
 		goto out_eof;
 	if (diff >= array->size) {
-		if (array->eof_index > 0)
+		if (array->eof_index >= 0)
 			goto out_eof;
 		desc->current_index += array->size;
 		return -EAGAIN;
@@ -281,8 +294,6 @@
 	index = (unsigned int)diff;
 	*desc->dir_cookie = array->array[index].cookie;
 	desc->cache_entry_index = index;
-	if (index == array->eof_index)
-		desc->eof = 1;
 	return 0;
 out_eof:
 	desc->eof = 1;
@@ -296,17 +307,17 @@
 	int status = -EAGAIN;
 
 	for (i = 0; i < array->size; i++) {
-		if (i == array->eof_index) {
-			desc->eof = 1;
-			status = -EBADCOOKIE;
-		}
 		if (array->array[i].cookie == *desc->dir_cookie) {
 			desc->cache_entry_index = i;
 			status = 0;
-			break;
+			goto out;
 		}
 	}
-
+	if (i == array->eof_index) {
+		desc->eof = 1;
+		status = -EBADCOOKIE;
+	}
+out:
 	return status;
 }
 
@@ -449,7 +460,7 @@
 
 /* Perform conversion from xdr to cache array */
 static
-void nfs_readdir_page_filler(nfs_readdir_descriptor_t *desc, struct nfs_entry *entry,
+int nfs_readdir_page_filler(nfs_readdir_descriptor_t *desc, struct nfs_entry *entry,
 				void *xdr_page, struct page *page, unsigned int buflen)
 {
 	struct xdr_stream stream;
@@ -471,21 +482,29 @@
 
 	do {
 		status = xdr_decode(desc, entry, &stream);
-		if (status != 0)
+		if (status != 0) {
+			if (status == -EAGAIN)
+				status = 0;
 			break;
+		}
 
-		if (nfs_readdir_add_to_array(entry, page) == -1)
-			break;
 		if (desc->plus == 1)
 			nfs_prime_dcache(desc->file->f_path.dentry, entry);
+
+		status = nfs_readdir_add_to_array(entry, page);
+		if (status != 0)
+			break;
 	} while (!entry->eof);
 
 	if (status == -EBADCOOKIE && entry->eof) {
 		array = nfs_readdir_get_array(page);
-		array->eof_index = array->size - 1;
-		status = 0;
-		nfs_readdir_release_array(page);
+		if (!IS_ERR(array)) {
+			array->eof_index = array->size;
+			status = 0;
+			nfs_readdir_release_array(page);
+		}
 	}
+	return status;
 }
 
 static
@@ -537,7 +556,7 @@
 	struct nfs_entry entry;
 	struct file	*file = desc->file;
 	struct nfs_cache_array *array;
-	int status = 0;
+	int status = -ENOMEM;
 	unsigned int array_size = ARRAY_SIZE(pages);
 
 	entry.prev_cookie = 0;
@@ -549,6 +568,10 @@
 		goto out;
 
 	array = nfs_readdir_get_array(page);
+	if (IS_ERR(array)) {
+		status = PTR_ERR(array);
+		goto out;
+	}
 	memset(array, 0, sizeof(struct nfs_cache_array));
 	array->eof_index = -1;
 
@@ -556,12 +579,19 @@
 	if (!pages_ptr)
 		goto out_release_array;
 	do {
+		unsigned int pglen;
 		status = nfs_readdir_xdr_filler(pages, desc, &entry, file, inode);
 
 		if (status < 0)
 			break;
-		nfs_readdir_page_filler(desc, &entry, pages_ptr, page, array_size * PAGE_SIZE);
-	} while (array->eof_index < 0 && array->size < MAX_READDIR_ARRAY);
+		pglen = status;
+		status = nfs_readdir_page_filler(desc, &entry, pages_ptr, page, pglen);
+		if (status < 0) {
+			if (status == -ENOSPC)
+				status = 0;
+			break;
+		}
+	} while (array->eof_index < 0);
 
 	nfs_readdir_free_large_page(pages_ptr, pages, array_size);
 out_release_array:
@@ -582,8 +612,10 @@
 int nfs_readdir_filler(nfs_readdir_descriptor_t *desc, struct page* page)
 {
 	struct inode	*inode = desc->file->f_path.dentry->d_inode;
+	int ret;
 
-	if (nfs_readdir_xdr_to_array(desc, page, inode) < 0)
+	ret = nfs_readdir_xdr_to_array(desc, page, inode);
+	if (ret < 0)
 		goto error;
 	SetPageUptodate(page);
 
@@ -595,7 +627,7 @@
 	return 0;
  error:
 	unlock_page(page);
-	return -EIO;
+	return ret;
 }
 
 static
@@ -608,12 +640,8 @@
 static
 struct page *get_cache_page(nfs_readdir_descriptor_t *desc)
 {
-	struct page *page;
-	page = read_cache_page(desc->file->f_path.dentry->d_inode->i_mapping,
+	return read_cache_page(desc->file->f_path.dentry->d_inode->i_mapping,
 			desc->page_index, (filler_t *)nfs_readdir_filler, desc);
-	if (IS_ERR(page))
-		desc->eof = 1;
-	return page;
 }
 
 /*
@@ -639,8 +667,10 @@
 static inline
 int readdir_search_pagecache(nfs_readdir_descriptor_t *desc)
 {
-	int res = -EAGAIN;
+	int res;
 
+	if (desc->page_index == 0)
+		desc->current_index = 0;
 	while (1) {
 		res = find_cache_page(desc);
 		if (res != -EAGAIN)
@@ -670,6 +700,8 @@
 	struct dentry *dentry = NULL;
 
 	array = nfs_readdir_get_array(desc->page);
+	if (IS_ERR(array))
+		return PTR_ERR(array);
 
 	for (i = desc->cache_entry_index; i < array->size; i++) {
 		d_type = DT_UNKNOWN;
@@ -685,11 +717,9 @@
 			*desc->dir_cookie = array->array[i+1].cookie;
 		else
 			*desc->dir_cookie = array->last_cookie;
-		if (i == array->eof_index) {
-			desc->eof = 1;
-			break;
-		}
 	}
+	if (i == array->eof_index)
+		desc->eof = 1;
 
 	nfs_readdir_release_array(desc->page);
 	cache_page_release(desc);
@@ -1345,12 +1375,12 @@
 				res = NULL;
 				goto out;
 			/* This turned out not to be a regular file */
-			case -EISDIR:
 			case -ENOTDIR:
 				goto no_open;
 			case -ELOOP:
 				if (!(nd->intent.open.flags & O_NOFOLLOW))
 					goto no_open;
+			/* case -EISDIR: */
 			/* case -EINVAL: */
 			default:
 				res = ERR_CAST(inode);
diff -urN linux-2.6.37-rc2/fs/nfs/nfs2xdr.c linux-2.6.37-rc3/fs/nfs/nfs2xdr.c
--- linux-2.6.37-rc2/fs/nfs/nfs2xdr.c	2010-11-21 23:40:12.687088193 +0000
+++ linux-2.6.37-rc3/fs/nfs/nfs2xdr.c	2010-11-21 23:40:17.989121881 +0000
@@ -423,7 +423,7 @@
 	struct page **page;
 	size_t hdrlen;
 	unsigned int pglen, recvd;
-	int status, nr = 0;
+	int status;
 
 	if ((status = ntohl(*p++)))
 		return nfs_stat_to_errno(status);
@@ -443,7 +443,7 @@
 	if (pglen > recvd)
 		pglen = recvd;
 	page = rcvbuf->pages;
-	return nr;
+	return pglen;
 }
 
 static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)
diff -urN linux-2.6.37-rc2/fs/nfs/nfs3xdr.c linux-2.6.37-rc3/fs/nfs/nfs3xdr.c
--- linux-2.6.37-rc2/fs/nfs/nfs3xdr.c	2010-11-21 23:40:12.687088193 +0000
+++ linux-2.6.37-rc3/fs/nfs/nfs3xdr.c	2010-11-21 23:40:17.990242576 +0000
@@ -555,7 +555,7 @@
 	struct page **page;
 	size_t hdrlen;
 	u32 recvd, pglen;
-	int status, nr = 0;
+	int status;
 
 	status = ntohl(*p++);
 	/* Decode post_op_attrs */
@@ -586,7 +586,7 @@
 		pglen = recvd;
 	page = rcvbuf->pages;
 
-	return nr;
+	return pglen;
 }
 
 __be32 *
diff -urN linux-2.6.37-rc2/fs/nfs/nfs4proc.c linux-2.6.37-rc3/fs/nfs/nfs4proc.c
--- linux-2.6.37-rc2/fs/nfs/nfs4proc.c	2010-11-21 23:40:12.689086204 +0000
+++ linux-2.6.37-rc3/fs/nfs/nfs4proc.c	2010-11-21 23:40:17.992242433 +0000
@@ -2852,8 +2852,10 @@
 	nfs4_setup_readdir(cookie, NFS_COOKIEVERF(dir), dentry, &args);
 	res.pgbase = args.pgbase;
 	status = nfs4_call_sync(NFS_SERVER(dir), &msg, &args, &res, 0);
-	if (status == 0)
+	if (status >= 0) {
 		memcpy(NFS_COOKIEVERF(dir), res.verifier.data, NFS4_VERIFIER_SIZE);
+		status += args.pgbase;
+	}
 
 	nfs_invalidate_atime(dir);
 
diff -urN linux-2.6.37-rc2/fs/nfs/nfs4xdr.c linux-2.6.37-rc3/fs/nfs/nfs4xdr.c
--- linux-2.6.37-rc2/fs/nfs/nfs4xdr.c	2010-11-21 23:40:12.690086256 +0000
+++ linux-2.6.37-rc3/fs/nfs/nfs4xdr.c	2010-11-21 23:40:17.993242564 +0000
@@ -4518,7 +4518,7 @@
 	xdr_read_pages(xdr, pglen);
 
 
-	return 0;
+	return pglen;
 }
 
 static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
diff -urN linux-2.6.37-rc2/fs/nfs/super.c linux-2.6.37-rc3/fs/nfs/super.c
--- linux-2.6.37-rc2/fs/nfs/super.c	2010-11-21 23:40:12.692086260 +0000
+++ linux-2.6.37-rc3/fs/nfs/super.c	2010-11-21 23:40:17.995242546 +0000
@@ -39,7 +39,6 @@
 #include <linux/nfs_mount.h>
 #include <linux/nfs4_mount.h>
 #include <linux/lockd/bind.h>
-#include <linux/smp_lock.h>
 #include <linux/seq_file.h>
 #include <linux/mount.h>
 #include <linux/mnt_namespace.h>
@@ -67,6 +66,12 @@
 
 #define NFSDBG_FACILITY		NFSDBG_VFS
 
+#ifdef CONFIG_NFS_V3
+#define NFS_DEFAULT_VERSION 3
+#else
+#define NFS_DEFAULT_VERSION 2
+#endif
+
 enum {
 	/* Mount options that take no arguments */
 	Opt_soft, Opt_hard,
@@ -2277,7 +2282,7 @@
 	};
 	int error = -ENOMEM;
 
-	data = nfs_alloc_parsed_mount_data(3);
+	data = nfs_alloc_parsed_mount_data(NFS_DEFAULT_VERSION);
 	mntfh = nfs_alloc_fhandle();
 	if (data == NULL || mntfh == NULL)
 		goto out_free_fh;
diff -urN linux-2.6.37-rc2/fs/nfsd/nfs4state.c linux-2.6.37-rc3/fs/nfsd/nfs4state.c
--- linux-2.6.37-rc2/fs/nfsd/nfs4state.c	2010-11-21 23:40:12.695064947 +0000
+++ linux-2.6.37-rc3/fs/nfsd/nfs4state.c	2010-11-21 23:40:17.997242607 +0000
@@ -2262,7 +2262,7 @@
  * Spawn a thread to perform a recall on the delegation represented
  * by the lease (file_lock)
  *
- * Called from break_lease() with lock_kernel() held.
+ * Called from break_lease() with lock_flocks() held.
  * Note: we assume break_lease will only call this *once* for any given
  * lease.
  */
@@ -2286,7 +2286,7 @@
 	list_add_tail(&dp->dl_recall_lru, &del_recall_lru);
 	spin_unlock(&recall_lock);
 
-	/* only place dl_time is set. protected by lock_kernel*/
+	/* only place dl_time is set. protected by lock_flocks*/
 	dp->dl_time = get_seconds();
 
 	/*
@@ -2303,7 +2303,7 @@
 /*
  * The file_lock is being reapd.
  *
- * Called by locks_free_lock() with lock_kernel() held.
+ * Called by locks_free_lock() with lock_flocks() held.
  */
 static
 void nfsd_release_deleg_cb(struct file_lock *fl)
@@ -2318,7 +2318,7 @@
 }
 
 /*
- * Called from setlease() with lock_kernel() held
+ * Called from setlease() with lock_flocks() held
  */
 static
 int nfsd_same_client_deleg_cb(struct file_lock *onlist, struct file_lock *try)
diff -urN linux-2.6.37-rc2/fs/ocfs2/super.c linux-2.6.37-rc3/fs/ocfs2/super.c
--- linux-2.6.37-rc2/fs/ocfs2/super.c	2010-11-21 23:40:12.711086269 +0000
+++ linux-2.6.37-rc3/fs/ocfs2/super.c	2010-11-21 23:40:18.013068106 +0000
@@ -41,7 +41,6 @@
 #include <linux/mount.h>
 #include <linux/seq_file.h>
 #include <linux/quotaops.h>
-#include <linux/smp_lock.h>
 
 #define MLOG_MASK_PREFIX ML_SUPER
 #include <cluster/masklog.h>
diff -urN linux-2.6.37-rc2/fs/proc/inode.c linux-2.6.37-rc3/fs/proc/inode.c
--- linux-2.6.37-rc2/fs/proc/inode.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/fs/proc/inode.c	2010-11-21 23:40:18.016078788 +0000
@@ -16,7 +16,6 @@
 #include <linux/limits.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/smp_lock.h>
 #include <linux/sysctl.h>
 #include <linux/slab.h>
 
diff -urN linux-2.6.37-rc2/fs/read_write.c linux-2.6.37-rc3/fs/read_write.c
--- linux-2.6.37-rc2/fs/read_write.c	2010-11-21 23:40:12.715086372 +0000
+++ linux-2.6.37-rc3/fs/read_write.c	2010-11-21 23:40:18.018242577 +0000
@@ -9,7 +9,6 @@
 #include <linux/fcntl.h>
 #include <linux/file.h>
 #include <linux/uio.h>
-#include <linux/smp_lock.h>
 #include <linux/fsnotify.h>
 #include <linux/security.h>
 #include <linux/module.h>
diff -urN linux-2.6.37-rc2/fs/reiserfs/inode.c linux-2.6.37-rc3/fs/reiserfs/inode.c
--- linux-2.6.37-rc2/fs/reiserfs/inode.c	2010-11-21 23:40:12.716086219 +0000
+++ linux-2.6.37-rc3/fs/reiserfs/inode.c	2010-11-21 23:40:18.019097334 +0000
@@ -8,7 +8,6 @@
 #include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/exportfs.h>
-#include <linux/smp_lock.h>
 #include <linux/pagemap.h>
 #include <linux/highmem.h>
 #include <linux/slab.h>
diff -urN linux-2.6.37-rc2/fs/reiserfs/ioctl.c linux-2.6.37-rc3/fs/reiserfs/ioctl.c
--- linux-2.6.37-rc2/fs/reiserfs/ioctl.c	2010-11-21 23:40:12.716086219 +0000
+++ linux-2.6.37-rc3/fs/reiserfs/ioctl.c	2010-11-21 23:40:18.019097334 +0000
@@ -9,7 +9,6 @@
 #include <linux/time.h>
 #include <asm/uaccess.h>
 #include <linux/pagemap.h>
-#include <linux/smp_lock.h>
 #include <linux/compat.h>
 
 /*
diff -urN linux-2.6.37-rc2/fs/reiserfs/journal.c linux-2.6.37-rc3/fs/reiserfs/journal.c
--- linux-2.6.37-rc2/fs/reiserfs/journal.c	2010-11-21 23:40:12.716086219 +0000
+++ linux-2.6.37-rc3/fs/reiserfs/journal.c	2010-11-21 23:40:18.020041443 +0000
@@ -43,7 +43,6 @@
 #include <linux/fcntl.h>
 #include <linux/stat.h>
 #include <linux/string.h>
-#include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/workqueue.h>
 #include <linux/writeback.h>
diff -urN linux-2.6.37-rc2/fs/reiserfs/super.c linux-2.6.37-rc3/fs/reiserfs/super.c
--- linux-2.6.37-rc2/fs/reiserfs/super.c	2010-11-21 23:40:12.717086142 +0000
+++ linux-2.6.37-rc3/fs/reiserfs/super.c	2010-11-21 23:40:18.020041443 +0000
@@ -28,7 +28,6 @@
 #include <linux/mount.h>
 #include <linux/namei.h>
 #include <linux/crc32.h>
-#include <linux/smp_lock.h>
 
 struct file_system_type reiserfs_fs_type;
 
diff -urN linux-2.6.37-rc2/include/drm/nouveau_drm.h linux-2.6.37-rc3/include/drm/nouveau_drm.h
--- linux-2.6.37-rc2/include/drm/nouveau_drm.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/include/drm/nouveau_drm.h	2010-11-21 23:40:18.050242483 +0000
@@ -80,6 +80,7 @@
 #define NOUVEAU_GETPARAM_VM_VRAM_BASE    12
 #define NOUVEAU_GETPARAM_GRAPH_UNITS     13
 #define NOUVEAU_GETPARAM_PTIMER_TIME     14
+#define NOUVEAU_GETPARAM_HAS_BO_USAGE    15
 struct drm_nouveau_getparam {
 	uint64_t param;
 	uint64_t value;
@@ -95,6 +96,12 @@
 #define NOUVEAU_GEM_DOMAIN_GART      (1 << 2)
 #define NOUVEAU_GEM_DOMAIN_MAPPABLE  (1 << 3)
 
+#define NOUVEAU_GEM_TILE_LAYOUT_MASK 0x0000ff00
+#define NOUVEAU_GEM_TILE_16BPP       0x00000001
+#define NOUVEAU_GEM_TILE_32BPP       0x00000002
+#define NOUVEAU_GEM_TILE_ZETA        0x00000004
+#define NOUVEAU_GEM_TILE_NONCONTIG   0x00000008
+
 struct drm_nouveau_gem_info {
 	uint32_t handle;
 	uint32_t domain;
diff -urN linux-2.6.37-rc2/include/linux/ceph/libceph.h linux-2.6.37-rc3/include/linux/ceph/libceph.h
--- linux-2.6.37-rc2/include/linux/ceph/libceph.h	2010-11-21 23:40:12.750086192 +0000
+++ linux-2.6.37-rc3/include/linux/ceph/libceph.h	2010-11-21 23:40:18.053242604 +0000
@@ -227,8 +227,7 @@
 extern void ceph_release_page_vector(struct page **pages, int num_pages);
 
 extern struct page **ceph_get_direct_page_vector(const char __user *data,
-					    int num_pages,
-					    loff_t off, size_t len);
+						 int num_pages);
 extern void ceph_put_page_vector(struct page **pages, int num_pages);
 extern void ceph_release_page_vector(struct page **pages, int num_pages);
 extern struct page **ceph_alloc_page_vector(int num_pages, gfp_t flags);
diff -urN linux-2.6.37-rc2/include/linux/ceph/messenger.h linux-2.6.37-rc3/include/linux/ceph/messenger.h
--- linux-2.6.37-rc2/include/linux/ceph/messenger.h	2010-11-21 23:40:12.750086192 +0000
+++ linux-2.6.37-rc3/include/linux/ceph/messenger.h	2010-11-21 23:40:18.054242541 +0000
@@ -82,6 +82,7 @@
 	struct ceph_buffer *middle;
 	struct page **pages;            /* data payload.  NOT OWNER. */
 	unsigned nr_pages;              /* size of page array */
+	unsigned page_alignment;        /* io offset in first page */
 	struct ceph_pagelist *pagelist; /* instead of pages */
 	struct list_head list_head;
 	struct kref kref;
diff -urN linux-2.6.37-rc2/include/linux/ceph/osd_client.h linux-2.6.37-rc3/include/linux/ceph/osd_client.h
--- linux-2.6.37-rc2/include/linux/ceph/osd_client.h	2010-11-21 23:40:12.750086192 +0000
+++ linux-2.6.37-rc3/include/linux/ceph/osd_client.h	2010-11-21 23:40:18.054242541 +0000
@@ -79,6 +79,7 @@
 	struct ceph_file_layout r_file_layout;
 	struct ceph_snap_context *r_snapc;    /* snap context for writes */
 	unsigned          r_num_pages;        /* size of page array (follows) */
+	unsigned          r_page_alignment;   /* io offset in first page */
 	struct page     **r_pages;            /* pages for data payload */
 	int               r_pages_from_pool;
 	int               r_own_pages;        /* if true, i own page list */
@@ -194,7 +195,8 @@
 				      int do_sync, u32 truncate_seq,
 				      u64 truncate_size,
 				      struct timespec *mtime,
-				      bool use_mempool, int num_reply);
+				      bool use_mempool, int num_reply,
+				      int page_align);
 
 static inline void ceph_osdc_get_request(struct ceph_osd_request *req)
 {
@@ -218,7 +220,8 @@
 			       struct ceph_file_layout *layout,
 			       u64 off, u64 *plen,
 			       u32 truncate_seq, u64 truncate_size,
-			       struct page **pages, int nr_pages);
+			       struct page **pages, int nr_pages,
+			       int page_align);
 
 extern int ceph_osdc_writepages(struct ceph_osd_client *osdc,
 				struct ceph_vino vino,
diff -urN linux-2.6.37-rc2/include/linux/fs.h linux-2.6.37-rc3/include/linux/fs.h
--- linux-2.6.37-rc2/include/linux/fs.h	2010-11-21 23:40:12.755086276 +0000
+++ linux-2.6.37-rc3/include/linux/fs.h	2010-11-21 23:40:18.059108646 +0000
@@ -1612,7 +1612,6 @@
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
-	int (*trim_fs) (struct super_block *, struct fstrim_range *);
 };
 
 /*
diff -urN linux-2.6.37-rc2/include/linux/hardirq.h linux-2.6.37-rc3/include/linux/hardirq.h
--- linux-2.6.37-rc2/include/linux/hardirq.h	2010-11-21 23:40:12.756086208 +0000
+++ linux-2.6.37-rc3/include/linux/hardirq.h	2010-11-21 23:40:18.060242523 +0000
@@ -2,9 +2,6 @@
 #define LINUX_HARDIRQ_H
 
 #include <linux/preempt.h>
-#ifdef CONFIG_PREEMPT
-#include <linux/smp_lock.h>
-#endif
 #include <linux/lockdep.h>
 #include <linux/ftrace_irq.h>
 #include <asm/hardirq.h>
@@ -97,7 +94,8 @@
 #define in_nmi()	(preempt_count() & NMI_MASK)
 
 #if defined(CONFIG_PREEMPT) && defined(CONFIG_BKL)
-# define PREEMPT_INATOMIC_BASE kernel_locked()
+# include <linux/sched.h>
+# define PREEMPT_INATOMIC_BASE (current->lock_depth >= 0)
 #else
 # define PREEMPT_INATOMIC_BASE 0
 #endif
diff -urN linux-2.6.37-rc2/include/linux/libata.h linux-2.6.37-rc3/include/linux/libata.h
--- linux-2.6.37-rc2/include/linux/libata.h	2010-11-21 23:40:12.763086207 +0000
+++ linux-2.6.37-rc3/include/linux/libata.h	2010-11-21 23:40:18.067040096 +0000
@@ -986,7 +986,7 @@
 			  unsigned long, struct ata_port_operations *);
 extern int ata_scsi_detect(struct scsi_host_template *sht);
 extern int ata_scsi_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
-extern int ata_scsi_queuecmd(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *));
+extern int ata_scsi_queuecmd(struct Scsi_Host *h, struct scsi_cmnd *cmd);
 extern int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *dev,
 			    int cmd, void __user *arg);
 extern void ata_sas_port_destroy(struct ata_port *);
diff -urN linux-2.6.37-rc2/include/linux/lockd/lockd.h linux-2.6.37-rc3/include/linux/lockd/lockd.h
--- linux-2.6.37-rc2/include/linux/lockd/lockd.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/include/linux/lockd/lockd.h	2010-11-21 23:40:18.067040096 +0000
@@ -43,6 +43,7 @@
 	struct sockaddr_storage	h_addr;		/* peer address */
 	size_t			h_addrlen;
 	struct sockaddr_storage	h_srcaddr;	/* our address (optional) */
+	size_t			h_srcaddrlen;
 	struct rpc_clnt		*h_rpcclnt;	/* RPC client to talk to peer */
 	char			*h_name;		/* remote hostname */
 	u32			h_version;	/* interface version */
diff -urN linux-2.6.37-rc2/include/linux/nfs_fs.h linux-2.6.37-rc3/include/linux/nfs_fs.h
--- linux-2.6.37-rc2/include/linux/nfs_fs.h	2010-11-21 23:40:12.771090322 +0000
+++ linux-2.6.37-rc3/include/linux/nfs_fs.h	2010-11-21 23:40:18.075242563 +0000
@@ -593,12 +593,6 @@
 	return ino;
 }
 
-#define nfs_wait_event(clnt, wq, condition)				\
-({									\
-	int __retval = wait_event_killable(wq, condition);		\
-	__retval;							\
-})
-
 #define NFS_JUKEBOX_RETRY_TIME (5 * HZ)
 
 #endif /* __KERNEL__ */
diff -urN linux-2.6.37-rc2/include/linux/reiserfs_fs.h linux-2.6.37-rc3/include/linux/reiserfs_fs.h
--- linux-2.6.37-rc2/include/linux/reiserfs_fs.h	2010-11-21 23:40:12.778086172 +0000
+++ linux-2.6.37-rc3/include/linux/reiserfs_fs.h	2010-11-21 23:40:18.082242607 +0000
@@ -22,7 +22,6 @@
 #include <asm/unaligned.h>
 #include <linux/bitops.h>
 #include <linux/proc_fs.h>
-#include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/reiserfs_fs_i.h>
 #include <linux/reiserfs_fs_sb.h>
diff -urN linux-2.6.37-rc2/include/linux/rtnetlink.h linux-2.6.37-rc3/include/linux/rtnetlink.h
--- linux-2.6.37-rc2/include/linux/rtnetlink.h	2010-11-21 23:40:12.779086332 +0000
+++ linux-2.6.37-rc3/include/linux/rtnetlink.h	2010-11-21 23:40:18.082242607 +0000
@@ -6,7 +6,6 @@
 #include <linux/if_link.h>
 #include <linux/if_addr.h>
 #include <linux/neighbour.h>
-#include <linux/netdevice.h>
 
 /* rtnetlink families. Values up to 127 are reserved for real address
  * families, values above 128 may be used arbitrarily.
@@ -606,6 +605,7 @@
 #ifdef __KERNEL__
 
 #include <linux/mutex.h>
+#include <linux/netdevice.h>
 
 static __inline__ int rtattr_strcmp(const struct rtattr *rta, const char *str)
 {
diff -urN linux-2.6.37-rc2/include/linux/sched.h linux-2.6.37-rc3/include/linux/sched.h
--- linux-2.6.37-rc2/include/linux/sched.h	2010-11-21 23:40:12.779086332 +0000
+++ linux-2.6.37-rc3/include/linux/sched.h	2010-11-21 23:40:18.083242524 +0000
@@ -862,6 +862,7 @@
 	 * single CPU.
 	 */
 	unsigned int cpu_power, cpu_power_orig;
+	unsigned int group_weight;
 
 	/*
 	 * The CPUs this group covers.
diff -urN linux-2.6.37-rc2/include/linux/smp_lock.h linux-2.6.37-rc3/include/linux/smp_lock.h
--- linux-2.6.37-rc2/include/linux/smp_lock.h	2010-11-21 23:40:12.783086185 +0000
+++ linux-2.6.37-rc3/include/linux/smp_lock.h	2010-11-21 23:40:18.086242595 +0000
@@ -4,8 +4,6 @@
 #ifdef CONFIG_LOCK_KERNEL
 #include <linux/sched.h>
 
-#define kernel_locked()		(current->lock_depth >= 0)
-
 extern int __lockfunc __reacquire_kernel_lock(void);
 extern void __lockfunc __release_kernel_lock(void);
 
@@ -58,7 +56,6 @@
 #define lock_kernel()
 #define unlock_kernel()
 #define cycle_kernel_lock()			do { } while(0)
-#define kernel_locked()				1
 #endif /* CONFIG_BKL */
 
 #define release_kernel_lock(task)		do { } while(0)
diff -urN linux-2.6.37-rc2/include/linux/tty.h linux-2.6.37-rc3/include/linux/tty.h
--- linux-2.6.37-rc2/include/linux/tty.h	2010-11-21 23:40:12.786053158 +0000
+++ linux-2.6.37-rc3/include/linux/tty.h	2010-11-21 23:40:18.090242580 +0000
@@ -13,7 +13,6 @@
 #include <linux/tty_driver.h>
 #include <linux/tty_ldisc.h>
 #include <linux/mutex.h>
-#include <linux/smp_lock.h>
 
 #include <asm/system.h>
 
diff -urN linux-2.6.37-rc2/include/net/cfg80211.h linux-2.6.37-rc3/include/net/cfg80211.h
--- linux-2.6.37-rc2/include/net/cfg80211.h	2010-11-21 23:40:12.794086294 +0000
+++ linux-2.6.37-rc3/include/net/cfg80211.h	2010-11-21 23:40:18.097242525 +0000
@@ -1355,7 +1355,7 @@
 	WIPHY_FLAG_4ADDR_AP			= BIT(5),
 	WIPHY_FLAG_4ADDR_STATION		= BIT(6),
 	WIPHY_FLAG_CONTROL_PORT_PROTOCOL	= BIT(7),
-	WIPHY_FLAG_IBSS_RSN			= BIT(7),
+	WIPHY_FLAG_IBSS_RSN			= BIT(8),
 };
 
 struct mac_address {
diff -urN linux-2.6.37-rc2/include/net/neighbour.h linux-2.6.37-rc3/include/net/neighbour.h
--- linux-2.6.37-rc2/include/net/neighbour.h	2010-11-21 23:40:12.797086365 +0000
+++ linux-2.6.37-rc3/include/net/neighbour.h	2010-11-21 23:40:18.101242515 +0000
@@ -303,7 +303,7 @@
 
 static inline int neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)
 {
-	unsigned long now = ACCESS_ONCE(jiffies);
+	unsigned long now = jiffies;
 	
 	if (neigh->used != now)
 		neigh->used = now;
diff -urN linux-2.6.37-rc2/include/scsi/libfc.h linux-2.6.37-rc3/include/scsi/libfc.h
--- linux-2.6.37-rc2/include/scsi/libfc.h	2010-11-21 23:40:12.801086228 +0000
+++ linux-2.6.37-rc3/include/scsi/libfc.h	2010-11-21 23:40:18.105242590 +0000
@@ -1006,8 +1006,7 @@
 /*
  * SCSI INTERACTION LAYER
  *****************************/
-int fc_queuecommand(struct scsi_cmnd *,
-		    void (*done)(struct scsi_cmnd *));
+int fc_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 int fc_eh_abort(struct scsi_cmnd *);
 int fc_eh_device_reset(struct scsi_cmnd *);
 int fc_eh_host_reset(struct scsi_cmnd *);
diff -urN linux-2.6.37-rc2/include/scsi/libiscsi.h linux-2.6.37-rc3/include/scsi/libiscsi.h
--- linux-2.6.37-rc2/include/scsi/libiscsi.h	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/include/scsi/libiscsi.h	2010-11-21 23:40:18.105242590 +0000
@@ -341,8 +341,7 @@
 extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
 extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
-extern int iscsi_queuecommand(struct scsi_cmnd *sc,
-			      void (*done)(struct scsi_cmnd *));
+extern int iscsi_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *sc);
 
 /*
  * iSCSI host helpers.
diff -urN linux-2.6.37-rc2/include/scsi/libsas.h linux-2.6.37-rc3/include/scsi/libsas.h
--- linux-2.6.37-rc2/include/scsi/libsas.h	2010-11-21 23:40:12.801086228 +0000
+++ linux-2.6.37-rc3/include/scsi/libsas.h	2010-11-21 23:40:18.105242590 +0000
@@ -621,8 +621,7 @@
 int sas_phy_enable(struct sas_phy *phy, int enabled);
 int sas_phy_reset(struct sas_phy *phy, int hard_reset);
 int sas_queue_up(struct sas_task *task);
-extern int sas_queuecommand(struct scsi_cmnd *,
-		     void (*scsi_done)(struct scsi_cmnd *));
+extern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);
 extern int sas_target_alloc(struct scsi_target *);
 extern int sas_slave_alloc(struct scsi_device *);
 extern int sas_slave_configure(struct scsi_device *);
diff -urN linux-2.6.37-rc2/include/scsi/scsi_host.h linux-2.6.37-rc3/include/scsi/scsi_host.h
--- linux-2.6.37-rc2/include/scsi/scsi_host.h	2010-11-21 23:40:12.802086241 +0000
+++ linux-2.6.37-rc3/include/scsi/scsi_host.h	2010-11-21 23:40:18.106242485 +0000
@@ -127,8 +127,7 @@
 	 *
 	 * STATUS: REQUIRED
 	 */
-	int (* queuecommand)(struct scsi_cmnd *,
-			     void (*done)(struct scsi_cmnd *));
+	int (* queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
 
 	/*
 	 * The transfer functions are used to queue a scsi command to
@@ -505,6 +504,25 @@
 };
 
 /*
+ * Temporary #define for host lock push down. Can be removed when all
+ * drivers have been updated to take advantage of unlocked
+ * queuecommand.
+ *
+ */
+#define DEF_SCSI_QCMD(func_name) \
+	int func_name(struct Scsi_Host *shost, struct scsi_cmnd *cmd)	\
+	{								\
+		unsigned long irq_flags;				\
+		int rc;							\
+		spin_lock_irqsave(shost->host_lock, irq_flags);		\
+		scsi_cmd_get_serial(shost, cmd);			\
+		rc = func_name##_lck (cmd, cmd->scsi_done);			\
+		spin_unlock_irqrestore(shost->host_lock, irq_flags);	\
+		return rc;						\
+	}
+
+
+/*
  * shost state: If you alter this, you also need to alter scsi_sysfs.c
  * (for the ascii descriptions) and the state model enforcer:
  * scsi_host_set_state()
@@ -752,6 +770,7 @@
 extern void scsi_host_put(struct Scsi_Host *t);
 extern struct Scsi_Host *scsi_host_lookup(unsigned short);
 extern const char *scsi_host_state_name(enum scsi_host_state);
+extern void scsi_cmd_get_serial(struct Scsi_Host *, struct scsi_cmnd *);
 
 extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
 
diff -urN linux-2.6.37-rc2/init/main.c linux-2.6.37-rc3/init/main.c
--- linux-2.6.37-rc2/init/main.c	2010-11-21 23:40:12.808086251 +0000
+++ linux-2.6.37-rc3/init/main.c	2010-11-21 23:40:18.112242573 +0000
@@ -20,7 +20,6 @@
 #include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/initrd.h>
 #include <linux/bootmem.h>
 #include <linux/acpi.h>
diff -urN linux-2.6.37-rc2/kernel/debug/kdb/kdb_main.c linux-2.6.37-rc3/kernel/debug/kdb/kdb_main.c
--- linux-2.6.37-rc2/kernel/debug/kdb/kdb_main.c	2010-11-21 23:40:12.812086269 +0000
+++ linux-2.6.37-rc3/kernel/debug/kdb/kdb_main.c	2010-11-21 23:40:18.116226912 +0000
@@ -82,7 +82,7 @@
 #define for_each_kdbcmd(cmd, num)					\
 	for ((cmd) = kdb_base_commands, (num) = 0;			\
 	     num < kdb_max_commands;					\
-	     num == KDB_BASE_CMD_MAX ? cmd = kdb_commands : cmd++, num++)
+	     num++, num == KDB_BASE_CMD_MAX ? cmd = kdb_commands : cmd++)
 
 typedef struct _kdbmsg {
 	int	km_diag;	/* kdb diagnostic */
@@ -646,7 +646,7 @@
 	}
 	if (!s->usable)
 		return KDB_NOTIMP;
-	s->command = kmalloc((s->count + 1) * sizeof(*(s->command)), GFP_KDB);
+	s->command = kzalloc((s->count + 1) * sizeof(*(s->command)), GFP_KDB);
 	if (!s->command) {
 		kdb_printf("Could not allocate new kdb_defcmd table for %s\n",
 			   cmdstr);
@@ -2361,7 +2361,7 @@
  */
 static int kdb_ll(int argc, const char **argv)
 {
-	int diag;
+	int diag = 0;
 	unsigned long addr;
 	long offset = 0;
 	unsigned long va;
@@ -2400,20 +2400,21 @@
 		char buf[80];
 
 		if (KDB_FLAG(CMD_INTERRUPT))
-			return 0;
+			goto out;
 
 		sprintf(buf, "%s " kdb_machreg_fmt "\n", command, va);
 		diag = kdb_parse(buf);
 		if (diag)
-			return diag;
+			goto out;
 
 		addr = va + linkoffset;
 		if (kdb_getword(&va, addr, sizeof(va)))
-			return 0;
+			goto out;
 	}
-	kfree(command);
 
-	return 0;
+out:
+	kfree(command);
+	return diag;
 }
 
 static int kdb_kgdb(int argc, const char **argv)
@@ -2739,13 +2740,13 @@
 		}
 		if (kdb_commands) {
 			memcpy(new, kdb_commands,
-			       kdb_max_commands * sizeof(*new));
+			  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));
 			kfree(kdb_commands);
 		}
 		memset(new + kdb_max_commands, 0,
 		       kdb_command_extend * sizeof(*new));
 		kdb_commands = new;
-		kp = kdb_commands + kdb_max_commands;
+		kp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;
 		kdb_max_commands += kdb_command_extend;
 	}
 
diff -urN linux-2.6.37-rc2/kernel/futex.c linux-2.6.37-rc3/kernel/futex.c
--- linux-2.6.37-rc2/kernel/futex.c	2010-11-21 23:40:12.814086261 +0000
+++ linux-2.6.37-rc3/kernel/futex.c	2010-11-21 23:40:18.118242441 +0000
@@ -2489,7 +2489,8 @@
 {
 	struct robust_list_head __user *head = curr->robust_list;
 	struct robust_list __user *entry, *next_entry, *pending;
-	unsigned int limit = ROBUST_LIST_LIMIT, pi, next_pi, pip;
+	unsigned int limit = ROBUST_LIST_LIMIT, pi, pip;
+	unsigned int uninitialized_var(next_pi);
 	unsigned long futex_offset;
 	int rc;
 
diff -urN linux-2.6.37-rc2/kernel/futex_compat.c linux-2.6.37-rc3/kernel/futex_compat.c
--- linux-2.6.37-rc2/kernel/futex_compat.c	2010-11-21 23:40:12.814086261 +0000
+++ linux-2.6.37-rc3/kernel/futex_compat.c	2010-11-21 23:40:18.118242441 +0000
@@ -49,7 +49,8 @@
 {
 	struct compat_robust_list_head __user *head = curr->compat_robust_list;
 	struct robust_list __user *entry, *next_entry, *pending;
-	unsigned int limit = ROBUST_LIST_LIMIT, pi, next_pi, pip;
+	unsigned int limit = ROBUST_LIST_LIMIT, pi, pip;
+	unsigned int uninitialized_var(next_pi);
 	compat_uptr_t uentry, next_uentry, upending;
 	compat_long_t futex_offset;
 	int rc;
diff -urN linux-2.6.37-rc2/kernel/pm_qos_params.c linux-2.6.37-rc3/kernel/pm_qos_params.c
--- linux-2.6.37-rc2/kernel/pm_qos_params.c	2010-11-21 23:40:12.821086189 +0000
+++ linux-2.6.37-rc3/kernel/pm_qos_params.c	2010-11-21 23:40:18.125242588 +0000
@@ -121,10 +121,10 @@
 
 	switch (o->type) {
 	case PM_QOS_MIN:
-		return plist_last(&o->requests)->prio;
+		return plist_first(&o->requests)->prio;
 
 	case PM_QOS_MAX:
-		return plist_first(&o->requests)->prio;
+		return plist_last(&o->requests)->prio;
 
 	default:
 		/* runtime check for not using enum */
diff -urN linux-2.6.37-rc2/kernel/power/Kconfig linux-2.6.37-rc3/kernel/power/Kconfig
--- linux-2.6.37-rc2/kernel/power/Kconfig	2010-11-21 23:40:12.821086189 +0000
+++ linux-2.6.37-rc3/kernel/power/Kconfig	2010-11-21 23:40:18.125242588 +0000
@@ -246,9 +246,13 @@
 	depends on PM_SLEEP || PM_RUNTIME
 	default y
 
+config ARCH_HAS_OPP
+	bool
+
 config PM_OPP
 	bool "Operating Performance Point (OPP) Layer library"
 	depends on PM
+	depends on ARCH_HAS_OPP
 	---help---
 	  SOCs have a standard set of tuples consisting of frequency and
 	  voltage pairs that the device will support per voltage domain. This
diff -urN linux-2.6.37-rc2/kernel/sched.c linux-2.6.37-rc3/kernel/sched.c
--- linux-2.6.37-rc2/kernel/sched.c	2010-11-21 23:40:12.826086280 +0000
+++ linux-2.6.37-rc3/kernel/sched.c	2010-11-21 23:40:18.130242476 +0000
@@ -560,18 +560,8 @@
 
 static DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
 
-static inline
-void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
-{
-	rq->curr->sched_class->check_preempt_curr(rq, p, flags);
 
-	/*
-	 * A queue event has occurred, and we're going to schedule.  In
-	 * this case, we can save a useless back to back clock update.
-	 */
-	if (test_tsk_need_resched(p))
-		rq->skip_clock_update = 1;
-}
+static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);
 
 static inline int cpu_of(struct rq *rq)
 {
@@ -2118,6 +2108,31 @@
 		p->sched_class->prio_changed(rq, p, oldprio, running);
 }
 
+static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
+{
+	const struct sched_class *class;
+
+	if (p->sched_class == rq->curr->sched_class) {
+		rq->curr->sched_class->check_preempt_curr(rq, p, flags);
+	} else {
+		for_each_class(class) {
+			if (class == rq->curr->sched_class)
+				break;
+			if (class == p->sched_class) {
+				resched_task(rq->curr);
+				break;
+			}
+		}
+	}
+
+	/*
+	 * A queue event has occurred, and we're going to schedule.  In
+	 * this case, we can save a useless back to back clock update.
+	 */
+	if (test_tsk_need_resched(rq->curr))
+		rq->skip_clock_update = 1;
+}
+
 #ifdef CONFIG_SMP
 /*
  * Is this task likely cache-hot:
@@ -6960,6 +6975,8 @@
 	if (cpu != group_first_cpu(sd->groups))
 		return;
 
+	sd->groups->group_weight = cpumask_weight(sched_group_cpus(sd->groups));
+
 	child = sd->child;
 
 	sd->groups->cpu_power = 0;
diff -urN linux-2.6.37-rc2/kernel/sched_fair.c linux-2.6.37-rc3/kernel/sched_fair.c
--- linux-2.6.37-rc2/kernel/sched_fair.c	2010-11-21 23:40:12.827086336 +0000
+++ linux-2.6.37-rc3/kernel/sched_fair.c	2010-11-21 23:40:18.131242456 +0000
@@ -1654,12 +1654,6 @@
 	struct cfs_rq *cfs_rq = task_cfs_rq(curr);
 	int scale = cfs_rq->nr_running >= sched_nr_latency;
 
-	if (unlikely(rt_prio(p->prio)))
-		goto preempt;
-
-	if (unlikely(p->sched_class != &fair_sched_class))
-		return;
-
 	if (unlikely(se == pse))
 		return;
 
@@ -2035,13 +2029,16 @@
 	unsigned long this_load_per_task;
 	unsigned long this_nr_running;
 	unsigned long this_has_capacity;
+	unsigned int  this_idle_cpus;
 
 	/* Statistics of the busiest group */
+	unsigned int  busiest_idle_cpus;
 	unsigned long max_load;
 	unsigned long busiest_load_per_task;
 	unsigned long busiest_nr_running;
 	unsigned long busiest_group_capacity;
 	unsigned long busiest_has_capacity;
+	unsigned int  busiest_group_weight;
 
 	int group_imb; /* Is there imbalance in this sd */
 #if defined(CONFIG_SCHED_MC) || defined(CONFIG_SCHED_SMT)
@@ -2063,6 +2060,8 @@
 	unsigned long sum_nr_running; /* Nr tasks running in the group */
 	unsigned long sum_weighted_load; /* Weighted load of group's tasks */
 	unsigned long group_capacity;
+	unsigned long idle_cpus;
+	unsigned long group_weight;
 	int group_imb; /* Is there an imbalance in the group ? */
 	int group_has_capacity; /* Is there extra capacity in the group? */
 };
@@ -2431,7 +2430,8 @@
 		sgs->group_load += load;
 		sgs->sum_nr_running += rq->nr_running;
 		sgs->sum_weighted_load += weighted_cpuload(i);
-
+		if (idle_cpu(i))
+			sgs->idle_cpus++;
 	}
 
 	/*
@@ -2469,6 +2469,7 @@
 	sgs->group_capacity = DIV_ROUND_CLOSEST(group->cpu_power, SCHED_LOAD_SCALE);
 	if (!sgs->group_capacity)
 		sgs->group_capacity = fix_small_capacity(sd, group);
+	sgs->group_weight = group->group_weight;
 
 	if (sgs->group_capacity > sgs->sum_nr_running)
 		sgs->group_has_capacity = 1;
@@ -2576,13 +2577,16 @@
 			sds->this_nr_running = sgs.sum_nr_running;
 			sds->this_load_per_task = sgs.sum_weighted_load;
 			sds->this_has_capacity = sgs.group_has_capacity;
+			sds->this_idle_cpus = sgs.idle_cpus;
 		} else if (update_sd_pick_busiest(sd, sds, sg, &sgs, this_cpu)) {
 			sds->max_load = sgs.avg_load;
 			sds->busiest = sg;
 			sds->busiest_nr_running = sgs.sum_nr_running;
+			sds->busiest_idle_cpus = sgs.idle_cpus;
 			sds->busiest_group_capacity = sgs.group_capacity;
 			sds->busiest_load_per_task = sgs.sum_weighted_load;
 			sds->busiest_has_capacity = sgs.group_has_capacity;
+			sds->busiest_group_weight = sgs.group_weight;
 			sds->group_imb = sgs.group_imb;
 		}
 
@@ -2860,8 +2864,26 @@
 	if (sds.this_load >= sds.avg_load)
 		goto out_balanced;
 
-	if (100 * sds.max_load <= sd->imbalance_pct * sds.this_load)
-		goto out_balanced;
+	/*
+	 * In the CPU_NEWLY_IDLE, use imbalance_pct to be conservative.
+	 * And to check for busy balance use !idle_cpu instead of
+	 * CPU_NOT_IDLE. This is because HT siblings will use CPU_NOT_IDLE
+	 * even when they are idle.
+	 */
+	if (idle == CPU_NEWLY_IDLE || !idle_cpu(this_cpu)) {
+		if (100 * sds.max_load <= sd->imbalance_pct * sds.this_load)
+			goto out_balanced;
+	} else {
+		/*
+		 * This cpu is idle. If the busiest group load doesn't
+		 * have more tasks than the number of available cpu's and
+		 * there is no imbalance between this and busiest group
+		 * wrt to idle cpu's, it is balanced.
+		 */
+		if ((sds.this_idle_cpus  <= sds.busiest_idle_cpus + 1) &&
+		    sds.busiest_nr_running <= sds.busiest_group_weight)
+			goto out_balanced;
+	}
 
 force_balance:
 	/* Looks like there is an imbalance. Compute it */
diff -urN linux-2.6.37-rc2/kernel/sched_stoptask.c linux-2.6.37-rc3/kernel/sched_stoptask.c
--- linux-2.6.37-rc2/kernel/sched_stoptask.c	2010-11-21 23:40:12.827086336 +0000
+++ linux-2.6.37-rc3/kernel/sched_stoptask.c	2010-11-21 23:40:18.131242456 +0000
@@ -19,14 +19,14 @@
 static void
 check_preempt_curr_stop(struct rq *rq, struct task_struct *p, int flags)
 {
-	resched_task(rq->curr); /* we preempt everything */
+	/* we're never preempted */
 }
 
 static struct task_struct *pick_next_task_stop(struct rq *rq)
 {
 	struct task_struct *stop = rq->stop;
 
-	if (stop && stop->state == TASK_RUNNING)
+	if (stop && stop->se.on_rq)
 		return stop;
 
 	return NULL;
diff -urN linux-2.6.37-rc2/kernel/sysctl.c linux-2.6.37-rc3/kernel/sysctl.c
--- linux-2.6.37-rc2/kernel/sysctl.c	2010-11-21 23:40:12.829086225 +0000
+++ linux-2.6.37-rc3/kernel/sysctl.c	2010-11-21 23:40:18.133227338 +0000
@@ -702,7 +702,6 @@
 		.extra1		= &zero,
 		.extra2		= &ten_thousand,
 	},
-#endif
 	{
 		.procname	= "dmesg_restrict",
 		.data		= &dmesg_restrict,
@@ -712,6 +711,7 @@
 		.extra1		= &zero,
 		.extra2		= &one,
 	},
+#endif
 	{
 		.procname	= "ngroups_max",
 		.data		= &ngroups_max,
diff -urN linux-2.6.37-rc2/kernel/trace/Kconfig linux-2.6.37-rc3/kernel/trace/Kconfig
--- linux-2.6.37-rc2/kernel/trace/Kconfig	2010-11-21 23:40:12.829086225 +0000
+++ linux-2.6.37-rc3/kernel/trace/Kconfig	2010-11-21 23:40:18.133227338 +0000
@@ -126,7 +126,7 @@
 config FUNCTION_TRACER
 	bool "Kernel Function Tracer"
 	depends on HAVE_FUNCTION_TRACER
-	select FRAME_POINTER if (!ARM_UNWIND)
+	select FRAME_POINTER if !ARM_UNWIND && !S390
 	select KALLSYMS
 	select GENERIC_TRACER
 	select CONTEXT_SWITCH_TRACER
diff -urN linux-2.6.37-rc2/kernel/trace/trace.c linux-2.6.37-rc3/kernel/trace/trace.c
--- linux-2.6.37-rc2/kernel/trace/trace.c	2010-11-21 23:40:12.832086355 +0000
+++ linux-2.6.37-rc3/kernel/trace/trace.c	2010-11-21 23:40:18.136242471 +0000
@@ -17,7 +17,6 @@
 #include <linux/writeback.h>
 #include <linux/kallsyms.h>
 #include <linux/seq_file.h>
-#include <linux/smp_lock.h>
 #include <linux/notifier.h>
 #include <linux/irqflags.h>
 #include <linux/debugfs.h>
diff -urN linux-2.6.37-rc2/net/ceph/messenger.c linux-2.6.37-rc3/net/ceph/messenger.c
--- linux-2.6.37-rc2/net/ceph/messenger.c	2010-11-21 23:40:12.862086301 +0000
+++ linux-2.6.37-rc3/net/ceph/messenger.c	2010-11-21 23:40:18.166242506 +0000
@@ -540,8 +540,7 @@
 		/* initialize page iterator */
 		con->out_msg_pos.page = 0;
 		if (m->pages)
-			con->out_msg_pos.page_pos =
-				le16_to_cpu(m->hdr.data_off) & ~PAGE_MASK;
+			con->out_msg_pos.page_pos = m->page_alignment;
 		else
 			con->out_msg_pos.page_pos = 0;
 		con->out_msg_pos.data_pos = 0;
@@ -1491,7 +1490,7 @@
 	struct ceph_msg *m = con->in_msg;
 	int ret;
 	int to, left;
-	unsigned front_len, middle_len, data_len, data_off;
+	unsigned front_len, middle_len, data_len;
 	int datacrc = con->msgr->nocrc;
 	int skip;
 	u64 seq;
@@ -1527,19 +1526,17 @@
 	data_len = le32_to_cpu(con->in_hdr.data_len);
 	if (data_len > CEPH_MSG_MAX_DATA_LEN)
 		return -EIO;
-	data_off = le16_to_cpu(con->in_hdr.data_off);
 
 	/* verify seq# */
 	seq = le64_to_cpu(con->in_hdr.seq);
 	if ((s64)seq - (s64)con->in_seq < 1) {
-		pr_info("skipping %s%lld %s seq %lld, expected %lld\n",
+		pr_info("skipping %s%lld %s seq %lld expected %lld\n",
 			ENTITY_NAME(con->peer_name),
 			ceph_pr_addr(&con->peer_addr.in_addr),
 			seq, con->in_seq + 1);
 		con->in_base_pos = -front_len - middle_len - data_len -
 			sizeof(m->footer);
 		con->in_tag = CEPH_MSGR_TAG_READY;
-		con->in_seq++;
 		return 0;
 	} else if ((s64)seq - (s64)con->in_seq > 1) {
 		pr_err("read_partial_message bad seq %lld expected %lld\n",
@@ -1576,7 +1573,7 @@
 
 		con->in_msg_pos.page = 0;
 		if (m->pages)
-			con->in_msg_pos.page_pos = data_off & ~PAGE_MASK;
+			con->in_msg_pos.page_pos = m->page_alignment;
 		else
 			con->in_msg_pos.page_pos = 0;
 		con->in_msg_pos.data_pos = 0;
@@ -2301,6 +2298,7 @@
 
 	/* data */
 	m->nr_pages = 0;
+	m->page_alignment = 0;
 	m->pages = NULL;
 	m->pagelist = NULL;
 	m->bio = NULL;
@@ -2370,6 +2368,7 @@
 			       type, front_len);
 			return NULL;
 		}
+		msg->page_alignment = le16_to_cpu(hdr->data_off);
 	}
 	memcpy(&msg->hdr, &con->in_hdr, sizeof(con->in_hdr));
 
diff -urN linux-2.6.37-rc2/net/ceph/osd_client.c linux-2.6.37-rc3/net/ceph/osd_client.c
--- linux-2.6.37-rc2/net/ceph/osd_client.c	2010-11-21 23:40:12.863086267 +0000
+++ linux-2.6.37-rc3/net/ceph/osd_client.c	2010-11-21 23:40:18.167118800 +0000
@@ -71,6 +71,7 @@
 		op->extent.length = objlen;
 	}
 	req->r_num_pages = calc_pages_for(off, *plen);
+	req->r_page_alignment = off & ~PAGE_MASK;
 	if (op->op == CEPH_OSD_OP_WRITE)
 		op->payload_len = *plen;
 
@@ -390,6 +391,8 @@
 		req->r_request->hdr.data_len = cpu_to_le32(data_len);
 	}
 
+	req->r_request->page_alignment = req->r_page_alignment;
+
 	BUG_ON(p > msg->front.iov_base + msg->front.iov_len);
 	msg_size = p - msg->front.iov_base;
 	msg->front.iov_len = msg_size;
@@ -419,7 +422,8 @@
 					       u32 truncate_seq,
 					       u64 truncate_size,
 					       struct timespec *mtime,
-					       bool use_mempool, int num_reply)
+					       bool use_mempool, int num_reply,
+					       int page_align)
 {
 	struct ceph_osd_req_op ops[3];
 	struct ceph_osd_request *req;
@@ -447,6 +451,10 @@
 	calc_layout(osdc, vino, layout, off, plen, req, ops);
 	req->r_file_layout = *layout;  /* keep a copy */
 
+	/* in case it differs from natural alignment that calc_layout
+	   filled in for us */
+	req->r_page_alignment = page_align;
+
 	ceph_osdc_build_request(req, off, plen, ops,
 				snapc,
 				mtime,
@@ -1489,7 +1497,7 @@
 			struct ceph_vino vino, struct ceph_file_layout *layout,
 			u64 off, u64 *plen,
 			u32 truncate_seq, u64 truncate_size,
-			struct page **pages, int num_pages)
+			struct page **pages, int num_pages, int page_align)
 {
 	struct ceph_osd_request *req;
 	int rc = 0;
@@ -1499,15 +1507,15 @@
 	req = ceph_osdc_new_request(osdc, layout, vino, off, plen,
 				    CEPH_OSD_OP_READ, CEPH_OSD_FLAG_READ,
 				    NULL, 0, truncate_seq, truncate_size, NULL,
-				    false, 1);
+				    false, 1, page_align);
 	if (!req)
 		return -ENOMEM;
 
 	/* it may be a short read due to an object boundary */
 	req->r_pages = pages;
 
-	dout("readpages  final extent is %llu~%llu (%d pages)\n",
-	     off, *plen, req->r_num_pages);
+	dout("readpages  final extent is %llu~%llu (%d pages align %d)\n",
+	     off, *plen, req->r_num_pages, page_align);
 
 	rc = ceph_osdc_start_request(osdc, req, false);
 	if (!rc)
@@ -1533,6 +1541,7 @@
 {
 	struct ceph_osd_request *req;
 	int rc = 0;
+	int page_align = off & ~PAGE_MASK;
 
 	BUG_ON(vino.snap != CEPH_NOSNAP);
 	req = ceph_osdc_new_request(osdc, layout, vino, off, &len,
@@ -1541,7 +1550,7 @@
 					    CEPH_OSD_FLAG_WRITE,
 				    snapc, do_sync,
 				    truncate_seq, truncate_size, mtime,
-				    nofail, 1);
+				    nofail, 1, page_align);
 	if (!req)
 		return -ENOMEM;
 
@@ -1638,8 +1647,7 @@
 	m = ceph_msg_get(req->r_reply);
 
 	if (data_len > 0) {
-		unsigned data_off = le16_to_cpu(hdr->data_off);
-		int want = calc_pages_for(data_off & ~PAGE_MASK, data_len);
+		int want = calc_pages_for(req->r_page_alignment, data_len);
 
 		if (unlikely(req->r_num_pages < want)) {
 			pr_warning("tid %lld reply %d > expected %d pages\n",
@@ -1651,6 +1659,7 @@
 		}
 		m->pages = req->r_pages;
 		m->nr_pages = req->r_num_pages;
+		m->page_alignment = req->r_page_alignment;
 #ifdef CONFIG_BLOCK
 		m->bio = req->r_bio;
 #endif
diff -urN linux-2.6.37-rc2/net/ceph/pagevec.c linux-2.6.37-rc3/net/ceph/pagevec.c
--- linux-2.6.37-rc2/net/ceph/pagevec.c	2010-11-21 23:40:12.864086481 +0000
+++ linux-2.6.37-rc3/net/ceph/pagevec.c	2010-11-21 23:40:18.168242532 +0000
@@ -13,8 +13,7 @@
  * build a vector of user pages
  */
 struct page **ceph_get_direct_page_vector(const char __user *data,
-						 int num_pages,
-						 loff_t off, size_t len)
+					  int num_pages)
 {
 	struct page **pages;
 	int rc;
diff -urN linux-2.6.37-rc2/net/core/filter.c linux-2.6.37-rc3/net/core/filter.c
--- linux-2.6.37-rc2/net/core/filter.c	2010-11-21 23:40:12.866086202 +0000
+++ linux-2.6.37-rc3/net/core/filter.c	2010-11-21 23:40:18.171242431 +0000
@@ -589,7 +589,7 @@
 EXPORT_SYMBOL(sk_chk_filter);
 
 /**
- * 	sk_filter_rcu_release: Release a socket filter by rcu_head
+ * 	sk_filter_rcu_release - Release a socket filter by rcu_head
  *	@rcu: rcu_head that contains the sk_filter to free
  */
 static void sk_filter_rcu_release(struct rcu_head *rcu)
diff -urN linux-2.6.37-rc2/net/core/net-sysfs.c linux-2.6.37-rc3/net/core/net-sysfs.c
--- linux-2.6.37-rc2/net/core/net-sysfs.c	2010-11-21 23:40:12.867086285 +0000
+++ linux-2.6.37-rc3/net/core/net-sysfs.c	2010-11-21 23:40:18.172242487 +0000
@@ -712,15 +712,21 @@
 
 
 	map = rcu_dereference_raw(queue->rps_map);
-	if (map)
+	if (map) {
+		RCU_INIT_POINTER(queue->rps_map, NULL);
 		call_rcu(&map->rcu, rps_map_release);
+	}
 
 	flow_table = rcu_dereference_raw(queue->rps_flow_table);
-	if (flow_table)
+	if (flow_table) {
+		RCU_INIT_POINTER(queue->rps_flow_table, NULL);
 		call_rcu(&flow_table->rcu, rps_dev_flow_table_release);
+	}
 
 	if (atomic_dec_and_test(&first->count))
 		kfree(first);
+	else
+		memset(kobj, 0, sizeof(*kobj));
 }
 
 static struct kobj_type rx_queue_ktype = {
diff -urN linux-2.6.37-rc2/net/ipv4/icmp.c linux-2.6.37-rc3/net/ipv4/icmp.c
--- linux-2.6.37-rc2/net/ipv4/icmp.c	2010-11-21 23:40:12.878075038 +0000
+++ linux-2.6.37-rc3/net/ipv4/icmp.c	2010-11-21 23:40:18.183242411 +0000
@@ -569,6 +569,9 @@
 		/* No need to clone since we're just using its address. */
 		rt2 = rt;
 
+		if (!fl.nl_u.ip4_u.saddr)
+			fl.nl_u.ip4_u.saddr = rt->rt_src;
+
 		err = xfrm_lookup(net, (struct dst_entry **)&rt, &fl, NULL, 0);
 		switch (err) {
 		case 0:
diff -urN linux-2.6.37-rc2/net/ipv6/addrconf.c linux-2.6.37-rc3/net/ipv6/addrconf.c
--- linux-2.6.37-rc2/net/ipv6/addrconf.c	2010-11-21 23:40:12.889086285 +0000
+++ linux-2.6.37-rc3/net/ipv6/addrconf.c	2010-11-21 23:40:18.194242588 +0000
@@ -98,7 +98,11 @@
 #endif
 
 #define	INFINITY_LIFE_TIME	0xFFFFFFFF
-#define TIME_DELTA(a, b) ((unsigned long)((long)(a) - (long)(b)))
+
+static inline u32 cstamp_delta(unsigned long cstamp)
+{
+	return (cstamp - INITIAL_JIFFIES) * 100UL / HZ;
+}
 
 #define ADDRCONF_TIMER_FUZZ_MINUS	(HZ > 50 ? HZ/50 : 1)
 #define ADDRCONF_TIMER_FUZZ		(HZ / 4)
@@ -3444,10 +3448,8 @@
 {
 	struct ifa_cacheinfo ci;
 
-	ci.cstamp = (u32)(TIME_DELTA(cstamp, INITIAL_JIFFIES) / HZ * 100
-			+ TIME_DELTA(cstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);
-	ci.tstamp = (u32)(TIME_DELTA(tstamp, INITIAL_JIFFIES) / HZ * 100
-			+ TIME_DELTA(tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);
+	ci.cstamp = cstamp_delta(cstamp);
+	ci.tstamp = cstamp_delta(tstamp);
 	ci.ifa_prefered = preferred;
 	ci.ifa_valid = valid;
 
@@ -3798,8 +3800,10 @@
 	array[DEVCONF_AUTOCONF] = cnf->autoconf;
 	array[DEVCONF_DAD_TRANSMITS] = cnf->dad_transmits;
 	array[DEVCONF_RTR_SOLICITS] = cnf->rtr_solicits;
-	array[DEVCONF_RTR_SOLICIT_INTERVAL] = cnf->rtr_solicit_interval;
-	array[DEVCONF_RTR_SOLICIT_DELAY] = cnf->rtr_solicit_delay;
+	array[DEVCONF_RTR_SOLICIT_INTERVAL] =
+		jiffies_to_msecs(cnf->rtr_solicit_interval);
+	array[DEVCONF_RTR_SOLICIT_DELAY] =
+		jiffies_to_msecs(cnf->rtr_solicit_delay);
 	array[DEVCONF_FORCE_MLD_VERSION] = cnf->force_mld_version;
 #ifdef CONFIG_IPV6_PRIVACY
 	array[DEVCONF_USE_TEMPADDR] = cnf->use_tempaddr;
@@ -3813,7 +3817,8 @@
 	array[DEVCONF_ACCEPT_RA_PINFO] = cnf->accept_ra_pinfo;
 #ifdef CONFIG_IPV6_ROUTER_PREF
 	array[DEVCONF_ACCEPT_RA_RTR_PREF] = cnf->accept_ra_rtr_pref;
-	array[DEVCONF_RTR_PROBE_INTERVAL] = cnf->rtr_probe_interval;
+	array[DEVCONF_RTR_PROBE_INTERVAL] =
+		jiffies_to_msecs(cnf->rtr_probe_interval);
 #ifdef CONFIG_IPV6_ROUTE_INFO
 	array[DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN] = cnf->accept_ra_rt_info_max_plen;
 #endif
@@ -3929,10 +3934,9 @@
 	NLA_PUT_U32(skb, IFLA_INET6_FLAGS, idev->if_flags);
 
 	ci.max_reasm_len = IPV6_MAXPLEN;
-	ci.tstamp = (__u32)(TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) / HZ * 100
-		    + TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);
-	ci.reachable_time = idev->nd_parms->reachable_time;
-	ci.retrans_time = idev->nd_parms->retrans_time;
+	ci.tstamp = cstamp_delta(idev->tstamp);
+	ci.reachable_time = jiffies_to_msecs(idev->nd_parms->reachable_time);
+	ci.retrans_time = jiffies_to_msecs(idev->nd_parms->retrans_time);
 	NLA_PUT(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci);
 
 	nla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));
diff -urN linux-2.6.37-rc2/net/irda/af_irda.c linux-2.6.37-rc3/net/irda/af_irda.c
--- linux-2.6.37-rc2/net/irda/af_irda.c	2010-11-21 23:40:12.896086260 +0000
+++ linux-2.6.37-rc3/net/irda/af_irda.c	2010-11-21 23:40:18.201242545 +0000
@@ -45,7 +45,6 @@
 #include <linux/capability.h>
 #include <linux/module.h>
 #include <linux/types.h>
-#include <linux/smp_lock.h>
 #include <linux/socket.h>
 #include <linux/sockios.h>
 #include <linux/slab.h>
diff -urN linux-2.6.37-rc2/net/irda/irnet/irnet_ppp.c linux-2.6.37-rc3/net/irda/irnet/irnet_ppp.c
--- linux-2.6.37-rc2/net/irda/irnet/irnet_ppp.c	2010-11-21 23:40:12.898086226 +0000
+++ linux-2.6.37-rc3/net/irda/irnet/irnet_ppp.c	2010-11-21 23:40:18.203242495 +0000
@@ -15,7 +15,6 @@
 
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include "irnet_ppp.h"		/* Private header */
 /* Please put other headers in irnet.h - Thanks */
 
diff -urN linux-2.6.37-rc2/net/irda/irttp.c linux-2.6.37-rc3/net/irda/irttp.c
--- linux-2.6.37-rc2/net/irda/irttp.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/net/irda/irttp.c	2010-11-21 23:40:18.203242495 +0000
@@ -550,22 +550,30 @@
  */
 int irttp_udata_request(struct tsap_cb *self, struct sk_buff *skb)
 {
+	int ret;
+
 	IRDA_ASSERT(self != NULL, return -1;);
 	IRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);
 	IRDA_ASSERT(skb != NULL, return -1;);
 
 	IRDA_DEBUG(4, "%s()\n", __func__);
 
+	/* Take shortcut on zero byte packets */
+	if (skb->len == 0) {
+		ret = 0;
+		goto err;
+	}
+
 	/* Check that nothing bad happens */
-	if ((skb->len == 0) || (!self->connected)) {
-		IRDA_DEBUG(1, "%s(), No data, or not connected\n",
-			   __func__);
+	if (!self->connected) {
+		IRDA_WARNING("%s(), Not connected\n", __func__);
+		ret = -ENOTCONN;
 		goto err;
 	}
 
 	if (skb->len > self->max_seg_size) {
-		IRDA_DEBUG(1, "%s(), UData is too large for IrLAP!\n",
-			   __func__);
+		IRDA_ERROR("%s(), UData is too large for IrLAP!\n", __func__);
+		ret = -EMSGSIZE;
 		goto err;
 	}
 
@@ -576,7 +584,7 @@
 
 err:
 	dev_kfree_skb(skb);
-	return -1;
+	return ret;
 }
 EXPORT_SYMBOL(irttp_udata_request);
 
@@ -599,9 +607,15 @@
 	IRDA_DEBUG(2, "%s() : queue len = %d\n", __func__,
 		   skb_queue_len(&self->tx_queue));
 
+	/* Take shortcut on zero byte packets */
+	if (skb->len == 0) {
+		ret = 0;
+		goto err;
+	}
+
 	/* Check that nothing bad happens */
-	if ((skb->len == 0) || (!self->connected)) {
-		IRDA_WARNING("%s: No data, or not connected\n", __func__);
+	if (!self->connected) {
+		IRDA_WARNING("%s: Not connected\n", __func__);
 		ret = -ENOTCONN;
 		goto err;
 	}
diff -urN linux-2.6.37-rc2/net/netfilter/ipvs/Kconfig linux-2.6.37-rc3/net/netfilter/ipvs/Kconfig
--- linux-2.6.37-rc2/net/netfilter/ipvs/Kconfig	2010-11-21 23:40:12.909086181 +0000
+++ linux-2.6.37-rc3/net/netfilter/ipvs/Kconfig	2010-11-21 23:40:18.214242529 +0000
@@ -4,6 +4,7 @@
 menuconfig IP_VS
 	tristate "IP virtual server support"
 	depends on NET && INET && NETFILTER
+	depends on (NF_CONNTRACK || NF_CONNTRACK=n)
 	---help---
 	  IP Virtual Server support will let you build a high-performance
 	  virtual server based on cluster of two or more real servers. This
diff -urN linux-2.6.37-rc2/net/rds/rdma.c linux-2.6.37-rc3/net/rds/rdma.c
--- linux-2.6.37-rc2/net/rds/rdma.c	2010-11-21 23:40:12.924086315 +0000
+++ linux-2.6.37-rc3/net/rds/rdma.c	2010-11-21 23:40:18.229114813 +0000
@@ -567,7 +567,7 @@
 		goto out;
 	}
 
-	if (args->nr_local > (u64)UINT_MAX) {
+	if (args->nr_local > UIO_MAXIOV) {
 		ret = -EMSGSIZE;
 		goto out;
 	}
diff -urN linux-2.6.37-rc2/net/sunrpc/stats.c linux-2.6.37-rc3/net/sunrpc/stats.c
--- linux-2.6.37-rc2/net/sunrpc/stats.c	2010-11-21 23:40:12.938086295 +0000
+++ linux-2.6.37-rc3/net/sunrpc/stats.c	2010-11-21 23:40:18.243056420 +0000
@@ -115,9 +115,7 @@
  */
 struct rpc_iostats *rpc_alloc_iostats(struct rpc_clnt *clnt)
 {
-	struct rpc_iostats *new;
-	new = kcalloc(clnt->cl_maxproc, sizeof(struct rpc_iostats), GFP_KERNEL);
-	return new;
+	return kcalloc(clnt->cl_maxproc, sizeof(struct rpc_iostats), GFP_KERNEL);
 }
 EXPORT_SYMBOL_GPL(rpc_alloc_iostats);
 
diff -urN linux-2.6.37-rc2/net/sunrpc/svc_xprt.c linux-2.6.37-rc3/net/sunrpc/svc_xprt.c
--- linux-2.6.37-rc2/net/sunrpc/svc_xprt.c	2010-11-21 23:40:12.939086344 +0000
+++ linux-2.6.37-rc3/net/sunrpc/svc_xprt.c	2010-11-21 23:40:18.244056350 +0000
@@ -5,7 +5,6 @@
  */
 
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <linux/errno.h>
 #include <linux/freezer.h>
 #include <linux/kthread.h>
diff -urN linux-2.6.37-rc2/net/wireless/chan.c linux-2.6.37-rc3/net/wireless/chan.c
--- linux-2.6.37-rc2/net/wireless/chan.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/net/wireless/chan.c	2010-11-21 23:40:18.252055987 +0000
@@ -44,6 +44,38 @@
 	return chan;
 }
 
+static bool can_beacon_sec_chan(struct wiphy *wiphy,
+				struct ieee80211_channel *chan,
+				enum nl80211_channel_type channel_type)
+{
+	struct ieee80211_channel *sec_chan;
+	int diff;
+
+	switch (channel_type) {
+	case NL80211_CHAN_HT40PLUS:
+		diff = 20;
+		break;
+	case NL80211_CHAN_HT40MINUS:
+		diff = -20;
+		break;
+	default:
+		return false;
+	}
+
+	sec_chan = ieee80211_get_channel(wiphy, chan->center_freq + diff);
+	if (!sec_chan)
+		return false;
+
+	/* we'll need a DFS capability later */
+	if (sec_chan->flags & (IEEE80211_CHAN_DISABLED |
+			       IEEE80211_CHAN_PASSIVE_SCAN |
+			       IEEE80211_CHAN_NO_IBSS |
+			       IEEE80211_CHAN_RADAR))
+		return false;
+
+	return true;
+}
+
 int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
 		      struct wireless_dev *wdev, int freq,
 		      enum nl80211_channel_type channel_type)
@@ -68,6 +100,28 @@
 	if (!chan)
 		return -EINVAL;
 
+	/* Both channels should be able to initiate communication */
+	if (wdev && (wdev->iftype == NL80211_IFTYPE_ADHOC ||
+		     wdev->iftype == NL80211_IFTYPE_AP ||
+		     wdev->iftype == NL80211_IFTYPE_AP_VLAN ||
+		     wdev->iftype == NL80211_IFTYPE_MESH_POINT ||
+		     wdev->iftype == NL80211_IFTYPE_P2P_GO)) {
+		switch (channel_type) {
+		case NL80211_CHAN_HT40PLUS:
+		case NL80211_CHAN_HT40MINUS:
+			if (!can_beacon_sec_chan(&rdev->wiphy, chan,
+						 channel_type)) {
+				printk(KERN_DEBUG
+				       "cfg80211: Secondary channel not "
+				       "allowed to initiate communication\n");
+				return -EINVAL;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
 	result = rdev->ops->set_channel(&rdev->wiphy,
 					wdev ? wdev->netdev : NULL,
 					chan, channel_type);
diff -urN linux-2.6.37-rc2/scripts/kernel-doc linux-2.6.37-rc3/scripts/kernel-doc
--- linux-2.6.37-rc2/scripts/kernel-doc	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/scripts/kernel-doc	2010-11-21 23:40:18.267056434 +0000
@@ -5,7 +5,7 @@
 ## Copyright (c) 1998 Michael Zucchi, All Rights Reserved        ##
 ## Copyright (C) 2000, 1  Tim Waugh <twaugh@redhat.com>          ##
 ## Copyright (C) 2001  Simon Huggins                             ##
-## Copyright (C) 2005-2009  Randy Dunlap                         ##
+## Copyright (C) 2005-2010  Randy Dunlap                         ##
 ## 								 ##
 ## #define enhancements by Armin Kuster <akuster@mvista.com>	 ##
 ## Copyright (c) 2000 MontaVista Software, Inc.			 ##
@@ -453,7 +453,7 @@
     if ($output_mode eq "html" || $output_mode eq "xml") {
 	$contents = local_unescape($contents);
 	# convert data read & converted thru xml_escape() into &xyz; format:
-	$contents =~ s/\\\\\\/&/g;
+	$contents =~ s/\\\\\\/\&/g;
     }
 #   print STDERR "contents b4:$contents\n";
     eval $dohighlight;
@@ -770,7 +770,11 @@
     print $args{'type'} . " " . $args{'struct'} . " {\n";
     foreach $parameter (@{$args{'parameterlist'}}) {
 	if ($parameter =~ /^#/) {
-	    print "$parameter\n";
+	    my $prm = $parameter;
+	    # convert data read & converted thru xml_escape() into &xyz; format:
+	    # This allows us to have #define macros interspersed in a struct.
+	    $prm =~ s/\\\\\\/\&/g;
+	    print "$prm\n";
 	    next;
 	}
 
@@ -1701,6 +1705,8 @@
 	}
 	}
 
+	$param = xml_escape($param);
+
 	# strip spaces from $param so that it is one continous string
 	# on @parameterlist;
 	# this fixes a problem where check_sections() cannot find
diff -urN linux-2.6.37-rc2/sound/core/info.c linux-2.6.37-rc3/sound/core/info.c
--- linux-2.6.37-rc2/sound/core/info.c	2010-10-20 20:30:22.000000000 +0000
+++ linux-2.6.37-rc3/sound/core/info.c	2010-11-21 23:40:18.275056611 +0000
@@ -23,7 +23,6 @@
 #include <linux/time.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/string.h>
 #include <sound/core.h>
 #include <sound/minors.h>
diff -urN linux-2.6.37-rc2/sound/core/pcm_native.c linux-2.6.37-rc3/sound/core/pcm_native.c
--- linux-2.6.37-rc2/sound/core/pcm_native.c	2010-11-21 23:40:12.971086374 +0000
+++ linux-2.6.37-rc3/sound/core/pcm_native.c	2010-11-21 23:40:18.277056757 +0000
@@ -22,7 +22,6 @@
 #include <linux/mm.h>
 #include <linux/file.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/time.h>
 #include <linux/pm_qos_params.h>
 #include <linux/uio.h>
diff -urN linux-2.6.37-rc2/sound/core/sound.c linux-2.6.37-rc3/sound/core/sound.c
--- linux-2.6.37-rc2/sound/core/sound.c	2010-11-21 23:40:12.971086374 +0000
+++ linux-2.6.37-rc3/sound/core/sound.c	2010-11-21 23:40:18.277056757 +0000
@@ -21,7 +21,6 @@
 
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/time.h>
 #include <linux/device.h>
 #include <linux/moduleparam.h>
diff -urN linux-2.6.37-rc2/sound/sound_core.c linux-2.6.37-rc3/sound/sound_core.c
--- linux-2.6.37-rc2/sound/sound_core.c	2010-11-21 23:40:13.056086122 +0000
+++ linux-2.6.37-rc3/sound/sound_core.c	2010-11-21 23:40:18.361115169 +0000
@@ -104,7 +104,6 @@
 
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/sound.h>
