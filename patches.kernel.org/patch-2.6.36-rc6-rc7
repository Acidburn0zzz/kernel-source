From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 2.6.36-rc7
Patch-mainline: 2.6.36-rc7

 This patch contains the differences between 2.6.36-rc6 and -rc7.

Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 CREDITS                                      |    8 -
 MAINTAINERS                                  |   14 +-
 Makefile                                     |    2 
 arch/alpha/kernel/signal.c                   |    2 
 arch/arm/oprofile/common.c                   |    7 -
 arch/arm/plat-omap/Kconfig                   |    2 
 arch/arm/plat-omap/mcbsp.c                   |    2 
 arch/avr32/kernel/module.c                   |    3 
 arch/h8300/kernel/module.c                   |    3 
 arch/m68k/mac/macboing.c                     |    6 -
 arch/mips/Kconfig                            |   21 +++
 arch/mips/alchemy/common/prom.c              |    5 
 arch/mips/boot/compressed/Makefile           |    2 
 arch/mips/cavium-octeon/Kconfig              |    4 
 arch/mips/cavium-octeon/cpu.c                |    2 
 arch/mips/cavium-octeon/executive/Makefile   |    2 
 arch/mips/include/asm/atomic.h               |    4 
 arch/mips/include/asm/cop2.h                 |    2 
 arch/mips/include/asm/gic.h                  |    1 
 arch/mips/include/asm/mach-tx49xx/kmalloc.h  |    2 
 arch/mips/include/asm/mips-boards/maltaint.h |    3 
 arch/mips/include/asm/page.h                 |   14 ++
 arch/mips/include/asm/thread_info.h          |    3 
 arch/mips/include/asm/unistd.h               |   21 ++-
 arch/mips/kernel/irq-gic.c                   |    5 
 arch/mips/kernel/kgdb.c                      |    2 
 arch/mips/kernel/kspd.c                      |    2 
 arch/mips/kernel/linux32.c                   |    7 +
 arch/mips/kernel/scall32-o32.S               |    5 
 arch/mips/kernel/scall64-64.S                |    7 -
 arch/mips/kernel/scall64-n32.S               |    5 
 arch/mips/kernel/scall64-o32.S               |    5 
 arch/mips/mm/dma-default.c                   |   28 +++--
 arch/mips/mm/sc-rm7k.c                       |    2 
 arch/mips/mti-malta/malta-int.c              |    3 
 arch/mips/pci/pci-rc32434.c                  |    2 
 arch/mips/pnx8550/common/reset.c             |   20 ---
 arch/mips/pnx8550/common/setup.c             |    3 
 arch/mn10300/kernel/module.c                 |    3 
 arch/mn10300/mm/cache.c                      |   20 +++
 arch/parisc/kernel/module.c                  |    3 
 arch/powerpc/kernel/module.c                 |    6 -
 arch/powerpc/platforms/512x/clock.c          |    2 
 arch/powerpc/platforms/52xx/efika.c          |    9 +
 arch/powerpc/platforms/52xx/mpc52xx_common.c |    8 +
 arch/s390/kernel/module.c                    |    3 
 arch/sh/kernel/module.c                      |    2 
 arch/um/drivers/net_kern.c                   |   17 ---
 arch/x86/kernel/acpi/cstate.c                |    2 
 arch/x86/kernel/apic/io_apic.c               |   11 +-
 arch/x86/kernel/cpu/common.c                 |    2 
 arch/x86/kernel/cpu/cpu.h                    |    1 
 arch/x86/kernel/cpu/cpufreq/pcc-cpufreq.c    |   18 ++-
 arch/x86/kernel/cpu/intel.c                  |    1 
 arch/x86/kernel/cpu/perf_event_p4.c          |    6 -
 arch/x86/kernel/hpet.c                       |    2 
 arch/x86/kernel/module.c                     |    3 
 arch/x86/oprofile/nmi_int.c                  |    1 
 arch/x86/xen/time.c                          |    5 
 drivers/acpi/Kconfig                         |    2 
 drivers/acpi/acpi_pad.c                      |   34 +++---
 drivers/acpi/acpica/aclocal.h                |    1 
 drivers/acpi/acpica/exutils.c                |    2 
 drivers/acpi/acpica/rsutils.c                |    2 
 drivers/acpi/apei/Kconfig                    |    2 
 drivers/acpi/apei/apei-base.c                |   21 ++-
 drivers/acpi/apei/einj.c                     |    4 
 drivers/acpi/apei/erst-dbg.c                 |   18 ++-
 drivers/acpi/apei/erst.c                     |   29 ++++-
 drivers/acpi/apei/ghes.c                     |    2 
 drivers/acpi/apei/hest.c                     |   11 +-
 drivers/acpi/atomicio.c                      |    2 
 drivers/acpi/battery.c                       |    1 
 drivers/acpi/blacklist.c                     |   18 +++
 drivers/acpi/bus.c                           |   18 ---
 drivers/acpi/fan.c                           |    2 
 drivers/acpi/processor_core.c                |    6 -
 drivers/acpi/processor_driver.c              |    2 
 drivers/acpi/processor_perflib.c             |    4 
 drivers/acpi/sleep.c                         |   22 ++++
 drivers/acpi/sysfs.c                         |   20 ++-
 drivers/acpi/video_detect.c                  |    4 
 drivers/cpuidle/governors/menu.c             |    2 
 drivers/dma/shdma.c                          |    3 
 drivers/edac/i7core_edac.c                   |    1 
 drivers/gpu/drm/drm_gem.c                    |   39 +------
 drivers/gpu/drm/drm_info.c                   |    2 
 drivers/gpu/drm/drm_vm.c                     |   28 +++--
 drivers/gpu/drm/i810/i810_dma.c              |    2 
 drivers/gpu/drm/i830/i830_dma.c              |    2 
 drivers/gpu/drm/i915/i915_dma.c              |    6 -
 drivers/gpu/drm/i915/i915_gem.c              |   52 +++++----
 drivers/gpu/drm/i915/i915_gem_evict.c        |   45 +++-----
 drivers/gpu/drm/i915/intel_display.c         |   58 ++++++----
 drivers/gpu/drm/i915/intel_dp.c              |   19 +--
 drivers/gpu/drm/i915/intel_drv.h             |    1 
 drivers/gpu/drm/i915/intel_fb.c              |    4 
 drivers/gpu/drm/nouveau/nouveau_fbcon.c      |    1 
 drivers/gpu/drm/nouveau/nouveau_gem.c        |    6 -
 drivers/gpu/drm/nouveau/nouveau_notifier.c   |    1 
 drivers/gpu/drm/radeon/r600.c                |    3 
 drivers/gpu/drm/radeon/radeon_atombios.c     |    9 +
 drivers/gpu/drm/radeon/radeon_display.c      |    5 
 drivers/gpu/drm/radeon/radeon_fb.c           |   14 --
 drivers/gpu/drm/radeon/radeon_gem.c          |    4 
 drivers/gpu/drm/vmwgfx/vmwgfx_drv.c          |  145 ++++++++++++++++++++-------
 drivers/gpu/drm/vmwgfx/vmwgfx_drv.h          |    8 +
 drivers/gpu/drm/vmwgfx/vmwgfx_fb.c           |    5 
 drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c         |    3 
 drivers/gpu/drm/vmwgfx/vmwgfx_kms.c          |   17 +++
 drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c          |   27 +++--
 drivers/gpu/drm/vmwgfx/vmwgfx_resource.c     |    4 
 drivers/hwmon/f71882fg.c                     |   32 +++--
 drivers/i2c/busses/i2c-davinci.c             |    6 -
 drivers/i2c/busses/i2c-octeon.c              |    2 
 drivers/i2c/busses/i2c-s3c2410.c             |    4 
 drivers/idle/intel_idle.c                    |   20 ++-
 drivers/mfd/max8925-core.c                   |   13 +-
 drivers/mfd/wm831x-irq.c                     |    9 +
 drivers/mtd/nand/omap2.c                     |    2 
 drivers/net/wireless/iwlwifi/iwl-agn-lib.c   |    2 
 drivers/net/wireless/iwlwifi/iwl3945-base.c  |    2 
 drivers/pci/quirks.c                         |   20 +++
 drivers/regulator/core.c                     |    6 -
 drivers/regulator/max8649.c                  |    2 
 drivers/serial/mfd.c                         |    1 
 drivers/serial/mrst_max3110.c                |    1 
 drivers/spi/spi.c                            |    5 
 drivers/spi/spi_gpio.c                       |    2 
 drivers/spi/spi_mpc8xxx.c                    |   10 +
 drivers/xen/xenbus/xenbus_probe.c            |    9 +
 fs/cifs/cifssmb.c                            |   49 ++++++---
 fs/cifs/inode.c                              |    2 
 fs/fs-writeback.c                            |   19 ---
 fs/fuse/dev.c                                |    2 
 fs/ocfs2/symlink.c                           |    2 
 fs/proc/base.c                               |    4 
 fs/reiserfs/ioctl.c                          |    7 -
 fs/xfs/xfs_log_cil.c                         |   12 +-
 fs/xfs/xfs_log_priv.h                        |   37 +++---
 include/acpi/acpixf.h                        |    2 
 include/drm/drmP.h                           |   29 +++--
 include/drm/drm_pciids.h                     |    2 
 include/linux/cpuidle.h                      |    1 
 include/linux/dmaengine.h                    |    2 
 include/linux/module.h                       |    5 
 include/linux/rcupdate.h                     |    2 
 include/linux/wait.h                         |    1 
 ipc/sem.c                                    |    2 
 kernel/kfifo.c                               |    2 
 kernel/module.c                              |    4 
 kernel/smp.c                                 |   17 ++-
 lib/bug.c                                    |    6 -
 lib/list_sort.c                              |    2 
 mm/ksm.c                                     |    6 -
 mm/rmap.c                                    |    8 +
 net/8021q/vlan_core.c                        |   14 +-
 net/ipv4/Kconfig                             |    1 
 net/ipv4/tcp_timer.c                         |   24 ++--
 net/mac80211/rx.c                            |    4 
 net/phonet/pep.c                             |    3 
 samples/kfifo/dma-example.c                  |   17 +--
 sound/core/control.c                         |    5 
 sound/i2c/other/ak4xxx-adda.c                |    2 
 tools/perf/Makefile                          |    2 
 tools/perf/util/trace-event-scripting.c      |    4 
 tools/perf/util/ui/browsers/hists.c          |    2 
 167 files changed, 990 insertions(+), 560 deletions(-)

diff -urN linux-2.6.36-rc6/CREDITS linux-2.6.36-rc7/CREDITS
--- linux-2.6.36-rc6/CREDITS	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/CREDITS	2010-10-06 21:33:47.977620443 +0000
@@ -3554,12 +3554,12 @@
 D: portions of the Linux Security Module (LSM) framework and security modules
 
 N: Petr Vandrovec
-E: vandrove@vc.cvut.cz
+E: petr@vandrovec.name
 D: Small contributions to ncpfs
 D: Matrox framebuffer driver
-S: Chudenicka 8
-S: 10200 Prague 10, Hostivar
-S: Czech Republic
+S: 21513 Conradia Ct
+S: Cupertino, CA 95014
+S: USA
 
 N: Thibaut Varene
 E: T-Bone@parisc-linux.org
diff -urN linux-2.6.36-rc6/MAINTAINERS linux-2.6.36-rc7/MAINTAINERS
--- linux-2.6.36-rc6/MAINTAINERS	2010-10-06 21:33:42.960628443 +0000
+++ linux-2.6.36-rc7/MAINTAINERS	2010-10-06 21:33:48.033379530 +0000
@@ -962,6 +962,13 @@
 S:	Maintained
 F:	arch/arm/mach-s3c6410/
 
+ARM/S5P ARM ARCHITECTURES
+M:	Kukjin Kim <kgene.kim@samsung.com>
+L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
+L:	linux-samsung-soc@vger.kernel.org (moderated for non-subscribers)
+S:	Maintained
+F:	arch/arm/mach-s5p*/
+
 ARM/SHMOBILE ARM ARCHITECTURE
 M:	Paul Mundt <lethal@linux-sh.org>
 M:	Magnus Damm <magnus.damm@gmail.com>
@@ -3781,9 +3788,8 @@
 S:	Supported
 
 MATROX FRAMEBUFFER DRIVER
-M:	Petr Vandrovec <vandrove@vc.cvut.cz>
 L:	linux-fbdev@vger.kernel.org
-S:	Maintained
+S:	Orphan
 F:	drivers/video/matrox/matroxfb_*
 F:	include/linux/matroxfb.h
 
@@ -3970,8 +3976,8 @@
 F:	drivers/net/natsemi.c
 
 NCP FILESYSTEM
-M:	Petr Vandrovec <vandrove@vc.cvut.cz>
-S:	Maintained
+M:	Petr Vandrovec <petr@vandrovec.name>
+S:	Odd Fixes
 F:	fs/ncpfs/
 
 NCR DUAL 700 SCSI DRIVER (MICROCHANNEL)
diff -urN linux-2.6.36-rc6/Makefile linux-2.6.36-rc7/Makefile
--- linux-2.6.36-rc6/Makefile	2010-10-06 21:33:42.961628799 +0000
+++ linux-2.6.36-rc7/Makefile	2010-10-06 21:33:48.033379530 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 36
-EXTRAVERSION = -rc6
+EXTRAVERSION = -rc7
 NAME = Sheep on Meth
 
 # *DOCUMENTATION*
diff -urN linux-2.6.36-rc6/arch/alpha/kernel/signal.c linux-2.6.36-rc7/arch/alpha/kernel/signal.c
--- linux-2.6.36-rc6/arch/alpha/kernel/signal.c	2010-10-06 21:33:42.968691120 +0000
+++ linux-2.6.36-rc7/arch/alpha/kernel/signal.c	2010-10-06 21:33:48.039816200 +0000
@@ -48,7 +48,7 @@
 	sigset_t mask;
 	unsigned long res;
 
-	siginitset(&mask, newmask & ~_BLOCKABLE);
+	siginitset(&mask, newmask & _BLOCKABLE);
 	res = sigprocmask(how, &mask, &oldmask);
 	if (!res) {
 		force_successful_syscall_return();
diff -urN linux-2.6.36-rc6/arch/arm/oprofile/common.c linux-2.6.36-rc7/arch/arm/oprofile/common.c
--- linux-2.6.36-rc6/arch/arm/oprofile/common.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/arm/oprofile/common.c	2010-10-06 21:33:48.201815758 +0000
@@ -102,6 +102,7 @@
 	if (IS_ERR(pevent)) {
 		ret = PTR_ERR(pevent);
 	} else if (pevent->state != PERF_EVENT_STATE_ACTIVE) {
+		perf_event_release_kernel(pevent);
 		pr_warning("oprofile: failed to enable event %d "
 				"on CPU %d\n", event, cpu);
 		ret = -EBUSY;
@@ -365,6 +366,7 @@
 	ret = init_driverfs();
 	if (ret) {
 		kfree(counter_config);
+		counter_config = NULL;
 		return ret;
 	}
 
@@ -402,7 +404,6 @@
 	struct perf_event *event;
 
 	if (*perf_events) {
-		exit_driverfs();
 		for_each_possible_cpu(cpu) {
 			for (id = 0; id < perf_num_counters; ++id) {
 				event = perf_events[cpu][id];
@@ -413,8 +414,10 @@
 		}
 	}
 
-	if (counter_config)
+	if (counter_config) {
 		kfree(counter_config);
+		exit_driverfs();
+	}
 }
 #else
 int __init oprofile_arch_init(struct oprofile_operations *ops)
diff -urN linux-2.6.36-rc6/arch/arm/plat-omap/Kconfig linux-2.6.36-rc7/arch/arm/plat-omap/Kconfig
--- linux-2.6.36-rc6/arch/arm/plat-omap/Kconfig	2010-10-06 21:33:43.177753216 +0000
+++ linux-2.6.36-rc7/arch/arm/plat-omap/Kconfig	2010-10-06 21:33:48.213815769 +0000
@@ -33,7 +33,7 @@
 config OMAP_DEBUG_LEDS
 	bool
 	depends on OMAP_DEBUG_DEVICES
-	default y if LEDS
+	default y if LEDS_CLASS
 
 config OMAP_RESET_CLOCKS
 	bool "Reset unused clocks during boot"
diff -urN linux-2.6.36-rc6/arch/arm/plat-omap/mcbsp.c linux-2.6.36-rc7/arch/arm/plat-omap/mcbsp.c
--- linux-2.6.36-rc6/arch/arm/plat-omap/mcbsp.c	2010-10-06 21:33:43.182753226 +0000
+++ linux-2.6.36-rc7/arch/arm/plat-omap/mcbsp.c	2010-10-06 21:33:48.219816296 +0000
@@ -156,7 +156,7 @@
 		/* Writing zero to RSYNC_ERR clears the IRQ */
 		MCBSP_WRITE(mcbsp_rx, SPCR1, MCBSP_READ_CACHE(mcbsp_rx, SPCR1));
 	} else {
-		complete(&mcbsp_rx->tx_irq_completion);
+		complete(&mcbsp_rx->rx_irq_completion);
 	}
 
 	return IRQ_HANDLED;
diff -urN linux-2.6.36-rc6/arch/avr32/kernel/module.c linux-2.6.36-rc7/arch/avr32/kernel/module.c
--- linux-2.6.36-rc6/arch/avr32/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/avr32/kernel/module.c	2010-10-06 21:33:48.237815954 +0000
@@ -314,10 +314,9 @@
 	vfree(module->arch.syminfo);
 	module->arch.syminfo = NULL;
 
-	return module_bug_finalize(hdr, sechdrs, module);
+	return 0;
 }
 
 void module_arch_cleanup(struct module *module)
 {
-	module_bug_cleanup(module);
 }
diff -urN linux-2.6.36-rc6/arch/h8300/kernel/module.c linux-2.6.36-rc7/arch/h8300/kernel/module.c
--- linux-2.6.36-rc6/arch/h8300/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/h8300/kernel/module.c	2010-10-06 21:33:48.283815975 +0000
@@ -112,10 +112,9 @@
 		    const Elf_Shdr *sechdrs,
 		    struct module *me)
 {
-	return module_bug_finalize(hdr, sechdrs, me);
+	return 0;
 }
 
 void module_arch_cleanup(struct module *mod)
 {
-	module_bug_cleanup(mod);
 }
diff -urN linux-2.6.36-rc6/arch/m68k/mac/macboing.c linux-2.6.36-rc7/arch/m68k/mac/macboing.c
--- linux-2.6.36-rc6/arch/m68k/mac/macboing.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/m68k/mac/macboing.c	2010-10-06 21:33:48.309815827 +0000
@@ -162,7 +162,7 @@
 void mac_mksound( unsigned int freq, unsigned int length )
 {
 	__u32 cfreq = ( freq << 5 ) / 468;
-	__u32 flags;
+	unsigned long flags;
 	int i;
 
 	if ( mac_special_bell == NULL )
@@ -224,7 +224,7 @@
  */
 static void mac_quadra_start_bell( unsigned int freq, unsigned int length, unsigned int volume )
 {
-	__u32 flags;
+	unsigned long flags;
 
 	/* if the bell is already ringing, ring longer */
 	if ( mac_bell_duration > 0 )
@@ -271,7 +271,7 @@
 static void mac_quadra_ring_bell( unsigned long ignored )
 {
 	int	i, count = mac_asc_samplespersec / HZ;
-	__u32 flags;
+	unsigned long flags;
 
 	/*
 	 * we neither want a sound buffer overflow nor underflow, so we need to match
diff -urN linux-2.6.36-rc6/arch/mips/Kconfig linux-2.6.36-rc7/arch/mips/Kconfig
--- linux-2.6.36-rc6/arch/mips/Kconfig	2010-10-06 21:33:43.310816195 +0000
+++ linux-2.6.36-rc7/arch/mips/Kconfig	2010-10-06 21:33:48.322815845 +0000
@@ -13,6 +13,7 @@
 	select HAVE_KPROBES
 	select HAVE_KRETPROBES
 	select RTC_LIB if !MACH_LOONGSON
+	select GENERIC_ATOMIC64 if !64BIT
 
 mainmenu "Linux/MIPS Kernel Configuration"
 
@@ -1646,8 +1647,16 @@
 	select SYS_SUPPORTS_SMP
 	select SMP_UP
 	help
-	  This is a kernel model which is also known a VSMP or lately
-	  has been marketesed into SMVP.
+	  This is a kernel model which is known a VSMP but lately has been
+	  marketesed into SMVP.
+	  Virtual SMP uses the processor's VPEs  to implement virtual
+	  processors. In currently available configuration of the 34K processor
+	  this allows for a dual processor. Both processors will share the same
+	  primary caches; each will obtain the half of the TLB for it's own
+	  exclusive use. For a layman this model can be described as similar to
+	  what Intel calls Hyperthreading.
+
+	  For further information see http://www.linux-mips.org/wiki/34K#VSMP
 
 config MIPS_MT_SMTC
 	bool "SMTC: Use all TCs on all VPEs for SMP"
@@ -1664,6 +1673,14 @@
 	help
 	  This is a kernel model which is known a SMTC or lately has been
 	  marketesed into SMVP.
+	  is presenting the available TC's of the core as processors to Linux.
+	  On currently available 34K processors this means a Linux system will
+	  see up to 5 processors. The implementation of the SMTC kernel differs
+	  significantly from VSMP and cannot efficiently coexist in the same
+	  kernel binary so the choice between VSMP and SMTC is a compile time
+	  decision.
+
+	  For further information see http://www.linux-mips.org/wiki/34K#SMTC
 
 endchoice
 
diff -urN linux-2.6.36-rc6/arch/mips/alchemy/common/prom.c linux-2.6.36-rc7/arch/mips/alchemy/common/prom.c
--- linux-2.6.36-rc6/arch/mips/alchemy/common/prom.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/alchemy/common/prom.c	2010-10-06 21:33:48.323815904 +0000
@@ -43,7 +43,7 @@
 char **prom_argv;
 char **prom_envp;
 
-void prom_init_cmdline(void)
+void __init prom_init_cmdline(void)
 {
 	int i;
 
@@ -104,7 +104,7 @@
 	}
 }
 
-int prom_get_ethernet_addr(char *ethernet_addr)
+int __init prom_get_ethernet_addr(char *ethernet_addr)
 {
 	char *ethaddr_str;
 
@@ -123,7 +123,6 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(prom_get_ethernet_addr);
 
 void __init prom_free_prom_memory(void)
 {
diff -urN linux-2.6.36-rc6/arch/mips/boot/compressed/Makefile linux-2.6.36-rc7/arch/mips/boot/compressed/Makefile
--- linux-2.6.36-rc6/arch/mips/boot/compressed/Makefile	2010-10-06 21:33:43.314816159 +0000
+++ linux-2.6.36-rc7/arch/mips/boot/compressed/Makefile	2010-10-06 21:33:48.325815874 +0000
@@ -59,7 +59,7 @@
 hostprogs-y := calc_vmlinuz_load_addr
 
 VMLINUZ_LOAD_ADDRESS = $(shell $(obj)/calc_vmlinuz_load_addr \
-		$(objtree)/$(KBUILD_IMAGE) $(VMLINUX_LOAD_ADDRESS))
+		$(obj)/vmlinux.bin $(VMLINUX_LOAD_ADDRESS))
 
 vmlinuzobjs-y += $(obj)/piggy.o
 
diff -urN linux-2.6.36-rc6/arch/mips/cavium-octeon/Kconfig linux-2.6.36-rc7/arch/mips/cavium-octeon/Kconfig
--- linux-2.6.36-rc6/arch/mips/cavium-octeon/Kconfig	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/cavium-octeon/Kconfig	2010-10-06 21:33:48.326815783 +0000
@@ -83,3 +83,7 @@
 	def_bool y
 	select SPARSEMEM_STATIC
 	depends on CPU_CAVIUM_OCTEON
+
+config CAVIUM_OCTEON_HELPER
+	def_bool y
+	depends on OCTEON_ETHERNET || PCI
diff -urN linux-2.6.36-rc6/arch/mips/cavium-octeon/cpu.c linux-2.6.36-rc7/arch/mips/cavium-octeon/cpu.c
--- linux-2.6.36-rc6/arch/mips/cavium-octeon/cpu.c	2010-10-06 21:33:43.315816163 +0000
+++ linux-2.6.36-rc7/arch/mips/cavium-octeon/cpu.c	2010-10-06 21:33:48.326815783 +0000
@@ -41,7 +41,7 @@
 	return NOTIFY_OK;		/* Let default notifier send signals */
 }
 
-static int cnmips_cu2_setup(void)
+static int __init cnmips_cu2_setup(void)
 {
 	return cu2_notifier(cnmips_cu2_call, 0);
 }
diff -urN linux-2.6.36-rc6/arch/mips/cavium-octeon/executive/Makefile linux-2.6.36-rc7/arch/mips/cavium-octeon/executive/Makefile
--- linux-2.6.36-rc6/arch/mips/cavium-octeon/executive/Makefile	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/cavium-octeon/executive/Makefile	2010-10-06 21:33:48.326815783 +0000
@@ -11,4 +11,4 @@
 
 obj-y += cvmx-bootmem.o cvmx-l2c.o cvmx-sysinfo.o octeon-model.o
 
-obj-$(CONFIG_PCI) += cvmx-helper-errata.o cvmx-helper-jtag.o
+obj-$(CONFIG_CAVIUM_OCTEON_HELPER) += cvmx-helper-errata.o cvmx-helper-jtag.o
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/atomic.h linux-2.6.36-rc7/arch/mips/include/asm/atomic.h
--- linux-2.6.36-rc6/arch/mips/include/asm/atomic.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/atomic.h	2010-10-06 21:33:48.361815758 +0000
@@ -782,6 +782,10 @@
  */
 #define atomic64_add_negative(i, v) (atomic64_add_return(i, (v)) < 0)
 
+#else /* !CONFIG_64BIT */
+
+#include <asm-generic/atomic64.h>
+
 #endif /* CONFIG_64BIT */
 
 /*
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/cop2.h linux-2.6.36-rc7/arch/mips/include/asm/cop2.h
--- linux-2.6.36-rc6/arch/mips/include/asm/cop2.h	2010-10-06 21:33:43.368816745 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/cop2.h	2010-10-06 21:33:48.361815758 +0000
@@ -24,7 +24,7 @@
 
 #define cu2_notifier(fn, pri)						\
 ({									\
-	static struct notifier_block fn##_nb __cpuinitdata = {		\
+	static struct notifier_block fn##_nb = {			\
 		.notifier_call = fn,					\
 		.priority = pri						\
 	};								\
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/gic.h linux-2.6.36-rc7/arch/mips/include/asm/gic.h
--- linux-2.6.36-rc6/arch/mips/include/asm/gic.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/gic.h	2010-10-06 21:33:48.362815756 +0000
@@ -321,6 +321,7 @@
  */
 struct gic_intr_map {
 	unsigned int cpunum;	/* Directed to this CPU */
+#define GIC_UNUSED		0xdead			/* Dummy data */
 	unsigned int pin;	/* Directed to this Pin */
 	unsigned int polarity;	/* Polarity : +/-	*/
 	unsigned int trigtype;	/* Trigger  : Edge/Levl */
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/mach-tx49xx/kmalloc.h linux-2.6.36-rc7/arch/mips/include/asm/mach-tx49xx/kmalloc.h
--- linux-2.6.36-rc6/arch/mips/include/asm/mach-tx49xx/kmalloc.h	2010-10-06 21:33:43.373816458 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/mach-tx49xx/kmalloc.h	2010-10-06 21:33:48.366378462 +0000
@@ -1,6 +1,6 @@
 #ifndef __ASM_MACH_TX49XX_KMALLOC_H
 #define __ASM_MACH_TX49XX_KMALLOC_H
 
-#define ARCH_KMALLOC_MINALIGN	L1_CACHE_BYTES
+#define ARCH_DMA_MINALIGN L1_CACHE_BYTES
 
 #endif /* __ASM_MACH_TX49XX_KMALLOC_H */
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/mips-boards/maltaint.h linux-2.6.36-rc7/arch/mips/include/asm/mips-boards/maltaint.h
--- linux-2.6.36-rc6/arch/mips/include/asm/mips-boards/maltaint.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/mips-boards/maltaint.h	2010-10-06 21:33:48.366378462 +0000
@@ -88,9 +88,6 @@
 
 #define GIC_EXT_INTR(x)		x
 
-/* Dummy data */
-#define X			0xdead
-
 /* External Interrupts used for IPI */
 #define GIC_IPI_EXT_INTR_RESCHED_VPE0	16
 #define GIC_IPI_EXT_INTR_CALLFNC_VPE0	17
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/page.h linux-2.6.36-rc7/arch/mips/include/asm/page.h
--- linux-2.6.36-rc6/arch/mips/include/asm/page.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/page.h	2010-10-06 21:33:48.366378462 +0000
@@ -150,6 +150,20 @@
     ((unsigned long)(x) - PAGE_OFFSET + PHYS_OFFSET)
 #endif
 #define __va(x)		((void *)((unsigned long)(x) + PAGE_OFFSET - PHYS_OFFSET))
+
+/*
+ * RELOC_HIDE was originally added by 6007b903dfe5f1d13e0c711ac2894bdd4a61b1ad
+ * (lmo) rsp. 8431fd094d625b94d364fe393076ccef88e6ce18 (kernel.org).  The
+ * discussion can be found in lkml posting
+ * <a2ebde260608230500o3407b108hc03debb9da6e62c@mail.gmail.com> which is
+ * archived at http://lists.linuxcoding.com/kernel/2006-q3/msg17360.html
+ *
+ * It is unclear if the misscompilations mentioned in
+ * http://lkml.org/lkml/2010/8/8/138 also affect MIPS so we keep this one
+ * until GCC 3.x has been retired before we can apply
+ * https://patchwork.linux-mips.org/patch/1541/
+ */
+
 #define __pa_symbol(x)	__pa(RELOC_HIDE((unsigned long)(x), 0))
 
 #define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/thread_info.h linux-2.6.36-rc7/arch/mips/include/asm/thread_info.h
--- linux-2.6.36-rc6/arch/mips/include/asm/thread_info.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/thread_info.h	2010-10-06 21:33:48.367815855 +0000
@@ -146,7 +146,8 @@
 #define _TIF_LOAD_WATCH		(1<<TIF_LOAD_WATCH)
 
 /* work to do on interrupt/exception return */
-#define _TIF_WORK_MASK		(0x0000ffef & ~_TIF_SECCOMP)
+#define _TIF_WORK_MASK		(0x0000ffef &				\
+					~(_TIF_SECCOMP | _TIF_SYSCALL_AUDIT))
 /* work to do on any return to u-space */
 #define _TIF_ALLWORK_MASK	(0x8000ffff & ~_TIF_SECCOMP)
 
diff -urN linux-2.6.36-rc6/arch/mips/include/asm/unistd.h linux-2.6.36-rc7/arch/mips/include/asm/unistd.h
--- linux-2.6.36-rc6/arch/mips/include/asm/unistd.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/include/asm/unistd.h	2010-10-06 21:33:48.367815855 +0000
@@ -356,16 +356,19 @@
 #define __NR_perf_event_open		(__NR_Linux + 333)
 #define __NR_accept4			(__NR_Linux + 334)
 #define __NR_recvmmsg			(__NR_Linux + 335)
+#define __NR_fanotify_init		(__NR_Linux + 336)
+#define __NR_fanotify_mark		(__NR_Linux + 337)
+#define __NR_prlimit64			(__NR_Linux + 338)
 
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		335
+#define __NR_Linux_syscalls		338
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
 #define __NR_O32_Linux			4000
-#define __NR_O32_Linux_syscalls		335
+#define __NR_O32_Linux_syscalls		338
 
 #if _MIPS_SIM == _MIPS_SIM_ABI64
 
@@ -668,16 +671,19 @@
 #define __NR_perf_event_open		(__NR_Linux + 292)
 #define __NR_accept4			(__NR_Linux + 293)
 #define __NR_recvmmsg			(__NR_Linux + 294)
+#define __NR_fanotify_init		(__NR_Linux + 295)
+#define __NR_fanotify_mark		(__NR_Linux + 296)
+#define __NR_prlimit64			(__NR_Linux + 297)
 
 /*
  * Offset of the last Linux 64-bit flavoured syscall
  */
-#define __NR_Linux_syscalls		294
+#define __NR_Linux_syscalls		297
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
 #define __NR_64_Linux			5000
-#define __NR_64_Linux_syscalls		294
+#define __NR_64_Linux_syscalls		297
 
 #if _MIPS_SIM == _MIPS_SIM_NABI32
 
@@ -985,16 +991,19 @@
 #define __NR_accept4			(__NR_Linux + 297)
 #define __NR_recvmmsg			(__NR_Linux + 298)
 #define __NR_getdents64			(__NR_Linux + 299)
+#define __NR_fanotify_init		(__NR_Linux + 300)
+#define __NR_fanotify_mark		(__NR_Linux + 301)
+#define __NR_prlimit64			(__NR_Linux + 302)
 
 /*
  * Offset of the last N32 flavoured syscall
  */
-#define __NR_Linux_syscalls		299
+#define __NR_Linux_syscalls		302
 
 #endif /* _MIPS_SIM == _MIPS_SIM_NABI32 */
 
 #define __NR_N32_Linux			6000
-#define __NR_N32_Linux_syscalls		299
+#define __NR_N32_Linux_syscalls		302
 
 #ifdef __KERNEL__
 
diff -urN linux-2.6.36-rc6/arch/mips/kernel/irq-gic.c linux-2.6.36-rc7/arch/mips/kernel/irq-gic.c
--- linux-2.6.36-rc6/arch/mips/kernel/irq-gic.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/irq-gic.c	2010-10-06 21:33:48.370815772 +0000
@@ -7,7 +7,6 @@
 #include <asm/io.h>
 #include <asm/gic.h>
 #include <asm/gcmpregs.h>
-#include <asm/mips-boards/maltaint.h>
 #include <asm/irq.h>
 #include <linux/hardirq.h>
 #include <asm-generic/bitops/find.h>
@@ -131,7 +130,7 @@
 	int		i;
 
 	irq -= _irqbase;
-	pr_debug(KERN_DEBUG "%s(%d) called\n", __func__, irq);
+	pr_debug("%s(%d) called\n", __func__, irq);
 	cpumask_and(&tmp, cpumask, cpu_online_mask);
 	if (cpus_empty(tmp))
 		return -1;
@@ -222,7 +221,7 @@
 	/* Setup specifics */
 	for (i = 0; i < mapsize; i++) {
 		cpu = intrmap[i].cpunum;
-		if (cpu == X)
+		if (cpu == GIC_UNUSED)
 			continue;
 		if (cpu == 0 && i != 0 && intrmap[i].flags == 0)
 			continue;
diff -urN linux-2.6.36-rc6/arch/mips/kernel/kgdb.c linux-2.6.36-rc7/arch/mips/kernel/kgdb.c
--- linux-2.6.36-rc6/arch/mips/kernel/kgdb.c	2010-10-06 21:33:43.380816147 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/kgdb.c	2010-10-06 21:33:48.371815813 +0000
@@ -283,7 +283,7 @@
 	struct pt_regs *regs = args->regs;
 	int trap = (regs->cp0_cause & 0x7c) >> 2;
 
-	/* Userpace events, ignore. */
+	/* Userspace events, ignore. */
 	if (user_mode(regs))
 		return NOTIFY_DONE;
 
diff -urN linux-2.6.36-rc6/arch/mips/kernel/kspd.c linux-2.6.36-rc7/arch/mips/kernel/kspd.c
--- linux-2.6.36-rc6/arch/mips/kernel/kspd.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/kspd.c	2010-10-06 21:33:48.371815813 +0000
@@ -251,7 +251,7 @@
  		memset(&tz, 0, sizeof(tz));
  		if ((ret.retval = sp_syscall(__NR_gettimeofday, (int)&tv,
 					     (int)&tz, 0, 0)) == 0)
-		ret.retval = tv.tv_sec;
+			ret.retval = tv.tv_sec;
 		break;
 
  	case MTSP_SYSCALL_EXIT:
diff -urN linux-2.6.36-rc6/arch/mips/kernel/linux32.c linux-2.6.36-rc7/arch/mips/kernel/linux32.c
--- linux-2.6.36-rc6/arch/mips/kernel/linux32.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/linux32.c	2010-10-06 21:33:48.371815813 +0000
@@ -341,3 +341,10 @@
 {
 	return sys_lookup_dcookie(merge_64(a0, a1), buf, len);
 }
+
+SYSCALL_DEFINE6(32_fanotify_mark, int, fanotify_fd, unsigned int, flags,
+		u64, a3, u64, a4, int, dfd, const char  __user *, pathname)
+{
+	return sys_fanotify_mark(fanotify_fd, flags, merge_64(a3, a4),
+				 dfd, pathname);
+}
diff -urN linux-2.6.36-rc6/arch/mips/kernel/scall32-o32.S linux-2.6.36-rc7/arch/mips/kernel/scall32-o32.S
--- linux-2.6.36-rc6/arch/mips/kernel/scall32-o32.S	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/scall32-o32.S	2010-10-06 21:33:48.371815813 +0000
@@ -583,7 +583,10 @@
 	sys	sys_rt_tgsigqueueinfo	4
 	sys	sys_perf_event_open	5
 	sys	sys_accept4		4
-	sys     sys_recvmmsg            5
+	sys	sys_recvmmsg		5	/* 4335 */
+	sys	sys_fanotify_init	2
+	sys	sys_fanotify_mark	6
+	sys	sys_prlimit64		4
 	.endm
 
 	/* We pre-compute the number of _instruction_ bytes needed to
diff -urN linux-2.6.36-rc6/arch/mips/kernel/scall64-64.S linux-2.6.36-rc7/arch/mips/kernel/scall64-64.S
--- linux-2.6.36-rc6/arch/mips/kernel/scall64-64.S	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/scall64-64.S	2010-10-06 21:33:48.371815813 +0000
@@ -416,9 +416,12 @@
 	PTR	sys_pipe2
 	PTR	sys_inotify_init1
 	PTR	sys_preadv
-	PTR	sys_pwritev			/* 5390 */
+	PTR	sys_pwritev			/* 5290 */
 	PTR	sys_rt_tgsigqueueinfo
 	PTR	sys_perf_event_open
 	PTR	sys_accept4
-	PTR     sys_recvmmsg
+	PTR	sys_recvmmsg
+	PTR	sys_fanotify_init		/* 5295 */
+	PTR	sys_fanotify_mark
+	PTR	sys_prlimit64
 	.size	sys_call_table,.-sys_call_table
diff -urN linux-2.6.36-rc6/arch/mips/kernel/scall64-n32.S linux-2.6.36-rc7/arch/mips/kernel/scall64-n32.S
--- linux-2.6.36-rc6/arch/mips/kernel/scall64-n32.S	2010-10-06 21:33:43.381816144 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/scall64-n32.S	2010-10-06 21:33:48.372815763 +0000
@@ -419,5 +419,8 @@
 	PTR	sys_perf_event_open
 	PTR	sys_accept4
 	PTR     compat_sys_recvmmsg
-	PTR     sys_getdents
+	PTR     sys_getdents64
+	PTR	sys_fanotify_init		/* 6300 */
+	PTR	sys_fanotify_mark
+	PTR	sys_prlimit64
 	.size	sysn32_call_table,.-sysn32_call_table
diff -urN linux-2.6.36-rc6/arch/mips/kernel/scall64-o32.S linux-2.6.36-rc7/arch/mips/kernel/scall64-o32.S
--- linux-2.6.36-rc6/arch/mips/kernel/scall64-o32.S	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/kernel/scall64-o32.S	2010-10-06 21:33:48.372815763 +0000
@@ -538,5 +538,8 @@
 	PTR	compat_sys_rt_tgsigqueueinfo
 	PTR	sys_perf_event_open
 	PTR	sys_accept4
-	PTR     compat_sys_recvmmsg
+	PTR	compat_sys_recvmmsg		/* 4335 */
+	PTR	sys_fanotify_init
+	PTR	sys_32_fanotify_mark
+	PTR	sys_prlimit64
 	.size	sys_call_table,.-sys_call_table
diff -urN linux-2.6.36-rc6/arch/mips/mm/dma-default.c linux-2.6.36-rc7/arch/mips/mm/dma-default.c
--- linux-2.6.36-rc6/arch/mips/mm/dma-default.c	2010-10-06 21:33:43.384816169 +0000
+++ linux-2.6.36-rc7/arch/mips/mm/dma-default.c	2010-10-06 21:33:48.374815775 +0000
@@ -44,27 +44,39 @@
 
 static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
 {
+	gfp_t dma_flag;
+
 	/* ignore region specifiers */
 	gfp &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);
 
-#ifdef CONFIG_ZONE_DMA
+#ifdef CONFIG_ISA
 	if (dev == NULL)
-		gfp |= __GFP_DMA;
-	else if (dev->coherent_dma_mask < DMA_BIT_MASK(24))
-		gfp |= __GFP_DMA;
+		dma_flag = __GFP_DMA;
 	else
 #endif
-#ifdef CONFIG_ZONE_DMA32
+#if defined(CONFIG_ZONE_DMA32) && defined(CONFIG_ZONE_DMA)
 	     if (dev->coherent_dma_mask < DMA_BIT_MASK(32))
-		gfp |= __GFP_DMA32;
+			dma_flag = __GFP_DMA;
+	else if (dev->coherent_dma_mask < DMA_BIT_MASK(64))
+			dma_flag = __GFP_DMA32;
+	else
+#endif
+#if defined(CONFIG_ZONE_DMA32) && !defined(CONFIG_ZONE_DMA)
+	     if (dev->coherent_dma_mask < DMA_BIT_MASK(64))
+		dma_flag = __GFP_DMA32;
+	else
+#endif
+#if defined(CONFIG_ZONE_DMA) && !defined(CONFIG_ZONE_DMA32)
+	     if (dev->coherent_dma_mask < DMA_BIT_MASK(64))
+		dma_flag = __GFP_DMA;
 	else
 #endif
-		;
+		dma_flag = 0;
 
 	/* Don't invoke OOM killer */
 	gfp |= __GFP_NORETRY;
 
-	return gfp;
+	return gfp | dma_flag;
 }
 
 void *dma_alloc_noncoherent(struct device *dev, size_t size,
diff -urN linux-2.6.36-rc6/arch/mips/mm/sc-rm7k.c linux-2.6.36-rc7/arch/mips/mm/sc-rm7k.c
--- linux-2.6.36-rc6/arch/mips/mm/sc-rm7k.c	2010-10-06 21:33:43.385816151 +0000
+++ linux-2.6.36-rc7/arch/mips/mm/sc-rm7k.c	2010-10-06 21:33:48.374815775 +0000
@@ -30,7 +30,7 @@
 #define tc_lsize	32
 
 extern unsigned long icache_way_size, dcache_way_size;
-unsigned long tcache_size;
+static unsigned long tcache_size;
 
 #include <asm/r4kcache.h>
 
diff -urN linux-2.6.36-rc6/arch/mips/mti-malta/malta-int.c linux-2.6.36-rc7/arch/mips/mti-malta/malta-int.c
--- linux-2.6.36-rc6/arch/mips/mti-malta/malta-int.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/mti-malta/malta-int.c	2010-10-06 21:33:48.376431884 +0000
@@ -385,6 +385,8 @@
  */
 
 #define GIC_CPU_NMI GIC_MAP_TO_NMI_MSK
+#define X GIC_UNUSED
+
 static struct gic_intr_map gic_intr_map[GIC_NUM_INTRS] = {
 	{ X, X,		   X,		X,		0 },
 	{ X, X,		   X,	 	X,		0 },
@@ -404,6 +406,7 @@
 	{ X, X,		   X,		X,	        0 },
 	/* The remainder of this table is initialised by fill_ipi_map */
 };
+#undef X
 
 /*
  * GCMP needs to be detected before any SMP initialisation
diff -urN linux-2.6.36-rc6/arch/mips/pci/pci-rc32434.c linux-2.6.36-rc7/arch/mips/pci/pci-rc32434.c
--- linux-2.6.36-rc6/arch/mips/pci/pci-rc32434.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mips/pci/pci-rc32434.c	2010-10-06 21:33:48.385815914 +0000
@@ -118,7 +118,7 @@
 	if (!((pcicvalue == PCIM_H_EA) ||
 	      (pcicvalue == PCIM_H_IA_FIX) ||
 	      (pcicvalue == PCIM_H_IA_RR))) {
-		pr_err(KERN_ERR "PCI init error!!!\n");
+		pr_err("PCI init error!!!\n");
 		/* Not in Host Mode, return ERROR */
 		return -1;
 	}
diff -urN linux-2.6.36-rc6/arch/mips/pnx8550/common/reset.c linux-2.6.36-rc7/arch/mips/pnx8550/common/reset.c
--- linux-2.6.36-rc6/arch/mips/pnx8550/common/reset.c	2010-10-06 21:33:43.403509027 +0000
+++ linux-2.6.36-rc7/arch/mips/pnx8550/common/reset.c	2010-10-06 21:33:48.387815785 +0000
@@ -22,29 +22,19 @@
  */
 #include <linux/kernel.h>
 
+#include <asm/processor.h>
 #include <asm/reboot.h>
 #include <glb.h>
 
 void pnx8550_machine_restart(char *command)
 {
-	char head[] = "************* Machine restart *************";
-	char foot[] = "*******************************************";
-
-	printk("\n\n");
-	printk("%s\n", head);
-	if (command != NULL)
-		printk("* %s\n", command);
-	printk("%s\n", foot);
-
 	PNX8550_RST_CTL = PNX8550_RST_DO_SW_RST;
 }
 
 void pnx8550_machine_halt(void)
 {
-	printk("*** Machine halt. (Not implemented) ***\n");
-}
-
-void pnx8550_machine_power_off(void)
-{
-	printk("*** Machine power off.  (Not implemented) ***\n");
+	while (1) {
+		if (cpu_wait)
+			cpu_wait();
+	}
 }
diff -urN linux-2.6.36-rc6/arch/mips/pnx8550/common/setup.c linux-2.6.36-rc7/arch/mips/pnx8550/common/setup.c
--- linux-2.6.36-rc6/arch/mips/pnx8550/common/setup.c	2010-10-06 21:33:43.403509027 +0000
+++ linux-2.6.36-rc7/arch/mips/pnx8550/common/setup.c	2010-10-06 21:33:48.387815785 +0000
@@ -44,7 +44,6 @@
 extern void __init board_setup(void);
 extern void pnx8550_machine_restart(char *);
 extern void pnx8550_machine_halt(void);
-extern void pnx8550_machine_power_off(void);
 extern struct resource ioport_resource;
 extern struct resource iomem_resource;
 extern char *prom_getcmdline(void);
@@ -100,7 +99,7 @@
 
         _machine_restart = pnx8550_machine_restart;
         _machine_halt = pnx8550_machine_halt;
-        pm_power_off = pnx8550_machine_power_off;
+        pm_power_off = pnx8550_machine_halt;
 
 	/* Clear the Global 2 Register, PCI Inta Output Enable Registers
 	   Bit 1:Enable DAC Powerdown
diff -urN linux-2.6.36-rc6/arch/mn10300/kernel/module.c linux-2.6.36-rc7/arch/mn10300/kernel/module.c
--- linux-2.6.36-rc6/arch/mn10300/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mn10300/kernel/module.c	2010-10-06 21:33:48.394701774 +0000
@@ -206,7 +206,7 @@
 		    const Elf_Shdr *sechdrs,
 		    struct module *me)
 {
-	return module_bug_finalize(hdr, sechdrs, me);
+	return 0;
 }
 
 /*
@@ -214,5 +214,4 @@
  */
 void module_arch_cleanup(struct module *mod)
 {
-	module_bug_cleanup(mod);
 }
diff -urN linux-2.6.36-rc6/arch/mn10300/mm/cache.c linux-2.6.36-rc7/arch/mn10300/mm/cache.c
--- linux-2.6.36-rc6/arch/mn10300/mm/cache.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/mn10300/mm/cache.c	2010-10-06 21:33:48.395954828 +0000
@@ -54,13 +54,30 @@
 void flush_icache_range(unsigned long start, unsigned long end)
 {
 #ifdef CONFIG_MN10300_CACHE_WBACK
-	unsigned long addr, size, off;
+	unsigned long addr, size, base, off;
 	struct page *page;
 	pgd_t *pgd;
 	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *ppte, pte;
 
+	if (end > 0x80000000UL) {
+		/* addresses above 0xa0000000 do not go through the cache */
+		if (end > 0xa0000000UL) {
+			end = 0xa0000000UL;
+			if (start >= end)
+				return;
+		}
+
+		/* kernel addresses between 0x80000000 and 0x9fffffff do not
+		 * require page tables, so we just map such addresses directly */
+		base = (start >= 0x80000000UL) ? start : 0x80000000UL;
+		mn10300_dcache_flush_range(base, end);
+		if (base == start)
+			goto invalidate;
+		end = base;
+	}
+
 	for (; start < end; start += size) {
 		/* work out how much of the page to flush */
 		off = start & (PAGE_SIZE - 1);
@@ -104,6 +121,7 @@
 	}
 #endif
 
+invalidate:
 	mn10300_icache_inv();
 }
 EXPORT_SYMBOL(flush_icache_range);
diff -urN linux-2.6.36-rc6/arch/parisc/kernel/module.c linux-2.6.36-rc7/arch/parisc/kernel/module.c
--- linux-2.6.36-rc6/arch/parisc/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/parisc/kernel/module.c	2010-10-06 21:33:48.400815828 +0000
@@ -941,11 +941,10 @@
 	nsyms = newptr - (Elf_Sym *)symhdr->sh_addr;
 	DEBUGP("NEW num_symtab %lu\n", nsyms);
 	symhdr->sh_size = nsyms * sizeof(Elf_Sym);
-	return module_bug_finalize(hdr, sechdrs, me);
+	return 0;
 }
 
 void module_arch_cleanup(struct module *mod)
 {
 	deregister_unwind_table(mod);
-	module_bug_cleanup(mod);
 }
diff -urN linux-2.6.36-rc6/arch/powerpc/kernel/module.c linux-2.6.36-rc7/arch/powerpc/kernel/module.c
--- linux-2.6.36-rc6/arch/powerpc/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/powerpc/kernel/module.c	2010-10-06 21:33:48.488815898 +0000
@@ -63,11 +63,6 @@
 		const Elf_Shdr *sechdrs, struct module *me)
 {
 	const Elf_Shdr *sect;
-	int err;
-
-	err = module_bug_finalize(hdr, sechdrs, me);
-	if (err)
-		return err;
 
 	/* Apply feature fixups */
 	sect = find_section(hdr, sechdrs, "__ftr_fixup");
@@ -101,5 +96,4 @@
 
 void module_arch_cleanup(struct module *mod)
 {
-	module_bug_cleanup(mod);
 }
diff -urN linux-2.6.36-rc6/arch/powerpc/platforms/512x/clock.c linux-2.6.36-rc7/arch/powerpc/platforms/512x/clock.c
--- linux-2.6.36-rc6/arch/powerpc/platforms/512x/clock.c	2010-10-06 21:33:43.512380071 +0000
+++ linux-2.6.36-rc7/arch/powerpc/platforms/512x/clock.c	2010-10-06 21:33:48.499815975 +0000
@@ -57,7 +57,7 @@
 	int id_match = 0;
 
 	if (dev == NULL || id == NULL)
-		return NULL;
+		return clk;
 
 	mutex_lock(&clocks_mutex);
 	list_for_each_entry(p, &clocks, node) {
diff -urN linux-2.6.36-rc6/arch/powerpc/platforms/52xx/efika.c linux-2.6.36-rc7/arch/powerpc/platforms/52xx/efika.c
--- linux-2.6.36-rc6/arch/powerpc/platforms/52xx/efika.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/powerpc/platforms/52xx/efika.c	2010-10-06 21:33:48.500815803 +0000
@@ -99,7 +99,7 @@
 	if (bus_range == NULL || len < 2 * sizeof(int)) {
 		printk(KERN_WARNING EFIKA_PLATFORM_NAME
 		       ": Can't get bus-range for %s\n", pcictrl->full_name);
-		return;
+		goto out_put;
 	}
 
 	if (bus_range[1] == bus_range[0])
@@ -111,12 +111,12 @@
 	printk(" controlled by %s\n", pcictrl->full_name);
 	printk("\n");
 
-	hose = pcibios_alloc_controller(of_node_get(pcictrl));
+	hose = pcibios_alloc_controller(pcictrl);
 	if (!hose) {
 		printk(KERN_WARNING EFIKA_PLATFORM_NAME
 		       ": Can't allocate PCI controller structure for %s\n",
 		       pcictrl->full_name);
-		return;
+		goto out_put;
 	}
 
 	hose->first_busno = bus_range[0];
@@ -124,6 +124,9 @@
 	hose->ops = &rtas_pci_ops;
 
 	pci_process_bridge_OF_ranges(hose, pcictrl, 0);
+	return;
+out_put:
+	of_node_put(pcictrl);
 }
 
 #else
diff -urN linux-2.6.36-rc6/arch/powerpc/platforms/52xx/mpc52xx_common.c linux-2.6.36-rc7/arch/powerpc/platforms/52xx/mpc52xx_common.c
--- linux-2.6.36-rc6/arch/powerpc/platforms/52xx/mpc52xx_common.c	2010-10-06 21:33:43.513507092 +0000
+++ linux-2.6.36-rc7/arch/powerpc/platforms/52xx/mpc52xx_common.c	2010-10-06 21:33:48.500815803 +0000
@@ -325,12 +325,16 @@
 	clrbits32(&simple_gpio->simple_dvo, sync | out);
 	clrbits8(&wkup_gpio->wkup_dvo, reset);
 
-	/* wait at lease 1 us */
-	udelay(2);
+	/* wait for 1 us */
+	udelay(1);
 
 	/* Deassert reset */
 	setbits8(&wkup_gpio->wkup_dvo, reset);
 
+	/* wait at least 200ns */
+	/* 7 ~= (200ns * timebase) / ns2sec */
+	__delay(7);
+
 	/* Restore pin-muxing */
 	out_be32(&simple_gpio->port_config, mux);
 
diff -urN linux-2.6.36-rc6/arch/s390/kernel/module.c linux-2.6.36-rc7/arch/s390/kernel/module.c
--- linux-2.6.36-rc6/arch/s390/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/s390/kernel/module.c	2010-10-06 21:33:48.514815790 +0000
@@ -407,10 +407,9 @@
 {
 	vfree(me->arch.syminfo);
 	me->arch.syminfo = NULL;
-	return module_bug_finalize(hdr, sechdrs, me);
+	return 0;
 }
 
 void module_arch_cleanup(struct module *mod)
 {
-	module_bug_cleanup(mod);
 }
diff -urN linux-2.6.36-rc6/arch/sh/kernel/module.c linux-2.6.36-rc7/arch/sh/kernel/module.c
--- linux-2.6.36-rc6/arch/sh/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/sh/kernel/module.c	2010-10-06 21:33:48.551815913 +0000
@@ -149,13 +149,11 @@
 	int ret = 0;
 
 	ret |= module_dwarf_finalize(hdr, sechdrs, me);
-	ret |= module_bug_finalize(hdr, sechdrs, me);
 
 	return ret;
 }
 
 void module_arch_cleanup(struct module *mod)
 {
-	module_bug_cleanup(mod);
 	module_dwarf_cleanup(mod);
 }
diff -urN linux-2.6.36-rc6/arch/um/drivers/net_kern.c linux-2.6.36-rc7/arch/um/drivers/net_kern.c
--- linux-2.6.36-rc6/arch/um/drivers/net_kern.c	2010-10-06 21:33:43.606752958 +0000
+++ linux-2.6.36-rc7/arch/um/drivers/net_kern.c	2010-10-06 21:33:48.594816068 +0000
@@ -255,18 +255,6 @@
 	netif_wake_queue(dev);
 }
 
-static int uml_net_set_mac(struct net_device *dev, void *addr)
-{
-	struct uml_net_private *lp = netdev_priv(dev);
-	struct sockaddr *hwaddr = addr;
-
-	spin_lock_irq(&lp->lock);
-	eth_mac_addr(dev, hwaddr->sa_data);
-	spin_unlock_irq(&lp->lock);
-
-	return 0;
-}
-
 static int uml_net_change_mtu(struct net_device *dev, int new_mtu)
 {
 	dev->mtu = new_mtu;
@@ -373,7 +361,7 @@
 	.ndo_start_xmit 	= uml_net_start_xmit,
 	.ndo_set_multicast_list = uml_net_set_multicast_list,
 	.ndo_tx_timeout 	= uml_net_tx_timeout,
-	.ndo_set_mac_address	= uml_net_set_mac,
+	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_change_mtu 	= uml_net_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 };
@@ -472,7 +460,8 @@
 	    ((*transport->user->init)(&lp->user, dev) != 0))
 		goto out_unregister;
 
-	eth_mac_addr(dev, device->mac);
+	/* don't use eth_mac_addr, it will not work here */
+	memcpy(dev->dev_addr, device->mac, ETH_ALEN);
 	dev->mtu = transport->user->mtu;
 	dev->netdev_ops = &uml_netdev_ops;
 	dev->ethtool_ops = &uml_net_ethtool_ops;
diff -urN linux-2.6.36-rc6/arch/x86/kernel/acpi/cstate.c linux-2.6.36-rc7/arch/x86/kernel/acpi/cstate.c
--- linux-2.6.36-rc6/arch/x86/kernel/acpi/cstate.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/acpi/cstate.c	2010-10-06 21:33:48.607815789 +0000
@@ -61,7 +61,7 @@
 		unsigned int ecx;
 	} states[ACPI_PROCESSOR_MAX_POWER];
 };
-static struct cstate_entry *cpu_cstate_entry;	/* per CPU ptr */
+static struct cstate_entry __percpu *cpu_cstate_entry;	/* per CPU ptr */
 
 static short mwait_supported[ACPI_PROCESSOR_MAX_POWER];
 
diff -urN linux-2.6.36-rc6/arch/x86/kernel/apic/io_apic.c linux-2.6.36-rc7/arch/x86/kernel/apic/io_apic.c
--- linux-2.6.36-rc6/arch/x86/kernel/apic/io_apic.c	2010-10-06 21:33:43.622417553 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/apic/io_apic.c	2010-10-06 21:33:48.609817033 +0000
@@ -306,14 +306,19 @@
 
 	old_cfg = old_desc->chip_data;
 
-	memcpy(cfg, old_cfg, sizeof(struct irq_cfg));
+	cfg->vector = old_cfg->vector;
+	cfg->move_in_progress = old_cfg->move_in_progress;
+	cpumask_copy(cfg->domain, old_cfg->domain);
+	cpumask_copy(cfg->old_domain, old_cfg->old_domain);
 
 	init_copy_irq_2_pin(old_cfg, cfg, node);
 }
 
-static void free_irq_cfg(struct irq_cfg *old_cfg)
+static void free_irq_cfg(struct irq_cfg *cfg)
 {
-	kfree(old_cfg);
+	free_cpumask_var(cfg->domain);
+	free_cpumask_var(cfg->old_domain);
+	kfree(cfg);
 }
 
 void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc)
diff -urN linux-2.6.36-rc6/arch/x86/kernel/cpu/common.c linux-2.6.36-rc7/arch/x86/kernel/cpu/common.c
--- linux-2.6.36-rc6/arch/x86/kernel/cpu/common.c	2010-10-06 21:33:43.624816782 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/cpu/common.c	2010-10-06 21:33:48.612816153 +0000
@@ -545,7 +545,7 @@
 	}
 }
 
-static void __cpuinit get_cpu_cap(struct cpuinfo_x86 *c)
+void __cpuinit get_cpu_cap(struct cpuinfo_x86 *c)
 {
 	u32 tfms, xlvl;
 	u32 ebx;
diff -urN linux-2.6.36-rc6/arch/x86/kernel/cpu/cpu.h linux-2.6.36-rc7/arch/x86/kernel/cpu/cpu.h
--- linux-2.6.36-rc6/arch/x86/kernel/cpu/cpu.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/cpu/cpu.h	2010-10-06 21:33:48.612816153 +0000
@@ -33,5 +33,6 @@
 			    *const __x86_cpu_dev_end[];
 
 extern void cpu_detect_cache_sizes(struct cpuinfo_x86 *c);
+extern void get_cpu_cap(struct cpuinfo_x86 *c);
 
 #endif
diff -urN linux-2.6.36-rc6/arch/x86/kernel/cpu/cpufreq/pcc-cpufreq.c linux-2.6.36-rc7/arch/x86/kernel/cpu/cpufreq/pcc-cpufreq.c
--- linux-2.6.36-rc6/arch/x86/kernel/cpu/cpufreq/pcc-cpufreq.c	2010-10-06 21:33:43.625816702 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/cpu/cpufreq/pcc-cpufreq.c	2010-10-06 21:33:48.613815879 +0000
@@ -368,16 +368,22 @@
 		return -ENODEV;
 
 	out_obj = output.pointer;
-	if (out_obj->type != ACPI_TYPE_BUFFER)
-		return -ENODEV;
+	if (out_obj->type != ACPI_TYPE_BUFFER) {
+		ret = -ENODEV;
+		goto out_free;
+	}
 
 	errors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);
-	if (errors)
-		return -ENODEV;
+	if (errors) {
+		ret = -ENODEV;
+		goto out_free;
+	}
 
 	supported = *((u32 *)(out_obj->buffer.pointer + 4));
-	if (!(supported & 0x1))
-		return -ENODEV;
+	if (!(supported & 0x1)) {
+		ret = -ENODEV;
+		goto out_free;
+	}
 
 out_free:
 	kfree(output.pointer);
diff -urN linux-2.6.36-rc6/arch/x86/kernel/cpu/intel.c linux-2.6.36-rc7/arch/x86/kernel/cpu/intel.c
--- linux-2.6.36-rc6/arch/x86/kernel/cpu/intel.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/cpu/intel.c	2010-10-06 21:33:48.614815807 +0000
@@ -39,6 +39,7 @@
 			misc_enable &= ~MSR_IA32_MISC_ENABLE_LIMIT_CPUID;
 			wrmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
 			c->cpuid_level = cpuid_eax(0);
+			get_cpu_cap(c);
 		}
 	}
 
diff -urN linux-2.6.36-rc6/arch/x86/kernel/cpu/perf_event_p4.c linux-2.6.36-rc7/arch/x86/kernel/cpu/perf_event_p4.c
--- linux-2.6.36-rc6/arch/x86/kernel/cpu/perf_event_p4.c	2010-10-06 21:33:43.629815782 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/cpu/perf_event_p4.c	2010-10-06 21:33:48.617506245 +0000
@@ -660,8 +660,12 @@
 	for (idx = 0; idx < x86_pmu.num_counters; idx++) {
 		int overflow;
 
-		if (!test_bit(idx, cpuc->active_mask))
+		if (!test_bit(idx, cpuc->active_mask)) {
+			/* catch in-flight IRQs */
+			if (__test_and_clear_bit(idx, cpuc->running))
+				handled++;
 			continue;
+		}
 
 		event = cpuc->events[idx];
 		hwc = &event->hw;
diff -urN linux-2.6.36-rc6/arch/x86/kernel/hpet.c linux-2.6.36-rc7/arch/x86/kernel/hpet.c
--- linux-2.6.36-rc6/arch/x86/kernel/hpet.c	2010-10-06 21:33:43.632815797 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/hpet.c	2010-10-06 21:33:48.620815919 +0000
@@ -506,7 +506,7 @@
 {
 	unsigned int irq;
 
-	irq = create_irq();
+	irq = create_irq_nr(0, -1);
 	if (!irq)
 		return -EINVAL;
 
diff -urN linux-2.6.36-rc6/arch/x86/kernel/module.c linux-2.6.36-rc7/arch/x86/kernel/module.c
--- linux-2.6.36-rc6/arch/x86/kernel/module.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/arch/x86/kernel/module.c	2010-10-06 21:33:48.621816004 +0000
@@ -239,11 +239,10 @@
 		apply_paravirt(pseg, pseg + para->sh_size);
 	}
 
-	return module_bug_finalize(hdr, sechdrs, me);
+	return 0;
 }
 
 void module_arch_cleanup(struct module *mod)
 {
 	alternatives_smp_module_del(mod);
-	module_bug_cleanup(mod);
 }
diff -urN linux-2.6.36-rc6/arch/x86/oprofile/nmi_int.c linux-2.6.36-rc7/arch/x86/oprofile/nmi_int.c
--- linux-2.6.36-rc6/arch/x86/oprofile/nmi_int.c	2010-10-06 21:33:43.647799706 +0000
+++ linux-2.6.36-rc7/arch/x86/oprofile/nmi_int.c	2010-10-06 21:33:48.635569695 +0000
@@ -674,6 +674,7 @@
 	case 0x0f:
 	case 0x16:
 	case 0x17:
+	case 0x1d:
 		*cpu_type = "i386/core_2";
 		break;
 	case 0x1a:
diff -urN linux-2.6.36-rc6/arch/x86/xen/time.c linux-2.6.36-rc7/arch/x86/xen/time.c
--- linux-2.6.36-rc6/arch/x86/xen/time.c	2010-10-06 21:33:43.650815885 +0000
+++ linux-2.6.36-rc7/arch/x86/xen/time.c	2010-10-06 21:33:48.638815825 +0000
@@ -489,8 +489,9 @@
 __init void xen_hvm_init_time_ops(void)
 {
 	/* vector callback is needed otherwise we cannot receive interrupts
-	 * on cpu > 0 */
-	if (!xen_have_vector_callback && num_present_cpus() > 1)
+	 * on cpu > 0 and at this point we don't know how many cpus are
+	 * available */
+	if (!xen_have_vector_callback)
 		return;
 	if (!xen_feature(XENFEAT_hvm_safe_pvclock)) {
 		printk(KERN_INFO "Xen doesn't support pvclock on HVM,"
diff -urN linux-2.6.36-rc6/drivers/acpi/Kconfig linux-2.6.36-rc7/drivers/acpi/Kconfig
--- linux-2.6.36-rc6/drivers/acpi/Kconfig	2010-10-06 21:33:43.658815785 +0000
+++ linux-2.6.36-rc7/drivers/acpi/Kconfig	2010-10-06 21:33:48.645815768 +0000
@@ -105,7 +105,7 @@
 
 	  Be aware that using this interface can confuse your Embedded
 	  Controller in a way that a normal reboot is not enough. You then
-	  have to power of your system, and remove the laptop battery for
+	  have to power off your system, and remove the laptop battery for
 	  some seconds.
 	  An Embedded Controller typically is available on laptops and reads
 	  sensor values like battery state and temperature.
diff -urN linux-2.6.36-rc6/drivers/acpi/acpi_pad.c linux-2.6.36-rc7/drivers/acpi/acpi_pad.c
--- linux-2.6.36-rc6/drivers/acpi/acpi_pad.c	2010-10-06 21:33:43.658815785 +0000
+++ linux-2.6.36-rc7/drivers/acpi/acpi_pad.c	2010-10-06 21:33:48.646815760 +0000
@@ -382,31 +382,32 @@
 	device_remove_file(&device->dev, &dev_attr_rrtime);
 }
 
-/* Query firmware how many CPUs should be idle */
-static int acpi_pad_pur(acpi_handle handle, int *num_cpus)
+/*
+ * Query firmware how many CPUs should be idle
+ * return -1 on failure
+ */
+static int acpi_pad_pur(acpi_handle handle)
 {
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object *package;
-	int rev, num, ret = -EINVAL;
+	int num = -1;
 
 	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_PUR", NULL, &buffer)))
-		return -EINVAL;
+		return num;
 
 	if (!buffer.length || !buffer.pointer)
-		return -EINVAL;
+		return num;
 
 	package = buffer.pointer;
-	if (package->type != ACPI_TYPE_PACKAGE || package->package.count != 2)
-		goto out;
-	rev = package->package.elements[0].integer.value;
-	num = package->package.elements[1].integer.value;
-	if (rev != 1 || num < 0)
-		goto out;
-	*num_cpus = num;
-	ret = 0;
-out:
+
+	if (package->type == ACPI_TYPE_PACKAGE &&
+		package->package.count == 2 &&
+		package->package.elements[0].integer.value == 1) /* rev 1 */
+
+		num = package->package.elements[1].integer.value;
+
 	kfree(buffer.pointer);
-	return ret;
+	return num;
 }
 
 /* Notify firmware how many CPUs are idle */
@@ -433,7 +434,8 @@
 	uint32_t idle_cpus;
 
 	mutex_lock(&isolated_cpus_lock);
-	if (acpi_pad_pur(handle, &num_cpus)) {
+	num_cpus = acpi_pad_pur(handle);
+	if (num_cpus < 0) {
 		mutex_unlock(&isolated_cpus_lock);
 		return;
 	}
diff -urN linux-2.6.36-rc6/drivers/acpi/acpica/aclocal.h linux-2.6.36-rc7/drivers/acpi/acpica/aclocal.h
--- linux-2.6.36-rc6/drivers/acpi/acpica/aclocal.h	2010-10-06 21:33:43.658815785 +0000
+++ linux-2.6.36-rc7/drivers/acpi/acpica/aclocal.h	2010-10-06 21:33:48.646815760 +0000
@@ -854,6 +854,7 @@
 	ACPI_BITMASK_POWER_BUTTON_STATUS   | \
 	ACPI_BITMASK_SLEEP_BUTTON_STATUS   | \
 	ACPI_BITMASK_RT_CLOCK_STATUS       | \
+	ACPI_BITMASK_PCIEXP_WAKE_DISABLE   | \
 	ACPI_BITMASK_WAKE_STATUS)
 
 #define ACPI_BITMASK_TIMER_ENABLE               0x0001
diff -urN linux-2.6.36-rc6/drivers/acpi/acpica/exutils.c linux-2.6.36-rc7/drivers/acpi/acpica/exutils.c
--- linux-2.6.36-rc6/drivers/acpi/acpica/exutils.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/acpica/exutils.c	2010-10-06 21:33:48.650815787 +0000
@@ -109,7 +109,7 @@
  *
  * DESCRIPTION: Reacquire the interpreter execution region from within the
  *              interpreter code. Failure to enter the interpreter region is a
- *              fatal system error. Used in  conjuction with
+ *              fatal system error. Used in  conjunction with
  *              relinquish_interpreter
  *
  ******************************************************************************/
diff -urN linux-2.6.36-rc6/drivers/acpi/acpica/rsutils.c linux-2.6.36-rc7/drivers/acpi/acpica/rsutils.c
--- linux-2.6.36-rc6/drivers/acpi/acpica/rsutils.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/acpica/rsutils.c	2010-10-06 21:33:48.652815846 +0000
@@ -149,7 +149,7 @@
 
 			/*
 			 * 16-, 32-, and 64-bit cases must use the move macros that perform
-			 * endian conversion and/or accomodate hardware that cannot perform
+			 * endian conversion and/or accommodate hardware that cannot perform
 			 * misaligned memory transfers
 			 */
 		case ACPI_RSC_MOVE16:
diff -urN linux-2.6.36-rc6/drivers/acpi/apei/Kconfig linux-2.6.36-rc7/drivers/acpi/apei/Kconfig
--- linux-2.6.36-rc6/drivers/acpi/apei/Kconfig	2010-10-06 21:33:43.665815823 +0000
+++ linux-2.6.36-rc7/drivers/acpi/apei/Kconfig	2010-10-06 21:33:48.653815824 +0000
@@ -34,6 +34,6 @@
 	depends on ACPI_APEI
 	help
 	  ERST is a way provided by APEI to save and retrieve hardware
-	  error infomation to and from a persistent store. Enable this
+	  error information to and from a persistent store. Enable this
 	  if you want to debugging and testing the ERST kernel support
 	  and firmware implementation.
diff -urN linux-2.6.36-rc6/drivers/acpi/apei/apei-base.c linux-2.6.36-rc7/drivers/acpi/apei/apei-base.c
--- linux-2.6.36-rc6/drivers/acpi/apei/apei-base.c	2010-10-06 21:33:43.666815912 +0000
+++ linux-2.6.36-rc7/drivers/acpi/apei/apei-base.c	2010-10-06 21:33:48.653815824 +0000
@@ -445,11 +445,15 @@
 int apei_resources_request(struct apei_resources *resources,
 			   const char *desc)
 {
-	struct apei_res *res, *res_bak;
+	struct apei_res *res, *res_bak = NULL;
 	struct resource *r;
+	int rc;
 
-	apei_resources_sub(resources, &apei_resources_all);
+	rc = apei_resources_sub(resources, &apei_resources_all);
+	if (rc)
+		return rc;
 
+	rc = -EINVAL;
 	list_for_each_entry(res, &resources->iomem, list) {
 		r = request_mem_region(res->start, res->end - res->start,
 				       desc);
@@ -475,7 +479,11 @@
 		}
 	}
 
-	apei_resources_merge(&apei_resources_all, resources);
+	rc = apei_resources_merge(&apei_resources_all, resources);
+	if (rc) {
+		pr_err(APEI_PFX "Fail to merge resources!\n");
+		goto err_unmap_ioport;
+	}
 
 	return 0;
 err_unmap_ioport:
@@ -491,12 +499,13 @@
 			break;
 		release_mem_region(res->start, res->end - res->start);
 	}
-	return -EINVAL;
+	return rc;
 }
 EXPORT_SYMBOL_GPL(apei_resources_request);
 
 void apei_resources_release(struct apei_resources *resources)
 {
+	int rc;
 	struct apei_res *res;
 
 	list_for_each_entry(res, &resources->iomem, list)
@@ -504,7 +513,9 @@
 	list_for_each_entry(res, &resources->ioport, list)
 		release_region(res->start, res->end - res->start);
 
-	apei_resources_sub(&apei_resources_all, resources);
+	rc = apei_resources_sub(&apei_resources_all, resources);
+	if (rc)
+		pr_err(APEI_PFX "Fail to sub resources!\n");
 }
 EXPORT_SYMBOL_GPL(apei_resources_release);
 
diff -urN linux-2.6.36-rc6/drivers/acpi/apei/einj.c linux-2.6.36-rc7/drivers/acpi/apei/einj.c
--- linux-2.6.36-rc6/drivers/acpi/apei/einj.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/apei/einj.c	2010-10-06 21:33:48.653815824 +0000
@@ -426,7 +426,9 @@
 
 static int einj_check_table(struct acpi_table_einj *einj_tab)
 {
-	if (einj_tab->header_length != sizeof(struct acpi_table_einj))
+	if ((einj_tab->header_length !=
+	     (sizeof(struct acpi_table_einj) - sizeof(einj_tab->header)))
+	    && (einj_tab->header_length != sizeof(struct acpi_table_einj)))
 		return -EINVAL;
 	if (einj_tab->header.length < sizeof(struct acpi_table_einj))
 		return -EINVAL;
diff -urN linux-2.6.36-rc6/drivers/acpi/apei/erst-dbg.c linux-2.6.36-rc7/drivers/acpi/apei/erst-dbg.c
--- linux-2.6.36-rc6/drivers/acpi/apei/erst-dbg.c	2010-10-06 21:33:43.666815912 +0000
+++ linux-2.6.36-rc7/drivers/acpi/apei/erst-dbg.c	2010-10-06 21:33:48.653815824 +0000
@@ -2,7 +2,7 @@
  * APEI Error Record Serialization Table debug support
  *
  * ERST is a way provided by APEI to save and retrieve hardware error
- * infomation to and from a persistent store. This file provide the
+ * information to and from a persistent store. This file provide the
  * debugging/testing support for ERST kernel support and firmware
  * implementation.
  *
@@ -111,11 +111,13 @@
 		goto out;
 	}
 	if (len > erst_dbg_buf_len) {
-		kfree(erst_dbg_buf);
+		void *p;
 		rc = -ENOMEM;
-		erst_dbg_buf = kmalloc(len, GFP_KERNEL);
-		if (!erst_dbg_buf)
+		p = kmalloc(len, GFP_KERNEL);
+		if (!p)
 			goto out;
+		kfree(erst_dbg_buf);
+		erst_dbg_buf = p;
 		erst_dbg_buf_len = len;
 		goto retry;
 	}
@@ -150,11 +152,13 @@
 	if (mutex_lock_interruptible(&erst_dbg_mutex))
 		return -EINTR;
 	if (usize > erst_dbg_buf_len) {
-		kfree(erst_dbg_buf);
+		void *p;
 		rc = -ENOMEM;
-		erst_dbg_buf = kmalloc(usize, GFP_KERNEL);
-		if (!erst_dbg_buf)
+		p = kmalloc(usize, GFP_KERNEL);
+		if (!p)
 			goto out;
+		kfree(erst_dbg_buf);
+		erst_dbg_buf = p;
 		erst_dbg_buf_len = usize;
 	}
 	rc = copy_from_user(erst_dbg_buf, ubuf, usize);
diff -urN linux-2.6.36-rc6/drivers/acpi/apei/erst.c linux-2.6.36-rc7/drivers/acpi/apei/erst.c
--- linux-2.6.36-rc6/drivers/acpi/apei/erst.c	2010-10-06 21:33:43.666815912 +0000
+++ linux-2.6.36-rc7/drivers/acpi/apei/erst.c	2010-10-06 21:33:48.654815785 +0000
@@ -2,7 +2,7 @@
  * APEI Error Record Serialization Table support
  *
  * ERST is a way provided by APEI to save and retrieve hardware error
- * infomation to and from a persistent store.
+ * information to and from a persistent store.
  *
  * For more information about ERST, please refer to ACPI Specification
  * version 4.0, section 17.4.
@@ -266,13 +266,30 @@
 {
 	int rc;
 	u64 offset;
+	void *src, *dst;
+
+	/* ioremap does not work in interrupt context */
+	if (in_interrupt()) {
+		pr_warning(ERST_PFX
+			   "MOVE_DATA can not be used in interrupt context");
+		return -EBUSY;
+	}
 
 	rc = __apei_exec_read_register(entry, &offset);
 	if (rc)
 		return rc;
-	memmove((void *)ctx->dst_base + offset,
-		(void *)ctx->src_base + offset,
-		ctx->var2);
+
+	src = ioremap(ctx->src_base + offset, ctx->var2);
+	if (!src)
+		return -ENOMEM;
+	dst = ioremap(ctx->dst_base + offset, ctx->var2);
+	if (!dst)
+		return -ENOMEM;
+
+	memmove(dst, src, ctx->var2);
+
+	iounmap(src);
+	iounmap(dst);
 
 	return 0;
 }
@@ -750,7 +767,9 @@
 
 static int erst_check_table(struct acpi_table_erst *erst_tab)
 {
-	if (erst_tab->header_length != sizeof(struct acpi_table_erst))
+	if ((erst_tab->header_length !=
+	     (sizeof(struct acpi_table_erst) - sizeof(erst_tab->header)))
+	    && (erst_tab->header_length != sizeof(struct acpi_table_einj)))
 		return -EINVAL;
 	if (erst_tab->header.length < sizeof(struct acpi_table_erst))
 		return -EINVAL;
diff -urN linux-2.6.36-rc6/drivers/acpi/apei/ghes.c linux-2.6.36-rc7/drivers/acpi/apei/ghes.c
--- linux-2.6.36-rc6/drivers/acpi/apei/ghes.c	2010-10-06 21:33:43.666815912 +0000
+++ linux-2.6.36-rc7/drivers/acpi/apei/ghes.c	2010-10-06 21:33:48.654815785 +0000
@@ -302,7 +302,7 @@
 	struct ghes *ghes = NULL;
 	int rc = -EINVAL;
 
-	generic = ghes_dev->dev.platform_data;
+	generic = *(struct acpi_hest_generic **)ghes_dev->dev.platform_data;
 	if (!generic->enabled)
 		return -ENODEV;
 
diff -urN linux-2.6.36-rc6/drivers/acpi/apei/hest.c linux-2.6.36-rc7/drivers/acpi/apei/hest.c
--- linux-2.6.36-rc6/drivers/acpi/apei/hest.c	2010-10-06 21:33:43.666815912 +0000
+++ linux-2.6.36-rc7/drivers/acpi/apei/hest.c	2010-10-06 21:33:48.654815785 +0000
@@ -137,20 +137,23 @@
 
 static int hest_parse_ghes(struct acpi_hest_header *hest_hdr, void *data)
 {
-	struct acpi_hest_generic *generic;
 	struct platform_device *ghes_dev;
 	struct ghes_arr *ghes_arr = data;
 	int rc;
 
 	if (hest_hdr->type != ACPI_HEST_TYPE_GENERIC_ERROR)
 		return 0;
-	generic = (struct acpi_hest_generic *)hest_hdr;
-	if (!generic->enabled)
+
+	if (!((struct acpi_hest_generic *)hest_hdr)->enabled)
 		return 0;
 	ghes_dev = platform_device_alloc("GHES", hest_hdr->source_id);
 	if (!ghes_dev)
 		return -ENOMEM;
-	ghes_dev->dev.platform_data = generic;
+
+	rc = platform_device_add_data(ghes_dev, &hest_hdr, sizeof(void *));
+	if (rc)
+		goto err;
+
 	rc = platform_device_add(ghes_dev);
 	if (rc)
 		goto err;
diff -urN linux-2.6.36-rc6/drivers/acpi/atomicio.c linux-2.6.36-rc7/drivers/acpi/atomicio.c
--- linux-2.6.36-rc6/drivers/acpi/atomicio.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/atomicio.c	2010-10-06 21:33:48.654815785 +0000
@@ -142,7 +142,7 @@
 	list_add_tail_rcu(&map->list, &acpi_iomaps);
 	spin_unlock_irqrestore(&acpi_iomaps_lock, flags);
 
-	return vaddr + (paddr - pg_off);
+	return map->vaddr + (paddr - map->paddr);
 err_unmap:
 	iounmap(vaddr);
 	return NULL;
diff -urN linux-2.6.36-rc6/drivers/acpi/battery.c linux-2.6.36-rc7/drivers/acpi/battery.c
--- linux-2.6.36-rc6/drivers/acpi/battery.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/battery.c	2010-10-06 21:33:48.654815785 +0000
@@ -273,7 +273,6 @@
 	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-	POWER_SUPPLY_PROP_CURRENT_NOW,
 	POWER_SUPPLY_PROP_POWER_NOW,
 	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
 	POWER_SUPPLY_PROP_ENERGY_FULL,
diff -urN linux-2.6.36-rc6/drivers/acpi/blacklist.c linux-2.6.36-rc7/drivers/acpi/blacklist.c
--- linux-2.6.36-rc6/drivers/acpi/blacklist.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/blacklist.c	2010-10-06 21:33:48.654815785 +0000
@@ -183,6 +183,8 @@
 {
 	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
 	acpi_osi_setup("!Windows 2006");
+	acpi_osi_setup("!Windows 2006 SP1");
+	acpi_osi_setup("!Windows 2006 SP2");
 	return 0;
 }
 static int __init dmi_disable_osi_win7(const struct dmi_system_id *d)
@@ -226,6 +228,14 @@
 		},
 	},
 	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Toshiba Satellite L355",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "Satellite L355"),
+		},
+	},
+	{
 	.callback = dmi_disable_osi_win7,
 	.ident = "ASUS K50IJ",
 	.matches = {
@@ -233,6 +243,14 @@
 		     DMI_MATCH(DMI_PRODUCT_NAME, "K50IJ"),
 		},
 	},
+	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "Toshiba P305D",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "Satellite P305D"),
+		},
+	},
 
 	/*
 	 * BIOS invocation of _OSI(Linux) is almost always a BIOS bug.
diff -urN linux-2.6.36-rc6/drivers/acpi/bus.c linux-2.6.36-rc7/drivers/acpi/bus.c
--- linux-2.6.36-rc6/drivers/acpi/bus.c	2010-10-06 21:33:43.666815912 +0000
+++ linux-2.6.36-rc7/drivers/acpi/bus.c	2010-10-06 21:33:48.655815795 +0000
@@ -55,7 +55,7 @@
 static int set_power_nocheck(const struct dmi_system_id *id)
 {
 	printk(KERN_NOTICE PREFIX "%s detected - "
-		"disable power check in power transistion\n", id->ident);
+		"disable power check in power transition\n", id->ident);
 	acpi_power_nocheck = 1;
 	return 0;
 }
@@ -80,23 +80,15 @@
 
 static struct dmi_system_id dsdt_dmi_table[] __initdata = {
 	/*
-	 * Insyde BIOS on some TOSHIBA machines corrupt the DSDT.
+	 * Invoke DSDT corruption work-around on all Toshiba Satellite.
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
 	 */
 	{
 	 .callback = set_copy_dsdt,
-	 .ident = "TOSHIBA Satellite A505",
+	 .ident = "TOSHIBA Satellite",
 	 .matches = {
 		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite A505"),
-		},
-	},
-	{
-	 .callback = set_copy_dsdt,
-	 .ident = "TOSHIBA Satellite L505D",
-	 .matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite L505D"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Satellite"),
 		},
 	},
 	{}
@@ -1027,7 +1019,7 @@
 
 	/*
 	 * If the laptop falls into the DMI check table, the power state check
-	 * will be disabled in the course of device power transistion.
+	 * will be disabled in the course of device power transition.
 	 */
 	dmi_check_system(power_nocheck_dmi_table);
 
diff -urN linux-2.6.36-rc6/drivers/acpi/fan.c linux-2.6.36-rc7/drivers/acpi/fan.c
--- linux-2.6.36-rc6/drivers/acpi/fan.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/fan.c	2010-10-06 21:33:48.656815965 +0000
@@ -369,7 +369,9 @@
 
 	acpi_bus_unregister_driver(&acpi_fan_driver);
 
+#ifdef CONFIG_ACPI_PROCFS
 	remove_proc_entry(ACPI_FAN_CLASS, acpi_root_dir);
+#endif
 
 	return;
 }
diff -urN linux-2.6.36-rc6/drivers/acpi/processor_core.c linux-2.6.36-rc7/drivers/acpi/processor_core.c
--- linux-2.6.36-rc6/drivers/acpi/processor_core.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/processor_core.c	2010-10-06 21:33:48.658815765 +0000
@@ -29,12 +29,6 @@
 
 static struct dmi_system_id __cpuinitdata processor_idle_dmi_table[] = {
 	{
-	set_no_mwait, "IFL91 board", {
-	DMI_MATCH(DMI_BIOS_VENDOR, "COMPAL"),
-	DMI_MATCH(DMI_SYS_VENDOR, "ZEPTO"),
-	DMI_MATCH(DMI_PRODUCT_VERSION, "3215W"),
-	DMI_MATCH(DMI_BOARD_NAME, "IFL91") }, NULL},
-	{
 	set_no_mwait, "Extensa 5220", {
 	DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies LTD"),
 	DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
diff -urN linux-2.6.36-rc6/drivers/acpi/processor_driver.c linux-2.6.36-rc7/drivers/acpi/processor_driver.c
--- linux-2.6.36-rc6/drivers/acpi/processor_driver.c	2010-10-06 21:33:43.670997669 +0000
+++ linux-2.6.36-rc7/drivers/acpi/processor_driver.c	2010-10-06 21:33:48.658815765 +0000
@@ -850,7 +850,7 @@
 		printk(KERN_DEBUG "ACPI: %s registered with cpuidle\n",
 			acpi_idle_driver.name);
 	} else {
-		printk(KERN_DEBUG "ACPI: acpi_idle yielding to %s",
+		printk(KERN_DEBUG "ACPI: acpi_idle yielding to %s\n",
 			cpuidle_get_driver()->name);
 	}
 
diff -urN linux-2.6.36-rc6/drivers/acpi/processor_perflib.c linux-2.6.36-rc7/drivers/acpi/processor_perflib.c
--- linux-2.6.36-rc6/drivers/acpi/processor_perflib.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/processor_perflib.c	2010-10-06 21:33:48.658815765 +0000
@@ -447,8 +447,8 @@
 	if (!try_module_get(calling_module))
 		return -EINVAL;
 
-	/* is_done is set to negative if an error occured,
-	 * and to postitive if _no_ error occured, but SMM
+	/* is_done is set to negative if an error occurred,
+	 * and to postitive if _no_ error occurred, but SMM
 	 * was already notified. This avoids double notification
 	 * which might lead to unexpected results...
 	 */
diff -urN linux-2.6.36-rc6/drivers/acpi/sleep.c linux-2.6.36-rc7/drivers/acpi/sleep.c
--- linux-2.6.36-rc6/drivers/acpi/sleep.c	2010-10-06 21:33:43.671815790 +0000
+++ linux-2.6.36-rc7/drivers/acpi/sleep.c	2010-10-06 21:33:48.659815776 +0000
@@ -363,6 +363,12 @@
 	return 0;
 }
 
+static int __init init_nvs_nosave(const struct dmi_system_id *d)
+{
+	acpi_nvs_nosave();
+	return 0;
+}
+
 static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	{
 	.callback = init_old_suspend_ordering,
@@ -397,6 +403,22 @@
 		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
 		},
 	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Sony Vaio VGN-SR11M",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR11M"),
+		},
+	},
+	{
+	.callback = init_nvs_nosave,
+	.ident = "Everex StepNote Series",
+	.matches = {
+		DMI_MATCH(DMI_SYS_VENDOR, "Everex Systems, Inc."),
+		DMI_MATCH(DMI_PRODUCT_NAME, "Everex StepNote Series"),
+		},
+	},
 	{},
 };
 #endif /* CONFIG_SUSPEND */
diff -urN linux-2.6.36-rc6/drivers/acpi/sysfs.c linux-2.6.36-rc7/drivers/acpi/sysfs.c
--- linux-2.6.36-rc6/drivers/acpi/sysfs.c	2010-10-06 21:33:43.672815778 +0000
+++ linux-2.6.36-rc7/drivers/acpi/sysfs.c	2010-10-06 21:33:48.660815803 +0000
@@ -100,7 +100,7 @@
 	ACPI_DEBUG_INIT(ACPI_LV_EVENTS),
 };
 
-static int param_get_debug_layer(char *buffer, struct kernel_param *kp)
+static int param_get_debug_layer(char *buffer, const struct kernel_param *kp)
 {
 	int result = 0;
 	int i;
@@ -128,7 +128,7 @@
 	return result;
 }
 
-static int param_get_debug_level(char *buffer, struct kernel_param *kp)
+static int param_get_debug_level(char *buffer, const struct kernel_param *kp)
 {
 	int result = 0;
 	int i;
@@ -149,10 +149,18 @@
 	return result;
 }
 
-module_param_call(debug_layer, param_set_uint, param_get_debug_layer,
-		  &acpi_dbg_layer, 0644);
-module_param_call(debug_level, param_set_uint, param_get_debug_level,
-		  &acpi_dbg_level, 0644);
+static struct kernel_param_ops param_ops_debug_layer = {
+	.set = param_set_uint,
+	.get = param_get_debug_layer,
+};
+
+static struct kernel_param_ops param_ops_debug_level = {
+	.set = param_set_uint,
+	.get = param_get_debug_level,
+};
+
+module_param_cb(debug_layer, &param_ops_debug_layer, &acpi_dbg_layer, 0644);
+module_param_cb(debug_level, &param_ops_debug_level, &acpi_dbg_level, 0644);
 
 static char trace_method_name[6];
 module_param_string(trace_method_name, trace_method_name, 6, 0644);
diff -urN linux-2.6.36-rc6/drivers/acpi/video_detect.c linux-2.6.36-rc7/drivers/acpi/video_detect.c
--- linux-2.6.36-rc6/drivers/acpi/video_detect.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/acpi/video_detect.c	2010-10-06 21:33:48.661815982 +0000
@@ -59,8 +59,8 @@
 				  "support\n"));
 		*cap |= ACPI_VIDEO_BACKLIGHT;
 		if (ACPI_FAILURE(acpi_get_handle(handle, "_BQC", &h_dummy)))
-			printk(KERN_WARNING FW_BUG PREFIX "ACPI brightness "
-					"control misses _BQC function\n");
+			printk(KERN_WARNING FW_BUG PREFIX "No _BQC method, "
+				"cannot determine initial brightness\n");
 		/* We have backlight support, no need to scan further */
 		return AE_CTRL_TERMINATE;
 	}
diff -urN linux-2.6.36-rc6/drivers/cpuidle/governors/menu.c linux-2.6.36-rc7/drivers/cpuidle/governors/menu.c
--- linux-2.6.36-rc6/drivers/cpuidle/governors/menu.c	2010-10-06 21:33:43.735815967 +0000
+++ linux-2.6.36-rc7/drivers/cpuidle/governors/menu.c	2010-10-06 21:33:48.720815817 +0000
@@ -80,7 +80,7 @@
  * Limiting Performance Impact
  * ---------------------------
  * C states, especially those with large exit latencies, can have a real
- * noticable impact on workloads, which is not acceptable for most sysadmins,
+ * noticeable impact on workloads, which is not acceptable for most sysadmins,
  * and in addition, less performance has a power price of its own.
  *
  * As a general rule of thumb, menu assumes that the following heuristic
diff -urN linux-2.6.36-rc6/drivers/dma/shdma.c linux-2.6.36-rc7/drivers/dma/shdma.c
--- linux-2.6.36-rc6/drivers/dma/shdma.c	2010-10-06 21:33:43.743815809 +0000
+++ linux-2.6.36-rc7/drivers/dma/shdma.c	2010-10-06 21:33:48.727815828 +0000
@@ -580,7 +580,6 @@
 
 	sh_chan = to_sh_chan(chan);
 	param = chan->private;
-	slave_addr = param->config->addr;
 
 	/* Someone calling slave DMA on a public channel? */
 	if (!param || !sg_len) {
@@ -589,6 +588,8 @@
 		return NULL;
 	}
 
+	slave_addr = param->config->addr;
+
 	/*
 	 * if (param != NULL), this is a successfully requested slave channel,
 	 * therefore param->config != NULL too.
diff -urN linux-2.6.36-rc6/drivers/edac/i7core_edac.c linux-2.6.36-rc7/drivers/edac/i7core_edac.c
--- linux-2.6.36-rc6/drivers/edac/i7core_edac.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/edac/i7core_edac.c	2010-10-06 21:33:48.732382091 +0000
@@ -1140,6 +1140,7 @@
 	ATTR_COUNTER(0),
 	ATTR_COUNTER(1),
 	ATTR_COUNTER(2),
+	{ .attr = { .name = NULL } }
 };
 
 static struct mcidev_sysfs_group i7core_udimm_counters = {
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/drm_gem.c linux-2.6.36-rc7/drivers/gpu/drm/drm_gem.c
--- linux-2.6.36-rc6/drivers/gpu/drm/drm_gem.c	2010-10-06 21:33:43.759815747 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/drm_gem.c	2010-10-06 21:33:48.743815809 +0000
@@ -148,7 +148,7 @@
 		return -ENOMEM;
 
 	kref_init(&obj->refcount);
-	kref_init(&obj->handlecount);
+	atomic_set(&obj->handle_count, 0);
 	obj->size = size;
 
 	atomic_inc(&dev->object_count);
@@ -462,28 +462,6 @@
 }
 EXPORT_SYMBOL(drm_gem_object_free);
 
-/**
- * Called after the last reference to the object has been lost.
- * Must be called without holding struct_mutex
- *
- * Frees the object
- */
-void
-drm_gem_object_free_unlocked(struct kref *kref)
-{
-	struct drm_gem_object *obj = (struct drm_gem_object *) kref;
-	struct drm_device *dev = obj->dev;
-
-	if (dev->driver->gem_free_object_unlocked != NULL)
-		dev->driver->gem_free_object_unlocked(obj);
-	else if (dev->driver->gem_free_object != NULL) {
-		mutex_lock(&dev->struct_mutex);
-		dev->driver->gem_free_object(obj);
-		mutex_unlock(&dev->struct_mutex);
-	}
-}
-EXPORT_SYMBOL(drm_gem_object_free_unlocked);
-
 static void drm_gem_object_ref_bug(struct kref *list_kref)
 {
 	BUG();
@@ -496,12 +474,8 @@
  * called before drm_gem_object_free or we'll be touching
  * freed memory
  */
-void
-drm_gem_object_handle_free(struct kref *kref)
+void drm_gem_object_handle_free(struct drm_gem_object *obj)
 {
-	struct drm_gem_object *obj = container_of(kref,
-						  struct drm_gem_object,
-						  handlecount);
 	struct drm_device *dev = obj->dev;
 
 	/* Remove any name for this object */
@@ -528,6 +502,10 @@
 	struct drm_gem_object *obj = vma->vm_private_data;
 
 	drm_gem_object_reference(obj);
+
+	mutex_lock(&obj->dev->struct_mutex);
+	drm_vm_open_locked(vma);
+	mutex_unlock(&obj->dev->struct_mutex);
 }
 EXPORT_SYMBOL(drm_gem_vm_open);
 
@@ -535,7 +513,10 @@
 {
 	struct drm_gem_object *obj = vma->vm_private_data;
 
-	drm_gem_object_unreference_unlocked(obj);
+	mutex_lock(&obj->dev->struct_mutex);
+	drm_vm_close_locked(vma);
+	drm_gem_object_unreference(obj);
+	mutex_unlock(&obj->dev->struct_mutex);
 }
 EXPORT_SYMBOL(drm_gem_vm_close);
 
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/drm_info.c linux-2.6.36-rc7/drivers/gpu/drm/drm_info.c
--- linux-2.6.36-rc6/drivers/gpu/drm/drm_info.c	2010-10-06 21:33:43.759815747 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/drm_info.c	2010-10-06 21:33:48.744380674 +0000
@@ -255,7 +255,7 @@
 
 	seq_printf(m, "%6d %8zd %7d %8d\n",
 		   obj->name, obj->size,
-		   atomic_read(&obj->handlecount.refcount),
+		   atomic_read(&obj->handle_count),
 		   atomic_read(&obj->refcount.refcount));
 	return 0;
 }
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/drm_vm.c linux-2.6.36-rc7/drivers/gpu/drm/drm_vm.c
--- linux-2.6.36-rc6/drivers/gpu/drm/drm_vm.c	2010-10-06 21:33:43.761815795 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/drm_vm.c	2010-10-06 21:33:48.745679829 +0000
@@ -433,15 +433,7 @@
 	mutex_unlock(&dev->struct_mutex);
 }
 
-/**
- * \c close method for all virtual memory types.
- *
- * \param vma virtual memory area.
- *
- * Search the \p vma private data entry in drm_device::vmalist, unlink it, and
- * free it.
- */
-static void drm_vm_close(struct vm_area_struct *vma)
+void drm_vm_close_locked(struct vm_area_struct *vma)
 {
 	struct drm_file *priv = vma->vm_file->private_data;
 	struct drm_device *dev = priv->minor->dev;
@@ -451,7 +443,6 @@
 		  vma->vm_start, vma->vm_end - vma->vm_start);
 	atomic_dec(&dev->vma_count);
 
-	mutex_lock(&dev->struct_mutex);
 	list_for_each_entry_safe(pt, temp, &dev->vmalist, head) {
 		if (pt->vma == vma) {
 			list_del(&pt->head);
@@ -459,6 +450,23 @@
 			break;
 		}
 	}
+}
+
+/**
+ * \c close method for all virtual memory types.
+ *
+ * \param vma virtual memory area.
+ *
+ * Search the \p vma private data entry in drm_device::vmalist, unlink it, and
+ * free it.
+ */
+static void drm_vm_close(struct vm_area_struct *vma)
+{
+	struct drm_file *priv = vma->vm_file->private_data;
+	struct drm_device *dev = priv->minor->dev;
+
+	mutex_lock(&dev->struct_mutex);
+	drm_vm_close_locked(vma);
 	mutex_unlock(&dev->struct_mutex);
 }
 
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i810/i810_dma.c linux-2.6.36-rc7/drivers/gpu/drm/i810/i810_dma.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i810/i810_dma.c	2010-10-06 21:33:43.762815779 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i810/i810_dma.c	2010-10-06 21:33:48.747394133 +0000
@@ -116,7 +116,7 @@
 static const struct file_operations i810_buffer_fops = {
 	.open = drm_open,
 	.release = drm_release,
-	.unlocked_ioctl = drm_ioctl,
+	.unlocked_ioctl = i810_ioctl,
 	.mmap = i810_mmap_buffers,
 	.fasync = drm_fasync,
 };
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i830/i830_dma.c linux-2.6.36-rc7/drivers/gpu/drm/i830/i830_dma.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i830/i830_dma.c	2010-10-06 21:33:43.763815767 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i830/i830_dma.c	2010-10-06 21:33:48.747394133 +0000
@@ -118,7 +118,7 @@
 static const struct file_operations i830_buffer_fops = {
 	.open = drm_open,
 	.release = drm_release,
-	.unlocked_ioctl = drm_ioctl,
+	.unlocked_ioctl = i830_ioctl,
 	.mmap = i830_mmap_buffers,
 	.fasync = drm_fasync,
 };
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i915/i915_dma.c linux-2.6.36-rc7/drivers/gpu/drm/i915/i915_dma.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i915/i915_dma.c	2010-10-06 21:33:43.764815774 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i915/i915_dma.c	2010-10-06 21:33:48.748815792 +0000
@@ -1787,9 +1787,9 @@
 		}
 	}
 
-	div_u64(diff, diff1);
+	diff = div_u64(diff, diff1);
 	ret = ((m * diff) + c);
-	div_u64(ret, 10);
+	ret = div_u64(ret, 10);
 
 	dev_priv->last_count1 = total_count;
 	dev_priv->last_time1 = now;
@@ -1858,7 +1858,7 @@
 
 	/* More magic constants... */
 	diff = diff * 1181;
-	div_u64(diff, diffms * 10);
+	diff = div_u64(diff, diffms * 10);
 	dev_priv->gfx_power = diff;
 }
 
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i915/i915_gem.c linux-2.6.36-rc7/drivers/gpu/drm/i915/i915_gem.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i915/i915_gem.c	2010-10-06 21:33:43.766404573 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i915/i915_gem.c	2010-10-06 21:33:48.750815834 +0000
@@ -136,14 +136,12 @@
 		return -ENOMEM;
 
 	ret = drm_gem_handle_create(file_priv, obj, &handle);
+	/* drop reference from allocate - handle holds it now */
+	drm_gem_object_unreference_unlocked(obj);
 	if (ret) {
-		drm_gem_object_unreference_unlocked(obj);
 		return ret;
 	}
 
-	/* Sink the floating reference from kref_init(handlecount) */
-	drm_gem_object_handle_unreference_unlocked(obj);
-
 	args->handle = handle;
 	return 0;
 }
@@ -471,14 +469,17 @@
 		return -ENOENT;
 	obj_priv = to_intel_bo(obj);
 
-	/* Bounds check source.
-	 *
-	 * XXX: This could use review for overflow issues...
-	 */
-	if (args->offset > obj->size || args->size > obj->size ||
-	    args->offset + args->size > obj->size) {
-		drm_gem_object_unreference_unlocked(obj);
-		return -EINVAL;
+	/* Bounds check source.  */
+	if (args->offset > obj->size || args->size > obj->size - args->offset) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (!access_ok(VERIFY_WRITE,
+		       (char __user *)(uintptr_t)args->data_ptr,
+		       args->size)) {
+		ret = -EFAULT;
+		goto err;
 	}
 
 	if (i915_gem_object_needs_bit17_swizzle(obj)) {
@@ -490,8 +491,8 @@
 							file_priv);
 	}
 
+err:
 	drm_gem_object_unreference_unlocked(obj);
-
 	return ret;
 }
 
@@ -580,8 +581,6 @@
 
 	user_data = (char __user *) (uintptr_t) args->data_ptr;
 	remain = args->size;
-	if (!access_ok(VERIFY_READ, user_data, remain))
-		return -EFAULT;
 
 
 	mutex_lock(&dev->struct_mutex);
@@ -934,14 +933,17 @@
 		return -ENOENT;
 	obj_priv = to_intel_bo(obj);
 
-	/* Bounds check destination.
-	 *
-	 * XXX: This could use review for overflow issues...
-	 */
-	if (args->offset > obj->size || args->size > obj->size ||
-	    args->offset + args->size > obj->size) {
-		drm_gem_object_unreference_unlocked(obj);
-		return -EINVAL;
+	/* Bounds check destination. */
+	if (args->offset > obj->size || args->size > obj->size - args->offset) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (!access_ok(VERIFY_READ,
+		       (char __user *)(uintptr_t)args->data_ptr,
+		       args->size)) {
+		ret = -EFAULT;
+		goto err;
 	}
 
 	/* We can only do the GTT pwrite on untiled buffers, as otherwise
@@ -975,8 +977,8 @@
 		DRM_INFO("pwrite failed %d\n", ret);
 #endif
 
+err:
 	drm_gem_object_unreference_unlocked(obj);
-
 	return ret;
 }
 
@@ -3258,6 +3260,8 @@
 				  (int) reloc->offset,
 				  reloc->read_domains,
 				  reloc->write_domain);
+			drm_gem_object_unreference(target_obj);
+			i915_gem_object_unpin(obj);
 			return -EINVAL;
 		}
 		if (reloc->write_domain & I915_GEM_DOMAIN_CPU ||
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i915/i915_gem_evict.c linux-2.6.36-rc7/drivers/gpu/drm/i915/i915_gem_evict.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i915/i915_gem_evict.c	2010-10-06 21:33:43.767815746 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i915/i915_gem_evict.c	2010-10-06 21:33:48.751815780 +0000
@@ -93,7 +93,7 @@
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	struct list_head eviction_list, unwind_list;
-	struct drm_i915_gem_object *obj_priv, *tmp_obj_priv;
+	struct drm_i915_gem_object *obj_priv;
 	struct list_head *render_iter, *bsd_iter;
 	int ret = 0;
 
@@ -175,39 +175,34 @@
 	return -ENOSPC;
 
 found:
+	/* drm_mm doesn't allow any other other operations while
+	 * scanning, therefore store to be evicted objects on a
+	 * temporary list. */
 	INIT_LIST_HEAD(&eviction_list);
-	list_for_each_entry_safe(obj_priv, tmp_obj_priv,
-				 &unwind_list, evict_list) {
+	while (!list_empty(&unwind_list)) {
+		obj_priv = list_first_entry(&unwind_list,
+					    struct drm_i915_gem_object,
+					    evict_list);
 		if (drm_mm_scan_remove_block(obj_priv->gtt_space)) {
-			/* drm_mm doesn't allow any other other operations while
-			 * scanning, therefore store to be evicted objects on a
-			 * temporary list. */
 			list_move(&obj_priv->evict_list, &eviction_list);
-		} else
-			drm_gem_object_unreference(&obj_priv->base);
+			continue;
+		}
+		list_del(&obj_priv->evict_list);
+		drm_gem_object_unreference(&obj_priv->base);
 	}
 
 	/* Unbinding will emit any required flushes */
-	list_for_each_entry_safe(obj_priv, tmp_obj_priv,
-				 &eviction_list, evict_list) {
-#if WATCH_LRU
-		DRM_INFO("%s: evicting %p\n", __func__, &obj_priv->base);
-#endif
-		ret = i915_gem_object_unbind(&obj_priv->base);
-		if (ret)
-			return ret;
-
+	while (!list_empty(&eviction_list)) {
+		obj_priv = list_first_entry(&eviction_list,
+					    struct drm_i915_gem_object,
+					    evict_list);
+		if (ret == 0)
+			ret = i915_gem_object_unbind(&obj_priv->base);
+		list_del(&obj_priv->evict_list);
 		drm_gem_object_unreference(&obj_priv->base);
 	}
 
-	/* The just created free hole should be on the top of the free stack
-	 * maintained by drm_mm, so this BUG_ON actually executes in O(1).
-	 * Furthermore all accessed data has just recently been used, so it
-	 * should be really fast, too. */
-	BUG_ON(!drm_mm_search_free(&dev_priv->mm.gtt_space, min_size,
-				   alignment, 0));
-
-	return 0;
+	return ret;
 }
 
 int
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_display.c linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_display.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_display.c	2010-10-06 21:33:43.771815736 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_display.c	2010-10-06 21:33:48.755815688 +0000
@@ -1013,8 +1013,8 @@
 		DRM_DEBUG_KMS("vblank wait timed out\n");
 }
 
-/**
- * intel_wait_for_vblank_off - wait for vblank after disabling a pipe
+/*
+ * intel_wait_for_pipe_off - wait for pipe to turn off
  * @dev: drm device
  * @pipe: pipe to wait for
  *
@@ -1022,25 +1022,39 @@
  * spinning on the vblank interrupt status bit, since we won't actually
  * see an interrupt when the pipe is disabled.
  *
- * So this function waits for the display line value to settle (it
- * usually ends up stopping at the start of the next frame).
+ * On Gen4 and above:
+ *   wait for the pipe register state bit to turn off
+ *
+ * Otherwise:
+ *   wait for the display line value to settle (it usually
+ *   ends up stopping at the start of the next frame).
+ *  
  */
-void intel_wait_for_vblank_off(struct drm_device *dev, int pipe)
+static void intel_wait_for_pipe_off(struct drm_device *dev, int pipe)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	int pipedsl_reg = (pipe == 0 ? PIPEADSL : PIPEBDSL);
-	unsigned long timeout = jiffies + msecs_to_jiffies(100);
-	u32 last_line;
 
-	/* Wait for the display line to settle */
-	do {
-		last_line = I915_READ(pipedsl_reg) & DSL_LINEMASK;
-		mdelay(5);
-	} while (((I915_READ(pipedsl_reg) & DSL_LINEMASK) != last_line) &&
-		 time_after(timeout, jiffies));
+	if (INTEL_INFO(dev)->gen >= 4) {
+		int pipeconf_reg = (pipe == 0 ? PIPEACONF : PIPEBCONF);
 
-	if (time_after(jiffies, timeout))
-		DRM_DEBUG_KMS("vblank wait timed out\n");
+		/* Wait for the Pipe State to go off */
+		if (wait_for((I915_READ(pipeconf_reg) & I965_PIPECONF_ACTIVE) == 0,
+			     100, 0))
+			DRM_DEBUG_KMS("pipe_off wait timed out\n");
+	} else {
+		u32 last_line;
+		int pipedsl_reg = (pipe == 0 ? PIPEADSL : PIPEBDSL);
+		unsigned long timeout = jiffies + msecs_to_jiffies(100);
+
+		/* Wait for the display line to settle */
+		do {
+			last_line = I915_READ(pipedsl_reg) & DSL_LINEMASK;
+			mdelay(5);
+		} while (((I915_READ(pipedsl_reg) & DSL_LINEMASK) != last_line) &&
+			 time_after(timeout, jiffies));
+		if (time_after(jiffies, timeout))
+			DRM_DEBUG_KMS("pipe_off wait timed out\n");
+	}
 }
 
 /* Parameters have changed, update FBC info */
@@ -2328,13 +2342,13 @@
 			I915_READ(dspbase_reg);
 		}
 
-		/* Wait for vblank for the disable to take effect */
-		intel_wait_for_vblank_off(dev, pipe);
-
 		/* Don't disable pipe A or pipe A PLLs if needed */
 		if (pipeconf_reg == PIPEACONF &&
-		    (dev_priv->quirks & QUIRK_PIPEA_FORCE))
+		    (dev_priv->quirks & QUIRK_PIPEA_FORCE)) {
+			/* Wait for vblank for the disable to take effect */
+			intel_wait_for_vblank(dev, pipe);
 			goto skip_pipe_off;
+		}
 
 		/* Next, disable display pipes */
 		temp = I915_READ(pipeconf_reg);
@@ -2343,8 +2357,8 @@
 			I915_READ(pipeconf_reg);
 		}
 
-		/* Wait for vblank for the disable to take effect. */
-		intel_wait_for_vblank_off(dev, pipe);
+		/* Wait for the pipe to turn off */
+		intel_wait_for_pipe_off(dev, pipe);
 
 		temp = I915_READ(dpll_reg);
 		if ((temp & DPLL_VCO_ENABLE) != 0) {
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_dp.c linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_dp.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_dp.c	2010-10-06 21:33:43.772815811 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_dp.c	2010-10-06 21:33:48.756815779 +0000
@@ -1138,18 +1138,14 @@
 intel_dp_set_link_train(struct intel_dp *intel_dp,
 			uint32_t dp_reg_value,
 			uint8_t dp_train_pat,
-			uint8_t train_set[4],
-			bool first)
+			uint8_t train_set[4])
 {
 	struct drm_device *dev = intel_dp->base.enc.dev;
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct intel_crtc *intel_crtc = to_intel_crtc(intel_dp->base.enc.crtc);
 	int ret;
 
 	I915_WRITE(intel_dp->output_reg, dp_reg_value);
 	POSTING_READ(intel_dp->output_reg);
-	if (first)
-		intel_wait_for_vblank(dev, intel_crtc->pipe);
 
 	intel_dp_aux_native_write_1(intel_dp,
 				    DP_TRAINING_PATTERN_SET,
@@ -1174,10 +1170,15 @@
 	uint8_t voltage;
 	bool clock_recovery = false;
 	bool channel_eq = false;
-	bool first = true;
 	int tries;
 	u32 reg;
 	uint32_t DP = intel_dp->DP;
+	struct intel_crtc *intel_crtc = to_intel_crtc(intel_dp->base.enc.crtc);
+
+	/* Enable output, wait for it to become active */
+	I915_WRITE(intel_dp->output_reg, intel_dp->DP);
+	POSTING_READ(intel_dp->output_reg);
+	intel_wait_for_vblank(dev, intel_crtc->pipe);
 
 	/* Write the link configuration data */
 	intel_dp_aux_native_write(intel_dp, DP_LINK_BW_SET,
@@ -1210,9 +1211,8 @@
 			reg = DP | DP_LINK_TRAIN_PAT_1;
 
 		if (!intel_dp_set_link_train(intel_dp, reg,
-					     DP_TRAINING_PATTERN_1, train_set, first))
+					     DP_TRAINING_PATTERN_1, train_set))
 			break;
-		first = false;
 		/* Set training pattern 1 */
 
 		udelay(100);
@@ -1266,8 +1266,7 @@
 
 		/* channel eq pattern */
 		if (!intel_dp_set_link_train(intel_dp, reg,
-					     DP_TRAINING_PATTERN_2, train_set,
-					     false))
+					     DP_TRAINING_PATTERN_2, train_set))
 			break;
 
 		udelay(400);
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_drv.h linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_drv.h
--- linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_drv.h	2010-10-06 21:33:43.772815811 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_drv.h	2010-10-06 21:33:48.756815779 +0000
@@ -229,7 +229,6 @@
 						    struct drm_crtc *crtc);
 int intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,
 				struct drm_file *file_priv);
-extern void intel_wait_for_vblank_off(struct drm_device *dev, int pipe);
 extern void intel_wait_for_vblank(struct drm_device *dev, int pipe);
 extern struct drm_crtc *intel_get_crtc_from_pipe(struct drm_device *dev, int pipe);
 extern struct drm_crtc *intel_get_load_detect_pipe(struct intel_encoder *intel_encoder,
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_fb.c linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_fb.c
--- linux-2.6.36-rc6/drivers/gpu/drm/i915/intel_fb.c	2010-10-06 21:33:43.773815769 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/i915/intel_fb.c	2010-10-06 21:33:48.757379447 +0000
@@ -237,8 +237,10 @@
 	drm_fb_helper_fini(&ifbdev->helper);
 
 	drm_framebuffer_cleanup(&ifb->base);
-	if (ifb->obj)
+	if (ifb->obj) {
+		drm_gem_object_handle_unreference(ifb->obj);
 		drm_gem_object_unreference(ifb->obj);
+	}
 
 	return 0;
 }
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/nouveau/nouveau_fbcon.c linux-2.6.36-rc7/drivers/gpu/drm/nouveau/nouveau_fbcon.c
--- linux-2.6.36-rc6/drivers/gpu/drm/nouveau/nouveau_fbcon.c	2010-10-06 21:33:43.783815767 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/nouveau/nouveau_fbcon.c	2010-10-06 21:33:48.767380165 +0000
@@ -352,6 +352,7 @@
 
 	if (nouveau_fb->nvbo) {
 		nouveau_bo_unmap(nouveau_fb->nvbo);
+		drm_gem_object_handle_unreference_unlocked(nouveau_fb->nvbo->gem);
 		drm_gem_object_unreference_unlocked(nouveau_fb->nvbo->gem);
 		nouveau_fb->nvbo = NULL;
 	}
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/nouveau/nouveau_gem.c linux-2.6.36-rc7/drivers/gpu/drm/nouveau/nouveau_gem.c
--- linux-2.6.36-rc6/drivers/gpu/drm/nouveau/nouveau_gem.c	2010-10-06 21:33:43.784815801 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/nouveau/nouveau_gem.c	2010-10-06 21:33:48.767380165 +0000
@@ -167,11 +167,9 @@
 		goto out;
 
 	ret = drm_gem_handle_create(file_priv, nvbo->gem, &req->info.handle);
+	/* drop reference from allocate - handle holds it now */
+	drm_gem_object_unreference_unlocked(nvbo->gem);
 out:
-	drm_gem_object_handle_unreference_unlocked(nvbo->gem);
-
-	if (ret)
-		drm_gem_object_unreference_unlocked(nvbo->gem);
 	return ret;
 }
 
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/nouveau/nouveau_notifier.c linux-2.6.36-rc7/drivers/gpu/drm/nouveau/nouveau_notifier.c
--- linux-2.6.36-rc6/drivers/gpu/drm/nouveau/nouveau_notifier.c	2010-10-06 21:33:43.786815840 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/nouveau/nouveau_notifier.c	2010-10-06 21:33:48.769815771 +0000
@@ -79,6 +79,7 @@
 	mutex_lock(&dev->struct_mutex);
 	nouveau_bo_unpin(chan->notifier_bo);
 	mutex_unlock(&dev->struct_mutex);
+	drm_gem_object_handle_unreference_unlocked(chan->notifier_bo->gem);
 	drm_gem_object_unreference_unlocked(chan->notifier_bo->gem);
 	drm_mm_takedown(&chan->notifier_heap);
 }
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/radeon/r600.c linux-2.6.36-rc7/drivers/gpu/drm/radeon/r600.c
--- linux-2.6.36-rc6/drivers/gpu/drm/radeon/r600.c	2010-10-06 21:33:43.800815782 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/radeon/r600.c	2010-10-06 21:33:48.783815828 +0000
@@ -3528,7 +3528,8 @@
 	/* r7xx hw bug.  write to HDP_DEBUG1 followed by fb read
 	 * rather than write to HDP_REG_COHERENCY_FLUSH_CNTL
 	 */
-	if ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740)) {
+	if ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740) &&
+	    rdev->vram_scratch.ptr) {
 		void __iomem *ptr = (void *)rdev->vram_scratch.ptr;
 		u32 tmp;
 
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_atombios.c linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_atombios.c
--- linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_atombios.c	2010-10-06 21:33:43.804815821 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_atombios.c	2010-10-06 21:33:48.787815817 +0000
@@ -317,6 +317,15 @@
 			*connector_type = DRM_MODE_CONNECTOR_DVID;
 	}
 
+	/* MSI K9A2GM V2/V3 board has no HDMI or DVI */
+	if ((dev->pdev->device == 0x796e) &&
+	    (dev->pdev->subsystem_vendor == 0x1462) &&
+	    (dev->pdev->subsystem_device == 0x7302)) {
+		if ((supported_device == ATOM_DEVICE_DFP2_SUPPORT) ||
+		    (supported_device == ATOM_DEVICE_DFP3_SUPPORT))
+			return false;
+	}
+
 	/* a-bit f-i90hd - ciaranm on #radeonhd - this board has no DVI */
 	if ((dev->pdev->device == 0x7941) &&
 	    (dev->pdev->subsystem_vendor == 0x147b) &&
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_display.c linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_display.c
--- linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_display.c	2010-10-06 21:33:43.808504414 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_display.c	2010-10-06 21:33:48.790815869 +0000
@@ -349,6 +349,8 @@
 					DRM_INFO("    DFP4: %s\n", encoder_names[radeon_encoder->encoder_id]);
 				if (devices & ATOM_DEVICE_DFP5_SUPPORT)
 					DRM_INFO("    DFP5: %s\n", encoder_names[radeon_encoder->encoder_id]);
+				if (devices & ATOM_DEVICE_DFP6_SUPPORT)
+					DRM_INFO("    DFP6: %s\n", encoder_names[radeon_encoder->encoder_id]);
 				if (devices & ATOM_DEVICE_TV1_SUPPORT)
 					DRM_INFO("    TV1: %s\n", encoder_names[radeon_encoder->encoder_id]);
 				if (devices & ATOM_DEVICE_CV_SUPPORT)
@@ -841,8 +843,9 @@
 {
 	struct radeon_framebuffer *radeon_fb = to_radeon_framebuffer(fb);
 
-	if (radeon_fb->obj)
+	if (radeon_fb->obj) {
 		drm_gem_object_unreference_unlocked(radeon_fb->obj);
+	}
 	drm_framebuffer_cleanup(fb);
 	kfree(radeon_fb);
 }
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_fb.c linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_fb.c
--- linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_fb.c	2010-10-06 21:33:43.808504414 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_fb.c	2010-10-06 21:33:48.791815800 +0000
@@ -94,8 +94,10 @@
 	ret = radeon_bo_reserve(rbo, false);
 	if (likely(ret == 0)) {
 		radeon_bo_kunmap(rbo);
+		radeon_bo_unpin(rbo);
 		radeon_bo_unreserve(rbo);
 	}
+	drm_gem_object_handle_unreference(gobj);
 	drm_gem_object_unreference_unlocked(gobj);
 }
 
@@ -325,8 +327,6 @@
 {
 	struct fb_info *info;
 	struct radeon_framebuffer *rfb = &rfbdev->rfb;
-	struct radeon_bo *rbo;
-	int r;
 
 	if (rfbdev->helper.fbdev) {
 		info = rfbdev->helper.fbdev;
@@ -338,14 +338,8 @@
 	}
 
 	if (rfb->obj) {
-		rbo = rfb->obj->driver_private;
-		r = radeon_bo_reserve(rbo, false);
-		if (likely(r == 0)) {
-			radeon_bo_kunmap(rbo);
-			radeon_bo_unpin(rbo);
-			radeon_bo_unreserve(rbo);
-		}
-		drm_gem_object_unreference_unlocked(rfb->obj);
+		radeonfb_destroy_pinned_object(rfb->obj);
+		rfb->obj = NULL;
 	}
 	drm_fb_helper_fini(&rfbdev->helper);
 	drm_framebuffer_cleanup(&rfb->base);
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_gem.c linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_gem.c
--- linux-2.6.36-rc6/drivers/gpu/drm/radeon/radeon_gem.c	2010-10-06 21:33:43.808504414 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/radeon/radeon_gem.c	2010-10-06 21:33:48.791815800 +0000
@@ -201,11 +201,11 @@
 		return r;
 	}
 	r = drm_gem_handle_create(filp, gobj, &handle);
+	/* drop reference from allocate - handle holds it now */
+	drm_gem_object_unreference_unlocked(gobj);
 	if (r) {
-		drm_gem_object_unreference_unlocked(gobj);
 		return r;
 	}
-	drm_gem_object_handle_unreference_unlocked(gobj);
 	args->handle = handle;
 	return 0;
 }
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
--- linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c	2010-10-06 21:33:43.817815757 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c	2010-10-06 21:33:48.800929946 +0000
@@ -148,13 +148,16 @@
 	{0, 0, 0}
 };
 
-static char *vmw_devname = "vmwgfx";
+static int enable_fbdev;
 
 static int vmw_probe(struct pci_dev *, const struct pci_device_id *);
 static void vmw_master_init(struct vmw_master *);
 static int vmwgfx_pm_notifier(struct notifier_block *nb, unsigned long val,
 			      void *ptr);
 
+MODULE_PARM_DESC(enable_fbdev, "Enable vmwgfx fbdev");
+module_param_named(enable_fbdev, enable_fbdev, int, 0600);
+
 static void vmw_print_capabilities(uint32_t capabilities)
 {
 	DRM_INFO("Capabilities:\n");
@@ -192,8 +195,6 @@
 {
 	int ret;
 
-	vmw_kms_save_vga(dev_priv);
-
 	ret = vmw_fifo_init(dev_priv, &dev_priv->fifo);
 	if (unlikely(ret != 0)) {
 		DRM_ERROR("Unable to initialize FIFO.\n");
@@ -206,9 +207,35 @@
 static void vmw_release_device(struct vmw_private *dev_priv)
 {
 	vmw_fifo_release(dev_priv, &dev_priv->fifo);
-	vmw_kms_restore_vga(dev_priv);
 }
 
+int vmw_3d_resource_inc(struct vmw_private *dev_priv)
+{
+	int ret = 0;
+
+	mutex_lock(&dev_priv->release_mutex);
+	if (unlikely(dev_priv->num_3d_resources++ == 0)) {
+		ret = vmw_request_device(dev_priv);
+		if (unlikely(ret != 0))
+			--dev_priv->num_3d_resources;
+	}
+	mutex_unlock(&dev_priv->release_mutex);
+	return ret;
+}
+
+
+void vmw_3d_resource_dec(struct vmw_private *dev_priv)
+{
+	int32_t n3d;
+
+	mutex_lock(&dev_priv->release_mutex);
+	if (unlikely(--dev_priv->num_3d_resources == 0))
+		vmw_release_device(dev_priv);
+	n3d = (int32_t) dev_priv->num_3d_resources;
+	mutex_unlock(&dev_priv->release_mutex);
+
+	BUG_ON(n3d < 0);
+}
 
 static int vmw_driver_load(struct drm_device *dev, unsigned long chipset)
 {
@@ -228,6 +255,7 @@
 	dev_priv->last_read_sequence = (uint32_t) -100;
 	mutex_init(&dev_priv->hw_mutex);
 	mutex_init(&dev_priv->cmdbuf_mutex);
+	mutex_init(&dev_priv->release_mutex);
 	rwlock_init(&dev_priv->resource_lock);
 	idr_init(&dev_priv->context_idr);
 	idr_init(&dev_priv->surface_idr);
@@ -244,6 +272,8 @@
 	dev_priv->vram_start = pci_resource_start(dev->pdev, 1);
 	dev_priv->mmio_start = pci_resource_start(dev->pdev, 2);
 
+	dev_priv->enable_fb = enable_fbdev;
+
 	mutex_lock(&dev_priv->hw_mutex);
 
 	vmw_write(dev_priv, SVGA_REG_ID, SVGA_ID_2);
@@ -343,17 +373,6 @@
 
 	dev->dev_private = dev_priv;
 
-	if (!dev->devname)
-		dev->devname = vmw_devname;
-
-	if (dev_priv->capabilities & SVGA_CAP_IRQMASK) {
-		ret = drm_irq_install(dev);
-		if (unlikely(ret != 0)) {
-			DRM_ERROR("Failed installing irq: %d\n", ret);
-			goto out_no_irq;
-		}
-	}
-
 	ret = pci_request_regions(dev->pdev, "vmwgfx probe");
 	dev_priv->stealth = (ret != 0);
 	if (dev_priv->stealth) {
@@ -369,26 +388,52 @@
 			goto out_no_device;
 		}
 	}
-	ret = vmw_request_device(dev_priv);
+	ret = vmw_kms_init(dev_priv);
 	if (unlikely(ret != 0))
-		goto out_no_device;
-	vmw_kms_init(dev_priv);
+		goto out_no_kms;
 	vmw_overlay_init(dev_priv);
-	vmw_fb_init(dev_priv);
+	if (dev_priv->enable_fb) {
+		ret = vmw_3d_resource_inc(dev_priv);
+		if (unlikely(ret != 0))
+			goto out_no_fifo;
+		vmw_kms_save_vga(dev_priv);
+		vmw_fb_init(dev_priv);
+		DRM_INFO("%s", vmw_fifo_have_3d(dev_priv) ?
+			 "Detected device 3D availability.\n" :
+			 "Detected no device 3D availability.\n");
+	} else {
+		DRM_INFO("Delayed 3D detection since we're not "
+			 "running the device in SVGA mode yet.\n");
+	}
+
+	if (dev_priv->capabilities & SVGA_CAP_IRQMASK) {
+		ret = drm_irq_install(dev);
+		if (unlikely(ret != 0)) {
+			DRM_ERROR("Failed installing irq: %d\n", ret);
+			goto out_no_irq;
+		}
+	}
 
 	dev_priv->pm_nb.notifier_call = vmwgfx_pm_notifier;
 	register_pm_notifier(&dev_priv->pm_nb);
 
-	DRM_INFO("%s", vmw_fifo_have_3d(dev_priv) ? "Have 3D\n" : "No 3D\n");
-
 	return 0;
 
-out_no_device:
-	if (dev_priv->capabilities & SVGA_CAP_IRQMASK)
-		drm_irq_uninstall(dev_priv->dev);
-	if (dev->devname == vmw_devname)
-		dev->devname = NULL;
 out_no_irq:
+	if (dev_priv->enable_fb) {
+		vmw_fb_close(dev_priv);
+		vmw_kms_restore_vga(dev_priv);
+		vmw_3d_resource_dec(dev_priv);
+	}
+out_no_fifo:
+	vmw_overlay_close(dev_priv);
+	vmw_kms_close(dev_priv);
+out_no_kms:
+	if (dev_priv->stealth)
+		pci_release_region(dev->pdev, 2);
+	else
+		pci_release_regions(dev->pdev);
+out_no_device:
 	ttm_object_device_release(&dev_priv->tdev);
 out_err4:
 	iounmap(dev_priv->mmio_virt);
@@ -415,19 +460,20 @@
 
 	unregister_pm_notifier(&dev_priv->pm_nb);
 
-	vmw_fb_close(dev_priv);
+	if (dev_priv->capabilities & SVGA_CAP_IRQMASK)
+		drm_irq_uninstall(dev_priv->dev);
+	if (dev_priv->enable_fb) {
+		vmw_fb_close(dev_priv);
+		vmw_kms_restore_vga(dev_priv);
+		vmw_3d_resource_dec(dev_priv);
+	}
 	vmw_kms_close(dev_priv);
 	vmw_overlay_close(dev_priv);
-	vmw_release_device(dev_priv);
 	if (dev_priv->stealth)
 		pci_release_region(dev->pdev, 2);
 	else
 		pci_release_regions(dev->pdev);
 
-	if (dev_priv->capabilities & SVGA_CAP_IRQMASK)
-		drm_irq_uninstall(dev_priv->dev);
-	if (dev->devname == vmw_devname)
-		dev->devname = NULL;
 	ttm_object_device_release(&dev_priv->tdev);
 	iounmap(dev_priv->mmio_virt);
 	drm_mtrr_del(dev_priv->mmio_mtrr, dev_priv->mmio_start,
@@ -500,7 +546,7 @@
 		struct drm_ioctl_desc *ioctl =
 		    &vmw_ioctls[nr - DRM_COMMAND_BASE];
 
-		if (unlikely(ioctl->cmd != cmd)) {
+		if (unlikely(ioctl->cmd_drv != cmd)) {
 			DRM_ERROR("Invalid command format, ioctl %d\n",
 				  nr - DRM_COMMAND_BASE);
 			return -EINVAL;
@@ -589,6 +635,16 @@
 	struct vmw_master *vmaster = vmw_master(file_priv->master);
 	int ret = 0;
 
+	if (!dev_priv->enable_fb) {
+		ret = vmw_3d_resource_inc(dev_priv);
+		if (unlikely(ret != 0))
+			return ret;
+		vmw_kms_save_vga(dev_priv);
+		mutex_lock(&dev_priv->hw_mutex);
+		vmw_write(dev_priv, SVGA_REG_TRACES, 0);
+		mutex_unlock(&dev_priv->hw_mutex);
+	}
+
 	if (active) {
 		BUG_ON(active != &dev_priv->fbdev_master);
 		ret = ttm_vt_lock(&active->lock, false, vmw_fp->tfile);
@@ -617,7 +673,13 @@
 	return 0;
 
 out_no_active_lock:
-	vmw_release_device(dev_priv);
+	if (!dev_priv->enable_fb) {
+		mutex_lock(&dev_priv->hw_mutex);
+		vmw_write(dev_priv, SVGA_REG_TRACES, 1);
+		mutex_unlock(&dev_priv->hw_mutex);
+		vmw_kms_restore_vga(dev_priv);
+		vmw_3d_resource_dec(dev_priv);
+	}
 	return ret;
 }
 
@@ -645,11 +707,23 @@
 
 	ttm_lock_set_kill(&vmaster->lock, true, SIGTERM);
 
+	if (!dev_priv->enable_fb) {
+		ret = ttm_bo_evict_mm(&dev_priv->bdev, TTM_PL_VRAM);
+		if (unlikely(ret != 0))
+			DRM_ERROR("Unable to clean VRAM on master drop.\n");
+		mutex_lock(&dev_priv->hw_mutex);
+		vmw_write(dev_priv, SVGA_REG_TRACES, 1);
+		mutex_unlock(&dev_priv->hw_mutex);
+		vmw_kms_restore_vga(dev_priv);
+		vmw_3d_resource_dec(dev_priv);
+	}
+
 	dev_priv->active_master = &dev_priv->fbdev_master;
 	ttm_lock_set_kill(&dev_priv->fbdev_master.lock, false, SIGTERM);
 	ttm_vt_unlock(&dev_priv->fbdev_master.lock);
 
-	vmw_fb_on(dev_priv);
+	if (dev_priv->enable_fb)
+		vmw_fb_on(dev_priv);
 }
 
 
@@ -722,6 +796,7 @@
 	.irq_postinstall = vmw_irq_postinstall,
 	.irq_uninstall = vmw_irq_uninstall,
 	.irq_handler = vmw_irq_handler,
+	.get_vblank_counter = vmw_get_vblank_counter,
 	.reclaim_buffers_locked = NULL,
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
--- linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h	2010-10-06 21:33:43.817815757 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h	2010-10-06 21:33:48.800929946 +0000
@@ -277,6 +277,7 @@
 
 	bool stealth;
 	bool is_opened;
+	bool enable_fb;
 
 	/**
 	 * Master management.
@@ -285,6 +286,9 @@
 	struct vmw_master *active_master;
 	struct vmw_master fbdev_master;
 	struct notifier_block pm_nb;
+
+	struct mutex release_mutex;
+	uint32_t num_3d_resources;
 };
 
 static inline struct vmw_private *vmw_priv(struct drm_device *dev)
@@ -319,6 +323,9 @@
 	return val;
 }
 
+int vmw_3d_resource_inc(struct vmw_private *dev_priv);
+void vmw_3d_resource_dec(struct vmw_private *dev_priv);
+
 /**
  * GMR utilities - vmwgfx_gmr.c
  */
@@ -511,6 +518,7 @@
 			unsigned bbp, unsigned depth);
 int vmw_kms_update_layout_ioctl(struct drm_device *dev, void *data,
 				struct drm_file *file_priv);
+u32 vmw_get_vblank_counter(struct drm_device *dev, int crtc);
 
 /**
  * Overlay control - vmwgfx_overlay.c
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c
--- linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c	2010-10-06 21:33:43.817815757 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c	2010-10-06 21:33:48.800929946 +0000
@@ -615,6 +615,11 @@
 	if (unlikely(ret != 0))
 		goto err_unlock;
 
+	if (bo->mem.mem_type == TTM_PL_VRAM &&
+	    bo->mem.mm_node->start < bo->num_pages)
+		(void) ttm_bo_validate(bo, &vmw_sys_placement, false,
+				       false, false);
+
 	ret = ttm_bo_validate(bo, &ne_placement, false, false, false);
 
 	/* Could probably bug on */
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c
--- linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c	2010-10-06 21:33:48.800929946 +0000
@@ -106,6 +106,7 @@
 	mutex_lock(&dev_priv->hw_mutex);
 	dev_priv->enable_state = vmw_read(dev_priv, SVGA_REG_ENABLE);
 	dev_priv->config_done_state = vmw_read(dev_priv, SVGA_REG_CONFIG_DONE);
+	dev_priv->traces_state = vmw_read(dev_priv, SVGA_REG_TRACES);
 	vmw_write(dev_priv, SVGA_REG_ENABLE, 1);
 
 	min = 4;
@@ -175,6 +176,8 @@
 		  dev_priv->config_done_state);
 	vmw_write(dev_priv, SVGA_REG_ENABLE,
 		  dev_priv->enable_state);
+	vmw_write(dev_priv, SVGA_REG_TRACES,
+		  dev_priv->traces_state);
 
 	mutex_unlock(&dev_priv->hw_mutex);
 	vmw_fence_queue_takedown(&fifo->fence_queue);
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
--- linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c	2010-10-06 21:33:43.817815757 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c	2010-10-06 21:33:48.801816440 +0000
@@ -898,7 +898,19 @@
 		save->width = vmw_read(vmw_priv, SVGA_REG_DISPLAY_WIDTH);
 		save->height = vmw_read(vmw_priv, SVGA_REG_DISPLAY_HEIGHT);
 		vmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);
+		if (i == 0 && vmw_priv->num_displays == 1 &&
+		    save->width == 0 && save->height == 0) {
+
+			/*
+			 * It should be fairly safe to assume that these
+			 * values are uninitialized.
+			 */
+
+			save->width = vmw_priv->vga_width - save->pos_x;
+			save->height = vmw_priv->vga_height - save->pos_y;
+		}
 	}
+
 	return 0;
 }
 
@@ -984,3 +996,8 @@
 	ttm_read_unlock(&vmaster->lock);
 	return ret;
 }
+
+u32 vmw_get_vblank_counter(struct drm_device *dev, int crtc)
+{
+	return 0;
+}
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c
--- linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c	2010-10-06 21:33:43.817815757 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c	2010-10-06 21:33:48.801816440 +0000
@@ -27,6 +27,8 @@
 
 #include "vmwgfx_kms.h"
 
+#define VMWGFX_LDU_NUM_DU 8
+
 #define vmw_crtc_to_ldu(x) \
 	container_of(x, struct vmw_legacy_display_unit, base.crtc)
 #define vmw_encoder_to_ldu(x) \
@@ -536,6 +538,10 @@
 
 int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv)
 {
+	struct drm_device *dev = dev_priv->dev;
+	int i;
+	int ret;
+
 	if (dev_priv->ldu_priv) {
 		DRM_INFO("ldu system already on\n");
 		return -EINVAL;
@@ -553,23 +559,24 @@
 
 	drm_mode_create_dirty_info_property(dev_priv->dev);
 
-	vmw_ldu_init(dev_priv, 0);
-	/* for old hardware without multimon only enable one display */
 	if (dev_priv->capabilities & SVGA_CAP_MULTIMON) {
-		vmw_ldu_init(dev_priv, 1);
-		vmw_ldu_init(dev_priv, 2);
-		vmw_ldu_init(dev_priv, 3);
-		vmw_ldu_init(dev_priv, 4);
-		vmw_ldu_init(dev_priv, 5);
-		vmw_ldu_init(dev_priv, 6);
-		vmw_ldu_init(dev_priv, 7);
+		for (i = 0; i < VMWGFX_LDU_NUM_DU; ++i)
+			vmw_ldu_init(dev_priv, i);
+		ret = drm_vblank_init(dev, VMWGFX_LDU_NUM_DU);
+	} else {
+		/* for old hardware without multimon only enable one display */
+		vmw_ldu_init(dev_priv, 0);
+		ret = drm_vblank_init(dev, 1);
 	}
 
-	return 0;
+	return ret;
 }
 
 int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv)
 {
+	struct drm_device *dev = dev_priv->dev;
+
+	drm_vblank_cleanup(dev);
 	if (!dev_priv->ldu_priv)
 		return -ENOSYS;
 
diff -urN linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c
--- linux-2.6.36-rc6/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c	2010-10-06 21:33:43.818815811 +0000
+++ linux-2.6.36-rc7/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c	2010-10-06 21:33:48.801816440 +0000
@@ -211,6 +211,7 @@
 	cmd->body.cid = cpu_to_le32(res->id);
 
 	vmw_fifo_commit(dev_priv, sizeof(*cmd));
+	vmw_3d_resource_dec(dev_priv);
 }
 
 static int vmw_context_init(struct vmw_private *dev_priv,
@@ -247,6 +248,7 @@
 	cmd->body.cid = cpu_to_le32(res->id);
 
 	vmw_fifo_commit(dev_priv, sizeof(*cmd));
+	(void) vmw_3d_resource_inc(dev_priv);
 	vmw_resource_activate(res, vmw_hw_context_destroy);
 	return 0;
 }
@@ -406,6 +408,7 @@
 	cmd->body.sid = cpu_to_le32(res->id);
 
 	vmw_fifo_commit(dev_priv, sizeof(*cmd));
+	vmw_3d_resource_dec(dev_priv);
 }
 
 void vmw_surface_res_free(struct vmw_resource *res)
@@ -473,6 +476,7 @@
 	}
 
 	vmw_fifo_commit(dev_priv, submit_size);
+	(void) vmw_3d_resource_inc(dev_priv);
 	vmw_resource_activate(res, vmw_hw_surface_destroy);
 	return 0;
 }
diff -urN linux-2.6.36-rc6/drivers/hwmon/f71882fg.c linux-2.6.36-rc7/drivers/hwmon/f71882fg.c
--- linux-2.6.36-rc6/drivers/hwmon/f71882fg.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/hwmon/f71882fg.c	2010-10-06 21:33:48.807815758 +0000
@@ -111,7 +111,7 @@
 /* Super-I/O Function prototypes */
 static inline int superio_inb(int base, int reg);
 static inline int superio_inw(int base, int reg);
-static inline void superio_enter(int base);
+static inline int superio_enter(int base);
 static inline void superio_select(int base, int ld);
 static inline void superio_exit(int base);
 
@@ -861,11 +861,20 @@
 	return val;
 }
 
-static inline void superio_enter(int base)
+static inline int superio_enter(int base)
 {
+	/* Don't step on other drivers' I/O space by accident */
+	if (!request_muxed_region(base, 2, DRVNAME)) {
+		printk(KERN_ERR DRVNAME ": I/O address 0x%04x already in use\n",
+				base);
+		return -EBUSY;
+	}
+
 	/* according to the datasheet the key must be send twice! */
 	outb(SIO_UNLOCK_KEY, base);
 	outb(SIO_UNLOCK_KEY, base);
+
+	return 0;
 }
 
 static inline void superio_select(int base, int ld)
@@ -877,6 +886,7 @@
 static inline void superio_exit(int base)
 {
 	outb(SIO_LOCK_KEY, base);
+	release_region(base, 2);
 }
 
 static inline int fan_from_reg(u16 reg)
@@ -2175,21 +2185,15 @@
 static int __init f71882fg_find(int sioaddr, unsigned short *address,
 	struct f71882fg_sio_data *sio_data)
 {
-	int err = -ENODEV;
 	u16 devid;
-
-	/* Don't step on other drivers' I/O space by accident */
-	if (!request_region(sioaddr, 2, DRVNAME)) {
-		printk(KERN_ERR DRVNAME ": I/O address 0x%04x already in use\n",
-				(int)sioaddr);
-		return -EBUSY;
-	}
-
-	superio_enter(sioaddr);
+	int err = superio_enter(sioaddr);
+	if (err)
+		return err;
 
 	devid = superio_inw(sioaddr, SIO_REG_MANID);
 	if (devid != SIO_FINTEK_ID) {
 		pr_debug(DRVNAME ": Not a Fintek device\n");
+		err = -ENODEV;
 		goto exit;
 	}
 
@@ -2213,6 +2217,7 @@
 	default:
 		printk(KERN_INFO DRVNAME ": Unsupported Fintek device: %04x\n",
 		       (unsigned int)devid);
+		err = -ENODEV;
 		goto exit;
 	}
 
@@ -2223,12 +2228,14 @@
 
 	if (!(superio_inb(sioaddr, SIO_REG_ENABLE) & 0x01)) {
 		printk(KERN_WARNING DRVNAME ": Device not activated\n");
+		err = -ENODEV;
 		goto exit;
 	}
 
 	*address = superio_inw(sioaddr, SIO_REG_ADDR);
 	if (*address == 0) {
 		printk(KERN_WARNING DRVNAME ": Base address not set\n");
+		err = -ENODEV;
 		goto exit;
 	}
 	*address &= ~(REGION_LENGTH - 1);	/* Ignore 3 LSB */
@@ -2239,7 +2246,6 @@
 		(int)superio_inb(sioaddr, SIO_REG_DEVREV));
 exit:
 	superio_exit(sioaddr);
-	release_region(sioaddr, 2);
 	return err;
 }
 
diff -urN linux-2.6.36-rc6/drivers/i2c/busses/i2c-davinci.c linux-2.6.36-rc7/drivers/i2c/busses/i2c-davinci.c
--- linux-2.6.36-rc6/drivers/i2c/busses/i2c-davinci.c	2010-10-06 21:33:43.829815792 +0000
+++ linux-2.6.36-rc7/drivers/i2c/busses/i2c-davinci.c	2010-10-06 21:33:48.813815811 +0000
@@ -357,9 +357,6 @@
 
 	dev->terminate = 0;
 
-	/* write the data into mode register */
-	davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);
-
 	/*
 	 * First byte should be set here, not after interrupt,
 	 * because transmit-data-ready interrupt can come before
@@ -371,6 +368,9 @@
 		dev->buf_len--;
 	}
 
+	/* write the data into mode register; start transmitting */
+	davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);
+
 	r = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
 						      dev->adapter.timeout);
 	if (r == 0) {
diff -urN linux-2.6.36-rc6/drivers/i2c/busses/i2c-octeon.c linux-2.6.36-rc7/drivers/i2c/busses/i2c-octeon.c
--- linux-2.6.36-rc6/drivers/i2c/busses/i2c-octeon.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/i2c/busses/i2c-octeon.c	2010-10-06 21:33:48.814815821 +0000
@@ -218,7 +218,7 @@
 		return result;
 	} else if (result == 0) {
 		dev_dbg(i2c->dev, "%s: timeout\n", __func__);
-		result = -ETIMEDOUT;
+		return -ETIMEDOUT;
 	}
 
 	return 0;
diff -urN linux-2.6.36-rc6/drivers/i2c/busses/i2c-s3c2410.c linux-2.6.36-rc7/drivers/i2c/busses/i2c-s3c2410.c
--- linux-2.6.36-rc6/drivers/i2c/busses/i2c-s3c2410.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/i2c/busses/i2c-s3c2410.c	2010-10-06 21:33:48.815723077 +0000
@@ -662,8 +662,8 @@
 		unsigned long sda_delay;
 
 		if (pdata->sda_delay) {
-			sda_delay = (freq / 1000) * pdata->sda_delay;
-			sda_delay /= 1000000;
+			sda_delay = clkin * pdata->sda_delay;
+			sda_delay = DIV_ROUND_UP(sda_delay, 1000000);
 			sda_delay = DIV_ROUND_UP(sda_delay, 5);
 			if (sda_delay > 3)
 				sda_delay = 3;
diff -urN linux-2.6.36-rc6/drivers/idle/intel_idle.c linux-2.6.36-rc7/drivers/idle/intel_idle.c
--- linux-2.6.36-rc6/drivers/idle/intel_idle.c	2010-10-06 21:33:43.835672169 +0000
+++ linux-2.6.36-rc7/drivers/idle/intel_idle.c	2010-10-06 21:33:48.820541645 +0000
@@ -83,7 +83,7 @@
 /* Reliable LAPIC Timer States, bit 1 for C1 etc.  */
 static unsigned int lapic_timer_reliable_states;
 
-static struct cpuidle_device *intel_idle_cpuidle_devices;
+static struct cpuidle_device __percpu *intel_idle_cpuidle_devices;
 static int intel_idle(struct cpuidle_device *dev, struct cpuidle_state *state);
 
 static struct cpuidle_state *cpuidle_state_table;
@@ -108,7 +108,7 @@
 		.name = "NHM-C3",
 		.desc = "MWAIT 0x10",
 		.driver_data = (void *) 0x10,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.flags = CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
 		.exit_latency = 20,
 		.power_usage = 500,
 		.target_residency = 80,
@@ -117,7 +117,7 @@
 		.name = "NHM-C6",
 		.desc = "MWAIT 0x20",
 		.driver_data = (void *) 0x20,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.flags = CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
 		.exit_latency = 200,
 		.power_usage = 350,
 		.target_residency = 800,
@@ -149,7 +149,7 @@
 		.name = "ATM-C4",
 		.desc = "MWAIT 0x30",
 		.driver_data = (void *) 0x30,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.flags = CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
 		.exit_latency = 100,
 		.power_usage = 250,
 		.target_residency = 400,
@@ -159,7 +159,7 @@
 		.name = "ATM-C6",
 		.desc = "MWAIT 0x40",
 		.driver_data = (void *) 0x40,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.flags = CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
 		.exit_latency = 200,
 		.power_usage = 150,
 		.target_residency = 800,
@@ -185,6 +185,16 @@
 
 	local_irq_disable();
 
+	/*
+	 * If the state flag indicates that the TLB will be flushed or if this
+	 * is the deepest c-state supported, do a voluntary leave mm to avoid
+	 * costly and mostly unnecessary wakeups for flushing the user TLB's
+	 * associated with the active mm.
+	 */
+	if (state->flags & CPUIDLE_FLAG_TLB_FLUSHED ||
+	    (&dev->states[dev->state_count - 1] == state))
+		leave_mm(cpu);
+
 	if (!(lapic_timer_reliable_states & (1 << (cstate))))
 		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);
 
diff -urN linux-2.6.36-rc6/drivers/mfd/max8925-core.c linux-2.6.36-rc7/drivers/mfd/max8925-core.c
--- linux-2.6.36-rc6/drivers/mfd/max8925-core.c	2010-10-06 21:33:43.999378645 +0000
+++ linux-2.6.36-rc7/drivers/mfd/max8925-core.c	2010-10-06 21:33:48.960815810 +0000
@@ -429,24 +429,25 @@
 	irq_tsc = cache_tsc;
 	for (i = 0; i < ARRAY_SIZE(max8925_irqs); i++) {
 		irq_data = &max8925_irqs[i];
+		/* 1 -- disable, 0 -- enable */
 		switch (irq_data->mask_reg) {
 		case MAX8925_CHG_IRQ1_MASK:
-			irq_chg[0] &= irq_data->enable;
+			irq_chg[0] &= ~irq_data->enable;
 			break;
 		case MAX8925_CHG_IRQ2_MASK:
-			irq_chg[1] &= irq_data->enable;
+			irq_chg[1] &= ~irq_data->enable;
 			break;
 		case MAX8925_ON_OFF_IRQ1_MASK:
-			irq_on[0] &= irq_data->enable;
+			irq_on[0] &= ~irq_data->enable;
 			break;
 		case MAX8925_ON_OFF_IRQ2_MASK:
-			irq_on[1] &= irq_data->enable;
+			irq_on[1] &= ~irq_data->enable;
 			break;
 		case MAX8925_RTC_IRQ_MASK:
-			irq_rtc &= irq_data->enable;
+			irq_rtc &= ~irq_data->enable;
 			break;
 		case MAX8925_TSC_IRQ_MASK:
-			irq_tsc &= irq_data->enable;
+			irq_tsc &= ~irq_data->enable;
 			break;
 		default:
 			dev_err(chip->dev, "wrong IRQ\n");
diff -urN linux-2.6.36-rc6/drivers/mfd/wm831x-irq.c linux-2.6.36-rc7/drivers/mfd/wm831x-irq.c
--- linux-2.6.36-rc6/drivers/mfd/wm831x-irq.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/mfd/wm831x-irq.c	2010-10-06 21:33:48.963815801 +0000
@@ -394,8 +394,13 @@
 
 	irq = irq - wm831x->irq_base;
 
-	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_11)
-		return -EINVAL;
+	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_11) {
+		/* Ignore internal-only IRQs */
+		if (irq >= 0 && irq < WM831X_NUM_IRQS)
+			return 0;
+		else
+			return -EINVAL;
+	}
 
 	switch (type) {
 	case IRQ_TYPE_EDGE_BOTH:
diff -urN linux-2.6.36-rc6/drivers/mtd/nand/omap2.c linux-2.6.36-rc7/drivers/mtd/nand/omap2.c
--- linux-2.6.36-rc6/drivers/mtd/nand/omap2.c	2010-10-06 21:33:44.037378654 +0000
+++ linux-2.6.36-rc7/drivers/mtd/nand/omap2.c	2010-10-06 21:33:48.987815812 +0000
@@ -413,7 +413,7 @@
 		prefetch_status = gpmc_read_status(GPMC_PREFETCH_COUNT);
 	} while (prefetch_status);
 	/* disable and stop the PFPW engine */
-	gpmc_prefetch_reset();
+	gpmc_prefetch_reset(info->gpmc_cs);
 
 	dma_unmap_single(&info->pdev->dev, dma_addr, len, dir);
 	return 0;
diff -urN linux-2.6.36-rc6/drivers/net/wireless/iwlwifi/iwl-agn-lib.c linux-2.6.36-rc7/drivers/net/wireless/iwlwifi/iwl-agn-lib.c
--- linux-2.6.36-rc6/drivers/net/wireless/iwlwifi/iwl-agn-lib.c	2010-10-06 21:33:44.274378329 +0000
+++ linux-2.6.36-rc7/drivers/net/wireless/iwlwifi/iwl-agn-lib.c	2010-10-06 21:33:49.207542576 +0000
@@ -1411,7 +1411,7 @@
 	clear_bit(STATUS_SCAN_HW, &priv->status);
 	clear_bit(STATUS_SCANNING, &priv->status);
 	/* inform mac80211 scan aborted */
-	queue_work(priv->workqueue, &priv->scan_completed);
+	queue_work(priv->workqueue, &priv->abort_scan);
 }
 
 int iwlagn_manage_ibss_station(struct iwl_priv *priv,
diff -urN linux-2.6.36-rc6/drivers/net/wireless/iwlwifi/iwl3945-base.c linux-2.6.36-rc7/drivers/net/wireless/iwlwifi/iwl3945-base.c
--- linux-2.6.36-rc6/drivers/net/wireless/iwlwifi/iwl3945-base.c	2010-10-06 21:33:44.285379197 +0000
+++ linux-2.6.36-rc7/drivers/net/wireless/iwlwifi/iwl3945-base.c	2010-10-06 21:33:49.218815821 +0000
@@ -3018,7 +3018,7 @@
 	clear_bit(STATUS_SCANNING, &priv->status);
 
 	/* inform mac80211 scan aborted */
-	queue_work(priv->workqueue, &priv->scan_completed);
+	queue_work(priv->workqueue, &priv->abort_scan);
 }
 
 static void iwl3945_bg_restart(struct work_struct *data)
diff -urN linux-2.6.36-rc6/drivers/pci/quirks.c linux-2.6.36-rc7/drivers/pci/quirks.c
--- linux-2.6.36-rc6/drivers/pci/quirks.c	2010-10-06 21:33:44.335378676 +0000
+++ linux-2.6.36-rc7/drivers/pci/quirks.c	2010-10-06 21:33:49.267815917 +0000
@@ -163,6 +163,26 @@
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_3,	quirk_isa_dma_hangs);
 
 /*
+ * Intel NM10 "TigerPoint" LPC PM1a_STS.BM_STS must be clear
+ * for some HT machines to use C4 w/o hanging.
+ */
+static void __devinit quirk_tigerpoint_bm_sts(struct pci_dev *dev)
+{
+	u32 pmbase;
+	u16 pm1a;
+
+	pci_read_config_dword(dev, 0x40, &pmbase);
+	pmbase = pmbase & 0xff80;
+	pm1a = inw(pmbase);
+
+	if (pm1a & 0x10) {
+		dev_info(&dev->dev, FW_BUG "TigerPoint LPC.BM_STS cleared\n");
+		outw(0x10, pmbase);
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TGP_LPC, quirk_tigerpoint_bm_sts);
+
+/*
  *	Chipsets where PCI->PCI transfers vanish or hang
  */
 static void __devinit quirk_nopcipci(struct pci_dev *dev)
diff -urN linux-2.6.36-rc6/drivers/regulator/core.c linux-2.6.36-rc7/drivers/regulator/core.c
--- linux-2.6.36-rc6/drivers/regulator/core.c	2010-10-06 21:33:44.353378491 +0000
+++ linux-2.6.36-rc7/drivers/regulator/core.c	2010-10-06 21:33:49.284815818 +0000
@@ -700,7 +700,7 @@
 	    constraints->min_uA != constraints->max_uA) {
 		ret = _regulator_get_current_limit(rdev);
 		if (ret > 0)
-			count += sprintf(buf + count, "at %d uA ", ret / 1000);
+			count += sprintf(buf + count, "at %d mA ", ret / 1000);
 	}
 
 	if (constraints->valid_modes_mask & REGULATOR_MODE_FAST)
@@ -2302,8 +2302,10 @@
 	dev_set_name(&rdev->dev, "regulator.%d",
 		     atomic_inc_return(&regulator_no) - 1);
 	ret = device_register(&rdev->dev);
-	if (ret != 0)
+	if (ret != 0) {
+		put_device(&rdev->dev);
 		goto clean;
+	}
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
diff -urN linux-2.6.36-rc6/drivers/regulator/max8649.c linux-2.6.36-rc7/drivers/regulator/max8649.c
--- linux-2.6.36-rc6/drivers/regulator/max8649.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/drivers/regulator/max8649.c	2010-10-06 21:33:49.285815775 +0000
@@ -330,7 +330,7 @@
 		/* set external clock frequency */
 		info->extclk_freq = pdata->extclk_freq;
 		max8649_set_bits(info->i2c, MAX8649_SYNC, MAX8649_EXT_MASK,
-				 info->extclk_freq);
+				 info->extclk_freq << 6);
 	}
 
 	if (pdata->ramp_timing) {
diff -urN linux-2.6.36-rc6/drivers/serial/mfd.c linux-2.6.36-rc7/drivers/serial/mfd.c
--- linux-2.6.36-rc6/drivers/serial/mfd.c	2010-10-06 21:33:44.481378398 +0000
+++ linux-2.6.36-rc7/drivers/serial/mfd.c	2010-10-06 21:33:49.406815777 +0000
@@ -27,6 +27,7 @@
 #include <linux/init.h>
 #include <linux/console.h>
 #include <linux/sysrq.h>
+#include <linux/slab.h>
 #include <linux/serial_reg.h>
 #include <linux/circ_buf.h>
 #include <linux/delay.h>
diff -urN linux-2.6.36-rc6/drivers/serial/mrst_max3110.c linux-2.6.36-rc7/drivers/serial/mrst_max3110.c
--- linux-2.6.36-rc6/drivers/serial/mrst_max3110.c	2010-10-06 21:33:44.482378505 +0000
+++ linux-2.6.36-rc7/drivers/serial/mrst_max3110.c	2010-10-06 21:33:49.407815787 +0000
@@ -29,6 +29,7 @@
 
 #include <linux/module.h>
 #include <linux/ioport.h>
+#include <linux/irq.h>
 #include <linux/init.h>
 #include <linux/console.h>
 #include <linux/sysrq.h>
diff -urN linux-2.6.36-rc6/drivers/spi/spi.c linux-2.6.36-rc7/drivers/spi/spi.c
--- linux-2.6.36-rc6/drivers/spi/spi.c	2010-10-06 21:33:44.488378400 +0000
+++ linux-2.6.36-rc7/drivers/spi/spi.c	2010-10-06 21:33:49.413619345 +0000
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/cache.h>
 #include <linux/mutex.h>
+#include <linux/of_device.h>
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
@@ -86,6 +87,10 @@
 	const struct spi_device	*spi = to_spi_device(dev);
 	const struct spi_driver	*sdrv = to_spi_driver(drv);
 
+	/* Attempt an OF style match */
+	if (of_driver_match_device(dev, drv))
+		return 1;
+
 	if (sdrv->id_table)
 		return !!spi_match_id(sdrv->id_table, spi);
 
diff -urN linux-2.6.36-rc6/drivers/spi/spi_gpio.c linux-2.6.36-rc7/drivers/spi/spi_gpio.c
--- linux-2.6.36-rc6/drivers/spi/spi_gpio.c	2010-10-06 21:33:44.488378400 +0000
+++ linux-2.6.36-rc7/drivers/spi/spi_gpio.c	2010-10-06 21:33:49.414815777 +0000
@@ -350,7 +350,7 @@
 	spi_gpio->bitbang.master = spi_master_get(master);
 	spi_gpio->bitbang.chipselect = spi_gpio_chipselect;
 
-	if ((master_flags & (SPI_MASTER_NO_RX | SPI_MASTER_NO_RX)) == 0) {
+	if ((master_flags & (SPI_MASTER_NO_TX | SPI_MASTER_NO_RX)) == 0) {
 		spi_gpio->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;
 		spi_gpio->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;
 		spi_gpio->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;
diff -urN linux-2.6.36-rc6/drivers/spi/spi_mpc8xxx.c linux-2.6.36-rc7/drivers/spi/spi_mpc8xxx.c
--- linux-2.6.36-rc6/drivers/spi/spi_mpc8xxx.c	2010-10-06 21:33:44.489378321 +0000
+++ linux-2.6.36-rc7/drivers/spi/spi_mpc8xxx.c	2010-10-06 21:33:49.414815777 +0000
@@ -408,11 +408,17 @@
 
 	xfer_ofs = mspi->xfer_in_progress->len - mspi->count;
 
-	out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma + xfer_ofs);
+	if (mspi->rx_dma == mspi->dma_dummy_rx)
+		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma);
+	else
+		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma + xfer_ofs);
 	out_be16(&rx_bd->cbd_datlen, 0);
 	out_be16(&rx_bd->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT | BD_SC_WRAP);
 
-	out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma + xfer_ofs);
+	if (mspi->tx_dma == mspi->dma_dummy_tx)
+		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma);
+	else
+		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma + xfer_ofs);
 	out_be16(&tx_bd->cbd_datlen, xfer_len);
 	out_be16(&tx_bd->cbd_sc, BD_SC_READY | BD_SC_INTRPT | BD_SC_WRAP |
 				 BD_SC_LAST);
diff -urN linux-2.6.36-rc6/drivers/xen/xenbus/xenbus_probe.c linux-2.6.36-rc7/drivers/xen/xenbus/xenbus_probe.c
--- linux-2.6.36-rc6/drivers/xen/xenbus/xenbus_probe.c	2010-10-06 21:33:44.859503662 +0000
+++ linux-2.6.36-rc7/drivers/xen/xenbus/xenbus_probe.c	2010-10-06 21:33:49.717815799 +0000
@@ -755,7 +755,10 @@
 {
 	int ret = 0;
 
-	blocking_notifier_chain_register(&xenstore_chain, nb);
+	if (xenstored_ready > 0)
+		ret = nb->notifier_call(nb, 0, NULL);
+	else
+		blocking_notifier_chain_register(&xenstore_chain, nb);
 
 	return ret;
 }
@@ -769,7 +772,7 @@
 
 void xenbus_probe(struct work_struct *unused)
 {
-	BUG_ON((xenstored_ready <= 0));
+	xenstored_ready = 1;
 
 	/* Enumerate devices in xenstore and watch for changes. */
 	xenbus_probe_devices(&xenbus_frontend);
@@ -835,8 +838,8 @@
 			xen_store_evtchn = xen_start_info->store_evtchn;
 			xen_store_mfn = xen_start_info->store_mfn;
 			xen_store_interface = mfn_to_virt(xen_store_mfn);
+			xenstored_ready = 1;
 		}
-		xenstored_ready = 1;
 	}
 
 	/* Initialize the interface to xenstore. */
diff -urN linux-2.6.36-rc6/fs/cifs/cifssmb.c linux-2.6.36-rc7/fs/cifs/cifssmb.c
--- linux-2.6.36-rc6/fs/cifs/cifssmb.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/fs/cifs/cifssmb.c	2010-10-06 21:33:49.742759134 +0000
@@ -232,7 +232,7 @@
 small_smb_init(int smb_command, int wct, struct cifsTconInfo *tcon,
 		void **request_buf)
 {
-	int rc = 0;
+	int rc;
 
 	rc = cifs_reconnect_tcon(tcon, smb_command);
 	if (rc)
@@ -250,7 +250,7 @@
 	if (tcon != NULL)
 		cifs_stats_inc(&tcon->num_smbs_sent);
 
-	return rc;
+	return 0;
 }
 
 int
@@ -281,16 +281,9 @@
 
 /* If the return code is zero, this function must fill in request_buf pointer */
 static int
-smb_init(int smb_command, int wct, struct cifsTconInfo *tcon,
-	 void **request_buf /* returned */ ,
-	 void **response_buf /* returned */ )
+__smb_init(int smb_command, int wct, struct cifsTconInfo *tcon,
+			void **request_buf, void **response_buf)
 {
-	int rc = 0;
-
-	rc = cifs_reconnect_tcon(tcon, smb_command);
-	if (rc)
-		return rc;
-
 	*request_buf = cifs_buf_get();
 	if (*request_buf == NULL) {
 		/* BB should we add a retry in here if not a writepage? */
@@ -309,7 +302,31 @@
 	if (tcon != NULL)
 		cifs_stats_inc(&tcon->num_smbs_sent);
 
-	return rc;
+	return 0;
+}
+
+/* If the return code is zero, this function must fill in request_buf pointer */
+static int
+smb_init(int smb_command, int wct, struct cifsTconInfo *tcon,
+	 void **request_buf, void **response_buf)
+{
+	int rc;
+
+	rc = cifs_reconnect_tcon(tcon, smb_command);
+	if (rc)
+		return rc;
+
+	return __smb_init(smb_command, wct, tcon, request_buf, response_buf);
+}
+
+static int
+smb_init_no_reconnect(int smb_command, int wct, struct cifsTconInfo *tcon,
+			void **request_buf, void **response_buf)
+{
+	if (tcon->ses->need_reconnect || tcon->need_reconnect)
+		return -EHOSTDOWN;
+
+	return __smb_init(smb_command, wct, tcon, request_buf, response_buf);
 }
 
 static int validate_t2(struct smb_t2_rsp *pSMB)
@@ -4534,8 +4551,8 @@
 
 	cFYI(1, "In QFSUnixInfo");
 QFSUnixRetry:
-	rc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,
-		      (void **) &pSMBr);
+	rc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,
+				   (void **) &pSMB, (void **) &pSMBr);
 	if (rc)
 		return rc;
 
@@ -4604,8 +4621,8 @@
 	cFYI(1, "In SETFSUnixInfo");
 SETFSUnixRetry:
 	/* BB switch to small buf init to save memory */
-	rc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,
-		      (void **) &pSMBr);
+	rc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,
+					(void **) &pSMB, (void **) &pSMBr);
 	if (rc)
 		return rc;
 
diff -urN linux-2.6.36-rc6/fs/cifs/inode.c linux-2.6.36-rc7/fs/cifs/inode.c
--- linux-2.6.36-rc6/fs/cifs/inode.c	2010-10-06 21:33:44.900503818 +0000
+++ linux-2.6.36-rc7/fs/cifs/inode.c	2010-10-06 21:33:49.744815824 +0000
@@ -801,6 +801,8 @@
 			inode->i_flags |= S_NOATIME | S_NOCMTIME;
 		if (inode->i_state & I_NEW) {
 			inode->i_ino = hash;
+			if (S_ISREG(inode->i_mode))
+				inode->i_data.backing_dev_info = sb->s_bdi;
 #ifdef CONFIG_CIFS_FSCACHE
 			/* initialize per-inode cache cookie pointer */
 			CIFS_I(inode)->fscache = NULL;
diff -urN linux-2.6.36-rc6/fs/fs-writeback.c linux-2.6.36-rc7/fs/fs-writeback.c
--- linux-2.6.36-rc6/fs/fs-writeback.c	2010-10-06 21:33:44.928503732 +0000
+++ linux-2.6.36-rc7/fs/fs-writeback.c	2010-10-06 21:33:49.764815801 +0000
@@ -72,22 +72,11 @@
 static inline struct backing_dev_info *inode_to_bdi(struct inode *inode)
 {
 	struct super_block *sb = inode->i_sb;
-	struct backing_dev_info *bdi = inode->i_mapping->backing_dev_info;
 
-	/*
-	 * For inodes on standard filesystems, we use superblock's bdi. For
-	 * inodes on virtual filesystems, we want to use inode mapping's bdi
-	 * because they can possibly point to something useful (think about
-	 * block_dev filesystem).
-	 */
-	if (sb->s_bdi && sb->s_bdi != &noop_backing_dev_info) {
-		/* Some device inodes could play dirty tricks. Catch them... */
-		WARN(bdi != sb->s_bdi && bdi_cap_writeback_dirty(bdi),
-			"Dirtiable inode bdi %s != sb bdi %s\n",
-			bdi->name, sb->s_bdi->name);
-		return sb->s_bdi;
-	}
-	return bdi;
+	if (strcmp(sb->s_type->name, "bdev") == 0)
+		return inode->i_mapping->backing_dev_info;
+
+	return sb->s_bdi;
 }
 
 static void bdi_queue_work(struct backing_dev_info *bdi,
diff -urN linux-2.6.36-rc6/fs/fuse/dev.c linux-2.6.36-rc7/fs/fuse/dev.c
--- linux-2.6.36-rc6/fs/fuse/dev.c	2010-10-06 21:33:44.930503708 +0000
+++ linux-2.6.36-rc7/fs/fuse/dev.c	2010-10-06 21:33:49.766815845 +0000
@@ -1354,7 +1354,7 @@
 	loff_t file_size;
 	unsigned int num;
 	unsigned int offset;
-	size_t total_len;
+	size_t total_len = 0;
 
 	req = fuse_get_req(fc);
 	if (IS_ERR(req))
diff -urN linux-2.6.36-rc6/fs/ocfs2/symlink.c linux-2.6.36-rc7/fs/ocfs2/symlink.c
--- linux-2.6.36-rc6/fs/ocfs2/symlink.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/fs/ocfs2/symlink.c	2010-10-06 21:33:49.818815784 +0000
@@ -128,7 +128,7 @@
 	}
 
 	/* Fast symlinks can't be large */
-	len = strlen(target);
+	len = strnlen(target, ocfs2_fast_symlink_chars(inode->i_sb));
 	link = kzalloc(len + 1, GFP_NOFS);
 	if (!link) {
 		status = -ENOMEM;
diff -urN linux-2.6.36-rc6/fs/proc/base.c linux-2.6.36-rc7/fs/proc/base.c
--- linux-2.6.36-rc6/fs/proc/base.c	2010-10-06 21:33:45.013503255 +0000
+++ linux-2.6.36-rc7/fs/proc/base.c	2010-10-06 21:33:49.823815844 +0000
@@ -2675,7 +2675,7 @@
 	INF("auxv",       S_IRUSR, proc_pid_auxv),
 	ONE("status",     S_IRUGO, proc_pid_status),
 	ONE("personality", S_IRUSR, proc_pid_personality),
-	INF("limits",	  S_IRUSR, proc_pid_limits),
+	INF("limits",	  S_IRUGO, proc_pid_limits),
 #ifdef CONFIG_SCHED_DEBUG
 	REG("sched",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),
 #endif
@@ -3011,7 +3011,7 @@
 	INF("auxv",      S_IRUSR, proc_pid_auxv),
 	ONE("status",    S_IRUGO, proc_pid_status),
 	ONE("personality", S_IRUSR, proc_pid_personality),
-	INF("limits",	 S_IRUSR, proc_pid_limits),
+	INF("limits",	 S_IRUGO, proc_pid_limits),
 #ifdef CONFIG_SCHED_DEBUG
 	REG("sched",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),
 #endif
diff -urN linux-2.6.36-rc6/fs/reiserfs/ioctl.c linux-2.6.36-rc7/fs/reiserfs/ioctl.c
--- linux-2.6.36-rc6/fs/reiserfs/ioctl.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/fs/reiserfs/ioctl.c	2010-10-06 21:33:49.826815803 +0000
@@ -170,6 +170,7 @@
 int reiserfs_unpack(struct inode *inode, struct file *filp)
 {
 	int retval = 0;
+	int depth;
 	int index;
 	struct page *page;
 	struct address_space *mapping;
@@ -188,8 +189,8 @@
 	/* we need to make sure nobody is changing the file size beneath
 	 ** us
 	 */
-	mutex_lock(&inode->i_mutex);
-	reiserfs_write_lock(inode->i_sb);
+	reiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);
+	depth = reiserfs_write_lock_once(inode->i_sb);
 
 	write_from = inode->i_size & (blocksize - 1);
 	/* if we are on a block boundary, we are already unpacked.  */
@@ -224,6 +225,6 @@
 
       out:
 	mutex_unlock(&inode->i_mutex);
-	reiserfs_write_unlock(inode->i_sb);
+	reiserfs_write_unlock_once(inode->i_sb, depth);
 	return retval;
 }
diff -urN linux-2.6.36-rc6/fs/xfs/xfs_log_cil.c linux-2.6.36-rc7/fs/xfs/xfs_log_cil.c
--- linux-2.6.36-rc6/fs/xfs/xfs_log_cil.c	2010-10-06 21:33:45.058503780 +0000
+++ linux-2.6.36-rc7/fs/xfs/xfs_log_cil.c	2010-10-06 21:33:49.854815787 +0000
@@ -405,9 +405,15 @@
 	new_ctx = kmem_zalloc(sizeof(*new_ctx), KM_SLEEP|KM_NOFS);
 	new_ctx->ticket = xlog_cil_ticket_alloc(log);
 
-	/* lock out transaction commit, but don't block on background push */
+	/*
+	 * Lock out transaction commit, but don't block for background pushes
+	 * unless we are well over the CIL space limit. See the definition of
+	 * XLOG_CIL_HARD_SPACE_LIMIT() for the full explanation of the logic
+	 * used here.
+	 */
 	if (!down_write_trylock(&cil->xc_ctx_lock)) {
-		if (!push_seq)
+		if (!push_seq &&
+		    cil->xc_ctx->space_used < XLOG_CIL_HARD_SPACE_LIMIT(log))
 			goto out_free_ticket;
 		down_write(&cil->xc_ctx_lock);
 	}
@@ -422,7 +428,7 @@
 		goto out_skip;
 
 	/* check for a previously pushed seqeunce */
-	if (push_seq < cil->xc_ctx->sequence)
+	if (push_seq && push_seq < cil->xc_ctx->sequence)
 		goto out_skip;
 
 	/*
diff -urN linux-2.6.36-rc6/fs/xfs/xfs_log_priv.h linux-2.6.36-rc7/fs/xfs/xfs_log_priv.h
--- linux-2.6.36-rc6/fs/xfs/xfs_log_priv.h	2010-10-06 21:33:45.058503780 +0000
+++ linux-2.6.36-rc7/fs/xfs/xfs_log_priv.h	2010-10-06 21:33:49.854815787 +0000
@@ -426,13 +426,13 @@
 };
 
 /*
- * The amount of log space we should the CIL to aggregate is difficult to size.
- * Whatever we chose we have to make we can get a reservation for the log space
- * effectively, that it is large enough to capture sufficient relogging to
- * reduce log buffer IO significantly, but it is not too large for the log or
- * induces too much latency when writing out through the iclogs. We track both
- * space consumed and the number of vectors in the checkpoint context, so we
- * need to decide which to use for limiting.
+ * The amount of log space we allow the CIL to aggregate is difficult to size.
+ * Whatever we choose, we have to make sure we can get a reservation for the
+ * log space effectively, that it is large enough to capture sufficient
+ * relogging to reduce log buffer IO significantly, but it is not too large for
+ * the log or induces too much latency when writing out through the iclogs. We
+ * track both space consumed and the number of vectors in the checkpoint
+ * context, so we need to decide which to use for limiting.
  *
  * Every log buffer we write out during a push needs a header reserved, which
  * is at least one sector and more for v2 logs. Hence we need a reservation of
@@ -459,16 +459,21 @@
  * checkpoint transaction ticket is specific to the checkpoint context, rather
  * than the CIL itself.
  *
- * With dynamic reservations, we can basically make up arbitrary limits for the
- * checkpoint size so long as they don't violate any other size rules.  Hence
- * the initial maximum size for the checkpoint transaction will be set to a
- * quarter of the log or 8MB, which ever is smaller. 8MB is an arbitrary limit
- * right now based on the latency of writing out a large amount of data through
- * the circular iclog buffers.
+ * With dynamic reservations, we can effectively make up arbitrary limits for
+ * the checkpoint size so long as they don't violate any other size rules.
+ * Recovery imposes a rule that no transaction exceed half the log, so we are
+ * limited by that.  Furthermore, the log transaction reservation subsystem
+ * tries to keep 25% of the log free, so we need to keep below that limit or we
+ * risk running out of free log space to start any new transactions.
+ *
+ * In order to keep background CIL push efficient, we will set a lower
+ * threshold at which background pushing is attempted without blocking current
+ * transaction commits.  A separate, higher bound defines when CIL pushes are
+ * enforced to ensure we stay within our maximum checkpoint size bounds.
+ * threshold, yet give us plenty of space for aggregation on large logs.
  */
-
-#define XLOG_CIL_SPACE_LIMIT(log)	\
-	(min((log->l_logsize >> 2), (8 * 1024 * 1024)))
+#define XLOG_CIL_SPACE_LIMIT(log)	(log->l_logsize >> 3)
+#define XLOG_CIL_HARD_SPACE_LIMIT(log)	(3 * (log->l_logsize >> 4))
 
 /*
  * The reservation head lsn is not made up of a cycle number and block number.
diff -urN linux-2.6.36-rc6/include/acpi/acpixf.h linux-2.6.36-rc7/include/acpi/acpixf.h
--- linux-2.6.36-rc6/include/acpi/acpixf.h	2010-10-06 21:33:45.065503812 +0000
+++ linux-2.6.36-rc7/include/acpi/acpixf.h	2010-10-06 21:33:49.859815838 +0000
@@ -55,7 +55,7 @@
 extern u8 acpi_gbl_permanent_mmap;
 
 /*
- * Globals that are publically available, allowing for
+ * Globals that are publicly available, allowing for
  * run time configuration
  */
 extern u32 acpi_dbg_level;
diff -urN linux-2.6.36-rc6/include/drm/drmP.h linux-2.6.36-rc7/include/drm/drmP.h
--- linux-2.6.36-rc6/include/drm/drmP.h	2010-10-06 21:33:45.070504062 +0000
+++ linux-2.6.36-rc7/include/drm/drmP.h	2010-10-06 21:33:49.862532539 +0000
@@ -612,7 +612,7 @@
 	struct kref refcount;
 
 	/** Handle count of this object. Each handle also holds a reference */
-	struct kref handlecount;
+	atomic_t handle_count; /* number of handles on this object */
 
 	/** Related drm device */
 	struct drm_device *dev;
@@ -808,7 +808,6 @@
 	 */
 	int (*gem_init_object) (struct drm_gem_object *obj);
 	void (*gem_free_object) (struct drm_gem_object *obj);
-	void (*gem_free_object_unlocked) (struct drm_gem_object *obj);
 
 	/* vga arb irq handler */
 	void (*vgaarb_irq)(struct drm_device *dev, bool state);
@@ -1175,6 +1174,7 @@
 extern int drm_mmap(struct file *filp, struct vm_area_struct *vma);
 extern int drm_mmap_locked(struct file *filp, struct vm_area_struct *vma);
 extern void drm_vm_open_locked(struct vm_area_struct *vma);
+extern void drm_vm_close_locked(struct vm_area_struct *vma);
 extern resource_size_t drm_core_get_map_ofs(struct drm_local_map * map);
 extern resource_size_t drm_core_get_reg_ofs(struct drm_device *dev);
 extern unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
@@ -1455,12 +1455,11 @@
 void drm_gem_destroy(struct drm_device *dev);
 void drm_gem_object_release(struct drm_gem_object *obj);
 void drm_gem_object_free(struct kref *kref);
-void drm_gem_object_free_unlocked(struct kref *kref);
 struct drm_gem_object *drm_gem_object_alloc(struct drm_device *dev,
 					    size_t size);
 int drm_gem_object_init(struct drm_device *dev,
 			struct drm_gem_object *obj, size_t size);
-void drm_gem_object_handle_free(struct kref *kref);
+void drm_gem_object_handle_free(struct drm_gem_object *obj);
 void drm_gem_vm_open(struct vm_area_struct *vma);
 void drm_gem_vm_close(struct vm_area_struct *vma);
 int drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
@@ -1483,8 +1482,12 @@
 static inline void
 drm_gem_object_unreference_unlocked(struct drm_gem_object *obj)
 {
-	if (obj != NULL)
-		kref_put(&obj->refcount, drm_gem_object_free_unlocked);
+	if (obj != NULL) {
+		struct drm_device *dev = obj->dev;
+		mutex_lock(&dev->struct_mutex);
+		kref_put(&obj->refcount, drm_gem_object_free);
+		mutex_unlock(&dev->struct_mutex);
+	}
 }
 
 int drm_gem_handle_create(struct drm_file *file_priv,
@@ -1495,7 +1498,7 @@
 drm_gem_object_handle_reference(struct drm_gem_object *obj)
 {
 	drm_gem_object_reference(obj);
-	kref_get(&obj->handlecount);
+	atomic_inc(&obj->handle_count);
 }
 
 static inline void
@@ -1504,12 +1507,15 @@
 	if (obj == NULL)
 		return;
 
+	if (atomic_read(&obj->handle_count) == 0)
+		return;
 	/*
 	 * Must bump handle count first as this may be the last
 	 * ref, in which case the object would disappear before we
 	 * checked for a name
 	 */
-	kref_put(&obj->handlecount, drm_gem_object_handle_free);
+	if (atomic_dec_and_test(&obj->handle_count))
+		drm_gem_object_handle_free(obj);
 	drm_gem_object_unreference(obj);
 }
 
@@ -1519,12 +1525,17 @@
 	if (obj == NULL)
 		return;
 
+	if (atomic_read(&obj->handle_count) == 0)
+		return;
+
 	/*
 	* Must bump handle count first as this may be the last
 	* ref, in which case the object would disappear before we
 	* checked for a name
 	*/
-	kref_put(&obj->handlecount, drm_gem_object_handle_free);
+
+	if (atomic_dec_and_test(&obj->handle_count))
+		drm_gem_object_handle_free(obj);
 	drm_gem_object_unreference_unlocked(obj);
 }
 
diff -urN linux-2.6.36-rc6/include/drm/drm_pciids.h linux-2.6.36-rc7/include/drm/drm_pciids.h
--- linux-2.6.36-rc6/include/drm/drm_pciids.h	2010-10-06 21:33:45.071503668 +0000
+++ linux-2.6.36-rc7/include/drm/drm_pciids.h	2010-10-06 21:33:49.863815748 +0000
@@ -85,7 +85,6 @@
 	{0x1002, 0x5460, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
 	{0x1002, 0x5462, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
 	{0x1002, 0x5464, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_IS_MOBILITY}, \
-	{0x1002, 0x5657, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV380|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x5548, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x5549, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x554A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_R423|RADEON_NEW_MEMMAP}, \
@@ -103,6 +102,7 @@
 	{0x1002, 0x564F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x5652, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x5653, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x5657, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RV410|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x5834, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP}, \
 	{0x1002, 0x5835, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY}, \
 	{0x1002, 0x5954, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART}, \
diff -urN linux-2.6.36-rc6/include/linux/cpuidle.h linux-2.6.36-rc7/include/linux/cpuidle.h
--- linux-2.6.36-rc6/include/linux/cpuidle.h	2010-10-06 21:33:45.079503601 +0000
+++ linux-2.6.36-rc7/include/linux/cpuidle.h	2010-10-06 21:33:49.869816064 +0000
@@ -53,6 +53,7 @@
 #define CPUIDLE_FLAG_BALANCED	(0x40) /* medium latency, moderate savings */
 #define CPUIDLE_FLAG_DEEP	(0x80) /* high latency, large savings */
 #define CPUIDLE_FLAG_IGNORE	(0x100) /* ignore during this idle period */
+#define CPUIDLE_FLAG_TLB_FLUSHED (0x200) /* tlb will be flushed */
 
 #define CPUIDLE_DRIVER_FLAGS_MASK (0xFFFF0000)
 
diff -urN linux-2.6.36-rc6/include/linux/dmaengine.h linux-2.6.36-rc7/include/linux/dmaengine.h
--- linux-2.6.36-rc6/include/linux/dmaengine.h	2010-10-06 21:33:45.081503392 +0000
+++ linux-2.6.36-rc7/include/linux/dmaengine.h	2010-10-06 21:33:49.870815798 +0000
@@ -548,7 +548,7 @@
 	return (dma->max_pq & DMA_HAS_PQ_CONTINUE) == DMA_HAS_PQ_CONTINUE;
 }
 
-static unsigned short dma_dev_to_maxpq(struct dma_device *dma)
+static inline unsigned short dma_dev_to_maxpq(struct dma_device *dma)
 {
 	return dma->max_pq & ~DMA_HAS_PQ_CONTINUE;
 }
diff -urN linux-2.6.36-rc6/include/linux/module.h linux-2.6.36-rc7/include/linux/module.h
--- linux-2.6.36-rc6/include/linux/module.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/include/linux/module.h	2010-10-06 21:33:49.887815792 +0000
@@ -686,17 +686,16 @@
 
 
 #ifdef CONFIG_GENERIC_BUG
-int  module_bug_finalize(const Elf_Ehdr *, const Elf_Shdr *,
+void module_bug_finalize(const Elf_Ehdr *, const Elf_Shdr *,
 			 struct module *);
 void module_bug_cleanup(struct module *);
 
 #else	/* !CONFIG_GENERIC_BUG */
 
-static inline int  module_bug_finalize(const Elf_Ehdr *hdr,
+static inline void module_bug_finalize(const Elf_Ehdr *hdr,
 					const Elf_Shdr *sechdrs,
 					struct module *mod)
 {
-	return 0;
 }
 static inline void module_bug_cleanup(struct module *mod) {}
 #endif	/* CONFIG_GENERIC_BUG */
diff -urN linux-2.6.36-rc6/include/linux/rcupdate.h linux-2.6.36-rc7/include/linux/rcupdate.h
--- linux-2.6.36-rc6/include/linux/rcupdate.h	2010-10-06 21:33:45.121691022 +0000
+++ linux-2.6.36-rc7/include/linux/rcupdate.h	2010-10-06 21:33:49.898427187 +0000
@@ -454,7 +454,7 @@
  * Makes rcu_dereference_check() do the dirty work.
  */
 #define rcu_dereference_bh(p) \
-		rcu_dereference_check(p, rcu_read_lock_bh_held())
+		rcu_dereference_check(p, rcu_read_lock_bh_held() || irqs_disabled())
 
 /**
  * rcu_dereference_sched - fetch RCU-protected pointer, checking for RCU-sched
diff -urN linux-2.6.36-rc6/include/linux/wait.h linux-2.6.36-rc7/include/linux/wait.h
--- linux-2.6.36-rc6/include/linux/wait.h	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/include/linux/wait.h	2010-10-06 21:33:49.908383261 +0000
@@ -614,6 +614,7 @@
 		(wait)->private = current;				\
 		(wait)->func = autoremove_wake_function;		\
 		INIT_LIST_HEAD(&(wait)->task_list);			\
+		(wait)->flags = 0;					\
 	} while (0)
 
 /**
diff -urN linux-2.6.36-rc6/ipc/sem.c linux-2.6.36-rc7/ipc/sem.c
--- linux-2.6.36-rc6/ipc/sem.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/ipc/sem.c	2010-10-06 21:33:49.931816518 +0000
@@ -743,6 +743,8 @@
 	    {
 		struct semid_ds out;
 
+		memset(&out, 0, sizeof(out));
+
 		ipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);
 
 		out.sem_otime	= in->sem_otime;
diff -urN linux-2.6.36-rc6/kernel/kfifo.c linux-2.6.36-rc7/kernel/kfifo.c
--- linux-2.6.36-rc6/kernel/kfifo.c	2010-10-06 21:33:45.172379800 +0000
+++ linux-2.6.36-rc7/kernel/kfifo.c	2010-10-06 21:33:49.939816196 +0000
@@ -365,8 +365,6 @@
 	n = setup_sgl_buf(sgl, fifo->data + off, nents, l);
 	n += setup_sgl_buf(sgl + n, fifo->data, nents - n, len - l);
 
-	if (n)
-		sg_mark_end(sgl + n - 1);
 	return n;
 }
 
diff -urN linux-2.6.36-rc6/kernel/module.c linux-2.6.36-rc7/kernel/module.c
--- linux-2.6.36-rc6/kernel/module.c	2010-10-06 21:33:45.174815793 +0000
+++ linux-2.6.36-rc7/kernel/module.c	2010-10-06 21:33:49.941725466 +0000
@@ -1537,6 +1537,7 @@
 {
 	struct module *mod = _mod;
 	list_del(&mod->list);
+	module_bug_cleanup(mod);
 	return 0;
 }
 
@@ -2625,6 +2626,7 @@
 	if (err < 0)
 		goto ddebug;
 
+	module_bug_finalize(info.hdr, info.sechdrs, mod);
 	list_add_rcu(&mod->list, &modules);
 	mutex_unlock(&module_mutex);
 
@@ -2650,6 +2652,8 @@
 	mutex_lock(&module_mutex);
 	/* Unlink carefully: kallsyms could be walking list. */
 	list_del_rcu(&mod->list);
+	module_bug_cleanup(mod);
+
  ddebug:
 	if (!mod->taints)
 		dynamic_debug_remove(info.debug);
diff -urN linux-2.6.36-rc6/kernel/smp.c linux-2.6.36-rc7/kernel/smp.c
--- linux-2.6.36-rc6/kernel/smp.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/kernel/smp.c	2010-10-06 21:33:49.953815785 +0000
@@ -365,9 +365,10 @@
 EXPORT_SYMBOL_GPL(smp_call_function_any);
 
 /**
- * __smp_call_function_single(): Run a function on another CPU
+ * __smp_call_function_single(): Run a function on a specific CPU
  * @cpu: The CPU to run on.
  * @data: Pre-allocated and setup data structure
+ * @wait: If true, wait until function has completed on specified CPU.
  *
  * Like smp_call_function_single(), but allow caller to pass in a
  * pre-allocated data structure. Useful for embedding @data inside
@@ -376,8 +377,10 @@
 void __smp_call_function_single(int cpu, struct call_single_data *data,
 				int wait)
 {
-	csd_lock(data);
+	unsigned int this_cpu;
+	unsigned long flags;
 
+	this_cpu = get_cpu();
 	/*
 	 * Can deadlock when called with interrupts disabled.
 	 * We allow cpu's that are not yet online though, as no one else can
@@ -387,7 +390,15 @@
 	WARN_ON_ONCE(cpu_online(smp_processor_id()) && wait && irqs_disabled()
 		     && !oops_in_progress);
 
-	generic_exec_single(cpu, data, wait);
+	if (cpu == this_cpu) {
+		local_irq_save(flags);
+		data->func(data->info);
+		local_irq_restore(flags);
+	} else {
+		csd_lock(data);
+		generic_exec_single(cpu, data, wait);
+	}
+	put_cpu();
 }
 
 /**
diff -urN linux-2.6.36-rc6/lib/bug.c linux-2.6.36-rc7/lib/bug.c
--- linux-2.6.36-rc6/lib/bug.c	2010-10-06 21:33:45.198815807 +0000
+++ linux-2.6.36-rc7/lib/bug.c	2010-10-06 21:33:49.966815753 +0000
@@ -72,8 +72,8 @@
 	return NULL;
 }
 
-int module_bug_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
-			struct module *mod)
+void module_bug_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
+			 struct module *mod)
 {
 	char *secstrings;
 	unsigned int i;
@@ -97,8 +97,6 @@
 	 * could potentially lead to deadlock and thus be counter-productive.
 	 */
 	list_add(&mod->bug_list, &module_bug_list);
-
-	return 0;
 }
 
 void module_bug_cleanup(struct module *mod)
diff -urN linux-2.6.36-rc6/lib/list_sort.c linux-2.6.36-rc7/lib/list_sort.c
--- linux-2.6.36-rc6/lib/list_sort.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/lib/list_sort.c	2010-10-06 21:33:49.967815815 +0000
@@ -70,7 +70,7 @@
 		 * element comparison is needed, so the client's cmp()
 		 * routine can invoke cond_resched() periodically.
 		 */
-		(*cmp)(priv, tail, tail);
+		(*cmp)(priv, tail->next, tail->next);
 
 		tail->next->prev = tail;
 		tail = tail->next;
diff -urN linux-2.6.36-rc6/mm/ksm.c linux-2.6.36-rc7/mm/ksm.c
--- linux-2.6.36-rc6/mm/ksm.c	2010-10-06 21:33:45.206815865 +0000
+++ linux-2.6.36-rc7/mm/ksm.c	2010-10-06 21:33:49.973815915 +0000
@@ -712,7 +712,7 @@
 	if (!ptep)
 		goto out;
 
-	if (pte_write(*ptep)) {
+	if (pte_write(*ptep) || pte_dirty(*ptep)) {
 		pte_t entry;
 
 		swapped = PageSwapCache(page);
@@ -735,7 +735,9 @@
 			set_pte_at(mm, addr, ptep, entry);
 			goto out_unlock;
 		}
-		entry = pte_wrprotect(entry);
+		if (pte_dirty(entry))
+			set_page_dirty(page);
+		entry = pte_mkclean(pte_wrprotect(entry));
 		set_pte_at_notify(mm, addr, ptep, entry);
 	}
 	*orig_pte = *ptep;
diff -urN linux-2.6.36-rc6/mm/rmap.c linux-2.6.36-rc7/mm/rmap.c
--- linux-2.6.36-rc6/mm/rmap.c	2010-10-06 21:33:45.213815963 +0000
+++ linux-2.6.36-rc7/mm/rmap.c	2010-10-06 21:33:49.980815781 +0000
@@ -381,7 +381,13 @@
 unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)
 {
 	if (PageAnon(page)) {
-		if (vma->anon_vma->root != page_anon_vma(page)->root)
+		struct anon_vma *page__anon_vma = page_anon_vma(page);
+		/*
+		 * Note: swapoff's unuse_vma() is more efficient with this
+		 * check, and needs it to match anon_vma when KSM is active.
+		 */
+		if (!vma->anon_vma || !page__anon_vma ||
+		    vma->anon_vma->root != page__anon_vma->root)
 			return -EFAULT;
 	} else if (page->mapping && !(vma->vm_flags & VM_NONLINEAR)) {
 		if (!vma->vm_file ||
diff -urN linux-2.6.36-rc6/net/8021q/vlan_core.c linux-2.6.36-rc7/net/8021q/vlan_core.c
--- linux-2.6.36-rc6/net/8021q/vlan_core.c	2010-10-06 21:33:45.218815760 +0000
+++ linux-2.6.36-rc7/net/8021q/vlan_core.c	2010-10-06 21:33:49.985749110 +0000
@@ -24,8 +24,11 @@
 
 	if (vlan_dev)
 		skb->dev = vlan_dev;
-	else if (vlan_id)
-		goto drop;
+	else if (vlan_id) {
+		if (!(skb->dev->flags & IFF_PROMISC))
+			goto drop;
+		skb->pkt_type = PACKET_OTHERHOST;
+	}
 
 	return (polling ? netif_receive_skb(skb) : netif_rx(skb));
 
@@ -102,8 +105,11 @@
 
 	if (vlan_dev)
 		skb->dev = vlan_dev;
-	else if (vlan_id)
-		goto drop;
+	else if (vlan_id) {
+		if (!(skb->dev->flags & IFF_PROMISC))
+			goto drop;
+		skb->pkt_type = PACKET_OTHERHOST;
+	}
 
 	for (p = napi->gro_list; p; p = p->next) {
 		NAPI_GRO_CB(p)->same_flow =
diff -urN linux-2.6.36-rc6/net/ipv4/Kconfig linux-2.6.36-rc7/net/ipv4/Kconfig
--- linux-2.6.36-rc6/net/ipv4/Kconfig	2010-10-06 21:33:45.238815802 +0000
+++ linux-2.6.36-rc7/net/ipv4/Kconfig	2010-10-06 21:33:50.006815967 +0000
@@ -217,6 +217,7 @@
 
 config NET_IPGRE
 	tristate "IP: GRE tunnels over IP"
+	depends on IPV6 || IPV6=n
 	help
 	  Tunneling means encapsulating data of one protocol type within
 	  another protocol and sending it over a channel that understands the
diff -urN linux-2.6.36-rc6/net/ipv4/tcp_timer.c linux-2.6.36-rc7/net/ipv4/tcp_timer.c
--- linux-2.6.36-rc6/net/ipv4/tcp_timer.c	2010-10-06 21:33:45.252818044 +0000
+++ linux-2.6.36-rc7/net/ipv4/tcp_timer.c	2010-10-06 21:33:50.021815815 +0000
@@ -135,13 +135,16 @@
 
 /* This function calculates a "timeout" which is equivalent to the timeout of a
  * TCP connection after "boundary" unsuccessful, exponentially backed-off
- * retransmissions with an initial RTO of TCP_RTO_MIN.
+ * retransmissions with an initial RTO of TCP_RTO_MIN or TCP_TIMEOUT_INIT if
+ * syn_set flag is set.
  */
 static bool retransmits_timed_out(struct sock *sk,
-				  unsigned int boundary)
+				  unsigned int boundary,
+				  bool syn_set)
 {
 	unsigned int timeout, linear_backoff_thresh;
 	unsigned int start_ts;
+	unsigned int rto_base = syn_set ? TCP_TIMEOUT_INIT : TCP_RTO_MIN;
 
 	if (!inet_csk(sk)->icsk_retransmits)
 		return false;
@@ -151,12 +154,12 @@
 	else
 		start_ts = tcp_sk(sk)->retrans_stamp;
 
-	linear_backoff_thresh = ilog2(TCP_RTO_MAX/TCP_RTO_MIN);
+	linear_backoff_thresh = ilog2(TCP_RTO_MAX/rto_base);
 
 	if (boundary <= linear_backoff_thresh)
-		timeout = ((2 << boundary) - 1) * TCP_RTO_MIN;
+		timeout = ((2 << boundary) - 1) * rto_base;
 	else
-		timeout = ((2 << linear_backoff_thresh) - 1) * TCP_RTO_MIN +
+		timeout = ((2 << linear_backoff_thresh) - 1) * rto_base +
 			  (boundary - linear_backoff_thresh) * TCP_RTO_MAX;
 
 	return (tcp_time_stamp - start_ts) >= timeout;
@@ -167,14 +170,15 @@
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	int retry_until;
-	bool do_reset;
+	bool do_reset, syn_set = 0;
 
 	if ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
 		if (icsk->icsk_retransmits)
 			dst_negative_advice(sk);
 		retry_until = icsk->icsk_syn_retries ? : sysctl_tcp_syn_retries;
+		syn_set = 1;
 	} else {
-		if (retransmits_timed_out(sk, sysctl_tcp_retries1)) {
+		if (retransmits_timed_out(sk, sysctl_tcp_retries1, 0)) {
 			/* Black hole detection */
 			tcp_mtu_probing(icsk, sk);
 
@@ -187,14 +191,14 @@
 
 			retry_until = tcp_orphan_retries(sk, alive);
 			do_reset = alive ||
-				   !retransmits_timed_out(sk, retry_until);
+				   !retransmits_timed_out(sk, retry_until, 0);
 
 			if (tcp_out_of_resources(sk, do_reset))
 				return 1;
 		}
 	}
 
-	if (retransmits_timed_out(sk, retry_until)) {
+	if (retransmits_timed_out(sk, retry_until, syn_set)) {
 		/* Has it gone just too far? */
 		tcp_write_err(sk);
 		return 1;
@@ -436,7 +440,7 @@
 		icsk->icsk_rto = min(icsk->icsk_rto << 1, TCP_RTO_MAX);
 	}
 	inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk->icsk_rto, TCP_RTO_MAX);
-	if (retransmits_timed_out(sk, sysctl_tcp_retries1 + 1))
+	if (retransmits_timed_out(sk, sysctl_tcp_retries1 + 1, 0))
 		__sk_dst_reset(sk);
 
 out:;
diff -urN linux-2.6.36-rc6/net/mac80211/rx.c linux-2.6.36-rc7/net/mac80211/rx.c
--- linux-2.6.36-rc6/net/mac80211/rx.c	2010-10-06 21:33:45.272815848 +0000
+++ linux-2.6.36-rc7/net/mac80211/rx.c	2010-10-06 21:33:50.039815758 +0000
@@ -2199,9 +2199,6 @@
 	struct net_device *prev_dev = NULL;
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
 
-	if (status->flag & RX_FLAG_INTERNAL_CMTR)
-		goto out_free_skb;
-
 	if (skb_headroom(skb) < sizeof(*rthdr) &&
 	    pskb_expand_head(skb, sizeof(*rthdr), 0, GFP_ATOMIC))
 		goto out_free_skb;
@@ -2260,7 +2257,6 @@
 	} else
 		goto out_free_skb;
 
-	status->flag |= RX_FLAG_INTERNAL_CMTR;
 	return;
 
  out_free_skb:
diff -urN linux-2.6.36-rc6/net/phonet/pep.c linux-2.6.36-rc7/net/phonet/pep.c
--- linux-2.6.36-rc6/net/phonet/pep.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/net/phonet/pep.c	2010-10-06 21:33:50.050815869 +0000
@@ -225,12 +225,13 @@
 static int pipe_rcv_status(struct sock *sk, struct sk_buff *skb)
 {
 	struct pep_sock *pn = pep_sk(sk);
-	struct pnpipehdr *hdr = pnp_hdr(skb);
+	struct pnpipehdr *hdr;
 	int wake = 0;
 
 	if (!pskb_may_pull(skb, sizeof(*hdr) + 4))
 		return -EINVAL;
 
+	hdr = pnp_hdr(skb);
 	if (hdr->data[0] != PN_PEP_TYPE_COMMON) {
 		LIMIT_NETDEBUG(KERN_DEBUG"Phonet unknown PEP type: %u\n",
 				(unsigned)hdr->data[0]);
diff -urN linux-2.6.36-rc6/samples/kfifo/dma-example.c linux-2.6.36-rc7/samples/kfifo/dma-example.c
--- linux-2.6.36-rc6/samples/kfifo/dma-example.c	2010-10-06 21:33:45.302815837 +0000
+++ linux-2.6.36-rc7/samples/kfifo/dma-example.c	2010-10-06 21:33:50.068399830 +0000
@@ -24,6 +24,7 @@
 {
 	int			i;
 	unsigned int		ret;
+	unsigned int		nents;
 	struct scatterlist	sg[10];
 
 	printk(KERN_INFO "DMA fifo test start\n");
@@ -61,9 +62,9 @@
 	 * byte at the beginning, after the kfifo_skip().
 	 */
 	sg_init_table(sg, ARRAY_SIZE(sg));
-	ret = kfifo_dma_in_prepare(&fifo, sg, ARRAY_SIZE(sg), FIFO_SIZE);
-	printk(KERN_INFO "DMA sgl entries: %d\n", ret);
-	if (!ret) {
+	nents = kfifo_dma_in_prepare(&fifo, sg, ARRAY_SIZE(sg), FIFO_SIZE);
+	printk(KERN_INFO "DMA sgl entries: %d\n", nents);
+	if (!nents) {
 		/* fifo is full and no sgl was created */
 		printk(KERN_WARNING "error kfifo_dma_in_prepare\n");
 		return -EIO;
@@ -71,7 +72,7 @@
 
 	/* receive data */
 	printk(KERN_INFO "scatterlist for receive:\n");
-	for (i = 0; i < ARRAY_SIZE(sg); i++) {
+	for (i = 0; i < nents; i++) {
 		printk(KERN_INFO
 		"sg[%d] -> "
 		"page_link 0x%.8lx offset 0x%.8x length 0x%.8x\n",
@@ -91,16 +92,16 @@
 	kfifo_dma_in_finish(&fifo, ret);
 
 	/* Prepare to transmit data, example: 8 bytes */
-	ret = kfifo_dma_out_prepare(&fifo, sg, ARRAY_SIZE(sg), 8);
-	printk(KERN_INFO "DMA sgl entries: %d\n", ret);
-	if (!ret) {
+	nents = kfifo_dma_out_prepare(&fifo, sg, ARRAY_SIZE(sg), 8);
+	printk(KERN_INFO "DMA sgl entries: %d\n", nents);
+	if (!nents) {
 		/* no data was available and no sgl was created */
 		printk(KERN_WARNING "error kfifo_dma_out_prepare\n");
 		return -EIO;
 	}
 
 	printk(KERN_INFO "scatterlist for transmit:\n");
-	for (i = 0; i < ARRAY_SIZE(sg); i++) {
+	for (i = 0; i < nents; i++) {
 		printk(KERN_INFO
 		"sg[%d] -> "
 		"page_link 0x%.8lx offset 0x%.8x length 0x%.8x\n",
diff -urN linux-2.6.36-rc6/sound/core/control.c linux-2.6.36-rc7/sound/core/control.c
--- linux-2.6.36-rc6/sound/core/control.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/sound/core/control.c	2010-10-06 21:33:50.093815763 +0000
@@ -31,6 +31,7 @@
 
 /* max number of user-defined controls */
 #define MAX_USER_CONTROLS	32
+#define MAX_CONTROL_COUNT	1028
 
 struct snd_kctl_ioctl {
 	struct list_head list;		/* list of all ioctls */
@@ -195,6 +196,10 @@
 	
 	if (snd_BUG_ON(!control || !control->count))
 		return NULL;
+
+	if (control->count > MAX_CONTROL_COUNT)
+		return NULL;
+
 	kctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);
 	if (kctl == NULL) {
 		snd_printk(KERN_ERR "Cannot allocate control instance\n");
diff -urN linux-2.6.36-rc6/sound/i2c/other/ak4xxx-adda.c linux-2.6.36-rc7/sound/i2c/other/ak4xxx-adda.c
--- linux-2.6.36-rc6/sound/i2c/other/ak4xxx-adda.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/sound/i2c/other/ak4xxx-adda.c	2010-10-06 21:33:50.095815782 +0000
@@ -900,7 +900,7 @@
 	return 0;
 }
 #else /* !CONFIG_PROC_FS */
-static int proc_init(struct snd_akm4xxx *ak) {}
+static int proc_init(struct snd_akm4xxx *ak) { return 0; }
 #endif
 
 int snd_akm4xxx_build_controls(struct snd_akm4xxx *ak)
diff -urN linux-2.6.36-rc6/tools/perf/Makefile linux-2.6.36-rc7/tools/perf/Makefile
--- linux-2.6.36-rc6/tools/perf/Makefile	2010-10-06 21:33:45.378815807 +0000
+++ linux-2.6.36-rc7/tools/perf/Makefile	2010-10-06 21:33:50.143815940 +0000
@@ -1017,7 +1017,7 @@
 # we compile into subdirectories. if the target directory is not the source directory, they might not exists. So
 # we depend the various files onto their directories.
 DIRECTORY_DEPS = $(LIB_OBJS) $(BUILTIN_OBJS) $(OUTPUT)PERF-VERSION-FILE $(OUTPUT)common-cmds.h
-$(DIRECTORY_DEPS): $(sort $(dir $(DIRECTORY_DEPS)))
+$(DIRECTORY_DEPS): | $(sort $(dir $(DIRECTORY_DEPS)))
 # In the second step, we make a rule to actually create these directories
 $(sort $(dir $(DIRECTORY_DEPS))):
 	$(QUIET_MKDIR)$(MKDIR) -p $@ 2>/dev/null
diff -urN linux-2.6.36-rc6/tools/perf/util/trace-event-scripting.c linux-2.6.36-rc7/tools/perf/util/trace-event-scripting.c
--- linux-2.6.36-rc6/tools/perf/util/trace-event-scripting.c	2010-08-01 22:11:14.000000000 +0000
+++ linux-2.6.36-rc7/tools/perf/util/trace-event-scripting.c	2010-10-06 21:33:50.153815846 +0000
@@ -97,7 +97,7 @@
 	register_python_scripting(&python_scripting_unsupported_ops);
 }
 #else
-struct scripting_ops python_scripting_ops;
+extern struct scripting_ops python_scripting_ops;
 
 void setup_python_scripting(void)
 {
@@ -158,7 +158,7 @@
 	register_perl_scripting(&perl_scripting_unsupported_ops);
 }
 #else
-struct scripting_ops perl_scripting_ops;
+extern struct scripting_ops perl_scripting_ops;
 
 void setup_perl_scripting(void)
 {
diff -urN linux-2.6.36-rc6/tools/perf/util/ui/browsers/hists.c linux-2.6.36-rc7/tools/perf/util/ui/browsers/hists.c
--- linux-2.6.36-rc6/tools/perf/util/ui/browsers/hists.c	2010-10-06 21:33:45.388815851 +0000
+++ linux-2.6.36-rc7/tools/perf/util/ui/browsers/hists.c	2010-10-06 21:33:50.154815858 +0000
@@ -773,7 +773,7 @@
 
 			switch (key) {
 			case 'a':
-				if (browser->selection->map == NULL &&
+				if (browser->selection->map == NULL ||
 				    browser->selection->map->dso->annotate_warned)
 					continue;
 				goto do_annotate;
