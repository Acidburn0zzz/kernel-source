diff --git a/Documentation/CodingStyle b/Documentation/CodingStyle
index afc2867..b49b92e 100644
--- a/Documentation/CodingStyle
+++ b/Documentation/CodingStyle
@@ -495,29 +495,40 @@ re-formatting you may want to take a look at the man page.  But
 remember: "indent" is not a fix for bad programming.
 
 
-		Chapter 10: Configuration-files
+		Chapter 10: Kconfig configuration files
 
-For configuration options (arch/xxx/Kconfig, and all the Kconfig files),
-somewhat different indentation is used.
+For all of the Kconfig* configuration files throughout the source tree,
+the indentation is somewhat different.  Lines under a "config" definition
+are indented with one tab, while help text is indented an additional two
+spaces.  Example:
 
-Help text is indented with 2 spaces.
-
-if CONFIG_EXPERIMENTAL
-	tristate CONFIG_BOOM
-	default n
-	help
-	  Apply nitroglycerine inside the keyboard (DANGEROUS)
-	bool CONFIG_CHEER
-	depends on CONFIG_BOOM
-	default y
+config AUDIT
+	bool "Auditing support"
+	depends on NET
 	help
-	  Output nice messages when you explode
-endif
+	  Enable auditing infrastructure that can be used with another
+	  kernel subsystem, such as SELinux (which requires this for
+	  logging of avc messages output).  Does not do system-call
+	  auditing without CONFIG_AUDITSYSCALL.
+
+Features that might still be considered unstable should be defined as
+dependent on "EXPERIMENTAL":
+
+config SLUB
+	depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT
+	bool "SLUB (Unqueued Allocator)"
+	...
+
+while seriously dangerous features (such as write support for certain
+filesystems) should advertise this prominently in their prompt string:
+
+config ADFS_FS_RW
+	bool "ADFS write support (DANGEROUS)"
+	depends on ADFS_FS
+	...
 
-Generally, CONFIG_EXPERIMENTAL should surround all options not considered
-stable. All options that are known to trash data (experimental write-
-support for file-systems, for instance) should be denoted (DANGEROUS), other
-experimental options should be denoted (EXPERIMENTAL).
+For full documentation on the configuration files, see the file
+Documentation/kbuild/kconfig-language.txt.
 
 
 		Chapter 11: Data structures
diff --git a/Documentation/DocBook/gadget.tmpl b/Documentation/DocBook/gadget.tmpl
index e7fc964..6996d97 100644
--- a/Documentation/DocBook/gadget.tmpl
+++ b/Documentation/DocBook/gadget.tmpl
@@ -52,7 +52,7 @@
 
 <toc></toc>
 
-<chapter><title>Introduction</title>
+<chapter id="intro"><title>Introduction</title>
 
 <para>This document presents a Linux-USB "Gadget"
 kernel mode
diff --git a/Documentation/DocBook/usb.tmpl b/Documentation/DocBook/usb.tmpl
index a2ebd65..af29360 100644
--- a/Documentation/DocBook/usb.tmpl
+++ b/Documentation/DocBook/usb.tmpl
@@ -185,7 +185,7 @@
 
     </chapter>
 
-<chapter><title>USB-Standard Types</title>
+<chapter id="types"><title>USB-Standard Types</title>
 
     <para>In <filename>&lt;linux/usb/ch9.h&gt;</filename> you will find
     the USB data types defined in chapter 9 of the USB specification.
@@ -197,7 +197,7 @@
 
     </chapter>
 
-<chapter><title>Host-Side Data Types and Macros</title>
+<chapter id="hostside"><title>Host-Side Data Types and Macros</title>
 
     <para>The host side API exposes several layers to drivers, some of
     which are more necessary than others.
@@ -211,7 +211,7 @@
 
     </chapter>
 
-    <chapter><title>USB Core APIs</title>
+    <chapter id="usbcore"><title>USB Core APIs</title>
 
     <para>There are two basic I/O models in the USB API.
     The most elemental one is asynchronous:  drivers submit requests
@@ -248,7 +248,7 @@
 !Edrivers/usb/core/hub.c
     </chapter>
 
-    <chapter><title>Host Controller APIs</title>
+    <chapter id="hcd"><title>Host Controller APIs</title>
 
     <para>These APIs are only for use by host controller drivers,
     most of which implement standard register interfaces such as
@@ -285,7 +285,7 @@
 !Idrivers/usb/core/buffer.c
     </chapter>
 
-    <chapter>
+    <chapter id="usbfs">
 	<title>The USB Filesystem (usbfs)</title>
 
 	<para>This chapter presents the Linux <emphasis>usbfs</emphasis>.
@@ -317,7 +317,7 @@
 	not it has a kernel driver.
 	</para>
 
-	<sect1>
+	<sect1 id="usbfs-files">
 	    <title>What files are in "usbfs"?</title>
 
 	    <para>Conventionally mounted at
@@ -356,7 +356,7 @@
 
 	</sect1>
 
-	<sect1>
+	<sect1 id="usbfs-fstab">
 	    <title>Mounting and Access Control</title>
 
 	    <para>There are a number of mount options for usbfs, which will
@@ -439,7 +439,7 @@
 
 	</sect1>
 
-	<sect1>
+	<sect1 id="usbfs-devices">
 	    <title>/proc/bus/usb/devices</title>
 
 	    <para>This file is handy for status viewing tools in user
@@ -473,7 +473,7 @@ for (;;) {
 	    </para>
 	</sect1>
 
-	<sect1>
+	<sect1 id="usbfs-bbbddd">
 	    <title>/proc/bus/usb/BBB/DDD</title>
 
 	    <para>Use these files in one of these basic ways:
@@ -510,7 +510,7 @@ for (;;) {
 	    </sect1>
 
 
-	<sect1>
+	<sect1 id="usbfs-lifecycle">
 	    <title>Life Cycle of User Mode Drivers</title>
 
 	    <para>Such a driver first needs to find a device file
@@ -565,7 +565,7 @@ for (;;) {
 
 	    </sect1>
 
-	<sect1><title>The ioctl() Requests</title>
+	<sect1 id="usbfs-ioctl"><title>The ioctl() Requests</title>
 
 	    <para>To use these ioctls, you need to include the following
 	    headers in your userspace program:
@@ -604,7 +604,7 @@ for (;;) {
 	    </para>
 
 
-	    <sect2>
+	    <sect2 id="usbfs-mgmt">
 		<title>Management/Status Requests</title>
 
 		<para>A number of usbfs requests don't deal very directly
@@ -736,7 +736,7 @@ usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
 
 		</sect2>
 
-	    <sect2>
+	    <sect2 id="usbfs-sync">
 		<title>Synchronous I/O Support</title>
 
 		<para>Synchronous requests involve the kernel blocking
@@ -865,7 +865,7 @@ usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
 		</variablelist>
 	    </sect2>
 
-	    <sect2>
+	    <sect2 id="usbfs-async">
 		<title>Asynchronous I/O Support</title>
 
 		<para>As mentioned above, there are situations where it may be
diff --git a/Documentation/HOWTO b/Documentation/HOWTO
index 48123db..ced9207 100644
--- a/Documentation/HOWTO
+++ b/Documentation/HOWTO
@@ -396,26 +396,6 @@ bugme-janitor mailing list (every change in the bugzilla is mailed here)
 
 
 
-Managing bug reports
---------------------
-
-One of the best ways to put into practice your hacking skills is by fixing
-bugs reported by other people. Not only you will help to make the kernel
-more stable, you'll learn to fix real world problems and you will improve
-your skills, and other developers will be aware of your presence. Fixing
-bugs is one of the best ways to get merits among other developers, because
-not many people like wasting time fixing other people's bugs.
-
-To work in the already reported bug reports, go to http://bugzilla.kernel.org.
-If you want to be advised of the future bug reports, you can subscribe to the
-bugme-new mailing list (only new bug reports are mailed here) or to the
-bugme-janitor mailing list (every change in the bugzilla is mailed here)
-
-	http://lists.osdl.org/mailman/listinfo/bugme-new
-	http://lists.osdl.org/mailman/listinfo/bugme-janitors
-
-
-
 Mailing lists
 -------------
 
diff --git a/Documentation/block/capability.txt b/Documentation/block/capability.txt
new file mode 100644
index 0000000..2f17294
--- /dev/null
+++ b/Documentation/block/capability.txt
@@ -0,0 +1,15 @@
+Generic Block Device Capability
+===============================================================================
+This file documents the sysfs file block/<disk>/capability
+
+capability is a hex word indicating which capabilities a specific disk
+supports.  For more information on bits not listed here, see
+include/linux/genhd.h
+
+Capability				Value
+-------------------------------------------------------------------------------
+GENHD_FL_MEDIA_CHANGE_NOTIFY		4
+	When this bit is set, the disk supports Asynchronous Notification
+	of media change events.  These events will be broadcast to user
+	space via kernel uevent.
+
diff --git a/Documentation/dontdiff b/Documentation/dontdiff
index 64e9f6c..595a5ea 100644
--- a/Documentation/dontdiff
+++ b/Documentation/dontdiff
@@ -10,10 +10,12 @@
 *.grp
 *.gz
 *.html
+*.i
 *.jpeg
 *.ko
 *.log
 *.lst
+*.moc
 *.mod.c
 *.o
 *.orig
@@ -25,6 +27,9 @@
 *.s
 *.sgml
 *.so
+*.symtypes
+*.tab.c
+*.tab.h
 *.tex
 *.ver
 *.xml
@@ -32,9 +37,13 @@
 *_vga16.c
 *cscope*
 *~
+*.9
+*.9.gz
 .*
 .cscope
 53c700_d.h
+53c7xx_d.h
+53c7xx_u.h
 53c8xx_d.h*
 BitKeeper
 COPYING
@@ -70,9 +79,11 @@ bzImage*
 classlist.h*
 comp*.log
 compile.h*
+conf
 config
 config-*
 config_data.h*
+config_data.gz*
 conmakehash
 consolemap_deftbl.c*
 crc32table.h*
@@ -81,18 +92,23 @@ defkeymap.c*
 devlist.h*
 docproc
 dummy_sym.c*
+elf2ecoff
 elfconfig.h*
 filelist
 fixdep
 fore200e_mkfirm
 fore200e_pca_fw.c*
+gconf
 gen-devlist
 gen-kdb_cmds.c*
 gen_crc32table
 gen_init_cpio
 genksyms
 gentbl
+*_gray256.c
 ikconfig.h*
+initramfs_data.cpio
+initramfs_data.cpio.gz
 initramfs_list
 kallsyms
 kconfig
@@ -100,19 +116,30 @@ kconfig.tk
 keywords.c*
 ksym.c*
 ksym.h*
+kxgettext
+lkc_defs.h
 lex.c*
+lex.*.c
+lk201-map.c
 logo_*.c
 logo_*_clut224.c
 logo_*_mono.c
 lxdialog
 mach-types
 mach-types.h
+machtypes.h
 make_times_h
 map
 maui_boot.h
+mconf
+miboot*
 mk_elfconfig
+mkboot
+mkbugboot
 mkdep
+mkprep
 mktables
+mktree
 modpost
 modversions.h*
 offset.h
@@ -120,18 +147,28 @@ offsets.h
 oui.c*
 parse.c*
 parse.h*
+patches*
+pca200e.bin
+pca200e_ecd.bin2
+piggy.gz
+piggyback
 pnmtologo
 ppc_defs.h*
 promcon_tbl.c*
 pss_boot.h
+qconf
 raid6altivec*.c
 raid6int*.c
 raid6tables.c
+relocs
+series
 setup
 sim710_d.h*
+sImage
 sm_tbl*
 split-include
 tags
+tftpboot.img
 times.h*
 tkparse
 trix_boot.h
@@ -139,8 +176,11 @@ utsrelease.h*
 version.h*
 vmlinux
 vmlinux-*
+vmlinux.aout
 vmlinux.lds
 vsyscall.lds
 wanxlfw.inc
 uImage
-zImage
+unifdef
+zImage*
+zconf.hash.c
diff --git a/Documentation/filesystems/directory-locking b/Documentation/filesystems/directory-locking
index d7099a9..ff7b611 100644
--- a/Documentation/filesystems/directory-locking
+++ b/Documentation/filesystems/directory-locking
@@ -1,5 +1,6 @@
 	Locking scheme used for directory operations is based on two
-kinds of locks - per-inode (->i_sem) and per-filesystem (->s_vfs_rename_sem).
+kinds of locks - per-inode (->i_mutex) and per-filesystem
+(->s_vfs_rename_mutex).
 
 	For our purposes all operations fall in 5 classes:
 
@@ -63,7 +64,7 @@ objects - A < B iff A is an ancestor of B.
 attempt to acquire some lock and already holds at least one lock.  Let's
 consider the set of contended locks.  First of all, filesystem lock is
 not contended, since any process blocked on it is not holding any locks.
-Thus all processes are blocked on ->i_sem.
+Thus all processes are blocked on ->i_mutex.
 
 	Non-directory objects are not contended due to (3).  Thus link
 creation can't be a part of deadlock - it can't be blocked on source
diff --git a/Documentation/filesystems/porting b/Documentation/filesystems/porting
index 5531694..dac45c9 100644
--- a/Documentation/filesystems/porting
+++ b/Documentation/filesystems/porting
@@ -107,7 +107,7 @@ free to drop it...
 ---
 [informational]
 
-->link() callers hold ->i_sem on the object we are linking to.  Some of your
+->link() callers hold ->i_mutex on the object we are linking to.  Some of your
 problems might be over...
 
 ---
@@ -130,9 +130,9 @@ went in - and hadn't been documented ;-/).  Just remove it from fs_flags
 ---
 [mandatory]
 
-->setattr() is called without BKL now.  Caller _always_ holds ->i_sem, so
-watch for ->i_sem-grabbing code that might be used by your ->setattr().
-Callers of notify_change() need ->i_sem now.
+->setattr() is called without BKL now.  Caller _always_ holds ->i_mutex, so
+watch for ->i_mutex-grabbing code that might be used by your ->setattr().
+Callers of notify_change() need ->i_mutex now.
 
 ---
 [recommended]
diff --git a/Documentation/i386/boot.txt b/Documentation/i386/boot.txt
index 66fa67f..35985b3 100644
--- a/Documentation/i386/boot.txt
+++ b/Documentation/i386/boot.txt
@@ -2,7 +2,7 @@
 		     ----------------------------
 
 		    H. Peter Anvin <hpa@zytor.com>
-			Last update 2007-05-16
+			Last update 2007-05-23
 
 On the i386 platform, the Linux kernel uses a rather complicated boot
 convention.  This has evolved partially due to historical aspects, as
@@ -202,6 +202,8 @@ All general purpose boot loaders should write the fields marked
 nonstandard address should fill in the fields marked (reloc); other
 boot loaders can ignore those fields.
 
+The byte order of all fields is littleendian (this is x86, after all.)
+
 Field name:	setup_secs
 Type:		read
 Offset/size:	0x1f1/1
@@ -280,14 +282,16 @@ Type:		read
 Offset/size:	0x206/2
 Protocol:	2.00+
 
-  Contains the boot protocol version, e.g. 0x0204 for version 2.04.
+  Contains the boot protocol version, in (major << 8)+minor format,
+  e.g. 0x0204 for version 2.04, and 0x0a11 for a hypothetical version
+  10.17.
 
 Field name:	readmode_swtch
 Type:		modify (optional)
 Offset/size:	0x208/4
 Protocol:	2.00+
 
-  Boot loader hook (see separate chapter.)
+  Boot loader hook (see ADVANCED BOOT LOADER HOOKS below.)
 
 Field name:	start_sys
 Type:		read
@@ -304,10 +308,17 @@ Protocol:	2.00+
   If set to a nonzero value, contains a pointer to a NUL-terminated
   human-readable kernel version number string, less 0x200.  This can
   be used to display the kernel version to the user.  This value
-  should be less than (0x200*setup_sects).  For example, if this value
-  is set to 0x1c00, the kernel version number string can be found at
-  offset 0x1e00 in the kernel file.  This is a valid value if and only
-  if the "setup_sects" field contains the value 14 or higher.
+  should be less than (0x200*setup_sects).
+
+  For example, if this value is set to 0x1c00, the kernel version
+  number string can be found at offset 0x1e00 in the kernel file.
+  This is a valid value if and only if the "setup_sects" field
+  contains the value 15 or higher, as:
+
+	0x1c00  < 15*0x200 (= 0x1e00) but
+	0x1c00 >= 14*0x200 (= 0x1c00)
+
+	0x1c00 >> 9 = 14, so the minimum value for setup_secs is 15.
 
 Field name:	type_of_loader
 Type:		write (obligatory)
@@ -377,7 +388,7 @@ Protocol:	2.00+
 
   This field can be modified for two purposes:
 
-  1. as a boot loader hook (see separate chapter.)
+  1. as a boot loader hook (see ADVANCED BOOT LOADER HOOKS below.)
 
   2. if a bootloader which does not install a hook loads a
      relocatable kernel at a nonstandard address it will have to modify
@@ -715,7 +726,7 @@ switched off, especially if the loaded kernel has the floppy driver as
 a demand-loaded module!
 
 
-**** ADVANCED BOOT TIME HOOKS
+**** ADVANCED BOOT LOADER HOOKS
 
 If the boot loader runs in a particularly hostile environment (such as
 LOADLIN, which runs under DOS) it may be impossible to follow the
@@ -740,4 +751,5 @@ IMPORTANT: All the hooks are required to preserve %esp, %ebp, %esi and
 	set them up to BOOT_DS (0x18) yourself.
 
 	After completing your hook, you should jump to the address
-	that was in this field before your boot loader overwrote it.
+	that was in this field before your boot loader overwrote it
+	(relocated, if appropriate.)
diff --git a/Documentation/initrd.txt b/Documentation/initrd.txt
index 15f1b35..d3dc505 100644
--- a/Documentation/initrd.txt
+++ b/Documentation/initrd.txt
@@ -27,16 +27,20 @@ When using initrd, the system typically boots as follows:
   1) the boot loader loads the kernel and the initial RAM disk
   2) the kernel converts initrd into a "normal" RAM disk and
      frees the memory used by initrd
-  3) initrd is mounted read-write as root
-  4) /linuxrc is executed (this can be any valid executable, including
+  3) if the root device is not /dev/ram0, the old (deprecated)
+     change_root procedure is followed. see the "Obsolete root change
+     mechanism" section below.
+  4) root device is mounted. if it is /dev/ram0, the initrd image is
+     then mounted as root
+  5) /sbin/init is executed (this can be any valid executable, including
      shell scripts; it is run with uid 0 and can do basically everything
-     init can do)
-  5) linuxrc mounts the "real" root file system
-  6) linuxrc places the root file system at the root directory using the
+     init can do).
+  6) init mounts the "real" root file system
+  7) init places the root file system at the root directory using the
      pivot_root system call
-  7) the usual boot sequence (e.g. invocation of /sbin/init) is performed
-     on the root file system
-  8) the initrd file system is removed
+  8) init execs the /sbin/init on the new root filesystem, performing
+     the usual boot sequence
+  9) the initrd file system is removed
 
 Note that changing the root directory does not involve unmounting it.
 It is therefore possible to leave processes running on initrd during that
@@ -70,7 +74,7 @@ initrd adds the following new options:
   root=/dev/ram0
 
     initrd is mounted as root, and the normal boot procedure is followed,
-    with the RAM disk still mounted as root.
+    with the RAM disk mounted as root.
 
 Compressed cpio images
 ----------------------
@@ -137,11 +141,11 @@ We'll describe the loopback device method:
     # mkdir /mnt/dev
     # mknod /mnt/dev/console c 5 1
  5) copy all the files that are needed to properly use the initrd
-    environment. Don't forget the most important file, /linuxrc
-    Note that /linuxrc's permissions must include "x" (execute).
+    environment. Don't forget the most important file, /sbin/init
+    Note that /sbin/init's permissions must include "x" (execute).
  6) correct operation the initrd environment can frequently be tested
     even without rebooting with the command
-    # chroot /mnt /linuxrc
+    # chroot /mnt /sbin/init
     This is of course limited to initrds that do not interfere with the
     general system state (e.g. by reconfiguring network interfaces,
     overwriting mounted devices, trying to start already running demons,
@@ -154,7 +158,7 @@ We'll describe the loopback device method:
     # gzip -9 initrd
 
 For experimenting with initrd, you may want to take a rescue floppy and
-only add a symbolic link from /linuxrc to /bin/sh. Alternatively, you
+only add a symbolic link from /sbin/init to /bin/sh. Alternatively, you
 can try the experimental newlib environment [2] to create a small
 initrd.
 
@@ -163,15 +167,14 @@ boot loaders support initrd. Since the boot process is still compatible
 with an older mechanism, the following boot command line parameters
 have to be given:
 
-  root=/dev/ram0 init=/linuxrc rw
+  root=/dev/ram0 rw
 
 (rw is only necessary if writing to the initrd file system.)
 
 With LOADLIN, you simply execute
 
      LOADLIN <kernel> initrd=<disk_image>
-e.g. LOADLIN C:\LINUX\BZIMAGE initrd=C:\LINUX\INITRD.GZ root=/dev/ram0
-       init=/linuxrc rw
+e.g. LOADLIN C:\LINUX\BZIMAGE initrd=C:\LINUX\INITRD.GZ root=/dev/ram0 rw
 
 With LILO, you add the option INITRD=<path> to either the global section
 or to the section of the respective kernel in /etc/lilo.conf, and pass
@@ -179,7 +182,7 @@ the options using APPEND, e.g.
 
   image = /bzImage
     initrd = /boot/initrd.gz
-    append = "root=/dev/ram0 init=/linuxrc rw"
+    append = "root=/dev/ram0 rw"
 
 and run /sbin/lilo
 
@@ -191,7 +194,7 @@ Now you can boot and enjoy using initrd.
 Changing the root device
 ------------------------
 
-When finished with its duties, linuxrc typically changes the root device
+When finished with its duties, init typically changes the root device
 and proceeds with starting the Linux system on the "real" root device.
 
 The procedure involves the following steps:
@@ -217,7 +220,7 @@ must exist before calling pivot_root. Example:
 # mkdir initrd
 # pivot_root . initrd
 
-Now, the linuxrc process may still access the old root via its
+Now, the init process may still access the old root via its
 executable, shared libraries, standard input/output/error, and its
 current root directory. All these references are dropped by the
 following command:
@@ -249,10 +252,6 @@ disk can be freed:
 It is also possible to use initrd with an NFS-mounted root, see the
 pivot_root(8) man page for details.
 
-Note: if linuxrc or any program exec'ed from it terminates for some
-reason, the old change_root mechanism is invoked (see section "Obsolete
-root change mechanism").
-
 
 Usage scenarios
 ---------------
@@ -264,15 +263,15 @@ as follows:
   1) system boots from floppy or other media with a minimal kernel
      (e.g. support for RAM disks, initrd, a.out, and the Ext2 FS) and
      loads initrd
-  2) /linuxrc determines what is needed to (1) mount the "real" root FS
+  2) /sbin/init determines what is needed to (1) mount the "real" root FS
      (i.e. device type, device drivers, file system) and (2) the
      distribution media (e.g. CD-ROM, network, tape, ...). This can be
      done by asking the user, by auto-probing, or by using a hybrid
      approach.
-  3) /linuxrc loads the necessary kernel modules
-  4) /linuxrc creates and populates the root file system (this doesn't
+  3) /sbin/init loads the necessary kernel modules
+  4) /sbin/init creates and populates the root file system (this doesn't
      have to be a very usable system yet)
-  5) /linuxrc invokes pivot_root to change the root file system and
+  5) /sbin/init invokes pivot_root to change the root file system and
      execs - via chroot - a program that continues the installation
   6) the boot loader is installed
   7) the boot loader is configured to load an initrd with the set of
@@ -291,7 +290,7 @@ different hardware configurations in a single administrative domain. In
 such cases, it is desirable to generate only a small set of kernels
 (ideally only one) and to keep the system-specific part of configuration
 information as small as possible. In this case, a common initrd could be
-generated with all the necessary modules. Then, only /linuxrc or a file
+generated with all the necessary modules. Then, only /sbin/init or a file
 read by it would have to be different.
 
 A third scenario are more convenient recovery disks, because information
@@ -337,6 +336,25 @@ This old, deprecated mechanism is commonly called "change_root", while
 the new, supported mechanism is called "pivot_root".
 
 
+Mixed change_root and pivot_root mechanism
+------------------------------------------
+
+In case you did not want to use root=/dev/ram0 to trig the pivot_root mechanism,
+you may create both /linuxrc and /sbin/init in your initrd image.
+
+/linuxrc would contain only the following:
+
+#! /bin/sh
+mount -n -t proc proc /proc
+echo 0x0100 >/proc/sys/kernel/real-root-dev
+umount -n /proc
+
+Once linuxrc exited, the kernel would mount again your initrd as root,
+this time executing /sbin/init. Again, it would be duty of this init
+to build the right environment (maybe using the root= device passed on
+the cmdline) before the final execution of the real /sbin/init.
+
+
 Resources
 ---------
 
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 09220a1..aae2282 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -396,6 +396,26 @@ and is between 256 and 4096 characters. It is defined in the file
 			clocksource is not available, it defaults to PIT.
 			Format: { pit | tsc | cyclone | pmtmr }
 
+	clocksource=	[GENERIC_TIME] Override the default clocksource
+			Format: <string>
+			Override the default clocksource and use the clocksource
+			with the name specified.
+			Some clocksource names to choose from, depending on
+			the platform:
+			[all] jiffies (this is the base, fallback clocksource)
+			[ACPI] acpi_pm
+			[ARM] imx_timer1,OSTS,netx_timer,mpu_timer2,
+				pxa_timer,timer3,32k_counter,timer0_1
+			[AVR32] avr32
+			[IA-32] pit,hpet,tsc,vmi-timer;
+				scx200_hrt on Geode; cyclone on IBM x440
+			[MIPS] MIPS
+			[PARISC] cr16
+			[S390] tod
+			[SH] SuperH
+			[SPARC64] tick
+			[X86-64] hpet,tsc
+
 	code_bytes	[IA32] How many bytes of object code to print in an
 			oops report.
 			Range: 0 - 8192
@@ -1807,10 +1827,6 @@ and is between 256 and 4096 characters. It is defined in the file
 
 	time		Show timing data prefixed to each printk message line
 
-	clocksource=	[GENERIC_TIME] Override the default clocksource
-			Override the default clocksource and use the clocksource
-			with the name specified.
-
 	tipar.timeout=	[HW,PPT]
 			Set communications timeout in tenths of a second
 			(default 15).
diff --git a/Documentation/ldm.txt b/Documentation/ldm.txt
index e266e11..718085b 100644
--- a/Documentation/ldm.txt
+++ b/Documentation/ldm.txt
@@ -2,10 +2,13 @@
             LDM - Logical Disk Manager (Dynamic Disks)
             ------------------------------------------
 
+Originally Written by FlatCap - Richard Russon <ldm@flatcap.org>.
+Last Updated by Anton Altaparmakov on 30 March 2007 for Windows Vista.
+
 Overview
 --------
 
-Windows 2000 and XP use a new partitioning scheme.  It is a complete
+Windows 2000, XP, and Vista use a new partitioning scheme.  It is a complete
 replacement for the MSDOS style partitions.  It stores its information in a
 1MiB journalled database at the end of the physical disk.  The size of
 partitions is limited only by disk space.  The maximum number of partitions is
@@ -23,7 +26,11 @@ Once the LDM driver has divided up the disk, you can use the MD driver to
 assemble any multi-partition volumes, e.g.  Stripes, RAID5.
 
 To prevent legacy applications from repartitioning the disk, the LDM creates a
-dummy MSDOS partition containing one disk-sized partition.
+dummy MSDOS partition containing one disk-sized partition.  This is what is
+supported with the Linux LDM driver.
+
+A newer approach that has been implemented with Vista is to put LDM on top of a
+GPT label disk.  This is not supported by the Linux LDM driver yet.
 
 
 Example
@@ -88,13 +95,13 @@ and cannot boot from a Dynamic Disk.
 More Documentation
 ------------------
 
-There is an Overview of the LDM online together with complete Technical
-Documentation.  It can also be downloaded in html.
+There is an Overview of the LDM together with complete Technical Documentation.
+It is available for download.
 
-  http://linux-ntfs.sourceforge.net/ldm/index.html
-  http://linux-ntfs.sourceforge.net/downloads.html
+  http://www.linux-ntfs.org/content/view/19/37/
 
-If you have any LDM questions that aren't answered on the website, email me.
+If you have any LDM questions that aren't answered in the documentation, email
+me.
 
 Cheers,
     FlatCap - Richard Russon
diff --git a/Documentation/memory-barriers.txt b/Documentation/memory-barriers.txt
index 58408dd..650657c 100644
--- a/Documentation/memory-barriers.txt
+++ b/Documentation/memory-barriers.txt
@@ -24,7 +24,7 @@ Contents:
  (*) Explicit kernel barriers.
 
      - Compiler barrier.
-     - The CPU memory barriers.
+     - CPU memory barriers.
      - MMIO write barrier.
 
  (*) Implicit kernel memory barriers.
@@ -265,7 +265,7 @@ Memory barriers are such interventions.  They impose a perceived partial
 ordering over the memory operations on either side of the barrier.
 
 Such enforcement is important because the CPUs and other devices in a system
-can use a variety of tricks to improve performance - including reordering,
+can use a variety of tricks to improve performance, including reordering,
 deferral and combination of memory operations; speculative loads; speculative
 branch prediction and various types of caching.  Memory barriers are used to
 override or suppress these tricks, allowing the code to sanely control the
@@ -457,7 +457,7 @@ sequence, Q must be either &A or &B, and that:
 	(Q == &A) implies (D == 1)
 	(Q == &B) implies (D == 4)
 
-But! CPU 2's perception of P may be updated _before_ its perception of B, thus
+But!  CPU 2's perception of P may be updated _before_ its perception of B, thus
 leading to the following situation:
 
 	(Q == &B) and (D == 2) ????
@@ -573,7 +573,7 @@ Basically, the read barrier always has to be there, even though it can be of
 the "weaker" type.
 
 [!] Note that the stores before the write barrier would normally be expected to
-match the loads after the read barrier or data dependency barrier, and vice
+match the loads after the read barrier or the data dependency barrier, and vice
 versa:
 
 	CPU 1                           CPU 2
@@ -588,7 +588,7 @@ versa:
 EXAMPLES OF MEMORY BARRIER SEQUENCES
 ------------------------------------
 
-Firstly, write barriers act as a partial orderings on store operations.
+Firstly, write barriers act as partial orderings on store operations.
 Consider the following sequence of events:
 
 	CPU 1
@@ -608,15 +608,15 @@ STORE B, STORE C } all occurring before the unordered set of { STORE D, STORE E
 	+-------+       :      :
 	|       |       +------+
 	|       |------>| C=3  |     }     /\
-	|       |  :    +------+     }-----  \  -----> Events perceptible
-	|       |  :    | A=1  |     }        \/       to rest of system
+	|       |  :    +------+     }-----  \  -----> Events perceptible to
+	|       |  :    | A=1  |     }        \/       the rest of the system
 	|       |  :    +------+     }
 	| CPU 1 |  :    | B=2  |     }
 	|       |       +------+     }
 	|       |   wwwwwwwwwwwwwwww }   <--- At this point the write barrier
 	|       |       +------+     }        requires all stores prior to the
 	|       |  :    | E=5  |     }        barrier to be committed before
-	|       |  :    +------+     }        further stores may be take place.
+	|       |  :    +------+     }        further stores may take place
 	|       |------>| D=4  |     }
 	|       |       +------+
 	+-------+       :      :
@@ -626,7 +626,7 @@ STORE B, STORE C } all occurring before the unordered set of { STORE D, STORE E
 	                   V
 
 
-Secondly, data dependency barriers act as a partial orderings on data-dependent
+Secondly, data dependency barriers act as partial orderings on data-dependent
 loads.  Consider the following sequence of events:
 
 	CPU 1			CPU 2
@@ -975,7 +975,7 @@ compiler from moving the memory accesses either side of it to the other side:
 
 	barrier();
 
-This a general barrier - lesser varieties of compiler barrier do not exist.
+This is a general barrier - lesser varieties of compiler barrier do not exist.
 
 The compiler barrier has no direct effect on the CPU, which may then reorder
 things however it wishes.
@@ -997,7 +997,7 @@ The Linux kernel has eight basic CPU memory barriers:
 All CPU memory barriers unconditionally imply compiler barriers.
 
 SMP memory barriers are reduced to compiler barriers on uniprocessor compiled
-systems because it is assumed that a CPU will be appear to be self-consistent,
+systems because it is assumed that a CPU will appear to be self-consistent,
 and will order overlapping accesses correctly with respect to itself.
 
 [!] Note that SMP memory barriers _must_ be used to control the ordering of
@@ -1146,9 +1146,9 @@ for each construct.  These operations all imply certain barriers:
 Therefore, from (1), (2) and (4) an UNLOCK followed by an unconditional LOCK is
 equivalent to a full barrier, but a LOCK followed by an UNLOCK is not.
 
-[!] Note: one of the consequence of LOCKs and UNLOCKs being only one-way
-    barriers is that the effects instructions outside of a critical section may
-    seep into the inside of the critical section.
+[!] Note: one of the consequences of LOCKs and UNLOCKs being only one-way
+    barriers is that the effects of instructions outside of a critical section
+    may seep into the inside of the critical section.
 
 A LOCK followed by an UNLOCK may not be assumed to be full memory barrier
 because it is possible for an access preceding the LOCK to happen after the
@@ -1239,7 +1239,7 @@ three CPUs; then should the following sequence of events occur:
 	UNLOCK M			UNLOCK Q
 	*D = d;				*H = h;
 
-Then there is no guarantee as to what order CPU #3 will see the accesses to *A
+Then there is no guarantee as to what order CPU 3 will see the accesses to *A
 through *H occur in, other than the constraints imposed by the separate locks
 on the separate CPUs. It might, for example, see:
 
@@ -1269,12 +1269,12 @@ However, if the following occurs:
 					UNLOCK M	[2]
 					*H = h;
 
-CPU #3 might see:
+CPU 3 might see:
 
 	*E, LOCK M [1], *C, *B, *A, UNLOCK M [1],
 		LOCK M [2], *H, *F, *G, UNLOCK M [2], *D
 
-But assuming CPU #1 gets the lock first, it won't see any of:
+But assuming CPU 1 gets the lock first, CPU 3 won't see any of:
 
 	*B, *C, *D, *F, *G or *H preceding LOCK M [1]
 	*A, *B or *C following UNLOCK M [1]
@@ -1327,12 +1327,12 @@ spinlock, for example:
 					mmiowb();
 					spin_unlock(Q);
 
-this will ensure that the two stores issued on CPU #1 appear at the PCI bridge
-before either of the stores issued on CPU #2.
+this will ensure that the two stores issued on CPU 1 appear at the PCI bridge
+before either of the stores issued on CPU 2.
 
 
-Furthermore, following a store by a load to the same device obviates the need
-for an mmiowb(), because the load forces the store to complete before the load
+Furthermore, following a store by a load from the same device obviates the need
+for the mmiowb(), because the load forces the store to complete before the load
 is performed:
 
 	CPU 1				CPU 2
@@ -1363,7 +1363,7 @@ circumstances in which reordering definitely _could_ be a problem:
 
  (*) Atomic operations.
 
- (*) Accessing devices (I/O).
+ (*) Accessing devices.
 
  (*) Interrupts.
 
@@ -1399,7 +1399,7 @@ To wake up a particular waiter, the up_read() or up_write() functions have to:
  (1) read the next pointer from this waiter's record to know as to where the
      next waiter record is;
 
- (4) read the pointer to the waiter's task structure;
+ (2) read the pointer to the waiter's task structure;
 
  (3) clear the task pointer to tell the waiter it has been given the semaphore;
 
@@ -1407,7 +1407,7 @@ To wake up a particular waiter, the up_read() or up_write() functions have to:
 
  (5) release the reference held on the waiter's task struct.
 
-In otherwords, it has to perform this sequence of events:
+In other words, it has to perform this sequence of events:
 
 	LOAD waiter->list.next;
 	LOAD waiter->task;
@@ -1502,7 +1502,7 @@ operations and adjusting reference counters towards object destruction, and as
 such the implicit memory barrier effects are necessary.
 
 
-The following operation are potential problems as they do _not_ imply memory
+The following operations are potential problems as they do _not_ imply memory
 barriers, but might be used for implementing such things as UNLOCK-class
 operations:
 
@@ -1517,7 +1517,7 @@ With these the appropriate explicit memory barrier should be used if necessary
 
 The following also do _not_ imply memory barriers, and so may require explicit
 memory barriers under some circumstances (smp_mb__before_atomic_dec() for
-instance)):
+instance):
 
 	atomic_add();
 	atomic_sub();
@@ -1641,8 +1641,8 @@ functions:
      indeed have special I/O space access cycles and instructions, but many
      CPUs don't have such a concept.
 
-     The PCI bus, amongst others, defines an I/O space concept - which on such
-     CPUs as i386 and x86_64 cpus readily maps to the CPU's concept of I/O
+     The PCI bus, amongst others, defines an I/O space concept which - on such
+     CPUs as i386 and x86_64 - readily maps to the CPU's concept of I/O
      space.  However, it may also be mapped as a virtual I/O space in the CPU's
      memory map, particularly on those CPUs that don't support alternate I/O
      spaces.
@@ -1664,7 +1664,7 @@ functions:
      i386 architecture machines, for example, this is controlled by way of the
      MTRR registers.
 
-     Ordinarily, these will be guaranteed to be fully ordered and uncombined,,
+     Ordinarily, these will be guaranteed to be fully ordered and uncombined,
      provided they're not accessing a prefetchable device.
 
      However, intermediary hardware (such as a PCI bridge) may indulge in
@@ -1689,7 +1689,7 @@ functions:
 
  (*) ioreadX(), iowriteX()
 
-     These will perform as appropriate for the type of access they're actually
+     These will perform appropriately for the type of access they're actually
      doing, be it inX()/outX() or readX()/writeX().
 
 
@@ -1705,7 +1705,7 @@ of arch-specific code.
 
 This means that it must be considered that the CPU will execute its instruction
 stream in any order it feels like - or even in parallel - provided that if an
-instruction in the stream depends on the an earlier instruction, then that
+instruction in the stream depends on an earlier instruction, then that
 earlier instruction must be sufficiently complete[*] before the later
 instruction may proceed; in other words: provided that the appearance of
 causality is maintained.
@@ -1795,8 +1795,8 @@ eventually become visible on all CPUs, there's no guarantee that they will
 become apparent in the same order on those other CPUs.
 
 
-Consider dealing with a system that has pair of CPUs (1 & 2), each of which has
-a pair of parallel data caches (CPU 1 has A/B, and CPU 2 has C/D):
+Consider dealing with a system that has a pair of CPUs (1 & 2), each of which
+has a pair of parallel data caches (CPU 1 has A/B, and CPU 2 has C/D):
 
 	            :
 	            :                          +--------+
@@ -1835,7 +1835,7 @@ Imagine the system has the following properties:
 
  (*) the coherency queue is not flushed by normal loads to lines already
      present in the cache, even though the contents of the queue may
-     potentially effect those loads.
+     potentially affect those loads.
 
 Imagine, then, that two writes are made on the first CPU, with a write barrier
 between them to guarantee that they will appear to reach that CPU's caches in
@@ -1845,7 +1845,7 @@ the requisite order:
 	===============	===============	=======================================
 					u == 0, v == 1 and p == &u, q == &u
 	v = 2;
-	smp_wmb();			Make sure change to v visible before
+	smp_wmb();			Make sure change to v is visible before
 					 change to p
 	<A:modify v=2>			v is now in cache A exclusively
 	p = &v;
@@ -1853,7 +1853,7 @@ the requisite order:
 
 The write memory barrier forces the other CPUs in the system to perceive that
 the local CPU's caches have apparently been updated in the correct order.  But
-now imagine that the second CPU that wants to read those values:
+now imagine that the second CPU wants to read those values:
 
 	CPU 1		CPU 2		COMMENT
 	===============	===============	=======================================
@@ -1861,7 +1861,7 @@ now imagine that the second CPU that wants to read those values:
 			q = p;
 			x = *q;
 
-The above pair of reads may then fail to happen in expected order, as the
+The above pair of reads may then fail to happen in the expected order, as the
 cacheline holding p may get updated in one of the second CPU's caches whilst
 the update to the cacheline holding v is delayed in the other of the second
 CPU's caches by some other cache event:
@@ -1916,7 +1916,7 @@ access depends on a read, not all do, so it may not be relied on.
 
 Other CPUs may also have split caches, but must coordinate between the various
 cachelets for normal memory accesses.  The semantics of the Alpha removes the
-need for coordination in absence of memory barriers.
+need for coordination in the absence of memory barriers.
 
 
 CACHE COHERENCY VS DMA
@@ -1931,10 +1931,10 @@ invalidate them as well).
 
 In addition, the data DMA'd to RAM by a device may be overwritten by dirty
 cache lines being written back to RAM from a CPU's cache after the device has
-installed its own data, or cache lines simply present in a CPUs cache may
-simply obscure the fact that RAM has been updated, until at such time as the
-cacheline is discarded from the CPU's cache and reloaded.  To deal with this,
-the appropriate part of the kernel must invalidate the overlapping bits of the
+installed its own data, or cache lines present in the CPU's cache may simply
+obscure the fact that RAM has been updated, until at such time as the cacheline
+is discarded from the CPU's cache and reloaded.  To deal with this, the
+appropriate part of the kernel must invalidate the overlapping bits of the
 cache on each CPU.
 
 See Documentation/cachetlb.txt for more information on cache management.
@@ -1944,7 +1944,7 @@ CACHE COHERENCY VS MMIO
 -----------------------
 
 Memory mapped I/O usually takes place through memory locations that are part of
-a window in the CPU's memory space that have different properties assigned than
+a window in the CPU's memory space that has different properties assigned than
 the usual RAM directed window.
 
 Amongst these properties is usually the fact that such accesses bypass the
@@ -1960,7 +1960,7 @@ THE THINGS CPUS GET UP TO
 =========================
 
 A programmer might take it for granted that the CPU will perform memory
-operations in exactly the order specified, so that if a CPU is, for example,
+operations in exactly the order specified, so that if the CPU is, for example,
 given the following piece of code to execute:
 
 	a = *A;
@@ -1969,7 +1969,7 @@ given the following piece of code to execute:
 	d = *D;
 	*E = e;
 
-They would then expect that the CPU will complete the memory operation for each
+they would then expect that the CPU will complete the memory operation for each
 instruction before moving on to the next one, leading to a definite sequence of
 operations as seen by external observers in the system:
 
@@ -1986,8 +1986,8 @@ assumption doesn't hold because:
  (*) loads may be done speculatively, and the result discarded should it prove
      to have been unnecessary;
 
- (*) loads may be done speculatively, leading to the result having being
-     fetched at the wrong time in the expected sequence of events;
+ (*) loads may be done speculatively, leading to the result having been fetched
+     at the wrong time in the expected sequence of events;
 
  (*) the order of the memory accesses may be rearranged to promote better use
      of the CPU buses and caches;
@@ -2069,12 +2069,12 @@ AND THEN THERE'S THE ALPHA
 
 The DEC Alpha CPU is one of the most relaxed CPUs there is.  Not only that,
 some versions of the Alpha CPU have a split data cache, permitting them to have
-two semantically related cache lines updating at separate times.  This is where
+two semantically-related cache lines updated at separate times.  This is where
 the data dependency barrier really becomes necessary as this synchronises both
 caches with the memory coherence system, thus making it seem like pointer
 changes vs new data occur in the right order.
 
-The Alpha defines the Linux's kernel's memory barrier model.
+The Alpha defines the Linux kernel's memory barrier model.
 
 See the subsection on "Cache Coherency" above.
 
diff --git a/Documentation/s390/cds.txt b/Documentation/s390/cds.txt
index 05a2b4f..58919d6 100644
--- a/Documentation/s390/cds.txt
+++ b/Documentation/s390/cds.txt
@@ -51,13 +51,8 @@ The major changes are:
 * The interrupt handlers must be adapted to use a ccw_device as argument.
   Moreover, they don't return a devstat, but an irb.
 * Before initiating an io, the options must be set via ccw_device_set_options().
-
-read_dev_chars()	
-   read device characteristics
-   
-read_conf_data()
-read_conf_data_lpm()
-   read configuration data.
+* Instead of calling read_dev_chars()/read_conf_data(), the driver issues
+  the channel program and handles the interrupt itself.
 
 ccw_device_get_ciw()
    get commands from extended sense data.
@@ -130,11 +125,6 @@ present their hardware status by the same (shared) IRQ, the operating system
 has to call every single device driver registered on this IRQ in order to
 determine the device driver owning the device that raised the interrupt.
 
-In order not to introduce a new I/O concept to the common Linux code,
-Linux/390 preserves the IRQ concept and semantically maps the ESA/390
-subchannels to Linux as IRQs. This allows Linux/390 to support up to 64k
-different IRQs, uniquely representing a single device each.
-
 Up to kernel 2.4, Linux/390 used to provide interfaces via the IRQ (subchannel).
 For internal use of the common I/O layer, these are still there. However, 
 device drivers should use the new calling interface via the ccw_device only.
@@ -151,9 +141,8 @@ information during their initialization step to recognize the devices they
 support using the information saved in the struct ccw_device given to them.
 This methods implies that Linux/390 doesn't require to probe for free (not
 armed) interrupt request lines (IRQs) to drive its devices with. Where
-applicable, the device drivers can use the read_dev_chars() to retrieve device
-characteristics. This can be done without having to request device ownership
-previously.
+applicable, the device drivers can use issue the READ DEVICE CHARACTERISTICS
+ccw to retrieve device characteristics in its online routine.
 
 In order to allow for easy I/O initiation the CDS layer provides a
 ccw_device_start() interface that takes a device specific channel program (one
@@ -170,69 +159,6 @@ SUBCHANNEL (HSCH) command without having pending I/O requests. This function is
 also covered by ccw_device_halt().
 
 
-read_dev_chars() - Read Device Characteristics
-
-This routine returns the characteristics for the device specified.
-
-The function is meant to be called with the device already enabled; that is,
-at earliest during set_online() processing.
-
-The ccw_device must not be locked prior to calling read_dev_chars().
-
-The function may be called enabled or disabled.
-
-int read_dev_chars(struct ccw_device *cdev, void **buffer, int length );
-
-cdev   - the ccw_device the information is requested for.
-buffer - pointer to a buffer pointer. The buffer pointer itself
-         must contain a valid buffer area.
-length - length of the buffer provided.
-
-The read_dev_chars() function returns :
-
-      0 - successful completion
--ENODEV - cdev invalid
--EINVAL - an invalid parameter was detected, or the function was called early.
--EBUSY  - an irrecoverable I/O error occurred or the device is not
-          operational.
-
-
-read_conf_data(), read_conf_data_lpm() - Read Configuration Data
-
-Retrieve the device dependent configuration data. Please have a look at your 
-device dependent I/O commands for the device specific layout of the node 
-descriptor elements. read_conf_data_lpm() will retrieve the configuration data
-for a specific path.
-
-The function is meant to be called with the device already enabled; that is,
-at earliest during set_online() processing.
-
-The function may be called enabled or disabled, but the device must not be
-locked
-
-int read_conf_data(struct ccw_device, void **buffer, int *length);
-int read_conf_data_lpm(struct ccw_device, void **buffer, int *length, __u8 lpm);
-
-cdev   - the ccw_device the data is requested for.
-buffer - Pointer to a buffer pointer. The read_conf_data() routine
-         will allocate a buffer and initialize the buffer pointer
-         accordingly. It's the device driver's responsibility to
-         release the kernel memory if no longer needed. 
-length - Length of the buffer allocated and retrieved.
-lpm    - Logical path mask to be used for retrieving the data. If
-         zero the data is retrieved on the next path available.
-
-The read_conf_data() function returns :
-          0 - Successful completion
--ENODEV     - cdev invalid.
--EINVAL     - An invalid parameter was detected, or the function was called early.
--EIO        - An irrecoverable I/O error occurred or the device is
-              not operational.
--ENOMEM     - The read_conf_data() routine couldn't obtain storage.
--EOPNOTSUPP - The device doesn't support the read configuration 
-              data command.
-
-
 get_ciw() - get command information word
 
 This call enables a device driver to get information about supported commands
diff --git a/Documentation/spi/spi-summary b/Documentation/spi/spi-summary
index 795fbb4..76ea6c8 100644
--- a/Documentation/spi/spi-summary
+++ b/Documentation/spi/spi-summary
@@ -1,26 +1,30 @@
 Overview of Linux kernel SPI support
 ====================================
 
-02-Dec-2005
+21-May-2007
 
 What is SPI?
 ------------
 The "Serial Peripheral Interface" (SPI) is a synchronous four wire serial
 link used to connect microcontrollers to sensors, memory, and peripherals.
+It's a simple "de facto" standard, not complicated enough to acquire a
+standardization body.  SPI uses a master/slave configuration.
 
 The three signal wires hold a clock (SCK, often on the order of 10 MHz),
 and parallel data lines with "Master Out, Slave In" (MOSI) or "Master In,
 Slave Out" (MISO) signals.  (Other names are also used.)  There are four
 clocking modes through which data is exchanged; mode-0 and mode-3 are most
 commonly used.  Each clock cycle shifts data out and data in; the clock
-doesn't cycle except when there is data to shift.
+doesn't cycle except when there is a data bit to shift.  Not all data bits
+are used though; not every protocol uses those full duplex capabilities.
 
-SPI masters may use a "chip select" line to activate a given SPI slave
+SPI masters use a fourth "chip select" line to activate a given SPI slave
 device, so those three signal wires may be connected to several chips
-in parallel.  All SPI slaves support chipselects.  Some devices have
+in parallel.  All SPI slaves support chipselects; they are usually active
+low signals, labeled nCSx for slave 'x' (e.g. nCS0).  Some devices have
 other signals, often including an interrupt to the master.
 
-Unlike serial busses like USB or SMBUS, even low level protocols for
+Unlike serial busses like USB or SMBus, even low level protocols for
 SPI slave functions are usually not interoperable between vendors
 (except for commodities like SPI memory chips).
 
@@ -33,6 +37,11 @@ SPI slave functions are usually not interoperable between vendors
   - Some devices may use eight bit words.  Others may different word
     lengths, such as streams of 12-bit or 20-bit digital samples.
 
+  - Words are usually sent with their most significant bit (MSB) first,
+    but sometimes the least significant bit (LSB) goes first instead.
+
+  - Sometimes SPI is used to daisy-chain devices, like shift registers.
+
 In the same way, SPI slaves will only rarely support any kind of automatic
 discovery/enumeration protocol.  The tree of slave devices accessible from
 a given SPI master will normally be set up manually, with configuration
@@ -44,6 +53,14 @@ half-duplex SPI, for request/response protocols), SSP ("Synchronous
 Serial Protocol"), PSP ("Programmable Serial Protocol"), and other
 related protocols.
 
+Some chips eliminate a signal line by combining MOSI and MISO, and
+limiting themselves to half-duplex at the hardware level.  In fact
+some SPI chips have this signal mode as a strapping option.  These
+can be accessed using the same programming interface as SPI, but of
+course they won't handle full duplex transfers.  You may find such
+chips described as using "three wire" signaling: SCK, data, nCSx.
+(That data line is sometimes called MOMI or SISO.)
+
 Microcontrollers often support both master and slave sides of the SPI
 protocol.  This document (and Linux) currently only supports the master
 side of SPI interactions.
@@ -74,6 +91,32 @@ interfaces with SPI modes.  Given SPI support, they could use MMC or SD
 cards without needing a special purpose MMC/SD/SDIO controller.
 
 
+I'm confused.  What are these four SPI "clock modes"?
+-----------------------------------------------------
+It's easy to be confused here, and the vendor documentation you'll
+find isn't necessarily helpful.  The four modes combine two mode bits:
+
+ - CPOL indicates the initial clock polarity.  CPOL=0 means the
+   clock starts low, so the first (leading) edge is rising, and
+   the second (trailing) edge is falling.  CPOL=1 means the clock
+   starts high, so the first (leading) edge is falling.
+
+ - CPHA indicates the clock phase used to sample data; CPHA=0 says
+   sample on the leading edge, CPHA=1 means the trailing edge.
+
+   Since the signal needs to stablize before it's sampled, CPHA=0
+   implies that its data is written half a clock before the first
+   clock edge.  The chipselect may have made it become available.
+
+Chip specs won't always say "uses SPI mode X" in as many words,
+but their timing diagrams will make the CPOL and CPHA modes clear.
+
+In the SPI mode number, CPOL is the high order bit and CPHA is the
+low order bit.  So when a chip's timing diagram shows the clock
+starting low (CPOL=0) and data stabilized for sampling during the
+trailing clock edge (CPHA=1), that's SPI mode 1.
+
+
 How do these driver programming interfaces work?
 ------------------------------------------------
 The <linux/spi/spi.h> header file includes kerneldoc, as does the
diff --git a/MAINTAINERS b/MAINTAINERS
index 4c3277c..953291d 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -332,6 +332,9 @@ L:	linux-usb-devel@lists.sourceforge.net
 W:	http://www.linux-usb.org/SpeedTouch/
 S:	Maintained
 
+ALCHEMY AU1XX0 MMC DRIVER
+S:	Orphan
+
 ALI1563 I2C DRIVER
 P:	Rudolf Marek
 M:	r.marek@assembler.cz
@@ -418,6 +421,12 @@ P:	Ian Molton
 M:	spyro@f2s.com
 S:	Maintained
 
+ARM PRIMECELL MMCI PL180/1 DRIVER
+P:	Russell King
+M:	rmk@arm.linux.org.uk
+L:	linux-arm-kernel@lists.arm.linux.org.uk (subscribers-only)
+S:	Maintained
+
 ARM/ADI ROADRUNNER MACHINE SUPPORT
 P:	Lennert Buytenhek
 M:	kernel@wantstofly.org
@@ -649,6 +658,9 @@ L:	linux-atm-general@lists.sourceforge.net (subscribers-only)
 W:	http://linux-atm.sourceforge.net
 S:	Maintained
 
+ATMEL AT91 MCI DRIVER
+S:	Orphan
+
 ATMEL MACB ETHERNET DRIVER
 P:	Haavard Skinnemoen
 M:	hskinnemoen@atmel.com
@@ -2231,11 +2243,11 @@ M:	khali@linux-fr.org
 L:	lm-sensors@lm-sensors.org
 S:	Maintained
 
-LOGICAL DISK MANAGER SUPPORT (LDM, Windows 2000/XP Dynamic Disks)
+LOGICAL DISK MANAGER SUPPORT (LDM, Windows 2000/XP/Vista Dynamic Disks)
 P:	Richard Russon (FlatCap)
 M:	ldm@flatcap.org
-L:	ldm-devel@lists.sourceforge.net
-W:	http://ldm.sourceforge.net
+L:	linux-ntfs-dev@lists.sourceforge.net
+W:	http://www.linux-ntfs.org/content/view/19/37/
 S:	Maintained
 
 LSILOGIC MPT FUSION DRIVERS (FC/SAS/SPI)
@@ -2380,6 +2392,13 @@ M:	stelian@popies.net
 W:	http://popies.net/meye/
 S:	Maintained
 
+MOTOROLA IMX MMC/SD HOST CONTROLLER INTERFACE DRIVER
+P:	Pavel Pisa
+M:	ppisa@pikron.com
+L:	linux-arm-kernel@lists.arm.linux.org.uk (subscribers-only)
+W:	http://mmc.drzeus.cx/wiki/Controllers/Freescale/SDHC
+S:	Maintained
+
 MOUSE AND MISC DEVICES [GENERAL]
 P:	Alessandro Rubini
 M:	rubini@ipvvis.unipv.it
@@ -2900,6 +2919,9 @@ M:	nico@cam.org
 L:	linux-arm-kernel@lists.arm.linux.org.uk	(subscribers-only)
 S:	Maintained
 
+PXA MMCI DRIVER
+S:	Orphan
+
 QLOGIC QLA2XXX FC-SCSI DRIVER
 P:	Andrew Vasquez
 M:	linux-driver@qlogic.com
@@ -3416,6 +3438,13 @@ P:      Alex Dubov
 M:      oakad@yahoo.com
 S:      Maintained
 
+TI OMAP MMC INTERFACE DRIVER
+P:	Carlos Aguiar, Anderson Briglia and Syed Khasim
+M:	linux-omap-open-source@linux.omap.com 
+W:	http://linux.omap.com
+W:	http://www.muru.com/linux/omap/
+S:	Maintained
+
 TI OMAP RANDOM NUMBER GENERATOR SUPPORT
 P:	Deepak Saxena
 M:	dsaxena@plexity.net
diff --git a/Makefile b/Makefile
index 34210af..28fb40f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 22
-EXTRAVERSION = -rc2
+EXTRAVERSION = -rc2-git7
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff --git a/arch/alpha/kernel/vmlinux.lds.S b/arch/alpha/kernel/vmlinux.lds.S
index cf1e6fc..449e76f 100644
--- a/arch/alpha/kernel/vmlinux.lds.S
+++ b/arch/alpha/kernel/vmlinux.lds.S
@@ -15,7 +15,7 @@ SECTIONS
 
   _text = .;					/* Text and read-only data */
   .text : { 
-	*(.text) 
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	*(.fixup)
@@ -89,7 +89,7 @@ SECTIONS
 
   _data = .;
   .data : {					/* Data */
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
   }
 
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index e55bbd3..50d9f3e 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -287,6 +287,7 @@ config ARCH_IXP2000
 config ARCH_IXP4XX
 	bool "IXP4xx-based"
 	depends on MMU
+	select GENERIC_GPIO
 	select GENERIC_TIME
 	select GENERIC_CLOCKEVENTS
 	help
diff --git a/arch/arm/common/dmabounce.c b/arch/arm/common/dmabounce.c
index 6fbe772..b36b1e8 100644
--- a/arch/arm/common/dmabounce.c
+++ b/arch/arm/common/dmabounce.c
@@ -6,7 +6,7 @@
  *  copy data to/from buffers located outside the DMA region. This
  *  only works for systems in which DMA memory is at the bottom of
  *  RAM, the remainder of memory is at the top and the DMA memory
- *  can be marked as ZONE_DMA. Anything beyond that such as discontigous
+ *  can be marked as ZONE_DMA. Anything beyond that such as discontiguous
  *  DMA windows will require custom implementations that reserve memory
  *  areas at early bootup.
  *
diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index 4deece5..0c89bd3 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -72,7 +72,7 @@ static inline unsigned int gic_irq(unsigned int irq)
  * unmask it, in the same way we need to unmask an interrupt when
  * we first enable it.
  *
- * The GIC has a seperate notion of "end of interrupt" to re-enable
+ * The GIC has a separate notion of "end of interrupt" to re-enable
  * an interrupt after handling, in order to support hardware
  * prioritisation.
  *
@@ -125,12 +125,11 @@ static void gic_set_cpu(unsigned int irq, cpumask_t mask_val)
 }
 #endif
 
-static void fastcall gic_handle_cascade_irq(unsigned int irq,
-					    struct irq_desc *desc)
+static void gic_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
 {
 	struct gic_chip_data *chip_data = get_irq_data(irq);
 	struct irq_chip *chip = get_irq_chip(irq);
-	unsigned int cascade_irq;
+	unsigned int cascade_irq, gic_irq;
 	unsigned long status;
 
 	/* primary controller ack'ing */
@@ -140,16 +139,15 @@ static void fastcall gic_handle_cascade_irq(unsigned int irq,
 	status = readl(chip_data->cpu_base + GIC_CPU_INTACK);
 	spin_unlock(&irq_controller_lock);
 
-	cascade_irq = (status & 0x3ff);
-	if (cascade_irq > 1020)
+	gic_irq = (status & 0x3ff);
+	if (gic_irq == 1023)
 		goto out;
-	if (cascade_irq < 32 || cascade_irq >= NR_IRQS) {
-		do_bad_IRQ(cascade_irq, desc);
-		goto out;
-	}
 
-	cascade_irq += chip_data->irq_offset;
-	generic_handle_irq(cascade_irq);
+	cascade_irq = gic_irq + chip_data->irq_offset;
+	if (unlikely(gic_irq < 32 || gic_irq > 1020 || cascade_irq >= NR_IRQS))
+		do_bad_IRQ(cascade_irq, desc);
+	else
+		generic_handle_irq(cascade_irq);
 
  out:
 	/* primary controller unmasking */
diff --git a/arch/arm/common/sharpsl_param.c b/arch/arm/common/sharpsl_param.c
index c94864c..aad4d94 100644
--- a/arch/arm/common/sharpsl_param.c
+++ b/arch/arm/common/sharpsl_param.c
@@ -20,7 +20,7 @@
  * typically including LCD parameters are loaded by the bootloader at the
  * address PARAM_BASE. As the kernel will overwrite them, we need to store
  * them early in the boot process, then pass them to the appropriate drivers.
- * Not all devices use all paramaters but the format is common to all.
+ * Not all devices use all parameters but the format is common to all.
  */
 #ifdef CONFIG_ARCH_SA1100
 #define PARAM_BASE	0xe8ffc000
diff --git a/arch/arm/common/sharpsl_pm.c b/arch/arm/common/sharpsl_pm.c
index 5972df2..3bf3a92 100644
--- a/arch/arm/common/sharpsl_pm.c
+++ b/arch/arm/common/sharpsl_pm.c
@@ -153,7 +153,7 @@ static void sharpsl_battery_thread(struct work_struct *private_)
 		sharpsl_pm.battstat.mainbat_percent = percent;
 	}
 
-	dev_dbg(sharpsl_pm.dev, "Battery: voltage: %d, status: %d, percentage: %d, time: %d\n", voltage,
+	dev_dbg(sharpsl_pm.dev, "Battery: voltage: %d, status: %d, percentage: %d, time: %ld\n", voltage,
 			sharpsl_pm.battstat.mainbat_status, sharpsl_pm.battstat.mainbat_percent, jiffies);
 
 	/* If battery is low. limit backlight intensity to save power. */
@@ -291,7 +291,7 @@ static void sharpsl_chrg_full_timer(unsigned long data)
 }
 
 /* Charging Finished Interrupt (Not present on Corgi) */
-/* Can trigger at the same time as an AC staus change so
+/* Can trigger at the same time as an AC status change so
    delay until after that has been processed */
 irqreturn_t sharpsl_chrg_full_isr(int irq, void *dev_id)
 {
@@ -625,7 +625,7 @@ static int sharpsl_fatal_check(void)
 	}
 
 	temp = get_select_val(buff);
-	dev_dbg(sharpsl_pm.dev, "sharpsl_fatal_check: acin: %d, discharge voltage: %d, no discharge: %d\n", acin, temp, sharpsl_pm.machinfo->read_devdata(SHARPSL_BATT_VOLT));
+	dev_dbg(sharpsl_pm.dev, "sharpsl_fatal_check: acin: %d, discharge voltage: %d, no discharge: %ld\n", acin, temp, sharpsl_pm.machinfo->read_devdata(SHARPSL_BATT_VOLT));
 
 	if ((acin && (temp < sharpsl_pm.machinfo->fatal_acin_volt)) ||
 			(!acin && (temp < sharpsl_pm.machinfo->fatal_noacin_volt)))
@@ -635,7 +635,7 @@ static int sharpsl_fatal_check(void)
 
 static int sharpsl_off_charge_error(void)
 {
-	dev_err(sharpsl_pm.dev, "Offline Charger: Error occured.\n");
+	dev_err(sharpsl_pm.dev, "Offline Charger: Error occurred.\n");
 	sharpsl_pm.machinfo->charge(0);
 	sharpsl_pm_led(SHARPSL_LED_ERROR);
 	sharpsl_pm.charge_mode = CHRG_ERROR;
@@ -691,14 +691,14 @@ static int sharpsl_off_charge_battery(void)
 
 		time = RCNR;
 		while(1) {
-			/* Check if any wakeup event had occured */
+			/* Check if any wakeup event had occurred */
 			if (sharpsl_pm.machinfo->charger_wakeup() != 0)
 				return 0;
 			/* Check for timeout */
 			if ((RCNR - time) > SHARPSL_WAIT_CO_TIME)
 				return 1;
 			if (sharpsl_pm.machinfo->read_devdata(SHARPSL_STATUS_CHRGFULL)) {
-				dev_dbg(sharpsl_pm.dev, "Offline Charger: Charge full occured. Retrying to check\n");
+				dev_dbg(sharpsl_pm.dev, "Offline Charger: Charge full occurred. Retrying to check\n");
 	   			sharpsl_pm.full_count++;
 				sharpsl_pm.machinfo->charge(0);
 				mdelay(SHARPSL_CHARGE_WAIT_TIME);
@@ -714,7 +714,7 @@ static int sharpsl_off_charge_battery(void)
 
 	time = RCNR;
 	while(1) {
-		/* Check if any wakeup event had occured */
+		/* Check if any wakeup event had occurred */
 		if (sharpsl_pm.machinfo->charger_wakeup() != 0)
 			return 0;
 		/* Check for timeout */
@@ -774,6 +774,8 @@ static struct pm_ops sharpsl_pm_ops = {
 
 static int __init sharpsl_pm_probe(struct platform_device *pdev)
 {
+	int ret;
+
 	if (!pdev->dev.platform_data)
 		return -EINVAL;
 
@@ -792,8 +794,10 @@ static int __init sharpsl_pm_probe(struct platform_device *pdev)
 
 	sharpsl_pm.machinfo->init();
 
-	device_create_file(&pdev->dev, &dev_attr_battery_percentage);
-	device_create_file(&pdev->dev, &dev_attr_battery_voltage);
+	ret = device_create_file(&pdev->dev, &dev_attr_battery_percentage);
+	ret |= device_create_file(&pdev->dev, &dev_attr_battery_voltage);
+	if (ret != 0)
+		dev_warn(&pdev->dev, "Failed to register attributes (%d)\n", ret);
 
 	apm_get_power_status = sharpsl_apm_get_power_status;
 
diff --git a/arch/arm/kernel/asm-offsets.c b/arch/arm/kernel/asm-offsets.c
index 3c078e3..3278e71 100644
--- a/arch/arm/kernel/asm-offsets.c
+++ b/arch/arm/kernel/asm-offsets.c
@@ -85,7 +85,7 @@ int main(void)
   DEFINE(S_OLD_R0,		offsetof(struct pt_regs, ARM_ORIG_r0));
   DEFINE(S_FRAME_SIZE,		sizeof(struct pt_regs));
   BLANK();
-#if __LINUX_ARM_ARCH__ >= 6
+#ifdef CONFIG_CPU_HAS_ASID
   DEFINE(MM_CONTEXT_ID,		offsetof(struct mm_struct, context.id));
   BLANK();
 #endif
diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index ae89cdd..19326d7 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -357,6 +357,10 @@
 /* 345 */	CALL(sys_getcpu)
 		CALL(sys_ni_syscall)		/* eventually epoll_pwait */
 		CALL(sys_kexec_load)
+		CALL(sys_utimensat)
+		CALL(sys_signalfd)
+/* 350 */	CALL(sys_timerfd)
+		CALL(sys_eventfd)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 0453dcc..650eac1 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -918,7 +918,7 @@ static int c_show(struct seq_file *m, void *v)
 
 	if ((processor_id & 0x0008f000) == 0x00000000) {
 		/* pre-ARM7 */
-		seq_printf(m, "CPU part\t\t: %07x\n", processor_id >> 4);
+		seq_printf(m, "CPU part\t: %07x\n", processor_id >> 4);
 	} else {
 		if ((processor_id & 0x0008f000) == 0x00007000) {
 			/* ARM7 */
diff --git a/arch/arm/kernel/sys_arm.c b/arch/arm/kernel/sys_arm.c
index 3d4fcbc..1ca2d51 100644
--- a/arch/arm/kernel/sys_arm.c
+++ b/arch/arm/kernel/sys_arm.c
@@ -320,7 +320,7 @@ int kernel_execve(const char *filename, char *const argv[], char *const envp[])
 EXPORT_SYMBOL(kernel_execve);
 
 /*
- * Since loff_t is a 64 bit type we avoid a lot of ABI hastle
+ * Since loff_t is a 64 bit type we avoid a lot of ABI hassle
  * with a different argument ordering.
  */
 asmlinkage long sys_arm_fadvise64_64(int fd, int advice,
diff --git a/arch/arm/kernel/vmlinux.lds.S b/arch/arm/kernel/vmlinux.lds.S
index e4156e7..2b7a8f5 100644
--- a/arch/arm/kernel/vmlinux.lds.S
+++ b/arch/arm/kernel/vmlinux.lds.S
@@ -90,7 +90,7 @@ SECTIONS
 			__exception_text_start = .;
 			*(.exception.text)
 			__exception_text_end = .;
-			*(.text)
+			TEXT_TEXT
 			SCHED_TEXT
 			LOCK_TEXT
 #ifdef CONFIG_MMU
@@ -158,7 +158,7 @@ SECTIONS
 		/*
 		 * and the usual data section
 		 */
-		*(.data)
+		DATA_DATA
 		CONSTRUCTORS
 
 		_edata = .;
diff --git a/arch/arm/lib/bitops.h b/arch/arm/lib/bitops.h
index 5422510..2e787d4 100644
--- a/arch/arm/lib/bitops.h
+++ b/arch/arm/lib/bitops.h
@@ -47,7 +47,7 @@
  * @store: store instruction
  *
  * Note: we can trivially conditionalise the store instruction
- * to avoid dirting the data cache.
+ * to avoid dirtying the data cache.
  */
 	.macro	testop, instr, store
 	add	r1, r1, r0, lsr #3
diff --git a/arch/arm/mach-at91/board-carmeva.c b/arch/arm/mach-at91/board-carmeva.c
index b451861..76ec856 100644
--- a/arch/arm/mach-at91/board-carmeva.c
+++ b/arch/arm/mach-at91/board-carmeva.c
@@ -79,7 +79,7 @@ static struct at91_udc_data __initdata carmeva_udc_data = {
 	.pullup_pin	= AT91_PIN_PD9,
 };
 
-/* FIXME: user dependend */
+/* FIXME: user dependant */
 // static struct at91_cf_data __initdata carmeva_cf_data = {
 //	.det_pin	= AT91_PIN_PB0,
 //	.rst_pin	= AT91_PIN_PC5,
@@ -100,17 +100,17 @@ static struct spi_board_info carmeva_spi_devices[] = {
 		.chip_select  = 0,
 		.max_speed_hz = 10 * 1000 * 1000,
 	},
-	{ /* User accessable spi - cs1 (250KHz) */
+	{ /* User accessible spi - cs1 (250KHz) */
 		.modalias = "spi-cs1",
 		.chip_select  = 1,
 		.max_speed_hz = 250 *  1000,
 	},
-	{ /* User accessable spi - cs2 (1MHz) */
+	{ /* User accessible spi - cs2 (1MHz) */
 		.modalias = "spi-cs2",
 		.chip_select  = 2,
 		.max_speed_hz = 1 * 1000 *  1000,
 	},
-	{ /* User accessable spi - cs3 (10MHz) */
+	{ /* User accessible spi - cs3 (10MHz) */
 		.modalias = "spi-cs3",
 		.chip_select  = 3,
 		.max_speed_hz = 10 * 1000 *  1000,
diff --git a/arch/arm/mach-h720x/cpu-h7202.c b/arch/arm/mach-h720x/cpu-h7202.c
index 82e420d..0a1a25f 100644
--- a/arch/arm/mach-h720x/cpu-h7202.c
+++ b/arch/arm/mach-h720x/cpu-h7202.c
@@ -143,7 +143,7 @@ h7202_timer_interrupt(int irq, void *dev_id)
 }
 
 /*
- * mask multiplexed timer irq's
+ * mask multiplexed timer IRQs
  */
 static void inline mask_timerx_irq (u32 irq)
 {
@@ -153,7 +153,7 @@ static void inline mask_timerx_irq (u32 irq)
 }
 
 /*
- * unmask multiplexed timer irq's
+ * unmask multiplexed timer IRQs
  */
 static void inline unmask_timerx_irq (u32 irq)
 {
diff --git a/arch/arm/mach-imx/cpufreq.c b/arch/arm/mach-imx/cpufreq.c
index 7e70e0b..467d899 100644
--- a/arch/arm/mach-imx/cpufreq.c
+++ b/arch/arm/mach-imx/cpufreq.c
@@ -245,7 +245,7 @@ static int imx_set_target(struct cpufreq_policy *policy,
 	if(mpctl0) {
 		CSCR |= CSCR_MPLL_RESTART;
 
-		/* Wait until MPLL is stablized */
+		/* Wait until MPLL is stabilized */
 		while( CSCR & CSCR_MPLL_RESTART );
 
 		imx_set_async_mode();
diff --git a/arch/arm/mach-imx/dma.c b/arch/arm/mach-imx/dma.c
index 6d50d85..bc6fb02 100644
--- a/arch/arm/mach-imx/dma.c
+++ b/arch/arm/mach-imx/dma.c
@@ -131,7 +131,7 @@ imx_dma_setup_sg_base(imx_dmach_t dma_ch,
  * The function setups DMA channel source and destination addresses for transfer
  * specified by provided parameters. The scatter-gather emulation is disabled,
  * because linear data block
- * form the physical address range is transfered.
+ * form the physical address range is transferred.
  * Return value: if incorrect parameters are provided -%EINVAL.
  *		Zero indicates success.
  */
@@ -192,7 +192,7 @@ imx_dma_setup_single(imx_dmach_t dma_ch, dma_addr_t dma_address,
  * @dmamode: DMA transfer mode, %DMA_MODE_READ from the device to the memory
  *           or %DMA_MODE_WRITE from memory to the device
  *
- * The function setups DMA channel state and registers to be ready for transfer
+ * The function sets up DMA channel state and registers to be ready for transfer
  * specified by provided parameters. The scatter-gather emulation is set up
  * according to the parameters.
  *
@@ -212,7 +212,7 @@ imx_dma_setup_single(imx_dmach_t dma_ch, dma_addr_t dma_address,
  *
  * %CCR_SMOD_LINEAR | %CCR_SSIZ_32 | %CCR_DMOD_FIFO | %CCR_DSIZ_x
  *
- * Be carefull there and do not mistakenly mix source and target device
+ * Be careful here and do not mistakenly mix source and target device
  * port sizes constants, they are really different:
  * %CCR_SSIZ_8, %CCR_SSIZ_16, %CCR_SSIZ_32,
  * %CCR_DSIZ_8, %CCR_DSIZ_16, %CCR_DSIZ_32
@@ -495,7 +495,7 @@ static irqreturn_t dma_err_handler(int irq, void *dev_id)
 		/*
 		 * The cleaning of @sg field would be questionable
 		 * there, because its value can help to compute
-		 * remaining/transfered bytes count in the handler
+		 * remaining/transferred bytes count in the handler
 		 */
 		/*imx_dma_channels[i].sg = NULL;*/
 
diff --git a/arch/arm/mach-integrator/Makefile b/arch/arm/mach-integrator/Makefile
index ebb255b..158daaf 100644
--- a/arch/arm/mach-integrator/Makefile
+++ b/arch/arm/mach-integrator/Makefile
@@ -12,4 +12,3 @@ obj-$(CONFIG_LEDS)			+= leds.o
 obj-$(CONFIG_PCI)			+= pci_v3.o pci.o
 obj-$(CONFIG_CPU_FREQ_INTEGRATOR)	+= cpu.o
 obj-$(CONFIG_INTEGRATOR_IMPD1)		+= impd1.o
-obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o
diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 897c21c..e9c82de 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -257,23 +257,7 @@ integrator_timer_interrupt(int irq, void *dev_id)
 	 */
 	writel(1, TIMER1_VA_BASE + TIMER_INTCLR);
 
-	/*
-	 * the clock tick routines are only processed on the
-	 * primary CPU
-	 */
-	if (hard_smp_processor_id() == 0) {
-		timer_tick();
-#ifdef CONFIG_SMP
-		smp_send_timer();
-#endif
-	}
-
-#ifdef CONFIG_SMP
-	/*
-	 * this is the ARM equivalent of the APIC timer interrupt
-	 */
-	update_process_times(user_mode(get_irq_regs()));
-#endif /* CONFIG_SMP */
+	timer_tick();
 
 	write_sequnlock(&xtime_lock);
 
diff --git a/arch/arm/mach-integrator/headsmp.S b/arch/arm/mach-integrator/headsmp.S
deleted file mode 100644
index ceaa88e..0000000
--- a/arch/arm/mach-integrator/headsmp.S
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- *  linux/arch/arm/mach-integrator/headsmp.S
- *
- *  Copyright (c) 2003 ARM Limited
- *  All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/linkage.h>
-#include <linux/init.h>
-
-	__INIT
-
-/*
- * Integrator specific entry point for secondary CPUs.  This provides
- * a "holding pen" into which all secondary cores are held until we're
- * ready for them to initialise.
- */
-ENTRY(integrator_secondary_startup)
-	adr	r4, 1f
-	ldmia	r4, {r5, r6}
-	sub	r4, r4, r5
-	ldr	r6, [r6, r4]
-pen:	ldr	r7, [r6]
-	cmp	r7, r0
-	bne	pen
-
-	/*
-	 * we've been released from the holding pen: secondary_stack
-	 * should now contain the SVC stack for this core
-	 */
-	b	secondary_startup
-
-1:	.long	.
-	.long	phys_pen_release
diff --git a/arch/arm/mach-integrator/pci_v3.c b/arch/arm/mach-integrator/pci_v3.c
index af9ebcc..d4d8134 100644
--- a/arch/arm/mach-integrator/pci_v3.c
+++ b/arch/arm/mach-integrator/pci_v3.c
@@ -33,6 +33,7 @@
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/mach/pci.h>
+#include <asm/irq_regs.h>
 
 #include <asm/hardware/pci_v3.h>
 
diff --git a/arch/arm/mach-integrator/platsmp.c b/arch/arm/mach-integrator/platsmp.c
deleted file mode 100644
index 613b841..0000000
--- a/arch/arm/mach-integrator/platsmp.c
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- *  linux/arch/arm/mach-cintegrator/platsmp.c
- *
- *  Copyright (C) 2002 ARM Ltd.
- *  All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/mm.h>
-
-#include <asm/atomic.h>
-#include <asm/cacheflush.h>
-#include <asm/delay.h>
-#include <asm/mmu_context.h>
-#include <asm/ptrace.h>
-#include <asm/smp.h>
-
-extern void integrator_secondary_startup(void);
-
-/*
- * control for which core is the next to come out of the secondary
- * boot "holding pen"
- */
-volatile int __cpuinitdata pen_release = -1;
-unsigned long __cpuinitdata phys_pen_release = 0;
-
-static DEFINE_SPINLOCK(boot_lock);
-
-void __cpuinit platform_secondary_init(unsigned int cpu)
-{
-	/*
-	 * the primary core may have used a "cross call" soft interrupt
-	 * to get this processor out of WFI in the BootMonitor - make
-	 * sure that we are no longer being sent this soft interrupt
-	 */
-	smp_cross_call_done(cpumask_of_cpu(cpu));
-
-	/*
-	 * if any interrupts are already enabled for the primary
-	 * core (e.g. timer irq), then they will not have been enabled
-	 * for us: do so
-	 */
-	secondary_scan_irqs();
-
-	/*
-	 * let the primary processor know we're out of the
-	 * pen, then head off into the C entry point
-	 */
-	pen_release = -1;
-
-	/*
-	 * Synchronise with the boot thread.
-	 */
-	spin_lock(&boot_lock);
-	spin_unlock(&boot_lock);
-}
-
-int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
-{
-	unsigned long timeout;
-
-	/*
-	 * set synchronisation state between this boot processor
-	 * and the secondary one
-	 */
-	spin_lock(&boot_lock);
-
-	/*
-	 * The secondary processor is waiting to be released from
-	 * the holding pen - release it, then wait for it to flag
-	 * that it has been released by resetting pen_release.
-	 *
-	 * Note that "pen_release" is the hardware CPU ID, whereas
-	 * "cpu" is Linux's internal ID.
-	 */
-	pen_release = cpu;
-	flush_cache_all();
-
-	/*
-	 * XXX
-	 *
-	 * This is a later addition to the booting protocol: the
-	 * bootMonitor now puts secondary cores into WFI, so
-	 * poke_milo() no longer gets the cores moving; we need
-	 * to send a soft interrupt to wake the secondary core.
-	 * Use smp_cross_call() for this, since there's little
-	 * point duplicating the code here
-	 */
-	smp_cross_call(cpumask_of_cpu(cpu));
-
-	timeout = jiffies + (1 * HZ);
-	while (time_before(jiffies, timeout)) {
-		if (pen_release == -1)
-			break;
-
-		udelay(10);
-	}
-
-	/*
-	 * now the secondary core is starting up let it run its
-	 * calibrations, then wait for it to finish
-	 */
-	spin_unlock(&boot_lock);
-
-	return pen_release != -1 ? -ENOSYS : 0;
-}
-
-static void __init poke_milo(void)
-{
-	extern void secondary_startup(void);
-
-	/* nobody is to be released from the pen yet */
-	pen_release = -1;
-
-	phys_pen_release = virt_to_phys(&pen_release);
-
-	/*
-	 * write the address of secondary startup into the system-wide
-	 * flags register, then clear the bottom two bits, which is what
-	 * BootMonitor is waiting for
-	 */
-#if 1
-#define CINTEGRATOR_HDR_FLAGSS_OFFSET 0x30
-	__raw_writel(virt_to_phys(integrator_secondary_startup),
-		     (IO_ADDRESS(INTEGRATOR_HDR_BASE) +
-		      CINTEGRATOR_HDR_FLAGSS_OFFSET));
-#define CINTEGRATOR_HDR_FLAGSC_OFFSET 0x34
-	__raw_writel(3,
-		     (IO_ADDRESS(INTEGRATOR_HDR_BASE) +
-		      CINTEGRATOR_HDR_FLAGSC_OFFSET));
-#endif
-
-	mb();
-}
-
-/*
- * Initialise the CPU possible map early - this describes the CPUs
- * which may be present or become present in the system.
- */
-void __init smp_init_cpus(void)
-{
-	unsigned int i, ncores = get_core_count();
-
-	for (i = 0; i < ncores; i++)
-		cpu_set(i, cpu_possible_map);
-}
-
-void __init smp_prepare_cpus(unsigned int max_cpus)
-{
-	unsigned int ncores = get_core_count();
-	unsigned int cpu = smp_processor_id();
-	int i;
-
-	/* sanity check */
-	if (ncores == 0) {
-		printk(KERN_ERR
-		       "Integrator/CP: strange CM count of 0? Default to 1\n");
-
-		ncores = 1;
-	}
-
-	if (ncores > NR_CPUS) {
-		printk(KERN_WARNING
-		       "Integrator/CP: no. of cores (%d) greater than configured "
-		       "maximum of %d - clipping\n",
-		       ncores, NR_CPUS);
-		ncores = NR_CPUS;
-	}
-
-	/*
-	 * start with some more config for the Boot CPU, now that
-	 * the world is a bit more alive (which was not the case
-	 * when smp_prepare_boot_cpu() was called)
-	 */
-	smp_store_cpu_info(cpu);
-
-	/*
-	 * are we trying to boot more cores than exist?
-	 */
-	if (max_cpus > ncores)
-		max_cpus = ncores;
-
-	/*
-	 * Initialise the present map, which describes the set of CPUs
-	 * actually populated at the present time.
-	 */
-	for (i = 0; i < max_cpus; i++)
-		cpu_set(i, cpu_present_map);
-
-	/*
-	 * Do we need any more CPUs? If so, then let them know where
-	 * to start. Note that, on modern versions of MILO, the "poke"
-	 * doesn't actually do anything until each individual core is
-	 * sent a soft interrupt to get it out of WFI
-	 */
-	if (max_cpus > 1)
-		poke_milo();
-}
diff --git a/arch/arm/mach-iop13xx/irq.c b/arch/arm/mach-iop13xx/irq.c
index 5791add..69f07b2 100644
--- a/arch/arm/mach-iop13xx/irq.c
+++ b/arch/arm/mach-iop13xx/irq.c
@@ -30,77 +30,65 @@
 
 /* INTCTL0 CP6 R0 Page 4
  */
-static inline u32 read_intctl_0(void)
+static u32 read_intctl_0(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c0, c4, 0":"=r" (val));
 	return val;
 }
-static inline void write_intctl_0(u32 val)
+static void write_intctl_0(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c0, c4, 0"::"r" (val));
 }
 
 /* INTCTL1 CP6 R1 Page 4
  */
-static inline u32 read_intctl_1(void)
+static u32 read_intctl_1(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c1, c4, 0":"=r" (val));
 	return val;
 }
-static inline void write_intctl_1(u32 val)
+static void write_intctl_1(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c1, c4, 0"::"r" (val));
 }
 
 /* INTCTL2 CP6 R2 Page 4
  */
-static inline u32 read_intctl_2(void)
+static u32 read_intctl_2(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c2, c4, 0":"=r" (val));
 	return val;
 }
-static inline void write_intctl_2(u32 val)
+static void write_intctl_2(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c2, c4, 0"::"r" (val));
 }
 
 /* INTCTL3 CP6 R3 Page 4
  */
-static inline u32 read_intctl_3(void)
+static u32 read_intctl_3(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c3, c4, 0":"=r" (val));
 	return val;
 }
-static inline void write_intctl_3(u32 val)
+static void write_intctl_3(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c3, c4, 0"::"r" (val));
 }
 
 /* INTSTR0 CP6 R0 Page 5
  */
-static inline u32 read_intstr_0(void)
-{
-	u32 val;
-	asm volatile("mrc p6, 0, %0, c0, c5, 0":"=r" (val));
-	return val;
-}
-static inline void write_intstr_0(u32 val)
+static void write_intstr_0(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c0, c5, 0"::"r" (val));
 }
 
 /* INTSTR1 CP6 R1 Page 5
  */
-static inline u32 read_intstr_1(void)
-{
-	u32 val;
-	asm volatile("mrc p6, 0, %0, c1, c5, 0":"=r" (val));
-	return val;
-}
 static void write_intstr_1(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c1, c5, 0"::"r" (val));
@@ -108,12 +96,6 @@ static void write_intstr_1(u32 val)
 
 /* INTSTR2 CP6 R2 Page 5
  */
-static inline u32 read_intstr_2(void)
-{
-	u32 val;
-	asm volatile("mrc p6, 0, %0, c2, c5, 0":"=r" (val));
-	return val;
-}
 static void write_intstr_2(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c2, c5, 0"::"r" (val));
@@ -121,12 +103,6 @@ static void write_intstr_2(u32 val)
 
 /* INTSTR3 CP6 R3 Page 5
  */
-static inline u32 read_intstr_3(void)
-{
-	u32 val;
-	asm volatile("mrc p6, 0, %0, c3, c5, 0":"=r" (val));
-	return val;
-}
 static void write_intstr_3(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c3, c5, 0"::"r" (val));
@@ -134,12 +110,6 @@ static void write_intstr_3(u32 val)
 
 /* INTBASE CP6 R0 Page 2
  */
-static inline u32 read_intbase(void)
-{
-	u32 val;
-	asm volatile("mrc p6, 0, %0, c0, c2, 0":"=r" (val));
-	return val;
-}
 static void write_intbase(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c0, c2, 0"::"r" (val));
@@ -147,12 +117,6 @@ static void write_intbase(u32 val)
 
 /* INTSIZE CP6 R2 Page 2
  */
-static inline u32 read_intsize(void)
-{
-	u32 val;
-	asm volatile("mrc p6, 0, %0, c2, c2, 0":"=r" (val));
-	return val;
-}
 static void write_intsize(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c2, c2, 0"::"r" (val));
diff --git a/arch/arm/mach-iop13xx/msi.c b/arch/arm/mach-iop13xx/msi.c
index 2d23693..63ef112 100644
--- a/arch/arm/mach-iop13xx/msi.c
+++ b/arch/arm/mach-iop13xx/msi.c
@@ -30,52 +30,52 @@ static DECLARE_BITMAP(msi_irq_in_use, IOP13XX_NUM_MSI_IRQS);
 
 /* IMIPR0 CP6 R8 Page 1
  */
-static inline u32 read_imipr_0(void)
+static u32 read_imipr_0(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c8, c1, 0":"=r" (val));
 	return val;
 }
-static inline void write_imipr_0(u32 val)
+static void write_imipr_0(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c8, c1, 0"::"r" (val));
 }
 
 /* IMIPR1 CP6 R9 Page 1
  */
-static inline u32 read_imipr_1(void)
+static u32 read_imipr_1(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c9, c1, 0":"=r" (val));
 	return val;
 }
-static inline void write_imipr_1(u32 val)
+static void write_imipr_1(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c9, c1, 0"::"r" (val));
 }
 
 /* IMIPR2 CP6 R10 Page 1
  */
-static inline u32 read_imipr_2(void)
+static u32 read_imipr_2(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c10, c1, 0":"=r" (val));
 	return val;
 }
-static inline void write_imipr_2(u32 val)
+static void write_imipr_2(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c10, c1, 0"::"r" (val));
 }
 
 /* IMIPR3 CP6 R11 Page 1
  */
-static inline u32 read_imipr_3(void)
+static u32 read_imipr_3(void)
 {
 	u32 val;
 	asm volatile("mrc p6, 0, %0, c11, c1, 0":"=r" (val));
 	return val;
 }
-static inline void write_imipr_3(u32 val)
+static void write_imipr_3(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c11, c1, 0"::"r" (val));
 }
@@ -190,5 +190,5 @@ int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
 	write_msi_msg(irq, &msg);
 	set_irq_chip_and_handler(irq, &iop13xx_msi_chip, handle_simple_irq);
 
-	return irq;
+	return 0;
 }
diff --git a/arch/arm/mach-iop13xx/pci.c b/arch/arm/mach-iop13xx/pci.c
index 1c9e94c..9d63d7f 100644
--- a/arch/arm/mach-iop13xx/pci.c
+++ b/arch/arm/mach-iop13xx/pci.c
@@ -19,10 +19,11 @@
 
 #include <linux/pci.h>
 #include <linux/delay.h>
-
+#include <linux/jiffies.h>
 #include <asm/irq.h>
 #include <asm/hardware.h>
 #include <asm/sizes.h>
+#include <asm/signal.h>
 #include <asm/mach/pci.h>
 #include <asm/arch/pci.h>
 
@@ -144,7 +145,7 @@ void iop13xx_map_pci_memory(void)
 	}
 }
 
-static inline int iop13xx_atu_function(int atu)
+static int iop13xx_atu_function(int atu)
 {
 	int func = 0;
 	/* the function number depends on the value of the
@@ -259,7 +260,7 @@ static int iop13xx_atux_pci_status(int clear)
  * data.  Note that the data dependency on %0 encourages an abort
  * to be detected before we return.
  */
-static inline u32 iop13xx_atux_read(unsigned long addr)
+static u32 iop13xx_atux_read(unsigned long addr)
 {
 	u32 val;
 
@@ -387,7 +388,7 @@ static int iop13xx_atue_pci_status(int clear)
 	return err;
 }
 
-static inline int __init
+static int
 iop13xx_pcie_map_irq(struct pci_dev *dev, u8 idsel, u8 pin)
 {
 	WARN_ON(idsel != 0);
@@ -401,7 +402,7 @@ iop13xx_pcie_map_irq(struct pci_dev *dev, u8 idsel, u8 pin)
 	}
 }
 
-static inline u32 iop13xx_atue_read(unsigned long addr)
+static u32 iop13xx_atue_read(unsigned long addr)
 {
 	u32 val;
 
@@ -989,7 +990,7 @@ void __init iop13xx_pci_init(void)
 			"imprecise external abort");
 }
 
-/* intialize the pci memory space.  handle any combination of
+/* initialize the pci memory space.  handle any combination of
  * atue and atux enabled/disabled
  */
 int iop13xx_pci_setup(int nr, struct pci_sys_data *sys)
diff --git a/arch/arm/mach-iop32x/glantank.c b/arch/arm/mach-iop32x/glantank.c
index 45f4f13..5776fd8 100644
--- a/arch/arm/mach-iop32x/glantank.c
+++ b/arch/arm/mach-iop32x/glantank.c
@@ -75,7 +75,7 @@ void __init glantank_map_io(void)
 #define INTC	IRQ_IOP32X_XINT2
 #define INTD	IRQ_IOP32X_XINT3
 
-static inline int __init
+static int __init
 glantank_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	static int pci_irq_table[][4] = {
diff --git a/arch/arm/mach-iop32x/iq31244.c b/arch/arm/mach-iop32x/iq31244.c
index 7b21c6e..d4eefbe 100644
--- a/arch/arm/mach-iop32x/iq31244.c
+++ b/arch/arm/mach-iop32x/iq31244.c
@@ -104,7 +104,7 @@ void __init iq31244_map_io(void)
 /*
  * EP80219/IQ31244 PCI.
  */
-static inline int __init
+static int __init
 ep80219_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
@@ -140,7 +140,7 @@ static struct hw_pci ep80219_pci __initdata = {
 	.map_irq	= ep80219_pci_map_irq,
 };
 
-static inline int __init
+static int __init
 iq31244_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
diff --git a/arch/arm/mach-iop32x/iq80321.c b/arch/arm/mach-iop32x/iq80321.c
index bc25fb9..8d9f491 100644
--- a/arch/arm/mach-iop32x/iq80321.c
+++ b/arch/arm/mach-iop32x/iq80321.c
@@ -72,7 +72,7 @@ void __init iq80321_map_io(void)
 /*
  * IQ80321 PCI.
  */
-static inline int __init
+static int __init
 iq80321_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
diff --git a/arch/arm/mach-iop32x/irq.c b/arch/arm/mach-iop32x/irq.c
index 82598dc..c971171 100644
--- a/arch/arm/mach-iop32x/irq.c
+++ b/arch/arm/mach-iop32x/irq.c
@@ -21,12 +21,12 @@
 
 static u32 iop32x_mask;
 
-static inline void intctl_write(u32 val)
+static void intctl_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c0, c0, 0" : : "r" (val));
 }
 
-static inline void intstr_write(u32 val)
+static void intstr_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c4, c0, 0" : : "r" (val));
 }
diff --git a/arch/arm/mach-iop32x/n2100.c b/arch/arm/mach-iop32x/n2100.c
index 5f07344..d55005d 100644
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@ -76,7 +76,7 @@ void __init n2100_map_io(void)
 /*
  * N2100 PCI.
  */
-static inline int __init
+static int __init
 n2100_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
diff --git a/arch/arm/mach-iop33x/iq80331.c b/arch/arm/mach-iop33x/iq80331.c
index 376c932..2b06318 100644
--- a/arch/arm/mach-iop33x/iq80331.c
+++ b/arch/arm/mach-iop33x/iq80331.c
@@ -55,7 +55,7 @@ static struct sys_timer iq80331_timer = {
 /*
  * IQ80331 PCI.
  */
-static inline int __init
+static int __init
 iq80331_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
diff --git a/arch/arm/mach-iop33x/iq80332.c b/arch/arm/mach-iop33x/iq80332.c
index 58c8149..7889ce3 100644
--- a/arch/arm/mach-iop33x/iq80332.c
+++ b/arch/arm/mach-iop33x/iq80332.c
@@ -55,7 +55,7 @@ static struct sys_timer iq80332_timer = {
 /*
  * IQ80332 PCI.
  */
-static inline int __init
+static int __init
 iq80332_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int irq;
diff --git a/arch/arm/mach-iop33x/irq.c b/arch/arm/mach-iop33x/irq.c
index c65ea78..f09dd05 100644
--- a/arch/arm/mach-iop33x/irq.c
+++ b/arch/arm/mach-iop33x/irq.c
@@ -22,32 +22,32 @@
 static u32 iop33x_mask0;
 static u32 iop33x_mask1;
 
-static inline void intctl0_write(u32 val)
+static void intctl0_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c0, c0, 0" : : "r" (val));
 }
 
-static inline void intctl1_write(u32 val)
+static void intctl1_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c1, c0, 0" : : "r" (val));
 }
 
-static inline void intstr0_write(u32 val)
+static void intstr0_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c2, c0, 0" : : "r" (val));
 }
 
-static inline void intstr1_write(u32 val)
+static void intstr1_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c3, c0, 0" : : "r" (val));
 }
 
-static inline void intbase_write(u32 val)
+static void intbase_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c12, c0, 0" : : "r" (val));
 }
 
-static inline void intsize_write(u32 val)
+static void intsize_write(u32 val)
 {
 	asm volatile("mcr p6, 0, %0, c13, c0, 0" : : "r" (val));
 }
diff --git a/arch/arm/mach-ixp2000/enp2611.c b/arch/arm/mach-ixp2000/enp2611.c
index 500e997..9c49435 100644
--- a/arch/arm/mach-ixp2000/enp2611.c
+++ b/arch/arm/mach-ixp2000/enp2611.c
@@ -198,7 +198,7 @@ subsys_initcall(enp2611_pci_init);
 
 
 /*************************************************************************
- * ENP-2611 Machine Intialization
+ * ENP-2611 Machine Initialization
  *************************************************************************/
 static struct flash_platform_data enp2611_flash_platform_data = {
 	.map_name	= "cfi_probe",
diff --git a/arch/arm/mach-ixp2000/ixdp2x00.c b/arch/arm/mach-ixp2000/ixdp2x00.c
index 52b368b..011065b 100644
--- a/arch/arm/mach-ixp2000/ixdp2x00.c
+++ b/arch/arm/mach-ixp2000/ixdp2x00.c
@@ -195,7 +195,7 @@ void __init ixdp2x00_map_io(void)
  * instances  of the kernel. So far so good. Peers on the PCI bus running 
  * Linux is a common design in telecom systems. The problem is that instead 
  * of all the devices being controlled by a single host, different
- * devices are controlles by different NPUs on the same bus, leading to
+ * devices are controlled by different NPUs on the same bus, leading to
  * multiple hosts on the bus. The exact bus layout looks like:
  *
  *                   Bus 0
@@ -211,7 +211,7 @@ void __init ixdp2x00_map_io(void)
  *                  |      |         |         |      |
  *             ... Dev    PMC       Media     Eth0   Eth1 ...
  *
- * The master controlls all but Eth1, which is controlled by the
+ * The master controls all but Eth1, which is controlled by the
  * slave. What this means is that the both the master and the slave
  * have to scan the bus, but only one of them can enumerate the bus.
  * In addition, after the bus is scanned, each kernel must remove
diff --git a/arch/arm/mach-ixp2000/ixdp2x01.c b/arch/arm/mach-ixp2000/ixdp2x01.c
index 3084a5f..d3d730d 100644
--- a/arch/arm/mach-ixp2000/ixdp2x01.c
+++ b/arch/arm/mach-ixp2000/ixdp2x01.c
@@ -276,7 +276,7 @@ static int __init ixdp2x01_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 	/* Device is located after first MB bridge */
 	case 0x0008:
 		if (tmp_bus == dev->bus) {
-			/* Device is located directy after first MB bridge */
+			/* Device is located directly after first MB bridge */
 			switch (devpin) {
 			case DEVPIN(1, 1):	/* Onboard 82546 ch 0 */
 				if (machine_is_ixdp2401())
@@ -299,7 +299,7 @@ static int __init ixdp2x01_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 		break;
 	case 0x0010:
 		if (tmp_bus == dev->bus) {
-			/* Device is located directy after second MB bridge */
+			/* Device is located directly after second MB bridge */
 			/* Secondary bus of second bridge */
 			switch (devpin) {
 			case DEVPIN(0, 1):	/* DB#0 */
@@ -348,7 +348,7 @@ int __init ixdp2x01_pci_init(void)
 subsys_initcall(ixdp2x01_pci_init);
 
 /*************************************************************************
- * IXDP2x01 Machine Intialization
+ * IXDP2x01 Machine Initialization
  *************************************************************************/
 static struct flash_platform_data ixdp2x01_flash_platform_data = {
 	.map_name	= "cfi_probe",
diff --git a/arch/arm/mach-ixp2000/pci.c b/arch/arm/mach-ixp2000/pci.c
index 5a09a90..03f4cf7 100644
--- a/arch/arm/mach-ixp2000/pci.c
+++ b/arch/arm/mach-ixp2000/pci.c
@@ -102,7 +102,7 @@ int ixp2000_pci_read_config(struct pci_bus *bus, unsigned int devfn, int where,
 }
 
 /*
- * We don't do error checks by callling clear_master_aborts() b/c the
+ * We don't do error checks by calling clear_master_aborts() b/c the
  * assumption is that the caller did a read first to make sure a device
  * exists.
  */
diff --git a/arch/arm/mach-ixp23xx/core.c b/arch/arm/mach-ixp23xx/core.c
index b644bba..16356ff 100644
--- a/arch/arm/mach-ixp23xx/core.c
+++ b/arch/arm/mach-ixp23xx/core.c
@@ -389,7 +389,7 @@ struct sys_timer ixp23xx_timer = {
 
 
 /*************************************************************************
- * IXP23xx Platform Initializaion
+ * IXP23xx Platform Initialization
  *************************************************************************/
 static struct resource ixp23xx_uart_resources[] = {
 	{
diff --git a/arch/arm/mach-ixp4xx/gtwx5715-setup.c b/arch/arm/mach-ixp4xx/gtwx5715-setup.c
index 30f1300..dc6725b 100644
--- a/arch/arm/mach-ixp4xx/gtwx5715-setup.c
+++ b/arch/arm/mach-ixp4xx/gtwx5715-setup.c
@@ -1,7 +1,7 @@
 /*
  * arch/arm/mach-ixp4xx/gtwx5715-setup.c
  *
- * Gemtek GTWX5715 (Linksys WRV54G) board settup
+ * Gemtek GTWX5715 (Linksys WRV54G) board setup
  *
  * Copyright (C) 2004 George T. Joseph
  * Derived from Coyote
diff --git a/arch/arm/mach-lh7a40x/lcd-panel.h b/arch/arm/mach-lh7a40x/lcd-panel.h
index 4fb2efc..df6e38e 100644
--- a/arch/arm/mach-lh7a40x/lcd-panel.h
+++ b/arch/arm/mach-lh7a40x/lcd-panel.h
@@ -126,7 +126,7 @@ static struct clcd_panel_extra lcd_panel_extra = {
 
  */
 
-/* The full horozontal cycle (Th) is clock/360/400/450. */
+/* The full horizontal cycle (Th) is clock/360/400/450. */
 /* The full vertical   cycle (Tv) is line/251/262/280. */
 
 #define PIX_CLOCK_TARGET	(6300000) /* -/6.3/7 MHz */
@@ -162,7 +162,7 @@ static struct clcd_panel lcd_panel = {
 	/* Logic Product Development LCD 6.4" VGA -10 */
 	/* Sharp PN LQ64D343 */
 
-/* The full horozontal cycle (Th) is clock/750/800/900. */
+/* The full horizontal cycle (Th) is clock/750/800/900. */
 /* The full vertical   cycle (Tv) is line/515/525/560. */
 
 #define PIX_CLOCK_TARGET	(28330000)
@@ -243,7 +243,7 @@ static struct clcd_panel lcd_panel = {
  * (fdisk, e2fsck).  And, at that speed the display may have a visible
  * flicker. */
 
-/* The full horozontal cycle (Th) is clock/832/1056/1395. */
+/* The full horizontal cycle (Th) is clock/832/1056/1395. */
 
 #define PIX_CLOCK_TARGET	(20000000)
 #define PIX_CLOCK_DIVIDER	CLOCK_TO_DIV (PIX_CLOCK_TARGET, HCLK)
diff --git a/arch/arm/mach-ns9xxx/time.c b/arch/arm/mach-ns9xxx/time.c
index dd25708..b97d0c5 100644
--- a/arch/arm/mach-ns9xxx/time.c
+++ b/arch/arm/mach-ns9xxx/time.c
@@ -35,7 +35,7 @@ static unsigned long ns9xxx_timer_gettimeoffset(void)
 {
 	/* return the microseconds which have passed since the last interrupt
 	 * was _serviced_.  That is, if an interrupt is pending or the counter
-	 * reloads, return one periode more. */
+	 * reloads, return one period more. */
 
 	u32 counter1 = SYS_TR(0);
 	int pending = SYS_ISR & (1 << IRQ_TIMER0);
diff --git a/arch/arm/mach-omap1/Kconfig b/arch/arm/mach-omap1/Kconfig
index 856c681..f6ecdd3 100644
--- a/arch/arm/mach-omap1/Kconfig
+++ b/arch/arm/mach-omap1/Kconfig
@@ -38,7 +38,7 @@ config MACH_OMAP_H2
 config MACH_OMAP_H3
 	bool "TI H3 Support"
 	depends on ARCH_OMAP1 && ARCH_OMAP16XX
-	select GPIOEXPANDER_OMAP
+#	select GPIOEXPANDER_OMAP
     	help
 	  TI OMAP 1710 H3 board support. Say Y here if you have such
 	  a board.
diff --git a/arch/arm/mach-omap1/board-osk.c b/arch/arm/mach-omap1/board-osk.c
index 7d0cf7a..e713029 100644
--- a/arch/arm/mach-omap1/board-osk.c
+++ b/arch/arm/mach-omap1/board-osk.c
@@ -385,7 +385,7 @@ static void __init osk_init(void)
 	/* Workaround for wrong CS3 (NOR flash) timing
 	 * There are some U-Boot versions out there which configure
 	 * wrong CS3 memory timings. This mainly leads to CRC
-	 * or similiar errors if you use NOR flash (e.g. with JFFS2)
+	 * or similar errors if you use NOR flash (e.g. with JFFS2)
 	 */
 	if (EMIFS_CCS(3) != EMIFS_CS3_VAL)
 		EMIFS_CCS(3) = EMIFS_CS3_VAL;
diff --git a/arch/arm/mach-omap1/board-palmte.c b/arch/arm/mach-omap1/board-palmte.c
index 4bc8a62..0158241 100644
--- a/arch/arm/mach-omap1/board-palmte.c
+++ b/arch/arm/mach-omap1/board-palmte.c
@@ -7,7 +7,7 @@
  *
  * Original version : Laurent Gonzalez
  *
- * Maintainters : http://palmtelinux.sf.net
+ * Maintainers : http://palmtelinux.sf.net
  *                palmtelinux-developpers@lists.sf.net
  *
  * This program is free software; you can redistribute it and/or modify
diff --git a/arch/arm/mach-omap1/pm.c b/arch/arm/mach-omap1/pm.c
index 8caee68..5bb348e 100644
--- a/arch/arm/mach-omap1/pm.c
+++ b/arch/arm/mach-omap1/pm.c
@@ -438,7 +438,7 @@ void omap_pm_suspend(void)
 		omap_writew(0, ULPD_SOFT_DISABLE_REQ_REG);
 
 	/*
-	 * Reenable interrupts
+	 * Re-enable interrupts
 	 */
 
 	local_irq_enable();
diff --git a/arch/arm/mach-omap2/clock.c b/arch/arm/mach-omap2/clock.c
index 5170481..588adb5 100644
--- a/arch/arm/mach-omap2/clock.c
+++ b/arch/arm/mach-omap2/clock.c
@@ -443,7 +443,7 @@ static long omap2_clk_round_rate(struct clk *clk, unsigned long rate)
 
 /*
  * Check the DLL lock state, and return tue if running in unlock mode.
- * This is needed to compenste for the shifted DLL value in unlock mode.
+ * This is needed to compensate for the shifted DLL value in unlock mode.
  */
 static u32 omap2_dll_force_needed(void)
 {
diff --git a/arch/arm/mach-omap2/clock.h b/arch/arm/mach-omap2/clock.h
index 162978f..4f79186 100644
--- a/arch/arm/mach-omap2/clock.h
+++ b/arch/arm/mach-omap2/clock.h
@@ -338,7 +338,7 @@ struct prcm_config {
 /*
  * These represent optimal values for common parts, it won't work for all.
  * As long as you scale down, most parameters are still work, they just
- * become sub-optimal. The RFR value goes in the oppisite direction. If you
+ * become sub-optimal. The RFR value goes in the opposite direction. If you
  * don't adjust it down as your clock period increases the refresh interval
  * will not be met. Setting all parameters for complete worst case may work,
  * but may cut memory performance by 2x. Due to errata the DLLs need to be
@@ -384,7 +384,7 @@ struct prcm_config {
  * Filling in table based on H4 boards and 2430-SDPs variants available.
  * There are quite a few more rates combinations which could be defined.
  *
- * When multiple values are defiend the start up will try and choose the
+ * When multiple values are defined the start up will try and choose the
  * fastest one. If a 'fast' value is defined, then automatically, the /2
  * one should be included as it can be used.	Generally having more that
  * one fast set does not make sense, as static timings need to be changed
diff --git a/arch/arm/mach-pxa/corgi_lcd.c b/arch/arm/mach-pxa/corgi_lcd.c
index a72476c..365b943 100644
--- a/arch/arm/mach-pxa/corgi_lcd.c
+++ b/arch/arm/mach-pxa/corgi_lcd.c
@@ -40,7 +40,7 @@
 #define PICTRL_ADRS     0x06
 #define POLCTRL_ADRS    0x07
 
-/* Resgister Bit Definitions */
+/* Register Bit Definitions */
 #define RESCTL_QVGA     0x01
 #define RESCTL_VGA      0x00
 
@@ -55,11 +55,11 @@
 #define POWER0_COM_DCLK 0x01  /* COM Voltage DC Bias DAC Serial Data Clock */
 #define POWER0_COM_DOUT 0x02  /* COM Voltage DC Bias DAC Serial Data Out */
 #define POWER0_DAC_ON   0x04  /* DAC Power Supply ON */
-#define POWER0_COM_ON   0x08  /* COM Powewr Supply ON */
+#define POWER0_COM_ON   0x08  /* COM Power Supply ON */
 #define POWER0_VCC5_ON  0x10  /* VCC5 Power Supply ON */
 
 #define POWER0_DAC_OFF  0x00  /* DAC Power Supply OFF */
-#define POWER0_COM_OFF  0x00  /* COM Powewr Supply OFF */
+#define POWER0_COM_OFF  0x00  /* COM Power Supply OFF */
 #define POWER0_VCC5_OFF 0x00  /* VCC5 Power Supply OFF */
 
 #define PICTRL_INIT_STATE      0x01
@@ -145,7 +145,7 @@ static void lcdtg_set_common_voltage(u8 base_data, u8 data)
 	lcdtg_i2c_send_stop(base_data);
 }
 
-/* Set Phase Adjuct */
+/* Set Phase Adjust */
 static void lcdtg_set_phadadj(int mode)
 {
 	int adj;
@@ -226,7 +226,7 @@ static void lcdtg_hw_init(int mode)
 		/* Signals output enable */
 		corgi_ssp_lcdtg_send(PICTRL_ADRS, 0);
 
-		/* Set Phase Adjuct */
+		/* Set Phase Adjust */
 		lcdtg_set_phadadj(mode);
 
 		/* Initialize for Input Signals from ATI */
diff --git a/arch/arm/mach-pxa/corgi_ssp.c b/arch/arm/mach-pxa/corgi_ssp.c
index ff6b4ee..40dea3d 100644
--- a/arch/arm/mach-pxa/corgi_ssp.c
+++ b/arch/arm/mach-pxa/corgi_ssp.c
@@ -32,7 +32,7 @@ static struct corgissp_machinfo *ssp_machinfo;
  * There are three devices connected to the SSP interface:
  *   1. A touchscreen controller (TI ADS7846 compatible)
  *   2. An LCD contoller (with some Backlight functionality)
- *   3. A battery moinitoring IC (Maxim MAX1111)
+ *   3. A battery monitoring IC (Maxim MAX1111)
  *
  * Each device uses a different speed/mode of communication.
  *
diff --git a/arch/arm/mach-realview/localtimer.c b/arch/arm/mach-realview/localtimer.c
index caf6b8b..c7bdf04 100644
--- a/arch/arm/mach-realview/localtimer.c
+++ b/arch/arm/mach-realview/localtimer.c
@@ -30,7 +30,7 @@ static unsigned long mpcore_timer_rate;
 /*
  * local_timer_ack: checks for a local timer interrupt.
  *
- * If a local timer interrupt has occured, acknowledge and return 1.
+ * If a local timer interrupt has occurred, acknowledge and return 1.
  * Otherwise, return 0.
  */
 int local_timer_ack(void)
diff --git a/arch/arm/mach-s3c2410/mach-h1940.c b/arch/arm/mach-s3c2410/mach-h1940.c
index 5ccd0be..5c9bcea 100644
--- a/arch/arm/mach-s3c2410/mach-h1940.c
+++ b/arch/arm/mach-s3c2410/mach-h1940.c
@@ -17,6 +17,7 @@
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/sysdev.h>
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
 
diff --git a/arch/arm/mach-s3c2410/mach-qt2410.c b/arch/arm/mach-s3c2410/mach-qt2410.c
index 9cc4253..d86e6f1 100644
--- a/arch/arm/mach-s3c2410/mach-qt2410.c
+++ b/arch/arm/mach-s3c2410/mach-qt2410.c
@@ -27,6 +27,7 @@
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/sysdev.h>
 #include <linux/platform_device.h>
 #include <linux/serial_core.h>
 #include <linux/spi/spi.h>
diff --git a/arch/arm/mach-s3c2412/dma.c b/arch/arm/mach-s3c2412/dma.c
index d0f4695..668ccce 100644
--- a/arch/arm/mach-s3c2412/dma.c
+++ b/arch/arm/mach-s3c2412/dma.c
@@ -59,8 +59,8 @@ static struct s3c24xx_dma_map __initdata s3c2412_dma_mappings[] = {
 	[DMACH_SPI1] = {
 		.name		= "spi1",
 		.channels	= MAP(S3C2412_DMAREQSEL_SPI1TX),
-		.hw_addr.to	= S3C2410_PA_SPI + 0x20 + S3C2410_SPTDAT,
-		.hw_addr.from	= S3C2410_PA_SPI + 0x20 + S3C2410_SPRDAT,
+		.hw_addr.to	= S3C2410_PA_SPI + S3C2412_SPI1 + S3C2410_SPTDAT,
+		.hw_addr.from	= S3C2410_PA_SPI + S3C2412_SPI1  + S3C2410_SPRDAT,
 	},
 	[DMACH_UART0] = {
 		.name		= "uart0",
diff --git a/arch/arm/mach-s3c2412/s3c2412.c b/arch/arm/mach-s3c2412/s3c2412.c
index aafe0bc..c602aa3 100644
--- a/arch/arm/mach-s3c2412/s3c2412.c
+++ b/arch/arm/mach-s3c2412/s3c2412.c
@@ -37,6 +37,7 @@
 #include <asm/arch/regs-gpio.h>
 #include <asm/arch/regs-gpioj.h>
 #include <asm/arch/regs-dsc.h>
+#include <asm/arch/regs-spi.h>
 
 #include <asm/plat-s3c24xx/s3c2412.h>
 #include <asm/plat-s3c24xx/cpu.h>
@@ -74,6 +75,14 @@ void __init s3c2412_init_uarts(struct s3c2410_uartcfg *cfg, int no)
 	s3c_device_sdi.name  = "s3c2412-sdi";
 	s3c_device_lcd.name  = "s3c2412-lcd";
 	s3c_device_nand.name = "s3c2412-nand";
+
+	/* spi channel related changes, s3c2412/13 specific */
+	s3c_device_spi0.name = "s3c2412-spi";
+	s3c_device_spi0.resource[0].end = S3C24XX_PA_SPI + 0x24;
+	s3c_device_spi1.name = "s3c2412-spi";
+	s3c_device_spi1.resource[0].start = S3C24XX_PA_SPI + S3C2412_SPI1;
+	s3c_device_spi1.resource[0].end = S3C24XX_PA_SPI + S3C2412_SPI1 + 0x24;
+
 }
 
 /* s3c2412_idle
diff --git a/arch/arm/mach-s3c2440/mach-osiris.c b/arch/arm/mach-s3c2440/mach-osiris.c
index 324f5a2..4d6c7a5 100644
--- a/arch/arm/mach-s3c2440/mach-osiris.c
+++ b/arch/arm/mach-s3c2440/mach-osiris.c
@@ -45,7 +45,7 @@
 #include <asm/plat-s3c24xx/devs.h>
 #include <asm/plat-s3c24xx/cpu.h>
 
-/* onboard perihpheral map */
+/* onboard perihperal map */
 
 static struct map_desc osiris_iodesc[] __initdata = {
   /* ISA IO areas (may be over-written later) */
diff --git a/arch/arm/mach-s3c2440/mach-rx3715.c b/arch/arm/mach-s3c2440/mach-rx3715.c
index c3cc4bf..866ff71 100644
--- a/arch/arm/mach-s3c2440/mach-rx3715.c
+++ b/arch/arm/mach-s3c2440/mach-rx3715.c
@@ -19,6 +19,7 @@
 #include <linux/init.h>
 #include <linux/tty.h>
 #include <linux/console.h>
+#include <linux/sysdev.h>
 #include <linux/platform_device.h>
 #include <linux/serial_core.h>
 #include <linux/serial.h>
diff --git a/arch/arm/mach-s3c2443/clock.c b/arch/arm/mach-s3c2443/clock.c
index 0b6e360..5955efb 100644
--- a/arch/arm/mach-s3c2443/clock.c
+++ b/arch/arm/mach-s3c2443/clock.c
@@ -747,6 +747,25 @@ static struct clk init_clocks[] = {
 		.enable		= s3c2443_clkcon_enable_h,
 		.ctrlbit	= S3C2443_HCLKCON_USBD,
 	}, {
+		.name		= "hsmmc",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c2443_clkcon_enable_h,
+		.ctrlbit	= S3C2443_HCLKCON_HSMMC,
+	}, {
+		.name		= "cfc",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c2443_clkcon_enable_h,
+		.ctrlbit	= S3C2443_HCLKCON_CFC,
+		.ctrlbit	= S3C2443_HCLKCON_HSMMC,
+	}, {
+		.name		= "ssmc",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c2443_clkcon_enable_h,
+		.ctrlbit	= S3C2443_HCLKCON_SSMC,
+	}, {
 		.name		= "timers",
 		.id		= -1,
 		.parent		= &clk_p,
@@ -791,7 +810,8 @@ static struct clk init_clocks[] = {
 		.name		= "usb-bus-host",
 		.id		= -1,
 		.parent		= &clk_usb_bus_host,
-	}, {	.name		= "ac97",
+	}, {
+		.name		= "ac97",
 		.id		= -1,
 		.parent		= &clk_p,
 		.ctrlbit	= S3C2443_PCLKCON_AC97,
diff --git a/arch/arm/mach-s3c2443/mach-smdk2443.c b/arch/arm/mach-s3c2443/mach-smdk2443.c
index b71ee53..b1eb709 100644
--- a/arch/arm/mach-s3c2443/mach-smdk2443.c
+++ b/arch/arm/mach-s3c2443/mach-smdk2443.c
@@ -104,6 +104,7 @@ static struct s3c2410_uartcfg smdk2443_uartcfgs[] __initdata = {
 static struct platform_device *smdk2443_devices[] __initdata = {
 	&s3c_device_wdt,
 	&s3c_device_i2c,
+	&s3c_device_hsmmc,
 };
 
 static void __init smdk2443_map_io(void)
diff --git a/arch/arm/mach-s3c2443/s3c2443.c b/arch/arm/mach-s3c2443/s3c2443.c
index 11b1d0b..8d81171 100644
--- a/arch/arm/mach-s3c2443/s3c2443.c
+++ b/arch/arm/mach-s3c2443/s3c2443.c
@@ -63,6 +63,10 @@ int __init s3c2443_init(void)
 
 	s3c_device_nand.name = "s3c2412-nand";
 
+	/* change WDT IRQ number */
+	s3c_device_wdt.resource[1].start = IRQ_S3C2443_WDT;
+	s3c_device_wdt.resource[1].end   = IRQ_S3C2443_WDT;
+
 	return sysdev_register(&s3c2443_sysdev);
 }
 
diff --git a/arch/arm/mach-sa1100/time.c b/arch/arm/mach-sa1100/time.c
index 416e277..29cb0c1 100644
--- a/arch/arm/mach-sa1100/time.c
+++ b/arch/arm/mach-sa1100/time.c
@@ -25,7 +25,7 @@ static unsigned long __init sa1100_get_rtc_time(void)
 {
 	/*
 	 * According to the manual we should be able to let RTTR be zero
-	 * and then a default diviser for a 32.768KHz clock is used.
+	 * and then a default divisor for a 32.768KHz clock is used.
 	 * Apparently this doesn't work, at least for my SA1110 rev 5.
 	 * If the clock divider is uninitialized then reset it to the
 	 * default value to get the 1Hz clock.
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 15f0284..5f472a8 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -351,6 +351,7 @@ config CPU_V6
 	select CPU_CACHE_V6
 	select CPU_CACHE_VIPT
 	select CPU_CP15_MMU
+	select CPU_HAS_ASID
 	select CPU_COPY_V6 if MMU
 	select CPU_TLB_V6 if MMU
 
@@ -376,6 +377,7 @@ config CPU_V7
 	select CPU_CACHE_V7
 	select CPU_CACHE_VIPT
 	select CPU_CP15_MMU
+	select CPU_HAS_ASID
 	select CPU_COPY_V6 if MMU
 	select CPU_TLB_V6 if MMU
 
@@ -498,6 +500,12 @@ config CPU_TLB_V6
 
 endif
 
+config CPU_HAS_ASID
+	bool
+	help
+	  This indicates whether the CPU has the ASID register; used to
+	  tag TLB and possibly cache entries.
+
 config CPU_CP15
 	bool
 	help
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index 19ca333..36440c8 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 1995  Linus Torvalds
  *  Modifications for ARM processor (c) 1995-2001 Russell King
- *  Thumb aligment fault fixups (c) 2004 MontaVista Software, Inc.
+ *  Thumb alignment fault fixups (c) 2004 MontaVista Software, Inc.
  *  - Adapted from gdb/sim/arm/thumbemu.c -- Thumb instruction emulation.
  *    Copyright (C) 1996, Cygnus Software Technologies Ltd.
  *
diff --git a/arch/arm/mm/ioremap.c b/arch/arm/mm/ioremap.c
index d6167ad..f3ade18 100644
--- a/arch/arm/mm/ioremap.c
+++ b/arch/arm/mm/ioremap.c
@@ -346,7 +346,7 @@ void __iounmap(volatile void __iomem *addr)
 #ifndef CONFIG_SMP
 	/*
 	 * If this is a section based mapping we need to handle it
-	 * specially as the VM subysystem does not know how to handle
+	 * specially as the VM subsystem does not know how to handle
 	 * such a beast. We need the lock here b/c we need to clear
 	 * all the mappings before the area can be reclaimed
 	 * by someone else.
diff --git a/arch/arm/mm/mmap.c b/arch/arm/mm/mmap.c
index 2c4c242..2728b0e 100644
--- a/arch/arm/mm/mmap.c
+++ b/arch/arm/mm/mmap.c
@@ -5,7 +5,7 @@
 #include <linux/mm.h>
 #include <linux/mman.h>
 #include <linux/shm.h>
-
+#include <linux/sched.h>
 #include <asm/system.h>
 
 #define COLOUR_ALIGN(addr,pgoff)		\
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 2ba1530..02e050a 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -92,7 +92,7 @@ static struct cachepolicy cache_policies[] __initdata = {
 };
 
 /*
- * These are useful for identifing cache coherency
+ * These are useful for identifying cache coherency
  * problems by allowing the cache or the cache and
  * writebuffer to be turned off.  (Note: the write
  * buffer should not be on and the cache off).
diff --git a/arch/arm/plat-iop/pci.c b/arch/arm/plat-iop/pci.c
index e2744b7..2b5aa11 100644
--- a/arch/arm/plat-iop/pci.c
+++ b/arch/arm/plat-iop/pci.c
@@ -19,6 +19,7 @@
 #include <linux/ioport.h>
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/signal.h>
 #include <asm/system.h>
 #include <asm/hardware.h>
 #include <asm/mach/pci.h>
@@ -85,10 +86,10 @@ static int iop3xx_pci_status(void)
 
 /*
  * Simply write the address register and read the configuration
- * data.  Note that the 4 nop's ensure that we are able to handle
+ * data.  Note that the 4 nops ensure that we are able to handle
  * a delayed abort (in theory.)
  */
-static inline u32 iop3xx_read(unsigned long addr)
+static u32 iop3xx_read(unsigned long addr)
 {
 	u32 val;
 
@@ -321,7 +322,7 @@ void __init iop3xx_atu_disable(void)
 /* Flag to determine whether the ATU is initialized and the PCI bus scanned */
 int init_atu;
 
-void iop3xx_pci_preinit(void)
+void __init iop3xx_pci_preinit(void)
 {
 	if (iop3xx_get_init_atu() == IOP3XX_INIT_ATU_ENABLE) {
 		iop3xx_atu_disable();
diff --git a/arch/arm/plat-omap/common.c b/arch/arm/plat-omap/common.c
index dd8708a..7987aa6 100644
--- a/arch/arm/plat-omap/common.c
+++ b/arch/arm/plat-omap/common.c
@@ -73,7 +73,7 @@ static const void *get_config(u16 tag, size_t len, int skip, size_t *len_out)
 	}
 	if (info != NULL) {
 		/* Check the length as a lame attempt to check for
-		 * binary inconsistancy. */
+		 * binary inconsistency. */
 		if (len != NO_LENGTH_CHECK) {
 			/* Word-align len */
 			if (len & 0x03)
diff --git a/arch/arm/plat-omap/dma.c b/arch/arm/plat-omap/dma.c
index 55a4d3b..88d5b6d 100644
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@ -1172,7 +1172,7 @@ static void set_b1_regs(void)
 		break;
 	default:
 		BUG();
-		return;	/* Supress warning about uninitialized vars */
+		return;	/* Suppress warning about uninitialized vars */
 	}
 
 	if (omap_dma_in_1510_mode()) {
diff --git a/arch/arm/plat-omap/sram.c b/arch/arm/plat-omap/sram.c
index bc46f33..1f23f04 100644
--- a/arch/arm/plat-omap/sram.c
+++ b/arch/arm/plat-omap/sram.c
@@ -59,8 +59,8 @@ extern unsigned long omapfb_reserve_sram(unsigned long sram_pstart,
 
 /*
  * Depending on the target RAMFS firewall setup, the public usable amount of
- * SRAM varies.  The default accessable size for all device types is 2k. A GP
- * device allows ARM11 but not other initators for full size. This
+ * SRAM varies.  The default accessible size for all device types is 2k. A GP
+ * device allows ARM11 but not other initiators for full size. This
  * functionality seems ok until some nice security API happens.
  */
 static int is_sram_locked(void)
@@ -71,7 +71,7 @@ static int is_sram_locked(void)
 		type = __raw_readl(VA_CONTROL_STAT) & TYPE_MASK;
 
 	if (type == GP_DEVICE) {
-		/* RAMFW: R/W access to all initators for all qualifier sets */
+		/* RAMFW: R/W access to all initiators for all qualifier sets */
 		if (cpu_is_omap242x()) {
 			__raw_writel(0xFF, VA_REQINFOPERM0); /* all q-vects */
 			__raw_writel(0xCFDE, VA_READPERM0);  /* all i-read */
diff --git a/arch/arm/plat-omap/usb.c b/arch/arm/plat-omap/usb.c
index 25489aa..a5aedf9 100644
--- a/arch/arm/plat-omap/usb.c
+++ b/arch/arm/plat-omap/usb.c
@@ -177,7 +177,7 @@ static u32 __init omap_usb0_init(unsigned nwires, unsigned is_device)
 
 	/* NOTE:  SPEED and SUSP aren't configured here.  OTG hosts
 	 * may be able to use I2C requests to set those bits along
-	 * with VBUS switching and overcurrent detction.
+	 * with VBUS switching and overcurrent detection.
 	 */
 
 	if (cpu_class_is_omap1() && nwires != 6)
diff --git a/arch/arm/plat-s3c24xx/common-smdk.c b/arch/arm/plat-s3c24xx/common-smdk.c
index 908efa7..7ed19b2 100644
--- a/arch/arm/plat-s3c24xx/common-smdk.c
+++ b/arch/arm/plat-s3c24xx/common-smdk.c
@@ -18,6 +18,7 @@
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/sysdev.h>
 #include <linux/platform_device.h>
 
 #include <linux/mtd/mtd.h>
@@ -29,6 +30,7 @@
 #include <asm/mach/map.h>
 #include <asm/mach/irq.h>
 
+#include <asm/mach-types.h>
 #include <asm/hardware.h>
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -192,6 +194,9 @@ void __init smdk_machine_init(void)
 	s3c2410_gpio_setpin(S3C2410_GPF6, 1);
 	s3c2410_gpio_setpin(S3C2410_GPF7, 1);
 
+	if (machine_is_smdk2443())
+		smdk_nand_info.twrph0 = 50;
+
 	s3c_device_nand.dev.platform_data = &smdk_nand_info;
 
 	platform_add_devices(smdk_devs, ARRAY_SIZE(smdk_devs));
diff --git a/arch/arm/plat-s3c24xx/devs.c b/arch/arm/plat-s3c24xx/devs.c
index 0fe53b3..5875da0 100644
--- a/arch/arm/plat-s3c24xx/devs.c
+++ b/arch/arm/plat-s3c24xx/devs.c
@@ -33,6 +33,7 @@
 
 #include <asm/plat-s3c24xx/devs.h>
 #include <asm/plat-s3c24xx/cpu.h>
+#include <asm/arch/regs-spi.h>
 
 /* Serial port registrations */
 
@@ -402,6 +403,36 @@ struct platform_device s3c_device_sdi = {
 
 EXPORT_SYMBOL(s3c_device_sdi);
 
+/* High-speed MMC/SD */
+
+static struct resource s3c_hsmmc_resource[] = {
+	[0] = {
+		.start = S3C2443_PA_HSMMC,
+		.end   = S3C2443_PA_HSMMC + S3C2443_SZ_HSMMC - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_S3C2443_HSMMC,
+		.end   = IRQ_S3C2443_HSMMC,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static u64 s3c_device_hsmmc_dmamask = 0xffffffffUL;
+
+struct platform_device s3c_device_hsmmc = {
+	.name		  = "s3c-sdhci",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_hsmmc_resource),
+	.resource	  = s3c_hsmmc_resource,
+	.dev              = {
+		.dma_mask = &s3c_device_hsmmc_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+
+
+
 /* SPI (0) */
 
 static struct resource s3c_spi0_resource[] = {
@@ -437,8 +468,8 @@ EXPORT_SYMBOL(s3c_device_spi0);
 
 static struct resource s3c_spi1_resource[] = {
 	[0] = {
-		.start = S3C24XX_PA_SPI + 0x20,
-		.end   = S3C24XX_PA_SPI + 0x20 + 0x1f,
+		.start = S3C24XX_PA_SPI + S3C2410_SPI1,
+		.end   = S3C24XX_PA_SPI + S3C2410_SPI1 + 0x1f,
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
diff --git a/arch/arm/plat-s3c24xx/dma.c b/arch/arm/plat-s3c24xx/dma.c
index 6f03c93..08d80f2 100644
--- a/arch/arm/plat-s3c24xx/dma.c
+++ b/arch/arm/plat-s3c24xx/dma.c
@@ -1153,7 +1153,7 @@ EXPORT_SYMBOL(s3c2410_dma_set_buffdone_fn);
  *
  * hwcfg:     the value for xxxSTCn register,
  *            bit 0: 0=increment pointer, 1=leave pointer
- *            bit 1: 0=soucre is AHB, 1=soucre is APB
+ *            bit 1: 0=source is AHB, 1=source is APB
  *
  * devaddr:   physical address of the source
 */
diff --git a/arch/arm/plat-s3c24xx/pm-simtec.c b/arch/arm/plat-s3c24xx/pm-simtec.c
index bd965f2..cb0b3a4 100644
--- a/arch/arm/plat-s3c24xx/pm-simtec.c
+++ b/arch/arm/plat-s3c24xx/pm-simtec.c
@@ -18,6 +18,7 @@
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/sysdev.h>
 #include <linux/device.h>
 
 #include <asm/mach/arch.h>
diff --git a/arch/arm/plat-s3c24xx/pm.c b/arch/arm/plat-s3c24xx/pm.c
index c6b03f8..5692ecc 100644
--- a/arch/arm/plat-s3c24xx/pm.c
+++ b/arch/arm/plat-s3c24xx/pm.c
@@ -555,7 +555,7 @@ static int s3c2410_pm_enter(suspend_state_t state)
 	__raw_writel(__raw_readl(S3C2410_INTPND), S3C2410_INTPND);
 	__raw_writel(__raw_readl(S3C2410_SRCPND), S3C2410_SRCPND);
 
-	/* call cpu specific preperation */
+	/* call cpu specific preparation */
 
 	pm_cpu_prep();
 
diff --git a/arch/arm26/kernel/vmlinux-arm26-xip.lds.in b/arch/arm26/kernel/vmlinux-arm26-xip.lds.in
index 046a850..4ec715c 100644
--- a/arch/arm26/kernel/vmlinux-arm26-xip.lds.in
+++ b/arch/arm26/kernel/vmlinux-arm26-xip.lds.in
@@ -64,7 +64,7 @@ SECTIONS
 
 	.text : {			/* Real text segment		*/
 		_text = .;		/* Text and read-only data	*/
-			*(.text)
+			TEXT_TEXT
 			SCHED_TEXT
 			LOCK_TEXT       /* FIXME - borrowed from arm32 - check*/
 			*(.fixup)
@@ -111,7 +111,7 @@ SECTIONS
 		/*
 		 * and the usual data section
 		 */
-		*(.data)
+		DATA_DATA
 		CONSTRUCTORS
 
 		*(.init.data)
diff --git a/arch/arm26/kernel/vmlinux-arm26.lds.in b/arch/arm26/kernel/vmlinux-arm26.lds.in
index 1d2949e..6c44f6a 100644
--- a/arch/arm26/kernel/vmlinux-arm26.lds.in
+++ b/arch/arm26/kernel/vmlinux-arm26.lds.in
@@ -65,7 +65,7 @@ SECTIONS
 
 	.text : {			/* Real text segment		*/
 		_text = .;		/* Text and read-only data	*/
-			*(.text)
+			TEXT_TEXT
 			SCHED_TEXT
 			LOCK_TEXT
 			*(.fixup)
@@ -106,7 +106,7 @@ SECTIONS
 		/*
 		 * and the usual data section
 		 */
-		*(.data)
+		DATA_DATA
 		CONSTRUCTORS
 
 		_edata = .;
diff --git a/arch/avr32/kernel/vmlinux.lds.c b/arch/avr32/kernel/vmlinux.lds.c
index e7f72c9..db0438f 100644
--- a/arch/avr32/kernel/vmlinux.lds.c
+++ b/arch/avr32/kernel/vmlinux.lds.c
@@ -76,7 +76,7 @@ SECTIONS
 		. = 0x100;
 		*(.scall.text)
 		*(.irq.text)
-		*(.text)
+		TEXT_TEXT
 		SCHED_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
@@ -112,7 +112,7 @@ SECTIONS
 
 		/* And the rest... */
 		*(.data.rel*)
-		*(.data)
+		DATA_DATA
 		CONSTRUCTORS
 
 		_edata = .;
diff --git a/arch/blackfin/Kconfig b/arch/blackfin/Kconfig
index d80e5b1..b1b111b 100644
--- a/arch/blackfin/Kconfig
+++ b/arch/blackfin/Kconfig
@@ -25,6 +25,10 @@ config BLACKFIN
 	bool
 	default y
 
+config ZONE_DMA
+	bool
+	default y
+
 config BFIN
 	bool
 	default y
@@ -189,7 +193,7 @@ config BFIN537_BLUETECHNIX_CM
 	  CM-BF537 support for EVAL- and DEV-Board.
 
 config BFIN561_BLUETECHNIX_CM
-	bool "BF561-CM"
+	bool "Bluetechnix CM-BF561"
 	depends on (BF561)
 	help
 	  CM-BF561 support for EVAL- and DEV-Board.
@@ -200,6 +204,12 @@ config BFIN561_EZKIT
 	help
 	  BF561-EZKIT-LITE board Support.
 
+config BFIN561_TEPLA
+	bool "BF561-TEPLA"
+	depends on (BF561)
+	help
+	 BF561-TEPLA board Support.
+
 config PNAV10
 	bool "PNAV 1.0 board"
 	depends on (BF537)
diff --git a/arch/blackfin/Makefile b/arch/blackfin/Makefile
index 52d4dbd..75e89c3 100644
--- a/arch/blackfin/Makefile
+++ b/arch/blackfin/Makefile
@@ -15,6 +15,7 @@ GZFLAGS          := -9
 CFLAGS_MODULE    += -mlong-calls
 KALLSYMS         += --symbol-prefix=_
 
+KBUILD_DEFCONFIG := BF537-STAMP_defconfig
 
 # setup the machine name and the machine dependent settings
 machine-$(CONFIG_BF531) := bf533
diff --git a/arch/blackfin/configs/BF533-EZKIT_defconfig b/arch/blackfin/configs/BF533-EZKIT_defconfig
new file mode 100644
index 0000000..377c8e0
--- /dev/null
+++ b/arch/blackfin/configs/BF533-EZKIT_defconfig
@@ -0,0 +1,1014 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.19.3
+#
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_BLACKFIN=y
+CONFIG_BFIN=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_UCLINUX=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_IRQCHIP_DEMUX_GPIO=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_BIG_ORDER_ALLOC_NOFAIL_MAGIC=3
+# CONFIG_LIMIT_PAGECACHE is not set
+CONFIG_BUDDY=y
+# CONFIG_NP2 is not set
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# Blackfin Processor Options
+#
+
+#
+# Processor and Board Settings
+#
+# CONFIG_BF531 is not set
+# CONFIG_BF532 is not set
+CONFIG_BF533=y
+# CONFIG_BF534 is not set
+# CONFIG_BF535 is not set
+# CONFIG_BF536 is not set
+# CONFIG_BF537 is not set
+# CONFIG_BF561 is not set
+# CONFIG_BF_REV_0_2 is not set
+CONFIG_BF_REV_0_3=y
+# CONFIG_BF_REV_0_4 is not set
+# CONFIG_BF_REV_0_5 is not set
+CONFIG_BFIN_SINGLE_CORE=y
+CONFIG_BFIN533_EZKIT=y
+# CONFIG_BFIN533_STAMP is not set
+# CONFIG_BFIN537_STAMP is not set
+# CONFIG_BFIN533_BLUETECHNIX_CM is not set
+# CONFIG_BFIN537_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_EZKIT is not set
+# CONFIG_PNAV10 is not set
+# CONFIG_GENERIC_BOARD is not set
+CONFIG_MEM_MT48LC16M16A2TG_75=y
+
+#
+# BF533/2/1 Specific Configuration
+#
+
+#
+# Interrupt Priority Assignment
+#
+
+#
+# Priority
+#
+CONFIG_UART_ERROR=7
+CONFIG_SPORT0_ERROR=7
+CONFIG_SPI_ERROR=7
+CONFIG_SPORT1_ERROR=7
+CONFIG_PPI_ERROR=7
+CONFIG_DMA_ERROR=7
+CONFIG_PLLWAKE_ERROR=7
+CONFIG_RTC_ERROR=8
+CONFIG_DMA0_PPI=8
+CONFIG_DMA1_SPORT0RX=9
+CONFIG_DMA2_SPORT0TX=9
+CONFIG_DMA3_SPORT1RX=9
+CONFIG_DMA4_SPORT1TX=9
+CONFIG_DMA5_SPI=10
+CONFIG_DMA6_UARTRX=10
+CONFIG_DMA7_UARTTX=10
+CONFIG_TIMER0=11
+CONFIG_TIMER1=11
+CONFIG_TIMER2=11
+CONFIG_PFA=12
+CONFIG_PFB=12
+CONFIG_MEMDMA0=13
+CONFIG_MEMDMA1=13
+CONFIG_WDTIMER=13
+
+#
+# Board customizations
+#
+
+#
+# Board Setup
+#
+CONFIG_CLKIN_HZ=27000000
+CONFIG_MEM_SIZE=32
+CONFIG_MEM_ADD_WIDTH=9
+CONFIG_BOOT_LOAD=0x1000
+
+#
+# Console UART Setup
+#
+# CONFIG_BAUD_9600 is not set
+# CONFIG_BAUD_19200 is not set
+# CONFIG_BAUD_38400 is not set
+CONFIG_BAUD_57600=y
+# CONFIG_BAUD_115200 is not set
+CONFIG_BAUD_NO_PARITY=y
+# CONFIG_BAUD_PARITY is not set
+CONFIG_BAUD_1_STOPBIT=y
+# CONFIG_BAUD_2_STOPBIT is not set
+
+#
+# Blackfin Kernel Optimizations
+#
+
+#
+# Timer Tick
+#
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+
+#
+# Memory Optimizations
+#
+CONFIG_I_ENTRY_L1=y
+CONFIG_EXCPT_IRQ_SYSC_L1=y
+CONFIG_DO_IRQ_L1=y
+CONFIG_CORE_TIMER_IRQ_L1=y
+CONFIG_IDLE_L1=y
+CONFIG_SCHEDULE_L1=y
+CONFIG_ARITHMETIC_OPS_L1=y
+CONFIG_ACCESS_OK_L1=y
+CONFIG_MEMSET_L1=y
+CONFIG_MEMCPY_L1=y
+CONFIG_SYS_BFIN_SPINLOCK_L1=y
+# CONFIG_IP_CHECKSUM_L1 is not set
+# CONFIG_SYSCALL_TAB_L1 is not set
+# CONFIG_CPLB_SWITCH_TAB_L1 is not set
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_LARGE_ALLOCS=y
+CONFIG_BFIN_DMA_5XX=y
+# CONFIG_DMA_UNCACHED_2M is not set
+CONFIG_DMA_UNCACHED_1M=y
+# CONFIG_DMA_UNCACHED_NONE is not set
+
+#
+# Cache Support
+#
+CONFIG_BLKFIN_CACHE=y
+CONFIG_BLKFIN_DCACHE=y
+# CONFIG_BLKFIN_DCACHE_BANKA is not set
+# CONFIG_BLKFIN_CACHE_LOCK is not set
+# CONFIG_BLKFIN_WB is not set
+CONFIG_BLKFIN_WT=y
+CONFIG_L1_MAX_PIECE=16
+
+#
+# Clock Settings
+#
+# CONFIG_BFIN_KERNEL_CLOCK is not set
+
+#
+# Asynchonous Memory Configuration
+#
+
+#
+# EBIU_AMBCTL Global Control
+#
+CONFIG_C_AMCKEN=y
+CONFIG_C_CDPRIO=y
+# CONFIG_C_AMBEN is not set
+# CONFIG_C_AMBEN_B0 is not set
+# CONFIG_C_AMBEN_B0_B1 is not set
+# CONFIG_C_AMBEN_B0_B1_B2 is not set
+CONFIG_C_AMBEN_ALL=y
+
+#
+# EBIU_AMBCTL Control
+#
+CONFIG_BANK_0=0x7BB0
+CONFIG_BANK_1=0x7BB0
+CONFIG_BANK_2=0x7BB0
+CONFIG_BANK_3=0x99B3
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+CONFIG_PM_WAKEUP_GPIO_BY_SIC_IWR=y
+# CONFIG_PM_WAKEUP_BY_GPIO is not set
+# CONFIG_PM_WAKEUP_GPIO_API is not set
+CONFIG_PM_WAKEUP_SIC_IWR=0x100000
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_MW320D=m
+CONFIG_MTD_RAM=y
+CONFIG_MTD_ROM=m
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_BF5xx=m
+CONFIG_BFIN_FLASH_SIZE=0x400000
+CONFIG_EBIU_FLASH_BASE=0x20000000
+
+#
+# FLASH_EBIU_AMBCTL Control
+#
+CONFIG_BFIN_FLASH_BANK_0=0x7BB0
+CONFIG_BFIN_FLASH_BANK_1=0x7BB0
+CONFIG_BFIN_FLASH_BANK_2=0x7BB0
+CONFIG_BFIN_FLASH_BANK_3=0x7BB0
+# CONFIG_MTD_UCLINUX is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Misc devices
+#
+# CONFIG_TIFM_CORE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_AD9960 is not set
+# CONFIG_SPI_ADC_BF533 is not set
+# CONFIG_BF533_PFLAGS is not set
+# CONFIG_BF5xx_PPIFCD is not set
+# CONFIG_BF5xx_TIMERS is not set
+# CONFIG_BF5xx_PPI is not set
+# CONFIG_BFIN_SPORT is not set
+# CONFIG_BFIN_TIMER_LATENCY is not set
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_BFIN=y
+CONFIG_SERIAL_BFIN_CONSOLE=y
+CONFIG_SERIAL_BFIN_DMA=y
+# CONFIG_SERIAL_BFIN_PIO is not set
+CONFIG_SERIAL_BFIN_UART0=y
+# CONFIG_BFIN_UART0_CTSRTS is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_BFIN_SPORT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# CAN, the car bus and industrial fieldbus
+#
+# CONFIG_CAN4LINUX is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_GEN_RTC is not set
+CONFIG_BLACKFIN_DPMC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+
+#
+# RTC drivers
+#
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_BFIN=y
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# PBX support
+#
+# CONFIG_PBX is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=m
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SERIAL_EARLY_INIT is not set
+CONFIG_DEBUG_HUNT_FOR_ZERO=y
+# CONFIG_DEBUG_BFIN_NO_KERN_HWTRACE is not set
+# CONFIG_BOOTPARAM is not set
+# CONFIG_NO_KERNEL_MSG is not set
+CONFIG_CPLB_INFO=y
+# CONFIG_NO_ACCESS_CHECK is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_CAPABILITIES=y
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_PLIST=y
diff --git a/arch/blackfin/configs/BF533-STAMP_defconfig b/arch/blackfin/configs/BF533-STAMP_defconfig
new file mode 100644
index 0000000..14a948c
--- /dev/null
+++ b/arch/blackfin/configs/BF533-STAMP_defconfig
@@ -0,0 +1,1296 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.20.4
+#
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_BLACKFIN=y
+CONFIG_BFIN=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+# CONFIG_GENERIC_TIME is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_IRQCHIP_DEMUX_GPIO=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_BIG_ORDER_ALLOC_NOFAIL_MAGIC=3
+# CONFIG_LIMIT_PAGECACHE is not set
+CONFIG_BUDDY=y
+# CONFIG_NP2 is not set
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# Blackfin Processor Options
+#
+
+#
+# Processor and Board Settings
+#
+# CONFIG_BF531 is not set
+# CONFIG_BF532 is not set
+CONFIG_BF533=y
+# CONFIG_BF534 is not set
+# CONFIG_BF536 is not set
+# CONFIG_BF537 is not set
+# CONFIG_BF561 is not set
+# CONFIG_BF_REV_0_2 is not set
+CONFIG_BF_REV_0_3=y
+# CONFIG_BF_REV_0_4 is not set
+# CONFIG_BF_REV_0_5 is not set
+CONFIG_BFIN_SINGLE_CORE=y
+# CONFIG_BFIN533_EZKIT is not set
+CONFIG_BFIN533_STAMP=y
+# CONFIG_BFIN537_STAMP is not set
+# CONFIG_BFIN533_BLUETECHNIX_CM is not set
+# CONFIG_BFIN537_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_EZKIT is not set
+# CONFIG_PNAV10 is not set
+# CONFIG_GENERIC_BOARD is not set
+CONFIG_MEM_MT48LC64M4A2FB_7E=y
+CONFIG_BFIN_SHARED_FLASH_ENET=y
+
+#
+# BF533/2/1 Specific Configuration
+#
+
+#
+# Interrupt Priority Assignment
+#
+
+#
+# Priority
+#
+CONFIG_UART_ERROR=7
+CONFIG_SPORT0_ERROR=7
+CONFIG_SPI_ERROR=7
+CONFIG_SPORT1_ERROR=7
+CONFIG_PPI_ERROR=7
+CONFIG_DMA_ERROR=7
+CONFIG_PLLWAKE_ERROR=7
+CONFIG_RTC_ERROR=8
+CONFIG_DMA0_PPI=8
+CONFIG_DMA1_SPORT0RX=9
+CONFIG_DMA2_SPORT0TX=9
+CONFIG_DMA3_SPORT1RX=9
+CONFIG_DMA4_SPORT1TX=9
+CONFIG_DMA5_SPI=10
+CONFIG_DMA6_UARTRX=10
+CONFIG_DMA7_UARTTX=10
+CONFIG_TIMER0=11
+CONFIG_TIMER1=11
+CONFIG_TIMER2=11
+CONFIG_PFA=12
+CONFIG_PFB=12
+CONFIG_MEMDMA0=13
+CONFIG_MEMDMA1=13
+CONFIG_WDTIMER=13
+
+#
+# Board customizations
+#
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Board Setup
+#
+CONFIG_CLKIN_HZ=11059200
+CONFIG_MEM_SIZE=128
+CONFIG_MEM_ADD_WIDTH=11
+CONFIG_ENET_FLASH_PIN=0
+CONFIG_BOOT_LOAD=0x1000
+
+#
+# LED Status Indicators
+#
+# CONFIG_BFIN_ALIVE_LED is not set
+# CONFIG_BFIN_IDLE_LED is not set
+CONFIG_BFIN_ALIVE_LED_PORT=0xFFC00700
+CONFIG_BFIN_ALIVE_LED_DPORT=0xFFC00730
+CONFIG_BFIN_IDLE_LED_PORT=0xFFC00700
+CONFIG_BFIN_IDLE_LED_DPORT=0xFFC00730
+
+#
+# Console UART Setup
+#
+# CONFIG_BAUD_9600 is not set
+# CONFIG_BAUD_19200 is not set
+# CONFIG_BAUD_38400 is not set
+CONFIG_BAUD_57600=y
+# CONFIG_BAUD_115200 is not set
+CONFIG_BAUD_NO_PARITY=y
+# CONFIG_BAUD_PARITY is not set
+CONFIG_BAUD_1_STOPBIT=y
+# CONFIG_BAUD_2_STOPBIT is not set
+
+#
+# Blackfin Kernel Optimizations
+#
+
+#
+# Timer Tick
+#
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+
+#
+# Memory Optimizations
+#
+CONFIG_I_ENTRY_L1=y
+CONFIG_EXCPT_IRQ_SYSC_L1=y
+CONFIG_DO_IRQ_L1=y
+CONFIG_CORE_TIMER_IRQ_L1=y
+CONFIG_IDLE_L1=y
+CONFIG_SCHEDULE_L1=y
+CONFIG_ARITHMETIC_OPS_L1=y
+CONFIG_ACCESS_OK_L1=y
+CONFIG_MEMSET_L1=y
+CONFIG_MEMCPY_L1=y
+CONFIG_SYS_BFIN_SPINLOCK_L1=y
+# CONFIG_IP_CHECKSUM_L1 is not set
+# CONFIG_SYSCALL_TAB_L1 is not set
+# CONFIG_CPLB_SWITCH_TAB_L1 is not set
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_LARGE_ALLOCS=y
+CONFIG_BFIN_DMA_5XX=y
+# CONFIG_DMA_UNCACHED_2M is not set
+CONFIG_DMA_UNCACHED_1M=y
+# CONFIG_DMA_UNCACHED_NONE is not set
+
+#
+# Cache Support
+#
+CONFIG_BLKFIN_CACHE=y
+CONFIG_BLKFIN_DCACHE=y
+# CONFIG_BLKFIN_DCACHE_BANKA is not set
+# CONFIG_BLKFIN_CACHE_LOCK is not set
+# CONFIG_BLKFIN_WB is not set
+CONFIG_BLKFIN_WT=y
+CONFIG_L1_MAX_PIECE=16
+
+#
+# Clock Settings
+#
+# CONFIG_BFIN_KERNEL_CLOCK is not set
+
+#
+# Asynchonous Memory Configuration
+#
+
+#
+# EBIU_AMBCTL Global Control
+#
+CONFIG_C_AMCKEN=y
+CONFIG_C_CDPRIO=y
+# CONFIG_C_AMBEN is not set
+# CONFIG_C_AMBEN_B0 is not set
+# CONFIG_C_AMBEN_B0_B1 is not set
+# CONFIG_C_AMBEN_B0_B1_B2 is not set
+CONFIG_C_AMBEN_ALL=y
+
+#
+# EBIU_AMBCTL Control
+#
+CONFIG_BANK_0=0x7BB0
+CONFIG_BANK_1=0x7BB0
+CONFIG_BANK_2=0x7BB0
+CONFIG_BANK_3=0x99B3
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+CONFIG_PM_WAKEUP_GPIO_BY_SIC_IWR=y
+# CONFIG_PM_WAKEUP_BY_GPIO is not set
+# CONFIG_PM_WAKEUP_GPIO_API is not set
+CONFIG_PM_WAKEUP_SIC_IWR=0x100000
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRCOMM=m
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+# CONFIG_IRDA_FAST_RR is not set
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+
+#
+# Old SIR device drivers
+#
+# CONFIG_IRPORT_SIR is not set
+
+#
+# Old Serial dongle support
+#
+
+#
+# FIR device drivers
+#
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_MW320D=m
+CONFIG_MTD_RAM=y
+CONFIG_MTD_ROM=m
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_BF5xx=m
+CONFIG_BFIN_FLASH_SIZE=0x400000
+CONFIG_EBIU_FLASH_BASE=0x20000000
+
+#
+# FLASH_EBIU_AMBCTL Control
+#
+CONFIG_BFIN_FLASH_BANK_0=0x7BB0
+CONFIG_BFIN_FLASH_BANK_1=0x7BB0
+CONFIG_BFIN_FLASH_BANK_2=0x7BB0
+CONFIG_BFIN_FLASH_BANK_3=0x7BB0
+# CONFIG_MTD_UCLINUX is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Misc devices
+#
+# CONFIG_TIFM_CORE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_BF53X_PFBUTTONS is not set
+CONFIG_TWI_KEYPAD=m
+CONFIG_BFIN_TWIKEYPAD_IRQ_PFX=39
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_AD9960 is not set
+# CONFIG_SPI_ADC_BF533 is not set
+# CONFIG_BF533_PFLAGS is not set
+# CONFIG_BF5xx_PPIFCD is not set
+# CONFIG_BF5xx_TIMERS is not set
+# CONFIG_BF5xx_PPI is not set
+CONFIG_BFIN_SPORT=y
+# CONFIG_BFIN_TIMER_LATENCY is not set
+CONFIG_TWI_LCD=m
+CONFIG_TWI_LCD_SLAVE_ADDR=34
+# CONFIG_AD5304 is not set
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_BFIN=y
+CONFIG_SERIAL_BFIN_CONSOLE=y
+CONFIG_SERIAL_BFIN_DMA=y
+# CONFIG_SERIAL_BFIN_PIO is not set
+CONFIG_SERIAL_BFIN_UART0=y
+# CONFIG_BFIN_UART0_CTSRTS is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_BFIN_SPORT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# CAN, the car bus and industrial fieldbus
+#
+# CONFIG_CAN4LINUX is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_GEN_RTC is not set
+CONFIG_BLACKFIN_DPMC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_BLACKFIN_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_AD5252 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8575 is not set
+# CONFIG_SENSORS_PCA9543 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_BFIN=y
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB=m
+CONFIG_FB_CFB_FILLRECT=m
+CONFIG_FB_CFB_COPYAREA=m
+CONFIG_FB_CFB_IMAGEBLIT=m
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_BFIN_7171=m
+CONFIG_FB_BFIN_7393=m
+CONFIG_NTSC=y
+# CONFIG_PAL is not set
+# CONFIG_NTSC_640x480 is not set
+# CONFIG_PAL_640x480 is not set
+# CONFIG_NTSC_YCBCR is not set
+# CONFIG_PAL_YCBCR is not set
+CONFIG_ADV7393_1XMEM=y
+# CONFIG_ADV7393_2XMEM is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=y
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_SPI_MMC is not set
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+
+#
+# RTC drivers
+#
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_BFIN=y
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# Virtualization
+#
+
+#
+# PBX support
+#
+# CONFIG_PBX is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=m
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_SERIAL_EARLY_INIT is not set
+CONFIG_DEBUG_HUNT_FOR_ZERO=y
+# CONFIG_DEBUG_BFIN_NO_KERN_HWTRACE is not set
+CONFIG_CPLB_INFO=y
+CONFIG_ACCESS_CHECK=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_CAPABILITIES=y
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_PLIST=y
+CONFIG_IOMAP_COPY=y
diff --git a/arch/blackfin/configs/BF537-STAMP_defconfig b/arch/blackfin/configs/BF537-STAMP_defconfig
new file mode 100644
index 0000000..8ed67dc
--- /dev/null
+++ b/arch/blackfin/configs/BF537-STAMP_defconfig
@@ -0,0 +1,1332 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.20.4
+#
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_BLACKFIN=y
+CONFIG_BFIN=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+# CONFIG_GENERIC_TIME is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_IRQCHIP_DEMUX_GPIO=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_BIG_ORDER_ALLOC_NOFAIL_MAGIC=3
+# CONFIG_LIMIT_PAGECACHE is not set
+CONFIG_BUDDY=y
+# CONFIG_NP2 is not set
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# Blackfin Processor Options
+#
+
+#
+# Processor and Board Settings
+#
+# CONFIG_BF531 is not set
+# CONFIG_BF532 is not set
+# CONFIG_BF533 is not set
+# CONFIG_BF534 is not set
+# CONFIG_BF536 is not set
+CONFIG_BF537=y
+# CONFIG_BF561 is not set
+CONFIG_BF_REV_0_2=y
+# CONFIG_BF_REV_0_3 is not set
+# CONFIG_BF_REV_0_4 is not set
+# CONFIG_BF_REV_0_5 is not set
+CONFIG_BFIN_SINGLE_CORE=y
+# CONFIG_BFIN533_EZKIT is not set
+# CONFIG_BFIN533_STAMP is not set
+CONFIG_BFIN537_STAMP=y
+# CONFIG_BFIN533_BLUETECHNIX_CM is not set
+# CONFIG_BFIN537_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_EZKIT is not set
+# CONFIG_PNAV10 is not set
+# CONFIG_GENERIC_BOARD is not set
+CONFIG_MEM_MT48LC32M8A2_75=y
+CONFIG_IRQ_PLL_WAKEUP=7
+
+#
+# BF537 Specific Configuration
+#
+
+#
+# PORT F/G Selection
+#
+CONFIG_BF537_PORT_F=y
+# CONFIG_BF537_PORT_G is not set
+# CONFIG_BF537_PORT_H is not set
+
+#
+# Interrupt Priority Assignment
+#
+
+#
+# Priority
+#
+CONFIG_IRQ_DMA_ERROR=7
+CONFIG_IRQ_ERROR=7
+CONFIG_IRQ_RTC=8
+CONFIG_IRQ_PPI=8
+CONFIG_IRQ_SPORT0_RX=9
+CONFIG_IRQ_SPORT0_TX=9
+CONFIG_IRQ_SPORT1_RX=9
+CONFIG_IRQ_SPORT1_TX=9
+CONFIG_IRQ_TWI=10
+CONFIG_IRQ_SPI=10
+CONFIG_IRQ_UART0_RX=10
+CONFIG_IRQ_UART0_TX=10
+CONFIG_IRQ_UART1_RX=10
+CONFIG_IRQ_UART1_TX=10
+CONFIG_IRQ_CAN_RX=11
+CONFIG_IRQ_CAN_TX=11
+CONFIG_IRQ_MAC_RX=11
+CONFIG_IRQ_MAC_TX=11
+CONFIG_IRQ_TMR0=12
+CONFIG_IRQ_TMR1=12
+CONFIG_IRQ_TMR2=12
+CONFIG_IRQ_TMR3=12
+CONFIG_IRQ_TMR4=12
+CONFIG_IRQ_TMR5=12
+CONFIG_IRQ_TMR6=12
+CONFIG_IRQ_TMR7=12
+CONFIG_IRQ_PROG_INTA=12
+CONFIG_IRQ_PORTG_INTB=12
+CONFIG_IRQ_MEM_DMA0=13
+CONFIG_IRQ_MEM_DMA1=13
+CONFIG_IRQ_WATCH=13
+
+#
+# Board customizations
+#
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Board Setup
+#
+CONFIG_CLKIN_HZ=25000000
+CONFIG_MEM_SIZE=64
+CONFIG_MEM_ADD_WIDTH=10
+CONFIG_BOOT_LOAD=0x1000
+
+#
+# Console UART Setup
+#
+# CONFIG_BAUD_9600 is not set
+# CONFIG_BAUD_19200 is not set
+# CONFIG_BAUD_38400 is not set
+CONFIG_BAUD_57600=y
+# CONFIG_BAUD_115200 is not set
+CONFIG_BAUD_NO_PARITY=y
+# CONFIG_BAUD_PARITY is not set
+CONFIG_BAUD_1_STOPBIT=y
+# CONFIG_BAUD_2_STOPBIT is not set
+
+#
+# Blackfin Kernel Optimizations
+#
+
+#
+# Timer Tick
+#
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+
+#
+# Memory Optimizations
+#
+CONFIG_I_ENTRY_L1=y
+CONFIG_EXCPT_IRQ_SYSC_L1=y
+CONFIG_DO_IRQ_L1=y
+CONFIG_CORE_TIMER_IRQ_L1=y
+CONFIG_IDLE_L1=y
+CONFIG_SCHEDULE_L1=y
+CONFIG_ARITHMETIC_OPS_L1=y
+CONFIG_ACCESS_OK_L1=y
+CONFIG_MEMSET_L1=y
+CONFIG_MEMCPY_L1=y
+CONFIG_SYS_BFIN_SPINLOCK_L1=y
+# CONFIG_IP_CHECKSUM_L1 is not set
+# CONFIG_SYSCALL_TAB_L1 is not set
+# CONFIG_CPLB_SWITCH_TAB_L1 is not set
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_LARGE_ALLOCS=y
+CONFIG_BFIN_DMA_5XX=y
+# CONFIG_DMA_UNCACHED_2M is not set
+CONFIG_DMA_UNCACHED_1M=y
+# CONFIG_DMA_UNCACHED_NONE is not set
+
+#
+# Cache Support
+#
+CONFIG_BLKFIN_CACHE=y
+CONFIG_BLKFIN_DCACHE=y
+# CONFIG_BLKFIN_DCACHE_BANKA is not set
+# CONFIG_BLKFIN_CACHE_LOCK is not set
+# CONFIG_BLKFIN_WB is not set
+CONFIG_BLKFIN_WT=y
+CONFIG_L1_MAX_PIECE=16
+
+#
+# Clock Settings
+#
+# CONFIG_BFIN_KERNEL_CLOCK is not set
+
+#
+# Asynchonous Memory Configuration
+#
+
+#
+# EBIU_AMBCTL Global Control
+#
+CONFIG_C_AMCKEN=y
+CONFIG_C_CDPRIO=y
+# CONFIG_C_AMBEN is not set
+# CONFIG_C_AMBEN_B0 is not set
+# CONFIG_C_AMBEN_B0_B1 is not set
+# CONFIG_C_AMBEN_B0_B1_B2 is not set
+CONFIG_C_AMBEN_ALL=y
+
+#
+# EBIU_AMBCTL Control
+#
+CONFIG_BANK_0=0x7BB0
+CONFIG_BANK_1=0x7BB0
+CONFIG_BANK_2=0x7BB0
+CONFIG_BANK_3=0x99B3
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+CONFIG_PM_WAKEUP_GPIO_BY_SIC_IWR=y
+# CONFIG_PM_WAKEUP_BY_GPIO is not set
+# CONFIG_PM_WAKEUP_GPIO_API is not set
+CONFIG_PM_WAKEUP_SIC_IWR=0x80000000
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRCOMM=m
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+# CONFIG_IRDA_FAST_RR is not set
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+
+#
+# Old SIR device drivers
+#
+# CONFIG_IRPORT_SIR is not set
+
+#
+# Old Serial dongle support
+#
+
+#
+# FIR device drivers
+#
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_MW320D=m
+CONFIG_MTD_RAM=y
+CONFIG_MTD_ROM=m
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_BF5xx=m
+CONFIG_BFIN_FLASH_SIZE=0x400000
+CONFIG_EBIU_FLASH_BASE=0x20000000
+
+#
+# FLASH_EBIU_AMBCTL Control
+#
+CONFIG_BFIN_FLASH_BANK_0=0x7BB0
+CONFIG_BFIN_FLASH_BANK_1=0x7BB0
+CONFIG_BFIN_FLASH_BANK_2=0x7BB0
+CONFIG_BFIN_FLASH_BANK_3=0x7BB0
+# CONFIG_MTD_UCLINUX is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_BFIN=m
+CONFIG_BFIN_NAND_BASE=0x20212000
+CONFIG_BFIN_NAND_CLE=2
+CONFIG_BFIN_NAND_ALE=1
+CONFIG_BFIN_NAND_READY=3
+CONFIG_MTD_NAND_IDS=m
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Misc devices
+#
+# CONFIG_TIFM_CORE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+CONFIG_BFIN_MAC=y
+CONFIG_BFIN_MAC_USE_L1=y
+CONFIG_BFIN_TX_DESC_NUM=10
+CONFIG_BFIN_RX_DESC_NUM=20
+# CONFIG_BFIN_MAC_RMII is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_BF53X_PFBUTTONS is not set
+CONFIG_TWI_KEYPAD=m
+CONFIG_BFIN_TWIKEYPAD_IRQ_PFX=72
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_AD9960 is not set
+# CONFIG_SPI_ADC_BF533 is not set
+# CONFIG_BF533_PFLAGS is not set
+# CONFIG_BF5xx_PPIFCD is not set
+# CONFIG_BF5xx_TIMERS is not set
+# CONFIG_BF5xx_PPI is not set
+CONFIG_BFIN_SPORT=y
+# CONFIG_BFIN_TIMER_LATENCY is not set
+CONFIG_TWI_LCD=m
+CONFIG_TWI_LCD_SLAVE_ADDR=34
+# CONFIG_AD5304 is not set
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_BFIN=y
+CONFIG_SERIAL_BFIN_CONSOLE=y
+CONFIG_SERIAL_BFIN_DMA=y
+# CONFIG_SERIAL_BFIN_PIO is not set
+CONFIG_SERIAL_BFIN_UART0=y
+# CONFIG_BFIN_UART0_CTSRTS is not set
+# CONFIG_SERIAL_BFIN_UART1 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_BFIN_SPORT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# CAN, the car bus and industrial fieldbus
+#
+CONFIG_CAN4LINUX=y
+
+#
+# linux embedded drivers
+#
+# CONFIG_CAN_MCF5282 is not set
+# CONFIG_CAN_UNCTWINCAN is not set
+CONFIG_CAN_BLACKFIN=m
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_GEN_RTC is not set
+CONFIG_BLACKFIN_DPMC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_BLACKFIN_GPIO is not set
+CONFIG_I2C_BLACKFIN_TWI=m
+CONFIG_I2C_BLACKFIN_TWI_CLK_KHZ=50
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+CONFIG_SENSORS_AD5252=m
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8575 is not set
+# CONFIG_SENSORS_PCA9543 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_BFIN=y
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB=m
+CONFIG_FB_CFB_FILLRECT=m
+CONFIG_FB_CFB_COPYAREA=m
+CONFIG_FB_CFB_IMAGEBLIT=m
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_BFIN_7171=m
+CONFIG_FB_BFIN_7393=m
+CONFIG_NTSC=y
+# CONFIG_PAL is not set
+# CONFIG_NTSC_640x480 is not set
+# CONFIG_PAL_640x480 is not set
+# CONFIG_NTSC_YCBCR is not set
+# CONFIG_PAL_YCBCR is not set
+CONFIG_ADV7393_1XMEM=y
+# CONFIG_ADV7393_2XMEM is not set
+CONFIG_FB_BF537_LQ035=m
+CONFIG_LQ035_SLAVE_ADDR=0x58
+# CONFIG_FB_BFIN_LANDSCAPE is not set
+# CONFIG_FB_BFIN_BGR is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=m
+CONFIG_BACKLIGHT_DEVICE=y
+CONFIG_LCD_CLASS_DEVICE=m
+CONFIG_LCD_DEVICE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=y
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_SPI_MMC is not set
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+
+#
+# RTC drivers
+#
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_BFIN=y
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# Virtualization
+#
+
+#
+# PBX support
+#
+# CONFIG_PBX is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=m
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_SERIAL_EARLY_INIT is not set
+CONFIG_DEBUG_HUNT_FOR_ZERO=y
+# CONFIG_DEBUG_BFIN_NO_KERN_HWTRACE is not set
+CONFIG_CPLB_INFO=y
+CONFIG_ACCESS_CHECK=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_CAPABILITIES=y
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_PLIST=y
+CONFIG_IOMAP_COPY=y
diff --git a/arch/blackfin/configs/BF561-EZKIT_defconfig b/arch/blackfin/configs/BF561-EZKIT_defconfig
new file mode 100644
index 0000000..e32ca20
--- /dev/null
+++ b/arch/blackfin/configs/BF561-EZKIT_defconfig
@@ -0,0 +1,1073 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.19.3
+#
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_BLACKFIN=y
+CONFIG_BFIN=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_UCLINUX=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_IRQCHIP_DEMUX_GPIO=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+# CONFIG_UID16 is not set
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_BIG_ORDER_ALLOC_NOFAIL_MAGIC=3
+# CONFIG_LIMIT_PAGECACHE is not set
+CONFIG_BUDDY=y
+# CONFIG_NP2 is not set
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# Blackfin Processor Options
+#
+
+#
+# Processor and Board Settings
+#
+# CONFIG_BF531 is not set
+# CONFIG_BF532 is not set
+# CONFIG_BF533 is not set
+# CONFIG_BF534 is not set
+# CONFIG_BF535 is not set
+# CONFIG_BF536 is not set
+# CONFIG_BF537 is not set
+CONFIG_BF561=y
+# CONFIG_BF_REV_0_2 is not set
+CONFIG_BF_REV_0_3=y
+# CONFIG_BF_REV_0_4 is not set
+# CONFIG_BF_REV_0_5 is not set
+CONFIG_BFIN_DUAL_CORE=y
+# CONFIG_BFIN533_EZKIT is not set
+# CONFIG_BFIN533_STAMP is not set
+# CONFIG_BFIN537_STAMP is not set
+# CONFIG_BFIN533_BLUETECHNIX_CM is not set
+# CONFIG_BFIN537_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_BLUETECHNIX_CM is not set
+CONFIG_BFIN561_EZKIT=y
+# CONFIG_PNAV10 is not set
+# CONFIG_GENERIC_BOARD is not set
+CONFIG_MEM_MT48LC16M16A2TG_75=y
+
+#
+# BF561 Specific Configuration
+#
+
+#
+# Core B Support
+#
+
+#
+# Core B Support
+#
+CONFIG_BF561_COREB=y
+CONFIG_BF561_COREB_RESET=y
+
+#
+# Interrupt Priority Assignment
+#
+
+#
+# Priority
+#
+CONFIG_IRQ_PLL_WAKEUP=7
+CONFIG_IRQ_DMA1_ERROR=7
+CONFIG_IRQ_DMA2_ERROR=7
+CONFIG_IRQ_IMDMA_ERROR=7
+CONFIG_IRQ_PPI0_ERROR=7
+CONFIG_IRQ_PPI1_ERROR=7
+CONFIG_IRQ_SPORT0_ERROR=7
+CONFIG_IRQ_SPORT1_ERROR=7
+CONFIG_IRQ_SPI_ERROR=7
+CONFIG_IRQ_UART_ERROR=7
+CONFIG_IRQ_RESERVED_ERROR=7
+CONFIG_IRQ_DMA1_0=8
+CONFIG_IRQ_DMA1_1=8
+CONFIG_IRQ_DMA1_2=8
+CONFIG_IRQ_DMA1_3=8
+CONFIG_IRQ_DMA1_4=8
+CONFIG_IRQ_DMA1_5=8
+CONFIG_IRQ_DMA1_6=8
+CONFIG_IRQ_DMA1_7=8
+CONFIG_IRQ_DMA1_8=8
+CONFIG_IRQ_DMA1_9=8
+CONFIG_IRQ_DMA1_10=8
+CONFIG_IRQ_DMA1_11=8
+CONFIG_IRQ_DMA2_0=9
+CONFIG_IRQ_DMA2_1=9
+CONFIG_IRQ_DMA2_2=9
+CONFIG_IRQ_DMA2_3=9
+CONFIG_IRQ_DMA2_4=9
+CONFIG_IRQ_DMA2_5=9
+CONFIG_IRQ_DMA2_6=9
+CONFIG_IRQ_DMA2_7=9
+CONFIG_IRQ_DMA2_8=9
+CONFIG_IRQ_DMA2_9=9
+CONFIG_IRQ_DMA2_10=9
+CONFIG_IRQ_DMA2_11=9
+CONFIG_IRQ_TIMER0=10
+CONFIG_IRQ_TIMER1=10
+CONFIG_IRQ_TIMER2=10
+CONFIG_IRQ_TIMER3=10
+CONFIG_IRQ_TIMER4=10
+CONFIG_IRQ_TIMER5=10
+CONFIG_IRQ_TIMER6=10
+CONFIG_IRQ_TIMER7=10
+CONFIG_IRQ_TIMER8=10
+CONFIG_IRQ_TIMER9=10
+CONFIG_IRQ_TIMER10=10
+CONFIG_IRQ_TIMER11=10
+CONFIG_IRQ_PROG0_INTA=11
+CONFIG_IRQ_PROG0_INTB=11
+CONFIG_IRQ_PROG1_INTA=11
+CONFIG_IRQ_PROG1_INTB=11
+CONFIG_IRQ_PROG2_INTA=11
+CONFIG_IRQ_PROG2_INTB=11
+CONFIG_IRQ_DMA1_WRRD0=8
+CONFIG_IRQ_DMA1_WRRD1=8
+CONFIG_IRQ_DMA2_WRRD0=9
+CONFIG_IRQ_DMA2_WRRD1=9
+CONFIG_IRQ_IMDMA_WRRD0=12
+CONFIG_IRQ_IMDMA_WRRD1=12
+CONFIG_IRQ_WDTIMER=13
+
+#
+# Board customizations
+#
+
+#
+# Board Setup
+#
+CONFIG_CLKIN_HZ=30000000
+CONFIG_MEM_SIZE=64
+CONFIG_MEM_ADD_WIDTH=9
+CONFIG_BOOT_LOAD=0x1000
+
+#
+# Console UART Setup
+#
+# CONFIG_BAUD_9600 is not set
+# CONFIG_BAUD_19200 is not set
+# CONFIG_BAUD_38400 is not set
+CONFIG_BAUD_57600=y
+# CONFIG_BAUD_115200 is not set
+CONFIG_BAUD_NO_PARITY=y
+# CONFIG_BAUD_PARITY is not set
+CONFIG_BAUD_1_STOPBIT=y
+# CONFIG_BAUD_2_STOPBIT is not set
+
+#
+# Blackfin Kernel Optimizations
+#
+
+#
+# Timer Tick
+#
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+
+#
+# Memory Optimizations
+#
+CONFIG_I_ENTRY_L1=y
+CONFIG_EXCPT_IRQ_SYSC_L1=y
+CONFIG_DO_IRQ_L1=y
+CONFIG_CORE_TIMER_IRQ_L1=y
+CONFIG_IDLE_L1=y
+CONFIG_SCHEDULE_L1=y
+CONFIG_ARITHMETIC_OPS_L1=y
+CONFIG_ACCESS_OK_L1=y
+CONFIG_MEMSET_L1=y
+CONFIG_MEMCPY_L1=y
+CONFIG_SYS_BFIN_SPINLOCK_L1=y
+# CONFIG_IP_CHECKSUM_L1 is not set
+# CONFIG_SYSCALL_TAB_L1 is not set
+# CONFIG_CPLB_SWITCH_TAB_L1 is not set
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_LARGE_ALLOCS=y
+CONFIG_BFIN_DMA_5XX=y
+# CONFIG_DMA_UNCACHED_2M is not set
+CONFIG_DMA_UNCACHED_1M=y
+# CONFIG_DMA_UNCACHED_NONE is not set
+
+#
+# Cache Support
+#
+CONFIG_BLKFIN_CACHE=y
+CONFIG_BLKFIN_DCACHE=y
+# CONFIG_BLKFIN_DCACHE_BANKA is not set
+# CONFIG_BLKFIN_CACHE_LOCK is not set
+# CONFIG_BLKFIN_WB is not set
+CONFIG_BLKFIN_WT=y
+CONFIG_L1_MAX_PIECE=16
+
+#
+# Clock Settings
+#
+# CONFIG_BFIN_KERNEL_CLOCK is not set
+
+#
+# Asynchonous Memory Configuration
+#
+
+#
+# EBIU_AMBCTL Global Control
+#
+CONFIG_C_AMCKEN=y
+CONFIG_C_CDPRIO=y
+CONFIG_C_B0PEN=y
+CONFIG_C_B1PEN=y
+CONFIG_C_B2PEN=y
+# CONFIG_C_B3PEN is not set
+# CONFIG_C_AMBEN is not set
+# CONFIG_C_AMBEN_B0 is not set
+# CONFIG_C_AMBEN_B0_B1 is not set
+# CONFIG_C_AMBEN_B0_B1_B2 is not set
+CONFIG_C_AMBEN_ALL=y
+
+#
+# EBIU_AMBCTL Control
+#
+CONFIG_BANK_0=0x7BB0
+CONFIG_BANK_1=0x7BB0
+CONFIG_BANK_2=0x7BB0
+CONFIG_BANK_3=0x99B3
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_MW320D=m
+CONFIG_MTD_RAM=y
+CONFIG_MTD_ROM=m
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_EZKIT561 is not set
+CONFIG_MTD_BF5xx=m
+CONFIG_BFIN_FLASH_SIZE=0x0400000
+CONFIG_EBIU_FLASH_BASE=0x20000000
+
+#
+# FLASH_EBIU_AMBCTL Control
+#
+CONFIG_BFIN_FLASH_BANK_0=0x7BB0
+CONFIG_BFIN_FLASH_BANK_1=0x7BB0
+CONFIG_BFIN_FLASH_BANK_2=0x7BB0
+CONFIG_BFIN_FLASH_BANK_3=0x7BB0
+# CONFIG_MTD_UCLINUX is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Misc devices
+#
+# CONFIG_TIFM_CORE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_SMC91X=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_AD9960 is not set
+# CONFIG_SPI_ADC_BF533 is not set
+# CONFIG_BF533_PFLAGS is not set
+# CONFIG_BF5xx_PPIFCD is not set
+# CONFIG_BF5xx_TIMERS is not set
+# CONFIG_BF5xx_PPI is not set
+# CONFIG_BFIN_SPORT is not set
+# CONFIG_BFIN_TIMER_LATENCY is not set
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_BFIN=y
+CONFIG_SERIAL_BFIN_CONSOLE=y
+CONFIG_SERIAL_BFIN_DMA=y
+# CONFIG_SERIAL_BFIN_PIO is not set
+CONFIG_SERIAL_BFIN_UART0=y
+# CONFIG_BFIN_UART0_CTSRTS is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_BFIN_SPORT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# CAN, the car bus and industrial fieldbus
+#
+# CONFIG_CAN4LINUX is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_GEN_RTC is not set
+# CONFIG_BLACKFIN_DPMC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# PBX support
+#
+# CONFIG_PBX is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=m
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SERIAL_EARLY_INIT is not set
+CONFIG_DEBUG_HUNT_FOR_ZERO=y
+# CONFIG_DEBUG_BFIN_NO_KERN_HWTRACE is not set
+# CONFIG_DUAL_CORE_TEST_MODULE is not set
+# CONFIG_BOOTPARAM is not set
+# CONFIG_NO_KERNEL_MSG is not set
+CONFIG_CPLB_INFO=y
+# CONFIG_NO_ACCESS_CHECK is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_CAPABILITIES=y
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_PLIST=y
diff --git a/arch/blackfin/configs/PNAV-10_defconfig b/arch/blackfin/configs/PNAV-10_defconfig
new file mode 100644
index 0000000..97b4ffa
--- /dev/null
+++ b/arch/blackfin/configs/PNAV-10_defconfig
@@ -0,0 +1,1253 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.19.3
+#
+# CONFIG_MMU is not set
+# CONFIG_FPU is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_BLACKFIN=y
+CONFIG_BFIN=y
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_UCLINUX=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_IRQCHIP_DEMUX_GPIO=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_BIG_ORDER_ALLOC_NOFAIL_MAGIC=9
+# CONFIG_LIMIT_PAGECACHE is not set
+CONFIG_BUDDY=y
+# CONFIG_NP2 is not set
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_BLK_DEV_IO_TRACE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# Blackfin Processor Options
+#
+
+#
+# Processor and Board Settings
+#
+# CONFIG_BF531 is not set
+# CONFIG_BF532 is not set
+# CONFIG_BF533 is not set
+# CONFIG_BF534 is not set
+# CONFIG_BF535 is not set
+# CONFIG_BF536 is not set
+CONFIG_BF537=y
+# CONFIG_BF561 is not set
+CONFIG_BF_REV_0_2=y
+# CONFIG_BF_REV_0_3 is not set
+# CONFIG_BF_REV_0_4 is not set
+# CONFIG_BF_REV_0_5 is not set
+CONFIG_BFIN_SINGLE_CORE=y
+# CONFIG_BFIN533_EZKIT is not set
+# CONFIG_BFIN533_STAMP is not set
+# CONFIG_BFIN537_STAMP is not set
+# CONFIG_BFIN533_BLUETECHNIX_CM is not set
+# CONFIG_BFIN537_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_BLUETECHNIX_CM is not set
+# CONFIG_BFIN561_EZKIT is not set
+CONFIG_PNAV10=y
+# CONFIG_GENERIC_BOARD is not set
+CONFIG_MEM_MT48LC32M8A2_75=y
+CONFIG_IRQ_PLL_WAKEUP=7
+
+#
+# BF537 Specific Configuration
+#
+
+#
+# PORT F/G Selection
+#
+CONFIG_BF537_PORT_F=y
+# CONFIG_BF537_PORT_G is not set
+# CONFIG_BF537_PORT_H is not set
+
+#
+# Interrupt Priority Assignment
+#
+
+#
+# Priority
+#
+CONFIG_IRQ_DMA_ERROR=7
+CONFIG_IRQ_ERROR=7
+CONFIG_IRQ_RTC=8
+CONFIG_IRQ_PPI=8
+CONFIG_IRQ_SPORT0_RX=9
+CONFIG_IRQ_SPORT0_TX=9
+CONFIG_IRQ_SPORT1_RX=9
+CONFIG_IRQ_SPORT1_TX=9
+CONFIG_IRQ_TWI=10
+CONFIG_IRQ_SPI=10
+CONFIG_IRQ_UART0_RX=10
+CONFIG_IRQ_UART0_TX=10
+CONFIG_IRQ_UART1_RX=10
+CONFIG_IRQ_UART1_TX=10
+CONFIG_IRQ_CAN_RX=11
+CONFIG_IRQ_CAN_TX=11
+CONFIG_IRQ_MAC_RX=11
+CONFIG_IRQ_MAC_TX=11
+CONFIG_IRQ_TMR0=12
+CONFIG_IRQ_TMR1=12
+CONFIG_IRQ_TMR2=12
+CONFIG_IRQ_TMR3=12
+CONFIG_IRQ_TMR4=12
+CONFIG_IRQ_TMR5=12
+CONFIG_IRQ_TMR6=12
+CONFIG_IRQ_TMR7=12
+CONFIG_IRQ_PROG_INTA=12
+CONFIG_IRQ_PORTG_INTB=12
+CONFIG_IRQ_MEM_DMA0=13
+CONFIG_IRQ_MEM_DMA1=13
+CONFIG_IRQ_WATCH=13
+
+#
+# Board customizations
+#
+
+#
+# Board Setup
+#
+CONFIG_CLKIN_HZ=24576000
+CONFIG_MEM_SIZE=64
+CONFIG_MEM_ADD_WIDTH=10
+CONFIG_BOOT_LOAD=0x1000
+
+#
+# Console UART Setup
+#
+# CONFIG_BAUD_9600 is not set
+# CONFIG_BAUD_19200 is not set
+# CONFIG_BAUD_38400 is not set
+# CONFIG_BAUD_57600 is not set
+CONFIG_BAUD_115200=y
+CONFIG_BAUD_NO_PARITY=y
+# CONFIG_BAUD_PARITY is not set
+CONFIG_BAUD_1_STOPBIT=y
+# CONFIG_BAUD_2_STOPBIT is not set
+
+#
+# Blackfin Kernel Optimizations
+#
+
+#
+# Timer Tick
+#
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+
+#
+# Memory Optimizations
+#
+CONFIG_I_ENTRY_L1=y
+CONFIG_EXCPT_IRQ_SYSC_L1=y
+CONFIG_DO_IRQ_L1=y
+CONFIG_CORE_TIMER_IRQ_L1=y
+CONFIG_IDLE_L1=y
+CONFIG_SCHEDULE_L1=y
+CONFIG_ARITHMETIC_OPS_L1=y
+CONFIG_ACCESS_OK_L1=y
+CONFIG_MEMSET_L1=y
+CONFIG_MEMCPY_L1=y
+CONFIG_SYS_BFIN_SPINLOCK_L1=y
+CONFIG_IP_CHECKSUM_L1=y
+CONFIG_SYSCALL_TAB_L1=y
+CONFIG_CPLB_SWITCH_TAB_L1=y
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_LARGE_ALLOCS=y
+CONFIG_BFIN_DMA_5XX=y
+# CONFIG_DMA_UNCACHED_2M is not set
+CONFIG_DMA_UNCACHED_1M=y
+# CONFIG_DMA_UNCACHED_NONE is not set
+
+#
+# Cache Support
+#
+CONFIG_BLKFIN_CACHE=y
+CONFIG_BLKFIN_DCACHE=y
+# CONFIG_BLKFIN_DCACHE_BANKA is not set
+# CONFIG_BLKFIN_CACHE_LOCK is not set
+CONFIG_BLKFIN_WB=y
+# CONFIG_BLKFIN_WT is not set
+CONFIG_L1_MAX_PIECE=16
+
+#
+# Clock Settings
+#
+# CONFIG_BFIN_KERNEL_CLOCK is not set
+
+#
+# Asynchonous Memory Configuration
+#
+
+#
+# EBIU_AMBCTL Global Control
+#
+CONFIG_C_AMCKEN=y
+CONFIG_C_CDPRIO=y
+# CONFIG_C_AMBEN is not set
+# CONFIG_C_AMBEN_B0 is not set
+# CONFIG_C_AMBEN_B0_B1 is not set
+# CONFIG_C_AMBEN_B0_B1_B2 is not set
+CONFIG_C_AMBEN_ALL=y
+
+#
+# EBIU_AMBCTL Control
+#
+CONFIG_BANK_0=0x7BB0
+CONFIG_BANK_1=0x33B0
+CONFIG_BANK_2=0x33B0
+CONFIG_BANK_3=0x99B3
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF_FDPIC=y
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_BF5xx is not set
+CONFIG_MTD_UCLINUX=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_BFIN=y
+CONFIG_BFIN_NAND_BASE=0x20100000
+CONFIG_BFIN_NAND_CLE=2
+CONFIG_BFIN_NAND_ALE=1
+CONFIG_BFIN_NAND_READY=44
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Misc devices
+#
+# CONFIG_TIFM_CORE is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+CONFIG_BFIN_MAC=y
+# CONFIG_BFIN_MAC_USE_L1 is not set
+CONFIG_BFIN_TX_DESC_NUM=100
+CONFIG_BFIN_RX_DESC_NUM=100
+CONFIG_BFIN_MAC_RMII=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_TSDEV=y
+CONFIG_INPUT_TSDEV_SCREEN_X=240
+CONFIG_INPUT_TSDEV_SCREEN_Y=320
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+CONFIG_TOUCHSCREEN_AD7877=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+# CONFIG_BF53X_PFBUTTONS is not set
+# CONFIG_TWI_KEYPAD is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_AD9960 is not set
+# CONFIG_SPI_ADC_BF533 is not set
+# CONFIG_BF533_PFLAGS is not set
+# CONFIG_BF5xx_PPIFCD is not set
+# CONFIG_BF5xx_TIMERS is not set
+# CONFIG_BF5xx_PPI is not set
+CONFIG_BFIN_SPORT=y
+# CONFIG_BFIN_TIMER_LATENCY is not set
+CONFIG_TWI_LCD=m
+CONFIG_TWI_LCD_SLAVE_ADDR=34
+# CONFIG_AD5304 is not set
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_BFIN=y
+CONFIG_SERIAL_BFIN_CONSOLE=y
+CONFIG_SERIAL_BFIN_DMA=y
+# CONFIG_SERIAL_BFIN_PIO is not set
+CONFIG_SERIAL_BFIN_UART0=y
+# CONFIG_BFIN_UART0_CTSRTS is not set
+CONFIG_SERIAL_BFIN_UART1=y
+# CONFIG_BFIN_UART1_CTSRTS is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_BFIN_SPORT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# CAN, the car bus and industrial fieldbus
+#
+CONFIG_CAN4LINUX=y
+
+#
+# linux embedded drivers
+#
+# CONFIG_CAN_MCF5282 is not set
+# CONFIG_CAN_UNCTWINCAN is not set
+CONFIG_CAN_BLACKFIN=m
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_GEN_RTC is not set
+CONFIG_BLACKFIN_DPMC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_BFIN_GPIO is not set
+CONFIG_I2C_BFIN_TWI=y
+CONFIG_TWICLK_KHZ=50
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_AD5252 is not set
+# CONFIG_SENSORS_EEPROM is not set
+CONFIG_SENSORS_PCF8574=m
+CONFIG_SENSORS_PCF8575=y
+# CONFIG_SENSORS_PCA9543 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_BFIN=y
+
+#
+# SPI Protocol Masters
+#
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_BFIN_7171 is not set
+# CONFIG_FB_BFIN_7393 is not set
+CONFIG_FB_BF537_LQ035=y
+CONFIG_LQ035_SLAVE_ADDR=0x58
+CONFIG_FB_BFIN_LANDSCAPE=y
+# CONFIG_FB_BFIN_BGR is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_DEVICE=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_DEVICE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA Blackfin devices
+#
+# CONFIG_SND_BLACKFIN_AD1836 is not set
+CONFIG_SND_BLACKFIN_AD1981B=m
+# CONFIG_SND_BFIN_AD73311 is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+CONFIG_OSS_OBSOLETE_DRIVER=y
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_SPI_MMC is not set
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+
+#
+# RTC drivers
+#
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_BFIN=y
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# PBX support
+#
+# CONFIG_PBX is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SERIAL_EARLY_INIT is not set
+# CONFIG_DEBUG_HUNT_FOR_ZERO is not set
+# CONFIG_DEBUG_BFIN_NO_KERN_HWTRACE is not set
+# CONFIG_BOOTPARAM is not set
+# CONFIG_NO_KERNEL_MSG is not set
+# CONFIG_CPLB_INFO is not set
+# CONFIG_NO_ACCESS_CHECK is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_CAPABILITIES=y
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
diff --git a/arch/blackfin/defconfig b/arch/blackfin/defconfig
index d5904ca..a513fbe 100644
--- a/arch/blackfin/defconfig
+++ b/arch/blackfin/defconfig
@@ -1,19 +1,20 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.20
+# Linux kernel version: 2.6.20.4
 #
 # CONFIG_MMU is not set
 # CONFIG_FPU is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_BLACKFIN=y
 CONFIG_BFIN=y
 CONFIG_SEMAPHORE_SLEEPERS=y
 CONFIG_GENERIC_FIND_NEXT_BIT=y
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
+# CONFIG_GENERIC_TIME is not set
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_UCLINUX=y
 CONFIG_FORCE_MAX_ZONEORDER=14
 CONFIG_IRQCHIP_DEMUX_GPIO=y
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
@@ -55,6 +56,7 @@ CONFIG_ELF_CORE=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
+CONFIG_BIG_ORDER_ALLOC_NOFAIL_MAGIC=3
 # CONFIG_LIMIT_PAGECACHE is not set
 CONFIG_BUDDY=y
 # CONFIG_NP2 is not set
@@ -95,6 +97,9 @@ CONFIG_DEFAULT_AS=y
 # CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_IOSCHED="anticipatory"
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
 
 #
 # Blackfin Processor Options
@@ -107,7 +112,6 @@ CONFIG_DEFAULT_IOSCHED="anticipatory"
 # CONFIG_BF532 is not set
 # CONFIG_BF533 is not set
 # CONFIG_BF534 is not set
-# CONFIG_BF535 is not set
 # CONFIG_BF536 is not set
 CONFIG_BF537=y
 # CONFIG_BF561 is not set
@@ -115,7 +119,6 @@ CONFIG_BF_REV_0_2=y
 # CONFIG_BF_REV_0_3 is not set
 # CONFIG_BF_REV_0_4 is not set
 # CONFIG_BF_REV_0_5 is not set
-CONFIG_BLACKFIN=y
 CONFIG_BFIN_SINGLE_CORE=y
 # CONFIG_BFIN533_EZKIT is not set
 # CONFIG_BFIN533_STAMP is not set
@@ -182,6 +185,7 @@ CONFIG_IRQ_WATCH=13
 #
 # Board customizations
 #
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Board Setup
@@ -221,6 +225,19 @@ CONFIG_HZ=250
 # Memory Optimizations
 #
 CONFIG_I_ENTRY_L1=y
+CONFIG_EXCPT_IRQ_SYSC_L1=y
+CONFIG_DO_IRQ_L1=y
+CONFIG_CORE_TIMER_IRQ_L1=y
+CONFIG_IDLE_L1=y
+CONFIG_SCHEDULE_L1=y
+CONFIG_ARITHMETIC_OPS_L1=y
+CONFIG_ACCESS_OK_L1=y
+CONFIG_MEMSET_L1=y
+CONFIG_MEMCPY_L1=y
+CONFIG_SYS_BFIN_SPINLOCK_L1=y
+# CONFIG_IP_CHECKSUM_L1 is not set
+# CONFIG_SYSCALL_TAB_L1 is not set
+# CONFIG_CPLB_SWITCH_TAB_L1 is not set
 CONFIG_RAMKERNEL=y
 # CONFIG_ROMKERNEL is not set
 CONFIG_SELECT_MEMORY_MODEL=y
@@ -243,6 +260,7 @@ CONFIG_DMA_UNCACHED_1M=y
 #
 CONFIG_BLKFIN_CACHE=y
 CONFIG_BLKFIN_DCACHE=y
+# CONFIG_BLKFIN_DCACHE_BANKA is not set
 # CONFIG_BLKFIN_CACHE_LOCK is not set
 # CONFIG_BLKFIN_WB is not set
 CONFIG_BLKFIN_WT=y
@@ -815,9 +833,8 @@ CONFIG_I2C_CHARDEV=m
 #
 # I2C Hardware Bus support
 #
-# CONFIG_I2C_BFIN_GPIO is not set
-CONFIG_I2C_BFIN_TWI=m
-CONFIG_TWICLK_KHZ=50
+# CONFIG_I2C_BLACKFIN_GPIO is not set
+# CONFIG_I2C_BLACKFIN_TWI is not set
 # CONFIG_I2C_OCORES is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_STUB is not set
@@ -832,6 +849,7 @@ CONFIG_SENSORS_AD5252=m
 # CONFIG_SENSORS_EEPROM is not set
 # CONFIG_SENSORS_PCF8574 is not set
 # CONFIG_SENSORS_PCF8575 is not set
+# CONFIG_SENSORS_PCA9543 is not set
 # CONFIG_SENSORS_PCA9539 is not set
 # CONFIG_SENSORS_PCF8591 is not set
 # CONFIG_SENSORS_MAX6875 is not set
@@ -850,11 +868,11 @@ CONFIG_SPI_MASTER=y
 # SPI Master Controller Drivers
 #
 # CONFIG_SPI_BITBANG is not set
-CONFIG_SPI_BFIN=y
 
 #
 # SPI Protocol Masters
 #
+CONFIG_SPI_BFIN=y
 
 #
 # Dallas's 1-wire bus
@@ -940,10 +958,6 @@ CONFIG_NTSC=y
 # CONFIG_PAL_YCBCR is not set
 CONFIG_ADV7393_1XMEM=y
 # CONFIG_ADV7393_2XMEM is not set
-CONFIG_FB_BF537_LQ035=m
-CONFIG_LQ035_SLAVE_ADDR=0x58
-# CONFIG_FB_BFIN_LANDSCAPE is not set
-# CONFIG_FB_BFIN_BGR is not set
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
 
@@ -1280,12 +1294,11 @@ CONFIG_ENABLE_MUST_CHECK=y
 # CONFIG_DEBUG_KERNEL is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_SERIAL_EARLY_INIT is not set
 CONFIG_DEBUG_HUNT_FOR_ZERO=y
 # CONFIG_DEBUG_BFIN_NO_KERN_HWTRACE is not set
-# CONFIG_BOOTPARAM is not set
-# CONFIG_NO_KERNEL_MSG is not set
 CONFIG_CPLB_INFO=y
-# CONFIG_NO_ACCESS_CHECK is not set
+CONFIG_ACCESS_CHECK=y
 
 #
 # Security options
diff --git a/arch/blackfin/kernel/bfin_dma_5xx.c b/arch/blackfin/kernel/bfin_dma_5xx.c
index 8ea079e..0ccb0dc 100644
--- a/arch/blackfin/kernel/bfin_dma_5xx.c
+++ b/arch/blackfin/kernel/bfin_dma_5xx.c
@@ -119,7 +119,7 @@ static void clear_dma_buffer(unsigned int channel)
 	SSYNC();
 }
 
-int __init blackfin_dma_init(void)
+static int __init blackfin_dma_init(void)
 {
 	int i;
 
@@ -130,7 +130,9 @@ int __init blackfin_dma_init(void)
 		dma_ch[i].regs = base_addr[i];
 		mutex_init(&(dma_ch[i].dmalock));
 	}
-
+	/* Mark MEMDMA Channel 0 as requested since we're using it internally */
+	dma_ch[CH_MEM_STREAM0_DEST].chan_status = DMA_CHANNEL_REQUESTED;
+	dma_ch[CH_MEM_STREAM0_SRC].chan_status = DMA_CHANNEL_REQUESTED;
 	return 0;
 }
 
@@ -593,14 +595,17 @@ unsigned short get_dma_curr_ycount(unsigned int channel)
 }
 EXPORT_SYMBOL(get_dma_curr_ycount);
 
-void *dma_memcpy(void *dest, const void *src, size_t size)
+void *_dma_memcpy(void *dest, const void *src, size_t size)
 {
 	int direction;	/* 1 - address decrease, 0 - address increase */
 	int flag_align;	/* 1 - address aligned,  0 - address unaligned */
 	int flag_2D;	/* 1 - 2D DMA needed,	 0 - 1D DMA needed */
+	unsigned long flags;
 
 	if (size <= 0)
 		return NULL;
+	
+	local_irq_save(flags);
 
 	if ((unsigned long)src < memory_end)
 		blackfin_dcache_flush_range((unsigned int)src,
@@ -725,18 +730,224 @@ void *dma_memcpy(void *dest, const void *src, size_t size)
 	if ((unsigned long)dest < memory_end)
 		blackfin_dcache_invalidate_range((unsigned int)dest,
 						 (unsigned int)(dest + size));
+	local_irq_restore(flags);
 
 	return dest;
 }
+
+void *dma_memcpy(void *dest, const void *src, size_t size)
+{
+	size_t bulk;
+	size_t rest;
+	void * addr;
+
+	bulk = (size >> 16) << 16;
+	rest = size - bulk;
+	if (bulk)
+		_dma_memcpy(dest, src, bulk);
+	addr = _dma_memcpy(dest+bulk, src+bulk, rest);
+	return addr;
+}
+
 EXPORT_SYMBOL(dma_memcpy);
 
 void *safe_dma_memcpy(void *dest, const void *src, size_t size)
 {
-	int flags = 0;
 	void *addr;
-	local_irq_save(flags);
 	addr = dma_memcpy(dest, src, size);
-	local_irq_restore(flags);
 	return addr;
 }
 EXPORT_SYMBOL(safe_dma_memcpy);
+
+void dma_outsb(void __iomem *addr, const void *buf, unsigned short len)
+{
+
+	unsigned long flags;
+	
+	local_irq_save(flags);
+	
+	blackfin_dcache_flush_range((unsigned int)buf,(unsigned int)(buf) + len);
+
+   	bfin_write_MDMA_D0_START_ADDR(addr);
+	bfin_write_MDMA_D0_X_COUNT(len);
+	bfin_write_MDMA_D0_X_MODIFY(0);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_START_ADDR(buf);
+	bfin_write_MDMA_S0_X_COUNT(len);
+	bfin_write_MDMA_S0_X_MODIFY(1);
+	bfin_write_MDMA_S0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(DMAEN | WDSIZE_8);
+	bfin_write_MDMA_D0_CONFIG(WNR | DI_EN | DMAEN | WDSIZE_8);
+
+	while (!(bfin_read_MDMA_D0_IRQ_STATUS() & DMA_DONE));
+
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(0);
+	bfin_write_MDMA_D0_CONFIG(0);
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(dma_outsb);
+
+
+void dma_insb(const void __iomem *addr, void *buf, unsigned short len)
+{
+	unsigned long flags;
+		
+	local_irq_save(flags);
+   	bfin_write_MDMA_D0_START_ADDR(buf);
+	bfin_write_MDMA_D0_X_COUNT(len);
+	bfin_write_MDMA_D0_X_MODIFY(1);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_START_ADDR(addr);
+	bfin_write_MDMA_S0_X_COUNT(len);
+	bfin_write_MDMA_S0_X_MODIFY(0);
+	bfin_write_MDMA_S0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(DMAEN | WDSIZE_8);
+	bfin_write_MDMA_D0_CONFIG(WNR | DI_EN | DMAEN | WDSIZE_8);
+
+	blackfin_dcache_invalidate_range((unsigned int)buf, (unsigned int)(buf) + len);
+
+	while (!(bfin_read_MDMA_D0_IRQ_STATUS() & DMA_DONE));
+
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(0);
+	bfin_write_MDMA_D0_CONFIG(0);
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(dma_insb);
+
+void dma_outsw(void __iomem *addr, const void  *buf, unsigned short len)
+{
+	unsigned long flags;
+	
+	local_irq_save(flags);
+		
+	blackfin_dcache_flush_range((unsigned int)buf,(unsigned int)(buf) + len);
+
+   	bfin_write_MDMA_D0_START_ADDR(addr);
+	bfin_write_MDMA_D0_X_COUNT(len);
+	bfin_write_MDMA_D0_X_MODIFY(0);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_START_ADDR(buf);
+	bfin_write_MDMA_S0_X_COUNT(len);
+	bfin_write_MDMA_S0_X_MODIFY(2);
+	bfin_write_MDMA_S0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(DMAEN | WDSIZE_16);
+	bfin_write_MDMA_D0_CONFIG(WNR | DI_EN | DMAEN | WDSIZE_16);
+
+	while (!(bfin_read_MDMA_D0_IRQ_STATUS() & DMA_DONE));
+
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(0);
+	bfin_write_MDMA_D0_CONFIG(0);
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(dma_outsw);
+
+void dma_insw(const void __iomem *addr, void *buf, unsigned short len)
+{
+	unsigned long flags;
+		
+	local_irq_save(flags);
+	
+   	bfin_write_MDMA_D0_START_ADDR(buf);
+	bfin_write_MDMA_D0_X_COUNT(len);
+	bfin_write_MDMA_D0_X_MODIFY(2);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_START_ADDR(addr);
+	bfin_write_MDMA_S0_X_COUNT(len);
+	bfin_write_MDMA_S0_X_MODIFY(0);
+	bfin_write_MDMA_S0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(DMAEN | WDSIZE_16);
+	bfin_write_MDMA_D0_CONFIG(WNR | DI_EN | DMAEN | WDSIZE_16);
+
+	blackfin_dcache_invalidate_range((unsigned int)buf, (unsigned int)(buf) + len);
+
+	while (!(bfin_read_MDMA_D0_IRQ_STATUS() & DMA_DONE));
+
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(0);
+	bfin_write_MDMA_D0_CONFIG(0);
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(dma_insw);
+
+void dma_outsl(void __iomem *addr, const void *buf, unsigned short len)
+{
+	unsigned long flags;
+	
+	local_irq_save(flags);
+	
+	blackfin_dcache_flush_range((unsigned int)buf,(unsigned int)(buf) + len);
+
+   	bfin_write_MDMA_D0_START_ADDR(addr);
+	bfin_write_MDMA_D0_X_COUNT(len);
+	bfin_write_MDMA_D0_X_MODIFY(0);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_START_ADDR(buf);
+	bfin_write_MDMA_S0_X_COUNT(len);
+	bfin_write_MDMA_S0_X_MODIFY(4);
+	bfin_write_MDMA_S0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(DMAEN | WDSIZE_32);
+	bfin_write_MDMA_D0_CONFIG(WNR | DI_EN | DMAEN | WDSIZE_32);
+
+	while (!(bfin_read_MDMA_D0_IRQ_STATUS() & DMA_DONE));
+
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(0);
+	bfin_write_MDMA_D0_CONFIG(0);
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(dma_outsl);
+
+void dma_insl(const void __iomem *addr, void *buf, unsigned short len)
+{
+	unsigned long flags;
+	
+	local_irq_save(flags);
+	
+   	bfin_write_MDMA_D0_START_ADDR(buf);
+	bfin_write_MDMA_D0_X_COUNT(len);
+	bfin_write_MDMA_D0_X_MODIFY(4);
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_START_ADDR(addr);
+	bfin_write_MDMA_S0_X_COUNT(len);
+	bfin_write_MDMA_S0_X_MODIFY(0);
+	bfin_write_MDMA_S0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(DMAEN | WDSIZE_32);
+	bfin_write_MDMA_D0_CONFIG(WNR | DI_EN | DMAEN | WDSIZE_32);
+
+	blackfin_dcache_invalidate_range((unsigned int)buf, (unsigned int)(buf) + len);
+
+	while (!(bfin_read_MDMA_D0_IRQ_STATUS() & DMA_DONE));
+
+	bfin_write_MDMA_D0_IRQ_STATUS(DMA_DONE | DMA_ERR);
+
+	bfin_write_MDMA_S0_CONFIG(0);
+	bfin_write_MDMA_D0_CONFIG(0);
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(dma_insl);
diff --git a/arch/blackfin/kernel/bfin_gpio.c b/arch/blackfin/kernel/bfin_gpio.c
index e9f24a9..3f49fae 100644
--- a/arch/blackfin/kernel/bfin_gpio.c
+++ b/arch/blackfin/kernel/bfin_gpio.c
@@ -144,7 +144,7 @@ inline int check_gpio(unsigned short gpio)
 }
 
 #ifdef BF537_FAMILY
-void port_setup(unsigned short gpio, unsigned short usage)
+static void port_setup(unsigned short gpio, unsigned short usage)
 {
 	if (usage == GPIO_USAGE) {
 		if (*port_fer[gpio_bank(gpio)] & gpio_bit(gpio))
@@ -160,7 +160,7 @@ void port_setup(unsigned short gpio, unsigned short usage)
 #endif
 
 
-void default_gpio(unsigned short gpio)
+static void default_gpio(unsigned short gpio)
 {
 	unsigned short bank,bitmask;
 
@@ -177,8 +177,7 @@ void default_gpio(unsigned short gpio)
 	gpio_bankb[bank]->edge &= ~bitmask;
 }
 
-
-int __init bfin_gpio_init(void)
+static int __init bfin_gpio_init(void)
 {
 	int i;
 
@@ -189,9 +188,9 @@ int __init bfin_gpio_init(void)
 
 #if defined(BF537_FAMILY) && (defined(CONFIG_BFIN_MAC) || defined(CONFIG_BFIN_MAC_MODULE))
 # if defined(CONFIG_BFIN_MAC_RMII)
-	reserved_map[PORT_H] = 0xC373;
+	reserved_map[gpio_bank(PORT_H)] = 0xC373;
 # else
-	reserved_map[PORT_H] = 0xFFFF;
+	reserved_map[gpio_bank(PORT_H)] = 0xFFFF;
 # endif
 #endif
 
diff --git a/arch/blackfin/kernel/setup.c b/arch/blackfin/kernel/setup.c
index 342bb8d..02dc743 100644
--- a/arch/blackfin/kernel/setup.c
+++ b/arch/blackfin/kernel/setup.c
@@ -33,7 +33,6 @@
 #include <linux/seq_file.h>
 #include <linux/cpu.h>
 #include <linux/module.h>
-#include <linux/console.h>
 #include <linux/tty.h>
 
 #include <linux/ext2_fs.h>
@@ -44,6 +43,8 @@
 #include <asm/blackfin.h>
 #include <asm/cplbinit.h>
 
+u16 _bfin_swrst;
+
 unsigned long memory_start, memory_end, physical_mem_end;
 unsigned long reserved_mem_dcache_on;
 unsigned long reserved_mem_icache_on;
@@ -175,6 +176,9 @@ void __init setup_arch(char **cmdline_p)
 	unsigned long mtd_phys = 0;
 #endif
 
+#ifdef CONFIG_DUMMY_CONSOLE
+	conswitchp = &dummy_con;
+#endif
 	cclk = get_cclk();
 	sclk = get_sclk();
 
@@ -379,37 +383,27 @@ void __init setup_arch(char **cmdline_p)
 	if (l1_length > L1_DATA_A_LENGTH)
 		panic("L1 memory overflow\n");
 
-	bf53x_cache_init();
-
-#if defined(CONFIG_SMC91X) || defined(CONFIG_SMC91X_MODULE)
-# if defined(CONFIG_BFIN_SHARED_FLASH_ENET) && defined(CONFIG_BFIN533_STAMP)
-	/* setup BF533_STAMP CPLD to route AMS3 to Ethernet MAC */
-	bfin_write_FIO_DIR(bfin_read_FIO_DIR() | (1 << CONFIG_ENET_FLASH_PIN));
-	bfin_write_FIO_FLAG_S(1 << CONFIG_ENET_FLASH_PIN);
-	SSYNC();
-# endif
-# if defined (CONFIG_BFIN561_EZKIT)
-	bfin_write_FIO0_DIR(bfin_read_FIO0_DIR() | (1 << 12));
-	SSYNC();
-# endif /* defined (CONFIG_BFIN561_EZKIT) */
+#ifdef BF561_FAMILY
+	_bfin_swrst = bfin_read_SICA_SWRST();
+#else
+	_bfin_swrst = bfin_read_SWRST();
 #endif
 
+	bf53x_cache_init();
+
 	printk(KERN_INFO "Hardware Trace Enabled\n");
 	bfin_write_TBUFCTL(0x03);
 }
 
-#if defined(CONFIG_BF561)
-static struct cpu cpu[2];
-#else
-static struct cpu cpu[1];
-#endif
 static int __init topology_init(void)
 {
 #if defined (CONFIG_BF561)
+	static struct cpu cpu[2];
 	register_cpu(&cpu[0], 0);
 	register_cpu(&cpu[1], 1);
 	return 0;
 #else
+	static struct cpu cpu[1];
 	return register_cpu(cpu, 0);
 #endif
 }
diff --git a/arch/blackfin/kernel/traps.c b/arch/blackfin/kernel/traps.c
index 9556b73..9932ede 100644
--- a/arch/blackfin/kernel/traps.c
+++ b/arch/blackfin/kernel/traps.c
@@ -59,9 +59,10 @@ static int printk_address(unsigned long address)
 	struct vm_list_struct *vml;
 	struct task_struct *p;
 	struct mm_struct *mm;
+	unsigned long offset;
 
 #ifdef CONFIG_KALLSYMS
-	unsigned long offset = 0, symsize;
+	unsigned long symsize;
 	const char *symname;
 	char *modname;
 	char *delim = ":";
@@ -106,12 +107,19 @@ static int printk_address(unsigned long address)
 					              sizeof(_tmpbuf));
 				}
 
+				/* FLAT does not have its text aligned to the start of
+				 * the map while FDPIC ELF does ...
+				 */
+				if (current->mm &&
+				    (address > current->mm->start_code) &&
+				    (address < current->mm->end_code))
+					offset = address - current->mm->start_code;
+				else
+					offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
+
 				write_unlock_irq(&tasklist_lock);
 				return printk("<0x%p> [ %s + 0x%lx ]",
-				              (void*)address, name,
-				              (unsigned long)
-				                ((address - vma->vm_start) +
-				                 (vma->vm_pgoff << PAGE_SHIFT)));
+				              (void*)address, name, offset);
 			}
 
 			vml = vml->next;
diff --git a/arch/blackfin/kernel/vmlinux.lds.S b/arch/blackfin/kernel/vmlinux.lds.S
index 6ae9ebb..86fe679 100644
--- a/arch/blackfin/kernel/vmlinux.lds.S
+++ b/arch/blackfin/kernel/vmlinux.lds.S
@@ -54,7 +54,7 @@ SECTIONS
 	{
 		 _text = .;
 		 __stext = .;
-		*(.text)
+		TEXT_TEXT
 		SCHED_TEXT
 		*(.text.lock)
 		. = ALIGN(16);
@@ -200,7 +200,7 @@ SECTIONS
 		 __sdata = .;
 		. = ALIGN(0x2000);
 		*(.data.init_task)
-		*(.data)
+		DATA_DATA
 
 		. = ALIGN(32);
 		*(.data.cacheline_aligned)
diff --git a/arch/blackfin/lib/ins.S b/arch/blackfin/lib/ins.S
index 730d2b4..7d5e984 100644
--- a/arch/blackfin/lib/ins.S
+++ b/arch/blackfin/lib/ins.S
@@ -29,6 +29,7 @@
  */
 
 #include <linux/linkage.h>
+#include <asm/blackfin.h>
 
 .align 2
 
@@ -39,11 +40,14 @@ ENTRY(_insl)
 	P2 = R2;	/* P2 = count */
 	SSYNC;
 	LSETUP( .Llong_loop_s, .Llong_loop_e) LC0 = P2;
-.Llong_loop_s: R0 = [P0];
-.Llong_loop_e: [P1++] = R0;
+.Llong_loop_s:  R0 = [P0];
+		[P1++] = R0;
+		NOP;
+.Llong_loop_e: 	NOP;
 	sti R3;
 	RTS;
 
+
 ENTRY(_insw)
 	P0 = R0;	/* P0 = port */
 	cli R3;
@@ -51,8 +55,10 @@ ENTRY(_insw)
 	P2 = R2;	/* P2 = count */
 	SSYNC;
 	LSETUP( .Lword_loop_s, .Lword_loop_e) LC0 = P2;
-.Lword_loop_s: R0 = W[P0];
-.Lword_loop_e: W[P1++] = R0;
+.Lword_loop_s:  R0 = W[P0];
+		W[P1++] = R0;
+		NOP;
+.Lword_loop_e: 	NOP;
 	sti R3;
 	RTS;
 
@@ -63,7 +69,9 @@ ENTRY(_insb)
 	P2 = R2;	/* P2 = count */
 	SSYNC;
 	LSETUP( .Lbyte_loop_s, .Lbyte_loop_e) LC0 = P2;
-.Lbyte_loop_s: R0 = B[P0];
-.Lbyte_loop_e: B[P1++] = R0;
+.Lbyte_loop_s:  R0 = B[P0];
+		B[P1++] = R0;
+		NOP;
+.Lbyte_loop_e:  NOP;
 	sti R3;
 	RTS;
diff --git a/arch/blackfin/mach-bf533/boards/stamp.c b/arch/blackfin/mach-bf533/boards/stamp.c
index d7b3a5d..9a472fe 100644
--- a/arch/blackfin/mach-bf533/boards/stamp.c
+++ b/arch/blackfin/mach-bf533/boards/stamp.c
@@ -164,6 +164,13 @@ static struct bfin5xx_spi_chip ad5304_chip_info = {
 };
 #endif
 
+#if defined(CONFIG_SPI_MMC) || defined(CONFIG_SPI_MMC_MODULE)
+static struct bfin5xx_spi_chip spi_mmc_chip_info = {
+	.enable_dma = 1,
+	.bits_per_word = 8,
+};
+#endif
+
 static struct spi_board_info bfin_spi_board_info[] __initdata = {
 #if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
 	{
@@ -199,6 +206,27 @@ static struct spi_board_info bfin_spi_board_info[] __initdata = {
 	},
 #endif
 
+#if defined(CONFIG_SPI_MMC) || defined(CONFIG_SPI_MMC_MODULE)
+	{
+		.modalias = "spi_mmc_dummy",
+		.max_speed_hz = 25000000,     /* max spi clock (SCK) speed in HZ */
+		.bus_num = 1,
+		.chip_select = 0,
+		.platform_data = NULL,
+		.controller_data = &spi_mmc_chip_info,
+		.mode = SPI_MODE_3,
+	},
+	{
+		.modalias = "spi_mmc",
+		.max_speed_hz = 25000000,     /* max spi clock (SCK) speed in HZ */
+		.bus_num = 1,
+		.chip_select = CONFIG_SPI_MMC_CS_CHAN,
+		.platform_data = NULL,
+		.controller_data = &spi_mmc_chip_info,
+		.mode = SPI_MODE_3,
+	},
+#endif
+
 #if defined(CONFIG_PBX)
 	{
 		.modalias	= "fxs-spi",
@@ -310,12 +338,25 @@ static struct platform_device *stamp_devices[] __initdata = {
 
 static int __init stamp_init(void)
 {
+	int ret;
+
 	printk(KERN_INFO "%s(): registering device resources\n", __FUNCTION__);
-	platform_add_devices(stamp_devices, ARRAY_SIZE(stamp_devices));
+	ret = platform_add_devices(stamp_devices, ARRAY_SIZE(stamp_devices));
+	if (ret < 0)
+		return ret;
+
+#if defined(CONFIG_SMC91X) || defined(CONFIG_SMC91X_MODULE)
+# if defined(CONFIG_BFIN_SHARED_FLASH_ENET)
+	/* setup BF533_STAMP CPLD to route AMS3 to Ethernet MAC */
+	bfin_write_FIO_DIR(bfin_read_FIO_DIR() | (1 << CONFIG_ENET_FLASH_PIN));
+	bfin_write_FIO_FLAG_S(1 << CONFIG_ENET_FLASH_PIN);
+	SSYNC();
+# endif
+#endif
+
 #if defined(CONFIG_SPI_BFIN) || defined(CONFIG_SPI_BFIN_MODULE)
-	spi_register_board_info(bfin_spi_board_info, ARRAY_SIZE(bfin_spi_board_info));
+	return spi_register_board_info(bfin_spi_board_info, ARRAY_SIZE(bfin_spi_board_info));
 #endif
-	return 0;
 }
 
 arch_initcall(stamp_init);
diff --git a/arch/blackfin/mach-bf533/head.S b/arch/blackfin/mach-bf533/head.S
index 4808edb..4db9e62 100644
--- a/arch/blackfin/mach-bf533/head.S
+++ b/arch/blackfin/mach-bf533/head.S
@@ -173,7 +173,8 @@ ENTRY(__stext)
 	STI R2;
 #endif
 
-	/* Initialise UART */
+	/* Initialise UART - when booting from u-boot, the UART is not disabled
+	 * so if we dont initalize here, our serial console gets hosed */
 	p0.h = hi(UART_LCR);
 	p0.l = lo(UART_LCR);
 	r0 = 0x0(Z);
@@ -468,12 +469,6 @@ ENTRY(_bfin_reset)
 	w[p0] = r0.l;
 #endif
 
-	/* Clear the bits 13-15 in SWRST if they werent cleared */
-	p0.h = hi(SWRST);
-	p0.l = lo(SWRST);
-	csync;
-	r0.l = w[p0];
-
 	/* Clear the IMASK register */
 	p0.h = hi(IMASK);
 	p0.l = lo(IMASK);
@@ -487,66 +482,30 @@ ENTRY(_bfin_reset)
 	[p0] = r0;
 	SSYNC;
 
-	/* Disable the WDOG TIMER */
-	p0.h = hi(WDOG_CTL);
-	p0.l = lo(WDOG_CTL);
-	r0.l = 0xAD6;
-	w[p0] = r0.l;
-	SSYNC;
-
-	/* Clear the sticky bit incase it is already set */
-	p0.h = hi(WDOG_CTL);
-	p0.l = lo(WDOG_CTL);
-	r0.l = 0x8AD6;
-	w[p0] = r0.l;
-	SSYNC;
-
-	/* Program the count value */
-	R0.l = 0x100;
-	R0.h = 0x0;
-	P0.h = hi(WDOG_CNT);
-	P0.l = lo(WDOG_CNT);
-	[P0] = R0;
+	/* make sure SYSCR is set to use BMODE */
+	P0.h = hi(SYSCR);
+	P0.l = lo(SYSCR);
+	R0.l = 0x0;
+	W[P0] = R0.l;
 	SSYNC;
 
-	/* Program WDOG_STAT if necessary */
-	P0.h = hi(WDOG_CTL);
-	P0.l = lo(WDOG_CTL);
-	R0 = W[P0](Z);
-	CC = BITTST(R0,1);
-	if !CC JUMP .LWRITESTAT;
-	CC = BITTST(R0,2);
-	if !CC JUMP .LWRITESTAT;
-	JUMP .LSKIP_WRITE;
-
-.LWRITESTAT:
-	/* When watch dog timer is enabled, a write to STAT will load the contents of CNT to STAT */
-	R0 = 0x0000(z);
-	P0.h = hi(WDOG_STAT);
-	P0.l = lo(WDOG_STAT)
-	[P0] = R0;
+	/* issue a system soft reset */
+	P1.h = hi(SWRST);
+	P1.l = lo(SWRST);
+	R1.l = 0x0007;
+	W[P1] = R1;
 	SSYNC;
 
-.LSKIP_WRITE:
-	/* Enable the reset event */
-	P0.h = hi(WDOG_CTL);
-	P0.l = lo(WDOG_CTL);
-	R0 = W[P0](Z);
-	BITCLR(R0,1);
-	BITCLR(R0,2);
-	W[P0] = R0.L;
-	SSYNC;
-	NOP;
-
-	/* Enable the wdog counter */
-	R0 = W[P0](Z);
-	BITCLR(R0,4);
-	W[P0] = R0.L;
+	/* clear system soft reset */
+	R0.l = 0x0000;
+	W[P0] = R0;
 	SSYNC;
 
-	IDLE;
+	/* issue core reset */
+	raise 1;
 
 	RTS;
+ENDPROC(_bfin_reset)
 
 #if CONFIG_DEBUG_KERNEL_START
 debug_kernel_start_trap:
diff --git a/arch/blackfin/mach-bf537/cpu.c b/arch/blackfin/mach-bf537/cpu.c
index 2d83b7e..0442c4c 100644
--- a/arch/blackfin/mach-bf537/cpu.c
+++ b/arch/blackfin/mach-bf537/cpu.c
@@ -43,13 +43,13 @@
 #define VCO1 (CONFIG_CLKIN_HZ*9)	/*99532800 */
 #define VCO(x) VCO##x
 
-#define FREQ(x) {VCO(x),VCO(x)/4},{VCO(x),VCO(x)/2},{VCO(x),VCO(x)}
+#define MFREQ(x) {VCO(x),VCO(x)/4},{VCO(x),VCO(x)/2},{VCO(x),VCO(x)}
 /* frequency */
 static struct cpufreq_frequency_table bf537_freq_table[] = {
-	FREQ(1),
-	FREQ(3),
+	MFREQ(1),
+	MFREQ(3),
 	{VCO4, VCO4 / 2}, {VCO4, VCO4},
-	FREQ(5),
+	MFREQ(5),
 	{0, CPUFREQ_TABLE_END},
 };
 
@@ -59,13 +59,14 @@ static struct cpufreq_frequency_table bf537_freq_table[] = {
  */
 static int bf537_getfreq(unsigned int cpu)
 {
-	unsigned long cclk_mhz, vco_mhz;
+	unsigned long cclk_mhz;
 
 	/* The driver only support single cpu */
 	if (cpu == 0)
 		dpmc_fops.ioctl(NULL, NULL, IOCTL_GET_CORECLOCK, &cclk_mhz);
 	else
 		cclk_mhz = -1;
+
 	return cclk_mhz;
 }
 
@@ -75,13 +76,12 @@ static int bf537_target(struct cpufreq_policy *policy,
 	unsigned long cclk_mhz;
 	unsigned long vco_mhz;
 	unsigned long flags;
-	unsigned int index, vco_index;
-	int i;
-
+	unsigned int index;
 	struct cpufreq_freqs freqs;
-	if (cpufreq_frequency_table_target
-	    (policy, bf537_freq_table, target_freq, relation, &index))
+
+	if (cpufreq_frequency_table_target(policy, bf537_freq_table, target_freq, relation, &index))
 		return -EINVAL;
+
 	cclk_mhz = bf537_freq_table[index].frequency;
 	vco_mhz = bf537_freq_table[index].index;
 
@@ -114,8 +114,6 @@ static int bf537_verify_speed(struct cpufreq_policy *policy)
 
 static int __init __bf537_cpu_init(struct cpufreq_policy *policy)
 {
-	int result;
-
 	if (policy->cpu != 0)
 		return -EINVAL;
 
diff --git a/arch/blackfin/mach-bf537/head.S b/arch/blackfin/mach-bf537/head.S
index d104e1d..2c2652b 100644
--- a/arch/blackfin/mach-bf537/head.S
+++ b/arch/blackfin/mach-bf537/head.S
@@ -181,7 +181,8 @@ ENTRY(__stext)
 	SSYNC;
 #endif
 
-	/*Initialise UART*/
+	/* Initialise UART - when booting from u-boot, the UART is not disabled
+	 * so if we dont initalize here, our serial console gets hosed */
 	p0.h = hi(UART_LCR);
 	p0.l = lo(UART_LCR);
 	r0 = 0x0(Z);
@@ -469,47 +470,41 @@ ENTRY(_bfin_reset)
 	SSYNC;
 
 #if defined(CONFIG_MTD_M25P80)
-/*
- * The following code fix the SPI flash reboot issue,
- * /CS signal of the chip which is using PF10 return to GPIO mode
- */
+	/*
+	 * The following code fix the SPI flash reboot issue,
+	 * /CS signal of the chip which is using PF10 return to GPIO mode
+	 */
 	p0.h = hi(PORTF_FER);
 	p0.l = lo(PORTF_FER);
 	r0.l = 0x0000;
 	w[p0] = r0.l;
 	SSYNC;
 
-/* /CS return to high */
+	/* /CS return to high */
 	p0.h = hi(PORTFIO);
 	p0.l = lo(PORTFIO);
 	r0.l = 0xFFFF;
 	w[p0] = r0.l;
 	SSYNC;
 
-/* Delay some time, This is necessary */
+	/* Delay some time, This is necessary */
 	r1.h = 0;
 	r1.l = 0x400;
 	p1   = r1;
-	lsetup (_delay_lab1,_delay_lab1_end ) lc1 = p1;
-_delay_lab1:
+	lsetup (.L_delay_lab1, .L_delay_lab1_end) lc1 = p1;
+.L_delay_lab1:
 	r0.h = 0;
 	r0.l = 0x8000;
 	p0   = r0;
-	lsetup (_delay_lab0,_delay_lab0_end ) lc0 = p0;
-_delay_lab0:
+	lsetup (.L_delay_lab0, .L_delay_lab0_end) lc0 = p0;
+.L_delay_lab0:
 	nop;
-_delay_lab0_end:
+.L_delay_lab0_end:
 	nop;
-_delay_lab1_end:
+.L_delay_lab1_end:
 	nop;
 #endif
 
-	/* Clear the bits 13-15 in SWRST if they werent cleared */
-	p0.h = hi(SWRST);
-	p0.l = lo(SWRST);
-	csync;
-	r0.l = w[p0];
-
 	/* Clear the IMASK register */
 	p0.h = hi(IMASK);
 	p0.l = lo(IMASK);
@@ -523,68 +518,30 @@ _delay_lab1_end:
 	[p0] = r0;
 	SSYNC;
 
-	/* Disable the WDOG TIMER */
-	p0.h = hi(WDOG_CTL);
-	p0.l = lo(WDOG_CTL);
-	r0.l = 0xAD6;
-	w[p0] = r0.l;
-	SSYNC;
-
-	/* Clear the sticky bit incase it is already set */
-	p0.h = hi(WDOG_CTL);
-	p0.l = lo(WDOG_CTL);
-	r0.l = 0x8AD6;
-	w[p0] = r0.l;
-	SSYNC;
-
-	/* Program the count value */
-	R0.l = 0x100;
-	R0.h = 0x0;
-	P0.h = hi(WDOG_CNT);
-	P0.l = lo(WDOG_CNT);
-	[P0] = R0;
-	SSYNC;
-
-	/* Program WDOG_STAT if necessary */
-	P0.h = hi(WDOG_CTL);
-	P0.l = lo(WDOG_CTL);
-	R0 = W[P0](Z);
-	CC = BITTST(R0,1);
-	if !CC JUMP .LWRITESTAT;
-	CC = BITTST(R0,2);
-	if !CC JUMP .LWRITESTAT;
-	JUMP .LSKIP_WRITE;
-
-.LWRITESTAT:
-	/* When watch dog timer is enabled,
-	 * a write to STAT will load the contents of CNT to STAT
-	 */
-	R0 = 0x0000(z);
-	P0.h = hi(WDOG_STAT);
-	P0.l = lo(WDOG_STAT)
-	[P0] = R0;
+	/* make sure SYSCR is set to use BMODE */
+	P0.h = hi(SYSCR);
+	P0.l = lo(SYSCR);
+	R0.l = 0x0;
+	W[P0] = R0.l;
 	SSYNC;
 
-.LSKIP_WRITE:
-	/* Enable the reset event */
-	P0.h = hi(WDOG_CTL);
-	P0.l = lo(WDOG_CTL);
-	R0 = W[P0](Z);
-	BITCLR(R0,1);
-	BITCLR(R0,2);
-	W[P0] = R0.L;
+	/* issue a system soft reset */
+	P1.h = hi(SWRST);
+	P1.l = lo(SWRST);
+	R1.l = 0x0007;
+	W[P1] = R1;
 	SSYNC;
-	NOP;
 
-	/* Enable the wdog counter */
-	R0 = W[P0](Z);
-	BITCLR(R0,4);
-	W[P0] = R0.L;
+	/* clear system soft reset */
+	R0.l = 0x0000;
+	W[P0] = R0;
 	SSYNC;
 
-	IDLE;
+	/* issue core reset */
+	raise 1;
 
 	RTS;
+ENDPROC(_bfin_reset)
 
 .data
 
diff --git a/arch/blackfin/mach-bf561/boards/Makefile b/arch/blackfin/mach-bf561/boards/Makefile
index 886edc7..495a1cf 100644
--- a/arch/blackfin/mach-bf561/boards/Makefile
+++ b/arch/blackfin/mach-bf561/boards/Makefile
@@ -3,5 +3,6 @@
 #
 
 obj-$(CONFIG_GENERIC_BOARD)            += generic_board.o
-obj-$(CONFIG_BFIN561_EZKIT)            += ezkit.o
 obj-$(CONFIG_BFIN561_BLUETECHNIX_CM)   += cm_bf561.o
+obj-$(CONFIG_BFIN561_EZKIT)            += ezkit.o
+obj-$(CONFIG_BFIN561_TEPLA)            += tepla.o
diff --git a/arch/blackfin/mach-bf561/boards/ezkit.c b/arch/blackfin/mach-bf561/boards/ezkit.c
index 14eb4f9..9720b5c 100644
--- a/arch/blackfin/mach-bf561/boards/ezkit.c
+++ b/arch/blackfin/mach-bf561/boards/ezkit.c
@@ -32,12 +32,61 @@
 #include <linux/spi/spi.h>
 #include <asm/irq.h>
 #include <asm/bfin5xx_spi.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
 
 /*
  * Name the Board for the /proc/cpuinfo
  */
 char *bfin_board_name = "ADDS-BF561-EZKIT";
 
+#define ISP1761_BASE       0x2C0F0000
+#define ISP1761_IRQ        IRQ_PF10
+
+#if defined(CONFIG_USB_ISP1760_HCD) || defined(CONFIG_USB_ISP1760_HCD_MODULE)
+static struct resource bfin_isp1761_resources[] = {
+	[0] = {
+		.name	= "isp1761-regs",
+		.start  = ISP1761_BASE + 0x00000000,
+		.end    = ISP1761_BASE + 0x000fffff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = ISP1761_IRQ,
+		.end    = ISP1761_IRQ,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device bfin_isp1761_device = {
+	.name           = "isp1761",
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(bfin_isp1761_resources),
+	.resource       = bfin_isp1761_resources,
+};
+
+static struct platform_device *bfin_isp1761_devices[] = {
+	&bfin_isp1761_device,
+};
+
+int __init bfin_isp1761_init(void)
+{
+	unsigned int num_devices=ARRAY_SIZE(bfin_isp1761_devices);
+
+	printk(KERN_INFO "%s(): registering device resources\n", __FUNCTION__);
+	set_irq_type(ISP1761_IRQ, IRQF_TRIGGER_FALLING);
+
+	return platform_add_devices(bfin_isp1761_devices, num_devices);
+}
+
+void __exit bfin_isp1761_exit(void)
+{
+	platform_device_unregister(&bfin_isp1761_device);
+}
+
+arch_initcall(bfin_isp1761_init);
+#endif
+
 /*
  *  USB-LAN EzExtender board
  *  Driver needs to know address, irq and flag pin.
@@ -135,13 +184,18 @@ static int __init ezkit_init(void)
 {
 	int ret;
 
-	printk(KERN_INFO "%s(): registering device resources\n", __FUNCTION__);
-	ret = platform_add_devices(ezkit_devices,
-		 ARRAY_SIZE(ezkit_devices));
+	printk(KERN_INFO "%s(): registering device resources\n", __func__);
+
+	ret = platform_add_devices(ezkit_devices, ARRAY_SIZE(ezkit_devices));
 	if (ret < 0)
 		return ret;
-	return spi_register_board_info(bfin_spi_board_info,
-				ARRAY_SIZE(bfin_spi_board_info));
+
+#if defined(CONFIG_SMC91X) || defined(CONFIG_SMC91X_MODULE)
+	bfin_write_FIO0_DIR(bfin_read_FIO0_DIR() | (1 << 12));
+	SSYNC();
+#endif
+
+	return spi_register_board_info(bfin_spi_board_info, ARRAY_SIZE(bfin_spi_board_info));
 }
 
 arch_initcall(ezkit_init);
diff --git a/arch/blackfin/mach-bf561/boards/tepla.c b/arch/blackfin/mach-bf561/boards/tepla.c
new file mode 100644
index 0000000..db308c7
--- /dev/null
+++ b/arch/blackfin/mach-bf561/boards/tepla.c
@@ -0,0 +1,61 @@
+/*
+ *  File: arch/blackfin/mach-bf561/tepla.c
+ *
+ *  Copyright 2004-2007 Analog Devices Inc.
+ *  Only SMSC91C1111 was registered, may do more later.
+ *
+ *  Copyright 2005 National ICT Australia (NICTA), Aidan Williams <aidan@nicta.com.au>
+ *  Thanks to Jamey Hicks.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+
+char *bfin_board_name = "Tepla-BF561";
+
+/*
+ *  Driver needs to know address, irq and flag pin.
+ */
+static struct resource smc91x_resources[] = {
+	{
+		.start	= 0x2C000300,
+		.end	= 0x2C000320,
+		.flags	= IORESOURCE_MEM,
+	},{
+		.start	= IRQ_PROG_INTB,
+		.end	= IRQ_PROG_INTB,
+		.flags	= IORESOURCE_IRQ|IORESOURCE_IRQ_HIGHLEVEL,
+	},{
+		/*
+		 *  denotes the flag pin and is used directly if
+		 *  CONFIG_IRQCHIP_DEMUX_GPIO is defined.
+		 */
+		.start	= IRQ_PF7,
+		.end	= IRQ_PF7,
+		.flags	= IORESOURCE_IRQ|IORESOURCE_IRQ_HIGHLEVEL,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name          = "smc91x",
+	.id            = 0,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource      = smc91x_resources,
+};
+
+static struct platform_device *tepla_devices[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init tepla_init(void)
+{
+	printk(KERN_INFO "%s(): registering device resources\n", __FUNCTION__);
+	return platform_add_devices(tepla_devices, ARRAY_SIZE(tepla_devices));
+}
+
+arch_initcall(tepla_init);
diff --git a/arch/blackfin/mach-bf561/head.S b/arch/blackfin/mach-bf561/head.S
index 7bca478..ad9187a 100644
--- a/arch/blackfin/mach-bf561/head.S
+++ b/arch/blackfin/mach-bf561/head.S
@@ -127,7 +127,8 @@ ENTRY(__stext)
 	STI R2;
 #endif
 
-	/* Initialise UART*/
+	/* Initialise UART - when booting from u-boot, the UART is not disabled
+	 * so if we dont initalize here, our serial console gets hosed */
 	p0.h = hi(UART_LCR);
 	p0.l = lo(UART_LCR);
 	r0 = 0x0(Z);
@@ -414,12 +415,6 @@ ENTRY(_bfin_reset)
 	w[p0] = r0.l;
 #endif
 
-	/* Clear the bits 13-15 in SWRST if they werent cleared */
-	p0.h = hi(SICA_SWRST);
-	p0.l = lo(SICA_SWRST);
-	csync;
-	r0.l = w[p0];
-
 	/* Clear the IMASK register */
 	p0.h = hi(IMASK);
 	p0.l = lo(IMASK);
@@ -433,68 +428,30 @@ ENTRY(_bfin_reset)
 	[p0] = r0;
 	SSYNC;
 
-	/* Disable the WDOG TIMER */
-	p0.h = hi(WDOGA_CTL);
-	p0.l = lo(WDOGA_CTL);
-	r0.l = 0xAD6;
-	w[p0] = r0.l;
-	SSYNC;
-
-	/* Clear the sticky bit incase it is already set */
-	p0.h = hi(WDOGA_CTL);
-	p0.l = lo(WDOGA_CTL);
-	r0.l = 0x8AD6;
-	w[p0] = r0.l;
+	/* make sure SYSCR is set to use BMODE */
+	P0.h = hi(SICA_SYSCR);
+	P0.l = lo(SICA_SYSCR);
+	R0.l = 0x20;
+	W[P0] = R0.l;
 	SSYNC;
 
-	/* Program the count value */
-	R0.l = 0x100;
-	R0.h = 0x0;
-	P0.h = hi(WDOGA_CNT);
-	P0.l = lo(WDOGA_CNT);
-	[P0] = R0;
+	/* issue a system soft reset */
+	P1.h = hi(SICA_SWRST);
+	P1.l = lo(SICA_SWRST);
+	R1.l = 0x0007;
+	W[P1] = R1;
 	SSYNC;
 
-	/* Program WDOG_STAT if necessary */
-	P0.h = hi(WDOGA_CTL);
-	P0.l = lo(WDOGA_CTL);
-	R0 = W[P0](Z);
-	CC = BITTST(R0,1);
-	if !CC JUMP .LWRITESTAT;
-	CC = BITTST(R0,2);
-	if !CC JUMP .LWRITESTAT;
-	JUMP .LSKIP_WRITE;
-
-.LWRITESTAT:
-	/* When watch dog timer is enabled,
-	 * a write to STAT will load the contents of CNT to STAT
-	 */
-	R0 = 0x0000(z);
-	P0.h = hi(WDOGA_STAT);
-	P0.l = lo(WDOGA_STAT)
-	[P0] = R0;
-	SSYNC;
-
-.LSKIP_WRITE:
-	/* Enable the reset event */
-	P0.h = hi(WDOGA_CTL);
-	P0.l = lo(WDOGA_CTL);
-	R0 = W[P0](Z);
-	BITCLR(R0,1);
-	BITCLR(R0,2);
-	W[P0] = R0.L;
-	SSYNC;
-	NOP;
-
-	/* Enable the wdog counter */
-	R0 = W[P0](Z);
-	BITCLR(R0,4);
-	W[P0] = R0.L;
+	/* clear system soft reset */
+	R0.l = 0x0000;
+	W[P0] = R0;
 	SSYNC;
 
-	IDLE;
+	/* issue core reset */
+	raise 1;
 
 	RTS;
+ENDPROC(_bfin_reset)
 
 .data
 
diff --git a/arch/blackfin/mach-common/entry.S b/arch/blackfin/mach-common/entry.S
index 8eb0a90..7d03687 100644
--- a/arch/blackfin/mach-common/entry.S
+++ b/arch/blackfin/mach-common/entry.S
@@ -181,6 +181,12 @@ ENTRY(_ex_single_step)
 
 _return_from_exception:
 	DEBUG_START_HWTRACE
+#ifdef ANOMALY_05000257
+	R7=LC0;
+	LC0=R7;
+	R7=LC1;
+	LC1=R7;
+#endif
 	(R7:6,P5:4) = [sp++];
 	ASTAT = [sp++];
 	sp = retn;
@@ -706,6 +712,11 @@ _schedule_and_signal_from_int:
 	p1.h = _evt_system_call;
 	[p0] = p1;
 	csync;
+
+	/* Set orig_p0 to -1 to indicate this isn't the end of a syscall.  */
+	r0 = -1 (x);
+	[sp + PT_ORIG_P0] = r0;
+
 	p1 = rets;
 	[sp + PT_RESERVED] = p1;
 
diff --git a/arch/blackfin/mach-common/pm.c b/arch/blackfin/mach-common/pm.c
index deb2727..afed524 100644
--- a/arch/blackfin/mach-common/pm.c
+++ b/arch/blackfin/mach-common/pm.c
@@ -102,10 +102,8 @@ static int bfin_pm_prepare(suspend_state_t state)
 	switch (state) {
 	case PM_SUSPEND_STANDBY:
 		break;
-	case PM_SUSPEND_MEM:
-		return -ENOTSUPP;
 
-	case PM_SUSPEND_DISK:
+	case PM_SUSPEND_MEM:
 		return -ENOTSUPP;
 
 	default:
@@ -126,10 +124,8 @@ static int bfin_pm_enter(suspend_state_t state)
 	case PM_SUSPEND_STANDBY:
 		bfin_pm_suspend_standby_enter();
 		break;
-	case PM_SUSPEND_MEM:
-		return -ENOTSUPP;
 
-	case PM_SUSPEND_DISK:
+	case PM_SUSPEND_MEM:
 		return -ENOTSUPP;
 
 	default:
@@ -155,9 +151,6 @@ static int bfin_pm_finish(suspend_state_t state)
 	case PM_SUSPEND_MEM:
 		return -ENOTSUPP;
 
-	case PM_SUSPEND_DISK:
-		return -ENOTSUPP;
-
 	default:
 		return -EINVAL;
 	}
@@ -166,7 +159,6 @@ static int bfin_pm_finish(suspend_state_t state)
 }
 
 struct pm_ops bfin_pm_ops = {
-	.pm_disk_mode = PM_DISK_PLATFORM,
 	.prepare = bfin_pm_prepare,
 	.enter = bfin_pm_enter,
 	.finish = bfin_pm_finish,
diff --git a/arch/blackfin/mm/init.c b/arch/blackfin/mm/init.c
index 73f72ab..d6cf105 100644
--- a/arch/blackfin/mm/init.c
+++ b/arch/blackfin/mm/init.c
@@ -116,7 +116,8 @@ void paging_init(void)
 	{
 		unsigned long zones_size[MAX_NR_ZONES] = { 0, };
 
-		zones_size[ZONE_NORMAL] = (end_mem - PAGE_OFFSET) >> PAGE_SHIFT;
+		zones_size[ZONE_DMA] = (end_mem - PAGE_OFFSET) >> PAGE_SHIFT;
+		zones_size[ZONE_NORMAL] = 0;
 #ifdef CONFIG_HIGHMEM
 		zones_size[ZONE_HIGHMEM] = 0;
 #endif
diff --git a/arch/frv/kernel/vmlinux.lds.S b/arch/frv/kernel/vmlinux.lds.S
index 28eae97..481dc13 100644
--- a/arch/frv/kernel/vmlinux.lds.S
+++ b/arch/frv/kernel/vmlinux.lds.S
@@ -101,13 +101,14 @@ SECTIONS
   _stext = .;
   .text : {
 	*(
-		.text.start .text .text.*
+		.text.start .text.*
 #ifdef CONFIG_DEBUG_INFO
 	.init.text
 	.exit.text
 	.exitcall.exit
 #endif
 	)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	*(.fixup)
@@ -135,7 +136,8 @@ SECTIONS
 
   _sdata = .;
   .data : {			/* Data */
-	*(.data .data.*)
+	DATA_DATA
+	*(.data.*)
 	*(.exit.data)
 	CONSTRUCTORS
 	}
diff --git a/arch/h8300/kernel/vmlinux.lds.S b/arch/h8300/kernel/vmlinux.lds.S
index 65f1cdc..a2e72d4 100644
--- a/arch/h8300/kernel/vmlinux.lds.S
+++ b/arch/h8300/kernel/vmlinux.lds.S
@@ -75,7 +75,7 @@ SECTIONS
 	*(.int_redirect)
 #endif
 	__stext = . ;
-        	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	__etext = . ;
@@ -103,7 +103,7 @@ SECTIONS
 	. = ALIGN(0x2000) ;
 		*(.data.init_task)
 	. = ALIGN(0x4) ;
-		*(.data)
+		DATA_DATA
 	. = ALIGN(0x4) ;
 		*(.data.*)	
 
diff --git a/arch/i386/Kconfig b/arch/i386/Kconfig
index c2d54b8..8770a5d 100644
--- a/arch/i386/Kconfig
+++ b/arch/i386/Kconfig
@@ -891,7 +891,7 @@ config PHYSICAL_ALIGN
 	  Don't change this unless you know what you are doing.
 
 config HOTPLUG_CPU
-	bool "Support for hot-pluggable CPUs (EXPERIMENTAL)"
+	bool "Support for suspend on SMP and hot-pluggable CPUs (EXPERIMENTAL)"
 	depends on SMP && HOTPLUG && EXPERIMENTAL && !X86_VOYAGER
 	---help---
 	  Say Y here to experiment with turning CPUs off and on, and to
diff --git a/arch/i386/boot/setup.S b/arch/i386/boot/setup.S
index f8b3b9c..6dbcc95 100644
--- a/arch/i386/boot/setup.S
+++ b/arch/i386/boot/setup.S
@@ -310,6 +310,8 @@ loader_ok:
 	call verify_cpu
 	testl  %eax,%eax
 	jz	cpu_ok
+	movw	%cs,%ax		# aka SETUPSEG
+	movw	%ax,%ds
 	lea	cpu_panic_mess,%si
 	call	prtstr
 1:	jmp	1b
diff --git a/arch/i386/defconfig b/arch/i386/defconfig
index 9da8441..1a3a221 100644
--- a/arch/i386/defconfig
+++ b/arch/i386/defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.21-git3
-# Tue May  1 07:30:51 2007
+# Linux kernel version: 2.6.22-rc2
+# Mon May 21 13:23:44 2007
 #
 CONFIG_X86_32=y
 CONFIG_GENERIC_TIME=y
@@ -14,6 +14,7 @@ CONFIG_SEMAPHORE_SLEEPERS=y
 CONFIG_X86=y
 CONFIG_MMU=y
 CONFIG_ZONE_DMA=y
+CONFIG_QUICKLIST=y
 CONFIG_GENERIC_ISA_DMA=y
 CONFIG_GENERIC_IOMAP=y
 CONFIG_GENERIC_BUG=y
@@ -45,6 +46,7 @@ CONFIG_POSIX_MQUEUE=y
 # CONFIG_AUDIT is not set
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
 # CONFIG_CPUSETS is not set
 CONFIG_SYSFS_DEPRECATED=y
 # CONFIG_RELAY is not set
@@ -64,14 +66,19 @@ CONFIG_BUG=y
 CONFIG_ELF_CORE=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
-CONFIG_SLAB=y
 CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
 CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
-# CONFIG_SLOB is not set
 
 #
 # Loadable module support
@@ -165,7 +172,7 @@ CONFIG_X86_INTEL_USERCOPY=y
 CONFIG_X86_USE_PPRO_CHECKSUM=y
 CONFIG_X86_TSC=y
 CONFIG_X86_CMOV=y
-CONFIG_X86_MINIMUM_CPU_MODEL=4
+CONFIG_X86_MINIMUM_CPU_FAMILY=4
 CONFIG_HPET_TIMER=y
 CONFIG_HPET_EMULATE_RTC=y
 CONFIG_NR_CPUS=32
@@ -211,6 +218,7 @@ CONFIG_FLAT_NODE_MEM_MAP=y
 CONFIG_SPLIT_PTLOCK_CPUS=4
 CONFIG_RESOURCES_64BIT=y
 CONFIG_ZONE_DMA_FLAG=1
+CONFIG_NR_QUICK=1
 # CONFIG_HIGHPTE is not set
 # CONFIG_MATH_EMULATION is not set
 CONFIG_MTRR=y
@@ -237,7 +245,7 @@ CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
 CONFIG_PM=y
 CONFIG_PM_LEGACY=y
 # CONFIG_PM_DEBUG is not set
-CONFIG_PM_SYSFS_DEPRECATED=y
+# CONFIG_PM_SYSFS_DEPRECATED is not set
 
 #
 # ACPI (Advanced Configuration and Power Interface) Support
@@ -277,7 +285,7 @@ CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
 # CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
 
 #
 # CPUFreq processor drivers
@@ -315,9 +323,10 @@ CONFIG_PCI_BIOS=y
 CONFIG_PCI_DIRECT=y
 CONFIG_PCI_MMCONFIG=y
 # CONFIG_PCIEPORTBUS is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
 CONFIG_PCI_MSI=y
 # CONFIG_PCI_DEBUG is not set
-# CONFIG_HT_IRQ is not set
+CONFIG_HT_IRQ=y
 CONFIG_ISA_DMA_API=y
 # CONFIG_ISA is not set
 # CONFIG_MCA is not set
@@ -328,10 +337,6 @@ CONFIG_K8_NB=y
 # PCCARD (PCMCIA/CardBus) support
 #
 # CONFIG_PCCARD is not set
-
-#
-# PCI Hotplug Support
-#
 # CONFIG_HOTPLUG_PCI is not set
 
 #
@@ -377,7 +382,7 @@ CONFIG_IP_PNP_DHCP=y
 CONFIG_INET_TUNNEL=y
 CONFIG_INET_XFRM_MODE_TRANSPORT=y
 CONFIG_INET_XFRM_MODE_TUNNEL=y
-# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_XFRM_MODE_BEET=y
 CONFIG_INET_DIAG=y
 CONFIG_INET_TCP_DIAG=y
 # CONFIG_TCP_CONG_ADVANCED is not set
@@ -396,7 +401,7 @@ CONFIG_IPV6=y
 # CONFIG_INET6_TUNNEL is not set
 CONFIG_INET6_XFRM_MODE_TRANSPORT=y
 CONFIG_INET6_XFRM_MODE_TUNNEL=y
-# CONFIG_INET6_XFRM_MODE_BEET is not set
+CONFIG_INET6_XFRM_MODE_BEET=y
 # CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
 CONFIG_IPV6_SIT=y
 # CONFIG_IPV6_TUNNEL is not set
@@ -450,7 +455,9 @@ CONFIG_IPV6_SIT=y
 #
 # CONFIG_CFG80211 is not set
 # CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
 # CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
 
 #
 # Device Drivers
@@ -513,14 +520,12 @@ CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
 # Misc devices
 #
 # CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
 # CONFIG_SGI_IOC4 is not set
 # CONFIG_TIFM_CORE is not set
 # CONFIG_SONY_LAPTOP is not set
 # CONFIG_THINKPAD_ACPI is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
+# CONFIG_BLINK is not set
 CONFIG_IDE=y
 CONFIG_BLK_DEV_IDE=y
 
@@ -537,6 +542,7 @@ CONFIG_BLK_DEV_IDECD=y
 # CONFIG_BLK_DEV_IDESCSI is not set
 CONFIG_BLK_DEV_IDEACPI=y
 # CONFIG_IDE_TASK_IOCTL is not set
+CONFIG_IDE_PROC_FS=y
 
 #
 # IDE chipset support/bugfixes
@@ -546,6 +552,7 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPNP is not set
 CONFIG_BLK_DEV_IDEPCI=y
 # CONFIG_IDEPCI_SHARE_IRQ is not set
+CONFIG_IDEPCI_PCIBUS_ORDER=y
 # CONFIG_BLK_DEV_OFFBOARD is not set
 # CONFIG_BLK_DEV_GENERIC is not set
 # CONFIG_BLK_DEV_OPTI621 is not set
@@ -600,9 +607,8 @@ CONFIG_SCSI_NETLINK=y
 CONFIG_BLK_DEV_SD=y
 # CONFIG_CHR_DEV_ST is not set
 # CONFIG_CHR_DEV_OSST is not set
-CONFIG_BLK_DEV_SR=y
-# CONFIG_BLK_DEV_SR_VENDOR is not set
-CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
 # CONFIG_CHR_DEV_SCH is not set
 
 #
@@ -612,6 +618,7 @@ CONFIG_CHR_DEV_SG=y
 # CONFIG_SCSI_CONSTANTS is not set
 # CONFIG_SCSI_LOGGING is not set
 # CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
 
 #
 # SCSI Transports
@@ -640,7 +647,6 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 CONFIG_SCSI_AIC79XX=y
 CONFIG_AIC79XX_CMDS_PER_DEVICE=32
 CONFIG_AIC79XX_RESET_DELAY_MS=4000
-# CONFIG_AIC79XX_ENABLE_RD_STRM is not set
 # CONFIG_AIC79XX_DEBUG_ENABLE is not set
 CONFIG_AIC79XX_DEBUG_MASK=0
 # CONFIG_AIC79XX_REG_PRETTY_PRINT is not set
@@ -662,7 +668,6 @@ CONFIG_AIC79XX_DEBUG_MASK=0
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_STEX is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 # CONFIG_SCSI_QLA_FC is not set
 # CONFIG_SCSI_QLA_ISCSI is not set
@@ -673,79 +678,12 @@ CONFIG_AIC79XX_DEBUG_MASK=0
 # CONFIG_SCSI_DEBUG is not set
 # CONFIG_SCSI_ESP_CORE is not set
 # CONFIG_SCSI_SRP is not set
-
-#
-# Serial ATA (prod) and Parallel ATA (experimental) drivers
-#
-CONFIG_ATA=y
-# CONFIG_ATA_NONSTANDARD is not set
-CONFIG_SATA_AHCI=y
-CONFIG_SATA_SVW=y
-CONFIG_ATA_PIIX=y
-# CONFIG_SATA_MV is not set
-CONFIG_SATA_NV=y
-# CONFIG_PDC_ADMA is not set
-# CONFIG_SATA_QSTOR is not set
-# CONFIG_SATA_PROMISE is not set
-# CONFIG_SATA_SX4 is not set
-CONFIG_SATA_SIL=y
-# CONFIG_SATA_SIL24 is not set
-# CONFIG_SATA_SIS is not set
-# CONFIG_SATA_ULI is not set
-CONFIG_SATA_VIA=y
-# CONFIG_SATA_VITESSE is not set
-# CONFIG_SATA_INIC162X is not set
-CONFIG_SATA_ACPI=y
-# CONFIG_PATA_ALI is not set
-# CONFIG_PATA_AMD is not set
-# CONFIG_PATA_ARTOP is not set
-# CONFIG_PATA_ATIIXP is not set
-# CONFIG_PATA_CMD640_PCI is not set
-# CONFIG_PATA_CMD64X is not set
-# CONFIG_PATA_CS5520 is not set
-# CONFIG_PATA_CS5530 is not set
-# CONFIG_PATA_CS5535 is not set
-# CONFIG_PATA_CYPRESS is not set
-# CONFIG_PATA_EFAR is not set
-# CONFIG_ATA_GENERIC is not set
-# CONFIG_PATA_HPT366 is not set
-# CONFIG_PATA_HPT37X is not set
-# CONFIG_PATA_HPT3X2N is not set
-# CONFIG_PATA_HPT3X3 is not set
-# CONFIG_PATA_IT821X is not set
-# CONFIG_PATA_IT8213 is not set
-# CONFIG_PATA_JMICRON is not set
-# CONFIG_PATA_TRIFLEX is not set
-# CONFIG_PATA_MARVELL is not set
-# CONFIG_PATA_MPIIX is not set
-# CONFIG_PATA_OLDPIIX is not set
-# CONFIG_PATA_NETCELL is not set
-# CONFIG_PATA_NS87410 is not set
-# CONFIG_PATA_OPTI is not set
-# CONFIG_PATA_OPTIDMA is not set
-# CONFIG_PATA_PDC_OLD is not set
-# CONFIG_PATA_RADISYS is not set
-# CONFIG_PATA_RZ1000 is not set
-# CONFIG_PATA_SC1200 is not set
-# CONFIG_PATA_SERVERWORKS is not set
-# CONFIG_PATA_PDC2027X is not set
-# CONFIG_PATA_SIL680 is not set
-# CONFIG_PATA_SIS is not set
-# CONFIG_PATA_VIA is not set
-# CONFIG_PATA_WINBOND is not set
+# CONFIG_ATA is not set
 
 #
 # Multi-device support (RAID and LVM)
 #
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_DM=y
-# CONFIG_DM_DEBUG is not set
-# CONFIG_DM_CRYPT is not set
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
+# CONFIG_MD is not set
 
 #
 # Fusion MPT device support
@@ -760,6 +698,7 @@ CONFIG_FUSION_MAX_SGE=128
 #
 # IEEE 1394 (FireWire) support
 #
+# CONFIG_FIREWIRE is not set
 CONFIG_IEEE1394=y
 
 #
@@ -790,11 +729,7 @@ CONFIG_IEEE1394_RAWIO=y
 # I2O device support
 #
 # CONFIG_I2O is not set
-
-#
-# Macintosh device drivers
-#
-# CONFIG_MAC_EMUMOUSEBTN is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
 
 #
 # Network device support
@@ -810,10 +745,6 @@ CONFIG_NETDEVICES=y
 # ARCnet devices
 #
 # CONFIG_ARCNET is not set
-
-#
-# PHY device support
-#
 # CONFIG_PHYLIB is not set
 
 #
@@ -824,9 +755,7 @@ CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_CASSINI is not set
-CONFIG_NET_VENDOR_3COM=y
-CONFIG_VORTEX=y
-# CONFIG_TYPHOON is not set
+# CONFIG_NET_VENDOR_3COM is not set
 
 #
 # Tulip family network device support
@@ -867,10 +796,7 @@ CONFIG_8139TOO=y
 # CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
 # CONFIG_SC92031 is not set
-
-#
-# Ethernet (1000 Mbit)
-#
+CONFIG_NETDEV_1000=y
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
 CONFIG_E1000=y
@@ -890,16 +816,14 @@ CONFIG_TIGON3=y
 CONFIG_BNX2=y
 # CONFIG_QLA3XXX is not set
 # CONFIG_ATL1 is not set
-
-#
-# Ethernet (10000 Mbit)
-#
+CONFIG_NETDEV_10000=y
 # CONFIG_CHELSIO_T1 is not set
 # CONFIG_CHELSIO_T3 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 # CONFIG_MYRI10GE is not set
 # CONFIG_NETXEN_NIC is not set
+# CONFIG_MLX4_CORE is not set
 
 #
 # Token Ring devices
@@ -913,8 +837,14 @@ CONFIG_BNX2=y
 # CONFIG_WLAN_80211 is not set
 
 #
-# Wan interfaces
+# USB Network Adapters
 #
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET_MII is not set
+# CONFIG_USB_USBNET is not set
 # CONFIG_WAN is not set
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
@@ -967,9 +897,17 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_STOWAWAY is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
 # CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
 # CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
 
@@ -1019,10 +957,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 # IPMI
 #
 # CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
 # CONFIG_WATCHDOG is not set
 CONFIG_HW_RANDOM=y
 CONFIG_HW_RANDOM_INTEL=y
@@ -1031,7 +965,6 @@ CONFIG_HW_RANDOM_GEODE=y
 CONFIG_HW_RANDOM_VIA=y
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
 # CONFIG_SONYPI is not set
@@ -1056,17 +989,14 @@ CONFIG_MAX_RAW_DEVS=256
 CONFIG_HPET=y
 # CONFIG_HPET_RTC_IRQ is not set
 CONFIG_HPET_MMAP=y
-# CONFIG_HANGCHECK_TIMER is not set
+CONFIG_HANGCHECK_TIMER=y
 
 #
 # TPM devices
 #
 # CONFIG_TCG_TPM is not set
 # CONFIG_TELCLOCK is not set
-
-#
-# I2C support
-#
+CONFIG_DEVPORT=y
 # CONFIG_I2C is not set
 
 #
@@ -1079,12 +1009,7 @@ CONFIG_HPET_MMAP=y
 # Dallas's 1-wire bus
 #
 # CONFIG_W1 is not set
-
-#
-# Hardware Monitoring support
-#
 # CONFIG_HWMON is not set
-# CONFIG_HWMON_VID is not set
 
 #
 # Multifunction device drivers
@@ -1095,17 +1020,20 @@ CONFIG_HPET_MMAP=y
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-# CONFIG_DVB is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_DAB=y
 # CONFIG_USB_DABUSB is not set
 
 #
 # Graphics support
 #
 # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
 # CONFIG_FB is not set
 
 #
@@ -1114,7 +1042,7 @@ CONFIG_HPET_MMAP=y
 CONFIG_VGA_CONSOLE=y
 CONFIG_VGACON_SOFT_SCROLLBACK=y
 CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=128
-CONFIG_VIDEO_SELECT=y
+# CONFIG_VIDEO_SELECT is not set
 CONFIG_DUMMY_CONSOLE=y
 
 #
@@ -1131,14 +1059,10 @@ CONFIG_SOUND=y
 # Open Sound System
 #
 CONFIG_SOUND_PRIME=y
-CONFIG_OBSOLETE_OSS=y
-# CONFIG_SOUND_BT878 is not set
-# CONFIG_SOUND_ES1371 is not set
-CONFIG_SOUND_ICH=y
+# CONFIG_OSS_OBSOLETE is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
-# CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
 
 #
@@ -1217,37 +1141,10 @@ CONFIG_USB_STORAGE=y
 # CONFIG_USB_LIBUSUAL is not set
 
 #
-# USB Input Devices
-#
-# CONFIG_USB_AIPTEK is not set
-# CONFIG_USB_WACOM is not set
-# CONFIG_USB_ACECAD is not set
-# CONFIG_USB_KBTAB is not set
-# CONFIG_USB_POWERMATE is not set
-# CONFIG_USB_TOUCHSCREEN is not set
-# CONFIG_USB_YEALINK is not set
-# CONFIG_USB_XPAD is not set
-# CONFIG_USB_ATI_REMOTE is not set
-# CONFIG_USB_ATI_REMOTE2 is not set
-# CONFIG_USB_KEYSPAN_REMOTE is not set
-# CONFIG_USB_APPLETOUCH is not set
-# CONFIG_USB_GTCO is not set
-
-#
 # USB Imaging devices
 #
 # CONFIG_USB_MDC800 is not set
 # CONFIG_USB_MICROTEK is not set
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_USBNET_MII is not set
-# CONFIG_USB_USBNET is not set
 CONFIG_USB_MON=y
 
 #
@@ -1291,10 +1188,6 @@ CONFIG_USB_MON=y
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
-
-#
-# MMC/SD Card support
-#
 # CONFIG_MMC is not set
 
 #
@@ -1339,10 +1232,6 @@ CONFIG_USB_MON=y
 #
 
 #
-# Auxiliary Display support
-#
-
-#
 # Virtualization
 #
 # CONFIG_KVM is not set
@@ -1383,7 +1272,6 @@ CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 CONFIG_AUTOFS4_FS=y
 # CONFIG_FUSE_FS is not set
-CONFIG_GENERIC_ACL=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -1411,7 +1299,7 @@ CONFIG_PROC_KCORE=y
 CONFIG_PROC_SYSCTL=y
 CONFIG_SYSFS=y
 CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_TMPFS_POSIX_ACL is not set
 CONFIG_HUGETLBFS=y
 CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
@@ -1453,6 +1341,7 @@ CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
@@ -1529,17 +1418,16 @@ CONFIG_KPROBES=y
 #
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 # CONFIG_PRINTK_TIME is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_ENABLE_MUST_CHECK=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_UNUSED_SYMBOLS=y
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
-CONFIG_LOG_BUF_SHIFT=18
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
-CONFIG_TIMER_STATS=y
+# CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
@@ -1556,6 +1444,7 @@ CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_LIST is not set
 # CONFIG_FRAME_POINTER is not set
+# CONFIG_UNWIND_INFO is not set
 # CONFIG_FORCED_INLINING is not set
 # CONFIG_RCU_TORTURE_TEST is not set
 # CONFIG_LKDTM is not set
@@ -1586,12 +1475,14 @@ CONFIG_DOUBLEFAULT=y
 CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_PLIST=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_GENERIC_PENDING_IRQ=y
diff --git a/arch/i386/kernel/cpu/amd.c b/arch/i386/kernel/cpu/amd.c
index 4fec702..6f47eee 100644
--- a/arch/i386/kernel/cpu/amd.c
+++ b/arch/i386/kernel/cpu/amd.c
@@ -280,6 +280,10 @@ static void __cpuinit init_amd(struct cpuinfo_x86 *c)
 
 	if (c->x86 == 0x10 && !force_mwait)
 		clear_bit(X86_FEATURE_MWAIT, c->x86_capability);
+
+	/* K6s reports MCEs but don't actually have all the MSRs */
+	if (c->x86 < 6)
+		clear_bit(X86_FEATURE_MCE, c->x86_capability);
 }
 
 static unsigned int __cpuinit amd_size_cache(struct cpuinfo_x86 * c, unsigned int size)
diff --git a/arch/i386/kernel/cpu/cpufreq/speedstep-ich.c b/arch/i386/kernel/cpu/cpufreq/speedstep-ich.c
index b425cd3..698f980 100644
--- a/arch/i386/kernel/cpu/cpufreq/speedstep-ich.c
+++ b/arch/i386/kernel/cpu/cpufreq/speedstep-ich.c
@@ -24,6 +24,7 @@
 #include <linux/cpufreq.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 
 #include "speedstep-lib.h"
 
diff --git a/arch/i386/kernel/cpu/cyrix.c b/arch/i386/kernel/cpu/cyrix.c
index 0b8411a..e88d2fb 100644
--- a/arch/i386/kernel/cpu/cyrix.c
+++ b/arch/i386/kernel/cpu/cyrix.c
@@ -7,6 +7,7 @@
 #include <asm/processor.h>
 #include <asm/timer.h>
 #include <asm/pci-direct.h>
+#include <asm/tsc.h>
 
 #include "cpu.h"
 
diff --git a/arch/i386/kernel/cpu/mcheck/k7.c b/arch/i386/kernel/cpu/mcheck/k7.c
index f9fa414..eef63e3 100644
--- a/arch/i386/kernel/cpu/mcheck/k7.c
+++ b/arch/i386/kernel/cpu/mcheck/k7.c
@@ -72,12 +72,12 @@ void amd_mcheck_init(struct cpuinfo_x86 *c)
 	u32 l, h;
 	int i;
 
-	machine_check_vector = k7_machine_check;
-	wmb();
-
 	if (!cpu_has(c, X86_FEATURE_MCE))
 		return;
 
+	machine_check_vector = k7_machine_check;
+	wmb();
+
 	printk (KERN_INFO "Intel machine check architecture supported.\n");
 	rdmsr (MSR_IA32_MCG_CAP, l, h);
 	if (l & (1<<8))	/* Control register present ? */
diff --git a/arch/i386/kernel/cpu/mtrr/cyrix.c b/arch/i386/kernel/cpu/mtrr/cyrix.c
index 0737a59..9edf562 100644
--- a/arch/i386/kernel/cpu/mtrr/cyrix.c
+++ b/arch/i386/kernel/cpu/mtrr/cyrix.c
@@ -136,7 +136,7 @@ static void prepare_set(void)
 	/*  Save value of CR4 and clear Page Global Enable (bit 7)  */
 	if ( cpu_has_pge ) {
 		cr4 = read_cr4();
-		write_cr4(cr4 & (unsigned char) ~(1 << 7));
+		write_cr4(cr4 & ~X86_CR4_PGE);
 	}
 
 	/*  Disable and flush caches. Note that wbinvd flushes the TLBs as
diff --git a/arch/i386/kernel/cpu/mtrr/state.c b/arch/i386/kernel/cpu/mtrr/state.c
index f62ecd1..7b39a2f 100644
--- a/arch/i386/kernel/cpu/mtrr/state.c
+++ b/arch/i386/kernel/cpu/mtrr/state.c
@@ -19,7 +19,7 @@ void set_mtrr_prepare_save(struct set_mtrr_context *ctxt)
 		/*  Save value of CR4 and clear Page Global Enable (bit 7)  */
 		if ( cpu_has_pge ) {
 			ctxt->cr4val = read_cr4();
-			write_cr4(ctxt->cr4val & (unsigned char) ~(1 << 7));
+			write_cr4(ctxt->cr4val & ~X86_CR4_PGE);
 		}
 
 		/*  Disable and flush caches. Note that wbinvd flushes the TLBs as
diff --git a/arch/i386/kernel/verify_cpu.S b/arch/i386/kernel/verify_cpu.S
index b2a9d80..f1d1eac 100644
--- a/arch/i386/kernel/verify_cpu.S
+++ b/arch/i386/kernel/verify_cpu.S
@@ -2,6 +2,7 @@
    This runs in 16bit mode so that the caller can still use the BIOS
    to output errors on the screen */
 #include <asm/cpufeature.h>
+#include <asm/msr.h>
 
 verify_cpu:
 	pushfl				# Save caller passed flags
@@ -45,6 +46,32 @@ verify_cpu:
 	cmpl	$0x1,%eax
 	jb	bad			# no cpuid 1
 
+#if REQUIRED_MASK1 & NEED_CMPXCHG64
+	/* Some VIA C3s need magic MSRs to enable CX64. Do this here */
+	cmpl	$0x746e6543,%ebx	# Cent
+	jne	1f
+	cmpl 	$0x48727561,%edx	# aurH
+	jne	1f
+	cmpl	$0x736c7561,%ecx	# auls
+	jne	1f
+	movl	$1,%eax			# check model
+	cpuid
+	movl	%eax,%ebx
+	shr	$8,%ebx
+	andl	$0xf,%ebx
+	cmp	$6,%ebx			# check family == 6
+	jne	1f
+	shr	$4,%eax
+	andl	$0xf,%eax
+	cmpl	$6,%eax			# check model >= 6
+	jb	1f
+	# assume models >= 6 all support this MSR
+	movl	$MSR_VIA_FCR,%ecx
+	rdmsr
+	orl	$((1<<1)|(1<<7)),%eax	# enable CMPXCHG64 and PGE
+	wrmsr
+1:
+#endif
 	movl    $0x1,%eax		# Does the cpu have what it takes
 	cpuid
 
diff --git a/arch/i386/kernel/vmlinux.lds.S b/arch/i386/kernel/vmlinux.lds.S
index 80bec66..aa87b06 100644
--- a/arch/i386/kernel/vmlinux.lds.S
+++ b/arch/i386/kernel/vmlinux.lds.S
@@ -44,7 +44,7 @@ SECTIONS
 
   /* read-only */
   .text : AT(ADDR(.text) - LOAD_OFFSET) {
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	KPROBES_TEXT
@@ -74,7 +74,7 @@ SECTIONS
   /* writeable */
   . = ALIGN(4096);
   .data : AT(ADDR(.data) - LOAD_OFFSET) {	/* Data */
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	} :data
 
diff --git a/arch/i386/mach-generic/bigsmp.c b/arch/i386/mach-generic/bigsmp.c
index e932d34..58a477b 100644
--- a/arch/i386/mach-generic/bigsmp.c
+++ b/arch/i386/mach-generic/bigsmp.c
@@ -21,7 +21,7 @@
 
 static int dmi_bigsmp; /* can be set by dmi scanners */
 
-static __init int hp_ht_bigsmp(struct dmi_system_id *d)
+static int hp_ht_bigsmp(struct dmi_system_id *d)
 {
 #ifdef CONFIG_X86_GENERICARCH
 	printk(KERN_NOTICE "%s detected: force use of apic=bigsmp\n", d->ident);
@@ -31,7 +31,7 @@ static __init int hp_ht_bigsmp(struct dmi_system_id *d)
 }
 
 
-static struct dmi_system_id __initdata bigsmp_dmi_table[] = {
+static struct dmi_system_id bigsmp_dmi_table[] = {
 	{ hp_ht_bigsmp, "HP ProLiant DL760 G2", {
 		DMI_MATCH(DMI_BIOS_VENDOR, "HP"),
 		DMI_MATCH(DMI_BIOS_VERSION, "P44-"),
@@ -45,7 +45,7 @@ static struct dmi_system_id __initdata bigsmp_dmi_table[] = {
 };
 
 
-static int __init probe_bigsmp(void)
+static int probe_bigsmp(void)
 { 
 	if (def_to_bigsmp)
         	dmi_bigsmp = 1;
diff --git a/arch/i386/mm/mmap.c b/arch/i386/mm/mmap.c
index e4730a1..552e084 100644
--- a/arch/i386/mm/mmap.c
+++ b/arch/i386/mm/mmap.c
@@ -27,6 +27,7 @@
 #include <linux/personality.h>
 #include <linux/mm.h>
 #include <linux/random.h>
+#include <linux/sched.h>
 
 /*
  * Top of mmap area (just below the process stack).
diff --git a/arch/i386/oprofile/nmi_int.c b/arch/i386/oprofile/nmi_int.c
index 8e18520..a7c0783 100644
--- a/arch/i386/oprofile/nmi_int.c
+++ b/arch/i386/oprofile/nmi_int.c
@@ -131,7 +131,6 @@ static void nmi_save_registers(void * dummy)
 {
 	int cpu = smp_processor_id();
 	struct op_msrs * msrs = &cpu_msrs[cpu];
-	model->fill_in_addresses(msrs);
 	nmi_cpu_save_registers(msrs);
 }
 
@@ -195,6 +194,7 @@ static struct notifier_block profile_exceptions_nb = {
 static int nmi_setup(void)
 {
 	int err=0;
+	int cpu;
 
 	if (!allocate_msrs())
 		return -ENOMEM;
@@ -207,6 +207,13 @@ static int nmi_setup(void)
 	/* We need to serialize save and setup for HT because the subset
 	 * of msrs are distinct for save and setup operations
 	 */
+
+	/* Assume saved/restored counters are the same on all CPUs */
+	model->fill_in_addresses(&cpu_msrs[0]);
+	for_each_possible_cpu (cpu) {
+		if (cpu != 0)
+			cpu_msrs[cpu] = cpu_msrs[0];
+	}
 	on_each_cpu(nmi_save_registers, NULL, 0, 1);
 	on_each_cpu(nmi_cpu_setup, NULL, 0, 1);
 	nmi_enabled = 1;
diff --git a/arch/ia64/kernel/acpi-processor.c b/arch/ia64/kernel/acpi-processor.c
index 4d4993a..5a216c0 100644
--- a/arch/ia64/kernel/acpi-processor.c
+++ b/arch/ia64/kernel/acpi-processor.c
@@ -44,7 +44,7 @@ static void init_intel_pdc(struct acpi_processor *pr)
 
 	buf[0] = ACPI_PDC_REVISION_ID;
 	buf[1] = 1;
-	buf[2] |= ACPI_PDC_EST_CAPABILITY_SMP;
+	buf[2] = ACPI_PDC_EST_CAPABILITY_SMP;
 
 	obj->type = ACPI_TYPE_BUFFER;
 	obj->buffer.length = 12;
diff --git a/arch/ia64/kernel/acpi.c b/arch/ia64/kernel/acpi.c
index c478449..103dd8e 100644
--- a/arch/ia64/kernel/acpi.c
+++ b/arch/ia64/kernel/acpi.c
@@ -67,7 +67,8 @@ EXPORT_SYMBOL(pm_power_off);
 unsigned int acpi_cpei_override;
 unsigned int acpi_cpei_phys_cpuid;
 
-const char *acpi_get_sysname(void)
+const char __init *
+acpi_get_sysname(void)
 {
 #ifdef CONFIG_IA64_GENERIC
 	unsigned long rsdp_phys;
diff --git a/arch/ia64/kernel/process.c b/arch/ia64/kernel/process.c
index d1c3ed9..af73b8d 100644
--- a/arch/ia64/kernel/process.c
+++ b/arch/ia64/kernel/process.c
@@ -763,6 +763,9 @@ get_wchan (struct task_struct *p)
 	unsigned long ip;
 	int count = 0;
 
+	if (!p || p == current || p->state == TASK_RUNNING)
+		return 0;
+
 	/*
 	 * Note: p may not be a blocked task (it could be current or
 	 * another process running on some other CPU.  Rather than
@@ -773,6 +776,8 @@ get_wchan (struct task_struct *p)
 	 */
 	unw_init_from_blocked_task(&info, p);
 	do {
+		if (p->state == TASK_RUNNING)
+			return 0;
 		if (unw_unwind(&info) < 0)
 			return 0;
 		unw_get_ip(&info, &ip);
diff --git a/arch/ia64/kernel/smpboot.c b/arch/ia64/kernel/smpboot.c
index 5429580..3c9d8e6 100644
--- a/arch/ia64/kernel/smpboot.c
+++ b/arch/ia64/kernel/smpboot.c
@@ -370,7 +370,7 @@ smp_setup_percpu_timer (void)
 {
 }
 
-static void __devinit
+static void __cpuinit
 smp_callin (void)
 {
 	int cpuid, phys_id, itc_master;
@@ -456,7 +456,7 @@ smp_callin (void)
 /*
  * Activate a secondary processor.  head.S calls this.
  */
-int __devinit
+int __cpuinit
 start_secondary (void *unused)
 {
 	/* Early console may use I/O ports */
diff --git a/arch/ia64/kernel/unwind.c b/arch/ia64/kernel/unwind.c
index 7d3dd6c..b0b08b5 100644
--- a/arch/ia64/kernel/unwind.c
+++ b/arch/ia64/kernel/unwind.c
@@ -1860,7 +1860,7 @@ int
 unw_unwind (struct unw_frame_info *info)
 {
 	unsigned long prev_ip, prev_sp, prev_bsp;
-	unsigned long ip, pr, num_regs;
+	unsigned long ip, pr, num_regs, rp_loc, pfs_loc;
 	STAT(unsigned long start, flags;)
 	int retval;
 
@@ -1870,14 +1870,16 @@ unw_unwind (struct unw_frame_info *info)
 	prev_sp = info->sp;
 	prev_bsp = info->bsp;
 
-	/* restore the ip */
-	if (!info->rp_loc) {
+	/* validate the return IP pointer */
+	rp_loc = (unsigned long) info->rp_loc;
+	if ((rp_loc < info->regstk.limit) || (rp_loc > info->regstk.top)) {
 		/* FIXME: should really be level 0 but it occurs too often. KAO */
 		UNW_DPRINT(1, "unwind.%s: failed to locate return link (ip=0x%lx)!\n",
 			   __FUNCTION__, info->ip);
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
+	/* restore the ip */
 	ip = info->ip = *info->rp_loc;
 	if (ip < GATE_ADDR) {
 		UNW_DPRINT(2, "unwind.%s: reached user-space (ip=0x%lx)\n", __FUNCTION__, ip);
@@ -1885,12 +1887,14 @@ unw_unwind (struct unw_frame_info *info)
 		return -1;
 	}
 
-	/* restore the cfm: */
-	if (!info->pfs_loc) {
+	/* validate the previous stack frame pointer */
+	pfs_loc = (unsigned long) info->pfs_loc;
+	if ((pfs_loc < info->regstk.limit) || (pfs_loc > info->regstk.top)) {
 		UNW_DPRINT(0, "unwind.%s: failed to locate ar.pfs!\n", __FUNCTION__);
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
+	/* restore the cfm: */
 	info->cfm_loc = info->pfs_loc;
 
 	/* restore the bsp: */
@@ -1992,13 +1996,16 @@ init_frame_info (struct unw_frame_info *info, struct task_struct *t,
 	memset(info, 0, sizeof(*info));
 
 	rbslimit = (unsigned long) t + IA64_RBS_OFFSET;
+	stklimit = (unsigned long) t + IA64_STK_OFFSET;
+
 	rbstop   = sw->ar_bspstore;
-	if (rbstop - (unsigned long) t >= IA64_STK_OFFSET)
+	if (rbstop > stklimit || rbstop < rbslimit)
 		rbstop = rbslimit;
 
-	stklimit = (unsigned long) t + IA64_STK_OFFSET;
 	if (stktop <= rbstop)
 		stktop = rbstop;
+	if (stktop > stklimit)
+		stktop = stklimit;
 
 	info->regstk.limit = rbslimit;
 	info->regstk.top   = rbstop;
diff --git a/arch/ia64/kernel/vmlinux.lds.S b/arch/ia64/kernel/vmlinux.lds.S
index 6923826..5a65965 100644
--- a/arch/ia64/kernel/vmlinux.lds.S
+++ b/arch/ia64/kernel/vmlinux.lds.S
@@ -44,7 +44,7 @@ SECTIONS
   .text : AT(ADDR(.text) - LOAD_OFFSET)
     {
 	IVT_TEXT
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	KPROBES_TEXT
@@ -214,7 +214,12 @@ SECTIONS
 
   data : { } :data
   .data : AT(ADDR(.data) - LOAD_OFFSET)
-	{ *(.data) *(.data1) *(.gnu.linkonce.d*) CONSTRUCTORS }
+	{
+		DATA_DATA
+		*(.data1)
+		*(.gnu.linkonce.d*)
+		CONSTRUCTORS
+	}
 
   . = ALIGN(16);	/* gp must be 16-byte aligned for exc. table */
   .got : AT(ADDR(.got) - LOAD_OFFSET)
diff --git a/arch/ia64/pci/pci.c b/arch/ia64/pci/pci.c
index 3549f3b..73696b4 100644
--- a/arch/ia64/pci/pci.c
+++ b/arch/ia64/pci/pci.c
@@ -354,10 +354,13 @@ pci_acpi_scan_root(struct acpi_device *device, int domain, int bus)
 
 	acpi_walk_resources(device->handle, METHOD_NAME__CRS, count_window,
 			&windows);
-	controller->window = kmalloc_node(sizeof(*controller->window) * windows,
-			GFP_KERNEL, controller->node);
-	if (!controller->window)
-		goto out2;
+	if (windows) {
+		controller->window =
+			kmalloc_node(sizeof(*controller->window) * windows,
+				     GFP_KERNEL, controller->node);
+		if (!controller->window)
+			goto out2;
+	}
 
 	name = kmalloc(16, GFP_KERNEL);
 	if (!name)
diff --git a/arch/ia64/sn/kernel/setup.c b/arch/ia64/sn/kernel/setup.c
index a574fcd..684b1c9 100644
--- a/arch/ia64/sn/kernel/setup.c
+++ b/arch/ia64/sn/kernel/setup.c
@@ -194,7 +194,7 @@ void __init early_sn_setup(void)
 }
 
 extern int platform_intr_list[];
-static int __initdata shub_1_1_found;
+static int __cpuinitdata shub_1_1_found;
 
 /*
  * sn_check_for_wars
diff --git a/arch/m32r/kernel/vmlinux.lds.S b/arch/m32r/kernel/vmlinux.lds.S
index 6c73bca..4e2d5b9 100644
--- a/arch/m32r/kernel/vmlinux.lds.S
+++ b/arch/m32r/kernel/vmlinux.lds.S
@@ -27,7 +27,7 @@ SECTIONS
   _text = .;			/* Text and read-only data */
   .boot : { *(.boot) } = 0
   .text : {
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	*(.fixup)
@@ -50,7 +50,7 @@ SECTIONS
   .data : {			/* Data */
 	*(.spu)
 	*(.spi)
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	}
 
diff --git a/arch/m68k/kernel/vmlinux-std.lds b/arch/m68k/kernel/vmlinux-std.lds
index 437b4f8..78f1392 100644
--- a/arch/m68k/kernel/vmlinux-std.lds
+++ b/arch/m68k/kernel/vmlinux-std.lds
@@ -11,7 +11,7 @@ SECTIONS
   . = 0x1000;
   _text = .;			/* Text and read-only data */
   .text : {
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	*(.fixup)
@@ -28,7 +28,7 @@ SECTIONS
   _etext = .;			/* End of text section */
 
   .data : {			/* Data */
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	}
 
diff --git a/arch/m68k/kernel/vmlinux-sun3.lds b/arch/m68k/kernel/vmlinux-sun3.lds
index 2868e20..c8999b2 100644
--- a/arch/m68k/kernel/vmlinux-sun3.lds
+++ b/arch/m68k/kernel/vmlinux-sun3.lds
@@ -12,7 +12,7 @@ SECTIONS
   _text = .;			/* Text and read-only data */
   .text : {
 	*(.head)
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	*(.fixup)
@@ -23,7 +23,7 @@ SECTIONS
   _etext = .;			/* End of text section */
 
   .data : {			/* Data */
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	. = ALIGN(16);		/* Exception table */
 	__start___ex_table = .;
diff --git a/arch/m68knommu/kernel/vmlinux.lds.S b/arch/m68knommu/kernel/vmlinux.lds.S
index c86a1bf..07a0055 100644
--- a/arch/m68knommu/kernel/vmlinux.lds.S
+++ b/arch/m68knommu/kernel/vmlinux.lds.S
@@ -62,7 +62,7 @@ SECTIONS {
 	.text : {
 		_text = .;
 		_stext = . ;
-        	*(.text)
+		TEXT_TEXT
 		SCHED_TEXT
         	*(.text.lock)
 
@@ -133,7 +133,7 @@ SECTIONS {
 	.data DATA_ADDR : {
 		. = ALIGN(4);
 		_sdata = . ;
-		*(.data)
+		DATA_DATA
 		. = ALIGN(8192) ;
 		*(.data.init_task)
 		_edata = . ;
diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index a7d49ae..18c4a3c 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -76,7 +76,7 @@
 #include <linux/module.h>
 #include <linux/signal.h>
 #include <linux/smp.h>
-
+#include <linux/sched.h>
 #include <asm/asm.h>
 #include <asm/branch.h>
 #include <asm/byteorder.h>
diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S
index 043f637..9b9992c 100644
--- a/arch/mips/kernel/vmlinux.lds.S
+++ b/arch/mips/kernel/vmlinux.lds.S
@@ -27,7 +27,7 @@ SECTIONS
   /* read-only */
   _text = .;			/* Text and read-only data */
   .text : {
-    *(.text)
+    TEXT_TEXT
     SCHED_TEXT
     LOCK_TEXT
     *(.fixup)
@@ -62,7 +62,7 @@ SECTIONS
     . = ALIGN(_PAGE_SIZE);
     *(.data.init_task)
 
-    *(.data)
+    DATA_DATA
 
     CONSTRUCTORS
   }
diff --git a/arch/mips/mm/ioremap.c b/arch/mips/mm/ioremap.c
index cea7d0e..59945b9 100644
--- a/arch/mips/mm/ioremap.c
+++ b/arch/mips/mm/ioremap.c
@@ -9,7 +9,7 @@
 #include <linux/module.h>
 #include <asm/addrspace.h>
 #include <asm/byteorder.h>
-
+#include <linux/sched.h>
 #include <linux/vmalloc.h>
 #include <asm/cacheflush.h>
 #include <asm/io.h>
diff --git a/arch/mips/sgi-ip32/Makefile b/arch/mips/sgi-ip32/Makefile
index 7e14167..60f0227 100644
--- a/arch/mips/sgi-ip32/Makefile
+++ b/arch/mips/sgi-ip32/Makefile
@@ -3,5 +3,5 @@
 # under Linux.
 #
 
-obj-y	+= ip32-berr.o ip32-irq.o ip32-setup.o ip32-reset.o \
+obj-y	+= ip32-berr.o ip32-irq.o ip32-platform.o ip32-setup.o ip32-reset.o \
 	   crime.o ip32-memory.o
diff --git a/arch/mips/sgi-ip32/ip32-platform.c b/arch/mips/sgi-ip32/ip32-platform.c
new file mode 100644
index 0000000..120b159
--- /dev/null
+++ b/arch/mips/sgi-ip32/ip32-platform.c
@@ -0,0 +1,20 @@
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+static __init int meth_devinit(void)
+{
+	struct platform_device *pd;
+	int ret;
+
+	pd = platform_device_alloc("meth", -1);
+	if (!pd)
+		return -ENOMEM;
+
+	ret = platform_device_add(pd);
+	if (ret)
+		platform_device_put(pd);
+
+	return ret;
+}
+
+device_initcall(meth_devinit);
diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c
index 0dc924c..395bbce 100644
--- a/arch/parisc/kernel/cache.c
+++ b/arch/parisc/kernel/cache.c
@@ -18,7 +18,7 @@
 #include <linux/module.h>
 #include <linux/seq_file.h>
 #include <linux/pagemap.h>
-
+#include <linux/sched.h>
 #include <asm/pdc.h>
 #include <asm/cache.h>
 #include <asm/cacheflush.h>
diff --git a/arch/parisc/kernel/processor.c b/arch/parisc/kernel/processor.c
index dd5d0cb..566226d 100644
--- a/arch/parisc/kernel/processor.c
+++ b/arch/parisc/kernel/processor.c
@@ -33,7 +33,7 @@
 #include <linux/seq_file.h>
 #include <linux/slab.h>
 #include <linux/cpu.h>
-
+#include <asm/param.h>
 #include <asm/cache.h>
 #include <asm/hardware.h>	/* for register_parisc_driver() stuff */
 #include <asm/processor.h>
diff --git a/arch/parisc/kernel/vmlinux.lds.S b/arch/parisc/kernel/vmlinux.lds.S
index c745859..4d96ba4 100644
--- a/arch/parisc/kernel/vmlinux.lds.S
+++ b/arch/parisc/kernel/vmlinux.lds.S
@@ -51,7 +51,7 @@ SECTIONS
 
   _text = .;			/* Text and read-only data */
   .text ALIGN(16) : {
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	*(.text.do_softirq)
@@ -91,7 +91,7 @@ SECTIONS
 
   . = ALIGN(L1_CACHE_BYTES);
   .data : {			/* Data */
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	}
 
diff --git a/arch/powerpc/kernel/cputable.c b/arch/powerpc/kernel/cputable.c
index 6ef87fb..b2b5d66 100644
--- a/arch/powerpc/kernel/cputable.c
+++ b/arch/powerpc/kernel/cputable.c
@@ -235,6 +235,7 @@ static struct cpu_spec cpu_specs[] = {
 		.icache_bsize		= 128,
 		.dcache_bsize		= 128,
 		.num_pmcs		= 8,
+		.pmc_type		= PPC_PMC_IBM,
 		.cpu_setup		= __setup_cpu_ppc970,
 		.cpu_restore		= __restore_cpu_ppc970,
 		.oprofile_cpu_type	= "ppc64/970MP",
@@ -251,6 +252,7 @@ static struct cpu_spec cpu_specs[] = {
 		.icache_bsize		= 128,
 		.dcache_bsize		= 128,
 		.num_pmcs		= 8,
+		.pmc_type		= PPC_PMC_IBM,
 		.cpu_setup		= __setup_cpu_ppc970MP,
 		.cpu_restore		= __restore_cpu_ppc970,
 		.oprofile_cpu_type	= "ppc64/970MP",
@@ -317,6 +319,7 @@ static struct cpu_spec cpu_specs[] = {
 		.icache_bsize		= 128,
 		.dcache_bsize		= 128,
 		.num_pmcs		= 6,
+		.pmc_type		= PPC_PMC_IBM,
 		.oprofile_cpu_type	= "ppc64/power6",
 		.oprofile_type		= PPC_OPROFILE_POWER4,
 		.oprofile_mmcra_sihv	= POWER6_MMCRA_SIHV,
@@ -335,6 +338,7 @@ static struct cpu_spec cpu_specs[] = {
 		.icache_bsize		= 128,
 		.dcache_bsize		= 128,
 		.num_pmcs		= 6,
+		.pmc_type		= PPC_PMC_IBM,
 		.oprofile_cpu_type	= "ppc64/power6",
 		.oprofile_type		= PPC_OPROFILE_POWER4,
 		.oprofile_mmcra_sihv	= POWER6_MMCRA_SIHV,
diff --git a/arch/powerpc/kernel/pmc.c b/arch/powerpc/kernel/pmc.c
index 24d7b7c..ea04e0a 100644
--- a/arch/powerpc/kernel/pmc.c
+++ b/arch/powerpc/kernel/pmc.c
@@ -20,8 +20,8 @@
 #include <asm/cputable.h>
 #include <asm/pmc.h>
 
-#ifndef MMCR0_PMA0
-#define MMCR0_PMA0	0
+#ifndef MMCR0_PMAO
+#define MMCR0_PMAO	0
 #endif
 
 static void dummy_perf(struct pt_regs *regs)
@@ -30,7 +30,7 @@ static void dummy_perf(struct pt_regs *regs)
 	mtpmr(PMRN_PMGC0, mfpmr(PMRN_PMGC0) & ~PMGC0_PMIE);
 #elif defined(CONFIG_PPC64) || defined(CONFIG_6xx)
 	if (cur_cpu_spec->pmc_type == PPC_PMC_IBM)
-		mtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~(MMCR0_PMXE|MMCR0_PMA0));
+		mtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~(MMCR0_PMXE|MMCR0_PMAO));
 #else
 	mtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~MMCR0_PMXE);
 #endif
diff --git a/arch/powerpc/kernel/smp.c b/arch/powerpc/kernel/smp.c
index 22f1ef1..d577b71 100644
--- a/arch/powerpc/kernel/smp.c
+++ b/arch/powerpc/kernel/smp.c
@@ -201,13 +201,6 @@ int smp_call_function_map(void (*func) (void *info), void *info, int nonatomic,
 	/* Can deadlock when called with interrupts disabled */
 	WARN_ON(irqs_disabled());
 
-	/* remove 'self' from the map */
-	if (cpu_isset(smp_processor_id(), map))
-		cpu_clear(smp_processor_id(), map);
-
-	/* sanity check the map, remove any non-online processors. */
-	cpus_and(map, map, cpu_online_map);
-
 	if (unlikely(smp_ops == NULL))
 		return ret;
 
@@ -222,10 +215,17 @@ int smp_call_function_map(void (*func) (void *info), void *info, int nonatomic,
 	/* Must grab online cpu count with preempt disabled, otherwise
 	 * it can change. */
 	num_cpus = num_online_cpus() - 1;
-	if (!num_cpus || cpus_empty(map)) {
-		ret = 0;
-		goto out;
-	}
+	if (!num_cpus)
+		goto done;
+
+	/* remove 'self' from the map */
+	if (cpu_isset(smp_processor_id(), map))
+		cpu_clear(smp_processor_id(), map);
+
+	/* sanity check the map, remove any non-online processors. */
+	cpus_and(map, map, cpu_online_map);
+	if (cpus_empty(map))
+		goto done;
 
 	call_data = &data;
 	smp_wmb();
@@ -263,6 +263,7 @@ int smp_call_function_map(void (*func) (void *info), void *info, int nonatomic,
 		}
 	}
 
+ done:
 	ret = 0;
 
  out:
@@ -282,16 +283,17 @@ EXPORT_SYMBOL(smp_call_function);
 int smp_call_function_single(int cpu, void (*func) (void *info), void *info, int nonatomic,
 			int wait)
 {
-	cpumask_t map=CPU_MASK_NONE;
+	cpumask_t map = CPU_MASK_NONE;
+	int ret = -EBUSY;
 
 	if (!cpu_online(cpu))
 		return -EINVAL;
 
-	if (cpu == smp_processor_id())
-		return -EBUSY;
-
 	cpu_set(cpu, map);
-	return smp_call_function_map(func,info,nonatomic,wait,map);
+	if (cpu != get_cpu())
+		ret = smp_call_function_map(func,info,nonatomic,wait,map);
+	put_cpu();
+	return ret;
 }
 EXPORT_SYMBOL(smp_call_function_single);
 
diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
index 1320673..21c39ff 100644
--- a/arch/powerpc/kernel/vmlinux.lds.S
+++ b/arch/powerpc/kernel/vmlinux.lds.S
@@ -34,7 +34,7 @@ SECTIONS
 	/* Text and gots */
 	.text : {
 		_text = .;
-		*(.text .text.*)
+		TEXT_TEXT
 		SCHED_TEXT
 		LOCK_TEXT
 		KPROBES_TEXT
@@ -167,7 +167,7 @@ SECTIONS
 #ifdef CONFIG_PPC32
 	.data    :
 	{
-		*(.data)
+		DATA_DATA
 		*(.sdata)
 		*(.got.plt) *(.got)
 	}
diff --git a/arch/powerpc/mm/mem.c b/arch/powerpc/mm/mem.c
index 246eeea..0266a94 100644
--- a/arch/powerpc/mm/mem.c
+++ b/arch/powerpc/mm/mem.c
@@ -310,11 +310,12 @@ void __init paging_init(void)
 
 #ifdef CONFIG_HIGHMEM
 	map_page(PKMAP_BASE, 0, 0);	/* XXX gross */
-	pkmap_page_table = pte_offset_kernel(pmd_offset(pgd_offset_k
-			(PKMAP_BASE), PKMAP_BASE), PKMAP_BASE);
+	pkmap_page_table = pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k
+			(PKMAP_BASE), PKMAP_BASE), PKMAP_BASE), PKMAP_BASE);
 	map_page(KMAP_FIX_BEGIN, 0, 0);	/* XXX gross */
-	kmap_pte = pte_offset_kernel(pmd_offset(pgd_offset_k
-			(KMAP_FIX_BEGIN), KMAP_FIX_BEGIN), KMAP_FIX_BEGIN);
+	kmap_pte = pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k
+			(KMAP_FIX_BEGIN), KMAP_FIX_BEGIN), KMAP_FIX_BEGIN),
+			 KMAP_FIX_BEGIN);
 	kmap_prot = PAGE_KERNEL;
 #endif /* CONFIG_HIGHMEM */
 
diff --git a/arch/powerpc/mm/mmap.c b/arch/powerpc/mm/mmap.c
index 972a8e8..86010fc 100644
--- a/arch/powerpc/mm/mmap.c
+++ b/arch/powerpc/mm/mmap.c
@@ -24,6 +24,7 @@
 
 #include <linux/personality.h>
 #include <linux/mm.h>
+#include <linux/sched.h>
 
 /*
  * Top of mmap area (just below the process stack).
diff --git a/arch/ppc/kernel/vmlinux.lds.S b/arch/ppc/kernel/vmlinux.lds.S
index 44cd128..19db874 100644
--- a/arch/ppc/kernel/vmlinux.lds.S
+++ b/arch/ppc/kernel/vmlinux.lds.S
@@ -32,7 +32,7 @@ SECTIONS
   .text      :
   {
     _text = .;
-    *(.text)
+    TEXT_TEXT
     SCHED_TEXT
     LOCK_TEXT
     *(.fixup)
@@ -67,7 +67,7 @@ SECTIONS
   . = ALIGN(4096);
   .data    :
   {
-    *(.data)
+    DATA_DATA
     *(.data1)
     *(.sdata)
     *(.sdata2)
diff --git a/arch/s390/kernel/compat_wrapper.S b/arch/s390/kernel/compat_wrapper.S
index 32a69a1..acc4154 100644
--- a/arch/s390/kernel/compat_wrapper.S
+++ b/arch/s390/kernel/compat_wrapper.S
@@ -1682,3 +1682,31 @@ compat_sys_utimes_wrapper:
 	llgtr	%r2,%r2			# char *
 	llgtr	%r3,%r3			# struct compat_timeval *
 	jg	compat_sys_utimes
+
+	.globl	compat_sys_utimensat_wrapper
+compat_sys_utimensat_wrapper:
+	llgfr	%r2,%r2			# unsigned int
+	llgtr	%r3,%r3			# char *
+	llgtr	%r4,%r4			# struct compat_timespec *
+	lgfr	%r5,%r5			# int
+	jg	compat_sys_utimensat
+
+	.globl	compat_sys_signalfd_wrapper
+compat_sys_signalfd_wrapper:
+	lgfr	%r2,%r2			# int
+	llgtr	%r3,%r3			# compat_sigset_t *
+	llgfr	%r4,%r4			# compat_size_t
+	jg	compat_sys_signalfd
+
+	.globl	compat_sys_timerfd_wrapper
+compat_sys_timerfd_wrapper:
+	lgfr	%r2,%r2			# int
+	lgfr	%r3,%r3			# int
+	lgfr	%r4,%r4			# int
+	llgtr	%r5,%r5			# struct compat_itimerspec *
+	jg	compat_sys_timerfd
+
+	.globl	sys_eventfd_wrapper
+sys_eventfd_wrapper:
+	llgfr	%r2,%r2			# unsigned int
+	jg	sys_eventfd
diff --git a/arch/s390/kernel/kprobes.c b/arch/s390/kernel/kprobes.c
index e39333a..358d2bb 100644
--- a/arch/s390/kernel/kprobes.c
+++ b/arch/s390/kernel/kprobes.c
@@ -413,7 +413,7 @@ static int __kprobes trampoline_probe_handler(struct kprobe *p,
 			break;
 		}
 	}
-	BUG_ON(!orig_ret_address || (orig_ret_address == trampoline_address));
+	kretprobe_assert(ri, orig_ret_address, trampoline_address);
 	regs->psw.addr = orig_ret_address | PSW_ADDR_AMODE;
 
 	reset_current_kprobe();
diff --git a/arch/s390/kernel/syscalls.S b/arch/s390/kernel/syscalls.S
index cd8d321..738feb4 100644
--- a/arch/s390/kernel/syscalls.S
+++ b/arch/s390/kernel/syscalls.S
@@ -322,3 +322,8 @@ NI_SYSCALL							/* 310 sys_move_pages */
 SYSCALL(sys_getcpu,sys_getcpu,sys_getcpu_wrapper)
 SYSCALL(sys_epoll_pwait,sys_epoll_pwait,compat_sys_epoll_pwait_wrapper)
 SYSCALL(sys_utimes,sys_utimes,compat_sys_utimes_wrapper)
+NI_SYSCALL							/* 314 sys_fallocate */
+SYSCALL(sys_utimensat,sys_utimensat,compat_sys_utimensat_wrapper)	/* 315 */
+SYSCALL(sys_signalfd,sys_signalfd,compat_sys_signalfd_wrapper)
+SYSCALL(sys_timerfd,sys_timerfd,compat_sys_timerfd_wrapper)
+SYSCALL(sys_eventfd,sys_eventfd,sys_eventfd_wrapper)
diff --git a/arch/s390/kernel/vmlinux.lds.S b/arch/s390/kernel/vmlinux.lds.S
index e9d3432..7158a80 100644
--- a/arch/s390/kernel/vmlinux.lds.S
+++ b/arch/s390/kernel/vmlinux.lds.S
@@ -21,7 +21,7 @@ SECTIONS
   . = 0x00000000;
   _text = .;			/* Text and read-only data */
   .text : {
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	KPROBES_TEXT
@@ -48,7 +48,7 @@ SECTIONS
   BUG_TABLE
 
   .data : {			/* Data */
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	}
 
diff --git a/arch/s390/mm/init.c b/arch/s390/mm/init.c
index 916b72a..9098531 100644
--- a/arch/s390/mm/init.c
+++ b/arch/s390/mm/init.c
@@ -61,30 +61,38 @@ void diag10(unsigned long addr)
 
 void show_mem(void)
 {
-        int i, total = 0, reserved = 0;
-        int shared = 0, cached = 0;
+	int i, total = 0, reserved = 0;
+	int shared = 0, cached = 0;
 	struct page *page;
 
-        printk("Mem-info:\n");
-        show_free_areas();
-        printk("Free swap:       %6ldkB\n", nr_swap_pages<<(PAGE_SHIFT-10));
-        i = max_mapnr;
-        while (i-- > 0) {
+	printk("Mem-info:\n");
+	show_free_areas();
+	printk("Free swap:       %6ldkB\n", nr_swap_pages << (PAGE_SHIFT - 10));
+	i = max_mapnr;
+	while (i-- > 0) {
 		if (!pfn_valid(i))
 			continue;
 		page = pfn_to_page(i);
-                total++;
+		total++;
 		if (PageReserved(page))
-                        reserved++;
+			reserved++;
 		else if (PageSwapCache(page))
-                        cached++;
+			cached++;
 		else if (page_count(page))
 			shared += page_count(page) - 1;
-        }
-        printk("%d pages of RAM\n",total);
-        printk("%d reserved pages\n",reserved);
-        printk("%d pages shared\n",shared);
-        printk("%d pages swap cached\n",cached);
+	}
+	printk("%d pages of RAM\n", total);
+	printk("%d reserved pages\n", reserved);
+	printk("%d pages shared\n", shared);
+	printk("%d pages swap cached\n", cached);
+
+	printk("%lu pages dirty\n", global_page_state(NR_FILE_DIRTY));
+	printk("%lu pages writeback\n", global_page_state(NR_WRITEBACK));
+	printk("%lu pages mapped\n", global_page_state(NR_FILE_MAPPED));
+	printk("%lu pages slab\n",
+	       global_page_state(NR_SLAB_RECLAIMABLE) +
+	       global_page_state(NR_SLAB_UNRECLAIMABLE));
+	printk("%lu pages pagetables\n", global_page_state(NR_PAGETABLE));
 }
 
 static void __init setup_ro_region(void)
diff --git a/arch/sh/boards/landisk/gio.c b/arch/sh/boards/landisk/gio.c
index 50d38be..a37643d 100644
--- a/arch/sh/boards/landisk/gio.c
+++ b/arch/sh/boards/landisk/gio.c
@@ -69,7 +69,7 @@ static int gio_ioctl(struct inode *inode, struct file *filp,
 	}
 
 	switch (cmd) {
-	case GIODRV_IOCSGIOSETADDR:	/* addres set */
+	case GIODRV_IOCSGIOSETADDR:	/* address set */
 		addr = data;
 		break;
 
diff --git a/arch/sh/boards/landisk/setup.c b/arch/sh/boards/landisk/setup.c
index 4058b4f..f953c74 100644
--- a/arch/sh/boards/landisk/setup.c
+++ b/arch/sh/boards/landisk/setup.c
@@ -44,8 +44,14 @@ static struct platform_device cf_ide_device = {
 	},
 };
 
+static struct platform_device rtc_device = {
+	.name		= "rs5c313",
+	.id		= -1,
+};
+
 static struct platform_device *landisk_devices[] __initdata = {
 	&cf_ide_device,
+	&rtc_device,
 };
 
 static int __init landisk_devices_setup(void)
diff --git a/arch/sh/boards/renesas/r7780rp/Makefile b/arch/sh/boards/renesas/r7780rp/Makefile
index 609e5d5..b1d20af 100644
--- a/arch/sh/boards/renesas/r7780rp/Makefile
+++ b/arch/sh/boards/renesas/r7780rp/Makefile
@@ -3,5 +3,8 @@
 #
 irqinit-y			:= irq-r7780rp.o
 irqinit-$(CONFIG_SH_R7785RP)	:= irq-r7785rp.o
+obj-y				:= setup.o irq.o $(irqinit-y)
+
+ifneq ($(CONFIG_SH_R7785RP),y)
 obj-$(CONFIG_PUSH_SWITCH)	+= psw.o
-obj-y	 			:= setup.o irq.o $(irqinit-y)
+endif
diff --git a/arch/sh/boards/snapgear/rtc.c b/arch/sh/boards/snapgear/rtc.c
index 1659fdd..edb3dd9 100644
--- a/arch/sh/boards/snapgear/rtc.c
+++ b/arch/sh/boards/snapgear/rtc.c
@@ -108,7 +108,7 @@ static void ds1302_writebyte(unsigned int addr, unsigned int val)
 static void ds1302_reset(void)
 {
 	unsigned long	flags;
-	/* Hardware dependant reset/init */
+	/* Hardware dependent reset/init */
 	local_irq_save(flags);
 	set_dirp(get_dirp() | RTC_RESET | RTC_IODATA | RTC_SCLK);
 	set_dp(get_dp() & ~(RTC_RESET | RTC_IODATA | RTC_SCLK));
diff --git a/arch/sh/boards/superh/microdev/io.c b/arch/sh/boards/superh/microdev/io.c
index 83419bf..b704e20 100644
--- a/arch/sh/boards/superh/microdev/io.c
+++ b/arch/sh/boards/superh/microdev/io.c
@@ -198,12 +198,12 @@ void microdev_outb(unsigned char b, unsigned long port)
 	/*
 	 *	There is a board feature with the current SH4-202 MicroDev in
 	 *	that the 2 byte enables (nBE0 and nBE1) are tied together (and
-	 *	to the Chip Select Line (Ethernet_CS)). Due to this conectivity,
+	 *	to the Chip Select Line (Ethernet_CS)). Due to this connectivity,
 	 *	it is not possible to safely perform 8-bit writes to the
 	 *	Ethernet registers, as 16-bits will be consumed from the Data
 	 *	lines (corrupting the other byte).  Hence, this function is
-	 *	written to impliment 16-bit read/modify/write for all byte-wide
-	 *	acceses.
+	 *	written to implement 16-bit read/modify/write for all byte-wide
+	 *	accesses.
 	 *
 	 *	Note: there is no problem with byte READS (even or odd).
 	 *
diff --git a/arch/sh/boards/superh/microdev/irq.c b/arch/sh/boards/superh/microdev/irq.c
index 8c64baa..cc1cb04 100644
--- a/arch/sh/boards/superh/microdev/irq.c
+++ b/arch/sh/boards/superh/microdev/irq.c
@@ -100,7 +100,7 @@ static void disable_microdev_irq(unsigned int irq)
 
 	fpgaIrq = fpgaIrqTable[irq].fpgaIrq;
 
-	/* disable interupts on the FPGA INTC register */
+	/* disable interrupts on the FPGA INTC register */
 	ctrl_outl(MICRODEV_FPGA_INTC_MASK(fpgaIrq), MICRODEV_FPGA_INTDSB_REG);
 }
 
@@ -125,7 +125,7 @@ static void enable_microdev_irq(unsigned int irq)
 	priorities |= MICRODEV_FPGA_INTPRI_LEVEL(fpgaIrq, pri);
 	ctrl_outl(priorities, priorityReg);
 
-	/* enable interupts on the FPGA INTC register */
+	/* enable interrupts on the FPGA INTC register */
 	ctrl_outl(MICRODEV_FPGA_INTC_MASK(fpgaIrq), MICRODEV_FPGA_INTENB_REG);
 }
 
@@ -152,7 +152,7 @@ extern void __init init_microdev_irq(void)
 {
 	int i;
 
-		/* disable interupts on the FPGA INTC register */
+		/* disable interrupts on the FPGA INTC register */
 	ctrl_outl(~0ul, MICRODEV_FPGA_INTDSB_REG);
 
 	for (i = 0; i < NUM_EXTERNAL_IRQS; i++)
diff --git a/arch/sh/boards/superh/microdev/setup.c b/arch/sh/boards/superh/microdev/setup.c
index 031c814..6396cea 100644
--- a/arch/sh/boards/superh/microdev/setup.c
+++ b/arch/sh/boards/superh/microdev/setup.c
@@ -349,7 +349,7 @@ static int __init smsc_superio_setup(void)
 	SMSC_WRITE_INDEXED(0x00, 0xc7);	/* GP47 = nIOWOP */
 	SMSC_WRITE_INDEXED(0x08, 0xe8);	/* GP20 = nIDE2_OE */
 
-		/* Exit the configuraton state */
+		/* Exit the configuration state */
 	outb(SMSC_EXIT_CONFIG_KEY, SMSC_CONFIG_PORT_ADDR);
 
 	return 0;
diff --git a/arch/sh/boards/unknown/setup.c b/arch/sh/boards/unknown/setup.c
index 1c94137..bee4612 100644
--- a/arch/sh/boards/unknown/setup.c
+++ b/arch/sh/boards/unknown/setup.c
@@ -6,7 +6,7 @@
  * May be copied or modified under the terms of the GNU General Public
  * License.  See linux/COPYING for more information.
  *
- * Setup code for an unknown machine (internal peripherials only)
+ * Setup code for an unknown machine (internal peripherals only)
  *
  * This is the simplest of all boards, and serves only as a quick and dirty
  * method to start debugging a new board during bring-up until proper board
diff --git a/arch/sh/drivers/dma/dma-api.c b/arch/sh/drivers/dma/dma-api.c
index e062067..8057a27 100644
--- a/arch/sh/drivers/dma/dma-api.c
+++ b/arch/sh/drivers/dma/dma-api.c
@@ -115,7 +115,7 @@ static int search_cap(const char **haystack, const char *needle)
 /**
  * request_dma_bycap - Allocate a DMA channel based on its capabilities
  * @dmac: List of DMA controllers to search
- * @caps: List of capabilites
+ * @caps: List of capabilities
  *
  * Search all channels of all DMA controllers to find a channel which
  * matches the requested capabilities. The result is the channel
diff --git a/arch/sh/drivers/dma/dma-isa.c b/arch/sh/drivers/dma/dma-isa.c
index 05a74ff..5fb044b 100644
--- a/arch/sh/drivers/dma/dma-isa.c
+++ b/arch/sh/drivers/dma/dma-isa.c
@@ -28,7 +28,7 @@
  * NOTE: ops->xfer() is the preferred way of doing things. However, there
  * are some users of the ISA DMA API that exist in common code that we
  * don't necessarily want to go out of our way to break, so we still
- * allow for some compatability at that level. Any new code is strongly
+ * allow for some compatibility at that level. Any new code is strongly
  * advised to run far away from the ISA DMA API and use the SH DMA API
  * directly.
  */
diff --git a/arch/sh/drivers/dma/dmabrg.c b/arch/sh/drivers/dma/dmabrg.c
index 9d0a293..5e22689 100644
--- a/arch/sh/drivers/dma/dmabrg.c
+++ b/arch/sh/drivers/dma/dmabrg.c
@@ -33,7 +33,7 @@
  *     9      | HAC1/SSI1 | rec | half done    | DMABRGI2
  *
  * all can be enabled/disabled in the DMABRGCR register,
- * as well as checked if they occured.
+ * as well as checked if they occurred.
  *
  * DMABRGI0 services  USB  DMA  Address  errors,  but it still must be
  * enabled/acked in the DMABRGCR register.  USB-DMA complete indicator
diff --git a/arch/sh/drivers/pci/ops-dreamcast.c b/arch/sh/drivers/pci/ops-dreamcast.c
index 381306c..e1284fc 100644
--- a/arch/sh/drivers/pci/ops-dreamcast.c
+++ b/arch/sh/drivers/pci/ops-dreamcast.c
@@ -57,7 +57,7 @@ struct pci_channel board_pci_channels[] = {
  *
  * Also, we could very easily support both Type 0 and Type 1 configurations
  * here, but since it doesn't seem that there is any such implementation in
- * existance, we don't bother.
+ * existence, we don't bother.
  *
  * I suppose if someone actually gets around to ripping the chip out of
  * the BBA and hanging some more devices off of it, then this might be
diff --git a/arch/sh/drivers/pci/pci-st40.c b/arch/sh/drivers/pci/pci-st40.c
index d67656a..543417f 100644
--- a/arch/sh/drivers/pci/pci-st40.c
+++ b/arch/sh/drivers/pci/pci-st40.c
@@ -292,7 +292,7 @@ int __init st40pci_init(unsigned memStart, unsigned memSize)
 			    PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
 			    PCI_COMMAND_IO);
 
-	/* Accesse to the 0xb0000000 -> 0xb6000000 area will go through to 0x10000000 -> 0x16000000
+	/* Access to the 0xb0000000 -> 0xb6000000 area will go through to 0x10000000 -> 0x16000000
 	 * on the PCI bus. This allows a nice 1-1 bus to phys mapping.
 	 */
 
@@ -315,7 +315,7 @@ int __init st40pci_init(unsigned memStart, unsigned memSize)
 	ST40PCI_WRITE(CSR_MBAR0, 0);
 	ST40PCI_WRITE(LSR0, 0x0fff0001);
 
-	/* ... and set up the initial incomming window to expose all of RAM */
+	/* ... and set up the initial incoming window to expose all of RAM */
 	pci_set_rbar_region(7, memStart, memStart, memSize);
 
 	/* Maximise timeout values */
@@ -473,7 +473,7 @@ static void pci_set_rbar_region(unsigned int region,     unsigned long localAddr
 
 	mask = r2p2(regionSize) - 0x10000;
 
-	/* Diable the region (in case currently in use, should never happen) */
+	/* Disable the region (in case currently in use, should never happen) */
 	ST40PCI_WRITE_INDEXED(RSR, region, 0);
 
 	/* Start of local address space to publish */
diff --git a/arch/sh/drivers/pci/pci-st40.h b/arch/sh/drivers/pci/pci-st40.h
index d729e0c..cf0d35b 100644
--- a/arch/sh/drivers/pci/pci-st40.h
+++ b/arch/sh/drivers/pci/pci-st40.h
@@ -4,7 +4,7 @@
  * May be copied or modified under the terms of the GNU General Public
  * License.  See linux/COPYING for more information.                            
  *
- * Defintions for the ST40 PCI hardware.
+ * Definitions for the ST40 PCI hardware.
  */
 
 #ifndef __PCI_ST40_H__
diff --git a/arch/sh/drivers/superhyway/ops-sh4-202.c b/arch/sh/drivers/superhyway/ops-sh4-202.c
index a55c98a..3b14bf8 100644
--- a/arch/sh/drivers/superhyway/ops-sh4-202.c
+++ b/arch/sh/drivers/superhyway/ops-sh4-202.c
@@ -130,7 +130,7 @@ static int sh4202_read_vcr(unsigned long base, struct superhyway_vcr_info *vcr)
 	 * Some modules (PBR and ePBR for instance) also appear to have
 	 * VCRL/VCRH flipped in the documentation, but on the SH4-202
 	 * itself it appears that these are all consistently mapped with
-	 * VCRH preceeding VCRL.
+	 * VCRH preceding VCRL.
 	 *
 	 * Do not trust the documentation, for it is evil.
 	 */
diff --git a/arch/sh/kernel/cf-enabler.c b/arch/sh/kernel/cf-enabler.c
index 0758d48..849a9e1 100644
--- a/arch/sh/kernel/cf-enabler.c
+++ b/arch/sh/kernel/cf-enabler.c
@@ -31,7 +31,7 @@
  */
 #if defined(CONFIG_CPU_SH4)
 /* SH4 can't access PCMCIA interface through P2 area.
- * we must remap it with appropreate attribute bit of the page set.
+ * we must remap it with appropriate attribute bit of the page set.
  * this part is based on Greg Banks' hd64465_ss.c implementation - Masahiro Abe */
 
 #if defined(CONFIG_CF_AREA6)
diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 014f318..6325154 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -278,6 +278,11 @@ arch_init_clk_ops(struct clk_ops **ops, int type)
 {
 }
 
+void __init __attribute__ ((weak))
+arch_clk_init(void)
+{
+}
+
 static int show_clocks(char *buf, char **start, off_t off,
 		       int len, int *eof, void *data)
 {
@@ -314,6 +319,8 @@ int __init clk_init(void)
 		ret |= clk_register(clk);
 	}
 
+	arch_clk_init();
+
 	/* Kick the child clocks.. */
 	propagate_rate(&master_clk);
 	propagate_rate(&bus_clk);
diff --git a/arch/sh/kernel/cpu/irq/maskreg.c b/arch/sh/kernel/cpu/irq/maskreg.c
index 492db31..978992e 100644
--- a/arch/sh/kernel/cpu/irq/maskreg.c
+++ b/arch/sh/kernel/cpu/irq/maskreg.c
@@ -38,7 +38,7 @@ static struct hw_interrupt_type maskreg_irq_type = {
 	.end = end_maskreg_irq
 };
 
-/* actual implementatin */
+/* actual implementation */
 static unsigned int startup_maskreg_irq(unsigned int irq)
 {
 	enable_maskreg_irq(irq);
diff --git a/arch/sh/kernel/cpu/sh4/fpu.c b/arch/sh/kernel/cpu/sh4/fpu.c
index d61dd59..c5a4fc7 100644
--- a/arch/sh/kernel/cpu/sh4/fpu.c
+++ b/arch/sh/kernel/cpu/sh4/fpu.c
@@ -138,7 +138,7 @@ restore_fpu(struct task_struct *tsk)
 /*
  * Load the FPU with signalling NANS.  This bit pattern we're using
  * has the property that no matter wether considered as single or as
- * double precission represents signaling NANS.  
+ * double precision represents signaling NANS.  
  */
 
 static void
diff --git a/arch/sh/kernel/cpu/sh4/setup-sh7750.c b/arch/sh/kernel/cpu/sh4/setup-sh7750.c
index 6f8f458..03b14cf 100644
--- a/arch/sh/kernel/cpu/sh4/setup-sh7750.c
+++ b/arch/sh/kernel/cpu/sh4/setup-sh7750.c
@@ -106,6 +106,7 @@ static struct ipr_data sh7750_ipr_map[] = {
 	{ 38, 2,  8, 7 }, /* DMAC DMAE */
 };
 
+#ifdef CONFIG_CPU_SUBTYPE_SH7751
 static struct ipr_data sh7751_ipr_map[] = {
 	{ 44, 2,  8, 7 }, /* DMAC DMTE4 */
 	{ 45, 2,  8, 7 }, /* DMAC DMTE5 */
@@ -117,6 +118,7 @@ static struct ipr_data sh7751_ipr_map[] = {
 	/*{ 72, INTPRI00,  8, ? },*/ /* TMU3 TUNI */
 	/*{ 76, INTPRI00, 12, ? },*/ /* TMU4 TUNI */
 };
+#endif
 
 static unsigned long ipr_offsets[] = {
 	0xffd00004UL,	/* 0: IPRA */
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7722.c b/arch/sh/kernel/cpu/sh4a/clock-sh7722.c
index 2909003..51b386d 100644
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7722.c
+++ b/arch/sh/kernel/cpu/sh4a/clock-sh7722.c
@@ -17,7 +17,6 @@
 #include <asm/clock.h>
 #include <asm/freq.h>
 
-#define SH7722_PLL_FREQ (32000000/8)
 #define N  (-1)
 #define NM (-2)
 #define ROUND_NEAREST 0
@@ -141,28 +140,36 @@ static void adjust_clocks(int originate, int *l, unsigned long v[],
 */
 static int divisors2[] = { 2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40 };
 
+static void master_clk_recalc(struct clk *clk)
+{
+	unsigned frqcr = ctrl_inl(FRQCR);
+
+	clk->rate = CONFIG_SH_PCLK_FREQ * (((frqcr >> 24) & 0x1f) + 1);
+}
+
 static void master_clk_init(struct clk *clk)
 {
-	clk_set_rate(clk, clk_get_rate(clk));
+	clk->parent = NULL;
+	clk->flags |= CLK_RATE_PROPAGATES;
+	clk->rate = CONFIG_SH_PCLK_FREQ;
+	master_clk_recalc(clk);
 }
 
-static void master_clk_recalc(struct clk *clk)
+
+static void module_clk_recalc(struct clk *clk)
 {
 	unsigned long frqcr = ctrl_inl(FRQCR);
 
-	clk->rate = CONFIG_SH_PCLK_FREQ * (1 + (frqcr >> 24 & 0xF));
+	clk->rate = clk->parent->rate / (((frqcr >> 24) & 0x1f) + 1);
 }
 
 static int master_clk_setrate(struct clk *clk, unsigned long rate, int id)
 {
-	int div = rate / SH7722_PLL_FREQ;
+	int div = rate / clk->rate;
 	int master_divs[] = { 2, 3, 4, 6, 8, 16 };
 	int index;
 	unsigned long frqcr;
 
-	if (rate < SH7722_PLL_FREQ * 2)
-		return -EINVAL;
-
 	for (index = 1; index < ARRAY_SIZE(master_divs); index++)
 		if (div >= master_divs[index - 1] && div < master_divs[index])
 			break;
@@ -185,6 +192,10 @@ static struct clk_ops sh7722_master_clk_ops = {
 	.set_rate = master_clk_setrate,
 };
 
+static struct clk_ops sh7722_module_clk_ops = {
+       .recalc = module_clk_recalc,
+};
+
 struct frqcr_context {
 	unsigned mask;
 	unsigned shift;
@@ -489,7 +500,7 @@ static void sh7722_siu_recalc(struct clk *clk)
 
 	if (siu < 0)
 		return /* siu */ ;
-	BUG_ON(siu > 1);
+	BUG_ON(siu > 2);
 	r = ctrl_inl(sh7722_siu_regs[siu]);
 	clk->rate = clk->parent->rate * 2 / divisors2[r & 0xF];
 }
@@ -571,7 +582,7 @@ static struct clk *sh7722_clocks[] = {
  */
 struct clk_ops *onchip_ops[] = {
 	&sh7722_master_clk_ops,
-	&sh7722_frqcr_clk_ops,
+	&sh7722_module_clk_ops,
 	&sh7722_frqcr_clk_ops,
 	&sh7722_frqcr_clk_ops,
 };
@@ -583,7 +594,7 @@ arch_init_clk_ops(struct clk_ops **ops, int type)
 	*ops = onchip_ops[type];
 }
 
-int __init sh7722_clock_init(void)
+int __init arch_clk_init(void)
 {
 	struct clk *master;
 	int i;
@@ -597,4 +608,3 @@ int __init sh7722_clock_init(void)
 	clk_put(master);
 	return 0;
 }
-arch_initcall(sh7722_clock_init);
diff --git a/arch/sh/kernel/kgdb_stub.c b/arch/sh/kernel/kgdb_stub.c
index a532336..edd1ec2 100644
--- a/arch/sh/kernel/kgdb_stub.c
+++ b/arch/sh/kernel/kgdb_stub.c
@@ -2,7 +2,7 @@
  * May be copied or modified under the terms of the GNU General Public
  * License.  See linux/COPYING for more information.
  *
- * Containes extracts from code by Glenn Engel, Jim Kingdon,
+ * Contains extracts from code by Glenn Engel, Jim Kingdon,
  * David Grothe <dave@gcom.com>, Tigran Aivazian <tigran@sco.com>,
  * Amit S. Kale <akale@veritas.com>,  William Gatliff <bgat@open-widgets.com>,
  * Ben Lee, Steve Chamberlain and Benoit Miller <fulg@iname.com>.
@@ -85,7 +85,7 @@
  *
  * Responses can be run-length encoded to save space.  A '*' means that
  * the next character is an ASCII encoding giving a repeat count which
- * stands for that many repititions of the character preceding the '*'.
+ * stands for that many repetitions of the character preceding the '*'.
  * The encoding is n+29, yielding a printable character where n >=3
  * (which is where RLE starts to win).  Don't use an n > 126.
  *
diff --git a/arch/sh/kernel/process.c b/arch/sh/kernel/process.c
index 6b4f574..a11e2aa 100644
--- a/arch/sh/kernel/process.c
+++ b/arch/sh/kernel/process.c
@@ -26,8 +26,6 @@
 static int hlt_counter;
 int ubc_usercnt = 0;
 
-#define HARD_IDLE_TIMEOUT (HZ / 3)
-
 void (*pm_idle)(void);
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
@@ -44,16 +42,39 @@ void enable_hlt(void)
 }
 EXPORT_SYMBOL(enable_hlt);
 
+static int __init nohlt_setup(char *__unused)
+{
+	hlt_counter = 1;
+	return 1;
+}
+__setup("nohlt", nohlt_setup);
+
+static int __init hlt_setup(char *__unused)
+{
+	hlt_counter = 0;
+	return 1;
+}
+__setup("hlt", hlt_setup);
+
 void default_idle(void)
 {
-	if (!hlt_counter)
-		cpu_sleep();
-	else
-		cpu_relax();
+	if (!hlt_counter) {
+		clear_thread_flag(TIF_POLLING_NRFLAG);
+		smp_mb__after_clear_bit();
+		set_bl_bit();
+		while (!need_resched())
+			cpu_sleep();
+		clear_bl_bit();
+		set_thread_flag(TIF_POLLING_NRFLAG);
+	} else
+		while (!need_resched())
+			cpu_relax();
 }
 
 void cpu_idle(void)
 {
+	set_thread_flag(TIF_POLLING_NRFLAG);
+
 	/* endless idle loop with no priority at all */
 	while (1) {
 		void (*idle)(void) = pm_idle;
diff --git a/arch/sh/kernel/syscalls.S b/arch/sh/kernel/syscalls.S
index 4357d1a..7db1c2d 100644
--- a/arch/sh/kernel/syscalls.S
+++ b/arch/sh/kernel/syscalls.S
@@ -355,3 +355,6 @@ ENTRY(sys_call_table)
 	.long sys_getcpu
 	.long sys_epoll_pwait
 	.long sys_utimensat		/* 320 */
+	.long sys_signalfd
+	.long sys_timerfd
+	.long sys_eventfd
diff --git a/arch/sh/kernel/traps.c b/arch/sh/kernel/traps.c
index 3a19764..5b75cb6 100644
--- a/arch/sh/kernel/traps.c
+++ b/arch/sh/kernel/traps.c
@@ -21,6 +21,7 @@
 #include <linux/bug.h>
 #include <linux/debug_locks.h>
 #include <linux/kdebug.h>
+#include <linux/kexec.h>
 #include <linux/limits.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -101,6 +102,16 @@ void die(const char * str, struct pt_regs * regs, long err)
 
 	bust_spinlocks(0);
 	spin_unlock_irq(&die_lock);
+
+	if (kexec_should_crash(current))
+		crash_kexec(regs);
+
+	if (in_interrupt())
+		panic("Fatal exception in interrupt");
+
+	if (panic_on_oops)
+		panic("Fatal exception");
+
 	do_exit(SIGSEGV);
 }
 
@@ -513,7 +524,7 @@ static int handle_unaligned_access(u16 instruction, struct pt_regs *regs)
  *       misaligned data access
  *       access to >= 0x80000000 is user mode
  * Unfortuntaly we can't distinguish between instruction address error
- * and data address errors caused by read acceses.
+ * and data address errors caused by read accesses.
  */
 asmlinkage void do_address_error(struct pt_regs *regs,
 				 unsigned long writeaccess,
diff --git a/arch/sh/kernel/vmlinux.lds.S b/arch/sh/kernel/vmlinux.lds.S
index d83143c..4c5b57e 100644
--- a/arch/sh/kernel/vmlinux.lds.S
+++ b/arch/sh/kernel/vmlinux.lds.S
@@ -22,7 +22,7 @@ SECTIONS
 	*(.empty_zero_page)
 	} = 0
   .text : {
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	*(.fixup)
@@ -41,7 +41,7 @@ SECTIONS
   BUG_TABLE
 
   .data : {			/* Data */
-	*(.data)
+	DATA_DATA
 
  	 /* Align the initial ramdisk image (INITRD) on page boundaries. */
  	 . = ALIGN(PAGE_SIZE);
diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index 1efbac1..a38e1ee 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -148,7 +148,7 @@ fmac(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
 	return 0;
 }
 
-// to process fmov's extention (odd n for DR access XD).
+// to process fmov's extension (odd n for DR access XD).
 #define FMOV_EXT(x) if(x&1) x+=16-1
 
 static int
diff --git a/arch/sh/mm/copy_page.S b/arch/sh/mm/copy_page.S
index 397c94c..ae039f2 100644
--- a/arch/sh/mm/copy_page.S
+++ b/arch/sh/mm/copy_page.S
@@ -129,6 +129,7 @@ ENTRY(__copy_user_page)
 	rts
 	 nop
 #endif
+	.align 2
 .Lpsz:	.long	PAGE_SIZE
 /*
  * __kernel_size_t __copy_user(void *to, const void *from, __kernel_size_t n);
diff --git a/arch/sh/mm/fault.c b/arch/sh/mm/fault.c
index 9207da6..c878faa 100644
--- a/arch/sh/mm/fault.c
+++ b/arch/sh/mm/fault.c
@@ -15,43 +15,11 @@
 #include <linux/mm.h>
 #include <linux/hardirq.h>
 #include <linux/kprobes.h>
-#include <linux/kdebug.h>
 #include <asm/system.h>
 #include <asm/mmu_context.h>
 #include <asm/tlbflush.h>
 #include <asm/kgdb.h>
 
-#ifdef CONFIG_KPROBES
-ATOMIC_NOTIFIER_HEAD(notify_page_fault_chain);
-
-/* Hook to register for page fault notifications */
-int register_page_fault_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&notify_page_fault_chain, nb);
-}
-
-int unregister_page_fault_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&notify_page_fault_chain, nb);
-}
-
-static inline int notify_page_fault(enum die_val val, struct pt_regs *regs,
-				    int trap, int sig)
-{
-	struct die_args args = {
-		.regs = regs,
-		.trapnr = trap,
-	};
-	return atomic_notifier_call_chain(&notify_page_fault_chain, val, &args);
-}
-#else
-static inline int notify_page_fault(enum die_val val, struct pt_regs *regs,
-				    int trap, int sig)
-{
-	return NOTIFY_DONE;
-}
-#endif
-
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
@@ -69,11 +37,6 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
 	siginfo_t info;
 
 	trace_hardirqs_on();
-
-	if (notify_page_fault(DIE_PAGE_FAULT, regs,
-			      writeaccess, SIGSEGV) == NOTIFY_STOP)
-		return;
-
 	local_irq_enable();
 
 #ifdef CONFIG_SH_KGDB
@@ -285,7 +248,7 @@ asmlinkage int __kprobes __do_page_fault(struct pt_regs *regs,
 	pte_t *pte;
 	pte_t entry;
 	struct mm_struct *mm = current->mm;
-	spinlock_t *ptl;
+	spinlock_t *ptl = NULL;
 	int ret = 1;
 
 #ifdef CONFIG_SH_KGDB
diff --git a/arch/sh/mm/init.c b/arch/sh/mm/init.c
index 8fe223a..e0e644f 100644
--- a/arch/sh/mm/init.c
+++ b/arch/sh/mm/init.c
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/bootmem.h>
 #include <linux/proc_fs.h>
+#include <linux/pagemap.h>
 #include <linux/percpu.h>
 #include <linux/io.h>
 #include <asm/mmu_context.h>
@@ -112,7 +113,7 @@ static void set_pte_phys(unsigned long addr, unsigned long phys, pgprot_t prot)
  * As a performance optimization, other platforms preserve the fixmap mapping
  * across a context switch, we don't presently do this, but this could be done
  * in a similar fashion as to the wired TLB interface that sh64 uses (by way
- * of the memorry mapped UTLB configuration) -- this unfortunately forces us to
+ * of the memory mapped UTLB configuration) -- this unfortunately forces us to
  * give up a TLB entry for each mapping we want to preserve. While this may be
  * viable for a small number of fixmaps, it's not particularly useful for
  * everything and needs to be carefully evaluated. (ie, we may want this for
diff --git a/arch/sh/mm/pmb.c b/arch/sh/mm/pmb.c
index 02aae06..b6a5a33 100644
--- a/arch/sh/mm/pmb.c
+++ b/arch/sh/mm/pmb.c
@@ -3,7 +3,7 @@
  *
  * Privileged Space Mapping Buffer (PMB) Support.
  *
- * Copyright (C) 2005, 2006 Paul Mundt
+ * Copyright (C) 2005, 2006, 2007 Paul Mundt
  *
  * P1/P2 Section mapping definitions from map32.h, which was:
  *
@@ -68,6 +68,32 @@ static inline unsigned long mk_pmb_data(unsigned int entry)
 	return mk_pmb_entry(entry) | PMB_DATA;
 }
 
+static DEFINE_SPINLOCK(pmb_list_lock);
+static struct pmb_entry *pmb_list;
+
+static inline void pmb_list_add(struct pmb_entry *pmbe)
+{
+	struct pmb_entry **p, *tmp;
+
+	p = &pmb_list;
+	while ((tmp = *p) != NULL)
+		p = &tmp->next;
+
+	pmbe->next = tmp;
+	*p = pmbe;
+}
+
+static inline void pmb_list_del(struct pmb_entry *pmbe)
+{
+	struct pmb_entry **p, *tmp;
+
+	for (p = &pmb_list; (tmp = *p); p = &tmp->next)
+		if (tmp == pmbe) {
+			*p = tmp->next;
+			return;
+		}
+}
+
 struct pmb_entry *pmb_alloc(unsigned long vpn, unsigned long ppn,
 			    unsigned long flags)
 {
@@ -81,11 +107,19 @@ struct pmb_entry *pmb_alloc(unsigned long vpn, unsigned long ppn,
 	pmbe->ppn	= ppn;
 	pmbe->flags	= flags;
 
+	spin_lock_irq(&pmb_list_lock);
+	pmb_list_add(pmbe);
+	spin_unlock_irq(&pmb_list_lock);
+
 	return pmbe;
 }
 
 void pmb_free(struct pmb_entry *pmbe)
 {
+	spin_lock_irq(&pmb_list_lock);
+	pmb_list_del(pmbe);
+	spin_unlock_irq(&pmb_list_lock);
+
 	kmem_cache_free(pmb_cache, pmbe);
 }
 
@@ -167,31 +201,6 @@ void clear_pmb_entry(struct pmb_entry *pmbe)
 	clear_bit(entry, &pmb_map);
 }
 
-static DEFINE_SPINLOCK(pmb_list_lock);
-static struct pmb_entry *pmb_list;
-
-static inline void pmb_list_add(struct pmb_entry *pmbe)
-{
-	struct pmb_entry **p, *tmp;
-
-	p = &pmb_list;
-	while ((tmp = *p) != NULL)
-		p = &tmp->next;
-
-	pmbe->next = tmp;
-	*p = pmbe;
-}
-
-static inline void pmb_list_del(struct pmb_entry *pmbe)
-{
-	struct pmb_entry **p, *tmp;
-
-	for (p = &pmb_list; (tmp = *p); p = &tmp->next)
-		if (tmp == pmbe) {
-			*p = tmp->next;
-			return;
-		}
-}
 
 static struct {
 	unsigned long size;
@@ -283,25 +292,14 @@ void pmb_unmap(unsigned long addr)
 	} while (pmbe);
 }
 
-static void pmb_cache_ctor(void *pmb, struct kmem_cache *cachep, unsigned long flags)
+static void pmb_cache_ctor(void *pmb, struct kmem_cache *cachep,
+			   unsigned long flags)
 {
 	struct pmb_entry *pmbe = pmb;
 
 	memset(pmb, 0, sizeof(struct pmb_entry));
 
-	spin_lock_irq(&pmb_list_lock);
-
 	pmbe->entry = PMB_NO_ENTRY;
-	pmb_list_add(pmbe);
-
-	spin_unlock_irq(&pmb_list_lock);
-}
-
-static void pmb_cache_dtor(void *pmb, struct kmem_cache *cachep, unsigned long flags)
-{
-	spin_lock_irq(&pmb_list_lock);
-	pmb_list_del(pmb);
-	spin_unlock_irq(&pmb_list_lock);
 }
 
 static int __init pmb_init(void)
@@ -312,8 +310,7 @@ static int __init pmb_init(void)
 	BUG_ON(unlikely(nr_entries >= NR_PMB_ENTRIES));
 
 	pmb_cache = kmem_cache_create("pmb", sizeof(struct pmb_entry), 0,
-				      SLAB_PANIC, pmb_cache_ctor,
-				      pmb_cache_dtor);
+				      SLAB_PANIC, pmb_cache_ctor, NULL);
 
 	jump_to_P2();
 
diff --git a/arch/sh/tools/mach-types b/arch/sh/tools/mach-types
index 554f801..fb40f18 100644
--- a/arch/sh/tools/mach-types
+++ b/arch/sh/tools/mach-types
@@ -7,8 +7,11 @@
 #
 SE			SH_SOLUTION_ENGINE
 7751SE			SH_7751_SOLUTION_ENGINE		
+7722SE			SH_7722_SOLUTION_ENGINE		
 7300SE			SH_7300_SOLUTION_ENGINE
 7343SE			SH_7343_SOLUTION_ENGINE
+7206SE			SH_7206_SOLUTION_ENGINE
+7619SE			SH_7619_SOLUTION_ENGINE
 7780SE			SH_7780_SOLUTION_ENGINE
 73180SE			SH_73180_SOLUTION_ENGINE
 7751SYSTEMH		SH_7751_SYSTEMH
@@ -31,5 +34,3 @@ R7785RP			SH_R7785RP
 TITAN			SH_TITAN
 SHMIN			SH_SHMIN
 7710VOIPGW		SH_7710VOIPGW
-7206SE			SH_7206_SOLUTION_ENGINE
-7619SE			SH_7619_SOLUTION_ENGINE
diff --git a/arch/sh64/kernel/vmlinux.lds.S b/arch/sh64/kernel/vmlinux.lds.S
index 4f9616f..02aea86 100644
--- a/arch/sh64/kernel/vmlinux.lds.S
+++ b/arch/sh64/kernel/vmlinux.lds.S
@@ -54,7 +54,7 @@ SECTIONS
 	} = 0
 
   .text : C_PHYS(.text) {
-	*(.text)
+	TEXT_TEXT
 	*(.text64)
         *(.text..SHmedia32)
 	SCHED_TEXT
@@ -78,7 +78,7 @@ SECTIONS
   _etext = .;			/* End of text section */
 
   .data : C_PHYS(.data) {			/* Data */
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	}
 
diff --git a/arch/sparc/kernel/vmlinux.lds.S b/arch/sparc/kernel/vmlinux.lds.S
index f0bb6e6..f75a1b8 100644
--- a/arch/sparc/kernel/vmlinux.lds.S
+++ b/arch/sparc/kernel/vmlinux.lds.S
@@ -12,7 +12,7 @@ SECTIONS
   .text 0xf0004000 :
   {
     _text = .;
-    *(.text)
+    TEXT_TEXT
     SCHED_TEXT
     LOCK_TEXT
     *(.gnu.warning)
@@ -22,7 +22,7 @@ SECTIONS
   RODATA
   .data    :
   {
-    *(.data)
+    DATA_DATA
     CONSTRUCTORS
   }
   .data1   : { *(.data1) }
diff --git a/arch/sparc64/kernel/vmlinux.lds.S b/arch/sparc64/kernel/vmlinux.lds.S
index 13fa2a2..fb648de 100644
--- a/arch/sparc64/kernel/vmlinux.lds.S
+++ b/arch/sparc64/kernel/vmlinux.lds.S
@@ -14,7 +14,7 @@ SECTIONS
   .text 0x0000000000404000 :
   {
     _text = .;
-    *(.text)
+    TEXT_TEXT
     SCHED_TEXT
     LOCK_TEXT
     KPROBES_TEXT
@@ -27,7 +27,7 @@ SECTIONS
 
   .data    :
   {
-    *(.data)
+    DATA_DATA
     CONSTRUCTORS
   }
   .data1   : { *(.data1) }
diff --git a/arch/um/kernel/dyn.lds.S b/arch/um/kernel/dyn.lds.S
index 87a4e44..2454774 100644
--- a/arch/um/kernel/dyn.lds.S
+++ b/arch/um/kernel/dyn.lds.S
@@ -62,7 +62,7 @@ SECTIONS
   } =0x90909090
   .plt            : { *(.plt) }
   .text           : {
-    *(.text)
+    TEXT_TEXT
     SCHED_TEXT
     LOCK_TEXT
     *(.fixup)
@@ -99,7 +99,8 @@ SECTIONS
     *(.data.init_task)
     . = ALIGN(KERNEL_STACK_SIZE);
     *(.data.init_irqstack)
-    *(.data .data.* .gnu.linkonce.d.*)
+    DATA_DATA
+    *(.data.* .gnu.linkonce.d.*)
     SORT(CONSTRUCTORS)
   }
   .data1          : { *(.data1) }
diff --git a/arch/um/kernel/uml.lds.S b/arch/um/kernel/uml.lds.S
index bc59f97..307b937 100644
--- a/arch/um/kernel/uml.lds.S
+++ b/arch/um/kernel/uml.lds.S
@@ -37,7 +37,7 @@ SECTIONS
 
   .text      :
   {
-    *(.text)
+    TEXT_TEXT
     SCHED_TEXT
     LOCK_TEXT
     *(.fixup)
@@ -61,7 +61,7 @@ SECTIONS
     *(.data.init_task)
     . = ALIGN(KERNEL_STACK_SIZE);
     *(.data.init_irqstack)
-    *(.data)
+    DATA_DATA
     *(.gnu.linkonce.d*)
     CONSTRUCTORS
   }
diff --git a/arch/um/os-Linux/start_up.c b/arch/um/os-Linux/start_up.c
index 79471f8..3fc13fa 100644
--- a/arch/um/os-Linux/start_up.c
+++ b/arch/um/os-Linux/start_up.c
@@ -144,9 +144,7 @@ static int stop_ptraced_child(int pid, void *stack, int exitcode,
 		int exit_with = WEXITSTATUS(status);
 		if (exit_with == 2)
 			non_fatal("check_ptrace : child exited with status 2. "
-				  "Serious trouble happening! Try updating "
-				  "your host skas patch!\nDisabling SYSEMU "
-				  "support.");
+				  "\nDisabling SYSEMU support.\n");
 		non_fatal("check_ptrace : child exited with exitcode %d, while "
 			  "expecting %d; status 0x%x\n", exit_with,
 			  exitcode, status);
@@ -209,6 +207,7 @@ __uml_setup("nosysemu", nosysemu_cmd_param,
 static void __init check_sysemu(void)
 {
 	void *stack;
+	unsigned long regs[MAX_REG_NR];
 	int pid, n, status, count=0;
 
 	non_fatal("Checking syscall emulation patch for ptrace...");
@@ -225,11 +224,20 @@ static void __init check_sysemu(void)
 		fatal("check_sysemu : expected SIGTRAP, got status = %d",
 		      status);
 
-	n = ptrace(PTRACE_POKEUSR, pid, PT_SYSCALL_RET_OFFSET,
-		   os_getpid());
-	if(n < 0)
-		fatal_perror("check_sysemu : failed to modify system call "
-			     "return");
+	if(ptrace(PTRACE_GETREGS, pid, 0, regs) < 0)
+		fatal_perror("check_sysemu : PTRACE_GETREGS failed");
+	if(PT_SYSCALL_NR(regs) != __NR_getpid){
+		non_fatal("check_sysemu got system call number %d, "
+			  "expected %d...", PT_SYSCALL_NR(regs), __NR_getpid);
+		goto fail;
+	}
+
+	n = ptrace(PTRACE_POKEUSR, pid, PT_SYSCALL_RET_OFFSET, os_getpid());
+	if(n < 0){
+		non_fatal("check_sysemu : failed to modify system call "
+			  "return");
+		goto fail;
+	}
 
 	if (stop_ptraced_child(pid, stack, 0, 0) < 0)
 		goto fail_stopped;
diff --git a/arch/v850/kernel/vmlinux.lds.S b/arch/v850/kernel/vmlinux.lds.S
index 3563082..6172599 100644
--- a/arch/v850/kernel/vmlinux.lds.S
+++ b/arch/v850/kernel/vmlinux.lds.S
@@ -92,7 +92,7 @@
 #define TEXT_CONTENTS							      \
 		_text = .;						      \
 		__stext = . ;						      \
-        	*(.text)						      \
+		TEXT_TEXT						      \
 		SCHED_TEXT						      \
 			*(.exit.text)	/* 2.5 convention */		      \
 			*(.text.exit)	/* 2.4 convention */		      \
@@ -113,7 +113,7 @@
 /* Kernel data segment.  */
 #define DATA_CONTENTS							      \
 		__sdata = . ;						      \
-        	*(.data)						      \
+		DATA_DATA						      \
 			*(.exit.data)	/* 2.5 convention */		      \
 			*(.data.exit)	/* 2.4 convention */		      \
 		. = ALIGN (16) ;					      \
diff --git a/arch/x86_64/Kconfig b/arch/x86_64/Kconfig
index 145bb82..5ce9443 100644
--- a/arch/x86_64/Kconfig
+++ b/arch/x86_64/Kconfig
@@ -428,12 +428,15 @@ config NR_CPUS
 	  memory in the static kernel configuration.
 
 config HOTPLUG_CPU
-	bool "Support for hot-pluggable CPUs (EXPERIMENTAL)"
+	bool "Support for suspend on SMP and hot-pluggable CPUs (EXPERIMENTAL)"
 	depends on SMP && HOTPLUG && EXPERIMENTAL
 	help
 		Say Y here to experiment with turning CPUs off and on.  CPUs
 		can be controlled through /sys/devices/system/cpu/cpu#.
-		Say N if you want to disable CPU hotplug.
+		This is also required for suspend/hibernation on SMP systems.
+
+		Say N if you want to disable CPU hotplug and don't need to
+		suspend.
 
 config ARCH_ENABLE_MEMORY_HOTPLUG
 	def_bool y
diff --git a/arch/x86_64/defconfig b/arch/x86_64/defconfig
index 941a7e3..40178e5 100644
--- a/arch/x86_64/defconfig
+++ b/arch/x86_64/defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.21-git3
-# Tue May  1 07:30:48 2007
+# Linux kernel version: 2.6.22-rc2
+# Mon May 21 13:23:40 2007
 #
 CONFIG_X86_64=y
 CONFIG_64BIT=y
@@ -53,6 +53,7 @@ CONFIG_POSIX_MQUEUE=y
 # CONFIG_AUDIT is not set
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
 # CONFIG_CPUSETS is not set
 CONFIG_SYSFS_DEPRECATED=y
 # CONFIG_RELAY is not set
@@ -72,14 +73,19 @@ CONFIG_BUG=y
 CONFIG_ELF_CORE=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
-CONFIG_SLAB=y
 CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
 CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
-# CONFIG_SLOB is not set
 
 #
 # Loadable module support
@@ -118,11 +124,11 @@ CONFIG_X86_PC=y
 # CONFIG_X86_VSMP is not set
 # CONFIG_MK8 is not set
 # CONFIG_MPSC is not set
-CONFIG_MCORE2=y
-# CONFIG_GENERIC_CPU is not set
-CONFIG_X86_L1_CACHE_BYTES=64
-CONFIG_X86_L1_CACHE_SHIFT=6
-CONFIG_X86_INTERNODE_CACHE_BYTES=64
+# CONFIG_MCORE2 is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=128
+CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_X86_INTERNODE_CACHE_BYTES=128
 CONFIG_X86_TSC=y
 CONFIG_X86_GOOD_APIC=y
 # CONFIG_MICROCODE is not set
@@ -174,7 +180,7 @@ CONFIG_X86_MCE_INTEL=y
 CONFIG_X86_MCE_AMD=y
 # CONFIG_KEXEC is not set
 # CONFIG_CRASH_DUMP is not set
-# CONFIG_RELOCATABLE is not set
+CONFIG_RELOCATABLE=y
 CONFIG_PHYSICAL_START=0x200000
 CONFIG_SECCOMP=y
 # CONFIG_CC_STACKPROTECTOR is not set
@@ -242,7 +248,7 @@ CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
 # CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
 
 #
 # CPUFreq processor drivers
@@ -266,6 +272,7 @@ CONFIG_PCI_DIRECT=y
 CONFIG_PCI_MMCONFIG=y
 CONFIG_PCIEPORTBUS=y
 CONFIG_PCIEAER=y
+CONFIG_ARCH_SUPPORTS_MSI=y
 CONFIG_PCI_MSI=y
 # CONFIG_PCI_DEBUG is not set
 # CONFIG_HT_IRQ is not set
@@ -274,10 +281,6 @@ CONFIG_PCI_MSI=y
 # PCCARD (PCMCIA/CardBus) support
 #
 # CONFIG_PCCARD is not set
-
-#
-# PCI Hotplug Support
-#
 # CONFIG_HOTPLUG_PCI is not set
 
 #
@@ -395,7 +398,9 @@ CONFIG_IPV6_SIT=y
 #
 # CONFIG_CFG80211 is not set
 # CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
 # CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
 
 #
 # Device Drivers
@@ -458,14 +463,12 @@ CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
 # Misc devices
 #
 # CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
 # CONFIG_SGI_IOC4 is not set
 # CONFIG_TIFM_CORE is not set
 # CONFIG_SONY_LAPTOP is not set
 # CONFIG_THINKPAD_ACPI is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
+# CONFIG_BLINK is not set
 CONFIG_IDE=y
 CONFIG_BLK_DEV_IDE=y
 
@@ -482,6 +485,7 @@ CONFIG_BLK_DEV_IDECD=y
 # CONFIG_BLK_DEV_IDESCSI is not set
 CONFIG_BLK_DEV_IDEACPI=y
 # CONFIG_IDE_TASK_IOCTL is not set
+CONFIG_IDE_PROC_FS=y
 
 #
 # IDE chipset support/bugfixes
@@ -491,6 +495,7 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPNP is not set
 CONFIG_BLK_DEV_IDEPCI=y
 # CONFIG_IDEPCI_SHARE_IRQ is not set
+CONFIG_IDEPCI_PCIBUS_ORDER=y
 # CONFIG_BLK_DEV_OFFBOARD is not set
 # CONFIG_BLK_DEV_GENERIC is not set
 # CONFIG_BLK_DEV_OPTI621 is not set
@@ -556,6 +561,7 @@ CONFIG_CHR_DEV_SG=y
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
 # CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
 
 #
 # SCSI Transports
@@ -579,15 +585,16 @@ CONFIG_SCSI_SAS_ATTRS=y
 CONFIG_SCSI_AIC79XX=y
 CONFIG_AIC79XX_CMDS_PER_DEVICE=32
 CONFIG_AIC79XX_RESET_DELAY_MS=4000
-# CONFIG_AIC79XX_ENABLE_RD_STRM is not set
 # CONFIG_AIC79XX_DEBUG_ENABLE is not set
 CONFIG_AIC79XX_DEBUG_MASK=0
 # CONFIG_AIC79XX_REG_PRETTY_PRINT is not set
 # CONFIG_SCSI_AIC94XX is not set
 # CONFIG_SCSI_ARCMSR is not set
-# CONFIG_MEGARAID_NEWGEN is not set
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=y
+CONFIG_MEGARAID_MAILBOX=y
 # CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_MEGARAID_SAS is not set
+CONFIG_MEGARAID_SAS=y
 # CONFIG_SCSI_HPTIOP is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -609,12 +616,9 @@ CONFIG_AIC79XX_DEBUG_MASK=0
 # CONFIG_SCSI_DEBUG is not set
 # CONFIG_SCSI_ESP_CORE is not set
 # CONFIG_SCSI_SRP is not set
-
-#
-# Serial ATA (prod) and Parallel ATA (experimental) drivers
-#
 CONFIG_ATA=y
 # CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_ACPI=y
 CONFIG_SATA_AHCI=y
 CONFIG_SATA_SVW=y
 CONFIG_ATA_PIIX=y
@@ -631,7 +635,6 @@ CONFIG_SATA_SIL=y
 CONFIG_SATA_VIA=y
 # CONFIG_SATA_VITESSE is not set
 # CONFIG_SATA_INIC162X is not set
-CONFIG_SATA_ACPI=y
 # CONFIG_PATA_ALI is not set
 # CONFIG_PATA_AMD is not set
 # CONFIG_PATA_ARTOP is not set
@@ -681,6 +684,7 @@ CONFIG_BLK_DEV_DM=y
 # CONFIG_DM_MIRROR is not set
 # CONFIG_DM_ZERO is not set
 # CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
 
 #
 # Fusion MPT device support
@@ -688,13 +692,14 @@ CONFIG_BLK_DEV_DM=y
 CONFIG_FUSION=y
 CONFIG_FUSION_SPI=y
 # CONFIG_FUSION_FC is not set
-# CONFIG_FUSION_SAS is not set
+CONFIG_FUSION_SAS=y
 CONFIG_FUSION_MAX_SGE=128
 # CONFIG_FUSION_CTL is not set
 
 #
 # IEEE 1394 (FireWire) support
 #
+# CONFIG_FIREWIRE is not set
 CONFIG_IEEE1394=y
 
 #
@@ -705,10 +710,7 @@ CONFIG_IEEE1394=y
 #
 # Controllers
 #
-
-#
-# Texas Instruments PCILynx requires I2C
-#
+# CONFIG_IEEE1394_PCILYNX is not set
 CONFIG_IEEE1394_OHCI1394=y
 
 #
@@ -725,11 +727,7 @@ CONFIG_IEEE1394_RAWIO=y
 # I2O device support
 #
 # CONFIG_I2O is not set
-
-#
-# Macintosh device drivers
-#
-# CONFIG_MAC_EMUMOUSEBTN is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
 
 #
 # Network device support
@@ -745,10 +743,6 @@ CONFIG_TUN=y
 # ARCnet devices
 #
 # CONFIG_ARCNET is not set
-
-#
-# PHY device support
-#
 # CONFIG_PHYLIB is not set
 
 #
@@ -779,8 +773,7 @@ CONFIG_TULIP=y
 # CONFIG_HP100 is not set
 CONFIG_NET_PCI=y
 # CONFIG_PCNET32 is not set
-CONFIG_AMD8111_ETH=y
-# CONFIG_AMD8111E_NAPI is not set
+# CONFIG_AMD8111_ETH is not set
 # CONFIG_ADAPTEC_STARFIRE is not set
 CONFIG_B44=y
 CONFIG_FORCEDETH=y
@@ -802,10 +795,7 @@ CONFIG_8139TOO=y
 # CONFIG_SUNDANCE is not set
 # CONFIG_VIA_RHINE is not set
 # CONFIG_SC92031 is not set
-
-#
-# Ethernet (1000 Mbit)
-#
+CONFIG_NETDEV_1000=y
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
 CONFIG_E1000=y
@@ -824,10 +814,7 @@ CONFIG_TIGON3=y
 CONFIG_BNX2=y
 # CONFIG_QLA3XXX is not set
 # CONFIG_ATL1 is not set
-
-#
-# Ethernet (10000 Mbit)
-#
+CONFIG_NETDEV_10000=y
 # CONFIG_CHELSIO_T1 is not set
 # CONFIG_CHELSIO_T3 is not set
 # CONFIG_IXGB is not set
@@ -835,6 +822,7 @@ CONFIG_S2IO=m
 # CONFIG_S2IO_NAPI is not set
 # CONFIG_MYRI10GE is not set
 # CONFIG_NETXEN_NIC is not set
+# CONFIG_MLX4_CORE is not set
 
 #
 # Token Ring devices
@@ -848,8 +836,14 @@ CONFIG_S2IO=m
 # CONFIG_WLAN_80211 is not set
 
 #
-# Wan interfaces
+# USB Network Adapters
 #
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET_MII is not set
+# CONFIG_USB_USBNET is not set
 # CONFIG_WAN is not set
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
@@ -902,9 +896,17 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_STOWAWAY is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
 # CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
 # CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
 
@@ -954,10 +956,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 # IPMI
 #
 # CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
 # CONFIG_WATCHDOG is not set
 CONFIG_HW_RANDOM=y
 CONFIG_HW_RANDOM_INTEL=y
@@ -965,7 +963,6 @@ CONFIG_HW_RANDOM_AMD=y
 # CONFIG_HW_RANDOM_GEODE is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
 CONFIG_AGP=y
@@ -988,11 +985,58 @@ CONFIG_HPET_MMAP=y
 #
 # CONFIG_TCG_TPM is not set
 # CONFIG_TELCLOCK is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
 
 #
 # SPI support
@@ -1004,12 +1048,58 @@ CONFIG_HPET_MMAP=y
 # Dallas's 1-wire bus
 #
 # CONFIG_W1 is not set
-
-#
-# Hardware Monitoring support
-#
-# CONFIG_HWMON is not set
+CONFIG_HWMON=y
 # CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+CONFIG_SENSORS_CORETEMP=y
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+CONFIG_SENSORS_SMSC47B397=m
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
 
 #
 # Multifunction device drivers
@@ -1020,17 +1110,20 @@ CONFIG_HPET_MMAP=y
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-# CONFIG_DVB is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_DAB=y
 # CONFIG_USB_DABUSB is not set
 
 #
 # Graphics support
 #
 # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
 # CONFIG_FB is not set
 
 #
@@ -1056,14 +1149,10 @@ CONFIG_SOUND=y
 # Open Sound System
 #
 CONFIG_SOUND_PRIME=y
-CONFIG_OBSOLETE_OSS=y
-# CONFIG_SOUND_BT878 is not set
-# CONFIG_SOUND_ES1371 is not set
-CONFIG_SOUND_ICH=y
+# CONFIG_OSS_OBSOLETE is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
-# CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
 
 #
@@ -1142,37 +1231,10 @@ CONFIG_USB_STORAGE=y
 # CONFIG_USB_LIBUSUAL is not set
 
 #
-# USB Input Devices
-#
-# CONFIG_USB_AIPTEK is not set
-# CONFIG_USB_WACOM is not set
-# CONFIG_USB_ACECAD is not set
-# CONFIG_USB_KBTAB is not set
-# CONFIG_USB_POWERMATE is not set
-# CONFIG_USB_TOUCHSCREEN is not set
-# CONFIG_USB_YEALINK is not set
-# CONFIG_USB_XPAD is not set
-# CONFIG_USB_ATI_REMOTE is not set
-# CONFIG_USB_ATI_REMOTE2 is not set
-# CONFIG_USB_KEYSPAN_REMOTE is not set
-# CONFIG_USB_APPLETOUCH is not set
-# CONFIG_USB_GTCO is not set
-
-#
 # USB Imaging devices
 #
 # CONFIG_USB_MDC800 is not set
 # CONFIG_USB_MICROTEK is not set
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_USBNET_MII is not set
-# CONFIG_USB_USBNET is not set
 CONFIG_USB_MON=y
 
 #
@@ -1216,10 +1278,6 @@ CONFIG_USB_MON=y
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
-
-#
-# MMC/SD Card support
-#
 # CONFIG_MMC is not set
 
 #
@@ -1264,10 +1322,6 @@ CONFIG_USB_MON=y
 #
 
 #
-# Auxiliary Display support
-#
-
-#
 # Virtualization
 #
 # CONFIG_KVM is not set
@@ -1385,6 +1439,7 @@ CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
@@ -1468,10 +1523,9 @@ CONFIG_DEBUG_FS=y
 # CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
-CONFIG_LOG_BUF_SHIFT=18
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
-CONFIG_TIMER_STATS=y
+# CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
@@ -1487,6 +1541,8 @@ CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_LIST is not set
 # CONFIG_FRAME_POINTER is not set
+CONFIG_UNWIND_INFO=y
+CONFIG_STACK_UNWIND=y
 # CONFIG_FORCED_INLINING is not set
 # CONFIG_RCU_TORTURE_TEST is not set
 # CONFIG_LKDTM is not set
@@ -1513,9 +1569,11 @@ CONFIG_DEBUG_STACKOVERFLOW=y
 CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_PLIST=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/x86_64/ia32/mmap32.c b/arch/x86_64/ia32/mmap32.c
index 079f413..e4b84b4 100644
--- a/arch/x86_64/ia32/mmap32.c
+++ b/arch/x86_64/ia32/mmap32.c
@@ -29,6 +29,7 @@
 #include <linux/personality.h>
 #include <linux/mm.h>
 #include <linux/random.h>
+#include <linux/sched.h>
 
 /*
  * Top of mmap area (just below the process stack).
diff --git a/arch/x86_64/kernel/early_printk.c b/arch/x86_64/kernel/early_printk.c
index 56eaa25..296d2b0 100644
--- a/arch/x86_64/kernel/early_printk.c
+++ b/arch/x86_64/kernel/early_printk.c
@@ -91,9 +91,9 @@ static int early_serial_putc(unsigned char ch)
 static void early_serial_write(struct console *con, const char *s, unsigned n)
 {
 	while (*s && n-- > 0) {
-		early_serial_putc(*s);
 		if (*s == '\n')
 			early_serial_putc('\r');
+		early_serial_putc(*s);
 		s++;
 	}
 }
diff --git a/arch/x86_64/kernel/k8.c b/arch/x86_64/kernel/k8.c
index bc11b32..7377ccb 100644
--- a/arch/x86_64/kernel/k8.c
+++ b/arch/x86_64/kernel/k8.c
@@ -39,10 +39,10 @@ int cache_k8_northbridges(void)
 {
 	int i;
 	struct pci_dev *dev;
+
 	if (num_k8_northbridges)
 		return 0;
 
-	num_k8_northbridges = 0;
 	dev = NULL;
 	while ((dev = next_k8_northbridge(dev)) != NULL)
 		num_k8_northbridges++;
@@ -52,6 +52,11 @@ int cache_k8_northbridges(void)
 	if (!k8_northbridges)
 		return -ENOMEM;
 
+	if (!num_k8_northbridges) {
+		k8_northbridges[0] = NULL;
+		return 0;
+	}
+
 	flush_words = kmalloc(num_k8_northbridges * sizeof(u32), GFP_KERNEL);
 	if (!flush_words) {
 		kfree(k8_northbridges);
diff --git a/arch/x86_64/kernel/reboot.c b/arch/x86_64/kernel/reboot.c
index c116b54..7503068 100644
--- a/arch/x86_64/kernel/reboot.c
+++ b/arch/x86_64/kernel/reboot.c
@@ -8,6 +8,7 @@
 #include <linux/string.h>
 #include <linux/pm.h>
 #include <linux/kdebug.h>
+#include <linux/sched.h>
 #include <asm/io.h>
 #include <asm/delay.h>
 #include <asm/hw_irq.h>
diff --git a/arch/x86_64/kernel/vmlinux.lds.S b/arch/x86_64/kernel/vmlinux.lds.S
index 88cfa50..dbccfda 100644
--- a/arch/x86_64/kernel/vmlinux.lds.S
+++ b/arch/x86_64/kernel/vmlinux.lds.S
@@ -31,7 +31,7 @@ SECTIONS
 	*(.bootstrap.text)
 	_stext = .;
 	/* Then the rest */
-	*(.text)
+	TEXT_TEXT
 	SCHED_TEXT
 	LOCK_TEXT
 	KPROBES_TEXT
@@ -55,7 +55,7 @@ SECTIONS
   . = ALIGN(PAGE_SIZE);        /* Align data segment to page size boundary */
 				/* Data */
   .data : AT(ADDR(.data) - LOAD_OFFSET) {
-	*(.data)
+	DATA_DATA
 	CONSTRUCTORS
 	} :data
 
diff --git a/arch/x86_64/kernel/vsyscall.c b/arch/x86_64/kernel/vsyscall.c
index 51d4c6f..57660d5 100644
--- a/arch/x86_64/kernel/vsyscall.c
+++ b/arch/x86_64/kernel/vsyscall.c
@@ -175,10 +175,13 @@ int __vsyscall(0) vgettimeofday(struct timeval * tv, struct timezone * tz)
  * unlikely */
 time_t __vsyscall(1) vtime(time_t *t)
 {
+	struct timeval tv;
 	time_t result;
 	if (unlikely(!__vsyscall_gtod_data.sysctl_enabled))
 		return time_syscall(t);
-	result = __vsyscall_gtod_data.wall_time_sec;
+
+	vgettimeofday(&tv, 0);
+	result = tv.tv_sec;
 	if (t)
 		*t = result;
 	return result;
diff --git a/arch/xtensa/kernel/vmlinux.lds.S b/arch/xtensa/kernel/vmlinux.lds.S
index 4fbd66a..4b7b4ff 100644
--- a/arch/xtensa/kernel/vmlinux.lds.S
+++ b/arch/xtensa/kernel/vmlinux.lds.S
@@ -84,7 +84,8 @@ SECTIONS
   {
     /* The .head.text section must be the first section! */
     *(.head.text)
-    *(.literal .text)
+    *(.literal)
+    TEXT_TEXT
     *(.srom.text)
     VMLINUX_SYMBOL(__sched_text_start) = .;
     *(.sched.literal .sched.text)
@@ -144,7 +145,8 @@ SECTIONS
   _fdata = .;
   .data :
   {
-    *(.data) CONSTRUCTORS
+    DATA_DATA
+    CONSTRUCTORS
     . = ALIGN(XCHAL_ICACHE_LINESIZE);
     *(.data.cacheline_aligned)
   }
diff --git a/block/genhd.c b/block/genhd.c
index 93a2cf6..863a8c0 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -423,7 +423,10 @@ static ssize_t disk_size_read(struct gendisk * disk, char *page)
 {
 	return sprintf(page, "%llu\n", (unsigned long long)get_capacity(disk));
 }
-
+static ssize_t disk_capability_read(struct gendisk *disk, char *page)
+{
+	return sprintf(page, "%x\n", disk->flags);
+}
 static ssize_t disk_stats_read(struct gendisk * disk, char *page)
 {
 	preempt_disable();
@@ -466,6 +469,10 @@ static struct disk_attribute disk_attr_size = {
 	.attr = {.name = "size", .mode = S_IRUGO },
 	.show	= disk_size_read
 };
+static struct disk_attribute disk_attr_capability = {
+	.attr = {.name = "capability", .mode = S_IRUGO },
+	.show	= disk_capability_read
+};
 static struct disk_attribute disk_attr_stat = {
 	.attr = {.name = "stat", .mode = S_IRUGO },
 	.show	= disk_stats_read
@@ -506,6 +513,7 @@ static struct attribute * default_attrs[] = {
 	&disk_attr_removable.attr,
 	&disk_attr_size.attr,
 	&disk_attr_stat.attr,
+	&disk_attr_capability.attr,
 #ifdef CONFIG_FAIL_MAKE_REQUEST
 	&disk_attr_fail.attr,
 #endif
@@ -688,6 +696,27 @@ struct seq_operations diskstats_op = {
 	.show	= diskstats_show
 };
 
+static void media_change_notify_thread(struct work_struct *work)
+{
+	struct gendisk *gd = container_of(work, struct gendisk, async_notify);
+	char event[] = "MEDIA_CHANGE=1";
+	char *envp[] = { event, NULL };
+
+	/*
+	 * set enviroment vars to indicate which event this is for
+	 * so that user space will know to go check the media status.
+	 */
+	kobject_uevent_env(&gd->kobj, KOBJ_CHANGE, envp);
+	put_device(gd->driverfs_dev);
+}
+
+void genhd_media_change_notify(struct gendisk *disk)
+{
+	get_device(disk->driverfs_dev);
+	schedule_work(&disk->async_notify);
+}
+EXPORT_SYMBOL_GPL(genhd_media_change_notify);
+
 struct gendisk *alloc_disk(int minors)
 {
 	return alloc_disk_node(minors, -1);
@@ -717,6 +746,8 @@ struct gendisk *alloc_disk_node(int minors, int node_id)
 		kobj_set_kset_s(disk,block_subsys);
 		kobject_init(&disk->kobj);
 		rand_initialize_disk(disk);
+		INIT_WORK(&disk->async_notify,
+			media_change_notify_thread);
 	}
 	return disk;
 }
diff --git a/crypto/api.c b/crypto/api.c
index 55af8bb..33734fd 100644
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -48,8 +48,10 @@ EXPORT_SYMBOL_GPL(crypto_mod_get);
 
 void crypto_mod_put(struct crypto_alg *alg)
 {
+	struct module *module = alg->cra_module;
+
 	crypto_alg_put(alg);
-	module_put(alg->cra_module);
+	module_put(module);
 }
 EXPORT_SYMBOL_GPL(crypto_mod_put);
 
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index ad1f59c..b4a8d60 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -132,7 +132,7 @@ config SATA_SIS
 	depends on PCI
 	select PATA_SIS
 	help
-	  This option enables support for SiS Serial ATA on 
+	  This option enables support for SiS Serial ATA on
 	  SiS 964/965/966/180 and Parallel ATA on SiS 180.
 	  The PATA support for SiS 180 requires additionally to
 	  enable the PATA_SIS driver in the config.
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index e00e1b9..7baeaff 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -46,7 +46,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"ahci"
-#define DRV_VERSION	"2.1"
+#define DRV_VERSION	"2.2"
 
 
 enum {
@@ -170,6 +170,7 @@ enum {
 	AHCI_FLAG_IGN_IRQ_IF_ERR	= (1 << 25), /* ignore IRQ_IF_ERR */
 	AHCI_FLAG_HONOR_PI		= (1 << 26), /* honor PORTS_IMPL */
 	AHCI_FLAG_IGN_SERR_INTERNAL	= (1 << 27), /* ignore SERR_INTERNAL */
+	AHCI_FLAG_32BIT_ONLY		= (1 << 28), /* force 32bit */
 
 	AHCI_FLAG_COMMON		= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
 					  ATA_FLAG_MMIO | ATA_FLAG_PIO_DMA |
@@ -354,7 +355,8 @@ static const struct ata_port_info ahci_port_info[] = {
 	/* board_ahci_sb600 */
 	{
 		.flags		= AHCI_FLAG_COMMON |
-				  AHCI_FLAG_IGN_SERR_INTERNAL,
+				  AHCI_FLAG_IGN_SERR_INTERNAL |
+				  AHCI_FLAG_32BIT_ONLY,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
 		.port_ops	= &ahci_ops,
@@ -492,6 +494,13 @@ static void ahci_save_initial_config(struct pci_dev *pdev,
 	hpriv->saved_cap = cap = readl(mmio + HOST_CAP);
 	hpriv->saved_port_map = port_map = readl(mmio + HOST_PORTS_IMPL);
 
+	/* some chips lie about 64bit support */
+	if ((cap & HOST_CAP_64) && (pi->flags & AHCI_FLAG_32BIT_ONLY)) {
+		dev_printk(KERN_INFO, &pdev->dev,
+			   "controller can't do 64bit DMA, forcing 32bit\n");
+		cap &= ~HOST_CAP_64;
+	}
+
 	/* fixup zero port_map */
 	if (!port_map) {
 		port_map = (1 << ahci_nr_ports(hpriv->cap)) - 1;
diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index c3d7532..7565f02 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "ata_generic"
-#define DRV_VERSION "0.2.11"
+#define DRV_VERSION "0.2.12"
 
 /*
  *	A generic parallel ATA driver using libata
diff --git a/drivers/ata/ata_piix.c b/drivers/ata/ata_piix.c
index 13b6b1d..9c07b88 100644
--- a/drivers/ata/ata_piix.c
+++ b/drivers/ata/ata_piix.c
@@ -155,7 +155,6 @@ struct piix_host_priv {
 static int piix_init_one (struct pci_dev *pdev,
 				    const struct pci_device_id *ent);
 static void piix_pata_error_handler(struct ata_port *ap);
-static void piix_sata_error_handler(struct ata_port *ap);
 static void piix_set_piomode (struct ata_port *ap, struct ata_device *adev);
 static void piix_set_dmamode (struct ata_port *ap, struct ata_device *adev);
 static void ich_set_dmamode (struct ata_port *ap, struct ata_device *adev);
@@ -364,7 +363,7 @@ static const struct ata_port_operations piix_sata_ops = {
 
 	.freeze			= ata_bmdma_freeze,
 	.thaw			= ata_bmdma_thaw,
-	.error_handler		= piix_sata_error_handler,
+	.error_handler		= ata_bmdma_error_handler,
 	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
 
 	.irq_handler		= ata_interrupt,
@@ -579,6 +578,7 @@ static const struct ich_laptop ich_laptop[] = {
 	{ 0x27DF, 0x0005, 0x0280 },	/* ICH7 on Acer 5602WLMi */
 	{ 0x27DF, 0x1025, 0x0110 },	/* ICH7 on Acer 3682WLMi */
 	{ 0x27DF, 0x1043, 0x1267 },	/* ICH7 on Asus W5F */
+	{ 0x24CA, 0x1025, 0x0061 },	/* ICH4 on ACER Aspire 2023WLMi */
 	/* end marker */
 	{ 0, }
 };
@@ -641,12 +641,6 @@ static void piix_pata_error_handler(struct ata_port *ap)
 			   ata_std_postreset);
 }
 
-static void piix_sata_error_handler(struct ata_port *ap)
-{
-	ata_bmdma_drive_eh(ap, ata_std_prereset, ata_std_softreset, NULL,
-			   ata_std_postreset);
-}
-
 /**
  *	piix_set_piomode - Initialize host controller PATA PIO timings
  *	@ap: Port whose timings we are configuring
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index d3ea7f5..3ca9c61 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -59,7 +59,7 @@
 
 #include "libata.h"
 
-#define DRV_VERSION	"2.20"	/* must be exactly four chars */
+#define DRV_VERSION	"2.21"	/* must be exactly four chars */
 
 
 /* debounce timing parameters in msecs { interval, duration, timeout } */
@@ -977,7 +977,7 @@ static u64 ata_hpa_resize(struct ata_device *dev)
 {
 	u64 sectors = dev->n_sectors;
 	u64 hpa_sectors;
-	
+
 	if (ata_id_has_lba48(dev->id))
 		hpa_sectors = ata_read_native_max_address_ext(dev);
 	else
@@ -1588,7 +1588,7 @@ unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd)
  *	Check if the current speed of the device requires IORDY. Used
  *	by various controllers for chip configuration.
  */
- 
+
 unsigned int ata_pio_need_iordy(const struct ata_device *adev)
 {
 	/* Controller doesn't support  IORDY. Probably a pointless check
@@ -1611,7 +1611,7 @@ unsigned int ata_pio_need_iordy(const struct ata_device *adev)
  *	Compute the highest mode possible if we are not using iordy. Return
  *	-1 if no iordy mode is available.
  */
- 
+
 static u32 ata_pio_mask_no_iordy(const struct ata_device *adev)
 {
 	/* If we have no drive specific rule, then PIO 2 is non IORDY */
@@ -2663,7 +2663,7 @@ int ata_timing_compute(struct ata_device *adev, unsigned short speed,
 		t->active += (t->cycle - (t->active + t->recover)) / 2;
 		t->recover = t->cycle - t->active;
 	}
-	
+
 	/* In a few cases quantisation may produce enough errors to
 	   leave t->cycle too low for the sum of active and recovery
 	   if so we must correct this */
@@ -2893,9 +2893,6 @@ int ata_do_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev)
 	if (used_dma && (ap->host->flags & ATA_HOST_SIMPLEX))
 		ap->host->simplex_claimed = ap;
 
-	/* step5: chip specific finalisation */
-	if (ap->ops->post_set_mode)
-		ap->ops->post_set_mode(ap);
  out:
 	if (rc)
 		*r_failed_dev = dev;
@@ -3025,7 +3022,7 @@ int ata_wait_ready(struct ata_port *ap, unsigned long deadline)
 
 		if (!(status & ATA_BUSY))
 			return 0;
-		if (status == 0xff)
+		if (!ata_port_online(ap) && status == 0xff)
 			return -ENODEV;
 		if (time_after(now, deadline))
 			return -EBUSY;
@@ -3371,7 +3368,7 @@ int ata_std_prereset(struct ata_port *ap, unsigned long deadline)
 	 */
 	if (!(ap->flags & ATA_FLAG_SKIP_D2H_BSY) && !ata_port_offline(ap)) {
 		rc = ata_wait_ready(ap, deadline);
-		if (rc) {
+		if (rc && rc != -ENODEV) {
 			ata_port_printk(ap, KERN_WARNING, "device not ready "
 					"(errno=%d), forcing hardreset\n", rc);
 			ehc->i.action |= ATA_EH_HARDRESET;
@@ -3771,6 +3768,7 @@ static const struct ata_blacklist_entry ata_device_blacklist [] = {
 	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",NULL,ATA_HORKAGE_NODMA },
 	{ "_NEC DV5800A", 	NULL,		ATA_HORKAGE_NODMA },
 	{ "SAMSUNG CD-ROM SN-124","N001",	ATA_HORKAGE_NODMA },
+	{ "Seagate STT20000A", NULL,		ATA_HORKAGE_NODMA },
 
 	/* Weird ATAPI devices */
 	{ "TORiSAN DVD-ROM DRD-N216", NULL,	ATA_HORKAGE_MAX_SEC_128 |
diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c
index 5309c31..d807098 100644
--- a/drivers/ata/libata-eh.c
+++ b/drivers/ata/libata-eh.c
@@ -1009,7 +1009,7 @@ static unsigned int atapi_eh_request_sense(struct ata_queued_cmd *qc)
 	sense_buf[0] = 0x70;
 	sense_buf[2] = qc->result_tf.feature >> 4;
 
-	/* some devices time out if garbage left in tf */ 
+	/* some devices time out if garbage left in tf */
 	ata_tf_init(dev, &tf);
 
 	memset(cdb, 0, ATAPI_CDB_LEN);
diff --git a/drivers/ata/pata_artop.c b/drivers/ata/pata_artop.c
index 9861059..7b4810c 100644
--- a/drivers/ata/pata_artop.c
+++ b/drivers/ata/pata_artop.c
@@ -28,7 +28,7 @@
 #include <linux/ata.h>
 
 #define DRV_NAME	"pata_artop"
-#define DRV_VERSION	"0.4.2"
+#define DRV_VERSION	"0.4.3"
 
 /*
  *	The ARTOP has 33 Mhz and "over clocked" timing tables. Until we
@@ -99,7 +99,7 @@ static int artop6260_pre_reset(struct ata_port *ap, unsigned long deadline)
  *
  *	Identify the cable type for the ARTOp interface in question
  */
- 
+
 static int artop6260_cable_detect(struct ata_port *ap)
 {
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
diff --git a/drivers/ata/pata_cmd640.c b/drivers/ata/pata_cmd640.c
index ed00fa9..31cbf8d 100644
--- a/drivers/ata/pata_cmd640.c
+++ b/drivers/ata/pata_cmd640.c
@@ -107,7 +107,7 @@ static void cmd640_set_piomode(struct ata_port *ap, struct ata_device *adev)
 		pci_write_config_byte(pdev, arttim + 1, (t.active << 4) | t.recover);
 	} else {
 		/* Save the shared timings for channel, they will be loaded
-		   by qc_issue_prot. Reloading the setup time is expensive 
+		   by qc_issue_prot. Reloading the setup time is expensive
 		   so we keep a merged one loaded */
 		pci_read_config_byte(pdev, ARTIM23, &reg);
 		reg &= 0x3F;
@@ -231,7 +231,7 @@ static void cmd640_hardware_init(struct pci_dev *pdev)
 	pci_write_config_byte(pdev, CMDTIM, 0);
 	/* 512 byte bursts (sector) */
 	pci_write_config_byte(pdev, BRST, 0x40);
-	/* 
+	/*
 	 * A reporter a long time ago
 	 * Had problems with the data fifo
 	 * So don't run the risk
diff --git a/drivers/ata/pata_cmd64x.c b/drivers/ata/pata_cmd64x.c
index 2a79b33..320a5b1 100644
--- a/drivers/ata/pata_cmd64x.c
+++ b/drivers/ata/pata_cmd64x.c
@@ -31,7 +31,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "pata_cmd64x"
-#define DRV_VERSION "0.2.2"
+#define DRV_VERSION "0.2.3"
 
 /*
  * CMD64x specific registers definition.
diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 83bcc5b..1aabe15 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -41,7 +41,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_cs5520"
-#define DRV_VERSION	"0.6.4"
+#define DRV_VERSION	"0.6.5"
 
 struct pio_clocks
 {
diff --git a/drivers/ata/pata_cs5530.c b/drivers/ata/pata_cs5530.c
index 1b67923..848f030 100644
--- a/drivers/ata/pata_cs5530.c
+++ b/drivers/ata/pata_cs5530.c
@@ -35,7 +35,7 @@
 #include <linux/dmi.h>
 
 #define DRV_NAME	"pata_cs5530"
-#define DRV_VERSION	"0.7.2"
+#define DRV_VERSION	"0.7.3"
 
 static void __iomem *cs5530_port_base(struct ata_port *ap)
 {
diff --git a/drivers/ata/pata_cs5535.c b/drivers/ata/pata_cs5535.c
index f37d4cd..aa3256f 100644
--- a/drivers/ata/pata_cs5535.c
+++ b/drivers/ata/pata_cs5535.c
@@ -39,7 +39,7 @@
 #include <asm/msr.h>
 
 #define DRV_NAME	"cs5535"
-#define DRV_VERSION	"0.2.11"
+#define DRV_VERSION	"0.2.12"
 
 /*
  *	The Geode (Aka Athlon GX now) uses an internal MSR based
diff --git a/drivers/ata/pata_cypress.c b/drivers/ata/pata_cypress.c
index 27b9f29..d41a769 100644
--- a/drivers/ata/pata_cypress.c
+++ b/drivers/ata/pata_cypress.c
@@ -18,7 +18,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "pata_cypress"
-#define DRV_VERSION "0.1.4"
+#define DRV_VERSION "0.1.5"
 
 /* here are the offset definitions for the registers */
 
diff --git a/drivers/ata/pata_hpt366.c b/drivers/ata/pata_hpt366.c
index c6c8a8b..0c9cb60 100644
--- a/drivers/ata/pata_hpt366.c
+++ b/drivers/ata/pata_hpt366.c
@@ -220,32 +220,6 @@ static int hpt36x_cable_detect(struct ata_port *ap)
 	return ATA_CBL_PATA80;
 }
 
-static int hpt36x_pre_reset(struct ata_port *ap, unsigned long deadline)
-{
-	static const struct pci_bits hpt36x_enable_bits[] = {
-		{ 0x50, 1, 0x04, 0x04 },
-		{ 0x54, 1, 0x04, 0x04 }
-	};
-	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
-
-	if (!pci_test_config_bits(pdev, &hpt36x_enable_bits[ap->port_no]))
-		return -ENOENT;
-
-	return ata_std_prereset(ap, deadline);
-}
-
-/**
- *	hpt36x_error_handler	-	reset the hpt36x bus
- *	@ap: ATA port to reset
- *
- *	Perform the reset handling for the 366/368
- */
-
-static void hpt36x_error_handler(struct ata_port *ap)
-{
-	ata_bmdma_drive_eh(ap, hpt36x_pre_reset, ata_std_softreset, NULL, ata_std_postreset);
-}
-
 /**
  *	hpt366_set_piomode		-	PIO setup
  *	@ap: ATA interface
@@ -351,7 +325,7 @@ static struct ata_port_operations hpt366_port_ops = {
 
 	.freeze		= ata_bmdma_freeze,
 	.thaw		= ata_bmdma_thaw,
-	.error_handler	= hpt36x_error_handler,
+	.error_handler	= ata_bmdma_error_handler,
 	.post_internal_cmd = ata_bmdma_post_internal_cmd,
 	.cable_detect	= hpt36x_cable_detect,
 
diff --git a/drivers/ata/pata_hpt37x.c b/drivers/ata/pata_hpt37x.c
index 5a0a410..a54c174 100644
--- a/drivers/ata/pata_hpt37x.c
+++ b/drivers/ata/pata_hpt37x.c
@@ -961,7 +961,7 @@ static int hpt37x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 	u8 mcr1;
 	u32 freq;
 	int prefer_dpll = 1;
-	
+
 	unsigned long iobase = pci_resource_start(dev, 4);
 
 	const struct hpt_chip *chip_table;
@@ -1055,7 +1055,7 @@ static int hpt37x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 	 */
 
 	pci_write_config_byte(dev, 0x5b, 0x23);
-	
+
 	/*
 	 * HighPoint does this for HPT372A.
 	 * NOTE: This register is only writeable via I/O space.
@@ -1088,7 +1088,7 @@ static int hpt37x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 	 *	Turn the frequency check into a band and then find a timing
 	 *	table to match it.
 	 */
-	 
+
 	clock_slot = hpt37x_clock_slot(freq, chip_table->base);
 	if (chip_table->clocks[clock_slot] == NULL || prefer_dpll) {
 		/*
@@ -1099,11 +1099,11 @@ static int hpt37x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 		 */
 		unsigned int f_low, f_high;
 		int adjust;
-		
+
 		clock_slot = 2;
 		if (port->udma_mask & 0xE0)
 			clock_slot = 3;
-		
+
 		f_low = (MHz[clock_slot] * chip_table->base) / 192;
 		f_high = f_low + 2;
 
diff --git a/drivers/ata/pata_hpt3x2n.c b/drivers/ata/pata_hpt3x2n.c
index f25154a..e947433 100644
--- a/drivers/ata/pata_hpt3x2n.c
+++ b/drivers/ata/pata_hpt3x2n.c
@@ -521,8 +521,8 @@ static int hpt3x2n_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 			/* 371N if rev > 1 */
 			break;
 		case PCI_DEVICE_ID_TTI_HPT372:
-			/* 372N if rev >= 1*/
-			if (class_rev == 0)
+			/* 372N if rev >= 2*/
+			if (class_rev < 2)
 				return -ENODEV;
 			break;
 		case PCI_DEVICE_ID_TTI_HPT302:
diff --git a/drivers/ata/pata_hpt3x3.c b/drivers/ata/pata_hpt3x3.c
index bbabe79..8ce5e23 100644
--- a/drivers/ata/pata_hpt3x3.c
+++ b/drivers/ata/pata_hpt3x3.c
@@ -23,7 +23,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_hpt3x3"
-#define DRV_VERSION	"0.4.2"
+#define DRV_VERSION	"0.4.3"
 
 /**
  *	hpt3x3_set_piomode		-	PIO setup
diff --git a/drivers/ata/pata_isapnp.c b/drivers/ata/pata_isapnp.c
index d042efd..1f647b6 100644
--- a/drivers/ata/pata_isapnp.c
+++ b/drivers/ata/pata_isapnp.c
@@ -17,7 +17,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "pata_isapnp"
-#define DRV_VERSION "0.2.0"
+#define DRV_VERSION "0.2.1"
 
 static struct scsi_host_template isapnp_sht = {
 	.module			= THIS_MODULE,
diff --git a/drivers/ata/pata_it8213.c b/drivers/ata/pata_it8213.c
index a769952..95b0bb6 100644
--- a/drivers/ata/pata_it8213.c
+++ b/drivers/ata/pata_it8213.c
@@ -19,7 +19,7 @@
 #include <linux/ata.h>
 
 #define DRV_NAME	"pata_it8213"
-#define DRV_VERSION	"0.0.2"
+#define DRV_VERSION	"0.0.3"
 
 /**
  *	it8213_pre_reset	-	check for 40/80 pin
diff --git a/drivers/ata/pata_ixp4xx_cf.c b/drivers/ata/pata_ixp4xx_cf.c
index b994351..8d2bc1e 100644
--- a/drivers/ata/pata_ixp4xx_cf.c
+++ b/drivers/ata/pata_ixp4xx_cf.c
@@ -23,7 +23,7 @@
 #include <scsi/scsi_host.h>
 
 #define DRV_NAME	"pata_ixp4xx_cf"
-#define DRV_VERSION	"0.1.2"
+#define DRV_VERSION	"0.1.3"
 
 static int ixp4xx_set_mode(struct ata_port *ap, struct ata_device **error)
 {
diff --git a/drivers/ata/pata_jmicron.c b/drivers/ata/pata_jmicron.c
index 8d799e8..2af7ff8 100644
--- a/drivers/ata/pata_jmicron.c
+++ b/drivers/ata/pata_jmicron.c
@@ -19,7 +19,7 @@
 #include <linux/ata.h>
 
 #define DRV_NAME	"pata_jmicron"
-#define DRV_VERSION	"0.1.4"
+#define DRV_VERSION	"0.1.5"
 
 typedef enum {
 	PORT_PATA0 = 0,
diff --git a/drivers/ata/pata_legacy.c b/drivers/ata/pata_legacy.c
index 7070992..edffc25 100644
--- a/drivers/ata/pata_legacy.c
+++ b/drivers/ata/pata_legacy.c
@@ -64,7 +64,7 @@
 #include <linux/platform_device.h>
 
 #define DRV_NAME "pata_legacy"
-#define DRV_VERSION "0.5.4"
+#define DRV_VERSION "0.5.5"
 
 #define NR_HOST 6
 
diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 1f63848..cbb7866 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -22,7 +22,7 @@
 #include <linux/pata_platform.h>
 
 #define DRV_NAME "pata_platform"
-#define DRV_VERSION "0.1.2"
+#define DRV_VERSION "1.0"
 
 static int pio_mask = 1;
 
diff --git a/drivers/ata/pata_qdi.c b/drivers/ata/pata_qdi.c
index fb8c9e1..1998c19 100644
--- a/drivers/ata/pata_qdi.c
+++ b/drivers/ata/pata_qdi.c
@@ -26,7 +26,7 @@
 #include <linux/platform_device.h>
 
 #define DRV_NAME "pata_qdi"
-#define DRV_VERSION "0.3.0"
+#define DRV_VERSION "0.3.1"
 
 #define NR_HOST 4	/* Two 6580s */
 
diff --git a/drivers/ata/pata_rz1000.c b/drivers/ata/pata_rz1000.c
index 2bfd7ef..a3488b4 100644
--- a/drivers/ata/pata_rz1000.c
+++ b/drivers/ata/pata_rz1000.c
@@ -21,7 +21,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_rz1000"
-#define DRV_VERSION	"0.2.3"
+#define DRV_VERSION	"0.2.4"
 
 
 /**
diff --git a/drivers/ata/pata_sc1200.c b/drivers/ata/pata_sc1200.c
index 225013e..1233063 100644
--- a/drivers/ata/pata_sc1200.c
+++ b/drivers/ata/pata_sc1200.c
@@ -40,7 +40,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"sc1200"
-#define DRV_VERSION	"0.2.4"
+#define DRV_VERSION	"0.2.5"
 
 #define SC1200_REV_A	0x00
 #define SC1200_REV_B1	0x01
diff --git a/drivers/ata/pata_scc.c b/drivers/ata/pata_scc.c
index 844e53b..aa138d2 100644
--- a/drivers/ata/pata_scc.c
+++ b/drivers/ata/pata_scc.c
@@ -43,7 +43,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME		"pata_scc"
-#define DRV_VERSION		"0.1"
+#define DRV_VERSION		"0.2"
 
 #define PCI_DEVICE_ID_TOSHIBA_SCC_ATA		0x01b4
 
diff --git a/drivers/ata/pata_serverworks.c b/drivers/ata/pata_serverworks.c
index dee6e21..1e8f421 100644
--- a/drivers/ata/pata_serverworks.c
+++ b/drivers/ata/pata_serverworks.c
@@ -41,7 +41,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "pata_serverworks"
-#define DRV_VERSION "0.4.0"
+#define DRV_VERSION "0.4.1"
 
 #define SVWKS_CSB5_REVISION_NEW	0x92 /* min PCI_REVISION_ID for UDMA5 (A2.0) */
 #define SVWKS_CSB6_REVISION	0xa0 /* min PCI_REVISION_ID for UDMA4 (A1.0) */
diff --git a/drivers/ata/pata_sis.c b/drivers/ata/pata_sis.c
index f223126..ec3ae93 100644
--- a/drivers/ata/pata_sis.c
+++ b/drivers/ata/pata_sis.c
@@ -73,14 +73,14 @@ static int sis_short_ata40(struct pci_dev *dev)
 }
 
 /**
- *	sis_port_base		-	return PCI configuration base for dev
+ *	sis_old_port_base		-	return PCI configuration base for dev
  *	@adev: device
  *
  *	Returns the base of the PCI configuration registers for this port
  *	number.
  */
 
-static int sis_port_base(struct ata_device *adev)
+static int sis_old_port_base(struct ata_device *adev)
 {
 	return  0x40 + (4 * adev->ap->port_no) +  (2 * adev->devno);
 }
@@ -211,7 +211,7 @@ static void sis_set_fifo(struct ata_port *ap, struct ata_device *adev)
 static void sis_old_set_piomode (struct ata_port *ap, struct ata_device *adev)
 {
 	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
-	int port = sis_port_base(adev);
+	int port = sis_old_port_base(adev);
 	u8 t1, t2;
 	int speed = adev->pio_mode - XFER_PIO_0;
 
@@ -248,7 +248,7 @@ static void sis_old_set_piomode (struct ata_port *ap, struct ata_device *adev)
 static void sis_100_set_piomode (struct ata_port *ap, struct ata_device *adev)
 {
 	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
-	int port = sis_port_base(adev);
+	int port = sis_old_port_base(adev);
 	int speed = adev->pio_mode - XFER_PIO_0;
 
 	const u8 actrec[] = { 0x00, 0x67, 0x44, 0x33, 0x31 };
@@ -328,7 +328,7 @@ static void sis_old_set_dmamode (struct ata_port *ap, struct ata_device *adev)
 {
 	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
 	int speed = adev->dma_mode - XFER_MW_DMA_0;
-	int drive_pci = sis_port_base(adev);
+	int drive_pci = sis_old_port_base(adev);
 	u16 timing;
 
 	const u16 mwdma_bits[] = { 0x707, 0x202, 0x202 };
@@ -367,7 +367,7 @@ static void sis_66_set_dmamode (struct ata_port *ap, struct ata_device *adev)
 {
 	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
 	int speed = adev->dma_mode - XFER_MW_DMA_0;
-	int drive_pci = sis_port_base(adev);
+	int drive_pci = sis_old_port_base(adev);
 	u16 timing;
 
 	const u16 mwdma_bits[] = { 0x707, 0x202, 0x202 };
@@ -378,12 +378,12 @@ static void sis_66_set_dmamode (struct ata_port *ap, struct ata_device *adev)
 	if (adev->dma_mode < XFER_UDMA_0) {
 		/* bits 3-0 hold recovery timing bits 8-10 active timing and
 		   the higer bits are dependant on the device, bit 15 udma */
-		timing &= ~ 0x870F;
+		timing &= ~0x870F;
 		timing |= mwdma_bits[speed];
 	} else {
 		/* Bit 15 is UDMA on/off, bit 12-14 are cycle time */
 		speed = adev->dma_mode - XFER_UDMA_0;
-		timing &= ~0x6000;
+		timing &= ~0xF000;
 		timing |= udma_bits[speed];
 	}
 	pci_write_config_word(pdev, drive_pci, timing);
@@ -405,22 +405,22 @@ static void sis_100_set_dmamode (struct ata_port *ap, struct ata_device *adev)
 {
 	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
 	int speed = adev->dma_mode - XFER_MW_DMA_0;
-	int drive_pci = sis_port_base(adev);
-	u16 timing;
+	int drive_pci = sis_old_port_base(adev);
+	u8 timing;
 
-	const u16 udma_bits[]  = { 0x8B00, 0x8700, 0x8500, 0x8300, 0x8200, 0x8100};
+	const u8 udma_bits[]  = { 0x8B, 0x87, 0x85, 0x83, 0x82, 0x81};
 
-	pci_read_config_word(pdev, drive_pci, &timing);
+	pci_read_config_byte(pdev, drive_pci + 1, &timing);
 
 	if (adev->dma_mode < XFER_UDMA_0) {
 		/* NOT SUPPORTED YET: NEED DATA SHEET. DITTO IN OLD DRIVER */
 	} else {
-		/* Bit 15 is UDMA on/off, bit 12-14 are cycle time */
+		/* Bit 7 is UDMA on/off, bit 0-3 are cycle time */
 		speed = adev->dma_mode - XFER_UDMA_0;
-		timing &= ~0x0F00;
+		timing &= ~0x8F;
 		timing |= udma_bits[speed];
 	}
-	pci_write_config_word(pdev, drive_pci, timing);
+	pci_write_config_byte(pdev, drive_pci + 1, timing);
 }
 
 /**
@@ -440,22 +440,22 @@ static void sis_133_early_set_dmamode (struct ata_port *ap, struct ata_device *a
 {
 	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
 	int speed = adev->dma_mode - XFER_MW_DMA_0;
-	int drive_pci = sis_port_base(adev);
-	u16 timing;
-
-	static const u16 udma_bits[]  = { 0x8F00, 0x8A00, 0x8700, 0x8500, 0x8300, 0x8200, 0x8100};
+	int drive_pci = sis_old_port_base(adev);
+	u8 timing;
+	/* Low 4 bits are timing */
+	static const u8 udma_bits[]  = { 0x8F, 0x8A, 0x87, 0x85, 0x83, 0x82, 0x81};
 
-	pci_read_config_word(pdev, drive_pci, &timing);
+	pci_read_config_byte(pdev, drive_pci + 1, &timing);
 
 	if (adev->dma_mode < XFER_UDMA_0) {
 		/* NOT SUPPORTED YET: NEED DATA SHEET. DITTO IN OLD DRIVER */
 	} else {
-		/* Bit 15 is UDMA on/off, bit 12-14 are cycle time */
+		/* Bit 7 is UDMA on/off, bit 0-3 are cycle time */
 		speed = adev->dma_mode - XFER_UDMA_0;
-		timing &= ~0x0F00;
+		timing &= ~0x8F;
 		timing |= udma_bits[speed];
 	}
-	pci_write_config_word(pdev, drive_pci, timing);
+	pci_write_config_byte(pdev, drive_pci + 1, timing);
 }
 
 /**
diff --git a/drivers/ata/pata_sl82c105.c b/drivers/ata/pata_sl82c105.c
index f48491a..e5aaec4 100644
--- a/drivers/ata/pata_sl82c105.c
+++ b/drivers/ata/pata_sl82c105.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "pata_sl82c105"
-#define DRV_VERSION "0.3.0"
+#define DRV_VERSION "0.3.1"
 
 enum {
 	/*
diff --git a/drivers/ata/pata_via.c b/drivers/ata/pata_via.c
index e4c71f7..708dfc0 100644
--- a/drivers/ata/pata_via.c
+++ b/drivers/ata/pata_via.c
@@ -60,6 +60,7 @@
 #include <linux/delay.h>
 #include <scsi/scsi_host.h>
 #include <linux/libata.h>
+#include <linux/dmi.h>
 
 #define DRV_NAME "pata_via"
 #define DRV_VERSION "0.3.1"
@@ -122,6 +123,31 @@ static const struct via_isa_bridge {
 	{ NULL }
 };
 
+
+/*
+ *	Cable special cases
+ */
+
+static struct dmi_system_id cable_dmi_table[] = {
+	{
+		.ident = "Acer Ferrari 3400",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Acer,Inc."),
+			DMI_MATCH(DMI_BOARD_NAME, "Ferrari 3400"),
+		},
+	},
+	{ }
+};
+
+static int via_cable_override(struct pci_dev *pdev)
+{
+	/* Systems by DMI */
+	if (dmi_check_system(cable_dmi_table))
+		return 1;
+	return 0;
+}
+
+
 /**
  *	via_cable_detect	-	cable detection
  *	@ap: ATA port
@@ -139,6 +165,9 @@ static int via_cable_detect(struct ata_port *ap) {
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 	u32 ata66;
 
+	if (via_cable_override(pdev))
+		return ATA_CBL_PATA40_SHORT;
+
 	/* Early chips are 40 wire */
 	if ((config->flags & VIA_UDMA) < VIA_UDMA_66)
 		return ATA_CBL_PATA40;
diff --git a/drivers/ata/pata_winbond.c b/drivers/ata/pata_winbond.c
index cc4ad27..83abfec 100644
--- a/drivers/ata/pata_winbond.c
+++ b/drivers/ata/pata_winbond.c
@@ -16,7 +16,7 @@
 #include <linux/platform_device.h>
 
 #define DRV_NAME "pata_winbond"
-#define DRV_VERSION "0.0.2"
+#define DRV_VERSION "0.0.3"
 
 #define NR_HOST 4	/* Two winbond controllers, two channels each */
 
diff --git a/drivers/ata/pdc_adma.c b/drivers/ata/pdc_adma.c
index 52b6953..f12c2b6 100644
--- a/drivers/ata/pdc_adma.c
+++ b/drivers/ata/pdc_adma.c
@@ -44,7 +44,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pdc_adma"
-#define DRV_VERSION	"0.05"
+#define DRV_VERSION	"0.06"
 
 /* macro to calculate base address for ATA regs */
 #define ADMA_ATA_REGS(base,port_no)	((base) + ((port_no) * 0x40))
diff --git a/drivers/ata/sata_inic162x.c b/drivers/ata/sata_inic162x.c
index bda5e77..2d80c9d 100644
--- a/drivers/ata/sata_inic162x.c
+++ b/drivers/ata/sata_inic162x.c
@@ -28,7 +28,7 @@
 #include <scsi/scsi_device.h>
 
 #define DRV_NAME	"sata_inic162x"
-#define DRV_VERSION	"0.1"
+#define DRV_VERSION	"0.2"
 
 enum {
 	MMIO_BAR		= 5,
diff --git a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c
index cb9b9ac..705a020 100644
--- a/drivers/ata/sata_mv.c
+++ b/drivers/ata/sata_mv.c
@@ -35,7 +35,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"sata_mv"
-#define DRV_VERSION	"0.8"
+#define DRV_VERSION	"0.81"
 
 enum {
 	/* BAR's are enumerated in terms of pci_resource_start() terms */
diff --git a/drivers/ata/sata_nv.c b/drivers/ata/sata_nv.c
index 1a49c77..adfa693 100644
--- a/drivers/ata/sata_nv.c
+++ b/drivers/ata/sata_nv.c
@@ -49,7 +49,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME			"sata_nv"
-#define DRV_VERSION			"3.3"
+#define DRV_VERSION			"3.4"
 
 #define NV_ADMA_DMA_BOUNDARY		0xffffffffUL
 
@@ -802,7 +802,7 @@ static irqreturn_t nv_adma_interrupt(int irq, void *dev_instance)
 			u16 status;
 			u32 gen_ctl;
 			u32 notifier, notifier_error;
-			
+
 			/* if ADMA is disabled, use standard ata interrupt handler */
 			if (pp->flags & NV_ADMA_ATAPI_SETUP_COMPLETE) {
 				u8 irq_stat = readb(host->iomap[NV_MMIO_BAR] + NV_INT_STATUS_CK804)
@@ -963,7 +963,7 @@ static void nv_adma_irq_clear(struct ata_port *ap)
 
 	/* clear ADMA status */
 	writew(0xffff, mmio + NV_ADMA_STAT);
-	
+
 	/* clear notifiers - note both ports need to be written with
 	   something even though we are only clearing on one */
 	if (ap->port_no == 0) {
diff --git a/drivers/ata/sata_qstor.c b/drivers/ata/sata_qstor.c
index f5a05de..6688ccb 100644
--- a/drivers/ata/sata_qstor.c
+++ b/drivers/ata/sata_qstor.c
@@ -39,7 +39,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"sata_qstor"
-#define DRV_VERSION	"0.07"
+#define DRV_VERSION	"0.08"
 
 enum {
 	QS_MMIO_BAR		= 4,
diff --git a/drivers/ata/sata_sil.c b/drivers/ata/sata_sil.c
index e8483aa..a3b339b 100644
--- a/drivers/ata/sata_sil.c
+++ b/drivers/ata/sata_sil.c
@@ -305,7 +305,7 @@ static int sil_set_mode (struct ata_port *ap, struct ata_device **r_failed)
 	u32 tmp, dev_mode[2];
 	unsigned int i;
 	int rc;
-	
+
 	rc = ata_do_set_mode(ap, r_failed);
 	if (rc)
 		return rc;
diff --git a/drivers/ata/sata_sil24.c b/drivers/ata/sata_sil24.c
index 0cb6618..0ddfae9 100644
--- a/drivers/ata/sata_sil24.c
+++ b/drivers/ata/sata_sil24.c
@@ -30,7 +30,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"sata_sil24"
-#define DRV_VERSION	"0.8"
+#define DRV_VERSION	"0.9"
 
 /*
  * Port request block (PRB) 32 bytes
diff --git a/drivers/ata/sata_sis.c b/drivers/ata/sata_sis.c
index ee66c5f..51d9251 100644
--- a/drivers/ata/sata_sis.c
+++ b/drivers/ata/sata_sis.c
@@ -43,7 +43,7 @@
 #include "sis.h"
 
 #define DRV_NAME	"sata_sis"
-#define DRV_VERSION	"0.7"
+#define DRV_VERSION	"0.8"
 
 enum {
 	sis_180			= 0,
diff --git a/drivers/ata/sata_svw.c b/drivers/ata/sata_svw.c
index 1724673..bcb2cd8 100644
--- a/drivers/ata/sata_svw.c
+++ b/drivers/ata/sata_svw.c
@@ -53,7 +53,7 @@
 #endif /* CONFIG_PPC_OF */
 
 #define DRV_NAME	"sata_svw"
-#define DRV_VERSION	"2.1"
+#define DRV_VERSION	"2.2"
 
 enum {
 	/* ap->flags bits */
diff --git a/drivers/ata/sata_sx4.c b/drivers/ata/sata_sx4.c
index 3a4f445..2d14f3d 100644
--- a/drivers/ata/sata_sx4.c
+++ b/drivers/ata/sata_sx4.c
@@ -44,7 +44,7 @@
 #include "sata_promise.h"
 
 #define DRV_NAME	"sata_sx4"
-#define DRV_VERSION	"0.10"
+#define DRV_VERSION	"0.11"
 
 
 enum {
diff --git a/drivers/ata/sata_uli.c b/drivers/ata/sata_uli.c
index 006f5e3..6815de7 100644
--- a/drivers/ata/sata_uli.c
+++ b/drivers/ata/sata_uli.c
@@ -36,7 +36,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"sata_uli"
-#define DRV_VERSION	"1.1"
+#define DRV_VERSION	"1.2"
 
 enum {
 	uli_5289		= 0,
diff --git a/drivers/ata/sata_via.c b/drivers/ata/sata_via.c
index ac4f43c..01bba26 100644
--- a/drivers/ata/sata_via.c
+++ b/drivers/ata/sata_via.c
@@ -46,7 +46,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"sata_via"
-#define DRV_VERSION	"2.1"
+#define DRV_VERSION	"2.2"
 
 enum board_ids_enum {
 	vt6420,
diff --git a/drivers/ata/sata_vsc.c b/drivers/ata/sata_vsc.c
index 80126f8..8133017 100644
--- a/drivers/ata/sata_vsc.c
+++ b/drivers/ata/sata_vsc.c
@@ -47,7 +47,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"sata_vsc"
-#define DRV_VERSION	"2.1"
+#define DRV_VERSION	"2.2"
 
 enum {
 	VSC_MMIO_BAR			= 0,
diff --git a/drivers/atm/idt77252.c b/drivers/atm/idt77252.c
index 057efbc..3800bc0 100644
--- a/drivers/atm/idt77252.c
+++ b/drivers/atm/idt77252.c
@@ -47,7 +47,8 @@ static char const rcsid[] =
 #include <linux/bitops.h>
 #include <linux/wait.h>
 #include <linux/jiffies.h>
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
+
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
@@ -2435,7 +2436,7 @@ idt77252_open(struct atm_vcc *vcc)
 
 	set_bit(ATM_VF_ADDR, &vcc->flags);
 
-	down(&card->mutex);
+	mutex_lock(&card->mutex);
 
 	OPRINTK("%s: opening vpi.vci: %d.%d\n", card->name, vpi, vci);
 
@@ -2446,7 +2447,7 @@ idt77252_open(struct atm_vcc *vcc)
 		break;
 	default:
 		printk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);
-		up(&card->mutex);
+		mutex_unlock(&card->mutex);
 		return -EPROTONOSUPPORT;
 	}
 
@@ -2455,7 +2456,7 @@ idt77252_open(struct atm_vcc *vcc)
 		card->vcs[index] = kzalloc(sizeof(struct vc_map), GFP_KERNEL);
 		if (!card->vcs[index]) {
 			printk("%s: can't alloc vc in open()\n", card->name);
-			up(&card->mutex);
+			mutex_unlock(&card->mutex);
 			return -ENOMEM;
 		}
 		card->vcs[index]->card = card;
@@ -2484,14 +2485,14 @@ idt77252_open(struct atm_vcc *vcc)
 	if (inuse) {
 		printk("%s: %s vci already in use.\n", card->name,
 		       inuse == 1 ? "tx" : inuse == 2 ? "rx" : "tx and rx");
-		up(&card->mutex);
+		mutex_unlock(&card->mutex);
 		return -EADDRINUSE;
 	}
 
 	if (vcc->qos.txtp.traffic_class != ATM_NONE) {
 		error = idt77252_init_tx(card, vc, vcc, &vcc->qos);
 		if (error) {
-			up(&card->mutex);
+			mutex_unlock(&card->mutex);
 			return error;
 		}
 	}
@@ -2499,14 +2500,14 @@ idt77252_open(struct atm_vcc *vcc)
 	if (vcc->qos.rxtp.traffic_class != ATM_NONE) {
 		error = idt77252_init_rx(card, vc, vcc, &vcc->qos);
 		if (error) {
-			up(&card->mutex);
+			mutex_unlock(&card->mutex);
 			return error;
 		}
 	}
 
 	set_bit(ATM_VF_READY, &vcc->flags);
 
-	up(&card->mutex);
+	mutex_unlock(&card->mutex);
 	return 0;
 }
 
@@ -2520,7 +2521,7 @@ idt77252_close(struct atm_vcc *vcc)
 	unsigned long addr;
 	unsigned long timeout;
 
-	down(&card->mutex);
+	mutex_lock(&card->mutex);
 
 	IPRINTK("%s: idt77252_close: vc = %d (%d.%d)\n",
 		card->name, vc->index, vcc->vpi, vcc->vci);
@@ -2591,7 +2592,7 @@ done:
 		free_scq(card, vc->scq);
 	}
 
-	up(&card->mutex);
+	mutex_unlock(&card->mutex);
 }
 
 static int
@@ -2602,7 +2603,7 @@ idt77252_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)
 	struct vc_map *vc = vcc->dev_data;
 	int error = 0;
 
-	down(&card->mutex);
+	mutex_lock(&card->mutex);
 
 	if (qos->txtp.traffic_class != ATM_NONE) {
 	    	if (!test_bit(VCF_TX, &vc->flags)) {
@@ -2648,7 +2649,7 @@ idt77252_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)
 	set_bit(ATM_VF_HASQOS, &vcc->flags);
 
 out:
-	up(&card->mutex);
+	mutex_unlock(&card->mutex);
 	return error;
 }
 
@@ -3709,7 +3710,7 @@ idt77252_init_one(struct pci_dev *pcidev, const struct pci_device_id *id)
 	membase = pci_resource_start(pcidev, 1);
 	srambase = pci_resource_start(pcidev, 2);
 
-	init_MUTEX(&card->mutex);
+	mutex_init(&card->mutex);
 	spin_lock_init(&card->cmd_lock);
 	spin_lock_init(&card->tst_lock);
 
diff --git a/drivers/atm/idt77252.h b/drivers/atm/idt77252.h
index 544b397..6f2b4a5 100644
--- a/drivers/atm/idt77252.h
+++ b/drivers/atm/idt77252.h
@@ -37,7 +37,7 @@
 #include <linux/ptrace.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
-
+#include <linux/mutex.h>
 
 /*****************************************************************************/
 /*                                                                           */
@@ -359,7 +359,7 @@ struct idt77252_dev
 	unsigned long		srambase;	/* SAR's sram  base address */
 	void __iomem		*fbq[4];	/* FBQ fill addresses */
 
-	struct semaphore	mutex;
+	struct mutex		mutex;
 	spinlock_t		cmd_lock;	/* for r/w utility/sram */
 
 	unsigned long		softstat;
diff --git a/drivers/base/dmapool.c b/drivers/base/dmapool.c
index 9406259..91970e9 100644
--- a/drivers/base/dmapool.c
+++ b/drivers/base/dmapool.c
@@ -8,6 +8,7 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/poison.h>
+#include <linux/sched.h>
 
 /*
  * Pool allocator ... wraps the dma_alloc_coherent page allocator, so
diff --git a/drivers/block/floppy.c b/drivers/block/floppy.c
index 3587cb4..fe08804 100644
--- a/drivers/block/floppy.c
+++ b/drivers/block/floppy.c
@@ -670,7 +670,7 @@ static void __reschedule_timeout(int drive, const char *message, int marg)
 	if (drive == current_reqD)
 		drive = current_drive;
 	del_timer(&fd_timeout);
-	if (drive < 0 || drive > N_DRIVE) {
+	if (drive < 0 || drive >= N_DRIVE) {
 		fd_timeout.expires = jiffies + 20UL * HZ;
 		drive = 0;
 	} else
diff --git a/drivers/bluetooth/hci_usb.c b/drivers/bluetooth/hci_usb.c
index b0238b4..7e04dd6 100644
--- a/drivers/bluetooth/hci_usb.c
+++ b/drivers/bluetooth/hci_usb.c
@@ -115,11 +115,11 @@ static struct usb_device_id blacklist_ids[] = {
 	{ USB_DEVICE(0x0a5c, 0x2009), .driver_info = HCI_BCM92035 },
 
 	/* Broadcom BCM2045 */
-	{ USB_DEVICE(0x0a5c, 0x2101), .driver_info = HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x0a5c, 0x2101), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
 
 	/* IBM/Lenovo ThinkPad with Broadcom chip */
-	{ USB_DEVICE(0x0a5c, 0x201e), .driver_info = HCI_WRONG_SCO_MTU },
-	{ USB_DEVICE(0x0a5c, 0x2110), .driver_info = HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x0a5c, 0x201e), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x0a5c, 0x2110), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
 
 	/* Targus ACB10US */
 	{ USB_DEVICE(0x0a5c, 0x2100), .driver_info = HCI_RESET },
@@ -128,17 +128,17 @@ static struct usb_device_id blacklist_ids[] = {
 	{ USB_DEVICE(0x0a5c, 0x2111), .driver_info = HCI_RESET },
 
 	/* HP laptop with Broadcom chip */
-	{ USB_DEVICE(0x03f0, 0x171d), .driver_info = HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x03f0, 0x171d), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
 
 	/* Dell laptop with Broadcom chip */
-	{ USB_DEVICE(0x413c, 0x8126), .driver_info = HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x413c, 0x8126), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
 
 	/* Microsoft Wireless Transceiver for Bluetooth 2.0 */
 	{ USB_DEVICE(0x045e, 0x009c), .driver_info = HCI_RESET },
 
 	/* Kensington Bluetooth USB adapter */
 	{ USB_DEVICE(0x047d, 0x105d), .driver_info = HCI_RESET },
-	{ USB_DEVICE(0x047d, 0x105e), .driver_info = HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x047d, 0x105e), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
 
 	/* ISSC Bluetooth Adapter v3.1 */
 	{ USB_DEVICE(0x1131, 0x1001), .driver_info = HCI_RESET },
@@ -148,8 +148,8 @@ static struct usb_device_id blacklist_ids[] = {
 	{ USB_DEVICE(0x0400, 0x080a), .driver_info = HCI_BROKEN_ISOC },
 
 	/* Belkin F8T012 and F8T013 devices */
-	{ USB_DEVICE(0x050d, 0x0012), .driver_info = HCI_WRONG_SCO_MTU },
-	{ USB_DEVICE(0x050d, 0x0013), .driver_info = HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x050d, 0x0012), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
+	{ USB_DEVICE(0x050d, 0x0013), .driver_info = HCI_RESET | HCI_WRONG_SCO_MTU },
 
 	/* Digianswer devices */
 	{ USB_DEVICE(0x08fd, 0x0001), .driver_info = HCI_DIGIANSWER },
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index abcafac..ef683eb 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -815,7 +815,7 @@ config SGI_IP27_RTC
 
 config GEN_RTC
 	tristate "Generic /dev/rtc emulation"
-	depends on RTC!=y && !IA64 && !ARM && !M32R && !SPARC && !FRV && !S390
+	depends on RTC!=y && !IA64 && !ARM && !M32R && !SPARC && !FRV && !S390 && !SUPERH
 	---help---
 	  If you say Y here and create a character special file /dev/rtc with
 	  major number 10 and minor number 135 using mknod ("man mknod"), you
diff --git a/drivers/char/agp/frontend.c b/drivers/char/agp/frontend.c
index 679d7f9..c7ed617 100644
--- a/drivers/char/agp/frontend.c
+++ b/drivers/char/agp/frontend.c
@@ -37,6 +37,7 @@
 #include <linux/agpgart.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
+#include <linux/sched.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include "agp.h"
diff --git a/drivers/char/agp/generic.c b/drivers/char/agp/generic.c
index 45aeb91..d535c40 100644
--- a/drivers/char/agp/generic.c
+++ b/drivers/char/agp/generic.c
@@ -37,6 +37,7 @@
 #include <linux/vmalloc.h>
 #include <linux/dma-mapping.h>
 #include <linux/mm.h>
+#include <linux/sched.h>
 #include <asm/io.h>
 #include <asm/cacheflush.h>
 #include <asm/pgtable.h>
diff --git a/drivers/char/cyclades.c b/drivers/char/cyclades.c
index c72ee97..ca376b9 100644
--- a/drivers/char/cyclades.c
+++ b/drivers/char/cyclades.c
@@ -1061,6 +1061,7 @@ static void cyy_intr_chip(struct cyclades_card *cinfo, int chip,
 
 				if (data & info->ignore_status_mask) {
 					info->icount.rx++;
+					spin_unlock(&cinfo->card_lock);
 					return;
 				}
 				if (tty_buffer_request_room(tty, 1)) {
diff --git a/drivers/char/hangcheck-timer.c b/drivers/char/hangcheck-timer.c
index f0e7263..0e8ceea 100644
--- a/drivers/char/hangcheck-timer.c
+++ b/drivers/char/hangcheck-timer.c
@@ -48,7 +48,7 @@
 #include <linux/delay.h>
 #include <asm/uaccess.h>
 #include <linux/sysrq.h>
-
+#include <linux/timer.h>
 
 #define VERSION_STR "0.9.0"
 
diff --git a/drivers/crypto/geode-aes.c b/drivers/crypto/geode-aes.c
index 6d3840e..6a86958 100644
--- a/drivers/crypto/geode-aes.c
+++ b/drivers/crypto/geode-aes.c
@@ -102,10 +102,15 @@ geode_aes_crypt(struct geode_aes_op *op)
 	u32 flags = 0;
 	unsigned long iflags;
 
-	if (op->len == 0 || op->src == op->dst)
+	if (op->len == 0)
 		return 0;
 
-	if (op->flags & AES_FLAGS_COHERENT)
+	/* If the source and destination is the same, then
+	 * we need to turn on the coherent flags, otherwise
+	 * we don't need to worry
+	 */
+
+	if (op->src == op->dst)
 		flags |= (AES_CTRL_DCA | AES_CTRL_SCA);
 
 	if (op->dir == AES_DIR_ENCRYPT)
@@ -120,7 +125,7 @@ geode_aes_crypt(struct geode_aes_op *op)
 		_writefield(AES_WRITEIV0_REG, op->iv);
 	}
 
-	if (op->flags & AES_FLAGS_USRKEY) {
+	if (!(op->flags & AES_FLAGS_HIDDENKEY)) {
 		flags |= AES_CTRL_WRKEY;
 		_writefield(AES_WRITEKEY0_REG, op->key);
 	}
@@ -289,6 +294,7 @@ static struct crypto_alg geode_cbc_alg = {
 			.setkey			=	geode_setkey,
 			.encrypt		=	geode_cbc_encrypt,
 			.decrypt		=	geode_cbc_decrypt,
+			.ivsize			=	AES_IV_LENGTH,
 		}
 	}
 };
diff --git a/drivers/crypto/geode-aes.h b/drivers/crypto/geode-aes.h
index 8003a36..f479686 100644
--- a/drivers/crypto/geode-aes.h
+++ b/drivers/crypto/geode-aes.h
@@ -20,8 +20,7 @@
 #define AES_DIR_DECRYPT 0
 #define AES_DIR_ENCRYPT 1
 
-#define AES_FLAGS_USRKEY   (1 << 0)
-#define AES_FLAGS_COHERENT (1 << 1)
+#define AES_FLAGS_HIDDENKEY (1 << 0)
 
 struct geode_aes_op {
 
diff --git a/drivers/hwmon/applesmc.c b/drivers/hwmon/applesmc.c
index 0c16067..366f4a1 100644
--- a/drivers/hwmon/applesmc.c
+++ b/drivers/hwmon/applesmc.c
@@ -491,6 +491,12 @@ out:
 
 /* Sysfs Files */
 
+static ssize_t applesmc_name_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "applesmc\n");
+}
+
 static ssize_t applesmc_position_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
@@ -913,6 +919,8 @@ static struct led_classdev applesmc_backlight = {
 	.brightness_set		= applesmc_brightness_set,
 };
 
+static DEVICE_ATTR(name, 0444, applesmc_name_show, NULL);
+
 static DEVICE_ATTR(position, 0444, applesmc_position_show, NULL);
 static DEVICE_ATTR(calibrate, 0644,
 			applesmc_calibrate_show, applesmc_calibrate_store);
@@ -1197,6 +1205,8 @@ static int __init applesmc_init(void)
 		goto out_driver;
 	}
 
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_name.attr);
+
 	/* Create key enumeration sysfs files */
 	ret = sysfs_create_group(&pdev->dev.kobj, &key_enumeration_group);
 	if (ret)
diff --git a/drivers/i2c/busses/i2c-s3c2410.c b/drivers/i2c/busses/i2c-s3c2410.c
index e68a96f..e4540fc 100644
--- a/drivers/i2c/busses/i2c-s3c2410.c
+++ b/drivers/i2c/busses/i2c-s3c2410.c
@@ -830,7 +830,8 @@ static int s3c24xx_i2c_probe(struct platform_device *pdev)
 
 	i2c->irq = res;
 		
-	dev_dbg(&pdev->dev, "irq resource %p (%ld)\n", res, res->start);
+	dev_dbg(&pdev->dev, "irq resource %p (%lu)\n", res,
+		(unsigned long)res->start);
 
 	ret = i2c_add_adapter(&i2c->adap);
 	if (ret < 0) {
diff --git a/drivers/i2c/busses/i2c-tiny-usb.c b/drivers/i2c/busses/i2c-tiny-usb.c
index 9079990..cb9abe7 100644
--- a/drivers/i2c/busses/i2c-tiny-usb.c
+++ b/drivers/i2c/busses/i2c-tiny-usb.c
@@ -208,7 +208,7 @@ static int i2c_tiny_usb_probe(struct usb_interface *interface,
 	dev->adapter.class = I2C_CLASS_HWMON;
 	dev->adapter.algo = &usb_algorithm;
 	dev->adapter.algo_data = dev;
-	snprintf(dev->adapter.name, I2C_NAME_SIZE,
+	snprintf(dev->adapter.name, sizeof(dev->adapter.name),
 		 "i2c-tiny-usb at bus %03d device %03d",
 		 dev->usb_dev->bus->busnum, dev->usb_dev->devnum);
 
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index 64f8e56..435925e 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -697,9 +697,10 @@ int i2c_attach_client(struct i2c_client *client)
 	if (client->driver)
 		client->dev.driver = &client->driver->driver;
 
-	if (client->driver && !is_newstyle_driver(client->driver))
+	if (client->driver && !is_newstyle_driver(client->driver)) {
 		client->dev.release = i2c_client_release;
-	else
+		client->dev.uevent_suppress = 1;
+	} else
 		client->dev.release = i2c_client_dev_release;
 
 	snprintf(&client->dev.bus_id[0], sizeof(client->dev.bus_id),
diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index b77b7d1..ead141e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -119,15 +119,17 @@ static const struct drive_list_entry drive_blacklist [] = {
 	{ "HITACHI CDR-8335"	,	"ALL"		},
 	{ "HITACHI CDR-8435"	,	"ALL"		},
 	{ "Toshiba CD-ROM XM-6202B"	,	"ALL"		},
+	{ "TOSHIBA CD-ROM XM-1702BC",	"ALL"		},
 	{ "CD-532E-A"		,	"ALL"		},
 	{ "E-IDE CD-ROM CR-840",	"ALL"		},
 	{ "CD-ROM Drive/F5A",	"ALL"		},
 	{ "WPI CDD-820",		"ALL"		},
 	{ "SAMSUNG CD-ROM SC-148C",	"ALL"		},
 	{ "SAMSUNG CD-ROM SC",	"ALL"		},
-	{ "SanDisk SDP3B-64"	,	"ALL"		},
 	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
 	{ "_NEC DV5800A",               "ALL"           },  
+	{ "SAMSUNG CD-ROM SN-124",	"N001" },
+	{ "Seagate STT20000A",		"ALL" },
 	{ NULL			,	NULL		}
 
 };
diff --git a/drivers/ide/ide-proc.c b/drivers/ide/ide-proc.c
index d50bd99..ea94c9a 100644
--- a/drivers/ide/ide-proc.c
+++ b/drivers/ide/ide-proc.c
@@ -67,6 +67,8 @@ static int proc_ide_read_imodel
 		case ide_4drives:	name = "4drives";	break;
 		case ide_pmac:		name = "mac-io";	break;
 		case ide_au1xxx:	name = "au1xxx";	break;
+		case ide_etrax100:	name = "etrax100";	break;
+		case ide_acorn:		name = "acorn";		break;
 		default:		name = "(unknown)";	break;
 	}
 	len = sprintf(page, "%s\n", name);
diff --git a/drivers/ide/pci/atiixp.c b/drivers/ide/pci/atiixp.c
index 0e52ad7..8ab33fa 100644
--- a/drivers/ide/pci/atiixp.c
+++ b/drivers/ide/pci/atiixp.c
@@ -317,6 +317,7 @@ static struct pci_device_id atiixp_pci_tbl[] = {
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP300_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP400_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP600_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP700_IDE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, atiixp_pci_tbl);
diff --git a/drivers/ide/pci/serverworks.c b/drivers/ide/pci/serverworks.c
index 6234f80..47bcd91 100644
--- a/drivers/ide/pci/serverworks.c
+++ b/drivers/ide/pci/serverworks.c
@@ -158,6 +158,12 @@ static int svwks_tune_chipset (ide_drive_t *drive, u8 xferspeed)
 	pci_read_config_word(dev, 0x4A, &csb5_pio);
 	pci_read_config_byte(dev, 0x54, &ultra_enable);
 
+	/* If we are in RAID mode (eg AMI MegaIDE) then we can't it
+	   turns out trust the firmware configuration */
+
+	if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE)
+		goto oem_setup_failed;
+
 	/* Per Specified Design by OEM, and ASIC Architect */
 	if ((dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE) ||
 	    (dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)) {
@@ -173,7 +179,7 @@ dma_pio:
 				   ((dma_stat&(1<<(5+unit)))==(1<<(5+unit)))) {
 				u8 dmaspeed = dma_timing;
 
-				dma_timing &= ~0xFF;
+				dma_timing &= ~0xFFU;
 				if ((dmaspeed & 0x20) == 0x20)
 					dmaspeed = XFER_MW_DMA_2;
 				else if ((dmaspeed & 0x21) == 0x21)
@@ -187,7 +193,7 @@ dma_pio:
 			} else if (pio_timing) {
 				u8 piospeed = pio_timing;
 
-				pio_timing &= ~0xFF;
+				pio_timing &= ~0xFFU;
 				if ((piospeed & 0x20) == 0x20)
 					piospeed = XFER_PIO_4;
 				else if ((piospeed & 0x22) == 0x22)
@@ -208,8 +214,8 @@ dma_pio:
 
 oem_setup_failed:
 
-	pio_timing	&= ~0xFF;
-	dma_timing	&= ~0xFF;
+	pio_timing	&= ~0xFFU;
+	dma_timing	&= ~0xFFU;
 	ultra_timing	&= ~(0x0F << (4*unit));
 	ultra_enable	&= ~(0x01 << drive->dn);
 	csb5_pio	&= ~(0x0F << (4*drive->dn));
diff --git a/drivers/infiniband/core/cache.c b/drivers/infiniband/core/cache.c
index 558c9a0..e85f701 100644
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@ -38,6 +38,7 @@
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/workqueue.h>
 
 #include <rdma/ib_cache.h>
 
diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c
index eff591d..e840434 100644
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@ -306,7 +306,9 @@ static int cm_alloc_id(struct cm_id_private *cm_id_priv)
 	do {
 		spin_lock_irqsave(&cm.lock, flags);
 		ret = idr_get_new_above(&cm.local_id_table, cm_id_priv,
-					next_id++, &id);
+					next_id, &id);
+		if (!ret)
+			next_id = ((unsigned) id + 1) & MAX_ID_MASK;
 		spin_unlock_irqrestore(&cm.lock, flags);
 	} while( (ret == -EAGAIN) && idr_pre_get(&cm.local_id_table, GFP_KERNEL) );
 
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index 592c90a..3ada17c 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -40,6 +40,7 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/mutex.h>
+#include <linux/workqueue.h>
 
 #include "core_priv.h"
 
@@ -149,6 +150,18 @@ static int alloc_name(char *name)
 	return 0;
 }
 
+static int start_port(struct ib_device *device)
+{
+	return (device->node_type == RDMA_NODE_IB_SWITCH) ? 0 : 1;
+}
+
+
+static int end_port(struct ib_device *device)
+{
+	return (device->node_type == RDMA_NODE_IB_SWITCH) ?
+		0 : device->phys_port_cnt;
+}
+
 /**
  * ib_alloc_device - allocate an IB device struct
  * @size:size of structure to allocate
@@ -208,6 +221,45 @@ static int add_client_context(struct ib_device *device, struct ib_client *client
 	return 0;
 }
 
+static int read_port_table_lengths(struct ib_device *device)
+{
+	struct ib_port_attr *tprops = NULL;
+	int num_ports, ret = -ENOMEM;
+	u8 port_index;
+
+	tprops = kmalloc(sizeof *tprops, GFP_KERNEL);
+	if (!tprops)
+		goto out;
+
+	num_ports = end_port(device) - start_port(device) + 1;
+
+	device->pkey_tbl_len = kmalloc(sizeof *device->pkey_tbl_len * num_ports,
+				       GFP_KERNEL);
+	device->gid_tbl_len = kmalloc(sizeof *device->gid_tbl_len * num_ports,
+				      GFP_KERNEL);
+	if (!device->pkey_tbl_len || !device->gid_tbl_len)
+		goto err;
+
+	for (port_index = 0; port_index < num_ports; ++port_index) {
+		ret = ib_query_port(device, port_index + start_port(device),
+					tprops);
+		if (ret)
+			goto err;
+		device->pkey_tbl_len[port_index] = tprops->pkey_tbl_len;
+		device->gid_tbl_len[port_index]  = tprops->gid_tbl_len;
+	}
+
+	ret = 0;
+	goto out;
+
+err:
+	kfree(device->gid_tbl_len);
+	kfree(device->pkey_tbl_len);
+out:
+	kfree(tprops);
+	return ret;
+}
+
 /**
  * ib_register_device - Register an IB device with IB core
  * @device:Device to register
@@ -239,10 +291,19 @@ int ib_register_device(struct ib_device *device)
 	spin_lock_init(&device->event_handler_lock);
 	spin_lock_init(&device->client_data_lock);
 
+	ret = read_port_table_lengths(device);
+	if (ret) {
+		printk(KERN_WARNING "Couldn't create table lengths cache for device %s\n",
+		       device->name);
+		goto out;
+	}
+
 	ret = ib_device_register_sysfs(device);
 	if (ret) {
 		printk(KERN_WARNING "Couldn't register device %s with driver model\n",
 		       device->name);
+		kfree(device->gid_tbl_len);
+		kfree(device->pkey_tbl_len);
 		goto out;
 	}
 
@@ -284,6 +345,9 @@ void ib_unregister_device(struct ib_device *device)
 
 	list_del(&device->core_list);
 
+	kfree(device->gid_tbl_len);
+	kfree(device->pkey_tbl_len);
+
 	mutex_unlock(&device_mutex);
 
 	spin_lock_irqsave(&device->client_data_lock, flags);
@@ -506,10 +570,7 @@ int ib_query_port(struct ib_device *device,
 		  u8 port_num,
 		  struct ib_port_attr *port_attr)
 {
-	if (device->node_type == RDMA_NODE_IB_SWITCH) {
-		if (port_num)
-			return -EINVAL;
-	} else if (port_num < 1 || port_num > device->phys_port_cnt)
+	if (port_num < start_port(device) || port_num > end_port(device))
 		return -EINVAL;
 
 	return device->query_port(device, port_num, port_attr);
@@ -581,10 +642,7 @@ int ib_modify_port(struct ib_device *device,
 		   u8 port_num, int port_modify_mask,
 		   struct ib_port_modify *port_modify)
 {
-	if (device->node_type == RDMA_NODE_IB_SWITCH) {
-		if (port_num)
-			return -EINVAL;
-	} else if (port_num < 1 || port_num > device->phys_port_cnt)
+	if (port_num < start_port(device) || port_num > end_port(device))
 		return -EINVAL;
 
 	return device->modify_port(device, port_num, port_modify_mask,
@@ -592,6 +650,68 @@ int ib_modify_port(struct ib_device *device,
 }
 EXPORT_SYMBOL(ib_modify_port);
 
+/**
+ * ib_find_gid - Returns the port number and GID table index where
+ *   a specified GID value occurs.
+ * @device: The device to query.
+ * @gid: The GID value to search for.
+ * @port_num: The port number of the device where the GID value was found.
+ * @index: The index into the GID table where the GID was found.  This
+ *   parameter may be NULL.
+ */
+int ib_find_gid(struct ib_device *device, union ib_gid *gid,
+		u8 *port_num, u16 *index)
+{
+	union ib_gid tmp_gid;
+	int ret, port, i;
+
+	for (port = start_port(device); port <= end_port(device); ++port) {
+		for (i = 0; i < device->gid_tbl_len[port - start_port(device)]; ++i) {
+			ret = ib_query_gid(device, port, i, &tmp_gid);
+			if (ret)
+				return ret;
+			if (!memcmp(&tmp_gid, gid, sizeof *gid)) {
+				*port_num = port;
+				if (index)
+					*index = i;
+				return 0;
+			}
+		}
+	}
+
+	return -ENOENT;
+}
+EXPORT_SYMBOL(ib_find_gid);
+
+/**
+ * ib_find_pkey - Returns the PKey table index where a specified
+ *   PKey value occurs.
+ * @device: The device to query.
+ * @port_num: The port number of the device to search for the PKey.
+ * @pkey: The PKey value to search for.
+ * @index: The index into the PKey table where the PKey was found.
+ */
+int ib_find_pkey(struct ib_device *device,
+		 u8 port_num, u16 pkey, u16 *index)
+{
+	int ret, i;
+	u16 tmp_pkey;
+
+	for (i = 0; i < device->pkey_tbl_len[port_num - start_port(device)]; ++i) {
+		ret = ib_query_pkey(device, port_num, i, &tmp_pkey);
+		if (ret)
+			return ret;
+
+		if (pkey == tmp_pkey) {
+			*index = i;
+			return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+EXPORT_SYMBOL(ib_find_pkey);
+
 static int __init ib_core_init(void)
 {
 	int ret;
diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c
index f32ca5f..b4aec51 100644
--- a/drivers/infiniband/core/umem.c
+++ b/drivers/infiniband/core/umem.c
@@ -36,6 +36,7 @@
 
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
+#include <linux/sched.h>
 
 #include "uverbs.h"
 
@@ -209,8 +210,10 @@ void ib_umem_release(struct ib_umem *umem)
 	__ib_umem_release(umem->context->device, umem, 1);
 
 	mm = get_task_mm(current);
-	if (!mm)
+	if (!mm) {
+		kfree(umem);
 		return;
+	}
 
 	diff = PAGE_ALIGN(umem->length + umem->offset) >> PAGE_SHIFT;
 
diff --git a/drivers/infiniband/hw/ehca/ehca_mrmw.c b/drivers/infiniband/hw/ehca/ehca_mrmw.c
index 84c5bb4..add79bd 100644
--- a/drivers/infiniband/hw/ehca/ehca_mrmw.c
+++ b/drivers/infiniband/hw/ehca/ehca_mrmw.c
@@ -2050,13 +2050,10 @@ int ehca_mrmw_map_hrc_alloc(const u64 hipz_rc)
 	switch (hipz_rc) {
 	case H_SUCCESS:	             /* successful completion */
 		return 0;
-	case H_ADAPTER_PARM:         /* invalid adapter handle */
-	case H_RT_PARM:              /* invalid resource type */
 	case H_NOT_ENOUGH_RESOURCES: /* insufficient resources */
-	case H_MLENGTH_PARM:         /* invalid memory length */
-	case H_MEM_ACCESS_PARM:      /* invalid access controls */
 	case H_CONSTRAINED:          /* resource constraint */
-		return -EINVAL;
+	case H_NO_MEM:
+		return -ENOMEM;
 	case H_BUSY:                 /* long busy */
 		return -EBUSY;
 	default:
diff --git a/drivers/infiniband/hw/ipath/ipath_verbs_mcast.c b/drivers/infiniband/hw/ipath/ipath_verbs_mcast.c
index 085e28b..dd691cf 100644
--- a/drivers/infiniband/hw/ipath/ipath_verbs_mcast.c
+++ b/drivers/infiniband/hw/ipath/ipath_verbs_mcast.c
@@ -165,10 +165,9 @@ static int ipath_mcast_add(struct ipath_ibdev *dev,
 {
 	struct rb_node **n = &mcast_tree.rb_node;
 	struct rb_node *pn = NULL;
-	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&mcast_lock, flags);
+	spin_lock_irq(&mcast_lock);
 
 	while (*n) {
 		struct ipath_mcast *tmcast;
@@ -228,7 +227,7 @@ static int ipath_mcast_add(struct ipath_ibdev *dev,
 	ret = 0;
 
 bail:
-	spin_unlock_irqrestore(&mcast_lock, flags);
+	spin_unlock_irq(&mcast_lock);
 
 	return ret;
 }
@@ -289,17 +288,16 @@ int ipath_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 	struct ipath_mcast *mcast = NULL;
 	struct ipath_mcast_qp *p, *tmp;
 	struct rb_node *n;
-	unsigned long flags;
 	int last = 0;
 	int ret;
 
-	spin_lock_irqsave(&mcast_lock, flags);
+	spin_lock_irq(&mcast_lock);
 
 	/* Find the GID in the mcast table. */
 	n = mcast_tree.rb_node;
 	while (1) {
 		if (n == NULL) {
-			spin_unlock_irqrestore(&mcast_lock, flags);
+			spin_unlock_irq(&mcast_lock);
 			ret = -EINVAL;
 			goto bail;
 		}
@@ -334,7 +332,7 @@ int ipath_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 		break;
 	}
 
-	spin_unlock_irqrestore(&mcast_lock, flags);
+	spin_unlock_irq(&mcast_lock);
 
 	if (p) {
 		/*
@@ -348,9 +346,9 @@ int ipath_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 		atomic_dec(&mcast->refcount);
 		wait_event(mcast->wait, !atomic_read(&mcast->refcount));
 		ipath_mcast_free(mcast);
-		spin_lock(&dev->n_mcast_grps_lock);
+		spin_lock_irq(&dev->n_mcast_grps_lock);
 		dev->n_mcast_grps_allocated--;
-		spin_unlock(&dev->n_mcast_grps_lock);
+		spin_unlock_irq(&dev->n_mcast_grps_lock);
 	}
 
 	ret = 0;
diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c
index 5cd7069..a824bc5 100644
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@ -188,14 +188,32 @@ static int send_wqe_overhead(enum ib_qp_type type)
 	}
 }
 
-static int set_qp_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,
-		       enum ib_qp_type type, struct mlx4_ib_qp *qp)
+static int set_rq_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,
+		       struct mlx4_ib_qp *qp)
 {
-	/* Sanity check QP size before proceeding */
+	/* Sanity check RQ size before proceeding */
+	if (cap->max_recv_wr  > dev->dev->caps.max_wqes  ||
+	    cap->max_recv_sge > dev->dev->caps.max_rq_sg)
+		return -EINVAL;
+
+	qp->rq.max = cap->max_recv_wr ? roundup_pow_of_two(cap->max_recv_wr) : 0;
+
+	qp->rq.wqe_shift = ilog2(roundup_pow_of_two(cap->max_recv_sge *
+						    sizeof (struct mlx4_wqe_data_seg)));
+	qp->rq.max_gs    = (1 << qp->rq.wqe_shift) / sizeof (struct mlx4_wqe_data_seg);
+
+	cap->max_recv_wr  = qp->rq.max;
+	cap->max_recv_sge = qp->rq.max_gs;
+
+	return 0;
+}
+
+static int set_kernel_sq_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,
+			      enum ib_qp_type type, struct mlx4_ib_qp *qp)
+{
+	/* Sanity check SQ size before proceeding */
 	if (cap->max_send_wr	 > dev->dev->caps.max_wqes  ||
-	    cap->max_recv_wr	 > dev->dev->caps.max_wqes  ||
 	    cap->max_send_sge	 > dev->dev->caps.max_sq_sg ||
-	    cap->max_recv_sge	 > dev->dev->caps.max_rq_sg ||
 	    cap->max_inline_data + send_wqe_overhead(type) +
 	    sizeof (struct mlx4_wqe_inline_seg) > dev->dev->caps.max_sq_desc_sz)
 		return -EINVAL;
@@ -208,12 +226,7 @@ static int set_qp_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,
 	    cap->max_send_sge + 2 > dev->dev->caps.max_sq_sg)
 		return -EINVAL;
 
-	qp->rq.max = cap->max_recv_wr ? roundup_pow_of_two(cap->max_recv_wr) : 0;
-	qp->sq.max = cap->max_send_wr ? roundup_pow_of_two(cap->max_send_wr) : 0;
-
-	qp->rq.wqe_shift = ilog2(roundup_pow_of_two(cap->max_recv_sge *
-						    sizeof (struct mlx4_wqe_data_seg)));
-	qp->rq.max_gs    = (1 << qp->rq.wqe_shift) / sizeof (struct mlx4_wqe_data_seg);
+	qp->sq.max = cap->max_send_wr ? roundup_pow_of_two(cap->max_send_wr) : 1;
 
 	qp->sq.wqe_shift = ilog2(roundup_pow_of_two(max(cap->max_send_sge *
 							sizeof (struct mlx4_wqe_data_seg),
@@ -233,16 +246,26 @@ static int set_qp_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,
 		qp->sq.offset = 0;
 	}
 
-	cap->max_send_wr  = qp->sq.max;
-	cap->max_recv_wr  = qp->rq.max;
-	cap->max_send_sge = qp->sq.max_gs;
-	cap->max_recv_sge = qp->rq.max_gs;
+	cap->max_send_wr     = qp->sq.max;
+	cap->max_send_sge    = qp->sq.max_gs;
 	cap->max_inline_data = (1 << qp->sq.wqe_shift) - send_wqe_overhead(type) -
 		sizeof (struct mlx4_wqe_inline_seg);
 
 	return 0;
 }
 
+static int set_user_sq_size(struct mlx4_ib_qp *qp,
+			    struct mlx4_ib_create_qp *ucmd)
+{
+	qp->sq.max       = 1 << ucmd->log_sq_bb_count;
+	qp->sq.wqe_shift = ucmd->log_sq_stride;
+
+	qp->buf_size = (qp->rq.max << qp->rq.wqe_shift) +
+		(qp->sq.max << qp->sq.wqe_shift);
+
+	return 0;
+}
+
 static int create_qp_common(struct mlx4_ib_dev *dev, struct ib_pd *pd,
 			    struct ib_qp_init_attr *init_attr,
 			    struct ib_udata *udata, int sqpn, struct mlx4_ib_qp *qp)
@@ -264,7 +287,7 @@ static int create_qp_common(struct mlx4_ib_dev *dev, struct ib_pd *pd,
 	qp->sq.head	    = 0;
 	qp->sq.tail	    = 0;
 
-	err = set_qp_size(dev, &init_attr->cap, init_attr->qp_type, qp);
+	err = set_rq_size(dev, &init_attr->cap, qp);
 	if (err)
 		goto err;
 
@@ -276,6 +299,10 @@ static int create_qp_common(struct mlx4_ib_dev *dev, struct ib_pd *pd,
 			goto err;
 		}
 
+		err = set_user_sq_size(qp, &ucmd);
+		if (err)
+			goto err;
+
 		qp->umem = ib_umem_get(pd->uobject->context, ucmd.buf_addr,
 				       qp->buf_size, 0);
 		if (IS_ERR(qp->umem)) {
@@ -297,6 +324,10 @@ static int create_qp_common(struct mlx4_ib_dev *dev, struct ib_pd *pd,
 		if (err)
 			goto err_mtt;
 	} else {
+		err = set_kernel_sq_size(dev, &init_attr->cap, init_attr->qp_type, qp);
+		if (err)
+			goto err;
+
 		err = mlx4_ib_db_alloc(dev, &qp->db, 0);
 		if (err)
 			goto err;
@@ -573,7 +604,7 @@ static int to_mlx4_st(enum ib_qp_type type)
 	}
 }
 
-static __be32 to_mlx4_access_flags(struct mlx4_ib_qp *qp, struct ib_qp_attr *attr,
+static __be32 to_mlx4_access_flags(struct mlx4_ib_qp *qp, const struct ib_qp_attr *attr,
 				   int attr_mask)
 {
 	u8 dest_rd_atomic;
@@ -603,7 +634,7 @@ static __be32 to_mlx4_access_flags(struct mlx4_ib_qp *qp, struct ib_qp_attr *att
 	return cpu_to_be32(hw_access_flags);
 }
 
-static void store_sqp_attrs(struct mlx4_ib_sqp *sqp, struct ib_qp_attr *attr,
+static void store_sqp_attrs(struct mlx4_ib_sqp *sqp, const struct ib_qp_attr *attr,
 			    int attr_mask)
 {
 	if (attr_mask & IB_QP_PKEY_INDEX)
@@ -619,7 +650,7 @@ static void mlx4_set_sched(struct mlx4_qp_path *path, u8 port)
 	path->sched_queue = (path->sched_queue & 0xbf) | ((port - 1) << 6);
 }
 
-static int mlx4_set_path(struct mlx4_ib_dev *dev, struct ib_ah_attr *ah,
+static int mlx4_set_path(struct mlx4_ib_dev *dev, const struct ib_ah_attr *ah,
 			 struct mlx4_qp_path *path, u8 port)
 {
 	path->grh_mylmc     = ah->src_path_bits & 0x7f;
@@ -655,14 +686,14 @@ static int mlx4_set_path(struct mlx4_ib_dev *dev, struct ib_ah_attr *ah,
 	return 0;
 }
 
-int mlx4_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,
-		      int attr_mask, struct ib_udata *udata)
+static int __mlx4_ib_modify_qp(struct ib_qp *ibqp,
+			       const struct ib_qp_attr *attr, int attr_mask,
+			       enum ib_qp_state cur_state, enum ib_qp_state new_state)
 {
 	struct mlx4_ib_dev *dev = to_mdev(ibqp->device);
 	struct mlx4_ib_qp *qp = to_mqp(ibqp);
 	struct mlx4_qp_context *context;
 	enum mlx4_qp_optpar optpar = 0;
-	enum ib_qp_state cur_state, new_state;
 	int sqd_event;
 	int err = -EINVAL;
 
@@ -670,34 +701,6 @@ int mlx4_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,
 	if (!context)
 		return -ENOMEM;
 
-	mutex_lock(&qp->mutex);
-
-	cur_state = attr_mask & IB_QP_CUR_STATE ? attr->cur_qp_state : qp->state;
-	new_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;
-
-	if (!ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type, attr_mask))
-		goto out;
-
-	if ((attr_mask & IB_QP_PKEY_INDEX) &&
-	     attr->pkey_index >= dev->dev->caps.pkey_table_len) {
-		goto out;
-	}
-
-	if ((attr_mask & IB_QP_PORT) &&
-	    (attr->port_num == 0 || attr->port_num > dev->dev->caps.num_ports)) {
-		goto out;
-	}
-
-	if (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&
-	    attr->max_rd_atomic > dev->dev->caps.max_qp_init_rdma) {
-		goto out;
-	}
-
-	if (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&
-	    attr->max_dest_rd_atomic > 1 << dev->dev->caps.max_qp_dest_rdma) {
-		goto out;
-	}
-
 	context->flags = cpu_to_be32((to_mlx4_state(new_state) << 28) |
 				     (to_mlx4_st(ibqp->qp_type) << 16));
 	context->flags     |= cpu_to_be32(1 << 8); /* DE? */
@@ -920,11 +923,84 @@ int mlx4_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,
 	}
 
 out:
-	mutex_unlock(&qp->mutex);
 	kfree(context);
 	return err;
 }
 
+static const struct ib_qp_attr mlx4_ib_qp_attr = { .port_num = 1 };
+static const int mlx4_ib_qp_attr_mask_table[IB_QPT_UD + 1] = {
+		[IB_QPT_UD]  = (IB_QP_PKEY_INDEX		|
+				IB_QP_PORT			|
+				IB_QP_QKEY),
+		[IB_QPT_UC]  = (IB_QP_PKEY_INDEX		|
+				IB_QP_PORT			|
+				IB_QP_ACCESS_FLAGS),
+		[IB_QPT_RC]  = (IB_QP_PKEY_INDEX		|
+				IB_QP_PORT			|
+				IB_QP_ACCESS_FLAGS),
+		[IB_QPT_SMI] = (IB_QP_PKEY_INDEX		|
+				IB_QP_QKEY),
+		[IB_QPT_GSI] = (IB_QP_PKEY_INDEX		|
+				IB_QP_QKEY),
+};
+
+int mlx4_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,
+		      int attr_mask, struct ib_udata *udata)
+{
+	struct mlx4_ib_dev *dev = to_mdev(ibqp->device);
+	struct mlx4_ib_qp *qp = to_mqp(ibqp);
+	enum ib_qp_state cur_state, new_state;
+	int err = -EINVAL;
+
+	mutex_lock(&qp->mutex);
+
+	cur_state = attr_mask & IB_QP_CUR_STATE ? attr->cur_qp_state : qp->state;
+	new_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;
+
+	if (!ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type, attr_mask))
+		goto out;
+
+	if ((attr_mask & IB_QP_PKEY_INDEX) &&
+	     attr->pkey_index >= dev->dev->caps.pkey_table_len) {
+		goto out;
+	}
+
+	if ((attr_mask & IB_QP_PORT) &&
+	    (attr->port_num == 0 || attr->port_num > dev->dev->caps.num_ports)) {
+		goto out;
+	}
+
+	if (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&
+	    attr->max_rd_atomic > dev->dev->caps.max_qp_init_rdma) {
+		goto out;
+	}
+
+	if (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&
+	    attr->max_dest_rd_atomic > dev->dev->caps.max_qp_dest_rdma) {
+		goto out;
+	}
+
+	if (cur_state == new_state && cur_state == IB_QPS_RESET) {
+		err = 0;
+		goto out;
+	}
+
+	if (cur_state == IB_QPS_RESET && new_state == IB_QPS_ERR) {
+		err = __mlx4_ib_modify_qp(ibqp, &mlx4_ib_qp_attr,
+					  mlx4_ib_qp_attr_mask_table[ibqp->qp_type],
+					  IB_QPS_RESET, IB_QPS_INIT);
+		if (err)
+			goto out;
+		cur_state = IB_QPS_INIT;
+	}
+
+	err = __mlx4_ib_modify_qp(ibqp, attr, attr_mask, cur_state, new_state);
+
+out:
+	mutex_unlock(&qp->mutex);
+	return err;
+}
+
 static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_send_wr *wr,
 			    void *wqe)
 {
@@ -952,6 +1028,7 @@ static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_send_wr *wr,
 			(be32_to_cpu(ah->av.sl_tclass_flowlabel) >> 20) & 0xff;
 		sqp->ud_header.grh.flow_label    =
 			ah->av.sl_tclass_flowlabel & cpu_to_be32(0xfffff);
+		sqp->ud_header.grh.hop_limit     = ah->av.hop_limit;
 		ib_get_cached_gid(ib_dev, be32_to_cpu(ah->av.port_pd) >> 24,
 				  ah->av.gid_index, &sqp->ud_header.grh.source_gid);
 		memcpy(sqp->ud_header.grh.destination_gid.raw,
@@ -1192,7 +1269,7 @@ int mlx4_ib_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,
 		 */
 		wmb();
 
-		if (wr->opcode < 0 || wr->opcode > ARRAY_SIZE(mlx4_ib_opcode)) {
+		if (wr->opcode < 0 || wr->opcode >= ARRAY_SIZE(mlx4_ib_opcode)) {
 			err = -EINVAL;
 			goto out;
 		}
diff --git a/drivers/infiniband/hw/mlx4/srq.c b/drivers/infiniband/hw/mlx4/srq.c
index 42ab4a8..12fac1c 100644
--- a/drivers/infiniband/hw/mlx4/srq.c
+++ b/drivers/infiniband/hw/mlx4/srq.c
@@ -297,6 +297,12 @@ int mlx4_ib_post_srq_recv(struct ib_srq *ibsrq, struct ib_recv_wr *wr,
 			break;
 		}
 
+		if (unlikely(srq->head == srq->tail)) {
+			err = -ENOMEM;
+			*bad_wr = wr;
+			break;
+		}
+
 		srq->wrid[srq->head] = wr->wr_id;
 
 		next      = get_wqe(srq, srq->head);
diff --git a/drivers/infiniband/hw/mlx4/user.h b/drivers/infiniband/hw/mlx4/user.h
index 5b8eddc..88c72d5 100644
--- a/drivers/infiniband/hw/mlx4/user.h
+++ b/drivers/infiniband/hw/mlx4/user.h
@@ -39,7 +39,7 @@
  * Increment this value if any changes that break userspace ABI
  * compatibility are made.
  */
-#define MLX4_IB_UVERBS_ABI_VERSION	1
+#define MLX4_IB_UVERBS_ABI_VERSION	2
 
 /*
  * Make sure that all structs defined in this file remain laid out so
@@ -87,6 +87,9 @@ struct mlx4_ib_create_srq_resp {
 struct mlx4_ib_create_qp {
 	__u64	buf_addr;
 	__u64	db_addr;
+        __u8	log_sq_bb_count;
+        __u8	log_sq_stride;
+        __u8	reserved[6];
 };
 
 #endif /* MLX4_IB_USER_H */
diff --git a/drivers/infiniband/hw/mthca/mthca_av.c b/drivers/infiniband/hw/mthca/mthca_av.c
index 27caf3b..4b111a8 100644
--- a/drivers/infiniband/hw/mthca/mthca_av.c
+++ b/drivers/infiniband/hw/mthca/mthca_av.c
@@ -279,6 +279,7 @@ int mthca_read_ah(struct mthca_dev *dev, struct mthca_ah *ah,
 			(be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 20) & 0xff;
 		header->grh.flow_label    =
 			ah->av->sl_tclass_flowlabel & cpu_to_be32(0xfffff);
+		header->grh.hop_limit     = ah->av->hop_limit;
 		ib_get_cached_gid(&dev->ib_dev,
 				  be32_to_cpu(ah->av->port_pd) >> 24,
 				  ah->av->gid_index % dev->limits.gid_table_len,
diff --git a/drivers/infiniband/hw/mthca/mthca_cmd.c b/drivers/infiniband/hw/mthca/mthca_cmd.c
index 7131446..3810252 100644
--- a/drivers/infiniband/hw/mthca/mthca_cmd.c
+++ b/drivers/infiniband/hw/mthca/mthca_cmd.c
@@ -37,6 +37,7 @@
 #include <linux/completion.h>
 #include <linux/pci.h>
 #include <linux/errno.h>
+#include <linux/sched.h>
 #include <asm/io.h>
 #include <rdma/ib_mad.h>
 
diff --git a/drivers/infiniband/hw/mthca/mthca_cq.c b/drivers/infiniband/hw/mthca/mthca_cq.c
index ca224d0..be6e1e0 100644
--- a/drivers/infiniband/hw/mthca/mthca_cq.c
+++ b/drivers/infiniband/hw/mthca/mthca_cq.c
@@ -37,6 +37,7 @@
  */
 
 #include <linux/hardirq.h>
+#include <linux/sched.h>
 
 #include <asm/io.h>
 
diff --git a/drivers/infiniband/hw/mthca/mthca_main.c b/drivers/infiniband/hw/mthca/mthca_main.c
index 773145e..aa563e6 100644
--- a/drivers/infiniband/hw/mthca/mthca_main.c
+++ b/drivers/infiniband/hw/mthca/mthca_main.c
@@ -1250,12 +1250,14 @@ static void __mthca_remove_one(struct pci_dev *pdev)
 int __mthca_restart_one(struct pci_dev *pdev)
 {
 	struct mthca_dev *mdev;
+	int hca_type;
 
 	mdev = pci_get_drvdata(pdev);
 	if (!mdev)
 		return -ENODEV;
+	hca_type = mdev->hca_type;
 	__mthca_remove_one(pdev);
-	return __mthca_init_one(pdev, mdev->hca_type);
+	return __mthca_init_one(pdev, hca_type);
 }
 
 static int __devinit mthca_init_one(struct pci_dev *pdev,
diff --git a/drivers/infiniband/hw/mthca/mthca_memfree.c b/drivers/infiniband/hw/mthca/mthca_memfree.c
index 48f7c65..e61f3e6 100644
--- a/drivers/infiniband/hw/mthca/mthca_memfree.c
+++ b/drivers/infiniband/hw/mthca/mthca_memfree.c
@@ -36,6 +36,7 @@
 
 #include <linux/mm.h>
 #include <linux/scatterlist.h>
+#include <linux/sched.h>
 
 #include <asm/page.h>
 
diff --git a/drivers/infiniband/hw/mthca/mthca_qp.c b/drivers/infiniband/hw/mthca/mthca_qp.c
index 72fabb8..0276649 100644
--- a/drivers/infiniband/hw/mthca/mthca_qp.c
+++ b/drivers/infiniband/hw/mthca/mthca_qp.c
@@ -37,6 +37,7 @@
 
 #include <linux/string.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 
 #include <asm/io.h>
 
@@ -295,7 +296,7 @@ static int to_mthca_st(int transport)
 	}
 }
 
-static void store_attrs(struct mthca_sqp *sqp, struct ib_qp_attr *attr,
+static void store_attrs(struct mthca_sqp *sqp, const struct ib_qp_attr *attr,
 			int attr_mask)
 {
 	if (attr_mask & IB_QP_PKEY_INDEX)
@@ -327,7 +328,7 @@ static void init_port(struct mthca_dev *dev, int port)
 		mthca_warn(dev, "INIT_IB returned status %02x.\n", status);
 }
 
-static __be32 get_hw_access_flags(struct mthca_qp *qp, struct ib_qp_attr *attr,
+static __be32 get_hw_access_flags(struct mthca_qp *qp, const struct ib_qp_attr *attr,
 				  int attr_mask)
 {
 	u8 dest_rd_atomic;
@@ -510,7 +511,7 @@ out:
 	return err;
 }
 
-static int mthca_path_set(struct mthca_dev *dev, struct ib_ah_attr *ah,
+static int mthca_path_set(struct mthca_dev *dev, const struct ib_ah_attr *ah,
 			  struct mthca_qp_path *path, u8 port)
 {
 	path->g_mylmc     = ah->src_path_bits & 0x7f;
@@ -538,12 +539,12 @@ static int mthca_path_set(struct mthca_dev *dev, struct ib_ah_attr *ah,
 	return 0;
 }
 
-int mthca_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,
-		    struct ib_udata *udata)
+static int __mthca_modify_qp(struct ib_qp *ibqp,
+			     const struct ib_qp_attr *attr, int attr_mask,
+			     enum ib_qp_state cur_state, enum ib_qp_state new_state)
 {
 	struct mthca_dev *dev = to_mdev(ibqp->device);
 	struct mthca_qp *qp = to_mqp(ibqp);
-	enum ib_qp_state cur_state, new_state;
 	struct mthca_mailbox *mailbox;
 	struct mthca_qp_param *qp_param;
 	struct mthca_qp_context *qp_context;
@@ -551,60 +552,6 @@ int mthca_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,
 	u8 status;
 	int err = -EINVAL;
 
-	mutex_lock(&qp->mutex);
-
-	if (attr_mask & IB_QP_CUR_STATE) {
-		cur_state = attr->cur_qp_state;
-	} else {
-		spin_lock_irq(&qp->sq.lock);
-		spin_lock(&qp->rq.lock);
-		cur_state = qp->state;
-		spin_unlock(&qp->rq.lock);
-		spin_unlock_irq(&qp->sq.lock);
-	}
-
-	new_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;
-
-	if (!ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type, attr_mask)) {
-		mthca_dbg(dev, "Bad QP transition (transport %d) "
-			  "%d->%d with attr 0x%08x\n",
-			  qp->transport, cur_state, new_state,
-			  attr_mask);
-		goto out;
-	}
-
-	if (cur_state == new_state && cur_state == IB_QPS_RESET) {
-		err = 0;
-		goto out;
-	}
-
-	if ((attr_mask & IB_QP_PKEY_INDEX) &&
-	     attr->pkey_index >= dev->limits.pkey_table_len) {
-		mthca_dbg(dev, "P_Key index (%u) too large. max is %d\n",
-			  attr->pkey_index, dev->limits.pkey_table_len-1);
-		goto out;
-	}
-
-	if ((attr_mask & IB_QP_PORT) &&
-	    (attr->port_num == 0 || attr->port_num > dev->limits.num_ports)) {
-		mthca_dbg(dev, "Port number (%u) is invalid\n", attr->port_num);
-		goto out;
-	}
-
-	if (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&
-	    attr->max_rd_atomic > dev->limits.max_qp_init_rdma) {
-		mthca_dbg(dev, "Max rdma_atomic as initiator %u too large (max is %d)\n",
-			  attr->max_rd_atomic, dev->limits.max_qp_init_rdma);
-		goto out;
-	}
-
-	if (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&
-	    attr->max_dest_rd_atomic > 1 << dev->qp_table.rdb_shift) {
-		mthca_dbg(dev, "Max rdma_atomic as responder %u too large (max %d)\n",
-			  attr->max_dest_rd_atomic, 1 << dev->qp_table.rdb_shift);
-		goto out;
-	}
-
 	mailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);
 	if (IS_ERR(mailbox)) {
 		err = PTR_ERR(mailbox);
@@ -891,6 +838,98 @@ int mthca_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,
 
 out_mailbox:
 	mthca_free_mailbox(dev, mailbox);
+out:
+	return err;
+}
+
+static const struct ib_qp_attr dummy_init_attr = { .port_num = 1 };
+static const int dummy_init_attr_mask[] = {
+	[IB_QPT_UD]  = (IB_QP_PKEY_INDEX		|
+			IB_QP_PORT			|
+			IB_QP_QKEY),
+	[IB_QPT_UC]  = (IB_QP_PKEY_INDEX		|
+			IB_QP_PORT			|
+			IB_QP_ACCESS_FLAGS),
+	[IB_QPT_RC]  = (IB_QP_PKEY_INDEX		|
+			IB_QP_PORT			|
+			IB_QP_ACCESS_FLAGS),
+	[IB_QPT_SMI] = (IB_QP_PKEY_INDEX		|
+			IB_QP_QKEY),
+	[IB_QPT_GSI] = (IB_QP_PKEY_INDEX		|
+			IB_QP_QKEY),
+};
+
+int mthca_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,
+		    struct ib_udata *udata)
+{
+	struct mthca_dev *dev = to_mdev(ibqp->device);
+	struct mthca_qp *qp = to_mqp(ibqp);
+	enum ib_qp_state cur_state, new_state;
+	int err = -EINVAL;
+
+	mutex_lock(&qp->mutex);
+	if (attr_mask & IB_QP_CUR_STATE) {
+		cur_state = attr->cur_qp_state;
+	} else {
+		spin_lock_irq(&qp->sq.lock);
+		spin_lock(&qp->rq.lock);
+		cur_state = qp->state;
+		spin_unlock(&qp->rq.lock);
+		spin_unlock_irq(&qp->sq.lock);
+	}
+
+	new_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;
+
+	if (!ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type, attr_mask)) {
+		mthca_dbg(dev, "Bad QP transition (transport %d) "
+			  "%d->%d with attr 0x%08x\n",
+			  qp->transport, cur_state, new_state,
+			  attr_mask);
+		goto out;
+	}
+
+	if ((attr_mask & IB_QP_PKEY_INDEX) &&
+	     attr->pkey_index >= dev->limits.pkey_table_len) {
+		mthca_dbg(dev, "P_Key index (%u) too large. max is %d\n",
+			  attr->pkey_index, dev->limits.pkey_table_len-1);
+		goto out;
+	}
+
+	if ((attr_mask & IB_QP_PORT) &&
+	    (attr->port_num == 0 || attr->port_num > dev->limits.num_ports)) {
+		mthca_dbg(dev, "Port number (%u) is invalid\n", attr->port_num);
+		goto out;
+	}
+
+	if (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&
+	    attr->max_rd_atomic > dev->limits.max_qp_init_rdma) {
+		mthca_dbg(dev, "Max rdma_atomic as initiator %u too large (max is %d)\n",
+			  attr->max_rd_atomic, dev->limits.max_qp_init_rdma);
+		goto out;
+	}
+
+	if (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&
+	    attr->max_dest_rd_atomic > 1 << dev->qp_table.rdb_shift) {
+		mthca_dbg(dev, "Max rdma_atomic as responder %u too large (max %d)\n",
+			  attr->max_dest_rd_atomic, 1 << dev->qp_table.rdb_shift);
+		goto out;
+	}
+
+	if (cur_state == new_state && cur_state == IB_QPS_RESET) {
+		err = 0;
+		goto out;
+	}
+
+	if (cur_state == IB_QPS_RESET && new_state == IB_QPS_ERR) {
+		err = __mthca_modify_qp(ibqp, &dummy_init_attr,
+					dummy_init_attr_mask[ibqp->qp_type],
+					IB_QPS_RESET, IB_QPS_INIT);
+		if (err)
+			goto out;
+		cur_state = IB_QPS_INIT;
+	}
+
+	err = __mthca_modify_qp(ibqp, attr, attr_mask, cur_state, new_state);
 
 out:
 	mutex_unlock(&qp->mutex);
diff --git a/drivers/infiniband/hw/mthca/mthca_srq.c b/drivers/infiniband/hw/mthca/mthca_srq.c
index 61974b0..b8f05a5 100644
--- a/drivers/infiniband/hw/mthca/mthca_srq.c
+++ b/drivers/infiniband/hw/mthca/mthca_srq.c
@@ -34,6 +34,7 @@
 
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/sched.h>
 
 #include <asm/io.h>
 
diff --git a/drivers/infiniband/ulp/ipoib/ipoib.h b/drivers/infiniband/ulp/ipoib/ipoib.h
index 87310ee..a0b3782 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib.h
+++ b/drivers/infiniband/ulp/ipoib/ipoib.h
@@ -132,12 +132,46 @@ struct ipoib_cm_data {
 	__be32 mtu;
 };
 
+/*
+ * Quoting 10.3.1 Queue Pair and EE Context States:
+ *
+ * Note, for QPs that are associated with an SRQ, the Consumer should take the
+ * QP through the Error State before invoking a Destroy QP or a Modify QP to the
+ * Reset State.  The Consumer may invoke the Destroy QP without first performing
+ * a Modify QP to the Error State and waiting for the Affiliated Asynchronous
+ * Last WQE Reached Event. However, if the Consumer does not wait for the
+ * Affiliated Asynchronous Last WQE Reached Event, then WQE and Data Segment
+ * leakage may occur. Therefore, it is good programming practice to tear down a
+ * QP that is associated with an SRQ by using the following process:
+ *
+ * - Put the QP in the Error State
+ * - Wait for the Affiliated Asynchronous Last WQE Reached Event;
+ * - either:
+ *       drain the CQ by invoking the Poll CQ verb and either wait for CQ
+ *       to be empty or the number of Poll CQ operations has exceeded
+ *       CQ capacity size;
+ * - or
+ *       post another WR that completes on the same CQ and wait for this
+ *       WR to return as a WC;
+ * - and then invoke a Destroy QP or Reset QP.
+ *
+ * We use the second option and wait for a completion on the
+ * rx_drain_qp before destroying QPs attached to our SRQ.
+ */
+
+enum ipoib_cm_state {
+	IPOIB_CM_RX_LIVE,
+	IPOIB_CM_RX_ERROR, /* Ignored by stale task */
+	IPOIB_CM_RX_FLUSH  /* Last WQE Reached event observed */
+};
+
 struct ipoib_cm_rx {
 	struct ib_cm_id     *id;
 	struct ib_qp        *qp;
 	struct list_head     list;
 	struct net_device   *dev;
 	unsigned long        jiffies;
+	enum ipoib_cm_state  state;
 };
 
 struct ipoib_cm_tx {
@@ -165,10 +199,16 @@ struct ipoib_cm_dev_priv {
 	struct ib_srq  	       *srq;
 	struct ipoib_cm_rx_buf *srq_ring;
 	struct ib_cm_id        *id;
-	struct list_head        passive_ids;
+	struct ib_qp           *rx_drain_qp;   /* generates WR described in 10.3.1 */
+	struct list_head        passive_ids;   /* state: LIVE */
+	struct list_head        rx_error_list; /* state: ERROR */
+	struct list_head        rx_flush_list; /* state: FLUSH, drain not started */
+	struct list_head        rx_drain_list; /* state: FLUSH, drain started */
+	struct list_head        rx_reap_list;  /* state: FLUSH, drain done */
 	struct work_struct      start_task;
 	struct work_struct      reap_task;
 	struct work_struct      skb_task;
+	struct work_struct      rx_reap_task;
 	struct delayed_work     stale_task;
 	struct sk_buff_head     skb_queue;
 	struct list_head        start_list;
@@ -201,15 +241,17 @@ struct ipoib_dev_priv {
 	struct list_head multicast_list;
 	struct rb_root multicast_tree;
 
-	struct delayed_work pkey_task;
+	struct delayed_work pkey_poll_task;
 	struct delayed_work mcast_task;
 	struct work_struct flush_task;
 	struct work_struct restart_task;
 	struct delayed_work ah_reap_task;
+	struct work_struct pkey_event_task;
 
 	struct ib_device *ca;
 	u8            	  port;
 	u16           	  pkey;
+	u16               pkey_index;
 	struct ib_pd  	 *pd;
 	struct ib_mr  	 *mr;
 	struct ib_cq  	 *cq;
@@ -333,12 +375,13 @@ struct ipoib_dev_priv *ipoib_intf_alloc(const char *format);
 
 int ipoib_ib_dev_init(struct net_device *dev, struct ib_device *ca, int port);
 void ipoib_ib_dev_flush(struct work_struct *work);
+void ipoib_pkey_event(struct work_struct *work);
 void ipoib_ib_dev_cleanup(struct net_device *dev);
 
 int ipoib_ib_dev_open(struct net_device *dev);
 int ipoib_ib_dev_up(struct net_device *dev);
 int ipoib_ib_dev_down(struct net_device *dev, int flush);
-int ipoib_ib_dev_stop(struct net_device *dev);
+int ipoib_ib_dev_stop(struct net_device *dev, int flush);
 
 int ipoib_dev_init(struct net_device *dev, struct ib_device *ca, int port);
 void ipoib_dev_cleanup(struct net_device *dev);
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
index eec833b..ffec794 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
@@ -37,6 +37,7 @@
 #include <net/dst.h>
 #include <net/icmp.h>
 #include <linux/icmpv6.h>
+#include <linux/delay.h>
 
 #ifdef CONFIG_INFINIBAND_IPOIB_DEBUG_DATA
 static int data_debug_level;
@@ -62,6 +63,16 @@ struct ipoib_cm_id {
 	u32 remote_mtu;
 };
 
+static struct ib_qp_attr ipoib_cm_err_attr = {
+	.qp_state = IB_QPS_ERR
+};
+
+#define IPOIB_CM_RX_DRAIN_WRID 0x7fffffff
+
+static struct ib_recv_wr ipoib_cm_rx_drain_wr = {
+	.wr_id = IPOIB_CM_RX_DRAIN_WRID
+};
+
 static int ipoib_cm_tx_handler(struct ib_cm_id *cm_id,
 			       struct ib_cm_event *event);
 
@@ -150,11 +161,44 @@ partial_error:
 	return NULL;
 }
 
+static void ipoib_cm_start_rx_drain(struct ipoib_dev_priv* priv)
+{
+	struct ib_recv_wr *bad_wr;
+
+	/* rx_drain_qp send queue depth is 1, so
+	 * make sure we have at most 1 outstanding WR. */
+	if (list_empty(&priv->cm.rx_flush_list) ||
+	    !list_empty(&priv->cm.rx_drain_list))
+		return;
+
+	if (ib_post_recv(priv->cm.rx_drain_qp, &ipoib_cm_rx_drain_wr, &bad_wr))
+		ipoib_warn(priv, "failed to post rx_drain wr\n");
+
+	list_splice_init(&priv->cm.rx_flush_list, &priv->cm.rx_drain_list);
+}
+
+static void ipoib_cm_rx_event_handler(struct ib_event *event, void *ctx)
+{
+	struct ipoib_cm_rx *p = ctx;
+	struct ipoib_dev_priv *priv = netdev_priv(p->dev);
+	unsigned long flags;
+
+	if (event->event != IB_EVENT_QP_LAST_WQE_REACHED)
+		return;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	list_move(&p->list, &priv->cm.rx_flush_list);
+	p->state = IPOIB_CM_RX_FLUSH;
+	ipoib_cm_start_rx_drain(priv);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
 static struct ib_qp *ipoib_cm_create_rx_qp(struct net_device *dev,
 					   struct ipoib_cm_rx *p)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct ib_qp_init_attr attr = {
+		.event_handler = ipoib_cm_rx_event_handler,
 		.send_cq = priv->cq, /* does not matter, we never send anything */
 		.recv_cq = priv->cq,
 		.srq = priv->cm.srq,
@@ -256,6 +300,7 @@ static int ipoib_cm_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *even
 
 	cm_id->context = p;
 	p->jiffies = jiffies;
+	p->state = IPOIB_CM_RX_LIVE;
 	spin_lock_irq(&priv->lock);
 	if (list_empty(&priv->cm.passive_ids))
 		queue_delayed_work(ipoib_workqueue,
@@ -277,7 +322,6 @@ static int ipoib_cm_rx_handler(struct ib_cm_id *cm_id,
 {
 	struct ipoib_cm_rx *p;
 	struct ipoib_dev_priv *priv;
-	int ret;
 
 	switch (event->event) {
 	case IB_CM_REQ_RECEIVED:
@@ -289,20 +333,9 @@ static int ipoib_cm_rx_handler(struct ib_cm_id *cm_id,
 	case IB_CM_REJ_RECEIVED:
 		p = cm_id->context;
 		priv = netdev_priv(p->dev);
-		spin_lock_irq(&priv->lock);
-		if (list_empty(&p->list))
-			ret = 0; /* Connection is going away already. */
-		else {
-			list_del_init(&p->list);
-			ret = -ECONNRESET;
-		}
-		spin_unlock_irq(&priv->lock);
-		if (ret) {
-			ib_destroy_qp(p->qp);
-			kfree(p);
-			return ret;
-		}
-		return 0;
+		if (ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE))
+			ipoib_warn(priv, "unable to move qp to error state\n");
+		/* Fall through */
 	default:
 		return 0;
 	}
@@ -354,8 +387,15 @@ void ipoib_cm_handle_rx_wc(struct net_device *dev, struct ib_wc *wc)
 		       wr_id, wc->status);
 
 	if (unlikely(wr_id >= ipoib_recvq_size)) {
-		ipoib_warn(priv, "cm recv completion event with wrid %d (> %d)\n",
-			   wr_id, ipoib_recvq_size);
+		if (wr_id == (IPOIB_CM_RX_DRAIN_WRID & ~IPOIB_CM_OP_SRQ)) {
+			spin_lock_irqsave(&priv->lock, flags);
+			list_splice_init(&priv->cm.rx_drain_list, &priv->cm.rx_reap_list);
+			ipoib_cm_start_rx_drain(priv);
+			queue_work(ipoib_workqueue, &priv->cm.rx_reap_task);
+			spin_unlock_irqrestore(&priv->lock, flags);
+		} else
+			ipoib_warn(priv, "cm recv completion event with wrid %d (> %d)\n",
+				   wr_id, ipoib_recvq_size);
 		return;
 	}
 
@@ -374,9 +414,9 @@ void ipoib_cm_handle_rx_wc(struct net_device *dev, struct ib_wc *wc)
 		if (p && time_after_eq(jiffies, p->jiffies + IPOIB_CM_RX_UPDATE_TIME)) {
 			spin_lock_irqsave(&priv->lock, flags);
 			p->jiffies = jiffies;
-			/* Move this entry to list head, but do
-			 * not re-add it if it has been removed. */
-			if (!list_empty(&p->list))
+			/* Move this entry to list head, but do not re-add it
+			 * if it has been moved out of list. */
+			if (p->state == IPOIB_CM_RX_LIVE)
 				list_move(&p->list, &priv->cm.passive_ids);
 			spin_unlock_irqrestore(&priv->lock, flags);
 		}
@@ -583,17 +623,43 @@ static void ipoib_cm_tx_completion(struct ib_cq *cq, void *tx_ptr)
 int ipoib_cm_dev_open(struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
+	struct ib_qp_init_attr qp_init_attr = {
+		.send_cq = priv->cq,   /* does not matter, we never send anything */
+		.recv_cq = priv->cq,
+		.cap.max_send_wr = 1,  /* FIXME: 0 Seems not to work */
+		.cap.max_send_sge = 1, /* FIXME: 0 Seems not to work */
+		.cap.max_recv_wr = 1,
+		.cap.max_recv_sge = 1, /* FIXME: 0 Seems not to work */
+		.sq_sig_type = IB_SIGNAL_ALL_WR,
+		.qp_type = IB_QPT_UC,
+	};
 	int ret;
 
 	if (!IPOIB_CM_SUPPORTED(dev->dev_addr))
 		return 0;
 
+	priv->cm.rx_drain_qp = ib_create_qp(priv->pd, &qp_init_attr);
+	if (IS_ERR(priv->cm.rx_drain_qp)) {
+		printk(KERN_WARNING "%s: failed to create CM ID\n", priv->ca->name);
+		ret = PTR_ERR(priv->cm.rx_drain_qp);
+		return ret;
+	}
+
+	/*
+	 * We put the QP in error state directly.  This way, a "flush
+	 * error" WC will be immediately generated for each WR we post.
+	 */
+	ret = ib_modify_qp(priv->cm.rx_drain_qp, &ipoib_cm_err_attr, IB_QP_STATE);
+	if (ret) {
+		ipoib_warn(priv, "failed to modify drain QP to error: %d\n", ret);
+		goto err_qp;
+	}
+
 	priv->cm.id = ib_create_cm_id(priv->ca, ipoib_cm_rx_handler, dev);
 	if (IS_ERR(priv->cm.id)) {
 		printk(KERN_WARNING "%s: failed to create CM ID\n", priv->ca->name);
 		ret = PTR_ERR(priv->cm.id);
-		priv->cm.id = NULL;
-		return ret;
+		goto err_cm;
 	}
 
 	ret = ib_cm_listen(priv->cm.id, cpu_to_be64(IPOIB_CM_IETF_ID | priv->qp->qp_num),
@@ -601,35 +667,79 @@ int ipoib_cm_dev_open(struct net_device *dev)
 	if (ret) {
 		printk(KERN_WARNING "%s: failed to listen on ID 0x%llx\n", priv->ca->name,
 		       IPOIB_CM_IETF_ID | priv->qp->qp_num);
-		ib_destroy_cm_id(priv->cm.id);
-		priv->cm.id = NULL;
-		return ret;
+		goto err_listen;
 	}
+
 	return 0;
+
+err_listen:
+	ib_destroy_cm_id(priv->cm.id);
+err_cm:
+	priv->cm.id = NULL;
+err_qp:
+	ib_destroy_qp(priv->cm.rx_drain_qp);
+	return ret;
 }
 
 void ipoib_cm_dev_stop(struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
-	struct ipoib_cm_rx *p;
+	struct ipoib_cm_rx *p, *n;
+	unsigned long begin;
+	LIST_HEAD(list);
+	int ret;
 
 	if (!IPOIB_CM_SUPPORTED(dev->dev_addr) || !priv->cm.id)
 		return;
 
 	ib_destroy_cm_id(priv->cm.id);
 	priv->cm.id = NULL;
+
 	spin_lock_irq(&priv->lock);
 	while (!list_empty(&priv->cm.passive_ids)) {
 		p = list_entry(priv->cm.passive_ids.next, typeof(*p), list);
-		list_del_init(&p->list);
+		list_move(&p->list, &priv->cm.rx_error_list);
+		p->state = IPOIB_CM_RX_ERROR;
 		spin_unlock_irq(&priv->lock);
+		ret = ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE);
+		if (ret)
+			ipoib_warn(priv, "unable to move qp to error state: %d\n", ret);
+		spin_lock_irq(&priv->lock);
+	}
+
+	/* Wait for all RX to be drained */
+	begin = jiffies;
+
+	while (!list_empty(&priv->cm.rx_error_list) ||
+	       !list_empty(&priv->cm.rx_flush_list) ||
+	       !list_empty(&priv->cm.rx_drain_list)) {
+		if (!time_after(jiffies, begin + 5 * HZ)) {
+			ipoib_warn(priv, "RX drain timing out\n");
+
+			/*
+			 * assume the HW is wedged and just free up everything.
+			 */
+			list_splice_init(&priv->cm.rx_flush_list, &list);
+			list_splice_init(&priv->cm.rx_error_list, &list);
+			list_splice_init(&priv->cm.rx_drain_list, &list);
+			break;
+		}
+		spin_unlock_irq(&priv->lock);
+		msleep(1);
+		spin_lock_irq(&priv->lock);
+	}
+
+	list_splice_init(&priv->cm.rx_reap_list, &list);
+
+	spin_unlock_irq(&priv->lock);
+
+	list_for_each_entry_safe(p, n, &list, list) {
 		ib_destroy_cm_id(p->id);
 		ib_destroy_qp(p->qp);
 		kfree(p);
-		spin_lock_irq(&priv->lock);
 	}
-	spin_unlock_irq(&priv->lock);
 
+	ib_destroy_qp(priv->cm.rx_drain_qp);
 	cancel_delayed_work(&priv->cm.stale_task);
 }
 
@@ -1079,24 +1189,44 @@ void ipoib_cm_skb_too_long(struct net_device* dev, struct sk_buff *skb,
 		queue_work(ipoib_workqueue, &priv->cm.skb_task);
 }
 
+static void ipoib_cm_rx_reap(struct work_struct *work)
+{
+	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,
+						   cm.rx_reap_task);
+	struct ipoib_cm_rx *p, *n;
+	LIST_HEAD(list);
+
+	spin_lock_irq(&priv->lock);
+	list_splice_init(&priv->cm.rx_reap_list, &list);
+	spin_unlock_irq(&priv->lock);
+
+	list_for_each_entry_safe(p, n, &list, list) {
+		ib_destroy_cm_id(p->id);
+		ib_destroy_qp(p->qp);
+		kfree(p);
+	}
+}
+
 static void ipoib_cm_stale_task(struct work_struct *work)
 {
 	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,
 						   cm.stale_task.work);
 	struct ipoib_cm_rx *p;
+	int ret;
 
 	spin_lock_irq(&priv->lock);
 	while (!list_empty(&priv->cm.passive_ids)) {
-		/* List if sorted by LRU, start from tail,
+		/* List is sorted by LRU, start from tail,
 		 * stop when we see a recently used entry */
 		p = list_entry(priv->cm.passive_ids.prev, typeof(*p), list);
 		if (time_before_eq(jiffies, p->jiffies + IPOIB_CM_RX_TIMEOUT))
 			break;
-		list_del_init(&p->list);
+		list_move(&p->list, &priv->cm.rx_error_list);
+		p->state = IPOIB_CM_RX_ERROR;
 		spin_unlock_irq(&priv->lock);
-		ib_destroy_cm_id(p->id);
-		ib_destroy_qp(p->qp);
-		kfree(p);
+		ret = ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE);
+		if (ret)
+			ipoib_warn(priv, "unable to move qp to error state: %d\n", ret);
 		spin_lock_irq(&priv->lock);
 	}
 
@@ -1164,9 +1294,14 @@ int ipoib_cm_dev_init(struct net_device *dev)
 	INIT_LIST_HEAD(&priv->cm.passive_ids);
 	INIT_LIST_HEAD(&priv->cm.reap_list);
 	INIT_LIST_HEAD(&priv->cm.start_list);
+	INIT_LIST_HEAD(&priv->cm.rx_error_list);
+	INIT_LIST_HEAD(&priv->cm.rx_flush_list);
+	INIT_LIST_HEAD(&priv->cm.rx_drain_list);
+	INIT_LIST_HEAD(&priv->cm.rx_reap_list);
 	INIT_WORK(&priv->cm.start_task, ipoib_cm_tx_start);
 	INIT_WORK(&priv->cm.reap_task, ipoib_cm_tx_reap);
 	INIT_WORK(&priv->cm.skb_task, ipoib_cm_skb_reap);
+	INIT_WORK(&priv->cm.rx_reap_task, ipoib_cm_rx_reap);
 	INIT_DELAYED_WORK(&priv->cm.stale_task, ipoib_cm_stale_task);
 
 	skb_queue_head_init(&priv->cm.skb_queue);
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
index 68d72c6..c1aad06 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
@@ -448,6 +448,13 @@ int ipoib_ib_dev_open(struct net_device *dev)
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	int ret;
 
+	if (ib_find_pkey(priv->ca, priv->port, priv->pkey, &priv->pkey_index)) {
+		ipoib_warn(priv, "P_Key 0x%04x not found\n", priv->pkey);
+		clear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);
+		return -1;
+	}
+	set_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);
+
 	ret = ipoib_init_qp(dev);
 	if (ret) {
 		ipoib_warn(priv, "ipoib_init_qp returned %d\n", ret);
@@ -457,14 +464,14 @@ int ipoib_ib_dev_open(struct net_device *dev)
 	ret = ipoib_ib_post_receives(dev);
 	if (ret) {
 		ipoib_warn(priv, "ipoib_ib_post_receives returned %d\n", ret);
-		ipoib_ib_dev_stop(dev);
+		ipoib_ib_dev_stop(dev, 1);
 		return -1;
 	}
 
 	ret = ipoib_cm_dev_open(dev);
 	if (ret) {
-		ipoib_warn(priv, "ipoib_ib_post_receives returned %d\n", ret);
-		ipoib_ib_dev_stop(dev);
+		ipoib_warn(priv, "ipoib_cm_dev_open returned %d\n", ret);
+		ipoib_ib_dev_stop(dev, 1);
 		return -1;
 	}
 
@@ -516,7 +523,7 @@ int ipoib_ib_dev_down(struct net_device *dev, int flush)
 	if (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags)) {
 		mutex_lock(&pkey_mutex);
 		set_bit(IPOIB_PKEY_STOP, &priv->flags);
-		cancel_delayed_work(&priv->pkey_task);
+		cancel_delayed_work(&priv->pkey_poll_task);
 		mutex_unlock(&pkey_mutex);
 		if (flush)
 			flush_workqueue(ipoib_workqueue);
@@ -543,7 +550,7 @@ static int recvs_pending(struct net_device *dev)
 	return pending;
 }
 
-int ipoib_ib_dev_stop(struct net_device *dev)
+int ipoib_ib_dev_stop(struct net_device *dev, int flush)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct ib_qp_attr qp_attr;
@@ -629,7 +636,8 @@ timeout:
 	/* Wait for all AHs to be reaped */
 	set_bit(IPOIB_STOP_REAPER, &priv->flags);
 	cancel_delayed_work(&priv->ah_reap_task);
-	flush_workqueue(ipoib_workqueue);
+	if (flush)
+		flush_workqueue(ipoib_workqueue);
 
 	begin = jiffies;
 
@@ -673,13 +681,24 @@ int ipoib_ib_dev_init(struct net_device *dev, struct ib_device *ca, int port)
 	return 0;
 }
 
-void ipoib_ib_dev_flush(struct work_struct *work)
+static void __ipoib_ib_dev_flush(struct ipoib_dev_priv *priv, int pkey_event)
 {
-	struct ipoib_dev_priv *cpriv, *priv =
-		container_of(work, struct ipoib_dev_priv, flush_task);
+	struct ipoib_dev_priv *cpriv;
 	struct net_device *dev = priv->dev;
+	u16 new_index;
+
+	mutex_lock(&priv->vlan_mutex);
 
-	if (!test_bit(IPOIB_FLAG_INITIALIZED, &priv->flags) ) {
+	/*
+	 * Flush any child interfaces too -- they might be up even if
+	 * the parent is down.
+	 */
+	list_for_each_entry(cpriv, &priv->child_intfs, list)
+		__ipoib_ib_dev_flush(cpriv, pkey_event);
+
+	mutex_unlock(&priv->vlan_mutex);
+
+	if (!test_bit(IPOIB_FLAG_INITIALIZED, &priv->flags)) {
 		ipoib_dbg(priv, "Not flushing - IPOIB_FLAG_INITIALIZED not set.\n");
 		return;
 	}
@@ -689,10 +708,32 @@ void ipoib_ib_dev_flush(struct work_struct *work)
 		return;
 	}
 
+	if (pkey_event) {
+		if (ib_find_pkey(priv->ca, priv->port, priv->pkey, &new_index)) {
+			clear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);
+			ipoib_ib_dev_down(dev, 0);
+			ipoib_pkey_dev_delay_open(dev);
+			return;
+		}
+		set_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);
+
+		/* restart QP only if P_Key index is changed */
+		if (new_index == priv->pkey_index) {
+			ipoib_dbg(priv, "Not flushing - P_Key index not changed.\n");
+			return;
+		}
+		priv->pkey_index = new_index;
+	}
+
 	ipoib_dbg(priv, "flushing\n");
 
 	ipoib_ib_dev_down(dev, 0);
 
+	if (pkey_event) {
+		ipoib_ib_dev_stop(dev, 0);
+		ipoib_ib_dev_open(dev);
+	}
+
 	/*
 	 * The device could have been brought down between the start and when
 	 * we get here, don't bring it back up if it's not configured up
@@ -701,14 +742,24 @@ void ipoib_ib_dev_flush(struct work_struct *work)
 		ipoib_ib_dev_up(dev);
 		ipoib_mcast_restart_task(&priv->restart_task);
 	}
+}
 
-	mutex_lock(&priv->vlan_mutex);
+void ipoib_ib_dev_flush(struct work_struct *work)
+{
+	struct ipoib_dev_priv *priv =
+		container_of(work, struct ipoib_dev_priv, flush_task);
 
-	/* Flush any child interfaces too */
-	list_for_each_entry(cpriv, &priv->child_intfs, list)
-		ipoib_ib_dev_flush(&cpriv->flush_task);
+	ipoib_dbg(priv, "Flushing %s\n", priv->dev->name);
+	__ipoib_ib_dev_flush(priv, 0);
+}
 
-	mutex_unlock(&priv->vlan_mutex);
+void ipoib_pkey_event(struct work_struct *work)
+{
+	struct ipoib_dev_priv *priv =
+		container_of(work, struct ipoib_dev_priv, pkey_event_task);
+
+	ipoib_dbg(priv, "Flushing %s and restarting its QP\n", priv->dev->name);
+	__ipoib_ib_dev_flush(priv, 1);
 }
 
 void ipoib_ib_dev_cleanup(struct net_device *dev)
@@ -736,7 +787,7 @@ void ipoib_ib_dev_cleanup(struct net_device *dev)
 void ipoib_pkey_poll(struct work_struct *work)
 {
 	struct ipoib_dev_priv *priv =
-		container_of(work, struct ipoib_dev_priv, pkey_task.work);
+		container_of(work, struct ipoib_dev_priv, pkey_poll_task.work);
 	struct net_device *dev = priv->dev;
 
 	ipoib_pkey_dev_check_presence(dev);
@@ -747,7 +798,7 @@ void ipoib_pkey_poll(struct work_struct *work)
 		mutex_lock(&pkey_mutex);
 		if (!test_bit(IPOIB_PKEY_STOP, &priv->flags))
 			queue_delayed_work(ipoib_workqueue,
-					   &priv->pkey_task,
+					   &priv->pkey_poll_task,
 					   HZ);
 		mutex_unlock(&pkey_mutex);
 	}
@@ -766,7 +817,7 @@ int ipoib_pkey_dev_delay_open(struct net_device *dev)
 		mutex_lock(&pkey_mutex);
 		clear_bit(IPOIB_PKEY_STOP, &priv->flags);
 		queue_delayed_work(ipoib_workqueue,
-				   &priv->pkey_task,
+				   &priv->pkey_poll_task,
 				   HZ);
 		mutex_unlock(&pkey_mutex);
 		return 1;
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index 0a428f2..894b1dc 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -107,7 +107,7 @@ int ipoib_open(struct net_device *dev)
 		return -EINVAL;
 
 	if (ipoib_ib_dev_up(dev)) {
-		ipoib_ib_dev_stop(dev);
+		ipoib_ib_dev_stop(dev, 1);
 		return -EINVAL;
 	}
 
@@ -152,7 +152,7 @@ static int ipoib_stop(struct net_device *dev)
 	flush_workqueue(ipoib_workqueue);
 
 	ipoib_ib_dev_down(dev, 1);
-	ipoib_ib_dev_stop(dev);
+	ipoib_ib_dev_stop(dev, 1);
 
 	if (!test_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags)) {
 		struct ipoib_dev_priv *cpriv;
@@ -988,7 +988,8 @@ static void ipoib_setup(struct net_device *dev)
 	INIT_LIST_HEAD(&priv->dead_ahs);
 	INIT_LIST_HEAD(&priv->multicast_list);
 
-	INIT_DELAYED_WORK(&priv->pkey_task,    ipoib_pkey_poll);
+	INIT_DELAYED_WORK(&priv->pkey_poll_task, ipoib_pkey_poll);
+	INIT_WORK(&priv->pkey_event_task, ipoib_pkey_event);
 	INIT_DELAYED_WORK(&priv->mcast_task,   ipoib_mcast_join_task);
 	INIT_WORK(&priv->flush_task,   ipoib_ib_dev_flush);
 	INIT_WORK(&priv->restart_task, ipoib_mcast_restart_task);
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
index 54fbead..aae3670 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
@@ -524,7 +524,7 @@ void ipoib_mcast_join_task(struct work_struct *work)
 		return;
 
 	if (ib_query_gid(priv->ca, priv->port, 0, &priv->local_gid))
-		ipoib_warn(priv, "ib_gid_entry_get() failed\n");
+		ipoib_warn(priv, "ib_query_gid() failed\n");
 	else
 		memcpy(priv->dev->dev_addr + 4, priv->local_gid.raw, sizeof (union ib_gid));
 
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c b/drivers/infiniband/ulp/ipoib/ipoib_verbs.c
index 5c3c6a4..982eb88 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_verbs.c
@@ -33,8 +33,6 @@
  * $Id: ipoib_verbs.c 1349 2004-12-16 21:09:43Z roland $
  */
 
-#include <rdma/ib_cache.h>
-
 #include "ipoib.h"
 
 int ipoib_mcast_attach(struct net_device *dev, u16 mlid, union ib_gid *mgid)
@@ -49,7 +47,7 @@ int ipoib_mcast_attach(struct net_device *dev, u16 mlid, union ib_gid *mgid)
 	if (!qp_attr)
 		goto out;
 
-	if (ib_find_cached_pkey(priv->ca, priv->port, priv->pkey, &pkey_index)) {
+	if (ib_find_pkey(priv->ca, priv->port, priv->pkey, &pkey_index)) {
 		clear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);
 		ret = -ENXIO;
 		goto out;
@@ -94,26 +92,16 @@ int ipoib_init_qp(struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	int ret;
-	u16 pkey_index;
 	struct ib_qp_attr qp_attr;
 	int attr_mask;
 
-	/*
-	 * Search through the port P_Key table for the requested pkey value.
-	 * The port has to be assigned to the respective IB partition in
-	 * advance.
-	 */
-	ret = ib_find_cached_pkey(priv->ca, priv->port, priv->pkey, &pkey_index);
-	if (ret) {
-		clear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);
-		return ret;
-	}
-	set_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);
+	if (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags))
+		return -1;
 
 	qp_attr.qp_state = IB_QPS_INIT;
 	qp_attr.qkey = 0;
 	qp_attr.port_num = priv->port;
-	qp_attr.pkey_index = pkey_index;
+	qp_attr.pkey_index = priv->pkey_index;
 	attr_mask =
 	    IB_QP_QKEY |
 	    IB_QP_PORT |
@@ -185,7 +173,7 @@ int ipoib_transport_dev_init(struct net_device *dev, struct ib_device *ca)
 	size = ipoib_sendq_size + ipoib_recvq_size + 1;
 	ret = ipoib_cm_dev_init(dev);
 	if (!ret)
-		size += ipoib_recvq_size;
+		size += ipoib_recvq_size + 1 /* 1 extra for rx_drain_qp */;
 
 	priv->cq = ib_create_cq(priv->ca, ipoib_ib_completion, NULL, dev, size, 0);
 	if (IS_ERR(priv->cq)) {
@@ -259,14 +247,18 @@ void ipoib_event(struct ib_event_handler *handler,
 	struct ipoib_dev_priv *priv =
 		container_of(handler, struct ipoib_dev_priv, event_handler);
 
-	if ((record->event == IB_EVENT_PORT_ERR    ||
-	     record->event == IB_EVENT_PKEY_CHANGE ||
-	     record->event == IB_EVENT_PORT_ACTIVE ||
-	     record->event == IB_EVENT_LID_CHANGE  ||
-	     record->event == IB_EVENT_SM_CHANGE   ||
-	     record->event == IB_EVENT_CLIENT_REREGISTER) &&
-	    record->element.port_num == priv->port) {
+	if (record->element.port_num != priv->port)
+		return;
+
+	if (record->event == IB_EVENT_PORT_ERR    ||
+	    record->event == IB_EVENT_PORT_ACTIVE ||
+	    record->event == IB_EVENT_LID_CHANGE  ||
+	    record->event == IB_EVENT_SM_CHANGE   ||
+	    record->event == IB_EVENT_CLIENT_REREGISTER) {
 		ipoib_dbg(priv, "Port state change event\n");
 		queue_work(ipoib_workqueue, &priv->flush_task);
+	} else if (record->event == IB_EVENT_PKEY_CHANGE) {
+		ipoib_dbg(priv, "P_Key change event on port:%d\n", priv->port);
+		queue_work(ipoib_workqueue, &priv->pkey_event_task);
 	}
 }
diff --git a/drivers/input/joystick/iforce/iforce-main.c b/drivers/input/joystick/iforce/iforce-main.c
index fb129c4..682244b 100644
--- a/drivers/input/joystick/iforce/iforce-main.c
+++ b/drivers/input/joystick/iforce/iforce-main.c
@@ -370,10 +370,8 @@ int iforce_init_device(struct iforce *iforce)
 
 /*
  * Disable spring, enable force feedback.
- * FIXME: We should use iforce_set_autocenter() et al here.
  */
-
-	iforce_send_packet(iforce, FF_CMD_AUTOCENTER, "\004\000");
+	iforce_set_autocenter(input_dev, 0);
 
 /*
  * Find appropriate device entry
diff --git a/drivers/input/joystick/iforce/iforce-packets.c b/drivers/input/joystick/iforce/iforce-packets.c
index 21c4e13..3154ccd 100644
--- a/drivers/input/joystick/iforce/iforce-packets.c
+++ b/drivers/input/joystick/iforce/iforce-packets.c
@@ -246,6 +246,8 @@ void iforce_process_packet(struct iforce *iforce, u16 cmd, unsigned char *data)
 
 int iforce_get_id_packet(struct iforce *iforce, char *packet)
 {
+	int status;
+
 	switch (iforce->bus) {
 
 	case IFORCE_USB:
@@ -254,18 +256,22 @@ int iforce_get_id_packet(struct iforce *iforce, char *packet)
 		iforce->cr.bRequest = packet[0];
 		iforce->ctrl->dev = iforce->usbdev;
 
-		if (usb_submit_urb(iforce->ctrl, GFP_ATOMIC))
+		status = usb_submit_urb(iforce->ctrl, GFP_ATOMIC);
+		if (status) {
+			err("usb_submit_urb failed %d", status);
 			return -1;
+		}
 
 		wait_event_interruptible_timeout(iforce->wait,
 			iforce->ctrl->status != -EINPROGRESS, HZ);
 
 		if (iforce->ctrl->status) {
+			dbg("iforce->ctrl->status = %d", iforce->ctrl->status);
 			usb_unlink_urb(iforce->ctrl);
 			return -1;
 		}
 #else
-		err("iforce_get_id_packet: iforce->bus = USB!");
+		dbg("iforce_get_id_packet: iforce->bus = USB!");
 #endif
 		break;
 
diff --git a/drivers/input/joystick/iforce/iforce-usb.c b/drivers/input/joystick/iforce/iforce-usb.c
index 750099d..1457b73 100644
--- a/drivers/input/joystick/iforce/iforce-usb.c
+++ b/drivers/input/joystick/iforce/iforce-usb.c
@@ -65,6 +65,7 @@ void iforce_usb_xmit(struct iforce *iforce)
 	XMIT_INC(iforce->xmit.tail, n);
 
 	if ( (n=usb_submit_urb(iforce->out, GFP_ATOMIC)) ) {
+		clear_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags);
 		warn("usb_submit_urb failed %d\n", n);
 	}
 
@@ -163,8 +164,8 @@ static int iforce_usb_probe(struct usb_interface *intf,
 	usb_fill_int_urb(iforce->irq, dev, usb_rcvintpipe(dev, epirq->bEndpointAddress),
 			iforce->data, 16, iforce_usb_irq, iforce, epirq->bInterval);
 
-	usb_fill_bulk_urb(iforce->out, dev, usb_sndbulkpipe(dev, epout->bEndpointAddress),
-			iforce + 1, 32, iforce_usb_out, iforce);
+	usb_fill_int_urb(iforce->out, dev, usb_sndintpipe(dev, epout->bEndpointAddress),
+			iforce + 1, 32, iforce_usb_out, iforce, epout->bInterval);
 
 	usb_fill_control_urb(iforce->ctrl, dev, usb_rcvctrlpipe(dev, 0),
 			(void*) &iforce->cr, iforce->edata, 16, iforce_usb_ctrl, iforce);
diff --git a/drivers/input/misc/input-polldev.c b/drivers/input/misc/input-polldev.c
index 1b2b9c9..b773d4c 100644
--- a/drivers/input/misc/input-polldev.c
+++ b/drivers/input/misc/input-polldev.c
@@ -12,6 +12,11 @@
 #include <linux/mutex.h>
 #include <linux/input-polldev.h>
 
+MODULE_AUTHOR("Dmitry Torokhov <dtor@mail.ru>");
+MODULE_DESCRIPTION("Generic implementation of a polled input device");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.1");
+
 static DEFINE_MUTEX(polldev_mutex);
 static int polldev_users;
 static struct workqueue_struct *polldev_wq;
diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c
index cf3e466..2c5f11a 100644
--- a/drivers/input/mouse/alps.c
+++ b/drivers/input/mouse/alps.c
@@ -251,11 +251,15 @@ static const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int
 
 	dbg("E7 report: %2.2x %2.2x %2.2x", param[0], param[1], param[2]);
 
-	for (i = 0; i < ARRAY_SIZE(rates) && param[2] != rates[i]; i++);
-	*version = (param[0] << 8) | (param[1] << 4) | i;
+	if (version) {
+		for (i = 0; i < ARRAY_SIZE(rates) && param[2] != rates[i]; i++)
+			/* empty */;
+		*version = (param[0] << 8) | (param[1] << 4) | i;
+	}
 
 	for (i = 0; i < ARRAY_SIZE(alps_model_data); i++)
-		if (!memcmp(param, alps_model_data[i].signature, sizeof(alps_model_data[i].signature)))
+		if (!memcmp(param, alps_model_data[i].signature,
+			    sizeof(alps_model_data[i].signature)))
 			return alps_model_data + i;
 
 	return NULL;
@@ -380,32 +384,46 @@ static int alps_poll(struct psmouse *psmouse)
 	return 0;
 }
 
-static int alps_reconnect(struct psmouse *psmouse)
+static int alps_hw_init(struct psmouse *psmouse, int *version)
 {
 	struct alps_data *priv = psmouse->private;
-	int version;
-
-	psmouse_reset(psmouse);
 
-	if (!(priv->i = alps_get_model(psmouse, &version)))
+	priv->i = alps_get_model(psmouse, version);
+	if (!priv->i)
 		return -1;
 
 	if ((priv->i->flags & ALPS_PASS) && alps_passthrough_mode(psmouse, 1))
 		return -1;
 
 	if (alps_tap_mode(psmouse, 1)) {
-		printk(KERN_WARNING "alps.c: Failed to reenable hardware tapping\n");
+		printk(KERN_WARNING "alps.c: Failed to enable hardware tapping\n");
 		return -1;
 	}
 
 	if (alps_absolute_mode(psmouse)) {
-		printk(KERN_ERR "alps.c: Failed to reenable absolute mode\n");
+		printk(KERN_ERR "alps.c: Failed to enable absolute mode\n");
 		return -1;
 	}
 
 	if ((priv->i->flags & ALPS_PASS) && alps_passthrough_mode(psmouse, 0))
 		return -1;
 
+	/* ALPS needs stream mode, otherwise it won't report any data */
+	if (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)) {
+		printk(KERN_ERR "alps.c: Failed to enable stream mode\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int alps_reconnect(struct psmouse *psmouse)
+{
+	psmouse_reset(psmouse);
+
+	if (alps_hw_init(psmouse, NULL))
+		return -1;
+
 	return 0;
 }
 
@@ -430,23 +448,9 @@ int alps_init(struct psmouse *psmouse)
 		goto init_fail;
 
 	priv->dev2 = dev2;
+	psmouse->private = priv;
 
-	priv->i = alps_get_model(psmouse, &version);
-	if (!priv->i)
-		goto init_fail;
-
-	if ((priv->i->flags & ALPS_PASS) && alps_passthrough_mode(psmouse, 1))
-		goto init_fail;
-
-	if (alps_tap_mode(psmouse, 1))
-		printk(KERN_WARNING "alps.c: Failed to enable hardware tapping\n");
-
-	if (alps_absolute_mode(psmouse)) {
-		printk(KERN_ERR "alps.c: Failed to enable absolute mode\n");
-		goto init_fail;
-	}
-
-	if ((priv->i->flags & ALPS_PASS) && alps_passthrough_mode(psmouse, 0))
+	if (alps_hw_init(psmouse, &version))
 		goto init_fail;
 
 	dev1->evbit[LONG(EV_KEY)] |= BIT(EV_KEY);
@@ -493,13 +497,13 @@ int alps_init(struct psmouse *psmouse)
 	/* We are having trouble resyncing ALPS touchpads so disable it for now */
 	psmouse->resync_time = 0;
 
-	psmouse->private = priv;
 	return 0;
 
 init_fail:
 	psmouse_reset(psmouse);
 	input_free_device(dev2);
 	kfree(priv);
+	psmouse->private = NULL;
 	return -1;
 }
 
diff --git a/drivers/input/mouse/logips2pp.c b/drivers/input/mouse/logips2pp.c
index 9df74b7..0c5660d 100644
--- a/drivers/input/mouse/logips2pp.c
+++ b/drivers/input/mouse/logips2pp.c
@@ -221,6 +221,7 @@ static const struct ps2pp_info *get_model_info(unsigned char model)
 		{ 66,	PS2PP_KIND_MX,					/* MX3100 reciver */
 				PS2PP_WHEEL | PS2PP_SIDE_BTN | PS2PP_TASK_BTN |
 				PS2PP_EXTRA_BTN | PS2PP_NAV_BTN | PS2PP_HWHEEL },
+		{ 72,	PS2PP_KIND_TRACKMAN,	0 },			/* T-CH11: TrackMan Marble */
 		{ 73,	0,			PS2PP_SIDE_BTN },
 		{ 75,	PS2PP_KIND_WHEEL,	PS2PP_WHEEL },
 		{ 76,	PS2PP_KIND_WHEEL,	PS2PP_WHEEL },
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 4f09180..e5cca9b 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -12,17 +12,17 @@ menuconfig INPUT_TOUCHSCREEN
 if INPUT_TOUCHSCREEN
 
 config TOUCHSCREEN_ADS7846
-	tristate "ADS 7846/7843 based touchscreens"
+	tristate "ADS7846/TSC2046 and ADS7843 based touchscreens"
 	depends on SPI_MASTER
 	depends on HWMON = n || HWMON
 	help
 	  Say Y here if you have a touchscreen interface using the
-	  ADS7846 or ADS7843 controller, and your board-specific setup
-	  code includes that in its table of SPI devices.
+	  ADS7846/TSC2046 or ADS7843 controller, and your board-specific
+	  setup code includes that in its table of SPI devices.
 
 	  If HWMON is selected, and the driver is told the reference voltage
 	  on your board, you will also get hwmon interfaces for the voltage
-	  (and on ads7846, temperature) sensors of this chip.
+	  (and on ads7846/tsc2046, temperature) sensors of this chip.
 
 	  If unsure, say N (but it's safe to say "Y").
 
diff --git a/drivers/input/touchscreen/ads7846.c b/drivers/input/touchscreen/ads7846.c
index 693e3b2..1c9069c 100644
--- a/drivers/input/touchscreen/ads7846.c
+++ b/drivers/input/touchscreen/ads7846.c
@@ -39,6 +39,7 @@
 /*
  * This code has been heavily tested on a Nokia 770, and lightly
  * tested on other ads7846 devices (OSK/Mistral, Lubbock).
+ * TSC2046 is just newer ads7846 silicon.
  * Support for ads7843 tested on Atmel at91sam926x-EK.
  * Support for ads7845 has only been stubbed in.
  *
@@ -847,7 +848,7 @@ static int __devinit ads7846_probe(struct spi_device *spi)
 	 * may not.  So we stick to very-portable 8 bit words, both RX and TX.
 	 */
 	spi->bits_per_word = 8;
-	spi->mode = SPI_MODE_1;
+	spi->mode = SPI_MODE_0;
 	err = spi_setup(spi);
 	if (err < 0)
 		return err;
diff --git a/drivers/input/touchscreen/hp680_ts_input.c b/drivers/input/touchscreen/hp680_ts_input.c
index 61c1502..1a15475 100644
--- a/drivers/input/touchscreen/hp680_ts_input.c
+++ b/drivers/input/touchscreen/hp680_ts_input.c
@@ -1,7 +1,6 @@
 #include <linux/input.h>
 #include <linux/module.h>
 #include <linux/init.h>
-
 #include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/delay.h>
@@ -18,12 +17,12 @@
 #define	PHDR	0xa400012e
 #define SCPDR	0xa4000136
 
-static void do_softint(void *data);
+static void do_softint(struct work_struct *work);
 
 static struct input_dev *hp680_ts_dev;
-static DECLARE_WORK(work, do_softint);
+static DECLARE_DELAYED_WORK(work, do_softint);
 
-static void do_softint(void *data)
+static void do_softint(struct work_struct *work)
 {
 	int absx = 0, absy = 0;
 	u8 scpdr;
diff --git a/drivers/input/touchscreen/ucb1400_ts.c b/drivers/input/touchscreen/ucb1400_ts.c
index 6582816..f0cbcdb 100644
--- a/drivers/input/touchscreen/ucb1400_ts.c
+++ b/drivers/input/touchscreen/ucb1400_ts.c
@@ -288,9 +288,9 @@ static int ucb1400_ts_thread(void *_ucb)
 	struct ucb1400 *ucb = _ucb;
 	struct task_struct *tsk = current;
 	int valid = 0;
+	struct sched_param param = { .sched_priority = 1 };
 
-	tsk->policy = SCHED_FIFO;
-	tsk->rt_priority = 1;
+	sched_setscheduler(tsk, SCHED_FIFO, &param);
 
 	while (!kthread_should_stop()) {
 		unsigned int x, y, p;
diff --git a/drivers/isdn/hardware/eicon/capifunc.c b/drivers/isdn/hardware/eicon/capifunc.c
index ff284ae..82edc1c 100644
--- a/drivers/isdn/hardware/eicon/capifunc.c
+++ b/drivers/isdn/hardware/eicon/capifunc.c
@@ -189,21 +189,21 @@ void *TransmitBufferSet(APPL * appl, dword ref)
 {
 	appl->xbuffer_used[ref] = true;
 	DBG_PRV1(("%d:xbuf_used(%d)", appl->Id, ref + 1))
-	    return (void *) ref;
+	    return (void *)(long)ref;
 }
 
 void *TransmitBufferGet(APPL * appl, void *p)
 {
-	if (appl->xbuffer_internal[(dword) p])
-		return appl->xbuffer_internal[(dword) p];
+	if (appl->xbuffer_internal[(dword)(long)p])
+		return appl->xbuffer_internal[(dword)(long)p];
 
-	return appl->xbuffer_ptr[(dword) p];
+	return appl->xbuffer_ptr[(dword)(long)p];
 }
 
 void TransmitBufferFree(APPL * appl, void *p)
 {
-	appl->xbuffer_used[(dword) p] = false;
-	DBG_PRV1(("%d:xbuf_free(%d)", appl->Id, ((dword) p) + 1))
+	appl->xbuffer_used[(dword)(long)p] = false;
+	DBG_PRV1(("%d:xbuf_free(%d)", appl->Id, ((dword)(long)p) + 1))
 }
 
 void *ReceiveBufferGet(APPL * appl, int Num)
@@ -301,7 +301,7 @@ void sendf(APPL * appl, word command, dword Id, word Number, byte * format, ...)
 	/* if DATA_B3_IND, copy data too */
 	if (command == _DATA_B3_I) {
 		dword data = GET_DWORD(&msg.info.data_b3_ind.Data);
-		memcpy(write + length, (void *) data, dlength);
+		memcpy(write + length, (void *)(long)data, dlength);
 	}
 
 #ifndef DIVA_NO_DEBUGLIB
@@ -318,7 +318,7 @@ void sendf(APPL * appl, word command, dword Id, word Number, byte * format, ...)
 			if (myDriverDebugHandle.dbgMask & DL_BLK) {
 				xlog("\x00\x02", &msg, 0x81, length);
 				for (i = 0; i < dlength; i += 256) {
-				  DBG_BLK((((char *) GET_DWORD(&msg.info.data_b3_ind.Data)) + i,
+				  DBG_BLK((((char *)(long)GET_DWORD(&msg.info.data_b3_ind.Data)) + i,
 				  	((dlength - i) < 256) ? (dlength - i) : 256))
 				  if (!(myDriverDebugHandle.dbgMask & DL_PRV0))
 					  break; /* not more if not explicitely requested */
diff --git a/drivers/isdn/hardware/eicon/message.c b/drivers/isdn/hardware/eicon/message.c
index 784232a..ccd35d0 100644
--- a/drivers/isdn/hardware/eicon/message.c
+++ b/drivers/isdn/hardware/eicon/message.c
@@ -1,4 +1,3 @@
-
 /*
  *
   Copyright (c) Eicon Networks, 2002.
@@ -533,7 +532,7 @@ word api_put(APPL   * appl, CAPI_MSG   * msg)
         if (m->header.command == _DATA_B3_R)
         {
 
-          m->info.data_b3_req.Data = (dword)(TransmitBufferSet (appl, m->info.data_b3_req.Data));
+          m->info.data_b3_req.Data = (dword)(long)(TransmitBufferSet (appl, m->info.data_b3_req.Data));
 
         }
 
@@ -1032,7 +1031,7 @@ static void plci_free_msg_in_queue (PLCI   *plci)
       {
 
         TransmitBufferFree (plci->appl,
-          (byte   *)(((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[i]))->info.data_b3_req.Data));
+          (byte *)(long)(((CAPI_MSG *)(&((byte *)(plci->msg_in_queue))[i]))->info.data_b3_req.Data));
 
       }
 
@@ -3118,7 +3117,7 @@ byte data_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci,
        && (((byte   *)(parms[0].info)) < ((byte   *)(plci->msg_in_queue)) + sizeof(plci->msg_in_queue)))
       {
 
-        data->P = (byte   *)(*((dword   *)(parms[0].info)));
+        data->P = (byte *)(long)(*((dword *)(parms[0].info)));
 
       }
       else
@@ -3151,7 +3150,7 @@ byte data_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci,
        && (((byte   *)(parms[0].info)) < ((byte   *)(plci->msg_in_queue)) + sizeof(plci->msg_in_queue)))
       {
 
-        TransmitBufferFree (appl, (byte   *)(*((dword   *)(parms[0].info))));
+        TransmitBufferFree (appl, (byte *)(long)(*((dword *)(parms[0].info))));
 
       }
     }
@@ -4057,7 +4056,7 @@ capi_callback_suffix:
     {
       if (m->header.command == _DATA_B3_R)
 
-        TransmitBufferFree (appl, (byte   *)(m->info.data_b3_req.Data));
+        TransmitBufferFree (appl, (byte *)(long)(m->info.data_b3_req.Data));
 
       dbug(1,dprintf("Error 0x%04x from msg(0x%04x)", i, m->header.command));
       break;
@@ -7134,7 +7133,7 @@ void nl_ind(PLCI   * plci)
   case N_UDATA:
     if (!(udata_forwarding_table[plci->NL.RBuffer->P[0] >> 5] & (1L << (plci->NL.RBuffer->P[0] & 0x1f))))
     {
-      plci->RData[0].P = plci->internal_ind_buffer + (-((int)(plci->internal_ind_buffer)) & 3);
+      plci->RData[0].P = plci->internal_ind_buffer + (-((int)(long)(plci->internal_ind_buffer)) & 3);
       plci->RData[0].PLength = INTERNAL_IND_BUFFER_SIZE;
       plci->NL.R = plci->RData;
       plci->NL.RNum = 1;
diff --git a/drivers/isdn/hisax/config.c b/drivers/isdn/hisax/config.c
index da4196f..8d53a7f 100644
--- a/drivers/isdn/hisax/config.c
+++ b/drivers/isdn/hisax/config.c
@@ -1551,7 +1551,7 @@ int hisax_register(struct hisax_d_if *hisax_d_if, struct hisax_b_if *b_if[],
 	if (retval == 0) { // yuck
 		cards[i].typ = 0;
 		nrcards--;
-		return retval;
+		return -EINVAL;
 	}
 	cs = cards[i].cs;
 	hisax_d_if->cs = cs;
diff --git a/drivers/isdn/hisax/hfc_usb.c b/drivers/isdn/hisax/hfc_usb.c
index 1f18f19..b1a26e0 100644
--- a/drivers/isdn/hisax/hfc_usb.c
+++ b/drivers/isdn/hisax/hfc_usb.c
@@ -485,7 +485,6 @@ fill_isoc_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,
 {
 	int k;
 
-	spin_lock_init(&urb->lock);
 	urb->dev = dev;
 	urb->pipe = pipe;
 	urb->complete = complete;
@@ -578,16 +577,14 @@ stop_isoc_chain(usb_fifo * fifo)
 			    "HFC-S USB: Stopping iso chain for fifo %i.%i",
 			    fifo->fifonum, i);
 #endif
-			usb_unlink_urb(fifo->iso[i].purb);
+			usb_kill_urb(fifo->iso[i].purb);
 			usb_free_urb(fifo->iso[i].purb);
 			fifo->iso[i].purb = NULL;
 		}
 	}
-	if (fifo->urb) {
-		usb_unlink_urb(fifo->urb);
-		usb_free_urb(fifo->urb);
-		fifo->urb = NULL;
-	}
+	usb_kill_urb(fifo->urb);
+	usb_free_urb(fifo->urb);
+	fifo->urb = NULL;
 	fifo->active = 0;
 }
 
@@ -1305,7 +1302,11 @@ usb_init(hfcusb_data * hfc)
 	}
 	/* default Prot: EURO ISDN, should be a module_param */
 	hfc->protocol = 2;
-	hisax_register(&hfc->d_if, p_b_if, "hfc_usb", hfc->protocol);
+	i = hisax_register(&hfc->d_if, p_b_if, "hfc_usb", hfc->protocol);
+	if (i) {
+		printk(KERN_INFO "HFC-S USB: hisax_register -> %d\n", i);
+		return i;
+	}
 
 #ifdef CONFIG_HISAX_DEBUG
 	hfc_debug = debug;
@@ -1626,11 +1627,9 @@ hfc_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)
 #endif
 			/* init the chip and register the driver */
 			if (usb_init(context)) {
-				if (context->ctrl_urb) {
-					usb_unlink_urb(context->ctrl_urb);
-					usb_free_urb(context->ctrl_urb);
-					context->ctrl_urb = NULL;
-				}
+				usb_kill_urb(context->ctrl_urb);
+				usb_free_urb(context->ctrl_urb);
+				context->ctrl_urb = NULL;
 				kfree(context);
 				return (-EIO);
 			}
@@ -1682,21 +1681,15 @@ hfc_usb_disconnect(struct usb_interface
 				    i);
 #endif
 			}
-			if (context->fifos[i].urb) {
-				usb_unlink_urb(context->fifos[i].urb);
-				usb_free_urb(context->fifos[i].urb);
-				context->fifos[i].urb = NULL;
-			}
+			usb_kill_urb(context->fifos[i].urb);
+			usb_free_urb(context->fifos[i].urb);
+			context->fifos[i].urb = NULL;
 		}
 		context->fifos[i].active = 0;
 	}
-	/* wait for all URBS to terminate */
-	mdelay(10);
-	if (context->ctrl_urb) {
-		usb_unlink_urb(context->ctrl_urb);
-		usb_free_urb(context->ctrl_urb);
-		context->ctrl_urb = NULL;
-	}
+	usb_kill_urb(context->ctrl_urb);
+	usb_free_urb(context->ctrl_urb);
+	context->ctrl_urb = NULL;
 	hisax_unregister(&context->d_if);
 	kfree(context);		/* free our structure again */
 }				/* hfc_usb_disconnect */
diff --git a/drivers/isdn/hisax/hisax_fcpcipnp.c b/drivers/isdn/hisax/hisax_fcpcipnp.c
index 9e088fc..7993e01 100644
--- a/drivers/isdn/hisax/hisax_fcpcipnp.c
+++ b/drivers/isdn/hisax/hisax_fcpcipnp.c
@@ -859,7 +859,11 @@ new_adapter(void)
 	for (i = 0; i < 2; i++)
 		b_if[i] = &adapter->bcs[i].b_if;
 
-	hisax_register(&adapter->isac.hisax_d_if, b_if, "fcpcipnp", protocol);
+	if (hisax_register(&adapter->isac.hisax_d_if, b_if, "fcpcipnp",
+			protocol) != 0) {
+		kfree(adapter);
+		adapter = NULL;
+	}
 
 	return adapter;
 }
diff --git a/drivers/isdn/hisax/st5481_init.c b/drivers/isdn/hisax/st5481_init.c
index bb3a28a..1375123 100644
--- a/drivers/isdn/hisax/st5481_init.c
+++ b/drivers/isdn/hisax/st5481_init.c
@@ -107,12 +107,17 @@ static int probe_st5481(struct usb_interface *intf,
 	for (i = 0; i < 2; i++)
 		b_if[i] = &adapter->bcs[i].b_if;
 
-	hisax_register(&adapter->hisax_d_if, b_if, "st5481_usb", protocol);
+	if (hisax_register(&adapter->hisax_d_if, b_if, "st5481_usb",
+			protocol) != 0)
+		goto err_b1;
+
 	st5481_start(adapter);
 
 	usb_set_intfdata(intf, adapter);
 	return 0;
 
+ err_b1:
+	st5481_release_b(&adapter->bcs[1]);
  err_b:
 	st5481_release_b(&adapter->bcs[0]);
  err_d:
diff --git a/drivers/isdn/hisax/st5481_usb.c b/drivers/isdn/hisax/st5481_usb.c
index ff15951..4ada66b 100644
--- a/drivers/isdn/hisax/st5481_usb.c
+++ b/drivers/isdn/hisax/st5481_usb.c
@@ -407,7 +407,6 @@ fill_isoc_urb(struct urb *urb, struct usb_device *dev,
 {
 	int k;
 
-	spin_lock_init(&urb->lock);
 	urb->dev=dev;
 	urb->pipe=pipe;
 	urb->interval = 1;
diff --git a/drivers/isdn/icn/icn.c b/drivers/isdn/icn/icn.c
index 1e699bc..82d957b 100644
--- a/drivers/isdn/icn/icn.c
+++ b/drivers/isdn/icn/icn.c
@@ -12,6 +12,7 @@
 #include "icn.h"
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/sched.h>
 
 static int portbase = ICN_BASEADDR;
 static unsigned long membase = ICN_MEMADDR;
diff --git a/drivers/isdn/sc/message.c b/drivers/isdn/sc/message.c
index c5a307e..0b4c4f1 100644
--- a/drivers/isdn/sc/message.c
+++ b/drivers/isdn/sc/message.c
@@ -16,7 +16,7 @@
  *     +1 (416) 297-8565
  *     +1 (416) 297-6433 Facsimile
  */
-
+#include <linux/sched.h>
 #include "includes.h"
 #include "hardware.h"
 #include "message.h"
diff --git a/drivers/kvm/kvm.h b/drivers/kvm/kvm.h
index 41634fd..1c040d8 100644
--- a/drivers/kvm/kvm.h
+++ b/drivers/kvm/kvm.h
@@ -11,6 +11,7 @@
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
 #include <linux/mm.h>
+#include <asm/signal.h>
 
 #include "vmx.h"
 #include <linux/kvm.h>
diff --git a/drivers/kvm/kvm_main.c b/drivers/kvm/kvm_main.c
index 0d89260..da985b3 100644
--- a/drivers/kvm/kvm_main.c
+++ b/drivers/kvm/kvm_main.c
@@ -40,6 +40,7 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/mount.h>
+#include <linux/sched.h>
 
 #include "x86_emulate.h"
 #include "segment_descriptor.h"
diff --git a/drivers/kvm/svm.c b/drivers/kvm/svm.c
index 9c15f32..fa17d6d 100644
--- a/drivers/kvm/svm.c
+++ b/drivers/kvm/svm.c
@@ -19,6 +19,7 @@
 #include <linux/vmalloc.h>
 #include <linux/highmem.h>
 #include <linux/profile.h>
+#include <linux/sched.h>
 #include <asm/desc.h>
 
 #include "kvm_svm.h"
diff --git a/drivers/kvm/vmx.c b/drivers/kvm/vmx.c
index 724db00..e6e4d24 100644
--- a/drivers/kvm/vmx.c
+++ b/drivers/kvm/vmx.c
@@ -22,6 +22,7 @@
 #include <linux/mm.h>
 #include <linux/highmem.h>
 #include <linux/profile.h>
+#include <linux/sched.h>
 #include <asm/io.h>
 #include <asm/desc.h>
 
diff --git a/drivers/macintosh/adbhid.c b/drivers/macintosh/adbhid.c
index b77ef51..b46817f 100644
--- a/drivers/macintosh/adbhid.c
+++ b/drivers/macintosh/adbhid.c
@@ -628,16 +628,16 @@ static void real_leds(unsigned char leds, int device)
  */
 static int adbhid_kbd_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
-	struct adbhid *adbhid = dev->private;
+	struct adbhid *adbhid = input_get_drvdata(dev);
 	unsigned char leds;
 
 	switch (type) {
 	case EV_LED:
-	  leds = (test_bit(LED_SCROLLL, dev->led) ? 4 : 0)
-	       | (test_bit(LED_NUML,    dev->led) ? 1 : 0)
-	       | (test_bit(LED_CAPSL,   dev->led) ? 2 : 0);
-	  real_leds(leds, adbhid->id);
-	  return 0;
+		leds =  (test_bit(LED_SCROLLL, dev->led) ? 4 : 0) |
+			(test_bit(LED_NUML,    dev->led) ? 1 : 0) |
+			(test_bit(LED_CAPSL,   dev->led) ? 2 : 0);
+		real_leds(leds, adbhid->id);
+		return 0;
 	}
 
 	return -1;
@@ -649,7 +649,7 @@ adb_message_handler(struct notifier_block *this, unsigned long code, void *x)
 	switch (code) {
 	case ADB_MSG_PRE_RESET:
 	case ADB_MSG_POWERDOWN:
-	    	/* Stop the repeat timer. Autopoll is already off at this point */
+		/* Stop the repeat timer. Autopoll is already off at this point */
 		{
 			int i;
 			for (i = 1; i < 16; i++) {
@@ -699,7 +699,7 @@ adbhid_input_register(int id, int default_id, int original_handler_id,
 	hid->current_handler_id = current_handler_id;
 	hid->mouse_kind = mouse_kind;
 	hid->flags = 0;
-	input_dev->private = hid;
+	input_set_drvdata(input_dev, hid);
 	input_dev->name = hid->name;
 	input_dev->phys = hid->phys;
 	input_dev->id.bustype = BUS_ADB;
diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c
index 5a4a74c..9620d45 100644
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@ -255,19 +255,25 @@ static struct page *read_sb_page(mddev_t *mddev, long offset, unsigned long inde
 
 }
 
-static int write_sb_page(mddev_t *mddev, long offset, struct page *page, int wait)
+static int write_sb_page(struct bitmap *bitmap, struct page *page, int wait)
 {
 	mdk_rdev_t *rdev;
 	struct list_head *tmp;
+	mddev_t *mddev = bitmap->mddev;
 
 	ITERATE_RDEV(mddev, rdev, tmp)
 		if (test_bit(In_sync, &rdev->flags)
-		    && !test_bit(Faulty, &rdev->flags))
+		    && !test_bit(Faulty, &rdev->flags)) {
+			int size = PAGE_SIZE;
+			if (page->index == bitmap->file_pages-1)
+				size = roundup(bitmap->last_page_size,
+					       bdev_hardsect_size(rdev->bdev));
 			md_super_write(mddev, rdev,
-				       (rdev->sb_offset<<1) + offset
+				       (rdev->sb_offset<<1) + bitmap->offset
 				       + page->index * (PAGE_SIZE/512),
-				       PAGE_SIZE,
+				       size,
 				       page);
+		}
 
 	if (wait)
 		md_super_wait(mddev);
@@ -282,7 +288,7 @@ static int write_page(struct bitmap *bitmap, struct page *page, int wait)
 	struct buffer_head *bh;
 
 	if (bitmap->file == NULL)
-		return write_sb_page(bitmap->mddev, bitmap->offset, page, wait);
+		return write_sb_page(bitmap, page, wait);
 
 	bh = page_buffers(page);
 
@@ -923,6 +929,7 @@ static int bitmap_init_from_disk(struct bitmap *bitmap, sector_t start)
 			}
 
 			bitmap->filemap[bitmap->file_pages++] = page;
+			bitmap->last_page_size = count;
 		}
 		paddr = kmap_atomic(page, KM_USER0);
 		if (bitmap->flags & BITMAP_HOSTENDIAN)
diff --git a/drivers/md/linear.c b/drivers/md/linear.c
index d5ecd2d..1927410 100644
--- a/drivers/md/linear.c
+++ b/drivers/md/linear.c
@@ -139,8 +139,6 @@ static linear_conf_t *linear_conf(mddev_t *mddev, int raid_disks)
 	if (!conf)
 		return NULL;
 
-	mddev->private = conf;
-
 	cnt = 0;
 	conf->array_size = 0;
 
@@ -232,7 +230,7 @@ static linear_conf_t *linear_conf(mddev_t *mddev, int raid_disks)
 	 * First calculate the device offsets.
 	 */
 	conf->disks[0].offset = 0;
-	for (i=1; i<mddev->raid_disks; i++)
+	for (i = 1; i < raid_disks; i++)
 		conf->disks[i].offset =
 			conf->disks[i-1].offset +
 			conf->disks[i-1].size;
@@ -244,7 +242,7 @@ static linear_conf_t *linear_conf(mddev_t *mddev, int raid_disks)
 	     curr_offset < conf->array_size;
 	     curr_offset += conf->hash_spacing) {
 
-		while (i < mddev->raid_disks-1 &&
+		while (i < raid_disks-1 &&
 		       curr_offset >= conf->disks[i+1].offset)
 			i++;
 
@@ -299,9 +297,11 @@ static int linear_add(mddev_t *mddev, mdk_rdev_t *rdev)
 	 */
 	linear_conf_t *newconf;
 
-	if (rdev->raid_disk != mddev->raid_disks)
+	if (rdev->saved_raid_disk != mddev->raid_disks)
 		return -EINVAL;
 
+	rdev->raid_disk = rdev->saved_raid_disk;
+
 	newconf = linear_conf(mddev,mddev->raid_disks+1);
 
 	if (!newconf)
diff --git a/drivers/md/md.c b/drivers/md/md.c
index c10ce91..1c54f3c 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -1298,8 +1298,9 @@ static void super_1_sync(mddev_t *mddev, mdk_rdev_t *rdev)
 	ITERATE_RDEV(mddev,rdev2,tmp)
 		if (rdev2->desc_nr+1 > max_dev)
 			max_dev = rdev2->desc_nr+1;
-	
-	sb->max_dev = cpu_to_le32(max_dev);
+
+	if (max_dev > le32_to_cpu(sb->max_dev))
+		sb->max_dev = cpu_to_le32(max_dev);
 	for (i=0; i<max_dev;i++)
 		sb->dev_roles[i] = cpu_to_le16(0xfffe);
 	
@@ -1365,10 +1366,14 @@ static int bind_rdev_to_array(mdk_rdev_t * rdev, mddev_t * mddev)
 	}
 	/* make sure rdev->size exceeds mddev->size */
 	if (rdev->size && (mddev->size == 0 || rdev->size < mddev->size)) {
-		if (mddev->pers)
-			/* Cannot change size, so fail */
-			return -ENOSPC;
-		else
+		if (mddev->pers) {
+			/* Cannot change size, so fail
+			 * If mddev->level <= 0, then we don't care
+			 * about aligning sizes (e.g. linear)
+			 */
+			if (mddev->level > 0)
+				return -ENOSPC;
+		} else
 			mddev->size = rdev->size;
 	}
 
@@ -2142,6 +2147,9 @@ static void analyze_sbs(mddev_t * mddev)
 			rdev->desc_nr = i++;
 			rdev->raid_disk = rdev->desc_nr;
 			set_bit(In_sync, &rdev->flags);
+		} else if (rdev->raid_disk >= mddev->raid_disks) {
+			rdev->raid_disk = -1;
+			clear_bit(In_sync, &rdev->flags);
 		}
 	}
 
diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c
index dfe3214..2c404f7 100644
--- a/drivers/md/raid0.c
+++ b/drivers/md/raid0.c
@@ -415,7 +415,7 @@ static int raid0_make_request (request_queue_t *q, struct bio *bio)
 	raid0_conf_t *conf = mddev_to_conf(mddev);
 	struct strip_zone *zone;
 	mdk_rdev_t *tmp_dev;
-	unsigned long chunk;
+	sector_t chunk;
 	sector_t block, rsect;
 	const int rw = bio_data_dir(bio);
 
@@ -470,7 +470,6 @@ static int raid0_make_request (request_queue_t *q, struct bio *bio)
 
 		sector_div(x, zone->nb_dev);
 		chunk = x;
-		BUG_ON(x != (sector_t)chunk);
 
 		x = block >> chunksize_bits;
 		tmp_dev = zone->dev[sector_div(x, zone->nb_dev)];
diff --git a/drivers/media/dvb/bt8xx/dst.c b/drivers/media/dvb/bt8xx/dst.c
index 0393a3d..e908e3c 100644
--- a/drivers/media/dvb/bt8xx/dst.c
+++ b/drivers/media/dvb/bt8xx/dst.c
@@ -1721,9 +1721,6 @@ static void dst_release(struct dvb_frontend *fe)
 		symbol_put(dst_ca_attach);
 #endif
 	}
-#ifdef CONFIG_DVB_CORE_ATTACH
-	symbol_put(dst_attach);
-#endif
 	kfree(state);
 }
 
diff --git a/drivers/media/dvb/dvb-core/dvbdev.c b/drivers/media/dvb/dvb-core/dvbdev.c
index e23d8a0..a9fa333 100644
--- a/drivers/media/dvb/dvb-core/dvbdev.c
+++ b/drivers/media/dvb/dvb-core/dvbdev.c
@@ -200,7 +200,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 {
 	struct dvb_device *dvbdev;
 	struct file_operations *dvbdevfops;
-
+	struct class_device *clsdev;
 	int id;
 
 	mutex_lock(&dvbdev_register_lock);
@@ -242,8 +242,15 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 
 	mutex_unlock(&dvbdev_register_lock);
 
-	class_device_create(dvb_class, NULL, MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
-			    adap->device, "dvb%d.%s%d", adap->num, dnames[type], id);
+	clsdev = class_device_create(dvb_class, NULL, MKDEV(DVB_MAJOR,
+				     nums2minor(adap->num, type, id)),
+				     adap->device, "dvb%d.%s%d", adap->num,
+				     dnames[type], id);
+	if (IS_ERR(clsdev)) {
+		printk(KERN_ERR "%s: failed to create device dvb%d.%s%d (%ld)\n",
+		       __FUNCTION__, adap->num, dnames[type], id, PTR_ERR(clsdev));
+		return PTR_ERR(clsdev);
+	}
 
 	dprintk("DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
 		adap->num, dnames[type], id, nums2minor(adap->num, type, id),
@@ -431,7 +438,7 @@ static void __exit exit_dvbdev(void)
 	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
 }
 
-module_init(init_dvbdev);
+subsys_initcall(init_dvbdev);
 module_exit(exit_dvbdev);
 
 MODULE_DESCRIPTION("DVB Core Driver");
diff --git a/drivers/media/video/cafe_ccic-regs.h b/drivers/media/video/cafe_ccic-regs.h
index b2c22a0..8e2a87c 100644
--- a/drivers/media/video/cafe_ccic-regs.h
+++ b/drivers/media/video/cafe_ccic-regs.h
@@ -150,6 +150,12 @@
 #define REG_GL_IMASK   0x300c  /* Interrupt mask register */
 #define   GIMSK_CCIC_EN          0x00000004    /* CCIC Interrupt enable */
 
+#define REG_GL_FCR	0x3038  /* GPIO functional control register */
+#define	  GFCR_GPIO_ON	  0x08		/* Camera GPIO enabled */
+#define REG_GL_GPIOR	0x315c	/* GPIO register */
+#define   GGPIO_OUT  		0x80000	/* GPIO output */
+#define   GGPIO_VAL  		0x00008	/* Output pin value */
+
 #define REG_LEN                REG_GL_IMASK + 4
 
 
diff --git a/drivers/media/video/cafe_ccic.c b/drivers/media/video/cafe_ccic.c
index 96254db..c08f650 100644
--- a/drivers/media/video/cafe_ccic.c
+++ b/drivers/media/video/cafe_ccic.c
@@ -775,6 +775,12 @@ static void cafe_ctlr_power_up(struct cafe_camera *cam)
 	spin_lock_irqsave(&cam->dev_lock, flags);
 	cafe_reg_clear_bit(cam, REG_CTRL1, C1_PWRDWN);
 	/*
+	 * Part one of the sensor dance: turn the global
+	 * GPIO signal on.
+	 */
+	cafe_reg_write(cam, REG_GL_FCR, GFCR_GPIO_ON);
+	cafe_reg_write(cam, REG_GL_GPIOR, GGPIO_OUT|GGPIO_VAL);
+	/*
 	 * Put the sensor into operational mode (assumes OLPC-style
 	 * wiring).  Control 0 is reset - set to 1 to operate.
 	 * Control 1 is power down, set to 0 to operate.
@@ -784,6 +790,7 @@ static void cafe_ctlr_power_up(struct cafe_camera *cam)
 	cafe_reg_write(cam, REG_GPR, GPR_C1EN|GPR_C0EN|GPR_C0);
 //	mdelay(1); /* Enough? */
 	spin_unlock_irqrestore(&cam->dev_lock, flags);
+	msleep(5); /* Just to be sure */
 }
 
 static void cafe_ctlr_power_down(struct cafe_camera *cam)
@@ -792,6 +799,8 @@ static void cafe_ctlr_power_down(struct cafe_camera *cam)
 
 	spin_lock_irqsave(&cam->dev_lock, flags);
 	cafe_reg_write(cam, REG_GPR, GPR_C1EN|GPR_C0EN|GPR_C1);
+	cafe_reg_write(cam, REG_GL_FCR, GFCR_GPIO_ON);
+	cafe_reg_write(cam, REG_GL_GPIOR, GGPIO_OUT);
 	cafe_reg_set_bit(cam, REG_CTRL1, C1_PWRDWN);
 	spin_unlock_irqrestore(&cam->dev_lock, flags);
 }
@@ -851,6 +860,7 @@ static int cafe_cam_init(struct cafe_camera *cam)
 	ret = 0;
 	cam->state = S_IDLE;
   out:
+	cafe_ctlr_power_down(cam);
 	mutex_unlock(&cam->s_mutex);
 	return ret;
 }
@@ -2103,10 +2113,16 @@ static int cafe_pci_probe(struct pci_dev *pdev,
 	ret = request_irq(pdev->irq, cafe_irq, IRQF_SHARED, "cafe-ccic", cam);
 	if (ret)
 		goto out_iounmap;
+	/*
+	 * Initialize the controller and leave it powered up.  It will
+	 * stay that way until the sensor driver shows up.
+	 */
 	cafe_ctlr_init(cam);
 	cafe_ctlr_power_up(cam);
 	/*
-	 * Set up I2C/SMBUS communications
+	 * Set up I2C/SMBUS communications.  We have to drop the mutex here
+	 * because the sensor could attach in this call chain, leading to
+	 * unsightly deadlocks.
 	 */
 	mutex_unlock(&cam->s_mutex);  /* attach can deadlock */
 	ret = cafe_smbus_setup(cam);
diff --git a/drivers/media/video/em28xx/Kconfig b/drivers/media/video/em28xx/Kconfig
index 2c450bd..5b6a403 100644
--- a/drivers/media/video/em28xx/Kconfig
+++ b/drivers/media/video/em28xx/Kconfig
@@ -1,7 +1,6 @@
 config VIDEO_EM28XX
 	tristate "Empia EM2800/2820/2840 USB video capture support"
-	depends on VIDEO_V4L1 && I2C && PCI
-	select VIDEO_BUF
+	depends on VIDEO_V4L1 && I2C
 	select VIDEO_TUNER
 	select VIDEO_TVEEPROM
 	select VIDEO_IR
diff --git a/drivers/media/video/ivtv/Kconfig b/drivers/media/video/ivtv/Kconfig
index 0cc98a0..1aaeaa0 100644
--- a/drivers/media/video/ivtv/Kconfig
+++ b/drivers/media/video/ivtv/Kconfig
@@ -1,6 +1,6 @@
 config VIDEO_IVTV
 	tristate "Conexant cx23416/cx23415 MPEG encoder/decoder support"
-	depends on VIDEO_V4L1 && VIDEO_V4L2 && USB && I2C && EXPERIMENTAL && PCI
+	depends on VIDEO_V4L1 && VIDEO_V4L2 && PCI && I2C && EXPERIMENTAL
 	select FW_LOADER
 	select VIDEO_TUNER
 	select VIDEO_TVEEPROM
diff --git a/drivers/media/video/ivtv/ivtv-driver.h b/drivers/media/video/ivtv/ivtv-driver.h
index 9a412d6..552f045 100644
--- a/drivers/media/video/ivtv/ivtv-driver.h
+++ b/drivers/media/video/ivtv/ivtv-driver.h
@@ -67,14 +67,6 @@
 
 #include <media/ivtv.h>
 
-#ifdef CONFIG_LIRC_I2C
-#  error "This driver is not compatible with the LIRC I2C kernel configuration option."
-#endif /* CONFIG_LIRC_I2C */
-
-#ifndef CONFIG_PCI
-#  error "This driver requires kernel PCI support."
-#endif /* CONFIG_PCI */
-
 #define IVTV_ENCODER_OFFSET	0x00000000
 #define IVTV_ENCODER_SIZE	0x00800000	/* Last half isn't needed 0x01000000 */
 
diff --git a/drivers/media/video/ivtv/ivtv-ioctl.c b/drivers/media/video/ivtv/ivtv-ioctl.c
index 794a6a0..1989ec1 100644
--- a/drivers/media/video/ivtv/ivtv-ioctl.c
+++ b/drivers/media/video/ivtv/ivtv-ioctl.c
@@ -362,8 +362,6 @@ static int ivtv_get_fmt(struct ivtv *itv, int streamtype, struct v4l2_format *fm
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 		if (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))
 			return -EINVAL;
-		fmt->fmt.pix.left = itv->main_rect.left;
-		fmt->fmt.pix.top = itv->main_rect.top;
 		fmt->fmt.pix.width = itv->main_rect.width;
 		fmt->fmt.pix.height = itv->main_rect.height;
 		fmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
@@ -402,8 +400,6 @@ static int ivtv_get_fmt(struct ivtv *itv, int streamtype, struct v4l2_format *fm
 		break;
 
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		fmt->fmt.pix.left = 0;
-		fmt->fmt.pix.top = 0;
 		fmt->fmt.pix.width = itv->params.width;
 		fmt->fmt.pix.height = itv->params.height;
 		fmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
@@ -498,15 +494,13 @@ static int ivtv_try_or_set_fmt(struct ivtv *itv, int streamtype,
 		if (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))
 			return -EINVAL;
 		field = fmt->fmt.pix.field;
-		r.top = fmt->fmt.pix.top;
-		r.left = fmt->fmt.pix.left;
+		r.top = 0;
+		r.left = 0;
 		r.width = fmt->fmt.pix.width;
 		r.height = fmt->fmt.pix.height;
 		ivtv_get_fmt(itv, streamtype, fmt);
 		if (itv->output_mode != OUT_UDMA_YUV) {
 			/* TODO: would setting the rect also be valid for this mode? */
-			fmt->fmt.pix.top = r.top;
-			fmt->fmt.pix.left = r.left;
 			fmt->fmt.pix.width = r.width;
 			fmt->fmt.pix.height = r.height;
 		}
@@ -1141,8 +1135,6 @@ int ivtv_v4l2_ioctls(struct ivtv *itv, struct file *filp, unsigned int cmd, void
 		fb->fmt.pixelformat = itv->osd_pixelformat;
 		fb->fmt.width = itv->osd_rect.width;
 		fb->fmt.height = itv->osd_rect.height;
-		fb->fmt.left = itv->osd_rect.left;
-		fb->fmt.top = itv->osd_rect.top;
 		fb->base = (void *)itv->osd_video_pbase;
 		if (itv->osd_global_alpha_state)
 			fb->flags |= V4L2_FBUF_FLAG_GLOBAL_ALPHA;
diff --git a/drivers/media/video/ov7670.c b/drivers/media/video/ov7670.c
index 03bc369..3ceb8a6 100644
--- a/drivers/media/video/ov7670.c
+++ b/drivers/media/video/ov7670.c
@@ -720,12 +720,22 @@ static int ov7670_s_fmt(struct i2c_client *c, struct v4l2_format *fmt)
 	struct ov7670_format_struct *ovfmt;
 	struct ov7670_win_size *wsize;
 	struct ov7670_info *info = i2c_get_clientdata(c);
-	unsigned char com7;
+	unsigned char com7, clkrc;
 
 	ret = ov7670_try_fmt(c, fmt, &ovfmt, &wsize);
 	if (ret)
 		return ret;
 	/*
+	 * HACK: if we're running rgb565 we need to grab then rewrite
+	 * CLKRC.  If we're *not*, however, then rewriting clkrc hoses
+	 * the colors.
+	 */
+	if (fmt->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB565) {
+		ret = ov7670_read(c, REG_CLKRC, &clkrc);
+		if (ret)
+			return ret;
+	}
+	/*
 	 * COM7 is a pain in the ass, it doesn't like to be read then
 	 * quickly written afterward.  But we have everything we need
 	 * to set it absolutely here, as long as the format-specific
@@ -744,7 +754,10 @@ static int ov7670_s_fmt(struct i2c_client *c, struct v4l2_format *fmt)
 	if (wsize->regs)
 		ret = ov7670_write_array(c, wsize->regs);
 	info->fmt = ovfmt;
-	return 0;
+
+	if (fmt->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB565 && ret == 0)
+		ret = ov7670_write(c, REG_CLKRC, clkrc);
+	return ret;
 }
 
 /*
@@ -1267,7 +1280,9 @@ static int ov7670_attach(struct i2c_adapter *adapter)
 	ret = ov7670_detect(client);
 	if (ret)
 		goto out_free_info;
-	i2c_attach_client(client);
+	ret = i2c_attach_client(client);
+	if (ret)
+		goto out_free_info;
 	return 0;
 
   out_free_info:
diff --git a/drivers/media/video/tuner-simple.c b/drivers/media/video/tuner-simple.c
index 1b9b074..c40b92c 100644
--- a/drivers/media/video/tuner-simple.c
+++ b/drivers/media/video/tuner-simple.c
@@ -205,9 +205,13 @@ static void default_set_tv_freq(struct i2c_client *c, unsigned int freq)
 		/* 0x01 -> ??? no change ??? */
 		/* 0x02 -> PAL BDGHI / SECAM L */
 		/* 0x04 -> ??? PAL others / SECAM others ??? */
-		cb &= ~0x02;
-		if (t->std & V4L2_STD_SECAM)
-			cb |= 0x02;
+		cb &= ~0x03;
+		if (t->std & V4L2_STD_SECAM_L) //also valid for V4L2_STD_SECAM
+			cb |= PHILIPS_MF_SET_PAL_L;
+		else if (t->std & V4L2_STD_SECAM_LC)
+			cb |= PHILIPS_MF_SET_PAL_L2;
+		else /* V4L2_STD_B|V4L2_STD_GH */
+			cb |= PHILIPS_MF_SET_BG;
 		break;
 
 	case TUNER_TEMIC_4046FM5:
diff --git a/drivers/message/i2o/driver.c b/drivers/message/i2o/driver.c
index d3235f2..e0d474b 100644
--- a/drivers/message/i2o/driver.c
+++ b/drivers/message/i2o/driver.c
@@ -123,8 +123,12 @@ int i2o_driver_register(struct i2o_driver *drv)
 	}
 
 	rc = driver_register(&drv->driver);
-	if (rc)
-		destroy_workqueue(drv->event_queue);
+	if (rc) {
+		if (drv->event) {
+			destroy_workqueue(drv->event_queue);
+			drv->event_queue = NULL;
+		}
+	}
 
 	return rc;
 };
@@ -256,7 +260,7 @@ void i2o_driver_notify_controller_add_all(struct i2o_controller *c)
 	int i;
 	struct i2o_driver *drv;
 
-	for (i = 0; i < I2O_MAX_DRIVERS; i++) {
+	for (i = 0; i < i2o_max_drivers; i++) {
 		drv = i2o_drivers[i];
 
 		if (drv)
@@ -276,7 +280,7 @@ void i2o_driver_notify_controller_remove_all(struct i2o_controller *c)
 	int i;
 	struct i2o_driver *drv;
 
-	for (i = 0; i < I2O_MAX_DRIVERS; i++) {
+	for (i = 0; i < i2o_max_drivers; i++) {
 		drv = i2o_drivers[i];
 
 		if (drv)
@@ -295,7 +299,7 @@ void i2o_driver_notify_device_add_all(struct i2o_device *i2o_dev)
 	int i;
 	struct i2o_driver *drv;
 
-	for (i = 0; i < I2O_MAX_DRIVERS; i++) {
+	for (i = 0; i < i2o_max_drivers; i++) {
 		drv = i2o_drivers[i];
 
 		if (drv)
@@ -314,7 +318,7 @@ void i2o_driver_notify_device_remove_all(struct i2o_device *i2o_dev)
 	int i;
 	struct i2o_driver *drv;
 
-	for (i = 0; i < I2O_MAX_DRIVERS; i++) {
+	for (i = 0; i < i2o_max_drivers; i++) {
 		drv = i2o_drivers[i];
 
 		if (drv)
@@ -335,17 +339,15 @@ int __init i2o_driver_init(void)
 
 	spin_lock_init(&i2o_drivers_lock);
 
-	if ((i2o_max_drivers < 2) || (i2o_max_drivers > 64) ||
-	    ((i2o_max_drivers ^ (i2o_max_drivers - 1)) !=
-	     (2 * i2o_max_drivers - 1))) {
-		osm_warn("max_drivers set to %d, but must be >=2 and <= 64 and "
-			 "a power of 2\n", i2o_max_drivers);
+	if ((i2o_max_drivers < 2) || (i2o_max_drivers > 64)) {
+		osm_warn("max_drivers set to %d, but must be >=2 and <= 64\n",
+			 i2o_max_drivers);
 		i2o_max_drivers = I2O_MAX_DRIVERS;
 	}
 	osm_info("max drivers = %d\n", i2o_max_drivers);
 
 	i2o_drivers =
-	    kzalloc(i2o_max_drivers * sizeof(*i2o_drivers), GFP_KERNEL);
+	    kcalloc(i2o_max_drivers, sizeof(*i2o_drivers), GFP_KERNEL);
 	if (!i2o_drivers)
 		return -ENOMEM;
 
diff --git a/drivers/mfd/ucb1x00-ts.c b/drivers/mfd/ucb1x00-ts.c
index cb8c264..7772bd1 100644
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -207,16 +207,7 @@ static int ucb1x00_thread(void *_ts)
 	struct ucb1x00_ts *ts = _ts;
 	struct task_struct *tsk = current;
 	DECLARE_WAITQUEUE(wait, tsk);
-	int valid;
-
-	/*
-	 * We could run as a real-time thread.  However, thus far
-	 * this doesn't seem to be necessary.
-	 */
-//	tsk->policy = SCHED_FIFO;
-//	tsk->rt_priority = 1;
-
-	valid = 0;
+	int valid = 0;
 
 	add_wait_queue(&ts->irq_wait, &wait);
 	while (!kthread_should_stop()) {
diff --git a/drivers/misc/phantom.c b/drivers/misc/phantom.c
index 35b139b..5108b7c 100644
--- a/drivers/misc/phantom.c
+++ b/drivers/misc/phantom.c
@@ -47,6 +47,7 @@ struct phantom_device {
 	struct cdev cdev;
 
 	struct mutex open_lock;
+	spinlock_t ioctl_lock;
 };
 
 static unsigned char phantom_devices[PHANTOM_MAX_MINORS];
@@ -59,8 +60,11 @@ static int phantom_status(struct phantom_device *dev, unsigned long newstat)
 		atomic_set(&dev->counter, 0);
 		iowrite32(PHN_CTL_IRQ, dev->iaddr + PHN_CONTROL);
 		iowrite32(0x43, dev->caddr + PHN_IRQCTL);
-	} else if ((dev->status & PHB_RUNNING) && !(newstat & PHB_RUNNING))
+		ioread32(dev->caddr + PHN_IRQCTL); /* PCI posting */
+	} else if ((dev->status & PHB_RUNNING) && !(newstat & PHB_RUNNING)) {
 		iowrite32(0, dev->caddr + PHN_IRQCTL);
+		ioread32(dev->caddr + PHN_IRQCTL); /* PCI posting */
+	}
 
 	dev->status = newstat;
 
@@ -71,8 +75,8 @@ static int phantom_status(struct phantom_device *dev, unsigned long newstat)
  * File ops
  */
 
-static int phantom_ioctl(struct inode *inode, struct file *file, u_int cmd,
-	u_long arg)
+static long phantom_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
 {
 	struct phantom_device *dev = file->private_data;
 	struct phm_regs rs;
@@ -92,24 +96,32 @@ static int phantom_ioctl(struct inode *inode, struct file *file, u_int cmd,
 		if (r.reg > 7)
 			return -EINVAL;
 
+		spin_lock(&dev->ioctl_lock);
 		if (r.reg == PHN_CONTROL && (r.value & PHN_CTL_IRQ) &&
-				phantom_status(dev, dev->status | PHB_RUNNING))
+				phantom_status(dev, dev->status | PHB_RUNNING)){
+			spin_unlock(&dev->ioctl_lock);
 			return -ENODEV;
+		}
 
 		pr_debug("phantom: writing %x to %u\n", r.value, r.reg);
 		iowrite32(r.value, dev->iaddr + r.reg);
+		ioread32(dev->iaddr); /* PCI posting */
 
 		if (r.reg == PHN_CONTROL && !(r.value & PHN_CTL_IRQ))
 			phantom_status(dev, dev->status & ~PHB_RUNNING);
+		spin_unlock(&dev->ioctl_lock);
 		break;
 	case PHN_SET_REGS:
 		if (copy_from_user(&rs, argp, sizeof(rs)))
 			return -EFAULT;
 
 		pr_debug("phantom: SRS %u regs %x\n", rs.count, rs.mask);
+		spin_lock(&dev->ioctl_lock);
 		for (i = 0; i < min(rs.count, 8U); i++)
 			if ((1 << i) & rs.mask)
 				iowrite32(rs.values[i], dev->oaddr + i);
+		ioread32(dev->iaddr); /* PCI posting */
+		spin_unlock(&dev->ioctl_lock);
 		break;
 	case PHN_GET_REG:
 		if (copy_from_user(&r, argp, sizeof(r)))
@@ -128,9 +140,11 @@ static int phantom_ioctl(struct inode *inode, struct file *file, u_int cmd,
 			return -EFAULT;
 
 		pr_debug("phantom: GRS %u regs %x\n", rs.count, rs.mask);
+		spin_lock(&dev->ioctl_lock);
 		for (i = 0; i < min(rs.count, 8U); i++)
 			if ((1 << i) & rs.mask)
 				rs.values[i] = ioread32(dev->iaddr + i);
+		spin_unlock(&dev->ioctl_lock);
 
 		if (copy_to_user(argp, &rs, sizeof(rs)))
 			return -EFAULT;
@@ -199,7 +213,7 @@ static unsigned int phantom_poll(struct file *file, poll_table *wait)
 static struct file_operations phantom_file_ops = {
 	.open = phantom_open,
 	.release = phantom_release,
-	.ioctl = phantom_ioctl,
+	.unlocked_ioctl = phantom_ioctl,
 	.poll = phantom_poll,
 };
 
@@ -212,6 +226,7 @@ static irqreturn_t phantom_isr(int irq, void *data)
 
 	iowrite32(0, dev->iaddr);
 	iowrite32(0xc0, dev->iaddr);
+	ioread32(dev->iaddr); /* PCI posting */
 
 	atomic_inc(&dev->counter);
 	wake_up_interruptible(&dev->wait);
@@ -282,11 +297,13 @@ static int __devinit phantom_probe(struct pci_dev *pdev,
 	}
 
 	mutex_init(&pht->open_lock);
+	spin_lock_init(&pht->ioctl_lock);
 	init_waitqueue_head(&pht->wait);
 	cdev_init(&pht->cdev, &phantom_file_ops);
 	pht->cdev.owner = THIS_MODULE;
 
 	iowrite32(0, pht->caddr + PHN_IRQCTL);
+	ioread32(pht->caddr + PHN_IRQCTL); /* PCI posting */
 	retval = request_irq(pdev->irq, phantom_isr,
 			IRQF_SHARED | IRQF_DISABLED, "phantom", pht);
 	if (retval) {
@@ -337,6 +354,7 @@ static void __devexit phantom_remove(struct pci_dev *pdev)
 	cdev_del(&pht->cdev);
 
 	iowrite32(0, pht->caddr + PHN_IRQCTL);
+	ioread32(pht->caddr + PHN_IRQCTL); /* PCI posting */
 	free_irq(pdev->irq, pht);
 
 	pci_iounmap(pdev, pht->oaddr);
@@ -358,6 +376,7 @@ static int phantom_suspend(struct pci_dev *pdev, pm_message_t state)
 	struct phantom_device *dev = pci_get_drvdata(pdev);
 
 	iowrite32(0, dev->caddr + PHN_IRQCTL);
+	ioread32(dev->caddr + PHN_IRQCTL); /* PCI posting */
 
 	return 0;
 }
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index a7562f7..540ff4b 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -135,23 +135,6 @@ struct mmc_blk_request {
 	struct mmc_data		data;
 };
 
-static int mmc_blk_prep_rq(struct mmc_queue *mq, struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	int stat = BLKPREP_OK;
-
-	/*
-	 * If we have no device, we haven't finished initialising.
-	 */
-	if (!md || !mq->card) {
-		printk(KERN_ERR "%s: killing request - no device/host\n",
-		       req->rq_disk->disk_name);
-		stat = BLKPREP_KILL;
-	}
-
-	return stat;
-}
-
 static u32 mmc_sd_num_wr_blocks(struct mmc_card *card)
 {
 	int err;
@@ -460,7 +443,6 @@ static struct mmc_blk_data *mmc_blk_alloc(struct mmc_card *card)
 	if (ret)
 		goto err_putdisk;
 
-	md->queue.prep_fn = mmc_blk_prep_rq;
 	md->queue.issue_fn = mmc_blk_issue_rq;
 	md->queue.data = md;
 
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 2e77963..dd97bc7 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -20,40 +20,21 @@
 #define MMC_QUEUE_SUSPENDED	(1 << 0)
 
 /*
- * Prepare a MMC request.  Essentially, this means passing the
- * preparation off to the media driver.  The media driver will
- * create a mmc_io_request in req->special.
+ * Prepare a MMC request. This just filters out odd stuff.
  */
 static int mmc_prep_request(struct request_queue *q, struct request *req)
 {
-	struct mmc_queue *mq = q->queuedata;
-	int ret = BLKPREP_KILL;
-
-	if (blk_special_request(req)) {
-		/*
-		 * Special commands already have the command
-		 * blocks already setup in req->special.
-		 */
-		BUG_ON(!req->special);
-
-		ret = BLKPREP_OK;
-	} else if (blk_fs_request(req) || blk_pc_request(req)) {
-		/*
-		 * Block I/O requests need translating according
-		 * to the protocol.
-		 */
-		ret = mq->prep_fn(mq, req);
-	} else {
-		/*
-		 * Everything else is invalid.
-		 */
+	/*
+	 * We only like normal block requests.
+	 */
+	if (!blk_fs_request(req) && !blk_pc_request(req)) {
 		blk_dump_rq_flags(req, "MMC bad request");
+		return BLKPREP_KILL;
 	}
 
-	if (ret == BLKPREP_OK)
-		req->cmd_flags |= REQ_DONTPREP;
+	req->cmd_flags |= REQ_DONTPREP;
 
-	return ret;
+	return BLKPREP_OK;
 }
 
 static int mmc_queue_thread(void *d)
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index c9f139e..1590b3f 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -10,20 +10,12 @@ struct mmc_queue {
 	struct semaphore	thread_sem;
 	unsigned int		flags;
 	struct request		*req;
-	int			(*prep_fn)(struct mmc_queue *, struct request *);
 	int			(*issue_fn)(struct mmc_queue *, struct request *);
 	void			*data;
 	struct request_queue	*queue;
 	struct scatterlist	*sg;
 };
 
-struct mmc_io_request {
-	struct request		*rq;
-	int			num;
-	struct mmc_command	selcmd;		/* mmc_queue private */
-	struct mmc_command	cmd[4];		/* max 4 commands */
-};
-
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *);
 extern void mmc_cleanup_queue(struct mmc_queue *);
 extern void mmc_queue_suspend(struct mmc_queue *);
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index c5baa19..30fd479 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2218,7 +2218,7 @@ config SK98LIN
 
 config VIA_VELOCITY
 	tristate "VIA Velocity support"
-	depends on NET_PCI && PCI
+	depends on PCI
 	select CRC32
 	select CRC_CCITT
 	select MII
diff --git a/drivers/net/arcnet/Kconfig b/drivers/net/arcnet/Kconfig
index 7284cca..4030274 100644
--- a/drivers/net/arcnet/Kconfig
+++ b/drivers/net/arcnet/Kconfig
@@ -2,10 +2,8 @@
 # Arcnet configuration
 #
 
-menu "ARCnet devices"
+menuconfig ARCNET
 	depends on NETDEVICES && (ISA || PCI)
-
-config ARCNET
 	tristate "ARCnet support"
 	---help---
 	  If you have a network card of this type, say Y and check out the
@@ -25,9 +23,10 @@ config ARCNET
 	  <file:Documentation/networking/net-modules.txt>.  The module will
 	  be called arcnet.
 
+if ARCNET
+
 config ARCNET_1201
 	tristate "Enable standard ARCNet packet format (RFC 1201)"
-	depends on ARCNET
 	help
 	  This allows you to use RFC1201 with your ARCnet card via the virtual
 	  arc0 device.  You need to say Y here to communicate with
@@ -38,7 +37,6 @@ config ARCNET_1201
 
 config ARCNET_1051
 	tristate "Enable old ARCNet packet format (RFC 1051)"
-	depends on ARCNET
 	---help---
 	  This allows you to use RFC1051 with your ARCnet card via the virtual
 	  arc0s device. You only need arc0s if you want to talk to ARCnet
@@ -53,7 +51,6 @@ config ARCNET_1051
 
 config ARCNET_RAW
 	tristate "Enable raw mode packet interface"
-	depends on ARCNET
 	help
 	  ARCnet "raw mode" packet encapsulation, no soft headers.  Unlikely
 	  to work unless talking to a copy of the same Linux arcnet driver,
@@ -61,7 +58,6 @@ config ARCNET_RAW
 
 config ARCNET_CAP
 	tristate "Enable CAP mode packet interface"
-	depends on ARCNET
 	help
 	  ARCnet "cap mode" packet encapsulation. Used to get the hardware
           acknowledge back to userspace. After the initial protocol byte every
@@ -80,7 +76,6 @@ config ARCNET_CAP
 
 config ARCNET_COM90xx
 	tristate "ARCnet COM90xx (normal) chipset driver"
-	depends on ARCNET
 	help
 	  This is the chipset driver for the standard COM90xx cards. If you
 	  have always used the old ARCnet driver without knowing what type of
@@ -92,7 +87,6 @@ config ARCNET_COM90xx
 
 config ARCNET_COM90xxIO
 	tristate "ARCnet COM90xx (IO mapped) chipset driver"
-	depends on ARCNET
 	---help---
 	  This is the chipset driver for the COM90xx cards, using them in
 	  IO-mapped mode instead of memory-mapped mode. This is slower than
@@ -105,7 +99,6 @@ config ARCNET_COM90xxIO
 
 config ARCNET_RIM_I
 	tristate "ARCnet COM90xx (RIM I) chipset driver"
-	depends on ARCNET
 	---help---
 	  This is yet another chipset driver for the COM90xx cards, but this
 	  time only using memory-mapped mode, and no IO ports at all. This
@@ -118,7 +111,6 @@ config ARCNET_RIM_I
 
 config ARCNET_COM20020
 	tristate "ARCnet COM20020 chipset driver"
-	depends on ARCNET
 	help
 	  This is the driver for the new COM20020 chipset. It supports such
 	  things as promiscuous mode, so packet sniffing is possible, and
@@ -136,5 +128,4 @@ config ARCNET_COM20020_PCI
 	tristate "Support for COM20020 on PCI"
 	depends on ARCNET_COM20020 && PCI
 
-endmenu
-
+endif # ARCNET
diff --git a/drivers/net/cassini.c b/drivers/net/cassini.c
index 4aec747..9fe3a38 100644
--- a/drivers/net/cassini.c
+++ b/drivers/net/cassini.c
@@ -4919,7 +4919,10 @@ static int __devinit cas_init_one(struct pci_dev *pdev,
 	pci_cmd &= ~PCI_COMMAND_SERR;
 	pci_cmd |= PCI_COMMAND_PARITY;
 	pci_write_config_word(pdev, PCI_COMMAND, pci_cmd);
-	pci_set_mwi(pdev);
+	if (pci_set_mwi(pdev))
+		printk(KERN_WARNING PFX "Could enable MWI for %s\n",
+		       pci_name(pdev));
+
 	/*
 	 * On some architectures, the default cache line size set
 	 * by pci_set_mwi reduces perforamnce.  We have to increase
diff --git a/drivers/net/chelsio/suni1x10gexp_regs.h b/drivers/net/chelsio/suni1x10gexp_regs.h
index 269d097..d0f87d8 100644
--- a/drivers/net/chelsio/suni1x10gexp_regs.h
+++ b/drivers/net/chelsio/suni1x10gexp_regs.h
@@ -105,7 +105,7 @@
 #define mSUNI1x10GEXP_REG_RXXG_EXACT_MATCH_ADDR_LOW(filterId) (0x204A + mSUNI1x10GEXP_MAC_FILTER_OFFSET(filterId))
 #define mSUNI1x10GEXP_REG_RXXG_EXACT_MATCH_ADDR_MID(filterId) (0x204B + mSUNI1x10GEXP_MAC_FILTER_OFFSET(filterId))
 #define mSUNI1x10GEXP_REG_RXXG_EXACT_MATCH_ADDR_HIGH(filterId)(0x204C + mSUNI1x10GEXP_MAC_FILTER_OFFSET(filterId))
-#define mSUNI1x10GEXP_REG_RXXG_EXACT_MATCH_VID(filterId)      (0x2062 + mSUNI1x10GEXP_MAC_VID_FILTER_OFFSET(filterId)
+#define mSUNI1x10GEXP_REG_RXXG_EXACT_MATCH_VID(filterId)      (0x2062 + mSUNI1x10GEXP_MAC_VID_FILTER_OFFSET(filterId))
 #define SUNI1x10GEXP_REG_RXXG_EXACT_MATCH_ADDR_0_LOW                     0x204A
 #define SUNI1x10GEXP_REG_RXXG_EXACT_MATCH_ADDR_0_MID                     0x204B
 #define SUNI1x10GEXP_REG_RXXG_EXACT_MATCH_ADDR_0_HIGH                    0x204C
diff --git a/drivers/net/declance.c b/drivers/net/declance.c
index 95d854e..b2577f4 100644
--- a/drivers/net/declance.c
+++ b/drivers/net/declance.c
@@ -932,8 +932,6 @@ static int lance_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* Kick the lance: transmit now */
 	writereg(&ll->rdp, LE_C0_INEA | LE_C0_TDMD);
 
-	spin_unlock_irq(&lp->lock);
-
 	dev->trans_start = jiffies;
 	dev_kfree_skb(skb);
 
diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 49be393..cbc7feb 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -1431,10 +1431,6 @@ e1000_open(struct net_device *netdev)
 	/* From here on the code is the same as e1000_up() */
 	clear_bit(__E1000_DOWN, &adapter->flags);
 
-#ifdef CONFIG_E1000_NAPI
-	netif_poll_enable(netdev);
-#endif
-
 	e1000_irq_enable(adapter);
 
 	/* fire a link status change interrupt to start the watchdog */
diff --git a/drivers/net/forcedeth.c b/drivers/net/forcedeth.c
index 7a01802..4154fd0 100644
--- a/drivers/net/forcedeth.c
+++ b/drivers/net/forcedeth.c
@@ -195,7 +195,7 @@ enum {
 #define NVREG_IRQ_TX_FORCED		0x0100
 #define NVREG_IRQ_RECOVER_ERROR		0x8000
 #define NVREG_IRQMASK_THROUGHPUT	0x00df
-#define NVREG_IRQMASK_CPU		0x0040
+#define NVREG_IRQMASK_CPU		0x0060
 #define NVREG_IRQ_TX_ALL		(NVREG_IRQ_TX_ERR|NVREG_IRQ_TX_OK|NVREG_IRQ_TX_FORCED)
 #define NVREG_IRQ_RX_ALL		(NVREG_IRQ_RX_ERROR|NVREG_IRQ_RX|NVREG_IRQ_RX_NOBUF|NVREG_IRQ_RX_FORCED)
 #define NVREG_IRQ_OTHER			(NVREG_IRQ_TIMER|NVREG_IRQ_LINK|NVREG_IRQ_RECOVER_ERROR)
diff --git a/drivers/net/meth.c b/drivers/net/meth.c
index 0343ea1..92b403b 100644
--- a/drivers/net/meth.c
+++ b/drivers/net/meth.c
@@ -8,15 +8,16 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include <linux/kernel.h> /* printk() */
 #include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/errno.h>  /* error codes */
-#include <linux/types.h>  /* size_t */
-#include <linux/interrupt.h> /* mark_bh */
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
 
 #include <linux/in.h>
 #include <linux/in6.h>
@@ -33,7 +34,6 @@
 
 #include <asm/io.h>
 #include <asm/scatterlist.h>
-#include <linux/dma-mapping.h>
 
 #include "meth.h"
 
@@ -51,8 +51,6 @@
 
 
 static const char *meth_str="SGI O2 Fast Ethernet";
-MODULE_AUTHOR("Ilya Volynets <ilya@theIlya.com>");
-MODULE_DESCRIPTION("SGI O2 Builtin Fast Ethernet driver");
 
 #define HAVE_TX_TIMEOUT
 /* The maximum time waited (in jiffies) before assuming a Tx failed. (400ms) */
@@ -784,15 +782,15 @@ static struct net_device_stats *meth_stats(struct net_device *dev)
 /*
  * The init function.
  */
-static struct net_device *meth_init(void)
+static int __init meth_probe(struct platform_device *pdev)
 {
 	struct net_device *dev;
 	struct meth_private *priv;
-	int ret;
+	int err;
 
 	dev = alloc_etherdev(sizeof(struct meth_private));
 	if (!dev)
-		return ERR_PTR(-ENOMEM);
+		return -ENOMEM;
 
 	dev->open            = meth_open;
 	dev->stop            = meth_release;
@@ -808,11 +806,12 @@ static struct net_device *meth_init(void)
 
 	priv = netdev_priv(dev);
 	spin_lock_init(&priv->meth_lock);
+	SET_NETDEV_DEV(dev, &pdev->dev);
 
-	ret = register_netdev(dev);
-	if (ret) {
+	err = register_netdev(dev);
+	if (err) {
 		free_netdev(dev);
-		return ERR_PTR(ret);
+		return err;
 	}
 
 	printk(KERN_INFO "%s: SGI MACE Ethernet rev. %d\n",
@@ -820,21 +819,44 @@ static struct net_device *meth_init(void)
 	return 0;
 }
 
-static struct net_device *meth_dev;
+static int __exit meth_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+
+	unregister_netdev(dev);
+	free_netdev(dev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver meth_driver = {
+	.probe	= meth_probe,
+	.remove	= __devexit_p(meth_remove),
+	.driver = {
+		.name	= "meth",
+	}
+};
 
 static int __init meth_init_module(void)
 {
-	meth_dev = meth_init();
-	if (IS_ERR(meth_dev))
-		return PTR_ERR(meth_dev);
-	return 0;
+	int err;
+
+	err = platform_driver_register(&meth_driver);
+	if (err)
+		printk(KERN_ERR "Driver registration failed\n");
+
+	return err;
 }
 
 static void __exit meth_exit_module(void)
 {
-	unregister_netdev(meth_dev);
-	free_netdev(meth_dev);
+	platform_driver_unregister(&meth_driver);
 }
 
 module_init(meth_init_module);
 module_exit(meth_exit_module);
+
+MODULE_AUTHOR("Ilya Volynets <ilya@theIlya.com>");
+MODULE_DESCRIPTION("SGI O2 Builtin Fast Ethernet driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/mlx4/fw.c b/drivers/net/mlx4/fw.c
index c427173..cfa5cc0 100644
--- a/drivers/net/mlx4/fw.c
+++ b/drivers/net/mlx4/fw.c
@@ -90,7 +90,7 @@ static void dump_dev_cap_flags(struct mlx4_dev *dev, u32 flags)
 	int i;
 
 	mlx4_dbg(dev, "DEV_CAP flags:\n");
-	for (i = 0; i < 32; ++i)
+	for (i = 0; i < ARRAY_SIZE(fname); ++i)
 		if (fname[i] && (flags & (1 << i)))
 			mlx4_dbg(dev, "    %s\n", fname[i]);
 }
diff --git a/drivers/net/phy/fixed.c b/drivers/net/phy/fixed.c
index 68c99b4..bb96691 100644
--- a/drivers/net/phy/fixed.c
+++ b/drivers/net/phy/fixed.c
@@ -89,6 +89,7 @@ EXPORT_SYMBOL(fixed_mdio_set_link_update);
 /*-----------------------------------------------------------------------------
  *  This is used for updating internal mii regs from the status
  *-----------------------------------------------------------------------------*/
+#if defined(CONFIG_FIXED_MII_100_FDX) || defined(CONFIG_FIXED_MII_10_FDX)
 static int fixed_mdio_update_regs(struct fixed_info *fixed)
 {
 	u16 *regs = fixed->regs;
@@ -165,6 +166,7 @@ static int fixed_mii_reset(struct mii_bus *bus)
 	/*nothing here - no way/need to reset it*/
 	return 0;
 }
+#endif
 
 static int fixed_config_aneg(struct phy_device *phydev)
 {
@@ -194,6 +196,7 @@ static struct phy_driver fixed_mdio_driver = {
  * number is used to create multiple fixed PHYs, so that several devices can
  * utilize them simultaneously.
  *-----------------------------------------------------------------------------*/
+#if defined(CONFIG_FIXED_MII_100_FDX) || defined(CONFIG_FIXED_MII_10_FDX)
 static int fixed_mdio_register_device(int number, int speed, int duplex)
 {
 	struct mii_bus *new_bus;
@@ -301,6 +304,7 @@ device_create_fail:
 
 	return err;
 }
+#endif
 
 
 MODULE_DESCRIPTION("Fixed PHY device & driver for PAL");
diff --git a/drivers/net/spider_net.c b/drivers/net/spider_net.c
index c3964c3..ef84d7c 100644
--- a/drivers/net/spider_net.c
+++ b/drivers/net/spider_net.c
@@ -1014,12 +1014,12 @@ spider_net_pass_skb_up(struct spider_net_descr *descr,
 		 */
 	}
 
-	/* pass skb up to stack */
-	netif_receive_skb(skb);
-
 	/* update netdevice statistics */
 	card->netdev_stats.rx_packets++;
 	card->netdev_stats.rx_bytes += skb->len;
+
+	/* pass skb up to stack */
+	netif_receive_skb(skb);
 }
 
 #ifdef DEBUG
diff --git a/drivers/net/tokenring/Kconfig b/drivers/net/tokenring/Kconfig
index 99c4c19..e6b2e06 100644
--- a/drivers/net/tokenring/Kconfig
+++ b/drivers/net/tokenring/Kconfig
@@ -2,12 +2,10 @@
 # Token Ring driver configuration
 #
 
-menu "Token Ring devices"
-	depends on NETDEVICES && !UML
-
 # So far, we only have PCI, ISA, and MCA token ring devices
-config TR
+menuconfig TR
 	bool "Token Ring driver support"
+	depends on NETDEVICES && !UML
 	depends on (PCI || ISA || MCA || CCW)
 	select LLC
 	help
@@ -20,9 +18,11 @@ config TR
 	  from <http://www.tldp.org/docs.html#howto>. Most people can
 	  say N here.
 
+if TR
+
 config IBMTR
 	tristate "IBM Tropic chipset based adapter support"
-	depends on TR && (ISA || MCA)
+	depends on ISA || MCA
 	---help---
 	  This is support for all IBM Token Ring cards that don't use DMA. If
 	  you have such a beast, say Y and read the Token-Ring mini-HOWTO,
@@ -36,7 +36,7 @@ config IBMTR
 
 config IBMOL
 	tristate "IBM Olympic chipset PCI adapter support"
-	depends on TR && PCI
+	depends on PCI
 	---help---
 	  This is support for all non-Lanstreamer IBM PCI Token Ring Cards.
 	  Specifically this is all IBM PCI, PCI Wake On Lan, PCI II, PCI II
@@ -54,7 +54,7 @@ config IBMOL
 
 config IBMLS
 	tristate "IBM Lanstreamer chipset PCI adapter support"
-	depends on TR && PCI && !64BIT
+	depends on PCI && !64BIT
 	help
 	  This is support for IBM Lanstreamer PCI Token Ring Cards.
 
@@ -66,7 +66,7 @@ config IBMLS
 
 config 3C359
 	tristate "3Com 3C359 Token Link Velocity XL adapter support"
-	depends on TR && PCI
+	depends on PCI
 	---help---
 	  This is support for the 3Com PCI Velocity XL cards, specifically
 	  the 3Com 3C359, please note this is not for the 3C339 cards, you
@@ -84,7 +84,7 @@ config 3C359
 
 config TMS380TR
 	tristate "Generic TMS380 Token Ring ISA/PCI adapter support"
-	depends on TR && (PCI || ISA && ISA_DMA_API || MCA)
+	depends on PCI || ISA && ISA_DMA_API || MCA
 	select FW_LOADER
 	---help---
 	  This driver provides generic support for token ring adapters
@@ -108,7 +108,7 @@ config TMS380TR
 
 config TMSPCI
 	tristate "Generic TMS380 PCI support"
-	depends on TR && TMS380TR && PCI
+	depends on TMS380TR && PCI
 	---help---
 	  This tms380 module supports generic TMS380-based PCI cards.
 
@@ -123,7 +123,7 @@ config TMSPCI
 
 config SKISA
 	tristate "SysKonnect TR4/16 ISA support"
-	depends on TR && TMS380TR && ISA
+	depends on TMS380TR && ISA
 	help
 	  This tms380 module supports SysKonnect TR4/16 ISA cards.
 
@@ -135,7 +135,7 @@ config SKISA
 
 config PROTEON
 	tristate "Proteon ISA support"
-	depends on TR && TMS380TR && ISA
+	depends on TMS380TR && ISA
 	help
 	  This tms380 module supports Proteon ISA cards.
 
@@ -148,7 +148,7 @@ config PROTEON
 
 config ABYSS
 	tristate "Madge Smart 16/4 PCI Mk2 support"
-	depends on TR && TMS380TR && PCI
+	depends on TMS380TR && PCI
 	help
 	  This tms380 module supports the Madge Smart 16/4 PCI Mk2
 	  cards (51-02).
@@ -158,7 +158,7 @@ config ABYSS
 
 config MADGEMC
 	tristate "Madge Smart 16/4 Ringnode MicroChannel"
-	depends on TR && TMS380TR && MCA
+	depends on TMS380TR && MCA
 	help
 	  This tms380 module supports the Madge Smart 16/4 MC16 and MC32
 	  MicroChannel adapters.
@@ -168,7 +168,7 @@ config MADGEMC
 
 config SMCTR
 	tristate "SMC ISA/MCA adapter support"
-	depends on TR && (ISA || MCA_LEGACY) && (BROKEN || !64BIT)
+	depends on (ISA || MCA_LEGACY) && (BROKEN || !64BIT)
 	---help---
 	  This is support for the ISA and MCA SMC Token Ring cards,
 	  specifically SMC TokenCard Elite (8115T) and SMC TokenCard Elite/A
@@ -182,5 +182,4 @@ config SMCTR
 	  To compile this driver as a module, choose M here: the module will be
 	  called smctr.
 
-endmenu
-
+endif # TR
diff --git a/drivers/net/ucc_geth.c b/drivers/net/ucc_geth.c
index c2ccbd0..18b731b 100644
--- a/drivers/net/ucc_geth.c
+++ b/drivers/net/ucc_geth.c
@@ -23,11 +23,8 @@
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
 #include <linux/mm.h>
-#include <linux/ethtool.h>
-#include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/fsl_devices.h>
-#include <linux/ethtool.h>
 #include <linux/mii.h>
 #include <linux/phy.h>
 #include <linux/workqueue.h>
diff --git a/drivers/net/ucc_geth_mii.c b/drivers/net/ucc_geth_mii.c
index f96966d..7bcb82f 100644
--- a/drivers/net/ucc_geth_mii.c
+++ b/drivers/net/ucc_geth_mii.c
@@ -260,8 +260,6 @@ static struct of_device_id uec_mdio_match[] = {
 	{},
 };
 
-MODULE_DEVICE_TABLE(of, uec_mdio_match);
-
 static struct of_platform_driver uec_mdio_driver = {
 	.name	= DRV_NAME,
 	.probe	= uec_mdio_probe,
diff --git a/drivers/net/usb/asix.c b/drivers/net/usb/asix.c
index d5ef97b..6d95cac 100644
--- a/drivers/net/usb/asix.c
+++ b/drivers/net/usb/asix.c
@@ -1458,6 +1458,10 @@ static const struct usb_device_id	products [] = {
 	// IO-DATA ETG-US2
 	USB_DEVICE (0x04bb, 0x0930),
 	.driver_info = (unsigned long) &ax88178_info,
+}, {
+	// Belkin F5D5055
+	USB_DEVICE(0x050d, 0x5055),
+	.driver_info = (unsigned long) &ax88178_info,
 },
 	{ },		// END
 };
diff --git a/drivers/net/usb/cdc_ether.c b/drivers/net/usb/cdc_ether.c
index 5a21f06..675ac99 100644
--- a/drivers/net/usb/cdc_ether.c
+++ b/drivers/net/usb/cdc_ether.c
@@ -91,6 +91,22 @@ int usbnet_generic_cdc_bind(struct usbnet *dev, struct usb_interface *intf)
 				"CDC descriptors on config\n");
 	}
 
+	/* Maybe CDC descriptors are after the endpoint?  This bug has
+	 * been seen on some 2Wire Inc RNDIS-ish products.
+	 */
+	if (len == 0) {
+		struct usb_host_endpoint	*hep;
+
+		hep = intf->cur_altsetting->endpoint;
+		if (hep) {
+			buf = hep->extra;
+			len = hep->extralen;
+		}
+		if (len)
+			dev_dbg(&intf->dev,
+				"CDC descriptors on endpoint\n");
+	}
+
 	/* this assumes that if there's a non-RNDIS vendor variant
 	 * of cdc-acm, it'll fail RNDIS requests cleanly.
 	 */
diff --git a/drivers/net/usb/rndis_host.c b/drivers/net/usb/rndis_host.c
index 980e4aa..cd991a0 100644
--- a/drivers/net/usb/rndis_host.c
+++ b/drivers/net/usb/rndis_host.c
@@ -515,6 +515,7 @@ static int rndis_bind(struct usbnet *dev, struct usb_interface *intf)
 		dev_err(&intf->dev,
 			"dev can't take %u byte packets (max %u)\n",
 			dev->hard_mtu, tmp);
+		retval = -EINVAL;
 		goto fail_and_release;
 	}
 
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index f9cd42d..5b16d9a 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -1252,20 +1252,23 @@ EXPORT_SYMBOL_GPL(usbnet_probe);
 
 /*-------------------------------------------------------------------------*/
 
-/* FIXME these suspend/resume methods assume non-CDC style
- * devices, with only one interface.
+/*
+ * suspend the whole driver as soon as the first interface is suspended
+ * resume only when the last interface is resumed
  */
 
 int usbnet_suspend (struct usb_interface *intf, pm_message_t message)
 {
 	struct usbnet		*dev = usb_get_intfdata(intf);
 
-	/* accelerate emptying of the rx and queues, to avoid
-	 * having everything error out.
-	 */
-	netif_device_detach (dev->net);
-	(void) unlink_urbs (dev, &dev->rxq);
-	(void) unlink_urbs (dev, &dev->txq);
+	if (!dev->suspend_count++) {
+		/* accelerate emptying of the rx and queues, to avoid
+		 * having everything error out.
+		 */
+		netif_device_detach (dev->net);
+		(void) unlink_urbs (dev, &dev->rxq);
+		(void) unlink_urbs (dev, &dev->txq);
+	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(usbnet_suspend);
@@ -1274,8 +1277,10 @@ int usbnet_resume (struct usb_interface *intf)
 {
 	struct usbnet		*dev = usb_get_intfdata(intf);
 
-	netif_device_attach (dev->net);
-	tasklet_schedule (&dev->bh);
+	if (!--dev->suspend_count) {
+		netif_device_attach (dev->net);
+		tasklet_schedule (&dev->bh);
+	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(usbnet_resume);
diff --git a/drivers/net/usb/usbnet.h b/drivers/net/usb/usbnet.h
index 82db5a8..a3f8b9e 100644
--- a/drivers/net/usb/usbnet.h
+++ b/drivers/net/usb/usbnet.h
@@ -32,6 +32,7 @@ struct usbnet {
 	const char		*driver_name;
 	wait_queue_head_t	*wait;
 	struct mutex		phy_mutex;
+	unsigned char		suspend_count;
 
 	/* i/o info: pipes etc */
 	unsigned		in, out;
diff --git a/drivers/net/wireless/libertas/decl.h b/drivers/net/wireless/libertas/decl.h
index 606bdd0..dfe2764 100644
--- a/drivers/net/wireless/libertas/decl.h
+++ b/drivers/net/wireless/libertas/decl.h
@@ -46,7 +46,7 @@ u32 libertas_index_to_data_rate(u8 index);
 u8 libertas_data_rate_to_index(u32 rate);
 void libertas_get_fwversion(wlan_adapter * adapter, char *fwversion, int maxlen);
 
-int libertas_upload_rx_packet(wlan_private * priv, struct sk_buff *skb);
+void libertas_upload_rx_packet(wlan_private * priv, struct sk_buff *skb);
 
 /** The proc fs interface */
 int libertas_process_rx_command(wlan_private * priv);
diff --git a/drivers/net/wireless/libertas/fw.c b/drivers/net/wireless/libertas/fw.c
index 441123c..5c63c9b 100644
--- a/drivers/net/wireless/libertas/fw.c
+++ b/drivers/net/wireless/libertas/fw.c
@@ -333,18 +333,22 @@ static void command_timer_fn(unsigned long data)
 	unsigned long flags;
 
 	ptempnode = adapter->cur_cmd;
+	if (ptempnode == NULL) {
+		lbs_pr_debug(1, "PTempnode Empty\n");
+		return;
+	}
+
 	cmd = (struct cmd_ds_command *)ptempnode->bufvirtualaddr;
+	if (!cmd) {
+		lbs_pr_debug(1, "cmd is NULL\n");
+		return;
+	}
 
 	lbs_pr_info("command_timer_fn fired (%x)\n", cmd->command);
 
 	if (!adapter->fw_ready)
 		return;
 
-	if (ptempnode == NULL) {
-		lbs_pr_debug(1, "PTempnode Empty\n");
-		return;
-	}
-
 	spin_lock_irqsave(&adapter->driver_lock, flags);
 	adapter->cur_cmd = NULL;
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
diff --git a/drivers/net/wireless/libertas/rx.c b/drivers/net/wireless/libertas/rx.c
index d17924f..96619a3 100644
--- a/drivers/net/wireless/libertas/rx.c
+++ b/drivers/net/wireless/libertas/rx.c
@@ -136,7 +136,7 @@ static void wlan_compute_rssi(wlan_private * priv, struct rxpd *p_rx_pd)
 	LEAVE();
 }
 
-int libertas_upload_rx_packet(wlan_private * priv, struct sk_buff *skb)
+void libertas_upload_rx_packet(wlan_private * priv, struct sk_buff *skb)
 {
 	lbs_pr_debug(1, "skb->data=%p\n", skb->data);
 
@@ -148,8 +148,6 @@ int libertas_upload_rx_packet(wlan_private * priv, struct sk_buff *skb)
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 
 	netif_rx(skb);
-
-	return 0;
 }
 
 /**
@@ -269,15 +267,11 @@ int libertas_process_rxed_packet(wlan_private * priv, struct sk_buff *skb)
 	wlan_compute_rssi(priv, p_rx_pd);
 
 	lbs_pr_debug(1, "RX Data: size of actual packet = %d\n", skb->len);
-	if (libertas_upload_rx_packet(priv, skb)) {
-		lbs_pr_debug(1, "RX error: libertas_upload_rx_packet"
-		       " returns failure\n");
-		ret = -1;
-		goto done;
-	}
 	priv->stats.rx_bytes += skb->len;
 	priv->stats.rx_packets++;
 
+	libertas_upload_rx_packet(priv, skb);
+
 	ret = 0;
 done:
 	LEAVE();
@@ -438,22 +432,14 @@ static int process_rxed_802_11_packet(wlan_private * priv, struct sk_buff *skb)
 	wlan_compute_rssi(priv, prxpd);
 
 	lbs_pr_debug(1, "RX Data: size of actual packet = %d\n", skb->len);
-
-	if (libertas_upload_rx_packet(priv, skb)) {
-		lbs_pr_debug(1, "RX error: libertas_upload_rx_packet "
-			"returns failure\n");
-		ret = -1;
-		goto done;
-	}
-
 	priv->stats.rx_bytes += skb->len;
 	priv->stats.rx_packets++;
 
+	libertas_upload_rx_packet(priv, skb);
+
 	ret = 0;
 done:
 	LEAVE();
 
-	skb->protocol = __constant_htons(0x0019);	/* ETH_P_80211_RAW */
-
 	return (ret);
 }
diff --git a/drivers/oprofile/buffer_sync.c b/drivers/oprofile/buffer_sync.c
index 78c2e6e..edd6de9 100644
--- a/drivers/oprofile/buffer_sync.c
+++ b/drivers/oprofile/buffer_sync.c
@@ -26,6 +26,7 @@
 #include <linux/profile.h>
 #include <linux/module.h>
 #include <linux/fs.h>
+#include <linux/sched.h>
  
 #include "oprofile_stats.h"
 #include "event_buffer.h"
diff --git a/drivers/pci/hotplug/ibmphp_hpc.c b/drivers/pci/hotplug/ibmphp_hpc.c
index 46abaa8..d06ccb6 100644
--- a/drivers/pci/hotplug/ibmphp_hpc.c
+++ b/drivers/pci/hotplug/ibmphp_hpc.c
@@ -34,6 +34,7 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/mutex.h>
+#include <linux/sched.h>
 
 #include "ibmphp.h"
 
diff --git a/drivers/pci/pcie/aer/aerdrv.h b/drivers/pci/pcie/aer/aerdrv.h
index bf655db..5cca394 100644
--- a/drivers/pci/pcie/aer/aerdrv.h
+++ b/drivers/pci/pcie/aer/aerdrv.h
@@ -8,6 +8,7 @@
 #ifndef _AERDRV_H_
 #define _AERDRV_H_
 
+#include <linux/workqueue.h>
 #include <linux/pcieport_if.h>
 #include <linux/aer.h>
 
diff --git a/drivers/scsi/megaraid/megaraid_mm.c b/drivers/scsi/megaraid/megaraid_mm.c
index e075a52..84d9c27 100644
--- a/drivers/scsi/megaraid/megaraid_mm.c
+++ b/drivers/scsi/megaraid/megaraid_mm.c
@@ -14,7 +14,7 @@
  *
  * Common management module
  */
-
+#include <linux/sched.h>
 #include "megaraid_mm.h"
 
 
diff --git a/drivers/serial/bfin_5xx.c b/drivers/serial/bfin_5xx.c
index 408390f..787dc71 100644
--- a/drivers/serial/bfin_5xx.c
+++ b/drivers/serial/bfin_5xx.c
@@ -6,8 +6,6 @@
  * Created:
  * Description:  Driver for blackfin 5xx serial ports
  *
- * Rev:          $Id: bfin_5xx.c,v 1.19 2006/09/24 02:33:53 aubrey Exp $
- *
  * Modified:
  *               Copyright 2006 Analog Devices Inc.
  *
@@ -152,7 +150,7 @@ static void local_put_char(struct bfin_serial_port *uart, char ch)
 
 static void bfin_serial_rx_chars(struct bfin_serial_port *uart)
 {
-	struct tty_struct *tty = uart->port.info?uart->port.info->tty:0;
+	struct tty_struct *tty = uart->port.info->tty;
 	unsigned int status, ch, flg;
 #ifdef BF533_FAMILY
 	static int in_break = 0;
@@ -173,8 +171,10 @@ static void bfin_serial_rx_chars(struct bfin_serial_port *uart)
 		if (ch != 0) {
 			in_break = 0;
 			ch = UART_GET_CHAR(uart);
-		}
-		return;
+			if (bfin_revid() < 5)
+				return;
+		} else
+			return;
 	}
 #endif
 
@@ -185,27 +185,32 @@ static void bfin_serial_rx_chars(struct bfin_serial_port *uart)
 		uart->port.icount.brk++;
 		if (uart_handle_break(&uart->port))
 			goto ignore_char;
-		flg = TTY_BREAK;
-	} else if (status & PE) {
-		flg = TTY_PARITY;
+	}
+	if (status & PE)
 		uart->port.icount.parity++;
-	} else if (status & OE) {
-		flg = TTY_OVERRUN;
+	if (status & OE)
 		uart->port.icount.overrun++;
-	} else if (status & FE) {
-		flg = TTY_FRAME;
+	if (status & FE)
 		uart->port.icount.frame++;
-	} else
+
+	status &= uart->port.read_status_mask;
+
+	if (status & BI)
+		flg = TTY_BREAK;
+	else if (status & PE)
+		flg = TTY_PARITY;
+	else if (status & FE)
+		flg = TTY_FRAME;
+	else
 		flg = TTY_NORMAL;
 
 	if (uart_handle_sysrq_char(&uart->port, ch))
 		goto ignore_char;
-	if (tty)
-		uart_insert_char(&uart->port, status, 2, ch, flg);
 
-ignore_char:
-	if (tty)
-		tty_flip_buffer_push(tty);
+	uart_insert_char(&uart->port, status, OE, ch, flg);
+
+ ignore_char:
+	tty_flip_buffer_push(tty);
 }
 
 static void bfin_serial_tx_chars(struct bfin_serial_port *uart)
@@ -240,24 +245,29 @@ static void bfin_serial_tx_chars(struct bfin_serial_port *uart)
 		bfin_serial_stop_tx(&uart->port);
 }
 
-static irqreturn_t bfin_serial_int(int irq, void *dev_id)
+static irqreturn_t bfin_serial_rx_int(int irq, void *dev_id)
 {
 	struct bfin_serial_port *uart = dev_id;
-	unsigned short status;
 
 	spin_lock(&uart->port.lock);
-	status = UART_GET_IIR(uart);
-	do {
-		if ((status & IIR_STATUS) == IIR_TX_READY)
-			bfin_serial_tx_chars(uart);
-		if ((status & IIR_STATUS) == IIR_RX_READY)
-			bfin_serial_rx_chars(uart);
-		status = UART_GET_IIR(uart);
-	} while (status & (IIR_TX_READY | IIR_RX_READY));
+	while ((UART_GET_IIR(uart) & IIR_STATUS) == IIR_RX_READY)
+		bfin_serial_rx_chars(uart);
 	spin_unlock(&uart->port.lock);
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t bfin_serial_tx_int(int irq, void *dev_id)
+{
+	struct bfin_serial_port *uart = dev_id;
+
+	spin_lock(&uart->port.lock);
+	while ((UART_GET_IIR(uart) & IIR_STATUS) == IIR_TX_READY)
+		bfin_serial_tx_chars(uart);
+	spin_unlock(&uart->port.lock);
+	return IRQ_HANDLED;
+}
+
+
 static void bfin_serial_do_work(struct work_struct *work)
 {
 	struct bfin_serial_port *uart = container_of(work, struct bfin_serial_port, cts_workqueue);
@@ -319,7 +329,7 @@ static void bfin_serial_dma_tx_chars(struct bfin_serial_port *uart)
 	spin_unlock_irqrestore(&uart->port.lock, flags);
 }
 
-static void bfin_serial_dma_rx_chars(struct bfin_serial_port * uart)
+static void bfin_serial_dma_rx_chars(struct bfin_serial_port *uart)
 {
 	struct tty_struct *tty = uart->port.info->tty;
 	int i, flg, status;
@@ -331,25 +341,32 @@ static void bfin_serial_dma_rx_chars(struct bfin_serial_port * uart)
 		uart->port.icount.brk++;
 		if (uart_handle_break(&uart->port))
 			goto dma_ignore_char;
-		flg = TTY_BREAK;
-	} else if (status & PE) {
-		flg = TTY_PARITY;
+	}
+	if (status & PE)
 		uart->port.icount.parity++;
-	} else if (status & OE) {
-		flg = TTY_OVERRUN;
+	if (status & OE)
 		uart->port.icount.overrun++;
-	} else if (status & FE) {
-		flg = TTY_FRAME;
+	if (status & FE)
 		uart->port.icount.frame++;
-	} else
+
+	status &= uart->port.read_status_mask;
+
+	if (status & BI)
+		flg = TTY_BREAK;
+	else if (status & PE)
+		flg = TTY_PARITY;
+	else if (status & FE)
+		flg = TTY_FRAME;
+	else
 		flg = TTY_NORMAL;
 
 	for (i = uart->rx_dma_buf.head; i < uart->rx_dma_buf.tail; i++) {
 		if (uart_handle_sysrq_char(&uart->port, uart->rx_dma_buf.buf[i]))
 			goto dma_ignore_char;
-		uart_insert_char(&uart->port, status, 2, uart->rx_dma_buf.buf[i], flg);
+		uart_insert_char(&uart->port, status, OE, uart->rx_dma_buf.buf[i], flg);
 	}
-dma_ignore_char:
+
+ dma_ignore_char:
 	tty_flip_buffer_push(tty);
 }
 
@@ -545,14 +562,14 @@ static int bfin_serial_startup(struct uart_port *port)
 	add_timer(&(uart->rx_dma_timer));
 #else
 	if (request_irq
-	    (uart->port.irq, bfin_serial_int, IRQF_DISABLED,
+	    (uart->port.irq, bfin_serial_rx_int, IRQF_DISABLED,
 	     "BFIN_UART_RX", uart)) {
 		printk(KERN_NOTICE "Unable to attach BlackFin UART RX interrupt\n");
 		return -EBUSY;
 	}
 
 	if (request_irq
-	    (uart->port.irq+1, bfin_serial_int, IRQF_DISABLED,
+	    (uart->port.irq+1, bfin_serial_tx_int, IRQF_DISABLED,
 	     "BFIN_UART_TX", uart)) {
 		printk(KERN_NOTICE "Unable to attach BlackFin UART TX interrupt\n");
 		free_irq(uart->port.irq, uart);
@@ -614,13 +631,27 @@ bfin_serial_set_termios(struct uart_port *port, struct ktermios *termios,
 			lcr |= EPS;
 	}
 
-	/* These controls are not implemented for this port */
-	termios->c_iflag |= INPCK | BRKINT | PARMRK;
-	termios->c_iflag &= ~(IGNPAR | IGNBRK);
+	port->read_status_mask = OE;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= (FE | PE);
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= BI;
 
-	/* These controls are not implemented for this port */
-	termios->c_iflag |= INPCK | BRKINT | PARMRK;
-	termios->c_iflag &= ~(IGNPAR | IGNBRK);
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= FE | PE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= OE;
+	}
 
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
 	quot = uart_get_divisor(port, baud);
diff --git a/drivers/serial/serial_ks8695.c b/drivers/serial/serial_ks8695.c
index c5346d6..698763b 100644
--- a/drivers/serial/serial_ks8695.c
+++ b/drivers/serial/serial_ks8695.c
@@ -301,11 +301,11 @@ static int ks8695uart_startup(struct uart_port *port)
 
 	retval = request_irq(KS8695_IRQ_UART_LINE_STATUS, ks8695uart_rx_chars, IRQF_DISABLED, "UART LineStatus", port);
 	if (retval)
-		return err_ls;
+		goto err_ls;
 
 	retval = request_irq(KS8695_IRQ_UART_MODEM_STATUS, ks8695uart_modem_status, IRQF_DISABLED, "UART ModemStatus", port);
 	if (retval)
-		return err_ms;
+		goto err_ms;
 
 	return 0;
 
diff --git a/drivers/spi/mpc52xx_psc_spi.c b/drivers/spi/mpc52xx_psc_spi.c
index 052359f..11f36be 100644
--- a/drivers/spi/mpc52xx_psc_spi.c
+++ b/drivers/spi/mpc52xx_psc_spi.c
@@ -329,8 +329,8 @@ static int mpc52xx_psc_spi_port_config(int psc_id, struct mpc52xx_psc_spi *mps)
 	int ret = 0;
 
 #if defined(CONFIG_PPC_MERGE)
-	cdm = mpc52xx_find_and_map("mpc52xx-cdm");
-	gpio = mpc52xx_find_and_map("mpc52xx-gpio");
+	cdm = mpc52xx_find_and_map("mpc5200-cdm");
+	gpio = mpc52xx_find_and_map("mpc5200-gpio");
 #else
 	cdm = ioremap(MPC52xx_PA(MPC52xx_CDM_OFFSET), MPC52xx_CDM_SIZE);
 	gpio = ioremap(MPC52xx_PA(MPC52xx_GPIO_OFFSET), MPC52xx_GPIO_SIZE);
@@ -445,9 +445,6 @@ static int __init mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,
 	struct spi_master *master;
 	int ret;
 
-	if (pdata == NULL)
-		return -ENODEV;
-
 	master = spi_alloc_master(dev, sizeof *mps);
 	if (master == NULL)
 		return -ENOMEM;
@@ -594,17 +591,17 @@ static int __init mpc52xx_psc_spi_of_probe(struct of_device *op,
 	}
 	regaddr64 = of_translate_address(op->node, regaddr_p);
 
+	/* get PSC id (1..6, used by port_config) */
 	if (op->dev.platform_data == NULL) {
-		struct device_node *np;
-		int i = 0;
+		const u32 *psc_nump;
 
-		for_each_node_by_type(np, "spi") {
-			if (of_find_device_by_node(np) == op) {
-				id = i;
-				break;
-			}
-			i++;
+		psc_nump = of_get_property(op->node, "cell-index", NULL);
+		if (!psc_nump || *psc_nump > 5) {
+			printk(KERN_ERR "mpc52xx_psc_spi: Device node %s has invalid "
+					"cell-index property\n", op->node->full_name);
+			return -EINVAL;
 		}
+		id = *psc_nump + 1;
 	}
 
 	return mpc52xx_psc_spi_do_probe(&op->dev, (u32)regaddr64, (u32)size64,
@@ -617,7 +614,7 @@ static int __exit mpc52xx_psc_spi_of_remove(struct of_device *op)
 }
 
 static struct of_device_id mpc52xx_psc_spi_of_match[] = {
-	{ .type = "spi", .compatible = "mpc52xx-psc-spi", },
+	{ .type = "spi", .compatible = "mpc5200-psc-spi", },
 	{},
 };
 
diff --git a/drivers/spi/omap_uwire.c b/drivers/spi/omap_uwire.c
index 96f62b2..95183e1 100644
--- a/drivers/spi/omap_uwire.c
+++ b/drivers/spi/omap_uwire.c
@@ -358,11 +358,11 @@ static int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
 	switch (spi->mode & (SPI_CPOL | SPI_CPHA)) {
 	case SPI_MODE_0:
 	case SPI_MODE_3:
-		flags |= UWIRE_WRITE_RISING_EDGE | UWIRE_READ_FALLING_EDGE;
+		flags |= UWIRE_WRITE_FALLING_EDGE | UWIRE_READ_RISING_EDGE;
 		break;
 	case SPI_MODE_1:
 	case SPI_MODE_2:
-		flags |= UWIRE_WRITE_FALLING_EDGE | UWIRE_READ_RISING_EDGE;
+		flags |= UWIRE_WRITE_RISING_EDGE | UWIRE_READ_FALLING_EDGE;
 		break;
 	}
 
diff --git a/drivers/spi/spi_bfin5xx.c b/drivers/spi/spi_bfin5xx.c
index ce3c0ce..7d2d9ec 100644
--- a/drivers/spi/spi_bfin5xx.c
+++ b/drivers/spi/spi_bfin5xx.c
@@ -126,7 +126,7 @@ struct chip_data {
 
 	u8 chip_select_num;
 	u8 n_bytes;
-	u32 width;		/* 0 or 1 */
+	u8 width;		/* 0 or 1 */
 	u8 enable_dma;
 	u8 bits_per_word;	/* 8 or 16 */
 	u8 cs_change_per_word;
@@ -136,7 +136,7 @@ struct chip_data {
 	void (*duplex) (struct driver_data *);
 };
 
-void bfin_spi_enable(struct driver_data *drv_data)
+static void bfin_spi_enable(struct driver_data *drv_data)
 {
 	u16 cr;
 
@@ -145,7 +145,7 @@ void bfin_spi_enable(struct driver_data *drv_data)
 	SSYNC();
 }
 
-void bfin_spi_disable(struct driver_data *drv_data)
+static void bfin_spi_disable(struct driver_data *drv_data)
 {
 	u16 cr;
 
@@ -163,9 +163,6 @@ static u16 hz_to_spi_baud(u32 speed_hz)
 	if ((sclk % (2 * speed_hz)) > 0)
 		spi_baud++;
 
-	pr_debug("sclk = %ld, speed_hz = %d, spi_baud = %d\n", sclk, speed_hz,
-		 spi_baud);
-
 	return spi_baud;
 }
 
@@ -190,11 +187,12 @@ static void restore_state(struct driver_data *drv_data)
 	/* Clear status and disable clock */
 	write_STAT(BIT_STAT_CLR);
 	bfin_spi_disable(drv_data);
-	pr_debug("restoring spi ctl state\n");
+	dev_dbg(&drv_data->pdev->dev, "restoring spi ctl state\n");
 
 #if defined(CONFIG_BF534) || defined(CONFIG_BF536) || defined(CONFIG_BF537)
-	pr_debug("chip select number is %d\n", chip->chip_select_num);
-
+	dev_dbg(&drv_data->pdev->dev, 
+		"chip select number is %d\n", chip->chip_select_num);
+	
 	switch (chip->chip_select_num) {
 	case 1:
 		bfin_write_PORTF_FER(bfin_read_PORTF_FER() | 0x3c00);
@@ -280,7 +278,8 @@ static void null_reader(struct driver_data *drv_data)
 
 static void u8_writer(struct driver_data *drv_data)
 {
-	pr_debug("cr8-s is 0x%x\n", read_STAT());
+	dev_dbg(&drv_data->pdev->dev, 
+		"cr8-s is 0x%x\n", read_STAT());
 	while (drv_data->tx < drv_data->tx_end) {
 		write_TDBR(*(u8 *) (drv_data->tx));
 		while (read_STAT() & BIT_STAT_TXS)
@@ -318,7 +317,8 @@ static void u8_cs_chg_writer(struct driver_data *drv_data)
 
 static void u8_reader(struct driver_data *drv_data)
 {
-	pr_debug("cr-8 is 0x%x\n", read_STAT());
+	dev_dbg(&drv_data->pdev->dev, 
+		"cr-8 is 0x%x\n", read_STAT());
 
 	/* clear TDBR buffer before read(else it will be shifted out) */
 	write_TDBR(0xFFFF);
@@ -404,7 +404,9 @@ static void u8_cs_chg_duplex(struct driver_data *drv_data)
 
 static void u16_writer(struct driver_data *drv_data)
 {
-	pr_debug("cr16 is 0x%x\n", read_STAT());
+	dev_dbg(&drv_data->pdev->dev, 
+		"cr16 is 0x%x\n", read_STAT());
+
 	while (drv_data->tx < drv_data->tx_end) {
 		write_TDBR(*(u16 *) (drv_data->tx));
 		while ((read_STAT() & BIT_STAT_TXS))
@@ -442,7 +444,8 @@ static void u16_cs_chg_writer(struct driver_data *drv_data)
 
 static void u16_reader(struct driver_data *drv_data)
 {
-	pr_debug("cr-16 is 0x%x\n", read_STAT());
+	dev_dbg(&drv_data->pdev->dev,
+		"cr-16 is 0x%x\n", read_STAT());
 	dummy_read();
 
 	while (drv_data->rx < (drv_data->rx_end - 2)) {
@@ -571,12 +574,12 @@ static void giveback(struct driver_data *drv_data)
 		msg->complete(msg->context);
 }
 
-static irqreturn_t dma_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 {
 	struct driver_data *drv_data = (struct driver_data *)dev_id;
 	struct spi_message *msg = drv_data->cur_msg;
 
-	pr_debug("in dma_irq_handler\n");
+	dev_dbg(&drv_data->pdev->dev, "in dma_irq_handler\n");
 	clear_dma_irqstat(CH_SPI);
 
 	/*
@@ -604,7 +607,9 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
 	tasklet_schedule(&drv_data->pump_transfers);
 
 	/* free the irq handler before next transfer */
-	pr_debug("disable dma channel irq%d\n", CH_SPI);
+	dev_dbg(&drv_data->pdev->dev,
+		"disable dma channel irq%d\n",
+		CH_SPI);
 	dma_disable_irq(CH_SPI);
 
 	return IRQ_HANDLED;
@@ -617,7 +622,8 @@ static void pump_transfers(unsigned long data)
 	struct spi_transfer *transfer = NULL;
 	struct spi_transfer *previous = NULL;
 	struct chip_data *chip = NULL;
-	u16 cr, width, dma_width, dma_config;
+	u8 width;
+	u16 cr, dma_width, dma_config;
 	u32 tranf_success = 1;
 
 	/* Get current state information */
@@ -662,8 +668,8 @@ static void pump_transfers(unsigned long data)
 	if (transfer->tx_buf != NULL) {
 		drv_data->tx = (void *)transfer->tx_buf;
 		drv_data->tx_end = drv_data->tx + transfer->len;
-		pr_debug("tx_buf is %p, tx_end is %p\n", transfer->tx_buf,
-			 drv_data->tx_end);
+		dev_dbg(&drv_data->pdev->dev, "tx_buf is %p, tx_end is %p\n",
+			transfer->tx_buf, drv_data->tx_end);
 	} else {
 		drv_data->tx = NULL;
 	}
@@ -671,8 +677,8 @@ static void pump_transfers(unsigned long data)
 	if (transfer->rx_buf != NULL) {
 		drv_data->rx = transfer->rx_buf;
 		drv_data->rx_end = drv_data->rx + transfer->len;
-		pr_debug("rx_buf is %p, rx_end is %p\n", transfer->rx_buf,
-			 drv_data->rx_end);
+		dev_dbg(&drv_data->pdev->dev, "rx_buf is %p, rx_end is %p\n",
+			transfer->rx_buf, drv_data->rx_end);
 	} else {
 		drv_data->rx = NULL;
 	}
@@ -690,9 +696,9 @@ static void pump_transfers(unsigned long data)
 	drv_data->write = drv_data->tx ? chip->write : null_writer;
 	drv_data->read = drv_data->rx ? chip->read : null_reader;
 	drv_data->duplex = chip->duplex ? chip->duplex : null_writer;
-	pr_debug
-	    ("transfer: drv_data->write is %p, chip->write is %p, null_wr is %p\n",
-	     drv_data->write, chip->write, null_writer);
+	dev_dbg(&drv_data->pdev->dev,
+		"transfer: drv_data->write is %p, chip->write is %p, null_wr is %p\n",
+   		drv_data->write, chip->write, null_writer);
 
 	/* speed and width has been set on per message */
 	message->state = RUNNING_STATE;
@@ -706,8 +712,9 @@ static void pump_transfers(unsigned long data)
 	}
 	write_FLAG(chip->flag);
 
-	pr_debug("now pumping a transfer: width is %d, len is %d\n", width,
-		 transfer->len);
+	dev_dbg(&drv_data->pdev->dev,
+		"now pumping a transfer: width is %d, len is %d\n",
+		width, transfer->len);
 
 	/*
 	 * Try to map dma buffer and do a dma transfer if
@@ -722,7 +729,7 @@ static void pump_transfers(unsigned long data)
 		bfin_spi_disable(drv_data);
 
 		/* config dma channel */
-		pr_debug("doing dma transfer\n");
+		dev_dbg(&drv_data->pdev->dev, "doing dma transfer\n");
 		if (width == CFG_SPI_WORDSIZE16) {
 			set_dma_x_count(CH_SPI, drv_data->len);
 			set_dma_x_modify(CH_SPI, 2);
@@ -738,7 +745,8 @@ static void pump_transfers(unsigned long data)
 
 		/* dirty hack for autobuffer DMA mode */
 		if (drv_data->tx_dma == 0xFFFF) {
-			pr_debug("doing autobuffer DMA out.\n");
+			dev_dbg(&drv_data->pdev->dev,
+				"doing autobuffer DMA out.\n");
 
 			/* no irq in autobuffer mode */
 			dma_config =
@@ -758,7 +766,7 @@ static void pump_transfers(unsigned long data)
 		/* In dma mode, rx or tx must be NULL in one transfer */
 		if (drv_data->rx != NULL) {
 			/* set transfer mode, and enable SPI */
-			pr_debug("doing DMA in.\n");
+			dev_dbg(&drv_data->pdev->dev, "doing DMA in.\n");
 
 			/* disable SPI before write to TDBR */
 			write_CTRL(cr & ~BIT_CTL_ENABLE);
@@ -781,7 +789,7 @@ static void pump_transfers(unsigned long data)
 			/* set transfer mode, and enable SPI */
 			write_CTRL(cr);
 		} else if (drv_data->tx != NULL) {
-			pr_debug("doing DMA out.\n");
+			dev_dbg(&drv_data->pdev->dev, "doing DMA out.\n");
 
 			/* start dma */
 			dma_enable_irq(CH_SPI);
@@ -796,7 +804,7 @@ static void pump_transfers(unsigned long data)
 		}
 	} else {
 		/* IO mode write then read */
-		pr_debug("doing IO transfer\n");
+		dev_dbg(&drv_data->pdev->dev, "doing IO transfer\n");
 
 		write_STAT(BIT_STAT_CLR);
 
@@ -804,11 +812,11 @@ static void pump_transfers(unsigned long data)
 			/* full duplex mode */
 			BUG_ON((drv_data->tx_end - drv_data->tx) !=
 			       (drv_data->rx_end - drv_data->rx));
-			cr = (read_CTRL() & (~BIT_CTL_TIMOD));	/* clear the TIMOD bits */
-			cr |=
-			    CFG_SPI_WRITE | (width << 8) | (CFG_SPI_ENABLE <<
-							    14);
-			pr_debug("IO duplex: cr is 0x%x\n", cr);
+			cr = (read_CTRL() & (~BIT_CTL_TIMOD));	
+			cr |= CFG_SPI_WRITE | (width << 8) |
+				(CFG_SPI_ENABLE << 14);
+			dev_dbg(&drv_data->pdev->dev,
+				"IO duplex: cr is 0x%x\n", cr);
 
 			write_CTRL(cr);
 			SSYNC();
@@ -819,11 +827,11 @@ static void pump_transfers(unsigned long data)
 				tranf_success = 0;
 		} else if (drv_data->tx != NULL) {
 			/* write only half duplex */
-			cr = (read_CTRL() & (~BIT_CTL_TIMOD));	/* clear the TIMOD bits */
-			cr |=
-			    CFG_SPI_WRITE | (width << 8) | (CFG_SPI_ENABLE <<
-							    14);
-			pr_debug("IO write: cr is 0x%x\n", cr);
+			cr = (read_CTRL() & (~BIT_CTL_TIMOD));
+			cr |= CFG_SPI_WRITE | (width << 8) |
+				(CFG_SPI_ENABLE << 14);
+			dev_dbg(&drv_data->pdev->dev, 
+				"IO write: cr is 0x%x\n", cr);
 
 			write_CTRL(cr);
 			SSYNC();
@@ -834,11 +842,11 @@ static void pump_transfers(unsigned long data)
 				tranf_success = 0;
 		} else if (drv_data->rx != NULL) {
 			/* read only half duplex */
-			cr = (read_CTRL() & (~BIT_CTL_TIMOD));	/* cleare the TIMOD bits */
-			cr |=
-			    CFG_SPI_READ | (width << 8) | (CFG_SPI_ENABLE <<
-							   14);
-			pr_debug("IO read: cr is 0x%x\n", cr);
+			cr = (read_CTRL() & (~BIT_CTL_TIMOD));
+			cr |= CFG_SPI_READ | (width << 8) |
+				(CFG_SPI_ENABLE << 14);
+			dev_dbg(&drv_data->pdev->dev, 
+				"IO read: cr is 0x%x\n", cr);
 
 			write_CTRL(cr);
 			SSYNC();
@@ -849,7 +857,8 @@ static void pump_transfers(unsigned long data)
 		}
 
 		if (!tranf_success) {
-			pr_debug("IO write error!\n");
+			dev_dbg(&drv_data->pdev->dev, 
+				"IO write error!\n");
 			message->state = ERROR_STATE;
 		} else {
 			/* Update total byte transfered */
@@ -899,11 +908,14 @@ static void pump_messages(struct work_struct *work)
 	/* Setup the SSP using the per chip configuration */
 	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
 	restore_state(drv_data);
-	pr_debug
-	    ("got a message to pump, state is set to: baud %d, flag 0x%x, ctl 0x%x\n",
-	     drv_data->cur_chip->baud, drv_data->cur_chip->flag,
-	     drv_data->cur_chip->ctl_reg);
-	pr_debug("the first transfer len is %d\n", drv_data->cur_transfer->len);
+	dev_dbg(&drv_data->pdev->dev,
+		"got a message to pump, state is set to: baud %d, flag 0x%x, ctl 0x%x\n",
+   		drv_data->cur_chip->baud, drv_data->cur_chip->flag,
+   		drv_data->cur_chip->ctl_reg);
+	
+	dev_dbg(&drv_data->pdev->dev, 
+		"the first transfer len is %d\n",
+		drv_data->cur_transfer->len);
 
 	/* Mark as busy and launch transfers */
 	tasklet_schedule(&drv_data->pump_transfers);
@@ -932,7 +944,7 @@ static int transfer(struct spi_device *spi, struct spi_message *msg)
 	msg->status = -EINPROGRESS;
 	msg->state = START_STATE;
 
-	pr_debug("adding an msg in transfer() \n");
+	dev_dbg(&spi->dev, "adding an msg in transfer() \n");
 	list_add_tail(&msg->queue, &drv_data->queue);
 
 	if (drv_data->run == QUEUE_RUNNING && !drv_data->busy)
@@ -1002,13 +1014,13 @@ static int setup(struct spi_device *spi)
 	if (chip->enable_dma && !dma_requested) {
 		/* register dma irq handler */
 		if (request_dma(CH_SPI, "BF53x_SPI_DMA") < 0) {
-			pr_debug
-			    ("Unable to request BlackFin SPI DMA channel\n");
+			dev_dbg(&spi->dev,
+				"Unable to request BlackFin SPI DMA channel\n");
 			return -ENODEV;
 		}
 		if (set_dma_callback(CH_SPI, (void *)dma_irq_handler, drv_data)
 		    < 0) {
-			pr_debug("Unable to set dma callback\n");
+			dev_dbg(&spi->dev, "Unable to set dma callback\n");
 			return -EPERM;
 		}
 		dma_disable_irq(CH_SPI);
@@ -1054,9 +1066,9 @@ static int setup(struct spi_device *spi)
 		return -ENODEV;
 	}
 
-	pr_debug("setup spi chip %s, width is %d, dma is %d,",
+	dev_dbg(&spi->dev, "setup spi chip %s, width is %d, dma is %d,",
 			spi->modalias, chip->width, chip->enable_dma);
-	pr_debug("ctl_reg is 0x%x, flag_reg is 0x%x\n",
+	dev_dbg(&spi->dev, "ctl_reg is 0x%x, flag_reg is 0x%x\n",
 			chip->ctl_reg, chip->flag);
 
 	spi_set_ctldata(spi, chip);
@@ -1068,7 +1080,7 @@ static int setup(struct spi_device *spi)
  * callback for spi framework.
  * clean driver specific data
  */
-static void cleanup(const struct spi_device *spi)
+static void cleanup(struct spi_device *spi)
 {
 	struct chip_data *chip = spi_get_ctldata((struct spi_device *)spi);
 
@@ -1207,7 +1219,7 @@ static int __init bfin5xx_spi_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "problem registering spi master\n");
 		goto out_error_queue_alloc;
 	}
-	pr_debug("controller probe successfully\n");
+	dev_dbg(&pdev->dev, "controller probe successfully\n");
 	return status;
 
       out_error_queue_alloc:
@@ -1287,27 +1299,23 @@ static int bfin5xx_spi_resume(struct platform_device *pdev)
 #endif				/* CONFIG_PM */
 
 static struct platform_driver bfin5xx_spi_driver = {
-	.driver = {
-		   .name = "bfin-spi-master",
-		   .bus = &platform_bus_type,
-		   .owner = THIS_MODULE,
-		   },
-	.probe = bfin5xx_spi_probe,
-	.remove = __devexit_p(bfin5xx_spi_remove),
-	.suspend = bfin5xx_spi_suspend,
-	.resume = bfin5xx_spi_resume,
+	.driver 	= {
+		.name	= "bfin-spi-master",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= bfin5xx_spi_suspend,
+	.resume		= bfin5xx_spi_resume,
+	.remove		= __devexit_p(bfin5xx_spi_remove),
 };
 
 static int __init bfin5xx_spi_init(void)
 {
-	return platform_driver_register(&bfin5xx_spi_driver);
+	return platform_driver_probe(&bfin5xx_spi_driver, bfin5xx_spi_probe);
 }
-
 module_init(bfin5xx_spi_init);
 
 static void __exit bfin5xx_spi_exit(void)
 {
 	platform_driver_unregister(&bfin5xx_spi_driver);
 }
-
 module_exit(bfin5xx_spi_exit);
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 225d6b2..d04242a 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -168,6 +168,12 @@ static int spidev_message(struct spidev_data *spidev,
 			n--, k_tmp++, u_tmp++) {
 		k_tmp->len = u_tmp->len;
 
+		total += k_tmp->len;
+		if (total > bufsiz) {
+			status = -EMSGSIZE;
+			goto done;
+		}
+
 		if (u_tmp->rx_buf) {
 			k_tmp->rx_buf = buf;
 			if (!access_ok(VERIFY_WRITE, u_tmp->rx_buf, u_tmp->len))
@@ -179,12 +185,6 @@ static int spidev_message(struct spidev_data *spidev,
 					u_tmp->len))
 				goto done;
 		}
-
-		total += k_tmp->len;
-		if (total > bufsiz) {
-			status = -EMSGSIZE;
-			goto done;
-		}
 		buf += k_tmp->len;
 
 		k_tmp->cs_change = !!u_tmp->cs_change;
@@ -364,6 +364,7 @@ spidev_ioctl(struct inode *inode, struct file *filp,
 			break;
 		}
 		if (__copy_from_user(ioc, (void __user *)arg, tmp)) {
+			kfree(ioc);
 			retval = -EFAULT;
 			break;
 		}
diff --git a/drivers/usb/class/usblp.c b/drivers/usb/class/usblp.c
index 15e740e..7b1edfe 100644
--- a/drivers/usb/class/usblp.c
+++ b/drivers/usb/class/usblp.c
@@ -1003,7 +1003,7 @@ abort:
 				usblp->writebuf, usblp->writeurb->transfer_dma);
 		if (usblp->readbuf)
 			usb_buffer_free (usblp->dev, USBLP_BUF_SIZE,
-				usblp->readbuf, usblp->writeurb->transfer_dma);
+				usblp->readbuf, usblp->readurb->transfer_dma);
 		kfree(usblp->statusbuf);
 		kfree(usblp->device_id_string);
 		usb_free_urb(usblp->writeurb);
diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index bfb3731..2d4fd53 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -185,10 +185,12 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 		num_ep = USB_MAXENDPOINTS;
 	}
 
-	len = sizeof(struct usb_host_endpoint) * num_ep;
-	alt->endpoint = kzalloc(len, GFP_KERNEL);
-	if (!alt->endpoint)
-		return -ENOMEM;
+	if (num_ep > 0) {	/* Can't allocate 0 bytes */
+		len = sizeof(struct usb_host_endpoint) * num_ep;
+		alt->endpoint = kzalloc(len, GFP_KERNEL);
+		if (!alt->endpoint)
+			return -ENOMEM;
+	}
 
 	/* Parse all the endpoint descriptors */
 	n = 0;
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index b9f7f90..2619986 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -983,7 +983,10 @@ static int autosuspend_check(struct usb_device *udev)
 
 #else
 
-#define autosuspend_check(udev)		0
+static inline int autosuspend_check(struct usb_device *udev)
+{
+	return 0;
+}
 
 #endif	/* CONFIG_USB_SUSPEND */
 
@@ -1041,7 +1044,6 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 		if (status < 0)
 			goto done;
 	}
-	cancel_delayed_work(&udev->autosuspend);
 
 	/* Suspend all the interfaces and then udev itself */
 	if (udev->actconfig) {
@@ -1062,9 +1064,16 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 			usb_resume_interface(intf);
 		}
 
+		/* Try another autosuspend when the interfaces aren't busy */
+		if (udev->auto_pm)
+			autosuspend_check(udev);
+
 	/* If the suspend succeeded, propagate it up the tree */
-	} else if (parent)
-		usb_autosuspend_device(parent);
+	} else {
+		cancel_delayed_work(&udev->autosuspend);
+		if (parent)
+			usb_autosuspend_device(parent);
+	}
 
  done:
 	// dev_dbg(&udev->dev, "%s: status %d\n", __FUNCTION__, status);
@@ -1475,6 +1484,7 @@ int usb_external_resume_device(struct usb_device *udev)
 	usb_pm_lock(udev);
 	udev->auto_pm = 0;
 	status = usb_resume_both(udev);
+	udev->last_busy = jiffies;
 	usb_pm_unlock(udev);
 
 	/* Now that the device is awake, we can start trying to autosuspend
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 40cf882..e277258 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1018,8 +1018,8 @@ done:
 		atomic_dec (&urb->use_count);
 		if (urb->reject)
 			wake_up (&usb_kill_urb_queue);
-		usb_put_urb (urb);
 		usbmon_urb_submit_error(&hcd->self, urb, status);
+		usb_put_urb (urb);
 	}
 	return status;
 }
@@ -1175,10 +1175,6 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	struct urb		*urb;
 
 	hcd = bus_to_hcd(udev->bus);
-
-	WARN_ON (!HC_IS_RUNNING (hcd->state) && hcd->state != HC_STATE_HALT &&
-			udev->state != USB_STATE_NOTATTACHED);
-
 	local_irq_disable ();
 
 	/* ep is already gone from udev->ep_{in,out}[]; no more submits */
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f6b74a6..caaa46f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2201,14 +2201,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 				continue;
 			}
 
-			/* Use a short timeout the first time through,
-			 * so that recalcitrant full-speed devices with
-			 * 8- or 16-byte ep0-maxpackets won't slow things
-			 * down tremendously by NAKing the unexpectedly
-			 * early status stage.  Also, retry on all errors;
-			 * some devices are flakey.
-			 * 255 is for WUSB devices, we actually need to use 512.
-			 * WUSB1.0[4.8.1].
+			/* Retry on all errors; some devices are flakey.
+			 * 255 is for WUSB devices, we actually need to use
+			 * 512 (WUSB1.0[4.8.1]).
 			 */
 			for (j = 0; j < 3; ++j) {
 				buf->bMaxPacketSize0 = 0;
@@ -2216,7 +2211,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
 					USB_DT_DEVICE << 8, 0,
 					buf, GET_DESCRIPTOR_BUFSIZE,
-					(i ? USB_CTRL_GET_TIMEOUT : 1000));
+					USB_CTRL_GET_TIMEOUT);
 				switch (buf->bMaxPacketSize0) {
 				case 8: case 16: case 32: case 64: case 255:
 					if (buf->bDescriptorType ==
@@ -2426,10 +2421,10 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 	if (portchange & USB_PORT_STAT_C_CONNECTION) {
 		status = hub_port_debounce(hub, port1);
-		if (status < 0 && printk_ratelimit()) {
-			dev_err (hub_dev,
-				"connect-debounce failed, port %d disabled\n",
-				port1);
+		if (status < 0) {
+			if (printk_ratelimit())
+				dev_err (hub_dev, "connect-debounce failed, "
+						"port %d disabled\n", port1);
 			goto done;
 		}
 		portstatus = status;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index b743478..f9fed34 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -221,15 +221,10 @@ int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 
 	if ((ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
 			USB_ENDPOINT_XFER_INT) {
-		int interval;
-
-		if (usb_dev->speed == USB_SPEED_HIGH)
-			interval = 1 << min(15, ep->desc.bInterval - 1);
-		else
-			interval = ep->desc.bInterval;
 		pipe = (pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);
 		usb_fill_int_urb(urb, usb_dev, pipe, data, len,
-				usb_api_blocking_completion, NULL, interval);
+				usb_api_blocking_completion, NULL,
+				ep->desc.bInterval);
 	} else
 		usb_fill_bulk_urb(urb, usb_dev, pipe, data, len,
 				usb_api_blocking_completion, NULL);
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index e7c9823..be37c86 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -232,12 +232,15 @@ set_level(struct device *dev, struct device_attribute *attr,
 	int len = count;
 	char *cp;
 	int rc = 0;
+	int old_autosuspend_disabled, old_autoresume_disabled;
 
 	cp = memchr(buf, '\n', count);
 	if (cp)
 		len = cp - buf;
 
 	usb_lock_device(udev);
+	old_autosuspend_disabled = udev->autosuspend_disabled;
+	old_autoresume_disabled = udev->autoresume_disabled;
 
 	/* Setting the flags without calling usb_pm_lock is a subject to
 	 * races, but who cares...
@@ -263,6 +266,10 @@ set_level(struct device *dev, struct device_attribute *attr,
 	} else
 		rc = -EINVAL;
 
+	if (rc) {
+		udev->autosuspend_disabled = old_autosuspend_disabled;
+		udev->autoresume_disabled = old_autoresume_disabled;
+	}
 	usb_unlock_device(udev);
 	return (rc < 0 ? rc : count);
 }
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 18ddc5e..80627b6 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -205,7 +205,11 @@ struct device_type usb_device_type = {
 
 static int ksuspend_usb_init(void)
 {
-	ksuspend_usb_wq = create_singlethread_workqueue("ksuspend_usbd");
+	/* This workqueue is supposed to be both freezable and
+	 * singlethreaded.  Its job doesn't justify running on more
+	 * than one CPU.
+	 */
+	ksuspend_usb_wq = create_freezeable_workqueue("ksuspend_usbd");
 	if (!ksuspend_usb_wq)
 		return -ENOMEM;
 	return 0;
diff --git a/drivers/usb/gadget/fsl_usb2_udc.c b/drivers/usb/gadget/fsl_usb2_udc.c
index 157054e..3ca2b31 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.c
+++ b/drivers/usb/gadget/fsl_usb2_udc.c
@@ -228,13 +228,15 @@ static int dr_controller_setup(struct fsl_udc *udc)
 
 	/* Config PHY interface */
 	portctrl = fsl_readl(&dr_regs->portsc1);
-	portctrl &= ~PORTSCX_PHY_TYPE_SEL;
+	portctrl &= ~(PORTSCX_PHY_TYPE_SEL & PORTSCX_PORT_WIDTH);
 	switch (udc->phy_mode) {
 	case FSL_USB2_PHY_ULPI:
 		portctrl |= PORTSCX_PTS_ULPI;
 		break;
-	case FSL_USB2_PHY_UTMI:
 	case FSL_USB2_PHY_UTMI_WIDE:
+		portctrl |= PORTSCX_PTW_16BIT;
+		/* fall through */
+	case FSL_USB2_PHY_UTMI:
 		portctrl |= PORTSCX_PTS_UTMI;
 		break;
 	case FSL_USB2_PHY_SERIAL:
@@ -625,7 +627,7 @@ static void fsl_free_buffer(struct usb_ep *_ep, void *buf,
 	struct fsl_ep *ep;
 
 	if (!_ep)
-		return NULL;
+		return;
 
 	ep = container_of(_ep, struct fsl_ep, ep);
 
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index a524805..c7a7c59 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -193,6 +193,19 @@ static void mpc83xx_usb_setup(struct usb_hcd *hcd)
 	out_be32(non_ehci + FSL_SOC_USB_CTRL, 0x00000004);
 	out_be32(non_ehci + FSL_SOC_USB_SNOOP1, 0x0000001b);
 
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+	/*
+	 * Turn on cache snooping hardware, since some PowerPC platforms
+	 * wholly rely on hardware to deal with cache coherent
+	 */
+
+	/* Setup Snooping for all the 4GB space */
+	/* SNOOP1 starts from 0x0, size 2G */
+	out_be32(non_ehci + FSL_SOC_USB_SNOOP1, 0x0 | SNOOP_SIZE_2GB);
+	/* SNOOP2 starts from 0x80000000, size 2G */
+	out_be32(non_ehci + FSL_SOC_USB_SNOOP2, 0x80000000 | SNOOP_SIZE_2GB);
+#endif
+
 	if (pdata->operating_mode == FSL_USB2_DR_HOST)
 		mpc83xx_setup_phy(ehci, pdata->phy_mode, 0);
 
diff --git a/drivers/usb/host/ehci-fsl.h b/drivers/usb/host/ehci-fsl.h
index f28736a..b5e59db 100644
--- a/drivers/usb/host/ehci-fsl.h
+++ b/drivers/usb/host/ehci-fsl.h
@@ -34,4 +34,5 @@
 #define FSL_SOC_USB_PRICTRL	0x40c	/* NOTE: big-endian */
 #define FSL_SOC_USB_SICTRL	0x410	/* NOTE: big-endian */
 #define FSL_SOC_USB_CTRL	0x500	/* NOTE: big-endian */
+#define SNOOP_SIZE_2GB		0x1e
 #endif				/* _EHCI_FSL_H */
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 7970560..ca62cb5 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -137,7 +137,7 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		/* Toshiba portege 4000 */
 		.vendor		= PCI_VENDOR_ID_AL,
 		.device		= 0x5237,
-		.subvendor	= PCI_VENDOR_ID_TOSHIBA_2,
+		.subvendor	= PCI_VENDOR_ID_TOSHIBA,
 		.subdevice	= 0x0004,
 		.driver_data	= (unsigned long) broken_suspend,
 	},
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 2086165..c225159 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -44,6 +44,7 @@
 #define EHCI_USBSTS		4		/* status register */
 #define EHCI_USBSTS_HALTED	(1 << 12)	/* HCHalted bit */
 #define EHCI_USBINTR		8		/* interrupt register */
+#define EHCI_CONFIGFLAG		0x40		/* configured flag register */
 #define EHCI_USBLEGSUP		0		/* legacy support register */
 #define EHCI_USBLEGSUP_BIOS	(1 << 16)	/* BIOS semaphore */
 #define EHCI_USBLEGSUP_OS	(1 << 24)	/* OS semaphore */
@@ -216,6 +217,7 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 	u32	hcc_params, val;
 	u8	offset, cap_length;
 	int	count = 256/4;
+	int	tried_handoff = 0;
 
 	if (!mmio_resource_enabled(pdev, 0))
 		return;
@@ -273,6 +275,7 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 			 */
 			msec = 5000;
 			while ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {
+				tried_handoff = 1;
 				msleep(10);
 				msec -= 10;
 				pci_read_config_dword(pdev, offset, &cap);
@@ -292,6 +295,12 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 			pci_write_config_dword(pdev,
 					offset + EHCI_USBLEGCTLSTS,
 					0);
+
+			/* If the BIOS ever owned the controller then we
+			 * can't expect any power sessions to remain intact.
+			 */
+			if (tried_handoff)
+				writel(0, op_reg_base + EHCI_CONFIGFLAG);
 			break;
 		case 0:			/* illegal reserved capability */
 			cap = 0;
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index ff0dba0..e98df2e 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -57,6 +57,13 @@
 #include <asm/system.h>
 #include <asm/byteorder.h>
 #include "../core/hcd.h"
+
+	/* FIXME ohci.h is ONLY for internal use by the OHCI driver.
+	 * If you're going to try stuff like this, you need to split
+	 * out shareable stuff (register declarations?) into its own
+	 * file, maybe name <linux/usb/ohci.h>
+	 */
+
 #include "ohci.h"
 #define OHCI_CONTROL_INIT OHCI_CTRL_CBSR
 #define OHCI_INTR_INIT (OHCI_INTR_MIE | OHCI_INTR_UE | OHCI_INTR_RD | \
@@ -173,11 +180,6 @@ struct u132_ring {
         struct u132_endp *curr_endp;
         struct delayed_work scheduler;
 };
-#define OHCI_QUIRK_AMD756 0x01
-#define OHCI_QUIRK_SUPERIO 0x02
-#define OHCI_QUIRK_INITRESET 0x04
-#define OHCI_BIG_ENDIAN 0x08
-#define OHCI_QUIRK_ZFMICRO 0x10
 struct u132 {
         struct kref kref;
         struct list_head u132_list;
diff --git a/drivers/usb/misc/auerswald.c b/drivers/usb/misc/auerswald.c
index 88fb56d..cac1500 100644
--- a/drivers/usb/misc/auerswald.c
+++ b/drivers/usb/misc/auerswald.c
@@ -1822,16 +1822,10 @@ static int auerchar_release (struct inode *inode, struct file *file)
 	pauerswald_t cp;
 	dbg("release");
 
-	/* get the mutexes */
-	if (down_interruptible (&ccp->mutex)) {
-		return -ERESTARTSYS;
-	}
+	down(&ccp->mutex);
 	cp = ccp->auerdev;
 	if (cp) {
-		if (down_interruptible (&cp->mutex)) {
-			up (&ccp->mutex);
-			return -ERESTARTSYS;
-		}
+		down(&cp->mutex);
 		/* remove an open service */
 		auerswald_removeservice (cp, &ccp->scontext);
 		/* detach from device */
diff --git a/drivers/usb/misc/ftdi-elan.c b/drivers/usb/misc/ftdi-elan.c
index e2172e5..e0f122e 100644
--- a/drivers/usb/misc/ftdi-elan.c
+++ b/drivers/usb/misc/ftdi-elan.c
@@ -73,6 +73,13 @@ static struct list_head ftdi_static_list;
 #include "usb_u132.h"
 #include <asm/io.h>
 #include "../core/hcd.h"
+
+	/* FIXME ohci.h is ONLY for internal use by the OHCI driver.
+	 * If you're going to try stuff like this, you need to split
+	 * out shareable stuff (register declarations?) into its own
+	 * file, maybe name <linux/usb/ohci.h>
+	 */
+
 #include "../host/ohci.h"
 /* Define these values to match your devices*/
 #define USB_FTDI_ELAN_VENDOR_ID 0x0403
@@ -2300,10 +2307,7 @@ static int ftdi_elan_checkingPCI(struct usb_ftdi *ftdi)
         offsetof(struct ohci_regs, member), 0, data);
 #define ftdi_write_pcimem(ftdi, member, data) ftdi_elan_write_pcimem(ftdi, \
         offsetof(struct ohci_regs, member), 0, data);
-#define OHCI_QUIRK_AMD756 0x01
-#define OHCI_QUIRK_SUPERIO 0x02
-#define OHCI_QUIRK_INITRESET 0x04
-#define OHCI_BIG_ENDIAN 0x08
+
 #define OHCI_CONTROL_INIT OHCI_CTRL_CBSR
 #define OHCI_INTR_INIT (OHCI_INTR_MIE | OHCI_INTR_UE | OHCI_INTR_RD | \
         OHCI_INTR_WDH)
diff --git a/drivers/usb/misc/ldusb.c b/drivers/usb/misc/ldusb.c
index 11555bd..7bad494 100644
--- a/drivers/usb/misc/ldusb.c
+++ b/drivers/usb/misc/ldusb.c
@@ -165,6 +165,8 @@ struct ld_usb {
 	size_t			interrupt_in_endpoint_size;
 	int			interrupt_in_running;
 	int			interrupt_in_done;
+	int			buffer_overflow;
+	spinlock_t		rbsl;
 
 	char*			interrupt_out_buffer;
 	struct usb_endpoint_descriptor* interrupt_out_endpoint;
@@ -230,10 +232,12 @@ static void ld_usb_interrupt_in_callback(struct urb *urb)
 		} else {
 			dbg_info(&dev->intf->dev, "%s: nonzero status received: %d\n",
 				 __FUNCTION__, urb->status);
+			spin_lock(&dev->rbsl);
 			goto resubmit; /* maybe we can recover */
 		}
 	}
 
+	spin_lock(&dev->rbsl);
 	if (urb->actual_length > 0) {
 		next_ring_head = (dev->ring_head+1) % ring_buffer_size;
 		if (next_ring_head != dev->ring_tail) {
@@ -244,21 +248,25 @@ static void ld_usb_interrupt_in_callback(struct urb *urb)
 			dev->ring_head = next_ring_head;
 			dbg_info(&dev->intf->dev, "%s: received %d bytes\n",
 				 __FUNCTION__, urb->actual_length);
-		} else
+		} else {
 			dev_warn(&dev->intf->dev,
 				 "Ring buffer overflow, %d bytes dropped\n",
 				 urb->actual_length);
+			dev->buffer_overflow = 1;
+		}
 	}
 
 resubmit:
 	/* resubmit if we're still running */
-	if (dev->interrupt_in_running && dev->intf) {
+	if (dev->interrupt_in_running && !dev->buffer_overflow && dev->intf) {
 		retval = usb_submit_urb(dev->interrupt_in_urb, GFP_ATOMIC);
-		if (retval)
+		if (retval) {
 			dev_err(&dev->intf->dev,
 				"usb_submit_urb failed (%d)\n", retval);
+			dev->buffer_overflow = 1;
+		}
 	}
-
+	spin_unlock(&dev->rbsl);
 exit:
 	dev->interrupt_in_done = 1;
 	wake_up_interruptible(&dev->read_wait);
@@ -330,6 +338,7 @@ static int ld_usb_open(struct inode *inode, struct file *file)
 	/* initialize in direction */
 	dev->ring_head = 0;
 	dev->ring_tail = 0;
+	dev->buffer_overflow = 0;
 	usb_fill_int_urb(dev->interrupt_in_urb,
 			 interface_to_usbdev(interface),
 			 usb_rcvintpipe(interface_to_usbdev(interface),
@@ -439,6 +448,7 @@ static ssize_t ld_usb_read(struct file *file, char __user *buffer, size_t count,
 	size_t *actual_buffer;
 	size_t bytes_to_read;
 	int retval = 0;
+	int rv;
 
 	dev = file->private_data;
 
@@ -460,7 +470,10 @@ static ssize_t ld_usb_read(struct file *file, char __user *buffer, size_t count,
 	}
 
 	/* wait for data */
+	spin_lock_irq(&dev->rbsl);
 	if (dev->ring_head == dev->ring_tail) {
+		dev->interrupt_in_done = 0;
+		spin_unlock_irq(&dev->rbsl);
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
 			goto unlock_exit;
@@ -468,6 +481,8 @@ static ssize_t ld_usb_read(struct file *file, char __user *buffer, size_t count,
 		retval = wait_event_interruptible(dev->read_wait, dev->interrupt_in_done);
 		if (retval < 0)
 			goto unlock_exit;
+	} else {
+		spin_unlock_irq(&dev->rbsl);
 	}
 
 	/* actual_buffer contains actual_length + interrupt_in_buffer */
@@ -486,6 +501,17 @@ static ssize_t ld_usb_read(struct file *file, char __user *buffer, size_t count,
 
 	retval = bytes_to_read;
 
+	spin_lock_irq(&dev->rbsl);
+	if (dev->buffer_overflow) {
+		dev->buffer_overflow = 0;
+		spin_unlock_irq(&dev->rbsl);
+		rv = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);
+		if (rv < 0)
+			dev->buffer_overflow = 1;
+	} else {
+		spin_unlock_irq(&dev->rbsl);
+	}
+
 unlock_exit:
 	/* unlock the device */
 	up(&dev->sem);
@@ -635,6 +661,7 @@ static int ld_usb_probe(struct usb_interface *intf, const struct usb_device_id *
 		goto exit;
 	}
 	init_MUTEX(&dev->sem);
+	spin_lock_init(&dev->rbsl);
 	dev->intf = intf;
 	init_waitqueue_head(&dev->read_wait);
 	init_waitqueue_head(&dev->write_wait);
diff --git a/drivers/usb/serial/ark3116.c b/drivers/usb/serial/ark3116.c
index ea2175b..fe43712 100644
--- a/drivers/usb/serial/ark3116.c
+++ b/drivers/usb/serial/ark3116.c
@@ -63,7 +63,8 @@ static inline void ARK3116_RCV(struct usb_serial *serial, int seq,
 				 request, requesttype, value, index,
 				 buf, 0x0000001, 1000);
 	if (result)
-		dbg("%03d < %d bytes [0x%02X]", seq, result, buf[0]);
+		dbg("%03d < %d bytes [0x%02X]", seq, result,
+		    ((unsigned char *)buf)[0]);
 	else
 		dbg("%03d < 0 bytes", seq);
 }
diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
index 95a1805..2353679 100644
--- a/drivers/usb/serial/ftdi_sio.c
+++ b/drivers/usb/serial/ftdi_sio.c
@@ -273,12 +273,18 @@ static __u16 product;
 
 /* struct ftdi_sio_quirk is used by devices requiring special attention. */
 struct ftdi_sio_quirk {
+	int (*probe)(struct usb_serial *);
 	void (*setup)(struct usb_serial *); /* Special settings during startup. */
 };
 
+static int   ftdi_olimex_probe		(struct usb_serial *serial);
 static void  ftdi_USB_UIRT_setup	(struct usb_serial *serial);
 static void  ftdi_HE_TIRA1_setup	(struct usb_serial *serial);
 
+static struct ftdi_sio_quirk ftdi_olimex_quirk = {
+	.probe	= ftdi_olimex_probe,
+};
+
 static struct ftdi_sio_quirk ftdi_USB_UIRT_quirk = {
 	.setup = ftdi_USB_UIRT_setup,
 };
@@ -319,6 +325,7 @@ static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_8U2232C_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_MICRO_CHAMELEON_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_RELAIS_PID) },
+	{ USB_DEVICE(FTDI_VID, FTDI_OPENDCC_PID) },
 	{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_IOBOARD_PID) },
 	{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_MINI_IOBOARD_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_XF_632_PID) },
@@ -525,6 +532,9 @@ static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_TACTRIX_OPENPORT_13U_PID) },
 	{ USB_DEVICE(ELEKTOR_VID, ELEKTOR_FT323R_PID) },
 	{ USB_DEVICE(TELLDUS_VID, TELLDUS_TELLSTICK_PID) },
+	{ USB_DEVICE(FTDI_VID, FTDI_MAXSTREAM_PID) },
+	{ USB_DEVICE(OLIMEX_VID, OLIMEX_ARM_USB_OCD_PID),
+		.driver_info = (kernel_ulong_t)&ftdi_olimex_quirk },
 	{ },					/* Optional parameter entry */
 	{ }					/* Terminating entry */
 };
@@ -669,7 +679,7 @@ static struct usb_serial_driver ftdi_sio_device = {
 
 /*
  * ***************************************************************************
- * Utlity functions
+ * Utility functions
  * ***************************************************************************
  */
 
@@ -1171,9 +1181,17 @@ static void remove_sysfs_attrs(struct usb_serial_port *port)
 /* Probe function to check for special devices */
 static int ftdi_sio_probe (struct usb_serial *serial, const struct usb_device_id *id)
 {
+	struct ftdi_sio_quirk *quirk = (struct ftdi_sio_quirk *)id->driver_info;
+
+	if (quirk && quirk->probe) {
+		int ret = quirk->probe(serial);
+		if (ret != 0)
+			return ret;
+	}
+
 	usb_set_serial_data(serial, (void *)id->driver_info);
 
-	return (0);
+	return 0;
 }
 
 static int ftdi_sio_port_probe(struct usb_serial_port *port)
@@ -1268,6 +1286,24 @@ static void ftdi_HE_TIRA1_setup (struct usb_serial *serial)
 	priv->force_rtscts = 1;
 } /* ftdi_HE_TIRA1_setup */
 
+/*
+ * First port on Olimex arm-usb-ocd is reserved for JTAG interface
+ * and can be accessed from userspace using openocd.
+ */
+static int ftdi_olimex_probe(struct usb_serial *serial)
+{
+	struct usb_device *udev = serial->dev;
+	struct usb_interface *interface = serial->interface;
+
+	dbg("%s",__FUNCTION__);
+
+	if (interface == udev->actconfig->interface[0]) {
+		info("Ignoring reserved serial port on Olimex arm-usb-ocd\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
 
 /* ftdi_shutdown is called from usbserial:usb_serial_disconnect
  *   it is called when the usb device is disconnected
diff --git a/drivers/usb/serial/ftdi_sio.h b/drivers/usb/serial/ftdi_sio.h
index 77ad0a0..33aee90 100644
--- a/drivers/usb/serial/ftdi_sio.h
+++ b/drivers/usb/serial/ftdi_sio.h
@@ -60,6 +60,9 @@
 /* DMX4ALL DMX Interfaces */
 #define FTDI_DMX4ALL 0xC850
 
+/* OpenDCC (www.opendcc.de) product id */
+#define FTDI_OPENDCC_PID	0xBFD8
+
 /* www.crystalfontz.com devices - thanx for providing free devices for evaluation ! */
 /* they use the ftdi chipset for the USB interface and the vendor id is the same */
 #define FTDI_XF_632_PID 0xFC08	/* 632: 16x2 Character Display */
@@ -518,6 +521,15 @@
 #define FTDI_IBS_PEDO_PID	0xff3e  /* IBS PEDO-Modem (RF modem 868.35 MHz) */
 #define FTDI_IBS_PROD_PID	0xff3f  /* future device */
 
+/*
+ *  MaxStream devices	www.maxstream.net
+ */
+#define FTDI_MAXSTREAM_PID	0xEE18	/* Xbee PKG-U Module */
+
+/* Olimex */
+#define OLIMEX_VID			0x15BA
+#define OLIMEX_ARM_USB_OCD_PID		0x0003
+
 /* Commands */
 #define FTDI_SIO_RESET 		0 /* Reset the port */
 #define FTDI_SIO_MODEM_CTRL 	1 /* Set the modem control register */
diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c
index 2366e7b..36620c6 100644
--- a/drivers/usb/serial/mos7840.c
+++ b/drivers/usb/serial/mos7840.c
@@ -769,11 +769,6 @@ static void mos7840_bulk_out_data_callback(struct urb *urb)
 		return;
 	}
 
-	if (!mos7840_port) {
-		dbg("%s", "NULL mos7840_port pointer \n");
-		return;
-	}
-
 	if (mos7840_port_paranoia_check(mos7840_port->port, __FUNCTION__)) {
 		dbg("%s", "Port Paranoia failed \n");
 		return;
diff --git a/drivers/usb/serial/omninet.c b/drivers/usb/serial/omninet.c
index 4adfab9..00afc17 100644
--- a/drivers/usb/serial/omninet.c
+++ b/drivers/usb/serial/omninet.c
@@ -165,12 +165,10 @@ static int omninet_open (struct usb_serial_port *port, struct file *filp)
 {
 	struct usb_serial	*serial = port->serial;
 	struct usb_serial_port	*wport;
-	struct omninet_data	*od = usb_get_serial_port_data(port);
 	int			result = 0;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	od = kmalloc( sizeof(struct omninet_data), GFP_KERNEL );
 	wport = serial->port[1];
 	wport->tty = port->tty;
 
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 8c3f55b..89f067d 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -165,7 +165,6 @@ static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1410) }, /* Novatel U740 */
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1420) }, /* Novatel EU870 */
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1430) }, /* Novatel Merlin XU870 HSDPA/3G */
-	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x1430) }, /* Novatel XU870 */
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x2100) }, /* Novatel EV620 CDMA/EV-DO */
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x2110) }, /* Novatel Merlin ES620 / Merlin ES720 / Ovation U720 */
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, 0x2130) }, /* Novatel Merlin ES620 SM Bus */
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index 644607d..ac1829c 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -35,6 +35,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(0x1199, 0x0218) },	/* Sierra Wireless MC5720 */
 	{ USB_DEVICE(0x1199, 0x0020) },	/* Sierra Wireless MC5725 */
 	{ USB_DEVICE(0x1199, 0x0019) },	/* Sierra Wireless AirCard 595 */
+	{ USB_DEVICE(0x1199, 0x0120) },	/* Sierra Wireless AirCard 595U */
 	{ USB_DEVICE(0x1199, 0x0021) },	/* Sierra Wireless AirCard 597E */
 	{ USB_DEVICE(0x1199, 0x6802) },	/* Sierra Wireless MC8755 */
 	{ USB_DEVICE(0x1199, 0x6804) },	/* Sierra Wireless MC8755 */
@@ -60,6 +61,7 @@ static struct usb_device_id id_table_3port [] = {
 	{ USB_DEVICE(0x1199, 0x0218) },	/* Sierra Wireless MC5720 */
 	{ USB_DEVICE(0x1199, 0x0020) },	/* Sierra Wireless MC5725 */
 	{ USB_DEVICE(0x1199, 0x0019) },	/* Sierra Wireless AirCard 595 */
+	{ USB_DEVICE(0x1199, 0x0120) },	/* Sierra Wireless AirCard 595U */
 	{ USB_DEVICE(0x1199, 0x0021) },	/* Sierra Wireless AirCard 597E */
 	{ USB_DEVICE(0x1199, 0x6802) },	/* Sierra Wireless MC8755 */
 	{ USB_DEVICE(0x1199, 0x6804) },	/* Sierra Wireless MC8755 */
diff --git a/drivers/usb/storage/onetouch.c b/drivers/usb/storage/onetouch.c
index 6d3dad3..d353693 100644
--- a/drivers/usb/storage/onetouch.c
+++ b/drivers/usb/storage/onetouch.c
@@ -84,7 +84,7 @@ resubmit:
 
 static int usb_onetouch_open(struct input_dev *dev)
 {
-	struct usb_onetouch *onetouch = dev->private;
+	struct usb_onetouch *onetouch = input_get_drvdata(dev);
 
 	onetouch->is_open = 1;
 	onetouch->irq->dev = onetouch->udev;
@@ -98,7 +98,7 @@ static int usb_onetouch_open(struct input_dev *dev)
 
 static void usb_onetouch_close(struct input_dev *dev)
 {
-	struct usb_onetouch *onetouch = dev->private;
+	struct usb_onetouch *onetouch = input_get_drvdata(dev);
 
 	usb_kill_urb(onetouch->irq);
 	onetouch->is_open = 0;
@@ -185,13 +185,14 @@ int onetouch_connect_input(struct us_data *ss)
 	input_dev->name = onetouch->name;
 	input_dev->phys = onetouch->phys;
 	usb_to_input_id(udev, &input_dev->id);
-	input_dev->cdev.dev = &udev->dev;
+	input_dev->dev.parent = &udev->dev;
 
 	set_bit(EV_KEY, input_dev->evbit);
 	set_bit(ONETOUCH_BUTTON, input_dev->keybit);
 	clear_bit(0, input_dev->keybit);
 
-	input_dev->private = onetouch;
+	input_set_drvdata(input_dev, onetouch);
+
 	input_dev->open = usb_onetouch_open;
 	input_dev->close = usb_onetouch_close;
 
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 8b3145a..d230ee7 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1179,14 +1179,20 @@ UNUSUAL_DEV( 0x0a17, 0x006, 0x0000, 0xffff,
                 US_SC_DEVICE, US_PR_DEVICE, NULL,
                 US_FL_FIX_INQUIRY ),
 
-/* This is a virtual windows driver CD, which the zd1211rw driver automatically
- * converts into a WLAN device. */
+/* These are virtual windows driver CDs, which the zd1211rw driver automatically
+ * converts into a WLAN devices. */
 UNUSUAL_DEV( 0x0ace, 0x2011, 0x0101, 0x0101,
                 "ZyXEL",
                 "G-220F USB-WLAN Install",
                 US_SC_DEVICE, US_PR_DEVICE, NULL,
                 US_FL_IGNORE_DEVICE ),
 
+UNUSUAL_DEV( 0x0ace, 0x20ff, 0x0101, 0x0101,
+		"SiteCom",
+		"WL-117 USB-WLAN Install",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_IGNORE_DEVICE ),
+
 #ifdef CONFIG_USB_STORAGE_ISD200
 UNUSUAL_DEV(  0x0bf6, 0xa001, 0x0100, 0x0110,
 		"ATI",
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 4d7485f..6e1f1ea 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -704,6 +704,91 @@ config FB_CG6
 	  This is the frame buffer device driver for the CGsix (GX, TurboGX)
 	  frame buffer.
 
+config FB_FFB
+	bool "Creator/Creator3D/Elite3D support"
+	depends on FB_SBUS && SPARC64
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the frame buffer device driver for the Creator, Creator3D,
+	  and Elite3D graphics boards.
+
+config FB_TCX
+	bool "TCX (SS4/SS5 only) support"
+	depends on FB_SBUS
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the frame buffer device driver for the TCX 24/8bit frame
+	  buffer.
+
+config FB_CG14
+	bool "CGfourteen (SX) support"
+	depends on FB_SBUS
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the frame buffer device driver for the CGfourteen frame
+	  buffer on Desktop SPARCsystems with the SX graphics option.
+
+config FB_P9100
+	bool "P9100 (Sparcbook 3 only) support"
+	depends on FB_SBUS
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the frame buffer device driver for the P9100 card
+	  supported on Sparcbook 3 machines.
+
+config FB_LEO
+	bool "Leo (ZX) support"
+	depends on FB_SBUS
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the frame buffer device driver for the SBUS-based Sun ZX
+	  (leo) frame buffer cards.
+
+config FB_IGA
+	bool "IGA 168x display support"
+	depends on FB && SPARC32
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the framebuffer device for the INTERGRAPHICS 1680 and
+	  successor frame buffer cards.
+
+config FB_XVR500
+	bool "Sun XVR-500 3DLABS Wildcat support"
+	depends on FB && PCI && SPARC64
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the framebuffer device for the Sun XVR-500 and similar
+	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
+	  only works on sparc64 systems where the system firwmare has
+	  mostly initialized the card already.  It is treated as a
+	  completely dumb framebuffer device.
+
+config FB_XVR2500
+	bool "Sun XVR-2500 3DLABS Wildcat support"
+	depends on FB && PCI && SPARC64
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This is the framebuffer device for the Sun XVR-2500 and similar
+	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
+	  only works on sparc64 systems where the system firwmare has
+	  mostly initialized the card already.  It is treated as a
+	  completely dumb framebuffer device.
+
 config FB_PVR2
 	tristate "NEC PowerVR 2 display support"
 	depends on FB && SH_DREAMCAST
@@ -1195,7 +1280,7 @@ config FB_ATY
 config FB_ATY_CT
 	bool "Mach64 CT/VT/GT/LT (incl. 3D RAGE) support"
 	depends on PCI && FB_ATY
-	default y if SPARC64 && FB_PCI
+	default y if SPARC64 && PCI
 	help
 	  Say Y here to support use of ATI's 64-bit Rage boards (or other
 	  boards based on the Mach64 CT, VT, GT, and LT chipsets) as a
@@ -1484,95 +1569,6 @@ config FB_AU1200
 
 source "drivers/video/geode/Kconfig"
 
-config FB_FFB
-	bool "Creator/Creator3D/Elite3D support"
-	depends on FB_SBUS && SPARC64
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the frame buffer device driver for the Creator, Creator3D,
-	  and Elite3D graphics boards.
-
-config FB_TCX
-	bool "TCX (SS4/SS5 only) support"
-	depends on FB_SBUS
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the frame buffer device driver for the TCX 24/8bit frame
-	  buffer.
-
-config FB_CG14
-	bool "CGfourteen (SX) support"
-	depends on FB_SBUS
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the frame buffer device driver for the CGfourteen frame
-	  buffer on Desktop SPARCsystems with the SX graphics option.
-
-config FB_P9100
-	bool "P9100 (Sparcbook 3 only) support"
-	depends on FB_SBUS
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the frame buffer device driver for the P9100 card
-	  supported on Sparcbook 3 machines.
-
-config FB_LEO
-	bool "Leo (ZX) support"
-	depends on FB_SBUS
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the frame buffer device driver for the SBUS-based Sun ZX
-	  (leo) frame buffer cards.
-
-config FB_XVR500
-	bool "Sun XVR-500 3DLABS Wildcat support"
-	depends on (FB = y) && PCI && SPARC64
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the framebuffer device for the Sun XVR-500 and similar
-	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
-	  only works on sparc64 systems where the system firwmare has
-	  mostly initialized the card already.  It is treated as a
-	  completely dumb framebuffer device.
-
-config FB_XVR2500
-	bool "Sun XVR-2500 3DLABS Wildcat support"
-	depends on (FB = y) && PCI && SPARC64
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the framebuffer device for the Sun XVR-2500 and similar
-	  graphics cards based upon the 3DLABS Wildcat chipset.  The driver
-	  only works on sparc64 systems where the system firwmare has
-	  mostly initialized the card already.  It is treated as a
-	  completely dumb framebuffer device.
-
-config FB_PCI
-	bool "PCI framebuffers"
-	depends on (FB = y) && PCI && SPARC
-
-config FB_IGA
-	bool "IGA 168x display support"
-	depends on SPARC32 && FB_PCI
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	help
-	  This is the framebuffer device for the INTERGRAPHICS 1680 and
-	  successor frame buffer cards.
-
 config FB_HIT
 	tristate "HD64461 Frame Buffer support"
 	depends on FB && HD64461
@@ -1796,9 +1792,10 @@ config FB_IBM_GXT4500
 config FB_PS3
 	bool "PS3 GPU framebuffer driver"
 	depends on (FB = y) && PS3_PS3AV
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
 	---help---
 	  Include support for the virtual frame buffer in the PS3 platform.
 
diff --git a/drivers/video/imxfb.c b/drivers/video/imxfb.c
index 267c1ff..a125898 100644
--- a/drivers/video/imxfb.c
+++ b/drivers/video/imxfb.c
@@ -394,26 +394,18 @@ static void imxfb_setup_gpio(struct imxfb_info *fbi)
 
 	/* initialize GPIOs */
 	imx_gpio_mode(PD6_PF_LSCLK);
-	imx_gpio_mode(PD10_PF_SPL_SPR);
 	imx_gpio_mode(PD11_PF_CONTRAST);
 	imx_gpio_mode(PD14_PF_FLM_VSYNC);
 	imx_gpio_mode(PD13_PF_LP_HSYNC);
-	imx_gpio_mode(PD7_PF_REV);
-	imx_gpio_mode(PD8_PF_CLS);
-
-#ifndef CONFIG_MACH_PIMX1
-	/* on PiMX1 used as buffers enable signal
-	 */
-	imx_gpio_mode(PD9_PF_PS);
-#endif
-
-#ifndef CONFIG_MACH_MX1FS2
-	/* on mx1fs2 this pin is used to (de)activate the display, so we need
-	 * it as a normal gpio
-	 */
 	imx_gpio_mode(PD12_PF_ACD_OE);
-#endif
 
+	/* These are only needed for Sharp HR TFT displays */
+	if (fbi->pcr & PCR_SHARP) {
+		imx_gpio_mode(PD7_PF_REV);
+		imx_gpio_mode(PD8_PF_CLS);
+		imx_gpio_mode(PD9_PF_PS);
+		imx_gpio_mode(PD10_PF_SPL_SPR);
+	}
 }
 
 #ifdef CONFIG_PM
@@ -476,7 +468,6 @@ static int __init imxfb_init_fbinfo(struct device *dev)
 
 	info->fbops			= &imxfb_ops;
 	info->flags			= FBINFO_FLAG_DEFAULT;
-	info->pseudo_palette		= (fbi + 1);
 
 	fbi->rgb[RGB_16]		= &def_rgb_16;
 	fbi->rgb[RGB_8]			= &def_rgb_8;
@@ -499,6 +490,7 @@ static int __init imxfb_init_fbinfo(struct device *dev)
 	info->var.sync			= inf->sync;
 	info->var.grayscale		= inf->cmap_greyscale;
 	fbi->cmap_inverse		= inf->cmap_inverse;
+	fbi->cmap_static		= inf->cmap_static;
 	fbi->pcr			= inf->pcr;
 	fbi->lscr1			= inf->lscr1;
 	fbi->dmacr			= inf->dmacr;
diff --git a/drivers/video/pm2fb.c b/drivers/video/pm2fb.c
index ab5e668..0a04483 100644
--- a/drivers/video/pm2fb.c
+++ b/drivers/video/pm2fb.c
@@ -183,15 +183,17 @@ static inline void pm2_RDAC_WR(struct pm2fb_par* p, s32 idx, u32 v)
 		index = PM2VR_RD_INDEXED_DATA;
 		break;
 	}	
-	mb();
+	wmb();
 	pm2_WR(p, index, v);
+	wmb();
 }
 
 static inline void pm2v_RDAC_WR(struct pm2fb_par* p, s32 idx, u32 v)
 {
 	pm2_WR(p, PM2VR_RD_INDEX_LOW, idx & 0xff);
-	mb();
+	wmb();
 	pm2_WR(p, PM2VR_RD_INDEXED_DATA, v);
+	wmb();
 }
 
 #ifdef CONFIG_FB_PM2_FIFO_DISCONNECT
@@ -466,11 +468,9 @@ static void set_memclock(struct pm2fb_par* par, u32 clk)
 		WAIT_FIFO(par, 8);
 		pm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_MCLK_CONTROL >> 8);
 		pm2v_RDAC_WR(par, PM2VI_RD_MCLK_CONTROL, 0);
-		wmb();
 		pm2v_RDAC_WR(par, PM2VI_RD_MCLK_PRESCALE, m);
 		pm2v_RDAC_WR(par, PM2VI_RD_MCLK_FEEDBACK, n);
 		pm2v_RDAC_WR(par, PM2VI_RD_MCLK_POSTSCALE, p);
-		wmb();
 		pm2v_RDAC_WR(par, PM2VI_RD_MCLK_CONTROL, 1);
 		rmb();
 		for (i = 256;
@@ -483,12 +483,9 @@ static void set_memclock(struct pm2fb_par* par, u32 clk)
 		pm2_mnp(clk, &m, &n, &p);
 		WAIT_FIFO(par, 10);
 		pm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_3, 6);
-		wmb();
 		pm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_1, m);
 		pm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_2, n);
-		wmb();
 		pm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_3, 8|p);
-		wmb();
 		pm2_RDAC_RD(par, PM2I_RD_MEMORY_CLOCK_STATUS);
 		rmb();
 		for (i = 256;
@@ -509,12 +506,9 @@ static void set_pixclock(struct pm2fb_par* par, u32 clk)
 		pm2_mnp(clk, &m, &n, &p);
 		WAIT_FIFO(par, 8);
 		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 0);
-		wmb();
 		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A1, m);
 		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A2, n);
-		wmb();
 		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 8|p);
-		wmb();
 		pm2_RDAC_RD(par, PM2I_RD_PIXEL_CLOCK_STATUS);
 		rmb();
 		for (i = 256;
@@ -1066,10 +1060,9 @@ static void pm2fb_block_op(struct fb_info* info, int copy,
 
 	if (!w || !h)
 		return;
-	WAIT_FIFO(par, 6);
+	WAIT_FIFO(par, 5);
 	pm2_WR(par, PM2R_CONFIG, PM2F_CONFIG_FB_WRITE_ENABLE |
 		PM2F_CONFIG_FB_READ_SOURCE_ENABLE);
-	pm2_WR(par, PM2R_FB_PIXEL_OFFSET, 0);
 	if (copy)
 		pm2_WR(par, PM2R_FB_SOURCE_DELTA,
 			((ysrc-y) & 0xfff) << 16 | ((xsrc-x) & 0xfff));
diff --git a/drivers/video/pm3fb.c b/drivers/video/pm3fb.c
index c77a1a1..616a0c0 100644
--- a/drivers/video/pm3fb.c
+++ b/drivers/video/pm3fb.c
@@ -52,11 +52,6 @@
 static char *mode_option __devinitdata;
 
 /*
- *  If your driver supports multiple boards, you should make the
- *  below data types arrays, or allocate them dynamically (using kmalloc()).
- */
-
-/*
  * This structure defines the hardware state of the graphics card. Normally
  * you place this in a header file in linux/include/video. This file usually
  * also includes register information. That allows other driver subsystems
@@ -67,7 +62,7 @@ struct pm3_par {
 	unsigned char	__iomem *v_regs;/* virtual address of p_regs */
 	u32		video;		/* video flags before blanking */
 	u32		base;		/* screen base (xoffset+yoffset) in 128 bits unit */
-	u32 		palette[16];
+	u32		palette[16];
 };
 
 /*
@@ -104,36 +99,28 @@ static inline void PM3_WAIT(struct pm3_par *par, u32 n)
 	while (PM3_READ_REG(par, PM3InFIFOSpace) < n);
 }
 
-static inline void PM3_SLOW_WRITE_REG(struct pm3_par *par, s32 off, u32 v)
-{
-	if (par->v_regs) {
-		mb();
-		PM3_WAIT(par, 1);
-		wmb();
-		PM3_WRITE_REG(par, off, v);
-	}
-}
-
-static inline void PM3_SET_INDEX(struct pm3_par *par, unsigned index)
-{
-	PM3_SLOW_WRITE_REG(par, PM3RD_IndexHigh, (index >> 8) & 0xff);
-	PM3_SLOW_WRITE_REG(par, PM3RD_IndexLow, index & 0xff);
-}
-
 static inline void PM3_WRITE_DAC_REG(struct pm3_par *par, unsigned r, u8 v)
 {
-	PM3_SET_INDEX(par, r);
+	PM3_WAIT(par, 3);
+	PM3_WRITE_REG(par, PM3RD_IndexHigh, (r >> 8) & 0xff);
+	PM3_WRITE_REG(par, PM3RD_IndexLow, r & 0xff);
 	wmb();
 	PM3_WRITE_REG(par, PM3RD_IndexedData, v);
+	wmb();
 }
 
 static inline void pm3fb_set_color(struct pm3_par *par, unsigned char regno,
 			unsigned char r, unsigned char g, unsigned char b)
 {
-	PM3_SLOW_WRITE_REG(par, PM3RD_PaletteWriteAddress, regno);
-	PM3_SLOW_WRITE_REG(par, PM3RD_PaletteData, r);
-	PM3_SLOW_WRITE_REG(par, PM3RD_PaletteData, g);
-	PM3_SLOW_WRITE_REG(par, PM3RD_PaletteData, b);
+	PM3_WAIT(par, 4);
+	PM3_WRITE_REG(par, PM3RD_PaletteWriteAddress, regno);
+	wmb();
+	PM3_WRITE_REG(par, PM3RD_PaletteData, r);
+	wmb();
+	PM3_WRITE_REG(par, PM3RD_PaletteData, g);
+	wmb();
+	PM3_WRITE_REG(par, PM3RD_PaletteData, b);
+	wmb();
 }
 
 static void pm3fb_clear_colormap(struct pm3_par *par,
@@ -141,7 +128,7 @@ static void pm3fb_clear_colormap(struct pm3_par *par,
 {
 	int i;
 
-	for (i = 0; i < 256 ; i++) /* fill color map with white */
+	for (i = 0; i < 256 ; i++)
 		pm3fb_set_color(par, i, r, g, b);
 
 }
@@ -175,19 +162,26 @@ static void pm3fb_calculate_clock(unsigned long reqclock,
 	}
 }
 
-static inline int pm3fb_shift_bpp(unsigned long depth, int v)
+static inline int pm3fb_depth(const struct fb_var_screeninfo *var)
 {
-	switch (depth) {
+	if ( var->bits_per_pixel == 16 )
+		return var->red.length + var->green.length
+			+ var->blue.length;
+
+	return var->bits_per_pixel;
+}
+
+static inline int pm3fb_shift_bpp(unsigned bpp, int v)
+{
+	switch (bpp) {
 	case 8:
 		return (v >> 4);
-	case 12:
-	case 15:
 	case 16:
 		return (v >> 3);
 	case 32:
 		return (v >> 2);
 	}
-	DPRINTK("Unsupported depth %ld\n", depth);
+	DPRINTK("Unsupported depth %u\n", bpp);
 	return 0;
 }
 
@@ -206,56 +200,50 @@ static void pm3fb_write_mode(struct fb_info *info)
 	const u32 vbend = vsend + info->var.upper_margin;
 	const u32 vtotal = info->var.yres + vbend;
 	const u32 width = (info->var.xres_virtual + 7) & ~7;
-
-	PM3_SLOW_WRITE_REG(par, PM3MemBypassWriteMask, 0xffffffff);
-	PM3_SLOW_WRITE_REG(par, PM3Aperture0, 0x00000000);
-	PM3_SLOW_WRITE_REG(par, PM3Aperture1, 0x00000000);
-	PM3_SLOW_WRITE_REG(par, PM3FIFODis, 0x00000007);
-
-	PM3_SLOW_WRITE_REG(par, PM3HTotal,
-			   pm3fb_shift_bpp(info->var.bits_per_pixel,
-					  htotal - 1));
-	PM3_SLOW_WRITE_REG(par, PM3HsEnd,
-			   pm3fb_shift_bpp(info->var.bits_per_pixel,
-					  hsend));
-	PM3_SLOW_WRITE_REG(par, PM3HsStart,
-			   pm3fb_shift_bpp(info->var.bits_per_pixel,
-					  hsstart));
-	PM3_SLOW_WRITE_REG(par, PM3HbEnd,
-			   pm3fb_shift_bpp(info->var.bits_per_pixel,
-					  hbend));
-	PM3_SLOW_WRITE_REG(par, PM3HgEnd,
-			   pm3fb_shift_bpp(info->var.bits_per_pixel,
-					  hbend));
-	PM3_SLOW_WRITE_REG(par, PM3ScreenStride,
-			   pm3fb_shift_bpp(info->var.bits_per_pixel,
-					  width));
-	PM3_SLOW_WRITE_REG(par, PM3VTotal, vtotal - 1);
-	PM3_SLOW_WRITE_REG(par, PM3VsEnd, vsend - 1);
-	PM3_SLOW_WRITE_REG(par, PM3VsStart, vsstart - 1);
-	PM3_SLOW_WRITE_REG(par, PM3VbEnd, vbend);
-
-	switch (info->var.bits_per_pixel) {
+	const unsigned bpp = info->var.bits_per_pixel;
+
+	PM3_WAIT(par, 20);
+	PM3_WRITE_REG(par, PM3MemBypassWriteMask, 0xffffffff);
+	PM3_WRITE_REG(par, PM3Aperture0, 0x00000000);
+	PM3_WRITE_REG(par, PM3Aperture1, 0x00000000);
+	PM3_WRITE_REG(par, PM3FIFODis, 0x00000007);
+
+	PM3_WRITE_REG(par, PM3HTotal,
+			   pm3fb_shift_bpp(bpp, htotal - 1));
+	PM3_WRITE_REG(par, PM3HsEnd,
+			   pm3fb_shift_bpp(bpp, hsend));
+	PM3_WRITE_REG(par, PM3HsStart,
+			   pm3fb_shift_bpp(bpp, hsstart));
+	PM3_WRITE_REG(par, PM3HbEnd,
+			   pm3fb_shift_bpp(bpp, hbend));
+	PM3_WRITE_REG(par, PM3HgEnd,
+			   pm3fb_shift_bpp(bpp, hbend));
+	PM3_WRITE_REG(par, PM3ScreenStride,
+			   pm3fb_shift_bpp(bpp, width));
+	PM3_WRITE_REG(par, PM3VTotal, vtotal - 1);
+	PM3_WRITE_REG(par, PM3VsEnd, vsend - 1);
+	PM3_WRITE_REG(par, PM3VsStart, vsstart - 1);
+	PM3_WRITE_REG(par, PM3VbEnd, vbend);
+
+	switch (bpp) {
 	case 8:
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture1Mode,
+		PM3_WRITE_REG(par, PM3ByAperture1Mode,
 				   PM3ByApertureMode_PIXELSIZE_8BIT);
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture2Mode,
+		PM3_WRITE_REG(par, PM3ByAperture2Mode,
 				   PM3ByApertureMode_PIXELSIZE_8BIT);
 		break;
 
-	case 12:
-	case 15:
 	case 16:
 #ifndef __BIG_ENDIAN
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture1Mode,
+		PM3_WRITE_REG(par, PM3ByAperture1Mode,
 				   PM3ByApertureMode_PIXELSIZE_16BIT);
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture2Mode,
+		PM3_WRITE_REG(par, PM3ByAperture2Mode,
 				   PM3ByApertureMode_PIXELSIZE_16BIT);
 #else
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture1Mode,
+		PM3_WRITE_REG(par, PM3ByAperture1Mode,
 				   PM3ByApertureMode_PIXELSIZE_16BIT |
 				   PM3ByApertureMode_BYTESWAP_BADC);
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture2Mode,
+		PM3_WRITE_REG(par, PM3ByAperture2Mode,
 				   PM3ByApertureMode_PIXELSIZE_16BIT |
 				   PM3ByApertureMode_BYTESWAP_BADC);
 #endif /* ! __BIG_ENDIAN */
@@ -263,23 +251,22 @@ static void pm3fb_write_mode(struct fb_info *info)
 
 	case 32:
 #ifndef __BIG_ENDIAN
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture1Mode,
+		PM3_WRITE_REG(par, PM3ByAperture1Mode,
 				   PM3ByApertureMode_PIXELSIZE_32BIT);
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture2Mode,
+		PM3_WRITE_REG(par, PM3ByAperture2Mode,
 				   PM3ByApertureMode_PIXELSIZE_32BIT);
 #else
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture1Mode,
+		PM3_WRITE_REG(par, PM3ByAperture1Mode,
 				   PM3ByApertureMode_PIXELSIZE_32BIT |
 				   PM3ByApertureMode_BYTESWAP_DCBA);
-		PM3_SLOW_WRITE_REG(par, PM3ByAperture2Mode,
+		PM3_WRITE_REG(par, PM3ByAperture2Mode,
 				   PM3ByApertureMode_PIXELSIZE_32BIT |
 				   PM3ByApertureMode_BYTESWAP_DCBA);
 #endif /* ! __BIG_ENDIAN */
 		break;
 
 	default:
-		DPRINTK("Unsupported depth %d\n",
-			info->var.bits_per_pixel);
+		DPRINTK("Unsupported depth %d\n", bpp);
 		break;
 	}
 
@@ -296,14 +283,15 @@ static void pm3fb_write_mode(struct fb_info *info)
 			   PM3VideoControl_VSYNC_MASK);
 		video |= PM3VideoControl_HSYNC_ACTIVE_HIGH |
 			 PM3VideoControl_VSYNC_ACTIVE_HIGH;
-		PM3_SLOW_WRITE_REG(par, PM3VideoControl, video);
+		PM3_WRITE_REG(par, PM3VideoControl, video);
 	}
-	PM3_SLOW_WRITE_REG(par, PM3VClkCtl,
+	PM3_WRITE_REG(par, PM3VClkCtl,
 			   (PM3_READ_REG(par, PM3VClkCtl) & 0xFFFFFFFC));
-	PM3_SLOW_WRITE_REG(par, PM3ScreenBase, par->base);
-	PM3_SLOW_WRITE_REG(par, PM3ChipConfig,
+	PM3_WRITE_REG(par, PM3ScreenBase, par->base);
+	PM3_WRITE_REG(par, PM3ChipConfig,
 			   (PM3_READ_REG(par, PM3ChipConfig) & 0xFFFFFFFD));
 
+	wmb();
 	{
 		unsigned char uninitialized_var(m);	/* ClkPreScale */
 		unsigned char uninitialized_var(n);	/* ClkFeedBackScale */
@@ -337,7 +325,7 @@ static void pm3fb_write_mode(struct fb_info *info)
 
 	PM3_WRITE_DAC_REG(par, PM3RD_DACControl, 0x00);
 
-	switch (info->var.bits_per_pixel) {
+	switch (pm3fb_depth(&info->var)) {
 	case 8:
 		PM3_WRITE_DAC_REG(par, PM3RD_PixelSize,
 				  PM3RD_PixelSize_8_BIT_PIXELS);
@@ -393,57 +381,44 @@ static void pm3fb_write_mode(struct fb_info *info)
  * hardware independent functions
  */
 int pm3fb_init(void);
-int pm3fb_setup(char*);
 
 static int pm3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	u32 lpitch;
+	unsigned bpp = var->red.length + var->green.length
+			+ var->blue.length + var->transp.length;
 
-	var->transp.offset = 0;
-	var->transp.length = 0;
-	switch(var->bits_per_pixel) {
-	case 8:
-		var->red.length = var->green.length = var->blue.length = 8;
-		var->red.offset = var->green.offset = var->blue.offset = 0;
-		break;
-	case 12:
-		var->red.offset   = 8;
-		var->red.length   = 4;
-		var->green.offset = 4;
-		var->green.length = 4;
-		var->blue.offset  = 0;
-		var->blue.length  = 4;
-		var->transp.offset = 12;
-		var->transp.length = 4;
-	case 15:
-		var->red.offset   = 10;
-		var->red.length   = 5;
-		var->green.offset = 5;
-		var->green.length = 5;
-		var->blue.offset  = 0;
-		var->blue.length  = 5;
-		var->transp.offset = 15;
-		var->transp.length = 1;
-		break;
-	case 16:
-		var->red.offset   = 11;
-		var->red.length   = 5;
-		var->green.offset = 5;
-		var->green.length = 6;
-		var->blue.offset  = 0;
-		var->blue.length  = 5;
-		break;
-	case 32:
-		var->transp.offset = 24;
-		var->transp.length = 8;
-		var->red.offset	  = 16;
-		var->green.offset = 8;
-		var->blue.offset  = 0;
-		var->red.length = var->green.length = var->blue.length = 8;
-		break;
-	default:
-		DPRINTK("depth not supported: %u\n", var->bits_per_pixel);
-		return -EINVAL;
+	if ( bpp != var->bits_per_pixel ) {
+		/* set predefined mode for bits_per_pixel settings */
+
+		switch(var->bits_per_pixel) {
+		case 8:
+			var->red.length = var->green.length = var->blue.length = 8;
+			var->red.offset = var->green.offset = var->blue.offset = 0;
+			var->transp.offset = 0;
+			var->transp.length = 0;
+			break;
+		case 16:
+			var->red.length = var->blue.length = 5;
+			var->green.length = 6;
+			var->transp.length = 0;
+			break;
+		case 32:
+			var->red.length = var->green.length = var->blue.length = 8;
+			var->transp.length = 8;
+			break;
+		default:
+			DPRINTK("depth not supported: %u\n", var->bits_per_pixel);
+			return -EINVAL;
+		}
+	}
+	/* it is assumed BGRA order */
+	if (var->bits_per_pixel > 8 )
+	{
+		var->blue.offset = 0;
+		var->green.offset = var->blue.length;
+		var->red.offset = var->green.offset + var->green.length;
+		var->transp.offset = var->red.offset + var->red.length;
 	}
 	var->height = var->width = -1;
 
@@ -502,10 +477,9 @@ static int pm3fb_set_par(struct fb_info *info)
 {
 	struct pm3_par *par = info->par;
 	const u32 xres = (info->var.xres + 31) & ~31;
-	const int depth = (info->var.bits_per_pixel + 7) & ~7;
+	const unsigned bpp = info->var.bits_per_pixel;
 
-	par->base = pm3fb_shift_bpp(info->var.bits_per_pixel,
-					(info->var.yoffset * xres)
+	par->base = pm3fb_shift_bpp(bpp,(info->var.yoffset * xres)
 					+ info->var.xoffset);
 	par->video = 0;
 
@@ -530,12 +504,10 @@ static int pm3fb_set_par(struct fb_info *info)
 		par->video |= PM3VideoControl_DISABLE;
 		DPRINTK("PM3Video disabled\n");
 	}
-	switch (depth) {
+	switch (bpp) {
 	case 8:
 		par->video |= PM3VideoControl_PIXELSIZE_8BIT;
 		break;
-	case 12:
-	case 15:
 	case 16:
 		par->video |= PM3VideoControl_PIXELSIZE_16BIT;
 		break;
@@ -548,9 +520,9 @@ static int pm3fb_set_par(struct fb_info *info)
 	}
 
 	info->fix.visual =
-		(depth == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+		(bpp == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
 	info->fix.line_length = ((info->var.xres_virtual + 7)  & ~7)
-					* depth / 8;
+					* bpp / 8;
 
 /*	pm3fb_clear_memory(info, 0);*/
 	pm3fb_clear_colormap(par, 0, 0, 0);
@@ -580,8 +552,8 @@ static int pm3fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 	 *   var->{color}.length contains length of bitfield
 	 *   {hardwarespecific} contains width of DAC
 	 *   pseudo_palette[X] is programmed to (X << red.offset) |
-	 *				      (X << green.offset) |
-	 *				      (X << blue.offset)
+	 *					(X << green.offset) |
+	 *					(X << blue.offset)
 	 *   RAMDAC[X] is programmed to (red, green, blue)
 	 *   color depth = SUM(var->{color}.length)
 	 *
@@ -621,7 +593,6 @@ static int pm3fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 		case 8:
 			break;
 		case 16:
-		case 24:
 		case 32:
 			((u32*)(info->pseudo_palette))[regno] = v;
 			break;
@@ -643,7 +614,8 @@ static int pm3fb_pan_display(struct fb_var_screeninfo *var,
 	par->base = pm3fb_shift_bpp(var->bits_per_pixel,
 					(var->yoffset * xres)
 					+ var->xoffset);
-	PM3_SLOW_WRITE_REG(par, PM3ScreenBase, par->base);
+	PM3_WAIT(par, 1);
+	PM3_WRITE_REG(par, PM3ScreenBase, par->base);
 	return 0;
 }
 
@@ -665,31 +637,31 @@ static int pm3fb_blank(int blank_mode, struct fb_info *info)
 
 	switch (blank_mode) {
 	case FB_BLANK_UNBLANK:
-		video = video | PM3VideoControl_ENABLE;
+		video |= PM3VideoControl_ENABLE;
 		break;
-	case FB_BLANK_NORMAL:	/* FIXME */
-		video = video & ~(PM3VideoControl_ENABLE);
+	case FB_BLANK_NORMAL:
+		video &= ~(PM3VideoControl_ENABLE);
 		break;
 	case FB_BLANK_HSYNC_SUSPEND:
-		video = video & ~(PM3VideoControl_HSYNC_MASK |
-				  PM3VideoControl_BLANK_ACTIVE_LOW);
+		video &= ~(PM3VideoControl_HSYNC_MASK |
+			  PM3VideoControl_BLANK_ACTIVE_LOW);
 		break;
 	case FB_BLANK_VSYNC_SUSPEND:
-		video = video & ~(PM3VideoControl_VSYNC_MASK |
-				  PM3VideoControl_BLANK_ACTIVE_LOW);
+		video &= ~(PM3VideoControl_VSYNC_MASK |
+			  PM3VideoControl_BLANK_ACTIVE_LOW);
 		break;
 	case FB_BLANK_POWERDOWN:
-		video = video & ~(PM3VideoControl_HSYNC_MASK |
-				  PM3VideoControl_VSYNC_MASK |
-				  PM3VideoControl_BLANK_ACTIVE_LOW);
+		video &= ~(PM3VideoControl_HSYNC_MASK |
+			  PM3VideoControl_VSYNC_MASK |
+			  PM3VideoControl_BLANK_ACTIVE_LOW);
 		break;
 	default:
 		DPRINTK("Unsupported blanking %d\n", blank_mode);
 		return 1;
 	}
 
-	PM3_SLOW_WRITE_REG(par,PM3VideoControl, video);
-
+	PM3_WAIT(par, 1);
+	PM3_WRITE_REG(par,PM3VideoControl, video);
 	return 0;
 }
 
@@ -703,9 +675,9 @@ static struct fb_ops pm3fb_ops = {
 	.fb_set_par	= pm3fb_set_par,
 	.fb_setcolreg	= pm3fb_setcolreg,
 	.fb_pan_display	= pm3fb_pan_display,
-	.fb_fillrect	= cfb_fillrect,		/* Needed !!! */
-	.fb_copyarea	= cfb_copyarea,		/* Needed !!! */
-	.fb_imageblit	= cfb_imageblit,	/* Needed !!! */
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
 	.fb_blank	= pm3fb_blank,
 };
 
@@ -722,7 +694,7 @@ static unsigned long pm3fb_size_memory(struct pm3_par *par)
 	unsigned long	memsize = 0, tempBypass, i, temp1, temp2;
 	unsigned char	__iomem *screen_mem;
 
-	pm3fb_fix.smem_len = 64 * 1024 * 1024; /* request full aperture size */
+	pm3fb_fix.smem_len = 64 * 1024l * 1024; /* request full aperture size */
 	/* Linear frame buffer - request region and map it. */
 	if (!request_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len,
 				 "pm3fb smem")) {
@@ -744,7 +716,8 @@ static unsigned long pm3fb_size_memory(struct pm3_par *par)
 
 	DPRINTK("PM3MemBypassWriteMask was: 0x%08lx\n", tempBypass);
 
-	PM3_SLOW_WRITE_REG(par, PM3MemBypassWriteMask, 0xFFFFFFFF);
+	PM3_WAIT(par, 1);
+	PM3_WRITE_REG(par, PM3MemBypassWriteMask, 0xFFFFFFFF);
 
 	/* pm3 split up memory, replicates, and do a lot of nasty stuff IMHO ;-) */
 	for (i = 0; i < 32; i++) {
@@ -765,10 +738,9 @@ static unsigned long pm3fb_size_memory(struct pm3_par *par)
 	if (memsize + 1 == i) {
 		for (i = 0; i < 32; i++) {
 			/* Clear first 32MB ; 0 is 0, no need to byteswap */
-			writel(0x0000000,
-			       (screen_mem + (i * 1048576)));
-			mb();
+			writel(0x0000000, (screen_mem + (i * 1048576)));
 		}
+		wmb();
 
 		for (i = 32; i < 64; i++) {
 			fb_writel(i * 0x00345678,
@@ -787,7 +759,8 @@ static unsigned long pm3fb_size_memory(struct pm3_par *par)
 	}
 	DPRINTK("Second detect pass got %ld MB\n", memsize + 1);
 
-	PM3_SLOW_WRITE_REG(par, PM3MemBypassWriteMask, tempBypass);
+	PM3_WAIT(par, 1);
+	PM3_WRITE_REG(par, PM3MemBypassWriteMask, tempBypass);
 
 	iounmap(screen_mem);
 	release_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);
@@ -890,7 +863,6 @@ static int __devinit pm3fb_probe(struct pci_dev *dev,
 		goto err_exit_both;
 	}
 
-	/* This has to been done !!! */
 	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
 		retval = -ENOMEM;
 		goto err_exit_both;
@@ -907,7 +879,7 @@ static int __devinit pm3fb_probe(struct pci_dev *dev,
 	}
 	printk(KERN_INFO "fb%d: %s frame buffer device\n", info->node,
 	   info->fix.id);
-	pci_set_drvdata(dev, info); /* or dev_set_drvdata(device, info) */
+	pci_set_drvdata(dev, info);
 	return 0;
 
  err_exit_all:
@@ -949,8 +921,7 @@ static void __devexit pm3fb_remove(struct pci_dev *dev)
 
 static struct pci_device_id pm3fb_id_table[] = {
 	{ PCI_VENDOR_ID_3DLABS, 0x0a,
-	  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,
-	  0xff0000, 0 },
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
 	{ 0, }
 };
 
@@ -964,6 +935,22 @@ static struct pci_driver pm3fb_driver = {
 
 MODULE_DEVICE_TABLE(pci, pm3fb_id_table);
 
+#ifndef MODULE
+	/*
+	 *  Setup
+	 */
+
+/*
+ * Only necessary if your driver takes special options,
+ * otherwise we fall back on the generic fb_setup().
+ */
+static int __init pm3fb_setup(char *options)
+{
+	/* Parse user speficied options (`video=pm3fb:') */
+	return 0;
+}
+#endif /* MODULE */
+
 int __init pm3fb_init(void)
 {
 	/*
@@ -985,22 +972,6 @@ static void __exit pm3fb_exit(void)
 	pci_unregister_driver(&pm3fb_driver);
 }
 
-#ifndef MODULE
-	/*
-	 *  Setup
-	 */
-
-/*
- * Only necessary if your driver takes special options,
- * otherwise we fall back on the generic fb_setup().
- */
-int __init pm3fb_setup(char *options)
-{
-	/* Parse user speficied options (`video=pm3fb:') */
-	return 0;
-}
-#endif /* MODULE */
-
 module_init(pm3fb_init);
 module_exit(pm3fb_exit);
 
diff --git a/drivers/video/ps3fb.c b/drivers/video/ps3fb.c
index 9756a72..9cf92ba 100644
--- a/drivers/video/ps3fb.c
+++ b/drivers/video/ps3fb.c
@@ -951,12 +951,14 @@ static int ps3fb_xdr_settings(u64 xdr_lpar)
 static struct fb_ops ps3fb_ops = {
 	.fb_open	= ps3fb_open,
 	.fb_release	= ps3fb_release,
+	.fb_read        = fb_sys_read,
+	.fb_write       = fb_sys_write,
 	.fb_check_var	= ps3fb_check_var,
 	.fb_set_par	= ps3fb_set_par,
 	.fb_setcolreg	= ps3fb_setcolreg,
-	.fb_fillrect	= cfb_fillrect,
-	.fb_copyarea	= cfb_copyarea,
-	.fb_imageblit	= cfb_imageblit,
+	.fb_fillrect	= sys_fillrect,
+	.fb_copyarea	= sys_copyarea,
+	.fb_imageblit	= sys_imageblit,
 	.fb_mmap	= ps3fb_mmap,
 	.fb_blank	= ps3fb_blank,
 	.fb_ioctl	= ps3fb_ioctl,
diff --git a/drivers/video/w100fb.c b/drivers/video/w100fb.c
index 5fc86ea..003c49a 100644
--- a/drivers/video/w100fb.c
+++ b/drivers/video/w100fb.c
@@ -660,7 +660,7 @@ int __init w100fb_probe(struct platform_device *pdev)
 			err = -ENODEV;
 			goto out;
 	}
-	printk(" at 0x%08lx.\n", mem->start+W100_CFG_BASE);
+	printk(" at 0x%08lx.\n", (unsigned long) mem->start+W100_CFG_BASE);
 
 	/* Remap the framebuffer */
 	remapped_fbuf = ioremap_nocache(mem->start+MEM_WINDOW_BASE, MEM_WINDOW_SIZE);
@@ -753,10 +753,14 @@ int __init w100fb_probe(struct platform_device *pdev)
 		goto out;
 	}
 
-	device_create_file(&pdev->dev, &dev_attr_fastpllclk);
-	device_create_file(&pdev->dev, &dev_attr_reg_read);
-	device_create_file(&pdev->dev, &dev_attr_reg_write);
-	device_create_file(&pdev->dev, &dev_attr_flip);
+	err = device_create_file(&pdev->dev, &dev_attr_fastpllclk);
+	err |= device_create_file(&pdev->dev, &dev_attr_reg_read);
+	err |= device_create_file(&pdev->dev, &dev_attr_reg_write);
+	err |= device_create_file(&pdev->dev, &dev_attr_flip);
+
+	if (err != 0)
+		printk(KERN_WARNING "fb%d: failed to register attributes (%d)\n",
+				info->node, err);
 
 	printk(KERN_INFO "fb%d: %s frame buffer device\n", info->node, info->fix.id);
 	return 0;
diff --git a/fs/9p/vfs_addr.c b/fs/9p/vfs_addr.c
index 3128aa9..9ac4ffe 100644
--- a/fs/9p/vfs_addr.c
+++ b/fs/9p/vfs_addr.c
@@ -32,6 +32,7 @@
 #include <linux/inet.h>
 #include <linux/pagemap.h>
 #include <linux/idr.h>
+#include <linux/sched.h>
 
 #include "debug.h"
 #include "v9fs.h"
diff --git a/fs/9p/vfs_dentry.c b/fs/9p/vfs_dentry.c
index 775e26e..d939604 100644
--- a/fs/9p/vfs_dentry.c
+++ b/fs/9p/vfs_dentry.c
@@ -33,6 +33,7 @@
 #include <linux/inet.h>
 #include <linux/namei.h>
 #include <linux/idr.h>
+#include <linux/sched.h>
 
 #include "debug.h"
 #include "v9fs.h"
diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index 7624821..c76cd8f 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -33,6 +33,7 @@
 #include <linux/inet.h>
 #include <linux/namei.h>
 #include <linux/idr.h>
+#include <linux/sched.h>
 
 #include "debug.h"
 #include "v9fs.h"
diff --git a/fs/9p/vfs_super.c b/fs/9p/vfs_super.c
index 8eb9263..7bdf8b3 100644
--- a/fs/9p/vfs_super.c
+++ b/fs/9p/vfs_super.c
@@ -36,6 +36,7 @@
 #include <linux/seq_file.h>
 #include <linux/mount.h>
 #include <linux/idr.h>
+#include <linux/sched.h>
 
 #include "debug.h"
 #include "v9fs.h"
diff --git a/fs/Kconfig.binfmt b/fs/Kconfig.binfmt
index 74c6440..d4fc609 100644
--- a/fs/Kconfig.binfmt
+++ b/fs/Kconfig.binfmt
@@ -38,7 +38,7 @@ config BINFMT_ELF_FDPIC
 
 config BINFMT_FLAT
 	tristate "Kernel support for flat binaries"
-	depends on !MMU || SUPERH
+	depends on !MMU
 	help
 	  Support uClinux FLAT format binaries.
 
diff --git a/fs/affs/inode.c b/fs/affs/inode.c
index c5b9d73..4609a6c 100644
--- a/fs/affs/inode.c
+++ b/fs/affs/inode.c
@@ -9,7 +9,7 @@
  *
  *  (C) 1991  Linus Torvalds - minix filesystem
  */
-
+#include <linux/sched.h>
 #include "affs.h"
 
 extern const struct inode_operations affs_symlink_inode_operations;
diff --git a/fs/affs/super.c b/fs/affs/super.c
index b800d45..6d0ebc3 100644
--- a/fs/affs/super.c
+++ b/fs/affs/super.c
@@ -15,6 +15,7 @@
 #include <linux/statfs.h>
 #include <linux/parser.h>
 #include <linux/magic.h>
+#include <linux/sched.h>
 #include "affs.h"
 
 extern struct timezone sys_tz;
diff --git a/fs/afs/callback.c b/fs/afs/callback.c
index f64e40f..bacf518 100644
--- a/fs/afs/callback.c
+++ b/fs/afs/callback.c
@@ -17,6 +17,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/circ_buf.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 unsigned afs_vnode_update_timeout = 10;
diff --git a/fs/afs/cell.c b/fs/afs/cell.c
index 9b1311a..175a567 100644
--- a/fs/afs/cell.c
+++ b/fs/afs/cell.c
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/key.h>
 #include <linux/ctype.h>
+#include <linux/sched.h>
 #include <keys/rxrpc-type.h>
 #include "internal.h"
 
diff --git a/fs/afs/dir.c b/fs/afs/dir.c
index 719af4f..546c595 100644
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@ -16,6 +16,7 @@
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 #include <linux/ctype.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,
diff --git a/fs/afs/inode.c b/fs/afs/inode.c
index 47f5fed..d196840 100644
--- a/fs/afs/inode.c
+++ b/fs/afs/inode.c
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 struct afs_iget_data {
diff --git a/fs/afs/internal.h b/fs/afs/internal.h
index 4953ba5..2dac3ad 100644
--- a/fs/afs/internal.h
+++ b/fs/afs/internal.h
@@ -16,6 +16,7 @@
 #include <linux/skbuff.h>
 #include <linux/rxrpc.h>
 #include <linux/key.h>
+#include <linux/workqueue.h>
 #include "afs.h"
 #include "afs_vl.h"
 
diff --git a/fs/afs/main.c b/fs/afs/main.c
index f1f71ff..cd21195 100644
--- a/fs/afs/main.c
+++ b/fs/afs/main.c
@@ -13,6 +13,7 @@
 #include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/completion.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 MODULE_DESCRIPTION("AFS Client File System");
diff --git a/fs/afs/proc.c b/fs/afs/proc.c
index d5601f6..13df512 100644
--- a/fs/afs/proc.c
+++ b/fs/afs/proc.c
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/sched.h>
 #include <asm/uaccess.h>
 #include "internal.h"
 
diff --git a/fs/afs/security.c b/fs/afs/security.c
index e0ea88b..566fe71 100644
--- a/fs/afs/security.c
+++ b/fs/afs/security.c
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/fs.h>
 #include <linux/ctype.h>
+#include <linux/sched.h>
 #include <keys/rxrpc-type.h>
 #include "internal.h"
 
diff --git a/fs/afs/super.c b/fs/afs/super.c
index 8d47ad8..2e8496b 100644
--- a/fs/afs/super.c
+++ b/fs/afs/super.c
@@ -22,6 +22,7 @@
 #include <linux/pagemap.h>
 #include <linux/parser.h>
 #include <linux/statfs.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 #define AFS_FS_MAGIC 0x6B414653 /* 'kAFS' */
diff --git a/fs/afs/vlocation.c b/fs/afs/vlocation.c
index 3370cdb..09e3ad0 100644
--- a/fs/afs/vlocation.c
+++ b/fs/afs/vlocation.c
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 unsigned afs_vlocation_timeout = 10;	/* volume location timeout in seconds */
diff --git a/fs/afs/vnode.c b/fs/afs/vnode.c
index c36c98c..232c55d 100644
--- a/fs/afs/vnode.c
+++ b/fs/afs/vnode.c
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 #if 0
diff --git a/fs/afs/volume.c b/fs/afs/volume.c
index dd160ca..8bab0e3 100644
--- a/fs/afs/volume.c
+++ b/fs/afs/volume.c
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
+#include <linux/sched.h>
 #include "internal.h"
 
 static const char *afs_voltypes[] = { "R/W", "R/O", "BAK" };
diff --git a/fs/binfmt_misc.c b/fs/binfmt_misc.c
index 72d0b41..330fd3f 100644
--- a/fs/binfmt_misc.c
+++ b/fs/binfmt_misc.c
@@ -18,7 +18,7 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
-
+#include <linux/sched.h>
 #include <linux/binfmts.h>
 #include <linux/slab.h>
 #include <linux/ctype.h>
diff --git a/fs/buffer.c b/fs/buffer.c
index 49590d5..aa68206 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2101,7 +2101,7 @@ int cont_prepare_write(struct page *page, unsigned offset,
 						PAGE_CACHE_SIZE, get_block);
 		if (status)
 			goto out_unmap;
-		zero_user_page(page, zerofrom, PAGE_CACHE_SIZE - zerofrom,
+		zero_user_page(new_page, zerofrom, PAGE_CACHE_SIZE - zerofrom,
 				KM_USER0);
 		generic_commit_write(NULL, new_page, zerofrom, PAGE_CACHE_SIZE);
 		unlock_page(new_page);
diff --git a/fs/coda/cache.c b/fs/coda/cache.c
index 5d05271..fcb88fa 100644
--- a/fs/coda/cache.c
+++ b/fs/coda/cache.c
@@ -16,6 +16,7 @@
 #include <asm/uaccess.h>
 #include <linux/string.h>
 #include <linux/list.h>
+#include <linux/sched.h>
 
 #include <linux/coda.h>
 #include <linux/coda_linux.h>
diff --git a/fs/coda/upcall.c b/fs/coda/upcall.c
index a5b5e63..5faacdb 100644
--- a/fs/coda/upcall.c
+++ b/fs/coda/upcall.c
@@ -16,7 +16,7 @@
 
 #include <asm/system.h>
 #include <linux/signal.h>
-
+#include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
diff --git a/fs/compat.c b/fs/compat.c
index 1de2331..4db6216 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -1544,9 +1544,10 @@ int compat_core_sys_select(int n, compat_ulong_t __user *inp,
 	compat_ulong_t __user *outp, compat_ulong_t __user *exp, s64 *timeout)
 {
 	fd_set_bits fds;
-	char *bits;
+	void *bits;
 	int size, max_fds, ret = -EINVAL;
 	struct fdtable *fdt;
+	long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];
 
 	if (n < 0)
 		goto out_nofds;
@@ -1564,11 +1565,14 @@ int compat_core_sys_select(int n, compat_ulong_t __user *inp,
 	 * since we used fdset we need to allocate memory in units of
 	 * long-words.
 	 */
-	ret = -ENOMEM;
 	size = FDS_BYTES(n);
-	bits = kmalloc(6 * size, GFP_KERNEL);
-	if (!bits)
-		goto out_nofds;
+	bits = stack_fds;
+	if (size > sizeof(stack_fds) / 6) {
+		bits = kmalloc(6 * size, GFP_KERNEL);
+		ret = -ENOMEM;
+		if (!bits)
+			goto out_nofds;
+	}
 	fds.in      = (unsigned long *)  bits;
 	fds.out     = (unsigned long *) (bits +   size);
 	fds.ex      = (unsigned long *) (bits + 2*size);
@@ -1600,7 +1604,8 @@ int compat_core_sys_select(int n, compat_ulong_t __user *inp,
 	    compat_set_fd_set(n, exp, fds.res_ex))
 		ret = -EFAULT;
 out:
-	kfree(bits);
+	if (bits != stack_fds)
+		kfree(bits);
 out_nofds:
 	return ret;
 }
diff --git a/fs/configfs/inode.c b/fs/configfs/inode.c
index 2ec9bea..ddc003a 100644
--- a/fs/configfs/inode.c
+++ b/fs/configfs/inode.c
@@ -32,6 +32,7 @@
 #include <linux/namei.h>
 #include <linux/backing-dev.h>
 #include <linux/capability.h>
+#include <linux/sched.h>
 
 #include <linux/configfs.h>
 #include "configfs_internal.h"
diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c
index 9881b5c..59288d8 100644
--- a/fs/ecryptfs/file.c
+++ b/fs/ecryptfs/file.c
@@ -33,63 +33,6 @@
 #include "ecryptfs_kernel.h"
 
 /**
- * ecryptfs_llseek
- * @file: File we are seeking in
- * @offset: The offset to seek to
- * @origin: 2 - offset from i_size; 1 - offset from f_pos
- *
- * Returns the position we have seeked to, or negative on error
- */
-static loff_t ecryptfs_llseek(struct file *file, loff_t offset, int origin)
-{
-	loff_t rv;
-	loff_t new_end_pos;
-	int rc;
-	int expanding_file = 0;
-	struct inode *inode = file->f_mapping->host;
-
-	/* If our offset is past the end of our file, we're going to
-	 * need to grow it so we have a valid length of 0's */
-	new_end_pos = offset;
-	switch (origin) {
-	case 2:
-		new_end_pos += i_size_read(inode);
-		expanding_file = 1;
-		break;
-	case 1:
-		new_end_pos += file->f_pos;
-		if (new_end_pos > i_size_read(inode)) {
-			ecryptfs_printk(KERN_DEBUG, "new_end_pos(=[0x%.16x]) "
-					"> i_size_read(inode)(=[0x%.16x])\n",
-					new_end_pos, i_size_read(inode));
-			expanding_file = 1;
-		}
-		break;
-	default:
-		if (new_end_pos > i_size_read(inode)) {
-			ecryptfs_printk(KERN_DEBUG, "new_end_pos(=[0x%.16x]) "
-					"> i_size_read(inode)(=[0x%.16x])\n",
-					new_end_pos, i_size_read(inode));
-			expanding_file = 1;
-		}
-	}
-	ecryptfs_printk(KERN_DEBUG, "new_end_pos = [0x%.16x]\n", new_end_pos);
-	if (expanding_file) {
-		rc = ecryptfs_truncate(file->f_path.dentry, new_end_pos);
-		if (rc) {
-			rv = rc;
-			ecryptfs_printk(KERN_ERR, "Error on attempt to "
-					"truncate to (higher) offset [0x%.16x];"
-					" rc = [%d]\n", new_end_pos, rc);
-			goto out;
-		}
-	}
-	rv = generic_file_llseek(file, offset, origin);
-out:
-	return rv;
-}
-
-/**
  * ecryptfs_read_update_atime
  *
  * generic_file_read updates the atime of upper layer inode.  But, it
@@ -425,7 +368,7 @@ const struct file_operations ecryptfs_dir_fops = {
 };
 
 const struct file_operations ecryptfs_main_fops = {
-	.llseek = ecryptfs_llseek,
+	.llseek = generic_file_llseek,
 	.read = do_sync_read,
 	.aio_read = ecryptfs_read_update_atime,
 	.write = do_sync_write,
diff --git a/fs/ecryptfs/messaging.c b/fs/ecryptfs/messaging.c
index 3baf253..a9d87c4 100644
--- a/fs/ecryptfs/messaging.c
+++ b/fs/ecryptfs/messaging.c
@@ -19,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.
  */
-
+#include <linux/sched.h>
 #include "ecryptfs_kernel.h"
 
 static LIST_HEAD(ecryptfs_msg_ctx_free_list);
diff --git a/fs/ecryptfs/mmap.c b/fs/ecryptfs/mmap.c
index 88ea669..55cec98 100644
--- a/fs/ecryptfs/mmap.c
+++ b/fs/ecryptfs/mmap.c
@@ -376,9 +376,31 @@ out:
 	return 0;
 }
 
+/**
+ * eCryptfs does not currently support holes. When writing after a
+ * seek past the end of the file, eCryptfs fills in 0's through to the
+ * current location. The code to fill in the 0's to all the
+ * intermediate pages calls ecryptfs_prepare_write_no_truncate().
+ */
+static int
+ecryptfs_prepare_write_no_truncate(struct file *file, struct page *page,
+				   unsigned from, unsigned to)
+{
+	int rc = 0;
+
+	if (from == 0 && to == PAGE_CACHE_SIZE)
+		goto out;	/* If we are writing a full page, it will be
+				   up to date. */
+	if (!PageUptodate(page))
+		rc = ecryptfs_do_readpage(file, page, page->index);
+out:
+	return rc;
+}
+
 static int ecryptfs_prepare_write(struct file *file, struct page *page,
 				  unsigned from, unsigned to)
 {
+	loff_t pos;
 	int rc = 0;
 
 	if (from == 0 && to == PAGE_CACHE_SIZE)
@@ -386,6 +408,16 @@ static int ecryptfs_prepare_write(struct file *file, struct page *page,
 				   up to date. */
 	if (!PageUptodate(page))
 		rc = ecryptfs_do_readpage(file, page, page->index);
+	pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
+	if (pos > i_size_read(page->mapping->host)) {
+		rc = ecryptfs_truncate(file->f_path.dentry, pos);
+		if (rc) {
+			printk(KERN_ERR "Error on attempt to "
+			       "truncate to (higher) offset [%lld];"
+			       " rc = [%d]\n", pos, rc);
+			goto out;
+		}
+	}
 out:
 	return rc;
 }
@@ -744,10 +776,10 @@ int write_zeros(struct file *file, pgoff_t index, int start, int num_zeros)
 		rc = PTR_ERR(tmp_page);
 		goto out;
 	}
-	rc = ecryptfs_prepare_write(file, tmp_page, start, start + num_zeros);
-	if (rc) {
+	if ((rc = ecryptfs_prepare_write_no_truncate(file, tmp_page, start,
+						     (start + num_zeros)))) {
 		ecryptfs_printk(KERN_ERR, "Error preparing to write zero's "
-				"to remainder of page at index [0x%.16x]\n",
+				"to page at index [0x%.16x]\n",
 				index);
 		page_cache_release(tmp_page);
 		goto out;
diff --git a/fs/exec.c b/fs/exec.c
index 0b68588..f20561f 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -134,6 +134,9 @@ asmlinkage long sys_uselib(const char __user * library)
 	if (error)
 		goto out;
 
+	error = -EACCES;
+	if (nd.mnt->mnt_flags & MNT_NOEXEC)
+		goto exit;
 	error = -EINVAL;
 	if (!S_ISREG(nd.dentry->d_inode->i_mode))
 		goto exit;
diff --git a/fs/fifo.c b/fs/fifo.c
index 6e7df72..9785e36 100644
--- a/fs/fifo.c
+++ b/fs/fifo.c
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include <linux/sched.h>
 #include <linux/pipe_fs_i.h>
 
 static void wait_for_partner(struct inode* inode, unsigned int *cnt)
diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index 8890eba..bd5a772 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -485,7 +485,7 @@ static int fuse_mknod(struct inode *dir, struct dentry *entry, int mode,
 static int fuse_create(struct inode *dir, struct dentry *entry, int mode,
 		       struct nameidata *nd)
 {
-	if (nd && (nd->flags & LOOKUP_CREATE)) {
+	if (nd && (nd->flags & LOOKUP_OPEN)) {
 		int err = fuse_create_open(dir, entry, mode, nd);
 		if (err != -ENOSYS)
 			return err;
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index acfad65..adf7995 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -11,6 +11,7 @@
 #include <linux/pagemap.h>
 #include <linux/slab.h>
 #include <linux/kernel.h>
+#include <linux/sched.h>
 
 static const struct file_operations fuse_direct_io_file_operations;
 
@@ -609,7 +610,9 @@ static ssize_t fuse_direct_write(struct file *file, const char __user *buf,
 	ssize_t res;
 	/* Don't allow parallel writes to the same file */
 	mutex_lock(&inode->i_mutex);
-	res = fuse_direct_io(file, buf, count, ppos, 1);
+	res = generic_write_checks(file, ppos, &count, 0);
+	if (!res)
+		res = fuse_direct_io(file, buf, count, ppos, 1);
 	mutex_unlock(&inode->i_mutex);
 	return res;
 }
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index c3a2ad0..9804c0c 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -17,6 +17,7 @@
 #include <linux/parser.h>
 #include <linux/statfs.h>
 #include <linux/random.h>
+#include <linux/sched.h>
 
 MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
 MODULE_DESCRIPTION("Filesystem in Userspace");
@@ -453,6 +454,7 @@ static const struct super_operations fuse_super_operations = {
 	.destroy_inode  = fuse_destroy_inode,
 	.read_inode	= fuse_read_inode,
 	.clear_inode	= fuse_clear_inode,
+	.drop_inode	= generic_delete_inode,
 	.remount_fs	= fuse_remount_fs,
 	.put_super	= fuse_put_super,
 	.umount_begin	= fuse_umount_begin,
diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.h
index 11477ca..b3e152d 100644
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@ -10,6 +10,7 @@
 #ifndef __GLOCK_DOT_H__
 #define __GLOCK_DOT_H__
 
+#include <linux/sched.h>
 #include "incore.h"
 
 /* Flags for lock requests; used in gfs2_holder gh_flag field.
diff --git a/fs/hfs/inode.c b/fs/hfs/inode.c
index fafcba5..9a934db 100644
--- a/fs/hfs/inode.c
+++ b/fs/hfs/inode.c
@@ -13,6 +13,7 @@
 
 #include <linux/pagemap.h>
 #include <linux/mpage.h>
+#include <linux/sched.h>
 
 #include "hfs_fs.h"
 #include "btree.h"
diff --git a/fs/hfsplus/inode.c b/fs/hfsplus/inode.c
index 642012a..45dab5d 100644
--- a/fs/hfsplus/inode.c
+++ b/fs/hfsplus/inode.c
@@ -12,6 +12,7 @@
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 #include <linux/mpage.h>
+#include <linux/sched.h>
 
 #include "hfsplus_fs.h"
 #include "hfsplus_raw.h"
diff --git a/fs/hpfs/buffer.c b/fs/hpfs/buffer.c
index b52b738..b6fca54 100644
--- a/fs/hpfs/buffer.c
+++ b/fs/hpfs/buffer.c
@@ -5,7 +5,7 @@
  *
  *  general buffer i/o
  */
-
+#include <linux/sched.h>
 #include "hpfs_fn.h"
 
 void hpfs_lock_creation(struct super_block *s)
diff --git a/fs/hpfs/namei.c b/fs/hpfs/namei.c
index 9953cf9..d256559 100644
--- a/fs/hpfs/namei.c
+++ b/fs/hpfs/namei.c
@@ -5,7 +5,7 @@
  *
  *  adding & removing files & directories
  */
-
+#include <linux/sched.h>
 #include "hpfs_fn.h"
 
 static int hpfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c
index fca1165..29cc34a 100644
--- a/fs/hpfs/super.c
+++ b/fs/hpfs/super.c
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/statfs.h>
 #include <linux/magic.h>
+#include <linux/sched.h>
 
 /* Mark the filesystem dirty, so that chkdsk checks it when os/2 booted */
 
diff --git a/fs/minix/bitmap.c b/fs/minix/bitmap.c
index c4a554d..99a12f1 100644
--- a/fs/minix/bitmap.c
+++ b/fs/minix/bitmap.c
@@ -15,6 +15,7 @@
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
 #include <linux/bitops.h>
+#include <linux/sched.h>
 
 static int nibblemap[] = { 4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0 };
 
diff --git a/fs/ncpfs/file.c b/fs/ncpfs/file.c
index addfd31..d3152f8 100644
--- a/fs/ncpfs/file.c
+++ b/fs/ncpfs/file.c
@@ -17,6 +17,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
+#include <linux/sched.h>
 
 #include <linux/ncp_fs.h>
 #include "ncplib_kernel.h"
diff --git a/fs/ncpfs/ioctl.c b/fs/ncpfs/ioctl.c
index 8843a83..c67b4bd 100644
--- a/fs/ncpfs/ioctl.c
+++ b/fs/ncpfs/ioctl.c
@@ -17,6 +17,7 @@
 #include <linux/highuid.h>
 #include <linux/smp_lock.h>
 #include <linux/vmalloc.h>
+#include <linux/sched.h>
 
 #include <linux/ncp_fs.h>
 
diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index 50c6821..881fa49 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -12,7 +12,7 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
-
+#include <linux/sched.h>
 #include <linux/time.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index ac92e45..c27258b 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -33,6 +33,7 @@
 #include <linux/pagevec.h>
 #include <linux/namei.h>
 #include <linux/mount.h>
+#include <linux/sched.h>
 
 #include "nfs4_fs.h"
 #include "delegation.h"
diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c
index 345aa5c..0c542ec 100644
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@ -122,19 +122,25 @@ ssize_t nfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov, loff_
 	return -EINVAL;
 }
 
-static void nfs_direct_dirty_pages(struct page **pages, int npages)
+static void nfs_direct_dirty_pages(struct page **pages, unsigned int pgbase, size_t count)
 {
-	int i;
+	unsigned int npages;
+	unsigned int i;
+
+	if (count == 0)
+		return;
+	pages += (pgbase >> PAGE_SHIFT);
+	npages = (count + (pgbase & ~PAGE_MASK) + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	for (i = 0; i < npages; i++) {
 		struct page *page = pages[i];
 		if (!PageCompound(page))
-			set_page_dirty_lock(page);
+			set_page_dirty(page);
 	}
 }
 
-static void nfs_direct_release_pages(struct page **pages, int npages)
+static void nfs_direct_release_pages(struct page **pages, unsigned int npages)
 {
-	int i;
+	unsigned int i;
 	for (i = 0; i < npages; i++)
 		page_cache_release(pages[i]);
 }
@@ -224,17 +230,18 @@ static void nfs_direct_read_result(struct rpc_task *task, void *calldata)
 	if (nfs_readpage_result(task, data) != 0)
 		return;
 
-	nfs_direct_dirty_pages(data->pagevec, data->npages);
-	nfs_direct_release_pages(data->pagevec, data->npages);
-
 	spin_lock(&dreq->lock);
-
-	if (likely(task->tk_status >= 0))
-		dreq->count += data->res.count;
-	else
+	if (unlikely(task->tk_status < 0)) {
 		dreq->error = task->tk_status;
-
-	spin_unlock(&dreq->lock);
+		spin_unlock(&dreq->lock);
+	} else {
+		dreq->count += data->res.count;
+		spin_unlock(&dreq->lock);
+		nfs_direct_dirty_pages(data->pagevec,
+				data->args.pgbase,
+				data->res.count);
+	}
+	nfs_direct_release_pages(data->pagevec, data->npages);
 
 	if (put_dreq(dreq))
 		nfs_direct_complete(dreq);
@@ -279,9 +286,12 @@ static ssize_t nfs_direct_read_schedule(struct nfs_direct_req *dreq, unsigned lo
 		result = get_user_pages(current, current->mm, user_addr,
 					data->npages, 1, 0, data->pagevec, NULL);
 		up_read(&current->mm->mmap_sem);
-		if (unlikely(result < data->npages)) {
-			if (result > 0)
-				nfs_direct_release_pages(data->pagevec, result);
+		if (result < 0) {
+			nfs_readdata_release(data);
+			break;
+		}
+		if ((unsigned)result < data->npages) {
+			nfs_direct_release_pages(data->pagevec, result);
 			nfs_readdata_release(data);
 			break;
 		}
@@ -610,9 +620,12 @@ static ssize_t nfs_direct_write_schedule(struct nfs_direct_req *dreq, unsigned l
 		result = get_user_pages(current, current->mm, user_addr,
 					data->npages, 0, 0, data->pagevec, NULL);
 		up_read(&current->mm->mmap_sem);
-		if (unlikely(result < data->npages)) {
-			if (result > 0)
-				nfs_direct_release_pages(data->pagevec, result);
+		if (result < 0) {
+			nfs_writedata_release(data);
+			break;
+		}
+		if ((unsigned)result < data->npages) {
+			nfs_direct_release_pages(data->pagevec, result);
 			nfs_writedata_release(data);
 			break;
 		}
diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index 5eaee6d..9eb8eb4 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 #include <linux/pagemap.h>
 #include <linux/smp_lock.h>
+#include <linux/aio.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 2b26ad7..bd9f5a8 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -15,7 +15,7 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
-
+#include <linux/sched.h>
 #include <linux/time.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c
index e12054c..c5bb51a 100644
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -11,6 +11,7 @@
 
 #include <linux/slab.h>
 #include <linux/file.h>
+#include <linux/sched.h>
 #include <linux/sunrpc/clnt.h>
 #include <linux/nfs3.h>
 #include <linux/nfs4.h>
@@ -354,6 +355,26 @@ void nfs_pageio_complete(struct nfs_pageio_descriptor *desc)
 	nfs_pageio_doio(desc);
 }
 
+/**
+ * nfs_pageio_cond_complete - Conditional I/O completion
+ * @desc: pointer to io descriptor
+ * @index: page index
+ *
+ * It is important to ensure that processes don't try to take locks
+ * on non-contiguous ranges of pages as that might deadlock. This
+ * function should be called before attempting to wait on a locked
+ * nfs_page. It will complete the I/O if the page index 'index'
+ * is not contiguous with the existing list of pages in 'desc'.
+ */
+void nfs_pageio_cond_complete(struct nfs_pageio_descriptor *desc, pgoff_t index)
+{
+	if (!list_empty(&desc->pg_list)) {
+		struct nfs_page *prev = nfs_list_entry(desc->pg_list.prev);
+		if (index != prev->wb_index + 1)
+			nfs_pageio_doio(desc);
+	}
+}
+
 #define NFS_SCAN_MAXENTRIES 16
 /**
  * nfs_scan_list - Scan a list for matching requests
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index b084c03..af344a1 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -273,8 +273,6 @@ static int nfs_page_async_flush(struct nfs_pageio_descriptor *pgio,
 		 *	 request as dirty (in which case we don't care).
 		 */
 		spin_unlock(req_lock);
-		/* Prevent deadlock! */
-		nfs_pageio_complete(pgio);
 		ret = nfs_wait_on_request(req);
 		nfs_release_request(req);
 		if (ret != 0)
@@ -321,6 +319,8 @@ static int nfs_writepage_locked(struct page *page, struct writeback_control *wbc
 		pgio = &mypgio;
 	}
 
+	nfs_pageio_cond_complete(pgio, page->index);
+
 	err = nfs_page_async_flush(pgio, page);
 	if (err <= 0)
 		goto out;
@@ -329,6 +329,8 @@ static int nfs_writepage_locked(struct page *page, struct writeback_control *wbc
 	if (!offset)
 		goto out;
 
+	nfs_pageio_cond_complete(pgio, page->index);
+
 	ctx = nfs_find_open_context(inode, NULL, FMODE_WRITE);
 	if (ctx == NULL) {
 		err = -EBADF;
diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 32ffea0..864090e 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -38,6 +38,7 @@
 #include <linux/inet.h>
 #include <linux/errno.h>
 #include <linux/delay.h>
+#include <linux/sched.h>
 #include <linux/sunrpc/xdr.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/sunrpc/clnt.h>
diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index c7774e3..ebd03cc 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -45,7 +45,7 @@
 #include <asm/uaccess.h>
 #include <asm/scatterlist.h>
 #include <linux/crypto.h>
-
+#include <linux/sched.h>
 
 #define NFSDDBG_FACILITY                NFSDDBG_PROC
 
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index d7759ce..ff55950 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -9,7 +9,7 @@
  */
 
 #include <linux/module.h>
-
+#include <linux/sched.h>
 #include <linux/time.h>
 #include <linux/errno.h>
 #include <linux/nfs.h>
diff --git a/fs/ntfs/file.c b/fs/ntfs/file.c
index 39a1669..7ed5639 100644
--- a/fs/ntfs/file.c
+++ b/fs/ntfs/file.c
@@ -26,6 +26,7 @@
 #include <linux/swap.h>
 #include <linux/uio.h>
 #include <linux/writeback.h>
+#include <linux/sched.h>
 
 #include <asm/page.h>
 #include <asm/uaccess.h>
diff --git a/fs/partitions/Kconfig b/fs/partitions/Kconfig
index 7638a1c..a99acd8 100644
--- a/fs/partitions/Kconfig
+++ b/fs/partitions/Kconfig
@@ -166,8 +166,12 @@ config LDM_PARTITION
 	depends on PARTITION_ADVANCED
 	---help---
 	  Say Y here if you would like to use hard disks under Linux which
-	  were partitioned using Windows 2000's or XP's Logical Disk Manager.
-	  They are also known as "Dynamic Disks".
+	  were partitioned using Windows 2000's/XP's or Vista's Logical Disk
+	  Manager.  They are also known as "Dynamic Disks".
+
+	  Note this driver only supports Dynamic Disks with a protective MBR
+	  label, i.e. DOS partition table.  It does not support GPT labelled
+	  Dynamic Disks yet as can be created with Vista.
 
 	  Windows 2000 introduced the concept of Dynamic Disks to get around
 	  the limitations of the PC's partitioning scheme.  The Logical Disk
@@ -175,8 +179,8 @@ config LDM_PARTITION
 	  mirrored, striped or RAID volumes, all without the need for
 	  rebooting.
 
-	  Normal partitions are now called Basic Disks under Windows 2000 and
-	  XP.
+	  Normal partitions are now called Basic Disks under Windows 2000, XP,
+	  and Vista.
 
 	  For a fuller description read <file:Documentation/ldm.txt>.
 
diff --git a/fs/partitions/ldm.c b/fs/partitions/ldm.c
index 1a60926..99873a2 100644
--- a/fs/partitions/ldm.c
+++ b/fs/partitions/ldm.c
@@ -2,10 +2,10 @@
  * ldm - Support for Windows Logical Disk Manager (Dynamic Disks)
  *
  * Copyright (C) 2001,2002 Richard Russon <ldm@flatcap.org>
- * Copyright (c) 2001-2004 Anton Altaparmakov
+ * Copyright (c) 2001-2007 Anton Altaparmakov
  * Copyright (C) 2001,2002 Jakob Kemi <jakob.kemi@telia.com>
  *
- * Documentation is available at http://linux-ntfs.sf.net/ldm
+ * Documentation is available at http://www.linux-ntfs.org/content/view/19/37/
  *
  * This program is free software; you can redistribute it and/or modify it under
  * the terms of the GNU General Public License as published by the Free Software
@@ -62,7 +62,6 @@ static void _ldm_printk (const char *level, const char *function,
 	printk ("%s%s(): %s\n", level, function, buf);
 }
 
-
 /**
  * ldm_parse_hexbyte - Convert a ASCII hex number to a byte
  * @src:  Pointer to at least 2 characters to convert.
@@ -118,7 +117,6 @@ static bool ldm_parse_guid (const u8 *src, u8 *dest)
 	return true;
 }
 
-
 /**
  * ldm_parse_privhead - Read the LDM Database PRIVHEAD structure
  * @data:  Raw database PRIVHEAD structure loaded from the device
@@ -130,46 +128,48 @@ static bool ldm_parse_guid (const u8 *src, u8 *dest)
  * Return:  'true'   @ph contains the PRIVHEAD data
  *          'false'  @ph contents are undefined
  */
-static bool ldm_parse_privhead (const u8 *data, struct privhead *ph)
+static bool ldm_parse_privhead(const u8 *data, struct privhead *ph)
 {
-	BUG_ON (!data || !ph);
+	bool is_vista = false;
 
-	if (MAGIC_PRIVHEAD != BE64 (data)) {
-		ldm_error ("Cannot find PRIVHEAD structure. LDM database is"
+	BUG_ON(!data || !ph);
+	if (MAGIC_PRIVHEAD != BE64(data)) {
+		ldm_error("Cannot find PRIVHEAD structure. LDM database is"
 			" corrupt. Aborting.");
 		return false;
 	}
-
-	ph->ver_major          = BE16 (data + 0x000C);
-	ph->ver_minor          = BE16 (data + 0x000E);
-	ph->logical_disk_start = BE64 (data + 0x011B);
-	ph->logical_disk_size  = BE64 (data + 0x0123);
-	ph->config_start       = BE64 (data + 0x012B);
-	ph->config_size        = BE64 (data + 0x0133);
-
-	if ((ph->ver_major != 2) || (ph->ver_minor != 11)) {
-		ldm_error ("Expected PRIVHEAD version %d.%d, got %d.%d."
-			" Aborting.", 2, 11, ph->ver_major, ph->ver_minor);
+	ph->ver_major = BE16(data + 0x000C);
+	ph->ver_minor = BE16(data + 0x000E);
+	ph->logical_disk_start = BE64(data + 0x011B);
+	ph->logical_disk_size = BE64(data + 0x0123);
+	ph->config_start = BE64(data + 0x012B);
+	ph->config_size = BE64(data + 0x0133);
+	/* Version 2.11 is Win2k/XP and version 2.12 is Vista. */
+	if (ph->ver_major == 2 && ph->ver_minor == 12)
+		is_vista = true;
+	if (!is_vista && (ph->ver_major != 2 || ph->ver_minor != 11)) {
+		ldm_error("Expected PRIVHEAD version 2.11 or 2.12, got %d.%d."
+			" Aborting.", ph->ver_major, ph->ver_minor);
 		return false;
 	}
+	ldm_debug("PRIVHEAD version %d.%d (Windows %s).", ph->ver_major,
+			ph->ver_minor, is_vista ? "Vista" : "2000/XP");
 	if (ph->config_size != LDM_DB_SIZE) {	/* 1 MiB in sectors. */
-		/* Warn the user and continue, carefully */
-		ldm_info ("Database is normally %u bytes, it claims to "
+		/* Warn the user and continue, carefully. */
+		ldm_info("Database is normally %u bytes, it claims to "
 			"be %llu bytes.", LDM_DB_SIZE,
-			(unsigned long long)ph->config_size );
+			(unsigned long long)ph->config_size);
 	}
-	if ((ph->logical_disk_size == 0) ||
-	    (ph->logical_disk_start + ph->logical_disk_size > ph->config_start)) {
-		ldm_error ("PRIVHEAD disk size doesn't match real disk size");
+	if ((ph->logical_disk_size == 0) || (ph->logical_disk_start +
+			ph->logical_disk_size > ph->config_start)) {
+		ldm_error("PRIVHEAD disk size doesn't match real disk size");
 		return false;
 	}
-
-	if (!ldm_parse_guid (data + 0x0030, ph->disk_id)) {
-		ldm_error ("PRIVHEAD contains an invalid GUID.");
+	if (!ldm_parse_guid(data + 0x0030, ph->disk_id)) {
+		ldm_error("PRIVHEAD contains an invalid GUID.");
 		return false;
 	}
-
-	ldm_debug ("Parsed PRIVHEAD successfully.");
+	ldm_debug("Parsed PRIVHEAD successfully.");
 	return true;
 }
 
@@ -409,7 +409,7 @@ out:
  * Return:  'true'   @toc1 contains validated TOCBLOCK info
  *          'false'  @toc1 contents are undefined
  */
-static bool ldm_validate_tocblocks (struct block_device *bdev,
+static bool ldm_validate_tocblocks(struct block_device *bdev,
 	unsigned long base, struct ldmdb *ldb)
 {
 	static const int off[4] = { OFF_TOCB1, OFF_TOCB2, OFF_TOCB3, OFF_TOCB4};
@@ -417,54 +417,57 @@ static bool ldm_validate_tocblocks (struct block_device *bdev,
 	struct privhead *ph;
 	Sector sect;
 	u8 *data;
+	int i, nr_tbs;
 	bool result = false;
-	int i;
 
-	BUG_ON (!bdev || !ldb);
-
-	ph    = &ldb->ph;
+	BUG_ON(!bdev || !ldb);
+	ph = &ldb->ph;
 	tb[0] = &ldb->toc;
-	tb[1] = kmalloc (sizeof (*tb[1]), GFP_KERNEL);
-	tb[2] = kmalloc (sizeof (*tb[2]), GFP_KERNEL);
-	tb[3] = kmalloc (sizeof (*tb[3]), GFP_KERNEL);
-	if (!tb[1] || !tb[2] || !tb[3]) {
-		ldm_crit ("Out of memory.");
-		goto out;
+	tb[1] = kmalloc(sizeof(*tb[1]) * 3, GFP_KERNEL);
+	if (!tb[1]) {
+		ldm_crit("Out of memory.");
+		goto err;
 	}
-
-	for (i = 0; i < 4; i++)		/* Read and parse all four toc's. */
-	{
-		data = read_dev_sector (bdev, base + off[i], &sect);
+	tb[2] = (struct tocblock*)((u8*)tb[1] + sizeof(*tb[1]));
+	tb[3] = (struct tocblock*)((u8*)tb[2] + sizeof(*tb[2]));
+	/*
+	 * Try to read and parse all four TOCBLOCKs.
+	 *
+	 * Windows Vista LDM v2.12 does not always have all four TOCBLOCKs so
+	 * skip any that fail as long as we get at least one valid TOCBLOCK.
+	 */
+	for (nr_tbs = i = 0; i < 4; i++) {
+		data = read_dev_sector(bdev, base + off[i], &sect);
 		if (!data) {
-			ldm_crit ("Disk read failed.");
-			goto out;
+			ldm_error("Disk read failed for TOCBLOCK %d.", i);
+			continue;
 		}
-		result = ldm_parse_tocblock (data, tb[i]);
-		put_dev_sector (sect);
-		if (!result)
-			goto out;	/* Already logged */
+		if (ldm_parse_tocblock(data, tb[nr_tbs]))
+			nr_tbs++;
+		put_dev_sector(sect);
 	}
-
-	/* Range check the toc against a privhead. */
+	if (!nr_tbs) {
+		ldm_crit("Failed to find a valid TOCBLOCK.");
+		goto err;
+	}
+	/* Range check the TOCBLOCK against a privhead. */
 	if (((tb[0]->bitmap1_start + tb[0]->bitmap1_size) > ph->config_size) ||
-	    ((tb[0]->bitmap2_start + tb[0]->bitmap2_size) > ph->config_size)) {
-		ldm_crit ("The bitmaps are out of range.  Giving up.");
-		goto out;
+			((tb[0]->bitmap2_start + tb[0]->bitmap2_size) >
+			ph->config_size)) {
+		ldm_crit("The bitmaps are out of range.  Giving up.");
+		goto err;
 	}
-
-	if (!ldm_compare_tocblocks (tb[0], tb[1]) ||	/* Compare all tocs. */
-	    !ldm_compare_tocblocks (tb[0], tb[2]) ||
-	    !ldm_compare_tocblocks (tb[0], tb[3])) {
-		ldm_crit ("The TOCBLOCKs don't match.");
-		goto out;
+	/* Compare all loaded TOCBLOCKs. */
+	for (i = 1; i < nr_tbs; i++) {
+		if (!ldm_compare_tocblocks(tb[0], tb[i])) {
+			ldm_crit("TOCBLOCKs 0 and %d do not match.", i);
+			goto err;
+		}
 	}
-
-	ldm_debug ("Validated TOCBLOCKs successfully.");
+	ldm_debug("Validated %d TOCBLOCKs successfully.", nr_tbs);
 	result = true;
-out:
-	kfree (tb[1]);
-	kfree (tb[2]);
-	kfree (tb[3]);
+err:
+	kfree(tb[1]);
 	return result;
 }
 
@@ -566,7 +569,7 @@ static bool ldm_validate_partition_table (struct block_device *bdev)
 
 	p = (struct partition*)(data + 0x01BE);
 	for (i = 0; i < 4; i++, p++)
-		if (SYS_IND (p) == WIN2K_DYNAMIC_PARTITION) {
+		if (SYS_IND (p) == LDM_PARTITION) {
 			result = true;
 			break;
 		}
@@ -975,44 +978,68 @@ static bool ldm_parse_dsk4 (const u8 *buffer, int buflen, struct vblk *vb)
  * Return:  'true'   @vb contains a Partition VBLK
  *          'false'  @vb contents are not defined
  */
-static bool ldm_parse_prt3 (const u8 *buffer, int buflen, struct vblk *vb)
+static bool ldm_parse_prt3(const u8 *buffer, int buflen, struct vblk *vb)
 {
 	int r_objid, r_name, r_size, r_parent, r_diskid, r_index, len;
 	struct vblk_part *part;
 
-	BUG_ON (!buffer || !vb);
-
-	r_objid  = ldm_relative (buffer, buflen, 0x18, 0);
-	r_name   = ldm_relative (buffer, buflen, 0x18, r_objid);
-	r_size   = ldm_relative (buffer, buflen, 0x34, r_name);
-	r_parent = ldm_relative (buffer, buflen, 0x34, r_size);
-	r_diskid = ldm_relative (buffer, buflen, 0x34, r_parent);
-
+	BUG_ON(!buffer || !vb);
+	r_objid = ldm_relative(buffer, buflen, 0x18, 0);
+	if (r_objid < 0) {
+		ldm_error("r_objid %d < 0", r_objid);
+		return false;
+	}
+	r_name = ldm_relative(buffer, buflen, 0x18, r_objid);
+	if (r_name < 0) {
+		ldm_error("r_name %d < 0", r_name);
+		return false;
+	}
+	r_size = ldm_relative(buffer, buflen, 0x34, r_name);
+	if (r_size < 0) {
+		ldm_error("r_size %d < 0", r_size);
+		return false;
+	}
+	r_parent = ldm_relative(buffer, buflen, 0x34, r_size);
+	if (r_parent < 0) {
+		ldm_error("r_parent %d < 0", r_parent);
+		return false;
+	}
+	r_diskid = ldm_relative(buffer, buflen, 0x34, r_parent);
+	if (r_diskid < 0) {
+		ldm_error("r_diskid %d < 0", r_diskid);
+		return false;
+	}
 	if (buffer[0x12] & VBLK_FLAG_PART_INDEX) {
-		r_index = ldm_relative (buffer, buflen, 0x34, r_diskid);
+		r_index = ldm_relative(buffer, buflen, 0x34, r_diskid);
+		if (r_index < 0) {
+			ldm_error("r_index %d < 0", r_index);
+			return false;
+		}
 		len = r_index;
 	} else {
 		r_index = 0;
 		len = r_diskid;
 	}
-	if (len < 0)
+	if (len < 0) {
+		ldm_error("len %d < 0", len);
 		return false;
-
+	}
 	len += VBLK_SIZE_PRT3;
-	if (len != BE32 (buffer + 0x14))
+	if (len > BE32(buffer + 0x14)) {
+		ldm_error("len %d > BE32(buffer + 0x14) %d", len,
+				BE32(buffer + 0x14));
 		return false;
-
+	}
 	part = &vb->vblk.part;
-	part->start         = BE64         (buffer + 0x24 + r_name);
-	part->volume_offset = BE64         (buffer + 0x2C + r_name);
-	part->size          = ldm_get_vnum (buffer + 0x34 + r_name);
-	part->parent_id     = ldm_get_vnum (buffer + 0x34 + r_size);
-	part->disk_id       = ldm_get_vnum (buffer + 0x34 + r_parent);
+	part->start = BE64(buffer + 0x24 + r_name);
+	part->volume_offset = BE64(buffer + 0x2C + r_name);
+	part->size = ldm_get_vnum(buffer + 0x34 + r_name);
+	part->parent_id = ldm_get_vnum(buffer + 0x34 + r_size);
+	part->disk_id = ldm_get_vnum(buffer + 0x34 + r_parent);
 	if (vb->flags & VBLK_FLAG_PART_INDEX)
 		part->partnum = buffer[0x35 + r_diskid];
 	else
 		part->partnum = 0;
-
 	return true;
 }
 
@@ -1475,4 +1502,3 @@ out:
 	kfree (ldb);
 	return result;
 }
-
diff --git a/fs/partitions/ldm.h b/fs/partitions/ldm.h
index 6e8d795..d2e6a30 100644
--- a/fs/partitions/ldm.h
+++ b/fs/partitions/ldm.h
@@ -2,10 +2,10 @@
  * ldm - Part of the Linux-NTFS project.
  *
  * Copyright (C) 2001,2002 Richard Russon <ldm@flatcap.org>
- * Copyright (C) 2001      Anton Altaparmakov <aia21@cantab.net>
+ * Copyright (c) 2001-2007 Anton Altaparmakov
  * Copyright (C) 2001,2002 Jakob Kemi <jakob.kemi@telia.com>
  *
- * Documentation is available at http://linux-ntfs.sf.net/ldm
+ * Documentation is available at http://www.linux-ntfs.org/content/view/19/37/
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -93,7 +93,7 @@ struct parsed_partitions;
 
 #define OFF_VMDB		17		/* List of partitions. */
 
-#define WIN2K_DYNAMIC_PARTITION	0x42		/* Formerly SFS (Landis). */
+#define LDM_PARTITION		0x42		/* Formerly SFS (Landis). */
 
 #define TOC_BITMAP1		"config"	/* Names of the two defined */
 #define TOC_BITMAP2		"log"		/* bitmaps in the TOCBLOCK. */
diff --git a/fs/ramfs/inode.c b/fs/ramfs/inode.c
index 4ace5d7..d40d22b 100644
--- a/fs/ramfs/inode.c
+++ b/fs/ramfs/inode.c
@@ -32,7 +32,7 @@
 #include <linux/string.h>
 #include <linux/backing-dev.h>
 #include <linux/ramfs.h>
-
+#include <linux/sched.h>
 #include <asm/uaccess.h>
 #include "internal.h"
 
diff --git a/fs/reiserfs/dir.c b/fs/reiserfs/dir.c
index 9c23fee..ffbfc2c 100644
--- a/fs/reiserfs/dir.c
+++ b/fs/reiserfs/dir.c
@@ -10,7 +10,7 @@
 #include <linux/buffer_head.h>
 #include <asm/uaccess.h>
 
-extern struct reiserfs_key MIN_KEY;
+extern const struct reiserfs_key MIN_KEY;
 
 static int reiserfs_readdir(struct file *, void *, filldir_t);
 static int reiserfs_dir_fsync(struct file *filp, struct dentry *dentry,
diff --git a/fs/signalfd.c b/fs/signalfd.c
index 7cfeab4..f1da892 100644
--- a/fs/signalfd.c
+++ b/fs/signalfd.c
@@ -11,6 +11,8 @@
  *      Now using anonymous inode source.
  *      Thanks to Oleg Nesterov for useful code review and suggestions.
  *      More comments and suggestions from Arnd Bergmann.
+ * Sat May 19, 2007: Davi E. M. Arnaut <davi@haxent.com.br>
+ *      Retrieve multiple signals with one read() call
  */
 
 #include <linux/file.h>
@@ -206,6 +208,59 @@ static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,
 	return err ? -EFAULT: sizeof(*uinfo);
 }
 
+static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, siginfo_t *info,
+				int nonblock)
+{
+	ssize_t ret;
+	struct signalfd_lockctx lk;
+	DECLARE_WAITQUEUE(wait, current);
+
+	if (!signalfd_lock(ctx, &lk))
+		return 0;
+
+	ret = dequeue_signal(lk.tsk, &ctx->sigmask, info);
+	switch (ret) {
+	case 0:
+		if (!nonblock)
+			break;
+		ret = -EAGAIN;
+	default:
+		signalfd_unlock(&lk);
+		return ret;
+	}
+
+	add_wait_queue(&ctx->wqh, &wait);
+	for (;;) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		ret = dequeue_signal(lk.tsk, &ctx->sigmask, info);
+		signalfd_unlock(&lk);
+		if (ret != 0)
+			break;
+		if (signal_pending(current)) {
+			ret = -ERESTARTSYS;
+			break;
+		}
+		schedule();
+		ret = signalfd_lock(ctx, &lk);
+		if (unlikely(!ret)) {
+			/*
+			 * Let the caller read zero byte, ala socket
+			 * recv() when the peer disconnect. This test
+			 * must be done before doing a dequeue_signal(),
+			 * because if the sighand has been orphaned,
+			 * the dequeue_signal() call is going to crash
+			 * because ->sighand will be long gone.
+			 */
+			 break;
+		}
+	}
+
+	remove_wait_queue(&ctx->wqh, &wait);
+	__set_current_state(TASK_RUNNING);
+
+	return ret;
+}
+
 /*
  * Returns either the size of a "struct signalfd_siginfo", or zero if the
  * sighand we are attached to, has been orphaned. The "count" parameter
@@ -215,55 +270,30 @@ static ssize_t signalfd_read(struct file *file, char __user *buf, size_t count,
 			     loff_t *ppos)
 {
 	struct signalfd_ctx *ctx = file->private_data;
-	ssize_t res = 0;
-	int locked, signo;
+	struct signalfd_siginfo __user *siginfo;
+	int nonblock = file->f_flags & O_NONBLOCK;
+	ssize_t ret, total = 0;
 	siginfo_t info;
-	struct signalfd_lockctx lk;
-	DECLARE_WAITQUEUE(wait, current);
 
-	if (count < sizeof(struct signalfd_siginfo))
+	count /= sizeof(struct signalfd_siginfo);
+	if (!count)
 		return -EINVAL;
-	locked = signalfd_lock(ctx, &lk);
-	if (!locked)
-		return 0;
-	res = -EAGAIN;
-	signo = dequeue_signal(lk.tsk, &ctx->sigmask, &info);
-	if (signo == 0 && !(file->f_flags & O_NONBLOCK)) {
-		add_wait_queue(&ctx->wqh, &wait);
-		for (;;) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			signo = dequeue_signal(lk.tsk, &ctx->sigmask, &info);
-			if (signo != 0)
-				break;
-			if (signal_pending(current)) {
-				res = -ERESTARTSYS;
-				break;
-			}
-			signalfd_unlock(&lk);
-			schedule();
-			locked = signalfd_lock(ctx, &lk);
-			if (unlikely(!locked)) {
-				/*
-				 * Let the caller read zero byte, ala socket
-				 * recv() when the peer disconnect. This test
-				 * must be done before doing a dequeue_signal(),
-				 * because if the sighand has been orphaned,
-				 * the dequeue_signal() call is going to crash.
-				 */
-				res = 0;
-				break;
-			}
-		}
-		remove_wait_queue(&ctx->wqh, &wait);
-		__set_current_state(TASK_RUNNING);
-	}
-	if (likely(locked))
-		signalfd_unlock(&lk);
-	if (likely(signo))
-		res = signalfd_copyinfo((struct signalfd_siginfo __user *) buf,
-					&info);
 
-	return res;
+	siginfo = (struct signalfd_siginfo __user *) buf;
+
+	do {
+		ret = signalfd_dequeue(ctx, &info, nonblock);
+		if (unlikely(ret <= 0))
+			break;
+		ret = signalfd_copyinfo(siginfo, &info);
+		if (ret < 0)
+			break;
+		siginfo++;
+		total += ret;
+		nonblock = 1;
+	} while (--count);
+
+	return total ? total : ret;
 }
 
 static const struct file_operations signalfd_fops = {
diff --git a/fs/smbfs/dir.c b/fs/smbfs/dir.c
index 50136b1..48da4fa 100644
--- a/fs/smbfs/dir.c
+++ b/fs/smbfs/dir.c
@@ -13,6 +13,7 @@
 #include <linux/smp_lock.h>
 #include <linux/ctype.h>
 #include <linux/net.h>
+#include <linux/sched.h>
 
 #include <linux/smb_fs.h>
 #include <linux/smb_mount.h>
diff --git a/fs/smbfs/file.c b/fs/smbfs/file.c
index f161797..aea3f8a 100644
--- a/fs/smbfs/file.c
+++ b/fs/smbfs/file.c
@@ -17,6 +17,7 @@
 #include <linux/pagemap.h>
 #include <linux/smp_lock.h>
 #include <linux/net.h>
+#include <linux/aio.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
diff --git a/fs/smbfs/inode.c b/fs/smbfs/inode.c
index 5c9243a..6724a6c 100644
--- a/fs/smbfs/inode.c
+++ b/fs/smbfs/inode.c
@@ -25,6 +25,7 @@
 #include <linux/net.h>
 #include <linux/vfs.h>
 #include <linux/highuid.h>
+#include <linux/sched.h>
 #include <linux/smb_fs.h>
 #include <linux/smbno.h>
 #include <linux/smb_mount.h>
diff --git a/fs/smbfs/request.c b/fs/smbfs/request.c
index c288fbe..3f54a0f 100644
--- a/fs/smbfs/request.c
+++ b/fs/smbfs/request.c
@@ -11,6 +11,7 @@
 #include <linux/fs.h>
 #include <linux/slab.h>
 #include <linux/net.h>
+#include <linux/sched.h>
 
 #include <linux/smb_fs.h>
 #include <linux/smbno.h>
diff --git a/fs/sysfs/inode.c b/fs/sysfs/inode.c
index 4de5c6b..bdd30e7 100644
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@ -13,6 +13,7 @@
 #include <linux/backing-dev.h>
 #include <linux/capability.h>
 #include <linux/errno.h>
+#include <linux/sched.h>
 #include <asm/semaphore.h>
 #include "sysfs.h"
 
diff --git a/fs/udf/file.c b/fs/udf/file.c
index 40d5047..51b5764 100644
--- a/fs/udf/file.c
+++ b/fs/udf/file.c
@@ -36,6 +36,7 @@
 #include <linux/smp_lock.h>
 #include <linux/pagemap.h>
 #include <linux/buffer_head.h>
+#include <linux/aio.h>
 
 #include "udf_i.h"
 #include "udf_sb.h"
diff --git a/fs/udf/namei.c b/fs/udf/namei.c
index 91df492..51fe307 100644
--- a/fs/udf/namei.c
+++ b/fs/udf/namei.c
@@ -30,6 +30,7 @@
 #include <linux/quotaops.h>
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
+#include <linux/sched.h>
 
 static inline int udf_match(int len1, const char *name1, int len2, const char *name2)
 {
diff --git a/include/asm-arm/arch-at91/at91_adc.h b/include/asm-arm/arch-at91/at91_adc.h
index 1ed66ea..6d71ea2 100644
--- a/include/asm-arm/arch-at91/at91_adc.h
+++ b/include/asm-arm/arch-at91/at91_adc.h
@@ -55,7 +55,7 @@
 #define AT91_ADC_IDR		0x28		/* Interrupt Disable Register */
 #define AT91_ADC_IMR		0x2C		/* Interrupt Mask Register */
 
-#define AT91_ADC_CHR(n)		(0x30 + ((n) * 4)	/* Channel Data Register N */
+#define AT91_ADC_CHR(n)		(0x30 + ((n) * 4))	/* Channel Data Register N */
 #define		AT91_ADC_DATA		(0x3ff)
 
 #endif
diff --git a/include/asm-arm/arch-integrator/smp.h b/include/asm-arm/arch-integrator/smp.h
deleted file mode 100644
index ab2c79b..0000000
--- a/include/asm-arm/arch-integrator/smp.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef ASMARM_ARCH_SMP_H
-#define ASMARM_ARCH_SMP_H
-
-
-#include <asm/hardware.h>
-#include <asm/io.h>
-
-#define hard_smp_processor_id()				\
-	({						\
-		unsigned int cpunum;			\
-		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
-			: "=r" (cpunum));		\
-		cpunum &= 0x0F;				\
-	})
-
-extern void secondary_scan_irqs(void);
-
-#endif
diff --git a/include/asm-arm/arch-s3c2410/irqs.h b/include/asm-arm/arch-s3c2410/irqs.h
index c79cb18..3b49cd1 100644
--- a/include/asm-arm/arch-s3c2410/irqs.h
+++ b/include/asm-arm/arch-s3c2410/irqs.h
@@ -124,7 +124,7 @@
 #define IRQ_S3C2443_DMA		S3C2410_IRQ(17)		/* IRQ_DMA1 */
 #define IRQ_S3C2443_UART3	S3C2410_IRQ(18)		/* IRQ_DMA2 */
 #define IRQ_S3C2443_CFCON	S3C2410_IRQ(19)		/* IRQ_DMA3 */
-#define IRQ_S3C2443_SDI1	S3C2410_IRQ(20)		/* IRQ_SDI */
+#define IRQ_S3C2443_HSMMC	S3C2410_IRQ(20)		/* IRQ_SDI */
 #define IRQ_S3C2443_NAND	S3C2410_IRQ(24)		/* reserved */
 
 #define IRQ_S3C2443_LCD1	S3C2410_IRQSUB(14)
diff --git a/include/asm-arm/arch-s3c2410/regs-spi.h b/include/asm-arm/arch-s3c2410/regs-spi.h
index 3552280..4a499a1 100644
--- a/include/asm-arm/arch-s3c2410/regs-spi.h
+++ b/include/asm-arm/arch-s3c2410/regs-spi.h
@@ -12,6 +12,8 @@
 #ifndef __ASM_ARCH_REGS_SPI_H
 #define __ASM_ARCH_REGS_SPI_H
 
+#define S3C2410_SPI1	(0x20)
+#define S3C2412_SPI1	(0x100)
 
 #define S3C2410_SPCON	(0x00)
 
diff --git a/include/asm-arm/io.h b/include/asm-arm/io.h
index 8261ff9..1d3caa4 100644
--- a/include/asm-arm/io.h
+++ b/include/asm-arm/io.h
@@ -259,9 +259,11 @@ extern void pci_iounmap(struct pci_dev *dev, void __iomem *addr);
 #define BIOVEC_MERGEABLE(vec1, vec2)	\
 	((bvec_to_phys((vec1)) + (vec1)->bv_len) == bvec_to_phys((vec2)))
 
+#ifdef CONFIG_MMU
 #define ARCH_HAS_VALID_PHYS_ADDR_RANGE
 extern int valid_phys_addr_range(unsigned long addr, size_t size);
 extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+#endif
 
 /*
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
diff --git a/include/asm-arm/mmu.h b/include/asm-arm/mmu.h
index fe2a23b..53099d4 100644
--- a/include/asm-arm/mmu.h
+++ b/include/asm-arm/mmu.h
@@ -4,13 +4,13 @@
 #ifdef CONFIG_MMU
 
 typedef struct {
-#if __LINUX_ARM_ARCH__ >= 6
+#ifdef CONFIG_CPU_HAS_ASID
 	unsigned int id;
 #endif
 	unsigned int kvm_seq;
 } mm_context_t;
 
-#if __LINUX_ARM_ARCH__ >= 6
+#ifdef CONFIG_CPU_HAS_ASID
 #define ASID(mm)	((mm)->context.id & 255)
 #else
 #define ASID(mm)	(0)
diff --git a/include/asm-arm/mmu_context.h b/include/asm-arm/mmu_context.h
index 4981ad4..6913d02 100644
--- a/include/asm-arm/mmu_context.h
+++ b/include/asm-arm/mmu_context.h
@@ -20,7 +20,7 @@
 
 void __check_kvm_seq(struct mm_struct *mm);
 
-#if __LINUX_ARM_ARCH__ >= 6
+#ifdef CONFIG_CPU_HAS_ASID
 
 /*
  * On ARMv6, we have the following structure in the Context ID:
diff --git a/include/asm-arm/plat-s3c24xx/devs.h b/include/asm-arm/plat-s3c24xx/devs.h
index dddf485..f9d6f03 100644
--- a/include/asm-arm/plat-s3c24xx/devs.h
+++ b/include/asm-arm/plat-s3c24xx/devs.h
@@ -29,6 +29,7 @@ extern struct platform_device s3c_device_iis;
 extern struct platform_device s3c_device_rtc;
 extern struct platform_device s3c_device_adc;
 extern struct platform_device s3c_device_sdi;
+extern struct platform_device s3c_device_hsmmc;
 
 extern struct platform_device s3c_device_spi0;
 extern struct platform_device s3c_device_spi1;
diff --git a/include/asm-arm/tlbflush.h b/include/asm-arm/tlbflush.h
index 08c6991..ccd0de0 100644
--- a/include/asm-arm/tlbflush.h
+++ b/include/asm-arm/tlbflush.h
@@ -144,6 +144,8 @@
 
 #ifndef __ASSEMBLY__
 
+#include <linux/sched.h>
+
 struct cpu_tlb_fns {
 	void (*flush_user_range)(unsigned long, unsigned long, struct vm_area_struct *);
 	void (*flush_kern_range)(unsigned long, unsigned long);
diff --git a/include/asm-arm/unistd.h b/include/asm-arm/unistd.h
index c025ab4..250d7f1 100644
--- a/include/asm-arm/unistd.h
+++ b/include/asm-arm/unistd.h
@@ -373,6 +373,10 @@
 #define __NR_getcpu			(__NR_SYSCALL_BASE+345)
 					/* 346 for epoll_pwait */
 #define __NR_kexec_load			(__NR_SYSCALL_BASE+347)
+#define __NR_utimensat			(__NR_SYSCALL_BASE+348)
+#define __NR_signalfd			(__NR_SYSCALL_BASE+349)
+#define __NR_timerfd			(__NR_SYSCALL_BASE+350)
+#define __NR_eventfd			(__NR_SYSCALL_BASE+351)
 
 /*
  * The following SWIs are ARM private.
@@ -433,5 +437,11 @@
  */
 #define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
 
+/*
+ * Unimplemented (or alternatively implemented) syscalls
+ */
+#define __IGNORE_sync_file_range	1
+#define __IGNORE_fadvise64_64		1
+
 #endif /* __KERNEL__ */
 #endif /* __ASM_ARM_UNISTD_H */
diff --git a/include/asm-blackfin/bfin-global.h b/include/asm-blackfin/bfin-global.h
index e37f816..57f37cc 100644
--- a/include/asm-blackfin/bfin-global.h
+++ b/include/asm-blackfin/bfin-global.h
@@ -104,6 +104,7 @@ extern unsigned long dpdt_swapcount_table[];
 
 extern unsigned long table_start, table_end;
 
+extern u16 _bfin_swrst; /* shadow for Software Reset Register (SWRST) */
 extern struct file_operations dpmc_fops;
 extern char _start;
 extern unsigned long _ramstart, _ramend, _rambase;
diff --git a/include/asm-blackfin/gpio.h b/include/asm-blackfin/gpio.h
index d16fe3c..aa0d550 100644
--- a/include/asm-blackfin/gpio.h
+++ b/include/asm-blackfin/gpio.h
@@ -148,10 +148,6 @@
 
 #ifdef BF537_FAMILY
 #define MAX_BLACKFIN_GPIOS 48
-#define PORT_F 0
-#define PORT_G 1
-#define PORT_H 2
-#define PORT_J 3
 
 #define	GPIO_PF0	0
 #define	GPIO_PF1	1
@@ -202,13 +198,17 @@
 #define	GPIO_PH14      	46
 #define	GPIO_PH15      	47
 
+#define PORT_F GPIO_PF0
+#define PORT_G GPIO_PG0
+#define PORT_H GPIO_PH0
+
 #endif
 
 #ifdef BF561_FAMILY
 #define MAX_BLACKFIN_GPIOS 48
-#define PORT_FIO0 0
-#define PORT_FIO1 1
-#define PORT_FIO2 2
+#define PORT_FIO0 GPIO_0
+#define PORT_FIO1 GPIO_16
+#define PORT_FIO2 GPIO_32
 #endif
 
 #ifndef __ASSEMBLY__
diff --git a/include/asm-blackfin/io.h b/include/asm-blackfin/io.h
index 7e6995e..eac8bca 100644
--- a/include/asm-blackfin/io.h
+++ b/include/asm-blackfin/io.h
@@ -115,13 +115,21 @@ static inline unsigned int readl(void __iomem *addr)
 
 #ifndef __ASSEMBLY__
 
-extern void outsb(void __iomem *port, const void *addr, unsigned long count);
-extern void outsw(void __iomem *port, const void *addr, unsigned long count);
-extern void outsl(void __iomem *port, const void *addr, unsigned long count);
+extern void outsb(void __iomem *port, const void *addr, unsigned short count);
+extern void outsw(void __iomem *port, const void *addr, unsigned short count);
+extern void outsl(void __iomem *port, const void *addr, unsigned short count);
 
-extern void insb(const void __iomem *port, void *addr, unsigned long count);
-extern void insw(const void __iomem *port, void *addr, unsigned long count);
-extern void insl(const void __iomem *port, void *addr, unsigned long count);
+extern void insb(const void __iomem *port, void *addr, unsigned short count);
+extern void insw(const void __iomem *port, void *addr, unsigned short count);
+extern void insl(const void __iomem *port, void *addr, unsigned short count);
+
+extern void dma_outsb(void __iomem *port, const void *addr, unsigned short count);
+extern void dma_outsw(void __iomem *port, const void *addr, unsigned short count);
+extern void dma_outsl(void __iomem *port, const void *addr, unsigned short count);
+
+extern void dma_insb(const void __iomem *port, void *addr, unsigned short count);
+extern void dma_insw(const void __iomem *port, void *addr, unsigned short count);
+extern void dma_insl(const void __iomem *port, void *addr, unsigned short count);
 
 /*
  * Map some physical address range into the kernel address space.
diff --git a/include/asm-blackfin/mach-bf527/cdefBF522.h b/include/asm-blackfin/mach-bf527/cdefBF522.h
new file mode 100644
index 0000000..52c0649
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/cdefBF522.h
@@ -0,0 +1,46 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/cdefbf522.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  system mmr register map
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF522_H
+#define _CDEF_BF522_H
+
+/* include all Core registers and bit definitions */
+#include "defBF522.h"
+
+/* include core specific register pointer definitions */
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF522 */
+
+/* include cdefBF52x_base.h for the set of #defines that are common to all ADSP-BF52x processors */
+#include "cdefBF52x_base.h"
+
+#endif /* _CDEF_BF522_H */
diff --git a/include/asm-blackfin/mach-bf527/cdefBF525.h b/include/asm-blackfin/mach-bf527/cdefBF525.h
new file mode 100644
index 0000000..2cc67e4
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/cdefBF525.h
@@ -0,0 +1,461 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/cdefbf525.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  system mmr register map
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF525_H
+#define _CDEF_BF525_H
+
+/* include all Core registers and bit definitions */
+#include "defBF525.h"
+
+/* include core specific register pointer definitions */
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF525 */
+
+/* include cdefBF52x_base.h for the set of #defines that are common to all ADSP-BF52x processors */
+#include "cdefBF52x_base.h"
+
+/* The following are the #defines needed by ADSP-BF525 that are not in the common header */
+
+/* USB Control Registers */
+
+#define bfin_read_USB_FADDR()			bfin_read16(USB_FADDR)
+#define bfin_write_USB_FADDR(val)		bfin_write16(USB_FADDR, val)
+#define bfin_read_USB_POWER()			bfin_read16(USB_POWER)
+#define bfin_write_USB_POWER(val)		bfin_write16(USB_POWER, val)
+#define bfin_read_USB_INTRTX()			bfin_read16(USB_INTRTX)
+#define bfin_write_USB_INTRTX(val)		bfin_write16(USB_INTRTX, val)
+#define bfin_read_USB_INTRRX()			bfin_read16(USB_INTRRX)
+#define bfin_write_USB_INTRRX(val)		bfin_write16(USB_INTRRX, val)
+#define bfin_read_USB_INTRTXE()			bfin_read16(USB_INTRTXE)
+#define bfin_write_USB_INTRTXE(val)		bfin_write16(USB_INTRTXE, val)
+#define bfin_read_USB_INTRRXE()			bfin_read16(USB_INTRRXE)
+#define bfin_write_USB_INTRRXE(val)		bfin_write16(USB_INTRRXE, val)
+#define bfin_read_USB_INTRUSB()			bfin_read16(USB_INTRUSB)
+#define bfin_write_USB_INTRUSB(val)		bfin_write16(USB_INTRUSB, val)
+#define bfin_read_USB_INTRUSBE()		bfin_read16(USB_INTRUSBE)
+#define bfin_write_USB_INTRUSBE(val)		bfin_write16(USB_INTRUSBE, val)
+#define bfin_read_USB_FRAME()			bfin_read16(USB_FRAME)
+#define bfin_write_USB_FRAME(val)		bfin_write16(USB_FRAME, val)
+#define bfin_read_USB_INDEX()			bfin_read16(USB_INDEX)
+#define bfin_write_USB_INDEX(val)		bfin_write16(USB_INDEX, val)
+#define bfin_read_USB_TESTMODE()		bfin_read16(USB_TESTMODE)
+#define bfin_write_USB_TESTMODE(val)		bfin_write16(USB_TESTMODE, val)
+#define bfin_read_USB_GLOBINTR()		bfin_read16(USB_GLOBINTR)
+#define bfin_write_USB_GLOBINTR(val)		bfin_write16(USB_GLOBINTR, val)
+#define bfin_read_USB_GLOBAL_CTL()		bfin_read16(USB_GLOBAL_CTL)
+#define bfin_write_USB_GLOBAL_CTL(val)		bfin_write16(USB_GLOBAL_CTL, val)
+
+/* USB Packet Control Registers */
+
+#define bfin_read_USB_TX_MAX_PACKET()		bfin_read16(USB_TX_MAX_PACKET)
+#define bfin_write_USB_TX_MAX_PACKET(val)	bfin_write16(USB_TX_MAX_PACKET, val)
+#define bfin_read_USB_CSR0()			bfin_read16(USB_CSR0)
+#define bfin_write_USB_CSR0(val)		bfin_write16(USB_CSR0, val)
+#define bfin_read_USB_TXCSR()			bfin_read16(USB_TXCSR)
+#define bfin_write_USB_TXCSR(val)		bfin_write16(USB_TXCSR, val)
+#define bfin_read_USB_RX_MAX_PACKET()		bfin_read16(USB_RX_MAX_PACKET)
+#define bfin_write_USB_RX_MAX_PACKET(val)	bfin_write16(USB_RX_MAX_PACKET, val)
+#define bfin_read_USB_RXCSR()			bfin_read16(USB_RXCSR)
+#define bfin_write_USB_RXCSR(val)		bfin_write16(USB_RXCSR, val)
+#define bfin_read_USB_COUNT0()			bfin_read16(USB_COUNT0)
+#define bfin_write_USB_COUNT0(val)		bfin_write16(USB_COUNT0, val)
+#define bfin_read_USB_RXCOUNT()			bfin_read16(USB_RXCOUNT)
+#define bfin_write_USB_RXCOUNT(val)		bfin_write16(USB_RXCOUNT, val)
+#define bfin_read_USB_TXTYPE()			bfin_read16(USB_TXTYPE)
+#define bfin_write_USB_TXTYPE(val)		bfin_write16(USB_TXTYPE, val)
+#define bfin_read_USB_NAKLIMIT0()		bfin_read16(USB_NAKLIMIT0)
+#define bfin_write_USB_NAKLIMIT0(val)		bfin_write16(USB_NAKLIMIT0, val)
+#define bfin_read_USB_TXINTERVAL()		bfin_read16(USB_TXINTERVAL)
+#define bfin_write_USB_TXINTERVAL(val)		bfin_write16(USB_TXINTERVAL, val)
+#define bfin_read_USB_RXTYPE()			bfin_read16(USB_RXTYPE)
+#define bfin_write_USB_RXTYPE(val)		bfin_write16(USB_RXTYPE, val)
+#define bfin_read_USB_RXINTERVAL()		bfin_read16(USB_RXINTERVAL)
+#define bfin_write_USB_RXINTERVAL(val)		bfin_write16(USB_RXINTERVAL, val)
+#define bfin_read_USB_TXCOUNT()			bfin_read16(USB_TXCOUNT)
+#define bfin_write_USB_TXCOUNT(val)		bfin_write16(USB_TXCOUNT, val)
+
+/* USB Endpoint FIFO Registers */
+
+#define bfin_read_USB_EP0_FIFO()		bfin_read16(USB_EP0_FIFO)
+#define bfin_write_USB_EP0_FIFO(val)		bfin_write16(USB_EP0_FIFO, val)
+#define bfin_read_USB_EP1_FIFO()		bfin_read16(USB_EP1_FIFO)
+#define bfin_write_USB_EP1_FIFO(val)		bfin_write16(USB_EP1_FIFO, val)
+#define bfin_read_USB_EP2_FIFO()		bfin_read16(USB_EP2_FIFO)
+#define bfin_write_USB_EP2_FIFO(val)		bfin_write16(USB_EP2_FIFO, val)
+#define bfin_read_USB_EP3_FIFO()		bfin_read16(USB_EP3_FIFO)
+#define bfin_write_USB_EP3_FIFO(val)		bfin_write16(USB_EP3_FIFO, val)
+#define bfin_read_USB_EP4_FIFO()		bfin_read16(USB_EP4_FIFO)
+#define bfin_write_USB_EP4_FIFO(val)		bfin_write16(USB_EP4_FIFO, val)
+#define bfin_read_USB_EP5_FIFO()		bfin_read16(USB_EP5_FIFO)
+#define bfin_write_USB_EP5_FIFO(val)		bfin_write16(USB_EP5_FIFO, val)
+#define bfin_read_USB_EP6_FIFO()		bfin_read16(USB_EP6_FIFO)
+#define bfin_write_USB_EP6_FIFO(val)		bfin_write16(USB_EP6_FIFO, val)
+#define bfin_read_USB_EP7_FIFO()		bfin_read16(USB_EP7_FIFO)
+#define bfin_write_USB_EP7_FIFO(val)		bfin_write16(USB_EP7_FIFO, val)
+
+/* USB OTG Control Registers */
+
+#define bfin_read_USB_OTG_DEV_CTL()		bfin_read16(USB_OTG_DEV_CTL)
+#define bfin_write_USB_OTG_DEV_CTL(val)		bfin_write16(USB_OTG_DEV_CTL, val)
+#define bfin_read_USB_OTG_VBUS_IRQ()		bfin_read16(USB_OTG_VBUS_IRQ)
+#define bfin_write_USB_OTG_VBUS_IRQ(val)	bfin_write16(USB_OTG_VBUS_IRQ, val)
+#define bfin_read_USB_OTG_VBUS_MASK()		bfin_read16(USB_OTG_VBUS_MASK)
+#define bfin_write_USB_OTG_VBUS_MASK(val)	bfin_write16(USB_OTG_VBUS_MASK, val)
+
+/* USB Phy Control Registers */
+
+#define bfin_read_USB_LINKINFO()		bfin_read16(USB_LINKINFO)
+#define bfin_write_USB_LINKINFO(val)		bfin_write16(USB_LINKINFO, val)
+#define bfin_read_USB_VPLEN()			bfin_read16(USB_VPLEN)
+#define bfin_write_USB_VPLEN(val)		bfin_write16(USB_VPLEN, val)
+#define bfin_read_USB_HS_EOF1()			bfin_read16(USB_HS_EOF1)
+#define bfin_write_USB_HS_EOF1(val)		bfin_write16(USB_HS_EOF1, val)
+#define bfin_read_USB_FS_EOF1()			bfin_read16(USB_FS_EOF1)
+#define bfin_write_USB_FS_EOF1(val)		bfin_write16(USB_FS_EOF1, val)
+#define bfin_read_USB_LS_EOF1()			bfin_read16(USB_LS_EOF1)
+#define bfin_write_USB_LS_EOF1(val)		bfin_write16(USB_LS_EOF1, val)
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CNTRL()		bfin_read16(USB_APHY_CNTRL)
+#define bfin_write_USB_APHY_CNTRL(val)		bfin_write16(USB_APHY_CNTRL, val)
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CALIB()		bfin_read16(USB_APHY_CALIB)
+#define bfin_write_USB_APHY_CALIB(val)		bfin_write16(USB_APHY_CALIB, val)
+
+#define bfin_read_USB_APHY_CNTRL2()		bfin_read16(USB_APHY_CNTRL2)
+#define bfin_write_USB_APHY_CNTRL2(val)		bfin_write16(USB_APHY_CNTRL2, val)
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define bfin_read_USB_PHY_TEST()		bfin_read16(USB_PHY_TEST)
+#define bfin_write_USB_PHY_TEST(val)		bfin_write16(USB_PHY_TEST, val)
+
+#define bfin_read_USB_PLLOSC_CTRL()		bfin_read16(USB_PLLOSC_CTRL)
+#define bfin_write_USB_PLLOSC_CTRL(val)		bfin_write16(USB_PLLOSC_CTRL, val)
+#define bfin_read_USB_SRP_CLKDIV()		bfin_read16(USB_SRP_CLKDIV)
+#define bfin_write_USB_SRP_CLKDIV(val)		bfin_write16(USB_SRP_CLKDIV, val)
+
+/* USB Endpoint 0 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXMAXP()		bfin_read16(USB_EP_NI0_TXMAXP)
+#define bfin_write_USB_EP_NI0_TXMAXP(val)	bfin_write16(USB_EP_NI0_TXMAXP, val)
+#define bfin_read_USB_EP_NI0_TXCSR()		bfin_read16(USB_EP_NI0_TXCSR)
+#define bfin_write_USB_EP_NI0_TXCSR(val)	bfin_write16(USB_EP_NI0_TXCSR, val)
+#define bfin_read_USB_EP_NI0_RXMAXP()		bfin_read16(USB_EP_NI0_RXMAXP)
+#define bfin_write_USB_EP_NI0_RXMAXP(val)	bfin_write16(USB_EP_NI0_RXMAXP, val)
+#define bfin_read_USB_EP_NI0_RXCSR()		bfin_read16(USB_EP_NI0_RXCSR)
+#define bfin_write_USB_EP_NI0_RXCSR(val)	bfin_write16(USB_EP_NI0_RXCSR, val)
+#define bfin_read_USB_EP_NI0_RXCOUNT()		bfin_read16(USB_EP_NI0_RXCOUNT)
+#define bfin_write_USB_EP_NI0_RXCOUNT(val)	bfin_write16(USB_EP_NI0_RXCOUNT, val)
+#define bfin_read_USB_EP_NI0_TXTYPE()		bfin_read16(USB_EP_NI0_TXTYPE)
+#define bfin_write_USB_EP_NI0_TXTYPE(val)	bfin_write16(USB_EP_NI0_TXTYPE, val)
+#define bfin_read_USB_EP_NI0_TXINTERVAL()	bfin_read16(USB_EP_NI0_TXINTERVAL)
+#define bfin_write_USB_EP_NI0_TXINTERVAL(val)	bfin_write16(USB_EP_NI0_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI0_RXTYPE()		bfin_read16(USB_EP_NI0_RXTYPE)
+#define bfin_write_USB_EP_NI0_RXTYPE(val)	bfin_write16(USB_EP_NI0_RXTYPE, val)
+#define bfin_read_USB_EP_NI0_RXINTERVAL()	bfin_read16(USB_EP_NI0_RXINTERVAL)
+#define bfin_write_USB_EP_NI0_RXINTERVAL(val)	bfin_write16(USB_EP_NI0_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI0_TXCOUNT()		bfin_read16(USB_EP_NI0_TXCOUNT)
+#define bfin_write_USB_EP_NI0_TXCOUNT(val)	bfin_write16(USB_EP_NI0_TXCOUNT, val)
+
+/* USB Endpoint 1 Control Registers */
+
+#define bfin_read_USB_EP_NI1_TXMAXP()		bfin_read16(USB_EP_NI1_TXMAXP)
+#define bfin_write_USB_EP_NI1_TXMAXP(val)	bfin_write16(USB_EP_NI1_TXMAXP, val)
+#define bfin_read_USB_EP_NI1_TXCSR()		bfin_read16(USB_EP_NI1_TXCSR)
+#define bfin_write_USB_EP_NI1_TXCSR(val)	bfin_write16(USB_EP_NI1_TXCSR, val)
+#define bfin_read_USB_EP_NI1_RXMAXP()		bfin_read16(USB_EP_NI1_RXMAXP)
+#define bfin_write_USB_EP_NI1_RXMAXP(val)	bfin_write16(USB_EP_NI1_RXMAXP, val)
+#define bfin_read_USB_EP_NI1_RXCSR()		bfin_read16(USB_EP_NI1_RXCSR)
+#define bfin_write_USB_EP_NI1_RXCSR(val)	bfin_write16(USB_EP_NI1_RXCSR, val)
+#define bfin_read_USB_EP_NI1_RXCOUNT()		bfin_read16(USB_EP_NI1_RXCOUNT)
+#define bfin_write_USB_EP_NI1_RXCOUNT(val)	bfin_write16(USB_EP_NI1_RXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXTYPE()		bfin_read16(USB_EP_NI1_TXTYPE)
+#define bfin_write_USB_EP_NI1_TXTYPE(val)	bfin_write16(USB_EP_NI1_TXTYPE, val)
+#define bfin_read_USB_EP_NI1_TXINTERVAL()	bfin_read16(USB_EP_NI1_TXINTERVAL)
+#define bfin_write_USB_EP_NI1_TXINTERVAL(val)	bfin_write16(USB_EP_NI1_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI1_RXTYPE()		bfin_read16(USB_EP_NI1_RXTYPE)
+#define bfin_write_USB_EP_NI1_RXTYPE(val)	bfin_write16(USB_EP_NI1_RXTYPE, val)
+#define bfin_read_USB_EP_NI1_RXINTERVAL()	bfin_read16(USB_EP_NI1_RXINTERVAL)
+#define bfin_write_USB_EP_NI1_RXINTERVAL(val)	bfin_write16(USB_EP_NI1_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI1_TXCOUNT()		bfin_read16(USB_EP_NI1_TXCOUNT)
+#define bfin_write_USB_EP_NI1_TXCOUNT(val)	bfin_write16(USB_EP_NI1_TXCOUNT, val)
+
+/* USB Endpoint 2 Control Registers */
+
+#define bfin_read_USB_EP_NI2_TXMAXP()		bfin_read16(USB_EP_NI2_TXMAXP)
+#define bfin_write_USB_EP_NI2_TXMAXP(val)	bfin_write16(USB_EP_NI2_TXMAXP, val)
+#define bfin_read_USB_EP_NI2_TXCSR()		bfin_read16(USB_EP_NI2_TXCSR)
+#define bfin_write_USB_EP_NI2_TXCSR(val)	bfin_write16(USB_EP_NI2_TXCSR, val)
+#define bfin_read_USB_EP_NI2_RXMAXP()		bfin_read16(USB_EP_NI2_RXMAXP)
+#define bfin_write_USB_EP_NI2_RXMAXP(val)	bfin_write16(USB_EP_NI2_RXMAXP, val)
+#define bfin_read_USB_EP_NI2_RXCSR()		bfin_read16(USB_EP_NI2_RXCSR)
+#define bfin_write_USB_EP_NI2_RXCSR(val)	bfin_write16(USB_EP_NI2_RXCSR, val)
+#define bfin_read_USB_EP_NI2_RXCOUNT()		bfin_read16(USB_EP_NI2_RXCOUNT)
+#define bfin_write_USB_EP_NI2_RXCOUNT(val)	bfin_write16(USB_EP_NI2_RXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXTYPE()		bfin_read16(USB_EP_NI2_TXTYPE)
+#define bfin_write_USB_EP_NI2_TXTYPE(val)	bfin_write16(USB_EP_NI2_TXTYPE, val)
+#define bfin_read_USB_EP_NI2_TXINTERVAL()	bfin_read16(USB_EP_NI2_TXINTERVAL)
+#define bfin_write_USB_EP_NI2_TXINTERVAL(val)	bfin_write16(USB_EP_NI2_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI2_RXTYPE()		bfin_read16(USB_EP_NI2_RXTYPE)
+#define bfin_write_USB_EP_NI2_RXTYPE(val)	bfin_write16(USB_EP_NI2_RXTYPE, val)
+#define bfin_read_USB_EP_NI2_RXINTERVAL()	bfin_read16(USB_EP_NI2_RXINTERVAL)
+#define bfin_write_USB_EP_NI2_RXINTERVAL(val)	bfin_write16(USB_EP_NI2_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI2_TXCOUNT()		bfin_read16(USB_EP_NI2_TXCOUNT)
+#define bfin_write_USB_EP_NI2_TXCOUNT(val)	bfin_write16(USB_EP_NI2_TXCOUNT, val)
+
+/* USB Endpoint 3 Control Registers */
+
+#define bfin_read_USB_EP_NI3_TXMAXP()		bfin_read16(USB_EP_NI3_TXMAXP)
+#define bfin_write_USB_EP_NI3_TXMAXP(val)	bfin_write16(USB_EP_NI3_TXMAXP, val)
+#define bfin_read_USB_EP_NI3_TXCSR()		bfin_read16(USB_EP_NI3_TXCSR)
+#define bfin_write_USB_EP_NI3_TXCSR(val)	bfin_write16(USB_EP_NI3_TXCSR, val)
+#define bfin_read_USB_EP_NI3_RXMAXP()		bfin_read16(USB_EP_NI3_RXMAXP)
+#define bfin_write_USB_EP_NI3_RXMAXP(val)	bfin_write16(USB_EP_NI3_RXMAXP, val)
+#define bfin_read_USB_EP_NI3_RXCSR()		bfin_read16(USB_EP_NI3_RXCSR)
+#define bfin_write_USB_EP_NI3_RXCSR(val)	bfin_write16(USB_EP_NI3_RXCSR, val)
+#define bfin_read_USB_EP_NI3_RXCOUNT()		bfin_read16(USB_EP_NI3_RXCOUNT)
+#define bfin_write_USB_EP_NI3_RXCOUNT(val)	bfin_write16(USB_EP_NI3_RXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXTYPE()		bfin_read16(USB_EP_NI3_TXTYPE)
+#define bfin_write_USB_EP_NI3_TXTYPE(val)	bfin_write16(USB_EP_NI3_TXTYPE, val)
+#define bfin_read_USB_EP_NI3_TXINTERVAL()	bfin_read16(USB_EP_NI3_TXINTERVAL)
+#define bfin_write_USB_EP_NI3_TXINTERVAL(val)	bfin_write16(USB_EP_NI3_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI3_RXTYPE()		bfin_read16(USB_EP_NI3_RXTYPE)
+#define bfin_write_USB_EP_NI3_RXTYPE(val)	bfin_write16(USB_EP_NI3_RXTYPE, val)
+#define bfin_read_USB_EP_NI3_RXINTERVAL()	bfin_read16(USB_EP_NI3_RXINTERVAL)
+#define bfin_write_USB_EP_NI3_RXINTERVAL(val)	bfin_write16(USB_EP_NI3_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI3_TXCOUNT()		bfin_read16(USB_EP_NI3_TXCOUNT)
+#define bfin_write_USB_EP_NI3_TXCOUNT(val)	bfin_write16(USB_EP_NI3_TXCOUNT, val)
+
+/* USB Endpoint 4 Control Registers */
+
+#define bfin_read_USB_EP_NI4_TXMAXP()		bfin_read16(USB_EP_NI4_TXMAXP)
+#define bfin_write_USB_EP_NI4_TXMAXP(val)	bfin_write16(USB_EP_NI4_TXMAXP, val)
+#define bfin_read_USB_EP_NI4_TXCSR()		bfin_read16(USB_EP_NI4_TXCSR)
+#define bfin_write_USB_EP_NI4_TXCSR(val)	bfin_write16(USB_EP_NI4_TXCSR, val)
+#define bfin_read_USB_EP_NI4_RXMAXP()		bfin_read16(USB_EP_NI4_RXMAXP)
+#define bfin_write_USB_EP_NI4_RXMAXP(val)	bfin_write16(USB_EP_NI4_RXMAXP, val)
+#define bfin_read_USB_EP_NI4_RXCSR()		bfin_read16(USB_EP_NI4_RXCSR)
+#define bfin_write_USB_EP_NI4_RXCSR(val)	bfin_write16(USB_EP_NI4_RXCSR, val)
+#define bfin_read_USB_EP_NI4_RXCOUNT()		bfin_read16(USB_EP_NI4_RXCOUNT)
+#define bfin_write_USB_EP_NI4_RXCOUNT(val)	bfin_write16(USB_EP_NI4_RXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXTYPE()		bfin_read16(USB_EP_NI4_TXTYPE)
+#define bfin_write_USB_EP_NI4_TXTYPE(val)	bfin_write16(USB_EP_NI4_TXTYPE, val)
+#define bfin_read_USB_EP_NI4_TXINTERVAL()	bfin_read16(USB_EP_NI4_TXINTERVAL)
+#define bfin_write_USB_EP_NI4_TXINTERVAL(val)	bfin_write16(USB_EP_NI4_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI4_RXTYPE()		bfin_read16(USB_EP_NI4_RXTYPE)
+#define bfin_write_USB_EP_NI4_RXTYPE(val)	bfin_write16(USB_EP_NI4_RXTYPE, val)
+#define bfin_read_USB_EP_NI4_RXINTERVAL()	bfin_read16(USB_EP_NI4_RXINTERVAL)
+#define bfin_write_USB_EP_NI4_RXINTERVAL(val)	bfin_write16(USB_EP_NI4_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI4_TXCOUNT()		bfin_read16(USB_EP_NI4_TXCOUNT)
+#define bfin_write_USB_EP_NI4_TXCOUNT(val)	bfin_write16(USB_EP_NI4_TXCOUNT, val)
+
+/* USB Endpoint 5 Control Registers */
+
+#define bfin_read_USB_EP_NI5_TXMAXP()		bfin_read16(USB_EP_NI5_TXMAXP)
+#define bfin_write_USB_EP_NI5_TXMAXP(val)	bfin_write16(USB_EP_NI5_TXMAXP, val)
+#define bfin_read_USB_EP_NI5_TXCSR()		bfin_read16(USB_EP_NI5_TXCSR)
+#define bfin_write_USB_EP_NI5_TXCSR(val)	bfin_write16(USB_EP_NI5_TXCSR, val)
+#define bfin_read_USB_EP_NI5_RXMAXP()		bfin_read16(USB_EP_NI5_RXMAXP)
+#define bfin_write_USB_EP_NI5_RXMAXP(val)	bfin_write16(USB_EP_NI5_RXMAXP, val)
+#define bfin_read_USB_EP_NI5_RXCSR()		bfin_read16(USB_EP_NI5_RXCSR)
+#define bfin_write_USB_EP_NI5_RXCSR(val)	bfin_write16(USB_EP_NI5_RXCSR, val)
+#define bfin_read_USB_EP_NI5_RXCOUNT()		bfin_read16(USB_EP_NI5_RXCOUNT)
+#define bfin_write_USB_EP_NI5_RXCOUNT(val)	bfin_write16(USB_EP_NI5_RXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXTYPE()		bfin_read16(USB_EP_NI5_TXTYPE)
+#define bfin_write_USB_EP_NI5_TXTYPE(val)	bfin_write16(USB_EP_NI5_TXTYPE, val)
+#define bfin_read_USB_EP_NI5_TXINTERVAL()	bfin_read16(USB_EP_NI5_TXINTERVAL)
+#define bfin_write_USB_EP_NI5_TXINTERVAL(val)	bfin_write16(USB_EP_NI5_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI5_RXTYPE()		bfin_read16(USB_EP_NI5_RXTYPE)
+#define bfin_write_USB_EP_NI5_RXTYPE(val)	bfin_write16(USB_EP_NI5_RXTYPE, val)
+#define bfin_read_USB_EP_NI5_RXINTERVAL()	bfin_read16(USB_EP_NI5_RXINTERVAL)
+#define bfin_write_USB_EP_NI5_RXINTERVAL(val)	bfin_write16(USB_EP_NI5_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI5_TXCOUNT()		bfin_read16(USB_EP_NI5_TXCOUNT)
+#define bfin_write_USB_EP_NI5_TXCOUNT(val)	bfin_write16(USB_EP_NI5_TXCOUNT, val)
+
+/* USB Endpoint 6 Control Registers */
+
+#define bfin_read_USB_EP_NI6_TXMAXP()		bfin_read16(USB_EP_NI6_TXMAXP)
+#define bfin_write_USB_EP_NI6_TXMAXP(val)	bfin_write16(USB_EP_NI6_TXMAXP, val)
+#define bfin_read_USB_EP_NI6_TXCSR()		bfin_read16(USB_EP_NI6_TXCSR)
+#define bfin_write_USB_EP_NI6_TXCSR(val)	bfin_write16(USB_EP_NI6_TXCSR, val)
+#define bfin_read_USB_EP_NI6_RXMAXP()		bfin_read16(USB_EP_NI6_RXMAXP)
+#define bfin_write_USB_EP_NI6_RXMAXP(val)	bfin_write16(USB_EP_NI6_RXMAXP, val)
+#define bfin_read_USB_EP_NI6_RXCSR()		bfin_read16(USB_EP_NI6_RXCSR)
+#define bfin_write_USB_EP_NI6_RXCSR(val)	bfin_write16(USB_EP_NI6_RXCSR, val)
+#define bfin_read_USB_EP_NI6_RXCOUNT()		bfin_read16(USB_EP_NI6_RXCOUNT)
+#define bfin_write_USB_EP_NI6_RXCOUNT(val)	bfin_write16(USB_EP_NI6_RXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXTYPE()		bfin_read16(USB_EP_NI6_TXTYPE)
+#define bfin_write_USB_EP_NI6_TXTYPE(val)	bfin_write16(USB_EP_NI6_TXTYPE, val)
+#define bfin_read_USB_EP_NI6_TXINTERVAL()	bfin_read16(USB_EP_NI6_TXINTERVAL)
+#define bfin_write_USB_EP_NI6_TXINTERVAL(val)	bfin_write16(USB_EP_NI6_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI6_RXTYPE()		bfin_read16(USB_EP_NI6_RXTYPE)
+#define bfin_write_USB_EP_NI6_RXTYPE(val)	bfin_write16(USB_EP_NI6_RXTYPE, val)
+#define bfin_read_USB_EP_NI6_RXINTERVAL()	bfin_read16(USB_EP_NI6_RXINTERVAL)
+#define bfin_write_USB_EP_NI6_RXINTERVAL(val)	bfin_write16(USB_EP_NI6_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI6_TXCOUNT()		bfin_read16(USB_EP_NI6_TXCOUNT)
+#define bfin_write_USB_EP_NI6_TXCOUNT(val)	bfin_write16(USB_EP_NI6_TXCOUNT, val)
+
+/* USB Endpoint 7 Control Registers */
+
+#define bfin_read_USB_EP_NI7_TXMAXP()		bfin_read16(USB_EP_NI7_TXMAXP)
+#define bfin_write_USB_EP_NI7_TXMAXP(val)	bfin_write16(USB_EP_NI7_TXMAXP, val)
+#define bfin_read_USB_EP_NI7_TXCSR()		bfin_read16(USB_EP_NI7_TXCSR)
+#define bfin_write_USB_EP_NI7_TXCSR(val)	bfin_write16(USB_EP_NI7_TXCSR, val)
+#define bfin_read_USB_EP_NI7_RXMAXP()		bfin_read16(USB_EP_NI7_RXMAXP)
+#define bfin_write_USB_EP_NI7_RXMAXP(val)	bfin_write16(USB_EP_NI7_RXMAXP, val)
+#define bfin_read_USB_EP_NI7_RXCSR()		bfin_read16(USB_EP_NI7_RXCSR)
+#define bfin_write_USB_EP_NI7_RXCSR(val)	bfin_write16(USB_EP_NI7_RXCSR, val)
+#define bfin_read_USB_EP_NI7_RXCOUNT()		bfin_read16(USB_EP_NI7_RXCOUNT)
+#define bfin_write_USB_EP_NI7_RXCOUNT(val)	bfin_write16(USB_EP_NI7_RXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXTYPE()		bfin_read16(USB_EP_NI7_TXTYPE)
+#define bfin_write_USB_EP_NI7_TXTYPE(val)	bfin_write16(USB_EP_NI7_TXTYPE, val)
+#define bfin_read_USB_EP_NI7_TXINTERVAL()	bfin_read16(USB_EP_NI7_TXINTERVAL)
+#define bfin_write_USB_EP_NI7_TXINTERVAL(val)	bfin_write16(USB_EP_NI7_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_RXTYPE()		bfin_read16(USB_EP_NI7_RXTYPE)
+#define bfin_write_USB_EP_NI7_RXTYPE(val)	bfin_write16(USB_EP_NI7_RXTYPE, val)
+#define bfin_read_USB_EP_NI7_RXINTERVAL()	bfin_read16(USB_EP_NI7_RXINTERVAL)
+#define bfin_write_USB_EP_NI7_RXINTERVAL(val)	bfin_write16(USB_EP_NI7_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_TXCOUNT()		bfin_read16(USB_EP_NI7_TXCOUNT)
+#define bfin_write_USB_EP_NI7_TXCOUNT(val)	bfin_write16(USB_EP_NI7_TXCOUNT, val)
+
+#define bfin_read_USB_DMA_INTERRUPT()		bfin_read16(USB_DMA_INTERRUPT)
+#define bfin_write_USB_DMA_INTERRUPT(val)	bfin_write16(USB_DMA_INTERRUPT, val)
+
+/* USB Channel 0 Config Registers */
+
+#define bfin_read_USB_DMA0CONTROL()		bfin_read16(USB_DMA0CONTROL)
+#define bfin_write_USB_DMA0CONTROL(val)		bfin_write16(USB_DMA0CONTROL, val)
+#define bfin_read_USB_DMA0ADDRLOW()		bfin_read16(USB_DMA0ADDRLOW)
+#define bfin_write_USB_DMA0ADDRLOW(val)		bfin_write16(USB_DMA0ADDRLOW, val)
+#define bfin_read_USB_DMA0ADDRHIGH()		bfin_read16(USB_DMA0ADDRHIGH)
+#define bfin_write_USB_DMA0ADDRHIGH(val)	bfin_write16(USB_DMA0ADDRHIGH, val)
+#define bfin_read_USB_DMA0COUNTLOW()		bfin_read16(USB_DMA0COUNTLOW)
+#define bfin_write_USB_DMA0COUNTLOW(val)	bfin_write16(USB_DMA0COUNTLOW, val)
+#define bfin_read_USB_DMA0COUNTHIGH()		bfin_read16(USB_DMA0COUNTHIGH)
+#define bfin_write_USB_DMA0COUNTHIGH(val)	bfin_write16(USB_DMA0COUNTHIGH, val)
+
+/* USB Channel 1 Config Registers */
+
+#define bfin_read_USB_DMA1CONTROL()		bfin_read16(USB_DMA1CONTROL)
+#define bfin_write_USB_DMA1CONTROL(val)		bfin_write16(USB_DMA1CONTROL, val)
+#define bfin_read_USB_DMA1ADDRLOW()		bfin_read16(USB_DMA1ADDRLOW)
+#define bfin_write_USB_DMA1ADDRLOW(val)		bfin_write16(USB_DMA1ADDRLOW, val)
+#define bfin_read_USB_DMA1ADDRHIGH()		bfin_read16(USB_DMA1ADDRHIGH)
+#define bfin_write_USB_DMA1ADDRHIGH(val)	bfin_write16(USB_DMA1ADDRHIGH, val)
+#define bfin_read_USB_DMA1COUNTLOW()		bfin_read16(USB_DMA1COUNTLOW)
+#define bfin_write_USB_DMA1COUNTLOW(val)	bfin_write16(USB_DMA1COUNTLOW, val)
+#define bfin_read_USB_DMA1COUNTHIGH()		bfin_read16(USB_DMA1COUNTHIGH)
+#define bfin_write_USB_DMA1COUNTHIGH(val)	bfin_write16(USB_DMA1COUNTHIGH, val)
+
+/* USB Channel 2 Config Registers */
+
+#define bfin_read_USB_DMA2CONTROL()		bfin_read16(USB_DMA2CONTROL)
+#define bfin_write_USB_DMA2CONTROL(val)		bfin_write16(USB_DMA2CONTROL, val)
+#define bfin_read_USB_DMA2ADDRLOW()		bfin_read16(USB_DMA2ADDRLOW)
+#define bfin_write_USB_DMA2ADDRLOW(val)		bfin_write16(USB_DMA2ADDRLOW, val)
+#define bfin_read_USB_DMA2ADDRHIGH()		bfin_read16(USB_DMA2ADDRHIGH)
+#define bfin_write_USB_DMA2ADDRHIGH(val)	bfin_write16(USB_DMA2ADDRHIGH, val)
+#define bfin_read_USB_DMA2COUNTLOW()		bfin_read16(USB_DMA2COUNTLOW)
+#define bfin_write_USB_DMA2COUNTLOW(val)	bfin_write16(USB_DMA2COUNTLOW, val)
+#define bfin_read_USB_DMA2COUNTHIGH()		bfin_read16(USB_DMA2COUNTHIGH)
+#define bfin_write_USB_DMA2COUNTHIGH(val)	bfin_write16(USB_DMA2COUNTHIGH, val)
+
+/* USB Channel 3 Config Registers */
+
+#define bfin_read_USB_DMA3CONTROL()		bfin_read16(USB_DMA3CONTROL)
+#define bfin_write_USB_DMA3CONTROL(val)		bfin_write16(USB_DMA3CONTROL, val)
+#define bfin_read_USB_DMA3ADDRLOW()		bfin_read16(USB_DMA3ADDRLOW)
+#define bfin_write_USB_DMA3ADDRLOW(val)		bfin_write16(USB_DMA3ADDRLOW, val)
+#define bfin_read_USB_DMA3ADDRHIGH()		bfin_read16(USB_DMA3ADDRHIGH)
+#define bfin_write_USB_DMA3ADDRHIGH(val)	bfin_write16(USB_DMA3ADDRHIGH, val)
+#define bfin_read_USB_DMA3COUNTLOW()		bfin_read16(USB_DMA3COUNTLOW)
+#define bfin_write_USB_DMA3COUNTLOW(val)	bfin_write16(USB_DMA3COUNTLOW, val)
+#define bfin_read_USB_DMA3COUNTHIGH()		bfin_read16(USB_DMA3COUNTHIGH)
+#define bfin_write_USB_DMA3COUNTHIGH(val)	bfin_write16(USB_DMA3COUNTHIGH, val)
+
+/* USB Channel 4 Config Registers */
+
+#define bfin_read_USB_DMA4CONTROL()		bfin_read16(USB_DMA4CONTROL)
+#define bfin_write_USB_DMA4CONTROL(val)		bfin_write16(USB_DMA4CONTROL, val)
+#define bfin_read_USB_DMA4ADDRLOW()		bfin_read16(USB_DMA4ADDRLOW)
+#define bfin_write_USB_DMA4ADDRLOW(val)		bfin_write16(USB_DMA4ADDRLOW, val)
+#define bfin_read_USB_DMA4ADDRHIGH()		bfin_read16(USB_DMA4ADDRHIGH)
+#define bfin_write_USB_DMA4ADDRHIGH(val)	bfin_write16(USB_DMA4ADDRHIGH, val)
+#define bfin_read_USB_DMA4COUNTLOW()		bfin_read16(USB_DMA4COUNTLOW)
+#define bfin_write_USB_DMA4COUNTLOW(val)	bfin_write16(USB_DMA4COUNTLOW, val)
+#define bfin_read_USB_DMA4COUNTHIGH()		bfin_read16(USB_DMA4COUNTHIGH)
+#define bfin_write_USB_DMA4COUNTHIGH(val)	bfin_write16(USB_DMA4COUNTHIGH, val)
+
+/* USB Channel 5 Config Registers */
+
+#define bfin_read_USB_DMA5CONTROL()		bfin_read16(USB_DMA5CONTROL)
+#define bfin_write_USB_DMA5CONTROL(val)		bfin_write16(USB_DMA5CONTROL, val)
+#define bfin_read_USB_DMA5ADDRLOW()		bfin_read16(USB_DMA5ADDRLOW)
+#define bfin_write_USB_DMA5ADDRLOW(val)		bfin_write16(USB_DMA5ADDRLOW, val)
+#define bfin_read_USB_DMA5ADDRHIGH()		bfin_read16(USB_DMA5ADDRHIGH)
+#define bfin_write_USB_DMA5ADDRHIGH(val)	bfin_write16(USB_DMA5ADDRHIGH, val)
+#define bfin_read_USB_DMA5COUNTLOW()		bfin_read16(USB_DMA5COUNTLOW)
+#define bfin_write_USB_DMA5COUNTLOW(val)	bfin_write16(USB_DMA5COUNTLOW, val)
+#define bfin_read_USB_DMA5COUNTHIGH()		bfin_read16(USB_DMA5COUNTHIGH)
+#define bfin_write_USB_DMA5COUNTHIGH(val)	bfin_write16(USB_DMA5COUNTHIGH, val)
+
+/* USB Channel 6 Config Registers */
+
+#define bfin_read_USB_DMA6CONTROL()		bfin_read16(USB_DMA6CONTROL)
+#define bfin_write_USB_DMA6CONTROL(val)		bfin_write16(USB_DMA6CONTROL, val)
+#define bfin_read_USB_DMA6ADDRLOW()		bfin_read16(USB_DMA6ADDRLOW)
+#define bfin_write_USB_DMA6ADDRLOW(val)		bfin_write16(USB_DMA6ADDRLOW, val)
+#define bfin_read_USB_DMA6ADDRHIGH()		bfin_read16(USB_DMA6ADDRHIGH)
+#define bfin_write_USB_DMA6ADDRHIGH(val)	bfin_write16(USB_DMA6ADDRHIGH, val)
+#define bfin_read_USB_DMA6COUNTLOW()		bfin_read16(USB_DMA6COUNTLOW)
+#define bfin_write_USB_DMA6COUNTLOW(val)	bfin_write16(USB_DMA6COUNTLOW, val)
+#define bfin_read_USB_DMA6COUNTHIGH()		bfin_read16(USB_DMA6COUNTHIGH)
+#define bfin_write_USB_DMA6COUNTHIGH(val)	bfin_write16(USB_DMA6COUNTHIGH, val)
+
+/* USB Channel 7 Config Registers */
+
+#define bfin_read_USB_DMA7CONTROL()		bfin_read16(USB_DMA7CONTROL)
+#define bfin_write_USB_DMA7CONTROL(val)		bfin_write16(USB_DMA7CONTROL, val)
+#define bfin_read_USB_DMA7ADDRLOW()		bfin_read16(USB_DMA7ADDRLOW)
+#define bfin_write_USB_DMA7ADDRLOW(val)		bfin_write16(USB_DMA7ADDRLOW, val)
+#define bfin_read_USB_DMA7ADDRHIGH()		bfin_read16(USB_DMA7ADDRHIGH)
+#define bfin_write_USB_DMA7ADDRHIGH(val)	bfin_write16(USB_DMA7ADDRHIGH, val)
+#define bfin_read_USB_DMA7COUNTLOW()		bfin_read16(USB_DMA7COUNTLOW)
+#define bfin_write_USB_DMA7COUNTLOW(val)	bfin_write16(USB_DMA7COUNTLOW, val)
+#define bfin_read_USB_DMA7COUNTHIGH()		bfin_read16(USB_DMA7COUNTHIGH)
+#define bfin_write_USB_DMA7COUNTHIGH(val)	bfin_write16(USB_DMA7COUNTHIGH, val)
+
+#endif /* _CDEF_BF525_H */
diff --git a/include/asm-blackfin/mach-bf527/cdefBF527.h b/include/asm-blackfin/mach-bf527/cdefBF527.h
new file mode 100644
index 0000000..5bd1a86
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/cdefBF527.h
@@ -0,0 +1,626 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/cdefbf527.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:  system mmr register map
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF527_H
+#define _CDEF_BF527_H
+
+/* include all Core registers and bit definitions */
+#include "defBF527.h"
+
+/* include core specific register pointer definitions */
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF527 */
+
+/* include cdefBF52x_base.h for the set of #defines that are common to all ADSP-BF52x processors */
+#include "cdefBF52x_base.h"
+
+/* The following are the #defines needed by ADSP-BF527 that are not in the common header */
+
+/* 10/100 Ethernet Controller	(0xFFC03000 - 0xFFC031FF) */
+
+#define bfin_read_EMAC_OPMODE()			bfin_read32(EMAC_OPMODE)
+#define bfin_write_EMAC_OPMODE(val)		bfin_write32(EMAC_OPMODE, val)
+#define bfin_read_EMAC_ADDRLO()			bfin_read32(EMAC_ADDRLO)
+#define bfin_write_EMAC_ADDRLO(val)		bfin_write32(EMAC_ADDRLO, val)
+#define bfin_read_EMAC_ADDRHI()			bfin_read32(EMAC_ADDRHI)
+#define bfin_write_EMAC_ADDRHI(val)		bfin_write32(EMAC_ADDRHI, val)
+#define bfin_read_EMAC_HASHLO()			bfin_read32(EMAC_HASHLO)
+#define bfin_write_EMAC_HASHLO(val)		bfin_write32(EMAC_HASHLO, val)
+#define bfin_read_EMAC_HASHHI()			bfin_read32(EMAC_HASHHI)
+#define bfin_write_EMAC_HASHHI(val)		bfin_write32(EMAC_HASHHI, val)
+#define bfin_read_EMAC_STAADD()			bfin_read32(EMAC_STAADD)
+#define bfin_write_EMAC_STAADD(val)		bfin_write32(EMAC_STAADD, val)
+#define bfin_read_EMAC_STADAT()			bfin_read32(EMAC_STADAT)
+#define bfin_write_EMAC_STADAT(val)		bfin_write32(EMAC_STADAT, val)
+#define bfin_read_EMAC_FLC()			bfin_read32(EMAC_FLC)
+#define bfin_write_EMAC_FLC(val)		bfin_write32(EMAC_FLC, val)
+#define bfin_read_EMAC_VLAN1()			bfin_read32(EMAC_VLAN1)
+#define bfin_write_EMAC_VLAN1(val)		bfin_write32(EMAC_VLAN1, val)
+#define bfin_read_EMAC_VLAN2()			bfin_read32(EMAC_VLAN2)
+#define bfin_write_EMAC_VLAN2(val)		bfin_write32(EMAC_VLAN2, val)
+#define bfin_read_EMAC_WKUP_CTL()		bfin_read32(EMAC_WKUP_CTL)
+#define bfin_write_EMAC_WKUP_CTL(val)		bfin_write32(EMAC_WKUP_CTL, val)
+#define bfin_read_EMAC_WKUP_FFMSK0()		bfin_read32(EMAC_WKUP_FFMSK0)
+#define bfin_write_EMAC_WKUP_FFMSK0(val)	bfin_write32(EMAC_WKUP_FFMSK0, val)
+#define bfin_read_EMAC_WKUP_FFMSK1()		bfin_read32(EMAC_WKUP_FFMSK1)
+#define bfin_write_EMAC_WKUP_FFMSK1(val)	bfin_write32(EMAC_WKUP_FFMSK1, val)
+#define bfin_read_EMAC_WKUP_FFMSK2()		bfin_read32(EMAC_WKUP_FFMSK2)
+#define bfin_write_EMAC_WKUP_FFMSK2(val)	bfin_write32(EMAC_WKUP_FFMSK2, val)
+#define bfin_read_EMAC_WKUP_FFMSK3()		bfin_read32(EMAC_WKUP_FFMSK3)
+#define bfin_write_EMAC_WKUP_FFMSK3(val)	bfin_write32(EMAC_WKUP_FFMSK3, val)
+#define bfin_read_EMAC_WKUP_FFCMD()		bfin_read32(EMAC_WKUP_FFCMD)
+#define bfin_write_EMAC_WKUP_FFCMD(val)		bfin_write32(EMAC_WKUP_FFCMD, val)
+#define bfin_read_EMAC_WKUP_FFOFF()		bfin_read32(EMAC_WKUP_FFOFF)
+#define bfin_write_EMAC_WKUP_FFOFF(val)		bfin_write32(EMAC_WKUP_FFOFF, val)
+#define bfin_read_EMAC_WKUP_FFCRC0()		bfin_read32(EMAC_WKUP_FFCRC0)
+#define bfin_write_EMAC_WKUP_FFCRC0(val)	bfin_write32(EMAC_WKUP_FFCRC0, val)
+#define bfin_read_EMAC_WKUP_FFCRC1()		bfin_read32(EMAC_WKUP_FFCRC1)
+#define bfin_write_EMAC_WKUP_FFCRC1(val)	bfin_write32(EMAC_WKUP_FFCRC1, val)
+
+#define bfin_read_EMAC_SYSCTL()			bfin_read32(EMAC_SYSCTL)
+#define bfin_write_EMAC_SYSCTL(val)		bfin_write32(EMAC_SYSCTL, val)
+#define bfin_read_EMAC_SYSTAT()			bfin_read32(EMAC_SYSTAT)
+#define bfin_write_EMAC_SYSTAT(val)		bfin_write32(EMAC_SYSTAT, val)
+#define bfin_read_EMAC_RX_STAT()		bfin_read32(EMAC_RX_STAT)
+#define bfin_write_EMAC_RX_STAT(val)		bfin_write32(EMAC_RX_STAT, val)
+#define bfin_read_EMAC_RX_STKY()		bfin_read32(EMAC_RX_STKY)
+#define bfin_write_EMAC_RX_STKY(val)		bfin_write32(EMAC_RX_STKY, val)
+#define bfin_read_EMAC_RX_IRQE()		bfin_read32(EMAC_RX_IRQE)
+#define bfin_write_EMAC_RX_IRQE(val)		bfin_write32(EMAC_RX_IRQE, val)
+#define bfin_read_EMAC_TX_STAT()		bfin_read32(EMAC_TX_STAT)
+#define bfin_write_EMAC_TX_STAT(val)		bfin_write32(EMAC_TX_STAT, val)
+#define bfin_read_EMAC_TX_STKY()		bfin_read32(EMAC_TX_STKY)
+#define bfin_write_EMAC_TX_STKY(val)		bfin_write32(EMAC_TX_STKY, val)
+#define bfin_read_EMAC_TX_IRQE()		bfin_read32(EMAC_TX_IRQE)
+#define bfin_write_EMAC_TX_IRQE(val)		bfin_write32(EMAC_TX_IRQE, val)
+
+#define bfin_read_EMAC_MMC_CTL()		bfin_read32(EMAC_MMC_CTL)
+#define bfin_write_EMAC_MMC_CTL(val)		bfin_write32(EMAC_MMC_CTL, val)
+#define bfin_read_EMAC_MMC_RIRQS()		bfin_read32(EMAC_MMC_RIRQS)
+#define bfin_write_EMAC_MMC_RIRQS(val)		bfin_write32(EMAC_MMC_RIRQS, val)
+#define bfin_read_EMAC_MMC_RIRQE()		bfin_read32(EMAC_MMC_RIRQE)
+#define bfin_write_EMAC_MMC_RIRQE(val)		bfin_write32(EMAC_MMC_RIRQE, val)
+#define bfin_read_EMAC_MMC_TIRQS()		bfin_read32(EMAC_MMC_TIRQS)
+#define bfin_write_EMAC_MMC_TIRQS(val)		bfin_write32(EMAC_MMC_TIRQS, val)
+#define bfin_read_EMAC_MMC_TIRQE()		bfin_read32(EMAC_MMC_TIRQE)
+#define bfin_write_EMAC_MMC_TIRQE(val)		bfin_write32(EMAC_MMC_TIRQE, val)
+
+#define bfin_read_EMAC_RXC_OK()			bfin_read32(EMAC_RXC_OK)
+#define bfin_write_EMAC_RXC_OK(val)		bfin_write32(EMAC_RXC_OK, val)
+#define bfin_read_EMAC_RXC_FCS()		bfin_read32(EMAC_RXC_FCS)
+#define bfin_write_EMAC_RXC_FCS(val)		bfin_write32(EMAC_RXC_FCS, val)
+#define bfin_read_EMAC_RXC_ALIGN()		bfin_read32(EMAC_RXC_ALIGN)
+#define bfin_write_EMAC_RXC_ALIGN(val)		bfin_write32(EMAC_RXC_ALIGN, val)
+#define bfin_read_EMAC_RXC_OCTET()		bfin_read32(EMAC_RXC_OCTET)
+#define bfin_write_EMAC_RXC_OCTET(val)		bfin_write32(EMAC_RXC_OCTET, val)
+#define bfin_read_EMAC_RXC_DMAOVF()		bfin_read32(EMAC_RXC_DMAOVF)
+#define bfin_write_EMAC_RXC_DMAOVF(val)		bfin_write32(EMAC_RXC_DMAOVF, val)
+#define bfin_read_EMAC_RXC_UNICST()		bfin_read32(EMAC_RXC_UNICST)
+#define bfin_write_EMAC_RXC_UNICST(val)		bfin_write32(EMAC_RXC_UNICST, val)
+#define bfin_read_EMAC_RXC_MULTI()		bfin_read32(EMAC_RXC_MULTI)
+#define bfin_write_EMAC_RXC_MULTI(val)		bfin_write32(EMAC_RXC_MULTI, val)
+#define bfin_read_EMAC_RXC_BROAD()		bfin_read32(EMAC_RXC_BROAD)
+#define bfin_write_EMAC_RXC_BROAD(val)		bfin_write32(EMAC_RXC_BROAD, val)
+#define bfin_read_EMAC_RXC_LNERRI()		bfin_read32(EMAC_RXC_LNERRI)
+#define bfin_write_EMAC_RXC_LNERRI(val)		bfin_write32(EMAC_RXC_LNERRI, val)
+#define bfin_read_EMAC_RXC_LNERRO()		bfin_read32(EMAC_RXC_LNERRO)
+#define bfin_write_EMAC_RXC_LNERRO(val)		bfin_write32(EMAC_RXC_LNERRO, val)
+#define bfin_read_EMAC_RXC_LONG()		bfin_read32(EMAC_RXC_LONG)
+#define bfin_write_EMAC_RXC_LONG(val)		bfin_write32(EMAC_RXC_LONG, val)
+#define bfin_read_EMAC_RXC_MACCTL()		bfin_read32(EMAC_RXC_MACCTL)
+#define bfin_write_EMAC_RXC_MACCTL(val)		bfin_write32(EMAC_RXC_MACCTL, val)
+#define bfin_read_EMAC_RXC_OPCODE()		bfin_read32(EMAC_RXC_OPCODE)
+#define bfin_write_EMAC_RXC_OPCODE(val)		bfin_write32(EMAC_RXC_OPCODE, val)
+#define bfin_read_EMAC_RXC_PAUSE()		bfin_read32(EMAC_RXC_PAUSE)
+#define bfin_write_EMAC_RXC_PAUSE(val)		bfin_write32(EMAC_RXC_PAUSE, val)
+#define bfin_read_EMAC_RXC_ALLFRM()		bfin_read32(EMAC_RXC_ALLFRM)
+#define bfin_write_EMAC_RXC_ALLFRM(val)		bfin_write32(EMAC_RXC_ALLFRM, val)
+#define bfin_read_EMAC_RXC_ALLOCT()		bfin_read32(EMAC_RXC_ALLOCT)
+#define bfin_write_EMAC_RXC_ALLOCT(val)		bfin_write32(EMAC_RXC_ALLOCT, val)
+#define bfin_read_EMAC_RXC_TYPED()		bfin_read32(EMAC_RXC_TYPED)
+#define bfin_write_EMAC_RXC_TYPED(val)		bfin_write32(EMAC_RXC_TYPED, val)
+#define bfin_read_EMAC_RXC_SHORT()		bfin_read32(EMAC_RXC_SHORT)
+#define bfin_write_EMAC_RXC_SHORT(val)		bfin_write32(EMAC_RXC_SHORT, val)
+#define bfin_read_EMAC_RXC_EQ64()		bfin_read32(EMAC_RXC_EQ64)
+#define bfin_write_EMAC_RXC_EQ64(val)		bfin_write32(EMAC_RXC_EQ64, val)
+#define bfin_read_EMAC_RXC_LT128()		bfin_read32(EMAC_RXC_LT128)
+#define bfin_write_EMAC_RXC_LT128(val)		bfin_write32(EMAC_RXC_LT128, val)
+#define bfin_read_EMAC_RXC_LT256()		bfin_read32(EMAC_RXC_LT256)
+#define bfin_write_EMAC_RXC_LT256(val)		bfin_write32(EMAC_RXC_LT256, val)
+#define bfin_read_EMAC_RXC_LT512()		bfin_read32(EMAC_RXC_LT512)
+#define bfin_write_EMAC_RXC_LT512(val)		bfin_write32(EMAC_RXC_LT512, val)
+#define bfin_read_EMAC_RXC_LT1024()		bfin_read32(EMAC_RXC_LT1024)
+#define bfin_write_EMAC_RXC_LT1024(val)		bfin_write32(EMAC_RXC_LT1024, val)
+#define bfin_read_EMAC_RXC_GE1024()		bfin_read32(EMAC_RXC_GE1024)
+#define bfin_write_EMAC_RXC_GE1024(val)		bfin_write32(EMAC_RXC_GE1024, val)
+
+#define bfin_read_EMAC_TXC_OK()			bfin_read32(EMAC_TXC_OK)
+#define bfin_write_EMAC_TXC_OK(val)		bfin_write32(EMAC_TXC_OK, val)
+#define bfin_read_EMAC_TXC_1COL()		bfin_read32(EMAC_TXC_1COL)
+#define bfin_write_EMAC_TXC_1COL(val)		bfin_write32(EMAC_TXC_1COL, val)
+#define bfin_read_EMAC_TXC_GT1COL()		bfin_read32(EMAC_TXC_GT1COL)
+#define bfin_write_EMAC_TXC_GT1COL(val)		bfin_write32(EMAC_TXC_GT1COL, val)
+#define bfin_read_EMAC_TXC_OCTET()		bfin_read32(EMAC_TXC_OCTET)
+#define bfin_write_EMAC_TXC_OCTET(val)		bfin_write32(EMAC_TXC_OCTET, val)
+#define bfin_read_EMAC_TXC_DEFER()		bfin_read32(EMAC_TXC_DEFER)
+#define bfin_write_EMAC_TXC_DEFER(val)		bfin_write32(EMAC_TXC_DEFER, val)
+#define bfin_read_EMAC_TXC_LATECL()		bfin_read32(EMAC_TXC_LATECL)
+#define bfin_write_EMAC_TXC_LATECL(val)		bfin_write32(EMAC_TXC_LATECL, val)
+#define bfin_read_EMAC_TXC_XS_COL()		bfin_read32(EMAC_TXC_XS_COL)
+#define bfin_write_EMAC_TXC_XS_COL(val)		bfin_write32(EMAC_TXC_XS_COL, val)
+#define bfin_read_EMAC_TXC_DMAUND()		bfin_read32(EMAC_TXC_DMAUND)
+#define bfin_write_EMAC_TXC_DMAUND(val)		bfin_write32(EMAC_TXC_DMAUND, val)
+#define bfin_read_EMAC_TXC_CRSERR()		bfin_read32(EMAC_TXC_CRSERR)
+#define bfin_write_EMAC_TXC_CRSERR(val)		bfin_write32(EMAC_TXC_CRSERR, val)
+#define bfin_read_EMAC_TXC_UNICST()		bfin_read32(EMAC_TXC_UNICST)
+#define bfin_write_EMAC_TXC_UNICST(val)		bfin_write32(EMAC_TXC_UNICST, val)
+#define bfin_read_EMAC_TXC_MULTI()		bfin_read32(EMAC_TXC_MULTI)
+#define bfin_write_EMAC_TXC_MULTI(val)		bfin_write32(EMAC_TXC_MULTI, val)
+#define bfin_read_EMAC_TXC_BROAD()		bfin_read32(EMAC_TXC_BROAD)
+#define bfin_write_EMAC_TXC_BROAD(val)		bfin_write32(EMAC_TXC_BROAD, val)
+#define bfin_read_EMAC_TXC_XS_DFR()		bfin_read32(EMAC_TXC_XS_DFR)
+#define bfin_write_EMAC_TXC_XS_DFR(val)		bfin_write32(EMAC_TXC_XS_DFR, val)
+#define bfin_read_EMAC_TXC_MACCTL()		bfin_read32(EMAC_TXC_MACCTL)
+#define bfin_write_EMAC_TXC_MACCTL(val)		bfin_write32(EMAC_TXC_MACCTL, val)
+#define bfin_read_EMAC_TXC_ALLFRM()		bfin_read32(EMAC_TXC_ALLFRM)
+#define bfin_write_EMAC_TXC_ALLFRM(val)		bfin_write32(EMAC_TXC_ALLFRM, val)
+#define bfin_read_EMAC_TXC_ALLOCT()		bfin_read32(EMAC_TXC_ALLOCT)
+#define bfin_write_EMAC_TXC_ALLOCT(val)		bfin_write32(EMAC_TXC_ALLOCT, val)
+#define bfin_read_EMAC_TXC_EQ64()		bfin_read32(EMAC_TXC_EQ64)
+#define bfin_write_EMAC_TXC_EQ64(val)		bfin_write32(EMAC_TXC_EQ64, val)
+#define bfin_read_EMAC_TXC_LT128()		bfin_read32(EMAC_TXC_LT128)
+#define bfin_write_EMAC_TXC_LT128(val)		bfin_write32(EMAC_TXC_LT128, val)
+#define bfin_read_EMAC_TXC_LT256()		bfin_read32(EMAC_TXC_LT256)
+#define bfin_write_EMAC_TXC_LT256(val)		bfin_write32(EMAC_TXC_LT256, val)
+#define bfin_read_EMAC_TXC_LT512()		bfin_read32(EMAC_TXC_LT512)
+#define bfin_write_EMAC_TXC_LT512(val)		bfin_write32(EMAC_TXC_LT512, val)
+#define bfin_read_EMAC_TXC_LT1024()		bfin_read32(EMAC_TXC_LT1024)
+#define bfin_write_EMAC_TXC_LT1024(val)		bfin_write32(EMAC_TXC_LT1024, val)
+#define bfin_read_EMAC_TXC_GE1024()		bfin_read32(EMAC_TXC_GE1024)
+#define bfin_write_EMAC_TXC_GE1024(val)		bfin_write32(EMAC_TXC_GE1024, val)
+#define bfin_read_EMAC_TXC_ABORT()		bfin_read32(EMAC_TXC_ABORT)
+#define bfin_write_EMAC_TXC_ABORT(val)		bfin_write32(EMAC_TXC_ABORT, val)
+
+/* USB Control Registers */
+
+#define bfin_read_USB_FADDR()			bfin_read16(USB_FADDR)
+#define bfin_write_USB_FADDR(val)		bfin_write16(USB_FADDR, val)
+#define bfin_read_USB_POWER()			bfin_read16(USB_POWER)
+#define bfin_write_USB_POWER(val)		bfin_write16(USB_POWER, val)
+#define bfin_read_USB_INTRTX()			bfin_read16(USB_INTRTX)
+#define bfin_write_USB_INTRTX(val)		bfin_write16(USB_INTRTX, val)
+#define bfin_read_USB_INTRRX()			bfin_read16(USB_INTRRX)
+#define bfin_write_USB_INTRRX(val)		bfin_write16(USB_INTRRX, val)
+#define bfin_read_USB_INTRTXE()			bfin_read16(USB_INTRTXE)
+#define bfin_write_USB_INTRTXE(val)		bfin_write16(USB_INTRTXE, val)
+#define bfin_read_USB_INTRRXE()			bfin_read16(USB_INTRRXE)
+#define bfin_write_USB_INTRRXE(val)		bfin_write16(USB_INTRRXE, val)
+#define bfin_read_USB_INTRUSB()			bfin_read16(USB_INTRUSB)
+#define bfin_write_USB_INTRUSB(val)		bfin_write16(USB_INTRUSB, val)
+#define bfin_read_USB_INTRUSBE()		bfin_read16(USB_INTRUSBE)
+#define bfin_write_USB_INTRUSBE(val)		bfin_write16(USB_INTRUSBE, val)
+#define bfin_read_USB_FRAME()			bfin_read16(USB_FRAME)
+#define bfin_write_USB_FRAME(val)		bfin_write16(USB_FRAME, val)
+#define bfin_read_USB_INDEX()			bfin_read16(USB_INDEX)
+#define bfin_write_USB_INDEX(val)		bfin_write16(USB_INDEX, val)
+#define bfin_read_USB_TESTMODE()		bfin_read16(USB_TESTMODE)
+#define bfin_write_USB_TESTMODE(val)		bfin_write16(USB_TESTMODE, val)
+#define bfin_read_USB_GLOBINTR()		bfin_read16(USB_GLOBINTR)
+#define bfin_write_USB_GLOBINTR(val)		bfin_write16(USB_GLOBINTR, val)
+#define bfin_read_USB_GLOBAL_CTL()		bfin_read16(USB_GLOBAL_CTL)
+#define bfin_write_USB_GLOBAL_CTL(val)		bfin_write16(USB_GLOBAL_CTL, val)
+
+/* USB Packet Control Registers */
+
+#define bfin_read_USB_TX_MAX_PACKET()		bfin_read16(USB_TX_MAX_PACKET)
+#define bfin_write_USB_TX_MAX_PACKET(val)	bfin_write16(USB_TX_MAX_PACKET, val)
+#define bfin_read_USB_CSR0()			bfin_read16(USB_CSR0)
+#define bfin_write_USB_CSR0(val)		bfin_write16(USB_CSR0, val)
+#define bfin_read_USB_TXCSR()			bfin_read16(USB_TXCSR)
+#define bfin_write_USB_TXCSR(val)		bfin_write16(USB_TXCSR, val)
+#define bfin_read_USB_RX_MAX_PACKET()		bfin_read16(USB_RX_MAX_PACKET)
+#define bfin_write_USB_RX_MAX_PACKET(val)	bfin_write16(USB_RX_MAX_PACKET, val)
+#define bfin_read_USB_RXCSR()			bfin_read16(USB_RXCSR)
+#define bfin_write_USB_RXCSR(val)		bfin_write16(USB_RXCSR, val)
+#define bfin_read_USB_COUNT0()			bfin_read16(USB_COUNT0)
+#define bfin_write_USB_COUNT0(val)		bfin_write16(USB_COUNT0, val)
+#define bfin_read_USB_RXCOUNT()			bfin_read16(USB_RXCOUNT)
+#define bfin_write_USB_RXCOUNT(val)		bfin_write16(USB_RXCOUNT, val)
+#define bfin_read_USB_TXTYPE()			bfin_read16(USB_TXTYPE)
+#define bfin_write_USB_TXTYPE(val)		bfin_write16(USB_TXTYPE, val)
+#define bfin_read_USB_NAKLIMIT0()		bfin_read16(USB_NAKLIMIT0)
+#define bfin_write_USB_NAKLIMIT0(val)		bfin_write16(USB_NAKLIMIT0, val)
+#define bfin_read_USB_TXINTERVAL()		bfin_read16(USB_TXINTERVAL)
+#define bfin_write_USB_TXINTERVAL(val)		bfin_write16(USB_TXINTERVAL, val)
+#define bfin_read_USB_RXTYPE()			bfin_read16(USB_RXTYPE)
+#define bfin_write_USB_RXTYPE(val)		bfin_write16(USB_RXTYPE, val)
+#define bfin_read_USB_RXINTERVAL()		bfin_read16(USB_RXINTERVAL)
+#define bfin_write_USB_RXINTERVAL(val)		bfin_write16(USB_RXINTERVAL, val)
+#define bfin_read_USB_TXCOUNT()			bfin_read16(USB_TXCOUNT)
+#define bfin_write_USB_TXCOUNT(val)		bfin_write16(USB_TXCOUNT, val)
+
+/* USB Endpoint FIFO Registers */
+
+#define bfin_read_USB_EP0_FIFO()		bfin_read16(USB_EP0_FIFO)
+#define bfin_write_USB_EP0_FIFO(val)		bfin_write16(USB_EP0_FIFO, val)
+#define bfin_read_USB_EP1_FIFO()		bfin_read16(USB_EP1_FIFO)
+#define bfin_write_USB_EP1_FIFO(val)		bfin_write16(USB_EP1_FIFO, val)
+#define bfin_read_USB_EP2_FIFO()		bfin_read16(USB_EP2_FIFO)
+#define bfin_write_USB_EP2_FIFO(val)		bfin_write16(USB_EP2_FIFO, val)
+#define bfin_read_USB_EP3_FIFO()		bfin_read16(USB_EP3_FIFO)
+#define bfin_write_USB_EP3_FIFO(val)		bfin_write16(USB_EP3_FIFO, val)
+#define bfin_read_USB_EP4_FIFO()		bfin_read16(USB_EP4_FIFO)
+#define bfin_write_USB_EP4_FIFO(val)		bfin_write16(USB_EP4_FIFO, val)
+#define bfin_read_USB_EP5_FIFO()		bfin_read16(USB_EP5_FIFO)
+#define bfin_write_USB_EP5_FIFO(val)		bfin_write16(USB_EP5_FIFO, val)
+#define bfin_read_USB_EP6_FIFO()		bfin_read16(USB_EP6_FIFO)
+#define bfin_write_USB_EP6_FIFO(val)		bfin_write16(USB_EP6_FIFO, val)
+#define bfin_read_USB_EP7_FIFO()		bfin_read16(USB_EP7_FIFO)
+#define bfin_write_USB_EP7_FIFO(val)		bfin_write16(USB_EP7_FIFO, val)
+
+/* USB OTG Control Registers */
+
+#define bfin_read_USB_OTG_DEV_CTL()		bfin_read16(USB_OTG_DEV_CTL)
+#define bfin_write_USB_OTG_DEV_CTL(val)		bfin_write16(USB_OTG_DEV_CTL, val)
+#define bfin_read_USB_OTG_VBUS_IRQ()		bfin_read16(USB_OTG_VBUS_IRQ)
+#define bfin_write_USB_OTG_VBUS_IRQ(val)	bfin_write16(USB_OTG_VBUS_IRQ, val)
+#define bfin_read_USB_OTG_VBUS_MASK()		bfin_read16(USB_OTG_VBUS_MASK)
+#define bfin_write_USB_OTG_VBUS_MASK(val)	bfin_write16(USB_OTG_VBUS_MASK, val)
+
+/* USB Phy Control Registers */
+
+#define bfin_read_USB_LINKINFO()		bfin_read16(USB_LINKINFO)
+#define bfin_write_USB_LINKINFO(val)		bfin_write16(USB_LINKINFO, val)
+#define bfin_read_USB_VPLEN()			bfin_read16(USB_VPLEN)
+#define bfin_write_USB_VPLEN(val)		bfin_write16(USB_VPLEN, val)
+#define bfin_read_USB_HS_EOF1()			bfin_read16(USB_HS_EOF1)
+#define bfin_write_USB_HS_EOF1(val)		bfin_write16(USB_HS_EOF1, val)
+#define bfin_read_USB_FS_EOF1()			bfin_read16(USB_FS_EOF1)
+#define bfin_write_USB_FS_EOF1(val)		bfin_write16(USB_FS_EOF1, val)
+#define bfin_read_USB_LS_EOF1()			bfin_read16(USB_LS_EOF1)
+#define bfin_write_USB_LS_EOF1(val)		bfin_write16(USB_LS_EOF1, val)
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CNTRL()		bfin_read16(USB_APHY_CNTRL)
+#define bfin_write_USB_APHY_CNTRL(val)		bfin_write16(USB_APHY_CNTRL, val)
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CALIB()		bfin_read16(USB_APHY_CALIB)
+#define bfin_write_USB_APHY_CALIB(val)		bfin_write16(USB_APHY_CALIB, val)
+
+#define bfin_read_USB_APHY_CNTRL2()		bfin_read16(USB_APHY_CNTRL2)
+#define bfin_write_USB_APHY_CNTRL2(val)		bfin_write16(USB_APHY_CNTRL2, val)
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define bfin_read_USB_PHY_TEST()		bfin_read16(USB_PHY_TEST)
+#define bfin_write_USB_PHY_TEST(val)		bfin_write16(USB_PHY_TEST, val)
+
+#define bfin_read_USB_PLLOSC_CTRL()		bfin_read16(USB_PLLOSC_CTRL)
+#define bfin_write_USB_PLLOSC_CTRL(val)		bfin_write16(USB_PLLOSC_CTRL, val)
+#define bfin_read_USB_SRP_CLKDIV()		bfin_read16(USB_SRP_CLKDIV)
+#define bfin_write_USB_SRP_CLKDIV(val)		bfin_write16(USB_SRP_CLKDIV, val)
+
+/* USB Endpoint 0 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXMAXP()		bfin_read16(USB_EP_NI0_TXMAXP)
+#define bfin_write_USB_EP_NI0_TXMAXP(val)	bfin_write16(USB_EP_NI0_TXMAXP, val)
+#define bfin_read_USB_EP_NI0_TXCSR()		bfin_read16(USB_EP_NI0_TXCSR)
+#define bfin_write_USB_EP_NI0_TXCSR(val)	bfin_write16(USB_EP_NI0_TXCSR, val)
+#define bfin_read_USB_EP_NI0_RXMAXP()		bfin_read16(USB_EP_NI0_RXMAXP)
+#define bfin_write_USB_EP_NI0_RXMAXP(val)	bfin_write16(USB_EP_NI0_RXMAXP, val)
+#define bfin_read_USB_EP_NI0_RXCSR()		bfin_read16(USB_EP_NI0_RXCSR)
+#define bfin_write_USB_EP_NI0_RXCSR(val)	bfin_write16(USB_EP_NI0_RXCSR, val)
+#define bfin_read_USB_EP_NI0_RXCOUNT()		bfin_read16(USB_EP_NI0_RXCOUNT)
+#define bfin_write_USB_EP_NI0_RXCOUNT(val)	bfin_write16(USB_EP_NI0_RXCOUNT, val)
+#define bfin_read_USB_EP_NI0_TXTYPE()		bfin_read16(USB_EP_NI0_TXTYPE)
+#define bfin_write_USB_EP_NI0_TXTYPE(val)	bfin_write16(USB_EP_NI0_TXTYPE, val)
+#define bfin_read_USB_EP_NI0_TXINTERVAL()	bfin_read16(USB_EP_NI0_TXINTERVAL)
+#define bfin_write_USB_EP_NI0_TXINTERVAL(val)	bfin_write16(USB_EP_NI0_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI0_RXTYPE()		bfin_read16(USB_EP_NI0_RXTYPE)
+#define bfin_write_USB_EP_NI0_RXTYPE(val)	bfin_write16(USB_EP_NI0_RXTYPE, val)
+#define bfin_read_USB_EP_NI0_RXINTERVAL()	bfin_read16(USB_EP_NI0_RXINTERVAL)
+#define bfin_write_USB_EP_NI0_RXINTERVAL(val)	bfin_write16(USB_EP_NI0_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI0_TXCOUNT()		bfin_read16(USB_EP_NI0_TXCOUNT)
+#define bfin_write_USB_EP_NI0_TXCOUNT(val)	bfin_write16(USB_EP_NI0_TXCOUNT, val)
+
+/* USB Endpoint 1 Control Registers */
+
+#define bfin_read_USB_EP_NI1_TXMAXP()		bfin_read16(USB_EP_NI1_TXMAXP)
+#define bfin_write_USB_EP_NI1_TXMAXP(val)	bfin_write16(USB_EP_NI1_TXMAXP, val)
+#define bfin_read_USB_EP_NI1_TXCSR()		bfin_read16(USB_EP_NI1_TXCSR)
+#define bfin_write_USB_EP_NI1_TXCSR(val)	bfin_write16(USB_EP_NI1_TXCSR, val)
+#define bfin_read_USB_EP_NI1_RXMAXP()		bfin_read16(USB_EP_NI1_RXMAXP)
+#define bfin_write_USB_EP_NI1_RXMAXP(val)	bfin_write16(USB_EP_NI1_RXMAXP, val)
+#define bfin_read_USB_EP_NI1_RXCSR()		bfin_read16(USB_EP_NI1_RXCSR)
+#define bfin_write_USB_EP_NI1_RXCSR(val)	bfin_write16(USB_EP_NI1_RXCSR, val)
+#define bfin_read_USB_EP_NI1_RXCOUNT()		bfin_read16(USB_EP_NI1_RXCOUNT)
+#define bfin_write_USB_EP_NI1_RXCOUNT(val)	bfin_write16(USB_EP_NI1_RXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXTYPE()		bfin_read16(USB_EP_NI1_TXTYPE)
+#define bfin_write_USB_EP_NI1_TXTYPE(val)	bfin_write16(USB_EP_NI1_TXTYPE, val)
+#define bfin_read_USB_EP_NI1_TXINTERVAL()	bfin_read16(USB_EP_NI1_TXINTERVAL)
+#define bfin_write_USB_EP_NI1_TXINTERVAL(val)	bfin_write16(USB_EP_NI1_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI1_RXTYPE()		bfin_read16(USB_EP_NI1_RXTYPE)
+#define bfin_write_USB_EP_NI1_RXTYPE(val)	bfin_write16(USB_EP_NI1_RXTYPE, val)
+#define bfin_read_USB_EP_NI1_RXINTERVAL()	bfin_read16(USB_EP_NI1_RXINTERVAL)
+#define bfin_write_USB_EP_NI1_RXINTERVAL(val)	bfin_write16(USB_EP_NI1_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI1_TXCOUNT()		bfin_read16(USB_EP_NI1_TXCOUNT)
+#define bfin_write_USB_EP_NI1_TXCOUNT(val)	bfin_write16(USB_EP_NI1_TXCOUNT, val)
+
+/* USB Endpoint 2 Control Registers */
+
+#define bfin_read_USB_EP_NI2_TXMAXP()		bfin_read16(USB_EP_NI2_TXMAXP)
+#define bfin_write_USB_EP_NI2_TXMAXP(val)	bfin_write16(USB_EP_NI2_TXMAXP, val)
+#define bfin_read_USB_EP_NI2_TXCSR()		bfin_read16(USB_EP_NI2_TXCSR)
+#define bfin_write_USB_EP_NI2_TXCSR(val)	bfin_write16(USB_EP_NI2_TXCSR, val)
+#define bfin_read_USB_EP_NI2_RXMAXP()		bfin_read16(USB_EP_NI2_RXMAXP)
+#define bfin_write_USB_EP_NI2_RXMAXP(val)	bfin_write16(USB_EP_NI2_RXMAXP, val)
+#define bfin_read_USB_EP_NI2_RXCSR()		bfin_read16(USB_EP_NI2_RXCSR)
+#define bfin_write_USB_EP_NI2_RXCSR(val)	bfin_write16(USB_EP_NI2_RXCSR, val)
+#define bfin_read_USB_EP_NI2_RXCOUNT()		bfin_read16(USB_EP_NI2_RXCOUNT)
+#define bfin_write_USB_EP_NI2_RXCOUNT(val)	bfin_write16(USB_EP_NI2_RXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXTYPE()		bfin_read16(USB_EP_NI2_TXTYPE)
+#define bfin_write_USB_EP_NI2_TXTYPE(val)	bfin_write16(USB_EP_NI2_TXTYPE, val)
+#define bfin_read_USB_EP_NI2_TXINTERVAL()	bfin_read16(USB_EP_NI2_TXINTERVAL)
+#define bfin_write_USB_EP_NI2_TXINTERVAL(val)	bfin_write16(USB_EP_NI2_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI2_RXTYPE()		bfin_read16(USB_EP_NI2_RXTYPE)
+#define bfin_write_USB_EP_NI2_RXTYPE(val)	bfin_write16(USB_EP_NI2_RXTYPE, val)
+#define bfin_read_USB_EP_NI2_RXINTERVAL()	bfin_read16(USB_EP_NI2_RXINTERVAL)
+#define bfin_write_USB_EP_NI2_RXINTERVAL(val)	bfin_write16(USB_EP_NI2_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI2_TXCOUNT()		bfin_read16(USB_EP_NI2_TXCOUNT)
+#define bfin_write_USB_EP_NI2_TXCOUNT(val)	bfin_write16(USB_EP_NI2_TXCOUNT, val)
+
+/* USB Endpoint 3 Control Registers */
+
+#define bfin_read_USB_EP_NI3_TXMAXP()		bfin_read16(USB_EP_NI3_TXMAXP)
+#define bfin_write_USB_EP_NI3_TXMAXP(val)	bfin_write16(USB_EP_NI3_TXMAXP, val)
+#define bfin_read_USB_EP_NI3_TXCSR()		bfin_read16(USB_EP_NI3_TXCSR)
+#define bfin_write_USB_EP_NI3_TXCSR(val)	bfin_write16(USB_EP_NI3_TXCSR, val)
+#define bfin_read_USB_EP_NI3_RXMAXP()		bfin_read16(USB_EP_NI3_RXMAXP)
+#define bfin_write_USB_EP_NI3_RXMAXP(val)	bfin_write16(USB_EP_NI3_RXMAXP, val)
+#define bfin_read_USB_EP_NI3_RXCSR()		bfin_read16(USB_EP_NI3_RXCSR)
+#define bfin_write_USB_EP_NI3_RXCSR(val)	bfin_write16(USB_EP_NI3_RXCSR, val)
+#define bfin_read_USB_EP_NI3_RXCOUNT()		bfin_read16(USB_EP_NI3_RXCOUNT)
+#define bfin_write_USB_EP_NI3_RXCOUNT(val)	bfin_write16(USB_EP_NI3_RXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXTYPE()		bfin_read16(USB_EP_NI3_TXTYPE)
+#define bfin_write_USB_EP_NI3_TXTYPE(val)	bfin_write16(USB_EP_NI3_TXTYPE, val)
+#define bfin_read_USB_EP_NI3_TXINTERVAL()	bfin_read16(USB_EP_NI3_TXINTERVAL)
+#define bfin_write_USB_EP_NI3_TXINTERVAL(val)	bfin_write16(USB_EP_NI3_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI3_RXTYPE()		bfin_read16(USB_EP_NI3_RXTYPE)
+#define bfin_write_USB_EP_NI3_RXTYPE(val)	bfin_write16(USB_EP_NI3_RXTYPE, val)
+#define bfin_read_USB_EP_NI3_RXINTERVAL()	bfin_read16(USB_EP_NI3_RXINTERVAL)
+#define bfin_write_USB_EP_NI3_RXINTERVAL(val)	bfin_write16(USB_EP_NI3_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI3_TXCOUNT()		bfin_read16(USB_EP_NI3_TXCOUNT)
+#define bfin_write_USB_EP_NI3_TXCOUNT(val)	bfin_write16(USB_EP_NI3_TXCOUNT, val)
+
+/* USB Endpoint 4 Control Registers */
+
+#define bfin_read_USB_EP_NI4_TXMAXP()		bfin_read16(USB_EP_NI4_TXMAXP)
+#define bfin_write_USB_EP_NI4_TXMAXP(val)	bfin_write16(USB_EP_NI4_TXMAXP, val)
+#define bfin_read_USB_EP_NI4_TXCSR()		bfin_read16(USB_EP_NI4_TXCSR)
+#define bfin_write_USB_EP_NI4_TXCSR(val)	bfin_write16(USB_EP_NI4_TXCSR, val)
+#define bfin_read_USB_EP_NI4_RXMAXP()		bfin_read16(USB_EP_NI4_RXMAXP)
+#define bfin_write_USB_EP_NI4_RXMAXP(val)	bfin_write16(USB_EP_NI4_RXMAXP, val)
+#define bfin_read_USB_EP_NI4_RXCSR()		bfin_read16(USB_EP_NI4_RXCSR)
+#define bfin_write_USB_EP_NI4_RXCSR(val)	bfin_write16(USB_EP_NI4_RXCSR, val)
+#define bfin_read_USB_EP_NI4_RXCOUNT()		bfin_read16(USB_EP_NI4_RXCOUNT)
+#define bfin_write_USB_EP_NI4_RXCOUNT(val)	bfin_write16(USB_EP_NI4_RXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXTYPE()		bfin_read16(USB_EP_NI4_TXTYPE)
+#define bfin_write_USB_EP_NI4_TXTYPE(val)	bfin_write16(USB_EP_NI4_TXTYPE, val)
+#define bfin_read_USB_EP_NI4_TXINTERVAL()	bfin_read16(USB_EP_NI4_TXINTERVAL)
+#define bfin_write_USB_EP_NI4_TXINTERVAL(val)	bfin_write16(USB_EP_NI4_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI4_RXTYPE()		bfin_read16(USB_EP_NI4_RXTYPE)
+#define bfin_write_USB_EP_NI4_RXTYPE(val)	bfin_write16(USB_EP_NI4_RXTYPE, val)
+#define bfin_read_USB_EP_NI4_RXINTERVAL()	bfin_read16(USB_EP_NI4_RXINTERVAL)
+#define bfin_write_USB_EP_NI4_RXINTERVAL(val)	bfin_write16(USB_EP_NI4_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI4_TXCOUNT()		bfin_read16(USB_EP_NI4_TXCOUNT)
+#define bfin_write_USB_EP_NI4_TXCOUNT(val)	bfin_write16(USB_EP_NI4_TXCOUNT, val)
+
+/* USB Endpoint 5 Control Registers */
+
+#define bfin_read_USB_EP_NI5_TXMAXP()		bfin_read16(USB_EP_NI5_TXMAXP)
+#define bfin_write_USB_EP_NI5_TXMAXP(val)	bfin_write16(USB_EP_NI5_TXMAXP, val)
+#define bfin_read_USB_EP_NI5_TXCSR()		bfin_read16(USB_EP_NI5_TXCSR)
+#define bfin_write_USB_EP_NI5_TXCSR(val)	bfin_write16(USB_EP_NI5_TXCSR, val)
+#define bfin_read_USB_EP_NI5_RXMAXP()		bfin_read16(USB_EP_NI5_RXMAXP)
+#define bfin_write_USB_EP_NI5_RXMAXP(val)	bfin_write16(USB_EP_NI5_RXMAXP, val)
+#define bfin_read_USB_EP_NI5_RXCSR()		bfin_read16(USB_EP_NI5_RXCSR)
+#define bfin_write_USB_EP_NI5_RXCSR(val)	bfin_write16(USB_EP_NI5_RXCSR, val)
+#define bfin_read_USB_EP_NI5_RXCOUNT()		bfin_read16(USB_EP_NI5_RXCOUNT)
+#define bfin_write_USB_EP_NI5_RXCOUNT(val)	bfin_write16(USB_EP_NI5_RXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXTYPE()		bfin_read16(USB_EP_NI5_TXTYPE)
+#define bfin_write_USB_EP_NI5_TXTYPE(val)	bfin_write16(USB_EP_NI5_TXTYPE, val)
+#define bfin_read_USB_EP_NI5_TXINTERVAL()	bfin_read16(USB_EP_NI5_TXINTERVAL)
+#define bfin_write_USB_EP_NI5_TXINTERVAL(val)	bfin_write16(USB_EP_NI5_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI5_RXTYPE()		bfin_read16(USB_EP_NI5_RXTYPE)
+#define bfin_write_USB_EP_NI5_RXTYPE(val)	bfin_write16(USB_EP_NI5_RXTYPE, val)
+#define bfin_read_USB_EP_NI5_RXINTERVAL()	bfin_read16(USB_EP_NI5_RXINTERVAL)
+#define bfin_write_USB_EP_NI5_RXINTERVAL(val)	bfin_write16(USB_EP_NI5_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI5_TXCOUNT()		bfin_read16(USB_EP_NI5_TXCOUNT)
+#define bfin_write_USB_EP_NI5_TXCOUNT(val)	bfin_write16(USB_EP_NI5_TXCOUNT, val)
+
+/* USB Endpoint 6 Control Registers */
+
+#define bfin_read_USB_EP_NI6_TXMAXP()		bfin_read16(USB_EP_NI6_TXMAXP)
+#define bfin_write_USB_EP_NI6_TXMAXP(val)	bfin_write16(USB_EP_NI6_TXMAXP, val)
+#define bfin_read_USB_EP_NI6_TXCSR()		bfin_read16(USB_EP_NI6_TXCSR)
+#define bfin_write_USB_EP_NI6_TXCSR(val)	bfin_write16(USB_EP_NI6_TXCSR, val)
+#define bfin_read_USB_EP_NI6_RXMAXP()		bfin_read16(USB_EP_NI6_RXMAXP)
+#define bfin_write_USB_EP_NI6_RXMAXP(val)	bfin_write16(USB_EP_NI6_RXMAXP, val)
+#define bfin_read_USB_EP_NI6_RXCSR()		bfin_read16(USB_EP_NI6_RXCSR)
+#define bfin_write_USB_EP_NI6_RXCSR(val)	bfin_write16(USB_EP_NI6_RXCSR, val)
+#define bfin_read_USB_EP_NI6_RXCOUNT()		bfin_read16(USB_EP_NI6_RXCOUNT)
+#define bfin_write_USB_EP_NI6_RXCOUNT(val)	bfin_write16(USB_EP_NI6_RXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXTYPE()		bfin_read16(USB_EP_NI6_TXTYPE)
+#define bfin_write_USB_EP_NI6_TXTYPE(val)	bfin_write16(USB_EP_NI6_TXTYPE, val)
+#define bfin_read_USB_EP_NI6_TXINTERVAL()	bfin_read16(USB_EP_NI6_TXINTERVAL)
+#define bfin_write_USB_EP_NI6_TXINTERVAL(val)	bfin_write16(USB_EP_NI6_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI6_RXTYPE()		bfin_read16(USB_EP_NI6_RXTYPE)
+#define bfin_write_USB_EP_NI6_RXTYPE(val)	bfin_write16(USB_EP_NI6_RXTYPE, val)
+#define bfin_read_USB_EP_NI6_RXINTERVAL()	bfin_read16(USB_EP_NI6_RXINTERVAL)
+#define bfin_write_USB_EP_NI6_RXINTERVAL(val)	bfin_write16(USB_EP_NI6_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI6_TXCOUNT()		bfin_read16(USB_EP_NI6_TXCOUNT)
+#define bfin_write_USB_EP_NI6_TXCOUNT(val)	bfin_write16(USB_EP_NI6_TXCOUNT, val)
+
+/* USB Endpoint 7 Control Registers */
+
+#define bfin_read_USB_EP_NI7_TXMAXP()		bfin_read16(USB_EP_NI7_TXMAXP)
+#define bfin_write_USB_EP_NI7_TXMAXP(val)	bfin_write16(USB_EP_NI7_TXMAXP, val)
+#define bfin_read_USB_EP_NI7_TXCSR()		bfin_read16(USB_EP_NI7_TXCSR)
+#define bfin_write_USB_EP_NI7_TXCSR(val)	bfin_write16(USB_EP_NI7_TXCSR, val)
+#define bfin_read_USB_EP_NI7_RXMAXP()		bfin_read16(USB_EP_NI7_RXMAXP)
+#define bfin_write_USB_EP_NI7_RXMAXP(val)	bfin_write16(USB_EP_NI7_RXMAXP, val)
+#define bfin_read_USB_EP_NI7_RXCSR()		bfin_read16(USB_EP_NI7_RXCSR)
+#define bfin_write_USB_EP_NI7_RXCSR(val)	bfin_write16(USB_EP_NI7_RXCSR, val)
+#define bfin_read_USB_EP_NI7_RXCOUNT()		bfin_read16(USB_EP_NI7_RXCOUNT)
+#define bfin_write_USB_EP_NI7_RXCOUNT(val)	bfin_write16(USB_EP_NI7_RXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXTYPE()		bfin_read16(USB_EP_NI7_TXTYPE)
+#define bfin_write_USB_EP_NI7_TXTYPE(val)	bfin_write16(USB_EP_NI7_TXTYPE, val)
+#define bfin_read_USB_EP_NI7_TXINTERVAL()	bfin_read16(USB_EP_NI7_TXINTERVAL)
+#define bfin_write_USB_EP_NI7_TXINTERVAL(val)	bfin_write16(USB_EP_NI7_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_RXTYPE()		bfin_read16(USB_EP_NI7_RXTYPE)
+#define bfin_write_USB_EP_NI7_RXTYPE(val)	bfin_write16(USB_EP_NI7_RXTYPE, val)
+#define bfin_read_USB_EP_NI7_RXINTERVAL()	bfin_read16(USB_EP_NI7_RXINTERVAL)
+#define bfin_write_USB_EP_NI7_RXINTERVAL(val)	bfin_write16(USB_EP_NI7_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_TXCOUNT()		bfin_read16(USB_EP_NI7_TXCOUNT)
+#define bfin_write_USB_EP_NI7_TXCOUNT(val)	bfin_write16(USB_EP_NI7_TXCOUNT, val)
+
+#define bfin_read_USB_DMA_INTERRUPT()		bfin_read16(USB_DMA_INTERRUPT)
+#define bfin_write_USB_DMA_INTERRUPT(val)	bfin_write16(USB_DMA_INTERRUPT, val)
+
+/* USB Channel 0 Config Registers */
+
+#define bfin_read_USB_DMA0CONTROL()		bfin_read16(USB_DMA0CONTROL)
+#define bfin_write_USB_DMA0CONTROL(val)		bfin_write16(USB_DMA0CONTROL, val)
+#define bfin_read_USB_DMA0ADDRLOW()		bfin_read16(USB_DMA0ADDRLOW)
+#define bfin_write_USB_DMA0ADDRLOW(val)		bfin_write16(USB_DMA0ADDRLOW, val)
+#define bfin_read_USB_DMA0ADDRHIGH()		bfin_read16(USB_DMA0ADDRHIGH)
+#define bfin_write_USB_DMA0ADDRHIGH(val)	bfin_write16(USB_DMA0ADDRHIGH, val)
+#define bfin_read_USB_DMA0COUNTLOW()		bfin_read16(USB_DMA0COUNTLOW)
+#define bfin_write_USB_DMA0COUNTLOW(val)	bfin_write16(USB_DMA0COUNTLOW, val)
+#define bfin_read_USB_DMA0COUNTHIGH()		bfin_read16(USB_DMA0COUNTHIGH)
+#define bfin_write_USB_DMA0COUNTHIGH(val)	bfin_write16(USB_DMA0COUNTHIGH, val)
+
+/* USB Channel 1 Config Registers */
+
+#define bfin_read_USB_DMA1CONTROL()		bfin_read16(USB_DMA1CONTROL)
+#define bfin_write_USB_DMA1CONTROL(val)		bfin_write16(USB_DMA1CONTROL, val)
+#define bfin_read_USB_DMA1ADDRLOW()		bfin_read16(USB_DMA1ADDRLOW)
+#define bfin_write_USB_DMA1ADDRLOW(val)		bfin_write16(USB_DMA1ADDRLOW, val)
+#define bfin_read_USB_DMA1ADDRHIGH()		bfin_read16(USB_DMA1ADDRHIGH)
+#define bfin_write_USB_DMA1ADDRHIGH(val)	bfin_write16(USB_DMA1ADDRHIGH, val)
+#define bfin_read_USB_DMA1COUNTLOW()		bfin_read16(USB_DMA1COUNTLOW)
+#define bfin_write_USB_DMA1COUNTLOW(val)	bfin_write16(USB_DMA1COUNTLOW, val)
+#define bfin_read_USB_DMA1COUNTHIGH()		bfin_read16(USB_DMA1COUNTHIGH)
+#define bfin_write_USB_DMA1COUNTHIGH(val)	bfin_write16(USB_DMA1COUNTHIGH, val)
+
+/* USB Channel 2 Config Registers */
+
+#define bfin_read_USB_DMA2CONTROL()		bfin_read16(USB_DMA2CONTROL)
+#define bfin_write_USB_DMA2CONTROL(val)		bfin_write16(USB_DMA2CONTROL, val)
+#define bfin_read_USB_DMA2ADDRLOW()		bfin_read16(USB_DMA2ADDRLOW)
+#define bfin_write_USB_DMA2ADDRLOW(val)		bfin_write16(USB_DMA2ADDRLOW, val)
+#define bfin_read_USB_DMA2ADDRHIGH()		bfin_read16(USB_DMA2ADDRHIGH)
+#define bfin_write_USB_DMA2ADDRHIGH(val)	bfin_write16(USB_DMA2ADDRHIGH, val)
+#define bfin_read_USB_DMA2COUNTLOW()		bfin_read16(USB_DMA2COUNTLOW)
+#define bfin_write_USB_DMA2COUNTLOW(val)	bfin_write16(USB_DMA2COUNTLOW, val)
+#define bfin_read_USB_DMA2COUNTHIGH()		bfin_read16(USB_DMA2COUNTHIGH)
+#define bfin_write_USB_DMA2COUNTHIGH(val)	bfin_write16(USB_DMA2COUNTHIGH, val)
+
+/* USB Channel 3 Config Registers */
+
+#define bfin_read_USB_DMA3CONTROL()		bfin_read16(USB_DMA3CONTROL)
+#define bfin_write_USB_DMA3CONTROL(val)		bfin_write16(USB_DMA3CONTROL, val)
+#define bfin_read_USB_DMA3ADDRLOW()		bfin_read16(USB_DMA3ADDRLOW)
+#define bfin_write_USB_DMA3ADDRLOW(val)		bfin_write16(USB_DMA3ADDRLOW, val)
+#define bfin_read_USB_DMA3ADDRHIGH()		bfin_read16(USB_DMA3ADDRHIGH)
+#define bfin_write_USB_DMA3ADDRHIGH(val)	bfin_write16(USB_DMA3ADDRHIGH, val)
+#define bfin_read_USB_DMA3COUNTLOW()		bfin_read16(USB_DMA3COUNTLOW)
+#define bfin_write_USB_DMA3COUNTLOW(val)	bfin_write16(USB_DMA3COUNTLOW, val)
+#define bfin_read_USB_DMA3COUNTHIGH()		bfin_read16(USB_DMA3COUNTHIGH)
+#define bfin_write_USB_DMA3COUNTHIGH(val)	bfin_write16(USB_DMA3COUNTHIGH, val)
+
+/* USB Channel 4 Config Registers */
+
+#define bfin_read_USB_DMA4CONTROL()		bfin_read16(USB_DMA4CONTROL)
+#define bfin_write_USB_DMA4CONTROL(val)		bfin_write16(USB_DMA4CONTROL, val)
+#define bfin_read_USB_DMA4ADDRLOW()		bfin_read16(USB_DMA4ADDRLOW)
+#define bfin_write_USB_DMA4ADDRLOW(val)		bfin_write16(USB_DMA4ADDRLOW, val)
+#define bfin_read_USB_DMA4ADDRHIGH()		bfin_read16(USB_DMA4ADDRHIGH)
+#define bfin_write_USB_DMA4ADDRHIGH(val)	bfin_write16(USB_DMA4ADDRHIGH, val)
+#define bfin_read_USB_DMA4COUNTLOW()		bfin_read16(USB_DMA4COUNTLOW)
+#define bfin_write_USB_DMA4COUNTLOW(val)	bfin_write16(USB_DMA4COUNTLOW, val)
+#define bfin_read_USB_DMA4COUNTHIGH()		bfin_read16(USB_DMA4COUNTHIGH)
+#define bfin_write_USB_DMA4COUNTHIGH(val)	bfin_write16(USB_DMA4COUNTHIGH, val)
+
+/* USB Channel 5 Config Registers */
+
+#define bfin_read_USB_DMA5CONTROL()		bfin_read16(USB_DMA5CONTROL)
+#define bfin_write_USB_DMA5CONTROL(val)		bfin_write16(USB_DMA5CONTROL, val)
+#define bfin_read_USB_DMA5ADDRLOW()		bfin_read16(USB_DMA5ADDRLOW)
+#define bfin_write_USB_DMA5ADDRLOW(val)		bfin_write16(USB_DMA5ADDRLOW, val)
+#define bfin_read_USB_DMA5ADDRHIGH()		bfin_read16(USB_DMA5ADDRHIGH)
+#define bfin_write_USB_DMA5ADDRHIGH(val)	bfin_write16(USB_DMA5ADDRHIGH, val)
+#define bfin_read_USB_DMA5COUNTLOW()		bfin_read16(USB_DMA5COUNTLOW)
+#define bfin_write_USB_DMA5COUNTLOW(val)	bfin_write16(USB_DMA5COUNTLOW, val)
+#define bfin_read_USB_DMA5COUNTHIGH()		bfin_read16(USB_DMA5COUNTHIGH)
+#define bfin_write_USB_DMA5COUNTHIGH(val)	bfin_write16(USB_DMA5COUNTHIGH, val)
+
+/* USB Channel 6 Config Registers */
+
+#define bfin_read_USB_DMA6CONTROL()		bfin_read16(USB_DMA6CONTROL)
+#define bfin_write_USB_DMA6CONTROL(val)		bfin_write16(USB_DMA6CONTROL, val)
+#define bfin_read_USB_DMA6ADDRLOW()		bfin_read16(USB_DMA6ADDRLOW)
+#define bfin_write_USB_DMA6ADDRLOW(val)		bfin_write16(USB_DMA6ADDRLOW, val)
+#define bfin_read_USB_DMA6ADDRHIGH()		bfin_read16(USB_DMA6ADDRHIGH)
+#define bfin_write_USB_DMA6ADDRHIGH(val)	bfin_write16(USB_DMA6ADDRHIGH, val)
+#define bfin_read_USB_DMA6COUNTLOW()		bfin_read16(USB_DMA6COUNTLOW)
+#define bfin_write_USB_DMA6COUNTLOW(val)	bfin_write16(USB_DMA6COUNTLOW, val)
+#define bfin_read_USB_DMA6COUNTHIGH()		bfin_read16(USB_DMA6COUNTHIGH)
+#define bfin_write_USB_DMA6COUNTHIGH(val)	bfin_write16(USB_DMA6COUNTHIGH, val)
+
+/* USB Channel 7 Config Registers */
+
+#define bfin_read_USB_DMA7CONTROL()		bfin_read16(USB_DMA7CONTROL)
+#define bfin_write_USB_DMA7CONTROL(val)		bfin_write16(USB_DMA7CONTROL, val)
+#define bfin_read_USB_DMA7ADDRLOW()		bfin_read16(USB_DMA7ADDRLOW)
+#define bfin_write_USB_DMA7ADDRLOW(val)		bfin_write16(USB_DMA7ADDRLOW, val)
+#define bfin_read_USB_DMA7ADDRHIGH()		bfin_read16(USB_DMA7ADDRHIGH)
+#define bfin_write_USB_DMA7ADDRHIGH(val)	bfin_write16(USB_DMA7ADDRHIGH, val)
+#define bfin_read_USB_DMA7COUNTLOW()		bfin_read16(USB_DMA7COUNTLOW)
+#define bfin_write_USB_DMA7COUNTLOW(val)	bfin_write16(USB_DMA7COUNTLOW, val)
+#define bfin_read_USB_DMA7COUNTHIGH()		bfin_read16(USB_DMA7COUNTHIGH)
+#define bfin_write_USB_DMA7COUNTHIGH(val)	bfin_write16(USB_DMA7COUNTHIGH, val)
+
+#endif /* _CDEF_BF527_H */
diff --git a/include/asm-blackfin/mach-bf527/cdefBF52x_base.h b/include/asm-blackfin/mach-bf527/cdefBF52x_base.h
new file mode 100644
index 0000000..5f801a0
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/cdefBF52x_base.h
@@ -0,0 +1,1187 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/cdefBF52x_base.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF52X_H
+
+#include "defBF52x_base.h"
+
+/* ==== begin from cdefBF534.h ==== */
+
+/* Clock and System Control	(0xFFC00000 - 0xFFC000FF)								*/
+#define bfin_read_PLL_CTL()			bfin_read16(PLL_CTL)
+#define bfin_write_PLL_CTL(val)			bfin_write16(PLL_CTL, val)
+#define bfin_read_PLL_DIV()			bfin_read16(PLL_DIV)
+#define bfin_write_PLL_DIV(val)			bfin_write16(PLL_DIV, val)
+#define bfin_read_VR_CTL()			bfin_read16(VR_CTL)
+#define bfin_write_VR_CTL(val)			bfin_write16(VR_CTL, val)
+#define bfin_read_PLL_STAT()			bfin_read16(PLL_STAT)
+#define bfin_write_PLL_STAT(val)		bfin_write16(PLL_STAT, val)
+#define bfin_read_PLL_LOCKCNT()			bfin_read16(PLL_LOCKCNT)
+#define bfin_write_PLL_LOCKCNT(val)		bfin_write16(PLL_LOCKCNT, val)
+#define bfin_read_CHIPID()			bfin_read16(CHIPID)
+#define bfin_write_CHIPID(val)			bfin_write16(CHIPID, val)
+
+
+/* System Interrupt Controller (0xFFC00100 - 0xFFC001FF)							*/
+#define bfin_read_SWRST()			bfin_read16(SWRST)
+#define bfin_write_SWRST(val)			bfin_write16(SWRST, val)
+#define bfin_read_SYSCR()			bfin_read16(SYSCR)
+#define bfin_write_SYSCR(val)			bfin_write16(SYSCR, val)
+
+#define bfin_read_SIC_RVECT()			bfin_read32(SIC_RVECT)
+#define bfin_write_SIC_RVECT(val)		bfin_write32(SIC_RVECT, val)
+#define bfin_read_SIC_IMASK0()			bfin_read32(SIC_IMASK0)
+#define bfin_write_SIC_IMASK0(val)		bfin_write32(SIC_IMASK0, val)
+/* legacy register name (below) provided for backwards code compatibility */
+#define bfin_read_SIC_IMASK()			bfin_read32(SIC_IMASK)
+#define bfin_write_SIC_IMASK(val)		bfin_write32(SIC_IMASK, val)
+
+#define bfin_read_SIC_IAR0()			bfin_read32(SIC_IAR0)
+#define bfin_write_SIC_IAR0(val)		bfin_write32(SIC_IAR0, val)
+#define bfin_read_SIC_IAR1()			bfin_read32(SIC_IAR1)
+#define bfin_write_SIC_IAR1(val)		bfin_write32(SIC_IAR1, val)
+#define bfin_read_SIC_IAR2()			bfin_read32(SIC_IAR2)
+#define bfin_write_SIC_IAR2(val)		bfin_write32(SIC_IAR2, val)
+#define bfin_read_SIC_IAR3()			bfin_read32(SIC_IAR3)
+#define bfin_write_SIC_IAR3(val)		bfin_write32(SIC_IAR3, val)
+
+#define bfin_read_SIC_ISR0()			bfin_read32(SIC_ISR0)
+#define bfin_write_SIC_ISR0(val)		bfin_write32(SIC_ISR0, val)
+/* legacy register name (below) provided for backwards code compatibility */
+#define bfin_read_SIC_ISR()			bfin_read32(SIC_ISR)
+#define bfin_write_SIC_ISR(val)			bfin_write32(SIC_ISR, val)
+
+#define bfin_read_SIC_IWR0()			bfin_read32(SIC_IWR0)
+#define bfin_write_SIC_IWR0(val)		bfin_write32(SIC_IWR0, val)
+/* legacy register name (below) provided for backwards code compatibility */
+#define bfin_read_SIC_IWR()			bfin_read32(SIC_IWR)
+#define bfin_write_SIC_IWR(val)			bfin_write32(SIC_IWR, val)
+
+/* SIC Additions to ADSP-BF52x (0xFFC0014C - 0xFFC00162) */
+
+#define bfin_read_SIC_IMASK1()			bfin_read32(SIC_IMASK1)
+#define bfin_write_SIC_IMASK1(val)		bfin_write32(SIC_IMASK1, val)
+#define bfin_read_SIC_IAR4()			bfin_read32(SIC_IAR4)
+#define bfin_write_SIC_IAR4(val)		bfin_write32(SIC_IAR4, val)
+#define bfin_read_SIC_IAR5()			bfin_read32(SIC_IAR5)
+#define bfin_write_SIC_IAR5(val)		bfin_write32(SIC_IAR5, val)
+#define bfin_read_SIC_IAR6()			bfin_read32(SIC_IAR6)
+#define bfin_write_SIC_IAR6(val)		bfin_write32(SIC_IAR6, val)
+#define bfin_read_SIC_IAR7()			bfin_read32(SIC_IAR7)
+#define bfin_write_SIC_IAR7(val)		bfin_write32(SIC_IAR7, val)
+#define bfin_read_SIC_ISR1()			bfin_read32(SIC_ISR1)
+#define bfin_write_SIC_ISR1(val)		bfin_write32(SIC_ISR1, val)
+#define bfin_read_SIC_IWR1()			bfin_read32(SIC_IWR1)
+#define bfin_write_SIC_IWR1(val)		bfin_write32(SIC_IWR1, val)
+
+/* Watchdog Timer		(0xFFC00200 - 0xFFC002FF)									*/
+#define bfin_read_WDOG_CTL()			bfin_read16(WDOG_CTL)
+#define bfin_write_WDOG_CTL(val)		bfin_write16(WDOG_CTL, val)
+#define bfin_read_WDOG_CNT()			bfin_read32(WDOG_CNT)
+#define bfin_write_WDOG_CNT(val)		bfin_write32(WDOG_CNT, val)
+#define bfin_read_WDOG_STAT()			bfin_read32(WDOG_STAT)
+#define bfin_write_WDOG_STAT(val)		bfin_write32(WDOG_STAT, val)
+
+
+/* Real Time Clock		(0xFFC00300 - 0xFFC003FF)									*/
+#define bfin_read_RTC_STAT()			bfin_read32(RTC_STAT)
+#define bfin_write_RTC_STAT(val)		bfin_write32(RTC_STAT, val)
+#define bfin_read_RTC_ICTL()			bfin_read16(RTC_ICTL)
+#define bfin_write_RTC_ICTL(val)		bfin_write16(RTC_ICTL, val)
+#define bfin_read_RTC_ISTAT()			bfin_read16(RTC_ISTAT)
+#define bfin_write_RTC_ISTAT(val)		bfin_write16(RTC_ISTAT, val)
+#define bfin_read_RTC_SWCNT()			bfin_read16(RTC_SWCNT)
+#define bfin_write_RTC_SWCNT(val)		bfin_write16(RTC_SWCNT, val)
+#define bfin_read_RTC_ALARM()			bfin_read32(RTC_ALARM)
+#define bfin_write_RTC_ALARM(val)		bfin_write32(RTC_ALARM, val)
+#define bfin_read_RTC_FAST()			bfin_read16(RTC_FAST)
+#define bfin_write_RTC_FAST(val)		bfin_write16(RTC_FAST, val)
+#define bfin_read_RTC_PREN()			bfin_read16(RTC_PREN)
+#define bfin_write_RTC_PREN(val)		bfin_write16(RTC_PREN, val)
+
+
+/* UART0 Controller		(0xFFC00400 - 0xFFC004FF)									*/
+#define bfin_read_UART0_THR()			bfin_read16(UART0_THR)
+#define bfin_write_UART0_THR(val)		bfin_write16(UART0_THR, val)
+#define bfin_read_UART0_RBR()			bfin_read16(UART0_RBR)
+#define bfin_write_UART0_RBR(val)		bfin_write16(UART0_RBR, val)
+#define bfin_read_UART0_DLL()			bfin_read16(UART0_DLL)
+#define bfin_write_UART0_DLL(val)		bfin_write16(UART0_DLL, val)
+#define bfin_read_UART0_IER()			bfin_read16(UART0_IER)
+#define bfin_write_UART0_IER(val)		bfin_write16(UART0_IER, val)
+#define bfin_read_UART0_DLH()			bfin_read16(UART0_DLH)
+#define bfin_write_UART0_DLH(val)		bfin_write16(UART0_DLH, val)
+#define bfin_read_UART0_IIR()			bfin_read16(UART0_IIR)
+#define bfin_write_UART0_IIR(val)		bfin_write16(UART0_IIR, val)
+#define bfin_read_UART0_LCR()			bfin_read16(UART0_LCR)
+#define bfin_write_UART0_LCR(val)		bfin_write16(UART0_LCR, val)
+#define bfin_read_UART0_MCR()			bfin_read16(UART0_MCR)
+#define bfin_write_UART0_MCR(val)		bfin_write16(UART0_MCR, val)
+#define bfin_read_UART0_LSR()			bfin_read16(UART0_LSR)
+#define bfin_write_UART0_LSR(val)		bfin_write16(UART0_LSR, val)
+#define bfin_read_UART0_MSR()			bfin_read16(UART0_MSR)
+#define bfin_write_UART0_MSR(val)		bfin_write16(UART0_MSR, val)
+#define bfin_read_UART0_SCR()			bfin_read16(UART0_SCR)
+#define bfin_write_UART0_SCR(val)		bfin_write16(UART0_SCR, val)
+#define bfin_read_UART0_GCTL()			bfin_read16(UART0_GCTL)
+#define bfin_write_UART0_GCTL(val)		bfin_write16(UART0_GCTL, val)
+
+
+/* SPI Controller		(0xFFC00500 - 0xFFC005FF)									*/
+#define bfin_read_SPI_CTL()			bfin_read16(SPI_CTL)
+#define bfin_write_SPI_CTL(val)			bfin_write16(SPI_CTL, val)
+#define bfin_read_SPI_FLG()			bfin_read16(SPI_FLG)
+#define bfin_write_SPI_FLG(val)			bfin_write16(SPI_FLG, val)
+#define bfin_read_SPI_STAT()			bfin_read16(SPI_STAT)
+#define bfin_write_SPI_STAT(val)		bfin_write16(SPI_STAT, val)
+#define bfin_read_SPI_TDBR()			bfin_read16(SPI_TDBR)
+#define bfin_write_SPI_TDBR(val)		bfin_write16(SPI_TDBR, val)
+#define bfin_read_SPI_RDBR()			bfin_read16(SPI_RDBR)
+#define bfin_write_SPI_RDBR(val)		bfin_write16(SPI_RDBR, val)
+#define bfin_read_SPI_BAUD()			bfin_read16(SPI_BAUD)
+#define bfin_write_SPI_BAUD(val)		bfin_write16(SPI_BAUD, val)
+#define bfin_read_SPI_SHADOW()			bfin_read16(SPI_SHADOW)
+#define bfin_write_SPI_SHADOW(val)		bfin_write16(SPI_SHADOW, val)
+
+
+/* TIMER0-7 Registers		(0xFFC00600 - 0xFFC006FF)								*/
+#define bfin_read_TIMER0_CONFIG()		bfin_read16(TIMER0_CONFIG)
+#define bfin_write_TIMER0_CONFIG(val)		bfin_write16(TIMER0_CONFIG, val)
+#define bfin_read_TIMER0_COUNTER()		bfin_read32(TIMER0_COUNTER)
+#define bfin_write_TIMER0_COUNTER(val)		bfin_write32(TIMER0_COUNTER, val)
+#define bfin_read_TIMER0_PERIOD()		bfin_read32(TIMER0_PERIOD)
+#define bfin_write_TIMER0_PERIOD(val)		bfin_write32(TIMER0_PERIOD, val)
+#define bfin_read_TIMER0_WIDTH()		bfin_read32(TIMER0_WIDTH)
+#define bfin_write_TIMER0_WIDTH(val)		bfin_write32(TIMER0_WIDTH, val)
+
+#define bfin_read_TIMER1_CONFIG()		bfin_read16(TIMER1_CONFIG)
+#define bfin_write_TIMER1_CONFIG(val)		bfin_write16(TIMER1_CONFIG, val)
+#define bfin_read_TIMER1_COUNTER()		bfin_read32(TIMER1_COUNTER)
+#define bfin_write_TIMER1_COUNTER(val)		bfin_write32(TIMER1_COUNTER, val)
+#define bfin_read_TIMER1_PERIOD()		bfin_read32(TIMER1_PERIOD)
+#define bfin_write_TIMER1_PERIOD(val)		bfin_write32(TIMER1_PERIOD, val)
+#define bfin_read_TIMER1_WIDTH()		bfin_read32(TIMER1_WIDTH)
+#define bfin_write_TIMER1_WIDTH(val)		bfin_write32(TIMER1_WIDTH, val)
+
+#define bfin_read_TIMER2_CONFIG()		bfin_read16(TIMER2_CONFIG)
+#define bfin_write_TIMER2_CONFIG(val)		bfin_write16(TIMER2_CONFIG, val)
+#define bfin_read_TIMER2_COUNTER()		bfin_read32(TIMER2_COUNTER)
+#define bfin_write_TIMER2_COUNTER(val)		bfin_write32(TIMER2_COUNTER, val)
+#define bfin_read_TIMER2_PERIOD()		bfin_read32(TIMER2_PERIOD)
+#define bfin_write_TIMER2_PERIOD(val)		bfin_write32(TIMER2_PERIOD, val)
+#define bfin_read_TIMER2_WIDTH()		bfin_read32(TIMER2_WIDTH)
+#define bfin_write_TIMER2_WIDTH(val)		bfin_write32(TIMER2_WIDTH, val)
+
+#define bfin_read_TIMER3_CONFIG()		bfin_read16(TIMER3_CONFIG)
+#define bfin_write_TIMER3_CONFIG(val)		bfin_write16(TIMER3_CONFIG, val)
+#define bfin_read_TIMER3_COUNTER()		bfin_read32(TIMER3_COUNTER)
+#define bfin_write_TIMER3_COUNTER(val)		bfin_write32(TIMER3_COUNTER, val)
+#define bfin_read_TIMER3_PERIOD()		bfin_read32(TIMER3_PERIOD)
+#define bfin_write_TIMER3_PERIOD(val)		bfin_write32(TIMER3_PERIOD, val)
+#define bfin_read_TIMER3_WIDTH()		bfin_read32(TIMER3_WIDTH)
+#define bfin_write_TIMER3_WIDTH(val)		bfin_write32(TIMER3_WIDTH, val)
+
+#define bfin_read_TIMER4_CONFIG()		bfin_read16(TIMER4_CONFIG)
+#define bfin_write_TIMER4_CONFIG(val)		bfin_write16(TIMER4_CONFIG, val)
+#define bfin_read_TIMER4_COUNTER()		bfin_read32(TIMER4_COUNTER)
+#define bfin_write_TIMER4_COUNTER(val)		bfin_write32(TIMER4_COUNTER, val)
+#define bfin_read_TIMER4_PERIOD()		bfin_read32(TIMER4_PERIOD)
+#define bfin_write_TIMER4_PERIOD(val)		bfin_write32(TIMER4_PERIOD, val)
+#define bfin_read_TIMER4_WIDTH()		bfin_read32(TIMER4_WIDTH)
+#define bfin_write_TIMER4_WIDTH(val)		bfin_write32(TIMER4_WIDTH, val)
+
+#define bfin_read_TIMER5_CONFIG()		bfin_read16(TIMER5_CONFIG)
+#define bfin_write_TIMER5_CONFIG(val)		bfin_write16(TIMER5_CONFIG, val)
+#define bfin_read_TIMER5_COUNTER()		bfin_read32(TIMER5_COUNTER)
+#define bfin_write_TIMER5_COUNTER(val)		bfin_write32(TIMER5_COUNTER, val)
+#define bfin_read_TIMER5_PERIOD()		bfin_read32(TIMER5_PERIOD)
+#define bfin_write_TIMER5_PERIOD(val)		bfin_write32(TIMER5_PERIOD, val)
+#define bfin_read_TIMER5_WIDTH()		bfin_read32(TIMER5_WIDTH)
+#define bfin_write_TIMER5_WIDTH(val)		bfin_write32(TIMER5_WIDTH, val)
+
+#define bfin_read_TIMER6_CONFIG()		bfin_read16(TIMER6_CONFIG)
+#define bfin_write_TIMER6_CONFIG(val)		bfin_write16(TIMER6_CONFIG, val)
+#define bfin_read_TIMER6_COUNTER()		bfin_read32(TIMER6_COUNTER)
+#define bfin_write_TIMER6_COUNTER(val)		bfin_write32(TIMER6_COUNTER, val)
+#define bfin_read_TIMER6_PERIOD()		bfin_read32(TIMER6_PERIOD)
+#define bfin_write_TIMER6_PERIOD(val)		bfin_write32(TIMER6_PERIOD, val)
+#define bfin_read_TIMER6_WIDTH()		bfin_read32(TIMER6_WIDTH)
+#define bfin_write_TIMER6_WIDTH(val)		bfin_write32(TIMER6_WIDTH, val)
+
+#define bfin_read_TIMER7_CONFIG()		bfin_read16(TIMER7_CONFIG)
+#define bfin_write_TIMER7_CONFIG(val)		bfin_write16(TIMER7_CONFIG, val)
+#define bfin_read_TIMER7_COUNTER()		bfin_read32(TIMER7_COUNTER)
+#define bfin_write_TIMER7_COUNTER(val)		bfin_write32(TIMER7_COUNTER, val)
+#define bfin_read_TIMER7_PERIOD()		bfin_read32(TIMER7_PERIOD)
+#define bfin_write_TIMER7_PERIOD(val)		bfin_write32(TIMER7_PERIOD, val)
+#define bfin_read_TIMER7_WIDTH()		bfin_read32(TIMER7_WIDTH)
+#define bfin_write_TIMER7_WIDTH(val)		bfin_write32(TIMER7_WIDTH, val)
+
+#define bfin_read_TIMER_ENABLE()		bfin_read16(TIMER_ENABLE)
+#define bfin_write_TIMER_ENABLE(val)		bfin_write16(TIMER_ENABLE, val)
+#define bfin_read_TIMER_DISABLE()		bfin_read16(TIMER_DISABLE)
+#define bfin_write_TIMER_DISABLE(val)		bfin_write16(TIMER_DISABLE, val)
+#define bfin_read_TIMER_STATUS()		bfin_read32(TIMER_STATUS)
+#define bfin_write_TIMER_STATUS(val)		bfin_write32(TIMER_STATUS, val)
+
+
+/* General Purpose I/O Port F (0xFFC00700 - 0xFFC007FF)								*/
+#define bfin_read_PORTFIO()			bfin_read16(PORTFIO)
+#define bfin_write_PORTFIO(val)			bfin_write16(PORTFIO, val)
+#define bfin_read_PORTFIO_CLEAR()		bfin_read16(PORTFIO_CLEAR)
+#define bfin_write_PORTFIO_CLEAR(val)		bfin_write16(PORTFIO_CLEAR, val)
+#define bfin_read_PORTFIO_SET()			bfin_read16(PORTFIO_SET)
+#define bfin_write_PORTFIO_SET(val)		bfin_write16(PORTFIO_SET, val)
+#define bfin_read_PORTFIO_TOGGLE()		bfin_read16(PORTFIO_TOGGLE)
+#define bfin_write_PORTFIO_TOGGLE(val)		bfin_write16(PORTFIO_TOGGLE, val)
+#define bfin_read_PORTFIO_MASKA()		bfin_read16(PORTFIO_MASKA)
+#define bfin_write_PORTFIO_MASKA(val)		bfin_write16(PORTFIO_MASKA, val)
+#define bfin_read_PORTFIO_MASKA_CLEAR()		bfin_read16(PORTFIO_MASKA_CLEAR)
+#define bfin_write_PORTFIO_MASKA_CLEAR(val)	bfin_write16(PORTFIO_MASKA_CLEAR, val)
+#define bfin_read_PORTFIO_MASKA_SET()		bfin_read16(PORTFIO_MASKA_SET)
+#define bfin_write_PORTFIO_MASKA_SET(val)	bfin_write16(PORTFIO_MASKA_SET, val)
+#define bfin_read_PORTFIO_MASKA_TOGGLE()	bfin_read16(PORTFIO_MASKA_TOGGLE)
+#define bfin_write_PORTFIO_MASKA_TOGGLE(val)	bfin_write16(PORTFIO_MASKA_TOGGLE, val)
+#define bfin_read_PORTFIO_MASKB()		bfin_read16(PORTFIO_MASKB)
+#define bfin_write_PORTFIO_MASKB(val)		bfin_write16(PORTFIO_MASKB, val)
+#define bfin_read_PORTFIO_MASKB_CLEAR()		bfin_read16(PORTFIO_MASKB_CLEAR)
+#define bfin_write_PORTFIO_MASKB_CLEAR(val)	bfin_write16(PORTFIO_MASKB_CLEAR, val)
+#define bfin_read_PORTFIO_MASKB_SET()		bfin_read16(PORTFIO_MASKB_SET)
+#define bfin_write_PORTFIO_MASKB_SET(val)	bfin_write16(PORTFIO_MASKB_SET, val)
+#define bfin_read_PORTFIO_MASKB_TOGGLE()	bfin_read16(PORTFIO_MASKB_TOGGLE)
+#define bfin_write_PORTFIO_MASKB_TOGGLE(val)	bfin_write16(PORTFIO_MASKB_TOGGLE, val)
+#define bfin_read_PORTFIO_DIR()			bfin_read16(PORTFIO_DIR)
+#define bfin_write_PORTFIO_DIR(val)		bfin_write16(PORTFIO_DIR, val)
+#define bfin_read_PORTFIO_POLAR()		bfin_read16(PORTFIO_POLAR)
+#define bfin_write_PORTFIO_POLAR(val)		bfin_write16(PORTFIO_POLAR, val)
+#define bfin_read_PORTFIO_EDGE()		bfin_read16(PORTFIO_EDGE)
+#define bfin_write_PORTFIO_EDGE(val)		bfin_write16(PORTFIO_EDGE, val)
+#define bfin_read_PORTFIO_BOTH()		bfin_read16(PORTFIO_BOTH)
+#define bfin_write_PORTFIO_BOTH(val)		bfin_write16(PORTFIO_BOTH, val)
+#define bfin_read_PORTFIO_INEN()		bfin_read16(PORTFIO_INEN)
+#define bfin_write_PORTFIO_INEN(val)		bfin_write16(PORTFIO_INEN, val)
+
+
+/* SPORT0 Controller		(0xFFC00800 - 0xFFC008FF)								*/
+#define bfin_read_SPORT0_TCR1()			bfin_read16(SPORT0_TCR1)
+#define bfin_write_SPORT0_TCR1(val)		bfin_write16(SPORT0_TCR1, val)
+#define bfin_read_SPORT0_TCR2()			bfin_read16(SPORT0_TCR2)
+#define bfin_write_SPORT0_TCR2(val)		bfin_write16(SPORT0_TCR2, val)
+#define bfin_read_SPORT0_TCLKDIV()		bfin_read16(SPORT0_TCLKDIV)
+#define bfin_write_SPORT0_TCLKDIV(val)		bfin_write16(SPORT0_TCLKDIV, val)
+#define bfin_read_SPORT0_TFSDIV()		bfin_read16(SPORT0_TFSDIV)
+#define bfin_write_SPORT0_TFSDIV(val)		bfin_write16(SPORT0_TFSDIV, val)
+#define bfin_read_SPORT0_TX()			bfin_read32(SPORT0_TX)
+#define bfin_write_SPORT0_TX(val)		bfin_write32(SPORT0_TX, val)
+#define bfin_read_SPORT0_RX()			bfin_read32(SPORT0_RX)
+#define bfin_write_SPORT0_RX(val)		bfin_write32(SPORT0_RX, val)
+#define bfin_read_SPORT0_TX32()			bfin_read32(SPORT0_TX32)
+#define bfin_write_SPORT0_TX32(val)		bfin_write32(SPORT0_TX32, val)
+#define bfin_read_SPORT0_RX32()			bfin_read32(SPORT0_RX32)
+#define bfin_write_SPORT0_RX32(val)		bfin_write32(SPORT0_RX32, val)
+#define bfin_read_SPORT0_TX16()			bfin_read16(SPORT0_TX16)
+#define bfin_write_SPORT0_TX16(val)		bfin_write16(SPORT0_TX16, val)
+#define bfin_read_SPORT0_RX16()			bfin_read16(SPORT0_RX16)
+#define bfin_write_SPORT0_RX16(val)		bfin_write16(SPORT0_RX16, val)
+#define bfin_read_SPORT0_RCR1()			bfin_read16(SPORT0_RCR1)
+#define bfin_write_SPORT0_RCR1(val)		bfin_write16(SPORT0_RCR1, val)
+#define bfin_read_SPORT0_RCR2()			bfin_read16(SPORT0_RCR2)
+#define bfin_write_SPORT0_RCR2(val)		bfin_write16(SPORT0_RCR2, val)
+#define bfin_read_SPORT0_RCLKDIV()		bfin_read16(SPORT0_RCLKDIV)
+#define bfin_write_SPORT0_RCLKDIV(val)		bfin_write16(SPORT0_RCLKDIV, val)
+#define bfin_read_SPORT0_RFSDIV()		bfin_read16(SPORT0_RFSDIV)
+#define bfin_write_SPORT0_RFSDIV(val)		bfin_write16(SPORT0_RFSDIV, val)
+#define bfin_read_SPORT0_STAT()			bfin_read16(SPORT0_STAT)
+#define bfin_write_SPORT0_STAT(val)		bfin_write16(SPORT0_STAT, val)
+#define bfin_read_SPORT0_CHNL()			bfin_read16(SPORT0_CHNL)
+#define bfin_write_SPORT0_CHNL(val)		bfin_write16(SPORT0_CHNL, val)
+#define bfin_read_SPORT0_MCMC1()		bfin_read16(SPORT0_MCMC1)
+#define bfin_write_SPORT0_MCMC1(val)		bfin_write16(SPORT0_MCMC1, val)
+#define bfin_read_SPORT0_MCMC2()		bfin_read16(SPORT0_MCMC2)
+#define bfin_write_SPORT0_MCMC2(val)		bfin_write16(SPORT0_MCMC2, val)
+#define bfin_read_SPORT0_MTCS0()		bfin_read32(SPORT0_MTCS0)
+#define bfin_write_SPORT0_MTCS0(val)		bfin_write32(SPORT0_MTCS0, val)
+#define bfin_read_SPORT0_MTCS1()		bfin_read32(SPORT0_MTCS1)
+#define bfin_write_SPORT0_MTCS1(val)		bfin_write32(SPORT0_MTCS1, val)
+#define bfin_read_SPORT0_MTCS2()		bfin_read32(SPORT0_MTCS2)
+#define bfin_write_SPORT0_MTCS2(val)		bfin_write32(SPORT0_MTCS2, val)
+#define bfin_read_SPORT0_MTCS3()		bfin_read32(SPORT0_MTCS3)
+#define bfin_write_SPORT0_MTCS3(val)		bfin_write32(SPORT0_MTCS3, val)
+#define bfin_read_SPORT0_MRCS0()		bfin_read32(SPORT0_MRCS0)
+#define bfin_write_SPORT0_MRCS0(val)		bfin_write32(SPORT0_MRCS0, val)
+#define bfin_read_SPORT0_MRCS1()		bfin_read32(SPORT0_MRCS1)
+#define bfin_write_SPORT0_MRCS1(val)		bfin_write32(SPORT0_MRCS1, val)
+#define bfin_read_SPORT0_MRCS2()		bfin_read32(SPORT0_MRCS2)
+#define bfin_write_SPORT0_MRCS2(val)		bfin_write32(SPORT0_MRCS2, val)
+#define bfin_read_SPORT0_MRCS3()		bfin_read32(SPORT0_MRCS3)
+#define bfin_write_SPORT0_MRCS3(val)		bfin_write32(SPORT0_MRCS3, val)
+
+
+/* SPORT1 Controller		(0xFFC00900 - 0xFFC009FF)								*/
+#define bfin_read_SPORT1_TCR1()			bfin_read16(SPORT1_TCR1)
+#define bfin_write_SPORT1_TCR1(val)		bfin_write16(SPORT1_TCR1, val)
+#define bfin_read_SPORT1_TCR2()			bfin_read16(SPORT1_TCR2)
+#define bfin_write_SPORT1_TCR2(val)		bfin_write16(SPORT1_TCR2, val)
+#define bfin_read_SPORT1_TCLKDIV()		bfin_read16(SPORT1_TCLKDIV)
+#define bfin_write_SPORT1_TCLKDIV(val)		bfin_write16(SPORT1_TCLKDIV, val)
+#define bfin_read_SPORT1_TFSDIV()		bfin_read16(SPORT1_TFSDIV)
+#define bfin_write_SPORT1_TFSDIV(val)		bfin_write16(SPORT1_TFSDIV, val)
+#define bfin_read_SPORT1_TX()			bfin_read32(SPORT1_TX)
+#define bfin_write_SPORT1_TX(val)		bfin_write32(SPORT1_TX, val)
+#define bfin_read_SPORT1_RX()			bfin_read32(SPORT1_RX)
+#define bfin_write_SPORT1_RX(val)		bfin_write32(SPORT1_RX, val)
+#define bfin_read_SPORT1_TX32()			bfin_read32(SPORT1_TX32)
+#define bfin_write_SPORT1_TX32(val)		bfin_write32(SPORT1_TX32, val)
+#define bfin_read_SPORT1_RX32()			bfin_read32(SPORT1_RX32)
+#define bfin_write_SPORT1_RX32(val)		bfin_write32(SPORT1_RX32, val)
+#define bfin_read_SPORT1_TX16()			bfin_read16(SPORT1_TX16)
+#define bfin_write_SPORT1_TX16(val)		bfin_write16(SPORT1_TX16, val)
+#define bfin_read_SPORT1_RX16()			bfin_read16(SPORT1_RX16)
+#define bfin_write_SPORT1_RX16(val)		bfin_write16(SPORT1_RX16, val)
+#define bfin_read_SPORT1_RCR1()			bfin_read16(SPORT1_RCR1)
+#define bfin_write_SPORT1_RCR1(val)		bfin_write16(SPORT1_RCR1, val)
+#define bfin_read_SPORT1_RCR2()			bfin_read16(SPORT1_RCR2)
+#define bfin_write_SPORT1_RCR2(val)		bfin_write16(SPORT1_RCR2, val)
+#define bfin_read_SPORT1_RCLKDIV()		bfin_read16(SPORT1_RCLKDIV)
+#define bfin_write_SPORT1_RCLKDIV(val)		bfin_write16(SPORT1_RCLKDIV, val)
+#define bfin_read_SPORT1_RFSDIV()		bfin_read16(SPORT1_RFSDIV)
+#define bfin_write_SPORT1_RFSDIV(val)		bfin_write16(SPORT1_RFSDIV, val)
+#define bfin_read_SPORT1_STAT()			bfin_read16(SPORT1_STAT)
+#define bfin_write_SPORT1_STAT(val)		bfin_write16(SPORT1_STAT, val)
+#define bfin_read_SPORT1_CHNL()			bfin_read16(SPORT1_CHNL)
+#define bfin_write_SPORT1_CHNL(val)		bfin_write16(SPORT1_CHNL, val)
+#define bfin_read_SPORT1_MCMC1()		bfin_read16(SPORT1_MCMC1)
+#define bfin_write_SPORT1_MCMC1(val)		bfin_write16(SPORT1_MCMC1, val)
+#define bfin_read_SPORT1_MCMC2()		bfin_read16(SPORT1_MCMC2)
+#define bfin_write_SPORT1_MCMC2(val)		bfin_write16(SPORT1_MCMC2, val)
+#define bfin_read_SPORT1_MTCS0()		bfin_read32(SPORT1_MTCS0)
+#define bfin_write_SPORT1_MTCS0(val)		bfin_write32(SPORT1_MTCS0, val)
+#define bfin_read_SPORT1_MTCS1()		bfin_read32(SPORT1_MTCS1)
+#define bfin_write_SPORT1_MTCS1(val)		bfin_write32(SPORT1_MTCS1, val)
+#define bfin_read_SPORT1_MTCS2()		bfin_read32(SPORT1_MTCS2)
+#define bfin_write_SPORT1_MTCS2(val)		bfin_write32(SPORT1_MTCS2, val)
+#define bfin_read_SPORT1_MTCS3()		bfin_read32(SPORT1_MTCS3)
+#define bfin_write_SPORT1_MTCS3(val)		bfin_write32(SPORT1_MTCS3, val)
+#define bfin_read_SPORT1_MRCS0()		bfin_read32(SPORT1_MRCS0)
+#define bfin_write_SPORT1_MRCS0(val)		bfin_write32(SPORT1_MRCS0, val)
+#define bfin_read_SPORT1_MRCS1()		bfin_read32(SPORT1_MRCS1)
+#define bfin_write_SPORT1_MRCS1(val)		bfin_write32(SPORT1_MRCS1, val)
+#define bfin_read_SPORT1_MRCS2()		bfin_read32(SPORT1_MRCS2)
+#define bfin_write_SPORT1_MRCS2(val)		bfin_write32(SPORT1_MRCS2, val)
+#define bfin_read_SPORT1_MRCS3()		bfin_read32(SPORT1_MRCS3)
+#define bfin_write_SPORT1_MRCS3(val)		bfin_write32(SPORT1_MRCS3, val)
+
+
+/* External Bus Interface Unit (0xFFC00A00 - 0xFFC00AFF)							*/
+#define bfin_read_EBIU_AMGCTL()			bfin_read16(EBIU_AMGCTL)
+#define bfin_write_EBIU_AMGCTL(val)		bfin_write16(EBIU_AMGCTL, val)
+#define bfin_read_EBIU_AMBCTL0()		bfin_read32(EBIU_AMBCTL0)
+#define bfin_write_EBIU_AMBCTL0(val)		bfin_write32(EBIU_AMBCTL0, val)
+#define bfin_read_EBIU_AMBCTL1()		bfin_read32(EBIU_AMBCTL1)
+#define bfin_write_EBIU_AMBCTL1(val)		bfin_write32(EBIU_AMBCTL1, val)
+#define bfin_read_EBIU_SDGCTL()			bfin_read32(EBIU_SDGCTL)
+#define bfin_write_EBIU_SDGCTL(val)		bfin_write32(EBIU_SDGCTL, val)
+#define bfin_read_EBIU_SDBCTL()			bfin_read16(EBIU_SDBCTL)
+#define bfin_write_EBIU_SDBCTL(val)		bfin_write16(EBIU_SDBCTL, val)
+#define bfin_read_EBIU_SDRRC()			bfin_read16(EBIU_SDRRC)
+#define bfin_write_EBIU_SDRRC(val)		bfin_write16(EBIU_SDRRC, val)
+#define bfin_read_EBIU_SDSTAT()			bfin_read16(EBIU_SDSTAT)
+#define bfin_write_EBIU_SDSTAT(val)		bfin_write16(EBIU_SDSTAT, val)
+
+
+/* DMA Traffic Control Registers													*/
+#define bfin_read_DMA_TC_PER()			bfin_read16(DMA_TC_PER)
+#define bfin_write_DMA_TC_PER(val)		bfin_write16(DMA_TC_PER, val)
+#define bfin_read_DMA_TC_CNT()			bfin_read16(DMA_TC_CNT)
+#define bfin_write_DMA_TC_CNT(val)		bfin_write16(DMA_TC_CNT, val)
+
+/* Alternate deprecated register names (below) provided for backwards code compatibility */
+#define bfin_read_DMA_TCPER()			bfin_read16(DMA_TCPER)
+#define bfin_write_DMA_TCPER(val)		bfin_write16(DMA_TCPER, val)
+#define bfin_read_DMA_TCCNT()			bfin_read16(DMA_TCCNT)
+#define bfin_write_DMA_TCCNT(val)		bfin_write16(DMA_TCCNT, val)
+
+/* DMA Controller																	*/
+#define bfin_read_DMA0_CONFIG()			bfin_read16(DMA0_CONFIG)
+#define bfin_write_DMA0_CONFIG(val)		bfin_write16(DMA0_CONFIG, val)
+#define bfin_read_DMA0_NEXT_DESC_PTR()		bfin_read32(DMA0_NEXT_DESC_PTR)
+#define bfin_write_DMA0_NEXT_DESC_PTR(val)	bfin_write32(DMA0_NEXT_DESC_PTR, val)
+#define bfin_read_DMA0_START_ADDR()		bfin_read32(DMA0_START_ADDR)
+#define bfin_write_DMA0_START_ADDR(val)		bfin_write32(DMA0_START_ADDR, val)
+#define bfin_read_DMA0_X_COUNT()		bfin_read16(DMA0_X_COUNT)
+#define bfin_write_DMA0_X_COUNT(val)		bfin_write16(DMA0_X_COUNT, val)
+#define bfin_read_DMA0_Y_COUNT()		bfin_read16(DMA0_Y_COUNT)
+#define bfin_write_DMA0_Y_COUNT(val)		bfin_write16(DMA0_Y_COUNT, val)
+#define bfin_read_DMA0_X_MODIFY()		bfin_read16(DMA0_X_MODIFY)
+#define bfin_write_DMA0_X_MODIFY(val)		bfin_write16(DMA0_X_MODIFY, val)
+#define bfin_read_DMA0_Y_MODIFY()		bfin_read16(DMA0_Y_MODIFY)
+#define bfin_write_DMA0_Y_MODIFY(val)		bfin_write16(DMA0_Y_MODIFY, val)
+#define bfin_read_DMA0_CURR_DESC_PTR()		bfin_read32(DMA0_CURR_DESC_PTR)
+#define bfin_write_DMA0_CURR_DESC_PTR(val)	bfin_write32(DMA0_CURR_DESC_PTR, val)
+#define bfin_read_DMA0_CURR_ADDR()		bfin_read32(DMA0_CURR_ADDR)
+#define bfin_write_DMA0_CURR_ADDR(val)		bfin_write32(DMA0_CURR_ADDR, val)
+#define bfin_read_DMA0_CURR_X_COUNT()		bfin_read16(DMA0_CURR_X_COUNT)
+#define bfin_write_DMA0_CURR_X_COUNT(val)	bfin_write16(DMA0_CURR_X_COUNT, val)
+#define bfin_read_DMA0_CURR_Y_COUNT()		bfin_read16(DMA0_CURR_Y_COUNT)
+#define bfin_write_DMA0_CURR_Y_COUNT(val)	bfin_write16(DMA0_CURR_Y_COUNT, val)
+#define bfin_read_DMA0_IRQ_STATUS()		bfin_read16(DMA0_IRQ_STATUS)
+#define bfin_write_DMA0_IRQ_STATUS(val)		bfin_write16(DMA0_IRQ_STATUS, val)
+#define bfin_read_DMA0_PERIPHERAL_MAP()		bfin_read16(DMA0_PERIPHERAL_MAP)
+#define bfin_write_DMA0_PERIPHERAL_MAP(val)	bfin_write16(DMA0_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA1_CONFIG()			bfin_read16(DMA1_CONFIG)
+#define bfin_write_DMA1_CONFIG(val)		bfin_write16(DMA1_CONFIG, val)
+#define bfin_read_DMA1_NEXT_DESC_PTR()		bfin_read32(DMA1_NEXT_DESC_PTR)
+#define bfin_write_DMA1_NEXT_DESC_PTR(val)	bfin_write32(DMA1_NEXT_DESC_PTR, val)
+#define bfin_read_DMA1_START_ADDR()		bfin_read32(DMA1_START_ADDR)
+#define bfin_write_DMA1_START_ADDR(val)		bfin_write32(DMA1_START_ADDR, val)
+#define bfin_read_DMA1_X_COUNT()		bfin_read16(DMA1_X_COUNT)
+#define bfin_write_DMA1_X_COUNT(val)		bfin_write16(DMA1_X_COUNT, val)
+#define bfin_read_DMA1_Y_COUNT()		bfin_read16(DMA1_Y_COUNT)
+#define bfin_write_DMA1_Y_COUNT(val)		bfin_write16(DMA1_Y_COUNT, val)
+#define bfin_read_DMA1_X_MODIFY()		bfin_read16(DMA1_X_MODIFY)
+#define bfin_write_DMA1_X_MODIFY(val)		bfin_write16(DMA1_X_MODIFY, val)
+#define bfin_read_DMA1_Y_MODIFY()		bfin_read16(DMA1_Y_MODIFY)
+#define bfin_write_DMA1_Y_MODIFY(val)		bfin_write16(DMA1_Y_MODIFY, val)
+#define bfin_read_DMA1_CURR_DESC_PTR()		bfin_read32(DMA1_CURR_DESC_PTR)
+#define bfin_write_DMA1_CURR_DESC_PTR(val)	bfin_write32(DMA1_CURR_DESC_PTR, val)
+#define bfin_read_DMA1_CURR_ADDR()		bfin_read32(DMA1_CURR_ADDR)
+#define bfin_write_DMA1_CURR_ADDR(val)		bfin_write32(DMA1_CURR_ADDR, val)
+#define bfin_read_DMA1_CURR_X_COUNT()		bfin_read16(DMA1_CURR_X_COUNT)
+#define bfin_write_DMA1_CURR_X_COUNT(val)	bfin_write16(DMA1_CURR_X_COUNT, val)
+#define bfin_read_DMA1_CURR_Y_COUNT()		bfin_read16(DMA1_CURR_Y_COUNT)
+#define bfin_write_DMA1_CURR_Y_COUNT(val)	bfin_write16(DMA1_CURR_Y_COUNT, val)
+#define bfin_read_DMA1_IRQ_STATUS()		bfin_read16(DMA1_IRQ_STATUS)
+#define bfin_write_DMA1_IRQ_STATUS(val)		bfin_write16(DMA1_IRQ_STATUS, val)
+#define bfin_read_DMA1_PERIPHERAL_MAP()		bfin_read16(DMA1_PERIPHERAL_MAP)
+#define bfin_write_DMA1_PERIPHERAL_MAP(val)	bfin_write16(DMA1_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA2_CONFIG()			bfin_read16(DMA2_CONFIG)
+#define bfin_write_DMA2_CONFIG(val)		bfin_write16(DMA2_CONFIG, val)
+#define bfin_read_DMA2_NEXT_DESC_PTR()		bfin_read32(DMA2_NEXT_DESC_PTR)
+#define bfin_write_DMA2_NEXT_DESC_PTR(val)	bfin_write32(DMA2_NEXT_DESC_PTR, val)
+#define bfin_read_DMA2_START_ADDR()		bfin_read32(DMA2_START_ADDR)
+#define bfin_write_DMA2_START_ADDR(val)		bfin_write32(DMA2_START_ADDR, val)
+#define bfin_read_DMA2_X_COUNT()		bfin_read16(DMA2_X_COUNT)
+#define bfin_write_DMA2_X_COUNT(val)		bfin_write16(DMA2_X_COUNT, val)
+#define bfin_read_DMA2_Y_COUNT()		bfin_read16(DMA2_Y_COUNT)
+#define bfin_write_DMA2_Y_COUNT(val)		bfin_write16(DMA2_Y_COUNT, val)
+#define bfin_read_DMA2_X_MODIFY()		bfin_read16(DMA2_X_MODIFY)
+#define bfin_write_DMA2_X_MODIFY(val)		bfin_write16(DMA2_X_MODIFY, val)
+#define bfin_read_DMA2_Y_MODIFY()		bfin_read16(DMA2_Y_MODIFY)
+#define bfin_write_DMA2_Y_MODIFY(val)		bfin_write16(DMA2_Y_MODIFY, val)
+#define bfin_read_DMA2_CURR_DESC_PTR()		bfin_read32(DMA2_CURR_DESC_PTR)
+#define bfin_write_DMA2_CURR_DESC_PTR(val)	bfin_write32(DMA2_CURR_DESC_PTR, val)
+#define bfin_read_DMA2_CURR_ADDR()		bfin_read32(DMA2_CURR_ADDR)
+#define bfin_write_DMA2_CURR_ADDR(val)		bfin_write32(DMA2_CURR_ADDR, val)
+#define bfin_read_DMA2_CURR_X_COUNT()		bfin_read16(DMA2_CURR_X_COUNT)
+#define bfin_write_DMA2_CURR_X_COUNT(val)	bfin_write16(DMA2_CURR_X_COUNT, val)
+#define bfin_read_DMA2_CURR_Y_COUNT()		bfin_read16(DMA2_CURR_Y_COUNT)
+#define bfin_write_DMA2_CURR_Y_COUNT(val)	bfin_write16(DMA2_CURR_Y_COUNT, val)
+#define bfin_read_DMA2_IRQ_STATUS()		bfin_read16(DMA2_IRQ_STATUS)
+#define bfin_write_DMA2_IRQ_STATUS(val)		bfin_write16(DMA2_IRQ_STATUS, val)
+#define bfin_read_DMA2_PERIPHERAL_MAP()		bfin_read16(DMA2_PERIPHERAL_MAP)
+#define bfin_write_DMA2_PERIPHERAL_MAP(val)	bfin_write16(DMA2_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA3_CONFIG()			bfin_read16(DMA3_CONFIG)
+#define bfin_write_DMA3_CONFIG(val)		bfin_write16(DMA3_CONFIG, val)
+#define bfin_read_DMA3_NEXT_DESC_PTR()		bfin_read32(DMA3_NEXT_DESC_PTR)
+#define bfin_write_DMA3_NEXT_DESC_PTR(val)	bfin_write32(DMA3_NEXT_DESC_PTR, val)
+#define bfin_read_DMA3_START_ADDR()		bfin_read32(DMA3_START_ADDR)
+#define bfin_write_DMA3_START_ADDR(val)		bfin_write32(DMA3_START_ADDR, val)
+#define bfin_read_DMA3_X_COUNT()		bfin_read16(DMA3_X_COUNT)
+#define bfin_write_DMA3_X_COUNT(val)		bfin_write16(DMA3_X_COUNT, val)
+#define bfin_read_DMA3_Y_COUNT()		bfin_read16(DMA3_Y_COUNT)
+#define bfin_write_DMA3_Y_COUNT(val)		bfin_write16(DMA3_Y_COUNT, val)
+#define bfin_read_DMA3_X_MODIFY()		bfin_read16(DMA3_X_MODIFY)
+#define bfin_write_DMA3_X_MODIFY(val)		bfin_write16(DMA3_X_MODIFY, val)
+#define bfin_read_DMA3_Y_MODIFY()		bfin_read16(DMA3_Y_MODIFY)
+#define bfin_write_DMA3_Y_MODIFY(val)		bfin_write16(DMA3_Y_MODIFY, val)
+#define bfin_read_DMA3_CURR_DESC_PTR()		bfin_read32(DMA3_CURR_DESC_PTR)
+#define bfin_write_DMA3_CURR_DESC_PTR(val)	bfin_write32(DMA3_CURR_DESC_PTR, val)
+#define bfin_read_DMA3_CURR_ADDR()		bfin_read32(DMA3_CURR_ADDR)
+#define bfin_write_DMA3_CURR_ADDR(val)		bfin_write32(DMA3_CURR_ADDR, val)
+#define bfin_read_DMA3_CURR_X_COUNT()		bfin_read16(DMA3_CURR_X_COUNT)
+#define bfin_write_DMA3_CURR_X_COUNT(val)	bfin_write16(DMA3_CURR_X_COUNT, val)
+#define bfin_read_DMA3_CURR_Y_COUNT()		bfin_read16(DMA3_CURR_Y_COUNT)
+#define bfin_write_DMA3_CURR_Y_COUNT(val)	bfin_write16(DMA3_CURR_Y_COUNT, val)
+#define bfin_read_DMA3_IRQ_STATUS()		bfin_read16(DMA3_IRQ_STATUS)
+#define bfin_write_DMA3_IRQ_STATUS(val)		bfin_write16(DMA3_IRQ_STATUS, val)
+#define bfin_read_DMA3_PERIPHERAL_MAP()		bfin_read16(DMA3_PERIPHERAL_MAP)
+#define bfin_write_DMA3_PERIPHERAL_MAP(val)	bfin_write16(DMA3_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA4_CONFIG()			bfin_read16(DMA4_CONFIG)
+#define bfin_write_DMA4_CONFIG(val)		bfin_write16(DMA4_CONFIG, val)
+#define bfin_read_DMA4_NEXT_DESC_PTR()		bfin_read32(DMA4_NEXT_DESC_PTR)
+#define bfin_write_DMA4_NEXT_DESC_PTR(val)	bfin_write32(DMA4_NEXT_DESC_PTR, val)
+#define bfin_read_DMA4_START_ADDR()		bfin_read32(DMA4_START_ADDR)
+#define bfin_write_DMA4_START_ADDR(val)		bfin_write32(DMA4_START_ADDR, val)
+#define bfin_read_DMA4_X_COUNT()		bfin_read16(DMA4_X_COUNT)
+#define bfin_write_DMA4_X_COUNT(val)		bfin_write16(DMA4_X_COUNT, val)
+#define bfin_read_DMA4_Y_COUNT()		bfin_read16(DMA4_Y_COUNT)
+#define bfin_write_DMA4_Y_COUNT(val)		bfin_write16(DMA4_Y_COUNT, val)
+#define bfin_read_DMA4_X_MODIFY()		bfin_read16(DMA4_X_MODIFY)
+#define bfin_write_DMA4_X_MODIFY(val)		bfin_write16(DMA4_X_MODIFY, val)
+#define bfin_read_DMA4_Y_MODIFY()		bfin_read16(DMA4_Y_MODIFY)
+#define bfin_write_DMA4_Y_MODIFY(val)		bfin_write16(DMA4_Y_MODIFY, val)
+#define bfin_read_DMA4_CURR_DESC_PTR()		bfin_read32(DMA4_CURR_DESC_PTR)
+#define bfin_write_DMA4_CURR_DESC_PTR(val)	bfin_write32(DMA4_CURR_DESC_PTR, val)
+#define bfin_read_DMA4_CURR_ADDR()		bfin_read32(DMA4_CURR_ADDR)
+#define bfin_write_DMA4_CURR_ADDR(val)		bfin_write32(DMA4_CURR_ADDR, val)
+#define bfin_read_DMA4_CURR_X_COUNT()		bfin_read16(DMA4_CURR_X_COUNT)
+#define bfin_write_DMA4_CURR_X_COUNT(val)	bfin_write16(DMA4_CURR_X_COUNT, val)
+#define bfin_read_DMA4_CURR_Y_COUNT()		bfin_read16(DMA4_CURR_Y_COUNT)
+#define bfin_write_DMA4_CURR_Y_COUNT(val)	bfin_write16(DMA4_CURR_Y_COUNT, val)
+#define bfin_read_DMA4_IRQ_STATUS()		bfin_read16(DMA4_IRQ_STATUS)
+#define bfin_write_DMA4_IRQ_STATUS(val)		bfin_write16(DMA4_IRQ_STATUS, val)
+#define bfin_read_DMA4_PERIPHERAL_MAP()		bfin_read16(DMA4_PERIPHERAL_MAP)
+#define bfin_write_DMA4_PERIPHERAL_MAP(val)	bfin_write16(DMA4_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA5_CONFIG()			bfin_read16(DMA5_CONFIG)
+#define bfin_write_DMA5_CONFIG(val)		bfin_write16(DMA5_CONFIG, val)
+#define bfin_read_DMA5_NEXT_DESC_PTR()		bfin_read32(DMA5_NEXT_DESC_PTR)
+#define bfin_write_DMA5_NEXT_DESC_PTR(val)	bfin_write32(DMA5_NEXT_DESC_PTR, val)
+#define bfin_read_DMA5_START_ADDR()		bfin_read32(DMA5_START_ADDR)
+#define bfin_write_DMA5_START_ADDR(val)		bfin_write32(DMA5_START_ADDR, val)
+#define bfin_read_DMA5_X_COUNT()		bfin_read16(DMA5_X_COUNT)
+#define bfin_write_DMA5_X_COUNT(val)		bfin_write16(DMA5_X_COUNT, val)
+#define bfin_read_DMA5_Y_COUNT()		bfin_read16(DMA5_Y_COUNT)
+#define bfin_write_DMA5_Y_COUNT(val)		bfin_write16(DMA5_Y_COUNT, val)
+#define bfin_read_DMA5_X_MODIFY()		bfin_read16(DMA5_X_MODIFY)
+#define bfin_write_DMA5_X_MODIFY(val)		bfin_write16(DMA5_X_MODIFY, val)
+#define bfin_read_DMA5_Y_MODIFY()		bfin_read16(DMA5_Y_MODIFY)
+#define bfin_write_DMA5_Y_MODIFY(val)		bfin_write16(DMA5_Y_MODIFY, val)
+#define bfin_read_DMA5_CURR_DESC_PTR()		bfin_read32(DMA5_CURR_DESC_PTR)
+#define bfin_write_DMA5_CURR_DESC_PTR(val)	bfin_write32(DMA5_CURR_DESC_PTR, val)
+#define bfin_read_DMA5_CURR_ADDR()		bfin_read32(DMA5_CURR_ADDR)
+#define bfin_write_DMA5_CURR_ADDR(val)		bfin_write32(DMA5_CURR_ADDR, val)
+#define bfin_read_DMA5_CURR_X_COUNT()		bfin_read16(DMA5_CURR_X_COUNT)
+#define bfin_write_DMA5_CURR_X_COUNT(val)	bfin_write16(DMA5_CURR_X_COUNT, val)
+#define bfin_read_DMA5_CURR_Y_COUNT()		bfin_read16(DMA5_CURR_Y_COUNT)
+#define bfin_write_DMA5_CURR_Y_COUNT(val)	bfin_write16(DMA5_CURR_Y_COUNT, val)
+#define bfin_read_DMA5_IRQ_STATUS()		bfin_read16(DMA5_IRQ_STATUS)
+#define bfin_write_DMA5_IRQ_STATUS(val)		bfin_write16(DMA5_IRQ_STATUS, val)
+#define bfin_read_DMA5_PERIPHERAL_MAP()		bfin_read16(DMA5_PERIPHERAL_MAP)
+#define bfin_write_DMA5_PERIPHERAL_MAP(val)	bfin_write16(DMA5_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA6_CONFIG()			bfin_read16(DMA6_CONFIG)
+#define bfin_write_DMA6_CONFIG(val)		bfin_write16(DMA6_CONFIG, val)
+#define bfin_read_DMA6_NEXT_DESC_PTR()		bfin_read32(DMA6_NEXT_DESC_PTR)
+#define bfin_write_DMA6_NEXT_DESC_PTR(val)	bfin_write32(DMA6_NEXT_DESC_PTR, val)
+#define bfin_read_DMA6_START_ADDR()		bfin_read32(DMA6_START_ADDR)
+#define bfin_write_DMA6_START_ADDR(val)		bfin_write32(DMA6_START_ADDR, val)
+#define bfin_read_DMA6_X_COUNT()		bfin_read16(DMA6_X_COUNT)
+#define bfin_write_DMA6_X_COUNT(val)		bfin_write16(DMA6_X_COUNT, val)
+#define bfin_read_DMA6_Y_COUNT()		bfin_read16(DMA6_Y_COUNT)
+#define bfin_write_DMA6_Y_COUNT(val)		bfin_write16(DMA6_Y_COUNT, val)
+#define bfin_read_DMA6_X_MODIFY()		bfin_read16(DMA6_X_MODIFY)
+#define bfin_write_DMA6_X_MODIFY(val)		bfin_write16(DMA6_X_MODIFY, val)
+#define bfin_read_DMA6_Y_MODIFY()		bfin_read16(DMA6_Y_MODIFY)
+#define bfin_write_DMA6_Y_MODIFY(val)		bfin_write16(DMA6_Y_MODIFY, val)
+#define bfin_read_DMA6_CURR_DESC_PTR()		bfin_read32(DMA6_CURR_DESC_PTR)
+#define bfin_write_DMA6_CURR_DESC_PTR(val)	bfin_write32(DMA6_CURR_DESC_PTR, val)
+#define bfin_read_DMA6_CURR_ADDR()		bfin_read32(DMA6_CURR_ADDR)
+#define bfin_write_DMA6_CURR_ADDR(val)		bfin_write32(DMA6_CURR_ADDR, val)
+#define bfin_read_DMA6_CURR_X_COUNT()		bfin_read16(DMA6_CURR_X_COUNT)
+#define bfin_write_DMA6_CURR_X_COUNT(val)	bfin_write16(DMA6_CURR_X_COUNT, val)
+#define bfin_read_DMA6_CURR_Y_COUNT()		bfin_read16(DMA6_CURR_Y_COUNT)
+#define bfin_write_DMA6_CURR_Y_COUNT(val)	bfin_write16(DMA6_CURR_Y_COUNT, val)
+#define bfin_read_DMA6_IRQ_STATUS()		bfin_read16(DMA6_IRQ_STATUS)
+#define bfin_write_DMA6_IRQ_STATUS(val)		bfin_write16(DMA6_IRQ_STATUS, val)
+#define bfin_read_DMA6_PERIPHERAL_MAP()		bfin_read16(DMA6_PERIPHERAL_MAP)
+#define bfin_write_DMA6_PERIPHERAL_MAP(val)	bfin_write16(DMA6_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA7_CONFIG()			bfin_read16(DMA7_CONFIG)
+#define bfin_write_DMA7_CONFIG(val)		bfin_write16(DMA7_CONFIG, val)
+#define bfin_read_DMA7_NEXT_DESC_PTR()		bfin_read32(DMA7_NEXT_DESC_PTR)
+#define bfin_write_DMA7_NEXT_DESC_PTR(val)	bfin_write32(DMA7_NEXT_DESC_PTR, val)
+#define bfin_read_DMA7_START_ADDR()		bfin_read32(DMA7_START_ADDR)
+#define bfin_write_DMA7_START_ADDR(val)		bfin_write32(DMA7_START_ADDR, val)
+#define bfin_read_DMA7_X_COUNT()		bfin_read16(DMA7_X_COUNT)
+#define bfin_write_DMA7_X_COUNT(val)		bfin_write16(DMA7_X_COUNT, val)
+#define bfin_read_DMA7_Y_COUNT()		bfin_read16(DMA7_Y_COUNT)
+#define bfin_write_DMA7_Y_COUNT(val)		bfin_write16(DMA7_Y_COUNT, val)
+#define bfin_read_DMA7_X_MODIFY()		bfin_read16(DMA7_X_MODIFY)
+#define bfin_write_DMA7_X_MODIFY(val)		bfin_write16(DMA7_X_MODIFY, val)
+#define bfin_read_DMA7_Y_MODIFY()		bfin_read16(DMA7_Y_MODIFY)
+#define bfin_write_DMA7_Y_MODIFY(val)		bfin_write16(DMA7_Y_MODIFY, val)
+#define bfin_read_DMA7_CURR_DESC_PTR()		bfin_read32(DMA7_CURR_DESC_PTR)
+#define bfin_write_DMA7_CURR_DESC_PTR(val)	bfin_write32(DMA7_CURR_DESC_PTR, val)
+#define bfin_read_DMA7_CURR_ADDR()		bfin_read32(DMA7_CURR_ADDR)
+#define bfin_write_DMA7_CURR_ADDR(val)		bfin_write32(DMA7_CURR_ADDR, val)
+#define bfin_read_DMA7_CURR_X_COUNT()		bfin_read16(DMA7_CURR_X_COUNT)
+#define bfin_write_DMA7_CURR_X_COUNT(val)	bfin_write16(DMA7_CURR_X_COUNT, val)
+#define bfin_read_DMA7_CURR_Y_COUNT()		bfin_read16(DMA7_CURR_Y_COUNT)
+#define bfin_write_DMA7_CURR_Y_COUNT(val)	bfin_write16(DMA7_CURR_Y_COUNT, val)
+#define bfin_read_DMA7_IRQ_STATUS()		bfin_read16(DMA7_IRQ_STATUS)
+#define bfin_write_DMA7_IRQ_STATUS(val)		bfin_write16(DMA7_IRQ_STATUS, val)
+#define bfin_read_DMA7_PERIPHERAL_MAP()		bfin_read16(DMA7_PERIPHERAL_MAP)
+#define bfin_write_DMA7_PERIPHERAL_MAP(val)	bfin_write16(DMA7_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA8_CONFIG()			bfin_read16(DMA8_CONFIG)
+#define bfin_write_DMA8_CONFIG(val)		bfin_write16(DMA8_CONFIG, val)
+#define bfin_read_DMA8_NEXT_DESC_PTR()		bfin_read32(DMA8_NEXT_DESC_PTR)
+#define bfin_write_DMA8_NEXT_DESC_PTR(val)	bfin_write32(DMA8_NEXT_DESC_PTR, val)
+#define bfin_read_DMA8_START_ADDR()		bfin_read32(DMA8_START_ADDR)
+#define bfin_write_DMA8_START_ADDR(val)		bfin_write32(DMA8_START_ADDR, val)
+#define bfin_read_DMA8_X_COUNT()		bfin_read16(DMA8_X_COUNT)
+#define bfin_write_DMA8_X_COUNT(val)		bfin_write16(DMA8_X_COUNT, val)
+#define bfin_read_DMA8_Y_COUNT()		bfin_read16(DMA8_Y_COUNT)
+#define bfin_write_DMA8_Y_COUNT(val)		bfin_write16(DMA8_Y_COUNT, val)
+#define bfin_read_DMA8_X_MODIFY()		bfin_read16(DMA8_X_MODIFY)
+#define bfin_write_DMA8_X_MODIFY(val)		bfin_write16(DMA8_X_MODIFY, val)
+#define bfin_read_DMA8_Y_MODIFY()		bfin_read16(DMA8_Y_MODIFY)
+#define bfin_write_DMA8_Y_MODIFY(val)		bfin_write16(DMA8_Y_MODIFY, val)
+#define bfin_read_DMA8_CURR_DESC_PTR()		bfin_read32(DMA8_CURR_DESC_PTR)
+#define bfin_write_DMA8_CURR_DESC_PTR(val)	bfin_write32(DMA8_CURR_DESC_PTR, val)
+#define bfin_read_DMA8_CURR_ADDR()		bfin_read32(DMA8_CURR_ADDR)
+#define bfin_write_DMA8_CURR_ADDR(val)		bfin_write32(DMA8_CURR_ADDR, val)
+#define bfin_read_DMA8_CURR_X_COUNT()		bfin_read16(DMA8_CURR_X_COUNT)
+#define bfin_write_DMA8_CURR_X_COUNT(val)	bfin_write16(DMA8_CURR_X_COUNT, val)
+#define bfin_read_DMA8_CURR_Y_COUNT()		bfin_read16(DMA8_CURR_Y_COUNT)
+#define bfin_write_DMA8_CURR_Y_COUNT(val)	bfin_write16(DMA8_CURR_Y_COUNT, val)
+#define bfin_read_DMA8_IRQ_STATUS()		bfin_read16(DMA8_IRQ_STATUS)
+#define bfin_write_DMA8_IRQ_STATUS(val)		bfin_write16(DMA8_IRQ_STATUS, val)
+#define bfin_read_DMA8_PERIPHERAL_MAP()		bfin_read16(DMA8_PERIPHERAL_MAP)
+#define bfin_write_DMA8_PERIPHERAL_MAP(val)	bfin_write16(DMA8_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA9_CONFIG()			bfin_read16(DMA9_CONFIG)
+#define bfin_write_DMA9_CONFIG(val)		bfin_write16(DMA9_CONFIG, val)
+#define bfin_read_DMA9_NEXT_DESC_PTR()		bfin_read32(DMA9_NEXT_DESC_PTR)
+#define bfin_write_DMA9_NEXT_DESC_PTR(val)	bfin_write32(DMA9_NEXT_DESC_PTR, val)
+#define bfin_read_DMA9_START_ADDR()		bfin_read32(DMA9_START_ADDR)
+#define bfin_write_DMA9_START_ADDR(val)		bfin_write32(DMA9_START_ADDR, val)
+#define bfin_read_DMA9_X_COUNT()		bfin_read16(DMA9_X_COUNT)
+#define bfin_write_DMA9_X_COUNT(val)		bfin_write16(DMA9_X_COUNT, val)
+#define bfin_read_DMA9_Y_COUNT()		bfin_read16(DMA9_Y_COUNT)
+#define bfin_write_DMA9_Y_COUNT(val)		bfin_write16(DMA9_Y_COUNT, val)
+#define bfin_read_DMA9_X_MODIFY()		bfin_read16(DMA9_X_MODIFY)
+#define bfin_write_DMA9_X_MODIFY(val)		bfin_write16(DMA9_X_MODIFY, val)
+#define bfin_read_DMA9_Y_MODIFY()		bfin_read16(DMA9_Y_MODIFY)
+#define bfin_write_DMA9_Y_MODIFY(val)		bfin_write16(DMA9_Y_MODIFY, val)
+#define bfin_read_DMA9_CURR_DESC_PTR()		bfin_read32(DMA9_CURR_DESC_PTR)
+#define bfin_write_DMA9_CURR_DESC_PTR(val)	bfin_write32(DMA9_CURR_DESC_PTR, val)
+#define bfin_read_DMA9_CURR_ADDR()		bfin_read32(DMA9_CURR_ADDR)
+#define bfin_write_DMA9_CURR_ADDR(val)		bfin_write32(DMA9_CURR_ADDR, val)
+#define bfin_read_DMA9_CURR_X_COUNT()		bfin_read16(DMA9_CURR_X_COUNT)
+#define bfin_write_DMA9_CURR_X_COUNT(val)	bfin_write16(DMA9_CURR_X_COUNT, val)
+#define bfin_read_DMA9_CURR_Y_COUNT()		bfin_read16(DMA9_CURR_Y_COUNT)
+#define bfin_write_DMA9_CURR_Y_COUNT(val)	bfin_write16(DMA9_CURR_Y_COUNT, val)
+#define bfin_read_DMA9_IRQ_STATUS()		bfin_read16(DMA9_IRQ_STATUS)
+#define bfin_write_DMA9_IRQ_STATUS(val)		bfin_write16(DMA9_IRQ_STATUS, val)
+#define bfin_read_DMA9_PERIPHERAL_MAP()		bfin_read16(DMA9_PERIPHERAL_MAP)
+#define bfin_write_DMA9_PERIPHERAL_MAP(val)	bfin_write16(DMA9_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA10_CONFIG()		bfin_read16(DMA10_CONFIG)
+#define bfin_write_DMA10_CONFIG(val)		bfin_write16(DMA10_CONFIG, val)
+#define bfin_read_DMA10_NEXT_DESC_PTR()		bfin_read32(DMA10_NEXT_DESC_PTR)
+#define bfin_write_DMA10_NEXT_DESC_PTR(val)	bfin_write32(DMA10_NEXT_DESC_PTR, val)
+#define bfin_read_DMA10_START_ADDR()		bfin_read32(DMA10_START_ADDR)
+#define bfin_write_DMA10_START_ADDR(val)	bfin_write32(DMA10_START_ADDR, val)
+#define bfin_read_DMA10_X_COUNT()		bfin_read16(DMA10_X_COUNT)
+#define bfin_write_DMA10_X_COUNT(val)		bfin_write16(DMA10_X_COUNT, val)
+#define bfin_read_DMA10_Y_COUNT()		bfin_read16(DMA10_Y_COUNT)
+#define bfin_write_DMA10_Y_COUNT(val)		bfin_write16(DMA10_Y_COUNT, val)
+#define bfin_read_DMA10_X_MODIFY()		bfin_read16(DMA10_X_MODIFY)
+#define bfin_write_DMA10_X_MODIFY(val)		bfin_write16(DMA10_X_MODIFY, val)
+#define bfin_read_DMA10_Y_MODIFY()		bfin_read16(DMA10_Y_MODIFY)
+#define bfin_write_DMA10_Y_MODIFY(val)		bfin_write16(DMA10_Y_MODIFY, val)
+#define bfin_read_DMA10_CURR_DESC_PTR()		bfin_read32(DMA10_CURR_DESC_PTR)
+#define bfin_write_DMA10_CURR_DESC_PTR(val)	bfin_write32(DMA10_CURR_DESC_PTR, val)
+#define bfin_read_DMA10_CURR_ADDR()		bfin_read32(DMA10_CURR_ADDR)
+#define bfin_write_DMA10_CURR_ADDR(val)		bfin_write32(DMA10_CURR_ADDR, val)
+#define bfin_read_DMA10_CURR_X_COUNT()		bfin_read16(DMA10_CURR_X_COUNT)
+#define bfin_write_DMA10_CURR_X_COUNT(val)	bfin_write16(DMA10_CURR_X_COUNT, val)
+#define bfin_read_DMA10_CURR_Y_COUNT()		bfin_read16(DMA10_CURR_Y_COUNT)
+#define bfin_write_DMA10_CURR_Y_COUNT(val)	bfin_write16(DMA10_CURR_Y_COUNT, val)
+#define bfin_read_DMA10_IRQ_STATUS()		bfin_read16(DMA10_IRQ_STATUS)
+#define bfin_write_DMA10_IRQ_STATUS(val)	bfin_write16(DMA10_IRQ_STATUS, val)
+#define bfin_read_DMA10_PERIPHERAL_MAP()	bfin_read16(DMA10_PERIPHERAL_MAP)
+#define bfin_write_DMA10_PERIPHERAL_MAP(val)	bfin_write16(DMA10_PERIPHERAL_MAP, val)
+
+#define bfin_read_DMA11_CONFIG()		bfin_read16(DMA11_CONFIG)
+#define bfin_write_DMA11_CONFIG(val)		bfin_write16(DMA11_CONFIG, val)
+#define bfin_read_DMA11_NEXT_DESC_PTR()		bfin_read32(DMA11_NEXT_DESC_PTR)
+#define bfin_write_DMA11_NEXT_DESC_PTR(val)	bfin_write32(DMA11_NEXT_DESC_PTR, val)
+#define bfin_read_DMA11_START_ADDR()		bfin_read32(DMA11_START_ADDR)
+#define bfin_write_DMA11_START_ADDR(val)	bfin_write32(DMA11_START_ADDR, val)
+#define bfin_read_DMA11_X_COUNT()		bfin_read16(DMA11_X_COUNT)
+#define bfin_write_DMA11_X_COUNT(val)		bfin_write16(DMA11_X_COUNT, val)
+#define bfin_read_DMA11_Y_COUNT()		bfin_read16(DMA11_Y_COUNT)
+#define bfin_write_DMA11_Y_COUNT(val)		bfin_write16(DMA11_Y_COUNT, val)
+#define bfin_read_DMA11_X_MODIFY()		bfin_read16(DMA11_X_MODIFY)
+#define bfin_write_DMA11_X_MODIFY(val)		bfin_write16(DMA11_X_MODIFY, val)
+#define bfin_read_DMA11_Y_MODIFY()		bfin_read16(DMA11_Y_MODIFY)
+#define bfin_write_DMA11_Y_MODIFY(val)		bfin_write16(DMA11_Y_MODIFY, val)
+#define bfin_read_DMA11_CURR_DESC_PTR()		bfin_read32(DMA11_CURR_DESC_PTR)
+#define bfin_write_DMA11_CURR_DESC_PTR(val)	bfin_write32(DMA11_CURR_DESC_PTR, val)
+#define bfin_read_DMA11_CURR_ADDR()		bfin_read32(DMA11_CURR_ADDR)
+#define bfin_write_DMA11_CURR_ADDR(val)		bfin_write32(DMA11_CURR_ADDR, val)
+#define bfin_read_DMA11_CURR_X_COUNT()		bfin_read16(DMA11_CURR_X_COUNT)
+#define bfin_write_DMA11_CURR_X_COUNT(val)	bfin_write16(DMA11_CURR_X_COUNT, val)
+#define bfin_read_DMA11_CURR_Y_COUNT()		bfin_read16(DMA11_CURR_Y_COUNT)
+#define bfin_write_DMA11_CURR_Y_COUNT(val)	bfin_write16(DMA11_CURR_Y_COUNT, val)
+#define bfin_read_DMA11_IRQ_STATUS()		bfin_read16(DMA11_IRQ_STATUS)
+#define bfin_write_DMA11_IRQ_STATUS(val)	bfin_write16(DMA11_IRQ_STATUS, val)
+#define bfin_read_DMA11_PERIPHERAL_MAP()	bfin_read16(DMA11_PERIPHERAL_MAP)
+#define bfin_write_DMA11_PERIPHERAL_MAP(val)	bfin_write16(DMA11_PERIPHERAL_MAP, val)
+
+#define bfin_read_MDMA_D0_CONFIG()		bfin_read16(MDMA_D0_CONFIG)
+#define bfin_write_MDMA_D0_CONFIG(val)		bfin_write16(MDMA_D0_CONFIG, val)
+#define bfin_read_MDMA_D0_NEXT_DESC_PTR()	bfin_read32(MDMA_D0_NEXT_DESC_PTR)
+#define bfin_write_MDMA_D0_NEXT_DESC_PTR(val)	bfin_write32(MDMA_D0_NEXT_DESC_PTR, val)
+#define bfin_read_MDMA_D0_START_ADDR()		bfin_read32(MDMA_D0_START_ADDR)
+#define bfin_write_MDMA_D0_START_ADDR(val)	bfin_write32(MDMA_D0_START_ADDR, val)
+#define bfin_read_MDMA_D0_X_COUNT()		bfin_read16(MDMA_D0_X_COUNT)
+#define bfin_write_MDMA_D0_X_COUNT(val)		bfin_write16(MDMA_D0_X_COUNT, val)
+#define bfin_read_MDMA_D0_Y_COUNT()		bfin_read16(MDMA_D0_Y_COUNT)
+#define bfin_write_MDMA_D0_Y_COUNT(val)		bfin_write16(MDMA_D0_Y_COUNT, val)
+#define bfin_read_MDMA_D0_X_MODIFY()		bfin_read16(MDMA_D0_X_MODIFY)
+#define bfin_write_MDMA_D0_X_MODIFY(val)	bfin_write16(MDMA_D0_X_MODIFY, val)
+#define bfin_read_MDMA_D0_Y_MODIFY()		bfin_read16(MDMA_D0_Y_MODIFY)
+#define bfin_write_MDMA_D0_Y_MODIFY(val)	bfin_write16(MDMA_D0_Y_MODIFY, val)
+#define bfin_read_MDMA_D0_CURR_DESC_PTR()	bfin_read32(MDMA_D0_CURR_DESC_PTR)
+#define bfin_write_MDMA_D0_CURR_DESC_PTR(val)	bfin_write32(MDMA_D0_CURR_DESC_PTR, val)
+#define bfin_read_MDMA_D0_CURR_ADDR()		bfin_read32(MDMA_D0_CURR_ADDR)
+#define bfin_write_MDMA_D0_CURR_ADDR(val)	bfin_write32(MDMA_D0_CURR_ADDR, val)
+#define bfin_read_MDMA_D0_CURR_X_COUNT()	bfin_read16(MDMA_D0_CURR_X_COUNT)
+#define bfin_write_MDMA_D0_CURR_X_COUNT(val)	bfin_write16(MDMA_D0_CURR_X_COUNT, val)
+#define bfin_read_MDMA_D0_CURR_Y_COUNT()	bfin_read16(MDMA_D0_CURR_Y_COUNT)
+#define bfin_write_MDMA_D0_CURR_Y_COUNT(val)	bfin_write16(MDMA_D0_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_D0_IRQ_STATUS()		bfin_read16(MDMA_D0_IRQ_STATUS)
+#define bfin_write_MDMA_D0_IRQ_STATUS(val)	bfin_write16(MDMA_D0_IRQ_STATUS, val)
+#define bfin_read_MDMA_D0_PERIPHERAL_MAP()	bfin_read16(MDMA_D0_PERIPHERAL_MAP)
+#define bfin_write_MDMA_D0_PERIPHERAL_MAP(val)	bfin_write16(MDMA_D0_PERIPHERAL_MAP, val)
+
+#define bfin_read_MDMA_S0_CONFIG()		bfin_read16(MDMA_S0_CONFIG)
+#define bfin_write_MDMA_S0_CONFIG(val)		bfin_write16(MDMA_S0_CONFIG, val)
+#define bfin_read_MDMA_S0_NEXT_DESC_PTR()	bfin_read32(MDMA_S0_NEXT_DESC_PTR)
+#define bfin_write_MDMA_S0_NEXT_DESC_PTR(val)	bfin_write32(MDMA_S0_NEXT_DESC_PTR, val)
+#define bfin_read_MDMA_S0_START_ADDR()		bfin_read32(MDMA_S0_START_ADDR)
+#define bfin_write_MDMA_S0_START_ADDR(val)	bfin_write32(MDMA_S0_START_ADDR, val)
+#define bfin_read_MDMA_S0_X_COUNT()		bfin_read16(MDMA_S0_X_COUNT)
+#define bfin_write_MDMA_S0_X_COUNT(val)		bfin_write16(MDMA_S0_X_COUNT, val)
+#define bfin_read_MDMA_S0_Y_COUNT()		bfin_read16(MDMA_S0_Y_COUNT)
+#define bfin_write_MDMA_S0_Y_COUNT(val)		bfin_write16(MDMA_S0_Y_COUNT, val)
+#define bfin_read_MDMA_S0_X_MODIFY()		bfin_read16(MDMA_S0_X_MODIFY)
+#define bfin_write_MDMA_S0_X_MODIFY(val)	bfin_write16(MDMA_S0_X_MODIFY, val)
+#define bfin_read_MDMA_S0_Y_MODIFY()		bfin_read16(MDMA_S0_Y_MODIFY)
+#define bfin_write_MDMA_S0_Y_MODIFY(val)	bfin_write16(MDMA_S0_Y_MODIFY, val)
+#define bfin_read_MDMA_S0_CURR_DESC_PTR()	bfin_read32(MDMA_S0_CURR_DESC_PTR)
+#define bfin_write_MDMA_S0_CURR_DESC_PTR(val)	bfin_write32(MDMA_S0_CURR_DESC_PTR, val)
+#define bfin_read_MDMA_S0_CURR_ADDR()		bfin_read32(MDMA_S0_CURR_ADDR)
+#define bfin_write_MDMA_S0_CURR_ADDR(val)	bfin_write32(MDMA_S0_CURR_ADDR, val)
+#define bfin_read_MDMA_S0_CURR_X_COUNT()	bfin_read16(MDMA_S0_CURR_X_COUNT)
+#define bfin_write_MDMA_S0_CURR_X_COUNT(val)	bfin_write16(MDMA_S0_CURR_X_COUNT, val)
+#define bfin_read_MDMA_S0_CURR_Y_COUNT()	bfin_read16(MDMA_S0_CURR_Y_COUNT)
+#define bfin_write_MDMA_S0_CURR_Y_COUNT(val)	bfin_write16(MDMA_S0_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_S0_IRQ_STATUS()		bfin_read16(MDMA_S0_IRQ_STATUS)
+#define bfin_write_MDMA_S0_IRQ_STATUS(val)	bfin_write16(MDMA_S0_IRQ_STATUS, val)
+#define bfin_read_MDMA_S0_PERIPHERAL_MAP()	bfin_read16(MDMA_S0_PERIPHERAL_MAP)
+#define bfin_write_MDMA_S0_PERIPHERAL_MAP(val)	bfin_write16(MDMA_S0_PERIPHERAL_MAP, val)
+
+#define bfin_read_MDMA_D1_CONFIG()		bfin_read16(MDMA_D1_CONFIG)
+#define bfin_write_MDMA_D1_CONFIG(val)		bfin_write16(MDMA_D1_CONFIG, val)
+#define bfin_read_MDMA_D1_NEXT_DESC_PTR()	bfin_read32(MDMA_D1_NEXT_DESC_PTR)
+#define bfin_write_MDMA_D1_NEXT_DESC_PTR(val)	bfin_write32(MDMA_D1_NEXT_DESC_PTR, val)
+#define bfin_read_MDMA_D1_START_ADDR()		bfin_read32(MDMA_D1_START_ADDR)
+#define bfin_write_MDMA_D1_START_ADDR(val)	bfin_write32(MDMA_D1_START_ADDR, val)
+#define bfin_read_MDMA_D1_X_COUNT()		bfin_read16(MDMA_D1_X_COUNT)
+#define bfin_write_MDMA_D1_X_COUNT(val)		bfin_write16(MDMA_D1_X_COUNT, val)
+#define bfin_read_MDMA_D1_Y_COUNT()		bfin_read16(MDMA_D1_Y_COUNT)
+#define bfin_write_MDMA_D1_Y_COUNT(val)		bfin_write16(MDMA_D1_Y_COUNT, val)
+#define bfin_read_MDMA_D1_X_MODIFY()		bfin_read16(MDMA_D1_X_MODIFY)
+#define bfin_write_MDMA_D1_X_MODIFY(val)	bfin_write16(MDMA_D1_X_MODIFY, val)
+#define bfin_read_MDMA_D1_Y_MODIFY()		bfin_read16(MDMA_D1_Y_MODIFY)
+#define bfin_write_MDMA_D1_Y_MODIFY(val)	bfin_write16(MDMA_D1_Y_MODIFY, val)
+#define bfin_read_MDMA_D1_CURR_DESC_PTR()	bfin_read32(MDMA_D1_CURR_DESC_PTR)
+#define bfin_write_MDMA_D1_CURR_DESC_PTR(val)	bfin_write32(MDMA_D1_CURR_DESC_PTR, val)
+#define bfin_read_MDMA_D1_CURR_ADDR()		bfin_read32(MDMA_D1_CURR_ADDR)
+#define bfin_write_MDMA_D1_CURR_ADDR(val)	bfin_write32(MDMA_D1_CURR_ADDR, val)
+#define bfin_read_MDMA_D1_CURR_X_COUNT()	bfin_read16(MDMA_D1_CURR_X_COUNT)
+#define bfin_write_MDMA_D1_CURR_X_COUNT(val)	bfin_write16(MDMA_D1_CURR_X_COUNT, val)
+#define bfin_read_MDMA_D1_CURR_Y_COUNT()	bfin_read16(MDMA_D1_CURR_Y_COUNT)
+#define bfin_write_MDMA_D1_CURR_Y_COUNT(val)	bfin_write16(MDMA_D1_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_D1_IRQ_STATUS()		bfin_read16(MDMA_D1_IRQ_STATUS)
+#define bfin_write_MDMA_D1_IRQ_STATUS(val)	bfin_write16(MDMA_D1_IRQ_STATUS, val)
+#define bfin_read_MDMA_D1_PERIPHERAL_MAP()	bfin_read16(MDMA_D1_PERIPHERAL_MAP)
+#define bfin_write_MDMA_D1_PERIPHERAL_MAP(val)	bfin_write16(MDMA_D1_PERIPHERAL_MAP, val)
+
+#define bfin_read_MDMA_S1_CONFIG()		bfin_read16(MDMA_S1_CONFIG)
+#define bfin_write_MDMA_S1_CONFIG(val)		bfin_write16(MDMA_S1_CONFIG, val)
+#define bfin_read_MDMA_S1_NEXT_DESC_PTR()	bfin_read32(MDMA_S1_NEXT_DESC_PTR)
+#define bfin_write_MDMA_S1_NEXT_DESC_PTR(val)	bfin_write32(MDMA_S1_NEXT_DESC_PTR, val)
+#define bfin_read_MDMA_S1_START_ADDR()		bfin_read32(MDMA_S1_START_ADDR)
+#define bfin_write_MDMA_S1_START_ADDR(val)	bfin_write32(MDMA_S1_START_ADDR, val)
+#define bfin_read_MDMA_S1_X_COUNT()		bfin_read16(MDMA_S1_X_COUNT)
+#define bfin_write_MDMA_S1_X_COUNT(val)		bfin_write16(MDMA_S1_X_COUNT, val)
+#define bfin_read_MDMA_S1_Y_COUNT()		bfin_read16(MDMA_S1_Y_COUNT)
+#define bfin_write_MDMA_S1_Y_COUNT(val)		bfin_write16(MDMA_S1_Y_COUNT, val)
+#define bfin_read_MDMA_S1_X_MODIFY()		bfin_read16(MDMA_S1_X_MODIFY)
+#define bfin_write_MDMA_S1_X_MODIFY(val)	bfin_write16(MDMA_S1_X_MODIFY, val)
+#define bfin_read_MDMA_S1_Y_MODIFY()		bfin_read16(MDMA_S1_Y_MODIFY)
+#define bfin_write_MDMA_S1_Y_MODIFY(val)	bfin_write16(MDMA_S1_Y_MODIFY, val)
+#define bfin_read_MDMA_S1_CURR_DESC_PTR()	bfin_read32(MDMA_S1_CURR_DESC_PTR)
+#define bfin_write_MDMA_S1_CURR_DESC_PTR(val)	bfin_write32(MDMA_S1_CURR_DESC_PTR, val)
+#define bfin_read_MDMA_S1_CURR_ADDR()		bfin_read32(MDMA_S1_CURR_ADDR)
+#define bfin_write_MDMA_S1_CURR_ADDR(val)	bfin_write32(MDMA_S1_CURR_ADDR, val)
+#define bfin_read_MDMA_S1_CURR_X_COUNT()	bfin_read16(MDMA_S1_CURR_X_COUNT)
+#define bfin_write_MDMA_S1_CURR_X_COUNT(val)	bfin_write16(MDMA_S1_CURR_X_COUNT, val)
+#define bfin_read_MDMA_S1_CURR_Y_COUNT()	bfin_read16(MDMA_S1_CURR_Y_COUNT)
+#define bfin_write_MDMA_S1_CURR_Y_COUNT(val)	bfin_write16(MDMA_S1_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_S1_IRQ_STATUS()		bfin_read16(MDMA_S1_IRQ_STATUS)
+#define bfin_write_MDMA_S1_IRQ_STATUS(val)	bfin_write16(MDMA_S1_IRQ_STATUS, val)
+#define bfin_read_MDMA_S1_PERIPHERAL_MAP()	bfin_read16(MDMA_S1_PERIPHERAL_MAP)
+#define bfin_write_MDMA_S1_PERIPHERAL_MAP(val)	bfin_write16(MDMA_S1_PERIPHERAL_MAP, val)
+
+
+/* Parallel Peripheral Interface (0xFFC01000 - 0xFFC010FF)							*/
+#define bfin_read_PPI_CONTROL()			bfin_read16(PPI_CONTROL)
+#define bfin_write_PPI_CONTROL(val)		bfin_write16(PPI_CONTROL, val)
+#define bfin_read_PPI_STATUS()			bfin_read16(PPI_STATUS)
+#define bfin_write_PPI_STATUS(val)		bfin_write16(PPI_STATUS, val)
+#define bfin_read_PPI_DELAY()			bfin_read16(PPI_DELAY)
+#define bfin_write_PPI_DELAY(val)		bfin_write16(PPI_DELAY, val)
+#define bfin_read_PPI_COUNT()			bfin_read16(PPI_COUNT)
+#define bfin_write_PPI_COUNT(val)		bfin_write16(PPI_COUNT, val)
+#define bfin_read_PPI_FRAME()			bfin_read16(PPI_FRAME)
+#define bfin_write_PPI_FRAME(val)		bfin_write16(PPI_FRAME, val)
+
+
+/* Two-Wire Interface		(0xFFC01400 - 0xFFC014FF)								*/
+#define bfin_read_TWI_CLKDIV()			bfin_read16(TWI_CLKDIV)
+#define bfin_write_TWI_CLKDIV(val)		bfin_write16(TWI_CLKDIV, val)
+#define bfin_read_TWI_CONTROL()			bfin_read16(TWI_CONTROL)
+#define bfin_write_TWI_CONTROL(val)		bfin_write16(TWI_CONTROL, val)
+#define bfin_read_TWI_SLAVE_CTL()		bfin_read16(TWI_SLAVE_CTL)
+#define bfin_write_TWI_SLAVE_CTL(val)		bfin_write16(TWI_SLAVE_CTL, val)
+#define bfin_read_TWI_SLAVE_STAT()		bfin_read16(TWI_SLAVE_STAT)
+#define bfin_write_TWI_SLAVE_STAT(val)		bfin_write16(TWI_SLAVE_STAT, val)
+#define bfin_read_TWI_SLAVE_ADDR()		bfin_read16(TWI_SLAVE_ADDR)
+#define bfin_write_TWI_SLAVE_ADDR(val)		bfin_write16(TWI_SLAVE_ADDR, val)
+#define bfin_read_TWI_MASTER_CTL()		bfin_read16(TWI_MASTER_CTL)
+#define bfin_write_TWI_MASTER_CTL(val)		bfin_write16(TWI_MASTER_CTL, val)
+#define bfin_read_TWI_MASTER_STAT()		bfin_read16(TWI_MASTER_STAT)
+#define bfin_write_TWI_MASTER_STAT(val)		bfin_write16(TWI_MASTER_STAT, val)
+#define bfin_read_TWI_MASTER_ADDR()		bfin_read16(TWI_MASTER_ADDR)
+#define bfin_write_TWI_MASTER_ADDR(val)		bfin_write16(TWI_MASTER_ADDR, val)
+#define bfin_read_TWI_INT_STAT()		bfin_read16(TWI_INT_STAT)
+#define bfin_write_TWI_INT_STAT(val)		bfin_write16(TWI_INT_STAT, val)
+#define bfin_read_TWI_INT_MASK()		bfin_read16(TWI_INT_MASK)
+#define bfin_write_TWI_INT_MASK(val)		bfin_write16(TWI_INT_MASK, val)
+#define bfin_read_TWI_FIFO_CTL()		bfin_read16(TWI_FIFO_CTL)
+#define bfin_write_TWI_FIFO_CTL(val)		bfin_write16(TWI_FIFO_CTL, val)
+#define bfin_read_TWI_FIFO_STAT()		bfin_read16(TWI_FIFO_STAT)
+#define bfin_write_TWI_FIFO_STAT(val)		bfin_write16(TWI_FIFO_STAT, val)
+#define bfin_read_TWI_XMT_DATA8()		bfin_read16(TWI_XMT_DATA8)
+#define bfin_write_TWI_XMT_DATA8(val)		bfin_write16(TWI_XMT_DATA8, val)
+#define bfin_read_TWI_XMT_DATA16()		bfin_read16(TWI_XMT_DATA16)
+#define bfin_write_TWI_XMT_DATA16(val)		bfin_write16(TWI_XMT_DATA16, val)
+#define bfin_read_TWI_RCV_DATA8()		bfin_read16(TWI_RCV_DATA8)
+#define bfin_write_TWI_RCV_DATA8(val)		bfin_write16(TWI_RCV_DATA8, val)
+#define bfin_read_TWI_RCV_DATA16()		bfin_read16(TWI_RCV_DATA16)
+#define bfin_write_TWI_RCV_DATA16(val)		bfin_write16(TWI_RCV_DATA16, val)
+
+
+/* General Purpose I/O Port G (0xFFC01500 - 0xFFC015FF)								*/
+#define bfin_read_PORTGIO()			bfin_read16(PORTGIO)
+#define bfin_write_PORTGIO(val)			bfin_write16(PORTGIO, val)
+#define bfin_read_PORTGIO_CLEAR()		bfin_read16(PORTGIO_CLEAR)
+#define bfin_write_PORTGIO_CLEAR(val)		bfin_write16(PORTGIO_CLEAR, val)
+#define bfin_read_PORTGIO_SET()			bfin_read16(PORTGIO_SET)
+#define bfin_write_PORTGIO_SET(val)		bfin_write16(PORTGIO_SET, val)
+#define bfin_read_PORTGIO_TOGGLE()		bfin_read16(PORTGIO_TOGGLE)
+#define bfin_write_PORTGIO_TOGGLE(val)		bfin_write16(PORTGIO_TOGGLE, val)
+#define bfin_read_PORTGIO_MASKA()		bfin_read16(PORTGIO_MASKA)
+#define bfin_write_PORTGIO_MASKA(val)		bfin_write16(PORTGIO_MASKA, val)
+#define bfin_read_PORTGIO_MASKA_CLEAR()		bfin_read16(PORTGIO_MASKA_CLEAR)
+#define bfin_write_PORTGIO_MASKA_CLEAR(val)	bfin_write16(PORTGIO_MASKA_CLEAR, val)
+#define bfin_read_PORTGIO_MASKA_SET()		bfin_read16(PORTGIO_MASKA_SET)
+#define bfin_write_PORTGIO_MASKA_SET(val)	bfin_write16(PORTGIO_MASKA_SET, val)
+#define bfin_read_PORTGIO_MASKA_TOGGLE()	bfin_read16(PORTGIO_MASKA_TOGGLE)
+#define bfin_write_PORTGIO_MASKA_TOGGLE(val)	bfin_write16(PORTGIO_MASKA_TOGGLE, val)
+#define bfin_read_PORTGIO_MASKB()		bfin_read16(PORTGIO_MASKB)
+#define bfin_write_PORTGIO_MASKB(val)		bfin_write16(PORTGIO_MASKB, val)
+#define bfin_read_PORTGIO_MASKB_CLEAR()		bfin_read16(PORTGIO_MASKB_CLEAR)
+#define bfin_write_PORTGIO_MASKB_CLEAR(val)	bfin_write16(PORTGIO_MASKB_CLEAR, val)
+#define bfin_read_PORTGIO_MASKB_SET()		bfin_read16(PORTGIO_MASKB_SET)
+#define bfin_write_PORTGIO_MASKB_SET(val)	bfin_write16(PORTGIO_MASKB_SET, val)
+#define bfin_read_PORTGIO_MASKB_TOGGLE()	bfin_read16(PORTGIO_MASKB_TOGGLE)
+#define bfin_write_PORTGIO_MASKB_TOGGLE(val)	bfin_write16(PORTGIO_MASKB_TOGGLE, val)
+#define bfin_read_PORTGIO_DIR()			bfin_read16(PORTGIO_DIR)
+#define bfin_write_PORTGIO_DIR(val)		bfin_write16(PORTGIO_DIR, val)
+#define bfin_read_PORTGIO_POLAR()		bfin_read16(PORTGIO_POLAR)
+#define bfin_write_PORTGIO_POLAR(val)		bfin_write16(PORTGIO_POLAR, val)
+#define bfin_read_PORTGIO_EDGE()		bfin_read16(PORTGIO_EDGE)
+#define bfin_write_PORTGIO_EDGE(val)		bfin_write16(PORTGIO_EDGE, val)
+#define bfin_read_PORTGIO_BOTH()		bfin_read16(PORTGIO_BOTH)
+#define bfin_write_PORTGIO_BOTH(val)		bfin_write16(PORTGIO_BOTH, val)
+#define bfin_read_PORTGIO_INEN()		bfin_read16(PORTGIO_INEN)
+#define bfin_write_PORTGIO_INEN(val)		bfin_write16(PORTGIO_INEN, val)
+
+
+/* General Purpose I/O Port H (0xFFC01700 - 0xFFC017FF)								*/
+#define bfin_read_PORTHIO()			bfin_read16(PORTHIO)
+#define bfin_write_PORTHIO(val)			bfin_write16(PORTHIO, val)
+#define bfin_read_PORTHIO_CLEAR()		bfin_read16(PORTHIO_CLEAR)
+#define bfin_write_PORTHIO_CLEAR(val)		bfin_write16(PORTHIO_CLEAR, val)
+#define bfin_read_PORTHIO_SET()			bfin_read16(PORTHIO_SET)
+#define bfin_write_PORTHIO_SET(val)		bfin_write16(PORTHIO_SET, val)
+#define bfin_read_PORTHIO_TOGGLE()		bfin_read16(PORTHIO_TOGGLE)
+#define bfin_write_PORTHIO_TOGGLE(val)		bfin_write16(PORTHIO_TOGGLE, val)
+#define bfin_read_PORTHIO_MASKA()		bfin_read16(PORTHIO_MASKA)
+#define bfin_write_PORTHIO_MASKA(val)		bfin_write16(PORTHIO_MASKA, val)
+#define bfin_read_PORTHIO_MASKA_CLEAR()		bfin_read16(PORTHIO_MASKA_CLEAR)
+#define bfin_write_PORTHIO_MASKA_CLEAR(val)	bfin_write16(PORTHIO_MASKA_CLEAR, val)
+#define bfin_read_PORTHIO_MASKA_SET()		bfin_read16(PORTHIO_MASKA_SET)
+#define bfin_write_PORTHIO_MASKA_SET(val)	bfin_write16(PORTHIO_MASKA_SET, val)
+#define bfin_read_PORTHIO_MASKA_TOGGLE()	bfin_read16(PORTHIO_MASKA_TOGGLE)
+#define bfin_write_PORTHIO_MASKA_TOGGLE(val)	bfin_write16(PORTHIO_MASKA_TOGGLE, val)
+#define bfin_read_PORTHIO_MASKB()		bfin_read16(PORTHIO_MASKB)
+#define bfin_write_PORTHIO_MASKB(val)		bfin_write16(PORTHIO_MASKB, val)
+#define bfin_read_PORTHIO_MASKB_CLEAR()		bfin_read16(PORTHIO_MASKB_CLEAR)
+#define bfin_write_PORTHIO_MASKB_CLEAR(val)	bfin_write16(PORTHIO_MASKB_CLEAR, val)
+#define bfin_read_PORTHIO_MASKB_SET()		bfin_read16(PORTHIO_MASKB_SET)
+#define bfin_write_PORTHIO_MASKB_SET(val)	bfin_write16(PORTHIO_MASKB_SET, val)
+#define bfin_read_PORTHIO_MASKB_TOGGLE()	bfin_read16(PORTHIO_MASKB_TOGGLE)
+#define bfin_write_PORTHIO_MASKB_TOGGLE(val)	bfin_write16(PORTHIO_MASKB_TOGGLE, val)
+#define bfin_read_PORTHIO_DIR()			bfin_read16(PORTHIO_DIR)
+#define bfin_write_PORTHIO_DIR(val)		bfin_write16(PORTHIO_DIR, val)
+#define bfin_read_PORTHIO_POLAR()		bfin_read16(PORTHIO_POLAR)
+#define bfin_write_PORTHIO_POLAR(val)		bfin_write16(PORTHIO_POLAR, val)
+#define bfin_read_PORTHIO_EDGE()		bfin_read16(PORTHIO_EDGE)
+#define bfin_write_PORTHIO_EDGE(val)		bfin_write16(PORTHIO_EDGE, val)
+#define bfin_read_PORTHIO_BOTH()		bfin_read16(PORTHIO_BOTH)
+#define bfin_write_PORTHIO_BOTH(val)		bfin_write16(PORTHIO_BOTH, val)
+#define bfin_read_PORTHIO_INEN()		bfin_read16(PORTHIO_INEN)
+#define bfin_write_PORTHIO_INEN(val)		bfin_write16(PORTHIO_INEN, val)
+
+
+/* UART1 Controller		(0xFFC02000 - 0xFFC020FF)								*/
+#define bfin_read_UART1_THR()			bfin_read16(UART1_THR)
+#define bfin_write_UART1_THR(val)		bfin_write16(UART1_THR, val)
+#define bfin_read_UART1_RBR()			bfin_read16(UART1_RBR)
+#define bfin_write_UART1_RBR(val)		bfin_write16(UART1_RBR, val)
+#define bfin_read_UART1_DLL()			bfin_read16(UART1_DLL)
+#define bfin_write_UART1_DLL(val)		bfin_write16(UART1_DLL, val)
+#define bfin_read_UART1_IER()			bfin_read16(UART1_IER)
+#define bfin_write_UART1_IER(val)		bfin_write16(UART1_IER, val)
+#define bfin_read_UART1_DLH()			bfin_read16(UART1_DLH)
+#define bfin_write_UART1_DLH(val)		bfin_write16(UART1_DLH, val)
+#define bfin_read_UART1_IIR()			bfin_read16(UART1_IIR)
+#define bfin_write_UART1_IIR(val)		bfin_write16(UART1_IIR, val)
+#define bfin_read_UART1_LCR()			bfin_read16(UART1_LCR)
+#define bfin_write_UART1_LCR(val)		bfin_write16(UART1_LCR, val)
+#define bfin_read_UART1_MCR()			bfin_read16(UART1_MCR)
+#define bfin_write_UART1_MCR(val)		bfin_write16(UART1_MCR, val)
+#define bfin_read_UART1_LSR()			bfin_read16(UART1_LSR)
+#define bfin_write_UART1_LSR(val)		bfin_write16(UART1_LSR, val)
+#define bfin_read_UART1_MSR()			bfin_read16(UART1_MSR)
+#define bfin_write_UART1_MSR(val)		bfin_write16(UART1_MSR, val)
+#define bfin_read_UART1_SCR()			bfin_read16(UART1_SCR)
+#define bfin_write_UART1_SCR(val)		bfin_write16(UART1_SCR, val)
+#define bfin_read_UART1_GCTL()			bfin_read16(UART1_GCTL)
+#define bfin_write_UART1_GCTL(val)		bfin_write16(UART1_GCTL, val)
+
+/* Omit CAN register sets from the cdefBF534.h (CAN is not in the ADSP-BF52x processor) */
+
+/* Pin Control Registers	(0xFFC03200 - 0xFFC032FF)								*/
+#define bfin_read_PORTF_FER()			bfin_read16(PORTF_FER)
+#define bfin_write_PORTF_FER(val)		bfin_write16(PORTF_FER, val)
+#define bfin_read_PORTG_FER()			bfin_read16(PORTG_FER)
+#define bfin_write_PORTG_FER(val)		bfin_write16(PORTG_FER, val)
+#define bfin_read_PORTH_FER()			bfin_read16(PORTH_FER)
+#define bfin_write_PORTH_FER(val)		bfin_write16(PORTH_FER, val)
+#define bfin_read_PORT_MUX()			bfin_read16(PORT_MUX)
+#define bfin_write_PORT_MUX(val)		bfin_write16(PORT_MUX, val)
+
+
+/* Handshake MDMA Registers	(0xFFC03300 - 0xFFC033FF)								*/
+#define bfin_read_HMDMA0_CONTROL()		bfin_read16(HMDMA0_CONTROL)
+#define bfin_write_HMDMA0_CONTROL(val)		bfin_write16(HMDMA0_CONTROL, val)
+#define bfin_read_HMDMA0_ECINIT()		bfin_read16(HMDMA0_ECINIT)
+#define bfin_write_HMDMA0_ECINIT(val)		bfin_write16(HMDMA0_ECINIT, val)
+#define bfin_read_HMDMA0_BCINIT()		bfin_read16(HMDMA0_BCINIT)
+#define bfin_write_HMDMA0_BCINIT(val)		bfin_write16(HMDMA0_BCINIT, val)
+#define bfin_read_HMDMA0_ECURGENT()		bfin_read16(HMDMA0_ECURGENT)
+#define bfin_write_HMDMA0_ECURGENT(val)		bfin_write16(HMDMA0_ECURGENT, val)
+#define bfin_read_HMDMA0_ECOVERFLOW()		bfin_read16(HMDMA0_ECOVERFLOW)
+#define bfin_write_HMDMA0_ECOVERFLOW(val)	bfin_write16(HMDMA0_ECOVERFLOW, val)
+#define bfin_read_HMDMA0_ECOUNT()		bfin_read16(HMDMA0_ECOUNT)
+#define bfin_write_HMDMA0_ECOUNT(val)		bfin_write16(HMDMA0_ECOUNT, val)
+#define bfin_read_HMDMA0_BCOUNT()		bfin_read16(HMDMA0_BCOUNT)
+#define bfin_write_HMDMA0_BCOUNT(val)		bfin_write16(HMDMA0_BCOUNT, val)
+
+#define bfin_read_HMDMA1_CONTROL()		bfin_read16(HMDMA1_CONTROL)
+#define bfin_write_HMDMA1_CONTROL(val)		bfin_write16(HMDMA1_CONTROL, val)
+#define bfin_read_HMDMA1_ECINIT()		bfin_read16(HMDMA1_ECINIT)
+#define bfin_write_HMDMA1_ECINIT(val)		bfin_write16(HMDMA1_ECINIT, val)
+#define bfin_read_HMDMA1_BCINIT()		bfin_read16(HMDMA1_BCINIT)
+#define bfin_write_HMDMA1_BCINIT(val)		bfin_write16(HMDMA1_BCINIT, val)
+#define bfin_read_HMDMA1_ECURGENT()		bfin_read16(HMDMA1_ECURGENT)
+#define bfin_write_HMDMA1_ECURGENT(val)		bfin_write16(HMDMA1_ECURGENT, val)
+#define bfin_read_HMDMA1_ECOVERFLOW()		bfin_read16(HMDMA1_ECOVERFLOW)
+#define bfin_write_HMDMA1_ECOVERFLOW(val)	bfin_write16(HMDMA1_ECOVERFLOW, val)
+#define bfin_read_HMDMA1_ECOUNT()		bfin_read16(HMDMA1_ECOUNT)
+#define bfin_write_HMDMA1_ECOUNT(val)		bfin_write16(HMDMA1_ECOUNT, val)
+#define bfin_read_HMDMA1_BCOUNT()		bfin_read16(HMDMA1_BCOUNT)
+#define bfin_write_HMDMA1_BCOUNT(val)		bfin_write16(HMDMA1_BCOUNT, val)
+
+/* ==== end from cdefBF534.h ==== */
+
+/* GPIO PIN mux (0xFFC03210 - OxFFC03288) */
+
+#define bfin_read_PORTF_MUX()			bfin_read16(PORTF_MUX)
+#define bfin_write_PORTF_MUX(val)		bfin_write16(PORTF_MUX, val)
+#define bfin_read_PORTG_MUX()			bfin_read16(PORTG_MUX)
+#define bfin_write_PORTG_MUX(val)		bfin_write16(PORTG_MUX, val)
+#define bfin_read_PORTH_MUX()			bfin_read16(PORTH_MUX)
+#define bfin_write_PORTH_MUX(val)		bfin_write16(PORTH_MUX, val)
+
+#define bfin_read_PORTF_DRIVE()			bfin_read16(PORTF_DRIVE)
+#define bfin_write_PORTF_DRIVE(val)		bfin_write16(PORTF_DRIVE, val)
+#define bfin_read_PORTG_DRIVE()			bfin_read16(PORTG_DRIVE)
+#define bfin_write_PORTG_DRIVE(val)		bfin_write16(PORTG_DRIVE, val)
+#define bfin_read_PORTH_DRIVE()			bfin_read16(PORTH_DRIVE)
+#define bfin_write_PORTH_DRIVE(val)		bfin_write16(PORTH_DRIVE, val)
+#define bfin_read_PORTF_SLEW()			bfin_read16(PORTF_SLEW)
+#define bfin_write_PORTF_SLEW(val)		bfin_write16(PORTF_SLEW, val)
+#define bfin_read_PORTG_SLEW()			bfin_read16(PORTG_SLEW)
+#define bfin_write_PORTG_SLEW(val)		bfin_write16(PORTG_SLEW, val)
+#define bfin_read_PORTH_SLEW()			bfin_read16(PORTH_SLEW)
+#define bfin_write_PORTH_SLEW(val)		bfin_write16(PORTH_SLEW, val)
+#define bfin_read_PORTF_HYSTERISIS()		bfin_read16(PORTF_HYSTERISIS)
+#define bfin_write_PORTF_HYSTERISIS(val)	bfin_write16(PORTF_HYSTERISIS, val)
+#define bfin_read_PORTG_HYSTERISIS()		bfin_read16(PORTG_HYSTERISIS)
+#define bfin_write_PORTG_HYSTERISIS(val)	bfin_write16(PORTG_HYSTERISIS, val)
+#define bfin_read_PORTH_HYSTERISIS()		bfin_read16(PORTH_HYSTERISIS)
+#define bfin_write_PORTH_HYSTERISIS(val)	bfin_write16(PORTH_HYSTERISIS, val)
+#define bfin_read_MISCPORT_DRIVE()		bfin_read16(MISCPORT_DRIVE)
+#define bfin_write_MISCPORT_DRIVE(val)		bfin_write16(MISCPORT_DRIVE, val)
+#define bfin_read_MISCPORT_SLEW()		bfin_read16(MISCPORT_SLEW)
+#define bfin_write_MISCPORT_SLEW(val)		bfin_write16(MISCPORT_SLEW, val)
+#define bfin_read_MISCPORT_HYSTERISIS()		bfin_read16(MISCPORT_HYSTERISIS)
+#define bfin_write_MISCPORT_HYSTERISIS(val)	bfin_write16(MISCPORT_HYSTERISIS, val)
+
+/* HOST Port Registers */
+
+#define bfin_read_HOST_CONTROL()		bfin_read16(HOST_CONTROL)
+#define bfin_write_HOST_CONTROL(val)		bfin_write16(HOST_CONTROL, val)
+#define bfin_read_HOST_STATUS()			bfin_read16(HOST_STATUS)
+#define bfin_write_HOST_STATUS(val)		bfin_write16(HOST_STATUS, val)
+#define bfin_read_HOST_TIMEOUT()		bfin_read16(HOST_TIMEOUT)
+#define bfin_write_HOST_TIMEOUT(val)		bfin_write16(HOST_TIMEOUT, val)
+
+/* Counter Registers */
+
+#define bfin_read_CNT_CONFIG()			bfin_read16(CNT_CONFIG)
+#define bfin_write_CNT_CONFIG(val)		bfin_write16(CNT_CONFIG, val)
+#define bfin_read_CNT_IMASK()			bfin_read16(CNT_IMASK)
+#define bfin_write_CNT_IMASK(val)		bfin_write16(CNT_IMASK, val)
+#define bfin_read_CNT_STATUS()			bfin_read16(CNT_STATUS)
+#define bfin_write_CNT_STATUS(val)		bfin_write16(CNT_STATUS, val)
+#define bfin_read_CNT_COMMAND()			bfin_read16(CNT_COMMAND)
+#define bfin_write_CNT_COMMAND(val)		bfin_write16(CNT_COMMAND, val)
+#define bfin_read_CNT_DEBOUNCE()		bfin_read16(CNT_DEBOUNCE)
+#define bfin_write_CNT_DEBOUNCE(val)		bfin_write16(CNT_DEBOUNCE, val)
+#define bfin_read_CNT_COUNTER()			bfin_read32(CNT_COUNTER)
+#define bfin_write_CNT_COUNTER(val)		bfin_write32(CNT_COUNTER, val)
+#define bfin_read_CNT_MAX()			bfin_read32(CNT_MAX)
+#define bfin_write_CNT_MAX(val)			bfin_write32(CNT_MAX, val)
+#define bfin_read_CNT_MIN()			bfin_read32(CNT_MIN)
+#define bfin_write_CNT_MIN(val)			bfin_write32(CNT_MIN, val)
+
+/* OTP/FUSE Registers */
+
+#define bfin_read_OTP_CONTROL()			bfin_read16(OTP_CONTROL)
+#define bfin_write_OTP_CONTROL(val)		bfin_write16(OTP_CONTROL, val)
+#define bfin_read_OTP_BEN()			bfin_read16(OTP_BEN)
+#define bfin_write_OTP_BEN(val)			bfin_write16(OTP_BEN, val)
+#define bfin_read_OTP_STATUS()			bfin_read16(OTP_STATUS)
+#define bfin_write_OTP_STATUS(val)		bfin_write16(OTP_STATUS, val)
+#define bfin_read_OTP_TIMING()			bfin_read32(OTP_TIMING)
+#define bfin_write_OTP_TIMING(val)		bfin_write32(OTP_TIMING, val)
+
+/* Security Registers */
+
+#define bfin_read_SECURE_SYSSWT()		bfin_read32(SECURE_SYSSWT)
+#define bfin_write_SECURE_SYSSWT(val)		bfin_write32(SECURE_SYSSWT, val)
+#define bfin_read_SECURE_CONTROL()		bfin_read16(SECURE_CONTROL)
+#define bfin_write_SECURE_CONTROL(val)		bfin_write16(SECURE_CONTROL, val)
+#define bfin_read_SECURE_STATUS()		bfin_read16(SECURE_STATUS)
+#define bfin_write_SECURE_STATUS(val)		bfin_write16(SECURE_STATUS, val)
+
+/* OTP Read/Write Data Buffer Registers */
+
+#define bfin_read_OTP_DATA0()			bfin_read32(OTP_DATA0)
+#define bfin_write_OTP_DATA0(val)		bfin_write32(OTP_DATA0, val)
+#define bfin_read_OTP_DATA1()			bfin_read32(OTP_DATA1)
+#define bfin_write_OTP_DATA1(val)		bfin_write32(OTP_DATA1, val)
+#define bfin_read_OTP_DATA2()			bfin_read32(OTP_DATA2)
+#define bfin_write_OTP_DATA2(val)		bfin_write32(OTP_DATA2, val)
+#define bfin_read_OTP_DATA3()			bfin_read32(OTP_DATA3)
+#define bfin_write_OTP_DATA3(val)		bfin_write32(OTP_DATA3, val)
+
+/* NFC Registers */
+
+#define bfin_read_NFC_CTL()			bfin_read16(NFC_CTL)
+#define bfin_write_NFC_CTL(val)			bfin_write16(NFC_CTL, val)
+#define bfin_read_NFC_STAT()			bfin_read16(NFC_STAT)
+#define bfin_write_NFC_STAT(val)		bfin_write16(NFC_STAT, val)
+#define bfin_read_NFC_IRQSTAT()			bfin_read16(NFC_IRQSTAT)
+#define bfin_write_NFC_IRQSTAT(val)		bfin_write16(NFC_IRQSTAT, val)
+#define bfin_read_NFC_IRQMASK()			bfin_read16(NFC_IRQMASK)
+#define bfin_write_NFC_IRQMASK(val)		bfin_write16(NFC_IRQMASK, val)
+#define bfin_read_NFC_ECC0()			bfin_read16(NFC_ECC0)
+#define bfin_write_NFC_ECC0(val)		bfin_write16(NFC_ECC0, val)
+#define bfin_read_NFC_ECC1()			bfin_read16(NFC_ECC1)
+#define bfin_write_NFC_ECC1(val)		bfin_write16(NFC_ECC1, val)
+#define bfin_read_NFC_ECC2()			bfin_read16(NFC_ECC2)
+#define bfin_write_NFC_ECC2(val)		bfin_write16(NFC_ECC2, val)
+#define bfin_read_NFC_ECC3()			bfin_read16(NFC_ECC3)
+#define bfin_write_NFC_ECC3(val)		bfin_write16(NFC_ECC3, val)
+#define bfin_read_NFC_COUNT()			bfin_read16(NFC_COUNT)
+#define bfin_write_NFC_COUNT(val)		bfin_write16(NFC_COUNT, val)
+#define bfin_read_NFC_RST()			bfin_read16(NFC_RST)
+#define bfin_write_NFC_RST(val)			bfin_write16(NFC_RST, val)
+#define bfin_read_NFC_PGCTL()			bfin_read16(NFC_PGCTL)
+#define bfin_write_NFC_PGCTL(val)		bfin_write16(NFC_PGCTL, val)
+#define bfin_read_NFC_READ()			bfin_read16(NFC_READ)
+#define bfin_write_NFC_READ(val)		bfin_write16(NFC_READ, val)
+#define bfin_read_NFC_ADDR()			bfin_read16(NFC_ADDR)
+#define bfin_write_NFC_ADDR(val)		bfin_write16(NFC_ADDR, val)
+#define bfin_read_NFC_CMD()			bfin_read16(NFC_CMD)
+#define bfin_write_NFC_CMD(val)			bfin_write16(NFC_CMD, val)
+#define bfin_read_NFC_DATA_WR()			bfin_read16(NFC_DATA_WR)
+#define bfin_write_NFC_DATA_WR(val)		bfin_write16(NFC_DATA_WR, val)
+#define bfin_read_NFC_DATA_RD()			bfin_read16(NFC_DATA_RD)
+#define bfin_write_NFC_DATA_RD(val)		bfin_write16(NFC_DATA_RD, val)
+
+#endif /* _CDEF_BF52X_H */
diff --git a/include/asm-blackfin/mach-bf527/defBF522.h b/include/asm-blackfin/mach-bf527/defBF522.h
new file mode 100644
index 0000000..9671d8f
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/defBF522.h
@@ -0,0 +1,42 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/defBF522.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF522_H
+#define _DEF_BF522_H
+
+/* Include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF522 */
+
+/* Include defBF52x_base.h for the set of #defines that are common to all ADSP-BF52x processors */
+#include "defBF52x_base.h"
+
+#endif /* _DEF_BF522_H */
diff --git a/include/asm-blackfin/mach-bf527/defBF525.h b/include/asm-blackfin/mach-bf527/defBF525.h
new file mode 100644
index 0000000..6a375a0
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/defBF525.h
@@ -0,0 +1,713 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/defBF525.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF525_H
+#define _DEF_BF525_H
+
+/* Include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF525 */
+
+/* Include defBF52x_base.h for the set of #defines that are common to all ADSP-BF52x processors */
+#include "defBF52x_base.h"
+
+/* The following are the #defines needed by ADSP-BF525 that are not in the common header */
+
+/* USB Control Registers */
+
+#define                        USB_FADDR  0xffc03800   /* Function address register */
+#define                        USB_POWER  0xffc03804   /* Power management register */
+#define                       USB_INTRTX  0xffc03808   /* Interrupt register for endpoint 0 and Tx endpoint 1 to 7 */
+#define                       USB_INTRRX  0xffc0380c   /* Interrupt register for Rx endpoints 1 to 7 */
+#define                      USB_INTRTXE  0xffc03810   /* Interrupt enable register for IntrTx */
+#define                      USB_INTRRXE  0xffc03814   /* Interrupt enable register for IntrRx */
+#define                      USB_INTRUSB  0xffc03818   /* Interrupt register for common USB interrupts */
+#define                     USB_INTRUSBE  0xffc0381c   /* Interrupt enable register for IntrUSB */
+#define                        USB_FRAME  0xffc03820   /* USB frame number */
+#define                        USB_INDEX  0xffc03824   /* Index register for selecting the indexed endpoint registers */
+#define                     USB_TESTMODE  0xffc03828   /* Enabled USB 20 test modes */
+#define                     USB_GLOBINTR  0xffc0382c   /* Global Interrupt Mask register and Wakeup Exception Interrupt */
+#define                   USB_GLOBAL_CTL  0xffc03830   /* Global Clock Control for the core */
+
+/* USB Packet Control Registers */
+
+#define                USB_TX_MAX_PACKET  0xffc03840   /* Maximum packet size for Host Tx endpoint */
+#define                         USB_CSR0  0xffc03844   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                        USB_TXCSR  0xffc03844   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                USB_RX_MAX_PACKET  0xffc03848   /* Maximum packet size for Host Rx endpoint */
+#define                        USB_RXCSR  0xffc0384c   /* Control Status register for Host Rx endpoint */
+#define                       USB_COUNT0  0xffc03850   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                      USB_RXCOUNT  0xffc03850   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                       USB_TXTYPE  0xffc03854   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint */
+#define                    USB_NAKLIMIT0  0xffc03858   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                   USB_TXINTERVAL  0xffc03858   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                       USB_RXTYPE  0xffc0385c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint */
+#define                   USB_RXINTERVAL  0xffc03860   /* Sets the polling interval for Interrupt and Isochronous transfers or the NAK response timeout on Bulk transfers */
+#define                      USB_TXCOUNT  0xffc03868   /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* USB Endpoint FIFO Registers */
+
+#define                     USB_EP0_FIFO  0xffc03880   /* Endpoint 0 FIFO */
+#define                     USB_EP1_FIFO  0xffc03888   /* Endpoint 1 FIFO */
+#define                     USB_EP2_FIFO  0xffc03890   /* Endpoint 2 FIFO */
+#define                     USB_EP3_FIFO  0xffc03898   /* Endpoint 3 FIFO */
+#define                     USB_EP4_FIFO  0xffc038a0   /* Endpoint 4 FIFO */
+#define                     USB_EP5_FIFO  0xffc038a8   /* Endpoint 5 FIFO */
+#define                     USB_EP6_FIFO  0xffc038b0   /* Endpoint 6 FIFO */
+#define                     USB_EP7_FIFO  0xffc038b8   /* Endpoint 7 FIFO */
+
+/* USB OTG Control Registers */
+
+#define                  USB_OTG_DEV_CTL  0xffc03900   /* OTG Device Control Register */
+#define                 USB_OTG_VBUS_IRQ  0xffc03904   /* OTG VBUS Control Interrupts */
+#define                USB_OTG_VBUS_MASK  0xffc03908   /* VBUS Control Interrupt Enable */
+
+/* USB Phy Control Registers */
+
+#define                     USB_LINKINFO  0xffc03948   /* Enables programming of some PHY-side delays */
+#define                        USB_VPLEN  0xffc0394c   /* Determines duration of VBUS pulse for VBUS charging */
+#define                      USB_HS_EOF1  0xffc03950   /* Time buffer for High-Speed transactions */
+#define                      USB_FS_EOF1  0xffc03954   /* Time buffer for Full-Speed transactions */
+#define                      USB_LS_EOF1  0xffc03958   /* Time buffer for Low-Speed transactions */
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define                   USB_APHY_CNTRL  0xffc039e0   /* Register that increases visibility of Analog PHY */
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define                   USB_APHY_CALIB  0xffc039e4   /* Register used to set some calibration values */
+
+#define                  USB_APHY_CNTRL2  0xffc039e8   /* Register used to prevent re-enumeration once Moab goes into hibernate mode */
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define                     USB_PHY_TEST  0xffc039ec   /* Used for reducing simulation time and simplifies FIFO testability */
+
+#define                  USB_PLLOSC_CTRL  0xffc039f0   /* Used to program different parameters for USB PLL and Oscillator */
+#define                   USB_SRP_CLKDIV  0xffc039f4   /* Used to program clock divide value for the clock fed to the SRP detection logic */
+
+/* USB Endpoint 0 Control Registers */
+
+#define                USB_EP_NI0_TXMAXP  0xffc03a00   /* Maximum packet size for Host Tx endpoint0 */
+#define                 USB_EP_NI0_TXCSR  0xffc03a04   /* Control Status register for endpoint 0 */
+#define                USB_EP_NI0_RXMAXP  0xffc03a08   /* Maximum packet size for Host Rx endpoint0 */
+#define                 USB_EP_NI0_RXCSR  0xffc03a0c   /* Control Status register for Host Rx endpoint0 */
+#define               USB_EP_NI0_RXCOUNT  0xffc03a10   /* Number of bytes received in endpoint 0 FIFO */
+#define                USB_EP_NI0_TXTYPE  0xffc03a14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint0 */
+#define            USB_EP_NI0_TXINTERVAL  0xffc03a18   /* Sets the NAK response timeout on Endpoint 0 */
+#define                USB_EP_NI0_RXTYPE  0xffc03a1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint0 */
+#define            USB_EP_NI0_RXINTERVAL  0xffc03a20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint0 */
+#define               USB_EP_NI0_TXCOUNT  0xffc03a28   /* Number of bytes to be written to the endpoint0 Tx FIFO */
+
+/* USB Endpoint 1 Control Registers */
+
+#define                USB_EP_NI1_TXMAXP  0xffc03a40   /* Maximum packet size for Host Tx endpoint1 */
+#define                 USB_EP_NI1_TXCSR  0xffc03a44   /* Control Status register for endpoint1 */
+#define                USB_EP_NI1_RXMAXP  0xffc03a48   /* Maximum packet size for Host Rx endpoint1 */
+#define                 USB_EP_NI1_RXCSR  0xffc03a4c   /* Control Status register for Host Rx endpoint1 */
+#define               USB_EP_NI1_RXCOUNT  0xffc03a50   /* Number of bytes received in endpoint1 FIFO */
+#define                USB_EP_NI1_TXTYPE  0xffc03a54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint1 */
+#define            USB_EP_NI1_TXINTERVAL  0xffc03a58   /* Sets the NAK response timeout on Endpoint1 */
+#define                USB_EP_NI1_RXTYPE  0xffc03a5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint1 */
+#define            USB_EP_NI1_RXINTERVAL  0xffc03a60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint1 */
+#define               USB_EP_NI1_TXCOUNT  0xffc03a68   /* Number of bytes to be written to the+H102 endpoint1 Tx FIFO */
+
+/* USB Endpoint 2 Control Registers */
+
+#define                USB_EP_NI2_TXMAXP  0xffc03a80   /* Maximum packet size for Host Tx endpoint2 */
+#define                 USB_EP_NI2_TXCSR  0xffc03a84   /* Control Status register for endpoint2 */
+#define                USB_EP_NI2_RXMAXP  0xffc03a88   /* Maximum packet size for Host Rx endpoint2 */
+#define                 USB_EP_NI2_RXCSR  0xffc03a8c   /* Control Status register for Host Rx endpoint2 */
+#define               USB_EP_NI2_RXCOUNT  0xffc03a90   /* Number of bytes received in endpoint2 FIFO */
+#define                USB_EP_NI2_TXTYPE  0xffc03a94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint2 */
+#define            USB_EP_NI2_TXINTERVAL  0xffc03a98   /* Sets the NAK response timeout on Endpoint2 */
+#define                USB_EP_NI2_RXTYPE  0xffc03a9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint2 */
+#define            USB_EP_NI2_RXINTERVAL  0xffc03aa0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint2 */
+#define               USB_EP_NI2_TXCOUNT  0xffc03aa8   /* Number of bytes to be written to the endpoint2 Tx FIFO */
+
+/* USB Endpoint 3 Control Registers */
+
+#define                USB_EP_NI3_TXMAXP  0xffc03ac0   /* Maximum packet size for Host Tx endpoint3 */
+#define                 USB_EP_NI3_TXCSR  0xffc03ac4   /* Control Status register for endpoint3 */
+#define                USB_EP_NI3_RXMAXP  0xffc03ac8   /* Maximum packet size for Host Rx endpoint3 */
+#define                 USB_EP_NI3_RXCSR  0xffc03acc   /* Control Status register for Host Rx endpoint3 */
+#define               USB_EP_NI3_RXCOUNT  0xffc03ad0   /* Number of bytes received in endpoint3 FIFO */
+#define                USB_EP_NI3_TXTYPE  0xffc03ad4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint3 */
+#define            USB_EP_NI3_TXINTERVAL  0xffc03ad8   /* Sets the NAK response timeout on Endpoint3 */
+#define                USB_EP_NI3_RXTYPE  0xffc03adc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint3 */
+#define            USB_EP_NI3_RXINTERVAL  0xffc03ae0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint3 */
+#define               USB_EP_NI3_TXCOUNT  0xffc03ae8   /* Number of bytes to be written to the H124endpoint3 Tx FIFO */
+
+/* USB Endpoint 4 Control Registers */
+
+#define                USB_EP_NI4_TXMAXP  0xffc03b00   /* Maximum packet size for Host Tx endpoint4 */
+#define                 USB_EP_NI4_TXCSR  0xffc03b04   /* Control Status register for endpoint4 */
+#define                USB_EP_NI4_RXMAXP  0xffc03b08   /* Maximum packet size for Host Rx endpoint4 */
+#define                 USB_EP_NI4_RXCSR  0xffc03b0c   /* Control Status register for Host Rx endpoint4 */
+#define               USB_EP_NI4_RXCOUNT  0xffc03b10   /* Number of bytes received in endpoint4 FIFO */
+#define                USB_EP_NI4_TXTYPE  0xffc03b14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint4 */
+#define            USB_EP_NI4_TXINTERVAL  0xffc03b18   /* Sets the NAK response timeout on Endpoint4 */
+#define                USB_EP_NI4_RXTYPE  0xffc03b1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint4 */
+#define            USB_EP_NI4_RXINTERVAL  0xffc03b20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint4 */
+#define               USB_EP_NI4_TXCOUNT  0xffc03b28   /* Number of bytes to be written to the endpoint4 Tx FIFO */
+
+/* USB Endpoint 5 Control Registers */
+
+#define                USB_EP_NI5_TXMAXP  0xffc03b40   /* Maximum packet size for Host Tx endpoint5 */
+#define                 USB_EP_NI5_TXCSR  0xffc03b44   /* Control Status register for endpoint5 */
+#define                USB_EP_NI5_RXMAXP  0xffc03b48   /* Maximum packet size for Host Rx endpoint5 */
+#define                 USB_EP_NI5_RXCSR  0xffc03b4c   /* Control Status register for Host Rx endpoint5 */
+#define               USB_EP_NI5_RXCOUNT  0xffc03b50   /* Number of bytes received in endpoint5 FIFO */
+#define                USB_EP_NI5_TXTYPE  0xffc03b54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint5 */
+#define            USB_EP_NI5_TXINTERVAL  0xffc03b58   /* Sets the NAK response timeout on Endpoint5 */
+#define                USB_EP_NI5_RXTYPE  0xffc03b5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint5 */
+#define            USB_EP_NI5_RXINTERVAL  0xffc03b60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint5 */
+#define               USB_EP_NI5_TXCOUNT  0xffc03b68   /* Number of bytes to be written to the endpoint5 Tx FIFO */
+
+/* USB Endpoint 6 Control Registers */
+
+#define                USB_EP_NI6_TXMAXP  0xffc03b80   /* Maximum packet size for Host Tx endpoint6 */
+#define                 USB_EP_NI6_TXCSR  0xffc03b84   /* Control Status register for endpoint6 */
+#define                USB_EP_NI6_RXMAXP  0xffc03b88   /* Maximum packet size for Host Rx endpoint6 */
+#define                 USB_EP_NI6_RXCSR  0xffc03b8c   /* Control Status register for Host Rx endpoint6 */
+#define               USB_EP_NI6_RXCOUNT  0xffc03b90   /* Number of bytes received in endpoint6 FIFO */
+#define                USB_EP_NI6_TXTYPE  0xffc03b94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint6 */
+#define            USB_EP_NI6_TXINTERVAL  0xffc03b98   /* Sets the NAK response timeout on Endpoint6 */
+#define                USB_EP_NI6_RXTYPE  0xffc03b9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint6 */
+#define            USB_EP_NI6_RXINTERVAL  0xffc03ba0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint6 */
+#define               USB_EP_NI6_TXCOUNT  0xffc03ba8   /* Number of bytes to be written to the endpoint6 Tx FIFO */
+
+/* USB Endpoint 7 Control Registers */
+
+#define                USB_EP_NI7_TXMAXP  0xffc03bc0   /* Maximum packet size for Host Tx endpoint7 */
+#define                 USB_EP_NI7_TXCSR  0xffc03bc4   /* Control Status register for endpoint7 */
+#define                USB_EP_NI7_RXMAXP  0xffc03bc8   /* Maximum packet size for Host Rx endpoint7 */
+#define                 USB_EP_NI7_RXCSR  0xffc03bcc   /* Control Status register for Host Rx endpoint7 */
+#define               USB_EP_NI7_RXCOUNT  0xffc03bd0   /* Number of bytes received in endpoint7 FIFO */
+#define                USB_EP_NI7_TXTYPE  0xffc03bd4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint7 */
+#define            USB_EP_NI7_TXINTERVAL  0xffc03bd8   /* Sets the NAK response timeout on Endpoint7 */
+#define                USB_EP_NI7_RXTYPE  0xffc03bdc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint7 */
+#define            USB_EP_NI7_RXINTERVAL  0xffc03bf0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint7 */
+#define               USB_EP_NI7_TXCOUNT  0xffc03bf8   /* Number of bytes to be written to the endpoint7 Tx FIFO */
+
+#define                USB_DMA_INTERRUPT  0xffc03c00   /* Indicates pending interrupts for the DMA channels */
+
+/* USB Channel 0 Config Registers */
+
+#define                  USB_DMA0CONTROL  0xffc03c04   /* DMA master channel 0 configuration */
+#define                  USB_DMA0ADDRLOW  0xffc03c08   /* Lower 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0ADDRHIGH  0xffc03c0c   /* Upper 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0COUNTLOW  0xffc03c10   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 0 */
+#define                USB_DMA0COUNTHIGH  0xffc03c14   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 0 */
+
+/* USB Channel 1 Config Registers */
+
+#define                  USB_DMA1CONTROL  0xffc03c24   /* DMA master channel 1 configuration */
+#define                  USB_DMA1ADDRLOW  0xffc03c28   /* Lower 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1ADDRHIGH  0xffc03c2c   /* Upper 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1COUNTLOW  0xffc03c30   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 1 */
+#define                USB_DMA1COUNTHIGH  0xffc03c34   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 1 */
+
+/* USB Channel 2 Config Registers */
+
+#define                  USB_DMA2CONTROL  0xffc03c44   /* DMA master channel 2 configuration */
+#define                  USB_DMA2ADDRLOW  0xffc03c48   /* Lower 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2ADDRHIGH  0xffc03c4c   /* Upper 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2COUNTLOW  0xffc03c50   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 2 */
+#define                USB_DMA2COUNTHIGH  0xffc03c54   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 2 */
+
+/* USB Channel 3 Config Registers */
+
+#define                  USB_DMA3CONTROL  0xffc03c64   /* DMA master channel 3 configuration */
+#define                  USB_DMA3ADDRLOW  0xffc03c68   /* Lower 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3ADDRHIGH  0xffc03c6c   /* Upper 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3COUNTLOW  0xffc03c70   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 3 */
+#define                USB_DMA3COUNTHIGH  0xffc03c74   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 3 */
+
+/* USB Channel 4 Config Registers */
+
+#define                  USB_DMA4CONTROL  0xffc03c84   /* DMA master channel 4 configuration */
+#define                  USB_DMA4ADDRLOW  0xffc03c88   /* Lower 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4ADDRHIGH  0xffc03c8c   /* Upper 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4COUNTLOW  0xffc03c90   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 4 */
+#define                USB_DMA4COUNTHIGH  0xffc03c94   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 4 */
+
+/* USB Channel 5 Config Registers */
+
+#define                  USB_DMA5CONTROL  0xffc03ca4   /* DMA master channel 5 configuration */
+#define                  USB_DMA5ADDRLOW  0xffc03ca8   /* Lower 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5ADDRHIGH  0xffc03cac   /* Upper 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5COUNTLOW  0xffc03cb0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 5 */
+#define                USB_DMA5COUNTHIGH  0xffc03cb4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 5 */
+
+/* USB Channel 6 Config Registers */
+
+#define                  USB_DMA6CONTROL  0xffc03cc4   /* DMA master channel 6 configuration */
+#define                  USB_DMA6ADDRLOW  0xffc03cc8   /* Lower 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6ADDRHIGH  0xffc03ccc   /* Upper 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6COUNTLOW  0xffc03cd0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 6 */
+#define                USB_DMA6COUNTHIGH  0xffc03cd4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 6 */
+
+/* USB Channel 7 Config Registers */
+
+#define                  USB_DMA7CONTROL  0xffc03ce4   /* DMA master channel 7 configuration */
+#define                  USB_DMA7ADDRLOW  0xffc03ce8   /* Lower 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7ADDRHIGH  0xffc03cec   /* Upper 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7COUNTLOW  0xffc03cf0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 7 */
+#define                USB_DMA7COUNTHIGH  0xffc03cf4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 7 */
+
+/* Bit masks for USB_FADDR */
+
+#define          FUNCTION_ADDRESS  0x7f       /* Function address */
+
+/* Bit masks for USB_POWER */
+
+#define           ENABLE_SUSPENDM  0x1        /* enable SuspendM output */
+#define          nENABLE_SUSPENDM  0x0       
+#define              SUSPEND_MODE  0x2        /* Suspend Mode indicator */
+#define             nSUSPEND_MODE  0x0       
+#define               RESUME_MODE  0x4        /* DMA Mode */
+#define              nRESUME_MODE  0x0       
+#define                     RESET  0x8        /* Reset indicator */
+#define                    nRESET  0x0       
+#define                   HS_MODE  0x10       /* High Speed mode indicator */
+#define                  nHS_MODE  0x0       
+#define                 HS_ENABLE  0x20       /* high Speed Enable */
+#define                nHS_ENABLE  0x0       
+#define                 SOFT_CONN  0x40       /* Soft connect */
+#define                nSOFT_CONN  0x0       
+#define                ISO_UPDATE  0x80       /* Isochronous update */
+#define               nISO_UPDATE  0x0       
+
+/* Bit masks for USB_INTRTX */
+
+#define                    EP0_TX  0x1        /* Tx Endpoint 0 interrupt */
+#define                   nEP0_TX  0x0       
+#define                    EP1_TX  0x2        /* Tx Endpoint 1 interrupt */
+#define                   nEP1_TX  0x0       
+#define                    EP2_TX  0x4        /* Tx Endpoint 2 interrupt */
+#define                   nEP2_TX  0x0       
+#define                    EP3_TX  0x8        /* Tx Endpoint 3 interrupt */
+#define                   nEP3_TX  0x0       
+#define                    EP4_TX  0x10       /* Tx Endpoint 4 interrupt */
+#define                   nEP4_TX  0x0       
+#define                    EP5_TX  0x20       /* Tx Endpoint 5 interrupt */
+#define                   nEP5_TX  0x0       
+#define                    EP6_TX  0x40       /* Tx Endpoint 6 interrupt */
+#define                   nEP6_TX  0x0       
+#define                    EP7_TX  0x80       /* Tx Endpoint 7 interrupt */
+#define                   nEP7_TX  0x0       
+
+/* Bit masks for USB_INTRRX */
+
+#define                    EP1_RX  0x2        /* Rx Endpoint 1 interrupt */
+#define                   nEP1_RX  0x0       
+#define                    EP2_RX  0x4        /* Rx Endpoint 2 interrupt */
+#define                   nEP2_RX  0x0       
+#define                    EP3_RX  0x8        /* Rx Endpoint 3 interrupt */
+#define                   nEP3_RX  0x0       
+#define                    EP4_RX  0x10       /* Rx Endpoint 4 interrupt */
+#define                   nEP4_RX  0x0       
+#define                    EP5_RX  0x20       /* Rx Endpoint 5 interrupt */
+#define                   nEP5_RX  0x0       
+#define                    EP6_RX  0x40       /* Rx Endpoint 6 interrupt */
+#define                   nEP6_RX  0x0       
+#define                    EP7_RX  0x80       /* Rx Endpoint 7 interrupt */
+#define                   nEP7_RX  0x0       
+
+/* Bit masks for USB_INTRTXE */
+
+#define                  EP0_TX_E  0x1        /* Endpoint 0 interrupt Enable */
+#define                 nEP0_TX_E  0x0       
+#define                  EP1_TX_E  0x2        /* Tx Endpoint 1 interrupt  Enable */
+#define                 nEP1_TX_E  0x0       
+#define                  EP2_TX_E  0x4        /* Tx Endpoint 2 interrupt  Enable */
+#define                 nEP2_TX_E  0x0       
+#define                  EP3_TX_E  0x8        /* Tx Endpoint 3 interrupt  Enable */
+#define                 nEP3_TX_E  0x0       
+#define                  EP4_TX_E  0x10       /* Tx Endpoint 4 interrupt  Enable */
+#define                 nEP4_TX_E  0x0       
+#define                  EP5_TX_E  0x20       /* Tx Endpoint 5 interrupt  Enable */
+#define                 nEP5_TX_E  0x0       
+#define                  EP6_TX_E  0x40       /* Tx Endpoint 6 interrupt  Enable */
+#define                 nEP6_TX_E  0x0       
+#define                  EP7_TX_E  0x80       /* Tx Endpoint 7 interrupt  Enable */
+#define                 nEP7_TX_E  0x0       
+
+/* Bit masks for USB_INTRRXE */
+
+#define                  EP1_RX_E  0x2        /* Rx Endpoint 1 interrupt  Enable */
+#define                 nEP1_RX_E  0x0       
+#define                  EP2_RX_E  0x4        /* Rx Endpoint 2 interrupt  Enable */
+#define                 nEP2_RX_E  0x0       
+#define                  EP3_RX_E  0x8        /* Rx Endpoint 3 interrupt  Enable */
+#define                 nEP3_RX_E  0x0       
+#define                  EP4_RX_E  0x10       /* Rx Endpoint 4 interrupt  Enable */
+#define                 nEP4_RX_E  0x0       
+#define                  EP5_RX_E  0x20       /* Rx Endpoint 5 interrupt  Enable */
+#define                 nEP5_RX_E  0x0       
+#define                  EP6_RX_E  0x40       /* Rx Endpoint 6 interrupt  Enable */
+#define                 nEP6_RX_E  0x0       
+#define                  EP7_RX_E  0x80       /* Rx Endpoint 7 interrupt  Enable */
+#define                 nEP7_RX_E  0x0       
+
+/* Bit masks for USB_INTRUSB */
+
+#define                 SUSPEND_B  0x1        /* Suspend indicator */
+#define                nSUSPEND_B  0x0       
+#define                  RESUME_B  0x2        /* Resume indicator */
+#define                 nRESUME_B  0x0       
+#define          RESET_OR_BABLE_B  0x4        /* Reset/babble indicator */
+#define         nRESET_OR_BABLE_B  0x0       
+#define                     SOF_B  0x8        /* Start of frame */
+#define                    nSOF_B  0x0       
+#define                    CONN_B  0x10       /* Connection indicator */
+#define                   nCONN_B  0x0       
+#define                  DISCON_B  0x20       /* Disconnect indicator */
+#define                 nDISCON_B  0x0       
+#define             SESSION_REQ_B  0x40       /* Session Request */
+#define            nSESSION_REQ_B  0x0       
+#define              VBUS_ERROR_B  0x80       /* Vbus threshold indicator */
+#define             nVBUS_ERROR_B  0x0       
+
+/* Bit masks for USB_INTRUSBE */
+
+#define                SUSPEND_BE  0x1        /* Suspend indicator int enable */
+#define               nSUSPEND_BE  0x0       
+#define                 RESUME_BE  0x2        /* Resume indicator int enable */
+#define                nRESUME_BE  0x0       
+#define         RESET_OR_BABLE_BE  0x4        /* Reset/babble indicator int enable */
+#define        nRESET_OR_BABLE_BE  0x0       
+#define                    SOF_BE  0x8        /* Start of frame int enable */
+#define                   nSOF_BE  0x0       
+#define                   CONN_BE  0x10       /* Connection indicator int enable */
+#define                  nCONN_BE  0x0       
+#define                 DISCON_BE  0x20       /* Disconnect indicator int enable */
+#define                nDISCON_BE  0x0       
+#define            SESSION_REQ_BE  0x40       /* Session Request int enable */
+#define           nSESSION_REQ_BE  0x0       
+#define             VBUS_ERROR_BE  0x80       /* Vbus threshold indicator int enable */
+#define            nVBUS_ERROR_BE  0x0       
+
+/* Bit masks for USB_FRAME */
+
+#define              FRAME_NUMBER  0x7ff      /* Frame number */
+
+/* Bit masks for USB_INDEX */
+
+#define         SELECTED_ENDPOINT  0xf        /* selected endpoint */
+
+/* Bit masks for USB_GLOBAL_CTL */
+
+#define                GLOBAL_ENA  0x1        /* enables USB module */
+#define               nGLOBAL_ENA  0x0       
+#define                EP1_TX_ENA  0x2        /* Transmit endpoint 1 enable */
+#define               nEP1_TX_ENA  0x0       
+#define                EP2_TX_ENA  0x4        /* Transmit endpoint 2 enable */
+#define               nEP2_TX_ENA  0x0       
+#define                EP3_TX_ENA  0x8        /* Transmit endpoint 3 enable */
+#define               nEP3_TX_ENA  0x0       
+#define                EP4_TX_ENA  0x10       /* Transmit endpoint 4 enable */
+#define               nEP4_TX_ENA  0x0       
+#define                EP5_TX_ENA  0x20       /* Transmit endpoint 5 enable */
+#define               nEP5_TX_ENA  0x0       
+#define                EP6_TX_ENA  0x40       /* Transmit endpoint 6 enable */
+#define               nEP6_TX_ENA  0x0       
+#define                EP7_TX_ENA  0x80       /* Transmit endpoint 7 enable */
+#define               nEP7_TX_ENA  0x0       
+#define                EP1_RX_ENA  0x100      /* Receive endpoint 1 enable */
+#define               nEP1_RX_ENA  0x0       
+#define                EP2_RX_ENA  0x200      /* Receive endpoint 2 enable */
+#define               nEP2_RX_ENA  0x0       
+#define                EP3_RX_ENA  0x400      /* Receive endpoint 3 enable */
+#define               nEP3_RX_ENA  0x0       
+#define                EP4_RX_ENA  0x800      /* Receive endpoint 4 enable */
+#define               nEP4_RX_ENA  0x0       
+#define                EP5_RX_ENA  0x1000     /* Receive endpoint 5 enable */
+#define               nEP5_RX_ENA  0x0       
+#define                EP6_RX_ENA  0x2000     /* Receive endpoint 6 enable */
+#define               nEP6_RX_ENA  0x0       
+#define                EP7_RX_ENA  0x4000     /* Receive endpoint 7 enable */
+#define               nEP7_RX_ENA  0x0       
+
+/* Bit masks for USB_OTG_DEV_CTL */
+
+#define                   SESSION  0x1        /* session indicator */
+#define                  nSESSION  0x0       
+#define                  HOST_REQ  0x2        /* Host negotiation request */
+#define                 nHOST_REQ  0x0       
+#define                 HOST_MODE  0x4        /* indicates USBDRC is a host */
+#define                nHOST_MODE  0x0       
+#define                     VBUS0  0x8        /* Vbus level indicator[0] */
+#define                    nVBUS0  0x0       
+#define                     VBUS1  0x10       /* Vbus level indicator[1] */
+#define                    nVBUS1  0x0       
+#define                     LSDEV  0x20       /* Low-speed indicator */
+#define                    nLSDEV  0x0       
+#define                     FSDEV  0x40       /* Full or High-speed indicator */
+#define                    nFSDEV  0x0       
+#define                  B_DEVICE  0x80       /* A' or 'B' device indicator */
+#define                 nB_DEVICE  0x0       
+
+/* Bit masks for USB_OTG_VBUS_IRQ */
+
+#define             DRIVE_VBUS_ON  0x1        /* indicator to drive VBUS control circuit */
+#define            nDRIVE_VBUS_ON  0x0       
+#define            DRIVE_VBUS_OFF  0x2        /* indicator to shut off charge pump */
+#define           nDRIVE_VBUS_OFF  0x0       
+#define           CHRG_VBUS_START  0x4        /* indicator for external circuit to start charging VBUS */
+#define          nCHRG_VBUS_START  0x0       
+#define             CHRG_VBUS_END  0x8        /* indicator for external circuit to end charging VBUS */
+#define            nCHRG_VBUS_END  0x0       
+#define        DISCHRG_VBUS_START  0x10       /* indicator to start discharging VBUS */
+#define       nDISCHRG_VBUS_START  0x0       
+#define          DISCHRG_VBUS_END  0x20       /* indicator to stop discharging VBUS */
+#define         nDISCHRG_VBUS_END  0x0       
+
+/* Bit masks for USB_OTG_VBUS_MASK */
+
+#define         DRIVE_VBUS_ON_ENA  0x1        /* enable DRIVE_VBUS_ON interrupt */
+#define        nDRIVE_VBUS_ON_ENA  0x0       
+#define        DRIVE_VBUS_OFF_ENA  0x2        /* enable DRIVE_VBUS_OFF interrupt */
+#define       nDRIVE_VBUS_OFF_ENA  0x0       
+#define       CHRG_VBUS_START_ENA  0x4        /* enable CHRG_VBUS_START interrupt */
+#define      nCHRG_VBUS_START_ENA  0x0       
+#define         CHRG_VBUS_END_ENA  0x8        /* enable CHRG_VBUS_END interrupt */
+#define        nCHRG_VBUS_END_ENA  0x0       
+#define    DISCHRG_VBUS_START_ENA  0x10       /* enable DISCHRG_VBUS_START interrupt */
+#define   nDISCHRG_VBUS_START_ENA  0x0       
+#define      DISCHRG_VBUS_END_ENA  0x20       /* enable DISCHRG_VBUS_END interrupt */
+#define     nDISCHRG_VBUS_END_ENA  0x0       
+
+/* Bit masks for USB_CSR0 */
+
+#define                  RXPKTRDY  0x1        /* data packet receive indicator */
+#define                 nRXPKTRDY  0x0       
+#define                  TXPKTRDY  0x2        /* data packet in FIFO indicator */
+#define                 nTXPKTRDY  0x0       
+#define                STALL_SENT  0x4        /* STALL handshake sent */
+#define               nSTALL_SENT  0x0       
+#define                   DATAEND  0x8        /* Data end indicator */
+#define                  nDATAEND  0x0       
+#define                  SETUPEND  0x10       /* Setup end */
+#define                 nSETUPEND  0x0       
+#define                 SENDSTALL  0x20       /* Send STALL handshake */
+#define                nSENDSTALL  0x0       
+#define         SERVICED_RXPKTRDY  0x40       /* used to clear the RxPktRdy bit */
+#define        nSERVICED_RXPKTRDY  0x0       
+#define         SERVICED_SETUPEND  0x80       /* used to clear the SetupEnd bit */
+#define        nSERVICED_SETUPEND  0x0       
+#define                 FLUSHFIFO  0x100      /* flush endpoint FIFO */
+#define                nFLUSHFIFO  0x0       
+#define          STALL_RECEIVED_H  0x4        /* STALL handshake received host mode */
+#define         nSTALL_RECEIVED_H  0x0       
+#define                SETUPPKT_H  0x8        /* send Setup token host mode */
+#define               nSETUPPKT_H  0x0       
+#define                   ERROR_H  0x10       /* timeout error indicator host mode */
+#define                  nERROR_H  0x0       
+#define                  REQPKT_H  0x20       /* Request an IN transaction host mode */
+#define                 nREQPKT_H  0x0       
+#define               STATUSPKT_H  0x40       /* Status stage transaction host mode */
+#define              nSTATUSPKT_H  0x0       
+#define             NAK_TIMEOUT_H  0x80       /* EP0 halted after a NAK host mode */
+#define            nNAK_TIMEOUT_H  0x0       
+
+/* Bit masks for USB_COUNT0 */
+
+#define              EP0_RX_COUNT  0x7f       /* number of received bytes in EP0 FIFO */
+
+/* Bit masks for USB_NAKLIMIT0 */
+
+#define             EP0_NAK_LIMIT  0x1f       /* number of frames/micro frames after which EP0 timeouts */
+
+/* Bit masks for USB_TX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_T  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_RX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_R  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_TXCSR */
+
+#define                TXPKTRDY_T  0x1        /* data packet in FIFO indicator */
+#define               nTXPKTRDY_T  0x0       
+#define          FIFO_NOT_EMPTY_T  0x2        /* FIFO not empty */
+#define         nFIFO_NOT_EMPTY_T  0x0       
+#define                UNDERRUN_T  0x4        /* TxPktRdy not set  for an IN token */
+#define               nUNDERRUN_T  0x0       
+#define               FLUSHFIFO_T  0x8        /* flush endpoint FIFO */
+#define              nFLUSHFIFO_T  0x0       
+#define              STALL_SEND_T  0x10       /* issue a Stall handshake */
+#define             nSTALL_SEND_T  0x0       
+#define              STALL_SENT_T  0x20       /* Stall handshake transmitted */
+#define             nSTALL_SENT_T  0x0       
+#define        CLEAR_DATATOGGLE_T  0x40       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_T  0x0       
+#define                INCOMPTX_T  0x80       /* indicates that a large packet is split */
+#define               nINCOMPTX_T  0x0       
+#define              DMAREQMODE_T  0x400      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_T  0x0       
+#define        FORCE_DATATOGGLE_T  0x800      /* Force data toggle */
+#define       nFORCE_DATATOGGLE_T  0x0       
+#define              DMAREQ_ENA_T  0x1000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_T  0x0       
+#define                     ISO_T  0x4000     /* enable Isochronous transfers */
+#define                    nISO_T  0x0       
+#define                 AUTOSET_T  0x8000     /* allows TxPktRdy to be set automatically */
+#define                nAUTOSET_T  0x0       
+#define                  ERROR_TH  0x4        /* error condition host mode */
+#define                 nERROR_TH  0x0       
+#define         STALL_RECEIVED_TH  0x20       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_TH  0x0       
+#define            NAK_TIMEOUT_TH  0x80       /* NAK timeout host mode */
+#define           nNAK_TIMEOUT_TH  0x0       
+
+/* Bit masks for USB_TXCOUNT */
+
+#define                  TX_COUNT  0x1fff     /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* Bit masks for USB_RXCSR */
+
+#define                RXPKTRDY_R  0x1        /* data packet in FIFO indicator */
+#define               nRXPKTRDY_R  0x0       
+#define               FIFO_FULL_R  0x2        /* FIFO not empty */
+#define              nFIFO_FULL_R  0x0       
+#define                 OVERRUN_R  0x4        /* TxPktRdy not set  for an IN token */
+#define                nOVERRUN_R  0x0       
+#define               DATAERROR_R  0x8        /* Out packet cannot be loaded into Rx  FIFO */
+#define              nDATAERROR_R  0x0       
+#define               FLUSHFIFO_R  0x10       /* flush endpoint FIFO */
+#define              nFLUSHFIFO_R  0x0       
+#define              STALL_SEND_R  0x20       /* issue a Stall handshake */
+#define             nSTALL_SEND_R  0x0       
+#define              STALL_SENT_R  0x40       /* Stall handshake transmitted */
+#define             nSTALL_SENT_R  0x0       
+#define        CLEAR_DATATOGGLE_R  0x80       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_R  0x0       
+#define                INCOMPRX_R  0x100      /* indicates that a large packet is split */
+#define               nINCOMPRX_R  0x0       
+#define              DMAREQMODE_R  0x800      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_R  0x0       
+#define                 DISNYET_R  0x1000     /* disable Nyet handshakes */
+#define                nDISNYET_R  0x0       
+#define              DMAREQ_ENA_R  0x2000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_R  0x0       
+#define                     ISO_R  0x4000     /* enable Isochronous transfers */
+#define                    nISO_R  0x0       
+#define               AUTOCLEAR_R  0x8000     /* allows TxPktRdy to be set automatically */
+#define              nAUTOCLEAR_R  0x0       
+#define                  ERROR_RH  0x4        /* TxPktRdy not set  for an IN token host mode */
+#define                 nERROR_RH  0x0       
+#define                 REQPKT_RH  0x20       /* request an IN transaction host mode */
+#define                nREQPKT_RH  0x0       
+#define         STALL_RECEIVED_RH  0x40       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_RH  0x0       
+#define               INCOMPRX_RH  0x100      /* indicates that a large packet is split host mode */
+#define              nINCOMPRX_RH  0x0       
+#define             DMAREQMODE_RH  0x800      /* DMA mode (0 or 1) selection host mode */
+#define            nDMAREQMODE_RH  0x0       
+#define                AUTOREQ_RH  0x4000     /* sets ReqPkt automatically host mode */
+#define               nAUTOREQ_RH  0x0       
+
+/* Bit masks for USB_RXCOUNT */
+
+#define                  RX_COUNT  0x1fff     /* Number of received bytes in the packet in the Rx FIFO */
+
+/* Bit masks for USB_TXTYPE */
+
+#define            TARGET_EP_NO_T  0xf        /* EP number */
+#define                PROTOCOL_T  0xc        /* transfer type */
+
+/* Bit masks for USB_TXINTERVAL */
+
+#define          TX_POLL_INTERVAL  0xff       /* polling interval for selected Tx EP */
+
+/* Bit masks for USB_RXTYPE */
+
+#define            TARGET_EP_NO_R  0xf        /* EP number */
+#define                PROTOCOL_R  0xc        /* transfer type */
+
+/* Bit masks for USB_RXINTERVAL */
+
+#define          RX_POLL_INTERVAL  0xff       /* polling interval for selected Rx EP */
+
+/* Bit masks for USB_DMA_INTERRUPT */
+
+#define                  DMA0_INT  0x1        /* DMA0 pending interrupt */
+#define                 nDMA0_INT  0x0       
+#define                  DMA1_INT  0x2        /* DMA1 pending interrupt */
+#define                 nDMA1_INT  0x0       
+#define                  DMA2_INT  0x4        /* DMA2 pending interrupt */
+#define                 nDMA2_INT  0x0       
+#define                  DMA3_INT  0x8        /* DMA3 pending interrupt */
+#define                 nDMA3_INT  0x0       
+#define                  DMA4_INT  0x10       /* DMA4 pending interrupt */
+#define                 nDMA4_INT  0x0       
+#define                  DMA5_INT  0x20       /* DMA5 pending interrupt */
+#define                 nDMA5_INT  0x0       
+#define                  DMA6_INT  0x40       /* DMA6 pending interrupt */
+#define                 nDMA6_INT  0x0       
+#define                  DMA7_INT  0x80       /* DMA7 pending interrupt */
+#define                 nDMA7_INT  0x0       
+
+/* Bit masks for USB_DMAxCONTROL */
+
+#define                   DMA_ENA  0x1        /* DMA enable */
+#define                  nDMA_ENA  0x0       
+#define                 DIRECTION  0x2        /* direction of DMA transfer */
+#define                nDIRECTION  0x0       
+#define                      MODE  0x4        /* DMA Bus error */
+#define                     nMODE  0x0       
+#define                   INT_ENA  0x8        /* Interrupt enable */
+#define                  nINT_ENA  0x0       
+#define                     EPNUM  0xf0       /* EP number */
+#define                  BUSERROR  0x100      /* DMA Bus error */
+#define                 nBUSERROR  0x0       
+
+/* Bit masks for USB_DMAxADDRHIGH */
+
+#define             DMA_ADDR_HIGH  0xffff     /* Upper 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxADDRLOW */
+
+#define              DMA_ADDR_LOW  0xffff     /* Lower 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTHIGH */
+
+#define            DMA_COUNT_HIGH  0xffff     /* Upper 16-bits of byte count of DMA transfer for DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTLOW */
+
+#define             DMA_COUNT_LOW  0xffff     /* Lower 16-bits of byte count of DMA transfer for DMA master channel */
+
+#endif /* _DEF_BF525_H */
diff --git a/include/asm-blackfin/mach-bf527/defBF527.h b/include/asm-blackfin/mach-bf527/defBF527.h
new file mode 100644
index 0000000..2be3293
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/defBF527.h
@@ -0,0 +1,1089 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/defBF527.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF527_H
+#define _DEF_BF527_H
+
+/* Include all Core registers and bit definitions */
+#include <def_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF527 */
+
+/* Include defBF52x_base.h for the set of #defines that are common to all ADSP-BF52x processors */
+#include <defBF52x_base.h>
+
+/* The following are the #defines needed by ADSP-BF527 that are not in the common header */
+/* 10/100 Ethernet Controller	(0xFFC03000 - 0xFFC031FF) */
+
+#define EMAC_OPMODE             0xFFC03000       /* Operating Mode Register                              */
+#define EMAC_ADDRLO             0xFFC03004       /* Address Low (32 LSBs) Register                       */
+#define EMAC_ADDRHI             0xFFC03008       /* Address High (16 MSBs) Register                      */
+#define EMAC_HASHLO             0xFFC0300C       /* Multicast Hash Table Low (Bins 31-0) Register        */
+#define EMAC_HASHHI             0xFFC03010       /* Multicast Hash Table High (Bins 63-32) Register      */
+#define EMAC_STAADD             0xFFC03014       /* Station Management Address Register                  */
+#define EMAC_STADAT             0xFFC03018       /* Station Management Data Register                     */
+#define EMAC_FLC                0xFFC0301C       /* Flow Control Register                                */
+#define EMAC_VLAN1              0xFFC03020       /* VLAN1 Tag Register                                   */
+#define EMAC_VLAN2              0xFFC03024       /* VLAN2 Tag Register                                   */
+#define EMAC_WKUP_CTL           0xFFC0302C       /* Wake-Up Control/Status Register                      */
+#define EMAC_WKUP_FFMSK0        0xFFC03030       /* Wake-Up Frame Filter 0 Byte Mask Register            */
+#define EMAC_WKUP_FFMSK1        0xFFC03034       /* Wake-Up Frame Filter 1 Byte Mask Register            */
+#define EMAC_WKUP_FFMSK2        0xFFC03038       /* Wake-Up Frame Filter 2 Byte Mask Register            */
+#define EMAC_WKUP_FFMSK3        0xFFC0303C       /* Wake-Up Frame Filter 3 Byte Mask Register            */
+#define EMAC_WKUP_FFCMD         0xFFC03040       /* Wake-Up Frame Filter Commands Register               */
+#define EMAC_WKUP_FFOFF         0xFFC03044       /* Wake-Up Frame Filter Offsets Register                */
+#define EMAC_WKUP_FFCRC0        0xFFC03048       /* Wake-Up Frame Filter 0,1 CRC-16 Register             */
+#define EMAC_WKUP_FFCRC1        0xFFC0304C       /* Wake-Up Frame Filter 2,3 CRC-16 Register             */
+
+#define EMAC_SYSCTL             0xFFC03060       /* EMAC System Control Register                         */
+#define EMAC_SYSTAT             0xFFC03064       /* EMAC System Status Register                          */
+#define EMAC_RX_STAT            0xFFC03068       /* RX Current Frame Status Register                     */
+#define EMAC_RX_STKY            0xFFC0306C       /* RX Sticky Frame Status Register                      */
+#define EMAC_RX_IRQE            0xFFC03070       /* RX Frame Status Interrupt Enables Register           */
+#define EMAC_TX_STAT            0xFFC03074       /* TX Current Frame Status Register                     */
+#define EMAC_TX_STKY            0xFFC03078       /* TX Sticky Frame Status Register                      */
+#define EMAC_TX_IRQE            0xFFC0307C       /* TX Frame Status Interrupt Enables Register           */
+
+#define EMAC_MMC_CTL            0xFFC03080       /* MMC Counter Control Register                         */
+#define EMAC_MMC_RIRQS          0xFFC03084       /* MMC RX Interrupt Status Register                     */
+#define EMAC_MMC_RIRQE          0xFFC03088       /* MMC RX Interrupt Enables Register                    */
+#define EMAC_MMC_TIRQS          0xFFC0308C       /* MMC TX Interrupt Status Register                     */
+#define EMAC_MMC_TIRQE          0xFFC03090       /* MMC TX Interrupt Enables Register                    */
+
+#define EMAC_RXC_OK             0xFFC03100       /* RX Frame Successful Count                            */
+#define EMAC_RXC_FCS            0xFFC03104       /* RX Frame FCS Failure Count                           */
+#define EMAC_RXC_ALIGN          0xFFC03108       /* RX Alignment Error Count                             */
+#define EMAC_RXC_OCTET          0xFFC0310C       /* RX Octets Successfully Received Count                */
+#define EMAC_RXC_DMAOVF         0xFFC03110       /* Internal MAC Sublayer Error RX Frame Count           */
+#define EMAC_RXC_UNICST         0xFFC03114       /* Unicast RX Frame Count                               */
+#define EMAC_RXC_MULTI          0xFFC03118       /* Multicast RX Frame Count                             */
+#define EMAC_RXC_BROAD          0xFFC0311C       /* Broadcast RX Frame Count                             */
+#define EMAC_RXC_LNERRI         0xFFC03120       /* RX Frame In Range Error Count                        */
+#define EMAC_RXC_LNERRO         0xFFC03124       /* RX Frame Out Of Range Error Count                    */
+#define EMAC_RXC_LONG           0xFFC03128       /* RX Frame Too Long Count                              */
+#define EMAC_RXC_MACCTL         0xFFC0312C       /* MAC Control RX Frame Count                           */
+#define EMAC_RXC_OPCODE         0xFFC03130       /* Unsupported Op-Code RX Frame Count                   */
+#define EMAC_RXC_PAUSE          0xFFC03134       /* MAC Control Pause RX Frame Count                     */
+#define EMAC_RXC_ALLFRM         0xFFC03138       /* Overall RX Frame Count                               */
+#define EMAC_RXC_ALLOCT         0xFFC0313C       /* Overall RX Octet Count                               */
+#define EMAC_RXC_TYPED          0xFFC03140       /* Type/Length Consistent RX Frame Count                */
+#define EMAC_RXC_SHORT          0xFFC03144       /* RX Frame Fragment Count - Byte Count x < 64          */
+#define EMAC_RXC_EQ64           0xFFC03148       /* Good RX Frame Count - Byte Count x = 64              */
+#define EMAC_RXC_LT128          0xFFC0314C       /* Good RX Frame Count - Byte Count  64 < x < 128       */
+#define EMAC_RXC_LT256          0xFFC03150       /* Good RX Frame Count - Byte Count 128 <= x < 256      */
+#define EMAC_RXC_LT512          0xFFC03154       /* Good RX Frame Count - Byte Count 256 <= x < 512      */
+#define EMAC_RXC_LT1024         0xFFC03158       /* Good RX Frame Count - Byte Count 512 <= x < 1024     */
+#define EMAC_RXC_GE1024         0xFFC0315C       /* Good RX Frame Count - Byte Count x >= 1024           */
+
+#define EMAC_TXC_OK             0xFFC03180       /* TX Frame Successful Count                             */
+#define EMAC_TXC_1COL           0xFFC03184       /* TX Frames Successful After Single Collision Count     */
+#define EMAC_TXC_GT1COL         0xFFC03188       /* TX Frames Successful After Multiple Collisions Count  */
+#define EMAC_TXC_OCTET          0xFFC0318C       /* TX Octets Successfully Received Count                 */
+#define EMAC_TXC_DEFER          0xFFC03190       /* TX Frame Delayed Due To Busy Count                    */
+#define EMAC_TXC_LATECL         0xFFC03194       /* Late TX Collisions Count                              */
+#define EMAC_TXC_XS_COL         0xFFC03198       /* TX Frame Failed Due To Excessive Collisions Count     */
+#define EMAC_TXC_DMAUND         0xFFC0319C       /* Internal MAC Sublayer Error TX Frame Count            */
+#define EMAC_TXC_CRSERR         0xFFC031A0       /* Carrier Sense Deasserted During TX Frame Count        */
+#define EMAC_TXC_UNICST         0xFFC031A4       /* Unicast TX Frame Count                                */
+#define EMAC_TXC_MULTI          0xFFC031A8       /* Multicast TX Frame Count                              */
+#define EMAC_TXC_BROAD          0xFFC031AC       /* Broadcast TX Frame Count                              */
+#define EMAC_TXC_XS_DFR         0xFFC031B0       /* TX Frames With Excessive Deferral Count               */
+#define EMAC_TXC_MACCTL         0xFFC031B4       /* MAC Control TX Frame Count                            */
+#define EMAC_TXC_ALLFRM         0xFFC031B8       /* Overall TX Frame Count                                */
+#define EMAC_TXC_ALLOCT         0xFFC031BC       /* Overall TX Octet Count                                */
+#define EMAC_TXC_EQ64           0xFFC031C0       /* Good TX Frame Count - Byte Count x = 64               */
+#define EMAC_TXC_LT128          0xFFC031C4       /* Good TX Frame Count - Byte Count  64 < x < 128        */
+#define EMAC_TXC_LT256          0xFFC031C8       /* Good TX Frame Count - Byte Count 128 <= x < 256       */
+#define EMAC_TXC_LT512          0xFFC031CC       /* Good TX Frame Count - Byte Count 256 <= x < 512       */
+#define EMAC_TXC_LT1024         0xFFC031D0       /* Good TX Frame Count - Byte Count 512 <= x < 1024      */
+#define EMAC_TXC_GE1024         0xFFC031D4       /* Good TX Frame Count - Byte Count x >= 1024            */
+#define EMAC_TXC_ABORT          0xFFC031D8       /* Total TX Frames Aborted Count                         */
+
+/* Listing for IEEE-Supported Count Registers */
+
+#define FramesReceivedOK                EMAC_RXC_OK        /* RX Frame Successful Count                            */
+#define FrameCheckSequenceErrors        EMAC_RXC_FCS       /* RX Frame FCS Failure Count                           */
+#define AlignmentErrors                 EMAC_RXC_ALIGN     /* RX Alignment Error Count                             */
+#define OctetsReceivedOK                EMAC_RXC_OCTET     /* RX Octets Successfully Received Count                */
+#define FramesLostDueToIntMACRcvError   EMAC_RXC_DMAOVF    /* Internal MAC Sublayer Error RX Frame Count           */
+#define UnicastFramesReceivedOK         EMAC_RXC_UNICST    /* Unicast RX Frame Count                               */
+#define MulticastFramesReceivedOK       EMAC_RXC_MULTI     /* Multicast RX Frame Count                             */
+#define BroadcastFramesReceivedOK       EMAC_RXC_BROAD     /* Broadcast RX Frame Count                             */
+#define InRangeLengthErrors             EMAC_RXC_LNERRI    /* RX Frame In Range Error Count                        */
+#define OutOfRangeLengthField           EMAC_RXC_LNERRO    /* RX Frame Out Of Range Error Count                    */
+#define FrameTooLongErrors              EMAC_RXC_LONG      /* RX Frame Too Long Count                              */
+#define MACControlFramesReceived        EMAC_RXC_MACCTL    /* MAC Control RX Frame Count                           */
+#define UnsupportedOpcodesReceived      EMAC_RXC_OPCODE    /* Unsupported Op-Code RX Frame Count                   */
+#define PAUSEMACCtrlFramesReceived      EMAC_RXC_PAUSE     /* MAC Control Pause RX Frame Count                     */
+#define FramesReceivedAll               EMAC_RXC_ALLFRM    /* Overall RX Frame Count                               */
+#define OctetsReceivedAll               EMAC_RXC_ALLOCT    /* Overall RX Octet Count                               */
+#define TypedFramesReceived             EMAC_RXC_TYPED     /* Type/Length Consistent RX Frame Count                */
+#define FramesLenLt64Received           EMAC_RXC_SHORT     /* RX Frame Fragment Count - Byte Count x < 64          */
+#define FramesLenEq64Received           EMAC_RXC_EQ64      /* Good RX Frame Count - Byte Count x = 64              */
+#define FramesLen65_127Received         EMAC_RXC_LT128     /* Good RX Frame Count - Byte Count  64 < x < 128       */
+#define FramesLen128_255Received        EMAC_RXC_LT256     /* Good RX Frame Count - Byte Count 128 <= x < 256      */
+#define FramesLen256_511Received        EMAC_RXC_LT512     /* Good RX Frame Count - Byte Count 256 <= x < 512      */
+#define FramesLen512_1023Received       EMAC_RXC_LT1024    /* Good RX Frame Count - Byte Count 512 <= x < 1024     */
+#define FramesLen1024_MaxReceived       EMAC_RXC_GE1024    /* Good RX Frame Count - Byte Count x >= 1024           */
+
+#define FramesTransmittedOK             EMAC_TXC_OK        /* TX Frame Successful Count                            */
+#define SingleCollisionFrames           EMAC_TXC_1COL      /* TX Frames Successful After Single Collision Count    */
+#define MultipleCollisionFrames         EMAC_TXC_GT1COL    /* TX Frames Successful After Multiple Collisions Count */
+#define OctetsTransmittedOK             EMAC_TXC_OCTET     /* TX Octets Successfully Received Count                */
+#define FramesWithDeferredXmissions     EMAC_TXC_DEFER     /* TX Frame Delayed Due To Busy Count                   */
+#define LateCollisions                  EMAC_TXC_LATECL    /* Late TX Collisions Count                             */
+#define FramesAbortedDueToXSColls       EMAC_TXC_XS_COL    /* TX Frame Failed Due To Excessive Collisions Count    */
+#define FramesLostDueToIntMacXmitError  EMAC_TXC_DMAUND    /* Internal MAC Sublayer Error TX Frame Count           */
+#define CarrierSenseErrors              EMAC_TXC_CRSERR    /* Carrier Sense Deasserted During TX Frame Count       */
+#define UnicastFramesXmittedOK          EMAC_TXC_UNICST    /* Unicast TX Frame Count                               */
+#define MulticastFramesXmittedOK        EMAC_TXC_MULTI     /* Multicast TX Frame Count                             */
+#define BroadcastFramesXmittedOK        EMAC_TXC_BROAD     /* Broadcast TX Frame Count                             */
+#define FramesWithExcessiveDeferral     EMAC_TXC_XS_DFR    /* TX Frames With Excessive Deferral Count              */
+#define MACControlFramesTransmitted     EMAC_TXC_MACCTL    /* MAC Control TX Frame Count                           */
+#define FramesTransmittedAll            EMAC_TXC_ALLFRM    /* Overall TX Frame Count                               */
+#define OctetsTransmittedAll            EMAC_TXC_ALLOCT    /* Overall TX Octet Count                               */
+#define FramesLenEq64Transmitted        EMAC_TXC_EQ64      /* Good TX Frame Count - Byte Count x = 64              */
+#define FramesLen65_127Transmitted      EMAC_TXC_LT128     /* Good TX Frame Count - Byte Count  64 < x < 128       */
+#define FramesLen128_255Transmitted     EMAC_TXC_LT256     /* Good TX Frame Count - Byte Count 128 <= x < 256      */
+#define FramesLen256_511Transmitted     EMAC_TXC_LT512     /* Good TX Frame Count - Byte Count 256 <= x < 512      */
+#define FramesLen512_1023Transmitted    EMAC_TXC_LT1024    /* Good TX Frame Count - Byte Count 512 <= x < 1024     */
+#define FramesLen1024_MaxTransmitted    EMAC_TXC_GE1024    /* Good TX Frame Count - Byte Count x >= 1024           */
+#define TxAbortedFrames                 EMAC_TXC_ABORT     /* Total TX Frames Aborted Count                        */
+
+/***********************************************************************************
+** System MMR Register Bits And Macros
+**
+** Disclaimer:	All macros are intended to make C and Assembly code more readable.
+**				Use these macros carefully, as any that do left shifts for field
+**				depositing will result in the lower order bits being destroyed.  Any
+**				macro that shifts left to properly position the bit-field should be
+**				used as part of an OR to initialize a register and NOT as a dynamic
+**				modifier UNLESS the lower order bits are saved and ORed back in when
+**				the macro is used.
+*************************************************************************************/
+
+/************************  ETHERNET 10/100 CONTROLLER MASKS  ************************/
+
+/* EMAC_OPMODE Masks */
+
+#define	RE                 0x00000001     /* Receiver Enable                                    */
+#define	ASTP               0x00000002     /* Enable Automatic Pad Stripping On RX Frames        */
+#define	HU                 0x00000010     /* Hash Filter Unicast Address                        */
+#define	HM                 0x00000020     /* Hash Filter Multicast Address                      */
+#define	PAM                0x00000040     /* Pass-All-Multicast Mode Enable                     */
+#define	PR                 0x00000080     /* Promiscuous Mode Enable                            */
+#define	IFE                0x00000100     /* Inverse Filtering Enable                           */
+#define	DBF                0x00000200     /* Disable Broadcast Frame Reception                  */
+#define	PBF                0x00000400     /* Pass Bad Frames Enable                             */
+#define	PSF                0x00000800     /* Pass Short Frames Enable                           */
+#define	RAF                0x00001000     /* Receive-All Mode                                   */
+#define	TE                 0x00010000     /* Transmitter Enable                                 */
+#define	DTXPAD             0x00020000     /* Disable Automatic TX Padding                       */
+#define	DTXCRC             0x00040000     /* Disable Automatic TX CRC Generation                */
+#define	DC                 0x00080000     /* Deferral Check                                     */
+#define	BOLMT              0x00300000     /* Back-Off Limit                                     */
+#define	BOLMT_10           0x00000000     /*		10-bit range                            */
+#define	BOLMT_8            0x00100000     /*		8-bit range                             */
+#define	BOLMT_4            0x00200000     /*		4-bit range                             */
+#define	BOLMT_1            0x00300000     /*		1-bit range                             */
+#define	DRTY               0x00400000     /* Disable TX Retry On Collision                      */
+#define	LCTRE              0x00800000     /* Enable TX Retry On Late Collision                  */
+#define	RMII               0x01000000     /* RMII/MII* Mode                                     */
+#define	RMII_10            0x02000000     /* Speed Select for RMII Port (10MBit/100MBit*)       */
+#define	FDMODE             0x04000000     /* Duplex Mode Enable (Full/Half*)                    */
+#define	LB                 0x08000000     /* Internal Loopback Enable                           */
+#define	DRO                0x10000000     /* Disable Receive Own Frames (Half-Duplex Mode)      */
+
+/* EMAC_STAADD Masks */
+
+#define	STABUSY            0x00000001     /* Initiate Station Mgt Reg Access / STA Busy Stat    */
+#define	STAOP              0x00000002     /* Station Management Operation Code (Write/Read*)    */
+#define	STADISPRE          0x00000004     /* Disable Preamble Generation                        */
+#define	STAIE              0x00000008     /* Station Mgt. Transfer Done Interrupt Enable        */
+#define	REGAD              0x000007C0     /* STA Register Address                               */
+#define	PHYAD              0x0000F800     /* PHY Device Address                                 */
+
+#define	SET_REGAD(x) (((x)&0x1F)<<  6 )   /* Set STA Register Address                           */
+#define	SET_PHYAD(x) (((x)&0x1F)<< 11 )   /* Set PHY Device Address                             */
+
+/* EMAC_STADAT Mask */
+
+#define	STADATA            0x0000FFFF     /* Station Management Data                            */
+
+/* EMAC_FLC Masks */
+
+#define	FLCBUSY            0x00000001     /* Send Flow Ctrl Frame / Flow Ctrl Busy Status       */
+#define	FLCE               0x00000002     /* Flow Control Enable                                */
+#define	PCF                0x00000004     /* Pass Control Frames                                */
+#define	BKPRSEN            0x00000008     /* Enable Backpressure                                */
+#define	FLCPAUSE           0xFFFF0000     /* Pause Time                                         */
+
+#define	SET_FLCPAUSE(x) (((x)&0xFFFF)<< 16) /* Set Pause Time                                   */
+
+/* EMAC_WKUP_CTL Masks */
+
+#define	CAPWKFRM           0x00000001    /* Capture Wake-Up Frames                              */
+#define	MPKE               0x00000002    /* Magic Packet Enable                                 */
+#define	RWKE               0x00000004    /* Remote Wake-Up Frame Enable                         */
+#define	GUWKE              0x00000008    /* Global Unicast Wake Enable                          */
+#define	MPKS               0x00000020    /* Magic Packet Received Status                        */
+#define	RWKS               0x00000F00    /* Wake-Up Frame Received Status, Filters 3:0          */
+
+/* EMAC_WKUP_FFCMD Masks */
+
+#define	WF0_E              0x00000001    /* Enable Wake-Up Filter 0                              */
+#define	WF0_T              0x00000008    /* Wake-Up Filter 0 Addr Type (Multicast/Unicast*)      */
+#define	WF1_E              0x00000100    /* Enable Wake-Up Filter 1                              */
+#define	WF1_T              0x00000800    /* Wake-Up Filter 1 Addr Type (Multicast/Unicast*)      */
+#define	WF2_E              0x00010000    /* Enable Wake-Up Filter 2                              */
+#define	WF2_T              0x00080000    /* Wake-Up Filter 2 Addr Type (Multicast/Unicast*)      */
+#define	WF3_E              0x01000000    /* Enable Wake-Up Filter 3                              */
+#define	WF3_T              0x08000000    /* Wake-Up Filter 3 Addr Type (Multicast/Unicast*)      */
+
+/* EMAC_WKUP_FFOFF Masks */
+
+#define	WF0_OFF            0x000000FF    /* Wake-Up Filter 0 Pattern Offset                      */
+#define	WF1_OFF            0x0000FF00    /* Wake-Up Filter 1 Pattern Offset                      */
+#define	WF2_OFF            0x00FF0000    /* Wake-Up Filter 2 Pattern Offset                      */
+#define	WF3_OFF            0xFF000000    /* Wake-Up Filter 3 Pattern Offset                      */
+
+#define	SET_WF0_OFF(x) (((x)&0xFF)<<  0 ) /* Set Wake-Up Filter 0 Byte Offset                    */
+#define	SET_WF1_OFF(x) (((x)&0xFF)<<  8 ) /* Set Wake-Up Filter 1 Byte Offset                    */
+#define	SET_WF2_OFF(x) (((x)&0xFF)<< 16 ) /* Set Wake-Up Filter 2 Byte Offset                    */
+#define	SET_WF3_OFF(x) (((x)&0xFF)<< 24 ) /* Set Wake-Up Filter 3 Byte Offset                    */
+/* Set ALL Offsets */
+#define	SET_WF_OFFS(x0,x1,x2,x3) (SET_WF0_OFF((x0))|SET_WF1_OFF((x1))|SET_WF2_OFF((x2))|SET_WF3_OFF((x3)))
+
+/* EMAC_WKUP_FFCRC0 Masks */
+
+#define	WF0_CRC           0x0000FFFF    /* Wake-Up Filter 0 Pattern CRC                           */
+#define	WF1_CRC           0xFFFF0000    /* Wake-Up Filter 1 Pattern CRC                           */
+
+#define	SET_WF0_CRC(x) (((x)&0xFFFF)<<   0 ) /* Set Wake-Up Filter 0 Target CRC                   */
+#define	SET_WF1_CRC(x) (((x)&0xFFFF)<<  16 ) /* Set Wake-Up Filter 1 Target CRC                   */
+
+/* EMAC_WKUP_FFCRC1 Masks */
+
+#define	WF2_CRC           0x0000FFFF    /* Wake-Up Filter 2 Pattern CRC                           */
+#define	WF3_CRC           0xFFFF0000    /* Wake-Up Filter 3 Pattern CRC                           */
+
+#define	SET_WF2_CRC(x) (((x)&0xFFFF)<<   0 ) /* Set Wake-Up Filter 2 Target CRC                   */
+#define	SET_WF3_CRC(x) (((x)&0xFFFF)<<  16 ) /* Set Wake-Up Filter 3 Target CRC                   */
+
+/* EMAC_SYSCTL Masks */
+
+#define	PHYIE             0x00000001    /* PHY_INT Interrupt Enable                               */
+#define	RXDWA             0x00000002    /* Receive Frame DMA Word Alignment (Odd/Even*)           */
+#define	RXCKS             0x00000004    /* Enable RX Frame TCP/UDP Checksum Computation           */
+#define	MDCDIV            0x00003F00    /* SCLK:MDC Clock Divisor [MDC=SCLK/(2*(N+1))]            */
+
+#define	SET_MDCDIV(x) (((x)&0x3F)<< 8)   /* Set MDC Clock Divisor                                 */
+
+/* EMAC_SYSTAT Masks */
+
+#define	PHYINT            0x00000001    /* PHY_INT Interrupt Status                               */
+#define	MMCINT            0x00000002    /* MMC Counter Interrupt Status                           */
+#define	RXFSINT           0x00000004    /* RX Frame-Status Interrupt Status                       */
+#define	TXFSINT           0x00000008    /* TX Frame-Status Interrupt Status                       */
+#define	WAKEDET           0x00000010    /* Wake-Up Detected Status                                */
+#define	RXDMAERR          0x00000020    /* RX DMA Direction Error Status                          */
+#define	TXDMAERR          0x00000040    /* TX DMA Direction Error Status                          */
+#define	STMDONE           0x00000080    /* Station Mgt. Transfer Done Interrupt Status            */
+
+/* EMAC_RX_STAT, EMAC_RX_STKY, and EMAC_RX_IRQE Masks */
+
+#define	RX_FRLEN          0x000007FF    /* Frame Length In Bytes                                  */
+#define	RX_COMP           0x00001000    /* RX Frame Complete                                      */
+#define	RX_OK             0x00002000    /* RX Frame Received With No Errors                       */
+#define	RX_LONG           0x00004000    /* RX Frame Too Long Error                                */
+#define	RX_ALIGN          0x00008000    /* RX Frame Alignment Error                               */
+#define	RX_CRC            0x00010000    /* RX Frame CRC Error                                     */
+#define	RX_LEN            0x00020000    /* RX Frame Length Error                                  */
+#define	RX_FRAG           0x00040000    /* RX Frame Fragment Error                                */
+#define	RX_ADDR           0x00080000    /* RX Frame Address Filter Failed Error                   */
+#define	RX_DMAO           0x00100000    /* RX Frame DMA Overrun Error                             */
+#define	RX_PHY            0x00200000    /* RX Frame PHY Error                                     */
+#define	RX_LATE           0x00400000    /* RX Frame Late Collision Error                          */
+#define	RX_RANGE          0x00800000    /* RX Frame Length Field Out of Range Error               */
+#define	RX_MULTI          0x01000000    /* RX Multicast Frame Indicator                           */
+#define	RX_BROAD          0x02000000    /* RX Broadcast Frame Indicator                           */
+#define	RX_CTL            0x04000000    /* RX Control Frame Indicator                             */
+#define	RX_UCTL           0x08000000    /* Unsupported RX Control Frame Indicator                 */
+#define	RX_TYPE           0x10000000    /* RX Typed Frame Indicator                               */
+#define	RX_VLAN1          0x20000000    /* RX VLAN1 Frame Indicator                               */
+#define	RX_VLAN2          0x40000000    /* RX VLAN2 Frame Indicator                               */
+#define	RX_ACCEPT         0x80000000    /* RX Frame Accepted Indicator                            */
+
+/*  EMAC_TX_STAT, EMAC_TX_STKY, and EMAC_TX_IRQE Masks  */
+
+#define	TX_COMP           0x00000001    /* TX Frame Complete                                      */
+#define	TX_OK             0x00000002    /* TX Frame Sent With No Errors                           */
+#define	TX_ECOLL          0x00000004    /* TX Frame Excessive Collision Error                     */
+#define	TX_LATE           0x00000008    /* TX Frame Late Collision Error                          */
+#define	TX_DMAU           0x00000010    /* TX Frame DMA Underrun Error (STAT)                     */
+#define	TX_MACE           0x00000010    /* Internal MAC Error Detected (STKY and IRQE)            */
+#define	TX_EDEFER         0x00000020    /* TX Frame Excessive Deferral Error                      */
+#define	TX_BROAD          0x00000040    /* TX Broadcast Frame Indicator                           */
+#define	TX_MULTI          0x00000080    /* TX Multicast Frame Indicator                           */
+#define	TX_CCNT           0x00000F00    /* TX Frame Collision Count                               */
+#define	TX_DEFER          0x00001000    /* TX Frame Deferred Indicator                            */
+#define	TX_CRS            0x00002000    /* TX Frame Carrier Sense Not Asserted Error              */
+#define	TX_LOSS           0x00004000    /* TX Frame Carrier Lost During TX Error                  */
+#define	TX_RETRY          0x00008000    /* TX Frame Successful After Retry                        */
+#define	TX_FRLEN          0x07FF0000    /* TX Frame Length (Bytes)                                */
+
+/* EMAC_MMC_CTL Masks */
+#define	RSTC              0x00000001    /* Reset All Counters                                     */
+#define	CROLL             0x00000002    /* Counter Roll-Over Enable                               */
+#define	CCOR              0x00000004    /* Counter Clear-On-Read Mode Enable                      */
+#define	MMCE              0x00000008    /* Enable MMC Counter Operation                           */
+
+/* EMAC_MMC_RIRQS and EMAC_MMC_RIRQE Masks */
+#define	RX_OK_CNT         0x00000001    /* RX Frames Received With No Errors                      */
+#define	RX_FCS_CNT        0x00000002    /* RX Frames W/Frame Check Sequence Errors                */
+#define	RX_ALIGN_CNT      0x00000004    /* RX Frames With Alignment Errors                        */
+#define	RX_OCTET_CNT      0x00000008    /* RX Octets Received OK                                  */
+#define	RX_LOST_CNT       0x00000010    /* RX Frames Lost Due To Internal MAC RX Error            */
+#define	RX_UNI_CNT        0x00000020    /* Unicast RX Frames Received OK                          */
+#define	RX_MULTI_CNT      0x00000040    /* Multicast RX Frames Received OK                        */
+#define	RX_BROAD_CNT      0x00000080    /* Broadcast RX Frames Received OK                        */
+#define	RX_IRL_CNT        0x00000100    /* RX Frames With In-Range Length Errors                  */
+#define	RX_ORL_CNT        0x00000200    /* RX Frames With Out-Of-Range Length Errors              */
+#define	RX_LONG_CNT       0x00000400    /* RX Frames With Frame Too Long Errors                   */
+#define	RX_MACCTL_CNT     0x00000800    /* MAC Control RX Frames Received                         */
+#define	RX_OPCODE_CTL     0x00001000    /* Unsupported Op-Code RX Frames Received                 */
+#define	RX_PAUSE_CNT      0x00002000    /* PAUSEMAC Control RX Frames Received                    */
+#define	RX_ALLF_CNT       0x00004000    /* All RX Frames Received                                 */
+#define	RX_ALLO_CNT       0x00008000    /* All RX Octets Received                                 */
+#define	RX_TYPED_CNT      0x00010000    /* Typed RX Frames Received                               */
+#define	RX_SHORT_CNT      0x00020000    /* RX Frame Fragments (< 64 Bytes) Received               */
+#define	RX_EQ64_CNT       0x00040000    /* 64-Byte RX Frames Received                             */
+#define	RX_LT128_CNT      0x00080000    /* 65-127-Byte RX Frames Received                         */
+#define	RX_LT256_CNT      0x00100000    /* 128-255-Byte RX Frames Received                        */
+#define	RX_LT512_CNT      0x00200000    /* 256-511-Byte RX Frames Received                        */
+#define	RX_LT1024_CNT     0x00400000    /* 512-1023-Byte RX Frames Received                       */
+#define	RX_GE1024_CNT     0x00800000    /* 1024-Max-Byte RX Frames Received                       */
+
+/* EMAC_MMC_TIRQS and EMAC_MMC_TIRQE Masks  */
+
+#define	TX_OK_CNT         0x00000001    /* TX Frames Sent OK                                      */
+#define	TX_SCOLL_CNT      0x00000002    /* TX Frames With Single Collisions                       */
+#define	TX_MCOLL_CNT      0x00000004    /* TX Frames With Multiple Collisions                     */
+#define	TX_OCTET_CNT      0x00000008    /* TX Octets Sent OK                                      */
+#define	TX_DEFER_CNT      0x00000010    /* TX Frames With Deferred Transmission                   */
+#define	TX_LATE_CNT       0x00000020    /* TX Frames With Late Collisions                         */
+#define	TX_ABORTC_CNT     0x00000040    /* TX Frames Aborted Due To Excess Collisions             */
+#define	TX_LOST_CNT       0x00000080    /* TX Frames Lost Due To Internal MAC TX Error            */
+#define	TX_CRS_CNT        0x00000100    /* TX Frames With Carrier Sense Errors                    */
+#define	TX_UNI_CNT        0x00000200    /* Unicast TX Frames Sent                                 */
+#define	TX_MULTI_CNT      0x00000400    /* Multicast TX Frames Sent                               */
+#define	TX_BROAD_CNT      0x00000800    /* Broadcast TX Frames Sent                               */
+#define	TX_EXDEF_CTL      0x00001000    /* TX Frames With Excessive Deferral                      */
+#define	TX_MACCTL_CNT     0x00002000    /* MAC Control TX Frames Sent                             */
+#define	TX_ALLF_CNT       0x00004000    /* All TX Frames Sent                                     */
+#define	TX_ALLO_CNT       0x00008000    /* All TX Octets Sent                                     */
+#define	TX_EQ64_CNT       0x00010000    /* 64-Byte TX Frames Sent                                 */
+#define	TX_LT128_CNT      0x00020000    /* 65-127-Byte TX Frames Sent                             */
+#define	TX_LT256_CNT      0x00040000    /* 128-255-Byte TX Frames Sent                            */
+#define	TX_LT512_CNT      0x00080000    /* 256-511-Byte TX Frames Sent                            */
+#define	TX_LT1024_CNT     0x00100000    /* 512-1023-Byte TX Frames Sent                           */
+#define	TX_GE1024_CNT     0x00200000    /* 1024-Max-Byte TX Frames Sent                           */
+#define	TX_ABORT_CNT      0x00400000    /* TX Frames Aborted                                      */
+
+/* USB Control Registers */
+
+#define                        USB_FADDR  0xffc03800   /* Function address register */
+#define                        USB_POWER  0xffc03804   /* Power management register */
+#define                       USB_INTRTX  0xffc03808   /* Interrupt register for endpoint 0 and Tx endpoint 1 to 7 */
+#define                       USB_INTRRX  0xffc0380c   /* Interrupt register for Rx endpoints 1 to 7 */
+#define                      USB_INTRTXE  0xffc03810   /* Interrupt enable register for IntrTx */
+#define                      USB_INTRRXE  0xffc03814   /* Interrupt enable register for IntrRx */
+#define                      USB_INTRUSB  0xffc03818   /* Interrupt register for common USB interrupts */
+#define                     USB_INTRUSBE  0xffc0381c   /* Interrupt enable register for IntrUSB */
+#define                        USB_FRAME  0xffc03820   /* USB frame number */
+#define                        USB_INDEX  0xffc03824   /* Index register for selecting the indexed endpoint registers */
+#define                     USB_TESTMODE  0xffc03828   /* Enabled USB 20 test modes */
+#define                     USB_GLOBINTR  0xffc0382c   /* Global Interrupt Mask register and Wakeup Exception Interrupt */
+#define                   USB_GLOBAL_CTL  0xffc03830   /* Global Clock Control for the core */
+
+/* USB Packet Control Registers */
+
+#define                USB_TX_MAX_PACKET  0xffc03840   /* Maximum packet size for Host Tx endpoint */
+#define                         USB_CSR0  0xffc03844   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                        USB_TXCSR  0xffc03844   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                USB_RX_MAX_PACKET  0xffc03848   /* Maximum packet size for Host Rx endpoint */
+#define                        USB_RXCSR  0xffc0384c   /* Control Status register for Host Rx endpoint */
+#define                       USB_COUNT0  0xffc03850   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                      USB_RXCOUNT  0xffc03850   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                       USB_TXTYPE  0xffc03854   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint */
+#define                    USB_NAKLIMIT0  0xffc03858   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                   USB_TXINTERVAL  0xffc03858   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                       USB_RXTYPE  0xffc0385c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint */
+#define                   USB_RXINTERVAL  0xffc03860   /* Sets the polling interval for Interrupt and Isochronous transfers or the NAK response timeout on Bulk transfers */
+#define                      USB_TXCOUNT  0xffc03868   /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* USB Endpoint FIFO Registers */
+
+#define                     USB_EP0_FIFO  0xffc03880   /* Endpoint 0 FIFO */
+#define                     USB_EP1_FIFO  0xffc03888   /* Endpoint 1 FIFO */
+#define                     USB_EP2_FIFO  0xffc03890   /* Endpoint 2 FIFO */
+#define                     USB_EP3_FIFO  0xffc03898   /* Endpoint 3 FIFO */
+#define                     USB_EP4_FIFO  0xffc038a0   /* Endpoint 4 FIFO */
+#define                     USB_EP5_FIFO  0xffc038a8   /* Endpoint 5 FIFO */
+#define                     USB_EP6_FIFO  0xffc038b0   /* Endpoint 6 FIFO */
+#define                     USB_EP7_FIFO  0xffc038b8   /* Endpoint 7 FIFO */
+
+/* USB OTG Control Registers */
+
+#define                  USB_OTG_DEV_CTL  0xffc03900   /* OTG Device Control Register */
+#define                 USB_OTG_VBUS_IRQ  0xffc03904   /* OTG VBUS Control Interrupts */
+#define                USB_OTG_VBUS_MASK  0xffc03908   /* VBUS Control Interrupt Enable */
+
+/* USB Phy Control Registers */
+
+#define                     USB_LINKINFO  0xffc03948   /* Enables programming of some PHY-side delays */
+#define                        USB_VPLEN  0xffc0394c   /* Determines duration of VBUS pulse for VBUS charging */
+#define                      USB_HS_EOF1  0xffc03950   /* Time buffer for High-Speed transactions */
+#define                      USB_FS_EOF1  0xffc03954   /* Time buffer for Full-Speed transactions */
+#define                      USB_LS_EOF1  0xffc03958   /* Time buffer for Low-Speed transactions */
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define                   USB_APHY_CNTRL  0xffc039e0   /* Register that increases visibility of Analog PHY */
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define                   USB_APHY_CALIB  0xffc039e4   /* Register used to set some calibration values */
+
+#define                  USB_APHY_CNTRL2  0xffc039e8   /* Register used to prevent re-enumeration once Moab goes into hibernate mode */
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define                     USB_PHY_TEST  0xffc039ec   /* Used for reducing simulation time and simplifies FIFO testability */
+
+#define                  USB_PLLOSC_CTRL  0xffc039f0   /* Used to program different parameters for USB PLL and Oscillator */
+#define                   USB_SRP_CLKDIV  0xffc039f4   /* Used to program clock divide value for the clock fed to the SRP detection logic */
+
+/* USB Endpoint 0 Control Registers */
+
+#define                USB_EP_NI0_TXMAXP  0xffc03a00   /* Maximum packet size for Host Tx endpoint0 */
+#define                 USB_EP_NI0_TXCSR  0xffc03a04   /* Control Status register for endpoint 0 */
+#define                USB_EP_NI0_RXMAXP  0xffc03a08   /* Maximum packet size for Host Rx endpoint0 */
+#define                 USB_EP_NI0_RXCSR  0xffc03a0c   /* Control Status register for Host Rx endpoint0 */
+#define               USB_EP_NI0_RXCOUNT  0xffc03a10   /* Number of bytes received in endpoint 0 FIFO */
+#define                USB_EP_NI0_TXTYPE  0xffc03a14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint0 */
+#define            USB_EP_NI0_TXINTERVAL  0xffc03a18   /* Sets the NAK response timeout on Endpoint 0 */
+#define                USB_EP_NI0_RXTYPE  0xffc03a1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint0 */
+#define            USB_EP_NI0_RXINTERVAL  0xffc03a20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint0 */
+#define               USB_EP_NI0_TXCOUNT  0xffc03a28   /* Number of bytes to be written to the endpoint0 Tx FIFO */
+
+/* USB Endpoint 1 Control Registers */
+
+#define                USB_EP_NI1_TXMAXP  0xffc03a40   /* Maximum packet size for Host Tx endpoint1 */
+#define                 USB_EP_NI1_TXCSR  0xffc03a44   /* Control Status register for endpoint1 */
+#define                USB_EP_NI1_RXMAXP  0xffc03a48   /* Maximum packet size for Host Rx endpoint1 */
+#define                 USB_EP_NI1_RXCSR  0xffc03a4c   /* Control Status register for Host Rx endpoint1 */
+#define               USB_EP_NI1_RXCOUNT  0xffc03a50   /* Number of bytes received in endpoint1 FIFO */
+#define                USB_EP_NI1_TXTYPE  0xffc03a54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint1 */
+#define            USB_EP_NI1_TXINTERVAL  0xffc03a58   /* Sets the NAK response timeout on Endpoint1 */
+#define                USB_EP_NI1_RXTYPE  0xffc03a5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint1 */
+#define            USB_EP_NI1_RXINTERVAL  0xffc03a60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint1 */
+#define               USB_EP_NI1_TXCOUNT  0xffc03a68   /* Number of bytes to be written to the+H102 endpoint1 Tx FIFO */
+
+/* USB Endpoint 2 Control Registers */
+
+#define                USB_EP_NI2_TXMAXP  0xffc03a80   /* Maximum packet size for Host Tx endpoint2 */
+#define                 USB_EP_NI2_TXCSR  0xffc03a84   /* Control Status register for endpoint2 */
+#define                USB_EP_NI2_RXMAXP  0xffc03a88   /* Maximum packet size for Host Rx endpoint2 */
+#define                 USB_EP_NI2_RXCSR  0xffc03a8c   /* Control Status register for Host Rx endpoint2 */
+#define               USB_EP_NI2_RXCOUNT  0xffc03a90   /* Number of bytes received in endpoint2 FIFO */
+#define                USB_EP_NI2_TXTYPE  0xffc03a94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint2 */
+#define            USB_EP_NI2_TXINTERVAL  0xffc03a98   /* Sets the NAK response timeout on Endpoint2 */
+#define                USB_EP_NI2_RXTYPE  0xffc03a9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint2 */
+#define            USB_EP_NI2_RXINTERVAL  0xffc03aa0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint2 */
+#define               USB_EP_NI2_TXCOUNT  0xffc03aa8   /* Number of bytes to be written to the endpoint2 Tx FIFO */
+
+/* USB Endpoint 3 Control Registers */
+
+#define                USB_EP_NI3_TXMAXP  0xffc03ac0   /* Maximum packet size for Host Tx endpoint3 */
+#define                 USB_EP_NI3_TXCSR  0xffc03ac4   /* Control Status register for endpoint3 */
+#define                USB_EP_NI3_RXMAXP  0xffc03ac8   /* Maximum packet size for Host Rx endpoint3 */
+#define                 USB_EP_NI3_RXCSR  0xffc03acc   /* Control Status register for Host Rx endpoint3 */
+#define               USB_EP_NI3_RXCOUNT  0xffc03ad0   /* Number of bytes received in endpoint3 FIFO */
+#define                USB_EP_NI3_TXTYPE  0xffc03ad4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint3 */
+#define            USB_EP_NI3_TXINTERVAL  0xffc03ad8   /* Sets the NAK response timeout on Endpoint3 */
+#define                USB_EP_NI3_RXTYPE  0xffc03adc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint3 */
+#define            USB_EP_NI3_RXINTERVAL  0xffc03ae0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint3 */
+#define               USB_EP_NI3_TXCOUNT  0xffc03ae8   /* Number of bytes to be written to the H124endpoint3 Tx FIFO */
+
+/* USB Endpoint 4 Control Registers */
+
+#define                USB_EP_NI4_TXMAXP  0xffc03b00   /* Maximum packet size for Host Tx endpoint4 */
+#define                 USB_EP_NI4_TXCSR  0xffc03b04   /* Control Status register for endpoint4 */
+#define                USB_EP_NI4_RXMAXP  0xffc03b08   /* Maximum packet size for Host Rx endpoint4 */
+#define                 USB_EP_NI4_RXCSR  0xffc03b0c   /* Control Status register for Host Rx endpoint4 */
+#define               USB_EP_NI4_RXCOUNT  0xffc03b10   /* Number of bytes received in endpoint4 FIFO */
+#define                USB_EP_NI4_TXTYPE  0xffc03b14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint4 */
+#define            USB_EP_NI4_TXINTERVAL  0xffc03b18   /* Sets the NAK response timeout on Endpoint4 */
+#define                USB_EP_NI4_RXTYPE  0xffc03b1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint4 */
+#define            USB_EP_NI4_RXINTERVAL  0xffc03b20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint4 */
+#define               USB_EP_NI4_TXCOUNT  0xffc03b28   /* Number of bytes to be written to the endpoint4 Tx FIFO */
+
+/* USB Endpoint 5 Control Registers */
+
+#define                USB_EP_NI5_TXMAXP  0xffc03b40   /* Maximum packet size for Host Tx endpoint5 */
+#define                 USB_EP_NI5_TXCSR  0xffc03b44   /* Control Status register for endpoint5 */
+#define                USB_EP_NI5_RXMAXP  0xffc03b48   /* Maximum packet size for Host Rx endpoint5 */
+#define                 USB_EP_NI5_RXCSR  0xffc03b4c   /* Control Status register for Host Rx endpoint5 */
+#define               USB_EP_NI5_RXCOUNT  0xffc03b50   /* Number of bytes received in endpoint5 FIFO */
+#define                USB_EP_NI5_TXTYPE  0xffc03b54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint5 */
+#define            USB_EP_NI5_TXINTERVAL  0xffc03b58   /* Sets the NAK response timeout on Endpoint5 */
+#define                USB_EP_NI5_RXTYPE  0xffc03b5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint5 */
+#define            USB_EP_NI5_RXINTERVAL  0xffc03b60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint5 */
+#define               USB_EP_NI5_TXCOUNT  0xffc03b68   /* Number of bytes to be written to the endpoint5 Tx FIFO */
+
+/* USB Endpoint 6 Control Registers */
+
+#define                USB_EP_NI6_TXMAXP  0xffc03b80   /* Maximum packet size for Host Tx endpoint6 */
+#define                 USB_EP_NI6_TXCSR  0xffc03b84   /* Control Status register for endpoint6 */
+#define                USB_EP_NI6_RXMAXP  0xffc03b88   /* Maximum packet size for Host Rx endpoint6 */
+#define                 USB_EP_NI6_RXCSR  0xffc03b8c   /* Control Status register for Host Rx endpoint6 */
+#define               USB_EP_NI6_RXCOUNT  0xffc03b90   /* Number of bytes received in endpoint6 FIFO */
+#define                USB_EP_NI6_TXTYPE  0xffc03b94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint6 */
+#define            USB_EP_NI6_TXINTERVAL  0xffc03b98   /* Sets the NAK response timeout on Endpoint6 */
+#define                USB_EP_NI6_RXTYPE  0xffc03b9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint6 */
+#define            USB_EP_NI6_RXINTERVAL  0xffc03ba0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint6 */
+#define               USB_EP_NI6_TXCOUNT  0xffc03ba8   /* Number of bytes to be written to the endpoint6 Tx FIFO */
+
+/* USB Endpoint 7 Control Registers */
+
+#define                USB_EP_NI7_TXMAXP  0xffc03bc0   /* Maximum packet size for Host Tx endpoint7 */
+#define                 USB_EP_NI7_TXCSR  0xffc03bc4   /* Control Status register for endpoint7 */
+#define                USB_EP_NI7_RXMAXP  0xffc03bc8   /* Maximum packet size for Host Rx endpoint7 */
+#define                 USB_EP_NI7_RXCSR  0xffc03bcc   /* Control Status register for Host Rx endpoint7 */
+#define               USB_EP_NI7_RXCOUNT  0xffc03bd0   /* Number of bytes received in endpoint7 FIFO */
+#define                USB_EP_NI7_TXTYPE  0xffc03bd4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint7 */
+#define            USB_EP_NI7_TXINTERVAL  0xffc03bd8   /* Sets the NAK response timeout on Endpoint7 */
+#define                USB_EP_NI7_RXTYPE  0xffc03bdc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint7 */
+#define            USB_EP_NI7_RXINTERVAL  0xffc03bf0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint7 */
+#define               USB_EP_NI7_TXCOUNT  0xffc03bf8   /* Number of bytes to be written to the endpoint7 Tx FIFO */
+
+#define                USB_DMA_INTERRUPT  0xffc03c00   /* Indicates pending interrupts for the DMA channels */
+
+/* USB Channel 0 Config Registers */
+
+#define                  USB_DMA0CONTROL  0xffc03c04   /* DMA master channel 0 configuration */
+#define                  USB_DMA0ADDRLOW  0xffc03c08   /* Lower 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0ADDRHIGH  0xffc03c0c   /* Upper 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0COUNTLOW  0xffc03c10   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 0 */
+#define                USB_DMA0COUNTHIGH  0xffc03c14   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 0 */
+
+/* USB Channel 1 Config Registers */
+
+#define                  USB_DMA1CONTROL  0xffc03c24   /* DMA master channel 1 configuration */
+#define                  USB_DMA1ADDRLOW  0xffc03c28   /* Lower 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1ADDRHIGH  0xffc03c2c   /* Upper 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1COUNTLOW  0xffc03c30   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 1 */
+#define                USB_DMA1COUNTHIGH  0xffc03c34   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 1 */
+
+/* USB Channel 2 Config Registers */
+
+#define                  USB_DMA2CONTROL  0xffc03c44   /* DMA master channel 2 configuration */
+#define                  USB_DMA2ADDRLOW  0xffc03c48   /* Lower 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2ADDRHIGH  0xffc03c4c   /* Upper 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2COUNTLOW  0xffc03c50   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 2 */
+#define                USB_DMA2COUNTHIGH  0xffc03c54   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 2 */
+
+/* USB Channel 3 Config Registers */
+
+#define                  USB_DMA3CONTROL  0xffc03c64   /* DMA master channel 3 configuration */
+#define                  USB_DMA3ADDRLOW  0xffc03c68   /* Lower 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3ADDRHIGH  0xffc03c6c   /* Upper 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3COUNTLOW  0xffc03c70   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 3 */
+#define                USB_DMA3COUNTHIGH  0xffc03c74   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 3 */
+
+/* USB Channel 4 Config Registers */
+
+#define                  USB_DMA4CONTROL  0xffc03c84   /* DMA master channel 4 configuration */
+#define                  USB_DMA4ADDRLOW  0xffc03c88   /* Lower 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4ADDRHIGH  0xffc03c8c   /* Upper 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4COUNTLOW  0xffc03c90   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 4 */
+#define                USB_DMA4COUNTHIGH  0xffc03c94   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 4 */
+
+/* USB Channel 5 Config Registers */
+
+#define                  USB_DMA5CONTROL  0xffc03ca4   /* DMA master channel 5 configuration */
+#define                  USB_DMA5ADDRLOW  0xffc03ca8   /* Lower 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5ADDRHIGH  0xffc03cac   /* Upper 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5COUNTLOW  0xffc03cb0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 5 */
+#define                USB_DMA5COUNTHIGH  0xffc03cb4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 5 */
+
+/* USB Channel 6 Config Registers */
+
+#define                  USB_DMA6CONTROL  0xffc03cc4   /* DMA master channel 6 configuration */
+#define                  USB_DMA6ADDRLOW  0xffc03cc8   /* Lower 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6ADDRHIGH  0xffc03ccc   /* Upper 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6COUNTLOW  0xffc03cd0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 6 */
+#define                USB_DMA6COUNTHIGH  0xffc03cd4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 6 */
+
+/* USB Channel 7 Config Registers */
+
+#define                  USB_DMA7CONTROL  0xffc03ce4   /* DMA master channel 7 configuration */
+#define                  USB_DMA7ADDRLOW  0xffc03ce8   /* Lower 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7ADDRHIGH  0xffc03cec   /* Upper 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7COUNTLOW  0xffc03cf0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 7 */
+#define                USB_DMA7COUNTHIGH  0xffc03cf4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 7 */
+
+/* Bit masks for USB_FADDR */
+
+#define          FUNCTION_ADDRESS  0x7f       /* Function address */
+
+/* Bit masks for USB_POWER */
+
+#define           ENABLE_SUSPENDM  0x1        /* enable SuspendM output */
+#define          nENABLE_SUSPENDM  0x0       
+#define              SUSPEND_MODE  0x2        /* Suspend Mode indicator */
+#define             nSUSPEND_MODE  0x0       
+#define               RESUME_MODE  0x4        /* DMA Mode */
+#define              nRESUME_MODE  0x0       
+#define                     RESET  0x8        /* Reset indicator */
+#define                    nRESET  0x0       
+#define                   HS_MODE  0x10       /* High Speed mode indicator */
+#define                  nHS_MODE  0x0       
+#define                 HS_ENABLE  0x20       /* high Speed Enable */
+#define                nHS_ENABLE  0x0       
+#define                 SOFT_CONN  0x40       /* Soft connect */
+#define                nSOFT_CONN  0x0       
+#define                ISO_UPDATE  0x80       /* Isochronous update */
+#define               nISO_UPDATE  0x0       
+
+/* Bit masks for USB_INTRTX */
+
+#define                    EP0_TX  0x1        /* Tx Endpoint 0 interrupt */
+#define                   nEP0_TX  0x0       
+#define                    EP1_TX  0x2        /* Tx Endpoint 1 interrupt */
+#define                   nEP1_TX  0x0       
+#define                    EP2_TX  0x4        /* Tx Endpoint 2 interrupt */
+#define                   nEP2_TX  0x0       
+#define                    EP3_TX  0x8        /* Tx Endpoint 3 interrupt */
+#define                   nEP3_TX  0x0       
+#define                    EP4_TX  0x10       /* Tx Endpoint 4 interrupt */
+#define                   nEP4_TX  0x0       
+#define                    EP5_TX  0x20       /* Tx Endpoint 5 interrupt */
+#define                   nEP5_TX  0x0       
+#define                    EP6_TX  0x40       /* Tx Endpoint 6 interrupt */
+#define                   nEP6_TX  0x0       
+#define                    EP7_TX  0x80       /* Tx Endpoint 7 interrupt */
+#define                   nEP7_TX  0x0       
+
+/* Bit masks for USB_INTRRX */
+
+#define                    EP1_RX  0x2        /* Rx Endpoint 1 interrupt */
+#define                   nEP1_RX  0x0       
+#define                    EP2_RX  0x4        /* Rx Endpoint 2 interrupt */
+#define                   nEP2_RX  0x0       
+#define                    EP3_RX  0x8        /* Rx Endpoint 3 interrupt */
+#define                   nEP3_RX  0x0       
+#define                    EP4_RX  0x10       /* Rx Endpoint 4 interrupt */
+#define                   nEP4_RX  0x0       
+#define                    EP5_RX  0x20       /* Rx Endpoint 5 interrupt */
+#define                   nEP5_RX  0x0       
+#define                    EP6_RX  0x40       /* Rx Endpoint 6 interrupt */
+#define                   nEP6_RX  0x0       
+#define                    EP7_RX  0x80       /* Rx Endpoint 7 interrupt */
+#define                   nEP7_RX  0x0       
+
+/* Bit masks for USB_INTRTXE */
+
+#define                  EP0_TX_E  0x1        /* Endpoint 0 interrupt Enable */
+#define                 nEP0_TX_E  0x0       
+#define                  EP1_TX_E  0x2        /* Tx Endpoint 1 interrupt  Enable */
+#define                 nEP1_TX_E  0x0       
+#define                  EP2_TX_E  0x4        /* Tx Endpoint 2 interrupt  Enable */
+#define                 nEP2_TX_E  0x0       
+#define                  EP3_TX_E  0x8        /* Tx Endpoint 3 interrupt  Enable */
+#define                 nEP3_TX_E  0x0       
+#define                  EP4_TX_E  0x10       /* Tx Endpoint 4 interrupt  Enable */
+#define                 nEP4_TX_E  0x0       
+#define                  EP5_TX_E  0x20       /* Tx Endpoint 5 interrupt  Enable */
+#define                 nEP5_TX_E  0x0       
+#define                  EP6_TX_E  0x40       /* Tx Endpoint 6 interrupt  Enable */
+#define                 nEP6_TX_E  0x0       
+#define                  EP7_TX_E  0x80       /* Tx Endpoint 7 interrupt  Enable */
+#define                 nEP7_TX_E  0x0       
+
+/* Bit masks for USB_INTRRXE */
+
+#define                  EP1_RX_E  0x2        /* Rx Endpoint 1 interrupt  Enable */
+#define                 nEP1_RX_E  0x0       
+#define                  EP2_RX_E  0x4        /* Rx Endpoint 2 interrupt  Enable */
+#define                 nEP2_RX_E  0x0       
+#define                  EP3_RX_E  0x8        /* Rx Endpoint 3 interrupt  Enable */
+#define                 nEP3_RX_E  0x0       
+#define                  EP4_RX_E  0x10       /* Rx Endpoint 4 interrupt  Enable */
+#define                 nEP4_RX_E  0x0       
+#define                  EP5_RX_E  0x20       /* Rx Endpoint 5 interrupt  Enable */
+#define                 nEP5_RX_E  0x0       
+#define                  EP6_RX_E  0x40       /* Rx Endpoint 6 interrupt  Enable */
+#define                 nEP6_RX_E  0x0       
+#define                  EP7_RX_E  0x80       /* Rx Endpoint 7 interrupt  Enable */
+#define                 nEP7_RX_E  0x0       
+
+/* Bit masks for USB_INTRUSB */
+
+#define                 SUSPEND_B  0x1        /* Suspend indicator */
+#define                nSUSPEND_B  0x0       
+#define                  RESUME_B  0x2        /* Resume indicator */
+#define                 nRESUME_B  0x0       
+#define          RESET_OR_BABLE_B  0x4        /* Reset/babble indicator */
+#define         nRESET_OR_BABLE_B  0x0       
+#define                     SOF_B  0x8        /* Start of frame */
+#define                    nSOF_B  0x0       
+#define                    CONN_B  0x10       /* Connection indicator */
+#define                   nCONN_B  0x0       
+#define                  DISCON_B  0x20       /* Disconnect indicator */
+#define                 nDISCON_B  0x0       
+#define             SESSION_REQ_B  0x40       /* Session Request */
+#define            nSESSION_REQ_B  0x0       
+#define              VBUS_ERROR_B  0x80       /* Vbus threshold indicator */
+#define             nVBUS_ERROR_B  0x0       
+
+/* Bit masks for USB_INTRUSBE */
+
+#define                SUSPEND_BE  0x1        /* Suspend indicator int enable */
+#define               nSUSPEND_BE  0x0       
+#define                 RESUME_BE  0x2        /* Resume indicator int enable */
+#define                nRESUME_BE  0x0       
+#define         RESET_OR_BABLE_BE  0x4        /* Reset/babble indicator int enable */
+#define        nRESET_OR_BABLE_BE  0x0       
+#define                    SOF_BE  0x8        /* Start of frame int enable */
+#define                   nSOF_BE  0x0       
+#define                   CONN_BE  0x10       /* Connection indicator int enable */
+#define                  nCONN_BE  0x0       
+#define                 DISCON_BE  0x20       /* Disconnect indicator int enable */
+#define                nDISCON_BE  0x0       
+#define            SESSION_REQ_BE  0x40       /* Session Request int enable */
+#define           nSESSION_REQ_BE  0x0       
+#define             VBUS_ERROR_BE  0x80       /* Vbus threshold indicator int enable */
+#define            nVBUS_ERROR_BE  0x0       
+
+/* Bit masks for USB_FRAME */
+
+#define              FRAME_NUMBER  0x7ff      /* Frame number */
+
+/* Bit masks for USB_INDEX */
+
+#define         SELECTED_ENDPOINT  0xf        /* selected endpoint */
+
+/* Bit masks for USB_GLOBAL_CTL */
+
+#define                GLOBAL_ENA  0x1        /* enables USB module */
+#define               nGLOBAL_ENA  0x0       
+#define                EP1_TX_ENA  0x2        /* Transmit endpoint 1 enable */
+#define               nEP1_TX_ENA  0x0       
+#define                EP2_TX_ENA  0x4        /* Transmit endpoint 2 enable */
+#define               nEP2_TX_ENA  0x0       
+#define                EP3_TX_ENA  0x8        /* Transmit endpoint 3 enable */
+#define               nEP3_TX_ENA  0x0       
+#define                EP4_TX_ENA  0x10       /* Transmit endpoint 4 enable */
+#define               nEP4_TX_ENA  0x0       
+#define                EP5_TX_ENA  0x20       /* Transmit endpoint 5 enable */
+#define               nEP5_TX_ENA  0x0       
+#define                EP6_TX_ENA  0x40       /* Transmit endpoint 6 enable */
+#define               nEP6_TX_ENA  0x0       
+#define                EP7_TX_ENA  0x80       /* Transmit endpoint 7 enable */
+#define               nEP7_TX_ENA  0x0       
+#define                EP1_RX_ENA  0x100      /* Receive endpoint 1 enable */
+#define               nEP1_RX_ENA  0x0       
+#define                EP2_RX_ENA  0x200      /* Receive endpoint 2 enable */
+#define               nEP2_RX_ENA  0x0       
+#define                EP3_RX_ENA  0x400      /* Receive endpoint 3 enable */
+#define               nEP3_RX_ENA  0x0       
+#define                EP4_RX_ENA  0x800      /* Receive endpoint 4 enable */
+#define               nEP4_RX_ENA  0x0       
+#define                EP5_RX_ENA  0x1000     /* Receive endpoint 5 enable */
+#define               nEP5_RX_ENA  0x0       
+#define                EP6_RX_ENA  0x2000     /* Receive endpoint 6 enable */
+#define               nEP6_RX_ENA  0x0       
+#define                EP7_RX_ENA  0x4000     /* Receive endpoint 7 enable */
+#define               nEP7_RX_ENA  0x0       
+
+/* Bit masks for USB_OTG_DEV_CTL */
+
+#define                   SESSION  0x1        /* session indicator */
+#define                  nSESSION  0x0       
+#define                  HOST_REQ  0x2        /* Host negotiation request */
+#define                 nHOST_REQ  0x0       
+#define                 HOST_MODE  0x4        /* indicates USBDRC is a host */
+#define                nHOST_MODE  0x0       
+#define                     VBUS0  0x8        /* Vbus level indicator[0] */
+#define                    nVBUS0  0x0       
+#define                     VBUS1  0x10       /* Vbus level indicator[1] */
+#define                    nVBUS1  0x0       
+#define                     LSDEV  0x20       /* Low-speed indicator */
+#define                    nLSDEV  0x0       
+#define                     FSDEV  0x40       /* Full or High-speed indicator */
+#define                    nFSDEV  0x0       
+#define                  B_DEVICE  0x80       /* A' or 'B' device indicator */
+#define                 nB_DEVICE  0x0       
+
+/* Bit masks for USB_OTG_VBUS_IRQ */
+
+#define             DRIVE_VBUS_ON  0x1        /* indicator to drive VBUS control circuit */
+#define            nDRIVE_VBUS_ON  0x0       
+#define            DRIVE_VBUS_OFF  0x2        /* indicator to shut off charge pump */
+#define           nDRIVE_VBUS_OFF  0x0       
+#define           CHRG_VBUS_START  0x4        /* indicator for external circuit to start charging VBUS */
+#define          nCHRG_VBUS_START  0x0       
+#define             CHRG_VBUS_END  0x8        /* indicator for external circuit to end charging VBUS */
+#define            nCHRG_VBUS_END  0x0       
+#define        DISCHRG_VBUS_START  0x10       /* indicator to start discharging VBUS */
+#define       nDISCHRG_VBUS_START  0x0       
+#define          DISCHRG_VBUS_END  0x20       /* indicator to stop discharging VBUS */
+#define         nDISCHRG_VBUS_END  0x0       
+
+/* Bit masks for USB_OTG_VBUS_MASK */
+
+#define         DRIVE_VBUS_ON_ENA  0x1        /* enable DRIVE_VBUS_ON interrupt */
+#define        nDRIVE_VBUS_ON_ENA  0x0       
+#define        DRIVE_VBUS_OFF_ENA  0x2        /* enable DRIVE_VBUS_OFF interrupt */
+#define       nDRIVE_VBUS_OFF_ENA  0x0       
+#define       CHRG_VBUS_START_ENA  0x4        /* enable CHRG_VBUS_START interrupt */
+#define      nCHRG_VBUS_START_ENA  0x0       
+#define         CHRG_VBUS_END_ENA  0x8        /* enable CHRG_VBUS_END interrupt */
+#define        nCHRG_VBUS_END_ENA  0x0       
+#define    DISCHRG_VBUS_START_ENA  0x10       /* enable DISCHRG_VBUS_START interrupt */
+#define   nDISCHRG_VBUS_START_ENA  0x0       
+#define      DISCHRG_VBUS_END_ENA  0x20       /* enable DISCHRG_VBUS_END interrupt */
+#define     nDISCHRG_VBUS_END_ENA  0x0       
+
+/* Bit masks for USB_CSR0 */
+
+#define                  RXPKTRDY  0x1        /* data packet receive indicator */
+#define                 nRXPKTRDY  0x0       
+#define                  TXPKTRDY  0x2        /* data packet in FIFO indicator */
+#define                 nTXPKTRDY  0x0       
+#define                STALL_SENT  0x4        /* STALL handshake sent */
+#define               nSTALL_SENT  0x0       
+#define                   DATAEND  0x8        /* Data end indicator */
+#define                  nDATAEND  0x0       
+#define                  SETUPEND  0x10       /* Setup end */
+#define                 nSETUPEND  0x0       
+#define                 SENDSTALL  0x20       /* Send STALL handshake */
+#define                nSENDSTALL  0x0       
+#define         SERVICED_RXPKTRDY  0x40       /* used to clear the RxPktRdy bit */
+#define        nSERVICED_RXPKTRDY  0x0       
+#define         SERVICED_SETUPEND  0x80       /* used to clear the SetupEnd bit */
+#define        nSERVICED_SETUPEND  0x0       
+#define                 FLUSHFIFO  0x100      /* flush endpoint FIFO */
+#define                nFLUSHFIFO  0x0       
+#define          STALL_RECEIVED_H  0x4        /* STALL handshake received host mode */
+#define         nSTALL_RECEIVED_H  0x0       
+#define                SETUPPKT_H  0x8        /* send Setup token host mode */
+#define               nSETUPPKT_H  0x0       
+#define                   ERROR_H  0x10       /* timeout error indicator host mode */
+#define                  nERROR_H  0x0       
+#define                  REQPKT_H  0x20       /* Request an IN transaction host mode */
+#define                 nREQPKT_H  0x0       
+#define               STATUSPKT_H  0x40       /* Status stage transaction host mode */
+#define              nSTATUSPKT_H  0x0       
+#define             NAK_TIMEOUT_H  0x80       /* EP0 halted after a NAK host mode */
+#define            nNAK_TIMEOUT_H  0x0       
+
+/* Bit masks for USB_COUNT0 */
+
+#define              EP0_RX_COUNT  0x7f       /* number of received bytes in EP0 FIFO */
+
+/* Bit masks for USB_NAKLIMIT0 */
+
+#define             EP0_NAK_LIMIT  0x1f       /* number of frames/micro frames after which EP0 timeouts */
+
+/* Bit masks for USB_TX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_T  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_RX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_R  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_TXCSR */
+
+#define                TXPKTRDY_T  0x1        /* data packet in FIFO indicator */
+#define               nTXPKTRDY_T  0x0       
+#define          FIFO_NOT_EMPTY_T  0x2        /* FIFO not empty */
+#define         nFIFO_NOT_EMPTY_T  0x0       
+#define                UNDERRUN_T  0x4        /* TxPktRdy not set  for an IN token */
+#define               nUNDERRUN_T  0x0       
+#define               FLUSHFIFO_T  0x8        /* flush endpoint FIFO */
+#define              nFLUSHFIFO_T  0x0       
+#define              STALL_SEND_T  0x10       /* issue a Stall handshake */
+#define             nSTALL_SEND_T  0x0       
+#define              STALL_SENT_T  0x20       /* Stall handshake transmitted */
+#define             nSTALL_SENT_T  0x0       
+#define        CLEAR_DATATOGGLE_T  0x40       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_T  0x0       
+#define                INCOMPTX_T  0x80       /* indicates that a large packet is split */
+#define               nINCOMPTX_T  0x0       
+#define              DMAREQMODE_T  0x400      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_T  0x0       
+#define        FORCE_DATATOGGLE_T  0x800      /* Force data toggle */
+#define       nFORCE_DATATOGGLE_T  0x0       
+#define              DMAREQ_ENA_T  0x1000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_T  0x0       
+#define                     ISO_T  0x4000     /* enable Isochronous transfers */
+#define                    nISO_T  0x0       
+#define                 AUTOSET_T  0x8000     /* allows TxPktRdy to be set automatically */
+#define                nAUTOSET_T  0x0       
+#define                  ERROR_TH  0x4        /* error condition host mode */
+#define                 nERROR_TH  0x0       
+#define         STALL_RECEIVED_TH  0x20       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_TH  0x0       
+#define            NAK_TIMEOUT_TH  0x80       /* NAK timeout host mode */
+#define           nNAK_TIMEOUT_TH  0x0       
+
+/* Bit masks for USB_TXCOUNT */
+
+#define                  TX_COUNT  0x1fff     /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* Bit masks for USB_RXCSR */
+
+#define                RXPKTRDY_R  0x1        /* data packet in FIFO indicator */
+#define               nRXPKTRDY_R  0x0       
+#define               FIFO_FULL_R  0x2        /* FIFO not empty */
+#define              nFIFO_FULL_R  0x0       
+#define                 OVERRUN_R  0x4        /* TxPktRdy not set  for an IN token */
+#define                nOVERRUN_R  0x0       
+#define               DATAERROR_R  0x8        /* Out packet cannot be loaded into Rx  FIFO */
+#define              nDATAERROR_R  0x0       
+#define               FLUSHFIFO_R  0x10       /* flush endpoint FIFO */
+#define              nFLUSHFIFO_R  0x0       
+#define              STALL_SEND_R  0x20       /* issue a Stall handshake */
+#define             nSTALL_SEND_R  0x0       
+#define              STALL_SENT_R  0x40       /* Stall handshake transmitted */
+#define             nSTALL_SENT_R  0x0       
+#define        CLEAR_DATATOGGLE_R  0x80       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_R  0x0       
+#define                INCOMPRX_R  0x100      /* indicates that a large packet is split */
+#define               nINCOMPRX_R  0x0       
+#define              DMAREQMODE_R  0x800      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_R  0x0       
+#define                 DISNYET_R  0x1000     /* disable Nyet handshakes */
+#define                nDISNYET_R  0x0       
+#define              DMAREQ_ENA_R  0x2000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_R  0x0       
+#define                     ISO_R  0x4000     /* enable Isochronous transfers */
+#define                    nISO_R  0x0       
+#define               AUTOCLEAR_R  0x8000     /* allows TxPktRdy to be set automatically */
+#define              nAUTOCLEAR_R  0x0       
+#define                  ERROR_RH  0x4        /* TxPktRdy not set  for an IN token host mode */
+#define                 nERROR_RH  0x0       
+#define                 REQPKT_RH  0x20       /* request an IN transaction host mode */
+#define                nREQPKT_RH  0x0       
+#define         STALL_RECEIVED_RH  0x40       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_RH  0x0       
+#define               INCOMPRX_RH  0x100      /* indicates that a large packet is split host mode */
+#define              nINCOMPRX_RH  0x0       
+#define             DMAREQMODE_RH  0x800      /* DMA mode (0 or 1) selection host mode */
+#define            nDMAREQMODE_RH  0x0       
+#define                AUTOREQ_RH  0x4000     /* sets ReqPkt automatically host mode */
+#define               nAUTOREQ_RH  0x0       
+
+/* Bit masks for USB_RXCOUNT */
+
+#define                  RX_COUNT  0x1fff     /* Number of received bytes in the packet in the Rx FIFO */
+
+/* Bit masks for USB_TXTYPE */
+
+#define            TARGET_EP_NO_T  0xf        /* EP number */
+#define                PROTOCOL_T  0xc        /* transfer type */
+
+/* Bit masks for USB_TXINTERVAL */
+
+#define          TX_POLL_INTERVAL  0xff       /* polling interval for selected Tx EP */
+
+/* Bit masks for USB_RXTYPE */
+
+#define            TARGET_EP_NO_R  0xf        /* EP number */
+#define                PROTOCOL_R  0xc        /* transfer type */
+
+/* Bit masks for USB_RXINTERVAL */
+
+#define          RX_POLL_INTERVAL  0xff       /* polling interval for selected Rx EP */
+
+/* Bit masks for USB_DMA_INTERRUPT */
+
+#define                  DMA0_INT  0x1        /* DMA0 pending interrupt */
+#define                 nDMA0_INT  0x0       
+#define                  DMA1_INT  0x2        /* DMA1 pending interrupt */
+#define                 nDMA1_INT  0x0       
+#define                  DMA2_INT  0x4        /* DMA2 pending interrupt */
+#define                 nDMA2_INT  0x0       
+#define                  DMA3_INT  0x8        /* DMA3 pending interrupt */
+#define                 nDMA3_INT  0x0       
+#define                  DMA4_INT  0x10       /* DMA4 pending interrupt */
+#define                 nDMA4_INT  0x0       
+#define                  DMA5_INT  0x20       /* DMA5 pending interrupt */
+#define                 nDMA5_INT  0x0       
+#define                  DMA6_INT  0x40       /* DMA6 pending interrupt */
+#define                 nDMA6_INT  0x0       
+#define                  DMA7_INT  0x80       /* DMA7 pending interrupt */
+#define                 nDMA7_INT  0x0       
+
+/* Bit masks for USB_DMAxCONTROL */
+
+#define                   DMA_ENA  0x1        /* DMA enable */
+#define                  nDMA_ENA  0x0       
+#define                 DIRECTION  0x2        /* direction of DMA transfer */
+#define                nDIRECTION  0x0       
+#define                      MODE  0x4        /* DMA Bus error */
+#define                     nMODE  0x0       
+#define                   INT_ENA  0x8        /* Interrupt enable */
+#define                  nINT_ENA  0x0       
+#define                     EPNUM  0xf0       /* EP number */
+#define                  BUSERROR  0x100      /* DMA Bus error */
+#define                 nBUSERROR  0x0       
+
+/* Bit masks for USB_DMAxADDRHIGH */
+
+#define             DMA_ADDR_HIGH  0xffff     /* Upper 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxADDRLOW */
+
+#define              DMA_ADDR_LOW  0xffff     /* Lower 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTHIGH */
+
+#define            DMA_COUNT_HIGH  0xffff     /* Upper 16-bits of byte count of DMA transfer for DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTLOW */
+
+#define             DMA_COUNT_LOW  0xffff     /* Lower 16-bits of byte count of DMA transfer for DMA master channel */
+
+#endif /* _DEF_BF527_H */
diff --git a/include/asm-blackfin/mach-bf527/defBF52x_base.h b/include/asm-blackfin/mach-bf527/defBF52x_base.h
new file mode 100644
index 0000000..0b2fb50
--- /dev/null
+++ b/include/asm-blackfin/mach-bf527/defBF52x_base.h
@@ -0,0 +1,2009 @@
+/*
+ * File:         include/asm-blackfin/mach-bf527/defBF52x_base.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF52X_H
+#define _DEF_BF52X_H
+
+
+/* ************************************************************** */
+/*   SYSTEM & MMR ADDRESS DEFINITIONS COMMON TO ALL ADSP-BF52x    */
+/* ************************************************************** */
+
+/* ==== begin from defBF534.h ==== */
+
+/* Clock and System Control	(0xFFC00000 - 0xFFC000FF)								*/
+#define PLL_CTL				0xFFC00000	/* PLL Control Register						*/
+#define PLL_DIV				0xFFC00004	/* PLL Divide Register						*/
+#define VR_CTL				0xFFC00008	/* Voltage Regulator Control Register		*/
+#define PLL_STAT			0xFFC0000C	/* PLL Status Register						*/
+#define PLL_LOCKCNT			0xFFC00010	/* PLL Lock Count Register					*/
+#define CHIPID        0xFFC00014  /* Device ID Register */
+
+
+/* System Interrupt Controller (0xFFC00100 - 0xFFC001FF)							*/
+#define SWRST				0xFFC00100	/* Software Reset Register					*/
+#define SYSCR				0xFFC00104	/* System Configuration Register			*/
+#define SIC_RVECT			0xFFC00108	/* Interrupt Reset Vector Address Register	*/
+
+#define SIC_IMASK			0xFFC0010C	/* Interrupt Mask Register					*/
+#define SIC_IAR0			0xFFC00110	/* Interrupt Assignment Register 0			*/
+#define SIC_IAR1			0xFFC00114	/* Interrupt Assignment Register 1			*/
+#define SIC_IAR2			0xFFC00118	/* Interrupt Assignment Register 2			*/
+#define SIC_IAR3			0xFFC0011C	/* Interrupt Assignment Register 3			*/
+#define SIC_ISR				0xFFC00120	/* Interrupt Status Register				*/
+#define SIC_IWR				0xFFC00124	/* Interrupt Wakeup Register				*/
+
+/* SIC Additions to ADSP-BF52x (0xFFC0014C - 0xFFC00162) */
+#define SIC_IMASK1                      0xFFC0014C     /* Interrupt Mask register of SIC2 */
+#define SIC_IAR4                        0xFFC00150     /* Interrupt Assignment register4 */
+#define SIC_IAR5                        0xFFC00154     /* Interrupt Assignment register5 */
+#define SIC_IAR6                        0xFFC00158     /* Interrupt Assignment register6 */
+#define SIC_IAR7                        0xFFC0015C     /* Interrupt Assignment register7 */
+#define SIC_ISR1                        0xFFC00160     /* Interrupt Statur register */
+#define SIC_IWR1                        0xFFC00164     /* Interrupt Wakeup register */
+
+
+/* Watchdog Timer			(0xFFC00200 - 0xFFC002FF)								*/
+#define WDOG_CTL			0xFFC00200	/* Watchdog Control Register				*/
+#define WDOG_CNT			0xFFC00204	/* Watchdog Count Register					*/
+#define WDOG_STAT			0xFFC00208	/* Watchdog Status Register					*/
+
+
+/* Real Time Clock		(0xFFC00300 - 0xFFC003FF)									*/
+#define RTC_STAT			0xFFC00300	/* RTC Status Register						*/
+#define RTC_ICTL			0xFFC00304	/* RTC Interrupt Control Register			*/
+#define RTC_ISTAT			0xFFC00308	/* RTC Interrupt Status Register			*/
+#define RTC_SWCNT			0xFFC0030C	/* RTC Stopwatch Count Register				*/
+#define RTC_ALARM			0xFFC00310	/* RTC Alarm Time Register					*/
+#define RTC_FAST			0xFFC00314	/* RTC Prescaler Enable Register			*/
+#define RTC_PREN			0xFFC00314	/* RTC Prescaler Enable Alternate Macro		*/
+
+
+/* UART0 Controller		(0xFFC00400 - 0xFFC004FF)									*/
+#define UART0_THR			0xFFC00400	/* Transmit Holding register				*/
+#define UART0_RBR			0xFFC00400	/* Receive Buffer register					*/
+#define UART0_DLL			0xFFC00400	/* Divisor Latch (Low-Byte)					*/
+#define UART0_IER			0xFFC00404	/* Interrupt Enable Register				*/
+#define UART0_DLH			0xFFC00404	/* Divisor Latch (High-Byte)				*/
+#define UART0_IIR			0xFFC00408	/* Interrupt Identification Register		*/
+#define UART0_LCR			0xFFC0040C	/* Line Control Register					*/
+#define UART0_MCR			0xFFC00410	/* Modem Control Register					*/
+#define UART0_LSR			0xFFC00414	/* Line Status Register						*/
+#define UART0_MSR			0xFFC00418	/* Modem Status Register					*/
+#define UART0_SCR			0xFFC0041C	/* SCR Scratch Register						*/
+#define UART0_GCTL			0xFFC00424	/* Global Control Register					*/
+
+
+/* SPI Controller			(0xFFC00500 - 0xFFC005FF)								*/
+#define SPI_CTL				0xFFC00500	/* SPI Control Register						*/
+#define SPI_FLG				0xFFC00504	/* SPI Flag register						*/
+#define SPI_STAT			0xFFC00508	/* SPI Status register						*/
+#define SPI_TDBR			0xFFC0050C	/* SPI Transmit Data Buffer Register		*/
+#define SPI_RDBR			0xFFC00510	/* SPI Receive Data Buffer Register			*/
+#define SPI_BAUD			0xFFC00514	/* SPI Baud rate Register					*/
+#define SPI_SHADOW			0xFFC00518	/* SPI_RDBR Shadow Register					*/
+
+
+/* TIMER0-7 Registers		(0xFFC00600 - 0xFFC006FF)								*/
+#define TIMER0_CONFIG		0xFFC00600	/* Timer 0 Configuration Register			*/
+#define TIMER0_COUNTER		0xFFC00604	/* Timer 0 Counter Register					*/
+#define TIMER0_PERIOD		0xFFC00608	/* Timer 0 Period Register					*/
+#define TIMER0_WIDTH		0xFFC0060C	/* Timer 0 Width Register					*/
+
+#define TIMER1_CONFIG		0xFFC00610	/* Timer 1 Configuration Register  			*/
+#define TIMER1_COUNTER		0xFFC00614	/* Timer 1 Counter Register        			*/
+#define TIMER1_PERIOD		0xFFC00618	/* Timer 1 Period Register         			*/
+#define TIMER1_WIDTH		0xFFC0061C	/* Timer 1 Width Register          			*/
+
+#define TIMER2_CONFIG		0xFFC00620	/* Timer 2 Configuration Register  			*/
+#define TIMER2_COUNTER		0xFFC00624	/* Timer 2 Counter Register        			*/
+#define TIMER2_PERIOD		0xFFC00628	/* Timer 2 Period Register         			*/
+#define TIMER2_WIDTH		0xFFC0062C	/* Timer 2 Width Register          			*/
+
+#define TIMER3_CONFIG		0xFFC00630	/* Timer 3 Configuration Register			*/
+#define TIMER3_COUNTER		0xFFC00634	/* Timer 3 Counter Register					*/
+#define TIMER3_PERIOD		0xFFC00638	/* Timer 3 Period Register					*/
+#define TIMER3_WIDTH		0xFFC0063C	/* Timer 3 Width Register					*/
+
+#define TIMER4_CONFIG		0xFFC00640	/* Timer 4 Configuration Register  			*/
+#define TIMER4_COUNTER		0xFFC00644	/* Timer 4 Counter Register        			*/
+#define TIMER4_PERIOD		0xFFC00648	/* Timer 4 Period Register         			*/
+#define TIMER4_WIDTH		0xFFC0064C	/* Timer 4 Width Register          			*/
+
+#define TIMER5_CONFIG		0xFFC00650	/* Timer 5 Configuration Register  			*/
+#define TIMER5_COUNTER		0xFFC00654	/* Timer 5 Counter Register        			*/
+#define TIMER5_PERIOD		0xFFC00658	/* Timer 5 Period Register         			*/
+#define TIMER5_WIDTH		0xFFC0065C	/* Timer 5 Width Register          			*/
+
+#define TIMER6_CONFIG		0xFFC00660	/* Timer 6 Configuration Register  			*/
+#define TIMER6_COUNTER		0xFFC00664	/* Timer 6 Counter Register        			*/
+#define TIMER6_PERIOD		0xFFC00668	/* Timer 6 Period Register         			*/
+#define TIMER6_WIDTH		0xFFC0066C	/* Timer 6 Width Register          			*/
+
+#define TIMER7_CONFIG		0xFFC00670	/* Timer 7 Configuration Register  			*/
+#define TIMER7_COUNTER		0xFFC00674	/* Timer 7 Counter Register        			*/
+#define TIMER7_PERIOD		0xFFC00678	/* Timer 7 Period Register         			*/
+#define TIMER7_WIDTH		0xFFC0067C	/* Timer 7 Width Register       			*/   
+
+#define TIMER_ENABLE		0xFFC00680	/* Timer Enable Register					*/
+#define TIMER_DISABLE		0xFFC00684	/* Timer Disable Register					*/
+#define TIMER_STATUS		0xFFC00688	/* Timer Status Register					*/
+
+
+/* General Purpose I/O Port F (0xFFC00700 - 0xFFC007FF)												*/
+#define PORTFIO					0xFFC00700	/* Port F I/O Pin State Specify Register				*/
+#define PORTFIO_CLEAR			0xFFC00704	/* Port F I/O Peripheral Interrupt Clear Register		*/
+#define PORTFIO_SET				0xFFC00708	/* Port F I/O Peripheral Interrupt Set Register			*/
+#define PORTFIO_TOGGLE			0xFFC0070C	/* Port F I/O Pin State Toggle Register					*/
+#define PORTFIO_MASKA			0xFFC00710	/* Port F I/O Mask State Specify Interrupt A Register	*/
+#define PORTFIO_MASKA_CLEAR		0xFFC00714	/* Port F I/O Mask Disable Interrupt A Register			*/
+#define PORTFIO_MASKA_SET		0xFFC00718	/* Port F I/O Mask Enable Interrupt A Register			*/
+#define PORTFIO_MASKA_TOGGLE	0xFFC0071C	/* Port F I/O Mask Toggle Enable Interrupt A Register	*/
+#define PORTFIO_MASKB			0xFFC00720	/* Port F I/O Mask State Specify Interrupt B Register	*/
+#define PORTFIO_MASKB_CLEAR		0xFFC00724	/* Port F I/O Mask Disable Interrupt B Register			*/
+#define PORTFIO_MASKB_SET		0xFFC00728	/* Port F I/O Mask Enable Interrupt B Register			*/
+#define PORTFIO_MASKB_TOGGLE	0xFFC0072C	/* Port F I/O Mask Toggle Enable Interrupt B Register	*/
+#define PORTFIO_DIR				0xFFC00730	/* Port F I/O Direction Register						*/
+#define PORTFIO_POLAR			0xFFC00734	/* Port F I/O Source Polarity Register					*/
+#define PORTFIO_EDGE			0xFFC00738	/* Port F I/O Source Sensitivity Register				*/
+#define PORTFIO_BOTH			0xFFC0073C	/* Port F I/O Set on BOTH Edges Register				*/
+#define PORTFIO_INEN			0xFFC00740	/* Port F I/O Input Enable Register 					*/
+
+
+/* SPORT0 Controller		(0xFFC00800 - 0xFFC008FF)										*/
+#define SPORT0_TCR1			0xFFC00800	/* SPORT0 Transmit Configuration 1 Register			*/
+#define SPORT0_TCR2			0xFFC00804	/* SPORT0 Transmit Configuration 2 Register			*/
+#define SPORT0_TCLKDIV		0xFFC00808	/* SPORT0 Transmit Clock Divider					*/
+#define SPORT0_TFSDIV		0xFFC0080C	/* SPORT0 Transmit Frame Sync Divider				*/
+#define SPORT0_TX			0xFFC00810	/* SPORT0 TX Data Register							*/
+#define SPORT0_RX			0xFFC00818	/* SPORT0 RX Data Register							*/
+#define SPORT0_RCR1			0xFFC00820	/* SPORT0 Transmit Configuration 1 Register			*/
+#define SPORT0_RCR2			0xFFC00824	/* SPORT0 Transmit Configuration 2 Register			*/
+#define SPORT0_RCLKDIV		0xFFC00828	/* SPORT0 Receive Clock Divider						*/
+#define SPORT0_RFSDIV		0xFFC0082C	/* SPORT0 Receive Frame Sync Divider				*/
+#define SPORT0_STAT			0xFFC00830	/* SPORT0 Status Register							*/
+#define SPORT0_CHNL			0xFFC00834	/* SPORT0 Current Channel Register					*/
+#define SPORT0_MCMC1		0xFFC00838	/* SPORT0 Multi-Channel Configuration Register 1	*/
+#define SPORT0_MCMC2		0xFFC0083C	/* SPORT0 Multi-Channel Configuration Register 2	*/
+#define SPORT0_MTCS0		0xFFC00840	/* SPORT0 Multi-Channel Transmit Select Register 0	*/
+#define SPORT0_MTCS1		0xFFC00844	/* SPORT0 Multi-Channel Transmit Select Register 1	*/
+#define SPORT0_MTCS2		0xFFC00848	/* SPORT0 Multi-Channel Transmit Select Register 2	*/
+#define SPORT0_MTCS3		0xFFC0084C	/* SPORT0 Multi-Channel Transmit Select Register 3	*/
+#define SPORT0_MRCS0		0xFFC00850	/* SPORT0 Multi-Channel Receive Select Register 0	*/
+#define SPORT0_MRCS1		0xFFC00854	/* SPORT0 Multi-Channel Receive Select Register 1	*/
+#define SPORT0_MRCS2		0xFFC00858	/* SPORT0 Multi-Channel Receive Select Register 2	*/
+#define SPORT0_MRCS3		0xFFC0085C	/* SPORT0 Multi-Channel Receive Select Register 3	*/
+
+
+/* SPORT1 Controller		(0xFFC00900 - 0xFFC009FF)										*/
+#define SPORT1_TCR1			0xFFC00900	/* SPORT1 Transmit Configuration 1 Register			*/
+#define SPORT1_TCR2			0xFFC00904	/* SPORT1 Transmit Configuration 2 Register			*/
+#define SPORT1_TCLKDIV		0xFFC00908	/* SPORT1 Transmit Clock Divider					*/
+#define SPORT1_TFSDIV		0xFFC0090C	/* SPORT1 Transmit Frame Sync Divider				*/
+#define SPORT1_TX			0xFFC00910	/* SPORT1 TX Data Register							*/
+#define SPORT1_RX			0xFFC00918	/* SPORT1 RX Data Register							*/
+#define SPORT1_RCR1			0xFFC00920	/* SPORT1 Transmit Configuration 1 Register			*/
+#define SPORT1_RCR2			0xFFC00924	/* SPORT1 Transmit Configuration 2 Register			*/
+#define SPORT1_RCLKDIV		0xFFC00928	/* SPORT1 Receive Clock Divider						*/
+#define SPORT1_RFSDIV		0xFFC0092C	/* SPORT1 Receive Frame Sync Divider				*/
+#define SPORT1_STAT			0xFFC00930	/* SPORT1 Status Register							*/
+#define SPORT1_CHNL			0xFFC00934	/* SPORT1 Current Channel Register					*/
+#define SPORT1_MCMC1		0xFFC00938	/* SPORT1 Multi-Channel Configuration Register 1	*/
+#define SPORT1_MCMC2		0xFFC0093C	/* SPORT1 Multi-Channel Configuration Register 2	*/
+#define SPORT1_MTCS0		0xFFC00940	/* SPORT1 Multi-Channel Transmit Select Register 0	*/
+#define SPORT1_MTCS1		0xFFC00944	/* SPORT1 Multi-Channel Transmit Select Register 1	*/
+#define SPORT1_MTCS2		0xFFC00948	/* SPORT1 Multi-Channel Transmit Select Register 2	*/
+#define SPORT1_MTCS3		0xFFC0094C	/* SPORT1 Multi-Channel Transmit Select Register 3	*/
+#define SPORT1_MRCS0		0xFFC00950	/* SPORT1 Multi-Channel Receive Select Register 0	*/
+#define SPORT1_MRCS1		0xFFC00954	/* SPORT1 Multi-Channel Receive Select Register 1	*/
+#define SPORT1_MRCS2		0xFFC00958	/* SPORT1 Multi-Channel Receive Select Register 2	*/
+#define SPORT1_MRCS3		0xFFC0095C	/* SPORT1 Multi-Channel Receive Select Register 3	*/
+
+
+/* External Bus Interface Unit (0xFFC00A00 - 0xFFC00AFF)								*/
+#define EBIU_AMGCTL			0xFFC00A00	/* Asynchronous Memory Global Control Register	*/
+#define EBIU_AMBCTL0		0xFFC00A04	/* Asynchronous Memory Bank Control Register 0	*/
+#define EBIU_AMBCTL1		0xFFC00A08	/* Asynchronous Memory Bank Control Register 1	*/
+#define EBIU_SDGCTL			0xFFC00A10	/* SDRAM Global Control Register				*/
+#define EBIU_SDBCTL			0xFFC00A14	/* SDRAM Bank Control Register					*/
+#define EBIU_SDRRC			0xFFC00A18	/* SDRAM Refresh Rate Control Register			*/
+#define EBIU_SDSTAT			0xFFC00A1C	/* SDRAM Status Register						*/
+
+
+/* DMA Traffic Control Registers													*/
+#define DMA_TC_PER			0xFFC00B0C	/* Traffic Control Periods Register			*/
+#define DMA_TC_CNT			0xFFC00B10	/* Traffic Control Current Counts Register	*/
+
+/* Alternate deprecated register names (below) provided for backwards code compatibility */
+#define DMA_TCPER			0xFFC00B0C	/* Traffic Control Periods Register			*/
+#define DMA_TCCNT			0xFFC00B10	/* Traffic Control Current Counts Register	*/
+
+/* DMA Controller (0xFFC00C00 - 0xFFC00FFF)															*/
+#define DMA0_NEXT_DESC_PTR		0xFFC00C00	/* DMA Channel 0 Next Descriptor Pointer Register		*/
+#define DMA0_START_ADDR			0xFFC00C04	/* DMA Channel 0 Start Address Register					*/
+#define DMA0_CONFIG				0xFFC00C08	/* DMA Channel 0 Configuration Register					*/
+#define DMA0_X_COUNT			0xFFC00C10	/* DMA Channel 0 X Count Register						*/
+#define DMA0_X_MODIFY			0xFFC00C14	/* DMA Channel 0 X Modify Register						*/
+#define DMA0_Y_COUNT			0xFFC00C18	/* DMA Channel 0 Y Count Register						*/
+#define DMA0_Y_MODIFY			0xFFC00C1C	/* DMA Channel 0 Y Modify Register						*/
+#define DMA0_CURR_DESC_PTR		0xFFC00C20	/* DMA Channel 0 Current Descriptor Pointer Register	*/
+#define DMA0_CURR_ADDR			0xFFC00C24	/* DMA Channel 0 Current Address Register				*/
+#define DMA0_IRQ_STATUS			0xFFC00C28	/* DMA Channel 0 Interrupt/Status Register				*/
+#define DMA0_PERIPHERAL_MAP		0xFFC00C2C	/* DMA Channel 0 Peripheral Map Register				*/
+#define DMA0_CURR_X_COUNT		0xFFC00C30	/* DMA Channel 0 Current X Count Register				*/
+#define DMA0_CURR_Y_COUNT		0xFFC00C38	/* DMA Channel 0 Current Y Count Register				*/
+
+#define DMA1_NEXT_DESC_PTR		0xFFC00C40	/* DMA Channel 1 Next Descriptor Pointer Register		*/
+#define DMA1_START_ADDR			0xFFC00C44	/* DMA Channel 1 Start Address Register					*/
+#define DMA1_CONFIG				0xFFC00C48	/* DMA Channel 1 Configuration Register					*/
+#define DMA1_X_COUNT			0xFFC00C50	/* DMA Channel 1 X Count Register						*/
+#define DMA1_X_MODIFY			0xFFC00C54	/* DMA Channel 1 X Modify Register						*/
+#define DMA1_Y_COUNT			0xFFC00C58	/* DMA Channel 1 Y Count Register						*/
+#define DMA1_Y_MODIFY			0xFFC00C5C	/* DMA Channel 1 Y Modify Register						*/
+#define DMA1_CURR_DESC_PTR		0xFFC00C60	/* DMA Channel 1 Current Descriptor Pointer Register	*/
+#define DMA1_CURR_ADDR			0xFFC00C64	/* DMA Channel 1 Current Address Register				*/
+#define DMA1_IRQ_STATUS			0xFFC00C68	/* DMA Channel 1 Interrupt/Status Register				*/
+#define DMA1_PERIPHERAL_MAP		0xFFC00C6C	/* DMA Channel 1 Peripheral Map Register				*/
+#define DMA1_CURR_X_COUNT		0xFFC00C70	/* DMA Channel 1 Current X Count Register				*/
+#define DMA1_CURR_Y_COUNT		0xFFC00C78	/* DMA Channel 1 Current Y Count Register				*/
+
+#define DMA2_NEXT_DESC_PTR		0xFFC00C80	/* DMA Channel 2 Next Descriptor Pointer Register		*/
+#define DMA2_START_ADDR			0xFFC00C84	/* DMA Channel 2 Start Address Register					*/
+#define DMA2_CONFIG				0xFFC00C88	/* DMA Channel 2 Configuration Register					*/
+#define DMA2_X_COUNT			0xFFC00C90	/* DMA Channel 2 X Count Register						*/
+#define DMA2_X_MODIFY			0xFFC00C94	/* DMA Channel 2 X Modify Register						*/
+#define DMA2_Y_COUNT			0xFFC00C98	/* DMA Channel 2 Y Count Register						*/
+#define DMA2_Y_MODIFY			0xFFC00C9C	/* DMA Channel 2 Y Modify Register						*/
+#define DMA2_CURR_DESC_PTR		0xFFC00CA0	/* DMA Channel 2 Current Descriptor Pointer Register	*/
+#define DMA2_CURR_ADDR			0xFFC00CA4	/* DMA Channel 2 Current Address Register				*/
+#define DMA2_IRQ_STATUS			0xFFC00CA8	/* DMA Channel 2 Interrupt/Status Register				*/
+#define DMA2_PERIPHERAL_MAP		0xFFC00CAC	/* DMA Channel 2 Peripheral Map Register				*/
+#define DMA2_CURR_X_COUNT		0xFFC00CB0	/* DMA Channel 2 Current X Count Register				*/
+#define DMA2_CURR_Y_COUNT		0xFFC00CB8	/* DMA Channel 2 Current Y Count Register				*/
+
+#define DMA3_NEXT_DESC_PTR		0xFFC00CC0	/* DMA Channel 3 Next Descriptor Pointer Register		*/
+#define DMA3_START_ADDR			0xFFC00CC4	/* DMA Channel 3 Start Address Register					*/
+#define DMA3_CONFIG				0xFFC00CC8	/* DMA Channel 3 Configuration Register					*/
+#define DMA3_X_COUNT			0xFFC00CD0	/* DMA Channel 3 X Count Register						*/
+#define DMA3_X_MODIFY			0xFFC00CD4	/* DMA Channel 3 X Modify Register						*/
+#define DMA3_Y_COUNT			0xFFC00CD8	/* DMA Channel 3 Y Count Register						*/
+#define DMA3_Y_MODIFY			0xFFC00CDC	/* DMA Channel 3 Y Modify Register						*/
+#define DMA3_CURR_DESC_PTR		0xFFC00CE0	/* DMA Channel 3 Current Descriptor Pointer Register	*/
+#define DMA3_CURR_ADDR			0xFFC00CE4	/* DMA Channel 3 Current Address Register				*/
+#define DMA3_IRQ_STATUS			0xFFC00CE8	/* DMA Channel 3 Interrupt/Status Register				*/
+#define DMA3_PERIPHERAL_MAP		0xFFC00CEC	/* DMA Channel 3 Peripheral Map Register				*/
+#define DMA3_CURR_X_COUNT		0xFFC00CF0	/* DMA Channel 3 Current X Count Register				*/
+#define DMA3_CURR_Y_COUNT		0xFFC00CF8	/* DMA Channel 3 Current Y Count Register				*/
+
+#define DMA4_NEXT_DESC_PTR		0xFFC00D00	/* DMA Channel 4 Next Descriptor Pointer Register		*/
+#define DMA4_START_ADDR			0xFFC00D04	/* DMA Channel 4 Start Address Register					*/
+#define DMA4_CONFIG				0xFFC00D08	/* DMA Channel 4 Configuration Register					*/
+#define DMA4_X_COUNT			0xFFC00D10	/* DMA Channel 4 X Count Register						*/
+#define DMA4_X_MODIFY			0xFFC00D14	/* DMA Channel 4 X Modify Register						*/
+#define DMA4_Y_COUNT			0xFFC00D18	/* DMA Channel 4 Y Count Register						*/
+#define DMA4_Y_MODIFY			0xFFC00D1C	/* DMA Channel 4 Y Modify Register						*/
+#define DMA4_CURR_DESC_PTR		0xFFC00D20	/* DMA Channel 4 Current Descriptor Pointer Register	*/
+#define DMA4_CURR_ADDR			0xFFC00D24	/* DMA Channel 4 Current Address Register				*/
+#define DMA4_IRQ_STATUS			0xFFC00D28	/* DMA Channel 4 Interrupt/Status Register				*/
+#define DMA4_PERIPHERAL_MAP		0xFFC00D2C	/* DMA Channel 4 Peripheral Map Register				*/
+#define DMA4_CURR_X_COUNT		0xFFC00D30	/* DMA Channel 4 Current X Count Register				*/
+#define DMA4_CURR_Y_COUNT		0xFFC00D38	/* DMA Channel 4 Current Y Count Register				*/
+
+#define DMA5_NEXT_DESC_PTR		0xFFC00D40	/* DMA Channel 5 Next Descriptor Pointer Register		*/
+#define DMA5_START_ADDR			0xFFC00D44	/* DMA Channel 5 Start Address Register					*/
+#define DMA5_CONFIG				0xFFC00D48	/* DMA Channel 5 Configuration Register					*/
+#define DMA5_X_COUNT			0xFFC00D50	/* DMA Channel 5 X Count Register						*/
+#define DMA5_X_MODIFY			0xFFC00D54	/* DMA Channel 5 X Modify Register						*/
+#define DMA5_Y_COUNT			0xFFC00D58	/* DMA Channel 5 Y Count Register						*/
+#define DMA5_Y_MODIFY			0xFFC00D5C	/* DMA Channel 5 Y Modify Register						*/
+#define DMA5_CURR_DESC_PTR		0xFFC00D60	/* DMA Channel 5 Current Descriptor Pointer Register	*/
+#define DMA5_CURR_ADDR			0xFFC00D64	/* DMA Channel 5 Current Address Register				*/
+#define DMA5_IRQ_STATUS			0xFFC00D68	/* DMA Channel 5 Interrupt/Status Register				*/
+#define DMA5_PERIPHERAL_MAP		0xFFC00D6C	/* DMA Channel 5 Peripheral Map Register				*/
+#define DMA5_CURR_X_COUNT		0xFFC00D70	/* DMA Channel 5 Current X Count Register				*/
+#define DMA5_CURR_Y_COUNT		0xFFC00D78	/* DMA Channel 5 Current Y Count Register				*/
+
+#define DMA6_NEXT_DESC_PTR		0xFFC00D80	/* DMA Channel 6 Next Descriptor Pointer Register		*/
+#define DMA6_START_ADDR			0xFFC00D84	/* DMA Channel 6 Start Address Register					*/
+#define DMA6_CONFIG				0xFFC00D88	/* DMA Channel 6 Configuration Register					*/
+#define DMA6_X_COUNT			0xFFC00D90	/* DMA Channel 6 X Count Register						*/
+#define DMA6_X_MODIFY			0xFFC00D94	/* DMA Channel 6 X Modify Register						*/
+#define DMA6_Y_COUNT			0xFFC00D98	/* DMA Channel 6 Y Count Register						*/
+#define DMA6_Y_MODIFY			0xFFC00D9C	/* DMA Channel 6 Y Modify Register						*/
+#define DMA6_CURR_DESC_PTR		0xFFC00DA0	/* DMA Channel 6 Current Descriptor Pointer Register	*/
+#define DMA6_CURR_ADDR			0xFFC00DA4	/* DMA Channel 6 Current Address Register				*/
+#define DMA6_IRQ_STATUS			0xFFC00DA8	/* DMA Channel 6 Interrupt/Status Register				*/
+#define DMA6_PERIPHERAL_MAP		0xFFC00DAC	/* DMA Channel 6 Peripheral Map Register				*/
+#define DMA6_CURR_X_COUNT		0xFFC00DB0	/* DMA Channel 6 Current X Count Register				*/
+#define DMA6_CURR_Y_COUNT		0xFFC00DB8	/* DMA Channel 6 Current Y Count Register				*/
+
+#define DMA7_NEXT_DESC_PTR		0xFFC00DC0	/* DMA Channel 7 Next Descriptor Pointer Register		*/
+#define DMA7_START_ADDR			0xFFC00DC4	/* DMA Channel 7 Start Address Register					*/
+#define DMA7_CONFIG				0xFFC00DC8	/* DMA Channel 7 Configuration Register					*/
+#define DMA7_X_COUNT			0xFFC00DD0	/* DMA Channel 7 X Count Register						*/
+#define DMA7_X_MODIFY			0xFFC00DD4	/* DMA Channel 7 X Modify Register						*/
+#define DMA7_Y_COUNT			0xFFC00DD8	/* DMA Channel 7 Y Count Register						*/
+#define DMA7_Y_MODIFY			0xFFC00DDC	/* DMA Channel 7 Y Modify Register						*/
+#define DMA7_CURR_DESC_PTR		0xFFC00DE0	/* DMA Channel 7 Current Descriptor Pointer Register	*/
+#define DMA7_CURR_ADDR			0xFFC00DE4	/* DMA Channel 7 Current Address Register				*/
+#define DMA7_IRQ_STATUS			0xFFC00DE8	/* DMA Channel 7 Interrupt/Status Register				*/
+#define DMA7_PERIPHERAL_MAP		0xFFC00DEC	/* DMA Channel 7 Peripheral Map Register				*/
+#define DMA7_CURR_X_COUNT		0xFFC00DF0	/* DMA Channel 7 Current X Count Register				*/
+#define DMA7_CURR_Y_COUNT		0xFFC00DF8	/* DMA Channel 7 Current Y Count Register				*/
+
+#define DMA8_NEXT_DESC_PTR		0xFFC00E00	/* DMA Channel 8 Next Descriptor Pointer Register		*/
+#define DMA8_START_ADDR			0xFFC00E04	/* DMA Channel 8 Start Address Register					*/
+#define DMA8_CONFIG				0xFFC00E08	/* DMA Channel 8 Configuration Register					*/
+#define DMA8_X_COUNT			0xFFC00E10	/* DMA Channel 8 X Count Register						*/
+#define DMA8_X_MODIFY			0xFFC00E14	/* DMA Channel 8 X Modify Register						*/
+#define DMA8_Y_COUNT			0xFFC00E18	/* DMA Channel 8 Y Count Register						*/
+#define DMA8_Y_MODIFY			0xFFC00E1C	/* DMA Channel 8 Y Modify Register						*/
+#define DMA8_CURR_DESC_PTR		0xFFC00E20	/* DMA Channel 8 Current Descriptor Pointer Register	*/
+#define DMA8_CURR_ADDR			0xFFC00E24	/* DMA Channel 8 Current Address Register				*/
+#define DMA8_IRQ_STATUS			0xFFC00E28	/* DMA Channel 8 Interrupt/Status Register				*/
+#define DMA8_PERIPHERAL_MAP		0xFFC00E2C	/* DMA Channel 8 Peripheral Map Register				*/
+#define DMA8_CURR_X_COUNT		0xFFC00E30	/* DMA Channel 8 Current X Count Register				*/
+#define DMA8_CURR_Y_COUNT		0xFFC00E38	/* DMA Channel 8 Current Y Count Register				*/
+
+#define DMA9_NEXT_DESC_PTR		0xFFC00E40	/* DMA Channel 9 Next Descriptor Pointer Register		*/
+#define DMA9_START_ADDR			0xFFC00E44	/* DMA Channel 9 Start Address Register					*/
+#define DMA9_CONFIG				0xFFC00E48	/* DMA Channel 9 Configuration Register					*/
+#define DMA9_X_COUNT			0xFFC00E50	/* DMA Channel 9 X Count Register						*/
+#define DMA9_X_MODIFY			0xFFC00E54	/* DMA Channel 9 X Modify Register						*/
+#define DMA9_Y_COUNT			0xFFC00E58	/* DMA Channel 9 Y Count Register						*/
+#define DMA9_Y_MODIFY			0xFFC00E5C	/* DMA Channel 9 Y Modify Register						*/
+#define DMA9_CURR_DESC_PTR		0xFFC00E60	/* DMA Channel 9 Current Descriptor Pointer Register	*/
+#define DMA9_CURR_ADDR			0xFFC00E64	/* DMA Channel 9 Current Address Register				*/
+#define DMA9_IRQ_STATUS			0xFFC00E68	/* DMA Channel 9 Interrupt/Status Register				*/
+#define DMA9_PERIPHERAL_MAP		0xFFC00E6C	/* DMA Channel 9 Peripheral Map Register				*/
+#define DMA9_CURR_X_COUNT		0xFFC00E70	/* DMA Channel 9 Current X Count Register				*/
+#define DMA9_CURR_Y_COUNT		0xFFC00E78	/* DMA Channel 9 Current Y Count Register				*/
+
+#define DMA10_NEXT_DESC_PTR		0xFFC00E80	/* DMA Channel 10 Next Descriptor Pointer Register		*/
+#define DMA10_START_ADDR		0xFFC00E84	/* DMA Channel 10 Start Address Register				*/
+#define DMA10_CONFIG			0xFFC00E88	/* DMA Channel 10 Configuration Register				*/
+#define DMA10_X_COUNT			0xFFC00E90	/* DMA Channel 10 X Count Register						*/
+#define DMA10_X_MODIFY			0xFFC00E94	/* DMA Channel 10 X Modify Register						*/
+#define DMA10_Y_COUNT			0xFFC00E98	/* DMA Channel 10 Y Count Register						*/
+#define DMA10_Y_MODIFY			0xFFC00E9C	/* DMA Channel 10 Y Modify Register						*/
+#define DMA10_CURR_DESC_PTR		0xFFC00EA0	/* DMA Channel 10 Current Descriptor Pointer Register	*/
+#define DMA10_CURR_ADDR			0xFFC00EA4	/* DMA Channel 10 Current Address Register				*/
+#define DMA10_IRQ_STATUS		0xFFC00EA8	/* DMA Channel 10 Interrupt/Status Register				*/
+#define DMA10_PERIPHERAL_MAP	0xFFC00EAC	/* DMA Channel 10 Peripheral Map Register				*/
+#define DMA10_CURR_X_COUNT		0xFFC00EB0	/* DMA Channel 10 Current X Count Register				*/
+#define DMA10_CURR_Y_COUNT		0xFFC00EB8	/* DMA Channel 10 Current Y Count Register				*/
+
+#define DMA11_NEXT_DESC_PTR		0xFFC00EC0	/* DMA Channel 11 Next Descriptor Pointer Register		*/
+#define DMA11_START_ADDR		0xFFC00EC4	/* DMA Channel 11 Start Address Register				*/
+#define DMA11_CONFIG			0xFFC00EC8	/* DMA Channel 11 Configuration Register				*/
+#define DMA11_X_COUNT			0xFFC00ED0	/* DMA Channel 11 X Count Register						*/
+#define DMA11_X_MODIFY			0xFFC00ED4	/* DMA Channel 11 X Modify Register						*/
+#define DMA11_Y_COUNT			0xFFC00ED8	/* DMA Channel 11 Y Count Register						*/
+#define DMA11_Y_MODIFY			0xFFC00EDC	/* DMA Channel 11 Y Modify Register						*/
+#define DMA11_CURR_DESC_PTR		0xFFC00EE0	/* DMA Channel 11 Current Descriptor Pointer Register	*/
+#define DMA11_CURR_ADDR			0xFFC00EE4	/* DMA Channel 11 Current Address Register				*/
+#define DMA11_IRQ_STATUS		0xFFC00EE8	/* DMA Channel 11 Interrupt/Status Register				*/
+#define DMA11_PERIPHERAL_MAP	0xFFC00EEC	/* DMA Channel 11 Peripheral Map Register				*/
+#define DMA11_CURR_X_COUNT		0xFFC00EF0	/* DMA Channel 11 Current X Count Register				*/
+#define DMA11_CURR_Y_COUNT		0xFFC00EF8	/* DMA Channel 11 Current Y Count Register				*/
+
+#define MDMA_D0_NEXT_DESC_PTR	0xFFC00F00	/* MemDMA Stream 0 Destination Next Descriptor Pointer Register		*/
+#define MDMA_D0_START_ADDR		0xFFC00F04	/* MemDMA Stream 0 Destination Start Address Register				*/
+#define MDMA_D0_CONFIG			0xFFC00F08	/* MemDMA Stream 0 Destination Configuration Register				*/
+#define MDMA_D0_X_COUNT			0xFFC00F10	/* MemDMA Stream 0 Destination X Count Register						*/
+#define MDMA_D0_X_MODIFY		0xFFC00F14	/* MemDMA Stream 0 Destination X Modify Register					*/
+#define MDMA_D0_Y_COUNT			0xFFC00F18	/* MemDMA Stream 0 Destination Y Count Register						*/
+#define MDMA_D0_Y_MODIFY		0xFFC00F1C	/* MemDMA Stream 0 Destination Y Modify Register					*/
+#define MDMA_D0_CURR_DESC_PTR	0xFFC00F20	/* MemDMA Stream 0 Destination Current Descriptor Pointer Register	*/
+#define MDMA_D0_CURR_ADDR		0xFFC00F24	/* MemDMA Stream 0 Destination Current Address Register				*/
+#define MDMA_D0_IRQ_STATUS		0xFFC00F28	/* MemDMA Stream 0 Destination Interrupt/Status Register			*/
+#define MDMA_D0_PERIPHERAL_MAP	0xFFC00F2C	/* MemDMA Stream 0 Destination Peripheral Map Register				*/
+#define MDMA_D0_CURR_X_COUNT	0xFFC00F30	/* MemDMA Stream 0 Destination Current X Count Register				*/
+#define MDMA_D0_CURR_Y_COUNT	0xFFC00F38	/* MemDMA Stream 0 Destination Current Y Count Register				*/
+
+#define MDMA_S0_NEXT_DESC_PTR	0xFFC00F40	/* MemDMA Stream 0 Source Next Descriptor Pointer Register			*/
+#define MDMA_S0_START_ADDR		0xFFC00F44	/* MemDMA Stream 0 Source Start Address Register					*/
+#define MDMA_S0_CONFIG			0xFFC00F48	/* MemDMA Stream 0 Source Configuration Register					*/
+#define MDMA_S0_X_COUNT			0xFFC00F50	/* MemDMA Stream 0 Source X Count Register							*/
+#define MDMA_S0_X_MODIFY		0xFFC00F54	/* MemDMA Stream 0 Source X Modify Register							*/
+#define MDMA_S0_Y_COUNT			0xFFC00F58	/* MemDMA Stream 0 Source Y Count Register							*/
+#define MDMA_S0_Y_MODIFY		0xFFC00F5C	/* MemDMA Stream 0 Source Y Modify Register							*/
+#define MDMA_S0_CURR_DESC_PTR	0xFFC00F60	/* MemDMA Stream 0 Source Current Descriptor Pointer Register		*/
+#define MDMA_S0_CURR_ADDR		0xFFC00F64	/* MemDMA Stream 0 Source Current Address Register					*/
+#define MDMA_S0_IRQ_STATUS		0xFFC00F68	/* MemDMA Stream 0 Source Interrupt/Status Register					*/
+#define MDMA_S0_PERIPHERAL_MAP	0xFFC00F6C	/* MemDMA Stream 0 Source Peripheral Map Register					*/
+#define MDMA_S0_CURR_X_COUNT	0xFFC00F70	/* MemDMA Stream 0 Source Current X Count Register					*/
+#define MDMA_S0_CURR_Y_COUNT	0xFFC00F78	/* MemDMA Stream 0 Source Current Y Count Register					*/
+
+#define MDMA_D1_NEXT_DESC_PTR	0xFFC00F80	/* MemDMA Stream 1 Destination Next Descriptor Pointer Register		*/
+#define MDMA_D1_START_ADDR		0xFFC00F84	/* MemDMA Stream 1 Destination Start Address Register				*/
+#define MDMA_D1_CONFIG			0xFFC00F88	/* MemDMA Stream 1 Destination Configuration Register				*/
+#define MDMA_D1_X_COUNT			0xFFC00F90	/* MemDMA Stream 1 Destination X Count Register						*/
+#define MDMA_D1_X_MODIFY		0xFFC00F94	/* MemDMA Stream 1 Destination X Modify Register					*/
+#define MDMA_D1_Y_COUNT			0xFFC00F98	/* MemDMA Stream 1 Destination Y Count Register						*/
+#define MDMA_D1_Y_MODIFY		0xFFC00F9C	/* MemDMA Stream 1 Destination Y Modify Register					*/
+#define MDMA_D1_CURR_DESC_PTR	0xFFC00FA0	/* MemDMA Stream 1 Destination Current Descriptor Pointer Register	*/
+#define MDMA_D1_CURR_ADDR		0xFFC00FA4	/* MemDMA Stream 1 Destination Current Address Register				*/
+#define MDMA_D1_IRQ_STATUS		0xFFC00FA8	/* MemDMA Stream 1 Destination Interrupt/Status Register			*/
+#define MDMA_D1_PERIPHERAL_MAP	0xFFC00FAC	/* MemDMA Stream 1 Destination Peripheral Map Register				*/
+#define MDMA_D1_CURR_X_COUNT	0xFFC00FB0	/* MemDMA Stream 1 Destination Current X Count Register				*/
+#define MDMA_D1_CURR_Y_COUNT	0xFFC00FB8	/* MemDMA Stream 1 Destination Current Y Count Register				*/
+
+#define MDMA_S1_NEXT_DESC_PTR	0xFFC00FC0	/* MemDMA Stream 1 Source Next Descriptor Pointer Register			*/
+#define MDMA_S1_START_ADDR		0xFFC00FC4	/* MemDMA Stream 1 Source Start Address Register					*/
+#define MDMA_S1_CONFIG			0xFFC00FC8	/* MemDMA Stream 1 Source Configuration Register					*/
+#define MDMA_S1_X_COUNT			0xFFC00FD0	/* MemDMA Stream 1 Source X Count Register							*/
+#define MDMA_S1_X_MODIFY		0xFFC00FD4	/* MemDMA Stream 1 Source X Modify Register							*/
+#define MDMA_S1_Y_COUNT			0xFFC00FD8	/* MemDMA Stream 1 Source Y Count Register							*/
+#define MDMA_S1_Y_MODIFY		0xFFC00FDC	/* MemDMA Stream 1 Source Y Modify Register							*/
+#define MDMA_S1_CURR_DESC_PTR	0xFFC00FE0	/* MemDMA Stream 1 Source Current Descriptor Pointer Register		*/
+#define MDMA_S1_CURR_ADDR		0xFFC00FE4	/* MemDMA Stream 1 Source Current Address Register					*/
+#define MDMA_S1_IRQ_STATUS		0xFFC00FE8	/* MemDMA Stream 1 Source Interrupt/Status Register					*/
+#define MDMA_S1_PERIPHERAL_MAP	0xFFC00FEC	/* MemDMA Stream 1 Source Peripheral Map Register					*/
+#define MDMA_S1_CURR_X_COUNT	0xFFC00FF0	/* MemDMA Stream 1 Source Current X Count Register					*/
+#define MDMA_S1_CURR_Y_COUNT	0xFFC00FF8	/* MemDMA Stream 1 Source Current Y Count Register					*/
+
+
+/* Parallel Peripheral Interface (0xFFC01000 - 0xFFC010FF)				*/
+#define PPI_CONTROL			0xFFC01000	/* PPI Control Register			*/
+#define PPI_STATUS			0xFFC01004	/* PPI Status Register			*/
+#define PPI_COUNT			0xFFC01008	/* PPI Transfer Count Register	*/
+#define PPI_DELAY			0xFFC0100C	/* PPI Delay Count Register		*/
+#define PPI_FRAME			0xFFC01010	/* PPI Frame Length Register	*/
+
+
+/* Two-Wire Interface		(0xFFC01400 - 0xFFC014FF)								*/
+#define TWI_CLKDIV			0xFFC01400	/* Serial Clock Divider Register			*/
+#define TWI_CONTROL			0xFFC01404	/* TWI Control Register						*/
+#define TWI_SLAVE_CTL		0xFFC01408	/* Slave Mode Control Register				*/
+#define TWI_SLAVE_STAT		0xFFC0140C	/* Slave Mode Status Register				*/
+#define TWI_SLAVE_ADDR		0xFFC01410	/* Slave Mode Address Register				*/
+#define TWI_MASTER_CTL		0xFFC01414	/* Master Mode Control Register				*/
+#define TWI_MASTER_STAT		0xFFC01418	/* Master Mode Status Register				*/
+#define TWI_MASTER_ADDR		0xFFC0141C	/* Master Mode Address Register				*/
+#define TWI_INT_STAT		0xFFC01420	/* TWI Interrupt Status Register			*/
+#define TWI_INT_MASK		0xFFC01424	/* TWI Master Interrupt Mask Register		*/
+#define TWI_FIFO_CTL		0xFFC01428	/* FIFO Control Register					*/
+#define TWI_FIFO_STAT		0xFFC0142C	/* FIFO Status Register						*/
+#define TWI_XMT_DATA8		0xFFC01480	/* FIFO Transmit Data Single Byte Register	*/
+#define TWI_XMT_DATA16		0xFFC01484	/* FIFO Transmit Data Double Byte Register	*/
+#define TWI_RCV_DATA8		0xFFC01488	/* FIFO Receive Data Single Byte Register	*/
+#define TWI_RCV_DATA16		0xFFC0148C	/* FIFO Receive Data Double Byte Register	*/
+
+
+/* General Purpose I/O Port G (0xFFC01500 - 0xFFC015FF)												*/
+#define PORTGIO					0xFFC01500	/* Port G I/O Pin State Specify Register				*/
+#define PORTGIO_CLEAR			0xFFC01504	/* Port G I/O Peripheral Interrupt Clear Register		*/
+#define PORTGIO_SET				0xFFC01508	/* Port G I/O Peripheral Interrupt Set Register			*/
+#define PORTGIO_TOGGLE			0xFFC0150C	/* Port G I/O Pin State Toggle Register					*/
+#define PORTGIO_MASKA			0xFFC01510	/* Port G I/O Mask State Specify Interrupt A Register	*/
+#define PORTGIO_MASKA_CLEAR		0xFFC01514	/* Port G I/O Mask Disable Interrupt A Register			*/
+#define PORTGIO_MASKA_SET		0xFFC01518	/* Port G I/O Mask Enable Interrupt A Register			*/
+#define PORTGIO_MASKA_TOGGLE	0xFFC0151C	/* Port G I/O Mask Toggle Enable Interrupt A Register	*/
+#define PORTGIO_MASKB			0xFFC01520	/* Port G I/O Mask State Specify Interrupt B Register	*/
+#define PORTGIO_MASKB_CLEAR		0xFFC01524	/* Port G I/O Mask Disable Interrupt B Register			*/
+#define PORTGIO_MASKB_SET		0xFFC01528	/* Port G I/O Mask Enable Interrupt B Register			*/
+#define PORTGIO_MASKB_TOGGLE	0xFFC0152C	/* Port G I/O Mask Toggle Enable Interrupt B Register	*/
+#define PORTGIO_DIR				0xFFC01530	/* Port G I/O Direction Register						*/
+#define PORTGIO_POLAR			0xFFC01534	/* Port G I/O Source Polarity Register					*/
+#define PORTGIO_EDGE			0xFFC01538	/* Port G I/O Source Sensitivity Register				*/
+#define PORTGIO_BOTH			0xFFC0153C	/* Port G I/O Set on BOTH Edges Register				*/
+#define PORTGIO_INEN			0xFFC01540	/* Port G I/O Input Enable Register						*/
+
+
+/* General Purpose I/O Port H (0xFFC01700 - 0xFFC017FF)												*/
+#define PORTHIO					0xFFC01700	/* Port H I/O Pin State Specify Register				*/
+#define PORTHIO_CLEAR			0xFFC01704	/* Port H I/O Peripheral Interrupt Clear Register		*/
+#define PORTHIO_SET				0xFFC01708	/* Port H I/O Peripheral Interrupt Set Register			*/
+#define PORTHIO_TOGGLE			0xFFC0170C	/* Port H I/O Pin State Toggle Register					*/
+#define PORTHIO_MASKA			0xFFC01710	/* Port H I/O Mask State Specify Interrupt A Register	*/
+#define PORTHIO_MASKA_CLEAR		0xFFC01714	/* Port H I/O Mask Disable Interrupt A Register			*/
+#define PORTHIO_MASKA_SET		0xFFC01718	/* Port H I/O Mask Enable Interrupt A Register			*/
+#define PORTHIO_MASKA_TOGGLE	0xFFC0171C	/* Port H I/O Mask Toggle Enable Interrupt A Register	*/
+#define PORTHIO_MASKB			0xFFC01720	/* Port H I/O Mask State Specify Interrupt B Register	*/
+#define PORTHIO_MASKB_CLEAR		0xFFC01724	/* Port H I/O Mask Disable Interrupt B Register			*/
+#define PORTHIO_MASKB_SET		0xFFC01728	/* Port H I/O Mask Enable Interrupt B Register			*/
+#define PORTHIO_MASKB_TOGGLE	0xFFC0172C	/* Port H I/O Mask Toggle Enable Interrupt B Register	*/
+#define PORTHIO_DIR				0xFFC01730	/* Port H I/O Direction Register						*/
+#define PORTHIO_POLAR			0xFFC01734	/* Port H I/O Source Polarity Register					*/
+#define PORTHIO_EDGE			0xFFC01738	/* Port H I/O Source Sensitivity Register				*/
+#define PORTHIO_BOTH			0xFFC0173C	/* Port H I/O Set on BOTH Edges Register				*/
+#define PORTHIO_INEN			0xFFC01740	/* Port H I/O Input Enable Register						*/
+
+
+/* UART1 Controller		(0xFFC02000 - 0xFFC020FF)								*/
+#define UART1_THR			0xFFC02000	/* Transmit Holding register			*/
+#define UART1_RBR			0xFFC02000	/* Receive Buffer register				*/
+#define UART1_DLL			0xFFC02000	/* Divisor Latch (Low-Byte)				*/
+#define UART1_IER			0xFFC02004	/* Interrupt Enable Register			*/
+#define UART1_DLH			0xFFC02004	/* Divisor Latch (High-Byte)			*/
+#define UART1_IIR			0xFFC02008	/* Interrupt Identification Register	*/
+#define UART1_LCR			0xFFC0200C	/* Line Control Register				*/
+#define UART1_MCR			0xFFC02010	/* Modem Control Register				*/
+#define UART1_LSR			0xFFC02014	/* Line Status Register					*/
+#define UART1_MSR			0xFFC02018	/* Modem Status Register				*/
+#define UART1_SCR			0xFFC0201C	/* SCR Scratch Register					*/
+#define UART1_GCTL			0xFFC02024	/* Global Control Register				*/
+
+
+/* Omit CAN register sets from the defBF534.h (CAN is not in the ADSP-BF52x processor) */
+
+/* Pin Control Registers	(0xFFC03200 - 0xFFC032FF)											*/
+#define PORTF_FER			0xFFC03200	/* Port F Function Enable Register (Alternate/Flag*)	*/
+#define PORTG_FER			0xFFC03204	/* Port G Function Enable Register (Alternate/Flag*)	*/
+#define PORTH_FER			0xFFC03208	/* Port H Function Enable Register (Alternate/Flag*)	*/
+#define BFIN_PORT_MUX			0xFFC0320C	/* Port Multiplexer Control Register					*/
+
+
+/* Handshake MDMA Registers	(0xFFC03300 - 0xFFC033FF)										*/
+#define HMDMA0_CONTROL		0xFFC03300	/* Handshake MDMA0 Control Register					*/
+#define HMDMA0_ECINIT		0xFFC03304	/* HMDMA0 Initial Edge Count Register				*/
+#define HMDMA0_BCINIT		0xFFC03308	/* HMDMA0 Initial Block Count Register				*/
+#define HMDMA0_ECURGENT		0xFFC0330C	/* HMDMA0 Urgent Edge Count Threshhold Register		*/
+#define HMDMA0_ECOVERFLOW	0xFFC03310	/* HMDMA0 Edge Count Overflow Interrupt Register	*/
+#define HMDMA0_ECOUNT		0xFFC03314	/* HMDMA0 Current Edge Count Register				*/
+#define HMDMA0_BCOUNT		0xFFC03318	/* HMDMA0 Current Block Count Register				*/
+
+#define HMDMA1_CONTROL		0xFFC03340	/* Handshake MDMA1 Control Register					*/
+#define HMDMA1_ECINIT		0xFFC03344	/* HMDMA1 Initial Edge Count Register				*/
+#define HMDMA1_BCINIT		0xFFC03348	/* HMDMA1 Initial Block Count Register				*/
+#define HMDMA1_ECURGENT		0xFFC0334C	/* HMDMA1 Urgent Edge Count Threshhold Register		*/
+#define HMDMA1_ECOVERFLOW	0xFFC03350	/* HMDMA1 Edge Count Overflow Interrupt Register	*/
+#define HMDMA1_ECOUNT		0xFFC03354	/* HMDMA1 Current Edge Count Register				*/
+#define HMDMA1_BCOUNT		0xFFC03358	/* HMDMA1 Current Block Count Register				*/
+
+/* GPIO PIN mux (0xFFC03210 - OxFFC03288) */
+#define PORTF_MUX               0xFFC03210      /* Port F mux control */
+#define PORTG_MUX               0xFFC03214      /* Port G mux control */
+#define PORTH_MUX               0xFFC03218      /* Port H mux control */
+#define PORTF_DRIVE             0xFFC03220      /* Port F drive strength control */
+#define PORTG_DRIVE             0xFFC03224      /* Port G drive strength control */
+#define PORTH_DRIVE             0xFFC03228      /* Port H drive strength control */
+#define PORTF_SLEW              0xFFC03230      /* Port F slew control */
+#define PORTG_SLEW              0xFFC03234      /* Port G slew control */
+#define PORTH_SLEW              0xFFC03238      /* Port H slew control */
+#define PORTF_HYSTERISIS        0xFFC03240      /* Port F Schmitt trigger control */
+#define PORTG_HYSTERISIS        0xFFC03244      /* Port G Schmitt trigger control */
+#define PORTH_HYSTERISIS        0xFFC03248      /* Port H Schmitt trigger control */
+#define MISCPORT_DRIVE          0xFFC03280      /* Misc Port drive strength control */
+#define MISCPORT_SLEW           0xFFC03284      /* Misc Port slew control */
+#define MISCPORT_HYSTERISIS     0xFFC03288      /* Misc Port Schmitt trigger control */
+
+
+/***********************************************************************************
+** System MMR Register Bits And Macros
+**
+** Disclaimer:	All macros are intended to make C and Assembly code more readable.
+**				Use these macros carefully, as any that do left shifts for field
+**				depositing will result in the lower order bits being destroyed.  Any
+**				macro that shifts left to properly position the bit-field should be
+**				used as part of an OR to initialize a register and NOT as a dynamic
+**				modifier UNLESS the lower order bits are saved and ORed back in when
+**				the macro is used.
+*************************************************************************************/
+/*
+** ********************* PLL AND RESET MASKS ****************************************/
+/* PLL_CTL Masks																	*/
+#define DF				0x0001	/* 0: PLL = CLKIN, 1: PLL = CLKIN/2					*/
+#define PLL_OFF			0x0002	/* PLL Not Powered									*/
+#define STOPCK			0x0008	/* Core Clock Off									*/
+#define PDWN			0x0020	/* Enter Deep Sleep Mode							*/
+#define	IN_DELAY		0x0040	/* Add 200ps Delay To EBIU Input Latches			*/
+#define	OUT_DELAY		0x0080	/* Add 200ps Delay To EBIU Output Signals			*/
+#define BYPASS			0x0100	/* Bypass the PLL									*/
+#define	MSEL			0x7E00	/* Multiplier Select For CCLK/VCO Factors			*/
+/* PLL_CTL Macros (Only Use With Logic OR While Setting Lower Order Bits)			*/
+#define	SET_MSEL(x)		(((x)&0x3F) << 0x9)	/* Set MSEL = 0-63 --> VCO = CLKIN*MSEL		*/
+
+/* PLL_DIV Masks														*/
+#define SSEL			0x000F	/* System Select						*/
+#define	CSEL			0x0030	/* Core Select							*/
+#define CSEL_DIV1		0x0000	/* 		CCLK = VCO / 1					*/
+#define CSEL_DIV2		0x0010	/* 		CCLK = VCO / 2					*/
+#define	CSEL_DIV4		0x0020	/* 		CCLK = VCO / 4					*/
+#define	CSEL_DIV8		0x0030	/* 		CCLK = VCO / 8					*/
+/* PLL_DIV Macros														*/
+#define SET_SSEL(x)		((x)&0xF)		/* Set SSEL = 0-15 --> SCLK = VCO/SSEL	*/
+
+/* VR_CTL Masks																	*/
+#define	FREQ			0x0003	/* Switching Oscillator Frequency For Regulator	*/
+#define	HIBERNATE		0x0000	/* 		Powerdown/Bypass On-Board Regulation	*/
+#define	FREQ_333		0x0001	/* 		Switching Frequency Is 333 kHz			*/
+#define	FREQ_667		0x0002	/* 		Switching Frequency Is 667 kHz			*/
+#define	FREQ_1000		0x0003	/* 		Switching Frequency Is 1 MHz			*/
+
+#define GAIN			0x000C	/* Voltage Level Gain	*/
+#define	GAIN_5			0x0000	/* 		GAIN = 5		*/
+#define	GAIN_10			0x0004	/* 		GAIN = 10		*/
+#define	GAIN_20			0x0008	/* 		GAIN = 20		*/
+#define	GAIN_50			0x000C	/* 		GAIN = 50		*/
+
+#define	VLEV			0x00F0	/* Internal Voltage Level					*/
+#define	VLEV_085 		0x0060	/* 		VLEV = 0.85 V (-5% - +10% Accuracy)	*/
+#define	VLEV_090		0x0070	/* 		VLEV = 0.90 V (-5% - +10% Accuracy)	*/
+#define	VLEV_095		0x0080	/* 		VLEV = 0.95 V (-5% - +10% Accuracy)	*/
+#define	VLEV_100		0x0090	/* 		VLEV = 1.00 V (-5% - +10% Accuracy)	*/
+#define	VLEV_105		0x00A0	/* 		VLEV = 1.05 V (-5% - +10% Accuracy)	*/
+#define	VLEV_110		0x00B0	/* 		VLEV = 1.10 V (-5% - +10% Accuracy)	*/
+#define	VLEV_115		0x00C0	/* 		VLEV = 1.15 V (-5% - +10% Accuracy)	*/
+#define	VLEV_120		0x00D0	/* 		VLEV = 1.20 V (-5% - +10% Accuracy)	*/
+#define	VLEV_125		0x00E0	/* 		VLEV = 1.25 V (-5% - +10% Accuracy)	*/
+#define	VLEV_130		0x00F0	/* 		VLEV = 1.30 V (-5% - +10% Accuracy)	*/
+
+#define	WAKE			0x0100	/* Enable RTC/Reset Wakeup From Hibernate	*/
+#define	CANWE			0x0200	/* Enable CAN Wakeup From Hibernate			*/
+#define	PHYWE			0x0400	/* Enable PHY Wakeup From Hibernate			*/
+#define	CLKBUFOE		0x4000	/* CLKIN Buffer Output Enable */
+#define	PHYCLKOE		CLKBUFOE	/* Alternative legacy name for the above */
+#define	SCKELOW		0x8000	/* Enable Drive CKE Low During Reset		*/
+
+/* PLL_STAT Masks																	*/
+#define ACTIVE_PLLENABLED	0x0001	/* Processor In Active Mode With PLL Enabled	*/
+#define	FULL_ON				0x0002	/* Processor In Full On Mode					*/
+#define ACTIVE_PLLDISABLED	0x0004	/* Processor In Active Mode With PLL Disabled	*/
+#define	PLL_LOCKED			0x0020	/* PLL_LOCKCNT Has Been Reached					*/
+
+/* CHIPID Masks */
+#define CHIPID_VERSION         0xF0000000
+#define CHIPID_FAMILY          0x0FFFF000
+#define CHIPID_MANUFACTURE     0x00000FFE
+
+/* SWRST Masks																		*/
+#define SYSTEM_RESET		0x0007	/* Initiates A System Software Reset			*/
+#define	DOUBLE_FAULT		0x0008	/* Core Double Fault Causes Reset				*/
+#define RESET_DOUBLE		0x2000	/* SW Reset Generated By Core Double-Fault		*/
+#define RESET_WDOG			0x4000	/* SW Reset Generated By Watchdog Timer			*/
+#define RESET_SOFTWARE		0x8000	/* SW Reset Occurred Since Last Read Of SWRST	*/
+
+/* SYSCR Masks																				*/
+#define BMODE				0x0007	/* Boot Mode - Latched During HW Reset From Mode Pins	*/
+#define	NOBOOT				0x0010	/* Execute From L1 or ASYNC Bank 0 When BMODE = 0		*/
+
+
+/* *************  SYSTEM INTERRUPT CONTROLLER MASKS *************************************/
+/* Peripheral Masks For SIC_ISR, SIC_IWR, SIC_IMASK										*/
+#define IRQ_PLL_WAKEUP	0x00000001	/* PLL Wakeup Interrupt			 					*/
+
+#define IRQ_ERROR1      0x00000002  /* Error Interrupt (DMA, DMARx Block, DMARx Overflow) */
+#define IRQ_ERROR2      0x00000004  /* Error Interrupt (CAN, Ethernet, SPORTx, PPI, SPI, UARTx) */
+#define IRQ_RTC			0x00000008	/* Real Time Clock Interrupt 						*/ 
+#define IRQ_DMA0		0x00000010	/* DMA Channel 0 (PPI) Interrupt 					*/ 
+#define IRQ_DMA3		0x00000020	/* DMA Channel 3 (SPORT0 RX) Interrupt 				*/ 
+#define IRQ_DMA4		0x00000040	/* DMA Channel 4 (SPORT0 TX) Interrupt 				*/
+#define IRQ_DMA5		0x00000080	/* DMA Channel 5 (SPORT1 RX) Interrupt 				*/
+
+#define IRQ_DMA6		0x00000100	/* DMA Channel 6 (SPORT1 TX) Interrupt 		 		*/
+#define IRQ_TWI			0x00000200	/* TWI Interrupt									*/
+#define IRQ_DMA7		0x00000400	/* DMA Channel 7 (SPI) Interrupt 					*/
+#define IRQ_DMA8		0x00000800	/* DMA Channel 8 (UART0 RX) Interrupt 				*/ 
+#define IRQ_DMA9		0x00001000	/* DMA Channel 9 (UART0 TX) Interrupt 				*/
+#define IRQ_DMA10		0x00002000	/* DMA Channel 10 (UART1 RX) Interrupt 				*/
+#define IRQ_DMA11		0x00004000	/* DMA Channel 11 (UART1 TX) Interrupt 				*/
+#define IRQ_CAN_RX		0x00008000	/* CAN Receive Interrupt 							*/
+
+#define IRQ_CAN_TX		0x00010000	/* CAN Transmit Interrupt  							*/
+#define IRQ_DMA1		0x00020000	/* DMA Channel 1 (Ethernet RX) Interrupt 			*/
+#define IRQ_PFA_PORTH	0x00020000	/* PF Port H (PF47:32) Interrupt A 					*/
+#define IRQ_DMA2		0x00040000	/* DMA Channel 2 (Ethernet TX) Interrupt 			*/
+#define IRQ_PFB_PORTH	0x00040000	/* PF Port H (PF47:32) Interrupt B 					*/
+#define IRQ_TIMER0		0x00080000	/* Timer 0 Interrupt								*/
+#define IRQ_TIMER1		0x00100000	/* Timer 1 Interrupt 								*/
+#define IRQ_TIMER2		0x00200000	/* Timer 2 Interrupt 								*/
+#define IRQ_TIMER3		0x00400000	/* Timer 3 Interrupt 								*/
+#define IRQ_TIMER4		0x00800000	/* Timer 4 Interrupt 								*/
+
+#define IRQ_TIMER5		0x01000000	/* Timer 5 Interrupt 								*/
+#define IRQ_TIMER6		0x02000000	/* Timer 6 Interrupt 								*/
+#define IRQ_TIMER7		0x04000000	/* Timer 7 Interrupt 								*/
+#define IRQ_PFA_PORTFG	0x08000000	/* PF Ports F&G (PF31:0) Interrupt A 				*/
+#define IRQ_PFB_PORTF	0x80000000	/* PF Port F (PF15:0) Interrupt B 					*/
+#define IRQ_DMA12		0x20000000	/* DMA Channels 12 (MDMA1 Source) RX Interrupt 		*/
+#define IRQ_DMA13		0x20000000	/* DMA Channels 13 (MDMA1 Destination) TX Interrupt */
+#define IRQ_DMA14		0x40000000	/* DMA Channels 14 (MDMA0 Source) RX Interrupt 		*/
+#define IRQ_DMA15		0x40000000	/* DMA Channels 15 (MDMA0 Destination) TX Interrupt */
+#define IRQ_WDOG		0x80000000	/* Software Watchdog Timer Interrupt 				*/
+#define IRQ_PFB_PORTG	0x10000000	/* PF Port G (PF31:16) Interrupt B 					*/
+
+/* SIC_IAR0 Macros															*/
+#define P0_IVG(x)		(((x)&0xF)-7)			/* Peripheral #0 assigned IVG #x 	*/
+#define P1_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #1 assigned IVG #x 	*/
+#define P2_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #2 assigned IVG #x 	*/
+#define P3_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #3 assigned IVG #x	*/
+#define P4_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #4 assigned IVG #x	*/
+#define P5_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #5 assigned IVG #x	*/
+#define P6_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #6 assigned IVG #x	*/
+#define P7_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #7 assigned IVG #x	*/
+
+/* SIC_IAR1 Macros															*/
+#define P8_IVG(x)		(((x)&0xF)-7)			/* Peripheral #8 assigned IVG #x 	*/
+#define P9_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #9 assigned IVG #x 	*/
+#define P10_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #10 assigned IVG #x	*/
+#define P11_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #11 assigned IVG #x 	*/
+#define P12_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #12 assigned IVG #x	*/
+#define P13_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #13 assigned IVG #x	*/
+#define P14_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #14 assigned IVG #x	*/
+#define P15_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #15 assigned IVG #x	*/
+
+/* SIC_IAR2 Macros															*/
+#define P16_IVG(x)		(((x)&0xF)-7)			/* Peripheral #16 assigned IVG #x	*/
+#define P17_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #17 assigned IVG #x	*/
+#define P18_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #18 assigned IVG #x	*/
+#define P19_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #19 assigned IVG #x	*/
+#define P20_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #20 assigned IVG #x	*/
+#define P21_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #21 assigned IVG #x	*/
+#define P22_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #22 assigned IVG #x	*/
+#define P23_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #23 assigned IVG #x	*/
+
+/* SIC_IAR3 Macros															*/
+#define P24_IVG(x)		(((x)&0xF)-7)			/* Peripheral #24 assigned IVG #x	*/
+#define P25_IVG(x)		(((x)&0xF)-7) << 0x4	/* Peripheral #25 assigned IVG #x	*/
+#define P26_IVG(x)		(((x)&0xF)-7) << 0x8	/* Peripheral #26 assigned IVG #x	*/
+#define P27_IVG(x)		(((x)&0xF)-7) << 0xC	/* Peripheral #27 assigned IVG #x	*/
+#define P28_IVG(x)		(((x)&0xF)-7) << 0x10	/* Peripheral #28 assigned IVG #x	*/
+#define P29_IVG(x)		(((x)&0xF)-7) << 0x14	/* Peripheral #29 assigned IVG #x	*/
+#define P30_IVG(x)		(((x)&0xF)-7) << 0x18	/* Peripheral #30 assigned IVG #x	*/
+#define P31_IVG(x)		(((x)&0xF)-7) << 0x1C	/* Peripheral #31 assigned IVG #x	*/
+
+
+/* SIC_IMASK Masks																		*/
+#define SIC_UNMASK_ALL	0x00000000					/* Unmask all peripheral interrupts	*/
+#define SIC_MASK_ALL	0xFFFFFFFF					/* Mask all peripheral interrupts	*/
+#define SIC_MASK(x)		(1 << ((x)&0x1F))					/* Mask Peripheral #x interrupt		*/
+#define SIC_UNMASK(x)	(0xFFFFFFFF ^ (1 << ((x)&0x1F)))	/* Unmask Peripheral #x interrupt	*/
+
+/* SIC_IWR Masks																		*/
+#define IWR_DISABLE_ALL	0x00000000					/* Wakeup Disable all peripherals	*/
+#define IWR_ENABLE_ALL	0xFFFFFFFF					/* Wakeup Enable all peripherals	*/
+#define IWR_ENABLE(x)	(1 << ((x)&0x1F))					/* Wakeup Enable Peripheral #x		*/
+#define IWR_DISABLE(x)	(0xFFFFFFFF ^ (1 << ((x)&0x1F))) 	/* Wakeup Disable Peripheral #x		*/
+
+
+/* ********* WATCHDOG TIMER MASKS ******************** */
+
+/* Watchdog Timer WDOG_CTL Register Masks */
+
+#define WDEV(x) (((x)<<1) & 0x0006) /* event generated on roll over */
+#define WDEV_RESET 0x0000 /* generate reset event on roll over */
+#define WDEV_NMI 0x0002 /* generate NMI event on roll over */
+#define WDEV_GPI 0x0004 /* generate GP IRQ on roll over */
+#define WDEV_NONE 0x0006 /* no event on roll over */
+#define WDEN 0x0FF0 /* enable watchdog */
+#define WDDIS 0x0AD0 /* disable watchdog */
+#define WDRO 0x8000 /* watchdog rolled over latch */ 
+
+/* depreciated WDOG_CTL Register Masks for legacy code */
+
+
+#define ICTL WDEV
+#define ENABLE_RESET WDEV_RESET
+#define WDOG_RESET WDEV_RESET
+#define ENABLE_NMI WDEV_NMI
+#define WDOG_NMI WDEV_NMI
+#define ENABLE_GPI WDEV_GPI
+#define WDOG_GPI WDEV_GPI
+#define DISABLE_EVT WDEV_NONE
+#define WDOG_NONE WDEV_NONE
+
+#define TMR_EN WDEN
+#define TMR_DIS WDDIS
+#define TRO WDRO
+#define ICTL_P0 0x01
+ #define ICTL_P1 0x02
+#define TRO_P 0x0F
+
+
+
+/* ***************  REAL TIME CLOCK MASKS  **************************/
+/* RTC_STAT and RTC_ALARM Masks										*/
+#define	RTC_SEC				0x0000003F	/* Real-Time Clock Seconds	*/
+#define	RTC_MIN				0x00000FC0	/* Real-Time Clock Minutes	*/
+#define	RTC_HR				0x0001F000	/* Real-Time Clock Hours	*/
+#define	RTC_DAY				0xFFFE0000	/* Real-Time Clock Days		*/
+
+/* RTC_ALARM Macro			z=day		y=hr	x=min	w=sec		*/
+#define SET_ALARM(z,y,x,w)	((((z)&0x7FFF)<<0x11)|(((y)&0x1F)<<0xC)|(((x)&0x3F)<<0x6)|((w)&0x3F))
+
+/* RTC_ICTL and RTC_ISTAT Masks																		*/
+#define	STOPWATCH			0x0001		/* Stopwatch Interrupt Enable								*/
+#define	ALARM				0x0002		/* Alarm Interrupt Enable									*/
+#define	SECOND				0x0004		/* Seconds (1 Hz) Interrupt Enable							*/
+#define	MINUTE				0x0008		/* Minutes Interrupt Enable									*/
+#define	HOUR				0x0010		/* Hours Interrupt Enable									*/
+#define	DAY					0x0020		/* 24 Hours (Days) Interrupt Enable							*/
+#define	DAY_ALARM			0x0040		/* Day Alarm (Day, Hour, Minute, Second) Interrupt Enable	*/
+#define	WRITE_PENDING		0x4000		/* Write Pending Status										*/
+#define	WRITE_COMPLETE		0x8000		/* Write Complete Interrupt Enable							*/
+
+/* RTC_FAST / RTC_PREN Mask												*/
+#define PREN				0x0001	/* Enable Prescaler, RTC Runs @1 Hz	*/
+
+
+/* ************** UART CONTROLLER MASKS *************************/
+/* UARTx_LCR Masks												*/
+#define WLS(x)		(((x)-5) & 0x03)	/* Word Length Select */
+#define STB			0x04				/* Stop Bits			*/
+#define PEN			0x08				/* Parity Enable		*/
+#define EPS			0x10				/* Even Parity Select	*/
+#define STP			0x20				/* Stick Parity			*/
+#define SB			0x40				/* Set Break			*/
+#define DLAB		0x80				/* Divisor Latch Access	*/
+
+/* UARTx_MCR Mask										*/
+#define LOOP_ENA	0x10	/* Loopback Mode Enable */
+#define LOOP_ENA_P	0x04
+
+/* UARTx_LSR Masks										*/
+#define DR			0x01	/* Data Ready				*/
+#define OE			0x02	/* Overrun Error			*/
+#define PE			0x04	/* Parity Error				*/
+#define FE			0x08	/* Framing Error			*/
+#define BI			0x10	/* Break Interrupt			*/
+#define THRE		0x20	/* THR Empty				*/
+#define TEMT		0x40	/* TSR and UART_THR Empty	*/
+
+/* UARTx_IER Masks															*/
+#define ERBFI		0x01		/* Enable Receive Buffer Full Interrupt		*/
+#define ETBEI		0x02		/* Enable Transmit Buffer Empty Interrupt	*/
+#define ELSI		0x04		/* Enable RX Status Interrupt				*/
+
+/* UARTx_IIR Masks														*/
+#define NINT		0x01		/* Pending Interrupt					*/
+#define IIR_TX_READY    0x02		/* UART_THR empty                               */
+#define IIR_RX_READY    0x04		/* Receive data ready                           */
+#define IIR_LINE_CHANGE 0x06		/* Receive line status    			*/ 
+#define IIR_STATUS	0x06		/* Highest Priority Pending Interrupt	*/
+
+/* UARTx_GCTL Masks													*/
+#define UCEN		0x01		/* Enable UARTx Clocks				*/
+#define IREN		0x02		/* Enable IrDA Mode					*/
+#define TPOLC		0x04		/* IrDA TX Polarity Change			*/
+#define RPOLC		0x08		/* IrDA RX Polarity Change			*/
+#define FPE			0x10		/* Force Parity Error On Transmit	*/
+#define FFE			0x20		/* Force Framing Error On Transmit	*/
+
+
+/* ***********  SERIAL PERIPHERAL INTERFACE (SPI) MASKS  ****************************/
+/* SPI_CTL Masks																	*/
+#define	TIMOD		0x0003		/* Transfer Initiate Mode							*/
+#define RDBR_CORE	0x0000		/* 		RDBR Read Initiates, IRQ When RDBR Full		*/
+#define	TDBR_CORE	0x0001		/* 		TDBR Write Initiates, IRQ When TDBR Empty	*/
+#define RDBR_DMA	0x0002		/* 		DMA Read, DMA Until FIFO Empty				*/
+#define TDBR_DMA	0x0003		/* 		DMA Write, DMA Until FIFO Full				*/
+#define SZ			0x0004		/* Send Zero (When TDBR Empty, Send Zero/Last*)		*/
+#define GM			0x0008		/* Get More (When RDBR Full, Overwrite/Discard*)	*/
+#define PSSE		0x0010		/* Slave-Select Input Enable						*/
+#define EMISO		0x0020		/* Enable MISO As Output							*/
+#define SIZE		0x0100		/* Size of Words (16/8* Bits)						*/
+#define LSBF		0x0200		/* LSB First										*/
+#define CPHA		0x0400		/* Clock Phase										*/
+#define CPOL		0x0800		/* Clock Polarity									*/
+#define MSTR		0x1000		/* Master/Slave*									*/
+#define WOM			0x2000		/* Write Open Drain Master							*/
+#define SPE			0x4000		/* SPI Enable										*/
+
+/* SPI_FLG Masks																	*/
+#define FLS1		0x0002		/* Enables SPI_FLOUT1 as SPI Slave-Select Output	*/
+#define FLS2		0x0004		/* Enables SPI_FLOUT2 as SPI Slave-Select Output	*/
+#define FLS3		0x0008		/* Enables SPI_FLOUT3 as SPI Slave-Select Output	*/
+#define FLS4		0x0010		/* Enables SPI_FLOUT4 as SPI Slave-Select Output	*/
+#define FLS5		0x0020		/* Enables SPI_FLOUT5 as SPI Slave-Select Output	*/
+#define FLS6		0x0040		/* Enables SPI_FLOUT6 as SPI Slave-Select Output	*/
+#define FLS7		0x0080		/* Enables SPI_FLOUT7 as SPI Slave-Select Output	*/
+#define FLG1		0xFDFF		/* Activates SPI_FLOUT1 							*/
+#define FLG2		0xFBFF		/* Activates SPI_FLOUT2								*/
+#define FLG3		0xF7FF		/* Activates SPI_FLOUT3								*/
+#define FLG4		0xEFFF		/* Activates SPI_FLOUT4								*/
+#define FLG5		0xDFFF		/* Activates SPI_FLOUT5								*/
+#define FLG6		0xBFFF		/* Activates SPI_FLOUT6								*/
+#define FLG7		0x7FFF		/* Activates SPI_FLOUT7								*/
+
+/* SPI_STAT Masks																				*/
+#define SPIF		0x0001		/* SPI Finished (Single-Word Transfer Complete)					*/
+#define MODF		0x0002		/* Mode Fault Error (Another Device Tried To Become Master)		*/
+#define TXE			0x0004		/* Transmission Error (Data Sent With No New Data In TDBR)		*/
+#define TXS			0x0008		/* SPI_TDBR Data Buffer Status (Full/Empty*)					*/
+#define RBSY		0x0010		/* Receive Error (Data Received With RDBR Full)					*/
+#define RXS			0x0020		/* SPI_RDBR Data Buffer Status (Full/Empty*)					*/
+#define TXCOL		0x0040		/* Transmit Collision Error (Corrupt Data May Have Been Sent)	*/
+
+
+/*  ****************  GENERAL PURPOSE TIMER MASKS  **********************/
+/* TIMER_ENABLE Masks													*/
+#define TIMEN0			0x0001		/* Enable Timer 0					*/
+#define TIMEN1			0x0002		/* Enable Timer 1					*/
+#define TIMEN2			0x0004		/* Enable Timer 2					*/
+#define TIMEN3			0x0008		/* Enable Timer 3					*/
+#define TIMEN4			0x0010		/* Enable Timer 4					*/
+#define TIMEN5			0x0020		/* Enable Timer 5					*/
+#define TIMEN6			0x0040		/* Enable Timer 6					*/
+#define TIMEN7			0x0080		/* Enable Timer 7					*/
+
+/* TIMER_DISABLE Masks													*/
+#define TIMDIS0			TIMEN0		/* Disable Timer 0					*/
+#define TIMDIS1			TIMEN1		/* Disable Timer 1					*/
+#define TIMDIS2			TIMEN2		/* Disable Timer 2					*/
+#define TIMDIS3			TIMEN3		/* Disable Timer 3					*/
+#define TIMDIS4			TIMEN4		/* Disable Timer 4					*/
+#define TIMDIS5			TIMEN5		/* Disable Timer 5					*/
+#define TIMDIS6			TIMEN6		/* Disable Timer 6					*/
+#define TIMDIS7			TIMEN7		/* Disable Timer 7					*/
+
+/* TIMER_STATUS Masks													*/
+#define TIMIL0			0x00000001	/* Timer 0 Interrupt				*/
+#define TIMIL1			0x00000002	/* Timer 1 Interrupt				*/
+#define TIMIL2			0x00000004	/* Timer 2 Interrupt				*/
+#define TIMIL3			0x00000008	/* Timer 3 Interrupt				*/
+#define TOVF_ERR0		0x00000010	/* Timer 0 Counter Overflow			*/
+#define TOVF_ERR1		0x00000020	/* Timer 1 Counter Overflow			*/
+#define TOVF_ERR2		0x00000040	/* Timer 2 Counter Overflow			*/
+#define TOVF_ERR3		0x00000080	/* Timer 3 Counter Overflow			*/
+#define TRUN0			0x00001000	/* Timer 0 Slave Enable Status		*/
+#define TRUN1			0x00002000	/* Timer 1 Slave Enable Status		*/
+#define TRUN2			0x00004000	/* Timer 2 Slave Enable Status		*/
+#define TRUN3			0x00008000	/* Timer 3 Slave Enable Status		*/
+#define TIMIL4			0x00010000	/* Timer 4 Interrupt				*/
+#define TIMIL5			0x00020000	/* Timer 5 Interrupt				*/
+#define TIMIL6			0x00040000	/* Timer 6 Interrupt				*/
+#define TIMIL7			0x00080000	/* Timer 7 Interrupt				*/
+#define TOVF_ERR4		0x00100000	/* Timer 4 Counter Overflow			*/
+#define TOVF_ERR5		0x00200000	/* Timer 5 Counter Overflow			*/
+#define TOVF_ERR6		0x00400000	/* Timer 6 Counter Overflow			*/
+#define TOVF_ERR7		0x00800000	/* Timer 7 Counter Overflow			*/
+#define TRUN4			0x10000000	/* Timer 4 Slave Enable Status		*/
+#define TRUN5			0x20000000	/* Timer 5 Slave Enable Status		*/
+#define TRUN6			0x40000000	/* Timer 6 Slave Enable Status		*/
+#define TRUN7			0x80000000	/* Timer 7 Slave Enable Status		*/
+
+/* Alternate Deprecated Macros Provided For Backwards Code Compatibility */
+#define TOVL_ERR0 TOVF_ERR0
+#define TOVL_ERR1 TOVF_ERR1
+#define TOVL_ERR2 TOVF_ERR2
+#define TOVL_ERR3 TOVF_ERR3
+#define TOVL_ERR4 TOVF_ERR4
+#define TOVL_ERR5 TOVF_ERR5
+#define TOVL_ERR6 TOVF_ERR6
+#define TOVL_ERR7 TOVF_ERR7
+
+/* TIMERx_CONFIG Masks													*/
+#define PWM_OUT			0x0001	/* Pulse-Width Modulation Output Mode	*/
+#define WDTH_CAP		0x0002	/* Width Capture Input Mode				*/
+#define EXT_CLK			0x0003	/* External Clock Mode					*/
+#define PULSE_HI		0x0004	/* Action Pulse (Positive/Negative*)	*/
+#define PERIOD_CNT		0x0008	/* Period Count							*/
+#define IRQ_ENA			0x0010	/* Interrupt Request Enable				*/
+#define TIN_SEL			0x0020	/* Timer Input Select					*/
+#define OUT_DIS			0x0040	/* Output Pad Disable					*/
+#define CLK_SEL			0x0080	/* Timer Clock Select					*/
+#define TOGGLE_HI		0x0100	/* PWM_OUT PULSE_HI Toggle Mode			*/
+#define EMU_RUN			0x0200	/* Emulation Behavior Select			*/
+#define ERR_TYP			0xC000	/* Error Type							*/
+
+
+/* ******************   GPIO PORTS F, G, H MASKS  ***********************/
+/*  General Purpose IO (0xFFC00700 - 0xFFC007FF)  Masks 				*/
+/* Port F Masks 														*/
+#define PF0		0x0001
+#define PF1		0x0002
+#define PF2		0x0004
+#define PF3		0x0008
+#define PF4		0x0010
+#define PF5		0x0020
+#define PF6		0x0040
+#define PF7		0x0080
+#define PF8		0x0100
+#define PF9		0x0200
+#define PF10	0x0400
+#define PF11	0x0800
+#define PF12	0x1000
+#define PF13	0x2000
+#define PF14	0x4000
+#define PF15	0x8000
+
+/* Port G Masks															*/
+#define PG0		0x0001
+#define PG1		0x0002
+#define PG2		0x0004
+#define PG3		0x0008
+#define PG4		0x0010
+#define PG5		0x0020
+#define PG6		0x0040
+#define PG7		0x0080
+#define PG8		0x0100
+#define PG9		0x0200
+#define PG10	0x0400
+#define PG11	0x0800
+#define PG12	0x1000
+#define PG13	0x2000
+#define PG14	0x4000
+#define PG15	0x8000
+
+/* Port H Masks															*/
+#define PH0		0x0001
+#define PH1		0x0002
+#define PH2		0x0004
+#define PH3		0x0008
+#define PH4		0x0010
+#define PH5		0x0020
+#define PH6		0x0040
+#define PH7		0x0080
+#define PH8		0x0100
+#define PH9		0x0200
+#define PH10	0x0400
+#define PH11	0x0800
+#define PH12	0x1000
+#define PH13	0x2000
+#define PH14	0x4000
+#define PH15	0x8000
+
+
+/* *******************  SERIAL PORT MASKS  **************************************/
+/* SPORTx_TCR1 Masks															*/
+#define TSPEN		0x0001		/* Transmit Enable								*/
+#define ITCLK		0x0002		/* Internal Transmit Clock Select				*/
+#define DTYPE_NORM	0x0004		/* Data Format Normal							*/
+#define DTYPE_ULAW	0x0008		/* Compand Using u-Law							*/
+#define DTYPE_ALAW	0x000C		/* Compand Using A-Law							*/
+#define TLSBIT		0x0010		/* Transmit Bit Order							*/
+#define ITFS		0x0200		/* Internal Transmit Frame Sync Select			*/
+#define TFSR		0x0400		/* Transmit Frame Sync Required Select			*/
+#define DITFS		0x0800		/* Data-Independent Transmit Frame Sync Select	*/
+#define LTFS		0x1000		/* Low Transmit Frame Sync Select				*/
+#define LATFS		0x2000		/* Late Transmit Frame Sync Select				*/
+#define TCKFE		0x4000		/* Clock Falling Edge Select					*/
+
+/* SPORTx_TCR2 Masks and Macro													*/
+#define SLEN(x)		((x)&0x1F)	/* SPORT TX Word Length (2 - 31)				*/
+#define TXSE		0x0100		/* TX Secondary Enable							*/
+#define TSFSE		0x0200		/* Transmit Stereo Frame Sync Enable			*/
+#define TRFST		0x0400		/* Left/Right Order (1 = Right Channel 1st)		*/
+
+/* SPORTx_RCR1 Masks															*/
+#define RSPEN		0x0001		/* Receive Enable 								*/
+#define IRCLK		0x0002		/* Internal Receive Clock Select 				*/
+#define DTYPE_NORM	0x0004		/* Data Format Normal							*/
+#define DTYPE_ULAW	0x0008		/* Compand Using u-Law							*/
+#define DTYPE_ALAW	0x000C		/* Compand Using A-Law							*/
+#define RLSBIT		0x0010		/* Receive Bit Order							*/
+#define IRFS		0x0200		/* Internal Receive Frame Sync Select 			*/
+#define RFSR		0x0400		/* Receive Frame Sync Required Select 			*/
+#define LRFS		0x1000		/* Low Receive Frame Sync Select 				*/
+#define LARFS		0x2000		/* Late Receive Frame Sync Select 				*/
+#define RCKFE		0x4000		/* Clock Falling Edge Select 					*/
+
+/* SPORTx_RCR2 Masks															*/
+#define SLEN(x)		((x)&0x1F)	/* SPORT RX Word Length (2 - 31)				*/
+#define RXSE		0x0100		/* RX Secondary Enable							*/
+#define RSFSE		0x0200		/* RX Stereo Frame Sync Enable					*/
+#define RRFST		0x0400		/* Right-First Data Order 						*/
+
+/* SPORTx_STAT Masks															*/
+#define RXNE		0x0001		/* Receive FIFO Not Empty Status				*/
+#define RUVF		0x0002		/* Sticky Receive Underflow Status				*/
+#define ROVF		0x0004		/* Sticky Receive Overflow Status				*/
+#define TXF			0x0008		/* Transmit FIFO Full Status					*/
+#define TUVF		0x0010		/* Sticky Transmit Underflow Status				*/
+#define TOVF		0x0020		/* Sticky Transmit Overflow Status				*/
+#define TXHRE		0x0040		/* Transmit Hold Register Empty					*/
+
+/* SPORTx_MCMC1 Macros															*/
+#define SP_WOFF(x)	((x) & 0x3FF) 	/* Multichannel Window Offset Field			*/
+
+/* Only use WSIZE Macro With Logic OR While Setting Lower Order Bits						*/
+#define SP_WSIZE(x)	(((((x)>>0x3)-1)&0xF) << 0xC)	/* Multichannel Window Size = (x/8)-1	*/
+
+/* SPORTx_MCMC2 Masks															*/
+#define REC_BYPASS	0x0000		/* Bypass Mode (No Clock Recovery)				*/
+#define REC_2FROM4	0x0002		/* Recover 2 MHz Clock from 4 MHz Clock			*/
+#define REC_8FROM16	0x0003		/* Recover 8 MHz Clock from 16 MHz Clock		*/
+#define MCDTXPE		0x0004 		/* Multichannel DMA Transmit Packing			*/
+#define MCDRXPE		0x0008 		/* Multichannel DMA Receive Packing				*/
+#define MCMEN		0x0010 		/* Multichannel Frame Mode Enable				*/
+#define FSDR		0x0080 		/* Multichannel Frame Sync to Data Relationship	*/
+#define MFD_0		0x0000		/* Multichannel Frame Delay = 0					*/
+#define MFD_1		0x1000		/* Multichannel Frame Delay = 1					*/
+#define MFD_2		0x2000		/* Multichannel Frame Delay = 2					*/
+#define MFD_3		0x3000		/* Multichannel Frame Delay = 3					*/
+#define MFD_4		0x4000		/* Multichannel Frame Delay = 4					*/
+#define MFD_5		0x5000		/* Multichannel Frame Delay = 5					*/
+#define MFD_6		0x6000		/* Multichannel Frame Delay = 6					*/
+#define MFD_7		0x7000		/* Multichannel Frame Delay = 7					*/
+#define MFD_8		0x8000		/* Multichannel Frame Delay = 8					*/
+#define MFD_9		0x9000		/* Multichannel Frame Delay = 9					*/
+#define MFD_10		0xA000		/* Multichannel Frame Delay = 10				*/
+#define MFD_11		0xB000		/* Multichannel Frame Delay = 11				*/
+#define MFD_12		0xC000		/* Multichannel Frame Delay = 12				*/
+#define MFD_13		0xD000		/* Multichannel Frame Delay = 13				*/
+#define MFD_14		0xE000		/* Multichannel Frame Delay = 14				*/
+#define MFD_15		0xF000		/* Multichannel Frame Delay = 15				*/
+
+
+/* *********************  ASYNCHRONOUS MEMORY CONTROLLER MASKS  *************************/
+/* EBIU_AMGCTL Masks																	*/
+#define AMCKEN			0x0001		/* Enable CLKOUT									*/
+#define	AMBEN_NONE		0x0000		/* All Banks Disabled								*/
+#define AMBEN_B0		0x0002		/* Enable Async Memory Bank 0 only					*/
+#define AMBEN_B0_B1		0x0004		/* Enable Async Memory Banks 0 & 1 only				*/
+#define AMBEN_B0_B1_B2	0x0006		/* Enable Async Memory Banks 0, 1, and 2			*/
+#define AMBEN_ALL		0x0008		/* Enable Async Memory Banks (all) 0, 1, 2, and 3	*/
+
+/* EBIU_AMBCTL0 Masks																	*/
+#define B0RDYEN			0x00000001  /* Bank 0 (B0) RDY Enable							*/
+#define B0RDYPOL		0x00000002  /* B0 RDY Active High								*/
+#define B0TT_1			0x00000004  /* B0 Transition Time (Read to Write) = 1 cycle		*/
+#define B0TT_2			0x00000008  /* B0 Transition Time (Read to Write) = 2 cycles	*/
+#define B0TT_3			0x0000000C  /* B0 Transition Time (Read to Write) = 3 cycles	*/
+#define B0TT_4			0x00000000  /* B0 Transition Time (Read to Write) = 4 cycles	*/
+#define B0ST_1			0x00000010  /* B0 Setup Time (AOE to Read/Write) = 1 cycle		*/
+#define B0ST_2			0x00000020  /* B0 Setup Time (AOE to Read/Write) = 2 cycles		*/
+#define B0ST_3			0x00000030  /* B0 Setup Time (AOE to Read/Write) = 3 cycles		*/
+#define B0ST_4			0x00000000  /* B0 Setup Time (AOE to Read/Write) = 4 cycles		*/
+#define B0HT_1			0x00000040  /* B0 Hold Time (~Read/Write to ~AOE) = 1 cycle		*/
+#define B0HT_2			0x00000080  /* B0 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B0HT_3			0x000000C0  /* B0 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B0HT_0			0x00000000  /* B0 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B0RAT_1			0x00000100  /* B0 Read Access Time = 1 cycle					*/
+#define B0RAT_2			0x00000200  /* B0 Read Access Time = 2 cycles					*/
+#define B0RAT_3			0x00000300  /* B0 Read Access Time = 3 cycles					*/
+#define B0RAT_4			0x00000400  /* B0 Read Access Time = 4 cycles					*/
+#define B0RAT_5			0x00000500  /* B0 Read Access Time = 5 cycles					*/
+#define B0RAT_6			0x00000600  /* B0 Read Access Time = 6 cycles					*/
+#define B0RAT_7			0x00000700  /* B0 Read Access Time = 7 cycles					*/
+#define B0RAT_8			0x00000800  /* B0 Read Access Time = 8 cycles					*/
+#define B0RAT_9			0x00000900  /* B0 Read Access Time = 9 cycles					*/
+#define B0RAT_10		0x00000A00  /* B0 Read Access Time = 10 cycles					*/
+#define B0RAT_11		0x00000B00  /* B0 Read Access Time = 11 cycles					*/
+#define B0RAT_12		0x00000C00  /* B0 Read Access Time = 12 cycles					*/
+#define B0RAT_13		0x00000D00  /* B0 Read Access Time = 13 cycles					*/
+#define B0RAT_14		0x00000E00  /* B0 Read Access Time = 14 cycles					*/
+#define B0RAT_15		0x00000F00  /* B0 Read Access Time = 15 cycles					*/
+#define B0WAT_1			0x00001000  /* B0 Write Access Time = 1 cycle					*/
+#define B0WAT_2			0x00002000  /* B0 Write Access Time = 2 cycles					*/
+#define B0WAT_3			0x00003000  /* B0 Write Access Time = 3 cycles					*/
+#define B0WAT_4			0x00004000  /* B0 Write Access Time = 4 cycles					*/
+#define B0WAT_5			0x00005000  /* B0 Write Access Time = 5 cycles					*/
+#define B0WAT_6			0x00006000  /* B0 Write Access Time = 6 cycles					*/
+#define B0WAT_7			0x00007000  /* B0 Write Access Time = 7 cycles					*/
+#define B0WAT_8			0x00008000  /* B0 Write Access Time = 8 cycles					*/
+#define B0WAT_9			0x00009000  /* B0 Write Access Time = 9 cycles					*/
+#define B0WAT_10		0x0000A000  /* B0 Write Access Time = 10 cycles					*/
+#define B0WAT_11		0x0000B000  /* B0 Write Access Time = 11 cycles					*/
+#define B0WAT_12		0x0000C000  /* B0 Write Access Time = 12 cycles					*/
+#define B0WAT_13		0x0000D000  /* B0 Write Access Time = 13 cycles					*/
+#define B0WAT_14		0x0000E000  /* B0 Write Access Time = 14 cycles					*/
+#define B0WAT_15		0x0000F000  /* B0 Write Access Time = 15 cycles					*/
+
+#define B1RDYEN			0x00010000  /* Bank 1 (B1) RDY Enable                       	*/
+#define B1RDYPOL		0x00020000  /* B1 RDY Active High                           	*/
+#define B1TT_1			0x00040000  /* B1 Transition Time (Read to Write) = 1 cycle 	*/
+#define B1TT_2			0x00080000  /* B1 Transition Time (Read to Write) = 2 cycles	*/
+#define B1TT_3			0x000C0000  /* B1 Transition Time (Read to Write) = 3 cycles	*/
+#define B1TT_4			0x00000000  /* B1 Transition Time (Read to Write) = 4 cycles	*/
+#define B1ST_1			0x00100000  /* B1 Setup Time (AOE to Read/Write) = 1 cycle  	*/
+#define B1ST_2			0x00200000  /* B1 Setup Time (AOE to Read/Write) = 2 cycles 	*/
+#define B1ST_3			0x00300000  /* B1 Setup Time (AOE to Read/Write) = 3 cycles 	*/
+#define B1ST_4			0x00000000  /* B1 Setup Time (AOE to Read/Write) = 4 cycles 	*/
+#define B1HT_1			0x00400000  /* B1 Hold Time (~Read/Write to ~AOE) = 1 cycle 	*/
+#define B1HT_2			0x00800000  /* B1 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B1HT_3			0x00C00000  /* B1 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B1HT_0			0x00000000  /* B1 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B1RAT_1			0x01000000  /* B1 Read Access Time = 1 cycle					*/
+#define B1RAT_2			0x02000000  /* B1 Read Access Time = 2 cycles					*/
+#define B1RAT_3			0x03000000  /* B1 Read Access Time = 3 cycles					*/
+#define B1RAT_4			0x04000000  /* B1 Read Access Time = 4 cycles					*/
+#define B1RAT_5			0x05000000  /* B1 Read Access Time = 5 cycles					*/
+#define B1RAT_6			0x06000000  /* B1 Read Access Time = 6 cycles					*/
+#define B1RAT_7			0x07000000  /* B1 Read Access Time = 7 cycles					*/
+#define B1RAT_8			0x08000000  /* B1 Read Access Time = 8 cycles					*/
+#define B1RAT_9			0x09000000  /* B1 Read Access Time = 9 cycles					*/
+#define B1RAT_10		0x0A000000  /* B1 Read Access Time = 10 cycles					*/
+#define B1RAT_11		0x0B000000  /* B1 Read Access Time = 11 cycles					*/
+#define B1RAT_12		0x0C000000  /* B1 Read Access Time = 12 cycles					*/
+#define B1RAT_13		0x0D000000  /* B1 Read Access Time = 13 cycles					*/
+#define B1RAT_14		0x0E000000  /* B1 Read Access Time = 14 cycles					*/
+#define B1RAT_15		0x0F000000  /* B1 Read Access Time = 15 cycles					*/
+#define B1WAT_1			0x10000000  /* B1 Write Access Time = 1 cycle					*/
+#define B1WAT_2			0x20000000  /* B1 Write Access Time = 2 cycles					*/
+#define B1WAT_3			0x30000000  /* B1 Write Access Time = 3 cycles					*/
+#define B1WAT_4			0x40000000  /* B1 Write Access Time = 4 cycles					*/
+#define B1WAT_5			0x50000000  /* B1 Write Access Time = 5 cycles					*/
+#define B1WAT_6			0x60000000  /* B1 Write Access Time = 6 cycles					*/
+#define B1WAT_7			0x70000000  /* B1 Write Access Time = 7 cycles					*/
+#define B1WAT_8			0x80000000  /* B1 Write Access Time = 8 cycles					*/
+#define B1WAT_9			0x90000000  /* B1 Write Access Time = 9 cycles					*/
+#define B1WAT_10		0xA0000000  /* B1 Write Access Time = 10 cycles					*/
+#define B1WAT_11		0xB0000000  /* B1 Write Access Time = 11 cycles					*/
+#define B1WAT_12		0xC0000000  /* B1 Write Access Time = 12 cycles					*/
+#define B1WAT_13		0xD0000000  /* B1 Write Access Time = 13 cycles					*/
+#define B1WAT_14		0xE0000000  /* B1 Write Access Time = 14 cycles					*/
+#define B1WAT_15		0xF0000000  /* B1 Write Access Time = 15 cycles					*/
+
+/* EBIU_AMBCTL1 Masks																	*/
+#define B2RDYEN			0x00000001  /* Bank 2 (B2) RDY Enable							*/
+#define B2RDYPOL		0x00000002  /* B2 RDY Active High								*/
+#define B2TT_1			0x00000004  /* B2 Transition Time (Read to Write) = 1 cycle		*/
+#define B2TT_2			0x00000008  /* B2 Transition Time (Read to Write) = 2 cycles	*/
+#define B2TT_3			0x0000000C  /* B2 Transition Time (Read to Write) = 3 cycles	*/
+#define B2TT_4			0x00000000  /* B2 Transition Time (Read to Write) = 4 cycles	*/
+#define B2ST_1			0x00000010  /* B2 Setup Time (AOE to Read/Write) = 1 cycle		*/
+#define B2ST_2			0x00000020  /* B2 Setup Time (AOE to Read/Write) = 2 cycles		*/
+#define B2ST_3			0x00000030  /* B2 Setup Time (AOE to Read/Write) = 3 cycles		*/
+#define B2ST_4			0x00000000  /* B2 Setup Time (AOE to Read/Write) = 4 cycles		*/
+#define B2HT_1			0x00000040  /* B2 Hold Time (~Read/Write to ~AOE) = 1 cycle		*/
+#define B2HT_2			0x00000080  /* B2 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B2HT_3			0x000000C0  /* B2 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B2HT_0			0x00000000  /* B2 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B2RAT_1			0x00000100  /* B2 Read Access Time = 1 cycle					*/
+#define B2RAT_2			0x00000200  /* B2 Read Access Time = 2 cycles					*/
+#define B2RAT_3			0x00000300  /* B2 Read Access Time = 3 cycles					*/
+#define B2RAT_4			0x00000400  /* B2 Read Access Time = 4 cycles					*/
+#define B2RAT_5			0x00000500  /* B2 Read Access Time = 5 cycles					*/
+#define B2RAT_6			0x00000600  /* B2 Read Access Time = 6 cycles					*/
+#define B2RAT_7			0x00000700  /* B2 Read Access Time = 7 cycles					*/
+#define B2RAT_8			0x00000800  /* B2 Read Access Time = 8 cycles					*/
+#define B2RAT_9			0x00000900  /* B2 Read Access Time = 9 cycles					*/
+#define B2RAT_10		0x00000A00  /* B2 Read Access Time = 10 cycles					*/
+#define B2RAT_11		0x00000B00  /* B2 Read Access Time = 11 cycles					*/
+#define B2RAT_12		0x00000C00  /* B2 Read Access Time = 12 cycles					*/
+#define B2RAT_13		0x00000D00  /* B2 Read Access Time = 13 cycles					*/
+#define B2RAT_14		0x00000E00  /* B2 Read Access Time = 14 cycles					*/
+#define B2RAT_15		0x00000F00  /* B2 Read Access Time = 15 cycles					*/
+#define B2WAT_1			0x00001000  /* B2 Write Access Time = 1 cycle					*/
+#define B2WAT_2			0x00002000  /* B2 Write Access Time = 2 cycles					*/
+#define B2WAT_3			0x00003000  /* B2 Write Access Time = 3 cycles					*/
+#define B2WAT_4			0x00004000  /* B2 Write Access Time = 4 cycles					*/
+#define B2WAT_5			0x00005000  /* B2 Write Access Time = 5 cycles					*/
+#define B2WAT_6			0x00006000  /* B2 Write Access Time = 6 cycles					*/
+#define B2WAT_7			0x00007000  /* B2 Write Access Time = 7 cycles					*/
+#define B2WAT_8			0x00008000  /* B2 Write Access Time = 8 cycles					*/
+#define B2WAT_9			0x00009000  /* B2 Write Access Time = 9 cycles					*/
+#define B2WAT_10		0x0000A000  /* B2 Write Access Time = 10 cycles					*/
+#define B2WAT_11		0x0000B000  /* B2 Write Access Time = 11 cycles					*/
+#define B2WAT_12		0x0000C000  /* B2 Write Access Time = 12 cycles					*/
+#define B2WAT_13		0x0000D000  /* B2 Write Access Time = 13 cycles					*/
+#define B2WAT_14		0x0000E000  /* B2 Write Access Time = 14 cycles					*/
+#define B2WAT_15		0x0000F000  /* B2 Write Access Time = 15 cycles					*/
+
+#define B3RDYEN			0x00010000  /* Bank 3 (B3) RDY Enable							*/
+#define B3RDYPOL		0x00020000  /* B3 RDY Active High								*/
+#define B3TT_1			0x00040000  /* B3 Transition Time (Read to Write) = 1 cycle		*/
+#define B3TT_2			0x00080000  /* B3 Transition Time (Read to Write) = 2 cycles	*/
+#define B3TT_3			0x000C0000  /* B3 Transition Time (Read to Write) = 3 cycles	*/
+#define B3TT_4			0x00000000  /* B3 Transition Time (Read to Write) = 4 cycles	*/
+#define B3ST_1			0x00100000  /* B3 Setup Time (AOE to Read/Write) = 1 cycle		*/
+#define B3ST_2			0x00200000  /* B3 Setup Time (AOE to Read/Write) = 2 cycles		*/
+#define B3ST_3			0x00300000  /* B3 Setup Time (AOE to Read/Write) = 3 cycles		*/
+#define B3ST_4			0x00000000  /* B3 Setup Time (AOE to Read/Write) = 4 cycles		*/
+#define B3HT_1			0x00400000  /* B3 Hold Time (~Read/Write to ~AOE) = 1 cycle		*/
+#define B3HT_2			0x00800000  /* B3 Hold Time (~Read/Write to ~AOE) = 2 cycles	*/
+#define B3HT_3			0x00C00000  /* B3 Hold Time (~Read/Write to ~AOE) = 3 cycles	*/
+#define B3HT_0			0x00000000  /* B3 Hold Time (~Read/Write to ~AOE) = 0 cycles	*/
+#define B3RAT_1			0x01000000  /* B3 Read Access Time = 1 cycle					*/
+#define B3RAT_2			0x02000000  /* B3 Read Access Time = 2 cycles					*/
+#define B3RAT_3			0x03000000  /* B3 Read Access Time = 3 cycles					*/
+#define B3RAT_4			0x04000000  /* B3 Read Access Time = 4 cycles					*/
+#define B3RAT_5			0x05000000  /* B3 Read Access Time = 5 cycles					*/
+#define B3RAT_6			0x06000000  /* B3 Read Access Time = 6 cycles					*/
+#define B3RAT_7			0x07000000  /* B3 Read Access Time = 7 cycles					*/
+#define B3RAT_8			0x08000000  /* B3 Read Access Time = 8 cycles					*/
+#define B3RAT_9			0x09000000  /* B3 Read Access Time = 9 cycles					*/
+#define B3RAT_10		0x0A000000  /* B3 Read Access Time = 10 cycles					*/
+#define B3RAT_11		0x0B000000  /* B3 Read Access Time = 11 cycles					*/
+#define B3RAT_12		0x0C000000  /* B3 Read Access Time = 12 cycles					*/
+#define B3RAT_13		0x0D000000  /* B3 Read Access Time = 13 cycles					*/
+#define B3RAT_14		0x0E000000  /* B3 Read Access Time = 14 cycles					*/
+#define B3RAT_15		0x0F000000  /* B3 Read Access Time = 15 cycles					*/
+#define B3WAT_1			0x10000000  /* B3 Write Access Time = 1 cycle					*/
+#define B3WAT_2			0x20000000  /* B3 Write Access Time = 2 cycles					*/
+#define B3WAT_3			0x30000000  /* B3 Write Access Time = 3 cycles					*/
+#define B3WAT_4			0x40000000  /* B3 Write Access Time = 4 cycles					*/
+#define B3WAT_5			0x50000000  /* B3 Write Access Time = 5 cycles					*/
+#define B3WAT_6			0x60000000  /* B3 Write Access Time = 6 cycles					*/
+#define B3WAT_7			0x70000000  /* B3 Write Access Time = 7 cycles					*/
+#define B3WAT_8			0x80000000  /* B3 Write Access Time = 8 cycles					*/
+#define B3WAT_9			0x90000000  /* B3 Write Access Time = 9 cycles					*/
+#define B3WAT_10		0xA0000000  /* B3 Write Access Time = 10 cycles					*/
+#define B3WAT_11		0xB0000000  /* B3 Write Access Time = 11 cycles					*/
+#define B3WAT_12		0xC0000000  /* B3 Write Access Time = 12 cycles					*/
+#define B3WAT_13		0xD0000000  /* B3 Write Access Time = 13 cycles					*/
+#define B3WAT_14		0xE0000000  /* B3 Write Access Time = 14 cycles					*/
+#define B3WAT_15		0xF0000000  /* B3 Write Access Time = 15 cycles					*/
+
+
+/* **********************  SDRAM CONTROLLER MASKS  **********************************************/
+/* EBIU_SDGCTL Masks																			*/
+#define SCTLE			0x00000001	/* Enable SDRAM Signals										*/
+#define CL_2			0x00000008	/* SDRAM CAS Latency = 2 cycles								*/
+#define CL_3			0x0000000C	/* SDRAM CAS Latency = 3 cycles								*/
+#define PASR_ALL		0x00000000	/* All 4 SDRAM Banks Refreshed In Self-Refresh				*/
+#define PASR_B0_B1		0x00000010	/* SDRAM Banks 0 and 1 Are Refreshed In Self-Refresh		*/
+#define PASR_B0			0x00000020	/* Only SDRAM Bank 0 Is Refreshed In Self-Refresh			*/
+#define TRAS_1			0x00000040	/* SDRAM tRAS = 1 cycle										*/
+#define TRAS_2			0x00000080	/* SDRAM tRAS = 2 cycles									*/
+#define TRAS_3			0x000000C0	/* SDRAM tRAS = 3 cycles									*/
+#define TRAS_4			0x00000100	/* SDRAM tRAS = 4 cycles									*/
+#define TRAS_5			0x00000140	/* SDRAM tRAS = 5 cycles									*/
+#define TRAS_6			0x00000180	/* SDRAM tRAS = 6 cycles									*/
+#define TRAS_7			0x000001C0	/* SDRAM tRAS = 7 cycles									*/
+#define TRAS_8			0x00000200	/* SDRAM tRAS = 8 cycles									*/
+#define TRAS_9			0x00000240	/* SDRAM tRAS = 9 cycles									*/
+#define TRAS_10			0x00000280	/* SDRAM tRAS = 10 cycles									*/
+#define TRAS_11			0x000002C0	/* SDRAM tRAS = 11 cycles									*/
+#define TRAS_12			0x00000300	/* SDRAM tRAS = 12 cycles									*/
+#define TRAS_13			0x00000340	/* SDRAM tRAS = 13 cycles									*/
+#define TRAS_14			0x00000380	/* SDRAM tRAS = 14 cycles									*/
+#define TRAS_15			0x000003C0	/* SDRAM tRAS = 15 cycles									*/
+#define TRP_1			0x00000800	/* SDRAM tRP = 1 cycle										*/
+#define TRP_2			0x00001000	/* SDRAM tRP = 2 cycles										*/
+#define TRP_3			0x00001800	/* SDRAM tRP = 3 cycles										*/
+#define TRP_4			0x00002000	/* SDRAM tRP = 4 cycles										*/
+#define TRP_5			0x00002800	/* SDRAM tRP = 5 cycles										*/
+#define TRP_6			0x00003000	/* SDRAM tRP = 6 cycles										*/
+#define TRP_7			0x00003800	/* SDRAM tRP = 7 cycles										*/
+#define TRCD_1			0x00008000	/* SDRAM tRCD = 1 cycle										*/
+#define TRCD_2			0x00010000	/* SDRAM tRCD = 2 cycles									*/
+#define TRCD_3			0x00018000	/* SDRAM tRCD = 3 cycles									*/
+#define TRCD_4			0x00020000	/* SDRAM tRCD = 4 cycles									*/
+#define TRCD_5			0x00028000	/* SDRAM tRCD = 5 cycles									*/
+#define TRCD_6			0x00030000	/* SDRAM tRCD = 6 cycles									*/
+#define TRCD_7			0x00038000	/* SDRAM tRCD = 7 cycles									*/
+#define TWR_1			0x00080000	/* SDRAM tWR = 1 cycle										*/
+#define TWR_2			0x00100000	/* SDRAM tWR = 2 cycles										*/
+#define TWR_3			0x00180000	/* SDRAM tWR = 3 cycles										*/
+#define PUPSD			0x00200000	/* Power-Up Start Delay (15 SCLK Cycles Delay)				*/
+#define PSM				0x00400000	/* Power-Up Sequence (Mode Register Before/After* Refresh)	*/
+#define PSS				0x00800000	/* Enable Power-Up Sequence on Next SDRAM Access			*/
+#define SRFS			0x01000000	/* Enable SDRAM Self-Refresh Mode							*/
+#define EBUFE			0x02000000	/* Enable External Buffering Timing							*/
+#define FBBRW			0x04000000	/* Enable Fast Back-To-Back Read To Write					*/
+#define EMREN			0x10000000	/* Extended Mode Register Enable							*/
+#define TCSR			0x20000000	/* Temp-Compensated Self-Refresh Value (85/45* Deg C)		*/
+#define CDDBG			0x40000000	/* Tristate SDRAM Controls During Bus Grant					*/
+
+/* EBIU_SDBCTL Masks																		*/
+#define EBE				0x0001		/* Enable SDRAM External Bank							*/
+#define EBSZ_16			0x0000		/* SDRAM External Bank Size = 16MB	*/
+#define EBSZ_32			0x0002		/* SDRAM External Bank Size = 32MB	*/
+#define EBSZ_64			0x0004		/* SDRAM External Bank Size = 64MB	*/
+#define EBSZ_128		0x0006		/* SDRAM External Bank Size = 128MB		*/
+#define EBSZ_256		0x0008		/* SDRAM External Bank Size = 256MB 	*/
+#define EBSZ_512		0x000A		/* SDRAM External Bank Size = 512MB		*/
+#define EBCAW_8			0x0000		/* SDRAM External Bank Column Address Width = 8 Bits	*/
+#define EBCAW_9			0x0010		/* SDRAM External Bank Column Address Width = 9 Bits	*/
+#define EBCAW_10		0x0020		/* SDRAM External Bank Column Address Width = 10 Bits	*/
+#define EBCAW_11		0x0030		/* SDRAM External Bank Column Address Width = 11 Bits	*/
+
+/* EBIU_SDSTAT Masks														*/
+#define SDCI			0x0001		/* SDRAM Controller Idle 				*/
+#define SDSRA			0x0002		/* SDRAM Self-Refresh Active			*/
+#define SDPUA			0x0004		/* SDRAM Power-Up Active 				*/
+#define SDRS			0x0008		/* SDRAM Will Power-Up On Next Access	*/
+#define SDEASE			0x0010		/* SDRAM EAB Sticky Error Status		*/
+#define BGSTAT			0x0020		/* Bus Grant Status						*/
+
+
+/* **************************  DMA CONTROLLER MASKS  ********************************/
+/* DMAx_CONFIG, MDMA_yy_CONFIG Masks												*/
+#define DMAEN			0x0001		/* DMA Channel Enable							*/
+#define WNR				0x0002		/* Channel Direction (W/R*)						*/
+#define WDSIZE_8		0x0000		/* Transfer Word Size = 8						*/
+#define WDSIZE_16		0x0004		/* Transfer Word Size = 16						*/
+#define WDSIZE_32		0x0008		/* Transfer Word Size = 32						*/
+#define DMA2D			0x0010		/* DMA Mode (2D/1D*)							*/
+#define RESTART			0x0020		/* DMA Buffer Clear								*/
+#define DI_SEL			0x0040		/* Data Interrupt Timing Select					*/
+#define DI_EN			0x0080		/* Data Interrupt Enable						*/
+#define NDSIZE_0		0x0000		/* Next Descriptor Size = 0 (Stop/Autobuffer)	*/
+#define NDSIZE_1		0x0100		/* Next Descriptor Size = 1						*/
+#define NDSIZE_2		0x0200		/* Next Descriptor Size = 2						*/
+#define NDSIZE_3		0x0300		/* Next Descriptor Size = 3						*/
+#define NDSIZE_4		0x0400		/* Next Descriptor Size = 4						*/
+#define NDSIZE_5		0x0500		/* Next Descriptor Size = 5						*/
+#define NDSIZE_6		0x0600		/* Next Descriptor Size = 6						*/
+#define NDSIZE_7		0x0700		/* Next Descriptor Size = 7						*/
+#define NDSIZE_8		0x0800		/* Next Descriptor Size = 8						*/
+#define NDSIZE_9		0x0900		/* Next Descriptor Size = 9						*/
+#define NDSIZE	        	0x0900	/* Next Descriptor Size */
+#define DMAFLOW	        	0x7000	/* Flow Control */
+#define DMAFLOW_STOP		0x0000		/* Stop Mode									*/
+#define DMAFLOW_AUTO		0x1000		/* Autobuffer Mode								*/
+#define DMAFLOW_ARRAY		0x4000		/* Descriptor Array Mode						*/
+#define DMAFLOW_SMALL		0x6000		/* Small Model Descriptor List Mode				*/
+#define DMAFLOW_LARGE		0x7000		/* Large Model Descriptor List Mode				*/
+
+/* DMAx_PERIPHERAL_MAP, MDMA_yy_PERIPHERAL_MAP Masks								*/
+#define CTYPE			0x0040	/* DMA Channel Type Indicator (Memory/Peripheral*)	*/
+#define PMAP			0xF000	/* Peripheral Mapped To This Channel				*/
+#define PMAP_PPI		0x0000	/* 		PPI Port DMA								*/
+#define	PMAP_EMACRX		0x1000	/* 		Ethernet Receive DMA						*/
+#define PMAP_EMACTX		0x2000	/* 		Ethernet Transmit DMA						*/
+#define PMAP_SPORT0RX	0x3000	/* 		SPORT0 Receive DMA							*/
+#define PMAP_SPORT0TX	0x4000	/* 		SPORT0 Transmit DMA							*/
+#define PMAP_SPORT1RX	0x5000	/* 		SPORT1 Receive DMA							*/
+#define PMAP_SPORT1TX	0x6000	/* 		SPORT1 Transmit DMA							*/
+#define PMAP_SPI		0x7000	/* 		SPI Port DMA								*/
+#define PMAP_UART0RX	0x8000	/* 		UART0 Port Receive DMA						*/
+#define PMAP_UART0TX	0x9000	/* 		UART0 Port Transmit DMA						*/
+#define	PMAP_UART1RX	0xA000	/* 		UART1 Port Receive DMA						*/
+#define	PMAP_UART1TX	0xB000	/* 		UART1 Port Transmit DMA						*/
+
+/* DMAx_IRQ_STATUS, MDMA_yy_IRQ_STATUS Masks						*/
+#define DMA_DONE		0x0001	/* DMA Completion Interrupt Status	*/
+#define DMA_ERR			0x0002	/* DMA Error Interrupt Status		*/
+#define DFETCH			0x0004	/* DMA Descriptor Fetch Indicator	*/
+#define DMA_RUN			0x0008	/* DMA Channel Running Indicator	*/
+
+
+/*  ************  PARALLEL PERIPHERAL INTERFACE (PPI) MASKS *************/
+/*  PPI_CONTROL Masks													*/
+#define PORT_EN			0x0001		/* PPI Port Enable					*/
+#define PORT_DIR		0x0002		/* PPI Port Direction				*/
+#define XFR_TYPE		0x000C		/* PPI Transfer Type				*/
+#define PORT_CFG		0x0030		/* PPI Port Configuration			*/
+#define FLD_SEL			0x0040		/* PPI Active Field Select			*/
+#define PACK_EN			0x0080		/* PPI Packing Mode					*/
+#define DMA32			0x0100		/* PPI 32-bit DMA Enable			*/
+#define SKIP_EN			0x0200		/* PPI Skip Element Enable			*/
+#define SKIP_EO			0x0400		/* PPI Skip Even/Odd Elements		*/
+#define DLEN_8			0x0000		/* Data Length = 8 Bits				*/
+#define DLEN_10			0x0800		/* Data Length = 10 Bits			*/
+#define DLEN_11			0x1000		/* Data Length = 11 Bits			*/
+#define DLEN_12			0x1800		/* Data Length = 12 Bits			*/
+#define DLEN_13			0x2000		/* Data Length = 13 Bits			*/
+#define DLEN_14			0x2800		/* Data Length = 14 Bits			*/
+#define DLEN_15			0x3000		/* Data Length = 15 Bits			*/
+#define DLEN_16			0x3800		/* Data Length = 16 Bits			*/
+#define DLENGTH			0x3800		/* PPI Data Length  */
+#define POLC			0x4000		/* PPI Clock Polarity				*/
+#define POLS			0x8000		/* PPI Frame Sync Polarity			*/
+
+/* PPI_STATUS Masks														*/
+#define FLD				0x0400		/* Field Indicator					*/
+#define FT_ERR			0x0800		/* Frame Track Error				*/
+#define OVR				0x1000		/* FIFO Overflow Error				*/
+#define UNDR			0x2000		/* FIFO Underrun Error				*/
+#define ERR_DET			0x4000		/* Error Detected Indicator			*/
+#define ERR_NCOR		0x8000		/* Error Not Corrected Indicator	*/
+
+
+/*  ********************  TWO-WIRE INTERFACE (TWI) MASKS  ***********************/
+/* TWI_CLKDIV Macros (Use: *pTWI_CLKDIV = CLKLOW(x)|CLKHI(y);  )				*/
+#define	CLKLOW(x)	((x) & 0xFF)		/* Periods Clock Is Held Low			*/
+#define CLKHI(y)	(((y)&0xFF)<<0x8)	/* Periods Before New Clock Low			*/
+
+/* TWI_PRESCALE Masks															*/
+#define	PRESCALE	0x007F		/* SCLKs Per Internal Time Reference (10MHz)	*/
+#define	TWI_ENA		0x0080		/* TWI Enable									*/
+#define	SCCB		0x0200		/* SCCB Compatibility Enable					*/
+
+/* TWI_SLAVE_CTRL Masks															*/
+#define	SEN			0x0001		/* Slave Enable									*/
+#define	SADD_LEN	0x0002		/* Slave Address Length							*/
+#define	STDVAL		0x0004		/* Slave Transmit Data Valid					*/
+#define	NAK			0x0008		/* NAK/ACK* Generated At Conclusion Of Transfer */
+#define	GEN			0x0010		/* General Call Adrress Matching Enabled		*/
+
+/* TWI_SLAVE_STAT Masks															*/
+#define	SDIR		0x0001		/* Slave Transfer Direction (Transmit/Receive*)	*/
+#define GCALL		0x0002		/* General Call Indicator						*/
+
+/* TWI_MASTER_CTRL Masks													*/
+#define	MEN			0x0001		/* Master Mode Enable						*/
+#define	MADD_LEN	0x0002		/* Master Address Length					*/
+#define	MDIR		0x0004		/* Master Transmit Direction (RX/TX*)		*/
+#define	FAST		0x0008		/* Use Fast Mode Timing Specs				*/
+#define	STOP		0x0010		/* Issue Stop Condition						*/
+#define	RSTART		0x0020		/* Repeat Start or Stop* At End Of Transfer	*/
+#define	DCNT		0x3FC0		/* Data Bytes To Transfer					*/
+#define	SDAOVR		0x4000		/* Serial Data Override						*/
+#define	SCLOVR		0x8000		/* Serial Clock Override					*/
+
+/* TWI_MASTER_STAT Masks														*/
+#define	MPROG		0x0001		/* Master Transfer In Progress					*/
+#define	LOSTARB		0x0002		/* Lost Arbitration Indicator (Xfer Aborted)	*/
+#define	ANAK		0x0004		/* Address Not Acknowledged						*/
+#define	DNAK		0x0008		/* Data Not Acknowledged						*/
+#define	BUFRDERR	0x0010		/* Buffer Read Error							*/
+#define	BUFWRERR	0x0020		/* Buffer Write Error							*/
+#define	SDASEN		0x0040		/* Serial Data Sense							*/
+#define	SCLSEN		0x0080		/* Serial Clock Sense							*/
+#define	BUSBUSY		0x0100		/* Bus Busy Indicator							*/
+
+/* TWI_INT_SRC and TWI_INT_ENABLE Masks						*/
+#define	SINIT		0x0001		/* Slave Transfer Initiated	*/
+#define	SCOMP		0x0002		/* Slave Transfer Complete	*/
+#define	SERR		0x0004		/* Slave Transfer Error		*/
+#define	SOVF		0x0008		/* Slave Overflow			*/
+#define	MCOMP		0x0010		/* Master Transfer Complete	*/
+#define	MERR		0x0020		/* Master Transfer Error	*/
+#define	XMTSERV		0x0040		/* Transmit FIFO Service	*/
+#define	RCVSERV		0x0080		/* Receive FIFO Service		*/
+
+/* TWI_FIFO_CTRL Masks												*/
+#define	XMTFLUSH	0x0001		/* Transmit Buffer Flush			*/
+#define	RCVFLUSH	0x0002		/* Receive Buffer Flush				*/
+#define	XMTINTLEN	0x0004		/* Transmit Buffer Interrupt Length	*/
+#define	RCVINTLEN	0x0008		/* Receive Buffer Interrupt Length	*/
+
+/* TWI_FIFO_STAT Masks															*/
+#define	XMTSTAT		0x0003		/* Transmit FIFO Status							*/
+#define	XMT_EMPTY	0x0000		/* 		Transmit FIFO Empty						*/
+#define	XMT_HALF	0x0001		/* 		Transmit FIFO Has 1 Byte To Write		*/
+#define	XMT_FULL	0x0003		/* 		Transmit FIFO Full (2 Bytes To Write)	*/
+
+#define	RCVSTAT		0x000C		/* Receive FIFO Status							*/
+#define	RCV_EMPTY	0x0000		/* 		Receive FIFO Empty						*/
+#define	RCV_HALF	0x0004		/* 		Receive FIFO Has 1 Byte To Read			*/
+#define	RCV_FULL	0x000C		/* 		Receive FIFO Full (2 Bytes To Read)		*/
+
+
+/* Omit CAN masks from defBF534.h */
+
+/*  *******************  PIN CONTROL REGISTER MASKS  ************************/
+/* PORT_MUX Masks															*/
+#define	PJSE			0x0001			/* Port J SPI/SPORT Enable			*/
+#define	PJSE_SPORT		0x0000			/* 		Enable TFS0/DT0PRI			*/
+#define	PJSE_SPI		0x0001			/* 		Enable SPI_SSEL3:2			*/
+
+#define	PJCE(x)			(((x)&0x3)<<1)	/* Port J CAN/SPI/SPORT Enable		*/
+#define	PJCE_SPORT		0x0000			/* 		Enable DR0SEC/DT0SEC		*/
+#define	PJCE_CAN		0x0002			/* 		Enable CAN RX/TX			*/
+#define	PJCE_SPI		0x0004			/* 		Enable SPI_SSEL7			*/
+
+#define	PFDE			0x0008			/* Port F DMA Request Enable		*/
+#define	PFDE_UART		0x0000			/* 		Enable UART0 RX/TX			*/
+#define	PFDE_DMA		0x0008			/* 		Enable DMAR1:0				*/
+
+#define	PFTE			0x0010			/* Port F Timer Enable				*/
+#define	PFTE_UART		0x0000			/*		Enable UART1 RX/TX			*/
+#define	PFTE_TIMER		0x0010			/* 		Enable TMR7:6				*/
+
+#define	PFS6E			0x0020			/* Port F SPI SSEL 6 Enable			*/
+#define	PFS6E_TIMER		0x0000			/*		Enable TMR5					*/
+#define	PFS6E_SPI		0x0020			/* 		Enable SPI_SSEL6			*/
+
+#define	PFS5E			0x0040			/* Port F SPI SSEL 5 Enable			*/
+#define	PFS5E_TIMER		0x0000			/*		Enable TMR4					*/
+#define	PFS5E_SPI		0x0040			/* 		Enable SPI_SSEL5			*/
+
+#define	PFS4E			0x0080			/* Port F SPI SSEL 4 Enable			*/
+#define	PFS4E_TIMER		0x0000			/*		Enable TMR3					*/
+#define	PFS4E_SPI		0x0080			/* 		Enable SPI_SSEL4			*/
+
+#define	PFFE			0x0100			/* Port F PPI Frame Sync Enable		*/
+#define	PFFE_TIMER		0x0000			/* 		Enable TMR2					*/
+#define	PFFE_PPI		0x0100			/* 		Enable PPI FS3				*/
+
+#define	PGSE			0x0200			/* Port G SPORT1 Secondary Enable	*/
+#define	PGSE_PPI		0x0000			/* 		Enable PPI D9:8				*/
+#define	PGSE_SPORT		0x0200			/* 		Enable DR1SEC/DT1SEC		*/
+
+#define	PGRE			0x0400			/* Port G SPORT1 Receive Enable		*/
+#define	PGRE_PPI		0x0000			/* 		Enable PPI D12:10			*/
+#define	PGRE_SPORT		0x0400			/* 		Enable DR1PRI/RFS1/RSCLK1	*/
+
+#define	PGTE			0x0800			/* Port G SPORT1 Transmit Enable	*/
+#define	PGTE_PPI		0x0000			/* 		Enable PPI D15:13			*/
+#define	PGTE_SPORT		0x0800			/* 		Enable DT1PRI/TFS1/TSCLK1	*/
+
+
+/*  ******************  HANDSHAKE DMA (HDMA) MASKS  *********************/
+/* HDMAx_CTL Masks														*/
+#define	HMDMAEN		0x0001	/* Enable Handshake DMA 0/1					*/
+#define	REP			0x0002	/* HDMA Request Polarity					*/
+#define	UTE			0x0004	/* Urgency Threshold Enable					*/
+#define	OIE			0x0010	/* Overflow Interrupt Enable				*/
+#define	BDIE		0x0020	/* Block Done Interrupt Enable				*/
+#define	MBDI		0x0040	/* Mask Block Done IRQ If Pending ECNT		*/
+#define	DRQ			0x0300	/* HDMA Request Type						*/
+#define	DRQ_NONE	0x0000	/* 		No Request							*/
+#define	DRQ_SINGLE	0x0100	/* 		Channels Request Single				*/
+#define	DRQ_MULTI	0x0200	/* 		Channels Request Multi (Default)	*/
+#define	DRQ_URGENT	0x0300	/* 		Channels Request Multi Urgent		*/
+#define	RBC			0x1000	/* Reload BCNT With IBCNT					*/
+#define	PS			0x2000	/* HDMA Pin Status							*/
+#define	OI			0x4000	/* Overflow Interrupt Generated				*/
+#define	BDI			0x8000	/* Block Done Interrupt Generated			*/
+
+/* entry addresses of the user-callable Boot ROM functions */
+
+#define _BOOTROM_RESET 0xEF000000 
+#define _BOOTROM_FINAL_INIT 0xEF000002 
+#define _BOOTROM_DO_MEMORY_DMA 0xEF000006
+#define _BOOTROM_BOOT_DXE_FLASH 0xEF000008 
+#define _BOOTROM_BOOT_DXE_SPI 0xEF00000A 
+#define _BOOTROM_BOOT_DXE_TWI 0xEF00000C 
+#define _BOOTROM_GET_DXE_ADDRESS_FLASH 0xEF000010
+#define _BOOTROM_GET_DXE_ADDRESS_SPI 0xEF000012
+#define _BOOTROM_GET_DXE_ADDRESS_TWI 0xEF000014
+
+/* Alternate Deprecated Macros Provided For Backwards Code Compatibility */
+#define	PGDE_UART   PFDE_UART
+#define	PGDE_DMA    PFDE_DMA
+#define	CKELOW		SCKELOW
+
+/* ==== end from defBF534.h ==== */
+
+/* HOST Port Registers */
+
+#define                     HOST_CONTROL  0xffc03400   /* HOST Control Register */
+#define                      HOST_STATUS  0xffc03404   /* HOST Status Register */
+#define                     HOST_TIMEOUT  0xffc03408   /* HOST Acknowledge Mode Timeout Register */
+
+/* Counter Registers */
+
+#define                       CNT_CONFIG  0xffc03500   /* Configuration Register */
+#define                        CNT_IMASK  0xffc03504   /* Interrupt Mask Register */
+#define                       CNT_STATUS  0xffc03508   /* Status Register */
+#define                      CNT_COMMAND  0xffc0350c   /* Command Register */
+#define                     CNT_DEBOUNCE  0xffc03510   /* Debounce Register */
+#define                      CNT_COUNTER  0xffc03514   /* Counter Register */
+#define                          CNT_MAX  0xffc03518   /* Maximal Count Register */
+#define                          CNT_MIN  0xffc0351c   /* Minimal Count Register */
+
+/* OTP/FUSE Registers */
+
+#define                      OTP_CONTROL  0xffc03600   /* OTP/Fuse Control Register */
+#define                          OTP_BEN  0xffc03604   /* OTP/Fuse Byte Enable */
+#define                       OTP_STATUS  0xffc03608   /* OTP/Fuse Status */
+#define                       OTP_TIMING  0xffc0360c   /* OTP/Fuse Access Timing */
+
+/* Security Registers */
+
+#define                    SECURE_SYSSWT  0xffc03620   /* Secure System Switches */
+#define                   SECURE_CONTROL  0xffc03624   /* Secure Control */
+#define                    SECURE_STATUS  0xffc03628   /* Secure Status */
+
+/* OTP Read/Write Data Buffer Registers */
+
+#define                        OTP_DATA0  0xffc03680   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+#define                        OTP_DATA1  0xffc03684   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+#define                        OTP_DATA2  0xffc03688   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+#define                        OTP_DATA3  0xffc0368c   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+
+/* NFC Registers */
+
+#define                          NFC_CTL  0xffc03700   /* NAND Control Register */
+#define                         NFC_STAT  0xffc03704   /* NAND Status Register */
+#define                      NFC_IRQSTAT  0xffc03708   /* NAND Interrupt Status Register */
+#define                      NFC_IRQMASK  0xffc0370c   /* NAND Interrupt Mask Register */
+#define                         NFC_ECC0  0xffc03710   /* NAND ECC Register 0 */
+#define                         NFC_ECC1  0xffc03714   /* NAND ECC Register 1 */
+#define                         NFC_ECC2  0xffc03718   /* NAND ECC Register 2 */
+#define                         NFC_ECC3  0xffc0371c   /* NAND ECC Register 3 */
+#define                        NFC_COUNT  0xffc03720   /* NAND ECC Count Register */
+#define                          NFC_RST  0xffc03724   /* NAND ECC Reset Register */
+#define                        NFC_PGCTL  0xffc03728   /* NAND Page Control Register */
+#define                         NFC_READ  0xffc0372c   /* NAND Read Data Register */
+#define                         NFC_ADDR  0xffc03740   /* NAND Address Register */
+#define                          NFC_CMD  0xffc03744   /* NAND Command Register */
+#define                      NFC_DATA_WR  0xffc03748   /* NAND Data Write Register */
+#define                      NFC_DATA_RD  0xffc0374c   /* NAND Data Read Register */
+
+/* ********************************************************** */
+/*     SINGLE BIT MACRO PAIRS (bit mask and negated one)      */
+/*     and MULTI BIT READ MACROS                              */
+/* ********************************************************** */
+
+/* Bit masks for HOST_CONTROL */
+
+#define                   HOST_EN  0x1        /* Host Enable */
+#define                  nHOST_EN  0x0       
+#define                  HOST_END  0x2        /* Host Endianess */
+#define                 nHOST_END  0x0       
+#define                 DATA_SIZE  0x4        /* Data Size */
+#define                nDATA_SIZE  0x0       
+#define                  HOST_RST  0x8        /* Host Reset */
+#define                 nHOST_RST  0x0       
+#define                  HRDY_OVR  0x20       /* Host Ready Override */
+#define                 nHRDY_OVR  0x0       
+#define                  INT_MODE  0x40       /* Interrupt Mode */
+#define                 nINT_MODE  0x0       
+#define                     BT_EN  0x80       /* Bus Timeout Enable */
+#define                    nBT_EN  0x0       
+#define                       EHW  0x100      /* Enable Host Write */
+#define                      nEHW  0x0       
+#define                       EHR  0x200      /* Enable Host Read */
+#define                      nEHR  0x0       
+#define                       BDR  0x400      /* Burst DMA Requests */
+#define                      nBDR  0x0       
+
+/* Bit masks for HOST_STATUS */
+
+#define                     READY  0x1        /* DMA Ready */
+#define                    nREADY  0x0       
+#define                  FIFOFULL  0x2        /* FIFO Full */
+#define                 nFIFOFULL  0x0       
+#define                 FIFOEMPTY  0x4        /* FIFO Empty */
+#define                nFIFOEMPTY  0x0       
+#define                  COMPLETE  0x8        /* DMA Complete */
+#define                 nCOMPLETE  0x0       
+#define                      HSHK  0x10       /* Host Handshake */
+#define                     nHSHK  0x0       
+#define                   TIMEOUT  0x20       /* Host Timeout */
+#define                  nTIMEOUT  0x0       
+#define                      HIRQ  0x40       /* Host Interrupt Request */
+#define                     nHIRQ  0x0       
+#define                ALLOW_CNFG  0x80       /* Allow New Configuration */
+#define               nALLOW_CNFG  0x0       
+#define                   DMA_DIR  0x100      /* DMA Direction */
+#define                  nDMA_DIR  0x0       
+#define                       BTE  0x200      /* Bus Timeout Enabled */
+#define                      nBTE  0x0       
+#define               HOSTRD_DONE  0x8000     /* Host Read Completion Interrupt */
+#define              nHOSTRD_DONE  0x0
+
+/* Bit masks for HOST_TIMEOUT */
+
+#define             COUNT_TIMEOUT  0x7ff      /* Host Timeout count */
+
+/* Bit masks for CNT_CONFIG */
+
+#define                      CNTE  0x1        /* Counter Enable */
+#define                     nCNTE  0x0       
+#define                      DEBE  0x2        /* Debounce Enable */
+#define                     nDEBE  0x0       
+#define                    CDGINV  0x10       /* CDG Pin Polarity Invert */
+#define                   nCDGINV  0x0       
+#define                    CUDINV  0x20       /* CUD Pin Polarity Invert */
+#define                   nCUDINV  0x0       
+#define                    CZMINV  0x40       /* CZM Pin Polarity Invert */
+#define                   nCZMINV  0x0       
+#define                   CNTMODE  0x700      /* Counter Operating Mode */
+#define                      ZMZC  0x800      /* CZM Zeroes Counter Enable */
+#define                     nZMZC  0x0       
+#define                   BNDMODE  0x3000     /* Boundary register Mode */
+#define                    INPDIS  0x8000     /* CUG and CDG Input Disable */
+#define                   nINPDIS  0x0       
+
+/* Bit masks for CNT_IMASK */
+
+#define                      ICIE  0x1        /* Illegal Gray/Binary Code Interrupt Enable */
+#define                     nICIE  0x0       
+#define                      UCIE  0x2        /* Up count Interrupt Enable */
+#define                     nUCIE  0x0       
+#define                      DCIE  0x4        /* Down count Interrupt Enable */
+#define                     nDCIE  0x0       
+#define                    MINCIE  0x8        /* Min Count Interrupt Enable */
+#define                   nMINCIE  0x0       
+#define                    MAXCIE  0x10       /* Max Count Interrupt Enable */
+#define                   nMAXCIE  0x0       
+#define                   COV31IE  0x20       /* Bit 31 Overflow Interrupt Enable */
+#define                  nCOV31IE  0x0       
+#define                   COV15IE  0x40       /* Bit 15 Overflow Interrupt Enable */
+#define                  nCOV15IE  0x0       
+#define                   CZEROIE  0x80       /* Count to Zero Interrupt Enable */
+#define                  nCZEROIE  0x0       
+#define                     CZMIE  0x100      /* CZM Pin Interrupt Enable */
+#define                    nCZMIE  0x0       
+#define                    CZMEIE  0x200      /* CZM Error Interrupt Enable */
+#define                   nCZMEIE  0x0       
+#define                    CZMZIE  0x400      /* CZM Zeroes Counter Interrupt Enable */
+#define                   nCZMZIE  0x0       
+
+/* Bit masks for CNT_STATUS */
+
+#define                      ICII  0x1        /* Illegal Gray/Binary Code Interrupt Identifier */
+#define                     nICII  0x0       
+#define                      UCII  0x2        /* Up count Interrupt Identifier */
+#define                     nUCII  0x0       
+#define                      DCII  0x4        /* Down count Interrupt Identifier */
+#define                     nDCII  0x0       
+#define                    MINCII  0x8        /* Min Count Interrupt Identifier */
+#define                   nMINCII  0x0       
+#define                    MAXCII  0x10       /* Max Count Interrupt Identifier */
+#define                   nMAXCII  0x0       
+#define                   COV31II  0x20       /* Bit 31 Overflow Interrupt Identifier */
+#define                  nCOV31II  0x0       
+#define                   COV15II  0x40       /* Bit 15 Overflow Interrupt Identifier */
+#define                  nCOV15II  0x0       
+#define                   CZEROII  0x80       /* Count to Zero Interrupt Identifier */
+#define                  nCZEROII  0x0       
+#define                     CZMII  0x100      /* CZM Pin Interrupt Identifier */
+#define                    nCZMII  0x0       
+#define                    CZMEII  0x200      /* CZM Error Interrupt Identifier */
+#define                   nCZMEII  0x0       
+#define                    CZMZII  0x400      /* CZM Zeroes Counter Interrupt Identifier */
+#define                   nCZMZII  0x0       
+
+/* Bit masks for CNT_COMMAND */
+
+#define                    W1LCNT  0xf        /* Load Counter Register */
+#define                    W1LMIN  0xf0       /* Load Min Register */
+#define                    W1LMAX  0xf00      /* Load Max Register */
+#define                  W1ZMONCE  0x1000     /* Enable CZM Clear Counter Once */
+#define                 nW1ZMONCE  0x0       
+
+/* Bit masks for CNT_DEBOUNCE */
+
+#define                 DPRESCALE  0xf        /* Load Counter Register */
+
+/* Bit masks for OTP_CONTROL */
+
+#define                FUSE_FADDR  0x1ff      /* OTP/Fuse Address */
+#define                      FIEN  0x800      /* OTP/Fuse Interrupt Enable */
+#define                     nFIEN  0x0       
+#define                  FTESTDEC  0x1000     /* OTP/Fuse Test Decoder */
+#define                 nFTESTDEC  0x0       
+#define                   FWRTEST  0x2000     /* OTP/Fuse Write Test */
+#define                  nFWRTEST  0x0       
+#define                     FRDEN  0x4000     /* OTP/Fuse Read Enable */
+#define                    nFRDEN  0x0       
+#define                     FWREN  0x8000     /* OTP/Fuse Write Enable */
+#define                    nFWREN  0x0       
+
+/* Bit masks for OTP_BEN */
+
+#define                      FBEN  0xffff     /* OTP/Fuse Byte Enable */
+
+/* Bit masks for OTP_STATUS */
+
+#define                     FCOMP  0x1        /* OTP/Fuse Access Complete */
+#define                    nFCOMP  0x0       
+#define                    FERROR  0x2        /* OTP/Fuse Access Error */
+#define                   nFERROR  0x0       
+#define                  MMRGLOAD  0x10       /* Memory Mapped Register Gasket Load */
+#define                 nMMRGLOAD  0x0       
+#define                  MMRGLOCK  0x20       /* Memory Mapped Register Gasket Lock */
+#define                 nMMRGLOCK  0x0       
+#define                    FPGMEN  0x40       /* OTP/Fuse Program Enable */
+#define                   nFPGMEN  0x0       
+
+/* Bit masks for OTP_TIMING */
+
+#define                   USECDIV  0xff       /* Micro Second Divider */
+#define                   READACC  0x7f00     /* Read Access Time */
+#define                   CPUMPRL  0x38000    /* Charge Pump Release Time */
+#define                   CPUMPSU  0xc0000    /* Charge Pump Setup Time */
+#define                   CPUMPHD  0xf00000   /* Charge Pump Hold Time */
+#define                   PGMTIME  0xff000000 /* Program Time */
+
+/* Bit masks for SECURE_SYSSWT */
+
+#define                   EMUDABL  0x1        /* Emulation Disable. */
+#define                  nEMUDABL  0x0       
+#define                   RSTDABL  0x2        /* Reset Disable */
+#define                  nRSTDABL  0x0       
+#define                   L1IDABL  0x1c       /* L1 Instruction Memory Disable. */
+#define                  L1DADABL  0xe0       /* L1 Data Bank A Memory Disable. */
+#define                  L1DBDABL  0x700      /* L1 Data Bank B Memory Disable. */
+#define                   DMA0OVR  0x800      /* DMA0 Memory Access Override */
+#define                  nDMA0OVR  0x0       
+#define                   DMA1OVR  0x1000     /* DMA1 Memory Access Override */
+#define                  nDMA1OVR  0x0       
+#define                    EMUOVR  0x4000     /* Emulation Override */
+#define                   nEMUOVR  0x0       
+#define                    OTPSEN  0x8000     /* OTP Secrets Enable. */
+#define                   nOTPSEN  0x0       
+#define                    L2DABL  0x70000    /* L2 Memory Disable. */
+
+/* Bit masks for SECURE_CONTROL */
+
+#define                   SECURE0  0x1        /* SECURE 0 */
+#define                  nSECURE0  0x0       
+#define                   SECURE1  0x2        /* SECURE 1 */
+#define                  nSECURE1  0x0       
+#define                   SECURE2  0x4        /* SECURE 2 */
+#define                  nSECURE2  0x0       
+#define                   SECURE3  0x8        /* SECURE 3 */
+#define                  nSECURE3  0x0       
+
+/* Bit masks for SECURE_STATUS */
+
+#define                   SECMODE  0x3        /* Secured Mode Control State */
+#define                       NMI  0x4        /* Non Maskable Interrupt */
+#define                      nNMI  0x0       
+#define                   AFVALID  0x8        /* Authentication Firmware Valid */
+#define                  nAFVALID  0x0       
+#define                    AFEXIT  0x10       /* Authentication Firmware Exit */
+#define                   nAFEXIT  0x0       
+#define                   SECSTAT  0xe0       /* Secure Status */
+
+/* Bit masks for NFC_CTL */
+
+#define                    WR_DLY  0xf        /* Write Strobe Delay */
+#define                    RD_DLY  0xf0       /* Read Strobe Delay */
+#define                    NWIDTH  0x100      /* NAND Data Width */
+#define                   nNWIDTH  0x0       
+#define                   PG_SIZE  0x200      /* Page Size */
+#define                  nPG_SIZE  0x0       
+
+/* Bit masks for NFC_STAT */
+
+#define                     NBUSY  0x1        /* Not Busy */
+#define                    nNBUSY  0x0       
+#define                   WB_FULL  0x2        /* Write Buffer Full */
+#define                  nWB_FULL  0x0       
+#define                PG_WR_STAT  0x4        /* Page Write Pending */
+#define               nPG_WR_STAT  0x0       
+#define                PG_RD_STAT  0x8        /* Page Read Pending */
+#define               nPG_RD_STAT  0x0       
+#define                  WB_EMPTY  0x10       /* Write Buffer Empty */
+#define                 nWB_EMPTY  0x0       
+
+/* Bit masks for NFC_IRQSTAT */
+
+#define                  NBUSYIRQ  0x1        /* Not Busy IRQ */
+#define                 nNBUSYIRQ  0x0       
+#define                    WB_OVF  0x2        /* Write Buffer Overflow */
+#define                   nWB_OVF  0x0       
+#define                   WB_EDGE  0x4        /* Write Buffer Edge Detect */
+#define                  nWB_EDGE  0x0       
+#define                    RD_RDY  0x8        /* Read Data Ready */
+#define                   nRD_RDY  0x0       
+#define                   WR_DONE  0x10       /* Page Write Done */
+#define                  nWR_DONE  0x0       
+
+/* Bit masks for NFC_IRQMASK */
+
+#define              MASK_BUSYIRQ  0x1        /* Mask Not Busy IRQ */
+#define             nMASK_BUSYIRQ  0x0       
+#define                MASK_WBOVF  0x2        /* Mask Write Buffer Overflow */
+#define               nMASK_WBOVF  0x0       
+#define              MASK_WBEMPTY  0x4        /* Mask Write Buffer Empty */
+#define             nMASK_WBEMPTY  0x0       
+#define                MASK_RDRDY  0x8        /* Mask Read Data Ready */
+#define               nMASK_RDRDY  0x0       
+#define               MASK_WRDONE  0x10       /* Mask Write Done */
+#define              nMASK_WRDONE  0x0       
+
+/* Bit masks for NFC_RST */
+
+#define                   ECC_RST  0x1        /* ECC (and NFC counters) Reset */
+#define                  nECC_RST  0x0       
+
+/* Bit masks for NFC_PGCTL */
+
+#define               PG_RD_START  0x1        /* Page Read Start */
+#define              nPG_RD_START  0x0       
+#define               PG_WR_START  0x2        /* Page Write Start */
+#define              nPG_WR_START  0x0       
+
+/* Bit masks for NFC_ECC0 */
+
+#define                      ECC0  0x7ff      /* Parity Calculation Result0 */
+
+/* Bit masks for NFC_ECC1 */
+
+#define                      ECC1  0x7ff      /* Parity Calculation Result1 */
+
+/* Bit masks for NFC_ECC2 */
+
+#define                      ECC2  0x7ff      /* Parity Calculation Result2 */
+
+/* Bit masks for NFC_ECC3 */
+
+#define                      ECC3  0x7ff      /* Parity Calculation Result3 */
+
+/* Bit masks for NFC_COUNT */
+
+#define                    ECCCNT  0x3ff      /* Transfer Count */
+
+
+#endif /* _DEF_BF52X_H */
diff --git a/include/asm-blackfin/mach-bf533/cdefBF532.h b/include/asm-blackfin/mach-bf533/cdefBF532.h
index 1d7c494..74f967b 100644
--- a/include/asm-blackfin/mach-bf533/cdefBF532.h
+++ b/include/asm-blackfin/mach-bf533/cdefBF532.h
@@ -51,10 +51,6 @@
 #define bfin_read_PLL_LOCKCNT()              bfin_read16(PLL_LOCKCNT)
 #define bfin_write_PLL_LOCKCNT(val)          bfin_write16(PLL_LOCKCNT,val)
 #define bfin_read_CHIPID()                   bfin_read32(CHIPID)
-#define bfin_read_SWRST()                    bfin_read16(SWRST)
-#define bfin_write_SWRST(val)                bfin_write16(SWRST,val)
-#define bfin_read_SYSCR()                    bfin_read16(SYSCR)
-#define bfin_write_SYSCR(val)                bfin_write16(SYSCR,val)
 #define bfin_read_PLL_DIV()                  bfin_read16(PLL_DIV)
 #define bfin_write_PLL_DIV(val)              bfin_write16(PLL_DIV,val)
 #define bfin_read_VR_CTL()                   bfin_read16(VR_CTL)
@@ -63,12 +59,14 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 {
 	unsigned long flags, iwr;
 
-	bfin_write16(VR_CTL, val);
-	__builtin_bfin_ssync();
 	/* Enable the PLL Wakeup bit in SIC IWR */
 	iwr = bfin_read32(SIC_IWR);
 	/* Only allow PPL Wakeup) */
 	bfin_write32(SIC_IWR, IWR_ENABLE(0));
+
+	bfin_write16(VR_CTL, val);
+	__builtin_bfin_ssync();
+
 	local_irq_save(flags);
 	asm("IDLE;");
 	local_irq_restore(flags);
@@ -76,6 +74,10 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 }
 
 /* System Interrupt Controller (0xFFC0 0C00-0xFFC0 0FFF) */
+#define bfin_read_SWRST()                    bfin_read16(SWRST)
+#define bfin_write_SWRST(val)                bfin_write16(SWRST,val)
+#define bfin_read_SYSCR()                    bfin_read16(SYSCR)
+#define bfin_write_SYSCR(val)                bfin_write16(SYSCR,val)
 #define bfin_read_SIC_IAR0()                 bfin_read32(SIC_IAR0)
 #define bfin_write_SIC_IAR0(val)             bfin_write32(SIC_IAR0,val)
 #define bfin_read_SIC_IAR1()                 bfin_read32(SIC_IAR1)
@@ -115,6 +117,18 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 #define bfin_read_RTC_PREN()                 bfin_read16(RTC_PREN)
 #define bfin_write_RTC_PREN(val)             bfin_write16(RTC_PREN,val)
 
+/* DMA Traffic controls */
+#define bfin_read_DMA_TCPER()                bfin_read16(DMA_TCPER)
+#define bfin_write_DMA_TCPER(val)            bfin_write16(DMA_TCPER,val)
+#define bfin_read_DMA_TCCNT()                bfin_read16(DMA_TCCNT)
+#define bfin_write_DMA_TCCNT(val)            bfin_write16(DMA_TCCNT,val)
+
+/* Alternate deprecated register names (below) provided for backwards code compatibility */
+#define bfin_read_DMA_TC_PER()               bfin_read16(DMA_TC_PER)
+#define bfin_write_DMA_TC_PER(val)           bfin_write16(DMA_TC_PER,val)
+#define bfin_read_DMA_TC_CNT()               bfin_read16(DMA_TC_CNT)
+#define bfin_write_DMA_TC_CNT(val)           bfin_write16(DMA_TC_CNT,val)
+
 /* General Purpose IO (0xFFC0 2400-0xFFC0 27FF) */
 #define bfin_read_FIO_DIR()                  bfin_read16(FIO_DIR)
 #define bfin_write_FIO_DIR(val)              bfin_write16(FIO_DIR,val)
@@ -151,16 +165,6 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 #define bfin_read_FIO_MASKB_T()              bfin_read16(FIO_MASKB_T)
 #define bfin_write_FIO_MASKB_T(val)          bfin_write16(FIO_MASKB_T,val)
 
-/* DMA Traffic controls */
-#define bfin_read_DMA_TCPER()                bfin_read16(DMA_TCPER)
-#define bfin_write_DMA_TCPER(val)            bfin_write16(DMA_TCPER,val)
-#define bfin_read_DMA_TCCNT()                bfin_read16(DMA_TCCNT)
-#define bfin_write_DMA_TCCNT(val)            bfin_write16(DMA_TCCNT,val)
-#define bfin_read_DMA_TC_PER()               bfin_read16(DMA_TC_PER)
-#define bfin_write_DMA_TC_PER(val)           bfin_write16(DMA_TC_PER,val)
-#define bfin_read_DMA_TC_CNT()               bfin_read16(DMA_TC_CNT)
-#define bfin_write_DMA_TC_CNT(val)           bfin_write16(DMA_TC_CNT,val)
-
 /* DMA Controller */
 #define bfin_read_DMA0_CONFIG()              bfin_read16(DMA0_CONFIG)
 #define bfin_write_DMA0_CONFIG(val)          bfin_write16(DMA0_CONFIG,val)
diff --git a/include/asm-blackfin/mach-bf533/defBF532.h b/include/asm-blackfin/mach-bf533/defBF532.h
index b240a08..6a3cf93 100644
--- a/include/asm-blackfin/mach-bf533/defBF532.h
+++ b/include/asm-blackfin/mach-bf533/defBF532.h
@@ -46,11 +46,7 @@
 
 #ifndef _DEF_BF532_H
 #define _DEF_BF532_H
-/*
-#if !defined(__ADSPLPBLACKFIN__)
-#warning defBF532.h should only be included for 532 compatible chips
-#endif
-*/
+
 /* include all Core registers and bit definitions */
 #include <asm/mach-common/def_LPBlackfin.h>
 
@@ -65,10 +61,10 @@
 #define PLL_STAT               0xFFC0000C	/* PLL Status register (16-bit) */
 #define PLL_LOCKCNT            0xFFC00010	/* PLL Lock Count register (16-bit) */
 #define CHIPID                 0xFFC00014       /* Chip ID Register */
-#define SWRST                  0xFFC00100	/* Software Reset Register (16-bit) */
-#define SYSCR                  0xFFC00104	/* System Configuration registe */
 
 /* System Interrupt Controller (0xFFC00100 - 0xFFC001FF) */
+#define SWRST			0xFFC00100  /* Software Reset Register (16-bit) */
+#define SYSCR			0xFFC00104  /* System Configuration registe */
 #define SIC_RVECT             		0xFFC00108	/* Interrupt Reset Vector Address Register */
 #define SIC_IMASK             		0xFFC0010C	/* Interrupt Mask Register */
 #define SIC_IAR0               		0xFFC00110	/* Interrupt Assignment Register 0 */
@@ -218,11 +214,13 @@
 #define EBIU_SDSTAT			0xFFC00A1C	/* SDRAM Status Register */
 
 /* DMA Traffic controls */
-#define DMA_TCPER 0xFFC00B0C	/* Traffic Control Periods Register */
-#define DMA_TCCNT 0xFFC00B10	/* Traffic Control Current Counts Register */
 #define DMA_TC_PER 0xFFC00B0C	/* Traffic Control Periods Register */
 #define DMA_TC_CNT 0xFFC00B10	/* Traffic Control Current Counts Register */
 
+/* Alternate deprecated register names (below) provided for backwards code compatibility */
+#define DMA_TCPER 0xFFC00B0C	/* Traffic Control Periods Register */
+#define DMA_TCCNT 0xFFC00B10	/* Traffic Control Current Counts Register */
+
 /* DMA Controller (0xFFC00C00 - 0xFFC00FFF) */
 #define DMA0_CONFIG		0xFFC00C08	/* DMA Channel 0 Configuration Register */
 #define DMA0_NEXT_DESC_PTR	0xFFC00C00	/* DMA Channel 0 Next Descriptor Pointer Register */
@@ -407,14 +405,25 @@
 /* ********************* PLL AND RESET MASKS ************************ */
 
 /* PLL_CTL Masks */
-#define PLL_CLKIN              0x00000000	/* Pass CLKIN to PLL */
-#define PLL_CLKIN_DIV2         0x00000001	/* Pass CLKIN/2 to PLL */
-#define PLL_OFF                0x00000002	/* Shut off PLL clocks */
-#define STOPCK_OFF             0x00000008	/* Core clock off */
-#define PDWN                   0x00000020	/* Put the PLL in a Deep Sleep state */
-#define BYPASS                 0x00000100	/* Bypass the PLL */
+#define PLL_CLKIN			0x0000  /* Pass CLKIN to PLL */
+#define PLL_CLKIN_DIV2			0x0001  /* Pass CLKIN/2 to PLL */
+#define DF				0x0001	/* 0: PLL = CLKIN, 1: PLL = CLKIN/2					*/
+#define PLL_OFF				0x0002  /* Shut off PLL clocks */
+#define STOPCK_OFF			0x0008  /* Core clock off */
+#define STOPCK				0x0008	/* Core Clock Off									*/
+#define PDWN				0x0020  /* Put the PLL in a Deep Sleep state */
+#if !defined(__ADSPBF538__)
+/* this file is included in defBF538.h but IN_DELAY/OUT_DELAY are different */
+# define IN_DELAY        0x0040  /* Add 200ps Delay To EBIU Input Latches */
+# define OUT_DELAY       0x0080  /* Add 200ps Delay To EBIU Output Signals */
+#endif
+#define BYPASS				0x0100  /* Bypass the PLL */
+/* PLL_CTL Macros (Only Use With Logic OR While Setting Lower Order Bits)			*/
+#define	SET_MSEL(x)		(((x)&0x3F) << 0x9)	/* Set MSEL = 0-63 --> VCO = CLKIN*MSEL		*/
 
 /* PLL_DIV Masks */
+#define SSEL				0x000F	/* System Select						*/
+#define	CSEL				0x0030	/* Core Select							*/
 
 #define SCLK_DIV(x)  (x)	/* SCLK = VCO / x */
 
@@ -422,6 +431,8 @@
 #define CCLK_DIV2              0x00000010	/* CCLK = VCO / 2 */
 #define CCLK_DIV4              0x00000020	/* CCLK = VCO / 4 */
 #define CCLK_DIV8              0x00000030	/* CCLK = VCO / 8 */
+/* PLL_DIV Macros														*/
+#define SET_SSEL(x)			((x)&0xF)	/* Set SSEL = 0-15 --> SCLK = VCO/SSEL	*/
 
 /* PLL_STAT Masks																	*/
 #define ACTIVE_PLLENABLED	0x0001	/* Processor In Active Mode With PLL Enabled    */
@@ -429,13 +440,47 @@
 #define ACTIVE_PLLDISABLED	0x0004	/* Processor In Active Mode With PLL Disabled   */
 #define	PLL_LOCKED			0x0020	/* PLL_LOCKCNT Has Been Reached                                 */
 
+/* VR_CTL Masks																	*/
+#define	FREQ			0x0003	/* Switching Oscillator Frequency For Regulator	*/
+#define	HIBERNATE		0x0000	/* 		Powerdown/Bypass On-Board Regulation	*/
+#define	FREQ_333		0x0001	/* 		Switching Frequency Is 333 kHz			*/
+#define	FREQ_667		0x0002	/* 		Switching Frequency Is 667 kHz			*/
+#define	FREQ_1000		0x0003	/* 		Switching Frequency Is 1 MHz			*/
+
+#define GAIN			0x000C	/* Voltage Level Gain	*/
+#define	GAIN_5			0x0000	/* 		GAIN = 5		*/
+#define	GAIN_10			0x0004	/* 		GAIN = 10		*/
+#define	GAIN_20			0x0008	/* 		GAIN = 20		*/
+#define	GAIN_50			0x000C	/* 		GAIN = 50		*/
+
+#define	VLEV			0x00F0	/* Internal Voltage Level					*/
+#define	VLEV_085 		0x0060	/* 		VLEV = 0.85 V (-5% - +10% Accuracy)	*/
+#define	VLEV_090		0x0070	/* 		VLEV = 0.90 V (-5% - +10% Accuracy)	*/
+#define	VLEV_095		0x0080	/* 		VLEV = 0.95 V (-5% - +10% Accuracy)	*/
+#define	VLEV_100		0x0090	/* 		VLEV = 1.00 V (-5% - +10% Accuracy)	*/
+#define	VLEV_105		0x00A0	/* 		VLEV = 1.05 V (-5% - +10% Accuracy)	*/
+#define	VLEV_110		0x00B0	/* 		VLEV = 1.10 V (-5% - +10% Accuracy)	*/
+#define	VLEV_115		0x00C0	/* 		VLEV = 1.15 V (-5% - +10% Accuracy)	*/
+#define	VLEV_120		0x00D0	/* 		VLEV = 1.20 V (-5% - +10% Accuracy)	*/
+
+#define	WAKE			0x0100	/* Enable RTC/Reset Wakeup From Hibernate	*/
+#define	SCKELOW			0x8000	/* Do Not Drive SCKE High During Reset After Hibernate */
+
 /* CHIPID Masks */
 #define CHIPID_VERSION         0xF0000000
 #define CHIPID_FAMILY          0x0FFFF000
 #define CHIPID_MANUFACTURE     0x00000FFE
 
 /* SWRST Mask */
-#define SYSTEM_RESET           0x00000007	/* Initiates a system software reset */
+#define SYSTEM_RESET	0x0007	/* Initiates A System Software Reset			*/
+#define	DOUBLE_FAULT	0x0008	/* Core Double Fault Causes Reset				*/
+#define RESET_DOUBLE	0x2000	/* SW Reset Generated By Core Double-Fault		*/
+#define RESET_WDOG	0x4000	/* SW Reset Generated By Watchdog Timer			*/
+#define RESET_SOFTWARE	0x8000	/* SW Reset Occurred Since Last Read Of SWRST	*/
+
+/* SYSCR Masks																				*/
+#define BMODE			0x0006	/* Boot Mode - Latched During HW Reset From Mode Pins	*/
+#define	NOBOOT			0x0010	/* Execute From L1 or ASYNC Bank 0 When BMODE = 0		*/
 
 /* *************  SYSTEM INTERRUPT CONTROLLER MASKS ***************** */
 
@@ -483,23 +528,6 @@
 #define IWR_ENABLE(x)	       (1 << (x))	/* Wakeup Enable Peripheral #x */
 #define IWR_DISABLE(x) (0xFFFFFFFF ^ (1 << (x)))	/* Wakeup Disable Peripheral #x */
 
-/* *********  WATCHDOG TIMER MASKS  ********************8 */
-
-/* Watchdog Timer WDOG_CTL Register */
-#define ICTL(x) ((x<<1) & 0x0006)
-#define ENABLE_RESET     0x00000000	/* Set Watchdog Timer to generate reset */
-#define ENABLE_NMI       0x00000002	/* Set Watchdog Timer to generate non-maskable interrupt */
-#define ENABLE_GPI       0x00000004	/* Set Watchdog Timer to generate general-purpose interrupt */
-#define DISABLE_EVT      0x00000006	/* Disable Watchdog Timer interrupts */
-
-#define TMR_EN		0x0000
-#define TMR_DIS		0x0AD0
-#define TRO		0x8000
-
-#define ICTL_P0		0x01
-#define ICTL_P1		0x02
-#define TRO_P		0x0F
-
 /* ***************************** UART CONTROLLER MASKS ********************** */
 
 /* UART_LCR Register */
@@ -583,6 +611,9 @@
 #define TSPEN    0x0001		/* TX enable  */
 #define ITCLK    0x0002		/* Internal TX Clock Select  */
 #define TDTYPE   0x000C		/* TX Data Formatting Select */
+#define DTYPE_NORM	0x0000		/* Data Format Normal							*/
+#define DTYPE_ULAW	0x0008		/* Compand Using u-Law							*/
+#define DTYPE_ALAW	0x000C		/* Compand Using A-Law							*/
 #define TLSBIT   0x0010		/* TX Bit Order */
 #define ITFS     0x0200		/* Internal TX Frame Sync Select  */
 #define TFSR     0x0400		/* TX Frame Sync Required Select  */
@@ -592,7 +623,12 @@
 #define TCKFE    0x4000		/* TX Clock Falling Edge Select  */
 
 /* SPORTx_TCR2 Masks */
-#define SLEN	    0x001F	/*TX Word Length  */
+#if defined(__ADSPBF531__) || defined(__ADSPBF532__) || \
+    defined(__ADSPBF533__)
+# define SLEN	    0x001F	/*TX Word Length  */
+#else
+# define SLEN(x)		((x)&0x1F)	/* SPORT TX Word Length (2 - 31)				*/
+#endif
 #define TXSE        0x0100	/*TX Secondary Enable */
 #define TSFSE       0x0200	/*TX Stereo Frame Sync Enable */
 #define TRFST       0x0400	/*TX Right-First Data Order  */
@@ -601,8 +637,9 @@
 #define RSPEN    0x0001		/* RX enable  */
 #define IRCLK    0x0002		/* Internal RX Clock Select  */
 #define RDTYPE   0x000C		/* RX Data Formatting Select */
-#define RULAW    0x0008		/* u-Law enable  */
-#define RALAW    0x000C		/* A-Law enable  */
+#define DTYPE_NORM	0x0000		/* no companding							*/
+#define DTYPE_ULAW	0x0008		/* Compand Using u-Law							*/
+#define DTYPE_ALAW	0x000C		/* Compand Using A-Law							*/
 #define RLSBIT   0x0010		/* RX Bit Order */
 #define IRFS     0x0200		/* Internal RX Frame Sync Select  */
 #define RFSR     0x0400		/* RX Frame Sync Required Select  */
@@ -611,7 +648,7 @@
 #define RCKFE    0x4000		/* RX Clock Falling Edge Select  */
 
 /* SPORTx_RCR2 Masks */
-#define SLEN	    0x001F	/*RX Word Length  */
+/* SLEN defined above */
 #define RXSE        0x0100	/*RX Secondary Enable */
 #define RSFSE       0x0200	/*RX Stereo Frame Sync Enable */
 #define RRFST       0x0400	/*Right-First Data Order  */
@@ -628,14 +665,37 @@
 /*SPORTx_MCMC1 Masks */
 #define SP_WSIZE		0x0000F000	/*Multichannel Window Size Field */
 #define SP_WOFF		0x000003FF	/*Multichannel Window Offset Field */
+/* SPORTx_MCMC1 Macros															*/
+#define SET_SP_WOFF(x)	((x) & 0x3FF) 	/* Multichannel Window Offset Field			*/
+/* Only use SET_WSIZE Macro With Logic OR While Setting Lower Order Bits						*/
+#define SET_SP_WSIZE(x)	(((((x)>>0x3)-1)&0xF) << 0xC)	/* Multichannel Window Size = (x/8)-1	*/
 
 /*SPORTx_MCMC2 Masks */
-#define MCCRM		0x00000003	/*Multichannel Clock Recovery Mode */
-#define MCDTXPE		0x00000004	/*Multichannel DMA Transmit Packing */
-#define MCDRXPE		0x00000008	/*Multichannel DMA Receive Packing */
-#define MCMEN		0x00000010	/*Multichannel Frame Mode Enable */
-#define FSDR		0x00000080	/*Multichannel Frame Sync to Data Relationship */
-#define MFD		0x0000F000	/*Multichannel Frame Delay    */
+#define MCCRM		0x00000003 	/*Multichannel Clock Recovery Mode */
+#define REC_BYPASS	0x0000		/* Bypass Mode (No Clock Recovery)				*/
+#define REC_2FROM4	0x0002		/* Recover 2 MHz Clock from 4 MHz Clock			*/
+#define REC_8FROM16	0x0003		/* Recover 8 MHz Clock from 16 MHz Clock		*/
+#define MCDTXPE		0x00000004 	/*Multichannel DMA Transmit Packing */
+#define MCDRXPE		0x00000008 	/*Multichannel DMA Receive Packing */
+#define MCMEN		0x00000010 	/*Multichannel Frame Mode Enable */
+#define FSDR		0x00000080 	/*Multichannel Frame Sync to Data Relationship */
+#define MFD		0x0000F000 	/*Multichannel Frame Delay    */
+#define MFD_0		0x0000		/* Multichannel Frame Delay = 0					*/
+#define MFD_1		0x1000		/* Multichannel Frame Delay = 1					*/
+#define MFD_2		0x2000		/* Multichannel Frame Delay = 2					*/
+#define MFD_3		0x3000		/* Multichannel Frame Delay = 3					*/
+#define MFD_4		0x4000		/* Multichannel Frame Delay = 4					*/
+#define MFD_5		0x5000		/* Multichannel Frame Delay = 5					*/
+#define MFD_6		0x6000		/* Multichannel Frame Delay = 6					*/
+#define MFD_7		0x7000		/* Multichannel Frame Delay = 7					*/
+#define MFD_8		0x8000		/* Multichannel Frame Delay = 8					*/
+#define MFD_9		0x9000		/* Multichannel Frame Delay = 9					*/
+#define MFD_10		0xA000		/* Multichannel Frame Delay = 10				*/
+#define MFD_11		0xB000		/* Multichannel Frame Delay = 11				*/
+#define MFD_12		0xC000		/* Multichannel Frame Delay = 12				*/
+#define MFD_13		0xD000		/* Multichannel Frame Delay = 13				*/
+#define MFD_14		0xE000		/* Multichannel Frame Delay = 14				*/
+#define MFD_15		0xF000		/* Multichannel Frame Delay = 15				*/
 
 /*  *********  PARALLEL PERIPHERAL INTERFACE (PPI) MASKS ****************   */
 
@@ -660,6 +720,8 @@
 #define DLEN_16			0x3800	/* Data Length = 16 Bits                        */
 #define DLEN(x)	(((x-9) & 0x07) << 11)	/* PPI Data Length (only works for x=10-->x=16) */
 #define POL                  0x0000C000	/* PPI Signal Polarities       */
+#define POLC		0x4000		/* PPI Clock Polarity				*/
+#define POLS		0x8000		/* PPI Frame Sync Polarity			*/
 
 /* PPI_STATUS Masks                                          */
 #define FLD	             0x00000400	/* Field Indicator   */
@@ -729,6 +791,15 @@
 #define PCAPRD	            0x00000800	/* DMA Read Operation Indicator */
 #define PMAP	            0x00007000	/* DMA Peripheral Map Field */
 
+#define PMAP_PPI		0x0000	/* PMAP PPI Port DMA */
+#define	PMAP_SPORT0RX		0x1000	/* PMAP SPORT0 Receive DMA */
+#define PMAP_SPORT0TX		0x2000	/* PMAP SPORT0 Transmit DMA */
+#define	PMAP_SPORT1RX		0x3000	/* PMAP SPORT1 Receive DMA */
+#define PMAP_SPORT1TX		0x4000	/* PMAP SPORT1 Transmit DMA */
+#define PMAP_SPI		0x5000	/* PMAP SPI DMA */
+#define PMAP_UARTRX		0x6000	/* PMAP UART Receive DMA */
+#define PMAP_UARTTX		0x7000	/* PMAP UART Transmit DMA */
+
 /*  *************  GENERAL PURPOSE TIMER MASKS  ******************** */
 
 /* PWM Timer bit definitions */
@@ -755,9 +826,9 @@
 #define TIMIL0		0x0001
 #define TIMIL1		0x0002
 #define TIMIL2		0x0004
-#define TOVL_ERR0	0x0010
-#define TOVL_ERR1	0x0020
-#define TOVL_ERR2	0x0040
+#define TOVF_ERR0		0x0010	/* Timer 0 Counter Overflow		*/
+#define TOVF_ERR1		0x0020	/* Timer 1 Counter Overflow		*/
+#define TOVF_ERR2		0x0040	/* Timer 2 Counter Overflow		*/
 #define TRUN0		0x1000
 #define TRUN1		0x2000
 #define TRUN2		0x4000
@@ -765,13 +836,21 @@
 #define TIMIL0_P	0x00
 #define TIMIL1_P	0x01
 #define TIMIL2_P	0x02
-#define TOVL_ERR0_P	0x04
-#define TOVL_ERR1_P	0x05
-#define TOVL_ERR2_P	0x06
+#define TOVF_ERR0_P		0x04
+#define TOVF_ERR1_P		0x05
+#define TOVF_ERR2_P		0x06
 #define TRUN0_P		0x0C
 #define TRUN1_P		0x0D
 #define TRUN2_P		0x0E
 
+/* Alternate Deprecated Macros Provided For Backwards Code Compatibility */
+#define TOVL_ERR0 		TOVF_ERR0
+#define TOVL_ERR1 		TOVF_ERR1
+#define TOVL_ERR2 		TOVF_ERR2
+#define TOVL_ERR0_P		TOVF_ERR0_P
+#define TOVL_ERR1_P 		TOVF_ERR1_P
+#define TOVL_ERR2_P 		TOVF_ERR2_P
+
 /* TIMERx_CONFIG Registers */
 #define PWM_OUT		0x0001
 #define WDTH_CAP	0x0002
@@ -841,6 +920,10 @@
 
 /* SPI_CTL Masks */
 #define TIMOD                  0x00000003	/* Transfer initiation mode and interrupt generation */
+#define RDBR_CORE	0x0000		/* 		RDBR Read Initiates, IRQ When RDBR Full		*/
+#define	TDBR_CORE	0x0001		/* 		TDBR Write Initiates, IRQ When TDBR Empty	*/
+#define RDBR_DMA	0x0002		/* 		DMA Read, DMA Until FIFO Empty				*/
+#define TDBR_DMA	0x0003		/* 		DMA Write, DMA Until FIFO Full				*/
 #define SZ                     0x00000004	/* Send Zero (=0) or last (=1) word when TDBR empty. */
 #define GM                     0x00000008	/* When RDBR full, get more (=1) data or discard (=0) incoming Data */
 #define PSSE                   0x00000010	/* Enable (=1) Slave-Select input for Master. */
@@ -894,10 +977,20 @@
 #define RXS                    0x00000020	/* SPI_RDBR Data Buffer Status (0=Empty, 1=Full)  */
 #define TXCOL                  0x00000040	/* When set (=1), corrupt data may have been transmitted  */
 
+/* SPIx_FLG Masks																	*/
+#define FLG1E	0xFDFF		/* Activates SPI_FLOUT1 							*/
+#define FLG2E	0xFBFF		/* Activates SPI_FLOUT2								*/
+#define FLG3E	0xF7FF		/* Activates SPI_FLOUT3								*/
+#define FLG4E	0xEFFF		/* Activates SPI_FLOUT4								*/
+#define FLG5E	0xDFFF		/* Activates SPI_FLOUT5								*/
+#define FLG6E	0xBFFF		/* Activates SPI_FLOUT6								*/
+#define FLG7E	0x7FFF		/* Activates SPI_FLOUT7								*/
+
 /* *********************  ASYNCHRONOUS MEMORY CONTROLLER MASKS  ************* */
 
 /* AMGCTL Masks */
 #define AMCKEN			0x00000001	/* Enable CLKOUT */
+#define	AMBEN_NONE		0x00000000	/* All Banks Disabled								*/
 #define AMBEN_B0		0x00000002	/* Enable Asynchronous Memory Bank 0 only */
 #define AMBEN_B0_B1		0x00000004	/* Enable Asynchronous Memory Banks 0 & 1 only */
 #define AMBEN_B0_B1_B2		0x00000006	/* Enable Asynchronous Memory Banks 0, 1, and 2 */
@@ -1097,6 +1190,9 @@
 #define CL_3			0x0000000C	/* SDRAM CAS latency = 3 cycles */
 #define PFE			0x00000010	/* Enable SDRAM prefetch */
 #define PFP			0x00000020	/* Prefetch has priority over AMC requests */
+#define PASR_ALL		0x00000000	/* All 4 SDRAM Banks Refreshed In Self-Refresh				*/
+#define PASR_B0_B1		0x00000010	/* SDRAM Banks 0 and 1 Are Refreshed In Self-Refresh		*/
+#define PASR_B0			0x00000020	/* Only SDRAM Bank 0 Is Refreshed In Self-Refresh			*/
 #define TRAS_1			0x00000040	/* SDRAM tRAS = 1 cycle */
 #define TRAS_2			0x00000080	/* SDRAM tRAS = 2 cycles */
 #define TRAS_3			0x000000C0	/* SDRAM tRAS = 3 cycles */
@@ -1158,18 +1254,5 @@
 #define SDEASE		      0x00000010	/* SDRAM EAB sticky error status - W1C */
 #define BGSTAT			0x00000020	/* Bus granted */
 
-/*VR_CTL Masks*/
-#define WAKE                    0x100
-#define VLEV_6                  0x60
-#define VLEV_7                  0x70
-#define VLEV_8                  0x80
-#define VLEV_9                  0x90
-#define VLEV_10                 0xA0
-#define VLEV_11                 0xB0
-#define VLEV_12                 0xC0
-#define VLEV_13                 0xD0
-#define VLEV_14                 0xE0
-#define VLEV_15                 0xF0
-#define FREQ_3                  0x03
 
 #endif				/* _DEF_BF532_H */
diff --git a/include/asm-blackfin/mach-bf537/cdefBF534.h b/include/asm-blackfin/mach-bf537/cdefBF534.h
index 7b658c1..84e58fa 100644
--- a/include/asm-blackfin/mach-bf537/cdefBF534.h
+++ b/include/asm-blackfin/mach-bf537/cdefBF534.h
@@ -51,12 +51,14 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 {
 	unsigned long flags, iwr;
 
-	bfin_write16(VR_CTL, val);
-	__builtin_bfin_ssync();
 	/* Enable the PLL Wakeup bit in SIC IWR */
 	iwr = bfin_read32(SIC_IWR);
 	/* Only allow PPL Wakeup) */
 	bfin_write32(SIC_IWR, IWR_ENABLE(0));
+
+	bfin_write16(VR_CTL, val);
+	__builtin_bfin_ssync();
+
 	local_irq_save(flags);
 	asm("IDLE;");
 	local_irq_restore(flags);
@@ -73,7 +75,6 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 #define bfin_write_SWRST(val)                bfin_write16(SWRST,val)
 #define bfin_read_SYSCR()                    bfin_read16(SYSCR)
 #define bfin_write_SYSCR(val)                bfin_write16(SYSCR,val)
-#define	pSIC_RVECT			((void * volatile *)SIC_RVECT)
 #define bfin_read_SIC_RVECT()                bfin_read32(SIC_RVECT)
 #define bfin_write_SIC_RVECT(val)            bfin_write32(SIC_RVECT,val)
 #define bfin_read_SIC_IMASK()                bfin_read32(SIC_IMASK)
@@ -398,10 +399,14 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 #define bfin_write_EBIU_SDSTAT(val)          bfin_write16(EBIU_SDSTAT,val)
 
 /* DMA Traffic Control Registers													*/
-#define	pDMA_TCPER			((volatile unsigned short *)DMA_TCPER)
+#define bfin_read_DMA_TC_PER()                bfin_read16(DMA_TC_PER)
+#define bfin_write_DMA_TC_PER(val)            bfin_write16(DMA_TC_PER,val)
+#define bfin_read_DMA_TC_CNT()                bfin_read16(DMA_TC_CNT)
+#define bfin_write_DMA_TC_CNT(val)            bfin_write16(DMA_TC_CNT,val)
+
+/* Alternate deprecated register names (below) provided for backwards code compatibility */
 #define bfin_read_DMA_TCPER()                bfin_read16(DMA_TCPER)
 #define bfin_write_DMA_TCPER(val)            bfin_write16(DMA_TCPER,val)
-#define	pDMA_TCCNT			((volatile unsigned short *)DMA_TCCNT)
 #define bfin_read_DMA_TCCNT()                bfin_read16(DMA_TCCNT)
 #define bfin_write_DMA_TCCNT(val)            bfin_write16(DMA_TCCNT,val)
 
@@ -1076,8 +1081,6 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 #define bfin_write_CAN_UCRC(val)             bfin_write16(CAN_UCRC,val)
 #define bfin_read_CAN_UCCNF()                bfin_read16(CAN_UCCNF)
 #define bfin_write_CAN_UCCNF(val)            bfin_write16(CAN_UCCNF,val)
-#define bfin_read_CAN_SFCMVER2()             bfin_read16(CAN_SFCMVER2)
-#define bfin_write_CAN_SFCMVER2(val)         bfin_write16(CAN_SFCMVER2,val)
 
 /* Mailbox Acceptance Masks */
 #define bfin_read_CAN_AM00L()                bfin_read16(CAN_AM00L)
diff --git a/include/asm-blackfin/mach-bf537/cdefBF537.h b/include/asm-blackfin/mach-bf537/cdefBF537.h
index 932a1b6..b8fc949 100644
--- a/include/asm-blackfin/mach-bf537/cdefBF537.h
+++ b/include/asm-blackfin/mach-bf537/cdefBF537.h
@@ -40,7 +40,6 @@
 
 /* Include Macro "Defines" For EMAC (Unique to BF536/BF537		*/
 /* 10/100 Ethernet Controller	(0xFFC03000 - 0xFFC031FF) 						*/
-#define	pEMAC_OPMODE		((volatile unsigned long  *)EMAC_OPMODE)
 #define bfin_read_EMAC_OPMODE()              bfin_read32(EMAC_OPMODE)
 #define bfin_write_EMAC_OPMODE(val)          bfin_write32(EMAC_OPMODE,val)
 #define bfin_read_EMAC_ADDRLO()              bfin_read32(EMAC_ADDRLO)
@@ -80,7 +79,6 @@
 #define bfin_read_EMAC_WKUP_FFCRC1()         bfin_read32(EMAC_WKUP_FFCRC1)
 #define bfin_write_EMAC_WKUP_FFCRC1(val)     bfin_write32(EMAC_WKUP_FFCRC1,val)
 
-#define	pEMAC_SYSCTL		((volatile unsigned long  *)EMAC_SYSCTL)
 #define bfin_read_EMAC_SYSCTL()              bfin_read32(EMAC_SYSCTL)
 #define bfin_write_EMAC_SYSCTL(val)          bfin_write32(EMAC_SYSCTL,val)
 #define bfin_read_EMAC_SYSTAT()              bfin_read32(EMAC_SYSTAT)
@@ -147,7 +145,6 @@
 #define bfin_write_EMAC_RXC_SHORT(val)       bfin_write32(EMAC_RXC_SHORT,val)
 #define bfin_read_EMAC_RXC_EQ64()            bfin_read32(EMAC_RXC_EQ64)
 #define bfin_write_EMAC_RXC_EQ64(val)        bfin_write32(EMAC_RXC_EQ64,val)
-#define	pEMAC_RXC_LT128		((volatile unsigned long  *)EMAC_RXC_LT128)
 #define bfin_read_EMAC_RXC_LT128()           bfin_read32(EMAC_RXC_LT128)
 #define bfin_write_EMAC_RXC_LT128(val)       bfin_write32(EMAC_RXC_LT128,val)
 #define bfin_read_EMAC_RXC_LT256()           bfin_read32(EMAC_RXC_LT256)
diff --git a/include/asm-blackfin/mach-bf537/defBF534.h b/include/asm-blackfin/mach-bf537/defBF534.h
index e605e97..1859f2f 100644
--- a/include/asm-blackfin/mach-bf537/defBF534.h
+++ b/include/asm-blackfin/mach-bf537/defBF534.h
@@ -216,8 +216,12 @@
 #define EBIU_SDSTAT			0xFFC00A1C	/* SDRAM Status Register                                                */
 
 /* DMA Traffic Control Registers													*/
-#define DMA_TCPER			0xFFC00B0C	/* Traffic Control Periods Register                     */
-#define DMA_TCCNT			0xFFC00B10	/* Traffic Control Current Counts Register      */
+#define DMA_TC_PER			0xFFC00B0C	/* Traffic Control Periods Register			*/
+#define DMA_TC_CNT			0xFFC00B10	/* Traffic Control Current Counts Register	*/
+
+/* Alternate deprecated register names (below) provided for backwards code compatibility */
+#define DMA_TCPER			0xFFC00B0C	/* Traffic Control Periods Register			*/
+#define DMA_TCCNT			0xFFC00B10	/* Traffic Control Current Counts Register	*/
 
 /* DMA Controller (0xFFC00C00 - 0xFFC00FFF)															*/
 #define DMA0_NEXT_DESC_PTR		0xFFC00C00	/* DMA Channel 0 Next Descriptor Pointer Register               */
@@ -563,7 +567,7 @@
 #define CAN_GIF				0xFFC02A9C	/* Global Interrupt Flag Register                               */
 #define CAN_CONTROL			0xFFC02AA0	/* Master Control Register                                              */
 #define CAN_INTR			0xFFC02AA4	/* Interrupt Pending Register                                   */
-#define CAN_SFCMVER			0xFFC02AA8	/* Version Code Register                                                */
+
 #define CAN_MBTD			0xFFC02AAC	/* Mailbox Temporary Disable Feature                    */
 #define CAN_EWR				0xFFC02AB0	/* Programmable Warning Level                                   */
 #define CAN_ESR				0xFFC02AB4	/* Error Status Register                                                */
@@ -1026,10 +1030,11 @@
 #define	VLEV_130		0x00F0	/*              VLEV = 1.30 V (-5% - +10% Accuracy)     */
 
 #define	WAKE			0x0100	/* Enable RTC/Reset Wakeup From Hibernate       */
-#define PHYWE			0x0200	/* Enable PHY Wakeup From Hibernate                     */
-#define	CANWE			0x0400	/* Enable CAN Wakeup From Hibernate                     */
-#define	PHYCLKOE		0x4000	/* PHY Clock Output Enable                                      */
-#define	CKELOW			0x8000	/* Enable Drive CKE Low During Reset            */
+#define	CANWE			0x0200	/* Enable CAN Wakeup From Hibernate			*/
+#define	PHYWE			0x0400	/* Enable PHY Wakeup From Hibernate			*/
+#define	CLKBUFOE		0x4000	/* CLKIN Buffer Output Enable */
+#define	PHYCLKOE		CLKBUFOE	/* Alternative legacy name for the above */
+#define	SCKELOW		0x8000	/* Enable Drive CKE Low During Reset		*/
 
 /* PLL_STAT Masks																	*/
 #define ACTIVE_PLLENABLED	0x0001	/* Processor In Active Mode With PLL Enabled    */
@@ -1050,7 +1055,7 @@
 #define RESET_SOFTWARE		0x8000	/* SW Reset Occurred Since Last Read Of SWRST   */
 
 /* SYSCR Masks																				*/
-#define BMODE				0x0006	/* Boot Mode - Latched During HW Reset From Mode Pins   */
+#define BMODE				0x0007	/* Boot Mode - Latched During HW Reset From Mode Pins   */
 #define	NOBOOT				0x0010	/* Execute From L1 or ASYNC Bank 0 When BMODE = 0               */
 
 /* *************  SYSTEM INTERRUPT CONTROLLER MASKS *************************************/
@@ -1107,19 +1112,9 @@
 #define IWR_ENABLE(x)	(1 << ((x)&0x1F))	/* Wakeup Enable Peripheral #x          */
 #define IWR_DISABLE(x)	(0xFFFFFFFF ^ (1 << ((x)&0x1F)))	/* Wakeup Disable Peripheral #x         */
 
-/* ***************  WATCHDOG TIMER MASKS  *******************************************/
-/* WDOG_CTL Masks																	*/
-#define WDOG_RESET		0x0000	/* Generate Reset Event                                                 */
-#define WDOG_NMI		0x0002	/* Generate Non-Maskable Interrupt (NMI) Event  */
-#define WDOG_GPI		0x0004	/* Generate General Purpose (GP) Interrupt              */
-#define WDOG_NONE		0x0006	/* Disable Watchdog Timer Interrupts                    */
-#define TMR_EN			0x0FF0	/* Watchdog Counter Enable                                              */
-#define	TMR_DIS			0x0AD0	/* Watchdog Counter Disable                                             */
-#define TRO			0x8000	/* Watchdog Expired                                                     */
-
 /* ************** UART CONTROLLER MASKS *************************/
 /* UARTx_LCR Masks												*/
-#define WLS(x)		((((x)&0x3)-5) & 0x03)	/* Word Length Select   */
+#define WLS(x)		(((x)-5) & 0x03)	/* Word Length Select   */
 #define STB			0x04	/* Stop Bits                    */
 #define PEN			0x08	/* Parity Enable                */
 #define EPS			0x10	/* Even Parity Select   */
@@ -1128,8 +1123,8 @@
 #define DLAB		0x80	/* Divisor Latch Access */
 
 /* UARTx_MCR Mask										*/
-#define LOOP		0x10	/* Loopback Mode Enable         */
-
+#define LOOP_ENA		0x10	/* Loopback Mode Enable         */
+#define LOOP_ENA_P	0x04
 /* UARTx_LSR Masks										*/
 #define DR			0x01	/* Data Ready                           */
 #define OE			0x02	/* Overrun Error                        */
@@ -1229,10 +1224,10 @@
 #define TIMIL1			0x00000002	/* Timer 1 Interrupt                            */
 #define TIMIL2			0x00000004	/* Timer 2 Interrupt                            */
 #define TIMIL3			0x00000008	/* Timer 3 Interrupt                            */
-#define TOVL_ERR0		0x00000010	/* Timer 0 Counter Overflow                     */
-#define TOVL_ERR1		0x00000020	/* Timer 1 Counter Overflow                     */
-#define TOVL_ERR2		0x00000040	/* Timer 2 Counter Overflow                     */
-#define TOVL_ERR3		0x00000080	/* Timer 3 Counter Overflow                     */
+#define TOVF_ERR0		0x00000010	/* Timer 0 Counter Overflow			*/
+#define TOVF_ERR1		0x00000020	/* Timer 1 Counter Overflow			*/
+#define TOVF_ERR2		0x00000040	/* Timer 2 Counter Overflow			*/
+#define TOVF_ERR3		0x00000080	/* Timer 3 Counter Overflow			*/
 #define TRUN0			0x00001000	/* Timer 0 Slave Enable Status          */
 #define TRUN1			0x00002000	/* Timer 1 Slave Enable Status          */
 #define TRUN2			0x00004000	/* Timer 2 Slave Enable Status          */
@@ -1241,15 +1236,24 @@
 #define TIMIL5			0x00020000	/* Timer 5 Interrupt                            */
 #define TIMIL6			0x00040000	/* Timer 6 Interrupt                            */
 #define TIMIL7			0x00080000	/* Timer 7 Interrupt                            */
-#define TOVL_ERR4		0x00100000	/* Timer 4 Counter Overflow                     */
-#define TOVL_ERR5		0x00200000	/* Timer 5 Counter Overflow                     */
-#define TOVL_ERR6		0x00400000	/* Timer 6 Counter Overflow                     */
-#define TOVL_ERR7		0x00800000	/* Timer 7 Counter Overflow                     */
+#define TOVF_ERR4		0x00100000	/* Timer 4 Counter Overflow			*/
+#define TOVF_ERR5		0x00200000	/* Timer 5 Counter Overflow			*/
+#define TOVF_ERR6		0x00400000	/* Timer 6 Counter Overflow			*/
+#define TOVF_ERR7		0x00800000	/* Timer 7 Counter Overflow			*/
 #define TRUN4			0x10000000	/* Timer 4 Slave Enable Status          */
 #define TRUN5			0x20000000	/* Timer 5 Slave Enable Status          */
 #define TRUN6			0x40000000	/* Timer 6 Slave Enable Status          */
 #define TRUN7			0x80000000	/* Timer 7 Slave Enable Status          */
 
+/* Alternate Deprecated Macros Provided For Backwards Code Compatibility */
+#define TOVL_ERR0 TOVF_ERR0
+#define TOVL_ERR1 TOVF_ERR1
+#define TOVL_ERR2 TOVF_ERR2
+#define TOVL_ERR3 TOVF_ERR3
+#define TOVL_ERR4 TOVF_ERR4
+#define TOVL_ERR5 TOVF_ERR5
+#define TOVL_ERR6 TOVF_ERR6
+#define TOVL_ERR7 TOVF_ERR7
 /* TIMERx_CONFIG Masks													*/
 #define PWM_OUT			0x0001	/* Pulse-Width Modulation Output Mode   */
 #define WDTH_CAP		0x0002	/* Width Capture Input Mode                             */
@@ -1647,6 +1651,8 @@
 #define EBSZ_32			0x0002	/* SDRAM External Bank Size = 32MB                                              */
 #define EBSZ_64			0x0004	/* SDRAM External Bank Size = 64MB                                              */
 #define EBSZ_128		0x0006	/* SDRAM External Bank Size = 128MB                                             */
+#define EBSZ_256		0x0008		/* SDRAM External Bank Size = 256MB 	*/
+#define EBSZ_512		0x000A		/* SDRAM External Bank Size = 512MB		*/
 #define EBCAW_8			0x0000	/* SDRAM External Bank Column Address Width = 8 Bits    */
 #define EBCAW_9			0x0010	/* SDRAM External Bank Column Address Width = 9 Bits    */
 #define EBCAW_10		0x0020	/* SDRAM External Bank Column Address Width = 10 Bits   */
@@ -1859,8 +1865,10 @@
 #define	TXECNT		0xFF00	/* Transmit Error Counter       */
 
 /* CAN_INTR Masks											*/
-#define	MBRIF		0x0001	/* Mailbox Receive Interrupt    */
-#define	MBTIF		0x0002	/* Mailbox Transmit Interrupt   */
+#define	MBRIRQ	0x0001	/* Mailbox Receive Interrupt	*/
+#define	MBRIF		MBRIRQ	/* legacy */
+#define	MBTIRQ	0x0002	/* Mailbox Transmit Interrupt	*/
+#define	MBTIF		MBTIRQ	/* legacy */
 #define	GIRQ		0x0004	/* Global Interrupt                             */
 #define	SMACK		0x0008	/* Sleep Mode Acknowledge               */
 #define	CANTX		0x0040	/* CAN TX Bus Value                             */
@@ -2445,8 +2453,8 @@
 #define	PJCE_SPI		0x0004	/*              Enable SPI_SSEL7                        */
 
 #define	PFDE			0x0008	/* Port F DMA Request Enable            */
-#define	PGDE_UART		0x0000	/*              Enable UART0 RX/TX                      */
-#define	PGDE_DMA		0x0008	/*              Enable DMAR1:0                          */
+#define	PFDE_UART		0x0000	/*              Enable UART0 RX/TX                      */
+#define	PFDE_DMA		0x0008	/*              Enable DMAR1:0                          */
 
 #define	PFTE			0x0010	/* Port F Timer Enable                          */
 #define	PFTE_UART		0x0000	/*              Enable UART1 RX/TX                      */
@@ -2498,4 +2506,20 @@
 #define	OI			0x4000	/* Overflow Interrupt Generated                         */
 #define	BDI			0x8000	/* Block Done Interrupt Generated                       */
 
+/* entry addresses of the user-callable Boot ROM functions */
+
+#define _BOOTROM_RESET 0xEF000000 
+#define _BOOTROM_FINAL_INIT 0xEF000002 
+#define _BOOTROM_DO_MEMORY_DMA 0xEF000006
+#define _BOOTROM_BOOT_DXE_FLASH 0xEF000008 
+#define _BOOTROM_BOOT_DXE_SPI 0xEF00000A 
+#define _BOOTROM_BOOT_DXE_TWI 0xEF00000C 
+#define _BOOTROM_GET_DXE_ADDRESS_FLASH 0xEF000010
+#define _BOOTROM_GET_DXE_ADDRESS_SPI 0xEF000012
+#define _BOOTROM_GET_DXE_ADDRESS_TWI 0xEF000014
+
+/* Alternate Deprecated Macros Provided For Backwards Code Compatibility */
+#define	PGDE_UART   PFDE_UART
+#define	PGDE_DMA    PFDE_DMA
+#define	CKELOW		SCKELOW
 #endif				/* _DEF_BF534_H */
diff --git a/include/asm-blackfin/mach-bf537/defBF537.h b/include/asm-blackfin/mach-bf537/defBF537.h
index 26f9c02..3f45590 100644
--- a/include/asm-blackfin/mach-bf537/defBF537.h
+++ b/include/asm-blackfin/mach-bf537/defBF537.h
@@ -32,12 +32,12 @@
 #ifndef _DEF_BF537_H
 #define _DEF_BF537_H
 
-/*include all Core registers and bit definitions*/
-#include "defBF537.h"
-
-/*include core specific register pointer definitions*/
+/* Include all Core registers and bit definitions*/
 #include <asm/mach-common/cdef_LPBlackfin.h>
 
+/* Include all MMR and bit defines common to BF534 */
+#include "defBF534.h"
+
 /************************************************************************************
 ** Define EMAC Section Unique to BF536/BF537
 *************************************************************************************/
diff --git a/include/asm-blackfin/mach-bf548/cdefBF542.h b/include/asm-blackfin/mach-bf548/cdefBF542.h
new file mode 100644
index 0000000..308b33a
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/cdefBF542.h
@@ -0,0 +1,590 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/cdefBF542.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF542_H
+#define _CDEF_BF542_H
+
+/* include all Core registers and bit definitions */
+#include "defBF542.h"
+
+/* include core sbfin_read_()ecific register pointer definitions */
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF542 */
+
+/* include cdefBF54x_base.h for the set of #defines that are common to all ADSP-BF54x bfin_read_()rocessors */
+#include "cdefBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF542 that are not in the common header */
+
+/* ATAPI Registers */
+
+#define bfin_read_ATAPI_CONTROL()		bfin_read16(ATAPI_CONTROL)
+#define bfin_write_ATAPI_CONTROL(val)		bfin_write16(ATAPI_CONTROL, val)
+#define bfin_read_ATAPI_STATUS()		bfin_read16(ATAPI_STATUS)
+#define bfin_write_ATAPI_STATUS(val)		bfin_write16(ATAPI_STATUS, val)
+#define bfin_read_ATAPI_DEV_ADDR()		bfin_read16(ATAPI_DEV_ADDR)
+#define bfin_write_ATAPI_DEV_ADDR(val)		bfin_write16(ATAPI_DEV_ADDR, val)
+#define bfin_read_ATAPI_DEV_TXBUF()		bfin_read16(ATAPI_DEV_TXBUF)
+#define bfin_write_ATAPI_DEV_TXBUF(val)		bfin_write16(ATAPI_DEV_TXBUF, val)
+#define bfin_read_ATAPI_DEV_RXBUF()		bfin_read16(ATAPI_DEV_RXBUF)
+#define bfin_write_ATAPI_DEV_RXBUF(val)		bfin_write16(ATAPI_DEV_RXBUF, val)
+#define bfin_read_ATAPI_INT_MASK()		bfin_read16(ATAPI_INT_MASK)
+#define bfin_write_ATAPI_INT_MASK(val)		bfin_write16(ATAPI_INT_MASK, val)
+#define bfin_read_ATAPI_INT_STATUS()		bfin_read16(ATAPI_INT_STATUS)
+#define bfin_write_ATAPI_INT_STATUS(val)	bfin_write16(ATAPI_INT_STATUS, val)
+#define bfin_read_ATAPI_XFER_LEN()		bfin_read16(ATAPI_XFER_LEN)
+#define bfin_write_ATAPI_XFER_LEN(val)		bfin_write16(ATAPI_XFER_LEN, val)
+#define bfin_read_ATAPI_LINE_STATUS()		bfin_read16(ATAPI_LINE_STATUS)
+#define bfin_write_ATAPI_LINE_STATUS(val)	bfin_write16(ATAPI_LINE_STATUS, val)
+#define bfin_read_ATAPI_SM_STATE()		bfin_read16(ATAPI_SM_STATE)
+#define bfin_write_ATAPI_SM_STATE(val)		bfin_write16(ATAPI_SM_STATE, val)
+#define bfin_read_ATAPI_TERMINATE()		bfin_read16(ATAPI_TERMINATE)
+#define bfin_write_ATAPI_TERMINATE(val)		bfin_write16(ATAPI_TERMINATE, val)
+#define bfin_read_ATAPI_PIO_TFRCNT()		bfin_read16(ATAPI_PIO_TFRCNT)
+#define bfin_write_ATAPI_PIO_TFRCNT(val)	bfin_write16(ATAPI_PIO_TFRCNT, val)
+#define bfin_read_ATAPI_DMA_TFRCNT()		bfin_read16(ATAPI_DMA_TFRCNT)
+#define bfin_write_ATAPI_DMA_TFRCNT(val)	bfin_write16(ATAPI_DMA_TFRCNT, val)
+#define bfin_read_ATAPI_UMAIN_TFRCNT()		bfin_read16(ATAPI_UMAIN_TFRCNT)
+#define bfin_write_ATAPI_UMAIN_TFRCNT(val)	bfin_write16(ATAPI_UMAIN_TFRCNT, val)
+#define bfin_read_ATAPI_UDMAOUT_TFRCNT()	bfin_read16(ATAPI_UDMAOUT_TFRCNT)
+#define bfin_write_ATAPI_UDMAOUT_TFRCNT(val)	bfin_write16(ATAPI_UDMAOUT_TFRCNT, val)
+#define bfin_read_ATAPI_REG_TIM_0()		bfin_read16(ATAPI_REG_TIM_0)
+#define bfin_write_ATAPI_REG_TIM_0(val)		bfin_write16(ATAPI_REG_TIM_0, val)
+#define bfin_read_ATAPI_PIO_TIM_0()		bfin_read16(ATAPI_PIO_TIM_0)
+#define bfin_write_ATAPI_PIO_TIM_0(val)		bfin_write16(ATAPI_PIO_TIM_0, val)
+#define bfin_read_ATAPI_PIO_TIM_1()		bfin_read16(ATAPI_PIO_TIM_1)
+#define bfin_write_ATAPI_PIO_TIM_1(val)		bfin_write16(ATAPI_PIO_TIM_1, val)
+#define bfin_read_ATAPI_MULTI_TIM_0()		bfin_read16(ATAPI_MULTI_TIM_0)
+#define bfin_write_ATAPI_MULTI_TIM_0(val)	bfin_write16(ATAPI_MULTI_TIM_0, val)
+#define bfin_read_ATAPI_MULTI_TIM_1()		bfin_read16(ATAPI_MULTI_TIM_1)
+#define bfin_write_ATAPI_MULTI_TIM_1(val)	bfin_write16(ATAPI_MULTI_TIM_1, val)
+#define bfin_read_ATAPI_MULTI_TIM_2()		bfin_read16(ATAPI_MULTI_TIM_2)
+#define bfin_write_ATAPI_MULTI_TIM_2(val)	bfin_write16(ATAPI_MULTI_TIM_2, val)
+#define bfin_read_ATAPI_ULTRA_TIM_0()		bfin_read16(ATAPI_ULTRA_TIM_0)
+#define bfin_write_ATAPI_ULTRA_TIM_0(val)	bfin_write16(ATAPI_ULTRA_TIM_0, val)
+#define bfin_read_ATAPI_ULTRA_TIM_1()		bfin_read16(ATAPI_ULTRA_TIM_1)
+#define bfin_write_ATAPI_ULTRA_TIM_1(val)	bfin_write16(ATAPI_ULTRA_TIM_1, val)
+#define bfin_read_ATAPI_ULTRA_TIM_2()		bfin_read16(ATAPI_ULTRA_TIM_2)
+#define bfin_write_ATAPI_ULTRA_TIM_2(val)	bfin_write16(ATAPI_ULTRA_TIM_2, val)
+#define bfin_read_ATAPI_ULTRA_TIM_3()		bfin_read16(ATAPI_ULTRA_TIM_3)
+#define bfin_write_ATAPI_ULTRA_TIM_3(val)	bfin_write16(ATAPI_ULTRA_TIM_3, val)
+
+/* SDH Registers */
+
+#define bfin_read_SDH_PWR_CTL()		bfin_read16(SDH_PWR_CTL)
+#define bfin_write_SDH_PWR_CTL(val)	bfin_write16(SDH_PWR_CTL, val)
+#define bfin_read_SDH_CLK_CTL()		bfin_read16(SDH_CLK_CTL)
+#define bfin_write_SDH_CLK_CTL(val)	bfin_write16(SDH_CLK_CTL, val)
+#define bfin_read_SDH_ARGUMENT()	bfin_read32(SDH_ARGUMENT)
+#define bfin_write_SDH_ARGUMENT(val)	bfin_write32(SDH_ARGUMENT, val)
+#define bfin_read_SDH_COMMAND()		bfin_read16(SDH_COMMAND)
+#define bfin_write_SDH_COMMAND(val)	bfin_write16(SDH_COMMAND, val)
+#define bfin_read_SDH_RESP_CMD()	bfin_read16(SDH_RESP_CMD)
+#define bfin_write_SDH_RESP_CMD(val)	bfin_write16(SDH_RESP_CMD, val)
+#define bfin_read_SDH_RESPONSE0()	bfin_read32(SDH_RESPONSE0)
+#define bfin_write_SDH_RESPONSE0(val)	bfin_write32(SDH_RESPONSE0, val)
+#define bfin_read_SDH_RESPONSE1()	bfin_read32(SDH_RESPONSE1)
+#define bfin_write_SDH_RESPONSE1(val)	bfin_write32(SDH_RESPONSE1, val)
+#define bfin_read_SDH_RESPONSE2()	bfin_read32(SDH_RESPONSE2)
+#define bfin_write_SDH_RESPONSE2(val)	bfin_write32(SDH_RESPONSE2, val)
+#define bfin_read_SDH_RESPONSE3()	bfin_read32(SDH_RESPONSE3)
+#define bfin_write_SDH_RESPONSE3(val)	bfin_write32(SDH_RESPONSE3, val)
+#define bfin_read_SDH_DATA_TIMER()	bfin_read32(SDH_DATA_TIMER)
+#define bfin_write_SDH_DATA_TIMER(val)	bfin_write32(SDH_DATA_TIMER, val)
+#define bfin_read_SDH_DATA_LGTH()	bfin_read16(SDH_DATA_LGTH)
+#define bfin_write_SDH_DATA_LGTH(val)	bfin_write16(SDH_DATA_LGTH, val)
+#define bfin_read_SDH_DATA_CTL()	bfin_read16(SDH_DATA_CTL)
+#define bfin_write_SDH_DATA_CTL(val)	bfin_write16(SDH_DATA_CTL, val)
+#define bfin_read_SDH_DATA_CNT()	fin_read16(SDH_DATA_CNT)
+#define bfin_write_SDH_DATA_CNT(val)	bfin_write16(SDH_DATA_CNT, val)
+#define bfin_read_SDH_STATUS()		bfin_read32(SDH_STATUS)
+#define bfin_write_SDH_STATUS(val)	bfin_write32(SDH_STATUS, val)
+#define bfin_read_SDH_STATUS_CLR()	fin_read16(SDH_STATUS_CLR)
+#define bfin_write_SDH_STATUS_CLR(val)	fin_write16(SDH_STATUS_CLR, val)
+#define bfin_read_SDH_MASK0()		bfin_read32(SDH_MASK0)
+#define bfin_write_SDH_MASK0(val)	bfin_write32(SDH_MASK0, val)
+#define bfin_read_SDH_MASK1()		bfin_read32(SDH_MASK1)
+#define bfin_write_SDH_MASK1(val)	bfin_write32(SDH_MASK1, val)
+#define bfin_read_SDH_FIFO_CNT()	bfin_read16(SDH_FIFO_CNT)
+#define bfin_write_SDH_FIFO_CNT(val)	bfin_write16(SDH_FIFO_CNT, val)
+#define bfin_read_SDH_FIFO()		bfin_read32(SDH_FIFO)
+#define bfin_write_SDH_FIFO(val)	bfin_write32(SDH_FIFO, val)
+#define bfin_read_SDH_E_STATUS()	bfin_read16(SDH_E_STATUS)
+#define bfin_write_SDH_E_STATUS(val)	bfin_write16(SDH_E_STATUS, val)
+#define bfin_read_SDH_E_MASK()		bfin_read16(SDH_E_MASK)
+#define bfin_write_SDH_E_MASK(val)	bfin_write16(SDH_E_MASK, val)
+#define bfin_read_SDH_CFG()		bfin_read16(SDH_CFG)
+#define bfin_write_SDH_CFG(val)		bfin_write16(SDH_CFG, val)
+#define bfin_read_SDH_RD_WAIT_EN()	bfin_read16(SDH_RD_WAIT_EN)
+#define bfin_write_SDH_RD_WAIT_EN(val)	bfin_write16(SDH_RD_WAIT_EN, val)
+#define bfin_read_SDH_PID0()		bfin_read16(SDH_PID0)
+#define bfin_write_SDH_PID0(val)	bfin_write16(SDH_PID0, val)
+#define bfin_read_SDH_PID1()		bfin_read16(SDH_PID1)
+#define bfin_write_SDH_PID1(val)	bfin_write16(SDH_PID1, val)
+#define bfin_read_SDH_PID2()		bfin_read16(SDH_PID2)
+#define bfin_write_SDH_PID2(val)	bfin_write16(SDH_PID2, val)
+#define bfin_read_SDH_PID3()		bfin_read16(SDH_PID3)
+#define bfin_write_SDH_PID3(val)	bfin_write16(SDH_PID3, val)
+#define bfin_read_SDH_PID4()		bfin_read16(SDH_PID4)
+#define bfin_write_SDH_PID4(val)	bfin_write16(SDH_PID4, val)
+#define bfin_read_SDH_PID5()		bfin_read16(SDH_PID5)
+#define bfin_write_SDH_PID5(val)	bfin_write16(SDH_PID5, val)
+#define bfin_read_SDH_PID6()		bfin_read16(SDH_PID6)
+#define bfin_write_SDH_PID6(val)	bfin_write16(SDH_PID6, val)
+#define bfin_read_SDH_PID7()		bfin_read16(SDH_PID7)
+#define bfin_write_SDH_PID7(val)	bfin_write16(SDH_PID7, val)
+
+/* USB Control Registers */
+
+#define bfin_read_USB_FADDR()		bfin_read16(USB_FADDR)
+#define bfin_write_USB_FADDR(val)	bfin_write16(USB_FADDR, val)
+#define bfin_read_USB_POWER()		bfin_read16(USB_POWER)
+#define bfin_write_USB_POWER(val)	bfin_write16(USB_POWER, val)
+#define bfin_read_USB_INTRTX()		bfin_read16(USB_INTRTX)
+#define bfin_write_USB_INTRTX(val)	bfin_write16(USB_INTRTX, val)
+#define bfin_read_USB_INTRRX()		bfin_read16(USB_INTRRX)
+#define bfin_write_USB_INTRRX(val)	bfin_write16(USB_INTRRX, val)
+#define bfin_read_USB_INTRTXE()		bfin_read16(USB_INTRTXE)
+#define bfin_write_USB_INTRTXE(val)	bfin_write16(USB_INTRTXE, val)
+#define bfin_read_USB_INTRRXE()		bfin_read16(USB_INTRRXE)
+#define bfin_write_USB_INTRRXE(val)	bfin_write16(USB_INTRRXE, val)
+#define bfin_read_USB_INTRUSB()		bfin_read16(USB_INTRUSB)
+#define bfin_write_USB_INTRUSB(val)	bfin_write16(USB_INTRUSB, val)
+#define bfin_read_USB_INTRUSBE()	bfin_read16(USB_INTRUSBE)
+#define bfin_write_USB_INTRUSBE(val)	bfin_write16(USB_INTRUSBE, val)
+#define bfin_read_USB_FRAME()		bfin_read16(USB_FRAME)
+#define bfin_write_USB_FRAME(val)	bfin_write16(USB_FRAME, val)
+#define bfin_read_USB_INDEX()		bfin_read16(USB_INDEX)
+#define bfin_write_USB_INDEX(val)	bfin_write16(USB_INDEX, val)
+#define bfin_read_USB_TESTMODE()	fin_read16(USB_TESTMODE)
+#define bfin_write_USB_TESTMODE(val)	fin_write16(USB_TESTMODE, val)
+#define bfin_read_USB_GLOBINTR()	bfin_read16(USB_GLOBINTR)
+#define bfin_write_USB_GLOBINTR(val)	bfin_write16(USB_GLOBINTR, val)
+#define bfin_read_USB_GLOBAL_CTL()	bfin_read16(USB_GLOBAL_CTL)
+#define bfin_write_USB_GLOBAL_CTL(val)	bfin_write16(USB_GLOBAL_CTL, val)
+
+/* USB Packet Control Registers */
+
+#define bfin_read_USB_TX_MAX_PACKET()		bfin_read16(USB_TX_MAX_PACKET)
+#define bfin_write_USB_TX_MAX_PACKET(val)	bfin_write16(USB_TX_MAX_PACKET, val)
+#define bfin_read_USB_CSR0()			bfin_read16(USB_CSR0)
+#define bfin_write_USB_CSR0(val)		bfin_write16(USB_CSR0, val)
+#define bfin_read_USB_TXCSR()			bfin_read16(USB_TXCSR)
+#define bfin_write_USB_TXCSR(val)		bfin_write16(USB_TXCSR, val)
+#define bfin_read_USB_RX_MAX_PACKET()		bfin_read16(USB_RX_MAX_PACKET)
+#define bfin_write_USB_RX_MAX_PACKET(val)	bfin_write16(USB_RX_MAX_PACKET, val)
+#define bfin_read_USB_RXCSR()			bfin_read16(USB_RXCSR)
+#define bfin_write_USB_RXCSR(val)		bfin_write16(USB_RXCSR, val)
+#define bfin_read_USB_COUNT0()			bfin_read16(USB_COUNT0)
+#define bfin_write_USB_COUNT0(val)		bfin_write16(USB_COUNT0, val)
+#define bfin_read_USB_RXCOUNT()			bfin_read16(USB_RXCOUNT)
+#define bfin_write_USB_RXCOUNT(val)		bfin_write16(USB_RXCOUNT, val)
+#define bfin_read_USB_TXTYPE()			bfin_read16(USB_TXTYPE)
+#define bfin_write_USB_TXTYPE(val)		bfin_write16(USB_TXTYPE, val)
+#define bfin_read_USB_NAKLIMIT0()		bfin_read16(USB_NAKLIMIT0)
+#define bfin_write_USB_NAKLIMIT0(val)		bfin_write16(USB_NAKLIMIT0, val)
+#define bfin_read_USB_TXINTERVAL()		bfin_read16(USB_TXINTERVAL)
+#define bfin_write_USB_TXINTERVAL(val)		bfin_write16(USB_TXINTERVAL, val)
+#define bfin_read_USB_RXTYPE()			bfin_read16(USB_RXTYPE)
+#define bfin_write_USB_RXTYPE(val)		bfin_write16(USB_RXTYPE, val)
+#define bfin_read_USB_RXINTERVAL()		bfin_read16(USB_RXINTERVAL)
+#define bfin_write_USB_RXINTERVAL(val)		bfin_write16(USB_RXINTERVAL, val)
+#define bfin_read_USB_TXCOUNT()			bfin_read16(USB_TXCOUNT)
+#define bfin_write_USB_TXCOUNT(val)		bfin_write16(USB_TXCOUNT, val)
+
+/* USB Endbfin_read_()oint FIFO Registers */
+
+#define bfin_read_USB_EP0_FIFO()		bfin_read16(USB_EP0_FIFO)
+#define bfin_write_USB_EP0_FIFO(val)		bfin_write16(USB_EP0_FIFO, val)
+#define bfin_read_USB_EP1_FIFO()		bfin_read16(USB_EP1_FIFO)
+#define bfin_write_USB_EP1_FIFO(val)		bfin_write16(USB_EP1_FIFO, val)
+#define bfin_read_USB_EP2_FIFO()		bfin_read16(USB_EP2_FIFO)
+#define bfin_write_USB_EP2_FIFO(val)		bfin_write16(USB_EP2_FIFO, val)
+#define bfin_read_USB_EP3_FIFO()		bfin_read16(USB_EP3_FIFO)
+#define bfin_write_USB_EP3_FIFO(val)		bfin_write16(USB_EP3_FIFO, val)
+#define bfin_read_USB_EP4_FIFO()		bfin_read16(USB_EP4_FIFO)
+#define bfin_write_USB_EP4_FIFO(val)		bfin_write16(USB_EP4_FIFO, val)
+#define bfin_read_USB_EP5_FIFO()		bfin_read16(USB_EP5_FIFO)
+#define bfin_write_USB_EP5_FIFO(val)		bfin_write16(USB_EP5_FIFO, val)
+#define bfin_read_USB_EP6_FIFO()		bfin_read16(USB_EP6_FIFO)
+#define bfin_write_USB_EP6_FIFO(val)		bfin_write16(USB_EP6_FIFO, val)
+#define bfin_read_USB_EP7_FIFO()		bfin_read16(USB_EP7_FIFO)
+#define bfin_write_USB_EP7_FIFO(val)		bfin_write16(USB_EP7_FIFO, val)
+
+/* USB OTG Control Registers */
+
+#define bfin_read_USB_OTG_DEV_CTL()		bfin_read16(USB_OTG_DEV_CTL)
+#define bfin_write_USB_OTG_DEV_CTL(val)		bfin_write16(USB_OTG_DEV_CTL, val)
+#define bfin_read_USB_OTG_VBUS_IRQ()		bfin_read16(USB_OTG_VBUS_IRQ)
+#define bfin_write_USB_OTG_VBUS_IRQ(val)	fin_write16(USB_OTG_VBUS_IRQ, val)
+#define bfin_read_USB_OTG_VBUS_MASK()		bfin_read16(USB_OTG_VBUS_MASK)
+#define bfin_write_USB_OTG_VBUS_MASK(val)	bfin_write16(USB_OTG_VBUS_MASK, val)
+
+/* USB Phy Control Registers */
+
+#define bfin_read_USB_LINKINFO()		bfin_read16(USB_LINKINFO)
+#define bfin_write_USB_LINKINFO(val)		bfin_write16(USB_LINKINFO, val)
+#define bfin_read_USB_VPLEN()			bfin_read16(USB_VPLEN)
+#define bfin_write_USB_VPLEN(val)		bfin_write16(USB_VPLEN, val)
+#define bfin_read_USB_HS_EOF1()			bfin_read16(USB_HS_EOF1)
+#define bfin_write_USB_HS_EOF1(val)		bfin_write16(USB_HS_EOF1, val)
+#define bfin_read_USB_FS_EOF1()			bfin_read16(USB_FS_EOF1)
+#define bfin_write_USB_FS_EOF1(val)		bfin_write16(USB_FS_EOF1, val)
+#define bfin_read_USB_LS_EOF1()			bfin_read16(USB_LS_EOF1)
+#define bfin_write_USB_LS_EOF1(val)		bfin_write16(USB_LS_EOF1, val)
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CNTRL()		bfin_read16(USB_APHY_CNTRL)
+#define bfin_write_USB_APHY_CNTRL(val)		bfin_write16(USB_APHY_CNTRL, val)
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CALIB()		bfin_read16(USB_APHY_CALIB)
+#define bfin_write_USB_APHY_CALIB(val)		bfin_write16(USB_APHY_CALIB, val)
+#define bfin_read_USB_APHY_CNTRL2()		bfin_read16(USB_APHY_CNTRL2)
+#define bfin_write_USB_APHY_CNTRL2(val)		bfin_write16(USB_APHY_CNTRL2, val)
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define bfin_read_USB_PHY_TEST()		bfin_read16(USB_PHY_TEST)
+#define bfin_write_USB_PHY_TEST(val)		bfin_write16(USB_PHY_TEST, val)
+#define bfin_read_USB_PLLOSC_CTRL()		bfin_read16(USB_PLLOSC_CTRL)
+#define bfin_write_USB_PLLOSC_CTRL(val)		bfin_write16(USB_PLLOSC_CTRL, val)
+#define bfin_read_USB_SRP_CLKDIV()		bfin_read16(USB_SRP_CLKDIV)
+#define bfin_write_USB_SRP_CLKDIV(val)		bfin_write16(USB_SRP_CLKDIV, val)
+
+/* USB Endbfin_read_()oint 0 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXMAXP()		bfin_read16(USB_EP_NI0_TXMAXP)
+#define bfin_write_USB_EP_NI0_TXMAXP(val)	bfin_write16(USB_EP_NI0_TXMAXP, val)
+#define bfin_read_USB_EP_NI0_TXCSR()		bfin_read16(USB_EP_NI0_TXCSR)
+#define bfin_write_USB_EP_NI0_TXCSR(val)	bfin_write16(USB_EP_NI0_TXCSR, val)
+#define bfin_read_USB_EP_NI0_RXMAXP()		bfin_read16(USB_EP_NI0_RXMAXP)
+#define bfin_write_USB_EP_NI0_RXMAXP(val)	bfin_write16(USB_EP_NI0_RXMAXP, val)
+#define bfin_read_USB_EP_NI0_RXCSR()		bfin_read16(USB_EP_NI0_RXCSR)
+#define bfin_write_USB_EP_NI0_RXCSR(val)	bfin_write16(USB_EP_NI0_RXCSR, val)
+#define bfin_read_USB_EP_NI0_RXCOUNT()		bfin_read16(USB_EP_NI0_RXCOUNT)
+#define bfin_write_USB_EP_NI0_RXCOUNT(val)	bfin_write16(USB_EP_NI0_RXCOUNT, val)
+#define bfin_read_USB_EP_NI0_TXTYPE()		bfin_read16(USB_EP_NI0_TXTYPE)
+#define bfin_write_USB_EP_NI0_TXTYPE(val)	bfin_write16(USB_EP_NI0_TXTYPE, val)
+#define bfin_read_USB_EP_NI0_TXINTERVAL()	bfin_read16(USB_EP_NI0_TXINTERVAL)
+#define bfin_write_USB_EP_NI0_TXINTERVAL(val)	bfin_write16(USB_EP_NI0_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI0_RXTYPE()		bfin_read16(USB_EP_NI0_RXTYPE)
+#define bfin_write_USB_EP_NI0_RXTYPE(val)	bfin_write16(USB_EP_NI0_RXTYPE, val)
+#define bfin_read_USB_EP_NI0_RXINTERVAL()	bfin_read16(USB_EP_NI0_RXINTERVAL)
+#define bfin_write_USB_EP_NI0_RXINTERVAL(val)	bfin_write16(USB_EP_NI0_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 1 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXCOUNT()		bfin_read16(USB_EP_NI0_TXCOUNT)
+#define bfin_write_USB_EP_NI0_TXCOUNT(val)	bfin_write16(USB_EP_NI0_TXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXMAXP()		bfin_read16(USB_EP_NI1_TXMAXP)
+#define bfin_write_USB_EP_NI1_TXMAXP(val)	bfin_write16(USB_EP_NI1_TXMAXP, val)
+#define bfin_read_USB_EP_NI1_TXCSR()		bfin_read16(USB_EP_NI1_TXCSR)
+#define bfin_write_USB_EP_NI1_TXCSR(val)	bfin_write16(USB_EP_NI1_TXCSR, val)
+#define bfin_read_USB_EP_NI1_RXMAXP()		bfin_read16(USB_EP_NI1_RXMAXP)
+#define bfin_write_USB_EP_NI1_RXMAXP(val)	bfin_write16(USB_EP_NI1_RXMAXP, val)
+#define bfin_read_USB_EP_NI1_RXCSR()		bfin_read16(USB_EP_NI1_RXCSR)
+#define bfin_write_USB_EP_NI1_RXCSR(val)	bfin_write16(USB_EP_NI1_RXCSR, val)
+#define bfin_read_USB_EP_NI1_RXCOUNT()		bfin_read16(USB_EP_NI1_RXCOUNT)
+#define bfin_write_USB_EP_NI1_RXCOUNT(val)	bfin_write16(USB_EP_NI1_RXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXTYPE()		bfin_read16(USB_EP_NI1_TXTYPE)
+#define bfin_write_USB_EP_NI1_TXTYPE(val)	bfin_write16(USB_EP_NI1_TXTYPE, val)
+#define bfin_read_USB_EP_NI1_TXINTERVAL()	bfin_read16(USB_EP_NI1_TXINTERVAL)
+#define bfin_write_USB_EP_NI1_TXINTERVAL(val)	bfin_write16(USB_EP_NI1_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI1_RXTYPE()		bfin_read16(USB_EP_NI1_RXTYPE)
+#define bfin_write_USB_EP_NI1_RXTYPE(val)	bfin_write16(USB_EP_NI1_RXTYPE, val)
+#define bfin_read_USB_EP_NI1_RXINTERVAL()	bfin_read16(USB_EP_NI1_RXINTERVAL)
+#define bfin_write_USB_EP_NI1_RXINTERVAL(val)	bfin_write16(USB_EP_NI1_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 2 Control Registers */
+
+#define bfin_read_USB_EP_NI1_TXCOUNT()		bfin_read16(USB_EP_NI1_TXCOUNT)
+#define bfin_write_USB_EP_NI1_TXCOUNT(val)	bfin_write16(USB_EP_NI1_TXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXMAXP()		bfin_read16(USB_EP_NI2_TXMAXP)
+#define bfin_write_USB_EP_NI2_TXMAXP(val)	bfin_write16(USB_EP_NI2_TXMAXP, val)
+#define bfin_read_USB_EP_NI2_TXCSR()		bfin_read16(USB_EP_NI2_TXCSR)
+#define bfin_write_USB_EP_NI2_TXCSR(val)	bfin_write16(USB_EP_NI2_TXCSR, val)
+#define bfin_read_USB_EP_NI2_RXMAXP()		bfin_read16(USB_EP_NI2_RXMAXP)
+#define bfin_write_USB_EP_NI2_RXMAXP(val)	bfin_write16(USB_EP_NI2_RXMAXP, val)
+#define bfin_read_USB_EP_NI2_RXCSR()		bfin_read16(USB_EP_NI2_RXCSR)
+#define bfin_write_USB_EP_NI2_RXCSR(val)	bfin_write16(USB_EP_NI2_RXCSR, val)
+#define bfin_read_USB_EP_NI2_RXCOUNT()		bfin_read16(USB_EP_NI2_RXCOUNT)
+#define bfin_write_USB_EP_NI2_RXCOUNT(val)	bfin_write16(USB_EP_NI2_RXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXTYPE()		bfin_read16(USB_EP_NI2_TXTYPE)
+#define bfin_write_USB_EP_NI2_TXTYPE(val)	bfin_write16(USB_EP_NI2_TXTYPE, val)
+#define bfin_read_USB_EP_NI2_TXINTERVAL()	bfin_read16(USB_EP_NI2_TXINTERVAL)
+#define bfin_write_USB_EP_NI2_TXINTERVAL(val)	bfin_write16(USB_EP_NI2_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI2_RXTYPE()		bfin_read16(USB_EP_NI2_RXTYPE)
+#define bfin_write_USB_EP_NI2_RXTYPE(val)	bfin_write16(USB_EP_NI2_RXTYPE, val)
+#define bfin_read_USB_EP_NI2_RXINTERVAL()	bfin_read16(USB_EP_NI2_RXINTERVAL)
+#define bfin_write_USB_EP_NI2_RXINTERVAL(val)	bfin_write16(USB_EP_NI2_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 3 Control Registers */
+
+#define bfin_read_USB_EP_NI2_TXCOUNT()		bfin_read16(USB_EP_NI2_TXCOUNT)
+#define bfin_write_USB_EP_NI2_TXCOUNT(val)	bfin_write16(USB_EP_NI2_TXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXMAXP()		bfin_read16(USB_EP_NI3_TXMAXP)
+#define bfin_write_USB_EP_NI3_TXMAXP(val)	bfin_write16(USB_EP_NI3_TXMAXP, val)
+#define bfin_read_USB_EP_NI3_TXCSR()		bfin_read16(USB_EP_NI3_TXCSR)
+#define bfin_write_USB_EP_NI3_TXCSR(val)	bfin_write16(USB_EP_NI3_TXCSR, val)
+#define bfin_read_USB_EP_NI3_RXMAXP()		bfin_read16(USB_EP_NI3_RXMAXP)
+#define bfin_write_USB_EP_NI3_RXMAXP(val)	bfin_write16(USB_EP_NI3_RXMAXP, val)
+#define bfin_read_USB_EP_NI3_RXCSR()		bfin_read16(USB_EP_NI3_RXCSR)
+#define bfin_write_USB_EP_NI3_RXCSR(val)	bfin_write16(USB_EP_NI3_RXCSR, val)
+#define bfin_read_USB_EP_NI3_RXCOUNT()		bfin_read16(USB_EP_NI3_RXCOUNT)
+#define bfin_write_USB_EP_NI3_RXCOUNT(val)	bfin_write16(USB_EP_NI3_RXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXTYPE()		bfin_read16(USB_EP_NI3_TXTYPE)
+#define bfin_write_USB_EP_NI3_TXTYPE(val)	bfin_write16(USB_EP_NI3_TXTYPE, val)
+#define bfin_read_USB_EP_NI3_TXINTERVAL()	bfin_read16(USB_EP_NI3_TXINTERVAL)
+#define bfin_write_USB_EP_NI3_TXINTERVAL(val)	bfin_write16(USB_EP_NI3_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI3_RXTYPE()		bfin_read16(USB_EP_NI3_RXTYPE)
+#define bfin_write_USB_EP_NI3_RXTYPE(val)	bfin_write16(USB_EP_NI3_RXTYPE, val)
+#define bfin_read_USB_EP_NI3_RXINTERVAL()	bfin_read16(USB_EP_NI3_RXINTERVAL)
+#define bfin_write_USB_EP_NI3_RXINTERVAL(val)	bfin_write16(USB_EP_NI3_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 4 Control Registers */
+
+#define bfin_read_USB_EP_NI3_TXCOUNT()		bfin_read16(USB_EP_NI3_TXCOUNT)
+#define bfin_write_USB_EP_NI3_TXCOUNT(val)	bfin_write16(USB_EP_NI3_TXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXMAXP()		bfin_read16(USB_EP_NI4_TXMAXP)
+#define bfin_write_USB_EP_NI4_TXMAXP(val)	bfin_write16(USB_EP_NI4_TXMAXP, val)
+#define bfin_read_USB_EP_NI4_TXCSR()		bfin_read16(USB_EP_NI4_TXCSR)
+#define bfin_write_USB_EP_NI4_TXCSR(val)	bfin_write16(USB_EP_NI4_TXCSR, val)
+#define bfin_read_USB_EP_NI4_RXMAXP()		bfin_read16(USB_EP_NI4_RXMAXP)
+#define bfin_write_USB_EP_NI4_RXMAXP(val)	bfin_write16(USB_EP_NI4_RXMAXP, val)
+#define bfin_read_USB_EP_NI4_RXCSR()		bfin_read16(USB_EP_NI4_RXCSR)
+#define bfin_write_USB_EP_NI4_RXCSR(val)	bfin_write16(USB_EP_NI4_RXCSR, val)
+#define bfin_read_USB_EP_NI4_RXCOUNT()		bfin_read16(USB_EP_NI4_RXCOUNT)
+#define bfin_write_USB_EP_NI4_RXCOUNT(val)	bfin_write16(USB_EP_NI4_RXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXTYPE()		bfin_read16(USB_EP_NI4_TXTYPE)
+#define bfin_write_USB_EP_NI4_TXTYPE(val)	bfin_write16(USB_EP_NI4_TXTYPE, val)
+#define bfin_read_USB_EP_NI4_TXINTERVAL()	bfin_read16(USB_EP_NI4_TXINTERVAL)
+#define bfin_write_USB_EP_NI4_TXINTERVAL(val)	bfin_write16(USB_EP_NI4_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI4_RXTYPE()		bfin_read16(USB_EP_NI4_RXTYPE)
+#define bfin_write_USB_EP_NI4_RXTYPE(val)	bfin_write16(USB_EP_NI4_RXTYPE, val)
+#define bfin_read_USB_EP_NI4_RXINTERVAL()	bfin_read16(USB_EP_NI4_RXINTERVAL)
+#define bfin_write_USB_EP_NI4_RXINTERVAL(val)	bfin_write16(USB_EP_NI4_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 5 Control Registers */
+
+#define bfin_read_USB_EP_NI4_TXCOUNT()		bfin_read16(USB_EP_NI4_TXCOUNT)
+#define bfin_write_USB_EP_NI4_TXCOUNT(val)	bfin_write16(USB_EP_NI4_TXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXMAXP()		bfin_read16(USB_EP_NI5_TXMAXP)
+#define bfin_write_USB_EP_NI5_TXMAXP(val)	bfin_write16(USB_EP_NI5_TXMAXP, val)
+#define bfin_read_USB_EP_NI5_TXCSR()		bfin_read16(USB_EP_NI5_TXCSR)
+#define bfin_write_USB_EP_NI5_TXCSR(val)	bfin_write16(USB_EP_NI5_TXCSR, val)
+#define bfin_read_USB_EP_NI5_RXMAXP()		bfin_read16(USB_EP_NI5_RXMAXP)
+#define bfin_write_USB_EP_NI5_RXMAXP(val)	bfin_write16(USB_EP_NI5_RXMAXP, val)
+#define bfin_read_USB_EP_NI5_RXCSR()		bfin_read16(USB_EP_NI5_RXCSR)
+#define bfin_write_USB_EP_NI5_RXCSR(val)	bfin_write16(USB_EP_NI5_RXCSR, val)
+#define bfin_read_USB_EP_NI5_RXCOUNT()		bfin_read16(USB_EP_NI5_RXCOUNT)
+#define bfin_write_USB_EP_NI5_RXCOUNT(val)	bfin_write16(USB_EP_NI5_RXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXTYPE()		bfin_read16(USB_EP_NI5_TXTYPE)
+#define bfin_write_USB_EP_NI5_TXTYPE(val)	bfin_write16(USB_EP_NI5_TXTYPE, val)
+#define bfin_read_USB_EP_NI5_TXINTERVAL()	bfin_read16(USB_EP_NI5_TXINTERVAL)
+#define bfin_write_USB_EP_NI5_TXINTERVAL(val)	bfin_write16(USB_EP_NI5_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI5_RXTYPE()		bfin_read16(USB_EP_NI5_RXTYPE)
+#define bfin_write_USB_EP_NI5_RXTYPE(val)	bfin_write16(USB_EP_NI5_RXTYPE, val)
+#define bfin_read_USB_EP_NI5_RXINTERVAL()	bfin_read16(USB_EP_NI5_RXINTERVAL)
+#define bfin_write_USB_EP_NI5_RXINTERVAL(val)	bfin_write16(USB_EP_NI5_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 6 Control Registers */
+
+#define bfin_read_USB_EP_NI5_TXCOUNT()		bfin_read16(USB_EP_NI5_TXCOUNT)
+#define bfin_write_USB_EP_NI5_TXCOUNT(val)	bfin_write16(USB_EP_NI5_TXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXMAXP()		bfin_read16(USB_EP_NI6_TXMAXP)
+#define bfin_write_USB_EP_NI6_TXMAXP(val)	bfin_write16(USB_EP_NI6_TXMAXP, val)
+#define bfin_read_USB_EP_NI6_TXCSR()		bfin_read16(USB_EP_NI6_TXCSR)
+#define bfin_write_USB_EP_NI6_TXCSR(val)	bfin_write16(USB_EP_NI6_TXCSR, val)
+#define bfin_read_USB_EP_NI6_RXMAXP()		bfin_read16(USB_EP_NI6_RXMAXP)
+#define bfin_write_USB_EP_NI6_RXMAXP(val)	bfin_write16(USB_EP_NI6_RXMAXP, val)
+#define bfin_read_USB_EP_NI6_RXCSR()		bfin_read16(USB_EP_NI6_RXCSR)
+#define bfin_write_USB_EP_NI6_RXCSR(val)	bfin_write16(USB_EP_NI6_RXCSR, val)
+#define bfin_read_USB_EP_NI6_RXCOUNT()		bfin_read16(USB_EP_NI6_RXCOUNT)
+#define bfin_write_USB_EP_NI6_RXCOUNT(val)	bfin_write16(USB_EP_NI6_RXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXTYPE()		bfin_read16(USB_EP_NI6_TXTYPE)
+#define bfin_write_USB_EP_NI6_TXTYPE(val)	bfin_write16(USB_EP_NI6_TXTYPE, val)
+#define bfin_read_USB_EP_NI6_TXINTERVAL()	bfin_read16(USB_EP_NI6_TXINTERVAL)
+#define bfin_write_USB_EP_NI6_TXINTERVAL(val)	bfin_write16(USB_EP_NI6_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI6_RXTYPE()		bfin_read16(USB_EP_NI6_RXTYPE)
+#define bfin_write_USB_EP_NI6_RXTYPE(val)	bfin_write16(USB_EP_NI6_RXTYPE, val)
+#define bfin_read_USB_EP_NI6_RXINTERVAL()	bfin_read16(USB_EP_NI6_RXINTERVAL)
+#define bfin_write_USB_EP_NI6_RXINTERVAL(val)	bfin_write16(USB_EP_NI6_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 7 Control Registers */
+
+#define bfin_read_USB_EP_NI6_TXCOUNT()		bfin_read16(USB_EP_NI6_TXCOUNT)
+#define bfin_write_USB_EP_NI6_TXCOUNT(val)	bfin_write16(USB_EP_NI6_TXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXMAXP()		bfin_read16(USB_EP_NI7_TXMAXP)
+#define bfin_write_USB_EP_NI7_TXMAXP(val)	bfin_write16(USB_EP_NI7_TXMAXP, val)
+#define bfin_read_USB_EP_NI7_TXCSR()		bfin_read16(USB_EP_NI7_TXCSR)
+#define bfin_write_USB_EP_NI7_TXCSR(val)	bfin_write16(USB_EP_NI7_TXCSR, val)
+#define bfin_read_USB_EP_NI7_RXMAXP()		bfin_read16(USB_EP_NI7_RXMAXP)
+#define bfin_write_USB_EP_NI7_RXMAXP(val)	bfin_write16(USB_EP_NI7_RXMAXP, val)
+#define bfin_read_USB_EP_NI7_RXCSR()		bfin_read16(USB_EP_NI7_RXCSR)
+#define bfin_write_USB_EP_NI7_RXCSR(val)	bfin_write16(USB_EP_NI7_RXCSR, val)
+#define bfin_read_USB_EP_NI7_RXCOUNT()		bfin_read16(USB_EP_NI7_RXCOUNT)
+#define bfin_write_USB_EP_NI7_RXCOUNT(val)	bfin_write16(USB_EP_NI7_RXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXTYPE()		bfin_read16(USB_EP_NI7_TXTYPE)
+#define bfin_write_USB_EP_NI7_TXTYPE(val)	bfin_write16(USB_EP_NI7_TXTYPE, val)
+#define bfin_read_USB_EP_NI7_TXINTERVAL()	bfin_read16(USB_EP_NI7_TXINTERVAL)
+#define bfin_write_USB_EP_NI7_TXINTERVAL(val)	bfin_write16(USB_EP_NI7_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_RXTYPE()		bfin_read16(USB_EP_NI7_RXTYPE)
+#define bfin_write_USB_EP_NI7_RXTYPE(val)	bfin_write16(USB_EP_NI7_RXTYPE, val)
+#define bfin_read_USB_EP_NI7_RXINTERVAL()	bfin_read16(USB_EP_NI7_RXINTERVAL)
+#define bfin_write_USB_EP_NI7_RXINTERVAL(val)	bfin_write16(USB_EP_NI7_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_TXCOUNT()		bfin_read16(USB_EP_NI7_TXCOUNT)
+#define bfin_write_USB_EP_NI7_TXCOUNT(val)	bfin_write16(USB_EP_NI7_TXCOUNT, val)
+#define bfin_read_USB_DMA_INTERRUPT()		bfin_read16(USB_DMA_INTERRUPT)
+#define bfin_write_USB_DMA_INTERRUPT(val)	bfin_write16(USB_DMA_INTERRUPT, val)
+
+/* USB Channel 0 Config Registers */
+
+#define bfin_read_USB_DMA0CONTROL()		bfin_read16(USB_DMA0CONTROL)
+#define bfin_write_USB_DMA0CONTROL(val)		bfin_write16(USB_DMA0CONTROL, val)
+#define bfin_read_USB_DMA0ADDRLOW()		bfin_read16(USB_DMA0ADDRLOW)
+#define bfin_write_USB_DMA0ADDRLOW(val)		bfin_write16(USB_DMA0ADDRLOW, val)
+#define bfin_read_USB_DMA0ADDRHIGH()		bfin_read16(USB_DMA0ADDRHIGH)
+#define bfin_write_USB_DMA0ADDRHIGH(val)	bfin_write16(USB_DMA0ADDRHIGH, val)
+#define bfin_read_USB_DMA0COUNTLOW()		bfin_read16(USB_DMA0COUNTLOW)
+#define bfin_write_USB_DMA0COUNTLOW(val)	bfin_write16(USB_DMA0COUNTLOW, val)
+#define bfin_read_USB_DMA0COUNTHIGH()		bfin_read16(USB_DMA0COUNTHIGH)
+#define bfin_write_USB_DMA0COUNTHIGH(val)	bfin_write16(USB_DMA0COUNTHIGH, val)
+
+/* USB Channel 1 Config Registers */
+
+#define bfin_read_USB_DMA1CONTROL()		bfin_read16(USB_DMA1CONTROL)
+#define bfin_write_USB_DMA1CONTROL(val)		bfin_write16(USB_DMA1CONTROL, val)
+#define bfin_read_USB_DMA1ADDRLOW()		bfin_read16(USB_DMA1ADDRLOW)
+#define bfin_write_USB_DMA1ADDRLOW(val)		bfin_write16(USB_DMA1ADDRLOW, val)
+#define bfin_read_USB_DMA1ADDRHIGH()		bfin_read16(USB_DMA1ADDRHIGH)
+#define bfin_write_USB_DMA1ADDRHIGH(val)	bfin_write16(USB_DMA1ADDRHIGH, val)
+#define bfin_read_USB_DMA1COUNTLOW()		bfin_read16(USB_DMA1COUNTLOW)
+#define bfin_write_USB_DMA1COUNTLOW(val)	bfin_write16(USB_DMA1COUNTLOW, val)
+#define bfin_read_USB_DMA1COUNTHIGH()		bfin_read16(USB_DMA1COUNTHIGH)
+#define bfin_write_USB_DMA1COUNTHIGH(val)	bfin_write16(USB_DMA1COUNTHIGH, val)
+
+/* USB Channel 2 Config Registers */
+
+#define bfin_read_USB_DMA2CONTROL()		bfin_read16(USB_DMA2CONTROL)
+#define bfin_write_USB_DMA2CONTROL(val)		bfin_write16(USB_DMA2CONTROL, val)
+#define bfin_read_USB_DMA2ADDRLOW()		bfin_read16(USB_DMA2ADDRLOW)
+#define bfin_write_USB_DMA2ADDRLOW(val)		bfin_write16(USB_DMA2ADDRLOW, val)
+#define bfin_read_USB_DMA2ADDRHIGH()		bfin_read16(USB_DMA2ADDRHIGH)
+#define bfin_write_USB_DMA2ADDRHIGH(val)	bfin_write16(USB_DMA2ADDRHIGH, val)
+#define bfin_read_USB_DMA2COUNTLOW()		bfin_read16(USB_DMA2COUNTLOW)
+#define bfin_write_USB_DMA2COUNTLOW(val)	bfin_write16(USB_DMA2COUNTLOW, val)
+#define bfin_read_USB_DMA2COUNTHIGH()		bfin_read16(USB_DMA2COUNTHIGH)
+#define bfin_write_USB_DMA2COUNTHIGH(val)	bfin_write16(USB_DMA2COUNTHIGH, val)
+
+/* USB Channel 3 Config Registers */
+
+#define bfin_read_USB_DMA3CONTROL()		bfin_read16(USB_DMA3CONTROL)
+#define bfin_write_USB_DMA3CONTROL(val)		bfin_write16(USB_DMA3CONTROL, val)
+#define bfin_read_USB_DMA3ADDRLOW()		bfin_read16(USB_DMA3ADDRLOW)
+#define bfin_write_USB_DMA3ADDRLOW(val)		bfin_write16(USB_DMA3ADDRLOW, val)
+#define bfin_read_USB_DMA3ADDRHIGH()		bfin_read16(USB_DMA3ADDRHIGH)
+#define bfin_write_USB_DMA3ADDRHIGH(val)	bfin_write16(USB_DMA3ADDRHIGH, val)
+#define bfin_read_USB_DMA3COUNTLOW()		bfin_read16(USB_DMA3COUNTLOW)
+#define bfin_write_USB_DMA3COUNTLOW(val)	bfin_write16(USB_DMA3COUNTLOW, val)
+#define bfin_read_USB_DMA3COUNTHIGH()		bfin_read16(USB_DMA3COUNTHIGH)
+#define bfin_write_USB_DMA3COUNTHIGH(val)	bfin_write16(USB_DMA3COUNTHIGH, val)
+
+/* USB Channel 4 Config Registers */
+
+#define bfin_read_USB_DMA4CONTROL()		bfin_read16(USB_DMA4CONTROL)
+#define bfin_write_USB_DMA4CONTROL(val)		bfin_write16(USB_DMA4CONTROL, val)
+#define bfin_read_USB_DMA4ADDRLOW()		bfin_read16(USB_DMA4ADDRLOW)
+#define bfin_write_USB_DMA4ADDRLOW(val)		bfin_write16(USB_DMA4ADDRLOW, val)
+#define bfin_read_USB_DMA4ADDRHIGH()		bfin_read16(USB_DMA4ADDRHIGH)
+#define bfin_write_USB_DMA4ADDRHIGH(val)	bfin_write16(USB_DMA4ADDRHIGH, val)
+#define bfin_read_USB_DMA4COUNTLOW()		bfin_read16(USB_DMA4COUNTLOW)
+#define bfin_write_USB_DMA4COUNTLOW(val)	bfin_write16(USB_DMA4COUNTLOW, val)
+#define bfin_read_USB_DMA4COUNTHIGH()		bfin_read16(USB_DMA4COUNTHIGH)
+#define bfin_write_USB_DMA4COUNTHIGH(val)	bfin_write16(USB_DMA4COUNTHIGH, val)
+
+/* USB Channel 5 Config Registers */
+
+#define bfin_read_USB_DMA5CONTROL()		bfin_read16(USB_DMA5CONTROL)
+#define bfin_write_USB_DMA5CONTROL(val)		bfin_write16(USB_DMA5CONTROL, val)
+#define bfin_read_USB_DMA5ADDRLOW()		bfin_read16(USB_DMA5ADDRLOW)
+#define bfin_write_USB_DMA5ADDRLOW(val)		bfin_write16(USB_DMA5ADDRLOW, val)
+#define bfin_read_USB_DMA5ADDRHIGH()		bfin_read16(USB_DMA5ADDRHIGH)
+#define bfin_write_USB_DMA5ADDRHIGH(val)	bfin_write16(USB_DMA5ADDRHIGH, val)
+#define bfin_read_USB_DMA5COUNTLOW()		bfin_read16(USB_DMA5COUNTLOW)
+#define bfin_write_USB_DMA5COUNTLOW(val)	bfin_write16(USB_DMA5COUNTLOW, val)
+#define bfin_read_USB_DMA5COUNTHIGH()		bfin_read16(USB_DMA5COUNTHIGH)
+#define bfin_write_USB_DMA5COUNTHIGH(val)	bfin_write16(USB_DMA5COUNTHIGH, val)
+
+/* USB Channel 6 Config Registers */
+
+#define bfin_read_USB_DMA6CONTROL()		bfin_read16(USB_DMA6CONTROL)
+#define bfin_write_USB_DMA6CONTROL(val)		bfin_write16(USB_DMA6CONTROL, val)
+#define bfin_read_USB_DMA6ADDRLOW()		bfin_read16(USB_DMA6ADDRLOW)
+#define bfin_write_USB_DMA6ADDRLOW(val)		bfin_write16(USB_DMA6ADDRLOW, val)
+#define bfin_read_USB_DMA6ADDRHIGH()		bfin_read16(USB_DMA6ADDRHIGH)
+#define bfin_write_USB_DMA6ADDRHIGH(val)	bfin_write16(USB_DMA6ADDRHIGH, val)
+#define bfin_read_USB_DMA6COUNTLOW()		bfin_read16(USB_DMA6COUNTLOW)
+#define bfin_write_USB_DMA6COUNTLOW(val)	bfin_write16(USB_DMA6COUNTLOW, val)
+#define bfin_read_USB_DMA6COUNTHIGH()		bfin_read16(USB_DMA6COUNTHIGH)
+#define bfin_write_USB_DMA6COUNTHIGH(val)	bfin_write16(USB_DMA6COUNTHIGH, val)
+
+/* USB Channel 7 Config Registers */
+
+#define bfin_read_USB_DMA7CONTROL()		bfin_read16(USB_DMA7CONTROL)
+#define bfin_write_USB_DMA7CONTROL(val)		bfin_write16(USB_DMA7CONTROL, val)
+#define bfin_read_USB_DMA7ADDRLOW()		bfin_read16(USB_DMA7ADDRLOW)
+#define bfin_write_USB_DMA7ADDRLOW(val)		bfin_write16(USB_DMA7ADDRLOW, val)
+#define bfin_read_USB_DMA7ADDRHIGH()		bfin_read16(USB_DMA7ADDRHIGH)
+#define bfin_write_USB_DMA7ADDRHIGH(val)	bfin_write16(USB_DMA7ADDRHIGH, val)
+#define bfin_read_USB_DMA7COUNTLOW()		bfin_read16(USB_DMA7COUNTLOW)
+#define bfin_write_USB_DMA7COUNTLOW(val)	bfin_write16(USB_DMA7COUNTLOW, val)
+#define bfin_read_USB_DMA7COUNTHIGH()		bfin_read16(USB_DMA7COUNTHIGH)
+#define bfin_write_USB_DMA7COUNTHIGH(val)	bfin_write16(USB_DMA7COUNTHIGH, val)
+
+/* Keybfin_read_()ad Registers */
+
+#define bfin_read_KPAD_CTL()			bfin_read16(KPAD_CTL)
+#define bfin_write_KPAD_CTL(val)		bfin_write16(KPAD_CTL, val)
+#define bfin_read_KPAD_PRESCALE()		bfin_read16(KPAD_PRESCALE)
+#define bfin_write_KPAD_PRESCALE(val)		bfin_write16(KPAD_PRESCALE, val)
+#define bfin_read_KPAD_MSEL()			bfin_read16(KPAD_MSEL)
+#define bfin_write_KPAD_MSEL(val)		bfin_write16(KPAD_MSEL, val)
+#define bfin_read_KPAD_ROWCOL()			bfin_read16(KPAD_ROWCOL)
+#define bfin_write_KPAD_ROWCOL(val)		bfin_write16(KPAD_ROWCOL, val)
+#define bfin_read_KPAD_STAT()			bfin_read16(KPAD_STAT)
+#define bfin_write_KPAD_STAT(val)		bfin_write16(KPAD_STAT, val)
+#define bfin_read_KPAD_SOFTEVAL()		bfin_read16(KPAD_SOFTEVAL)
+#define bfin_write_KPAD_SOFTEVAL(val)		bfin_write16(KPAD_SOFTEVAL, val)
+
+#endif /* _CDEF_BF542_H */
diff --git a/include/asm-blackfin/mach-bf548/cdefBF544.h b/include/asm-blackfin/mach-bf548/cdefBF544.h
new file mode 100644
index 0000000..7a2d177
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/cdefBF544.h
@@ -0,0 +1,978 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/cdefBF544.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF544_H
+#define _CDEF_BF544_H
+
+/* include all Core registers and bit definitions */
+#include "defBF544.h"
+
+/* include core sbfin_read_()ecific register pointer definitions */
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF544 */
+
+/* include cdefBF54x_base.h for the set of #defines that are common to all ADSP-BF54x bfin_read_()rocessors */
+#include "cdefBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF544 that are not in the common header */
+
+/* Timer Registers */
+
+#define bfin_read_TIMER8_CONFIG()		bfin_read16(TIMER8_CONFIG)
+#define bfin_write_TIMER8_CONFIG(val)		bfin_write16(TIMER8_CONFIG, val)
+#define bfin_read_TIMER8_COUNTER()		bfin_read32(TIMER8_COUNTER)
+#define bfin_write_TIMER8_COUNTER(val)		bfin_write32(TIMER8_COUNTER, val)
+#define bfin_read_TIMER8_PERIOD()		bfin_read32(TIMER8_PERIOD)
+#define bfin_write_TIMER8_PERIOD(val)		bfin_write32(TIMER8_PERIOD, val)
+#define bfin_read_TIMER8_WIDTH()		bfin_read32(TIMER8_WIDTH)
+#define bfin_write_TIMER8_WIDTH(val)		bfin_write32(TIMER8_WIDTH, val)
+#define bfin_read_TIMER9_CONFIG()		bfin_read16(TIMER9_CONFIG)
+#define bfin_write_TIMER9_CONFIG(val)		bfin_write16(TIMER9_CONFIG, val)
+#define bfin_read_TIMER9_COUNTER()		bfin_read32(TIMER9_COUNTER)
+#define bfin_write_TIMER9_COUNTER(val)		bfin_write32(TIMER9_COUNTER, val)
+#define bfin_read_TIMER9_PERIOD()		bfin_read32(TIMER9_PERIOD)
+#define bfin_write_TIMER9_PERIOD(val)		bfin_write32(TIMER9_PERIOD, val)
+#define bfin_read_TIMER9_WIDTH()		bfin_read32(TIMER9_WIDTH)
+#define bfin_write_TIMER9_WIDTH(val)		bfin_write32(TIMER9_WIDTH, val)
+#define bfin_read_TIMER10_CONFIG()		bfin_read16(TIMER10_CONFIG)
+#define bfin_write_TIMER10_CONFIG(val)		bfin_write16(TIMER10_CONFIG, val)
+#define bfin_read_TIMER10_COUNTER()		bfin_read32(TIMER10_COUNTER)
+#define bfin_write_TIMER10_COUNTER(val)		bfin_write32(TIMER10_COUNTER, val)
+#define bfin_read_TIMER10_PERIOD()		bfin_read32(TIMER10_PERIOD)
+#define bfin_write_TIMER10_PERIOD(val)		bfin_write32(TIMER10_PERIOD, val)
+#define bfin_read_TIMER10_WIDTH()		bfin_read32(TIMER10_WIDTH)
+#define bfin_write_TIMER10_WIDTH(val)		bfin_write32(TIMER10_WIDTH, val)
+
+/* Timer Groubfin_read_() of 3 */
+
+#define bfin_read_TIMER_ENABLE1()		bfin_read16(TIMER_ENABLE1)
+#define bfin_write_TIMER_ENABLE1(val)		bfin_write16(TIMER_ENABLE1, val)
+#define bfin_read_TIMER_DISABLE1()		bfin_read16(TIMER_DISABLE1)
+#define bfin_write_TIMER_DISABLE1(val)		bfin_write16(TIMER_DISABLE1, val)
+#define bfin_read_TIMER_STATUS1()		bfin_read32(TIMER_STATUS1)
+#define bfin_write_TIMER_STATUS1(val)		bfin_write32(TIMER_STATUS1, val)
+
+/* EPPI0 Registers */
+
+#define bfin_read_EPPI0_STATUS()		bfin_read16(EPPI0_STATUS)
+#define bfin_write_EPPI0_STATUS(val)		bfin_write16(EPPI0_STATUS, val)
+#define bfin_read_EPPI0_HCOUNT()		bfin_read16(EPPI0_HCOUNT)
+#define bfin_write_EPPI0_HCOUNT(val)		bfin_write16(EPPI0_HCOUNT, val)
+#define bfin_read_EPPI0_HDELAY()		bfin_read16(EPPI0_HDELAY)
+#define bfin_write_EPPI0_HDELAY(val)		bfin_write16(EPPI0_HDELAY, val)
+#define bfin_read_EPPI0_VCOUNT()		bfin_read16(EPPI0_VCOUNT)
+#define bfin_write_EPPI0_VCOUNT(val)		bfin_write16(EPPI0_VCOUNT, val)
+#define bfin_read_EPPI0_VDELAY()		bfin_read16(EPPI0_VDELAY)
+#define bfin_write_EPPI0_VDELAY(val)		bfin_write16(EPPI0_VDELAY, val)
+#define bfin_read_EPPI0_FRAME()			bfin_read16(EPPI0_FRAME)
+#define bfin_write_EPPI0_FRAME(val)		bfin_write16(EPPI0_FRAME, val)
+#define bfin_read_EPPI0_LINE()			bfin_read16(EPPI0_LINE)
+#define bfin_write_EPPI0_LINE(val)		bfin_write16(EPPI0_LINE, val)
+#define bfin_read_EPPI0_CLKDIV()		bfin_read16(EPPI0_CLKDIV)
+#define bfin_write_EPPI0_CLKDIV(val)		bfin_write16(EPPI0_CLKDIV, val)
+#define bfin_read_EPPI0_CONTROL()		bfin_read32(EPPI0_CONTROL)
+#define bfin_write_EPPI0_CONTROL(val)		bfin_write32(EPPI0_CONTROL, val)
+#define bfin_read_EPPI0_FS1W_HBL()		bfin_read32(EPPI0_FS1W_HBL)
+#define bfin_write_EPPI0_FS1W_HBL(val)		bfin_write32(EPPI0_FS1W_HBL, val)
+#define bfin_read_EPPI0_FS1P_AVPL()		bfin_read32(EPPI0_FS1P_AVPL)
+#define bfin_write_EPPI0_FS1P_AVPL(val)		bfin_write32(EPPI0_FS1P_AVPL, val)
+#define bfin_read_EPPI0_FS2W_LVB()		bfin_read32(EPPI0_FS2W_LVB)
+#define bfin_write_EPPI0_FS2W_LVB(val)		bfin_write32(EPPI0_FS2W_LVB, val)
+#define bfin_read_EPPI0_FS2P_LAVF()		bfin_read32(EPPI0_FS2P_LAVF)
+#define bfin_write_EPPI0_FS2P_LAVF(val)		bfin_write32(EPPI0_FS2P_LAVF, val)
+#define bfin_read_EPPI0_CLIP()			bfin_read32(EPPI0_CLIP)
+#define bfin_write_EPPI0_CLIP(val)		bfin_write32(EPPI0_CLIP, val)
+
+/* Two Wire Interface Registers (TWI1) */
+
+#define bfin_read_TWI1_CLKDIV()			bfin_read16(TWI1_CLKDIV)
+#define bfin_write_TWI1_CLKDIV(val)		bfin_write16(TWI1_CLKDIV, val)
+#define bfin_read_TWI1_CONTROL()		bfin_read16(TWI1_CONTROL)
+#define bfin_write_TWI1_CONTROL(val)		bfin_write16(TWI1_CONTROL, val)
+#define bfin_read_TWI1_SLAVE_CTRL()		bfin_read16(TWI1_SLAVE_CTRL)
+#define bfin_write_TWI1_SLAVE_CTRL(val)		bfin_write16(TWI1_SLAVE_CTRL, val)
+#define bfin_read_TWI1_SLAVE_STAT()		bfin_read16(TWI1_SLAVE_STAT)
+#define bfin_write_TWI1_SLAVE_STAT(val)		bfin_write16(TWI1_SLAVE_STAT, val)
+#define bfin_read_TWI1_SLAVE_ADDR()		bfin_read16(TWI1_SLAVE_ADDR)
+#define bfin_write_TWI1_SLAVE_ADDR(val)		bfin_write16(TWI1_SLAVE_ADDR, val)
+#define bfin_read_TWI1_MASTER_CTRL()		bfin_read16(TWI1_MASTER_CTRL)
+#define bfin_write_TWI1_MASTER_CTRL(val)	bfin_write16(TWI1_MASTER_CTRL, val)
+#define bfin_read_TWI1_MASTER_STAT()		bfin_read16(TWI1_MASTER_STAT)
+#define bfin_write_TWI1_MASTER_STAT(val)	bfin_write16(TWI1_MASTER_STAT, val)
+#define bfin_read_TWI1_MASTER_ADDR()		bfin_read16(TWI1_MASTER_ADDR)
+#define bfin_write_TWI1_MASTER_ADDR(val)	bfin_write16(TWI1_MASTER_ADDR, val)
+#define bfin_read_TWI1_INT_STAT()		bfin_read16(TWI1_INT_STAT)
+#define bfin_write_TWI1_INT_STAT(val)		bfin_write16(TWI1_INT_STAT, val)
+#define bfin_read_TWI1_INT_MASK()		bfin_read16(TWI1_INT_MASK)
+#define bfin_write_TWI1_INT_MASK(val)		bfin_write16(TWI1_INT_MASK, val)
+#define bfin_read_TWI1_FIFO_CTRL()		bfin_read16(TWI1_FIFO_CTRL)
+#define bfin_write_TWI1_FIFO_CTRL(val)		bfin_write16(TWI1_FIFO_CTRL, val)
+#define bfin_read_TWI1_FIFO_STAT()		bfin_read16(TWI1_FIFO_STAT)
+#define bfin_write_TWI1_FIFO_STAT(val)		bfin_write16(TWI1_FIFO_STAT, val)
+#define bfin_read_TWI1_XMT_DATA8()		bfin_read16(TWI1_XMT_DATA8)
+#define bfin_write_TWI1_XMT_DATA8(val)		bfin_write16(TWI1_XMT_DATA8, val)
+#define bfin_read_TWI1_XMT_DATA16()		bfin_read16(TWI1_XMT_DATA16)
+#define bfin_write_TWI1_XMT_DATA16(val)		bfin_write16(TWI1_XMT_DATA16, val)
+#define bfin_read_TWI1_RCV_DATA8()		bfin_read16(TWI1_RCV_DATA8)
+#define bfin_write_TWI1_RCV_DATA8(val)		bfin_write16(TWI1_RCV_DATA8, val)
+#define bfin_read_TWI1_RCV_DATA16()		bfin_read16(TWI1_RCV_DATA16)
+#define bfin_write_TWI1_RCV_DATA16(val)		bfin_write16(TWI1_RCV_DATA16, val)
+
+/* CAN Controller 1 Config 1 Registers */
+
+#define bfin_read_CAN1_MC1()		bfin_read16(CAN1_MC1)
+#define bfin_write_CAN1_MC1(val)	bfin_write16(CAN1_MC1, val)
+#define bfin_read_CAN1_MD1()		bfin_read16(CAN1_MD1)
+#define bfin_write_CAN1_MD1(val)	bfin_write16(CAN1_MD1, val)
+#define bfin_read_CAN1_TRS1()		bfin_read16(CAN1_TRS1)
+#define bfin_write_CAN1_TRS1(val)	bfin_write16(CAN1_TRS1, val)
+#define bfin_read_CAN1_TRR1()		bfin_read16(CAN1_TRR1)
+#define bfin_write_CAN1_TRR1(val)	bfin_write16(CAN1_TRR1, val)
+#define bfin_read_CAN1_TA1()		bfin_read16(CAN1_TA1)
+#define bfin_write_CAN1_TA1(val)	bfin_write16(CAN1_TA1, val)
+#define bfin_read_CAN1_AA1()		bfin_read16(CAN1_AA1)
+#define bfin_write_CAN1_AA1(val)	bfin_write16(CAN1_AA1, val)
+#define bfin_read_CAN1_RMP1()		bfin_read16(CAN1_RMP1)
+#define bfin_write_CAN1_RMP1(val)	bfin_write16(CAN1_RMP1, val)
+#define bfin_read_CAN1_RML1()		bfin_read16(CAN1_RML1)
+#define bfin_write_CAN1_RML1(val)	bfin_write16(CAN1_RML1, val)
+#define bfin_read_CAN1_MBTIF1()		bfin_read16(CAN1_MBTIF1)
+#define bfin_write_CAN1_MBTIF1(val)	bfin_write16(CAN1_MBTIF1, val)
+#define bfin_read_CAN1_MBRIF1()		bfin_read16(CAN1_MBRIF1)
+#define bfin_write_CAN1_MBRIF1(val)	bfin_write16(CAN1_MBRIF1, val)
+#define bfin_read_CAN1_MBIM1()		bfin_read16(CAN1_MBIM1)
+#define bfin_write_CAN1_MBIM1(val)	bfin_write16(CAN1_MBIM1, val)
+#define bfin_read_CAN1_RFH1()		bfin_read16(CAN1_RFH1)
+#define bfin_write_CAN1_RFH1(val)	bfin_write16(CAN1_RFH1, val)
+#define bfin_read_CAN1_OPSS1()		bfin_read16(CAN1_OPSS1)
+#define bfin_write_CAN1_OPSS1(val)	bfin_write16(CAN1_OPSS1, val)
+
+/* CAN Controller 1 Config 2 Registers */
+
+#define bfin_read_CAN1_MC2()		bfin_read16(CAN1_MC2)
+#define bfin_write_CAN1_MC2(val)	bfin_write16(CAN1_MC2, val)
+#define bfin_read_CAN1_MD2()		bfin_read16(CAN1_MD2)
+#define bfin_write_CAN1_MD2(val)	bfin_write16(CAN1_MD2, val)
+#define bfin_read_CAN1_TRS2()		bfin_read16(CAN1_TRS2)
+#define bfin_write_CAN1_TRS2(val)	bfin_write16(CAN1_TRS2, val)
+#define bfin_read_CAN1_TRR2()		bfin_read16(CAN1_TRR2)
+#define bfin_write_CAN1_TRR2(val)	bfin_write16(CAN1_TRR2, val)
+#define bfin_read_CAN1_TA2()		bfin_read16(CAN1_TA2)
+#define bfin_write_CAN1_TA2(val)	bfin_write16(CAN1_TA2, val)
+#define bfin_read_CAN1_AA2()		bfin_read16(CAN1_AA2)
+#define bfin_write_CAN1_AA2(val)	bfin_write16(CAN1_AA2, val)
+#define bfin_read_CAN1_RMP2()		bfin_read16(CAN1_RMP2)
+#define bfin_write_CAN1_RMP2(val)	bfin_write16(CAN1_RMP2, val)
+#define bfin_read_CAN1_RML2()		bfin_read16(CAN1_RML2)
+#define bfin_write_CAN1_RML2(val)	bfin_write16(CAN1_RML2, val)
+#define bfin_read_CAN1_MBTIF2()		bfin_read16(CAN1_MBTIF2)
+#define bfin_write_CAN1_MBTIF2(val)	bfin_write16(CAN1_MBTIF2, val)
+#define bfin_read_CAN1_MBRIF2()		bfin_read16(CAN1_MBRIF2)
+#define bfin_write_CAN1_MBRIF2(val)	bfin_write16(CAN1_MBRIF2, val)
+#define bfin_read_CAN1_MBIM2()		bfin_read16(CAN1_MBIM2)
+#define bfin_write_CAN1_MBIM2(val)	bfin_write16(CAN1_MBIM2, val)
+#define bfin_read_CAN1_RFH2()		bfin_read16(CAN1_RFH2)
+#define bfin_write_CAN1_RFH2(val)	bfin_write16(CAN1_RFH2, val)
+#define bfin_read_CAN1_OPSS2()		bfin_read16(CAN1_OPSS2)
+#define bfin_write_CAN1_OPSS2(val)	bfin_write16(CAN1_OPSS2, val)
+
+/* CAN Controller 1 Clock/Interrubfin_read_()t/Counter Registers */
+
+#define bfin_read_CAN1_CLOCK()		bfin_read16(CAN1_CLOCK)
+#define bfin_write_CAN1_CLOCK(val)	bfin_write16(CAN1_CLOCK, val)
+#define bfin_read_CAN1_TIMING()		bfin_read16(CAN1_TIMING)
+#define bfin_write_CAN1_TIMING(val)	bfin_write16(CAN1_TIMING, val)
+#define bfin_read_CAN1_DEBUG()		bfin_read16(CAN1_DEBUG)
+#define bfin_write_CAN1_DEBUG(val)	bfin_write16(CAN1_DEBUG, val)
+#define bfin_read_CAN1_STATUS()		bfin_read16(CAN1_STATUS)
+#define bfin_write_CAN1_STATUS(val)	bfin_write16(CAN1_STATUS, val)
+#define bfin_read_CAN1_CEC()		bfin_read16(CAN1_CEC)
+#define bfin_write_CAN1_CEC(val)	bfin_write16(CAN1_CEC, val)
+#define bfin_read_CAN1_GIS()		bfin_read16(CAN1_GIS)
+#define bfin_write_CAN1_GIS(val)	bfin_write16(CAN1_GIS, val)
+#define bfin_read_CAN1_GIM()		bfin_read16(CAN1_GIM)
+#define bfin_write_CAN1_GIM(val)	bfin_write16(CAN1_GIM, val)
+#define bfin_read_CAN1_GIF()		bfin_read16(CAN1_GIF)
+#define bfin_write_CAN1_GIF(val)	bfin_write16(CAN1_GIF, val)
+#define bfin_read_CAN1_CONTROL()	bfin_read16(CAN1_CONTROL)
+#define bfin_write_CAN1_CONTROL(val)	bfin_write16(CAN1_CONTROL, val)
+#define bfin_read_CAN1_INTR()		bfin_read16(CAN1_INTR)
+#define bfin_write_CAN1_INTR(val)	bfin_write16(CAN1_INTR, val)
+#define bfin_read_CAN1_MBTD()		bfin_read16(CAN1_MBTD)
+#define bfin_write_CAN1_MBTD(val)	bfin_write16(CAN1_MBTD, val)
+#define bfin_read_CAN1_EWR()		bfin_read16(CAN1_EWR)
+#define bfin_write_CAN1_EWR(val)	bfin_write16(CAN1_EWR, val)
+#define bfin_read_CAN1_ESR()		bfin_read16(CAN1_ESR)
+#define bfin_write_CAN1_ESR(val)	bfin_write16(CAN1_ESR, val)
+#define bfin_read_CAN1_UCCNT()		bfin_read16(CAN1_UCCNT)
+#define bfin_write_CAN1_UCCNT(val)	bfin_write16(CAN1_UCCNT, val)
+#define bfin_read_CAN1_UCRC()		bfin_read16(CAN1_UCRC)
+#define bfin_write_CAN1_UCRC(val)	bfin_write16(CAN1_UCRC, val)
+#define bfin_read_CAN1_UCCNF()		bfin_read16(CAN1_UCCNF)
+#define bfin_write_CAN1_UCCNF(val)	bfin_write16(CAN1_UCCNF, val)
+
+/* CAN Controller 1 Mailbox Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN1_AM00L()		bfin_read16(CAN1_AM00L)
+#define bfin_write_CAN1_AM00L(val)	bfin_write16(CAN1_AM00L, val)
+#define bfin_read_CAN1_AM00H()		bfin_read16(CAN1_AM00H)
+#define bfin_write_CAN1_AM00H(val)	bfin_write16(CAN1_AM00H, val)
+#define bfin_read_CAN1_AM01L()		bfin_read16(CAN1_AM01L)
+#define bfin_write_CAN1_AM01L(val)	bfin_write16(CAN1_AM01L, val)
+#define bfin_read_CAN1_AM01H()		bfin_read16(CAN1_AM01H)
+#define bfin_write_CAN1_AM01H(val)	bfin_write16(CAN1_AM01H, val)
+#define bfin_read_CAN1_AM02L()		bfin_read16(CAN1_AM02L)
+#define bfin_write_CAN1_AM02L(val)	bfin_write16(CAN1_AM02L, val)
+#define bfin_read_CAN1_AM02H()		bfin_read16(CAN1_AM02H)
+#define bfin_write_CAN1_AM02H(val)	bfin_write16(CAN1_AM02H, val)
+#define bfin_read_CAN1_AM03L()		bfin_read16(CAN1_AM03L)
+#define bfin_write_CAN1_AM03L(val)	bfin_write16(CAN1_AM03L, val)
+#define bfin_read_CAN1_AM03H()		bfin_read16(CAN1_AM03H)
+#define bfin_write_CAN1_AM03H(val)	bfin_write16(CAN1_AM03H, val)
+#define bfin_read_CAN1_AM04L()		bfin_read16(CAN1_AM04L)
+#define bfin_write_CAN1_AM04L(val)	bfin_write16(CAN1_AM04L, val)
+#define bfin_read_CAN1_AM04H()		bfin_read16(CAN1_AM04H)
+#define bfin_write_CAN1_AM04H(val)	bfin_write16(CAN1_AM04H, val)
+#define bfin_read_CAN1_AM05L()		bfin_read16(CAN1_AM05L)
+#define bfin_write_CAN1_AM05L(val)	bfin_write16(CAN1_AM05L, val)
+#define bfin_read_CAN1_AM05H()		bfin_read16(CAN1_AM05H)
+#define bfin_write_CAN1_AM05H(val)	bfin_write16(CAN1_AM05H, val)
+#define bfin_read_CAN1_AM06L()		bfin_read16(CAN1_AM06L)
+#define bfin_write_CAN1_AM06L(val)	bfin_write16(CAN1_AM06L, val)
+#define bfin_read_CAN1_AM06H()		bfin_read16(CAN1_AM06H)
+#define bfin_write_CAN1_AM06H(val)	bfin_write16(CAN1_AM06H, val)
+#define bfin_read_CAN1_AM07L()		bfin_read16(CAN1_AM07L)
+#define bfin_write_CAN1_AM07L(val)	bfin_write16(CAN1_AM07L, val)
+#define bfin_read_CAN1_AM07H()		bfin_read16(CAN1_AM07H)
+#define bfin_write_CAN1_AM07H(val)	bfin_write16(CAN1_AM07H, val)
+#define bfin_read_CAN1_AM08L()		bfin_read16(CAN1_AM08L)
+#define bfin_write_CAN1_AM08L(val)	bfin_write16(CAN1_AM08L, val)
+#define bfin_read_CAN1_AM08H()		bfin_read16(CAN1_AM08H)
+#define bfin_write_CAN1_AM08H(val)	bfin_write16(CAN1_AM08H, val)
+#define bfin_read_CAN1_AM09L()		bfin_read16(CAN1_AM09L)
+#define bfin_write_CAN1_AM09L(val)	bfin_write16(CAN1_AM09L, val)
+#define bfin_read_CAN1_AM09H()		bfin_read16(CAN1_AM09H)
+#define bfin_write_CAN1_AM09H(val)	bfin_write16(CAN1_AM09H, val)
+#define bfin_read_CAN1_AM10L()		bfin_read16(CAN1_AM10L)
+#define bfin_write_CAN1_AM10L(val)	bfin_write16(CAN1_AM10L, val)
+#define bfin_read_CAN1_AM10H()		bfin_read16(CAN1_AM10H)
+#define bfin_write_CAN1_AM10H(val)	bfin_write16(CAN1_AM10H, val)
+#define bfin_read_CAN1_AM11L()		bfin_read16(CAN1_AM11L)
+#define bfin_write_CAN1_AM11L(val)	bfin_write16(CAN1_AM11L, val)
+#define bfin_read_CAN1_AM11H()		bfin_read16(CAN1_AM11H)
+#define bfin_write_CAN1_AM11H(val)	bfin_write16(CAN1_AM11H, val)
+#define bfin_read_CAN1_AM12L()		bfin_read16(CAN1_AM12L)
+#define bfin_write_CAN1_AM12L(val)	bfin_write16(CAN1_AM12L, val)
+#define bfin_read_CAN1_AM12H()		bfin_read16(CAN1_AM12H)
+#define bfin_write_CAN1_AM12H(val)	bfin_write16(CAN1_AM12H, val)
+#define bfin_read_CAN1_AM13L()		bfin_read16(CAN1_AM13L)
+#define bfin_write_CAN1_AM13L(val)	bfin_write16(CAN1_AM13L, val)
+#define bfin_read_CAN1_AM13H()		bfin_read16(CAN1_AM13H)
+#define bfin_write_CAN1_AM13H(val)	bfin_write16(CAN1_AM13H, val)
+#define bfin_read_CAN1_AM14L()		bfin_read16(CAN1_AM14L)
+#define bfin_write_CAN1_AM14L(val)	bfin_write16(CAN1_AM14L, val)
+#define bfin_read_CAN1_AM14H()		bfin_read16(CAN1_AM14H)
+#define bfin_write_CAN1_AM14H(val)	bfin_write16(CAN1_AM14H, val)
+#define bfin_read_CAN1_AM15L()		bfin_read16(CAN1_AM15L)
+#define bfin_write_CAN1_AM15L(val)	bfin_write16(CAN1_AM15L, val)
+#define bfin_read_CAN1_AM15H()		bfin_read16(CAN1_AM15H)
+#define bfin_write_CAN1_AM15H(val)	bfin_write16(CAN1_AM15H, val)
+
+/* CAN Controller 1 Mailbox Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN1_AM16L()		bfin_read16(CAN1_AM16L)
+#define bfin_write_CAN1_AM16L(val)	bfin_write16(CAN1_AM16L, val)
+#define bfin_read_CAN1_AM16H()		bfin_read16(CAN1_AM16H)
+#define bfin_write_CAN1_AM16H(val)	bfin_write16(CAN1_AM16H, val)
+#define bfin_read_CAN1_AM17L()		bfin_read16(CAN1_AM17L)
+#define bfin_write_CAN1_AM17L(val)	bfin_write16(CAN1_AM17L, val)
+#define bfin_read_CAN1_AM17H()		bfin_read16(CAN1_AM17H)
+#define bfin_write_CAN1_AM17H(val)	bfin_write16(CAN1_AM17H, val)
+#define bfin_read_CAN1_AM18L()		bfin_read16(CAN1_AM18L)
+#define bfin_write_CAN1_AM18L(val)	bfin_write16(CAN1_AM18L, val)
+#define bfin_read_CAN1_AM18H()		bfin_read16(CAN1_AM18H)
+#define bfin_write_CAN1_AM18H(val)	bfin_write16(CAN1_AM18H, val)
+#define bfin_read_CAN1_AM19L()		bfin_read16(CAN1_AM19L)
+#define bfin_write_CAN1_AM19L(val)	bfin_write16(CAN1_AM19L, val)
+#define bfin_read_CAN1_AM19H()		bfin_read16(CAN1_AM19H)
+#define bfin_write_CAN1_AM19H(val)	bfin_write16(CAN1_AM19H, val)
+#define bfin_read_CAN1_AM20L()		bfin_read16(CAN1_AM20L)
+#define bfin_write_CAN1_AM20L(val)	bfin_write16(CAN1_AM20L, val)
+#define bfin_read_CAN1_AM20H()		bfin_read16(CAN1_AM20H)
+#define bfin_write_CAN1_AM20H(val)	bfin_write16(CAN1_AM20H, val)
+#define bfin_read_CAN1_AM21L()		bfin_read16(CAN1_AM21L)
+#define bfin_write_CAN1_AM21L(val)	bfin_write16(CAN1_AM21L, val)
+#define bfin_read_CAN1_AM21H()		bfin_read16(CAN1_AM21H)
+#define bfin_write_CAN1_AM21H(val)	bfin_write16(CAN1_AM21H, val)
+#define bfin_read_CAN1_AM22L()		bfin_read16(CAN1_AM22L)
+#define bfin_write_CAN1_AM22L(val)	bfin_write16(CAN1_AM22L, val)
+#define bfin_read_CAN1_AM22H()		bfin_read16(CAN1_AM22H)
+#define bfin_write_CAN1_AM22H(val)	bfin_write16(CAN1_AM22H, val)
+#define bfin_read_CAN1_AM23L()		bfin_read16(CAN1_AM23L)
+#define bfin_write_CAN1_AM23L(val)	bfin_write16(CAN1_AM23L, val)
+#define bfin_read_CAN1_AM23H()		bfin_read16(CAN1_AM23H)
+#define bfin_write_CAN1_AM23H(val)	bfin_write16(CAN1_AM23H, val)
+#define bfin_read_CAN1_AM24L()		bfin_read16(CAN1_AM24L)
+#define bfin_write_CAN1_AM24L(val)	bfin_write16(CAN1_AM24L, val)
+#define bfin_read_CAN1_AM24H()		bfin_read16(CAN1_AM24H)
+#define bfin_write_CAN1_AM24H(val)	bfin_write16(CAN1_AM24H, val)
+#define bfin_read_CAN1_AM25L()		bfin_read16(CAN1_AM25L)
+#define bfin_write_CAN1_AM25L(val)	bfin_write16(CAN1_AM25L, val)
+#define bfin_read_CAN1_AM25H()		bfin_read16(CAN1_AM25H)
+#define bfin_write_CAN1_AM25H(val)	bfin_write16(CAN1_AM25H, val)
+#define bfin_read_CAN1_AM26L()		bfin_read16(CAN1_AM26L)
+#define bfin_write_CAN1_AM26L(val)	bfin_write16(CAN1_AM26L, val)
+#define bfin_read_CAN1_AM26H()		bfin_read16(CAN1_AM26H)
+#define bfin_write_CAN1_AM26H(val)	bfin_write16(CAN1_AM26H, val)
+#define bfin_read_CAN1_AM27L()		bfin_read16(CAN1_AM27L)
+#define bfin_write_CAN1_AM27L(val)	bfin_write16(CAN1_AM27L, val)
+#define bfin_read_CAN1_AM27H()		bfin_read16(CAN1_AM27H)
+#define bfin_write_CAN1_AM27H(val)	bfin_write16(CAN1_AM27H, val)
+#define bfin_read_CAN1_AM28L()		bfin_read16(CAN1_AM28L)
+#define bfin_write_CAN1_AM28L(val)	bfin_write16(CAN1_AM28L, val)
+#define bfin_read_CAN1_AM28H()		bfin_read16(CAN1_AM28H)
+#define bfin_write_CAN1_AM28H(val)	bfin_write16(CAN1_AM28H, val)
+#define bfin_read_CAN1_AM29L()		bfin_read16(CAN1_AM29L)
+#define bfin_write_CAN1_AM29L(val)	bfin_write16(CAN1_AM29L, val)
+#define bfin_read_CAN1_AM29H()		bfin_read16(CAN1_AM29H)
+#define bfin_write_CAN1_AM29H(val)	bfin_write16(CAN1_AM29H, val)
+#define bfin_read_CAN1_AM30L()		bfin_read16(CAN1_AM30L)
+#define bfin_write_CAN1_AM30L(val)	bfin_write16(CAN1_AM30L, val)
+#define bfin_read_CAN1_AM30H()		bfin_read16(CAN1_AM30H)
+#define bfin_write_CAN1_AM30H(val)	bfin_write16(CAN1_AM30H, val)
+#define bfin_read_CAN1_AM31L()		bfin_read16(CAN1_AM31L)
+#define bfin_write_CAN1_AM31L(val)	bfin_write16(CAN1_AM31L, val)
+#define bfin_read_CAN1_AM31H()		bfin_read16(CAN1_AM31H)
+#define bfin_write_CAN1_AM31H(val)	bfin_write16(CAN1_AM31H, val)
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define bfin_read_CAN1_MB00_DATA0()		bfin_read16(CAN1_MB00_DATA0)
+#define bfin_write_CAN1_MB00_DATA0(val)		bfin_write16(CAN1_MB00_DATA0, val)
+#define bfin_read_CAN1_MB00_DATA1()		bfin_read16(CAN1_MB00_DATA1)
+#define bfin_write_CAN1_MB00_DATA1(val)		bfin_write16(CAN1_MB00_DATA1, val)
+#define bfin_read_CAN1_MB00_DATA2()		bfin_read16(CAN1_MB00_DATA2)
+#define bfin_write_CAN1_MB00_DATA2(val)		bfin_write16(CAN1_MB00_DATA2, val)
+#define bfin_read_CAN1_MB00_DATA3()		bfin_read16(CAN1_MB00_DATA3)
+#define bfin_write_CAN1_MB00_DATA3(val)		bfin_write16(CAN1_MB00_DATA3, val)
+#define bfin_read_CAN1_MB00_LENGTH()		bfin_read16(CAN1_MB00_LENGTH)
+#define bfin_write_CAN1_MB00_LENGTH(val)	bfin_write16(CAN1_MB00_LENGTH, val)
+#define bfin_read_CAN1_MB00_TIMESTAMP()		bfin_read16(CAN1_MB00_TIMESTAMP)
+#define bfin_write_CAN1_MB00_TIMESTAMP(val)	bfin_write16(CAN1_MB00_TIMESTAMP, val)
+#define bfin_read_CAN1_MB00_ID0()		bfin_read16(CAN1_MB00_ID0)
+#define bfin_write_CAN1_MB00_ID0(val)		bfin_write16(CAN1_MB00_ID0, val)
+#define bfin_read_CAN1_MB00_ID1()		bfin_read16(CAN1_MB00_ID1)
+#define bfin_write_CAN1_MB00_ID1(val)		bfin_write16(CAN1_MB00_ID1, val)
+#define bfin_read_CAN1_MB01_DATA0()		bfin_read16(CAN1_MB01_DATA0)
+#define bfin_write_CAN1_MB01_DATA0(val)		bfin_write16(CAN1_MB01_DATA0, val)
+#define bfin_read_CAN1_MB01_DATA1()		bfin_read16(CAN1_MB01_DATA1)
+#define bfin_write_CAN1_MB01_DATA1(val)		bfin_write16(CAN1_MB01_DATA1, val)
+#define bfin_read_CAN1_MB01_DATA2()		bfin_read16(CAN1_MB01_DATA2)
+#define bfin_write_CAN1_MB01_DATA2(val)		bfin_write16(CAN1_MB01_DATA2, val)
+#define bfin_read_CAN1_MB01_DATA3()		bfin_read16(CAN1_MB01_DATA3)
+#define bfin_write_CAN1_MB01_DATA3(val)		bfin_write16(CAN1_MB01_DATA3, val)
+#define bfin_read_CAN1_MB01_LENGTH()		bfin_read16(CAN1_MB01_LENGTH)
+#define bfin_write_CAN1_MB01_LENGTH(val)	bfin_write16(CAN1_MB01_LENGTH, val)
+#define bfin_read_CAN1_MB01_TIMESTAMP()		bfin_read16(CAN1_MB01_TIMESTAMP)
+#define bfin_write_CAN1_MB01_TIMESTAMP(val)	bfin_write16(CAN1_MB01_TIMESTAMP, val)
+#define bfin_read_CAN1_MB01_ID0()		bfin_read16(CAN1_MB01_ID0)
+#define bfin_write_CAN1_MB01_ID0(val)		bfin_write16(CAN1_MB01_ID0, val)
+#define bfin_read_CAN1_MB01_ID1()		bfin_read16(CAN1_MB01_ID1)
+#define bfin_write_CAN1_MB01_ID1(val)		bfin_write16(CAN1_MB01_ID1, val)
+#define bfin_read_CAN1_MB02_DATA0()		bfin_read16(CAN1_MB02_DATA0)
+#define bfin_write_CAN1_MB02_DATA0(val)		bfin_write16(CAN1_MB02_DATA0, val)
+#define bfin_read_CAN1_MB02_DATA1()		bfin_read16(CAN1_MB02_DATA1)
+#define bfin_write_CAN1_MB02_DATA1(val)		bfin_write16(CAN1_MB02_DATA1, val)
+#define bfin_read_CAN1_MB02_DATA2()		bfin_read16(CAN1_MB02_DATA2)
+#define bfin_write_CAN1_MB02_DATA2(val)		bfin_write16(CAN1_MB02_DATA2, val)
+#define bfin_read_CAN1_MB02_DATA3()		bfin_read16(CAN1_MB02_DATA3)
+#define bfin_write_CAN1_MB02_DATA3(val)		bfin_write16(CAN1_MB02_DATA3, val)
+#define bfin_read_CAN1_MB02_LENGTH()		bfin_read16(CAN1_MB02_LENGTH)
+#define bfin_write_CAN1_MB02_LENGTH(val)	bfin_write16(CAN1_MB02_LENGTH, val)
+#define bfin_read_CAN1_MB02_TIMESTAMP()		bfin_read16(CAN1_MB02_TIMESTAMP)
+#define bfin_write_CAN1_MB02_TIMESTAMP(val)	bfin_write16(CAN1_MB02_TIMESTAMP, val)
+#define bfin_read_CAN1_MB02_ID0()		bfin_read16(CAN1_MB02_ID0)
+#define bfin_write_CAN1_MB02_ID0(val)		bfin_write16(CAN1_MB02_ID0, val)
+#define bfin_read_CAN1_MB02_ID1()		bfin_read16(CAN1_MB02_ID1)
+#define bfin_write_CAN1_MB02_ID1(val)		bfin_write16(CAN1_MB02_ID1, val)
+#define bfin_read_CAN1_MB03_DATA0()		bfin_read16(CAN1_MB03_DATA0)
+#define bfin_write_CAN1_MB03_DATA0(val)		bfin_write16(CAN1_MB03_DATA0, val)
+#define bfin_read_CAN1_MB03_DATA1()		bfin_read16(CAN1_MB03_DATA1)
+#define bfin_write_CAN1_MB03_DATA1(val)		bfin_write16(CAN1_MB03_DATA1, val)
+#define bfin_read_CAN1_MB03_DATA2()		bfin_read16(CAN1_MB03_DATA2)
+#define bfin_write_CAN1_MB03_DATA2(val)		bfin_write16(CAN1_MB03_DATA2, val)
+#define bfin_read_CAN1_MB03_DATA3()		bfin_read16(CAN1_MB03_DATA3)
+#define bfin_write_CAN1_MB03_DATA3(val)		bfin_write16(CAN1_MB03_DATA3, val)
+#define bfin_read_CAN1_MB03_LENGTH()		bfin_read16(CAN1_MB03_LENGTH)
+#define bfin_write_CAN1_MB03_LENGTH(val)	bfin_write16(CAN1_MB03_LENGTH, val)
+#define bfin_read_CAN1_MB03_TIMESTAMP()		bfin_read16(CAN1_MB03_TIMESTAMP)
+#define bfin_write_CAN1_MB03_TIMESTAMP(val)	bfin_write16(CAN1_MB03_TIMESTAMP, val)
+#define bfin_read_CAN1_MB03_ID0()		bfin_read16(CAN1_MB03_ID0)
+#define bfin_write_CAN1_MB03_ID0(val)		bfin_write16(CAN1_MB03_ID0, val)
+#define bfin_read_CAN1_MB03_ID1()		bfin_read16(CAN1_MB03_ID1)
+#define bfin_write_CAN1_MB03_ID1(val)		bfin_write16(CAN1_MB03_ID1, val)
+#define bfin_read_CAN1_MB04_DATA0()		bfin_read16(CAN1_MB04_DATA0)
+#define bfin_write_CAN1_MB04_DATA0(val)		bfin_write16(CAN1_MB04_DATA0, val)
+#define bfin_read_CAN1_MB04_DATA1()		bfin_read16(CAN1_MB04_DATA1)
+#define bfin_write_CAN1_MB04_DATA1(val)		bfin_write16(CAN1_MB04_DATA1, val)
+#define bfin_read_CAN1_MB04_DATA2()		bfin_read16(CAN1_MB04_DATA2)
+#define bfin_write_CAN1_MB04_DATA2(val)		bfin_write16(CAN1_MB04_DATA2, val)
+#define bfin_read_CAN1_MB04_DATA3()		bfin_read16(CAN1_MB04_DATA3)
+#define bfin_write_CAN1_MB04_DATA3(val)		bfin_write16(CAN1_MB04_DATA3, val)
+#define bfin_read_CAN1_MB04_LENGTH()		bfin_read16(CAN1_MB04_LENGTH)
+#define bfin_write_CAN1_MB04_LENGTH(val)	bfin_write16(CAN1_MB04_LENGTH, val)
+#define bfin_read_CAN1_MB04_TIMESTAMP()		bfin_read16(CAN1_MB04_TIMESTAMP)
+#define bfin_write_CAN1_MB04_TIMESTAMP(val)	bfin_write16(CAN1_MB04_TIMESTAMP, val)
+#define bfin_read_CAN1_MB04_ID0()		bfin_read16(CAN1_MB04_ID0)
+#define bfin_write_CAN1_MB04_ID0(val)		bfin_write16(CAN1_MB04_ID0, val)
+#define bfin_read_CAN1_MB04_ID1()		bfin_read16(CAN1_MB04_ID1)
+#define bfin_write_CAN1_MB04_ID1(val)		bfin_write16(CAN1_MB04_ID1, val)
+#define bfin_read_CAN1_MB05_DATA0()		bfin_read16(CAN1_MB05_DATA0)
+#define bfin_write_CAN1_MB05_DATA0(val)		bfin_write16(CAN1_MB05_DATA0, val)
+#define bfin_read_CAN1_MB05_DATA1()		bfin_read16(CAN1_MB05_DATA1)
+#define bfin_write_CAN1_MB05_DATA1(val)		bfin_write16(CAN1_MB05_DATA1, val)
+#define bfin_read_CAN1_MB05_DATA2()		bfin_read16(CAN1_MB05_DATA2)
+#define bfin_write_CAN1_MB05_DATA2(val)		bfin_write16(CAN1_MB05_DATA2, val)
+#define bfin_read_CAN1_MB05_DATA3()		bfin_read16(CAN1_MB05_DATA3)
+#define bfin_write_CAN1_MB05_DATA3(val)		bfin_write16(CAN1_MB05_DATA3, val)
+#define bfin_read_CAN1_MB05_LENGTH()		bfin_read16(CAN1_MB05_LENGTH)
+#define bfin_write_CAN1_MB05_LENGTH(val)	bfin_write16(CAN1_MB05_LENGTH, val)
+#define bfin_read_CAN1_MB05_TIMESTAMP()		bfin_read16(CAN1_MB05_TIMESTAMP)
+#define bfin_write_CAN1_MB05_TIMESTAMP(val)	bfin_write16(CAN1_MB05_TIMESTAMP, val)
+#define bfin_read_CAN1_MB05_ID0()		bfin_read16(CAN1_MB05_ID0)
+#define bfin_write_CAN1_MB05_ID0(val)		bfin_write16(CAN1_MB05_ID0, val)
+#define bfin_read_CAN1_MB05_ID1()		bfin_read16(CAN1_MB05_ID1)
+#define bfin_write_CAN1_MB05_ID1(val)		bfin_write16(CAN1_MB05_ID1, val)
+#define bfin_read_CAN1_MB06_DATA0()		bfin_read16(CAN1_MB06_DATA0)
+#define bfin_write_CAN1_MB06_DATA0(val)		bfin_write16(CAN1_MB06_DATA0, val)
+#define bfin_read_CAN1_MB06_DATA1()		bfin_read16(CAN1_MB06_DATA1)
+#define bfin_write_CAN1_MB06_DATA1(val)		bfin_write16(CAN1_MB06_DATA1, val)
+#define bfin_read_CAN1_MB06_DATA2()		bfin_read16(CAN1_MB06_DATA2)
+#define bfin_write_CAN1_MB06_DATA2(val)		bfin_write16(CAN1_MB06_DATA2, val)
+#define bfin_read_CAN1_MB06_DATA3()		bfin_read16(CAN1_MB06_DATA3)
+#define bfin_write_CAN1_MB06_DATA3(val)		bfin_write16(CAN1_MB06_DATA3, val)
+#define bfin_read_CAN1_MB06_LENGTH()		bfin_read16(CAN1_MB06_LENGTH)
+#define bfin_write_CAN1_MB06_LENGTH(val)	bfin_write16(CAN1_MB06_LENGTH, val)
+#define bfin_read_CAN1_MB06_TIMESTAMP()		bfin_read16(CAN1_MB06_TIMESTAMP)
+#define bfin_write_CAN1_MB06_TIMESTAMP(val)	bfin_write16(CAN1_MB06_TIMESTAMP, val)
+#define bfin_read_CAN1_MB06_ID0()		bfin_read16(CAN1_MB06_ID0)
+#define bfin_write_CAN1_MB06_ID0(val)		bfin_write16(CAN1_MB06_ID0, val)
+#define bfin_read_CAN1_MB06_ID1()		bfin_read16(CAN1_MB06_ID1)
+#define bfin_write_CAN1_MB06_ID1(val)		bfin_write16(CAN1_MB06_ID1, val)
+#define bfin_read_CAN1_MB07_DATA0()		bfin_read16(CAN1_MB07_DATA0)
+#define bfin_write_CAN1_MB07_DATA0(val)		bfin_write16(CAN1_MB07_DATA0, val)
+#define bfin_read_CAN1_MB07_DATA1()		bfin_read16(CAN1_MB07_DATA1)
+#define bfin_write_CAN1_MB07_DATA1(val)		bfin_write16(CAN1_MB07_DATA1, val)
+#define bfin_read_CAN1_MB07_DATA2()		bfin_read16(CAN1_MB07_DATA2)
+#define bfin_write_CAN1_MB07_DATA2(val)		bfin_write16(CAN1_MB07_DATA2, val)
+#define bfin_read_CAN1_MB07_DATA3()		bfin_read16(CAN1_MB07_DATA3)
+#define bfin_write_CAN1_MB07_DATA3(val)		bfin_write16(CAN1_MB07_DATA3, val)
+#define bfin_read_CAN1_MB07_LENGTH()		bfin_read16(CAN1_MB07_LENGTH)
+#define bfin_write_CAN1_MB07_LENGTH(val)	bfin_write16(CAN1_MB07_LENGTH, val)
+#define bfin_read_CAN1_MB07_TIMESTAMP()		bfin_read16(CAN1_MB07_TIMESTAMP)
+#define bfin_write_CAN1_MB07_TIMESTAMP(val)	bfin_write16(CAN1_MB07_TIMESTAMP, val)
+#define bfin_read_CAN1_MB07_ID0()		bfin_read16(CAN1_MB07_ID0)
+#define bfin_write_CAN1_MB07_ID0(val)		bfin_write16(CAN1_MB07_ID0, val)
+#define bfin_read_CAN1_MB07_ID1()		bfin_read16(CAN1_MB07_ID1)
+#define bfin_write_CAN1_MB07_ID1(val)		bfin_write16(CAN1_MB07_ID1, val)
+#define bfin_read_CAN1_MB08_DATA0()		bfin_read16(CAN1_MB08_DATA0)
+#define bfin_write_CAN1_MB08_DATA0(val)		bfin_write16(CAN1_MB08_DATA0, val)
+#define bfin_read_CAN1_MB08_DATA1()		bfin_read16(CAN1_MB08_DATA1)
+#define bfin_write_CAN1_MB08_DATA1(val)		bfin_write16(CAN1_MB08_DATA1, val)
+#define bfin_read_CAN1_MB08_DATA2()		bfin_read16(CAN1_MB08_DATA2)
+#define bfin_write_CAN1_MB08_DATA2(val)		bfin_write16(CAN1_MB08_DATA2, val)
+#define bfin_read_CAN1_MB08_DATA3()		bfin_read16(CAN1_MB08_DATA3)
+#define bfin_write_CAN1_MB08_DATA3(val)		bfin_write16(CAN1_MB08_DATA3, val)
+#define bfin_read_CAN1_MB08_LENGTH()		bfin_read16(CAN1_MB08_LENGTH)
+#define bfin_write_CAN1_MB08_LENGTH(val)	bfin_write16(CAN1_MB08_LENGTH, val)
+#define bfin_read_CAN1_MB08_TIMESTAMP()		bfin_read16(CAN1_MB08_TIMESTAMP)
+#define bfin_write_CAN1_MB08_TIMESTAMP(val)	bfin_write16(CAN1_MB08_TIMESTAMP, val)
+#define bfin_read_CAN1_MB08_ID0()		bfin_read16(CAN1_MB08_ID0)
+#define bfin_write_CAN1_MB08_ID0(val)		bfin_write16(CAN1_MB08_ID0, val)
+#define bfin_read_CAN1_MB08_ID1()		bfin_read16(CAN1_MB08_ID1)
+#define bfin_write_CAN1_MB08_ID1(val)		bfin_write16(CAN1_MB08_ID1, val)
+#define bfin_read_CAN1_MB09_DATA0()		bfin_read16(CAN1_MB09_DATA0)
+#define bfin_write_CAN1_MB09_DATA0(val)		bfin_write16(CAN1_MB09_DATA0, val)
+#define bfin_read_CAN1_MB09_DATA1()		bfin_read16(CAN1_MB09_DATA1)
+#define bfin_write_CAN1_MB09_DATA1(val)		bfin_write16(CAN1_MB09_DATA1, val)
+#define bfin_read_CAN1_MB09_DATA2()		bfin_read16(CAN1_MB09_DATA2)
+#define bfin_write_CAN1_MB09_DATA2(val)		bfin_write16(CAN1_MB09_DATA2, val)
+#define bfin_read_CAN1_MB09_DATA3()		bfin_read16(CAN1_MB09_DATA3)
+#define bfin_write_CAN1_MB09_DATA3(val)		bfin_write16(CAN1_MB09_DATA3, val)
+#define bfin_read_CAN1_MB09_LENGTH()		bfin_read16(CAN1_MB09_LENGTH)
+#define bfin_write_CAN1_MB09_LENGTH(val)	bfin_write16(CAN1_MB09_LENGTH, val)
+#define bfin_read_CAN1_MB09_TIMESTAMP()		bfin_read16(CAN1_MB09_TIMESTAMP)
+#define bfin_write_CAN1_MB09_TIMESTAMP(val)	bfin_write16(CAN1_MB09_TIMESTAMP, val)
+#define bfin_read_CAN1_MB09_ID0()		bfin_read16(CAN1_MB09_ID0)
+#define bfin_write_CAN1_MB09_ID0(val)		bfin_write16(CAN1_MB09_ID0, val)
+#define bfin_read_CAN1_MB09_ID1()		bfin_read16(CAN1_MB09_ID1)
+#define bfin_write_CAN1_MB09_ID1(val)		bfin_write16(CAN1_MB09_ID1, val)
+#define bfin_read_CAN1_MB10_DATA0()		bfin_read16(CAN1_MB10_DATA0)
+#define bfin_write_CAN1_MB10_DATA0(val)		bfin_write16(CAN1_MB10_DATA0, val)
+#define bfin_read_CAN1_MB10_DATA1()		bfin_read16(CAN1_MB10_DATA1)
+#define bfin_write_CAN1_MB10_DATA1(val)		bfin_write16(CAN1_MB10_DATA1, val)
+#define bfin_read_CAN1_MB10_DATA2()		bfin_read16(CAN1_MB10_DATA2)
+#define bfin_write_CAN1_MB10_DATA2(val)		bfin_write16(CAN1_MB10_DATA2, val)
+#define bfin_read_CAN1_MB10_DATA3()		bfin_read16(CAN1_MB10_DATA3)
+#define bfin_write_CAN1_MB10_DATA3(val)		bfin_write16(CAN1_MB10_DATA3, val)
+#define bfin_read_CAN1_MB10_LENGTH()		bfin_read16(CAN1_MB10_LENGTH)
+#define bfin_write_CAN1_MB10_LENGTH(val)	bfin_write16(CAN1_MB10_LENGTH, val)
+#define bfin_read_CAN1_MB10_TIMESTAMP()		bfin_read16(CAN1_MB10_TIMESTAMP)
+#define bfin_write_CAN1_MB10_TIMESTAMP(val)	bfin_write16(CAN1_MB10_TIMESTAMP, val)
+#define bfin_read_CAN1_MB10_ID0()		bfin_read16(CAN1_MB10_ID0)
+#define bfin_write_CAN1_MB10_ID0(val)		bfin_write16(CAN1_MB10_ID0, val)
+#define bfin_read_CAN1_MB10_ID1()		bfin_read16(CAN1_MB10_ID1)
+#define bfin_write_CAN1_MB10_ID1(val)		bfin_write16(CAN1_MB10_ID1, val)
+#define bfin_read_CAN1_MB11_DATA0()		bfin_read16(CAN1_MB11_DATA0)
+#define bfin_write_CAN1_MB11_DATA0(val)		bfin_write16(CAN1_MB11_DATA0, val)
+#define bfin_read_CAN1_MB11_DATA1()		bfin_read16(CAN1_MB11_DATA1)
+#define bfin_write_CAN1_MB11_DATA1(val)		bfin_write16(CAN1_MB11_DATA1, val)
+#define bfin_read_CAN1_MB11_DATA2()		bfin_read16(CAN1_MB11_DATA2)
+#define bfin_write_CAN1_MB11_DATA2(val)		bfin_write16(CAN1_MB11_DATA2, val)
+#define bfin_read_CAN1_MB11_DATA3()		bfin_read16(CAN1_MB11_DATA3)
+#define bfin_write_CAN1_MB11_DATA3(val)		bfin_write16(CAN1_MB11_DATA3, val)
+#define bfin_read_CAN1_MB11_LENGTH()		bfin_read16(CAN1_MB11_LENGTH)
+#define bfin_write_CAN1_MB11_LENGTH(val)	bfin_write16(CAN1_MB11_LENGTH, val)
+#define bfin_read_CAN1_MB11_TIMESTAMP()		bfin_read16(CAN1_MB11_TIMESTAMP)
+#define bfin_write_CAN1_MB11_TIMESTAMP(val)	bfin_write16(CAN1_MB11_TIMESTAMP, val)
+#define bfin_read_CAN1_MB11_ID0()		bfin_read16(CAN1_MB11_ID0)
+#define bfin_write_CAN1_MB11_ID0(val)		bfin_write16(CAN1_MB11_ID0, val)
+#define bfin_read_CAN1_MB11_ID1()		bfin_read16(CAN1_MB11_ID1)
+#define bfin_write_CAN1_MB11_ID1(val)		bfin_write16(CAN1_MB11_ID1, val)
+#define bfin_read_CAN1_MB12_DATA0()		bfin_read16(CAN1_MB12_DATA0)
+#define bfin_write_CAN1_MB12_DATA0(val)		bfin_write16(CAN1_MB12_DATA0, val)
+#define bfin_read_CAN1_MB12_DATA1()		bfin_read16(CAN1_MB12_DATA1)
+#define bfin_write_CAN1_MB12_DATA1(val)		bfin_write16(CAN1_MB12_DATA1, val)
+#define bfin_read_CAN1_MB12_DATA2()		bfin_read16(CAN1_MB12_DATA2)
+#define bfin_write_CAN1_MB12_DATA2(val)		bfin_write16(CAN1_MB12_DATA2, val)
+#define bfin_read_CAN1_MB12_DATA3()		bfin_read16(CAN1_MB12_DATA3)
+#define bfin_write_CAN1_MB12_DATA3(val)		bfin_write16(CAN1_MB12_DATA3, val)
+#define bfin_read_CAN1_MB12_LENGTH()		bfin_read16(CAN1_MB12_LENGTH)
+#define bfin_write_CAN1_MB12_LENGTH(val)	bfin_write16(CAN1_MB12_LENGTH, val)
+#define bfin_read_CAN1_MB12_TIMESTAMP()		bfin_read16(CAN1_MB12_TIMESTAMP)
+#define bfin_write_CAN1_MB12_TIMESTAMP(val)	bfin_write16(CAN1_MB12_TIMESTAMP, val)
+#define bfin_read_CAN1_MB12_ID0()		bfin_read16(CAN1_MB12_ID0)
+#define bfin_write_CAN1_MB12_ID0(val)		bfin_write16(CAN1_MB12_ID0, val)
+#define bfin_read_CAN1_MB12_ID1()		bfin_read16(CAN1_MB12_ID1)
+#define bfin_write_CAN1_MB12_ID1(val)		bfin_write16(CAN1_MB12_ID1, val)
+#define bfin_read_CAN1_MB13_DATA0()		bfin_read16(CAN1_MB13_DATA0)
+#define bfin_write_CAN1_MB13_DATA0(val)		bfin_write16(CAN1_MB13_DATA0, val)
+#define bfin_read_CAN1_MB13_DATA1()		bfin_read16(CAN1_MB13_DATA1)
+#define bfin_write_CAN1_MB13_DATA1(val)		bfin_write16(CAN1_MB13_DATA1, val)
+#define bfin_read_CAN1_MB13_DATA2()		bfin_read16(CAN1_MB13_DATA2)
+#define bfin_write_CAN1_MB13_DATA2(val)		bfin_write16(CAN1_MB13_DATA2, val)
+#define bfin_read_CAN1_MB13_DATA3()		bfin_read16(CAN1_MB13_DATA3)
+#define bfin_write_CAN1_MB13_DATA3(val)		bfin_write16(CAN1_MB13_DATA3, val)
+#define bfin_read_CAN1_MB13_LENGTH()		bfin_read16(CAN1_MB13_LENGTH)
+#define bfin_write_CAN1_MB13_LENGTH(val)	bfin_write16(CAN1_MB13_LENGTH, val)
+#define bfin_read_CAN1_MB13_TIMESTAMP()		bfin_read16(CAN1_MB13_TIMESTAMP)
+#define bfin_write_CAN1_MB13_TIMESTAMP(val)	bfin_write16(CAN1_MB13_TIMESTAMP, val)
+#define bfin_read_CAN1_MB13_ID0()		bfin_read16(CAN1_MB13_ID0)
+#define bfin_write_CAN1_MB13_ID0(val)		bfin_write16(CAN1_MB13_ID0, val)
+#define bfin_read_CAN1_MB13_ID1()		bfin_read16(CAN1_MB13_ID1)
+#define bfin_write_CAN1_MB13_ID1(val)		bfin_write16(CAN1_MB13_ID1, val)
+#define bfin_read_CAN1_MB14_DATA0()		bfin_read16(CAN1_MB14_DATA0)
+#define bfin_write_CAN1_MB14_DATA0(val)		bfin_write16(CAN1_MB14_DATA0, val)
+#define bfin_read_CAN1_MB14_DATA1()		bfin_read16(CAN1_MB14_DATA1)
+#define bfin_write_CAN1_MB14_DATA1(val)		bfin_write16(CAN1_MB14_DATA1, val)
+#define bfin_read_CAN1_MB14_DATA2()		bfin_read16(CAN1_MB14_DATA2)
+#define bfin_write_CAN1_MB14_DATA2(val)		bfin_write16(CAN1_MB14_DATA2, val)
+#define bfin_read_CAN1_MB14_DATA3()		bfin_read16(CAN1_MB14_DATA3)
+#define bfin_write_CAN1_MB14_DATA3(val)		bfin_write16(CAN1_MB14_DATA3, val)
+#define bfin_read_CAN1_MB14_LENGTH()		bfin_read16(CAN1_MB14_LENGTH)
+#define bfin_write_CAN1_MB14_LENGTH(val)	bfin_write16(CAN1_MB14_LENGTH, val)
+#define bfin_read_CAN1_MB14_TIMESTAMP()		bfin_read16(CAN1_MB14_TIMESTAMP)
+#define bfin_write_CAN1_MB14_TIMESTAMP(val)	bfin_write16(CAN1_MB14_TIMESTAMP, val)
+#define bfin_read_CAN1_MB14_ID0()		bfin_read16(CAN1_MB14_ID0)
+#define bfin_write_CAN1_MB14_ID0(val)		bfin_write16(CAN1_MB14_ID0, val)
+#define bfin_read_CAN1_MB14_ID1()		bfin_read16(CAN1_MB14_ID1)
+#define bfin_write_CAN1_MB14_ID1(val)		bfin_write16(CAN1_MB14_ID1, val)
+#define bfin_read_CAN1_MB15_DATA0()		bfin_read16(CAN1_MB15_DATA0)
+#define bfin_write_CAN1_MB15_DATA0(val)		bfin_write16(CAN1_MB15_DATA0, val)
+#define bfin_read_CAN1_MB15_DATA1()		bfin_read16(CAN1_MB15_DATA1)
+#define bfin_write_CAN1_MB15_DATA1(val)		bfin_write16(CAN1_MB15_DATA1, val)
+#define bfin_read_CAN1_MB15_DATA2()		bfin_read16(CAN1_MB15_DATA2)
+#define bfin_write_CAN1_MB15_DATA2(val)		bfin_write16(CAN1_MB15_DATA2, val)
+#define bfin_read_CAN1_MB15_DATA3()		bfin_read16(CAN1_MB15_DATA3)
+#define bfin_write_CAN1_MB15_DATA3(val)		bfin_write16(CAN1_MB15_DATA3, val)
+#define bfin_read_CAN1_MB15_LENGTH()		bfin_read16(CAN1_MB15_LENGTH)
+#define bfin_write_CAN1_MB15_LENGTH(val)	bfin_write16(CAN1_MB15_LENGTH, val)
+#define bfin_read_CAN1_MB15_TIMESTAMP()		bfin_read16(CAN1_MB15_TIMESTAMP)
+#define bfin_write_CAN1_MB15_TIMESTAMP(val)	bfin_write16(CAN1_MB15_TIMESTAMP, val)
+#define bfin_read_CAN1_MB15_ID0()		bfin_read16(CAN1_MB15_ID0)
+#define bfin_write_CAN1_MB15_ID0(val)		bfin_write16(CAN1_MB15_ID0, val)
+#define bfin_read_CAN1_MB15_ID1()		bfin_read16(CAN1_MB15_ID1)
+#define bfin_write_CAN1_MB15_ID1(val)		bfin_write16(CAN1_MB15_ID1, val)
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define bfin_read_CAN1_MB16_DATA0()		bfin_read16(CAN1_MB16_DATA0)
+#define bfin_write_CAN1_MB16_DATA0(val)		bfin_write16(CAN1_MB16_DATA0, val)
+#define bfin_read_CAN1_MB16_DATA1()		bfin_read16(CAN1_MB16_DATA1)
+#define bfin_write_CAN1_MB16_DATA1(val)		bfin_write16(CAN1_MB16_DATA1, val)
+#define bfin_read_CAN1_MB16_DATA2()		bfin_read16(CAN1_MB16_DATA2)
+#define bfin_write_CAN1_MB16_DATA2(val)		bfin_write16(CAN1_MB16_DATA2, val)
+#define bfin_read_CAN1_MB16_DATA3()		bfin_read16(CAN1_MB16_DATA3)
+#define bfin_write_CAN1_MB16_DATA3(val)		bfin_write16(CAN1_MB16_DATA3, val)
+#define bfin_read_CAN1_MB16_LENGTH()		bfin_read16(CAN1_MB16_LENGTH)
+#define bfin_write_CAN1_MB16_LENGTH(val)	bfin_write16(CAN1_MB16_LENGTH, val)
+#define bfin_read_CAN1_MB16_TIMESTAMP()		bfin_read16(CAN1_MB16_TIMESTAMP)
+#define bfin_write_CAN1_MB16_TIMESTAMP(val)	bfin_write16(CAN1_MB16_TIMESTAMP, val)
+#define bfin_read_CAN1_MB16_ID0()		bfin_read16(CAN1_MB16_ID0)
+#define bfin_write_CAN1_MB16_ID0(val)		bfin_write16(CAN1_MB16_ID0, val)
+#define bfin_read_CAN1_MB16_ID1()		bfin_read16(CAN1_MB16_ID1)
+#define bfin_write_CAN1_MB16_ID1(val)		bfin_write16(CAN1_MB16_ID1, val)
+#define bfin_read_CAN1_MB17_DATA0()		bfin_read16(CAN1_MB17_DATA0)
+#define bfin_write_CAN1_MB17_DATA0(val)		bfin_write16(CAN1_MB17_DATA0, val)
+#define bfin_read_CAN1_MB17_DATA1()		bfin_read16(CAN1_MB17_DATA1)
+#define bfin_write_CAN1_MB17_DATA1(val)		bfin_write16(CAN1_MB17_DATA1, val)
+#define bfin_read_CAN1_MB17_DATA2()		bfin_read16(CAN1_MB17_DATA2)
+#define bfin_write_CAN1_MB17_DATA2(val)		bfin_write16(CAN1_MB17_DATA2, val)
+#define bfin_read_CAN1_MB17_DATA3()		bfin_read16(CAN1_MB17_DATA3)
+#define bfin_write_CAN1_MB17_DATA3(val)		bfin_write16(CAN1_MB17_DATA3, val)
+#define bfin_read_CAN1_MB17_LENGTH()		bfin_read16(CAN1_MB17_LENGTH)
+#define bfin_write_CAN1_MB17_LENGTH(val)	bfin_write16(CAN1_MB17_LENGTH, val)
+#define bfin_read_CAN1_MB17_TIMESTAMP()		bfin_read16(CAN1_MB17_TIMESTAMP)
+#define bfin_write_CAN1_MB17_TIMESTAMP(val)	bfin_write16(CAN1_MB17_TIMESTAMP, val)
+#define bfin_read_CAN1_MB17_ID0()		bfin_read16(CAN1_MB17_ID0)
+#define bfin_write_CAN1_MB17_ID0(val)		bfin_write16(CAN1_MB17_ID0, val)
+#define bfin_read_CAN1_MB17_ID1()		bfin_read16(CAN1_MB17_ID1)
+#define bfin_write_CAN1_MB17_ID1(val)		bfin_write16(CAN1_MB17_ID1, val)
+#define bfin_read_CAN1_MB18_DATA0()		bfin_read16(CAN1_MB18_DATA0)
+#define bfin_write_CAN1_MB18_DATA0(val)		bfin_write16(CAN1_MB18_DATA0, val)
+#define bfin_read_CAN1_MB18_DATA1()		bfin_read16(CAN1_MB18_DATA1)
+#define bfin_write_CAN1_MB18_DATA1(val)		bfin_write16(CAN1_MB18_DATA1, val)
+#define bfin_read_CAN1_MB18_DATA2()		bfin_read16(CAN1_MB18_DATA2)
+#define bfin_write_CAN1_MB18_DATA2(val)		bfin_write16(CAN1_MB18_DATA2, val)
+#define bfin_read_CAN1_MB18_DATA3()		bfin_read16(CAN1_MB18_DATA3)
+#define bfin_write_CAN1_MB18_DATA3(val)		bfin_write16(CAN1_MB18_DATA3, val)
+#define bfin_read_CAN1_MB18_LENGTH()		bfin_read16(CAN1_MB18_LENGTH)
+#define bfin_write_CAN1_MB18_LENGTH(val)	bfin_write16(CAN1_MB18_LENGTH, val)
+#define bfin_read_CAN1_MB18_TIMESTAMP()		bfin_read16(CAN1_MB18_TIMESTAMP)
+#define bfin_write_CAN1_MB18_TIMESTAMP(val)	bfin_write16(CAN1_MB18_TIMESTAMP, val)
+#define bfin_read_CAN1_MB18_ID0()		bfin_read16(CAN1_MB18_ID0)
+#define bfin_write_CAN1_MB18_ID0(val)		bfin_write16(CAN1_MB18_ID0, val)
+#define bfin_read_CAN1_MB18_ID1()		bfin_read16(CAN1_MB18_ID1)
+#define bfin_write_CAN1_MB18_ID1(val)		bfin_write16(CAN1_MB18_ID1, val)
+#define bfin_read_CAN1_MB19_DATA0()		bfin_read16(CAN1_MB19_DATA0)
+#define bfin_write_CAN1_MB19_DATA0(val)		bfin_write16(CAN1_MB19_DATA0, val)
+#define bfin_read_CAN1_MB19_DATA1()		bfin_read16(CAN1_MB19_DATA1)
+#define bfin_write_CAN1_MB19_DATA1(val)		bfin_write16(CAN1_MB19_DATA1, val)
+#define bfin_read_CAN1_MB19_DATA2()		bfin_read16(CAN1_MB19_DATA2)
+#define bfin_write_CAN1_MB19_DATA2(val)		bfin_write16(CAN1_MB19_DATA2, val)
+#define bfin_read_CAN1_MB19_DATA3()		bfin_read16(CAN1_MB19_DATA3)
+#define bfin_write_CAN1_MB19_DATA3(val)		bfin_write16(CAN1_MB19_DATA3, val)
+#define bfin_read_CAN1_MB19_LENGTH()		bfin_read16(CAN1_MB19_LENGTH)
+#define bfin_write_CAN1_MB19_LENGTH(val)	bfin_write16(CAN1_MB19_LENGTH, val)
+#define bfin_read_CAN1_MB19_TIMESTAMP()		bfin_read16(CAN1_MB19_TIMESTAMP)
+#define bfin_write_CAN1_MB19_TIMESTAMP(val)	bfin_write16(CAN1_MB19_TIMESTAMP, val)
+#define bfin_read_CAN1_MB19_ID0()		bfin_read16(CAN1_MB19_ID0)
+#define bfin_write_CAN1_MB19_ID0(val)		bfin_write16(CAN1_MB19_ID0, val)
+#define bfin_read_CAN1_MB19_ID1()		bfin_read16(CAN1_MB19_ID1)
+#define bfin_write_CAN1_MB19_ID1(val)		bfin_write16(CAN1_MB19_ID1, val)
+#define bfin_read_CAN1_MB20_DATA0()		bfin_read16(CAN1_MB20_DATA0)
+#define bfin_write_CAN1_MB20_DATA0(val)		bfin_write16(CAN1_MB20_DATA0, val)
+#define bfin_read_CAN1_MB20_DATA1()		bfin_read16(CAN1_MB20_DATA1)
+#define bfin_write_CAN1_MB20_DATA1(val)		bfin_write16(CAN1_MB20_DATA1, val)
+#define bfin_read_CAN1_MB20_DATA2()		bfin_read16(CAN1_MB20_DATA2)
+#define bfin_write_CAN1_MB20_DATA2(val)		bfin_write16(CAN1_MB20_DATA2, val)
+#define bfin_read_CAN1_MB20_DATA3()		bfin_read16(CAN1_MB20_DATA3)
+#define bfin_write_CAN1_MB20_DATA3(val)		bfin_write16(CAN1_MB20_DATA3, val)
+#define bfin_read_CAN1_MB20_LENGTH()		bfin_read16(CAN1_MB20_LENGTH)
+#define bfin_write_CAN1_MB20_LENGTH(val)	bfin_write16(CAN1_MB20_LENGTH, val)
+#define bfin_read_CAN1_MB20_TIMESTAMP()		bfin_read16(CAN1_MB20_TIMESTAMP)
+#define bfin_write_CAN1_MB20_TIMESTAMP(val)	bfin_write16(CAN1_MB20_TIMESTAMP, val)
+#define bfin_read_CAN1_MB20_ID0()		bfin_read16(CAN1_MB20_ID0)
+#define bfin_write_CAN1_MB20_ID0(val)		bfin_write16(CAN1_MB20_ID0, val)
+#define bfin_read_CAN1_MB20_ID1()		bfin_read16(CAN1_MB20_ID1)
+#define bfin_write_CAN1_MB20_ID1(val)		bfin_write16(CAN1_MB20_ID1, val)
+#define bfin_read_CAN1_MB21_DATA0()		bfin_read16(CAN1_MB21_DATA0)
+#define bfin_write_CAN1_MB21_DATA0(val)		bfin_write16(CAN1_MB21_DATA0, val)
+#define bfin_read_CAN1_MB21_DATA1()		bfin_read16(CAN1_MB21_DATA1)
+#define bfin_write_CAN1_MB21_DATA1(val)		bfin_write16(CAN1_MB21_DATA1, val)
+#define bfin_read_CAN1_MB21_DATA2()		bfin_read16(CAN1_MB21_DATA2)
+#define bfin_write_CAN1_MB21_DATA2(val)		bfin_write16(CAN1_MB21_DATA2, val)
+#define bfin_read_CAN1_MB21_DATA3()		bfin_read16(CAN1_MB21_DATA3)
+#define bfin_write_CAN1_MB21_DATA3(val)		bfin_write16(CAN1_MB21_DATA3, val)
+#define bfin_read_CAN1_MB21_LENGTH()		bfin_read16(CAN1_MB21_LENGTH)
+#define bfin_write_CAN1_MB21_LENGTH(val)	bfin_write16(CAN1_MB21_LENGTH, val)
+#define bfin_read_CAN1_MB21_TIMESTAMP()		bfin_read16(CAN1_MB21_TIMESTAMP)
+#define bfin_write_CAN1_MB21_TIMESTAMP(val)	bfin_write16(CAN1_MB21_TIMESTAMP, val)
+#define bfin_read_CAN1_MB21_ID0()		bfin_read16(CAN1_MB21_ID0)
+#define bfin_write_CAN1_MB21_ID0(val)		bfin_write16(CAN1_MB21_ID0, val)
+#define bfin_read_CAN1_MB21_ID1()		bfin_read16(CAN1_MB21_ID1)
+#define bfin_write_CAN1_MB21_ID1(val)		bfin_write16(CAN1_MB21_ID1, val)
+#define bfin_read_CAN1_MB22_DATA0()		bfin_read16(CAN1_MB22_DATA0)
+#define bfin_write_CAN1_MB22_DATA0(val)		bfin_write16(CAN1_MB22_DATA0, val)
+#define bfin_read_CAN1_MB22_DATA1()		bfin_read16(CAN1_MB22_DATA1)
+#define bfin_write_CAN1_MB22_DATA1(val)		bfin_write16(CAN1_MB22_DATA1, val)
+#define bfin_read_CAN1_MB22_DATA2()		bfin_read16(CAN1_MB22_DATA2)
+#define bfin_write_CAN1_MB22_DATA2(val)		bfin_write16(CAN1_MB22_DATA2, val)
+#define bfin_read_CAN1_MB22_DATA3()		bfin_read16(CAN1_MB22_DATA3)
+#define bfin_write_CAN1_MB22_DATA3(val)		bfin_write16(CAN1_MB22_DATA3, val)
+#define bfin_read_CAN1_MB22_LENGTH()		bfin_read16(CAN1_MB22_LENGTH)
+#define bfin_write_CAN1_MB22_LENGTH(val)	bfin_write16(CAN1_MB22_LENGTH, val)
+#define bfin_read_CAN1_MB22_TIMESTAMP()		bfin_read16(CAN1_MB22_TIMESTAMP)
+#define bfin_write_CAN1_MB22_TIMESTAMP(val)	bfin_write16(CAN1_MB22_TIMESTAMP, val)
+#define bfin_read_CAN1_MB22_ID0()		bfin_read16(CAN1_MB22_ID0)
+#define bfin_write_CAN1_MB22_ID0(val)		bfin_write16(CAN1_MB22_ID0, val)
+#define bfin_read_CAN1_MB22_ID1()		bfin_read16(CAN1_MB22_ID1)
+#define bfin_write_CAN1_MB22_ID1(val)		bfin_write16(CAN1_MB22_ID1, val)
+#define bfin_read_CAN1_MB23_DATA0()		bfin_read16(CAN1_MB23_DATA0)
+#define bfin_write_CAN1_MB23_DATA0(val)		bfin_write16(CAN1_MB23_DATA0, val)
+#define bfin_read_CAN1_MB23_DATA1()		bfin_read16(CAN1_MB23_DATA1)
+#define bfin_write_CAN1_MB23_DATA1(val)		bfin_write16(CAN1_MB23_DATA1, val)
+#define bfin_read_CAN1_MB23_DATA2()		bfin_read16(CAN1_MB23_DATA2)
+#define bfin_write_CAN1_MB23_DATA2(val)		bfin_write16(CAN1_MB23_DATA2, val)
+#define bfin_read_CAN1_MB23_DATA3()		bfin_read16(CAN1_MB23_DATA3)
+#define bfin_write_CAN1_MB23_DATA3(val)		bfin_write16(CAN1_MB23_DATA3, val)
+#define bfin_read_CAN1_MB23_LENGTH()		bfin_read16(CAN1_MB23_LENGTH)
+#define bfin_write_CAN1_MB23_LENGTH(val)	bfin_write16(CAN1_MB23_LENGTH, val)
+#define bfin_read_CAN1_MB23_TIMESTAMP()		bfin_read16(CAN1_MB23_TIMESTAMP)
+#define bfin_write_CAN1_MB23_TIMESTAMP(val)	bfin_write16(CAN1_MB23_TIMESTAMP, val)
+#define bfin_read_CAN1_MB23_ID0()		bfin_read16(CAN1_MB23_ID0)
+#define bfin_write_CAN1_MB23_ID0(val)		bfin_write16(CAN1_MB23_ID0, val)
+#define bfin_read_CAN1_MB23_ID1()		bfin_read16(CAN1_MB23_ID1)
+#define bfin_write_CAN1_MB23_ID1(val)		bfin_write16(CAN1_MB23_ID1, val)
+#define bfin_read_CAN1_MB24_DATA0()		bfin_read16(CAN1_MB24_DATA0)
+#define bfin_write_CAN1_MB24_DATA0(val)		bfin_write16(CAN1_MB24_DATA0, val)
+#define bfin_read_CAN1_MB24_DATA1()		bfin_read16(CAN1_MB24_DATA1)
+#define bfin_write_CAN1_MB24_DATA1(val)		bfin_write16(CAN1_MB24_DATA1, val)
+#define bfin_read_CAN1_MB24_DATA2()		bfin_read16(CAN1_MB24_DATA2)
+#define bfin_write_CAN1_MB24_DATA2(val)		bfin_write16(CAN1_MB24_DATA2, val)
+#define bfin_read_CAN1_MB24_DATA3()		bfin_read16(CAN1_MB24_DATA3)
+#define bfin_write_CAN1_MB24_DATA3(val)		bfin_write16(CAN1_MB24_DATA3, val)
+#define bfin_read_CAN1_MB24_LENGTH()		bfin_read16(CAN1_MB24_LENGTH)
+#define bfin_write_CAN1_MB24_LENGTH(val)	bfin_write16(CAN1_MB24_LENGTH, val)
+#define bfin_read_CAN1_MB24_TIMESTAMP()		bfin_read16(CAN1_MB24_TIMESTAMP)
+#define bfin_write_CAN1_MB24_TIMESTAMP(val)	bfin_write16(CAN1_MB24_TIMESTAMP, val)
+#define bfin_read_CAN1_MB24_ID0()		bfin_read16(CAN1_MB24_ID0)
+#define bfin_write_CAN1_MB24_ID0(val)		bfin_write16(CAN1_MB24_ID0, val)
+#define bfin_read_CAN1_MB24_ID1()		bfin_read16(CAN1_MB24_ID1)
+#define bfin_write_CAN1_MB24_ID1(val)		bfin_write16(CAN1_MB24_ID1, val)
+#define bfin_read_CAN1_MB25_DATA0()		bfin_read16(CAN1_MB25_DATA0)
+#define bfin_write_CAN1_MB25_DATA0(val)		bfin_write16(CAN1_MB25_DATA0, val)
+#define bfin_read_CAN1_MB25_DATA1()		bfin_read16(CAN1_MB25_DATA1)
+#define bfin_write_CAN1_MB25_DATA1(val)		bfin_write16(CAN1_MB25_DATA1, val)
+#define bfin_read_CAN1_MB25_DATA2()		bfin_read16(CAN1_MB25_DATA2)
+#define bfin_write_CAN1_MB25_DATA2(val)		bfin_write16(CAN1_MB25_DATA2, val)
+#define bfin_read_CAN1_MB25_DATA3()		bfin_read16(CAN1_MB25_DATA3)
+#define bfin_write_CAN1_MB25_DATA3(val)		bfin_write16(CAN1_MB25_DATA3, val)
+#define bfin_read_CAN1_MB25_LENGTH()		bfin_read16(CAN1_MB25_LENGTH)
+#define bfin_write_CAN1_MB25_LENGTH(val)	bfin_write16(CAN1_MB25_LENGTH, val)
+#define bfin_read_CAN1_MB25_TIMESTAMP()		bfin_read16(CAN1_MB25_TIMESTAMP)
+#define bfin_write_CAN1_MB25_TIMESTAMP(val)	bfin_write16(CAN1_MB25_TIMESTAMP, val)
+#define bfin_read_CAN1_MB25_ID0()		bfin_read16(CAN1_MB25_ID0)
+#define bfin_write_CAN1_MB25_ID0(val)		bfin_write16(CAN1_MB25_ID0, val)
+#define bfin_read_CAN1_MB25_ID1()		bfin_read16(CAN1_MB25_ID1)
+#define bfin_write_CAN1_MB25_ID1(val)		bfin_write16(CAN1_MB25_ID1, val)
+#define bfin_read_CAN1_MB26_DATA0()		bfin_read16(CAN1_MB26_DATA0)
+#define bfin_write_CAN1_MB26_DATA0(val)		bfin_write16(CAN1_MB26_DATA0, val)
+#define bfin_read_CAN1_MB26_DATA1()		bfin_read16(CAN1_MB26_DATA1)
+#define bfin_write_CAN1_MB26_DATA1(val)		bfin_write16(CAN1_MB26_DATA1, val)
+#define bfin_read_CAN1_MB26_DATA2()		bfin_read16(CAN1_MB26_DATA2)
+#define bfin_write_CAN1_MB26_DATA2(val)		bfin_write16(CAN1_MB26_DATA2, val)
+#define bfin_read_CAN1_MB26_DATA3()		bfin_read16(CAN1_MB26_DATA3)
+#define bfin_write_CAN1_MB26_DATA3(val)		bfin_write16(CAN1_MB26_DATA3, val)
+#define bfin_read_CAN1_MB26_LENGTH()		bfin_read16(CAN1_MB26_LENGTH)
+#define bfin_write_CAN1_MB26_LENGTH(val)	bfin_write16(CAN1_MB26_LENGTH, val)
+#define bfin_read_CAN1_MB26_TIMESTAMP()		bfin_read16(CAN1_MB26_TIMESTAMP)
+#define bfin_write_CAN1_MB26_TIMESTAMP(val)	bfin_write16(CAN1_MB26_TIMESTAMP, val)
+#define bfin_read_CAN1_MB26_ID0()		bfin_read16(CAN1_MB26_ID0)
+#define bfin_write_CAN1_MB26_ID0(val)		bfin_write16(CAN1_MB26_ID0, val)
+#define bfin_read_CAN1_MB26_ID1()		bfin_read16(CAN1_MB26_ID1)
+#define bfin_write_CAN1_MB26_ID1(val)		bfin_write16(CAN1_MB26_ID1, val)
+#define bfin_read_CAN1_MB27_DATA0()		bfin_read16(CAN1_MB27_DATA0)
+#define bfin_write_CAN1_MB27_DATA0(val)		bfin_write16(CAN1_MB27_DATA0, val)
+#define bfin_read_CAN1_MB27_DATA1()		bfin_read16(CAN1_MB27_DATA1)
+#define bfin_write_CAN1_MB27_DATA1(val)		bfin_write16(CAN1_MB27_DATA1, val)
+#define bfin_read_CAN1_MB27_DATA2()		bfin_read16(CAN1_MB27_DATA2)
+#define bfin_write_CAN1_MB27_DATA2(val)		bfin_write16(CAN1_MB27_DATA2, val)
+#define bfin_read_CAN1_MB27_DATA3()		bfin_read16(CAN1_MB27_DATA3)
+#define bfin_write_CAN1_MB27_DATA3(val)		bfin_write16(CAN1_MB27_DATA3, val)
+#define bfin_read_CAN1_MB27_LENGTH()		bfin_read16(CAN1_MB27_LENGTH)
+#define bfin_write_CAN1_MB27_LENGTH(val)	bfin_write16(CAN1_MB27_LENGTH, val)
+#define bfin_read_CAN1_MB27_TIMESTAMP()		bfin_read16(CAN1_MB27_TIMESTAMP)
+#define bfin_write_CAN1_MB27_TIMESTAMP(val)	bfin_write16(CAN1_MB27_TIMESTAMP, val)
+#define bfin_read_CAN1_MB27_ID0()		bfin_read16(CAN1_MB27_ID0)
+#define bfin_write_CAN1_MB27_ID0(val)		bfin_write16(CAN1_MB27_ID0, val)
+#define bfin_read_CAN1_MB27_ID1()		bfin_read16(CAN1_MB27_ID1)
+#define bfin_write_CAN1_MB27_ID1(val)		bfin_write16(CAN1_MB27_ID1, val)
+#define bfin_read_CAN1_MB28_DATA0()		bfin_read16(CAN1_MB28_DATA0)
+#define bfin_write_CAN1_MB28_DATA0(val)		bfin_write16(CAN1_MB28_DATA0, val)
+#define bfin_read_CAN1_MB28_DATA1()		bfin_read16(CAN1_MB28_DATA1)
+#define bfin_write_CAN1_MB28_DATA1(val)		bfin_write16(CAN1_MB28_DATA1, val)
+#define bfin_read_CAN1_MB28_DATA2()		bfin_read16(CAN1_MB28_DATA2)
+#define bfin_write_CAN1_MB28_DATA2(val)		bfin_write16(CAN1_MB28_DATA2, val)
+#define bfin_read_CAN1_MB28_DATA3()		bfin_read16(CAN1_MB28_DATA3)
+#define bfin_write_CAN1_MB28_DATA3(val)		bfin_write16(CAN1_MB28_DATA3, val)
+#define bfin_read_CAN1_MB28_LENGTH()		bfin_read16(CAN1_MB28_LENGTH)
+#define bfin_write_CAN1_MB28_LENGTH(val)	bfin_write16(CAN1_MB28_LENGTH, val)
+#define bfin_read_CAN1_MB28_TIMESTAMP()		bfin_read16(CAN1_MB28_TIMESTAMP)
+#define bfin_write_CAN1_MB28_TIMESTAMP(val)	bfin_write16(CAN1_MB28_TIMESTAMP, val)
+#define bfin_read_CAN1_MB28_ID0()		bfin_read16(CAN1_MB28_ID0)
+#define bfin_write_CAN1_MB28_ID0(val)		bfin_write16(CAN1_MB28_ID0, val)
+#define bfin_read_CAN1_MB28_ID1()		bfin_read16(CAN1_MB28_ID1)
+#define bfin_write_CAN1_MB28_ID1(val)		bfin_write16(CAN1_MB28_ID1, val)
+#define bfin_read_CAN1_MB29_DATA0()		bfin_read16(CAN1_MB29_DATA0)
+#define bfin_write_CAN1_MB29_DATA0(val)		bfin_write16(CAN1_MB29_DATA0, val)
+#define bfin_read_CAN1_MB29_DATA1()		bfin_read16(CAN1_MB29_DATA1)
+#define bfin_write_CAN1_MB29_DATA1(val)		bfin_write16(CAN1_MB29_DATA1, val)
+#define bfin_read_CAN1_MB29_DATA2()		bfin_read16(CAN1_MB29_DATA2)
+#define bfin_write_CAN1_MB29_DATA2(val)		bfin_write16(CAN1_MB29_DATA2, val)
+#define bfin_read_CAN1_MB29_DATA3()		bfin_read16(CAN1_MB29_DATA3)
+#define bfin_write_CAN1_MB29_DATA3(val)		bfin_write16(CAN1_MB29_DATA3, val)
+#define bfin_read_CAN1_MB29_LENGTH()		bfin_read16(CAN1_MB29_LENGTH)
+#define bfin_write_CAN1_MB29_LENGTH(val)	bfin_write16(CAN1_MB29_LENGTH, val)
+#define bfin_read_CAN1_MB29_TIMESTAMP()		bfin_read16(CAN1_MB29_TIMESTAMP)
+#define bfin_write_CAN1_MB29_TIMESTAMP(val)	bfin_write16(CAN1_MB29_TIMESTAMP, val)
+#define bfin_read_CAN1_MB29_ID0()		bfin_read16(CAN1_MB29_ID0)
+#define bfin_write_CAN1_MB29_ID0(val)		bfin_write16(CAN1_MB29_ID0, val)
+#define bfin_read_CAN1_MB29_ID1()		bfin_read16(CAN1_MB29_ID1)
+#define bfin_write_CAN1_MB29_ID1(val)		bfin_write16(CAN1_MB29_ID1, val)
+#define bfin_read_CAN1_MB30_DATA0()		bfin_read16(CAN1_MB30_DATA0)
+#define bfin_write_CAN1_MB30_DATA0(val)		bfin_write16(CAN1_MB30_DATA0, val)
+#define bfin_read_CAN1_MB30_DATA1()		bfin_read16(CAN1_MB30_DATA1)
+#define bfin_write_CAN1_MB30_DATA1(val)		bfin_write16(CAN1_MB30_DATA1, val)
+#define bfin_read_CAN1_MB30_DATA2()		bfin_read16(CAN1_MB30_DATA2)
+#define bfin_write_CAN1_MB30_DATA2(val)		bfin_write16(CAN1_MB30_DATA2, val)
+#define bfin_read_CAN1_MB30_DATA3()		bfin_read16(CAN1_MB30_DATA3)
+#define bfin_write_CAN1_MB30_DATA3(val)		bfin_write16(CAN1_MB30_DATA3, val)
+#define bfin_read_CAN1_MB30_LENGTH()		bfin_read16(CAN1_MB30_LENGTH)
+#define bfin_write_CAN1_MB30_LENGTH(val)	bfin_write16(CAN1_MB30_LENGTH, val)
+#define bfin_read_CAN1_MB30_TIMESTAMP()		bfin_read16(CAN1_MB30_TIMESTAMP)
+#define bfin_write_CAN1_MB30_TIMESTAMP(val)	bfin_write16(CAN1_MB30_TIMESTAMP, val)
+#define bfin_read_CAN1_MB30_ID0()		bfin_read16(CAN1_MB30_ID0)
+#define bfin_write_CAN1_MB30_ID0(val)		bfin_write16(CAN1_MB30_ID0, val)
+#define bfin_read_CAN1_MB30_ID1()		bfin_read16(CAN1_MB30_ID1)
+#define bfin_write_CAN1_MB30_ID1(val)		bfin_write16(CAN1_MB30_ID1, val)
+#define bfin_read_CAN1_MB31_DATA0()		bfin_read16(CAN1_MB31_DATA0)
+#define bfin_write_CAN1_MB31_DATA0(val)		bfin_write16(CAN1_MB31_DATA0, val)
+#define bfin_read_CAN1_MB31_DATA1()		bfin_read16(CAN1_MB31_DATA1)
+#define bfin_write_CAN1_MB31_DATA1(val)		bfin_write16(CAN1_MB31_DATA1, val)
+#define bfin_read_CAN1_MB31_DATA2()		bfin_read16(CAN1_MB31_DATA2)
+#define bfin_write_CAN1_MB31_DATA2(val)		bfin_write16(CAN1_MB31_DATA2, val)
+#define bfin_read_CAN1_MB31_DATA3()		bfin_read16(CAN1_MB31_DATA3)
+#define bfin_write_CAN1_MB31_DATA3(val)		bfin_write16(CAN1_MB31_DATA3, val)
+#define bfin_read_CAN1_MB31_LENGTH()		bfin_read16(CAN1_MB31_LENGTH)
+#define bfin_write_CAN1_MB31_LENGTH(val)	bfin_write16(CAN1_MB31_LENGTH, val)
+#define bfin_read_CAN1_MB31_TIMESTAMP()		bfin_read16(CAN1_MB31_TIMESTAMP)
+#define bfin_write_CAN1_MB31_TIMESTAMP(val)	bfin_write16(CAN1_MB31_TIMESTAMP, val)
+#define bfin_read_CAN1_MB31_ID0()		bfin_read16(CAN1_MB31_ID0)
+#define bfin_write_CAN1_MB31_ID0(val)		bfin_write16(CAN1_MB31_ID0, val)
+#define bfin_read_CAN1_MB31_ID1()		bfin_read16(CAN1_MB31_ID1)
+#define bfin_write_CAN1_MB31_ID1(val)		bfin_write16(CAN1_MB31_ID1, val)
+
+/* HOST Port Registers */
+
+#define bfin_read_HOST_CONTROL()		bfin_read16(HOST_CONTROL)
+#define bfin_write_HOST_CONTROL(val)		bfin_write16(HOST_CONTROL, val)
+#define bfin_read_HOST_STATUS()		bfin_read16(HOST_STATUS)
+#define bfin_write_HOST_STATUS(val)		bfin_write16(HOST_STATUS, val)
+#define bfin_read_HOST_TIMEOUT()		bfin_read16(HOST_TIMEOUT)
+#define bfin_write_HOST_TIMEOUT(val)		bfin_write16(HOST_TIMEOUT, val)
+
+/* Pixel Combfin_read_()ositor (PIXC) Registers */
+
+#define bfin_read_PIXC_CTL()		bfin_read16(PIXC_CTL)
+#define bfin_write_PIXC_CTL(val)	bfin_write16(PIXC_CTL, val)
+#define bfin_read_PIXC_PPL()		bfin_read16(PIXC_PPL)
+#define bfin_write_PIXC_PPL(val)	bfin_write16(PIXC_PPL, val)
+#define bfin_read_PIXC_LPF()		bfin_read16(PIXC_LPF)
+#define bfin_write_PIXC_LPF(val)	bfin_write16(PIXC_LPF, val)
+#define bfin_read_PIXC_AHSTART()	bfin_read16(PIXC_AHSTART)
+#define bfin_write_PIXC_AHSTART(val)	bfin_write16(PIXC_AHSTART, val)
+#define bfin_read_PIXC_AHEND()		bfin_read16(PIXC_AHEND)
+#define bfin_write_PIXC_AHEND(val)	bfin_write16(PIXC_AHEND, val)
+#define bfin_read_PIXC_AVSTART()	bfin_read16(PIXC_AVSTART)
+#define bfin_write_PIXC_AVSTART(val)	bfin_write16(PIXC_AVSTART, val)
+#define bfin_read_PIXC_AVEND()		bfin_read16(PIXC_AVEND)
+#define bfin_write_PIXC_AVEND(val)	bfin_write16(PIXC_AVEND, val)
+#define bfin_read_PIXC_ATRANSP()	bfin_read16(PIXC_ATRANSP)
+#define bfin_write_PIXC_ATRANSP(val)	bfin_write16(PIXC_ATRANSP, val)
+#define bfin_read_PIXC_BHSTART()	bfin_read16(PIXC_BHSTART)
+#define bfin_write_PIXC_BHSTART(val)	bfin_write16(PIXC_BHSTART, val)
+#define bfin_read_PIXC_BHEND()		bfin_read16(PIXC_BHEND)
+#define bfin_write_PIXC_BHEND(val)	bfin_write16(PIXC_BHEND, val)
+#define bfin_read_PIXC_BVSTART()	bfin_read16(PIXC_BVSTART)
+#define bfin_write_PIXC_BVSTART(val)	bfin_write16(PIXC_BVSTART, val)
+#define bfin_read_PIXC_BVEND()		bfin_read16(PIXC_BVEND)
+#define bfin_write_PIXC_BVEND(val)	bfin_write16(PIXC_BVEND, val)
+#define bfin_read_PIXC_BTRANSP()	bfin_read16(PIXC_BTRANSP)
+#define bfin_write_PIXC_BTRANSP(val)	bfin_write16(PIXC_BTRANSP, val)
+#define bfin_read_PIXC_INTRSTAT()	bfin_read16(PIXC_INTRSTAT)
+#define bfin_write_PIXC_INTRSTAT(val)	bfin_write16(PIXC_INTRSTAT, val)
+#define bfin_read_PIXC_RYCON()		bfin_read32(PIXC_RYCON)
+#define bfin_write_PIXC_RYCON(val)	bfin_write32(PIXC_RYCON, val)
+#define bfin_read_PIXC_GUCON()		bfin_read32(PIXC_GUCON)
+#define bfin_write_PIXC_GUCON(val)	bfin_write32(PIXC_GUCON, val)
+#define bfin_read_PIXC_BVCON()		bfin_read32(PIXC_BVCON)
+#define bfin_write_PIXC_BVCON(val)	bfin_write32(PIXC_BVCON, val)
+#define bfin_read_PIXC_CCBIAS()		bfin_read32(PIXC_CCBIAS)
+#define bfin_write_PIXC_CCBIAS(val)	bfin_write32(PIXC_CCBIAS, val)
+#define bfin_read_PIXC_TC()		bfin_read32(PIXC_TC)
+#define bfin_write_PIXC_TC(val)		bfin_write32(PIXC_TC, val)
+
+/* Handshake MDMA 0 Registers */
+
+#define bfin_read_HMDMA0_CONTROL()		bfin_read16(HMDMA0_CONTROL)
+#define bfin_write_HMDMA0_CONTROL(val)		bfin_write16(HMDMA0_CONTROL, val)
+#define bfin_read_HMDMA0_ECINIT()		bfin_read16(HMDMA0_ECINIT)
+#define bfin_write_HMDMA0_ECINIT(val)		bfin_write16(HMDMA0_ECINIT, val)
+#define bfin_read_HMDMA0_BCINIT()		bfin_read16(HMDMA0_BCINIT)
+#define bfin_write_HMDMA0_BCINIT(val)		bfin_write16(HMDMA0_BCINIT, val)
+#define bfin_read_HMDMA0_ECURGENT()		bfin_read16(HMDMA0_ECURGENT)
+#define bfin_write_HMDMA0_ECURGENT(val)		bfin_write16(HMDMA0_ECURGENT, val)
+#define bfin_read_HMDMA0_ECOVERFLOW()		bfin_read16(HMDMA0_ECOVERFLOW)
+#define bfin_write_HMDMA0_ECOVERFLOW(val)	bfin_write16(HMDMA0_ECOVERFLOW, val)
+#define bfin_read_HMDMA0_ECOUNT()		bfin_read16(HMDMA0_ECOUNT)
+#define bfin_write_HMDMA0_ECOUNT(val)		bfin_write16(HMDMA0_ECOUNT, val)
+#define bfin_read_HMDMA0_BCOUNT()		bfin_read16(HMDMA0_BCOUNT)
+#define bfin_write_HMDMA0_BCOUNT(val)		bfin_write16(HMDMA0_BCOUNT, val)
+
+/* Handshake MDMA 1 Registers */
+
+#define bfin_read_HMDMA1_CONTROL()		bfin_read16(HMDMA1_CONTROL)
+#define bfin_write_HMDMA1_CONTROL(val)		bfin_write16(HMDMA1_CONTROL, val)
+#define bfin_read_HMDMA1_ECINIT()		bfin_read16(HMDMA1_ECINIT)
+#define bfin_write_HMDMA1_ECINIT(val)		bfin_write16(HMDMA1_ECINIT, val)
+#define bfin_read_HMDMA1_BCINIT()		bfin_read16(HMDMA1_BCINIT)
+#define bfin_write_HMDMA1_BCINIT(val)		bfin_write16(HMDMA1_BCINIT, val)
+#define bfin_read_HMDMA1_ECURGENT()		bfin_read16(HMDMA1_ECURGENT)
+#define bfin_write_HMDMA1_ECURGENT(val)		bfin_write16(HMDMA1_ECURGENT, val)
+#define bfin_read_HMDMA1_ECOVERFLOW()		bfin_read16(HMDMA1_ECOVERFLOW)
+#define bfin_write_HMDMA1_ECOVERFLOW(val)	bfin_write16(HMDMA1_ECOVERFLOW, val)
+#define bfin_read_HMDMA1_ECOUNT()		bfin_read16(HMDMA1_ECOUNT)
+#define bfin_write_HMDMA1_ECOUNT(val)		bfin_write16(HMDMA1_ECOUNT, val)
+#define bfin_read_HMDMA1_BCOUNT()		bfin_read16(HMDMA1_BCOUNT)
+#define bfin_write_HMDMA1_BCOUNT(val)		bfin_write16(HMDMA1_BCOUNT, val)
+
+#endif /* _CDEF_BF544_H */
diff --git a/include/asm-blackfin/mach-bf548/cdefBF548.h b/include/asm-blackfin/mach-bf548/cdefBF548.h
new file mode 100644
index 0000000..674be02
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/cdefBF548.h
@@ -0,0 +1,1610 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/cdefBF548.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF548_H
+#define _CDEF_BF548_H
+
+/* include all Core registers and bit definitions */
+#include "defBF548.h"
+
+/* include core sbfin_read_()ecific register pointer definitions */
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF548 */
+
+/* include cdefBF54x_base.h for the set of #defines that are common to all ADSP-BF54x bfin_read_()rocessors */
+#include "cdefBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF548 that are not in the common header */
+
+/* Timer Registers */
+
+#define bfin_read_TIMER8_CONFIG()	bfin_read16(TIMER8_CONFIG)
+#define bfin_write_TIMER8_CONFIG(val)	bfin_write16(TIMER8_CONFIG, val)
+#define bfin_read_TIMER8_COUNTER()	bfin_read32(TIMER8_COUNTER)
+#define bfin_write_TIMER8_COUNTER(val)	bfin_write32(TIMER8_COUNTER, val)
+#define bfin_read_TIMER8_PERIOD()	bfin_read32(TIMER8_PERIOD)
+#define bfin_write_TIMER8_PERIOD(val)	bfin_write32(TIMER8_PERIOD, val)
+#define bfin_read_TIMER8_WIDTH()	bfin_read32(TIMER8_WIDTH)
+#define bfin_write_TIMER8_WIDTH(val)	bfin_write32(TIMER8_WIDTH, val)
+#define bfin_read_TIMER9_CONFIG()	bfin_read16(TIMER9_CONFIG)
+#define bfin_write_TIMER9_CONFIG(val)	bfin_write16(TIMER9_CONFIG, val)
+#define bfin_read_TIMER9_COUNTER()	bfin_read32(TIMER9_COUNTER)
+#define bfin_write_TIMER9_COUNTER(val)	bfin_write32(TIMER9_COUNTER, val)
+#define bfin_read_TIMER9_PERIOD()	bfin_read32(TIMER9_PERIOD)
+#define bfin_write_TIMER9_PERIOD(val)	bfin_write32(TIMER9_PERIOD, val)
+#define bfin_read_TIMER9_WIDTH()	bfin_read32(TIMER9_WIDTH)
+#define bfin_write_TIMER9_WIDTH(val)	bfin_write32(TIMER9_WIDTH, val)
+#define bfin_read_TIMER10_CONFIG()	bfin_read16(TIMER10_CONFIG)
+#define bfin_write_TIMER10_CONFIG(val)	bfin_write16(TIMER10_CONFIG, val)
+#define bfin_read_TIMER10_COUNTER()	bfin_read32(TIMER10_COUNTER)
+#define bfin_write_TIMER10_COUNTER(val)	bfin_write32(TIMER10_COUNTER, val)
+#define bfin_read_TIMER10_PERIOD()	bfin_read32(TIMER10_PERIOD)
+#define bfin_write_TIMER10_PERIOD(val)	bfin_write32(TIMER10_PERIOD, val)
+#define bfin_read_TIMER10_WIDTH()	bfin_read32(TIMER10_WIDTH)
+#define bfin_write_TIMER10_WIDTH(val)	bfin_write32(TIMER10_WIDTH, val)
+
+/* Timer Groubfin_read_() of 3 */
+
+#define bfin_read_TIMER_ENABLE1()	bfin_read16(TIMER_ENABLE1)
+#define bfin_write_TIMER_ENABLE1(val)	bfin_write16(TIMER_ENABLE1, val)
+#define bfin_read_TIMER_DISABLE1()	bfin_read16(TIMER_DISABLE1)
+#define bfin_write_TIMER_DISABLE1(val)	bfin_write16(TIMER_DISABLE1, val)
+#define bfin_read_TIMER_STATUS1()	bfin_read32(TIMER_STATUS1)
+#define bfin_write_TIMER_STATUS1(val)	bfin_write32(TIMER_STATUS1, val)
+
+/* SPORT0 Registers */
+
+#define bfin_read_SPORT0_TCR1()		bfin_read16(SPORT0_TCR1)
+#define bfin_write_SPORT0_TCR1(val)	bfin_write16(SPORT0_TCR1, val)
+#define bfin_read_SPORT0_TCR2()		bfin_read16(SPORT0_TCR2)
+#define bfin_write_SPORT0_TCR2(val)	bfin_write16(SPORT0_TCR2, val)
+#define bfin_read_SPORT0_TCLKDIV()	bfin_read16(SPORT0_TCLKDIV)
+#define bfin_write_SPORT0_TCLKDIV(val)	bfin_write16(SPORT0_TCLKDIV, val)
+#define bfin_read_SPORT0_TFSDIV()	bfin_read16(SPORT0_TFSDIV)
+#define bfin_write_SPORT0_TFSDIV(val)	bfin_write16(SPORT0_TFSDIV, val)
+#define bfin_read_SPORT0_TX()		bfin_read32(SPORT0_TX)
+#define bfin_write_SPORT0_TX(val)	bfin_write32(SPORT0_TX, val)
+#define bfin_read_SPORT0_RX()		bfin_read32(SPORT0_RX)
+#define bfin_write_SPORT0_RX(val)	bfin_write32(SPORT0_RX, val)
+#define bfin_read_SPORT0_RCR1()		bfin_read16(SPORT0_RCR1)
+#define bfin_write_SPORT0_RCR1(val)	bfin_write16(SPORT0_RCR1, val)
+#define bfin_read_SPORT0_RCR2()		bfin_read16(SPORT0_RCR2)
+#define bfin_write_SPORT0_RCR2(val)	bfin_write16(SPORT0_RCR2, val)
+#define bfin_read_SPORT0_RCLKDIV()	bfin_read16(SPORT0_RCLKDIV)
+#define bfin_write_SPORT0_RCLKDIV(val)	bfin_write16(SPORT0_RCLKDIV, val)
+#define bfin_read_SPORT0_RFSDIV()	bfin_read16(SPORT0_RFSDIV)
+#define bfin_write_SPORT0_RFSDIV(val)	bfin_write16(SPORT0_RFSDIV, val)
+#define bfin_read_SPORT0_STAT()		bfin_read16(SPORT0_STAT)
+#define bfin_write_SPORT0_STAT(val)	bfin_write16(SPORT0_STAT, val)
+#define bfin_read_SPORT0_CHNL()		bfin_read16(SPORT0_CHNL)
+#define bfin_write_SPORT0_CHNL(val)	bfin_write16(SPORT0_CHNL, val)
+#define bfin_read_SPORT0_MCMC1()	bfin_read16(SPORT0_MCMC1)
+#define bfin_write_SPORT0_MCMC1(val)	bfin_write16(SPORT0_MCMC1, val)
+#define bfin_read_SPORT0_MCMC2()	bfin_read16(SPORT0_MCMC2)
+#define bfin_write_SPORT0_MCMC2(val)	bfin_write16(SPORT0_MCMC2, val)
+#define bfin_read_SPORT0_MTCS0()	bfin_read32(SPORT0_MTCS0)
+#define bfin_write_SPORT0_MTCS0(val)	bfin_write32(SPORT0_MTCS0, val)
+#define bfin_read_SPORT0_MTCS1()	bfin_read32(SPORT0_MTCS1)
+#define bfin_write_SPORT0_MTCS1(val)	bfin_write32(SPORT0_MTCS1, val)
+#define bfin_read_SPORT0_MTCS2()	bfin_read32(SPORT0_MTCS2)
+#define bfin_write_SPORT0_MTCS2(val)	bfin_write32(SPORT0_MTCS2, val)
+#define bfin_read_SPORT0_MTCS3()	bfin_read32(SPORT0_MTCS3)
+#define bfin_write_SPORT0_MTCS3(val)	bfin_write32(SPORT0_MTCS3, val)
+#define bfin_read_SPORT0_MRCS0()	bfin_read32(SPORT0_MRCS0)
+#define bfin_write_SPORT0_MRCS0(val)	bfin_write32(SPORT0_MRCS0, val)
+#define bfin_read_SPORT0_MRCS1()	bfin_read32(SPORT0_MRCS1)
+#define bfin_write_SPORT0_MRCS1(val)	bfin_write32(SPORT0_MRCS1, val)
+#define bfin_read_SPORT0_MRCS2()	bfin_read32(SPORT0_MRCS2)
+#define bfin_write_SPORT0_MRCS2(val)	bfin_write32(SPORT0_MRCS2, val)
+#define bfin_read_SPORT0_MRCS3()	bfin_read32(SPORT0_MRCS3)
+#define bfin_write_SPORT0_MRCS3(val)	bfin_write32(SPORT0_MRCS3, val)
+
+/* EPPI0 Registers */
+
+#define bfin_read_EPPI0_STATUS()	bfin_read16(EPPI0_STATUS)
+#define bfin_write_EPPI0_STATUS(val)	bfin_write16(EPPI0_STATUS, val)
+#define bfin_read_EPPI0_HCOUNT()	bfin_read16(EPPI0_HCOUNT)
+#define bfin_write_EPPI0_HCOUNT(val)	bfin_write16(EPPI0_HCOUNT, val)
+#define bfin_read_EPPI0_HDELAY()	bfin_read16(EPPI0_HDELAY)
+#define bfin_write_EPPI0_HDELAY(val)	bfin_write16(EPPI0_HDELAY, val)
+#define bfin_read_EPPI0_VCOUNT()	bfin_read16(EPPI0_VCOUNT)
+#define bfin_write_EPPI0_VCOUNT(val)	bfin_write16(EPPI0_VCOUNT, val)
+#define bfin_read_EPPI0_VDELAY()	bfin_read16(EPPI0_VDELAY)
+#define bfin_write_EPPI0_VDELAY(val)	bfin_write16(EPPI0_VDELAY, val)
+#define bfin_read_EPPI0_FRAME()		bfin_read16(EPPI0_FRAME)
+#define bfin_write_EPPI0_FRAME(val)	bfin_write16(EPPI0_FRAME, val)
+#define bfin_read_EPPI0_LINE()		bfin_read16(EPPI0_LINE)
+#define bfin_write_EPPI0_LINE(val)	bfin_write16(EPPI0_LINE, val)
+#define bfin_read_EPPI0_CLKDIV()	bfin_read16(EPPI0_CLKDIV)
+#define bfin_write_EPPI0_CLKDIV(val)	bfin_write16(EPPI0_CLKDIV, val)
+#define bfin_read_EPPI0_CONTROL()	bfin_read32(EPPI0_CONTROL)
+#define bfin_write_EPPI0_CONTROL(val)	bfin_write32(EPPI0_CONTROL, val)
+#define bfin_read_EPPI0_FS1W_HBL()	bfin_read32(EPPI0_FS1W_HBL)
+#define bfin_write_EPPI0_FS1W_HBL(val)	bfin_write32(EPPI0_FS1W_HBL, val)
+#define bfin_read_EPPI0_FS1P_AVPL()	bfin_read32(EPPI0_FS1P_AVPL)
+#define bfin_write_EPPI0_FS1P_AVPL(val)	bfin_write32(EPPI0_FS1P_AVPL, val)
+#define bfin_read_EPPI0_FS2W_LVB()	bfin_read32(EPPI0_FS2W_LVB)
+#define bfin_write_EPPI0_FS2W_LVB(val)	bfin_write32(EPPI0_FS2W_LVB, val)
+#define bfin_read_EPPI0_FS2P_LAVF()	bfin_read32(EPPI0_FS2P_LAVF)
+#define bfin_write_EPPI0_FS2P_LAVF(val)	bfin_write32(EPPI0_FS2P_LAVF, val)
+#define bfin_read_EPPI0_CLIP()		bfin_read32(EPPI0_CLIP)
+#define bfin_write_EPPI0_CLIP(val)	bfin_write32(EPPI0_CLIP, val)
+
+/* UART2 Registers */
+
+#define bfin_read_UART2_DLL()		bfin_read16(UART2_DLL)
+#define bfin_write_UART2_DLL(val)	bfin_write16(UART2_DLL, val)
+#define bfin_read_UART2_DLH()		bfin_read16(UART2_DLH)
+#define bfin_write_UART2_DLH(val)	bfin_write16(UART2_DLH, val)
+#define bfin_read_UART2_GCTL()		bfin_read16(UART2_GCTL)
+#define bfin_write_UART2_GCTL(val)	bfin_write16(UART2_GCTL, val)
+#define bfin_read_UART2_LCR()		bfin_read16(UART2_LCR)
+#define bfin_write_UART2_LCR(val)	bfin_write16(UART2_LCR, val)
+#define bfin_read_UART2_MCR()		bfin_read16(UART2_MCR)
+#define bfin_write_UART2_MCR(val)	bfin_write16(UART2_MCR, val)
+#define bfin_read_UART2_LSR()		bfin_read16(UART2_LSR)
+#define bfin_write_UART2_LSR(val)	bfin_write16(UART2_LSR, val)
+#define bfin_read_UART2_MSR()		bfin_read16(UART2_MSR)
+#define bfin_write_UART2_MSR(val)	bfin_write16(UART2_MSR, val)
+#define bfin_read_UART2_SCR()		bfin_read16(UART2_SCR)
+#define bfin_write_UART2_SCR(val)	bfin_write16(UART2_SCR, val)
+#define bfin_read_UART2_IER_SET()	bfin_read16(UART2_IER_SET)
+#define bfin_write_UART2_IER_SET(val)	bfin_write16(UART2_IER_SET, val)
+#define bfin_read_UART2_IER_CLEAR()	bfin_read16(UART2_IER_CLEAR)
+#define bfin_write_UART2_IER_CLEAR(val)	bfin_write16(UART2_IER_CLEAR, val)
+#define bfin_read_UART2_RBR()		bfin_read16(UART2_RBR)
+#define bfin_write_UART2_RBR(val)	bfin_write16(UART2_RBR, val)
+
+/* Two Wire Interface Registers (TWI1) */
+
+#define bfin_read_TWI1_CLKDIV()			bfin_read16(TWI1_CLKDIV)
+#define bfin_write_TWI1_CLKDIV(val)		bfin_write16(TWI1_CLKDIV, val)
+#define bfin_read_TWI1_CONTROL()		bfin_read16(TWI1_CONTROL)
+#define bfin_write_TWI1_CONTROL(val)		bfin_write16(TWI1_CONTROL, val)
+#define bfin_read_TWI1_SLAVE_CTRL()		bfin_read16(TWI1_SLAVE_CTRL)
+#define bfin_write_TWI1_SLAVE_CTRL(val)		bfin_write16(TWI1_SLAVE_CTRL, val)
+#define bfin_read_TWI1_SLAVE_STAT()		bfin_read16(TWI1_SLAVE_STAT)
+#define bfin_write_TWI1_SLAVE_STAT(val)		bfin_write16(TWI1_SLAVE_STAT, val)
+#define bfin_read_TWI1_SLAVE_ADDR()		bfin_read16(TWI1_SLAVE_ADDR)
+#define bfin_write_TWI1_SLAVE_ADDR(val)		bfin_write16(TWI1_SLAVE_ADDR, val)
+#define bfin_read_TWI1_MASTER_CTRL()		bfin_read16(TWI1_MASTER_CTRL)
+#define bfin_write_TWI1_MASTER_CTRL(val)	bfin_write16(TWI1_MASTER_CTRL, val)
+#define bfin_read_TWI1_MASTER_STAT()		bfin_read16(TWI1_MASTER_STAT)
+#define bfin_write_TWI1_MASTER_STAT(val)	bfin_write16(TWI1_MASTER_STAT, val)
+#define bfin_read_TWI1_MASTER_ADDR()		bfin_read16(TWI1_MASTER_ADDR)
+#define bfin_write_TWI1_MASTER_ADDR(val)	bfin_write16(TWI1_MASTER_ADDR, val)
+#define bfin_read_TWI1_INT_STAT()		bfin_read16(TWI1_INT_STAT)
+#define bfin_write_TWI1_INT_STAT(val)		bfin_write16(TWI1_INT_STAT, val)
+#define bfin_read_TWI1_INT_MASK()		bfin_read16(TWI1_INT_MASK)
+#define bfin_write_TWI1_INT_MASK(val)		bfin_write16(TWI1_INT_MASK, val)
+#define bfin_read_TWI1_FIFO_CTRL()		bfin_read16(TWI1_FIFO_CTRL)
+#define bfin_write_TWI1_FIFO_CTRL(val)		bfin_write16(TWI1_FIFO_CTRL, val)
+#define bfin_read_TWI1_FIFO_STAT()		bfin_read16(TWI1_FIFO_STAT)
+#define bfin_write_TWI1_FIFO_STAT(val)		bfin_write16(TWI1_FIFO_STAT, val)
+#define bfin_read_TWI1_XMT_DATA8()		bfin_read16(TWI1_XMT_DATA8)
+#define bfin_write_TWI1_XMT_DATA8(val)		bfin_write16(TWI1_XMT_DATA8, val)
+#define bfin_read_TWI1_XMT_DATA16()		bfin_read16(TWI1_XMT_DATA16)
+#define bfin_write_TWI1_XMT_DATA16(val)		bfin_write16(TWI1_XMT_DATA16, val)
+#define bfin_read_TWI1_RCV_DATA8()		bfin_read16(TWI1_RCV_DATA8)
+#define bfin_write_TWI1_RCV_DATA8(val)		bfin_write16(TWI1_RCV_DATA8, val)
+#define bfin_read_TWI1_RCV_DATA16()		bfin_read16(TWI1_RCV_DATA16)
+#define bfin_write_TWI1_RCV_DATA16(val)		bfin_write16(TWI1_RCV_DATA16, val)
+
+/* SPI2  Registers */
+
+#define bfin_read_SPI2_CTL()		bfin_read16(SPI2_CTL)
+#define bfin_write_SPI2_CTL(val)	bfin_write16(SPI2_CTL, val)
+#define bfin_read_SPI2_FLG()		bfin_read16(SPI2_FLG)
+#define bfin_write_SPI2_FLG(val)	bfin_write16(SPI2_FLG, val)
+#define bfin_read_SPI2_STAT()		bfin_read16(SPI2_STAT)
+#define bfin_write_SPI2_STAT(val)	bfin_write16(SPI2_STAT, val)
+#define bfin_read_SPI2_TDBR()		bfin_read16(SPI2_TDBR)
+#define bfin_write_SPI2_TDBR(val)	bfin_write16(SPI2_TDBR, val)
+#define bfin_read_SPI2_RDBR()		bfin_read16(SPI2_RDBR)
+#define bfin_write_SPI2_RDBR(val)	bfin_write16(SPI2_RDBR, val)
+#define bfin_read_SPI2_BAUD()		bfin_read16(SPI2_BAUD)
+#define bfin_write_SPI2_BAUD(val)	bfin_write16(SPI2_BAUD, val)
+#define bfin_read_SPI2_SHADOW()		bfin_read16(SPI2_SHADOW)
+#define bfin_write_SPI2_SHADOW(val)	bfin_write16(SPI2_SHADOW, val)
+
+/* CAN Controller 1 Config 1 Registers */
+
+#define bfin_read_CAN1_MC1()		bfin_read16(CAN1_MC1)
+#define bfin_write_CAN1_MC1(val)	bfin_write16(CAN1_MC1, val)
+#define bfin_read_CAN1_MD1()		bfin_read16(CAN1_MD1)
+#define bfin_write_CAN1_MD1(val)	bfin_write16(CAN1_MD1, val)
+#define bfin_read_CAN1_TRS1()		bfin_read16(CAN1_TRS1)
+#define bfin_write_CAN1_TRS1(val)	bfin_write16(CAN1_TRS1, val)
+#define bfin_read_CAN1_TRR1()		bfin_read16(CAN1_TRR1)
+#define bfin_write_CAN1_TRR1(val)	bfin_write16(CAN1_TRR1, val)
+#define bfin_read_CAN1_TA1()		bfin_read16(CAN1_TA1)
+#define bfin_write_CAN1_TA1(val)	bfin_write16(CAN1_TA1, val)
+#define bfin_read_CAN1_AA1()		bfin_read16(CAN1_AA1)
+#define bfin_write_CAN1_AA1(val)	bfin_write16(CAN1_AA1, val)
+#define bfin_read_CAN1_RMP1()		bfin_read16(CAN1_RMP1)
+#define bfin_write_CAN1_RMP1(val)	bfin_write16(CAN1_RMP1, val)
+#define bfin_read_CAN1_RML1()		bfin_read16(CAN1_RML1)
+#define bfin_write_CAN1_RML1(val)	bfin_write16(CAN1_RML1, val)
+#define bfin_read_CAN1_MBTIF1()		bfin_read16(CAN1_MBTIF1)
+#define bfin_write_CAN1_MBTIF1(val)	bfin_write16(CAN1_MBTIF1, val)
+#define bfin_read_CAN1_MBRIF1()		bfin_read16(CAN1_MBRIF1)
+#define bfin_write_CAN1_MBRIF1(val)	bfin_write16(CAN1_MBRIF1, val)
+#define bfin_read_CAN1_MBIM1()		bfin_read16(CAN1_MBIM1)
+#define bfin_write_CAN1_MBIM1(val)	bfin_write16(CAN1_MBIM1, val)
+#define bfin_read_CAN1_RFH1()		bfin_read16(CAN1_RFH1)
+#define bfin_write_CAN1_RFH1(val)	bfin_write16(CAN1_RFH1, val)
+#define bfin_read_CAN1_OPSS1()		bfin_read16(CAN1_OPSS1)
+#define bfin_write_CAN1_OPSS1(val)	bfin_write16(CAN1_OPSS1, val)
+
+/* CAN Controller 1 Config 2 Registers */
+
+#define bfin_read_CAN1_MC2()		bfin_read16(CAN1_MC2)
+#define bfin_write_CAN1_MC2(val)	bfin_write16(CAN1_MC2, val)
+#define bfin_read_CAN1_MD2()		bfin_read16(CAN1_MD2)
+#define bfin_write_CAN1_MD2(val)	bfin_write16(CAN1_MD2, val)
+#define bfin_read_CAN1_TRS2()		bfin_read16(CAN1_TRS2)
+#define bfin_write_CAN1_TRS2(val)	bfin_write16(CAN1_TRS2, val)
+#define bfin_read_CAN1_TRR2()		bfin_read16(CAN1_TRR2)
+#define bfin_write_CAN1_TRR2(val)	bfin_write16(CAN1_TRR2, val)
+#define bfin_read_CAN1_TA2()		bfin_read16(CAN1_TA2)
+#define bfin_write_CAN1_TA2(val)	bfin_write16(CAN1_TA2, val)
+#define bfin_read_CAN1_AA2()		bfin_read16(CAN1_AA2)
+#define bfin_write_CAN1_AA2(val)	bfin_write16(CAN1_AA2, val)
+#define bfin_read_CAN1_RMP2()		bfin_read16(CAN1_RMP2)
+#define bfin_write_CAN1_RMP2(val)	bfin_write16(CAN1_RMP2, val)
+#define bfin_read_CAN1_RML2()		bfin_read16(CAN1_RML2)
+#define bfin_write_CAN1_RML2(val)	bfin_write16(CAN1_RML2, val)
+#define bfin_read_CAN1_MBTIF2()		bfin_read16(CAN1_MBTIF2)
+#define bfin_write_CAN1_MBTIF2(val)	bfin_write16(CAN1_MBTIF2, val)
+#define bfin_read_CAN1_MBRIF2()		bfin_read16(CAN1_MBRIF2)
+#define bfin_write_CAN1_MBRIF2(val)	bfin_write16(CAN1_MBRIF2, val)
+#define bfin_read_CAN1_MBIM2()		bfin_read16(CAN1_MBIM2)
+#define bfin_write_CAN1_MBIM2(val)	bfin_write16(CAN1_MBIM2, val)
+#define bfin_read_CAN1_RFH2()		bfin_read16(CAN1_RFH2)
+#define bfin_write_CAN1_RFH2(val)	bfin_write16(CAN1_RFH2, val)
+#define bfin_read_CAN1_OPSS2()		bfin_read16(CAN1_OPSS2)
+#define bfin_write_CAN1_OPSS2(val)	bfin_write16(CAN1_OPSS2, val)
+
+/* CAN Controller 1 Clock/Interrubfin_read_()t/Counter Registers */
+
+#define bfin_read_CAN1_CLOCK()		bfin_read16(CAN1_CLOCK)
+#define bfin_write_CAN1_CLOCK(val)	bfin_write16(CAN1_CLOCK, val)
+#define bfin_read_CAN1_TIMING()		bfin_read16(CAN1_TIMING)
+#define bfin_write_CAN1_TIMING(val)	bfin_write16(CAN1_TIMING, val)
+#define bfin_read_CAN1_DEBUG()		bfin_read16(CAN1_DEBUG)
+#define bfin_write_CAN1_DEBUG(val)	bfin_write16(CAN1_DEBUG, val)
+#define bfin_read_CAN1_STATUS()		bfin_read16(CAN1_STATUS)
+#define bfin_write_CAN1_STATUS(val)	bfin_write16(CAN1_STATUS, val)
+#define bfin_read_CAN1_CEC()		bfin_read16(CAN1_CEC)
+#define bfin_write_CAN1_CEC(val)	bfin_write16(CAN1_CEC, val)
+#define bfin_read_CAN1_GIS()		bfin_read16(CAN1_GIS)
+#define bfin_write_CAN1_GIS(val)	bfin_write16(CAN1_GIS, val)
+#define bfin_read_CAN1_GIM()		bfin_read16(CAN1_GIM)
+#define bfin_write_CAN1_GIM(val)	bfin_write16(CAN1_GIM, val)
+#define bfin_read_CAN1_GIF()		bfin_read16(CAN1_GIF)
+#define bfin_write_CAN1_GIF(val)	bfin_write16(CAN1_GIF, val)
+#define bfin_read_CAN1_CONTROL()	bfin_read16(CAN1_CONTROL)
+#define bfin_write_CAN1_CONTROL(val)	bfin_write16(CAN1_CONTROL, val)
+#define bfin_read_CAN1_INTR()		bfin_read16(CAN1_INTR)
+#define bfin_write_CAN1_INTR(val)	bfin_write16(CAN1_INTR, val)
+#define bfin_read_CAN1_MBTD()		bfin_read16(CAN1_MBTD)
+#define bfin_write_CAN1_MBTD(val)	bfin_write16(CAN1_MBTD, val)
+#define bfin_read_CAN1_EWR()		bfin_read16(CAN1_EWR)
+#define bfin_write_CAN1_EWR(val)	bfin_write16(CAN1_EWR, val)
+#define bfin_read_CAN1_ESR()		bfin_read16(CAN1_ESR)
+#define bfin_write_CAN1_ESR(val)	bfin_write16(CAN1_ESR, val)
+#define bfin_read_CAN1_UCCNT()		bfin_read16(CAN1_UCCNT)
+#define bfin_write_CAN1_UCCNT(val)	bfin_write16(CAN1_UCCNT, val)
+#define bfin_read_CAN1_UCRC()		bfin_read16(CAN1_UCRC)
+#define bfin_write_CAN1_UCRC(val)	bfin_write16(CAN1_UCRC, val)
+#define bfin_read_CAN1_UCCNF()		bfin_read16(CAN1_UCCNF)
+#define bfin_write_CAN1_UCCNF(val)	bfin_write16(CAN1_UCCNF, val)
+
+/* CAN Controller 1 Mailbox Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN1_AM00L()		bfin_read16(CAN1_AM00L)
+#define bfin_write_CAN1_AM00L(val)	bfin_write16(CAN1_AM00L, val)
+#define bfin_read_CAN1_AM00H()		bfin_read16(CAN1_AM00H)
+#define bfin_write_CAN1_AM00H(val)	bfin_write16(CAN1_AM00H, val)
+#define bfin_read_CAN1_AM01L()		bfin_read16(CAN1_AM01L)
+#define bfin_write_CAN1_AM01L(val)	bfin_write16(CAN1_AM01L, val)
+#define bfin_read_CAN1_AM01H()		bfin_read16(CAN1_AM01H)
+#define bfin_write_CAN1_AM01H(val)	bfin_write16(CAN1_AM01H, val)
+#define bfin_read_CAN1_AM02L()		bfin_read16(CAN1_AM02L)
+#define bfin_write_CAN1_AM02L(val)	bfin_write16(CAN1_AM02L, val)
+#define bfin_read_CAN1_AM02H()		bfin_read16(CAN1_AM02H)
+#define bfin_write_CAN1_AM02H(val)	bfin_write16(CAN1_AM02H, val)
+#define bfin_read_CAN1_AM03L()		bfin_read16(CAN1_AM03L)
+#define bfin_write_CAN1_AM03L(val)	bfin_write16(CAN1_AM03L, val)
+#define bfin_read_CAN1_AM03H()		bfin_read16(CAN1_AM03H)
+#define bfin_write_CAN1_AM03H(val)	bfin_write16(CAN1_AM03H, val)
+#define bfin_read_CAN1_AM04L()		bfin_read16(CAN1_AM04L)
+#define bfin_write_CAN1_AM04L(val)	bfin_write16(CAN1_AM04L, val)
+#define bfin_read_CAN1_AM04H()		bfin_read16(CAN1_AM04H)
+#define bfin_write_CAN1_AM04H(val)	bfin_write16(CAN1_AM04H, val)
+#define bfin_read_CAN1_AM05L()		bfin_read16(CAN1_AM05L)
+#define bfin_write_CAN1_AM05L(val)	bfin_write16(CAN1_AM05L, val)
+#define bfin_read_CAN1_AM05H()		bfin_read16(CAN1_AM05H)
+#define bfin_write_CAN1_AM05H(val)	bfin_write16(CAN1_AM05H, val)
+#define bfin_read_CAN1_AM06L()		bfin_read16(CAN1_AM06L)
+#define bfin_write_CAN1_AM06L(val)	bfin_write16(CAN1_AM06L, val)
+#define bfin_read_CAN1_AM06H()		bfin_read16(CAN1_AM06H)
+#define bfin_write_CAN1_AM06H(val)	bfin_write16(CAN1_AM06H, val)
+#define bfin_read_CAN1_AM07L()		bfin_read16(CAN1_AM07L)
+#define bfin_write_CAN1_AM07L(val)	bfin_write16(CAN1_AM07L, val)
+#define bfin_read_CAN1_AM07H()		bfin_read16(CAN1_AM07H)
+#define bfin_write_CAN1_AM07H(val)	bfin_write16(CAN1_AM07H, val)
+#define bfin_read_CAN1_AM08L()		bfin_read16(CAN1_AM08L)
+#define bfin_write_CAN1_AM08L(val)	bfin_write16(CAN1_AM08L, val)
+#define bfin_read_CAN1_AM08H()		bfin_read16(CAN1_AM08H)
+#define bfin_write_CAN1_AM08H(val)	bfin_write16(CAN1_AM08H, val)
+#define bfin_read_CAN1_AM09L()		bfin_read16(CAN1_AM09L)
+#define bfin_write_CAN1_AM09L(val)	bfin_write16(CAN1_AM09L, val)
+#define bfin_read_CAN1_AM09H()		bfin_read16(CAN1_AM09H)
+#define bfin_write_CAN1_AM09H(val)	bfin_write16(CAN1_AM09H, val)
+#define bfin_read_CAN1_AM10L()		bfin_read16(CAN1_AM10L)
+#define bfin_write_CAN1_AM10L(val)	bfin_write16(CAN1_AM10L, val)
+#define bfin_read_CAN1_AM10H()		bfin_read16(CAN1_AM10H)
+#define bfin_write_CAN1_AM10H(val)	bfin_write16(CAN1_AM10H, val)
+#define bfin_read_CAN1_AM11L()		bfin_read16(CAN1_AM11L)
+#define bfin_write_CAN1_AM11L(val)	bfin_write16(CAN1_AM11L, val)
+#define bfin_read_CAN1_AM11H()		bfin_read16(CAN1_AM11H)
+#define bfin_write_CAN1_AM11H(val)	bfin_write16(CAN1_AM11H, val)
+#define bfin_read_CAN1_AM12L()		bfin_read16(CAN1_AM12L)
+#define bfin_write_CAN1_AM12L(val)	bfin_write16(CAN1_AM12L, val)
+#define bfin_read_CAN1_AM12H()		bfin_read16(CAN1_AM12H)
+#define bfin_write_CAN1_AM12H(val)	bfin_write16(CAN1_AM12H, val)
+#define bfin_read_CAN1_AM13L()		bfin_read16(CAN1_AM13L)
+#define bfin_write_CAN1_AM13L(val)	bfin_write16(CAN1_AM13L, val)
+#define bfin_read_CAN1_AM13H()		bfin_read16(CAN1_AM13H)
+#define bfin_write_CAN1_AM13H(val)	bfin_write16(CAN1_AM13H, val)
+#define bfin_read_CAN1_AM14L()		bfin_read16(CAN1_AM14L)
+#define bfin_write_CAN1_AM14L(val)	bfin_write16(CAN1_AM14L, val)
+#define bfin_read_CAN1_AM14H()		bfin_read16(CAN1_AM14H)
+#define bfin_write_CAN1_AM14H(val)	bfin_write16(CAN1_AM14H, val)
+#define bfin_read_CAN1_AM15L()		bfin_read16(CAN1_AM15L)
+#define bfin_write_CAN1_AM15L(val)	bfin_write16(CAN1_AM15L, val)
+#define bfin_read_CAN1_AM15H()		bfin_read16(CAN1_AM15H)
+#define bfin_write_CAN1_AM15H(val)	bfin_write16(CAN1_AM15H, val)
+
+/* CAN Controller 1 Mailbox Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN1_AM16L()		bfin_read16(CAN1_AM16L)
+#define bfin_write_CAN1_AM16L(val)	bfin_write16(CAN1_AM16L, val)
+#define bfin_read_CAN1_AM16H()		bfin_read16(CAN1_AM16H)
+#define bfin_write_CAN1_AM16H(val)	bfin_write16(CAN1_AM16H, val)
+#define bfin_read_CAN1_AM17L()		bfin_read16(CAN1_AM17L)
+#define bfin_write_CAN1_AM17L(val)	bfin_write16(CAN1_AM17L, val)
+#define bfin_read_CAN1_AM17H()		bfin_read16(CAN1_AM17H)
+#define bfin_write_CAN1_AM17H(val)	bfin_write16(CAN1_AM17H, val)
+#define bfin_read_CAN1_AM18L()		bfin_read16(CAN1_AM18L)
+#define bfin_write_CAN1_AM18L(val)	bfin_write16(CAN1_AM18L, val)
+#define bfin_read_CAN1_AM18H()		bfin_read16(CAN1_AM18H)
+#define bfin_write_CAN1_AM18H(val)	bfin_write16(CAN1_AM18H, val)
+#define bfin_read_CAN1_AM19L()		bfin_read16(CAN1_AM19L)
+#define bfin_write_CAN1_AM19L(val)	bfin_write16(CAN1_AM19L, val)
+#define bfin_read_CAN1_AM19H()		bfin_read16(CAN1_AM19H)
+#define bfin_write_CAN1_AM19H(val)	bfin_write16(CAN1_AM19H, val)
+#define bfin_read_CAN1_AM20L()		bfin_read16(CAN1_AM20L)
+#define bfin_write_CAN1_AM20L(val)	bfin_write16(CAN1_AM20L, val)
+#define bfin_read_CAN1_AM20H()		bfin_read16(CAN1_AM20H)
+#define bfin_write_CAN1_AM20H(val)	bfin_write16(CAN1_AM20H, val)
+#define bfin_read_CAN1_AM21L()		bfin_read16(CAN1_AM21L)
+#define bfin_write_CAN1_AM21L(val)	bfin_write16(CAN1_AM21L, val)
+#define bfin_read_CAN1_AM21H()		bfin_read16(CAN1_AM21H)
+#define bfin_write_CAN1_AM21H(val)	bfin_write16(CAN1_AM21H, val)
+#define bfin_read_CAN1_AM22L()		bfin_read16(CAN1_AM22L)
+#define bfin_write_CAN1_AM22L(val)	bfin_write16(CAN1_AM22L, val)
+#define bfin_read_CAN1_AM22H()		bfin_read16(CAN1_AM22H)
+#define bfin_write_CAN1_AM22H(val)	bfin_write16(CAN1_AM22H, val)
+#define bfin_read_CAN1_AM23L()		bfin_read16(CAN1_AM23L)
+#define bfin_write_CAN1_AM23L(val)	bfin_write16(CAN1_AM23L, val)
+#define bfin_read_CAN1_AM23H()		bfin_read16(CAN1_AM23H)
+#define bfin_write_CAN1_AM23H(val)	bfin_write16(CAN1_AM23H, val)
+#define bfin_read_CAN1_AM24L()		bfin_read16(CAN1_AM24L)
+#define bfin_write_CAN1_AM24L(val)	bfin_write16(CAN1_AM24L, val)
+#define bfin_read_CAN1_AM24H()		bfin_read16(CAN1_AM24H)
+#define bfin_write_CAN1_AM24H(val)	bfin_write16(CAN1_AM24H, val)
+#define bfin_read_CAN1_AM25L()		bfin_read16(CAN1_AM25L)
+#define bfin_write_CAN1_AM25L(val)	bfin_write16(CAN1_AM25L, val)
+#define bfin_read_CAN1_AM25H()		bfin_read16(CAN1_AM25H)
+#define bfin_write_CAN1_AM25H(val)	bfin_write16(CAN1_AM25H, val)
+#define bfin_read_CAN1_AM26L()		bfin_read16(CAN1_AM26L)
+#define bfin_write_CAN1_AM26L(val)	bfin_write16(CAN1_AM26L, val)
+#define bfin_read_CAN1_AM26H()		bfin_read16(CAN1_AM26H)
+#define bfin_write_CAN1_AM26H(val)	bfin_write16(CAN1_AM26H, val)
+#define bfin_read_CAN1_AM27L()		bfin_read16(CAN1_AM27L)
+#define bfin_write_CAN1_AM27L(val)	bfin_write16(CAN1_AM27L, val)
+#define bfin_read_CAN1_AM27H()		bfin_read16(CAN1_AM27H)
+#define bfin_write_CAN1_AM27H(val)	bfin_write16(CAN1_AM27H, val)
+#define bfin_read_CAN1_AM28L()		bfin_read16(CAN1_AM28L)
+#define bfin_write_CAN1_AM28L(val)	bfin_write16(CAN1_AM28L, val)
+#define bfin_read_CAN1_AM28H()		bfin_read16(CAN1_AM28H)
+#define bfin_write_CAN1_AM28H(val)	bfin_write16(CAN1_AM28H, val)
+#define bfin_read_CAN1_AM29L()		bfin_read16(CAN1_AM29L)
+#define bfin_write_CAN1_AM29L(val)	bfin_write16(CAN1_AM29L, val)
+#define bfin_read_CAN1_AM29H()		bfin_read16(CAN1_AM29H)
+#define bfin_write_CAN1_AM29H(val)	bfin_write16(CAN1_AM29H, val)
+#define bfin_read_CAN1_AM30L()		bfin_read16(CAN1_AM30L)
+#define bfin_write_CAN1_AM30L(val)	bfin_write16(CAN1_AM30L, val)
+#define bfin_read_CAN1_AM30H()		bfin_read16(CAN1_AM30H)
+#define bfin_write_CAN1_AM30H(val)	bfin_write16(CAN1_AM30H, val)
+#define bfin_read_CAN1_AM31L()		bfin_read16(CAN1_AM31L)
+#define bfin_write_CAN1_AM31L(val)	bfin_write16(CAN1_AM31L, val)
+#define bfin_read_CAN1_AM31H()		bfin_read16(CAN1_AM31H)
+#define bfin_write_CAN1_AM31H(val)	bfin_write16(CAN1_AM31H, val)
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define bfin_read_CAN1_MB00_DATA0()		bfin_read16(CAN1_MB00_DATA0)
+#define bfin_write_CAN1_MB00_DATA0(val)		bfin_write16(CAN1_MB00_DATA0, val)
+#define bfin_read_CAN1_MB00_DATA1()		bfin_read16(CAN1_MB00_DATA1)
+#define bfin_write_CAN1_MB00_DATA1(val)		bfin_write16(CAN1_MB00_DATA1, val)
+#define bfin_read_CAN1_MB00_DATA2()		bfin_read16(CAN1_MB00_DATA2)
+#define bfin_write_CAN1_MB00_DATA2(val)		bfin_write16(CAN1_MB00_DATA2, val)
+#define bfin_read_CAN1_MB00_DATA3()		bfin_read16(CAN1_MB00_DATA3)
+#define bfin_write_CAN1_MB00_DATA3(val)		bfin_write16(CAN1_MB00_DATA3, val)
+#define bfin_read_CAN1_MB00_LENGTH()		bfin_read16(CAN1_MB00_LENGTH)
+#define bfin_write_CAN1_MB00_LENGTH(val)	bfin_write16(CAN1_MB00_LENGTH, val)
+#define bfin_read_CAN1_MB00_TIMESTAMP()		bfin_read16(CAN1_MB00_TIMESTAMP)
+#define bfin_write_CAN1_MB00_TIMESTAMP(val)	bfin_write16(CAN1_MB00_TIMESTAMP, val)
+#define bfin_read_CAN1_MB00_ID0()		bfin_read16(CAN1_MB00_ID0)
+#define bfin_write_CAN1_MB00_ID0(val)		bfin_write16(CAN1_MB00_ID0, val)
+#define bfin_read_CAN1_MB00_ID1()		bfin_read16(CAN1_MB00_ID1)
+#define bfin_write_CAN1_MB00_ID1(val)		bfin_write16(CAN1_MB00_ID1, val)
+#define bfin_read_CAN1_MB01_DATA0()		bfin_read16(CAN1_MB01_DATA0)
+#define bfin_write_CAN1_MB01_DATA0(val)		bfin_write16(CAN1_MB01_DATA0, val)
+#define bfin_read_CAN1_MB01_DATA1()		bfin_read16(CAN1_MB01_DATA1)
+#define bfin_write_CAN1_MB01_DATA1(val)		bfin_write16(CAN1_MB01_DATA1, val)
+#define bfin_read_CAN1_MB01_DATA2()		bfin_read16(CAN1_MB01_DATA2)
+#define bfin_write_CAN1_MB01_DATA2(val)		bfin_write16(CAN1_MB01_DATA2, val)
+#define bfin_read_CAN1_MB01_DATA3()		bfin_read16(CAN1_MB01_DATA3)
+#define bfin_write_CAN1_MB01_DATA3(val)		bfin_write16(CAN1_MB01_DATA3, val)
+#define bfin_read_CAN1_MB01_LENGTH()		bfin_read16(CAN1_MB01_LENGTH)
+#define bfin_write_CAN1_MB01_LENGTH(val)	bfin_write16(CAN1_MB01_LENGTH, val)
+#define bfin_read_CAN1_MB01_TIMESTAMP()		bfin_read16(CAN1_MB01_TIMESTAMP)
+#define bfin_write_CAN1_MB01_TIMESTAMP(val)	bfin_write16(CAN1_MB01_TIMESTAMP, val)
+#define bfin_read_CAN1_MB01_ID0()		bfin_read16(CAN1_MB01_ID0)
+#define bfin_write_CAN1_MB01_ID0(val)		bfin_write16(CAN1_MB01_ID0, val)
+#define bfin_read_CAN1_MB01_ID1()		bfin_read16(CAN1_MB01_ID1)
+#define bfin_write_CAN1_MB01_ID1(val)		bfin_write16(CAN1_MB01_ID1, val)
+#define bfin_read_CAN1_MB02_DATA0()		bfin_read16(CAN1_MB02_DATA0)
+#define bfin_write_CAN1_MB02_DATA0(val)		bfin_write16(CAN1_MB02_DATA0, val)
+#define bfin_read_CAN1_MB02_DATA1()		bfin_read16(CAN1_MB02_DATA1)
+#define bfin_write_CAN1_MB02_DATA1(val)		bfin_write16(CAN1_MB02_DATA1, val)
+#define bfin_read_CAN1_MB02_DATA2()		bfin_read16(CAN1_MB02_DATA2)
+#define bfin_write_CAN1_MB02_DATA2(val)		bfin_write16(CAN1_MB02_DATA2, val)
+#define bfin_read_CAN1_MB02_DATA3()		bfin_read16(CAN1_MB02_DATA3)
+#define bfin_write_CAN1_MB02_DATA3(val)		bfin_write16(CAN1_MB02_DATA3, val)
+#define bfin_read_CAN1_MB02_LENGTH()		bfin_read16(CAN1_MB02_LENGTH)
+#define bfin_write_CAN1_MB02_LENGTH(val)	bfin_write16(CAN1_MB02_LENGTH, val)
+#define bfin_read_CAN1_MB02_TIMESTAMP()		bfin_read16(CAN1_MB02_TIMESTAMP)
+#define bfin_write_CAN1_MB02_TIMESTAMP(val)	bfin_write16(CAN1_MB02_TIMESTAMP, val)
+#define bfin_read_CAN1_MB02_ID0()		bfin_read16(CAN1_MB02_ID0)
+#define bfin_write_CAN1_MB02_ID0(val)		bfin_write16(CAN1_MB02_ID0, val)
+#define bfin_read_CAN1_MB02_ID1()		bfin_read16(CAN1_MB02_ID1)
+#define bfin_write_CAN1_MB02_ID1(val)		bfin_write16(CAN1_MB02_ID1, val)
+#define bfin_read_CAN1_MB03_DATA0()		bfin_read16(CAN1_MB03_DATA0)
+#define bfin_write_CAN1_MB03_DATA0(val)		bfin_write16(CAN1_MB03_DATA0, val)
+#define bfin_read_CAN1_MB03_DATA1()		bfin_read16(CAN1_MB03_DATA1)
+#define bfin_write_CAN1_MB03_DATA1(val)		bfin_write16(CAN1_MB03_DATA1, val)
+#define bfin_read_CAN1_MB03_DATA2()		bfin_read16(CAN1_MB03_DATA2)
+#define bfin_write_CAN1_MB03_DATA2(val)		bfin_write16(CAN1_MB03_DATA2, val)
+#define bfin_read_CAN1_MB03_DATA3()		bfin_read16(CAN1_MB03_DATA3)
+#define bfin_write_CAN1_MB03_DATA3(val)		bfin_write16(CAN1_MB03_DATA3, val)
+#define bfin_read_CAN1_MB03_LENGTH()		bfin_read16(CAN1_MB03_LENGTH)
+#define bfin_write_CAN1_MB03_LENGTH(val)	bfin_write16(CAN1_MB03_LENGTH, val)
+#define bfin_read_CAN1_MB03_TIMESTAMP()		bfin_read16(CAN1_MB03_TIMESTAMP)
+#define bfin_write_CAN1_MB03_TIMESTAMP(val)	bfin_write16(CAN1_MB03_TIMESTAMP, val)
+#define bfin_read_CAN1_MB03_ID0()		bfin_read16(CAN1_MB03_ID0)
+#define bfin_write_CAN1_MB03_ID0(val)		bfin_write16(CAN1_MB03_ID0, val)
+#define bfin_read_CAN1_MB03_ID1()		bfin_read16(CAN1_MB03_ID1)
+#define bfin_write_CAN1_MB03_ID1(val)		bfin_write16(CAN1_MB03_ID1, val)
+#define bfin_read_CAN1_MB04_DATA0()		bfin_read16(CAN1_MB04_DATA0)
+#define bfin_write_CAN1_MB04_DATA0(val)		bfin_write16(CAN1_MB04_DATA0, val)
+#define bfin_read_CAN1_MB04_DATA1()		bfin_read16(CAN1_MB04_DATA1)
+#define bfin_write_CAN1_MB04_DATA1(val)		bfin_write16(CAN1_MB04_DATA1, val)
+#define bfin_read_CAN1_MB04_DATA2()		bfin_read16(CAN1_MB04_DATA2)
+#define bfin_write_CAN1_MB04_DATA2(val)		bfin_write16(CAN1_MB04_DATA2, val)
+#define bfin_read_CAN1_MB04_DATA3()		bfin_read16(CAN1_MB04_DATA3)
+#define bfin_write_CAN1_MB04_DATA3(val)		bfin_write16(CAN1_MB04_DATA3, val)
+#define bfin_read_CAN1_MB04_LENGTH()		bfin_read16(CAN1_MB04_LENGTH)
+#define bfin_write_CAN1_MB04_LENGTH(val)	bfin_write16(CAN1_MB04_LENGTH, val)
+#define bfin_read_CAN1_MB04_TIMESTAMP()		bfin_read16(CAN1_MB04_TIMESTAMP)
+#define bfin_write_CAN1_MB04_TIMESTAMP(val)	bfin_write16(CAN1_MB04_TIMESTAMP, val)
+#define bfin_read_CAN1_MB04_ID0()		bfin_read16(CAN1_MB04_ID0)
+#define bfin_write_CAN1_MB04_ID0(val)		bfin_write16(CAN1_MB04_ID0, val)
+#define bfin_read_CAN1_MB04_ID1()		bfin_read16(CAN1_MB04_ID1)
+#define bfin_write_CAN1_MB04_ID1(val)		bfin_write16(CAN1_MB04_ID1, val)
+#define bfin_read_CAN1_MB05_DATA0()		bfin_read16(CAN1_MB05_DATA0)
+#define bfin_write_CAN1_MB05_DATA0(val)		bfin_write16(CAN1_MB05_DATA0, val)
+#define bfin_read_CAN1_MB05_DATA1()		bfin_read16(CAN1_MB05_DATA1)
+#define bfin_write_CAN1_MB05_DATA1(val)		bfin_write16(CAN1_MB05_DATA1, val)
+#define bfin_read_CAN1_MB05_DATA2()		bfin_read16(CAN1_MB05_DATA2)
+#define bfin_write_CAN1_MB05_DATA2(val)		bfin_write16(CAN1_MB05_DATA2, val)
+#define bfin_read_CAN1_MB05_DATA3()		bfin_read16(CAN1_MB05_DATA3)
+#define bfin_write_CAN1_MB05_DATA3(val)		bfin_write16(CAN1_MB05_DATA3, val)
+#define bfin_read_CAN1_MB05_LENGTH()		bfin_read16(CAN1_MB05_LENGTH)
+#define bfin_write_CAN1_MB05_LENGTH(val)	bfin_write16(CAN1_MB05_LENGTH, val)
+#define bfin_read_CAN1_MB05_TIMESTAMP()		bfin_read16(CAN1_MB05_TIMESTAMP)
+#define bfin_write_CAN1_MB05_TIMESTAMP(val)	bfin_write16(CAN1_MB05_TIMESTAMP, val)
+#define bfin_read_CAN1_MB05_ID0()		bfin_read16(CAN1_MB05_ID0)
+#define bfin_write_CAN1_MB05_ID0(val)		bfin_write16(CAN1_MB05_ID0, val)
+#define bfin_read_CAN1_MB05_ID1()		bfin_read16(CAN1_MB05_ID1)
+#define bfin_write_CAN1_MB05_ID1(val)		bfin_write16(CAN1_MB05_ID1, val)
+#define bfin_read_CAN1_MB06_DATA0()		bfin_read16(CAN1_MB06_DATA0)
+#define bfin_write_CAN1_MB06_DATA0(val)		bfin_write16(CAN1_MB06_DATA0, val)
+#define bfin_read_CAN1_MB06_DATA1()		bfin_read16(CAN1_MB06_DATA1)
+#define bfin_write_CAN1_MB06_DATA1(val)		bfin_write16(CAN1_MB06_DATA1, val)
+#define bfin_read_CAN1_MB06_DATA2()		bfin_read16(CAN1_MB06_DATA2)
+#define bfin_write_CAN1_MB06_DATA2(val)		bfin_write16(CAN1_MB06_DATA2, val)
+#define bfin_read_CAN1_MB06_DATA3()		bfin_read16(CAN1_MB06_DATA3)
+#define bfin_write_CAN1_MB06_DATA3(val)		bfin_write16(CAN1_MB06_DATA3, val)
+#define bfin_read_CAN1_MB06_LENGTH()		bfin_read16(CAN1_MB06_LENGTH)
+#define bfin_write_CAN1_MB06_LENGTH(val)	bfin_write16(CAN1_MB06_LENGTH, val)
+#define bfin_read_CAN1_MB06_TIMESTAMP()		bfin_read16(CAN1_MB06_TIMESTAMP)
+#define bfin_write_CAN1_MB06_TIMESTAMP(val)	bfin_write16(CAN1_MB06_TIMESTAMP, val)
+#define bfin_read_CAN1_MB06_ID0()		bfin_read16(CAN1_MB06_ID0)
+#define bfin_write_CAN1_MB06_ID0(val)		bfin_write16(CAN1_MB06_ID0, val)
+#define bfin_read_CAN1_MB06_ID1()		bfin_read16(CAN1_MB06_ID1)
+#define bfin_write_CAN1_MB06_ID1(val)		bfin_write16(CAN1_MB06_ID1, val)
+#define bfin_read_CAN1_MB07_DATA0()		bfin_read16(CAN1_MB07_DATA0)
+#define bfin_write_CAN1_MB07_DATA0(val)		bfin_write16(CAN1_MB07_DATA0, val)
+#define bfin_read_CAN1_MB07_DATA1()		bfin_read16(CAN1_MB07_DATA1)
+#define bfin_write_CAN1_MB07_DATA1(val)		bfin_write16(CAN1_MB07_DATA1, val)
+#define bfin_read_CAN1_MB07_DATA2()		bfin_read16(CAN1_MB07_DATA2)
+#define bfin_write_CAN1_MB07_DATA2(val)		bfin_write16(CAN1_MB07_DATA2, val)
+#define bfin_read_CAN1_MB07_DATA3()		bfin_read16(CAN1_MB07_DATA3)
+#define bfin_write_CAN1_MB07_DATA3(val)		bfin_write16(CAN1_MB07_DATA3, val)
+#define bfin_read_CAN1_MB07_LENGTH()		bfin_read16(CAN1_MB07_LENGTH)
+#define bfin_write_CAN1_MB07_LENGTH(val)	bfin_write16(CAN1_MB07_LENGTH, val)
+#define bfin_read_CAN1_MB07_TIMESTAMP()		bfin_read16(CAN1_MB07_TIMESTAMP)
+#define bfin_write_CAN1_MB07_TIMESTAMP(val)	bfin_write16(CAN1_MB07_TIMESTAMP, val)
+#define bfin_read_CAN1_MB07_ID0()		bfin_read16(CAN1_MB07_ID0)
+#define bfin_write_CAN1_MB07_ID0(val)		bfin_write16(CAN1_MB07_ID0, val)
+#define bfin_read_CAN1_MB07_ID1()		bfin_read16(CAN1_MB07_ID1)
+#define bfin_write_CAN1_MB07_ID1(val)		bfin_write16(CAN1_MB07_ID1, val)
+#define bfin_read_CAN1_MB08_DATA0()		bfin_read16(CAN1_MB08_DATA0)
+#define bfin_write_CAN1_MB08_DATA0(val)		bfin_write16(CAN1_MB08_DATA0, val)
+#define bfin_read_CAN1_MB08_DATA1()		bfin_read16(CAN1_MB08_DATA1)
+#define bfin_write_CAN1_MB08_DATA1(val)		bfin_write16(CAN1_MB08_DATA1, val)
+#define bfin_read_CAN1_MB08_DATA2()		bfin_read16(CAN1_MB08_DATA2)
+#define bfin_write_CAN1_MB08_DATA2(val)		bfin_write16(CAN1_MB08_DATA2, val)
+#define bfin_read_CAN1_MB08_DATA3()		bfin_read16(CAN1_MB08_DATA3)
+#define bfin_write_CAN1_MB08_DATA3(val)		bfin_write16(CAN1_MB08_DATA3, val)
+#define bfin_read_CAN1_MB08_LENGTH()		bfin_read16(CAN1_MB08_LENGTH)
+#define bfin_write_CAN1_MB08_LENGTH(val)	bfin_write16(CAN1_MB08_LENGTH, val)
+#define bfin_read_CAN1_MB08_TIMESTAMP()		bfin_read16(CAN1_MB08_TIMESTAMP)
+#define bfin_write_CAN1_MB08_TIMESTAMP(val)	bfin_write16(CAN1_MB08_TIMESTAMP, val)
+#define bfin_read_CAN1_MB08_ID0()		bfin_read16(CAN1_MB08_ID0)
+#define bfin_write_CAN1_MB08_ID0(val)		bfin_write16(CAN1_MB08_ID0, val)
+#define bfin_read_CAN1_MB08_ID1()		bfin_read16(CAN1_MB08_ID1)
+#define bfin_write_CAN1_MB08_ID1(val)		bfin_write16(CAN1_MB08_ID1, val)
+#define bfin_read_CAN1_MB09_DATA0()		bfin_read16(CAN1_MB09_DATA0)
+#define bfin_write_CAN1_MB09_DATA0(val)		bfin_write16(CAN1_MB09_DATA0, val)
+#define bfin_read_CAN1_MB09_DATA1()		bfin_read16(CAN1_MB09_DATA1)
+#define bfin_write_CAN1_MB09_DATA1(val)		bfin_write16(CAN1_MB09_DATA1, val)
+#define bfin_read_CAN1_MB09_DATA2()		bfin_read16(CAN1_MB09_DATA2)
+#define bfin_write_CAN1_MB09_DATA2(val)		bfin_write16(CAN1_MB09_DATA2, val)
+#define bfin_read_CAN1_MB09_DATA3()		bfin_read16(CAN1_MB09_DATA3)
+#define bfin_write_CAN1_MB09_DATA3(val)		bfin_write16(CAN1_MB09_DATA3, val)
+#define bfin_read_CAN1_MB09_LENGTH()		bfin_read16(CAN1_MB09_LENGTH)
+#define bfin_write_CAN1_MB09_LENGTH(val)	bfin_write16(CAN1_MB09_LENGTH, val)
+#define bfin_read_CAN1_MB09_TIMESTAMP()		bfin_read16(CAN1_MB09_TIMESTAMP)
+#define bfin_write_CAN1_MB09_TIMESTAMP(val)	bfin_write16(CAN1_MB09_TIMESTAMP, val)
+#define bfin_read_CAN1_MB09_ID0()		bfin_read16(CAN1_MB09_ID0)
+#define bfin_write_CAN1_MB09_ID0(val)		bfin_write16(CAN1_MB09_ID0, val)
+#define bfin_read_CAN1_MB09_ID1()		bfin_read16(CAN1_MB09_ID1)
+#define bfin_write_CAN1_MB09_ID1(val)		bfin_write16(CAN1_MB09_ID1, val)
+#define bfin_read_CAN1_MB10_DATA0()		bfin_read16(CAN1_MB10_DATA0)
+#define bfin_write_CAN1_MB10_DATA0(val)		bfin_write16(CAN1_MB10_DATA0, val)
+#define bfin_read_CAN1_MB10_DATA1()		bfin_read16(CAN1_MB10_DATA1)
+#define bfin_write_CAN1_MB10_DATA1(val)		bfin_write16(CAN1_MB10_DATA1, val)
+#define bfin_read_CAN1_MB10_DATA2()		bfin_read16(CAN1_MB10_DATA2)
+#define bfin_write_CAN1_MB10_DATA2(val)		bfin_write16(CAN1_MB10_DATA2, val)
+#define bfin_read_CAN1_MB10_DATA3()		bfin_read16(CAN1_MB10_DATA3)
+#define bfin_write_CAN1_MB10_DATA3(val)		bfin_write16(CAN1_MB10_DATA3, val)
+#define bfin_read_CAN1_MB10_LENGTH()		bfin_read16(CAN1_MB10_LENGTH)
+#define bfin_write_CAN1_MB10_LENGTH(val)	bfin_write16(CAN1_MB10_LENGTH, val)
+#define bfin_read_CAN1_MB10_TIMESTAMP()		bfin_read16(CAN1_MB10_TIMESTAMP)
+#define bfin_write_CAN1_MB10_TIMESTAMP(val)	bfin_write16(CAN1_MB10_TIMESTAMP, val)
+#define bfin_read_CAN1_MB10_ID0()		bfin_read16(CAN1_MB10_ID0)
+#define bfin_write_CAN1_MB10_ID0(val)		bfin_write16(CAN1_MB10_ID0, val)
+#define bfin_read_CAN1_MB10_ID1()		bfin_read16(CAN1_MB10_ID1)
+#define bfin_write_CAN1_MB10_ID1(val)		bfin_write16(CAN1_MB10_ID1, val)
+#define bfin_read_CAN1_MB11_DATA0()		bfin_read16(CAN1_MB11_DATA0)
+#define bfin_write_CAN1_MB11_DATA0(val)		bfin_write16(CAN1_MB11_DATA0, val)
+#define bfin_read_CAN1_MB11_DATA1()		bfin_read16(CAN1_MB11_DATA1)
+#define bfin_write_CAN1_MB11_DATA1(val)		bfin_write16(CAN1_MB11_DATA1, val)
+#define bfin_read_CAN1_MB11_DATA2()		bfin_read16(CAN1_MB11_DATA2)
+#define bfin_write_CAN1_MB11_DATA2(val)		bfin_write16(CAN1_MB11_DATA2, val)
+#define bfin_read_CAN1_MB11_DATA3()		bfin_read16(CAN1_MB11_DATA3)
+#define bfin_write_CAN1_MB11_DATA3(val)		bfin_write16(CAN1_MB11_DATA3, val)
+#define bfin_read_CAN1_MB11_LENGTH()		bfin_read16(CAN1_MB11_LENGTH)
+#define bfin_write_CAN1_MB11_LENGTH(val)	bfin_write16(CAN1_MB11_LENGTH, val)
+#define bfin_read_CAN1_MB11_TIMESTAMP()		bfin_read16(CAN1_MB11_TIMESTAMP)
+#define bfin_write_CAN1_MB11_TIMESTAMP(val)	bfin_write16(CAN1_MB11_TIMESTAMP, val)
+#define bfin_read_CAN1_MB11_ID0()		bfin_read16(CAN1_MB11_ID0)
+#define bfin_write_CAN1_MB11_ID0(val)		bfin_write16(CAN1_MB11_ID0, val)
+#define bfin_read_CAN1_MB11_ID1()		bfin_read16(CAN1_MB11_ID1)
+#define bfin_write_CAN1_MB11_ID1(val)		bfin_write16(CAN1_MB11_ID1, val)
+#define bfin_read_CAN1_MB12_DATA0()		bfin_read16(CAN1_MB12_DATA0)
+#define bfin_write_CAN1_MB12_DATA0(val)		bfin_write16(CAN1_MB12_DATA0, val)
+#define bfin_read_CAN1_MB12_DATA1()		bfin_read16(CAN1_MB12_DATA1)
+#define bfin_write_CAN1_MB12_DATA1(val)		bfin_write16(CAN1_MB12_DATA1, val)
+#define bfin_read_CAN1_MB12_DATA2()		bfin_read16(CAN1_MB12_DATA2)
+#define bfin_write_CAN1_MB12_DATA2(val)		bfin_write16(CAN1_MB12_DATA2, val)
+#define bfin_read_CAN1_MB12_DATA3()		bfin_read16(CAN1_MB12_DATA3)
+#define bfin_write_CAN1_MB12_DATA3(val)		bfin_write16(CAN1_MB12_DATA3, val)
+#define bfin_read_CAN1_MB12_LENGTH()		bfin_read16(CAN1_MB12_LENGTH)
+#define bfin_write_CAN1_MB12_LENGTH(val)	bfin_write16(CAN1_MB12_LENGTH, val)
+#define bfin_read_CAN1_MB12_TIMESTAMP()		bfin_read16(CAN1_MB12_TIMESTAMP)
+#define bfin_write_CAN1_MB12_TIMESTAMP(val)	bfin_write16(CAN1_MB12_TIMESTAMP, val)
+#define bfin_read_CAN1_MB12_ID0()		bfin_read16(CAN1_MB12_ID0)
+#define bfin_write_CAN1_MB12_ID0(val)		bfin_write16(CAN1_MB12_ID0, val)
+#define bfin_read_CAN1_MB12_ID1()		bfin_read16(CAN1_MB12_ID1)
+#define bfin_write_CAN1_MB12_ID1(val)		bfin_write16(CAN1_MB12_ID1, val)
+#define bfin_read_CAN1_MB13_DATA0()		bfin_read16(CAN1_MB13_DATA0)
+#define bfin_write_CAN1_MB13_DATA0(val)		bfin_write16(CAN1_MB13_DATA0, val)
+#define bfin_read_CAN1_MB13_DATA1()		bfin_read16(CAN1_MB13_DATA1)
+#define bfin_write_CAN1_MB13_DATA1(val)		bfin_write16(CAN1_MB13_DATA1, val)
+#define bfin_read_CAN1_MB13_DATA2()		bfin_read16(CAN1_MB13_DATA2)
+#define bfin_write_CAN1_MB13_DATA2(val)		bfin_write16(CAN1_MB13_DATA2, val)
+#define bfin_read_CAN1_MB13_DATA3()		bfin_read16(CAN1_MB13_DATA3)
+#define bfin_write_CAN1_MB13_DATA3(val)		bfin_write16(CAN1_MB13_DATA3, val)
+#define bfin_read_CAN1_MB13_LENGTH()		bfin_read16(CAN1_MB13_LENGTH)
+#define bfin_write_CAN1_MB13_LENGTH(val)	bfin_write16(CAN1_MB13_LENGTH, val)
+#define bfin_read_CAN1_MB13_TIMESTAMP()		bfin_read16(CAN1_MB13_TIMESTAMP)
+#define bfin_write_CAN1_MB13_TIMESTAMP(val)	bfin_write16(CAN1_MB13_TIMESTAMP, val)
+#define bfin_read_CAN1_MB13_ID0()		bfin_read16(CAN1_MB13_ID0)
+#define bfin_write_CAN1_MB13_ID0(val)		bfin_write16(CAN1_MB13_ID0, val)
+#define bfin_read_CAN1_MB13_ID1()		bfin_read16(CAN1_MB13_ID1)
+#define bfin_write_CAN1_MB13_ID1(val)		bfin_write16(CAN1_MB13_ID1, val)
+#define bfin_read_CAN1_MB14_DATA0()		bfin_read16(CAN1_MB14_DATA0)
+#define bfin_write_CAN1_MB14_DATA0(val)		bfin_write16(CAN1_MB14_DATA0, val)
+#define bfin_read_CAN1_MB14_DATA1()		bfin_read16(CAN1_MB14_DATA1)
+#define bfin_write_CAN1_MB14_DATA1(val)		bfin_write16(CAN1_MB14_DATA1, val)
+#define bfin_read_CAN1_MB14_DATA2()		bfin_read16(CAN1_MB14_DATA2)
+#define bfin_write_CAN1_MB14_DATA2(val)		bfin_write16(CAN1_MB14_DATA2, val)
+#define bfin_read_CAN1_MB14_DATA3()		bfin_read16(CAN1_MB14_DATA3)
+#define bfin_write_CAN1_MB14_DATA3(val)		bfin_write16(CAN1_MB14_DATA3, val)
+#define bfin_read_CAN1_MB14_LENGTH()		bfin_read16(CAN1_MB14_LENGTH)
+#define bfin_write_CAN1_MB14_LENGTH(val)	bfin_write16(CAN1_MB14_LENGTH, val)
+#define bfin_read_CAN1_MB14_TIMESTAMP()		bfin_read16(CAN1_MB14_TIMESTAMP)
+#define bfin_write_CAN1_MB14_TIMESTAMP(val)	bfin_write16(CAN1_MB14_TIMESTAMP, val)
+#define bfin_read_CAN1_MB14_ID0()		bfin_read16(CAN1_MB14_ID0)
+#define bfin_write_CAN1_MB14_ID0(val)		bfin_write16(CAN1_MB14_ID0, val)
+#define bfin_read_CAN1_MB14_ID1()		bfin_read16(CAN1_MB14_ID1)
+#define bfin_write_CAN1_MB14_ID1(val)		bfin_write16(CAN1_MB14_ID1, val)
+#define bfin_read_CAN1_MB15_DATA0()		bfin_read16(CAN1_MB15_DATA0)
+#define bfin_write_CAN1_MB15_DATA0(val)		bfin_write16(CAN1_MB15_DATA0, val)
+#define bfin_read_CAN1_MB15_DATA1()		bfin_read16(CAN1_MB15_DATA1)
+#define bfin_write_CAN1_MB15_DATA1(val)		bfin_write16(CAN1_MB15_DATA1, val)
+#define bfin_read_CAN1_MB15_DATA2()		bfin_read16(CAN1_MB15_DATA2)
+#define bfin_write_CAN1_MB15_DATA2(val)		bfin_write16(CAN1_MB15_DATA2, val)
+#define bfin_read_CAN1_MB15_DATA3()		bfin_read16(CAN1_MB15_DATA3)
+#define bfin_write_CAN1_MB15_DATA3(val)		bfin_write16(CAN1_MB15_DATA3, val)
+#define bfin_read_CAN1_MB15_LENGTH()		bfin_read16(CAN1_MB15_LENGTH)
+#define bfin_write_CAN1_MB15_LENGTH(val)	bfin_write16(CAN1_MB15_LENGTH, val)
+#define bfin_read_CAN1_MB15_TIMESTAMP()		bfin_read16(CAN1_MB15_TIMESTAMP)
+#define bfin_write_CAN1_MB15_TIMESTAMP(val)	bfin_write16(CAN1_MB15_TIMESTAMP, val)
+#define bfin_read_CAN1_MB15_ID0()		bfin_read16(CAN1_MB15_ID0)
+#define bfin_write_CAN1_MB15_ID0(val)		bfin_write16(CAN1_MB15_ID0, val)
+#define bfin_read_CAN1_MB15_ID1()		bfin_read16(CAN1_MB15_ID1)
+#define bfin_write_CAN1_MB15_ID1(val)		bfin_write16(CAN1_MB15_ID1, val)
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define bfin_read_CAN1_MB16_DATA0()		bfin_read16(CAN1_MB16_DATA0)
+#define bfin_write_CAN1_MB16_DATA0(val)		bfin_write16(CAN1_MB16_DATA0, val)
+#define bfin_read_CAN1_MB16_DATA1()		bfin_read16(CAN1_MB16_DATA1)
+#define bfin_write_CAN1_MB16_DATA1(val)		bfin_write16(CAN1_MB16_DATA1, val)
+#define bfin_read_CAN1_MB16_DATA2()		bfin_read16(CAN1_MB16_DATA2)
+#define bfin_write_CAN1_MB16_DATA2(val)		bfin_write16(CAN1_MB16_DATA2, val)
+#define bfin_read_CAN1_MB16_DATA3()		bfin_read16(CAN1_MB16_DATA3)
+#define bfin_write_CAN1_MB16_DATA3(val)		bfin_write16(CAN1_MB16_DATA3, val)
+#define bfin_read_CAN1_MB16_LENGTH()		bfin_read16(CAN1_MB16_LENGTH)
+#define bfin_write_CAN1_MB16_LENGTH(val)	bfin_write16(CAN1_MB16_LENGTH, val)
+#define bfin_read_CAN1_MB16_TIMESTAMP()		bfin_read16(CAN1_MB16_TIMESTAMP)
+#define bfin_write_CAN1_MB16_TIMESTAMP(val)	bfin_write16(CAN1_MB16_TIMESTAMP, val)
+#define bfin_read_CAN1_MB16_ID0()		bfin_read16(CAN1_MB16_ID0)
+#define bfin_write_CAN1_MB16_ID0(val)		bfin_write16(CAN1_MB16_ID0, val)
+#define bfin_read_CAN1_MB16_ID1()		bfin_read16(CAN1_MB16_ID1)
+#define bfin_write_CAN1_MB16_ID1(val)		bfin_write16(CAN1_MB16_ID1, val)
+#define bfin_read_CAN1_MB17_DATA0()		bfin_read16(CAN1_MB17_DATA0)
+#define bfin_write_CAN1_MB17_DATA0(val)		bfin_write16(CAN1_MB17_DATA0, val)
+#define bfin_read_CAN1_MB17_DATA1()		bfin_read16(CAN1_MB17_DATA1)
+#define bfin_write_CAN1_MB17_DATA1(val)		bfin_write16(CAN1_MB17_DATA1, val)
+#define bfin_read_CAN1_MB17_DATA2()		bfin_read16(CAN1_MB17_DATA2)
+#define bfin_write_CAN1_MB17_DATA2(val)		bfin_write16(CAN1_MB17_DATA2, val)
+#define bfin_read_CAN1_MB17_DATA3()		bfin_read16(CAN1_MB17_DATA3)
+#define bfin_write_CAN1_MB17_DATA3(val)		bfin_write16(CAN1_MB17_DATA3, val)
+#define bfin_read_CAN1_MB17_LENGTH()		bfin_read16(CAN1_MB17_LENGTH)
+#define bfin_write_CAN1_MB17_LENGTH(val)	bfin_write16(CAN1_MB17_LENGTH, val)
+#define bfin_read_CAN1_MB17_TIMESTAMP()		bfin_read16(CAN1_MB17_TIMESTAMP)
+#define bfin_write_CAN1_MB17_TIMESTAMP(val)	bfin_write16(CAN1_MB17_TIMESTAMP, val)
+#define bfin_read_CAN1_MB17_ID0()		bfin_read16(CAN1_MB17_ID0)
+#define bfin_write_CAN1_MB17_ID0(val)		bfin_write16(CAN1_MB17_ID0, val)
+#define bfin_read_CAN1_MB17_ID1()		bfin_read16(CAN1_MB17_ID1)
+#define bfin_write_CAN1_MB17_ID1(val)		bfin_write16(CAN1_MB17_ID1, val)
+#define bfin_read_CAN1_MB18_DATA0()		bfin_read16(CAN1_MB18_DATA0)
+#define bfin_write_CAN1_MB18_DATA0(val)		bfin_write16(CAN1_MB18_DATA0, val)
+#define bfin_read_CAN1_MB18_DATA1()		bfin_read16(CAN1_MB18_DATA1)
+#define bfin_write_CAN1_MB18_DATA1(val)		bfin_write16(CAN1_MB18_DATA1, val)
+#define bfin_read_CAN1_MB18_DATA2()		bfin_read16(CAN1_MB18_DATA2)
+#define bfin_write_CAN1_MB18_DATA2(val)		bfin_write16(CAN1_MB18_DATA2, val)
+#define bfin_read_CAN1_MB18_DATA3()		bfin_read16(CAN1_MB18_DATA3)
+#define bfin_write_CAN1_MB18_DATA3(val)		bfin_write16(CAN1_MB18_DATA3, val)
+#define bfin_read_CAN1_MB18_LENGTH()		bfin_read16(CAN1_MB18_LENGTH)
+#define bfin_write_CAN1_MB18_LENGTH(val)	bfin_write16(CAN1_MB18_LENGTH, val)
+#define bfin_read_CAN1_MB18_TIMESTAMP()		bfin_read16(CAN1_MB18_TIMESTAMP)
+#define bfin_write_CAN1_MB18_TIMESTAMP(val)	bfin_write16(CAN1_MB18_TIMESTAMP, val)
+#define bfin_read_CAN1_MB18_ID0()		bfin_read16(CAN1_MB18_ID0)
+#define bfin_write_CAN1_MB18_ID0(val)		bfin_write16(CAN1_MB18_ID0, val)
+#define bfin_read_CAN1_MB18_ID1()		bfin_read16(CAN1_MB18_ID1)
+#define bfin_write_CAN1_MB18_ID1(val)		bfin_write16(CAN1_MB18_ID1, val)
+#define bfin_read_CAN1_MB19_DATA0()		bfin_read16(CAN1_MB19_DATA0)
+#define bfin_write_CAN1_MB19_DATA0(val)		bfin_write16(CAN1_MB19_DATA0, val)
+#define bfin_read_CAN1_MB19_DATA1()		bfin_read16(CAN1_MB19_DATA1)
+#define bfin_write_CAN1_MB19_DATA1(val)		bfin_write16(CAN1_MB19_DATA1, val)
+#define bfin_read_CAN1_MB19_DATA2()		bfin_read16(CAN1_MB19_DATA2)
+#define bfin_write_CAN1_MB19_DATA2(val)		bfin_write16(CAN1_MB19_DATA2, val)
+#define bfin_read_CAN1_MB19_DATA3()		bfin_read16(CAN1_MB19_DATA3)
+#define bfin_write_CAN1_MB19_DATA3(val)		bfin_write16(CAN1_MB19_DATA3, val)
+#define bfin_read_CAN1_MB19_LENGTH()		bfin_read16(CAN1_MB19_LENGTH)
+#define bfin_write_CAN1_MB19_LENGTH(val)	bfin_write16(CAN1_MB19_LENGTH, val)
+#define bfin_read_CAN1_MB19_TIMESTAMP()		bfin_read16(CAN1_MB19_TIMESTAMP)
+#define bfin_write_CAN1_MB19_TIMESTAMP(val)	bfin_write16(CAN1_MB19_TIMESTAMP, val)
+#define bfin_read_CAN1_MB19_ID0()		bfin_read16(CAN1_MB19_ID0)
+#define bfin_write_CAN1_MB19_ID0(val)		bfin_write16(CAN1_MB19_ID0, val)
+#define bfin_read_CAN1_MB19_ID1()		bfin_read16(CAN1_MB19_ID1)
+#define bfin_write_CAN1_MB19_ID1(val)		bfin_write16(CAN1_MB19_ID1, val)
+#define bfin_read_CAN1_MB20_DATA0()		bfin_read16(CAN1_MB20_DATA0)
+#define bfin_write_CAN1_MB20_DATA0(val)		bfin_write16(CAN1_MB20_DATA0, val)
+#define bfin_read_CAN1_MB20_DATA1()		bfin_read16(CAN1_MB20_DATA1)
+#define bfin_write_CAN1_MB20_DATA1(val)		bfin_write16(CAN1_MB20_DATA1, val)
+#define bfin_read_CAN1_MB20_DATA2()		bfin_read16(CAN1_MB20_DATA2)
+#define bfin_write_CAN1_MB20_DATA2(val)		bfin_write16(CAN1_MB20_DATA2, val)
+#define bfin_read_CAN1_MB20_DATA3()		bfin_read16(CAN1_MB20_DATA3)
+#define bfin_write_CAN1_MB20_DATA3(val)		bfin_write16(CAN1_MB20_DATA3, val)
+#define bfin_read_CAN1_MB20_LENGTH()		bfin_read16(CAN1_MB20_LENGTH)
+#define bfin_write_CAN1_MB20_LENGTH(val)	bfin_write16(CAN1_MB20_LENGTH, val)
+#define bfin_read_CAN1_MB20_TIMESTAMP()		bfin_read16(CAN1_MB20_TIMESTAMP)
+#define bfin_write_CAN1_MB20_TIMESTAMP(val)	bfin_write16(CAN1_MB20_TIMESTAMP, val)
+#define bfin_read_CAN1_MB20_ID0()		bfin_read16(CAN1_MB20_ID0)
+#define bfin_write_CAN1_MB20_ID0(val)		bfin_write16(CAN1_MB20_ID0, val)
+#define bfin_read_CAN1_MB20_ID1()		bfin_read16(CAN1_MB20_ID1)
+#define bfin_write_CAN1_MB20_ID1(val)		bfin_write16(CAN1_MB20_ID1, val)
+#define bfin_read_CAN1_MB21_DATA0()		bfin_read16(CAN1_MB21_DATA0)
+#define bfin_write_CAN1_MB21_DATA0(val)		bfin_write16(CAN1_MB21_DATA0, val)
+#define bfin_read_CAN1_MB21_DATA1()		bfin_read16(CAN1_MB21_DATA1)
+#define bfin_write_CAN1_MB21_DATA1(val)		bfin_write16(CAN1_MB21_DATA1, val)
+#define bfin_read_CAN1_MB21_DATA2()		bfin_read16(CAN1_MB21_DATA2)
+#define bfin_write_CAN1_MB21_DATA2(val)		bfin_write16(CAN1_MB21_DATA2, val)
+#define bfin_read_CAN1_MB21_DATA3()		bfin_read16(CAN1_MB21_DATA3)
+#define bfin_write_CAN1_MB21_DATA3(val)		bfin_write16(CAN1_MB21_DATA3, val)
+#define bfin_read_CAN1_MB21_LENGTH()		bfin_read16(CAN1_MB21_LENGTH)
+#define bfin_write_CAN1_MB21_LENGTH(val)	bfin_write16(CAN1_MB21_LENGTH, val)
+#define bfin_read_CAN1_MB21_TIMESTAMP()		bfin_read16(CAN1_MB21_TIMESTAMP)
+#define bfin_write_CAN1_MB21_TIMESTAMP(val)	bfin_write16(CAN1_MB21_TIMESTAMP, val)
+#define bfin_read_CAN1_MB21_ID0()		bfin_read16(CAN1_MB21_ID0)
+#define bfin_write_CAN1_MB21_ID0(val)		bfin_write16(CAN1_MB21_ID0, val)
+#define bfin_read_CAN1_MB21_ID1()		bfin_read16(CAN1_MB21_ID1)
+#define bfin_write_CAN1_MB21_ID1(val)		bfin_write16(CAN1_MB21_ID1, val)
+#define bfin_read_CAN1_MB22_DATA0()		bfin_read16(CAN1_MB22_DATA0)
+#define bfin_write_CAN1_MB22_DATA0(val)		bfin_write16(CAN1_MB22_DATA0, val)
+#define bfin_read_CAN1_MB22_DATA1()		bfin_read16(CAN1_MB22_DATA1)
+#define bfin_write_CAN1_MB22_DATA1(val)		bfin_write16(CAN1_MB22_DATA1, val)
+#define bfin_read_CAN1_MB22_DATA2()		bfin_read16(CAN1_MB22_DATA2)
+#define bfin_write_CAN1_MB22_DATA2(val)		bfin_write16(CAN1_MB22_DATA2, val)
+#define bfin_read_CAN1_MB22_DATA3()		bfin_read16(CAN1_MB22_DATA3)
+#define bfin_write_CAN1_MB22_DATA3(val)		bfin_write16(CAN1_MB22_DATA3, val)
+#define bfin_read_CAN1_MB22_LENGTH()		bfin_read16(CAN1_MB22_LENGTH)
+#define bfin_write_CAN1_MB22_LENGTH(val)	bfin_write16(CAN1_MB22_LENGTH, val)
+#define bfin_read_CAN1_MB22_TIMESTAMP()		bfin_read16(CAN1_MB22_TIMESTAMP)
+#define bfin_write_CAN1_MB22_TIMESTAMP(val)	bfin_write16(CAN1_MB22_TIMESTAMP, val)
+#define bfin_read_CAN1_MB22_ID0()		bfin_read16(CAN1_MB22_ID0)
+#define bfin_write_CAN1_MB22_ID0(val)		bfin_write16(CAN1_MB22_ID0, val)
+#define bfin_read_CAN1_MB22_ID1()		bfin_read16(CAN1_MB22_ID1)
+#define bfin_write_CAN1_MB22_ID1(val)		bfin_write16(CAN1_MB22_ID1, val)
+#define bfin_read_CAN1_MB23_DATA0()		bfin_read16(CAN1_MB23_DATA0)
+#define bfin_write_CAN1_MB23_DATA0(val)		bfin_write16(CAN1_MB23_DATA0, val)
+#define bfin_read_CAN1_MB23_DATA1()		bfin_read16(CAN1_MB23_DATA1)
+#define bfin_write_CAN1_MB23_DATA1(val)		bfin_write16(CAN1_MB23_DATA1, val)
+#define bfin_read_CAN1_MB23_DATA2()		bfin_read16(CAN1_MB23_DATA2)
+#define bfin_write_CAN1_MB23_DATA2(val)		bfin_write16(CAN1_MB23_DATA2, val)
+#define bfin_read_CAN1_MB23_DATA3()		bfin_read16(CAN1_MB23_DATA3)
+#define bfin_write_CAN1_MB23_DATA3(val)		bfin_write16(CAN1_MB23_DATA3, val)
+#define bfin_read_CAN1_MB23_LENGTH()		bfin_read16(CAN1_MB23_LENGTH)
+#define bfin_write_CAN1_MB23_LENGTH(val)	bfin_write16(CAN1_MB23_LENGTH, val)
+#define bfin_read_CAN1_MB23_TIMESTAMP()		bfin_read16(CAN1_MB23_TIMESTAMP)
+#define bfin_write_CAN1_MB23_TIMESTAMP(val)	bfin_write16(CAN1_MB23_TIMESTAMP, val)
+#define bfin_read_CAN1_MB23_ID0()		bfin_read16(CAN1_MB23_ID0)
+#define bfin_write_CAN1_MB23_ID0(val)		bfin_write16(CAN1_MB23_ID0, val)
+#define bfin_read_CAN1_MB23_ID1()		bfin_read16(CAN1_MB23_ID1)
+#define bfin_write_CAN1_MB23_ID1(val)		bfin_write16(CAN1_MB23_ID1, val)
+#define bfin_read_CAN1_MB24_DATA0()		bfin_read16(CAN1_MB24_DATA0)
+#define bfin_write_CAN1_MB24_DATA0(val)		bfin_write16(CAN1_MB24_DATA0, val)
+#define bfin_read_CAN1_MB24_DATA1()		bfin_read16(CAN1_MB24_DATA1)
+#define bfin_write_CAN1_MB24_DATA1(val)		bfin_write16(CAN1_MB24_DATA1, val)
+#define bfin_read_CAN1_MB24_DATA2()		bfin_read16(CAN1_MB24_DATA2)
+#define bfin_write_CAN1_MB24_DATA2(val)		bfin_write16(CAN1_MB24_DATA2, val)
+#define bfin_read_CAN1_MB24_DATA3()		bfin_read16(CAN1_MB24_DATA3)
+#define bfin_write_CAN1_MB24_DATA3(val)		bfin_write16(CAN1_MB24_DATA3, val)
+#define bfin_read_CAN1_MB24_LENGTH()		bfin_read16(CAN1_MB24_LENGTH)
+#define bfin_write_CAN1_MB24_LENGTH(val)	bfin_write16(CAN1_MB24_LENGTH, val)
+#define bfin_read_CAN1_MB24_TIMESTAMP()		bfin_read16(CAN1_MB24_TIMESTAMP)
+#define bfin_write_CAN1_MB24_TIMESTAMP(val)	bfin_write16(CAN1_MB24_TIMESTAMP, val)
+#define bfin_read_CAN1_MB24_ID0()		bfin_read16(CAN1_MB24_ID0)
+#define bfin_write_CAN1_MB24_ID0(val)		bfin_write16(CAN1_MB24_ID0, val)
+#define bfin_read_CAN1_MB24_ID1()		bfin_read16(CAN1_MB24_ID1)
+#define bfin_write_CAN1_MB24_ID1(val)		bfin_write16(CAN1_MB24_ID1, val)
+#define bfin_read_CAN1_MB25_DATA0()		bfin_read16(CAN1_MB25_DATA0)
+#define bfin_write_CAN1_MB25_DATA0(val)		bfin_write16(CAN1_MB25_DATA0, val)
+#define bfin_read_CAN1_MB25_DATA1()		bfin_read16(CAN1_MB25_DATA1)
+#define bfin_write_CAN1_MB25_DATA1(val)		bfin_write16(CAN1_MB25_DATA1, val)
+#define bfin_read_CAN1_MB25_DATA2()		bfin_read16(CAN1_MB25_DATA2)
+#define bfin_write_CAN1_MB25_DATA2(val)		bfin_write16(CAN1_MB25_DATA2, val)
+#define bfin_read_CAN1_MB25_DATA3()		bfin_read16(CAN1_MB25_DATA3)
+#define bfin_write_CAN1_MB25_DATA3(val)		bfin_write16(CAN1_MB25_DATA3, val)
+#define bfin_read_CAN1_MB25_LENGTH()		bfin_read16(CAN1_MB25_LENGTH)
+#define bfin_write_CAN1_MB25_LENGTH(val)	bfin_write16(CAN1_MB25_LENGTH, val)
+#define bfin_read_CAN1_MB25_TIMESTAMP()		bfin_read16(CAN1_MB25_TIMESTAMP)
+#define bfin_write_CAN1_MB25_TIMESTAMP(val)	bfin_write16(CAN1_MB25_TIMESTAMP, val)
+#define bfin_read_CAN1_MB25_ID0()		bfin_read16(CAN1_MB25_ID0)
+#define bfin_write_CAN1_MB25_ID0(val)		bfin_write16(CAN1_MB25_ID0, val)
+#define bfin_read_CAN1_MB25_ID1()		bfin_read16(CAN1_MB25_ID1)
+#define bfin_write_CAN1_MB25_ID1(val)		bfin_write16(CAN1_MB25_ID1, val)
+#define bfin_read_CAN1_MB26_DATA0()		bfin_read16(CAN1_MB26_DATA0)
+#define bfin_write_CAN1_MB26_DATA0(val)		bfin_write16(CAN1_MB26_DATA0, val)
+#define bfin_read_CAN1_MB26_DATA1()		bfin_read16(CAN1_MB26_DATA1)
+#define bfin_write_CAN1_MB26_DATA1(val)		bfin_write16(CAN1_MB26_DATA1, val)
+#define bfin_read_CAN1_MB26_DATA2()		bfin_read16(CAN1_MB26_DATA2)
+#define bfin_write_CAN1_MB26_DATA2(val)		bfin_write16(CAN1_MB26_DATA2, val)
+#define bfin_read_CAN1_MB26_DATA3()		bfin_read16(CAN1_MB26_DATA3)
+#define bfin_write_CAN1_MB26_DATA3(val)		bfin_write16(CAN1_MB26_DATA3, val)
+#define bfin_read_CAN1_MB26_LENGTH()		bfin_read16(CAN1_MB26_LENGTH)
+#define bfin_write_CAN1_MB26_LENGTH(val)	bfin_write16(CAN1_MB26_LENGTH, val)
+#define bfin_read_CAN1_MB26_TIMESTAMP()		bfin_read16(CAN1_MB26_TIMESTAMP)
+#define bfin_write_CAN1_MB26_TIMESTAMP(val)	bfin_write16(CAN1_MB26_TIMESTAMP, val)
+#define bfin_read_CAN1_MB26_ID0()		bfin_read16(CAN1_MB26_ID0)
+#define bfin_write_CAN1_MB26_ID0(val)		bfin_write16(CAN1_MB26_ID0, val)
+#define bfin_read_CAN1_MB26_ID1()		bfin_read16(CAN1_MB26_ID1)
+#define bfin_write_CAN1_MB26_ID1(val)		bfin_write16(CAN1_MB26_ID1, val)
+#define bfin_read_CAN1_MB27_DATA0()		bfin_read16(CAN1_MB27_DATA0)
+#define bfin_write_CAN1_MB27_DATA0(val)		bfin_write16(CAN1_MB27_DATA0, val)
+#define bfin_read_CAN1_MB27_DATA1()		bfin_read16(CAN1_MB27_DATA1)
+#define bfin_write_CAN1_MB27_DATA1(val)		bfin_write16(CAN1_MB27_DATA1, val)
+#define bfin_read_CAN1_MB27_DATA2()		bfin_read16(CAN1_MB27_DATA2)
+#define bfin_write_CAN1_MB27_DATA2(val)		bfin_write16(CAN1_MB27_DATA2, val)
+#define bfin_read_CAN1_MB27_DATA3()		bfin_read16(CAN1_MB27_DATA3)
+#define bfin_write_CAN1_MB27_DATA3(val)		bfin_write16(CAN1_MB27_DATA3, val)
+#define bfin_read_CAN1_MB27_LENGTH()		bfin_read16(CAN1_MB27_LENGTH)
+#define bfin_write_CAN1_MB27_LENGTH(val)	bfin_write16(CAN1_MB27_LENGTH, val)
+#define bfin_read_CAN1_MB27_TIMESTAMP()		bfin_read16(CAN1_MB27_TIMESTAMP)
+#define bfin_write_CAN1_MB27_TIMESTAMP(val)	bfin_write16(CAN1_MB27_TIMESTAMP, val)
+#define bfin_read_CAN1_MB27_ID0()		bfin_read16(CAN1_MB27_ID0)
+#define bfin_write_CAN1_MB27_ID0(val)		bfin_write16(CAN1_MB27_ID0, val)
+#define bfin_read_CAN1_MB27_ID1()		bfin_read16(CAN1_MB27_ID1)
+#define bfin_write_CAN1_MB27_ID1(val)		bfin_write16(CAN1_MB27_ID1, val)
+#define bfin_read_CAN1_MB28_DATA0()		bfin_read16(CAN1_MB28_DATA0)
+#define bfin_write_CAN1_MB28_DATA0(val)		bfin_write16(CAN1_MB28_DATA0, val)
+#define bfin_read_CAN1_MB28_DATA1()		bfin_read16(CAN1_MB28_DATA1)
+#define bfin_write_CAN1_MB28_DATA1(val)		bfin_write16(CAN1_MB28_DATA1, val)
+#define bfin_read_CAN1_MB28_DATA2()		bfin_read16(CAN1_MB28_DATA2)
+#define bfin_write_CAN1_MB28_DATA2(val)		bfin_write16(CAN1_MB28_DATA2, val)
+#define bfin_read_CAN1_MB28_DATA3()		bfin_read16(CAN1_MB28_DATA3)
+#define bfin_write_CAN1_MB28_DATA3(val)		bfin_write16(CAN1_MB28_DATA3, val)
+#define bfin_read_CAN1_MB28_LENGTH()		bfin_read16(CAN1_MB28_LENGTH)
+#define bfin_write_CAN1_MB28_LENGTH(val)	bfin_write16(CAN1_MB28_LENGTH, val)
+#define bfin_read_CAN1_MB28_TIMESTAMP()		bfin_read16(CAN1_MB28_TIMESTAMP)
+#define bfin_write_CAN1_MB28_TIMESTAMP(val)	bfin_write16(CAN1_MB28_TIMESTAMP, val)
+#define bfin_read_CAN1_MB28_ID0()		bfin_read16(CAN1_MB28_ID0)
+#define bfin_write_CAN1_MB28_ID0(val)		bfin_write16(CAN1_MB28_ID0, val)
+#define bfin_read_CAN1_MB28_ID1()		bfin_read16(CAN1_MB28_ID1)
+#define bfin_write_CAN1_MB28_ID1(val)		bfin_write16(CAN1_MB28_ID1, val)
+#define bfin_read_CAN1_MB29_DATA0()		bfin_read16(CAN1_MB29_DATA0)
+#define bfin_write_CAN1_MB29_DATA0(val)		bfin_write16(CAN1_MB29_DATA0, val)
+#define bfin_read_CAN1_MB29_DATA1()		bfin_read16(CAN1_MB29_DATA1)
+#define bfin_write_CAN1_MB29_DATA1(val)		bfin_write16(CAN1_MB29_DATA1, val)
+#define bfin_read_CAN1_MB29_DATA2()		bfin_read16(CAN1_MB29_DATA2)
+#define bfin_write_CAN1_MB29_DATA2(val)		bfin_write16(CAN1_MB29_DATA2, val)
+#define bfin_read_CAN1_MB29_DATA3()		bfin_read16(CAN1_MB29_DATA3)
+#define bfin_write_CAN1_MB29_DATA3(val)		bfin_write16(CAN1_MB29_DATA3, val)
+#define bfin_read_CAN1_MB29_LENGTH()		bfin_read16(CAN1_MB29_LENGTH)
+#define bfin_write_CAN1_MB29_LENGTH(val)	bfin_write16(CAN1_MB29_LENGTH, val)
+#define bfin_read_CAN1_MB29_TIMESTAMP()		bfin_read16(CAN1_MB29_TIMESTAMP)
+#define bfin_write_CAN1_MB29_TIMESTAMP(val)	bfin_write16(CAN1_MB29_TIMESTAMP, val)
+#define bfin_read_CAN1_MB29_ID0()		bfin_read16(CAN1_MB29_ID0)
+#define bfin_write_CAN1_MB29_ID0(val)		bfin_write16(CAN1_MB29_ID0, val)
+#define bfin_read_CAN1_MB29_ID1()		bfin_read16(CAN1_MB29_ID1)
+#define bfin_write_CAN1_MB29_ID1(val)		bfin_write16(CAN1_MB29_ID1, val)
+#define bfin_read_CAN1_MB30_DATA0()		bfin_read16(CAN1_MB30_DATA0)
+#define bfin_write_CAN1_MB30_DATA0(val)		bfin_write16(CAN1_MB30_DATA0, val)
+#define bfin_read_CAN1_MB30_DATA1()		bfin_read16(CAN1_MB30_DATA1)
+#define bfin_write_CAN1_MB30_DATA1(val)		bfin_write16(CAN1_MB30_DATA1, val)
+#define bfin_read_CAN1_MB30_DATA2()		bfin_read16(CAN1_MB30_DATA2)
+#define bfin_write_CAN1_MB30_DATA2(val)		bfin_write16(CAN1_MB30_DATA2, val)
+#define bfin_read_CAN1_MB30_DATA3()		bfin_read16(CAN1_MB30_DATA3)
+#define bfin_write_CAN1_MB30_DATA3(val)		bfin_write16(CAN1_MB30_DATA3, val)
+#define bfin_read_CAN1_MB30_LENGTH()		bfin_read16(CAN1_MB30_LENGTH)
+#define bfin_write_CAN1_MB30_LENGTH(val)	bfin_write16(CAN1_MB30_LENGTH, val)
+#define bfin_read_CAN1_MB30_TIMESTAMP()		bfin_read16(CAN1_MB30_TIMESTAMP)
+#define bfin_write_CAN1_MB30_TIMESTAMP(val)	bfin_write16(CAN1_MB30_TIMESTAMP, val)
+#define bfin_read_CAN1_MB30_ID0()		bfin_read16(CAN1_MB30_ID0)
+#define bfin_write_CAN1_MB30_ID0(val)		bfin_write16(CAN1_MB30_ID0, val)
+#define bfin_read_CAN1_MB30_ID1()		bfin_read16(CAN1_MB30_ID1)
+#define bfin_write_CAN1_MB30_ID1(val)		bfin_write16(CAN1_MB30_ID1, val)
+#define bfin_read_CAN1_MB31_DATA0()		bfin_read16(CAN1_MB31_DATA0)
+#define bfin_write_CAN1_MB31_DATA0(val)		bfin_write16(CAN1_MB31_DATA0, val)
+#define bfin_read_CAN1_MB31_DATA1()		bfin_read16(CAN1_MB31_DATA1)
+#define bfin_write_CAN1_MB31_DATA1(val)		bfin_write16(CAN1_MB31_DATA1, val)
+#define bfin_read_CAN1_MB31_DATA2()		bfin_read16(CAN1_MB31_DATA2)
+#define bfin_write_CAN1_MB31_DATA2(val)		bfin_write16(CAN1_MB31_DATA2, val)
+#define bfin_read_CAN1_MB31_DATA3()		bfin_read16(CAN1_MB31_DATA3)
+#define bfin_write_CAN1_MB31_DATA3(val)		bfin_write16(CAN1_MB31_DATA3, val)
+#define bfin_read_CAN1_MB31_LENGTH()		bfin_read16(CAN1_MB31_LENGTH)
+#define bfin_write_CAN1_MB31_LENGTH(val)	bfin_write16(CAN1_MB31_LENGTH, val)
+#define bfin_read_CAN1_MB31_TIMESTAMP()		bfin_read16(CAN1_MB31_TIMESTAMP)
+#define bfin_write_CAN1_MB31_TIMESTAMP(val)	bfin_write16(CAN1_MB31_TIMESTAMP, val)
+#define bfin_read_CAN1_MB31_ID0()		bfin_read16(CAN1_MB31_ID0)
+#define bfin_write_CAN1_MB31_ID0(val)		bfin_write16(CAN1_MB31_ID0, val)
+#define bfin_read_CAN1_MB31_ID1()		bfin_read16(CAN1_MB31_ID1)
+#define bfin_write_CAN1_MB31_ID1(val)		bfin_write16(CAN1_MB31_ID1, val)
+
+/* ATAPI Registers */
+
+#define bfin_read_ATAPI_CONTROL()		bfin_read16(ATAPI_CONTROL)
+#define bfin_write_ATAPI_CONTROL(val)		bfin_write16(ATAPI_CONTROL, val)
+#define bfin_read_ATAPI_STATUS()		bfin_read16(ATAPI_STATUS)
+#define bfin_write_ATAPI_STATUS(val)		bfin_write16(ATAPI_STATUS, val)
+#define bfin_read_ATAPI_DEV_ADDR()		bfin_read16(ATAPI_DEV_ADDR)
+#define bfin_write_ATAPI_DEV_ADDR(val)		bfin_write16(ATAPI_DEV_ADDR, val)
+#define bfin_read_ATAPI_DEV_TXBUF()		bfin_read16(ATAPI_DEV_TXBUF)
+#define bfin_write_ATAPI_DEV_TXBUF(val)		bfin_write16(ATAPI_DEV_TXBUF, val)
+#define bfin_read_ATAPI_DEV_RXBUF()		bfin_read16(ATAPI_DEV_RXBUF)
+#define bfin_write_ATAPI_DEV_RXBUF(val)		bfin_write16(ATAPI_DEV_RXBUF, val)
+#define bfin_read_ATAPI_INT_MASK()		bfin_read16(ATAPI_INT_MASK)
+#define bfin_write_ATAPI_INT_MASK(val)		bfin_write16(ATAPI_INT_MASK, val)
+#define bfin_read_ATAPI_INT_STATUS()		bfin_read16(ATAPI_INT_STATUS)
+#define bfin_write_ATAPI_INT_STATUS(val)	bfin_write16(ATAPI_INT_STATUS, val)
+#define bfin_read_ATAPI_XFER_LEN()		bfin_read16(ATAPI_XFER_LEN)
+#define bfin_write_ATAPI_XFER_LEN(val)		bfin_write16(ATAPI_XFER_LEN, val)
+#define bfin_read_ATAPI_LINE_STATUS()		bfin_read16(ATAPI_LINE_STATUS)
+#define bfin_write_ATAPI_LINE_STATUS(val)	bfin_write16(ATAPI_LINE_STATUS, val)
+#define bfin_read_ATAPI_SM_STATE()		bfin_read16(ATAPI_SM_STATE)
+#define bfin_write_ATAPI_SM_STATE(val)		bfin_write16(ATAPI_SM_STATE, val)
+#define bfin_read_ATAPI_TERMINATE()		bfin_read16(ATAPI_TERMINATE)
+#define bfin_write_ATAPI_TERMINATE(val)		bfin_write16(ATAPI_TERMINATE, val)
+#define bfin_read_ATAPI_PIO_TFRCNT()		bfin_read16(ATAPI_PIO_TFRCNT)
+#define bfin_write_ATAPI_PIO_TFRCNT(val)	bfin_write16(ATAPI_PIO_TFRCNT, val)
+#define bfin_read_ATAPI_DMA_TFRCNT()		bfin_read16(ATAPI_DMA_TFRCNT)
+#define bfin_write_ATAPI_DMA_TFRCNT(val)	bfin_write16(ATAPI_DMA_TFRCNT, val)
+#define bfin_read_ATAPI_UMAIN_TFRCNT()		bfin_read16(ATAPI_UMAIN_TFRCNT)
+#define bfin_write_ATAPI_UMAIN_TFRCNT(val)	bfin_write16(ATAPI_UMAIN_TFRCNT, val)
+#define bfin_read_ATAPI_UDMAOUT_TFRCNT()	bfin_read16(ATAPI_UDMAOUT_TFRCNT)
+#define bfin_write_ATAPI_UDMAOUT_TFRCNT(val)	bfin_write16(ATAPI_UDMAOUT_TFRCNT, val)
+#define bfin_read_ATAPI_REG_TIM_0()		bfin_read16(ATAPI_REG_TIM_0)
+#define bfin_write_ATAPI_REG_TIM_0(val)		bfin_write16(ATAPI_REG_TIM_0, val)
+#define bfin_read_ATAPI_PIO_TIM_0()		bfin_read16(ATAPI_PIO_TIM_0)
+#define bfin_write_ATAPI_PIO_TIM_0(val)		bfin_write16(ATAPI_PIO_TIM_0, val)
+#define bfin_read_ATAPI_PIO_TIM_1()		bfin_read16(ATAPI_PIO_TIM_1)
+#define bfin_write_ATAPI_PIO_TIM_1(val)		bfin_write16(ATAPI_PIO_TIM_1, val)
+#define bfin_read_ATAPI_MULTI_TIM_0()		bfin_read16(ATAPI_MULTI_TIM_0)
+#define bfin_write_ATAPI_MULTI_TIM_0(val)	bfin_write16(ATAPI_MULTI_TIM_0, val)
+#define bfin_read_ATAPI_MULTI_TIM_1()		bfin_read16(ATAPI_MULTI_TIM_1)
+#define bfin_write_ATAPI_MULTI_TIM_1(val)	bfin_write16(ATAPI_MULTI_TIM_1, val)
+#define bfin_read_ATAPI_MULTI_TIM_2()		bfin_read16(ATAPI_MULTI_TIM_2)
+#define bfin_write_ATAPI_MULTI_TIM_2(val)	bfin_write16(ATAPI_MULTI_TIM_2, val)
+#define bfin_read_ATAPI_ULTRA_TIM_0()		bfin_read16(ATAPI_ULTRA_TIM_0)
+#define bfin_write_ATAPI_ULTRA_TIM_0(val)	bfin_write16(ATAPI_ULTRA_TIM_0, val)
+#define bfin_read_ATAPI_ULTRA_TIM_1()		bfin_read16(ATAPI_ULTRA_TIM_1)
+#define bfin_write_ATAPI_ULTRA_TIM_1(val)	bfin_write16(ATAPI_ULTRA_TIM_1, val)
+#define bfin_read_ATAPI_ULTRA_TIM_2()		bfin_read16(ATAPI_ULTRA_TIM_2)
+#define bfin_write_ATAPI_ULTRA_TIM_2(val)	bfin_write16(ATAPI_ULTRA_TIM_2, val)
+#define bfin_read_ATAPI_ULTRA_TIM_3()		bfin_read16(ATAPI_ULTRA_TIM_3)
+#define bfin_write_ATAPI_ULTRA_TIM_3(val)	bfin_write16(ATAPI_ULTRA_TIM_3, val)
+
+/* SDH Registers */
+
+#define bfin_read_SDH_PWR_CTL()		bfin_read16(SDH_PWR_CTL)
+#define bfin_write_SDH_PWR_CTL(val)	bfin_write16(SDH_PWR_CTL, val)
+#define bfin_read_SDH_CLK_CTL()		bfin_read16(SDH_CLK_CTL)
+#define bfin_write_SDH_CLK_CTL(val)	bfin_write16(SDH_CLK_CTL, val)
+#define bfin_read_SDH_ARGUMENT()	bfin_read32(SDH_ARGUMENT)
+#define bfin_write_SDH_ARGUMENT(val)	bfin_write32(SDH_ARGUMENT, val)
+#define bfin_read_SDH_COMMAND()		bfin_read16(SDH_COMMAND)
+#define bfin_write_SDH_COMMAND(val)	bfin_write16(SDH_COMMAND, val)
+#define bfin_read_SDH_RESP_CMD()	bfin_read16(SDH_RESP_CMD)
+#define bfin_write_SDH_RESP_CMD(val)	bfin_write16(SDH_RESP_CMD, val)
+#define bfin_read_SDH_RESPONSE0()	bfin_read32(SDH_RESPONSE0)
+#define bfin_write_SDH_RESPONSE0(val)	bfin_write32(SDH_RESPONSE0, val)
+#define bfin_read_SDH_RESPONSE1()	bfin_read32(SDH_RESPONSE1)
+#define bfin_write_SDH_RESPONSE1(val)	bfin_write32(SDH_RESPONSE1, val)
+#define bfin_read_SDH_RESPONSE2()	bfin_read32(SDH_RESPONSE2)
+#define bfin_write_SDH_RESPONSE2(val)	bfin_write32(SDH_RESPONSE2, val)
+#define bfin_read_SDH_RESPONSE3()	bfin_read32(SDH_RESPONSE3)
+#define bfin_write_SDH_RESPONSE3(val)	bfin_write32(SDH_RESPONSE3, val)
+#define bfin_read_SDH_DATA_TIMER()	bfin_read32(SDH_DATA_TIMER)
+#define bfin_write_SDH_DATA_TIMER(val)	bfin_write32(SDH_DATA_TIMER, val)
+#define bfin_read_SDH_DATA_LGTH()	bfin_read16(SDH_DATA_LGTH)
+#define bfin_write_SDH_DATA_LGTH(val)	bfin_write16(SDH_DATA_LGTH, val)
+#define bfin_read_SDH_DATA_CTL()	bfin_read16(SDH_DATA_CTL)
+#define bfin_write_SDH_DATA_CTL(val)	bfin_write16(SDH_DATA_CTL, val)
+#define bfin_read_SDH_DATA_CNT()	bfin_read16(SDH_DATA_CNT)
+#define bfin_write_SDH_DATA_CNT(val)	bfin_write16(SDH_DATA_CNT, val)
+#define bfin_read_SDH_STATUS()		bfin_read32(SDH_STATUS)
+#define bfin_write_SDH_STATUS(val)	bfin_write32(SDH_STATUS, val)
+#define bfin_read_SDH_STATUS_CLR()	bfin_read16(SDH_STATUS_CLR)
+#define bfin_write_SDH_STATUS_CLR(val)	bfin_write16(SDH_STATUS_CLR, val)
+#define bfin_read_SDH_MASK0()		bfin_read32(SDH_MASK0)
+#define bfin_write_SDH_MASK0(val)	bfin_write32(SDH_MASK0, val)
+#define bfin_read_SDH_MASK1()		bfin_read32(SDH_MASK1)
+#define bfin_write_SDH_MASK1(val)	bfin_write32(SDH_MASK1, val)
+#define bfin_read_SDH_FIFO_CNT()	bfin_read16(SDH_FIFO_CNT)
+#define bfin_write_SDH_FIFO_CNT(val)	bfin_write16(SDH_FIFO_CNT, val)
+#define bfin_read_SDH_FIFO()		bfin_read32(SDH_FIFO)
+#define bfin_write_SDH_FIFO(val)	bfin_write32(SDH_FIFO, val)
+#define bfin_read_SDH_E_STATUS()	bfin_read16(SDH_E_STATUS)
+#define bfin_write_SDH_E_STATUS(val)	bfin_write16(SDH_E_STATUS, val)
+#define bfin_read_SDH_E_MASK()		bfin_read16(SDH_E_MASK)
+#define bfin_write_SDH_E_MASK(val)	bfin_write16(SDH_E_MASK, val)
+#define bfin_read_SDH_CFG()		bfin_read16(SDH_CFG)
+#define bfin_write_SDH_CFG(val)		bfin_write16(SDH_CFG, val)
+#define bfin_read_SDH_RD_WAIT_EN()	bfin_read16(SDH_RD_WAIT_EN)
+#define bfin_write_SDH_RD_WAIT_EN(val)	bfin_write16(SDH_RD_WAIT_EN, val)
+#define bfin_read_SDH_PID0()		bfin_read16(SDH_PID0)
+#define bfin_write_SDH_PID0(val)	bfin_write16(SDH_PID0, val)
+#define bfin_read_SDH_PID1()		bfin_read16(SDH_PID1)
+#define bfin_write_SDH_PID1(val)	bfin_write16(SDH_PID1, val)
+#define bfin_read_SDH_PID2()		bfin_read16(SDH_PID2)
+#define bfin_write_SDH_PID2(val)	bfin_write16(SDH_PID2, val)
+#define bfin_read_SDH_PID3()		bfin_read16(SDH_PID3)
+#define bfin_write_SDH_PID3(val)	bfin_write16(SDH_PID3, val)
+#define bfin_read_SDH_PID4()		bfin_read16(SDH_PID4)
+#define bfin_write_SDH_PID4(val)	bfin_write16(SDH_PID4, val)
+#define bfin_read_SDH_PID5()		bfin_read16(SDH_PID5)
+#define bfin_write_SDH_PID5(val)	bfin_write16(SDH_PID5, val)
+#define bfin_read_SDH_PID6()		bfin_read16(SDH_PID6)
+#define bfin_write_SDH_PID6(val)	bfin_write16(SDH_PID6, val)
+#define bfin_read_SDH_PID7()		bfin_read16(SDH_PID7)
+#define bfin_write_SDH_PID7(val)	bfin_write16(SDH_PID7, val)
+
+/* HOST Port Registers */
+
+#define bfin_read_HOST_CONTROL()	bfin_read16(HOST_CONTROL)
+#define bfin_write_HOST_CONTROL(val)	bfin_write16(HOST_CONTROL, val)
+#define bfin_read_HOST_STATUS()		bfin_read16(HOST_STATUS)
+#define bfin_write_HOST_STATUS(val)	bfin_write16(HOST_STATUS, val)
+#define bfin_read_HOST_TIMEOUT()	bfin_read16(HOST_TIMEOUT)
+#define bfin_write_HOST_TIMEOUT(val)	bfin_write16(HOST_TIMEOUT, val)
+
+/* USB Control Registers */
+
+#define bfin_read_USB_FADDR()		bfin_read16(USB_FADDR)
+#define bfin_write_USB_FADDR(val)	bfin_write16(USB_FADDR, val)
+#define bfin_read_USB_POWER()		bfin_read16(USB_POWER)
+#define bfin_write_USB_POWER(val)	bfin_write16(USB_POWER, val)
+#define bfin_read_USB_INTRTX()		bfin_read16(USB_INTRTX)
+#define bfin_write_USB_INTRTX(val)	bfin_write16(USB_INTRTX, val)
+#define bfin_read_USB_INTRRX()		bfin_read16(USB_INTRRX)
+#define bfin_write_USB_INTRRX(val)	bfin_write16(USB_INTRRX, val)
+#define bfin_read_USB_INTRTXE()		bfin_read16(USB_INTRTXE)
+#define bfin_write_USB_INTRTXE(val)	bfin_write16(USB_INTRTXE, val)
+#define bfin_read_USB_INTRRXE()		bfin_read16(USB_INTRRXE)
+#define bfin_write_USB_INTRRXE(val)	bfin_write16(USB_INTRRXE, val)
+#define bfin_read_USB_INTRUSB()		bfin_read16(USB_INTRUSB)
+#define bfin_write_USB_INTRUSB(val)	bfin_write16(USB_INTRUSB, val)
+#define bfin_read_USB_INTRUSBE()	bfin_read16(USB_INTRUSBE)
+#define bfin_write_USB_INTRUSBE(val)	bfin_write16(USB_INTRUSBE, val)
+#define bfin_read_USB_FRAME()		bfin_read16(USB_FRAME)
+#define bfin_write_USB_FRAME(val)	bfin_write16(USB_FRAME, val)
+#define bfin_read_USB_INDEX()		bfin_read16(USB_INDEX)
+#define bfin_write_USB_INDEX(val)	bfin_write16(USB_INDEX, val)
+#define bfin_read_USB_TESTMODE()	bfin_read16(USB_TESTMODE)
+#define bfin_write_USB_TESTMODE(val)	bfin_write16(USB_TESTMODE, val)
+#define bfin_read_USB_GLOBINTR()	bfin_read16(USB_GLOBINTR)
+#define bfin_write_USB_GLOBINTR(val)	bfin_write16(USB_GLOBINTR, val)
+#define bfin_read_USB_GLOBAL_CTL()	bfin_read16(USB_GLOBAL_CTL)
+#define bfin_write_USB_GLOBAL_CTL(val)		bfin_write16(USB_GLOBAL_CTL, val)
+
+/* USB Packet Control Registers */
+
+#define bfin_read_USB_TX_MAX_PACKET()		bfin_read16(USB_TX_MAX_PACKET)
+#define bfin_write_USB_TX_MAX_PACKET(val)	bfin_write16(USB_TX_MAX_PACKET, val)
+#define bfin_read_USB_CSR0()		bfin_read16(USB_CSR0)
+#define bfin_write_USB_CSR0(val)	bfin_write16(USB_CSR0, val)
+#define bfin_read_USB_TXCSR()		bfin_read16(USB_TXCSR)
+#define bfin_write_USB_TXCSR(val)	bfin_write16(USB_TXCSR, val)
+#define bfin_read_USB_RX_MAX_PACKET()		bfin_read16(USB_RX_MAX_PACKET)
+#define bfin_write_USB_RX_MAX_PACKET(val)	bfin_write16(USB_RX_MAX_PACKET, val)
+#define bfin_read_USB_RXCSR()		bfin_read16(USB_RXCSR)
+#define bfin_write_USB_RXCSR(val)	bfin_write16(USB_RXCSR, val)
+#define bfin_read_USB_COUNT0()		bfin_read16(USB_COUNT0)
+#define bfin_write_USB_COUNT0(val)	bfin_write16(USB_COUNT0, val)
+#define bfin_read_USB_RXCOUNT()		bfin_read16(USB_RXCOUNT)
+#define bfin_write_USB_RXCOUNT(val)	bfin_write16(USB_RXCOUNT, val)
+#define bfin_read_USB_TXTYPE()		bfin_read16(USB_TXTYPE)
+#define bfin_write_USB_TXTYPE(val)	bfin_write16(USB_TXTYPE, val)
+#define bfin_read_USB_NAKLIMIT0()	bfin_read16(USB_NAKLIMIT0)
+#define bfin_write_USB_NAKLIMIT0(val)	bfin_write16(USB_NAKLIMIT0, val)
+#define bfin_read_USB_TXINTERVAL()	bfin_read16(USB_TXINTERVAL)
+#define bfin_write_USB_TXINTERVAL(val)	bfin_write16(USB_TXINTERVAL, val)
+#define bfin_read_USB_RXTYPE()		bfin_read16(USB_RXTYPE)
+#define bfin_write_USB_RXTYPE(val)	bfin_write16(USB_RXTYPE, val)
+#define bfin_read_USB_RXINTERVAL()	bfin_read16(USB_RXINTERVAL)
+#define bfin_write_USB_RXINTERVAL(val)	bfin_write16(USB_RXINTERVAL, val)
+#define bfin_read_USB_TXCOUNT()		bfin_read16(USB_TXCOUNT)
+#define bfin_write_USB_TXCOUNT(val)	bfin_write16(USB_TXCOUNT, val)
+
+/* USB Endbfin_read_()oint FIFO Registers */
+
+#define bfin_read_USB_EP0_FIFO()	bfin_read16(USB_EP0_FIFO)
+#define bfin_write_USB_EP0_FIFO(val)	bfin_write16(USB_EP0_FIFO, val)
+#define bfin_read_USB_EP1_FIFO()	bfin_read16(USB_EP1_FIFO)
+#define bfin_write_USB_EP1_FIFO(val)	bfin_write16(USB_EP1_FIFO, val)
+#define bfin_read_USB_EP2_FIFO()	bfin_read16(USB_EP2_FIFO)
+#define bfin_write_USB_EP2_FIFO(val)	bfin_write16(USB_EP2_FIFO, val)
+#define bfin_read_USB_EP3_FIFO()	bfin_read16(USB_EP3_FIFO)
+#define bfin_write_USB_EP3_FIFO(val)	bfin_write16(USB_EP3_FIFO, val)
+#define bfin_read_USB_EP4_FIFO()	bfin_read16(USB_EP4_FIFO)
+#define bfin_write_USB_EP4_FIFO(val)	bfin_write16(USB_EP4_FIFO, val)
+#define bfin_read_USB_EP5_FIFO()	bfin_read16(USB_EP5_FIFO)
+#define bfin_write_USB_EP5_FIFO(val)	bfin_write16(USB_EP5_FIFO, val)
+#define bfin_read_USB_EP6_FIFO()	bfin_read16(USB_EP6_FIFO)
+#define bfin_write_USB_EP6_FIFO(val)	bfin_write16(USB_EP6_FIFO, val)
+#define bfin_read_USB_EP7_FIFO()	bfin_read16(USB_EP7_FIFO)
+#define bfin_write_USB_EP7_FIFO(val)	bfin_write16(USB_EP7_FIFO, val)
+
+/* USB OTG Control Registers */
+
+#define bfin_read_USB_OTG_DEV_CTL()		bfin_read16(USB_OTG_DEV_CTL)
+#define bfin_write_USB_OTG_DEV_CTL(val)		bfin_write16(USB_OTG_DEV_CTL, val)
+#define bfin_read_USB_OTG_VBUS_IRQ()		bfin_read16(USB_OTG_VBUS_IRQ)
+#define bfin_write_USB_OTG_VBUS_IRQ(val)	bfin_write16(USB_OTG_VBUS_IRQ, val)
+#define bfin_read_USB_OTG_VBUS_MASK()		bfin_read16(USB_OTG_VBUS_MASK)
+#define bfin_write_USB_OTG_VBUS_MASK(val)	bfin_write16(USB_OTG_VBUS_MASK, val)
+
+/* USB Phy Control Registers */
+
+#define bfin_read_USB_LINKINFO()	bfin_read16(USB_LINKINFO)
+#define bfin_write_USB_LINKINFO(val)	bfin_write16(USB_LINKINFO, val)
+#define bfin_read_USB_VPLEN()		bfin_read16(USB_VPLEN)
+#define bfin_write_USB_VPLEN(val)	bfin_write16(USB_VPLEN, val)
+#define bfin_read_USB_HS_EOF1()		bfin_read16(USB_HS_EOF1)
+#define bfin_write_USB_HS_EOF1(val)	bfin_write16(USB_HS_EOF1, val)
+#define bfin_read_USB_FS_EOF1()		bfin_read16(USB_FS_EOF1)
+#define bfin_write_USB_FS_EOF1(val)	bfin_write16(USB_FS_EOF1, val)
+#define bfin_read_USB_LS_EOF1()		bfin_read16(USB_LS_EOF1)
+#define bfin_write_USB_LS_EOF1(val)	bfin_write16(USB_LS_EOF1, val)
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CNTRL()		bfin_read16(USB_APHY_CNTRL)
+#define bfin_write_USB_APHY_CNTRL(val)		bfin_write16(USB_APHY_CNTRL, val)
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CALIB()		bfin_read16(USB_APHY_CALIB)
+#define bfin_write_USB_APHY_CALIB(val)		bfin_write16(USB_APHY_CALIB, val)
+#define bfin_read_USB_APHY_CNTRL2()		bfin_read16(USB_APHY_CNTRL2)
+#define bfin_write_USB_APHY_CNTRL2(val)		bfin_write16(USB_APHY_CNTRL2, val)
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define bfin_read_USB_PHY_TEST()		bfin_read16(USB_PHY_TEST)
+#define bfin_write_USB_PHY_TEST(val)		bfin_write16(USB_PHY_TEST, val)
+#define bfin_read_USB_PLLOSC_CTRL()		bfin_read16(USB_PLLOSC_CTRL)
+#define bfin_write_USB_PLLOSC_CTRL(val)		bfin_write16(USB_PLLOSC_CTRL, val)
+#define bfin_read_USB_SRP_CLKDIV()		bfin_read16(USB_SRP_CLKDIV)
+#define bfin_write_USB_SRP_CLKDIV(val)		bfin_write16(USB_SRP_CLKDIV, val)
+
+/* USB Endbfin_read_()oint 0 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXMAXP()		bfin_read16(USB_EP_NI0_TXMAXP)
+#define bfin_write_USB_EP_NI0_TXMAXP(val)	bfin_write16(USB_EP_NI0_TXMAXP, val)
+#define bfin_read_USB_EP_NI0_TXCSR()		bfin_read16(USB_EP_NI0_TXCSR)
+#define bfin_write_USB_EP_NI0_TXCSR(val)	bfin_write16(USB_EP_NI0_TXCSR, val)
+#define bfin_read_USB_EP_NI0_RXMAXP()		bfin_read16(USB_EP_NI0_RXMAXP)
+#define bfin_write_USB_EP_NI0_RXMAXP(val)	bfin_write16(USB_EP_NI0_RXMAXP, val)
+#define bfin_read_USB_EP_NI0_RXCSR()		bfin_read16(USB_EP_NI0_RXCSR)
+#define bfin_write_USB_EP_NI0_RXCSR(val)	bfin_write16(USB_EP_NI0_RXCSR, val)
+#define bfin_read_USB_EP_NI0_RXCOUNT()		bfin_read16(USB_EP_NI0_RXCOUNT)
+#define bfin_write_USB_EP_NI0_RXCOUNT(val)	bfin_write16(USB_EP_NI0_RXCOUNT, val)
+#define bfin_read_USB_EP_NI0_TXTYPE()		bfin_read16(USB_EP_NI0_TXTYPE)
+#define bfin_write_USB_EP_NI0_TXTYPE(val)	bfin_write16(USB_EP_NI0_TXTYPE, val)
+#define bfin_read_USB_EP_NI0_TXINTERVAL()	bfin_read16(USB_EP_NI0_TXINTERVAL)
+#define bfin_write_USB_EP_NI0_TXINTERVAL(val)	bfin_write16(USB_EP_NI0_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI0_RXTYPE()		bfin_read16(USB_EP_NI0_RXTYPE)
+#define bfin_write_USB_EP_NI0_RXTYPE(val)	bfin_write16(USB_EP_NI0_RXTYPE, val)
+#define bfin_read_USB_EP_NI0_RXINTERVAL()	bfin_read16(USB_EP_NI0_RXINTERVAL)
+#define bfin_write_USB_EP_NI0_RXINTERVAL(val)	bfin_write16(USB_EP_NI0_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 1 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXCOUNT()		bfin_read16(USB_EP_NI0_TXCOUNT)
+#define bfin_write_USB_EP_NI0_TXCOUNT(val)	bfin_write16(USB_EP_NI0_TXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXMAXP()		bfin_read16(USB_EP_NI1_TXMAXP)
+#define bfin_write_USB_EP_NI1_TXMAXP(val)	bfin_write16(USB_EP_NI1_TXMAXP, val)
+#define bfin_read_USB_EP_NI1_TXCSR()		bfin_read16(USB_EP_NI1_TXCSR)
+#define bfin_write_USB_EP_NI1_TXCSR(val)	bfin_write16(USB_EP_NI1_TXCSR, val)
+#define bfin_read_USB_EP_NI1_RXMAXP()		bfin_read16(USB_EP_NI1_RXMAXP)
+#define bfin_write_USB_EP_NI1_RXMAXP(val)	bfin_write16(USB_EP_NI1_RXMAXP, val)
+#define bfin_read_USB_EP_NI1_RXCSR()		bfin_read16(USB_EP_NI1_RXCSR)
+#define bfin_write_USB_EP_NI1_RXCSR(val)	bfin_write16(USB_EP_NI1_RXCSR, val)
+#define bfin_read_USB_EP_NI1_RXCOUNT()		bfin_read16(USB_EP_NI1_RXCOUNT)
+#define bfin_write_USB_EP_NI1_RXCOUNT(val)	bfin_write16(USB_EP_NI1_RXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXTYPE()		bfin_read16(USB_EP_NI1_TXTYPE)
+#define bfin_write_USB_EP_NI1_TXTYPE(val)	bfin_write16(USB_EP_NI1_TXTYPE, val)
+#define bfin_read_USB_EP_NI1_TXINTERVAL()	bfin_read16(USB_EP_NI1_TXINTERVAL)
+#define bfin_write_USB_EP_NI1_TXINTERVAL(val)	bfin_write16(USB_EP_NI1_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI1_RXTYPE()		bfin_read16(USB_EP_NI1_RXTYPE)
+#define bfin_write_USB_EP_NI1_RXTYPE(val)	bfin_write16(USB_EP_NI1_RXTYPE, val)
+#define bfin_read_USB_EP_NI1_RXINTERVAL()	bfin_read16(USB_EP_NI1_RXINTERVAL)
+#define bfin_write_USB_EP_NI1_RXINTERVAL(val)	bfin_write16(USB_EP_NI1_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 2 Control Registers */
+
+#define bfin_read_USB_EP_NI1_TXCOUNT()		bfin_read16(USB_EP_NI1_TXCOUNT)
+#define bfin_write_USB_EP_NI1_TXCOUNT(val)	bfin_write16(USB_EP_NI1_TXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXMAXP()		bfin_read16(USB_EP_NI2_TXMAXP)
+#define bfin_write_USB_EP_NI2_TXMAXP(val)	bfin_write16(USB_EP_NI2_TXMAXP, val)
+#define bfin_read_USB_EP_NI2_TXCSR()		bfin_read16(USB_EP_NI2_TXCSR)
+#define bfin_write_USB_EP_NI2_TXCSR(val)	bfin_write16(USB_EP_NI2_TXCSR, val)
+#define bfin_read_USB_EP_NI2_RXMAXP()		bfin_read16(USB_EP_NI2_RXMAXP)
+#define bfin_write_USB_EP_NI2_RXMAXP(val)	bfin_write16(USB_EP_NI2_RXMAXP, val)
+#define bfin_read_USB_EP_NI2_RXCSR()		bfin_read16(USB_EP_NI2_RXCSR)
+#define bfin_write_USB_EP_NI2_RXCSR(val)	bfin_write16(USB_EP_NI2_RXCSR, val)
+#define bfin_read_USB_EP_NI2_RXCOUNT()		bfin_read16(USB_EP_NI2_RXCOUNT)
+#define bfin_write_USB_EP_NI2_RXCOUNT(val)	bfin_write16(USB_EP_NI2_RXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXTYPE()		bfin_read16(USB_EP_NI2_TXTYPE)
+#define bfin_write_USB_EP_NI2_TXTYPE(val)	bfin_write16(USB_EP_NI2_TXTYPE, val)
+#define bfin_read_USB_EP_NI2_TXINTERVAL()	bfin_read16(USB_EP_NI2_TXINTERVAL)
+#define bfin_write_USB_EP_NI2_TXINTERVAL(val)	bfin_write16(USB_EP_NI2_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI2_RXTYPE()		bfin_read16(USB_EP_NI2_RXTYPE)
+#define bfin_write_USB_EP_NI2_RXTYPE(val)	bfin_write16(USB_EP_NI2_RXTYPE, val)
+#define bfin_read_USB_EP_NI2_RXINTERVAL()	bfin_read16(USB_EP_NI2_RXINTERVAL)
+#define bfin_write_USB_EP_NI2_RXINTERVAL(val)	bfin_write16(USB_EP_NI2_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 3 Control Registers */
+
+#define bfin_read_USB_EP_NI2_TXCOUNT()		bfin_read16(USB_EP_NI2_TXCOUNT)
+#define bfin_write_USB_EP_NI2_TXCOUNT(val)	bfin_write16(USB_EP_NI2_TXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXMAXP()		bfin_read16(USB_EP_NI3_TXMAXP)
+#define bfin_write_USB_EP_NI3_TXMAXP(val)	bfin_write16(USB_EP_NI3_TXMAXP, val)
+#define bfin_read_USB_EP_NI3_TXCSR()		bfin_read16(USB_EP_NI3_TXCSR)
+#define bfin_write_USB_EP_NI3_TXCSR(val)	bfin_write16(USB_EP_NI3_TXCSR, val)
+#define bfin_read_USB_EP_NI3_RXMAXP()		bfin_read16(USB_EP_NI3_RXMAXP)
+#define bfin_write_USB_EP_NI3_RXMAXP(val)	bfin_write16(USB_EP_NI3_RXMAXP, val)
+#define bfin_read_USB_EP_NI3_RXCSR()		bfin_read16(USB_EP_NI3_RXCSR)
+#define bfin_write_USB_EP_NI3_RXCSR(val)	bfin_write16(USB_EP_NI3_RXCSR, val)
+#define bfin_read_USB_EP_NI3_RXCOUNT()		bfin_read16(USB_EP_NI3_RXCOUNT)
+#define bfin_write_USB_EP_NI3_RXCOUNT(val)	bfin_write16(USB_EP_NI3_RXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXTYPE()		bfin_read16(USB_EP_NI3_TXTYPE)
+#define bfin_write_USB_EP_NI3_TXTYPE(val)	bfin_write16(USB_EP_NI3_TXTYPE, val)
+#define bfin_read_USB_EP_NI3_TXINTERVAL()	bfin_read16(USB_EP_NI3_TXINTERVAL)
+#define bfin_write_USB_EP_NI3_TXINTERVAL(val)	bfin_write16(USB_EP_NI3_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI3_RXTYPE()		bfin_read16(USB_EP_NI3_RXTYPE)
+#define bfin_write_USB_EP_NI3_RXTYPE(val)	bfin_write16(USB_EP_NI3_RXTYPE, val)
+#define bfin_read_USB_EP_NI3_RXINTERVAL()	bfin_read16(USB_EP_NI3_RXINTERVAL)
+#define bfin_write_USB_EP_NI3_RXINTERVAL(val)	bfin_write16(USB_EP_NI3_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 4 Control Registers */
+
+#define bfin_read_USB_EP_NI3_TXCOUNT()		bfin_read16(USB_EP_NI3_TXCOUNT)
+#define bfin_write_USB_EP_NI3_TXCOUNT(val)	bfin_write16(USB_EP_NI3_TXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXMAXP()		bfin_read16(USB_EP_NI4_TXMAXP)
+#define bfin_write_USB_EP_NI4_TXMAXP(val)	bfin_write16(USB_EP_NI4_TXMAXP, val)
+#define bfin_read_USB_EP_NI4_TXCSR()		bfin_read16(USB_EP_NI4_TXCSR)
+#define bfin_write_USB_EP_NI4_TXCSR(val)	bfin_write16(USB_EP_NI4_TXCSR, val)
+#define bfin_read_USB_EP_NI4_RXMAXP()		bfin_read16(USB_EP_NI4_RXMAXP)
+#define bfin_write_USB_EP_NI4_RXMAXP(val)	bfin_write16(USB_EP_NI4_RXMAXP, val)
+#define bfin_read_USB_EP_NI4_RXCSR()		bfin_read16(USB_EP_NI4_RXCSR)
+#define bfin_write_USB_EP_NI4_RXCSR(val)	bfin_write16(USB_EP_NI4_RXCSR, val)
+#define bfin_read_USB_EP_NI4_RXCOUNT()		bfin_read16(USB_EP_NI4_RXCOUNT)
+#define bfin_write_USB_EP_NI4_RXCOUNT(val)	bfin_write16(USB_EP_NI4_RXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXTYPE()		bfin_read16(USB_EP_NI4_TXTYPE)
+#define bfin_write_USB_EP_NI4_TXTYPE(val)	bfin_write16(USB_EP_NI4_TXTYPE, val)
+#define bfin_read_USB_EP_NI4_TXINTERVAL()	bfin_read16(USB_EP_NI4_TXINTERVAL)
+#define bfin_write_USB_EP_NI4_TXINTERVAL(val)	bfin_write16(USB_EP_NI4_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI4_RXTYPE()		bfin_read16(USB_EP_NI4_RXTYPE)
+#define bfin_write_USB_EP_NI4_RXTYPE(val)	bfin_write16(USB_EP_NI4_RXTYPE, val)
+#define bfin_read_USB_EP_NI4_RXINTERVAL()	bfin_read16(USB_EP_NI4_RXINTERVAL)
+#define bfin_write_USB_EP_NI4_RXINTERVAL(val)	bfin_write16(USB_EP_NI4_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 5 Control Registers */
+
+#define bfin_read_USB_EP_NI4_TXCOUNT()		bfin_read16(USB_EP_NI4_TXCOUNT)
+#define bfin_write_USB_EP_NI4_TXCOUNT(val)	bfin_write16(USB_EP_NI4_TXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXMAXP()		bfin_read16(USB_EP_NI5_TXMAXP)
+#define bfin_write_USB_EP_NI5_TXMAXP(val)	bfin_write16(USB_EP_NI5_TXMAXP, val)
+#define bfin_read_USB_EP_NI5_TXCSR()		bfin_read16(USB_EP_NI5_TXCSR)
+#define bfin_write_USB_EP_NI5_TXCSR(val)	bfin_write16(USB_EP_NI5_TXCSR, val)
+#define bfin_read_USB_EP_NI5_RXMAXP()		bfin_read16(USB_EP_NI5_RXMAXP)
+#define bfin_write_USB_EP_NI5_RXMAXP(val)	bfin_write16(USB_EP_NI5_RXMAXP, val)
+#define bfin_read_USB_EP_NI5_RXCSR()		bfin_read16(USB_EP_NI5_RXCSR)
+#define bfin_write_USB_EP_NI5_RXCSR(val)	bfin_write16(USB_EP_NI5_RXCSR, val)
+#define bfin_read_USB_EP_NI5_RXCOUNT()		bfin_read16(USB_EP_NI5_RXCOUNT)
+#define bfin_write_USB_EP_NI5_RXCOUNT(val)	bfin_write16(USB_EP_NI5_RXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXTYPE()		bfin_read16(USB_EP_NI5_TXTYPE)
+#define bfin_write_USB_EP_NI5_TXTYPE(val)	bfin_write16(USB_EP_NI5_TXTYPE, val)
+#define bfin_read_USB_EP_NI5_TXINTERVAL()	bfin_read16(USB_EP_NI5_TXINTERVAL)
+#define bfin_write_USB_EP_NI5_TXINTERVAL(val)	bfin_write16(USB_EP_NI5_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI5_RXTYPE()		bfin_read16(USB_EP_NI5_RXTYPE)
+#define bfin_write_USB_EP_NI5_RXTYPE(val)	bfin_write16(USB_EP_NI5_RXTYPE, val)
+#define bfin_read_USB_EP_NI5_RXINTERVAL()	bfin_read16(USB_EP_NI5_RXINTERVAL)
+#define bfin_write_USB_EP_NI5_RXINTERVAL(val)	bfin_write16(USB_EP_NI5_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 6 Control Registers */
+
+#define bfin_read_USB_EP_NI5_TXCOUNT()		bfin_read16(USB_EP_NI5_TXCOUNT)
+#define bfin_write_USB_EP_NI5_TXCOUNT(val)	bfin_write16(USB_EP_NI5_TXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXMAXP()		bfin_read16(USB_EP_NI6_TXMAXP)
+#define bfin_write_USB_EP_NI6_TXMAXP(val)	bfin_write16(USB_EP_NI6_TXMAXP, val)
+#define bfin_read_USB_EP_NI6_TXCSR()		bfin_read16(USB_EP_NI6_TXCSR)
+#define bfin_write_USB_EP_NI6_TXCSR(val)	bfin_write16(USB_EP_NI6_TXCSR, val)
+#define bfin_read_USB_EP_NI6_RXMAXP()		bfin_read16(USB_EP_NI6_RXMAXP)
+#define bfin_write_USB_EP_NI6_RXMAXP(val)	bfin_write16(USB_EP_NI6_RXMAXP, val)
+#define bfin_read_USB_EP_NI6_RXCSR()		bfin_read16(USB_EP_NI6_RXCSR)
+#define bfin_write_USB_EP_NI6_RXCSR(val)	bfin_write16(USB_EP_NI6_RXCSR, val)
+#define bfin_read_USB_EP_NI6_RXCOUNT()		bfin_read16(USB_EP_NI6_RXCOUNT)
+#define bfin_write_USB_EP_NI6_RXCOUNT(val)	bfin_write16(USB_EP_NI6_RXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXTYPE()		bfin_read16(USB_EP_NI6_TXTYPE)
+#define bfin_write_USB_EP_NI6_TXTYPE(val)	bfin_write16(USB_EP_NI6_TXTYPE, val)
+#define bfin_read_USB_EP_NI6_TXINTERVAL()	bfin_read16(USB_EP_NI6_TXINTERVAL)
+#define bfin_write_USB_EP_NI6_TXINTERVAL(val)	bfin_write16(USB_EP_NI6_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI6_RXTYPE()		bfin_read16(USB_EP_NI6_RXTYPE)
+#define bfin_write_USB_EP_NI6_RXTYPE(val)	bfin_write16(USB_EP_NI6_RXTYPE, val)
+#define bfin_read_USB_EP_NI6_RXINTERVAL()	bfin_read16(USB_EP_NI6_RXINTERVAL)
+#define bfin_write_USB_EP_NI6_RXINTERVAL(val)	bfin_write16(USB_EP_NI6_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 7 Control Registers */
+
+#define bfin_read_USB_EP_NI6_TXCOUNT()		bfin_read16(USB_EP_NI6_TXCOUNT)
+#define bfin_write_USB_EP_NI6_TXCOUNT(val)	bfin_write16(USB_EP_NI6_TXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXMAXP()		bfin_read16(USB_EP_NI7_TXMAXP)
+#define bfin_write_USB_EP_NI7_TXMAXP(val)	bfin_write16(USB_EP_NI7_TXMAXP, val)
+#define bfin_read_USB_EP_NI7_TXCSR()		bfin_read16(USB_EP_NI7_TXCSR)
+#define bfin_write_USB_EP_NI7_TXCSR(val)	bfin_write16(USB_EP_NI7_TXCSR, val)
+#define bfin_read_USB_EP_NI7_RXMAXP()		bfin_read16(USB_EP_NI7_RXMAXP)
+#define bfin_write_USB_EP_NI7_RXMAXP(val)	bfin_write16(USB_EP_NI7_RXMAXP, val)
+#define bfin_read_USB_EP_NI7_RXCSR()		bfin_read16(USB_EP_NI7_RXCSR)
+#define bfin_write_USB_EP_NI7_RXCSR(val)	bfin_write16(USB_EP_NI7_RXCSR, val)
+#define bfin_read_USB_EP_NI7_RXCOUNT()		bfin_read16(USB_EP_NI7_RXCOUNT)
+#define bfin_write_USB_EP_NI7_RXCOUNT(val)	bfin_write16(USB_EP_NI7_RXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXTYPE()		bfin_read16(USB_EP_NI7_TXTYPE)
+#define bfin_write_USB_EP_NI7_TXTYPE(val)	bfin_write16(USB_EP_NI7_TXTYPE, val)
+#define bfin_read_USB_EP_NI7_TXINTERVAL()	bfin_read16(USB_EP_NI7_TXINTERVAL)
+#define bfin_write_USB_EP_NI7_TXINTERVAL(val)	bfin_write16(USB_EP_NI7_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_RXTYPE()		bfin_read16(USB_EP_NI7_RXTYPE)
+#define bfin_write_USB_EP_NI7_RXTYPE(val)	bfin_write16(USB_EP_NI7_RXTYPE, val)
+#define bfin_read_USB_EP_NI7_RXINTERVAL()	bfin_read16(USB_EP_NI7_RXINTERVAL)
+#define bfin_write_USB_EP_NI7_RXINTERVAL(val)	bfin_write16(USB_EP_NI7_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_TXCOUNT()		bfin_read16(USB_EP_NI7_TXCOUNT)
+#define bfin_write_USB_EP_NI7_TXCOUNT(val)	bfin_write16(USB_EP_NI7_TXCOUNT, val)
+#define bfin_read_USB_DMA_INTERRUPT()		bfin_read16(USB_DMA_INTERRUPT)
+#define bfin_write_USB_DMA_INTERRUPT(val)	bfin_write16(USB_DMA_INTERRUPT, val)
+
+/* USB Channel 0 Config Registers */
+
+#define bfin_read_USB_DMA0CONTROL()		bfin_read16(USB_DMA0CONTROL)
+#define bfin_write_USB_DMA0CONTROL(val)		bfin_write16(USB_DMA0CONTROL, val)
+#define bfin_read_USB_DMA0ADDRLOW()		bfin_read16(USB_DMA0ADDRLOW)
+#define bfin_write_USB_DMA0ADDRLOW(val)		bfin_write16(USB_DMA0ADDRLOW, val)
+#define bfin_read_USB_DMA0ADDRHIGH()		bfin_read16(USB_DMA0ADDRHIGH)
+#define bfin_write_USB_DMA0ADDRHIGH(val)	bfin_write16(USB_DMA0ADDRHIGH, val)
+#define bfin_read_USB_DMA0COUNTLOW()		bfin_read16(USB_DMA0COUNTLOW)
+#define bfin_write_USB_DMA0COUNTLOW(val)	bfin_write16(USB_DMA0COUNTLOW, val)
+#define bfin_read_USB_DMA0COUNTHIGH()		bfin_read16(USB_DMA0COUNTHIGH)
+#define bfin_write_USB_DMA0COUNTHIGH(val)	bfin_write16(USB_DMA0COUNTHIGH, val)
+
+/* USB Channel 1 Config Registers */
+
+#define bfin_read_USB_DMA1CONTROL()		bfin_read16(USB_DMA1CONTROL)
+#define bfin_write_USB_DMA1CONTROL(val)		bfin_write16(USB_DMA1CONTROL, val)
+#define bfin_read_USB_DMA1ADDRLOW()		bfin_read16(USB_DMA1ADDRLOW)
+#define bfin_write_USB_DMA1ADDRLOW(val)		bfin_write16(USB_DMA1ADDRLOW, val)
+#define bfin_read_USB_DMA1ADDRHIGH()		bfin_read16(USB_DMA1ADDRHIGH)
+#define bfin_write_USB_DMA1ADDRHIGH(val)	bfin_write16(USB_DMA1ADDRHIGH, val)
+#define bfin_read_USB_DMA1COUNTLOW()		bfin_read16(USB_DMA1COUNTLOW)
+#define bfin_write_USB_DMA1COUNTLOW(val)	bfin_write16(USB_DMA1COUNTLOW, val)
+#define bfin_read_USB_DMA1COUNTHIGH()		bfin_read16(USB_DMA1COUNTHIGH)
+#define bfin_write_USB_DMA1COUNTHIGH(val)	bfin_write16(USB_DMA1COUNTHIGH, val)
+
+/* USB Channel 2 Config Registers */
+
+#define bfin_read_USB_DMA2CONTROL()		bfin_read16(USB_DMA2CONTROL)
+#define bfin_write_USB_DMA2CONTROL(val)		bfin_write16(USB_DMA2CONTROL, val)
+#define bfin_read_USB_DMA2ADDRLOW()		bfin_read16(USB_DMA2ADDRLOW)
+#define bfin_write_USB_DMA2ADDRLOW(val)		bfin_write16(USB_DMA2ADDRLOW, val)
+#define bfin_read_USB_DMA2ADDRHIGH()		bfin_read16(USB_DMA2ADDRHIGH)
+#define bfin_write_USB_DMA2ADDRHIGH(val)	bfin_write16(USB_DMA2ADDRHIGH, val)
+#define bfin_read_USB_DMA2COUNTLOW()		bfin_read16(USB_DMA2COUNTLOW)
+#define bfin_write_USB_DMA2COUNTLOW(val)	bfin_write16(USB_DMA2COUNTLOW, val)
+#define bfin_read_USB_DMA2COUNTHIGH()		bfin_read16(USB_DMA2COUNTHIGH)
+#define bfin_write_USB_DMA2COUNTHIGH(val)	bfin_write16(USB_DMA2COUNTHIGH, val)
+
+/* USB Channel 3 Config Registers */
+
+#define bfin_read_USB_DMA3CONTROL()		bfin_read16(USB_DMA3CONTROL)
+#define bfin_write_USB_DMA3CONTROL(val)		bfin_write16(USB_DMA3CONTROL, val)
+#define bfin_read_USB_DMA3ADDRLOW()		bfin_read16(USB_DMA3ADDRLOW)
+#define bfin_write_USB_DMA3ADDRLOW(val)		bfin_write16(USB_DMA3ADDRLOW, val)
+#define bfin_read_USB_DMA3ADDRHIGH()		bfin_read16(USB_DMA3ADDRHIGH)
+#define bfin_write_USB_DMA3ADDRHIGH(val)	bfin_write16(USB_DMA3ADDRHIGH, val)
+#define bfin_read_USB_DMA3COUNTLOW()		bfin_read16(USB_DMA3COUNTLOW)
+#define bfin_write_USB_DMA3COUNTLOW(val)	bfin_write16(USB_DMA3COUNTLOW, val)
+#define bfin_read_USB_DMA3COUNTHIGH()		bfin_read16(USB_DMA3COUNTHIGH)
+#define bfin_write_USB_DMA3COUNTHIGH(val)	bfin_write16(USB_DMA3COUNTHIGH, val)
+
+/* USB Channel 4 Config Registers */
+
+#define bfin_read_USB_DMA4CONTROL()		bfin_read16(USB_DMA4CONTROL)
+#define bfin_write_USB_DMA4CONTROL(val)		bfin_write16(USB_DMA4CONTROL, val)
+#define bfin_read_USB_DMA4ADDRLOW()		bfin_read16(USB_DMA4ADDRLOW)
+#define bfin_write_USB_DMA4ADDRLOW(val)		bfin_write16(USB_DMA4ADDRLOW, val)
+#define bfin_read_USB_DMA4ADDRHIGH()		bfin_read16(USB_DMA4ADDRHIGH)
+#define bfin_write_USB_DMA4ADDRHIGH(val)	bfin_write16(USB_DMA4ADDRHIGH, val)
+#define bfin_read_USB_DMA4COUNTLOW()		bfin_read16(USB_DMA4COUNTLOW)
+#define bfin_write_USB_DMA4COUNTLOW(val)	bfin_write16(USB_DMA4COUNTLOW, val)
+#define bfin_read_USB_DMA4COUNTHIGH()		bfin_read16(USB_DMA4COUNTHIGH)
+#define bfin_write_USB_DMA4COUNTHIGH(val)	bfin_write16(USB_DMA4COUNTHIGH, val)
+
+/* USB Channel 5 Config Registers */
+
+#define bfin_read_USB_DMA5CONTROL()		bfin_read16(USB_DMA5CONTROL)
+#define bfin_write_USB_DMA5CONTROL(val)		bfin_write16(USB_DMA5CONTROL, val)
+#define bfin_read_USB_DMA5ADDRLOW()		bfin_read16(USB_DMA5ADDRLOW)
+#define bfin_write_USB_DMA5ADDRLOW(val)		bfin_write16(USB_DMA5ADDRLOW, val)
+#define bfin_read_USB_DMA5ADDRHIGH()		bfin_read16(USB_DMA5ADDRHIGH)
+#define bfin_write_USB_DMA5ADDRHIGH(val)	bfin_write16(USB_DMA5ADDRHIGH, val)
+#define bfin_read_USB_DMA5COUNTLOW()		bfin_read16(USB_DMA5COUNTLOW)
+#define bfin_write_USB_DMA5COUNTLOW(val)	bfin_write16(USB_DMA5COUNTLOW, val)
+#define bfin_read_USB_DMA5COUNTHIGH()		bfin_read16(USB_DMA5COUNTHIGH)
+#define bfin_write_USB_DMA5COUNTHIGH(val)	bfin_write16(USB_DMA5COUNTHIGH, val)
+
+/* USB Channel 6 Config Registers */
+
+#define bfin_read_USB_DMA6CONTROL()		bfin_read16(USB_DMA6CONTROL)
+#define bfin_write_USB_DMA6CONTROL(val)		bfin_write16(USB_DMA6CONTROL, val)
+#define bfin_read_USB_DMA6ADDRLOW()		bfin_read16(USB_DMA6ADDRLOW)
+#define bfin_write_USB_DMA6ADDRLOW(val)		bfin_write16(USB_DMA6ADDRLOW, val)
+#define bfin_read_USB_DMA6ADDRHIGH()		bfin_read16(USB_DMA6ADDRHIGH)
+#define bfin_write_USB_DMA6ADDRHIGH(val)	bfin_write16(USB_DMA6ADDRHIGH, val)
+#define bfin_read_USB_DMA6COUNTLOW()		bfin_read16(USB_DMA6COUNTLOW)
+#define bfin_write_USB_DMA6COUNTLOW(val)	bfin_write16(USB_DMA6COUNTLOW, val)
+#define bfin_read_USB_DMA6COUNTHIGH()		bfin_read16(USB_DMA6COUNTHIGH)
+#define bfin_write_USB_DMA6COUNTHIGH(val)	bfin_write16(USB_DMA6COUNTHIGH, val)
+
+/* USB Channel 7 Config Registers */
+
+#define bfin_read_USB_DMA7CONTROL()		bfin_read16(USB_DMA7CONTROL)
+#define bfin_write_USB_DMA7CONTROL(val)		bfin_write16(USB_DMA7CONTROL, val)
+#define bfin_read_USB_DMA7ADDRLOW()		bfin_read16(USB_DMA7ADDRLOW)
+#define bfin_write_USB_DMA7ADDRLOW(val)		bfin_write16(USB_DMA7ADDRLOW, val)
+#define bfin_read_USB_DMA7ADDRHIGH()		bfin_read16(USB_DMA7ADDRHIGH)
+#define bfin_write_USB_DMA7ADDRHIGH(val)	bfin_write16(USB_DMA7ADDRHIGH, val)
+#define bfin_read_USB_DMA7COUNTLOW()		bfin_read16(USB_DMA7COUNTLOW)
+#define bfin_write_USB_DMA7COUNTLOW(val)	bfin_write16(USB_DMA7COUNTLOW, val)
+#define bfin_read_USB_DMA7COUNTHIGH()		bfin_read16(USB_DMA7COUNTHIGH)
+#define bfin_write_USB_DMA7COUNTHIGH(val)	bfin_write16(USB_DMA7COUNTHIGH, val)
+
+/* Keybfin_read_()ad Registers */
+
+#define bfin_read_KPAD_CTL()		bfin_read16(KPAD_CTL)
+#define bfin_write_KPAD_CTL(val)	bfin_write16(KPAD_CTL, val)
+#define bfin_read_KPAD_PRESCALE()	bfin_read16(KPAD_PRESCALE)
+#define bfin_write_KPAD_PRESCALE(val)	bfin_write16(KPAD_PRESCALE, val)
+#define bfin_read_KPAD_MSEL()		bfin_read16(KPAD_MSEL)
+#define bfin_write_KPAD_MSEL(val)	bfin_write16(KPAD_MSEL, val)
+#define bfin_read_KPAD_ROWCOL()		bfin_read16(KPAD_ROWCOL)
+#define bfin_write_KPAD_ROWCOL(val)	bfin_write16(KPAD_ROWCOL, val)
+#define bfin_read_KPAD_STAT()		bfin_read16(KPAD_STAT)
+#define bfin_write_KPAD_STAT(val)	bfin_write16(KPAD_STAT, val)
+#define bfin_read_KPAD_SOFTEVAL()	bfin_read16(KPAD_SOFTEVAL)
+#define bfin_write_KPAD_SOFTEVAL(val)	bfin_write16(KPAD_SOFTEVAL, val)
+
+/* Pixel Combfin_read_()ositor (PIXC) Registers */
+
+#define bfin_read_PIXC_CTL()		bfin_read16(PIXC_CTL)
+#define bfin_write_PIXC_CTL(val)	bfin_write16(PIXC_CTL, val)
+#define bfin_read_PIXC_PPL()		bfin_read16(PIXC_PPL)
+#define bfin_write_PIXC_PPL(val)	bfin_write16(PIXC_PPL, val)
+#define bfin_read_PIXC_LPF()		bfin_read16(PIXC_LPF)
+#define bfin_write_PIXC_LPF(val)	bfin_write16(PIXC_LPF, val)
+#define bfin_read_PIXC_AHSTART()	bfin_read16(PIXC_AHSTART)
+#define bfin_write_PIXC_AHSTART(val)	bfin_write16(PIXC_AHSTART, val)
+#define bfin_read_PIXC_AHEND()		bfin_read16(PIXC_AHEND)
+#define bfin_write_PIXC_AHEND(val)	bfin_write16(PIXC_AHEND, val)
+#define bfin_read_PIXC_AVSTART()	bfin_read16(PIXC_AVSTART)
+#define bfin_write_PIXC_AVSTART(val)	bfin_write16(PIXC_AVSTART, val)
+#define bfin_read_PIXC_AVEND()		bfin_read16(PIXC_AVEND)
+#define bfin_write_PIXC_AVEND(val)	bfin_write16(PIXC_AVEND, val)
+#define bfin_read_PIXC_ATRANSP()	bfin_read16(PIXC_ATRANSP)
+#define bfin_write_PIXC_ATRANSP(val)	bfin_write16(PIXC_ATRANSP, val)
+#define bfin_read_PIXC_BHSTART()	bfin_read16(PIXC_BHSTART)
+#define bfin_write_PIXC_BHSTART(val)	bfin_write16(PIXC_BHSTART, val)
+#define bfin_read_PIXC_BHEND()		bfin_read16(PIXC_BHEND)
+#define bfin_write_PIXC_BHEND(val)	bfin_write16(PIXC_BHEND, val)
+#define bfin_read_PIXC_BVSTART()	bfin_read16(PIXC_BVSTART)
+#define bfin_write_PIXC_BVSTART(val)	bfin_write16(PIXC_BVSTART, val)
+#define bfin_read_PIXC_BVEND()		bfin_read16(PIXC_BVEND)
+#define bfin_write_PIXC_BVEND(val)	bfin_write16(PIXC_BVEND, val)
+#define bfin_read_PIXC_BTRANSP()	bfin_read16(PIXC_BTRANSP)
+#define bfin_write_PIXC_BTRANSP(val)	bfin_write16(PIXC_BTRANSP, val)
+#define bfin_read_PIXC_INTRSTAT()	bfin_read16(PIXC_INTRSTAT)
+#define bfin_write_PIXC_INTRSTAT(val)	bfin_write16(PIXC_INTRSTAT, val)
+#define bfin_read_PIXC_RYCON()		bfin_read32(PIXC_RYCON)
+#define bfin_write_PIXC_RYCON(val)	bfin_write32(PIXC_RYCON, val)
+#define bfin_read_PIXC_GUCON()		bfin_read32(PIXC_GUCON)
+#define bfin_write_PIXC_GUCON(val)	bfin_write32(PIXC_GUCON, val)
+#define bfin_read_PIXC_BVCON()		bfin_read32(PIXC_BVCON)
+#define bfin_write_PIXC_BVCON(val)	bfin_write32(PIXC_BVCON, val)
+#define bfin_read_PIXC_CCBIAS()		bfin_read32(PIXC_CCBIAS)
+#define bfin_write_PIXC_CCBIAS(val)	bfin_write32(PIXC_CCBIAS, val)
+#define bfin_read_PIXC_TC()		bfin_read32(PIXC_TC)
+#define bfin_write_PIXC_TC(val)		bfin_write32(PIXC_TC, val)
+
+/* Handshake MDMA 0 Registers */
+
+#define bfin_read_HMDMA0_CONTROL()		bfin_read16(HMDMA0_CONTROL)
+#define bfin_write_HMDMA0_CONTROL(val)		bfin_write16(HMDMA0_CONTROL, val)
+#define bfin_read_HMDMA0_ECINIT()		bfin_read16(HMDMA0_ECINIT)
+#define bfin_write_HMDMA0_ECINIT(val)		bfin_write16(HMDMA0_ECINIT, val)
+#define bfin_read_HMDMA0_BCINIT()		bfin_read16(HMDMA0_BCINIT)
+#define bfin_write_HMDMA0_BCINIT(val)		bfin_write16(HMDMA0_BCINIT, val)
+#define bfin_read_HMDMA0_ECURGENT()		bfin_read16(HMDMA0_ECURGENT)
+#define bfin_write_HMDMA0_ECURGENT(val)		bfin_write16(HMDMA0_ECURGENT, val)
+#define bfin_read_HMDMA0_ECOVERFLOW()		bfin_read16(HMDMA0_ECOVERFLOW)
+#define bfin_write_HMDMA0_ECOVERFLOW(val)	bfin_write16(HMDMA0_ECOVERFLOW, val)
+#define bfin_read_HMDMA0_ECOUNT()		bfin_read16(HMDMA0_ECOUNT)
+#define bfin_write_HMDMA0_ECOUNT(val)		bfin_write16(HMDMA0_ECOUNT, val)
+#define bfin_read_HMDMA0_BCOUNT()		bfin_read16(HMDMA0_BCOUNT)
+#define bfin_write_HMDMA0_BCOUNT(val)		bfin_write16(HMDMA0_BCOUNT, val)
+
+/* Handshake MDMA 1 Registers */
+
+#define bfin_read_HMDMA1_CONTROL()		bfin_read16(HMDMA1_CONTROL)
+#define bfin_write_HMDMA1_CONTROL(val)		bfin_write16(HMDMA1_CONTROL, val)
+#define bfin_read_HMDMA1_ECINIT()		bfin_read16(HMDMA1_ECINIT)
+#define bfin_write_HMDMA1_ECINIT(val)		bfin_write16(HMDMA1_ECINIT, val)
+#define bfin_read_HMDMA1_BCINIT()		bfin_read16(HMDMA1_BCINIT)
+#define bfin_write_HMDMA1_BCINIT(val)		bfin_write16(HMDMA1_BCINIT, val)
+#define bfin_read_HMDMA1_ECURGENT()		bfin_read16(HMDMA1_ECURGENT)
+#define bfin_write_HMDMA1_ECURGENT(val)		bfin_write16(HMDMA1_ECURGENT, val)
+#define bfin_read_HMDMA1_ECOVERFLOW()		bfin_read16(HMDMA1_ECOVERFLOW)
+#define bfin_write_HMDMA1_ECOVERFLOW(val)	bfin_write16(HMDMA1_ECOVERFLOW, val)
+#define bfin_read_HMDMA1_ECOUNT()		bfin_read16(HMDMA1_ECOUNT)
+#define bfin_write_HMDMA1_ECOUNT(val)		bfin_write16(HMDMA1_ECOUNT, val)
+#define bfin_read_HMDMA1_BCOUNT()		bfin_read16(HMDMA1_BCOUNT)
+#define bfin_write_HMDMA1_BCOUNT(val)		bfin_write16(HMDMA1_BCOUNT, val)
+
+#endif /* _CDEF_BF548_H */
diff --git a/include/asm-blackfin/mach-bf548/cdefBF549.h b/include/asm-blackfin/mach-bf548/cdefBF549.h
new file mode 100644
index 0000000..2ab5b7c
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/cdefBF549.h
@@ -0,0 +1,1896 @@
+/*
+ * File:         include/asm-blackfin/mach-bf549/cdefBF549.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF549_H
+#define _CDEF_BF549_H
+
+/* include all Core registers and bit definitions */
+#include "defBF549.h"
+
+/* include core sbfin_read_()ecific register pointer definitions */
+#include <asm/mach-common/cdef_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF549 */
+
+/* include cdefBF54x_base.h for the set of #defines that are common to all ADSP-BF54x bfin_read_()rocessors */
+#include "cdefBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF549 that are not in the common header */
+
+/* Timer Registers */
+
+#define bfin_read_TIMER8_CONFIG()		bfin_read16(TIMER8_CONFIG)
+#define bfin_write_TIMER8_CONFIG(val)		bfin_write16(TIMER8_CONFIG, val)
+#define bfin_read_TIMER8_COUNTER()		bfin_read32(TIMER8_COUNTER)
+#define bfin_write_TIMER8_COUNTER(val)		bfin_write32(TIMER8_COUNTER, val)
+#define bfin_read_TIMER8_PERIOD()		bfin_read32(TIMER8_PERIOD)
+#define bfin_write_TIMER8_PERIOD(val)		bfin_write32(TIMER8_PERIOD, val)
+#define bfin_read_TIMER8_WIDTH()		bfin_read32(TIMER8_WIDTH)
+#define bfin_write_TIMER8_WIDTH(val)		bfin_write32(TIMER8_WIDTH, val)
+#define bfin_read_TIMER9_CONFIG()		bfin_read16(TIMER9_CONFIG)
+#define bfin_write_TIMER9_CONFIG(val)		bfin_write16(TIMER9_CONFIG, val)
+#define bfin_read_TIMER9_COUNTER()		bfin_read32(TIMER9_COUNTER)
+#define bfin_write_TIMER9_COUNTER(val)		bfin_write32(TIMER9_COUNTER, val)
+#define bfin_read_TIMER9_PERIOD()		bfin_read32(TIMER9_PERIOD)
+#define bfin_write_TIMER9_PERIOD(val)		bfin_write32(TIMER9_PERIOD, val)
+#define bfin_read_TIMER9_WIDTH()		bfin_read32(TIMER9_WIDTH)
+#define bfin_write_TIMER9_WIDTH(val)		bfin_write32(TIMER9_WIDTH, val)
+#define bfin_read_TIMER10_CONFIG()		bfin_read16(TIMER10_CONFIG)
+#define bfin_write_TIMER10_CONFIG(val)		bfin_write16(TIMER10_CONFIG, val)
+#define bfin_read_TIMER10_COUNTER()		bfin_read32(TIMER10_COUNTER)
+#define bfin_write_TIMER10_COUNTER(val)		bfin_write32(TIMER10_COUNTER, val)
+#define bfin_read_TIMER10_PERIOD()		bfin_read32(TIMER10_PERIOD)
+#define bfin_write_TIMER10_PERIOD(val)		bfin_write32(TIMER10_PERIOD, val)
+#define bfin_read_TIMER10_WIDTH()		bfin_read32(TIMER10_WIDTH)
+#define bfin_write_TIMER10_WIDTH(val)		bfin_write32(TIMER10_WIDTH, val)
+
+/* Timer Groubfin_read_() of 3 */
+
+#define bfin_read_TIMER_ENABLE1()		bfin_read16(TIMER_ENABLE1)
+#define bfin_write_TIMER_ENABLE1(val)		bfin_write16(TIMER_ENABLE1, val)
+#define bfin_read_TIMER_DISABLE1()		bfin_read16(TIMER_DISABLE1)
+#define bfin_write_TIMER_DISABLE1(val)		bfin_write16(TIMER_DISABLE1, val)
+#define bfin_read_TIMER_STATUS1()		bfin_read32(TIMER_STATUS1)
+#define bfin_write_TIMER_STATUS1(val)		bfin_write32(TIMER_STATUS1, val)
+
+/* SPORT0 Registers */
+
+#define bfin_read_SPORT0_TCR1()			bfin_read16(SPORT0_TCR1)
+#define bfin_write_SPORT0_TCR1(val)		bfin_write16(SPORT0_TCR1, val)
+#define bfin_read_SPORT0_TCR2()			bfin_read16(SPORT0_TCR2)
+#define bfin_write_SPORT0_TCR2(val)		bfin_write16(SPORT0_TCR2, val)
+#define bfin_read_SPORT0_TCLKDIV()		bfin_read16(SPORT0_TCLKDIV)
+#define bfin_write_SPORT0_TCLKDIV(val)		bfin_write16(SPORT0_TCLKDIV, val)
+#define bfin_read_SPORT0_TFSDIV()		bfin_read16(SPORT0_TFSDIV)
+#define bfin_write_SPORT0_TFSDIV(val)		bfin_write16(SPORT0_TFSDIV, val)
+#define bfin_read_SPORT0_TX()			bfin_read32(SPORT0_TX)
+#define bfin_write_SPORT0_TX(val)		bfin_write32(SPORT0_TX, val)
+#define bfin_read_SPORT0_RX()			bfin_read32(SPORT0_RX)
+#define bfin_write_SPORT0_RX(val)		bfin_write32(SPORT0_RX, val)
+#define bfin_read_SPORT0_RCR1()			bfin_read16(SPORT0_RCR1)
+#define bfin_write_SPORT0_RCR1(val)		bfin_write16(SPORT0_RCR1, val)
+#define bfin_read_SPORT0_RCR2()			bfin_read16(SPORT0_RCR2)
+#define bfin_write_SPORT0_RCR2(val)		bfin_write16(SPORT0_RCR2, val)
+#define bfin_read_SPORT0_RCLKDIV()		bfin_read16(SPORT0_RCLKDIV)
+#define bfin_write_SPORT0_RCLKDIV(val)		bfin_write16(SPORT0_RCLKDIV, val)
+#define bfin_read_SPORT0_RFSDIV()		bfin_read16(SPORT0_RFSDIV)
+#define bfin_write_SPORT0_RFSDIV(val)		bfin_write16(SPORT0_RFSDIV, val)
+#define bfin_read_SPORT0_STAT()			bfin_read16(SPORT0_STAT)
+#define bfin_write_SPORT0_STAT(val)		bfin_write16(SPORT0_STAT, val)
+#define bfin_read_SPORT0_CHNL()			bfin_read16(SPORT0_CHNL)
+#define bfin_write_SPORT0_CHNL(val)		bfin_write16(SPORT0_CHNL, val)
+#define bfin_read_SPORT0_MCMC1()		bfin_read16(SPORT0_MCMC1)
+#define bfin_write_SPORT0_MCMC1(val)		bfin_write16(SPORT0_MCMC1, val)
+#define bfin_read_SPORT0_MCMC2()		bfin_read16(SPORT0_MCMC2)
+#define bfin_write_SPORT0_MCMC2(val)		bfin_write16(SPORT0_MCMC2, val)
+#define bfin_read_SPORT0_MTCS0()		bfin_read32(SPORT0_MTCS0)
+#define bfin_write_SPORT0_MTCS0(val)		bfin_write32(SPORT0_MTCS0, val)
+#define bfin_read_SPORT0_MTCS1()		bfin_read32(SPORT0_MTCS1)
+#define bfin_write_SPORT0_MTCS1(val)		bfin_write32(SPORT0_MTCS1, val)
+#define bfin_read_SPORT0_MTCS2()		bfin_read32(SPORT0_MTCS2)
+#define bfin_write_SPORT0_MTCS2(val)		bfin_write32(SPORT0_MTCS2, val)
+#define bfin_read_SPORT0_MTCS3()		bfin_read32(SPORT0_MTCS3)
+#define bfin_write_SPORT0_MTCS3(val)		bfin_write32(SPORT0_MTCS3, val)
+#define bfin_read_SPORT0_MRCS0()		bfin_read32(SPORT0_MRCS0)
+#define bfin_write_SPORT0_MRCS0(val)		bfin_write32(SPORT0_MRCS0, val)
+#define bfin_read_SPORT0_MRCS1()		bfin_read32(SPORT0_MRCS1)
+#define bfin_write_SPORT0_MRCS1(val)		bfin_write32(SPORT0_MRCS1, val)
+#define bfin_read_SPORT0_MRCS2()		bfin_read32(SPORT0_MRCS2)
+#define bfin_write_SPORT0_MRCS2(val)		bfin_write32(SPORT0_MRCS2, val)
+#define bfin_read_SPORT0_MRCS3()		bfin_read32(SPORT0_MRCS3)
+#define bfin_write_SPORT0_MRCS3(val)		bfin_write32(SPORT0_MRCS3, val)
+
+/* EPPI0 Registers */
+
+#define bfin_read_EPPI0_STATUS()		bfin_read16(EPPI0_STATUS)
+#define bfin_write_EPPI0_STATUS(val)		bfin_write16(EPPI0_STATUS, val)
+#define bfin_read_EPPI0_HCOUNT()		bfin_read16(EPPI0_HCOUNT)
+#define bfin_write_EPPI0_HCOUNT(val)		bfin_write16(EPPI0_HCOUNT, val)
+#define bfin_read_EPPI0_HDELAY()		bfin_read16(EPPI0_HDELAY)
+#define bfin_write_EPPI0_HDELAY(val)		bfin_write16(EPPI0_HDELAY, val)
+#define bfin_read_EPPI0_VCOUNT()		bfin_read16(EPPI0_VCOUNT)
+#define bfin_write_EPPI0_VCOUNT(val)		bfin_write16(EPPI0_VCOUNT, val)
+#define bfin_read_EPPI0_VDELAY()		bfin_read16(EPPI0_VDELAY)
+#define bfin_write_EPPI0_VDELAY(val)		bfin_write16(EPPI0_VDELAY, val)
+#define bfin_read_EPPI0_FRAME()			bfin_read16(EPPI0_FRAME)
+#define bfin_write_EPPI0_FRAME(val)		bfin_write16(EPPI0_FRAME, val)
+#define bfin_read_EPPI0_LINE()			bfin_read16(EPPI0_LINE)
+#define bfin_write_EPPI0_LINE(val)		bfin_write16(EPPI0_LINE, val)
+#define bfin_read_EPPI0_CLKDIV()		bfin_read16(EPPI0_CLKDIV)
+#define bfin_write_EPPI0_CLKDIV(val)		bfin_write16(EPPI0_CLKDIV, val)
+#define bfin_read_EPPI0_CONTROL()		bfin_read32(EPPI0_CONTROL)
+#define bfin_write_EPPI0_CONTROL(val)		bfin_write32(EPPI0_CONTROL, val)
+#define bfin_read_EPPI0_FS1W_HBL()		bfin_read32(EPPI0_FS1W_HBL)
+#define bfin_write_EPPI0_FS1W_HBL(val)		bfin_write32(EPPI0_FS1W_HBL, val)
+#define bfin_read_EPPI0_FS1P_AVPL()		bfin_read32(EPPI0_FS1P_AVPL)
+#define bfin_write_EPPI0_FS1P_AVPL(val)		bfin_write32(EPPI0_FS1P_AVPL, val)
+#define bfin_read_EPPI0_FS2W_LVB()		bfin_read32(EPPI0_FS2W_LVB)
+#define bfin_write_EPPI0_FS2W_LVB(val)		bfin_write32(EPPI0_FS2W_LVB, val)
+#define bfin_read_EPPI0_FS2P_LAVF()		bfin_read32(EPPI0_FS2P_LAVF)
+#define bfin_write_EPPI0_FS2P_LAVF(val)		bfin_write32(EPPI0_FS2P_LAVF, val)
+#define bfin_read_EPPI0_CLIP()			bfin_read32(EPPI0_CLIP)
+#define bfin_write_EPPI0_CLIP(val)		bfin_write32(EPPI0_CLIP, val)
+
+/* UART2 Registers */
+
+#define bfin_read_UART2_DLL()			bfin_read16(UART2_DLL)
+#define bfin_write_UART2_DLL(val)		bfin_write16(UART2_DLL, val)
+#define bfin_read_UART2_DLH()			bfin_read16(UART2_DLH)
+#define bfin_write_UART2_DLH(val)		bfin_write16(UART2_DLH, val)
+#define bfin_read_UART2_GCTL()			bfin_read16(UART2_GCTL)
+#define bfin_write_UART2_GCTL(val)		bfin_write16(UART2_GCTL, val)
+#define bfin_read_UART2_LCR()			bfin_read16(UART2_LCR)
+#define bfin_write_UART2_LCR(val)		bfin_write16(UART2_LCR, val)
+#define bfin_read_UART2_MCR()			bfin_read16(UART2_MCR)
+#define bfin_write_UART2_MCR(val)		bfin_write16(UART2_MCR, val)
+#define bfin_read_UART2_LSR()			bfin_read16(UART2_LSR)
+#define bfin_write_UART2_LSR(val)		bfin_write16(UART2_LSR, val)
+#define bfin_read_UART2_MSR()			bfin_read16(UART2_MSR)
+#define bfin_write_UART2_MSR(val)		bfin_write16(UART2_MSR, val)
+#define bfin_read_UART2_SCR()			bfin_read16(UART2_SCR)
+#define bfin_write_UART2_SCR(val)		bfin_write16(UART2_SCR, val)
+#define bfin_read_UART2_IER_SET()		bfin_read16(UART2_IER_SET)
+#define bfin_write_UART2_IER_SET(val)		bfin_write16(UART2_IER_SET, val)
+#define bfin_read_UART2_IER_CLEAR()		bfin_read16(UART2_IER_CLEAR)
+#define bfin_write_UART2_IER_CLEAR(val)		bfin_write16(UART2_IER_CLEAR, val)
+#define bfin_read_UART2_RBR()			bfin_read16(UART2_RBR)
+#define bfin_write_UART2_RBR(val)		bfin_write16(UART2_RBR, val)
+
+/* Two Wire Interface Registers (TWI1) */
+
+#define bfin_read_TWI1_CLKDIV()			bfin_read16(TWI1_CLKDIV)
+#define bfin_write_TWI1_CLKDIV(val)		bfin_write16(TWI1_CLKDIV, val)
+#define bfin_read_TWI1_CONTROL()		bfin_read16(TWI1_CONTROL)
+#define bfin_write_TWI1_CONTROL(val)		bfin_write16(TWI1_CONTROL, val)
+#define bfin_read_TWI1_SLAVE_CTRL()		bfin_read16(TWI1_SLAVE_CTRL)
+#define bfin_write_TWI1_SLAVE_CTRL(val)		bfin_write16(TWI1_SLAVE_CTRL, val)
+#define bfin_read_TWI1_SLAVE_STAT()		bfin_read16(TWI1_SLAVE_STAT)
+#define bfin_write_TWI1_SLAVE_STAT(val)		bfin_write16(TWI1_SLAVE_STAT, val)
+#define bfin_read_TWI1_SLAVE_ADDR()		bfin_read16(TWI1_SLAVE_ADDR)
+#define bfin_write_TWI1_SLAVE_ADDR(val)		bfin_write16(TWI1_SLAVE_ADDR, val)
+#define bfin_read_TWI1_MASTER_CTRL()		bfin_read16(TWI1_MASTER_CTRL)
+#define bfin_write_TWI1_MASTER_CTRL(val)	bfin_write16(TWI1_MASTER_CTRL, val)
+#define bfin_read_TWI1_MASTER_STAT()		bfin_read16(TWI1_MASTER_STAT)
+#define bfin_write_TWI1_MASTER_STAT(val)	bfin_write16(TWI1_MASTER_STAT, val)
+#define bfin_read_TWI1_MASTER_ADDR()		bfin_read16(TWI1_MASTER_ADDR)
+#define bfin_write_TWI1_MASTER_ADDR(val)	bfin_write16(TWI1_MASTER_ADDR, val)
+#define bfin_read_TWI1_INT_STAT()		bfin_read16(TWI1_INT_STAT)
+#define bfin_write_TWI1_INT_STAT(val)		bfin_write16(TWI1_INT_STAT, val)
+#define bfin_read_TWI1_INT_MASK()		bfin_read16(TWI1_INT_MASK)
+#define bfin_write_TWI1_INT_MASK(val)		bfin_write16(TWI1_INT_MASK, val)
+#define bfin_read_TWI1_FIFO_CTRL()		bfin_read16(TWI1_FIFO_CTRL)
+#define bfin_write_TWI1_FIFO_CTRL(val)		bfin_write16(TWI1_FIFO_CTRL, val)
+#define bfin_read_TWI1_FIFO_STAT()		bfin_read16(TWI1_FIFO_STAT)
+#define bfin_write_TWI1_FIFO_STAT(val)		bfin_write16(TWI1_FIFO_STAT, val)
+#define bfin_read_TWI1_XMT_DATA8()		bfin_read16(TWI1_XMT_DATA8)
+#define bfin_write_TWI1_XMT_DATA8(val)		bfin_write16(TWI1_XMT_DATA8, val)
+#define bfin_read_TWI1_XMT_DATA16()		bfin_read16(TWI1_XMT_DATA16)
+#define bfin_write_TWI1_XMT_DATA16(val)		bfin_write16(TWI1_XMT_DATA16, val)
+#define bfin_read_TWI1_RCV_DATA8()		bfin_read16(TWI1_RCV_DATA8)
+#define bfin_write_TWI1_RCV_DATA8(val)		bfin_write16(TWI1_RCV_DATA8, val)
+#define bfin_read_TWI1_RCV_DATA16()		bfin_read16(TWI1_RCV_DATA16)
+#define bfin_write_TWI1_RCV_DATA16(val)		bfin_write16(TWI1_RCV_DATA16, val)
+
+/* SPI2 Registers */
+
+#define bfin_read_SPI2_CTL()		bfin_read16(SPI2_CTL)
+#define bfin_write_SPI2_CTL(val)	bfin_write16(SPI2_CTL, val)
+#define bfin_read_SPI2_FLG()		bfin_read16(SPI2_FLG)
+#define bfin_write_SPI2_FLG(val)	bfin_write16(SPI2_FLG, val)
+#define bfin_read_SPI2_STAT()		bfin_read16(SPI2_STAT)
+#define bfin_write_SPI2_STAT(val)	bfin_write16(SPI2_STAT, val)
+#define bfin_read_SPI2_TDBR()		bfin_read16(SPI2_TDBR)
+#define bfin_write_SPI2_TDBR(val)	bfin_write16(SPI2_TDBR, val)
+#define bfin_read_SPI2_RDBR()		bfin_read16(SPI2_RDBR)
+#define bfin_write_SPI2_RDBR(val)	bfin_write16(SPI2_RDBR, val)
+#define bfin_read_SPI2_BAUD()		bfin_read16(SPI2_BAUD)
+#define bfin_write_SPI2_BAUD(val)	bfin_write16(SPI2_BAUD, val)
+#define bfin_read_SPI2_SHADOW()		bfin_read16(SPI2_SHADOW)
+#define bfin_write_SPI2_SHADOW(val)	bfin_write16(SPI2_SHADOW, val)
+
+/* MXVR Registers */
+
+#define bfin_read_MXVR_CONFIG()			bfin_read16(MXVR_CONFIG)
+#define bfin_write_MXVR_CONFIG(val)		bfin_write16(MXVR_CONFIG, val)
+#define bfin_read_MXVR_STATE_0()		bfin_read32(MXVR_STATE_0)
+#define bfin_write_MXVR_STATE_0(val)		bfin_write32(MXVR_STATE_0, val)
+#define bfin_read_MXVR_STATE_1()		bfin_read32(MXVR_STATE_1)
+#define bfin_write_MXVR_STATE_1(val)		bfin_write32(MXVR_STATE_1, val)
+#define bfin_read_MXVR_INT_STAT_0()		bfin_read32(MXVR_INT_STAT_0)
+#define bfin_write_MXVR_INT_STAT_0(val)		bfin_write32(MXVR_INT_STAT_0, val)
+#define bfin_read_MXVR_INT_STAT_1()		bfin_read32(MXVR_INT_STAT_1)
+#define bfin_write_MXVR_INT_STAT_1(val)		bfin_write32(MXVR_INT_STAT_1, val)
+#define bfin_read_MXVR_INT_EN_0()		bfin_read32(MXVR_INT_EN_0)
+#define bfin_write_MXVR_INT_EN_0(val)		bfin_write32(MXVR_INT_EN_0, val)
+#define bfin_read_MXVR_INT_EN_1()		bfin_read32(MXVR_INT_EN_1)
+#define bfin_write_MXVR_INT_EN_1(val)		bfin_write32(MXVR_INT_EN_1, val)
+#define bfin_read_MXVR_POSITION()		bfin_read16(MXVR_POSITION)
+#define bfin_write_MXVR_POSITION(val)		bfin_write16(MXVR_POSITION, val)
+#define bfin_read_MXVR_MAX_POSITION()		bfin_read16(MXVR_MAX_POSITION)
+#define bfin_write_MXVR_MAX_POSITION(val)	bfin_write16(MXVR_MAX_POSITION, val)
+#define bfin_read_MXVR_DELAY()			bfin_read16(MXVR_DELAY)
+#define bfin_write_MXVR_DELAY(val)		bfin_write16(MXVR_DELAY, val)
+#define bfin_read_MXVR_MAX_DELAY()		bfin_read16(MXVR_MAX_DELAY)
+#define bfin_write_MXVR_MAX_DELAY(val)		bfin_write16(MXVR_MAX_DELAY, val)
+#define bfin_read_MXVR_LADDR()			bfin_read32(MXVR_LADDR)
+#define bfin_write_MXVR_LADDR(val)		bfin_write32(MXVR_LADDR, val)
+#define bfin_read_MXVR_GADDR()			bfin_read16(MXVR_GADDR)
+#define bfin_write_MXVR_GADDR(val)		bfin_write16(MXVR_GADDR, val)
+#define bfin_read_MXVR_AADDR()			bfin_read32(MXVR_AADDR)
+#define bfin_write_MXVR_AADDR(val)		bfin_write32(MXVR_AADDR, val)
+
+/* MXVR Allocation Table Registers */
+
+#define bfin_read_MXVR_ALLOC_0()		bfin_read32(MXVR_ALLOC_0)
+#define bfin_write_MXVR_ALLOC_0(val)		bfin_write32(MXVR_ALLOC_0, val)
+#define bfin_read_MXVR_ALLOC_1()		bfin_read32(MXVR_ALLOC_1)
+#define bfin_write_MXVR_ALLOC_1(val)		bfin_write32(MXVR_ALLOC_1, val)
+#define bfin_read_MXVR_ALLOC_2()		bfin_read32(MXVR_ALLOC_2)
+#define bfin_write_MXVR_ALLOC_2(val)		bfin_write32(MXVR_ALLOC_2, val)
+#define bfin_read_MXVR_ALLOC_3()		bfin_read32(MXVR_ALLOC_3)
+#define bfin_write_MXVR_ALLOC_3(val)		bfin_write32(MXVR_ALLOC_3, val)
+#define bfin_read_MXVR_ALLOC_4()		bfin_read32(MXVR_ALLOC_4)
+#define bfin_write_MXVR_ALLOC_4(val)		bfin_write32(MXVR_ALLOC_4, val)
+#define bfin_read_MXVR_ALLOC_5()		bfin_read32(MXVR_ALLOC_5)
+#define bfin_write_MXVR_ALLOC_5(val)		bfin_write32(MXVR_ALLOC_5, val)
+#define bfin_read_MXVR_ALLOC_6()		bfin_read32(MXVR_ALLOC_6)
+#define bfin_write_MXVR_ALLOC_6(val)		bfin_write32(MXVR_ALLOC_6, val)
+#define bfin_read_MXVR_ALLOC_7()		bfin_read32(MXVR_ALLOC_7)
+#define bfin_write_MXVR_ALLOC_7(val)		bfin_write32(MXVR_ALLOC_7, val)
+#define bfin_read_MXVR_ALLOC_8()		bfin_read32(MXVR_ALLOC_8)
+#define bfin_write_MXVR_ALLOC_8(val)		bfin_write32(MXVR_ALLOC_8, val)
+#define bfin_read_MXVR_ALLOC_9()		bfin_read32(MXVR_ALLOC_9)
+#define bfin_write_MXVR_ALLOC_9(val)		bfin_write32(MXVR_ALLOC_9, val)
+#define bfin_read_MXVR_ALLOC_10()		bfin_read32(MXVR_ALLOC_10)
+#define bfin_write_MXVR_ALLOC_10(val)		bfin_write32(MXVR_ALLOC_10, val)
+#define bfin_read_MXVR_ALLOC_11()		bfin_read32(MXVR_ALLOC_11)
+#define bfin_write_MXVR_ALLOC_11(val)		bfin_write32(MXVR_ALLOC_11, val)
+#define bfin_read_MXVR_ALLOC_12()		bfin_read32(MXVR_ALLOC_12)
+#define bfin_write_MXVR_ALLOC_12(val)		bfin_write32(MXVR_ALLOC_12, val)
+#define bfin_read_MXVR_ALLOC_13()		bfin_read32(MXVR_ALLOC_13)
+#define bfin_write_MXVR_ALLOC_13(val)		bfin_write32(MXVR_ALLOC_13, val)
+#define bfin_read_MXVR_ALLOC_14()		bfin_read32(MXVR_ALLOC_14)
+#define bfin_write_MXVR_ALLOC_14(val)		bfin_write32(MXVR_ALLOC_14, val)
+
+/* MXVR Channel Assign Registers */
+
+#define bfin_read_MXVR_SYNC_LCHAN_0()		bfin_read32(MXVR_SYNC_LCHAN_0)
+#define bfin_write_MXVR_SYNC_LCHAN_0(val)	bfin_write32(MXVR_SYNC_LCHAN_0, val)
+#define bfin_read_MXVR_SYNC_LCHAN_1()		bfin_read32(MXVR_SYNC_LCHAN_1)
+#define bfin_write_MXVR_SYNC_LCHAN_1(val)	bfin_write32(MXVR_SYNC_LCHAN_1, val)
+#define bfin_read_MXVR_SYNC_LCHAN_2()		bfin_read32(MXVR_SYNC_LCHAN_2)
+#define bfin_write_MXVR_SYNC_LCHAN_2(val)	bfin_write32(MXVR_SYNC_LCHAN_2, val)
+#define bfin_read_MXVR_SYNC_LCHAN_3()		bfin_read32(MXVR_SYNC_LCHAN_3)
+#define bfin_write_MXVR_SYNC_LCHAN_3(val)	bfin_write32(MXVR_SYNC_LCHAN_3, val)
+#define bfin_read_MXVR_SYNC_LCHAN_4()		bfin_read32(MXVR_SYNC_LCHAN_4)
+#define bfin_write_MXVR_SYNC_LCHAN_4(val)	bfin_write32(MXVR_SYNC_LCHAN_4, val)
+#define bfin_read_MXVR_SYNC_LCHAN_5()		bfin_read32(MXVR_SYNC_LCHAN_5)
+#define bfin_write_MXVR_SYNC_LCHAN_5(val)	bfin_write32(MXVR_SYNC_LCHAN_5, val)
+#define bfin_read_MXVR_SYNC_LCHAN_6()		bfin_read32(MXVR_SYNC_LCHAN_6)
+#define bfin_write_MXVR_SYNC_LCHAN_6(val)	bfin_write32(MXVR_SYNC_LCHAN_6, val)
+#define bfin_read_MXVR_SYNC_LCHAN_7()		bfin_read32(MXVR_SYNC_LCHAN_7)
+#define bfin_write_MXVR_SYNC_LCHAN_7(val)	bfin_write32(MXVR_SYNC_LCHAN_7, val)
+
+/* MXVR DMA0 Registers */
+
+#define bfin_read_MXVR_DMA0_CONFIG()		bfin_read32(MXVR_DMA0_CONFIG)
+#define bfin_write_MXVR_DMA0_CONFIG(val)	bfin_write32(MXVR_DMA0_CONFIG, val)
+#define bfin_read_MXVR_DMA0_START_ADDR()	bfin_read32(MXVR_DMA0_START_ADDR)
+#define bfin_write_MXVR_DMA0_START_ADDR(val)	bfin_write32(MXVR_DMA0_START_ADDR)
+#define bfin_read_MXVR_DMA0_COUNT()		bfin_read16(MXVR_DMA0_COUNT)
+#define bfin_write_MXVR_DMA0_COUNT(val)		bfin_write16(MXVR_DMA0_COUNT, val)
+#define bfin_read_MXVR_DMA0_CURR_ADDR()		bfin_read32(MXVR_DMA0_CURR_ADDR)
+#define bfin_write_MXVR_DMA0_CURR_ADDR(val)	bfin_write32(MXVR_DMA0_CURR_ADDR)
+#define bfin_read_MXVR_DMA0_CURR_COUNT()	bfin_read16(MXVR_DMA0_CURR_COUNT)
+#define bfin_write_MXVR_DMA0_CURR_COUNT(val)	bfin_write16(MXVR_DMA0_CURR_COUNT, val)
+
+/* MXVR DMA1 Registers */
+
+#define bfin_read_MXVR_DMA1_CONFIG()		bfin_read32(MXVR_DMA1_CONFIG)
+#define bfin_write_MXVR_DMA1_CONFIG(val)	bfin_write32(MXVR_DMA1_CONFIG, val)
+#define bfin_read_MXVR_DMA1_START_ADDR()	bfin_read32(MXVR_DMA1_START_ADDR)
+#define bfin_write_MXVR_DMA1_START_ADDR(val)	bfin_write32(MXVR_DMA1_START_ADDR)
+#define bfin_read_MXVR_DMA1_COUNT()		bfin_read16(MXVR_DMA1_COUNT)
+#define bfin_write_MXVR_DMA1_COUNT(val)		bfin_write16(MXVR_DMA1_COUNT, val)
+#define bfin_read_MXVR_DMA1_CURR_ADDR()		bfin_read32(MXVR_DMA1_CURR_ADDR)
+#define bfin_write_MXVR_DMA1_CURR_ADDR(val)	bfin_write32(MXVR_DMA1_CURR_ADDR)
+#define bfin_read_MXVR_DMA1_CURR_COUNT()	bfin_read16(MXVR_DMA1_CURR_COUNT)
+#define bfin_write_MXVR_DMA1_CURR_COUNT(val)	bfin_write16(MXVR_DMA1_CURR_COUNT, val)
+
+/* MXVR DMA2 Registers */
+
+#define bfin_read_MXVR_DMA2_CONFIG()		bfin_read32(MXVR_DMA2_CONFIG)
+#define bfin_write_MXVR_DMA2_CONFIG(val)	bfin_write32(MXVR_DMA2_CONFIG, val)
+#define bfin_read_MXVR_DMA2_START_ADDR() 	bfin_read32(MXVR_DMA2_START_ADDR)
+#define bfin_write_MXVR_DMA2_START_ADDR(val) 	bfin_write32(MXVR_DMA2_START_ADDR)
+#define bfin_read_MXVR_DMA2_COUNT()		bfin_read16(MXVR_DMA2_COUNT)
+#define bfin_write_MXVR_DMA2_COUNT(val)		bfin_write16(MXVR_DMA2_COUNT, val)
+#define bfin_read_MXVR_DMA2_CURR_ADDR() 	bfin_read32(MXVR_DMA2_CURR_ADDR)
+#define bfin_write_MXVR_DMA2_CURR_ADDR(val) 	bfin_write32(MXVR_DMA2_CURR_ADDR)
+#define bfin_read_MXVR_DMA2_CURR_COUNT()	bfin_read16(MXVR_DMA2_CURR_COUNT)
+#define bfin_write_MXVR_DMA2_CURR_COUNT(val)	bfin_write16(MXVR_DMA2_CURR_COUNT, val)
+
+/* MXVR DMA3 Registers */
+
+#define bfin_read_MXVR_DMA3_CONFIG()		bfin_read32(MXVR_DMA3_CONFIG)
+#define bfin_write_MXVR_DMA3_CONFIG(val)	bfin_write32(MXVR_DMA3_CONFIG, val)
+#define bfin_read_MXVR_DMA3_START_ADDR() 	bfin_read32(MXVR_DMA3_START_ADDR)
+#define bfin_write_MXVR_DMA3_START_ADDR(val) 	bfin_write32(MXVR_DMA3_START_ADDR)
+#define bfin_read_MXVR_DMA3_COUNT()		bfin_read16(MXVR_DMA3_COUNT)
+#define bfin_write_MXVR_DMA3_COUNT(val)		bfin_write16(MXVR_DMA3_COUNT, val)
+#define bfin_read_MXVR_DMA3_CURR_ADDR() 	bfin_read32(MXVR_DMA3_CURR_ADDR)
+#define bfin_write_MXVR_DMA3_CURR_ADDR(val) 	bfin_write32(MXVR_DMA3_CURR_ADDR)
+#define bfin_read_MXVR_DMA3_CURR_COUNT()	bfin_read16(MXVR_DMA3_CURR_COUNT)
+#define bfin_write_MXVR_DMA3_CURR_COUNT(val)	bfin_write16(MXVR_DMA3_CURR_COUNT, val)
+
+/* MXVR DMA4 Registers */
+
+#define bfin_read_MXVR_DMA4_CONFIG()		bfin_read32(MXVR_DMA4_CONFIG)
+#define bfin_write_MXVR_DMA4_CONFIG(val)	bfin_write32(MXVR_DMA4_CONFIG, val)
+#define bfin_read_MXVR_DMA4_START_ADDR() 	bfin_read32(MXVR_DMA4_START_ADDR)
+#define bfin_write_MXVR_DMA4_START_ADDR(val) 	bfin_write32(MXVR_DMA4_START_ADDR)
+#define bfin_read_MXVR_DMA4_COUNT()		bfin_read16(MXVR_DMA4_COUNT)
+#define bfin_write_MXVR_DMA4_COUNT(val)		bfin_write16(MXVR_DMA4_COUNT, val)
+#define bfin_read_MXVR_DMA4_CURR_ADDR() 	bfin_read32(MXVR_DMA4_CURR_ADDR)
+#define bfin_write_MXVR_DMA4_CURR_ADDR(val) 	bfin_write32(MXVR_DMA4_CURR_ADDR)
+#define bfin_read_MXVR_DMA4_CURR_COUNT()	bfin_read16(MXVR_DMA4_CURR_COUNT)
+#define bfin_write_MXVR_DMA4_CURR_COUNT(val)	bfin_write16(MXVR_DMA4_CURR_COUNT, val)
+
+/* MXVR DMA5 Registers */
+
+#define bfin_read_MXVR_DMA5_CONFIG()		bfin_read32(MXVR_DMA5_CONFIG)
+#define bfin_write_MXVR_DMA5_CONFIG(val)	bfin_write32(MXVR_DMA5_CONFIG, val)
+#define bfin_read_MXVR_DMA5_START_ADDR() 	bfin_read32(MXVR_DMA5_START_ADDR)
+#define bfin_write_MXVR_DMA5_START_ADDR(val) 	bfin_write32(MXVR_DMA5_START_ADDR)
+#define bfin_read_MXVR_DMA5_COUNT()		bfin_read16(MXVR_DMA5_COUNT)
+#define bfin_write_MXVR_DMA5_COUNT(val)		bfin_write16(MXVR_DMA5_COUNT, val)
+#define bfin_read_MXVR_DMA5_CURR_ADDR() 	bfin_read32(MXVR_DMA5_CURR_ADDR)
+#define bfin_write_MXVR_DMA5_CURR_ADDR(val) 	bfin_write32(MXVR_DMA5_CURR_ADDR)
+#define bfin_read_MXVR_DMA5_CURR_COUNT()	bfin_read16(MXVR_DMA5_CURR_COUNT)
+#define bfin_write_MXVR_DMA5_CURR_COUNT(val)	bfin_write16(MXVR_DMA5_CURR_COUNT, val)
+
+/* MXVR DMA6 Registers */
+
+#define bfin_read_MXVR_DMA6_CONFIG()		bfin_read32(MXVR_DMA6_CONFIG)
+#define bfin_write_MXVR_DMA6_CONFIG(val)	bfin_write32(MXVR_DMA6_CONFIG, val)
+#define bfin_read_MXVR_DMA6_START_ADDR() 	bfin_read32(MXVR_DMA6_START_ADDR)
+#define bfin_write_MXVR_DMA6_START_ADDR(val) 	bfin_write32(MXVR_DMA6_START_ADDR)
+#define bfin_read_MXVR_DMA6_COUNT()		bfin_read16(MXVR_DMA6_COUNT)
+#define bfin_write_MXVR_DMA6_COUNT(val)		bfin_write16(MXVR_DMA6_COUNT, val)
+#define bfin_read_MXVR_DMA6_CURR_ADDR() 	bfin_read32(MXVR_DMA6_CURR_ADDR)
+#define bfin_write_MXVR_DMA6_CURR_ADDR(val) 	bfin_write32(MXVR_DMA6_CURR_ADDR)
+#define bfin_read_MXVR_DMA6_CURR_COUNT()	bfin_read16(MXVR_DMA6_CURR_COUNT)
+#define bfin_write_MXVR_DMA6_CURR_COUNT(val)	bfin_write16(MXVR_DMA6_CURR_COUNT, val)
+
+/* MXVR DMA7 Registers */
+
+#define bfin_read_MXVR_DMA7_CONFIG()		bfin_read32(MXVR_DMA7_CONFIG)
+#define bfin_write_MXVR_DMA7_CONFIG(val)	bfin_write32(MXVR_DMA7_CONFIG, val)
+#define bfin_read_MXVR_DMA7_START_ADDR() 	bfin_read32(MXVR_DMA7_START_ADDR)
+#define bfin_write_MXVR_DMA7_START_ADDR(val) 	bfin_write32(MXVR_DMA7_START_ADDR)
+#define bfin_read_MXVR_DMA7_COUNT()		bfin_read16(MXVR_DMA7_COUNT)
+#define bfin_write_MXVR_DMA7_COUNT(val)		bfin_write16(MXVR_DMA7_COUNT, val)
+#define bfin_read_MXVR_DMA7_CURR_ADDR() 	bfin_read32(MXVR_DMA7_CURR_ADDR)
+#define bfin_write_MXVR_DMA7_CURR_ADDR(val) 	bfin_write32(MXVR_DMA7_CURR_ADDR)
+#define bfin_read_MXVR_DMA7_CURR_COUNT()	bfin_read16(MXVR_DMA7_CURR_COUNT)
+#define bfin_write_MXVR_DMA7_CURR_COUNT(val)	bfin_write16(MXVR_DMA7_CURR_COUNT, val)
+
+/* MXVR Asynch Packet Registers */
+
+#define bfin_read_MXVR_AP_CTL()			bfin_read16(MXVR_AP_CTL)
+#define bfin_write_MXVR_AP_CTL(val)		bfin_write16(MXVR_AP_CTL, val)
+#define bfin_read_MXVR_APRB_START_ADDR() 	bfin_read32(MXVR_APRB_START_ADDR)
+#define bfin_write_MXVR_APRB_START_ADDR(val) 	bfin_write32(MXVR_APRB_START_ADDR)
+#define bfin_read_MXVR_APRB_CURR_ADDR() 	bfin_read32(MXVR_APRB_CURR_ADDR)
+#define bfin_write_MXVR_APRB_CURR_ADDR(val) 	bfin_write32(MXVR_APRB_CURR_ADDR)
+#define bfin_read_MXVR_APTB_START_ADDR() 	bfin_read32(MXVR_APTB_START_ADDR)
+#define bfin_write_MXVR_APTB_START_ADDR(val) 	bfin_write32(MXVR_APTB_START_ADDR)
+#define bfin_read_MXVR_APTB_CURR_ADDR() 	bfin_read32(MXVR_APTB_CURR_ADDR)
+#define bfin_write_MXVR_APTB_CURR_ADDR(val) 	bfin_write32(MXVR_APTB_CURR_ADDR)
+
+/* MXVR Control Message Registers */
+
+#define bfin_read_MXVR_CM_CTL()			bfin_read32(MXVR_CM_CTL)
+#define bfin_write_MXVR_CM_CTL(val)		bfin_write32(MXVR_CM_CTL, val)
+#define bfin_read_MXVR_CMRB_START_ADDR() 	bfin_read32(MXVR_CMRB_START_ADDR)
+#define bfin_write_MXVR_CMRB_START_ADDR(val) 	bfin_write32(MXVR_CMRB_START_ADDR)
+#define bfin_read_MXVR_CMRB_CURR_ADDR() 	bfin_read32(MXVR_CMRB_CURR_ADDR)
+#define bfin_write_MXVR_CMRB_CURR_ADDR(val) 	bfin_write32(MXVR_CMRB_CURR_ADDR)
+#define bfin_read_MXVR_CMTB_START_ADDR() 	bfin_read32(MXVR_CMTB_START_ADDR)
+#define bfin_write_MXVR_CMTB_START_ADDR(val) 	bfin_write32(MXVR_CMTB_START_ADDR)
+#define bfin_read_MXVR_CMTB_CURR_ADDR() 	bfin_read32(MXVR_CMTB_CURR_ADDR)
+#define bfin_write_MXVR_CMTB_CURR_ADDR(val) 	bfin_write32(MXVR_CMTB_CURR_ADDR)
+
+/* MXVR Remote Read Registers */
+
+#define bfin_read_MXVR_RRDB_START_ADDR() 	bfin_read32(MXVR_RRDB_START_ADDR)
+#define bfin_write_MXVR_RRDB_START_ADDR(val) 	bfin_write32(MXVR_RRDB_START_ADDR)
+#define bfin_read_MXVR_RRDB_CURR_ADDR() 	bfin_read32(MXVR_RRDB_CURR_ADDR)
+#define bfin_write_MXVR_RRDB_CURR_ADDR(val) 	bfin_write32(MXVR_RRDB_CURR_ADDR)
+
+/* MXVR Pattern Data Registers */
+
+#define bfin_read_MXVR_PAT_DATA_0()		bfin_read32(MXVR_PAT_DATA_0)
+#define bfin_write_MXVR_PAT_DATA_0(val)		bfin_write32(MXVR_PAT_DATA_0, val)
+#define bfin_read_MXVR_PAT_EN_0()		bfin_read32(MXVR_PAT_EN_0)
+#define bfin_write_MXVR_PAT_EN_0(val)		bfin_write32(MXVR_PAT_EN_0, val)
+#define bfin_read_MXVR_PAT_DATA_1()		bfin_read32(MXVR_PAT_DATA_1)
+#define bfin_write_MXVR_PAT_DATA_1(val)		bfin_write32(MXVR_PAT_DATA_1, val)
+#define bfin_read_MXVR_PAT_EN_1()		bfin_read32(MXVR_PAT_EN_1)
+#define bfin_write_MXVR_PAT_EN_1(val)		bfin_write32(MXVR_PAT_EN_1, val)
+
+/* MXVR Frame Counter Registers */
+
+#define bfin_read_MXVR_FRAME_CNT_0()		bfin_read16(MXVR_FRAME_CNT_0)
+#define bfin_write_MXVR_FRAME_CNT_0(val)	bfin_write16(MXVR_FRAME_CNT_0, val)
+#define bfin_read_MXVR_FRAME_CNT_1()		bfin_read16(MXVR_FRAME_CNT_1)
+#define bfin_write_MXVR_FRAME_CNT_1(val)	bfin_write16(MXVR_FRAME_CNT_1, val)
+
+/* MXVR Routing Table Registers */
+
+#define bfin_read_MXVR_ROUTING_0()		bfin_read32(MXVR_ROUTING_0)
+#define bfin_write_MXVR_ROUTING_0(val)		bfin_write32(MXVR_ROUTING_0, val)
+#define bfin_read_MXVR_ROUTING_1()		bfin_read32(MXVR_ROUTING_1)
+#define bfin_write_MXVR_ROUTING_1(val)		bfin_write32(MXVR_ROUTING_1, val)
+#define bfin_read_MXVR_ROUTING_2()		bfin_read32(MXVR_ROUTING_2)
+#define bfin_write_MXVR_ROUTING_2(val)		bfin_write32(MXVR_ROUTING_2, val)
+#define bfin_read_MXVR_ROUTING_3()		bfin_read32(MXVR_ROUTING_3)
+#define bfin_write_MXVR_ROUTING_3(val)		bfin_write32(MXVR_ROUTING_3, val)
+#define bfin_read_MXVR_ROUTING_4()		bfin_read32(MXVR_ROUTING_4)
+#define bfin_write_MXVR_ROUTING_4(val)		bfin_write32(MXVR_ROUTING_4, val)
+#define bfin_read_MXVR_ROUTING_5()		bfin_read32(MXVR_ROUTING_5)
+#define bfin_write_MXVR_ROUTING_5(val)		bfin_write32(MXVR_ROUTING_5, val)
+#define bfin_read_MXVR_ROUTING_6()		bfin_read32(MXVR_ROUTING_6)
+#define bfin_write_MXVR_ROUTING_6(val)		bfin_write32(MXVR_ROUTING_6, val)
+#define bfin_read_MXVR_ROUTING_7()		bfin_read32(MXVR_ROUTING_7)
+#define bfin_write_MXVR_ROUTING_7(val)		bfin_write32(MXVR_ROUTING_7, val)
+#define bfin_read_MXVR_ROUTING_8()		bfin_read32(MXVR_ROUTING_8)
+#define bfin_write_MXVR_ROUTING_8(val)		bfin_write32(MXVR_ROUTING_8, val)
+#define bfin_read_MXVR_ROUTING_9()		bfin_read32(MXVR_ROUTING_9)
+#define bfin_write_MXVR_ROUTING_9(val)		bfin_write32(MXVR_ROUTING_9, val)
+#define bfin_read_MXVR_ROUTING_10()		bfin_read32(MXVR_ROUTING_10)
+#define bfin_write_MXVR_ROUTING_10(val)		bfin_write32(MXVR_ROUTING_10, val)
+#define bfin_read_MXVR_ROUTING_11()		bfin_read32(MXVR_ROUTING_11)
+#define bfin_write_MXVR_ROUTING_11(val)		bfin_write32(MXVR_ROUTING_11, val)
+#define bfin_read_MXVR_ROUTING_12()		bfin_read32(MXVR_ROUTING_12)
+#define bfin_write_MXVR_ROUTING_12(val)		bfin_write32(MXVR_ROUTING_12, val)
+#define bfin_read_MXVR_ROUTING_13()		bfin_read32(MXVR_ROUTING_13)
+#define bfin_write_MXVR_ROUTING_13(val)		bfin_write32(MXVR_ROUTING_13, val)
+#define bfin_read_MXVR_ROUTING_14()		bfin_read32(MXVR_ROUTING_14)
+#define bfin_write_MXVR_ROUTING_14(val)		bfin_write32(MXVR_ROUTING_14, val)
+
+/* MXVR Counter-Clock-Control Registers */
+
+#define bfin_read_MXVR_BLOCK_CNT()		bfin_read16(MXVR_BLOCK_CNT)
+#define bfin_write_MXVR_BLOCK_CNT(val)		bfin_write16(MXVR_BLOCK_CNT, val)
+#define bfin_read_MXVR_CLK_CTL()		bfin_read32(MXVR_CLK_CTL)
+#define bfin_write_MXVR_CLK_CTL(val)		bfin_write32(MXVR_CLK_CTL, val)
+#define bfin_read_MXVR_CDRPLL_CTL()		bfin_read32(MXVR_CDRPLL_CTL)
+#define bfin_write_MXVR_CDRPLL_CTL(val)		bfin_write32(MXVR_CDRPLL_CTL, val)
+#define bfin_read_MXVR_FMPLL_CTL()		bfin_read32(MXVR_FMPLL_CTL)
+#define bfin_write_MXVR_FMPLL_CTL(val)		bfin_write32(MXVR_FMPLL_CTL, val)
+#define bfin_read_MXVR_PIN_CTL()		bfin_read16(MXVR_PIN_CTL)
+#define bfin_write_MXVR_PIN_CTL(val)		bfin_write16(MXVR_PIN_CTL, val)
+#define bfin_read_MXVR_SCLK_CNT()		bfin_read16(MXVR_SCLK_CNT)
+#define bfin_write_MXVR_SCLK_CNT(val)		bfin_write16(MXVR_SCLK_CNT, val)
+
+/* CAN Controller 1 Config 1 Registers */
+
+#define bfin_read_CAN1_MC1()		bfin_read16(CAN1_MC1)
+#define bfin_write_CAN1_MC1(val)	bfin_write16(CAN1_MC1, val)
+#define bfin_read_CAN1_MD1()		bfin_read16(CAN1_MD1)
+#define bfin_write_CAN1_MD1(val)	bfin_write16(CAN1_MD1, val)
+#define bfin_read_CAN1_TRS1()		bfin_read16(CAN1_TRS1)
+#define bfin_write_CAN1_TRS1(val)	bfin_write16(CAN1_TRS1, val)
+#define bfin_read_CAN1_TRR1()		bfin_read16(CAN1_TRR1)
+#define bfin_write_CAN1_TRR1(val)	bfin_write16(CAN1_TRR1, val)
+#define bfin_read_CAN1_TA1()		bfin_read16(CAN1_TA1)
+#define bfin_write_CAN1_TA1(val)	bfin_write16(CAN1_TA1, val)
+#define bfin_read_CAN1_AA1()		bfin_read16(CAN1_AA1)
+#define bfin_write_CAN1_AA1(val)	bfin_write16(CAN1_AA1, val)
+#define bfin_read_CAN1_RMP1()		bfin_read16(CAN1_RMP1)
+#define bfin_write_CAN1_RMP1(val)	bfin_write16(CAN1_RMP1, val)
+#define bfin_read_CAN1_RML1()		bfin_read16(CAN1_RML1)
+#define bfin_write_CAN1_RML1(val)	bfin_write16(CAN1_RML1, val)
+#define bfin_read_CAN1_MBTIF1()		bfin_read16(CAN1_MBTIF1)
+#define bfin_write_CAN1_MBTIF1(val)	bfin_write16(CAN1_MBTIF1, val)
+#define bfin_read_CAN1_MBRIF1()		bfin_read16(CAN1_MBRIF1)
+#define bfin_write_CAN1_MBRIF1(val)	bfin_write16(CAN1_MBRIF1, val)
+#define bfin_read_CAN1_MBIM1()		bfin_read16(CAN1_MBIM1)
+#define bfin_write_CAN1_MBIM1(val)	bfin_write16(CAN1_MBIM1, val)
+#define bfin_read_CAN1_RFH1()		bfin_read16(CAN1_RFH1)
+#define bfin_write_CAN1_RFH1(val)	bfin_write16(CAN1_RFH1, val)
+#define bfin_read_CAN1_OPSS1()		bfin_read16(CAN1_OPSS1)
+#define bfin_write_CAN1_OPSS1(val)	bfin_write16(CAN1_OPSS1, val)
+
+/* CAN Controller 1 Config 2 Registers */
+
+#define bfin_read_CAN1_MC2()		bfin_read16(CAN1_MC2)
+#define bfin_write_CAN1_MC2(val)	bfin_write16(CAN1_MC2, val)
+#define bfin_read_CAN1_MD2()		bfin_read16(CAN1_MD2)
+#define bfin_write_CAN1_MD2(val)	bfin_write16(CAN1_MD2, val)
+#define bfin_read_CAN1_TRS2()		bfin_read16(CAN1_TRS2)
+#define bfin_write_CAN1_TRS2(val)	bfin_write16(CAN1_TRS2, val)
+#define bfin_read_CAN1_TRR2()		bfin_read16(CAN1_TRR2)
+#define bfin_write_CAN1_TRR2(val)	bfin_write16(CAN1_TRR2, val)
+#define bfin_read_CAN1_TA2()		bfin_read16(CAN1_TA2)
+#define bfin_write_CAN1_TA2(val)	bfin_write16(CAN1_TA2, val)
+#define bfin_read_CAN1_AA2()		bfin_read16(CAN1_AA2)
+#define bfin_write_CAN1_AA2(val)	bfin_write16(CAN1_AA2, val)
+#define bfin_read_CAN1_RMP2()		bfin_read16(CAN1_RMP2)
+#define bfin_write_CAN1_RMP2(val)	bfin_write16(CAN1_RMP2, val)
+#define bfin_read_CAN1_RML2()		bfin_read16(CAN1_RML2)
+#define bfin_write_CAN1_RML2(val)	bfin_write16(CAN1_RML2, val)
+#define bfin_read_CAN1_MBTIF2()		bfin_read16(CAN1_MBTIF2)
+#define bfin_write_CAN1_MBTIF2(val)	bfin_write16(CAN1_MBTIF2, val)
+#define bfin_read_CAN1_MBRIF2()		bfin_read16(CAN1_MBRIF2)
+#define bfin_write_CAN1_MBRIF2(val)	bfin_write16(CAN1_MBRIF2, val)
+#define bfin_read_CAN1_MBIM2()		bfin_read16(CAN1_MBIM2)
+#define bfin_write_CAN1_MBIM2(val)	bfin_write16(CAN1_MBIM2, val)
+#define bfin_read_CAN1_RFH2()		bfin_read16(CAN1_RFH2)
+#define bfin_write_CAN1_RFH2(val)	bfin_write16(CAN1_RFH2, val)
+#define bfin_read_CAN1_OPSS2()		bfin_read16(CAN1_OPSS2)
+#define bfin_write_CAN1_OPSS2(val)	bfin_write16(CAN1_OPSS2, val)
+
+/* CAN Controller 1 Clock/Interrubfin_read_()t/Counter Registers */
+
+#define bfin_read_CAN1_CLOCK()		bfin_read16(CAN1_CLOCK)
+#define bfin_write_CAN1_CLOCK(val)	bfin_write16(CAN1_CLOCK, val)
+#define bfin_read_CAN1_TIMING()		bfin_read16(CAN1_TIMING)
+#define bfin_write_CAN1_TIMING(val)	bfin_write16(CAN1_TIMING, val)
+#define bfin_read_CAN1_DEBUG()		bfin_read16(CAN1_DEBUG)
+#define bfin_write_CAN1_DEBUG(val)	bfin_write16(CAN1_DEBUG, val)
+#define bfin_read_CAN1_STATUS()		bfin_read16(CAN1_STATUS)
+#define bfin_write_CAN1_STATUS(val)	bfin_write16(CAN1_STATUS, val)
+#define bfin_read_CAN1_CEC()		bfin_read16(CAN1_CEC)
+#define bfin_write_CAN1_CEC(val)	bfin_write16(CAN1_CEC, val)
+#define bfin_read_CAN1_GIS()		bfin_read16(CAN1_GIS)
+#define bfin_write_CAN1_GIS(val)	bfin_write16(CAN1_GIS, val)
+#define bfin_read_CAN1_GIM()		bfin_read16(CAN1_GIM)
+#define bfin_write_CAN1_GIM(val)	bfin_write16(CAN1_GIM, val)
+#define bfin_read_CAN1_GIF()		bfin_read16(CAN1_GIF)
+#define bfin_write_CAN1_GIF(val)	bfin_write16(CAN1_GIF, val)
+#define bfin_read_CAN1_CONTROL()	bfin_read16(CAN1_CONTROL)
+#define bfin_write_CAN1_CONTROL(val)	bfin_write16(CAN1_CONTROL, val)
+#define bfin_read_CAN1_INTR()		bfin_read16(CAN1_INTR)
+#define bfin_write_CAN1_INTR(val)	bfin_write16(CAN1_INTR, val)
+#define bfin_read_CAN1_MBTD()		bfin_read16(CAN1_MBTD)
+#define bfin_write_CAN1_MBTD(val)	bfin_write16(CAN1_MBTD, val)
+#define bfin_read_CAN1_EWR()		bfin_read16(CAN1_EWR)
+#define bfin_write_CAN1_EWR(val)	bfin_write16(CAN1_EWR, val)
+#define bfin_read_CAN1_ESR()		bfin_read16(CAN1_ESR)
+#define bfin_write_CAN1_ESR(val)	bfin_write16(CAN1_ESR, val)
+#define bfin_read_CAN1_UCCNT()		bfin_read16(CAN1_UCCNT)
+#define bfin_write_CAN1_UCCNT(val)	bfin_write16(CAN1_UCCNT, val)
+#define bfin_read_CAN1_UCRC()		bfin_read16(CAN1_UCRC)
+#define bfin_write_CAN1_UCRC(val)	bfin_write16(CAN1_UCRC, val)
+#define bfin_read_CAN1_UCCNF()		bfin_read16(CAN1_UCCNF)
+#define bfin_write_CAN1_UCCNF(val)	bfin_write16(CAN1_UCCNF, val)
+
+/* CAN Controller 1 Mailbox Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN1_AM00L()		bfin_read16(CAN1_AM00L)
+#define bfin_write_CAN1_AM00L(val)	bfin_write16(CAN1_AM00L, val)
+#define bfin_read_CAN1_AM00H()		bfin_read16(CAN1_AM00H)
+#define bfin_write_CAN1_AM00H(val)	bfin_write16(CAN1_AM00H, val)
+#define bfin_read_CAN1_AM01L()		bfin_read16(CAN1_AM01L)
+#define bfin_write_CAN1_AM01L(val)	bfin_write16(CAN1_AM01L, val)
+#define bfin_read_CAN1_AM01H()		bfin_read16(CAN1_AM01H)
+#define bfin_write_CAN1_AM01H(val)	bfin_write16(CAN1_AM01H, val)
+#define bfin_read_CAN1_AM02L()		bfin_read16(CAN1_AM02L)
+#define bfin_write_CAN1_AM02L(val)	bfin_write16(CAN1_AM02L, val)
+#define bfin_read_CAN1_AM02H()		bfin_read16(CAN1_AM02H)
+#define bfin_write_CAN1_AM02H(val)	bfin_write16(CAN1_AM02H, val)
+#define bfin_read_CAN1_AM03L()		bfin_read16(CAN1_AM03L)
+#define bfin_write_CAN1_AM03L(val)	bfin_write16(CAN1_AM03L, val)
+#define bfin_read_CAN1_AM03H()		bfin_read16(CAN1_AM03H)
+#define bfin_write_CAN1_AM03H(val)	bfin_write16(CAN1_AM03H, val)
+#define bfin_read_CAN1_AM04L()		bfin_read16(CAN1_AM04L)
+#define bfin_write_CAN1_AM04L(val)	bfin_write16(CAN1_AM04L, val)
+#define bfin_read_CAN1_AM04H()		bfin_read16(CAN1_AM04H)
+#define bfin_write_CAN1_AM04H(val)	bfin_write16(CAN1_AM04H, val)
+#define bfin_read_CAN1_AM05L()		bfin_read16(CAN1_AM05L)
+#define bfin_write_CAN1_AM05L(val)	bfin_write16(CAN1_AM05L, val)
+#define bfin_read_CAN1_AM05H()		bfin_read16(CAN1_AM05H)
+#define bfin_write_CAN1_AM05H(val)	bfin_write16(CAN1_AM05H, val)
+#define bfin_read_CAN1_AM06L()		bfin_read16(CAN1_AM06L)
+#define bfin_write_CAN1_AM06L(val)	bfin_write16(CAN1_AM06L, val)
+#define bfin_read_CAN1_AM06H()		bfin_read16(CAN1_AM06H)
+#define bfin_write_CAN1_AM06H(val)	bfin_write16(CAN1_AM06H, val)
+#define bfin_read_CAN1_AM07L()		bfin_read16(CAN1_AM07L)
+#define bfin_write_CAN1_AM07L(val)	bfin_write16(CAN1_AM07L, val)
+#define bfin_read_CAN1_AM07H()		bfin_read16(CAN1_AM07H)
+#define bfin_write_CAN1_AM07H(val)	bfin_write16(CAN1_AM07H, val)
+#define bfin_read_CAN1_AM08L()		bfin_read16(CAN1_AM08L)
+#define bfin_write_CAN1_AM08L(val)	bfin_write16(CAN1_AM08L, val)
+#define bfin_read_CAN1_AM08H()		bfin_read16(CAN1_AM08H)
+#define bfin_write_CAN1_AM08H(val)	bfin_write16(CAN1_AM08H, val)
+#define bfin_read_CAN1_AM09L()		bfin_read16(CAN1_AM09L)
+#define bfin_write_CAN1_AM09L(val)	bfin_write16(CAN1_AM09L, val)
+#define bfin_read_CAN1_AM09H()		bfin_read16(CAN1_AM09H)
+#define bfin_write_CAN1_AM09H(val)	bfin_write16(CAN1_AM09H, val)
+#define bfin_read_CAN1_AM10L()		bfin_read16(CAN1_AM10L)
+#define bfin_write_CAN1_AM10L(val)	bfin_write16(CAN1_AM10L, val)
+#define bfin_read_CAN1_AM10H()		bfin_read16(CAN1_AM10H)
+#define bfin_write_CAN1_AM10H(val)	bfin_write16(CAN1_AM10H, val)
+#define bfin_read_CAN1_AM11L()		bfin_read16(CAN1_AM11L)
+#define bfin_write_CAN1_AM11L(val)	bfin_write16(CAN1_AM11L, val)
+#define bfin_read_CAN1_AM11H()		bfin_read16(CAN1_AM11H)
+#define bfin_write_CAN1_AM11H(val)	bfin_write16(CAN1_AM11H, val)
+#define bfin_read_CAN1_AM12L()		bfin_read16(CAN1_AM12L)
+#define bfin_write_CAN1_AM12L(val)	bfin_write16(CAN1_AM12L, val)
+#define bfin_read_CAN1_AM12H()		bfin_read16(CAN1_AM12H)
+#define bfin_write_CAN1_AM12H(val)	bfin_write16(CAN1_AM12H, val)
+#define bfin_read_CAN1_AM13L()		bfin_read16(CAN1_AM13L)
+#define bfin_write_CAN1_AM13L(val)	bfin_write16(CAN1_AM13L, val)
+#define bfin_read_CAN1_AM13H()		bfin_read16(CAN1_AM13H)
+#define bfin_write_CAN1_AM13H(val)	bfin_write16(CAN1_AM13H, val)
+#define bfin_read_CAN1_AM14L()		bfin_read16(CAN1_AM14L)
+#define bfin_write_CAN1_AM14L(val)	bfin_write16(CAN1_AM14L, val)
+#define bfin_read_CAN1_AM14H()		bfin_read16(CAN1_AM14H)
+#define bfin_write_CAN1_AM14H(val)	bfin_write16(CAN1_AM14H, val)
+#define bfin_read_CAN1_AM15L()		bfin_read16(CAN1_AM15L)
+#define bfin_write_CAN1_AM15L(val)	bfin_write16(CAN1_AM15L, val)
+#define bfin_read_CAN1_AM15H()		bfin_read16(CAN1_AM15H)
+#define bfin_write_CAN1_AM15H(val)	bfin_write16(CAN1_AM15H, val)
+
+/* CAN Controller 1 Mailbox Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN1_AM16L()		bfin_read16(CAN1_AM16L)
+#define bfin_write_CAN1_AM16L(val)	bfin_write16(CAN1_AM16L, val)
+#define bfin_read_CAN1_AM16H()		bfin_read16(CAN1_AM16H)
+#define bfin_write_CAN1_AM16H(val)	bfin_write16(CAN1_AM16H, val)
+#define bfin_read_CAN1_AM17L()		bfin_read16(CAN1_AM17L)
+#define bfin_write_CAN1_AM17L(val)	bfin_write16(CAN1_AM17L, val)
+#define bfin_read_CAN1_AM17H()		bfin_read16(CAN1_AM17H)
+#define bfin_write_CAN1_AM17H(val)	bfin_write16(CAN1_AM17H, val)
+#define bfin_read_CAN1_AM18L()		bfin_read16(CAN1_AM18L)
+#define bfin_write_CAN1_AM18L(val)	bfin_write16(CAN1_AM18L, val)
+#define bfin_read_CAN1_AM18H()		bfin_read16(CAN1_AM18H)
+#define bfin_write_CAN1_AM18H(val)	bfin_write16(CAN1_AM18H, val)
+#define bfin_read_CAN1_AM19L()		bfin_read16(CAN1_AM19L)
+#define bfin_write_CAN1_AM19L(val)	bfin_write16(CAN1_AM19L, val)
+#define bfin_read_CAN1_AM19H()		bfin_read16(CAN1_AM19H)
+#define bfin_write_CAN1_AM19H(val)	bfin_write16(CAN1_AM19H, val)
+#define bfin_read_CAN1_AM20L()		bfin_read16(CAN1_AM20L)
+#define bfin_write_CAN1_AM20L(val)	bfin_write16(CAN1_AM20L, val)
+#define bfin_read_CAN1_AM20H()		bfin_read16(CAN1_AM20H)
+#define bfin_write_CAN1_AM20H(val)	bfin_write16(CAN1_AM20H, val)
+#define bfin_read_CAN1_AM21L()		bfin_read16(CAN1_AM21L)
+#define bfin_write_CAN1_AM21L(val)	bfin_write16(CAN1_AM21L, val)
+#define bfin_read_CAN1_AM21H()		bfin_read16(CAN1_AM21H)
+#define bfin_write_CAN1_AM21H(val)	bfin_write16(CAN1_AM21H, val)
+#define bfin_read_CAN1_AM22L()		bfin_read16(CAN1_AM22L)
+#define bfin_write_CAN1_AM22L(val)	bfin_write16(CAN1_AM22L, val)
+#define bfin_read_CAN1_AM22H()		bfin_read16(CAN1_AM22H)
+#define bfin_write_CAN1_AM22H(val)	bfin_write16(CAN1_AM22H, val)
+#define bfin_read_CAN1_AM23L()		bfin_read16(CAN1_AM23L)
+#define bfin_write_CAN1_AM23L(val)	bfin_write16(CAN1_AM23L, val)
+#define bfin_read_CAN1_AM23H()		bfin_read16(CAN1_AM23H)
+#define bfin_write_CAN1_AM23H(val)	bfin_write16(CAN1_AM23H, val)
+#define bfin_read_CAN1_AM24L()		bfin_read16(CAN1_AM24L)
+#define bfin_write_CAN1_AM24L(val)	bfin_write16(CAN1_AM24L, val)
+#define bfin_read_CAN1_AM24H()		bfin_read16(CAN1_AM24H)
+#define bfin_write_CAN1_AM24H(val)	bfin_write16(CAN1_AM24H, val)
+#define bfin_read_CAN1_AM25L()		bfin_read16(CAN1_AM25L)
+#define bfin_write_CAN1_AM25L(val)	bfin_write16(CAN1_AM25L, val)
+#define bfin_read_CAN1_AM25H()		bfin_read16(CAN1_AM25H)
+#define bfin_write_CAN1_AM25H(val)	bfin_write16(CAN1_AM25H, val)
+#define bfin_read_CAN1_AM26L()		bfin_read16(CAN1_AM26L)
+#define bfin_write_CAN1_AM26L(val)	bfin_write16(CAN1_AM26L, val)
+#define bfin_read_CAN1_AM26H()		bfin_read16(CAN1_AM26H)
+#define bfin_write_CAN1_AM26H(val)	bfin_write16(CAN1_AM26H, val)
+#define bfin_read_CAN1_AM27L()		bfin_read16(CAN1_AM27L)
+#define bfin_write_CAN1_AM27L(val)	bfin_write16(CAN1_AM27L, val)
+#define bfin_read_CAN1_AM27H()		bfin_read16(CAN1_AM27H)
+#define bfin_write_CAN1_AM27H(val)	bfin_write16(CAN1_AM27H, val)
+#define bfin_read_CAN1_AM28L()		bfin_read16(CAN1_AM28L)
+#define bfin_write_CAN1_AM28L(val)	bfin_write16(CAN1_AM28L, val)
+#define bfin_read_CAN1_AM28H()		bfin_read16(CAN1_AM28H)
+#define bfin_write_CAN1_AM28H(val)	bfin_write16(CAN1_AM28H, val)
+#define bfin_read_CAN1_AM29L()		bfin_read16(CAN1_AM29L)
+#define bfin_write_CAN1_AM29L(val)	bfin_write16(CAN1_AM29L, val)
+#define bfin_read_CAN1_AM29H()		bfin_read16(CAN1_AM29H)
+#define bfin_write_CAN1_AM29H(val)	bfin_write16(CAN1_AM29H, val)
+#define bfin_read_CAN1_AM30L()		bfin_read16(CAN1_AM30L)
+#define bfin_write_CAN1_AM30L(val)	bfin_write16(CAN1_AM30L, val)
+#define bfin_read_CAN1_AM30H()		bfin_read16(CAN1_AM30H)
+#define bfin_write_CAN1_AM30H(val)	bfin_write16(CAN1_AM30H, val)
+#define bfin_read_CAN1_AM31L()		bfin_read16(CAN1_AM31L)
+#define bfin_write_CAN1_AM31L(val)	bfin_write16(CAN1_AM31L, val)
+#define bfin_read_CAN1_AM31H()		bfin_read16(CAN1_AM31H)
+#define bfin_write_CAN1_AM31H(val)	bfin_write16(CAN1_AM31H, val)
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define bfin_read_CAN1_MB00_DATA0()		bfin_read16(CAN1_MB00_DATA0)
+#define bfin_write_CAN1_MB00_DATA0(val)		bfin_write16(CAN1_MB00_DATA0, val)
+#define bfin_read_CAN1_MB00_DATA1()		bfin_read16(CAN1_MB00_DATA1)
+#define bfin_write_CAN1_MB00_DATA1(val)		bfin_write16(CAN1_MB00_DATA1, val)
+#define bfin_read_CAN1_MB00_DATA2()		bfin_read16(CAN1_MB00_DATA2)
+#define bfin_write_CAN1_MB00_DATA2(val)		bfin_write16(CAN1_MB00_DATA2, val)
+#define bfin_read_CAN1_MB00_DATA3()		bfin_read16(CAN1_MB00_DATA3)
+#define bfin_write_CAN1_MB00_DATA3(val)		bfin_write16(CAN1_MB00_DATA3, val)
+#define bfin_read_CAN1_MB00_LENGTH()		bfin_read16(CAN1_MB00_LENGTH)
+#define bfin_write_CAN1_MB00_LENGTH(val)	bfin_write16(CAN1_MB00_LENGTH, val)
+#define bfin_read_CAN1_MB00_TIMESTAMP()		bfin_read16(CAN1_MB00_TIMESTAMP)
+#define bfin_write_CAN1_MB00_TIMESTAMP(val)	bfin_write16(CAN1_MB00_TIMESTAMP, val)
+#define bfin_read_CAN1_MB00_ID0()		bfin_read16(CAN1_MB00_ID0)
+#define bfin_write_CAN1_MB00_ID0(val)		bfin_write16(CAN1_MB00_ID0, val)
+#define bfin_read_CAN1_MB00_ID1()		bfin_read16(CAN1_MB00_ID1)
+#define bfin_write_CAN1_MB00_ID1(val)		bfin_write16(CAN1_MB00_ID1, val)
+#define bfin_read_CAN1_MB01_DATA0()		bfin_read16(CAN1_MB01_DATA0)
+#define bfin_write_CAN1_MB01_DATA0(val)		bfin_write16(CAN1_MB01_DATA0, val)
+#define bfin_read_CAN1_MB01_DATA1()		bfin_read16(CAN1_MB01_DATA1)
+#define bfin_write_CAN1_MB01_DATA1(val)		bfin_write16(CAN1_MB01_DATA1, val)
+#define bfin_read_CAN1_MB01_DATA2()		bfin_read16(CAN1_MB01_DATA2)
+#define bfin_write_CAN1_MB01_DATA2(val)		bfin_write16(CAN1_MB01_DATA2, val)
+#define bfin_read_CAN1_MB01_DATA3()		bfin_read16(CAN1_MB01_DATA3)
+#define bfin_write_CAN1_MB01_DATA3(val)		bfin_write16(CAN1_MB01_DATA3, val)
+#define bfin_read_CAN1_MB01_LENGTH()		bfin_read16(CAN1_MB01_LENGTH)
+#define bfin_write_CAN1_MB01_LENGTH(val)	bfin_write16(CAN1_MB01_LENGTH, val)
+#define bfin_read_CAN1_MB01_TIMESTAMP()		bfin_read16(CAN1_MB01_TIMESTAMP)
+#define bfin_write_CAN1_MB01_TIMESTAMP(val)	bfin_write16(CAN1_MB01_TIMESTAMP, val)
+#define bfin_read_CAN1_MB01_ID0()		bfin_read16(CAN1_MB01_ID0)
+#define bfin_write_CAN1_MB01_ID0(val)		bfin_write16(CAN1_MB01_ID0, val)
+#define bfin_read_CAN1_MB01_ID1()		bfin_read16(CAN1_MB01_ID1)
+#define bfin_write_CAN1_MB01_ID1(val)		bfin_write16(CAN1_MB01_ID1, val)
+#define bfin_read_CAN1_MB02_DATA0()		bfin_read16(CAN1_MB02_DATA0)
+#define bfin_write_CAN1_MB02_DATA0(val)		bfin_write16(CAN1_MB02_DATA0, val)
+#define bfin_read_CAN1_MB02_DATA1()		bfin_read16(CAN1_MB02_DATA1)
+#define bfin_write_CAN1_MB02_DATA1(val)		bfin_write16(CAN1_MB02_DATA1, val)
+#define bfin_read_CAN1_MB02_DATA2()		bfin_read16(CAN1_MB02_DATA2)
+#define bfin_write_CAN1_MB02_DATA2(val)		bfin_write16(CAN1_MB02_DATA2, val)
+#define bfin_read_CAN1_MB02_DATA3()		bfin_read16(CAN1_MB02_DATA3)
+#define bfin_write_CAN1_MB02_DATA3(val)		bfin_write16(CAN1_MB02_DATA3, val)
+#define bfin_read_CAN1_MB02_LENGTH()		bfin_read16(CAN1_MB02_LENGTH)
+#define bfin_write_CAN1_MB02_LENGTH(val)	bfin_write16(CAN1_MB02_LENGTH, val)
+#define bfin_read_CAN1_MB02_TIMESTAMP()		bfin_read16(CAN1_MB02_TIMESTAMP)
+#define bfin_write_CAN1_MB02_TIMESTAMP(val)	bfin_write16(CAN1_MB02_TIMESTAMP, val)
+#define bfin_read_CAN1_MB02_ID0()		bfin_read16(CAN1_MB02_ID0)
+#define bfin_write_CAN1_MB02_ID0(val)		bfin_write16(CAN1_MB02_ID0, val)
+#define bfin_read_CAN1_MB02_ID1()		bfin_read16(CAN1_MB02_ID1)
+#define bfin_write_CAN1_MB02_ID1(val)		bfin_write16(CAN1_MB02_ID1, val)
+#define bfin_read_CAN1_MB03_DATA0()		bfin_read16(CAN1_MB03_DATA0)
+#define bfin_write_CAN1_MB03_DATA0(val)		bfin_write16(CAN1_MB03_DATA0, val)
+#define bfin_read_CAN1_MB03_DATA1()		bfin_read16(CAN1_MB03_DATA1)
+#define bfin_write_CAN1_MB03_DATA1(val)		bfin_write16(CAN1_MB03_DATA1, val)
+#define bfin_read_CAN1_MB03_DATA2()		bfin_read16(CAN1_MB03_DATA2)
+#define bfin_write_CAN1_MB03_DATA2(val)		bfin_write16(CAN1_MB03_DATA2, val)
+#define bfin_read_CAN1_MB03_DATA3()		bfin_read16(CAN1_MB03_DATA3)
+#define bfin_write_CAN1_MB03_DATA3(val)		bfin_write16(CAN1_MB03_DATA3, val)
+#define bfin_read_CAN1_MB03_LENGTH()		bfin_read16(CAN1_MB03_LENGTH)
+#define bfin_write_CAN1_MB03_LENGTH(val)	bfin_write16(CAN1_MB03_LENGTH, val)
+#define bfin_read_CAN1_MB03_TIMESTAMP()		bfin_read16(CAN1_MB03_TIMESTAMP)
+#define bfin_write_CAN1_MB03_TIMESTAMP(val)	bfin_write16(CAN1_MB03_TIMESTAMP, val)
+#define bfin_read_CAN1_MB03_ID0()		bfin_read16(CAN1_MB03_ID0)
+#define bfin_write_CAN1_MB03_ID0(val)		bfin_write16(CAN1_MB03_ID0, val)
+#define bfin_read_CAN1_MB03_ID1()		bfin_read16(CAN1_MB03_ID1)
+#define bfin_write_CAN1_MB03_ID1(val)		bfin_write16(CAN1_MB03_ID1, val)
+#define bfin_read_CAN1_MB04_DATA0()		bfin_read16(CAN1_MB04_DATA0)
+#define bfin_write_CAN1_MB04_DATA0(val)		bfin_write16(CAN1_MB04_DATA0, val)
+#define bfin_read_CAN1_MB04_DATA1()		bfin_read16(CAN1_MB04_DATA1)
+#define bfin_write_CAN1_MB04_DATA1(val)		bfin_write16(CAN1_MB04_DATA1, val)
+#define bfin_read_CAN1_MB04_DATA2()		bfin_read16(CAN1_MB04_DATA2)
+#define bfin_write_CAN1_MB04_DATA2(val)		bfin_write16(CAN1_MB04_DATA2, val)
+#define bfin_read_CAN1_MB04_DATA3()		bfin_read16(CAN1_MB04_DATA3)
+#define bfin_write_CAN1_MB04_DATA3(val)		bfin_write16(CAN1_MB04_DATA3, val)
+#define bfin_read_CAN1_MB04_LENGTH()		bfin_read16(CAN1_MB04_LENGTH)
+#define bfin_write_CAN1_MB04_LENGTH(val)	bfin_write16(CAN1_MB04_LENGTH, val)
+#define bfin_read_CAN1_MB04_TIMESTAMP()		bfin_read16(CAN1_MB04_TIMESTAMP)
+#define bfin_write_CAN1_MB04_TIMESTAMP(val)	bfin_write16(CAN1_MB04_TIMESTAMP, val)
+#define bfin_read_CAN1_MB04_ID0()		bfin_read16(CAN1_MB04_ID0)
+#define bfin_write_CAN1_MB04_ID0(val)		bfin_write16(CAN1_MB04_ID0, val)
+#define bfin_read_CAN1_MB04_ID1()		bfin_read16(CAN1_MB04_ID1)
+#define bfin_write_CAN1_MB04_ID1(val)		bfin_write16(CAN1_MB04_ID1, val)
+#define bfin_read_CAN1_MB05_DATA0()		bfin_read16(CAN1_MB05_DATA0)
+#define bfin_write_CAN1_MB05_DATA0(val)		bfin_write16(CAN1_MB05_DATA0, val)
+#define bfin_read_CAN1_MB05_DATA1()		bfin_read16(CAN1_MB05_DATA1)
+#define bfin_write_CAN1_MB05_DATA1(val)		bfin_write16(CAN1_MB05_DATA1, val)
+#define bfin_read_CAN1_MB05_DATA2()		bfin_read16(CAN1_MB05_DATA2)
+#define bfin_write_CAN1_MB05_DATA2(val)		bfin_write16(CAN1_MB05_DATA2, val)
+#define bfin_read_CAN1_MB05_DATA3()		bfin_read16(CAN1_MB05_DATA3)
+#define bfin_write_CAN1_MB05_DATA3(val)		bfin_write16(CAN1_MB05_DATA3, val)
+#define bfin_read_CAN1_MB05_LENGTH()		bfin_read16(CAN1_MB05_LENGTH)
+#define bfin_write_CAN1_MB05_LENGTH(val)	bfin_write16(CAN1_MB05_LENGTH, val)
+#define bfin_read_CAN1_MB05_TIMESTAMP()		bfin_read16(CAN1_MB05_TIMESTAMP)
+#define bfin_write_CAN1_MB05_TIMESTAMP(val)	bfin_write16(CAN1_MB05_TIMESTAMP, val)
+#define bfin_read_CAN1_MB05_ID0()		bfin_read16(CAN1_MB05_ID0)
+#define bfin_write_CAN1_MB05_ID0(val)		bfin_write16(CAN1_MB05_ID0, val)
+#define bfin_read_CAN1_MB05_ID1()		bfin_read16(CAN1_MB05_ID1)
+#define bfin_write_CAN1_MB05_ID1(val)		bfin_write16(CAN1_MB05_ID1, val)
+#define bfin_read_CAN1_MB06_DATA0()		bfin_read16(CAN1_MB06_DATA0)
+#define bfin_write_CAN1_MB06_DATA0(val)		bfin_write16(CAN1_MB06_DATA0, val)
+#define bfin_read_CAN1_MB06_DATA1()		bfin_read16(CAN1_MB06_DATA1)
+#define bfin_write_CAN1_MB06_DATA1(val)		bfin_write16(CAN1_MB06_DATA1, val)
+#define bfin_read_CAN1_MB06_DATA2()		bfin_read16(CAN1_MB06_DATA2)
+#define bfin_write_CAN1_MB06_DATA2(val)		bfin_write16(CAN1_MB06_DATA2, val)
+#define bfin_read_CAN1_MB06_DATA3()		bfin_read16(CAN1_MB06_DATA3)
+#define bfin_write_CAN1_MB06_DATA3(val)		bfin_write16(CAN1_MB06_DATA3, val)
+#define bfin_read_CAN1_MB06_LENGTH()		bfin_read16(CAN1_MB06_LENGTH)
+#define bfin_write_CAN1_MB06_LENGTH(val)	bfin_write16(CAN1_MB06_LENGTH, val)
+#define bfin_read_CAN1_MB06_TIMESTAMP()		bfin_read16(CAN1_MB06_TIMESTAMP)
+#define bfin_write_CAN1_MB06_TIMESTAMP(val)	bfin_write16(CAN1_MB06_TIMESTAMP, val)
+#define bfin_read_CAN1_MB06_ID0()		bfin_read16(CAN1_MB06_ID0)
+#define bfin_write_CAN1_MB06_ID0(val)		bfin_write16(CAN1_MB06_ID0, val)
+#define bfin_read_CAN1_MB06_ID1()		bfin_read16(CAN1_MB06_ID1)
+#define bfin_write_CAN1_MB06_ID1(val)		bfin_write16(CAN1_MB06_ID1, val)
+#define bfin_read_CAN1_MB07_DATA0()		bfin_read16(CAN1_MB07_DATA0)
+#define bfin_write_CAN1_MB07_DATA0(val)		bfin_write16(CAN1_MB07_DATA0, val)
+#define bfin_read_CAN1_MB07_DATA1()		bfin_read16(CAN1_MB07_DATA1)
+#define bfin_write_CAN1_MB07_DATA1(val)		bfin_write16(CAN1_MB07_DATA1, val)
+#define bfin_read_CAN1_MB07_DATA2()		bfin_read16(CAN1_MB07_DATA2)
+#define bfin_write_CAN1_MB07_DATA2(val)		bfin_write16(CAN1_MB07_DATA2, val)
+#define bfin_read_CAN1_MB07_DATA3()		bfin_read16(CAN1_MB07_DATA3)
+#define bfin_write_CAN1_MB07_DATA3(val)		bfin_write16(CAN1_MB07_DATA3, val)
+#define bfin_read_CAN1_MB07_LENGTH()		bfin_read16(CAN1_MB07_LENGTH)
+#define bfin_write_CAN1_MB07_LENGTH(val)	bfin_write16(CAN1_MB07_LENGTH, val)
+#define bfin_read_CAN1_MB07_TIMESTAMP()		bfin_read16(CAN1_MB07_TIMESTAMP)
+#define bfin_write_CAN1_MB07_TIMESTAMP(val)	bfin_write16(CAN1_MB07_TIMESTAMP, val)
+#define bfin_read_CAN1_MB07_ID0()		bfin_read16(CAN1_MB07_ID0)
+#define bfin_write_CAN1_MB07_ID0(val)		bfin_write16(CAN1_MB07_ID0, val)
+#define bfin_read_CAN1_MB07_ID1()		bfin_read16(CAN1_MB07_ID1)
+#define bfin_write_CAN1_MB07_ID1(val)		bfin_write16(CAN1_MB07_ID1, val)
+#define bfin_read_CAN1_MB08_DATA0()		bfin_read16(CAN1_MB08_DATA0)
+#define bfin_write_CAN1_MB08_DATA0(val)		bfin_write16(CAN1_MB08_DATA0, val)
+#define bfin_read_CAN1_MB08_DATA1()		bfin_read16(CAN1_MB08_DATA1)
+#define bfin_write_CAN1_MB08_DATA1(val)		bfin_write16(CAN1_MB08_DATA1, val)
+#define bfin_read_CAN1_MB08_DATA2()		bfin_read16(CAN1_MB08_DATA2)
+#define bfin_write_CAN1_MB08_DATA2(val)		bfin_write16(CAN1_MB08_DATA2, val)
+#define bfin_read_CAN1_MB08_DATA3()		bfin_read16(CAN1_MB08_DATA3)
+#define bfin_write_CAN1_MB08_DATA3(val)		bfin_write16(CAN1_MB08_DATA3, val)
+#define bfin_read_CAN1_MB08_LENGTH()		bfin_read16(CAN1_MB08_LENGTH)
+#define bfin_write_CAN1_MB08_LENGTH(val)	bfin_write16(CAN1_MB08_LENGTH, val)
+#define bfin_read_CAN1_MB08_TIMESTAMP()		bfin_read16(CAN1_MB08_TIMESTAMP)
+#define bfin_write_CAN1_MB08_TIMESTAMP(val)	bfin_write16(CAN1_MB08_TIMESTAMP, val)
+#define bfin_read_CAN1_MB08_ID0()		bfin_read16(CAN1_MB08_ID0)
+#define bfin_write_CAN1_MB08_ID0(val)		bfin_write16(CAN1_MB08_ID0, val)
+#define bfin_read_CAN1_MB08_ID1()		bfin_read16(CAN1_MB08_ID1)
+#define bfin_write_CAN1_MB08_ID1(val)		bfin_write16(CAN1_MB08_ID1, val)
+#define bfin_read_CAN1_MB09_DATA0()		bfin_read16(CAN1_MB09_DATA0)
+#define bfin_write_CAN1_MB09_DATA0(val)		bfin_write16(CAN1_MB09_DATA0, val)
+#define bfin_read_CAN1_MB09_DATA1()		bfin_read16(CAN1_MB09_DATA1)
+#define bfin_write_CAN1_MB09_DATA1(val)		bfin_write16(CAN1_MB09_DATA1, val)
+#define bfin_read_CAN1_MB09_DATA2()		bfin_read16(CAN1_MB09_DATA2)
+#define bfin_write_CAN1_MB09_DATA2(val)		bfin_write16(CAN1_MB09_DATA2, val)
+#define bfin_read_CAN1_MB09_DATA3()		bfin_read16(CAN1_MB09_DATA3)
+#define bfin_write_CAN1_MB09_DATA3(val)		bfin_write16(CAN1_MB09_DATA3, val)
+#define bfin_read_CAN1_MB09_LENGTH()		bfin_read16(CAN1_MB09_LENGTH)
+#define bfin_write_CAN1_MB09_LENGTH(val)	bfin_write16(CAN1_MB09_LENGTH, val)
+#define bfin_read_CAN1_MB09_TIMESTAMP()		bfin_read16(CAN1_MB09_TIMESTAMP)
+#define bfin_write_CAN1_MB09_TIMESTAMP(val)	bfin_write16(CAN1_MB09_TIMESTAMP, val)
+#define bfin_read_CAN1_MB09_ID0()		bfin_read16(CAN1_MB09_ID0)
+#define bfin_write_CAN1_MB09_ID0(val)		bfin_write16(CAN1_MB09_ID0, val)
+#define bfin_read_CAN1_MB09_ID1()		bfin_read16(CAN1_MB09_ID1)
+#define bfin_write_CAN1_MB09_ID1(val)		bfin_write16(CAN1_MB09_ID1, val)
+#define bfin_read_CAN1_MB10_DATA0()		bfin_read16(CAN1_MB10_DATA0)
+#define bfin_write_CAN1_MB10_DATA0(val)		bfin_write16(CAN1_MB10_DATA0, val)
+#define bfin_read_CAN1_MB10_DATA1()		bfin_read16(CAN1_MB10_DATA1)
+#define bfin_write_CAN1_MB10_DATA1(val)		bfin_write16(CAN1_MB10_DATA1, val)
+#define bfin_read_CAN1_MB10_DATA2()		bfin_read16(CAN1_MB10_DATA2)
+#define bfin_write_CAN1_MB10_DATA2(val)		bfin_write16(CAN1_MB10_DATA2, val)
+#define bfin_read_CAN1_MB10_DATA3()		bfin_read16(CAN1_MB10_DATA3)
+#define bfin_write_CAN1_MB10_DATA3(val)		bfin_write16(CAN1_MB10_DATA3, val)
+#define bfin_read_CAN1_MB10_LENGTH()		bfin_read16(CAN1_MB10_LENGTH)
+#define bfin_write_CAN1_MB10_LENGTH(val)	bfin_write16(CAN1_MB10_LENGTH, val)
+#define bfin_read_CAN1_MB10_TIMESTAMP()		bfin_read16(CAN1_MB10_TIMESTAMP)
+#define bfin_write_CAN1_MB10_TIMESTAMP(val)	bfin_write16(CAN1_MB10_TIMESTAMP, val)
+#define bfin_read_CAN1_MB10_ID0()		bfin_read16(CAN1_MB10_ID0)
+#define bfin_write_CAN1_MB10_ID0(val)		bfin_write16(CAN1_MB10_ID0, val)
+#define bfin_read_CAN1_MB10_ID1()		bfin_read16(CAN1_MB10_ID1)
+#define bfin_write_CAN1_MB10_ID1(val)		bfin_write16(CAN1_MB10_ID1, val)
+#define bfin_read_CAN1_MB11_DATA0()		bfin_read16(CAN1_MB11_DATA0)
+#define bfin_write_CAN1_MB11_DATA0(val)		bfin_write16(CAN1_MB11_DATA0, val)
+#define bfin_read_CAN1_MB11_DATA1()		bfin_read16(CAN1_MB11_DATA1)
+#define bfin_write_CAN1_MB11_DATA1(val)		bfin_write16(CAN1_MB11_DATA1, val)
+#define bfin_read_CAN1_MB11_DATA2()		bfin_read16(CAN1_MB11_DATA2)
+#define bfin_write_CAN1_MB11_DATA2(val)		bfin_write16(CAN1_MB11_DATA2, val)
+#define bfin_read_CAN1_MB11_DATA3()		bfin_read16(CAN1_MB11_DATA3)
+#define bfin_write_CAN1_MB11_DATA3(val)		bfin_write16(CAN1_MB11_DATA3, val)
+#define bfin_read_CAN1_MB11_LENGTH()		bfin_read16(CAN1_MB11_LENGTH)
+#define bfin_write_CAN1_MB11_LENGTH(val)	bfin_write16(CAN1_MB11_LENGTH, val)
+#define bfin_read_CAN1_MB11_TIMESTAMP()		bfin_read16(CAN1_MB11_TIMESTAMP)
+#define bfin_write_CAN1_MB11_TIMESTAMP(val)	bfin_write16(CAN1_MB11_TIMESTAMP, val)
+#define bfin_read_CAN1_MB11_ID0()		bfin_read16(CAN1_MB11_ID0)
+#define bfin_write_CAN1_MB11_ID0(val)		bfin_write16(CAN1_MB11_ID0, val)
+#define bfin_read_CAN1_MB11_ID1()		bfin_read16(CAN1_MB11_ID1)
+#define bfin_write_CAN1_MB11_ID1(val)		bfin_write16(CAN1_MB11_ID1, val)
+#define bfin_read_CAN1_MB12_DATA0()		bfin_read16(CAN1_MB12_DATA0)
+#define bfin_write_CAN1_MB12_DATA0(val)		bfin_write16(CAN1_MB12_DATA0, val)
+#define bfin_read_CAN1_MB12_DATA1()		bfin_read16(CAN1_MB12_DATA1)
+#define bfin_write_CAN1_MB12_DATA1(val)		bfin_write16(CAN1_MB12_DATA1, val)
+#define bfin_read_CAN1_MB12_DATA2()		bfin_read16(CAN1_MB12_DATA2)
+#define bfin_write_CAN1_MB12_DATA2(val)		bfin_write16(CAN1_MB12_DATA2, val)
+#define bfin_read_CAN1_MB12_DATA3()		bfin_read16(CAN1_MB12_DATA3)
+#define bfin_write_CAN1_MB12_DATA3(val)		bfin_write16(CAN1_MB12_DATA3, val)
+#define bfin_read_CAN1_MB12_LENGTH()		bfin_read16(CAN1_MB12_LENGTH)
+#define bfin_write_CAN1_MB12_LENGTH(val)	bfin_write16(CAN1_MB12_LENGTH, val)
+#define bfin_read_CAN1_MB12_TIMESTAMP()		bfin_read16(CAN1_MB12_TIMESTAMP)
+#define bfin_write_CAN1_MB12_TIMESTAMP(val)	bfin_write16(CAN1_MB12_TIMESTAMP, val)
+#define bfin_read_CAN1_MB12_ID0()		bfin_read16(CAN1_MB12_ID0)
+#define bfin_write_CAN1_MB12_ID0(val)		bfin_write16(CAN1_MB12_ID0, val)
+#define bfin_read_CAN1_MB12_ID1()		bfin_read16(CAN1_MB12_ID1)
+#define bfin_write_CAN1_MB12_ID1(val)		bfin_write16(CAN1_MB12_ID1, val)
+#define bfin_read_CAN1_MB13_DATA0()		bfin_read16(CAN1_MB13_DATA0)
+#define bfin_write_CAN1_MB13_DATA0(val)		bfin_write16(CAN1_MB13_DATA0, val)
+#define bfin_read_CAN1_MB13_DATA1()		bfin_read16(CAN1_MB13_DATA1)
+#define bfin_write_CAN1_MB13_DATA1(val)		bfin_write16(CAN1_MB13_DATA1, val)
+#define bfin_read_CAN1_MB13_DATA2()		bfin_read16(CAN1_MB13_DATA2)
+#define bfin_write_CAN1_MB13_DATA2(val)		bfin_write16(CAN1_MB13_DATA2, val)
+#define bfin_read_CAN1_MB13_DATA3()		bfin_read16(CAN1_MB13_DATA3)
+#define bfin_write_CAN1_MB13_DATA3(val)		bfin_write16(CAN1_MB13_DATA3, val)
+#define bfin_read_CAN1_MB13_LENGTH()		bfin_read16(CAN1_MB13_LENGTH)
+#define bfin_write_CAN1_MB13_LENGTH(val)	bfin_write16(CAN1_MB13_LENGTH, val)
+#define bfin_read_CAN1_MB13_TIMESTAMP()		bfin_read16(CAN1_MB13_TIMESTAMP)
+#define bfin_write_CAN1_MB13_TIMESTAMP(val)	bfin_write16(CAN1_MB13_TIMESTAMP, val)
+#define bfin_read_CAN1_MB13_ID0()		bfin_read16(CAN1_MB13_ID0)
+#define bfin_write_CAN1_MB13_ID0(val)		bfin_write16(CAN1_MB13_ID0, val)
+#define bfin_read_CAN1_MB13_ID1()		bfin_read16(CAN1_MB13_ID1)
+#define bfin_write_CAN1_MB13_ID1(val)		bfin_write16(CAN1_MB13_ID1, val)
+#define bfin_read_CAN1_MB14_DATA0()		bfin_read16(CAN1_MB14_DATA0)
+#define bfin_write_CAN1_MB14_DATA0(val)		bfin_write16(CAN1_MB14_DATA0, val)
+#define bfin_read_CAN1_MB14_DATA1()		bfin_read16(CAN1_MB14_DATA1)
+#define bfin_write_CAN1_MB14_DATA1(val)		bfin_write16(CAN1_MB14_DATA1, val)
+#define bfin_read_CAN1_MB14_DATA2()		bfin_read16(CAN1_MB14_DATA2)
+#define bfin_write_CAN1_MB14_DATA2(val)		bfin_write16(CAN1_MB14_DATA2, val)
+#define bfin_read_CAN1_MB14_DATA3()		bfin_read16(CAN1_MB14_DATA3)
+#define bfin_write_CAN1_MB14_DATA3(val)		bfin_write16(CAN1_MB14_DATA3, val)
+#define bfin_read_CAN1_MB14_LENGTH()		bfin_read16(CAN1_MB14_LENGTH)
+#define bfin_write_CAN1_MB14_LENGTH(val)	bfin_write16(CAN1_MB14_LENGTH, val)
+#define bfin_read_CAN1_MB14_TIMESTAMP()		bfin_read16(CAN1_MB14_TIMESTAMP)
+#define bfin_write_CAN1_MB14_TIMESTAMP(val)	bfin_write16(CAN1_MB14_TIMESTAMP, val)
+#define bfin_read_CAN1_MB14_ID0()		bfin_read16(CAN1_MB14_ID0)
+#define bfin_write_CAN1_MB14_ID0(val)		bfin_write16(CAN1_MB14_ID0, val)
+#define bfin_read_CAN1_MB14_ID1()		bfin_read16(CAN1_MB14_ID1)
+#define bfin_write_CAN1_MB14_ID1(val)		bfin_write16(CAN1_MB14_ID1, val)
+#define bfin_read_CAN1_MB15_DATA0()		bfin_read16(CAN1_MB15_DATA0)
+#define bfin_write_CAN1_MB15_DATA0(val)		bfin_write16(CAN1_MB15_DATA0, val)
+#define bfin_read_CAN1_MB15_DATA1()		bfin_read16(CAN1_MB15_DATA1)
+#define bfin_write_CAN1_MB15_DATA1(val)		bfin_write16(CAN1_MB15_DATA1, val)
+#define bfin_read_CAN1_MB15_DATA2()		bfin_read16(CAN1_MB15_DATA2)
+#define bfin_write_CAN1_MB15_DATA2(val)		bfin_write16(CAN1_MB15_DATA2, val)
+#define bfin_read_CAN1_MB15_DATA3()		bfin_read16(CAN1_MB15_DATA3)
+#define bfin_write_CAN1_MB15_DATA3(val)		bfin_write16(CAN1_MB15_DATA3, val)
+#define bfin_read_CAN1_MB15_LENGTH()		bfin_read16(CAN1_MB15_LENGTH)
+#define bfin_write_CAN1_MB15_LENGTH(val)	bfin_write16(CAN1_MB15_LENGTH, val)
+#define bfin_read_CAN1_MB15_TIMESTAMP()		bfin_read16(CAN1_MB15_TIMESTAMP)
+#define bfin_write_CAN1_MB15_TIMESTAMP(val)	bfin_write16(CAN1_MB15_TIMESTAMP, val)
+#define bfin_read_CAN1_MB15_ID0()		bfin_read16(CAN1_MB15_ID0)
+#define bfin_write_CAN1_MB15_ID0(val)		bfin_write16(CAN1_MB15_ID0, val)
+#define bfin_read_CAN1_MB15_ID1()		bfin_read16(CAN1_MB15_ID1)
+#define bfin_write_CAN1_MB15_ID1(val)		bfin_write16(CAN1_MB15_ID1, val)
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define bfin_read_CAN1_MB16_DATA0()		bfin_read16(CAN1_MB16_DATA0)
+#define bfin_write_CAN1_MB16_DATA0(val)		bfin_write16(CAN1_MB16_DATA0, val)
+#define bfin_read_CAN1_MB16_DATA1()		bfin_read16(CAN1_MB16_DATA1)
+#define bfin_write_CAN1_MB16_DATA1(val)		bfin_write16(CAN1_MB16_DATA1, val)
+#define bfin_read_CAN1_MB16_DATA2()		bfin_read16(CAN1_MB16_DATA2)
+#define bfin_write_CAN1_MB16_DATA2(val)		bfin_write16(CAN1_MB16_DATA2, val)
+#define bfin_read_CAN1_MB16_DATA3()		bfin_read16(CAN1_MB16_DATA3)
+#define bfin_write_CAN1_MB16_DATA3(val)		bfin_write16(CAN1_MB16_DATA3, val)
+#define bfin_read_CAN1_MB16_LENGTH()		bfin_read16(CAN1_MB16_LENGTH)
+#define bfin_write_CAN1_MB16_LENGTH(val)	bfin_write16(CAN1_MB16_LENGTH, val)
+#define bfin_read_CAN1_MB16_TIMESTAMP()		bfin_read16(CAN1_MB16_TIMESTAMP)
+#define bfin_write_CAN1_MB16_TIMESTAMP(val)	bfin_write16(CAN1_MB16_TIMESTAMP, val)
+#define bfin_read_CAN1_MB16_ID0()		bfin_read16(CAN1_MB16_ID0)
+#define bfin_write_CAN1_MB16_ID0(val)		bfin_write16(CAN1_MB16_ID0, val)
+#define bfin_read_CAN1_MB16_ID1()		bfin_read16(CAN1_MB16_ID1)
+#define bfin_write_CAN1_MB16_ID1(val)		bfin_write16(CAN1_MB16_ID1, val)
+#define bfin_read_CAN1_MB17_DATA0()		bfin_read16(CAN1_MB17_DATA0)
+#define bfin_write_CAN1_MB17_DATA0(val)		bfin_write16(CAN1_MB17_DATA0, val)
+#define bfin_read_CAN1_MB17_DATA1()		bfin_read16(CAN1_MB17_DATA1)
+#define bfin_write_CAN1_MB17_DATA1(val)		bfin_write16(CAN1_MB17_DATA1, val)
+#define bfin_read_CAN1_MB17_DATA2()		bfin_read16(CAN1_MB17_DATA2)
+#define bfin_write_CAN1_MB17_DATA2(val)		bfin_write16(CAN1_MB17_DATA2, val)
+#define bfin_read_CAN1_MB17_DATA3()		bfin_read16(CAN1_MB17_DATA3)
+#define bfin_write_CAN1_MB17_DATA3(val)		bfin_write16(CAN1_MB17_DATA3, val)
+#define bfin_read_CAN1_MB17_LENGTH()		bfin_read16(CAN1_MB17_LENGTH)
+#define bfin_write_CAN1_MB17_LENGTH(val)	bfin_write16(CAN1_MB17_LENGTH, val)
+#define bfin_read_CAN1_MB17_TIMESTAMP()		bfin_read16(CAN1_MB17_TIMESTAMP)
+#define bfin_write_CAN1_MB17_TIMESTAMP(val)	bfin_write16(CAN1_MB17_TIMESTAMP, val)
+#define bfin_read_CAN1_MB17_ID0()		bfin_read16(CAN1_MB17_ID0)
+#define bfin_write_CAN1_MB17_ID0(val)		bfin_write16(CAN1_MB17_ID0, val)
+#define bfin_read_CAN1_MB17_ID1()		bfin_read16(CAN1_MB17_ID1)
+#define bfin_write_CAN1_MB17_ID1(val)		bfin_write16(CAN1_MB17_ID1, val)
+#define bfin_read_CAN1_MB18_DATA0()		bfin_read16(CAN1_MB18_DATA0)
+#define bfin_write_CAN1_MB18_DATA0(val)		bfin_write16(CAN1_MB18_DATA0, val)
+#define bfin_read_CAN1_MB18_DATA1()		bfin_read16(CAN1_MB18_DATA1)
+#define bfin_write_CAN1_MB18_DATA1(val)		bfin_write16(CAN1_MB18_DATA1, val)
+#define bfin_read_CAN1_MB18_DATA2()		bfin_read16(CAN1_MB18_DATA2)
+#define bfin_write_CAN1_MB18_DATA2(val)		bfin_write16(CAN1_MB18_DATA2, val)
+#define bfin_read_CAN1_MB18_DATA3()		bfin_read16(CAN1_MB18_DATA3)
+#define bfin_write_CAN1_MB18_DATA3(val)		bfin_write16(CAN1_MB18_DATA3, val)
+#define bfin_read_CAN1_MB18_LENGTH()		bfin_read16(CAN1_MB18_LENGTH)
+#define bfin_write_CAN1_MB18_LENGTH(val)	bfin_write16(CAN1_MB18_LENGTH, val)
+#define bfin_read_CAN1_MB18_TIMESTAMP()		bfin_read16(CAN1_MB18_TIMESTAMP)
+#define bfin_write_CAN1_MB18_TIMESTAMP(val)	bfin_write16(CAN1_MB18_TIMESTAMP, val)
+#define bfin_read_CAN1_MB18_ID0()		bfin_read16(CAN1_MB18_ID0)
+#define bfin_write_CAN1_MB18_ID0(val)		bfin_write16(CAN1_MB18_ID0, val)
+#define bfin_read_CAN1_MB18_ID1()		bfin_read16(CAN1_MB18_ID1)
+#define bfin_write_CAN1_MB18_ID1(val)		bfin_write16(CAN1_MB18_ID1, val)
+#define bfin_read_CAN1_MB19_DATA0()		bfin_read16(CAN1_MB19_DATA0)
+#define bfin_write_CAN1_MB19_DATA0(val)		bfin_write16(CAN1_MB19_DATA0, val)
+#define bfin_read_CAN1_MB19_DATA1()		bfin_read16(CAN1_MB19_DATA1)
+#define bfin_write_CAN1_MB19_DATA1(val)		bfin_write16(CAN1_MB19_DATA1, val)
+#define bfin_read_CAN1_MB19_DATA2()		bfin_read16(CAN1_MB19_DATA2)
+#define bfin_write_CAN1_MB19_DATA2(val)		bfin_write16(CAN1_MB19_DATA2, val)
+#define bfin_read_CAN1_MB19_DATA3()		bfin_read16(CAN1_MB19_DATA3)
+#define bfin_write_CAN1_MB19_DATA3(val)		bfin_write16(CAN1_MB19_DATA3, val)
+#define bfin_read_CAN1_MB19_LENGTH()		bfin_read16(CAN1_MB19_LENGTH)
+#define bfin_write_CAN1_MB19_LENGTH(val)	bfin_write16(CAN1_MB19_LENGTH, val)
+#define bfin_read_CAN1_MB19_TIMESTAMP()		bfin_read16(CAN1_MB19_TIMESTAMP)
+#define bfin_write_CAN1_MB19_TIMESTAMP(val)	bfin_write16(CAN1_MB19_TIMESTAMP, val)
+#define bfin_read_CAN1_MB19_ID0()		bfin_read16(CAN1_MB19_ID0)
+#define bfin_write_CAN1_MB19_ID0(val)		bfin_write16(CAN1_MB19_ID0, val)
+#define bfin_read_CAN1_MB19_ID1()		bfin_read16(CAN1_MB19_ID1)
+#define bfin_write_CAN1_MB19_ID1(val)		bfin_write16(CAN1_MB19_ID1, val)
+#define bfin_read_CAN1_MB20_DATA0()		bfin_read16(CAN1_MB20_DATA0)
+#define bfin_write_CAN1_MB20_DATA0(val)		bfin_write16(CAN1_MB20_DATA0, val)
+#define bfin_read_CAN1_MB20_DATA1()		bfin_read16(CAN1_MB20_DATA1)
+#define bfin_write_CAN1_MB20_DATA1(val)		bfin_write16(CAN1_MB20_DATA1, val)
+#define bfin_read_CAN1_MB20_DATA2()		bfin_read16(CAN1_MB20_DATA2)
+#define bfin_write_CAN1_MB20_DATA2(val)		bfin_write16(CAN1_MB20_DATA2, val)
+#define bfin_read_CAN1_MB20_DATA3()		bfin_read16(CAN1_MB20_DATA3)
+#define bfin_write_CAN1_MB20_DATA3(val)		bfin_write16(CAN1_MB20_DATA3, val)
+#define bfin_read_CAN1_MB20_LENGTH()		bfin_read16(CAN1_MB20_LENGTH)
+#define bfin_write_CAN1_MB20_LENGTH(val)	bfin_write16(CAN1_MB20_LENGTH, val)
+#define bfin_read_CAN1_MB20_TIMESTAMP()		bfin_read16(CAN1_MB20_TIMESTAMP)
+#define bfin_write_CAN1_MB20_TIMESTAMP(val)	bfin_write16(CAN1_MB20_TIMESTAMP, val)
+#define bfin_read_CAN1_MB20_ID0()		bfin_read16(CAN1_MB20_ID0)
+#define bfin_write_CAN1_MB20_ID0(val)		bfin_write16(CAN1_MB20_ID0, val)
+#define bfin_read_CAN1_MB20_ID1()		bfin_read16(CAN1_MB20_ID1)
+#define bfin_write_CAN1_MB20_ID1(val)		bfin_write16(CAN1_MB20_ID1, val)
+#define bfin_read_CAN1_MB21_DATA0()		bfin_read16(CAN1_MB21_DATA0)
+#define bfin_write_CAN1_MB21_DATA0(val)		bfin_write16(CAN1_MB21_DATA0, val)
+#define bfin_read_CAN1_MB21_DATA1()		bfin_read16(CAN1_MB21_DATA1)
+#define bfin_write_CAN1_MB21_DATA1(val)		bfin_write16(CAN1_MB21_DATA1, val)
+#define bfin_read_CAN1_MB21_DATA2()		bfin_read16(CAN1_MB21_DATA2)
+#define bfin_write_CAN1_MB21_DATA2(val)		bfin_write16(CAN1_MB21_DATA2, val)
+#define bfin_read_CAN1_MB21_DATA3()		bfin_read16(CAN1_MB21_DATA3)
+#define bfin_write_CAN1_MB21_DATA3(val)		bfin_write16(CAN1_MB21_DATA3, val)
+#define bfin_read_CAN1_MB21_LENGTH()		bfin_read16(CAN1_MB21_LENGTH)
+#define bfin_write_CAN1_MB21_LENGTH(val)	bfin_write16(CAN1_MB21_LENGTH, val)
+#define bfin_read_CAN1_MB21_TIMESTAMP()		bfin_read16(CAN1_MB21_TIMESTAMP)
+#define bfin_write_CAN1_MB21_TIMESTAMP(val)	bfin_write16(CAN1_MB21_TIMESTAMP, val)
+#define bfin_read_CAN1_MB21_ID0()		bfin_read16(CAN1_MB21_ID0)
+#define bfin_write_CAN1_MB21_ID0(val)		bfin_write16(CAN1_MB21_ID0, val)
+#define bfin_read_CAN1_MB21_ID1()		bfin_read16(CAN1_MB21_ID1)
+#define bfin_write_CAN1_MB21_ID1(val)		bfin_write16(CAN1_MB21_ID1, val)
+#define bfin_read_CAN1_MB22_DATA0()		bfin_read16(CAN1_MB22_DATA0)
+#define bfin_write_CAN1_MB22_DATA0(val)		bfin_write16(CAN1_MB22_DATA0, val)
+#define bfin_read_CAN1_MB22_DATA1()		bfin_read16(CAN1_MB22_DATA1)
+#define bfin_write_CAN1_MB22_DATA1(val)		bfin_write16(CAN1_MB22_DATA1, val)
+#define bfin_read_CAN1_MB22_DATA2()		bfin_read16(CAN1_MB22_DATA2)
+#define bfin_write_CAN1_MB22_DATA2(val)		bfin_write16(CAN1_MB22_DATA2, val)
+#define bfin_read_CAN1_MB22_DATA3()		bfin_read16(CAN1_MB22_DATA3)
+#define bfin_write_CAN1_MB22_DATA3(val)		bfin_write16(CAN1_MB22_DATA3, val)
+#define bfin_read_CAN1_MB22_LENGTH()		bfin_read16(CAN1_MB22_LENGTH)
+#define bfin_write_CAN1_MB22_LENGTH(val)	bfin_write16(CAN1_MB22_LENGTH, val)
+#define bfin_read_CAN1_MB22_TIMESTAMP()		bfin_read16(CAN1_MB22_TIMESTAMP)
+#define bfin_write_CAN1_MB22_TIMESTAMP(val)	bfin_write16(CAN1_MB22_TIMESTAMP, val)
+#define bfin_read_CAN1_MB22_ID0()		bfin_read16(CAN1_MB22_ID0)
+#define bfin_write_CAN1_MB22_ID0(val)		bfin_write16(CAN1_MB22_ID0, val)
+#define bfin_read_CAN1_MB22_ID1()		bfin_read16(CAN1_MB22_ID1)
+#define bfin_write_CAN1_MB22_ID1(val)		bfin_write16(CAN1_MB22_ID1, val)
+#define bfin_read_CAN1_MB23_DATA0()		bfin_read16(CAN1_MB23_DATA0)
+#define bfin_write_CAN1_MB23_DATA0(val)		bfin_write16(CAN1_MB23_DATA0, val)
+#define bfin_read_CAN1_MB23_DATA1()		bfin_read16(CAN1_MB23_DATA1)
+#define bfin_write_CAN1_MB23_DATA1(val)		bfin_write16(CAN1_MB23_DATA1, val)
+#define bfin_read_CAN1_MB23_DATA2()		bfin_read16(CAN1_MB23_DATA2)
+#define bfin_write_CAN1_MB23_DATA2(val)		bfin_write16(CAN1_MB23_DATA2, val)
+#define bfin_read_CAN1_MB23_DATA3()		bfin_read16(CAN1_MB23_DATA3)
+#define bfin_write_CAN1_MB23_DATA3(val)		bfin_write16(CAN1_MB23_DATA3, val)
+#define bfin_read_CAN1_MB23_LENGTH()		bfin_read16(CAN1_MB23_LENGTH)
+#define bfin_write_CAN1_MB23_LENGTH(val)	bfin_write16(CAN1_MB23_LENGTH, val)
+#define bfin_read_CAN1_MB23_TIMESTAMP()		bfin_read16(CAN1_MB23_TIMESTAMP)
+#define bfin_write_CAN1_MB23_TIMESTAMP(val)	bfin_write16(CAN1_MB23_TIMESTAMP, val)
+#define bfin_read_CAN1_MB23_ID0()		bfin_read16(CAN1_MB23_ID0)
+#define bfin_write_CAN1_MB23_ID0(val)		bfin_write16(CAN1_MB23_ID0, val)
+#define bfin_read_CAN1_MB23_ID1()		bfin_read16(CAN1_MB23_ID1)
+#define bfin_write_CAN1_MB23_ID1(val)		bfin_write16(CAN1_MB23_ID1, val)
+#define bfin_read_CAN1_MB24_DATA0()		bfin_read16(CAN1_MB24_DATA0)
+#define bfin_write_CAN1_MB24_DATA0(val)		bfin_write16(CAN1_MB24_DATA0, val)
+#define bfin_read_CAN1_MB24_DATA1()		bfin_read16(CAN1_MB24_DATA1)
+#define bfin_write_CAN1_MB24_DATA1(val)		bfin_write16(CAN1_MB24_DATA1, val)
+#define bfin_read_CAN1_MB24_DATA2()		bfin_read16(CAN1_MB24_DATA2)
+#define bfin_write_CAN1_MB24_DATA2(val)		bfin_write16(CAN1_MB24_DATA2, val)
+#define bfin_read_CAN1_MB24_DATA3()		bfin_read16(CAN1_MB24_DATA3)
+#define bfin_write_CAN1_MB24_DATA3(val)		bfin_write16(CAN1_MB24_DATA3, val)
+#define bfin_read_CAN1_MB24_LENGTH()		bfin_read16(CAN1_MB24_LENGTH)
+#define bfin_write_CAN1_MB24_LENGTH(val)	bfin_write16(CAN1_MB24_LENGTH, val)
+#define bfin_read_CAN1_MB24_TIMESTAMP()		bfin_read16(CAN1_MB24_TIMESTAMP)
+#define bfin_write_CAN1_MB24_TIMESTAMP(val)	bfin_write16(CAN1_MB24_TIMESTAMP, val)
+#define bfin_read_CAN1_MB24_ID0()		bfin_read16(CAN1_MB24_ID0)
+#define bfin_write_CAN1_MB24_ID0(val)		bfin_write16(CAN1_MB24_ID0, val)
+#define bfin_read_CAN1_MB24_ID1()		bfin_read16(CAN1_MB24_ID1)
+#define bfin_write_CAN1_MB24_ID1(val)		bfin_write16(CAN1_MB24_ID1, val)
+#define bfin_read_CAN1_MB25_DATA0()		bfin_read16(CAN1_MB25_DATA0)
+#define bfin_write_CAN1_MB25_DATA0(val)		bfin_write16(CAN1_MB25_DATA0, val)
+#define bfin_read_CAN1_MB25_DATA1()		bfin_read16(CAN1_MB25_DATA1)
+#define bfin_write_CAN1_MB25_DATA1(val)		bfin_write16(CAN1_MB25_DATA1, val)
+#define bfin_read_CAN1_MB25_DATA2()		bfin_read16(CAN1_MB25_DATA2)
+#define bfin_write_CAN1_MB25_DATA2(val)		bfin_write16(CAN1_MB25_DATA2, val)
+#define bfin_read_CAN1_MB25_DATA3()		bfin_read16(CAN1_MB25_DATA3)
+#define bfin_write_CAN1_MB25_DATA3(val)		bfin_write16(CAN1_MB25_DATA3, val)
+#define bfin_read_CAN1_MB25_LENGTH()		bfin_read16(CAN1_MB25_LENGTH)
+#define bfin_write_CAN1_MB25_LENGTH(val)	bfin_write16(CAN1_MB25_LENGTH, val)
+#define bfin_read_CAN1_MB25_TIMESTAMP()		bfin_read16(CAN1_MB25_TIMESTAMP)
+#define bfin_write_CAN1_MB25_TIMESTAMP(val)	bfin_write16(CAN1_MB25_TIMESTAMP, val)
+#define bfin_read_CAN1_MB25_ID0()		bfin_read16(CAN1_MB25_ID0)
+#define bfin_write_CAN1_MB25_ID0(val)		bfin_write16(CAN1_MB25_ID0, val)
+#define bfin_read_CAN1_MB25_ID1()		bfin_read16(CAN1_MB25_ID1)
+#define bfin_write_CAN1_MB25_ID1(val)		bfin_write16(CAN1_MB25_ID1, val)
+#define bfin_read_CAN1_MB26_DATA0()		bfin_read16(CAN1_MB26_DATA0)
+#define bfin_write_CAN1_MB26_DATA0(val)		bfin_write16(CAN1_MB26_DATA0, val)
+#define bfin_read_CAN1_MB26_DATA1()		bfin_read16(CAN1_MB26_DATA1)
+#define bfin_write_CAN1_MB26_DATA1(val)		bfin_write16(CAN1_MB26_DATA1, val)
+#define bfin_read_CAN1_MB26_DATA2()		bfin_read16(CAN1_MB26_DATA2)
+#define bfin_write_CAN1_MB26_DATA2(val)		bfin_write16(CAN1_MB26_DATA2, val)
+#define bfin_read_CAN1_MB26_DATA3()		bfin_read16(CAN1_MB26_DATA3)
+#define bfin_write_CAN1_MB26_DATA3(val)		bfin_write16(CAN1_MB26_DATA3, val)
+#define bfin_read_CAN1_MB26_LENGTH()		bfin_read16(CAN1_MB26_LENGTH)
+#define bfin_write_CAN1_MB26_LENGTH(val)	bfin_write16(CAN1_MB26_LENGTH, val)
+#define bfin_read_CAN1_MB26_TIMESTAMP()		bfin_read16(CAN1_MB26_TIMESTAMP)
+#define bfin_write_CAN1_MB26_TIMESTAMP(val)	bfin_write16(CAN1_MB26_TIMESTAMP, val)
+#define bfin_read_CAN1_MB26_ID0()		bfin_read16(CAN1_MB26_ID0)
+#define bfin_write_CAN1_MB26_ID0(val)		bfin_write16(CAN1_MB26_ID0, val)
+#define bfin_read_CAN1_MB26_ID1()		bfin_read16(CAN1_MB26_ID1)
+#define bfin_write_CAN1_MB26_ID1(val)		bfin_write16(CAN1_MB26_ID1, val)
+#define bfin_read_CAN1_MB27_DATA0()		bfin_read16(CAN1_MB27_DATA0)
+#define bfin_write_CAN1_MB27_DATA0(val)		bfin_write16(CAN1_MB27_DATA0, val)
+#define bfin_read_CAN1_MB27_DATA1()		bfin_read16(CAN1_MB27_DATA1)
+#define bfin_write_CAN1_MB27_DATA1(val)		bfin_write16(CAN1_MB27_DATA1, val)
+#define bfin_read_CAN1_MB27_DATA2()		bfin_read16(CAN1_MB27_DATA2)
+#define bfin_write_CAN1_MB27_DATA2(val)		bfin_write16(CAN1_MB27_DATA2, val)
+#define bfin_read_CAN1_MB27_DATA3()		bfin_read16(CAN1_MB27_DATA3)
+#define bfin_write_CAN1_MB27_DATA3(val)		bfin_write16(CAN1_MB27_DATA3, val)
+#define bfin_read_CAN1_MB27_LENGTH()		bfin_read16(CAN1_MB27_LENGTH)
+#define bfin_write_CAN1_MB27_LENGTH(val)	bfin_write16(CAN1_MB27_LENGTH, val)
+#define bfin_read_CAN1_MB27_TIMESTAMP()		bfin_read16(CAN1_MB27_TIMESTAMP)
+#define bfin_write_CAN1_MB27_TIMESTAMP(val)	bfin_write16(CAN1_MB27_TIMESTAMP, val)
+#define bfin_read_CAN1_MB27_ID0()		bfin_read16(CAN1_MB27_ID0)
+#define bfin_write_CAN1_MB27_ID0(val)		bfin_write16(CAN1_MB27_ID0, val)
+#define bfin_read_CAN1_MB27_ID1()		bfin_read16(CAN1_MB27_ID1)
+#define bfin_write_CAN1_MB27_ID1(val)		bfin_write16(CAN1_MB27_ID1, val)
+#define bfin_read_CAN1_MB28_DATA0()		bfin_read16(CAN1_MB28_DATA0)
+#define bfin_write_CAN1_MB28_DATA0(val)		bfin_write16(CAN1_MB28_DATA0, val)
+#define bfin_read_CAN1_MB28_DATA1()		bfin_read16(CAN1_MB28_DATA1)
+#define bfin_write_CAN1_MB28_DATA1(val)		bfin_write16(CAN1_MB28_DATA1, val)
+#define bfin_read_CAN1_MB28_DATA2()		bfin_read16(CAN1_MB28_DATA2)
+#define bfin_write_CAN1_MB28_DATA2(val)		bfin_write16(CAN1_MB28_DATA2, val)
+#define bfin_read_CAN1_MB28_DATA3()		bfin_read16(CAN1_MB28_DATA3)
+#define bfin_write_CAN1_MB28_DATA3(val)		bfin_write16(CAN1_MB28_DATA3, val)
+#define bfin_read_CAN1_MB28_LENGTH()		bfin_read16(CAN1_MB28_LENGTH)
+#define bfin_write_CAN1_MB28_LENGTH(val)	bfin_write16(CAN1_MB28_LENGTH, val)
+#define bfin_read_CAN1_MB28_TIMESTAMP()		bfin_read16(CAN1_MB28_TIMESTAMP)
+#define bfin_write_CAN1_MB28_TIMESTAMP(val)	bfin_write16(CAN1_MB28_TIMESTAMP, val)
+#define bfin_read_CAN1_MB28_ID0()		bfin_read16(CAN1_MB28_ID0)
+#define bfin_write_CAN1_MB28_ID0(val)		bfin_write16(CAN1_MB28_ID0, val)
+#define bfin_read_CAN1_MB28_ID1()		bfin_read16(CAN1_MB28_ID1)
+#define bfin_write_CAN1_MB28_ID1(val)		bfin_write16(CAN1_MB28_ID1, val)
+#define bfin_read_CAN1_MB29_DATA0()		bfin_read16(CAN1_MB29_DATA0)
+#define bfin_write_CAN1_MB29_DATA0(val)		bfin_write16(CAN1_MB29_DATA0, val)
+#define bfin_read_CAN1_MB29_DATA1()		bfin_read16(CAN1_MB29_DATA1)
+#define bfin_write_CAN1_MB29_DATA1(val)		bfin_write16(CAN1_MB29_DATA1, val)
+#define bfin_read_CAN1_MB29_DATA2()		bfin_read16(CAN1_MB29_DATA2)
+#define bfin_write_CAN1_MB29_DATA2(val)		bfin_write16(CAN1_MB29_DATA2, val)
+#define bfin_read_CAN1_MB29_DATA3()		bfin_read16(CAN1_MB29_DATA3)
+#define bfin_write_CAN1_MB29_DATA3(val)		bfin_write16(CAN1_MB29_DATA3, val)
+#define bfin_read_CAN1_MB29_LENGTH()		bfin_read16(CAN1_MB29_LENGTH)
+#define bfin_write_CAN1_MB29_LENGTH(val)	bfin_write16(CAN1_MB29_LENGTH, val)
+#define bfin_read_CAN1_MB29_TIMESTAMP()		bfin_read16(CAN1_MB29_TIMESTAMP)
+#define bfin_write_CAN1_MB29_TIMESTAMP(val)	bfin_write16(CAN1_MB29_TIMESTAMP, val)
+#define bfin_read_CAN1_MB29_ID0()		bfin_read16(CAN1_MB29_ID0)
+#define bfin_write_CAN1_MB29_ID0(val)		bfin_write16(CAN1_MB29_ID0, val)
+#define bfin_read_CAN1_MB29_ID1()		bfin_read16(CAN1_MB29_ID1)
+#define bfin_write_CAN1_MB29_ID1(val)		bfin_write16(CAN1_MB29_ID1, val)
+#define bfin_read_CAN1_MB30_DATA0()		bfin_read16(CAN1_MB30_DATA0)
+#define bfin_write_CAN1_MB30_DATA0(val)		bfin_write16(CAN1_MB30_DATA0, val)
+#define bfin_read_CAN1_MB30_DATA1()		bfin_read16(CAN1_MB30_DATA1)
+#define bfin_write_CAN1_MB30_DATA1(val)		bfin_write16(CAN1_MB30_DATA1, val)
+#define bfin_read_CAN1_MB30_DATA2()		bfin_read16(CAN1_MB30_DATA2)
+#define bfin_write_CAN1_MB30_DATA2(val)		bfin_write16(CAN1_MB30_DATA2, val)
+#define bfin_read_CAN1_MB30_DATA3()		bfin_read16(CAN1_MB30_DATA3)
+#define bfin_write_CAN1_MB30_DATA3(val)		bfin_write16(CAN1_MB30_DATA3, val)
+#define bfin_read_CAN1_MB30_LENGTH()		bfin_read16(CAN1_MB30_LENGTH)
+#define bfin_write_CAN1_MB30_LENGTH(val)	bfin_write16(CAN1_MB30_LENGTH, val)
+#define bfin_read_CAN1_MB30_TIMESTAMP()		bfin_read16(CAN1_MB30_TIMESTAMP)
+#define bfin_write_CAN1_MB30_TIMESTAMP(val)	bfin_write16(CAN1_MB30_TIMESTAMP, val)
+#define bfin_read_CAN1_MB30_ID0()		bfin_read16(CAN1_MB30_ID0)
+#define bfin_write_CAN1_MB30_ID0(val)		bfin_write16(CAN1_MB30_ID0, val)
+#define bfin_read_CAN1_MB30_ID1()		bfin_read16(CAN1_MB30_ID1)
+#define bfin_write_CAN1_MB30_ID1(val)		bfin_write16(CAN1_MB30_ID1, val)
+#define bfin_read_CAN1_MB31_DATA0()		bfin_read16(CAN1_MB31_DATA0)
+#define bfin_write_CAN1_MB31_DATA0(val)		bfin_write16(CAN1_MB31_DATA0, val)
+#define bfin_read_CAN1_MB31_DATA1()		bfin_read16(CAN1_MB31_DATA1)
+#define bfin_write_CAN1_MB31_DATA1(val)		bfin_write16(CAN1_MB31_DATA1, val)
+#define bfin_read_CAN1_MB31_DATA2()		bfin_read16(CAN1_MB31_DATA2)
+#define bfin_write_CAN1_MB31_DATA2(val)		bfin_write16(CAN1_MB31_DATA2, val)
+#define bfin_read_CAN1_MB31_DATA3()		bfin_read16(CAN1_MB31_DATA3)
+#define bfin_write_CAN1_MB31_DATA3(val)		bfin_write16(CAN1_MB31_DATA3, val)
+#define bfin_read_CAN1_MB31_LENGTH()		bfin_read16(CAN1_MB31_LENGTH)
+#define bfin_write_CAN1_MB31_LENGTH(val)	bfin_write16(CAN1_MB31_LENGTH, val)
+#define bfin_read_CAN1_MB31_TIMESTAMP()		bfin_read16(CAN1_MB31_TIMESTAMP)
+#define bfin_write_CAN1_MB31_TIMESTAMP(val)	bfin_write16(CAN1_MB31_TIMESTAMP, val)
+#define bfin_read_CAN1_MB31_ID0()		bfin_read16(CAN1_MB31_ID0)
+#define bfin_write_CAN1_MB31_ID0(val)		bfin_write16(CAN1_MB31_ID0, val)
+#define bfin_read_CAN1_MB31_ID1()		bfin_read16(CAN1_MB31_ID1)
+#define bfin_write_CAN1_MB31_ID1(val)		bfin_write16(CAN1_MB31_ID1, val)
+
+/* ATAPI Registers */
+
+#define bfin_read_ATAPI_CONTROL()		bfin_read16(ATAPI_CONTROL)
+#define bfin_write_ATAPI_CONTROL(val)		bfin_write16(ATAPI_CONTROL, val)
+#define bfin_read_ATAPI_STATUS()		bfin_read16(ATAPI_STATUS)
+#define bfin_write_ATAPI_STATUS(val)		bfin_write16(ATAPI_STATUS, val)
+#define bfin_read_ATAPI_DEV_ADDR()		bfin_read16(ATAPI_DEV_ADDR)
+#define bfin_write_ATAPI_DEV_ADDR(val)		bfin_write16(ATAPI_DEV_ADDR, val)
+#define bfin_read_ATAPI_DEV_TXBUF()		bfin_read16(ATAPI_DEV_TXBUF)
+#define bfin_write_ATAPI_DEV_TXBUF(val)		bfin_write16(ATAPI_DEV_TXBUF, val)
+#define bfin_read_ATAPI_DEV_RXBUF()		bfin_read16(ATAPI_DEV_RXBUF)
+#define bfin_write_ATAPI_DEV_RXBUF(val)		bfin_write16(ATAPI_DEV_RXBUF, val)
+#define bfin_read_ATAPI_INT_MASK()		bfin_read16(ATAPI_INT_MASK)
+#define bfin_write_ATAPI_INT_MASK(val)		bfin_write16(ATAPI_INT_MASK, val)
+#define bfin_read_ATAPI_INT_STATUS()		bfin_read16(ATAPI_INT_STATUS)
+#define bfin_write_ATAPI_INT_STATUS(val)	bfin_write16(ATAPI_INT_STATUS, val)
+#define bfin_read_ATAPI_XFER_LEN()		bfin_read16(ATAPI_XFER_LEN)
+#define bfin_write_ATAPI_XFER_LEN(val)		bfin_write16(ATAPI_XFER_LEN, val)
+#define bfin_read_ATAPI_LINE_STATUS()		bfin_read16(ATAPI_LINE_STATUS)
+#define bfin_write_ATAPI_LINE_STATUS(val)	bfin_write16(ATAPI_LINE_STATUS, val)
+#define bfin_read_ATAPI_SM_STATE()		bfin_read16(ATAPI_SM_STATE)
+#define bfin_write_ATAPI_SM_STATE(val)		bfin_write16(ATAPI_SM_STATE, val)
+#define bfin_read_ATAPI_TERMINATE()		bfin_read16(ATAPI_TERMINATE)
+#define bfin_write_ATAPI_TERMINATE(val)		bfin_write16(ATAPI_TERMINATE, val)
+#define bfin_read_ATAPI_PIO_TFRCNT()		bfin_read16(ATAPI_PIO_TFRCNT)
+#define bfin_write_ATAPI_PIO_TFRCNT(val)	bfin_write16(ATAPI_PIO_TFRCNT, val)
+#define bfin_read_ATAPI_DMA_TFRCNT()		bfin_read16(ATAPI_DMA_TFRCNT)
+#define bfin_write_ATAPI_DMA_TFRCNT(val)	bfin_write16(ATAPI_DMA_TFRCNT, val)
+#define bfin_read_ATAPI_UMAIN_TFRCNT()		bfin_read16(ATAPI_UMAIN_TFRCNT)
+#define bfin_write_ATAPI_UMAIN_TFRCNT(val)	bfin_write16(ATAPI_UMAIN_TFRCNT, val)
+#define bfin_read_ATAPI_UDMAOUT_TFRCNT()	bfin_read16(ATAPI_UDMAOUT_TFRCNT)
+#define bfin_write_ATAPI_UDMAOUT_TFRCNT(val)	bfin_write16(ATAPI_UDMAOUT_TFRCNT, val)
+#define bfin_read_ATAPI_REG_TIM_0()		bfin_read16(ATAPI_REG_TIM_0)
+#define bfin_write_ATAPI_REG_TIM_0(val)		bfin_write16(ATAPI_REG_TIM_0, val)
+#define bfin_read_ATAPI_PIO_TIM_0()		bfin_read16(ATAPI_PIO_TIM_0)
+#define bfin_write_ATAPI_PIO_TIM_0(val)		bfin_write16(ATAPI_PIO_TIM_0, val)
+#define bfin_read_ATAPI_PIO_TIM_1()		bfin_read16(ATAPI_PIO_TIM_1)
+#define bfin_write_ATAPI_PIO_TIM_1(val)		bfin_write16(ATAPI_PIO_TIM_1, val)
+#define bfin_read_ATAPI_MULTI_TIM_0()		bfin_read16(ATAPI_MULTI_TIM_0)
+#define bfin_write_ATAPI_MULTI_TIM_0(val)	bfin_write16(ATAPI_MULTI_TIM_0, val)
+#define bfin_read_ATAPI_MULTI_TIM_1()		bfin_read16(ATAPI_MULTI_TIM_1)
+#define bfin_write_ATAPI_MULTI_TIM_1(val)	bfin_write16(ATAPI_MULTI_TIM_1, val)
+#define bfin_read_ATAPI_MULTI_TIM_2()		bfin_read16(ATAPI_MULTI_TIM_2)
+#define bfin_write_ATAPI_MULTI_TIM_2(val)	bfin_write16(ATAPI_MULTI_TIM_2, val)
+#define bfin_read_ATAPI_ULTRA_TIM_0()		bfin_read16(ATAPI_ULTRA_TIM_0)
+#define bfin_write_ATAPI_ULTRA_TIM_0(val)	bfin_write16(ATAPI_ULTRA_TIM_0, val)
+#define bfin_read_ATAPI_ULTRA_TIM_1()		bfin_read16(ATAPI_ULTRA_TIM_1)
+#define bfin_write_ATAPI_ULTRA_TIM_1(val)	bfin_write16(ATAPI_ULTRA_TIM_1, val)
+#define bfin_read_ATAPI_ULTRA_TIM_2()		bfin_read16(ATAPI_ULTRA_TIM_2)
+#define bfin_write_ATAPI_ULTRA_TIM_2(val)	bfin_write16(ATAPI_ULTRA_TIM_2, val)
+#define bfin_read_ATAPI_ULTRA_TIM_3()		bfin_read16(ATAPI_ULTRA_TIM_3)
+#define bfin_write_ATAPI_ULTRA_TIM_3(val)	bfin_write16(ATAPI_ULTRA_TIM_3, val)
+
+/* SDH Registers */
+
+#define bfin_read_SDH_PWR_CTL()		bfin_read16(SDH_PWR_CTL)
+#define bfin_write_SDH_PWR_CTL(val)	bfin_write16(SDH_PWR_CTL, val)
+#define bfin_read_SDH_CLK_CTL()		bfin_read16(SDH_CLK_CTL)
+#define bfin_write_SDH_CLK_CTL(val)	bfin_write16(SDH_CLK_CTL, val)
+#define bfin_read_SDH_ARGUMENT()	bfin_read32(SDH_ARGUMENT)
+#define bfin_write_SDH_ARGUMENT(val)	bfin_write32(SDH_ARGUMENT, val)
+#define bfin_read_SDH_COMMAND()		bfin_read16(SDH_COMMAND)
+#define bfin_write_SDH_COMMAND(val)	bfin_write16(SDH_COMMAND, val)
+#define bfin_read_SDH_RESP_CMD()	bfin_read16(SDH_RESP_CMD)
+#define bfin_write_SDH_RESP_CMD(val)	bfin_write16(SDH_RESP_CMD, val)
+#define bfin_read_SDH_RESPONSE0()	bfin_read32(SDH_RESPONSE0)
+#define bfin_write_SDH_RESPONSE0(val)	bfin_write32(SDH_RESPONSE0, val)
+#define bfin_read_SDH_RESPONSE1()	bfin_read32(SDH_RESPONSE1)
+#define bfin_write_SDH_RESPONSE1(val)	bfin_write32(SDH_RESPONSE1, val)
+#define bfin_read_SDH_RESPONSE2()	bfin_read32(SDH_RESPONSE2)
+#define bfin_write_SDH_RESPONSE2(val)	bfin_write32(SDH_RESPONSE2, val)
+#define bfin_read_SDH_RESPONSE3()	bfin_read32(SDH_RESPONSE3)
+#define bfin_write_SDH_RESPONSE3(val)	bfin_write32(SDH_RESPONSE3, val)
+#define bfin_read_SDH_DATA_TIMER()	bfin_read32(SDH_DATA_TIMER)
+#define bfin_write_SDH_DATA_TIMER(val)	bfin_write32(SDH_DATA_TIMER, val)
+#define bfin_read_SDH_DATA_LGTH()	bfin_read16(SDH_DATA_LGTH)
+#define bfin_write_SDH_DATA_LGTH(val)	bfin_write16(SDH_DATA_LGTH, val)
+#define bfin_read_SDH_DATA_CTL()	bfin_read16(SDH_DATA_CTL)
+#define bfin_write_SDH_DATA_CTL(val)	bfin_write16(SDH_DATA_CTL, val)
+#define bfin_read_SDH_DATA_CNT()	bfin_read16(SDH_DATA_CNT)
+#define bfin_write_SDH_DATA_CNT(val)	bfin_write16(SDH_DATA_CNT, val)
+#define bfin_read_SDH_STATUS()		bfin_read32(SDH_STATUS)
+#define bfin_write_SDH_STATUS(val)	bfin_write32(SDH_STATUS, val)
+#define bfin_read_SDH_STATUS_CLR()	bfin_read16(SDH_STATUS_CLR)
+#define bfin_write_SDH_STATUS_CLR(val)	bfin_write16(SDH_STATUS_CLR, val)
+#define bfin_read_SDH_MASK0()		bfin_read32(SDH_MASK0)
+#define bfin_write_SDH_MASK0(val)	bfin_write32(SDH_MASK0, val)
+#define bfin_read_SDH_MASK1()		bfin_read32(SDH_MASK1)
+#define bfin_write_SDH_MASK1(val)	bfin_write32(SDH_MASK1, val)
+#define bfin_read_SDH_FIFO_CNT()	bfin_read16(SDH_FIFO_CNT)
+#define bfin_write_SDH_FIFO_CNT(val)	bfin_write16(SDH_FIFO_CNT, val)
+#define bfin_read_SDH_FIFO()		bfin_read32(SDH_FIFO)
+#define bfin_write_SDH_FIFO(val)	bfin_write32(SDH_FIFO, val)
+#define bfin_read_SDH_E_STATUS()	bfin_read16(SDH_E_STATUS)
+#define bfin_write_SDH_E_STATUS(val)	bfin_write16(SDH_E_STATUS, val)
+#define bfin_read_SDH_E_MASK()		bfin_read16(SDH_E_MASK)
+#define bfin_write_SDH_E_MASK(val)	bfin_write16(SDH_E_MASK, val)
+#define bfin_read_SDH_CFG()		bfin_read16(SDH_CFG)
+#define bfin_write_SDH_CFG(val)		bfin_write16(SDH_CFG, val)
+#define bfin_read_SDH_RD_WAIT_EN()	bfin_read16(SDH_RD_WAIT_EN)
+#define bfin_write_SDH_RD_WAIT_EN(val)	bfin_write16(SDH_RD_WAIT_EN, val)
+#define bfin_read_SDH_PID0()		bfin_read16(SDH_PID0)
+#define bfin_write_SDH_PID0(val)	bfin_write16(SDH_PID0, val)
+#define bfin_read_SDH_PID1()		bfin_read16(SDH_PID1)
+#define bfin_write_SDH_PID1(val)	bfin_write16(SDH_PID1, val)
+#define bfin_read_SDH_PID2()		bfin_read16(SDH_PID2)
+#define bfin_write_SDH_PID2(val)	bfin_write16(SDH_PID2, val)
+#define bfin_read_SDH_PID3()		bfin_read16(SDH_PID3)
+#define bfin_write_SDH_PID3(val)	bfin_write16(SDH_PID3, val)
+#define bfin_read_SDH_PID4()		bfin_read16(SDH_PID4)
+#define bfin_write_SDH_PID4(val)	bfin_write16(SDH_PID4, val)
+#define bfin_read_SDH_PID5()		bfin_read16(SDH_PID5)
+#define bfin_write_SDH_PID5(val)	bfin_write16(SDH_PID5, val)
+#define bfin_read_SDH_PID6()		bfin_read16(SDH_PID6)
+#define bfin_write_SDH_PID6(val)	bfin_write16(SDH_PID6, val)
+#define bfin_read_SDH_PID7()		bfin_read16(SDH_PID7)
+#define bfin_write_SDH_PID7(val)	bfin_write16(SDH_PID7, val)
+
+/* HOST Port Registers */
+
+#define bfin_read_HOST_CONTROL()	bfin_read16(HOST_CONTROL)
+#define bfin_write_HOST_CONTROL(val)	bfin_write16(HOST_CONTROL, val)
+#define bfin_read_HOST_STATUS()		bfin_read16(HOST_STATUS)
+#define bfin_write_HOST_STATUS(val)	bfin_write16(HOST_STATUS, val)
+#define bfin_read_HOST_TIMEOUT()	bfin_read16(HOST_TIMEOUT)
+#define bfin_write_HOST_TIMEOUT(val)	bfin_write16(HOST_TIMEOUT, val)
+
+/* USB Control Registers */
+
+#define bfin_read_USB_FADDR()		bfin_read16(USB_FADDR)
+#define bfin_write_USB_FADDR(val)	bfin_write16(USB_FADDR, val)
+#define bfin_read_USB_POWER()		bfin_read16(USB_POWER)
+#define bfin_write_USB_POWER(val)	bfin_write16(USB_POWER, val)
+#define bfin_read_USB_INTRTX()		bfin_read16(USB_INTRTX)
+#define bfin_write_USB_INTRTX(val)	bfin_write16(USB_INTRTX, val)
+#define bfin_read_USB_INTRRX()		bfin_read16(USB_INTRRX)
+#define bfin_write_USB_INTRRX(val)	bfin_write16(USB_INTRRX, val)
+#define bfin_read_USB_INTRTXE()		bfin_read16(USB_INTRTXE)
+#define bfin_write_USB_INTRTXE(val)	bfin_write16(USB_INTRTXE, val)
+#define bfin_read_USB_INTRRXE()		bfin_read16(USB_INTRRXE)
+#define bfin_write_USB_INTRRXE(val)	bfin_write16(USB_INTRRXE, val)
+#define bfin_read_USB_INTRUSB()		bfin_read16(USB_INTRUSB)
+#define bfin_write_USB_INTRUSB(val)	bfin_write16(USB_INTRUSB, val)
+#define bfin_read_USB_INTRUSBE()	bfin_read16(USB_INTRUSBE)
+#define bfin_write_USB_INTRUSBE(val)	bfin_write16(USB_INTRUSBE, val)
+#define bfin_read_USB_FRAME()		bfin_read16(USB_FRAME)
+#define bfin_write_USB_FRAME(val)	bfin_write16(USB_FRAME, val)
+#define bfin_read_USB_INDEX()		bfin_read16(USB_INDEX)
+#define bfin_write_USB_INDEX(val)	bfin_write16(USB_INDEX, val)
+#define bfin_read_USB_TESTMODE()	bfin_read16(USB_TESTMODE)
+#define bfin_write_USB_TESTMODE(val)	bfin_write16(USB_TESTMODE, val)
+#define bfin_read_USB_GLOBINTR()	bfin_read16(USB_GLOBINTR)
+#define bfin_write_USB_GLOBINTR(val)	bfin_write16(USB_GLOBINTR, val)
+#define bfin_read_USB_GLOBAL_CTL()	bfin_read16(USB_GLOBAL_CTL)
+#define bfin_write_USB_GLOBAL_CTL(val)	bfin_write16(USB_GLOBAL_CTL, val)
+
+/* USB Packet Control Registers */
+
+#define bfin_read_USB_TX_MAX_PACKET()		bfin_read16(USB_TX_MAX_PACKET)
+#define bfin_write_USB_TX_MAX_PACKET(val)	bfin_write16(USB_TX_MAX_PACKET, val)
+#define bfin_read_USB_CSR0()			bfin_read16(USB_CSR0)
+#define bfin_write_USB_CSR0(val)		bfin_write16(USB_CSR0, val)
+#define bfin_read_USB_TXCSR()			bfin_read16(USB_TXCSR)
+#define bfin_write_USB_TXCSR(val)		bfin_write16(USB_TXCSR, val)
+#define bfin_read_USB_RX_MAX_PACKET()		bfin_read16(USB_RX_MAX_PACKET)
+#define bfin_write_USB_RX_MAX_PACKET(val)	bfin_write16(USB_RX_MAX_PACKET, val)
+#define bfin_read_USB_RXCSR()			bfin_read16(USB_RXCSR)
+#define bfin_write_USB_RXCSR(val)		bfin_write16(USB_RXCSR, val)
+#define bfin_read_USB_COUNT0()			bfin_read16(USB_COUNT0)
+#define bfin_write_USB_COUNT0(val)		bfin_write16(USB_COUNT0, val)
+#define bfin_read_USB_RXCOUNT()			bfin_read16(USB_RXCOUNT)
+#define bfin_write_USB_RXCOUNT(val)		bfin_write16(USB_RXCOUNT, val)
+#define bfin_read_USB_TXTYPE()			bfin_read16(USB_TXTYPE)
+#define bfin_write_USB_TXTYPE(val)		bfin_write16(USB_TXTYPE, val)
+#define bfin_read_USB_NAKLIMIT0()		bfin_read16(USB_NAKLIMIT0)
+#define bfin_write_USB_NAKLIMIT0(val)		bfin_write16(USB_NAKLIMIT0, val)
+#define bfin_read_USB_TXINTERVAL()		bfin_read16(USB_TXINTERVAL)
+#define bfin_write_USB_TXINTERVAL(val)		bfin_write16(USB_TXINTERVAL, val)
+#define bfin_read_USB_RXTYPE()			bfin_read16(USB_RXTYPE)
+#define bfin_write_USB_RXTYPE(val)		bfin_write16(USB_RXTYPE, val)
+#define bfin_read_USB_RXINTERVAL()		bfin_read16(USB_RXINTERVAL)
+#define bfin_write_USB_RXINTERVAL(val)		bfin_write16(USB_RXINTERVAL, val)
+#define bfin_read_USB_TXCOUNT()			bfin_read16(USB_TXCOUNT)
+#define bfin_write_USB_TXCOUNT(val)		bfin_write16(USB_TXCOUNT, val)
+
+/* USB Endbfin_read_()oint FIFO Registers */
+
+#define bfin_read_USB_EP0_FIFO()		bfin_read16(USB_EP0_FIFO)
+#define bfin_write_USB_EP0_FIFO(val)		bfin_write16(USB_EP0_FIFO, val)
+#define bfin_read_USB_EP1_FIFO()		bfin_read16(USB_EP1_FIFO)
+#define bfin_write_USB_EP1_FIFO(val)		bfin_write16(USB_EP1_FIFO, val)
+#define bfin_read_USB_EP2_FIFO()		bfin_read16(USB_EP2_FIFO)
+#define bfin_write_USB_EP2_FIFO(val)		bfin_write16(USB_EP2_FIFO, val)
+#define bfin_read_USB_EP3_FIFO()		bfin_read16(USB_EP3_FIFO)
+#define bfin_write_USB_EP3_FIFO(val)		bfin_write16(USB_EP3_FIFO, val)
+#define bfin_read_USB_EP4_FIFO()		bfin_read16(USB_EP4_FIFO)
+#define bfin_write_USB_EP4_FIFO(val)		bfin_write16(USB_EP4_FIFO, val)
+#define bfin_read_USB_EP5_FIFO()		bfin_read16(USB_EP5_FIFO)
+#define bfin_write_USB_EP5_FIFO(val)		bfin_write16(USB_EP5_FIFO, val)
+#define bfin_read_USB_EP6_FIFO()		bfin_read16(USB_EP6_FIFO)
+#define bfin_write_USB_EP6_FIFO(val)		bfin_write16(USB_EP6_FIFO, val)
+#define bfin_read_USB_EP7_FIFO()		bfin_read16(USB_EP7_FIFO)
+#define bfin_write_USB_EP7_FIFO(val)		bfin_write16(USB_EP7_FIFO, val)
+
+/* USB OTG Control Registers */
+
+#define bfin_read_USB_OTG_DEV_CTL()		bfin_read16(USB_OTG_DEV_CTL)
+#define bfin_write_USB_OTG_DEV_CTL(val)		bfin_write16(USB_OTG_DEV_CTL, val)
+#define bfin_read_USB_OTG_VBUS_IRQ()		bfin_read16(USB_OTG_VBUS_IRQ)
+#define bfin_write_USB_OTG_VBUS_IRQ(val)	bfin_write16(USB_OTG_VBUS_IRQ, val)
+#define bfin_read_USB_OTG_VBUS_MASK()		bfin_read16(USB_OTG_VBUS_MASK)
+#define bfin_write_USB_OTG_VBUS_MASK(val)	bfin_write16(USB_OTG_VBUS_MASK, val)
+
+/* USB Phy Control Registers */
+
+#define bfin_read_USB_LINKINFO()		bfin_read16(USB_LINKINFO)
+#define bfin_write_USB_LINKINFO(val)		bfin_write16(USB_LINKINFO, val)
+#define bfin_read_USB_VPLEN()			bfin_read16(USB_VPLEN)
+#define bfin_write_USB_VPLEN(val)		bfin_write16(USB_VPLEN, val)
+#define bfin_read_USB_HS_EOF1()			bfin_read16(USB_HS_EOF1)
+#define bfin_write_USB_HS_EOF1(val)		bfin_write16(USB_HS_EOF1, val)
+#define bfin_read_USB_FS_EOF1()			bfin_read16(USB_FS_EOF1)
+#define bfin_write_USB_FS_EOF1(val)		bfin_write16(USB_FS_EOF1, val)
+#define bfin_read_USB_LS_EOF1()			bfin_read16(USB_LS_EOF1)
+#define bfin_write_USB_LS_EOF1(val)		bfin_write16(USB_LS_EOF1, val)
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CNTRL()		bfin_read16(USB_APHY_CNTRL)
+#define bfin_write_USB_APHY_CNTRL(val)		bfin_write16(USB_APHY_CNTRL, val)
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define bfin_read_USB_APHY_CALIB()		bfin_read16(USB_APHY_CALIB)
+#define bfin_write_USB_APHY_CALIB(val)		bfin_write16(USB_APHY_CALIB, val)
+#define bfin_read_USB_APHY_CNTRL2()		bfin_read16(USB_APHY_CNTRL2)
+#define bfin_write_USB_APHY_CNTRL2(val)		bfin_write16(USB_APHY_CNTRL2, val)
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define bfin_read_USB_PHY_TEST()		bfin_read16(USB_PHY_TEST)
+#define bfin_write_USB_PHY_TEST(val)		bfin_write16(USB_PHY_TEST, val)
+#define bfin_read_USB_PLLOSC_CTRL()		bfin_read16(USB_PLLOSC_CTRL)
+#define bfin_write_USB_PLLOSC_CTRL(val)		bfin_write16(USB_PLLOSC_CTRL, val)
+#define bfin_read_USB_SRP_CLKDIV()		bfin_read16(USB_SRP_CLKDIV)
+#define bfin_write_USB_SRP_CLKDIV(val)		bfin_write16(USB_SRP_CLKDIV, val)
+
+/* USB Endbfin_read_()oint 0 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXMAXP()		bfin_read16(USB_EP_NI0_TXMAXP)
+#define bfin_write_USB_EP_NI0_TXMAXP(val)	bfin_write16(USB_EP_NI0_TXMAXP, val)
+#define bfin_read_USB_EP_NI0_TXCSR()		bfin_read16(USB_EP_NI0_TXCSR)
+#define bfin_write_USB_EP_NI0_TXCSR(val)	bfin_write16(USB_EP_NI0_TXCSR, val)
+#define bfin_read_USB_EP_NI0_RXMAXP()		bfin_read16(USB_EP_NI0_RXMAXP)
+#define bfin_write_USB_EP_NI0_RXMAXP(val)	bfin_write16(USB_EP_NI0_RXMAXP, val)
+#define bfin_read_USB_EP_NI0_RXCSR()		bfin_read16(USB_EP_NI0_RXCSR)
+#define bfin_write_USB_EP_NI0_RXCSR(val)	bfin_write16(USB_EP_NI0_RXCSR, val)
+#define bfin_read_USB_EP_NI0_RXCOUNT()		bfin_read16(USB_EP_NI0_RXCOUNT)
+#define bfin_write_USB_EP_NI0_RXCOUNT(val)	bfin_write16(USB_EP_NI0_RXCOUNT, val)
+#define bfin_read_USB_EP_NI0_TXTYPE()		bfin_read16(USB_EP_NI0_TXTYPE)
+#define bfin_write_USB_EP_NI0_TXTYPE(val)	bfin_write16(USB_EP_NI0_TXTYPE, val)
+#define bfin_read_USB_EP_NI0_TXINTERVAL()	bfin_read16(USB_EP_NI0_TXINTERVAL)
+#define bfin_write_USB_EP_NI0_TXINTERVAL(val)	bfin_write16(USB_EP_NI0_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI0_RXTYPE()		bfin_read16(USB_EP_NI0_RXTYPE)
+#define bfin_write_USB_EP_NI0_RXTYPE(val)	bfin_write16(USB_EP_NI0_RXTYPE, val)
+#define bfin_read_USB_EP_NI0_RXINTERVAL()	bfin_read16(USB_EP_NI0_RXINTERVAL)
+#define bfin_write_USB_EP_NI0_RXINTERVAL(val)	bfin_write16(USB_EP_NI0_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 1 Control Registers */
+
+#define bfin_read_USB_EP_NI0_TXCOUNT()		bfin_read16(USB_EP_NI0_TXCOUNT)
+#define bfin_write_USB_EP_NI0_TXCOUNT(val)	bfin_write16(USB_EP_NI0_TXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXMAXP()		bfin_read16(USB_EP_NI1_TXMAXP)
+#define bfin_write_USB_EP_NI1_TXMAXP(val)	bfin_write16(USB_EP_NI1_TXMAXP, val)
+#define bfin_read_USB_EP_NI1_TXCSR()		bfin_read16(USB_EP_NI1_TXCSR)
+#define bfin_write_USB_EP_NI1_TXCSR(val)	bfin_write16(USB_EP_NI1_TXCSR, val)
+#define bfin_read_USB_EP_NI1_RXMAXP()		bfin_read16(USB_EP_NI1_RXMAXP)
+#define bfin_write_USB_EP_NI1_RXMAXP(val)	bfin_write16(USB_EP_NI1_RXMAXP, val)
+#define bfin_read_USB_EP_NI1_RXCSR()		bfin_read16(USB_EP_NI1_RXCSR)
+#define bfin_write_USB_EP_NI1_RXCSR(val)	bfin_write16(USB_EP_NI1_RXCSR, val)
+#define bfin_read_USB_EP_NI1_RXCOUNT()		bfin_read16(USB_EP_NI1_RXCOUNT)
+#define bfin_write_USB_EP_NI1_RXCOUNT(val)	bfin_write16(USB_EP_NI1_RXCOUNT, val)
+#define bfin_read_USB_EP_NI1_TXTYPE()		bfin_read16(USB_EP_NI1_TXTYPE)
+#define bfin_write_USB_EP_NI1_TXTYPE(val)	bfin_write16(USB_EP_NI1_TXTYPE, val)
+#define bfin_read_USB_EP_NI1_TXINTERVAL()	bfin_read16(USB_EP_NI1_TXINTERVAL)
+#define bfin_write_USB_EP_NI1_TXINTERVAL(val)	bfin_write16(USB_EP_NI1_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI1_RXTYPE()		bfin_read16(USB_EP_NI1_RXTYPE)
+#define bfin_write_USB_EP_NI1_RXTYPE(val)	bfin_write16(USB_EP_NI1_RXTYPE, val)
+#define bfin_read_USB_EP_NI1_RXINTERVAL()	bfin_read16(USB_EP_NI1_RXINTERVAL)
+#define bfin_write_USB_EP_NI1_RXINTERVAL(val)	bfin_write16(USB_EP_NI1_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 2 Control Registers */
+
+#define bfin_read_USB_EP_NI1_TXCOUNT()		bfin_read16(USB_EP_NI1_TXCOUNT)
+#define bfin_write_USB_EP_NI1_TXCOUNT(val)	bfin_write16(USB_EP_NI1_TXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXMAXP()		bfin_read16(USB_EP_NI2_TXMAXP)
+#define bfin_write_USB_EP_NI2_TXMAXP(val)	bfin_write16(USB_EP_NI2_TXMAXP, val)
+#define bfin_read_USB_EP_NI2_TXCSR()		bfin_read16(USB_EP_NI2_TXCSR)
+#define bfin_write_USB_EP_NI2_TXCSR(val)	bfin_write16(USB_EP_NI2_TXCSR, val)
+#define bfin_read_USB_EP_NI2_RXMAXP()		bfin_read16(USB_EP_NI2_RXMAXP)
+#define bfin_write_USB_EP_NI2_RXMAXP(val)	bfin_write16(USB_EP_NI2_RXMAXP, val)
+#define bfin_read_USB_EP_NI2_RXCSR()		bfin_read16(USB_EP_NI2_RXCSR)
+#define bfin_write_USB_EP_NI2_RXCSR(val)	bfin_write16(USB_EP_NI2_RXCSR, val)
+#define bfin_read_USB_EP_NI2_RXCOUNT()		bfin_read16(USB_EP_NI2_RXCOUNT)
+#define bfin_write_USB_EP_NI2_RXCOUNT(val)	bfin_write16(USB_EP_NI2_RXCOUNT, val)
+#define bfin_read_USB_EP_NI2_TXTYPE()		bfin_read16(USB_EP_NI2_TXTYPE)
+#define bfin_write_USB_EP_NI2_TXTYPE(val)	bfin_write16(USB_EP_NI2_TXTYPE, val)
+#define bfin_read_USB_EP_NI2_TXINTERVAL()	bfin_read16(USB_EP_NI2_TXINTERVAL)
+#define bfin_write_USB_EP_NI2_TXINTERVAL(val)	bfin_write16(USB_EP_NI2_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI2_RXTYPE()		bfin_read16(USB_EP_NI2_RXTYPE)
+#define bfin_write_USB_EP_NI2_RXTYPE(val)	bfin_write16(USB_EP_NI2_RXTYPE, val)
+#define bfin_read_USB_EP_NI2_RXINTERVAL()	bfin_read16(USB_EP_NI2_RXINTERVAL)
+#define bfin_write_USB_EP_NI2_RXINTERVAL(val)	bfin_write16(USB_EP_NI2_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 3 Control Registers */
+
+#define bfin_read_USB_EP_NI2_TXCOUNT()		bfin_read16(USB_EP_NI2_TXCOUNT)
+#define bfin_write_USB_EP_NI2_TXCOUNT(val)	bfin_write16(USB_EP_NI2_TXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXMAXP()		bfin_read16(USB_EP_NI3_TXMAXP)
+#define bfin_write_USB_EP_NI3_TXMAXP(val)	bfin_write16(USB_EP_NI3_TXMAXP, val)
+#define bfin_read_USB_EP_NI3_TXCSR()		bfin_read16(USB_EP_NI3_TXCSR)
+#define bfin_write_USB_EP_NI3_TXCSR(val)	bfin_write16(USB_EP_NI3_TXCSR, val)
+#define bfin_read_USB_EP_NI3_RXMAXP()		bfin_read16(USB_EP_NI3_RXMAXP)
+#define bfin_write_USB_EP_NI3_RXMAXP(val)	bfin_write16(USB_EP_NI3_RXMAXP, val)
+#define bfin_read_USB_EP_NI3_RXCSR()		bfin_read16(USB_EP_NI3_RXCSR)
+#define bfin_write_USB_EP_NI3_RXCSR(val)	bfin_write16(USB_EP_NI3_RXCSR, val)
+#define bfin_read_USB_EP_NI3_RXCOUNT()		bfin_read16(USB_EP_NI3_RXCOUNT)
+#define bfin_write_USB_EP_NI3_RXCOUNT(val)	bfin_write16(USB_EP_NI3_RXCOUNT, val)
+#define bfin_read_USB_EP_NI3_TXTYPE()		bfin_read16(USB_EP_NI3_TXTYPE)
+#define bfin_write_USB_EP_NI3_TXTYPE(val)	bfin_write16(USB_EP_NI3_TXTYPE, val)
+#define bfin_read_USB_EP_NI3_TXINTERVAL()	bfin_read16(USB_EP_NI3_TXINTERVAL)
+#define bfin_write_USB_EP_NI3_TXINTERVAL(val)	bfin_write16(USB_EP_NI3_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI3_RXTYPE()		bfin_read16(USB_EP_NI3_RXTYPE)
+#define bfin_write_USB_EP_NI3_RXTYPE(val)	bfin_write16(USB_EP_NI3_RXTYPE, val)
+#define bfin_read_USB_EP_NI3_RXINTERVAL()	bfin_read16(USB_EP_NI3_RXINTERVAL)
+#define bfin_write_USB_EP_NI3_RXINTERVAL(val)	bfin_write16(USB_EP_NI3_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 4 Control Registers */
+
+#define bfin_read_USB_EP_NI3_TXCOUNT()		bfin_read16(USB_EP_NI3_TXCOUNT)
+#define bfin_write_USB_EP_NI3_TXCOUNT(val)	bfin_write16(USB_EP_NI3_TXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXMAXP()		bfin_read16(USB_EP_NI4_TXMAXP)
+#define bfin_write_USB_EP_NI4_TXMAXP(val)	bfin_write16(USB_EP_NI4_TXMAXP, val)
+#define bfin_read_USB_EP_NI4_TXCSR()		bfin_read16(USB_EP_NI4_TXCSR)
+#define bfin_write_USB_EP_NI4_TXCSR(val)	bfin_write16(USB_EP_NI4_TXCSR, val)
+#define bfin_read_USB_EP_NI4_RXMAXP()		bfin_read16(USB_EP_NI4_RXMAXP)
+#define bfin_write_USB_EP_NI4_RXMAXP(val)	bfin_write16(USB_EP_NI4_RXMAXP, val)
+#define bfin_read_USB_EP_NI4_RXCSR()		bfin_read16(USB_EP_NI4_RXCSR)
+#define bfin_write_USB_EP_NI4_RXCSR(val)	bfin_write16(USB_EP_NI4_RXCSR, val)
+#define bfin_read_USB_EP_NI4_RXCOUNT()		bfin_read16(USB_EP_NI4_RXCOUNT)
+#define bfin_write_USB_EP_NI4_RXCOUNT(val)	bfin_write16(USB_EP_NI4_RXCOUNT, val)
+#define bfin_read_USB_EP_NI4_TXTYPE()		bfin_read16(USB_EP_NI4_TXTYPE)
+#define bfin_write_USB_EP_NI4_TXTYPE(val)	bfin_write16(USB_EP_NI4_TXTYPE, val)
+#define bfin_read_USB_EP_NI4_TXINTERVAL()	bfin_read16(USB_EP_NI4_TXINTERVAL)
+#define bfin_write_USB_EP_NI4_TXINTERVAL(val)	bfin_write16(USB_EP_NI4_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI4_RXTYPE()		bfin_read16(USB_EP_NI4_RXTYPE)
+#define bfin_write_USB_EP_NI4_RXTYPE(val)	bfin_write16(USB_EP_NI4_RXTYPE, val)
+#define bfin_read_USB_EP_NI4_RXINTERVAL()	bfin_read16(USB_EP_NI4_RXINTERVAL)
+#define bfin_write_USB_EP_NI4_RXINTERVAL(val)	bfin_write16(USB_EP_NI4_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 5 Control Registers */
+
+#define bfin_read_USB_EP_NI4_TXCOUNT()		bfin_read16(USB_EP_NI4_TXCOUNT)
+#define bfin_write_USB_EP_NI4_TXCOUNT(val)	bfin_write16(USB_EP_NI4_TXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXMAXP()		bfin_read16(USB_EP_NI5_TXMAXP)
+#define bfin_write_USB_EP_NI5_TXMAXP(val)	bfin_write16(USB_EP_NI5_TXMAXP, val)
+#define bfin_read_USB_EP_NI5_TXCSR()		bfin_read16(USB_EP_NI5_TXCSR)
+#define bfin_write_USB_EP_NI5_TXCSR(val)	bfin_write16(USB_EP_NI5_TXCSR, val)
+#define bfin_read_USB_EP_NI5_RXMAXP()		bfin_read16(USB_EP_NI5_RXMAXP)
+#define bfin_write_USB_EP_NI5_RXMAXP(val)	bfin_write16(USB_EP_NI5_RXMAXP, val)
+#define bfin_read_USB_EP_NI5_RXCSR()		bfin_read16(USB_EP_NI5_RXCSR)
+#define bfin_write_USB_EP_NI5_RXCSR(val)	bfin_write16(USB_EP_NI5_RXCSR, val)
+#define bfin_read_USB_EP_NI5_RXCOUNT()		bfin_read16(USB_EP_NI5_RXCOUNT)
+#define bfin_write_USB_EP_NI5_RXCOUNT(val)	bfin_write16(USB_EP_NI5_RXCOUNT, val)
+#define bfin_read_USB_EP_NI5_TXTYPE()		bfin_read16(USB_EP_NI5_TXTYPE)
+#define bfin_write_USB_EP_NI5_TXTYPE(val)	bfin_write16(USB_EP_NI5_TXTYPE, val)
+#define bfin_read_USB_EP_NI5_TXINTERVAL()	bfin_read16(USB_EP_NI5_TXINTERVAL)
+#define bfin_write_USB_EP_NI5_TXINTERVAL(val)	bfin_write16(USB_EP_NI5_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI5_RXTYPE()		bfin_read16(USB_EP_NI5_RXTYPE)
+#define bfin_write_USB_EP_NI5_RXTYPE(val)	bfin_write16(USB_EP_NI5_RXTYPE, val)
+#define bfin_read_USB_EP_NI5_RXINTERVAL()	bfin_read16(USB_EP_NI5_RXINTERVAL)
+#define bfin_write_USB_EP_NI5_RXINTERVAL(val)	bfin_write16(USB_EP_NI5_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 6 Control Registers */
+
+#define bfin_read_USB_EP_NI5_TXCOUNT()		bfin_read16(USB_EP_NI5_TXCOUNT)
+#define bfin_write_USB_EP_NI5_TXCOUNT(val)	bfin_write16(USB_EP_NI5_TXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXMAXP()		bfin_read16(USB_EP_NI6_TXMAXP)
+#define bfin_write_USB_EP_NI6_TXMAXP(val)	bfin_write16(USB_EP_NI6_TXMAXP, val)
+#define bfin_read_USB_EP_NI6_TXCSR()		bfin_read16(USB_EP_NI6_TXCSR)
+#define bfin_write_USB_EP_NI6_TXCSR(val)	bfin_write16(USB_EP_NI6_TXCSR, val)
+#define bfin_read_USB_EP_NI6_RXMAXP()		bfin_read16(USB_EP_NI6_RXMAXP)
+#define bfin_write_USB_EP_NI6_RXMAXP(val)	bfin_write16(USB_EP_NI6_RXMAXP, val)
+#define bfin_read_USB_EP_NI6_RXCSR()		bfin_read16(USB_EP_NI6_RXCSR)
+#define bfin_write_USB_EP_NI6_RXCSR(val)	bfin_write16(USB_EP_NI6_RXCSR, val)
+#define bfin_read_USB_EP_NI6_RXCOUNT()		bfin_read16(USB_EP_NI6_RXCOUNT)
+#define bfin_write_USB_EP_NI6_RXCOUNT(val)	bfin_write16(USB_EP_NI6_RXCOUNT, val)
+#define bfin_read_USB_EP_NI6_TXTYPE()		bfin_read16(USB_EP_NI6_TXTYPE)
+#define bfin_write_USB_EP_NI6_TXTYPE(val)	bfin_write16(USB_EP_NI6_TXTYPE, val)
+#define bfin_read_USB_EP_NI6_TXINTERVAL()	bfin_read16(USB_EP_NI6_TXINTERVAL)
+#define bfin_write_USB_EP_NI6_TXINTERVAL(val)	bfin_write16(USB_EP_NI6_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI6_RXTYPE()		bfin_read16(USB_EP_NI6_RXTYPE)
+#define bfin_write_USB_EP_NI6_RXTYPE(val)	bfin_write16(USB_EP_NI6_RXTYPE, val)
+#define bfin_read_USB_EP_NI6_RXINTERVAL()	bfin_read16(USB_EP_NI6_RXINTERVAL)
+#define bfin_write_USB_EP_NI6_RXINTERVAL(val)	bfin_write16(USB_EP_NI6_RXINTERVAL, val)
+
+/* USB Endbfin_read_()oint 7 Control Registers */
+
+#define bfin_read_USB_EP_NI6_TXCOUNT()		bfin_read16(USB_EP_NI6_TXCOUNT)
+#define bfin_write_USB_EP_NI6_TXCOUNT(val)	bfin_write16(USB_EP_NI6_TXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXMAXP()		bfin_read16(USB_EP_NI7_TXMAXP)
+#define bfin_write_USB_EP_NI7_TXMAXP(val)	bfin_write16(USB_EP_NI7_TXMAXP, val)
+#define bfin_read_USB_EP_NI7_TXCSR()		bfin_read16(USB_EP_NI7_TXCSR)
+#define bfin_write_USB_EP_NI7_TXCSR(val)	bfin_write16(USB_EP_NI7_TXCSR, val)
+#define bfin_read_USB_EP_NI7_RXMAXP()		bfin_read16(USB_EP_NI7_RXMAXP)
+#define bfin_write_USB_EP_NI7_RXMAXP(val)	bfin_write16(USB_EP_NI7_RXMAXP, val)
+#define bfin_read_USB_EP_NI7_RXCSR()		bfin_read16(USB_EP_NI7_RXCSR)
+#define bfin_write_USB_EP_NI7_RXCSR(val)	bfin_write16(USB_EP_NI7_RXCSR, val)
+#define bfin_read_USB_EP_NI7_RXCOUNT()		bfin_read16(USB_EP_NI7_RXCOUNT)
+#define bfin_write_USB_EP_NI7_RXCOUNT(val)	bfin_write16(USB_EP_NI7_RXCOUNT, val)
+#define bfin_read_USB_EP_NI7_TXTYPE()		bfin_read16(USB_EP_NI7_TXTYPE)
+#define bfin_write_USB_EP_NI7_TXTYPE(val)	bfin_write16(USB_EP_NI7_TXTYPE, val)
+#define bfin_read_USB_EP_NI7_TXINTERVAL()	bfin_read16(USB_EP_NI7_TXINTERVAL)
+#define bfin_write_USB_EP_NI7_TXINTERVAL(val)	bfin_write16(USB_EP_NI7_TXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_RXTYPE()		bfin_read16(USB_EP_NI7_RXTYPE)
+#define bfin_write_USB_EP_NI7_RXTYPE(val)	bfin_write16(USB_EP_NI7_RXTYPE, val)
+#define bfin_read_USB_EP_NI7_RXINTERVAL()	bfin_read16(USB_EP_NI7_RXINTERVAL)
+#define bfin_write_USB_EP_NI7_RXINTERVAL(val)	bfin_write16(USB_EP_NI7_RXINTERVAL, val)
+#define bfin_read_USB_EP_NI7_TXCOUNT()		bfin_read16(USB_EP_NI7_TXCOUNT)
+#define bfin_write_USB_EP_NI7_TXCOUNT(val)	bfin_write16(USB_EP_NI7_TXCOUNT, val)
+#define bfin_read_USB_DMA_INTERRUPT()		bfin_read16(USB_DMA_INTERRUPT)
+#define bfin_write_USB_DMA_INTERRUPT(val)	bfin_write16(USB_DMA_INTERRUPT, val)
+
+/* USB Channel 0 Config Registers */
+
+#define bfin_read_USB_DMA0CONTROL()		bfin_read16(USB_DMA0CONTROL)
+#define bfin_write_USB_DMA0CONTROL(val)		bfin_write16(USB_DMA0CONTROL, val)
+#define bfin_read_USB_DMA0ADDRLOW()		bfin_read16(USB_DMA0ADDRLOW)
+#define bfin_write_USB_DMA0ADDRLOW(val)		bfin_write16(USB_DMA0ADDRLOW, val)
+#define bfin_read_USB_DMA0ADDRHIGH()		bfin_read16(USB_DMA0ADDRHIGH)
+#define bfin_write_USB_DMA0ADDRHIGH(val)	bfin_write16(USB_DMA0ADDRHIGH, val)
+#define bfin_read_USB_DMA0COUNTLOW()		bfin_read16(USB_DMA0COUNTLOW)
+#define bfin_write_USB_DMA0COUNTLOW(val)	bfin_write16(USB_DMA0COUNTLOW, val)
+#define bfin_read_USB_DMA0COUNTHIGH()		bfin_read16(USB_DMA0COUNTHIGH)
+#define bfin_write_USB_DMA0COUNTHIGH(val)	bfin_write16(USB_DMA0COUNTHIGH, val)
+
+/* USB Channel 1 Config Registers */
+
+#define bfin_read_USB_DMA1CONTROL()		bfin_read16(USB_DMA1CONTROL)
+#define bfin_write_USB_DMA1CONTROL(val)		bfin_write16(USB_DMA1CONTROL, val)
+#define bfin_read_USB_DMA1ADDRLOW()		bfin_read16(USB_DMA1ADDRLOW)
+#define bfin_write_USB_DMA1ADDRLOW(val)		bfin_write16(USB_DMA1ADDRLOW, val)
+#define bfin_read_USB_DMA1ADDRHIGH()		bfin_read16(USB_DMA1ADDRHIGH)
+#define bfin_write_USB_DMA1ADDRHIGH(val)	bfin_write16(USB_DMA1ADDRHIGH, val)
+#define bfin_read_USB_DMA1COUNTLOW()		bfin_read16(USB_DMA1COUNTLOW)
+#define bfin_write_USB_DMA1COUNTLOW(val)	bfin_write16(USB_DMA1COUNTLOW, val)
+#define bfin_read_USB_DMA1COUNTHIGH()		bfin_read16(USB_DMA1COUNTHIGH)
+#define bfin_write_USB_DMA1COUNTHIGH(val)	bfin_write16(USB_DMA1COUNTHIGH, val)
+
+/* USB Channel 2 Config Registers */
+
+#define bfin_read_USB_DMA2CONTROL()		bfin_read16(USB_DMA2CONTROL)
+#define bfin_write_USB_DMA2CONTROL(val)		bfin_write16(USB_DMA2CONTROL, val)
+#define bfin_read_USB_DMA2ADDRLOW()		bfin_read16(USB_DMA2ADDRLOW)
+#define bfin_write_USB_DMA2ADDRLOW(val)		bfin_write16(USB_DMA2ADDRLOW, val)
+#define bfin_read_USB_DMA2ADDRHIGH()		bfin_read16(USB_DMA2ADDRHIGH)
+#define bfin_write_USB_DMA2ADDRHIGH(val)	bfin_write16(USB_DMA2ADDRHIGH, val)
+#define bfin_read_USB_DMA2COUNTLOW()		bfin_read16(USB_DMA2COUNTLOW)
+#define bfin_write_USB_DMA2COUNTLOW(val)	bfin_write16(USB_DMA2COUNTLOW, val)
+#define bfin_read_USB_DMA2COUNTHIGH()		bfin_read16(USB_DMA2COUNTHIGH)
+#define bfin_write_USB_DMA2COUNTHIGH(val)	bfin_write16(USB_DMA2COUNTHIGH, val)
+
+/* USB Channel 3 Config Registers */
+
+#define bfin_read_USB_DMA3CONTROL()		bfin_read16(USB_DMA3CONTROL)
+#define bfin_write_USB_DMA3CONTROL(val)		bfin_write16(USB_DMA3CONTROL, val)
+#define bfin_read_USB_DMA3ADDRLOW()		bfin_read16(USB_DMA3ADDRLOW)
+#define bfin_write_USB_DMA3ADDRLOW(val)		bfin_write16(USB_DMA3ADDRLOW, val)
+#define bfin_read_USB_DMA3ADDRHIGH()		bfin_read16(USB_DMA3ADDRHIGH)
+#define bfin_write_USB_DMA3ADDRHIGH(val)	bfin_write16(USB_DMA3ADDRHIGH, val)
+#define bfin_read_USB_DMA3COUNTLOW()		bfin_read16(USB_DMA3COUNTLOW)
+#define bfin_write_USB_DMA3COUNTLOW(val)	bfin_write16(USB_DMA3COUNTLOW, val)
+#define bfin_read_USB_DMA3COUNTHIGH()		bfin_read16(USB_DMA3COUNTHIGH)
+#define bfin_write_USB_DMA3COUNTHIGH(val)	bfin_write16(USB_DMA3COUNTHIGH, val)
+
+/* USB Channel 4 Config Registers */
+
+#define bfin_read_USB_DMA4CONTROL()		bfin_read16(USB_DMA4CONTROL)
+#define bfin_write_USB_DMA4CONTROL(val)		bfin_write16(USB_DMA4CONTROL, val)
+#define bfin_read_USB_DMA4ADDRLOW()		bfin_read16(USB_DMA4ADDRLOW)
+#define bfin_write_USB_DMA4ADDRLOW(val)		bfin_write16(USB_DMA4ADDRLOW, val)
+#define bfin_read_USB_DMA4ADDRHIGH()		bfin_read16(USB_DMA4ADDRHIGH)
+#define bfin_write_USB_DMA4ADDRHIGH(val)	bfin_write16(USB_DMA4ADDRHIGH, val)
+#define bfin_read_USB_DMA4COUNTLOW()		bfin_read16(USB_DMA4COUNTLOW)
+#define bfin_write_USB_DMA4COUNTLOW(val)	bfin_write16(USB_DMA4COUNTLOW, val)
+#define bfin_read_USB_DMA4COUNTHIGH()		bfin_read16(USB_DMA4COUNTHIGH)
+#define bfin_write_USB_DMA4COUNTHIGH(val)	bfin_write16(USB_DMA4COUNTHIGH, val)
+
+/* USB Channel 5 Config Registers */
+
+#define bfin_read_USB_DMA5CONTROL()		bfin_read16(USB_DMA5CONTROL)
+#define bfin_write_USB_DMA5CONTROL(val)		bfin_write16(USB_DMA5CONTROL, val)
+#define bfin_read_USB_DMA5ADDRLOW()		bfin_read16(USB_DMA5ADDRLOW)
+#define bfin_write_USB_DMA5ADDRLOW(val)		bfin_write16(USB_DMA5ADDRLOW, val)
+#define bfin_read_USB_DMA5ADDRHIGH()		bfin_read16(USB_DMA5ADDRHIGH)
+#define bfin_write_USB_DMA5ADDRHIGH(val)		bfin_write16(USB_DMA5ADDRHIGH, val)
+#define bfin_read_USB_DMA5COUNTLOW()		bfin_read16(USB_DMA5COUNTLOW)
+#define bfin_write_USB_DMA5COUNTLOW(val)	fin_write16(USB_DMA5COUNTLOW, val)
+#define bfin_read_USB_DMA5COUNTHIGH()		bfin_read16(USB_DMA5COUNTHIGH)
+#define bfin_write_USB_DMA5COUNTHIGH(val)	bfin_write16(USB_DMA5COUNTHIGH, val)
+
+/* USB Channel 6 Config Registers */
+
+#define bfin_read_USB_DMA6CONTROL()		bfin_read16(USB_DMA6CONTROL)
+#define bfin_write_USB_DMA6CONTROL(val)		bfin_write16(USB_DMA6CONTROL, val)
+#define bfin_read_USB_DMA6ADDRLOW()		bfin_read16(USB_DMA6ADDRLOW)
+#define bfin_write_USB_DMA6ADDRLOW(val)		bfin_write16(USB_DMA6ADDRLOW, val)
+#define bfin_read_USB_DMA6ADDRHIGH()		bfin_read16(USB_DMA6ADDRHIGH)
+#define bfin_write_USB_DMA6ADDRHIGH(val)	bfin_write16(USB_DMA6ADDRHIGH, val)
+#define bfin_read_USB_DMA6COUNTLOW()		bfin_read16(USB_DMA6COUNTLOW)
+#define bfin_write_USB_DMA6COUNTLOW(val)	bfin_write16(USB_DMA6COUNTLOW, val)
+#define bfin_read_USB_DMA6COUNTHIGH()		bfin_read16(USB_DMA6COUNTHIGH)
+#define bfin_write_USB_DMA6COUNTHIGH(val)	bfin_write16(USB_DMA6COUNTHIGH, val)
+
+/* USB Channel 7 Config Registers */
+
+#define bfin_read_USB_DMA7CONTROL()		bfin_read16(USB_DMA7CONTROL)
+#define bfin_write_USB_DMA7CONTROL(val)		bfin_write16(USB_DMA7CONTROL, val)
+#define bfin_read_USB_DMA7ADDRLOW()		bfin_read16(USB_DMA7ADDRLOW)
+#define bfin_write_USB_DMA7ADDRLOW(val)		bfin_write16(USB_DMA7ADDRLOW, val)
+#define bfin_read_USB_DMA7ADDRHIGH()		bfin_read16(USB_DMA7ADDRHIGH)
+#define bfin_write_USB_DMA7ADDRHIGH(val)	bfin_write16(USB_DMA7ADDRHIGH, val)
+#define bfin_read_USB_DMA7COUNTLOW()		bfin_read16(USB_DMA7COUNTLOW)
+#define bfin_write_USB_DMA7COUNTLOW(val)	bfin_write16(USB_DMA7COUNTLOW, val)
+#define bfin_read_USB_DMA7COUNTHIGH()		bfin_read16(USB_DMA7COUNTHIGH)
+#define bfin_write_USB_DMA7COUNTHIGH(val)	bfin_write16(USB_DMA7COUNTHIGH, val)
+
+/* Keybfin_read_()ad Registers */
+
+#define bfin_read_KPAD_CTL()		bfin_read16(KPAD_CTL)
+#define bfin_write_KPAD_CTL(val)	bfin_write16(KPAD_CTL, val)
+#define bfin_read_KPAD_PRESCALE()	bfin_read16(KPAD_PRESCALE)
+#define bfin_write_KPAD_PRESCALE(val)	bfin_write16(KPAD_PRESCALE, val)
+#define bfin_read_KPAD_MSEL()		bfin_read16(KPAD_MSEL)
+#define bfin_write_KPAD_MSEL(val)	bfin_write16(KPAD_MSEL, val)
+#define bfin_read_KPAD_ROWCOL()		bfin_read16(KPAD_ROWCOL)
+#define bfin_write_KPAD_ROWCOL(val)	bfin_write16(KPAD_ROWCOL, val)
+#define bfin_read_KPAD_STAT()		bfin_read16(KPAD_STAT)
+#define bfin_write_KPAD_STAT(val)	bfin_write16(KPAD_STAT, val)
+#define bfin_read_KPAD_SOFTEVAL()	bfin_read16(KPAD_SOFTEVAL)
+#define bfin_write_KPAD_SOFTEVAL(val)	bfin_write16(KPAD_SOFTEVAL, val)
+
+/* Pixel Combfin_read_()ositor (PIXC) Registers */
+
+#define bfin_read_PIXC_CTL()		bfin_read16(PIXC_CTL)
+#define bfin_write_PIXC_CTL(val)	bfin_write16(PIXC_CTL, val)
+#define bfin_read_PIXC_PPL()		bfin_read16(PIXC_PPL)
+#define bfin_write_PIXC_PPL(val)	bfin_write16(PIXC_PPL, val)
+#define bfin_read_PIXC_LPF()		bfin_read16(PIXC_LPF)
+#define bfin_write_PIXC_LPF(val)	bfin_write16(PIXC_LPF, val)
+#define bfin_read_PIXC_AHSTART()	bfin_read16(PIXC_AHSTART)
+#define bfin_write_PIXC_AHSTART(val)	bfin_write16(PIXC_AHSTART, val)
+#define bfin_read_PIXC_AHEND()		bfin_read16(PIXC_AHEND)
+#define bfin_write_PIXC_AHEND(val)	bfin_write16(PIXC_AHEND, val)
+#define bfin_read_PIXC_AVSTART()	bfin_read16(PIXC_AVSTART)
+#define bfin_write_PIXC_AVSTART(val)	bfin_write16(PIXC_AVSTART, val)
+#define bfin_read_PIXC_AVEND()		bfin_read16(PIXC_AVEND)
+#define bfin_write_PIXC_AVEND(val)	bfin_write16(PIXC_AVEND, val)
+#define bfin_read_PIXC_ATRANSP()	bfin_read16(PIXC_ATRANSP)
+#define bfin_write_PIXC_ATRANSP(val)	bfin_write16(PIXC_ATRANSP, val)
+#define bfin_read_PIXC_BHSTART()	bfin_read16(PIXC_BHSTART)
+#define bfin_write_PIXC_BHSTART(val)	bfin_write16(PIXC_BHSTART, val)
+#define bfin_read_PIXC_BHEND()		bfin_read16(PIXC_BHEND)
+#define bfin_write_PIXC_BHEND(val)	bfin_write16(PIXC_BHEND, val)
+#define bfin_read_PIXC_BVSTART()	bfin_read16(PIXC_BVSTART)
+#define bfin_write_PIXC_BVSTART(val)	bfin_write16(PIXC_BVSTART, val)
+#define bfin_read_PIXC_BVEND()		bfin_read16(PIXC_BVEND)
+#define bfin_write_PIXC_BVEND(val)	bfin_write16(PIXC_BVEND, val)
+#define bfin_read_PIXC_BTRANSP()	bfin_read16(PIXC_BTRANSP)
+#define bfin_write_PIXC_BTRANSP(val)	bfin_write16(PIXC_BTRANSP, val)
+#define bfin_read_PIXC_INTRSTAT()	bfin_read16(PIXC_INTRSTAT)
+#define bfin_write_PIXC_INTRSTAT(val)	bfin_write16(PIXC_INTRSTAT, val)
+#define bfin_read_PIXC_RYCON()		bfin_read32(PIXC_RYCON)
+#define bfin_write_PIXC_RYCON(val)	bfin_write32(PIXC_RYCON, val)
+#define bfin_read_PIXC_GUCON()		bfin_read32(PIXC_GUCON)
+#define bfin_write_PIXC_GUCON(val)	bfin_write32(PIXC_GUCON, val)
+#define bfin_read_PIXC_BVCON()		bfin_read32(PIXC_BVCON)
+#define bfin_write_PIXC_BVCON(val)	bfin_write32(PIXC_BVCON, val)
+#define bfin_read_PIXC_CCBIAS()		bfin_read32(PIXC_CCBIAS)
+#define bfin_write_PIXC_CCBIAS(val)	bfin_write32(PIXC_CCBIAS, val)
+#define bfin_read_PIXC_TC()		bfin_read32(PIXC_TC)
+#define bfin_write_PIXC_TC(val)		bfin_write32(PIXC_TC, val)
+
+/* Handshake MDMA 0 Registers */
+
+#define bfin_read_HMDMA0_CONTROL()		bfin_read16(HMDMA0_CONTROL)
+#define bfin_write_HMDMA0_CONTROL(val)		bfin_write16(HMDMA0_CONTROL, val)
+#define bfin_read_HMDMA0_ECINIT()		bfin_read16(HMDMA0_ECINIT)
+#define bfin_write_HMDMA0_ECINIT(val)		bfin_write16(HMDMA0_ECINIT, val)
+#define bfin_read_HMDMA0_BCINIT()		bfin_read16(HMDMA0_BCINIT)
+#define bfin_write_HMDMA0_BCINIT(val)		bfin_write16(HMDMA0_BCINIT, val)
+#define bfin_read_HMDMA0_ECURGENT()		bfin_read16(HMDMA0_ECURGENT)
+#define bfin_write_HMDMA0_ECURGENT(val)		bfin_write16(HMDMA0_ECURGENT, val)
+#define bfin_read_HMDMA0_ECOVERFLOW()		bfin_read16(HMDMA0_ECOVERFLOW)
+#define bfin_write_HMDMA0_ECOVERFLOW(val)	bfin_write16(HMDMA0_ECOVERFLOW, val)
+#define bfin_read_HMDMA0_ECOUNT()		bfin_read16(HMDMA0_ECOUNT)
+#define bfin_write_HMDMA0_ECOUNT(val)		bfin_write16(HMDMA0_ECOUNT, val)
+#define bfin_read_HMDMA0_BCOUNT()		bfin_read16(HMDMA0_BCOUNT)
+#define bfin_write_HMDMA0_BCOUNT(val)		bfin_write16(HMDMA0_BCOUNT, val)
+
+/* Handshake MDMA 1 Registers */
+
+#define bfin_read_HMDMA1_CONTROL()		bfin_read16(HMDMA1_CONTROL)
+#define bfin_write_HMDMA1_CONTROL(val)		bfin_write16(HMDMA1_CONTROL, val)
+#define bfin_read_HMDMA1_ECINIT()		bfin_read16(HMDMA1_ECINIT)
+#define bfin_write_HMDMA1_ECINIT(val)		bfin_write16(HMDMA1_ECINIT, val)
+#define bfin_read_HMDMA1_BCINIT()		bfin_read16(HMDMA1_BCINIT)
+#define bfin_write_HMDMA1_BCINIT(val)		bfin_write16(HMDMA1_BCINIT, val)
+#define bfin_read_HMDMA1_ECURGENT()		bfin_read16(HMDMA1_ECURGENT)
+#define bfin_write_HMDMA1_ECURGENT(val)		bfin_write16(HMDMA1_ECURGENT, val)
+#define bfin_read_HMDMA1_ECOVERFLOW()		bfin_read16(HMDMA1_ECOVERFLOW)
+#define bfin_write_HMDMA1_ECOVERFLOW(val)	bfin_write16(HMDMA1_ECOVERFLOW, val)
+#define bfin_read_HMDMA1_ECOUNT()		bfin_read16(HMDMA1_ECOUNT)
+#define bfin_write_HMDMA1_ECOUNT(val)		bfin_write16(HMDMA1_ECOUNT, val)
+#define bfin_read_HMDMA1_BCOUNT()		bfin_read16(HMDMA1_BCOUNT)
+#define bfin_write_HMDMA1_BCOUNT(val)		bfin_write16(HMDMA1_BCOUNT, val)
+
+#endif /* _CDEF_BF549_H */
diff --git a/include/asm-blackfin/mach-bf548/cdefBF54x_base.h b/include/asm-blackfin/mach-bf548/cdefBF54x_base.h
new file mode 100644
index 0000000..6bbcefe
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/cdefBF54x_base.h
@@ -0,0 +1,2722 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/cdefBF54x_base.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CDEF_BF54X_H
+#define _CDEF_BF54X_H
+
+#include <defBF54x_base.h>
+
+/* ************************************************************** */
+/* SYSTEM & MMR ADDRESS DEFINITIONS COMMON TO ALL ADSP-BF54x    */
+/* ************************************************************** */
+
+/* PLL Registers */
+
+#define bfin_read_PLL_CTL()		bfin_read16(PLL_CTL)
+#define bfin_write_PLL_CTL(val)		bfin_write16(PLL_CTL, val)
+#define bfin_read_PLL_DIV()		bfin_read16(PLL_DIV)
+#define bfin_write_PLL_DIV(val)		bfin_write16(PLL_DIV, val)
+#define bfin_read_VR_CTL()		bfin_read16(VR_CTL)
+#define bfin_write_VR_CTL(val)		bfin_write16(VR_CTL, val)
+#define bfin_read_PLL_STAT()		bfin_read16(PLL_STAT)
+#define bfin_write_PLL_STAT(val)	bfin_write16(PLL_STAT, val)
+#define bfin_read_PLL_LOCKCNT()		bfin_read16(PLL_LOCKCNT)
+#define bfin_write_PLL_LOCKCNT(val)	bfin_write16(PLL_LOCKCNT, val)
+
+/* Debug/MP/Emulation Registers (0xFFC00014 - 0xFFC00014) */
+
+#define bfin_read_CHIPID()		bfin_read32(CHIPID)
+#define bfin_write_CHIPID(val)		bfin_write32(CHIPID, val)
+
+/* System Reset and Interrubfin_read_()t Controller (0xFFC00100 - 0xFFC00104) */
+
+#define bfin_read_SWRST()		bfin_read16(SWRST)
+#define bfin_write_SWRST(val)		bfin_write16(SWRST, val)
+#define bfin_read_SYSCR()		bfin_read16(SYSCR)
+#define bfin_write_SYSCR(val)		bfin_write16(SYSCR, val)
+
+/* SIC Registers */
+
+#define bfin_read_SIC_IMASK0()		bfin_read32(SIC_IMASK0)
+#define bfin_write_SIC_IMASK0(val)	bfin_write32(SIC_IMASK0, val)
+#define bfin_read_SIC_IMASK1()		bfin_read32(SIC_IMASK1)
+#define bfin_write_SIC_IMASK1(val)	bfin_write32(SIC_IMASK1, val)
+#define bfin_read_SIC_IMASK2()		bfin_read32(SIC_IMASK2)
+#define bfin_write_SIC_IMASK2(val)	bfin_write32(SIC_IMASK2, val)
+#define bfin_read_SIC_ISR0()		bfin_read32(SIC_ISR0)
+#define bfin_write_SIC_ISR0(val)	bfin_write32(SIC_ISR0, val)
+#define bfin_read_SIC_ISR1()		bfin_read32(SIC_ISR1)
+#define bfin_write_SIC_ISR1(val)	bfin_write32(SIC_ISR1, val)
+#define bfin_read_SIC_ISR2()		bfin_read32(SIC_ISR2)
+#define bfin_write_SIC_ISR2(val)	bfin_write32(SIC_ISR2, val)
+#define bfin_read_SIC_IWR0()		bfin_read32(SIC_IWR0)
+#define bfin_write_SIC_IWR0(val)	bfin_write32(SIC_IWR0, val)
+#define bfin_read_SIC_IWR1()		bfin_read32(SIC_IWR1)
+#define bfin_write_SIC_IWR1(val)	bfin_write32(SIC_IWR1, val)
+#define bfin_read_SIC_IWR2()		bfin_read32(SIC_IWR2)
+#define bfin_write_SIC_IWR2(val)	bfin_write32(SIC_IWR2, val)
+#define bfin_read_SIC_IAR0()		bfin_read32(SIC_IAR0)
+#define bfin_write_SIC_IAR0(val)	bfin_write32(SIC_IAR0, val)
+#define bfin_read_SIC_IAR1()		bfin_read32(SIC_IAR1)
+#define bfin_write_SIC_IAR1(val)	bfin_write32(SIC_IAR1, val)
+#define bfin_read_SIC_IAR2()		bfin_read32(SIC_IAR2)
+#define bfin_write_SIC_IAR2(val)	bfin_write32(SIC_IAR2, val)
+#define bfin_read_SIC_IAR3()		bfin_read32(SIC_IAR3)
+#define bfin_write_SIC_IAR3(val)	bfin_write32(SIC_IAR3, val)
+#define bfin_read_SIC_IAR4()		bfin_read32(SIC_IAR4)
+#define bfin_write_SIC_IAR4(val)	bfin_write32(SIC_IAR4, val)
+#define bfin_read_SIC_IAR5()		bfin_read32(SIC_IAR5)
+#define bfin_write_SIC_IAR5(val)	bfin_write32(SIC_IAR5, val)
+#define bfin_read_SIC_IAR6()		bfin_read32(SIC_IAR6)
+#define bfin_write_SIC_IAR6(val)	bfin_write32(SIC_IAR6, val)
+#define bfin_read_SIC_IAR7()		bfin_read32(SIC_IAR7)
+#define bfin_write_SIC_IAR7(val)	bfin_write32(SIC_IAR7, val)
+#define bfin_read_SIC_IAR8()		bfin_read32(SIC_IAR8)
+#define bfin_write_SIC_IAR8(val)	bfin_write32(SIC_IAR8, val)
+#define bfin_read_SIC_IAR9()		bfin_read32(SIC_IAR9)
+#define bfin_write_SIC_IAR9(val)	bfin_write32(SIC_IAR9, val)
+#define bfin_read_SIC_IAR10()		bfin_read32(SIC_IAR10)
+#define bfin_write_SIC_IAR10(val)	bfin_write32(SIC_IAR10, val)
+#define bfin_read_SIC_IAR11()		bfin_read32(SIC_IAR11)
+#define bfin_write_SIC_IAR11(val)	bfin_write32(SIC_IAR11, val)
+
+/* Watchdog Timer Registers */
+
+#define bfin_read_WDOG_CTL()		bfin_read16(WDOG_CTL)
+#define bfin_write_WDOG_CTL(val)	bfin_write16(WDOG_CTL, val)
+#define bfin_read_WDOG_CNT()		bfin_read32(WDOG_CNT)
+#define bfin_write_WDOG_CNT(val)	bfin_write32(WDOG_CNT, val)
+#define bfin_read_WDOG_STAT()		bfin_read32(WDOG_STAT)
+#define bfin_write_WDOG_STAT(val)	bfin_write32(WDOG_STAT, val)
+
+/* RTC Registers */
+
+#define bfin_read_RTC_STAT()		bfin_read32(RTC_STAT)
+#define bfin_write_RTC_STAT(val)	bfin_write32(RTC_STAT, val)
+#define bfin_read_RTC_ICTL()		bfin_read16(RTC_ICTL)
+#define bfin_write_RTC_ICTL(val)	bfin_write16(RTC_ICTL, val)
+#define bfin_read_RTC_ISTAT()		bfin_read16(RTC_ISTAT)
+#define bfin_write_RTC_ISTAT(val)	bfin_write16(RTC_ISTAT, val)
+#define bfin_read_RTC_SWCNT()		bfin_read16(RTC_SWCNT)
+#define bfin_write_RTC_SWCNT(val)	bfin_write16(RTC_SWCNT, val)
+#define bfin_read_RTC_ALARM()		bfin_read32(RTC_ALARM)
+#define bfin_write_RTC_ALARM(val)	bfin_write32(RTC_ALARM, val)
+#define bfin_read_RTC_PREN()		bfin_read16(RTC_PREN)
+#define bfin_write_RTC_PREN(val)	bfin_write16(RTC_PREN, val)
+
+/* UART0 Registers */
+
+#define bfin_read_UART0_DLL()		bfin_read16(UART0_DLL)
+#define bfin_write_UART0_DLL(val)	bfin_write16(UART0_DLL, val)
+#define bfin_read_UART0_DLH()		bfin_read16(UART0_DLH)
+#define bfin_write_UART0_DLH(val)	bfin_write16(UART0_DLH, val)
+#define bfin_read_UART0_GCTL()		bfin_read16(UART0_GCTL)
+#define bfin_write_UART0_GCTL(val)	bfin_write16(UART0_GCTL, val)
+#define bfin_read_UART0_LCR()		bfin_read16(UART0_LCR)
+#define bfin_write_UART0_LCR(val)	bfin_write16(UART0_LCR, val)
+#define bfin_read_UART0_MCR()		bfin_read16(UART0_MCR)
+#define bfin_write_UART0_MCR(val)	bfin_write16(UART0_MCR, val)
+#define bfin_read_UART0_LSR()		bfin_read16(UART0_LSR)
+#define bfin_write_UART0_LSR(val)	bfin_write16(UART0_LSR, val)
+#define bfin_read_UART0_MSR()		bfin_read16(UART0_MSR)
+#define bfin_write_UART0_MSR(val)	bfin_write16(UART0_MSR, val)
+#define bfin_read_UART0_SCR()		bfin_read16(UART0_SCR)
+#define bfin_write_UART0_SCR(val)	bfin_write16(UART0_SCR, val)
+#define bfin_read_UART0_IER_SET()	bfin_read16(UART0_IER_SET)
+#define bfin_write_UART0_IER_SET(val)	bfin_write16(UART0_IER_SET, val)
+#define bfin_read_UART0_IER_CLEAR()	bfin_read16(UART0_IER_CLEAR)
+#define bfin_write_UART0_IER_CLEAR(val)	bfin_write16(UART0_IER_CLEAR, val)
+#define bfin_read_UART0_THR()		bfin_read16(UART0_THR)
+#define bfin_write_UART0_THR(val)	bfin_write16(UART0_THR, val)
+#define bfin_read_UART0_RBR()		bfin_read16(UART0_RBR)
+#define bfin_write_UART0_RBR(val)	bfin_write16(UART0_RBR, val)
+
+/* SPI0 Registers */
+
+#define bfin_read_SPI0_CTL()		bfin_read16(SPI0_CTL)
+#define bfin_write_SPI0_CTL(val)	bfin_write16(SPI0_CTL, val)
+#define bfin_read_SPI0_FLG()		bfin_read16(SPI0_FLG)
+#define bfin_write_SPI0_FLG(val)	bfin_write16(SPI0_FLG, val)
+#define bfin_read_SPI0_STAT()		bfin_read16(SPI0_STAT)
+#define bfin_write_SPI0_STAT(val)	bfin_write16(SPI0_STAT, val)
+#define bfin_read_SPI0_TDBR()		bfin_read16(SPI0_TDBR)
+#define bfin_write_SPI0_TDBR(val)	bfin_write16(SPI0_TDBR, val)
+#define bfin_read_SPI0_RDBR()		bfin_read16(SPI0_RDBR)
+#define bfin_write_SPI0_RDBR(val)	bfin_write16(SPI0_RDBR, val)
+#define bfin_read_SPI0_BAUD()		bfin_read16(SPI0_BAUD)
+#define bfin_write_SPI0_BAUD(val)	bfin_write16(SPI0_BAUD, val)
+#define bfin_read_SPI0_SHADOW()		bfin_read16(SPI0_SHADOW)
+#define bfin_write_SPI0_SHADOW(val)	bfin_write16(SPI0_SHADOW, val)
+
+/* Timer Groubfin_read_() of 3 registers are not defined in the shared file because they are not available on the ADSP-BF542 processor */
+
+/* Two Wire Interface Registers (TWI0) */
+
+#define bfin_read_TWI0_CLKDIV()			bfin_read16(TWI0_CLKDIV)
+#define bfin_write_TWI0_CLKDIV(val)		bfin_write16(TWI0_CLKDIV, val)
+#define bfin_read_TWI0_CONTROL()		bfin_read16(TWI0_CONTROL)
+#define bfin_write_TWI0_CONTROL(val)		bfin_write16(TWI0_CONTROL, val)
+#define bfin_read_TWI0_SLAVE_CTRL()		bfin_read16(TWI0_SLAVE_CTRL)
+#define bfin_write_TWI0_SLAVE_CTRL(val)		bfin_write16(TWI0_SLAVE_CTRL, val)
+#define bfin_read_TWI0_SLAVE_STAT()		bfin_read16(TWI0_SLAVE_STAT)
+#define bfin_write_TWI0_SLAVE_STAT(val)		bfin_write16(TWI0_SLAVE_STAT, val)
+#define bfin_read_TWI0_SLAVE_ADDR()		bfin_read16(TWI0_SLAVE_ADDR)
+#define bfin_write_TWI0_SLAVE_ADDR(val)		bfin_write16(TWI0_SLAVE_ADDR, val)
+#define bfin_read_TWI0_MASTER_CTRL()		bfin_read16(TWI0_MASTER_CTRL)
+#define bfin_write_TWI0_MASTER_CTRL(val)	bfin_write16(TWI0_MASTER_CTRL, val)
+#define bfin_read_TWI0_MASTER_STAT()		bfin_read16(TWI0_MASTER_STAT)
+#define bfin_write_TWI0_MASTER_STAT(val)	bfin_write16(TWI0_MASTER_STAT, val)
+#define bfin_read_TWI0_MASTER_ADDR()		bfin_read16(TWI0_MASTER_ADDR)
+#define bfin_write_TWI0_MASTER_ADDR(val)	bfin_write16(TWI0_MASTER_ADDR, val)
+#define bfin_read_TWI0_INT_STAT()		bfin_read16(TWI0_INT_STAT)
+#define bfin_write_TWI0_INT_STAT(val)		bfin_write16(TWI0_INT_STAT, val)
+#define bfin_read_TWI0_INT_MASK()		bfin_read16(TWI0_INT_MASK)
+#define bfin_write_TWI0_INT_MASK(val)		bfin_write16(TWI0_INT_MASK, val)
+#define bfin_read_TWI0_FIFO_CTRL()		bfin_read16(TWI0_FIFO_CTRL)
+#define bfin_write_TWI0_FIFO_CTRL(val)		bfin_write16(TWI0_FIFO_CTRL, val)
+#define bfin_read_TWI0_FIFO_STAT()		bfin_read16(TWI0_FIFO_STAT)
+#define bfin_write_TWI0_FIFO_STAT(val)		bfin_write16(TWI0_FIFO_STAT, val)
+#define bfin_read_TWI0_XMT_DATA8()		bfin_read16(TWI0_XMT_DATA8)
+#define bfin_write_TWI0_XMT_DATA8(val)		bfin_write16(TWI0_XMT_DATA8, val)
+#define bfin_read_TWI0_XMT_DATA16()		bfin_read16(TWI0_XMT_DATA16)
+#define bfin_write_TWI0_XMT_DATA16(val)		bfin_write16(TWI0_XMT_DATA16, val)
+#define bfin_read_TWI0_RCV_DATA8()		bfin_read16(TWI0_RCV_DATA8)
+#define bfin_write_TWI0_RCV_DATA8(val)		bfin_write16(TWI0_RCV_DATA8, val)
+#define bfin_read_TWI0_RCV_DATA16()		bfin_read16(TWI0_RCV_DATA16)
+#define bfin_write_TWI0_RCV_DATA16(val)		bfin_write16(TWI0_RCV_DATA16, val)
+
+/* SPORT0 is not defined in the shared file because it is not available on the ADSP-BF542 and ADSP-BF544 bfin_read_()rocessors */
+
+/* SPORT1 Registers */
+
+#define bfin_read_SPORT1_TCR1()		bfin_read16(SPORT1_TCR1)
+#define bfin_write_SPORT1_TCR1(val)	bfin_write16(SPORT1_TCR1, val)
+#define bfin_read_SPORT1_TCR2()		bfin_read16(SPORT1_TCR2)
+#define bfin_write_SPORT1_TCR2(val)	bfin_write16(SPORT1_TCR2, val)
+#define bfin_read_SPORT1_TCLKDIV()	bfin_read16(SPORT1_TCLKDIV)
+#define bfin_write_SPORT1_TCLKDIV(val)	bfin_write16(SPORT1_TCLKDIV, val)
+#define bfin_read_SPORT1_TFSDIV()	bfin_read16(SPORT1_TFSDIV)
+#define bfin_write_SPORT1_TFSDIV(val)	bfin_write16(SPORT1_TFSDIV, val)
+#define bfin_read_SPORT1_TX()		bfin_read32(SPORT1_TX)
+#define bfin_write_SPORT1_TX(val)	bfin_write32(SPORT1_TX, val)
+#define bfin_read_SPORT1_RX()		bfin_read32(SPORT1_RX)
+#define bfin_write_SPORT1_RX(val)	bfin_write32(SPORT1_RX, val)
+#define bfin_read_SPORT1_RCR1()		bfin_read16(SPORT1_RCR1)
+#define bfin_write_SPORT1_RCR1(val)	bfin_write16(SPORT1_RCR1, val)
+#define bfin_read_SPORT1_RCR2()		bfin_read16(SPORT1_RCR2)
+#define bfin_write_SPORT1_RCR2(val)	bfin_write16(SPORT1_RCR2, val)
+#define bfin_read_SPORT1_RCLKDIV()	bfin_read16(SPORT1_RCLKDIV)
+#define bfin_write_SPORT1_RCLKDIV(val)	bfin_write16(SPORT1_RCLKDIV, val)
+#define bfin_read_SPORT1_RFSDIV()	bfin_read16(SPORT1_RFSDIV)
+#define bfin_write_SPORT1_RFSDIV(val)	bfin_write16(SPORT1_RFSDIV, val)
+#define bfin_read_SPORT1_STAT()		bfin_read16(SPORT1_STAT)
+#define bfin_write_SPORT1_STAT(val)	bfin_write16(SPORT1_STAT, val)
+#define bfin_read_SPORT1_CHNL()		bfin_read16(SPORT1_CHNL)
+#define bfin_write_SPORT1_CHNL(val)	bfin_write16(SPORT1_CHNL, val)
+#define bfin_read_SPORT1_MCMC1()	bfin_read16(SPORT1_MCMC1)
+#define bfin_write_SPORT1_MCMC1(val)	bfin_write16(SPORT1_MCMC1, val)
+#define bfin_read_SPORT1_MCMC2()	bfin_read16(SPORT1_MCMC2)
+#define bfin_write_SPORT1_MCMC2(val)	bfin_write16(SPORT1_MCMC2, val)
+#define bfin_read_SPORT1_MTCS0()	bfin_read32(SPORT1_MTCS0)
+#define bfin_write_SPORT1_MTCS0(val)	bfin_write32(SPORT1_MTCS0, val)
+#define bfin_read_SPORT1_MTCS1()	bfin_read32(SPORT1_MTCS1)
+#define bfin_write_SPORT1_MTCS1(val)	bfin_write32(SPORT1_MTCS1, val)
+#define bfin_read_SPORT1_MTCS2()	bfin_read32(SPORT1_MTCS2)
+#define bfin_write_SPORT1_MTCS2(val)	bfin_write32(SPORT1_MTCS2, val)
+#define bfin_read_SPORT1_MTCS3()	bfin_read32(SPORT1_MTCS3)
+#define bfin_write_SPORT1_MTCS3(val)	bfin_write32(SPORT1_MTCS3, val)
+#define bfin_read_SPORT1_MRCS0()	bfin_read32(SPORT1_MRCS0)
+#define bfin_write_SPORT1_MRCS0(val)	bfin_write32(SPORT1_MRCS0, val)
+#define bfin_read_SPORT1_MRCS1()	bfin_read32(SPORT1_MRCS1)
+#define bfin_write_SPORT1_MRCS1(val)	bfin_write32(SPORT1_MRCS1, val)
+#define bfin_read_SPORT1_MRCS2()	bfin_read32(SPORT1_MRCS2)
+#define bfin_write_SPORT1_MRCS2(val)	bfin_write32(SPORT1_MRCS2, val)
+#define bfin_read_SPORT1_MRCS3()	bfin_read32(SPORT1_MRCS3)
+#define bfin_write_SPORT1_MRCS3(val)	bfin_write32(SPORT1_MRCS3, val)
+
+/* Asynchronous Memory Control Registers */
+
+#define bfin_read_EBIU_AMGCTL()		bfin_read16(EBIU_AMGCTL)
+#define bfin_write_EBIU_AMGCTL(val)	bfin_write16(EBIU_AMGCTL, val)
+#define bfin_read_EBIU_AMBCTL0()	bfin_read32(EBIU_AMBCTL0)
+#define bfin_write_EBIU_AMBCTL0(val)	bfin_write32(EBIU_AMBCTL0, val)
+#define bfin_read_EBIU_AMBCTL1()	bfin_read32(EBIU_AMBCTL1)
+#define bfin_write_EBIU_AMBCTL1(val)	bfin_write32(EBIU_AMBCTL1, val)
+#define bfin_read_EBIU_MBSCTL()		bfin_read16(EBIU_MBSCTL)
+#define bfin_write_EBIU_MBSCTL(val)	bfin_write16(EBIU_MBSCTL, val)
+#define bfin_read_EBIU_ARBSTAT()	bfin_read32(EBIU_ARBSTAT)
+#define bfin_write_EBIU_ARBSTAT(val)	bfin_write32(EBIU_ARBSTAT, val)
+#define bfin_read_EBIU_MODE()		bfin_read32(EBIU_MODE)
+#define bfin_write_EBIU_MODE(val)	bfin_write32(EBIU_MODE, val)
+#define bfin_read_EBIU_FCTL()		bfin_read16(EBIU_FCTL)
+#define bfin_write_EBIU_FCTL(val)	bfin_write16(EBIU_FCTL, val)
+
+/* DDR Memory Control Registers */
+
+#define bfin_read_EBIU_DDRCTL0()	bfin_read32(EBIU_DDRCTL0)
+#define bfin_write_EBIU_DDRCTL0(val)	bfin_write32(EBIU_DDRCTL0, val)
+#define bfin_read_EBIU_DDRCTL1()	bfin_read32(EBIU_DDRCTL1)
+#define bfin_write_EBIU_DDRCTL1(val)	bfin_write32(EBIU_DDRCTL1, val)
+#define bfin_read_EBIU_DDRCTL2()	bfin_read32(EBIU_DDRCTL2)
+#define bfin_write_EBIU_DDRCTL2(val)	bfin_write32(EBIU_DDRCTL2, val)
+#define bfin_read_EBIU_DDRCTL3()	bfin_read32(EBIU_DDRCTL3)
+#define bfin_write_EBIU_DDRCTL3(val)	bfin_write32(EBIU_DDRCTL3, val)
+#define bfin_read_EBIU_DDRQUE()		bfin_read32(EBIU_DDRQUE)
+#define bfin_write_EBIU_DDRQUE(val)	bfin_write32(EBIU_DDRQUE, val)
+#define bfin_read_EBIU_ERRADD() 	bfin_read32(EBIU_ERRADD)
+#define bfin_write_EBIU_ERRADD(val) 	bfin_write32(EBIU_ERRADD)
+#define bfin_read_EBIU_ERRMST()		bfin_read16(EBIU_ERRMST)
+#define bfin_write_EBIU_ERRMST(val)	bfin_write16(EBIU_ERRMST, val)
+#define bfin_read_EBIU_RSTCTL()		bfin_read16(EBIU_RSTCTL)
+#define bfin_write_EBIU_RSTCTL(val)	bfin_write16(EBIU_RSTCTL, val)
+
+/* DDR BankRead and Write Count Registers */
+
+#define bfin_read_EBIU_DDRBRC0()	bfin_read32(EBIU_DDRBRC0)
+#define bfin_write_EBIU_DDRBRC0(val)	bfin_write32(EBIU_DDRBRC0, val)
+#define bfin_read_EBIU_DDRBRC1()	bfin_read32(EBIU_DDRBRC1)
+#define bfin_write_EBIU_DDRBRC1(val)	bfin_write32(EBIU_DDRBRC1, val)
+#define bfin_read_EBIU_DDRBRC2()	bfin_read32(EBIU_DDRBRC2)
+#define bfin_write_EBIU_DDRBRC2(val)	bfin_write32(EBIU_DDRBRC2, val)
+#define bfin_read_EBIU_DDRBRC3()	bfin_read32(EBIU_DDRBRC3)
+#define bfin_write_EBIU_DDRBRC3(val)	bfin_write32(EBIU_DDRBRC3, val)
+#define bfin_read_EBIU_DDRBRC4()	bfin_read32(EBIU_DDRBRC4)
+#define bfin_write_EBIU_DDRBRC4(val)	bfin_write32(EBIU_DDRBRC4, val)
+#define bfin_read_EBIU_DDRBRC5()	bfin_read32(EBIU_DDRBRC5)
+#define bfin_write_EBIU_DDRBRC5(val)	bfin_write32(EBIU_DDRBRC5, val)
+#define bfin_read_EBIU_DDRBRC6()	bfin_read32(EBIU_DDRBRC6)
+#define bfin_write_EBIU_DDRBRC6(val)	bfin_write32(EBIU_DDRBRC6, val)
+#define bfin_read_EBIU_DDRBRC7()	bfin_read32(EBIU_DDRBRC7)
+#define bfin_write_EBIU_DDRBRC7(val)	bfin_write32(EBIU_DDRBRC7, val)
+#define bfin_read_EBIU_DDRBWC0()	bfin_read32(EBIU_DDRBWC0)
+#define bfin_write_EBIU_DDRBWC0(val)	bfin_write32(EBIU_DDRBWC0, val)
+#define bfin_read_EBIU_DDRBWC1()	bfin_read32(EBIU_DDRBWC1)
+#define bfin_write_EBIU_DDRBWC1(val)	bfin_write32(EBIU_DDRBWC1, val)
+#define bfin_read_EBIU_DDRBWC2()	bfin_read32(EBIU_DDRBWC2)
+#define bfin_write_EBIU_DDRBWC2(val)	bfin_write32(EBIU_DDRBWC2, val)
+#define bfin_read_EBIU_DDRBWC3()	bfin_read32(EBIU_DDRBWC3)
+#define bfin_write_EBIU_DDRBWC3(val)	bfin_write32(EBIU_DDRBWC3, val)
+#define bfin_read_EBIU_DDRBWC4()	bfin_read32(EBIU_DDRBWC4)
+#define bfin_write_EBIU_DDRBWC4(val)	bfin_write32(EBIU_DDRBWC4, val)
+#define bfin_read_EBIU_DDRBWC5()	bfin_read32(EBIU_DDRBWC5)
+#define bfin_write_EBIU_DDRBWC5(val)	bfin_write32(EBIU_DDRBWC5, val)
+#define bfin_read_EBIU_DDRBWC6()	bfin_read32(EBIU_DDRBWC6)
+#define bfin_write_EBIU_DDRBWC6(val)	bfin_write32(EBIU_DDRBWC6, val)
+#define bfin_read_EBIU_DDRBWC7()	bfin_read32(EBIU_DDRBWC7)
+#define bfin_write_EBIU_DDRBWC7(val)	bfin_write32(EBIU_DDRBWC7, val)
+#define bfin_read_EBIU_DDRACCT()	bfin_read32(EBIU_DDRACCT)
+#define bfin_write_EBIU_DDRACCT(val)	bfin_write32(EBIU_DDRACCT, val)
+#define bfin_read_EBIU_DDRTACT()	bfin_read32(EBIU_DDRTACT)
+#define bfin_write_EBIU_DDRTACT(val)	bfin_write32(EBIU_DDRTACT, val)
+#define bfin_read_EBIU_DDRARCT()	bfin_read32(EBIU_DDRARCT)
+#define bfin_write_EBIU_DDRARCT(val)	bfin_write32(EBIU_DDRARCT, val)
+#define bfin_read_EBIU_DDRGC0()		bfin_read32(EBIU_DDRGC0)
+#define bfin_write_EBIU_DDRGC0(val)	bfin_write32(EBIU_DDRGC0, val)
+#define bfin_read_EBIU_DDRGC1()		bfin_read32(EBIU_DDRGC1)
+#define bfin_write_EBIU_DDRGC1(val)	bfin_write32(EBIU_DDRGC1, val)
+#define bfin_read_EBIU_DDRGC2()		bfin_read32(EBIU_DDRGC2)
+#define bfin_write_EBIU_DDRGC2(val)	bfin_write32(EBIU_DDRGC2, val)
+#define bfin_read_EBIU_DDRGC3()		bfin_read32(EBIU_DDRGC3)
+#define bfin_write_EBIU_DDRGC3(val)	bfin_write32(EBIU_DDRGC3, val)
+#define bfin_read_EBIU_DDRMCEN()	bfin_read32(EBIU_DDRMCEN)
+#define bfin_write_EBIU_DDRMCEN(val)	bfin_write32(EBIU_DDRMCEN, val)
+#define bfin_read_EBIU_DDRMCCL()	bfin_read32(EBIU_DDRMCCL)
+#define bfin_write_EBIU_DDRMCCL(val)	bfin_write32(EBIU_DDRMCCL, val)
+
+/* DMAC0 Registers */
+
+#define bfin_read_DMAC0_TCPER()		bfin_read16(DMAC0_TCPER)
+#define bfin_write_DMAC0_TCPER(val)	bfin_write16(DMAC0_TCPER, val)
+#define bfin_read_DMAC0_TCCNT()		bfin_read16(DMAC0_TCCNT)
+#define bfin_write_DMAC0_TCCNT(val)	bfin_write16(DMAC0_TCCNT, val)
+
+/* DMA Channel 0 Registers */
+
+#define bfin_read_DMA0_NEXT_DESC_PTR() 		bfin_read32(DMA0_NEXT_DESC_PTR)
+#define bfin_write_DMA0_NEXT_DESC_PTR(val) 	bfin_write32(DMA0_NEXT_DESC_PTR)
+#define bfin_read_DMA0_START_ADDR() 		bfin_read32(DMA0_START_ADDR)
+#define bfin_write_DMA0_START_ADDR(val) 	bfin_write32(DMA0_START_ADDR)
+#define bfin_read_DMA0_CONFIG()			bfin_read16(DMA0_CONFIG)
+#define bfin_write_DMA0_CONFIG(val)		bfin_write16(DMA0_CONFIG, val)
+#define bfin_read_DMA0_X_COUNT()		bfin_read16(DMA0_X_COUNT)
+#define bfin_write_DMA0_X_COUNT(val)		bfin_write16(DMA0_X_COUNT, val)
+#define bfin_read_DMA0_X_MODIFY()		bfin_read16(DMA0_X_MODIFY)
+#define bfin_write_DMA0_X_MODIFY(val) 		bfin_write16(DMA0_X_MODIFY)
+#define bfin_read_DMA0_Y_COUNT()		bfin_read16(DMA0_Y_COUNT)
+#define bfin_write_DMA0_Y_COUNT(val)		bfin_write16(DMA0_Y_COUNT, val)
+#define bfin_read_DMA0_Y_MODIFY()		bfin_read16(DMA0_Y_MODIFY)
+#define bfin_write_DMA0_Y_MODIFY(val) 		bfin_write16(DMA0_Y_MODIFY)
+#define bfin_read_DMA0_CURR_DESC_PTR() 		bfin_read32(DMA0_CURR_DESC_PTR)
+#define bfin_write_DMA0_CURR_DESC_PTR(val) 	bfin_write32(DMA0_CURR_DESC_PTR)
+#define bfin_read_DMA0_CURR_ADDR() 		bfin_read32(DMA0_CURR_ADDR)
+#define bfin_write_DMA0_CURR_ADDR(val) 		bfin_write32(DMA0_CURR_ADDR)
+#define bfin_read_DMA0_IRQ_STATUS()		bfin_read16(DMA0_IRQ_STATUS)
+#define bfin_write_DMA0_IRQ_STATUS(val)		bfin_write16(DMA0_IRQ_STATUS, val)
+#define bfin_read_DMA0_PERIPHERAL_MAP()		bfin_read16(DMA0_PERIPHERAL_MAP)
+#define bfin_write_DMA0_PERIPHERAL_MAP(val)	bfin_write16(DMA0_PERIPHERAL_MAP, val)
+#define bfin_read_DMA0_CURR_X_COUNT()		bfin_read16(DMA0_CURR_X_COUNT)
+#define bfin_write_DMA0_CURR_X_COUNT(val)	bfin_write16(DMA0_CURR_X_COUNT, val)
+#define bfin_read_DMA0_CURR_Y_COUNT()		bfin_read16(DMA0_CURR_Y_COUNT)
+#define bfin_write_DMA0_CURR_Y_COUNT(val)	bfin_write16(DMA0_CURR_Y_COUNT, val)
+
+/* DMA Channel 1 Registers */
+
+#define bfin_read_DMA1_NEXT_DESC_PTR() 		bfin_read32(DMA1_NEXT_DESC_PTR)
+#define bfin_write_DMA1_NEXT_DESC_PTR(val) 	bfin_write32(DMA1_NEXT_DESC_PTR)
+#define bfin_read_DMA1_START_ADDR() 		bfin_read32(DMA1_START_ADDR)
+#define bfin_write_DMA1_START_ADDR(val) 	bfin_write32(DMA1_START_ADDR)
+#define bfin_read_DMA1_CONFIG()			bfin_read16(DMA1_CONFIG)
+#define bfin_write_DMA1_CONFIG(val)		bfin_write16(DMA1_CONFIG, val)
+#define bfin_read_DMA1_X_COUNT()		bfin_read16(DMA1_X_COUNT)
+#define bfin_write_DMA1_X_COUNT(val)		bfin_write16(DMA1_X_COUNT, val)
+#define bfin_read_DMA1_X_MODIFY()		bfin_read16(DMA1_X_MODIFY)
+#define bfin_write_DMA1_X_MODIFY(val) 		bfin_write16(DMA1_X_MODIFY)
+#define bfin_read_DMA1_Y_COUNT()		bfin_read16(DMA1_Y_COUNT)
+#define bfin_write_DMA1_Y_COUNT(val)		bfin_write16(DMA1_Y_COUNT, val)
+#define bfin_read_DMA1_Y_MODIFY()		bfin_read16(DMA1_Y_MODIFY)
+#define bfin_write_DMA1_Y_MODIFY(val) 		bfin_write16(DMA1_Y_MODIFY)
+#define bfin_read_DMA1_CURR_DESC_PTR() 		bfin_read32(DMA1_CURR_DESC_PTR)
+#define bfin_write_DMA1_CURR_DESC_PTR(val) 	bfin_write32(DMA1_CURR_DESC_PTR)
+#define bfin_read_DMA1_CURR_ADDR() 		bfin_read32(DMA1_CURR_ADDR)
+#define bfin_write_DMA1_CURR_ADDR(val) 		bfin_write32(DMA1_CURR_ADDR)
+#define bfin_read_DMA1_IRQ_STATUS()		bfin_read16(DMA1_IRQ_STATUS)
+#define bfin_write_DMA1_IRQ_STATUS(val)		bfin_write16(DMA1_IRQ_STATUS, val)
+#define bfin_read_DMA1_PERIPHERAL_MAP()		bfin_read16(DMA1_PERIPHERAL_MAP)
+#define bfin_write_DMA1_PERIPHERAL_MAP(val)	bfin_write16(DMA1_PERIPHERAL_MAP, val)
+#define bfin_read_DMA1_CURR_X_COUNT()		bfin_read16(DMA1_CURR_X_COUNT)
+#define bfin_write_DMA1_CURR_X_COUNT(val)	bfin_write16(DMA1_CURR_X_COUNT, val)
+#define bfin_read_DMA1_CURR_Y_COUNT()		bfin_read16(DMA1_CURR_Y_COUNT)
+#define bfin_write_DMA1_CURR_Y_COUNT(val)	bfin_write16(DMA1_CURR_Y_COUNT, val)
+
+/* DMA Channel 2 Registers */
+
+#define bfin_read_DMA2_NEXT_DESC_PTR() 		bfin_read32(DMA2_NEXT_DESC_PTR)
+#define bfin_write_DMA2_NEXT_DESC_PTR(val) 	bfin_write32(DMA2_NEXT_DESC_PTR)
+#define bfin_read_DMA2_START_ADDR() 		bfin_read32(DMA2_START_ADDR)
+#define bfin_write_DMA2_START_ADDR(val) 	bfin_write32(DMA2_START_ADDR)
+#define bfin_read_DMA2_CONFIG()			bfin_read16(DMA2_CONFIG)
+#define bfin_write_DMA2_CONFIG(val)		bfin_write16(DMA2_CONFIG, val)
+#define bfin_read_DMA2_X_COUNT()		bfin_read16(DMA2_X_COUNT)
+#define bfin_write_DMA2_X_COUNT(val)		bfin_write16(DMA2_X_COUNT, val)
+#define bfin_read_DMA2_X_MODIFY()		bfin_read16(DMA2_X_MODIFY)
+#define bfin_write_DMA2_X_MODIFY(val) 		bfin_write16(DMA2_X_MODIFY)
+#define bfin_read_DMA2_Y_COUNT()		bfin_read16(DMA2_Y_COUNT)
+#define bfin_write_DMA2_Y_COUNT(val)		bfin_write16(DMA2_Y_COUNT, val)
+#define bfin_read_DMA2_Y_MODIFY()		bfin_read16(DMA2_Y_MODIFY)
+#define bfin_write_DMA2_Y_MODIFY(val) 		bfin_write16(DMA2_Y_MODIFY)
+#define bfin_read_DMA2_CURR_DESC_PTR() 		bfin_read32(DMA2_CURR_DESC_PTR)
+#define bfin_write_DMA2_CURR_DESC_PTR(val) 	bfin_write32(DMA2_CURR_DESC_PTR)
+#define bfin_read_DMA2_CURR_ADDR() 		bfin_read32(DMA2_CURR_ADDR)
+#define bfin_write_DMA2_CURR_ADDR(val) 		bfin_write32(DMA2_CURR_ADDR)
+#define bfin_read_DMA2_IRQ_STATUS()		bfin_read16(DMA2_IRQ_STATUS)
+#define bfin_write_DMA2_IRQ_STATUS(val)		bfin_write16(DMA2_IRQ_STATUS, val)
+#define bfin_read_DMA2_PERIPHERAL_MAP()		bfin_read16(DMA2_PERIPHERAL_MAP)
+#define bfin_write_DMA2_PERIPHERAL_MAP(val)	bfin_write16(DMA2_PERIPHERAL_MAP, val)
+#define bfin_read_DMA2_CURR_X_COUNT()		bfin_read16(DMA2_CURR_X_COUNT)
+#define bfin_write_DMA2_CURR_X_COUNT(val)	bfin_write16(DMA2_CURR_X_COUNT, val)
+#define bfin_read_DMA2_CURR_Y_COUNT()		bfin_read16(DMA2_CURR_Y_COUNT)
+#define bfin_write_DMA2_CURR_Y_COUNT(val)	bfin_write16(DMA2_CURR_Y_COUNT, val)
+
+/* DMA Channel 3 Registers */
+
+#define bfin_read_DMA3_NEXT_DESC_PTR() 		bfin_read32(DMA3_NEXT_DESC_PTR)
+#define bfin_write_DMA3_NEXT_DESC_PTR(val) 	bfin_write32(DMA3_NEXT_DESC_PTR)
+#define bfin_read_DMA3_START_ADDR() 		bfin_read32(DMA3_START_ADDR)
+#define bfin_write_DMA3_START_ADDR(val) 	bfin_write32(DMA3_START_ADDR)
+#define bfin_read_DMA3_CONFIG()			bfin_read16(DMA3_CONFIG)
+#define bfin_write_DMA3_CONFIG(val)		bfin_write16(DMA3_CONFIG, val)
+#define bfin_read_DMA3_X_COUNT()		bfin_read16(DMA3_X_COUNT)
+#define bfin_write_DMA3_X_COUNT(val)		bfin_write16(DMA3_X_COUNT, val)
+#define bfin_read_DMA3_X_MODIFY()		bfin_read16(DMA3_X_MODIFY)
+#define bfin_write_DMA3_X_MODIFY(val) 		bfin_write16(DMA3_X_MODIFY)
+#define bfin_read_DMA3_Y_COUNT()		bfin_read16(DMA3_Y_COUNT)
+#define bfin_write_DMA3_Y_COUNT(val)		bfin_write16(DMA3_Y_COUNT, val)
+#define bfin_read_DMA3_Y_MODIFY()		bfin_read16(DMA3_Y_MODIFY)
+#define bfin_write_DMA3_Y_MODIFY(val) 		bfin_write16(DMA3_Y_MODIFY)
+#define bfin_read_DMA3_CURR_DESC_PTR() 		bfin_read32(DMA3_CURR_DESC_PTR)
+#define bfin_write_DMA3_CURR_DESC_PTR(val) 	bfin_write32(DMA3_CURR_DESC_PTR)
+#define bfin_read_DMA3_CURR_ADDR() 		bfin_read32(DMA3_CURR_ADDR)
+#define bfin_write_DMA3_CURR_ADDR(val) 		bfin_write32(DMA3_CURR_ADDR)
+#define bfin_read_DMA3_IRQ_STATUS()		bfin_read16(DMA3_IRQ_STATUS)
+#define bfin_write_DMA3_IRQ_STATUS(val)		bfin_write16(DMA3_IRQ_STATUS, val)
+#define bfin_read_DMA3_PERIPHERAL_MAP()		bfin_read16(DMA3_PERIPHERAL_MAP)
+#define bfin_write_DMA3_PERIPHERAL_MAP(val)	bfin_write16(DMA3_PERIPHERAL_MAP, val)
+#define bfin_read_DMA3_CURR_X_COUNT()		bfin_read16(DMA3_CURR_X_COUNT)
+#define bfin_write_DMA3_CURR_X_COUNT(val)	bfin_write16(DMA3_CURR_X_COUNT, val)
+#define bfin_read_DMA3_CURR_Y_COUNT()		bfin_read16(DMA3_CURR_Y_COUNT)
+#define bfin_write_DMA3_CURR_Y_COUNT(val)	bfin_write16(DMA3_CURR_Y_COUNT, val)
+
+/* DMA Channel 4 Registers */
+
+#define bfin_read_DMA4_NEXT_DESC_PTR() 		bfin_read32(DMA4_NEXT_DESC_PTR)
+#define bfin_write_DMA4_NEXT_DESC_PTR(val) 	bfin_write32(DMA4_NEXT_DESC_PTR)
+#define bfin_read_DMA4_START_ADDR() 		bfin_read32(DMA4_START_ADDR)
+#define bfin_write_DMA4_START_ADDR(val) 	bfin_write32(DMA4_START_ADDR)
+#define bfin_read_DMA4_CONFIG()			bfin_read16(DMA4_CONFIG)
+#define bfin_write_DMA4_CONFIG(val)		bfin_write16(DMA4_CONFIG, val)
+#define bfin_read_DMA4_X_COUNT()		bfin_read16(DMA4_X_COUNT)
+#define bfin_write_DMA4_X_COUNT(val)		bfin_write16(DMA4_X_COUNT, val)
+#define bfin_read_DMA4_X_MODIFY()		bfin_read16(DMA4_X_MODIFY)
+#define bfin_write_DMA4_X_MODIFY(val) 		bfin_write16(DMA4_X_MODIFY)
+#define bfin_read_DMA4_Y_COUNT()		bfin_read16(DMA4_Y_COUNT)
+#define bfin_write_DMA4_Y_COUNT(val)		bfin_write16(DMA4_Y_COUNT, val)
+#define bfin_read_DMA4_Y_MODIFY()		bfin_read16(DMA4_Y_MODIFY)
+#define bfin_write_DMA4_Y_MODIFY(val) 		bfin_write16(DMA4_Y_MODIFY)
+#define bfin_read_DMA4_CURR_DESC_PTR() 		bfin_read32(DMA4_CURR_DESC_PTR)
+#define bfin_write_DMA4_CURR_DESC_PTR(val) 	bfin_write32(DMA4_CURR_DESC_PTR)
+#define bfin_read_DMA4_CURR_ADDR() 		bfin_read32(DMA4_CURR_ADDR)
+#define bfin_write_DMA4_CURR_ADDR(val) 		bfin_write32(DMA4_CURR_ADDR)
+#define bfin_read_DMA4_IRQ_STATUS()		bfin_read16(DMA4_IRQ_STATUS)
+#define bfin_write_DMA4_IRQ_STATUS(val)		bfin_write16(DMA4_IRQ_STATUS, val)
+#define bfin_read_DMA4_PERIPHERAL_MAP()		bfin_read16(DMA4_PERIPHERAL_MAP)
+#define bfin_write_DMA4_PERIPHERAL_MAP(val)	bfin_write16(DMA4_PERIPHERAL_MAP, val)
+#define bfin_read_DMA4_CURR_X_COUNT()		bfin_read16(DMA4_CURR_X_COUNT)
+#define bfin_write_DMA4_CURR_X_COUNT(val)	bfin_write16(DMA4_CURR_X_COUNT, val)
+#define bfin_read_DMA4_CURR_Y_COUNT()		bfin_read16(DMA4_CURR_Y_COUNT)
+#define bfin_write_DMA4_CURR_Y_COUNT(val)	bfin_write16(DMA4_CURR_Y_COUNT, val)
+
+/* DMA Channel 5 Registers */
+
+#define bfin_read_DMA5_NEXT_DESC_PTR() 		bfin_read32(DMA5_NEXT_DESC_PTR)
+#define bfin_write_DMA5_NEXT_DESC_PTR(val) 	bfin_write32(DMA5_NEXT_DESC_PTR)
+#define bfin_read_DMA5_START_ADDR() 		bfin_read32(DMA5_START_ADDR)
+#define bfin_write_DMA5_START_ADDR(val) 	bfin_write32(DMA5_START_ADDR)
+#define bfin_read_DMA5_CONFIG()			bfin_read16(DMA5_CONFIG)
+#define bfin_write_DMA5_CONFIG(val)		bfin_write16(DMA5_CONFIG, val)
+#define bfin_read_DMA5_X_COUNT()		bfin_read16(DMA5_X_COUNT)
+#define bfin_write_DMA5_X_COUNT(val)		bfin_write16(DMA5_X_COUNT, val)
+#define bfin_read_DMA5_X_MODIFY()		bfin_read16(DMA5_X_MODIFY)
+#define bfin_write_DMA5_X_MODIFY(val) 		bfin_write16(DMA5_X_MODIFY)
+#define bfin_read_DMA5_Y_COUNT()		bfin_read16(DMA5_Y_COUNT)
+#define bfin_write_DMA5_Y_COUNT(val)		bfin_write16(DMA5_Y_COUNT, val)
+#define bfin_read_DMA5_Y_MODIFY()		bfin_read16(DMA5_Y_MODIFY)
+#define bfin_write_DMA5_Y_MODIFY(val) 		bfin_write16(DMA5_Y_MODIFY)
+#define bfin_read_DMA5_CURR_DESC_PTR() 		bfin_read32(DMA5_CURR_DESC_PTR)
+#define bfin_write_DMA5_CURR_DESC_PTR(val) 	bfin_write32(DMA5_CURR_DESC_PTR)
+#define bfin_read_DMA5_CURR_ADDR() 		bfin_read32(DMA5_CURR_ADDR)
+#define bfin_write_DMA5_CURR_ADDR(val) 		bfin_write32(DMA5_CURR_ADDR)
+#define bfin_read_DMA5_IRQ_STATUS()		bfin_read16(DMA5_IRQ_STATUS)
+#define bfin_write_DMA5_IRQ_STATUS(val)		bfin_write16(DMA5_IRQ_STATUS, val)
+#define bfin_read_DMA5_PERIPHERAL_MAP()		bfin_read16(DMA5_PERIPHERAL_MAP)
+#define bfin_write_DMA5_PERIPHERAL_MAP(val)	bfin_write16(DMA5_PERIPHERAL_MAP, val)
+#define bfin_read_DMA5_CURR_X_COUNT()		bfin_read16(DMA5_CURR_X_COUNT)
+#define bfin_write_DMA5_CURR_X_COUNT(val)	bfin_write16(DMA5_CURR_X_COUNT, val)
+#define bfin_read_DMA5_CURR_Y_COUNT()		bfin_read16(DMA5_CURR_Y_COUNT)
+#define bfin_write_DMA5_CURR_Y_COUNT(val)	bfin_write16(DMA5_CURR_Y_COUNT, val)
+
+/* DMA Channel 6 Registers */
+
+#define bfin_read_DMA6_NEXT_DESC_PTR() 		bfin_read32(DMA6_NEXT_DESC_PTR)
+#define bfin_write_DMA6_NEXT_DESC_PTR(val) 	bfin_write32(DMA6_NEXT_DESC_PTR)
+#define bfin_read_DMA6_START_ADDR() 		bfin_read32(DMA6_START_ADDR)
+#define bfin_write_DMA6_START_ADDR(val) 	bfin_write32(DMA6_START_ADDR)
+#define bfin_read_DMA6_CONFIG()			bfin_read16(DMA6_CONFIG)
+#define bfin_write_DMA6_CONFIG(val)		bfin_write16(DMA6_CONFIG, val)
+#define bfin_read_DMA6_X_COUNT()		bfin_read16(DMA6_X_COUNT)
+#define bfin_write_DMA6_X_COUNT(val)		bfin_write16(DMA6_X_COUNT, val)
+#define bfin_read_DMA6_X_MODIFY()		bfin_read16(DMA6_X_MODIFY)
+#define bfin_write_DMA6_X_MODIFY(val) 		bfin_write16(DMA6_X_MODIFY)
+#define bfin_read_DMA6_Y_COUNT()		bfin_read16(DMA6_Y_COUNT)
+#define bfin_write_DMA6_Y_COUNT(val)		bfin_write16(DMA6_Y_COUNT, val)
+#define bfin_read_DMA6_Y_MODIFY()		bfin_read16(DMA6_Y_MODIFY)
+#define bfin_write_DMA6_Y_MODIFY(val) 		bfin_write16(DMA6_Y_MODIFY)
+#define bfin_read_DMA6_CURR_DESC_PTR() 		bfin_read32(DMA6_CURR_DESC_PTR)
+#define bfin_write_DMA6_CURR_DESC_PTR(val) 	bfin_write32(DMA6_CURR_DESC_PTR)
+#define bfin_read_DMA6_CURR_ADDR() 		bfin_read32(DMA6_CURR_ADDR)
+#define bfin_write_DMA6_CURR_ADDR(val) 		bfin_write32(DMA6_CURR_ADDR)
+#define bfin_read_DMA6_IRQ_STATUS()		bfin_read16(DMA6_IRQ_STATUS)
+#define bfin_write_DMA6_IRQ_STATUS(val)		bfin_write16(DMA6_IRQ_STATUS, val)
+#define bfin_read_DMA6_PERIPHERAL_MAP()		bfin_read16(DMA6_PERIPHERAL_MAP)
+#define bfin_write_DMA6_PERIPHERAL_MAP(val)	bfin_write16(DMA6_PERIPHERAL_MAP, val)
+#define bfin_read_DMA6_CURR_X_COUNT()		bfin_read16(DMA6_CURR_X_COUNT)
+#define bfin_write_DMA6_CURR_X_COUNT(val)	bfin_write16(DMA6_CURR_X_COUNT, val)
+#define bfin_read_DMA6_CURR_Y_COUNT()		bfin_read16(DMA6_CURR_Y_COUNT)
+#define bfin_write_DMA6_CURR_Y_COUNT(val)	bfin_write16(DMA6_CURR_Y_COUNT, val)
+
+/* DMA Channel 7 Registers */
+
+#define bfin_read_DMA7_NEXT_DESC_PTR() 		bfin_read32(DMA7_NEXT_DESC_PTR)
+#define bfin_write_DMA7_NEXT_DESC_PTR(val) 	bfin_write32(DMA7_NEXT_DESC_PTR)
+#define bfin_read_DMA7_START_ADDR() 		bfin_read32(DMA7_START_ADDR)
+#define bfin_write_DMA7_START_ADDR(val) 	bfin_write32(DMA7_START_ADDR)
+#define bfin_read_DMA7_CONFIG()			bfin_read16(DMA7_CONFIG)
+#define bfin_write_DMA7_CONFIG(val)		bfin_write16(DMA7_CONFIG, val)
+#define bfin_read_DMA7_X_COUNT()		bfin_read16(DMA7_X_COUNT)
+#define bfin_write_DMA7_X_COUNT(val)		bfin_write16(DMA7_X_COUNT, val)
+#define bfin_read_DMA7_X_MODIFY()		bfin_read16(DMA7_X_MODIFY)
+#define bfin_write_DMA7_X_MODIFY(val) 		bfin_write16(DMA7_X_MODIFY)
+#define bfin_read_DMA7_Y_COUNT()		bfin_read16(DMA7_Y_COUNT)
+#define bfin_write_DMA7_Y_COUNT(val)		bfin_write16(DMA7_Y_COUNT, val)
+#define bfin_read_DMA7_Y_MODIFY()		bfin_read16(DMA7_Y_MODIFY)
+#define bfin_write_DMA7_Y_MODIFY(val) 		bfin_write16(DMA7_Y_MODIFY)
+#define bfin_read_DMA7_CURR_DESC_PTR() 		bfin_read32(DMA7_CURR_DESC_PTR)
+#define bfin_write_DMA7_CURR_DESC_PTR(val) 	bfin_write32(DMA7_CURR_DESC_PTR)
+#define bfin_read_DMA7_CURR_ADDR() 		bfin_read32(DMA7_CURR_ADDR)
+#define bfin_write_DMA7_CURR_ADDR(val) 		bfin_write32(DMA7_CURR_ADDR)
+#define bfin_read_DMA7_IRQ_STATUS()		bfin_read16(DMA7_IRQ_STATUS)
+#define bfin_write_DMA7_IRQ_STATUS(val)		bfin_write16(DMA7_IRQ_STATUS, val)
+#define bfin_read_DMA7_PERIPHERAL_MAP()		bfin_read16(DMA7_PERIPHERAL_MAP)
+#define bfin_write_DMA7_PERIPHERAL_MAP(val)	bfin_write16(DMA7_PERIPHERAL_MAP, val)
+#define bfin_read_DMA7_CURR_X_COUNT()		bfin_read16(DMA7_CURR_X_COUNT)
+#define bfin_write_DMA7_CURR_X_COUNT(val)	bfin_write16(DMA7_CURR_X_COUNT, val)
+#define bfin_read_DMA7_CURR_Y_COUNT()		bfin_read16(DMA7_CURR_Y_COUNT)
+#define bfin_write_DMA7_CURR_Y_COUNT(val)	bfin_write16(DMA7_CURR_Y_COUNT, val)
+
+/* DMA Channel 8 Registers */
+
+#define bfin_read_DMA8_NEXT_DESC_PTR() 		bfin_read32(DMA8_NEXT_DESC_PTR)
+#define bfin_write_DMA8_NEXT_DESC_PTR(val) 	bfin_write32(DMA8_NEXT_DESC_PTR)
+#define bfin_read_DMA8_START_ADDR() 		bfin_read32(DMA8_START_ADDR)
+#define bfin_write_DMA8_START_ADDR(val) 	bfin_write32(DMA8_START_ADDR)
+#define bfin_read_DMA8_CONFIG()			bfin_read16(DMA8_CONFIG)
+#define bfin_write_DMA8_CONFIG(val)		bfin_write16(DMA8_CONFIG, val)
+#define bfin_read_DMA8_X_COUNT()		bfin_read16(DMA8_X_COUNT)
+#define bfin_write_DMA8_X_COUNT(val)		bfin_write16(DMA8_X_COUNT, val)
+#define bfin_read_DMA8_X_MODIFY()		bfin_read16(DMA8_X_MODIFY)
+#define bfin_write_DMA8_X_MODIFY(val) 		bfin_write16(DMA8_X_MODIFY)
+#define bfin_read_DMA8_Y_COUNT()		bfin_read16(DMA8_Y_COUNT)
+#define bfin_write_DMA8_Y_COUNT(val)		bfin_write16(DMA8_Y_COUNT, val)
+#define bfin_read_DMA8_Y_MODIFY()		bfin_read16(DMA8_Y_MODIFY)
+#define bfin_write_DMA8_Y_MODIFY(val) 		bfin_write16(DMA8_Y_MODIFY)
+#define bfin_read_DMA8_CURR_DESC_PTR() 		bfin_read32(DMA8_CURR_DESC_PTR)
+#define bfin_write_DMA8_CURR_DESC_PTR(val) 	bfin_write32(DMA8_CURR_DESC_PTR)
+#define bfin_read_DMA8_CURR_ADDR() 		bfin_read32(DMA8_CURR_ADDR)
+#define bfin_write_DMA8_CURR_ADDR(val) 		bfin_write32(DMA8_CURR_ADDR)
+#define bfin_read_DMA8_IRQ_STATUS()		bfin_read16(DMA8_IRQ_STATUS)
+#define bfin_write_DMA8_IRQ_STATUS(val)		bfin_write16(DMA8_IRQ_STATUS, val)
+#define bfin_read_DMA8_PERIPHERAL_MAP()		bfin_read16(DMA8_PERIPHERAL_MAP)
+#define bfin_write_DMA8_PERIPHERAL_MAP(val)	bfin_write16(DMA8_PERIPHERAL_MAP, val)
+#define bfin_read_DMA8_CURR_X_COUNT()		bfin_read16(DMA8_CURR_X_COUNT)
+#define bfin_write_DMA8_CURR_X_COUNT(val)	bfin_write16(DMA8_CURR_X_COUNT, val)
+#define bfin_read_DMA8_CURR_Y_COUNT()		bfin_read16(DMA8_CURR_Y_COUNT)
+#define bfin_write_DMA8_CURR_Y_COUNT(val)	bfin_write16(DMA8_CURR_Y_COUNT, val)
+
+/* DMA Channel 9 Registers */
+
+#define bfin_read_DMA9_NEXT_DESC_PTR() 		bfin_read32(DMA9_NEXT_DESC_PTR)
+#define bfin_write_DMA9_NEXT_DESC_PTR(val) 	bfin_write32(DMA9_NEXT_DESC_PTR)
+#define bfin_read_DMA9_START_ADDR() 		bfin_read32(DMA9_START_ADDR)
+#define bfin_write_DMA9_START_ADDR(val) 	bfin_write32(DMA9_START_ADDR)
+#define bfin_read_DMA9_CONFIG()			bfin_read16(DMA9_CONFIG)
+#define bfin_write_DMA9_CONFIG(val)		bfin_write16(DMA9_CONFIG, val)
+#define bfin_read_DMA9_X_COUNT()		bfin_read16(DMA9_X_COUNT)
+#define bfin_write_DMA9_X_COUNT(val)		bfin_write16(DMA9_X_COUNT, val)
+#define bfin_read_DMA9_X_MODIFY()		bfin_read16(DMA9_X_MODIFY)
+#define bfin_write_DMA9_X_MODIFY(val) 		bfin_write16(DMA9_X_MODIFY)
+#define bfin_read_DMA9_Y_COUNT()		bfin_read16(DMA9_Y_COUNT)
+#define bfin_write_DMA9_Y_COUNT(val)		bfin_write16(DMA9_Y_COUNT, val)
+#define bfin_read_DMA9_Y_MODIFY()		bfin_read16(DMA9_Y_MODIFY)
+#define bfin_write_DMA9_Y_MODIFY(val) 		bfin_write16(DMA9_Y_MODIFY)
+#define bfin_read_DMA9_CURR_DESC_PTR() 		bfin_read32(DMA9_CURR_DESC_PTR)
+#define bfin_write_DMA9_CURR_DESC_PTR(val) 	bfin_write32(DMA9_CURR_DESC_PTR)
+#define bfin_read_DMA9_CURR_ADDR() 		bfin_read32(DMA9_CURR_ADDR)
+#define bfin_write_DMA9_CURR_ADDR(val) 		bfin_write32(DMA9_CURR_ADDR)
+#define bfin_read_DMA9_IRQ_STATUS()		bfin_read16(DMA9_IRQ_STATUS)
+#define bfin_write_DMA9_IRQ_STATUS(val)		bfin_write16(DMA9_IRQ_STATUS, val)
+#define bfin_read_DMA9_PERIPHERAL_MAP()		bfin_read16(DMA9_PERIPHERAL_MAP)
+#define bfin_write_DMA9_PERIPHERAL_MAP(val)	bfin_write16(DMA9_PERIPHERAL_MAP, val)
+#define bfin_read_DMA9_CURR_X_COUNT()		bfin_read16(DMA9_CURR_X_COUNT)
+#define bfin_write_DMA9_CURR_X_COUNT(val)	bfin_write16(DMA9_CURR_X_COUNT, val)
+#define bfin_read_DMA9_CURR_Y_COUNT()		bfin_read16(DMA9_CURR_Y_COUNT)
+#define bfin_write_DMA9_CURR_Y_COUNT(val)	bfin_write16(DMA9_CURR_Y_COUNT, val)
+
+/* DMA Channel 10 Registers */
+
+#define bfin_read_DMA10_NEXT_DESC_PTR() 	bfin_read32(DMA10_NEXT_DESC_PTR)
+#define bfin_write_DMA10_NEXT_DESC_PTR(val) 	bfin_write32(DMA10_NEXT_DESC_PTR)
+#define bfin_read_DMA10_START_ADDR() 		bfin_read32(DMA10_START_ADDR)
+#define bfin_write_DMA10_START_ADDR(val) 	bfin_write32(DMA10_START_ADDR)
+#define bfin_read_DMA10_CONFIG()		bfin_read16(DMA10_CONFIG)
+#define bfin_write_DMA10_CONFIG(val)		bfin_write16(DMA10_CONFIG, val)
+#define bfin_read_DMA10_X_COUNT()		bfin_read16(DMA10_X_COUNT)
+#define bfin_write_DMA10_X_COUNT(val)		bfin_write16(DMA10_X_COUNT, val)
+#define bfin_read_DMA10_X_MODIFY()		bfin_read16(DMA10_X_MODIFY)
+#define bfin_write_DMA10_X_MODIFY(val) 		bfin_write16(DMA10_X_MODIFY)
+#define bfin_read_DMA10_Y_COUNT()		bfin_read16(DMA10_Y_COUNT)
+#define bfin_write_DMA10_Y_COUNT(val)		bfin_write16(DMA10_Y_COUNT, val)
+#define bfin_read_DMA10_Y_MODIFY()		bfin_read16(DMA10_Y_MODIFY)
+#define bfin_write_DMA10_Y_MODIFY(val) 		bfin_write16(DMA10_Y_MODIFY)
+#define bfin_read_DMA10_CURR_DESC_PTR() 	bfin_read32(DMA10_CURR_DESC_PTR)
+#define bfin_write_DMA10_CURR_DESC_PTR(val) 	bfin_write32(DMA10_CURR_DESC_PTR)
+#define bfin_read_DMA10_CURR_ADDR() 		bfin_read32(DMA10_CURR_ADDR)
+#define bfin_write_DMA10_CURR_ADDR(val) 	bfin_write32(DMA10_CURR_ADDR)
+#define bfin_read_DMA10_IRQ_STATUS()		bfin_read16(DMA10_IRQ_STATUS)
+#define bfin_write_DMA10_IRQ_STATUS(val)	bfin_write16(DMA10_IRQ_STATUS, val)
+#define bfin_read_DMA10_PERIPHERAL_MAP()	bfin_read16(DMA10_PERIPHERAL_MAP)
+#define bfin_write_DMA10_PERIPHERAL_MAP(val)	bfin_write16(DMA10_PERIPHERAL_MAP, val)
+#define bfin_read_DMA10_CURR_X_COUNT()		bfin_read16(DMA10_CURR_X_COUNT)
+#define bfin_write_DMA10_CURR_X_COUNT(val)	bfin_write16(DMA10_CURR_X_COUNT, val)
+#define bfin_read_DMA10_CURR_Y_COUNT()		bfin_read16(DMA10_CURR_Y_COUNT)
+#define bfin_write_DMA10_CURR_Y_COUNT(val)	bfin_write16(DMA10_CURR_Y_COUNT, val)
+
+/* DMA Channel 11 Registers */
+
+#define bfin_read_DMA11_NEXT_DESC_PTR() 	bfin_read32(DMA11_NEXT_DESC_PTR)
+#define bfin_write_DMA11_NEXT_DESC_PTR(val) 	bfin_write32(DMA11_NEXT_DESC_PTR)
+#define bfin_read_DMA11_START_ADDR() 		bfin_read32(DMA11_START_ADDR)
+#define bfin_write_DMA11_START_ADDR(val) 	bfin_write32(DMA11_START_ADDR)
+#define bfin_read_DMA11_CONFIG()		bfin_read16(DMA11_CONFIG)
+#define bfin_write_DMA11_CONFIG(val)		bfin_write16(DMA11_CONFIG, val)
+#define bfin_read_DMA11_X_COUNT()		bfin_read16(DMA11_X_COUNT)
+#define bfin_write_DMA11_X_COUNT(val)		bfin_write16(DMA11_X_COUNT, val)
+#define bfin_read_DMA11_X_MODIFY()		bfin_read16(DMA11_X_MODIFY)
+#define bfin_write_DMA11_X_MODIFY(val) 		bfin_write16(DMA11_X_MODIFY)
+#define bfin_read_DMA11_Y_COUNT()		bfin_read16(DMA11_Y_COUNT)
+#define bfin_write_DMA11_Y_COUNT(val)		bfin_write16(DMA11_Y_COUNT, val)
+#define bfin_read_DMA11_Y_MODIFY()		bfin_read16(DMA11_Y_MODIFY)
+#define bfin_write_DMA11_Y_MODIFY(val) 		bfin_write16(DMA11_Y_MODIFY)
+#define bfin_read_DMA11_CURR_DESC_PTR() 	bfin_read32(DMA11_CURR_DESC_PTR)
+#define bfin_write_DMA11_CURR_DESC_PTR(val) 	bfin_write32(DMA11_CURR_DESC_PTR)
+#define bfin_read_DMA11_CURR_ADDR() 		bfin_read32(DMA11_CURR_ADDR)
+#define bfin_write_DMA11_CURR_ADDR(val) 	bfin_write32(DMA11_CURR_ADDR)
+#define bfin_read_DMA11_IRQ_STATUS()		bfin_read16(DMA11_IRQ_STATUS)
+#define bfin_write_DMA11_IRQ_STATUS(val)	bfin_write16(DMA11_IRQ_STATUS, val)
+#define bfin_read_DMA11_PERIPHERAL_MAP()	bfin_read16(DMA11_PERIPHERAL_MAP)
+#define bfin_write_DMA11_PERIPHERAL_MAP(val)	bfin_write16(DMA11_PERIPHERAL_MAP, val)
+#define bfin_read_DMA11_CURR_X_COUNT()		bfin_read16(DMA11_CURR_X_COUNT)
+#define bfin_write_DMA11_CURR_X_COUNT(val)	bfin_write16(DMA11_CURR_X_COUNT, val)
+#define bfin_read_DMA11_CURR_Y_COUNT()		bfin_read16(DMA11_CURR_Y_COUNT)
+#define bfin_write_DMA11_CURR_Y_COUNT(val)	bfin_write16(DMA11_CURR_Y_COUNT, val)
+
+/* MDMA Stream 0 Registers */
+
+#define bfin_read_MDMA_D0_NEXT_DESC_PTR() 	bfin_read32(MDMA_D0_NEXT_DESC_PTR)
+#define bfin_write_MDMA_D0_NEXT_DESC_PTR(val) 	bfin_write32(MDMA_D0_NEXT_DESC_PTR)
+#define bfin_read_MDMA_D0_START_ADDR() 		bfin_read32(MDMA_D0_START_ADDR)
+#define bfin_write_MDMA_D0_START_ADDR(val) 	bfin_write32(MDMA_D0_START_ADDR)
+#define bfin_read_MDMA_D0_CONFIG()		bfin_read16(MDMA_D0_CONFIG)
+#define bfin_write_MDMA_D0_CONFIG(val)		bfin_write16(MDMA_D0_CONFIG, val)
+#define bfin_read_MDMA_D0_X_COUNT()		bfin_read16(MDMA_D0_X_COUNT)
+#define bfin_write_MDMA_D0_X_COUNT(val)		bfin_write16(MDMA_D0_X_COUNT, val)
+#define bfin_read_MDMA_D0_X_MODIFY()		bfin_read16(MDMA_D0_X_MODIFY)
+#define bfin_write_MDMA_D0_X_MODIFY(val) 	bfin_write16(MDMA_D0_X_MODIFY)
+#define bfin_read_MDMA_D0_Y_COUNT()		bfin_read16(MDMA_D0_Y_COUNT)
+#define bfin_write_MDMA_D0_Y_COUNT(val)		bfin_write16(MDMA_D0_Y_COUNT, val)
+#define bfin_read_MDMA_D0_Y_MODIFY()		bfin_read16(MDMA_D0_Y_MODIFY)
+#define bfin_write_MDMA_D0_Y_MODIFY(val) 	bfin_write16(MDMA_D0_Y_MODIFY)
+#define bfin_read_MDMA_D0_CURR_DESC_PTR() 	bfin_read32(MDMA_D0_CURR_DESC_PTR)
+#define bfin_write_MDMA_D0_CURR_DESC_PTR(val) 	bfin_write32(MDMA_D0_CURR_DESC_PTR)
+#define bfin_read_MDMA_D0_CURR_ADDR() 		bfin_read32(MDMA_D0_CURR_ADDR)
+#define bfin_write_MDMA_D0_CURR_ADDR(val) 	bfin_write32(MDMA_D0_CURR_ADDR)
+#define bfin_read_MDMA_D0_IRQ_STATUS()		bfin_read16(MDMA_D0_IRQ_STATUS)
+#define bfin_write_MDMA_D0_IRQ_STATUS(val)	bfin_write16(MDMA_D0_IRQ_STATUS, val)
+#define bfin_read_MDMA_D0_PERIPHERAL_MAP()	bfin_read16(MDMA_D0_PERIPHERAL_MAP)
+#define bfin_write_MDMA_D0_PERIPHERAL_MAP(val)	bfin_write16(MDMA_D0_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_D0_CURR_X_COUNT()	bfin_read16(MDMA_D0_CURR_X_COUNT)
+#define bfin_write_MDMA_D0_CURR_X_COUNT(val)	bfin_write16(MDMA_D0_CURR_X_COUNT, val)
+#define bfin_read_MDMA_D0_CURR_Y_COUNT()	bfin_read16(MDMA_D0_CURR_Y_COUNT)
+#define bfin_write_MDMA_D0_CURR_Y_COUNT(val)	bfin_write16(MDMA_D0_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_S0_NEXT_DESC_PTR() 	bfin_read32(MDMA_S0_NEXT_DESC_PTR)
+#define bfin_write_MDMA_S0_NEXT_DESC_PTR(val) 	bfin_write32(MDMA_S0_NEXT_DESC_PTR)
+#define bfin_read_MDMA_S0_START_ADDR() 		bfin_read32(MDMA_S0_START_ADDR)
+#define bfin_write_MDMA_S0_START_ADDR(val) 	bfin_write32(MDMA_S0_START_ADDR)
+#define bfin_read_MDMA_S0_CONFIG()		bfin_read16(MDMA_S0_CONFIG)
+#define bfin_write_MDMA_S0_CONFIG(val)		bfin_write16(MDMA_S0_CONFIG, val)
+#define bfin_read_MDMA_S0_X_COUNT()		bfin_read16(MDMA_S0_X_COUNT)
+#define bfin_write_MDMA_S0_X_COUNT(val)		bfin_write16(MDMA_S0_X_COUNT, val)
+#define bfin_read_MDMA_S0_X_MODIFY()		bfin_read16(MDMA_S0_X_MODIFY)
+#define bfin_write_MDMA_S0_X_MODIFY(val) 	bfin_write16(MDMA_S0_X_MODIFY)
+#define bfin_read_MDMA_S0_Y_COUNT()		bfin_read16(MDMA_S0_Y_COUNT)
+#define bfin_write_MDMA_S0_Y_COUNT(val)		bfin_write16(MDMA_S0_Y_COUNT, val)
+#define bfin_read_MDMA_S0_Y_MODIFY()		bfin_read16(MDMA_S0_Y_MODIFY)
+#define bfin_write_MDMA_S0_Y_MODIFY(val) 	bfin_write16(MDMA_S0_Y_MODIFY)
+#define bfin_read_MDMA_S0_CURR_DESC_PTR() 	bfin_read32(MDMA_S0_CURR_DESC_PTR)
+#define bfin_write_MDMA_S0_CURR_DESC_PTR(val) 	bfin_write32(MDMA_S0_CURR_DESC_PTR)
+#define bfin_read_MDMA_S0_CURR_ADDR() 		bfin_read32(MDMA_S0_CURR_ADDR)
+#define bfin_write_MDMA_S0_CURR_ADDR(val) 	bfin_write32(MDMA_S0_CURR_ADDR)
+#define bfin_read_MDMA_S0_IRQ_STATUS()		bfin_read16(MDMA_S0_IRQ_STATUS)
+#define bfin_write_MDMA_S0_IRQ_STATUS(val)	bfin_write16(MDMA_S0_IRQ_STATUS, val)
+#define bfin_read_MDMA_S0_PERIPHERAL_MAP()	bfin_read16(MDMA_S0_PERIPHERAL_MAP)
+#define bfin_write_MDMA_S0_PERIPHERAL_MAP(val)	bfin_write16(MDMA_S0_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_S0_CURR_X_COUNT()	bfin_read16(MDMA_S0_CURR_X_COUNT)
+#define bfin_write_MDMA_S0_CURR_X_COUNT(val)	bfin_write16(MDMA_S0_CURR_X_COUNT, val)
+#define bfin_read_MDMA_S0_CURR_Y_COUNT()	bfin_read16(MDMA_S0_CURR_Y_COUNT)
+#define bfin_write_MDMA_S0_CURR_Y_COUNT(val)	bfin_write16(MDMA_S0_CURR_Y_COUNT, val)
+
+/* MDMA Stream 1 Registers */
+
+#define bfin_read_MDMA_D1_NEXT_DESC_PTR() 	bfin_read32(MDMA_D1_NEXT_DESC_PTR)
+#define bfin_write_MDMA_D1_NEXT_DESC_PTR(val) 	bfin_write32(MDMA_D1_NEXT_DESC_PTR)
+#define bfin_read_MDMA_D1_START_ADDR() 		bfin_read32(MDMA_D1_START_ADDR)
+#define bfin_write_MDMA_D1_START_ADDR(val) 	bfin_write32(MDMA_D1_START_ADDR)
+#define bfin_read_MDMA_D1_CONFIG()		bfin_read16(MDMA_D1_CONFIG)
+#define bfin_write_MDMA_D1_CONFIG(val)		bfin_write16(MDMA_D1_CONFIG, val)
+#define bfin_read_MDMA_D1_X_COUNT()		bfin_read16(MDMA_D1_X_COUNT)
+#define bfin_write_MDMA_D1_X_COUNT(val)		bfin_write16(MDMA_D1_X_COUNT, val)
+#define bfin_read_MDMA_D1_X_MODIFY()		bfin_read16(MDMA_D1_X_MODIFY)
+#define bfin_write_MDMA_D1_X_MODIFY(val) 	bfin_write16(MDMA_D1_X_MODIFY)
+#define bfin_read_MDMA_D1_Y_COUNT()		bfin_read16(MDMA_D1_Y_COUNT)
+#define bfin_write_MDMA_D1_Y_COUNT(val)		bfin_write16(MDMA_D1_Y_COUNT, val)
+#define bfin_read_MDMA_D1_Y_MODIFY()		bfin_read16(MDMA_D1_Y_MODIFY)
+#define bfin_write_MDMA_D1_Y_MODIFY(val) 	bfin_write16(MDMA_D1_Y_MODIFY)
+#define bfin_read_MDMA_D1_CURR_DESC_PTR() 	bfin_read32(MDMA_D1_CURR_DESC_PTR)
+#define bfin_write_MDMA_D1_CURR_DESC_PTR(val) 	bfin_write32(MDMA_D1_CURR_DESC_PTR)
+#define bfin_read_MDMA_D1_CURR_ADDR() 		bfin_read32(MDMA_D1_CURR_ADDR)
+#define bfin_write_MDMA_D1_CURR_ADDR(val) 	bfin_write32(MDMA_D1_CURR_ADDR)
+#define bfin_read_MDMA_D1_IRQ_STATUS()		bfin_read16(MDMA_D1_IRQ_STATUS)
+#define bfin_write_MDMA_D1_IRQ_STATUS(val)	bfin_write16(MDMA_D1_IRQ_STATUS, val)
+#define bfin_read_MDMA_D1_PERIPHERAL_MAP()	bfin_read16(MDMA_D1_PERIPHERAL_MAP)
+#define bfin_write_MDMA_D1_PERIPHERAL_MAP(val)	bfin_write16(MDMA_D1_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_D1_CURR_X_COUNT()	bfin_read16(MDMA_D1_CURR_X_COUNT)
+#define bfin_write_MDMA_D1_CURR_X_COUNT(val)	bfin_write16(MDMA_D1_CURR_X_COUNT, val)
+#define bfin_read_MDMA_D1_CURR_Y_COUNT()	bfin_read16(MDMA_D1_CURR_Y_COUNT)
+#define bfin_write_MDMA_D1_CURR_Y_COUNT(val)	bfin_write16(MDMA_D1_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_S1_NEXT_DESC_PTR() 	bfin_read32(MDMA_S1_NEXT_DESC_PTR)
+#define bfin_write_MDMA_S1_NEXT_DESC_PTR(val) 	bfin_write32(MDMA_S1_NEXT_DESC_PTR)
+#define bfin_read_MDMA_S1_START_ADDR() 		bfin_read32(MDMA_S1_START_ADDR)
+#define bfin_write_MDMA_S1_START_ADDR(val) 	bfin_write32(MDMA_S1_START_ADDR)
+#define bfin_read_MDMA_S1_CONFIG()		bfin_read16(MDMA_S1_CONFIG)
+#define bfin_write_MDMA_S1_CONFIG(val)		bfin_write16(MDMA_S1_CONFIG, val)
+#define bfin_read_MDMA_S1_X_COUNT()		bfin_read16(MDMA_S1_X_COUNT)
+#define bfin_write_MDMA_S1_X_COUNT(val)		bfin_write16(MDMA_S1_X_COUNT, val)
+#define bfin_read_MDMA_S1_X_MODIFY()		bfin_read16(MDMA_S1_X_MODIFY)
+#define bfin_write_MDMA_S1_X_MODIFY(val) 	bfin_write16(MDMA_S1_X_MODIFY)
+#define bfin_read_MDMA_S1_Y_COUNT()		bfin_read16(MDMA_S1_Y_COUNT)
+#define bfin_write_MDMA_S1_Y_COUNT(val)		bfin_write16(MDMA_S1_Y_COUNT, val)
+#define bfin_read_MDMA_S1_Y_MODIFY()		bfin_read16(MDMA_S1_Y_MODIFY)
+#define bfin_write_MDMA_S1_Y_MODIFY(val) 	bfin_write16(MDMA_S1_Y_MODIFY)
+#define bfin_read_MDMA_S1_CURR_DESC_PTR() 	bfin_read32(MDMA_S1_CURR_DESC_PTR)
+#define bfin_write_MDMA_S1_CURR_DESC_PTR(val) 	bfin_write32(MDMA_S1_CURR_DESC_PTR)
+#define bfin_read_MDMA_S1_CURR_ADDR() 		bfin_read32(MDMA_S1_CURR_ADDR)
+#define bfin_write_MDMA_S1_CURR_ADDR(val) 	bfin_write32(MDMA_S1_CURR_ADDR)
+#define bfin_read_MDMA_S1_IRQ_STATUS()		bfin_read16(MDMA_S1_IRQ_STATUS)
+#define bfin_write_MDMA_S1_IRQ_STATUS(val)	bfin_write16(MDMA_S1_IRQ_STATUS, val)
+#define bfin_read_MDMA_S1_PERIPHERAL_MAP()	bfin_read16(MDMA_S1_PERIPHERAL_MAP)
+#define bfin_write_MDMA_S1_PERIPHERAL_MAP(val)	bfin_write16(MDMA_S1_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_S1_CURR_X_COUNT()	bfin_read16(MDMA_S1_CURR_X_COUNT)
+#define bfin_write_MDMA_S1_CURR_X_COUNT(val)	bfin_write16(MDMA_S1_CURR_X_COUNT, val)
+#define bfin_read_MDMA_S1_CURR_Y_COUNT()	bfin_read16(MDMA_S1_CURR_Y_COUNT)
+#define bfin_write_MDMA_S1_CURR_Y_COUNT(val)	bfin_write16(MDMA_S1_CURR_Y_COUNT, val)
+
+/* EPPI1 Registers */
+
+#define bfin_read_EPPI1_STATUS()		bfin_read16(EPPI1_STATUS)
+#define bfin_write_EPPI1_STATUS(val)		bfin_write16(EPPI1_STATUS, val)
+#define bfin_read_EPPI1_HCOUNT()		bfin_read16(EPPI1_HCOUNT)
+#define bfin_write_EPPI1_HCOUNT(val)		bfin_write16(EPPI1_HCOUNT, val)
+#define bfin_read_EPPI1_HDELAY()		bfin_read16(EPPI1_HDELAY)
+#define bfin_write_EPPI1_HDELAY(val)		bfin_write16(EPPI1_HDELAY, val)
+#define bfin_read_EPPI1_VCOUNT()		bfin_read16(EPPI1_VCOUNT)
+#define bfin_write_EPPI1_VCOUNT(val)		bfin_write16(EPPI1_VCOUNT, val)
+#define bfin_read_EPPI1_VDELAY()		bfin_read16(EPPI1_VDELAY)
+#define bfin_write_EPPI1_VDELAY(val)		bfin_write16(EPPI1_VDELAY, val)
+#define bfin_read_EPPI1_FRAME()			bfin_read16(EPPI1_FRAME)
+#define bfin_write_EPPI1_FRAME(val)		bfin_write16(EPPI1_FRAME, val)
+#define bfin_read_EPPI1_LINE()			bfin_read16(EPPI1_LINE)
+#define bfin_write_EPPI1_LINE(val)		bfin_write16(EPPI1_LINE, val)
+#define bfin_read_EPPI1_CLKDIV()		bfin_read16(EPPI1_CLKDIV)
+#define bfin_write_EPPI1_CLKDIV(val)		bfin_write16(EPPI1_CLKDIV, val)
+#define bfin_read_EPPI1_CONTROL()		bfin_read32(EPPI1_CONTROL)
+#define bfin_write_EPPI1_CONTROL(val)		bfin_write32(EPPI1_CONTROL, val)
+#define bfin_read_EPPI1_FS1W_HBL()		bfin_read32(EPPI1_FS1W_HBL)
+#define bfin_write_EPPI1_FS1W_HBL(val)		bfin_write32(EPPI1_FS1W_HBL, val)
+#define bfin_read_EPPI1_FS1P_AVPL()		bfin_read32(EPPI1_FS1P_AVPL)
+#define bfin_write_EPPI1_FS1P_AVPL(val)		bfin_write32(EPPI1_FS1P_AVPL, val)
+#define bfin_read_EPPI1_FS2W_LVB()		bfin_read32(EPPI1_FS2W_LVB)
+#define bfin_write_EPPI1_FS2W_LVB(val)		bfin_write32(EPPI1_FS2W_LVB, val)
+#define bfin_read_EPPI1_FS2P_LAVF()		bfin_read32(EPPI1_FS2P_LAVF)
+#define bfin_write_EPPI1_FS2P_LAVF(val)		bfin_write32(EPPI1_FS2P_LAVF, val)
+#define bfin_read_EPPI1_CLIP()			bfin_read32(EPPI1_CLIP)
+#define bfin_write_EPPI1_CLIP(val)		bfin_write32(EPPI1_CLIP, val)
+
+/* Port Interrubfin_read_()t 0 Registers (32-bit) */
+
+#define bfin_read_PINT0_MASK_SET()		bfin_read32(PINT0_MASK_SET)
+#define bfin_write_PINT0_MASK_SET(val)		bfin_write32(PINT0_MASK_SET, val)
+#define bfin_read_PINT0_MASK_CLEAR()		bfin_read32(PINT0_MASK_CLEAR)
+#define bfin_write_PINT0_MASK_CLEAR(val)	bfin_write32(PINT0_MASK_CLEAR, val)
+#define bfin_read_PINT0_REQUEST()		bfin_read32(PINT0_REQUEST)
+#define bfin_write_PINT0_REQUEST(val)		bfin_write32(PINT0_REQUEST, val)
+#define bfin_read_PINT0_ASSIGN()		bfin_read32(PINT0_ASSIGN)
+#define bfin_write_PINT0_ASSIGN(val)		bfin_write32(PINT0_ASSIGN, val)
+#define bfin_read_PINT0_EDGE_SET()		bfin_read32(PINT0_EDGE_SET)
+#define bfin_write_PINT0_EDGE_SET(val)		bfin_write32(PINT0_EDGE_SET, val)
+#define bfin_read_PINT0_EDGE_CLEAR()		bfin_read32(PINT0_EDGE_CLEAR)
+#define bfin_write_PINT0_EDGE_CLEAR(val)	bfin_write32(PINT0_EDGE_CLEAR, val)
+#define bfin_read_PINT0_INVERT_SET()		bfin_read32(PINT0_INVERT_SET)
+#define bfin_write_PINT0_INVERT_SET(val)	bfin_write32(PINT0_INVERT_SET, val)
+#define bfin_read_PINT0_INVERT_CLEAR()		bfin_read32(PINT0_INVERT_CLEAR)
+#define bfin_write_PINT0_INVERT_CLEAR(val)	bfin_write32(PINT0_INVERT_CLEAR, val)
+#define bfin_read_PINT0_PINSTATE()		bfin_read32(PINT0_PINSTATE)
+#define bfin_write_PINT0_PINSTATE(val)		bfin_write32(PINT0_PINSTATE, val)
+#define bfin_read_PINT0_LATCH()			bfin_read32(PINT0_LATCH)
+#define bfin_write_PINT0_LATCH(val)		bfin_write32(PINT0_LATCH, val)
+
+/* Port Interrubfin_read_()t 1 Registers (32-bit) */
+
+#define bfin_read_PINT1_MASK_SET()		bfin_read32(PINT1_MASK_SET)
+#define bfin_write_PINT1_MASK_SET(val)		bfin_write32(PINT1_MASK_SET, val)
+#define bfin_read_PINT1_MASK_CLEAR()		bfin_read32(PINT1_MASK_CLEAR)
+#define bfin_write_PINT1_MASK_CLEAR(val)	bfin_write32(PINT1_MASK_CLEAR, val)
+#define bfin_read_PINT1_REQUEST()		bfin_read32(PINT1_REQUEST)
+#define bfin_write_PINT1_REQUEST(val)		bfin_write32(PINT1_REQUEST, val)
+#define bfin_read_PINT1_ASSIGN()		bfin_read32(PINT1_ASSIGN)
+#define bfin_write_PINT1_ASSIGN(val)		bfin_write32(PINT1_ASSIGN, val)
+#define bfin_read_PINT1_EDGE_SET()		bfin_read32(PINT1_EDGE_SET)
+#define bfin_write_PINT1_EDGE_SET(val)		bfin_write32(PINT1_EDGE_SET, val)
+#define bfin_read_PINT1_EDGE_CLEAR()		bfin_read32(PINT1_EDGE_CLEAR)
+#define bfin_write_PINT1_EDGE_CLEAR(val)	bfin_write32(PINT1_EDGE_CLEAR, val)
+#define bfin_read_PINT1_INVERT_SET()		bfin_read32(PINT1_INVERT_SET)
+#define bfin_write_PINT1_INVERT_SET(val)	bfin_write32(PINT1_INVERT_SET, val)
+#define bfin_read_PINT1_INVERT_CLEAR()		bfin_read32(PINT1_INVERT_CLEAR)
+#define bfin_write_PINT1_INVERT_CLEAR(val)	bfin_write32(PINT1_INVERT_CLEAR, val)
+#define bfin_read_PINT1_PINSTATE()		bfin_read32(PINT1_PINSTATE)
+#define bfin_write_PINT1_PINSTATE(val)		bfin_write32(PINT1_PINSTATE, val)
+#define bfin_read_PINT1_LATCH()			bfin_read32(PINT1_LATCH)
+#define bfin_write_PINT1_LATCH(val)		bfin_write32(PINT1_LATCH, val)
+
+/* Port Interrubfin_read_()t 2 Registers (32-bit) */
+
+#define bfin_read_PINT2_MASK_SET()		bfin_read32(PINT2_MASK_SET)
+#define bfin_write_PINT2_MASK_SET(val)		bfin_write32(PINT2_MASK_SET, val)
+#define bfin_read_PINT2_MASK_CLEAR()		bfin_read32(PINT2_MASK_CLEAR)
+#define bfin_write_PINT2_MASK_CLEAR(val)	bfin_write32(PINT2_MASK_CLEAR, val)
+#define bfin_read_PINT2_REQUEST()		bfin_read32(PINT2_REQUEST)
+#define bfin_write_PINT2_REQUEST(val)		bfin_write32(PINT2_REQUEST, val)
+#define bfin_read_PINT2_ASSIGN()		bfin_read32(PINT2_ASSIGN)
+#define bfin_write_PINT2_ASSIGN(val)		bfin_write32(PINT2_ASSIGN, val)
+#define bfin_read_PINT2_EDGE_SET()		bfin_read32(PINT2_EDGE_SET)
+#define bfin_write_PINT2_EDGE_SET(val)		bfin_write32(PINT2_EDGE_SET, val)
+#define bfin_read_PINT2_EDGE_CLEAR()		bfin_read32(PINT2_EDGE_CLEAR)
+#define bfin_write_PINT2_EDGE_CLEAR(val)	bfin_write32(PINT2_EDGE_CLEAR, val)
+#define bfin_read_PINT2_INVERT_SET()		bfin_read32(PINT2_INVERT_SET)
+#define bfin_write_PINT2_INVERT_SET(val)	bfin_write32(PINT2_INVERT_SET, val)
+#define bfin_read_PINT2_INVERT_CLEAR()		bfin_read32(PINT2_INVERT_CLEAR)
+#define bfin_write_PINT2_INVERT_CLEAR(val)	bfin_write32(PINT2_INVERT_CLEAR, val)
+#define bfin_read_PINT2_PINSTATE()		bfin_read32(PINT2_PINSTATE)
+#define bfin_write_PINT2_PINSTATE(val)		bfin_write32(PINT2_PINSTATE, val)
+#define bfin_read_PINT2_LATCH()			bfin_read32(PINT2_LATCH)
+#define bfin_write_PINT2_LATCH(val)		bfin_write32(PINT2_LATCH, val)
+
+/* Port Interrubfin_read_()t 3 Registers (32-bit) */
+
+#define bfin_read_PINT3_MASK_SET()		bfin_read32(PINT3_MASK_SET)
+#define bfin_write_PINT3_MASK_SET(val)		bfin_write32(PINT3_MASK_SET, val)
+#define bfin_read_PINT3_MASK_CLEAR()		bfin_read32(PINT3_MASK_CLEAR)
+#define bfin_write_PINT3_MASK_CLEAR(val)	bfin_write32(PINT3_MASK_CLEAR, val)
+#define bfin_read_PINT3_REQUEST()		bfin_read32(PINT3_REQUEST)
+#define bfin_write_PINT3_REQUEST(val)		bfin_write32(PINT3_REQUEST, val)
+#define bfin_read_PINT3_ASSIGN()		bfin_read32(PINT3_ASSIGN)
+#define bfin_write_PINT3_ASSIGN(val)		bfin_write32(PINT3_ASSIGN, val)
+#define bfin_read_PINT3_EDGE_SET()		bfin_read32(PINT3_EDGE_SET)
+#define bfin_write_PINT3_EDGE_SET(val)		bfin_write32(PINT3_EDGE_SET, val)
+#define bfin_read_PINT3_EDGE_CLEAR()		bfin_read32(PINT3_EDGE_CLEAR)
+#define bfin_write_PINT3_EDGE_CLEAR(val)	bfin_write32(PINT3_EDGE_CLEAR, val)
+#define bfin_read_PINT3_INVERT_SET()		bfin_read32(PINT3_INVERT_SET)
+#define bfin_write_PINT3_INVERT_SET(val)	bfin_write32(PINT3_INVERT_SET, val)
+#define bfin_read_PINT3_INVERT_CLEAR()		bfin_read32(PINT3_INVERT_CLEAR)
+#define bfin_write_PINT3_INVERT_CLEAR(val)	bfin_write32(PINT3_INVERT_CLEAR, val)
+#define bfin_read_PINT3_PINSTATE()		bfin_read32(PINT3_PINSTATE)
+#define bfin_write_PINT3_PINSTATE(val)		bfin_write32(PINT3_PINSTATE, val)
+#define bfin_read_PINT3_LATCH()			bfin_read32(PINT3_LATCH)
+#define bfin_write_PINT3_LATCH(val)		bfin_write32(PINT3_LATCH, val)
+
+/* Port A Registers */
+
+#define bfin_read_PORTA_FER()		bfin_read16(PORTA_FER)
+#define bfin_write_PORTA_FER(val)	bfin_write16(PORTA_FER, val)
+#define bfin_read_PORTA()		bfin_read16(PORTA)
+#define bfin_write_PORTA(val)		bfin_write16(PORTA, val)
+#define bfin_read_PORTA_SET()		bfin_read16(PORTA_SET)
+#define bfin_write_PORTA_SET(val)	bfin_write16(PORTA_SET, val)
+#define bfin_read_PORTA_CLEAR()		bfin_read16(PORTA_CLEAR)
+#define bfin_write_PORTA_CLEAR(val)	bfin_write16(PORTA_CLEAR, val)
+#define bfin_read_PORTA_DIR_SET()	bfin_read16(PORTA_DIR_SET)
+#define bfin_write_PORTA_DIR_SET(val)	bfin_write16(PORTA_DIR_SET, val)
+#define bfin_read_PORTA_DIR_CLEAR()	bfin_read16(PORTA_DIR_CLEAR)
+#define bfin_write_PORTA_DIR_CLEAR(val)	bfin_write16(PORTA_DIR_CLEAR, val)
+#define bfin_read_PORTA_INEN()		bfin_read16(PORTA_INEN)
+#define bfin_write_PORTA_INEN(val)	bfin_write16(PORTA_INEN, val)
+#define bfin_read_PORTA_MUX()		bfin_read32(PORTA_MUX)
+#define bfin_write_PORTA_MUX(val)	bfin_write32(PORTA_MUX, val)
+
+/* Port B Registers */
+
+#define bfin_read_PORTB_FER()		bfin_read16(PORTB_FER)
+#define bfin_write_PORTB_FER(val)	bfin_write16(PORTB_FER, val)
+#define bfin_read_PORTB()		bfin_read16(PORTB)
+#define bfin_write_PORTB(val)		bfin_write16(PORTB, val)
+#define bfin_read_PORTB_SET()		bfin_read16(PORTB_SET)
+#define bfin_write_PORTB_SET(val)	bfin_write16(PORTB_SET, val)
+#define bfin_read_PORTB_CLEAR()		bfin_read16(PORTB_CLEAR)
+#define bfin_write_PORTB_CLEAR(val)	bfin_write16(PORTB_CLEAR, val)
+#define bfin_read_PORTB_DIR_SET()	bfin_read16(PORTB_DIR_SET)
+#define bfin_write_PORTB_DIR_SET(val)	bfin_write16(PORTB_DIR_SET, val)
+#define bfin_read_PORTB_DIR_CLEAR()	bfin_read16(PORTB_DIR_CLEAR)
+#define bfin_write_PORTB_DIR_CLEAR(val)	bfin_write16(PORTB_DIR_CLEAR, val)
+#define bfin_read_PORTB_INEN()		bfin_read16(PORTB_INEN)
+#define bfin_write_PORTB_INEN(val)	bfin_write16(PORTB_INEN, val)
+#define bfin_read_PORTB_MUX()		bfin_read32(PORTB_MUX)
+#define bfin_write_PORTB_MUX(val)	bfin_write32(PORTB_MUX, val)
+
+/* Port C Registers */
+
+#define bfin_read_PORTC_FER()		bfin_read16(PORTC_FER)
+#define bfin_write_PORTC_FER(val)	bfin_write16(PORTC_FER, val)
+#define bfin_read_PORTC()		bfin_read16(PORTC)
+#define bfin_write_PORTC(val)		bfin_write16(PORTC, val)
+#define bfin_read_PORTC_SET()		bfin_read16(PORTC_SET)
+#define bfin_write_PORTC_SET(val)	bfin_write16(PORTC_SET, val)
+#define bfin_read_PORTC_CLEAR()		bfin_read16(PORTC_CLEAR)
+#define bfin_write_PORTC_CLEAR(val)	bfin_write16(PORTC_CLEAR, val)
+#define bfin_read_PORTC_DIR_SET()	bfin_read16(PORTC_DIR_SET)
+#define bfin_write_PORTC_DIR_SET(val)	bfin_write16(PORTC_DIR_SET, val)
+#define bfin_read_PORTC_DIR_CLEAR()	bfin_read16(PORTC_DIR_CLEAR)
+#define bfin_write_PORTC_DIR_CLEAR(val)	bfin_write16(PORTC_DIR_CLEAR, val)
+#define bfin_read_PORTC_INEN()		bfin_read16(PORTC_INEN)
+#define bfin_write_PORTC_INEN(val)	bfin_write16(PORTC_INEN, val)
+#define bfin_read_PORTC_MUX()		bfin_read32(PORTC_MUX)
+#define bfin_write_PORTC_MUX(val)	bfin_write32(PORTC_MUX, val)
+
+/* Port D Registers */
+
+#define bfin_read_PORTD_FER()		bfin_read16(PORTD_FER)
+#define bfin_write_PORTD_FER(val)	bfin_write16(PORTD_FER, val)
+#define bfin_read_PORTD()		bfin_read16(PORTD)
+#define bfin_write_PORTD(val)		bfin_write16(PORTD, val)
+#define bfin_read_PORTD_SET()		bfin_read16(PORTD_SET)
+#define bfin_write_PORTD_SET(val)	bfin_write16(PORTD_SET, val)
+#define bfin_read_PORTD_CLEAR()		bfin_read16(PORTD_CLEAR)
+#define bfin_write_PORTD_CLEAR(val)	bfin_write16(PORTD_CLEAR, val)
+#define bfin_read_PORTD_DIR_SET()	bfin_read16(PORTD_DIR_SET)
+#define bfin_write_PORTD_DIR_SET(val)	bfin_write16(PORTD_DIR_SET, val)
+#define bfin_read_PORTD_DIR_CLEAR()	bfin_read16(PORTD_DIR_CLEAR)
+#define bfin_write_PORTD_DIR_CLEAR(val)	bfin_write16(PORTD_DIR_CLEAR, val)
+#define bfin_read_PORTD_INEN()		bfin_read16(PORTD_INEN)
+#define bfin_write_PORTD_INEN(val)	bfin_write16(PORTD_INEN, val)
+#define bfin_read_PORTD_MUX()		bfin_read32(PORTD_MUX)
+#define bfin_write_PORTD_MUX(val)	bfin_write32(PORTD_MUX, val)
+
+/* Port E Registers */
+
+#define bfin_read_PORTE_FER()		bfin_read16(PORTE_FER)
+#define bfin_write_PORTE_FER(val)	bfin_write16(PORTE_FER, val)
+#define bfin_read_PORTE()		bfin_read16(PORTE)
+#define bfin_write_PORTE(val)		bfin_write16(PORTE, val)
+#define bfin_read_PORTE_SET()		bfin_read16(PORTE_SET)
+#define bfin_write_PORTE_SET(val)	bfin_write16(PORTE_SET, val)
+#define bfin_read_PORTE_CLEAR()		bfin_read16(PORTE_CLEAR)
+#define bfin_write_PORTE_CLEAR(val)	bfin_write16(PORTE_CLEAR, val)
+#define bfin_read_PORTE_DIR_SET()	bfin_read16(PORTE_DIR_SET)
+#define bfin_write_PORTE_DIR_SET(val)	bfin_write16(PORTE_DIR_SET, val)
+#define bfin_read_PORTE_DIR_CLEAR()	bfin_read16(PORTE_DIR_CLEAR)
+#define bfin_write_PORTE_DIR_CLEAR(val)	bfin_write16(PORTE_DIR_CLEAR, val)
+#define bfin_read_PORTE_INEN()		bfin_read16(PORTE_INEN)
+#define bfin_write_PORTE_INEN(val)	bfin_write16(PORTE_INEN, val)
+#define bfin_read_PORTE_MUX()		bfin_read32(PORTE_MUX)
+#define bfin_write_PORTE_MUX(val)	bfin_write32(PORTE_MUX, val)
+
+/* Port F Registers */
+
+#define bfin_read_PORTF_FER()		bfin_read16(PORTF_FER)
+#define bfin_write_PORTF_FER(val)	bfin_write16(PORTF_FER, val)
+#define bfin_read_PORTF()		bfin_read16(PORTF)
+#define bfin_write_PORTF(val)		bfin_write16(PORTF, val)
+#define bfin_read_PORTF_SET()		bfin_read16(PORTF_SET)
+#define bfin_write_PORTF_SET(val)	bfin_write16(PORTF_SET, val)
+#define bfin_read_PORTF_CLEAR()		bfin_read16(PORTF_CLEAR)
+#define bfin_write_PORTF_CLEAR(val)	bfin_write16(PORTF_CLEAR, val)
+#define bfin_read_PORTF_DIR_SET()	bfin_read16(PORTF_DIR_SET)
+#define bfin_write_PORTF_DIR_SET(val)	bfin_write16(PORTF_DIR_SET, val)
+#define bfin_read_PORTF_DIR_CLEAR()	bfin_read16(PORTF_DIR_CLEAR)
+#define bfin_write_PORTF_DIR_CLEAR(val)	bfin_write16(PORTF_DIR_CLEAR, val)
+#define bfin_read_PORTF_INEN()		bfin_read16(PORTF_INEN)
+#define bfin_write_PORTF_INEN(val)	bfin_write16(PORTF_INEN, val)
+#define bfin_read_PORTF_MUX()		bfin_read32(PORTF_MUX)
+#define bfin_write_PORTF_MUX(val)	bfin_write32(PORTF_MUX, val)
+
+/* Port G Registers */
+
+#define bfin_read_PORTG_FER()		bfin_read16(PORTG_FER)
+#define bfin_write_PORTG_FER(val)	bfin_write16(PORTG_FER, val)
+#define bfin_read_PORTG()		bfin_read16(PORTG)
+#define bfin_write_PORTG(val)		bfin_write16(PORTG, val)
+#define bfin_read_PORTG_SET()		bfin_read16(PORTG_SET)
+#define bfin_write_PORTG_SET(val)	bfin_write16(PORTG_SET, val)
+#define bfin_read_PORTG_CLEAR()		bfin_read16(PORTG_CLEAR)
+#define bfin_write_PORTG_CLEAR(val)	bfin_write16(PORTG_CLEAR, val)
+#define bfin_read_PORTG_DIR_SET()	bfin_read16(PORTG_DIR_SET)
+#define bfin_write_PORTG_DIR_SET(val)	bfin_write16(PORTG_DIR_SET, val)
+#define bfin_read_PORTG_DIR_CLEAR()	bfin_read16(PORTG_DIR_CLEAR)
+#define bfin_write_PORTG_DIR_CLEAR(val)	bfin_write16(PORTG_DIR_CLEAR, val)
+#define bfin_read_PORTG_INEN()		bfin_read16(PORTG_INEN)
+#define bfin_write_PORTG_INEN(val)	bfin_write16(PORTG_INEN, val)
+#define bfin_read_PORTG_MUX()		bfin_read32(PORTG_MUX)
+#define bfin_write_PORTG_MUX(val)	bfin_write32(PORTG_MUX, val)
+
+/* Port H Registers */
+
+#define bfin_read_PORTH_FER()		bfin_read16(PORTH_FER)
+#define bfin_write_PORTH_FER(val)	bfin_write16(PORTH_FER, val)
+#define bfin_read_PORTH()		bfin_read16(PORTH)
+#define bfin_write_PORTH(val)		bfin_write16(PORTH, val)
+#define bfin_read_PORTH_SET()		bfin_read16(PORTH_SET)
+#define bfin_write_PORTH_SET(val)	bfin_write16(PORTH_SET, val)
+#define bfin_read_PORTH_CLEAR()		bfin_read16(PORTH_CLEAR)
+#define bfin_write_PORTH_CLEAR(val)	bfin_write16(PORTH_CLEAR, val)
+#define bfin_read_PORTH_DIR_SET()	bfin_read16(PORTH_DIR_SET)
+#define bfin_write_PORTH_DIR_SET(val)	bfin_write16(PORTH_DIR_SET, val)
+#define bfin_read_PORTH_DIR_CLEAR()	bfin_read16(PORTH_DIR_CLEAR)
+#define bfin_write_PORTH_DIR_CLEAR(val)	bfin_write16(PORTH_DIR_CLEAR, val)
+#define bfin_read_PORTH_INEN()		bfin_read16(PORTH_INEN)
+#define bfin_write_PORTH_INEN(val)	bfin_write16(PORTH_INEN, val)
+#define bfin_read_PORTH_MUX()		bfin_read32(PORTH_MUX)
+#define bfin_write_PORTH_MUX(val)	bfin_write32(PORTH_MUX, val)
+
+/* Port I Registers */
+
+#define bfin_read_PORTI_FER()		bfin_read16(PORTI_FER)
+#define bfin_write_PORTI_FER(val)	bfin_write16(PORTI_FER, val)
+#define bfin_read_PORTI()		bfin_read16(PORTI)
+#define bfin_write_PORTI(val)		bfin_write16(PORTI, val)
+#define bfin_read_PORTI_SET()		bfin_read16(PORTI_SET)
+#define bfin_write_PORTI_SET(val)	bfin_write16(PORTI_SET, val)
+#define bfin_read_PORTI_CLEAR()		bfin_read16(PORTI_CLEAR)
+#define bfin_write_PORTI_CLEAR(val)	bfin_write16(PORTI_CLEAR, val)
+#define bfin_read_PORTI_DIR_SET()	bfin_read16(PORTI_DIR_SET)
+#define bfin_write_PORTI_DIR_SET(val)	bfin_write16(PORTI_DIR_SET, val)
+#define bfin_read_PORTI_DIR_CLEAR()	bfin_read16(PORTI_DIR_CLEAR)
+#define bfin_write_PORTI_DIR_CLEAR(val)	bfin_write16(PORTI_DIR_CLEAR, val)
+#define bfin_read_PORTI_INEN()		bfin_read16(PORTI_INEN)
+#define bfin_write_PORTI_INEN(val)	bfin_write16(PORTI_INEN, val)
+#define bfin_read_PORTI_MUX()		bfin_read32(PORTI_MUX)
+#define bfin_write_PORTI_MUX(val)	bfin_write32(PORTI_MUX, val)
+
+/* Port J Registers */
+
+#define bfin_read_PORTJ_FER()		bfin_read16(PORTJ_FER)
+#define bfin_write_PORTJ_FER(val)	bfin_write16(PORTJ_FER, val)
+#define bfin_read_PORTJ()		bfin_read16(PORTJ)
+#define bfin_write_PORTJ(val)		bfin_write16(PORTJ, val)
+#define bfin_read_PORTJ_SET()		bfin_read16(PORTJ_SET)
+#define bfin_write_PORTJ_SET(val)	bfin_write16(PORTJ_SET, val)
+#define bfin_read_PORTJ_CLEAR()		bfin_read16(PORTJ_CLEAR)
+#define bfin_write_PORTJ_CLEAR(val)	bfin_write16(PORTJ_CLEAR, val)
+#define bfin_read_PORTJ_DIR_SET()	bfin_read16(PORTJ_DIR_SET)
+#define bfin_write_PORTJ_DIR_SET(val)	bfin_write16(PORTJ_DIR_SET, val)
+#define bfin_read_PORTJ_DIR_CLEAR()	bfin_read16(PORTJ_DIR_CLEAR)
+#define bfin_write_PORTJ_DIR_CLEAR(val)	bfin_write16(PORTJ_DIR_CLEAR, val)
+#define bfin_read_PORTJ_INEN()		bfin_read16(PORTJ_INEN)
+#define bfin_write_PORTJ_INEN(val)	bfin_write16(PORTJ_INEN, val)
+#define bfin_read_PORTJ_MUX()		bfin_read32(PORTJ_MUX)
+#define bfin_write_PORTJ_MUX(val)	bfin_write32(PORTJ_MUX, val)
+
+/* PWM Timer Registers */
+
+#define bfin_read_TIMER0_CONFIG()		bfin_read16(TIMER0_CONFIG)
+#define bfin_write_TIMER0_CONFIG(val)		bfin_write16(TIMER0_CONFIG, val)
+#define bfin_read_TIMER0_COUNTER()		bfin_read32(TIMER0_COUNTER)
+#define bfin_write_TIMER0_COUNTER(val)		bfin_write32(TIMER0_COUNTER, val)
+#define bfin_read_TIMER0_PERIOD()		bfin_read32(TIMER0_PERIOD)
+#define bfin_write_TIMER0_PERIOD(val)		bfin_write32(TIMER0_PERIOD, val)
+#define bfin_read_TIMER0_WIDTH()		bfin_read32(TIMER0_WIDTH)
+#define bfin_write_TIMER0_WIDTH(val)		bfin_write32(TIMER0_WIDTH, val)
+#define bfin_read_TIMER1_CONFIG()		bfin_read16(TIMER1_CONFIG)
+#define bfin_write_TIMER1_CONFIG(val)		bfin_write16(TIMER1_CONFIG, val)
+#define bfin_read_TIMER1_COUNTER()		bfin_read32(TIMER1_COUNTER)
+#define bfin_write_TIMER1_COUNTER(val)		bfin_write32(TIMER1_COUNTER, val)
+#define bfin_read_TIMER1_PERIOD()		bfin_read32(TIMER1_PERIOD)
+#define bfin_write_TIMER1_PERIOD(val)		bfin_write32(TIMER1_PERIOD, val)
+#define bfin_read_TIMER1_WIDTH()		bfin_read32(TIMER1_WIDTH)
+#define bfin_write_TIMER1_WIDTH(val)		bfin_write32(TIMER1_WIDTH, val)
+#define bfin_read_TIMER2_CONFIG()		bfin_read16(TIMER2_CONFIG)
+#define bfin_write_TIMER2_CONFIG(val)		bfin_write16(TIMER2_CONFIG, val)
+#define bfin_read_TIMER2_COUNTER()		bfin_read32(TIMER2_COUNTER)
+#define bfin_write_TIMER2_COUNTER(val)		bfin_write32(TIMER2_COUNTER, val)
+#define bfin_read_TIMER2_PERIOD()		bfin_read32(TIMER2_PERIOD)
+#define bfin_write_TIMER2_PERIOD(val)		bfin_write32(TIMER2_PERIOD, val)
+#define bfin_read_TIMER2_WIDTH()		bfin_read32(TIMER2_WIDTH)
+#define bfin_write_TIMER2_WIDTH(val)		bfin_write32(TIMER2_WIDTH, val)
+#define bfin_read_TIMER3_CONFIG()		bfin_read16(TIMER3_CONFIG)
+#define bfin_write_TIMER3_CONFIG(val)		bfin_write16(TIMER3_CONFIG, val)
+#define bfin_read_TIMER3_COUNTER()		bfin_read32(TIMER3_COUNTER)
+#define bfin_write_TIMER3_COUNTER(val)		bfin_write32(TIMER3_COUNTER, val)
+#define bfin_read_TIMER3_PERIOD()		bfin_read32(TIMER3_PERIOD)
+#define bfin_write_TIMER3_PERIOD(val)		bfin_write32(TIMER3_PERIOD, val)
+#define bfin_read_TIMER3_WIDTH()		bfin_read32(TIMER3_WIDTH)
+#define bfin_write_TIMER3_WIDTH(val)		bfin_write32(TIMER3_WIDTH, val)
+#define bfin_read_TIMER4_CONFIG()		bfin_read16(TIMER4_CONFIG)
+#define bfin_write_TIMER4_CONFIG(val)		bfin_write16(TIMER4_CONFIG, val)
+#define bfin_read_TIMER4_COUNTER()		bfin_read32(TIMER4_COUNTER)
+#define bfin_write_TIMER4_COUNTER(val)		bfin_write32(TIMER4_COUNTER, val)
+#define bfin_read_TIMER4_PERIOD()		bfin_read32(TIMER4_PERIOD)
+#define bfin_write_TIMER4_PERIOD(val)		bfin_write32(TIMER4_PERIOD, val)
+#define bfin_read_TIMER4_WIDTH()		bfin_read32(TIMER4_WIDTH)
+#define bfin_write_TIMER4_WIDTH(val)		bfin_write32(TIMER4_WIDTH, val)
+#define bfin_read_TIMER5_CONFIG()		bfin_read16(TIMER5_CONFIG)
+#define bfin_write_TIMER5_CONFIG(val)		bfin_write16(TIMER5_CONFIG, val)
+#define bfin_read_TIMER5_COUNTER()		bfin_read32(TIMER5_COUNTER)
+#define bfin_write_TIMER5_COUNTER(val)		bfin_write32(TIMER5_COUNTER, val)
+#define bfin_read_TIMER5_PERIOD()		bfin_read32(TIMER5_PERIOD)
+#define bfin_write_TIMER5_PERIOD(val)		bfin_write32(TIMER5_PERIOD, val)
+#define bfin_read_TIMER5_WIDTH()		bfin_read32(TIMER5_WIDTH)
+#define bfin_write_TIMER5_WIDTH(val)		bfin_write32(TIMER5_WIDTH, val)
+#define bfin_read_TIMER6_CONFIG()		bfin_read16(TIMER6_CONFIG)
+#define bfin_write_TIMER6_CONFIG(val)		bfin_write16(TIMER6_CONFIG, val)
+#define bfin_read_TIMER6_COUNTER()		bfin_read32(TIMER6_COUNTER)
+#define bfin_write_TIMER6_COUNTER(val)		bfin_write32(TIMER6_COUNTER, val)
+#define bfin_read_TIMER6_PERIOD()		bfin_read32(TIMER6_PERIOD)
+#define bfin_write_TIMER6_PERIOD(val)		bfin_write32(TIMER6_PERIOD, val)
+#define bfin_read_TIMER6_WIDTH()		bfin_read32(TIMER6_WIDTH)
+#define bfin_write_TIMER6_WIDTH(val)		bfin_write32(TIMER6_WIDTH, val)
+#define bfin_read_TIMER7_CONFIG()		bfin_read16(TIMER7_CONFIG)
+#define bfin_write_TIMER7_CONFIG(val)		bfin_write16(TIMER7_CONFIG, val)
+#define bfin_read_TIMER7_COUNTER()		bfin_read32(TIMER7_COUNTER)
+#define bfin_write_TIMER7_COUNTER(val)		bfin_write32(TIMER7_COUNTER, val)
+#define bfin_read_TIMER7_PERIOD()		bfin_read32(TIMER7_PERIOD)
+#define bfin_write_TIMER7_PERIOD(val)		bfin_write32(TIMER7_PERIOD, val)
+#define bfin_read_TIMER7_WIDTH()		bfin_read32(TIMER7_WIDTH)
+#define bfin_write_TIMER7_WIDTH(val)		bfin_write32(TIMER7_WIDTH, val)
+
+/* Timer Groubfin_read_() of 8 */
+
+#define bfin_read_TIMER_ENABLE0()		bfin_read16(TIMER_ENABLE0)
+#define bfin_write_TIMER_ENABLE0(val)		bfin_write16(TIMER_ENABLE0, val)
+#define bfin_read_TIMER_DISABLE0()		bfin_read16(TIMER_DISABLE0)
+#define bfin_write_TIMER_DISABLE0(val)		bfin_write16(TIMER_DISABLE0, val)
+#define bfin_read_TIMER_STATUS0()		bfin_read32(TIMER_STATUS0)
+#define bfin_write_TIMER_STATUS0(val)		bfin_write32(TIMER_STATUS0, val)
+
+/* DMAC1 Registers */
+
+#define bfin_read_DMAC1_TCPER()			bfin_read16(DMAC1_TCPER)
+#define bfin_write_DMAC1_TCPER(val)		bfin_write16(DMAC1_TCPER, val)
+#define bfin_read_DMAC1_TCCNT()			bfin_read16(DMAC1_TCCNT)
+#define bfin_write_DMAC1_TCCNT(val)		bfin_write16(DMAC1_TCCNT, val)
+
+/* DMA Channel 12 Registers */
+
+#define bfin_read_DMA12_NEXT_DESC_PTR() 	bfin_read32(DMA12_NEXT_DESC_PTR)
+#define bfin_write_DMA12_NEXT_DESC_PTR(val) 	bfin_write32(DMA12_NEXT_DESC_PTR)
+#define bfin_read_DMA12_START_ADDR() 		bfin_read32(DMA12_START_ADDR)
+#define bfin_write_DMA12_START_ADDR(val) 	bfin_write32(DMA12_START_ADDR)
+#define bfin_read_DMA12_CONFIG()		bfin_read16(DMA12_CONFIG)
+#define bfin_write_DMA12_CONFIG(val)		bfin_write16(DMA12_CONFIG, val)
+#define bfin_read_DMA12_X_COUNT()		bfin_read16(DMA12_X_COUNT)
+#define bfin_write_DMA12_X_COUNT(val)		bfin_write16(DMA12_X_COUNT, val)
+#define bfin_read_DMA12_X_MODIFY()		bfin_read16(DMA12_X_MODIFY)
+#define bfin_write_DMA12_X_MODIFY(val) 		bfin_write16(DMA12_X_MODIFY)
+#define bfin_read_DMA12_Y_COUNT()		bfin_read16(DMA12_Y_COUNT)
+#define bfin_write_DMA12_Y_COUNT(val)		bfin_write16(DMA12_Y_COUNT, val)
+#define bfin_read_DMA12_Y_MODIFY()		bfin_read16(DMA12_Y_MODIFY)
+#define bfin_write_DMA12_Y_MODIFY(val) 		bfin_write16(DMA12_Y_MODIFY)
+#define bfin_read_DMA12_CURR_DESC_PTR() 	bfin_read32(DMA12_CURR_DESC_PTR)
+#define bfin_write_DMA12_CURR_DESC_PTR(val) 	bfin_write32(DMA12_CURR_DESC_PTR)
+#define bfin_read_DMA12_CURR_ADDR() 		bfin_read32(DMA12_CURR_ADDR)
+#define bfin_write_DMA12_CURR_ADDR(val) 	bfin_write32(DMA12_CURR_ADDR)
+#define bfin_read_DMA12_IRQ_STATUS()		bfin_read16(DMA12_IRQ_STATUS)
+#define bfin_write_DMA12_IRQ_STATUS(val)	bfin_write16(DMA12_IRQ_STATUS, val)
+#define bfin_read_DMA12_PERIPHERAL_MAP()	bfin_read16(DMA12_PERIPHERAL_MAP)
+#define bfin_write_DMA12_PERIPHERAL_MAP(val)	bfin_write16(DMA12_PERIPHERAL_MAP, val)
+#define bfin_read_DMA12_CURR_X_COUNT()		bfin_read16(DMA12_CURR_X_COUNT)
+#define bfin_write_DMA12_CURR_X_COUNT(val)	bfin_write16(DMA12_CURR_X_COUNT, val)
+#define bfin_read_DMA12_CURR_Y_COUNT()		bfin_read16(DMA12_CURR_Y_COUNT)
+#define bfin_write_DMA12_CURR_Y_COUNT(val)	bfin_write16(DMA12_CURR_Y_COUNT, val)
+
+/* DMA Channel 13 Registers */
+
+#define bfin_read_DMA13_NEXT_DESC_PTR() 	bfin_read32(DMA13_NEXT_DESC_PTR)
+#define bfin_write_DMA13_NEXT_DESC_PTR(val) 	bfin_write32(DMA13_NEXT_DESC_PTR)
+#define bfin_read_DMA13_START_ADDR() 		bfin_read32(DMA13_START_ADDR)
+#define bfin_write_DMA13_START_ADDR(val) 	bfin_write32(DMA13_START_ADDR)
+#define bfin_read_DMA13_CONFIG()		bfin_read16(DMA13_CONFIG)
+#define bfin_write_DMA13_CONFIG(val)		bfin_write16(DMA13_CONFIG, val)
+#define bfin_read_DMA13_X_COUNT()		bfin_read16(DMA13_X_COUNT)
+#define bfin_write_DMA13_X_COUNT(val)		bfin_write16(DMA13_X_COUNT, val)
+#define bfin_read_DMA13_X_MODIFY()		bfin_read16(DMA13_X_MODIFY)
+#define bfin_write_DMA13_X_MODIFY(val) 		bfin_write16(DMA13_X_MODIFY)
+#define bfin_read_DMA13_Y_COUNT()		bfin_read16(DMA13_Y_COUNT)
+#define bfin_write_DMA13_Y_COUNT(val)		bfin_write16(DMA13_Y_COUNT, val)
+#define bfin_read_DMA13_Y_MODIFY()		bfin_read16(DMA13_Y_MODIFY)
+#define bfin_write_DMA13_Y_MODIFY(val) 		bfin_write16(DMA13_Y_MODIFY)
+#define bfin_read_DMA13_CURR_DESC_PTR() 	bfin_read32(DMA13_CURR_DESC_PTR)
+#define bfin_write_DMA13_CURR_DESC_PTR(val) 	bfin_write32(DMA13_CURR_DESC_PTR)
+#define bfin_read_DMA13_CURR_ADDR() 		bfin_read32(DMA13_CURR_ADDR)
+#define bfin_write_DMA13_CURR_ADDR(val) 	bfin_write32(DMA13_CURR_ADDR)
+#define bfin_read_DMA13_IRQ_STATUS()		bfin_read16(DMA13_IRQ_STATUS)
+#define bfin_write_DMA13_IRQ_STATUS(val)	bfin_write16(DMA13_IRQ_STATUS, val)
+#define bfin_read_DMA13_PERIPHERAL_MAP()	bfin_read16(DMA13_PERIPHERAL_MAP)
+#define bfin_write_DMA13_PERIPHERAL_MAP(val)	bfin_write16(DMA13_PERIPHERAL_MAP, val)
+#define bfin_read_DMA13_CURR_X_COUNT()		bfin_read16(DMA13_CURR_X_COUNT)
+#define bfin_write_DMA13_CURR_X_COUNT(val)	bfin_write16(DMA13_CURR_X_COUNT, val)
+#define bfin_read_DMA13_CURR_Y_COUNT()		bfin_read16(DMA13_CURR_Y_COUNT)
+#define bfin_write_DMA13_CURR_Y_COUNT(val)	bfin_write16(DMA13_CURR_Y_COUNT, val)
+
+/* DMA Channel 14 Registers */
+
+#define bfin_read_DMA14_NEXT_DESC_PTR() 	bfin_read32(DMA14_NEXT_DESC_PTR)
+#define bfin_write_DMA14_NEXT_DESC_PTR(val) 	bfin_write32(DMA14_NEXT_DESC_PTR)
+#define bfin_read_DMA14_START_ADDR() 		bfin_read32(DMA14_START_ADDR)
+#define bfin_write_DMA14_START_ADDR(val) 	bfin_write32(DMA14_START_ADDR)
+#define bfin_read_DMA14_CONFIG()		bfin_read16(DMA14_CONFIG)
+#define bfin_write_DMA14_CONFIG(val)		bfin_write16(DMA14_CONFIG, val)
+#define bfin_read_DMA14_X_COUNT()		bfin_read16(DMA14_X_COUNT)
+#define bfin_write_DMA14_X_COUNT(val)		bfin_write16(DMA14_X_COUNT, val)
+#define bfin_read_DMA14_X_MODIFY()		bfin_read16(DMA14_X_MODIFY)
+#define bfin_write_DMA14_X_MODIFY(val) 		bfin_write16(DMA14_X_MODIFY)
+#define bfin_read_DMA14_Y_COUNT()		bfin_read16(DMA14_Y_COUNT)
+#define bfin_write_DMA14_Y_COUNT(val)		bfin_write16(DMA14_Y_COUNT, val)
+#define bfin_read_DMA14_Y_MODIFY()		bfin_read16(DMA14_Y_MODIFY)
+#define bfin_write_DMA14_Y_MODIFY(val) 		bfin_write16(DMA14_Y_MODIFY)
+#define bfin_read_DMA14_CURR_DESC_PTR() 	bfin_read32(DMA14_CURR_DESC_PTR)
+#define bfin_write_DMA14_CURR_DESC_PTR(val) 	bfin_write32(DMA14_CURR_DESC_PTR)
+#define bfin_read_DMA14_CURR_ADDR() 		bfin_read32(DMA14_CURR_ADDR)
+#define bfin_write_DMA14_CURR_ADDR(val) 	bfin_write32(DMA14_CURR_ADDR)
+#define bfin_read_DMA14_IRQ_STATUS()		bfin_read16(DMA14_IRQ_STATUS)
+#define bfin_write_DMA14_IRQ_STATUS(val)	bfin_write16(DMA14_IRQ_STATUS, val)
+#define bfin_read_DMA14_PERIPHERAL_MAP()	bfin_read16(DMA14_PERIPHERAL_MAP)
+#define bfin_write_DMA14_PERIPHERAL_MAP(val)	bfin_write16(DMA14_PERIPHERAL_MAP, val)
+#define bfin_read_DMA14_CURR_X_COUNT()		bfin_read16(DMA14_CURR_X_COUNT)
+#define bfin_write_DMA14_CURR_X_COUNT(val)	bfin_write16(DMA14_CURR_X_COUNT, val)
+#define bfin_read_DMA14_CURR_Y_COUNT()		bfin_read16(DMA14_CURR_Y_COUNT)
+#define bfin_write_DMA14_CURR_Y_COUNT(val)	bfin_write16(DMA14_CURR_Y_COUNT, val)
+
+/* DMA Channel 15 Registers */
+
+#define bfin_read_DMA15_NEXT_DESC_PTR() 	bfin_read32(DMA15_NEXT_DESC_PTR)
+#define bfin_write_DMA15_NEXT_DESC_PTR(val) 	bfin_write32(DMA15_NEXT_DESC_PTR)
+#define bfin_read_DMA15_START_ADDR() 		bfin_read32(DMA15_START_ADDR)
+#define bfin_write_DMA15_START_ADDR(val) 	bfin_write32(DMA15_START_ADDR)
+#define bfin_read_DMA15_CONFIG()		bfin_read16(DMA15_CONFIG)
+#define bfin_write_DMA15_CONFIG(val)		bfin_write16(DMA15_CONFIG, val)
+#define bfin_read_DMA15_X_COUNT()		bfin_read16(DMA15_X_COUNT)
+#define bfin_write_DMA15_X_COUNT(val)		bfin_write16(DMA15_X_COUNT, val)
+#define bfin_read_DMA15_X_MODIFY()		bfin_read16(DMA15_X_MODIFY)
+#define bfin_write_DMA15_X_MODIFY(val) 		bfin_write16(DMA15_X_MODIFY)
+#define bfin_read_DMA15_Y_COUNT()		bfin_read16(DMA15_Y_COUNT)
+#define bfin_write_DMA15_Y_COUNT(val)		bfin_write16(DMA15_Y_COUNT, val)
+#define bfin_read_DMA15_Y_MODIFY()		bfin_read16(DMA15_Y_MODIFY)
+#define bfin_write_DMA15_Y_MODIFY(val) 		bfin_write16(DMA15_Y_MODIFY)
+#define bfin_read_DMA15_CURR_DESC_PTR() 	bfin_read32(DMA15_CURR_DESC_PTR)
+#define bfin_write_DMA15_CURR_DESC_PTR(val) 	bfin_write32(DMA15_CURR_DESC_PTR)
+#define bfin_read_DMA15_CURR_ADDR() 		bfin_read32(DMA15_CURR_ADDR)
+#define bfin_write_DMA15_CURR_ADDR(val) 	bfin_write32(DMA15_CURR_ADDR)
+#define bfin_read_DMA15_IRQ_STATUS()		bfin_read16(DMA15_IRQ_STATUS)
+#define bfin_write_DMA15_IRQ_STATUS(val)	bfin_write16(DMA15_IRQ_STATUS, val)
+#define bfin_read_DMA15_PERIPHERAL_MAP()	bfin_read16(DMA15_PERIPHERAL_MAP)
+#define bfin_write_DMA15_PERIPHERAL_MAP(val)	bfin_write16(DMA15_PERIPHERAL_MAP, val)
+#define bfin_read_DMA15_CURR_X_COUNT()		bfin_read16(DMA15_CURR_X_COUNT)
+#define bfin_write_DMA15_CURR_X_COUNT(val)	bfin_write16(DMA15_CURR_X_COUNT, val)
+#define bfin_read_DMA15_CURR_Y_COUNT()		bfin_read16(DMA15_CURR_Y_COUNT)
+#define bfin_write_DMA15_CURR_Y_COUNT(val)	bfin_write16(DMA15_CURR_Y_COUNT, val)
+
+/* DMA Channel 16 Registers */
+
+#define bfin_read_DMA16_NEXT_DESC_PTR() 	bfin_read32(DMA16_NEXT_DESC_PTR)
+#define bfin_write_DMA16_NEXT_DESC_PTR(val) 	bfin_write32(DMA16_NEXT_DESC_PTR)
+#define bfin_read_DMA16_START_ADDR() 		bfin_read32(DMA16_START_ADDR)
+#define bfin_write_DMA16_START_ADDR(val) 	bfin_write32(DMA16_START_ADDR)
+#define bfin_read_DMA16_CONFIG()		bfin_read16(DMA16_CONFIG)
+#define bfin_write_DMA16_CONFIG(val)		bfin_write16(DMA16_CONFIG, val)
+#define bfin_read_DMA16_X_COUNT()		bfin_read16(DMA16_X_COUNT)
+#define bfin_write_DMA16_X_COUNT(val)		bfin_write16(DMA16_X_COUNT, val)
+#define bfin_read_DMA16_X_MODIFY()		bfin_read16(DMA16_X_MODIFY)
+#define bfin_write_DMA16_X_MODIFY(val) 		bfin_write16(DMA16_X_MODIFY)
+#define bfin_read_DMA16_Y_COUNT()		bfin_read16(DMA16_Y_COUNT)
+#define bfin_write_DMA16_Y_COUNT(val)		bfin_write16(DMA16_Y_COUNT, val)
+#define bfin_read_DMA16_Y_MODIFY()		bfin_read16(DMA16_Y_MODIFY)
+#define bfin_write_DMA16_Y_MODIFY(val) 		bfin_write16(DMA16_Y_MODIFY)
+#define bfin_read_DMA16_CURR_DESC_PTR() 	bfin_read32(DMA16_CURR_DESC_PTR)
+#define bfin_write_DMA16_CURR_DESC_PTR(val) 	bfin_write32(DMA16_CURR_DESC_PTR)
+#define bfin_read_DMA16_CURR_ADDR() 		bfin_read32(DMA16_CURR_ADDR)
+#define bfin_write_DMA16_CURR_ADDR(val) 	bfin_write32(DMA16_CURR_ADDR)
+#define bfin_read_DMA16_IRQ_STATUS()		bfin_read16(DMA16_IRQ_STATUS)
+#define bfin_write_DMA16_IRQ_STATUS(val)	bfin_write16(DMA16_IRQ_STATUS, val)
+#define bfin_read_DMA16_PERIPHERAL_MAP()	bfin_read16(DMA16_PERIPHERAL_MAP)
+#define bfin_write_DMA16_PERIPHERAL_MAP(val)	bfin_write16(DMA16_PERIPHERAL_MAP, val)
+#define bfin_read_DMA16_CURR_X_COUNT()		bfin_read16(DMA16_CURR_X_COUNT)
+#define bfin_write_DMA16_CURR_X_COUNT(val)	bfin_write16(DMA16_CURR_X_COUNT, val)
+#define bfin_read_DMA16_CURR_Y_COUNT()		bfin_read16(DMA16_CURR_Y_COUNT)
+#define bfin_write_DMA16_CURR_Y_COUNT(val)	bfin_write16(DMA16_CURR_Y_COUNT, val)
+
+/* DMA Channel 17 Registers */
+
+#define bfin_read_DMA17_NEXT_DESC_PTR() 	bfin_read32(DMA17_NEXT_DESC_PTR)
+#define bfin_write_DMA17_NEXT_DESC_PTR(val) 	bfin_write32(DMA17_NEXT_DESC_PTR)
+#define bfin_read_DMA17_START_ADDR() 		bfin_read32(DMA17_START_ADDR)
+#define bfin_write_DMA17_START_ADDR(val) 	bfin_write32(DMA17_START_ADDR)
+#define bfin_read_DMA17_CONFIG()		bfin_read16(DMA17_CONFIG)
+#define bfin_write_DMA17_CONFIG(val)		bfin_write16(DMA17_CONFIG, val)
+#define bfin_read_DMA17_X_COUNT()		bfin_read16(DMA17_X_COUNT)
+#define bfin_write_DMA17_X_COUNT(val)		bfin_write16(DMA17_X_COUNT, val)
+#define bfin_read_DMA17_X_MODIFY()		bfin_read16(DMA17_X_MODIFY)
+#define bfin_write_DMA17_X_MODIFY(val) 		bfin_write16(DMA17_X_MODIFY)
+#define bfin_read_DMA17_Y_COUNT()		bfin_read16(DMA17_Y_COUNT)
+#define bfin_write_DMA17_Y_COUNT(val)		bfin_write16(DMA17_Y_COUNT, val)
+#define bfin_read_DMA17_Y_MODIFY()		bfin_read16(DMA17_Y_MODIFY)
+#define bfin_write_DMA17_Y_MODIFY(val) 		bfin_write16(DMA17_Y_MODIFY)
+#define bfin_read_DMA17_CURR_DESC_PTR() 	bfin_read32(DMA17_CURR_DESC_PTR)
+#define bfin_write_DMA17_CURR_DESC_PTR(val) 	bfin_write32(DMA17_CURR_DESC_PTR)
+#define bfin_read_DMA17_CURR_ADDR() 		bfin_read32(DMA17_CURR_ADDR)
+#define bfin_write_DMA17_CURR_ADDR(val) 	bfin_write32(DMA17_CURR_ADDR)
+#define bfin_read_DMA17_IRQ_STATUS()		bfin_read16(DMA17_IRQ_STATUS)
+#define bfin_write_DMA17_IRQ_STATUS(val)	bfin_write16(DMA17_IRQ_STATUS, val)
+#define bfin_read_DMA17_PERIPHERAL_MAP()	bfin_read16(DMA17_PERIPHERAL_MAP)
+#define bfin_write_DMA17_PERIPHERAL_MAP(val)	bfin_write16(DMA17_PERIPHERAL_MAP, val)
+#define bfin_read_DMA17_CURR_X_COUNT()		bfin_read16(DMA17_CURR_X_COUNT)
+#define bfin_write_DMA17_CURR_X_COUNT(val)	bfin_write16(DMA17_CURR_X_COUNT, val)
+#define bfin_read_DMA17_CURR_Y_COUNT()		bfin_read16(DMA17_CURR_Y_COUNT)
+#define bfin_write_DMA17_CURR_Y_COUNT(val)	bfin_write16(DMA17_CURR_Y_COUNT, val)
+
+/* DMA Channel 18 Registers */
+
+#define bfin_read_DMA18_NEXT_DESC_PTR() 	bfin_read32(DMA18_NEXT_DESC_PTR)
+#define bfin_write_DMA18_NEXT_DESC_PTR(val) 	bfin_write32(DMA18_NEXT_DESC_PTR)
+#define bfin_read_DMA18_START_ADDR() 		bfin_read32(DMA18_START_ADDR)
+#define bfin_write_DMA18_START_ADDR(val) 	bfin_write32(DMA18_START_ADDR)
+#define bfin_read_DMA18_CONFIG()		bfin_read16(DMA18_CONFIG)
+#define bfin_write_DMA18_CONFIG(val)		bfin_write16(DMA18_CONFIG, val)
+#define bfin_read_DMA18_X_COUNT()		bfin_read16(DMA18_X_COUNT)
+#define bfin_write_DMA18_X_COUNT(val)		bfin_write16(DMA18_X_COUNT, val)
+#define bfin_read_DMA18_X_MODIFY()		bfin_read16(DMA18_X_MODIFY)
+#define bfin_write_DMA18_X_MODIFY(val) 		bfin_write16(DMA18_X_MODIFY)
+#define bfin_read_DMA18_Y_COUNT()		bfin_read16(DMA18_Y_COUNT)
+#define bfin_write_DMA18_Y_COUNT(val)		bfin_write16(DMA18_Y_COUNT, val)
+#define bfin_read_DMA18_Y_MODIFY()		bfin_read16(DMA18_Y_MODIFY)
+#define bfin_write_DMA18_Y_MODIFY(val) 		bfin_write16(DMA18_Y_MODIFY)
+#define bfin_read_DMA18_CURR_DESC_PTR() 	bfin_read32(DMA18_CURR_DESC_PTR)
+#define bfin_write_DMA18_CURR_DESC_PTR(val) 	bfin_write32(DMA18_CURR_DESC_PTR)
+#define bfin_read_DMA18_CURR_ADDR() 		bfin_read32(DMA18_CURR_ADDR)
+#define bfin_write_DMA18_CURR_ADDR(val) 	bfin_write32(DMA18_CURR_ADDR)
+#define bfin_read_DMA18_IRQ_STATUS()		bfin_read16(DMA18_IRQ_STATUS)
+#define bfin_write_DMA18_IRQ_STATUS(val)	bfin_write16(DMA18_IRQ_STATUS, val)
+#define bfin_read_DMA18_PERIPHERAL_MAP()	bfin_read16(DMA18_PERIPHERAL_MAP)
+#define bfin_write_DMA18_PERIPHERAL_MAP(val)	bfin_write16(DMA18_PERIPHERAL_MAP, val)
+#define bfin_read_DMA18_CURR_X_COUNT()		bfin_read16(DMA18_CURR_X_COUNT)
+#define bfin_write_DMA18_CURR_X_COUNT(val)	bfin_write16(DMA18_CURR_X_COUNT, val)
+#define bfin_read_DMA18_CURR_Y_COUNT()		bfin_read16(DMA18_CURR_Y_COUNT)
+#define bfin_write_DMA18_CURR_Y_COUNT(val)	bfin_write16(DMA18_CURR_Y_COUNT, val)
+
+/* DMA Channel 19 Registers */
+
+#define bfin_read_DMA19_NEXT_DESC_PTR() 	bfin_read32(DMA19_NEXT_DESC_PTR)
+#define bfin_write_DMA19_NEXT_DESC_PTR(val) 	bfin_write32(DMA19_NEXT_DESC_PTR)
+#define bfin_read_DMA19_START_ADDR() 		bfin_read32(DMA19_START_ADDR)
+#define bfin_write_DMA19_START_ADDR(val) 	bfin_write32(DMA19_START_ADDR)
+#define bfin_read_DMA19_CONFIG()		bfin_read16(DMA19_CONFIG)
+#define bfin_write_DMA19_CONFIG(val)		bfin_write16(DMA19_CONFIG, val)
+#define bfin_read_DMA19_X_COUNT()		bfin_read16(DMA19_X_COUNT)
+#define bfin_write_DMA19_X_COUNT(val)		bfin_write16(DMA19_X_COUNT, val)
+#define bfin_read_DMA19_X_MODIFY()		bfin_read16(DMA19_X_MODIFY)
+#define bfin_write_DMA19_X_MODIFY(val) 		bfin_write16(DMA19_X_MODIFY)
+#define bfin_read_DMA19_Y_COUNT()		bfin_read16(DMA19_Y_COUNT)
+#define bfin_write_DMA19_Y_COUNT(val)		bfin_write16(DMA19_Y_COUNT, val)
+#define bfin_read_DMA19_Y_MODIFY()		bfin_read16(DMA19_Y_MODIFY)
+#define bfin_write_DMA19_Y_MODIFY(val) 		bfin_write16(DMA19_Y_MODIFY)
+#define bfin_read_DMA19_CURR_DESC_PTR() 	bfin_read32(DMA19_CURR_DESC_PTR)
+#define bfin_write_DMA19_CURR_DESC_PTR(val) 	bfin_write32(DMA19_CURR_DESC_PTR)
+#define bfin_read_DMA19_CURR_ADDR() 		bfin_read32(DMA19_CURR_ADDR)
+#define bfin_write_DMA19_CURR_ADDR(val) 	bfin_write32(DMA19_CURR_ADDR)
+#define bfin_read_DMA19_IRQ_STATUS()		bfin_read16(DMA19_IRQ_STATUS)
+#define bfin_write_DMA19_IRQ_STATUS(val)	bfin_write16(DMA19_IRQ_STATUS, val)
+#define bfin_read_DMA19_PERIPHERAL_MAP()	bfin_read16(DMA19_PERIPHERAL_MAP)
+#define bfin_write_DMA19_PERIPHERAL_MAP(val)	bfin_write16(DMA19_PERIPHERAL_MAP, val)
+#define bfin_read_DMA19_CURR_X_COUNT()		bfin_read16(DMA19_CURR_X_COUNT)
+#define bfin_write_DMA19_CURR_X_COUNT(val)	bfin_write16(DMA19_CURR_X_COUNT, val)
+#define bfin_read_DMA19_CURR_Y_COUNT()		bfin_read16(DMA19_CURR_Y_COUNT)
+#define bfin_write_DMA19_CURR_Y_COUNT(val)	bfin_write16(DMA19_CURR_Y_COUNT, val)
+
+/* DMA Channel 20 Registers */
+
+#define bfin_read_DMA20_NEXT_DESC_PTR() 	bfin_read32(DMA20_NEXT_DESC_PTR)
+#define bfin_write_DMA20_NEXT_DESC_PTR(val) 	bfin_write32(DMA20_NEXT_DESC_PTR)
+#define bfin_read_DMA20_START_ADDR() 		bfin_read32(DMA20_START_ADDR)
+#define bfin_write_DMA20_START_ADDR(val) 	bfin_write32(DMA20_START_ADDR)
+#define bfin_read_DMA20_CONFIG()		bfin_read16(DMA20_CONFIG)
+#define bfin_write_DMA20_CONFIG(val)		bfin_write16(DMA20_CONFIG, val)
+#define bfin_read_DMA20_X_COUNT()		bfin_read16(DMA20_X_COUNT)
+#define bfin_write_DMA20_X_COUNT(val)		bfin_write16(DMA20_X_COUNT, val)
+#define bfin_read_DMA20_X_MODIFY()		bfin_read16(DMA20_X_MODIFY)
+#define bfin_write_DMA20_X_MODIFY(val) 		bfin_write16(DMA20_X_MODIFY)
+#define bfin_read_DMA20_Y_COUNT()		bfin_read16(DMA20_Y_COUNT)
+#define bfin_write_DMA20_Y_COUNT(val)		bfin_write16(DMA20_Y_COUNT, val)
+#define bfin_read_DMA20_Y_MODIFY()		bfin_read16(DMA20_Y_MODIFY)
+#define bfin_write_DMA20_Y_MODIFY(val) 		bfin_write16(DMA20_Y_MODIFY)
+#define bfin_read_DMA20_CURR_DESC_PTR() 	bfin_read32(DMA20_CURR_DESC_PTR)
+#define bfin_write_DMA20_CURR_DESC_PTR(val) 	bfin_write32(DMA20_CURR_DESC_PTR)
+#define bfin_read_DMA20_CURR_ADDR() 		bfin_read32(DMA20_CURR_ADDR)
+#define bfin_write_DMA20_CURR_ADDR(val) 	bfin_write32(DMA20_CURR_ADDR)
+#define bfin_read_DMA20_IRQ_STATUS()		bfin_read16(DMA20_IRQ_STATUS)
+#define bfin_write_DMA20_IRQ_STATUS(val)	bfin_write16(DMA20_IRQ_STATUS, val)
+#define bfin_read_DMA20_PERIPHERAL_MAP()	bfin_read16(DMA20_PERIPHERAL_MAP)
+#define bfin_write_DMA20_PERIPHERAL_MAP(val)	bfin_write16(DMA20_PERIPHERAL_MAP, val)
+#define bfin_read_DMA20_CURR_X_COUNT()		bfin_read16(DMA20_CURR_X_COUNT)
+#define bfin_write_DMA20_CURR_X_COUNT(val)	bfin_write16(DMA20_CURR_X_COUNT, val)
+#define bfin_read_DMA20_CURR_Y_COUNT()		bfin_read16(DMA20_CURR_Y_COUNT)
+#define bfin_write_DMA20_CURR_Y_COUNT(val)	bfin_write16(DMA20_CURR_Y_COUNT, val)
+
+/* DMA Channel 21 Registers */
+
+#define bfin_read_DMA21_NEXT_DESC_PTR() 	bfin_read32(DMA21_NEXT_DESC_PTR)
+#define bfin_write_DMA21_NEXT_DESC_PTR(val) 	bfin_write32(DMA21_NEXT_DESC_PTR)
+#define bfin_read_DMA21_START_ADDR() 		bfin_read32(DMA21_START_ADDR)
+#define bfin_write_DMA21_START_ADDR(val) 	bfin_write32(DMA21_START_ADDR)
+#define bfin_read_DMA21_CONFIG()		bfin_read16(DMA21_CONFIG)
+#define bfin_write_DMA21_CONFIG(val)		bfin_write16(DMA21_CONFIG, val)
+#define bfin_read_DMA21_X_COUNT()		bfin_read16(DMA21_X_COUNT)
+#define bfin_write_DMA21_X_COUNT(val)		bfin_write16(DMA21_X_COUNT, val)
+#define bfin_read_DMA21_X_MODIFY()		bfin_read16(DMA21_X_MODIFY)
+#define bfin_write_DMA21_X_MODIFY(val) 		bfin_write16(DMA21_X_MODIFY)
+#define bfin_read_DMA21_Y_COUNT()		bfin_read16(DMA21_Y_COUNT)
+#define bfin_write_DMA21_Y_COUNT(val)		bfin_write16(DMA21_Y_COUNT, val)
+#define bfin_read_DMA21_Y_MODIFY()		bfin_read16(DMA21_Y_MODIFY)
+#define bfin_write_DMA21_Y_MODIFY(val) 		bfin_write16(DMA21_Y_MODIFY)
+#define bfin_read_DMA21_CURR_DESC_PTR() 	bfin_read32(DMA21_CURR_DESC_PTR)
+#define bfin_write_DMA21_CURR_DESC_PTR(val) 	bfin_write32(DMA21_CURR_DESC_PTR)
+#define bfin_read_DMA21_CURR_ADDR() 		bfin_read32(DMA21_CURR_ADDR)
+#define bfin_write_DMA21_CURR_ADDR(val) 	bfin_write32(DMA21_CURR_ADDR)
+#define bfin_read_DMA21_IRQ_STATUS()		bfin_read16(DMA21_IRQ_STATUS)
+#define bfin_write_DMA21_IRQ_STATUS(val)	bfin_write16(DMA21_IRQ_STATUS, val)
+#define bfin_read_DMA21_PERIPHERAL_MAP()	bfin_read16(DMA21_PERIPHERAL_MAP)
+#define bfin_write_DMA21_PERIPHERAL_MAP(val)	bfin_write16(DMA21_PERIPHERAL_MAP, val)
+#define bfin_read_DMA21_CURR_X_COUNT()		bfin_read16(DMA21_CURR_X_COUNT)
+#define bfin_write_DMA21_CURR_X_COUNT(val)	bfin_write16(DMA21_CURR_X_COUNT, val)
+#define bfin_read_DMA21_CURR_Y_COUNT()		bfin_read16(DMA21_CURR_Y_COUNT)
+#define bfin_write_DMA21_CURR_Y_COUNT(val)	bfin_write16(DMA21_CURR_Y_COUNT, val)
+
+/* DMA Channel 22 Registers */
+
+#define bfin_read_DMA22_NEXT_DESC_PTR() 	bfin_read32(DMA22_NEXT_DESC_PTR)
+#define bfin_write_DMA22_NEXT_DESC_PTR(val) 	bfin_write32(DMA22_NEXT_DESC_PTR)
+#define bfin_read_DMA22_START_ADDR() 		bfin_read32(DMA22_START_ADDR)
+#define bfin_write_DMA22_START_ADDR(val) 	bfin_write32(DMA22_START_ADDR)
+#define bfin_read_DMA22_CONFIG()		bfin_read16(DMA22_CONFIG)
+#define bfin_write_DMA22_CONFIG(val)		bfin_write16(DMA22_CONFIG, val)
+#define bfin_read_DMA22_X_COUNT()		bfin_read16(DMA22_X_COUNT)
+#define bfin_write_DMA22_X_COUNT(val)		bfin_write16(DMA22_X_COUNT, val)
+#define bfin_read_DMA22_X_MODIFY()		bfin_read16(DMA22_X_MODIFY)
+#define bfin_write_DMA22_X_MODIFY(val) 		bfin_write16(DMA22_X_MODIFY)
+#define bfin_read_DMA22_Y_COUNT()		bfin_read16(DMA22_Y_COUNT)
+#define bfin_write_DMA22_Y_COUNT(val)		bfin_write16(DMA22_Y_COUNT, val)
+#define bfin_read_DMA22_Y_MODIFY()		bfin_read16(DMA22_Y_MODIFY)
+#define bfin_write_DMA22_Y_MODIFY(val) 		bfin_write16(DMA22_Y_MODIFY)
+#define bfin_read_DMA22_CURR_DESC_PTR() 	bfin_read32(DMA22_CURR_DESC_PTR)
+#define bfin_write_DMA22_CURR_DESC_PTR(val) 	bfin_write32(DMA22_CURR_DESC_PTR)
+#define bfin_read_DMA22_CURR_ADDR() 		bfin_read32(DMA22_CURR_ADDR)
+#define bfin_write_DMA22_CURR_ADDR(val) 	bfin_write32(DMA22_CURR_ADDR)
+#define bfin_read_DMA22_IRQ_STATUS()		bfin_read16(DMA22_IRQ_STATUS)
+#define bfin_write_DMA22_IRQ_STATUS(val)	bfin_write16(DMA22_IRQ_STATUS, val)
+#define bfin_read_DMA22_PERIPHERAL_MAP()	bfin_read16(DMA22_PERIPHERAL_MAP)
+#define bfin_write_DMA22_PERIPHERAL_MAP(val)	bfin_write16(DMA22_PERIPHERAL_MAP, val)
+#define bfin_read_DMA22_CURR_X_COUNT()		bfin_read16(DMA22_CURR_X_COUNT)
+#define bfin_write_DMA22_CURR_X_COUNT(val)	bfin_write16(DMA22_CURR_X_COUNT, val)
+#define bfin_read_DMA22_CURR_Y_COUNT()		bfin_read16(DMA22_CURR_Y_COUNT)
+#define bfin_write_DMA22_CURR_Y_COUNT(val)	bfin_write16(DMA22_CURR_Y_COUNT, val)
+
+/* DMA Channel 23 Registers */
+
+#define bfin_read_DMA23_NEXT_DESC_PTR() 		bfin_read32(DMA23_NEXT_DESC_PTR)
+#define bfin_write_DMA23_NEXT_DESC_PTR(val) 		bfin_write32(DMA23_NEXT_DESC_PTR)
+#define bfin_read_DMA23_START_ADDR() 			bfin_read32(DMA23_START_ADDR)
+#define bfin_write_DMA23_START_ADDR(val) 		bfin_write32(DMA23_START_ADDR)
+#define bfin_read_DMA23_CONFIG()			bfin_read16(DMA23_CONFIG)
+#define bfin_write_DMA23_CONFIG(val)			bfin_write16(DMA23_CONFIG, val)
+#define bfin_read_DMA23_X_COUNT()			bfin_read16(DMA23_X_COUNT)
+#define bfin_write_DMA23_X_COUNT(val)			bfin_write16(DMA23_X_COUNT, val)
+#define bfin_read_DMA23_X_MODIFY()			bfin_read16(DMA23_X_MODIFY)
+#define bfin_write_DMA23_X_MODIFY(val) 			bfin_write16(DMA23_X_MODIFY)
+#define bfin_read_DMA23_Y_COUNT()			bfin_read16(DMA23_Y_COUNT)
+#define bfin_write_DMA23_Y_COUNT(val)			bfin_write16(DMA23_Y_COUNT, val)
+#define bfin_read_DMA23_Y_MODIFY()			bfin_read16(DMA23_Y_MODIFY)
+#define bfin_write_DMA23_Y_MODIFY(val) 			bfin_write16(DMA23_Y_MODIFY)
+#define bfin_read_DMA23_CURR_DESC_PTR() 		bfin_read32(DMA23_CURR_DESC_PTR)
+#define bfin_write_DMA23_CURR_DESC_PTR(val) 		bfin_write32(DMA23_CURR_DESC_PTR)
+#define bfin_read_DMA23_CURR_ADDR() 			bfin_read32(DMA23_CURR_ADDR)
+#define bfin_write_DMA23_CURR_ADDR(val) 		bfin_write32(DMA23_CURR_ADDR)
+#define bfin_read_DMA23_IRQ_STATUS()			bfin_read16(DMA23_IRQ_STATUS)
+#define bfin_write_DMA23_IRQ_STATUS(val)		bfin_write16(DMA23_IRQ_STATUS, val)
+#define bfin_read_DMA23_PERIPHERAL_MAP()		bfin_read16(DMA23_PERIPHERAL_MAP)
+#define bfin_write_DMA23_PERIPHERAL_MAP(val)		bfin_write16(DMA23_PERIPHERAL_MAP, val)
+#define bfin_read_DMA23_CURR_X_COUNT()			bfin_read16(DMA23_CURR_X_COUNT)
+#define bfin_write_DMA23_CURR_X_COUNT(val)		bfin_write16(DMA23_CURR_X_COUNT, val)
+#define bfin_read_DMA23_CURR_Y_COUNT()			bfin_read16(DMA23_CURR_Y_COUNT)
+#define bfin_write_DMA23_CURR_Y_COUNT(val)		bfin_write16(DMA23_CURR_Y_COUNT, val)
+
+/* MDMA Stream 2 Registers */
+
+#define bfin_read_MDMA_D2_NEXT_DESC_PTR() 		bfin_read32(MDMA_D2_NEXT_DESC_PTR)
+#define bfin_write_MDMA_D2_NEXT_DESC_PTR(val) 		bfin_write32(MDMA_D2_NEXT_DESC_PTR)
+#define bfin_read_MDMA_D2_START_ADDR() 			bfin_read32(MDMA_D2_START_ADDR)
+#define bfin_write_MDMA_D2_START_ADDR(val) 		bfin_write32(MDMA_D2_START_ADDR)
+#define bfin_read_MDMA_D2_CONFIG()			bfin_read16(MDMA_D2_CONFIG)
+#define bfin_write_MDMA_D2_CONFIG(val)			bfin_write16(MDMA_D2_CONFIG, val)
+#define bfin_read_MDMA_D2_X_COUNT()			bfin_read16(MDMA_D2_X_COUNT)
+#define bfin_write_MDMA_D2_X_COUNT(val)			bfin_write16(MDMA_D2_X_COUNT, val)
+#define bfin_read_MDMA_D2_X_MODIFY()			bfin_read16(MDMA_D2_X_MODIFY)
+#define bfin_write_MDMA_D2_X_MODIFY(val) 		bfin_write16(MDMA_D2_X_MODIFY)
+#define bfin_read_MDMA_D2_Y_COUNT()			bfin_read16(MDMA_D2_Y_COUNT)
+#define bfin_write_MDMA_D2_Y_COUNT(val)			bfin_write16(MDMA_D2_Y_COUNT, val)
+#define bfin_read_MDMA_D2_Y_MODIFY()			bfin_read16(MDMA_D2_Y_MODIFY)
+#define bfin_write_MDMA_D2_Y_MODIFY(val) 		bfin_write16(MDMA_D2_Y_MODIFY)
+#define bfin_read_MDMA_D2_CURR_DESC_PTR() 		bfin_read32(MDMA_D2_CURR_DESC_PTR)
+#define bfin_write_MDMA_D2_CURR_DESC_PTR(val) 		bfin_write32(MDMA_D2_CURR_DESC_PTR)
+#define bfin_read_MDMA_D2_CURR_ADDR() 			bfin_read32(MDMA_D2_CURR_ADDR)
+#define bfin_write_MDMA_D2_CURR_ADDR(val) 		bfin_write32(MDMA_D2_CURR_ADDR)
+#define bfin_read_MDMA_D2_IRQ_STATUS()			bfin_read16(MDMA_D2_IRQ_STATUS)
+#define bfin_write_MDMA_D2_IRQ_STATUS(val)		bfin_write16(MDMA_D2_IRQ_STATUS, val)
+#define bfin_read_MDMA_D2_PERIPHERAL_MAP()		bfin_read16(MDMA_D2_PERIPHERAL_MAP)
+#define bfin_write_MDMA_D2_PERIPHERAL_MAP(val)		bfin_write16(MDMA_D2_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_D2_CURR_X_COUNT()		bfin_read16(MDMA_D2_CURR_X_COUNT)
+#define bfin_write_MDMA_D2_CURR_X_COUNT(val)		bfin_write16(MDMA_D2_CURR_X_COUNT, val)
+#define bfin_read_MDMA_D2_CURR_Y_COUNT()		bfin_read16(MDMA_D2_CURR_Y_COUNT)
+#define bfin_write_MDMA_D2_CURR_Y_COUNT(val)		bfin_write16(MDMA_D2_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_S2_NEXT_DESC_PTR() 		bfin_read32(MDMA_S2_NEXT_DESC_PTR)
+#define bfin_write_MDMA_S2_NEXT_DESC_PTR(val) 		bfin_write32(MDMA_S2_NEXT_DESC_PTR)
+#define bfin_read_MDMA_S2_START_ADDR() 			bfin_read32(MDMA_S2_START_ADDR)
+#define bfin_write_MDMA_S2_START_ADDR(val) 		bfin_write32(MDMA_S2_START_ADDR)
+#define bfin_read_MDMA_S2_CONFIG()			bfin_read16(MDMA_S2_CONFIG)
+#define bfin_write_MDMA_S2_CONFIG(val)			bfin_write16(MDMA_S2_CONFIG, val)
+#define bfin_read_MDMA_S2_X_COUNT()			bfin_read16(MDMA_S2_X_COUNT)
+#define bfin_write_MDMA_S2_X_COUNT(val)			bfin_write16(MDMA_S2_X_COUNT, val)
+#define bfin_read_MDMA_S2_X_MODIFY()			bfin_read16(MDMA_S2_X_MODIFY)
+#define bfin_write_MDMA_S2_X_MODIFY(val) 		bfin_write16(MDMA_S2_X_MODIFY)
+#define bfin_read_MDMA_S2_Y_COUNT()			bfin_read16(MDMA_S2_Y_COUNT)
+#define bfin_write_MDMA_S2_Y_COUNT(val)			bfin_write16(MDMA_S2_Y_COUNT, val)
+#define bfin_read_MDMA_S2_Y_MODIFY()			bfin_read16(MDMA_S2_Y_MODIFY)
+#define bfin_write_MDMA_S2_Y_MODIFY(val) 		bfin_write16(MDMA_S2_Y_MODIFY)
+#define bfin_read_MDMA_S2_CURR_DESC_PTR() 		bfin_read32(MDMA_S2_CURR_DESC_PTR)
+#define bfin_write_MDMA_S2_CURR_DESC_PTR(val) 		bfin_write32(MDMA_S2_CURR_DESC_PTR)
+#define bfin_read_MDMA_S2_CURR_ADDR() 			bfin_read32(MDMA_S2_CURR_ADDR)
+#define bfin_write_MDMA_S2_CURR_ADDR(val) 		bfin_write32(MDMA_S2_CURR_ADDR)
+#define bfin_read_MDMA_S2_IRQ_STATUS()			bfin_read16(MDMA_S2_IRQ_STATUS)
+#define bfin_write_MDMA_S2_IRQ_STATUS(val)		bfin_write16(MDMA_S2_IRQ_STATUS, val)
+#define bfin_read_MDMA_S2_PERIPHERAL_MAP()		bfin_read16(MDMA_S2_PERIPHERAL_MAP)
+#define bfin_write_MDMA_S2_PERIPHERAL_MAP(val)		bfin_write16(MDMA_S2_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_S2_CURR_X_COUNT()		bfin_read16(MDMA_S2_CURR_X_COUNT)
+#define bfin_write_MDMA_S2_CURR_X_COUNT(val)		bfin_write16(MDMA_S2_CURR_X_COUNT, val)
+#define bfin_read_MDMA_S2_CURR_Y_COUNT()		bfin_read16(MDMA_S2_CURR_Y_COUNT)
+#define bfin_write_MDMA_S2_CURR_Y_COUNT(val)		bfin_write16(MDMA_S2_CURR_Y_COUNT, val)
+
+/* MDMA Stream 3 Registers */
+
+#define bfin_read_MDMA_D3_NEXT_DESC_PTR() 		bfin_read32(MDMA_D3_NEXT_DESC_PTR)
+#define bfin_write_MDMA_D3_NEXT_DESC_PTR(val) 		bfin_write32(MDMA_D3_NEXT_DESC_PTR)
+#define bfin_read_MDMA_D3_START_ADDR() 			bfin_read32(MDMA_D3_START_ADDR)
+#define bfin_write_MDMA_D3_START_ADDR(val) 		bfin_write32(MDMA_D3_START_ADDR)
+#define bfin_read_MDMA_D3_CONFIG()			bfin_read16(MDMA_D3_CONFIG)
+#define bfin_write_MDMA_D3_CONFIG(val)			bfin_write16(MDMA_D3_CONFIG, val)
+#define bfin_read_MDMA_D3_X_COUNT()			bfin_read16(MDMA_D3_X_COUNT)
+#define bfin_write_MDMA_D3_X_COUNT(val)			bfin_write16(MDMA_D3_X_COUNT, val)
+#define bfin_read_MDMA_D3_X_MODIFY()			bfin_read16(MDMA_D3_X_MODIFY)
+#define bfin_write_MDMA_D3_X_MODIFY(val) 		bfin_write16(MDMA_D3_X_MODIFY)
+#define bfin_read_MDMA_D3_Y_COUNT()			bfin_read16(MDMA_D3_Y_COUNT)
+#define bfin_write_MDMA_D3_Y_COUNT(val)			bfin_write16(MDMA_D3_Y_COUNT, val)
+#define bfin_read_MDMA_D3_Y_MODIFY()			bfin_read16(MDMA_D3_Y_MODIFY)
+#define bfin_write_MDMA_D3_Y_MODIFY(val) 		bfin_write16(MDMA_D3_Y_MODIFY)
+#define bfin_read_MDMA_D3_CURR_DESC_PTR() 		bfin_read32(MDMA_D3_CURR_DESC_PTR)
+#define bfin_write_MDMA_D3_CURR_DESC_PTR(val) 		bfin_write32(MDMA_D3_CURR_DESC_PTR)
+#define bfin_read_MDMA_D3_CURR_ADDR() 			bfin_read32(MDMA_D3_CURR_ADDR)
+#define bfin_write_MDMA_D3_CURR_ADDR(val) 		bfin_write32(MDMA_D3_CURR_ADDR)
+#define bfin_read_MDMA_D3_IRQ_STATUS()			bfin_read16(MDMA_D3_IRQ_STATUS)
+#define bfin_write_MDMA_D3_IRQ_STATUS(val)		bfin_write16(MDMA_D3_IRQ_STATUS, val)
+#define bfin_read_MDMA_D3_PERIPHERAL_MAP()		bfin_read16(MDMA_D3_PERIPHERAL_MAP)
+#define bfin_write_MDMA_D3_PERIPHERAL_MAP(val)		bfin_write16(MDMA_D3_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_D3_CURR_X_COUNT()		bfin_read16(MDMA_D3_CURR_X_COUNT)
+#define bfin_write_MDMA_D3_CURR_X_COUNT(val)		bfin_write16(MDMA_D3_CURR_X_COUNT, val)
+#define bfin_read_MDMA_D3_CURR_Y_COUNT()		bfin_read16(MDMA_D3_CURR_Y_COUNT)
+#define bfin_write_MDMA_D3_CURR_Y_COUNT(val)		bfin_write16(MDMA_D3_CURR_Y_COUNT, val)
+#define bfin_read_MDMA_S3_NEXT_DESC_PTR() 		bfin_read32(MDMA_S3_NEXT_DESC_PTR)
+#define bfin_write_MDMA_S3_NEXT_DESC_PTR(val) 		bfin_write32(MDMA_S3_NEXT_DESC_PTR)
+#define bfin_read_MDMA_S3_START_ADDR() 			bfin_read32(MDMA_S3_START_ADDR)
+#define bfin_write_MDMA_S3_START_ADDR(val) 		bfin_write32(MDMA_S3_START_ADDR)
+#define bfin_read_MDMA_S3_CONFIG()			bfin_read16(MDMA_S3_CONFIG)
+#define bfin_write_MDMA_S3_CONFIG(val)			bfin_write16(MDMA_S3_CONFIG, val)
+#define bfin_read_MDMA_S3_X_COUNT()			bfin_read16(MDMA_S3_X_COUNT)
+#define bfin_write_MDMA_S3_X_COUNT(val)			bfin_write16(MDMA_S3_X_COUNT, val)
+#define bfin_read_MDMA_S3_X_MODIFY()			bfin_read16(MDMA_S3_X_MODIFY)
+#define bfin_write_MDMA_S3_X_MODIFY(val) 		bfin_write16(MDMA_S3_X_MODIFY)
+#define bfin_read_MDMA_S3_Y_COUNT()			bfin_read16(MDMA_S3_Y_COUNT)
+#define bfin_write_MDMA_S3_Y_COUNT(val)			bfin_write16(MDMA_S3_Y_COUNT, val)
+#define bfin_read_MDMA_S3_Y_MODIFY()			bfin_read16(MDMA_S3_Y_MODIFY)
+#define bfin_write_MDMA_S3_Y_MODIFY(val) 		bfin_write16(MDMA_S3_Y_MODIFY)
+#define bfin_read_MDMA_S3_CURR_DESC_PTR() 		bfin_read32(MDMA_S3_CURR_DESC_PTR)
+#define bfin_write_MDMA_S3_CURR_DESC_PTR(val) 		bfin_write32(MDMA_S3_CURR_DESC_PTR)
+#define bfin_read_MDMA_S3_CURR_ADDR() 			bfin_read32(MDMA_S3_CURR_ADDR)
+#define bfin_write_MDMA_S3_CURR_ADDR(val) 		bfin_write32(MDMA_S3_CURR_ADDR)
+#define bfin_read_MDMA_S3_IRQ_STATUS()			bfin_read16(MDMA_S3_IRQ_STATUS)
+#define bfin_write_MDMA_S3_IRQ_STATUS(val)		bfin_write16(MDMA_S3_IRQ_STATUS, val)
+#define bfin_read_MDMA_S3_PERIPHERAL_MAP()		bfin_read16(MDMA_S3_PERIPHERAL_MAP)
+#define bfin_write_MDMA_S3_PERIPHERAL_MAP(val)		bfin_write16(MDMA_S3_PERIPHERAL_MAP, val)
+#define bfin_read_MDMA_S3_CURR_X_COUNT()		bfin_read16(MDMA_S3_CURR_X_COUNT)
+#define bfin_write_MDMA_S3_CURR_X_COUNT(val)		bfin_write16(MDMA_S3_CURR_X_COUNT, val)
+#define bfin_read_MDMA_S3_CURR_Y_COUNT()		bfin_read16(MDMA_S3_CURR_Y_COUNT)
+#define bfin_write_MDMA_S3_CURR_Y_COUNT(val)		bfin_write16(MDMA_S3_CURR_Y_COUNT, val)
+
+/* UART1 Registers */
+
+#define bfin_read_UART1_DLL()			bfin_read16(UART1_DLL)
+#define bfin_write_UART1_DLL(val)		bfin_write16(UART1_DLL, val)
+#define bfin_read_UART1_DLH()			bfin_read16(UART1_DLH)
+#define bfin_write_UART1_DLH(val)		bfin_write16(UART1_DLH, val)
+#define bfin_read_UART1_GCTL()			bfin_read16(UART1_GCTL)
+#define bfin_write_UART1_GCTL(val)		bfin_write16(UART1_GCTL, val)
+#define bfin_read_UART1_LCR()			bfin_read16(UART1_LCR)
+#define bfin_write_UART1_LCR(val)		bfin_write16(UART1_LCR, val)
+#define bfin_read_UART1_MCR()			bfin_read16(UART1_MCR)
+#define bfin_write_UART1_MCR(val)		bfin_write16(UART1_MCR, val)
+#define bfin_read_UART1_LSR()			bfin_read16(UART1_LSR)
+#define bfin_write_UART1_LSR(val)		bfin_write16(UART1_LSR, val)
+#define bfin_read_UART1_MSR()			bfin_read16(UART1_MSR)
+#define bfin_write_UART1_MSR(val)		bfin_write16(UART1_MSR, val)
+#define bfin_read_UART1_SCR()			bfin_read16(UART1_SCR)
+#define bfin_write_UART1_SCR(val)		bfin_write16(UART1_SCR, val)
+#define bfin_read_UART1_IER_SET()		bfin_read16(UART1_IER_SET)
+#define bfin_write_UART1_IER_SET(val)		bfin_write16(UART1_IER_SET, val)
+#define bfin_read_UART1_IER_CLEAR()		bfin_read16(UART1_IER_CLEAR)
+#define bfin_write_UART1_IER_CLEAR(val)		bfin_write16(UART1_IER_CLEAR, val)
+#define bfin_read_UART1_THR()			bfin_read16(UART1_THR)
+#define bfin_write_UART1_THR(val)		bfin_write16(UART1_THR, val)
+#define bfin_read_UART1_RBR()			bfin_read16(UART1_RBR)
+#define bfin_write_UART1_RBR(val)		bfin_write16(UART1_RBR, val)
+
+/* UART2 is not defined in the shared file because it is not available on the ADSP-BF542 and ADSP-BF544 bfin_read_()rocessors */
+
+/* SPI1 Registers */
+
+#define bfin_read_SPI1_CTL()			bfin_read16(SPI1_CTL)
+#define bfin_write_SPI1_CTL(val)		bfin_write16(SPI1_CTL, val)
+#define bfin_read_SPI1_FLG()			bfin_read16(SPI1_FLG)
+#define bfin_write_SPI1_FLG(val)		bfin_write16(SPI1_FLG, val)
+#define bfin_read_SPI1_STAT()			bfin_read16(SPI1_STAT)
+#define bfin_write_SPI1_STAT(val)		bfin_write16(SPI1_STAT, val)
+#define bfin_read_SPI1_TDBR()			bfin_read16(SPI1_TDBR)
+#define bfin_write_SPI1_TDBR(val)		bfin_write16(SPI1_TDBR, val)
+#define bfin_read_SPI1_RDBR()			bfin_read16(SPI1_RDBR)
+#define bfin_write_SPI1_RDBR(val)		bfin_write16(SPI1_RDBR, val)
+#define bfin_read_SPI1_BAUD()			bfin_read16(SPI1_BAUD)
+#define bfin_write_SPI1_BAUD(val)		bfin_write16(SPI1_BAUD, val)
+#define bfin_read_SPI1_SHADOW()			bfin_read16(SPI1_SHADOW)
+#define bfin_write_SPI1_SHADOW(val)		bfin_write16(SPI1_SHADOW, val)
+
+/* SPORT2 Registers */
+
+#define bfin_read_SPORT2_TCR1()			bfin_read16(SPORT2_TCR1)
+#define bfin_write_SPORT2_TCR1(val)		bfin_write16(SPORT2_TCR1, val)
+#define bfin_read_SPORT2_TCR2()			bfin_read16(SPORT2_TCR2)
+#define bfin_write_SPORT2_TCR2(val)		bfin_write16(SPORT2_TCR2, val)
+#define bfin_read_SPORT2_TCLKDIV()		bfin_read16(SPORT2_TCLKDIV)
+#define bfin_write_SPORT2_TCLKDIV(val)		bfin_write16(SPORT2_TCLKDIV, val)
+#define bfin_read_SPORT2_TFSDIV()		bfin_read16(SPORT2_TFSDIV)
+#define bfin_write_SPORT2_TFSDIV(val)		bfin_write16(SPORT2_TFSDIV, val)
+#define bfin_read_SPORT2_TX()			bfin_read32(SPORT2_TX)
+#define bfin_write_SPORT2_TX(val)		bfin_write32(SPORT2_TX, val)
+#define bfin_read_SPORT2_RX()			bfin_read32(SPORT2_RX)
+#define bfin_write_SPORT2_RX(val)		bfin_write32(SPORT2_RX, val)
+#define bfin_read_SPORT2_RCR1()			bfin_read16(SPORT2_RCR1)
+#define bfin_write_SPORT2_RCR1(val)		bfin_write16(SPORT2_RCR1, val)
+#define bfin_read_SPORT2_RCR2()			bfin_read16(SPORT2_RCR2)
+#define bfin_write_SPORT2_RCR2(val)		bfin_write16(SPORT2_RCR2, val)
+#define bfin_read_SPORT2_RCLKDIV()		bfin_read16(SPORT2_RCLKDIV)
+#define bfin_write_SPORT2_RCLKDIV(val)		bfin_write16(SPORT2_RCLKDIV, val)
+#define bfin_read_SPORT2_RFSDIV()		bfin_read16(SPORT2_RFSDIV)
+#define bfin_write_SPORT2_RFSDIV(val)		bfin_write16(SPORT2_RFSDIV, val)
+#define bfin_read_SPORT2_STAT()			bfin_read16(SPORT2_STAT)
+#define bfin_write_SPORT2_STAT(val)		bfin_write16(SPORT2_STAT, val)
+#define bfin_read_SPORT2_CHNL()			bfin_read16(SPORT2_CHNL)
+#define bfin_write_SPORT2_CHNL(val)		bfin_write16(SPORT2_CHNL, val)
+#define bfin_read_SPORT2_MCMC1()		bfin_read16(SPORT2_MCMC1)
+#define bfin_write_SPORT2_MCMC1(val)		bfin_write16(SPORT2_MCMC1, val)
+#define bfin_read_SPORT2_MCMC2()		bfin_read16(SPORT2_MCMC2)
+#define bfin_write_SPORT2_MCMC2(val)		bfin_write16(SPORT2_MCMC2, val)
+#define bfin_read_SPORT2_MTCS0()		bfin_read32(SPORT2_MTCS0)
+#define bfin_write_SPORT2_MTCS0(val)		bfin_write32(SPORT2_MTCS0, val)
+#define bfin_read_SPORT2_MTCS1()		bfin_read32(SPORT2_MTCS1)
+#define bfin_write_SPORT2_MTCS1(val)		bfin_write32(SPORT2_MTCS1, val)
+#define bfin_read_SPORT2_MTCS2()		bfin_read32(SPORT2_MTCS2)
+#define bfin_write_SPORT2_MTCS2(val)		bfin_write32(SPORT2_MTCS2, val)
+#define bfin_read_SPORT2_MTCS3()		bfin_read32(SPORT2_MTCS3)
+#define bfin_write_SPORT2_MTCS3(val)		bfin_write32(SPORT2_MTCS3, val)
+#define bfin_read_SPORT2_MRCS0()		bfin_read32(SPORT2_MRCS0)
+#define bfin_write_SPORT2_MRCS0(val)		bfin_write32(SPORT2_MRCS0, val)
+#define bfin_read_SPORT2_MRCS1()		bfin_read32(SPORT2_MRCS1)
+#define bfin_write_SPORT2_MRCS1(val)		bfin_write32(SPORT2_MRCS1, val)
+#define bfin_read_SPORT2_MRCS2()		bfin_read32(SPORT2_MRCS2)
+#define bfin_write_SPORT2_MRCS2(val)		bfin_write32(SPORT2_MRCS2, val)
+#define bfin_read_SPORT2_MRCS3()		bfin_read32(SPORT2_MRCS3)
+#define bfin_write_SPORT2_MRCS3(val)		bfin_write32(SPORT2_MRCS3, val)
+
+/* SPORT3 Registers */
+
+#define bfin_read_SPORT3_TCR1()			bfin_read16(SPORT3_TCR1)
+#define bfin_write_SPORT3_TCR1(val)		bfin_write16(SPORT3_TCR1, val)
+#define bfin_read_SPORT3_TCR2()			bfin_read16(SPORT3_TCR2)
+#define bfin_write_SPORT3_TCR2(val)		bfin_write16(SPORT3_TCR2, val)
+#define bfin_read_SPORT3_TCLKDIV()		bfin_read16(SPORT3_TCLKDIV)
+#define bfin_write_SPORT3_TCLKDIV(val)		bfin_write16(SPORT3_TCLKDIV, val)
+#define bfin_read_SPORT3_TFSDIV()		bfin_read16(SPORT3_TFSDIV)
+#define bfin_write_SPORT3_TFSDIV(val)		bfin_write16(SPORT3_TFSDIV, val)
+#define bfin_read_SPORT3_TX()			bfin_read32(SPORT3_TX)
+#define bfin_write_SPORT3_TX(val)		bfin_write32(SPORT3_TX, val)
+#define bfin_read_SPORT3_RX()			bfin_read32(SPORT3_RX)
+#define bfin_write_SPORT3_RX(val)		bfin_write32(SPORT3_RX, val)
+#define bfin_read_SPORT3_RCR1()			bfin_read16(SPORT3_RCR1)
+#define bfin_write_SPORT3_RCR1(val)		bfin_write16(SPORT3_RCR1, val)
+#define bfin_read_SPORT3_RCR2()			bfin_read16(SPORT3_RCR2)
+#define bfin_write_SPORT3_RCR2(val)		bfin_write16(SPORT3_RCR2, val)
+#define bfin_read_SPORT3_RCLKDIV()		bfin_read16(SPORT3_RCLKDIV)
+#define bfin_write_SPORT3_RCLKDIV(val)		bfin_write16(SPORT3_RCLKDIV, val)
+#define bfin_read_SPORT3_RFSDIV()		bfin_read16(SPORT3_RFSDIV)
+#define bfin_write_SPORT3_RFSDIV(val)		bfin_write16(SPORT3_RFSDIV, val)
+#define bfin_read_SPORT3_STAT()			bfin_read16(SPORT3_STAT)
+#define bfin_write_SPORT3_STAT(val)		bfin_write16(SPORT3_STAT, val)
+#define bfin_read_SPORT3_CHNL()			bfin_read16(SPORT3_CHNL)
+#define bfin_write_SPORT3_CHNL(val)		bfin_write16(SPORT3_CHNL, val)
+#define bfin_read_SPORT3_MCMC1()		bfin_read16(SPORT3_MCMC1)
+#define bfin_write_SPORT3_MCMC1(val)		bfin_write16(SPORT3_MCMC1, val)
+#define bfin_read_SPORT3_MCMC2()		bfin_read16(SPORT3_MCMC2)
+#define bfin_write_SPORT3_MCMC2(val)		bfin_write16(SPORT3_MCMC2, val)
+#define bfin_read_SPORT3_MTCS0()		bfin_read32(SPORT3_MTCS0)
+#define bfin_write_SPORT3_MTCS0(val)		bfin_write32(SPORT3_MTCS0, val)
+#define bfin_read_SPORT3_MTCS1()		bfin_read32(SPORT3_MTCS1)
+#define bfin_write_SPORT3_MTCS1(val)		bfin_write32(SPORT3_MTCS1, val)
+#define bfin_read_SPORT3_MTCS2()		bfin_read32(SPORT3_MTCS2)
+#define bfin_write_SPORT3_MTCS2(val)		bfin_write32(SPORT3_MTCS2, val)
+#define bfin_read_SPORT3_MTCS3()		bfin_read32(SPORT3_MTCS3)
+#define bfin_write_SPORT3_MTCS3(val)		bfin_write32(SPORT3_MTCS3, val)
+#define bfin_read_SPORT3_MRCS0()		bfin_read32(SPORT3_MRCS0)
+#define bfin_write_SPORT3_MRCS0(val)		bfin_write32(SPORT3_MRCS0, val)
+#define bfin_read_SPORT3_MRCS1()		bfin_read32(SPORT3_MRCS1)
+#define bfin_write_SPORT3_MRCS1(val)		bfin_write32(SPORT3_MRCS1, val)
+#define bfin_read_SPORT3_MRCS2()		bfin_read32(SPORT3_MRCS2)
+#define bfin_write_SPORT3_MRCS2(val)		bfin_write32(SPORT3_MRCS2, val)
+#define bfin_read_SPORT3_MRCS3()		bfin_read32(SPORT3_MRCS3)
+#define bfin_write_SPORT3_MRCS3(val)		bfin_write32(SPORT3_MRCS3, val)
+
+/* EPPI2 Registers */
+
+#define bfin_read_EPPI2_STATUS()		bfin_read16(EPPI2_STATUS)
+#define bfin_write_EPPI2_STATUS(val)		bfin_write16(EPPI2_STATUS, val)
+#define bfin_read_EPPI2_HCOUNT()		bfin_read16(EPPI2_HCOUNT)
+#define bfin_write_EPPI2_HCOUNT(val)		bfin_write16(EPPI2_HCOUNT, val)
+#define bfin_read_EPPI2_HDELAY()		bfin_read16(EPPI2_HDELAY)
+#define bfin_write_EPPI2_HDELAY(val)		bfin_write16(EPPI2_HDELAY, val)
+#define bfin_read_EPPI2_VCOUNT()		bfin_read16(EPPI2_VCOUNT)
+#define bfin_write_EPPI2_VCOUNT(val)		bfin_write16(EPPI2_VCOUNT, val)
+#define bfin_read_EPPI2_VDELAY()		bfin_read16(EPPI2_VDELAY)
+#define bfin_write_EPPI2_VDELAY(val)		bfin_write16(EPPI2_VDELAY, val)
+#define bfin_read_EPPI2_FRAME()			bfin_read16(EPPI2_FRAME)
+#define bfin_write_EPPI2_FRAME(val)		bfin_write16(EPPI2_FRAME, val)
+#define bfin_read_EPPI2_LINE()			bfin_read16(EPPI2_LINE)
+#define bfin_write_EPPI2_LINE(val)		bfin_write16(EPPI2_LINE, val)
+#define bfin_read_EPPI2_CLKDIV()		bfin_read16(EPPI2_CLKDIV)
+#define bfin_write_EPPI2_CLKDIV(val)		bfin_write16(EPPI2_CLKDIV, val)
+#define bfin_read_EPPI2_CONTROL()		bfin_read32(EPPI2_CONTROL)
+#define bfin_write_EPPI2_CONTROL(val)		bfin_write32(EPPI2_CONTROL, val)
+#define bfin_read_EPPI2_FS1W_HBL()		bfin_read32(EPPI2_FS1W_HBL)
+#define bfin_write_EPPI2_FS1W_HBL(val)		bfin_write32(EPPI2_FS1W_HBL, val)
+#define bfin_read_EPPI2_FS1P_AVPL()		bfin_read32(EPPI2_FS1P_AVPL)
+#define bfin_write_EPPI2_FS1P_AVPL(val)		bfin_write32(EPPI2_FS1P_AVPL, val)
+#define bfin_read_EPPI2_FS2W_LVB()		bfin_read32(EPPI2_FS2W_LVB)
+#define bfin_write_EPPI2_FS2W_LVB(val)		bfin_write32(EPPI2_FS2W_LVB, val)
+#define bfin_read_EPPI2_FS2P_LAVF()		bfin_read32(EPPI2_FS2P_LAVF)
+#define bfin_write_EPPI2_FS2P_LAVF(val)		bfin_write32(EPPI2_FS2P_LAVF, val)
+#define bfin_read_EPPI2_CLIP()			bfin_read32(EPPI2_CLIP)
+#define bfin_write_EPPI2_CLIP(val)		bfin_write32(EPPI2_CLIP, val)
+
+/* CAN Controller 0 Config 1 Registers */
+
+#define bfin_read_CAN0_MC1()		bfin_read16(CAN0_MC1)
+#define bfin_write_CAN0_MC1(val)	bfin_write16(CAN0_MC1, val)
+#define bfin_read_CAN0_MD1()		bfin_read16(CAN0_MD1)
+#define bfin_write_CAN0_MD1(val)	bfin_write16(CAN0_MD1, val)
+#define bfin_read_CAN0_TRS1()		bfin_read16(CAN0_TRS1)
+#define bfin_write_CAN0_TRS1(val)	bfin_write16(CAN0_TRS1, val)
+#define bfin_read_CAN0_TRR1()		bfin_read16(CAN0_TRR1)
+#define bfin_write_CAN0_TRR1(val)	bfin_write16(CAN0_TRR1, val)
+#define bfin_read_CAN0_TA1()		bfin_read16(CAN0_TA1)
+#define bfin_write_CAN0_TA1(val)	bfin_write16(CAN0_TA1, val)
+#define bfin_read_CAN0_AA1()		bfin_read16(CAN0_AA1)
+#define bfin_write_CAN0_AA1(val)	bfin_write16(CAN0_AA1, val)
+#define bfin_read_CAN0_RMP1()		bfin_read16(CAN0_RMP1)
+#define bfin_write_CAN0_RMP1(val)	bfin_write16(CAN0_RMP1, val)
+#define bfin_read_CAN0_RML1()		bfin_read16(CAN0_RML1)
+#define bfin_write_CAN0_RML1(val)	bfin_write16(CAN0_RML1, val)
+#define bfin_read_CAN0_MBTIF1()		bfin_read16(CAN0_MBTIF1)
+#define bfin_write_CAN0_MBTIF1(val)	bfin_write16(CAN0_MBTIF1, val)
+#define bfin_read_CAN0_MBRIF1()		bfin_read16(CAN0_MBRIF1)
+#define bfin_write_CAN0_MBRIF1(val)	bfin_write16(CAN0_MBRIF1, val)
+#define bfin_read_CAN0_MBIM1()		bfin_read16(CAN0_MBIM1)
+#define bfin_write_CAN0_MBIM1(val)	bfin_write16(CAN0_MBIM1, val)
+#define bfin_read_CAN0_RFH1()		bfin_read16(CAN0_RFH1)
+#define bfin_write_CAN0_RFH1(val)	bfin_write16(CAN0_RFH1, val)
+#define bfin_read_CAN0_OPSS1()		bfin_read16(CAN0_OPSS1)
+#define bfin_write_CAN0_OPSS1(val)	bfin_write16(CAN0_OPSS1, val)
+
+/* CAN Controller 0 Config 2 Registers */
+
+#define bfin_read_CAN0_MC2()		bfin_read16(CAN0_MC2)
+#define bfin_write_CAN0_MC2(val)	bfin_write16(CAN0_MC2, val)
+#define bfin_read_CAN0_MD2()		bfin_read16(CAN0_MD2)
+#define bfin_write_CAN0_MD2(val)	bfin_write16(CAN0_MD2, val)
+#define bfin_read_CAN0_TRS2()		bfin_read16(CAN0_TRS2)
+#define bfin_write_CAN0_TRS2(val)	bfin_write16(CAN0_TRS2, val)
+#define bfin_read_CAN0_TRR2()		bfin_read16(CAN0_TRR2)
+#define bfin_write_CAN0_TRR2(val)	bfin_write16(CAN0_TRR2, val)
+#define bfin_read_CAN0_TA2()		bfin_read16(CAN0_TA2)
+#define bfin_write_CAN0_TA2(val)	bfin_write16(CAN0_TA2, val)
+#define bfin_read_CAN0_AA2()		bfin_read16(CAN0_AA2)
+#define bfin_write_CAN0_AA2(val)	bfin_write16(CAN0_AA2, val)
+#define bfin_read_CAN0_RMP2()		bfin_read16(CAN0_RMP2)
+#define bfin_write_CAN0_RMP2(val)	bfin_write16(CAN0_RMP2, val)
+#define bfin_read_CAN0_RML2()		bfin_read16(CAN0_RML2)
+#define bfin_write_CAN0_RML2(val)	bfin_write16(CAN0_RML2, val)
+#define bfin_read_CAN0_MBTIF2()		bfin_read16(CAN0_MBTIF2)
+#define bfin_write_CAN0_MBTIF2(val)	bfin_write16(CAN0_MBTIF2, val)
+#define bfin_read_CAN0_MBRIF2()		bfin_read16(CAN0_MBRIF2)
+#define bfin_write_CAN0_MBRIF2(val)	bfin_write16(CAN0_MBRIF2, val)
+#define bfin_read_CAN0_MBIM2()		bfin_read16(CAN0_MBIM2)
+#define bfin_write_CAN0_MBIM2(val)	bfin_write16(CAN0_MBIM2, val)
+#define bfin_read_CAN0_RFH2()		bfin_read16(CAN0_RFH2)
+#define bfin_write_CAN0_RFH2(val)	bfin_write16(CAN0_RFH2, val)
+#define bfin_read_CAN0_OPSS2()		bfin_read16(CAN0_OPSS2)
+#define bfin_write_CAN0_OPSS2(val)	bfin_write16(CAN0_OPSS2, val)
+
+/* CAN Controller 0 Clock/Interrubfin_read_()t/Counter Registers */
+
+#define bfin_read_CAN0_CLOCK()		bfin_read16(CAN0_CLOCK)
+#define bfin_write_CAN0_CLOCK(val)	bfin_write16(CAN0_CLOCK, val)
+#define bfin_read_CAN0_TIMING()		bfin_read16(CAN0_TIMING)
+#define bfin_write_CAN0_TIMING(val)	bfin_write16(CAN0_TIMING, val)
+#define bfin_read_CAN0_DEBUG()		bfin_read16(CAN0_DEBUG)
+#define bfin_write_CAN0_DEBUG(val)	bfin_write16(CAN0_DEBUG, val)
+#define bfin_read_CAN0_STATUS()		bfin_read16(CAN0_STATUS)
+#define bfin_write_CAN0_STATUS(val)	bfin_write16(CAN0_STATUS, val)
+#define bfin_read_CAN0_CEC()		bfin_read16(CAN0_CEC)
+#define bfin_write_CAN0_CEC(val)	bfin_write16(CAN0_CEC, val)
+#define bfin_read_CAN0_GIS()		bfin_read16(CAN0_GIS)
+#define bfin_write_CAN0_GIS(val)	bfin_write16(CAN0_GIS, val)
+#define bfin_read_CAN0_GIM()		bfin_read16(CAN0_GIM)
+#define bfin_write_CAN0_GIM(val)	bfin_write16(CAN0_GIM, val)
+#define bfin_read_CAN0_GIF()		bfin_read16(CAN0_GIF)
+#define bfin_write_CAN0_GIF(val)	bfin_write16(CAN0_GIF, val)
+#define bfin_read_CAN0_CONTROL()	bfin_read16(CAN0_CONTROL)
+#define bfin_write_CAN0_CONTROL(val)	bfin_write16(CAN0_CONTROL, val)
+#define bfin_read_CAN0_INTR()		bfin_read16(CAN0_INTR)
+#define bfin_write_CAN0_INTR(val)	bfin_write16(CAN0_INTR, val)
+#define bfin_read_CAN0_MBTD()		bfin_read16(CAN0_MBTD)
+#define bfin_write_CAN0_MBTD(val)	bfin_write16(CAN0_MBTD, val)
+#define bfin_read_CAN0_EWR()		bfin_read16(CAN0_EWR)
+#define bfin_write_CAN0_EWR(val)	bfin_write16(CAN0_EWR, val)
+#define bfin_read_CAN0_ESR()		bfin_read16(CAN0_ESR)
+#define bfin_write_CAN0_ESR(val)	bfin_write16(CAN0_ESR, val)
+#define bfin_read_CAN0_UCCNT()		bfin_read16(CAN0_UCCNT)
+#define bfin_write_CAN0_UCCNT(val)	bfin_write16(CAN0_UCCNT, val)
+#define bfin_read_CAN0_UCRC()		bfin_read16(CAN0_UCRC)
+#define bfin_write_CAN0_UCRC(val)	bfin_write16(CAN0_UCRC, val)
+#define bfin_read_CAN0_UCCNF()		bfin_read16(CAN0_UCCNF)
+#define bfin_write_CAN0_UCCNF(val)	bfin_write16(CAN0_UCCNF, val)
+
+/* CAN Controller 0 Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN0_AM00L()		bfin_read16(CAN0_AM00L)
+#define bfin_write_CAN0_AM00L(val)	bfin_write16(CAN0_AM00L, val)
+#define bfin_read_CAN0_AM00H()		bfin_read16(CAN0_AM00H)
+#define bfin_write_CAN0_AM00H(val)	bfin_write16(CAN0_AM00H, val)
+#define bfin_read_CAN0_AM01L()		bfin_read16(CAN0_AM01L)
+#define bfin_write_CAN0_AM01L(val)	bfin_write16(CAN0_AM01L, val)
+#define bfin_read_CAN0_AM01H()		bfin_read16(CAN0_AM01H)
+#define bfin_write_CAN0_AM01H(val)	bfin_write16(CAN0_AM01H, val)
+#define bfin_read_CAN0_AM02L()		bfin_read16(CAN0_AM02L)
+#define bfin_write_CAN0_AM02L(val)	bfin_write16(CAN0_AM02L, val)
+#define bfin_read_CAN0_AM02H()		bfin_read16(CAN0_AM02H)
+#define bfin_write_CAN0_AM02H(val)	bfin_write16(CAN0_AM02H, val)
+#define bfin_read_CAN0_AM03L()		bfin_read16(CAN0_AM03L)
+#define bfin_write_CAN0_AM03L(val)	bfin_write16(CAN0_AM03L, val)
+#define bfin_read_CAN0_AM03H()		bfin_read16(CAN0_AM03H)
+#define bfin_write_CAN0_AM03H(val)	bfin_write16(CAN0_AM03H, val)
+#define bfin_read_CAN0_AM04L()		bfin_read16(CAN0_AM04L)
+#define bfin_write_CAN0_AM04L(val)	bfin_write16(CAN0_AM04L, val)
+#define bfin_read_CAN0_AM04H()		bfin_read16(CAN0_AM04H)
+#define bfin_write_CAN0_AM04H(val)	bfin_write16(CAN0_AM04H, val)
+#define bfin_read_CAN0_AM05L()		bfin_read16(CAN0_AM05L)
+#define bfin_write_CAN0_AM05L(val)	bfin_write16(CAN0_AM05L, val)
+#define bfin_read_CAN0_AM05H()		bfin_read16(CAN0_AM05H)
+#define bfin_write_CAN0_AM05H(val)	bfin_write16(CAN0_AM05H, val)
+#define bfin_read_CAN0_AM06L()		bfin_read16(CAN0_AM06L)
+#define bfin_write_CAN0_AM06L(val)	bfin_write16(CAN0_AM06L, val)
+#define bfin_read_CAN0_AM06H()		bfin_read16(CAN0_AM06H)
+#define bfin_write_CAN0_AM06H(val)	bfin_write16(CAN0_AM06H, val)
+#define bfin_read_CAN0_AM07L()		bfin_read16(CAN0_AM07L)
+#define bfin_write_CAN0_AM07L(val)	bfin_write16(CAN0_AM07L, val)
+#define bfin_read_CAN0_AM07H()		bfin_read16(CAN0_AM07H)
+#define bfin_write_CAN0_AM07H(val)	bfin_write16(CAN0_AM07H, val)
+#define bfin_read_CAN0_AM08L()		bfin_read16(CAN0_AM08L)
+#define bfin_write_CAN0_AM08L(val)	bfin_write16(CAN0_AM08L, val)
+#define bfin_read_CAN0_AM08H()		bfin_read16(CAN0_AM08H)
+#define bfin_write_CAN0_AM08H(val)	bfin_write16(CAN0_AM08H, val)
+#define bfin_read_CAN0_AM09L()		bfin_read16(CAN0_AM09L)
+#define bfin_write_CAN0_AM09L(val)	bfin_write16(CAN0_AM09L, val)
+#define bfin_read_CAN0_AM09H()		bfin_read16(CAN0_AM09H)
+#define bfin_write_CAN0_AM09H(val)	bfin_write16(CAN0_AM09H, val)
+#define bfin_read_CAN0_AM10L()		bfin_read16(CAN0_AM10L)
+#define bfin_write_CAN0_AM10L(val)	bfin_write16(CAN0_AM10L, val)
+#define bfin_read_CAN0_AM10H()		bfin_read16(CAN0_AM10H)
+#define bfin_write_CAN0_AM10H(val)	bfin_write16(CAN0_AM10H, val)
+#define bfin_read_CAN0_AM11L()		bfin_read16(CAN0_AM11L)
+#define bfin_write_CAN0_AM11L(val)	bfin_write16(CAN0_AM11L, val)
+#define bfin_read_CAN0_AM11H()		bfin_read16(CAN0_AM11H)
+#define bfin_write_CAN0_AM11H(val)	bfin_write16(CAN0_AM11H, val)
+#define bfin_read_CAN0_AM12L()		bfin_read16(CAN0_AM12L)
+#define bfin_write_CAN0_AM12L(val)	bfin_write16(CAN0_AM12L, val)
+#define bfin_read_CAN0_AM12H()		bfin_read16(CAN0_AM12H)
+#define bfin_write_CAN0_AM12H(val)	bfin_write16(CAN0_AM12H, val)
+#define bfin_read_CAN0_AM13L()		bfin_read16(CAN0_AM13L)
+#define bfin_write_CAN0_AM13L(val)	bfin_write16(CAN0_AM13L, val)
+#define bfin_read_CAN0_AM13H()		bfin_read16(CAN0_AM13H)
+#define bfin_write_CAN0_AM13H(val)	bfin_write16(CAN0_AM13H, val)
+#define bfin_read_CAN0_AM14L()		bfin_read16(CAN0_AM14L)
+#define bfin_write_CAN0_AM14L(val)	bfin_write16(CAN0_AM14L, val)
+#define bfin_read_CAN0_AM14H()		bfin_read16(CAN0_AM14H)
+#define bfin_write_CAN0_AM14H(val)	bfin_write16(CAN0_AM14H, val)
+#define bfin_read_CAN0_AM15L()		bfin_read16(CAN0_AM15L)
+#define bfin_write_CAN0_AM15L(val)	bfin_write16(CAN0_AM15L, val)
+#define bfin_read_CAN0_AM15H()		bfin_read16(CAN0_AM15H)
+#define bfin_write_CAN0_AM15H(val)	bfin_write16(CAN0_AM15H, val)
+
+/* CAN Controller 0 Accebfin_read_()tance Registers */
+
+#define bfin_read_CAN0_AM16L()		bfin_read16(CAN0_AM16L)
+#define bfin_write_CAN0_AM16L(val)	bfin_write16(CAN0_AM16L, val)
+#define bfin_read_CAN0_AM16H()		bfin_read16(CAN0_AM16H)
+#define bfin_write_CAN0_AM16H(val)	bfin_write16(CAN0_AM16H, val)
+#define bfin_read_CAN0_AM17L()		bfin_read16(CAN0_AM17L)
+#define bfin_write_CAN0_AM17L(val)	bfin_write16(CAN0_AM17L, val)
+#define bfin_read_CAN0_AM17H()		bfin_read16(CAN0_AM17H)
+#define bfin_write_CAN0_AM17H(val)	bfin_write16(CAN0_AM17H, val)
+#define bfin_read_CAN0_AM18L()		bfin_read16(CAN0_AM18L)
+#define bfin_write_CAN0_AM18L(val)	bfin_write16(CAN0_AM18L, val)
+#define bfin_read_CAN0_AM18H()		bfin_read16(CAN0_AM18H)
+#define bfin_write_CAN0_AM18H(val)	bfin_write16(CAN0_AM18H, val)
+#define bfin_read_CAN0_AM19L()		bfin_read16(CAN0_AM19L)
+#define bfin_write_CAN0_AM19L(val)	bfin_write16(CAN0_AM19L, val)
+#define bfin_read_CAN0_AM19H()		bfin_read16(CAN0_AM19H)
+#define bfin_write_CAN0_AM19H(val)	bfin_write16(CAN0_AM19H, val)
+#define bfin_read_CAN0_AM20L()		bfin_read16(CAN0_AM20L)
+#define bfin_write_CAN0_AM20L(val)	bfin_write16(CAN0_AM20L, val)
+#define bfin_read_CAN0_AM20H()		bfin_read16(CAN0_AM20H)
+#define bfin_write_CAN0_AM20H(val)	bfin_write16(CAN0_AM20H, val)
+#define bfin_read_CAN0_AM21L()		bfin_read16(CAN0_AM21L)
+#define bfin_write_CAN0_AM21L(val)	bfin_write16(CAN0_AM21L, val)
+#define bfin_read_CAN0_AM21H()		bfin_read16(CAN0_AM21H)
+#define bfin_write_CAN0_AM21H(val)	bfin_write16(CAN0_AM21H, val)
+#define bfin_read_CAN0_AM22L()		bfin_read16(CAN0_AM22L)
+#define bfin_write_CAN0_AM22L(val)	bfin_write16(CAN0_AM22L, val)
+#define bfin_read_CAN0_AM22H()		bfin_read16(CAN0_AM22H)
+#define bfin_write_CAN0_AM22H(val)	bfin_write16(CAN0_AM22H, val)
+#define bfin_read_CAN0_AM23L()		bfin_read16(CAN0_AM23L)
+#define bfin_write_CAN0_AM23L(val)	bfin_write16(CAN0_AM23L, val)
+#define bfin_read_CAN0_AM23H()		bfin_read16(CAN0_AM23H)
+#define bfin_write_CAN0_AM23H(val)	bfin_write16(CAN0_AM23H, val)
+#define bfin_read_CAN0_AM24L()		bfin_read16(CAN0_AM24L)
+#define bfin_write_CAN0_AM24L(val)	bfin_write16(CAN0_AM24L, val)
+#define bfin_read_CAN0_AM24H()		bfin_read16(CAN0_AM24H)
+#define bfin_write_CAN0_AM24H(val)	bfin_write16(CAN0_AM24H, val)
+#define bfin_read_CAN0_AM25L()		bfin_read16(CAN0_AM25L)
+#define bfin_write_CAN0_AM25L(val)	bfin_write16(CAN0_AM25L, val)
+#define bfin_read_CAN0_AM25H()		bfin_read16(CAN0_AM25H)
+#define bfin_write_CAN0_AM25H(val)	bfin_write16(CAN0_AM25H, val)
+#define bfin_read_CAN0_AM26L()		bfin_read16(CAN0_AM26L)
+#define bfin_write_CAN0_AM26L(val)	bfin_write16(CAN0_AM26L, val)
+#define bfin_read_CAN0_AM26H()		bfin_read16(CAN0_AM26H)
+#define bfin_write_CAN0_AM26H(val)	bfin_write16(CAN0_AM26H, val)
+#define bfin_read_CAN0_AM27L()		bfin_read16(CAN0_AM27L)
+#define bfin_write_CAN0_AM27L(val)	bfin_write16(CAN0_AM27L, val)
+#define bfin_read_CAN0_AM27H()		bfin_read16(CAN0_AM27H)
+#define bfin_write_CAN0_AM27H(val)	bfin_write16(CAN0_AM27H, val)
+#define bfin_read_CAN0_AM28L()		bfin_read16(CAN0_AM28L)
+#define bfin_write_CAN0_AM28L(val)	bfin_write16(CAN0_AM28L, val)
+#define bfin_read_CAN0_AM28H()		bfin_read16(CAN0_AM28H)
+#define bfin_write_CAN0_AM28H(val)	bfin_write16(CAN0_AM28H, val)
+#define bfin_read_CAN0_AM29L()		bfin_read16(CAN0_AM29L)
+#define bfin_write_CAN0_AM29L(val)	bfin_write16(CAN0_AM29L, val)
+#define bfin_read_CAN0_AM29H()		bfin_read16(CAN0_AM29H)
+#define bfin_write_CAN0_AM29H(val)	bfin_write16(CAN0_AM29H, val)
+#define bfin_read_CAN0_AM30L()		bfin_read16(CAN0_AM30L)
+#define bfin_write_CAN0_AM30L(val)	bfin_write16(CAN0_AM30L, val)
+#define bfin_read_CAN0_AM30H()		bfin_read16(CAN0_AM30H)
+#define bfin_write_CAN0_AM30H(val)	bfin_write16(CAN0_AM30H, val)
+#define bfin_read_CAN0_AM31L()		bfin_read16(CAN0_AM31L)
+#define bfin_write_CAN0_AM31L(val)	bfin_write16(CAN0_AM31L, val)
+#define bfin_read_CAN0_AM31H()		bfin_read16(CAN0_AM31H)
+#define bfin_write_CAN0_AM31H(val)	bfin_write16(CAN0_AM31H, val)
+
+/* CAN Controller 0 Mailbox Data Registers */
+
+#define bfin_read_CAN0_MB00_DATA0()		bfin_read16(CAN0_MB00_DATA0)
+#define bfin_write_CAN0_MB00_DATA0(val)		bfin_write16(CAN0_MB00_DATA0, val)
+#define bfin_read_CAN0_MB00_DATA1()		bfin_read16(CAN0_MB00_DATA1)
+#define bfin_write_CAN0_MB00_DATA1(val)		bfin_write16(CAN0_MB00_DATA1, val)
+#define bfin_read_CAN0_MB00_DATA2()		bfin_read16(CAN0_MB00_DATA2)
+#define bfin_write_CAN0_MB00_DATA2(val)		bfin_write16(CAN0_MB00_DATA2, val)
+#define bfin_read_CAN0_MB00_DATA3()		bfin_read16(CAN0_MB00_DATA3)
+#define bfin_write_CAN0_MB00_DATA3(val)		bfin_write16(CAN0_MB00_DATA3, val)
+#define bfin_read_CAN0_MB00_LENGTH()		bfin_read16(CAN0_MB00_LENGTH)
+#define bfin_write_CAN0_MB00_LENGTH(val)	bfin_write16(CAN0_MB00_LENGTH, val)
+#define bfin_read_CAN0_MB00_TIMESTAMP()		bfin_read16(CAN0_MB00_TIMESTAMP)
+#define bfin_write_CAN0_MB00_TIMESTAMP(val)	bfin_write16(CAN0_MB00_TIMESTAMP, val)
+#define bfin_read_CAN0_MB00_ID0()		bfin_read16(CAN0_MB00_ID0)
+#define bfin_write_CAN0_MB00_ID0(val)		bfin_write16(CAN0_MB00_ID0, val)
+#define bfin_read_CAN0_MB00_ID1()		bfin_read16(CAN0_MB00_ID1)
+#define bfin_write_CAN0_MB00_ID1(val)		bfin_write16(CAN0_MB00_ID1, val)
+#define bfin_read_CAN0_MB01_DATA0()		bfin_read16(CAN0_MB01_DATA0)
+#define bfin_write_CAN0_MB01_DATA0(val)		bfin_write16(CAN0_MB01_DATA0, val)
+#define bfin_read_CAN0_MB01_DATA1()		bfin_read16(CAN0_MB01_DATA1)
+#define bfin_write_CAN0_MB01_DATA1(val)		bfin_write16(CAN0_MB01_DATA1, val)
+#define bfin_read_CAN0_MB01_DATA2()		bfin_read16(CAN0_MB01_DATA2)
+#define bfin_write_CAN0_MB01_DATA2(val)		bfin_write16(CAN0_MB01_DATA2, val)
+#define bfin_read_CAN0_MB01_DATA3()		bfin_read16(CAN0_MB01_DATA3)
+#define bfin_write_CAN0_MB01_DATA3(val)		bfin_write16(CAN0_MB01_DATA3, val)
+#define bfin_read_CAN0_MB01_LENGTH()		bfin_read16(CAN0_MB01_LENGTH)
+#define bfin_write_CAN0_MB01_LENGTH(val)	bfin_write16(CAN0_MB01_LENGTH, val)
+#define bfin_read_CAN0_MB01_TIMESTAMP()		bfin_read16(CAN0_MB01_TIMESTAMP)
+#define bfin_write_CAN0_MB01_TIMESTAMP(val)	bfin_write16(CAN0_MB01_TIMESTAMP, val)
+#define bfin_read_CAN0_MB01_ID0()		bfin_read16(CAN0_MB01_ID0)
+#define bfin_write_CAN0_MB01_ID0(val)		bfin_write16(CAN0_MB01_ID0, val)
+#define bfin_read_CAN0_MB01_ID1()		bfin_read16(CAN0_MB01_ID1)
+#define bfin_write_CAN0_MB01_ID1(val)		bfin_write16(CAN0_MB01_ID1, val)
+#define bfin_read_CAN0_MB02_DATA0()		bfin_read16(CAN0_MB02_DATA0)
+#define bfin_write_CAN0_MB02_DATA0(val)		bfin_write16(CAN0_MB02_DATA0, val)
+#define bfin_read_CAN0_MB02_DATA1()		bfin_read16(CAN0_MB02_DATA1)
+#define bfin_write_CAN0_MB02_DATA1(val)		bfin_write16(CAN0_MB02_DATA1, val)
+#define bfin_read_CAN0_MB02_DATA2()		bfin_read16(CAN0_MB02_DATA2)
+#define bfin_write_CAN0_MB02_DATA2(val)		bfin_write16(CAN0_MB02_DATA2, val)
+#define bfin_read_CAN0_MB02_DATA3()		bfin_read16(CAN0_MB02_DATA3)
+#define bfin_write_CAN0_MB02_DATA3(val)		bfin_write16(CAN0_MB02_DATA3, val)
+#define bfin_read_CAN0_MB02_LENGTH()		bfin_read16(CAN0_MB02_LENGTH)
+#define bfin_write_CAN0_MB02_LENGTH(val)	bfin_write16(CAN0_MB02_LENGTH, val)
+#define bfin_read_CAN0_MB02_TIMESTAMP()		bfin_read16(CAN0_MB02_TIMESTAMP)
+#define bfin_write_CAN0_MB02_TIMESTAMP(val)	bfin_write16(CAN0_MB02_TIMESTAMP, val)
+#define bfin_read_CAN0_MB02_ID0()		bfin_read16(CAN0_MB02_ID0)
+#define bfin_write_CAN0_MB02_ID0(val)		bfin_write16(CAN0_MB02_ID0, val)
+#define bfin_read_CAN0_MB02_ID1()		bfin_read16(CAN0_MB02_ID1)
+#define bfin_write_CAN0_MB02_ID1(val)		bfin_write16(CAN0_MB02_ID1, val)
+#define bfin_read_CAN0_MB03_DATA0()		bfin_read16(CAN0_MB03_DATA0)
+#define bfin_write_CAN0_MB03_DATA0(val)		bfin_write16(CAN0_MB03_DATA0, val)
+#define bfin_read_CAN0_MB03_DATA1()		bfin_read16(CAN0_MB03_DATA1)
+#define bfin_write_CAN0_MB03_DATA1(val)		bfin_write16(CAN0_MB03_DATA1, val)
+#define bfin_read_CAN0_MB03_DATA2()		bfin_read16(CAN0_MB03_DATA2)
+#define bfin_write_CAN0_MB03_DATA2(val)		bfin_write16(CAN0_MB03_DATA2, val)
+#define bfin_read_CAN0_MB03_DATA3()		bfin_read16(CAN0_MB03_DATA3)
+#define bfin_write_CAN0_MB03_DATA3(val)		bfin_write16(CAN0_MB03_DATA3, val)
+#define bfin_read_CAN0_MB03_LENGTH()		bfin_read16(CAN0_MB03_LENGTH)
+#define bfin_write_CAN0_MB03_LENGTH(val)	bfin_write16(CAN0_MB03_LENGTH, val)
+#define bfin_read_CAN0_MB03_TIMESTAMP()		bfin_read16(CAN0_MB03_TIMESTAMP)
+#define bfin_write_CAN0_MB03_TIMESTAMP(val)	bfin_write16(CAN0_MB03_TIMESTAMP, val)
+#define bfin_read_CAN0_MB03_ID0()		bfin_read16(CAN0_MB03_ID0)
+#define bfin_write_CAN0_MB03_ID0(val)		bfin_write16(CAN0_MB03_ID0, val)
+#define bfin_read_CAN0_MB03_ID1()		bfin_read16(CAN0_MB03_ID1)
+#define bfin_write_CAN0_MB03_ID1(val)		bfin_write16(CAN0_MB03_ID1, val)
+#define bfin_read_CAN0_MB04_DATA0()		bfin_read16(CAN0_MB04_DATA0)
+#define bfin_write_CAN0_MB04_DATA0(val)		bfin_write16(CAN0_MB04_DATA0, val)
+#define bfin_read_CAN0_MB04_DATA1()		bfin_read16(CAN0_MB04_DATA1)
+#define bfin_write_CAN0_MB04_DATA1(val)		bfin_write16(CAN0_MB04_DATA1, val)
+#define bfin_read_CAN0_MB04_DATA2()		bfin_read16(CAN0_MB04_DATA2)
+#define bfin_write_CAN0_MB04_DATA2(val)		bfin_write16(CAN0_MB04_DATA2, val)
+#define bfin_read_CAN0_MB04_DATA3()		bfin_read16(CAN0_MB04_DATA3)
+#define bfin_write_CAN0_MB04_DATA3(val)		bfin_write16(CAN0_MB04_DATA3, val)
+#define bfin_read_CAN0_MB04_LENGTH()		bfin_read16(CAN0_MB04_LENGTH)
+#define bfin_write_CAN0_MB04_LENGTH(val)	bfin_write16(CAN0_MB04_LENGTH, val)
+#define bfin_read_CAN0_MB04_TIMESTAMP()		bfin_read16(CAN0_MB04_TIMESTAMP)
+#define bfin_write_CAN0_MB04_TIMESTAMP(val)	bfin_write16(CAN0_MB04_TIMESTAMP, val)
+#define bfin_read_CAN0_MB04_ID0()		bfin_read16(CAN0_MB04_ID0)
+#define bfin_write_CAN0_MB04_ID0(val)		bfin_write16(CAN0_MB04_ID0, val)
+#define bfin_read_CAN0_MB04_ID1()		bfin_read16(CAN0_MB04_ID1)
+#define bfin_write_CAN0_MB04_ID1(val)		bfin_write16(CAN0_MB04_ID1, val)
+#define bfin_read_CAN0_MB05_DATA0()		bfin_read16(CAN0_MB05_DATA0)
+#define bfin_write_CAN0_MB05_DATA0(val)		bfin_write16(CAN0_MB05_DATA0, val)
+#define bfin_read_CAN0_MB05_DATA1()		bfin_read16(CAN0_MB05_DATA1)
+#define bfin_write_CAN0_MB05_DATA1(val)		bfin_write16(CAN0_MB05_DATA1, val)
+#define bfin_read_CAN0_MB05_DATA2()		bfin_read16(CAN0_MB05_DATA2)
+#define bfin_write_CAN0_MB05_DATA2(val)		bfin_write16(CAN0_MB05_DATA2, val)
+#define bfin_read_CAN0_MB05_DATA3()		bfin_read16(CAN0_MB05_DATA3)
+#define bfin_write_CAN0_MB05_DATA3(val)		bfin_write16(CAN0_MB05_DATA3, val)
+#define bfin_read_CAN0_MB05_LENGTH()		bfin_read16(CAN0_MB05_LENGTH)
+#define bfin_write_CAN0_MB05_LENGTH(val)	bfin_write16(CAN0_MB05_LENGTH, val)
+#define bfin_read_CAN0_MB05_TIMESTAMP()		bfin_read16(CAN0_MB05_TIMESTAMP)
+#define bfin_write_CAN0_MB05_TIMESTAMP(val)	bfin_write16(CAN0_MB05_TIMESTAMP, val)
+#define bfin_read_CAN0_MB05_ID0()		bfin_read16(CAN0_MB05_ID0)
+#define bfin_write_CAN0_MB05_ID0(val)		bfin_write16(CAN0_MB05_ID0, val)
+#define bfin_read_CAN0_MB05_ID1()		bfin_read16(CAN0_MB05_ID1)
+#define bfin_write_CAN0_MB05_ID1(val)		bfin_write16(CAN0_MB05_ID1, val)
+#define bfin_read_CAN0_MB06_DATA0()		bfin_read16(CAN0_MB06_DATA0)
+#define bfin_write_CAN0_MB06_DATA0(val)		bfin_write16(CAN0_MB06_DATA0, val)
+#define bfin_read_CAN0_MB06_DATA1()		bfin_read16(CAN0_MB06_DATA1)
+#define bfin_write_CAN0_MB06_DATA1(val)		bfin_write16(CAN0_MB06_DATA1, val)
+#define bfin_read_CAN0_MB06_DATA2()		bfin_read16(CAN0_MB06_DATA2)
+#define bfin_write_CAN0_MB06_DATA2(val)		bfin_write16(CAN0_MB06_DATA2, val)
+#define bfin_read_CAN0_MB06_DATA3()		bfin_read16(CAN0_MB06_DATA3)
+#define bfin_write_CAN0_MB06_DATA3(val)		bfin_write16(CAN0_MB06_DATA3, val)
+#define bfin_read_CAN0_MB06_LENGTH()		bfin_read16(CAN0_MB06_LENGTH)
+#define bfin_write_CAN0_MB06_LENGTH(val)	bfin_write16(CAN0_MB06_LENGTH, val)
+#define bfin_read_CAN0_MB06_TIMESTAMP()		bfin_read16(CAN0_MB06_TIMESTAMP)
+#define bfin_write_CAN0_MB06_TIMESTAMP(val)	bfin_write16(CAN0_MB06_TIMESTAMP, val)
+#define bfin_read_CAN0_MB06_ID0()		bfin_read16(CAN0_MB06_ID0)
+#define bfin_write_CAN0_MB06_ID0(val)		bfin_write16(CAN0_MB06_ID0, val)
+#define bfin_read_CAN0_MB06_ID1()		bfin_read16(CAN0_MB06_ID1)
+#define bfin_write_CAN0_MB06_ID1(val)		bfin_write16(CAN0_MB06_ID1, val)
+#define bfin_read_CAN0_MB07_DATA0()		bfin_read16(CAN0_MB07_DATA0)
+#define bfin_write_CAN0_MB07_DATA0(val)		bfin_write16(CAN0_MB07_DATA0, val)
+#define bfin_read_CAN0_MB07_DATA1()		bfin_read16(CAN0_MB07_DATA1)
+#define bfin_write_CAN0_MB07_DATA1(val)		bfin_write16(CAN0_MB07_DATA1, val)
+#define bfin_read_CAN0_MB07_DATA2()		bfin_read16(CAN0_MB07_DATA2)
+#define bfin_write_CAN0_MB07_DATA2(val)		bfin_write16(CAN0_MB07_DATA2, val)
+#define bfin_read_CAN0_MB07_DATA3()		bfin_read16(CAN0_MB07_DATA3)
+#define bfin_write_CAN0_MB07_DATA3(val)		bfin_write16(CAN0_MB07_DATA3, val)
+#define bfin_read_CAN0_MB07_LENGTH()		bfin_read16(CAN0_MB07_LENGTH)
+#define bfin_write_CAN0_MB07_LENGTH(val)	bfin_write16(CAN0_MB07_LENGTH, val)
+#define bfin_read_CAN0_MB07_TIMESTAMP()		bfin_read16(CAN0_MB07_TIMESTAMP)
+#define bfin_write_CAN0_MB07_TIMESTAMP(val)	bfin_write16(CAN0_MB07_TIMESTAMP, val)
+#define bfin_read_CAN0_MB07_ID0()		bfin_read16(CAN0_MB07_ID0)
+#define bfin_write_CAN0_MB07_ID0(val)		bfin_write16(CAN0_MB07_ID0, val)
+#define bfin_read_CAN0_MB07_ID1()		bfin_read16(CAN0_MB07_ID1)
+#define bfin_write_CAN0_MB07_ID1(val)		bfin_write16(CAN0_MB07_ID1, val)
+#define bfin_read_CAN0_MB08_DATA0()		bfin_read16(CAN0_MB08_DATA0)
+#define bfin_write_CAN0_MB08_DATA0(val)		bfin_write16(CAN0_MB08_DATA0, val)
+#define bfin_read_CAN0_MB08_DATA1()		bfin_read16(CAN0_MB08_DATA1)
+#define bfin_write_CAN0_MB08_DATA1(val)		bfin_write16(CAN0_MB08_DATA1, val)
+#define bfin_read_CAN0_MB08_DATA2()		bfin_read16(CAN0_MB08_DATA2)
+#define bfin_write_CAN0_MB08_DATA2(val)		bfin_write16(CAN0_MB08_DATA2, val)
+#define bfin_read_CAN0_MB08_DATA3()		bfin_read16(CAN0_MB08_DATA3)
+#define bfin_write_CAN0_MB08_DATA3(val)		bfin_write16(CAN0_MB08_DATA3, val)
+#define bfin_read_CAN0_MB08_LENGTH()		bfin_read16(CAN0_MB08_LENGTH)
+#define bfin_write_CAN0_MB08_LENGTH(val)	bfin_write16(CAN0_MB08_LENGTH, val)
+#define bfin_read_CAN0_MB08_TIMESTAMP()		bfin_read16(CAN0_MB08_TIMESTAMP)
+#define bfin_write_CAN0_MB08_TIMESTAMP(val)	bfin_write16(CAN0_MB08_TIMESTAMP, val)
+#define bfin_read_CAN0_MB08_ID0()		bfin_read16(CAN0_MB08_ID0)
+#define bfin_write_CAN0_MB08_ID0(val)		bfin_write16(CAN0_MB08_ID0, val)
+#define bfin_read_CAN0_MB08_ID1()		bfin_read16(CAN0_MB08_ID1)
+#define bfin_write_CAN0_MB08_ID1(val)		bfin_write16(CAN0_MB08_ID1, val)
+#define bfin_read_CAN0_MB09_DATA0()		bfin_read16(CAN0_MB09_DATA0)
+#define bfin_write_CAN0_MB09_DATA0(val)		bfin_write16(CAN0_MB09_DATA0, val)
+#define bfin_read_CAN0_MB09_DATA1()		bfin_read16(CAN0_MB09_DATA1)
+#define bfin_write_CAN0_MB09_DATA1(val)		bfin_write16(CAN0_MB09_DATA1, val)
+#define bfin_read_CAN0_MB09_DATA2()		bfin_read16(CAN0_MB09_DATA2)
+#define bfin_write_CAN0_MB09_DATA2(val)		bfin_write16(CAN0_MB09_DATA2, val)
+#define bfin_read_CAN0_MB09_DATA3()		bfin_read16(CAN0_MB09_DATA3)
+#define bfin_write_CAN0_MB09_DATA3(val)		bfin_write16(CAN0_MB09_DATA3, val)
+#define bfin_read_CAN0_MB09_LENGTH()		bfin_read16(CAN0_MB09_LENGTH)
+#define bfin_write_CAN0_MB09_LENGTH(val)	bfin_write16(CAN0_MB09_LENGTH, val)
+#define bfin_read_CAN0_MB09_TIMESTAMP()		bfin_read16(CAN0_MB09_TIMESTAMP)
+#define bfin_write_CAN0_MB09_TIMESTAMP(val)	bfin_write16(CAN0_MB09_TIMESTAMP, val)
+#define bfin_read_CAN0_MB09_ID0()		bfin_read16(CAN0_MB09_ID0)
+#define bfin_write_CAN0_MB09_ID0(val)		bfin_write16(CAN0_MB09_ID0, val)
+#define bfin_read_CAN0_MB09_ID1()		bfin_read16(CAN0_MB09_ID1)
+#define bfin_write_CAN0_MB09_ID1(val)		bfin_write16(CAN0_MB09_ID1, val)
+#define bfin_read_CAN0_MB10_DATA0()		bfin_read16(CAN0_MB10_DATA0)
+#define bfin_write_CAN0_MB10_DATA0(val)		bfin_write16(CAN0_MB10_DATA0, val)
+#define bfin_read_CAN0_MB10_DATA1()		bfin_read16(CAN0_MB10_DATA1)
+#define bfin_write_CAN0_MB10_DATA1(val)		bfin_write16(CAN0_MB10_DATA1, val)
+#define bfin_read_CAN0_MB10_DATA2()		bfin_read16(CAN0_MB10_DATA2)
+#define bfin_write_CAN0_MB10_DATA2(val)		bfin_write16(CAN0_MB10_DATA2, val)
+#define bfin_read_CAN0_MB10_DATA3()		bfin_read16(CAN0_MB10_DATA3)
+#define bfin_write_CAN0_MB10_DATA3(val)		bfin_write16(CAN0_MB10_DATA3, val)
+#define bfin_read_CAN0_MB10_LENGTH()		bfin_read16(CAN0_MB10_LENGTH)
+#define bfin_write_CAN0_MB10_LENGTH(val)	bfin_write16(CAN0_MB10_LENGTH, val)
+#define bfin_read_CAN0_MB10_TIMESTAMP()		bfin_read16(CAN0_MB10_TIMESTAMP)
+#define bfin_write_CAN0_MB10_TIMESTAMP(val)	bfin_write16(CAN0_MB10_TIMESTAMP, val)
+#define bfin_read_CAN0_MB10_ID0()		bfin_read16(CAN0_MB10_ID0)
+#define bfin_write_CAN0_MB10_ID0(val)		bfin_write16(CAN0_MB10_ID0, val)
+#define bfin_read_CAN0_MB10_ID1()		bfin_read16(CAN0_MB10_ID1)
+#define bfin_write_CAN0_MB10_ID1(val)		bfin_write16(CAN0_MB10_ID1, val)
+#define bfin_read_CAN0_MB11_DATA0()		bfin_read16(CAN0_MB11_DATA0)
+#define bfin_write_CAN0_MB11_DATA0(val)		bfin_write16(CAN0_MB11_DATA0, val)
+#define bfin_read_CAN0_MB11_DATA1()		bfin_read16(CAN0_MB11_DATA1)
+#define bfin_write_CAN0_MB11_DATA1(val)		bfin_write16(CAN0_MB11_DATA1, val)
+#define bfin_read_CAN0_MB11_DATA2()		bfin_read16(CAN0_MB11_DATA2)
+#define bfin_write_CAN0_MB11_DATA2(val)		bfin_write16(CAN0_MB11_DATA2, val)
+#define bfin_read_CAN0_MB11_DATA3()		bfin_read16(CAN0_MB11_DATA3)
+#define bfin_write_CAN0_MB11_DATA3(val)		bfin_write16(CAN0_MB11_DATA3, val)
+#define bfin_read_CAN0_MB11_LENGTH()		bfin_read16(CAN0_MB11_LENGTH)
+#define bfin_write_CAN0_MB11_LENGTH(val)	bfin_write16(CAN0_MB11_LENGTH, val)
+#define bfin_read_CAN0_MB11_TIMESTAMP()		bfin_read16(CAN0_MB11_TIMESTAMP)
+#define bfin_write_CAN0_MB11_TIMESTAMP(val)	bfin_write16(CAN0_MB11_TIMESTAMP, val)
+#define bfin_read_CAN0_MB11_ID0()		bfin_read16(CAN0_MB11_ID0)
+#define bfin_write_CAN0_MB11_ID0(val)		bfin_write16(CAN0_MB11_ID0, val)
+#define bfin_read_CAN0_MB11_ID1()		bfin_read16(CAN0_MB11_ID1)
+#define bfin_write_CAN0_MB11_ID1(val)		bfin_write16(CAN0_MB11_ID1, val)
+#define bfin_read_CAN0_MB12_DATA0()		bfin_read16(CAN0_MB12_DATA0)
+#define bfin_write_CAN0_MB12_DATA0(val)		bfin_write16(CAN0_MB12_DATA0, val)
+#define bfin_read_CAN0_MB12_DATA1()		bfin_read16(CAN0_MB12_DATA1)
+#define bfin_write_CAN0_MB12_DATA1(val)		bfin_write16(CAN0_MB12_DATA1, val)
+#define bfin_read_CAN0_MB12_DATA2()		bfin_read16(CAN0_MB12_DATA2)
+#define bfin_write_CAN0_MB12_DATA2(val)		bfin_write16(CAN0_MB12_DATA2, val)
+#define bfin_read_CAN0_MB12_DATA3()		bfin_read16(CAN0_MB12_DATA3)
+#define bfin_write_CAN0_MB12_DATA3(val)		bfin_write16(CAN0_MB12_DATA3, val)
+#define bfin_read_CAN0_MB12_LENGTH()		bfin_read16(CAN0_MB12_LENGTH)
+#define bfin_write_CAN0_MB12_LENGTH(val)	bfin_write16(CAN0_MB12_LENGTH, val)
+#define bfin_read_CAN0_MB12_TIMESTAMP()		bfin_read16(CAN0_MB12_TIMESTAMP)
+#define bfin_write_CAN0_MB12_TIMESTAMP(val)	bfin_write16(CAN0_MB12_TIMESTAMP, val)
+#define bfin_read_CAN0_MB12_ID0()		bfin_read16(CAN0_MB12_ID0)
+#define bfin_write_CAN0_MB12_ID0(val)		bfin_write16(CAN0_MB12_ID0, val)
+#define bfin_read_CAN0_MB12_ID1()		bfin_read16(CAN0_MB12_ID1)
+#define bfin_write_CAN0_MB12_ID1(val)		bfin_write16(CAN0_MB12_ID1, val)
+#define bfin_read_CAN0_MB13_DATA0()		bfin_read16(CAN0_MB13_DATA0)
+#define bfin_write_CAN0_MB13_DATA0(val)		bfin_write16(CAN0_MB13_DATA0, val)
+#define bfin_read_CAN0_MB13_DATA1()		bfin_read16(CAN0_MB13_DATA1)
+#define bfin_write_CAN0_MB13_DATA1(val)		bfin_write16(CAN0_MB13_DATA1, val)
+#define bfin_read_CAN0_MB13_DATA2()		bfin_read16(CAN0_MB13_DATA2)
+#define bfin_write_CAN0_MB13_DATA2(val)		bfin_write16(CAN0_MB13_DATA2, val)
+#define bfin_read_CAN0_MB13_DATA3()		bfin_read16(CAN0_MB13_DATA3)
+#define bfin_write_CAN0_MB13_DATA3(val)		bfin_write16(CAN0_MB13_DATA3, val)
+#define bfin_read_CAN0_MB13_LENGTH()		bfin_read16(CAN0_MB13_LENGTH)
+#define bfin_write_CAN0_MB13_LENGTH(val)	bfin_write16(CAN0_MB13_LENGTH, val)
+#define bfin_read_CAN0_MB13_TIMESTAMP()		bfin_read16(CAN0_MB13_TIMESTAMP)
+#define bfin_write_CAN0_MB13_TIMESTAMP(val)	bfin_write16(CAN0_MB13_TIMESTAMP, val)
+#define bfin_read_CAN0_MB13_ID0()		bfin_read16(CAN0_MB13_ID0)
+#define bfin_write_CAN0_MB13_ID0(val)		bfin_write16(CAN0_MB13_ID0, val)
+#define bfin_read_CAN0_MB13_ID1()		bfin_read16(CAN0_MB13_ID1)
+#define bfin_write_CAN0_MB13_ID1(val)		bfin_write16(CAN0_MB13_ID1, val)
+#define bfin_read_CAN0_MB14_DATA0()		bfin_read16(CAN0_MB14_DATA0)
+#define bfin_write_CAN0_MB14_DATA0(val)		bfin_write16(CAN0_MB14_DATA0, val)
+#define bfin_read_CAN0_MB14_DATA1()		bfin_read16(CAN0_MB14_DATA1)
+#define bfin_write_CAN0_MB14_DATA1(val)		bfin_write16(CAN0_MB14_DATA1, val)
+#define bfin_read_CAN0_MB14_DATA2()		bfin_read16(CAN0_MB14_DATA2)
+#define bfin_write_CAN0_MB14_DATA2(val)		bfin_write16(CAN0_MB14_DATA2, val)
+#define bfin_read_CAN0_MB14_DATA3()		bfin_read16(CAN0_MB14_DATA3)
+#define bfin_write_CAN0_MB14_DATA3(val)		bfin_write16(CAN0_MB14_DATA3, val)
+#define bfin_read_CAN0_MB14_LENGTH()		bfin_read16(CAN0_MB14_LENGTH)
+#define bfin_write_CAN0_MB14_LENGTH(val)	bfin_write16(CAN0_MB14_LENGTH, val)
+#define bfin_read_CAN0_MB14_TIMESTAMP()		bfin_read16(CAN0_MB14_TIMESTAMP)
+#define bfin_write_CAN0_MB14_TIMESTAMP(val)	bfin_write16(CAN0_MB14_TIMESTAMP, val)
+#define bfin_read_CAN0_MB14_ID0()		bfin_read16(CAN0_MB14_ID0)
+#define bfin_write_CAN0_MB14_ID0(val)		bfin_write16(CAN0_MB14_ID0, val)
+#define bfin_read_CAN0_MB14_ID1()		bfin_read16(CAN0_MB14_ID1)
+#define bfin_write_CAN0_MB14_ID1(val)		bfin_write16(CAN0_MB14_ID1, val)
+#define bfin_read_CAN0_MB15_DATA0()		bfin_read16(CAN0_MB15_DATA0)
+#define bfin_write_CAN0_MB15_DATA0(val)		bfin_write16(CAN0_MB15_DATA0, val)
+#define bfin_read_CAN0_MB15_DATA1()		bfin_read16(CAN0_MB15_DATA1)
+#define bfin_write_CAN0_MB15_DATA1(val)		bfin_write16(CAN0_MB15_DATA1, val)
+#define bfin_read_CAN0_MB15_DATA2()		bfin_read16(CAN0_MB15_DATA2)
+#define bfin_write_CAN0_MB15_DATA2(val)		bfin_write16(CAN0_MB15_DATA2, val)
+#define bfin_read_CAN0_MB15_DATA3()		bfin_read16(CAN0_MB15_DATA3)
+#define bfin_write_CAN0_MB15_DATA3(val)		bfin_write16(CAN0_MB15_DATA3, val)
+#define bfin_read_CAN0_MB15_LENGTH()		bfin_read16(CAN0_MB15_LENGTH)
+#define bfin_write_CAN0_MB15_LENGTH(val)	bfin_write16(CAN0_MB15_LENGTH, val)
+#define bfin_read_CAN0_MB15_TIMESTAMP()		bfin_read16(CAN0_MB15_TIMESTAMP)
+#define bfin_write_CAN0_MB15_TIMESTAMP(val)	bfin_write16(CAN0_MB15_TIMESTAMP, val)
+#define bfin_read_CAN0_MB15_ID0()		bfin_read16(CAN0_MB15_ID0)
+#define bfin_write_CAN0_MB15_ID0(val)		bfin_write16(CAN0_MB15_ID0, val)
+#define bfin_read_CAN0_MB15_ID1()		bfin_read16(CAN0_MB15_ID1)
+#define bfin_write_CAN0_MB15_ID1(val)		bfin_write16(CAN0_MB15_ID1, val)
+
+/* CAN Controller 0 Mailbox Data Registers */
+
+#define bfin_read_CAN0_MB16_DATA0()		bfin_read16(CAN0_MB16_DATA0)
+#define bfin_write_CAN0_MB16_DATA0(val)		bfin_write16(CAN0_MB16_DATA0, val)
+#define bfin_read_CAN0_MB16_DATA1()		bfin_read16(CAN0_MB16_DATA1)
+#define bfin_write_CAN0_MB16_DATA1(val)		bfin_write16(CAN0_MB16_DATA1, val)
+#define bfin_read_CAN0_MB16_DATA2()		bfin_read16(CAN0_MB16_DATA2)
+#define bfin_write_CAN0_MB16_DATA2(val)		bfin_write16(CAN0_MB16_DATA2, val)
+#define bfin_read_CAN0_MB16_DATA3()		bfin_read16(CAN0_MB16_DATA3)
+#define bfin_write_CAN0_MB16_DATA3(val)		bfin_write16(CAN0_MB16_DATA3, val)
+#define bfin_read_CAN0_MB16_LENGTH()		bfin_read16(CAN0_MB16_LENGTH)
+#define bfin_write_CAN0_MB16_LENGTH(val)	bfin_write16(CAN0_MB16_LENGTH, val)
+#define bfin_read_CAN0_MB16_TIMESTAMP()		bfin_read16(CAN0_MB16_TIMESTAMP)
+#define bfin_write_CAN0_MB16_TIMESTAMP(val)	bfin_write16(CAN0_MB16_TIMESTAMP, val)
+#define bfin_read_CAN0_MB16_ID0()		bfin_read16(CAN0_MB16_ID0)
+#define bfin_write_CAN0_MB16_ID0(val)		bfin_write16(CAN0_MB16_ID0, val)
+#define bfin_read_CAN0_MB16_ID1()		bfin_read16(CAN0_MB16_ID1)
+#define bfin_write_CAN0_MB16_ID1(val)		bfin_write16(CAN0_MB16_ID1, val)
+#define bfin_read_CAN0_MB17_DATA0()		bfin_read16(CAN0_MB17_DATA0)
+#define bfin_write_CAN0_MB17_DATA0(val)		bfin_write16(CAN0_MB17_DATA0, val)
+#define bfin_read_CAN0_MB17_DATA1()		bfin_read16(CAN0_MB17_DATA1)
+#define bfin_write_CAN0_MB17_DATA1(val)		bfin_write16(CAN0_MB17_DATA1, val)
+#define bfin_read_CAN0_MB17_DATA2()		bfin_read16(CAN0_MB17_DATA2)
+#define bfin_write_CAN0_MB17_DATA2(val)		bfin_write16(CAN0_MB17_DATA2, val)
+#define bfin_read_CAN0_MB17_DATA3()		bfin_read16(CAN0_MB17_DATA3)
+#define bfin_write_CAN0_MB17_DATA3(val)		bfin_write16(CAN0_MB17_DATA3, val)
+#define bfin_read_CAN0_MB17_LENGTH()		bfin_read16(CAN0_MB17_LENGTH)
+#define bfin_write_CAN0_MB17_LENGTH(val)	bfin_write16(CAN0_MB17_LENGTH, val)
+#define bfin_read_CAN0_MB17_TIMESTAMP()		bfin_read16(CAN0_MB17_TIMESTAMP)
+#define bfin_write_CAN0_MB17_TIMESTAMP(val)	bfin_write16(CAN0_MB17_TIMESTAMP, val)
+#define bfin_read_CAN0_MB17_ID0()		bfin_read16(CAN0_MB17_ID0)
+#define bfin_write_CAN0_MB17_ID0(val)		bfin_write16(CAN0_MB17_ID0, val)
+#define bfin_read_CAN0_MB17_ID1()		bfin_read16(CAN0_MB17_ID1)
+#define bfin_write_CAN0_MB17_ID1(val)		bfin_write16(CAN0_MB17_ID1, val)
+#define bfin_read_CAN0_MB18_DATA0()		bfin_read16(CAN0_MB18_DATA0)
+#define bfin_write_CAN0_MB18_DATA0(val)		bfin_write16(CAN0_MB18_DATA0, val)
+#define bfin_read_CAN0_MB18_DATA1()		bfin_read16(CAN0_MB18_DATA1)
+#define bfin_write_CAN0_MB18_DATA1(val)		bfin_write16(CAN0_MB18_DATA1, val)
+#define bfin_read_CAN0_MB18_DATA2()		bfin_read16(CAN0_MB18_DATA2)
+#define bfin_write_CAN0_MB18_DATA2(val)		bfin_write16(CAN0_MB18_DATA2, val)
+#define bfin_read_CAN0_MB18_DATA3()		bfin_read16(CAN0_MB18_DATA3)
+#define bfin_write_CAN0_MB18_DATA3(val)		bfin_write16(CAN0_MB18_DATA3, val)
+#define bfin_read_CAN0_MB18_LENGTH()		bfin_read16(CAN0_MB18_LENGTH)
+#define bfin_write_CAN0_MB18_LENGTH(val)	bfin_write16(CAN0_MB18_LENGTH, val)
+#define bfin_read_CAN0_MB18_TIMESTAMP()		bfin_read16(CAN0_MB18_TIMESTAMP)
+#define bfin_write_CAN0_MB18_TIMESTAMP(val)	bfin_write16(CAN0_MB18_TIMESTAMP, val)
+#define bfin_read_CAN0_MB18_ID0()		bfin_read16(CAN0_MB18_ID0)
+#define bfin_write_CAN0_MB18_ID0(val)		bfin_write16(CAN0_MB18_ID0, val)
+#define bfin_read_CAN0_MB18_ID1()		bfin_read16(CAN0_MB18_ID1)
+#define bfin_write_CAN0_MB18_ID1(val)		bfin_write16(CAN0_MB18_ID1, val)
+#define bfin_read_CAN0_MB19_DATA0()		bfin_read16(CAN0_MB19_DATA0)
+#define bfin_write_CAN0_MB19_DATA0(val)		bfin_write16(CAN0_MB19_DATA0, val)
+#define bfin_read_CAN0_MB19_DATA1()		bfin_read16(CAN0_MB19_DATA1)
+#define bfin_write_CAN0_MB19_DATA1(val)		bfin_write16(CAN0_MB19_DATA1, val)
+#define bfin_read_CAN0_MB19_DATA2()		bfin_read16(CAN0_MB19_DATA2)
+#define bfin_write_CAN0_MB19_DATA2(val)		bfin_write16(CAN0_MB19_DATA2, val)
+#define bfin_read_CAN0_MB19_DATA3()		bfin_read16(CAN0_MB19_DATA3)
+#define bfin_write_CAN0_MB19_DATA3(val)		bfin_write16(CAN0_MB19_DATA3, val)
+#define bfin_read_CAN0_MB19_LENGTH()		bfin_read16(CAN0_MB19_LENGTH)
+#define bfin_write_CAN0_MB19_LENGTH(val)	bfin_write16(CAN0_MB19_LENGTH, val)
+#define bfin_read_CAN0_MB19_TIMESTAMP()		bfin_read16(CAN0_MB19_TIMESTAMP)
+#define bfin_write_CAN0_MB19_TIMESTAMP(val)	bfin_write16(CAN0_MB19_TIMESTAMP, val)
+#define bfin_read_CAN0_MB19_ID0()		bfin_read16(CAN0_MB19_ID0)
+#define bfin_write_CAN0_MB19_ID0(val)		bfin_write16(CAN0_MB19_ID0, val)
+#define bfin_read_CAN0_MB19_ID1()		bfin_read16(CAN0_MB19_ID1)
+#define bfin_write_CAN0_MB19_ID1(val)		bfin_write16(CAN0_MB19_ID1, val)
+#define bfin_read_CAN0_MB20_DATA0()		bfin_read16(CAN0_MB20_DATA0)
+#define bfin_write_CAN0_MB20_DATA0(val)		bfin_write16(CAN0_MB20_DATA0, val)
+#define bfin_read_CAN0_MB20_DATA1()		bfin_read16(CAN0_MB20_DATA1)
+#define bfin_write_CAN0_MB20_DATA1(val)		bfin_write16(CAN0_MB20_DATA1, val)
+#define bfin_read_CAN0_MB20_DATA2()		bfin_read16(CAN0_MB20_DATA2)
+#define bfin_write_CAN0_MB20_DATA2(val)		bfin_write16(CAN0_MB20_DATA2, val)
+#define bfin_read_CAN0_MB20_DATA3()		bfin_read16(CAN0_MB20_DATA3)
+#define bfin_write_CAN0_MB20_DATA3(val)		bfin_write16(CAN0_MB20_DATA3, val)
+#define bfin_read_CAN0_MB20_LENGTH()		bfin_read16(CAN0_MB20_LENGTH)
+#define bfin_write_CAN0_MB20_LENGTH(val)	bfin_write16(CAN0_MB20_LENGTH, val)
+#define bfin_read_CAN0_MB20_TIMESTAMP()		bfin_read16(CAN0_MB20_TIMESTAMP)
+#define bfin_write_CAN0_MB20_TIMESTAMP(val)	bfin_write16(CAN0_MB20_TIMESTAMP, val)
+#define bfin_read_CAN0_MB20_ID0()		bfin_read16(CAN0_MB20_ID0)
+#define bfin_write_CAN0_MB20_ID0(val)		bfin_write16(CAN0_MB20_ID0, val)
+#define bfin_read_CAN0_MB20_ID1()		bfin_read16(CAN0_MB20_ID1)
+#define bfin_write_CAN0_MB20_ID1(val)		bfin_write16(CAN0_MB20_ID1, val)
+#define bfin_read_CAN0_MB21_DATA0()		bfin_read16(CAN0_MB21_DATA0)
+#define bfin_write_CAN0_MB21_DATA0(val)		bfin_write16(CAN0_MB21_DATA0, val)
+#define bfin_read_CAN0_MB21_DATA1()		bfin_read16(CAN0_MB21_DATA1)
+#define bfin_write_CAN0_MB21_DATA1(val)		bfin_write16(CAN0_MB21_DATA1, val)
+#define bfin_read_CAN0_MB21_DATA2()		bfin_read16(CAN0_MB21_DATA2)
+#define bfin_write_CAN0_MB21_DATA2(val)		bfin_write16(CAN0_MB21_DATA2, val)
+#define bfin_read_CAN0_MB21_DATA3()		bfin_read16(CAN0_MB21_DATA3)
+#define bfin_write_CAN0_MB21_DATA3(val)		bfin_write16(CAN0_MB21_DATA3, val)
+#define bfin_read_CAN0_MB21_LENGTH()		bfin_read16(CAN0_MB21_LENGTH)
+#define bfin_write_CAN0_MB21_LENGTH(val)	bfin_write16(CAN0_MB21_LENGTH, val)
+#define bfin_read_CAN0_MB21_TIMESTAMP()		bfin_read16(CAN0_MB21_TIMESTAMP)
+#define bfin_write_CAN0_MB21_TIMESTAMP(val)	bfin_write16(CAN0_MB21_TIMESTAMP, val)
+#define bfin_read_CAN0_MB21_ID0()		bfin_read16(CAN0_MB21_ID0)
+#define bfin_write_CAN0_MB21_ID0(val)		bfin_write16(CAN0_MB21_ID0, val)
+#define bfin_read_CAN0_MB21_ID1()		bfin_read16(CAN0_MB21_ID1)
+#define bfin_write_CAN0_MB21_ID1(val)		bfin_write16(CAN0_MB21_ID1, val)
+#define bfin_read_CAN0_MB22_DATA0()		bfin_read16(CAN0_MB22_DATA0)
+#define bfin_write_CAN0_MB22_DATA0(val)		bfin_write16(CAN0_MB22_DATA0, val)
+#define bfin_read_CAN0_MB22_DATA1()		bfin_read16(CAN0_MB22_DATA1)
+#define bfin_write_CAN0_MB22_DATA1(val)		bfin_write16(CAN0_MB22_DATA1, val)
+#define bfin_read_CAN0_MB22_DATA2()		bfin_read16(CAN0_MB22_DATA2)
+#define bfin_write_CAN0_MB22_DATA2(val)		bfin_write16(CAN0_MB22_DATA2, val)
+#define bfin_read_CAN0_MB22_DATA3()		bfin_read16(CAN0_MB22_DATA3)
+#define bfin_write_CAN0_MB22_DATA3(val)		bfin_write16(CAN0_MB22_DATA3, val)
+#define bfin_read_CAN0_MB22_LENGTH()		bfin_read16(CAN0_MB22_LENGTH)
+#define bfin_write_CAN0_MB22_LENGTH(val)	bfin_write16(CAN0_MB22_LENGTH, val)
+#define bfin_read_CAN0_MB22_TIMESTAMP()		bfin_read16(CAN0_MB22_TIMESTAMP)
+#define bfin_write_CAN0_MB22_TIMESTAMP(val)	bfin_write16(CAN0_MB22_TIMESTAMP, val)
+#define bfin_read_CAN0_MB22_ID0()		bfin_read16(CAN0_MB22_ID0)
+#define bfin_write_CAN0_MB22_ID0(val)		bfin_write16(CAN0_MB22_ID0, val)
+#define bfin_read_CAN0_MB22_ID1()		bfin_read16(CAN0_MB22_ID1)
+#define bfin_write_CAN0_MB22_ID1(val)		bfin_write16(CAN0_MB22_ID1, val)
+#define bfin_read_CAN0_MB23_DATA0()		bfin_read16(CAN0_MB23_DATA0)
+#define bfin_write_CAN0_MB23_DATA0(val)		bfin_write16(CAN0_MB23_DATA0, val)
+#define bfin_read_CAN0_MB23_DATA1()		bfin_read16(CAN0_MB23_DATA1)
+#define bfin_write_CAN0_MB23_DATA1(val)		bfin_write16(CAN0_MB23_DATA1, val)
+#define bfin_read_CAN0_MB23_DATA2()		bfin_read16(CAN0_MB23_DATA2)
+#define bfin_write_CAN0_MB23_DATA2(val)		bfin_write16(CAN0_MB23_DATA2, val)
+#define bfin_read_CAN0_MB23_DATA3()		bfin_read16(CAN0_MB23_DATA3)
+#define bfin_write_CAN0_MB23_DATA3(val)		bfin_write16(CAN0_MB23_DATA3, val)
+#define bfin_read_CAN0_MB23_LENGTH()		bfin_read16(CAN0_MB23_LENGTH)
+#define bfin_write_CAN0_MB23_LENGTH(val)	bfin_write16(CAN0_MB23_LENGTH, val)
+#define bfin_read_CAN0_MB23_TIMESTAMP()		bfin_read16(CAN0_MB23_TIMESTAMP)
+#define bfin_write_CAN0_MB23_TIMESTAMP(val)	bfin_write16(CAN0_MB23_TIMESTAMP, val)
+#define bfin_read_CAN0_MB23_ID0()		bfin_read16(CAN0_MB23_ID0)
+#define bfin_write_CAN0_MB23_ID0(val)		bfin_write16(CAN0_MB23_ID0, val)
+#define bfin_read_CAN0_MB23_ID1()		bfin_read16(CAN0_MB23_ID1)
+#define bfin_write_CAN0_MB23_ID1(val)		bfin_write16(CAN0_MB23_ID1, val)
+#define bfin_read_CAN0_MB24_DATA0()		bfin_read16(CAN0_MB24_DATA0)
+#define bfin_write_CAN0_MB24_DATA0(val)		bfin_write16(CAN0_MB24_DATA0, val)
+#define bfin_read_CAN0_MB24_DATA1()		bfin_read16(CAN0_MB24_DATA1)
+#define bfin_write_CAN0_MB24_DATA1(val)		bfin_write16(CAN0_MB24_DATA1, val)
+#define bfin_read_CAN0_MB24_DATA2()		bfin_read16(CAN0_MB24_DATA2)
+#define bfin_write_CAN0_MB24_DATA2(val)		bfin_write16(CAN0_MB24_DATA2, val)
+#define bfin_read_CAN0_MB24_DATA3()		bfin_read16(CAN0_MB24_DATA3)
+#define bfin_write_CAN0_MB24_DATA3(val)		bfin_write16(CAN0_MB24_DATA3, val)
+#define bfin_read_CAN0_MB24_LENGTH()		bfin_read16(CAN0_MB24_LENGTH)
+#define bfin_write_CAN0_MB24_LENGTH(val)	bfin_write16(CAN0_MB24_LENGTH, val)
+#define bfin_read_CAN0_MB24_TIMESTAMP()		bfin_read16(CAN0_MB24_TIMESTAMP)
+#define bfin_write_CAN0_MB24_TIMESTAMP(val)	bfin_write16(CAN0_MB24_TIMESTAMP, val)
+#define bfin_read_CAN0_MB24_ID0()		bfin_read16(CAN0_MB24_ID0)
+#define bfin_write_CAN0_MB24_ID0(val)		bfin_write16(CAN0_MB24_ID0, val)
+#define bfin_read_CAN0_MB24_ID1()		bfin_read16(CAN0_MB24_ID1)
+#define bfin_write_CAN0_MB24_ID1(val)		bfin_write16(CAN0_MB24_ID1, val)
+#define bfin_read_CAN0_MB25_DATA0()		bfin_read16(CAN0_MB25_DATA0)
+#define bfin_write_CAN0_MB25_DATA0(val)		bfin_write16(CAN0_MB25_DATA0, val)
+#define bfin_read_CAN0_MB25_DATA1()		bfin_read16(CAN0_MB25_DATA1)
+#define bfin_write_CAN0_MB25_DATA1(val)		bfin_write16(CAN0_MB25_DATA1, val)
+#define bfin_read_CAN0_MB25_DATA2()		bfin_read16(CAN0_MB25_DATA2)
+#define bfin_write_CAN0_MB25_DATA2(val)		bfin_write16(CAN0_MB25_DATA2, val)
+#define bfin_read_CAN0_MB25_DATA3()		bfin_read16(CAN0_MB25_DATA3)
+#define bfin_write_CAN0_MB25_DATA3(val)		bfin_write16(CAN0_MB25_DATA3, val)
+#define bfin_read_CAN0_MB25_LENGTH()		bfin_read16(CAN0_MB25_LENGTH)
+#define bfin_write_CAN0_MB25_LENGTH(val)	bfin_write16(CAN0_MB25_LENGTH, val)
+#define bfin_read_CAN0_MB25_TIMESTAMP()		bfin_read16(CAN0_MB25_TIMESTAMP)
+#define bfin_write_CAN0_MB25_TIMESTAMP(val)	bfin_write16(CAN0_MB25_TIMESTAMP, val)
+#define bfin_read_CAN0_MB25_ID0()		bfin_read16(CAN0_MB25_ID0)
+#define bfin_write_CAN0_MB25_ID0(val)		bfin_write16(CAN0_MB25_ID0, val)
+#define bfin_read_CAN0_MB25_ID1()		bfin_read16(CAN0_MB25_ID1)
+#define bfin_write_CAN0_MB25_ID1(val)		bfin_write16(CAN0_MB25_ID1, val)
+#define bfin_read_CAN0_MB26_DATA0()		bfin_read16(CAN0_MB26_DATA0)
+#define bfin_write_CAN0_MB26_DATA0(val)		bfin_write16(CAN0_MB26_DATA0, val)
+#define bfin_read_CAN0_MB26_DATA1()		bfin_read16(CAN0_MB26_DATA1)
+#define bfin_write_CAN0_MB26_DATA1(val)		bfin_write16(CAN0_MB26_DATA1, val)
+#define bfin_read_CAN0_MB26_DATA2()		bfin_read16(CAN0_MB26_DATA2)
+#define bfin_write_CAN0_MB26_DATA2(val)		bfin_write16(CAN0_MB26_DATA2, val)
+#define bfin_read_CAN0_MB26_DATA3()		bfin_read16(CAN0_MB26_DATA3)
+#define bfin_write_CAN0_MB26_DATA3(val)		bfin_write16(CAN0_MB26_DATA3, val)
+#define bfin_read_CAN0_MB26_LENGTH()		bfin_read16(CAN0_MB26_LENGTH)
+#define bfin_write_CAN0_MB26_LENGTH(val)	bfin_write16(CAN0_MB26_LENGTH, val)
+#define bfin_read_CAN0_MB26_TIMESTAMP()		bfin_read16(CAN0_MB26_TIMESTAMP)
+#define bfin_write_CAN0_MB26_TIMESTAMP(val)	bfin_write16(CAN0_MB26_TIMESTAMP, val)
+#define bfin_read_CAN0_MB26_ID0()		bfin_read16(CAN0_MB26_ID0)
+#define bfin_write_CAN0_MB26_ID0(val)		bfin_write16(CAN0_MB26_ID0, val)
+#define bfin_read_CAN0_MB26_ID1()		bfin_read16(CAN0_MB26_ID1)
+#define bfin_write_CAN0_MB26_ID1(val)		bfin_write16(CAN0_MB26_ID1, val)
+#define bfin_read_CAN0_MB27_DATA0()		bfin_read16(CAN0_MB27_DATA0)
+#define bfin_write_CAN0_MB27_DATA0(val)		bfin_write16(CAN0_MB27_DATA0, val)
+#define bfin_read_CAN0_MB27_DATA1()		bfin_read16(CAN0_MB27_DATA1)
+#define bfin_write_CAN0_MB27_DATA1(val)		bfin_write16(CAN0_MB27_DATA1, val)
+#define bfin_read_CAN0_MB27_DATA2()		bfin_read16(CAN0_MB27_DATA2)
+#define bfin_write_CAN0_MB27_DATA2(val)		bfin_write16(CAN0_MB27_DATA2, val)
+#define bfin_read_CAN0_MB27_DATA3()		bfin_read16(CAN0_MB27_DATA3)
+#define bfin_write_CAN0_MB27_DATA3(val)		bfin_write16(CAN0_MB27_DATA3, val)
+#define bfin_read_CAN0_MB27_LENGTH()		bfin_read16(CAN0_MB27_LENGTH)
+#define bfin_write_CAN0_MB27_LENGTH(val)	bfin_write16(CAN0_MB27_LENGTH, val)
+#define bfin_read_CAN0_MB27_TIMESTAMP()		bfin_read16(CAN0_MB27_TIMESTAMP)
+#define bfin_write_CAN0_MB27_TIMESTAMP(val)	bfin_write16(CAN0_MB27_TIMESTAMP, val)
+#define bfin_read_CAN0_MB27_ID0()		bfin_read16(CAN0_MB27_ID0)
+#define bfin_write_CAN0_MB27_ID0(val)		bfin_write16(CAN0_MB27_ID0, val)
+#define bfin_read_CAN0_MB27_ID1()		bfin_read16(CAN0_MB27_ID1)
+#define bfin_write_CAN0_MB27_ID1(val)		bfin_write16(CAN0_MB27_ID1, val)
+#define bfin_read_CAN0_MB28_DATA0()		bfin_read16(CAN0_MB28_DATA0)
+#define bfin_write_CAN0_MB28_DATA0(val)		bfin_write16(CAN0_MB28_DATA0, val)
+#define bfin_read_CAN0_MB28_DATA1()		bfin_read16(CAN0_MB28_DATA1)
+#define bfin_write_CAN0_MB28_DATA1(val)		bfin_write16(CAN0_MB28_DATA1, val)
+#define bfin_read_CAN0_MB28_DATA2()		bfin_read16(CAN0_MB28_DATA2)
+#define bfin_write_CAN0_MB28_DATA2(val)		bfin_write16(CAN0_MB28_DATA2, val)
+#define bfin_read_CAN0_MB28_DATA3()		bfin_read16(CAN0_MB28_DATA3)
+#define bfin_write_CAN0_MB28_DATA3(val)		bfin_write16(CAN0_MB28_DATA3, val)
+#define bfin_read_CAN0_MB28_LENGTH()		bfin_read16(CAN0_MB28_LENGTH)
+#define bfin_write_CAN0_MB28_LENGTH(val)	bfin_write16(CAN0_MB28_LENGTH, val)
+#define bfin_read_CAN0_MB28_TIMESTAMP()		bfin_read16(CAN0_MB28_TIMESTAMP)
+#define bfin_write_CAN0_MB28_TIMESTAMP(val)	bfin_write16(CAN0_MB28_TIMESTAMP, val)
+#define bfin_read_CAN0_MB28_ID0()		bfin_read16(CAN0_MB28_ID0)
+#define bfin_write_CAN0_MB28_ID0(val)		bfin_write16(CAN0_MB28_ID0, val)
+#define bfin_read_CAN0_MB28_ID1()		bfin_read16(CAN0_MB28_ID1)
+#define bfin_write_CAN0_MB28_ID1(val)		bfin_write16(CAN0_MB28_ID1, val)
+#define bfin_read_CAN0_MB29_DATA0()		bfin_read16(CAN0_MB29_DATA0)
+#define bfin_write_CAN0_MB29_DATA0(val)		bfin_write16(CAN0_MB29_DATA0, val)
+#define bfin_read_CAN0_MB29_DATA1()		bfin_read16(CAN0_MB29_DATA1)
+#define bfin_write_CAN0_MB29_DATA1(val)		bfin_write16(CAN0_MB29_DATA1, val)
+#define bfin_read_CAN0_MB29_DATA2()		bfin_read16(CAN0_MB29_DATA2)
+#define bfin_write_CAN0_MB29_DATA2(val)		bfin_write16(CAN0_MB29_DATA2, val)
+#define bfin_read_CAN0_MB29_DATA3()		bfin_read16(CAN0_MB29_DATA3)
+#define bfin_write_CAN0_MB29_DATA3(val)		bfin_write16(CAN0_MB29_DATA3, val)
+#define bfin_read_CAN0_MB29_LENGTH()		bfin_read16(CAN0_MB29_LENGTH)
+#define bfin_write_CAN0_MB29_LENGTH(val)	bfin_write16(CAN0_MB29_LENGTH, val)
+#define bfin_read_CAN0_MB29_TIMESTAMP()		bfin_read16(CAN0_MB29_TIMESTAMP)
+#define bfin_write_CAN0_MB29_TIMESTAMP(val)	bfin_write16(CAN0_MB29_TIMESTAMP, val)
+#define bfin_read_CAN0_MB29_ID0()		bfin_read16(CAN0_MB29_ID0)
+#define bfin_write_CAN0_MB29_ID0(val)		bfin_write16(CAN0_MB29_ID0, val)
+#define bfin_read_CAN0_MB29_ID1()		bfin_read16(CAN0_MB29_ID1)
+#define bfin_write_CAN0_MB29_ID1(val)		bfin_write16(CAN0_MB29_ID1, val)
+#define bfin_read_CAN0_MB30_DATA0()		bfin_read16(CAN0_MB30_DATA0)
+#define bfin_write_CAN0_MB30_DATA0(val)		bfin_write16(CAN0_MB30_DATA0, val)
+#define bfin_read_CAN0_MB30_DATA1()		bfin_read16(CAN0_MB30_DATA1)
+#define bfin_write_CAN0_MB30_DATA1(val)		bfin_write16(CAN0_MB30_DATA1, val)
+#define bfin_read_CAN0_MB30_DATA2()		bfin_read16(CAN0_MB30_DATA2)
+#define bfin_write_CAN0_MB30_DATA2(val)		bfin_write16(CAN0_MB30_DATA2, val)
+#define bfin_read_CAN0_MB30_DATA3()		bfin_read16(CAN0_MB30_DATA3)
+#define bfin_write_CAN0_MB30_DATA3(val)		bfin_write16(CAN0_MB30_DATA3, val)
+#define bfin_read_CAN0_MB30_LENGTH()		bfin_read16(CAN0_MB30_LENGTH)
+#define bfin_write_CAN0_MB30_LENGTH(val)	bfin_write16(CAN0_MB30_LENGTH, val)
+#define bfin_read_CAN0_MB30_TIMESTAMP()		bfin_read16(CAN0_MB30_TIMESTAMP)
+#define bfin_write_CAN0_MB30_TIMESTAMP(val)	bfin_write16(CAN0_MB30_TIMESTAMP, val)
+#define bfin_read_CAN0_MB30_ID0()		bfin_read16(CAN0_MB30_ID0)
+#define bfin_write_CAN0_MB30_ID0(val)		bfin_write16(CAN0_MB30_ID0, val)
+#define bfin_read_CAN0_MB30_ID1()		bfin_read16(CAN0_MB30_ID1)
+#define bfin_write_CAN0_MB30_ID1(val)		bfin_write16(CAN0_MB30_ID1, val)
+#define bfin_read_CAN0_MB31_DATA0()		bfin_read16(CAN0_MB31_DATA0)
+#define bfin_write_CAN0_MB31_DATA0(val)		bfin_write16(CAN0_MB31_DATA0, val)
+#define bfin_read_CAN0_MB31_DATA1()		bfin_read16(CAN0_MB31_DATA1)
+#define bfin_write_CAN0_MB31_DATA1(val)		bfin_write16(CAN0_MB31_DATA1, val)
+#define bfin_read_CAN0_MB31_DATA2()		bfin_read16(CAN0_MB31_DATA2)
+#define bfin_write_CAN0_MB31_DATA2(val)		bfin_write16(CAN0_MB31_DATA2, val)
+#define bfin_read_CAN0_MB31_DATA3()		bfin_read16(CAN0_MB31_DATA3)
+#define bfin_write_CAN0_MB31_DATA3(val)		bfin_write16(CAN0_MB31_DATA3, val)
+#define bfin_read_CAN0_MB31_LENGTH()		bfin_read16(CAN0_MB31_LENGTH)
+#define bfin_write_CAN0_MB31_LENGTH(val)	bfin_write16(CAN0_MB31_LENGTH, val)
+#define bfin_read_CAN0_MB31_TIMESTAMP()		bfin_read16(CAN0_MB31_TIMESTAMP)
+#define bfin_write_CAN0_MB31_TIMESTAMP(val)	bfin_write16(CAN0_MB31_TIMESTAMP, val)
+#define bfin_read_CAN0_MB31_ID0()		bfin_read16(CAN0_MB31_ID0)
+#define bfin_write_CAN0_MB31_ID0(val)		bfin_write16(CAN0_MB31_ID0, val)
+#define bfin_read_CAN0_MB31_ID1()		bfin_read16(CAN0_MB31_ID1)
+#define bfin_write_CAN0_MB31_ID1(val)		bfin_write16(CAN0_MB31_ID1, val)
+
+/* UART3 Registers */
+
+#define bfin_read_UART3_DLL()		bfin_read16(UART3_DLL)
+#define bfin_write_UART3_DLL(val)	bfin_write16(UART3_DLL, val)
+#define bfin_read_UART3_DLH()		bfin_read16(UART3_DLH)
+#define bfin_write_UART3_DLH(val)	bfin_write16(UART3_DLH, val)
+#define bfin_read_UART3_GCTL()		bfin_read16(UART3_GCTL)
+#define bfin_write_UART3_GCTL(val)	bfin_write16(UART3_GCTL, val)
+#define bfin_read_UART3_LCR()		bfin_read16(UART3_LCR)
+#define bfin_write_UART3_LCR(val)	bfin_write16(UART3_LCR, val)
+#define bfin_read_UART3_MCR()		bfin_read16(UART3_MCR)
+#define bfin_write_UART3_MCR(val)	bfin_write16(UART3_MCR, val)
+#define bfin_read_UART3_LSR()		bfin_read16(UART3_LSR)
+#define bfin_write_UART3_LSR(val)	bfin_write16(UART3_LSR, val)
+#define bfin_read_UART3_MSR()		bfin_read16(UART3_MSR)
+#define bfin_write_UART3_MSR(val)	bfin_write16(UART3_MSR, val)
+#define bfin_read_UART3_SCR()		bfin_read16(UART3_SCR)
+#define bfin_write_UART3_SCR(val)	bfin_write16(UART3_SCR, val)
+#define bfin_read_UART3_IER_SET()	bfin_read16(UART3_IER_SET)
+#define bfin_write_UART3_IER_SET(val)	bfin_write16(UART3_IER_SET, val)
+#define bfin_read_UART3_IER_CLEAR()	bfin_read16(UART3_IER_CLEAR)
+#define bfin_write_UART3_IER_CLEAR(val)	bfin_write16(UART3_IER_CLEAR, val)
+#define bfin_read_UART3_THR()		bfin_read16(UART3_THR)
+#define bfin_write_UART3_THR(val)	bfin_write16(UART3_THR, val)
+#define bfin_read_UART3_RBR()		bfin_read16(UART3_RBR)
+#define bfin_write_UART3_RBR(val)	bfin_write16(UART3_RBR, val)
+
+/* NFC Registers */
+
+#define bfin_read_NFC_CTL()		bfin_read16(NFC_CTL)
+#define bfin_write_NFC_CTL(val)		bfin_write16(NFC_CTL, val)
+#define bfin_read_NFC_STAT()		bfin_read16(NFC_STAT)
+#define bfin_write_NFC_STAT(val)	bfin_write16(NFC_STAT, val)
+#define bfin_read_NFC_IRQSTAT()		bfin_read16(NFC_IRQSTAT)
+#define bfin_write_NFC_IRQSTAT(val)	bfin_write16(NFC_IRQSTAT, val)
+#define bfin_read_NFC_IRQMASK()		bfin_read16(NFC_IRQMASK)
+#define bfin_write_NFC_IRQMASK(val)	bfin_write16(NFC_IRQMASK, val)
+#define bfin_read_NFC_ECC0()		bfin_read16(NFC_ECC0)
+#define bfin_write_NFC_ECC0(val)	bfin_write16(NFC_ECC0, val)
+#define bfin_read_NFC_ECC1()		bfin_read16(NFC_ECC1)
+#define bfin_write_NFC_ECC1(val)	bfin_write16(NFC_ECC1, val)
+#define bfin_read_NFC_ECC2()		bfin_read16(NFC_ECC2)
+#define bfin_write_NFC_ECC2(val)	bfin_write16(NFC_ECC2, val)
+#define bfin_read_NFC_ECC3()		bfin_read16(NFC_ECC3)
+#define bfin_write_NFC_ECC3(val)	bfin_write16(NFC_ECC3, val)
+#define bfin_read_NFC_COUNT()		bfin_read16(NFC_COUNT)
+#define bfin_write_NFC_COUNT(val)	bfin_write16(NFC_COUNT, val)
+#define bfin_read_NFC_RST()		bfin_read16(NFC_RST)
+#define bfin_write_NFC_RST(val)		bfin_write16(NFC_RST, val)
+#define bfin_read_NFC_PGCTL()		bfin_read16(NFC_PGCTL)
+#define bfin_write_NFC_PGCTL(val)	bfin_write16(NFC_PGCTL, val)
+#define bfin_read_NFC_READ()		bfin_read16(NFC_READ)
+#define bfin_write_NFC_READ(val)	bfin_write16(NFC_READ, val)
+#define bfin_read_NFC_ADDR()		bfin_read16(NFC_ADDR)
+#define bfin_write_NFC_ADDR(val)	bfin_write16(NFC_ADDR, val)
+#define bfin_read_NFC_CMD()		bfin_read16(NFC_CMD)
+#define bfin_write_NFC_CMD(val)		bfin_write16(NFC_CMD, val)
+#define bfin_read_NFC_DATA_WR()		bfin_read16(NFC_DATA_WR)
+#define bfin_write_NFC_DATA_WR(val)	bfin_write16(NFC_DATA_WR, val)
+#define bfin_read_NFC_DATA_RD()		bfin_read16(NFC_DATA_RD)
+#define bfin_write_NFC_DATA_RD(val)	bfin_write16(NFC_DATA_RD, val)
+
+/* Counter Registers */
+
+#define bfin_read_CNT_CONFIG()		bfin_read16(CNT_CONFIG)
+#define bfin_write_CNT_CONFIG(val)	bfin_write16(CNT_CONFIG, val)
+#define bfin_read_CNT_IMASK()		bfin_read16(CNT_IMASK)
+#define bfin_write_CNT_IMASK(val)	bfin_write16(CNT_IMASK, val)
+#define bfin_read_CNT_STATUS()		bfin_read16(CNT_STATUS)
+#define bfin_write_CNT_STATUS(val)	bfin_write16(CNT_STATUS, val)
+#define bfin_read_CNT_COMMAND()		bfin_read16(CNT_COMMAND)
+#define bfin_write_CNT_COMMAND(val)	bfin_write16(CNT_COMMAND, val)
+#define bfin_read_CNT_DEBOUNCE()	bfin_read16(CNT_DEBOUNCE)
+#define bfin_write_CNT_DEBOUNCE(val)	bfin_write16(CNT_DEBOUNCE, val)
+#define bfin_read_CNT_COUNTER()		bfin_read32(CNT_COUNTER)
+#define bfin_write_CNT_COUNTER(val)	bfin_write32(CNT_COUNTER, val)
+#define bfin_read_CNT_MAX()		bfin_read32(CNT_MAX)
+#define bfin_write_CNT_MAX(val)		bfin_write32(CNT_MAX, val)
+#define bfin_read_CNT_MIN()		bfin_read32(CNT_MIN)
+#define bfin_write_CNT_MIN(val)		bfin_write32(CNT_MIN, val)
+
+/* OTP/FUSE Registers */
+
+#define bfin_read_OTP_CONTROL()		bfin_read16(OTP_CONTROL)
+#define bfin_write_OTP_CONTROL(val)	bfin_write16(OTP_CONTROL, val)
+#define bfin_read_OTP_BEN()		bfin_read16(OTP_BEN)
+#define bfin_write_OTP_BEN(val)		bfin_write16(OTP_BEN, val)
+#define bfin_read_OTP_STATUS()		bfin_read16(OTP_STATUS)
+#define bfin_write_OTP_STATUS(val)	bfin_write16(OTP_STATUS, val)
+#define bfin_read_OTP_TIMING()		bfin_read32(OTP_TIMING)
+#define bfin_write_OTP_TIMING(val)	bfin_write32(OTP_TIMING, val)
+
+/* Security Registers */
+
+#define bfin_read_SECURE_SYSSWT()	bfin_read32(SECURE_SYSSWT)
+#define bfin_write_SECURE_SYSSWT(val)	bfin_write32(SECURE_SYSSWT, val)
+#define bfin_read_SECURE_CONTROL()	bfin_read16(SECURE_CONTROL)
+#define bfin_write_SECURE_CONTROL(val)	bfin_write16(SECURE_CONTROL, val)
+#define bfin_read_SECURE_STATUS()	bfin_read16(SECURE_STATUS)
+#define bfin_write_SECURE_STATUS(val)	bfin_write16(SECURE_STATUS, val)
+
+/* DMA Peribfin_read_()heral Mux Register */
+
+#define bfin_read_DMAC1_PERIMUX()	bfin_read16(DMAC1_PERIMUX)
+#define bfin_write_DMAC1_PERIMUX(val)	bfin_write16(DMAC1_PERIMUX, val)
+
+/* OTP Read/Write Data Buffer Registers */
+
+#define bfin_read_OTP_DATA0()		bfin_read32(OTP_DATA0)
+#define bfin_write_OTP_DATA0(val)	bfin_write32(OTP_DATA0, val)
+#define bfin_read_OTP_DATA1()		bfin_read32(OTP_DATA1)
+#define bfin_write_OTP_DATA1(val)	bfin_write32(OTP_DATA1, val)
+#define bfin_read_OTP_DATA2()		bfin_read32(OTP_DATA2)
+#define bfin_write_OTP_DATA2(val)	bfin_write32(OTP_DATA2, val)
+#define bfin_read_OTP_DATA3()		bfin_read32(OTP_DATA3)
+#define bfin_write_OTP_DATA3(val)	bfin_write32(OTP_DATA3, val)
+
+/* Handshake MDMA is not defined in the shared file because it is not available on the ADSP-BF542 bfin_read_()rocessor */
+
+/* legacy definitions */
+#define bfin_read_EBIU_AMCBCTL0		bfin_read_EBIU_AMBCTL0
+#define bfin_write_EBIU_AMCBCTL0	bfin_write_EBIU_AMBCTL0
+#define bfin_read_EBIU_AMCBCTL1		bfin_read_EBIU_AMBCTL1
+#define bfin_write_EBIU_AMCBCTL1	bfin_write_EBIU_AMBCTL1
+#define bfin_read_PINT0_IRQ		bfin_read_PINT0_REQUEST
+#define bfin_write_PINT0_IRQ		bfin_write_PINT0_REQUEST
+#define bfin_read_PINT1_IRQ		bfin_read_PINT1_REQUEST
+#define bfin_write_PINT1_IRQ		bfin_write_PINT1_REQUEST
+#define bfin_read_PINT2_IRQ		bfin_read_PINT2_REQUEST
+#define bfin_write_PINT2_IRQ		bfin_write_PINT2_REQUEST
+#define bfin_read_PINT3_IRQ		bfin_read_PINT3_REQUEST
+#define bfin_write_PINT3_IRQ		bfin_write_PINT3_REQUEST
+
+#endif /* _CDEF_BF54X_H */
+
diff --git a/include/asm-blackfin/mach-bf548/defBF542.h b/include/asm-blackfin/mach-bf548/defBF542.h
new file mode 100644
index 0000000..ac968fc
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/defBF542.h
@@ -0,0 +1,1206 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/defBF542.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF542_H
+#define _DEF_BF542_H
+
+/* Include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF542 */
+
+/* Include defBF54x_base.h for the set of #defines that are common to all ADSP-BF54x processors */
+#include "defBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF542 that are not in the common header */
+
+/* ATAPI Registers */
+
+#define                    ATAPI_CONTROL  0xffc03800   /* ATAPI Control Register */
+#define                     ATAPI_STATUS  0xffc03804   /* ATAPI Status Register */
+#define                   ATAPI_DEV_ADDR  0xffc03808   /* ATAPI Device Register Address */
+#define                  ATAPI_DEV_TXBUF  0xffc0380c   /* ATAPI Device Register Write Data */
+#define                  ATAPI_DEV_RXBUF  0xffc03810   /* ATAPI Device Register Read Data */
+#define                   ATAPI_INT_MASK  0xffc03814   /* ATAPI Interrupt Mask Register */
+#define                 ATAPI_INT_STATUS  0xffc03818   /* ATAPI Interrupt Status Register */
+#define                   ATAPI_XFER_LEN  0xffc0381c   /* ATAPI Length of Transfer */
+#define                ATAPI_LINE_STATUS  0xffc03820   /* ATAPI Line Status */
+#define                   ATAPI_SM_STATE  0xffc03824   /* ATAPI State Machine Status */
+#define                  ATAPI_TERMINATE  0xffc03828   /* ATAPI Host Terminate */
+#define                 ATAPI_PIO_TFRCNT  0xffc0382c   /* ATAPI PIO mode transfer count */
+#define                 ATAPI_DMA_TFRCNT  0xffc03830   /* ATAPI DMA mode transfer count */
+#define               ATAPI_UMAIN_TFRCNT  0xffc03834   /* ATAPI UDMAIN transfer count */
+#define             ATAPI_UDMAOUT_TFRCNT  0xffc03838   /* ATAPI UDMAOUT transfer count */
+#define                  ATAPI_REG_TIM_0  0xffc03840   /* ATAPI Register Transfer Timing 0 */
+#define                  ATAPI_PIO_TIM_0  0xffc03844   /* ATAPI PIO Timing 0 Register */
+#define                  ATAPI_PIO_TIM_1  0xffc03848   /* ATAPI PIO Timing 1 Register */
+#define                ATAPI_MULTI_TIM_0  0xffc03850   /* ATAPI Multi-DMA Timing 0 Register */
+#define                ATAPI_MULTI_TIM_1  0xffc03854   /* ATAPI Multi-DMA Timing 1 Register */
+#define                ATAPI_MULTI_TIM_2  0xffc03858   /* ATAPI Multi-DMA Timing 2 Register */
+#define                ATAPI_ULTRA_TIM_0  0xffc03860   /* ATAPI Ultra-DMA Timing 0 Register */
+#define                ATAPI_ULTRA_TIM_1  0xffc03864   /* ATAPI Ultra-DMA Timing 1 Register */
+#define                ATAPI_ULTRA_TIM_2  0xffc03868   /* ATAPI Ultra-DMA Timing 2 Register */
+#define                ATAPI_ULTRA_TIM_3  0xffc0386c   /* ATAPI Ultra-DMA Timing 3 Register */
+
+/* SDH Registers */
+
+#define                      SDH_PWR_CTL  0xffc03900   /* SDH Power Control */
+#define                      SDH_CLK_CTL  0xffc03904   /* SDH Clock Control */
+#define                     SDH_ARGUMENT  0xffc03908   /* SDH Argument */
+#define                      SDH_COMMAND  0xffc0390c   /* SDH Command */
+#define                     SDH_RESP_CMD  0xffc03910   /* SDH Response Command */
+#define                    SDH_RESPONSE0  0xffc03914   /* SDH Response0 */
+#define                    SDH_RESPONSE1  0xffc03918   /* SDH Response1 */
+#define                    SDH_RESPONSE2  0xffc0391c   /* SDH Response2 */
+#define                    SDH_RESPONSE3  0xffc03920   /* SDH Response3 */
+#define                   SDH_DATA_TIMER  0xffc03924   /* SDH Data Timer */
+#define                    SDH_DATA_LGTH  0xffc03928   /* SDH Data Length */
+#define                     SDH_DATA_CTL  0xffc0392c   /* SDH Data Control */
+#define                     SDH_DATA_CNT  0xffc03930   /* SDH Data Counter */
+#define                       SDH_STATUS  0xffc03934   /* SDH Status */
+#define                   SDH_STATUS_CLR  0xffc03938   /* SDH Status Clear */
+#define                        SDH_MASK0  0xffc0393c   /* SDH Interrupt0 Mask */
+#define                        SDH_MASK1  0xffc03940   /* SDH Interrupt1 Mask */
+#define                     SDH_FIFO_CNT  0xffc03948   /* SDH FIFO Counter */
+#define                         SDH_FIFO  0xffc03980   /* SDH Data FIFO */
+#define                     SDH_E_STATUS  0xffc039c0   /* SDH Exception Status */
+#define                       SDH_E_MASK  0xffc039c4   /* SDH Exception Mask */
+#define                          SDH_CFG  0xffc039c8   /* SDH Configuration */
+#define                   SDH_RD_WAIT_EN  0xffc039cc   /* SDH Read Wait Enable */
+#define                         SDH_PID0  0xffc039d0   /* SDH Peripheral Identification0 */
+#define                         SDH_PID1  0xffc039d4   /* SDH Peripheral Identification1 */
+#define                         SDH_PID2  0xffc039d8   /* SDH Peripheral Identification2 */
+#define                         SDH_PID3  0xffc039dc   /* SDH Peripheral Identification3 */
+#define                         SDH_PID4  0xffc039e0   /* SDH Peripheral Identification4 */
+#define                         SDH_PID5  0xffc039e4   /* SDH Peripheral Identification5 */
+#define                         SDH_PID6  0xffc039e8   /* SDH Peripheral Identification6 */
+#define                         SDH_PID7  0xffc039ec   /* SDH Peripheral Identification7 */
+
+/* USB Control Registers */
+
+#define                        USB_FADDR  0xffc03c00   /* Function address register */
+#define                        USB_POWER  0xffc03c04   /* Power management register */
+#define                       USB_INTRTX  0xffc03c08   /* Interrupt register for endpoint 0 and Tx endpoint 1 to 7 */
+#define                       USB_INTRRX  0xffc03c0c   /* Interrupt register for Rx endpoints 1 to 7 */
+#define                      USB_INTRTXE  0xffc03c10   /* Interrupt enable register for IntrTx */
+#define                      USB_INTRRXE  0xffc03c14   /* Interrupt enable register for IntrRx */
+#define                      USB_INTRUSB  0xffc03c18   /* Interrupt register for common USB interrupts */
+#define                     USB_INTRUSBE  0xffc03c1c   /* Interrupt enable register for IntrUSB */
+#define                        USB_FRAME  0xffc03c20   /* USB frame number */
+#define                        USB_INDEX  0xffc03c24   /* Index register for selecting the indexed endpoint registers */
+#define                     USB_TESTMODE  0xffc03c28   /* Enabled USB 20 test modes */
+#define                     USB_GLOBINTR  0xffc03c2c   /* Global Interrupt Mask register and Wakeup Exception Interrupt */
+#define                   USB_GLOBAL_CTL  0xffc03c30   /* Global Clock Control for the core */
+
+/* USB Packet Control Registers */
+
+#define                USB_TX_MAX_PACKET  0xffc03c40   /* Maximum packet size for Host Tx endpoint */
+#define                         USB_CSR0  0xffc03c44   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                        USB_TXCSR  0xffc03c44   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                USB_RX_MAX_PACKET  0xffc03c48   /* Maximum packet size for Host Rx endpoint */
+#define                        USB_RXCSR  0xffc03c4c   /* Control Status register for Host Rx endpoint */
+#define                       USB_COUNT0  0xffc03c50   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                      USB_RXCOUNT  0xffc03c50   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                       USB_TXTYPE  0xffc03c54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint */
+#define                    USB_NAKLIMIT0  0xffc03c58   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                   USB_TXINTERVAL  0xffc03c58   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                       USB_RXTYPE  0xffc03c5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint */
+#define                   USB_RXINTERVAL  0xffc03c60   /* Sets the polling interval for Interrupt and Isochronous transfers or the NAK response timeout on Bulk transfers */
+#define                      USB_TXCOUNT  0xffc03c68   /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* USB Endpoint FIFO Registers */
+
+#define                     USB_EP0_FIFO  0xffc03c80   /* Endpoint 0 FIFO */
+#define                     USB_EP1_FIFO  0xffc03c88   /* Endpoint 1 FIFO */
+#define                     USB_EP2_FIFO  0xffc03c90   /* Endpoint 2 FIFO */
+#define                     USB_EP3_FIFO  0xffc03c98   /* Endpoint 3 FIFO */
+#define                     USB_EP4_FIFO  0xffc03ca0   /* Endpoint 4 FIFO */
+#define                     USB_EP5_FIFO  0xffc03ca8   /* Endpoint 5 FIFO */
+#define                     USB_EP6_FIFO  0xffc03cb0   /* Endpoint 6 FIFO */
+#define                     USB_EP7_FIFO  0xffc03cb8   /* Endpoint 7 FIFO */
+
+/* USB OTG Control Registers */
+
+#define                  USB_OTG_DEV_CTL  0xffc03d00   /* OTG Device Control Register */
+#define                 USB_OTG_VBUS_IRQ  0xffc03d04   /* OTG VBUS Control Interrupts */
+#define                USB_OTG_VBUS_MASK  0xffc03d08   /* VBUS Control Interrupt Enable */
+
+/* USB Phy Control Registers */
+
+#define                     USB_LINKINFO  0xffc03d48   /* Enables programming of some PHY-side delays */
+#define                        USB_VPLEN  0xffc03d4c   /* Determines duration of VBUS pulse for VBUS charging */
+#define                      USB_HS_EOF1  0xffc03d50   /* Time buffer for High-Speed transactions */
+#define                      USB_FS_EOF1  0xffc03d54   /* Time buffer for Full-Speed transactions */
+#define                      USB_LS_EOF1  0xffc03d58   /* Time buffer for Low-Speed transactions */
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define                   USB_APHY_CNTRL  0xffc03de0   /* Register that increases visibility of Analog PHY */
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define                   USB_APHY_CALIB  0xffc03de4   /* Register used to set some calibration values */
+#define                  USB_APHY_CNTRL2  0xffc03de8   /* Register used to prevent re-enumeration once Moab goes into hibernate mode */
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define                     USB_PHY_TEST  0xffc03dec   /* Used for reducing simulation time and simplifies FIFO testability */
+#define                  USB_PLLOSC_CTRL  0xffc03df0   /* Used to program different parameters for USB PLL and Oscillator */
+#define                   USB_SRP_CLKDIV  0xffc03df4   /* Used to program clock divide value for the clock fed to the SRP detection logic */
+
+/* USB Endpoint 0 Control Registers */
+
+#define                USB_EP_NI0_TXMAXP  0xffc03e00   /* Maximum packet size for Host Tx endpoint0 */
+#define                 USB_EP_NI0_TXCSR  0xffc03e04   /* Control Status register for endpoint 0 */
+#define                USB_EP_NI0_RXMAXP  0xffc03e08   /* Maximum packet size for Host Rx endpoint0 */
+#define                 USB_EP_NI0_RXCSR  0xffc03e0c   /* Control Status register for Host Rx endpoint0 */
+#define               USB_EP_NI0_RXCOUNT  0xffc03e10   /* Number of bytes received in endpoint 0 FIFO */
+#define                USB_EP_NI0_TXTYPE  0xffc03e14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint0 */
+#define            USB_EP_NI0_TXINTERVAL  0xffc03e18   /* Sets the NAK response timeout on Endpoint 0 */
+#define                USB_EP_NI0_RXTYPE  0xffc03e1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint0 */
+#define            USB_EP_NI0_RXINTERVAL  0xffc03e20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint0 */
+
+/* USB Endpoint 1 Control Registers */
+
+#define               USB_EP_NI0_TXCOUNT  0xffc03e28   /* Number of bytes to be written to the endpoint0 Tx FIFO */
+#define                USB_EP_NI1_TXMAXP  0xffc03e40   /* Maximum packet size for Host Tx endpoint1 */
+#define                 USB_EP_NI1_TXCSR  0xffc03e44   /* Control Status register for endpoint1 */
+#define                USB_EP_NI1_RXMAXP  0xffc03e48   /* Maximum packet size for Host Rx endpoint1 */
+#define                 USB_EP_NI1_RXCSR  0xffc03e4c   /* Control Status register for Host Rx endpoint1 */
+#define               USB_EP_NI1_RXCOUNT  0xffc03e50   /* Number of bytes received in endpoint1 FIFO */
+#define                USB_EP_NI1_TXTYPE  0xffc03e54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint1 */
+#define            USB_EP_NI1_TXINTERVAL  0xffc03e58   /* Sets the NAK response timeout on Endpoint1 */
+#define                USB_EP_NI1_RXTYPE  0xffc03e5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint1 */
+#define            USB_EP_NI1_RXINTERVAL  0xffc03e60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint1 */
+
+/* USB Endpoint 2 Control Registers */
+
+#define               USB_EP_NI1_TXCOUNT  0xffc03e68   /* Number of bytes to be written to the+H102 endpoint1 Tx FIFO */
+#define                USB_EP_NI2_TXMAXP  0xffc03e80   /* Maximum packet size for Host Tx endpoint2 */
+#define                 USB_EP_NI2_TXCSR  0xffc03e84   /* Control Status register for endpoint2 */
+#define                USB_EP_NI2_RXMAXP  0xffc03e88   /* Maximum packet size for Host Rx endpoint2 */
+#define                 USB_EP_NI2_RXCSR  0xffc03e8c   /* Control Status register for Host Rx endpoint2 */
+#define               USB_EP_NI2_RXCOUNT  0xffc03e90   /* Number of bytes received in endpoint2 FIFO */
+#define                USB_EP_NI2_TXTYPE  0xffc03e94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint2 */
+#define            USB_EP_NI2_TXINTERVAL  0xffc03e98   /* Sets the NAK response timeout on Endpoint2 */
+#define                USB_EP_NI2_RXTYPE  0xffc03e9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint2 */
+#define            USB_EP_NI2_RXINTERVAL  0xffc03ea0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint2 */
+
+/* USB Endpoint 3 Control Registers */
+
+#define               USB_EP_NI2_TXCOUNT  0xffc03ea8   /* Number of bytes to be written to the endpoint2 Tx FIFO */
+#define                USB_EP_NI3_TXMAXP  0xffc03ec0   /* Maximum packet size for Host Tx endpoint3 */
+#define                 USB_EP_NI3_TXCSR  0xffc03ec4   /* Control Status register for endpoint3 */
+#define                USB_EP_NI3_RXMAXP  0xffc03ec8   /* Maximum packet size for Host Rx endpoint3 */
+#define                 USB_EP_NI3_RXCSR  0xffc03ecc   /* Control Status register for Host Rx endpoint3 */
+#define               USB_EP_NI3_RXCOUNT  0xffc03ed0   /* Number of bytes received in endpoint3 FIFO */
+#define                USB_EP_NI3_TXTYPE  0xffc03ed4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint3 */
+#define            USB_EP_NI3_TXINTERVAL  0xffc03ed8   /* Sets the NAK response timeout on Endpoint3 */
+#define                USB_EP_NI3_RXTYPE  0xffc03edc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint3 */
+#define            USB_EP_NI3_RXINTERVAL  0xffc03ee0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint3 */
+
+/* USB Endpoint 4 Control Registers */
+
+#define               USB_EP_NI3_TXCOUNT  0xffc03ee8   /* Number of bytes to be written to the H124endpoint3 Tx FIFO */
+#define                USB_EP_NI4_TXMAXP  0xffc03f00   /* Maximum packet size for Host Tx endpoint4 */
+#define                 USB_EP_NI4_TXCSR  0xffc03f04   /* Control Status register for endpoint4 */
+#define                USB_EP_NI4_RXMAXP  0xffc03f08   /* Maximum packet size for Host Rx endpoint4 */
+#define                 USB_EP_NI4_RXCSR  0xffc03f0c   /* Control Status register for Host Rx endpoint4 */
+#define               USB_EP_NI4_RXCOUNT  0xffc03f10   /* Number of bytes received in endpoint4 FIFO */
+#define                USB_EP_NI4_TXTYPE  0xffc03f14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint4 */
+#define            USB_EP_NI4_TXINTERVAL  0xffc03f18   /* Sets the NAK response timeout on Endpoint4 */
+#define                USB_EP_NI4_RXTYPE  0xffc03f1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint4 */
+#define            USB_EP_NI4_RXINTERVAL  0xffc03f20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint4 */
+
+/* USB Endpoint 5 Control Registers */
+
+#define               USB_EP_NI4_TXCOUNT  0xffc03f28   /* Number of bytes to be written to the endpoint4 Tx FIFO */
+#define                USB_EP_NI5_TXMAXP  0xffc03f40   /* Maximum packet size for Host Tx endpoint5 */
+#define                 USB_EP_NI5_TXCSR  0xffc03f44   /* Control Status register for endpoint5 */
+#define                USB_EP_NI5_RXMAXP  0xffc03f48   /* Maximum packet size for Host Rx endpoint5 */
+#define                 USB_EP_NI5_RXCSR  0xffc03f4c   /* Control Status register for Host Rx endpoint5 */
+#define               USB_EP_NI5_RXCOUNT  0xffc03f50   /* Number of bytes received in endpoint5 FIFO */
+#define                USB_EP_NI5_TXTYPE  0xffc03f54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint5 */
+#define            USB_EP_NI5_TXINTERVAL  0xffc03f58   /* Sets the NAK response timeout on Endpoint5 */
+#define                USB_EP_NI5_RXTYPE  0xffc03f5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint5 */
+#define            USB_EP_NI5_RXINTERVAL  0xffc03f60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint5 */
+
+/* USB Endpoint 6 Control Registers */
+
+#define               USB_EP_NI5_TXCOUNT  0xffc03f68   /* Number of bytes to be written to the H145endpoint5 Tx FIFO */
+#define                USB_EP_NI6_TXMAXP  0xffc03f80   /* Maximum packet size for Host Tx endpoint6 */
+#define                 USB_EP_NI6_TXCSR  0xffc03f84   /* Control Status register for endpoint6 */
+#define                USB_EP_NI6_RXMAXP  0xffc03f88   /* Maximum packet size for Host Rx endpoint6 */
+#define                 USB_EP_NI6_RXCSR  0xffc03f8c   /* Control Status register for Host Rx endpoint6 */
+#define               USB_EP_NI6_RXCOUNT  0xffc03f90   /* Number of bytes received in endpoint6 FIFO */
+#define                USB_EP_NI6_TXTYPE  0xffc03f94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint6 */
+#define            USB_EP_NI6_TXINTERVAL  0xffc03f98   /* Sets the NAK response timeout on Endpoint6 */
+#define                USB_EP_NI6_RXTYPE  0xffc03f9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint6 */
+#define            USB_EP_NI6_RXINTERVAL  0xffc03fa0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint6 */
+
+/* USB Endpoint 7 Control Registers */
+
+#define               USB_EP_NI6_TXCOUNT  0xffc03fa8   /* Number of bytes to be written to the endpoint6 Tx FIFO */
+#define                USB_EP_NI7_TXMAXP  0xffc03fc0   /* Maximum packet size for Host Tx endpoint7 */
+#define                 USB_EP_NI7_TXCSR  0xffc03fc4   /* Control Status register for endpoint7 */
+#define                USB_EP_NI7_RXMAXP  0xffc03fc8   /* Maximum packet size for Host Rx endpoint7 */
+#define                 USB_EP_NI7_RXCSR  0xffc03fcc   /* Control Status register for Host Rx endpoint7 */
+#define               USB_EP_NI7_RXCOUNT  0xffc03fd0   /* Number of bytes received in endpoint7 FIFO */
+#define                USB_EP_NI7_TXTYPE  0xffc03fd4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint7 */
+#define            USB_EP_NI7_TXINTERVAL  0xffc03fd8   /* Sets the NAK response timeout on Endpoint7 */
+#define                USB_EP_NI7_RXTYPE  0xffc03fdc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint7 */
+#define            USB_EP_NI7_RXINTERVAL  0xffc03ff0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint7 */
+#define               USB_EP_NI7_TXCOUNT  0xffc03ff8   /* Number of bytes to be written to the endpoint7 Tx FIFO */
+#define                USB_DMA_INTERRUPT  0xffc04000   /* Indicates pending interrupts for the DMA channels */
+
+/* USB Channel 0 Config Registers */
+
+#define                  USB_DMA0CONTROL  0xffc04004   /* DMA master channel 0 configuration */
+#define                  USB_DMA0ADDRLOW  0xffc04008   /* Lower 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0ADDRHIGH  0xffc0400c   /* Upper 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0COUNTLOW  0xffc04010   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 0 */
+#define                USB_DMA0COUNTHIGH  0xffc04014   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 0 */
+
+/* USB Channel 1 Config Registers */
+
+#define                  USB_DMA1CONTROL  0xffc04024   /* DMA master channel 1 configuration */
+#define                  USB_DMA1ADDRLOW  0xffc04028   /* Lower 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1ADDRHIGH  0xffc0402c   /* Upper 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1COUNTLOW  0xffc04030   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 1 */
+#define                USB_DMA1COUNTHIGH  0xffc04034   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 1 */
+
+/* USB Channel 2 Config Registers */
+
+#define                  USB_DMA2CONTROL  0xffc04044   /* DMA master channel 2 configuration */
+#define                  USB_DMA2ADDRLOW  0xffc04048   /* Lower 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2ADDRHIGH  0xffc0404c   /* Upper 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2COUNTLOW  0xffc04050   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 2 */
+#define                USB_DMA2COUNTHIGH  0xffc04054   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 2 */
+
+/* USB Channel 3 Config Registers */
+
+#define                  USB_DMA3CONTROL  0xffc04064   /* DMA master channel 3 configuration */
+#define                  USB_DMA3ADDRLOW  0xffc04068   /* Lower 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3ADDRHIGH  0xffc0406c   /* Upper 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3COUNTLOW  0xffc04070   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 3 */
+#define                USB_DMA3COUNTHIGH  0xffc04074   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 3 */
+
+/* USB Channel 4 Config Registers */
+
+#define                  USB_DMA4CONTROL  0xffc04084   /* DMA master channel 4 configuration */
+#define                  USB_DMA4ADDRLOW  0xffc04088   /* Lower 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4ADDRHIGH  0xffc0408c   /* Upper 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4COUNTLOW  0xffc04090   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 4 */
+#define                USB_DMA4COUNTHIGH  0xffc04094   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 4 */
+
+/* USB Channel 5 Config Registers */
+
+#define                  USB_DMA5CONTROL  0xffc040a4   /* DMA master channel 5 configuration */
+#define                  USB_DMA5ADDRLOW  0xffc040a8   /* Lower 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5ADDRHIGH  0xffc040ac   /* Upper 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5COUNTLOW  0xffc040b0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 5 */
+#define                USB_DMA5COUNTHIGH  0xffc040b4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 5 */
+
+/* USB Channel 6 Config Registers */
+
+#define                  USB_DMA6CONTROL  0xffc040c4   /* DMA master channel 6 configuration */
+#define                  USB_DMA6ADDRLOW  0xffc040c8   /* Lower 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6ADDRHIGH  0xffc040cc   /* Upper 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6COUNTLOW  0xffc040d0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 6 */
+#define                USB_DMA6COUNTHIGH  0xffc040d4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 6 */
+
+/* USB Channel 7 Config Registers */
+
+#define                  USB_DMA7CONTROL  0xffc040e4   /* DMA master channel 7 configuration */
+#define                  USB_DMA7ADDRLOW  0xffc040e8   /* Lower 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7ADDRHIGH  0xffc040ec   /* Upper 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7COUNTLOW  0xffc040f0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 7 */
+#define                USB_DMA7COUNTHIGH  0xffc040f4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 7 */
+
+/* Keypad Registers */
+
+#define                         KPAD_CTL  0xffc04100   /* Controls keypad module enable and disable */
+#define                    KPAD_PRESCALE  0xffc04104   /* Establish a time base for programing the KPAD_MSEL register */
+#define                        KPAD_MSEL  0xffc04108   /* Selects delay parameters for keypad interface sensitivity */
+#define                      KPAD_ROWCOL  0xffc0410c   /* Captures the row and column output values of the keys pressed */
+#define                        KPAD_STAT  0xffc04110   /* Holds and clears the status of the keypad interface interrupt */
+#define                    KPAD_SOFTEVAL  0xffc04114   /* Lets software force keypad interface to check for keys being pressed */
+
+
+/* ********************************************************** */
+/*     SINGLE BIT MACRO PAIRS (bit mask and negated one)      */
+/*     and MULTI BIT READ MACROS                              */
+/* ********************************************************** */
+
+/* Bit masks for KPAD_CTL */
+
+#define                   KPAD_EN  0x1        /* Keypad Enable */
+#define                  nKPAD_EN  0x0       
+#define              KPAD_IRQMODE  0x6        /* Key Press Interrupt Enable */
+#define                KPAD_ROWEN  0x1c00     /* Row Enable Width */
+#define                KPAD_COLEN  0xe000     /* Column Enable Width */
+
+/* Bit masks for KPAD_PRESCALE */
+
+#define         KPAD_PRESCALE_VAL  0x3f       /* Key Prescale Value */
+
+/* Bit masks for KPAD_MSEL */
+
+#define                DBON_SCALE  0xff       /* Debounce Scale Value */
+#define              COLDRV_SCALE  0xff00     /* Column Driver Scale Value */
+
+/* Bit masks for KPAD_ROWCOL */
+
+#define                  KPAD_ROW  0xff       /* Rows Pressed */
+#define                  KPAD_COL  0xff00     /* Columns Pressed */
+
+/* Bit masks for KPAD_STAT */
+
+#define                  KPAD_IRQ  0x1        /* Keypad Interrupt Status */
+#define                 nKPAD_IRQ  0x0       
+#define              KPAD_MROWCOL  0x6        /* Multiple Row/Column Keypress Status */
+#define              KPAD_PRESSED  0x8        /* Key press current status */
+#define             nKPAD_PRESSED  0x0       
+
+/* Bit masks for KPAD_SOFTEVAL */
+
+#define           KPAD_SOFTEVAL_E  0x2        /* Software Programmable Force Evaluate */
+#define          nKPAD_SOFTEVAL_E  0x0       
+
+/* Bit masks for SDH_COMMAND */
+
+#define                   CMD_IDX  0x3f       /* Command Index */
+#define                   CMD_RSP  0x40       /* Response */
+#define                  nCMD_RSP  0x0       
+#define                 CMD_L_RSP  0x80       /* Long Response */
+#define                nCMD_L_RSP  0x0       
+#define                 CMD_INT_E  0x100      /* Command Interrupt */
+#define                nCMD_INT_E  0x0       
+#define                CMD_PEND_E  0x200      /* Command Pending */
+#define               nCMD_PEND_E  0x0       
+#define                     CMD_E  0x400      /* Command Enable */
+#define                    nCMD_E  0x0       
+
+/* Bit masks for SDH_PWR_CTL */
+
+#define                    PWR_ON  0x3        /* Power On */
+#if 0
+#define                       TBD  0x3c       /* TBD */
+#endif
+#define                 SD_CMD_OD  0x40       /* Open Drain Output */
+#define                nSD_CMD_OD  0x0       
+#define                   ROD_CTL  0x80       /* Rod Control */
+#define                  nROD_CTL  0x0       
+
+/* Bit masks for SDH_CLK_CTL */
+
+#define                    CLKDIV  0xff       /* MC_CLK Divisor */
+#define                     CLK_E  0x100      /* MC_CLK Bus Clock Enable */
+#define                    nCLK_E  0x0       
+#define                  PWR_SV_E  0x200      /* Power Save Enable */
+#define                 nPWR_SV_E  0x0       
+#define             CLKDIV_BYPASS  0x400      /* Bypass Divisor */
+#define            nCLKDIV_BYPASS  0x0       
+#define                  WIDE_BUS  0x800      /* Wide Bus Mode Enable */
+#define                 nWIDE_BUS  0x0       
+
+/* Bit masks for SDH_RESP_CMD */
+
+#define                  RESP_CMD  0x3f       /* Response Command */
+
+/* Bit masks for SDH_DATA_CTL */
+
+#define                     DTX_E  0x1        /* Data Transfer Enable */
+#define                    nDTX_E  0x0       
+#define                   DTX_DIR  0x2        /* Data Transfer Direction */
+#define                  nDTX_DIR  0x0       
+#define                  DTX_MODE  0x4        /* Data Transfer Mode */
+#define                 nDTX_MODE  0x0       
+#define                 DTX_DMA_E  0x8        /* Data Transfer DMA Enable */
+#define                nDTX_DMA_E  0x0       
+#define              DTX_BLK_LGTH  0xf0       /* Data Transfer Block Length */
+
+/* Bit masks for SDH_STATUS */
+
+#define              CMD_CRC_FAIL  0x1        /* CMD CRC Fail */
+#define             nCMD_CRC_FAIL  0x0       
+#define              DAT_CRC_FAIL  0x2        /* Data CRC Fail */
+#define             nDAT_CRC_FAIL  0x0       
+#define               CMD_TIMEOUT  0x4        /* CMD Time Out */
+#define              nCMD_TIMEOUT  0x0       
+#define               DAT_TIMEOUT  0x8        /* Data Time Out */
+#define              nDAT_TIMEOUT  0x0       
+#define               TX_UNDERRUN  0x10       /* Transmit Underrun */
+#define              nTX_UNDERRUN  0x0       
+#define                RX_OVERRUN  0x20       /* Receive Overrun */
+#define               nRX_OVERRUN  0x0       
+#define              CMD_RESP_END  0x40       /* CMD Response End */
+#define             nCMD_RESP_END  0x0       
+#define                  CMD_SENT  0x80       /* CMD Sent */
+#define                 nCMD_SENT  0x0       
+#define                   DAT_END  0x100      /* Data End */
+#define                  nDAT_END  0x0       
+#define             START_BIT_ERR  0x200      /* Start Bit Error */
+#define            nSTART_BIT_ERR  0x0       
+#define               DAT_BLK_END  0x400      /* Data Block End */
+#define              nDAT_BLK_END  0x0       
+#define                   CMD_ACT  0x800      /* CMD Active */
+#define                  nCMD_ACT  0x0       
+#define                    TX_ACT  0x1000     /* Transmit Active */
+#define                   nTX_ACT  0x0       
+#define                    RX_ACT  0x2000     /* Receive Active */
+#define                   nRX_ACT  0x0       
+#define              TX_FIFO_STAT  0x4000     /* Transmit FIFO Status */
+#define             nTX_FIFO_STAT  0x0       
+#define              RX_FIFO_STAT  0x8000     /* Receive FIFO Status */
+#define             nRX_FIFO_STAT  0x0       
+#define              TX_FIFO_FULL  0x10000    /* Transmit FIFO Full */
+#define             nTX_FIFO_FULL  0x0       
+#define              RX_FIFO_FULL  0x20000    /* Receive FIFO Full */
+#define             nRX_FIFO_FULL  0x0       
+#define              TX_FIFO_ZERO  0x40000    /* Transmit FIFO Empty */
+#define             nTX_FIFO_ZERO  0x0       
+#define               RX_DAT_ZERO  0x80000    /* Receive FIFO Empty */
+#define              nRX_DAT_ZERO  0x0       
+#define                TX_DAT_RDY  0x100000   /* Transmit Data Available */
+#define               nTX_DAT_RDY  0x0       
+#define               RX_FIFO_RDY  0x200000   /* Receive Data Available */
+#define              nRX_FIFO_RDY  0x0       
+
+/* Bit masks for SDH_STATUS_CLR */
+
+#define         CMD_CRC_FAIL_STAT  0x1        /* CMD CRC Fail Status */
+#define        nCMD_CRC_FAIL_STAT  0x0       
+#define         DAT_CRC_FAIL_STAT  0x2        /* Data CRC Fail Status */
+#define        nDAT_CRC_FAIL_STAT  0x0       
+#define          CMD_TIMEOUT_STAT  0x4        /* CMD Time Out Status */
+#define         nCMD_TIMEOUT_STAT  0x0       
+#define          DAT_TIMEOUT_STAT  0x8        /* Data Time Out status */
+#define         nDAT_TIMEOUT_STAT  0x0       
+#define          TX_UNDERRUN_STAT  0x10       /* Transmit Underrun Status */
+#define         nTX_UNDERRUN_STAT  0x0       
+#define           RX_OVERRUN_STAT  0x20       /* Receive Overrun Status */
+#define          nRX_OVERRUN_STAT  0x0       
+#define         CMD_RESP_END_STAT  0x40       /* CMD Response End Status */
+#define        nCMD_RESP_END_STAT  0x0       
+#define             CMD_SENT_STAT  0x80       /* CMD Sent Status */
+#define            nCMD_SENT_STAT  0x0       
+#define              DAT_END_STAT  0x100      /* Data End Status */
+#define             nDAT_END_STAT  0x0       
+#define        START_BIT_ERR_STAT  0x200      /* Start Bit Error Status */
+#define       nSTART_BIT_ERR_STAT  0x0       
+#define          DAT_BLK_END_STAT  0x400      /* Data Block End Status */
+#define         nDAT_BLK_END_STAT  0x0       
+
+/* Bit masks for SDH_MASK0 */
+
+#define         CMD_CRC_FAIL_MASK  0x1        /* CMD CRC Fail Mask */
+#define        nCMD_CRC_FAIL_MASK  0x0       
+#define         DAT_CRC_FAIL_MASK  0x2        /* Data CRC Fail Mask */
+#define        nDAT_CRC_FAIL_MASK  0x0       
+#define          CMD_TIMEOUT_MASK  0x4        /* CMD Time Out Mask */
+#define         nCMD_TIMEOUT_MASK  0x0       
+#define          DAT_TIMEOUT_MASK  0x8        /* Data Time Out Mask */
+#define         nDAT_TIMEOUT_MASK  0x0       
+#define          TX_UNDERRUN_MASK  0x10       /* Transmit Underrun Mask */
+#define         nTX_UNDERRUN_MASK  0x0       
+#define           RX_OVERRUN_MASK  0x20       /* Receive Overrun Mask */
+#define          nRX_OVERRUN_MASK  0x0       
+#define         CMD_RESP_END_MASK  0x40       /* CMD Response End Mask */
+#define        nCMD_RESP_END_MASK  0x0       
+#define             CMD_SENT_MASK  0x80       /* CMD Sent Mask */
+#define            nCMD_SENT_MASK  0x0       
+#define              DAT_END_MASK  0x100      /* Data End Mask */
+#define             nDAT_END_MASK  0x0       
+#define        START_BIT_ERR_MASK  0x200      /* Start Bit Error Mask */
+#define       nSTART_BIT_ERR_MASK  0x0       
+#define          DAT_BLK_END_MASK  0x400      /* Data Block End Mask */
+#define         nDAT_BLK_END_MASK  0x0       
+#define              CMD_ACT_MASK  0x800      /* CMD Active Mask */
+#define             nCMD_ACT_MASK  0x0       
+#define               TX_ACT_MASK  0x1000     /* Transmit Active Mask */
+#define              nTX_ACT_MASK  0x0       
+#define               RX_ACT_MASK  0x2000     /* Receive Active Mask */
+#define              nRX_ACT_MASK  0x0       
+#define         TX_FIFO_STAT_MASK  0x4000     /* Transmit FIFO Status Mask */
+#define        nTX_FIFO_STAT_MASK  0x0       
+#define         RX_FIFO_STAT_MASK  0x8000     /* Receive FIFO Status Mask */
+#define        nRX_FIFO_STAT_MASK  0x0       
+#define         TX_FIFO_FULL_MASK  0x10000    /* Transmit FIFO Full Mask */
+#define        nTX_FIFO_FULL_MASK  0x0       
+#define         RX_FIFO_FULL_MASK  0x20000    /* Receive FIFO Full Mask */
+#define        nRX_FIFO_FULL_MASK  0x0       
+#define         TX_FIFO_ZERO_MASK  0x40000    /* Transmit FIFO Empty Mask */
+#define        nTX_FIFO_ZERO_MASK  0x0       
+#define          RX_DAT_ZERO_MASK  0x80000    /* Receive FIFO Empty Mask */
+#define         nRX_DAT_ZERO_MASK  0x0       
+#define           TX_DAT_RDY_MASK  0x100000   /* Transmit Data Available Mask */
+#define          nTX_DAT_RDY_MASK  0x0       
+#define          RX_FIFO_RDY_MASK  0x200000   /* Receive Data Available Mask */
+#define         nRX_FIFO_RDY_MASK  0x0       
+
+/* Bit masks for SDH_FIFO_CNT */
+
+#define                FIFO_COUNT  0x7fff     /* FIFO Count */
+
+/* Bit masks for SDH_E_STATUS */
+
+#define              SDIO_INT_DET  0x2        /* SDIO Int Detected */
+#define             nSDIO_INT_DET  0x0       
+#define               SD_CARD_DET  0x10       /* SD Card Detect */
+#define              nSD_CARD_DET  0x0       
+
+/* Bit masks for SDH_E_MASK */
+
+#define                  SDIO_MSK  0x2        /* Mask SDIO Int Detected */
+#define                 nSDIO_MSK  0x0       
+#define                   SCD_MSK  0x40       /* Mask Card Detect */
+#define                  nSCD_MSK  0x0       
+
+/* Bit masks for SDH_CFG */
+
+#define                   CLKS_EN  0x1        /* Clocks Enable */
+#define                  nCLKS_EN  0x0       
+#define                      SD4E  0x4        /* SDIO 4-Bit Enable */
+#define                     nSD4E  0x0       
+#define                       MWE  0x8        /* Moving Window Enable */
+#define                      nMWE  0x0       
+#define                    SD_RST  0x10       /* SDMMC Reset */
+#define                   nSD_RST  0x0       
+#define                 PUP_SDDAT  0x20       /* Pull-up SD_DAT */
+#define                nPUP_SDDAT  0x0       
+#define                PUP_SDDAT3  0x40       /* Pull-up SD_DAT3 */
+#define               nPUP_SDDAT3  0x0       
+#define                 PD_SDDAT3  0x80       /* Pull-down SD_DAT3 */
+#define                nPD_SDDAT3  0x0       
+
+/* Bit masks for SDH_RD_WAIT_EN */
+
+#define                       RWR  0x1        /* Read Wait Request */
+#define                      nRWR  0x0       
+
+/* Bit masks for ATAPI_CONTROL */
+
+#define                 PIO_START  0x1        /* Start PIO/Reg Op */
+#define                nPIO_START  0x0       
+#define               MULTI_START  0x2        /* Start Multi-DMA Op */
+#define              nMULTI_START  0x0       
+#define               ULTRA_START  0x4        /* Start Ultra-DMA Op */
+#define              nULTRA_START  0x0       
+#define                  XFER_DIR  0x8        /* Transfer Direction */
+#define                 nXFER_DIR  0x0       
+#define                  IORDY_EN  0x10       /* IORDY Enable */
+#define                 nIORDY_EN  0x0       
+#define                FIFO_FLUSH  0x20       /* Flush FIFOs */
+#define               nFIFO_FLUSH  0x0       
+#define                  SOFT_RST  0x40       /* Soft Reset */
+#define                 nSOFT_RST  0x0       
+#define                   DEV_RST  0x80       /* Device Reset */
+#define                  nDEV_RST  0x0       
+#define                TFRCNT_RST  0x100      /* Trans Count Reset */
+#define               nTFRCNT_RST  0x0       
+#define               END_ON_TERM  0x200      /* End/Terminate Select */
+#define              nEND_ON_TERM  0x0       
+#define               PIO_USE_DMA  0x400      /* PIO-DMA Enable */
+#define              nPIO_USE_DMA  0x0       
+#define          UDMAIN_FIFO_THRS  0xf000     /* Ultra DMA-IN FIFO Threshold */
+
+/* Bit masks for ATAPI_STATUS */
+
+#define               PIO_XFER_ON  0x1        /* PIO transfer in progress */
+#define              nPIO_XFER_ON  0x0       
+#define             MULTI_XFER_ON  0x2        /* Multi-word DMA transfer in progress */
+#define            nMULTI_XFER_ON  0x0       
+#define             ULTRA_XFER_ON  0x4        /* Ultra DMA transfer in progress */
+#define            nULTRA_XFER_ON  0x0       
+#define               ULTRA_IN_FL  0xf0       /* Ultra DMA Input FIFO Level */
+
+/* Bit masks for ATAPI_DEV_ADDR */
+
+#define                  DEV_ADDR  0x1f       /* Device Address */
+
+/* Bit masks for ATAPI_INT_MASK */
+
+#define        ATAPI_DEV_INT_MASK  0x1        /* Device interrupt mask */
+#define       nATAPI_DEV_INT_MASK  0x0       
+#define             PIO_DONE_MASK  0x2        /* PIO transfer done interrupt mask */
+#define            nPIO_DONE_MASK  0x0       
+#define           MULTI_DONE_MASK  0x4        /* Multi-DMA transfer done interrupt mask */
+#define          nMULTI_DONE_MASK  0x0       
+#define          UDMAIN_DONE_MASK  0x8        /* Ultra-DMA in transfer done interrupt mask */
+#define         nUDMAIN_DONE_MASK  0x0       
+#define         UDMAOUT_DONE_MASK  0x10       /* Ultra-DMA out transfer done interrupt mask */
+#define        nUDMAOUT_DONE_MASK  0x0       
+#define       HOST_TERM_XFER_MASK  0x20       /* Host terminate current transfer interrupt mask */
+#define      nHOST_TERM_XFER_MASK  0x0       
+#define           MULTI_TERM_MASK  0x40       /* Device terminate Multi-DMA transfer interrupt mask */
+#define          nMULTI_TERM_MASK  0x0       
+#define          UDMAIN_TERM_MASK  0x80       /* Device terminate Ultra-DMA-in transfer interrupt mask */
+#define         nUDMAIN_TERM_MASK  0x0       
+#define         UDMAOUT_TERM_MASK  0x100      /* Device terminate Ultra-DMA-out transfer interrupt mask */
+#define        nUDMAOUT_TERM_MASK  0x0       
+
+/* Bit masks for ATAPI_INT_STATUS */
+
+#define             ATAPI_DEV_INT  0x1        /* Device interrupt status */
+#define            nATAPI_DEV_INT  0x0       
+#define              PIO_DONE_INT  0x2        /* PIO transfer done interrupt status */
+#define             nPIO_DONE_INT  0x0       
+#define            MULTI_DONE_INT  0x4        /* Multi-DMA transfer done interrupt status */
+#define           nMULTI_DONE_INT  0x0       
+#define           UDMAIN_DONE_INT  0x8        /* Ultra-DMA in transfer done interrupt status */
+#define          nUDMAIN_DONE_INT  0x0       
+#define          UDMAOUT_DONE_INT  0x10       /* Ultra-DMA out transfer done interrupt status */
+#define         nUDMAOUT_DONE_INT  0x0       
+#define        HOST_TERM_XFER_INT  0x20       /* Host terminate current transfer interrupt status */
+#define       nHOST_TERM_XFER_INT  0x0       
+#define            MULTI_TERM_INT  0x40       /* Device terminate Multi-DMA transfer interrupt status */
+#define           nMULTI_TERM_INT  0x0       
+#define           UDMAIN_TERM_INT  0x80       /* Device terminate Ultra-DMA-in transfer interrupt status */
+#define          nUDMAIN_TERM_INT  0x0       
+#define          UDMAOUT_TERM_INT  0x100      /* Device terminate Ultra-DMA-out transfer interrupt status */
+#define         nUDMAOUT_TERM_INT  0x0       
+
+/* Bit masks for ATAPI_LINE_STATUS */
+
+#define                ATAPI_INTR  0x1        /* Device interrupt to host line status */
+#define               nATAPI_INTR  0x0       
+#define                ATAPI_DASP  0x2        /* Device dasp to host line status */
+#define               nATAPI_DASP  0x0       
+#define                ATAPI_CS0N  0x4        /* ATAPI chip select 0 line status */
+#define               nATAPI_CS0N  0x0       
+#define                ATAPI_CS1N  0x8        /* ATAPI chip select 1 line status */
+#define               nATAPI_CS1N  0x0       
+#define                ATAPI_ADDR  0x70       /* ATAPI address line status */
+#define              ATAPI_DMAREQ  0x80       /* ATAPI DMA request line status */
+#define             nATAPI_DMAREQ  0x0       
+#define             ATAPI_DMAACKN  0x100      /* ATAPI DMA acknowledge line status */
+#define            nATAPI_DMAACKN  0x0       
+#define               ATAPI_DIOWN  0x200      /* ATAPI write line status */
+#define              nATAPI_DIOWN  0x0       
+#define               ATAPI_DIORN  0x400      /* ATAPI read line status */
+#define              nATAPI_DIORN  0x0       
+#define               ATAPI_IORDY  0x800      /* ATAPI IORDY line status */
+#define              nATAPI_IORDY  0x0       
+
+/* Bit masks for ATAPI_SM_STATE */
+
+#define                PIO_CSTATE  0xf        /* PIO mode state machine current state */
+#define                DMA_CSTATE  0xf0       /* DMA mode state machine current state */
+#define             UDMAIN_CSTATE  0xf00      /* Ultra DMA-In mode state machine current state */
+#define            UDMAOUT_CSTATE  0xf000     /* ATAPI IORDY line status */
+
+/* Bit masks for ATAPI_TERMINATE */
+
+#define           ATAPI_HOST_TERM  0x1        /* Host terminationation */
+#define          nATAPI_HOST_TERM  0x0       
+
+/* Bit masks for ATAPI_REG_TIM_0 */
+
+#define                    T2_REG  0xff       /* End of cycle time for register access transfers */
+#define                  TEOC_REG  0xff00     /* Selects DIOR/DIOW pulsewidth */
+
+/* Bit masks for ATAPI_PIO_TIM_0 */
+
+#define                    T1_REG  0xf        /* Time from address valid to DIOR/DIOW */
+#define                T2_REG_PIO  0xff0      /* DIOR/DIOW pulsewidth */
+#define                    T4_REG  0xf000     /* DIOW data hold */
+
+/* Bit masks for ATAPI_PIO_TIM_1 */
+
+#define              TEOC_REG_PIO  0xff       /* End of cycle time for PIO access transfers. */
+
+/* Bit masks for ATAPI_MULTI_TIM_0 */
+
+#define                        TD  0xff       /* DIOR/DIOW asserted pulsewidth */
+#define                        TM  0xff00     /* Time from address valid to DIOR/DIOW */
+
+/* Bit masks for ATAPI_MULTI_TIM_1 */
+
+#define                       TKW  0xff       /* Selects DIOW negated pulsewidth */
+#define                       TKR  0xff00     /* Selects DIOR negated pulsewidth */
+
+/* Bit masks for ATAPI_MULTI_TIM_2 */
+
+#define                        TH  0xff       /* Selects DIOW data hold */
+#define                      TEOC  0xff00     /* Selects end of cycle for DMA */
+
+/* Bit masks for ATAPI_ULTRA_TIM_0 */
+
+#define                      TACK  0xff       /* Selects setup and hold times for TACK */
+#define                      TENV  0xff00     /* Selects envelope time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_1 */
+
+#define                      TDVS  0xff       /* Selects data valid setup time */
+#define                 TCYC_TDVS  0xff00     /* Selects cycle time - TDVS time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_2 */
+
+#define                       TSS  0xff       /* Selects time from STROBE edge to negation of DMARQ or assertion of STOP */
+#define                      TMLI  0xff00     /* Selects interlock time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_3 */
+
+#define                      TZAH  0xff       /* Selects minimum delay required for output */
+#define               READY_PAUSE  0xff00     /* Selects ready to pause */
+
+/* Bit masks for USB_FADDR */
+
+#define          FUNCTION_ADDRESS  0x7f       /* Function address */
+
+/* Bit masks for USB_POWER */
+
+#define           ENABLE_SUSPENDM  0x1        /* enable SuspendM output */
+#define          nENABLE_SUSPENDM  0x0       
+#define              SUSPEND_MODE  0x2        /* Suspend Mode indicator */
+#define             nSUSPEND_MODE  0x0       
+#define               RESUME_MODE  0x4        /* DMA Mode */
+#define              nRESUME_MODE  0x0       
+#define                     RESET  0x8        /* Reset indicator */
+#define                    nRESET  0x0       
+#define                   HS_MODE  0x10       /* High Speed mode indicator */
+#define                  nHS_MODE  0x0       
+#define                 HS_ENABLE  0x20       /* high Speed Enable */
+#define                nHS_ENABLE  0x0       
+#define                 SOFT_CONN  0x40       /* Soft connect */
+#define                nSOFT_CONN  0x0       
+#define                ISO_UPDATE  0x80       /* Isochronous update */
+#define               nISO_UPDATE  0x0       
+
+/* Bit masks for USB_INTRTX */
+
+#define                    EP0_TX  0x1        /* Tx Endpoint 0 interrupt */
+#define                   nEP0_TX  0x0       
+#define                    EP1_TX  0x2        /* Tx Endpoint 1 interrupt */
+#define                   nEP1_TX  0x0       
+#define                    EP2_TX  0x4        /* Tx Endpoint 2 interrupt */
+#define                   nEP2_TX  0x0       
+#define                    EP3_TX  0x8        /* Tx Endpoint 3 interrupt */
+#define                   nEP3_TX  0x0       
+#define                    EP4_TX  0x10       /* Tx Endpoint 4 interrupt */
+#define                   nEP4_TX  0x0       
+#define                    EP5_TX  0x20       /* Tx Endpoint 5 interrupt */
+#define                   nEP5_TX  0x0       
+#define                    EP6_TX  0x40       /* Tx Endpoint 6 interrupt */
+#define                   nEP6_TX  0x0       
+#define                    EP7_TX  0x80       /* Tx Endpoint 7 interrupt */
+#define                   nEP7_TX  0x0       
+
+/* Bit masks for USB_INTRRX */
+
+#define                    EP1_RX  0x2        /* Rx Endpoint 1 interrupt */
+#define                   nEP1_RX  0x0       
+#define                    EP2_RX  0x4        /* Rx Endpoint 2 interrupt */
+#define                   nEP2_RX  0x0       
+#define                    EP3_RX  0x8        /* Rx Endpoint 3 interrupt */
+#define                   nEP3_RX  0x0       
+#define                    EP4_RX  0x10       /* Rx Endpoint 4 interrupt */
+#define                   nEP4_RX  0x0       
+#define                    EP5_RX  0x20       /* Rx Endpoint 5 interrupt */
+#define                   nEP5_RX  0x0       
+#define                    EP6_RX  0x40       /* Rx Endpoint 6 interrupt */
+#define                   nEP6_RX  0x0       
+#define                    EP7_RX  0x80       /* Rx Endpoint 7 interrupt */
+#define                   nEP7_RX  0x0       
+
+/* Bit masks for USB_INTRTXE */
+
+#define                  EP0_TX_E  0x1        /* Endpoint 0 interrupt Enable */
+#define                 nEP0_TX_E  0x0       
+#define                  EP1_TX_E  0x2        /* Tx Endpoint 1 interrupt  Enable */
+#define                 nEP1_TX_E  0x0       
+#define                  EP2_TX_E  0x4        /* Tx Endpoint 2 interrupt  Enable */
+#define                 nEP2_TX_E  0x0       
+#define                  EP3_TX_E  0x8        /* Tx Endpoint 3 interrupt  Enable */
+#define                 nEP3_TX_E  0x0       
+#define                  EP4_TX_E  0x10       /* Tx Endpoint 4 interrupt  Enable */
+#define                 nEP4_TX_E  0x0       
+#define                  EP5_TX_E  0x20       /* Tx Endpoint 5 interrupt  Enable */
+#define                 nEP5_TX_E  0x0       
+#define                  EP6_TX_E  0x40       /* Tx Endpoint 6 interrupt  Enable */
+#define                 nEP6_TX_E  0x0       
+#define                  EP7_TX_E  0x80       /* Tx Endpoint 7 interrupt  Enable */
+#define                 nEP7_TX_E  0x0       
+
+/* Bit masks for USB_INTRRXE */
+
+#define                  EP1_RX_E  0x2        /* Rx Endpoint 1 interrupt  Enable */
+#define                 nEP1_RX_E  0x0       
+#define                  EP2_RX_E  0x4        /* Rx Endpoint 2 interrupt  Enable */
+#define                 nEP2_RX_E  0x0       
+#define                  EP3_RX_E  0x8        /* Rx Endpoint 3 interrupt  Enable */
+#define                 nEP3_RX_E  0x0       
+#define                  EP4_RX_E  0x10       /* Rx Endpoint 4 interrupt  Enable */
+#define                 nEP4_RX_E  0x0       
+#define                  EP5_RX_E  0x20       /* Rx Endpoint 5 interrupt  Enable */
+#define                 nEP5_RX_E  0x0       
+#define                  EP6_RX_E  0x40       /* Rx Endpoint 6 interrupt  Enable */
+#define                 nEP6_RX_E  0x0       
+#define                  EP7_RX_E  0x80       /* Rx Endpoint 7 interrupt  Enable */
+#define                 nEP7_RX_E  0x0       
+
+/* Bit masks for USB_INTRUSB */
+
+#define                 SUSPEND_B  0x1        /* Suspend indicator */
+#define                nSUSPEND_B  0x0       
+#define                  RESUME_B  0x2        /* Resume indicator */
+#define                 nRESUME_B  0x0       
+#define          RESET_OR_BABLE_B  0x4        /* Reset/babble indicator */
+#define         nRESET_OR_BABLE_B  0x0       
+#define                     SOF_B  0x8        /* Start of frame */
+#define                    nSOF_B  0x0       
+#define                    CONN_B  0x10       /* Connection indicator */
+#define                   nCONN_B  0x0       
+#define                  DISCON_B  0x20       /* Disconnect indicator */
+#define                 nDISCON_B  0x0       
+#define             SESSION_REQ_B  0x40       /* Session Request */
+#define            nSESSION_REQ_B  0x0       
+#define              VBUS_ERROR_B  0x80       /* Vbus threshold indicator */
+#define             nVBUS_ERROR_B  0x0       
+
+/* Bit masks for USB_INTRUSBE */
+
+#define                SUSPEND_BE  0x1        /* Suspend indicator int enable */
+#define               nSUSPEND_BE  0x0       
+#define                 RESUME_BE  0x2        /* Resume indicator int enable */
+#define                nRESUME_BE  0x0       
+#define         RESET_OR_BABLE_BE  0x4        /* Reset/babble indicator int enable */
+#define        nRESET_OR_BABLE_BE  0x0       
+#define                    SOF_BE  0x8        /* Start of frame int enable */
+#define                   nSOF_BE  0x0       
+#define                   CONN_BE  0x10       /* Connection indicator int enable */
+#define                  nCONN_BE  0x0       
+#define                 DISCON_BE  0x20       /* Disconnect indicator int enable */
+#define                nDISCON_BE  0x0       
+#define            SESSION_REQ_BE  0x40       /* Session Request int enable */
+#define           nSESSION_REQ_BE  0x0       
+#define             VBUS_ERROR_BE  0x80       /* Vbus threshold indicator int enable */
+#define            nVBUS_ERROR_BE  0x0       
+
+/* Bit masks for USB_FRAME */
+
+#define              FRAME_NUMBER  0x7ff      /* Frame number */
+
+/* Bit masks for USB_INDEX */
+
+#define         SELECTED_ENDPOINT  0xf        /* selected endpoint */
+
+/* Bit masks for USB_GLOBAL_CTL */
+
+#define                GLOBAL_ENA  0x1        /* enables USB module */
+#define               nGLOBAL_ENA  0x0       
+#define                EP1_TX_ENA  0x2        /* Transmit endpoint 1 enable */
+#define               nEP1_TX_ENA  0x0       
+#define                EP2_TX_ENA  0x4        /* Transmit endpoint 2 enable */
+#define               nEP2_TX_ENA  0x0       
+#define                EP3_TX_ENA  0x8        /* Transmit endpoint 3 enable */
+#define               nEP3_TX_ENA  0x0       
+#define                EP4_TX_ENA  0x10       /* Transmit endpoint 4 enable */
+#define               nEP4_TX_ENA  0x0       
+#define                EP5_TX_ENA  0x20       /* Transmit endpoint 5 enable */
+#define               nEP5_TX_ENA  0x0       
+#define                EP6_TX_ENA  0x40       /* Transmit endpoint 6 enable */
+#define               nEP6_TX_ENA  0x0       
+#define                EP7_TX_ENA  0x80       /* Transmit endpoint 7 enable */
+#define               nEP7_TX_ENA  0x0       
+#define                EP1_RX_ENA  0x100      /* Receive endpoint 1 enable */
+#define               nEP1_RX_ENA  0x0       
+#define                EP2_RX_ENA  0x200      /* Receive endpoint 2 enable */
+#define               nEP2_RX_ENA  0x0       
+#define                EP3_RX_ENA  0x400      /* Receive endpoint 3 enable */
+#define               nEP3_RX_ENA  0x0       
+#define                EP4_RX_ENA  0x800      /* Receive endpoint 4 enable */
+#define               nEP4_RX_ENA  0x0       
+#define                EP5_RX_ENA  0x1000     /* Receive endpoint 5 enable */
+#define               nEP5_RX_ENA  0x0       
+#define                EP6_RX_ENA  0x2000     /* Receive endpoint 6 enable */
+#define               nEP6_RX_ENA  0x0       
+#define                EP7_RX_ENA  0x4000     /* Receive endpoint 7 enable */
+#define               nEP7_RX_ENA  0x0       
+
+/* Bit masks for USB_OTG_DEV_CTL */
+
+#define                   SESSION  0x1        /* session indicator */
+#define                  nSESSION  0x0       
+#define                  HOST_REQ  0x2        /* Host negotiation request */
+#define                 nHOST_REQ  0x0       
+#define                 HOST_MODE  0x4        /* indicates USBDRC is a host */
+#define                nHOST_MODE  0x0       
+#define                     VBUS0  0x8        /* Vbus level indicator[0] */
+#define                    nVBUS0  0x0       
+#define                     VBUS1  0x10       /* Vbus level indicator[1] */
+#define                    nVBUS1  0x0       
+#define                     LSDEV  0x20       /* Low-speed indicator */
+#define                    nLSDEV  0x0       
+#define                     FSDEV  0x40       /* Full or High-speed indicator */
+#define                    nFSDEV  0x0       
+#define                  B_DEVICE  0x80       /* A' or 'B' device indicator */
+#define                 nB_DEVICE  0x0       
+
+/* Bit masks for USB_OTG_VBUS_IRQ */
+
+#define             DRIVE_VBUS_ON  0x1        /* indicator to drive VBUS control circuit */
+#define            nDRIVE_VBUS_ON  0x0       
+#define            DRIVE_VBUS_OFF  0x2        /* indicator to shut off charge pump */
+#define           nDRIVE_VBUS_OFF  0x0       
+#define           CHRG_VBUS_START  0x4        /* indicator for external circuit to start charging VBUS */
+#define          nCHRG_VBUS_START  0x0       
+#define             CHRG_VBUS_END  0x8        /* indicator for external circuit to end charging VBUS */
+#define            nCHRG_VBUS_END  0x0       
+#define        DISCHRG_VBUS_START  0x10       /* indicator to start discharging VBUS */
+#define       nDISCHRG_VBUS_START  0x0       
+#define          DISCHRG_VBUS_END  0x20       /* indicator to stop discharging VBUS */
+#define         nDISCHRG_VBUS_END  0x0       
+
+/* Bit masks for USB_OTG_VBUS_MASK */
+
+#define         DRIVE_VBUS_ON_ENA  0x1        /* enable DRIVE_VBUS_ON interrupt */
+#define        nDRIVE_VBUS_ON_ENA  0x0       
+#define        DRIVE_VBUS_OFF_ENA  0x2        /* enable DRIVE_VBUS_OFF interrupt */
+#define       nDRIVE_VBUS_OFF_ENA  0x0       
+#define       CHRG_VBUS_START_ENA  0x4        /* enable CHRG_VBUS_START interrupt */
+#define      nCHRG_VBUS_START_ENA  0x0       
+#define         CHRG_VBUS_END_ENA  0x8        /* enable CHRG_VBUS_END interrupt */
+#define        nCHRG_VBUS_END_ENA  0x0       
+#define    DISCHRG_VBUS_START_ENA  0x10       /* enable DISCHRG_VBUS_START interrupt */
+#define   nDISCHRG_VBUS_START_ENA  0x0       
+#define      DISCHRG_VBUS_END_ENA  0x20       /* enable DISCHRG_VBUS_END interrupt */
+#define     nDISCHRG_VBUS_END_ENA  0x0       
+
+/* Bit masks for USB_CSR0 */
+
+#define                  RXPKTRDY  0x1        /* data packet receive indicator */
+#define                 nRXPKTRDY  0x0       
+#define                  TXPKTRDY  0x2        /* data packet in FIFO indicator */
+#define                 nTXPKTRDY  0x0       
+#define                STALL_SENT  0x4        /* STALL handshake sent */
+#define               nSTALL_SENT  0x0       
+#define                   DATAEND  0x8        /* Data end indicator */
+#define                  nDATAEND  0x0       
+#define                  SETUPEND  0x10       /* Setup end */
+#define                 nSETUPEND  0x0       
+#define                 SENDSTALL  0x20       /* Send STALL handshake */
+#define                nSENDSTALL  0x0       
+#define         SERVICED_RXPKTRDY  0x40       /* used to clear the RxPktRdy bit */
+#define        nSERVICED_RXPKTRDY  0x0       
+#define         SERVICED_SETUPEND  0x80       /* used to clear the SetupEnd bit */
+#define        nSERVICED_SETUPEND  0x0       
+#define                 FLUSHFIFO  0x100      /* flush endpoint FIFO */
+#define                nFLUSHFIFO  0x0       
+#define          STALL_RECEIVED_H  0x4        /* STALL handshake received host mode */
+#define         nSTALL_RECEIVED_H  0x0       
+#define                SETUPPKT_H  0x8        /* send Setup token host mode */
+#define               nSETUPPKT_H  0x0       
+#define                   ERROR_H  0x10       /* timeout error indicator host mode */
+#define                  nERROR_H  0x0       
+#define                  REQPKT_H  0x20       /* Request an IN transaction host mode */
+#define                 nREQPKT_H  0x0       
+#define               STATUSPKT_H  0x40       /* Status stage transaction host mode */
+#define              nSTATUSPKT_H  0x0       
+#define             NAK_TIMEOUT_H  0x80       /* EP0 halted after a NAK host mode */
+#define            nNAK_TIMEOUT_H  0x0       
+
+/* Bit masks for USB_COUNT0 */
+
+#define              EP0_RX_COUNT  0x7f       /* number of received bytes in EP0 FIFO */
+
+/* Bit masks for USB_NAKLIMIT0 */
+
+#define             EP0_NAK_LIMIT  0x1f       /* number of frames/micro frames after which EP0 timeouts */
+
+/* Bit masks for USB_TX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_T  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_RX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_R  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_TXCSR */
+
+#define                TXPKTRDY_T  0x1        /* data packet in FIFO indicator */
+#define               nTXPKTRDY_T  0x0       
+#define          FIFO_NOT_EMPTY_T  0x2        /* FIFO not empty */
+#define         nFIFO_NOT_EMPTY_T  0x0       
+#define                UNDERRUN_T  0x4        /* TxPktRdy not set  for an IN token */
+#define               nUNDERRUN_T  0x0       
+#define               FLUSHFIFO_T  0x8        /* flush endpoint FIFO */
+#define              nFLUSHFIFO_T  0x0       
+#define              STALL_SEND_T  0x10       /* issue a Stall handshake */
+#define             nSTALL_SEND_T  0x0       
+#define              STALL_SENT_T  0x20       /* Stall handshake transmitted */
+#define             nSTALL_SENT_T  0x0       
+#define        CLEAR_DATATOGGLE_T  0x40       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_T  0x0       
+#define                INCOMPTX_T  0x80       /* indicates that a large packet is split */
+#define               nINCOMPTX_T  0x0       
+#define              DMAREQMODE_T  0x400      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_T  0x0       
+#define        FORCE_DATATOGGLE_T  0x800      /* Force data toggle */
+#define       nFORCE_DATATOGGLE_T  0x0       
+#define              DMAREQ_ENA_T  0x1000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_T  0x0       
+#define                     ISO_T  0x4000     /* enable Isochronous transfers */
+#define                    nISO_T  0x0       
+#define                 AUTOSET_T  0x8000     /* allows TxPktRdy to be set automatically */
+#define                nAUTOSET_T  0x0       
+#define                  ERROR_TH  0x4        /* error condition host mode */
+#define                 nERROR_TH  0x0       
+#define         STALL_RECEIVED_TH  0x20       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_TH  0x0       
+#define            NAK_TIMEOUT_TH  0x80       /* NAK timeout host mode */
+#define           nNAK_TIMEOUT_TH  0x0       
+
+/* Bit masks for USB_TXCOUNT */
+
+#define                  TX_COUNT  0x1fff     /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* Bit masks for USB_RXCSR */
+
+#define                RXPKTRDY_R  0x1        /* data packet in FIFO indicator */
+#define               nRXPKTRDY_R  0x0       
+#define               FIFO_FULL_R  0x2        /* FIFO not empty */
+#define              nFIFO_FULL_R  0x0       
+#define                 OVERRUN_R  0x4        /* TxPktRdy not set  for an IN token */
+#define                nOVERRUN_R  0x0       
+#define               DATAERROR_R  0x8        /* Out packet cannot be loaded into Rx  FIFO */
+#define              nDATAERROR_R  0x0       
+#define               FLUSHFIFO_R  0x10       /* flush endpoint FIFO */
+#define              nFLUSHFIFO_R  0x0       
+#define              STALL_SEND_R  0x20       /* issue a Stall handshake */
+#define             nSTALL_SEND_R  0x0       
+#define              STALL_SENT_R  0x40       /* Stall handshake transmitted */
+#define             nSTALL_SENT_R  0x0       
+#define        CLEAR_DATATOGGLE_R  0x80       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_R  0x0       
+#define                INCOMPRX_R  0x100      /* indicates that a large packet is split */
+#define               nINCOMPRX_R  0x0       
+#define              DMAREQMODE_R  0x800      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_R  0x0       
+#define                 DISNYET_R  0x1000     /* disable Nyet handshakes */
+#define                nDISNYET_R  0x0       
+#define              DMAREQ_ENA_R  0x2000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_R  0x0       
+#define                     ISO_R  0x4000     /* enable Isochronous transfers */
+#define                    nISO_R  0x0       
+#define               AUTOCLEAR_R  0x8000     /* allows TxPktRdy to be set automatically */
+#define              nAUTOCLEAR_R  0x0       
+#define                  ERROR_RH  0x4        /* TxPktRdy not set  for an IN token host mode */
+#define                 nERROR_RH  0x0       
+#define                 REQPKT_RH  0x20       /* request an IN transaction host mode */
+#define                nREQPKT_RH  0x0       
+#define         STALL_RECEIVED_RH  0x40       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_RH  0x0       
+#define               INCOMPRX_RH  0x100      /* indicates that a large packet is split host mode */
+#define              nINCOMPRX_RH  0x0       
+#define             DMAREQMODE_RH  0x800      /* DMA mode (0 or 1) selection host mode */
+#define            nDMAREQMODE_RH  0x0       
+#define                AUTOREQ_RH  0x4000     /* sets ReqPkt automatically host mode */
+#define               nAUTOREQ_RH  0x0       
+
+/* Bit masks for USB_RXCOUNT */
+
+#define                  RX_COUNT  0x1fff     /* Number of received bytes in the packet in the Rx FIFO */
+
+/* Bit masks for USB_TXTYPE */
+
+#define            TARGET_EP_NO_T  0xf        /* EP number */
+#define                PROTOCOL_T  0xc        /* transfer type */
+
+/* Bit masks for USB_TXINTERVAL */
+
+#define          TX_POLL_INTERVAL  0xff       /* polling interval for selected Tx EP */
+
+/* Bit masks for USB_RXTYPE */
+
+#define            TARGET_EP_NO_R  0xf        /* EP number */
+#define                PROTOCOL_R  0xc        /* transfer type */
+
+/* Bit masks for USB_RXINTERVAL */
+
+#define          RX_POLL_INTERVAL  0xff       /* polling interval for selected Rx EP */
+
+/* Bit masks for USB_DMA_INTERRUPT */
+
+#define                  DMA0_INT  0x1        /* DMA0 pending interrupt */
+#define                 nDMA0_INT  0x0       
+#define                  DMA1_INT  0x2        /* DMA1 pending interrupt */
+#define                 nDMA1_INT  0x0       
+#define                  DMA2_INT  0x4        /* DMA2 pending interrupt */
+#define                 nDMA2_INT  0x0       
+#define                  DMA3_INT  0x8        /* DMA3 pending interrupt */
+#define                 nDMA3_INT  0x0       
+#define                  DMA4_INT  0x10       /* DMA4 pending interrupt */
+#define                 nDMA4_INT  0x0       
+#define                  DMA5_INT  0x20       /* DMA5 pending interrupt */
+#define                 nDMA5_INT  0x0       
+#define                  DMA6_INT  0x40       /* DMA6 pending interrupt */
+#define                 nDMA6_INT  0x0       
+#define                  DMA7_INT  0x80       /* DMA7 pending interrupt */
+#define                 nDMA7_INT  0x0       
+
+/* Bit masks for USB_DMAxCONTROL */
+
+#define                   DMA_ENA  0x1        /* DMA enable */
+#define                  nDMA_ENA  0x0       
+#define                 DIRECTION  0x2        /* direction of DMA transfer */
+#define                nDIRECTION  0x0       
+#define                      MODE  0x4        /* DMA Bus error */
+#define                     nMODE  0x0       
+#define                   INT_ENA  0x8        /* Interrupt enable */
+#define                  nINT_ENA  0x0       
+#define                     EPNUM  0xf0       /* EP number */
+#define                  BUSERROR  0x100      /* DMA Bus error */
+#define                 nBUSERROR  0x0       
+
+/* Bit masks for USB_DMAxADDRHIGH */
+
+#define             DMA_ADDR_HIGH  0xffff     /* Upper 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxADDRLOW */
+
+#define              DMA_ADDR_LOW  0xffff     /* Lower 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTHIGH */
+
+#define            DMA_COUNT_HIGH  0xffff     /* Upper 16-bits of byte count of DMA transfer for DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTLOW */
+
+#define             DMA_COUNT_LOW  0xffff     /* Lower 16-bits of byte count of DMA transfer for DMA master channel */
+
+
+/* ******************************************* */
+/*     MULTI BIT MACRO ENUMERATIONS            */
+/* ******************************************* */
+
+
+#endif /* _DEF_BF542_H */
diff --git a/include/asm-blackfin/mach-bf548/defBF544.h b/include/asm-blackfin/mach-bf548/defBF544.h
new file mode 100644
index 0000000..8fc77ea
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/defBF544.h
@@ -0,0 +1,766 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/defBF544.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF544_H
+#define _DEF_BF544_H
+
+/* Include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF544 */
+
+/* Include defBF54x_base.h for the set of #defines that are common to all ADSP-BF54x processors */
+#include "defBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF544 that are not in the common header */
+
+/* Timer Registers */
+
+#define                    TIMER8_CONFIG  0xffc00600   /* Timer 8 Configuration Register */
+#define                   TIMER8_COUNTER  0xffc00604   /* Timer 8 Counter Register */
+#define                    TIMER8_PERIOD  0xffc00608   /* Timer 8 Period Register */
+#define                     TIMER8_WIDTH  0xffc0060c   /* Timer 8 Width Register */
+#define                    TIMER9_CONFIG  0xffc00610   /* Timer 9 Configuration Register */
+#define                   TIMER9_COUNTER  0xffc00614   /* Timer 9 Counter Register */
+#define                    TIMER9_PERIOD  0xffc00618   /* Timer 9 Period Register */
+#define                     TIMER9_WIDTH  0xffc0061c   /* Timer 9 Width Register */
+#define                   TIMER10_CONFIG  0xffc00620   /* Timer 10 Configuration Register */
+#define                  TIMER10_COUNTER  0xffc00624   /* Timer 10 Counter Register */
+#define                   TIMER10_PERIOD  0xffc00628   /* Timer 10 Period Register */
+#define                    TIMER10_WIDTH  0xffc0062c   /* Timer 10 Width Register */
+
+/* Timer Group of 3 Registers */
+
+#define                    TIMER_ENABLE1  0xffc00640   /* Timer Group of 3 Enable Register */
+#define                   TIMER_DISABLE1  0xffc00644   /* Timer Group of 3 Disable Register */
+#define                    TIMER_STATUS1  0xffc00648   /* Timer Group of 3 Status Register */
+
+/* EPPI0 Registers */
+
+#define                     EPPI0_STATUS  0xffc01000   /* EPPI0 Status Register */
+#define                     EPPI0_HCOUNT  0xffc01004   /* EPPI0 Horizontal Transfer Count Register */
+#define                     EPPI0_HDELAY  0xffc01008   /* EPPI0 Horizontal Delay Count Register */
+#define                     EPPI0_VCOUNT  0xffc0100c   /* EPPI0 Vertical Transfer Count Register */
+#define                     EPPI0_VDELAY  0xffc01010   /* EPPI0 Vertical Delay Count Register */
+#define                      EPPI0_FRAME  0xffc01014   /* EPPI0 Lines per Frame Register */
+#define                       EPPI0_LINE  0xffc01018   /* EPPI0 Samples per Line Register */
+#define                     EPPI0_CLKDIV  0xffc0101c   /* EPPI0 Clock Divide Register */
+#define                    EPPI0_CONTROL  0xffc01020   /* EPPI0 Control Register */
+#define                   EPPI0_FS1W_HBL  0xffc01024   /* EPPI0 FS1 Width Register / EPPI0 Horizontal Blanking Samples Per Line Register */
+#define                  EPPI0_FS1P_AVPL  0xffc01028   /* EPPI0 FS1 Period Register / EPPI0 Active Video Samples Per Line Register */
+#define                   EPPI0_FS2W_LVB  0xffc0102c   /* EPPI0 FS2 Width Register / EPPI0 Lines of Vertical Blanking Register */
+#define                  EPPI0_FS2P_LAVF  0xffc01030   /* EPPI0 FS2 Period Register/ EPPI0 Lines of Active Video Per Field Register */
+#define                       EPPI0_CLIP  0xffc01034   /* EPPI0 Clipping Register */
+
+/* Two Wire Interface Registers (TWI1) */
+
+#define                      TWI1_CLKDIV  0xffc02200   /* Clock Divider Register */
+#define                     TWI1_CONTROL  0xffc02204   /* TWI Control Register */
+#define                  TWI1_SLAVE_CTRL  0xffc02208   /* TWI Slave Mode Control Register */
+#define                  TWI1_SLAVE_STAT  0xffc0220c   /* TWI Slave Mode Status Register */
+#define                  TWI1_SLAVE_ADDR  0xffc02210   /* TWI Slave Mode Address Register */
+#define                 TWI1_MASTER_CTRL  0xffc02214   /* TWI Master Mode Control Register */
+#define                 TWI1_MASTER_STAT  0xffc02218   /* TWI Master Mode Status Register */
+#define                 TWI1_MASTER_ADDR  0xffc0221c   /* TWI Master Mode Address Register */
+#define                    TWI1_INT_STAT  0xffc02220   /* TWI Interrupt Status Register */
+#define                    TWI1_INT_MASK  0xffc02224   /* TWI Interrupt Mask Register */
+#define                   TWI1_FIFO_CTRL  0xffc02228   /* TWI FIFO Control Register */
+#define                   TWI1_FIFO_STAT  0xffc0222c   /* TWI FIFO Status Register */
+#define                   TWI1_XMT_DATA8  0xffc02280   /* TWI FIFO Transmit Data Single Byte Register */
+#define                  TWI1_XMT_DATA16  0xffc02284   /* TWI FIFO Transmit Data Double Byte Register */
+#define                   TWI1_RCV_DATA8  0xffc02288   /* TWI FIFO Receive Data Single Byte Register */
+#define                  TWI1_RCV_DATA16  0xffc0228c   /* TWI FIFO Receive Data Double Byte Register */
+
+/* CAN Controller 1 Config 1 Registers */
+
+#define                         CAN1_MC1  0xffc03200   /* CAN Controller 1 Mailbox Configuration Register 1 */
+#define                         CAN1_MD1  0xffc03204   /* CAN Controller 1 Mailbox Direction Register 1 */
+#define                        CAN1_TRS1  0xffc03208   /* CAN Controller 1 Transmit Request Set Register 1 */
+#define                        CAN1_TRR1  0xffc0320c   /* CAN Controller 1 Transmit Request Reset Register 1 */
+#define                         CAN1_TA1  0xffc03210   /* CAN Controller 1 Transmit Acknowledge Register 1 */
+#define                         CAN1_AA1  0xffc03214   /* CAN Controller 1 Abort Acknowledge Register 1 */
+#define                        CAN1_RMP1  0xffc03218   /* CAN Controller 1 Receive Message Pending Register 1 */
+#define                        CAN1_RML1  0xffc0321c   /* CAN Controller 1 Receive Message Lost Register 1 */
+#define                      CAN1_MBTIF1  0xffc03220   /* CAN Controller 1 Mailbox Transmit Interrupt Flag Register 1 */
+#define                      CAN1_MBRIF1  0xffc03224   /* CAN Controller 1 Mailbox Receive Interrupt Flag Register 1 */
+#define                       CAN1_MBIM1  0xffc03228   /* CAN Controller 1 Mailbox Interrupt Mask Register 1 */
+#define                        CAN1_RFH1  0xffc0322c   /* CAN Controller 1 Remote Frame Handling Enable Register 1 */
+#define                       CAN1_OPSS1  0xffc03230   /* CAN Controller 1 Overwrite Protection Single Shot Transmit Register 1 */
+
+/* CAN Controller 1 Config 2 Registers */
+
+#define                         CAN1_MC2  0xffc03240   /* CAN Controller 1 Mailbox Configuration Register 2 */
+#define                         CAN1_MD2  0xffc03244   /* CAN Controller 1 Mailbox Direction Register 2 */
+#define                        CAN1_TRS2  0xffc03248   /* CAN Controller 1 Transmit Request Set Register 2 */
+#define                        CAN1_TRR2  0xffc0324c   /* CAN Controller 1 Transmit Request Reset Register 2 */
+#define                         CAN1_TA2  0xffc03250   /* CAN Controller 1 Transmit Acknowledge Register 2 */
+#define                         CAN1_AA2  0xffc03254   /* CAN Controller 1 Abort Acknowledge Register 2 */
+#define                        CAN1_RMP2  0xffc03258   /* CAN Controller 1 Receive Message Pending Register 2 */
+#define                        CAN1_RML2  0xffc0325c   /* CAN Controller 1 Receive Message Lost Register 2 */
+#define                      CAN1_MBTIF2  0xffc03260   /* CAN Controller 1 Mailbox Transmit Interrupt Flag Register 2 */
+#define                      CAN1_MBRIF2  0xffc03264   /* CAN Controller 1 Mailbox Receive Interrupt Flag Register 2 */
+#define                       CAN1_MBIM2  0xffc03268   /* CAN Controller 1 Mailbox Interrupt Mask Register 2 */
+#define                        CAN1_RFH2  0xffc0326c   /* CAN Controller 1 Remote Frame Handling Enable Register 2 */
+#define                       CAN1_OPSS2  0xffc03270   /* CAN Controller 1 Overwrite Protection Single Shot Transmit Register 2 */
+
+/* CAN Controller 1 Clock/Interrupt/Counter Registers */
+
+#define                       CAN1_CLOCK  0xffc03280   /* CAN Controller 1 Clock Register */
+#define                      CAN1_TIMING  0xffc03284   /* CAN Controller 1 Timing Register */
+#define                       CAN1_DEBUG  0xffc03288   /* CAN Controller 1 Debug Register */
+#define                      CAN1_STATUS  0xffc0328c   /* CAN Controller 1 Global Status Register */
+#define                         CAN1_CEC  0xffc03290   /* CAN Controller 1 Error Counter Register */
+#define                         CAN1_GIS  0xffc03294   /* CAN Controller 1 Global Interrupt Status Register */
+#define                         CAN1_GIM  0xffc03298   /* CAN Controller 1 Global Interrupt Mask Register */
+#define                         CAN1_GIF  0xffc0329c   /* CAN Controller 1 Global Interrupt Flag Register */
+#define                     CAN1_CONTROL  0xffc032a0   /* CAN Controller 1 Master Control Register */
+#define                        CAN1_INTR  0xffc032a4   /* CAN Controller 1 Interrupt Pending Register */
+#define                        CAN1_MBTD  0xffc032ac   /* CAN Controller 1 Mailbox Temporary Disable Register */
+#define                         CAN1_EWR  0xffc032b0   /* CAN Controller 1 Programmable Warning Level Register */
+#define                         CAN1_ESR  0xffc032b4   /* CAN Controller 1 Error Status Register */
+#define                       CAN1_UCCNT  0xffc032c4   /* CAN Controller 1 Universal Counter Register */
+#define                        CAN1_UCRC  0xffc032c8   /* CAN Controller 1 Universal Counter Force Reload Register */
+#define                       CAN1_UCCNF  0xffc032cc   /* CAN Controller 1 Universal Counter Configuration Register */
+
+/* CAN Controller 1 Mailbox Acceptance Registers */
+
+#define                       CAN1_AM00L  0xffc03300   /* CAN Controller 1 Mailbox 0 Acceptance Mask High Register */
+#define                       CAN1_AM00H  0xffc03304   /* CAN Controller 1 Mailbox 0 Acceptance Mask Low Register */
+#define                       CAN1_AM01L  0xffc03308   /* CAN Controller 1 Mailbox 1 Acceptance Mask High Register */
+#define                       CAN1_AM01H  0xffc0330c   /* CAN Controller 1 Mailbox 1 Acceptance Mask Low Register */
+#define                       CAN1_AM02L  0xffc03310   /* CAN Controller 1 Mailbox 2 Acceptance Mask High Register */
+#define                       CAN1_AM02H  0xffc03314   /* CAN Controller 1 Mailbox 2 Acceptance Mask Low Register */
+#define                       CAN1_AM03L  0xffc03318   /* CAN Controller 1 Mailbox 3 Acceptance Mask High Register */
+#define                       CAN1_AM03H  0xffc0331c   /* CAN Controller 1 Mailbox 3 Acceptance Mask Low Register */
+#define                       CAN1_AM04L  0xffc03320   /* CAN Controller 1 Mailbox 4 Acceptance Mask High Register */
+#define                       CAN1_AM04H  0xffc03324   /* CAN Controller 1 Mailbox 4 Acceptance Mask Low Register */
+#define                       CAN1_AM05L  0xffc03328   /* CAN Controller 1 Mailbox 5 Acceptance Mask High Register */
+#define                       CAN1_AM05H  0xffc0332c   /* CAN Controller 1 Mailbox 5 Acceptance Mask Low Register */
+#define                       CAN1_AM06L  0xffc03330   /* CAN Controller 1 Mailbox 6 Acceptance Mask High Register */
+#define                       CAN1_AM06H  0xffc03334   /* CAN Controller 1 Mailbox 6 Acceptance Mask Low Register */
+#define                       CAN1_AM07L  0xffc03338   /* CAN Controller 1 Mailbox 7 Acceptance Mask High Register */
+#define                       CAN1_AM07H  0xffc0333c   /* CAN Controller 1 Mailbox 7 Acceptance Mask Low Register */
+#define                       CAN1_AM08L  0xffc03340   /* CAN Controller 1 Mailbox 8 Acceptance Mask High Register */
+#define                       CAN1_AM08H  0xffc03344   /* CAN Controller 1 Mailbox 8 Acceptance Mask Low Register */
+#define                       CAN1_AM09L  0xffc03348   /* CAN Controller 1 Mailbox 9 Acceptance Mask High Register */
+#define                       CAN1_AM09H  0xffc0334c   /* CAN Controller 1 Mailbox 9 Acceptance Mask Low Register */
+#define                       CAN1_AM10L  0xffc03350   /* CAN Controller 1 Mailbox 10 Acceptance Mask High Register */
+#define                       CAN1_AM10H  0xffc03354   /* CAN Controller 1 Mailbox 10 Acceptance Mask Low Register */
+#define                       CAN1_AM11L  0xffc03358   /* CAN Controller 1 Mailbox 11 Acceptance Mask High Register */
+#define                       CAN1_AM11H  0xffc0335c   /* CAN Controller 1 Mailbox 11 Acceptance Mask Low Register */
+#define                       CAN1_AM12L  0xffc03360   /* CAN Controller 1 Mailbox 12 Acceptance Mask High Register */
+#define                       CAN1_AM12H  0xffc03364   /* CAN Controller 1 Mailbox 12 Acceptance Mask Low Register */
+#define                       CAN1_AM13L  0xffc03368   /* CAN Controller 1 Mailbox 13 Acceptance Mask High Register */
+#define                       CAN1_AM13H  0xffc0336c   /* CAN Controller 1 Mailbox 13 Acceptance Mask Low Register */
+#define                       CAN1_AM14L  0xffc03370   /* CAN Controller 1 Mailbox 14 Acceptance Mask High Register */
+#define                       CAN1_AM14H  0xffc03374   /* CAN Controller 1 Mailbox 14 Acceptance Mask Low Register */
+#define                       CAN1_AM15L  0xffc03378   /* CAN Controller 1 Mailbox 15 Acceptance Mask High Register */
+#define                       CAN1_AM15H  0xffc0337c   /* CAN Controller 1 Mailbox 15 Acceptance Mask Low Register */
+
+/* CAN Controller 1 Mailbox Acceptance Registers */
+
+#define                       CAN1_AM16L  0xffc03380   /* CAN Controller 1 Mailbox 16 Acceptance Mask High Register */
+#define                       CAN1_AM16H  0xffc03384   /* CAN Controller 1 Mailbox 16 Acceptance Mask Low Register */
+#define                       CAN1_AM17L  0xffc03388   /* CAN Controller 1 Mailbox 17 Acceptance Mask High Register */
+#define                       CAN1_AM17H  0xffc0338c   /* CAN Controller 1 Mailbox 17 Acceptance Mask Low Register */
+#define                       CAN1_AM18L  0xffc03390   /* CAN Controller 1 Mailbox 18 Acceptance Mask High Register */
+#define                       CAN1_AM18H  0xffc03394   /* CAN Controller 1 Mailbox 18 Acceptance Mask Low Register */
+#define                       CAN1_AM19L  0xffc03398   /* CAN Controller 1 Mailbox 19 Acceptance Mask High Register */
+#define                       CAN1_AM19H  0xffc0339c   /* CAN Controller 1 Mailbox 19 Acceptance Mask Low Register */
+#define                       CAN1_AM20L  0xffc033a0   /* CAN Controller 1 Mailbox 20 Acceptance Mask High Register */
+#define                       CAN1_AM20H  0xffc033a4   /* CAN Controller 1 Mailbox 20 Acceptance Mask Low Register */
+#define                       CAN1_AM21L  0xffc033a8   /* CAN Controller 1 Mailbox 21 Acceptance Mask High Register */
+#define                       CAN1_AM21H  0xffc033ac   /* CAN Controller 1 Mailbox 21 Acceptance Mask Low Register */
+#define                       CAN1_AM22L  0xffc033b0   /* CAN Controller 1 Mailbox 22 Acceptance Mask High Register */
+#define                       CAN1_AM22H  0xffc033b4   /* CAN Controller 1 Mailbox 22 Acceptance Mask Low Register */
+#define                       CAN1_AM23L  0xffc033b8   /* CAN Controller 1 Mailbox 23 Acceptance Mask High Register */
+#define                       CAN1_AM23H  0xffc033bc   /* CAN Controller 1 Mailbox 23 Acceptance Mask Low Register */
+#define                       CAN1_AM24L  0xffc033c0   /* CAN Controller 1 Mailbox 24 Acceptance Mask High Register */
+#define                       CAN1_AM24H  0xffc033c4   /* CAN Controller 1 Mailbox 24 Acceptance Mask Low Register */
+#define                       CAN1_AM25L  0xffc033c8   /* CAN Controller 1 Mailbox 25 Acceptance Mask High Register */
+#define                       CAN1_AM25H  0xffc033cc   /* CAN Controller 1 Mailbox 25 Acceptance Mask Low Register */
+#define                       CAN1_AM26L  0xffc033d0   /* CAN Controller 1 Mailbox 26 Acceptance Mask High Register */
+#define                       CAN1_AM26H  0xffc033d4   /* CAN Controller 1 Mailbox 26 Acceptance Mask Low Register */
+#define                       CAN1_AM27L  0xffc033d8   /* CAN Controller 1 Mailbox 27 Acceptance Mask High Register */
+#define                       CAN1_AM27H  0xffc033dc   /* CAN Controller 1 Mailbox 27 Acceptance Mask Low Register */
+#define                       CAN1_AM28L  0xffc033e0   /* CAN Controller 1 Mailbox 28 Acceptance Mask High Register */
+#define                       CAN1_AM28H  0xffc033e4   /* CAN Controller 1 Mailbox 28 Acceptance Mask Low Register */
+#define                       CAN1_AM29L  0xffc033e8   /* CAN Controller 1 Mailbox 29 Acceptance Mask High Register */
+#define                       CAN1_AM29H  0xffc033ec   /* CAN Controller 1 Mailbox 29 Acceptance Mask Low Register */
+#define                       CAN1_AM30L  0xffc033f0   /* CAN Controller 1 Mailbox 30 Acceptance Mask High Register */
+#define                       CAN1_AM30H  0xffc033f4   /* CAN Controller 1 Mailbox 30 Acceptance Mask Low Register */
+#define                       CAN1_AM31L  0xffc033f8   /* CAN Controller 1 Mailbox 31 Acceptance Mask High Register */
+#define                       CAN1_AM31H  0xffc033fc   /* CAN Controller 1 Mailbox 31 Acceptance Mask Low Register */
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define                  CAN1_MB00_DATA0  0xffc03400   /* CAN Controller 1 Mailbox 0 Data 0 Register */
+#define                  CAN1_MB00_DATA1  0xffc03404   /* CAN Controller 1 Mailbox 0 Data 1 Register */
+#define                  CAN1_MB00_DATA2  0xffc03408   /* CAN Controller 1 Mailbox 0 Data 2 Register */
+#define                  CAN1_MB00_DATA3  0xffc0340c   /* CAN Controller 1 Mailbox 0 Data 3 Register */
+#define                 CAN1_MB00_LENGTH  0xffc03410   /* CAN Controller 1 Mailbox 0 Length Register */
+#define              CAN1_MB00_TIMESTAMP  0xffc03414   /* CAN Controller 1 Mailbox 0 Timestamp Register */
+#define                    CAN1_MB00_ID0  0xffc03418   /* CAN Controller 1 Mailbox 0 ID0 Register */
+#define                    CAN1_MB00_ID1  0xffc0341c   /* CAN Controller 1 Mailbox 0 ID1 Register */
+#define                  CAN1_MB01_DATA0  0xffc03420   /* CAN Controller 1 Mailbox 1 Data 0 Register */
+#define                  CAN1_MB01_DATA1  0xffc03424   /* CAN Controller 1 Mailbox 1 Data 1 Register */
+#define                  CAN1_MB01_DATA2  0xffc03428   /* CAN Controller 1 Mailbox 1 Data 2 Register */
+#define                  CAN1_MB01_DATA3  0xffc0342c   /* CAN Controller 1 Mailbox 1 Data 3 Register */
+#define                 CAN1_MB01_LENGTH  0xffc03430   /* CAN Controller 1 Mailbox 1 Length Register */
+#define              CAN1_MB01_TIMESTAMP  0xffc03434   /* CAN Controller 1 Mailbox 1 Timestamp Register */
+#define                    CAN1_MB01_ID0  0xffc03438   /* CAN Controller 1 Mailbox 1 ID0 Register */
+#define                    CAN1_MB01_ID1  0xffc0343c   /* CAN Controller 1 Mailbox 1 ID1 Register */
+#define                  CAN1_MB02_DATA0  0xffc03440   /* CAN Controller 1 Mailbox 2 Data 0 Register */
+#define                  CAN1_MB02_DATA1  0xffc03444   /* CAN Controller 1 Mailbox 2 Data 1 Register */
+#define                  CAN1_MB02_DATA2  0xffc03448   /* CAN Controller 1 Mailbox 2 Data 2 Register */
+#define                  CAN1_MB02_DATA3  0xffc0344c   /* CAN Controller 1 Mailbox 2 Data 3 Register */
+#define                 CAN1_MB02_LENGTH  0xffc03450   /* CAN Controller 1 Mailbox 2 Length Register */
+#define              CAN1_MB02_TIMESTAMP  0xffc03454   /* CAN Controller 1 Mailbox 2 Timestamp Register */
+#define                    CAN1_MB02_ID0  0xffc03458   /* CAN Controller 1 Mailbox 2 ID0 Register */
+#define                    CAN1_MB02_ID1  0xffc0345c   /* CAN Controller 1 Mailbox 2 ID1 Register */
+#define                  CAN1_MB03_DATA0  0xffc03460   /* CAN Controller 1 Mailbox 3 Data 0 Register */
+#define                  CAN1_MB03_DATA1  0xffc03464   /* CAN Controller 1 Mailbox 3 Data 1 Register */
+#define                  CAN1_MB03_DATA2  0xffc03468   /* CAN Controller 1 Mailbox 3 Data 2 Register */
+#define                  CAN1_MB03_DATA3  0xffc0346c   /* CAN Controller 1 Mailbox 3 Data 3 Register */
+#define                 CAN1_MB03_LENGTH  0xffc03470   /* CAN Controller 1 Mailbox 3 Length Register */
+#define              CAN1_MB03_TIMESTAMP  0xffc03474   /* CAN Controller 1 Mailbox 3 Timestamp Register */
+#define                    CAN1_MB03_ID0  0xffc03478   /* CAN Controller 1 Mailbox 3 ID0 Register */
+#define                    CAN1_MB03_ID1  0xffc0347c   /* CAN Controller 1 Mailbox 3 ID1 Register */
+#define                  CAN1_MB04_DATA0  0xffc03480   /* CAN Controller 1 Mailbox 4 Data 0 Register */
+#define                  CAN1_MB04_DATA1  0xffc03484   /* CAN Controller 1 Mailbox 4 Data 1 Register */
+#define                  CAN1_MB04_DATA2  0xffc03488   /* CAN Controller 1 Mailbox 4 Data 2 Register */
+#define                  CAN1_MB04_DATA3  0xffc0348c   /* CAN Controller 1 Mailbox 4 Data 3 Register */
+#define                 CAN1_MB04_LENGTH  0xffc03490   /* CAN Controller 1 Mailbox 4 Length Register */
+#define              CAN1_MB04_TIMESTAMP  0xffc03494   /* CAN Controller 1 Mailbox 4 Timestamp Register */
+#define                    CAN1_MB04_ID0  0xffc03498   /* CAN Controller 1 Mailbox 4 ID0 Register */
+#define                    CAN1_MB04_ID1  0xffc0349c   /* CAN Controller 1 Mailbox 4 ID1 Register */
+#define                  CAN1_MB05_DATA0  0xffc034a0   /* CAN Controller 1 Mailbox 5 Data 0 Register */
+#define                  CAN1_MB05_DATA1  0xffc034a4   /* CAN Controller 1 Mailbox 5 Data 1 Register */
+#define                  CAN1_MB05_DATA2  0xffc034a8   /* CAN Controller 1 Mailbox 5 Data 2 Register */
+#define                  CAN1_MB05_DATA3  0xffc034ac   /* CAN Controller 1 Mailbox 5 Data 3 Register */
+#define                 CAN1_MB05_LENGTH  0xffc034b0   /* CAN Controller 1 Mailbox 5 Length Register */
+#define              CAN1_MB05_TIMESTAMP  0xffc034b4   /* CAN Controller 1 Mailbox 5 Timestamp Register */
+#define                    CAN1_MB05_ID0  0xffc034b8   /* CAN Controller 1 Mailbox 5 ID0 Register */
+#define                    CAN1_MB05_ID1  0xffc034bc   /* CAN Controller 1 Mailbox 5 ID1 Register */
+#define                  CAN1_MB06_DATA0  0xffc034c0   /* CAN Controller 1 Mailbox 6 Data 0 Register */
+#define                  CAN1_MB06_DATA1  0xffc034c4   /* CAN Controller 1 Mailbox 6 Data 1 Register */
+#define                  CAN1_MB06_DATA2  0xffc034c8   /* CAN Controller 1 Mailbox 6 Data 2 Register */
+#define                  CAN1_MB06_DATA3  0xffc034cc   /* CAN Controller 1 Mailbox 6 Data 3 Register */
+#define                 CAN1_MB06_LENGTH  0xffc034d0   /* CAN Controller 1 Mailbox 6 Length Register */
+#define              CAN1_MB06_TIMESTAMP  0xffc034d4   /* CAN Controller 1 Mailbox 6 Timestamp Register */
+#define                    CAN1_MB06_ID0  0xffc034d8   /* CAN Controller 1 Mailbox 6 ID0 Register */
+#define                    CAN1_MB06_ID1  0xffc034dc   /* CAN Controller 1 Mailbox 6 ID1 Register */
+#define                  CAN1_MB07_DATA0  0xffc034e0   /* CAN Controller 1 Mailbox 7 Data 0 Register */
+#define                  CAN1_MB07_DATA1  0xffc034e4   /* CAN Controller 1 Mailbox 7 Data 1 Register */
+#define                  CAN1_MB07_DATA2  0xffc034e8   /* CAN Controller 1 Mailbox 7 Data 2 Register */
+#define                  CAN1_MB07_DATA3  0xffc034ec   /* CAN Controller 1 Mailbox 7 Data 3 Register */
+#define                 CAN1_MB07_LENGTH  0xffc034f0   /* CAN Controller 1 Mailbox 7 Length Register */
+#define              CAN1_MB07_TIMESTAMP  0xffc034f4   /* CAN Controller 1 Mailbox 7 Timestamp Register */
+#define                    CAN1_MB07_ID0  0xffc034f8   /* CAN Controller 1 Mailbox 7 ID0 Register */
+#define                    CAN1_MB07_ID1  0xffc034fc   /* CAN Controller 1 Mailbox 7 ID1 Register */
+#define                  CAN1_MB08_DATA0  0xffc03500   /* CAN Controller 1 Mailbox 8 Data 0 Register */
+#define                  CAN1_MB08_DATA1  0xffc03504   /* CAN Controller 1 Mailbox 8 Data 1 Register */
+#define                  CAN1_MB08_DATA2  0xffc03508   /* CAN Controller 1 Mailbox 8 Data 2 Register */
+#define                  CAN1_MB08_DATA3  0xffc0350c   /* CAN Controller 1 Mailbox 8 Data 3 Register */
+#define                 CAN1_MB08_LENGTH  0xffc03510   /* CAN Controller 1 Mailbox 8 Length Register */
+#define              CAN1_MB08_TIMESTAMP  0xffc03514   /* CAN Controller 1 Mailbox 8 Timestamp Register */
+#define                    CAN1_MB08_ID0  0xffc03518   /* CAN Controller 1 Mailbox 8 ID0 Register */
+#define                    CAN1_MB08_ID1  0xffc0351c   /* CAN Controller 1 Mailbox 8 ID1 Register */
+#define                  CAN1_MB09_DATA0  0xffc03520   /* CAN Controller 1 Mailbox 9 Data 0 Register */
+#define                  CAN1_MB09_DATA1  0xffc03524   /* CAN Controller 1 Mailbox 9 Data 1 Register */
+#define                  CAN1_MB09_DATA2  0xffc03528   /* CAN Controller 1 Mailbox 9 Data 2 Register */
+#define                  CAN1_MB09_DATA3  0xffc0352c   /* CAN Controller 1 Mailbox 9 Data 3 Register */
+#define                 CAN1_MB09_LENGTH  0xffc03530   /* CAN Controller 1 Mailbox 9 Length Register */
+#define              CAN1_MB09_TIMESTAMP  0xffc03534   /* CAN Controller 1 Mailbox 9 Timestamp Register */
+#define                    CAN1_MB09_ID0  0xffc03538   /* CAN Controller 1 Mailbox 9 ID0 Register */
+#define                    CAN1_MB09_ID1  0xffc0353c   /* CAN Controller 1 Mailbox 9 ID1 Register */
+#define                  CAN1_MB10_DATA0  0xffc03540   /* CAN Controller 1 Mailbox 10 Data 0 Register */
+#define                  CAN1_MB10_DATA1  0xffc03544   /* CAN Controller 1 Mailbox 10 Data 1 Register */
+#define                  CAN1_MB10_DATA2  0xffc03548   /* CAN Controller 1 Mailbox 10 Data 2 Register */
+#define                  CAN1_MB10_DATA3  0xffc0354c   /* CAN Controller 1 Mailbox 10 Data 3 Register */
+#define                 CAN1_MB10_LENGTH  0xffc03550   /* CAN Controller 1 Mailbox 10 Length Register */
+#define              CAN1_MB10_TIMESTAMP  0xffc03554   /* CAN Controller 1 Mailbox 10 Timestamp Register */
+#define                    CAN1_MB10_ID0  0xffc03558   /* CAN Controller 1 Mailbox 10 ID0 Register */
+#define                    CAN1_MB10_ID1  0xffc0355c   /* CAN Controller 1 Mailbox 10 ID1 Register */
+#define                  CAN1_MB11_DATA0  0xffc03560   /* CAN Controller 1 Mailbox 11 Data 0 Register */
+#define                  CAN1_MB11_DATA1  0xffc03564   /* CAN Controller 1 Mailbox 11 Data 1 Register */
+#define                  CAN1_MB11_DATA2  0xffc03568   /* CAN Controller 1 Mailbox 11 Data 2 Register */
+#define                  CAN1_MB11_DATA3  0xffc0356c   /* CAN Controller 1 Mailbox 11 Data 3 Register */
+#define                 CAN1_MB11_LENGTH  0xffc03570   /* CAN Controller 1 Mailbox 11 Length Register */
+#define              CAN1_MB11_TIMESTAMP  0xffc03574   /* CAN Controller 1 Mailbox 11 Timestamp Register */
+#define                    CAN1_MB11_ID0  0xffc03578   /* CAN Controller 1 Mailbox 11 ID0 Register */
+#define                    CAN1_MB11_ID1  0xffc0357c   /* CAN Controller 1 Mailbox 11 ID1 Register */
+#define                  CAN1_MB12_DATA0  0xffc03580   /* CAN Controller 1 Mailbox 12 Data 0 Register */
+#define                  CAN1_MB12_DATA1  0xffc03584   /* CAN Controller 1 Mailbox 12 Data 1 Register */
+#define                  CAN1_MB12_DATA2  0xffc03588   /* CAN Controller 1 Mailbox 12 Data 2 Register */
+#define                  CAN1_MB12_DATA3  0xffc0358c   /* CAN Controller 1 Mailbox 12 Data 3 Register */
+#define                 CAN1_MB12_LENGTH  0xffc03590   /* CAN Controller 1 Mailbox 12 Length Register */
+#define              CAN1_MB12_TIMESTAMP  0xffc03594   /* CAN Controller 1 Mailbox 12 Timestamp Register */
+#define                    CAN1_MB12_ID0  0xffc03598   /* CAN Controller 1 Mailbox 12 ID0 Register */
+#define                    CAN1_MB12_ID1  0xffc0359c   /* CAN Controller 1 Mailbox 12 ID1 Register */
+#define                  CAN1_MB13_DATA0  0xffc035a0   /* CAN Controller 1 Mailbox 13 Data 0 Register */
+#define                  CAN1_MB13_DATA1  0xffc035a4   /* CAN Controller 1 Mailbox 13 Data 1 Register */
+#define                  CAN1_MB13_DATA2  0xffc035a8   /* CAN Controller 1 Mailbox 13 Data 2 Register */
+#define                  CAN1_MB13_DATA3  0xffc035ac   /* CAN Controller 1 Mailbox 13 Data 3 Register */
+#define                 CAN1_MB13_LENGTH  0xffc035b0   /* CAN Controller 1 Mailbox 13 Length Register */
+#define              CAN1_MB13_TIMESTAMP  0xffc035b4   /* CAN Controller 1 Mailbox 13 Timestamp Register */
+#define                    CAN1_MB13_ID0  0xffc035b8   /* CAN Controller 1 Mailbox 13 ID0 Register */
+#define                    CAN1_MB13_ID1  0xffc035bc   /* CAN Controller 1 Mailbox 13 ID1 Register */
+#define                  CAN1_MB14_DATA0  0xffc035c0   /* CAN Controller 1 Mailbox 14 Data 0 Register */
+#define                  CAN1_MB14_DATA1  0xffc035c4   /* CAN Controller 1 Mailbox 14 Data 1 Register */
+#define                  CAN1_MB14_DATA2  0xffc035c8   /* CAN Controller 1 Mailbox 14 Data 2 Register */
+#define                  CAN1_MB14_DATA3  0xffc035cc   /* CAN Controller 1 Mailbox 14 Data 3 Register */
+#define                 CAN1_MB14_LENGTH  0xffc035d0   /* CAN Controller 1 Mailbox 14 Length Register */
+#define              CAN1_MB14_TIMESTAMP  0xffc035d4   /* CAN Controller 1 Mailbox 14 Timestamp Register */
+#define                    CAN1_MB14_ID0  0xffc035d8   /* CAN Controller 1 Mailbox 14 ID0 Register */
+#define                    CAN1_MB14_ID1  0xffc035dc   /* CAN Controller 1 Mailbox 14 ID1 Register */
+#define                  CAN1_MB15_DATA0  0xffc035e0   /* CAN Controller 1 Mailbox 15 Data 0 Register */
+#define                  CAN1_MB15_DATA1  0xffc035e4   /* CAN Controller 1 Mailbox 15 Data 1 Register */
+#define                  CAN1_MB15_DATA2  0xffc035e8   /* CAN Controller 1 Mailbox 15 Data 2 Register */
+#define                  CAN1_MB15_DATA3  0xffc035ec   /* CAN Controller 1 Mailbox 15 Data 3 Register */
+#define                 CAN1_MB15_LENGTH  0xffc035f0   /* CAN Controller 1 Mailbox 15 Length Register */
+#define              CAN1_MB15_TIMESTAMP  0xffc035f4   /* CAN Controller 1 Mailbox 15 Timestamp Register */
+#define                    CAN1_MB15_ID0  0xffc035f8   /* CAN Controller 1 Mailbox 15 ID0 Register */
+#define                    CAN1_MB15_ID1  0xffc035fc   /* CAN Controller 1 Mailbox 15 ID1 Register */
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define                  CAN1_MB16_DATA0  0xffc03600   /* CAN Controller 1 Mailbox 16 Data 0 Register */
+#define                  CAN1_MB16_DATA1  0xffc03604   /* CAN Controller 1 Mailbox 16 Data 1 Register */
+#define                  CAN1_MB16_DATA2  0xffc03608   /* CAN Controller 1 Mailbox 16 Data 2 Register */
+#define                  CAN1_MB16_DATA3  0xffc0360c   /* CAN Controller 1 Mailbox 16 Data 3 Register */
+#define                 CAN1_MB16_LENGTH  0xffc03610   /* CAN Controller 1 Mailbox 16 Length Register */
+#define              CAN1_MB16_TIMESTAMP  0xffc03614   /* CAN Controller 1 Mailbox 16 Timestamp Register */
+#define                    CAN1_MB16_ID0  0xffc03618   /* CAN Controller 1 Mailbox 16 ID0 Register */
+#define                    CAN1_MB16_ID1  0xffc0361c   /* CAN Controller 1 Mailbox 16 ID1 Register */
+#define                  CAN1_MB17_DATA0  0xffc03620   /* CAN Controller 1 Mailbox 17 Data 0 Register */
+#define                  CAN1_MB17_DATA1  0xffc03624   /* CAN Controller 1 Mailbox 17 Data 1 Register */
+#define                  CAN1_MB17_DATA2  0xffc03628   /* CAN Controller 1 Mailbox 17 Data 2 Register */
+#define                  CAN1_MB17_DATA3  0xffc0362c   /* CAN Controller 1 Mailbox 17 Data 3 Register */
+#define                 CAN1_MB17_LENGTH  0xffc03630   /* CAN Controller 1 Mailbox 17 Length Register */
+#define              CAN1_MB17_TIMESTAMP  0xffc03634   /* CAN Controller 1 Mailbox 17 Timestamp Register */
+#define                    CAN1_MB17_ID0  0xffc03638   /* CAN Controller 1 Mailbox 17 ID0 Register */
+#define                    CAN1_MB17_ID1  0xffc0363c   /* CAN Controller 1 Mailbox 17 ID1 Register */
+#define                  CAN1_MB18_DATA0  0xffc03640   /* CAN Controller 1 Mailbox 18 Data 0 Register */
+#define                  CAN1_MB18_DATA1  0xffc03644   /* CAN Controller 1 Mailbox 18 Data 1 Register */
+#define                  CAN1_MB18_DATA2  0xffc03648   /* CAN Controller 1 Mailbox 18 Data 2 Register */
+#define                  CAN1_MB18_DATA3  0xffc0364c   /* CAN Controller 1 Mailbox 18 Data 3 Register */
+#define                 CAN1_MB18_LENGTH  0xffc03650   /* CAN Controller 1 Mailbox 18 Length Register */
+#define              CAN1_MB18_TIMESTAMP  0xffc03654   /* CAN Controller 1 Mailbox 18 Timestamp Register */
+#define                    CAN1_MB18_ID0  0xffc03658   /* CAN Controller 1 Mailbox 18 ID0 Register */
+#define                    CAN1_MB18_ID1  0xffc0365c   /* CAN Controller 1 Mailbox 18 ID1 Register */
+#define                  CAN1_MB19_DATA0  0xffc03660   /* CAN Controller 1 Mailbox 19 Data 0 Register */
+#define                  CAN1_MB19_DATA1  0xffc03664   /* CAN Controller 1 Mailbox 19 Data 1 Register */
+#define                  CAN1_MB19_DATA2  0xffc03668   /* CAN Controller 1 Mailbox 19 Data 2 Register */
+#define                  CAN1_MB19_DATA3  0xffc0366c   /* CAN Controller 1 Mailbox 19 Data 3 Register */
+#define                 CAN1_MB19_LENGTH  0xffc03670   /* CAN Controller 1 Mailbox 19 Length Register */
+#define              CAN1_MB19_TIMESTAMP  0xffc03674   /* CAN Controller 1 Mailbox 19 Timestamp Register */
+#define                    CAN1_MB19_ID0  0xffc03678   /* CAN Controller 1 Mailbox 19 ID0 Register */
+#define                    CAN1_MB19_ID1  0xffc0367c   /* CAN Controller 1 Mailbox 19 ID1 Register */
+#define                  CAN1_MB20_DATA0  0xffc03680   /* CAN Controller 1 Mailbox 20 Data 0 Register */
+#define                  CAN1_MB20_DATA1  0xffc03684   /* CAN Controller 1 Mailbox 20 Data 1 Register */
+#define                  CAN1_MB20_DATA2  0xffc03688   /* CAN Controller 1 Mailbox 20 Data 2 Register */
+#define                  CAN1_MB20_DATA3  0xffc0368c   /* CAN Controller 1 Mailbox 20 Data 3 Register */
+#define                 CAN1_MB20_LENGTH  0xffc03690   /* CAN Controller 1 Mailbox 20 Length Register */
+#define              CAN1_MB20_TIMESTAMP  0xffc03694   /* CAN Controller 1 Mailbox 20 Timestamp Register */
+#define                    CAN1_MB20_ID0  0xffc03698   /* CAN Controller 1 Mailbox 20 ID0 Register */
+#define                    CAN1_MB20_ID1  0xffc0369c   /* CAN Controller 1 Mailbox 20 ID1 Register */
+#define                  CAN1_MB21_DATA0  0xffc036a0   /* CAN Controller 1 Mailbox 21 Data 0 Register */
+#define                  CAN1_MB21_DATA1  0xffc036a4   /* CAN Controller 1 Mailbox 21 Data 1 Register */
+#define                  CAN1_MB21_DATA2  0xffc036a8   /* CAN Controller 1 Mailbox 21 Data 2 Register */
+#define                  CAN1_MB21_DATA3  0xffc036ac   /* CAN Controller 1 Mailbox 21 Data 3 Register */
+#define                 CAN1_MB21_LENGTH  0xffc036b0   /* CAN Controller 1 Mailbox 21 Length Register */
+#define              CAN1_MB21_TIMESTAMP  0xffc036b4   /* CAN Controller 1 Mailbox 21 Timestamp Register */
+#define                    CAN1_MB21_ID0  0xffc036b8   /* CAN Controller 1 Mailbox 21 ID0 Register */
+#define                    CAN1_MB21_ID1  0xffc036bc   /* CAN Controller 1 Mailbox 21 ID1 Register */
+#define                  CAN1_MB22_DATA0  0xffc036c0   /* CAN Controller 1 Mailbox 22 Data 0 Register */
+#define                  CAN1_MB22_DATA1  0xffc036c4   /* CAN Controller 1 Mailbox 22 Data 1 Register */
+#define                  CAN1_MB22_DATA2  0xffc036c8   /* CAN Controller 1 Mailbox 22 Data 2 Register */
+#define                  CAN1_MB22_DATA3  0xffc036cc   /* CAN Controller 1 Mailbox 22 Data 3 Register */
+#define                 CAN1_MB22_LENGTH  0xffc036d0   /* CAN Controller 1 Mailbox 22 Length Register */
+#define              CAN1_MB22_TIMESTAMP  0xffc036d4   /* CAN Controller 1 Mailbox 22 Timestamp Register */
+#define                    CAN1_MB22_ID0  0xffc036d8   /* CAN Controller 1 Mailbox 22 ID0 Register */
+#define                    CAN1_MB22_ID1  0xffc036dc   /* CAN Controller 1 Mailbox 22 ID1 Register */
+#define                  CAN1_MB23_DATA0  0xffc036e0   /* CAN Controller 1 Mailbox 23 Data 0 Register */
+#define                  CAN1_MB23_DATA1  0xffc036e4   /* CAN Controller 1 Mailbox 23 Data 1 Register */
+#define                  CAN1_MB23_DATA2  0xffc036e8   /* CAN Controller 1 Mailbox 23 Data 2 Register */
+#define                  CAN1_MB23_DATA3  0xffc036ec   /* CAN Controller 1 Mailbox 23 Data 3 Register */
+#define                 CAN1_MB23_LENGTH  0xffc036f0   /* CAN Controller 1 Mailbox 23 Length Register */
+#define              CAN1_MB23_TIMESTAMP  0xffc036f4   /* CAN Controller 1 Mailbox 23 Timestamp Register */
+#define                    CAN1_MB23_ID0  0xffc036f8   /* CAN Controller 1 Mailbox 23 ID0 Register */
+#define                    CAN1_MB23_ID1  0xffc036fc   /* CAN Controller 1 Mailbox 23 ID1 Register */
+#define                  CAN1_MB24_DATA0  0xffc03700   /* CAN Controller 1 Mailbox 24 Data 0 Register */
+#define                  CAN1_MB24_DATA1  0xffc03704   /* CAN Controller 1 Mailbox 24 Data 1 Register */
+#define                  CAN1_MB24_DATA2  0xffc03708   /* CAN Controller 1 Mailbox 24 Data 2 Register */
+#define                  CAN1_MB24_DATA3  0xffc0370c   /* CAN Controller 1 Mailbox 24 Data 3 Register */
+#define                 CAN1_MB24_LENGTH  0xffc03710   /* CAN Controller 1 Mailbox 24 Length Register */
+#define              CAN1_MB24_TIMESTAMP  0xffc03714   /* CAN Controller 1 Mailbox 24 Timestamp Register */
+#define                    CAN1_MB24_ID0  0xffc03718   /* CAN Controller 1 Mailbox 24 ID0 Register */
+#define                    CAN1_MB24_ID1  0xffc0371c   /* CAN Controller 1 Mailbox 24 ID1 Register */
+#define                  CAN1_MB25_DATA0  0xffc03720   /* CAN Controller 1 Mailbox 25 Data 0 Register */
+#define                  CAN1_MB25_DATA1  0xffc03724   /* CAN Controller 1 Mailbox 25 Data 1 Register */
+#define                  CAN1_MB25_DATA2  0xffc03728   /* CAN Controller 1 Mailbox 25 Data 2 Register */
+#define                  CAN1_MB25_DATA3  0xffc0372c   /* CAN Controller 1 Mailbox 25 Data 3 Register */
+#define                 CAN1_MB25_LENGTH  0xffc03730   /* CAN Controller 1 Mailbox 25 Length Register */
+#define              CAN1_MB25_TIMESTAMP  0xffc03734   /* CAN Controller 1 Mailbox 25 Timestamp Register */
+#define                    CAN1_MB25_ID0  0xffc03738   /* CAN Controller 1 Mailbox 25 ID0 Register */
+#define                    CAN1_MB25_ID1  0xffc0373c   /* CAN Controller 1 Mailbox 25 ID1 Register */
+#define                  CAN1_MB26_DATA0  0xffc03740   /* CAN Controller 1 Mailbox 26 Data 0 Register */
+#define                  CAN1_MB26_DATA1  0xffc03744   /* CAN Controller 1 Mailbox 26 Data 1 Register */
+#define                  CAN1_MB26_DATA2  0xffc03748   /* CAN Controller 1 Mailbox 26 Data 2 Register */
+#define                  CAN1_MB26_DATA3  0xffc0374c   /* CAN Controller 1 Mailbox 26 Data 3 Register */
+#define                 CAN1_MB26_LENGTH  0xffc03750   /* CAN Controller 1 Mailbox 26 Length Register */
+#define              CAN1_MB26_TIMESTAMP  0xffc03754   /* CAN Controller 1 Mailbox 26 Timestamp Register */
+#define                    CAN1_MB26_ID0  0xffc03758   /* CAN Controller 1 Mailbox 26 ID0 Register */
+#define                    CAN1_MB26_ID1  0xffc0375c   /* CAN Controller 1 Mailbox 26 ID1 Register */
+#define                  CAN1_MB27_DATA0  0xffc03760   /* CAN Controller 1 Mailbox 27 Data 0 Register */
+#define                  CAN1_MB27_DATA1  0xffc03764   /* CAN Controller 1 Mailbox 27 Data 1 Register */
+#define                  CAN1_MB27_DATA2  0xffc03768   /* CAN Controller 1 Mailbox 27 Data 2 Register */
+#define                  CAN1_MB27_DATA3  0xffc0376c   /* CAN Controller 1 Mailbox 27 Data 3 Register */
+#define                 CAN1_MB27_LENGTH  0xffc03770   /* CAN Controller 1 Mailbox 27 Length Register */
+#define              CAN1_MB27_TIMESTAMP  0xffc03774   /* CAN Controller 1 Mailbox 27 Timestamp Register */
+#define                    CAN1_MB27_ID0  0xffc03778   /* CAN Controller 1 Mailbox 27 ID0 Register */
+#define                    CAN1_MB27_ID1  0xffc0377c   /* CAN Controller 1 Mailbox 27 ID1 Register */
+#define                  CAN1_MB28_DATA0  0xffc03780   /* CAN Controller 1 Mailbox 28 Data 0 Register */
+#define                  CAN1_MB28_DATA1  0xffc03784   /* CAN Controller 1 Mailbox 28 Data 1 Register */
+#define                  CAN1_MB28_DATA2  0xffc03788   /* CAN Controller 1 Mailbox 28 Data 2 Register */
+#define                  CAN1_MB28_DATA3  0xffc0378c   /* CAN Controller 1 Mailbox 28 Data 3 Register */
+#define                 CAN1_MB28_LENGTH  0xffc03790   /* CAN Controller 1 Mailbox 28 Length Register */
+#define              CAN1_MB28_TIMESTAMP  0xffc03794   /* CAN Controller 1 Mailbox 28 Timestamp Register */
+#define                    CAN1_MB28_ID0  0xffc03798   /* CAN Controller 1 Mailbox 28 ID0 Register */
+#define                    CAN1_MB28_ID1  0xffc0379c   /* CAN Controller 1 Mailbox 28 ID1 Register */
+#define                  CAN1_MB29_DATA0  0xffc037a0   /* CAN Controller 1 Mailbox 29 Data 0 Register */
+#define                  CAN1_MB29_DATA1  0xffc037a4   /* CAN Controller 1 Mailbox 29 Data 1 Register */
+#define                  CAN1_MB29_DATA2  0xffc037a8   /* CAN Controller 1 Mailbox 29 Data 2 Register */
+#define                  CAN1_MB29_DATA3  0xffc037ac   /* CAN Controller 1 Mailbox 29 Data 3 Register */
+#define                 CAN1_MB29_LENGTH  0xffc037b0   /* CAN Controller 1 Mailbox 29 Length Register */
+#define              CAN1_MB29_TIMESTAMP  0xffc037b4   /* CAN Controller 1 Mailbox 29 Timestamp Register */
+#define                    CAN1_MB29_ID0  0xffc037b8   /* CAN Controller 1 Mailbox 29 ID0 Register */
+#define                    CAN1_MB29_ID1  0xffc037bc   /* CAN Controller 1 Mailbox 29 ID1 Register */
+#define                  CAN1_MB30_DATA0  0xffc037c0   /* CAN Controller 1 Mailbox 30 Data 0 Register */
+#define                  CAN1_MB30_DATA1  0xffc037c4   /* CAN Controller 1 Mailbox 30 Data 1 Register */
+#define                  CAN1_MB30_DATA2  0xffc037c8   /* CAN Controller 1 Mailbox 30 Data 2 Register */
+#define                  CAN1_MB30_DATA3  0xffc037cc   /* CAN Controller 1 Mailbox 30 Data 3 Register */
+#define                 CAN1_MB30_LENGTH  0xffc037d0   /* CAN Controller 1 Mailbox 30 Length Register */
+#define              CAN1_MB30_TIMESTAMP  0xffc037d4   /* CAN Controller 1 Mailbox 30 Timestamp Register */
+#define                    CAN1_MB30_ID0  0xffc037d8   /* CAN Controller 1 Mailbox 30 ID0 Register */
+#define                    CAN1_MB30_ID1  0xffc037dc   /* CAN Controller 1 Mailbox 30 ID1 Register */
+#define                  CAN1_MB31_DATA0  0xffc037e0   /* CAN Controller 1 Mailbox 31 Data 0 Register */
+#define                  CAN1_MB31_DATA1  0xffc037e4   /* CAN Controller 1 Mailbox 31 Data 1 Register */
+#define                  CAN1_MB31_DATA2  0xffc037e8   /* CAN Controller 1 Mailbox 31 Data 2 Register */
+#define                  CAN1_MB31_DATA3  0xffc037ec   /* CAN Controller 1 Mailbox 31 Data 3 Register */
+#define                 CAN1_MB31_LENGTH  0xffc037f0   /* CAN Controller 1 Mailbox 31 Length Register */
+#define              CAN1_MB31_TIMESTAMP  0xffc037f4   /* CAN Controller 1 Mailbox 31 Timestamp Register */
+#define                    CAN1_MB31_ID0  0xffc037f8   /* CAN Controller 1 Mailbox 31 ID0 Register */
+#define                    CAN1_MB31_ID1  0xffc037fc   /* CAN Controller 1 Mailbox 31 ID1 Register */
+
+/* HOST Port Registers */
+
+#define                     HOST_CONTROL  0xffc03a00   /* HOST Control Register */
+#define                      HOST_STATUS  0xffc03a04   /* HOST Status Register */
+#define                     HOST_TIMEOUT  0xffc03a08   /* HOST Acknowledge Mode Timeout Register */
+
+/* Pixel Compositor (PIXC) Registers */
+
+#define                         PIXC_CTL  0xffc04400   /* Overlay enable, resampling mode, I/O data format, transparency enable, watermark level, FIFO status */
+#define                         PIXC_PPL  0xffc04404   /* Holds the number of pixels per line of the display */
+#define                         PIXC_LPF  0xffc04408   /* Holds the number of lines per frame of the display */
+#define                     PIXC_AHSTART  0xffc0440c   /* Contains horizontal start pixel information of the overlay data (set A) */
+#define                       PIXC_AHEND  0xffc04410   /* Contains horizontal end pixel information of the overlay data (set A) */
+#define                     PIXC_AVSTART  0xffc04414   /* Contains vertical start pixel information of the overlay data (set A) */
+#define                       PIXC_AVEND  0xffc04418   /* Contains vertical end pixel information of the overlay data (set A) */
+#define                     PIXC_ATRANSP  0xffc0441c   /* Contains the transparency ratio (set A) */
+#define                     PIXC_BHSTART  0xffc04420   /* Contains horizontal start pixel information of the overlay data (set B) */
+#define                       PIXC_BHEND  0xffc04424   /* Contains horizontal end pixel information of the overlay data (set B) */
+#define                     PIXC_BVSTART  0xffc04428   /* Contains vertical start pixel information of the overlay data (set B) */
+#define                       PIXC_BVEND  0xffc0442c   /* Contains vertical end pixel information of the overlay data (set B) */
+#define                     PIXC_BTRANSP  0xffc04430   /* Contains the transparency ratio (set B) */
+#define                    PIXC_INTRSTAT  0xffc0443c   /* Overlay interrupt configuration/status */
+#define                       PIXC_RYCON  0xffc04440   /* Color space conversion matrix register. Contains the R/Y conversion coefficients */
+#define                       PIXC_GUCON  0xffc04444   /* Color space conversion matrix register. Contains the G/U conversion coefficients */
+#define                       PIXC_BVCON  0xffc04448   /* Color space conversion matrix register. Contains the B/V conversion coefficients */
+#define                      PIXC_CCBIAS  0xffc0444c   /* Bias values for the color space conversion matrix */
+#define                          PIXC_TC  0xffc04450   /* Holds the transparent color value */
+
+/* Handshake MDMA 0 Registers */
+
+#define                   HMDMA0_CONTROL  0xffc04500   /* Handshake MDMA0 Control Register */
+#define                    HMDMA0_ECINIT  0xffc04504   /* Handshake MDMA0 Initial Edge Count Register */
+#define                    HMDMA0_BCINIT  0xffc04508   /* Handshake MDMA0 Initial Block Count Register */
+#define                  HMDMA0_ECURGENT  0xffc0450c   /* Handshake MDMA0 Urgent Edge Count Threshhold Register */
+#define                HMDMA0_ECOVERFLOW  0xffc04510   /* Handshake MDMA0 Edge Count Overflow Interrupt Register */
+#define                    HMDMA0_ECOUNT  0xffc04514   /* Handshake MDMA0 Current Edge Count Register */
+#define                    HMDMA0_BCOUNT  0xffc04518   /* Handshake MDMA0 Current Block Count Register */
+
+/* Handshake MDMA 1 Registers */
+
+#define                   HMDMA1_CONTROL  0xffc04540   /* Handshake MDMA1 Control Register */
+#define                    HMDMA1_ECINIT  0xffc04544   /* Handshake MDMA1 Initial Edge Count Register */
+#define                    HMDMA1_BCINIT  0xffc04548   /* Handshake MDMA1 Initial Block Count Register */
+#define                  HMDMA1_ECURGENT  0xffc0454c   /* Handshake MDMA1 Urgent Edge Count Threshhold Register */
+#define                HMDMA1_ECOVERFLOW  0xffc04550   /* Handshake MDMA1 Edge Count Overflow Interrupt Register */
+#define                    HMDMA1_ECOUNT  0xffc04554   /* Handshake MDMA1 Current Edge Count Register */
+#define                    HMDMA1_BCOUNT  0xffc04558   /* Handshake MDMA1 Current Block Count Register */
+
+
+/* ********************************************************** */
+/*     SINGLE BIT MACRO PAIRS (bit mask and negated one)      */
+/*     and MULTI BIT READ MACROS                              */
+/* ********************************************************** */
+
+/* Bit masks for PIXC_CTL */
+
+#define                   PIXC_EN  0x1        /* Pixel Compositor Enable */
+#define                  nPIXC_EN  0x0       
+#define                  OVR_A_EN  0x2        /* Overlay A Enable */
+#define                 nOVR_A_EN  0x0       
+#define                  OVR_B_EN  0x4        /* Overlay B Enable */
+#define                 nOVR_B_EN  0x0       
+#define                  IMG_FORM  0x8        /* Image Data Format */
+#define                 nIMG_FORM  0x0       
+#define                  OVR_FORM  0x10       /* Overlay Data Format */
+#define                 nOVR_FORM  0x0       
+#define                  OUT_FORM  0x20       /* Output Data Format */
+#define                 nOUT_FORM  0x0       
+#define                   UDS_MOD  0x40       /* Resampling Mode */
+#define                  nUDS_MOD  0x0       
+#define                     TC_EN  0x80       /* Transparent Color Enable */
+#define                    nTC_EN  0x0       
+#define                  IMG_STAT  0x300      /* Image FIFO Status */
+#define                  OVR_STAT  0xc00      /* Overlay FIFO Status */
+#define                    WM_LVL  0x3000     /* FIFO Watermark Level */
+
+/* Bit masks for PIXC_AHSTART */
+
+#define                  A_HSTART  0xfff      /* Horizontal Start Coordinates */
+
+/* Bit masks for PIXC_AHEND */
+
+#define                    A_HEND  0xfff      /* Horizontal End Coordinates */
+
+/* Bit masks for PIXC_AVSTART */
+
+#define                  A_VSTART  0x3ff      /* Vertical Start Coordinates */
+
+/* Bit masks for PIXC_AVEND */
+
+#define                    A_VEND  0x3ff      /* Vertical End Coordinates */
+
+/* Bit masks for PIXC_ATRANSP */
+
+#define                  A_TRANSP  0xf        /* Transparency Value */
+
+/* Bit masks for PIXC_BHSTART */
+
+#define                  B_HSTART  0xfff      /* Horizontal Start Coordinates */
+
+/* Bit masks for PIXC_BHEND */
+
+#define                    B_HEND  0xfff      /* Horizontal End Coordinates */
+
+/* Bit masks for PIXC_BVSTART */
+
+#define                  B_VSTART  0x3ff      /* Vertical Start Coordinates */
+
+/* Bit masks for PIXC_BVEND */
+
+#define                    B_VEND  0x3ff      /* Vertical End Coordinates */
+
+/* Bit masks for PIXC_BTRANSP */
+
+#define                  B_TRANSP  0xf        /* Transparency Value */
+
+/* Bit masks for PIXC_INTRSTAT */
+
+#define                OVR_INT_EN  0x1        /* Interrupt at End of Last Valid Overlay */
+#define               nOVR_INT_EN  0x0       
+#define                FRM_INT_EN  0x2        /* Interrupt at End of Frame */
+#define               nFRM_INT_EN  0x0       
+#define              OVR_INT_STAT  0x4        /* Overlay Interrupt Status */
+#define             nOVR_INT_STAT  0x0       
+#define              FRM_INT_STAT  0x8        /* Frame Interrupt Status */
+#define             nFRM_INT_STAT  0x0       
+
+/* Bit masks for PIXC_RYCON */
+
+#define                       A11  0x3ff      /* A11 in the Coefficient Matrix */
+#define                       A12  0xffc00    /* A12 in the Coefficient Matrix */
+#define                       A13  0x3ff00000 /* A13 in the Coefficient Matrix */
+#define                  RY_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nRY_MULT4  0x0       
+
+/* Bit masks for PIXC_GUCON */
+
+#define                       A21  0x3ff      /* A21 in the Coefficient Matrix */
+#define                       A22  0xffc00    /* A22 in the Coefficient Matrix */
+#define                       A23  0x3ff00000 /* A23 in the Coefficient Matrix */
+#define                  GU_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nGU_MULT4  0x0       
+
+/* Bit masks for PIXC_BVCON */
+
+#define                       A31  0x3ff      /* A31 in the Coefficient Matrix */
+#define                       A32  0xffc00    /* A32 in the Coefficient Matrix */
+#define                       A33  0x3ff00000 /* A33 in the Coefficient Matrix */
+#define                  BV_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nBV_MULT4  0x0       
+
+/* Bit masks for PIXC_CCBIAS */
+
+#define                       A14  0x3ff      /* A14 in the Bias Vector */
+#define                       A24  0xffc00    /* A24 in the Bias Vector */
+#define                       A34  0x3ff00000 /* A34 in the Bias Vector */
+
+/* Bit masks for PIXC_TC */
+
+#define                  RY_TRANS  0xff       /* Transparent Color - R/Y Component */
+#define                  GU_TRANS  0xff00     /* Transparent Color - G/U Component */
+#define                  BV_TRANS  0xff0000   /* Transparent Color - B/V Component */
+
+/* Bit masks for HOST_CONTROL */
+
+#define                   HOST_EN  0x1        /* Host Enable */
+#define                  nHOST_EN  0x0       
+#define                  HOST_END  0x2        /* Host Endianess */
+#define                 nHOST_END  0x0       
+#define                 DATA_SIZE  0x4        /* Data Size */
+#define                nDATA_SIZE  0x0       
+#define                  HOST_RST  0x8        /* Host Reset */
+#define                 nHOST_RST  0x0       
+#define                  HRDY_OVR  0x20       /* Host Ready Override */
+#define                 nHRDY_OVR  0x0       
+#define                  INT_MODE  0x40       /* Interrupt Mode */
+#define                 nINT_MODE  0x0       
+#define                     BT_EN  0x80       /* Bus Timeout Enable */
+#define                    nBT_EN  0x0       
+#define                       EHW  0x100      /* Enable Host Write */
+#define                      nEHW  0x0       
+#define                       EHR  0x200      /* Enable Host Read */
+#define                      nEHR  0x0       
+#define                       BDR  0x400      /* Burst DMA Requests */
+#define                      nBDR  0x0       
+
+/* Bit masks for HOST_STATUS */
+
+#define                     READY  0x1        /* DMA Ready */
+#define                    nREADY  0x0       
+#define                  FIFOFULL  0x2        /* FIFO Full */
+#define                 nFIFOFULL  0x0       
+#define                 FIFOEMPTY  0x4        /* FIFO Empty */
+#define                nFIFOEMPTY  0x0       
+#define                  COMPLETE  0x8        /* DMA Complete */
+#define                 nCOMPLETE  0x0       
+#define                      HSHK  0x10       /* Host Handshake */
+#define                     nHSHK  0x0       
+#define                   TIMEOUT  0x20       /* Host Timeout */
+#define                  nTIMEOUT  0x0       
+#define                      HIRQ  0x40       /* Host Interrupt Request */
+#define                     nHIRQ  0x0       
+#define                ALLOW_CNFG  0x80       /* Allow New Configuration */
+#define               nALLOW_CNFG  0x0       
+#define                   DMA_DIR  0x100      /* DMA Direction */
+#define                  nDMA_DIR  0x0       
+#define                       BTE  0x200      /* Bus Timeout Enabled */
+#define                      nBTE  0x0       
+
+/* Bit masks for HOST_TIMEOUT */
+
+#define             COUNT_TIMEOUT  0x7ff      /* Host Timeout count */
+
+/* Bit masks for TIMER_ENABLE1 */
+
+#define                    TIMEN8  0x1        /* Timer 8 Enable */
+#define                   nTIMEN8  0x0       
+#define                    TIMEN9  0x2        /* Timer 9 Enable */
+#define                   nTIMEN9  0x0       
+#define                   TIMEN10  0x4        /* Timer 10 Enable */
+#define                  nTIMEN10  0x0       
+
+/* Bit masks for TIMER_DISABLE1 */
+
+#define                   TIMDIS8  0x1        /* Timer 8 Disable */
+#define                  nTIMDIS8  0x0       
+#define                   TIMDIS9  0x2        /* Timer 9 Disable */
+#define                  nTIMDIS9  0x0       
+#define                  TIMDIS10  0x4        /* Timer 10 Disable */
+#define                 nTIMDIS10  0x0       
+
+/* Bit masks for TIMER_STATUS1 */
+
+#define                    TIMIL8  0x1        /* Timer 8 Interrupt */
+#define                   nTIMIL8  0x0       
+#define                    TIMIL9  0x2        /* Timer 9 Interrupt */
+#define                   nTIMIL9  0x0       
+#define                   TIMIL10  0x4        /* Timer 10 Interrupt */
+#define                  nTIMIL10  0x0       
+#define                 TOVF_ERR8  0x10       /* Timer 8 Counter Overflow */
+#define                nTOVF_ERR8  0x0       
+#define                 TOVF_ERR9  0x20       /* Timer 9 Counter Overflow */
+#define                nTOVF_ERR9  0x0       
+#define                TOVF_ERR10  0x40       /* Timer 10 Counter Overflow */
+#define               nTOVF_ERR10  0x0       
+#define                     TRUN8  0x1000     /* Timer 8 Slave Enable Status */
+#define                    nTRUN8  0x0       
+#define                     TRUN9  0x2000     /* Timer 9 Slave Enable Status */
+#define                    nTRUN9  0x0       
+#define                    TRUN10  0x4000     /* Timer 10 Slave Enable Status */
+#define                   nTRUN10  0x0       
+
+/* Bit masks for EPPI0 are obtained from common base header for EPPIx (EPPI1 and EPPI2) */
+
+/* Bit masks for HMDMAx_CONTROL */
+
+#define                   HMDMAEN  0x1        /* Handshake MDMA Enable */
+#define                  nHMDMAEN  0x0       
+#define                       REP  0x2        /* Handshake MDMA Request Polarity */
+#define                      nREP  0x0       
+#define                       UTE  0x8        /* Urgency Threshold Enable */
+#define                      nUTE  0x0       
+#define                       OIE  0x10       /* Overflow Interrupt Enable */
+#define                      nOIE  0x0       
+#define                      BDIE  0x20       /* Block Done Interrupt Enable */
+#define                     nBDIE  0x0       
+#define                      MBDI  0x40       /* Mask Block Done Interrupt */
+#define                     nMBDI  0x0       
+#define                       DRQ  0x300      /* Handshake MDMA Request Type */
+#define                       RBC  0x1000     /* Force Reload of BCOUNT */
+#define                      nRBC  0x0       
+#define                        PS  0x2000     /* Pin Status */
+#define                       nPS  0x0       
+#define                        OI  0x4000     /* Overflow Interrupt Generated */
+#define                       nOI  0x0       
+#define                       BDI  0x8000     /* Block Done Interrupt Generated */
+#define                      nBDI  0x0       
+
+/* ******************************************* */
+/*     MULTI BIT MACRO ENUMERATIONS            */
+/* ******************************************* */
+
+#endif /* _DEF_BF544_H */
diff --git a/include/asm-blackfin/mach-bf548/defBF548.h b/include/asm-blackfin/mach-bf548/defBF548.h
new file mode 100644
index 0000000..d9e3062
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/defBF548.h
@@ -0,0 +1,1966 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/defBF548.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF548_H
+#define _DEF_BF548_H
+
+/* Include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF548 */
+
+/* Include defBF54x_base.h for the set of #defines that are common to all ADSP-BF54x processors */
+#include "defBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF548 that are not in the common header */
+
+/* Timer Registers */
+
+#define                    TIMER8_CONFIG  0xffc00600   /* Timer 8 Configuration Register */
+#define                   TIMER8_COUNTER  0xffc00604   /* Timer 8 Counter Register */
+#define                    TIMER8_PERIOD  0xffc00608   /* Timer 8 Period Register */
+#define                     TIMER8_WIDTH  0xffc0060c   /* Timer 8 Width Register */
+#define                    TIMER9_CONFIG  0xffc00610   /* Timer 9 Configuration Register */
+#define                   TIMER9_COUNTER  0xffc00614   /* Timer 9 Counter Register */
+#define                    TIMER9_PERIOD  0xffc00618   /* Timer 9 Period Register */
+#define                     TIMER9_WIDTH  0xffc0061c   /* Timer 9 Width Register */
+#define                   TIMER10_CONFIG  0xffc00620   /* Timer 10 Configuration Register */
+#define                  TIMER10_COUNTER  0xffc00624   /* Timer 10 Counter Register */
+#define                   TIMER10_PERIOD  0xffc00628   /* Timer 10 Period Register */
+#define                    TIMER10_WIDTH  0xffc0062c   /* Timer 10 Width Register */
+
+/* Timer Group of 3 Registers */
+
+#define                    TIMER_ENABLE1  0xffc00640   /* Timer Group of 3 Enable Register */
+#define                   TIMER_DISABLE1  0xffc00644   /* Timer Group of 3 Disable Register */
+#define                    TIMER_STATUS1  0xffc00648   /* Timer Group of 3 Status Register */
+
+/* SPORT0 Registers */
+
+#define                      SPORT0_TCR1  0xffc00800   /* SPORT0 Transmit Configuration 1 Register */
+#define                      SPORT0_TCR2  0xffc00804   /* SPORT0 Transmit Configuration 2 Register */
+#define                   SPORT0_TCLKDIV  0xffc00808   /* SPORT0 Transmit Serial Clock Divider Register */
+#define                    SPORT0_TFSDIV  0xffc0080c   /* SPORT0 Transmit Frame Sync Divider Register */
+#define                        SPORT0_TX  0xffc00810   /* SPORT0 Transmit Data Register */
+#define                        SPORT0_RX  0xffc00818   /* SPORT0 Receive Data Register */
+#define                      SPORT0_RCR1  0xffc00820   /* SPORT0 Receive Configuration 1 Register */
+#define                      SPORT0_RCR2  0xffc00824   /* SPORT0 Receive Configuration 2 Register */
+#define                   SPORT0_RCLKDIV  0xffc00828   /* SPORT0 Receive Serial Clock Divider Register */
+#define                    SPORT0_RFSDIV  0xffc0082c   /* SPORT0 Receive Frame Sync Divider Register */
+#define                      SPORT0_STAT  0xffc00830   /* SPORT0 Status Register */
+#define                      SPORT0_CHNL  0xffc00834   /* SPORT0 Current Channel Register */
+#define                     SPORT0_MCMC1  0xffc00838   /* SPORT0 Multi channel Configuration Register 1 */
+#define                     SPORT0_MCMC2  0xffc0083c   /* SPORT0 Multi channel Configuration Register 2 */
+#define                     SPORT0_MTCS0  0xffc00840   /* SPORT0 Multi channel Transmit Select Register 0 */
+#define                     SPORT0_MTCS1  0xffc00844   /* SPORT0 Multi channel Transmit Select Register 1 */
+#define                     SPORT0_MTCS2  0xffc00848   /* SPORT0 Multi channel Transmit Select Register 2 */
+#define                     SPORT0_MTCS3  0xffc0084c   /* SPORT0 Multi channel Transmit Select Register 3 */
+#define                     SPORT0_MRCS0  0xffc00850   /* SPORT0 Multi channel Receive Select Register 0 */
+#define                     SPORT0_MRCS1  0xffc00854   /* SPORT0 Multi channel Receive Select Register 1 */
+#define                     SPORT0_MRCS2  0xffc00858   /* SPORT0 Multi channel Receive Select Register 2 */
+#define                     SPORT0_MRCS3  0xffc0085c   /* SPORT0 Multi channel Receive Select Register 3 */
+
+/* EPPI0 Registers */
+
+#define                     EPPI0_STATUS  0xffc01000   /* EPPI0 Status Register */
+#define                     EPPI0_HCOUNT  0xffc01004   /* EPPI0 Horizontal Transfer Count Register */
+#define                     EPPI0_HDELAY  0xffc01008   /* EPPI0 Horizontal Delay Count Register */
+#define                     EPPI0_VCOUNT  0xffc0100c   /* EPPI0 Vertical Transfer Count Register */
+#define                     EPPI0_VDELAY  0xffc01010   /* EPPI0 Vertical Delay Count Register */
+#define                      EPPI0_FRAME  0xffc01014   /* EPPI0 Lines per Frame Register */
+#define                       EPPI0_LINE  0xffc01018   /* EPPI0 Samples per Line Register */
+#define                     EPPI0_CLKDIV  0xffc0101c   /* EPPI0 Clock Divide Register */
+#define                    EPPI0_CONTROL  0xffc01020   /* EPPI0 Control Register */
+#define                   EPPI0_FS1W_HBL  0xffc01024   /* EPPI0 FS1 Width Register / EPPI0 Horizontal Blanking Samples Per Line Register */
+#define                  EPPI0_FS1P_AVPL  0xffc01028   /* EPPI0 FS1 Period Register / EPPI0 Active Video Samples Per Line Register */
+#define                   EPPI0_FS2W_LVB  0xffc0102c   /* EPPI0 FS2 Width Register / EPPI0 Lines of Vertical Blanking Register */
+#define                  EPPI0_FS2P_LAVF  0xffc01030   /* EPPI0 FS2 Period Register/ EPPI0 Lines of Active Video Per Field Register */
+#define                       EPPI0_CLIP  0xffc01034   /* EPPI0 Clipping Register */
+
+/* UART2 Registers */
+
+#define                        UART2_DLL  0xffc02100   /* Divisor Latch Low Byte */
+#define                        UART2_DLH  0xffc02104   /* Divisor Latch High Byte */
+#define                       UART2_GCTL  0xffc02108   /* Global Control Register */
+#define                        UART2_LCR  0xffc0210c   /* Line Control Register */
+#define                        UART2_MCR  0xffc02110   /* Modem Control Register */
+#define                        UART2_LSR  0xffc02114   /* Line Status Register */
+#define                        UART2_MSR  0xffc02118   /* Modem Status Register */
+#define                        UART2_SCR  0xffc0211c   /* Scratch Register */
+#define                    UART2_IER_SET  0xffc02120   /* Interrupt Enable Register Set */
+#define                  UART2_IER_CLEAR  0xffc02124   /* Interrupt Enable Register Clear */
+#define                        UART2_RBR  0xffc0212c   /* Receive Buffer Register */
+
+/* Two Wire Interface Registers (TWI1) */
+
+#define                      TWI1_CLKDIV  0xffc02200   /* Clock Divider Register */
+#define                     TWI1_CONTROL  0xffc02204   /* TWI Control Register */
+#define                  TWI1_SLAVE_CTRL  0xffc02208   /* TWI Slave Mode Control Register */
+#define                  TWI1_SLAVE_STAT  0xffc0220c   /* TWI Slave Mode Status Register */
+#define                  TWI1_SLAVE_ADDR  0xffc02210   /* TWI Slave Mode Address Register */
+#define                 TWI1_MASTER_CTRL  0xffc02214   /* TWI Master Mode Control Register */
+#define                 TWI1_MASTER_STAT  0xffc02218   /* TWI Master Mode Status Register */
+#define                 TWI1_MASTER_ADDR  0xffc0221c   /* TWI Master Mode Address Register */
+#define                    TWI1_INT_STAT  0xffc02220   /* TWI Interrupt Status Register */
+#define                    TWI1_INT_MASK  0xffc02224   /* TWI Interrupt Mask Register */
+#define                   TWI1_FIFO_CTRL  0xffc02228   /* TWI FIFO Control Register */
+#define                   TWI1_FIFO_STAT  0xffc0222c   /* TWI FIFO Status Register */
+#define                   TWI1_XMT_DATA8  0xffc02280   /* TWI FIFO Transmit Data Single Byte Register */
+#define                  TWI1_XMT_DATA16  0xffc02284   /* TWI FIFO Transmit Data Double Byte Register */
+#define                   TWI1_RCV_DATA8  0xffc02288   /* TWI FIFO Receive Data Single Byte Register */
+#define                  TWI1_RCV_DATA16  0xffc0228c   /* TWI FIFO Receive Data Double Byte Register */
+
+/* SPI2  Registers */
+
+#define                         SPI2_CTL  0xffc02400   /* SPI2 Control Register */
+#define                         SPI2_FLG  0xffc02404   /* SPI2 Flag Register */
+#define                        SPI2_STAT  0xffc02408   /* SPI2 Status Register */
+#define                        SPI2_TDBR  0xffc0240c   /* SPI2 Transmit Data Buffer Register */
+#define                        SPI2_RDBR  0xffc02410   /* SPI2 Receive Data Buffer Register */
+#define                        SPI2_BAUD  0xffc02414   /* SPI2 Baud Rate Register */
+#define                      SPI2_SHADOW  0xffc02418   /* SPI2 Receive Data Buffer Shadow Register */
+
+/* CAN Controller 1 Config 1 Registers */
+
+#define                         CAN1_MC1  0xffc03200   /* CAN Controller 1 Mailbox Configuration Register 1 */
+#define                         CAN1_MD1  0xffc03204   /* CAN Controller 1 Mailbox Direction Register 1 */
+#define                        CAN1_TRS1  0xffc03208   /* CAN Controller 1 Transmit Request Set Register 1 */
+#define                        CAN1_TRR1  0xffc0320c   /* CAN Controller 1 Transmit Request Reset Register 1 */
+#define                         CAN1_TA1  0xffc03210   /* CAN Controller 1 Transmit Acknowledge Register 1 */
+#define                         CAN1_AA1  0xffc03214   /* CAN Controller 1 Abort Acknowledge Register 1 */
+#define                        CAN1_RMP1  0xffc03218   /* CAN Controller 1 Receive Message Pending Register 1 */
+#define                        CAN1_RML1  0xffc0321c   /* CAN Controller 1 Receive Message Lost Register 1 */
+#define                      CAN1_MBTIF1  0xffc03220   /* CAN Controller 1 Mailbox Transmit Interrupt Flag Register 1 */
+#define                      CAN1_MBRIF1  0xffc03224   /* CAN Controller 1 Mailbox Receive Interrupt Flag Register 1 */
+#define                       CAN1_MBIM1  0xffc03228   /* CAN Controller 1 Mailbox Interrupt Mask Register 1 */
+#define                        CAN1_RFH1  0xffc0322c   /* CAN Controller 1 Remote Frame Handling Enable Register 1 */
+#define                       CAN1_OPSS1  0xffc03230   /* CAN Controller 1 Overwrite Protection Single Shot Transmit Register 1 */
+
+/* CAN Controller 1 Config 2 Registers */
+
+#define                         CAN1_MC2  0xffc03240   /* CAN Controller 1 Mailbox Configuration Register 2 */
+#define                         CAN1_MD2  0xffc03244   /* CAN Controller 1 Mailbox Direction Register 2 */
+#define                        CAN1_TRS2  0xffc03248   /* CAN Controller 1 Transmit Request Set Register 2 */
+#define                        CAN1_TRR2  0xffc0324c   /* CAN Controller 1 Transmit Request Reset Register 2 */
+#define                         CAN1_TA2  0xffc03250   /* CAN Controller 1 Transmit Acknowledge Register 2 */
+#define                         CAN1_AA2  0xffc03254   /* CAN Controller 1 Abort Acknowledge Register 2 */
+#define                        CAN1_RMP2  0xffc03258   /* CAN Controller 1 Receive Message Pending Register 2 */
+#define                        CAN1_RML2  0xffc0325c   /* CAN Controller 1 Receive Message Lost Register 2 */
+#define                      CAN1_MBTIF2  0xffc03260   /* CAN Controller 1 Mailbox Transmit Interrupt Flag Register 2 */
+#define                      CAN1_MBRIF2  0xffc03264   /* CAN Controller 1 Mailbox Receive Interrupt Flag Register 2 */
+#define                       CAN1_MBIM2  0xffc03268   /* CAN Controller 1 Mailbox Interrupt Mask Register 2 */
+#define                        CAN1_RFH2  0xffc0326c   /* CAN Controller 1 Remote Frame Handling Enable Register 2 */
+#define                       CAN1_OPSS2  0xffc03270   /* CAN Controller 1 Overwrite Protection Single Shot Transmit Register 2 */
+
+/* CAN Controller 1 Clock/Interrupt/Counter Registers */
+
+#define                       CAN1_CLOCK  0xffc03280   /* CAN Controller 1 Clock Register */
+#define                      CAN1_TIMING  0xffc03284   /* CAN Controller 1 Timing Register */
+#define                       CAN1_DEBUG  0xffc03288   /* CAN Controller 1 Debug Register */
+#define                      CAN1_STATUS  0xffc0328c   /* CAN Controller 1 Global Status Register */
+#define                         CAN1_CEC  0xffc03290   /* CAN Controller 1 Error Counter Register */
+#define                         CAN1_GIS  0xffc03294   /* CAN Controller 1 Global Interrupt Status Register */
+#define                         CAN1_GIM  0xffc03298   /* CAN Controller 1 Global Interrupt Mask Register */
+#define                         CAN1_GIF  0xffc0329c   /* CAN Controller 1 Global Interrupt Flag Register */
+#define                     CAN1_CONTROL  0xffc032a0   /* CAN Controller 1 Master Control Register */
+#define                        CAN1_INTR  0xffc032a4   /* CAN Controller 1 Interrupt Pending Register */
+#define                        CAN1_MBTD  0xffc032ac   /* CAN Controller 1 Mailbox Temporary Disable Register */
+#define                         CAN1_EWR  0xffc032b0   /* CAN Controller 1 Programmable Warning Level Register */
+#define                         CAN1_ESR  0xffc032b4   /* CAN Controller 1 Error Status Register */
+#define                       CAN1_UCCNT  0xffc032c4   /* CAN Controller 1 Universal Counter Register */
+#define                        CAN1_UCRC  0xffc032c8   /* CAN Controller 1 Universal Counter Force Reload Register */
+#define                       CAN1_UCCNF  0xffc032cc   /* CAN Controller 1 Universal Counter Configuration Register */
+
+/* CAN Controller 1 Mailbox Acceptance Registers */
+
+#define                       CAN1_AM00L  0xffc03300   /* CAN Controller 1 Mailbox 0 Acceptance Mask High Register */
+#define                       CAN1_AM00H  0xffc03304   /* CAN Controller 1 Mailbox 0 Acceptance Mask Low Register */
+#define                       CAN1_AM01L  0xffc03308   /* CAN Controller 1 Mailbox 1 Acceptance Mask High Register */
+#define                       CAN1_AM01H  0xffc0330c   /* CAN Controller 1 Mailbox 1 Acceptance Mask Low Register */
+#define                       CAN1_AM02L  0xffc03310   /* CAN Controller 1 Mailbox 2 Acceptance Mask High Register */
+#define                       CAN1_AM02H  0xffc03314   /* CAN Controller 1 Mailbox 2 Acceptance Mask Low Register */
+#define                       CAN1_AM03L  0xffc03318   /* CAN Controller 1 Mailbox 3 Acceptance Mask High Register */
+#define                       CAN1_AM03H  0xffc0331c   /* CAN Controller 1 Mailbox 3 Acceptance Mask Low Register */
+#define                       CAN1_AM04L  0xffc03320   /* CAN Controller 1 Mailbox 4 Acceptance Mask High Register */
+#define                       CAN1_AM04H  0xffc03324   /* CAN Controller 1 Mailbox 4 Acceptance Mask Low Register */
+#define                       CAN1_AM05L  0xffc03328   /* CAN Controller 1 Mailbox 5 Acceptance Mask High Register */
+#define                       CAN1_AM05H  0xffc0332c   /* CAN Controller 1 Mailbox 5 Acceptance Mask Low Register */
+#define                       CAN1_AM06L  0xffc03330   /* CAN Controller 1 Mailbox 6 Acceptance Mask High Register */
+#define                       CAN1_AM06H  0xffc03334   /* CAN Controller 1 Mailbox 6 Acceptance Mask Low Register */
+#define                       CAN1_AM07L  0xffc03338   /* CAN Controller 1 Mailbox 7 Acceptance Mask High Register */
+#define                       CAN1_AM07H  0xffc0333c   /* CAN Controller 1 Mailbox 7 Acceptance Mask Low Register */
+#define                       CAN1_AM08L  0xffc03340   /* CAN Controller 1 Mailbox 8 Acceptance Mask High Register */
+#define                       CAN1_AM08H  0xffc03344   /* CAN Controller 1 Mailbox 8 Acceptance Mask Low Register */
+#define                       CAN1_AM09L  0xffc03348   /* CAN Controller 1 Mailbox 9 Acceptance Mask High Register */
+#define                       CAN1_AM09H  0xffc0334c   /* CAN Controller 1 Mailbox 9 Acceptance Mask Low Register */
+#define                       CAN1_AM10L  0xffc03350   /* CAN Controller 1 Mailbox 10 Acceptance Mask High Register */
+#define                       CAN1_AM10H  0xffc03354   /* CAN Controller 1 Mailbox 10 Acceptance Mask Low Register */
+#define                       CAN1_AM11L  0xffc03358   /* CAN Controller 1 Mailbox 11 Acceptance Mask High Register */
+#define                       CAN1_AM11H  0xffc0335c   /* CAN Controller 1 Mailbox 11 Acceptance Mask Low Register */
+#define                       CAN1_AM12L  0xffc03360   /* CAN Controller 1 Mailbox 12 Acceptance Mask High Register */
+#define                       CAN1_AM12H  0xffc03364   /* CAN Controller 1 Mailbox 12 Acceptance Mask Low Register */
+#define                       CAN1_AM13L  0xffc03368   /* CAN Controller 1 Mailbox 13 Acceptance Mask High Register */
+#define                       CAN1_AM13H  0xffc0336c   /* CAN Controller 1 Mailbox 13 Acceptance Mask Low Register */
+#define                       CAN1_AM14L  0xffc03370   /* CAN Controller 1 Mailbox 14 Acceptance Mask High Register */
+#define                       CAN1_AM14H  0xffc03374   /* CAN Controller 1 Mailbox 14 Acceptance Mask Low Register */
+#define                       CAN1_AM15L  0xffc03378   /* CAN Controller 1 Mailbox 15 Acceptance Mask High Register */
+#define                       CAN1_AM15H  0xffc0337c   /* CAN Controller 1 Mailbox 15 Acceptance Mask Low Register */
+
+/* CAN Controller 1 Mailbox Acceptance Registers */
+
+#define                       CAN1_AM16L  0xffc03380   /* CAN Controller 1 Mailbox 16 Acceptance Mask High Register */
+#define                       CAN1_AM16H  0xffc03384   /* CAN Controller 1 Mailbox 16 Acceptance Mask Low Register */
+#define                       CAN1_AM17L  0xffc03388   /* CAN Controller 1 Mailbox 17 Acceptance Mask High Register */
+#define                       CAN1_AM17H  0xffc0338c   /* CAN Controller 1 Mailbox 17 Acceptance Mask Low Register */
+#define                       CAN1_AM18L  0xffc03390   /* CAN Controller 1 Mailbox 18 Acceptance Mask High Register */
+#define                       CAN1_AM18H  0xffc03394   /* CAN Controller 1 Mailbox 18 Acceptance Mask Low Register */
+#define                       CAN1_AM19L  0xffc03398   /* CAN Controller 1 Mailbox 19 Acceptance Mask High Register */
+#define                       CAN1_AM19H  0xffc0339c   /* CAN Controller 1 Mailbox 19 Acceptance Mask Low Register */
+#define                       CAN1_AM20L  0xffc033a0   /* CAN Controller 1 Mailbox 20 Acceptance Mask High Register */
+#define                       CAN1_AM20H  0xffc033a4   /* CAN Controller 1 Mailbox 20 Acceptance Mask Low Register */
+#define                       CAN1_AM21L  0xffc033a8   /* CAN Controller 1 Mailbox 21 Acceptance Mask High Register */
+#define                       CAN1_AM21H  0xffc033ac   /* CAN Controller 1 Mailbox 21 Acceptance Mask Low Register */
+#define                       CAN1_AM22L  0xffc033b0   /* CAN Controller 1 Mailbox 22 Acceptance Mask High Register */
+#define                       CAN1_AM22H  0xffc033b4   /* CAN Controller 1 Mailbox 22 Acceptance Mask Low Register */
+#define                       CAN1_AM23L  0xffc033b8   /* CAN Controller 1 Mailbox 23 Acceptance Mask High Register */
+#define                       CAN1_AM23H  0xffc033bc   /* CAN Controller 1 Mailbox 23 Acceptance Mask Low Register */
+#define                       CAN1_AM24L  0xffc033c0   /* CAN Controller 1 Mailbox 24 Acceptance Mask High Register */
+#define                       CAN1_AM24H  0xffc033c4   /* CAN Controller 1 Mailbox 24 Acceptance Mask Low Register */
+#define                       CAN1_AM25L  0xffc033c8   /* CAN Controller 1 Mailbox 25 Acceptance Mask High Register */
+#define                       CAN1_AM25H  0xffc033cc   /* CAN Controller 1 Mailbox 25 Acceptance Mask Low Register */
+#define                       CAN1_AM26L  0xffc033d0   /* CAN Controller 1 Mailbox 26 Acceptance Mask High Register */
+#define                       CAN1_AM26H  0xffc033d4   /* CAN Controller 1 Mailbox 26 Acceptance Mask Low Register */
+#define                       CAN1_AM27L  0xffc033d8   /* CAN Controller 1 Mailbox 27 Acceptance Mask High Register */
+#define                       CAN1_AM27H  0xffc033dc   /* CAN Controller 1 Mailbox 27 Acceptance Mask Low Register */
+#define                       CAN1_AM28L  0xffc033e0   /* CAN Controller 1 Mailbox 28 Acceptance Mask High Register */
+#define                       CAN1_AM28H  0xffc033e4   /* CAN Controller 1 Mailbox 28 Acceptance Mask Low Register */
+#define                       CAN1_AM29L  0xffc033e8   /* CAN Controller 1 Mailbox 29 Acceptance Mask High Register */
+#define                       CAN1_AM29H  0xffc033ec   /* CAN Controller 1 Mailbox 29 Acceptance Mask Low Register */
+#define                       CAN1_AM30L  0xffc033f0   /* CAN Controller 1 Mailbox 30 Acceptance Mask High Register */
+#define                       CAN1_AM30H  0xffc033f4   /* CAN Controller 1 Mailbox 30 Acceptance Mask Low Register */
+#define                       CAN1_AM31L  0xffc033f8   /* CAN Controller 1 Mailbox 31 Acceptance Mask High Register */
+#define                       CAN1_AM31H  0xffc033fc   /* CAN Controller 1 Mailbox 31 Acceptance Mask Low Register */
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define                  CAN1_MB00_DATA0  0xffc03400   /* CAN Controller 1 Mailbox 0 Data 0 Register */
+#define                  CAN1_MB00_DATA1  0xffc03404   /* CAN Controller 1 Mailbox 0 Data 1 Register */
+#define                  CAN1_MB00_DATA2  0xffc03408   /* CAN Controller 1 Mailbox 0 Data 2 Register */
+#define                  CAN1_MB00_DATA3  0xffc0340c   /* CAN Controller 1 Mailbox 0 Data 3 Register */
+#define                 CAN1_MB00_LENGTH  0xffc03410   /* CAN Controller 1 Mailbox 0 Length Register */
+#define              CAN1_MB00_TIMESTAMP  0xffc03414   /* CAN Controller 1 Mailbox 0 Timestamp Register */
+#define                    CAN1_MB00_ID0  0xffc03418   /* CAN Controller 1 Mailbox 0 ID0 Register */
+#define                    CAN1_MB00_ID1  0xffc0341c   /* CAN Controller 1 Mailbox 0 ID1 Register */
+#define                  CAN1_MB01_DATA0  0xffc03420   /* CAN Controller 1 Mailbox 1 Data 0 Register */
+#define                  CAN1_MB01_DATA1  0xffc03424   /* CAN Controller 1 Mailbox 1 Data 1 Register */
+#define                  CAN1_MB01_DATA2  0xffc03428   /* CAN Controller 1 Mailbox 1 Data 2 Register */
+#define                  CAN1_MB01_DATA3  0xffc0342c   /* CAN Controller 1 Mailbox 1 Data 3 Register */
+#define                 CAN1_MB01_LENGTH  0xffc03430   /* CAN Controller 1 Mailbox 1 Length Register */
+#define              CAN1_MB01_TIMESTAMP  0xffc03434   /* CAN Controller 1 Mailbox 1 Timestamp Register */
+#define                    CAN1_MB01_ID0  0xffc03438   /* CAN Controller 1 Mailbox 1 ID0 Register */
+#define                    CAN1_MB01_ID1  0xffc0343c   /* CAN Controller 1 Mailbox 1 ID1 Register */
+#define                  CAN1_MB02_DATA0  0xffc03440   /* CAN Controller 1 Mailbox 2 Data 0 Register */
+#define                  CAN1_MB02_DATA1  0xffc03444   /* CAN Controller 1 Mailbox 2 Data 1 Register */
+#define                  CAN1_MB02_DATA2  0xffc03448   /* CAN Controller 1 Mailbox 2 Data 2 Register */
+#define                  CAN1_MB02_DATA3  0xffc0344c   /* CAN Controller 1 Mailbox 2 Data 3 Register */
+#define                 CAN1_MB02_LENGTH  0xffc03450   /* CAN Controller 1 Mailbox 2 Length Register */
+#define              CAN1_MB02_TIMESTAMP  0xffc03454   /* CAN Controller 1 Mailbox 2 Timestamp Register */
+#define                    CAN1_MB02_ID0  0xffc03458   /* CAN Controller 1 Mailbox 2 ID0 Register */
+#define                    CAN1_MB02_ID1  0xffc0345c   /* CAN Controller 1 Mailbox 2 ID1 Register */
+#define                  CAN1_MB03_DATA0  0xffc03460   /* CAN Controller 1 Mailbox 3 Data 0 Register */
+#define                  CAN1_MB03_DATA1  0xffc03464   /* CAN Controller 1 Mailbox 3 Data 1 Register */
+#define                  CAN1_MB03_DATA2  0xffc03468   /* CAN Controller 1 Mailbox 3 Data 2 Register */
+#define                  CAN1_MB03_DATA3  0xffc0346c   /* CAN Controller 1 Mailbox 3 Data 3 Register */
+#define                 CAN1_MB03_LENGTH  0xffc03470   /* CAN Controller 1 Mailbox 3 Length Register */
+#define              CAN1_MB03_TIMESTAMP  0xffc03474   /* CAN Controller 1 Mailbox 3 Timestamp Register */
+#define                    CAN1_MB03_ID0  0xffc03478   /* CAN Controller 1 Mailbox 3 ID0 Register */
+#define                    CAN1_MB03_ID1  0xffc0347c   /* CAN Controller 1 Mailbox 3 ID1 Register */
+#define                  CAN1_MB04_DATA0  0xffc03480   /* CAN Controller 1 Mailbox 4 Data 0 Register */
+#define                  CAN1_MB04_DATA1  0xffc03484   /* CAN Controller 1 Mailbox 4 Data 1 Register */
+#define                  CAN1_MB04_DATA2  0xffc03488   /* CAN Controller 1 Mailbox 4 Data 2 Register */
+#define                  CAN1_MB04_DATA3  0xffc0348c   /* CAN Controller 1 Mailbox 4 Data 3 Register */
+#define                 CAN1_MB04_LENGTH  0xffc03490   /* CAN Controller 1 Mailbox 4 Length Register */
+#define              CAN1_MB04_TIMESTAMP  0xffc03494   /* CAN Controller 1 Mailbox 4 Timestamp Register */
+#define                    CAN1_MB04_ID0  0xffc03498   /* CAN Controller 1 Mailbox 4 ID0 Register */
+#define                    CAN1_MB04_ID1  0xffc0349c   /* CAN Controller 1 Mailbox 4 ID1 Register */
+#define                  CAN1_MB05_DATA0  0xffc034a0   /* CAN Controller 1 Mailbox 5 Data 0 Register */
+#define                  CAN1_MB05_DATA1  0xffc034a4   /* CAN Controller 1 Mailbox 5 Data 1 Register */
+#define                  CAN1_MB05_DATA2  0xffc034a8   /* CAN Controller 1 Mailbox 5 Data 2 Register */
+#define                  CAN1_MB05_DATA3  0xffc034ac   /* CAN Controller 1 Mailbox 5 Data 3 Register */
+#define                 CAN1_MB05_LENGTH  0xffc034b0   /* CAN Controller 1 Mailbox 5 Length Register */
+#define              CAN1_MB05_TIMESTAMP  0xffc034b4   /* CAN Controller 1 Mailbox 5 Timestamp Register */
+#define                    CAN1_MB05_ID0  0xffc034b8   /* CAN Controller 1 Mailbox 5 ID0 Register */
+#define                    CAN1_MB05_ID1  0xffc034bc   /* CAN Controller 1 Mailbox 5 ID1 Register */
+#define                  CAN1_MB06_DATA0  0xffc034c0   /* CAN Controller 1 Mailbox 6 Data 0 Register */
+#define                  CAN1_MB06_DATA1  0xffc034c4   /* CAN Controller 1 Mailbox 6 Data 1 Register */
+#define                  CAN1_MB06_DATA2  0xffc034c8   /* CAN Controller 1 Mailbox 6 Data 2 Register */
+#define                  CAN1_MB06_DATA3  0xffc034cc   /* CAN Controller 1 Mailbox 6 Data 3 Register */
+#define                 CAN1_MB06_LENGTH  0xffc034d0   /* CAN Controller 1 Mailbox 6 Length Register */
+#define              CAN1_MB06_TIMESTAMP  0xffc034d4   /* CAN Controller 1 Mailbox 6 Timestamp Register */
+#define                    CAN1_MB06_ID0  0xffc034d8   /* CAN Controller 1 Mailbox 6 ID0 Register */
+#define                    CAN1_MB06_ID1  0xffc034dc   /* CAN Controller 1 Mailbox 6 ID1 Register */
+#define                  CAN1_MB07_DATA0  0xffc034e0   /* CAN Controller 1 Mailbox 7 Data 0 Register */
+#define                  CAN1_MB07_DATA1  0xffc034e4   /* CAN Controller 1 Mailbox 7 Data 1 Register */
+#define                  CAN1_MB07_DATA2  0xffc034e8   /* CAN Controller 1 Mailbox 7 Data 2 Register */
+#define                  CAN1_MB07_DATA3  0xffc034ec   /* CAN Controller 1 Mailbox 7 Data 3 Register */
+#define                 CAN1_MB07_LENGTH  0xffc034f0   /* CAN Controller 1 Mailbox 7 Length Register */
+#define              CAN1_MB07_TIMESTAMP  0xffc034f4   /* CAN Controller 1 Mailbox 7 Timestamp Register */
+#define                    CAN1_MB07_ID0  0xffc034f8   /* CAN Controller 1 Mailbox 7 ID0 Register */
+#define                    CAN1_MB07_ID1  0xffc034fc   /* CAN Controller 1 Mailbox 7 ID1 Register */
+#define                  CAN1_MB08_DATA0  0xffc03500   /* CAN Controller 1 Mailbox 8 Data 0 Register */
+#define                  CAN1_MB08_DATA1  0xffc03504   /* CAN Controller 1 Mailbox 8 Data 1 Register */
+#define                  CAN1_MB08_DATA2  0xffc03508   /* CAN Controller 1 Mailbox 8 Data 2 Register */
+#define                  CAN1_MB08_DATA3  0xffc0350c   /* CAN Controller 1 Mailbox 8 Data 3 Register */
+#define                 CAN1_MB08_LENGTH  0xffc03510   /* CAN Controller 1 Mailbox 8 Length Register */
+#define              CAN1_MB08_TIMESTAMP  0xffc03514   /* CAN Controller 1 Mailbox 8 Timestamp Register */
+#define                    CAN1_MB08_ID0  0xffc03518   /* CAN Controller 1 Mailbox 8 ID0 Register */
+#define                    CAN1_MB08_ID1  0xffc0351c   /* CAN Controller 1 Mailbox 8 ID1 Register */
+#define                  CAN1_MB09_DATA0  0xffc03520   /* CAN Controller 1 Mailbox 9 Data 0 Register */
+#define                  CAN1_MB09_DATA1  0xffc03524   /* CAN Controller 1 Mailbox 9 Data 1 Register */
+#define                  CAN1_MB09_DATA2  0xffc03528   /* CAN Controller 1 Mailbox 9 Data 2 Register */
+#define                  CAN1_MB09_DATA3  0xffc0352c   /* CAN Controller 1 Mailbox 9 Data 3 Register */
+#define                 CAN1_MB09_LENGTH  0xffc03530   /* CAN Controller 1 Mailbox 9 Length Register */
+#define              CAN1_MB09_TIMESTAMP  0xffc03534   /* CAN Controller 1 Mailbox 9 Timestamp Register */
+#define                    CAN1_MB09_ID0  0xffc03538   /* CAN Controller 1 Mailbox 9 ID0 Register */
+#define                    CAN1_MB09_ID1  0xffc0353c   /* CAN Controller 1 Mailbox 9 ID1 Register */
+#define                  CAN1_MB10_DATA0  0xffc03540   /* CAN Controller 1 Mailbox 10 Data 0 Register */
+#define                  CAN1_MB10_DATA1  0xffc03544   /* CAN Controller 1 Mailbox 10 Data 1 Register */
+#define                  CAN1_MB10_DATA2  0xffc03548   /* CAN Controller 1 Mailbox 10 Data 2 Register */
+#define                  CAN1_MB10_DATA3  0xffc0354c   /* CAN Controller 1 Mailbox 10 Data 3 Register */
+#define                 CAN1_MB10_LENGTH  0xffc03550   /* CAN Controller 1 Mailbox 10 Length Register */
+#define              CAN1_MB10_TIMESTAMP  0xffc03554   /* CAN Controller 1 Mailbox 10 Timestamp Register */
+#define                    CAN1_MB10_ID0  0xffc03558   /* CAN Controller 1 Mailbox 10 ID0 Register */
+#define                    CAN1_MB10_ID1  0xffc0355c   /* CAN Controller 1 Mailbox 10 ID1 Register */
+#define                  CAN1_MB11_DATA0  0xffc03560   /* CAN Controller 1 Mailbox 11 Data 0 Register */
+#define                  CAN1_MB11_DATA1  0xffc03564   /* CAN Controller 1 Mailbox 11 Data 1 Register */
+#define                  CAN1_MB11_DATA2  0xffc03568   /* CAN Controller 1 Mailbox 11 Data 2 Register */
+#define                  CAN1_MB11_DATA3  0xffc0356c   /* CAN Controller 1 Mailbox 11 Data 3 Register */
+#define                 CAN1_MB11_LENGTH  0xffc03570   /* CAN Controller 1 Mailbox 11 Length Register */
+#define              CAN1_MB11_TIMESTAMP  0xffc03574   /* CAN Controller 1 Mailbox 11 Timestamp Register */
+#define                    CAN1_MB11_ID0  0xffc03578   /* CAN Controller 1 Mailbox 11 ID0 Register */
+#define                    CAN1_MB11_ID1  0xffc0357c   /* CAN Controller 1 Mailbox 11 ID1 Register */
+#define                  CAN1_MB12_DATA0  0xffc03580   /* CAN Controller 1 Mailbox 12 Data 0 Register */
+#define                  CAN1_MB12_DATA1  0xffc03584   /* CAN Controller 1 Mailbox 12 Data 1 Register */
+#define                  CAN1_MB12_DATA2  0xffc03588   /* CAN Controller 1 Mailbox 12 Data 2 Register */
+#define                  CAN1_MB12_DATA3  0xffc0358c   /* CAN Controller 1 Mailbox 12 Data 3 Register */
+#define                 CAN1_MB12_LENGTH  0xffc03590   /* CAN Controller 1 Mailbox 12 Length Register */
+#define              CAN1_MB12_TIMESTAMP  0xffc03594   /* CAN Controller 1 Mailbox 12 Timestamp Register */
+#define                    CAN1_MB12_ID0  0xffc03598   /* CAN Controller 1 Mailbox 12 ID0 Register */
+#define                    CAN1_MB12_ID1  0xffc0359c   /* CAN Controller 1 Mailbox 12 ID1 Register */
+#define                  CAN1_MB13_DATA0  0xffc035a0   /* CAN Controller 1 Mailbox 13 Data 0 Register */
+#define                  CAN1_MB13_DATA1  0xffc035a4   /* CAN Controller 1 Mailbox 13 Data 1 Register */
+#define                  CAN1_MB13_DATA2  0xffc035a8   /* CAN Controller 1 Mailbox 13 Data 2 Register */
+#define                  CAN1_MB13_DATA3  0xffc035ac   /* CAN Controller 1 Mailbox 13 Data 3 Register */
+#define                 CAN1_MB13_LENGTH  0xffc035b0   /* CAN Controller 1 Mailbox 13 Length Register */
+#define              CAN1_MB13_TIMESTAMP  0xffc035b4   /* CAN Controller 1 Mailbox 13 Timestamp Register */
+#define                    CAN1_MB13_ID0  0xffc035b8   /* CAN Controller 1 Mailbox 13 ID0 Register */
+#define                    CAN1_MB13_ID1  0xffc035bc   /* CAN Controller 1 Mailbox 13 ID1 Register */
+#define                  CAN1_MB14_DATA0  0xffc035c0   /* CAN Controller 1 Mailbox 14 Data 0 Register */
+#define                  CAN1_MB14_DATA1  0xffc035c4   /* CAN Controller 1 Mailbox 14 Data 1 Register */
+#define                  CAN1_MB14_DATA2  0xffc035c8   /* CAN Controller 1 Mailbox 14 Data 2 Register */
+#define                  CAN1_MB14_DATA3  0xffc035cc   /* CAN Controller 1 Mailbox 14 Data 3 Register */
+#define                 CAN1_MB14_LENGTH  0xffc035d0   /* CAN Controller 1 Mailbox 14 Length Register */
+#define              CAN1_MB14_TIMESTAMP  0xffc035d4   /* CAN Controller 1 Mailbox 14 Timestamp Register */
+#define                    CAN1_MB14_ID0  0xffc035d8   /* CAN Controller 1 Mailbox 14 ID0 Register */
+#define                    CAN1_MB14_ID1  0xffc035dc   /* CAN Controller 1 Mailbox 14 ID1 Register */
+#define                  CAN1_MB15_DATA0  0xffc035e0   /* CAN Controller 1 Mailbox 15 Data 0 Register */
+#define                  CAN1_MB15_DATA1  0xffc035e4   /* CAN Controller 1 Mailbox 15 Data 1 Register */
+#define                  CAN1_MB15_DATA2  0xffc035e8   /* CAN Controller 1 Mailbox 15 Data 2 Register */
+#define                  CAN1_MB15_DATA3  0xffc035ec   /* CAN Controller 1 Mailbox 15 Data 3 Register */
+#define                 CAN1_MB15_LENGTH  0xffc035f0   /* CAN Controller 1 Mailbox 15 Length Register */
+#define              CAN1_MB15_TIMESTAMP  0xffc035f4   /* CAN Controller 1 Mailbox 15 Timestamp Register */
+#define                    CAN1_MB15_ID0  0xffc035f8   /* CAN Controller 1 Mailbox 15 ID0 Register */
+#define                    CAN1_MB15_ID1  0xffc035fc   /* CAN Controller 1 Mailbox 15 ID1 Register */
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define                  CAN1_MB16_DATA0  0xffc03600   /* CAN Controller 1 Mailbox 16 Data 0 Register */
+#define                  CAN1_MB16_DATA1  0xffc03604   /* CAN Controller 1 Mailbox 16 Data 1 Register */
+#define                  CAN1_MB16_DATA2  0xffc03608   /* CAN Controller 1 Mailbox 16 Data 2 Register */
+#define                  CAN1_MB16_DATA3  0xffc0360c   /* CAN Controller 1 Mailbox 16 Data 3 Register */
+#define                 CAN1_MB16_LENGTH  0xffc03610   /* CAN Controller 1 Mailbox 16 Length Register */
+#define              CAN1_MB16_TIMESTAMP  0xffc03614   /* CAN Controller 1 Mailbox 16 Timestamp Register */
+#define                    CAN1_MB16_ID0  0xffc03618   /* CAN Controller 1 Mailbox 16 ID0 Register */
+#define                    CAN1_MB16_ID1  0xffc0361c   /* CAN Controller 1 Mailbox 16 ID1 Register */
+#define                  CAN1_MB17_DATA0  0xffc03620   /* CAN Controller 1 Mailbox 17 Data 0 Register */
+#define                  CAN1_MB17_DATA1  0xffc03624   /* CAN Controller 1 Mailbox 17 Data 1 Register */
+#define                  CAN1_MB17_DATA2  0xffc03628   /* CAN Controller 1 Mailbox 17 Data 2 Register */
+#define                  CAN1_MB17_DATA3  0xffc0362c   /* CAN Controller 1 Mailbox 17 Data 3 Register */
+#define                 CAN1_MB17_LENGTH  0xffc03630   /* CAN Controller 1 Mailbox 17 Length Register */
+#define              CAN1_MB17_TIMESTAMP  0xffc03634   /* CAN Controller 1 Mailbox 17 Timestamp Register */
+#define                    CAN1_MB17_ID0  0xffc03638   /* CAN Controller 1 Mailbox 17 ID0 Register */
+#define                    CAN1_MB17_ID1  0xffc0363c   /* CAN Controller 1 Mailbox 17 ID1 Register */
+#define                  CAN1_MB18_DATA0  0xffc03640   /* CAN Controller 1 Mailbox 18 Data 0 Register */
+#define                  CAN1_MB18_DATA1  0xffc03644   /* CAN Controller 1 Mailbox 18 Data 1 Register */
+#define                  CAN1_MB18_DATA2  0xffc03648   /* CAN Controller 1 Mailbox 18 Data 2 Register */
+#define                  CAN1_MB18_DATA3  0xffc0364c   /* CAN Controller 1 Mailbox 18 Data 3 Register */
+#define                 CAN1_MB18_LENGTH  0xffc03650   /* CAN Controller 1 Mailbox 18 Length Register */
+#define              CAN1_MB18_TIMESTAMP  0xffc03654   /* CAN Controller 1 Mailbox 18 Timestamp Register */
+#define                    CAN1_MB18_ID0  0xffc03658   /* CAN Controller 1 Mailbox 18 ID0 Register */
+#define                    CAN1_MB18_ID1  0xffc0365c   /* CAN Controller 1 Mailbox 18 ID1 Register */
+#define                  CAN1_MB19_DATA0  0xffc03660   /* CAN Controller 1 Mailbox 19 Data 0 Register */
+#define                  CAN1_MB19_DATA1  0xffc03664   /* CAN Controller 1 Mailbox 19 Data 1 Register */
+#define                  CAN1_MB19_DATA2  0xffc03668   /* CAN Controller 1 Mailbox 19 Data 2 Register */
+#define                  CAN1_MB19_DATA3  0xffc0366c   /* CAN Controller 1 Mailbox 19 Data 3 Register */
+#define                 CAN1_MB19_LENGTH  0xffc03670   /* CAN Controller 1 Mailbox 19 Length Register */
+#define              CAN1_MB19_TIMESTAMP  0xffc03674   /* CAN Controller 1 Mailbox 19 Timestamp Register */
+#define                    CAN1_MB19_ID0  0xffc03678   /* CAN Controller 1 Mailbox 19 ID0 Register */
+#define                    CAN1_MB19_ID1  0xffc0367c   /* CAN Controller 1 Mailbox 19 ID1 Register */
+#define                  CAN1_MB20_DATA0  0xffc03680   /* CAN Controller 1 Mailbox 20 Data 0 Register */
+#define                  CAN1_MB20_DATA1  0xffc03684   /* CAN Controller 1 Mailbox 20 Data 1 Register */
+#define                  CAN1_MB20_DATA2  0xffc03688   /* CAN Controller 1 Mailbox 20 Data 2 Register */
+#define                  CAN1_MB20_DATA3  0xffc0368c   /* CAN Controller 1 Mailbox 20 Data 3 Register */
+#define                 CAN1_MB20_LENGTH  0xffc03690   /* CAN Controller 1 Mailbox 20 Length Register */
+#define              CAN1_MB20_TIMESTAMP  0xffc03694   /* CAN Controller 1 Mailbox 20 Timestamp Register */
+#define                    CAN1_MB20_ID0  0xffc03698   /* CAN Controller 1 Mailbox 20 ID0 Register */
+#define                    CAN1_MB20_ID1  0xffc0369c   /* CAN Controller 1 Mailbox 20 ID1 Register */
+#define                  CAN1_MB21_DATA0  0xffc036a0   /* CAN Controller 1 Mailbox 21 Data 0 Register */
+#define                  CAN1_MB21_DATA1  0xffc036a4   /* CAN Controller 1 Mailbox 21 Data 1 Register */
+#define                  CAN1_MB21_DATA2  0xffc036a8   /* CAN Controller 1 Mailbox 21 Data 2 Register */
+#define                  CAN1_MB21_DATA3  0xffc036ac   /* CAN Controller 1 Mailbox 21 Data 3 Register */
+#define                 CAN1_MB21_LENGTH  0xffc036b0   /* CAN Controller 1 Mailbox 21 Length Register */
+#define              CAN1_MB21_TIMESTAMP  0xffc036b4   /* CAN Controller 1 Mailbox 21 Timestamp Register */
+#define                    CAN1_MB21_ID0  0xffc036b8   /* CAN Controller 1 Mailbox 21 ID0 Register */
+#define                    CAN1_MB21_ID1  0xffc036bc   /* CAN Controller 1 Mailbox 21 ID1 Register */
+#define                  CAN1_MB22_DATA0  0xffc036c0   /* CAN Controller 1 Mailbox 22 Data 0 Register */
+#define                  CAN1_MB22_DATA1  0xffc036c4   /* CAN Controller 1 Mailbox 22 Data 1 Register */
+#define                  CAN1_MB22_DATA2  0xffc036c8   /* CAN Controller 1 Mailbox 22 Data 2 Register */
+#define                  CAN1_MB22_DATA3  0xffc036cc   /* CAN Controller 1 Mailbox 22 Data 3 Register */
+#define                 CAN1_MB22_LENGTH  0xffc036d0   /* CAN Controller 1 Mailbox 22 Length Register */
+#define              CAN1_MB22_TIMESTAMP  0xffc036d4   /* CAN Controller 1 Mailbox 22 Timestamp Register */
+#define                    CAN1_MB22_ID0  0xffc036d8   /* CAN Controller 1 Mailbox 22 ID0 Register */
+#define                    CAN1_MB22_ID1  0xffc036dc   /* CAN Controller 1 Mailbox 22 ID1 Register */
+#define                  CAN1_MB23_DATA0  0xffc036e0   /* CAN Controller 1 Mailbox 23 Data 0 Register */
+#define                  CAN1_MB23_DATA1  0xffc036e4   /* CAN Controller 1 Mailbox 23 Data 1 Register */
+#define                  CAN1_MB23_DATA2  0xffc036e8   /* CAN Controller 1 Mailbox 23 Data 2 Register */
+#define                  CAN1_MB23_DATA3  0xffc036ec   /* CAN Controller 1 Mailbox 23 Data 3 Register */
+#define                 CAN1_MB23_LENGTH  0xffc036f0   /* CAN Controller 1 Mailbox 23 Length Register */
+#define              CAN1_MB23_TIMESTAMP  0xffc036f4   /* CAN Controller 1 Mailbox 23 Timestamp Register */
+#define                    CAN1_MB23_ID0  0xffc036f8   /* CAN Controller 1 Mailbox 23 ID0 Register */
+#define                    CAN1_MB23_ID1  0xffc036fc   /* CAN Controller 1 Mailbox 23 ID1 Register */
+#define                  CAN1_MB24_DATA0  0xffc03700   /* CAN Controller 1 Mailbox 24 Data 0 Register */
+#define                  CAN1_MB24_DATA1  0xffc03704   /* CAN Controller 1 Mailbox 24 Data 1 Register */
+#define                  CAN1_MB24_DATA2  0xffc03708   /* CAN Controller 1 Mailbox 24 Data 2 Register */
+#define                  CAN1_MB24_DATA3  0xffc0370c   /* CAN Controller 1 Mailbox 24 Data 3 Register */
+#define                 CAN1_MB24_LENGTH  0xffc03710   /* CAN Controller 1 Mailbox 24 Length Register */
+#define              CAN1_MB24_TIMESTAMP  0xffc03714   /* CAN Controller 1 Mailbox 24 Timestamp Register */
+#define                    CAN1_MB24_ID0  0xffc03718   /* CAN Controller 1 Mailbox 24 ID0 Register */
+#define                    CAN1_MB24_ID1  0xffc0371c   /* CAN Controller 1 Mailbox 24 ID1 Register */
+#define                  CAN1_MB25_DATA0  0xffc03720   /* CAN Controller 1 Mailbox 25 Data 0 Register */
+#define                  CAN1_MB25_DATA1  0xffc03724   /* CAN Controller 1 Mailbox 25 Data 1 Register */
+#define                  CAN1_MB25_DATA2  0xffc03728   /* CAN Controller 1 Mailbox 25 Data 2 Register */
+#define                  CAN1_MB25_DATA3  0xffc0372c   /* CAN Controller 1 Mailbox 25 Data 3 Register */
+#define                 CAN1_MB25_LENGTH  0xffc03730   /* CAN Controller 1 Mailbox 25 Length Register */
+#define              CAN1_MB25_TIMESTAMP  0xffc03734   /* CAN Controller 1 Mailbox 25 Timestamp Register */
+#define                    CAN1_MB25_ID0  0xffc03738   /* CAN Controller 1 Mailbox 25 ID0 Register */
+#define                    CAN1_MB25_ID1  0xffc0373c   /* CAN Controller 1 Mailbox 25 ID1 Register */
+#define                  CAN1_MB26_DATA0  0xffc03740   /* CAN Controller 1 Mailbox 26 Data 0 Register */
+#define                  CAN1_MB26_DATA1  0xffc03744   /* CAN Controller 1 Mailbox 26 Data 1 Register */
+#define                  CAN1_MB26_DATA2  0xffc03748   /* CAN Controller 1 Mailbox 26 Data 2 Register */
+#define                  CAN1_MB26_DATA3  0xffc0374c   /* CAN Controller 1 Mailbox 26 Data 3 Register */
+#define                 CAN1_MB26_LENGTH  0xffc03750   /* CAN Controller 1 Mailbox 26 Length Register */
+#define              CAN1_MB26_TIMESTAMP  0xffc03754   /* CAN Controller 1 Mailbox 26 Timestamp Register */
+#define                    CAN1_MB26_ID0  0xffc03758   /* CAN Controller 1 Mailbox 26 ID0 Register */
+#define                    CAN1_MB26_ID1  0xffc0375c   /* CAN Controller 1 Mailbox 26 ID1 Register */
+#define                  CAN1_MB27_DATA0  0xffc03760   /* CAN Controller 1 Mailbox 27 Data 0 Register */
+#define                  CAN1_MB27_DATA1  0xffc03764   /* CAN Controller 1 Mailbox 27 Data 1 Register */
+#define                  CAN1_MB27_DATA2  0xffc03768   /* CAN Controller 1 Mailbox 27 Data 2 Register */
+#define                  CAN1_MB27_DATA3  0xffc0376c   /* CAN Controller 1 Mailbox 27 Data 3 Register */
+#define                 CAN1_MB27_LENGTH  0xffc03770   /* CAN Controller 1 Mailbox 27 Length Register */
+#define              CAN1_MB27_TIMESTAMP  0xffc03774   /* CAN Controller 1 Mailbox 27 Timestamp Register */
+#define                    CAN1_MB27_ID0  0xffc03778   /* CAN Controller 1 Mailbox 27 ID0 Register */
+#define                    CAN1_MB27_ID1  0xffc0377c   /* CAN Controller 1 Mailbox 27 ID1 Register */
+#define                  CAN1_MB28_DATA0  0xffc03780   /* CAN Controller 1 Mailbox 28 Data 0 Register */
+#define                  CAN1_MB28_DATA1  0xffc03784   /* CAN Controller 1 Mailbox 28 Data 1 Register */
+#define                  CAN1_MB28_DATA2  0xffc03788   /* CAN Controller 1 Mailbox 28 Data 2 Register */
+#define                  CAN1_MB28_DATA3  0xffc0378c   /* CAN Controller 1 Mailbox 28 Data 3 Register */
+#define                 CAN1_MB28_LENGTH  0xffc03790   /* CAN Controller 1 Mailbox 28 Length Register */
+#define              CAN1_MB28_TIMESTAMP  0xffc03794   /* CAN Controller 1 Mailbox 28 Timestamp Register */
+#define                    CAN1_MB28_ID0  0xffc03798   /* CAN Controller 1 Mailbox 28 ID0 Register */
+#define                    CAN1_MB28_ID1  0xffc0379c   /* CAN Controller 1 Mailbox 28 ID1 Register */
+#define                  CAN1_MB29_DATA0  0xffc037a0   /* CAN Controller 1 Mailbox 29 Data 0 Register */
+#define                  CAN1_MB29_DATA1  0xffc037a4   /* CAN Controller 1 Mailbox 29 Data 1 Register */
+#define                  CAN1_MB29_DATA2  0xffc037a8   /* CAN Controller 1 Mailbox 29 Data 2 Register */
+#define                  CAN1_MB29_DATA3  0xffc037ac   /* CAN Controller 1 Mailbox 29 Data 3 Register */
+#define                 CAN1_MB29_LENGTH  0xffc037b0   /* CAN Controller 1 Mailbox 29 Length Register */
+#define              CAN1_MB29_TIMESTAMP  0xffc037b4   /* CAN Controller 1 Mailbox 29 Timestamp Register */
+#define                    CAN1_MB29_ID0  0xffc037b8   /* CAN Controller 1 Mailbox 29 ID0 Register */
+#define                    CAN1_MB29_ID1  0xffc037bc   /* CAN Controller 1 Mailbox 29 ID1 Register */
+#define                  CAN1_MB30_DATA0  0xffc037c0   /* CAN Controller 1 Mailbox 30 Data 0 Register */
+#define                  CAN1_MB30_DATA1  0xffc037c4   /* CAN Controller 1 Mailbox 30 Data 1 Register */
+#define                  CAN1_MB30_DATA2  0xffc037c8   /* CAN Controller 1 Mailbox 30 Data 2 Register */
+#define                  CAN1_MB30_DATA3  0xffc037cc   /* CAN Controller 1 Mailbox 30 Data 3 Register */
+#define                 CAN1_MB30_LENGTH  0xffc037d0   /* CAN Controller 1 Mailbox 30 Length Register */
+#define              CAN1_MB30_TIMESTAMP  0xffc037d4   /* CAN Controller 1 Mailbox 30 Timestamp Register */
+#define                    CAN1_MB30_ID0  0xffc037d8   /* CAN Controller 1 Mailbox 30 ID0 Register */
+#define                    CAN1_MB30_ID1  0xffc037dc   /* CAN Controller 1 Mailbox 30 ID1 Register */
+#define                  CAN1_MB31_DATA0  0xffc037e0   /* CAN Controller 1 Mailbox 31 Data 0 Register */
+#define                  CAN1_MB31_DATA1  0xffc037e4   /* CAN Controller 1 Mailbox 31 Data 1 Register */
+#define                  CAN1_MB31_DATA2  0xffc037e8   /* CAN Controller 1 Mailbox 31 Data 2 Register */
+#define                  CAN1_MB31_DATA3  0xffc037ec   /* CAN Controller 1 Mailbox 31 Data 3 Register */
+#define                 CAN1_MB31_LENGTH  0xffc037f0   /* CAN Controller 1 Mailbox 31 Length Register */
+#define              CAN1_MB31_TIMESTAMP  0xffc037f4   /* CAN Controller 1 Mailbox 31 Timestamp Register */
+#define                    CAN1_MB31_ID0  0xffc037f8   /* CAN Controller 1 Mailbox 31 ID0 Register */
+#define                    CAN1_MB31_ID1  0xffc037fc   /* CAN Controller 1 Mailbox 31 ID1 Register */
+
+/* ATAPI Registers */
+
+#define                    ATAPI_CONTROL  0xffc03800   /* ATAPI Control Register */
+#define                     ATAPI_STATUS  0xffc03804   /* ATAPI Status Register */
+#define                   ATAPI_DEV_ADDR  0xffc03808   /* ATAPI Device Register Address */
+#define                  ATAPI_DEV_TXBUF  0xffc0380c   /* ATAPI Device Register Write Data */
+#define                  ATAPI_DEV_RXBUF  0xffc03810   /* ATAPI Device Register Read Data */
+#define                   ATAPI_INT_MASK  0xffc03814   /* ATAPI Interrupt Mask Register */
+#define                 ATAPI_INT_STATUS  0xffc03818   /* ATAPI Interrupt Status Register */
+#define                   ATAPI_XFER_LEN  0xffc0381c   /* ATAPI Length of Transfer */
+#define                ATAPI_LINE_STATUS  0xffc03820   /* ATAPI Line Status */
+#define                   ATAPI_SM_STATE  0xffc03824   /* ATAPI State Machine Status */
+#define                  ATAPI_TERMINATE  0xffc03828   /* ATAPI Host Terminate */
+#define                 ATAPI_PIO_TFRCNT  0xffc0382c   /* ATAPI PIO mode transfer count */
+#define                 ATAPI_DMA_TFRCNT  0xffc03830   /* ATAPI DMA mode transfer count */
+#define               ATAPI_UMAIN_TFRCNT  0xffc03834   /* ATAPI UDMAIN transfer count */
+#define             ATAPI_UDMAOUT_TFRCNT  0xffc03838   /* ATAPI UDMAOUT transfer count */
+#define                  ATAPI_REG_TIM_0  0xffc03840   /* ATAPI Register Transfer Timing 0 */
+#define                  ATAPI_PIO_TIM_0  0xffc03844   /* ATAPI PIO Timing 0 Register */
+#define                  ATAPI_PIO_TIM_1  0xffc03848   /* ATAPI PIO Timing 1 Register */
+#define                ATAPI_MULTI_TIM_0  0xffc03850   /* ATAPI Multi-DMA Timing 0 Register */
+#define                ATAPI_MULTI_TIM_1  0xffc03854   /* ATAPI Multi-DMA Timing 1 Register */
+#define                ATAPI_MULTI_TIM_2  0xffc03858   /* ATAPI Multi-DMA Timing 2 Register */
+#define                ATAPI_ULTRA_TIM_0  0xffc03860   /* ATAPI Ultra-DMA Timing 0 Register */
+#define                ATAPI_ULTRA_TIM_1  0xffc03864   /* ATAPI Ultra-DMA Timing 1 Register */
+#define                ATAPI_ULTRA_TIM_2  0xffc03868   /* ATAPI Ultra-DMA Timing 2 Register */
+#define                ATAPI_ULTRA_TIM_3  0xffc0386c   /* ATAPI Ultra-DMA Timing 3 Register */
+
+/* SDH Registers */
+
+#define                      SDH_PWR_CTL  0xffc03900   /* SDH Power Control */
+#define                      SDH_CLK_CTL  0xffc03904   /* SDH Clock Control */
+#define                     SDH_ARGUMENT  0xffc03908   /* SDH Argument */
+#define                      SDH_COMMAND  0xffc0390c   /* SDH Command */
+#define                     SDH_RESP_CMD  0xffc03910   /* SDH Response Command */
+#define                    SDH_RESPONSE0  0xffc03914   /* SDH Response0 */
+#define                    SDH_RESPONSE1  0xffc03918   /* SDH Response1 */
+#define                    SDH_RESPONSE2  0xffc0391c   /* SDH Response2 */
+#define                    SDH_RESPONSE3  0xffc03920   /* SDH Response3 */
+#define                   SDH_DATA_TIMER  0xffc03924   /* SDH Data Timer */
+#define                    SDH_DATA_LGTH  0xffc03928   /* SDH Data Length */
+#define                     SDH_DATA_CTL  0xffc0392c   /* SDH Data Control */
+#define                     SDH_DATA_CNT  0xffc03930   /* SDH Data Counter */
+#define                       SDH_STATUS  0xffc03934   /* SDH Status */
+#define                   SDH_STATUS_CLR  0xffc03938   /* SDH Status Clear */
+#define                        SDH_MASK0  0xffc0393c   /* SDH Interrupt0 Mask */
+#define                        SDH_MASK1  0xffc03940   /* SDH Interrupt1 Mask */
+#define                     SDH_FIFO_CNT  0xffc03948   /* SDH FIFO Counter */
+#define                         SDH_FIFO  0xffc03980   /* SDH Data FIFO */
+#define                     SDH_E_STATUS  0xffc039c0   /* SDH Exception Status */
+#define                       SDH_E_MASK  0xffc039c4   /* SDH Exception Mask */
+#define                          SDH_CFG  0xffc039c8   /* SDH Configuration */
+#define                   SDH_RD_WAIT_EN  0xffc039cc   /* SDH Read Wait Enable */
+#define                         SDH_PID0  0xffc039d0   /* SDH Peripheral Identification0 */
+#define                         SDH_PID1  0xffc039d4   /* SDH Peripheral Identification1 */
+#define                         SDH_PID2  0xffc039d8   /* SDH Peripheral Identification2 */
+#define                         SDH_PID3  0xffc039dc   /* SDH Peripheral Identification3 */
+#define                         SDH_PID4  0xffc039e0   /* SDH Peripheral Identification4 */
+#define                         SDH_PID5  0xffc039e4   /* SDH Peripheral Identification5 */
+#define                         SDH_PID6  0xffc039e8   /* SDH Peripheral Identification6 */
+#define                         SDH_PID7  0xffc039ec   /* SDH Peripheral Identification7 */
+
+/* HOST Port Registers */
+
+#define                     HOST_CONTROL  0xffc03a00   /* HOST Control Register */
+#define                      HOST_STATUS  0xffc03a04   /* HOST Status Register */
+#define                     HOST_TIMEOUT  0xffc03a08   /* HOST Acknowledge Mode Timeout Register */
+
+/* USB Control Registers */
+
+#define                        USB_FADDR  0xffc03c00   /* Function address register */
+#define                        USB_POWER  0xffc03c04   /* Power management register */
+#define                       USB_INTRTX  0xffc03c08   /* Interrupt register for endpoint 0 and Tx endpoint 1 to 7 */
+#define                       USB_INTRRX  0xffc03c0c   /* Interrupt register for Rx endpoints 1 to 7 */
+#define                      USB_INTRTXE  0xffc03c10   /* Interrupt enable register for IntrTx */
+#define                      USB_INTRRXE  0xffc03c14   /* Interrupt enable register for IntrRx */
+#define                      USB_INTRUSB  0xffc03c18   /* Interrupt register for common USB interrupts */
+#define                     USB_INTRUSBE  0xffc03c1c   /* Interrupt enable register for IntrUSB */
+#define                        USB_FRAME  0xffc03c20   /* USB frame number */
+#define                        USB_INDEX  0xffc03c24   /* Index register for selecting the indexed endpoint registers */
+#define                     USB_TESTMODE  0xffc03c28   /* Enabled USB 20 test modes */
+#define                     USB_GLOBINTR  0xffc03c2c   /* Global Interrupt Mask register and Wakeup Exception Interrupt */
+#define                   USB_GLOBAL_CTL  0xffc03c30   /* Global Clock Control for the core */
+
+/* USB Packet Control Registers */
+
+#define                USB_TX_MAX_PACKET  0xffc03c40   /* Maximum packet size for Host Tx endpoint */
+#define                         USB_CSR0  0xffc03c44   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                        USB_TXCSR  0xffc03c44   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                USB_RX_MAX_PACKET  0xffc03c48   /* Maximum packet size for Host Rx endpoint */
+#define                        USB_RXCSR  0xffc03c4c   /* Control Status register for Host Rx endpoint */
+#define                       USB_COUNT0  0xffc03c50   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                      USB_RXCOUNT  0xffc03c50   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                       USB_TXTYPE  0xffc03c54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint */
+#define                    USB_NAKLIMIT0  0xffc03c58   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                   USB_TXINTERVAL  0xffc03c58   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                       USB_RXTYPE  0xffc03c5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint */
+#define                   USB_RXINTERVAL  0xffc03c60   /* Sets the polling interval for Interrupt and Isochronous transfers or the NAK response timeout on Bulk transfers */
+#define                      USB_TXCOUNT  0xffc03c68   /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* USB Endpoint FIFO Registers */
+
+#define                     USB_EP0_FIFO  0xffc03c80   /* Endpoint 0 FIFO */
+#define                     USB_EP1_FIFO  0xffc03c88   /* Endpoint 1 FIFO */
+#define                     USB_EP2_FIFO  0xffc03c90   /* Endpoint 2 FIFO */
+#define                     USB_EP3_FIFO  0xffc03c98   /* Endpoint 3 FIFO */
+#define                     USB_EP4_FIFO  0xffc03ca0   /* Endpoint 4 FIFO */
+#define                     USB_EP5_FIFO  0xffc03ca8   /* Endpoint 5 FIFO */
+#define                     USB_EP6_FIFO  0xffc03cb0   /* Endpoint 6 FIFO */
+#define                     USB_EP7_FIFO  0xffc03cb8   /* Endpoint 7 FIFO */
+
+/* USB OTG Control Registers */
+
+#define                  USB_OTG_DEV_CTL  0xffc03d00   /* OTG Device Control Register */
+#define                 USB_OTG_VBUS_IRQ  0xffc03d04   /* OTG VBUS Control Interrupts */
+#define                USB_OTG_VBUS_MASK  0xffc03d08   /* VBUS Control Interrupt Enable */
+
+/* USB Phy Control Registers */
+
+#define                     USB_LINKINFO  0xffc03d48   /* Enables programming of some PHY-side delays */
+#define                        USB_VPLEN  0xffc03d4c   /* Determines duration of VBUS pulse for VBUS charging */
+#define                      USB_HS_EOF1  0xffc03d50   /* Time buffer for High-Speed transactions */
+#define                      USB_FS_EOF1  0xffc03d54   /* Time buffer for Full-Speed transactions */
+#define                      USB_LS_EOF1  0xffc03d58   /* Time buffer for Low-Speed transactions */
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define                   USB_APHY_CNTRL  0xffc03de0   /* Register that increases visibility of Analog PHY */
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define                   USB_APHY_CALIB  0xffc03de4   /* Register used to set some calibration values */
+#define                  USB_APHY_CNTRL2  0xffc03de8   /* Register used to prevent re-enumeration once Moab goes into hibernate mode */
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define                     USB_PHY_TEST  0xffc03dec   /* Used for reducing simulation time and simplifies FIFO testability */
+#define                  USB_PLLOSC_CTRL  0xffc03df0   /* Used to program different parameters for USB PLL and Oscillator */
+#define                   USB_SRP_CLKDIV  0xffc03df4   /* Used to program clock divide value for the clock fed to the SRP detection logic */
+
+/* USB Endpoint 0 Control Registers */
+
+#define                USB_EP_NI0_TXMAXP  0xffc03e00   /* Maximum packet size for Host Tx endpoint0 */
+#define                 USB_EP_NI0_TXCSR  0xffc03e04   /* Control Status register for endpoint 0 */
+#define                USB_EP_NI0_RXMAXP  0xffc03e08   /* Maximum packet size for Host Rx endpoint0 */
+#define                 USB_EP_NI0_RXCSR  0xffc03e0c   /* Control Status register for Host Rx endpoint0 */
+#define               USB_EP_NI0_RXCOUNT  0xffc03e10   /* Number of bytes received in endpoint 0 FIFO */
+#define                USB_EP_NI0_TXTYPE  0xffc03e14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint0 */
+#define            USB_EP_NI0_TXINTERVAL  0xffc03e18   /* Sets the NAK response timeout on Endpoint 0 */
+#define                USB_EP_NI0_RXTYPE  0xffc03e1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint0 */
+#define            USB_EP_NI0_RXINTERVAL  0xffc03e20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint0 */
+
+/* USB Endpoint 1 Control Registers */
+
+#define               USB_EP_NI0_TXCOUNT  0xffc03e28   /* Number of bytes to be written to the endpoint0 Tx FIFO */
+#define                USB_EP_NI1_TXMAXP  0xffc03e40   /* Maximum packet size for Host Tx endpoint1 */
+#define                 USB_EP_NI1_TXCSR  0xffc03e44   /* Control Status register for endpoint1 */
+#define                USB_EP_NI1_RXMAXP  0xffc03e48   /* Maximum packet size for Host Rx endpoint1 */
+#define                 USB_EP_NI1_RXCSR  0xffc03e4c   /* Control Status register for Host Rx endpoint1 */
+#define               USB_EP_NI1_RXCOUNT  0xffc03e50   /* Number of bytes received in endpoint1 FIFO */
+#define                USB_EP_NI1_TXTYPE  0xffc03e54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint1 */
+#define            USB_EP_NI1_TXINTERVAL  0xffc03e58   /* Sets the NAK response timeout on Endpoint1 */
+#define                USB_EP_NI1_RXTYPE  0xffc03e5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint1 */
+#define            USB_EP_NI1_RXINTERVAL  0xffc03e60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint1 */
+
+/* USB Endpoint 2 Control Registers */
+
+#define               USB_EP_NI1_TXCOUNT  0xffc03e68   /* Number of bytes to be written to the+H102 endpoint1 Tx FIFO */
+#define                USB_EP_NI2_TXMAXP  0xffc03e80   /* Maximum packet size for Host Tx endpoint2 */
+#define                 USB_EP_NI2_TXCSR  0xffc03e84   /* Control Status register for endpoint2 */
+#define                USB_EP_NI2_RXMAXP  0xffc03e88   /* Maximum packet size for Host Rx endpoint2 */
+#define                 USB_EP_NI2_RXCSR  0xffc03e8c   /* Control Status register for Host Rx endpoint2 */
+#define               USB_EP_NI2_RXCOUNT  0xffc03e90   /* Number of bytes received in endpoint2 FIFO */
+#define                USB_EP_NI2_TXTYPE  0xffc03e94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint2 */
+#define            USB_EP_NI2_TXINTERVAL  0xffc03e98   /* Sets the NAK response timeout on Endpoint2 */
+#define                USB_EP_NI2_RXTYPE  0xffc03e9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint2 */
+#define            USB_EP_NI2_RXINTERVAL  0xffc03ea0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint2 */
+
+/* USB Endpoint 3 Control Registers */
+
+#define               USB_EP_NI2_TXCOUNT  0xffc03ea8   /* Number of bytes to be written to the endpoint2 Tx FIFO */
+#define                USB_EP_NI3_TXMAXP  0xffc03ec0   /* Maximum packet size for Host Tx endpoint3 */
+#define                 USB_EP_NI3_TXCSR  0xffc03ec4   /* Control Status register for endpoint3 */
+#define                USB_EP_NI3_RXMAXP  0xffc03ec8   /* Maximum packet size for Host Rx endpoint3 */
+#define                 USB_EP_NI3_RXCSR  0xffc03ecc   /* Control Status register for Host Rx endpoint3 */
+#define               USB_EP_NI3_RXCOUNT  0xffc03ed0   /* Number of bytes received in endpoint3 FIFO */
+#define                USB_EP_NI3_TXTYPE  0xffc03ed4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint3 */
+#define            USB_EP_NI3_TXINTERVAL  0xffc03ed8   /* Sets the NAK response timeout on Endpoint3 */
+#define                USB_EP_NI3_RXTYPE  0xffc03edc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint3 */
+#define            USB_EP_NI3_RXINTERVAL  0xffc03ee0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint3 */
+
+/* USB Endpoint 4 Control Registers */
+
+#define               USB_EP_NI3_TXCOUNT  0xffc03ee8   /* Number of bytes to be written to the H124endpoint3 Tx FIFO */
+#define                USB_EP_NI4_TXMAXP  0xffc03f00   /* Maximum packet size for Host Tx endpoint4 */
+#define                 USB_EP_NI4_TXCSR  0xffc03f04   /* Control Status register for endpoint4 */
+#define                USB_EP_NI4_RXMAXP  0xffc03f08   /* Maximum packet size for Host Rx endpoint4 */
+#define                 USB_EP_NI4_RXCSR  0xffc03f0c   /* Control Status register for Host Rx endpoint4 */
+#define               USB_EP_NI4_RXCOUNT  0xffc03f10   /* Number of bytes received in endpoint4 FIFO */
+#define                USB_EP_NI4_TXTYPE  0xffc03f14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint4 */
+#define            USB_EP_NI4_TXINTERVAL  0xffc03f18   /* Sets the NAK response timeout on Endpoint4 */
+#define                USB_EP_NI4_RXTYPE  0xffc03f1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint4 */
+#define            USB_EP_NI4_RXINTERVAL  0xffc03f20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint4 */
+
+/* USB Endpoint 5 Control Registers */
+
+#define               USB_EP_NI4_TXCOUNT  0xffc03f28   /* Number of bytes to be written to the endpoint4 Tx FIFO */
+#define                USB_EP_NI5_TXMAXP  0xffc03f40   /* Maximum packet size for Host Tx endpoint5 */
+#define                 USB_EP_NI5_TXCSR  0xffc03f44   /* Control Status register for endpoint5 */
+#define                USB_EP_NI5_RXMAXP  0xffc03f48   /* Maximum packet size for Host Rx endpoint5 */
+#define                 USB_EP_NI5_RXCSR  0xffc03f4c   /* Control Status register for Host Rx endpoint5 */
+#define               USB_EP_NI5_RXCOUNT  0xffc03f50   /* Number of bytes received in endpoint5 FIFO */
+#define                USB_EP_NI5_TXTYPE  0xffc03f54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint5 */
+#define            USB_EP_NI5_TXINTERVAL  0xffc03f58   /* Sets the NAK response timeout on Endpoint5 */
+#define                USB_EP_NI5_RXTYPE  0xffc03f5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint5 */
+#define            USB_EP_NI5_RXINTERVAL  0xffc03f60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint5 */
+
+/* USB Endpoint 6 Control Registers */
+
+#define               USB_EP_NI5_TXCOUNT  0xffc03f68   /* Number of bytes to be written to the H145endpoint5 Tx FIFO */
+#define                USB_EP_NI6_TXMAXP  0xffc03f80   /* Maximum packet size for Host Tx endpoint6 */
+#define                 USB_EP_NI6_TXCSR  0xffc03f84   /* Control Status register for endpoint6 */
+#define                USB_EP_NI6_RXMAXP  0xffc03f88   /* Maximum packet size for Host Rx endpoint6 */
+#define                 USB_EP_NI6_RXCSR  0xffc03f8c   /* Control Status register for Host Rx endpoint6 */
+#define               USB_EP_NI6_RXCOUNT  0xffc03f90   /* Number of bytes received in endpoint6 FIFO */
+#define                USB_EP_NI6_TXTYPE  0xffc03f94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint6 */
+#define            USB_EP_NI6_TXINTERVAL  0xffc03f98   /* Sets the NAK response timeout on Endpoint6 */
+#define                USB_EP_NI6_RXTYPE  0xffc03f9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint6 */
+#define            USB_EP_NI6_RXINTERVAL  0xffc03fa0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint6 */
+
+/* USB Endpoint 7 Control Registers */
+
+#define               USB_EP_NI6_TXCOUNT  0xffc03fa8   /* Number of bytes to be written to the endpoint6 Tx FIFO */
+#define                USB_EP_NI7_TXMAXP  0xffc03fc0   /* Maximum packet size for Host Tx endpoint7 */
+#define                 USB_EP_NI7_TXCSR  0xffc03fc4   /* Control Status register for endpoint7 */
+#define                USB_EP_NI7_RXMAXP  0xffc03fc8   /* Maximum packet size for Host Rx endpoint7 */
+#define                 USB_EP_NI7_RXCSR  0xffc03fcc   /* Control Status register for Host Rx endpoint7 */
+#define               USB_EP_NI7_RXCOUNT  0xffc03fd0   /* Number of bytes received in endpoint7 FIFO */
+#define                USB_EP_NI7_TXTYPE  0xffc03fd4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint7 */
+#define            USB_EP_NI7_TXINTERVAL  0xffc03fd8   /* Sets the NAK response timeout on Endpoint7 */
+#define                USB_EP_NI7_RXTYPE  0xffc03fdc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint7 */
+#define            USB_EP_NI7_RXINTERVAL  0xffc03ff0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint7 */
+#define               USB_EP_NI7_TXCOUNT  0xffc03ff8   /* Number of bytes to be written to the endpoint7 Tx FIFO */
+#define                USB_DMA_INTERRUPT  0xffc04000   /* Indicates pending interrupts for the DMA channels */
+
+/* USB Channel 0 Config Registers */
+
+#define                  USB_DMA0CONTROL  0xffc04004   /* DMA master channel 0 configuration */
+#define                  USB_DMA0ADDRLOW  0xffc04008   /* Lower 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0ADDRHIGH  0xffc0400c   /* Upper 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0COUNTLOW  0xffc04010   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 0 */
+#define                USB_DMA0COUNTHIGH  0xffc04014   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 0 */
+
+/* USB Channel 1 Config Registers */
+
+#define                  USB_DMA1CONTROL  0xffc04024   /* DMA master channel 1 configuration */
+#define                  USB_DMA1ADDRLOW  0xffc04028   /* Lower 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1ADDRHIGH  0xffc0402c   /* Upper 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1COUNTLOW  0xffc04030   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 1 */
+#define                USB_DMA1COUNTHIGH  0xffc04034   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 1 */
+
+/* USB Channel 2 Config Registers */
+
+#define                  USB_DMA2CONTROL  0xffc04044   /* DMA master channel 2 configuration */
+#define                  USB_DMA2ADDRLOW  0xffc04048   /* Lower 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2ADDRHIGH  0xffc0404c   /* Upper 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2COUNTLOW  0xffc04050   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 2 */
+#define                USB_DMA2COUNTHIGH  0xffc04054   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 2 */
+
+/* USB Channel 3 Config Registers */
+
+#define                  USB_DMA3CONTROL  0xffc04064   /* DMA master channel 3 configuration */
+#define                  USB_DMA3ADDRLOW  0xffc04068   /* Lower 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3ADDRHIGH  0xffc0406c   /* Upper 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3COUNTLOW  0xffc04070   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 3 */
+#define                USB_DMA3COUNTHIGH  0xffc04074   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 3 */
+
+/* USB Channel 4 Config Registers */
+
+#define                  USB_DMA4CONTROL  0xffc04084   /* DMA master channel 4 configuration */
+#define                  USB_DMA4ADDRLOW  0xffc04088   /* Lower 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4ADDRHIGH  0xffc0408c   /* Upper 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4COUNTLOW  0xffc04090   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 4 */
+#define                USB_DMA4COUNTHIGH  0xffc04094   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 4 */
+
+/* USB Channel 5 Config Registers */
+
+#define                  USB_DMA5CONTROL  0xffc040a4   /* DMA master channel 5 configuration */
+#define                  USB_DMA5ADDRLOW  0xffc040a8   /* Lower 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5ADDRHIGH  0xffc040ac   /* Upper 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5COUNTLOW  0xffc040b0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 5 */
+#define                USB_DMA5COUNTHIGH  0xffc040b4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 5 */
+
+/* USB Channel 6 Config Registers */
+
+#define                  USB_DMA6CONTROL  0xffc040c4   /* DMA master channel 6 configuration */
+#define                  USB_DMA6ADDRLOW  0xffc040c8   /* Lower 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6ADDRHIGH  0xffc040cc   /* Upper 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6COUNTLOW  0xffc040d0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 6 */
+#define                USB_DMA6COUNTHIGH  0xffc040d4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 6 */
+
+/* USB Channel 7 Config Registers */
+
+#define                  USB_DMA7CONTROL  0xffc040e4   /* DMA master channel 7 configuration */
+#define                  USB_DMA7ADDRLOW  0xffc040e8   /* Lower 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7ADDRHIGH  0xffc040ec   /* Upper 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7COUNTLOW  0xffc040f0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 7 */
+#define                USB_DMA7COUNTHIGH  0xffc040f4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 7 */
+
+/* Keypad Registers */
+
+#define                         KPAD_CTL  0xffc04100   /* Controls keypad module enable and disable */
+#define                    KPAD_PRESCALE  0xffc04104   /* Establish a time base for programing the KPAD_MSEL register */
+#define                        KPAD_MSEL  0xffc04108   /* Selects delay parameters for keypad interface sensitivity */
+#define                      KPAD_ROWCOL  0xffc0410c   /* Captures the row and column output values of the keys pressed */
+#define                        KPAD_STAT  0xffc04110   /* Holds and clears the status of the keypad interface interrupt */
+#define                    KPAD_SOFTEVAL  0xffc04114   /* Lets software force keypad interface to check for keys being pressed */
+
+/* Pixel Compositor (PIXC) Registers */
+
+#define                         PIXC_CTL  0xffc04400   /* Overlay enable, resampling mode, I/O data format, transparency enable, watermark level, FIFO status */
+#define                         PIXC_PPL  0xffc04404   /* Holds the number of pixels per line of the display */
+#define                         PIXC_LPF  0xffc04408   /* Holds the number of lines per frame of the display */
+#define                     PIXC_AHSTART  0xffc0440c   /* Contains horizontal start pixel information of the overlay data (set A) */
+#define                       PIXC_AHEND  0xffc04410   /* Contains horizontal end pixel information of the overlay data (set A) */
+#define                     PIXC_AVSTART  0xffc04414   /* Contains vertical start pixel information of the overlay data (set A) */
+#define                       PIXC_AVEND  0xffc04418   /* Contains vertical end pixel information of the overlay data (set A) */
+#define                     PIXC_ATRANSP  0xffc0441c   /* Contains the transparency ratio (set A) */
+#define                     PIXC_BHSTART  0xffc04420   /* Contains horizontal start pixel information of the overlay data (set B) */
+#define                       PIXC_BHEND  0xffc04424   /* Contains horizontal end pixel information of the overlay data (set B) */
+#define                     PIXC_BVSTART  0xffc04428   /* Contains vertical start pixel information of the overlay data (set B) */
+#define                       PIXC_BVEND  0xffc0442c   /* Contains vertical end pixel information of the overlay data (set B) */
+#define                     PIXC_BTRANSP  0xffc04430   /* Contains the transparency ratio (set B) */
+#define                    PIXC_INTRSTAT  0xffc0443c   /* Overlay interrupt configuration/status */
+#define                       PIXC_RYCON  0xffc04440   /* Color space conversion matrix register. Contains the R/Y conversion coefficients */
+#define                       PIXC_GUCON  0xffc04444   /* Color space conversion matrix register. Contains the G/U conversion coefficients */
+#define                       PIXC_BVCON  0xffc04448   /* Color space conversion matrix register. Contains the B/V conversion coefficients */
+#define                      PIXC_CCBIAS  0xffc0444c   /* Bias values for the color space conversion matrix */
+#define                          PIXC_TC  0xffc04450   /* Holds the transparent color value */
+
+/* Handshake MDMA 0 Registers */
+
+#define                   HMDMA0_CONTROL  0xffc04500   /* Handshake MDMA0 Control Register */
+#define                    HMDMA0_ECINIT  0xffc04504   /* Handshake MDMA0 Initial Edge Count Register */
+#define                    HMDMA0_BCINIT  0xffc04508   /* Handshake MDMA0 Initial Block Count Register */
+#define                  HMDMA0_ECURGENT  0xffc0450c   /* Handshake MDMA0 Urgent Edge Count Threshhold Register */
+#define                HMDMA0_ECOVERFLOW  0xffc04510   /* Handshake MDMA0 Edge Count Overflow Interrupt Register */
+#define                    HMDMA0_ECOUNT  0xffc04514   /* Handshake MDMA0 Current Edge Count Register */
+#define                    HMDMA0_BCOUNT  0xffc04518   /* Handshake MDMA0 Current Block Count Register */
+
+/* Handshake MDMA 1 Registers */
+
+#define                   HMDMA1_CONTROL  0xffc04540   /* Handshake MDMA1 Control Register */
+#define                    HMDMA1_ECINIT  0xffc04544   /* Handshake MDMA1 Initial Edge Count Register */
+#define                    HMDMA1_BCINIT  0xffc04548   /* Handshake MDMA1 Initial Block Count Register */
+#define                  HMDMA1_ECURGENT  0xffc0454c   /* Handshake MDMA1 Urgent Edge Count Threshhold Register */
+#define                HMDMA1_ECOVERFLOW  0xffc04550   /* Handshake MDMA1 Edge Count Overflow Interrupt Register */
+#define                    HMDMA1_ECOUNT  0xffc04554   /* Handshake MDMA1 Current Edge Count Register */
+#define                    HMDMA1_BCOUNT  0xffc04558   /* Handshake MDMA1 Current Block Count Register */
+
+
+/* ********************************************************** */
+/*     SINGLE BIT MACRO PAIRS (bit mask and negated one)      */
+/*     and MULTI BIT READ MACROS                              */
+/* ********************************************************** */
+
+/* Bit masks for PIXC_CTL */
+
+#define                   PIXC_EN  0x1        /* Pixel Compositor Enable */
+#define                  nPIXC_EN  0x0       
+#define                  OVR_A_EN  0x2        /* Overlay A Enable */
+#define                 nOVR_A_EN  0x0       
+#define                  OVR_B_EN  0x4        /* Overlay B Enable */
+#define                 nOVR_B_EN  0x0       
+#define                  IMG_FORM  0x8        /* Image Data Format */
+#define                 nIMG_FORM  0x0       
+#define                  OVR_FORM  0x10       /* Overlay Data Format */
+#define                 nOVR_FORM  0x0       
+#define                  OUT_FORM  0x20       /* Output Data Format */
+#define                 nOUT_FORM  0x0       
+#define                   UDS_MOD  0x40       /* Resampling Mode */
+#define                  nUDS_MOD  0x0       
+#define                     TC_EN  0x80       /* Transparent Color Enable */
+#define                    nTC_EN  0x0       
+#define                  IMG_STAT  0x300      /* Image FIFO Status */
+#define                  OVR_STAT  0xc00      /* Overlay FIFO Status */
+#define                    WM_LVL  0x3000     /* FIFO Watermark Level */
+
+/* Bit masks for PIXC_AHSTART */
+
+#define                  A_HSTART  0xfff      /* Horizontal Start Coordinates */
+
+/* Bit masks for PIXC_AHEND */
+
+#define                    A_HEND  0xfff      /* Horizontal End Coordinates */
+
+/* Bit masks for PIXC_AVSTART */
+
+#define                  A_VSTART  0x3ff      /* Vertical Start Coordinates */
+
+/* Bit masks for PIXC_AVEND */
+
+#define                    A_VEND  0x3ff      /* Vertical End Coordinates */
+
+/* Bit masks for PIXC_ATRANSP */
+
+#define                  A_TRANSP  0xf        /* Transparency Value */
+
+/* Bit masks for PIXC_BHSTART */
+
+#define                  B_HSTART  0xfff      /* Horizontal Start Coordinates */
+
+/* Bit masks for PIXC_BHEND */
+
+#define                    B_HEND  0xfff      /* Horizontal End Coordinates */
+
+/* Bit masks for PIXC_BVSTART */
+
+#define                  B_VSTART  0x3ff      /* Vertical Start Coordinates */
+
+/* Bit masks for PIXC_BVEND */
+
+#define                    B_VEND  0x3ff      /* Vertical End Coordinates */
+
+/* Bit masks for PIXC_BTRANSP */
+
+#define                  B_TRANSP  0xf        /* Transparency Value */
+
+/* Bit masks for PIXC_INTRSTAT */
+
+#define                OVR_INT_EN  0x1        /* Interrupt at End of Last Valid Overlay */
+#define               nOVR_INT_EN  0x0       
+#define                FRM_INT_EN  0x2        /* Interrupt at End of Frame */
+#define               nFRM_INT_EN  0x0       
+#define              OVR_INT_STAT  0x4        /* Overlay Interrupt Status */
+#define             nOVR_INT_STAT  0x0       
+#define              FRM_INT_STAT  0x8        /* Frame Interrupt Status */
+#define             nFRM_INT_STAT  0x0       
+
+/* Bit masks for PIXC_RYCON */
+
+#define                       A11  0x3ff      /* A11 in the Coefficient Matrix */
+#define                       A12  0xffc00    /* A12 in the Coefficient Matrix */
+#define                       A13  0x3ff00000 /* A13 in the Coefficient Matrix */
+#define                  RY_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nRY_MULT4  0x0       
+
+/* Bit masks for PIXC_GUCON */
+
+#define                       A21  0x3ff      /* A21 in the Coefficient Matrix */
+#define                       A22  0xffc00    /* A22 in the Coefficient Matrix */
+#define                       A23  0x3ff00000 /* A23 in the Coefficient Matrix */
+#define                  GU_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nGU_MULT4  0x0       
+
+/* Bit masks for PIXC_BVCON */
+
+#define                       A31  0x3ff      /* A31 in the Coefficient Matrix */
+#define                       A32  0xffc00    /* A32 in the Coefficient Matrix */
+#define                       A33  0x3ff00000 /* A33 in the Coefficient Matrix */
+#define                  BV_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nBV_MULT4  0x0       
+
+/* Bit masks for PIXC_CCBIAS */
+
+#define                       A14  0x3ff      /* A14 in the Bias Vector */
+#define                       A24  0xffc00    /* A24 in the Bias Vector */
+#define                       A34  0x3ff00000 /* A34 in the Bias Vector */
+
+/* Bit masks for PIXC_TC */
+
+#define                  RY_TRANS  0xff       /* Transparent Color - R/Y Component */
+#define                  GU_TRANS  0xff00     /* Transparent Color - G/U Component */
+#define                  BV_TRANS  0xff0000   /* Transparent Color - B/V Component */
+
+/* Bit masks for HOST_CONTROL */
+
+#define                   HOST_EN  0x1        /* Host Enable */
+#define                  nHOST_EN  0x0       
+#define                  HOST_END  0x2        /* Host Endianess */
+#define                 nHOST_END  0x0       
+#define                 DATA_SIZE  0x4        /* Data Size */
+#define                nDATA_SIZE  0x0       
+#define                  HOST_RST  0x8        /* Host Reset */
+#define                 nHOST_RST  0x0       
+#define                  HRDY_OVR  0x20       /* Host Ready Override */
+#define                 nHRDY_OVR  0x0       
+#define                  INT_MODE  0x40       /* Interrupt Mode */
+#define                 nINT_MODE  0x0       
+#define                     BT_EN  0x80       /* Bus Timeout Enable */
+#define                    nBT_EN  0x0       
+#define                       EHW  0x100      /* Enable Host Write */
+#define                      nEHW  0x0       
+#define                       EHR  0x200      /* Enable Host Read */
+#define                      nEHR  0x0       
+#define                       BDR  0x400      /* Burst DMA Requests */
+#define                      nBDR  0x0       
+
+/* Bit masks for HOST_STATUS */
+
+#define                     READY  0x1        /* DMA Ready */
+#define                    nREADY  0x0       
+#define                  FIFOFULL  0x2        /* FIFO Full */
+#define                 nFIFOFULL  0x0       
+#define                 FIFOEMPTY  0x4        /* FIFO Empty */
+#define                nFIFOEMPTY  0x0       
+#define                  COMPLETE  0x8        /* DMA Complete */
+#define                 nCOMPLETE  0x0       
+#define                      HSHK  0x10       /* Host Handshake */
+#define                     nHSHK  0x0       
+#define                   TIMEOUT  0x20       /* Host Timeout */
+#define                  nTIMEOUT  0x0       
+#define                      HIRQ  0x40       /* Host Interrupt Request */
+#define                     nHIRQ  0x0       
+#define                ALLOW_CNFG  0x80       /* Allow New Configuration */
+#define               nALLOW_CNFG  0x0       
+#define                   DMA_DIR  0x100      /* DMA Direction */
+#define                  nDMA_DIR  0x0       
+#define                       BTE  0x200      /* Bus Timeout Enabled */
+#define                      nBTE  0x0       
+
+/* Bit masks for HOST_TIMEOUT */
+
+#define             COUNT_TIMEOUT  0x7ff      /* Host Timeout count */
+
+/* Bit masks for KPAD_CTL */
+
+#define                   KPAD_EN  0x1        /* Keypad Enable */
+#define                  nKPAD_EN  0x0       
+#define              KPAD_IRQMODE  0x6        /* Key Press Interrupt Enable */
+#define                KPAD_ROWEN  0x1c00     /* Row Enable Width */
+#define                KPAD_COLEN  0xe000     /* Column Enable Width */
+
+/* Bit masks for KPAD_PRESCALE */
+
+#define         KPAD_PRESCALE_VAL  0x3f       /* Key Prescale Value */
+
+/* Bit masks for KPAD_MSEL */
+
+#define                DBON_SCALE  0xff       /* Debounce Scale Value */
+#define              COLDRV_SCALE  0xff00     /* Column Driver Scale Value */
+
+/* Bit masks for KPAD_ROWCOL */
+
+#define                  KPAD_ROW  0xff       /* Rows Pressed */
+#define                  KPAD_COL  0xff00     /* Columns Pressed */
+
+/* Bit masks for KPAD_STAT */
+
+#define                  KPAD_IRQ  0x1        /* Keypad Interrupt Status */
+#define                 nKPAD_IRQ  0x0       
+#define              KPAD_MROWCOL  0x6        /* Multiple Row/Column Keypress Status */
+#define              KPAD_PRESSED  0x8        /* Key press current status */
+#define             nKPAD_PRESSED  0x0       
+
+/* Bit masks for KPAD_SOFTEVAL */
+
+#define           KPAD_SOFTEVAL_E  0x2        /* Software Programmable Force Evaluate */
+#define          nKPAD_SOFTEVAL_E  0x0       
+
+/* Bit masks for SDH_COMMAND */
+
+#define                   CMD_IDX  0x3f       /* Command Index */
+#define                   CMD_RSP  0x40       /* Response */
+#define                  nCMD_RSP  0x0       
+#define                 CMD_L_RSP  0x80       /* Long Response */
+#define                nCMD_L_RSP  0x0       
+#define                 CMD_INT_E  0x100      /* Command Interrupt */
+#define                nCMD_INT_E  0x0       
+#define                CMD_PEND_E  0x200      /* Command Pending */
+#define               nCMD_PEND_E  0x0       
+#define                     CMD_E  0x400      /* Command Enable */
+#define                    nCMD_E  0x0       
+
+/* Bit masks for SDH_PWR_CTL */
+
+#define                    PWR_ON  0x3        /* Power On */
+#if 0
+#define                       TBD  0x3c       /* TBD */
+#endif
+#define                 SD_CMD_OD  0x40       /* Open Drain Output */
+#define                nSD_CMD_OD  0x0       
+#define                   ROD_CTL  0x80       /* Rod Control */
+#define                  nROD_CTL  0x0       
+
+/* Bit masks for SDH_CLK_CTL */
+
+#define                    CLKDIV  0xff       /* MC_CLK Divisor */
+#define                     CLK_E  0x100      /* MC_CLK Bus Clock Enable */
+#define                    nCLK_E  0x0       
+#define                  PWR_SV_E  0x200      /* Power Save Enable */
+#define                 nPWR_SV_E  0x0       
+#define             CLKDIV_BYPASS  0x400      /* Bypass Divisor */
+#define            nCLKDIV_BYPASS  0x0       
+#define                  WIDE_BUS  0x800      /* Wide Bus Mode Enable */
+#define                 nWIDE_BUS  0x0       
+
+/* Bit masks for SDH_RESP_CMD */
+
+#define                  RESP_CMD  0x3f       /* Response Command */
+
+/* Bit masks for SDH_DATA_CTL */
+
+#define                     DTX_E  0x1        /* Data Transfer Enable */
+#define                    nDTX_E  0x0       
+#define                   DTX_DIR  0x2        /* Data Transfer Direction */
+#define                  nDTX_DIR  0x0       
+#define                  DTX_MODE  0x4        /* Data Transfer Mode */
+#define                 nDTX_MODE  0x0       
+#define                 DTX_DMA_E  0x8        /* Data Transfer DMA Enable */
+#define                nDTX_DMA_E  0x0       
+#define              DTX_BLK_LGTH  0xf0       /* Data Transfer Block Length */
+
+/* Bit masks for SDH_STATUS */
+
+#define              CMD_CRC_FAIL  0x1        /* CMD CRC Fail */
+#define             nCMD_CRC_FAIL  0x0       
+#define              DAT_CRC_FAIL  0x2        /* Data CRC Fail */
+#define             nDAT_CRC_FAIL  0x0       
+#define               CMD_TIMEOUT  0x4        /* CMD Time Out */
+#define              nCMD_TIMEOUT  0x0       
+#define               DAT_TIMEOUT  0x8        /* Data Time Out */
+#define              nDAT_TIMEOUT  0x0       
+#define               TX_UNDERRUN  0x10       /* Transmit Underrun */
+#define              nTX_UNDERRUN  0x0       
+#define                RX_OVERRUN  0x20       /* Receive Overrun */
+#define               nRX_OVERRUN  0x0       
+#define              CMD_RESP_END  0x40       /* CMD Response End */
+#define             nCMD_RESP_END  0x0       
+#define                  CMD_SENT  0x80       /* CMD Sent */
+#define                 nCMD_SENT  0x0       
+#define                   DAT_END  0x100      /* Data End */
+#define                  nDAT_END  0x0       
+#define             START_BIT_ERR  0x200      /* Start Bit Error */
+#define            nSTART_BIT_ERR  0x0       
+#define               DAT_BLK_END  0x400      /* Data Block End */
+#define              nDAT_BLK_END  0x0       
+#define                   CMD_ACT  0x800      /* CMD Active */
+#define                  nCMD_ACT  0x0       
+#define                    TX_ACT  0x1000     /* Transmit Active */
+#define                   nTX_ACT  0x0       
+#define                    RX_ACT  0x2000     /* Receive Active */
+#define                   nRX_ACT  0x0       
+#define              TX_FIFO_STAT  0x4000     /* Transmit FIFO Status */
+#define             nTX_FIFO_STAT  0x0       
+#define              RX_FIFO_STAT  0x8000     /* Receive FIFO Status */
+#define             nRX_FIFO_STAT  0x0       
+#define              TX_FIFO_FULL  0x10000    /* Transmit FIFO Full */
+#define             nTX_FIFO_FULL  0x0       
+#define              RX_FIFO_FULL  0x20000    /* Receive FIFO Full */
+#define             nRX_FIFO_FULL  0x0       
+#define              TX_FIFO_ZERO  0x40000    /* Transmit FIFO Empty */
+#define             nTX_FIFO_ZERO  0x0       
+#define               RX_DAT_ZERO  0x80000    /* Receive FIFO Empty */
+#define              nRX_DAT_ZERO  0x0       
+#define                TX_DAT_RDY  0x100000   /* Transmit Data Available */
+#define               nTX_DAT_RDY  0x0       
+#define               RX_FIFO_RDY  0x200000   /* Receive Data Available */
+#define              nRX_FIFO_RDY  0x0       
+
+/* Bit masks for SDH_STATUS_CLR */
+
+#define         CMD_CRC_FAIL_STAT  0x1        /* CMD CRC Fail Status */
+#define        nCMD_CRC_FAIL_STAT  0x0       
+#define         DAT_CRC_FAIL_STAT  0x2        /* Data CRC Fail Status */
+#define        nDAT_CRC_FAIL_STAT  0x0       
+#define          CMD_TIMEOUT_STAT  0x4        /* CMD Time Out Status */
+#define         nCMD_TIMEOUT_STAT  0x0       
+#define          DAT_TIMEOUT_STAT  0x8        /* Data Time Out status */
+#define         nDAT_TIMEOUT_STAT  0x0       
+#define          TX_UNDERRUN_STAT  0x10       /* Transmit Underrun Status */
+#define         nTX_UNDERRUN_STAT  0x0       
+#define           RX_OVERRUN_STAT  0x20       /* Receive Overrun Status */
+#define          nRX_OVERRUN_STAT  0x0       
+#define         CMD_RESP_END_STAT  0x40       /* CMD Response End Status */
+#define        nCMD_RESP_END_STAT  0x0       
+#define             CMD_SENT_STAT  0x80       /* CMD Sent Status */
+#define            nCMD_SENT_STAT  0x0       
+#define              DAT_END_STAT  0x100      /* Data End Status */
+#define             nDAT_END_STAT  0x0       
+#define        START_BIT_ERR_STAT  0x200      /* Start Bit Error Status */
+#define       nSTART_BIT_ERR_STAT  0x0       
+#define          DAT_BLK_END_STAT  0x400      /* Data Block End Status */
+#define         nDAT_BLK_END_STAT  0x0       
+
+/* Bit masks for SDH_MASK0 */
+
+#define         CMD_CRC_FAIL_MASK  0x1        /* CMD CRC Fail Mask */
+#define        nCMD_CRC_FAIL_MASK  0x0       
+#define         DAT_CRC_FAIL_MASK  0x2        /* Data CRC Fail Mask */
+#define        nDAT_CRC_FAIL_MASK  0x0       
+#define          CMD_TIMEOUT_MASK  0x4        /* CMD Time Out Mask */
+#define         nCMD_TIMEOUT_MASK  0x0       
+#define          DAT_TIMEOUT_MASK  0x8        /* Data Time Out Mask */
+#define         nDAT_TIMEOUT_MASK  0x0       
+#define          TX_UNDERRUN_MASK  0x10       /* Transmit Underrun Mask */
+#define         nTX_UNDERRUN_MASK  0x0       
+#define           RX_OVERRUN_MASK  0x20       /* Receive Overrun Mask */
+#define          nRX_OVERRUN_MASK  0x0       
+#define         CMD_RESP_END_MASK  0x40       /* CMD Response End Mask */
+#define        nCMD_RESP_END_MASK  0x0       
+#define             CMD_SENT_MASK  0x80       /* CMD Sent Mask */
+#define            nCMD_SENT_MASK  0x0       
+#define              DAT_END_MASK  0x100      /* Data End Mask */
+#define             nDAT_END_MASK  0x0       
+#define        START_BIT_ERR_MASK  0x200      /* Start Bit Error Mask */
+#define       nSTART_BIT_ERR_MASK  0x0       
+#define          DAT_BLK_END_MASK  0x400      /* Data Block End Mask */
+#define         nDAT_BLK_END_MASK  0x0       
+#define              CMD_ACT_MASK  0x800      /* CMD Active Mask */
+#define             nCMD_ACT_MASK  0x0       
+#define               TX_ACT_MASK  0x1000     /* Transmit Active Mask */
+#define              nTX_ACT_MASK  0x0       
+#define               RX_ACT_MASK  0x2000     /* Receive Active Mask */
+#define              nRX_ACT_MASK  0x0       
+#define         TX_FIFO_STAT_MASK  0x4000     /* Transmit FIFO Status Mask */
+#define        nTX_FIFO_STAT_MASK  0x0       
+#define         RX_FIFO_STAT_MASK  0x8000     /* Receive FIFO Status Mask */
+#define        nRX_FIFO_STAT_MASK  0x0       
+#define         TX_FIFO_FULL_MASK  0x10000    /* Transmit FIFO Full Mask */
+#define        nTX_FIFO_FULL_MASK  0x0       
+#define         RX_FIFO_FULL_MASK  0x20000    /* Receive FIFO Full Mask */
+#define        nRX_FIFO_FULL_MASK  0x0       
+#define         TX_FIFO_ZERO_MASK  0x40000    /* Transmit FIFO Empty Mask */
+#define        nTX_FIFO_ZERO_MASK  0x0       
+#define          RX_DAT_ZERO_MASK  0x80000    /* Receive FIFO Empty Mask */
+#define         nRX_DAT_ZERO_MASK  0x0       
+#define           TX_DAT_RDY_MASK  0x100000   /* Transmit Data Available Mask */
+#define          nTX_DAT_RDY_MASK  0x0       
+#define          RX_FIFO_RDY_MASK  0x200000   /* Receive Data Available Mask */
+#define         nRX_FIFO_RDY_MASK  0x0       
+
+/* Bit masks for SDH_FIFO_CNT */
+
+#define                FIFO_COUNT  0x7fff     /* FIFO Count */
+
+/* Bit masks for SDH_E_STATUS */
+
+#define              SDIO_INT_DET  0x2        /* SDIO Int Detected */
+#define             nSDIO_INT_DET  0x0       
+#define               SD_CARD_DET  0x10       /* SD Card Detect */
+#define              nSD_CARD_DET  0x0       
+
+/* Bit masks for SDH_E_MASK */
+
+#define                  SDIO_MSK  0x2        /* Mask SDIO Int Detected */
+#define                 nSDIO_MSK  0x0       
+#define                   SCD_MSK  0x40       /* Mask Card Detect */
+#define                  nSCD_MSK  0x0       
+
+/* Bit masks for SDH_CFG */
+
+#define                   CLKS_EN  0x1        /* Clocks Enable */
+#define                  nCLKS_EN  0x0       
+#define                      SD4E  0x4        /* SDIO 4-Bit Enable */
+#define                     nSD4E  0x0       
+#define                       MWE  0x8        /* Moving Window Enable */
+#define                      nMWE  0x0       
+#define                    SD_RST  0x10       /* SDMMC Reset */
+#define                   nSD_RST  0x0       
+#define                 PUP_SDDAT  0x20       /* Pull-up SD_DAT */
+#define                nPUP_SDDAT  0x0       
+#define                PUP_SDDAT3  0x40       /* Pull-up SD_DAT3 */
+#define               nPUP_SDDAT3  0x0       
+#define                 PD_SDDAT3  0x80       /* Pull-down SD_DAT3 */
+#define                nPD_SDDAT3  0x0       
+
+/* Bit masks for SDH_RD_WAIT_EN */
+
+#define                       RWR  0x1        /* Read Wait Request */
+#define                      nRWR  0x0       
+
+/* Bit masks for ATAPI_CONTROL */
+
+#define                 PIO_START  0x1        /* Start PIO/Reg Op */
+#define                nPIO_START  0x0       
+#define               MULTI_START  0x2        /* Start Multi-DMA Op */
+#define              nMULTI_START  0x0       
+#define               ULTRA_START  0x4        /* Start Ultra-DMA Op */
+#define              nULTRA_START  0x0       
+#define                  XFER_DIR  0x8        /* Transfer Direction */
+#define                 nXFER_DIR  0x0       
+#define                  IORDY_EN  0x10       /* IORDY Enable */
+#define                 nIORDY_EN  0x0       
+#define                FIFO_FLUSH  0x20       /* Flush FIFOs */
+#define               nFIFO_FLUSH  0x0       
+#define                  SOFT_RST  0x40       /* Soft Reset */
+#define                 nSOFT_RST  0x0       
+#define                   DEV_RST  0x80       /* Device Reset */
+#define                  nDEV_RST  0x0       
+#define                TFRCNT_RST  0x100      /* Trans Count Reset */
+#define               nTFRCNT_RST  0x0       
+#define               END_ON_TERM  0x200      /* End/Terminate Select */
+#define              nEND_ON_TERM  0x0       
+#define               PIO_USE_DMA  0x400      /* PIO-DMA Enable */
+#define              nPIO_USE_DMA  0x0       
+#define          UDMAIN_FIFO_THRS  0xf000     /* Ultra DMA-IN FIFO Threshold */
+
+/* Bit masks for ATAPI_STATUS */
+
+#define               PIO_XFER_ON  0x1        /* PIO transfer in progress */
+#define              nPIO_XFER_ON  0x0       
+#define             MULTI_XFER_ON  0x2        /* Multi-word DMA transfer in progress */
+#define            nMULTI_XFER_ON  0x0       
+#define             ULTRA_XFER_ON  0x4        /* Ultra DMA transfer in progress */
+#define            nULTRA_XFER_ON  0x0       
+#define               ULTRA_IN_FL  0xf0       /* Ultra DMA Input FIFO Level */
+
+/* Bit masks for ATAPI_DEV_ADDR */
+
+#define                  DEV_ADDR  0x1f       /* Device Address */
+
+/* Bit masks for ATAPI_INT_MASK */
+
+#define        ATAPI_DEV_INT_MASK  0x1        /* Device interrupt mask */
+#define       nATAPI_DEV_INT_MASK  0x0       
+#define             PIO_DONE_MASK  0x2        /* PIO transfer done interrupt mask */
+#define            nPIO_DONE_MASK  0x0       
+#define           MULTI_DONE_MASK  0x4        /* Multi-DMA transfer done interrupt mask */
+#define          nMULTI_DONE_MASK  0x0       
+#define          UDMAIN_DONE_MASK  0x8        /* Ultra-DMA in transfer done interrupt mask */
+#define         nUDMAIN_DONE_MASK  0x0       
+#define         UDMAOUT_DONE_MASK  0x10       /* Ultra-DMA out transfer done interrupt mask */
+#define        nUDMAOUT_DONE_MASK  0x0       
+#define       HOST_TERM_XFER_MASK  0x20       /* Host terminate current transfer interrupt mask */
+#define      nHOST_TERM_XFER_MASK  0x0       
+#define           MULTI_TERM_MASK  0x40       /* Device terminate Multi-DMA transfer interrupt mask */
+#define          nMULTI_TERM_MASK  0x0       
+#define          UDMAIN_TERM_MASK  0x80       /* Device terminate Ultra-DMA-in transfer interrupt mask */
+#define         nUDMAIN_TERM_MASK  0x0       
+#define         UDMAOUT_TERM_MASK  0x100      /* Device terminate Ultra-DMA-out transfer interrupt mask */
+#define        nUDMAOUT_TERM_MASK  0x0       
+
+/* Bit masks for ATAPI_INT_STATUS */
+
+#define             ATAPI_DEV_INT  0x1        /* Device interrupt status */
+#define            nATAPI_DEV_INT  0x0       
+#define              PIO_DONE_INT  0x2        /* PIO transfer done interrupt status */
+#define             nPIO_DONE_INT  0x0       
+#define            MULTI_DONE_INT  0x4        /* Multi-DMA transfer done interrupt status */
+#define           nMULTI_DONE_INT  0x0       
+#define           UDMAIN_DONE_INT  0x8        /* Ultra-DMA in transfer done interrupt status */
+#define          nUDMAIN_DONE_INT  0x0       
+#define          UDMAOUT_DONE_INT  0x10       /* Ultra-DMA out transfer done interrupt status */
+#define         nUDMAOUT_DONE_INT  0x0       
+#define        HOST_TERM_XFER_INT  0x20       /* Host terminate current transfer interrupt status */
+#define       nHOST_TERM_XFER_INT  0x0       
+#define            MULTI_TERM_INT  0x40       /* Device terminate Multi-DMA transfer interrupt status */
+#define           nMULTI_TERM_INT  0x0       
+#define           UDMAIN_TERM_INT  0x80       /* Device terminate Ultra-DMA-in transfer interrupt status */
+#define          nUDMAIN_TERM_INT  0x0       
+#define          UDMAOUT_TERM_INT  0x100      /* Device terminate Ultra-DMA-out transfer interrupt status */
+#define         nUDMAOUT_TERM_INT  0x0       
+
+/* Bit masks for ATAPI_LINE_STATUS */
+
+#define                ATAPI_INTR  0x1        /* Device interrupt to host line status */
+#define               nATAPI_INTR  0x0       
+#define                ATAPI_DASP  0x2        /* Device dasp to host line status */
+#define               nATAPI_DASP  0x0       
+#define                ATAPI_CS0N  0x4        /* ATAPI chip select 0 line status */
+#define               nATAPI_CS0N  0x0       
+#define                ATAPI_CS1N  0x8        /* ATAPI chip select 1 line status */
+#define               nATAPI_CS1N  0x0       
+#define                ATAPI_ADDR  0x70       /* ATAPI address line status */
+#define              ATAPI_DMAREQ  0x80       /* ATAPI DMA request line status */
+#define             nATAPI_DMAREQ  0x0       
+#define             ATAPI_DMAACKN  0x100      /* ATAPI DMA acknowledge line status */
+#define            nATAPI_DMAACKN  0x0       
+#define               ATAPI_DIOWN  0x200      /* ATAPI write line status */
+#define              nATAPI_DIOWN  0x0       
+#define               ATAPI_DIORN  0x400      /* ATAPI read line status */
+#define              nATAPI_DIORN  0x0       
+#define               ATAPI_IORDY  0x800      /* ATAPI IORDY line status */
+#define              nATAPI_IORDY  0x0       
+
+/* Bit masks for ATAPI_SM_STATE */
+
+#define                PIO_CSTATE  0xf        /* PIO mode state machine current state */
+#define                DMA_CSTATE  0xf0       /* DMA mode state machine current state */
+#define             UDMAIN_CSTATE  0xf00      /* Ultra DMA-In mode state machine current state */
+#define            UDMAOUT_CSTATE  0xf000     /* ATAPI IORDY line status */
+
+/* Bit masks for ATAPI_TERMINATE */
+
+#define           ATAPI_HOST_TERM  0x1        /* Host terminationation */
+#define          nATAPI_HOST_TERM  0x0       
+
+/* Bit masks for ATAPI_REG_TIM_0 */
+
+#define                    T2_REG  0xff       /* End of cycle time for register access transfers */
+#define                  TEOC_REG  0xff00     /* Selects DIOR/DIOW pulsewidth */
+
+/* Bit masks for ATAPI_PIO_TIM_0 */
+
+#define                    T1_REG  0xf        /* Time from address valid to DIOR/DIOW */
+#define                T2_REG_PIO  0xff0      /* DIOR/DIOW pulsewidth */
+#define                    T4_REG  0xf000     /* DIOW data hold */
+
+/* Bit masks for ATAPI_PIO_TIM_1 */
+
+#define              TEOC_REG_PIO  0xff       /* End of cycle time for PIO access transfers. */
+
+/* Bit masks for ATAPI_MULTI_TIM_0 */
+
+#define                        TD  0xff       /* DIOR/DIOW asserted pulsewidth */
+#define                        TM  0xff00     /* Time from address valid to DIOR/DIOW */
+
+/* Bit masks for ATAPI_MULTI_TIM_1 */
+
+#define                       TKW  0xff       /* Selects DIOW negated pulsewidth */
+#define                       TKR  0xff00     /* Selects DIOR negated pulsewidth */
+
+/* Bit masks for ATAPI_MULTI_TIM_2 */
+
+#define                        TH  0xff       /* Selects DIOW data hold */
+#define                      TEOC  0xff00     /* Selects end of cycle for DMA */
+
+/* Bit masks for ATAPI_ULTRA_TIM_0 */
+
+#define                      TACK  0xff       /* Selects setup and hold times for TACK */
+#define                      TENV  0xff00     /* Selects envelope time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_1 */
+
+#define                      TDVS  0xff       /* Selects data valid setup time */
+#define                 TCYC_TDVS  0xff00     /* Selects cycle time - TDVS time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_2 */
+
+#define                       TSS  0xff       /* Selects time from STROBE edge to negation of DMARQ or assertion of STOP */
+#define                      TMLI  0xff00     /* Selects interlock time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_3 */
+
+#define                      TZAH  0xff       /* Selects minimum delay required for output */
+#define               READY_PAUSE  0xff00     /* Selects ready to pause */
+
+/* Bit masks for TIMER_ENABLE1 */
+
+#define                    TIMEN8  0x1        /* Timer 8 Enable */
+#define                   nTIMEN8  0x0       
+#define                    TIMEN9  0x2        /* Timer 9 Enable */
+#define                   nTIMEN9  0x0       
+#define                   TIMEN10  0x4        /* Timer 10 Enable */
+#define                  nTIMEN10  0x0       
+
+/* Bit masks for TIMER_DISABLE1 */
+
+#define                   TIMDIS8  0x1        /* Timer 8 Disable */
+#define                  nTIMDIS8  0x0       
+#define                   TIMDIS9  0x2        /* Timer 9 Disable */
+#define                  nTIMDIS9  0x0       
+#define                  TIMDIS10  0x4        /* Timer 10 Disable */
+#define                 nTIMDIS10  0x0       
+
+/* Bit masks for TIMER_STATUS1 */
+
+#define                    TIMIL8  0x1        /* Timer 8 Interrupt */
+#define                   nTIMIL8  0x0       
+#define                    TIMIL9  0x2        /* Timer 9 Interrupt */
+#define                   nTIMIL9  0x0       
+#define                   TIMIL10  0x4        /* Timer 10 Interrupt */
+#define                  nTIMIL10  0x0       
+#define                 TOVF_ERR8  0x10       /* Timer 8 Counter Overflow */
+#define                nTOVF_ERR8  0x0       
+#define                 TOVF_ERR9  0x20       /* Timer 9 Counter Overflow */
+#define                nTOVF_ERR9  0x0       
+#define                TOVF_ERR10  0x40       /* Timer 10 Counter Overflow */
+#define               nTOVF_ERR10  0x0       
+#define                     TRUN8  0x1000     /* Timer 8 Slave Enable Status */
+#define                    nTRUN8  0x0       
+#define                     TRUN9  0x2000     /* Timer 9 Slave Enable Status */
+#define                    nTRUN9  0x0       
+#define                    TRUN10  0x4000     /* Timer 10 Slave Enable Status */
+#define                   nTRUN10  0x0       
+
+/* Bit masks for EPPI0 are obtained from common base header for EPPIx (EPPI1 and EPPI2) */
+
+/* Bit masks for USB_FADDR */
+
+#define          FUNCTION_ADDRESS  0x7f       /* Function address */
+
+/* Bit masks for USB_POWER */
+
+#define           ENABLE_SUSPENDM  0x1        /* enable SuspendM output */
+#define          nENABLE_SUSPENDM  0x0       
+#define              SUSPEND_MODE  0x2        /* Suspend Mode indicator */
+#define             nSUSPEND_MODE  0x0       
+#define               RESUME_MODE  0x4        /* DMA Mode */
+#define              nRESUME_MODE  0x0       
+#define                     RESET  0x8        /* Reset indicator */
+#define                    nRESET  0x0       
+#define                   HS_MODE  0x10       /* High Speed mode indicator */
+#define                  nHS_MODE  0x0       
+#define                 HS_ENABLE  0x20       /* high Speed Enable */
+#define                nHS_ENABLE  0x0       
+#define                 SOFT_CONN  0x40       /* Soft connect */
+#define                nSOFT_CONN  0x0       
+#define                ISO_UPDATE  0x80       /* Isochronous update */
+#define               nISO_UPDATE  0x0       
+
+/* Bit masks for USB_INTRTX */
+
+#define                    EP0_TX  0x1        /* Tx Endpoint 0 interrupt */
+#define                   nEP0_TX  0x0       
+#define                    EP1_TX  0x2        /* Tx Endpoint 1 interrupt */
+#define                   nEP1_TX  0x0       
+#define                    EP2_TX  0x4        /* Tx Endpoint 2 interrupt */
+#define                   nEP2_TX  0x0       
+#define                    EP3_TX  0x8        /* Tx Endpoint 3 interrupt */
+#define                   nEP3_TX  0x0       
+#define                    EP4_TX  0x10       /* Tx Endpoint 4 interrupt */
+#define                   nEP4_TX  0x0       
+#define                    EP5_TX  0x20       /* Tx Endpoint 5 interrupt */
+#define                   nEP5_TX  0x0       
+#define                    EP6_TX  0x40       /* Tx Endpoint 6 interrupt */
+#define                   nEP6_TX  0x0       
+#define                    EP7_TX  0x80       /* Tx Endpoint 7 interrupt */
+#define                   nEP7_TX  0x0       
+
+/* Bit masks for USB_INTRRX */
+
+#define                    EP1_RX  0x2        /* Rx Endpoint 1 interrupt */
+#define                   nEP1_RX  0x0       
+#define                    EP2_RX  0x4        /* Rx Endpoint 2 interrupt */
+#define                   nEP2_RX  0x0       
+#define                    EP3_RX  0x8        /* Rx Endpoint 3 interrupt */
+#define                   nEP3_RX  0x0       
+#define                    EP4_RX  0x10       /* Rx Endpoint 4 interrupt */
+#define                   nEP4_RX  0x0       
+#define                    EP5_RX  0x20       /* Rx Endpoint 5 interrupt */
+#define                   nEP5_RX  0x0       
+#define                    EP6_RX  0x40       /* Rx Endpoint 6 interrupt */
+#define                   nEP6_RX  0x0       
+#define                    EP7_RX  0x80       /* Rx Endpoint 7 interrupt */
+#define                   nEP7_RX  0x0       
+
+/* Bit masks for USB_INTRTXE */
+
+#define                  EP0_TX_E  0x1        /* Endpoint 0 interrupt Enable */
+#define                 nEP0_TX_E  0x0       
+#define                  EP1_TX_E  0x2        /* Tx Endpoint 1 interrupt  Enable */
+#define                 nEP1_TX_E  0x0       
+#define                  EP2_TX_E  0x4        /* Tx Endpoint 2 interrupt  Enable */
+#define                 nEP2_TX_E  0x0       
+#define                  EP3_TX_E  0x8        /* Tx Endpoint 3 interrupt  Enable */
+#define                 nEP3_TX_E  0x0       
+#define                  EP4_TX_E  0x10       /* Tx Endpoint 4 interrupt  Enable */
+#define                 nEP4_TX_E  0x0       
+#define                  EP5_TX_E  0x20       /* Tx Endpoint 5 interrupt  Enable */
+#define                 nEP5_TX_E  0x0       
+#define                  EP6_TX_E  0x40       /* Tx Endpoint 6 interrupt  Enable */
+#define                 nEP6_TX_E  0x0       
+#define                  EP7_TX_E  0x80       /* Tx Endpoint 7 interrupt  Enable */
+#define                 nEP7_TX_E  0x0       
+
+/* Bit masks for USB_INTRRXE */
+
+#define                  EP1_RX_E  0x2        /* Rx Endpoint 1 interrupt  Enable */
+#define                 nEP1_RX_E  0x0       
+#define                  EP2_RX_E  0x4        /* Rx Endpoint 2 interrupt  Enable */
+#define                 nEP2_RX_E  0x0       
+#define                  EP3_RX_E  0x8        /* Rx Endpoint 3 interrupt  Enable */
+#define                 nEP3_RX_E  0x0       
+#define                  EP4_RX_E  0x10       /* Rx Endpoint 4 interrupt  Enable */
+#define                 nEP4_RX_E  0x0       
+#define                  EP5_RX_E  0x20       /* Rx Endpoint 5 interrupt  Enable */
+#define                 nEP5_RX_E  0x0       
+#define                  EP6_RX_E  0x40       /* Rx Endpoint 6 interrupt  Enable */
+#define                 nEP6_RX_E  0x0       
+#define                  EP7_RX_E  0x80       /* Rx Endpoint 7 interrupt  Enable */
+#define                 nEP7_RX_E  0x0       
+
+/* Bit masks for USB_INTRUSB */
+
+#define                 SUSPEND_B  0x1        /* Suspend indicator */
+#define                nSUSPEND_B  0x0       
+#define                  RESUME_B  0x2        /* Resume indicator */
+#define                 nRESUME_B  0x0       
+#define          RESET_OR_BABLE_B  0x4        /* Reset/babble indicator */
+#define         nRESET_OR_BABLE_B  0x0       
+#define                     SOF_B  0x8        /* Start of frame */
+#define                    nSOF_B  0x0       
+#define                    CONN_B  0x10       /* Connection indicator */
+#define                   nCONN_B  0x0       
+#define                  DISCON_B  0x20       /* Disconnect indicator */
+#define                 nDISCON_B  0x0       
+#define             SESSION_REQ_B  0x40       /* Session Request */
+#define            nSESSION_REQ_B  0x0       
+#define              VBUS_ERROR_B  0x80       /* Vbus threshold indicator */
+#define             nVBUS_ERROR_B  0x0       
+
+/* Bit masks for USB_INTRUSBE */
+
+#define                SUSPEND_BE  0x1        /* Suspend indicator int enable */
+#define               nSUSPEND_BE  0x0       
+#define                 RESUME_BE  0x2        /* Resume indicator int enable */
+#define                nRESUME_BE  0x0       
+#define         RESET_OR_BABLE_BE  0x4        /* Reset/babble indicator int enable */
+#define        nRESET_OR_BABLE_BE  0x0       
+#define                    SOF_BE  0x8        /* Start of frame int enable */
+#define                   nSOF_BE  0x0       
+#define                   CONN_BE  0x10       /* Connection indicator int enable */
+#define                  nCONN_BE  0x0       
+#define                 DISCON_BE  0x20       /* Disconnect indicator int enable */
+#define                nDISCON_BE  0x0       
+#define            SESSION_REQ_BE  0x40       /* Session Request int enable */
+#define           nSESSION_REQ_BE  0x0       
+#define             VBUS_ERROR_BE  0x80       /* Vbus threshold indicator int enable */
+#define            nVBUS_ERROR_BE  0x0       
+
+/* Bit masks for USB_FRAME */
+
+#define              FRAME_NUMBER  0x7ff      /* Frame number */
+
+/* Bit masks for USB_INDEX */
+
+#define         SELECTED_ENDPOINT  0xf        /* selected endpoint */
+
+/* Bit masks for USB_GLOBAL_CTL */
+
+#define                GLOBAL_ENA  0x1        /* enables USB module */
+#define               nGLOBAL_ENA  0x0       
+#define                EP1_TX_ENA  0x2        /* Transmit endpoint 1 enable */
+#define               nEP1_TX_ENA  0x0       
+#define                EP2_TX_ENA  0x4        /* Transmit endpoint 2 enable */
+#define               nEP2_TX_ENA  0x0       
+#define                EP3_TX_ENA  0x8        /* Transmit endpoint 3 enable */
+#define               nEP3_TX_ENA  0x0       
+#define                EP4_TX_ENA  0x10       /* Transmit endpoint 4 enable */
+#define               nEP4_TX_ENA  0x0       
+#define                EP5_TX_ENA  0x20       /* Transmit endpoint 5 enable */
+#define               nEP5_TX_ENA  0x0       
+#define                EP6_TX_ENA  0x40       /* Transmit endpoint 6 enable */
+#define               nEP6_TX_ENA  0x0       
+#define                EP7_TX_ENA  0x80       /* Transmit endpoint 7 enable */
+#define               nEP7_TX_ENA  0x0       
+#define                EP1_RX_ENA  0x100      /* Receive endpoint 1 enable */
+#define               nEP1_RX_ENA  0x0       
+#define                EP2_RX_ENA  0x200      /* Receive endpoint 2 enable */
+#define               nEP2_RX_ENA  0x0       
+#define                EP3_RX_ENA  0x400      /* Receive endpoint 3 enable */
+#define               nEP3_RX_ENA  0x0       
+#define                EP4_RX_ENA  0x800      /* Receive endpoint 4 enable */
+#define               nEP4_RX_ENA  0x0       
+#define                EP5_RX_ENA  0x1000     /* Receive endpoint 5 enable */
+#define               nEP5_RX_ENA  0x0       
+#define                EP6_RX_ENA  0x2000     /* Receive endpoint 6 enable */
+#define               nEP6_RX_ENA  0x0       
+#define                EP7_RX_ENA  0x4000     /* Receive endpoint 7 enable */
+#define               nEP7_RX_ENA  0x0       
+
+/* Bit masks for USB_OTG_DEV_CTL */
+
+#define                   SESSION  0x1        /* session indicator */
+#define                  nSESSION  0x0       
+#define                  HOST_REQ  0x2        /* Host negotiation request */
+#define                 nHOST_REQ  0x0       
+#define                 HOST_MODE  0x4        /* indicates USBDRC is a host */
+#define                nHOST_MODE  0x0       
+#define                     VBUS0  0x8        /* Vbus level indicator[0] */
+#define                    nVBUS0  0x0       
+#define                     VBUS1  0x10       /* Vbus level indicator[1] */
+#define                    nVBUS1  0x0       
+#define                     LSDEV  0x20       /* Low-speed indicator */
+#define                    nLSDEV  0x0       
+#define                     FSDEV  0x40       /* Full or High-speed indicator */
+#define                    nFSDEV  0x0       
+#define                  B_DEVICE  0x80       /* A' or 'B' device indicator */
+#define                 nB_DEVICE  0x0       
+
+/* Bit masks for USB_OTG_VBUS_IRQ */
+
+#define             DRIVE_VBUS_ON  0x1        /* indicator to drive VBUS control circuit */
+#define            nDRIVE_VBUS_ON  0x0       
+#define            DRIVE_VBUS_OFF  0x2        /* indicator to shut off charge pump */
+#define           nDRIVE_VBUS_OFF  0x0       
+#define           CHRG_VBUS_START  0x4        /* indicator for external circuit to start charging VBUS */
+#define          nCHRG_VBUS_START  0x0       
+#define             CHRG_VBUS_END  0x8        /* indicator for external circuit to end charging VBUS */
+#define            nCHRG_VBUS_END  0x0       
+#define        DISCHRG_VBUS_START  0x10       /* indicator to start discharging VBUS */
+#define       nDISCHRG_VBUS_START  0x0       
+#define          DISCHRG_VBUS_END  0x20       /* indicator to stop discharging VBUS */
+#define         nDISCHRG_VBUS_END  0x0       
+
+/* Bit masks for USB_OTG_VBUS_MASK */
+
+#define         DRIVE_VBUS_ON_ENA  0x1        /* enable DRIVE_VBUS_ON interrupt */
+#define        nDRIVE_VBUS_ON_ENA  0x0       
+#define        DRIVE_VBUS_OFF_ENA  0x2        /* enable DRIVE_VBUS_OFF interrupt */
+#define       nDRIVE_VBUS_OFF_ENA  0x0       
+#define       CHRG_VBUS_START_ENA  0x4        /* enable CHRG_VBUS_START interrupt */
+#define      nCHRG_VBUS_START_ENA  0x0       
+#define         CHRG_VBUS_END_ENA  0x8        /* enable CHRG_VBUS_END interrupt */
+#define        nCHRG_VBUS_END_ENA  0x0       
+#define    DISCHRG_VBUS_START_ENA  0x10       /* enable DISCHRG_VBUS_START interrupt */
+#define   nDISCHRG_VBUS_START_ENA  0x0       
+#define      DISCHRG_VBUS_END_ENA  0x20       /* enable DISCHRG_VBUS_END interrupt */
+#define     nDISCHRG_VBUS_END_ENA  0x0       
+
+/* Bit masks for USB_CSR0 */
+
+#define                  RXPKTRDY  0x1        /* data packet receive indicator */
+#define                 nRXPKTRDY  0x0       
+#define                  TXPKTRDY  0x2        /* data packet in FIFO indicator */
+#define                 nTXPKTRDY  0x0       
+#define                STALL_SENT  0x4        /* STALL handshake sent */
+#define               nSTALL_SENT  0x0       
+#define                   DATAEND  0x8        /* Data end indicator */
+#define                  nDATAEND  0x0       
+#define                  SETUPEND  0x10       /* Setup end */
+#define                 nSETUPEND  0x0       
+#define                 SENDSTALL  0x20       /* Send STALL handshake */
+#define                nSENDSTALL  0x0       
+#define         SERVICED_RXPKTRDY  0x40       /* used to clear the RxPktRdy bit */
+#define        nSERVICED_RXPKTRDY  0x0       
+#define         SERVICED_SETUPEND  0x80       /* used to clear the SetupEnd bit */
+#define        nSERVICED_SETUPEND  0x0       
+#define                 FLUSHFIFO  0x100      /* flush endpoint FIFO */
+#define                nFLUSHFIFO  0x0       
+#define          STALL_RECEIVED_H  0x4        /* STALL handshake received host mode */
+#define         nSTALL_RECEIVED_H  0x0       
+#define                SETUPPKT_H  0x8        /* send Setup token host mode */
+#define               nSETUPPKT_H  0x0       
+#define                   ERROR_H  0x10       /* timeout error indicator host mode */
+#define                  nERROR_H  0x0       
+#define                  REQPKT_H  0x20       /* Request an IN transaction host mode */
+#define                 nREQPKT_H  0x0       
+#define               STATUSPKT_H  0x40       /* Status stage transaction host mode */
+#define              nSTATUSPKT_H  0x0       
+#define             NAK_TIMEOUT_H  0x80       /* EP0 halted after a NAK host mode */
+#define            nNAK_TIMEOUT_H  0x0       
+
+/* Bit masks for USB_COUNT0 */
+
+#define              EP0_RX_COUNT  0x7f       /* number of received bytes in EP0 FIFO */
+
+/* Bit masks for USB_NAKLIMIT0 */
+
+#define             EP0_NAK_LIMIT  0x1f       /* number of frames/micro frames after which EP0 timeouts */
+
+/* Bit masks for USB_TX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_T  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_RX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_R  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_TXCSR */
+
+#define                TXPKTRDY_T  0x1        /* data packet in FIFO indicator */
+#define               nTXPKTRDY_T  0x0       
+#define          FIFO_NOT_EMPTY_T  0x2        /* FIFO not empty */
+#define         nFIFO_NOT_EMPTY_T  0x0       
+#define                UNDERRUN_T  0x4        /* TxPktRdy not set  for an IN token */
+#define               nUNDERRUN_T  0x0       
+#define               FLUSHFIFO_T  0x8        /* flush endpoint FIFO */
+#define              nFLUSHFIFO_T  0x0       
+#define              STALL_SEND_T  0x10       /* issue a Stall handshake */
+#define             nSTALL_SEND_T  0x0       
+#define              STALL_SENT_T  0x20       /* Stall handshake transmitted */
+#define             nSTALL_SENT_T  0x0       
+#define        CLEAR_DATATOGGLE_T  0x40       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_T  0x0       
+#define                INCOMPTX_T  0x80       /* indicates that a large packet is split */
+#define               nINCOMPTX_T  0x0       
+#define              DMAREQMODE_T  0x400      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_T  0x0       
+#define        FORCE_DATATOGGLE_T  0x800      /* Force data toggle */
+#define       nFORCE_DATATOGGLE_T  0x0       
+#define              DMAREQ_ENA_T  0x1000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_T  0x0       
+#define                     ISO_T  0x4000     /* enable Isochronous transfers */
+#define                    nISO_T  0x0       
+#define                 AUTOSET_T  0x8000     /* allows TxPktRdy to be set automatically */
+#define                nAUTOSET_T  0x0       
+#define                  ERROR_TH  0x4        /* error condition host mode */
+#define                 nERROR_TH  0x0       
+#define         STALL_RECEIVED_TH  0x20       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_TH  0x0       
+#define            NAK_TIMEOUT_TH  0x80       /* NAK timeout host mode */
+#define           nNAK_TIMEOUT_TH  0x0       
+
+/* Bit masks for USB_TXCOUNT */
+
+#define                  TX_COUNT  0x1fff     /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* Bit masks for USB_RXCSR */
+
+#define                RXPKTRDY_R  0x1        /* data packet in FIFO indicator */
+#define               nRXPKTRDY_R  0x0       
+#define               FIFO_FULL_R  0x2        /* FIFO not empty */
+#define              nFIFO_FULL_R  0x0       
+#define                 OVERRUN_R  0x4        /* TxPktRdy not set  for an IN token */
+#define                nOVERRUN_R  0x0       
+#define               DATAERROR_R  0x8        /* Out packet cannot be loaded into Rx  FIFO */
+#define              nDATAERROR_R  0x0       
+#define               FLUSHFIFO_R  0x10       /* flush endpoint FIFO */
+#define              nFLUSHFIFO_R  0x0       
+#define              STALL_SEND_R  0x20       /* issue a Stall handshake */
+#define             nSTALL_SEND_R  0x0       
+#define              STALL_SENT_R  0x40       /* Stall handshake transmitted */
+#define             nSTALL_SENT_R  0x0       
+#define        CLEAR_DATATOGGLE_R  0x80       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_R  0x0       
+#define                INCOMPRX_R  0x100      /* indicates that a large packet is split */
+#define               nINCOMPRX_R  0x0       
+#define              DMAREQMODE_R  0x800      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_R  0x0       
+#define                 DISNYET_R  0x1000     /* disable Nyet handshakes */
+#define                nDISNYET_R  0x0       
+#define              DMAREQ_ENA_R  0x2000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_R  0x0       
+#define                     ISO_R  0x4000     /* enable Isochronous transfers */
+#define                    nISO_R  0x0       
+#define               AUTOCLEAR_R  0x8000     /* allows TxPktRdy to be set automatically */
+#define              nAUTOCLEAR_R  0x0       
+#define                  ERROR_RH  0x4        /* TxPktRdy not set  for an IN token host mode */
+#define                 nERROR_RH  0x0       
+#define                 REQPKT_RH  0x20       /* request an IN transaction host mode */
+#define                nREQPKT_RH  0x0       
+#define         STALL_RECEIVED_RH  0x40       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_RH  0x0       
+#define               INCOMPRX_RH  0x100      /* indicates that a large packet is split host mode */
+#define              nINCOMPRX_RH  0x0       
+#define             DMAREQMODE_RH  0x800      /* DMA mode (0 or 1) selection host mode */
+#define            nDMAREQMODE_RH  0x0       
+#define                AUTOREQ_RH  0x4000     /* sets ReqPkt automatically host mode */
+#define               nAUTOREQ_RH  0x0       
+
+/* Bit masks for USB_RXCOUNT */
+
+#define                  RX_COUNT  0x1fff     /* Number of received bytes in the packet in the Rx FIFO */
+
+/* Bit masks for USB_TXTYPE */
+
+#define            TARGET_EP_NO_T  0xf        /* EP number */
+#define                PROTOCOL_T  0xc        /* transfer type */
+
+/* Bit masks for USB_TXINTERVAL */
+
+#define          TX_POLL_INTERVAL  0xff       /* polling interval for selected Tx EP */
+
+/* Bit masks for USB_RXTYPE */
+
+#define            TARGET_EP_NO_R  0xf        /* EP number */
+#define                PROTOCOL_R  0xc        /* transfer type */
+
+/* Bit masks for USB_RXINTERVAL */
+
+#define          RX_POLL_INTERVAL  0xff       /* polling interval for selected Rx EP */
+
+/* Bit masks for USB_DMA_INTERRUPT */
+
+#define                  DMA0_INT  0x1        /* DMA0 pending interrupt */
+#define                 nDMA0_INT  0x0       
+#define                  DMA1_INT  0x2        /* DMA1 pending interrupt */
+#define                 nDMA1_INT  0x0       
+#define                  DMA2_INT  0x4        /* DMA2 pending interrupt */
+#define                 nDMA2_INT  0x0       
+#define                  DMA3_INT  0x8        /* DMA3 pending interrupt */
+#define                 nDMA3_INT  0x0       
+#define                  DMA4_INT  0x10       /* DMA4 pending interrupt */
+#define                 nDMA4_INT  0x0       
+#define                  DMA5_INT  0x20       /* DMA5 pending interrupt */
+#define                 nDMA5_INT  0x0       
+#define                  DMA6_INT  0x40       /* DMA6 pending interrupt */
+#define                 nDMA6_INT  0x0       
+#define                  DMA7_INT  0x80       /* DMA7 pending interrupt */
+#define                 nDMA7_INT  0x0       
+
+/* Bit masks for USB_DMAxCONTROL */
+
+#define                   DMA_ENA  0x1        /* DMA enable */
+#define                  nDMA_ENA  0x0       
+#define                 DIRECTION  0x2        /* direction of DMA transfer */
+#define                nDIRECTION  0x0       
+#define                      MODE  0x4        /* DMA Bus error */
+#define                     nMODE  0x0       
+#define                   INT_ENA  0x8        /* Interrupt enable */
+#define                  nINT_ENA  0x0       
+#define                     EPNUM  0xf0       /* EP number */
+#define                  BUSERROR  0x100      /* DMA Bus error */
+#define                 nBUSERROR  0x0       
+
+/* Bit masks for USB_DMAxADDRHIGH */
+
+#define             DMA_ADDR_HIGH  0xffff     /* Upper 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxADDRLOW */
+
+#define              DMA_ADDR_LOW  0xffff     /* Lower 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTHIGH */
+
+#define            DMA_COUNT_HIGH  0xffff     /* Upper 16-bits of byte count of DMA transfer for DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTLOW */
+
+#define             DMA_COUNT_LOW  0xffff     /* Lower 16-bits of byte count of DMA transfer for DMA master channel */
+
+/* Bit masks for HMDMAx_CONTROL */
+
+#define                   HMDMAEN  0x1        /* Handshake MDMA Enable */
+#define                  nHMDMAEN  0x0       
+#define                       REP  0x2        /* Handshake MDMA Request Polarity */
+#define                      nREP  0x0       
+#define                       UTE  0x8        /* Urgency Threshold Enable */
+#define                      nUTE  0x0       
+#define                       OIE  0x10       /* Overflow Interrupt Enable */
+#define                      nOIE  0x0       
+#define                      BDIE  0x20       /* Block Done Interrupt Enable */
+#define                     nBDIE  0x0       
+#define                      MBDI  0x40       /* Mask Block Done Interrupt */
+#define                     nMBDI  0x0       
+#define                       DRQ  0x300      /* Handshake MDMA Request Type */
+#define                       RBC  0x1000     /* Force Reload of BCOUNT */
+#define                      nRBC  0x0       
+#define                        PS  0x2000     /* Pin Status */
+#define                       nPS  0x0       
+#define                        OI  0x4000     /* Overflow Interrupt Generated */
+#define                       nOI  0x0       
+#define                       BDI  0x8000     /* Block Done Interrupt Generated */
+#define                      nBDI  0x0       
+
+/* ******************************************* */
+/*     MULTI BIT MACRO ENUMERATIONS            */
+/* ******************************************* */
+
+
+#endif /* _DEF_BF548_H */
diff --git a/include/asm-blackfin/mach-bf548/defBF549.h b/include/asm-blackfin/mach-bf548/defBF549.h
new file mode 100644
index 0000000..b1cc1c0
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/defBF549.h
@@ -0,0 +1,3472 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/defBF549.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF549_H
+#define _DEF_BF549_H
+
+/* Include all Core registers and bit definitions */
+#include <asm/mach-common/def_LPBlackfin.h>
+
+
+/* SYSTEM & MMR ADDRESS DEFINITIONS FOR ADSP-BF549 */
+
+/* Include defBF54x_base.h for the set of #defines that are common to all ADSP-BF54x processors */
+#include "defBF54x_base.h"
+
+/* The following are the #defines needed by ADSP-BF549 that are not in the common header */
+
+/* Timer Registers */
+
+#define                    TIMER8_CONFIG  0xffc00600   /* Timer 8 Configuration Register */
+#define                   TIMER8_COUNTER  0xffc00604   /* Timer 8 Counter Register */
+#define                    TIMER8_PERIOD  0xffc00608   /* Timer 8 Period Register */
+#define                     TIMER8_WIDTH  0xffc0060c   /* Timer 8 Width Register */
+#define                    TIMER9_CONFIG  0xffc00610   /* Timer 9 Configuration Register */
+#define                   TIMER9_COUNTER  0xffc00614   /* Timer 9 Counter Register */
+#define                    TIMER9_PERIOD  0xffc00618   /* Timer 9 Period Register */
+#define                     TIMER9_WIDTH  0xffc0061c   /* Timer 9 Width Register */
+#define                   TIMER10_CONFIG  0xffc00620   /* Timer 10 Configuration Register */
+#define                  TIMER10_COUNTER  0xffc00624   /* Timer 10 Counter Register */
+#define                   TIMER10_PERIOD  0xffc00628   /* Timer 10 Period Register */
+#define                    TIMER10_WIDTH  0xffc0062c   /* Timer 10 Width Register */
+
+/* Timer Group of 3 Registers */
+
+#define                    TIMER_ENABLE1  0xffc00640   /* Timer Group of 3 Enable Register */
+#define                   TIMER_DISABLE1  0xffc00644   /* Timer Group of 3 Disable Register */
+#define                    TIMER_STATUS1  0xffc00648   /* Timer Group of 3 Status Register */
+
+/* SPORT0 Registers */
+
+#define                      SPORT0_TCR1  0xffc00800   /* SPORT0 Transmit Configuration 1 Register */
+#define                      SPORT0_TCR2  0xffc00804   /* SPORT0 Transmit Configuration 2 Register */
+#define                   SPORT0_TCLKDIV  0xffc00808   /* SPORT0 Transmit Serial Clock Divider Register */
+#define                    SPORT0_TFSDIV  0xffc0080c   /* SPORT0 Transmit Frame Sync Divider Register */
+#define                        SPORT0_TX  0xffc00810   /* SPORT0 Transmit Data Register */
+#define                        SPORT0_RX  0xffc00818   /* SPORT0 Receive Data Register */
+#define                      SPORT0_RCR1  0xffc00820   /* SPORT0 Receive Configuration 1 Register */
+#define                      SPORT0_RCR2  0xffc00824   /* SPORT0 Receive Configuration 2 Register */
+#define                   SPORT0_RCLKDIV  0xffc00828   /* SPORT0 Receive Serial Clock Divider Register */
+#define                    SPORT0_RFSDIV  0xffc0082c   /* SPORT0 Receive Frame Sync Divider Register */
+#define                      SPORT0_STAT  0xffc00830   /* SPORT0 Status Register */
+#define                      SPORT0_CHNL  0xffc00834   /* SPORT0 Current Channel Register */
+#define                     SPORT0_MCMC1  0xffc00838   /* SPORT0 Multi channel Configuration Register 1 */
+#define                     SPORT0_MCMC2  0xffc0083c   /* SPORT0 Multi channel Configuration Register 2 */
+#define                     SPORT0_MTCS0  0xffc00840   /* SPORT0 Multi channel Transmit Select Register 0 */
+#define                     SPORT0_MTCS1  0xffc00844   /* SPORT0 Multi channel Transmit Select Register 1 */
+#define                     SPORT0_MTCS2  0xffc00848   /* SPORT0 Multi channel Transmit Select Register 2 */
+#define                     SPORT0_MTCS3  0xffc0084c   /* SPORT0 Multi channel Transmit Select Register 3 */
+#define                     SPORT0_MRCS0  0xffc00850   /* SPORT0 Multi channel Receive Select Register 0 */
+#define                     SPORT0_MRCS1  0xffc00854   /* SPORT0 Multi channel Receive Select Register 1 */
+#define                     SPORT0_MRCS2  0xffc00858   /* SPORT0 Multi channel Receive Select Register 2 */
+#define                     SPORT0_MRCS3  0xffc0085c   /* SPORT0 Multi channel Receive Select Register 3 */
+
+/* EPPI0 Registers */
+
+#define                     EPPI0_STATUS  0xffc01000   /* EPPI0 Status Register */
+#define                     EPPI0_HCOUNT  0xffc01004   /* EPPI0 Horizontal Transfer Count Register */
+#define                     EPPI0_HDELAY  0xffc01008   /* EPPI0 Horizontal Delay Count Register */
+#define                     EPPI0_VCOUNT  0xffc0100c   /* EPPI0 Vertical Transfer Count Register */
+#define                     EPPI0_VDELAY  0xffc01010   /* EPPI0 Vertical Delay Count Register */
+#define                      EPPI0_FRAME  0xffc01014   /* EPPI0 Lines per Frame Register */
+#define                       EPPI0_LINE  0xffc01018   /* EPPI0 Samples per Line Register */
+#define                     EPPI0_CLKDIV  0xffc0101c   /* EPPI0 Clock Divide Register */
+#define                    EPPI0_CONTROL  0xffc01020   /* EPPI0 Control Register */
+#define                   EPPI0_FS1W_HBL  0xffc01024   /* EPPI0 FS1 Width Register / EPPI0 Horizontal Blanking Samples Per Line Register */
+#define                  EPPI0_FS1P_AVPL  0xffc01028   /* EPPI0 FS1 Period Register / EPPI0 Active Video Samples Per Line Register */
+#define                   EPPI0_FS2W_LVB  0xffc0102c   /* EPPI0 FS2 Width Register / EPPI0 Lines of Vertical Blanking Register */
+#define                  EPPI0_FS2P_LAVF  0xffc01030   /* EPPI0 FS2 Period Register/ EPPI0 Lines of Active Video Per Field Register */
+#define                       EPPI0_CLIP  0xffc01034   /* EPPI0 Clipping Register */
+
+/* UART2 Registers */
+
+#define                        UART2_DLL  0xffc02100   /* Divisor Latch Low Byte */
+#define                        UART2_DLH  0xffc02104   /* Divisor Latch High Byte */
+#define                       UART2_GCTL  0xffc02108   /* Global Control Register */
+#define                        UART2_LCR  0xffc0210c   /* Line Control Register */
+#define                        UART2_MCR  0xffc02110   /* Modem Control Register */
+#define                        UART2_LSR  0xffc02114   /* Line Status Register */
+#define                        UART2_MSR  0xffc02118   /* Modem Status Register */
+#define                        UART2_SCR  0xffc0211c   /* Scratch Register */
+#define                    UART2_IER_SET  0xffc02120   /* Interrupt Enable Register Set */
+#define                  UART2_IER_CLEAR  0xffc02124   /* Interrupt Enable Register Clear */
+#define                        UART2_RBR  0xffc0212c   /* Receive Buffer Register */
+
+/* Two Wire Interface Registers (TWI1) */
+
+#define                      TWI1_CLKDIV  0xffc02200   /* Clock Divider Register */
+#define                     TWI1_CONTROL  0xffc02204   /* TWI Control Register */
+#define                  TWI1_SLAVE_CTRL  0xffc02208   /* TWI Slave Mode Control Register */
+#define                  TWI1_SLAVE_STAT  0xffc0220c   /* TWI Slave Mode Status Register */
+#define                  TWI1_SLAVE_ADDR  0xffc02210   /* TWI Slave Mode Address Register */
+#define                 TWI1_MASTER_CTRL  0xffc02214   /* TWI Master Mode Control Register */
+#define                 TWI1_MASTER_STAT  0xffc02218   /* TWI Master Mode Status Register */
+#define                 TWI1_MASTER_ADDR  0xffc0221c   /* TWI Master Mode Address Register */
+#define                    TWI1_INT_STAT  0xffc02220   /* TWI Interrupt Status Register */
+#define                    TWI1_INT_MASK  0xffc02224   /* TWI Interrupt Mask Register */
+#define                   TWI1_FIFO_CTRL  0xffc02228   /* TWI FIFO Control Register */
+#define                   TWI1_FIFO_STAT  0xffc0222c   /* TWI FIFO Status Register */
+#define                   TWI1_XMT_DATA8  0xffc02280   /* TWI FIFO Transmit Data Single Byte Register */
+#define                  TWI1_XMT_DATA16  0xffc02284   /* TWI FIFO Transmit Data Double Byte Register */
+#define                   TWI1_RCV_DATA8  0xffc02288   /* TWI FIFO Receive Data Single Byte Register */
+#define                  TWI1_RCV_DATA16  0xffc0228c   /* TWI FIFO Receive Data Double Byte Register */
+
+/* SPI2  Registers */
+
+#define                         SPI2_CTL  0xffc02400   /* SPI2 Control Register */
+#define                         SPI2_FLG  0xffc02404   /* SPI2 Flag Register */
+#define                        SPI2_STAT  0xffc02408   /* SPI2 Status Register */
+#define                        SPI2_TDBR  0xffc0240c   /* SPI2 Transmit Data Buffer Register */
+#define                        SPI2_RDBR  0xffc02410   /* SPI2 Receive Data Buffer Register */
+#define                        SPI2_BAUD  0xffc02414   /* SPI2 Baud Rate Register */
+#define                      SPI2_SHADOW  0xffc02418   /* SPI2 Receive Data Buffer Shadow Register */
+
+/* MXVR Registers */
+
+#define                      MXVR_CONFIG  0xffc02700   /* MXVR Configuration Register */
+#define                     MXVR_STATE_0  0xffc02708   /* MXVR State Register 0 */
+#define                     MXVR_STATE_1  0xffc0270c   /* MXVR State Register 1 */
+#define                  MXVR_INT_STAT_0  0xffc02710   /* MXVR Interrupt Status Register 0 */
+#define                  MXVR_INT_STAT_1  0xffc02714   /* MXVR Interrupt Status Register 1 */
+#define                    MXVR_INT_EN_0  0xffc02718   /* MXVR Interrupt Enable Register 0 */
+#define                    MXVR_INT_EN_1  0xffc0271c   /* MXVR Interrupt Enable Register 1 */
+#define                    MXVR_POSITION  0xffc02720   /* MXVR Node Position Register */
+#define                MXVR_MAX_POSITION  0xffc02724   /* MXVR Maximum Node Position Register */
+#define                       MXVR_DELAY  0xffc02728   /* MXVR Node Frame Delay Register */
+#define                   MXVR_MAX_DELAY  0xffc0272c   /* MXVR Maximum Node Frame Delay Register */
+#define                       MXVR_LADDR  0xffc02730   /* MXVR Logical Address Register */
+#define                       MXVR_GADDR  0xffc02734   /* MXVR Group Address Register */
+#define                       MXVR_AADDR  0xffc02738   /* MXVR Alternate Address Register */
+
+/* MXVR Allocation Table Registers */
+
+#define                     MXVR_ALLOC_0  0xffc0273c   /* MXVR Allocation Table Register 0 */
+#define                     MXVR_ALLOC_1  0xffc02740   /* MXVR Allocation Table Register 1 */
+#define                     MXVR_ALLOC_2  0xffc02744   /* MXVR Allocation Table Register 2 */
+#define                     MXVR_ALLOC_3  0xffc02748   /* MXVR Allocation Table Register 3 */
+#define                     MXVR_ALLOC_4  0xffc0274c   /* MXVR Allocation Table Register 4 */
+#define                     MXVR_ALLOC_5  0xffc02750   /* MXVR Allocation Table Register 5 */
+#define                     MXVR_ALLOC_6  0xffc02754   /* MXVR Allocation Table Register 6 */
+#define                     MXVR_ALLOC_7  0xffc02758   /* MXVR Allocation Table Register 7 */
+#define                     MXVR_ALLOC_8  0xffc0275c   /* MXVR Allocation Table Register 8 */
+#define                     MXVR_ALLOC_9  0xffc02760   /* MXVR Allocation Table Register 9 */
+#define                    MXVR_ALLOC_10  0xffc02764   /* MXVR Allocation Table Register 10 */
+#define                    MXVR_ALLOC_11  0xffc02768   /* MXVR Allocation Table Register 11 */
+#define                    MXVR_ALLOC_12  0xffc0276c   /* MXVR Allocation Table Register 12 */
+#define                    MXVR_ALLOC_13  0xffc02770   /* MXVR Allocation Table Register 13 */
+#define                    MXVR_ALLOC_14  0xffc02774   /* MXVR Allocation Table Register 14 */
+
+/* MXVR Channel Assign Registers */
+
+#define                MXVR_SYNC_LCHAN_0  0xffc02778   /* MXVR Sync Data Logical Channel Assign Register 0 */
+#define                MXVR_SYNC_LCHAN_1  0xffc0277c   /* MXVR Sync Data Logical Channel Assign Register 1 */
+#define                MXVR_SYNC_LCHAN_2  0xffc02780   /* MXVR Sync Data Logical Channel Assign Register 2 */
+#define                MXVR_SYNC_LCHAN_3  0xffc02784   /* MXVR Sync Data Logical Channel Assign Register 3 */
+#define                MXVR_SYNC_LCHAN_4  0xffc02788   /* MXVR Sync Data Logical Channel Assign Register 4 */
+#define                MXVR_SYNC_LCHAN_5  0xffc0278c   /* MXVR Sync Data Logical Channel Assign Register 5 */
+#define                MXVR_SYNC_LCHAN_6  0xffc02790   /* MXVR Sync Data Logical Channel Assign Register 6 */
+#define                MXVR_SYNC_LCHAN_7  0xffc02794   /* MXVR Sync Data Logical Channel Assign Register 7 */
+
+/* MXVR DMA0 Registers */
+
+#define                 MXVR_DMA0_CONFIG  0xffc02798   /* MXVR Sync Data DMA0 Config Register */
+#define             MXVR_DMA0_START_ADDR  0xffc0279c   /* MXVR Sync Data DMA0 Start Address */
+#define                  MXVR_DMA0_COUNT  0xffc027a0   /* MXVR Sync Data DMA0 Loop Count Register */
+#define              MXVR_DMA0_CURR_ADDR  0xffc027a4   /* MXVR Sync Data DMA0 Current Address */
+#define             MXVR_DMA0_CURR_COUNT  0xffc027a8   /* MXVR Sync Data DMA0 Current Loop Count */
+
+/* MXVR DMA1 Registers */
+
+#define                 MXVR_DMA1_CONFIG  0xffc027ac   /* MXVR Sync Data DMA1 Config Register */
+#define             MXVR_DMA1_START_ADDR  0xffc027b0   /* MXVR Sync Data DMA1 Start Address */
+#define                  MXVR_DMA1_COUNT  0xffc027b4   /* MXVR Sync Data DMA1 Loop Count Register */
+#define              MXVR_DMA1_CURR_ADDR  0xffc027b8   /* MXVR Sync Data DMA1 Current Address */
+#define             MXVR_DMA1_CURR_COUNT  0xffc027bc   /* MXVR Sync Data DMA1 Current Loop Count */
+
+/* MXVR DMA2 Registers */
+
+#define                 MXVR_DMA2_CONFIG  0xffc027c0   /* MXVR Sync Data DMA2 Config Register */
+#define             MXVR_DMA2_START_ADDR  0xffc027c4   /* MXVR Sync Data DMA2 Start Address */
+#define                  MXVR_DMA2_COUNT  0xffc027c8   /* MXVR Sync Data DMA2 Loop Count Register */
+#define              MXVR_DMA2_CURR_ADDR  0xffc027cc   /* MXVR Sync Data DMA2 Current Address */
+#define             MXVR_DMA2_CURR_COUNT  0xffc027d0   /* MXVR Sync Data DMA2 Current Loop Count */
+
+/* MXVR DMA3 Registers */
+
+#define                 MXVR_DMA3_CONFIG  0xffc027d4   /* MXVR Sync Data DMA3 Config Register */
+#define             MXVR_DMA3_START_ADDR  0xffc027d8   /* MXVR Sync Data DMA3 Start Address */
+#define                  MXVR_DMA3_COUNT  0xffc027dc   /* MXVR Sync Data DMA3 Loop Count Register */
+#define              MXVR_DMA3_CURR_ADDR  0xffc027e0   /* MXVR Sync Data DMA3 Current Address */
+#define             MXVR_DMA3_CURR_COUNT  0xffc027e4   /* MXVR Sync Data DMA3 Current Loop Count */
+
+/* MXVR DMA4 Registers */
+
+#define                 MXVR_DMA4_CONFIG  0xffc027e8   /* MXVR Sync Data DMA4 Config Register */
+#define             MXVR_DMA4_START_ADDR  0xffc027ec   /* MXVR Sync Data DMA4 Start Address */
+#define                  MXVR_DMA4_COUNT  0xffc027f0   /* MXVR Sync Data DMA4 Loop Count Register */
+#define              MXVR_DMA4_CURR_ADDR  0xffc027f4   /* MXVR Sync Data DMA4 Current Address */
+#define             MXVR_DMA4_CURR_COUNT  0xffc027f8   /* MXVR Sync Data DMA4 Current Loop Count */
+
+/* MXVR DMA5 Registers */
+
+#define                 MXVR_DMA5_CONFIG  0xffc027fc   /* MXVR Sync Data DMA5 Config Register */
+#define             MXVR_DMA5_START_ADDR  0xffc02800   /* MXVR Sync Data DMA5 Start Address */
+#define                  MXVR_DMA5_COUNT  0xffc02804   /* MXVR Sync Data DMA5 Loop Count Register */
+#define              MXVR_DMA5_CURR_ADDR  0xffc02808   /* MXVR Sync Data DMA5 Current Address */
+#define             MXVR_DMA5_CURR_COUNT  0xffc0280c   /* MXVR Sync Data DMA5 Current Loop Count */
+
+/* MXVR DMA6 Registers */
+
+#define                 MXVR_DMA6_CONFIG  0xffc02810   /* MXVR Sync Data DMA6 Config Register */
+#define             MXVR_DMA6_START_ADDR  0xffc02814   /* MXVR Sync Data DMA6 Start Address */
+#define                  MXVR_DMA6_COUNT  0xffc02818   /* MXVR Sync Data DMA6 Loop Count Register */
+#define              MXVR_DMA6_CURR_ADDR  0xffc0281c   /* MXVR Sync Data DMA6 Current Address */
+#define             MXVR_DMA6_CURR_COUNT  0xffc02820   /* MXVR Sync Data DMA6 Current Loop Count */
+
+/* MXVR DMA7 Registers */
+
+#define                 MXVR_DMA7_CONFIG  0xffc02824   /* MXVR Sync Data DMA7 Config Register */
+#define             MXVR_DMA7_START_ADDR  0xffc02828   /* MXVR Sync Data DMA7 Start Address */
+#define                  MXVR_DMA7_COUNT  0xffc0282c   /* MXVR Sync Data DMA7 Loop Count Register */
+#define              MXVR_DMA7_CURR_ADDR  0xffc02830   /* MXVR Sync Data DMA7 Current Address */
+#define             MXVR_DMA7_CURR_COUNT  0xffc02834   /* MXVR Sync Data DMA7 Current Loop Count */
+
+/* MXVR Asynch Packet Registers */
+
+#define                      MXVR_AP_CTL  0xffc02838   /* MXVR Async Packet Control Register */
+#define             MXVR_APRB_START_ADDR  0xffc0283c   /* MXVR Async Packet RX Buffer Start Addr Register */
+#define              MXVR_APRB_CURR_ADDR  0xffc02840   /* MXVR Async Packet RX Buffer Current Addr Register */
+#define             MXVR_APTB_START_ADDR  0xffc02844   /* MXVR Async Packet TX Buffer Start Addr Register */
+#define              MXVR_APTB_CURR_ADDR  0xffc02848   /* MXVR Async Packet TX Buffer Current Addr Register */
+
+/* MXVR Control Message Registers */
+
+#define                      MXVR_CM_CTL  0xffc0284c   /* MXVR Control Message Control Register */
+#define             MXVR_CMRB_START_ADDR  0xffc02850   /* MXVR Control Message RX Buffer Start Addr Register */
+#define              MXVR_CMRB_CURR_ADDR  0xffc02854   /* MXVR Control Message RX Buffer Current Address */
+#define             MXVR_CMTB_START_ADDR  0xffc02858   /* MXVR Control Message TX Buffer Start Addr Register */
+#define              MXVR_CMTB_CURR_ADDR  0xffc0285c   /* MXVR Control Message TX Buffer Current Address */
+
+/* MXVR Remote Read Registers */
+
+#define             MXVR_RRDB_START_ADDR  0xffc02860   /* MXVR Remote Read Buffer Start Addr Register */
+#define              MXVR_RRDB_CURR_ADDR  0xffc02864   /* MXVR Remote Read Buffer Current Addr Register */
+
+/* MXVR Pattern Data Registers */
+
+#define                  MXVR_PAT_DATA_0  0xffc02868   /* MXVR Pattern Data Register 0 */
+#define                    MXVR_PAT_EN_0  0xffc0286c   /* MXVR Pattern Enable Register 0 */
+#define                  MXVR_PAT_DATA_1  0xffc02870   /* MXVR Pattern Data Register 1 */
+#define                    MXVR_PAT_EN_1  0xffc02874   /* MXVR Pattern Enable Register 1 */
+
+/* MXVR Frame Counter Registers */
+
+#define                 MXVR_FRAME_CNT_0  0xffc02878   /* MXVR Frame Counter 0 */
+#define                 MXVR_FRAME_CNT_1  0xffc0287c   /* MXVR Frame Counter 1 */
+
+/* MXVR Routing Table Registers */
+
+#define                   MXVR_ROUTING_0  0xffc02880   /* MXVR Routing Table Register 0 */
+#define                   MXVR_ROUTING_1  0xffc02884   /* MXVR Routing Table Register 1 */
+#define                   MXVR_ROUTING_2  0xffc02888   /* MXVR Routing Table Register 2 */
+#define                   MXVR_ROUTING_3  0xffc0288c   /* MXVR Routing Table Register 3 */
+#define                   MXVR_ROUTING_4  0xffc02890   /* MXVR Routing Table Register 4 */
+#define                   MXVR_ROUTING_5  0xffc02894   /* MXVR Routing Table Register 5 */
+#define                   MXVR_ROUTING_6  0xffc02898   /* MXVR Routing Table Register 6 */
+#define                   MXVR_ROUTING_7  0xffc0289c   /* MXVR Routing Table Register 7 */
+#define                   MXVR_ROUTING_8  0xffc028a0   /* MXVR Routing Table Register 8 */
+#define                   MXVR_ROUTING_9  0xffc028a4   /* MXVR Routing Table Register 9 */
+#define                  MXVR_ROUTING_10  0xffc028a8   /* MXVR Routing Table Register 10 */
+#define                  MXVR_ROUTING_11  0xffc028ac   /* MXVR Routing Table Register 11 */
+#define                  MXVR_ROUTING_12  0xffc028b0   /* MXVR Routing Table Register 12 */
+#define                  MXVR_ROUTING_13  0xffc028b4   /* MXVR Routing Table Register 13 */
+#define                  MXVR_ROUTING_14  0xffc028b8   /* MXVR Routing Table Register 14 */
+
+/* MXVR Counter-Clock-Control Registers */
+
+#define                   MXVR_BLOCK_CNT  0xffc028c0   /* MXVR Block Counter */
+#define                     MXVR_CLK_CTL  0xffc028d0   /* MXVR Clock Control Register */
+#define                  MXVR_CDRPLL_CTL  0xffc028d4   /* MXVR Clock/Data Recovery PLL Control Register */
+#define                   MXVR_FMPLL_CTL  0xffc028d8   /* MXVR Frequency Multiply PLL Control Register */
+#define                     MXVR_PIN_CTL  0xffc028dc   /* MXVR Pin Control Register */
+#define                    MXVR_SCLK_CNT  0xffc028e0   /* MXVR System Clock Counter Register */
+
+/* CAN Controller 1 Config 1 Registers */
+
+#define                         CAN1_MC1  0xffc03200   /* CAN Controller 1 Mailbox Configuration Register 1 */
+#define                         CAN1_MD1  0xffc03204   /* CAN Controller 1 Mailbox Direction Register 1 */
+#define                        CAN1_TRS1  0xffc03208   /* CAN Controller 1 Transmit Request Set Register 1 */
+#define                        CAN1_TRR1  0xffc0320c   /* CAN Controller 1 Transmit Request Reset Register 1 */
+#define                         CAN1_TA1  0xffc03210   /* CAN Controller 1 Transmit Acknowledge Register 1 */
+#define                         CAN1_AA1  0xffc03214   /* CAN Controller 1 Abort Acknowledge Register 1 */
+#define                        CAN1_RMP1  0xffc03218   /* CAN Controller 1 Receive Message Pending Register 1 */
+#define                        CAN1_RML1  0xffc0321c   /* CAN Controller 1 Receive Message Lost Register 1 */
+#define                      CAN1_MBTIF1  0xffc03220   /* CAN Controller 1 Mailbox Transmit Interrupt Flag Register 1 */
+#define                      CAN1_MBRIF1  0xffc03224   /* CAN Controller 1 Mailbox Receive Interrupt Flag Register 1 */
+#define                       CAN1_MBIM1  0xffc03228   /* CAN Controller 1 Mailbox Interrupt Mask Register 1 */
+#define                        CAN1_RFH1  0xffc0322c   /* CAN Controller 1 Remote Frame Handling Enable Register 1 */
+#define                       CAN1_OPSS1  0xffc03230   /* CAN Controller 1 Overwrite Protection Single Shot Transmit Register 1 */
+
+/* CAN Controller 1 Config 2 Registers */
+
+#define                         CAN1_MC2  0xffc03240   /* CAN Controller 1 Mailbox Configuration Register 2 */
+#define                         CAN1_MD2  0xffc03244   /* CAN Controller 1 Mailbox Direction Register 2 */
+#define                        CAN1_TRS2  0xffc03248   /* CAN Controller 1 Transmit Request Set Register 2 */
+#define                        CAN1_TRR2  0xffc0324c   /* CAN Controller 1 Transmit Request Reset Register 2 */
+#define                         CAN1_TA2  0xffc03250   /* CAN Controller 1 Transmit Acknowledge Register 2 */
+#define                         CAN1_AA2  0xffc03254   /* CAN Controller 1 Abort Acknowledge Register 2 */
+#define                        CAN1_RMP2  0xffc03258   /* CAN Controller 1 Receive Message Pending Register 2 */
+#define                        CAN1_RML2  0xffc0325c   /* CAN Controller 1 Receive Message Lost Register 2 */
+#define                      CAN1_MBTIF2  0xffc03260   /* CAN Controller 1 Mailbox Transmit Interrupt Flag Register 2 */
+#define                      CAN1_MBRIF2  0xffc03264   /* CAN Controller 1 Mailbox Receive Interrupt Flag Register 2 */
+#define                       CAN1_MBIM2  0xffc03268   /* CAN Controller 1 Mailbox Interrupt Mask Register 2 */
+#define                        CAN1_RFH2  0xffc0326c   /* CAN Controller 1 Remote Frame Handling Enable Register 2 */
+#define                       CAN1_OPSS2  0xffc03270   /* CAN Controller 1 Overwrite Protection Single Shot Transmit Register 2 */
+
+/* CAN Controller 1 Clock/Interrupt/Counter Registers */
+
+#define                       CAN1_CLOCK  0xffc03280   /* CAN Controller 1 Clock Register */
+#define                      CAN1_TIMING  0xffc03284   /* CAN Controller 1 Timing Register */
+#define                       CAN1_DEBUG  0xffc03288   /* CAN Controller 1 Debug Register */
+#define                      CAN1_STATUS  0xffc0328c   /* CAN Controller 1 Global Status Register */
+#define                         CAN1_CEC  0xffc03290   /* CAN Controller 1 Error Counter Register */
+#define                         CAN1_GIS  0xffc03294   /* CAN Controller 1 Global Interrupt Status Register */
+#define                         CAN1_GIM  0xffc03298   /* CAN Controller 1 Global Interrupt Mask Register */
+#define                         CAN1_GIF  0xffc0329c   /* CAN Controller 1 Global Interrupt Flag Register */
+#define                     CAN1_CONTROL  0xffc032a0   /* CAN Controller 1 Master Control Register */
+#define                        CAN1_INTR  0xffc032a4   /* CAN Controller 1 Interrupt Pending Register */
+#define                        CAN1_MBTD  0xffc032ac   /* CAN Controller 1 Mailbox Temporary Disable Register */
+#define                         CAN1_EWR  0xffc032b0   /* CAN Controller 1 Programmable Warning Level Register */
+#define                         CAN1_ESR  0xffc032b4   /* CAN Controller 1 Error Status Register */
+#define                       CAN1_UCCNT  0xffc032c4   /* CAN Controller 1 Universal Counter Register */
+#define                        CAN1_UCRC  0xffc032c8   /* CAN Controller 1 Universal Counter Force Reload Register */
+#define                       CAN1_UCCNF  0xffc032cc   /* CAN Controller 1 Universal Counter Configuration Register */
+
+/* CAN Controller 1 Mailbox Acceptance Registers */
+
+#define                       CAN1_AM00L  0xffc03300   /* CAN Controller 1 Mailbox 0 Acceptance Mask High Register */
+#define                       CAN1_AM00H  0xffc03304   /* CAN Controller 1 Mailbox 0 Acceptance Mask Low Register */
+#define                       CAN1_AM01L  0xffc03308   /* CAN Controller 1 Mailbox 1 Acceptance Mask High Register */
+#define                       CAN1_AM01H  0xffc0330c   /* CAN Controller 1 Mailbox 1 Acceptance Mask Low Register */
+#define                       CAN1_AM02L  0xffc03310   /* CAN Controller 1 Mailbox 2 Acceptance Mask High Register */
+#define                       CAN1_AM02H  0xffc03314   /* CAN Controller 1 Mailbox 2 Acceptance Mask Low Register */
+#define                       CAN1_AM03L  0xffc03318   /* CAN Controller 1 Mailbox 3 Acceptance Mask High Register */
+#define                       CAN1_AM03H  0xffc0331c   /* CAN Controller 1 Mailbox 3 Acceptance Mask Low Register */
+#define                       CAN1_AM04L  0xffc03320   /* CAN Controller 1 Mailbox 4 Acceptance Mask High Register */
+#define                       CAN1_AM04H  0xffc03324   /* CAN Controller 1 Mailbox 4 Acceptance Mask Low Register */
+#define                       CAN1_AM05L  0xffc03328   /* CAN Controller 1 Mailbox 5 Acceptance Mask High Register */
+#define                       CAN1_AM05H  0xffc0332c   /* CAN Controller 1 Mailbox 5 Acceptance Mask Low Register */
+#define                       CAN1_AM06L  0xffc03330   /* CAN Controller 1 Mailbox 6 Acceptance Mask High Register */
+#define                       CAN1_AM06H  0xffc03334   /* CAN Controller 1 Mailbox 6 Acceptance Mask Low Register */
+#define                       CAN1_AM07L  0xffc03338   /* CAN Controller 1 Mailbox 7 Acceptance Mask High Register */
+#define                       CAN1_AM07H  0xffc0333c   /* CAN Controller 1 Mailbox 7 Acceptance Mask Low Register */
+#define                       CAN1_AM08L  0xffc03340   /* CAN Controller 1 Mailbox 8 Acceptance Mask High Register */
+#define                       CAN1_AM08H  0xffc03344   /* CAN Controller 1 Mailbox 8 Acceptance Mask Low Register */
+#define                       CAN1_AM09L  0xffc03348   /* CAN Controller 1 Mailbox 9 Acceptance Mask High Register */
+#define                       CAN1_AM09H  0xffc0334c   /* CAN Controller 1 Mailbox 9 Acceptance Mask Low Register */
+#define                       CAN1_AM10L  0xffc03350   /* CAN Controller 1 Mailbox 10 Acceptance Mask High Register */
+#define                       CAN1_AM10H  0xffc03354   /* CAN Controller 1 Mailbox 10 Acceptance Mask Low Register */
+#define                       CAN1_AM11L  0xffc03358   /* CAN Controller 1 Mailbox 11 Acceptance Mask High Register */
+#define                       CAN1_AM11H  0xffc0335c   /* CAN Controller 1 Mailbox 11 Acceptance Mask Low Register */
+#define                       CAN1_AM12L  0xffc03360   /* CAN Controller 1 Mailbox 12 Acceptance Mask High Register */
+#define                       CAN1_AM12H  0xffc03364   /* CAN Controller 1 Mailbox 12 Acceptance Mask Low Register */
+#define                       CAN1_AM13L  0xffc03368   /* CAN Controller 1 Mailbox 13 Acceptance Mask High Register */
+#define                       CAN1_AM13H  0xffc0336c   /* CAN Controller 1 Mailbox 13 Acceptance Mask Low Register */
+#define                       CAN1_AM14L  0xffc03370   /* CAN Controller 1 Mailbox 14 Acceptance Mask High Register */
+#define                       CAN1_AM14H  0xffc03374   /* CAN Controller 1 Mailbox 14 Acceptance Mask Low Register */
+#define                       CAN1_AM15L  0xffc03378   /* CAN Controller 1 Mailbox 15 Acceptance Mask High Register */
+#define                       CAN1_AM15H  0xffc0337c   /* CAN Controller 1 Mailbox 15 Acceptance Mask Low Register */
+
+/* CAN Controller 1 Mailbox Acceptance Registers */
+
+#define                       CAN1_AM16L  0xffc03380   /* CAN Controller 1 Mailbox 16 Acceptance Mask High Register */
+#define                       CAN1_AM16H  0xffc03384   /* CAN Controller 1 Mailbox 16 Acceptance Mask Low Register */
+#define                       CAN1_AM17L  0xffc03388   /* CAN Controller 1 Mailbox 17 Acceptance Mask High Register */
+#define                       CAN1_AM17H  0xffc0338c   /* CAN Controller 1 Mailbox 17 Acceptance Mask Low Register */
+#define                       CAN1_AM18L  0xffc03390   /* CAN Controller 1 Mailbox 18 Acceptance Mask High Register */
+#define                       CAN1_AM18H  0xffc03394   /* CAN Controller 1 Mailbox 18 Acceptance Mask Low Register */
+#define                       CAN1_AM19L  0xffc03398   /* CAN Controller 1 Mailbox 19 Acceptance Mask High Register */
+#define                       CAN1_AM19H  0xffc0339c   /* CAN Controller 1 Mailbox 19 Acceptance Mask Low Register */
+#define                       CAN1_AM20L  0xffc033a0   /* CAN Controller 1 Mailbox 20 Acceptance Mask High Register */
+#define                       CAN1_AM20H  0xffc033a4   /* CAN Controller 1 Mailbox 20 Acceptance Mask Low Register */
+#define                       CAN1_AM21L  0xffc033a8   /* CAN Controller 1 Mailbox 21 Acceptance Mask High Register */
+#define                       CAN1_AM21H  0xffc033ac   /* CAN Controller 1 Mailbox 21 Acceptance Mask Low Register */
+#define                       CAN1_AM22L  0xffc033b0   /* CAN Controller 1 Mailbox 22 Acceptance Mask High Register */
+#define                       CAN1_AM22H  0xffc033b4   /* CAN Controller 1 Mailbox 22 Acceptance Mask Low Register */
+#define                       CAN1_AM23L  0xffc033b8   /* CAN Controller 1 Mailbox 23 Acceptance Mask High Register */
+#define                       CAN1_AM23H  0xffc033bc   /* CAN Controller 1 Mailbox 23 Acceptance Mask Low Register */
+#define                       CAN1_AM24L  0xffc033c0   /* CAN Controller 1 Mailbox 24 Acceptance Mask High Register */
+#define                       CAN1_AM24H  0xffc033c4   /* CAN Controller 1 Mailbox 24 Acceptance Mask Low Register */
+#define                       CAN1_AM25L  0xffc033c8   /* CAN Controller 1 Mailbox 25 Acceptance Mask High Register */
+#define                       CAN1_AM25H  0xffc033cc   /* CAN Controller 1 Mailbox 25 Acceptance Mask Low Register */
+#define                       CAN1_AM26L  0xffc033d0   /* CAN Controller 1 Mailbox 26 Acceptance Mask High Register */
+#define                       CAN1_AM26H  0xffc033d4   /* CAN Controller 1 Mailbox 26 Acceptance Mask Low Register */
+#define                       CAN1_AM27L  0xffc033d8   /* CAN Controller 1 Mailbox 27 Acceptance Mask High Register */
+#define                       CAN1_AM27H  0xffc033dc   /* CAN Controller 1 Mailbox 27 Acceptance Mask Low Register */
+#define                       CAN1_AM28L  0xffc033e0   /* CAN Controller 1 Mailbox 28 Acceptance Mask High Register */
+#define                       CAN1_AM28H  0xffc033e4   /* CAN Controller 1 Mailbox 28 Acceptance Mask Low Register */
+#define                       CAN1_AM29L  0xffc033e8   /* CAN Controller 1 Mailbox 29 Acceptance Mask High Register */
+#define                       CAN1_AM29H  0xffc033ec   /* CAN Controller 1 Mailbox 29 Acceptance Mask Low Register */
+#define                       CAN1_AM30L  0xffc033f0   /* CAN Controller 1 Mailbox 30 Acceptance Mask High Register */
+#define                       CAN1_AM30H  0xffc033f4   /* CAN Controller 1 Mailbox 30 Acceptance Mask Low Register */
+#define                       CAN1_AM31L  0xffc033f8   /* CAN Controller 1 Mailbox 31 Acceptance Mask High Register */
+#define                       CAN1_AM31H  0xffc033fc   /* CAN Controller 1 Mailbox 31 Acceptance Mask Low Register */
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define                  CAN1_MB00_DATA0  0xffc03400   /* CAN Controller 1 Mailbox 0 Data 0 Register */
+#define                  CAN1_MB00_DATA1  0xffc03404   /* CAN Controller 1 Mailbox 0 Data 1 Register */
+#define                  CAN1_MB00_DATA2  0xffc03408   /* CAN Controller 1 Mailbox 0 Data 2 Register */
+#define                  CAN1_MB00_DATA3  0xffc0340c   /* CAN Controller 1 Mailbox 0 Data 3 Register */
+#define                 CAN1_MB00_LENGTH  0xffc03410   /* CAN Controller 1 Mailbox 0 Length Register */
+#define              CAN1_MB00_TIMESTAMP  0xffc03414   /* CAN Controller 1 Mailbox 0 Timestamp Register */
+#define                    CAN1_MB00_ID0  0xffc03418   /* CAN Controller 1 Mailbox 0 ID0 Register */
+#define                    CAN1_MB00_ID1  0xffc0341c   /* CAN Controller 1 Mailbox 0 ID1 Register */
+#define                  CAN1_MB01_DATA0  0xffc03420   /* CAN Controller 1 Mailbox 1 Data 0 Register */
+#define                  CAN1_MB01_DATA1  0xffc03424   /* CAN Controller 1 Mailbox 1 Data 1 Register */
+#define                  CAN1_MB01_DATA2  0xffc03428   /* CAN Controller 1 Mailbox 1 Data 2 Register */
+#define                  CAN1_MB01_DATA3  0xffc0342c   /* CAN Controller 1 Mailbox 1 Data 3 Register */
+#define                 CAN1_MB01_LENGTH  0xffc03430   /* CAN Controller 1 Mailbox 1 Length Register */
+#define              CAN1_MB01_TIMESTAMP  0xffc03434   /* CAN Controller 1 Mailbox 1 Timestamp Register */
+#define                    CAN1_MB01_ID0  0xffc03438   /* CAN Controller 1 Mailbox 1 ID0 Register */
+#define                    CAN1_MB01_ID1  0xffc0343c   /* CAN Controller 1 Mailbox 1 ID1 Register */
+#define                  CAN1_MB02_DATA0  0xffc03440   /* CAN Controller 1 Mailbox 2 Data 0 Register */
+#define                  CAN1_MB02_DATA1  0xffc03444   /* CAN Controller 1 Mailbox 2 Data 1 Register */
+#define                  CAN1_MB02_DATA2  0xffc03448   /* CAN Controller 1 Mailbox 2 Data 2 Register */
+#define                  CAN1_MB02_DATA3  0xffc0344c   /* CAN Controller 1 Mailbox 2 Data 3 Register */
+#define                 CAN1_MB02_LENGTH  0xffc03450   /* CAN Controller 1 Mailbox 2 Length Register */
+#define              CAN1_MB02_TIMESTAMP  0xffc03454   /* CAN Controller 1 Mailbox 2 Timestamp Register */
+#define                    CAN1_MB02_ID0  0xffc03458   /* CAN Controller 1 Mailbox 2 ID0 Register */
+#define                    CAN1_MB02_ID1  0xffc0345c   /* CAN Controller 1 Mailbox 2 ID1 Register */
+#define                  CAN1_MB03_DATA0  0xffc03460   /* CAN Controller 1 Mailbox 3 Data 0 Register */
+#define                  CAN1_MB03_DATA1  0xffc03464   /* CAN Controller 1 Mailbox 3 Data 1 Register */
+#define                  CAN1_MB03_DATA2  0xffc03468   /* CAN Controller 1 Mailbox 3 Data 2 Register */
+#define                  CAN1_MB03_DATA3  0xffc0346c   /* CAN Controller 1 Mailbox 3 Data 3 Register */
+#define                 CAN1_MB03_LENGTH  0xffc03470   /* CAN Controller 1 Mailbox 3 Length Register */
+#define              CAN1_MB03_TIMESTAMP  0xffc03474   /* CAN Controller 1 Mailbox 3 Timestamp Register */
+#define                    CAN1_MB03_ID0  0xffc03478   /* CAN Controller 1 Mailbox 3 ID0 Register */
+#define                    CAN1_MB03_ID1  0xffc0347c   /* CAN Controller 1 Mailbox 3 ID1 Register */
+#define                  CAN1_MB04_DATA0  0xffc03480   /* CAN Controller 1 Mailbox 4 Data 0 Register */
+#define                  CAN1_MB04_DATA1  0xffc03484   /* CAN Controller 1 Mailbox 4 Data 1 Register */
+#define                  CAN1_MB04_DATA2  0xffc03488   /* CAN Controller 1 Mailbox 4 Data 2 Register */
+#define                  CAN1_MB04_DATA3  0xffc0348c   /* CAN Controller 1 Mailbox 4 Data 3 Register */
+#define                 CAN1_MB04_LENGTH  0xffc03490   /* CAN Controller 1 Mailbox 4 Length Register */
+#define              CAN1_MB04_TIMESTAMP  0xffc03494   /* CAN Controller 1 Mailbox 4 Timestamp Register */
+#define                    CAN1_MB04_ID0  0xffc03498   /* CAN Controller 1 Mailbox 4 ID0 Register */
+#define                    CAN1_MB04_ID1  0xffc0349c   /* CAN Controller 1 Mailbox 4 ID1 Register */
+#define                  CAN1_MB05_DATA0  0xffc034a0   /* CAN Controller 1 Mailbox 5 Data 0 Register */
+#define                  CAN1_MB05_DATA1  0xffc034a4   /* CAN Controller 1 Mailbox 5 Data 1 Register */
+#define                  CAN1_MB05_DATA2  0xffc034a8   /* CAN Controller 1 Mailbox 5 Data 2 Register */
+#define                  CAN1_MB05_DATA3  0xffc034ac   /* CAN Controller 1 Mailbox 5 Data 3 Register */
+#define                 CAN1_MB05_LENGTH  0xffc034b0   /* CAN Controller 1 Mailbox 5 Length Register */
+#define              CAN1_MB05_TIMESTAMP  0xffc034b4   /* CAN Controller 1 Mailbox 5 Timestamp Register */
+#define                    CAN1_MB05_ID0  0xffc034b8   /* CAN Controller 1 Mailbox 5 ID0 Register */
+#define                    CAN1_MB05_ID1  0xffc034bc   /* CAN Controller 1 Mailbox 5 ID1 Register */
+#define                  CAN1_MB06_DATA0  0xffc034c0   /* CAN Controller 1 Mailbox 6 Data 0 Register */
+#define                  CAN1_MB06_DATA1  0xffc034c4   /* CAN Controller 1 Mailbox 6 Data 1 Register */
+#define                  CAN1_MB06_DATA2  0xffc034c8   /* CAN Controller 1 Mailbox 6 Data 2 Register */
+#define                  CAN1_MB06_DATA3  0xffc034cc   /* CAN Controller 1 Mailbox 6 Data 3 Register */
+#define                 CAN1_MB06_LENGTH  0xffc034d0   /* CAN Controller 1 Mailbox 6 Length Register */
+#define              CAN1_MB06_TIMESTAMP  0xffc034d4   /* CAN Controller 1 Mailbox 6 Timestamp Register */
+#define                    CAN1_MB06_ID0  0xffc034d8   /* CAN Controller 1 Mailbox 6 ID0 Register */
+#define                    CAN1_MB06_ID1  0xffc034dc   /* CAN Controller 1 Mailbox 6 ID1 Register */
+#define                  CAN1_MB07_DATA0  0xffc034e0   /* CAN Controller 1 Mailbox 7 Data 0 Register */
+#define                  CAN1_MB07_DATA1  0xffc034e4   /* CAN Controller 1 Mailbox 7 Data 1 Register */
+#define                  CAN1_MB07_DATA2  0xffc034e8   /* CAN Controller 1 Mailbox 7 Data 2 Register */
+#define                  CAN1_MB07_DATA3  0xffc034ec   /* CAN Controller 1 Mailbox 7 Data 3 Register */
+#define                 CAN1_MB07_LENGTH  0xffc034f0   /* CAN Controller 1 Mailbox 7 Length Register */
+#define              CAN1_MB07_TIMESTAMP  0xffc034f4   /* CAN Controller 1 Mailbox 7 Timestamp Register */
+#define                    CAN1_MB07_ID0  0xffc034f8   /* CAN Controller 1 Mailbox 7 ID0 Register */
+#define                    CAN1_MB07_ID1  0xffc034fc   /* CAN Controller 1 Mailbox 7 ID1 Register */
+#define                  CAN1_MB08_DATA0  0xffc03500   /* CAN Controller 1 Mailbox 8 Data 0 Register */
+#define                  CAN1_MB08_DATA1  0xffc03504   /* CAN Controller 1 Mailbox 8 Data 1 Register */
+#define                  CAN1_MB08_DATA2  0xffc03508   /* CAN Controller 1 Mailbox 8 Data 2 Register */
+#define                  CAN1_MB08_DATA3  0xffc0350c   /* CAN Controller 1 Mailbox 8 Data 3 Register */
+#define                 CAN1_MB08_LENGTH  0xffc03510   /* CAN Controller 1 Mailbox 8 Length Register */
+#define              CAN1_MB08_TIMESTAMP  0xffc03514   /* CAN Controller 1 Mailbox 8 Timestamp Register */
+#define                    CAN1_MB08_ID0  0xffc03518   /* CAN Controller 1 Mailbox 8 ID0 Register */
+#define                    CAN1_MB08_ID1  0xffc0351c   /* CAN Controller 1 Mailbox 8 ID1 Register */
+#define                  CAN1_MB09_DATA0  0xffc03520   /* CAN Controller 1 Mailbox 9 Data 0 Register */
+#define                  CAN1_MB09_DATA1  0xffc03524   /* CAN Controller 1 Mailbox 9 Data 1 Register */
+#define                  CAN1_MB09_DATA2  0xffc03528   /* CAN Controller 1 Mailbox 9 Data 2 Register */
+#define                  CAN1_MB09_DATA3  0xffc0352c   /* CAN Controller 1 Mailbox 9 Data 3 Register */
+#define                 CAN1_MB09_LENGTH  0xffc03530   /* CAN Controller 1 Mailbox 9 Length Register */
+#define              CAN1_MB09_TIMESTAMP  0xffc03534   /* CAN Controller 1 Mailbox 9 Timestamp Register */
+#define                    CAN1_MB09_ID0  0xffc03538   /* CAN Controller 1 Mailbox 9 ID0 Register */
+#define                    CAN1_MB09_ID1  0xffc0353c   /* CAN Controller 1 Mailbox 9 ID1 Register */
+#define                  CAN1_MB10_DATA0  0xffc03540   /* CAN Controller 1 Mailbox 10 Data 0 Register */
+#define                  CAN1_MB10_DATA1  0xffc03544   /* CAN Controller 1 Mailbox 10 Data 1 Register */
+#define                  CAN1_MB10_DATA2  0xffc03548   /* CAN Controller 1 Mailbox 10 Data 2 Register */
+#define                  CAN1_MB10_DATA3  0xffc0354c   /* CAN Controller 1 Mailbox 10 Data 3 Register */
+#define                 CAN1_MB10_LENGTH  0xffc03550   /* CAN Controller 1 Mailbox 10 Length Register */
+#define              CAN1_MB10_TIMESTAMP  0xffc03554   /* CAN Controller 1 Mailbox 10 Timestamp Register */
+#define                    CAN1_MB10_ID0  0xffc03558   /* CAN Controller 1 Mailbox 10 ID0 Register */
+#define                    CAN1_MB10_ID1  0xffc0355c   /* CAN Controller 1 Mailbox 10 ID1 Register */
+#define                  CAN1_MB11_DATA0  0xffc03560   /* CAN Controller 1 Mailbox 11 Data 0 Register */
+#define                  CAN1_MB11_DATA1  0xffc03564   /* CAN Controller 1 Mailbox 11 Data 1 Register */
+#define                  CAN1_MB11_DATA2  0xffc03568   /* CAN Controller 1 Mailbox 11 Data 2 Register */
+#define                  CAN1_MB11_DATA3  0xffc0356c   /* CAN Controller 1 Mailbox 11 Data 3 Register */
+#define                 CAN1_MB11_LENGTH  0xffc03570   /* CAN Controller 1 Mailbox 11 Length Register */
+#define              CAN1_MB11_TIMESTAMP  0xffc03574   /* CAN Controller 1 Mailbox 11 Timestamp Register */
+#define                    CAN1_MB11_ID0  0xffc03578   /* CAN Controller 1 Mailbox 11 ID0 Register */
+#define                    CAN1_MB11_ID1  0xffc0357c   /* CAN Controller 1 Mailbox 11 ID1 Register */
+#define                  CAN1_MB12_DATA0  0xffc03580   /* CAN Controller 1 Mailbox 12 Data 0 Register */
+#define                  CAN1_MB12_DATA1  0xffc03584   /* CAN Controller 1 Mailbox 12 Data 1 Register */
+#define                  CAN1_MB12_DATA2  0xffc03588   /* CAN Controller 1 Mailbox 12 Data 2 Register */
+#define                  CAN1_MB12_DATA3  0xffc0358c   /* CAN Controller 1 Mailbox 12 Data 3 Register */
+#define                 CAN1_MB12_LENGTH  0xffc03590   /* CAN Controller 1 Mailbox 12 Length Register */
+#define              CAN1_MB12_TIMESTAMP  0xffc03594   /* CAN Controller 1 Mailbox 12 Timestamp Register */
+#define                    CAN1_MB12_ID0  0xffc03598   /* CAN Controller 1 Mailbox 12 ID0 Register */
+#define                    CAN1_MB12_ID1  0xffc0359c   /* CAN Controller 1 Mailbox 12 ID1 Register */
+#define                  CAN1_MB13_DATA0  0xffc035a0   /* CAN Controller 1 Mailbox 13 Data 0 Register */
+#define                  CAN1_MB13_DATA1  0xffc035a4   /* CAN Controller 1 Mailbox 13 Data 1 Register */
+#define                  CAN1_MB13_DATA2  0xffc035a8   /* CAN Controller 1 Mailbox 13 Data 2 Register */
+#define                  CAN1_MB13_DATA3  0xffc035ac   /* CAN Controller 1 Mailbox 13 Data 3 Register */
+#define                 CAN1_MB13_LENGTH  0xffc035b0   /* CAN Controller 1 Mailbox 13 Length Register */
+#define              CAN1_MB13_TIMESTAMP  0xffc035b4   /* CAN Controller 1 Mailbox 13 Timestamp Register */
+#define                    CAN1_MB13_ID0  0xffc035b8   /* CAN Controller 1 Mailbox 13 ID0 Register */
+#define                    CAN1_MB13_ID1  0xffc035bc   /* CAN Controller 1 Mailbox 13 ID1 Register */
+#define                  CAN1_MB14_DATA0  0xffc035c0   /* CAN Controller 1 Mailbox 14 Data 0 Register */
+#define                  CAN1_MB14_DATA1  0xffc035c4   /* CAN Controller 1 Mailbox 14 Data 1 Register */
+#define                  CAN1_MB14_DATA2  0xffc035c8   /* CAN Controller 1 Mailbox 14 Data 2 Register */
+#define                  CAN1_MB14_DATA3  0xffc035cc   /* CAN Controller 1 Mailbox 14 Data 3 Register */
+#define                 CAN1_MB14_LENGTH  0xffc035d0   /* CAN Controller 1 Mailbox 14 Length Register */
+#define              CAN1_MB14_TIMESTAMP  0xffc035d4   /* CAN Controller 1 Mailbox 14 Timestamp Register */
+#define                    CAN1_MB14_ID0  0xffc035d8   /* CAN Controller 1 Mailbox 14 ID0 Register */
+#define                    CAN1_MB14_ID1  0xffc035dc   /* CAN Controller 1 Mailbox 14 ID1 Register */
+#define                  CAN1_MB15_DATA0  0xffc035e0   /* CAN Controller 1 Mailbox 15 Data 0 Register */
+#define                  CAN1_MB15_DATA1  0xffc035e4   /* CAN Controller 1 Mailbox 15 Data 1 Register */
+#define                  CAN1_MB15_DATA2  0xffc035e8   /* CAN Controller 1 Mailbox 15 Data 2 Register */
+#define                  CAN1_MB15_DATA3  0xffc035ec   /* CAN Controller 1 Mailbox 15 Data 3 Register */
+#define                 CAN1_MB15_LENGTH  0xffc035f0   /* CAN Controller 1 Mailbox 15 Length Register */
+#define              CAN1_MB15_TIMESTAMP  0xffc035f4   /* CAN Controller 1 Mailbox 15 Timestamp Register */
+#define                    CAN1_MB15_ID0  0xffc035f8   /* CAN Controller 1 Mailbox 15 ID0 Register */
+#define                    CAN1_MB15_ID1  0xffc035fc   /* CAN Controller 1 Mailbox 15 ID1 Register */
+
+/* CAN Controller 1 Mailbox Data Registers */
+
+#define                  CAN1_MB16_DATA0  0xffc03600   /* CAN Controller 1 Mailbox 16 Data 0 Register */
+#define                  CAN1_MB16_DATA1  0xffc03604   /* CAN Controller 1 Mailbox 16 Data 1 Register */
+#define                  CAN1_MB16_DATA2  0xffc03608   /* CAN Controller 1 Mailbox 16 Data 2 Register */
+#define                  CAN1_MB16_DATA3  0xffc0360c   /* CAN Controller 1 Mailbox 16 Data 3 Register */
+#define                 CAN1_MB16_LENGTH  0xffc03610   /* CAN Controller 1 Mailbox 16 Length Register */
+#define              CAN1_MB16_TIMESTAMP  0xffc03614   /* CAN Controller 1 Mailbox 16 Timestamp Register */
+#define                    CAN1_MB16_ID0  0xffc03618   /* CAN Controller 1 Mailbox 16 ID0 Register */
+#define                    CAN1_MB16_ID1  0xffc0361c   /* CAN Controller 1 Mailbox 16 ID1 Register */
+#define                  CAN1_MB17_DATA0  0xffc03620   /* CAN Controller 1 Mailbox 17 Data 0 Register */
+#define                  CAN1_MB17_DATA1  0xffc03624   /* CAN Controller 1 Mailbox 17 Data 1 Register */
+#define                  CAN1_MB17_DATA2  0xffc03628   /* CAN Controller 1 Mailbox 17 Data 2 Register */
+#define                  CAN1_MB17_DATA3  0xffc0362c   /* CAN Controller 1 Mailbox 17 Data 3 Register */
+#define                 CAN1_MB17_LENGTH  0xffc03630   /* CAN Controller 1 Mailbox 17 Length Register */
+#define              CAN1_MB17_TIMESTAMP  0xffc03634   /* CAN Controller 1 Mailbox 17 Timestamp Register */
+#define                    CAN1_MB17_ID0  0xffc03638   /* CAN Controller 1 Mailbox 17 ID0 Register */
+#define                    CAN1_MB17_ID1  0xffc0363c   /* CAN Controller 1 Mailbox 17 ID1 Register */
+#define                  CAN1_MB18_DATA0  0xffc03640   /* CAN Controller 1 Mailbox 18 Data 0 Register */
+#define                  CAN1_MB18_DATA1  0xffc03644   /* CAN Controller 1 Mailbox 18 Data 1 Register */
+#define                  CAN1_MB18_DATA2  0xffc03648   /* CAN Controller 1 Mailbox 18 Data 2 Register */
+#define                  CAN1_MB18_DATA3  0xffc0364c   /* CAN Controller 1 Mailbox 18 Data 3 Register */
+#define                 CAN1_MB18_LENGTH  0xffc03650   /* CAN Controller 1 Mailbox 18 Length Register */
+#define              CAN1_MB18_TIMESTAMP  0xffc03654   /* CAN Controller 1 Mailbox 18 Timestamp Register */
+#define                    CAN1_MB18_ID0  0xffc03658   /* CAN Controller 1 Mailbox 18 ID0 Register */
+#define                    CAN1_MB18_ID1  0xffc0365c   /* CAN Controller 1 Mailbox 18 ID1 Register */
+#define                  CAN1_MB19_DATA0  0xffc03660   /* CAN Controller 1 Mailbox 19 Data 0 Register */
+#define                  CAN1_MB19_DATA1  0xffc03664   /* CAN Controller 1 Mailbox 19 Data 1 Register */
+#define                  CAN1_MB19_DATA2  0xffc03668   /* CAN Controller 1 Mailbox 19 Data 2 Register */
+#define                  CAN1_MB19_DATA3  0xffc0366c   /* CAN Controller 1 Mailbox 19 Data 3 Register */
+#define                 CAN1_MB19_LENGTH  0xffc03670   /* CAN Controller 1 Mailbox 19 Length Register */
+#define              CAN1_MB19_TIMESTAMP  0xffc03674   /* CAN Controller 1 Mailbox 19 Timestamp Register */
+#define                    CAN1_MB19_ID0  0xffc03678   /* CAN Controller 1 Mailbox 19 ID0 Register */
+#define                    CAN1_MB19_ID1  0xffc0367c   /* CAN Controller 1 Mailbox 19 ID1 Register */
+#define                  CAN1_MB20_DATA0  0xffc03680   /* CAN Controller 1 Mailbox 20 Data 0 Register */
+#define                  CAN1_MB20_DATA1  0xffc03684   /* CAN Controller 1 Mailbox 20 Data 1 Register */
+#define                  CAN1_MB20_DATA2  0xffc03688   /* CAN Controller 1 Mailbox 20 Data 2 Register */
+#define                  CAN1_MB20_DATA3  0xffc0368c   /* CAN Controller 1 Mailbox 20 Data 3 Register */
+#define                 CAN1_MB20_LENGTH  0xffc03690   /* CAN Controller 1 Mailbox 20 Length Register */
+#define              CAN1_MB20_TIMESTAMP  0xffc03694   /* CAN Controller 1 Mailbox 20 Timestamp Register */
+#define                    CAN1_MB20_ID0  0xffc03698   /* CAN Controller 1 Mailbox 20 ID0 Register */
+#define                    CAN1_MB20_ID1  0xffc0369c   /* CAN Controller 1 Mailbox 20 ID1 Register */
+#define                  CAN1_MB21_DATA0  0xffc036a0   /* CAN Controller 1 Mailbox 21 Data 0 Register */
+#define                  CAN1_MB21_DATA1  0xffc036a4   /* CAN Controller 1 Mailbox 21 Data 1 Register */
+#define                  CAN1_MB21_DATA2  0xffc036a8   /* CAN Controller 1 Mailbox 21 Data 2 Register */
+#define                  CAN1_MB21_DATA3  0xffc036ac   /* CAN Controller 1 Mailbox 21 Data 3 Register */
+#define                 CAN1_MB21_LENGTH  0xffc036b0   /* CAN Controller 1 Mailbox 21 Length Register */
+#define              CAN1_MB21_TIMESTAMP  0xffc036b4   /* CAN Controller 1 Mailbox 21 Timestamp Register */
+#define                    CAN1_MB21_ID0  0xffc036b8   /* CAN Controller 1 Mailbox 21 ID0 Register */
+#define                    CAN1_MB21_ID1  0xffc036bc   /* CAN Controller 1 Mailbox 21 ID1 Register */
+#define                  CAN1_MB22_DATA0  0xffc036c0   /* CAN Controller 1 Mailbox 22 Data 0 Register */
+#define                  CAN1_MB22_DATA1  0xffc036c4   /* CAN Controller 1 Mailbox 22 Data 1 Register */
+#define                  CAN1_MB22_DATA2  0xffc036c8   /* CAN Controller 1 Mailbox 22 Data 2 Register */
+#define                  CAN1_MB22_DATA3  0xffc036cc   /* CAN Controller 1 Mailbox 22 Data 3 Register */
+#define                 CAN1_MB22_LENGTH  0xffc036d0   /* CAN Controller 1 Mailbox 22 Length Register */
+#define              CAN1_MB22_TIMESTAMP  0xffc036d4   /* CAN Controller 1 Mailbox 22 Timestamp Register */
+#define                    CAN1_MB22_ID0  0xffc036d8   /* CAN Controller 1 Mailbox 22 ID0 Register */
+#define                    CAN1_MB22_ID1  0xffc036dc   /* CAN Controller 1 Mailbox 22 ID1 Register */
+#define                  CAN1_MB23_DATA0  0xffc036e0   /* CAN Controller 1 Mailbox 23 Data 0 Register */
+#define                  CAN1_MB23_DATA1  0xffc036e4   /* CAN Controller 1 Mailbox 23 Data 1 Register */
+#define                  CAN1_MB23_DATA2  0xffc036e8   /* CAN Controller 1 Mailbox 23 Data 2 Register */
+#define                  CAN1_MB23_DATA3  0xffc036ec   /* CAN Controller 1 Mailbox 23 Data 3 Register */
+#define                 CAN1_MB23_LENGTH  0xffc036f0   /* CAN Controller 1 Mailbox 23 Length Register */
+#define              CAN1_MB23_TIMESTAMP  0xffc036f4   /* CAN Controller 1 Mailbox 23 Timestamp Register */
+#define                    CAN1_MB23_ID0  0xffc036f8   /* CAN Controller 1 Mailbox 23 ID0 Register */
+#define                    CAN1_MB23_ID1  0xffc036fc   /* CAN Controller 1 Mailbox 23 ID1 Register */
+#define                  CAN1_MB24_DATA0  0xffc03700   /* CAN Controller 1 Mailbox 24 Data 0 Register */
+#define                  CAN1_MB24_DATA1  0xffc03704   /* CAN Controller 1 Mailbox 24 Data 1 Register */
+#define                  CAN1_MB24_DATA2  0xffc03708   /* CAN Controller 1 Mailbox 24 Data 2 Register */
+#define                  CAN1_MB24_DATA3  0xffc0370c   /* CAN Controller 1 Mailbox 24 Data 3 Register */
+#define                 CAN1_MB24_LENGTH  0xffc03710   /* CAN Controller 1 Mailbox 24 Length Register */
+#define              CAN1_MB24_TIMESTAMP  0xffc03714   /* CAN Controller 1 Mailbox 24 Timestamp Register */
+#define                    CAN1_MB24_ID0  0xffc03718   /* CAN Controller 1 Mailbox 24 ID0 Register */
+#define                    CAN1_MB24_ID1  0xffc0371c   /* CAN Controller 1 Mailbox 24 ID1 Register */
+#define                  CAN1_MB25_DATA0  0xffc03720   /* CAN Controller 1 Mailbox 25 Data 0 Register */
+#define                  CAN1_MB25_DATA1  0xffc03724   /* CAN Controller 1 Mailbox 25 Data 1 Register */
+#define                  CAN1_MB25_DATA2  0xffc03728   /* CAN Controller 1 Mailbox 25 Data 2 Register */
+#define                  CAN1_MB25_DATA3  0xffc0372c   /* CAN Controller 1 Mailbox 25 Data 3 Register */
+#define                 CAN1_MB25_LENGTH  0xffc03730   /* CAN Controller 1 Mailbox 25 Length Register */
+#define              CAN1_MB25_TIMESTAMP  0xffc03734   /* CAN Controller 1 Mailbox 25 Timestamp Register */
+#define                    CAN1_MB25_ID0  0xffc03738   /* CAN Controller 1 Mailbox 25 ID0 Register */
+#define                    CAN1_MB25_ID1  0xffc0373c   /* CAN Controller 1 Mailbox 25 ID1 Register */
+#define                  CAN1_MB26_DATA0  0xffc03740   /* CAN Controller 1 Mailbox 26 Data 0 Register */
+#define                  CAN1_MB26_DATA1  0xffc03744   /* CAN Controller 1 Mailbox 26 Data 1 Register */
+#define                  CAN1_MB26_DATA2  0xffc03748   /* CAN Controller 1 Mailbox 26 Data 2 Register */
+#define                  CAN1_MB26_DATA3  0xffc0374c   /* CAN Controller 1 Mailbox 26 Data 3 Register */
+#define                 CAN1_MB26_LENGTH  0xffc03750   /* CAN Controller 1 Mailbox 26 Length Register */
+#define              CAN1_MB26_TIMESTAMP  0xffc03754   /* CAN Controller 1 Mailbox 26 Timestamp Register */
+#define                    CAN1_MB26_ID0  0xffc03758   /* CAN Controller 1 Mailbox 26 ID0 Register */
+#define                    CAN1_MB26_ID1  0xffc0375c   /* CAN Controller 1 Mailbox 26 ID1 Register */
+#define                  CAN1_MB27_DATA0  0xffc03760   /* CAN Controller 1 Mailbox 27 Data 0 Register */
+#define                  CAN1_MB27_DATA1  0xffc03764   /* CAN Controller 1 Mailbox 27 Data 1 Register */
+#define                  CAN1_MB27_DATA2  0xffc03768   /* CAN Controller 1 Mailbox 27 Data 2 Register */
+#define                  CAN1_MB27_DATA3  0xffc0376c   /* CAN Controller 1 Mailbox 27 Data 3 Register */
+#define                 CAN1_MB27_LENGTH  0xffc03770   /* CAN Controller 1 Mailbox 27 Length Register */
+#define              CAN1_MB27_TIMESTAMP  0xffc03774   /* CAN Controller 1 Mailbox 27 Timestamp Register */
+#define                    CAN1_MB27_ID0  0xffc03778   /* CAN Controller 1 Mailbox 27 ID0 Register */
+#define                    CAN1_MB27_ID1  0xffc0377c   /* CAN Controller 1 Mailbox 27 ID1 Register */
+#define                  CAN1_MB28_DATA0  0xffc03780   /* CAN Controller 1 Mailbox 28 Data 0 Register */
+#define                  CAN1_MB28_DATA1  0xffc03784   /* CAN Controller 1 Mailbox 28 Data 1 Register */
+#define                  CAN1_MB28_DATA2  0xffc03788   /* CAN Controller 1 Mailbox 28 Data 2 Register */
+#define                  CAN1_MB28_DATA3  0xffc0378c   /* CAN Controller 1 Mailbox 28 Data 3 Register */
+#define                 CAN1_MB28_LENGTH  0xffc03790   /* CAN Controller 1 Mailbox 28 Length Register */
+#define              CAN1_MB28_TIMESTAMP  0xffc03794   /* CAN Controller 1 Mailbox 28 Timestamp Register */
+#define                    CAN1_MB28_ID0  0xffc03798   /* CAN Controller 1 Mailbox 28 ID0 Register */
+#define                    CAN1_MB28_ID1  0xffc0379c   /* CAN Controller 1 Mailbox 28 ID1 Register */
+#define                  CAN1_MB29_DATA0  0xffc037a0   /* CAN Controller 1 Mailbox 29 Data 0 Register */
+#define                  CAN1_MB29_DATA1  0xffc037a4   /* CAN Controller 1 Mailbox 29 Data 1 Register */
+#define                  CAN1_MB29_DATA2  0xffc037a8   /* CAN Controller 1 Mailbox 29 Data 2 Register */
+#define                  CAN1_MB29_DATA3  0xffc037ac   /* CAN Controller 1 Mailbox 29 Data 3 Register */
+#define                 CAN1_MB29_LENGTH  0xffc037b0   /* CAN Controller 1 Mailbox 29 Length Register */
+#define              CAN1_MB29_TIMESTAMP  0xffc037b4   /* CAN Controller 1 Mailbox 29 Timestamp Register */
+#define                    CAN1_MB29_ID0  0xffc037b8   /* CAN Controller 1 Mailbox 29 ID0 Register */
+#define                    CAN1_MB29_ID1  0xffc037bc   /* CAN Controller 1 Mailbox 29 ID1 Register */
+#define                  CAN1_MB30_DATA0  0xffc037c0   /* CAN Controller 1 Mailbox 30 Data 0 Register */
+#define                  CAN1_MB30_DATA1  0xffc037c4   /* CAN Controller 1 Mailbox 30 Data 1 Register */
+#define                  CAN1_MB30_DATA2  0xffc037c8   /* CAN Controller 1 Mailbox 30 Data 2 Register */
+#define                  CAN1_MB30_DATA3  0xffc037cc   /* CAN Controller 1 Mailbox 30 Data 3 Register */
+#define                 CAN1_MB30_LENGTH  0xffc037d0   /* CAN Controller 1 Mailbox 30 Length Register */
+#define              CAN1_MB30_TIMESTAMP  0xffc037d4   /* CAN Controller 1 Mailbox 30 Timestamp Register */
+#define                    CAN1_MB30_ID0  0xffc037d8   /* CAN Controller 1 Mailbox 30 ID0 Register */
+#define                    CAN1_MB30_ID1  0xffc037dc   /* CAN Controller 1 Mailbox 30 ID1 Register */
+#define                  CAN1_MB31_DATA0  0xffc037e0   /* CAN Controller 1 Mailbox 31 Data 0 Register */
+#define                  CAN1_MB31_DATA1  0xffc037e4   /* CAN Controller 1 Mailbox 31 Data 1 Register */
+#define                  CAN1_MB31_DATA2  0xffc037e8   /* CAN Controller 1 Mailbox 31 Data 2 Register */
+#define                  CAN1_MB31_DATA3  0xffc037ec   /* CAN Controller 1 Mailbox 31 Data 3 Register */
+#define                 CAN1_MB31_LENGTH  0xffc037f0   /* CAN Controller 1 Mailbox 31 Length Register */
+#define              CAN1_MB31_TIMESTAMP  0xffc037f4   /* CAN Controller 1 Mailbox 31 Timestamp Register */
+#define                    CAN1_MB31_ID0  0xffc037f8   /* CAN Controller 1 Mailbox 31 ID0 Register */
+#define                    CAN1_MB31_ID1  0xffc037fc   /* CAN Controller 1 Mailbox 31 ID1 Register */
+
+/* ATAPI Registers */
+
+#define                    ATAPI_CONTROL  0xffc03800   /* ATAPI Control Register */
+#define                     ATAPI_STATUS  0xffc03804   /* ATAPI Status Register */
+#define                   ATAPI_DEV_ADDR  0xffc03808   /* ATAPI Device Register Address */
+#define                  ATAPI_DEV_TXBUF  0xffc0380c   /* ATAPI Device Register Write Data */
+#define                  ATAPI_DEV_RXBUF  0xffc03810   /* ATAPI Device Register Read Data */
+#define                   ATAPI_INT_MASK  0xffc03814   /* ATAPI Interrupt Mask Register */
+#define                 ATAPI_INT_STATUS  0xffc03818   /* ATAPI Interrupt Status Register */
+#define                   ATAPI_XFER_LEN  0xffc0381c   /* ATAPI Length of Transfer */
+#define                ATAPI_LINE_STATUS  0xffc03820   /* ATAPI Line Status */
+#define                   ATAPI_SM_STATE  0xffc03824   /* ATAPI State Machine Status */
+#define                  ATAPI_TERMINATE  0xffc03828   /* ATAPI Host Terminate */
+#define                 ATAPI_PIO_TFRCNT  0xffc0382c   /* ATAPI PIO mode transfer count */
+#define                 ATAPI_DMA_TFRCNT  0xffc03830   /* ATAPI DMA mode transfer count */
+#define               ATAPI_UMAIN_TFRCNT  0xffc03834   /* ATAPI UDMAIN transfer count */
+#define             ATAPI_UDMAOUT_TFRCNT  0xffc03838   /* ATAPI UDMAOUT transfer count */
+#define                  ATAPI_REG_TIM_0  0xffc03840   /* ATAPI Register Transfer Timing 0 */
+#define                  ATAPI_PIO_TIM_0  0xffc03844   /* ATAPI PIO Timing 0 Register */
+#define                  ATAPI_PIO_TIM_1  0xffc03848   /* ATAPI PIO Timing 1 Register */
+#define                ATAPI_MULTI_TIM_0  0xffc03850   /* ATAPI Multi-DMA Timing 0 Register */
+#define                ATAPI_MULTI_TIM_1  0xffc03854   /* ATAPI Multi-DMA Timing 1 Register */
+#define                ATAPI_MULTI_TIM_2  0xffc03858   /* ATAPI Multi-DMA Timing 2 Register */
+#define                ATAPI_ULTRA_TIM_0  0xffc03860   /* ATAPI Ultra-DMA Timing 0 Register */
+#define                ATAPI_ULTRA_TIM_1  0xffc03864   /* ATAPI Ultra-DMA Timing 1 Register */
+#define                ATAPI_ULTRA_TIM_2  0xffc03868   /* ATAPI Ultra-DMA Timing 2 Register */
+#define                ATAPI_ULTRA_TIM_3  0xffc0386c   /* ATAPI Ultra-DMA Timing 3 Register */
+
+/* SDH Registers */
+
+#define                      SDH_PWR_CTL  0xffc03900   /* SDH Power Control */
+#define                      SDH_CLK_CTL  0xffc03904   /* SDH Clock Control */
+#define                     SDH_ARGUMENT  0xffc03908   /* SDH Argument */
+#define                      SDH_COMMAND  0xffc0390c   /* SDH Command */
+#define                     SDH_RESP_CMD  0xffc03910   /* SDH Response Command */
+#define                    SDH_RESPONSE0  0xffc03914   /* SDH Response0 */
+#define                    SDH_RESPONSE1  0xffc03918   /* SDH Response1 */
+#define                    SDH_RESPONSE2  0xffc0391c   /* SDH Response2 */
+#define                    SDH_RESPONSE3  0xffc03920   /* SDH Response3 */
+#define                   SDH_DATA_TIMER  0xffc03924   /* SDH Data Timer */
+#define                    SDH_DATA_LGTH  0xffc03928   /* SDH Data Length */
+#define                     SDH_DATA_CTL  0xffc0392c   /* SDH Data Control */
+#define                     SDH_DATA_CNT  0xffc03930   /* SDH Data Counter */
+#define                       SDH_STATUS  0xffc03934   /* SDH Status */
+#define                   SDH_STATUS_CLR  0xffc03938   /* SDH Status Clear */
+#define                        SDH_MASK0  0xffc0393c   /* SDH Interrupt0 Mask */
+#define                        SDH_MASK1  0xffc03940   /* SDH Interrupt1 Mask */
+#define                     SDH_FIFO_CNT  0xffc03948   /* SDH FIFO Counter */
+#define                         SDH_FIFO  0xffc03980   /* SDH Data FIFO */
+#define                     SDH_E_STATUS  0xffc039c0   /* SDH Exception Status */
+#define                       SDH_E_MASK  0xffc039c4   /* SDH Exception Mask */
+#define                          SDH_CFG  0xffc039c8   /* SDH Configuration */
+#define                   SDH_RD_WAIT_EN  0xffc039cc   /* SDH Read Wait Enable */
+#define                         SDH_PID0  0xffc039d0   /* SDH Peripheral Identification0 */
+#define                         SDH_PID1  0xffc039d4   /* SDH Peripheral Identification1 */
+#define                         SDH_PID2  0xffc039d8   /* SDH Peripheral Identification2 */
+#define                         SDH_PID3  0xffc039dc   /* SDH Peripheral Identification3 */
+#define                         SDH_PID4  0xffc039e0   /* SDH Peripheral Identification4 */
+#define                         SDH_PID5  0xffc039e4   /* SDH Peripheral Identification5 */
+#define                         SDH_PID6  0xffc039e8   /* SDH Peripheral Identification6 */
+#define                         SDH_PID7  0xffc039ec   /* SDH Peripheral Identification7 */
+
+/* HOST Port Registers */
+
+#define                     HOST_CONTROL  0xffc03a00   /* HOST Control Register */
+#define                      HOST_STATUS  0xffc03a04   /* HOST Status Register */
+#define                     HOST_TIMEOUT  0xffc03a08   /* HOST Acknowledge Mode Timeout Register */
+
+/* USB Control Registers */
+
+#define                        USB_FADDR  0xffc03c00   /* Function address register */
+#define                        USB_POWER  0xffc03c04   /* Power management register */
+#define                       USB_INTRTX  0xffc03c08   /* Interrupt register for endpoint 0 and Tx endpoint 1 to 7 */
+#define                       USB_INTRRX  0xffc03c0c   /* Interrupt register for Rx endpoints 1 to 7 */
+#define                      USB_INTRTXE  0xffc03c10   /* Interrupt enable register for IntrTx */
+#define                      USB_INTRRXE  0xffc03c14   /* Interrupt enable register for IntrRx */
+#define                      USB_INTRUSB  0xffc03c18   /* Interrupt register for common USB interrupts */
+#define                     USB_INTRUSBE  0xffc03c1c   /* Interrupt enable register for IntrUSB */
+#define                        USB_FRAME  0xffc03c20   /* USB frame number */
+#define                        USB_INDEX  0xffc03c24   /* Index register for selecting the indexed endpoint registers */
+#define                     USB_TESTMODE  0xffc03c28   /* Enabled USB 20 test modes */
+#define                     USB_GLOBINTR  0xffc03c2c   /* Global Interrupt Mask register and Wakeup Exception Interrupt */
+#define                   USB_GLOBAL_CTL  0xffc03c30   /* Global Clock Control for the core */
+
+/* USB Packet Control Registers */
+
+#define                USB_TX_MAX_PACKET  0xffc03c40   /* Maximum packet size for Host Tx endpoint */
+#define                         USB_CSR0  0xffc03c44   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                        USB_TXCSR  0xffc03c44   /* Control Status register for endpoint 0 and Control Status register for Host Tx endpoint */
+#define                USB_RX_MAX_PACKET  0xffc03c48   /* Maximum packet size for Host Rx endpoint */
+#define                        USB_RXCSR  0xffc03c4c   /* Control Status register for Host Rx endpoint */
+#define                       USB_COUNT0  0xffc03c50   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                      USB_RXCOUNT  0xffc03c50   /* Number of bytes received in endpoint 0 FIFO and Number of bytes received in Host Tx endpoint */
+#define                       USB_TXTYPE  0xffc03c54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint */
+#define                    USB_NAKLIMIT0  0xffc03c58   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                   USB_TXINTERVAL  0xffc03c58   /* Sets the NAK response timeout on Endpoint 0 and on Bulk transfers for Host Tx endpoint */
+#define                       USB_RXTYPE  0xffc03c5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint */
+#define                   USB_RXINTERVAL  0xffc03c60   /* Sets the polling interval for Interrupt and Isochronous transfers or the NAK response timeout on Bulk transfers */
+#define                      USB_TXCOUNT  0xffc03c68   /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* USB Endpoint FIFO Registers */
+
+#define                     USB_EP0_FIFO  0xffc03c80   /* Endpoint 0 FIFO */
+#define                     USB_EP1_FIFO  0xffc03c88   /* Endpoint 1 FIFO */
+#define                     USB_EP2_FIFO  0xffc03c90   /* Endpoint 2 FIFO */
+#define                     USB_EP3_FIFO  0xffc03c98   /* Endpoint 3 FIFO */
+#define                     USB_EP4_FIFO  0xffc03ca0   /* Endpoint 4 FIFO */
+#define                     USB_EP5_FIFO  0xffc03ca8   /* Endpoint 5 FIFO */
+#define                     USB_EP6_FIFO  0xffc03cb0   /* Endpoint 6 FIFO */
+#define                     USB_EP7_FIFO  0xffc03cb8   /* Endpoint 7 FIFO */
+
+/* USB OTG Control Registers */
+
+#define                  USB_OTG_DEV_CTL  0xffc03d00   /* OTG Device Control Register */
+#define                 USB_OTG_VBUS_IRQ  0xffc03d04   /* OTG VBUS Control Interrupts */
+#define                USB_OTG_VBUS_MASK  0xffc03d08   /* VBUS Control Interrupt Enable */
+
+/* USB Phy Control Registers */
+
+#define                     USB_LINKINFO  0xffc03d48   /* Enables programming of some PHY-side delays */
+#define                        USB_VPLEN  0xffc03d4c   /* Determines duration of VBUS pulse for VBUS charging */
+#define                      USB_HS_EOF1  0xffc03d50   /* Time buffer for High-Speed transactions */
+#define                      USB_FS_EOF1  0xffc03d54   /* Time buffer for Full-Speed transactions */
+#define                      USB_LS_EOF1  0xffc03d58   /* Time buffer for Low-Speed transactions */
+
+/* (APHY_CNTRL is for ADI usage only) */
+
+#define                   USB_APHY_CNTRL  0xffc03de0   /* Register that increases visibility of Analog PHY */
+
+/* (APHY_CALIB is for ADI usage only) */
+
+#define                   USB_APHY_CALIB  0xffc03de4   /* Register used to set some calibration values */
+#define                  USB_APHY_CNTRL2  0xffc03de8   /* Register used to prevent re-enumeration once Moab goes into hibernate mode */
+
+/* (PHY_TEST is for ADI usage only) */
+
+#define                     USB_PHY_TEST  0xffc03dec   /* Used for reducing simulation time and simplifies FIFO testability */
+#define                  USB_PLLOSC_CTRL  0xffc03df0   /* Used to program different parameters for USB PLL and Oscillator */
+#define                   USB_SRP_CLKDIV  0xffc03df4   /* Used to program clock divide value for the clock fed to the SRP detection logic */
+
+/* USB Endpoint 0 Control Registers */
+
+#define                USB_EP_NI0_TXMAXP  0xffc03e00   /* Maximum packet size for Host Tx endpoint0 */
+#define                 USB_EP_NI0_TXCSR  0xffc03e04   /* Control Status register for endpoint 0 */
+#define                USB_EP_NI0_RXMAXP  0xffc03e08   /* Maximum packet size for Host Rx endpoint0 */
+#define                 USB_EP_NI0_RXCSR  0xffc03e0c   /* Control Status register for Host Rx endpoint0 */
+#define               USB_EP_NI0_RXCOUNT  0xffc03e10   /* Number of bytes received in endpoint 0 FIFO */
+#define                USB_EP_NI0_TXTYPE  0xffc03e14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint0 */
+#define            USB_EP_NI0_TXINTERVAL  0xffc03e18   /* Sets the NAK response timeout on Endpoint 0 */
+#define                USB_EP_NI0_RXTYPE  0xffc03e1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint0 */
+#define            USB_EP_NI0_RXINTERVAL  0xffc03e20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint0 */
+
+/* USB Endpoint 1 Control Registers */
+
+#define               USB_EP_NI0_TXCOUNT  0xffc03e28   /* Number of bytes to be written to the endpoint0 Tx FIFO */
+#define                USB_EP_NI1_TXMAXP  0xffc03e40   /* Maximum packet size for Host Tx endpoint1 */
+#define                 USB_EP_NI1_TXCSR  0xffc03e44   /* Control Status register for endpoint1 */
+#define                USB_EP_NI1_RXMAXP  0xffc03e48   /* Maximum packet size for Host Rx endpoint1 */
+#define                 USB_EP_NI1_RXCSR  0xffc03e4c   /* Control Status register for Host Rx endpoint1 */
+#define               USB_EP_NI1_RXCOUNT  0xffc03e50   /* Number of bytes received in endpoint1 FIFO */
+#define                USB_EP_NI1_TXTYPE  0xffc03e54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint1 */
+#define            USB_EP_NI1_TXINTERVAL  0xffc03e58   /* Sets the NAK response timeout on Endpoint1 */
+#define                USB_EP_NI1_RXTYPE  0xffc03e5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint1 */
+#define            USB_EP_NI1_RXINTERVAL  0xffc03e60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint1 */
+
+/* USB Endpoint 2 Control Registers */
+
+#define               USB_EP_NI1_TXCOUNT  0xffc03e68   /* Number of bytes to be written to the+H102 endpoint1 Tx FIFO */
+#define                USB_EP_NI2_TXMAXP  0xffc03e80   /* Maximum packet size for Host Tx endpoint2 */
+#define                 USB_EP_NI2_TXCSR  0xffc03e84   /* Control Status register for endpoint2 */
+#define                USB_EP_NI2_RXMAXP  0xffc03e88   /* Maximum packet size for Host Rx endpoint2 */
+#define                 USB_EP_NI2_RXCSR  0xffc03e8c   /* Control Status register for Host Rx endpoint2 */
+#define               USB_EP_NI2_RXCOUNT  0xffc03e90   /* Number of bytes received in endpoint2 FIFO */
+#define                USB_EP_NI2_TXTYPE  0xffc03e94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint2 */
+#define            USB_EP_NI2_TXINTERVAL  0xffc03e98   /* Sets the NAK response timeout on Endpoint2 */
+#define                USB_EP_NI2_RXTYPE  0xffc03e9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint2 */
+#define            USB_EP_NI2_RXINTERVAL  0xffc03ea0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint2 */
+
+/* USB Endpoint 3 Control Registers */
+
+#define               USB_EP_NI2_TXCOUNT  0xffc03ea8   /* Number of bytes to be written to the endpoint2 Tx FIFO */
+#define                USB_EP_NI3_TXMAXP  0xffc03ec0   /* Maximum packet size for Host Tx endpoint3 */
+#define                 USB_EP_NI3_TXCSR  0xffc03ec4   /* Control Status register for endpoint3 */
+#define                USB_EP_NI3_RXMAXP  0xffc03ec8   /* Maximum packet size for Host Rx endpoint3 */
+#define                 USB_EP_NI3_RXCSR  0xffc03ecc   /* Control Status register for Host Rx endpoint3 */
+#define               USB_EP_NI3_RXCOUNT  0xffc03ed0   /* Number of bytes received in endpoint3 FIFO */
+#define                USB_EP_NI3_TXTYPE  0xffc03ed4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint3 */
+#define            USB_EP_NI3_TXINTERVAL  0xffc03ed8   /* Sets the NAK response timeout on Endpoint3 */
+#define                USB_EP_NI3_RXTYPE  0xffc03edc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint3 */
+#define            USB_EP_NI3_RXINTERVAL  0xffc03ee0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint3 */
+
+/* USB Endpoint 4 Control Registers */
+
+#define               USB_EP_NI3_TXCOUNT  0xffc03ee8   /* Number of bytes to be written to the H124endpoint3 Tx FIFO */
+#define                USB_EP_NI4_TXMAXP  0xffc03f00   /* Maximum packet size for Host Tx endpoint4 */
+#define                 USB_EP_NI4_TXCSR  0xffc03f04   /* Control Status register for endpoint4 */
+#define                USB_EP_NI4_RXMAXP  0xffc03f08   /* Maximum packet size for Host Rx endpoint4 */
+#define                 USB_EP_NI4_RXCSR  0xffc03f0c   /* Control Status register for Host Rx endpoint4 */
+#define               USB_EP_NI4_RXCOUNT  0xffc03f10   /* Number of bytes received in endpoint4 FIFO */
+#define                USB_EP_NI4_TXTYPE  0xffc03f14   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint4 */
+#define            USB_EP_NI4_TXINTERVAL  0xffc03f18   /* Sets the NAK response timeout on Endpoint4 */
+#define                USB_EP_NI4_RXTYPE  0xffc03f1c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint4 */
+#define            USB_EP_NI4_RXINTERVAL  0xffc03f20   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint4 */
+
+/* USB Endpoint 5 Control Registers */
+
+#define               USB_EP_NI4_TXCOUNT  0xffc03f28   /* Number of bytes to be written to the endpoint4 Tx FIFO */
+#define                USB_EP_NI5_TXMAXP  0xffc03f40   /* Maximum packet size for Host Tx endpoint5 */
+#define                 USB_EP_NI5_TXCSR  0xffc03f44   /* Control Status register for endpoint5 */
+#define                USB_EP_NI5_RXMAXP  0xffc03f48   /* Maximum packet size for Host Rx endpoint5 */
+#define                 USB_EP_NI5_RXCSR  0xffc03f4c   /* Control Status register for Host Rx endpoint5 */
+#define               USB_EP_NI5_RXCOUNT  0xffc03f50   /* Number of bytes received in endpoint5 FIFO */
+#define                USB_EP_NI5_TXTYPE  0xffc03f54   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint5 */
+#define            USB_EP_NI5_TXINTERVAL  0xffc03f58   /* Sets the NAK response timeout on Endpoint5 */
+#define                USB_EP_NI5_RXTYPE  0xffc03f5c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint5 */
+#define            USB_EP_NI5_RXINTERVAL  0xffc03f60   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint5 */
+
+/* USB Endpoint 6 Control Registers */
+
+#define               USB_EP_NI5_TXCOUNT  0xffc03f68   /* Number of bytes to be written to the H145endpoint5 Tx FIFO */
+#define                USB_EP_NI6_TXMAXP  0xffc03f80   /* Maximum packet size for Host Tx endpoint6 */
+#define                 USB_EP_NI6_TXCSR  0xffc03f84   /* Control Status register for endpoint6 */
+#define                USB_EP_NI6_RXMAXP  0xffc03f88   /* Maximum packet size for Host Rx endpoint6 */
+#define                 USB_EP_NI6_RXCSR  0xffc03f8c   /* Control Status register for Host Rx endpoint6 */
+#define               USB_EP_NI6_RXCOUNT  0xffc03f90   /* Number of bytes received in endpoint6 FIFO */
+#define                USB_EP_NI6_TXTYPE  0xffc03f94   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint6 */
+#define            USB_EP_NI6_TXINTERVAL  0xffc03f98   /* Sets the NAK response timeout on Endpoint6 */
+#define                USB_EP_NI6_RXTYPE  0xffc03f9c   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint6 */
+#define            USB_EP_NI6_RXINTERVAL  0xffc03fa0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint6 */
+
+/* USB Endpoint 7 Control Registers */
+
+#define               USB_EP_NI6_TXCOUNT  0xffc03fa8   /* Number of bytes to be written to the endpoint6 Tx FIFO */
+#define                USB_EP_NI7_TXMAXP  0xffc03fc0   /* Maximum packet size for Host Tx endpoint7 */
+#define                 USB_EP_NI7_TXCSR  0xffc03fc4   /* Control Status register for endpoint7 */
+#define                USB_EP_NI7_RXMAXP  0xffc03fc8   /* Maximum packet size for Host Rx endpoint7 */
+#define                 USB_EP_NI7_RXCSR  0xffc03fcc   /* Control Status register for Host Rx endpoint7 */
+#define               USB_EP_NI7_RXCOUNT  0xffc03fd0   /* Number of bytes received in endpoint7 FIFO */
+#define                USB_EP_NI7_TXTYPE  0xffc03fd4   /* Sets the transaction protocol and peripheral endpoint number for the Host Tx endpoint7 */
+#define            USB_EP_NI7_TXINTERVAL  0xffc03fd8   /* Sets the NAK response timeout on Endpoint7 */
+#define                USB_EP_NI7_RXTYPE  0xffc03fdc   /* Sets the transaction protocol and peripheral endpoint number for the Host Rx endpoint7 */
+#define            USB_EP_NI7_RXINTERVAL  0xffc03ff0   /* Sets the polling interval for Interrupt/Isochronous transfers or the NAK response timeout on Bulk transfers for Host Rx endpoint7 */
+#define               USB_EP_NI7_TXCOUNT  0xffc03ff8   /* Number of bytes to be written to the endpoint7 Tx FIFO */
+#define                USB_DMA_INTERRUPT  0xffc04000   /* Indicates pending interrupts for the DMA channels */
+
+/* USB Channel 0 Config Registers */
+
+#define                  USB_DMA0CONTROL  0xffc04004   /* DMA master channel 0 configuration */
+#define                  USB_DMA0ADDRLOW  0xffc04008   /* Lower 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0ADDRHIGH  0xffc0400c   /* Upper 16-bits of memory source/destination address for DMA master channel 0 */
+#define                 USB_DMA0COUNTLOW  0xffc04010   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 0 */
+#define                USB_DMA0COUNTHIGH  0xffc04014   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 0 */
+
+/* USB Channel 1 Config Registers */
+
+#define                  USB_DMA1CONTROL  0xffc04024   /* DMA master channel 1 configuration */
+#define                  USB_DMA1ADDRLOW  0xffc04028   /* Lower 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1ADDRHIGH  0xffc0402c   /* Upper 16-bits of memory source/destination address for DMA master channel 1 */
+#define                 USB_DMA1COUNTLOW  0xffc04030   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 1 */
+#define                USB_DMA1COUNTHIGH  0xffc04034   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 1 */
+
+/* USB Channel 2 Config Registers */
+
+#define                  USB_DMA2CONTROL  0xffc04044   /* DMA master channel 2 configuration */
+#define                  USB_DMA2ADDRLOW  0xffc04048   /* Lower 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2ADDRHIGH  0xffc0404c   /* Upper 16-bits of memory source/destination address for DMA master channel 2 */
+#define                 USB_DMA2COUNTLOW  0xffc04050   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 2 */
+#define                USB_DMA2COUNTHIGH  0xffc04054   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 2 */
+
+/* USB Channel 3 Config Registers */
+
+#define                  USB_DMA3CONTROL  0xffc04064   /* DMA master channel 3 configuration */
+#define                  USB_DMA3ADDRLOW  0xffc04068   /* Lower 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3ADDRHIGH  0xffc0406c   /* Upper 16-bits of memory source/destination address for DMA master channel 3 */
+#define                 USB_DMA3COUNTLOW  0xffc04070   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 3 */
+#define                USB_DMA3COUNTHIGH  0xffc04074   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 3 */
+
+/* USB Channel 4 Config Registers */
+
+#define                  USB_DMA4CONTROL  0xffc04084   /* DMA master channel 4 configuration */
+#define                  USB_DMA4ADDRLOW  0xffc04088   /* Lower 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4ADDRHIGH  0xffc0408c   /* Upper 16-bits of memory source/destination address for DMA master channel 4 */
+#define                 USB_DMA4COUNTLOW  0xffc04090   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 4 */
+#define                USB_DMA4COUNTHIGH  0xffc04094   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 4 */
+
+/* USB Channel 5 Config Registers */
+
+#define                  USB_DMA5CONTROL  0xffc040a4   /* DMA master channel 5 configuration */
+#define                  USB_DMA5ADDRLOW  0xffc040a8   /* Lower 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5ADDRHIGH  0xffc040ac   /* Upper 16-bits of memory source/destination address for DMA master channel 5 */
+#define                 USB_DMA5COUNTLOW  0xffc040b0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 5 */
+#define                USB_DMA5COUNTHIGH  0xffc040b4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 5 */
+
+/* USB Channel 6 Config Registers */
+
+#define                  USB_DMA6CONTROL  0xffc040c4   /* DMA master channel 6 configuration */
+#define                  USB_DMA6ADDRLOW  0xffc040c8   /* Lower 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6ADDRHIGH  0xffc040cc   /* Upper 16-bits of memory source/destination address for DMA master channel 6 */
+#define                 USB_DMA6COUNTLOW  0xffc040d0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 6 */
+#define                USB_DMA6COUNTHIGH  0xffc040d4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 6 */
+
+/* USB Channel 7 Config Registers */
+
+#define                  USB_DMA7CONTROL  0xffc040e4   /* DMA master channel 7 configuration */
+#define                  USB_DMA7ADDRLOW  0xffc040e8   /* Lower 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7ADDRHIGH  0xffc040ec   /* Upper 16-bits of memory source/destination address for DMA master channel 7 */
+#define                 USB_DMA7COUNTLOW  0xffc040f0   /* Lower 16-bits of byte count of DMA transfer for DMA master channel 7 */
+#define                USB_DMA7COUNTHIGH  0xffc040f4   /* Upper 16-bits of byte count of DMA transfer for DMA master channel 7 */
+
+/* Keypad Registers */
+
+#define                         KPAD_CTL  0xffc04100   /* Controls keypad module enable and disable */
+#define                    KPAD_PRESCALE  0xffc04104   /* Establish a time base for programing the KPAD_MSEL register */
+#define                        KPAD_MSEL  0xffc04108   /* Selects delay parameters for keypad interface sensitivity */
+#define                      KPAD_ROWCOL  0xffc0410c   /* Captures the row and column output values of the keys pressed */
+#define                        KPAD_STAT  0xffc04110   /* Holds and clears the status of the keypad interface interrupt */
+#define                    KPAD_SOFTEVAL  0xffc04114   /* Lets software force keypad interface to check for keys being pressed */
+
+/* Pixel Compositor (PIXC) Registers */
+
+#define                         PIXC_CTL  0xffc04400   /* Overlay enable, resampling mode, I/O data format, transparency enable, watermark level, FIFO status */
+#define                         PIXC_PPL  0xffc04404   /* Holds the number of pixels per line of the display */
+#define                         PIXC_LPF  0xffc04408   /* Holds the number of lines per frame of the display */
+#define                     PIXC_AHSTART  0xffc0440c   /* Contains horizontal start pixel information of the overlay data (set A) */
+#define                       PIXC_AHEND  0xffc04410   /* Contains horizontal end pixel information of the overlay data (set A) */
+#define                     PIXC_AVSTART  0xffc04414   /* Contains vertical start pixel information of the overlay data (set A) */
+#define                       PIXC_AVEND  0xffc04418   /* Contains vertical end pixel information of the overlay data (set A) */
+#define                     PIXC_ATRANSP  0xffc0441c   /* Contains the transparency ratio (set A) */
+#define                     PIXC_BHSTART  0xffc04420   /* Contains horizontal start pixel information of the overlay data (set B) */
+#define                       PIXC_BHEND  0xffc04424   /* Contains horizontal end pixel information of the overlay data (set B) */
+#define                     PIXC_BVSTART  0xffc04428   /* Contains vertical start pixel information of the overlay data (set B) */
+#define                       PIXC_BVEND  0xffc0442c   /* Contains vertical end pixel information of the overlay data (set B) */
+#define                     PIXC_BTRANSP  0xffc04430   /* Contains the transparency ratio (set B) */
+#define                    PIXC_INTRSTAT  0xffc0443c   /* Overlay interrupt configuration/status */
+#define                       PIXC_RYCON  0xffc04440   /* Color space conversion matrix register. Contains the R/Y conversion coefficients */
+#define                       PIXC_GUCON  0xffc04444   /* Color space conversion matrix register. Contains the G/U conversion coefficients */
+#define                       PIXC_BVCON  0xffc04448   /* Color space conversion matrix register. Contains the B/V conversion coefficients */
+#define                      PIXC_CCBIAS  0xffc0444c   /* Bias values for the color space conversion matrix */
+#define                          PIXC_TC  0xffc04450   /* Holds the transparent color value */
+
+/* Handshake MDMA 0 Registers */
+
+#define                   HMDMA0_CONTROL  0xffc04500   /* Handshake MDMA0 Control Register */
+#define                    HMDMA0_ECINIT  0xffc04504   /* Handshake MDMA0 Initial Edge Count Register */
+#define                    HMDMA0_BCINIT  0xffc04508   /* Handshake MDMA0 Initial Block Count Register */
+#define                  HMDMA0_ECURGENT  0xffc0450c   /* Handshake MDMA0 Urgent Edge Count Threshhold Register */
+#define                HMDMA0_ECOVERFLOW  0xffc04510   /* Handshake MDMA0 Edge Count Overflow Interrupt Register */
+#define                    HMDMA0_ECOUNT  0xffc04514   /* Handshake MDMA0 Current Edge Count Register */
+#define                    HMDMA0_BCOUNT  0xffc04518   /* Handshake MDMA0 Current Block Count Register */
+
+/* Handshake MDMA 1 Registers */
+
+#define                   HMDMA1_CONTROL  0xffc04540   /* Handshake MDMA1 Control Register */
+#define                    HMDMA1_ECINIT  0xffc04544   /* Handshake MDMA1 Initial Edge Count Register */
+#define                    HMDMA1_BCINIT  0xffc04548   /* Handshake MDMA1 Initial Block Count Register */
+#define                  HMDMA1_ECURGENT  0xffc0454c   /* Handshake MDMA1 Urgent Edge Count Threshhold Register */
+#define                HMDMA1_ECOVERFLOW  0xffc04550   /* Handshake MDMA1 Edge Count Overflow Interrupt Register */
+#define                    HMDMA1_ECOUNT  0xffc04554   /* Handshake MDMA1 Current Edge Count Register */
+#define                    HMDMA1_BCOUNT  0xffc04558   /* Handshake MDMA1 Current Block Count Register */
+
+
+/* ********************************************************** */
+/*     SINGLE BIT MACRO PAIRS (bit mask and negated one)      */
+/*     and MULTI BIT READ MACROS                              */
+/* ********************************************************** */
+
+/* Bit masks for PIXC_CTL */
+
+#define                   PIXC_EN  0x1        /* Pixel Compositor Enable */
+#define                  nPIXC_EN  0x0       
+#define                  OVR_A_EN  0x2        /* Overlay A Enable */
+#define                 nOVR_A_EN  0x0       
+#define                  OVR_B_EN  0x4        /* Overlay B Enable */
+#define                 nOVR_B_EN  0x0       
+#define                  IMG_FORM  0x8        /* Image Data Format */
+#define                 nIMG_FORM  0x0       
+#define                  OVR_FORM  0x10       /* Overlay Data Format */
+#define                 nOVR_FORM  0x0       
+#define                  OUT_FORM  0x20       /* Output Data Format */
+#define                 nOUT_FORM  0x0       
+#define                   UDS_MOD  0x40       /* Resampling Mode */
+#define                  nUDS_MOD  0x0       
+#define                     TC_EN  0x80       /* Transparent Color Enable */
+#define                    nTC_EN  0x0       
+#define                  IMG_STAT  0x300      /* Image FIFO Status */
+#define                  OVR_STAT  0xc00      /* Overlay FIFO Status */
+#define                    WM_LVL  0x3000     /* FIFO Watermark Level */
+
+/* Bit masks for PIXC_AHSTART */
+
+#define                  A_HSTART  0xfff      /* Horizontal Start Coordinates */
+
+/* Bit masks for PIXC_AHEND */
+
+#define                    A_HEND  0xfff      /* Horizontal End Coordinates */
+
+/* Bit masks for PIXC_AVSTART */
+
+#define                  A_VSTART  0x3ff      /* Vertical Start Coordinates */
+
+/* Bit masks for PIXC_AVEND */
+
+#define                    A_VEND  0x3ff      /* Vertical End Coordinates */
+
+/* Bit masks for PIXC_ATRANSP */
+
+#define                  A_TRANSP  0xf        /* Transparency Value */
+
+/* Bit masks for PIXC_BHSTART */
+
+#define                  B_HSTART  0xfff      /* Horizontal Start Coordinates */
+
+/* Bit masks for PIXC_BHEND */
+
+#define                    B_HEND  0xfff      /* Horizontal End Coordinates */
+
+/* Bit masks for PIXC_BVSTART */
+
+#define                  B_VSTART  0x3ff      /* Vertical Start Coordinates */
+
+/* Bit masks for PIXC_BVEND */
+
+#define                    B_VEND  0x3ff      /* Vertical End Coordinates */
+
+/* Bit masks for PIXC_BTRANSP */
+
+#define                  B_TRANSP  0xf        /* Transparency Value */
+
+/* Bit masks for PIXC_INTRSTAT */
+
+#define                OVR_INT_EN  0x1        /* Interrupt at End of Last Valid Overlay */
+#define               nOVR_INT_EN  0x0       
+#define                FRM_INT_EN  0x2        /* Interrupt at End of Frame */
+#define               nFRM_INT_EN  0x0       
+#define              OVR_INT_STAT  0x4        /* Overlay Interrupt Status */
+#define             nOVR_INT_STAT  0x0       
+#define              FRM_INT_STAT  0x8        /* Frame Interrupt Status */
+#define             nFRM_INT_STAT  0x0       
+
+/* Bit masks for PIXC_RYCON */
+
+#define                       A11  0x3ff      /* A11 in the Coefficient Matrix */
+#define                       A12  0xffc00    /* A12 in the Coefficient Matrix */
+#define                       A13  0x3ff00000 /* A13 in the Coefficient Matrix */
+#define                  RY_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nRY_MULT4  0x0       
+
+/* Bit masks for PIXC_GUCON */
+
+#define                       A21  0x3ff      /* A21 in the Coefficient Matrix */
+#define                       A22  0xffc00    /* A22 in the Coefficient Matrix */
+#define                       A23  0x3ff00000 /* A23 in the Coefficient Matrix */
+#define                  GU_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nGU_MULT4  0x0       
+
+/* Bit masks for PIXC_BVCON */
+
+#define                       A31  0x3ff      /* A31 in the Coefficient Matrix */
+#define                       A32  0xffc00    /* A32 in the Coefficient Matrix */
+#define                       A33  0x3ff00000 /* A33 in the Coefficient Matrix */
+#define                  BV_MULT4  0x40000000 /* Multiply Row by 4 */
+#define                 nBV_MULT4  0x0       
+
+/* Bit masks for PIXC_CCBIAS */
+
+#define                       A14  0x3ff      /* A14 in the Bias Vector */
+#define                       A24  0xffc00    /* A24 in the Bias Vector */
+#define                       A34  0x3ff00000 /* A34 in the Bias Vector */
+
+/* Bit masks for PIXC_TC */
+
+#define                  RY_TRANS  0xff       /* Transparent Color - R/Y Component */
+#define                  GU_TRANS  0xff00     /* Transparent Color - G/U Component */
+#define                  BV_TRANS  0xff0000   /* Transparent Color - B/V Component */
+
+/* Bit masks for HOST_CONTROL */
+
+#define                   HOST_EN  0x1        /* Host Enable */
+#define                  nHOST_EN  0x0       
+#define                  HOST_END  0x2        /* Host Endianess */
+#define                 nHOST_END  0x0       
+#define                 DATA_SIZE  0x4        /* Data Size */
+#define                nDATA_SIZE  0x0       
+#define                  HOST_RST  0x8        /* Host Reset */
+#define                 nHOST_RST  0x0       
+#define                  HRDY_OVR  0x20       /* Host Ready Override */
+#define                 nHRDY_OVR  0x0       
+#define                  INT_MODE  0x40       /* Interrupt Mode */
+#define                 nINT_MODE  0x0       
+#define                     BT_EN  0x80       /* Bus Timeout Enable */
+#define                    nBT_EN  0x0       
+#define                       EHW  0x100      /* Enable Host Write */
+#define                      nEHW  0x0       
+#define                       EHR  0x200      /* Enable Host Read */
+#define                      nEHR  0x0       
+#define                       BDR  0x400      /* Burst DMA Requests */
+#define                      nBDR  0x0       
+
+/* Bit masks for HOST_STATUS */
+
+#define                     READY  0x1        /* DMA Ready */
+#define                    nREADY  0x0       
+#define                  FIFOFULL  0x2        /* FIFO Full */
+#define                 nFIFOFULL  0x0       
+#define                 FIFOEMPTY  0x4        /* FIFO Empty */
+#define                nFIFOEMPTY  0x0       
+#define                  COMPLETE  0x8        /* DMA Complete */
+#define                 nCOMPLETE  0x0       
+#define                      HSHK  0x10       /* Host Handshake */
+#define                     nHSHK  0x0       
+#define                   TIMEOUT  0x20       /* Host Timeout */
+#define                  nTIMEOUT  0x0       
+#define                      HIRQ  0x40       /* Host Interrupt Request */
+#define                     nHIRQ  0x0       
+#define                ALLOW_CNFG  0x80       /* Allow New Configuration */
+#define               nALLOW_CNFG  0x0       
+#define                   DMA_DIR  0x100      /* DMA Direction */
+#define                  nDMA_DIR  0x0       
+#define                       BTE  0x200      /* Bus Timeout Enabled */
+#define                      nBTE  0x0       
+
+/* Bit masks for HOST_TIMEOUT */
+
+#define             COUNT_TIMEOUT  0x7ff      /* Host Timeout count */
+
+/* Bit masks for MXVR_CONFIG */
+
+#define                    MXVREN  0x1        /* MXVR Enable */
+#define                   nMXVREN  0x0       
+#define                      MMSM  0x2        /* MXVR Master/Slave Mode Select */
+#define                     nMMSM  0x0       
+#define                    ACTIVE  0x4        /* Active Mode */
+#define                   nACTIVE  0x0       
+#define                    SDELAY  0x8        /* Synchronous Data Delay */
+#define                   nSDELAY  0x0       
+#define                   NCMRXEN  0x10       /* Normal Control Message Receive Enable */
+#define                  nNCMRXEN  0x0       
+#define                   RWRRXEN  0x20       /* Remote Write Receive Enable */
+#define                  nRWRRXEN  0x0       
+#define                     MTXEN  0x40       /* MXVR Transmit Data Enable */
+#define                    nMTXEN  0x0       
+#define                    MTXONB  0x80       /* MXVR Phy Transmitter On */
+#define                   nMTXONB  0x0       
+#define                   EPARITY  0x100      /* Even Parity Select */
+#define                  nEPARITY  0x0       
+#define                       MSB  0x1e00     /* Master Synchronous Boundary */
+#define                    APRXEN  0x2000     /* Asynchronous Packet Receive Enable */
+#define                   nAPRXEN  0x0       
+#define                    WAKEUP  0x4000     /* Wake-Up */
+#define                   nWAKEUP  0x0       
+#define                     LMECH  0x8000     /* Lock Mechanism Select */
+#define                    nLMECH  0x0       
+
+/* Bit masks for MXVR_STATE_0 */
+
+#define                      NACT  0x1        /* Network Activity */
+#define                     nNACT  0x0       
+#define                    SBLOCK  0x2        /* Super Block Lock */
+#define                   nSBLOCK  0x0       
+#define                   FMPLLST  0xc        /* Frequency Multiply PLL SM State */
+#define                  CDRPLLST  0xe0       /* Clock/Data Recovery PLL SM State */
+#define                     APBSY  0x100      /* Asynchronous Packet Transmit Buffer Busy */
+#define                    nAPBSY  0x0       
+#define                     APARB  0x200      /* Asynchronous Packet Arbitrating */
+#define                    nAPARB  0x0       
+#define                      APTX  0x400      /* Asynchronous Packet Transmitting */
+#define                     nAPTX  0x0       
+#define                      APRX  0x800      /* Receiving Asynchronous Packet */
+#define                     nAPRX  0x0       
+#define                     CMBSY  0x1000     /* Control Message Transmit Buffer Busy */
+#define                    nCMBSY  0x0       
+#define                     CMARB  0x2000     /* Control Message Arbitrating */
+#define                    nCMARB  0x0       
+#define                      CMTX  0x4000     /* Control Message Transmitting */
+#define                     nCMTX  0x0       
+#define                      CMRX  0x8000     /* Receiving Control Message */
+#define                     nCMRX  0x0       
+#define                    MRXONB  0x10000    /* MRXONB Pin State */
+#define                   nMRXONB  0x0       
+#define                     RGSIP  0x20000    /* Remote Get Source In Progress */
+#define                    nRGSIP  0x0       
+#define                     DALIP  0x40000    /* Resource Deallocate In Progress */
+#define                    nDALIP  0x0       
+#define                      ALIP  0x80000    /* Resource Allocate In Progress */
+#define                     nALIP  0x0       
+#define                     RRDIP  0x100000   /* Remote Read In Progress */
+#define                    nRRDIP  0x0       
+#define                     RWRIP  0x200000   /* Remote Write In Progress */
+#define                    nRWRIP  0x0       
+#define                     FLOCK  0x400000   /* Frame Lock */
+#define                    nFLOCK  0x0       
+#define                     BLOCK  0x800000   /* Block Lock */
+#define                    nBLOCK  0x0       
+#define                       RSB  0xf000000  /* Received Synchronous Boundary */
+#define                   DERRNUM  0xf0000000 /* DMA Error Channel Number */
+
+/* Bit masks for MXVR_STATE_1 */
+
+#define                   SRXNUMB  0xf        /* Synchronous Receive FIFO Number of Bytes */
+#define                   STXNUMB  0xf0       /* Synchronous Transmit FIFO Number of Bytes */
+#define                    APCONT  0x100      /* Asynchronous Packet Continuation */
+#define                   nAPCONT  0x0       
+#define                  OBERRNUM  0xe00      /* DMA Out of Bounds Error Channel Number */
+#define                DMAACTIVE0  0x10000    /* DMA0 Active */
+#define               nDMAACTIVE0  0x0       
+#define                DMAACTIVE1  0x20000    /* DMA1 Active */
+#define               nDMAACTIVE1  0x0       
+#define                DMAACTIVE2  0x40000    /* DMA2 Active */
+#define               nDMAACTIVE2  0x0       
+#define                DMAACTIVE3  0x80000    /* DMA3 Active */
+#define               nDMAACTIVE3  0x0       
+#define                DMAACTIVE4  0x100000   /* DMA4 Active */
+#define               nDMAACTIVE4  0x0       
+#define                DMAACTIVE5  0x200000   /* DMA5 Active */
+#define               nDMAACTIVE5  0x0       
+#define                DMAACTIVE6  0x400000   /* DMA6 Active */
+#define               nDMAACTIVE6  0x0       
+#define                DMAACTIVE7  0x800000   /* DMA7 Active */
+#define               nDMAACTIVE7  0x0       
+#define                  DMAPMEN0  0x1000000  /* DMA0 Pattern Matching Enabled */
+#define                 nDMAPMEN0  0x0       
+#define                  DMAPMEN1  0x2000000  /* DMA1 Pattern Matching Enabled */
+#define                 nDMAPMEN1  0x0       
+#define                  DMAPMEN2  0x4000000  /* DMA2 Pattern Matching Enabled */
+#define                 nDMAPMEN2  0x0       
+#define                  DMAPMEN3  0x8000000  /* DMA3 Pattern Matching Enabled */
+#define                 nDMAPMEN3  0x0       
+#define                  DMAPMEN4  0x10000000 /* DMA4 Pattern Matching Enabled */
+#define                 nDMAPMEN4  0x0       
+#define                  DMAPMEN5  0x20000000 /* DMA5 Pattern Matching Enabled */
+#define                 nDMAPMEN5  0x0       
+#define                  DMAPMEN6  0x40000000 /* DMA6 Pattern Matching Enabled */
+#define                 nDMAPMEN6  0x0       
+#define                  DMAPMEN7  0x80000000 /* DMA7 Pattern Matching Enabled */
+#define                 nDMAPMEN7  0x0       
+
+/* Bit masks for MXVR_INT_STAT_0 */
+
+#define                      NI2A  0x1        /* Network Inactive to Active */
+#define                     nNI2A  0x0       
+#define                      NA2I  0x2        /* Network Active to Inactive */
+#define                     nNA2I  0x0       
+#define                     SBU2L  0x4        /* Super Block Unlock to Lock */
+#define                    nSBU2L  0x0       
+#define                     SBL2U  0x8        /* Super Block Lock to Unlock */
+#define                    nSBL2U  0x0       
+#define                       PRU  0x10       /* Position Register Updated */
+#define                      nPRU  0x0       
+#define                      MPRU  0x20       /* Maximum Position Register Updated */
+#define                     nMPRU  0x0       
+#define                       DRU  0x40       /* Delay Register Updated */
+#define                      nDRU  0x0       
+#define                      MDRU  0x80       /* Maximum Delay Register Updated */
+#define                     nMDRU  0x0       
+#define                       SBU  0x100      /* Synchronous Boundary Updated */
+#define                      nSBU  0x0       
+#define                       ATU  0x200      /* Allocation Table Updated */
+#define                      nATU  0x0       
+#define                      FCZ0  0x400      /* Frame Counter 0 Zero */
+#define                     nFCZ0  0x0       
+#define                      FCZ1  0x800      /* Frame Counter 1 Zero */
+#define                     nFCZ1  0x0       
+#define                      PERR  0x1000     /* Parity Error */
+#define                     nPERR  0x0       
+#define                      MH2L  0x2000     /* MRXONB High to Low */
+#define                     nMH2L  0x0       
+#define                      ML2H  0x4000     /* MRXONB Low to High */
+#define                     nML2H  0x0       
+#define                       WUP  0x8000     /* Wake-Up Preamble Received */
+#define                      nWUP  0x0       
+#define                      FU2L  0x10000    /* Frame Unlock to Lock */
+#define                     nFU2L  0x0       
+#define                      FL2U  0x20000    /* Frame Lock to Unlock */
+#define                     nFL2U  0x0       
+#define                      BU2L  0x40000    /* Block Unlock to Lock */
+#define                     nBU2L  0x0       
+#define                      BL2U  0x80000    /* Block Lock to Unlock */
+#define                     nBL2U  0x0       
+#define                     OBERR  0x100000   /* DMA Out of Bounds Error */
+#define                    nOBERR  0x0       
+#define                       PFL  0x200000   /* PLL Frequency Locked */
+#define                      nPFL  0x0       
+#define                       SCZ  0x400000   /* System Clock Counter Zero */
+#define                      nSCZ  0x0       
+#define                      FERR  0x800000   /* FIFO Error */
+#define                     nFERR  0x0       
+#define                       CMR  0x1000000  /* Control Message Received */
+#define                      nCMR  0x0       
+#define                     CMROF  0x2000000  /* Control Message Receive Buffer Overflow */
+#define                    nCMROF  0x0       
+#define                      CMTS  0x4000000  /* Control Message Transmit Buffer Successfully Sent */
+#define                     nCMTS  0x0       
+#define                      CMTC  0x8000000  /* Control Message Transmit Buffer Successfully Cancelled */
+#define                     nCMTC  0x0       
+#define                      RWRC  0x10000000 /* Remote Write Control Message Completed */
+#define                     nRWRC  0x0       
+#define                       BCZ  0x20000000 /* Block Counter Zero */
+#define                      nBCZ  0x0       
+#define                     BMERR  0x40000000 /* Biphase Mark Coding Error */
+#define                    nBMERR  0x0       
+#define                      DERR  0x80000000 /* DMA Error */
+#define                     nDERR  0x0       
+
+/* Bit masks for MXVR_INT_STAT_1 */
+
+#define                    HDONE0  0x1        /* DMA0 Half Done */
+#define                   nHDONE0  0x0       
+#define                     DONE0  0x2        /* DMA0 Done */
+#define                    nDONE0  0x0       
+#define                       APR  0x4        /* Asynchronous Packet Received */
+#define                      nAPR  0x0       
+#define                     APROF  0x8        /* Asynchronous Packet Receive Buffer Overflow */
+#define                    nAPROF  0x0       
+#define                    HDONE1  0x10       /* DMA1 Half Done */
+#define                   nHDONE1  0x0       
+#define                     DONE1  0x20       /* DMA1 Done */
+#define                    nDONE1  0x0       
+#define                      APTS  0x40       /* Asynchronous Packet Transmit Buffer Successfully Sent */
+#define                     nAPTS  0x0       
+#define                      APTC  0x80       /* Asynchronous Packet Transmit Buffer Successfully Cancelled */
+#define                     nAPTC  0x0       
+#define                    HDONE2  0x100      /* DMA2 Half Done */
+#define                   nHDONE2  0x0       
+#define                     DONE2  0x200      /* DMA2 Done */
+#define                    nDONE2  0x0       
+#define                     APRCE  0x400      /* Asynchronous Packet Receive CRC Error */
+#define                    nAPRCE  0x0       
+#define                     APRPE  0x800      /* Asynchronous Packet Receive Packet Error */
+#define                    nAPRPE  0x0       
+#define                    HDONE3  0x1000     /* DMA3 Half Done */
+#define                   nHDONE3  0x0       
+#define                     DONE3  0x2000     /* DMA3 Done */
+#define                    nDONE3  0x0       
+#define                    HDONE4  0x10000    /* DMA4 Half Done */
+#define                   nHDONE4  0x0       
+#define                     DONE4  0x20000    /* DMA4 Done */
+#define                    nDONE4  0x0       
+#define                    HDONE5  0x100000   /* DMA5 Half Done */
+#define                   nHDONE5  0x0       
+#define                     DONE5  0x200000   /* DMA5 Done */
+#define                    nDONE5  0x0       
+#define                    HDONE6  0x1000000  /* DMA6 Half Done */
+#define                   nHDONE6  0x0       
+#define                     DONE6  0x2000000  /* DMA6 Done */
+#define                    nDONE6  0x0       
+#define                    HDONE7  0x10000000 /* DMA7 Half Done */
+#define                   nHDONE7  0x0       
+#define                     DONE7  0x20000000 /* DMA7 Done */
+#define                    nDONE7  0x0       
+
+/* Bit masks for MXVR_INT_EN_0 */
+
+#define                    NI2AEN  0x1        /* Network Inactive to Active Interrupt Enable */
+#define                   nNI2AEN  0x0       
+#define                    NA2IEN  0x2        /* Network Active to Inactive Interrupt Enable */
+#define                   nNA2IEN  0x0       
+#define                   SBU2LEN  0x4        /* Super Block Unlock to Lock Interrupt Enable */
+#define                  nSBU2LEN  0x0       
+#define                   SBL2UEN  0x8        /* Super Block Lock to Unlock Interrupt Enable */
+#define                  nSBL2UEN  0x0       
+#define                     PRUEN  0x10       /* Position Register Updated Interrupt Enable */
+#define                    nPRUEN  0x0       
+#define                    MPRUEN  0x20       /* Maximum Position Register Updated Interrupt Enable */
+#define                   nMPRUEN  0x0       
+#define                     DRUEN  0x40       /* Delay Register Updated Interrupt Enable */
+#define                    nDRUEN  0x0       
+#define                    MDRUEN  0x80       /* Maximum Delay Register Updated Interrupt Enable */
+#define                   nMDRUEN  0x0       
+#define                     SBUEN  0x100      /* Synchronous Boundary Updated Interrupt Enable */
+#define                    nSBUEN  0x0       
+#define                     ATUEN  0x200      /* Allocation Table Updated Interrupt Enable */
+#define                    nATUEN  0x0       
+#define                    FCZ0EN  0x400      /* Frame Counter 0 Zero Interrupt Enable */
+#define                   nFCZ0EN  0x0       
+#define                    FCZ1EN  0x800      /* Frame Counter 1 Zero Interrupt Enable */
+#define                   nFCZ1EN  0x0       
+#define                    PERREN  0x1000     /* Parity Error Interrupt Enable */
+#define                   nPERREN  0x0       
+#define                    MH2LEN  0x2000     /* MRXONB High to Low Interrupt Enable */
+#define                   nMH2LEN  0x0       
+#define                    ML2HEN  0x4000     /* MRXONB Low to High Interrupt Enable */
+#define                   nML2HEN  0x0       
+#define                     WUPEN  0x8000     /* Wake-Up Preamble Received Interrupt Enable */
+#define                    nWUPEN  0x0       
+#define                    FU2LEN  0x10000    /* Frame Unlock to Lock Interrupt Enable */
+#define                   nFU2LEN  0x0       
+#define                    FL2UEN  0x20000    /* Frame Lock to Unlock Interrupt Enable */
+#define                   nFL2UEN  0x0       
+#define                    BU2LEN  0x40000    /* Block Unlock to Lock Interrupt Enable */
+#define                   nBU2LEN  0x0       
+#define                    BL2UEN  0x80000    /* Block Lock to Unlock Interrupt Enable */
+#define                   nBL2UEN  0x0       
+#define                   OBERREN  0x100000   /* DMA Out of Bounds Error Interrupt Enable */
+#define                  nOBERREN  0x0       
+#define                     PFLEN  0x200000   /* PLL Frequency Locked Interrupt Enable */
+#define                    nPFLEN  0x0       
+#define                     SCZEN  0x400000   /* System Clock Counter Zero Interrupt Enable */
+#define                    nSCZEN  0x0       
+#define                    FERREN  0x800000   /* FIFO Error Interrupt Enable */
+#define                   nFERREN  0x0       
+#define                     CMREN  0x1000000  /* Control Message Received Interrupt Enable */
+#define                    nCMREN  0x0       
+#define                   CMROFEN  0x2000000  /* Control Message Receive Buffer Overflow Interrupt Enable */
+#define                  nCMROFEN  0x0       
+#define                    CMTSEN  0x4000000  /* Control Message Transmit Buffer Successfully Sent Interrupt Enable */
+#define                   nCMTSEN  0x0       
+#define                    CMTCEN  0x8000000  /* Control Message Transmit Buffer Successfully Cancelled Interrupt Enable */
+#define                   nCMTCEN  0x0       
+#define                    RWRCEN  0x10000000 /* Remote Write Control Message Completed Interrupt Enable */
+#define                   nRWRCEN  0x0       
+#define                     BCZEN  0x20000000 /* Block Counter Zero Interrupt Enable */
+#define                    nBCZEN  0x0       
+#define                   BMERREN  0x40000000 /* Biphase Mark Coding Error Interrupt Enable */
+#define                  nBMERREN  0x0       
+#define                    DERREN  0x80000000 /* DMA Error Interrupt Enable */
+#define                   nDERREN  0x0       
+
+/* Bit masks for MXVR_INT_EN_1 */
+
+#define                  HDONEEN0  0x1        /* DMA0 Half Done Interrupt Enable */
+#define                 nHDONEEN0  0x0       
+#define                   DONEEN0  0x2        /* DMA0 Done Interrupt Enable */
+#define                  nDONEEN0  0x0       
+#define                     APREN  0x4        /* Asynchronous Packet Received Interrupt Enable */
+#define                    nAPREN  0x0       
+#define                   APROFEN  0x8        /* Asynchronous Packet Receive Buffer Overflow Interrupt Enable */
+#define                  nAPROFEN  0x0       
+#define                  HDONEEN1  0x10       /* DMA1 Half Done Interrupt Enable */
+#define                 nHDONEEN1  0x0       
+#define                   DONEEN1  0x20       /* DMA1 Done Interrupt Enable */
+#define                  nDONEEN1  0x0       
+#define                    APTSEN  0x40       /* Asynchronous Packet Transmit Buffer Successfully Sent Interrupt Enable */
+#define                   nAPTSEN  0x0       
+#define                    APTCEN  0x80       /* Asynchronous Packet Transmit Buffer Successfully Cancelled Interrupt Enable */
+#define                   nAPTCEN  0x0       
+#define                  HDONEEN2  0x100      /* DMA2 Half Done Interrupt Enable */
+#define                 nHDONEEN2  0x0       
+#define                   DONEEN2  0x200      /* DMA2 Done Interrupt Enable */
+#define                  nDONEEN2  0x0       
+#define                   APRCEEN  0x400      /* Asynchronous Packet Receive CRC Error Interrupt Enable */
+#define                  nAPRCEEN  0x0       
+#define                   APRPEEN  0x800      /* Asynchronous Packet Receive Packet Error Interrupt Enable */
+#define                  nAPRPEEN  0x0       
+#define                  HDONEEN3  0x1000     /* DMA3 Half Done Interrupt Enable */
+#define                 nHDONEEN3  0x0       
+#define                   DONEEN3  0x2000     /* DMA3 Done Interrupt Enable */
+#define                  nDONEEN3  0x0       
+#define                  HDONEEN4  0x10000    /* DMA4 Half Done Interrupt Enable */
+#define                 nHDONEEN4  0x0       
+#define                   DONEEN4  0x20000    /* DMA4 Done Interrupt Enable */
+#define                  nDONEEN4  0x0       
+#define                  HDONEEN5  0x100000   /* DMA5 Half Done Interrupt Enable */
+#define                 nHDONEEN5  0x0       
+#define                   DONEEN5  0x200000   /* DMA5 Done Interrupt Enable */
+#define                  nDONEEN5  0x0       
+#define                  HDONEEN6  0x1000000  /* DMA6 Half Done Interrupt Enable */
+#define                 nHDONEEN6  0x0       
+#define                   DONEEN6  0x2000000  /* DMA6 Done Interrupt Enable */
+#define                  nDONEEN6  0x0       
+#define                  HDONEEN7  0x10000000 /* DMA7 Half Done Interrupt Enable */
+#define                 nHDONEEN7  0x0       
+#define                   DONEEN7  0x20000000 /* DMA7 Done Interrupt Enable */
+#define                  nDONEEN7  0x0       
+
+/* Bit masks for MXVR_POSITION */
+
+#define                  POSITION  0x3f       /* Node Position */
+#define                    PVALID  0x8000     /* Node Position Valid */
+#define                   nPVALID  0x0       
+
+/* Bit masks for MXVR_MAX_POSITION */
+
+#define                 MPOSITION  0x3f       /* Maximum Node Position */
+#define                   MPVALID  0x8000     /* Maximum Node Position Valid */
+#define                  nMPVALID  0x0       
+
+/* Bit masks for MXVR_DELAY */
+
+#define                     DELAY  0x3f       /* Node Frame Delay */
+#define                    DVALID  0x8000     /* Node Frame Delay Valid */
+#define                   nDVALID  0x0       
+
+/* Bit masks for MXVR_MAX_DELAY */
+
+#define                    MDELAY  0x3f       /* Maximum Node Frame Delay */
+#define                   MDVALID  0x8000     /* Maximum Node Frame Delay Valid */
+#define                  nMDVALID  0x0       
+
+/* Bit masks for MXVR_LADDR */
+
+#define                     LADDR  0xffff     /* Logical Address */
+#define                    LVALID  0x80000000 /* Logical Address Valid */
+#define                   nLVALID  0x0       
+
+/* Bit masks for MXVR_GADDR */
+
+#define                    GADDRL  0xff       /* Group Address Lower Byte */
+#define                    GVALID  0x8000     /* Group Address Valid */
+#define                   nGVALID  0x0       
+
+/* Bit masks for MXVR_AADDR */
+
+#define                     AADDR  0xffff     /* Alternate Address */
+#define                    AVALID  0x80000000 /* Alternate Address Valid */
+#define                   nAVALID  0x0       
+
+/* Bit masks for MXVR_ALLOC_0 */
+
+#define                       CL0  0x7f       /* Channel 0 Connection Label */
+#define                      CIU0  0x80       /* Channel 0 In Use */
+#define                     nCIU0  0x0       
+#define                       CL1  0x7f00     /* Channel 0 Connection Label */
+#define                      CIU1  0x8000     /* Channel 0 In Use */
+#define                     nCIU1  0x0       
+#define                       CL2  0x7f0000   /* Channel 0 Connection Label */
+#define                      CIU2  0x800000   /* Channel 0 In Use */
+#define                     nCIU2  0x0       
+#define                       CL3  0x7f000000 /* Channel 0 Connection Label */
+#define                      CIU3  0x80000000 /* Channel 0 In Use */
+#define                     nCIU3  0x0       
+
+/* Bit masks for MXVR_ALLOC_1 */
+
+#define                       CL4  0x7f       /* Channel 4 Connection Label */
+#define                      CIU4  0x80       /* Channel 4 In Use */
+#define                     nCIU4  0x0       
+#define                       CL5  0x7f00     /* Channel 5 Connection Label */
+#define                      CIU5  0x8000     /* Channel 5 In Use */
+#define                     nCIU5  0x0       
+#define                       CL6  0x7f0000   /* Channel 6 Connection Label */
+#define                      CIU6  0x800000   /* Channel 6 In Use */
+#define                     nCIU6  0x0       
+#define                       CL7  0x7f000000 /* Channel 7 Connection Label */
+#define                      CIU7  0x80000000 /* Channel 7 In Use */
+#define                     nCIU7  0x0       
+
+/* Bit masks for MXVR_ALLOC_2 */
+
+#define                       CL8  0x7f       /* Channel 8 Connection Label */
+#define                      CIU8  0x80       /* Channel 8 In Use */
+#define                     nCIU8  0x0       
+#define                       CL9  0x7f00     /* Channel 9 Connection Label */
+#define                      CIU9  0x8000     /* Channel 9 In Use */
+#define                     nCIU9  0x0       
+#define                      CL10  0x7f0000   /* Channel 10 Connection Label */
+#define                     CIU10  0x800000   /* Channel 10 In Use */
+#define                    nCIU10  0x0       
+#define                      CL11  0x7f000000 /* Channel 11 Connection Label */
+#define                     CIU11  0x80000000 /* Channel 11 In Use */
+#define                    nCIU11  0x0       
+
+/* Bit masks for MXVR_ALLOC_3 */
+
+#define                      CL12  0x7f       /* Channel 12 Connection Label */
+#define                     CIU12  0x80       /* Channel 12 In Use */
+#define                    nCIU12  0x0       
+#define                      CL13  0x7f00     /* Channel 13 Connection Label */
+#define                     CIU13  0x8000     /* Channel 13 In Use */
+#define                    nCIU13  0x0       
+#define                      CL14  0x7f0000   /* Channel 14 Connection Label */
+#define                     CIU14  0x800000   /* Channel 14 In Use */
+#define                    nCIU14  0x0       
+#define                      CL15  0x7f000000 /* Channel 15 Connection Label */
+#define                     CIU15  0x80000000 /* Channel 15 In Use */
+#define                    nCIU15  0x0       
+
+/* Bit masks for MXVR_ALLOC_4 */
+
+#define                      CL16  0x7f       /* Channel 16 Connection Label */
+#define                     CIU16  0x80       /* Channel 16 In Use */
+#define                    nCIU16  0x0       
+#define                      CL17  0x7f00     /* Channel 17 Connection Label */
+#define                     CIU17  0x8000     /* Channel 17 In Use */
+#define                    nCIU17  0x0       
+#define                      CL18  0x7f0000   /* Channel 18 Connection Label */
+#define                     CIU18  0x800000   /* Channel 18 In Use */
+#define                    nCIU18  0x0       
+#define                      CL19  0x7f000000 /* Channel 19 Connection Label */
+#define                     CIU19  0x80000000 /* Channel 19 In Use */
+#define                    nCIU19  0x0       
+
+/* Bit masks for MXVR_ALLOC_5 */
+
+#define                      CL20  0x7f       /* Channel 20 Connection Label */
+#define                     CIU20  0x80       /* Channel 20 In Use */
+#define                    nCIU20  0x0       
+#define                      CL21  0x7f00     /* Channel 21 Connection Label */
+#define                     CIU21  0x8000     /* Channel 21 In Use */
+#define                    nCIU21  0x0       
+#define                      CL22  0x7f0000   /* Channel 22 Connection Label */
+#define                     CIU22  0x800000   /* Channel 22 In Use */
+#define                    nCIU22  0x0       
+#define                      CL23  0x7f000000 /* Channel 23 Connection Label */
+#define                     CIU23  0x80000000 /* Channel 23 In Use */
+#define                    nCIU23  0x0       
+
+/* Bit masks for MXVR_ALLOC_6 */
+
+#define                      CL24  0x7f       /* Channel 24 Connection Label */
+#define                     CIU24  0x80       /* Channel 24 In Use */
+#define                    nCIU24  0x0       
+#define                      CL25  0x7f00     /* Channel 25 Connection Label */
+#define                     CIU25  0x8000     /* Channel 25 In Use */
+#define                    nCIU25  0x0       
+#define                      CL26  0x7f0000   /* Channel 26 Connection Label */
+#define                     CIU26  0x800000   /* Channel 26 In Use */
+#define                    nCIU26  0x0       
+#define                      CL27  0x7f000000 /* Channel 27 Connection Label */
+#define                     CIU27  0x80000000 /* Channel 27 In Use */
+#define                    nCIU27  0x0       
+
+/* Bit masks for MXVR_ALLOC_7 */
+
+#define                      CL28  0x7f       /* Channel 28 Connection Label */
+#define                     CIU28  0x80       /* Channel 28 In Use */
+#define                    nCIU28  0x0       
+#define                      CL29  0x7f00     /* Channel 29 Connection Label */
+#define                     CIU29  0x8000     /* Channel 29 In Use */
+#define                    nCIU29  0x0       
+#define                      CL30  0x7f0000   /* Channel 30 Connection Label */
+#define                     CIU30  0x800000   /* Channel 30 In Use */
+#define                    nCIU30  0x0       
+#define                      CL31  0x7f000000 /* Channel 31 Connection Label */
+#define                     CIU31  0x80000000 /* Channel 31 In Use */
+#define                    nCIU31  0x0       
+
+/* Bit masks for MXVR_ALLOC_8 */
+
+#define                      CL32  0x7f       /* Channel 32 Connection Label */
+#define                     CIU32  0x80       /* Channel 32 In Use */
+#define                    nCIU32  0x0       
+#define                      CL33  0x7f00     /* Channel 33 Connection Label */
+#define                     CIU33  0x8000     /* Channel 33 In Use */
+#define                    nCIU33  0x0       
+#define                      CL34  0x7f0000   /* Channel 34 Connection Label */
+#define                     CIU34  0x800000   /* Channel 34 In Use */
+#define                    nCIU34  0x0       
+#define                      CL35  0x7f000000 /* Channel 35 Connection Label */
+#define                     CIU35  0x80000000 /* Channel 35 In Use */
+#define                    nCIU35  0x0       
+
+/* Bit masks for MXVR_ALLOC_9 */
+
+#define                      CL36  0x7f       /* Channel 36 Connection Label */
+#define                     CIU36  0x80       /* Channel 36 In Use */
+#define                    nCIU36  0x0       
+#define                      CL37  0x7f00     /* Channel 37 Connection Label */
+#define                     CIU37  0x8000     /* Channel 37 In Use */
+#define                    nCIU37  0x0       
+#define                      CL38  0x7f0000   /* Channel 38 Connection Label */
+#define                     CIU38  0x800000   /* Channel 38 In Use */
+#define                    nCIU38  0x0       
+#define                      CL39  0x7f000000 /* Channel 39 Connection Label */
+#define                     CIU39  0x80000000 /* Channel 39 In Use */
+#define                    nCIU39  0x0       
+
+/* Bit masks for MXVR_ALLOC_10 */
+
+#define                      CL40  0x7f       /* Channel 40 Connection Label */
+#define                     CIU40  0x80       /* Channel 40 In Use */
+#define                    nCIU40  0x0       
+#define                      CL41  0x7f00     /* Channel 41 Connection Label */
+#define                     CIU41  0x8000     /* Channel 41 In Use */
+#define                    nCIU41  0x0       
+#define                      CL42  0x7f0000   /* Channel 42 Connection Label */
+#define                     CIU42  0x800000   /* Channel 42 In Use */
+#define                    nCIU42  0x0       
+#define                      CL43  0x7f000000 /* Channel 43 Connection Label */
+#define                     CIU43  0x80000000 /* Channel 43 In Use */
+#define                    nCIU43  0x0       
+
+/* Bit masks for MXVR_ALLOC_11 */
+
+#define                      CL44  0x7f       /* Channel 44 Connection Label */
+#define                     CIU44  0x80       /* Channel 44 In Use */
+#define                    nCIU44  0x0       
+#define                      CL45  0x7f00     /* Channel 45 Connection Label */
+#define                     CIU45  0x8000     /* Channel 45 In Use */
+#define                    nCIU45  0x0       
+#define                      CL46  0x7f0000   /* Channel 46 Connection Label */
+#define                     CIU46  0x800000   /* Channel 46 In Use */
+#define                    nCIU46  0x0       
+#define                      CL47  0x7f000000 /* Channel 47 Connection Label */
+#define                     CIU47  0x80000000 /* Channel 47 In Use */
+#define                    nCIU47  0x0       
+
+/* Bit masks for MXVR_ALLOC_12 */
+
+#define                      CL48  0x7f       /* Channel 48 Connection Label */
+#define                     CIU48  0x80       /* Channel 48 In Use */
+#define                    nCIU48  0x0       
+#define                      CL49  0x7f00     /* Channel 49 Connection Label */
+#define                     CIU49  0x8000     /* Channel 49 In Use */
+#define                    nCIU49  0x0       
+#define                      CL50  0x7f0000   /* Channel 50 Connection Label */
+#define                     CIU50  0x800000   /* Channel 50 In Use */
+#define                    nCIU50  0x0       
+#define                      CL51  0x7f000000 /* Channel 51 Connection Label */
+#define                     CIU51  0x80000000 /* Channel 51 In Use */
+#define                    nCIU51  0x0       
+
+/* Bit masks for MXVR_ALLOC_13 */
+
+#define                      CL52  0x7f       /* Channel 52 Connection Label */
+#define                     CIU52  0x80       /* Channel 52 In Use */
+#define                    nCIU52  0x0       
+#define                      CL53  0x7f00     /* Channel 53 Connection Label */
+#define                     CIU53  0x8000     /* Channel 53 In Use */
+#define                    nCIU53  0x0       
+#define                      CL54  0x7f0000   /* Channel 54 Connection Label */
+#define                     CIU54  0x800000   /* Channel 54 In Use */
+#define                    nCIU54  0x0       
+#define                      CL55  0x7f000000 /* Channel 55 Connection Label */
+#define                     CIU55  0x80000000 /* Channel 55 In Use */
+#define                    nCIU55  0x0       
+
+/* Bit masks for MXVR_ALLOC_14 */
+
+#define                      CL56  0x7f       /* Channel 56 Connection Label */
+#define                     CIU56  0x80       /* Channel 56 In Use */
+#define                    nCIU56  0x0       
+#define                      CL57  0x7f00     /* Channel 57 Connection Label */
+#define                     CIU57  0x8000     /* Channel 57 In Use */
+#define                    nCIU57  0x0       
+#define                      CL58  0x7f0000   /* Channel 58 Connection Label */
+#define                     CIU58  0x800000   /* Channel 58 In Use */
+#define                    nCIU58  0x0       
+#define                      CL59  0x7f000000 /* Channel 59 Connection Label */
+#define                     CIU59  0x80000000 /* Channel 59 In Use */
+#define                    nCIU59  0x0       
+
+/* MXVR_SYNC_LCHAN_0 Masks */
+
+#define LCHANPC0     0x0000000Flu
+#define LCHANPC1     0x000000F0lu
+#define LCHANPC2     0x00000F00lu
+#define LCHANPC3     0x0000F000lu
+#define LCHANPC4     0x000F0000lu
+#define LCHANPC5     0x00F00000lu
+#define LCHANPC6     0x0F000000lu
+#define LCHANPC7     0xF0000000lu
+
+
+/* MXVR_SYNC_LCHAN_1 Masks */
+
+#define LCHANPC8     0x0000000Flu
+#define LCHANPC9     0x000000F0lu
+#define LCHANPC10    0x00000F00lu
+#define LCHANPC11    0x0000F000lu
+#define LCHANPC12    0x000F0000lu
+#define LCHANPC13    0x00F00000lu
+#define LCHANPC14    0x0F000000lu
+#define LCHANPC15    0xF0000000lu
+
+
+/* MXVR_SYNC_LCHAN_2 Masks */
+
+#define LCHANPC16    0x0000000Flu
+#define LCHANPC17    0x000000F0lu
+#define LCHANPC18    0x00000F00lu
+#define LCHANPC19    0x0000F000lu
+#define LCHANPC20    0x000F0000lu
+#define LCHANPC21    0x00F00000lu
+#define LCHANPC22    0x0F000000lu
+#define LCHANPC23    0xF0000000lu
+
+
+/* MXVR_SYNC_LCHAN_3 Masks */
+
+#define LCHANPC24    0x0000000Flu
+#define LCHANPC25    0x000000F0lu
+#define LCHANPC26    0x00000F00lu
+#define LCHANPC27    0x0000F000lu
+#define LCHANPC28    0x000F0000lu
+#define LCHANPC29    0x00F00000lu
+#define LCHANPC30    0x0F000000lu
+#define LCHANPC31    0xF0000000lu
+
+
+/* MXVR_SYNC_LCHAN_4 Masks */
+
+#define LCHANPC32    0x0000000Flu
+#define LCHANPC33    0x000000F0lu
+#define LCHANPC34    0x00000F00lu
+#define LCHANPC35    0x0000F000lu
+#define LCHANPC36    0x000F0000lu
+#define LCHANPC37    0x00F00000lu
+#define LCHANPC38    0x0F000000lu
+#define LCHANPC39    0xF0000000lu
+
+
+/* MXVR_SYNC_LCHAN_5 Masks */
+
+#define LCHANPC40    0x0000000Flu
+#define LCHANPC41    0x000000F0lu
+#define LCHANPC42    0x00000F00lu
+#define LCHANPC43    0x0000F000lu
+#define LCHANPC44    0x000F0000lu
+#define LCHANPC45    0x00F00000lu
+#define LCHANPC46    0x0F000000lu
+#define LCHANPC47    0xF0000000lu
+
+
+/* MXVR_SYNC_LCHAN_6 Masks */
+
+#define LCHANPC48    0x0000000Flu
+#define LCHANPC49    0x000000F0lu
+#define LCHANPC50    0x00000F00lu
+#define LCHANPC51    0x0000F000lu
+#define LCHANPC52    0x000F0000lu
+#define LCHANPC53    0x00F00000lu
+#define LCHANPC54    0x0F000000lu
+#define LCHANPC55    0xF0000000lu
+
+
+/* MXVR_SYNC_LCHAN_7 Masks */
+
+#define LCHANPC56    0x0000000Flu
+#define LCHANPC57    0x000000F0lu
+#define LCHANPC58    0x00000F00lu
+#define LCHANPC59    0x0000F000lu
+
+/* Bit masks for MXVR_DMAx_CONFIG */
+
+#define                    MDMAEN  0x1        /* DMA Channel Enable */
+#define                   nMDMAEN  0x0       
+#define                        DD  0x2        /* DMA Channel Direction */
+#define                       nDD  0x0       
+#define                 BY4SWAPEN  0x20       /* DMA Channel Four Byte Swap Enable */
+#define                nBY4SWAPEN  0x0       
+#define                     LCHAN  0x3c0      /* DMA Channel Logical Channel */
+#define                 BITSWAPEN  0x400      /* DMA Channel Bit Swap Enable */
+#define                nBITSWAPEN  0x0       
+#define                 BY2SWAPEN  0x800      /* DMA Channel Two Byte Swap Enable */
+#define                nBY2SWAPEN  0x0       
+#define                     MFLOW  0x7000     /* DMA Channel Operation Flow */
+#define                   FIXEDPM  0x80000    /* DMA Channel Fixed Pattern Matching Select */
+#define                  nFIXEDPM  0x0       
+#define                  STARTPAT  0x300000   /* DMA Channel Start Pattern Select */
+#define                   STOPPAT  0xc00000   /* DMA Channel Stop Pattern Select */
+#define                  COUNTPOS  0x1c000000 /* DMA Channel Count Position */
+
+/* Bit masks for MXVR_AP_CTL */
+
+#define                   STARTAP  0x1        /* Start Asynchronous Packet Transmission */
+#define                  nSTARTAP  0x0       
+#define                  CANCELAP  0x2        /* Cancel Asynchronous Packet Transmission */
+#define                 nCANCELAP  0x0       
+#define                   RESETAP  0x4        /* Reset Asynchronous Packet Arbitration */
+#define                  nRESETAP  0x0       
+#define                    APRBE0  0x4000     /* Asynchronous Packet Receive Buffer Entry 0 */
+#define                   nAPRBE0  0x0       
+#define                    APRBE1  0x8000     /* Asynchronous Packet Receive Buffer Entry 1 */
+#define                   nAPRBE1  0x0       
+
+/* Bit masks for MXVR_APRB_START_ADDR */
+
+#define      MXVR_APRB_START_ADDR  0x1fffffe  /* Asynchronous Packet Receive Buffer Start Address */
+
+/* Bit masks for MXVR_APRB_CURR_ADDR */
+
+#define       MXVR_APRB_CURR_ADDR  0xffffffff /* Asynchronous Packet Receive Buffer Current Address */
+
+/* Bit masks for MXVR_APTB_START_ADDR */
+
+#define       MXVR_APTB_START_ADDR  0x1fffffe  /* Asynchronous Packet Transmit Buffer Start Address */
+
+/* Bit masks for MXVR_APTB_CURR_ADDR */
+
+#define        MXVR_APTB_CURR_ADDR  0xffffffff /* Asynchronous Packet Transmit Buffer Current Address */
+
+/* Bit masks for MXVR_CM_CTL */
+
+#define                   STARTCM  0x1        /* Start Control Message Transmission */
+#define                  nSTARTCM  0x0       
+#define                  CANCELCM  0x2        /* Cancel Control Message Transmission */
+#define                 nCANCELCM  0x0       
+#define                    CMRBE0  0x10000    /* Control Message Receive Buffer Entry 0 */
+#define                   nCMRBE0  0x0       
+#define                    CMRBE1  0x20000    /* Control Message Receive Buffer Entry 1 */
+#define                   nCMRBE1  0x0       
+#define                    CMRBE2  0x40000    /* Control Message Receive Buffer Entry 2 */
+#define                   nCMRBE2  0x0       
+#define                    CMRBE3  0x80000    /* Control Message Receive Buffer Entry 3 */
+#define                   nCMRBE3  0x0       
+#define                    CMRBE4  0x100000   /* Control Message Receive Buffer Entry 4 */
+#define                   nCMRBE4  0x0       
+#define                    CMRBE5  0x200000   /* Control Message Receive Buffer Entry 5 */
+#define                   nCMRBE5  0x0       
+#define                    CMRBE6  0x400000   /* Control Message Receive Buffer Entry 6 */
+#define                   nCMRBE6  0x0       
+#define                    CMRBE7  0x800000   /* Control Message Receive Buffer Entry 7 */
+#define                   nCMRBE7  0x0       
+#define                    CMRBE8  0x1000000  /* Control Message Receive Buffer Entry 8 */
+#define                   nCMRBE8  0x0       
+#define                    CMRBE9  0x2000000  /* Control Message Receive Buffer Entry 9 */
+#define                   nCMRBE9  0x0       
+#define                   CMRBE10  0x4000000  /* Control Message Receive Buffer Entry 10 */
+#define                  nCMRBE10  0x0       
+#define                   CMRBE11  0x8000000  /* Control Message Receive Buffer Entry 11 */
+#define                  nCMRBE11  0x0       
+#define                   CMRBE12  0x10000000 /* Control Message Receive Buffer Entry 12 */
+#define                  nCMRBE12  0x0       
+#define                   CMRBE13  0x20000000 /* Control Message Receive Buffer Entry 13 */
+#define                  nCMRBE13  0x0       
+#define                   CMRBE14  0x40000000 /* Control Message Receive Buffer Entry 14 */
+#define                  nCMRBE14  0x0       
+#define                   CMRBE15  0x80000000 /* Control Message Receive Buffer Entry 15 */
+#define                  nCMRBE15  0x0       
+
+/* Bit masks for MXVR_CMRB_START_ADDR */
+
+#define      MXVR_CMRB_START_ADDR  0x1fffffe  /* Control Message Receive Buffer Start Address */
+
+/* Bit masks for MXVR_CMRB_CURR_ADDR */
+
+#define       MXVR_CMRB_CURR_ADDR  0xffffffff /* Control Message Receive Buffer Current Address */
+
+/* Bit masks for MXVR_CMTB_START_ADDR */
+
+#define      MXVR_CMTB_START_ADDR  0x1fffffe  /* Control Message Transmit Buffer Start Address */
+
+/* Bit masks for MXVR_CMTB_CURR_ADDR */
+
+#define       MXVR_CMTB_CURR_ADDR  0xffffffff /* Control Message Transmit Buffer Current Address */
+
+/* Bit masks for MXVR_RRDB_START_ADDR */
+
+#define      MXVR_RRDB_START_ADDR  0x1fffffe  /* Remote Read Buffer Start Address */
+
+/* Bit masks for MXVR_RRDB_CURR_ADDR */
+
+#define       MXVR_RRDB_CURR_ADDR  0xffffffff /* Remote Read Buffer Current Address */
+
+/* Bit masks for MXVR_PAT_DATAx */
+
+#define              MATCH_DATA_0  0xff       /* Pattern Match Data Byte 0 */
+#define              MATCH_DATA_1  0xff00     /* Pattern Match Data Byte 1 */
+#define              MATCH_DATA_2  0xff0000   /* Pattern Match Data Byte 2 */
+#define              MATCH_DATA_3  0xff000000 /* Pattern Match Data Byte 3 */
+
+/* Bit masks for MXVR_PAT_EN_0 */
+
+#define              MATCH_EN_0_0  0x1        /* Pattern Match Enable Byte 0 Bit 0 */
+#define             nMATCH_EN_0_0  0x0       
+#define              MATCH_EN_0_1  0x2        /* Pattern Match Enable Byte 0 Bit 1 */
+#define             nMATCH_EN_0_1  0x0       
+#define              MATCH_EN_0_2  0x4        /* Pattern Match Enable Byte 0 Bit 2 */
+#define             nMATCH_EN_0_2  0x0       
+#define              MATCH_EN_0_3  0x8        /* Pattern Match Enable Byte 0 Bit 3 */
+#define             nMATCH_EN_0_3  0x0       
+#define              MATCH_EN_0_4  0x10       /* Pattern Match Enable Byte 0 Bit 4 */
+#define             nMATCH_EN_0_4  0x0       
+#define              MATCH_EN_0_5  0x20       /* Pattern Match Enable Byte 0 Bit 5 */
+#define             nMATCH_EN_0_5  0x0       
+#define              MATCH_EN_0_6  0x40       /* Pattern Match Enable Byte 0 Bit 6 */
+#define             nMATCH_EN_0_6  0x0       
+#define              MATCH_EN_0_7  0x80       /* Pattern Match Enable Byte 0 Bit 7 */
+#define             nMATCH_EN_0_7  0x0       
+#define              MATCH_EN_1_0  0x100      /* Pattern Match Enable Byte 1 Bit 0 */
+#define             nMATCH_EN_1_0  0x0       
+#define              MATCH_EN_1_1  0x200      /* Pattern Match Enable Byte 1 Bit 1 */
+#define             nMATCH_EN_1_1  0x0       
+#define              MATCH_EN_1_2  0x400      /* Pattern Match Enable Byte 1 Bit 2 */
+#define             nMATCH_EN_1_2  0x0       
+#define              MATCH_EN_1_3  0x800      /* Pattern Match Enable Byte 1 Bit 3 */
+#define             nMATCH_EN_1_3  0x0       
+#define              MATCH_EN_1_4  0x1000     /* Pattern Match Enable Byte 1 Bit 4 */
+#define             nMATCH_EN_1_4  0x0       
+#define              MATCH_EN_1_5  0x2000     /* Pattern Match Enable Byte 1 Bit 5 */
+#define             nMATCH_EN_1_5  0x0       
+#define              MATCH_EN_1_6  0x4000     /* Pattern Match Enable Byte 1 Bit 6 */
+#define             nMATCH_EN_1_6  0x0       
+#define              MATCH_EN_1_7  0x8000     /* Pattern Match Enable Byte 1 Bit 7 */
+#define             nMATCH_EN_1_7  0x0       
+#define              MATCH_EN_2_0  0x10000    /* Pattern Match Enable Byte 2 Bit 0 */
+#define             nMATCH_EN_2_0  0x0       
+#define              MATCH_EN_2_1  0x20000    /* Pattern Match Enable Byte 2 Bit 1 */
+#define             nMATCH_EN_2_1  0x0       
+#define              MATCH_EN_2_2  0x40000    /* Pattern Match Enable Byte 2 Bit 2 */
+#define             nMATCH_EN_2_2  0x0       
+#define              MATCH_EN_2_3  0x80000    /* Pattern Match Enable Byte 2 Bit 3 */
+#define             nMATCH_EN_2_3  0x0       
+#define              MATCH_EN_2_4  0x100000   /* Pattern Match Enable Byte 2 Bit 4 */
+#define             nMATCH_EN_2_4  0x0       
+#define              MATCH_EN_2_5  0x200000   /* Pattern Match Enable Byte 2 Bit 5 */
+#define             nMATCH_EN_2_5  0x0       
+#define              MATCH_EN_2_6  0x400000   /* Pattern Match Enable Byte 2 Bit 6 */
+#define             nMATCH_EN_2_6  0x0       
+#define              MATCH_EN_2_7  0x800000   /* Pattern Match Enable Byte 2 Bit 7 */
+#define             nMATCH_EN_2_7  0x0       
+#define              MATCH_EN_3_0  0x1000000  /* Pattern Match Enable Byte 3 Bit 0 */
+#define             nMATCH_EN_3_0  0x0       
+#define              MATCH_EN_3_1  0x2000000  /* Pattern Match Enable Byte 3 Bit 1 */
+#define             nMATCH_EN_3_1  0x0       
+#define              MATCH_EN_3_2  0x4000000  /* Pattern Match Enable Byte 3 Bit 2 */
+#define             nMATCH_EN_3_2  0x0       
+#define              MATCH_EN_3_3  0x8000000  /* Pattern Match Enable Byte 3 Bit 3 */
+#define             nMATCH_EN_3_3  0x0       
+#define              MATCH_EN_3_4  0x10000000 /* Pattern Match Enable Byte 3 Bit 4 */
+#define             nMATCH_EN_3_4  0x0       
+#define              MATCH_EN_3_5  0x20000000 /* Pattern Match Enable Byte 3 Bit 5 */
+#define             nMATCH_EN_3_5  0x0       
+#define              MATCH_EN_3_6  0x40000000 /* Pattern Match Enable Byte 3 Bit 6 */
+#define             nMATCH_EN_3_6  0x0       
+#define              MATCH_EN_3_7  0x80000000 /* Pattern Match Enable Byte 3 Bit 7 */
+#define             nMATCH_EN_3_7  0x0       
+
+/* Bit masks for MXVR_PAT_EN_1 */
+
+#define              MATCH_EN_0_0  0x1        /* Pattern Match Enable Byte 0 Bit 0 */
+#define             nMATCH_EN_0_0  0x0       
+#define              MATCH_EN_0_1  0x2        /* Pattern Match Enable Byte 0 Bit 1 */
+#define             nMATCH_EN_0_1  0x0       
+#define              MATCH_EN_0_2  0x4        /* Pattern Match Enable Byte 0 Bit 2 */
+#define             nMATCH_EN_0_2  0x0       
+#define              MATCH_EN_0_3  0x8        /* Pattern Match Enable Byte 0 Bit 3 */
+#define             nMATCH_EN_0_3  0x0       
+#define              MATCH_EN_0_4  0x10       /* Pattern Match Enable Byte 0 Bit 4 */
+#define             nMATCH_EN_0_4  0x0       
+#define              MATCH_EN_0_5  0x20       /* Pattern Match Enable Byte 0 Bit 5 */
+#define             nMATCH_EN_0_5  0x0       
+#define              MATCH_EN_0_6  0x40       /* Pattern Match Enable Byte 0 Bit 6 */
+#define             nMATCH_EN_0_6  0x0       
+#define              MATCH_EN_0_7  0x80       /* Pattern Match Enable Byte 0 Bit 7 */
+#define             nMATCH_EN_0_7  0x0       
+#define              MATCH_EN_1_0  0x100      /* Pattern Match Enable Byte 1 Bit 0 */
+#define             nMATCH_EN_1_0  0x0       
+#define              MATCH_EN_1_1  0x200      /* Pattern Match Enable Byte 1 Bit 1 */
+#define             nMATCH_EN_1_1  0x0       
+#define              MATCH_EN_1_2  0x400      /* Pattern Match Enable Byte 1 Bit 2 */
+#define             nMATCH_EN_1_2  0x0       
+#define              MATCH_EN_1_3  0x800      /* Pattern Match Enable Byte 1 Bit 3 */
+#define             nMATCH_EN_1_3  0x0       
+#define              MATCH_EN_1_4  0x1000     /* Pattern Match Enable Byte 1 Bit 4 */
+#define             nMATCH_EN_1_4  0x0       
+#define              MATCH_EN_1_5  0x2000     /* Pattern Match Enable Byte 1 Bit 5 */
+#define             nMATCH_EN_1_5  0x0       
+#define              MATCH_EN_1_6  0x4000     /* Pattern Match Enable Byte 1 Bit 6 */
+#define             nMATCH_EN_1_6  0x0       
+#define              MATCH_EN_1_7  0x8000     /* Pattern Match Enable Byte 1 Bit 7 */
+#define             nMATCH_EN_1_7  0x0       
+#define              MATCH_EN_2_0  0x10000    /* Pattern Match Enable Byte 2 Bit 0 */
+#define             nMATCH_EN_2_0  0x0       
+#define              MATCH_EN_2_1  0x20000    /* Pattern Match Enable Byte 2 Bit 1 */
+#define             nMATCH_EN_2_1  0x0       
+#define              MATCH_EN_2_2  0x40000    /* Pattern Match Enable Byte 2 Bit 2 */
+#define             nMATCH_EN_2_2  0x0       
+#define              MATCH_EN_2_3  0x80000    /* Pattern Match Enable Byte 2 Bit 3 */
+#define             nMATCH_EN_2_3  0x0       
+#define              MATCH_EN_2_4  0x100000   /* Pattern Match Enable Byte 2 Bit 4 */
+#define             nMATCH_EN_2_4  0x0       
+#define              MATCH_EN_2_5  0x200000   /* Pattern Match Enable Byte 2 Bit 5 */
+#define             nMATCH_EN_2_5  0x0       
+#define              MATCH_EN_2_6  0x400000   /* Pattern Match Enable Byte 2 Bit 6 */
+#define             nMATCH_EN_2_6  0x0       
+#define              MATCH_EN_2_7  0x800000   /* Pattern Match Enable Byte 2 Bit 7 */
+#define             nMATCH_EN_2_7  0x0       
+#define              MATCH_EN_3_0  0x1000000  /* Pattern Match Enable Byte 3 Bit 0 */
+#define             nMATCH_EN_3_0  0x0       
+#define              MATCH_EN_3_1  0x2000000  /* Pattern Match Enable Byte 3 Bit 1 */
+#define             nMATCH_EN_3_1  0x0       
+#define              MATCH_EN_3_2  0x4000000  /* Pattern Match Enable Byte 3 Bit 2 */
+#define             nMATCH_EN_3_2  0x0       
+#define              MATCH_EN_3_3  0x8000000  /* Pattern Match Enable Byte 3 Bit 3 */
+#define             nMATCH_EN_3_3  0x0       
+#define              MATCH_EN_3_4  0x10000000 /* Pattern Match Enable Byte 3 Bit 4 */
+#define             nMATCH_EN_3_4  0x0       
+#define              MATCH_EN_3_5  0x20000000 /* Pattern Match Enable Byte 3 Bit 5 */
+#define             nMATCH_EN_3_5  0x0       
+#define              MATCH_EN_3_6  0x40000000 /* Pattern Match Enable Byte 3 Bit 6 */
+#define             nMATCH_EN_3_6  0x0       
+#define              MATCH_EN_3_7  0x80000000 /* Pattern Match Enable Byte 3 Bit 7 */
+#define             nMATCH_EN_3_7  0x0       
+
+/* Bit masks for MXVR_FRAME_CNT_0 */
+
+#define                      FCNT  0xffff     /* Frame Count */
+
+/* Bit masks for MXVR_FRAME_CNT_1 */
+
+#define                      FCNT  0xffff     /* Frame Count */
+
+/* Bit masks for MXVR_ROUTING_0 */
+
+#define                    TX_CH0  0x3f       /* Transmit Channel 0 */
+#define                  MUTE_CH0  0x80       /* Mute Channel 0 */
+#define                 nMUTE_CH0  0x0       
+#define                    TX_CH1  0x3f00     /* Transmit Channel 0 */
+#define                  MUTE_CH1  0x8000     /* Mute Channel 0 */
+#define                 nMUTE_CH1  0x0       
+#define                    TX_CH2  0x3f0000   /* Transmit Channel 0 */
+#define                  MUTE_CH2  0x800000   /* Mute Channel 0 */
+#define                 nMUTE_CH2  0x0       
+#define                    TX_CH3  0x3f000000 /* Transmit Channel 0 */
+#define                  MUTE_CH3  0x80000000 /* Mute Channel 0 */
+#define                 nMUTE_CH3  0x0       
+
+/* Bit masks for MXVR_ROUTING_1 */
+
+#define                    TX_CH4  0x3f       /* Transmit Channel 4 */
+#define                  MUTE_CH4  0x80       /* Mute Channel 4 */
+#define                 nMUTE_CH4  0x0       
+#define                    TX_CH5  0x3f00     /* Transmit Channel 5 */
+#define                  MUTE_CH5  0x8000     /* Mute Channel 5 */
+#define                 nMUTE_CH5  0x0       
+#define                    TX_CH6  0x3f0000   /* Transmit Channel 6 */
+#define                  MUTE_CH6  0x800000   /* Mute Channel 6 */
+#define                 nMUTE_CH6  0x0       
+#define                    TX_CH7  0x3f000000 /* Transmit Channel 7 */
+#define                  MUTE_CH7  0x80000000 /* Mute Channel 7 */
+#define                 nMUTE_CH7  0x0       
+
+/* Bit masks for MXVR_ROUTING_2 */
+
+#define                    TX_CH8  0x3f       /* Transmit Channel 8 */
+#define                  MUTE_CH8  0x80       /* Mute Channel 8 */
+#define                 nMUTE_CH8  0x0       
+#define                    TX_CH9  0x3f00     /* Transmit Channel 9 */
+#define                  MUTE_CH9  0x8000     /* Mute Channel 9 */
+#define                 nMUTE_CH9  0x0       
+#define                   TX_CH10  0x3f0000   /* Transmit Channel 10 */
+#define                 MUTE_CH10  0x800000   /* Mute Channel 10 */
+#define                nMUTE_CH10  0x0       
+#define                   TX_CH11  0x3f000000 /* Transmit Channel 11 */
+#define                 MUTE_CH11  0x80000000 /* Mute Channel 11 */
+#define                nMUTE_CH11  0x0       
+
+/* Bit masks for MXVR_ROUTING_3 */
+
+#define                   TX_CH12  0x3f       /* Transmit Channel 12 */
+#define                 MUTE_CH12  0x80       /* Mute Channel 12 */
+#define                nMUTE_CH12  0x0       
+#define                   TX_CH13  0x3f00     /* Transmit Channel 13 */
+#define                 MUTE_CH13  0x8000     /* Mute Channel 13 */
+#define                nMUTE_CH13  0x0       
+#define                   TX_CH14  0x3f0000   /* Transmit Channel 14 */
+#define                 MUTE_CH14  0x800000   /* Mute Channel 14 */
+#define                nMUTE_CH14  0x0       
+#define                   TX_CH15  0x3f000000 /* Transmit Channel 15 */
+#define                 MUTE_CH15  0x80000000 /* Mute Channel 15 */
+#define                nMUTE_CH15  0x0       
+
+/* Bit masks for MXVR_ROUTING_4 */
+
+#define                   TX_CH16  0x3f       /* Transmit Channel 16 */
+#define                 MUTE_CH16  0x80       /* Mute Channel 16 */
+#define                nMUTE_CH16  0x0       
+#define                   TX_CH17  0x3f00     /* Transmit Channel 17 */
+#define                 MUTE_CH17  0x8000     /* Mute Channel 17 */
+#define                nMUTE_CH17  0x0       
+#define                   TX_CH18  0x3f0000   /* Transmit Channel 18 */
+#define                 MUTE_CH18  0x800000   /* Mute Channel 18 */
+#define                nMUTE_CH18  0x0       
+#define                   TX_CH19  0x3f000000 /* Transmit Channel 19 */
+#define                 MUTE_CH19  0x80000000 /* Mute Channel 19 */
+#define                nMUTE_CH19  0x0       
+
+/* Bit masks for MXVR_ROUTING_5 */
+
+#define                   TX_CH20  0x3f       /* Transmit Channel 20 */
+#define                 MUTE_CH20  0x80       /* Mute Channel 20 */
+#define                nMUTE_CH20  0x0       
+#define                   TX_CH21  0x3f00     /* Transmit Channel 21 */
+#define                 MUTE_CH21  0x8000     /* Mute Channel 21 */
+#define                nMUTE_CH21  0x0       
+#define                   TX_CH22  0x3f0000   /* Transmit Channel 22 */
+#define                 MUTE_CH22  0x800000   /* Mute Channel 22 */
+#define                nMUTE_CH22  0x0       
+#define                   TX_CH23  0x3f000000 /* Transmit Channel 23 */
+#define                 MUTE_CH23  0x80000000 /* Mute Channel 23 */
+#define                nMUTE_CH23  0x0       
+
+/* Bit masks for MXVR_ROUTING_6 */
+
+#define                   TX_CH24  0x3f       /* Transmit Channel 24 */
+#define                 MUTE_CH24  0x80       /* Mute Channel 24 */
+#define                nMUTE_CH24  0x0       
+#define                   TX_CH25  0x3f00     /* Transmit Channel 25 */
+#define                 MUTE_CH25  0x8000     /* Mute Channel 25 */
+#define                nMUTE_CH25  0x0       
+#define                   TX_CH26  0x3f0000   /* Transmit Channel 26 */
+#define                 MUTE_CH26  0x800000   /* Mute Channel 26 */
+#define                nMUTE_CH26  0x0       
+#define                   TX_CH27  0x3f000000 /* Transmit Channel 27 */
+#define                 MUTE_CH27  0x80000000 /* Mute Channel 27 */
+#define                nMUTE_CH27  0x0       
+
+/* Bit masks for MXVR_ROUTING_7 */
+
+#define                   TX_CH28  0x3f       /* Transmit Channel 28 */
+#define                 MUTE_CH28  0x80       /* Mute Channel 28 */
+#define                nMUTE_CH28  0x0       
+#define                   TX_CH29  0x3f00     /* Transmit Channel 29 */
+#define                 MUTE_CH29  0x8000     /* Mute Channel 29 */
+#define                nMUTE_CH29  0x0       
+#define                   TX_CH30  0x3f0000   /* Transmit Channel 30 */
+#define                 MUTE_CH30  0x800000   /* Mute Channel 30 */
+#define                nMUTE_CH30  0x0       
+#define                   TX_CH31  0x3f000000 /* Transmit Channel 31 */
+#define                 MUTE_CH31  0x80000000 /* Mute Channel 31 */
+#define                nMUTE_CH31  0x0       
+
+/* Bit masks for MXVR_ROUTING_8 */
+
+#define                   TX_CH32  0x3f       /* Transmit Channel 32 */
+#define                 MUTE_CH32  0x80       /* Mute Channel 32 */
+#define                nMUTE_CH32  0x0       
+#define                   TX_CH33  0x3f00     /* Transmit Channel 33 */
+#define                 MUTE_CH33  0x8000     /* Mute Channel 33 */
+#define                nMUTE_CH33  0x0       
+#define                   TX_CH34  0x3f0000   /* Transmit Channel 34 */
+#define                 MUTE_CH34  0x800000   /* Mute Channel 34 */
+#define                nMUTE_CH34  0x0       
+#define                   TX_CH35  0x3f000000 /* Transmit Channel 35 */
+#define                 MUTE_CH35  0x80000000 /* Mute Channel 35 */
+#define                nMUTE_CH35  0x0       
+
+/* Bit masks for MXVR_ROUTING_9 */
+
+#define                   TX_CH36  0x3f       /* Transmit Channel 36 */
+#define                 MUTE_CH36  0x80       /* Mute Channel 36 */
+#define                nMUTE_CH36  0x0       
+#define                   TX_CH37  0x3f00     /* Transmit Channel 37 */
+#define                 MUTE_CH37  0x8000     /* Mute Channel 37 */
+#define                nMUTE_CH37  0x0       
+#define                   TX_CH38  0x3f0000   /* Transmit Channel 38 */
+#define                 MUTE_CH38  0x800000   /* Mute Channel 38 */
+#define                nMUTE_CH38  0x0       
+#define                   TX_CH39  0x3f000000 /* Transmit Channel 39 */
+#define                 MUTE_CH39  0x80000000 /* Mute Channel 39 */
+#define                nMUTE_CH39  0x0       
+
+/* Bit masks for MXVR_ROUTING_10 */
+
+#define                   TX_CH40  0x3f       /* Transmit Channel 40 */
+#define                 MUTE_CH40  0x80       /* Mute Channel 40 */
+#define                nMUTE_CH40  0x0       
+#define                   TX_CH41  0x3f00     /* Transmit Channel 41 */
+#define                 MUTE_CH41  0x8000     /* Mute Channel 41 */
+#define                nMUTE_CH41  0x0       
+#define                   TX_CH42  0x3f0000   /* Transmit Channel 42 */
+#define                 MUTE_CH42  0x800000   /* Mute Channel 42 */
+#define                nMUTE_CH42  0x0       
+#define                   TX_CH43  0x3f000000 /* Transmit Channel 43 */
+#define                 MUTE_CH43  0x80000000 /* Mute Channel 43 */
+#define                nMUTE_CH43  0x0       
+
+/* Bit masks for MXVR_ROUTING_11 */
+
+#define                   TX_CH44  0x3f       /* Transmit Channel 44 */
+#define                 MUTE_CH44  0x80       /* Mute Channel 44 */
+#define                nMUTE_CH44  0x0       
+#define                   TX_CH45  0x3f00     /* Transmit Channel 45 */
+#define                 MUTE_CH45  0x8000     /* Mute Channel 45 */
+#define                nMUTE_CH45  0x0       
+#define                   TX_CH46  0x3f0000   /* Transmit Channel 46 */
+#define                 MUTE_CH46  0x800000   /* Mute Channel 46 */
+#define                nMUTE_CH46  0x0       
+#define                   TX_CH47  0x3f000000 /* Transmit Channel 47 */
+#define                 MUTE_CH47  0x80000000 /* Mute Channel 47 */
+#define                nMUTE_CH47  0x0       
+
+/* Bit masks for MXVR_ROUTING_12 */
+
+#define                   TX_CH48  0x3f       /* Transmit Channel 48 */
+#define                 MUTE_CH48  0x80       /* Mute Channel 48 */
+#define                nMUTE_CH48  0x0       
+#define                   TX_CH49  0x3f00     /* Transmit Channel 49 */
+#define                 MUTE_CH49  0x8000     /* Mute Channel 49 */
+#define                nMUTE_CH49  0x0       
+#define                   TX_CH50  0x3f0000   /* Transmit Channel 50 */
+#define                 MUTE_CH50  0x800000   /* Mute Channel 50 */
+#define                nMUTE_CH50  0x0       
+#define                   TX_CH51  0x3f000000 /* Transmit Channel 51 */
+#define                 MUTE_CH51  0x80000000 /* Mute Channel 51 */
+#define                nMUTE_CH51  0x0       
+
+/* Bit masks for MXVR_ROUTING_13 */
+
+#define                   TX_CH52  0x3f       /* Transmit Channel 52 */
+#define                 MUTE_CH52  0x80       /* Mute Channel 52 */
+#define                nMUTE_CH52  0x0       
+#define                   TX_CH53  0x3f00     /* Transmit Channel 53 */
+#define                 MUTE_CH53  0x8000     /* Mute Channel 53 */
+#define                nMUTE_CH53  0x0       
+#define                   TX_CH54  0x3f0000   /* Transmit Channel 54 */
+#define                 MUTE_CH54  0x800000   /* Mute Channel 54 */
+#define                nMUTE_CH54  0x0       
+#define                   TX_CH55  0x3f000000 /* Transmit Channel 55 */
+#define                 MUTE_CH55  0x80000000 /* Mute Channel 55 */
+#define                nMUTE_CH55  0x0       
+
+/* Bit masks for MXVR_ROUTING_14 */
+
+#define                   TX_CH56  0x3f       /* Transmit Channel 56 */
+#define                 MUTE_CH56  0x80       /* Mute Channel 56 */
+#define                nMUTE_CH56  0x0       
+#define                   TX_CH57  0x3f00     /* Transmit Channel 57 */
+#define                 MUTE_CH57  0x8000     /* Mute Channel 57 */
+#define                nMUTE_CH57  0x0       
+#define                   TX_CH58  0x3f0000   /* Transmit Channel 58 */
+#define                 MUTE_CH58  0x800000   /* Mute Channel 58 */
+#define                nMUTE_CH58  0x0       
+#define                   TX_CH59  0x3f000000 /* Transmit Channel 59 */
+#define                 MUTE_CH59  0x80000000 /* Mute Channel 59 */
+#define                nMUTE_CH59  0x0       
+
+/* Bit masks for MXVR_BLOCK_CNT */
+
+#define                      BCNT  0xffff     /* Block Count */
+
+/* Bit masks for MXVR_CLK_CTL */
+
+#define                  MXTALCEN  0x1        /* MXVR Crystal Oscillator Clock Enable */
+#define                 nMXTALCEN  0x0       
+#define                  MXTALFEN  0x2        /* MXVR Crystal Oscillator Feedback Enable */
+#define                 nMXTALFEN  0x0       
+#define                  MXTALMUL  0x30       /* MXVR Crystal Multiplier */
+#define                  CLKX3SEL  0x80       /* Clock Generation Source Select */
+#define                 nCLKX3SEL  0x0       
+#define                   MMCLKEN  0x100      /* Master Clock Enable */
+#define                  nMMCLKEN  0x0       
+#define                  MMCLKMUL  0x1e00     /* Master Clock Multiplication Factor */
+#define                   PLLSMPS  0xe000     /* MXVR PLL State Machine Prescaler */
+#define                   MBCLKEN  0x10000    /* Bit Clock Enable */
+#define                  nMBCLKEN  0x0       
+#define                  MBCLKDIV  0x1e0000   /* Bit Clock Divide Factor */
+#define                     INVRX  0x800000   /* Invert Receive Data */
+#define                    nINVRX  0x0       
+#define                     MFSEN  0x1000000  /* Frame Sync Enable */
+#define                    nMFSEN  0x0       
+#define                    MFSDIV  0x1e000000 /* Frame Sync Divide Factor */
+#define                    MFSSEL  0x60000000 /* Frame Sync Select */
+#define                   MFSSYNC  0x80000000 /* Frame Sync Synchronization Select */
+#define                  nMFSSYNC  0x0       
+
+/* Bit masks for MXVR_CDRPLL_CTL */
+
+#define                   CDRSMEN  0x1        /* MXVR CDRPLL State Machine Enable */
+#define                  nCDRSMEN  0x0       
+#define                   CDRRSTB  0x2        /* MXVR CDRPLL Reset */
+#define                  nCDRRSTB  0x0       
+#define                   CDRSVCO  0x4        /* MXVR CDRPLL Start VCO */
+#define                  nCDRSVCO  0x0       
+#define                   CDRMODE  0x8        /* MXVR CDRPLL CDR Mode Select */
+#define                  nCDRMODE  0x0       
+#define                   CDRSCNT  0x3f0      /* MXVR CDRPLL Start Counter */
+#define                   CDRLCNT  0xfc00     /* MXVR CDRPLL Lock Counter */
+#define                 CDRSHPSEL  0x3f0000   /* MXVR CDRPLL Shaper Select */
+#define                  CDRSHPEN  0x800000   /* MXVR CDRPLL Shaper Enable */
+#define                 nCDRSHPEN  0x0       
+#define                  CDRCPSEL  0xff000000 /* MXVR CDRPLL Charge Pump Current Select */
+
+/* Bit masks for MXVR_FMPLL_CTL */
+
+#define                    FMSMEN  0x1        /* MXVR FMPLL State Machine Enable */
+#define                   nFMSMEN  0x0       
+#define                    FMRSTB  0x2        /* MXVR FMPLL Reset */
+#define                   nFMRSTB  0x0       
+#define                    FMSVCO  0x4        /* MXVR FMPLL Start VCO */
+#define                   nFMSVCO  0x0       
+#define                    FMSCNT  0x3f0      /* MXVR FMPLL Start Counter */
+#define                    FMLCNT  0xfc00     /* MXVR FMPLL Lock Counter */
+#define                   FMCPSEL  0xff000000 /* MXVR FMPLL Charge Pump Current Select */
+
+/* Bit masks for MXVR_PIN_CTL */
+
+#define                  MTXONBOD  0x1        /* MTXONB Open Drain Select */
+#define                 nMTXONBOD  0x0       
+#define                   MTXONBG  0x2        /* MTXONB Gates MTX Select */
+#define                  nMTXONBG  0x0       
+#define                     MFSOE  0x10       /* MFS Output Enable */
+#define                    nMFSOE  0x0       
+#define                  MFSGPSEL  0x20       /* MFS General Purpose Output Select */
+#define                 nMFSGPSEL  0x0       
+#define                  MFSGPDAT  0x40       /* MFS General Purpose Output Data */
+#define                 nMFSGPDAT  0x0       
+
+/* Bit masks for MXVR_SCLK_CNT */
+
+#define                      SCNT  0xffff     /* System Clock Count */
+
+/* Bit masks for KPAD_CTL */
+
+#define                   KPAD_EN  0x1        /* Keypad Enable */
+#define                  nKPAD_EN  0x0       
+#define              KPAD_IRQMODE  0x6        /* Key Press Interrupt Enable */
+#define                KPAD_ROWEN  0x1c00     /* Row Enable Width */
+#define                KPAD_COLEN  0xe000     /* Column Enable Width */
+
+/* Bit masks for KPAD_PRESCALE */
+
+#define         KPAD_PRESCALE_VAL  0x3f       /* Key Prescale Value */
+
+/* Bit masks for KPAD_MSEL */
+
+#define                DBON_SCALE  0xff       /* Debounce Scale Value */
+#define              COLDRV_SCALE  0xff00     /* Column Driver Scale Value */
+
+/* Bit masks for KPAD_ROWCOL */
+
+#define                  KPAD_ROW  0xff       /* Rows Pressed */
+#define                  KPAD_COL  0xff00     /* Columns Pressed */
+
+/* Bit masks for KPAD_STAT */
+
+#define                  KPAD_IRQ  0x1        /* Keypad Interrupt Status */
+#define                 nKPAD_IRQ  0x0       
+#define              KPAD_MROWCOL  0x6        /* Multiple Row/Column Keypress Status */
+#define              KPAD_PRESSED  0x8        /* Key press current status */
+#define             nKPAD_PRESSED  0x0       
+
+/* Bit masks for KPAD_SOFTEVAL */
+
+#define           KPAD_SOFTEVAL_E  0x2        /* Software Programmable Force Evaluate */
+#define          nKPAD_SOFTEVAL_E  0x0       
+
+/* Bit masks for SDH_COMMAND */
+
+#define                   CMD_IDX  0x3f       /* Command Index */
+#define                   CMD_RSP  0x40       /* Response */
+#define                  nCMD_RSP  0x0       
+#define                 CMD_L_RSP  0x80       /* Long Response */
+#define                nCMD_L_RSP  0x0       
+#define                 CMD_INT_E  0x100      /* Command Interrupt */
+#define                nCMD_INT_E  0x0       
+#define                CMD_PEND_E  0x200      /* Command Pending */
+#define               nCMD_PEND_E  0x0       
+#define                     CMD_E  0x400      /* Command Enable */
+#define                    nCMD_E  0x0       
+
+/* Bit masks for SDH_PWR_CTL */
+
+#define                    PWR_ON  0x3        /* Power On */
+#if 0
+#define                       TBD  0x3c       /* TBD */
+#endif
+#define                 SD_CMD_OD  0x40       /* Open Drain Output */
+#define                nSD_CMD_OD  0x0       
+#define                   ROD_CTL  0x80       /* Rod Control */
+#define                  nROD_CTL  0x0       
+
+/* Bit masks for SDH_CLK_CTL */
+
+#define                    CLKDIV  0xff       /* MC_CLK Divisor */
+#define                     CLK_E  0x100      /* MC_CLK Bus Clock Enable */
+#define                    nCLK_E  0x0       
+#define                  PWR_SV_E  0x200      /* Power Save Enable */
+#define                 nPWR_SV_E  0x0       
+#define             CLKDIV_BYPASS  0x400      /* Bypass Divisor */
+#define            nCLKDIV_BYPASS  0x0       
+#define                  WIDE_BUS  0x800      /* Wide Bus Mode Enable */
+#define                 nWIDE_BUS  0x0       
+
+/* Bit masks for SDH_RESP_CMD */
+
+#define                  RESP_CMD  0x3f       /* Response Command */
+
+/* Bit masks for SDH_DATA_CTL */
+
+#define                     DTX_E  0x1        /* Data Transfer Enable */
+#define                    nDTX_E  0x0       
+#define                   DTX_DIR  0x2        /* Data Transfer Direction */
+#define                  nDTX_DIR  0x0       
+#define                  DTX_MODE  0x4        /* Data Transfer Mode */
+#define                 nDTX_MODE  0x0       
+#define                 DTX_DMA_E  0x8        /* Data Transfer DMA Enable */
+#define                nDTX_DMA_E  0x0       
+#define              DTX_BLK_LGTH  0xf0       /* Data Transfer Block Length */
+
+/* Bit masks for SDH_STATUS */
+
+#define              CMD_CRC_FAIL  0x1        /* CMD CRC Fail */
+#define             nCMD_CRC_FAIL  0x0       
+#define              DAT_CRC_FAIL  0x2        /* Data CRC Fail */
+#define             nDAT_CRC_FAIL  0x0       
+#define               CMD_TIMEOUT  0x4        /* CMD Time Out */
+#define              nCMD_TIMEOUT  0x0       
+#define               DAT_TIMEOUT  0x8        /* Data Time Out */
+#define              nDAT_TIMEOUT  0x0       
+#define               TX_UNDERRUN  0x10       /* Transmit Underrun */
+#define              nTX_UNDERRUN  0x0       
+#define                RX_OVERRUN  0x20       /* Receive Overrun */
+#define               nRX_OVERRUN  0x0       
+#define              CMD_RESP_END  0x40       /* CMD Response End */
+#define             nCMD_RESP_END  0x0       
+#define                  CMD_SENT  0x80       /* CMD Sent */
+#define                 nCMD_SENT  0x0       
+#define                   DAT_END  0x100      /* Data End */
+#define                  nDAT_END  0x0       
+#define             START_BIT_ERR  0x200      /* Start Bit Error */
+#define            nSTART_BIT_ERR  0x0       
+#define               DAT_BLK_END  0x400      /* Data Block End */
+#define              nDAT_BLK_END  0x0       
+#define                   CMD_ACT  0x800      /* CMD Active */
+#define                  nCMD_ACT  0x0       
+#define                    TX_ACT  0x1000     /* Transmit Active */
+#define                   nTX_ACT  0x0       
+#define                    RX_ACT  0x2000     /* Receive Active */
+#define                   nRX_ACT  0x0       
+#define              TX_FIFO_STAT  0x4000     /* Transmit FIFO Status */
+#define             nTX_FIFO_STAT  0x0       
+#define              RX_FIFO_STAT  0x8000     /* Receive FIFO Status */
+#define             nRX_FIFO_STAT  0x0       
+#define              TX_FIFO_FULL  0x10000    /* Transmit FIFO Full */
+#define             nTX_FIFO_FULL  0x0       
+#define              RX_FIFO_FULL  0x20000    /* Receive FIFO Full */
+#define             nRX_FIFO_FULL  0x0       
+#define              TX_FIFO_ZERO  0x40000    /* Transmit FIFO Empty */
+#define             nTX_FIFO_ZERO  0x0       
+#define               RX_DAT_ZERO  0x80000    /* Receive FIFO Empty */
+#define              nRX_DAT_ZERO  0x0       
+#define                TX_DAT_RDY  0x100000   /* Transmit Data Available */
+#define               nTX_DAT_RDY  0x0       
+#define               RX_FIFO_RDY  0x200000   /* Receive Data Available */
+#define              nRX_FIFO_RDY  0x0       
+
+/* Bit masks for SDH_STATUS_CLR */
+
+#define         CMD_CRC_FAIL_STAT  0x1        /* CMD CRC Fail Status */
+#define        nCMD_CRC_FAIL_STAT  0x0       
+#define         DAT_CRC_FAIL_STAT  0x2        /* Data CRC Fail Status */
+#define        nDAT_CRC_FAIL_STAT  0x0       
+#define          CMD_TIMEOUT_STAT  0x4        /* CMD Time Out Status */
+#define         nCMD_TIMEOUT_STAT  0x0       
+#define          DAT_TIMEOUT_STAT  0x8        /* Data Time Out status */
+#define         nDAT_TIMEOUT_STAT  0x0       
+#define          TX_UNDERRUN_STAT  0x10       /* Transmit Underrun Status */
+#define         nTX_UNDERRUN_STAT  0x0       
+#define           RX_OVERRUN_STAT  0x20       /* Receive Overrun Status */
+#define          nRX_OVERRUN_STAT  0x0       
+#define         CMD_RESP_END_STAT  0x40       /* CMD Response End Status */
+#define        nCMD_RESP_END_STAT  0x0       
+#define             CMD_SENT_STAT  0x80       /* CMD Sent Status */
+#define            nCMD_SENT_STAT  0x0       
+#define              DAT_END_STAT  0x100      /* Data End Status */
+#define             nDAT_END_STAT  0x0       
+#define        START_BIT_ERR_STAT  0x200      /* Start Bit Error Status */
+#define       nSTART_BIT_ERR_STAT  0x0       
+#define          DAT_BLK_END_STAT  0x400      /* Data Block End Status */
+#define         nDAT_BLK_END_STAT  0x0       
+
+/* Bit masks for SDH_MASK0 */
+
+#define         CMD_CRC_FAIL_MASK  0x1        /* CMD CRC Fail Mask */
+#define        nCMD_CRC_FAIL_MASK  0x0       
+#define         DAT_CRC_FAIL_MASK  0x2        /* Data CRC Fail Mask */
+#define        nDAT_CRC_FAIL_MASK  0x0       
+#define          CMD_TIMEOUT_MASK  0x4        /* CMD Time Out Mask */
+#define         nCMD_TIMEOUT_MASK  0x0       
+#define          DAT_TIMEOUT_MASK  0x8        /* Data Time Out Mask */
+#define         nDAT_TIMEOUT_MASK  0x0       
+#define          TX_UNDERRUN_MASK  0x10       /* Transmit Underrun Mask */
+#define         nTX_UNDERRUN_MASK  0x0       
+#define           RX_OVERRUN_MASK  0x20       /* Receive Overrun Mask */
+#define          nRX_OVERRUN_MASK  0x0       
+#define         CMD_RESP_END_MASK  0x40       /* CMD Response End Mask */
+#define        nCMD_RESP_END_MASK  0x0       
+#define             CMD_SENT_MASK  0x80       /* CMD Sent Mask */
+#define            nCMD_SENT_MASK  0x0       
+#define              DAT_END_MASK  0x100      /* Data End Mask */
+#define             nDAT_END_MASK  0x0       
+#define        START_BIT_ERR_MASK  0x200      /* Start Bit Error Mask */
+#define       nSTART_BIT_ERR_MASK  0x0       
+#define          DAT_BLK_END_MASK  0x400      /* Data Block End Mask */
+#define         nDAT_BLK_END_MASK  0x0       
+#define              CMD_ACT_MASK  0x800      /* CMD Active Mask */
+#define             nCMD_ACT_MASK  0x0       
+#define               TX_ACT_MASK  0x1000     /* Transmit Active Mask */
+#define              nTX_ACT_MASK  0x0       
+#define               RX_ACT_MASK  0x2000     /* Receive Active Mask */
+#define              nRX_ACT_MASK  0x0       
+#define         TX_FIFO_STAT_MASK  0x4000     /* Transmit FIFO Status Mask */
+#define        nTX_FIFO_STAT_MASK  0x0       
+#define         RX_FIFO_STAT_MASK  0x8000     /* Receive FIFO Status Mask */
+#define        nRX_FIFO_STAT_MASK  0x0       
+#define         TX_FIFO_FULL_MASK  0x10000    /* Transmit FIFO Full Mask */
+#define        nTX_FIFO_FULL_MASK  0x0       
+#define         RX_FIFO_FULL_MASK  0x20000    /* Receive FIFO Full Mask */
+#define        nRX_FIFO_FULL_MASK  0x0       
+#define         TX_FIFO_ZERO_MASK  0x40000    /* Transmit FIFO Empty Mask */
+#define        nTX_FIFO_ZERO_MASK  0x0       
+#define          RX_DAT_ZERO_MASK  0x80000    /* Receive FIFO Empty Mask */
+#define         nRX_DAT_ZERO_MASK  0x0       
+#define           TX_DAT_RDY_MASK  0x100000   /* Transmit Data Available Mask */
+#define          nTX_DAT_RDY_MASK  0x0       
+#define          RX_FIFO_RDY_MASK  0x200000   /* Receive Data Available Mask */
+#define         nRX_FIFO_RDY_MASK  0x0       
+
+/* Bit masks for SDH_FIFO_CNT */
+
+#define                FIFO_COUNT  0x7fff     /* FIFO Count */
+
+/* Bit masks for SDH_E_STATUS */
+
+#define              SDIO_INT_DET  0x2        /* SDIO Int Detected */
+#define             nSDIO_INT_DET  0x0       
+#define               SD_CARD_DET  0x10       /* SD Card Detect */
+#define              nSD_CARD_DET  0x0       
+
+/* Bit masks for SDH_E_MASK */
+
+#define                  SDIO_MSK  0x2        /* Mask SDIO Int Detected */
+#define                 nSDIO_MSK  0x0       
+#define                   SCD_MSK  0x40       /* Mask Card Detect */
+#define                  nSCD_MSK  0x0       
+
+/* Bit masks for SDH_CFG */
+
+#define                   CLKS_EN  0x1        /* Clocks Enable */
+#define                  nCLKS_EN  0x0       
+#define                      SD4E  0x4        /* SDIO 4-Bit Enable */
+#define                     nSD4E  0x0       
+#define                       MWE  0x8        /* Moving Window Enable */
+#define                      nMWE  0x0       
+#define                    SD_RST  0x10       /* SDMMC Reset */
+#define                   nSD_RST  0x0       
+#define                 PUP_SDDAT  0x20       /* Pull-up SD_DAT */
+#define                nPUP_SDDAT  0x0       
+#define                PUP_SDDAT3  0x40       /* Pull-up SD_DAT3 */
+#define               nPUP_SDDAT3  0x0       
+#define                 PD_SDDAT3  0x80       /* Pull-down SD_DAT3 */
+#define                nPD_SDDAT3  0x0       
+
+/* Bit masks for SDH_RD_WAIT_EN */
+
+#define                       RWR  0x1        /* Read Wait Request */
+#define                      nRWR  0x0       
+
+/* Bit masks for ATAPI_CONTROL */
+
+#define                 PIO_START  0x1        /* Start PIO/Reg Op */
+#define                nPIO_START  0x0       
+#define               MULTI_START  0x2        /* Start Multi-DMA Op */
+#define              nMULTI_START  0x0       
+#define               ULTRA_START  0x4        /* Start Ultra-DMA Op */
+#define              nULTRA_START  0x0       
+#define                  XFER_DIR  0x8        /* Transfer Direction */
+#define                 nXFER_DIR  0x0       
+#define                  IORDY_EN  0x10       /* IORDY Enable */
+#define                 nIORDY_EN  0x0       
+#define                FIFO_FLUSH  0x20       /* Flush FIFOs */
+#define               nFIFO_FLUSH  0x0       
+#define                  SOFT_RST  0x40       /* Soft Reset */
+#define                 nSOFT_RST  0x0       
+#define                   DEV_RST  0x80       /* Device Reset */
+#define                  nDEV_RST  0x0       
+#define                TFRCNT_RST  0x100      /* Trans Count Reset */
+#define               nTFRCNT_RST  0x0       
+#define               END_ON_TERM  0x200      /* End/Terminate Select */
+#define              nEND_ON_TERM  0x0       
+#define               PIO_USE_DMA  0x400      /* PIO-DMA Enable */
+#define              nPIO_USE_DMA  0x0       
+#define          UDMAIN_FIFO_THRS  0xf000     /* Ultra DMA-IN FIFO Threshold */
+
+/* Bit masks for ATAPI_STATUS */
+
+#define               PIO_XFER_ON  0x1        /* PIO transfer in progress */
+#define              nPIO_XFER_ON  0x0       
+#define             MULTI_XFER_ON  0x2        /* Multi-word DMA transfer in progress */
+#define            nMULTI_XFER_ON  0x0       
+#define             ULTRA_XFER_ON  0x4        /* Ultra DMA transfer in progress */
+#define            nULTRA_XFER_ON  0x0       
+#define               ULTRA_IN_FL  0xf0       /* Ultra DMA Input FIFO Level */
+
+/* Bit masks for ATAPI_DEV_ADDR */
+
+#define                  DEV_ADDR  0x1f       /* Device Address */
+
+/* Bit masks for ATAPI_INT_MASK */
+
+#define        ATAPI_DEV_INT_MASK  0x1        /* Device interrupt mask */
+#define       nATAPI_DEV_INT_MASK  0x0       
+#define             PIO_DONE_MASK  0x2        /* PIO transfer done interrupt mask */
+#define            nPIO_DONE_MASK  0x0       
+#define           MULTI_DONE_MASK  0x4        /* Multi-DMA transfer done interrupt mask */
+#define          nMULTI_DONE_MASK  0x0       
+#define          UDMAIN_DONE_MASK  0x8        /* Ultra-DMA in transfer done interrupt mask */
+#define         nUDMAIN_DONE_MASK  0x0       
+#define         UDMAOUT_DONE_MASK  0x10       /* Ultra-DMA out transfer done interrupt mask */
+#define        nUDMAOUT_DONE_MASK  0x0       
+#define       HOST_TERM_XFER_MASK  0x20       /* Host terminate current transfer interrupt mask */
+#define      nHOST_TERM_XFER_MASK  0x0       
+#define           MULTI_TERM_MASK  0x40       /* Device terminate Multi-DMA transfer interrupt mask */
+#define          nMULTI_TERM_MASK  0x0       
+#define          UDMAIN_TERM_MASK  0x80       /* Device terminate Ultra-DMA-in transfer interrupt mask */
+#define         nUDMAIN_TERM_MASK  0x0       
+#define         UDMAOUT_TERM_MASK  0x100      /* Device terminate Ultra-DMA-out transfer interrupt mask */
+#define        nUDMAOUT_TERM_MASK  0x0       
+
+/* Bit masks for ATAPI_INT_STATUS */
+
+#define             ATAPI_DEV_INT  0x1        /* Device interrupt status */
+#define            nATAPI_DEV_INT  0x0       
+#define              PIO_DONE_INT  0x2        /* PIO transfer done interrupt status */
+#define             nPIO_DONE_INT  0x0       
+#define            MULTI_DONE_INT  0x4        /* Multi-DMA transfer done interrupt status */
+#define           nMULTI_DONE_INT  0x0       
+#define           UDMAIN_DONE_INT  0x8        /* Ultra-DMA in transfer done interrupt status */
+#define          nUDMAIN_DONE_INT  0x0       
+#define          UDMAOUT_DONE_INT  0x10       /* Ultra-DMA out transfer done interrupt status */
+#define         nUDMAOUT_DONE_INT  0x0       
+#define        HOST_TERM_XFER_INT  0x20       /* Host terminate current transfer interrupt status */
+#define       nHOST_TERM_XFER_INT  0x0       
+#define            MULTI_TERM_INT  0x40       /* Device terminate Multi-DMA transfer interrupt status */
+#define           nMULTI_TERM_INT  0x0       
+#define           UDMAIN_TERM_INT  0x80       /* Device terminate Ultra-DMA-in transfer interrupt status */
+#define          nUDMAIN_TERM_INT  0x0       
+#define          UDMAOUT_TERM_INT  0x100      /* Device terminate Ultra-DMA-out transfer interrupt status */
+#define         nUDMAOUT_TERM_INT  0x0       
+
+/* Bit masks for ATAPI_LINE_STATUS */
+
+#define                ATAPI_INTR  0x1        /* Device interrupt to host line status */
+#define               nATAPI_INTR  0x0       
+#define                ATAPI_DASP  0x2        /* Device dasp to host line status */
+#define               nATAPI_DASP  0x0       
+#define                ATAPI_CS0N  0x4        /* ATAPI chip select 0 line status */
+#define               nATAPI_CS0N  0x0       
+#define                ATAPI_CS1N  0x8        /* ATAPI chip select 1 line status */
+#define               nATAPI_CS1N  0x0       
+#define                ATAPI_ADDR  0x70       /* ATAPI address line status */
+#define              ATAPI_DMAREQ  0x80       /* ATAPI DMA request line status */
+#define             nATAPI_DMAREQ  0x0       
+#define             ATAPI_DMAACKN  0x100      /* ATAPI DMA acknowledge line status */
+#define            nATAPI_DMAACKN  0x0       
+#define               ATAPI_DIOWN  0x200      /* ATAPI write line status */
+#define              nATAPI_DIOWN  0x0       
+#define               ATAPI_DIORN  0x400      /* ATAPI read line status */
+#define              nATAPI_DIORN  0x0       
+#define               ATAPI_IORDY  0x800      /* ATAPI IORDY line status */
+#define              nATAPI_IORDY  0x0       
+
+/* Bit masks for ATAPI_SM_STATE */
+
+#define                PIO_CSTATE  0xf        /* PIO mode state machine current state */
+#define                DMA_CSTATE  0xf0       /* DMA mode state machine current state */
+#define             UDMAIN_CSTATE  0xf00      /* Ultra DMA-In mode state machine current state */
+#define            UDMAOUT_CSTATE  0xf000     /* ATAPI IORDY line status */
+
+/* Bit masks for ATAPI_TERMINATE */
+
+#define           ATAPI_HOST_TERM  0x1        /* Host terminationation */
+#define          nATAPI_HOST_TERM  0x0       
+
+/* Bit masks for ATAPI_REG_TIM_0 */
+
+#define                    T2_REG  0xff       /* End of cycle time for register access transfers */
+#define                  TEOC_REG  0xff00     /* Selects DIOR/DIOW pulsewidth */
+
+/* Bit masks for ATAPI_PIO_TIM_0 */
+
+#define                    T1_REG  0xf        /* Time from address valid to DIOR/DIOW */
+#define                T2_REG_PIO  0xff0      /* DIOR/DIOW pulsewidth */
+#define                    T4_REG  0xf000     /* DIOW data hold */
+
+/* Bit masks for ATAPI_PIO_TIM_1 */
+
+#define              TEOC_REG_PIO  0xff       /* End of cycle time for PIO access transfers. */
+
+/* Bit masks for ATAPI_MULTI_TIM_0 */
+
+#define                        TD  0xff       /* DIOR/DIOW asserted pulsewidth */
+#define                        TM  0xff00     /* Time from address valid to DIOR/DIOW */
+
+/* Bit masks for ATAPI_MULTI_TIM_1 */
+
+#define                       TKW  0xff       /* Selects DIOW negated pulsewidth */
+#define                       TKR  0xff00     /* Selects DIOR negated pulsewidth */
+
+/* Bit masks for ATAPI_MULTI_TIM_2 */
+
+#define                        TH  0xff       /* Selects DIOW data hold */
+#define                      TEOC  0xff00     /* Selects end of cycle for DMA */
+
+/* Bit masks for ATAPI_ULTRA_TIM_0 */
+
+#define                      TACK  0xff       /* Selects setup and hold times for TACK */
+#define                      TENV  0xff00     /* Selects envelope time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_1 */
+
+#define                      TDVS  0xff       /* Selects data valid setup time */
+#define                 TCYC_TDVS  0xff00     /* Selects cycle time - TDVS time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_2 */
+
+#define                       TSS  0xff       /* Selects time from STROBE edge to negation of DMARQ or assertion of STOP */
+#define                      TMLI  0xff00     /* Selects interlock time */
+
+/* Bit masks for ATAPI_ULTRA_TIM_3 */
+
+#define                      TZAH  0xff       /* Selects minimum delay required for output */
+#define               READY_PAUSE  0xff00     /* Selects ready to pause */
+
+/* Bit masks for TIMER_ENABLE1 */
+
+#define                    TIMEN8  0x1        /* Timer 8 Enable */
+#define                   nTIMEN8  0x0       
+#define                    TIMEN9  0x2        /* Timer 9 Enable */
+#define                   nTIMEN9  0x0       
+#define                   TIMEN10  0x4        /* Timer 10 Enable */
+#define                  nTIMEN10  0x0       
+
+/* Bit masks for TIMER_DISABLE1 */
+
+#define                   TIMDIS8  0x1        /* Timer 8 Disable */
+#define                  nTIMDIS8  0x0       
+#define                   TIMDIS9  0x2        /* Timer 9 Disable */
+#define                  nTIMDIS9  0x0       
+#define                  TIMDIS10  0x4        /* Timer 10 Disable */
+#define                 nTIMDIS10  0x0       
+
+/* Bit masks for TIMER_STATUS1 */
+
+#define                    TIMIL8  0x1        /* Timer 8 Interrupt */
+#define                   nTIMIL8  0x0       
+#define                    TIMIL9  0x2        /* Timer 9 Interrupt */
+#define                   nTIMIL9  0x0       
+#define                   TIMIL10  0x4        /* Timer 10 Interrupt */
+#define                  nTIMIL10  0x0       
+#define                 TOVF_ERR8  0x10       /* Timer 8 Counter Overflow */
+#define                nTOVF_ERR8  0x0       
+#define                 TOVF_ERR9  0x20       /* Timer 9 Counter Overflow */
+#define                nTOVF_ERR9  0x0       
+#define                TOVF_ERR10  0x40       /* Timer 10 Counter Overflow */
+#define               nTOVF_ERR10  0x0       
+#define                     TRUN8  0x1000     /* Timer 8 Slave Enable Status */
+#define                    nTRUN8  0x0       
+#define                     TRUN9  0x2000     /* Timer 9 Slave Enable Status */
+#define                    nTRUN9  0x0       
+#define                    TRUN10  0x4000     /* Timer 10 Slave Enable Status */
+#define                   nTRUN10  0x0       
+
+/* Bit masks for EPPI0 are obtained from common base header for EPPIx (EPPI1 and EPPI2) */
+
+/* Bit masks for USB_FADDR */
+
+#define          FUNCTION_ADDRESS  0x7f       /* Function address */
+
+/* Bit masks for USB_POWER */
+
+#define           ENABLE_SUSPENDM  0x1        /* enable SuspendM output */
+#define          nENABLE_SUSPENDM  0x0       
+#define              SUSPEND_MODE  0x2        /* Suspend Mode indicator */
+#define             nSUSPEND_MODE  0x0       
+#define               RESUME_MODE  0x4        /* DMA Mode */
+#define              nRESUME_MODE  0x0       
+#define                     RESET  0x8        /* Reset indicator */
+#define                    nRESET  0x0       
+#define                   HS_MODE  0x10       /* High Speed mode indicator */
+#define                  nHS_MODE  0x0       
+#define                 HS_ENABLE  0x20       /* high Speed Enable */
+#define                nHS_ENABLE  0x0       
+#define                 SOFT_CONN  0x40       /* Soft connect */
+#define                nSOFT_CONN  0x0       
+#define                ISO_UPDATE  0x80       /* Isochronous update */
+#define               nISO_UPDATE  0x0       
+
+/* Bit masks for USB_INTRTX */
+
+#define                    EP0_TX  0x1        /* Tx Endpoint 0 interrupt */
+#define                   nEP0_TX  0x0       
+#define                    EP1_TX  0x2        /* Tx Endpoint 1 interrupt */
+#define                   nEP1_TX  0x0       
+#define                    EP2_TX  0x4        /* Tx Endpoint 2 interrupt */
+#define                   nEP2_TX  0x0       
+#define                    EP3_TX  0x8        /* Tx Endpoint 3 interrupt */
+#define                   nEP3_TX  0x0       
+#define                    EP4_TX  0x10       /* Tx Endpoint 4 interrupt */
+#define                   nEP4_TX  0x0       
+#define                    EP5_TX  0x20       /* Tx Endpoint 5 interrupt */
+#define                   nEP5_TX  0x0       
+#define                    EP6_TX  0x40       /* Tx Endpoint 6 interrupt */
+#define                   nEP6_TX  0x0       
+#define                    EP7_TX  0x80       /* Tx Endpoint 7 interrupt */
+#define                   nEP7_TX  0x0       
+
+/* Bit masks for USB_INTRRX */
+
+#define                    EP1_RX  0x2        /* Rx Endpoint 1 interrupt */
+#define                   nEP1_RX  0x0       
+#define                    EP2_RX  0x4        /* Rx Endpoint 2 interrupt */
+#define                   nEP2_RX  0x0       
+#define                    EP3_RX  0x8        /* Rx Endpoint 3 interrupt */
+#define                   nEP3_RX  0x0       
+#define                    EP4_RX  0x10       /* Rx Endpoint 4 interrupt */
+#define                   nEP4_RX  0x0       
+#define                    EP5_RX  0x20       /* Rx Endpoint 5 interrupt */
+#define                   nEP5_RX  0x0       
+#define                    EP6_RX  0x40       /* Rx Endpoint 6 interrupt */
+#define                   nEP6_RX  0x0       
+#define                    EP7_RX  0x80       /* Rx Endpoint 7 interrupt */
+#define                   nEP7_RX  0x0       
+
+/* Bit masks for USB_INTRTXE */
+
+#define                  EP0_TX_E  0x1        /* Endpoint 0 interrupt Enable */
+#define                 nEP0_TX_E  0x0       
+#define                  EP1_TX_E  0x2        /* Tx Endpoint 1 interrupt  Enable */
+#define                 nEP1_TX_E  0x0       
+#define                  EP2_TX_E  0x4        /* Tx Endpoint 2 interrupt  Enable */
+#define                 nEP2_TX_E  0x0       
+#define                  EP3_TX_E  0x8        /* Tx Endpoint 3 interrupt  Enable */
+#define                 nEP3_TX_E  0x0       
+#define                  EP4_TX_E  0x10       /* Tx Endpoint 4 interrupt  Enable */
+#define                 nEP4_TX_E  0x0       
+#define                  EP5_TX_E  0x20       /* Tx Endpoint 5 interrupt  Enable */
+#define                 nEP5_TX_E  0x0       
+#define                  EP6_TX_E  0x40       /* Tx Endpoint 6 interrupt  Enable */
+#define                 nEP6_TX_E  0x0       
+#define                  EP7_TX_E  0x80       /* Tx Endpoint 7 interrupt  Enable */
+#define                 nEP7_TX_E  0x0       
+
+/* Bit masks for USB_INTRRXE */
+
+#define                  EP1_RX_E  0x2        /* Rx Endpoint 1 interrupt  Enable */
+#define                 nEP1_RX_E  0x0       
+#define                  EP2_RX_E  0x4        /* Rx Endpoint 2 interrupt  Enable */
+#define                 nEP2_RX_E  0x0       
+#define                  EP3_RX_E  0x8        /* Rx Endpoint 3 interrupt  Enable */
+#define                 nEP3_RX_E  0x0       
+#define                  EP4_RX_E  0x10       /* Rx Endpoint 4 interrupt  Enable */
+#define                 nEP4_RX_E  0x0       
+#define                  EP5_RX_E  0x20       /* Rx Endpoint 5 interrupt  Enable */
+#define                 nEP5_RX_E  0x0       
+#define                  EP6_RX_E  0x40       /* Rx Endpoint 6 interrupt  Enable */
+#define                 nEP6_RX_E  0x0       
+#define                  EP7_RX_E  0x80       /* Rx Endpoint 7 interrupt  Enable */
+#define                 nEP7_RX_E  0x0       
+
+/* Bit masks for USB_INTRUSB */
+
+#define                 SUSPEND_B  0x1        /* Suspend indicator */
+#define                nSUSPEND_B  0x0       
+#define                  RESUME_B  0x2        /* Resume indicator */
+#define                 nRESUME_B  0x0       
+#define          RESET_OR_BABLE_B  0x4        /* Reset/babble indicator */
+#define         nRESET_OR_BABLE_B  0x0       
+#define                     SOF_B  0x8        /* Start of frame */
+#define                    nSOF_B  0x0       
+#define                    CONN_B  0x10       /* Connection indicator */
+#define                   nCONN_B  0x0       
+#define                  DISCON_B  0x20       /* Disconnect indicator */
+#define                 nDISCON_B  0x0       
+#define             SESSION_REQ_B  0x40       /* Session Request */
+#define            nSESSION_REQ_B  0x0       
+#define              VBUS_ERROR_B  0x80       /* Vbus threshold indicator */
+#define             nVBUS_ERROR_B  0x0       
+
+/* Bit masks for USB_INTRUSBE */
+
+#define                SUSPEND_BE  0x1        /* Suspend indicator int enable */
+#define               nSUSPEND_BE  0x0       
+#define                 RESUME_BE  0x2        /* Resume indicator int enable */
+#define                nRESUME_BE  0x0       
+#define         RESET_OR_BABLE_BE  0x4        /* Reset/babble indicator int enable */
+#define        nRESET_OR_BABLE_BE  0x0       
+#define                    SOF_BE  0x8        /* Start of frame int enable */
+#define                   nSOF_BE  0x0       
+#define                   CONN_BE  0x10       /* Connection indicator int enable */
+#define                  nCONN_BE  0x0       
+#define                 DISCON_BE  0x20       /* Disconnect indicator int enable */
+#define                nDISCON_BE  0x0       
+#define            SESSION_REQ_BE  0x40       /* Session Request int enable */
+#define           nSESSION_REQ_BE  0x0       
+#define             VBUS_ERROR_BE  0x80       /* Vbus threshold indicator int enable */
+#define            nVBUS_ERROR_BE  0x0       
+
+/* Bit masks for USB_FRAME */
+
+#define              FRAME_NUMBER  0x7ff      /* Frame number */
+
+/* Bit masks for USB_INDEX */
+
+#define         SELECTED_ENDPOINT  0xf        /* selected endpoint */
+
+/* Bit masks for USB_GLOBAL_CTL */
+
+#define                GLOBAL_ENA  0x1        /* enables USB module */
+#define               nGLOBAL_ENA  0x0       
+#define                EP1_TX_ENA  0x2        /* Transmit endpoint 1 enable */
+#define               nEP1_TX_ENA  0x0       
+#define                EP2_TX_ENA  0x4        /* Transmit endpoint 2 enable */
+#define               nEP2_TX_ENA  0x0       
+#define                EP3_TX_ENA  0x8        /* Transmit endpoint 3 enable */
+#define               nEP3_TX_ENA  0x0       
+#define                EP4_TX_ENA  0x10       /* Transmit endpoint 4 enable */
+#define               nEP4_TX_ENA  0x0       
+#define                EP5_TX_ENA  0x20       /* Transmit endpoint 5 enable */
+#define               nEP5_TX_ENA  0x0       
+#define                EP6_TX_ENA  0x40       /* Transmit endpoint 6 enable */
+#define               nEP6_TX_ENA  0x0       
+#define                EP7_TX_ENA  0x80       /* Transmit endpoint 7 enable */
+#define               nEP7_TX_ENA  0x0       
+#define                EP1_RX_ENA  0x100      /* Receive endpoint 1 enable */
+#define               nEP1_RX_ENA  0x0       
+#define                EP2_RX_ENA  0x200      /* Receive endpoint 2 enable */
+#define               nEP2_RX_ENA  0x0       
+#define                EP3_RX_ENA  0x400      /* Receive endpoint 3 enable */
+#define               nEP3_RX_ENA  0x0       
+#define                EP4_RX_ENA  0x800      /* Receive endpoint 4 enable */
+#define               nEP4_RX_ENA  0x0       
+#define                EP5_RX_ENA  0x1000     /* Receive endpoint 5 enable */
+#define               nEP5_RX_ENA  0x0       
+#define                EP6_RX_ENA  0x2000     /* Receive endpoint 6 enable */
+#define               nEP6_RX_ENA  0x0       
+#define                EP7_RX_ENA  0x4000     /* Receive endpoint 7 enable */
+#define               nEP7_RX_ENA  0x0       
+
+/* Bit masks for USB_OTG_DEV_CTL */
+
+#define                   SESSION  0x1        /* session indicator */
+#define                  nSESSION  0x0       
+#define                  HOST_REQ  0x2        /* Host negotiation request */
+#define                 nHOST_REQ  0x0       
+#define                 HOST_MODE  0x4        /* indicates USBDRC is a host */
+#define                nHOST_MODE  0x0       
+#define                     VBUS0  0x8        /* Vbus level indicator[0] */
+#define                    nVBUS0  0x0       
+#define                     VBUS1  0x10       /* Vbus level indicator[1] */
+#define                    nVBUS1  0x0       
+#define                     LSDEV  0x20       /* Low-speed indicator */
+#define                    nLSDEV  0x0       
+#define                     FSDEV  0x40       /* Full or High-speed indicator */
+#define                    nFSDEV  0x0       
+#define                  B_DEVICE  0x80       /* A' or 'B' device indicator */
+#define                 nB_DEVICE  0x0       
+
+/* Bit masks for USB_OTG_VBUS_IRQ */
+
+#define             DRIVE_VBUS_ON  0x1        /* indicator to drive VBUS control circuit */
+#define            nDRIVE_VBUS_ON  0x0       
+#define            DRIVE_VBUS_OFF  0x2        /* indicator to shut off charge pump */
+#define           nDRIVE_VBUS_OFF  0x0       
+#define           CHRG_VBUS_START  0x4        /* indicator for external circuit to start charging VBUS */
+#define          nCHRG_VBUS_START  0x0       
+#define             CHRG_VBUS_END  0x8        /* indicator for external circuit to end charging VBUS */
+#define            nCHRG_VBUS_END  0x0       
+#define        DISCHRG_VBUS_START  0x10       /* indicator to start discharging VBUS */
+#define       nDISCHRG_VBUS_START  0x0       
+#define          DISCHRG_VBUS_END  0x20       /* indicator to stop discharging VBUS */
+#define         nDISCHRG_VBUS_END  0x0       
+
+/* Bit masks for USB_OTG_VBUS_MASK */
+
+#define         DRIVE_VBUS_ON_ENA  0x1        /* enable DRIVE_VBUS_ON interrupt */
+#define        nDRIVE_VBUS_ON_ENA  0x0       
+#define        DRIVE_VBUS_OFF_ENA  0x2        /* enable DRIVE_VBUS_OFF interrupt */
+#define       nDRIVE_VBUS_OFF_ENA  0x0       
+#define       CHRG_VBUS_START_ENA  0x4        /* enable CHRG_VBUS_START interrupt */
+#define      nCHRG_VBUS_START_ENA  0x0       
+#define         CHRG_VBUS_END_ENA  0x8        /* enable CHRG_VBUS_END interrupt */
+#define        nCHRG_VBUS_END_ENA  0x0       
+#define    DISCHRG_VBUS_START_ENA  0x10       /* enable DISCHRG_VBUS_START interrupt */
+#define   nDISCHRG_VBUS_START_ENA  0x0       
+#define      DISCHRG_VBUS_END_ENA  0x20       /* enable DISCHRG_VBUS_END interrupt */
+#define     nDISCHRG_VBUS_END_ENA  0x0       
+
+/* Bit masks for USB_CSR0 */
+
+#define                  RXPKTRDY  0x1        /* data packet receive indicator */
+#define                 nRXPKTRDY  0x0       
+#define                  TXPKTRDY  0x2        /* data packet in FIFO indicator */
+#define                 nTXPKTRDY  0x0       
+#define                STALL_SENT  0x4        /* STALL handshake sent */
+#define               nSTALL_SENT  0x0       
+#define                   DATAEND  0x8        /* Data end indicator */
+#define                  nDATAEND  0x0       
+#define                  SETUPEND  0x10       /* Setup end */
+#define                 nSETUPEND  0x0       
+#define                 SENDSTALL  0x20       /* Send STALL handshake */
+#define                nSENDSTALL  0x0       
+#define         SERVICED_RXPKTRDY  0x40       /* used to clear the RxPktRdy bit */
+#define        nSERVICED_RXPKTRDY  0x0       
+#define         SERVICED_SETUPEND  0x80       /* used to clear the SetupEnd bit */
+#define        nSERVICED_SETUPEND  0x0       
+#define                 FLUSHFIFO  0x100      /* flush endpoint FIFO */
+#define                nFLUSHFIFO  0x0       
+#define          STALL_RECEIVED_H  0x4        /* STALL handshake received host mode */
+#define         nSTALL_RECEIVED_H  0x0       
+#define                SETUPPKT_H  0x8        /* send Setup token host mode */
+#define               nSETUPPKT_H  0x0       
+#define                   ERROR_H  0x10       /* timeout error indicator host mode */
+#define                  nERROR_H  0x0       
+#define                  REQPKT_H  0x20       /* Request an IN transaction host mode */
+#define                 nREQPKT_H  0x0       
+#define               STATUSPKT_H  0x40       /* Status stage transaction host mode */
+#define              nSTATUSPKT_H  0x0       
+#define             NAK_TIMEOUT_H  0x80       /* EP0 halted after a NAK host mode */
+#define            nNAK_TIMEOUT_H  0x0       
+
+/* Bit masks for USB_COUNT0 */
+
+#define              EP0_RX_COUNT  0x7f       /* number of received bytes in EP0 FIFO */
+
+/* Bit masks for USB_NAKLIMIT0 */
+
+#define             EP0_NAK_LIMIT  0x1f       /* number of frames/micro frames after which EP0 timeouts */
+
+/* Bit masks for USB_TX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_T  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_RX_MAX_PACKET */
+
+#define         MAX_PACKET_SIZE_R  0x7ff      /* maximum data pay load in a frame */
+
+/* Bit masks for USB_TXCSR */
+
+#define                TXPKTRDY_T  0x1        /* data packet in FIFO indicator */
+#define               nTXPKTRDY_T  0x0       
+#define          FIFO_NOT_EMPTY_T  0x2        /* FIFO not empty */
+#define         nFIFO_NOT_EMPTY_T  0x0       
+#define                UNDERRUN_T  0x4        /* TxPktRdy not set  for an IN token */
+#define               nUNDERRUN_T  0x0       
+#define               FLUSHFIFO_T  0x8        /* flush endpoint FIFO */
+#define              nFLUSHFIFO_T  0x0       
+#define              STALL_SEND_T  0x10       /* issue a Stall handshake */
+#define             nSTALL_SEND_T  0x0       
+#define              STALL_SENT_T  0x20       /* Stall handshake transmitted */
+#define             nSTALL_SENT_T  0x0       
+#define        CLEAR_DATATOGGLE_T  0x40       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_T  0x0       
+#define                INCOMPTX_T  0x80       /* indicates that a large packet is split */
+#define               nINCOMPTX_T  0x0       
+#define              DMAREQMODE_T  0x400      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_T  0x0       
+#define        FORCE_DATATOGGLE_T  0x800      /* Force data toggle */
+#define       nFORCE_DATATOGGLE_T  0x0       
+#define              DMAREQ_ENA_T  0x1000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_T  0x0       
+#define                     ISO_T  0x4000     /* enable Isochronous transfers */
+#define                    nISO_T  0x0       
+#define                 AUTOSET_T  0x8000     /* allows TxPktRdy to be set automatically */
+#define                nAUTOSET_T  0x0       
+#define                  ERROR_TH  0x4        /* error condition host mode */
+#define                 nERROR_TH  0x0       
+#define         STALL_RECEIVED_TH  0x20       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_TH  0x0       
+#define            NAK_TIMEOUT_TH  0x80       /* NAK timeout host mode */
+#define           nNAK_TIMEOUT_TH  0x0       
+
+/* Bit masks for USB_TXCOUNT */
+
+#define                  TX_COUNT  0x1fff     /* Number of bytes to be written to the selected endpoint Tx FIFO */
+
+/* Bit masks for USB_RXCSR */
+
+#define                RXPKTRDY_R  0x1        /* data packet in FIFO indicator */
+#define               nRXPKTRDY_R  0x0       
+#define               FIFO_FULL_R  0x2        /* FIFO not empty */
+#define              nFIFO_FULL_R  0x0       
+#define                 OVERRUN_R  0x4        /* TxPktRdy not set  for an IN token */
+#define                nOVERRUN_R  0x0       
+#define               DATAERROR_R  0x8        /* Out packet cannot be loaded into Rx  FIFO */
+#define              nDATAERROR_R  0x0       
+#define               FLUSHFIFO_R  0x10       /* flush endpoint FIFO */
+#define              nFLUSHFIFO_R  0x0       
+#define              STALL_SEND_R  0x20       /* issue a Stall handshake */
+#define             nSTALL_SEND_R  0x0       
+#define              STALL_SENT_R  0x40       /* Stall handshake transmitted */
+#define             nSTALL_SENT_R  0x0       
+#define        CLEAR_DATATOGGLE_R  0x80       /* clear endpoint data toggle */
+#define       nCLEAR_DATATOGGLE_R  0x0       
+#define                INCOMPRX_R  0x100      /* indicates that a large packet is split */
+#define               nINCOMPRX_R  0x0       
+#define              DMAREQMODE_R  0x800      /* DMA mode (0 or 1) selection */
+#define             nDMAREQMODE_R  0x0       
+#define                 DISNYET_R  0x1000     /* disable Nyet handshakes */
+#define                nDISNYET_R  0x0       
+#define              DMAREQ_ENA_R  0x2000     /* Enable DMA request for Tx EP */
+#define             nDMAREQ_ENA_R  0x0       
+#define                     ISO_R  0x4000     /* enable Isochronous transfers */
+#define                    nISO_R  0x0       
+#define               AUTOCLEAR_R  0x8000     /* allows TxPktRdy to be set automatically */
+#define              nAUTOCLEAR_R  0x0       
+#define                  ERROR_RH  0x4        /* TxPktRdy not set  for an IN token host mode */
+#define                 nERROR_RH  0x0       
+#define                 REQPKT_RH  0x20       /* request an IN transaction host mode */
+#define                nREQPKT_RH  0x0       
+#define         STALL_RECEIVED_RH  0x40       /* Stall handshake received host mode */
+#define        nSTALL_RECEIVED_RH  0x0       
+#define               INCOMPRX_RH  0x100      /* indicates that a large packet is split host mode */
+#define              nINCOMPRX_RH  0x0       
+#define             DMAREQMODE_RH  0x800      /* DMA mode (0 or 1) selection host mode */
+#define            nDMAREQMODE_RH  0x0       
+#define                AUTOREQ_RH  0x4000     /* sets ReqPkt automatically host mode */
+#define               nAUTOREQ_RH  0x0       
+
+/* Bit masks for USB_RXCOUNT */
+
+#define                  RX_COUNT  0x1fff     /* Number of received bytes in the packet in the Rx FIFO */
+
+/* Bit masks for USB_TXTYPE */
+
+#define            TARGET_EP_NO_T  0xf        /* EP number */
+#define                PROTOCOL_T  0xc        /* transfer type */
+
+/* Bit masks for USB_TXINTERVAL */
+
+#define          TX_POLL_INTERVAL  0xff       /* polling interval for selected Tx EP */
+
+/* Bit masks for USB_RXTYPE */
+
+#define            TARGET_EP_NO_R  0xf        /* EP number */
+#define                PROTOCOL_R  0xc        /* transfer type */
+
+/* Bit masks for USB_RXINTERVAL */
+
+#define          RX_POLL_INTERVAL  0xff       /* polling interval for selected Rx EP */
+
+/* Bit masks for USB_DMA_INTERRUPT */
+
+#define                  DMA0_INT  0x1        /* DMA0 pending interrupt */
+#define                 nDMA0_INT  0x0       
+#define                  DMA1_INT  0x2        /* DMA1 pending interrupt */
+#define                 nDMA1_INT  0x0       
+#define                  DMA2_INT  0x4        /* DMA2 pending interrupt */
+#define                 nDMA2_INT  0x0       
+#define                  DMA3_INT  0x8        /* DMA3 pending interrupt */
+#define                 nDMA3_INT  0x0       
+#define                  DMA4_INT  0x10       /* DMA4 pending interrupt */
+#define                 nDMA4_INT  0x0       
+#define                  DMA5_INT  0x20       /* DMA5 pending interrupt */
+#define                 nDMA5_INT  0x0       
+#define                  DMA6_INT  0x40       /* DMA6 pending interrupt */
+#define                 nDMA6_INT  0x0       
+#define                  DMA7_INT  0x80       /* DMA7 pending interrupt */
+#define                 nDMA7_INT  0x0       
+
+/* Bit masks for USB_DMAxCONTROL */
+
+#define                   DMA_ENA  0x1        /* DMA enable */
+#define                  nDMA_ENA  0x0       
+#define                 DIRECTION  0x2        /* direction of DMA transfer */
+#define                nDIRECTION  0x0       
+#define                      MODE  0x4        /* DMA Bus error */
+#define                     nMODE  0x0       
+#define                   INT_ENA  0x8        /* Interrupt enable */
+#define                  nINT_ENA  0x0       
+#define                     EPNUM  0xf0       /* EP number */
+#define                  BUSERROR  0x100      /* DMA Bus error */
+#define                 nBUSERROR  0x0       
+
+/* Bit masks for USB_DMAxADDRHIGH */
+
+#define             DMA_ADDR_HIGH  0xffff     /* Upper 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxADDRLOW */
+
+#define              DMA_ADDR_LOW  0xffff     /* Lower 16-bits of memory source/destination address for the DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTHIGH */
+
+#define            DMA_COUNT_HIGH  0xffff     /* Upper 16-bits of byte count of DMA transfer for DMA master channel */
+
+/* Bit masks for USB_DMAxCOUNTLOW */
+
+#define             DMA_COUNT_LOW  0xffff     /* Lower 16-bits of byte count of DMA transfer for DMA master channel */
+
+/* Bit masks for HMDMAx_CONTROL */
+
+#define                   HMDMAEN  0x1        /* Handshake MDMA Enable */
+#define                  nHMDMAEN  0x0       
+#define                       REP  0x2        /* Handshake MDMA Request Polarity */
+#define                      nREP  0x0       
+#define                       UTE  0x8        /* Urgency Threshold Enable */
+#define                      nUTE  0x0       
+#define                       OIE  0x10       /* Overflow Interrupt Enable */
+#define                      nOIE  0x0       
+#define                      BDIE  0x20       /* Block Done Interrupt Enable */
+#define                     nBDIE  0x0       
+#define                      MBDI  0x40       /* Mask Block Done Interrupt */
+#define                     nMBDI  0x0       
+#define                       DRQ  0x300      /* Handshake MDMA Request Type */
+#define                       RBC  0x1000     /* Force Reload of BCOUNT */
+#define                      nRBC  0x0       
+#define                        PS  0x2000     /* Pin Status */
+#define                       nPS  0x0       
+#define                        OI  0x4000     /* Overflow Interrupt Generated */
+#define                       nOI  0x0       
+#define                       BDI  0x8000     /* Block Done Interrupt Generated */
+#define                      nBDI  0x0       
+
+/* ******************************************* */
+/*     MULTI BIT MACRO ENUMERATIONS            */
+/* ******************************************* */
+
+/* ************************ */
+/*   MXVR Address Offsets   */
+/* ************************ */
+
+/* Control Message Receive Buffer (CMRB) Address Offsets */
+
+#define CMRB_STRIDE       0x00000016lu
+
+#define CMRB_DST_OFFSET   0x00000000lu
+#define CMRB_SRC_OFFSET   0x00000002lu
+#define CMRB_DATA_OFFSET  0x00000005lu
+
+/* Control Message Transmit Buffer (CMTB) Address Offsets */
+
+#define CMTB_PRIO_OFFSET    0x00000000lu
+#define CMTB_DST_OFFSET     0x00000002lu
+#define CMTB_SRC_OFFSET     0x00000004lu
+#define CMTB_TYPE_OFFSET    0x00000006lu
+#define CMTB_DATA_OFFSET    0x00000007lu
+
+#define CMTB_ANSWER_OFFSET  0x0000000Alu
+
+#define CMTB_STAT_N_OFFSET  0x00000018lu
+#define CMTB_STAT_A_OFFSET  0x00000016lu
+#define CMTB_STAT_D_OFFSET  0x0000000Elu
+#define CMTB_STAT_R_OFFSET  0x00000014lu
+#define CMTB_STAT_W_OFFSET  0x00000014lu
+#define CMTB_STAT_G_OFFSET  0x00000014lu
+
+/* Asynchronous Packet Receive Buffer (APRB) Address Offsets */
+
+#define APRB_STRIDE       0x00000400lu
+
+#define APRB_DST_OFFSET   0x00000000lu
+#define APRB_LEN_OFFSET   0x00000002lu
+#define APRB_SRC_OFFSET   0x00000004lu
+#define APRB_DATA_OFFSET  0x00000006lu
+
+/* Asynchronous Packet Transmit Buffer (APTB) Address Offsets */
+
+#define APTB_PRIO_OFFSET  0x00000000lu
+#define APTB_DST_OFFSET   0x00000002lu
+#define APTB_LEN_OFFSET   0x00000004lu
+#define APTB_SRC_OFFSET   0x00000006lu
+#define APTB_DATA_OFFSET  0x00000008lu
+
+/* Remote Read Buffer (RRDB) Address Offsets */
+
+#define RRDB_WADDR_OFFSET 0x00000100lu
+#define RRDB_WLEN_OFFSET  0x00000101lu
+
+/* **************** */
+/*   MXVR Macros    */
+/* **************** */
+
+/* MXVR_CONFIG Macros */
+
+#define SET_MSB(x)       ( ( (x) & 0xF  ) << 9)
+
+/* MXVR_INT_STAT_1 Macros */
+
+#define DONEX(x)         (0x00000002 << (4 * (x)))
+#define HDONEX(x)        (0x00000001 << (4 * (x)))
+
+/* MXVR_INT_EN_1 Macros */
+
+#define DONEENX(x)       (0x00000002 << (4 * (x)))
+#define HDONEENX(x)      (0x00000001 << (4 * (x)))
+
+/* MXVR_CDRPLL_CTL Macros */
+
+#define SET_CDRSHPSEL(x) ( ( (x) & 0x3F ) << 16)
+
+/* MXVR_FMPLL_CTL Macros */
+
+#define SET_CDRCPSEL(x)  ( ( (x) & 0xFF ) << 24)
+#define SET_FMCPSEL(x)   ( ( (x) & 0xFF ) << 24)
+
+#endif /* _DEF_BF549_H */
diff --git a/include/asm-blackfin/mach-bf548/defBF54x_base.h b/include/asm-blackfin/mach-bf548/defBF54x_base.h
new file mode 100644
index 0000000..a1b200f
--- /dev/null
+++ b/include/asm-blackfin/mach-bf548/defBF54x_base.h
@@ -0,0 +1,4902 @@
+/*
+ * File:         include/asm-blackfin/mach-bf548/defBF54x_base.h
+ * Based on:
+ * Author:
+ *
+ * Created:
+ * Description:
+ *
+ * Rev:
+ *
+ * Modified:
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.
+ * If not, write to the Free Software Foundation,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DEF_BF54X_H
+#define _DEF_BF54X_H
+
+
+/* ************************************************************** */
+/*   SYSTEM & MMR ADDRESS DEFINITIONS COMMON TO ALL ADSP-BF54x    */
+/* ************************************************************** */
+
+/* PLL Registers */
+
+#define                          PLL_CTL  0xffc00000   /* PLL Control Register */
+#define                          PLL_DIV  0xffc00004   /* PLL Divisor Register */
+#define                           VR_CTL  0xffc00008   /* Voltage Regulator Control Register */
+#define                         PLL_STAT  0xffc0000c   /* PLL Status Register */
+#define                      PLL_LOCKCNT  0xffc00010   /* PLL Lock Count Register */
+
+/* Debug/MP/Emulation Registers (0xFFC00014 - 0xFFC00014) */
+
+#define                           CHIPID  0xffc00014   
+
+/* System Reset and Interrupt Controller (0xFFC00100 - 0xFFC00104) */
+
+#define                            SWRST  0xffc00100   /* Software Reset Register */
+#define                            SYSCR  0xffc00104   /* System Configuration register */
+
+/* SIC Registers */
+
+#define                       SIC_IMASK0  0xffc0010c   /* System Interrupt Mask Register 0 */
+#define                       SIC_IMASK1  0xffc00110   /* System Interrupt Mask Register 1 */
+#define                       SIC_IMASK2  0xffc00114   /* System Interrupt Mask Register 2 */
+#define                         SIC_ISR0  0xffc00118   /* System Interrupt Status Register 0 */
+#define                         SIC_ISR1  0xffc0011c   /* System Interrupt Status Register 1 */
+#define                         SIC_ISR2  0xffc00120   /* System Interrupt Status Register 2 */
+#define                         SIC_IWR0  0xffc00124   /* System Interrupt Wakeup Register 0 */
+#define                         SIC_IWR1  0xffc00128   /* System Interrupt Wakeup Register 1 */
+#define                         SIC_IWR2  0xffc0012c   /* System Interrupt Wakeup Register 2 */
+#define                         SIC_IAR0  0xffc00130   /* System Interrupt Assignment Register 0 */
+#define                         SIC_IAR1  0xffc00134   /* System Interrupt Assignment Register 1 */
+#define                         SIC_IAR2  0xffc00138   /* System Interrupt Assignment Register 2 */
+#define                         SIC_IAR3  0xffc0013c   /* System Interrupt Assignment Register 3 */
+#define                         SIC_IAR4  0xffc00140   /* System Interrupt Assignment Register 4 */
+#define                         SIC_IAR5  0xffc00144   /* System Interrupt Assignment Register 5 */
+#define                         SIC_IAR6  0xffc00148   /* System Interrupt Assignment Register 6 */
+#define                         SIC_IAR7  0xffc0014c   /* System Interrupt Assignment Register 7 */
+#define                         SIC_IAR8  0xffc00150   /* System Interrupt Assignment Register 8 */
+#define                         SIC_IAR9  0xffc00154   /* System Interrupt Assignment Register 9 */
+#define                        SIC_IAR10  0xffc00158   /* System Interrupt Assignment Register 10 */
+#define                        SIC_IAR11  0xffc0015c   /* System Interrupt Assignment Register 11 */
+
+/* Watchdog Timer Registers */
+
+#define                         WDOG_CTL  0xffc00200   /* Watchdog Control Register */
+#define                         WDOG_CNT  0xffc00204   /* Watchdog Count Register */
+#define                        WDOG_STAT  0xffc00208   /* Watchdog Status Register */
+
+/* RTC Registers */
+
+#define                         RTC_STAT  0xffc00300   /* RTC Status Register */
+#define                         RTC_ICTL  0xffc00304   /* RTC Interrupt Control Register */
+#define                        RTC_ISTAT  0xffc00308   /* RTC Interrupt Status Register */
+#define                        RTC_SWCNT  0xffc0030c   /* RTC Stopwatch Count Register */
+#define                        RTC_ALARM  0xffc00310   /* RTC Alarm Register */
+#define                         RTC_PREN  0xffc00314   /* RTC Prescaler Enable Register */
+
+/* UART0 Registers */
+
+#define                        UART0_DLL  0xffc00400   /* Divisor Latch Low Byte */
+#define                        UART0_DLH  0xffc00404   /* Divisor Latch High Byte */
+#define                       UART0_GCTL  0xffc00408   /* Global Control Register */
+#define                        UART0_LCR  0xffc0040c   /* Line Control Register */
+#define                        UART0_MCR  0xffc00410   /* Modem Control Register */
+#define                        UART0_LSR  0xffc00414   /* Line Status Register */
+#define                        UART0_MSR  0xffc00418   /* Modem Status Register */
+#define                        UART0_SCR  0xffc0041c   /* Scratch Register */
+#define                    UART0_IER_SET  0xffc00420   /* Interrupt Enable Register Set */
+#define                  UART0_IER_CLEAR  0xffc00424   /* Interrupt Enable Register Clear */
+#define                        UART0_THR  0xffc00428   /* Transmit Hold Register */
+#define                        UART0_RBR  0xffc0042c   /* Receive Buffer Register */
+
+/* SPI0 Registers */
+
+#define                         SPI0_CTL  0xffc00500   /* SPI0 Control Register */
+#define                         SPI0_FLG  0xffc00504   /* SPI0 Flag Register */
+#define                        SPI0_STAT  0xffc00508   /* SPI0 Status Register */
+#define                        SPI0_TDBR  0xffc0050c   /* SPI0 Transmit Data Buffer Register */
+#define                        SPI0_RDBR  0xffc00510   /* SPI0 Receive Data Buffer Register */
+#define                        SPI0_BAUD  0xffc00514   /* SPI0 Baud Rate Register */
+#define                      SPI0_SHADOW  0xffc00518   /* SPI0 Receive Data Buffer Shadow Register */
+
+/* Timer Group of 3 registers are not defined in the shared file because they are not available on the ADSP-BF542 processor */
+
+/* Two Wire Interface Registers (TWI0) */
+
+#define                      TWI0_CLKDIV  0xffc00700   /* Clock Divider Register */
+#define                     TWI0_CONTROL  0xffc00704   /* TWI Control Register */
+#define                  TWI0_SLAVE_CTRL  0xffc00708   /* TWI Slave Mode Control Register */
+#define                  TWI0_SLAVE_STAT  0xffc0070c   /* TWI Slave Mode Status Register */
+#define                  TWI0_SLAVE_ADDR  0xffc00710   /* TWI Slave Mode Address Register */
+#define                 TWI0_MASTER_CTRL  0xffc00714   /* TWI Master Mode Control Register */
+#define                 TWI0_MASTER_STAT  0xffc00718   /* TWI Master Mode Status Register */
+#define                 TWI0_MASTER_ADDR  0xffc0071c   /* TWI Master Mode Address Register */
+#define                    TWI0_INT_STAT  0xffc00720   /* TWI Interrupt Status Register */
+#define                    TWI0_INT_MASK  0xffc00724   /* TWI Interrupt Mask Register */
+#define                   TWI0_FIFO_CTRL  0xffc00728   /* TWI FIFO Control Register */
+#define                   TWI0_FIFO_STAT  0xffc0072c   /* TWI FIFO Status Register */
+#define                   TWI0_XMT_DATA8  0xffc00780   /* TWI FIFO Transmit Data Single Byte Register */
+#define                  TWI0_XMT_DATA16  0xffc00784   /* TWI FIFO Transmit Data Double Byte Register */
+#define                   TWI0_RCV_DATA8  0xffc00788   /* TWI FIFO Receive Data Single Byte Register */
+#define                  TWI0_RCV_DATA16  0xffc0078c   /* TWI FIFO Receive Data Double Byte Register */
+
+/* SPORT0 is not defined in the shared file because it is not available on the ADSP-BF542 and ADSP-BF544 processors */
+
+/* SPORT1 Registers */
+
+#define                      SPORT1_TCR1  0xffc00900   /* SPORT1 Transmit Configuration 1 Register */
+#define                      SPORT1_TCR2  0xffc00904   /* SPORT1 Transmit Configuration 2 Register */
+#define                   SPORT1_TCLKDIV  0xffc00908   /* SPORT1 Transmit Serial Clock Divider Register */
+#define                    SPORT1_TFSDIV  0xffc0090c   /* SPORT1 Transmit Frame Sync Divider Register */
+#define                        SPORT1_TX  0xffc00910   /* SPORT1 Transmit Data Register */
+#define                        SPORT1_RX  0xffc00918   /* SPORT1 Receive Data Register */
+#define                      SPORT1_RCR1  0xffc00920   /* SPORT1 Receive Configuration 1 Register */
+#define                      SPORT1_RCR2  0xffc00924   /* SPORT1 Receive Configuration 2 Register */
+#define                   SPORT1_RCLKDIV  0xffc00928   /* SPORT1 Receive Serial Clock Divider Register */
+#define                    SPORT1_RFSDIV  0xffc0092c   /* SPORT1 Receive Frame Sync Divider Register */
+#define                      SPORT1_STAT  0xffc00930   /* SPORT1 Status Register */
+#define                      SPORT1_CHNL  0xffc00934   /* SPORT1 Current Channel Register */
+#define                     SPORT1_MCMC1  0xffc00938   /* SPORT1 Multi channel Configuration Register 1 */
+#define                     SPORT1_MCMC2  0xffc0093c   /* SPORT1 Multi channel Configuration Register 2 */
+#define                     SPORT1_MTCS0  0xffc00940   /* SPORT1 Multi channel Transmit Select Register 0 */
+#define                     SPORT1_MTCS1  0xffc00944   /* SPORT1 Multi channel Transmit Select Register 1 */
+#define                     SPORT1_MTCS2  0xffc00948   /* SPORT1 Multi channel Transmit Select Register 2 */
+#define                     SPORT1_MTCS3  0xffc0094c   /* SPORT1 Multi channel Transmit Select Register 3 */
+#define                     SPORT1_MRCS0  0xffc00950   /* SPORT1 Multi channel Receive Select Register 0 */
+#define                     SPORT1_MRCS1  0xffc00954   /* SPORT1 Multi channel Receive Select Register 1 */
+#define                     SPORT1_MRCS2  0xffc00958   /* SPORT1 Multi channel Receive Select Register 2 */
+#define                     SPORT1_MRCS3  0xffc0095c   /* SPORT1 Multi channel Receive Select Register 3 */
+
+/* Asynchronous Memory Control Registers */
+
+#define                      EBIU_AMGCTL  0xffc00a00   /* Asynchronous Memory Global Control Register */
+#define                    EBIU_AMBCTL0   0xffc00a04   /* Asynchronous Memory Bank Control Register */
+#define                    EBIU_AMBCTL1   0xffc00a08   /* Asynchronous Memory Bank Control Register */
+#define                      EBIU_MBSCTL  0xffc00a0c   /* Asynchronous Memory Bank Select Control Register */
+#define                     EBIU_ARBSTAT  0xffc00a10   /* Asynchronous Memory Arbiter Status Register */
+#define                        EBIU_MODE  0xffc00a14   /* Asynchronous Mode Control Register */
+#define                        EBIU_FCTL  0xffc00a18   /* Asynchronous Memory Flash Control Register */
+
+/* DDR Memory Control Registers */
+
+#define                     EBIU_DDRCTL0  0xffc00a20   /* DDR Memory Control 0 Register */
+#define                     EBIU_DDRCTL1  0xffc00a24   /* DDR Memory Control 1 Register */
+#define                     EBIU_DDRCTL2  0xffc00a28   /* DDR Memory Control 2 Register */
+#define                     EBIU_DDRCTL3  0xffc00a2c   /* DDR Memory Control 3 Register */
+#define                      EBIU_DDRQUE  0xffc00a30   /* DDR Queue Configuration Register */
+#define                      EBIU_ERRADD  0xffc00a34   /* DDR Error Address Register */
+#define                      EBIU_ERRMST  0xffc00a38   /* DDR Error Master Register */
+#define                      EBIU_RSTCTL  0xffc00a3c   /* DDR Reset Control Register */
+
+/* DDR BankRead and Write Count Registers */
+
+#define                     EBIU_DDRBRC0  0xffc00a60   /* DDR Bank0 Read Count Register */
+#define                     EBIU_DDRBRC1  0xffc00a64   /* DDR Bank1 Read Count Register */
+#define                     EBIU_DDRBRC2  0xffc00a68   /* DDR Bank2 Read Count Register */
+#define                     EBIU_DDRBRC3  0xffc00a6c   /* DDR Bank3 Read Count Register */
+#define                     EBIU_DDRBRC4  0xffc00a70   /* DDR Bank4 Read Count Register */
+#define                     EBIU_DDRBRC5  0xffc00a74   /* DDR Bank5 Read Count Register */
+#define                     EBIU_DDRBRC6  0xffc00a78   /* DDR Bank6 Read Count Register */
+#define                     EBIU_DDRBRC7  0xffc00a7c   /* DDR Bank7 Read Count Register */
+#define                     EBIU_DDRBWC0  0xffc00a80   /* DDR Bank0 Write Count Register */
+#define                     EBIU_DDRBWC1  0xffc00a84   /* DDR Bank1 Write Count Register */
+#define                     EBIU_DDRBWC2  0xffc00a88   /* DDR Bank2 Write Count Register */
+#define                     EBIU_DDRBWC3  0xffc00a8c   /* DDR Bank3 Write Count Register */
+#define                     EBIU_DDRBWC4  0xffc00a90   /* DDR Bank4 Write Count Register */
+#define                     EBIU_DDRBWC5  0xffc00a94   /* DDR Bank5 Write Count Register */
+#define                     EBIU_DDRBWC6  0xffc00a98   /* DDR Bank6 Write Count Register */
+#define                     EBIU_DDRBWC7  0xffc00a9c   /* DDR Bank7 Write Count Register */
+#define                     EBIU_DDRACCT  0xffc00aa0   /* DDR Activation Count Register */
+#define                     EBIU_DDRTACT  0xffc00aa8   /* DDR Turn Around Count Register */
+#define                     EBIU_DDRARCT  0xffc00aac   /* DDR Auto-refresh Count Register */
+#define                      EBIU_DDRGC0  0xffc00ab0   /* DDR Grant Count 0 Register */
+#define                      EBIU_DDRGC1  0xffc00ab4   /* DDR Grant Count 1 Register */
+#define                      EBIU_DDRGC2  0xffc00ab8   /* DDR Grant Count 2 Register */
+#define                      EBIU_DDRGC3  0xffc00abc   /* DDR Grant Count 3 Register */
+#define                     EBIU_DDRMCEN  0xffc00ac0   /* DDR Metrics Counter Enable Register */
+#define                     EBIU_DDRMCCL  0xffc00ac4   /* DDR Metrics Counter Clear Register */
+
+/* DMAC0 Registers */
+
+#define                      DMAC0_TCPER  0xffc00b0c   /* DMA Controller 0 Traffic Control Periods Register */
+#define                      DMAC0_TCCNT  0xffc00b10   /* DMA Controller 0 Current Counts Register */
+
+/* DMA Channel 0 Registers */
+
+#define               DMA0_NEXT_DESC_PTR  0xffc00c00   /* DMA Channel 0 Next Descriptor Pointer Register */
+#define                  DMA0_START_ADDR  0xffc00c04   /* DMA Channel 0 Start Address Register */
+#define                      DMA0_CONFIG  0xffc00c08   /* DMA Channel 0 Configuration Register */
+#define                     DMA0_X_COUNT  0xffc00c10   /* DMA Channel 0 X Count Register */
+#define                    DMA0_X_MODIFY  0xffc00c14   /* DMA Channel 0 X Modify Register */
+#define                     DMA0_Y_COUNT  0xffc00c18   /* DMA Channel 0 Y Count Register */
+#define                    DMA0_Y_MODIFY  0xffc00c1c   /* DMA Channel 0 Y Modify Register */
+#define               DMA0_CURR_DESC_PTR  0xffc00c20   /* DMA Channel 0 Current Descriptor Pointer Register */
+#define                   DMA0_CURR_ADDR  0xffc00c24   /* DMA Channel 0 Current Address Register */
+#define                  DMA0_IRQ_STATUS  0xffc00c28   /* DMA Channel 0 Interrupt/Status Register */
+#define              DMA0_PERIPHERAL_MAP  0xffc00c2c   /* DMA Channel 0 Peripheral Map Register */
+#define                DMA0_CURR_X_COUNT  0xffc00c30   /* DMA Channel 0 Current X Count Register */
+#define                DMA0_CURR_Y_COUNT  0xffc00c38   /* DMA Channel 0 Current Y Count Register */
+
+/* DMA Channel 1 Registers */
+
+#define               DMA1_NEXT_DESC_PTR  0xffc00c40   /* DMA Channel 1 Next Descriptor Pointer Register */
+#define                  DMA1_START_ADDR  0xffc00c44   /* DMA Channel 1 Start Address Register */
+#define                      DMA1_CONFIG  0xffc00c48   /* DMA Channel 1 Configuration Register */
+#define                     DMA1_X_COUNT  0xffc00c50   /* DMA Channel 1 X Count Register */
+#define                    DMA1_X_MODIFY  0xffc00c54   /* DMA Channel 1 X Modify Register */
+#define                     DMA1_Y_COUNT  0xffc00c58   /* DMA Channel 1 Y Count Register */
+#define                    DMA1_Y_MODIFY  0xffc00c5c   /* DMA Channel 1 Y Modify Register */
+#define               DMA1_CURR_DESC_PTR  0xffc00c60   /* DMA Channel 1 Current Descriptor Pointer Register */
+#define                   DMA1_CURR_ADDR  0xffc00c64   /* DMA Channel 1 Current Address Register */
+#define                  DMA1_IRQ_STATUS  0xffc00c68   /* DMA Channel 1 Interrupt/Status Register */
+#define              DMA1_PERIPHERAL_MAP  0xffc00c6c   /* DMA Channel 1 Peripheral Map Register */
+#define                DMA1_CURR_X_COUNT  0xffc00c70   /* DMA Channel 1 Current X Count Register */
+#define                DMA1_CURR_Y_COUNT  0xffc00c78   /* DMA Channel 1 Current Y Count Register */
+
+/* DMA Channel 2 Registers */
+
+#define               DMA2_NEXT_DESC_PTR  0xffc00c80   /* DMA Channel 2 Next Descriptor Pointer Register */
+#define                  DMA2_START_ADDR  0xffc00c84   /* DMA Channel 2 Start Address Register */
+#define                      DMA2_CONFIG  0xffc00c88   /* DMA Channel 2 Configuration Register */
+#define                     DMA2_X_COUNT  0xffc00c90   /* DMA Channel 2 X Count Register */
+#define                    DMA2_X_MODIFY  0xffc00c94   /* DMA Channel 2 X Modify Register */
+#define                     DMA2_Y_COUNT  0xffc00c98   /* DMA Channel 2 Y Count Register */
+#define                    DMA2_Y_MODIFY  0xffc00c9c   /* DMA Channel 2 Y Modify Register */
+#define               DMA2_CURR_DESC_PTR  0xffc00ca0   /* DMA Channel 2 Current Descriptor Pointer Register */
+#define                   DMA2_CURR_ADDR  0xffc00ca4   /* DMA Channel 2 Current Address Register */
+#define                  DMA2_IRQ_STATUS  0xffc00ca8   /* DMA Channel 2 Interrupt/Status Register */
+#define              DMA2_PERIPHERAL_MAP  0xffc00cac   /* DMA Channel 2 Peripheral Map Register */
+#define                DMA2_CURR_X_COUNT  0xffc00cb0   /* DMA Channel 2 Current X Count Register */
+#define                DMA2_CURR_Y_COUNT  0xffc00cb8   /* DMA Channel 2 Current Y Count Register */
+
+/* DMA Channel 3 Registers */
+
+#define               DMA3_NEXT_DESC_PTR  0xffc00cc0   /* DMA Channel 3 Next Descriptor Pointer Register */
+#define                  DMA3_START_ADDR  0xffc00cc4   /* DMA Channel 3 Start Address Register */
+#define                      DMA3_CONFIG  0xffc00cc8   /* DMA Channel 3 Configuration Register */
+#define                     DMA3_X_COUNT  0xffc00cd0   /* DMA Channel 3 X Count Register */
+#define                    DMA3_X_MODIFY  0xffc00cd4   /* DMA Channel 3 X Modify Register */
+#define                     DMA3_Y_COUNT  0xffc00cd8   /* DMA Channel 3 Y Count Register */
+#define                    DMA3_Y_MODIFY  0xffc00cdc   /* DMA Channel 3 Y Modify Register */
+#define               DMA3_CURR_DESC_PTR  0xffc00ce0   /* DMA Channel 3 Current Descriptor Pointer Register */
+#define                   DMA3_CURR_ADDR  0xffc00ce4   /* DMA Channel 3 Current Address Register */
+#define                  DMA3_IRQ_STATUS  0xffc00ce8   /* DMA Channel 3 Interrupt/Status Register */
+#define              DMA3_PERIPHERAL_MAP  0xffc00cec   /* DMA Channel 3 Peripheral Map Register */
+#define                DMA3_CURR_X_COUNT  0xffc00cf0   /* DMA Channel 3 Current X Count Register */
+#define                DMA3_CURR_Y_COUNT  0xffc00cf8   /* DMA Channel 3 Current Y Count Register */
+
+/* DMA Channel 4 Registers */
+
+#define               DMA4_NEXT_DESC_PTR  0xffc00d00   /* DMA Channel 4 Next Descriptor Pointer Register */
+#define                  DMA4_START_ADDR  0xffc00d04   /* DMA Channel 4 Start Address Register */
+#define                      DMA4_CONFIG  0xffc00d08   /* DMA Channel 4 Configuration Register */
+#define                     DMA4_X_COUNT  0xffc00d10   /* DMA Channel 4 X Count Register */
+#define                    DMA4_X_MODIFY  0xffc00d14   /* DMA Channel 4 X Modify Register */
+#define                     DMA4_Y_COUNT  0xffc00d18   /* DMA Channel 4 Y Count Register */
+#define                    DMA4_Y_MODIFY  0xffc00d1c   /* DMA Channel 4 Y Modify Register */
+#define               DMA4_CURR_DESC_PTR  0xffc00d20   /* DMA Channel 4 Current Descriptor Pointer Register */
+#define                   DMA4_CURR_ADDR  0xffc00d24   /* DMA Channel 4 Current Address Register */
+#define                  DMA4_IRQ_STATUS  0xffc00d28   /* DMA Channel 4 Interrupt/Status Register */
+#define              DMA4_PERIPHERAL_MAP  0xffc00d2c   /* DMA Channel 4 Peripheral Map Register */
+#define                DMA4_CURR_X_COUNT  0xffc00d30   /* DMA Channel 4 Current X Count Register */
+#define                DMA4_CURR_Y_COUNT  0xffc00d38   /* DMA Channel 4 Current Y Count Register */
+
+/* DMA Channel 5 Registers */
+
+#define               DMA5_NEXT_DESC_PTR  0xffc00d40   /* DMA Channel 5 Next Descriptor Pointer Register */
+#define                  DMA5_START_ADDR  0xffc00d44   /* DMA Channel 5 Start Address Register */
+#define                      DMA5_CONFIG  0xffc00d48   /* DMA Channel 5 Configuration Register */
+#define                     DMA5_X_COUNT  0xffc00d50   /* DMA Channel 5 X Count Register */
+#define                    DMA5_X_MODIFY  0xffc00d54   /* DMA Channel 5 X Modify Register */
+#define                     DMA5_Y_COUNT  0xffc00d58   /* DMA Channel 5 Y Count Register */
+#define                    DMA5_Y_MODIFY  0xffc00d5c   /* DMA Channel 5 Y Modify Register */
+#define               DMA5_CURR_DESC_PTR  0xffc00d60   /* DMA Channel 5 Current Descriptor Pointer Register */
+#define                   DMA5_CURR_ADDR  0xffc00d64   /* DMA Channel 5 Current Address Register */
+#define                  DMA5_IRQ_STATUS  0xffc00d68   /* DMA Channel 5 Interrupt/Status Register */
+#define              DMA5_PERIPHERAL_MAP  0xffc00d6c   /* DMA Channel 5 Peripheral Map Register */
+#define                DMA5_CURR_X_COUNT  0xffc00d70   /* DMA Channel 5 Current X Count Register */
+#define                DMA5_CURR_Y_COUNT  0xffc00d78   /* DMA Channel 5 Current Y Count Register */
+
+/* DMA Channel 6 Registers */
+
+#define               DMA6_NEXT_DESC_PTR  0xffc00d80   /* DMA Channel 6 Next Descriptor Pointer Register */
+#define                  DMA6_START_ADDR  0xffc00d84   /* DMA Channel 6 Start Address Register */
+#define                      DMA6_CONFIG  0xffc00d88   /* DMA Channel 6 Configuration Register */
+#define                     DMA6_X_COUNT  0xffc00d90   /* DMA Channel 6 X Count Register */
+#define                    DMA6_X_MODIFY  0xffc00d94   /* DMA Channel 6 X Modify Register */
+#define                     DMA6_Y_COUNT  0xffc00d98   /* DMA Channel 6 Y Count Register */
+#define                    DMA6_Y_MODIFY  0xffc00d9c   /* DMA Channel 6 Y Modify Register */
+#define               DMA6_CURR_DESC_PTR  0xffc00da0   /* DMA Channel 6 Current Descriptor Pointer Register */
+#define                   DMA6_CURR_ADDR  0xffc00da4   /* DMA Channel 6 Current Address Register */
+#define                  DMA6_IRQ_STATUS  0xffc00da8   /* DMA Channel 6 Interrupt/Status Register */
+#define              DMA6_PERIPHERAL_MAP  0xffc00dac   /* DMA Channel 6 Peripheral Map Register */
+#define                DMA6_CURR_X_COUNT  0xffc00db0   /* DMA Channel 6 Current X Count Register */
+#define                DMA6_CURR_Y_COUNT  0xffc00db8   /* DMA Channel 6 Current Y Count Register */
+
+/* DMA Channel 7 Registers */
+
+#define               DMA7_NEXT_DESC_PTR  0xffc00dc0   /* DMA Channel 7 Next Descriptor Pointer Register */
+#define                  DMA7_START_ADDR  0xffc00dc4   /* DMA Channel 7 Start Address Register */
+#define                      DMA7_CONFIG  0xffc00dc8   /* DMA Channel 7 Configuration Register */
+#define                     DMA7_X_COUNT  0xffc00dd0   /* DMA Channel 7 X Count Register */
+#define                    DMA7_X_MODIFY  0xffc00dd4   /* DMA Channel 7 X Modify Register */
+#define                     DMA7_Y_COUNT  0xffc00dd8   /* DMA Channel 7 Y Count Register */
+#define                    DMA7_Y_MODIFY  0xffc00ddc   /* DMA Channel 7 Y Modify Register */
+#define               DMA7_CURR_DESC_PTR  0xffc00de0   /* DMA Channel 7 Current Descriptor Pointer Register */
+#define                   DMA7_CURR_ADDR  0xffc00de4   /* DMA Channel 7 Current Address Register */
+#define                  DMA7_IRQ_STATUS  0xffc00de8   /* DMA Channel 7 Interrupt/Status Register */
+#define              DMA7_PERIPHERAL_MAP  0xffc00dec   /* DMA Channel 7 Peripheral Map Register */
+#define                DMA7_CURR_X_COUNT  0xffc00df0   /* DMA Channel 7 Current X Count Register */
+#define                DMA7_CURR_Y_COUNT  0xffc00df8   /* DMA Channel 7 Current Y Count Register */
+
+/* DMA Channel 8 Registers */
+
+#define               DMA8_NEXT_DESC_PTR  0xffc00e00   /* DMA Channel 8 Next Descriptor Pointer Register */
+#define                  DMA8_START_ADDR  0xffc00e04   /* DMA Channel 8 Start Address Register */
+#define                      DMA8_CONFIG  0xffc00e08   /* DMA Channel 8 Configuration Register */
+#define                     DMA8_X_COUNT  0xffc00e10   /* DMA Channel 8 X Count Register */
+#define                    DMA8_X_MODIFY  0xffc00e14   /* DMA Channel 8 X Modify Register */
+#define                     DMA8_Y_COUNT  0xffc00e18   /* DMA Channel 8 Y Count Register */
+#define                    DMA8_Y_MODIFY  0xffc00e1c   /* DMA Channel 8 Y Modify Register */
+#define               DMA8_CURR_DESC_PTR  0xffc00e20   /* DMA Channel 8 Current Descriptor Pointer Register */
+#define                   DMA8_CURR_ADDR  0xffc00e24   /* DMA Channel 8 Current Address Register */
+#define                  DMA8_IRQ_STATUS  0xffc00e28   /* DMA Channel 8 Interrupt/Status Register */
+#define              DMA8_PERIPHERAL_MAP  0xffc00e2c   /* DMA Channel 8 Peripheral Map Register */
+#define                DMA8_CURR_X_COUNT  0xffc00e30   /* DMA Channel 8 Current X Count Register */
+#define                DMA8_CURR_Y_COUNT  0xffc00e38   /* DMA Channel 8 Current Y Count Register */
+
+/* DMA Channel 9 Registers */
+
+#define               DMA9_NEXT_DESC_PTR  0xffc00e40   /* DMA Channel 9 Next Descriptor Pointer Register */
+#define                  DMA9_START_ADDR  0xffc00e44   /* DMA Channel 9 Start Address Register */
+#define                      DMA9_CONFIG  0xffc00e48   /* DMA Channel 9 Configuration Register */
+#define                     DMA9_X_COUNT  0xffc00e50   /* DMA Channel 9 X Count Register */
+#define                    DMA9_X_MODIFY  0xffc00e54   /* DMA Channel 9 X Modify Register */
+#define                     DMA9_Y_COUNT  0xffc00e58   /* DMA Channel 9 Y Count Register */
+#define                    DMA9_Y_MODIFY  0xffc00e5c   /* DMA Channel 9 Y Modify Register */
+#define               DMA9_CURR_DESC_PTR  0xffc00e60   /* DMA Channel 9 Current Descriptor Pointer Register */
+#define                   DMA9_CURR_ADDR  0xffc00e64   /* DMA Channel 9 Current Address Register */
+#define                  DMA9_IRQ_STATUS  0xffc00e68   /* DMA Channel 9 Interrupt/Status Register */
+#define              DMA9_PERIPHERAL_MAP  0xffc00e6c   /* DMA Channel 9 Peripheral Map Register */
+#define                DMA9_CURR_X_COUNT  0xffc00e70   /* DMA Channel 9 Current X Count Register */
+#define                DMA9_CURR_Y_COUNT  0xffc00e78   /* DMA Channel 9 Current Y Count Register */
+
+/* DMA Channel 10 Registers */
+
+#define              DMA10_NEXT_DESC_PTR  0xffc00e80   /* DMA Channel 10 Next Descriptor Pointer Register */
+#define                 DMA10_START_ADDR  0xffc00e84   /* DMA Channel 10 Start Address Register */
+#define                     DMA10_CONFIG  0xffc00e88   /* DMA Channel 10 Configuration Register */
+#define                    DMA10_X_COUNT  0xffc00e90   /* DMA Channel 10 X Count Register */
+#define                   DMA10_X_MODIFY  0xffc00e94   /* DMA Channel 10 X Modify Register */
+#define                    DMA10_Y_COUNT  0xffc00e98   /* DMA Channel 10 Y Count Register */
+#define                   DMA10_Y_MODIFY  0xffc00e9c   /* DMA Channel 10 Y Modify Register */
+#define              DMA10_CURR_DESC_PTR  0xffc00ea0   /* DMA Channel 10 Current Descriptor Pointer Register */
+#define                  DMA10_CURR_ADDR  0xffc00ea4   /* DMA Channel 10 Current Address Register */
+#define                 DMA10_IRQ_STATUS  0xffc00ea8   /* DMA Channel 10 Interrupt/Status Register */
+#define             DMA10_PERIPHERAL_MAP  0xffc00eac   /* DMA Channel 10 Peripheral Map Register */
+#define               DMA10_CURR_X_COUNT  0xffc00eb0   /* DMA Channel 10 Current X Count Register */
+#define               DMA10_CURR_Y_COUNT  0xffc00eb8   /* DMA Channel 10 Current Y Count Register */
+
+/* DMA Channel 11 Registers */
+
+#define              DMA11_NEXT_DESC_PTR  0xffc00ec0   /* DMA Channel 11 Next Descriptor Pointer Register */
+#define                 DMA11_START_ADDR  0xffc00ec4   /* DMA Channel 11 Start Address Register */
+#define                     DMA11_CONFIG  0xffc00ec8   /* DMA Channel 11 Configuration Register */
+#define                    DMA11_X_COUNT  0xffc00ed0   /* DMA Channel 11 X Count Register */
+#define                   DMA11_X_MODIFY  0xffc00ed4   /* DMA Channel 11 X Modify Register */
+#define                    DMA11_Y_COUNT  0xffc00ed8   /* DMA Channel 11 Y Count Register */
+#define                   DMA11_Y_MODIFY  0xffc00edc   /* DMA Channel 11 Y Modify Register */
+#define              DMA11_CURR_DESC_PTR  0xffc00ee0   /* DMA Channel 11 Current Descriptor Pointer Register */
+#define                  DMA11_CURR_ADDR  0xffc00ee4   /* DMA Channel 11 Current Address Register */
+#define                 DMA11_IRQ_STATUS  0xffc00ee8   /* DMA Channel 11 Interrupt/Status Register */
+#define             DMA11_PERIPHERAL_MAP  0xffc00eec   /* DMA Channel 11 Peripheral Map Register */
+#define               DMA11_CURR_X_COUNT  0xffc00ef0   /* DMA Channel 11 Current X Count Register */
+#define               DMA11_CURR_Y_COUNT  0xffc00ef8   /* DMA Channel 11 Current Y Count Register */
+
+/* MDMA Stream 0 Registers */
+
+#define            MDMA_D0_NEXT_DESC_PTR  0xffc00f00   /* Memory DMA Stream 0 Destination Next Descriptor Pointer Register */
+#define               MDMA_D0_START_ADDR  0xffc00f04   /* Memory DMA Stream 0 Destination Start Address Register */
+#define                   MDMA_D0_CONFIG  0xffc00f08   /* Memory DMA Stream 0 Destination Configuration Register */
+#define                  MDMA_D0_X_COUNT  0xffc00f10   /* Memory DMA Stream 0 Destination X Count Register */
+#define                 MDMA_D0_X_MODIFY  0xffc00f14   /* Memory DMA Stream 0 Destination X Modify Register */
+#define                  MDMA_D0_Y_COUNT  0xffc00f18   /* Memory DMA Stream 0 Destination Y Count Register */
+#define                 MDMA_D0_Y_MODIFY  0xffc00f1c   /* Memory DMA Stream 0 Destination Y Modify Register */
+#define            MDMA_D0_CURR_DESC_PTR  0xffc00f20   /* Memory DMA Stream 0 Destination Current Descriptor Pointer Register */
+#define                MDMA_D0_CURR_ADDR  0xffc00f24   /* Memory DMA Stream 0 Destination Current Address Register */
+#define               MDMA_D0_IRQ_STATUS  0xffc00f28   /* Memory DMA Stream 0 Destination Interrupt/Status Register */
+#define           MDMA_D0_PERIPHERAL_MAP  0xffc00f2c   /* Memory DMA Stream 0 Destination Peripheral Map Register */
+#define             MDMA_D0_CURR_X_COUNT  0xffc00f30   /* Memory DMA Stream 0 Destination Current X Count Register */
+#define             MDMA_D0_CURR_Y_COUNT  0xffc00f38   /* Memory DMA Stream 0 Destination Current Y Count Register */
+#define            MDMA_S0_NEXT_DESC_PTR  0xffc00f40   /* Memory DMA Stream 0 Source Next Descriptor Pointer Register */
+#define               MDMA_S0_START_ADDR  0xffc00f44   /* Memory DMA Stream 0 Source Start Address Register */
+#define                   MDMA_S0_CONFIG  0xffc00f48   /* Memory DMA Stream 0 Source Configuration Register */
+#define                  MDMA_S0_X_COUNT  0xffc00f50   /* Memory DMA Stream 0 Source X Count Register */
+#define                 MDMA_S0_X_MODIFY  0xffc00f54   /* Memory DMA Stream 0 Source X Modify Register */
+#define                  MDMA_S0_Y_COUNT  0xffc00f58   /* Memory DMA Stream 0 Source Y Count Register */
+#define                 MDMA_S0_Y_MODIFY  0xffc00f5c   /* Memory DMA Stream 0 Source Y Modify Register */
+#define            MDMA_S0_CURR_DESC_PTR  0xffc00f60   /* Memory DMA Stream 0 Source Current Descriptor Pointer Register */
+#define                MDMA_S0_CURR_ADDR  0xffc00f64   /* Memory DMA Stream 0 Source Current Address Register */
+#define               MDMA_S0_IRQ_STATUS  0xffc00f68   /* Memory DMA Stream 0 Source Interrupt/Status Register */
+#define           MDMA_S0_PERIPHERAL_MAP  0xffc00f6c   /* Memory DMA Stream 0 Source Peripheral Map Register */
+#define             MDMA_S0_CURR_X_COUNT  0xffc00f70   /* Memory DMA Stream 0 Source Current X Count Register */
+#define             MDMA_S0_CURR_Y_COUNT  0xffc00f78   /* Memory DMA Stream 0 Source Current Y Count Register */
+
+/* MDMA Stream 1 Registers */
+
+#define            MDMA_D1_NEXT_DESC_PTR  0xffc00f80   /* Memory DMA Stream 1 Destination Next Descriptor Pointer Register */
+#define               MDMA_D1_START_ADDR  0xffc00f84   /* Memory DMA Stream 1 Destination Start Address Register */
+#define                   MDMA_D1_CONFIG  0xffc00f88   /* Memory DMA Stream 1 Destination Configuration Register */
+#define                  MDMA_D1_X_COUNT  0xffc00f90   /* Memory DMA Stream 1 Destination X Count Register */
+#define                 MDMA_D1_X_MODIFY  0xffc00f94   /* Memory DMA Stream 1 Destination X Modify Register */
+#define                  MDMA_D1_Y_COUNT  0xffc00f98   /* Memory DMA Stream 1 Destination Y Count Register */
+#define                 MDMA_D1_Y_MODIFY  0xffc00f9c   /* Memory DMA Stream 1 Destination Y Modify Register */
+#define            MDMA_D1_CURR_DESC_PTR  0xffc00fa0   /* Memory DMA Stream 1 Destination Current Descriptor Pointer Register */
+#define                MDMA_D1_CURR_ADDR  0xffc00fa4   /* Memory DMA Stream 1 Destination Current Address Register */
+#define               MDMA_D1_IRQ_STATUS  0xffc00fa8   /* Memory DMA Stream 1 Destination Interrupt/Status Register */
+#define           MDMA_D1_PERIPHERAL_MAP  0xffc00fac   /* Memory DMA Stream 1 Destination Peripheral Map Register */
+#define             MDMA_D1_CURR_X_COUNT  0xffc00fb0   /* Memory DMA Stream 1 Destination Current X Count Register */
+#define             MDMA_D1_CURR_Y_COUNT  0xffc00fb8   /* Memory DMA Stream 1 Destination Current Y Count Register */
+#define            MDMA_S1_NEXT_DESC_PTR  0xffc00fc0   /* Memory DMA Stream 1 Source Next Descriptor Pointer Register */
+#define               MDMA_S1_START_ADDR  0xffc00fc4   /* Memory DMA Stream 1 Source Start Address Register */
+#define                   MDMA_S1_CONFIG  0xffc00fc8   /* Memory DMA Stream 1 Source Configuration Register */
+#define                  MDMA_S1_X_COUNT  0xffc00fd0   /* Memory DMA Stream 1 Source X Count Register */
+#define                 MDMA_S1_X_MODIFY  0xffc00fd4   /* Memory DMA Stream 1 Source X Modify Register */
+#define                  MDMA_S1_Y_COUNT  0xffc00fd8   /* Memory DMA Stream 1 Source Y Count Register */
+#define                 MDMA_S1_Y_MODIFY  0xffc00fdc   /* Memory DMA Stream 1 Source Y Modify Register */
+#define            MDMA_S1_CURR_DESC_PTR  0xffc00fe0   /* Memory DMA Stream 1 Source Current Descriptor Pointer Register */
+#define                MDMA_S1_CURR_ADDR  0xffc00fe4   /* Memory DMA Stream 1 Source Current Address Register */
+#define               MDMA_S1_IRQ_STATUS  0xffc00fe8   /* Memory DMA Stream 1 Source Interrupt/Status Register */
+#define           MDMA_S1_PERIPHERAL_MAP  0xffc00fec   /* Memory DMA Stream 1 Source Peripheral Map Register */
+#define             MDMA_S1_CURR_X_COUNT  0xffc00ff0   /* Memory DMA Stream 1 Source Current X Count Register */
+#define             MDMA_S1_CURR_Y_COUNT  0xffc00ff8   /* Memory DMA Stream 1 Source Current Y Count Register */
+
+/* UART3 Registers */
+
+#define                        UART3_DLL  0xffc03100   /* Divisor Latch Low Byte */
+#define                        UART3_DLH  0xffc03104   /* Divisor Latch High Byte */
+#define                       UART3_GCTL  0xffc03108   /* Global Control Register */
+#define                        UART3_LCR  0xffc0310c   /* Line Control Register */
+#define                        UART3_MCR  0xffc03110   /* Modem Control Register */
+#define                        UART3_LSR  0xffc03114   /* Line Status Register */
+#define                        UART3_MSR  0xffc03118   /* Modem Status Register */
+#define                        UART3_SCR  0xffc0311c   /* Scratch Register */
+#define                    UART3_IER_SET  0xffc03120   /* Interrupt Enable Register Set */
+#define                  UART3_IER_CLEAR  0xffc03124   /* Interrupt Enable Register Clear */
+#define                        UART3_THR  0xffc03128   /* Transmit Hold Register */
+#define                        UART3_RBR  0xffc0312c   /* Receive Buffer Register */
+
+/* EPPI1 Registers */
+
+#define                     EPPI1_STATUS  0xffc01300   /* EPPI1 Status Register */
+#define                     EPPI1_HCOUNT  0xffc01304   /* EPPI1 Horizontal Transfer Count Register */
+#define                     EPPI1_HDELAY  0xffc01308   /* EPPI1 Horizontal Delay Count Register */
+#define                     EPPI1_VCOUNT  0xffc0130c   /* EPPI1 Vertical Transfer Count Register */
+#define                     EPPI1_VDELAY  0xffc01310   /* EPPI1 Vertical Delay Count Register */
+#define                      EPPI1_FRAME  0xffc01314   /* EPPI1 Lines per Frame Register */
+#define                       EPPI1_LINE  0xffc01318   /* EPPI1 Samples per Line Register */
+#define                     EPPI1_CLKDIV  0xffc0131c   /* EPPI1 Clock Divide Register */
+#define                    EPPI1_CONTROL  0xffc01320   /* EPPI1 Control Register */
+#define                   EPPI1_FS1W_HBL  0xffc01324   /* EPPI1 FS1 Width Register / EPPI1 Horizontal Blanking Samples Per Line Register */
+#define                  EPPI1_FS1P_AVPL  0xffc01328   /* EPPI1 FS1 Period Register / EPPI1 Active Video Samples Per Line Register */
+#define                   EPPI1_FS2W_LVB  0xffc0132c   /* EPPI1 FS2 Width Register / EPPI1 Lines of Vertical Blanking Register */
+#define                  EPPI1_FS2P_LAVF  0xffc01330   /* EPPI1 FS2 Period Register/ EPPI1 Lines of Active Video Per Field Register */
+#define                       EPPI1_CLIP  0xffc01334   /* EPPI1 Clipping Register */
+
+/* Port Interrupt 0 Registers (32-bit) */
+
+#define                   PINT0_MASK_SET  0xffc01400   /* Pin Interrupt 0 Mask Set Register */
+#define                 PINT0_MASK_CLEAR  0xffc01404   /* Pin Interrupt 0 Mask Clear Register */
+#define                    PINT0_REQUEST  0xffc01408   /* Pin Interrupt 0 Interrupt Request Register */
+#define                     PINT0_ASSIGN  0xffc0140c   /* Pin Interrupt 0 Port Assign Register */
+#define                   PINT0_EDGE_SET  0xffc01410   /* Pin Interrupt 0 Edge-sensitivity Set Register */
+#define                 PINT0_EDGE_CLEAR  0xffc01414   /* Pin Interrupt 0 Edge-sensitivity Clear Register */
+#define                 PINT0_INVERT_SET  0xffc01418   /* Pin Interrupt 0 Inversion Set Register */
+#define               PINT0_INVERT_CLEAR  0xffc0141c   /* Pin Interrupt 0 Inversion Clear Register */
+#define                   PINT0_PINSTATE  0xffc01420   /* Pin Interrupt 0 Pin Status Register */
+#define                      PINT0_LATCH  0xffc01424   /* Pin Interrupt 0 Latch Register */
+
+/* Port Interrupt 1 Registers (32-bit) */
+
+#define                   PINT1_MASK_SET  0xffc01430   /* Pin Interrupt 1 Mask Set Register */
+#define                 PINT1_MASK_CLEAR  0xffc01434   /* Pin Interrupt 1 Mask Clear Register */
+#define                    PINT1_REQUEST  0xffc01438   /* Pin Interrupt 1 Interrupt Request Register */
+#define                     PINT1_ASSIGN  0xffc0143c   /* Pin Interrupt 1 Port Assign Register */
+#define                   PINT1_EDGE_SET  0xffc01440   /* Pin Interrupt 1 Edge-sensitivity Set Register */
+#define                 PINT1_EDGE_CLEAR  0xffc01444   /* Pin Interrupt 1 Edge-sensitivity Clear Register */
+#define                 PINT1_INVERT_SET  0xffc01448   /* Pin Interrupt 1 Inversion Set Register */
+#define               PINT1_INVERT_CLEAR  0xffc0144c   /* Pin Interrupt 1 Inversion Clear Register */
+#define                   PINT1_PINSTATE  0xffc01450   /* Pin Interrupt 1 Pin Status Register */
+#define                      PINT1_LATCH  0xffc01454   /* Pin Interrupt 1 Latch Register */
+
+/* Port Interrupt 2 Registers (32-bit) */
+
+#define                   PINT2_MASK_SET  0xffc01460   /* Pin Interrupt 2 Mask Set Register */
+#define                 PINT2_MASK_CLEAR  0xffc01464   /* Pin Interrupt 2 Mask Clear Register */
+#define                    PINT2_REQUEST  0xffc01468   /* Pin Interrupt 2 Interrupt Request Register */
+#define                     PINT2_ASSIGN  0xffc0146c   /* Pin Interrupt 2 Port Assign Register */
+#define                   PINT2_EDGE_SET  0xffc01470   /* Pin Interrupt 2 Edge-sensitivity Set Register */
+#define                 PINT2_EDGE_CLEAR  0xffc01474   /* Pin Interrupt 2 Edge-sensitivity Clear Register */
+#define                 PINT2_INVERT_SET  0xffc01478   /* Pin Interrupt 2 Inversion Set Register */
+#define               PINT2_INVERT_CLEAR  0xffc0147c   /* Pin Interrupt 2 Inversion Clear Register */
+#define                   PINT2_PINSTATE  0xffc01480   /* Pin Interrupt 2 Pin Status Register */
+#define                      PINT2_LATCH  0xffc01484   /* Pin Interrupt 2 Latch Register */
+
+/* Port Interrupt 3 Registers (32-bit) */
+
+#define                   PINT3_MASK_SET  0xffc01490   /* Pin Interrupt 3 Mask Set Register */
+#define                 PINT3_MASK_CLEAR  0xffc01494   /* Pin Interrupt 3 Mask Clear Register */
+#define                    PINT3_REQUEST  0xffc01498   /* Pin Interrupt 3 Interrupt Request Register */
+#define                     PINT3_ASSIGN  0xffc0149c   /* Pin Interrupt 3 Port Assign Register */
+#define                   PINT3_EDGE_SET  0xffc014a0   /* Pin Interrupt 3 Edge-sensitivity Set Register */
+#define                 PINT3_EDGE_CLEAR  0xffc014a4   /* Pin Interrupt 3 Edge-sensitivity Clear Register */
+#define                 PINT3_INVERT_SET  0xffc014a8   /* Pin Interrupt 3 Inversion Set Register */
+#define               PINT3_INVERT_CLEAR  0xffc014ac   /* Pin Interrupt 3 Inversion Clear Register */
+#define                   PINT3_PINSTATE  0xffc014b0   /* Pin Interrupt 3 Pin Status Register */
+#define                      PINT3_LATCH  0xffc014b4   /* Pin Interrupt 3 Latch Register */
+
+/* Port A Registers */
+
+#define                        PORTA_FER  0xffc014c0   /* Function Enable Register */
+#define                            PORTA  0xffc014c4   /* GPIO Data Register */
+#define                        PORTA_SET  0xffc014c8   /* GPIO Data Set Register */
+#define                      PORTA_CLEAR  0xffc014cc   /* GPIO Data Clear Register */
+#define                    PORTA_DIR_SET  0xffc014d0   /* GPIO Direction Set Register */
+#define                  PORTA_DIR_CLEAR  0xffc014d4   /* GPIO Direction Clear Register */
+#define                       PORTA_INEN  0xffc014d8   /* GPIO Input Enable Register */
+#define                        PORTA_MUX  0xffc014dc   /* Multiplexer Control Register */
+
+/* Port B Registers */
+
+#define                        PORTB_FER  0xffc014e0   /* Function Enable Register */
+#define                            PORTB  0xffc014e4   /* GPIO Data Register */
+#define                        PORTB_SET  0xffc014e8   /* GPIO Data Set Register */
+#define                      PORTB_CLEAR  0xffc014ec   /* GPIO Data Clear Register */
+#define                    PORTB_DIR_SET  0xffc014f0   /* GPIO Direction Set Register */
+#define                  PORTB_DIR_CLEAR  0xffc014f4   /* GPIO Direction Clear Register */
+#define                       PORTB_INEN  0xffc014f8   /* GPIO Input Enable Register */
+#define                        PORTB_MUX  0xffc014fc   /* Multiplexer Control Register */
+
+/* Port C Registers */
+
+#define                        PORTC_FER  0xffc01500   /* Function Enable Register */
+#define                            PORTC  0xffc01504   /* GPIO Data Register */
+#define                        PORTC_SET  0xffc01508   /* GPIO Data Set Register */
+#define                      PORTC_CLEAR  0xffc0150c   /* GPIO Data Clear Register */
+#define                    PORTC_DIR_SET  0xffc01510   /* GPIO Direction Set Register */
+#define                  PORTC_DIR_CLEAR  0xffc01514   /* GPIO Direction Clear Register */
+#define                       PORTC_INEN  0xffc01518   /* GPIO Input Enable Register */
+#define                        PORTC_MUX  0xffc0151c   /* Multiplexer Control Register */
+
+/* Port D Registers */
+
+#define                        PORTD_FER  0xffc01520   /* Function Enable Register */
+#define                            PORTD  0xffc01524   /* GPIO Data Register */
+#define                        PORTD_SET  0xffc01528   /* GPIO Data Set Register */
+#define                      PORTD_CLEAR  0xffc0152c   /* GPIO Data Clear Register */
+#define                    PORTD_DIR_SET  0xffc01530   /* GPIO Direction Set Register */
+#define                  PORTD_DIR_CLEAR  0xffc01534   /* GPIO Direction Clear Register */
+#define                       PORTD_INEN  0xffc01538   /* GPIO Input Enable Register */
+#define                        PORTD_MUX  0xffc0153c   /* Multiplexer Control Register */
+
+/* Port E Registers */
+
+#define                        PORTE_FER  0xffc01540   /* Function Enable Register */
+#define                            PORTE  0xffc01544   /* GPIO Data Register */
+#define                        PORTE_SET  0xffc01548   /* GPIO Data Set Register */
+#define                      PORTE_CLEAR  0xffc0154c   /* GPIO Data Clear Register */
+#define                    PORTE_DIR_SET  0xffc01550   /* GPIO Direction Set Register */
+#define                  PORTE_DIR_CLEAR  0xffc01554   /* GPIO Direction Clear Register */
+#define                       PORTE_INEN  0xffc01558   /* GPIO Input Enable Register */
+#define                        PORTE_MUX  0xffc0155c   /* Multiplexer Control Register */
+
+/* Port F Registers */
+
+#define                        PORTF_FER  0xffc01560   /* Function Enable Register */
+#define                            PORTF  0xffc01564   /* GPIO Data Register */
+#define                        PORTF_SET  0xffc01568   /* GPIO Data Set Register */
+#define                      PORTF_CLEAR  0xffc0156c   /* GPIO Data Clear Register */
+#define                    PORTF_DIR_SET  0xffc01570   /* GPIO Direction Set Register */
+#define                  PORTF_DIR_CLEAR  0xffc01574   /* GPIO Direction Clear Register */
+#define                       PORTF_INEN  0xffc01578   /* GPIO Input Enable Register */
+#define                        PORTF_MUX  0xffc0157c   /* Multiplexer Control Register */
+
+/* Port G Registers */
+
+#define                        PORTG_FER  0xffc01580   /* Function Enable Register */
+#define                            PORTG  0xffc01584   /* GPIO Data Register */
+#define                        PORTG_SET  0xffc01588   /* GPIO Data Set Register */
+#define                      PORTG_CLEAR  0xffc0158c   /* GPIO Data Clear Register */
+#define                    PORTG_DIR_SET  0xffc01590   /* GPIO Direction Set Register */
+#define                  PORTG_DIR_CLEAR  0xffc01594   /* GPIO Direction Clear Register */
+#define                       PORTG_INEN  0xffc01598   /* GPIO Input Enable Register */
+#define                        PORTG_MUX  0xffc0159c   /* Multiplexer Control Register */
+
+/* Port H Registers */
+
+#define                        PORTH_FER  0xffc015a0   /* Function Enable Register */
+#define                            PORTH  0xffc015a4   /* GPIO Data Register */
+#define                        PORTH_SET  0xffc015a8   /* GPIO Data Set Register */
+#define                      PORTH_CLEAR  0xffc015ac   /* GPIO Data Clear Register */
+#define                    PORTH_DIR_SET  0xffc015b0   /* GPIO Direction Set Register */
+#define                  PORTH_DIR_CLEAR  0xffc015b4   /* GPIO Direction Clear Register */
+#define                       PORTH_INEN  0xffc015b8   /* GPIO Input Enable Register */
+#define                        PORTH_MUX  0xffc015bc   /* Multiplexer Control Register */
+
+/* Port I Registers */
+
+#define                        PORTI_FER  0xffc015c0   /* Function Enable Register */
+#define                            PORTI  0xffc015c4   /* GPIO Data Register */
+#define                        PORTI_SET  0xffc015c8   /* GPIO Data Set Register */
+#define                      PORTI_CLEAR  0xffc015cc   /* GPIO Data Clear Register */
+#define                    PORTI_DIR_SET  0xffc015d0   /* GPIO Direction Set Register */
+#define                  PORTI_DIR_CLEAR  0xffc015d4   /* GPIO Direction Clear Register */
+#define                       PORTI_INEN  0xffc015d8   /* GPIO Input Enable Register */
+#define                        PORTI_MUX  0xffc015dc   /* Multiplexer Control Register */
+
+/* Port J Registers */
+
+#define                        PORTJ_FER  0xffc015e0   /* Function Enable Register */
+#define                            PORTJ  0xffc015e4   /* GPIO Data Register */
+#define                        PORTJ_SET  0xffc015e8   /* GPIO Data Set Register */
+#define                      PORTJ_CLEAR  0xffc015ec   /* GPIO Data Clear Register */
+#define                    PORTJ_DIR_SET  0xffc015f0   /* GPIO Direction Set Register */
+#define                  PORTJ_DIR_CLEAR  0xffc015f4   /* GPIO Direction Clear Register */
+#define                       PORTJ_INEN  0xffc015f8   /* GPIO Input Enable Register */
+#define                        PORTJ_MUX  0xffc015fc   /* Multiplexer Control Register */
+
+/* PWM Timer Registers */
+
+#define                    TIMER0_CONFIG  0xffc01600   /* Timer 0 Configuration Register */
+#define                   TIMER0_COUNTER  0xffc01604   /* Timer 0 Counter Register */
+#define                    TIMER0_PERIOD  0xffc01608   /* Timer 0 Period Register */
+#define                     TIMER0_WIDTH  0xffc0160c   /* Timer 0 Width Register */
+#define                    TIMER1_CONFIG  0xffc01610   /* Timer 1 Configuration Register */
+#define                   TIMER1_COUNTER  0xffc01614   /* Timer 1 Counter Register */
+#define                    TIMER1_PERIOD  0xffc01618   /* Timer 1 Period Register */
+#define                     TIMER1_WIDTH  0xffc0161c   /* Timer 1 Width Register */
+#define                    TIMER2_CONFIG  0xffc01620   /* Timer 2 Configuration Register */
+#define                   TIMER2_COUNTER  0xffc01624   /* Timer 2 Counter Register */
+#define                    TIMER2_PERIOD  0xffc01628   /* Timer 2 Period Register */
+#define                     TIMER2_WIDTH  0xffc0162c   /* Timer 2 Width Register */
+#define                    TIMER3_CONFIG  0xffc01630   /* Timer 3 Configuration Register */
+#define                   TIMER3_COUNTER  0xffc01634   /* Timer 3 Counter Register */
+#define                    TIMER3_PERIOD  0xffc01638   /* Timer 3 Period Register */
+#define                     TIMER3_WIDTH  0xffc0163c   /* Timer 3 Width Register */
+#define                    TIMER4_CONFIG  0xffc01640   /* Timer 4 Configuration Register */
+#define                   TIMER4_COUNTER  0xffc01644   /* Timer 4 Counter Register */
+#define                    TIMER4_PERIOD  0xffc01648   /* Timer 4 Period Register */
+#define                     TIMER4_WIDTH  0xffc0164c   /* Timer 4 Width Register */
+#define                    TIMER5_CONFIG  0xffc01650   /* Timer 5 Configuration Register */
+#define                   TIMER5_COUNTER  0xffc01654   /* Timer 5 Counter Register */
+#define                    TIMER5_PERIOD  0xffc01658   /* Timer 5 Period Register */
+#define                     TIMER5_WIDTH  0xffc0165c   /* Timer 5 Width Register */
+#define                    TIMER6_CONFIG  0xffc01660   /* Timer 6 Configuration Register */
+#define                   TIMER6_COUNTER  0xffc01664   /* Timer 6 Counter Register */
+#define                    TIMER6_PERIOD  0xffc01668   /* Timer 6 Period Register */
+#define                     TIMER6_WIDTH  0xffc0166c   /* Timer 6 Width Register */
+#define                    TIMER7_CONFIG  0xffc01670   /* Timer 7 Configuration Register */
+#define                   TIMER7_COUNTER  0xffc01674   /* Timer 7 Counter Register */
+#define                    TIMER7_PERIOD  0xffc01678   /* Timer 7 Period Register */
+#define                     TIMER7_WIDTH  0xffc0167c   /* Timer 7 Width Register */
+
+/* Timer Group of 8 */
+
+#define                    TIMER_ENABLE0  0xffc01680   /* Timer Group of 8 Enable Register */
+#define                   TIMER_DISABLE0  0xffc01684   /* Timer Group of 8 Disable Register */
+#define                    TIMER_STATUS0  0xffc01688   /* Timer Group of 8 Status Register */
+
+/* DMAC1 Registers */
+
+#define                      DMAC1_TCPER  0xffc01b0c   /* DMA Controller 1 Traffic Control Periods Register */
+#define                      DMAC1_TCCNT  0xffc01b10   /* DMA Controller 1 Current Counts Register */
+
+/* DMA Channel 12 Registers */
+
+#define              DMA12_NEXT_DESC_PTR  0xffc01c00   /* DMA Channel 12 Next Descriptor Pointer Register */
+#define                 DMA12_START_ADDR  0xffc01c04   /* DMA Channel 12 Start Address Register */
+#define                     DMA12_CONFIG  0xffc01c08   /* DMA Channel 12 Configuration Register */
+#define                    DMA12_X_COUNT  0xffc01c10   /* DMA Channel 12 X Count Register */
+#define                   DMA12_X_MODIFY  0xffc01c14   /* DMA Channel 12 X Modify Register */
+#define                    DMA12_Y_COUNT  0xffc01c18   /* DMA Channel 12 Y Count Register */
+#define                   DMA12_Y_MODIFY  0xffc01c1c   /* DMA Channel 12 Y Modify Register */
+#define              DMA12_CURR_DESC_PTR  0xffc01c20   /* DMA Channel 12 Current Descriptor Pointer Register */
+#define                  DMA12_CURR_ADDR  0xffc01c24   /* DMA Channel 12 Current Address Register */
+#define                 DMA12_IRQ_STATUS  0xffc01c28   /* DMA Channel 12 Interrupt/Status Register */
+#define             DMA12_PERIPHERAL_MAP  0xffc01c2c   /* DMA Channel 12 Peripheral Map Register */
+#define               DMA12_CURR_X_COUNT  0xffc01c30   /* DMA Channel 12 Current X Count Register */
+#define               DMA12_CURR_Y_COUNT  0xffc01c38   /* DMA Channel 12 Current Y Count Register */
+
+/* DMA Channel 13 Registers */
+
+#define              DMA13_NEXT_DESC_PTR  0xffc01c40   /* DMA Channel 13 Next Descriptor Pointer Register */
+#define                 DMA13_START_ADDR  0xffc01c44   /* DMA Channel 13 Start Address Register */
+#define                     DMA13_CONFIG  0xffc01c48   /* DMA Channel 13 Configuration Register */
+#define                    DMA13_X_COUNT  0xffc01c50   /* DMA Channel 13 X Count Register */
+#define                   DMA13_X_MODIFY  0xffc01c54   /* DMA Channel 13 X Modify Register */
+#define                    DMA13_Y_COUNT  0xffc01c58   /* DMA Channel 13 Y Count Register */
+#define                   DMA13_Y_MODIFY  0xffc01c5c   /* DMA Channel 13 Y Modify Register */
+#define              DMA13_CURR_DESC_PTR  0xffc01c60   /* DMA Channel 13 Current Descriptor Pointer Register */
+#define                  DMA13_CURR_ADDR  0xffc01c64   /* DMA Channel 13 Current Address Register */
+#define                 DMA13_IRQ_STATUS  0xffc01c68   /* DMA Channel 13 Interrupt/Status Register */
+#define             DMA13_PERIPHERAL_MAP  0xffc01c6c   /* DMA Channel 13 Peripheral Map Register */
+#define               DMA13_CURR_X_COUNT  0xffc01c70   /* DMA Channel 13 Current X Count Register */
+#define               DMA13_CURR_Y_COUNT  0xffc01c78   /* DMA Channel 13 Current Y Count Register */
+
+/* DMA Channel 14 Registers */
+
+#define              DMA14_NEXT_DESC_PTR  0xffc01c80   /* DMA Channel 14 Next Descriptor Pointer Register */
+#define                 DMA14_START_ADDR  0xffc01c84   /* DMA Channel 14 Start Address Register */
+#define                     DMA14_CONFIG  0xffc01c88   /* DMA Channel 14 Configuration Register */
+#define                    DMA14_X_COUNT  0xffc01c90   /* DMA Channel 14 X Count Register */
+#define                   DMA14_X_MODIFY  0xffc01c94   /* DMA Channel 14 X Modify Register */
+#define                    DMA14_Y_COUNT  0xffc01c98   /* DMA Channel 14 Y Count Register */
+#define                   DMA14_Y_MODIFY  0xffc01c9c   /* DMA Channel 14 Y Modify Register */
+#define              DMA14_CURR_DESC_PTR  0xffc01ca0   /* DMA Channel 14 Current Descriptor Pointer Register */
+#define                  DMA14_CURR_ADDR  0xffc01ca4   /* DMA Channel 14 Current Address Register */
+#define                 DMA14_IRQ_STATUS  0xffc01ca8   /* DMA Channel 14 Interrupt/Status Register */
+#define             DMA14_PERIPHERAL_MAP  0xffc01cac   /* DMA Channel 14 Peripheral Map Register */
+#define               DMA14_CURR_X_COUNT  0xffc01cb0   /* DMA Channel 14 Current X Count Register */
+#define               DMA14_CURR_Y_COUNT  0xffc01cb8   /* DMA Channel 14 Current Y Count Register */
+
+/* DMA Channel 15 Registers */
+
+#define              DMA15_NEXT_DESC_PTR  0xffc01cc0   /* DMA Channel 15 Next Descriptor Pointer Register */
+#define                 DMA15_START_ADDR  0xffc01cc4   /* DMA Channel 15 Start Address Register */
+#define                     DMA15_CONFIG  0xffc01cc8   /* DMA Channel 15 Configuration Register */
+#define                    DMA15_X_COUNT  0xffc01cd0   /* DMA Channel 15 X Count Register */
+#define                   DMA15_X_MODIFY  0xffc01cd4   /* DMA Channel 15 X Modify Register */
+#define                    DMA15_Y_COUNT  0xffc01cd8   /* DMA Channel 15 Y Count Register */
+#define                   DMA15_Y_MODIFY  0xffc01cdc   /* DMA Channel 15 Y Modify Register */
+#define              DMA15_CURR_DESC_PTR  0xffc01ce0   /* DMA Channel 15 Current Descriptor Pointer Register */
+#define                  DMA15_CURR_ADDR  0xffc01ce4   /* DMA Channel 15 Current Address Register */
+#define                 DMA15_IRQ_STATUS  0xffc01ce8   /* DMA Channel 15 Interrupt/Status Register */
+#define             DMA15_PERIPHERAL_MAP  0xffc01cec   /* DMA Channel 15 Peripheral Map Register */
+#define               DMA15_CURR_X_COUNT  0xffc01cf0   /* DMA Channel 15 Current X Count Register */
+#define               DMA15_CURR_Y_COUNT  0xffc01cf8   /* DMA Channel 15 Current Y Count Register */
+
+/* DMA Channel 16 Registers */
+
+#define              DMA16_NEXT_DESC_PTR  0xffc01d00   /* DMA Channel 16 Next Descriptor Pointer Register */
+#define                 DMA16_START_ADDR  0xffc01d04   /* DMA Channel 16 Start Address Register */
+#define                     DMA16_CONFIG  0xffc01d08   /* DMA Channel 16 Configuration Register */
+#define                    DMA16_X_COUNT  0xffc01d10   /* DMA Channel 16 X Count Register */
+#define                   DMA16_X_MODIFY  0xffc01d14   /* DMA Channel 16 X Modify Register */
+#define                    DMA16_Y_COUNT  0xffc01d18   /* DMA Channel 16 Y Count Register */
+#define                   DMA16_Y_MODIFY  0xffc01d1c   /* DMA Channel 16 Y Modify Register */
+#define              DMA16_CURR_DESC_PTR  0xffc01d20   /* DMA Channel 16 Current Descriptor Pointer Register */
+#define                  DMA16_CURR_ADDR  0xffc01d24   /* DMA Channel 16 Current Address Register */
+#define                 DMA16_IRQ_STATUS  0xffc01d28   /* DMA Channel 16 Interrupt/Status Register */
+#define             DMA16_PERIPHERAL_MAP  0xffc01d2c   /* DMA Channel 16 Peripheral Map Register */
+#define               DMA16_CURR_X_COUNT  0xffc01d30   /* DMA Channel 16 Current X Count Register */
+#define               DMA16_CURR_Y_COUNT  0xffc01d38   /* DMA Channel 16 Current Y Count Register */
+
+/* DMA Channel 17 Registers */
+
+#define              DMA17_NEXT_DESC_PTR  0xffc01d40   /* DMA Channel 17 Next Descriptor Pointer Register */
+#define                 DMA17_START_ADDR  0xffc01d44   /* DMA Channel 17 Start Address Register */
+#define                     DMA17_CONFIG  0xffc01d48   /* DMA Channel 17 Configuration Register */
+#define                    DMA17_X_COUNT  0xffc01d50   /* DMA Channel 17 X Count Register */
+#define                   DMA17_X_MODIFY  0xffc01d54   /* DMA Channel 17 X Modify Register */
+#define                    DMA17_Y_COUNT  0xffc01d58   /* DMA Channel 17 Y Count Register */
+#define                   DMA17_Y_MODIFY  0xffc01d5c   /* DMA Channel 17 Y Modify Register */
+#define              DMA17_CURR_DESC_PTR  0xffc01d60   /* DMA Channel 17 Current Descriptor Pointer Register */
+#define                  DMA17_CURR_ADDR  0xffc01d64   /* DMA Channel 17 Current Address Register */
+#define                 DMA17_IRQ_STATUS  0xffc01d68   /* DMA Channel 17 Interrupt/Status Register */
+#define             DMA17_PERIPHERAL_MAP  0xffc01d6c   /* DMA Channel 17 Peripheral Map Register */
+#define               DMA17_CURR_X_COUNT  0xffc01d70   /* DMA Channel 17 Current X Count Register */
+#define               DMA17_CURR_Y_COUNT  0xffc01d78   /* DMA Channel 17 Current Y Count Register */
+
+/* DMA Channel 18 Registers */
+
+#define              DMA18_NEXT_DESC_PTR  0xffc01d80   /* DMA Channel 18 Next Descriptor Pointer Register */
+#define                 DMA18_START_ADDR  0xffc01d84   /* DMA Channel 18 Start Address Register */
+#define                     DMA18_CONFIG  0xffc01d88   /* DMA Channel 18 Configuration Register */
+#define                    DMA18_X_COUNT  0xffc01d90   /* DMA Channel 18 X Count Register */
+#define                   DMA18_X_MODIFY  0xffc01d94   /* DMA Channel 18 X Modify Register */
+#define                    DMA18_Y_COUNT  0xffc01d98   /* DMA Channel 18 Y Count Register */
+#define                   DMA18_Y_MODIFY  0xffc01d9c   /* DMA Channel 18 Y Modify Register */
+#define              DMA18_CURR_DESC_PTR  0xffc01da0   /* DMA Channel 18 Current Descriptor Pointer Register */
+#define                  DMA18_CURR_ADDR  0xffc01da4   /* DMA Channel 18 Current Address Register */
+#define                 DMA18_IRQ_STATUS  0xffc01da8   /* DMA Channel 18 Interrupt/Status Register */
+#define             DMA18_PERIPHERAL_MAP  0xffc01dac   /* DMA Channel 18 Peripheral Map Register */
+#define               DMA18_CURR_X_COUNT  0xffc01db0   /* DMA Channel 18 Current X Count Register */
+#define               DMA18_CURR_Y_COUNT  0xffc01db8   /* DMA Channel 18 Current Y Count Register */
+
+/* DMA Channel 19 Registers */
+
+#define              DMA19_NEXT_DESC_PTR  0xffc01dc0   /* DMA Channel 19 Next Descriptor Pointer Register */
+#define                 DMA19_START_ADDR  0xffc01dc4   /* DMA Channel 19 Start Address Register */
+#define                     DMA19_CONFIG  0xffc01dc8   /* DMA Channel 19 Configuration Register */
+#define                    DMA19_X_COUNT  0xffc01dd0   /* DMA Channel 19 X Count Register */
+#define                   DMA19_X_MODIFY  0xffc01dd4   /* DMA Channel 19 X Modify Register */
+#define                    DMA19_Y_COUNT  0xffc01dd8   /* DMA Channel 19 Y Count Register */
+#define                   DMA19_Y_MODIFY  0xffc01ddc   /* DMA Channel 19 Y Modify Register */
+#define              DMA19_CURR_DESC_PTR  0xffc01de0   /* DMA Channel 19 Current Descriptor Pointer Register */
+#define                  DMA19_CURR_ADDR  0xffc01de4   /* DMA Channel 19 Current Address Register */
+#define                 DMA19_IRQ_STATUS  0xffc01de8   /* DMA Channel 19 Interrupt/Status Register */
+#define             DMA19_PERIPHERAL_MAP  0xffc01dec   /* DMA Channel 19 Peripheral Map Register */
+#define               DMA19_CURR_X_COUNT  0xffc01df0   /* DMA Channel 19 Current X Count Register */
+#define               DMA19_CURR_Y_COUNT  0xffc01df8   /* DMA Channel 19 Current Y Count Register */
+
+/* DMA Channel 20 Registers */
+
+#define              DMA20_NEXT_DESC_PTR  0xffc01e00   /* DMA Channel 20 Next Descriptor Pointer Register */
+#define                 DMA20_START_ADDR  0xffc01e04   /* DMA Channel 20 Start Address Register */
+#define                     DMA20_CONFIG  0xffc01e08   /* DMA Channel 20 Configuration Register */
+#define                    DMA20_X_COUNT  0xffc01e10   /* DMA Channel 20 X Count Register */
+#define                   DMA20_X_MODIFY  0xffc01e14   /* DMA Channel 20 X Modify Register */
+#define                    DMA20_Y_COUNT  0xffc01e18   /* DMA Channel 20 Y Count Register */
+#define                   DMA20_Y_MODIFY  0xffc01e1c   /* DMA Channel 20 Y Modify Register */
+#define              DMA20_CURR_DESC_PTR  0xffc01e20   /* DMA Channel 20 Current Descriptor Pointer Register */
+#define                  DMA20_CURR_ADDR  0xffc01e24   /* DMA Channel 20 Current Address Register */
+#define                 DMA20_IRQ_STATUS  0xffc01e28   /* DMA Channel 20 Interrupt/Status Register */
+#define             DMA20_PERIPHERAL_MAP  0xffc01e2c   /* DMA Channel 20 Peripheral Map Register */
+#define               DMA20_CURR_X_COUNT  0xffc01e30   /* DMA Channel 20 Current X Count Register */
+#define               DMA20_CURR_Y_COUNT  0xffc01e38   /* DMA Channel 20 Current Y Count Register */
+
+/* DMA Channel 21 Registers */
+
+#define              DMA21_NEXT_DESC_PTR  0xffc01e40   /* DMA Channel 21 Next Descriptor Pointer Register */
+#define                 DMA21_START_ADDR  0xffc01e44   /* DMA Channel 21 Start Address Register */
+#define                     DMA21_CONFIG  0xffc01e48   /* DMA Channel 21 Configuration Register */
+#define                    DMA21_X_COUNT  0xffc01e50   /* DMA Channel 21 X Count Register */
+#define                   DMA21_X_MODIFY  0xffc01e54   /* DMA Channel 21 X Modify Register */
+#define                    DMA21_Y_COUNT  0xffc01e58   /* DMA Channel 21 Y Count Register */
+#define                   DMA21_Y_MODIFY  0xffc01e5c   /* DMA Channel 21 Y Modify Register */
+#define              DMA21_CURR_DESC_PTR  0xffc01e60   /* DMA Channel 21 Current Descriptor Pointer Register */
+#define                  DMA21_CURR_ADDR  0xffc01e64   /* DMA Channel 21 Current Address Register */
+#define                 DMA21_IRQ_STATUS  0xffc01e68   /* DMA Channel 21 Interrupt/Status Register */
+#define             DMA21_PERIPHERAL_MAP  0xffc01e6c   /* DMA Channel 21 Peripheral Map Register */
+#define               DMA21_CURR_X_COUNT  0xffc01e70   /* DMA Channel 21 Current X Count Register */
+#define               DMA21_CURR_Y_COUNT  0xffc01e78   /* DMA Channel 21 Current Y Count Register */
+
+/* DMA Channel 22 Registers */
+
+#define              DMA22_NEXT_DESC_PTR  0xffc01e80   /* DMA Channel 22 Next Descriptor Pointer Register */
+#define                 DMA22_START_ADDR  0xffc01e84   /* DMA Channel 22 Start Address Register */
+#define                     DMA22_CONFIG  0xffc01e88   /* DMA Channel 22 Configuration Register */
+#define                    DMA22_X_COUNT  0xffc01e90   /* DMA Channel 22 X Count Register */
+#define                   DMA22_X_MODIFY  0xffc01e94   /* DMA Channel 22 X Modify Register */
+#define                    DMA22_Y_COUNT  0xffc01e98   /* DMA Channel 22 Y Count Register */
+#define                   DMA22_Y_MODIFY  0xffc01e9c   /* DMA Channel 22 Y Modify Register */
+#define              DMA22_CURR_DESC_PTR  0xffc01ea0   /* DMA Channel 22 Current Descriptor Pointer Register */
+#define                  DMA22_CURR_ADDR  0xffc01ea4   /* DMA Channel 22 Current Address Register */
+#define                 DMA22_IRQ_STATUS  0xffc01ea8   /* DMA Channel 22 Interrupt/Status Register */
+#define             DMA22_PERIPHERAL_MAP  0xffc01eac   /* DMA Channel 22 Peripheral Map Register */
+#define               DMA22_CURR_X_COUNT  0xffc01eb0   /* DMA Channel 22 Current X Count Register */
+#define               DMA22_CURR_Y_COUNT  0xffc01eb8   /* DMA Channel 22 Current Y Count Register */
+
+/* DMA Channel 23 Registers */
+
+#define              DMA23_NEXT_DESC_PTR  0xffc01ec0   /* DMA Channel 23 Next Descriptor Pointer Register */
+#define                 DMA23_START_ADDR  0xffc01ec4   /* DMA Channel 23 Start Address Register */
+#define                     DMA23_CONFIG  0xffc01ec8   /* DMA Channel 23 Configuration Register */
+#define                    DMA23_X_COUNT  0xffc01ed0   /* DMA Channel 23 X Count Register */
+#define                   DMA23_X_MODIFY  0xffc01ed4   /* DMA Channel 23 X Modify Register */
+#define                    DMA23_Y_COUNT  0xffc01ed8   /* DMA Channel 23 Y Count Register */
+#define                   DMA23_Y_MODIFY  0xffc01edc   /* DMA Channel 23 Y Modify Register */
+#define              DMA23_CURR_DESC_PTR  0xffc01ee0   /* DMA Channel 23 Current Descriptor Pointer Register */
+#define                  DMA23_CURR_ADDR  0xffc01ee4   /* DMA Channel 23 Current Address Register */
+#define                 DMA23_IRQ_STATUS  0xffc01ee8   /* DMA Channel 23 Interrupt/Status Register */
+#define             DMA23_PERIPHERAL_MAP  0xffc01eec   /* DMA Channel 23 Peripheral Map Register */
+#define               DMA23_CURR_X_COUNT  0xffc01ef0   /* DMA Channel 23 Current X Count Register */
+#define               DMA23_CURR_Y_COUNT  0xffc01ef8   /* DMA Channel 23 Current Y Count Register */
+
+/* MDMA Stream 2 Registers */
+
+#define            MDMA_D2_NEXT_DESC_PTR  0xffc01f00   /* Memory DMA Stream 2 Destination Next Descriptor Pointer Register */
+#define               MDMA_D2_START_ADDR  0xffc01f04   /* Memory DMA Stream 2 Destination Start Address Register */
+#define                   MDMA_D2_CONFIG  0xffc01f08   /* Memory DMA Stream 2 Destination Configuration Register */
+#define                  MDMA_D2_X_COUNT  0xffc01f10   /* Memory DMA Stream 2 Destination X Count Register */
+#define                 MDMA_D2_X_MODIFY  0xffc01f14   /* Memory DMA Stream 2 Destination X Modify Register */
+#define                  MDMA_D2_Y_COUNT  0xffc01f18   /* Memory DMA Stream 2 Destination Y Count Register */
+#define                 MDMA_D2_Y_MODIFY  0xffc01f1c   /* Memory DMA Stream 2 Destination Y Modify Register */
+#define            MDMA_D2_CURR_DESC_PTR  0xffc01f20   /* Memory DMA Stream 2 Destination Current Descriptor Pointer Register */
+#define                MDMA_D2_CURR_ADDR  0xffc01f24   /* Memory DMA Stream 2 Destination Current Address Register */
+#define               MDMA_D2_IRQ_STATUS  0xffc01f28   /* Memory DMA Stream 2 Destination Interrupt/Status Register */
+#define           MDMA_D2_PERIPHERAL_MAP  0xffc01f2c   /* Memory DMA Stream 2 Destination Peripheral Map Register */
+#define             MDMA_D2_CURR_X_COUNT  0xffc01f30   /* Memory DMA Stream 2 Destination Current X Count Register */
+#define             MDMA_D2_CURR_Y_COUNT  0xffc01f38   /* Memory DMA Stream 2 Destination Current Y Count Register */
+#define            MDMA_S2_NEXT_DESC_PTR  0xffc01f40   /* Memory DMA Stream 2 Source Next Descriptor Pointer Register */
+#define               MDMA_S2_START_ADDR  0xffc01f44   /* Memory DMA Stream 2 Source Start Address Register */
+#define                   MDMA_S2_CONFIG  0xffc01f48   /* Memory DMA Stream 2 Source Configuration Register */
+#define                  MDMA_S2_X_COUNT  0xffc01f50   /* Memory DMA Stream 2 Source X Count Register */
+#define                 MDMA_S2_X_MODIFY  0xffc01f54   /* Memory DMA Stream 2 Source X Modify Register */
+#define                  MDMA_S2_Y_COUNT  0xffc01f58   /* Memory DMA Stream 2 Source Y Count Register */
+#define                 MDMA_S2_Y_MODIFY  0xffc01f5c   /* Memory DMA Stream 2 Source Y Modify Register */
+#define            MDMA_S2_CURR_DESC_PTR  0xffc01f60   /* Memory DMA Stream 2 Source Current Descriptor Pointer Register */
+#define                MDMA_S2_CURR_ADDR  0xffc01f64   /* Memory DMA Stream 2 Source Current Address Register */
+#define               MDMA_S2_IRQ_STATUS  0xffc01f68   /* Memory DMA Stream 2 Source Interrupt/Status Register */
+#define           MDMA_S2_PERIPHERAL_MAP  0xffc01f6c   /* Memory DMA Stream 2 Source Peripheral Map Register */
+#define             MDMA_S2_CURR_X_COUNT  0xffc01f70   /* Memory DMA Stream 2 Source Current X Count Register */
+#define             MDMA_S2_CURR_Y_COUNT  0xffc01f78   /* Memory DMA Stream 2 Source Current Y Count Register */
+
+/* MDMA Stream 3 Registers */
+
+#define            MDMA_D3_NEXT_DESC_PTR  0xffc01f80   /* Memory DMA Stream 3 Destination Next Descriptor Pointer Register */
+#define               MDMA_D3_START_ADDR  0xffc01f84   /* Memory DMA Stream 3 Destination Start Address Register */
+#define                   MDMA_D3_CONFIG  0xffc01f88   /* Memory DMA Stream 3 Destination Configuration Register */
+#define                  MDMA_D3_X_COUNT  0xffc01f90   /* Memory DMA Stream 3 Destination X Count Register */
+#define                 MDMA_D3_X_MODIFY  0xffc01f94   /* Memory DMA Stream 3 Destination X Modify Register */
+#define                  MDMA_D3_Y_COUNT  0xffc01f98   /* Memory DMA Stream 3 Destination Y Count Register */
+#define                 MDMA_D3_Y_MODIFY  0xffc01f9c   /* Memory DMA Stream 3 Destination Y Modify Register */
+#define            MDMA_D3_CURR_DESC_PTR  0xffc01fa0   /* Memory DMA Stream 3 Destination Current Descriptor Pointer Register */
+#define                MDMA_D3_CURR_ADDR  0xffc01fa4   /* Memory DMA Stream 3 Destination Current Address Register */
+#define               MDMA_D3_IRQ_STATUS  0xffc01fa8   /* Memory DMA Stream 3 Destination Interrupt/Status Register */
+#define           MDMA_D3_PERIPHERAL_MAP  0xffc01fac   /* Memory DMA Stream 3 Destination Peripheral Map Register */
+#define             MDMA_D3_CURR_X_COUNT  0xffc01fb0   /* Memory DMA Stream 3 Destination Current X Count Register */
+#define             MDMA_D3_CURR_Y_COUNT  0xffc01fb8   /* Memory DMA Stream 3 Destination Current Y Count Register */
+#define            MDMA_S3_NEXT_DESC_PTR  0xffc01fc0   /* Memory DMA Stream 3 Source Next Descriptor Pointer Register */
+#define               MDMA_S3_START_ADDR  0xffc01fc4   /* Memory DMA Stream 3 Source Start Address Register */
+#define                   MDMA_S3_CONFIG  0xffc01fc8   /* Memory DMA Stream 3 Source Configuration Register */
+#define                  MDMA_S3_X_COUNT  0xffc01fd0   /* Memory DMA Stream 3 Source X Count Register */
+#define                 MDMA_S3_X_MODIFY  0xffc01fd4   /* Memory DMA Stream 3 Source X Modify Register */
+#define                  MDMA_S3_Y_COUNT  0xffc01fd8   /* Memory DMA Stream 3 Source Y Count Register */
+#define                 MDMA_S3_Y_MODIFY  0xffc01fdc   /* Memory DMA Stream 3 Source Y Modify Register */
+#define            MDMA_S3_CURR_DESC_PTR  0xffc01fe0   /* Memory DMA Stream 3 Source Current Descriptor Pointer Register */
+#define                MDMA_S3_CURR_ADDR  0xffc01fe4   /* Memory DMA Stream 3 Source Current Address Register */
+#define               MDMA_S3_IRQ_STATUS  0xffc01fe8   /* Memory DMA Stream 3 Source Interrupt/Status Register */
+#define           MDMA_S3_PERIPHERAL_MAP  0xffc01fec   /* Memory DMA Stream 3 Source Peripheral Map Register */
+#define             MDMA_S3_CURR_X_COUNT  0xffc01ff0   /* Memory DMA Stream 3 Source Current X Count Register */
+#define             MDMA_S3_CURR_Y_COUNT  0xffc01ff8   /* Memory DMA Stream 3 Source Current Y Count Register */
+
+/* UART1 Registers */
+
+#define                        UART1_DLL  0xffc02000   /* Divisor Latch Low Byte */
+#define                        UART1_DLH  0xffc02004   /* Divisor Latch High Byte */
+#define                       UART1_GCTL  0xffc02008   /* Global Control Register */
+#define                        UART1_LCR  0xffc0200c   /* Line Control Register */
+#define                        UART1_MCR  0xffc02010   /* Modem Control Register */
+#define                        UART1_LSR  0xffc02014   /* Line Status Register */
+#define                        UART1_MSR  0xffc02018   /* Modem Status Register */
+#define                        UART1_SCR  0xffc0201c   /* Scratch Register */
+#define                    UART1_IER_SET  0xffc02020   /* Interrupt Enable Register Set */
+#define                  UART1_IER_CLEAR  0xffc02024   /* Interrupt Enable Register Clear */
+#define                        UART1_THR  0xffc02028   /* Transmit Hold Register */
+#define                        UART1_RBR  0xffc0202c   /* Receive Buffer Register */
+
+/* UART2 is not defined in the shared file because it is not available on the ADSP-BF542 and ADSP-BF544 processors */
+
+/* SPI1 Registers */
+
+#define                         SPI1_CTL  0xffc02300   /* SPI1 Control Register */
+#define                         SPI1_FLG  0xffc02304   /* SPI1 Flag Register */
+#define                        SPI1_STAT  0xffc02308   /* SPI1 Status Register */
+#define                        SPI1_TDBR  0xffc0230c   /* SPI1 Transmit Data Buffer Register */
+#define                        SPI1_RDBR  0xffc02310   /* SPI1 Receive Data Buffer Register */
+#define                        SPI1_BAUD  0xffc02314   /* SPI1 Baud Rate Register */
+#define                      SPI1_SHADOW  0xffc02318   /* SPI1 Receive Data Buffer Shadow Register */
+
+/* SPORT2 Registers */
+
+#define                      SPORT2_TCR1  0xffc02500   /* SPORT2 Transmit Configuration 1 Register */
+#define                      SPORT2_TCR2  0xffc02504   /* SPORT2 Transmit Configuration 2 Register */
+#define                   SPORT2_TCLKDIV  0xffc02508   /* SPORT2 Transmit Serial Clock Divider Register */
+#define                    SPORT2_TFSDIV  0xffc0250c   /* SPORT2 Transmit Frame Sync Divider Register */
+#define                        SPORT2_TX  0xffc02510   /* SPORT2 Transmit Data Register */
+#define                        SPORT2_RX  0xffc02518   /* SPORT2 Receive Data Register */
+#define                      SPORT2_RCR1  0xffc02520   /* SPORT2 Receive Configuration 1 Register */
+#define                      SPORT2_RCR2  0xffc02524   /* SPORT2 Receive Configuration 2 Register */
+#define                   SPORT2_RCLKDIV  0xffc02528   /* SPORT2 Receive Serial Clock Divider Register */
+#define                    SPORT2_RFSDIV  0xffc0252c   /* SPORT2 Receive Frame Sync Divider Register */
+#define                      SPORT2_STAT  0xffc02530   /* SPORT2 Status Register */
+#define                      SPORT2_CHNL  0xffc02534   /* SPORT2 Current Channel Register */
+#define                     SPORT2_MCMC1  0xffc02538   /* SPORT2 Multi channel Configuration Register 1 */
+#define                     SPORT2_MCMC2  0xffc0253c   /* SPORT2 Multi channel Configuration Register 2 */
+#define                     SPORT2_MTCS0  0xffc02540   /* SPORT2 Multi channel Transmit Select Register 0 */
+#define                     SPORT2_MTCS1  0xffc02544   /* SPORT2 Multi channel Transmit Select Register 1 */
+#define                     SPORT2_MTCS2  0xffc02548   /* SPORT2 Multi channel Transmit Select Register 2 */
+#define                     SPORT2_MTCS3  0xffc0254c   /* SPORT2 Multi channel Transmit Select Register 3 */
+#define                     SPORT2_MRCS0  0xffc02550   /* SPORT2 Multi channel Receive Select Register 0 */
+#define                     SPORT2_MRCS1  0xffc02554   /* SPORT2 Multi channel Receive Select Register 1 */
+#define                     SPORT2_MRCS2  0xffc02558   /* SPORT2 Multi channel Receive Select Register 2 */
+#define                     SPORT2_MRCS3  0xffc0255c   /* SPORT2 Multi channel Receive Select Register 3 */
+
+/* SPORT3 Registers */
+
+#define                      SPORT3_TCR1  0xffc02600   /* SPORT3 Transmit Configuration 1 Register */
+#define                      SPORT3_TCR2  0xffc02604   /* SPORT3 Transmit Configuration 2 Register */
+#define                   SPORT3_TCLKDIV  0xffc02608   /* SPORT3 Transmit Serial Clock Divider Register */
+#define                    SPORT3_TFSDIV  0xffc0260c   /* SPORT3 Transmit Frame Sync Divider Register */
+#define                        SPORT3_TX  0xffc02610   /* SPORT3 Transmit Data Register */
+#define                        SPORT3_RX  0xffc02618   /* SPORT3 Receive Data Register */
+#define                      SPORT3_RCR1  0xffc02620   /* SPORT3 Receive Configuration 1 Register */
+#define                      SPORT3_RCR2  0xffc02624   /* SPORT3 Receive Configuration 2 Register */
+#define                   SPORT3_RCLKDIV  0xffc02628   /* SPORT3 Receive Serial Clock Divider Register */
+#define                    SPORT3_RFSDIV  0xffc0262c   /* SPORT3 Receive Frame Sync Divider Register */
+#define                      SPORT3_STAT  0xffc02630   /* SPORT3 Status Register */
+#define                      SPORT3_CHNL  0xffc02634   /* SPORT3 Current Channel Register */
+#define                     SPORT3_MCMC1  0xffc02638   /* SPORT3 Multi channel Configuration Register 1 */
+#define                     SPORT3_MCMC2  0xffc0263c   /* SPORT3 Multi channel Configuration Register 2 */
+#define                     SPORT3_MTCS0  0xffc02640   /* SPORT3 Multi channel Transmit Select Register 0 */
+#define                     SPORT3_MTCS1  0xffc02644   /* SPORT3 Multi channel Transmit Select Register 1 */
+#define                     SPORT3_MTCS2  0xffc02648   /* SPORT3 Multi channel Transmit Select Register 2 */
+#define                     SPORT3_MTCS3  0xffc0264c   /* SPORT3 Multi channel Transmit Select Register 3 */
+#define                     SPORT3_MRCS0  0xffc02650   /* SPORT3 Multi channel Receive Select Register 0 */
+#define                     SPORT3_MRCS1  0xffc02654   /* SPORT3 Multi channel Receive Select Register 1 */
+#define                     SPORT3_MRCS2  0xffc02658   /* SPORT3 Multi channel Receive Select Register 2 */
+#define                     SPORT3_MRCS3  0xffc0265c   /* SPORT3 Multi channel Receive Select Register 3 */
+
+/* EPPI2 Registers */
+
+#define                     EPPI2_STATUS  0xffc02900   /* EPPI2 Status Register */
+#define                     EPPI2_HCOUNT  0xffc02904   /* EPPI2 Horizontal Transfer Count Register */
+#define                     EPPI2_HDELAY  0xffc02908   /* EPPI2 Horizontal Delay Count Register */
+#define                     EPPI2_VCOUNT  0xffc0290c   /* EPPI2 Vertical Transfer Count Register */
+#define                     EPPI2_VDELAY  0xffc02910   /* EPPI2 Vertical Delay Count Register */
+#define                      EPPI2_FRAME  0xffc02914   /* EPPI2 Lines per Frame Register */
+#define                       EPPI2_LINE  0xffc02918   /* EPPI2 Samples per Line Register */
+#define                     EPPI2_CLKDIV  0xffc0291c   /* EPPI2 Clock Divide Register */
+#define                    EPPI2_CONTROL  0xffc02920   /* EPPI2 Control Register */
+#define                   EPPI2_FS1W_HBL  0xffc02924   /* EPPI2 FS1 Width Register / EPPI2 Horizontal Blanking Samples Per Line Register */
+#define                  EPPI2_FS1P_AVPL  0xffc02928   /* EPPI2 FS1 Period Register / EPPI2 Active Video Samples Per Line Register */
+#define                   EPPI2_FS2W_LVB  0xffc0292c   /* EPPI2 FS2 Width Register / EPPI2 Lines of Vertical Blanking Register */
+#define                  EPPI2_FS2P_LAVF  0xffc02930   /* EPPI2 FS2 Period Register/ EPPI2 Lines of Active Video Per Field Register */
+#define                       EPPI2_CLIP  0xffc02934   /* EPPI2 Clipping Register */
+
+/* CAN Controller 0 Config 1 Registers */
+
+#define                         CAN0_MC1  0xffc02a00   /* CAN Controller 0 Mailbox Configuration Register 1 */
+#define                         CAN0_MD1  0xffc02a04   /* CAN Controller 0 Mailbox Direction Register 1 */
+#define                        CAN0_TRS1  0xffc02a08   /* CAN Controller 0 Transmit Request Set Register 1 */
+#define                        CAN0_TRR1  0xffc02a0c   /* CAN Controller 0 Transmit Request Reset Register 1 */
+#define                         CAN0_TA1  0xffc02a10   /* CAN Controller 0 Transmit Acknowledge Register 1 */
+#define                         CAN0_AA1  0xffc02a14   /* CAN Controller 0 Abort Acknowledge Register 1 */
+#define                        CAN0_RMP1  0xffc02a18   /* CAN Controller 0 Receive Message Pending Register 1 */
+#define                        CAN0_RML1  0xffc02a1c   /* CAN Controller 0 Receive Message Lost Register 1 */
+#define                      CAN0_MBTIF1  0xffc02a20   /* CAN Controller 0 Mailbox Transmit Interrupt Flag Register 1 */
+#define                      CAN0_MBRIF1  0xffc02a24   /* CAN Controller 0 Mailbox Receive Interrupt Flag Register 1 */
+#define                       CAN0_MBIM1  0xffc02a28   /* CAN Controller 0 Mailbox Interrupt Mask Register 1 */
+#define                        CAN0_RFH1  0xffc02a2c   /* CAN Controller 0 Remote Frame Handling Enable Register 1 */
+#define                       CAN0_OPSS1  0xffc02a30   /* CAN Controller 0 Overwrite Protection Single Shot Transmit Register 1 */
+
+/* CAN Controller 0 Config 2 Registers */
+
+#define                         CAN0_MC2  0xffc02a40   /* CAN Controller 0 Mailbox Configuration Register 2 */
+#define                         CAN0_MD2  0xffc02a44   /* CAN Controller 0 Mailbox Direction Register 2 */
+#define                        CAN0_TRS2  0xffc02a48   /* CAN Controller 0 Transmit Request Set Register 2 */
+#define                        CAN0_TRR2  0xffc02a4c   /* CAN Controller 0 Transmit Request Reset Register 2 */
+#define                         CAN0_TA2  0xffc02a50   /* CAN Controller 0 Transmit Acknowledge Register 2 */
+#define                         CAN0_AA2  0xffc02a54   /* CAN Controller 0 Abort Acknowledge Register 2 */
+#define                        CAN0_RMP2  0xffc02a58   /* CAN Controller 0 Receive Message Pending Register 2 */
+#define                        CAN0_RML2  0xffc02a5c   /* CAN Controller 0 Receive Message Lost Register 2 */
+#define                      CAN0_MBTIF2  0xffc02a60   /* CAN Controller 0 Mailbox Transmit Interrupt Flag Register 2 */
+#define                      CAN0_MBRIF2  0xffc02a64   /* CAN Controller 0 Mailbox Receive Interrupt Flag Register 2 */
+#define                       CAN0_MBIM2  0xffc02a68   /* CAN Controller 0 Mailbox Interrupt Mask Register 2 */
+#define                        CAN0_RFH2  0xffc02a6c   /* CAN Controller 0 Remote Frame Handling Enable Register 2 */
+#define                       CAN0_OPSS2  0xffc02a70   /* CAN Controller 0 Overwrite Protection Single Shot Transmit Register 2 */
+
+/* CAN Controller 0 Clock/Interrupt/Counter Registers */
+
+#define                       CAN0_CLOCK  0xffc02a80   /* CAN Controller 0 Clock Register */
+#define                      CAN0_TIMING  0xffc02a84   /* CAN Controller 0 Timing Register */
+#define                       CAN0_DEBUG  0xffc02a88   /* CAN Controller 0 Debug Register */
+#define                      CAN0_STATUS  0xffc02a8c   /* CAN Controller 0 Global Status Register */
+#define                         CAN0_CEC  0xffc02a90   /* CAN Controller 0 Error Counter Register */
+#define                         CAN0_GIS  0xffc02a94   /* CAN Controller 0 Global Interrupt Status Register */
+#define                         CAN0_GIM  0xffc02a98   /* CAN Controller 0 Global Interrupt Mask Register */
+#define                         CAN0_GIF  0xffc02a9c   /* CAN Controller 0 Global Interrupt Flag Register */
+#define                     CAN0_CONTROL  0xffc02aa0   /* CAN Controller 0 Master Control Register */
+#define                        CAN0_INTR  0xffc02aa4   /* CAN Controller 0 Interrupt Pending Register */
+#define                        CAN0_MBTD  0xffc02aac   /* CAN Controller 0 Mailbox Temporary Disable Register */
+#define                         CAN0_EWR  0xffc02ab0   /* CAN Controller 0 Programmable Warning Level Register */
+#define                         CAN0_ESR  0xffc02ab4   /* CAN Controller 0 Error Status Register */
+#define                       CAN0_UCCNT  0xffc02ac4   /* CAN Controller 0 Universal Counter Register */
+#define                        CAN0_UCRC  0xffc02ac8   /* CAN Controller 0 Universal Counter Force Reload Register */
+#define                       CAN0_UCCNF  0xffc02acc   /* CAN Controller 0 Universal Counter Configuration Register */
+
+/* CAN Controller 0 Acceptance Registers */
+
+#define                       CAN0_AM00L  0xffc02b00   /* CAN Controller 0 Mailbox 0 Acceptance Mask High Register */
+#define                       CAN0_AM00H  0xffc02b04   /* CAN Controller 0 Mailbox 0 Acceptance Mask Low Register */
+#define                       CAN0_AM01L  0xffc02b08   /* CAN Controller 0 Mailbox 1 Acceptance Mask High Register */
+#define                       CAN0_AM01H  0xffc02b0c   /* CAN Controller 0 Mailbox 1 Acceptance Mask Low Register */
+#define                       CAN0_AM02L  0xffc02b10   /* CAN Controller 0 Mailbox 2 Acceptance Mask High Register */
+#define                       CAN0_AM02H  0xffc02b14   /* CAN Controller 0 Mailbox 2 Acceptance Mask Low Register */
+#define                       CAN0_AM03L  0xffc02b18   /* CAN Controller 0 Mailbox 3 Acceptance Mask High Register */
+#define                       CAN0_AM03H  0xffc02b1c   /* CAN Controller 0 Mailbox 3 Acceptance Mask Low Register */
+#define                       CAN0_AM04L  0xffc02b20   /* CAN Controller 0 Mailbox 4 Acceptance Mask High Register */
+#define                       CAN0_AM04H  0xffc02b24   /* CAN Controller 0 Mailbox 4 Acceptance Mask Low Register */
+#define                       CAN0_AM05L  0xffc02b28   /* CAN Controller 0 Mailbox 5 Acceptance Mask High Register */
+#define                       CAN0_AM05H  0xffc02b2c   /* CAN Controller 0 Mailbox 5 Acceptance Mask Low Register */
+#define                       CAN0_AM06L  0xffc02b30   /* CAN Controller 0 Mailbox 6 Acceptance Mask High Register */
+#define                       CAN0_AM06H  0xffc02b34   /* CAN Controller 0 Mailbox 6 Acceptance Mask Low Register */
+#define                       CAN0_AM07L  0xffc02b38   /* CAN Controller 0 Mailbox 7 Acceptance Mask High Register */
+#define                       CAN0_AM07H  0xffc02b3c   /* CAN Controller 0 Mailbox 7 Acceptance Mask Low Register */
+#define                       CAN0_AM08L  0xffc02b40   /* CAN Controller 0 Mailbox 8 Acceptance Mask High Register */
+#define                       CAN0_AM08H  0xffc02b44   /* CAN Controller 0 Mailbox 8 Acceptance Mask Low Register */
+#define                       CAN0_AM09L  0xffc02b48   /* CAN Controller 0 Mailbox 9 Acceptance Mask High Register */
+#define                       CAN0_AM09H  0xffc02b4c   /* CAN Controller 0 Mailbox 9 Acceptance Mask Low Register */
+#define                       CAN0_AM10L  0xffc02b50   /* CAN Controller 0 Mailbox 10 Acceptance Mask High Register */
+#define                       CAN0_AM10H  0xffc02b54   /* CAN Controller 0 Mailbox 10 Acceptance Mask Low Register */
+#define                       CAN0_AM11L  0xffc02b58   /* CAN Controller 0 Mailbox 11 Acceptance Mask High Register */
+#define                       CAN0_AM11H  0xffc02b5c   /* CAN Controller 0 Mailbox 11 Acceptance Mask Low Register */
+#define                       CAN0_AM12L  0xffc02b60   /* CAN Controller 0 Mailbox 12 Acceptance Mask High Register */
+#define                       CAN0_AM12H  0xffc02b64   /* CAN Controller 0 Mailbox 12 Acceptance Mask Low Register */
+#define                       CAN0_AM13L  0xffc02b68   /* CAN Controller 0 Mailbox 13 Acceptance Mask High Register */
+#define                       CAN0_AM13H  0xffc02b6c   /* CAN Controller 0 Mailbox 13 Acceptance Mask Low Register */
+#define                       CAN0_AM14L  0xffc02b70   /* CAN Controller 0 Mailbox 14 Acceptance Mask High Register */
+#define                       CAN0_AM14H  0xffc02b74   /* CAN Controller 0 Mailbox 14 Acceptance Mask Low Register */
+#define                       CAN0_AM15L  0xffc02b78   /* CAN Controller 0 Mailbox 15 Acceptance Mask High Register */
+#define                       CAN0_AM15H  0xffc02b7c   /* CAN Controller 0 Mailbox 15 Acceptance Mask Low Register */
+
+/* CAN Controller 0 Acceptance Registers */
+
+#define                       CAN0_AM16L  0xffc02b80   /* CAN Controller 0 Mailbox 16 Acceptance Mask High Register */
+#define                       CAN0_AM16H  0xffc02b84   /* CAN Controller 0 Mailbox 16 Acceptance Mask Low Register */
+#define                       CAN0_AM17L  0xffc02b88   /* CAN Controller 0 Mailbox 17 Acceptance Mask High Register */
+#define                       CAN0_AM17H  0xffc02b8c   /* CAN Controller 0 Mailbox 17 Acceptance Mask Low Register */
+#define                       CAN0_AM18L  0xffc02b90   /* CAN Controller 0 Mailbox 18 Acceptance Mask High Register */
+#define                       CAN0_AM18H  0xffc02b94   /* CAN Controller 0 Mailbox 18 Acceptance Mask Low Register */
+#define                       CAN0_AM19L  0xffc02b98   /* CAN Controller 0 Mailbox 19 Acceptance Mask High Register */
+#define                       CAN0_AM19H  0xffc02b9c   /* CAN Controller 0 Mailbox 19 Acceptance Mask Low Register */
+#define                       CAN0_AM20L  0xffc02ba0   /* CAN Controller 0 Mailbox 20 Acceptance Mask High Register */
+#define                       CAN0_AM20H  0xffc02ba4   /* CAN Controller 0 Mailbox 20 Acceptance Mask Low Register */
+#define                       CAN0_AM21L  0xffc02ba8   /* CAN Controller 0 Mailbox 21 Acceptance Mask High Register */
+#define                       CAN0_AM21H  0xffc02bac   /* CAN Controller 0 Mailbox 21 Acceptance Mask Low Register */
+#define                       CAN0_AM22L  0xffc02bb0   /* CAN Controller 0 Mailbox 22 Acceptance Mask High Register */
+#define                       CAN0_AM22H  0xffc02bb4   /* CAN Controller 0 Mailbox 22 Acceptance Mask Low Register */
+#define                       CAN0_AM23L  0xffc02bb8   /* CAN Controller 0 Mailbox 23 Acceptance Mask High Register */
+#define                       CAN0_AM23H  0xffc02bbc   /* CAN Controller 0 Mailbox 23 Acceptance Mask Low Register */
+#define                       CAN0_AM24L  0xffc02bc0   /* CAN Controller 0 Mailbox 24 Acceptance Mask High Register */
+#define                       CAN0_AM24H  0xffc02bc4   /* CAN Controller 0 Mailbox 24 Acceptance Mask Low Register */
+#define                       CAN0_AM25L  0xffc02bc8   /* CAN Controller 0 Mailbox 25 Acceptance Mask High Register */
+#define                       CAN0_AM25H  0xffc02bcc   /* CAN Controller 0 Mailbox 25 Acceptance Mask Low Register */
+#define                       CAN0_AM26L  0xffc02bd0   /* CAN Controller 0 Mailbox 26 Acceptance Mask High Register */
+#define                       CAN0_AM26H  0xffc02bd4   /* CAN Controller 0 Mailbox 26 Acceptance Mask Low Register */
+#define                       CAN0_AM27L  0xffc02bd8   /* CAN Controller 0 Mailbox 27 Acceptance Mask High Register */
+#define                       CAN0_AM27H  0xffc02bdc   /* CAN Controller 0 Mailbox 27 Acceptance Mask Low Register */
+#define                       CAN0_AM28L  0xffc02be0   /* CAN Controller 0 Mailbox 28 Acceptance Mask High Register */
+#define                       CAN0_AM28H  0xffc02be4   /* CAN Controller 0 Mailbox 28 Acceptance Mask Low Register */
+#define                       CAN0_AM29L  0xffc02be8   /* CAN Controller 0 Mailbox 29 Acceptance Mask High Register */
+#define                       CAN0_AM29H  0xffc02bec   /* CAN Controller 0 Mailbox 29 Acceptance Mask Low Register */
+#define                       CAN0_AM30L  0xffc02bf0   /* CAN Controller 0 Mailbox 30 Acceptance Mask High Register */
+#define                       CAN0_AM30H  0xffc02bf4   /* CAN Controller 0 Mailbox 30 Acceptance Mask Low Register */
+#define                       CAN0_AM31L  0xffc02bf8   /* CAN Controller 0 Mailbox 31 Acceptance Mask High Register */
+#define                       CAN0_AM31H  0xffc02bfc   /* CAN Controller 0 Mailbox 31 Acceptance Mask Low Register */
+
+/* CAN Controller 0 Mailbox Data Registers */
+
+#define                  CAN0_MB00_DATA0  0xffc02c00   /* CAN Controller 0 Mailbox 0 Data 0 Register */
+#define                  CAN0_MB00_DATA1  0xffc02c04   /* CAN Controller 0 Mailbox 0 Data 1 Register */
+#define                  CAN0_MB00_DATA2  0xffc02c08   /* CAN Controller 0 Mailbox 0 Data 2 Register */
+#define                  CAN0_MB00_DATA3  0xffc02c0c   /* CAN Controller 0 Mailbox 0 Data 3 Register */
+#define                 CAN0_MB00_LENGTH  0xffc02c10   /* CAN Controller 0 Mailbox 0 Length Register */
+#define              CAN0_MB00_TIMESTAMP  0xffc02c14   /* CAN Controller 0 Mailbox 0 Timestamp Register */
+#define                    CAN0_MB00_ID0  0xffc02c18   /* CAN Controller 0 Mailbox 0 ID0 Register */
+#define                    CAN0_MB00_ID1  0xffc02c1c   /* CAN Controller 0 Mailbox 0 ID1 Register */
+#define                  CAN0_MB01_DATA0  0xffc02c20   /* CAN Controller 0 Mailbox 1 Data 0 Register */
+#define                  CAN0_MB01_DATA1  0xffc02c24   /* CAN Controller 0 Mailbox 1 Data 1 Register */
+#define                  CAN0_MB01_DATA2  0xffc02c28   /* CAN Controller 0 Mailbox 1 Data 2 Register */
+#define                  CAN0_MB01_DATA3  0xffc02c2c   /* CAN Controller 0 Mailbox 1 Data 3 Register */
+#define                 CAN0_MB01_LENGTH  0xffc02c30   /* CAN Controller 0 Mailbox 1 Length Register */
+#define              CAN0_MB01_TIMESTAMP  0xffc02c34   /* CAN Controller 0 Mailbox 1 Timestamp Register */
+#define                    CAN0_MB01_ID0  0xffc02c38   /* CAN Controller 0 Mailbox 1 ID0 Register */
+#define                    CAN0_MB01_ID1  0xffc02c3c   /* CAN Controller 0 Mailbox 1 ID1 Register */
+#define                  CAN0_MB02_DATA0  0xffc02c40   /* CAN Controller 0 Mailbox 2 Data 0 Register */
+#define                  CAN0_MB02_DATA1  0xffc02c44   /* CAN Controller 0 Mailbox 2 Data 1 Register */
+#define                  CAN0_MB02_DATA2  0xffc02c48   /* CAN Controller 0 Mailbox 2 Data 2 Register */
+#define                  CAN0_MB02_DATA3  0xffc02c4c   /* CAN Controller 0 Mailbox 2 Data 3 Register */
+#define                 CAN0_MB02_LENGTH  0xffc02c50   /* CAN Controller 0 Mailbox 2 Length Register */
+#define              CAN0_MB02_TIMESTAMP  0xffc02c54   /* CAN Controller 0 Mailbox 2 Timestamp Register */
+#define                    CAN0_MB02_ID0  0xffc02c58   /* CAN Controller 0 Mailbox 2 ID0 Register */
+#define                    CAN0_MB02_ID1  0xffc02c5c   /* CAN Controller 0 Mailbox 2 ID1 Register */
+#define                  CAN0_MB03_DATA0  0xffc02c60   /* CAN Controller 0 Mailbox 3 Data 0 Register */
+#define                  CAN0_MB03_DATA1  0xffc02c64   /* CAN Controller 0 Mailbox 3 Data 1 Register */
+#define                  CAN0_MB03_DATA2  0xffc02c68   /* CAN Controller 0 Mailbox 3 Data 2 Register */
+#define                  CAN0_MB03_DATA3  0xffc02c6c   /* CAN Controller 0 Mailbox 3 Data 3 Register */
+#define                 CAN0_MB03_LENGTH  0xffc02c70   /* CAN Controller 0 Mailbox 3 Length Register */
+#define              CAN0_MB03_TIMESTAMP  0xffc02c74   /* CAN Controller 0 Mailbox 3 Timestamp Register */
+#define                    CAN0_MB03_ID0  0xffc02c78   /* CAN Controller 0 Mailbox 3 ID0 Register */
+#define                    CAN0_MB03_ID1  0xffc02c7c   /* CAN Controller 0 Mailbox 3 ID1 Register */
+#define                  CAN0_MB04_DATA0  0xffc02c80   /* CAN Controller 0 Mailbox 4 Data 0 Register */
+#define                  CAN0_MB04_DATA1  0xffc02c84   /* CAN Controller 0 Mailbox 4 Data 1 Register */
+#define                  CAN0_MB04_DATA2  0xffc02c88   /* CAN Controller 0 Mailbox 4 Data 2 Register */
+#define                  CAN0_MB04_DATA3  0xffc02c8c   /* CAN Controller 0 Mailbox 4 Data 3 Register */
+#define                 CAN0_MB04_LENGTH  0xffc02c90   /* CAN Controller 0 Mailbox 4 Length Register */
+#define              CAN0_MB04_TIMESTAMP  0xffc02c94   /* CAN Controller 0 Mailbox 4 Timestamp Register */
+#define                    CAN0_MB04_ID0  0xffc02c98   /* CAN Controller 0 Mailbox 4 ID0 Register */
+#define                    CAN0_MB04_ID1  0xffc02c9c   /* CAN Controller 0 Mailbox 4 ID1 Register */
+#define                  CAN0_MB05_DATA0  0xffc02ca0   /* CAN Controller 0 Mailbox 5 Data 0 Register */
+#define                  CAN0_MB05_DATA1  0xffc02ca4   /* CAN Controller 0 Mailbox 5 Data 1 Register */
+#define                  CAN0_MB05_DATA2  0xffc02ca8   /* CAN Controller 0 Mailbox 5 Data 2 Register */
+#define                  CAN0_MB05_DATA3  0xffc02cac   /* CAN Controller 0 Mailbox 5 Data 3 Register */
+#define                 CAN0_MB05_LENGTH  0xffc02cb0   /* CAN Controller 0 Mailbox 5 Length Register */
+#define              CAN0_MB05_TIMESTAMP  0xffc02cb4   /* CAN Controller 0 Mailbox 5 Timestamp Register */
+#define                    CAN0_MB05_ID0  0xffc02cb8   /* CAN Controller 0 Mailbox 5 ID0 Register */
+#define                    CAN0_MB05_ID1  0xffc02cbc   /* CAN Controller 0 Mailbox 5 ID1 Register */
+#define                  CAN0_MB06_DATA0  0xffc02cc0   /* CAN Controller 0 Mailbox 6 Data 0 Register */
+#define                  CAN0_MB06_DATA1  0xffc02cc4   /* CAN Controller 0 Mailbox 6 Data 1 Register */
+#define                  CAN0_MB06_DATA2  0xffc02cc8   /* CAN Controller 0 Mailbox 6 Data 2 Register */
+#define                  CAN0_MB06_DATA3  0xffc02ccc   /* CAN Controller 0 Mailbox 6 Data 3 Register */
+#define                 CAN0_MB06_LENGTH  0xffc02cd0   /* CAN Controller 0 Mailbox 6 Length Register */
+#define              CAN0_MB06_TIMESTAMP  0xffc02cd4   /* CAN Controller 0 Mailbox 6 Timestamp Register */
+#define                    CAN0_MB06_ID0  0xffc02cd8   /* CAN Controller 0 Mailbox 6 ID0 Register */
+#define                    CAN0_MB06_ID1  0xffc02cdc   /* CAN Controller 0 Mailbox 6 ID1 Register */
+#define                  CAN0_MB07_DATA0  0xffc02ce0   /* CAN Controller 0 Mailbox 7 Data 0 Register */
+#define                  CAN0_MB07_DATA1  0xffc02ce4   /* CAN Controller 0 Mailbox 7 Data 1 Register */
+#define                  CAN0_MB07_DATA2  0xffc02ce8   /* CAN Controller 0 Mailbox 7 Data 2 Register */
+#define                  CAN0_MB07_DATA3  0xffc02cec   /* CAN Controller 0 Mailbox 7 Data 3 Register */
+#define                 CAN0_MB07_LENGTH  0xffc02cf0   /* CAN Controller 0 Mailbox 7 Length Register */
+#define              CAN0_MB07_TIMESTAMP  0xffc02cf4   /* CAN Controller 0 Mailbox 7 Timestamp Register */
+#define                    CAN0_MB07_ID0  0xffc02cf8   /* CAN Controller 0 Mailbox 7 ID0 Register */
+#define                    CAN0_MB07_ID1  0xffc02cfc   /* CAN Controller 0 Mailbox 7 ID1 Register */
+#define                  CAN0_MB08_DATA0  0xffc02d00   /* CAN Controller 0 Mailbox 8 Data 0 Register */
+#define                  CAN0_MB08_DATA1  0xffc02d04   /* CAN Controller 0 Mailbox 8 Data 1 Register */
+#define                  CAN0_MB08_DATA2  0xffc02d08   /* CAN Controller 0 Mailbox 8 Data 2 Register */
+#define                  CAN0_MB08_DATA3  0xffc02d0c   /* CAN Controller 0 Mailbox 8 Data 3 Register */
+#define                 CAN0_MB08_LENGTH  0xffc02d10   /* CAN Controller 0 Mailbox 8 Length Register */
+#define              CAN0_MB08_TIMESTAMP  0xffc02d14   /* CAN Controller 0 Mailbox 8 Timestamp Register */
+#define                    CAN0_MB08_ID0  0xffc02d18   /* CAN Controller 0 Mailbox 8 ID0 Register */
+#define                    CAN0_MB08_ID1  0xffc02d1c   /* CAN Controller 0 Mailbox 8 ID1 Register */
+#define                  CAN0_MB09_DATA0  0xffc02d20   /* CAN Controller 0 Mailbox 9 Data 0 Register */
+#define                  CAN0_MB09_DATA1  0xffc02d24   /* CAN Controller 0 Mailbox 9 Data 1 Register */
+#define                  CAN0_MB09_DATA2  0xffc02d28   /* CAN Controller 0 Mailbox 9 Data 2 Register */
+#define                  CAN0_MB09_DATA3  0xffc02d2c   /* CAN Controller 0 Mailbox 9 Data 3 Register */
+#define                 CAN0_MB09_LENGTH  0xffc02d30   /* CAN Controller 0 Mailbox 9 Length Register */
+#define              CAN0_MB09_TIMESTAMP  0xffc02d34   /* CAN Controller 0 Mailbox 9 Timestamp Register */
+#define                    CAN0_MB09_ID0  0xffc02d38   /* CAN Controller 0 Mailbox 9 ID0 Register */
+#define                    CAN0_MB09_ID1  0xffc02d3c   /* CAN Controller 0 Mailbox 9 ID1 Register */
+#define                  CAN0_MB10_DATA0  0xffc02d40   /* CAN Controller 0 Mailbox 10 Data 0 Register */
+#define                  CAN0_MB10_DATA1  0xffc02d44   /* CAN Controller 0 Mailbox 10 Data 1 Register */
+#define                  CAN0_MB10_DATA2  0xffc02d48   /* CAN Controller 0 Mailbox 10 Data 2 Register */
+#define                  CAN0_MB10_DATA3  0xffc02d4c   /* CAN Controller 0 Mailbox 10 Data 3 Register */
+#define                 CAN0_MB10_LENGTH  0xffc02d50   /* CAN Controller 0 Mailbox 10 Length Register */
+#define              CAN0_MB10_TIMESTAMP  0xffc02d54   /* CAN Controller 0 Mailbox 10 Timestamp Register */
+#define                    CAN0_MB10_ID0  0xffc02d58   /* CAN Controller 0 Mailbox 10 ID0 Register */
+#define                    CAN0_MB10_ID1  0xffc02d5c   /* CAN Controller 0 Mailbox 10 ID1 Register */
+#define                  CAN0_MB11_DATA0  0xffc02d60   /* CAN Controller 0 Mailbox 11 Data 0 Register */
+#define                  CAN0_MB11_DATA1  0xffc02d64   /* CAN Controller 0 Mailbox 11 Data 1 Register */
+#define                  CAN0_MB11_DATA2  0xffc02d68   /* CAN Controller 0 Mailbox 11 Data 2 Register */
+#define                  CAN0_MB11_DATA3  0xffc02d6c   /* CAN Controller 0 Mailbox 11 Data 3 Register */
+#define                 CAN0_MB11_LENGTH  0xffc02d70   /* CAN Controller 0 Mailbox 11 Length Register */
+#define              CAN0_MB11_TIMESTAMP  0xffc02d74   /* CAN Controller 0 Mailbox 11 Timestamp Register */
+#define                    CAN0_MB11_ID0  0xffc02d78   /* CAN Controller 0 Mailbox 11 ID0 Register */
+#define                    CAN0_MB11_ID1  0xffc02d7c   /* CAN Controller 0 Mailbox 11 ID1 Register */
+#define                  CAN0_MB12_DATA0  0xffc02d80   /* CAN Controller 0 Mailbox 12 Data 0 Register */
+#define                  CAN0_MB12_DATA1  0xffc02d84   /* CAN Controller 0 Mailbox 12 Data 1 Register */
+#define                  CAN0_MB12_DATA2  0xffc02d88   /* CAN Controller 0 Mailbox 12 Data 2 Register */
+#define                  CAN0_MB12_DATA3  0xffc02d8c   /* CAN Controller 0 Mailbox 12 Data 3 Register */
+#define                 CAN0_MB12_LENGTH  0xffc02d90   /* CAN Controller 0 Mailbox 12 Length Register */
+#define              CAN0_MB12_TIMESTAMP  0xffc02d94   /* CAN Controller 0 Mailbox 12 Timestamp Register */
+#define                    CAN0_MB12_ID0  0xffc02d98   /* CAN Controller 0 Mailbox 12 ID0 Register */
+#define                    CAN0_MB12_ID1  0xffc02d9c   /* CAN Controller 0 Mailbox 12 ID1 Register */
+#define                  CAN0_MB13_DATA0  0xffc02da0   /* CAN Controller 0 Mailbox 13 Data 0 Register */
+#define                  CAN0_MB13_DATA1  0xffc02da4   /* CAN Controller 0 Mailbox 13 Data 1 Register */
+#define                  CAN0_MB13_DATA2  0xffc02da8   /* CAN Controller 0 Mailbox 13 Data 2 Register */
+#define                  CAN0_MB13_DATA3  0xffc02dac   /* CAN Controller 0 Mailbox 13 Data 3 Register */
+#define                 CAN0_MB13_LENGTH  0xffc02db0   /* CAN Controller 0 Mailbox 13 Length Register */
+#define              CAN0_MB13_TIMESTAMP  0xffc02db4   /* CAN Controller 0 Mailbox 13 Timestamp Register */
+#define                    CAN0_MB13_ID0  0xffc02db8   /* CAN Controller 0 Mailbox 13 ID0 Register */
+#define                    CAN0_MB13_ID1  0xffc02dbc   /* CAN Controller 0 Mailbox 13 ID1 Register */
+#define                  CAN0_MB14_DATA0  0xffc02dc0   /* CAN Controller 0 Mailbox 14 Data 0 Register */
+#define                  CAN0_MB14_DATA1  0xffc02dc4   /* CAN Controller 0 Mailbox 14 Data 1 Register */
+#define                  CAN0_MB14_DATA2  0xffc02dc8   /* CAN Controller 0 Mailbox 14 Data 2 Register */
+#define                  CAN0_MB14_DATA3  0xffc02dcc   /* CAN Controller 0 Mailbox 14 Data 3 Register */
+#define                 CAN0_MB14_LENGTH  0xffc02dd0   /* CAN Controller 0 Mailbox 14 Length Register */
+#define              CAN0_MB14_TIMESTAMP  0xffc02dd4   /* CAN Controller 0 Mailbox 14 Timestamp Register */
+#define                    CAN0_MB14_ID0  0xffc02dd8   /* CAN Controller 0 Mailbox 14 ID0 Register */
+#define                    CAN0_MB14_ID1  0xffc02ddc   /* CAN Controller 0 Mailbox 14 ID1 Register */
+#define                  CAN0_MB15_DATA0  0xffc02de0   /* CAN Controller 0 Mailbox 15 Data 0 Register */
+#define                  CAN0_MB15_DATA1  0xffc02de4   /* CAN Controller 0 Mailbox 15 Data 1 Register */
+#define                  CAN0_MB15_DATA2  0xffc02de8   /* CAN Controller 0 Mailbox 15 Data 2 Register */
+#define                  CAN0_MB15_DATA3  0xffc02dec   /* CAN Controller 0 Mailbox 15 Data 3 Register */
+#define                 CAN0_MB15_LENGTH  0xffc02df0   /* CAN Controller 0 Mailbox 15 Length Register */
+#define              CAN0_MB15_TIMESTAMP  0xffc02df4   /* CAN Controller 0 Mailbox 15 Timestamp Register */
+#define                    CAN0_MB15_ID0  0xffc02df8   /* CAN Controller 0 Mailbox 15 ID0 Register */
+#define                    CAN0_MB15_ID1  0xffc02dfc   /* CAN Controller 0 Mailbox 15 ID1 Register */
+
+/* CAN Controller 0 Mailbox Data Registers */
+
+#define                  CAN0_MB16_DATA0  0xffc02e00   /* CAN Controller 0 Mailbox 16 Data 0 Register */
+#define                  CAN0_MB16_DATA1  0xffc02e04   /* CAN Controller 0 Mailbox 16 Data 1 Register */
+#define                  CAN0_MB16_DATA2  0xffc02e08   /* CAN Controller 0 Mailbox 16 Data 2 Register */
+#define                  CAN0_MB16_DATA3  0xffc02e0c   /* CAN Controller 0 Mailbox 16 Data 3 Register */
+#define                 CAN0_MB16_LENGTH  0xffc02e10   /* CAN Controller 0 Mailbox 16 Length Register */
+#define              CAN0_MB16_TIMESTAMP  0xffc02e14   /* CAN Controller 0 Mailbox 16 Timestamp Register */
+#define                    CAN0_MB16_ID0  0xffc02e18   /* CAN Controller 0 Mailbox 16 ID0 Register */
+#define                    CAN0_MB16_ID1  0xffc02e1c   /* CAN Controller 0 Mailbox 16 ID1 Register */
+#define                  CAN0_MB17_DATA0  0xffc02e20   /* CAN Controller 0 Mailbox 17 Data 0 Register */
+#define                  CAN0_MB17_DATA1  0xffc02e24   /* CAN Controller 0 Mailbox 17 Data 1 Register */
+#define                  CAN0_MB17_DATA2  0xffc02e28   /* CAN Controller 0 Mailbox 17 Data 2 Register */
+#define                  CAN0_MB17_DATA3  0xffc02e2c   /* CAN Controller 0 Mailbox 17 Data 3 Register */
+#define                 CAN0_MB17_LENGTH  0xffc02e30   /* CAN Controller 0 Mailbox 17 Length Register */
+#define              CAN0_MB17_TIMESTAMP  0xffc02e34   /* CAN Controller 0 Mailbox 17 Timestamp Register */
+#define                    CAN0_MB17_ID0  0xffc02e38   /* CAN Controller 0 Mailbox 17 ID0 Register */
+#define                    CAN0_MB17_ID1  0xffc02e3c   /* CAN Controller 0 Mailbox 17 ID1 Register */
+#define                  CAN0_MB18_DATA0  0xffc02e40   /* CAN Controller 0 Mailbox 18 Data 0 Register */
+#define                  CAN0_MB18_DATA1  0xffc02e44   /* CAN Controller 0 Mailbox 18 Data 1 Register */
+#define                  CAN0_MB18_DATA2  0xffc02e48   /* CAN Controller 0 Mailbox 18 Data 2 Register */
+#define                  CAN0_MB18_DATA3  0xffc02e4c   /* CAN Controller 0 Mailbox 18 Data 3 Register */
+#define                 CAN0_MB18_LENGTH  0xffc02e50   /* CAN Controller 0 Mailbox 18 Length Register */
+#define              CAN0_MB18_TIMESTAMP  0xffc02e54   /* CAN Controller 0 Mailbox 18 Timestamp Register */
+#define                    CAN0_MB18_ID0  0xffc02e58   /* CAN Controller 0 Mailbox 18 ID0 Register */
+#define                    CAN0_MB18_ID1  0xffc02e5c   /* CAN Controller 0 Mailbox 18 ID1 Register */
+#define                  CAN0_MB19_DATA0  0xffc02e60   /* CAN Controller 0 Mailbox 19 Data 0 Register */
+#define                  CAN0_MB19_DATA1  0xffc02e64   /* CAN Controller 0 Mailbox 19 Data 1 Register */
+#define                  CAN0_MB19_DATA2  0xffc02e68   /* CAN Controller 0 Mailbox 19 Data 2 Register */
+#define                  CAN0_MB19_DATA3  0xffc02e6c   /* CAN Controller 0 Mailbox 19 Data 3 Register */
+#define                 CAN0_MB19_LENGTH  0xffc02e70   /* CAN Controller 0 Mailbox 19 Length Register */
+#define              CAN0_MB19_TIMESTAMP  0xffc02e74   /* CAN Controller 0 Mailbox 19 Timestamp Register */
+#define                    CAN0_MB19_ID0  0xffc02e78   /* CAN Controller 0 Mailbox 19 ID0 Register */
+#define                    CAN0_MB19_ID1  0xffc02e7c   /* CAN Controller 0 Mailbox 19 ID1 Register */
+#define                  CAN0_MB20_DATA0  0xffc02e80   /* CAN Controller 0 Mailbox 20 Data 0 Register */
+#define                  CAN0_MB20_DATA1  0xffc02e84   /* CAN Controller 0 Mailbox 20 Data 1 Register */
+#define                  CAN0_MB20_DATA2  0xffc02e88   /* CAN Controller 0 Mailbox 20 Data 2 Register */
+#define                  CAN0_MB20_DATA3  0xffc02e8c   /* CAN Controller 0 Mailbox 20 Data 3 Register */
+#define                 CAN0_MB20_LENGTH  0xffc02e90   /* CAN Controller 0 Mailbox 20 Length Register */
+#define              CAN0_MB20_TIMESTAMP  0xffc02e94   /* CAN Controller 0 Mailbox 20 Timestamp Register */
+#define                    CAN0_MB20_ID0  0xffc02e98   /* CAN Controller 0 Mailbox 20 ID0 Register */
+#define                    CAN0_MB20_ID1  0xffc02e9c   /* CAN Controller 0 Mailbox 20 ID1 Register */
+#define                  CAN0_MB21_DATA0  0xffc02ea0   /* CAN Controller 0 Mailbox 21 Data 0 Register */
+#define                  CAN0_MB21_DATA1  0xffc02ea4   /* CAN Controller 0 Mailbox 21 Data 1 Register */
+#define                  CAN0_MB21_DATA2  0xffc02ea8   /* CAN Controller 0 Mailbox 21 Data 2 Register */
+#define                  CAN0_MB21_DATA3  0xffc02eac   /* CAN Controller 0 Mailbox 21 Data 3 Register */
+#define                 CAN0_MB21_LENGTH  0xffc02eb0   /* CAN Controller 0 Mailbox 21 Length Register */
+#define              CAN0_MB21_TIMESTAMP  0xffc02eb4   /* CAN Controller 0 Mailbox 21 Timestamp Register */
+#define                    CAN0_MB21_ID0  0xffc02eb8   /* CAN Controller 0 Mailbox 21 ID0 Register */
+#define                    CAN0_MB21_ID1  0xffc02ebc   /* CAN Controller 0 Mailbox 21 ID1 Register */
+#define                  CAN0_MB22_DATA0  0xffc02ec0   /* CAN Controller 0 Mailbox 22 Data 0 Register */
+#define                  CAN0_MB22_DATA1  0xffc02ec4   /* CAN Controller 0 Mailbox 22 Data 1 Register */
+#define                  CAN0_MB22_DATA2  0xffc02ec8   /* CAN Controller 0 Mailbox 22 Data 2 Register */
+#define                  CAN0_MB22_DATA3  0xffc02ecc   /* CAN Controller 0 Mailbox 22 Data 3 Register */
+#define                 CAN0_MB22_LENGTH  0xffc02ed0   /* CAN Controller 0 Mailbox 22 Length Register */
+#define              CAN0_MB22_TIMESTAMP  0xffc02ed4   /* CAN Controller 0 Mailbox 22 Timestamp Register */
+#define                    CAN0_MB22_ID0  0xffc02ed8   /* CAN Controller 0 Mailbox 22 ID0 Register */
+#define                    CAN0_MB22_ID1  0xffc02edc   /* CAN Controller 0 Mailbox 22 ID1 Register */
+#define                  CAN0_MB23_DATA0  0xffc02ee0   /* CAN Controller 0 Mailbox 23 Data 0 Register */
+#define                  CAN0_MB23_DATA1  0xffc02ee4   /* CAN Controller 0 Mailbox 23 Data 1 Register */
+#define                  CAN0_MB23_DATA2  0xffc02ee8   /* CAN Controller 0 Mailbox 23 Data 2 Register */
+#define                  CAN0_MB23_DATA3  0xffc02eec   /* CAN Controller 0 Mailbox 23 Data 3 Register */
+#define                 CAN0_MB23_LENGTH  0xffc02ef0   /* CAN Controller 0 Mailbox 23 Length Register */
+#define              CAN0_MB23_TIMESTAMP  0xffc02ef4   /* CAN Controller 0 Mailbox 23 Timestamp Register */
+#define                    CAN0_MB23_ID0  0xffc02ef8   /* CAN Controller 0 Mailbox 23 ID0 Register */
+#define                    CAN0_MB23_ID1  0xffc02efc   /* CAN Controller 0 Mailbox 23 ID1 Register */
+#define                  CAN0_MB24_DATA0  0xffc02f00   /* CAN Controller 0 Mailbox 24 Data 0 Register */
+#define                  CAN0_MB24_DATA1  0xffc02f04   /* CAN Controller 0 Mailbox 24 Data 1 Register */
+#define                  CAN0_MB24_DATA2  0xffc02f08   /* CAN Controller 0 Mailbox 24 Data 2 Register */
+#define                  CAN0_MB24_DATA3  0xffc02f0c   /* CAN Controller 0 Mailbox 24 Data 3 Register */
+#define                 CAN0_MB24_LENGTH  0xffc02f10   /* CAN Controller 0 Mailbox 24 Length Register */
+#define              CAN0_MB24_TIMESTAMP  0xffc02f14   /* CAN Controller 0 Mailbox 24 Timestamp Register */
+#define                    CAN0_MB24_ID0  0xffc02f18   /* CAN Controller 0 Mailbox 24 ID0 Register */
+#define                    CAN0_MB24_ID1  0xffc02f1c   /* CAN Controller 0 Mailbox 24 ID1 Register */
+#define                  CAN0_MB25_DATA0  0xffc02f20   /* CAN Controller 0 Mailbox 25 Data 0 Register */
+#define                  CAN0_MB25_DATA1  0xffc02f24   /* CAN Controller 0 Mailbox 25 Data 1 Register */
+#define                  CAN0_MB25_DATA2  0xffc02f28   /* CAN Controller 0 Mailbox 25 Data 2 Register */
+#define                  CAN0_MB25_DATA3  0xffc02f2c   /* CAN Controller 0 Mailbox 25 Data 3 Register */
+#define                 CAN0_MB25_LENGTH  0xffc02f30   /* CAN Controller 0 Mailbox 25 Length Register */
+#define              CAN0_MB25_TIMESTAMP  0xffc02f34   /* CAN Controller 0 Mailbox 25 Timestamp Register */
+#define                    CAN0_MB25_ID0  0xffc02f38   /* CAN Controller 0 Mailbox 25 ID0 Register */
+#define                    CAN0_MB25_ID1  0xffc02f3c   /* CAN Controller 0 Mailbox 25 ID1 Register */
+#define                  CAN0_MB26_DATA0  0xffc02f40   /* CAN Controller 0 Mailbox 26 Data 0 Register */
+#define                  CAN0_MB26_DATA1  0xffc02f44   /* CAN Controller 0 Mailbox 26 Data 1 Register */
+#define                  CAN0_MB26_DATA2  0xffc02f48   /* CAN Controller 0 Mailbox 26 Data 2 Register */
+#define                  CAN0_MB26_DATA3  0xffc02f4c   /* CAN Controller 0 Mailbox 26 Data 3 Register */
+#define                 CAN0_MB26_LENGTH  0xffc02f50   /* CAN Controller 0 Mailbox 26 Length Register */
+#define              CAN0_MB26_TIMESTAMP  0xffc02f54   /* CAN Controller 0 Mailbox 26 Timestamp Register */
+#define                    CAN0_MB26_ID0  0xffc02f58   /* CAN Controller 0 Mailbox 26 ID0 Register */
+#define                    CAN0_MB26_ID1  0xffc02f5c   /* CAN Controller 0 Mailbox 26 ID1 Register */
+#define                  CAN0_MB27_DATA0  0xffc02f60   /* CAN Controller 0 Mailbox 27 Data 0 Register */
+#define                  CAN0_MB27_DATA1  0xffc02f64   /* CAN Controller 0 Mailbox 27 Data 1 Register */
+#define                  CAN0_MB27_DATA2  0xffc02f68   /* CAN Controller 0 Mailbox 27 Data 2 Register */
+#define                  CAN0_MB27_DATA3  0xffc02f6c   /* CAN Controller 0 Mailbox 27 Data 3 Register */
+#define                 CAN0_MB27_LENGTH  0xffc02f70   /* CAN Controller 0 Mailbox 27 Length Register */
+#define              CAN0_MB27_TIMESTAMP  0xffc02f74   /* CAN Controller 0 Mailbox 27 Timestamp Register */
+#define                    CAN0_MB27_ID0  0xffc02f78   /* CAN Controller 0 Mailbox 27 ID0 Register */
+#define                    CAN0_MB27_ID1  0xffc02f7c   /* CAN Controller 0 Mailbox 27 ID1 Register */
+#define                  CAN0_MB28_DATA0  0xffc02f80   /* CAN Controller 0 Mailbox 28 Data 0 Register */
+#define                  CAN0_MB28_DATA1  0xffc02f84   /* CAN Controller 0 Mailbox 28 Data 1 Register */
+#define                  CAN0_MB28_DATA2  0xffc02f88   /* CAN Controller 0 Mailbox 28 Data 2 Register */
+#define                  CAN0_MB28_DATA3  0xffc02f8c   /* CAN Controller 0 Mailbox 28 Data 3 Register */
+#define                 CAN0_MB28_LENGTH  0xffc02f90   /* CAN Controller 0 Mailbox 28 Length Register */
+#define              CAN0_MB28_TIMESTAMP  0xffc02f94   /* CAN Controller 0 Mailbox 28 Timestamp Register */
+#define                    CAN0_MB28_ID0  0xffc02f98   /* CAN Controller 0 Mailbox 28 ID0 Register */
+#define                    CAN0_MB28_ID1  0xffc02f9c   /* CAN Controller 0 Mailbox 28 ID1 Register */
+#define                  CAN0_MB29_DATA0  0xffc02fa0   /* CAN Controller 0 Mailbox 29 Data 0 Register */
+#define                  CAN0_MB29_DATA1  0xffc02fa4   /* CAN Controller 0 Mailbox 29 Data 1 Register */
+#define                  CAN0_MB29_DATA2  0xffc02fa8   /* CAN Controller 0 Mailbox 29 Data 2 Register */
+#define                  CAN0_MB29_DATA3  0xffc02fac   /* CAN Controller 0 Mailbox 29 Data 3 Register */
+#define                 CAN0_MB29_LENGTH  0xffc02fb0   /* CAN Controller 0 Mailbox 29 Length Register */
+#define              CAN0_MB29_TIMESTAMP  0xffc02fb4   /* CAN Controller 0 Mailbox 29 Timestamp Register */
+#define                    CAN0_MB29_ID0  0xffc02fb8   /* CAN Controller 0 Mailbox 29 ID0 Register */
+#define                    CAN0_MB29_ID1  0xffc02fbc   /* CAN Controller 0 Mailbox 29 ID1 Register */
+#define                  CAN0_MB30_DATA0  0xffc02fc0   /* CAN Controller 0 Mailbox 30 Data 0 Register */
+#define                  CAN0_MB30_DATA1  0xffc02fc4   /* CAN Controller 0 Mailbox 30 Data 1 Register */
+#define                  CAN0_MB30_DATA2  0xffc02fc8   /* CAN Controller 0 Mailbox 30 Data 2 Register */
+#define                  CAN0_MB30_DATA3  0xffc02fcc   /* CAN Controller 0 Mailbox 30 Data 3 Register */
+#define                 CAN0_MB30_LENGTH  0xffc02fd0   /* CAN Controller 0 Mailbox 30 Length Register */
+#define              CAN0_MB30_TIMESTAMP  0xffc02fd4   /* CAN Controller 0 Mailbox 30 Timestamp Register */
+#define                    CAN0_MB30_ID0  0xffc02fd8   /* CAN Controller 0 Mailbox 30 ID0 Register */
+#define                    CAN0_MB30_ID1  0xffc02fdc   /* CAN Controller 0 Mailbox 30 ID1 Register */
+#define                  CAN0_MB31_DATA0  0xffc02fe0   /* CAN Controller 0 Mailbox 31 Data 0 Register */
+#define                  CAN0_MB31_DATA1  0xffc02fe4   /* CAN Controller 0 Mailbox 31 Data 1 Register */
+#define                  CAN0_MB31_DATA2  0xffc02fe8   /* CAN Controller 0 Mailbox 31 Data 2 Register */
+#define                  CAN0_MB31_DATA3  0xffc02fec   /* CAN Controller 0 Mailbox 31 Data 3 Register */
+#define                 CAN0_MB31_LENGTH  0xffc02ff0   /* CAN Controller 0 Mailbox 31 Length Register */
+#define              CAN0_MB31_TIMESTAMP  0xffc02ff4   /* CAN Controller 0 Mailbox 31 Timestamp Register */
+#define                    CAN0_MB31_ID0  0xffc02ff8   /* CAN Controller 0 Mailbox 31 ID0 Register */
+#define                    CAN0_MB31_ID1  0xffc02ffc   /* CAN Controller 0 Mailbox 31 ID1 Register */
+
+/* UART3 Registers */
+
+#define                        UART3_DLL  0xffc03100   /* Divisor Latch Low Byte */
+#define                        UART3_DLH  0xffc03104   /* Divisor Latch High Byte */
+#define                       UART3_GCTL  0xffc03108   /* Global Control Register */
+#define                        UART3_LCR  0xffc0310c   /* Line Control Register */
+#define                        UART3_MCR  0xffc03110   /* Modem Control Register */
+#define                        UART3_LSR  0xffc03114   /* Line Status Register */
+#define                        UART3_MSR  0xffc03118   /* Modem Status Register */
+#define                        UART3_SCR  0xffc0311c   /* Scratch Register */
+#define                    UART3_IER_SET  0xffc03120   /* Interrupt Enable Register Set */
+#define                  UART3_IER_CLEAR  0xffc03124   /* Interrupt Enable Register Clear */
+#define                        UART3_THR  0xffc03128   /* Transmit Hold Register */
+#define                        UART3_RBR  0xffc0312c   /* Receive Buffer Register */
+
+/* NFC Registers */
+
+#define                          NFC_CTL  0xffc03b00   /* NAND Control Register */
+#define                         NFC_STAT  0xffc03b04   /* NAND Status Register */
+#define                      NFC_IRQSTAT  0xffc03b08   /* NAND Interrupt Status Register */
+#define                      NFC_IRQMASK  0xffc03b0c   /* NAND Interrupt Mask Register */
+#define                         NFC_ECC0  0xffc03b10   /* NAND ECC Register 0 */
+#define                         NFC_ECC1  0xffc03b14   /* NAND ECC Register 1 */
+#define                         NFC_ECC2  0xffc03b18   /* NAND ECC Register 2 */
+#define                         NFC_ECC3  0xffc03b1c   /* NAND ECC Register 3 */
+#define                        NFC_COUNT  0xffc03b20   /* NAND ECC Count Register */
+#define                          NFC_RST  0xffc03b24   /* NAND ECC Reset Register */
+#define                        NFC_PGCTL  0xffc03b28   /* NAND Page Control Register */
+#define                         NFC_READ  0xffc03b2c   /* NAND Read Data Register */
+#define                         NFC_ADDR  0xffc03b40   /* NAND Address Register */
+#define                          NFC_CMD  0xffc03b44   /* NAND Command Register */
+#define                      NFC_DATA_WR  0xffc03b48   /* NAND Data Write Register */
+#define                      NFC_DATA_RD  0xffc03b4c   /* NAND Data Read Register */
+
+/* Counter Registers */
+
+#define                       CNT_CONFIG  0xffc04200   /* Configuration Register */
+#define                        CNT_IMASK  0xffc04204   /* Interrupt Mask Register */
+#define                       CNT_STATUS  0xffc04208   /* Status Register */
+#define                      CNT_COMMAND  0xffc0420c   /* Command Register */
+#define                     CNT_DEBOUNCE  0xffc04210   /* Debounce Register */
+#define                      CNT_COUNTER  0xffc04214   /* Counter Register */
+#define                          CNT_MAX  0xffc04218   /* Maximal Count Register */
+#define                          CNT_MIN  0xffc0421c   /* Minimal Count Register */
+
+/* OTP/FUSE Registers */
+
+#define                      OTP_CONTROL  0xffc04300   /* OTP/Fuse Control Register */
+#define                          OTP_BEN  0xffc04304   /* OTP/Fuse Byte Enable */
+#define                       OTP_STATUS  0xffc04308   /* OTP/Fuse Status */
+#define                       OTP_TIMING  0xffc0430c   /* OTP/Fuse Access Timing */
+
+/* Security Registers */
+
+#define                    SECURE_SYSSWT  0xffc04320   /* Secure System Switches */
+#define                   SECURE_CONTROL  0xffc04324   /* Secure Control */
+#define                    SECURE_STATUS  0xffc04328   /* Secure Status */
+
+/* DMA Peripheral Mux Register */
+
+#define                    DMAC1_PERIMUX  0xffc04340   /* DMA Controller 1 Peripheral Multiplexer Register */
+
+/* OTP Read/Write Data Buffer Registers */
+
+#define                        OTP_DATA0  0xffc04380   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+#define                        OTP_DATA1  0xffc04384   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+#define                        OTP_DATA2  0xffc04388   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+#define                        OTP_DATA3  0xffc0438c   /* OTP/Fuse Data (OTP_DATA0-3) accesses the fuse read write buffer */
+
+/* Handshake MDMA is not defined in the shared file because it is not available on the ADSP-BF542 processor */
+
+/* ********************************************************** */
+/*     SINGLE BIT MACRO PAIRS (bit mask and negated one)      */
+/*     and MULTI BIT READ MACROS                              */
+/* ********************************************************** */
+
+/* Bit masks for SIC_IAR0 */
+
+#define            IRQ_PLL_WAKEUP  0x1        /* PLL Wakeup */
+#define           nIRQ_PLL_WAKEUP  0x0       
+
+/* Bit masks for SIC_IWR0, SIC_IMASK0, SIC_ISR0 */
+
+#define              IRQ_DMA0_ERR  0x2        /* DMA Controller 0 Error */
+#define             nIRQ_DMA0_ERR  0x0       
+#define             IRQ_EPPI0_ERR  0x4        /* EPPI0 Error */
+#define            nIRQ_EPPI0_ERR  0x0       
+#define            IRQ_SPORT0_ERR  0x8        /* SPORT0 Error */
+#define           nIRQ_SPORT0_ERR  0x0       
+#define            IRQ_SPORT1_ERR  0x10       /* SPORT1 Error */
+#define           nIRQ_SPORT1_ERR  0x0       
+#define              IRQ_SPI0_ERR  0x20       /* SPI0 Error */
+#define             nIRQ_SPI0_ERR  0x0       
+#define             IRQ_UART0_ERR  0x40       /* UART0 Error */
+#define            nIRQ_UART0_ERR  0x0       
+#define                   IRQ_RTC  0x80       /* Real-Time Clock */
+#define                  nIRQ_RTC  0x0       
+#define                 IRQ_DMA12  0x100      /* DMA Channel 12 */
+#define                nIRQ_DMA12  0x0       
+#define                  IRQ_DMA0  0x200      /* DMA Channel 0 */
+#define                 nIRQ_DMA0  0x0       
+#define                  IRQ_DMA1  0x400      /* DMA Channel 1 */
+#define                 nIRQ_DMA1  0x0       
+#define                  IRQ_DMA2  0x800      /* DMA Channel 2 */
+#define                 nIRQ_DMA2  0x0       
+#define                  IRQ_DMA3  0x1000     /* DMA Channel 3 */
+#define                 nIRQ_DMA3  0x0       
+#define                  IRQ_DMA4  0x2000     /* DMA Channel 4 */
+#define                 nIRQ_DMA4  0x0       
+#define                  IRQ_DMA6  0x4000     /* DMA Channel 6 */
+#define                 nIRQ_DMA6  0x0       
+#define                  IRQ_DMA7  0x8000     /* DMA Channel 7 */
+#define                 nIRQ_DMA7  0x0       
+#define                 IRQ_PINT0  0x80000    /* Pin Interrupt 0 */
+#define                nIRQ_PINT0  0x0       
+#define                 IRQ_PINT1  0x100000   /* Pin Interrupt 1 */
+#define                nIRQ_PINT1  0x0       
+#define                 IRQ_MDMA0  0x200000   /* Memory DMA Stream 0 */
+#define                nIRQ_MDMA0  0x0       
+#define                 IRQ_MDMA1  0x400000   /* Memory DMA Stream 1 */
+#define                nIRQ_MDMA1  0x0       
+#define                  IRQ_WDOG  0x800000   /* Watchdog Timer */
+#define                 nIRQ_WDOG  0x0       
+#define              IRQ_DMA1_ERR  0x1000000  /* DMA Controller 1 Error */
+#define             nIRQ_DMA1_ERR  0x0       
+#define            IRQ_SPORT2_ERR  0x2000000  /* SPORT2 Error */
+#define           nIRQ_SPORT2_ERR  0x0       
+#define            IRQ_SPORT3_ERR  0x4000000  /* SPORT3 Error */
+#define           nIRQ_SPORT3_ERR  0x0       
+#define               IRQ_MXVR_SD  0x8000000  /* MXVR Synchronous Data */
+#define              nIRQ_MXVR_SD  0x0       
+#define              IRQ_SPI1_ERR  0x10000000 /* SPI1 Error */
+#define             nIRQ_SPI1_ERR  0x0       
+#define              IRQ_SPI2_ERR  0x20000000 /* SPI2 Error */
+#define             nIRQ_SPI2_ERR  0x0       
+#define             IRQ_UART1_ERR  0x40000000 /* UART1 Error */
+#define            nIRQ_UART1_ERR  0x0       
+#define             IRQ_UART2_ERR  0x80000000 /* UART2 Error */
+#define            nIRQ_UART2_ERR  0x0       
+
+/* Bit masks for SIC_IWR1, SIC_IMASK1, SIC_ISR1 */
+
+#define              IRQ_CAN0_ERR  0x1        /* CAN0 Error */
+#define             nIRQ_CAN0_ERR  0x0       
+#define                 IRQ_DMA18  0x2        /* DMA Channel 18 */
+#define                nIRQ_DMA18  0x0       
+#define                 IRQ_DMA19  0x4        /* DMA Channel 19 */
+#define                nIRQ_DMA19  0x0       
+#define                 IRQ_DMA20  0x8        /* DMA Channel 20 */
+#define                nIRQ_DMA20  0x0       
+#define                 IRQ_DMA21  0x10       /* DMA Channel 21 */
+#define                nIRQ_DMA21  0x0       
+#define                 IRQ_DMA13  0x20       /* DMA Channel 13 */
+#define                nIRQ_DMA13  0x0       
+#define                 IRQ_DMA14  0x40       /* DMA Channel 14 */
+#define                nIRQ_DMA14  0x0       
+#define                  IRQ_DMA5  0x80       /* DMA Channel 5 */
+#define                 nIRQ_DMA5  0x0       
+#define                 IRQ_DMA23  0x100      /* DMA Channel 23 */
+#define                nIRQ_DMA23  0x0       
+#define                  IRQ_DMA8  0x200      /* DMA Channel 8 */
+#define                 nIRQ_DMA8  0x0       
+#define                  IRQ_DMA9  0x400      /* DMA Channel 9 */
+#define                 nIRQ_DMA9  0x0       
+#define                 IRQ_DMA10  0x800      /* DMA Channel 10 */
+#define                nIRQ_DMA10  0x0       
+#define                 IRQ_DMA11  0x1000     /* DMA Channel 11 */
+#define                nIRQ_DMA11  0x0       
+#define                  IRQ_TWI0  0x2000     /* TWI0 */
+#define                 nIRQ_TWI0  0x0       
+#define                  IRQ_TWI1  0x4000     /* TWI1 */
+#define                 nIRQ_TWI1  0x0       
+#define               IRQ_CAN0_RX  0x8000     /* CAN0 Receive */
+#define              nIRQ_CAN0_RX  0x0       
+#define               IRQ_CAN0_TX  0x10000    /* CAN0 Transmit */
+#define              nIRQ_CAN0_TX  0x0       
+#define                 IRQ_MDMA2  0x20000    /* Memory DMA Stream 0 */
+#define                nIRQ_MDMA2  0x0       
+#define                 IRQ_MDMA3  0x40000    /* Memory DMA Stream 1 */
+#define                nIRQ_MDMA3  0x0       
+#define             IRQ_MXVR_STAT  0x80000    /* MXVR Status */
+#define            nIRQ_MXVR_STAT  0x0       
+#define               IRQ_MXVR_CM  0x100000   /* MXVR Control Message */
+#define              nIRQ_MXVR_CM  0x0       
+#define               IRQ_MXVR_AP  0x200000   /* MXVR Asynchronous Packet */
+#define              nIRQ_MXVR_AP  0x0       
+#define             IRQ_EPPI1_ERR  0x400000   /* EPPI1 Error */
+#define            nIRQ_EPPI1_ERR  0x0       
+#define             IRQ_EPPI2_ERR  0x800000   /* EPPI2 Error */
+#define            nIRQ_EPPI2_ERR  0x0       
+#define             IRQ_UART3_ERR  0x1000000  /* UART3 Error */
+#define            nIRQ_UART3_ERR  0x0       
+#define              IRQ_HOST_ERR  0x2000000  /* Host DMA Port Error */
+#define             nIRQ_HOST_ERR  0x0       
+#define               IRQ_USB_ERR  0x4000000  /* USB Error */
+#define              nIRQ_USB_ERR  0x0       
+#define              IRQ_PIXC_ERR  0x8000000  /* Pixel Compositor Error */
+#define             nIRQ_PIXC_ERR  0x0       
+#define               IRQ_NFC_ERR  0x10000000 /* Nand Flash Controller Error */
+#define              nIRQ_NFC_ERR  0x0       
+#define             IRQ_ATAPI_ERR  0x20000000 /* ATAPI Error */
+#define            nIRQ_ATAPI_ERR  0x0       
+#define              IRQ_CAN1_ERR  0x40000000 /* CAN1 Error */
+#define             nIRQ_CAN1_ERR  0x0       
+#define             IRQ_DMAR0_ERR  0x80000000 /* DMAR0 Overflow Error */
+#define            nIRQ_DMAR0_ERR  0x0       
+#define             IRQ_DMAR1_ERR  0x80000000 /* DMAR1 Overflow Error */
+#define            nIRQ_DMAR1_ERR  0x0       
+#define                 IRQ_DMAR0  0x80000000 /* DMAR0 Block */
+#define                nIRQ_DMAR0  0x0       
+#define                 IRQ_DMAR1  0x80000000 /* DMAR1 Block */
+#define                nIRQ_DMAR1  0x0       
+
+/* Bit masks for SIC_IWR2, SIC_IMASK2, SIC_ISR2 */
+
+#define                 IRQ_DMA15  0x1        /* DMA Channel 15 */
+#define                nIRQ_DMA15  0x0       
+#define                 IRQ_DMA16  0x2        /* DMA Channel 16 */
+#define                nIRQ_DMA16  0x0       
+#define                 IRQ_DMA17  0x4        /* DMA Channel 17 */
+#define                nIRQ_DMA17  0x0       
+#define                 IRQ_DMA22  0x8        /* DMA Channel 22 */
+#define                nIRQ_DMA22  0x0       
+#define                   IRQ_CNT  0x10       /* Counter */
+#define                  nIRQ_CNT  0x0       
+#define                   IRQ_KEY  0x20       /* Keypad */
+#define                  nIRQ_KEY  0x0       
+#define               IRQ_CAN1_RX  0x40       /* CAN1 Receive */
+#define              nIRQ_CAN1_RX  0x0       
+#define               IRQ_CAN1_TX  0x80       /* CAN1 Transmit */
+#define              nIRQ_CAN1_TX  0x0       
+#define             IRQ_SDH_MASK0  0x100      /* SDH Mask 0 */
+#define            nIRQ_SDH_MASK0  0x0       
+#define             IRQ_SDH_MASK1  0x200      /* SDH Mask 1 */
+#define            nIRQ_SDH_MASK1  0x0       
+#define              IRQ_USB_EINT  0x400      /* USB Exception */
+#define             nIRQ_USB_EINT  0x0       
+#define              IRQ_USB_INT0  0x800      /* USB Interrupt 0 */
+#define             nIRQ_USB_INT0  0x0       
+#define              IRQ_USB_INT1  0x1000     /* USB Interrupt 1 */
+#define             nIRQ_USB_INT1  0x0       
+#define              IRQ_USB_INT2  0x2000     /* USB Interrupt 2 */
+#define             nIRQ_USB_INT2  0x0       
+#define            IRQ_USB_DMAINT  0x4000     /* USB DMA */
+#define           nIRQ_USB_DMAINT  0x0       
+#define                IRQ_OTPSEC  0x8000     /* OTP Access Complete */
+#define               nIRQ_OTPSEC  0x0       
+#define                IRQ_TIMER0  0x400000   /* Timer 0 */
+#define               nIRQ_TIMER0  0x0       
+#define                IRQ_TIMER1  0x800000   /* Timer 1 */
+#define               nIRQ_TIMER1  0x0       
+#define                IRQ_TIMER2  0x1000000  /* Timer 2 */
+#define               nIRQ_TIMER2  0x0       
+#define                IRQ_TIMER3  0x2000000  /* Timer 3 */
+#define               nIRQ_TIMER3  0x0       
+#define                IRQ_TIMER4  0x4000000  /* Timer 4 */
+#define               nIRQ_TIMER4  0x0       
+#define                IRQ_TIMER5  0x8000000  /* Timer 5 */
+#define               nIRQ_TIMER5  0x0       
+#define                IRQ_TIMER6  0x10000000 /* Timer 6 */
+#define               nIRQ_TIMER6  0x0       
+#define                IRQ_TIMER7  0x20000000 /* Timer 7 */
+#define               nIRQ_TIMER7  0x0       
+#define                 IRQ_PINT2  0x40000000 /* Pin Interrupt 2 */
+#define                nIRQ_PINT2  0x0       
+#define                 IRQ_PINT3  0x80000000 /* Pin Interrupt 3 */
+#define                nIRQ_PINT3  0x0       
+
+/* Bit masks for DMAx_CONFIG, MDMA_Sx_CONFIG, MDMA_Dx_CONFIG */
+
+#define                     DMAEN  0x1        /* DMA Channel Enable */
+#define                    nDMAEN  0x0       
+#define                       WNR  0x2        /* DMA Direction */
+#define                      nWNR  0x0       
+#define                    WDSIZE  0xc        /* Transfer Word Size */
+#define                     DMA2D  0x10       /* DMA Mode */
+#define                    nDMA2D  0x0       
+#define                   RESTART  0x20       /* Work Unit Transitions */
+#define                  nRESTART  0x0       
+#define                    DI_SEL  0x40       /* Data Interrupt Timing Select */
+#define                   nDI_SEL  0x0       
+#define                     DI_EN  0x80       /* Data Interrupt Enable */
+#define                    nDI_EN  0x0       
+#define                    NDSIZE  0xf00      /* Flex Descriptor Size */
+#define                   DMAFLOW  0xf000     /* Next Operation */
+
+/* Bit masks for DMAx_IRQ_STATUS, MDMA_Sx_IRQ_STATUS, MDMA_Dx_IRQ_STATUS */
+
+#define                  DMA_DONE  0x1        /* DMA Completion Interrupt Status */
+#define                 nDMA_DONE  0x0       
+#define                   DMA_ERR  0x2        /* DMA Error Interrupt Status */
+#define                  nDMA_ERR  0x0       
+#define                    DFETCH  0x4        /* DMA Descriptor Fetch */
+#define                   nDFETCH  0x0       
+#define                   DMA_RUN  0x8        /* DMA Channel Running */
+#define                  nDMA_RUN  0x0       
+
+/* Bit masks for DMAx_PERIPHERAL_MAP, MDMA_Sx_IRQ_STATUS, MDMA_Dx_IRQ_STATUS */
+
+#define                     CTYPE  0x40       /* DMA Channel Type */
+#define                    nCTYPE  0x0       
+#define                      PMAP  0xf000     /* Peripheral Mapped To This Channel */
+
+/* Bit masks for DMACx_TCPER */
+
+#define        DCB_TRAFFIC_PERIOD  0xf        /* DCB Traffic Control Period */
+#define        DEB_TRAFFIC_PERIOD  0xf0       /* DEB Traffic Control Period */
+#define        DAB_TRAFFIC_PERIOD  0x700      /* DAB Traffic Control Period */
+#define   MDMA_ROUND_ROBIN_PERIOD  0xf800     /* MDMA Round Robin Period */
+
+/* Bit masks for DMACx_TCCNT */
+
+#define         DCB_TRAFFIC_COUNT  0xf        /* DCB Traffic Control Count */
+#define         DEB_TRAFFIC_COUNT  0xf0       /* DEB Traffic Control Count */
+#define         DAB_TRAFFIC_COUNT  0x700      /* DAB Traffic Control Count */
+#define    MDMA_ROUND_ROBIN_COUNT  0xf800     /* MDMA Round Robin Count */
+
+/* Bit masks for DMAC1_PERIMUX */
+
+#define                   PMUXSDH  0x1        /* Peripheral Select for DMA22 channel */
+#define                  nPMUXSDH  0x0       
+
+/* Bit masks for EBIU_AMGCTL */
+
+#define                    AMCKEN  0x1        /* Async Memory Enable */
+#define                   nAMCKEN  0x0       
+#define                     AMBEN  0xe        /* Async bank enable */
+
+/* Bit masks for EBIU_AMBCTL0 */
+
+#define                   B0RDYEN  0x1        /* Bank 0 ARDY Enable */
+#define                  nB0RDYEN  0x0       
+#define                  B0RDYPOL  0x2        /* Bank 0 ARDY Polarity */
+#define                 nB0RDYPOL  0x0       
+#define                      B0TT  0xc        /* Bank 0 transition time */
+#define                      B0ST  0x30       /* Bank 0 Setup time */
+#define                      B0HT  0xc0       /* Bank 0 Hold time */
+#define                     B0RAT  0xf00      /* Bank 0 Read access time */
+#define                     B0WAT  0xf000     /* Bank 0 write access time */
+#define                   B1RDYEN  0x10000    /* Bank 1 ARDY Enable */
+#define                  nB1RDYEN  0x0       
+#define                  B1RDYPOL  0x20000    /* Bank 1 ARDY Polarity */
+#define                 nB1RDYPOL  0x0       
+#define                      B1TT  0xc0000    /* Bank 1 transition time */
+#define                      B1ST  0x300000   /* Bank 1 Setup time */
+#define                      B1HT  0xc00000   /* Bank 1 Hold time */
+#define                     B1RAT  0xf000000  /* Bank 1 Read access time */
+#define                     B1WAT  0xf0000000 /* Bank 1 write access time */
+
+/* Bit masks for EBIU_AMBCTL1 */
+
+#define                   B2RDYEN  0x1        /* Bank 2 ARDY Enable */
+#define                  nB2RDYEN  0x0       
+#define                  B2RDYPOL  0x2        /* Bank 2 ARDY Polarity */
+#define                 nB2RDYPOL  0x0       
+#define                      B2TT  0xc        /* Bank 2 transition time */
+#define                      B2ST  0x30       /* Bank 2 Setup time */
+#define                      B2HT  0xc0       /* Bank 2 Hold time */
+#define                     B2RAT  0xf00      /* Bank 2 Read access time */
+#define                     B2WAT  0xf000     /* Bank 2 write access time */
+#define                   B3RDYEN  0x10000    /* Bank 3 ARDY Enable */
+#define                  nB3RDYEN  0x0       
+#define                  B3RDYPOL  0x20000    /* Bank 3 ARDY Polarity */
+#define                 nB3RDYPOL  0x0       
+#define                      B3TT  0xc0000    /* Bank 3 transition time */
+#define                      B3ST  0x300000   /* Bank 3 Setup time */
+#define                      B3HT  0xc00000   /* Bank 3 Hold time */
+#define                     B3RAT  0xf000000  /* Bank 3 Read access time */
+#define                     B3WAT  0xf0000000 /* Bank 3 write access time */
+
+/* Bit masks for EBIU_MBSCTL */
+
+#define                  AMSB0CTL  0x3        /* Async Memory Bank 0 select */
+#define                  AMSB1CTL  0xc        /* Async Memory Bank 1 select */
+#define                  AMSB2CTL  0x30       /* Async Memory Bank 2 select */
+#define                  AMSB3CTL  0xc0       /* Async Memory Bank 3 select */
+
+/* Bit masks for EBIU_MODE */
+
+#define                    B0MODE  0x3        /* Async Memory Bank 0 Access Mode */
+#define                    B1MODE  0xc        /* Async Memory Bank 1 Access Mode */
+#define                    B2MODE  0x30       /* Async Memory Bank 2 Access Mode */
+#define                    B3MODE  0xc0       /* Async Memory Bank 3 Access Mode */
+
+/* Bit masks for EBIU_FCTL */
+
+#define               TESTSETLOCK  0x1        /* Test set lock */
+#define              nTESTSETLOCK  0x0       
+#define                      BCLK  0x6        /* Burst clock frequency */
+#define                      PGWS  0x38       /* Page wait states */
+#define                      PGSZ  0x40       /* Page size */
+#define                     nPGSZ  0x0       
+#define                      RDDL  0x380      /* Read data delay */
+
+/* Bit masks for EBIU_ARBSTAT */
+
+#define                   ARBSTAT  0x1        /* Arbitration status */
+#define                  nARBSTAT  0x0       
+#define                    BGSTAT  0x2        /* Bus grant status */
+#define                   nBGSTAT  0x0       
+
+/* Bit masks for EBIU_DDRCTL0 */
+
+#define                     TREFI  0x3fff     /* Refresh Interval */
+#define                      TRFC  0x3c000    /* Auto-refresh command period */
+#define                       TRP  0x3c0000   /* Pre charge-to-active command period */
+#define                      TRAS  0x3c00000  /* Min Active-to-pre charge time */
+#define                       TRC  0x3c000000 /* Active-to-active time */
+
+/* Bit masks for EBIU_DDRCTL1 */
+
+#define                      TRCD  0xf        /* Active-to-Read/write delay */
+#define                       MRD  0xf0       /* Mode register set to active */
+#define                       TWR  0x300      /* Write Recovery time */
+#define               DDRDATWIDTH  0x3000     /* DDR data width */
+#define                  EXTBANKS  0xc000     /* External banks */
+#define               DDRDEVWIDTH  0x30000    /* DDR device width */
+#define                DDRDEVSIZE  0xc0000    /* DDR device size */
+#define                     TWWTR  0xf0000000 /* Write-to-read delay */
+
+/* Bit masks for EBIU_DDRCTL2 */
+
+#define               BURSTLENGTH  0x7        /* Burst length */
+#define                CASLATENCY  0x70       /* CAS latency */
+#define                  DLLRESET  0x100      /* DLL Reset */
+#define                 nDLLRESET  0x0       
+#define                      REGE  0x1000     /* Register mode enable */
+#define                     nREGE  0x0       
+
+/* Bit masks for EBIU_DDRCTL3 */
+
+#define                      PASR  0x7        /* Partial array self-refresh */
+
+/* Bit masks for EBIU_DDRQUE */
+
+#define                DEB1_PFLEN  0x3        /* Pre fetch length for DEB1 accesses */
+#define                DEB2_PFLEN  0xc        /* Pre fetch length for DEB2 accesses */
+#define                DEB3_PFLEN  0x30       /* Pre fetch length for DEB3 accesses */
+#define          DEB_ARB_PRIORITY  0x700      /* Arbitration between DEB busses */
+#define               DEB1_URGENT  0x1000     /* DEB1 Urgent */
+#define              nDEB1_URGENT  0x0       
+#define               DEB2_URGENT  0x2000     /* DEB2 Urgent */
+#define              nDEB2_URGENT  0x0       
+#define               DEB3_URGENT  0x4000     /* DEB3 Urgent */
+#define              nDEB3_URGENT  0x0       
+
+/* Bit masks for EBIU_ERRMST */
+
+#define                DEB1_ERROR  0x1        /* DEB1 Error */
+#define               nDEB1_ERROR  0x0       
+#define                DEB2_ERROR  0x2        /* DEB2 Error */
+#define               nDEB2_ERROR  0x0       
+#define                DEB3_ERROR  0x4        /* DEB3 Error */
+#define               nDEB3_ERROR  0x0       
+#define                CORE_ERROR  0x8        /* Core error */
+#define               nCORE_ERROR  0x0       
+#define                DEB_MERROR  0x10       /* DEB1 Error (2nd) */
+#define               nDEB_MERROR  0x0       
+#define               DEB2_MERROR  0x20       /* DEB2 Error (2nd) */
+#define              nDEB2_MERROR  0x0       
+#define               DEB3_MERROR  0x40       /* DEB3 Error (2nd) */
+#define              nDEB3_MERROR  0x0       
+#define               CORE_MERROR  0x80       /* Core Error (2nd) */
+#define              nCORE_MERROR  0x0       
+
+/* Bit masks for EBIU_ERRADD */
+
+#define             ERROR_ADDRESS  0xffffffff /* Error Address */
+
+/* Bit masks for EBIU_RSTCTL */
+
+#define                 DDRSRESET  0x1        /* DDR soft reset */
+#define                nDDRSRESET  0x0       
+#define               PFTCHSRESET  0x4        /* DDR prefetch reset */
+#define              nPFTCHSRESET  0x0       
+#define                     SRREQ  0x8        /* Self-refresh request */
+#define                    nSRREQ  0x0       
+#define                     SRACK  0x10       /* Self-refresh acknowledge */
+#define                    nSRACK  0x0       
+#define                MDDRENABLE  0x20       /* Mobile DDR enable */
+#define               nMDDRENABLE  0x0       
+
+/* Bit masks for EBIU_DDRBRC0 */
+
+#define                      BRC0  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBRC1 */
+
+#define                      BRC1  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBRC2 */
+
+#define                      BRC2  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBRC3 */
+
+#define                      BRC3  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBRC4 */
+
+#define                      BRC4  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBRC5 */
+
+#define                      BRC5  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBRC6 */
+
+#define                      BRC6  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBRC7 */
+
+#define                      BRC7  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC0 */
+
+#define                      BWC0  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC1 */
+
+#define                      BWC1  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC2 */
+
+#define                      BWC2  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC3 */
+
+#define                      BWC3  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC4 */
+
+#define                      BWC4  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC5 */
+
+#define                      BWC5  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC6 */
+
+#define                      BWC6  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRBWC7 */
+
+#define                      BWC7  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRACCT */
+
+#define                      ACCT  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRTACT */
+
+#define                      TECT  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRARCT */
+
+#define                      ARCT  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRGC0 */
+
+#define                       GC0  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRGC1 */
+
+#define                       GC1  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRGC2 */
+
+#define                       GC2  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRGC3 */
+
+#define                       GC3  0xffffffff /* Count */
+
+/* Bit masks for EBIU_DDRMCEN */
+
+#define                B0WCENABLE  0x1        /* Bank 0 write count enable */
+#define               nB0WCENABLE  0x0       
+#define                B1WCENABLE  0x2        /* Bank 1 write count enable */
+#define               nB1WCENABLE  0x0       
+#define                B2WCENABLE  0x4        /* Bank 2 write count enable */
+#define               nB2WCENABLE  0x0       
+#define                B3WCENABLE  0x8        /* Bank 3 write count enable */
+#define               nB3WCENABLE  0x0       
+#define                B4WCENABLE  0x10       /* Bank 4 write count enable */
+#define               nB4WCENABLE  0x0       
+#define                B5WCENABLE  0x20       /* Bank 5 write count enable */
+#define               nB5WCENABLE  0x0       
+#define                B6WCENABLE  0x40       /* Bank 6 write count enable */
+#define               nB6WCENABLE  0x0       
+#define                B7WCENABLE  0x80       /* Bank 7 write count enable */
+#define               nB7WCENABLE  0x0       
+#define                B0RCENABLE  0x100      /* Bank 0 read count enable */
+#define               nB0RCENABLE  0x0       
+#define                B1RCENABLE  0x200      /* Bank 1 read count enable */
+#define               nB1RCENABLE  0x0       
+#define                B2RCENABLE  0x400      /* Bank 2 read count enable */
+#define               nB2RCENABLE  0x0       
+#define                B3RCENABLE  0x800      /* Bank 3 read count enable */
+#define               nB3RCENABLE  0x0       
+#define                B4RCENABLE  0x1000     /* Bank 4 read count enable */
+#define               nB4RCENABLE  0x0       
+#define                B5RCENABLE  0x2000     /* Bank 5 read count enable */
+#define               nB5RCENABLE  0x0       
+#define                B6RCENABLE  0x4000     /* Bank 6 read count enable */
+#define               nB6RCENABLE  0x0       
+#define                B7RCENABLE  0x8000     /* Bank 7 read count enable */
+#define               nB7RCENABLE  0x0       
+#define             ROWACTCENABLE  0x10000    /* DDR Row activate count enable */
+#define            nROWACTCENABLE  0x0       
+#define                RWTCENABLE  0x20000    /* DDR R/W Turn around count enable */
+#define               nRWTCENABLE  0x0       
+#define                 ARCENABLE  0x40000    /* DDR Auto-refresh count enable */
+#define                nARCENABLE  0x0       
+#define                 GC0ENABLE  0x100000   /* DDR Grant count 0 enable */
+#define                nGC0ENABLE  0x0       
+#define                 GC1ENABLE  0x200000   /* DDR Grant count 1 enable */
+#define                nGC1ENABLE  0x0       
+#define                 GC2ENABLE  0x400000   /* DDR Grant count 2 enable */
+#define                nGC2ENABLE  0x0       
+#define                 GC3ENABLE  0x800000   /* DDR Grant count 3 enable */
+#define                nGC3ENABLE  0x0       
+#define                 GCCONTROL  0x3000000  /* DDR Grant Count Control */
+
+/* Bit masks for EBIU_DDRMCCL */
+
+#define                 CB0WCOUNT  0x1        /* Clear write count 0 */
+#define                nCB0WCOUNT  0x0       
+#define                 CB1WCOUNT  0x2        /* Clear write count 1 */
+#define                nCB1WCOUNT  0x0       
+#define                 CB2WCOUNT  0x4        /* Clear write count 2 */
+#define                nCB2WCOUNT  0x0       
+#define                 CB3WCOUNT  0x8        /* Clear write count 3 */
+#define                nCB3WCOUNT  0x0       
+#define                 CB4WCOUNT  0x10       /* Clear write count 4 */
+#define                nCB4WCOUNT  0x0       
+#define                 CB5WCOUNT  0x20       /* Clear write count 5 */
+#define                nCB5WCOUNT  0x0       
+#define                 CB6WCOUNT  0x40       /* Clear write count 6 */
+#define                nCB6WCOUNT  0x0       
+#define                 CB7WCOUNT  0x80       /* Clear write count 7 */
+#define                nCB7WCOUNT  0x0       
+#define                  CBRCOUNT  0x100      /* Clear read count 0 */
+#define                 nCBRCOUNT  0x0       
+#define                 CB1RCOUNT  0x200      /* Clear read count 1 */
+#define                nCB1RCOUNT  0x0       
+#define                 CB2RCOUNT  0x400      /* Clear read count 2 */
+#define                nCB2RCOUNT  0x0       
+#define                 CB3RCOUNT  0x800      /* Clear read count 3 */
+#define                nCB3RCOUNT  0x0       
+#define                 CB4RCOUNT  0x1000     /* Clear read count 4 */
+#define                nCB4RCOUNT  0x0       
+#define                 CB5RCOUNT  0x2000     /* Clear read count 5 */
+#define                nCB5RCOUNT  0x0       
+#define                 CB6RCOUNT  0x4000     /* Clear read count 6 */
+#define                nCB6RCOUNT  0x0       
+#define                 CB7RCOUNT  0x8000     /* Clear read count 7 */
+#define                nCB7RCOUNT  0x0       
+#define                  CRACOUNT  0x10000    /* Clear row activation count */
+#define                 nCRACOUNT  0x0       
+#define                CRWTACOUNT  0x20000    /* Clear R/W turn-around count */
+#define               nCRWTACOUNT  0x0       
+#define                  CARCOUNT  0x40000    /* Clear auto-refresh count */
+#define                 nCARCOUNT  0x0       
+#define                  CG0COUNT  0x100000   /* Clear grant count 0 */
+#define                 nCG0COUNT  0x0       
+#define                  CG1COUNT  0x200000   /* Clear grant count 1 */
+#define                 nCG1COUNT  0x0       
+#define                  CG2COUNT  0x400000   /* Clear grant count 2 */
+#define                 nCG2COUNT  0x0       
+#define                  CG3COUNT  0x800000   /* Clear grant count 3 */
+#define                 nCG3COUNT  0x0       
+
+/* Bit masks for (PORTx is PORTA - PORTJ) includes PORTx_FER, PORTx_SET, PORTx_CLEAR, PORTx_DIR_SET, PORTx_DIR_CLEAR, PORTx_INEN */
+
+#define                       Px0  0x1        /* GPIO 0 */
+#define                      nPx0  0x0       
+#define                       Px1  0x2        /* GPIO 1 */
+#define                      nPx1  0x0       
+#define                       Px2  0x4        /* GPIO 2 */
+#define                      nPx2  0x0       
+#define                       Px3  0x8        /* GPIO 3 */
+#define                      nPx3  0x0       
+#define                       Px4  0x10       /* GPIO 4 */
+#define                      nPx4  0x0       
+#define                       Px5  0x20       /* GPIO 5 */
+#define                      nPx5  0x0       
+#define                       Px6  0x40       /* GPIO 6 */
+#define                      nPx6  0x0       
+#define                       Px7  0x80       /* GPIO 7 */
+#define                      nPx7  0x0       
+#define                       Px8  0x100      /* GPIO 8 */
+#define                      nPx8  0x0       
+#define                       Px9  0x200      /* GPIO 9 */
+#define                      nPx9  0x0       
+#define                      Px10  0x400      /* GPIO 10 */
+#define                     nPx10  0x0       
+#define                      Px11  0x800      /* GPIO 11 */
+#define                     nPx11  0x0       
+#define                      Px12  0x1000     /* GPIO 12 */
+#define                     nPx12  0x0       
+#define                      Px13  0x2000     /* GPIO 13 */
+#define                     nPx13  0x0       
+#define                      Px14  0x4000     /* GPIO 14 */
+#define                     nPx14  0x0       
+#define                      Px15  0x8000     /* GPIO 15 */
+#define                     nPx15  0x0       
+
+/* Bit masks for PORTA_MUX - PORTJ_MUX */
+
+#define                      PxM0  0x3        /* GPIO Mux 0 */
+#define                      PxM1  0xc        /* GPIO Mux 1 */
+#define                      PxM2  0x30       /* GPIO Mux 2 */
+#define                      PxM3  0xc0       /* GPIO Mux 3 */
+#define                      PxM4  0x300      /* GPIO Mux 4 */
+#define                      PxM5  0xc00      /* GPIO Mux 5 */
+#define                      PxM6  0x3000     /* GPIO Mux 6 */
+#define                      PxM7  0xc000     /* GPIO Mux 7 */
+#define                      PxM8  0x30000    /* GPIO Mux 8 */
+#define                      PxM9  0xc0000    /* GPIO Mux 9 */
+#define                     PxM10  0x300000   /* GPIO Mux 10 */
+#define                     PxM11  0xc00000   /* GPIO Mux 11 */
+#define                     PxM12  0x3000000  /* GPIO Mux 12 */
+#define                     PxM13  0xc000000  /* GPIO Mux 13 */
+#define                     PxM14  0x30000000 /* GPIO Mux 14 */
+#define                     PxM15  0xc0000000 /* GPIO Mux 15 */
+
+
+/* Bit masks for PINTx_MASK_SET/CLEAR, PINTx_REQUEST, PINTx_LATCH, PINTx_EDGE_SET/CLEAR, PINTx_INVERT_SET/CLEAR, PINTx_PINTSTATE */
+
+#define                       IB0  0x1        /* Interrupt Bit 0 */
+#define                      nIB0  0x0       
+#define                       IB1  0x2        /* Interrupt Bit 1 */
+#define                      nIB1  0x0       
+#define                       IB2  0x4        /* Interrupt Bit 2 */
+#define                      nIB2  0x0       
+#define                       IB3  0x8        /* Interrupt Bit 3 */
+#define                      nIB3  0x0       
+#define                       IB4  0x10       /* Interrupt Bit 4 */
+#define                      nIB4  0x0       
+#define                       IB5  0x20       /* Interrupt Bit 5 */
+#define                      nIB5  0x0       
+#define                       IB6  0x40       /* Interrupt Bit 6 */
+#define                      nIB6  0x0       
+#define                       IB7  0x80       /* Interrupt Bit 7 */
+#define                      nIB7  0x0       
+#define                       IB8  0x100      /* Interrupt Bit 8 */
+#define                      nIB8  0x0       
+#define                       IB9  0x200      /* Interrupt Bit 9 */
+#define                      nIB9  0x0       
+#define                      IB10  0x400      /* Interrupt Bit 10 */
+#define                     nIB10  0x0       
+#define                      IB11  0x800      /* Interrupt Bit 11 */
+#define                     nIB11  0x0       
+#define                      IB12  0x1000     /* Interrupt Bit 12 */
+#define                     nIB12  0x0       
+#define                      IB13  0x2000     /* Interrupt Bit 13 */
+#define                     nIB13  0x0       
+#define                      IB14  0x4000     /* Interrupt Bit 14 */
+#define                     nIB14  0x0       
+#define                      IB15  0x8000     /* Interrupt Bit 15 */
+#define                     nIB15  0x0       
+
+/* Bit masks for TIMERx_CONFIG */
+
+#define                     TMODE  0x3        /* Timer Mode */
+#define                  PULSE_HI  0x4        /* Pulse Polarity */
+#define                 nPULSE_HI  0x0       
+#define                PERIOD_CNT  0x8        /* Period Count */
+#define               nPERIOD_CNT  0x0       
+#define                   IRQ_ENA  0x10       /* Interrupt Request Enable */
+#define                  nIRQ_ENA  0x0       
+#define                   TIN_SEL  0x20       /* Timer Input Select */
+#define                  nTIN_SEL  0x0       
+#define                   OUT_DIS  0x40       /* Output Pad Disable */
+#define                  nOUT_DIS  0x0       
+#define                   CLK_SEL  0x80       /* Timer Clock Select */
+#define                  nCLK_SEL  0x0       
+#define                 TOGGLE_HI  0x100      /* Toggle Mode */
+#define                nTOGGLE_HI  0x0       
+#define                   EMU_RUN  0x200      /* Emulation Behavior Select */
+#define                  nEMU_RUN  0x0       
+#define                   ERR_TYP  0xc000     /* Error Type */
+
+/* Bit masks for TIMER_ENABLE0 */
+
+#define                    TIMEN0  0x1        /* Timer 0 Enable */
+#define                   nTIMEN0  0x0       
+#define                    TIMEN1  0x2        /* Timer 1 Enable */
+#define                   nTIMEN1  0x0       
+#define                    TIMEN2  0x4        /* Timer 2 Enable */
+#define                   nTIMEN2  0x0       
+#define                    TIMEN3  0x8        /* Timer 3 Enable */
+#define                   nTIMEN3  0x0       
+#define                    TIMEN4  0x10       /* Timer 4 Enable */
+#define                   nTIMEN4  0x0       
+#define                    TIMEN5  0x20       /* Timer 5 Enable */
+#define                   nTIMEN5  0x0       
+#define                    TIMEN6  0x40       /* Timer 6 Enable */
+#define                   nTIMEN6  0x0       
+#define                    TIMEN7  0x80       /* Timer 7 Enable */
+#define                   nTIMEN7  0x0       
+
+/* Bit masks for TIMER_DISABLE0 */
+
+#define                   TIMDIS0  0x1        /* Timer 0 Disable */
+#define                  nTIMDIS0  0x0       
+#define                   TIMDIS1  0x2        /* Timer 1 Disable */
+#define                  nTIMDIS1  0x0       
+#define                   TIMDIS2  0x4        /* Timer 2 Disable */
+#define                  nTIMDIS2  0x0       
+#define                   TIMDIS3  0x8        /* Timer 3 Disable */
+#define                  nTIMDIS3  0x0       
+#define                   TIMDIS4  0x10       /* Timer 4 Disable */
+#define                  nTIMDIS4  0x0       
+#define                   TIMDIS5  0x20       /* Timer 5 Disable */
+#define                  nTIMDIS5  0x0       
+#define                   TIMDIS6  0x40       /* Timer 6 Disable */
+#define                  nTIMDIS6  0x0       
+#define                   TIMDIS7  0x80       /* Timer 7 Disable */
+#define                  nTIMDIS7  0x0       
+
+/* Bit masks for TIMER_STATUS0 */
+
+#define                    TIMIL0  0x1        /* Timer 0 Interrupt */
+#define                   nTIMIL0  0x0       
+#define                    TIMIL1  0x2        /* Timer 1 Interrupt */
+#define                   nTIMIL1  0x0       
+#define                    TIMIL2  0x4        /* Timer 2 Interrupt */
+#define                   nTIMIL2  0x0       
+#define                    TIMIL3  0x8        /* Timer 3 Interrupt */
+#define                   nTIMIL3  0x0       
+#define                 TOVF_ERR0  0x10       /* Timer 0 Counter Overflow */
+#define                nTOVF_ERR0  0x0       
+#define                 TOVF_ERR1  0x20       /* Timer 1 Counter Overflow */
+#define                nTOVF_ERR1  0x0       
+#define                 TOVF_ERR2  0x40       /* Timer 2 Counter Overflow */
+#define                nTOVF_ERR2  0x0       
+#define                 TOVF_ERR3  0x80       /* Timer 3 Counter Overflow */
+#define                nTOVF_ERR3  0x0       
+#define                     TRUN0  0x1000     /* Timer 0 Slave Enable Status */
+#define                    nTRUN0  0x0       
+#define                     TRUN1  0x2000     /* Timer 1 Slave Enable Status */
+#define                    nTRUN1  0x0       
+#define                     TRUN2  0x4000     /* Timer 2 Slave Enable Status */
+#define                    nTRUN2  0x0       
+#define                     TRUN3  0x8000     /* Timer 3 Slave Enable Status */
+#define                    nTRUN3  0x0       
+#define                    TIMIL4  0x10000    /* Timer 4 Interrupt */
+#define                   nTIMIL4  0x0       
+#define                    TIMIL5  0x20000    /* Timer 5 Interrupt */
+#define                   nTIMIL5  0x0       
+#define                    TIMIL6  0x40000    /* Timer 6 Interrupt */
+#define                   nTIMIL6  0x0       
+#define                    TIMIL7  0x80000    /* Timer 7 Interrupt */
+#define                   nTIMIL7  0x0       
+#define                 TOVF_ERR4  0x100000   /* Timer 4 Counter Overflow */
+#define                nTOVF_ERR4  0x0       
+#define                 TOVF_ERR5  0x200000   /* Timer 5 Counter Overflow */
+#define                nTOVF_ERR5  0x0       
+#define                 TOVF_ERR6  0x400000   /* Timer 6 Counter Overflow */
+#define                nTOVF_ERR6  0x0       
+#define                 TOVF_ERR7  0x800000   /* Timer 7 Counter Overflow */
+#define                nTOVF_ERR7  0x0       
+#define                     TRUN4  0x10000000 /* Timer 4 Slave Enable Status */
+#define                    nTRUN4  0x0       
+#define                     TRUN5  0x20000000 /* Timer 5 Slave Enable Status */
+#define                    nTRUN5  0x0       
+#define                     TRUN6  0x40000000 /* Timer 6 Slave Enable Status */
+#define                    nTRUN6  0x0       
+#define                     TRUN7  0x80000000 /* Timer 7 Slave Enable Status */
+#define                    nTRUN7  0x0       
+
+/* Bit masks for WDOG_CTL */
+
+#define                      WDEV  0x6        /* Watchdog Event */
+#define                      WDEN  0xff0      /* Watchdog Enable */
+#define                      WDRO  0x8000     /* Watchdog Rolled Over */
+#define                     nWDRO  0x0       
+
+/* Bit masks for CNT_CONFIG */
+
+#define                      CNTE  0x1        /* Counter Enable */
+#define                     nCNTE  0x0       
+#define                      DEBE  0x2        /* Debounce Enable */
+#define                     nDEBE  0x0       
+#define                    CDGINV  0x10       /* CDG Pin Polarity Invert */
+#define                   nCDGINV  0x0       
+#define                    CUDINV  0x20       /* CUD Pin Polarity Invert */
+#define                   nCUDINV  0x0       
+#define                    CZMINV  0x40       /* CZM Pin Polarity Invert */
+#define                   nCZMINV  0x0       
+#define                   CNTMODE  0x700      /* Counter Operating Mode */
+#define                      ZMZC  0x800      /* CZM Zeroes Counter Enable */
+#define                     nZMZC  0x0       
+#define                   BNDMODE  0x3000     /* Boundary register Mode */
+#define                    INPDIS  0x8000     /* CUG and CDG Input Disable */
+#define                   nINPDIS  0x0       
+
+/* Bit masks for CNT_IMASK */
+
+#define                      ICIE  0x1        /* Illegal Gray/Binary Code Interrupt Enable */
+#define                     nICIE  0x0       
+#define                      UCIE  0x2        /* Up count Interrupt Enable */
+#define                     nUCIE  0x0       
+#define                      DCIE  0x4        /* Down count Interrupt Enable */
+#define                     nDCIE  0x0       
+#define                    MINCIE  0x8        /* Min Count Interrupt Enable */
+#define                   nMINCIE  0x0       
+#define                    MAXCIE  0x10       /* Max Count Interrupt Enable */
+#define                   nMAXCIE  0x0       
+#define                   COV31IE  0x20       /* Bit 31 Overflow Interrupt Enable */
+#define                  nCOV31IE  0x0       
+#define                   COV15IE  0x40       /* Bit 15 Overflow Interrupt Enable */
+#define                  nCOV15IE  0x0       
+#define                   CZEROIE  0x80       /* Count to Zero Interrupt Enable */
+#define                  nCZEROIE  0x0       
+#define                     CZMIE  0x100      /* CZM Pin Interrupt Enable */
+#define                    nCZMIE  0x0       
+#define                    CZMEIE  0x200      /* CZM Error Interrupt Enable */
+#define                   nCZMEIE  0x0       
+#define                    CZMZIE  0x400      /* CZM Zeroes Counter Interrupt Enable */
+#define                   nCZMZIE  0x0       
+
+/* Bit masks for CNT_STATUS */
+
+#define                      ICII  0x1        /* Illegal Gray/Binary Code Interrupt Identifier */
+#define                     nICII  0x0       
+#define                      UCII  0x2        /* Up count Interrupt Identifier */
+#define                     nUCII  0x0       
+#define                      DCII  0x4        /* Down count Interrupt Identifier */
+#define                     nDCII  0x0       
+#define                    MINCII  0x8        /* Min Count Interrupt Identifier */
+#define                   nMINCII  0x0       
+#define                    MAXCII  0x10       /* Max Count Interrupt Identifier */
+#define                   nMAXCII  0x0       
+#define                   COV31II  0x20       /* Bit 31 Overflow Interrupt Identifier */
+#define                  nCOV31II  0x0       
+#define                   COV15II  0x40       /* Bit 15 Overflow Interrupt Identifier */
+#define                  nCOV15II  0x0       
+#define                   CZEROII  0x80       /* Count to Zero Interrupt Identifier */
+#define                  nCZEROII  0x0       
+#define                     CZMII  0x100      /* CZM Pin Interrupt Identifier */
+#define                    nCZMII  0x0       
+#define                    CZMEII  0x200      /* CZM Error Interrupt Identifier */
+#define                   nCZMEII  0x0       
+#define                    CZMZII  0x400      /* CZM Zeroes Counter Interrupt Identifier */
+#define                   nCZMZII  0x0       
+
+/* Bit masks for CNT_COMMAND */
+
+#define                    W1LCNT  0xf        /* Load Counter Register */
+#define                    W1LMIN  0xf0       /* Load Min Register */
+#define                    W1LMAX  0xf00      /* Load Max Register */
+#define                  W1ZMONCE  0x1000     /* Enable CZM Clear Counter Once */
+#define                 nW1ZMONCE  0x0       
+
+/* Bit masks for CNT_DEBOUNCE */
+
+#define                 DPRESCALE  0xf        /* Load Counter Register */
+
+/* Bit masks for RTC_STAT */
+
+#define                   SECONDS  0x3f       /* Seconds */
+#define                   MINUTES  0xfc0      /* Minutes */
+#define                     HOURS  0x1f000    /* Hours */
+#define               DAY_COUNTER  0xfffe0000 /* Day Counter */
+
+/* Bit masks for RTC_ICTL */
+
+#define STOPWATCH_INTERRUPT_ENABLE  0x1        /* Stopwatch Interrupt Enable */
+#define nSTOPWATCH_INTERRUPT_ENABLE  0x0       
+#define    ALARM_INTERRUPT_ENABLE  0x2        /* Alarm Interrupt Enable */
+#define   nALARM_INTERRUPT_ENABLE  0x0       
+#define  SECONDS_INTERRUPT_ENABLE  0x4        /* Seconds Interrupt Enable */
+#define nSECONDS_INTERRUPT_ENABLE  0x0       
+#define  MINUTES_INTERRUPT_ENABLE  0x8        /* Minutes Interrupt Enable */
+#define nMINUTES_INTERRUPT_ENABLE  0x0       
+#define    HOURS_INTERRUPT_ENABLE  0x10       /* Hours Interrupt Enable */
+#define   nHOURS_INTERRUPT_ENABLE  0x0       
+#define TWENTY_FOUR_HOURS_INTERRUPT_ENABLE  0x20       /* 24 Hours Interrupt Enable */
+#define nTWENTY_FOUR_HOURS_INTERRUPT_ENABLE  0x0       
+#define DAY_ALARM_INTERRUPT_ENABLE  0x40       /* Day Alarm Interrupt Enable */
+#define nDAY_ALARM_INTERRUPT_ENABLE  0x0       
+#define WRITE_COMPLETE_INTERRUPT_ENABLE  0x8000     /* Write Complete Interrupt Enable */
+#define nWRITE_COMPLETE_INTERRUPT_ENABLE  0x0       
+
+/* Bit masks for RTC_ISTAT */
+
+#define      STOPWATCH_EVENT_FLAG  0x1        /* Stopwatch Event Flag */
+#define     nSTOPWATCH_EVENT_FLAG  0x0       
+#define          ALARM_EVENT_FLAG  0x2        /* Alarm Event Flag */
+#define         nALARM_EVENT_FLAG  0x0       
+#define        SECONDS_EVENT_FLAG  0x4        /* Seconds Event Flag */
+#define       nSECONDS_EVENT_FLAG  0x0       
+#define        MINUTES_EVENT_FLAG  0x8        /* Minutes Event Flag */
+#define       nMINUTES_EVENT_FLAG  0x0       
+#define          HOURS_EVENT_FLAG  0x10       /* Hours Event Flag */
+#define         nHOURS_EVENT_FLAG  0x0       
+#define TWENTY_FOUR_HOURS_EVENT_FLAG  0x20       /* 24 Hours Event Flag */
+#define nTWENTY_FOUR_HOURS_EVENT_FLAG  0x0       
+#define      DAY_ALARM_EVENT_FLAG  0x40       /* Day Alarm Event Flag */
+#define     nDAY_ALARM_EVENT_FLAG  0x0       
+#define     WRITE_PENDING__STATUS  0x4000     /* Write Pending  Status */
+#define    nWRITE_PENDING__STATUS  0x0       
+#define            WRITE_COMPLETE  0x8000     /* Write Complete */
+#define           nWRITE_COMPLETE  0x0       
+
+/* Bit masks for RTC_SWCNT */
+
+#define           STOPWATCH_COUNT  0xffff     /* Stopwatch Count */
+
+/* Bit masks for RTC_ALARM */
+
+#define                   SECONDS  0x3f       /* Seconds */
+#define                   MINUTES  0xfc0      /* Minutes */
+#define                     HOURS  0x1f000    /* Hours */
+#define                       DAY  0xfffe0000 /* Day */
+
+/* Bit masks for RTC_PREN */
+
+#define                      PREN  0x1        /* Prescaler Enable */
+#define                     nPREN  0x0       
+
+/* Bit masks for OTP_CONTROL */
+
+#define                FUSE_FADDR  0x1ff      /* OTP/Fuse Address */
+#define                      FIEN  0x800      /* OTP/Fuse Interrupt Enable */
+#define                     nFIEN  0x0       
+#define                  FTESTDEC  0x1000     /* OTP/Fuse Test Decoder */
+#define                 nFTESTDEC  0x0       
+#define                   FWRTEST  0x2000     /* OTP/Fuse Write Test */
+#define                  nFWRTEST  0x0       
+#define                     FRDEN  0x4000     /* OTP/Fuse Read Enable */
+#define                    nFRDEN  0x0       
+#define                     FWREN  0x8000     /* OTP/Fuse Write Enable */
+#define                    nFWREN  0x0       
+
+/* Bit masks for OTP_BEN */
+
+#define                      FBEN  0xffff     /* OTP/Fuse Byte Enable */
+
+/* Bit masks for OTP_STATUS */
+
+#define                     FCOMP  0x1        /* OTP/Fuse Access Complete */
+#define                    nFCOMP  0x0       
+#define                    FERROR  0x2        /* OTP/Fuse Access Error */
+#define                   nFERROR  0x0       
+#define                  MMRGLOAD  0x10       /* Memory Mapped Register Gasket Load */
+#define                 nMMRGLOAD  0x0       
+#define                  MMRGLOCK  0x20       /* Memory Mapped Register Gasket Lock */
+#define                 nMMRGLOCK  0x0       
+#define                    FPGMEN  0x40       /* OTP/Fuse Program Enable */
+#define                   nFPGMEN  0x0       
+
+/* Bit masks for OTP_TIMING */
+
+#define                   USECDIV  0xff       /* Micro Second Divider */
+#define                   READACC  0x7f00     /* Read Access Time */
+#define                   CPUMPRL  0x38000    /* Charge Pump Release Time */
+#define                   CPUMPSU  0xc0000    /* Charge Pump Setup Time */
+#define                   CPUMPHD  0xf00000   /* Charge Pump Hold Time */
+#define                   PGMTIME  0xff000000 /* Program Time */
+
+/* Bit masks for SECURE_SYSSWT */
+
+#define                   EMUDABL  0x1        /* Emulation Disable. */
+#define                  nEMUDABL  0x0       
+#define                   RSTDABL  0x2        /* Reset Disable */
+#define                  nRSTDABL  0x0       
+#define                   L1IDABL  0x1c       /* L1 Instruction Memory Disable. */
+#define                  L1DADABL  0xe0       /* L1 Data Bank A Memory Disable. */
+#define                  L1DBDABL  0x700      /* L1 Data Bank B Memory Disable. */
+#define                   DMA0OVR  0x800      /* DMA0 Memory Access Override */
+#define                  nDMA0OVR  0x0       
+#define                   DMA1OVR  0x1000     /* DMA1 Memory Access Override */
+#define                  nDMA1OVR  0x0       
+#define                    EMUOVR  0x4000     /* Emulation Override */
+#define                   nEMUOVR  0x0       
+#define                    OTPSEN  0x8000     /* OTP Secrets Enable. */
+#define                   nOTPSEN  0x0       
+#define                    L2DABL  0x70000    /* L2 Memory Disable. */
+
+/* Bit masks for SECURE_CONTROL */
+
+#define                   SECURE0  0x1        /* SECURE 0 */
+#define                  nSECURE0  0x0       
+#define                   SECURE1  0x2        /* SECURE 1 */
+#define                  nSECURE1  0x0       
+#define                   SECURE2  0x4        /* SECURE 2 */
+#define                  nSECURE2  0x0       
+#define                   SECURE3  0x8        /* SECURE 3 */
+#define                  nSECURE3  0x0       
+
+/* Bit masks for SECURE_STATUS */
+
+#define                   SECMODE  0x3        /* Secured Mode Control State */
+#define                       NMI  0x4        /* Non Maskable Interrupt */
+#define                      nNMI  0x0       
+#define                   AFVALID  0x8        /* Authentication Firmware Valid */
+#define                  nAFVALID  0x0       
+#define                    AFEXIT  0x10       /* Authentication Firmware Exit */
+#define                   nAFEXIT  0x0       
+#define                   SECSTAT  0xe0       /* Secure Status */
+
+/* Bit masks for PLL_DIV */
+
+#define                      CSEL  0x30       /* Core Select */
+#define                      SSEL  0xf        /* System Select */
+
+/* Bit masks for PLL_CTL */
+
+#define                      MSEL  0x7e00     /* Multiplier Select */
+#define                    BYPASS  0x100      /* PLL Bypass Enable */
+#define                   nBYPASS  0x0       
+#define              OUTPUT_DELAY  0x80       /* External Memory Output Delay Enable */
+#define             nOUTPUT_DELAY  0x0       
+#define               INPUT_DELAY  0x40       /* External Memory Input Delay Enable */
+#define              nINPUT_DELAY  0x0       
+#define                      PDWN  0x20       /* Power Down */
+#define                     nPDWN  0x0       
+#define                    STOPCK  0x8        /* Stop Clock */
+#define                   nSTOPCK  0x0       
+#define                   PLL_OFF  0x2        /* Disable PLL */
+#define                  nPLL_OFF  0x0       
+#define                        DF  0x1        /* Divide Frequency */
+#define                       nDF  0x0       
+
+/* Bit masks for PLL_STAT */
+
+#define                PLL_LOCKED  0x20       /* PLL Locked Status */
+#define               nPLL_LOCKED  0x0       
+#define        ACTIVE_PLLDISABLED  0x4        /* Active Mode With PLL Disabled */
+#define       nACTIVE_PLLDISABLED  0x0       
+#define                   FULL_ON  0x2        /* Full-On Mode */
+#define                  nFULL_ON  0x0       
+#define         ACTIVE_PLLENABLED  0x1        /* Active Mode With PLL Enabled */
+#define        nACTIVE_PLLENABLED  0x0       
+#define                     RTCWS  0x400      /* RTC/Reset Wake-Up Status */
+#define                    nRTCWS  0x0       
+#define                     CANWS  0x800      /* CAN Wake-Up Status */
+#define                    nCANWS  0x0       
+#define                     USBWS  0x2000     /* USB Wake-Up Status */
+#define                    nUSBWS  0x0       
+#define                    KPADWS  0x4000     /* Keypad Wake-Up Status */
+#define                   nKPADWS  0x0       
+#define                     ROTWS  0x8000     /* Rotary Wake-Up Status */
+#define                    nROTWS  0x0       
+#define                      GPWS  0x1000     /* General-Purpose Wake-Up Status */
+#define                     nGPWS  0x0       
+
+/* Bit masks for VR_CTL */
+
+#define                      FREQ  0x3        /* Regulator Switching Frequency */
+#define                      GAIN  0xc        /* Voltage Output Level Gain */
+#define                      VLEV  0xf0       /* Internal Voltage Level */
+#define                   SCKELOW  0x8000     /* Drive SCKE Low During Reset Enable */
+#define                  nSCKELOW  0x0       
+#define                      WAKE  0x100      /* RTC/Reset Wake-Up Enable */
+#define                     nWAKE  0x0       
+#define                     CANWE  0x200      /* CAN0/1 Wake-Up Enable */
+#define                    nCANWE  0x0       
+#define                      GPWE  0x400      /* General-Purpose Wake-Up Enable */
+#define                     nGPWE  0x0       
+#define                     USBWE  0x800      /* USB Wake-Up Enable */
+#define                    nUSBWE  0x0       
+#define                    KPADWE  0x1000     /* Keypad Wake-Up Enable */
+#define                   nKPADWE  0x0       
+#define                     ROTWE  0x2000     /* Rotary Wake-Up Enable */
+#define                    nROTWE  0x0       
+
+/* Bit masks for NFC_CTL */
+
+#define                    WR_DLY  0xf        /* Write Strobe Delay */
+#define                    RD_DLY  0xf0       /* Read Strobe Delay */
+#define                    NWIDTH  0x100      /* NAND Data Width */
+#define                   nNWIDTH  0x0       
+#define                   PG_SIZE  0x200      /* Page Size */
+#define                  nPG_SIZE  0x0       
+
+/* Bit masks for NFC_STAT */
+
+#define                     NBUSY  0x1        /* Not Busy */
+#define                    nNBUSY  0x0       
+#define                   WB_FULL  0x2        /* Write Buffer Full */
+#define                  nWB_FULL  0x0       
+#define                PG_WR_STAT  0x4        /* Page Write Pending */
+#define               nPG_WR_STAT  0x0       
+#define                PG_RD_STAT  0x8        /* Page Read Pending */
+#define               nPG_RD_STAT  0x0       
+#define                  WB_EMPTY  0x10       /* Write Buffer Empty */
+#define                 nWB_EMPTY  0x0       
+
+/* Bit masks for NFC_IRQSTAT */
+
+#define                  NBUSYIRQ  0x1        /* Not Busy IRQ */
+#define                 nNBUSYIRQ  0x0       
+#define                    WB_OVF  0x2        /* Write Buffer Overflow */
+#define                   nWB_OVF  0x0       
+#define                   WB_EDGE  0x4        /* Write Buffer Edge Detect */
+#define                  nWB_EDGE  0x0       
+#define                    RD_RDY  0x8        /* Read Data Ready */
+#define                   nRD_RDY  0x0       
+#define                   WR_DONE  0x10       /* Page Write Done */
+#define                  nWR_DONE  0x0       
+
+/* Bit masks for NFC_IRQMASK */
+
+#define              MASK_BUSYIRQ  0x1        /* Mask Not Busy IRQ */
+#define             nMASK_BUSYIRQ  0x0       
+#define                MASK_WBOVF  0x2        /* Mask Write Buffer Overflow */
+#define               nMASK_WBOVF  0x0       
+#define              MASK_WBEMPTY  0x4        /* Mask Write Buffer Empty */
+#define             nMASK_WBEMPTY  0x0       
+#define                MASK_RDRDY  0x8        /* Mask Read Data Ready */
+#define               nMASK_RDRDY  0x0       
+#define               MASK_WRDONE  0x10       /* Mask Write Done */
+#define              nMASK_WRDONE  0x0       
+
+/* Bit masks for NFC_RST */
+
+#define                   ECC_RST  0x1        /* ECC (and NFC counters) Reset */
+#define                  nECC_RST  0x0       
+
+/* Bit masks for NFC_PGCTL */
+
+#define               PG_RD_START  0x1        /* Page Read Start */
+#define              nPG_RD_START  0x0       
+#define               PG_WR_START  0x2        /* Page Write Start */
+#define              nPG_WR_START  0x0       
+
+/* Bit masks for NFC_ECC0 */
+
+#define                      ECC0  0x7ff      /* Parity Calculation Result0 */
+
+/* Bit masks for NFC_ECC1 */
+
+#define                      ECC1  0x7ff      /* Parity Calculation Result1 */
+
+/* Bit masks for NFC_ECC2 */
+
+#define                      ECC2  0x7ff      /* Parity Calculation Result2 */
+
+/* Bit masks for NFC_ECC3 */
+
+#define                      ECC3  0x7ff      /* Parity Calculation Result3 */
+
+/* Bit masks for NFC_COUNT */
+
+#define                    ECCCNT  0x3ff      /* Transfer Count */
+
+/* Bit masks for CAN0_CONTROL */
+
+#define                       SRS  0x1        /* Software Reset */
+#define                      nSRS  0x0       
+#define                       DNM  0x2        /* DeviceNet Mode */
+#define                      nDNM  0x0       
+#define                       ABO  0x4        /* Auto Bus On */
+#define                      nABO  0x0       
+#define                       WBA  0x10       /* Wakeup On CAN Bus Activity */
+#define                      nWBA  0x0       
+#define                       SMR  0x20       /* Sleep Mode Request */
+#define                      nSMR  0x0       
+#define                       CSR  0x40       /* CAN Suspend Mode Request */
+#define                      nCSR  0x0       
+#define                       CCR  0x80       /* CAN Configuration Mode Request */
+#define                      nCCR  0x0       
+
+/* Bit masks for CAN0_STATUS */
+
+#define                        WT  0x1        /* CAN Transmit Warning Flag */
+#define                       nWT  0x0       
+#define                        WR  0x2        /* CAN Receive Warning Flag */
+#define                       nWR  0x0       
+#define                        EP  0x4        /* CAN Error Passive Mode */
+#define                       nEP  0x0       
+#define                       EBO  0x8        /* CAN Error Bus Off Mode */
+#define                      nEBO  0x0       
+#define                       CSA  0x40       /* CAN Suspend Mode Acknowledge */
+#define                      nCSA  0x0       
+#define                       CCA  0x80       /* CAN Configuration Mode Acknowledge */
+#define                      nCCA  0x0       
+#define                     MBPTR  0x1f00     /* Mailbox Pointer */
+#define                       TRM  0x4000     /* Transmit Mode Status */
+#define                      nTRM  0x0       
+#define                       REC  0x8000     /* Receive Mode Status */
+#define                      nREC  0x0       
+
+/* Bit masks for CAN0_DEBUG */
+
+#define                       DEC  0x1        /* Disable Transmit/Receive Error Counters */
+#define                      nDEC  0x0       
+#define                       DRI  0x2        /* Disable CANRX Input Pin */
+#define                      nDRI  0x0       
+#define                       DTO  0x4        /* Disable CANTX Output Pin */
+#define                      nDTO  0x0       
+#define                       DIL  0x8        /* Disable Internal Loop */
+#define                      nDIL  0x0       
+#define                       MAA  0x10       /* Mode Auto-Acknowledge */
+#define                      nMAA  0x0       
+#define                       MRB  0x20       /* Mode Read Back */
+#define                      nMRB  0x0       
+#define                       CDE  0x8000     /* CAN Debug Mode Enable */
+#define                      nCDE  0x0       
+
+/* Bit masks for CAN0_CLOCK */
+
+#define                       BRP  0x3ff      /* CAN Bit Rate Prescaler */
+
+/* Bit masks for CAN0_TIMING */
+
+#define                       SJW  0x300      /* Synchronization Jump Width */
+#define                       SAM  0x80       /* Sampling */
+#define                      nSAM  0x0       
+#define                     TSEG2  0x70       /* Time Segment 2 */
+#define                     TSEG1  0xf        /* Time Segment 1 */
+
+/* Bit masks for CAN0_INTR */
+
+#define                     CANRX  0x80       /* Serial Input From Transceiver */
+#define                    nCANRX  0x0       
+#define                     CANTX  0x40       /* Serial Output To Transceiver */
+#define                    nCANTX  0x0       
+#define                     SMACK  0x8        /* Sleep Mode Acknowledge */
+#define                    nSMACK  0x0       
+#define                      GIRQ  0x4        /* Global Interrupt Request Status */
+#define                     nGIRQ  0x0       
+#define                    MBTIRQ  0x2        /* Mailbox Transmit Interrupt Request */
+#define                   nMBTIRQ  0x0       
+#define                    MBRIRQ  0x1        /* Mailbox Receive Interrupt Request */
+#define                   nMBRIRQ  0x0       
+
+/* Bit masks for CAN0_GIM */
+
+#define                     EWTIM  0x1        /* Error Warning Transmit Interrupt Mask */
+#define                    nEWTIM  0x0       
+#define                     EWRIM  0x2        /* Error Warning Receive Interrupt Mask */
+#define                    nEWRIM  0x0       
+#define                      EPIM  0x4        /* Error Passive Interrupt Mask */
+#define                     nEPIM  0x0       
+#define                      BOIM  0x8        /* Bus Off Interrupt Mask */
+#define                     nBOIM  0x0       
+#define                      WUIM  0x10       /* Wakeup Interrupt Mask */
+#define                     nWUIM  0x0       
+#define                     UIAIM  0x20       /* Unimplemented Address Interrupt Mask */
+#define                    nUIAIM  0x0       
+#define                      AAIM  0x40       /* Abort Acknowledge Interrupt Mask */
+#define                     nAAIM  0x0       
+#define                     RMLIM  0x80       /* Receive Message Lost Interrupt Mask */
+#define                    nRMLIM  0x0       
+#define                     UCEIM  0x100      /* Universal Counter Exceeded Interrupt Mask */
+#define                    nUCEIM  0x0       
+#define                      ADIM  0x400      /* Access Denied Interrupt Mask */
+#define                     nADIM  0x0       
+
+/* Bit masks for CAN0_GIS */
+
+#define                     EWTIS  0x1        /* Error Warning Transmit Interrupt Status */
+#define                    nEWTIS  0x0       
+#define                     EWRIS  0x2        /* Error Warning Receive Interrupt Status */
+#define                    nEWRIS  0x0       
+#define                      EPIS  0x4        /* Error Passive Interrupt Status */
+#define                     nEPIS  0x0       
+#define                      BOIS  0x8        /* Bus Off Interrupt Status */
+#define                     nBOIS  0x0       
+#define                      WUIS  0x10       /* Wakeup Interrupt Status */
+#define                     nWUIS  0x0       
+#define                     UIAIS  0x20       /* Unimplemented Address Interrupt Status */
+#define                    nUIAIS  0x0       
+#define                      AAIS  0x40       /* Abort Acknowledge Interrupt Status */
+#define                     nAAIS  0x0       
+#define                     RMLIS  0x80       /* Receive Message Lost Interrupt Status */
+#define                    nRMLIS  0x0       
+#define                     UCEIS  0x100      /* Universal Counter Exceeded Interrupt Status */
+#define                    nUCEIS  0x0       
+#define                      ADIS  0x400      /* Access Denied Interrupt Status */
+#define                     nADIS  0x0       
+
+/* Bit masks for CAN0_GIF */
+
+#define                     EWTIF  0x1        /* Error Warning Transmit Interrupt Flag */
+#define                    nEWTIF  0x0       
+#define                     EWRIF  0x2        /* Error Warning Receive Interrupt Flag */
+#define                    nEWRIF  0x0       
+#define                      EPIF  0x4        /* Error Passive Interrupt Flag */
+#define                     nEPIF  0x0       
+#define                      BOIF  0x8        /* Bus Off Interrupt Flag */
+#define                     nBOIF  0x0       
+#define                      WUIF  0x10       /* Wakeup Interrupt Flag */
+#define                     nWUIF  0x0       
+#define                     UIAIF  0x20       /* Unimplemented Address Interrupt Flag */
+#define                    nUIAIF  0x0       
+#define                      AAIF  0x40       /* Abort Acknowledge Interrupt Flag */
+#define                     nAAIF  0x0       
+#define                     RMLIF  0x80       /* Receive Message Lost Interrupt Flag */
+#define                    nRMLIF  0x0       
+#define                     UCEIF  0x100      /* Universal Counter Exceeded Interrupt Flag */
+#define                    nUCEIF  0x0       
+#define                      ADIF  0x400      /* Access Denied Interrupt Flag */
+#define                     nADIF  0x0       
+
+/* Bit masks for CAN0_MBTD */
+
+#define                       TDR  0x80       /* Temporary Disable Request */
+#define                      nTDR  0x0       
+#define                       TDA  0x40       /* Temporary Disable Acknowledge */
+#define                      nTDA  0x0       
+#define                     TDPTR  0x1f       /* Temporary Disable Pointer */
+
+/* Bit masks for CAN0_UCCNF */
+
+#define                     UCCNF  0xf        /* Universal Counter Configuration */
+#define                      UCRC  0x20       /* Universal Counter Reload/Clear */
+#define                     nUCRC  0x0       
+#define                      UCCT  0x40       /* Universal Counter CAN Trigger */
+#define                     nUCCT  0x0       
+#define                       UCE  0x80       /* Universal Counter Enable */
+#define                      nUCE  0x0       
+
+/* Bit masks for CAN0_UCCNT */
+
+#define                     UCCNT  0xffff     /* Universal Counter Count Value */
+
+/* Bit masks for CAN0_UCRC */
+
+#define                     UCVAL  0xffff     /* Universal Counter Reload/Capture Value */
+
+/* Bit masks for CAN0_CEC */
+
+#define                    RXECNT  0xff       /* Receive Error Counter */
+#define                    TXECNT  0xff00     /* Transmit Error Counter */
+
+/* Bit masks for CAN0_ESR */
+
+#define                       FER  0x80       /* Form Error */
+#define                      nFER  0x0       
+#define                       BEF  0x40       /* Bit Error Flag */
+#define                      nBEF  0x0       
+#define                       SA0  0x20       /* Stuck At Dominant */
+#define                      nSA0  0x0       
+#define                      CRCE  0x10       /* CRC Error */
+#define                     nCRCE  0x0       
+#define                       SER  0x8        /* Stuff Bit Error */
+#define                      nSER  0x0       
+#define                      ACKE  0x4        /* Acknowledge Error */
+#define                     nACKE  0x0       
+
+/* Bit masks for CAN0_EWR */
+
+#define                    EWLTEC  0xff00     /* Transmit Error Warning Limit */
+#define                    EWLREC  0xff       /* Receive Error Warning Limit */
+
+/* Bit masks for CAN0_AMxx_H */
+
+#define                       FDF  0x8000     /* Filter On Data Field */
+#define                      nFDF  0x0       
+#define                       FMD  0x4000     /* Full Mask Data */
+#define                      nFMD  0x0       
+#define                     AMIDE  0x2000     /* Acceptance Mask Identifier Extension */
+#define                    nAMIDE  0x0       
+#define                    BASEID  0x1ffc     /* Base Identifier */
+#define                  EXTID_HI  0x3        /* Extended Identifier High Bits */
+
+/* Bit masks for CAN0_AMxx_L */
+
+#define                  EXTID_LO  0xffff     /* Extended Identifier Low Bits */
+#define                       DFM  0xffff     /* Data Field Mask */
+
+/* Bit masks for CAN0_MBxx_ID1 */
+
+#define                       AME  0x8000     /* Acceptance Mask Enable */
+#define                      nAME  0x0       
+#define                       RTR  0x4000     /* Remote Transmission Request */
+#define                      nRTR  0x0       
+#define                       IDE  0x2000     /* Identifier Extension */
+#define                      nIDE  0x0       
+#define                    BASEID  0x1ffc     /* Base Identifier */
+#define                  EXTID_HI  0x3        /* Extended Identifier High Bits */
+
+/* Bit masks for CAN0_MBxx_ID0 */
+
+#define                  EXTID_LO  0xffff     /* Extended Identifier Low Bits */
+#define                       DFM  0xffff     /* Data Field Mask */
+
+/* Bit masks for CAN0_MBxx_TIMESTAMP */
+
+#define                       TSV  0xffff     /* Time Stamp Value */
+
+/* Bit masks for CAN0_MBxx_LENGTH */
+
+#define                       DLC  0xf        /* Data Length Code */
+
+/* Bit masks for CAN0_MBxx_DATA3 */
+
+#define                 CAN_BYTE0  0xff00     /* Data Field Byte 0 */
+#define                 CAN_BYTE1  0xff       /* Data Field Byte 1 */
+
+/* Bit masks for CAN0_MBxx_DATA2 */
+
+#define                 CAN_BYTE2  0xff00     /* Data Field Byte 2 */
+#define                 CAN_BYTE3  0xff       /* Data Field Byte 3 */
+
+/* Bit masks for CAN0_MBxx_DATA1 */
+
+#define                 CAN_BYTE4  0xff00     /* Data Field Byte 4 */
+#define                 CAN_BYTE5  0xff       /* Data Field Byte 5 */
+
+/* Bit masks for CAN0_MBxx_DATA0 */
+
+#define                 CAN_BYTE6  0xff00     /* Data Field Byte 6 */
+#define                 CAN_BYTE7  0xff       /* Data Field Byte 7 */
+
+/* Bit masks for CAN0_MC1 */
+
+#define                       MC0  0x1        /* Mailbox 0 Enable */
+#define                      nMC0  0x0       
+#define                       MC1  0x2        /* Mailbox 1 Enable */
+#define                      nMC1  0x0       
+#define                       MC2  0x4        /* Mailbox 2 Enable */
+#define                      nMC2  0x0       
+#define                       MC3  0x8        /* Mailbox 3 Enable */
+#define                      nMC3  0x0       
+#define                       MC4  0x10       /* Mailbox 4 Enable */
+#define                      nMC4  0x0       
+#define                       MC5  0x20       /* Mailbox 5 Enable */
+#define                      nMC5  0x0       
+#define                       MC6  0x40       /* Mailbox 6 Enable */
+#define                      nMC6  0x0       
+#define                       MC7  0x80       /* Mailbox 7 Enable */
+#define                      nMC7  0x0       
+#define                       MC8  0x100      /* Mailbox 8 Enable */
+#define                      nMC8  0x0       
+#define                       MC9  0x200      /* Mailbox 9 Enable */
+#define                      nMC9  0x0       
+#define                      MC10  0x400      /* Mailbox 10 Enable */
+#define                     nMC10  0x0       
+#define                      MC11  0x800      /* Mailbox 11 Enable */
+#define                     nMC11  0x0       
+#define                      MC12  0x1000     /* Mailbox 12 Enable */
+#define                     nMC12  0x0       
+#define                      MC13  0x2000     /* Mailbox 13 Enable */
+#define                     nMC13  0x0       
+#define                      MC14  0x4000     /* Mailbox 14 Enable */
+#define                     nMC14  0x0       
+#define                      MC15  0x8000     /* Mailbox 15 Enable */
+#define                     nMC15  0x0       
+
+/* Bit masks for CAN0_MC2 */
+
+#define                      MC16  0x1        /* Mailbox 16 Enable */
+#define                     nMC16  0x0       
+#define                      MC17  0x2        /* Mailbox 17 Enable */
+#define                     nMC17  0x0       
+#define                      MC18  0x4        /* Mailbox 18 Enable */
+#define                     nMC18  0x0       
+#define                      MC19  0x8        /* Mailbox 19 Enable */
+#define                     nMC19  0x0       
+#define                      MC20  0x10       /* Mailbox 20 Enable */
+#define                     nMC20  0x0       
+#define                      MC21  0x20       /* Mailbox 21 Enable */
+#define                     nMC21  0x0       
+#define                      MC22  0x40       /* Mailbox 22 Enable */
+#define                     nMC22  0x0       
+#define                      MC23  0x80       /* Mailbox 23 Enable */
+#define                     nMC23  0x0       
+#define                      MC24  0x100      /* Mailbox 24 Enable */
+#define                     nMC24  0x0       
+#define                      MC25  0x200      /* Mailbox 25 Enable */
+#define                     nMC25  0x0       
+#define                      MC26  0x400      /* Mailbox 26 Enable */
+#define                     nMC26  0x0       
+#define                      MC27  0x800      /* Mailbox 27 Enable */
+#define                     nMC27  0x0       
+#define                      MC28  0x1000     /* Mailbox 28 Enable */
+#define                     nMC28  0x0       
+#define                      MC29  0x2000     /* Mailbox 29 Enable */
+#define                     nMC29  0x0       
+#define                      MC30  0x4000     /* Mailbox 30 Enable */
+#define                     nMC30  0x0       
+#define                      MC31  0x8000     /* Mailbox 31 Enable */
+#define                     nMC31  0x0       
+
+/* Bit masks for CAN0_MD1 */
+
+#define                       MD0  0x1        /* Mailbox 0 Receive Enable */
+#define                      nMD0  0x0       
+#define                       MD1  0x2        /* Mailbox 1 Receive Enable */
+#define                      nMD1  0x0       
+#define                       MD2  0x4        /* Mailbox 2 Receive Enable */
+#define                      nMD2  0x0       
+#define                       MD3  0x8        /* Mailbox 3 Receive Enable */
+#define                      nMD3  0x0       
+#define                       MD4  0x10       /* Mailbox 4 Receive Enable */
+#define                      nMD4  0x0       
+#define                       MD5  0x20       /* Mailbox 5 Receive Enable */
+#define                      nMD5  0x0       
+#define                       MD6  0x40       /* Mailbox 6 Receive Enable */
+#define                      nMD6  0x0       
+#define                       MD7  0x80       /* Mailbox 7 Receive Enable */
+#define                      nMD7  0x0       
+#define                       MD8  0x100      /* Mailbox 8 Receive Enable */
+#define                      nMD8  0x0       
+#define                       MD9  0x200      /* Mailbox 9 Receive Enable */
+#define                      nMD9  0x0       
+#define                      MD10  0x400      /* Mailbox 10 Receive Enable */
+#define                     nMD10  0x0       
+#define                      MD11  0x800      /* Mailbox 11 Receive Enable */
+#define                     nMD11  0x0       
+#define                      MD12  0x1000     /* Mailbox 12 Receive Enable */
+#define                     nMD12  0x0       
+#define                      MD13  0x2000     /* Mailbox 13 Receive Enable */
+#define                     nMD13  0x0       
+#define                      MD14  0x4000     /* Mailbox 14 Receive Enable */
+#define                     nMD14  0x0       
+#define                      MD15  0x8000     /* Mailbox 15 Receive Enable */
+#define                     nMD15  0x0       
+
+/* Bit masks for CAN0_MD2 */
+
+#define                      MD16  0x1        /* Mailbox 16 Receive Enable */
+#define                     nMD16  0x0       
+#define                      MD17  0x2        /* Mailbox 17 Receive Enable */
+#define                     nMD17  0x0       
+#define                      MD18  0x4        /* Mailbox 18 Receive Enable */
+#define                     nMD18  0x0       
+#define                      MD19  0x8        /* Mailbox 19 Receive Enable */
+#define                     nMD19  0x0       
+#define                      MD20  0x10       /* Mailbox 20 Receive Enable */
+#define                     nMD20  0x0       
+#define                      MD21  0x20       /* Mailbox 21 Receive Enable */
+#define                     nMD21  0x0       
+#define                      MD22  0x40       /* Mailbox 22 Receive Enable */
+#define                     nMD22  0x0       
+#define                      MD23  0x80       /* Mailbox 23 Receive Enable */
+#define                     nMD23  0x0       
+#define                      MD24  0x100      /* Mailbox 24 Receive Enable */
+#define                     nMD24  0x0       
+#define                      MD25  0x200      /* Mailbox 25 Receive Enable */
+#define                     nMD25  0x0       
+#define                      MD26  0x400      /* Mailbox 26 Receive Enable */
+#define                     nMD26  0x0       
+#define                      MD27  0x800      /* Mailbox 27 Receive Enable */
+#define                     nMD27  0x0       
+#define                      MD28  0x1000     /* Mailbox 28 Receive Enable */
+#define                     nMD28  0x0       
+#define                      MD29  0x2000     /* Mailbox 29 Receive Enable */
+#define                     nMD29  0x0       
+#define                      MD30  0x4000     /* Mailbox 30 Receive Enable */
+#define                     nMD30  0x0       
+#define                      MD31  0x8000     /* Mailbox 31 Receive Enable */
+#define                     nMD31  0x0       
+
+/* Bit masks for CAN0_RMP1 */
+
+#define                      RMP0  0x1        /* Mailbox 0 Receive Message Pending */
+#define                     nRMP0  0x0       
+#define                      RMP1  0x2        /* Mailbox 1 Receive Message Pending */
+#define                     nRMP1  0x0       
+#define                      RMP2  0x4        /* Mailbox 2 Receive Message Pending */
+#define                     nRMP2  0x0       
+#define                      RMP3  0x8        /* Mailbox 3 Receive Message Pending */
+#define                     nRMP3  0x0       
+#define                      RMP4  0x10       /* Mailbox 4 Receive Message Pending */
+#define                     nRMP4  0x0       
+#define                      RMP5  0x20       /* Mailbox 5 Receive Message Pending */
+#define                     nRMP5  0x0       
+#define                      RMP6  0x40       /* Mailbox 6 Receive Message Pending */
+#define                     nRMP6  0x0       
+#define                      RMP7  0x80       /* Mailbox 7 Receive Message Pending */
+#define                     nRMP7  0x0       
+#define                      RMP8  0x100      /* Mailbox 8 Receive Message Pending */
+#define                     nRMP8  0x0       
+#define                      RMP9  0x200      /* Mailbox 9 Receive Message Pending */
+#define                     nRMP9  0x0       
+#define                     RMP10  0x400      /* Mailbox 10 Receive Message Pending */
+#define                    nRMP10  0x0       
+#define                     RMP11  0x800      /* Mailbox 11 Receive Message Pending */
+#define                    nRMP11  0x0       
+#define                     RMP12  0x1000     /* Mailbox 12 Receive Message Pending */
+#define                    nRMP12  0x0       
+#define                     RMP13  0x2000     /* Mailbox 13 Receive Message Pending */
+#define                    nRMP13  0x0       
+#define                     RMP14  0x4000     /* Mailbox 14 Receive Message Pending */
+#define                    nRMP14  0x0       
+#define                     RMP15  0x8000     /* Mailbox 15 Receive Message Pending */
+#define                    nRMP15  0x0       
+
+/* Bit masks for CAN0_RMP2 */
+
+#define                     RMP16  0x1        /* Mailbox 16 Receive Message Pending */
+#define                    nRMP16  0x0       
+#define                     RMP17  0x2        /* Mailbox 17 Receive Message Pending */
+#define                    nRMP17  0x0       
+#define                     RMP18  0x4        /* Mailbox 18 Receive Message Pending */
+#define                    nRMP18  0x0       
+#define                     RMP19  0x8        /* Mailbox 19 Receive Message Pending */
+#define                    nRMP19  0x0       
+#define                     RMP20  0x10       /* Mailbox 20 Receive Message Pending */
+#define                    nRMP20  0x0       
+#define                     RMP21  0x20       /* Mailbox 21 Receive Message Pending */
+#define                    nRMP21  0x0       
+#define                     RMP22  0x40       /* Mailbox 22 Receive Message Pending */
+#define                    nRMP22  0x0       
+#define                     RMP23  0x80       /* Mailbox 23 Receive Message Pending */
+#define                    nRMP23  0x0       
+#define                     RMP24  0x100      /* Mailbox 24 Receive Message Pending */
+#define                    nRMP24  0x0       
+#define                     RMP25  0x200      /* Mailbox 25 Receive Message Pending */
+#define                    nRMP25  0x0       
+#define                     RMP26  0x400      /* Mailbox 26 Receive Message Pending */
+#define                    nRMP26  0x0       
+#define                     RMP27  0x800      /* Mailbox 27 Receive Message Pending */
+#define                    nRMP27  0x0       
+#define                     RMP28  0x1000     /* Mailbox 28 Receive Message Pending */
+#define                    nRMP28  0x0       
+#define                     RMP29  0x2000     /* Mailbox 29 Receive Message Pending */
+#define                    nRMP29  0x0       
+#define                     RMP30  0x4000     /* Mailbox 30 Receive Message Pending */
+#define                    nRMP30  0x0       
+#define                     RMP31  0x8000     /* Mailbox 31 Receive Message Pending */
+#define                    nRMP31  0x0       
+
+/* Bit masks for CAN0_RML1 */
+
+#define                      RML0  0x1        /* Mailbox 0 Receive Message Lost */
+#define                     nRML0  0x0       
+#define                      RML1  0x2        /* Mailbox 1 Receive Message Lost */
+#define                     nRML1  0x0       
+#define                      RML2  0x4        /* Mailbox 2 Receive Message Lost */
+#define                     nRML2  0x0       
+#define                      RML3  0x8        /* Mailbox 3 Receive Message Lost */
+#define                     nRML3  0x0       
+#define                      RML4  0x10       /* Mailbox 4 Receive Message Lost */
+#define                     nRML4  0x0       
+#define                      RML5  0x20       /* Mailbox 5 Receive Message Lost */
+#define                     nRML5  0x0       
+#define                      RML6  0x40       /* Mailbox 6 Receive Message Lost */
+#define                     nRML6  0x0       
+#define                      RML7  0x80       /* Mailbox 7 Receive Message Lost */
+#define                     nRML7  0x0       
+#define                      RML8  0x100      /* Mailbox 8 Receive Message Lost */
+#define                     nRML8  0x0       
+#define                      RML9  0x200      /* Mailbox 9 Receive Message Lost */
+#define                     nRML9  0x0       
+#define                     RML10  0x400      /* Mailbox 10 Receive Message Lost */
+#define                    nRML10  0x0       
+#define                     RML11  0x800      /* Mailbox 11 Receive Message Lost */
+#define                    nRML11  0x0       
+#define                     RML12  0x1000     /* Mailbox 12 Receive Message Lost */
+#define                    nRML12  0x0       
+#define                     RML13  0x2000     /* Mailbox 13 Receive Message Lost */
+#define                    nRML13  0x0       
+#define                     RML14  0x4000     /* Mailbox 14 Receive Message Lost */
+#define                    nRML14  0x0       
+#define                     RML15  0x8000     /* Mailbox 15 Receive Message Lost */
+#define                    nRML15  0x0       
+
+/* Bit masks for CAN0_RML2 */
+
+#define                     RML16  0x1        /* Mailbox 16 Receive Message Lost */
+#define                    nRML16  0x0       
+#define                     RML17  0x2        /* Mailbox 17 Receive Message Lost */
+#define                    nRML17  0x0       
+#define                     RML18  0x4        /* Mailbox 18 Receive Message Lost */
+#define                    nRML18  0x0       
+#define                     RML19  0x8        /* Mailbox 19 Receive Message Lost */
+#define                    nRML19  0x0       
+#define                     RML20  0x10       /* Mailbox 20 Receive Message Lost */
+#define                    nRML20  0x0       
+#define                     RML21  0x20       /* Mailbox 21 Receive Message Lost */
+#define                    nRML21  0x0       
+#define                     RML22  0x40       /* Mailbox 22 Receive Message Lost */
+#define                    nRML22  0x0       
+#define                     RML23  0x80       /* Mailbox 23 Receive Message Lost */
+#define                    nRML23  0x0       
+#define                     RML24  0x100      /* Mailbox 24 Receive Message Lost */
+#define                    nRML24  0x0       
+#define                     RML25  0x200      /* Mailbox 25 Receive Message Lost */
+#define                    nRML25  0x0       
+#define                     RML26  0x400      /* Mailbox 26 Receive Message Lost */
+#define                    nRML26  0x0       
+#define                     RML27  0x800      /* Mailbox 27 Receive Message Lost */
+#define                    nRML27  0x0       
+#define                     RML28  0x1000     /* Mailbox 28 Receive Message Lost */
+#define                    nRML28  0x0       
+#define                     RML29  0x2000     /* Mailbox 29 Receive Message Lost */
+#define                    nRML29  0x0       
+#define                     RML30  0x4000     /* Mailbox 30 Receive Message Lost */
+#define                    nRML30  0x0       
+#define                     RML31  0x8000     /* Mailbox 31 Receive Message Lost */
+#define                    nRML31  0x0       
+
+/* Bit masks for CAN0_OPSS1 */
+
+#define                     OPSS0  0x1        /* Mailbox 0 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS0  0x0       
+#define                     OPSS1  0x2        /* Mailbox 1 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS1  0x0       
+#define                     OPSS2  0x4        /* Mailbox 2 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS2  0x0       
+#define                     OPSS3  0x8        /* Mailbox 3 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS3  0x0       
+#define                     OPSS4  0x10       /* Mailbox 4 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS4  0x0       
+#define                     OPSS5  0x20       /* Mailbox 5 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS5  0x0       
+#define                     OPSS6  0x40       /* Mailbox 6 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS6  0x0       
+#define                     OPSS7  0x80       /* Mailbox 7 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS7  0x0       
+#define                     OPSS8  0x100      /* Mailbox 8 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS8  0x0       
+#define                     OPSS9  0x200      /* Mailbox 9 Overwrite Protection/Single-Shot Transmission Enable */
+#define                    nOPSS9  0x0       
+#define                    OPSS10  0x400      /* Mailbox 10 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS10  0x0       
+#define                    OPSS11  0x800      /* Mailbox 11 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS11  0x0       
+#define                    OPSS12  0x1000     /* Mailbox 12 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS12  0x0       
+#define                    OPSS13  0x2000     /* Mailbox 13 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS13  0x0       
+#define                    OPSS14  0x4000     /* Mailbox 14 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS14  0x0       
+#define                    OPSS15  0x8000     /* Mailbox 15 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS15  0x0       
+
+/* Bit masks for CAN0_OPSS2 */
+
+#define                    OPSS16  0x1        /* Mailbox 16 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS16  0x0       
+#define                    OPSS17  0x2        /* Mailbox 17 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS17  0x0       
+#define                    OPSS18  0x4        /* Mailbox 18 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS18  0x0       
+#define                    OPSS19  0x8        /* Mailbox 19 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS19  0x0       
+#define                    OPSS20  0x10       /* Mailbox 20 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS20  0x0       
+#define                    OPSS21  0x20       /* Mailbox 21 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS21  0x0       
+#define                    OPSS22  0x40       /* Mailbox 22 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS22  0x0       
+#define                    OPSS23  0x80       /* Mailbox 23 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS23  0x0       
+#define                    OPSS24  0x100      /* Mailbox 24 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS24  0x0       
+#define                    OPSS25  0x200      /* Mailbox 25 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS25  0x0       
+#define                    OPSS26  0x400      /* Mailbox 26 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS26  0x0       
+#define                    OPSS27  0x800      /* Mailbox 27 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS27  0x0       
+#define                    OPSS28  0x1000     /* Mailbox 28 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS28  0x0       
+#define                    OPSS29  0x2000     /* Mailbox 29 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS29  0x0       
+#define                    OPSS30  0x4000     /* Mailbox 30 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS30  0x0       
+#define                    OPSS31  0x8000     /* Mailbox 31 Overwrite Protection/Single-Shot Transmission Enable */
+#define                   nOPSS31  0x0       
+
+/* Bit masks for CAN0_TRS1 */
+
+#define                      TRS0  0x1        /* Mailbox 0 Transmit Request Set */
+#define                     nTRS0  0x0       
+#define                      TRS1  0x2        /* Mailbox 1 Transmit Request Set */
+#define                     nTRS1  0x0       
+#define                      TRS2  0x4        /* Mailbox 2 Transmit Request Set */
+#define                     nTRS2  0x0       
+#define                      TRS3  0x8        /* Mailbox 3 Transmit Request Set */
+#define                     nTRS3  0x0       
+#define                      TRS4  0x10       /* Mailbox 4 Transmit Request Set */
+#define                     nTRS4  0x0       
+#define                      TRS5  0x20       /* Mailbox 5 Transmit Request Set */
+#define                     nTRS5  0x0       
+#define                      TRS6  0x40       /* Mailbox 6 Transmit Request Set */
+#define                     nTRS6  0x0       
+#define                      TRS7  0x80       /* Mailbox 7 Transmit Request Set */
+#define                     nTRS7  0x0       
+#define                      TRS8  0x100      /* Mailbox 8 Transmit Request Set */
+#define                     nTRS8  0x0       
+#define                      TRS9  0x200      /* Mailbox 9 Transmit Request Set */
+#define                     nTRS9  0x0       
+#define                     TRS10  0x400      /* Mailbox 10 Transmit Request Set */
+#define                    nTRS10  0x0       
+#define                     TRS11  0x800      /* Mailbox 11 Transmit Request Set */
+#define                    nTRS11  0x0       
+#define                     TRS12  0x1000     /* Mailbox 12 Transmit Request Set */
+#define                    nTRS12  0x0       
+#define                     TRS13  0x2000     /* Mailbox 13 Transmit Request Set */
+#define                    nTRS13  0x0       
+#define                     TRS14  0x4000     /* Mailbox 14 Transmit Request Set */
+#define                    nTRS14  0x0       
+#define                     TRS15  0x8000     /* Mailbox 15 Transmit Request Set */
+#define                    nTRS15  0x0       
+
+/* Bit masks for CAN0_TRS2 */
+
+#define                     TRS16  0x1        /* Mailbox 16 Transmit Request Set */
+#define                    nTRS16  0x0       
+#define                     TRS17  0x2        /* Mailbox 17 Transmit Request Set */
+#define                    nTRS17  0x0       
+#define                     TRS18  0x4        /* Mailbox 18 Transmit Request Set */
+#define                    nTRS18  0x0       
+#define                     TRS19  0x8        /* Mailbox 19 Transmit Request Set */
+#define                    nTRS19  0x0       
+#define                     TRS20  0x10       /* Mailbox 20 Transmit Request Set */
+#define                    nTRS20  0x0       
+#define                     TRS21  0x20       /* Mailbox 21 Transmit Request Set */
+#define                    nTRS21  0x0       
+#define                     TRS22  0x40       /* Mailbox 22 Transmit Request Set */
+#define                    nTRS22  0x0       
+#define                     TRS23  0x80       /* Mailbox 23 Transmit Request Set */
+#define                    nTRS23  0x0       
+#define                     TRS24  0x100      /* Mailbox 24 Transmit Request Set */
+#define                    nTRS24  0x0       
+#define                     TRS25  0x200      /* Mailbox 25 Transmit Request Set */
+#define                    nTRS25  0x0       
+#define                     TRS26  0x400      /* Mailbox 26 Transmit Request Set */
+#define                    nTRS26  0x0       
+#define                     TRS27  0x800      /* Mailbox 27 Transmit Request Set */
+#define                    nTRS27  0x0       
+#define                     TRS28  0x1000     /* Mailbox 28 Transmit Request Set */
+#define                    nTRS28  0x0       
+#define                     TRS29  0x2000     /* Mailbox 29 Transmit Request Set */
+#define                    nTRS29  0x0       
+#define                     TRS30  0x4000     /* Mailbox 30 Transmit Request Set */
+#define                    nTRS30  0x0       
+#define                     TRS31  0x8000     /* Mailbox 31 Transmit Request Set */
+#define                    nTRS31  0x0       
+
+/* Bit masks for CAN0_TRR1 */
+
+#define                      TRR0  0x1        /* Mailbox 0 Transmit Request Reset */
+#define                     nTRR0  0x0       
+#define                      TRR1  0x2        /* Mailbox 1 Transmit Request Reset */
+#define                     nTRR1  0x0       
+#define                      TRR2  0x4        /* Mailbox 2 Transmit Request Reset */
+#define                     nTRR2  0x0       
+#define                      TRR3  0x8        /* Mailbox 3 Transmit Request Reset */
+#define                     nTRR3  0x0       
+#define                      TRR4  0x10       /* Mailbox 4 Transmit Request Reset */
+#define                     nTRR4  0x0       
+#define                      TRR5  0x20       /* Mailbox 5 Transmit Request Reset */
+#define                     nTRR5  0x0       
+#define                      TRR6  0x40       /* Mailbox 6 Transmit Request Reset */
+#define                     nTRR6  0x0       
+#define                      TRR7  0x80       /* Mailbox 7 Transmit Request Reset */
+#define                     nTRR7  0x0       
+#define                      TRR8  0x100      /* Mailbox 8 Transmit Request Reset */
+#define                     nTRR8  0x0       
+#define                      TRR9  0x200      /* Mailbox 9 Transmit Request Reset */
+#define                     nTRR9  0x0       
+#define                     TRR10  0x400      /* Mailbox 10 Transmit Request Reset */
+#define                    nTRR10  0x0       
+#define                     TRR11  0x800      /* Mailbox 11 Transmit Request Reset */
+#define                    nTRR11  0x0       
+#define                     TRR12  0x1000     /* Mailbox 12 Transmit Request Reset */
+#define                    nTRR12  0x0       
+#define                     TRR13  0x2000     /* Mailbox 13 Transmit Request Reset */
+#define                    nTRR13  0x0       
+#define                     TRR14  0x4000     /* Mailbox 14 Transmit Request Reset */
+#define                    nTRR14  0x0       
+#define                     TRR15  0x8000     /* Mailbox 15 Transmit Request Reset */
+#define                    nTRR15  0x0       
+
+/* Bit masks for CAN0_TRR2 */
+
+#define                     TRR16  0x1        /* Mailbox 16 Transmit Request Reset */
+#define                    nTRR16  0x0       
+#define                     TRR17  0x2        /* Mailbox 17 Transmit Request Reset */
+#define                    nTRR17  0x0       
+#define                     TRR18  0x4        /* Mailbox 18 Transmit Request Reset */
+#define                    nTRR18  0x0       
+#define                     TRR19  0x8        /* Mailbox 19 Transmit Request Reset */
+#define                    nTRR19  0x0       
+#define                     TRR20  0x10       /* Mailbox 20 Transmit Request Reset */
+#define                    nTRR20  0x0       
+#define                     TRR21  0x20       /* Mailbox 21 Transmit Request Reset */
+#define                    nTRR21  0x0       
+#define                     TRR22  0x40       /* Mailbox 22 Transmit Request Reset */
+#define                    nTRR22  0x0       
+#define                     TRR23  0x80       /* Mailbox 23 Transmit Request Reset */
+#define                    nTRR23  0x0       
+#define                     TRR24  0x100      /* Mailbox 24 Transmit Request Reset */
+#define                    nTRR24  0x0       
+#define                     TRR25  0x200      /* Mailbox 25 Transmit Request Reset */
+#define                    nTRR25  0x0       
+#define                     TRR26  0x400      /* Mailbox 26 Transmit Request Reset */
+#define                    nTRR26  0x0       
+#define                     TRR27  0x800      /* Mailbox 27 Transmit Request Reset */
+#define                    nTRR27  0x0       
+#define                     TRR28  0x1000     /* Mailbox 28 Transmit Request Reset */
+#define                    nTRR28  0x0       
+#define                     TRR29  0x2000     /* Mailbox 29 Transmit Request Reset */
+#define                    nTRR29  0x0       
+#define                     TRR30  0x4000     /* Mailbox 30 Transmit Request Reset */
+#define                    nTRR30  0x0       
+#define                     TRR31  0x8000     /* Mailbox 31 Transmit Request Reset */
+#define                    nTRR31  0x0       
+
+/* Bit masks for CAN0_AA1 */
+
+#define                       AA0  0x1        /* Mailbox 0 Abort Acknowledge */
+#define                      nAA0  0x0       
+#define                       AA1  0x2        /* Mailbox 1 Abort Acknowledge */
+#define                      nAA1  0x0       
+#define                       AA2  0x4        /* Mailbox 2 Abort Acknowledge */
+#define                      nAA2  0x0       
+#define                       AA3  0x8        /* Mailbox 3 Abort Acknowledge */
+#define                      nAA3  0x0       
+#define                       AA4  0x10       /* Mailbox 4 Abort Acknowledge */
+#define                      nAA4  0x0       
+#define                       AA5  0x20       /* Mailbox 5 Abort Acknowledge */
+#define                      nAA5  0x0       
+#define                       AA6  0x40       /* Mailbox 6 Abort Acknowledge */
+#define                      nAA6  0x0       
+#define                       AA7  0x80       /* Mailbox 7 Abort Acknowledge */
+#define                      nAA7  0x0       
+#define                       AA8  0x100      /* Mailbox 8 Abort Acknowledge */
+#define                      nAA8  0x0       
+#define                       AA9  0x200      /* Mailbox 9 Abort Acknowledge */
+#define                      nAA9  0x0       
+#define                      AA10  0x400      /* Mailbox 10 Abort Acknowledge */
+#define                     nAA10  0x0       
+#define                      AA11  0x800      /* Mailbox 11 Abort Acknowledge */
+#define                     nAA11  0x0       
+#define                      AA12  0x1000     /* Mailbox 12 Abort Acknowledge */
+#define                     nAA12  0x0       
+#define                      AA13  0x2000     /* Mailbox 13 Abort Acknowledge */
+#define                     nAA13  0x0       
+#define                      AA14  0x4000     /* Mailbox 14 Abort Acknowledge */
+#define                     nAA14  0x0       
+#define                      AA15  0x8000     /* Mailbox 15 Abort Acknowledge */
+#define                     nAA15  0x0       
+
+/* Bit masks for CAN0_AA2 */
+
+#define                      AA16  0x1        /* Mailbox 16 Abort Acknowledge */
+#define                     nAA16  0x0       
+#define                      AA17  0x2        /* Mailbox 17 Abort Acknowledge */
+#define                     nAA17  0x0       
+#define                      AA18  0x4        /* Mailbox 18 Abort Acknowledge */
+#define                     nAA18  0x0       
+#define                      AA19  0x8        /* Mailbox 19 Abort Acknowledge */
+#define                     nAA19  0x0       
+#define                      AA20  0x10       /* Mailbox 20 Abort Acknowledge */
+#define                     nAA20  0x0       
+#define                      AA21  0x20       /* Mailbox 21 Abort Acknowledge */
+#define                     nAA21  0x0       
+#define                      AA22  0x40       /* Mailbox 22 Abort Acknowledge */
+#define                     nAA22  0x0       
+#define                      AA23  0x80       /* Mailbox 23 Abort Acknowledge */
+#define                     nAA23  0x0       
+#define                      AA24  0x100      /* Mailbox 24 Abort Acknowledge */
+#define                     nAA24  0x0       
+#define                      AA25  0x200      /* Mailbox 25 Abort Acknowledge */
+#define                     nAA25  0x0       
+#define                      AA26  0x400      /* Mailbox 26 Abort Acknowledge */
+#define                     nAA26  0x0       
+#define                      AA27  0x800      /* Mailbox 27 Abort Acknowledge */
+#define                     nAA27  0x0       
+#define                      AA28  0x1000     /* Mailbox 28 Abort Acknowledge */
+#define                     nAA28  0x0       
+#define                      AA29  0x2000     /* Mailbox 29 Abort Acknowledge */
+#define                     nAA29  0x0       
+#define                      AA30  0x4000     /* Mailbox 30 Abort Acknowledge */
+#define                     nAA30  0x0       
+#define                      AA31  0x8000     /* Mailbox 31 Abort Acknowledge */
+#define                     nAA31  0x0       
+
+/* Bit masks for CAN0_TA1 */
+
+#define                       TA0  0x1        /* Mailbox 0 Transmit Acknowledge */
+#define                      nTA0  0x0       
+#define                       TA1  0x2        /* Mailbox 1 Transmit Acknowledge */
+#define                      nTA1  0x0       
+#define                       TA2  0x4        /* Mailbox 2 Transmit Acknowledge */
+#define                      nTA2  0x0       
+#define                       TA3  0x8        /* Mailbox 3 Transmit Acknowledge */
+#define                      nTA3  0x0       
+#define                       TA4  0x10       /* Mailbox 4 Transmit Acknowledge */
+#define                      nTA4  0x0       
+#define                       TA5  0x20       /* Mailbox 5 Transmit Acknowledge */
+#define                      nTA5  0x0       
+#define                       TA6  0x40       /* Mailbox 6 Transmit Acknowledge */
+#define                      nTA6  0x0       
+#define                       TA7  0x80       /* Mailbox 7 Transmit Acknowledge */
+#define                      nTA7  0x0       
+#define                       TA8  0x100      /* Mailbox 8 Transmit Acknowledge */
+#define                      nTA8  0x0       
+#define                       TA9  0x200      /* Mailbox 9 Transmit Acknowledge */
+#define                      nTA9  0x0       
+#define                      TA10  0x400      /* Mailbox 10 Transmit Acknowledge */
+#define                     nTA10  0x0       
+#define                      TA11  0x800      /* Mailbox 11 Transmit Acknowledge */
+#define                     nTA11  0x0       
+#define                      TA12  0x1000     /* Mailbox 12 Transmit Acknowledge */
+#define                     nTA12  0x0       
+#define                      TA13  0x2000     /* Mailbox 13 Transmit Acknowledge */
+#define                     nTA13  0x0       
+#define                      TA14  0x4000     /* Mailbox 14 Transmit Acknowledge */
+#define                     nTA14  0x0       
+#define                      TA15  0x8000     /* Mailbox 15 Transmit Acknowledge */
+#define                     nTA15  0x0       
+
+/* Bit masks for CAN0_TA2 */
+
+#define                      TA16  0x1        /* Mailbox 16 Transmit Acknowledge */
+#define                     nTA16  0x0       
+#define                      TA17  0x2        /* Mailbox 17 Transmit Acknowledge */
+#define                     nTA17  0x0       
+#define                      TA18  0x4        /* Mailbox 18 Transmit Acknowledge */
+#define                     nTA18  0x0       
+#define                      TA19  0x8        /* Mailbox 19 Transmit Acknowledge */
+#define                     nTA19  0x0       
+#define                      TA20  0x10       /* Mailbox 20 Transmit Acknowledge */
+#define                     nTA20  0x0       
+#define                      TA21  0x20       /* Mailbox 21 Transmit Acknowledge */
+#define                     nTA21  0x0       
+#define                      TA22  0x40       /* Mailbox 22 Transmit Acknowledge */
+#define                     nTA22  0x0       
+#define                      TA23  0x80       /* Mailbox 23 Transmit Acknowledge */
+#define                     nTA23  0x0       
+#define                      TA24  0x100      /* Mailbox 24 Transmit Acknowledge */
+#define                     nTA24  0x0       
+#define                      TA25  0x200      /* Mailbox 25 Transmit Acknowledge */
+#define                     nTA25  0x0       
+#define                      TA26  0x400      /* Mailbox 26 Transmit Acknowledge */
+#define                     nTA26  0x0       
+#define                      TA27  0x800      /* Mailbox 27 Transmit Acknowledge */
+#define                     nTA27  0x0       
+#define                      TA28  0x1000     /* Mailbox 28 Transmit Acknowledge */
+#define                     nTA28  0x0       
+#define                      TA29  0x2000     /* Mailbox 29 Transmit Acknowledge */
+#define                     nTA29  0x0       
+#define                      TA30  0x4000     /* Mailbox 30 Transmit Acknowledge */
+#define                     nTA30  0x0       
+#define                      TA31  0x8000     /* Mailbox 31 Transmit Acknowledge */
+#define                     nTA31  0x0       
+
+/* Bit masks for CAN0_RFH1 */
+
+#define                      RFH0  0x1        /* Mailbox 0 Remote Frame Handling Enable */
+#define                     nRFH0  0x0       
+#define                      RFH1  0x2        /* Mailbox 1 Remote Frame Handling Enable */
+#define                     nRFH1  0x0       
+#define                      RFH2  0x4        /* Mailbox 2 Remote Frame Handling Enable */
+#define                     nRFH2  0x0       
+#define                      RFH3  0x8        /* Mailbox 3 Remote Frame Handling Enable */
+#define                     nRFH3  0x0       
+#define                      RFH4  0x10       /* Mailbox 4 Remote Frame Handling Enable */
+#define                     nRFH4  0x0       
+#define                      RFH5  0x20       /* Mailbox 5 Remote Frame Handling Enable */
+#define                     nRFH5  0x0       
+#define                      RFH6  0x40       /* Mailbox 6 Remote Frame Handling Enable */
+#define                     nRFH6  0x0       
+#define                      RFH7  0x80       /* Mailbox 7 Remote Frame Handling Enable */
+#define                     nRFH7  0x0       
+#define                      RFH8  0x100      /* Mailbox 8 Remote Frame Handling Enable */
+#define                     nRFH8  0x0       
+#define                      RFH9  0x200      /* Mailbox 9 Remote Frame Handling Enable */
+#define                     nRFH9  0x0       
+#define                     RFH10  0x400      /* Mailbox 10 Remote Frame Handling Enable */
+#define                    nRFH10  0x0       
+#define                     RFH11  0x800      /* Mailbox 11 Remote Frame Handling Enable */
+#define                    nRFH11  0x0       
+#define                     RFH12  0x1000     /* Mailbox 12 Remote Frame Handling Enable */
+#define                    nRFH12  0x0       
+#define                     RFH13  0x2000     /* Mailbox 13 Remote Frame Handling Enable */
+#define                    nRFH13  0x0       
+#define                     RFH14  0x4000     /* Mailbox 14 Remote Frame Handling Enable */
+#define                    nRFH14  0x0       
+#define                     RFH15  0x8000     /* Mailbox 15 Remote Frame Handling Enable */
+#define                    nRFH15  0x0       
+
+/* Bit masks for CAN0_RFH2 */
+
+#define                     RFH16  0x1        /* Mailbox 16 Remote Frame Handling Enable */
+#define                    nRFH16  0x0       
+#define                     RFH17  0x2        /* Mailbox 17 Remote Frame Handling Enable */
+#define                    nRFH17  0x0       
+#define                     RFH18  0x4        /* Mailbox 18 Remote Frame Handling Enable */
+#define                    nRFH18  0x0       
+#define                     RFH19  0x8        /* Mailbox 19 Remote Frame Handling Enable */
+#define                    nRFH19  0x0       
+#define                     RFH20  0x10       /* Mailbox 20 Remote Frame Handling Enable */
+#define                    nRFH20  0x0       
+#define                     RFH21  0x20       /* Mailbox 21 Remote Frame Handling Enable */
+#define                    nRFH21  0x0       
+#define                     RFH22  0x40       /* Mailbox 22 Remote Frame Handling Enable */
+#define                    nRFH22  0x0       
+#define                     RFH23  0x80       /* Mailbox 23 Remote Frame Handling Enable */
+#define                    nRFH23  0x0       
+#define                     RFH24  0x100      /* Mailbox 24 Remote Frame Handling Enable */
+#define                    nRFH24  0x0       
+#define                     RFH25  0x200      /* Mailbox 25 Remote Frame Handling Enable */
+#define                    nRFH25  0x0       
+#define                     RFH26  0x400      /* Mailbox 26 Remote Frame Handling Enable */
+#define                    nRFH26  0x0       
+#define                     RFH27  0x800      /* Mailbox 27 Remote Frame Handling Enable */
+#define                    nRFH27  0x0       
+#define                     RFH28  0x1000     /* Mailbox 28 Remote Frame Handling Enable */
+#define                    nRFH28  0x0       
+#define                     RFH29  0x2000     /* Mailbox 29 Remote Frame Handling Enable */
+#define                    nRFH29  0x0       
+#define                     RFH30  0x4000     /* Mailbox 30 Remote Frame Handling Enable */
+#define                    nRFH30  0x0       
+#define                     RFH31  0x8000     /* Mailbox 31 Remote Frame Handling Enable */
+#define                    nRFH31  0x0       
+
+/* Bit masks for CAN0_MBIM1 */
+
+#define                     MBIM0  0x1        /* Mailbox 0 Mailbox Interrupt Mask */
+#define                    nMBIM0  0x0       
+#define                     MBIM1  0x2        /* Mailbox 1 Mailbox Interrupt Mask */
+#define                    nMBIM1  0x0       
+#define                     MBIM2  0x4        /* Mailbox 2 Mailbox Interrupt Mask */
+#define                    nMBIM2  0x0       
+#define                     MBIM3  0x8        /* Mailbox 3 Mailbox Interrupt Mask */
+#define                    nMBIM3  0x0       
+#define                     MBIM4  0x10       /* Mailbox 4 Mailbox Interrupt Mask */
+#define                    nMBIM4  0x0       
+#define                     MBIM5  0x20       /* Mailbox 5 Mailbox Interrupt Mask */
+#define                    nMBIM5  0x0       
+#define                     MBIM6  0x40       /* Mailbox 6 Mailbox Interrupt Mask */
+#define                    nMBIM6  0x0       
+#define                     MBIM7  0x80       /* Mailbox 7 Mailbox Interrupt Mask */
+#define                    nMBIM7  0x0       
+#define                     MBIM8  0x100      /* Mailbox 8 Mailbox Interrupt Mask */
+#define                    nMBIM8  0x0       
+#define                     MBIM9  0x200      /* Mailbox 9 Mailbox Interrupt Mask */
+#define                    nMBIM9  0x0       
+#define                    MBIM10  0x400      /* Mailbox 10 Mailbox Interrupt Mask */
+#define                   nMBIM10  0x0       
+#define                    MBIM11  0x800      /* Mailbox 11 Mailbox Interrupt Mask */
+#define                   nMBIM11  0x0       
+#define                    MBIM12  0x1000     /* Mailbox 12 Mailbox Interrupt Mask */
+#define                   nMBIM12  0x0       
+#define                    MBIM13  0x2000     /* Mailbox 13 Mailbox Interrupt Mask */
+#define                   nMBIM13  0x0       
+#define                    MBIM14  0x4000     /* Mailbox 14 Mailbox Interrupt Mask */
+#define                   nMBIM14  0x0       
+#define                    MBIM15  0x8000     /* Mailbox 15 Mailbox Interrupt Mask */
+#define                   nMBIM15  0x0       
+
+/* Bit masks for CAN0_MBIM2 */
+
+#define                    MBIM16  0x1        /* Mailbox 16 Mailbox Interrupt Mask */
+#define                   nMBIM16  0x0       
+#define                    MBIM17  0x2        /* Mailbox 17 Mailbox Interrupt Mask */
+#define                   nMBIM17  0x0       
+#define                    MBIM18  0x4        /* Mailbox 18 Mailbox Interrupt Mask */
+#define                   nMBIM18  0x0       
+#define                    MBIM19  0x8        /* Mailbox 19 Mailbox Interrupt Mask */
+#define                   nMBIM19  0x0       
+#define                    MBIM20  0x10       /* Mailbox 20 Mailbox Interrupt Mask */
+#define                   nMBIM20  0x0       
+#define                    MBIM21  0x20       /* Mailbox 21 Mailbox Interrupt Mask */
+#define                   nMBIM21  0x0       
+#define                    MBIM22  0x40       /* Mailbox 22 Mailbox Interrupt Mask */
+#define                   nMBIM22  0x0       
+#define                    MBIM23  0x80       /* Mailbox 23 Mailbox Interrupt Mask */
+#define                   nMBIM23  0x0       
+#define                    MBIM24  0x100      /* Mailbox 24 Mailbox Interrupt Mask */
+#define                   nMBIM24  0x0       
+#define                    MBIM25  0x200      /* Mailbox 25 Mailbox Interrupt Mask */
+#define                   nMBIM25  0x0       
+#define                    MBIM26  0x400      /* Mailbox 26 Mailbox Interrupt Mask */
+#define                   nMBIM26  0x0       
+#define                    MBIM27  0x800      /* Mailbox 27 Mailbox Interrupt Mask */
+#define                   nMBIM27  0x0       
+#define                    MBIM28  0x1000     /* Mailbox 28 Mailbox Interrupt Mask */
+#define                   nMBIM28  0x0       
+#define                    MBIM29  0x2000     /* Mailbox 29 Mailbox Interrupt Mask */
+#define                   nMBIM29  0x0       
+#define                    MBIM30  0x4000     /* Mailbox 30 Mailbox Interrupt Mask */
+#define                   nMBIM30  0x0       
+#define                    MBIM31  0x8000     /* Mailbox 31 Mailbox Interrupt Mask */
+#define                   nMBIM31  0x0       
+
+/* Bit masks for CAN0_MBTIF1 */
+
+#define                    MBTIF0  0x1        /* Mailbox 0 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF0  0x0       
+#define                    MBTIF1  0x2        /* Mailbox 1 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF1  0x0       
+#define                    MBTIF2  0x4        /* Mailbox 2 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF2  0x0       
+#define                    MBTIF3  0x8        /* Mailbox 3 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF3  0x0       
+#define                    MBTIF4  0x10       /* Mailbox 4 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF4  0x0       
+#define                    MBTIF5  0x20       /* Mailbox 5 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF5  0x0       
+#define                    MBTIF6  0x40       /* Mailbox 6 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF6  0x0       
+#define                    MBTIF7  0x80       /* Mailbox 7 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF7  0x0       
+#define                    MBTIF8  0x100      /* Mailbox 8 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF8  0x0       
+#define                    MBTIF9  0x200      /* Mailbox 9 Mailbox Transmit Interrupt Flag */
+#define                   nMBTIF9  0x0       
+#define                   MBTIF10  0x400      /* Mailbox 10 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF10  0x0       
+#define                   MBTIF11  0x800      /* Mailbox 11 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF11  0x0       
+#define                   MBTIF12  0x1000     /* Mailbox 12 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF12  0x0       
+#define                   MBTIF13  0x2000     /* Mailbox 13 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF13  0x0       
+#define                   MBTIF14  0x4000     /* Mailbox 14 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF14  0x0       
+#define                   MBTIF15  0x8000     /* Mailbox 15 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF15  0x0       
+
+/* Bit masks for CAN0_MBTIF2 */
+
+#define                   MBTIF16  0x1        /* Mailbox 16 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF16  0x0       
+#define                   MBTIF17  0x2        /* Mailbox 17 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF17  0x0       
+#define                   MBTIF18  0x4        /* Mailbox 18 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF18  0x0       
+#define                   MBTIF19  0x8        /* Mailbox 19 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF19  0x0       
+#define                   MBTIF20  0x10       /* Mailbox 20 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF20  0x0       
+#define                   MBTIF21  0x20       /* Mailbox 21 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF21  0x0       
+#define                   MBTIF22  0x40       /* Mailbox 22 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF22  0x0       
+#define                   MBTIF23  0x80       /* Mailbox 23 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF23  0x0       
+#define                   MBTIF24  0x100      /* Mailbox 24 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF24  0x0       
+#define                   MBTIF25  0x200      /* Mailbox 25 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF25  0x0       
+#define                   MBTIF26  0x400      /* Mailbox 26 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF26  0x0       
+#define                   MBTIF27  0x800      /* Mailbox 27 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF27  0x0       
+#define                   MBTIF28  0x1000     /* Mailbox 28 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF28  0x0       
+#define                   MBTIF29  0x2000     /* Mailbox 29 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF29  0x0       
+#define                   MBTIF30  0x4000     /* Mailbox 30 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF30  0x0       
+#define                   MBTIF31  0x8000     /* Mailbox 31 Mailbox Transmit Interrupt Flag */
+#define                  nMBTIF31  0x0       
+
+/* Bit masks for CAN0_MBRIF1 */
+
+#define                    MBRIF0  0x1        /* Mailbox 0 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF0  0x0       
+#define                    MBRIF1  0x2        /* Mailbox 1 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF1  0x0       
+#define                    MBRIF2  0x4        /* Mailbox 2 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF2  0x0       
+#define                    MBRIF3  0x8        /* Mailbox 3 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF3  0x0       
+#define                    MBRIF4  0x10       /* Mailbox 4 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF4  0x0       
+#define                    MBRIF5  0x20       /* Mailbox 5 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF5  0x0       
+#define                    MBRIF6  0x40       /* Mailbox 6 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF6  0x0       
+#define                    MBRIF7  0x80       /* Mailbox 7 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF7  0x0       
+#define                    MBRIF8  0x100      /* Mailbox 8 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF8  0x0       
+#define                    MBRIF9  0x200      /* Mailbox 9 Mailbox Receive Interrupt Flag */
+#define                   nMBRIF9  0x0       
+#define                   MBRIF10  0x400      /* Mailbox 10 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF10  0x0       
+#define                   MBRIF11  0x800      /* Mailbox 11 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF11  0x0       
+#define                   MBRIF12  0x1000     /* Mailbox 12 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF12  0x0       
+#define                   MBRIF13  0x2000     /* Mailbox 13 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF13  0x0       
+#define                   MBRIF14  0x4000     /* Mailbox 14 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF14  0x0       
+#define                   MBRIF15  0x8000     /* Mailbox 15 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF15  0x0       
+
+/* Bit masks for CAN0_MBRIF2 */
+
+#define                   MBRIF16  0x1        /* Mailbox 16 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF16  0x0       
+#define                   MBRIF17  0x2        /* Mailbox 17 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF17  0x0       
+#define                   MBRIF18  0x4        /* Mailbox 18 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF18  0x0       
+#define                   MBRIF19  0x8        /* Mailbox 19 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF19  0x0       
+#define                   MBRIF20  0x10       /* Mailbox 20 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF20  0x0       
+#define                   MBRIF21  0x20       /* Mailbox 21 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF21  0x0       
+#define                   MBRIF22  0x40       /* Mailbox 22 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF22  0x0       
+#define                   MBRIF23  0x80       /* Mailbox 23 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF23  0x0       
+#define                   MBRIF24  0x100      /* Mailbox 24 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF24  0x0       
+#define                   MBRIF25  0x200      /* Mailbox 25 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF25  0x0       
+#define                   MBRIF26  0x400      /* Mailbox 26 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF26  0x0       
+#define                   MBRIF27  0x800      /* Mailbox 27 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF27  0x0       
+#define                   MBRIF28  0x1000     /* Mailbox 28 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF28  0x0       
+#define                   MBRIF29  0x2000     /* Mailbox 29 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF29  0x0       
+#define                   MBRIF30  0x4000     /* Mailbox 30 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF30  0x0       
+#define                   MBRIF31  0x8000     /* Mailbox 31 Mailbox Receive Interrupt Flag */
+#define                  nMBRIF31  0x0       
+
+/* Bit masks for EPPIx_STATUS */
+
+#define                 CFIFO_ERR  0x1        /* Chroma FIFO Error */
+#define                nCFIFO_ERR  0x0       
+#define                 YFIFO_ERR  0x2        /* Luma FIFO Error */
+#define                nYFIFO_ERR  0x0       
+#define                 LTERR_OVR  0x4        /* Line Track Overflow */
+#define                nLTERR_OVR  0x0       
+#define                LTERR_UNDR  0x8        /* Line Track Underflow */
+#define               nLTERR_UNDR  0x0       
+#define                 FTERR_OVR  0x10       /* Frame Track Overflow */
+#define                nFTERR_OVR  0x0       
+#define                FTERR_UNDR  0x20       /* Frame Track Underflow */
+#define               nFTERR_UNDR  0x0       
+#define                  ERR_NCOR  0x40       /* Preamble Error Not Corrected */
+#define                 nERR_NCOR  0x0       
+#define                   DMA1URQ  0x80       /* DMA1 Urgent Request */
+#define                  nDMA1URQ  0x0       
+#define                   DMA0URQ  0x100      /* DMA0 Urgent Request */
+#define                  nDMA0URQ  0x0       
+#define                   ERR_DET  0x4000     /* Preamble Error Detected */
+#define                  nERR_DET  0x0       
+#define                       FLD  0x8000     /* Field */
+#define                      nFLD  0x0       
+
+/* Bit masks for EPPIx_CONTROL */
+
+#define                   EPPI_EN  0x1        /* Enable */
+#define                  nEPPI_EN  0x0       
+#define                  EPPI_DIR  0x2        /* Direction */
+#define                 nEPPI_DIR  0x0       
+#define                  XFR_TYPE  0xc        /* Operating Mode */
+#define                    FS_CFG  0x30       /* Frame Sync Configuration */
+#define                   FLD_SEL  0x40       /* Field Select/Trigger */
+#define                  nFLD_SEL  0x0       
+#define                  ITU_TYPE  0x80       /* ITU Interlaced or Progressive */
+#define                 nITU_TYPE  0x0       
+#define                  BLANKGEN  0x100      /* ITU Output Mode with Internal Blanking Generation */
+#define                 nBLANKGEN  0x0       
+#define                   ICLKGEN  0x200      /* Internal Clock Generation */
+#define                  nICLKGEN  0x0       
+#define                    IFSGEN  0x400      /* Internal Frame Sync Generation */
+#define                   nIFSGEN  0x0       
+#define                      POLC  0x1800     /* Frame Sync and Data Driving/Sampling Edges */
+#define                      POLS  0x6000     /* Frame Sync Polarity */
+#define                   DLENGTH  0x38000    /* Data Length */
+#define                   SKIP_EN  0x40000    /* Skip Enable */
+#define                  nSKIP_EN  0x0       
+#define                   SKIP_EO  0x80000    /* Skip Even or Odd */
+#define                  nSKIP_EO  0x0       
+#define                    PACKEN  0x100000   /* Packing/Unpacking Enable */
+#define                   nPACKEN  0x0       
+#define                    SWAPEN  0x200000   /* Swap Enable */
+#define                   nSWAPEN  0x0       
+#define                  SIGN_EXT  0x400000   /* Sign Extension or Zero-filled / Data Split Format */
+#define                 nSIGN_EXT  0x0       
+#define             SPLT_EVEN_ODD  0x800000   /* Split Even and Odd Data Samples */
+#define            nSPLT_EVEN_ODD  0x0       
+#define               SUBSPLT_ODD  0x1000000  /* Sub-split Odd Samples */
+#define              nSUBSPLT_ODD  0x0       
+#define                    DMACFG  0x2000000  /* One or Two DMA Channels Mode */
+#define                   nDMACFG  0x0       
+#define                RGB_FMT_EN  0x4000000  /* RGB Formatting Enable */
+#define               nRGB_FMT_EN  0x0       
+#define                  FIFO_RWM  0x18000000 /* FIFO Regular Watermarks */
+#define                  FIFO_UWM  0x60000000 /* FIFO Urgent Watermarks */
+
+/* Bit masks for EPPIx_FS2W_LVB */
+
+#define                   F1VB_BD  0xff       /* Vertical Blanking before Field 1 Active Data */
+#define                   F1VB_AD  0xff00     /* Vertical Blanking after Field 1 Active Data */
+#define                   F2VB_BD  0xff0000   /* Vertical Blanking before Field 2 Active Data */
+#define                   F2VB_AD  0xff000000 /* Vertical Blanking after Field 2 Active Data */
+
+/* Bit masks for EPPIx_FS2W_LAVF */
+
+#define                    F1_ACT  0xffff     /* Number of Lines of Active Data in Field 1 */
+#define                    F2_ACT  0xffff0000 /* Number of Lines of Active Data in Field 2 */
+
+/* Bit masks for EPPIx_CLIP */
+
+#define                   LOW_ODD  0xff       /* Lower Limit for Odd Bytes (Chroma) */
+#define                  HIGH_ODD  0xff00     /* Upper Limit for Odd Bytes (Chroma) */
+#define                  LOW_EVEN  0xff0000   /* Lower Limit for Even Bytes (Luma) */
+#define                 HIGH_EVEN  0xff000000 /* Upper Limit for Even Bytes (Luma) */
+
+/* Bit masks for SPIx_BAUD */
+
+#define                  SPI_BAUD  0xffff     /* Baud Rate */
+
+/* Bit masks for SPIx_CTL */
+
+#define                       SPE  0x4000     /* SPI Enable */
+#define                      nSPE  0x0       
+#define                       WOM  0x2000     /* Write Open Drain Master */
+#define                      nWOM  0x0       
+#define                      MSTR  0x1000     /* Master Mode */
+#define                     nMSTR  0x0       
+#define                      CPOL  0x800      /* Clock Polarity */
+#define                     nCPOL  0x0       
+#define                      CPHA  0x400      /* Clock Phase */
+#define                     nCPHA  0x0       
+#define                      LSBF  0x200      /* LSB First */
+#define                     nLSBF  0x0       
+#define                      SIZE  0x100      /* Size of Words */
+#define                     nSIZE  0x0       
+#define                     EMISO  0x20       /* Enable MISO Output */
+#define                    nEMISO  0x0       
+#define                      PSSE  0x10       /* Slave-Select Enable */
+#define                     nPSSE  0x0       
+#define                        GM  0x8        /* Get More Data */
+#define                       nGM  0x0       
+#define                        SZ  0x4        /* Send Zero */
+#define                       nSZ  0x0       
+#define                     TIMOD  0x3        /* Transfer Initiation Mode */
+
+/* Bit masks for SPIx_FLG */
+
+#define                      FLS1  0x2        /* Slave Select Enable 1 */
+#define                     nFLS1  0x0       
+#define                      FLS2  0x4        /* Slave Select Enable 2 */
+#define                     nFLS2  0x0       
+#define                      FLS3  0x8        /* Slave Select Enable 3 */
+#define                     nFLS3  0x0       
+#define                      FLG1  0x200      /* Slave Select Value 1 */
+#define                     nFLG1  0x0       
+#define                      FLG2  0x400      /* Slave Select Value 2 */
+#define                     nFLG2  0x0       
+#define                      FLG3  0x800      /* Slave Select Value 3 */
+#define                     nFLG3  0x0       
+
+/* Bit masks for SPIx_STAT */
+
+#define                     TXCOL  0x40       /* Transmit Collision Error */
+#define                    nTXCOL  0x0       
+#define                       RXS  0x20       /* RDBR Data Buffer Status */
+#define                      nRXS  0x0       
+#define                      RBSY  0x10       /* Receive Error */
+#define                     nRBSY  0x0       
+#define                       TXS  0x8        /* TDBR Data Buffer Status */
+#define                      nTXS  0x0       
+#define                       TXE  0x4        /* Transmission Error */
+#define                      nTXE  0x0       
+#define                      MODF  0x2        /* Mode Fault Error */
+#define                     nMODF  0x0       
+#define                      SPIF  0x1        /* SPI Finished */
+#define                     nSPIF  0x0       
+
+/* Bit masks for SPIx_TDBR */
+
+#define                      TDBR  0xffff     /* Transmit Data Buffer */
+
+/* Bit masks for SPIx_RDBR */
+
+#define                      RDBR  0xffff     /* Receive Data Buffer */
+
+/* Bit masks for SPIx_SHADOW */
+
+#define                    SHADOW  0xffff     /* RDBR Shadow */
+
+/* ************************************************ */
+/* The TWI bit masks fields are from the ADSP-BF538 */
+/* and they have not been verified as the final     */
+/* ones for the Moab processors ... bz 1/19/2007    */
+/* ************************************************ */
+
+/* Bit masks for TWIx_CONTROL */
+
+#define                  PRESCALE  0x7f       /* Prescale Value */
+#define                   TWI_ENA  0x80       /* TWI Enable */
+#define                  nTWI_ENA  0x0       
+#define                      SCCB  0x200      /* Serial Camera Control Bus */
+#define                     nSCCB  0x0       
+
+/* Bit maskes for TWIx_CLKDIV */
+
+#define                    CLKLOW  0xff       /* Clock Low */
+#define                     CLKHI  0xff00     /* Clock High */
+
+/* Bit maskes for TWIx_SLAVE_CTL */
+
+#define                       SEN  0x1        /* Slave Enable */
+#define                      nSEN  0x0       
+#define                    STDVAL  0x4        /* Slave Transmit Data Valid */
+#define                   nSTDVAL  0x0       
+#define                       NAK  0x8        /* Not Acknowledge */
+#define                      nNAK  0x0       
+#define                       GEN  0x10       /* General Call Enable */
+#define                      nGEN  0x0       
+
+/* Bit maskes for TWIx_SLAVE_ADDR */
+
+#define                     SADDR  0x7f       /* Slave Mode Address */
+
+/* Bit maskes for TWIx_SLAVE_STAT */
+
+#define                      SDIR  0x1        /* Slave Transfer Direction */
+#define                     nSDIR  0x0       
+#define                     GCALL  0x2        /* General Call */
+#define                    nGCALL  0x0       
+
+/* Bit maskes for TWIx_MASTER_CTL */
+
+#define                       MEN  0x1        /* Master Mode Enable */
+#define                      nMEN  0x0       
+#define                      MDIR  0x4        /* Master Transfer Direction */
+#define                     nMDIR  0x0       
+#define                      FAST  0x8        /* Fast Mode */
+#define                     nFAST  0x0       
+#define                      STOP  0x10       /* Issue Stop Condition */
+#define                     nSTOP  0x0       
+#define                    RSTART  0x20       /* Repeat Start */
+#define                   nRSTART  0x0       
+#define                      DCNT  0x3fc0     /* Data Transfer Count */
+#define                    SDAOVR  0x4000     /* Serial Data Override */
+#define                   nSDAOVR  0x0       
+#define                    SCLOVR  0x8000     /* Serial Clock Override */
+#define                   nSCLOVR  0x0       
+
+/* Bit maskes for TWIx_MASTER_ADDR */
+
+#define                     MADDR  0x7f       /* Master Mode Address */
+
+/* Bit maskes for TWIx_MASTER_STAT */
+
+#define                     MPROG  0x1        /* Master Transfer in Progress */
+#define                    nMPROG  0x0       
+#define                   LOSTARB  0x2        /* Lost Arbitration */
+#define                  nLOSTARB  0x0       
+#define                      ANAK  0x4        /* Address Not Acknowledged */
+#define                     nANAK  0x0       
+#define                      DNAK  0x8        /* Data Not Acknowledged */
+#define                     nDNAK  0x0       
+#define                  BUFRDERR  0x10       /* Buffer Read Error */
+#define                 nBUFRDERR  0x0       
+#define                  BUFWRERR  0x20       /* Buffer Write Error */
+#define                 nBUFWRERR  0x0       
+#define                    SDASEN  0x40       /* Serial Data Sense */
+#define                   nSDASEN  0x0       
+#define                    SCLSEN  0x80       /* Serial Clock Sense */
+#define                   nSCLSEN  0x0       
+#define                   BUSBUSY  0x100      /* Bus Busy */
+#define                  nBUSBUSY  0x0       
+
+/* Bit maskes for TWIx_FIFO_CTL */
+
+#define                  XMTFLUSH  0x1        /* Transmit Buffer Flush */
+#define                 nXMTFLUSH  0x0       
+#define                  RCVFLUSH  0x2        /* Receive Buffer Flush */
+#define                 nRCVFLUSH  0x0       
+#define                 XMTINTLEN  0x4        /* Transmit Buffer Interrupt Length */
+#define                nXMTINTLEN  0x0       
+#define                 RCVINTLEN  0x8        /* Receive Buffer Interrupt Length */
+#define                nRCVINTLEN  0x0       
+
+/* Bit maskes for TWIx_FIFO_STAT */
+
+#define                   XMTSTAT  0x3        /* Transmit FIFO Status */
+#define                   RCVSTAT  0xc        /* Receive FIFO Status */
+
+/* Bit maskes for TWIx_INT_MASK */
+
+#define                    SINITM  0x1        /* Slave Transfer Initiated Interrupt Mask */
+#define                   nSINITM  0x0       
+#define                    SCOMPM  0x2        /* Slave Transfer Complete Interrupt Mask */
+#define                   nSCOMPM  0x0       
+#define                     SERRM  0x4        /* Slave Transfer Error Interrupt Mask */
+#define                    nSERRM  0x0       
+#define                     SOVFM  0x8        /* Slave Overflow Interrupt Mask */
+#define                    nSOVFM  0x0       
+#define                    MCOMPM  0x10       /* Master Transfer Complete Interrupt Mask */
+#define                   nMCOMPM  0x0       
+#define                     MERRM  0x20       /* Master Transfer Error Interrupt Mask */
+#define                    nMERRM  0x0       
+#define                  XMTSERVM  0x40       /* Transmit FIFO Service Interrupt Mask */
+#define                 nXMTSERVM  0x0       
+#define                  RCVSERVM  0x80       /* Receive FIFO Service Interrupt Mask */
+#define                 nRCVSERVM  0x0       
+
+/* Bit maskes for TWIx_INT_STAT */
+
+#define                     SINIT  0x1        /* Slave Transfer Initiated */
+#define                    nSINIT  0x0       
+#define                     SCOMP  0x2        /* Slave Transfer Complete */
+#define                    nSCOMP  0x0       
+#define                      SERR  0x4        /* Slave Transfer Error */
+#define                     nSERR  0x0       
+#define                      SOVF  0x8        /* Slave Overflow */
+#define                     nSOVF  0x0       
+#define                     MCOMP  0x10       /* Master Transfer Complete */
+#define                    nMCOMP  0x0       
+#define                      MERR  0x20       /* Master Transfer Error */
+#define                     nMERR  0x0       
+#define                   XMTSERV  0x40       /* Transmit FIFO Service */
+#define                  nXMTSERV  0x0       
+#define                   RCVSERV  0x80       /* Receive FIFO Service */
+#define                  nRCVSERV  0x0       
+
+/* Bit maskes for TWIx_XMT_DATA8 */
+
+#define                  XMTDATA8  0xff       /* Transmit FIFO 8-Bit Data */
+
+/* Bit maskes for TWIx_XMT_DATA16 */
+
+#define                 XMTDATA16  0xffff     /* Transmit FIFO 16-Bit Data */
+
+/* Bit maskes for TWIx_RCV_DATA8 */
+
+#define                  RCVDATA8  0xff       /* Receive FIFO 8-Bit Data */
+
+/* Bit maskes for TWIx_RCV_DATA16 */
+
+#define                 RCVDATA16  0xffff     /* Receive FIFO 16-Bit Data */
+
+/* Bit masks for SPORTx_TCR1 */
+
+#define                     TCKFE  0x4000     /* Clock Falling Edge Select */
+#define                    nTCKFE  0x0       
+#define                     LATFS  0x2000     /* Late Transmit Frame Sync */
+#define                    nLATFS  0x0       
+#define                      LTFS  0x1000     /* Low Transmit Frame Sync Select */
+#define                     nLTFS  0x0       
+#define                     DITFS  0x800      /* Data-Independent Transmit Frame Sync Select */
+#define                    nDITFS  0x0       
+#define                      TFSR  0x400      /* Transmit Frame Sync Required Select */
+#define                     nTFSR  0x0       
+#define                      ITFS  0x200      /* Internal Transmit Frame Sync Select */
+#define                     nITFS  0x0       
+#define                    TLSBIT  0x10       /* Transmit Bit Order */
+#define                   nTLSBIT  0x0       
+#define                    TDTYPE  0xc        /* Data Formatting Type Select */
+#define                     ITCLK  0x2        /* Internal Transmit Clock Select */
+#define                    nITCLK  0x0       
+#define                     TSPEN  0x1        /* Transmit Enable */
+#define                    nTSPEN  0x0       
+
+/* Bit masks for SPORTx_TCR2 */
+
+#define                     TRFST  0x400      /* Left/Right Order */
+#define                    nTRFST  0x0       
+#define                     TSFSE  0x200      /* Transmit Stereo Frame Sync Enable */
+#define                    nTSFSE  0x0       
+#define                      TXSE  0x100      /* TxSEC Enable */
+#define                     nTXSE  0x0       
+#define                    SLEN_T  0x1f       /* SPORT Word Length */
+
+/* Bit masks for SPORTx_RCR1 */
+
+#define                     RCKFE  0x4000     /* Clock Falling Edge Select */
+#define                    nRCKFE  0x0       
+#define                     LARFS  0x2000     /* Late Receive Frame Sync */
+#define                    nLARFS  0x0       
+#define                      LRFS  0x1000     /* Low Receive Frame Sync Select */
+#define                     nLRFS  0x0       
+#define                      RFSR  0x400      /* Receive Frame Sync Required Select */
+#define                     nRFSR  0x0       
+#define                      IRFS  0x200      /* Internal Receive Frame Sync Select */
+#define                     nIRFS  0x0       
+#define                    RLSBIT  0x10       /* Receive Bit Order */
+#define                   nRLSBIT  0x0       
+#define                    RDTYPE  0xc        /* Data Formatting Type Select */
+#define                     IRCLK  0x2        /* Internal Receive Clock Select */
+#define                    nIRCLK  0x0       
+#define                     RSPEN  0x1        /* Receive Enable */
+#define                    nRSPEN  0x0       
+
+/* Bit masks for SPORTx_RCR2 */
+
+#define                     RRFST  0x400      /* Left/Right Order */
+#define                    nRRFST  0x0       
+#define                     RSFSE  0x200      /* Receive Stereo Frame Sync Enable */
+#define                    nRSFSE  0x0       
+#define                      RXSE  0x100      /* RxSEC Enable */
+#define                     nRXSE  0x0       
+#define                    SLEN_R  0x1f       /* SPORT Word Length */
+
+/* Bit masks for SPORTx_STAT */
+
+#define                     TXHRE  0x40       /* Transmit Hold Register Empty */
+#define                    nTXHRE  0x0       
+#define                      TOVF  0x20       /* Sticky Transmit Overflow Status */
+#define                     nTOVF  0x0       
+#define                      TUVF  0x10       /* Sticky Transmit Underflow Status */
+#define                     nTUVF  0x0       
+#define                       TXF  0x8        /* Transmit FIFO Full Status */
+#define                      nTXF  0x0       
+#define                      ROVF  0x4        /* Sticky Receive Overflow Status */
+#define                     nROVF  0x0       
+#define                      RUVF  0x2        /* Sticky Receive Underflow Status */
+#define                     nRUVF  0x0       
+#define                      RXNE  0x1        /* Receive FIFO Not Empty Status */
+#define                     nRXNE  0x0       
+
+/* Bit masks for SPORTx_MCMC1 */
+
+#define                  SP_WSIZE  0xf000     /* Window Size */
+#define                   SP_WOFF  0x3ff      /* Windows Offset */
+
+/* Bit masks for SPORTx_MCMC2 */
+
+#define                       MFD  0xf000     /* Multi channel Frame Delay */
+#define                      FSDR  0x80       /* Frame Sync to Data Relationship */
+#define                     nFSDR  0x0       
+#define                     MCMEM  0x10       /* Multi channel Frame Mode Enable */
+#define                    nMCMEM  0x0       
+#define                   MCDRXPE  0x8        /* Multi channel DMA Receive Packing */
+#define                  nMCDRXPE  0x0       
+#define                   MCDTXPE  0x4        /* Multi channel DMA Transmit Packing */
+#define                  nMCDTXPE  0x0       
+#define                     MCCRM  0x3        /* 2X Clock Recovery Mode */
+
+/* Bit masks for SPORTx_CHNL */
+
+#define                  CUR_CHNL  0x3ff      /* Current Channel Indicator */
+
+/* Bit masks for UARTx_LCR */
+
+#if 0
+/* conflicts with legacy one in last section */
+#define                       WLS  0x3        /* Word Length Select */
+#endif
+#define                       STB  0x4        /* Stop Bits */
+#define                      nSTB  0x0       
+#define                       PEN  0x8        /* Parity Enable */
+#define                      nPEN  0x0       
+#define                       EPS  0x10       /* Even Parity Select */
+#define                      nEPS  0x0       
+#define                       STP  0x20       /* Sticky Parity */
+#define                      nSTP  0x0       
+#define                        SB  0x40       /* Set Break */
+#define                       nSB  0x0       
+
+/* Bit masks for UARTx_MCR */
+
+#define                      XOFF  0x1        /* Transmitter Off */
+#define                     nXOFF  0x0       
+#define                      MRTS  0x2        /* Manual Request To Send */
+#define                     nMRTS  0x0       
+#define                      RFIT  0x4        /* Receive FIFO IRQ Threshold */
+#define                     nRFIT  0x0       
+#define                      RFRT  0x8        /* Receive FIFO RTS Threshold */
+#define                     nRFRT  0x0       
+#define                  LOOP_ENA  0x10       /* Loopback Mode Enable */
+#define                 nLOOP_ENA  0x0       
+#define                     FCPOL  0x20       /* Flow Control Pin Polarity */
+#define                    nFCPOL  0x0       
+#define                      ARTS  0x40       /* Automatic Request To Send */
+#define                     nARTS  0x0       
+#define                      ACTS  0x80       /* Automatic Clear To Send */
+#define                     nACTS  0x0       
+
+/* Bit masks for UARTx_LSR */
+
+#define                        DR  0x1        /* Data Ready */
+#define                       nDR  0x0       
+#define                        OE  0x2        /* Overrun Error */
+#define                       nOE  0x0       
+#define                        PE  0x4        /* Parity Error */
+#define                       nPE  0x0       
+#define                        FE  0x8        /* Framing Error */
+#define                       nFE  0x0       
+#define                        BI  0x10       /* Break Interrupt */
+#define                       nBI  0x0       
+#define                      THRE  0x20       /* THR Empty */
+#define                     nTHRE  0x0       
+#define                      TEMT  0x40       /* Transmitter Empty */
+#define                     nTEMT  0x0       
+#define                       TFI  0x80       /* Transmission Finished Indicator */
+#define                      nTFI  0x0       
+
+/* Bit masks for UARTx_MSR */
+
+#define                      SCTS  0x1        /* Sticky CTS */
+#define                     nSCTS  0x0       
+#define                       CTS  0x10       /* Clear To Send */
+#define                      nCTS  0x0       
+#define                      RFCS  0x20       /* Receive FIFO Count Status */
+#define                     nRFCS  0x0       
+
+/* Bit masks for UARTx_IER_SET */
+
+#define                   ERBFI_S  0x1        /* Enable Receive Buffer Full Interrupt */
+#define                  nERBFI_S  0x0       
+#define                   ETBEI_S  0x2        /* Enable Transmit Buffer Empty Interrupt */
+#define                  nETBEI_S  0x0       
+#define                    ELSI_S  0x4        /* Enable Receive Status Interrupt */
+#define                   nELSI_S  0x0       
+#define                   EDSSI_S  0x8        /* Enable Modem Status Interrupt */
+#define                  nEDSSI_S  0x0       
+#define                  EDTPTI_S  0x10       /* Enable DMA Transmit PIRQ Interrupt */
+#define                 nEDTPTI_S  0x0       
+#define                    ETFI_S  0x20       /* Enable Transmission Finished Interrupt */
+#define                   nETFI_S  0x0       
+#define                   ERFCI_S  0x40       /* Enable Receive FIFO Count Interrupt */
+#define                  nERFCI_S  0x0       
+
+/* Bit masks for UARTx_IER_CLEAR */
+
+#define                   ERBFI_C  0x1        /* Enable Receive Buffer Full Interrupt */
+#define                  nERBFI_C  0x0       
+#define                   ETBEI_C  0x2        /* Enable Transmit Buffer Empty Interrupt */
+#define                  nETBEI_C  0x0       
+#define                    ELSI_C  0x4        /* Enable Receive Status Interrupt */
+#define                   nELSI_C  0x0       
+#define                   EDSSI_C  0x8        /* Enable Modem Status Interrupt */
+#define                  nEDSSI_C  0x0       
+#define                  EDTPTI_C  0x10       /* Enable DMA Transmit PIRQ Interrupt */
+#define                 nEDTPTI_C  0x0       
+#define                    ETFI_C  0x20       /* Enable Transmission Finished Interrupt */
+#define                   nETFI_C  0x0       
+#define                   ERFCI_C  0x40       /* Enable Receive FIFO Count Interrupt */
+#define                  nERFCI_C  0x0       
+
+/* Bit masks for UARTx_GCTL */
+
+#define                      UCEN  0x1        /* UART Enable */
+#define                     nUCEN  0x0       
+#define                      IREN  0x2        /* IrDA Mode Enable */
+#define                     nIREN  0x0       
+#define                     TPOLC  0x4        /* IrDA TX Polarity Change */
+#define                    nTPOLC  0x0       
+#define                     RPOLC  0x8        /* IrDA RX Polarity Change */
+#define                    nRPOLC  0x0       
+#define                       FPE  0x10       /* Force Parity Error */
+#define                      nFPE  0x0       
+#define                       FFE  0x20       /* Force Framing Error */
+#define                      nFFE  0x0       
+#define                      EDBO  0x40       /* Enable Divide-by-One */
+#define                     nEDBO  0x0       
+#define                     EGLSI  0x80       /* Enable Global LS Interrupt */
+#define                    nEGLSI  0x0       
+
+
+/* ******************************************* */
+/*     MULTI BIT MACRO ENUMERATIONS            */
+/* ******************************************* */
+
+/* BCODE bit field options (SYSCFG register) */
+
+#define BCODE_WAKEUP    0x0000  /* boot according to wake-up condition */
+#define BCODE_FULLBOOT  0x0010  /* always perform full boot */ 
+#define BCODE_QUICKBOOT 0x0020  /* always perform quick boot */
+#define BCODE_NOBOOT    0x0030  /* always perform full boot */
+
+/* CNT_COMMAND bit field options */
+ 
+#define W1LCNT_ZERO   0x0001   /* write 1 to load CNT_COUNTER with zero */
+#define W1LCNT_MIN    0x0004   /* write 1 to load CNT_COUNTER from CNT_MIN */
+#define W1LCNT_MAX    0x0008   /* write 1 to load CNT_COUNTER from CNT_MAX */
+ 
+#define W1LMIN_ZERO   0x0010   /* write 1 to load CNT_MIN with zero */
+#define W1LMIN_CNT    0x0020   /* write 1 to load CNT_MIN from CNT_COUNTER */
+#define W1LMIN_MAX    0x0080   /* write 1 to load CNT_MIN from CNT_MAX */
+ 
+#define W1LMAX_ZERO   0x0100   /* write 1 to load CNT_MAX with zero */
+#define W1LMAX_CNT    0x0200   /* write 1 to load CNT_MAX from CNT_COUNTER */
+#define W1LMAX_MIN    0x0400   /* write 1 to load CNT_MAX from CNT_MIN */
+ 
+/* CNT_CONFIG bit field options */
+ 
+#define CNTMODE_QUADENC  0x0000  /* quadrature encoder mode */
+#define CNTMODE_BINENC   0x0100  /* binary encoder mode */
+#define CNTMODE_UDCNT    0x0200  /* up/down counter mode */
+#define CNTMODE_DIRCNT   0x0400  /* direction counter mode */
+#define CNTMODE_DIRTMR   0x0500  /* direction timer mode */
+ 
+#define BNDMODE_COMP     0x0000  /* boundary compare mode */
+#define BNDMODE_ZERO     0x1000  /* boundary compare and zero mode */
+#define BNDMODE_CAPT     0x2000  /* boundary capture mode */
+#define BNDMODE_AEXT     0x3000  /* boundary auto-extend mode */
+
+/* TMODE in TIMERx_CONFIG bit field options */
+
+#define PWM_OUT  0x0001
+#define WDTH_CAP 0x0002
+#define EXT_CLK  0x0003
+
+/* UARTx_LCR bit field options */
+ 
+#define WLS_5   0x0000    /* 5 data bits */
+#define WLS_6   0x0001    /* 6 data bits */
+#define WLS_7   0x0002    /* 7 data bits */
+#define WLS_8   0x0003    /* 8 data bits */
+
+/* PINTx Register Bit Definitions */
+
+#define PIQ0 0x00000001
+#define PIQ1 0x00000002
+#define PIQ2 0x00000004
+#define PIQ3 0x00000008
+
+#define PIQ4 0x00000010
+#define PIQ5 0x00000020
+#define PIQ6 0x00000040
+#define PIQ7 0x00000080
+
+#define PIQ8 0x00000100
+#define PIQ9 0x00000200
+#define PIQ10 0x00000400
+#define PIQ11 0x00000800
+
+#define PIQ12 0x00001000
+#define PIQ13 0x00002000
+#define PIQ14 0x00004000
+#define PIQ15 0x00008000
+
+#define PIQ16 0x00010000
+#define PIQ17 0x00020000
+#define PIQ18 0x00040000
+#define PIQ19 0x00080000
+
+#define PIQ20 0x00100000
+#define PIQ21 0x00200000
+#define PIQ22 0x00400000
+#define PIQ23 0x00800000
+
+#define PIQ24 0x01000000
+#define PIQ25 0x02000000
+#define PIQ26 0x04000000
+#define PIQ27 0x08000000
+
+#define PIQ28 0x10000000
+#define PIQ29 0x20000000
+#define PIQ30 0x40000000
+#define PIQ31 0x80000000
+
+/* PORT A Bit Definitions for the registers 
+PORTA, PORTA_SET, PORTA_CLEAR,
+PORTA_DIR_SET, PORTA_DIR_CLEAR, PORTA_INEN,
+PORTA_FER registers
+*/
+
+#define PA0 0x0001
+#define PA1 0x0002
+#define PA2 0x0004
+#define PA3 0x0008
+#define PA4 0x0010
+#define PA5 0x0020
+#define PA6 0x0040
+#define PA7 0x0080
+#define PA8 0x0100
+#define PA9 0x0200
+#define PA10 0x0400
+#define PA11 0x0800
+#define PA12 0x1000
+#define PA13 0x2000
+#define PA14 0x4000
+#define PA15 0x8000
+
+/* PORT B Bit Definitions for the registers 
+PORTB, PORTB_SET, PORTB_CLEAR,
+PORTB_DIR_SET, PORTB_DIR_CLEAR, PORTB_INEN,
+PORTB_FER registers
+*/
+
+#define PB0 0x0001
+#define PB1 0x0002
+#define PB2 0x0004
+#define PB3 0x0008
+#define PB4 0x0010
+#define PB5 0x0020
+#define PB6 0x0040
+#define PB7 0x0080
+#define PB8 0x0100
+#define PB9 0x0200
+#define PB10 0x0400
+#define PB11 0x0800
+#define PB12 0x1000
+#define PB13 0x2000
+#define PB14 0x4000
+
+
+/* PORT C Bit Definitions for the registers 
+PORTC, PORTC_SET, PORTC_CLEAR,
+PORTC_DIR_SET, PORTC_DIR_CLEAR, PORTC_INEN,
+PORTC_FER registers
+*/
+
+
+#define PC0 0x0001
+#define PC1 0x0002
+#define PC2 0x0004
+#define PC3 0x0008
+#define PC4 0x0010
+#define PC5 0x0020
+#define PC6 0x0040
+#define PC7 0x0080
+#define PC8 0x0100
+#define PC9 0x0200
+#define PC10 0x0400
+#define PC11 0x0800
+#define PC12 0x1000
+#define PC13 0x2000
+
+
+/* PORT D Bit Definitions for the registers 
+PORTD, PORTD_SET, PORTD_CLEAR,
+PORTD_DIR_SET, PORTD_DIR_CLEAR, PORTD_INEN,
+PORTD_FER registers
+*/
+
+#define PD0 0x0001
+#define PD1 0x0002
+#define PD2 0x0004
+#define PD3 0x0008
+#define PD4 0x0010
+#define PD5 0x0020
+#define PD6 0x0040
+#define PD7 0x0080
+#define PD8 0x0100
+#define PD9 0x0200
+#define PD10 0x0400
+#define PD11 0x0800
+#define PD12 0x1000
+#define PD13 0x2000
+#define PD14 0x4000
+#define PD15 0x8000
+
+/* PORT E Bit Definitions for the registers 
+PORTE, PORTE_SET, PORTE_CLEAR,
+PORTE_DIR_SET, PORTE_DIR_CLEAR, PORTE_INEN,
+PORTE_FER registers
+*/
+
+
+#define PE0 0x0001
+#define PE1 0x0002
+#define PE2 0x0004
+#define PE3 0x0008
+#define PE4 0x0010
+#define PE5 0x0020
+#define PE6 0x0040
+#define PE7 0x0080
+#define PE8 0x0100
+#define PE9 0x0200
+#define PE10 0x0400
+#define PE11 0x0800
+#define PE12 0x1000
+#define PE13 0x2000
+#define PE14 0x4000
+#define PE15 0x8000
+
+/* PORT F Bit Definitions for the registers 
+PORTF, PORTF_SET, PORTF_CLEAR,
+PORTF_DIR_SET, PORTF_DIR_CLEAR, PORTF_INEN,
+PORTF_FER registers
+*/
+
+
+#define PF0 0x0001
+#define PF1 0x0002
+#define PF2 0x0004
+#define PF3 0x0008
+#define PF4 0x0010
+#define PF5 0x0020
+#define PF6 0x0040
+#define PF7 0x0080
+#define PF8 0x0100
+#define PF9 0x0200
+#define PF10 0x0400
+#define PF11 0x0800
+#define PF12 0x1000
+#define PF13 0x2000
+#define PF14 0x4000
+#define PF15 0x8000
+
+/* PORT G Bit Definitions for the registers 
+PORTG, PORTG_SET, PORTG_CLEAR,
+PORTG_DIR_SET, PORTG_DIR_CLEAR, PORTG_INEN,
+PORTG_FER registers
+*/
+
+
+#define PG0 0x0001
+#define PG1 0x0002
+#define PG2 0x0004
+#define PG3 0x0008
+#define PG4 0x0010
+#define PG5 0x0020
+#define PG6 0x0040
+#define PG7 0x0080
+#define PG8 0x0100
+#define PG9 0x0200
+#define PG10 0x0400
+#define PG11 0x0800
+#define PG12 0x1000
+#define PG13 0x2000
+#define PG14 0x4000
+#define PG15 0x8000
+
+/* PORT H Bit Definitions for the registers 
+PORTH, PORTH_SET, PORTH_CLEAR,
+PORTH_DIR_SET, PORTH_DIR_CLEAR, PORTH_INEN,
+PORTH_FER registers
+*/
+
+
+#define PH0 0x0001
+#define PH1 0x0002
+#define PH2 0x0004
+#define PH3 0x0008
+#define PH4 0x0010
+#define PH5 0x0020
+#define PH6 0x0040
+#define PH7 0x0080
+#define PH8 0x0100
+#define PH9 0x0200
+#define PH10 0x0400
+#define PH11 0x0800
+#define PH12 0x1000
+#define PH13 0x2000
+
+
+/* PORT I Bit Definitions for the registers 
+PORTI, PORTI_SET, PORTI_CLEAR,
+PORTI_DIR_SET, PORTI_DIR_CLEAR, PORTI_INEN,
+PORTI_FER registers
+*/
+
+
+#define PI0 0x0001
+#define PI1 0x0002
+#define PI2 0x0004
+#define PI3 0x0008
+#define PI4 0x0010
+#define PI5 0x0020
+#define PI6 0x0040
+#define PI7 0x0080
+#define PI8 0x0100
+#define PI9 0x0200
+#define PI10 0x0400
+#define PI11 0x0800
+#define PI12 0x1000
+#define PI13 0x2000
+#define PI14 0x4000
+#define PI15 0x8000
+
+/* PORT J Bit Definitions for the registers 
+PORTJ, PORTJ_SET, PORTJ_CLEAR,
+PORTJ_DIR_SET, PORTJ_DIR_CLEAR, PORTJ_INEN,
+PORTJ_FER registers
+*/
+
+
+#define PJ0 0x0001
+#define PJ1 0x0002
+#define PJ2 0x0004
+#define PJ3 0x0008
+#define PJ4 0x0010
+#define PJ5 0x0020
+#define PJ6 0x0040
+#define PJ7 0x0080
+#define PJ8 0x0100
+#define PJ9 0x0200
+#define PJ10 0x0400
+#define PJ11 0x0800
+#define PJ12 0x1000
+#define PJ13 0x2000
+ 
+
+/* Port Muxing Bit Fields for PORTx_MUX Registers */
+
+#define MUX0 0x00000003
+#define MUX0_0 0x00000000
+#define MUX0_1 0x00000001
+#define MUX0_2 0x00000002
+#define MUX0_3 0x00000003
+
+#define MUX1 0x0000000C
+#define MUX1_0 0x00000000
+#define MUX1_1 0x00000004
+#define MUX1_2 0x00000008
+#define MUX1_3 0x0000000C
+
+#define MUX2 0x00000030
+#define MUX2_0 0x00000000
+#define MUX2_1 0x00000010
+#define MUX2_2 0x00000020
+#define MUX2_3 0x00000030
+
+#define MUX3 0x000000C0
+#define MUX3_0 0x00000000
+#define MUX3_1 0x00000040
+#define MUX3_2 0x00000080
+#define MUX3_3 0x000000C0
+
+#define MUX4 0x00000300
+#define MUX4_0 0x00000000
+#define MUX4_1 0x00000100
+#define MUX4_2 0x00000200
+#define MUX4_3 0x00000300
+
+#define MUX5 0x00000C00
+#define MUX5_0 0x00000000
+#define MUX5_1 0x00000400
+#define MUX5_2 0x00000800
+#define MUX5_3 0x00000C00
+
+#define MUX6 0x00003000
+#define MUX6_0 0x00000000
+#define MUX6_1 0x00001000
+#define MUX6_2 0x00002000
+#define MUX6_3 0x00003000
+
+#define MUX7 0x0000C000
+#define MUX7_0 0x00000000
+#define MUX7_1 0x00004000
+#define MUX7_2 0x00008000
+#define MUX7_3 0x0000C000
+
+#define MUX8 0x00030000
+#define MUX8_0 0x00000000
+#define MUX8_1 0x00010000
+#define MUX8_2 0x00020000
+#define MUX8_3 0x00030000
+
+#define MUX9 0x000C0000
+#define MUX9_0 0x00000000
+#define MUX9_1 0x00040000
+#define MUX9_2 0x00080000
+#define MUX9_3 0x000C0000
+
+#define MUX10 0x00300000
+#define MUX10_0 0x00000000
+#define MUX10_1 0x00100000
+#define MUX10_2 0x00200000
+#define MUX10_3 0x00300000
+
+#define MUX11 0x00C00000
+#define MUX11_0 0x00000000
+#define MUX11_1 0x00400000
+#define MUX11_2 0x00800000
+#define MUX11_3 0x00C00000
+
+#define MUX12 0x03000000
+#define MUX12_0 0x00000000
+#define MUX12_1 0x01000000
+#define MUX12_2 0x02000000
+#define MUX12_3 0x03000000
+
+#define MUX13 0x0C000000
+#define MUX13_0 0x00000000
+#define MUX13_1 0x04000000
+#define MUX13_2 0x08000000
+#define MUX13_3 0x0C000000
+
+#define MUX14 0x30000000
+#define MUX14_0 0x00000000
+#define MUX14_1 0x10000000
+#define MUX14_2 0x20000000
+#define MUX14_3 0x30000000
+
+#define MUX15 0xC0000000
+#define MUX15_0 0x00000000
+#define MUX15_1 0x40000000
+#define MUX15_2 0x80000000
+#define MUX15_3 0xC0000000
+
+#define MUX(b15,b14,b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,b2,b1,b0) \
+    ((((b15)&3) << 30) | \
+     (((b14)&3) << 28) | \
+     (((b13)&3) << 26) | \
+     (((b12)&3) << 24) | \
+     (((b11)&3) << 22) | \
+     (((b10)&3) << 20) | \
+     (((b9) &3) << 18) | \
+     (((b8) &3) << 16) | \
+     (((b7) &3) << 14) | \
+     (((b6) &3) << 12) | \
+     (((b5) &3) << 10) | \
+     (((b4) &3) << 8)  | \
+     (((b3) &3) << 6)  | \
+     (((b2) &3) << 4)  | \
+     (((b1) &3) << 2)  | \
+     (((b0) &3)))
+
+/* Bit fields for PINT0_ASSIGN and PINT1_ASSIGN registers */
+
+#define B0MAP 0x000000FF     /* Byte 0 Lower Half Port Mapping */
+#define B0MAP_PAL 0x00000000 /* Map Port A Low to Byte 0 */
+#define B0MAP_PBL 0x00000001 /* Map Port B Low to Byte 0 */
+#define B1MAP 0x0000FF00     /* Byte 1 Upper Half Port Mapping */
+#define B1MAP_PAH 0x00000000 /* Map Port A High to Byte 1 */
+#define B1MAP_PBH 0x00000100 /* Map Port B High to Byte 1 */
+#define B2MAP 0x00FF0000     /* Byte 2 Lower Half Port Mapping */
+#define B2MAP_PAL 0x00000000 /* Map Port A Low to Byte 2 */
+#define B2MAP_PBL 0x00010000 /* Map Port B Low to Byte 2 */
+#define B3MAP 0xFF000000     /* Byte 3 Upper Half Port Mapping */
+#define B3MAP_PAH 0x00000000 /* Map Port A High to Byte 3 */
+#define B3MAP_PBH 0x01000000 /* Map Port B High to Byte 3 */
+
+/* Bit fields for PINT2_ASSIGN and PINT3_ASSIGN registers */
+
+#define B0MAP_PCL 0x00000000 /* Map Port C Low to Byte 0 */
+#define B0MAP_PDL 0x00000001 /* Map Port D Low to Byte 0 */
+#define B0MAP_PEL 0x00000002 /* Map Port E Low to Byte 0 */
+#define B0MAP_PFL 0x00000003 /* Map Port F Low to Byte 0 */
+#define B0MAP_PGL 0x00000004 /* Map Port G Low to Byte 0 */
+#define B0MAP_PHL 0x00000005 /* Map Port H Low to Byte 0 */
+#define B0MAP_PIL 0x00000006 /* Map Port I Low to Byte 0 */
+#define B0MAP_PJL 0x00000007 /* Map Port J Low to Byte 0 */
+
+#define B1MAP_PCH 0x00000000 /* Map Port C High to Byte 1 */ 
+#define B1MAP_PDH 0x00000100 /* Map Port D High to Byte 1 */
+#define B1MAP_PEH 0x00000200 /* Map Port E High to Byte 1 */
+#define B1MAP_PFH 0x00000300 /* Map Port F High to Byte 1 */
+#define B1MAP_PGH 0x00000400 /* Map Port G High to Byte 1 */
+#define B1MAP_PHH 0x00000500 /* Map Port H High to Byte 1 */
+#define B1MAP_PIH 0x00000600 /* Map Port I High to Byte 1 */
+#define B1MAP_PJH 0x00000700 /* Map Port J High to Byte 1 */
+
+#define B2MAP_PCL 0x00000000 /* Map Port C Low to Byte 2 */ 
+#define B2MAP_PDL 0x00010000 /* Map Port D Low to Byte 2 */ 
+#define B2MAP_PEL 0x00020000 /* Map Port E Low to Byte 2 */ 
+#define B2MAP_PFL 0x00030000 /* Map Port F Low to Byte 2 */ 
+#define B2MAP_PGL 0x00040000 /* Map Port G Low to Byte 2 */ 
+#define B2MAP_PHL 0x00050000 /* Map Port H Low to Byte 2 */ 
+#define B2MAP_PIL 0x00060000 /* Map Port I Low to Byte 2 */ 
+#define B2MAP_PJL 0x00070000 /* Map Port J Low to Byte 2 */ 
+
+#define B3MAP_PCH 0x00000000 /* Map Port C High to Byte 3 */ 
+#define B3MAP_PDH 0x01000000 /* Map Port D High to Byte 3 */ 
+#define B3MAP_PEH 0x02000000 /* Map Port E High to Byte 3 */ 
+#define B3MAP_PFH 0x03000000 /* Map Port F High to Byte 3 */ 
+#define B3MAP_PGH 0x04000000 /* Map Port G High to Byte 3 */ 
+#define B3MAP_PHH 0x05000000 /* Map Port H High to Byte 3 */ 
+#define B3MAP_PIH 0x06000000 /* Map Port I High to Byte 3 */ 
+#define B3MAP_PJH 0x07000000 /* Map Port J High to Byte 3 */ 
+
+
+/* for legacy compatibility */
+ 
+#define WLS(x)  (((x)-5) & 0x03) /* Word Length Select */
+#define W1LMAX_MAX W1LMAX_MIN
+#define EBIU_AMCBCTL0 EBIU_AMBCTL0
+#define EBIU_AMCBCTL1 EBIU_AMBCTL1
+#define PINT0_IRQ PINT0_REQUEST
+#define PINT1_IRQ PINT1_REQUEST
+#define PINT2_IRQ PINT2_REQUEST
+#define PINT3_IRQ PINT3_REQUEST
+
+#endif /* _DEF_BF54X_H */
diff --git a/include/asm-blackfin/mach-bf561/cdefBF561.h b/include/asm-blackfin/mach-bf561/cdefBF561.h
index 5dc0ed8..b14f872 100644
--- a/include/asm-blackfin/mach-bf561/cdefBF561.h
+++ b/include/asm-blackfin/mach-bf561/cdefBF561.h
@@ -59,12 +59,14 @@ static __inline__ void bfin_write_VR_CTL(unsigned int val)
 {
 	unsigned long flags, iwr;
 
-	bfin_write16(VR_CTL, val);
-	__builtin_bfin_ssync();
 	/* Enable the PLL Wakeup bit in SIC IWR */
 	iwr = bfin_read32(SICA_IWR0);
 	/* Only allow PPL Wakeup) */
 	bfin_write32(SICA_IWR0, IWR_ENABLE(0));
+
+	bfin_write16(VR_CTL, val);
+	__builtin_bfin_ssync();
+
 	local_irq_save(flags);
 	asm("IDLE;");
 	local_irq_restore(flags);
diff --git a/include/asm-blackfin/mach-bf561/defBF561.h b/include/asm-blackfin/mach-bf561/defBF561.h
index a6de4c6..89150ec 100644
--- a/include/asm-blackfin/mach-bf561/defBF561.h
+++ b/include/asm-blackfin/mach-bf561/defBF561.h
@@ -904,23 +904,6 @@
 #define IWR_ENABLE(x)	       (1 << (x))	/* Wakeup Enable Peripheral #x */
 #define IWR_DISABLE(x) (0xFFFFFFFF ^ (1 << (x)))	/* Wakeup Disable Peripheral #x */
 
-/* *********  WATCHDOG TIMER MASKS  ********************8 */
-
-/* Watchdog Timer WDOG_CTL Register */
-#define ICTL(x) ((x<<1) & 0x0006)
-#define ENABLE_RESET     0x00000000	/* Set Watchdog Timer to generate reset */
-#define ENABLE_NMI       0x00000002	/* Set Watchdog Timer to generate non-maskable interrupt */
-#define ENABLE_GPI       0x00000004	/* Set Watchdog Timer to generate general-purpose interrupt */
-#define DISABLE_EVT      0x00000006	/* Disable Watchdog Timer interrupts */
-
-#define TMR_EN		0x0000
-#define TMR_DIS		0x0AD0
-#define TRO		0x8000
-
-#define ICTL_P0		0x01
-#define ICTL_P1		0x02
-#define TRO_P		0x0F
-
 /* ***************************** UART CONTROLLER MASKS ********************** */
 
 /* UART_LCR Register */
@@ -1214,18 +1197,18 @@
 #define TIMIL9		0x0002
 #define TIMIL10		0x0004
 #define TIMIL11		0x0008
-#define TOVL_ERR0	0x00000010
-#define TOVL_ERR1	0x00000020
-#define TOVL_ERR2	0x00000040
-#define TOVL_ERR3	0x00000080
-#define TOVL_ERR4	0x00100000
-#define TOVL_ERR5	0x00200000
-#define TOVL_ERR6	0x00400000
-#define TOVL_ERR7	0x00800000
-#define TOVL_ERR8	0x0010
-#define TOVL_ERR9	0x0020
-#define TOVL_ERR10	0x0040
-#define TOVL_ERR11	0x0080
+#define TOVF_ERR0	0x00000010
+#define TOVF_ERR1	0x00000020
+#define TOVF_ERR2	0x00000040
+#define TOVF_ERR3	0x00000080
+#define TOVF_ERR4	0x00100000
+#define TOVF_ERR5	0x00200000
+#define TOVF_ERR6	0x00400000
+#define TOVF_ERR7	0x00800000
+#define TOVF_ERR8	0x0010
+#define TOVF_ERR9	0x0020
+#define TOVF_ERR10	0x0040
+#define TOVF_ERR11	0x0080
 #define TRUN0		0x00001000
 #define TRUN1		0x00002000
 #define TRUN2		0x00004000
@@ -1251,18 +1234,18 @@
 #define TIMIL9_P	0x01
 #define TIMIL10_P	0x02
 #define TIMIL11_P	0x03
-#define TOVL_ERR0_P	0x04
-#define TOVL_ERR1_P	0x05
-#define TOVL_ERR2_P	0x06
-#define TOVL_ERR3_P	0x07
-#define TOVL_ERR4_P	0x14
-#define TOVL_ERR5_P	0x15
-#define TOVL_ERR6_P	0x16
-#define TOVL_ERR7_P	0x17
-#define TOVL_ERR8_P	0x04
-#define TOVL_ERR9_P	0x05
-#define TOVL_ERR10_P	0x06
-#define TOVL_ERR11_P	0x07
+#define TOVF_ERR0_P	0x04
+#define TOVF_ERR1_P	0x05
+#define TOVF_ERR2_P	0x06
+#define TOVF_ERR3_P	0x07
+#define TOVF_ERR4_P	0x14
+#define TOVF_ERR5_P	0x15
+#define TOVF_ERR6_P	0x16
+#define TOVF_ERR7_P	0x17
+#define TOVF_ERR8_P	0x04
+#define TOVF_ERR9_P	0x05
+#define TOVF_ERR10_P	0x06
+#define TOVF_ERR11_P	0x07
 #define TRUN0_P		0x0C
 #define TRUN1_P		0x0D
 #define TRUN2_P		0x0E
@@ -1276,6 +1259,32 @@
 #define TRUN10_P	0x0E
 #define TRUN11_P	0x0F
 
+/* Alternate Deprecated Macros Provided For Backwards Code Compatibility */
+#define TOVL_ERR0 TOVF_ERR0
+#define TOVL_ERR1 TOVF_ERR1
+#define TOVL_ERR2 TOVF_ERR2
+#define TOVL_ERR3 TOVF_ERR3
+#define TOVL_ERR4 TOVF_ERR4
+#define TOVL_ERR5 TOVF_ERR5
+#define TOVL_ERR6 TOVF_ERR6
+#define TOVL_ERR7 TOVF_ERR7
+#define TOVL_ERR8 TOVF_ERR8
+#define TOVL_ERR9 TOVF_ERR9
+#define TOVL_ERR10 TOVF_ERR10
+#define TOVL_ERR11 TOVF_ERR11
+#define TOVL_ERR0_P TOVF_ERR0_P
+#define TOVL_ERR1_P TOVF_ERR1_P
+#define TOVL_ERR2_P TOVF_ERR2_P
+#define TOVL_ERR3_P TOVF_ERR3_P
+#define TOVL_ERR4_P TOVF_ERR4_P
+#define TOVL_ERR5_P TOVF_ERR5_P
+#define TOVL_ERR6_P TOVF_ERR6_P
+#define TOVL_ERR7_P TOVF_ERR7_P
+#define TOVL_ERR8_P TOVF_ERR8_P
+#define TOVL_ERR9_P TOVF_ERR9_P
+#define TOVL_ERR10_P TOVF_ERR10_P
+#define TOVL_ERR11_P TOVF_ERR11_P
+
 /* TIMERx_CONFIG Registers */
 #define PWM_OUT		0x0001
 #define WDTH_CAP	0x0002
@@ -1700,18 +1709,4 @@
 #define SDEASE		    0x00000010	/* SDRAM EAB sticky error status - W1C */
 #define BGSTAT			0x00000020	/* Bus granted */
 
-/*VR_CTL Masks*/
-#define WAKE                    0x100
-#define VLEV_6                  0x60
-#define VLEV_7                  0x70
-#define VLEV_8                  0x80
-#define VLEV_9                  0x90
-#define VLEV_10                 0xA0
-#define VLEV_11                 0xB0
-#define VLEV_12                 0xC0
-#define VLEV_13                 0xD0
-#define VLEV_14                 0xE0
-#define VLEV_15                 0xF0
-#define FREQ_3                  0x03
-
 #endif				/* _DEF_BF561_H */
diff --git a/include/asm-blackfin/mach-common/cdef_LPBlackfin.h b/include/asm-blackfin/mach-common/cdef_LPBlackfin.h
index 22aa5e6..d39c396 100644
--- a/include/asm-blackfin/mach-common/cdef_LPBlackfin.h
+++ b/include/asm-blackfin/mach-common/cdef_LPBlackfin.h
@@ -36,417 +36,288 @@
 #include <asm/mach-common/def_LPBlackfin.h>
 
 /*Cache & SRAM Memory*/
-#define pSRAM_BASE_ADDRESS ((volatile void **)SRAM_BASE_ADDRESS)
 #define bfin_read_SRAM_BASE_ADDRESS()        bfin_read32(SRAM_BASE_ADDRESS)
 #define bfin_write_SRAM_BASE_ADDRESS(val)    bfin_write32(SRAM_BASE_ADDRESS,val)
-#define pDMEM_CONTROL ((volatile unsigned long *)DMEM_CONTROL)
 #define bfin_read_DMEM_CONTROL()             bfin_read32(DMEM_CONTROL)
 #define bfin_write_DMEM_CONTROL(val)         bfin_write32(DMEM_CONTROL,val)
-#define pDCPLB_STATUS ((volatile unsigned long *)DCPLB_STATUS)
 #define bfin_read_DCPLB_STATUS()             bfin_read32(DCPLB_STATUS)
 #define bfin_write_DCPLB_STATUS(val)         bfin_write32(DCPLB_STATUS,val)
-#define pDCPLB_FAULT_ADDR ((volatile void **)DCPLB_FAULT_ADDR)
 #define bfin_read_DCPLB_FAULT_ADDR()         bfin_read32(DCPLB_FAULT_ADDR)
 #define bfin_write_DCPLB_FAULT_ADDR(val)     bfin_write32(DCPLB_FAULT_ADDR,val)
 /*
 #define MMR_TIMEOUT            0xFFE00010
 */
-#define pDCPLB_ADDR0 ((volatile void **)DCPLB_ADDR0)
 #define bfin_read_DCPLB_ADDR0()              bfin_read32(DCPLB_ADDR0)
 #define bfin_write_DCPLB_ADDR0(val)          bfin_write32(DCPLB_ADDR0,val)
-#define pDCPLB_ADDR1 ((volatile void **)DCPLB_ADDR1)
 #define bfin_read_DCPLB_ADDR1()              bfin_read32(DCPLB_ADDR1)
 #define bfin_write_DCPLB_ADDR1(val)          bfin_write32(DCPLB_ADDR1,val)
-#define pDCPLB_ADDR2 ((volatile void **)DCPLB_ADDR2)
 #define bfin_read_DCPLB_ADDR2()              bfin_read32(DCPLB_ADDR2)
 #define bfin_write_DCPLB_ADDR2(val)          bfin_write32(DCPLB_ADDR2,val)
-#define pDCPLB_ADDR3 ((volatile void **)DCPLB_ADDR3)
 #define bfin_read_DCPLB_ADDR3()              bfin_read32(DCPLB_ADDR3)
 #define bfin_write_DCPLB_ADDR3(val)          bfin_write32(DCPLB_ADDR3,val)
-#define pDCPLB_ADDR4 ((volatile void **)DCPLB_ADDR4)
 #define bfin_read_DCPLB_ADDR4()              bfin_read32(DCPLB_ADDR4)
 #define bfin_write_DCPLB_ADDR4(val)          bfin_write32(DCPLB_ADDR4,val)
-#define pDCPLB_ADDR5 ((volatile void **)DCPLB_ADDR5)
 #define bfin_read_DCPLB_ADDR5()              bfin_read32(DCPLB_ADDR5)
 #define bfin_write_DCPLB_ADDR5(val)          bfin_write32(DCPLB_ADDR5,val)
-#define pDCPLB_ADDR6 ((volatile void **)DCPLB_ADDR6)
 #define bfin_read_DCPLB_ADDR6()              bfin_read32(DCPLB_ADDR6)
 #define bfin_write_DCPLB_ADDR6(val)          bfin_write32(DCPLB_ADDR6,val)
-#define pDCPLB_ADDR7 ((volatile void **)DCPLB_ADDR7)
 #define bfin_read_DCPLB_ADDR7()              bfin_read32(DCPLB_ADDR7)
 #define bfin_write_DCPLB_ADDR7(val)          bfin_write32(DCPLB_ADDR7,val)
-#define pDCPLB_ADDR8 ((volatile void **)DCPLB_ADDR8)
 #define bfin_read_DCPLB_ADDR8()              bfin_read32(DCPLB_ADDR8)
 #define bfin_write_DCPLB_ADDR8(val)          bfin_write32(DCPLB_ADDR8,val)
-#define pDCPLB_ADDR9 ((volatile void **)DCPLB_ADDR9)
 #define bfin_read_DCPLB_ADDR9()              bfin_read32(DCPLB_ADDR9)
 #define bfin_write_DCPLB_ADDR9(val)          bfin_write32(DCPLB_ADDR9,val)
-#define pDCPLB_ADDR10 ((volatile void **)DCPLB_ADDR10)
 #define bfin_read_DCPLB_ADDR10()             bfin_read32(DCPLB_ADDR10)
 #define bfin_write_DCPLB_ADDR10(val)         bfin_write32(DCPLB_ADDR10,val)
-#define pDCPLB_ADDR11 ((volatile void **)DCPLB_ADDR11)
 #define bfin_read_DCPLB_ADDR11()             bfin_read32(DCPLB_ADDR11)
 #define bfin_write_DCPLB_ADDR11(val)         bfin_write32(DCPLB_ADDR11,val)
-#define pDCPLB_ADDR12 ((volatile void **)DCPLB_ADDR12)
 #define bfin_read_DCPLB_ADDR12()             bfin_read32(DCPLB_ADDR12)
 #define bfin_write_DCPLB_ADDR12(val)         bfin_write32(DCPLB_ADDR12,val)
-#define pDCPLB_ADDR13 ((volatile void **)DCPLB_ADDR13)
 #define bfin_read_DCPLB_ADDR13()             bfin_read32(DCPLB_ADDR13)
 #define bfin_write_DCPLB_ADDR13(val)         bfin_write32(DCPLB_ADDR13,val)
-#define pDCPLB_ADDR14 ((volatile void **)DCPLB_ADDR14)
 #define bfin_read_DCPLB_ADDR14()             bfin_read32(DCPLB_ADDR14)
 #define bfin_write_DCPLB_ADDR14(val)         bfin_write32(DCPLB_ADDR14,val)
-#define pDCPLB_ADDR15 ((volatile void **)DCPLB_ADDR15)
 #define bfin_read_DCPLB_ADDR15()             bfin_read32(DCPLB_ADDR15)
 #define bfin_write_DCPLB_ADDR15(val)         bfin_write32(DCPLB_ADDR15,val)
-#define pDCPLB_DATA0 ((volatile unsigned long *)DCPLB_DATA0)
 #define bfin_read_DCPLB_DATA0()              bfin_read32(DCPLB_DATA0)
 #define bfin_write_DCPLB_DATA0(val)          bfin_write32(DCPLB_DATA0,val)
-#define pDCPLB_DATA1 ((volatile unsigned long *)DCPLB_DATA1)
 #define bfin_read_DCPLB_DATA1()              bfin_read32(DCPLB_DATA1)
 #define bfin_write_DCPLB_DATA1(val)          bfin_write32(DCPLB_DATA1,val)
-#define pDCPLB_DATA2 ((volatile unsigned long *)DCPLB_DATA2)
 #define bfin_read_DCPLB_DATA2()              bfin_read32(DCPLB_DATA2)
 #define bfin_write_DCPLB_DATA2(val)          bfin_write32(DCPLB_DATA2,val)
-#define pDCPLB_DATA3 ((volatile unsigned long *)DCPLB_DATA3)
 #define bfin_read_DCPLB_DATA3()              bfin_read32(DCPLB_DATA3)
 #define bfin_write_DCPLB_DATA3(val)          bfin_write32(DCPLB_DATA3,val)
-#define pDCPLB_DATA4 ((volatile unsigned long *)DCPLB_DATA4)
 #define bfin_read_DCPLB_DATA4()              bfin_read32(DCPLB_DATA4)
 #define bfin_write_DCPLB_DATA4(val)          bfin_write32(DCPLB_DATA4,val)
-#define pDCPLB_DATA5 ((volatile unsigned long *)DCPLB_DATA5)
 #define bfin_read_DCPLB_DATA5()              bfin_read32(DCPLB_DATA5)
 #define bfin_write_DCPLB_DATA5(val)          bfin_write32(DCPLB_DATA5,val)
-#define pDCPLB_DATA6 ((volatile unsigned long *)DCPLB_DATA6)
 #define bfin_read_DCPLB_DATA6()              bfin_read32(DCPLB_DATA6)
 #define bfin_write_DCPLB_DATA6(val)          bfin_write32(DCPLB_DATA6,val)
-#define pDCPLB_DATA7 ((volatile unsigned long *)DCPLB_DATA7)
 #define bfin_read_DCPLB_DATA7()              bfin_read32(DCPLB_DATA7)
 #define bfin_write_DCPLB_DATA7(val)          bfin_write32(DCPLB_DATA7,val)
-#define pDCPLB_DATA8 ((volatile unsigned long *)DCPLB_DATA8)
 #define bfin_read_DCPLB_DATA8()              bfin_read32(DCPLB_DATA8)
 #define bfin_write_DCPLB_DATA8(val)          bfin_write32(DCPLB_DATA8,val)
-#define pDCPLB_DATA9 ((volatile unsigned long *)DCPLB_DATA9)
 #define bfin_read_DCPLB_DATA9()              bfin_read32(DCPLB_DATA9)
 #define bfin_write_DCPLB_DATA9(val)          bfin_write32(DCPLB_DATA9,val)
-#define pDCPLB_DATA10 ((volatile unsigned long *)DCPLB_DATA10)
 #define bfin_read_DCPLB_DATA10()             bfin_read32(DCPLB_DATA10)
 #define bfin_write_DCPLB_DATA10(val)         bfin_write32(DCPLB_DATA10,val)
-#define pDCPLB_DATA11 ((volatile unsigned long *)DCPLB_DATA11)
 #define bfin_read_DCPLB_DATA11()             bfin_read32(DCPLB_DATA11)
 #define bfin_write_DCPLB_DATA11(val)         bfin_write32(DCPLB_DATA11,val)
-#define pDCPLB_DATA12 ((volatile unsigned long *)DCPLB_DATA12)
 #define bfin_read_DCPLB_DATA12()             bfin_read32(DCPLB_DATA12)
 #define bfin_write_DCPLB_DATA12(val)         bfin_write32(DCPLB_DATA12,val)
-#define pDCPLB_DATA13 ((volatile unsigned long *)DCPLB_DATA13)
 #define bfin_read_DCPLB_DATA13()             bfin_read32(DCPLB_DATA13)
 #define bfin_write_DCPLB_DATA13(val)         bfin_write32(DCPLB_DATA13,val)
-#define pDCPLB_DATA14 ((volatile unsigned long *)DCPLB_DATA14)
 #define bfin_read_DCPLB_DATA14()             bfin_read32(DCPLB_DATA14)
 #define bfin_write_DCPLB_DATA14(val)         bfin_write32(DCPLB_DATA14,val)
-#define pDCPLB_DATA15 ((volatile unsigned long *)DCPLB_DATA15)
 #define bfin_read_DCPLB_DATA15()             bfin_read32(DCPLB_DATA15)
 #define bfin_write_DCPLB_DATA15(val)         bfin_write32(DCPLB_DATA15,val)
-#define pDTEST_COMMAND ((volatile unsigned long *)DTEST_COMMAND)
 #define bfin_read_DTEST_COMMAND()            bfin_read32(DTEST_COMMAND)
 #define bfin_write_DTEST_COMMAND(val)        bfin_write32(DTEST_COMMAND,val)
 /*
 #define DTEST_INDEX            0xFFE00304
 */
-#define pDTEST_DATA0 ((volatile unsigned long *)DTEST_DATA0)
 #define bfin_read_DTEST_DATA0()              bfin_read32(DTEST_DATA0)
 #define bfin_write_DTEST_DATA0(val)          bfin_write32(DTEST_DATA0,val)
-#define pDTEST_DATA1 ((volatile unsigned long *)DTEST_DATA1)
 #define bfin_read_DTEST_DATA1()              bfin_read32(DTEST_DATA1)
 #define bfin_write_DTEST_DATA1(val)          bfin_write32(DTEST_DATA1,val)
 /*
 #define DTEST_DATA2            0xFFE00408
 #define DTEST_DATA3            0xFFE0040C
 */
-#define pIMEM_CONTROL ((volatile unsigned long *)IMEM_CONTROL)
 #define bfin_read_IMEM_CONTROL()             bfin_read32(IMEM_CONTROL)
 #define bfin_write_IMEM_CONTROL(val)         bfin_write32(IMEM_CONTROL,val)
-#define pICPLB_STATUS ((volatile unsigned long *)ICPLB_STATUS)
 #define bfin_read_ICPLB_STATUS()             bfin_read32(ICPLB_STATUS)
 #define bfin_write_ICPLB_STATUS(val)         bfin_write32(ICPLB_STATUS,val)
-#define pICPLB_FAULT_ADDR ((volatile void **)ICPLB_FAULT_ADDR)
 #define bfin_read_ICPLB_FAULT_ADDR()         bfin_read32(ICPLB_FAULT_ADDR)
 #define bfin_write_ICPLB_FAULT_ADDR(val)     bfin_write32(ICPLB_FAULT_ADDR,val)
-#define pICPLB_ADDR0 ((volatile void **)ICPLB_ADDR0)
 #define bfin_read_ICPLB_ADDR0()              bfin_read32(ICPLB_ADDR0)
 #define bfin_write_ICPLB_ADDR0(val)          bfin_write32(ICPLB_ADDR0,val)
-#define pICPLB_ADDR1 ((volatile void **)ICPLB_ADDR1)
 #define bfin_read_ICPLB_ADDR1()              bfin_read32(ICPLB_ADDR1)
 #define bfin_write_ICPLB_ADDR1(val)          bfin_write32(ICPLB_ADDR1,val)
-#define pICPLB_ADDR2 ((volatile void **)ICPLB_ADDR2)
 #define bfin_read_ICPLB_ADDR2()              bfin_read32(ICPLB_ADDR2)
 #define bfin_write_ICPLB_ADDR2(val)          bfin_write32(ICPLB_ADDR2,val)
-#define pICPLB_ADDR3 ((volatile void **)ICPLB_ADDR3)
 #define bfin_read_ICPLB_ADDR3()              bfin_read32(ICPLB_ADDR3)
 #define bfin_write_ICPLB_ADDR3(val)          bfin_write32(ICPLB_ADDR3,val)
-#define pICPLB_ADDR4 ((volatile void **)ICPLB_ADDR4)
 #define bfin_read_ICPLB_ADDR4()              bfin_read32(ICPLB_ADDR4)
 #define bfin_write_ICPLB_ADDR4(val)          bfin_write32(ICPLB_ADDR4,val)
-#define pICPLB_ADDR5 ((volatile void **)ICPLB_ADDR5)
 #define bfin_read_ICPLB_ADDR5()              bfin_read32(ICPLB_ADDR5)
 #define bfin_write_ICPLB_ADDR5(val)          bfin_write32(ICPLB_ADDR5,val)
-#define pICPLB_ADDR6 ((volatile void **)ICPLB_ADDR6)
 #define bfin_read_ICPLB_ADDR6()              bfin_read32(ICPLB_ADDR6)
 #define bfin_write_ICPLB_ADDR6(val)          bfin_write32(ICPLB_ADDR6,val)
-#define pICPLB_ADDR7 ((volatile void **)ICPLB_ADDR7)
 #define bfin_read_ICPLB_ADDR7()              bfin_read32(ICPLB_ADDR7)
 #define bfin_write_ICPLB_ADDR7(val)          bfin_write32(ICPLB_ADDR7,val)
-#define pICPLB_ADDR8 ((volatile void **)ICPLB_ADDR8)
 #define bfin_read_ICPLB_ADDR8()              bfin_read32(ICPLB_ADDR8)
 #define bfin_write_ICPLB_ADDR8(val)          bfin_write32(ICPLB_ADDR8,val)
-#define pICPLB_ADDR9 ((volatile void **)ICPLB_ADDR9)
 #define bfin_read_ICPLB_ADDR9()              bfin_read32(ICPLB_ADDR9)
 #define bfin_write_ICPLB_ADDR9(val)          bfin_write32(ICPLB_ADDR9,val)
-#define pICPLB_ADDR10 ((volatile void **)ICPLB_ADDR10)
 #define bfin_read_ICPLB_ADDR10()             bfin_read32(ICPLB_ADDR10)
 #define bfin_write_ICPLB_ADDR10(val)         bfin_write32(ICPLB_ADDR10,val)
-#define pICPLB_ADDR11 ((volatile void **)ICPLB_ADDR11)
 #define bfin_read_ICPLB_ADDR11()             bfin_read32(ICPLB_ADDR11)
 #define bfin_write_ICPLB_ADDR11(val)         bfin_write32(ICPLB_ADDR11,val)
-#define pICPLB_ADDR12 ((volatile void **)ICPLB_ADDR12)
 #define bfin_read_ICPLB_ADDR12()             bfin_read32(ICPLB_ADDR12)
 #define bfin_write_ICPLB_ADDR12(val)         bfin_write32(ICPLB_ADDR12,val)
-#define pICPLB_ADDR13 ((volatile void **)ICPLB_ADDR13)
 #define bfin_read_ICPLB_ADDR13()             bfin_read32(ICPLB_ADDR13)
 #define bfin_write_ICPLB_ADDR13(val)         bfin_write32(ICPLB_ADDR13,val)
-#define pICPLB_ADDR14 ((volatile void **)ICPLB_ADDR14)
 #define bfin_read_ICPLB_ADDR14()             bfin_read32(ICPLB_ADDR14)
 #define bfin_write_ICPLB_ADDR14(val)         bfin_write32(ICPLB_ADDR14,val)
-#define pICPLB_ADDR15 ((volatile void **)ICPLB_ADDR15)
 #define bfin_read_ICPLB_ADDR15()             bfin_read32(ICPLB_ADDR15)
 #define bfin_write_ICPLB_ADDR15(val)         bfin_write32(ICPLB_ADDR15,val)
-#define pICPLB_DATA0 ((volatile unsigned long *)ICPLB_DATA0)
 #define bfin_read_ICPLB_DATA0()              bfin_read32(ICPLB_DATA0)
 #define bfin_write_ICPLB_DATA0(val)          bfin_write32(ICPLB_DATA0,val)
-#define pICPLB_DATA1 ((volatile unsigned long *)ICPLB_DATA1)
 #define bfin_read_ICPLB_DATA1()              bfin_read32(ICPLB_DATA1)
 #define bfin_write_ICPLB_DATA1(val)          bfin_write32(ICPLB_DATA1,val)
-#define pICPLB_DATA2 ((volatile unsigned long *)ICPLB_DATA2)
 #define bfin_read_ICPLB_DATA2()              bfin_read32(ICPLB_DATA2)
 #define bfin_write_ICPLB_DATA2(val)          bfin_write32(ICPLB_DATA2,val)
-#define pICPLB_DATA3 ((volatile unsigned long *)ICPLB_DATA3)
 #define bfin_read_ICPLB_DATA3()              bfin_read32(ICPLB_DATA3)
 #define bfin_write_ICPLB_DATA3(val)          bfin_write32(ICPLB_DATA3,val)
-#define pICPLB_DATA4 ((volatile unsigned long *)ICPLB_DATA4)
 #define bfin_read_ICPLB_DATA4()              bfin_read32(ICPLB_DATA4)
 #define bfin_write_ICPLB_DATA4(val)          bfin_write32(ICPLB_DATA4,val)
-#define pICPLB_DATA5 ((volatile unsigned long *)ICPLB_DATA5)
 #define bfin_read_ICPLB_DATA5()              bfin_read32(ICPLB_DATA5)
 #define bfin_write_ICPLB_DATA5(val)          bfin_write32(ICPLB_DATA5,val)
-#define pICPLB_DATA6 ((volatile unsigned long *)ICPLB_DATA6)
 #define bfin_read_ICPLB_DATA6()              bfin_read32(ICPLB_DATA6)
 #define bfin_write_ICPLB_DATA6(val)          bfin_write32(ICPLB_DATA6,val)
-#define pICPLB_DATA7 ((volatile unsigned long *)ICPLB_DATA7)
 #define bfin_read_ICPLB_DATA7()              bfin_read32(ICPLB_DATA7)
 #define bfin_write_ICPLB_DATA7(val)          bfin_write32(ICPLB_DATA7,val)
-#define pICPLB_DATA8 ((volatile unsigned long *)ICPLB_DATA8)
 #define bfin_read_ICPLB_DATA8()              bfin_read32(ICPLB_DATA8)
 #define bfin_write_ICPLB_DATA8(val)          bfin_write32(ICPLB_DATA8,val)
-#define pICPLB_DATA9 ((volatile unsigned long *)ICPLB_DATA9)
 #define bfin_read_ICPLB_DATA9()              bfin_read32(ICPLB_DATA9)
 #define bfin_write_ICPLB_DATA9(val)          bfin_write32(ICPLB_DATA9,val)
-#define pICPLB_DATA10 ((volatile unsigned long *)ICPLB_DATA10)
 #define bfin_read_ICPLB_DATA10()             bfin_read32(ICPLB_DATA10)
 #define bfin_write_ICPLB_DATA10(val)         bfin_write32(ICPLB_DATA10,val)
-#define pICPLB_DATA11 ((volatile unsigned long *)ICPLB_DATA11)
 #define bfin_read_ICPLB_DATA11()             bfin_read32(ICPLB_DATA11)
 #define bfin_write_ICPLB_DATA11(val)         bfin_write32(ICPLB_DATA11,val)
-#define pICPLB_DATA12 ((volatile unsigned long *)ICPLB_DATA12)
 #define bfin_read_ICPLB_DATA12()             bfin_read32(ICPLB_DATA12)
 #define bfin_write_ICPLB_DATA12(val)         bfin_write32(ICPLB_DATA12,val)
-#define pICPLB_DATA13 ((volatile unsigned long *)ICPLB_DATA13)
 #define bfin_read_ICPLB_DATA13()             bfin_read32(ICPLB_DATA13)
 #define bfin_write_ICPLB_DATA13(val)         bfin_write32(ICPLB_DATA13,val)
-#define pICPLB_DATA14 ((volatile unsigned long *)ICPLB_DATA14)
 #define bfin_read_ICPLB_DATA14()             bfin_read32(ICPLB_DATA14)
 #define bfin_write_ICPLB_DATA14(val)         bfin_write32(ICPLB_DATA14,val)
-#define pICPLB_DATA15 ((volatile unsigned long *)ICPLB_DATA15)
 #define bfin_read_ICPLB_DATA15()             bfin_read32(ICPLB_DATA15)
 #define bfin_write_ICPLB_DATA15(val)         bfin_write32(ICPLB_DATA15,val)
-#define pITEST_COMMAND ((volatile unsigned long *)ITEST_COMMAND)
 #define bfin_read_ITEST_COMMAND()            bfin_read32(ITEST_COMMAND)
 #define bfin_write_ITEST_COMMAND(val)        bfin_write32(ITEST_COMMAND,val)
 #if 0
 #define ITEST_INDEX            0xFFE01304   /* Instruction Test Index Register */
 #endif
-#define pITEST_DATA0 ((volatile unsigned long *)ITEST_DATA0)
 #define bfin_read_ITEST_DATA0()              bfin_read32(ITEST_DATA0)
 #define bfin_write_ITEST_DATA0(val)          bfin_write32(ITEST_DATA0,val)
-#define pITEST_DATA1 ((volatile unsigned long *)ITEST_DATA1)
 #define bfin_read_ITEST_DATA1()              bfin_read32(ITEST_DATA1)
 #define bfin_write_ITEST_DATA1(val)          bfin_write32(ITEST_DATA1,val)
 
 /* Event/Interrupt Registers*/
 
-#define pEVT0 ((volatile void **)EVT0)
 #define bfin_read_EVT0()                     bfin_read32(EVT0)
 #define bfin_write_EVT0(val)                 bfin_write32(EVT0,val)
-#define pEVT1 ((volatile void **)EVT1)
 #define bfin_read_EVT1()                     bfin_read32(EVT1)
 #define bfin_write_EVT1(val)                 bfin_write32(EVT1,val)
-#define pEVT2 ((volatile void **)EVT2)
 #define bfin_read_EVT2()                     bfin_read32(EVT2)
 #define bfin_write_EVT2(val)                 bfin_write32(EVT2,val)
-#define pEVT3 ((volatile void **)EVT3)
 #define bfin_read_EVT3()                     bfin_read32(EVT3)
 #define bfin_write_EVT3(val)                 bfin_write32(EVT3,val)
-#define pEVT4 ((volatile void **)EVT4)
 #define bfin_read_EVT4()                     bfin_read32(EVT4)
 #define bfin_write_EVT4(val)                 bfin_write32(EVT4,val)
-#define pEVT5 ((volatile void **)EVT5)
 #define bfin_read_EVT5()                     bfin_read32(EVT5)
 #define bfin_write_EVT5(val)                 bfin_write32(EVT5,val)
-#define pEVT6 ((volatile void **)EVT6)
 #define bfin_read_EVT6()                     bfin_read32(EVT6)
 #define bfin_write_EVT6(val)                 bfin_write32(EVT6,val)
-#define pEVT7 ((volatile void **)EVT7)
 #define bfin_read_EVT7()                     bfin_read32(EVT7)
 #define bfin_write_EVT7(val)                 bfin_write32(EVT7,val)
-#define pEVT8 ((volatile void **)EVT8)
 #define bfin_read_EVT8()                     bfin_read32(EVT8)
 #define bfin_write_EVT8(val)                 bfin_write32(EVT8,val)
-#define pEVT9 ((volatile void **)EVT9)
 #define bfin_read_EVT9()                     bfin_read32(EVT9)
 #define bfin_write_EVT9(val)                 bfin_write32(EVT9,val)
-#define pEVT10 ((volatile void **)EVT10)
 #define bfin_read_EVT10()                    bfin_read32(EVT10)
 #define bfin_write_EVT10(val)                bfin_write32(EVT10,val)
-#define pEVT11 ((volatile void **)EVT11)
 #define bfin_read_EVT11()                    bfin_read32(EVT11)
 #define bfin_write_EVT11(val)                bfin_write32(EVT11,val)
-#define pEVT12 ((volatile void **)EVT12)
 #define bfin_read_EVT12()                    bfin_read32(EVT12)
 #define bfin_write_EVT12(val)                bfin_write32(EVT12,val)
-#define pEVT13 ((volatile void **)EVT13)
 #define bfin_read_EVT13()                    bfin_read32(EVT13)
 #define bfin_write_EVT13(val)                bfin_write32(EVT13,val)
-#define pEVT14 ((volatile void **)EVT14)
 #define bfin_read_EVT14()                    bfin_read32(EVT14)
 #define bfin_write_EVT14(val)                bfin_write32(EVT14,val)
-#define pEVT15 ((volatile void **)EVT15)
 #define bfin_read_EVT15()                    bfin_read32(EVT15)
 #define bfin_write_EVT15(val)                bfin_write32(EVT15,val)
-#define pIMASK ((volatile unsigned long *)IMASK)
 #define bfin_read_IMASK()                    bfin_read32(IMASK)
 #define bfin_write_IMASK(val)                bfin_write32(IMASK,val)
-#define pIPEND ((volatile unsigned long *)IPEND)
 #define bfin_read_IPEND()                    bfin_read32(IPEND)
 #define bfin_write_IPEND(val)                bfin_write32(IPEND,val)
-#define pILAT ((volatile unsigned long *)ILAT)
 #define bfin_read_ILAT()                     bfin_read32(ILAT)
 #define bfin_write_ILAT(val)                 bfin_write32(ILAT,val)
 
 /*Core Timer Registers*/
-#define pTCNTL ((volatile unsigned long *)TCNTL)
 #define bfin_read_TCNTL()                    bfin_read32(TCNTL)
 #define bfin_write_TCNTL(val)                bfin_write32(TCNTL,val)
-#define pTPERIOD ((volatile unsigned long *)TPERIOD)
 #define bfin_read_TPERIOD()                  bfin_read32(TPERIOD)
 #define bfin_write_TPERIOD(val)              bfin_write32(TPERIOD,val)
-#define pTSCALE ((volatile unsigned long *)TSCALE)
 #define bfin_read_TSCALE()                   bfin_read32(TSCALE)
 #define bfin_write_TSCALE(val)               bfin_write32(TSCALE,val)
-#define pTCOUNT ((volatile unsigned long *)TCOUNT)
 #define bfin_read_TCOUNT()                   bfin_read32(TCOUNT)
 #define bfin_write_TCOUNT(val)               bfin_write32(TCOUNT,val)
 
 /*Debug/MP/Emulation Registers*/
-#define pDSPID ((volatile unsigned long *)DSPID)
 #define bfin_read_DSPID()                    bfin_read32(DSPID)
 #define bfin_write_DSPID(val)                bfin_write32(DSPID,val)
-#define pDBGCTL ((volatile unsigned long *)DBGCTL)
 #define bfin_read_DBGCTL()                   bfin_read32(DBGCTL)
 #define bfin_write_DBGCTL(val)               bfin_write32(DBGCTL,val)
-#define pDBGSTAT ((volatile unsigned long *)DBGSTAT)
 #define bfin_read_DBGSTAT()                  bfin_read32(DBGSTAT)
 #define bfin_write_DBGSTAT(val)              bfin_write32(DBGSTAT,val)
-#define pEMUDAT ((volatile unsigned long *)EMUDAT)
 #define bfin_read_EMUDAT()                   bfin_read32(EMUDAT)
 #define bfin_write_EMUDAT(val)               bfin_write32(EMUDAT,val)
 
 /*Trace Buffer Registers*/
-#define pTBUFCTL ((volatile unsigned long *)TBUFCTL)
 #define bfin_read_TBUFCTL()                  bfin_read32(TBUFCTL)
 #define bfin_write_TBUFCTL(val)              bfin_write32(TBUFCTL,val)
-#define pTBUFSTAT ((volatile unsigned long *)TBUFSTAT)
 #define bfin_read_TBUFSTAT()                 bfin_read32(TBUFSTAT)
 #define bfin_write_TBUFSTAT(val)             bfin_write32(TBUFSTAT,val)
-#define pTBUF ((volatile void **)TBUF)
 #define bfin_read_TBUF()                     bfin_read32(TBUF)
 #define bfin_write_TBUF(val)                 bfin_write32(TBUF,val)
 
 /*Watch Point Control Registers*/
-#define pWPIACTL ((volatile unsigned long *)WPIACTL)
 #define bfin_read_WPIACTL()                  bfin_read32(WPIACTL)
 #define bfin_write_WPIACTL(val)              bfin_write32(WPIACTL,val)
-#define pWPIA0 ((volatile void **)WPIA0)
 #define bfin_read_WPIA0()                    bfin_read32(WPIA0)
 #define bfin_write_WPIA0(val)                bfin_write32(WPIA0,val)
-#define pWPIA1 ((volatile void **)WPIA1)
 #define bfin_read_WPIA1()                    bfin_read32(WPIA1)
 #define bfin_write_WPIA1(val)                bfin_write32(WPIA1,val)
-#define pWPIA2 ((volatile void **)WPIA2)
 #define bfin_read_WPIA2()                    bfin_read32(WPIA2)
 #define bfin_write_WPIA2(val)                bfin_write32(WPIA2,val)
-#define pWPIA3 ((volatile void **)WPIA3)
 #define bfin_read_WPIA3()                    bfin_read32(WPIA3)
 #define bfin_write_WPIA3(val)                bfin_write32(WPIA3,val)
-#define pWPIA4 ((volatile void **)WPIA4)
 #define bfin_read_WPIA4()                    bfin_read32(WPIA4)
 #define bfin_write_WPIA4(val)                bfin_write32(WPIA4,val)
-#define pWPIA5 ((volatile void **)WPIA5)
 #define bfin_read_WPIA5()                    bfin_read32(WPIA5)
 #define bfin_write_WPIA5(val)                bfin_write32(WPIA5,val)
-#define pWPIACNT0 ((volatile unsigned long *)WPIACNT0)
 #define bfin_read_WPIACNT0()                 bfin_read32(WPIACNT0)
 #define bfin_write_WPIACNT0(val)             bfin_write32(WPIACNT0,val)
-#define pWPIACNT1 ((volatile unsigned long *)WPIACNT1)
 #define bfin_read_WPIACNT1()                 bfin_read32(WPIACNT1)
 #define bfin_write_WPIACNT1(val)             bfin_write32(WPIACNT1,val)
-#define pWPIACNT2 ((volatile unsigned long *)WPIACNT2)
 #define bfin_read_WPIACNT2()                 bfin_read32(WPIACNT2)
 #define bfin_write_WPIACNT2(val)             bfin_write32(WPIACNT2,val)
-#define pWPIACNT3 ((volatile unsigned long *)WPIACNT3)
 #define bfin_read_WPIACNT3()                 bfin_read32(WPIACNT3)
 #define bfin_write_WPIACNT3(val)             bfin_write32(WPIACNT3,val)
-#define pWPIACNT4 ((volatile unsigned long *)WPIACNT4)
 #define bfin_read_WPIACNT4()                 bfin_read32(WPIACNT4)
 #define bfin_write_WPIACNT4(val)             bfin_write32(WPIACNT4,val)
-#define pWPIACNT5 ((volatile unsigned long *)WPIACNT5)
 #define bfin_read_WPIACNT5()                 bfin_read32(WPIACNT5)
 #define bfin_write_WPIACNT5(val)             bfin_write32(WPIACNT5,val)
-#define pWPDACTL ((volatile unsigned long *)WPDACTL)
 #define bfin_read_WPDACTL()                  bfin_read32(WPDACTL)
 #define bfin_write_WPDACTL(val)              bfin_write32(WPDACTL,val)
-#define pWPDA0 ((volatile void **)WPDA0)
 #define bfin_read_WPDA0()                    bfin_read32(WPDA0)
 #define bfin_write_WPDA0(val)                bfin_write32(WPDA0,val)
-#define pWPDA1 ((volatile void **)WPDA1)
 #define bfin_read_WPDA1()                    bfin_read32(WPDA1)
 #define bfin_write_WPDA1(val)                bfin_write32(WPDA1,val)
-#define pWPDACNT0 ((volatile unsigned long *)WPDACNT0)
 #define bfin_read_WPDACNT0()                 bfin_read32(WPDACNT0)
 #define bfin_write_WPDACNT0(val)             bfin_write32(WPDACNT0,val)
-#define pWPDACNT1 ((volatile unsigned long *)WPDACNT1)
 #define bfin_read_WPDACNT1()                 bfin_read32(WPDACNT1)
 #define bfin_write_WPDACNT1(val)             bfin_write32(WPDACNT1,val)
-#define pWPSTAT ((volatile unsigned long *)WPSTAT)
 #define bfin_read_WPSTAT()                   bfin_read32(WPSTAT)
 #define bfin_write_WPSTAT(val)               bfin_write32(WPSTAT,val)
 
 /*Performance Monitor Registers*/
-#define pPFCTL ((volatile unsigned long *)PFCTL)
 #define bfin_read_PFCTL()                    bfin_read32(PFCTL)
 #define bfin_write_PFCTL(val)                bfin_write32(PFCTL,val)
-#define pPFCNTR0 ((volatile unsigned long *)PFCNTR0)
 #define bfin_read_PFCNTR0()                  bfin_read32(PFCNTR0)
 #define bfin_write_PFCNTR0(val)              bfin_write32(PFCNTR0,val)
-#define pPFCNTR1 ((volatile unsigned long *)PFCNTR1)
 #define bfin_read_PFCNTR1()                  bfin_read32(PFCNTR1)
 #define bfin_write_PFCNTR1(val)              bfin_write32(PFCNTR1,val)
 
@@ -454,18 +325,4 @@
 #define IPRIO                  0xFFE02110
 */
 
-#if defined(CONFIG_BFIN_ALIVE_LED)
-#define pCONFIG_BFIN_ALIVE_LED_DPORT \
-	(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_DPORT
-#define pCONFIG_BFIN_ALIVE_LED_PORT \
-	(volatile unsigned short *)CONFIG_BFIN_ALIVE_LED_PORT
-#endif
-
-#if defined(CONFIG_BFIN_IDLE_LED)
-#define pCONFIG_BFIN_IDLE_LED_DPORT \
-	(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_DPORT
-#define pCONFIG_BFIN_IDLE_LED_PORT \
-	(volatile unsigned short *)CONFIG_BFIN_IDLE_LED_PORT
-#endif
-
 #endif				/* _CDEF_LPBLACKFIN_H */
diff --git a/include/asm-blackfin/processor.h b/include/asm-blackfin/processor.h
index 0336ff1..aba2b30 100644
--- a/include/asm-blackfin/processor.h
+++ b/include/asm-blackfin/processor.h
@@ -104,13 +104,13 @@ unsigned long get_wchan(struct task_struct *p);
 #define cpu_relax()    	barrier()
 
 /* Get the Silicon Revision of the chip */
-static inline uint32_t bfin_revid(void)
+static inline __attribute_pure__ uint32_t bfin_revid(void)
 {
 	/* stored in the upper 4 bits */
 	return bfin_read_CHIPID() >> 28;
 }
 
-static inline uint32_t bfin_compiled_revid(void)
+static inline __attribute_pure__ uint32_t bfin_compiled_revid(void)
 {
 #if defined(CONFIG_BF_REV_0_0)
 	return 0;
diff --git a/include/asm-blackfin/uaccess.h b/include/asm-blackfin/uaccess.h
index bfcb679..2233f8f 100644
--- a/include/asm-blackfin/uaccess.h
+++ b/include/asm-blackfin/uaccess.h
@@ -14,7 +14,7 @@
 #include <linux/string.h>
 
 #include <asm/segment.h>
-#ifndef CONFIG_NO_ACCESS_CHECK
+#ifdef CONFIG_ACCESS_CHECK
 # include <asm/bfin-global.h>
 #endif
 
@@ -56,7 +56,7 @@ static inline int is_in_rom(unsigned long addr)
  * get_fs() == KERNEL_DS, checking is bypassed.
  */
 
-#ifdef CONFIG_NO_ACCESS_CHECK
+#ifndef CONFIG_ACCESS_CHECK
 static inline int _access_ok(unsigned long addr, unsigned long size) { return 1; }
 #else
 #ifdef CONFIG_ACCESS_OK_L1
diff --git a/include/asm-generic/bug.h b/include/asm-generic/bug.h
index 14fae1f..7f30cce 100644
--- a/include/asm-generic/bug.h
+++ b/include/asm-generic/bug.h
@@ -35,7 +35,7 @@ struct bug_entry {
 #define WARN_ON(condition) ({						\
 	typeof(condition) __ret_warn_on = (condition);			\
 	if (unlikely(__ret_warn_on)) {					\
-		printk("BUG: at %s:%d %s()\n", __FILE__,		\
+		printk("WARNING: at %s:%d %s()\n", __FILE__,		\
 			__LINE__, __FUNCTION__);			\
 		dump_stack();						\
 	}								\
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index f3806a7..8307b1b 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -9,6 +9,11 @@
 /* Align . to a 8 byte boundary equals to maximum function alignment. */
 #define ALIGN_FUNCTION()  . = ALIGN(8)
 
+/* .data section */
+#define DATA_DATA							\
+	*(.data)							\
+	*(.data.init.refok)
+
 #define RODATA								\
 	. = ALIGN(4096);						\
 	.rodata           : AT(ADDR(.rodata) - LOAD_OFFSET) {		\
@@ -139,6 +144,13 @@
 		VMLINUX_SYMBOL(__security_initcall_end) = .;		\
 	}
 
+/* .text section. Map to function alignment to avoid address changes
+ * during second ld run in second ld pass when generating System.map */
+#define TEXT_TEXT							\
+		ALIGN_FUNCTION();					\
+		*(.text)						\
+		*(.text.init.refok)
+
 /* sched.text is aling to function alignment to secure we have same
  * address even at second ld pass when generating System.map */
 #define SCHED_TEXT							\
diff --git a/include/asm-i386/atomic.h b/include/asm-i386/atomic.h
index 0baa2f8..437aac8 100644
--- a/include/asm-i386/atomic.h
+++ b/include/asm-i386/atomic.h
@@ -182,7 +182,7 @@ static __inline__ int atomic_add_return(int i, atomic_t *v)
 	int __i;
 #ifdef CONFIG_M386
 	unsigned long flags;
-	if(unlikely(boot_cpu_data.x86==3))
+	if(unlikely(boot_cpu_data.x86 <= 3))
 		goto no_xadd;
 #endif
 	/* Modern 486+ processor */
diff --git a/include/asm-i386/local.h b/include/asm-i386/local.h
index e13d3e9..6e85975 100644
--- a/include/asm-i386/local.h
+++ b/include/asm-i386/local.h
@@ -135,7 +135,7 @@ static __inline__ long local_add_return(long i, local_t *l)
 	long __i;
 #ifdef CONFIG_M386
 	unsigned long flags;
-	if(unlikely(boot_cpu_data.x86==3))
+	if(unlikely(boot_cpu_data.x86 <= 3))
 		goto no_xadd;
 #endif
 	/* Modern 486+ processor */
diff --git a/include/asm-i386/tlbflush.h b/include/asm-i386/tlbflush.h
index db7f77e..fc525c5 100644
--- a/include/asm-i386/tlbflush.h
+++ b/include/asm-i386/tlbflush.h
@@ -90,6 +90,8 @@
 
 #ifndef CONFIG_SMP
 
+#include <linux/sched.h>
+
 #define flush_tlb() __flush_tlb()
 #define flush_tlb_all() __flush_tlb_all()
 #define local_flush_tlb() __flush_tlb()
diff --git a/include/asm-ia64/acpi.h b/include/asm-ia64/acpi.h
index 5d03792..5b52635 100644
--- a/include/asm-ia64/acpi.h
+++ b/include/asm-ia64/acpi.h
@@ -30,6 +30,8 @@
 
 #ifdef __KERNEL__
 
+#include <acpi/pdc_intel.h>
+
 #include <linux/init.h>
 #include <linux/numa.h>
 #include <asm/system.h>
@@ -119,11 +121,6 @@ extern int __devinitdata pxm_to_nid_map[MAX_PXM_DOMAINS];
 extern int __initdata nid_to_pxm_map[MAX_NUMNODES];
 #endif
 
-/*
- * Refer Intel ACPI _PDC support document for bit definitions
- */
-#define ACPI_PDC_EST_CAPABILITY_SMP     0x8
-
 #endif /*__KERNEL__*/
 
 #endif /*_ASM_ACPI_H*/
diff --git a/include/asm-ia64/unistd.h b/include/asm-ia64/unistd.h
index d7781a2..441c9e0 100644
--- a/include/asm-ia64/unistd.h
+++ b/include/asm-ia64/unistd.h
@@ -305,6 +305,19 @@
 
 #define NR_syscalls			286 /* length of syscall table */
 
+/*
+ * The following defines stop scripts/checksyscalls.sh from complaining about
+ * unimplemented system calls.  Glibc provides for each of these by using
+ * more modern equivalent system calls.
+ */
+#define __IGNORE_fork		/* clone() */
+#define __IGNORE_time		/* gettimeofday() */
+#define __IGNORE_alarm		/* setitimer(ITIMER_REAL, ... */
+#define __IGNORE_pause		/* rt_sigprocmask(), rt_sigsuspend() */
+#define __IGNORE_utime		/* utimes() */
+#define __IGNORE_getpgrp	/* getpgid() */
+#define __IGNORE_vfork		/* clone() */
+
 #define __ARCH_WANT_SYS_RT_SIGACTION
 #define __ARCH_WANT_SYS_RT_SIGSUSPEND
 
diff --git a/include/asm-mips/pgalloc.h b/include/asm-mips/pgalloc.h
index 5685d4f..9fb57c0 100644
--- a/include/asm-mips/pgalloc.h
+++ b/include/asm-mips/pgalloc.h
@@ -11,6 +11,7 @@
 
 #include <linux/highmem.h>
 #include <linux/mm.h>
+#include <linux/sched.h>
 
 static inline void pmd_populate_kernel(struct mm_struct *mm, pmd_t *pmd,
 	pte_t *pte)
diff --git a/include/asm-parisc/mmu_context.h b/include/asm-parisc/mmu_context.h
index bad6902..85856c7 100644
--- a/include/asm-parisc/mmu_context.h
+++ b/include/asm-parisc/mmu_context.h
@@ -2,6 +2,7 @@
 #define __PARISC_MMU_CONTEXT_H
 
 #include <linux/mm.h>
+#include <linux/sched.h>
 #include <asm/atomic.h>
 #include <asm/pgalloc.h>
 #include <asm/pgtable.h>
diff --git a/include/asm-parisc/tlbflush.h b/include/asm-parisc/tlbflush.h
index 3313da9..270cf30 100644
--- a/include/asm-parisc/tlbflush.h
+++ b/include/asm-parisc/tlbflush.h
@@ -4,6 +4,7 @@
 /* TLB flushing routines.... */
 
 #include <linux/mm.h>
+#include <linux/sched.h>
 #include <asm/mmu_context.h>
 
 
diff --git a/include/asm-powerpc/mmu_context.h b/include/asm-powerpc/mmu_context.h
index c0d7795..40c9e5a 100644
--- a/include/asm-powerpc/mmu_context.h
+++ b/include/asm-powerpc/mmu_context.h
@@ -8,6 +8,7 @@
 
 #include <linux/kernel.h>	
 #include <linux/mm.h>	
+#include <linux/sched.h>
 #include <asm/mmu.h>	
 #include <asm/cputable.h>
 #include <asm-generic/mm_hooks.h>
diff --git a/include/asm-s390/unistd.h b/include/asm-s390/unistd.h
index 5c6f00d..790c1c5 100644
--- a/include/asm-s390/unistd.h
+++ b/include/asm-s390/unistd.h
@@ -251,8 +251,12 @@
 #define __NR_getcpu		311
 #define __NR_epoll_pwait	312
 #define __NR_utimes		313
-
-#define NR_syscalls 314
+/* Number 314 is reserved for new sys_fallocate */
+#define __NR_utimensat		315
+#define __NR_signalfd		316
+#define __NR_timerfd		317
+#define __NR_eventfd		318
+#define NR_syscalls 319
 
 /* 
  * There are some system calls that are not present on 64 bit, some
@@ -346,6 +350,19 @@
 
 #ifdef __KERNEL__
 
+#ifndef CONFIG_64BIT
+#define __IGNORE_select
+#else
+#define __IGNORE_time
+#endif
+
+/* Ignore NUMA system calls. Not wired up on s390. */
+#define __IGNORE_mbind
+#define __IGNORE_get_mempolicy
+#define __IGNORE_set_mempolicy
+#define __IGNORE_migrate_pages
+#define __IGNORE_move_pages
+
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
 #define __ARCH_WANT_SYS_ALARM
diff --git a/include/asm-sh/dreamcast/sysasic.h b/include/asm-sh/dreamcast/sysasic.h
index 7874e3d..f334266 100644
--- a/include/asm-sh/dreamcast/sysasic.h
+++ b/include/asm-sh/dreamcast/sysasic.h
@@ -23,7 +23,7 @@
    takes.
 */
 
-#define HW_EVENT_IRQ_BASE  OFFCHIP_IRQ_BASE /* 48 */
+#define HW_EVENT_IRQ_BASE  48
 
 /* IRQ 13 */
 #define HW_EVENT_VSYNC     (HW_EVENT_IRQ_BASE +  5) /* VSync */
diff --git a/include/asm-sh/kdebug.h b/include/asm-sh/kdebug.h
index 16578b7..382cfc7 100644
--- a/include/asm-sh/kdebug.h
+++ b/include/asm-sh/kdebug.h
@@ -6,10 +6,6 @@
 /* Grossly misnamed. */
 enum die_val {
 	DIE_TRAP,
-	DIE_PAGE_FAULT,
 };
 
-int register_page_fault_notifier(struct notifier_block *nb);
-int unregister_page_fault_notifier(struct notifier_block *nb);
-
 #endif /* __ASM_SH_KDEBUG_H */
diff --git a/include/asm-sh/landisk/gio.h b/include/asm-sh/landisk/gio.h
index 3fce4c4..35d7368 100644
--- a/include/asm-sh/landisk/gio.h
+++ b/include/asm-sh/landisk/gio.h
@@ -29,16 +29,8 @@
 #define GIODRV_IOCGGIODATA4   _IOR(GIODRV_IOC_MAGIC,  6, unsigned long *)
 #define GIODRV_IOCSGIOSETADDR _IOW(GIODRV_IOC_MAGIC,  7, unsigned long *)
 #define GIODRV_IOCHARDRESET   _IO(GIODRV_IOC_MAGIC, 8) /* debugging tool */
-
-#define GIODRV_IOCSGIO_LED    _IOW(GIODRV_IOC_MAGIC,  9, unsigned long *)
-#define GIODRV_IOCGGIO_LED    _IOR(GIODRV_IOC_MAGIC,  10, unsigned long *)
-#define GIODRV_IOCSGIO_BUZZER _IOW(GIODRV_IOC_MAGIC,  11, unsigned long *)
-#define GIODRV_IOCGGIO_LANDISK _IOR(GIODRV_IOC_MAGIC,  14, unsigned long *)
-#define GIODRV_IOCGGIO_BTN _IOR(GIODRV_IOC_MAGIC,  22, unsigned long *)
-#define GIODRV_IOCSGIO_BTNPID _IOW(GIODRV_IOC_MAGIC,  23, unsigned long *)
-#define GIODRV_IOCGGIO_BTNPID _IOR(GIODRV_IOC_MAGIC,  24, unsigned long *)
-
 #define GIODRV_IOC_MAXNR 8
+
 #define GIO_READ 0x00000000
 #define GIO_WRITE 0x00000001
 
diff --git a/include/asm-sh/landisk/iodata_landisk.h b/include/asm-sh/landisk/iodata_landisk.h
index c74d3c7..6fb04ab 100644
--- a/include/asm-sh/landisk/iodata_landisk.h
+++ b/include/asm-sh/landisk/iodata_landisk.h
@@ -22,16 +22,6 @@
 /* 2003.10.31 I-O DATA NSD NWG	add.	for shutdown port clear */
 #define PA_PWRINT_CLR	0xb0000006	/* Shutdown Interrupt clear Register */
 
-#define PA_LCD_CLRDSP	0x00		/* LCD Clear Display Offset */
-#define PA_LCD_RTNHOME	0x00		/* LCD Return Home Offset */
-#define PA_LCD_ENTMODE	0x00		/* LCD Entry Mode Offset */
-#define PA_LCD_DSPCTL	0x00		/* LCD Display ON/OFF Control Offset */
-#define PA_LCD_FUNC	0x00		/* LCD Function Set Offset */
-#define PA_LCD_CGRAM	0x00		/* LCD Set CGRAM Address Offset */
-#define PA_LCD_DDRAM	0x00		/* LCD Set DDRAM Address Offset */
-#define PA_LCD_RDFLAG	0x01		/* LCD Read Busy Flag Offset */
-#define PA_LCD_WTDATA	0x02		/* LCD Write Datat to RAM Offset */
-#define PA_LCD_RDDATA	0x03		/* LCD Read Data from RAM Offset */
 #define PA_PIDE_OFFSET	0x40		/* CF IDE Offset */
 #define PA_SIDE_OFFSET	0x40		/* HDD IDE Offset */
 
@@ -45,33 +35,6 @@
 #define IRQ_BUTTON	12		/* USL-5P Button IRQ */
 #define IRQ_FAULT	13		/* USL-5P Fault  IRQ */
 
-#define SHUTDOWN_BTN_MAJOR	99	/* Shutdown button device major no. */
-
-#define SHUTDOWN_LOOP_CNT	5	/* Shutdown button Detection loop */
-#define SHUTDOWN_DELAY		200	/* Shutdown button delay value(ms) */
-
-
-/* added by kogiidena */
-/*
- *  landisk_ledparam
- *
- * led  ------10 -6543210 -6543210 -6543210
- *     |000000..|0.......|0.......|U.......|
- *     |  HARD  |fastblik| blink  |   on   |
- *
- *   led0: power       U:update flag
- *   led1: error
- *   led2: usb1
- *   led3: usb2
- *   led4: usb3
- *   led5: usb4
- *   led6: usb5
- *
- */
-extern int landisk_ledparam;    /* from setup.c */
-extern int landisk_buzzerparam; /* from setup.c */
-extern int landisk_arch;        /* from setup.c */
-
 #define __IO_PREFIX landisk
 #include <asm/io_generic.h>
 
diff --git a/include/asm-sh/unistd.h b/include/asm-sh/unistd.h
index af71e37..77bcb09 100644
--- a/include/asm-sh/unistd.h
+++ b/include/asm-sh/unistd.h
@@ -329,8 +329,11 @@
 #define __NR_getcpu		318
 #define __NR_epoll_pwait	319
 #define __NR_utimensat		320
+#define __NR_signalfd		321
+#define __NR_timerfd		322
+#define __NR_eventfd		323
 
-#define NR_syscalls 321
+#define NR_syscalls 324
 
 #ifdef __KERNEL__
 
diff --git a/include/asm-x86_64/calgary.h b/include/asm-x86_64/calgary.h
index 7ee9006..4d5747a 100644
--- a/include/asm-x86_64/calgary.h
+++ b/include/asm-x86_64/calgary.h
@@ -27,6 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
+#include <linux/timer.h>
 #include <asm/types.h>
 
 struct iommu_table {
diff --git a/include/asm-x86_64/tlbflush.h b/include/asm-x86_64/tlbflush.h
index 512401b..8516225 100644
--- a/include/asm-x86_64/tlbflush.h
+++ b/include/asm-x86_64/tlbflush.h
@@ -2,6 +2,7 @@
 #define _X8664_TLBFLUSH_H
 
 #include <linux/mm.h>
+#include <linux/sched.h>
 #include <asm/processor.h>
 #include <asm/system.h>
 
diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index bcd01f2..e101315 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -239,6 +239,7 @@ unifdef-y += ipc.h
 unifdef-y += ipmi.h
 unifdef-y += ipv6.h
 unifdef-y += ipv6_route.h
+unifdef-y += ip6_tunnel.h
 unifdef-y += isdn.h
 unifdef-y += isdnif.h
 unifdef-y += isdn_divertif.h
diff --git a/include/linux/capability.h b/include/linux/capability.h
index 6548b35..bbf8df7 100644
--- a/include/linux/capability.h
+++ b/include/linux/capability.h
@@ -16,6 +16,8 @@
 #include <linux/types.h>
 #include <linux/compiler.h>
 
+struct task_struct;
+
 /* User-level do most of the mapping between kernel and user
    capabilities based on the version tag given by the kernel. The
    kernel might be somewhat backwards compatible, but don't bet on
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 498c359..8287a72 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -36,9 +36,7 @@ extern void __chk_io_ptr(const void __iomem *);
 
 #ifdef __KERNEL__
 
-#if __GNUC__ > 4
-#error no compiler-gcc.h file for this gcc version
-#elif __GNUC__ == 4
+#if __GNUC__ >= 4
 # include <linux/compiler-gcc4.h>
 #elif __GNUC__ == 3 && __GNUC_MINOR__ >= 2
 # include <linux/compiler-gcc3.h>
diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 5e75e26..4631086 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -37,25 +37,25 @@ static inline void do_not_freeze(struct task_struct *p)
 
 /*
  * Wake up a frozen process
+ *
+ * task_lock() is taken to prevent the race with refrigerator() which may
+ * occur if the freezing of tasks fails.  Namely, without the lock, if the
+ * freezing of tasks failed, thaw_tasks() might have run before a task in
+ * refrigerator() could call frozen_process(), in which case the task would be
+ * frozen and no one would thaw it.
  */
 static inline int thaw_process(struct task_struct *p)
 {
+	task_lock(p);
 	if (frozen(p)) {
 		p->flags &= ~PF_FROZEN;
+		task_unlock(p);
 		wake_up_process(p);
 		return 1;
 	}
-	return 0;
-}
-
-/*
- * freezing is complete, mark process as frozen
- */
-static inline void frozen_process(struct task_struct *p)
-{
-	p->flags |= PF_FROZEN;
-	wmb();
 	clear_tsk_thread_flag(p, TIF_FREEZE);
+	task_unlock(p);
+	return 0;
 }
 
 extern void refrigerator(void);
@@ -71,14 +71,55 @@ static inline int try_to_freeze(void)
 		return 0;
 }
 
-extern void thaw_some_processes(int all);
+/*
+ * The PF_FREEZER_SKIP flag should be set by a vfork parent right before it
+ * calls wait_for_completion(&vfork) and reset right after it returns from this
+ * function.  Next, the parent should call try_to_freeze() to freeze itself
+ * appropriately in case the child has exited before the freezing of tasks is
+ * complete.  However, we don't want kernel threads to be frozen in unexpected
+ * places, so we allow them to block freeze_processes() instead or to set
+ * PF_NOFREEZE if needed and PF_FREEZER_SKIP is only set for userland vfork
+ * parents.  Fortunately, in the ____call_usermodehelper() case the parent won't
+ * really block freeze_processes(), since ____call_usermodehelper() (the child)
+ * does a little before exec/exit and it can't be frozen before waking up the
+ * parent.
+ */
+
+/*
+ * If the current task is a user space one, tell the freezer not to count it as
+ * freezable.
+ */
+static inline void freezer_do_not_count(void)
+{
+	if (current->mm)
+		current->flags |= PF_FREEZER_SKIP;
+}
+
+/*
+ * If the current task is a user space one, tell the freezer to count it as
+ * freezable again and try to freeze it.
+ */
+static inline void freezer_count(void)
+{
+	if (current->mm) {
+		current->flags &= ~PF_FREEZER_SKIP;
+		try_to_freeze();
+	}
+}
+
+/*
+ * Check if the task should be counted as freezeable by the freezer
+ */
+static inline int freezer_should_skip(struct task_struct *p)
+{
+	return !!(p->flags & PF_FREEZER_SKIP);
+}
 
 #else
 static inline int frozen(struct task_struct *p) { return 0; }
 static inline int freezing(struct task_struct *p) { return 0; }
 static inline void freeze(struct task_struct *p) { BUG(); }
 static inline int thaw_process(struct task_struct *p) { return 1; }
-static inline void frozen_process(struct task_struct *p) { BUG(); }
 
 static inline void refrigerator(void) {}
 static inline int freeze_processes(void) { BUG(); return 0; }
@@ -86,5 +127,7 @@ static inline void thaw_processes(void) {}
 
 static inline int try_to_freeze(void) { return 0; }
 
-
+static inline void freezer_do_not_count(void) {}
+static inline void freezer_count(void) {}
+static inline int freezer_should_skip(struct task_struct *p) { return 0; }
 #endif
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index 4c03ee3..9756fc1 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -66,6 +66,7 @@ struct partition {
 #include <linux/smp.h>
 #include <linux/string.h>
 #include <linux/fs.h>
+#include <linux/workqueue.h>
 
 struct partition {
 	unsigned char boot_ind;		/* 0x80 - active */
@@ -94,6 +95,7 @@ struct hd_struct {
 
 #define GENHD_FL_REMOVABLE			1
 #define GENHD_FL_DRIVERFS			2
+#define GENHD_FL_MEDIA_CHANGE_NOTIFY		4
 #define GENHD_FL_CD				8
 #define GENHD_FL_UP				16
 #define GENHD_FL_SUPPRESS_PARTITION_INFO	32
@@ -138,6 +140,7 @@ struct gendisk {
 #else
 	struct disk_stats dkstats;
 #endif
+	struct work_struct async_notify;
 };
 
 /* Structure for sysfs attributes on block devices */
@@ -419,7 +422,7 @@ extern struct gendisk *alloc_disk_node(int minors, int node_id);
 extern struct gendisk *alloc_disk(int minors);
 extern struct kobject *get_disk(struct gendisk *disk);
 extern void put_disk(struct gendisk *disk);
-
+extern void genhd_media_change_notify(struct gendisk *disk);
 extern void blk_register_region(dev_t dev, unsigned long range,
 			struct module *module,
 			struct kobject *(*probe)(dev_t, int *, void *),
diff --git a/include/linux/if_ether.h b/include/linux/if_ether.h
index 1db774c..3213f6f 100644
--- a/include/linux/if_ether.h
+++ b/include/linux/if_ether.h
@@ -33,6 +33,7 @@
 #define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
 #define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
 #define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+#define ETH_FCS_LEN	4		/* Octets in the FCS		 */
 
 /*
  *	These are the defined Ethernet Protocol ID's.
diff --git a/include/linux/init.h b/include/linux/init.h
index e007ae4..56ec4c6 100644
--- a/include/linux/init.h
+++ b/include/linux/init.h
@@ -45,6 +45,19 @@
 #define __exitdata	__attribute__ ((__section__(".exit.data")))
 #define __exit_call	__attribute_used__ __attribute__ ((__section__ (".exitcall.exit")))
 
+/* modpost check for section mismatches during the kernel build.
+ * A section mismatch happens when there are references from a
+ * code or data section to an init section (both code or data).
+ * The init sections are (for most archs) discarded by the kernel
+ * when early init has completed so all such references are potential bugs.
+ * For exit sections the same issue exists.
+ * The following markers are used for the cases where the reference to
+ * the init/exit section (code or data) is valid and will teach modpost
+ * not to issue a warning.
+ * The markers follow same syntax rules as __init / __initdata. */
+#define __init_refok     noinline __attribute__ ((__section__ (".text.init.refok")))
+#define __initdata_refok          __attribute__ ((__section__ (".data.init.refok")))
+
 #ifdef MODULE
 #define __exit		__attribute__ ((__section__(".exit.text")))
 #else
diff --git a/include/linux/libata.h b/include/linux/libata.h
index 666592e..85f7b1b 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -574,8 +574,6 @@ struct ata_port_operations {
 	void (*phy_reset) (struct ata_port *ap); /* obsolete */
 	int  (*set_mode) (struct ata_port *ap, struct ata_device **r_failed_dev);
 
-	void (*post_set_mode) (struct ata_port *ap);
-
 	int (*cable_detect) (struct ata_port *ap);
 
 	int  (*check_atapi_dma) (struct ata_queued_cmd *qc);
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 4670ebd..e4183c6 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1,7 +1,6 @@
 #ifndef _LINUX_MM_H
 #define _LINUX_MM_H
 
-#include <linux/sched.h>
 #include <linux/errno.h>
 #include <linux/capability.h>
 
@@ -20,6 +19,7 @@
 
 struct mempolicy;
 struct anon_vma;
+struct user_struct;
 
 #ifndef CONFIG_DISCONTIGMEM          /* Don't use mapnrs, do it properly */
 extern unsigned long max_mapnr;
@@ -717,14 +717,7 @@ extern unsigned long shmem_get_unmapped_area(struct file *file,
 					     unsigned long flags);
 #endif
 
-static inline int can_do_mlock(void)
-{
-	if (capable(CAP_IPC_LOCK))
-		return 1;
-	if (current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur != 0)
-		return 1;
-	return 0;
-}
+extern int can_do_mlock(void);
 extern int user_shm_lock(size_t, struct user_struct *);
 extern void user_shm_unlock(size_t, struct user_struct *);
 
diff --git a/include/linux/netfilter/nf_conntrack_ftp.h b/include/linux/netfilter/nf_conntrack_ftp.h
index 81453ea..b7c360f 100644
--- a/include/linux/netfilter/nf_conntrack_ftp.h
+++ b/include/linux/netfilter/nf_conntrack_ftp.h
@@ -37,8 +37,7 @@ extern unsigned int (*nf_nat_ftp_hook)(struct sk_buff **pskb,
 				       enum nf_ct_ftp_type type,
 				       unsigned int matchoff,
 				       unsigned int matchlen,
-				       struct nf_conntrack_expect *exp,
-				       u32 *seq);
+				       struct nf_conntrack_expect *exp);
 #endif /* __KERNEL__ */
 
 #endif /* _NF_CONNTRACK_FTP_H */
diff --git a/include/linux/netfilter/nf_conntrack_h323_types.h b/include/linux/netfilter/nf_conntrack_h323_types.h
index 38d74d5..f35b6b4 100644
--- a/include/linux/netfilter/nf_conntrack_h323_types.h
+++ b/include/linux/netfilter/nf_conntrack_h323_types.h
@@ -1,4 +1,4 @@
-/* Generated by Jing Min Zhao's ASN.1 parser, Apr 20 2006
+/* Generated by Jing Min Zhao's ASN.1 parser, May 16 2007
  *
  * Copyright (c) 2006 Jing Min Zhao <zhaojingmin@users.sourceforge.net>
  *
@@ -12,7 +12,7 @@ typedef struct TransportAddress_ipAddress {	/* SEQUENCE */
 
 typedef struct TransportAddress_ip6Address {	/* SEQUENCE */
 	int options;		/* No use */
-	unsigned ip6;
+	unsigned ip;
 } TransportAddress_ip6Address;
 
 typedef struct TransportAddress {	/* CHOICE */
@@ -364,23 +364,6 @@ typedef struct Alerting_UUIE {	/* SEQUENCE */
 	Alerting_UUIE_fastStart fastStart;
 } Alerting_UUIE;
 
-typedef struct Information_UUIE_fastStart {	/* SEQUENCE OF */
-	int count;
-	OpenLogicalChannel item[30];
-} Information_UUIE_fastStart;
-
-typedef struct Information_UUIE {	/* SEQUENCE */
-	enum {
-		eInformation_UUIE_callIdentifier = (1 << 31),
-		eInformation_UUIE_tokens = (1 << 30),
-		eInformation_UUIE_cryptoTokens = (1 << 29),
-		eInformation_UUIE_fastStart = (1 << 28),
-		eInformation_UUIE_fastConnectRefused = (1 << 27),
-		eInformation_UUIE_circuitInfo = (1 << 26),
-	} options;
-	Information_UUIE_fastStart fastStart;
-} Information_UUIE;
-
 typedef struct FacilityReason {	/* CHOICE */
 	enum {
 		eFacilityReason_routeCallToGatekeeper,
@@ -471,7 +454,6 @@ typedef struct H323_UU_PDU_h323_message_body {	/* CHOICE */
 		CallProceeding_UUIE callProceeding;
 		Connect_UUIE connect;
 		Alerting_UUIE alerting;
-		Information_UUIE information;
 		Facility_UUIE facility;
 		Progress_UUIE progress;
 	};
@@ -561,6 +543,7 @@ typedef struct OpenLogicalChannelAck {	/* SEQUENCE */
 	} options;
 	OpenLogicalChannelAck_reverseLogicalChannelParameters
 	    reverseLogicalChannelParameters;
+	NetworkAccessParameters separateStack;
 	OpenLogicalChannelAck_forwardMultiplexAckParameters
 	    forwardMultiplexAckParameters;
 } OpenLogicalChannelAck;
diff --git a/include/linux/nfs_page.h b/include/linux/nfs_page.h
index 41afab6..bd193af 100644
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@ -81,6 +81,7 @@ extern	void nfs_pageio_init(struct nfs_pageio_descriptor *desc,
 extern	int nfs_pageio_add_request(struct nfs_pageio_descriptor *,
 				   struct nfs_page *);
 extern	void nfs_pageio_complete(struct nfs_pageio_descriptor *desc);
+extern	void nfs_pageio_cond_complete(struct nfs_pageio_descriptor *, pgoff_t);
 extern  int nfs_wait_on_request(struct nfs_page *);
 extern	void nfs_unlock_request(struct nfs_page *req);
 extern  int nfs_set_page_writeback_locked(struct nfs_page *req);
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 62b3e00..4712e26 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -371,6 +371,7 @@
 #define PCI_DEVICE_ID_ATI_IXP600_SMBUS	0x4385
 #define PCI_DEVICE_ID_ATI_IXP600_IDE	0x438c
 #define PCI_DEVICE_ID_ATI_IXP700_SATA	0x4390
+#define PCI_DEVICE_ID_ATI_IXP700_IDE	0x439c
 
 #define PCI_VENDOR_ID_VLSI		0x1004
 #define PCI_DEVICE_ID_VLSI_82C592	0x0005
diff --git a/include/linux/raid/bitmap.h b/include/linux/raid/bitmap.h
index 6db9a4c..dd5a05d 100644
--- a/include/linux/raid/bitmap.h
+++ b/include/linux/raid/bitmap.h
@@ -232,6 +232,7 @@ struct bitmap {
 	struct page **filemap; /* list of cache pages for the file */
 	unsigned long *filemap_attr; /* attributes associated w/ filemap pages */
 	unsigned long file_pages; /* number of pages in the file */
+	int last_page_size; /* bytes in the last page */
 
 	unsigned long flags;
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index a81897e..d58e74b 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1182,6 +1182,7 @@ static inline void put_task_struct(struct task_struct *t)
 #define PF_SPREAD_SLAB	0x02000000	/* Spread some slab caches over cpuset */
 #define PF_MEMPOLICY	0x10000000	/* Non-default NUMA mempolicy */
 #define PF_MUTEX_TESTER	0x20000000	/* Thread belongs to the rt mutex tester */
+#define PF_FREEZER_SKIP	0x40000000	/* Freezer should not count it as freezeable */
 
 /*
  * Only the _current_ task can read/write to tsk->flags, but other
@@ -1615,11 +1616,13 @@ static inline int lock_need_resched(spinlock_t *lock)
 	return 0;
 }
 
-/* Reevaluate whether the task has signals pending delivery.
-   This is required every time the blocked sigset_t changes.
-   callers must hold sighand->siglock.  */
-
-extern FASTCALL(void recalc_sigpending_tsk(struct task_struct *t));
+/*
+ * Reevaluate whether the task has signals pending delivery.
+ * Wake the task if so.
+ * This is required every time the blocked sigset_t changes.
+ * callers must hold sighand->siglock.
+ */
+extern void recalc_sigpending_and_wake(struct task_struct *t);
 extern void recalc_sigpending(void);
 
 extern void signal_wake_up(struct task_struct *t, int resume_stopped);
diff --git a/include/linux/smb_fs.h b/include/linux/smb_fs.h
index 13b3af5..2c5cd55 100644
--- a/include/linux/smb_fs.h
+++ b/include/linux/smb_fs.h
@@ -29,6 +29,7 @@
 #include <linux/pagemap.h>
 #include <linux/vmalloc.h>
 #include <linux/smb_mount.h>
+#include <linux/jiffies.h>
 #include <asm/unaligned.h>
 
 static inline struct smb_sb_info *SMB_SB(struct super_block *sb)
diff --git a/include/linux/task_io_accounting_ops.h b/include/linux/task_io_accounting_ops.h
index 1218733..ff46c6f 100644
--- a/include/linux/task_io_accounting_ops.h
+++ b/include/linux/task_io_accounting_ops.h
@@ -4,6 +4,8 @@
 #ifndef __TASK_IO_ACCOUNTING_OPS_INCLUDED
 #define __TASK_IO_ACCOUNTING_OPS_INCLUDED
 
+#include <linux/sched.h>
+
 #ifdef CONFIG_TASK_IO_ACCOUNTING
 static inline void task_io_account_read(size_t bytes)
 {
diff --git a/include/linux/videodev2.h b/include/linux/videodev2.h
index a25c2af..e756038 100644
--- a/include/linux/videodev2.h
+++ b/include/linux/videodev2.h
@@ -267,8 +267,6 @@ struct v4l2_pix_format
 	__u32          		sizeimage;
 	enum v4l2_colorspace	colorspace;
 	__u32			priv;		/* private data, depends on pixelformat */
-	__u32 			left;	/* only valid if V4L2_CAP_VIDEO_OUTPUT_POS is set */
-	__u32 			top;	/* only valid if V4L2_CAP_VIDEO_OUTPUT_POS is set */
 };
 
 /*      Pixel format         FOURCC                        depth  Description  */
diff --git a/include/linux/writeback.h b/include/linux/writeback.h
index 050915b..4ef4d22 100644
--- a/include/linux/writeback.h
+++ b/include/linux/writeback.h
@@ -4,6 +4,8 @@
 #ifndef WRITEBACK_H
 #define WRITEBACK_H
 
+#include <linux/sched.h>
+
 struct backing_dev_info;
 
 extern spinlock_t inode_lock;
diff --git a/include/net/bluetooth/l2cap.h b/include/net/bluetooth/l2cap.h
index 8242a0e..87df4e8 100644
--- a/include/net/bluetooth/l2cap.h
+++ b/include/net/bluetooth/l2cap.h
@@ -129,8 +129,10 @@ struct l2cap_conf_rsp {
 	__u8       data[0];
 } __attribute__ ((packed));
 
-#define L2CAP_CONF_SUCCESS	0x00
-#define L2CAP_CONF_UNACCEPT	0x01
+#define L2CAP_CONF_SUCCESS	0x0000
+#define L2CAP_CONF_UNACCEPT	0x0001
+#define L2CAP_CONF_REJECT	0x0002
+#define L2CAP_CONF_UNKNOWN	0x0003
 
 struct l2cap_conf_opt {
 	__u8       type;
@@ -215,6 +217,8 @@ struct l2cap_pinfo {
 
 	__u32		link_mode;
 
+	__u8		conf_req[64];
+	__u8		conf_len;
 	__u8		conf_state;
 	__u8		conf_retry;
 	__u16		conf_mtu;
diff --git a/include/net/dst.h b/include/net/dst.h
index e12a8ce..82270f9 100644
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@ -265,9 +265,16 @@ static inline int xfrm_lookup(struct dst_entry **dst_p, struct flowi *fl,
 {
 	return 0;
 } 
+static inline int __xfrm_lookup(struct dst_entry **dst_p, struct flowi *fl,
+				struct sock *sk, int flags)
+{
+	return 0;
+}
 #else
 extern int xfrm_lookup(struct dst_entry **dst_p, struct flowi *fl,
 		       struct sock *sk, int flags);
+extern int __xfrm_lookup(struct dst_entry **dst_p, struct flowi *fl,
+			 struct sock *sk, int flags);
 #endif
 #endif
 
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 4fa5dfe..78a0d06 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -469,6 +469,9 @@ extern void			ip6_flush_pending_frames(struct sock *sk);
 extern int			ip6_dst_lookup(struct sock *sk,
 					       struct dst_entry **dst,
 					       struct flowi *fl);
+extern int			ip6_dst_blackhole(struct sock *sk,
+						  struct dst_entry **dst,
+						  struct flowi *fl);
 extern int			ip6_sk_dst_lookup(struct sock *sk,
 						  struct dst_entry **dst,
 						  struct flowi *fl);
diff --git a/include/rdma/ib_umem.h b/include/rdma/ib_umem.h
index b3a36f7..c533d6c 100644
--- a/include/rdma/ib_umem.h
+++ b/include/rdma/ib_umem.h
@@ -35,6 +35,7 @@
 
 #include <linux/list.h>
 #include <linux/scatterlist.h>
+#include <linux/workqueue.h>
 
 struct ib_ucontext;
 
diff --git a/include/rdma/ib_verbs.h b/include/rdma/ib_verbs.h
index 47cefca..0627a6a 100644
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@ -890,6 +890,8 @@ struct ib_device {
 	spinlock_t                    client_data_lock;
 
 	struct ib_cache               cache;
+	int                          *pkey_tbl_len;
+	int                          *gid_tbl_len;
 
 	u32                           flags;
 
@@ -1118,6 +1120,12 @@ int ib_modify_port(struct ib_device *device,
 		   u8 port_num, int port_modify_mask,
 		   struct ib_port_modify *port_modify);
 
+int ib_find_gid(struct ib_device *device, union ib_gid *gid,
+		u8 *port_num, u16 *index);
+
+int ib_find_pkey(struct ib_device *device,
+		 u8 port_num, u16 pkey, u16 *index);
+
 /**
  * ib_alloc_pd - Allocates an unused protection domain.
  * @device: The device on which to allocate the protection domain.
diff --git a/init/main.c b/init/main.c
index 1940fa7..eb8bdba 100644
--- a/init/main.c
+++ b/init/main.c
@@ -423,7 +423,7 @@ static void __init setup_command_line(char *command_line)
  * gcc-3.4 accidentally inlines this function, so use noinline.
  */
 
-static void noinline rest_init(void)
+static void noinline __init_refok rest_init(void)
 	__releases(kernel_lock)
 {
 	int pid;
diff --git a/kernel/exit.c b/kernel/exit.c
index c6d14b8..5b888c2 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -762,11 +762,8 @@ static void exit_notify(struct task_struct *tsk)
 		read_lock(&tasklist_lock);
 		spin_lock_irq(&tsk->sighand->siglock);
 		for (t = next_thread(tsk); t != tsk; t = next_thread(t))
-			if (!signal_pending(t) && !(t->flags & PF_EXITING)) {
-				recalc_sigpending_tsk(t);
-				if (signal_pending(t))
-					signal_wake_up(t, 0);
-			}
+			if (!signal_pending(t) && !(t->flags & PF_EXITING))
+				recalc_sigpending_and_wake(t);
 		spin_unlock_irq(&tsk->sighand->siglock);
 		read_unlock(&tasklist_lock);
 	}
diff --git a/kernel/fork.c b/kernel/fork.c
index 87069cf..73ad5cd 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -45,6 +45,7 @@
 #include <linux/acct.h>
 #include <linux/tsacct_kern.h>
 #include <linux/cn_proc.h>
+#include <linux/freezer.h>
 #include <linux/delayacct.h>
 #include <linux/taskstats_kern.h>
 #include <linux/random.h>
@@ -1405,7 +1406,9 @@ long do_fork(unsigned long clone_flags,
 		}
 
 		if (clone_flags & CLONE_VFORK) {
+			freezer_do_not_count();
 			wait_for_completion(&vfork);
+			freezer_count();
 			if (unlikely (current->ptrace & PT_TRACE_VFORK_DONE)) {
 				current->ptrace_message = nr;
 				ptrace_notify ((PTRACE_EVENT_VFORK_DONE << 8) | SIGTRAP);
diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c
index b0d81aa..bd9e272 100644
--- a/kernel/irq/spurious.c
+++ b/kernel/irq/spurious.c
@@ -135,6 +135,39 @@ report_bad_irq(unsigned int irq, struct irq_desc *desc, irqreturn_t action_ret)
 	}
 }
 
+static inline int try_misrouted_irq(unsigned int irq, struct irq_desc *desc, irqreturn_t action_ret)
+{
+	struct irqaction *action;
+
+	if (!irqfixup)
+		return 0;
+
+	/* We didn't actually handle the IRQ - see if it was misrouted? */
+	if (action_ret == IRQ_NONE)
+		return 1;
+
+	/*
+	 * But for 'irqfixup == 2' we also do it for handled interrupts if
+	 * they are marked as IRQF_IRQPOLL (or for irq zero, which is the
+	 * traditional PC timer interrupt.. Legacy)
+	 */
+	if (irqfixup < 2)
+		return 0;
+
+	if (!irq)
+		return 1;
+
+	/*
+	 * Since we don't get the descriptor lock, "action" can
+	 * change under us.  We don't really care, but we don't
+	 * want to follow a NULL pointer. So tell the compiler to
+	 * just load it once by using a barrier.
+	 */
+	action = desc->action;
+	barrier();
+	return action && (action->flags & IRQF_IRQPOLL);
+}
+
 void note_interrupt(unsigned int irq, struct irq_desc *desc,
 		    irqreturn_t action_ret)
 {
@@ -144,15 +177,10 @@ void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			report_bad_irq(irq, desc, action_ret);
 	}
 
-	if (unlikely(irqfixup)) {
-		/* Don't punish working computers */
-		if ((irqfixup == 2 && ((irq == 0) ||
-				(desc->action->flags & IRQF_IRQPOLL))) ||
-				action_ret == IRQ_NONE) {
-			int ok = misrouted_irq(irq);
-			if (action_ret == IRQ_NONE)
-				desc->irqs_unhandled -= ok;
-		}
+	if (unlikely(try_misrouted_irq(irq, desc, action_ret))) {
+		int ok = misrouted_irq(irq);
+		if (action_ret == IRQ_NONE)
+			desc->irqs_unhandled -= ok;
 	}
 
 	desc->irq_count++;
diff --git a/kernel/kthread.c b/kernel/kthread.c
index df8a8e8..bbd51b8 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -70,7 +70,7 @@ static int kthread(void *_create)
 	data = create->data;
 
 	/* OK, tell user we're spawned, wait for stop or wakeup */
-	__set_current_state(TASK_INTERRUPTIBLE);
+	__set_current_state(TASK_UNINTERRUPTIBLE);
 	complete(&create->started);
 	schedule();
 
@@ -162,7 +162,10 @@ EXPORT_SYMBOL(kthread_create);
  */
 void kthread_bind(struct task_struct *k, unsigned int cpu)
 {
-	BUG_ON(k->state != TASK_INTERRUPTIBLE);
+	if (k->state != TASK_UNINTERRUPTIBLE) {
+		WARN_ON(1);
+		return;
+	}
 	/* Must have done schedule() in kthread() before we set_task_cpu */
 	wait_task_inactive(k);
 	set_task_cpu(k, cpu);
diff --git a/kernel/power/process.c b/kernel/power/process.c
index 0884193..e0233d8 100644
--- a/kernel/power/process.c
+++ b/kernel/power/process.c
@@ -31,16 +31,36 @@ static inline int freezeable(struct task_struct * p)
 	return 1;
 }
 
+/*
+ * freezing is complete, mark current process as frozen
+ */
+static inline void frozen_process(void)
+{
+	if (!unlikely(current->flags & PF_NOFREEZE)) {
+		current->flags |= PF_FROZEN;
+		wmb();
+	}
+	clear_tsk_thread_flag(current, TIF_FREEZE);
+}
+
 /* Refrigerator is place where frozen processes are stored :-). */
 void refrigerator(void)
 {
 	/* Hmm, should we be allowed to suspend when there are realtime
 	   processes around? */
 	long save;
+
+	task_lock(current);
+	if (freezing(current)) {
+		frozen_process();
+		task_unlock(current);
+	} else {
+		task_unlock(current);
+		return;
+	}
 	save = current->state;
 	pr_debug("%s entered refrigerator\n", current->comm);
 
-	frozen_process(current);
 	spin_lock_irq(&current->sighand->siglock);
 	recalc_sigpending(); /* We sent fake signal, clean it up */
 	spin_unlock_irq(&current->sighand->siglock);
@@ -81,7 +101,7 @@ static void cancel_freezing(struct task_struct *p)
 		pr_debug("  clean up: %s\n", p->comm);
 		do_not_freeze(p);
 		spin_lock_irqsave(&p->sighand->siglock, flags);
-		recalc_sigpending_tsk(p);
+		recalc_sigpending_and_wake(p);
 		spin_unlock_irqrestore(&p->sighand->siglock, flags);
 	}
 }
@@ -112,22 +132,12 @@ static unsigned int try_to_freeze_tasks(int freeze_user_space)
 				cancel_freezing(p);
 				continue;
 			}
-			if (is_user_space(p)) {
-				if (!freeze_user_space)
-					continue;
-
-				/* Freeze the task unless there is a vfork
-				 * completion pending
-				 */
-				if (!p->vfork_done)
-					freeze_process(p);
-			} else {
-				if (freeze_user_space)
-					continue;
-
-				freeze_process(p);
-			}
-			todo++;
+			if (freeze_user_space && !is_user_space(p))
+				continue;
+
+			freeze_process(p);
+			if (!freezer_should_skip(p))
+				todo++;
 		} while_each_thread(g, p);
 		read_unlock(&tasklist_lock);
 		yield();			/* Yield is okay here */
@@ -149,13 +159,16 @@ static unsigned int try_to_freeze_tasks(int freeze_user_space)
 				TIMEOUT / HZ, todo);
 		read_lock(&tasklist_lock);
 		do_each_thread(g, p) {
-			if (is_user_space(p) == !freeze_user_space)
+			if (freeze_user_space && !is_user_space(p))
 				continue;
 
-			if (freezeable(p) && !frozen(p))
+			task_lock(p);
+			if (freezeable(p) && !frozen(p) &&
+			    !freezer_should_skip(p))
 				printk(KERN_ERR " %s\n", p->comm);
 
 			cancel_freezing(p);
+			task_unlock(p);
 		} while_each_thread(g, p);
 		read_unlock(&tasklist_lock);
 	}
@@ -200,9 +213,7 @@ static void thaw_tasks(int thaw_user_space)
 		if (is_user_space(p) == !thaw_user_space)
 			continue;
 
-		if (!thaw_process(p))
-			printk(KERN_WARNING " Strange, %s not stopped\n",
-				p->comm );
+		thaw_process(p);
 	} while_each_thread(g, p);
 	read_unlock(&tasklist_lock);
 }
diff --git a/kernel/power/swap.c b/kernel/power/swap.c
index b8b235c..8b1a1b8 100644
--- a/kernel/power/swap.c
+++ b/kernel/power/swap.c
@@ -584,7 +584,7 @@ int swsusp_check(void)
 	resume_bdev = open_by_devnum(swsusp_resume_device, FMODE_READ);
 	if (!IS_ERR(resume_bdev)) {
 		set_blocksize(resume_bdev, PAGE_SIZE);
-		memset(swsusp_header, 0, sizeof(PAGE_SIZE));
+		memset(swsusp_header, 0, PAGE_SIZE);
 		error = bio_read_page(swsusp_resume_block,
 					swsusp_header, NULL);
 		if (error)
diff --git a/kernel/profile.c b/kernel/profile.c
index cc91b9b..5b20fe9 100644
--- a/kernel/profile.c
+++ b/kernel/profile.c
@@ -26,6 +26,7 @@
 #include <asm/sections.h>
 #include <asm/semaphore.h>
 #include <asm/irq_regs.h>
+#include <asm/ptrace.h>
 
 struct profile_hit {
 	u32 pc, hits;
diff --git a/kernel/sched.c b/kernel/sched.c
index 799d23b..13cdab3 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4775,9 +4775,7 @@ int __sched cond_resched_softirq(void)
 	BUG_ON(!in_softirq());
 
 	if (need_resched() && system_state == SYSTEM_RUNNING) {
-		raw_local_irq_disable();
-		_local_bh_enable();
-		raw_local_irq_enable();
+		local_bh_enable();
 		__cond_resched();
 		local_bh_disable();
 		return 1;
diff --git a/kernel/signal.c b/kernel/signal.c
index 364fc95..acdfc05 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -96,15 +96,27 @@ static inline int has_pending_signals(sigset_t *signal, sigset_t *blocked)
 
 #define PENDING(p,b) has_pending_signals(&(p)->signal, (b))
 
-fastcall void recalc_sigpending_tsk(struct task_struct *t)
+static int recalc_sigpending_tsk(struct task_struct *t)
 {
 	if (t->signal->group_stop_count > 0 ||
 	    (freezing(t)) ||
 	    PENDING(&t->pending, &t->blocked) ||
-	    PENDING(&t->signal->shared_pending, &t->blocked))
+	    PENDING(&t->signal->shared_pending, &t->blocked)) {
 		set_tsk_thread_flag(t, TIF_SIGPENDING);
-	else
-		clear_tsk_thread_flag(t, TIF_SIGPENDING);
+		return 1;
+	}
+	clear_tsk_thread_flag(t, TIF_SIGPENDING);
+	return 0;
+}
+
+/*
+ * After recalculating TIF_SIGPENDING, we need to make sure the task wakes up.
+ * This is superfluous when called on current, the wakeup is a harmless no-op.
+ */
+void recalc_sigpending_and_wake(struct task_struct *t)
+{
+	if (recalc_sigpending_tsk(t))
+		signal_wake_up(t, 0);
 }
 
 void recalc_sigpending(void)
@@ -744,7 +756,7 @@ force_sig_info(int sig, struct siginfo *info, struct task_struct *t)
 		action->sa.sa_handler = SIG_DFL;
 		if (blocked) {
 			sigdelset(&t->blocked, sig);
-			recalc_sigpending_tsk(t);
+			recalc_sigpending_and_wake(t);
 		}
 	}
 	ret = specific_send_sig_info(sig, info, t);
@@ -2273,7 +2285,7 @@ int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)
 			rm_from_queue_full(&mask, &t->signal->shared_pending);
 			do {
 				rm_from_queue_full(&mask, &t->pending);
-				recalc_sigpending_tsk(t);
+				recalc_sigpending_and_wake(t);
 				t = next_thread(t);
 			} while (t != current);
 		}
diff --git a/kernel/time/ntp.c b/kernel/time/ntp.c
index cb25649..87aa5ff 100644
--- a/kernel/time/ntp.c
+++ b/kernel/time/ntp.c
@@ -11,6 +11,8 @@
 #include <linux/mm.h>
 #include <linux/time.h>
 #include <linux/timex.h>
+#include <linux/jiffies.h>
+#include <linux/hrtimer.h>
 
 #include <asm/div64.h>
 #include <asm/timex.h>
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
index eadfce2..8001d37 100644
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -243,11 +243,18 @@ void tick_broadcast_on_off(unsigned long reason, int *oncpu)
 {
 	int cpu = get_cpu();
 
-	if (cpu == *oncpu)
-		tick_do_broadcast_on_off(&reason);
-	else
-		smp_call_function_single(*oncpu, tick_do_broadcast_on_off,
-					 &reason, 1, 1);
+	if (!cpu_isset(*oncpu, cpu_online_map)) {
+		printk(KERN_ERR "tick-braodcast: ignoring broadcast for "
+		       "offline CPU #%d\n", *oncpu);
+	} else {
+
+		if (cpu == *oncpu)
+			tick_do_broadcast_on_off(&reason);
+		else
+			smp_call_function_single(*oncpu,
+						 tick_do_broadcast_on_off,
+						 &reason, 1, 1);
+	}
 	put_cpu();
 }
 
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 3483e6c..3e7ebc4 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -167,9 +167,15 @@ void tick_nohz_stop_sched_tick(void)
 		goto end;
 
 	cpu = smp_processor_id();
-	if (unlikely(local_softirq_pending()))
-		printk(KERN_ERR "NOHZ: local_softirq_pending %02x\n",
-		       local_softirq_pending());
+	if (unlikely(local_softirq_pending())) {
+		static int ratelimit;
+
+		if (ratelimit < 10) {
+			printk(KERN_ERR "NOHZ: local_softirq_pending %02x\n",
+			       local_softirq_pending());
+			ratelimit++;
+		}
+	}
 
 	now = ktime_get();
 	/*
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index fb56fed..3bebf73 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -47,7 +47,6 @@ struct cpu_workqueue_struct {
 
 	struct workqueue_struct *wq;
 	struct task_struct *thread;
-	int should_stop;
 
 	int run_depth;		/* Detect run_workqueue() recursion depth */
 } ____cacheline_aligned;
@@ -71,7 +70,13 @@ static LIST_HEAD(workqueues);
 
 static int singlethread_cpu __read_mostly;
 static cpumask_t cpu_singlethread_map __read_mostly;
-/* optimization, we could use cpu_possible_map */
+/*
+ * _cpu_down() first removes CPU from cpu_online_map, then CPU_DEAD
+ * flushes cwq->worklist. This means that flush_workqueue/wait_on_work
+ * which comes in between can't use for_each_online_cpu(). We could
+ * use cpu_possible_map, the cpumask below is more a documentation
+ * than optimization.
+ */
 static cpumask_t cpu_populated_map __read_mostly;
 
 /* If it's single threaded, it isn't in the list of workqueues. */
@@ -272,24 +277,6 @@ static void run_workqueue(struct cpu_workqueue_struct *cwq)
 	spin_unlock_irq(&cwq->lock);
 }
 
-/*
- * NOTE: the caller must not touch *cwq if this func returns true
- */
-static int cwq_should_stop(struct cpu_workqueue_struct *cwq)
-{
-	int should_stop = cwq->should_stop;
-
-	if (unlikely(should_stop)) {
-		spin_lock_irq(&cwq->lock);
-		should_stop = cwq->should_stop && list_empty(&cwq->worklist);
-		if (should_stop)
-			cwq->thread = NULL;
-		spin_unlock_irq(&cwq->lock);
-	}
-
-	return should_stop;
-}
-
 static int worker_thread(void *__cwq)
 {
 	struct cpu_workqueue_struct *cwq = __cwq;
@@ -302,14 +289,15 @@ static int worker_thread(void *__cwq)
 
 	for (;;) {
 		prepare_to_wait(&cwq->more_work, &wait, TASK_INTERRUPTIBLE);
-		if (!freezing(current) && !cwq->should_stop
-		    && list_empty(&cwq->worklist))
+		if (!freezing(current) &&
+		    !kthread_should_stop() &&
+		    list_empty(&cwq->worklist))
 			schedule();
 		finish_wait(&cwq->more_work, &wait);
 
 		try_to_freeze();
 
-		if (cwq_should_stop(cwq))
+		if (kthread_should_stop())
 			break;
 
 		run_workqueue(cwq);
@@ -340,18 +328,21 @@ static void insert_wq_barrier(struct cpu_workqueue_struct *cwq,
 	insert_work(cwq, &barr->work, tail);
 }
 
-static void flush_cpu_workqueue(struct cpu_workqueue_struct *cwq)
+static int flush_cpu_workqueue(struct cpu_workqueue_struct *cwq)
 {
+	int active;
+
 	if (cwq->thread == current) {
 		/*
 		 * Probably keventd trying to flush its own queue. So simply run
 		 * it by hand rather than deadlocking.
 		 */
 		run_workqueue(cwq);
+		active = 1;
 	} else {
 		struct wq_barrier barr;
-		int active = 0;
 
+		active = 0;
 		spin_lock_irq(&cwq->lock);
 		if (!list_empty(&cwq->worklist) || cwq->current_work != NULL) {
 			insert_wq_barrier(cwq, &barr, 1);
@@ -362,6 +353,8 @@ static void flush_cpu_workqueue(struct cpu_workqueue_struct *cwq)
 		if (active)
 			wait_for_completion(&barr.done);
 	}
+
+	return active;
 }
 
 /**
@@ -674,7 +667,6 @@ static int create_workqueue_thread(struct cpu_workqueue_struct *cwq, int cpu)
 		return PTR_ERR(p);
 
 	cwq->thread = p;
-	cwq->should_stop = 0;
 
 	return 0;
 }
@@ -740,29 +732,27 @@ EXPORT_SYMBOL_GPL(__create_workqueue);
 
 static void cleanup_workqueue_thread(struct cpu_workqueue_struct *cwq, int cpu)
 {
-	struct wq_barrier barr;
-	int alive = 0;
-
-	spin_lock_irq(&cwq->lock);
-	if (cwq->thread != NULL) {
-		insert_wq_barrier(cwq, &barr, 1);
-		cwq->should_stop = 1;
-		alive = 1;
-	}
-	spin_unlock_irq(&cwq->lock);
+	/*
+	 * Our caller is either destroy_workqueue() or CPU_DEAD,
+	 * workqueue_mutex protects cwq->thread
+	 */
+	if (cwq->thread == NULL)
+		return;
 
-	if (alive) {
-		wait_for_completion(&barr.done);
+	/*
+	 * If the caller is CPU_DEAD the single flush_cpu_workqueue()
+	 * is not enough, a concurrent flush_workqueue() can insert a
+	 * barrier after us.
+	 * When ->worklist becomes empty it is safe to exit because no
+	 * more work_structs can be queued on this cwq: flush_workqueue
+	 * checks list_empty(), and a "normal" queue_work() can't use
+	 * a dead CPU.
+	 */
+	while (flush_cpu_workqueue(cwq))
+		;
 
-		while (unlikely(cwq->thread != NULL))
-			cpu_relax();
-		/*
-		 * Wait until cwq->thread unlocks cwq->lock,
-		 * it won't touch *cwq after that.
-		 */
-		smp_rmb();
-		spin_unlock_wait(&cwq->lock);
-	}
+	kthread_stop(cwq->thread);
+	cwq->thread = NULL;
 }
 
 /**
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index fbc5c62..1ba77ca 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -378,14 +378,13 @@ config FORCED_INLINING
 config RCU_TORTURE_TEST
 	tristate "torture tests for RCU"
 	depends on DEBUG_KERNEL
+	depends on m
 	default n
 	help
 	  This option provides a kernel module that runs torture tests
 	  on the RCU infrastructure.  The kernel module may be built
 	  after the fact on the running kernel to be tested, if desired.
 
-	  Say Y here if you want RCU torture tests to start automatically
-	  at boot time (you probably don't).
 	  Say M if you want the RCU torture tests to build as a module.
 	  Say N if you are unsure.
 
diff --git a/lib/ioremap.c b/lib/ioremap.c
index a9e4415..7605214 100644
--- a/lib/ioremap.c
+++ b/lib/ioremap.c
@@ -7,7 +7,7 @@
  */
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
-
+#include <linux/sched.h>
 #include <asm/cacheflush.h>
 #include <asm/pgtable.h>
 
diff --git a/mm/filemap_xip.c b/mm/filemap_xip.c
index 1b49dab..fa360e5 100644
--- a/mm/filemap_xip.c
+++ b/mm/filemap_xip.c
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/uio.h>
 #include <linux/rmap.h>
+#include <linux/sched.h>
 #include <asm/tlbflush.h>
 #include "filemap.h"
 
diff --git a/mm/madvise.c b/mm/madvise.c
index e75096b..60542d0 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -10,6 +10,7 @@
 #include <linux/syscalls.h>
 #include <linux/mempolicy.h>
 #include <linux/hugetlb.h>
+#include <linux/sched.h>
 
 /*
  * Any behaviour which results in changes to the vma->vm_flags needs to
diff --git a/mm/mlock.c b/mm/mlock.c
index 3446b7e..4d3fea2 100644
--- a/mm/mlock.c
+++ b/mm/mlock.c
@@ -10,7 +10,18 @@
 #include <linux/mm.h>
 #include <linux/mempolicy.h>
 #include <linux/syscalls.h>
+#include <linux/sched.h>
+#include <linux/module.h>
 
+int can_do_mlock(void)
+{
+	if (capable(CAP_IPC_LOCK))
+		return 1;
+	if (current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur != 0)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(can_do_mlock);
 
 static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,
 	unsigned long start, unsigned long end, unsigned int newflags)
diff --git a/mm/msync.c b/mm/msync.c
index 358d73c..144a757 100644
--- a/mm/msync.c
+++ b/mm/msync.c
@@ -12,6 +12,7 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/syscalls.h>
+#include <linux/sched.h>
 
 /*
  * MS_SYNC syncs the entire file - including mappings.
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index ae96dd8..d897062 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -136,6 +136,11 @@ static unsigned long __meminitdata dma_reserve;
 #endif /* CONFIG_MEMORY_HOTPLUG_RESERVE */
 #endif /* CONFIG_ARCH_POPULATES_NODE_MAP */
 
+#if MAX_NUMNODES > 1
+int nr_node_ids __read_mostly = MAX_NUMNODES;
+EXPORT_SYMBOL(nr_node_ids);
+#endif
+
 #ifdef CONFIG_DEBUG_VM
 static int page_outside_zone_boundaries(struct zone *zone, struct page *page)
 {
@@ -669,26 +674,6 @@ static int rmqueue_bulk(struct zone *zone, unsigned int order,
 	return i;
 }
 
-#if MAX_NUMNODES > 1
-int nr_node_ids __read_mostly = MAX_NUMNODES;
-EXPORT_SYMBOL(nr_node_ids);
-
-/*
- * Figure out the number of possible node ids.
- */
-static void __init setup_nr_node_ids(void)
-{
-	unsigned int node;
-	unsigned int highest = 0;
-
-	for_each_node_mask(node, node_possible_map)
-		highest = node;
-	nr_node_ids = highest + 1;
-}
-#else
-static void __init setup_nr_node_ids(void) {}
-#endif
-
 #ifdef CONFIG_NUMA
 /*
  * Called from the vmstat counter updater to drain pagesets of this
@@ -2165,7 +2150,7 @@ void __init setup_per_cpu_pageset(void)
 
 #endif
 
-static __meminit noinline
+static noinline __init_refok
 int zone_wait_table_init(struct zone *zone, unsigned long zone_size_pages)
 {
 	int i;
@@ -2678,7 +2663,7 @@ static void __meminit free_area_init_core(struct pglist_data *pgdat,
 	}
 }
 
-static void __meminit alloc_node_mem_map(struct pglist_data *pgdat)
+static void __init_refok alloc_node_mem_map(struct pglist_data *pgdat)
 {
 	/* Skip empty nodes */
 	if (!pgdat->node_spanned_pages)
@@ -2733,6 +2718,26 @@ void __meminit free_area_init_node(int nid, struct pglist_data *pgdat,
 }
 
 #ifdef CONFIG_ARCH_POPULATES_NODE_MAP
+
+#if MAX_NUMNODES > 1
+/*
+ * Figure out the number of possible node ids.
+ */
+static void __init setup_nr_node_ids(void)
+{
+	unsigned int node;
+	unsigned int highest = 0;
+
+	for_each_node_mask(node, node_possible_map)
+		highest = node;
+	nr_node_ids = highest + 1;
+}
+#else
+static inline void setup_nr_node_ids(void)
+{
+}
+#endif
+
 /**
  * add_active_range - Register a range of PFNs backed by physical memory
  * @nid: The node ID the range resides on
diff --git a/mm/slab.c b/mm/slab.c
index 528243e..2e71a32 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -2037,7 +2037,7 @@ static size_t calculate_slab_order(struct kmem_cache *cachep,
 	return left_over;
 }
 
-static int setup_cpu_cache(struct kmem_cache *cachep)
+static int __init_refok setup_cpu_cache(struct kmem_cache *cachep)
 {
 	if (g_cpucache_up == FULL)
 		return enable_cpucache(cachep);
diff --git a/mm/slub.c b/mm/slub.c
index 98801d4..3e5aefc 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -939,7 +939,7 @@ static void kmem_cache_open_debug_check(struct kmem_cache *s)
 	 * Debugging or ctor may create a need to move the free
 	 * pointer. Fail if this happens.
 	 */
-	if (s->size >= 65535 * sizeof(void *)) {
+	if (s->objsize >= 65535 * sizeof(void *)) {
 		BUG_ON(s->flags & (SLAB_RED_ZONE | SLAB_POISON |
 				SLAB_STORE_USER | SLAB_DESTROY_BY_RCU));
 		BUG_ON(s->ctor);
@@ -1917,7 +1917,6 @@ static int calculate_sizes(struct kmem_cache *s)
 	 */
 	s->inuse = size;
 
-#ifdef CONFIG_SLUB_DEBUG
 	if (((flags & (SLAB_DESTROY_BY_RCU | SLAB_POISON)) ||
 		s->ctor)) {
 		/*
@@ -1932,6 +1931,7 @@ static int calculate_sizes(struct kmem_cache *s)
 		size += sizeof(void *);
 	}
 
+#ifdef CONFIG_SLUB_DEBUG
 	if (flags & SLAB_STORE_USER)
 		/*
 		 * Need to store information about allocs and frees after
diff --git a/mm/sparse.c b/mm/sparse.c
index 6f3fff9..1302f83 100644
--- a/mm/sparse.c
+++ b/mm/sparse.c
@@ -44,7 +44,7 @@ EXPORT_SYMBOL(page_to_nid);
 #endif
 
 #ifdef CONFIG_SPARSEMEM_EXTREME
-static struct mem_section noinline *sparse_index_alloc(int nid)
+static struct mem_section noinline __init_refok *sparse_index_alloc(int nid)
 {
 	struct mem_section *section = NULL;
 	unsigned long array_size = SECTIONS_PER_ROOT *
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 8faf27e..3825429 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/cpu.h>
+#include <linux/sched.h>
 
 #ifdef CONFIG_VM_EVENT_COUNTERS
 DEFINE_PER_CPU(struct vm_event_state, vm_event_states) = {{0}};
diff --git a/net/bluetooth/l2cap.c b/net/bluetooth/l2cap.c
index a59b1fb..670ff95 100644
--- a/net/bluetooth/l2cap.c
+++ b/net/bluetooth/l2cap.c
@@ -507,6 +507,7 @@ static void l2cap_sock_init(struct sock *sk, struct sock *parent)
 	}
 
 	/* Default config options */
+	pi->conf_len = 0;
 	pi->conf_mtu = L2CAP_DEFAULT_MTU;
 	pi->flush_to = L2CAP_DEFAULT_FLUSH_TO;
 }
@@ -1271,42 +1272,6 @@ static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned
 	return len;
 }
 
-static inline void l2cap_parse_conf_req(struct sock *sk, void *data, int len)
-{
-	int type, hint, olen;
-	unsigned long val;
-	void *ptr = data;
-
-	BT_DBG("sk %p len %d", sk, len);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&ptr, &type, &olen, &val);
-
-		hint  = type & 0x80;
-		type &= 0x7f;
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			l2cap_pi(sk)->conf_mtu = val;
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			l2cap_pi(sk)->flush_to = val;
-			break;
-
-		case L2CAP_CONF_QOS:
-			break;
-
-		default:
-			if (hint)
-				break;
-
-			/* FIXME: Reject unknown option */
-			break;
-		}
-	}
-}
-
 static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
 {
 	struct l2cap_conf_opt *opt = *ptr;
@@ -1358,39 +1323,75 @@ static int l2cap_build_conf_req(struct sock *sk, void *data)
 	return ptr - data;
 }
 
-static inline int l2cap_conf_output(struct sock *sk, void **ptr)
+static int l2cap_parse_conf_req(struct sock *sk, void *data)
 {
 	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int result = 0;
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
+	void *req = pi->conf_req;
+	int len = pi->conf_len;
+	int type, hint, olen;
+	unsigned long val;
+	u16 result = L2CAP_CONF_SUCCESS;
 
-	/* Configure output options and let the other side know
-	 * which ones we don't like. */
-	if (pi->conf_mtu < pi->omtu)
-		result = L2CAP_CONF_UNACCEPT;
-	else
-		pi->omtu = pi->conf_mtu;
+	BT_DBG("sk %p", sk);
+
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
 
-	l2cap_add_conf_opt(ptr, L2CAP_CONF_MTU, 2, pi->omtu);
+		hint  = type & 0x80;
+		type &= 0x7f;
+
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			pi->conf_mtu = val;
+			break;
+
+		case L2CAP_CONF_FLUSH_TO:
+			pi->flush_to = val;
+			break;
+
+		case L2CAP_CONF_QOS:
+			break;
+
+		default:
+			if (hint)
+				break;
+
+			result = L2CAP_CONF_UNKNOWN;
+			*((u8 *) ptr++) = type;
+			break;
+		}
+	}
+
+	if (result == L2CAP_CONF_SUCCESS) {
+		/* Configure output options and let the other side know
+		 * which ones we don't like. */
+
+		if (pi->conf_mtu < pi->omtu)
+			result = L2CAP_CONF_UNACCEPT;
+		else
+			pi->omtu = pi->conf_mtu;
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
+	}
 
-	BT_DBG("sk %p result %d", sk, result);
-	return result;
+	rsp->scid   = cpu_to_le16(pi->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(0x0000);
+
+	return ptr - data;
 }
 
-static int l2cap_build_conf_rsp(struct sock *sk, void *data, int *result)
+static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)
 {
 	struct l2cap_conf_rsp *rsp = data;
 	void *ptr = rsp->data;
-	u16 flags = 0;
-
-	BT_DBG("sk %p complete %d", sk, result ? 1 : 0);
 
-	if (result)
-		*result = l2cap_conf_output(sk, &ptr);
-	else
-		flags = 0x0001;
+	BT_DBG("sk %p", sk);
 
 	rsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-	rsp->result = cpu_to_le16(result ? *result : 0);
+	rsp->result = cpu_to_le16(result);
 	rsp->flags  = cpu_to_le16(flags);
 
 	return ptr - data;
@@ -1535,7 +1536,7 @@ static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr
 	u16 dcid, flags;
 	u8 rsp[64];
 	struct sock *sk;
-	int result;
+	int len;
 
 	dcid  = __le16_to_cpu(req->dcid);
 	flags = __le16_to_cpu(req->flags);
@@ -1548,25 +1549,40 @@ static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr
 	if (sk->sk_state == BT_DISCONN)
 		goto unlock;
 
-	l2cap_parse_conf_req(sk, req->data, cmd->len - sizeof(*req));
+	/* Reject if config buffer is too small. */
+	len = cmd->len - sizeof(*req);
+	if (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(sk, rsp,
+					L2CAP_CONF_REJECT, flags), rsp);
+		goto unlock;
+	}
+
+	/* Store config. */
+	memcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);
+	l2cap_pi(sk)->conf_len += len;
 
 	if (flags & 0x0001) {
 		/* Incomplete config. Send empty response. */
 		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rsp, NULL), rsp);
+				l2cap_build_conf_rsp(sk, rsp,
+					L2CAP_CONF_SUCCESS, 0x0001), rsp);
 		goto unlock;
 	}
 
 	/* Complete config. */
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-			l2cap_build_conf_rsp(sk, rsp, &result), rsp);
-
-	if (result)
+	len = l2cap_parse_conf_req(sk, rsp);
+	if (len < 0)
 		goto unlock;
 
-	/* Output config done */
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
+
+	/* Output config done. */
 	l2cap_pi(sk)->conf_state |= L2CAP_CONF_OUTPUT_DONE;
 
+	/* Reset config buffer. */
+	l2cap_pi(sk)->conf_len = 0;
+
 	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
 		sk->sk_state = BT_CONNECTED;
 		l2cap_chan_ready(sk);
diff --git a/net/core/dev.c b/net/core/dev.c
index f2b6111..5a7f20f 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3314,7 +3314,6 @@ void netdev_run_todo(void)
 			continue;
 		}
 
-		netdev_unregister_sysfs(dev);
 		dev->reg_state = NETREG_UNREGISTERED;
 
 		netdev_wait_allrefs(dev);
@@ -3325,11 +3324,11 @@ void netdev_run_todo(void)
 		BUG_TRAP(!dev->ip6_ptr);
 		BUG_TRAP(!dev->dn_ptr);
 
-		/* It must be the very last action,
-		 * after this 'dev' may point to freed up memory.
-		 */
 		if (dev->destructor)
 			dev->destructor(dev);
+
+		/* Free network device */
+		kobject_put(&dev->dev.kobj);
 	}
 
 out:
@@ -3480,6 +3479,9 @@ void unregister_netdevice(struct net_device *dev)
 	/* Notifier chain MUST detach us from master device. */
 	BUG_TRAP(!dev->master);
 
+	/* Remove entries from sysfs */
+	netdev_unregister_sysfs(dev);
+
 	/* Finish processing unregister after unlock */
 	net_set_todo(dev);
 
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index b21307b..5c19b06 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -456,9 +456,15 @@ static struct class net_class = {
 #endif
 };
 
+/* Delete sysfs entries but hold kobject reference until after all
+ * netdev references are gone.
+ */
 void netdev_unregister_sysfs(struct net_device * net)
 {
-	device_del(&(net->dev));
+	struct device *dev = &(net->dev);
+
+	kobject_get(&dev->kobj);
+	device_del(dev);
 }
 
 /* Create sysfs entries for network device. */
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 8c971a2..27da9cd 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -437,7 +437,7 @@ static void copy_rtnl_link_stats(struct rtnl_link_stats *a,
 	a->tx_compressed = b->tx_compressed;
 };
 
-static inline size_t if_nlmsg_size(int iwbuflen)
+static inline size_t if_nlmsg_size(void)
 {
 	return NLMSG_ALIGN(sizeof(struct ifinfomsg))
 	       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */
@@ -452,13 +452,12 @@ static inline size_t if_nlmsg_size(int iwbuflen)
 	       + nla_total_size(4) /* IFLA_LINK */
 	       + nla_total_size(4) /* IFLA_MASTER */
 	       + nla_total_size(1) /* IFLA_OPERSTATE */
-	       + nla_total_size(1) /* IFLA_LINKMODE */
-	       + nla_total_size(iwbuflen);
+	       + nla_total_size(1); /* IFLA_LINKMODE */
 }
 
 static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
-			    void *iwbuf, int iwbuflen, int type, u32 pid,
-			    u32 seq, u32 change, unsigned int flags)
+			    int type, u32 pid, u32 seq, u32 change,
+			    unsigned int flags)
 {
 	struct ifinfomsg *ifm;
 	struct nlmsghdr *nlh;
@@ -523,9 +522,6 @@ static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
 		}
 	}
 
-	if (iwbuf)
-		NLA_PUT(skb, IFLA_WIRELESS, iwbuflen, iwbuf);
-
 	return nlmsg_end(skb, nlh);
 
 nla_put_failure:
@@ -543,7 +539,7 @@ static int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)
 	for_each_netdev(dev) {
 		if (idx < s_idx)
 			goto cont;
-		if (rtnl_fill_ifinfo(skb, dev, NULL, 0, RTM_NEWLINK,
+		if (rtnl_fill_ifinfo(skb, dev, RTM_NEWLINK,
 				     NETLINK_CB(cb->skb).pid,
 				     cb->nlh->nlmsg_seq, 0, NLM_F_MULTI) <= 0)
 			break;
@@ -689,8 +685,15 @@ static int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 	}
 
 
-	if (ifm->ifi_flags)
-		dev_change_flags(dev, ifm->ifi_flags);
+	if (ifm->ifi_flags || ifm->ifi_change) {
+		unsigned int flags = ifm->ifi_flags;
+
+		/* bugwards compatibility: ifi_change == 0 is treated as ~0 */
+		if (ifm->ifi_change)
+			flags = (flags & ifm->ifi_change) |
+				(dev->flags & ~ifm->ifi_change);
+		dev_change_flags(dev, flags);
+	}
 
 	if (tb[IFLA_TXQLEN])
 		dev->tx_queue_len = nla_get_u32(tb[IFLA_TXQLEN]);
@@ -730,8 +733,6 @@ static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 	struct nlattr *tb[IFLA_MAX+1];
 	struct net_device *dev = NULL;
 	struct sk_buff *nskb;
-	char *iw_buf = NULL, *iw = NULL;
-	int iw_buf_len = 0;
 	int err;
 
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);
@@ -746,14 +747,14 @@ static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 	} else
 		return -EINVAL;
 
-	nskb = nlmsg_new(if_nlmsg_size(iw_buf_len), GFP_KERNEL);
+	nskb = nlmsg_new(if_nlmsg_size(), GFP_KERNEL);
 	if (nskb == NULL) {
 		err = -ENOBUFS;
 		goto errout;
 	}
 
-	err = rtnl_fill_ifinfo(nskb, dev, iw, iw_buf_len, RTM_NEWLINK,
-			       NETLINK_CB(skb).pid, nlh->nlmsg_seq, 0, 0);
+	err = rtnl_fill_ifinfo(nskb, dev, RTM_NEWLINK, NETLINK_CB(skb).pid,
+			       nlh->nlmsg_seq, 0, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in if_nlmsg_size */
 		WARN_ON(err == -EMSGSIZE);
@@ -762,7 +763,6 @@ static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)
 	}
 	err = rtnl_unicast(nskb, NETLINK_CB(skb).pid);
 errout:
-	kfree(iw_buf);
 	dev_put(dev);
 
 	return err;
@@ -797,11 +797,11 @@ void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change)
 	struct sk_buff *skb;
 	int err = -ENOBUFS;
 
-	skb = nlmsg_new(if_nlmsg_size(0), GFP_KERNEL);
+	skb = nlmsg_new(if_nlmsg_size(), GFP_KERNEL);
 	if (skb == NULL)
 		goto errout;
 
-	err = rtnl_fill_ifinfo(skb, dev, NULL, 0, type, 0, 0, change, 0);
+	err = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in if_nlmsg_size() */
 		WARN_ON(err == -EMSGSIZE);
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 1422573..7c6a34e 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -644,11 +644,10 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 
 	/* Copy only real data... and, alas, header. This should be
 	 * optimized for the cases when header is void. */
-	memcpy(data + nhead, skb->head,
 #ifdef NET_SKBUFF_DATA_USES_OFFSET
-		skb->tail);
+	memcpy(data + nhead, skb->head, skb->tail);
 #else
-		skb->tail - skb->head);
+	memcpy(data + nhead, skb->head, skb->tail - skb->head);
 #endif
 	memcpy(data + size, skb_end_pointer(skb),
 	       sizeof(struct skb_shared_info));
diff --git a/net/core/sock.c b/net/core/sock.c
index 22183c2..7e51d3a 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -206,7 +206,19 @@ static int sock_set_timeout(long *timeo_p, char __user *optval, int optlen)
 		return -EINVAL;
 	if (copy_from_user(&tv, optval, sizeof(tv)))
 		return -EFAULT;
-
+	if (tv.tv_usec < 0 || tv.tv_usec >= USEC_PER_SEC)
+		return -EDOM;
+
+	if (tv.tv_sec < 0) {
+		static int warned = 0;
+		*timeo_p = 0;
+		if (warned < 10 && net_ratelimit())
+			warned++;
+			printk(KERN_INFO "sock_set_timeout: `%s' (pid %d) "
+			       "tries to set negative timeout\n",
+			        current->comm, current->pid);
+		return 0;
+	}
 	*timeo_p = MAX_SCHEDULE_TIMEOUT;
 	if (tv.tv_sec == 0 && tv.tv_usec == 0)
 		return 0;
diff --git a/net/core/sysctl_net_core.c b/net/core/sysctl_net_core.c
index b297120..f34aca0 100644
--- a/net/core/sysctl_net_core.c
+++ b/net/core/sysctl_net_core.c
@@ -24,6 +24,7 @@ extern int sysctl_core_destroy_delay;
 #ifdef CONFIG_XFRM
 extern u32 sysctl_xfrm_aevent_etime;
 extern u32 sysctl_xfrm_aevent_rseqth;
+extern int sysctl_xfrm_larval_drop;
 #endif
 
 ctl_table core_table[] = {
@@ -118,6 +119,14 @@ ctl_table core_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "xfrm_larval_drop",
+		.data		= &sysctl_xfrm_larval_drop,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
 #endif /* CONFIG_XFRM */
 #endif /* CONFIG_NET */
 	{
diff --git a/net/dccp/Kconfig b/net/dccp/Kconfig
index b8a68dd..0549e47 100644
--- a/net/dccp/Kconfig
+++ b/net/dccp/Kconfig
@@ -1,8 +1,6 @@
-menu "DCCP Configuration (EXPERIMENTAL)"
-	depends on INET && EXPERIMENTAL
-
-config IP_DCCP
+menuconfig IP_DCCP
 	tristate "The DCCP Protocol (EXPERIMENTAL)"
+	depends on INET && EXPERIMENTAL
 	---help---
 	  Datagram Congestion Control Protocol (RFC 4340)
 
@@ -19,19 +17,20 @@ config IP_DCCP
 
 	  If in doubt, say N.
 
+if IP_DCCP
+
 config INET_DCCP_DIAG
-	depends on IP_DCCP && INET_DIAG
+	depends on INET_DIAG
 	def_tristate y if (IP_DCCP = y && INET_DIAG = y)
 	def_tristate m
 
 config IP_DCCP_ACKVEC
-	depends on IP_DCCP
 	bool
 
 source "net/dccp/ccids/Kconfig"
 
 menu "DCCP Kernel Hacking"
-	depends on IP_DCCP && DEBUG_KERNEL=y
+	depends on DEBUG_KERNEL=y
 
 config IP_DCCP_DEBUG
 	bool "DCCP debug messages"
@@ -61,4 +60,4 @@ config NET_DCCPPROBE
 
 endmenu
 
-endmenu
+endif # IP_DDCP
diff --git a/net/dccp/ccids/ccid3.c b/net/dccp/ccids/ccid3.c
index d7d9ce7..ec7fa4d 100644
--- a/net/dccp/ccids/ccid3.c
+++ b/net/dccp/ccids/ccid3.c
@@ -419,7 +419,6 @@ static void ccid3_hc_tx_packet_sent(struct sock *sk, int more,
 
 static void ccid3_hc_tx_packet_recv(struct sock *sk, struct sk_buff *skb)
 {
-	const struct dccp_sock *dp = dccp_sk(sk);
 	struct ccid3_hc_tx_sock *hctx = ccid3_hc_tx_sk(sk);
 	struct ccid3_options_received *opt_recv;
 	struct dccp_tx_hist_entry *packet;
@@ -491,7 +490,7 @@ static void ccid3_hc_tx_packet_recv(struct sock *sk, struct sk_buff *skb)
 			ccid3_pr_debug("%s(%p), s=%u, MSS=%u, "
 				       "R_sample=%uus, X=%u\n", dccp_role(sk),
 				       sk, hctx->ccid3hctx_s,
-				       dp->dccps_mss_cache, r_sample,
+				       dccp_sk(sk)->dccps_mss_cache, r_sample,
 				       (unsigned)(hctx->ccid3hctx_x >> 6));
 
 			ccid3_hc_tx_set_state(sk, TFRC_SSTATE_FBACK);
diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c
index 64eac25..31737cd 100644
--- a/net/dccp/ipv6.c
+++ b/net/dccp/ipv6.c
@@ -1043,9 +1043,13 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
 	if (final_p)
 		ipv6_addr_copy(&fl.fl6_dst, final_p);
 
-	err = xfrm_lookup(&dst, &fl, sk, 1);
-	if (err < 0)
-		goto failure;
+	err = __xfrm_lookup(&dst, &fl, sk, 1);
+	if (err < 0) {
+		if (err == -EREMOTE)
+			err = ip6_dst_blackhole(sk, &dst, &fl);
+		if (err < 0)
+			goto failure;
+	}
 
 	if (saddr == NULL) {
 		saddr = &fl.fl6_src;
diff --git a/net/ipv4/fib_hash.c b/net/ipv4/fib_hash.c
index 9cfecf1..07e843a 100644
--- a/net/ipv4/fib_hash.c
+++ b/net/ipv4/fib_hash.c
@@ -456,6 +456,8 @@ static int fn_hash_insert(struct fib_table *tb, struct fib_config *cfg)
 			fib_release_info(fi_drop);
 			if (state & FA_S_ACCESSED)
 				rt_cache_flush(-1);
+			rtmsg_fib(RTM_NEWROUTE, key, fa, cfg->fc_dst_len, tb->tb_id,
+				  &cfg->fc_nlinfo, NLM_F_REPLACE);
 			return 0;
 		}
 
@@ -523,7 +525,7 @@ static int fn_hash_insert(struct fib_table *tb, struct fib_config *cfg)
 	rt_cache_flush(-1);
 
 	rtmsg_fib(RTM_NEWROUTE, key, new_fa, cfg->fc_dst_len, tb->tb_id,
-		  &cfg->fc_nlinfo);
+		  &cfg->fc_nlinfo, 0);
 	return 0;
 
 out_free_new_fa:
@@ -589,7 +591,7 @@ static int fn_hash_delete(struct fib_table *tb, struct fib_config *cfg)
 
 		fa = fa_to_delete;
 		rtmsg_fib(RTM_DELROUTE, key, fa, cfg->fc_dst_len,
-			  tb->tb_id, &cfg->fc_nlinfo);
+			  tb->tb_id, &cfg->fc_nlinfo, 0);
 
 		kill_fn = 0;
 		write_lock_bh(&fib_hash_lock);
diff --git a/net/ipv4/fib_lookup.h b/net/ipv4/fib_lookup.h
index 0e8b70b..eef9eec 100644
--- a/net/ipv4/fib_lookup.h
+++ b/net/ipv4/fib_lookup.h
@@ -30,7 +30,8 @@ extern int fib_dump_info(struct sk_buff *skb, u32 pid, u32 seq, int event,
 			 int dst_len, u8 tos, struct fib_info *fi,
 			 unsigned int);
 extern void rtmsg_fib(int event, __be32 key, struct fib_alias *fa,
-		      int dst_len, u32 tb_id, struct nl_info *info);
+		      int dst_len, u32 tb_id, struct nl_info *info,
+		      unsigned int nlm_flags);
 extern struct fib_alias *fib_find_alias(struct list_head *fah,
 					u8 tos, u32 prio);
 extern int fib_detect_death(struct fib_info *fi, int order,
diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index 406ea70..bb94550 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -301,7 +301,8 @@ static inline size_t fib_nlmsg_size(struct fib_info *fi)
 }
 
 void rtmsg_fib(int event, __be32 key, struct fib_alias *fa,
-	       int dst_len, u32 tb_id, struct nl_info *info)
+	       int dst_len, u32 tb_id, struct nl_info *info,
+	       unsigned int nlm_flags)
 {
 	struct sk_buff *skb;
 	u32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;
@@ -313,7 +314,7 @@ void rtmsg_fib(int event, __be32 key, struct fib_alias *fa,
 
 	err = fib_dump_info(skb, info->pid, seq, event, tb_id,
 			    fa->fa_type, fa->fa_scope, key, dst_len,
-			    fa->fa_tos, fa->fa_info, 0);
+			    fa->fa_tos, fa->fa_info, nlm_flags);
 	if (err < 0) {
 		/* -EMSGSIZE implies BUG in fib_nlmsg_size() */
 		WARN_ON(err == -EMSGSIZE);
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 9be7da7..30e332a 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -1226,6 +1226,8 @@ static int fn_trie_insert(struct fib_table *tb, struct fib_config *cfg)
 			fib_release_info(fi_drop);
 			if (state & FA_S_ACCESSED)
 				rt_cache_flush(-1);
+			rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen,
+				tb->tb_id, &cfg->fc_nlinfo, NLM_F_REPLACE);
 
 			goto succeeded;
 		}
@@ -1278,7 +1280,7 @@ static int fn_trie_insert(struct fib_table *tb, struct fib_config *cfg)
 
 	rt_cache_flush(-1);
 	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, tb->tb_id,
-		  &cfg->fc_nlinfo);
+		  &cfg->fc_nlinfo, 0);
 succeeded:
 	return 0;
 
@@ -1624,7 +1626,7 @@ static int fn_trie_delete(struct fib_table *tb, struct fib_config *cfg)
 
 	fa = fa_to_delete;
 	rtmsg_fib(RTM_DELROUTE, htonl(key), fa, plen, tb->tb_id,
-		  &cfg->fc_nlinfo);
+		  &cfg->fc_nlinfo, 0);
 
 	l = fib_find_node(t, key);
 	li = find_leaf_info(l, plen);
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index d38cbba..e238b17 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -514,7 +514,10 @@ void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
 
 	saddr = iph->daddr;
 	if (!(rt->rt_flags & RTCF_LOCAL)) {
-		if (sysctl_icmp_errors_use_inbound_ifaddr)
+		/* This is broken, skb_in->dev points to the outgoing device
+		 * after the packet passes through ip_output().
+		 */
+		if (skb_in->dev && sysctl_icmp_errors_use_inbound_ifaddr)
 			saddr = inet_select_addr(skb_in->dev, 0, RT_SCOPE_LINK);
 		else
 			saddr = 0;
diff --git a/net/ipv4/ipvs/Kconfig b/net/ipv4/ipvs/Kconfig
index 891b935..09d0c3f 100644
--- a/net/ipv4/ipvs/Kconfig
+++ b/net/ipv4/ipvs/Kconfig
@@ -1,10 +1,7 @@
 #
 # IP Virtual Server configuration
 #
-menu	"IP: Virtual Server Configuration"
-	depends on NETFILTER
-
-config	IP_VS
+menuconfig IP_VS
 	tristate "IP virtual server support (EXPERIMENTAL)"
 	depends on NETFILTER
 	---help---
@@ -25,9 +22,10 @@ config	IP_VS
 	  If you want to compile it in kernel, say Y. To compile it as a
 	  module, choose M here. If unsure, say N.
 
+if IP_VS
+
 config	IP_VS_DEBUG
 	bool "IP virtual server debugging"
-	depends on IP_VS
 	---help---
 	  Say Y here if you want to get additional messages useful in
 	  debugging the IP virtual server code. You can change the debug
@@ -35,7 +33,6 @@ config	IP_VS_DEBUG
 
 config	IP_VS_TAB_BITS
 	int "IPVS connection table size (the Nth power of 2)"
-	depends on IP_VS 
 	default "12" 
 	---help---
 	  The IPVS connection hash table uses the chaining scheme to handle
@@ -61,42 +58,35 @@ config	IP_VS_TAB_BITS
 	  needed for your box.
 
 comment "IPVS transport protocol load balancing support"
-        depends on IP_VS
 
 config	IP_VS_PROTO_TCP
 	bool "TCP load balancing support"
-	depends on IP_VS
 	---help---
 	  This option enables support for load balancing TCP transport
 	  protocol. Say Y if unsure.
 
 config	IP_VS_PROTO_UDP
 	bool "UDP load balancing support"
-	depends on IP_VS
 	---help---
 	  This option enables support for load balancing UDP transport
 	  protocol. Say Y if unsure.
 
 config	IP_VS_PROTO_ESP
 	bool "ESP load balancing support"
-	depends on IP_VS
 	---help---
 	  This option enables support for load balancing ESP (Encapsulation
 	  Security Payload) transport protocol. Say Y if unsure.
 
 config	IP_VS_PROTO_AH
 	bool "AH load balancing support"
-	depends on IP_VS
 	---help---
 	  This option enables support for load balancing AH (Authentication
 	  Header) transport protocol. Say Y if unsure.
 
 comment "IPVS scheduler"
-        depends on IP_VS
 
 config	IP_VS_RR
 	tristate "round-robin scheduling"
-	depends on IP_VS
 	---help---
 	  The robin-robin scheduling algorithm simply directs network
 	  connections to different real servers in a round-robin manner.
@@ -106,7 +96,6 @@ config	IP_VS_RR
  
 config	IP_VS_WRR
         tristate "weighted round-robin scheduling" 
-	depends on IP_VS
 	---help---
 	  The weighted robin-robin scheduling algorithm directs network
 	  connections to different real servers based on server weights
@@ -120,7 +109,6 @@ config	IP_VS_WRR
 
 config	IP_VS_LC
         tristate "least-connection scheduling"
-        depends on IP_VS
 	---help---
 	  The least-connection scheduling algorithm directs network
 	  connections to the server with the least number of active 
@@ -131,7 +119,6 @@ config	IP_VS_LC
 
 config	IP_VS_WLC
         tristate "weighted least-connection scheduling"
-        depends on IP_VS
 	---help---
 	  The weighted least-connection scheduling algorithm directs network
 	  connections to the server with the least active connections
@@ -142,7 +129,6 @@ config	IP_VS_WLC
 
 config	IP_VS_LBLC
 	tristate "locality-based least-connection scheduling"
-        depends on IP_VS
 	---help---
 	  The locality-based least-connection scheduling algorithm is for
 	  destination IP load balancing. It is usually used in cache cluster.
@@ -157,7 +143,6 @@ config	IP_VS_LBLC
 
 config  IP_VS_LBLCR
 	tristate "locality-based least-connection with replication scheduling"
-        depends on IP_VS
 	---help---
 	  The locality-based least-connection with replication scheduling
 	  algorithm is also for destination IP load balancing. It is 
@@ -176,7 +161,6 @@ config  IP_VS_LBLCR
 
 config	IP_VS_DH
 	tristate "destination hashing scheduling"
-        depends on IP_VS
 	---help---
 	  The destination hashing scheduling algorithm assigns network
 	  connections to the servers through looking up a statically assigned
@@ -187,7 +171,6 @@ config	IP_VS_DH
 
 config	IP_VS_SH
 	tristate "source hashing scheduling"
-        depends on IP_VS
 	---help---
 	  The source hashing scheduling algorithm assigns network
 	  connections to the servers through looking up a statically assigned
@@ -198,7 +181,6 @@ config	IP_VS_SH
 
 config	IP_VS_SED
 	tristate "shortest expected delay scheduling"
-        depends on IP_VS
 	---help---
 	  The shortest expected delay scheduling algorithm assigns network
 	  connections to the server with the shortest expected delay. The 
@@ -212,7 +194,6 @@ config	IP_VS_SED
 
 config	IP_VS_NQ
 	tristate "never queue scheduling"
-        depends on IP_VS
 	---help---
 	  The never queue scheduling algorithm adopts a two-speed model.
 	  When there is an idle server available, the job will be sent to
@@ -225,11 +206,10 @@ config	IP_VS_NQ
 	  module, choose M here. If unsure, say N.
 
 comment 'IPVS application helper'
-	depends on IP_VS
 
 config	IP_VS_FTP
   	tristate "FTP protocol helper"
-        depends on IP_VS && IP_VS_PROTO_TCP
+        depends on IP_VS_PROTO_TCP
 	---help---
 	  FTP is a protocol that transfers IP address and/or port number in
 	  the payload. In the virtual server via Network Address Translation,
@@ -241,4 +221,4 @@ config	IP_VS_FTP
 	  If you want to compile it in kernel, say Y. To compile it as a
 	  module, choose M here. If unsure, say N.
 
-endmenu
+endif # IP_VS
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index 0654eaa..fd62a41 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -154,12 +154,10 @@ static unsigned int ipv4_conntrack_defrag(unsigned int hooknum,
 					  const struct net_device *out,
 					  int (*okfn)(struct sk_buff *))
 {
-#if !defined(CONFIG_IP_NF_NAT) && !defined(CONFIG_IP_NF_NAT_MODULE)
 	/* Previously seen (loopback)?  Ignore.  Do this before
 	   fragment check. */
 	if ((*pskb)->nfct)
 		return NF_ACCEPT;
-#endif
 
 	/* Gather fragments. */
 	if (ip_hdr(*pskb)->frag_off & htons(IP_MF | IP_OFFSET)) {
diff --git a/net/ipv4/netfilter/nf_nat_ftp.c b/net/ipv4/netfilter/nf_nat_ftp.c
index 751b598..e6bc8e5 100644
--- a/net/ipv4/netfilter/nf_nat_ftp.c
+++ b/net/ipv4/netfilter/nf_nat_ftp.c
@@ -40,8 +40,7 @@ mangle_rfc959_packet(struct sk_buff **pskb,
 		     unsigned int matchoff,
 		     unsigned int matchlen,
 		     struct nf_conn *ct,
-		     enum ip_conntrack_info ctinfo,
-		     u32 *seq)
+		     enum ip_conntrack_info ctinfo)
 {
 	char buffer[sizeof("nnn,nnn,nnn,nnn,nnn,nnn")];
 
@@ -50,7 +49,6 @@ mangle_rfc959_packet(struct sk_buff **pskb,
 
 	DEBUGP("calling nf_nat_mangle_tcp_packet\n");
 
-	*seq += strlen(buffer) - matchlen;
 	return nf_nat_mangle_tcp_packet(pskb, ct, ctinfo, matchoff,
 					matchlen, buffer, strlen(buffer));
 }
@@ -63,8 +61,7 @@ mangle_eprt_packet(struct sk_buff **pskb,
 		   unsigned int matchoff,
 		   unsigned int matchlen,
 		   struct nf_conn *ct,
-		   enum ip_conntrack_info ctinfo,
-		   u32 *seq)
+		   enum ip_conntrack_info ctinfo)
 {
 	char buffer[sizeof("|1|255.255.255.255|65535|")];
 
@@ -72,7 +69,6 @@ mangle_eprt_packet(struct sk_buff **pskb,
 
 	DEBUGP("calling nf_nat_mangle_tcp_packet\n");
 
-	*seq += strlen(buffer) - matchlen;
 	return nf_nat_mangle_tcp_packet(pskb, ct, ctinfo, matchoff,
 					matchlen, buffer, strlen(buffer));
 }
@@ -85,8 +81,7 @@ mangle_epsv_packet(struct sk_buff **pskb,
 		   unsigned int matchoff,
 		   unsigned int matchlen,
 		   struct nf_conn *ct,
-		   enum ip_conntrack_info ctinfo,
-		   u32 *seq)
+		   enum ip_conntrack_info ctinfo)
 {
 	char buffer[sizeof("|||65535|")];
 
@@ -94,14 +89,13 @@ mangle_epsv_packet(struct sk_buff **pskb,
 
 	DEBUGP("calling nf_nat_mangle_tcp_packet\n");
 
-	*seq += strlen(buffer) - matchlen;
 	return nf_nat_mangle_tcp_packet(pskb, ct, ctinfo, matchoff,
 					matchlen, buffer, strlen(buffer));
 }
 
 static int (*mangle[])(struct sk_buff **, __be32, u_int16_t,
 		       unsigned int, unsigned int, struct nf_conn *,
-		       enum ip_conntrack_info, u32 *seq)
+		       enum ip_conntrack_info)
 = {
 	[NF_CT_FTP_PORT] = mangle_rfc959_packet,
 	[NF_CT_FTP_PASV] = mangle_rfc959_packet,
@@ -116,8 +110,7 @@ static unsigned int nf_nat_ftp(struct sk_buff **pskb,
 			       enum nf_ct_ftp_type type,
 			       unsigned int matchoff,
 			       unsigned int matchlen,
-			       struct nf_conntrack_expect *exp,
-			       u32 *seq)
+			       struct nf_conntrack_expect *exp)
 {
 	__be32 newip;
 	u_int16_t port;
@@ -145,8 +138,7 @@ static unsigned int nf_nat_ftp(struct sk_buff **pskb,
 	if (port == 0)
 		return NF_DROP;
 
-	if (!mangle[type](pskb, newip, port, matchoff, matchlen, ct, ctinfo,
-			  seq)) {
+	if (!mangle[type](pskb, newip, port, matchoff, matchlen, ct, ctinfo)) {
 		nf_conntrack_unexpect_related(exp);
 		return NF_DROP;
 	}
diff --git a/net/ipv4/netfilter/nf_nat_h323.c b/net/ipv4/netfilter/nf_nat_h323.c
index fcebc96..c5d2a2d 100644
--- a/net/ipv4/netfilter/nf_nat_h323.c
+++ b/net/ipv4/netfilter/nf_nat_h323.c
@@ -455,9 +455,9 @@ static int nat_q931(struct sk_buff **pskb, struct nf_conn *ct,
 		if (idx > 0 &&
 		    get_h225_addr(ct, *data, &taddr[0], &addr, &port) &&
 		    (ntohl(addr.ip) & 0xff000000) == 0x7f000000) {
-			set_h225_addr_hook(pskb, data, 0, &taddr[0],
-					   &ct->tuplehash[!dir].tuple.dst.u3,
-					   info->sig_port[!dir]);
+			set_h225_addr(pskb, data, 0, &taddr[0],
+				      &ct->tuplehash[!dir].tuple.dst.u3,
+				      info->sig_port[!dir]);
 		}
 	} else {
 		nf_conntrack_unexpect_related(exp);
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index df9fe4f..8603cfb 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -2598,6 +2598,69 @@ int __ip_route_output_key(struct rtable **rp, const struct flowi *flp)
 
 EXPORT_SYMBOL_GPL(__ip_route_output_key);
 
+static void ipv4_rt_blackhole_update_pmtu(struct dst_entry *dst, u32 mtu)
+{
+}
+
+static struct dst_ops ipv4_dst_blackhole_ops = {
+	.family			=	AF_INET,
+	.protocol		=	__constant_htons(ETH_P_IP),
+	.destroy		=	ipv4_dst_destroy,
+	.check			=	ipv4_dst_check,
+	.update_pmtu		=	ipv4_rt_blackhole_update_pmtu,
+	.entry_size		=	sizeof(struct rtable),
+};
+
+
+static int ipv4_blackhole_output(struct sk_buff *skb)
+{
+	kfree_skb(skb);
+	return 0;
+}
+
+static int ipv4_dst_blackhole(struct rtable **rp, struct flowi *flp, struct sock *sk)
+{
+	struct rtable *ort = *rp;
+	struct rtable *rt = (struct rtable *)
+		dst_alloc(&ipv4_dst_blackhole_ops);
+
+	if (rt) {
+		struct dst_entry *new = &rt->u.dst;
+
+		atomic_set(&new->__refcnt, 1);
+		new->__use = 1;
+		new->input = ipv4_blackhole_output;
+		new->output = ipv4_blackhole_output;
+		memcpy(new->metrics, ort->u.dst.metrics, RTAX_MAX*sizeof(u32));
+
+		new->dev = ort->u.dst.dev;
+		if (new->dev)
+			dev_hold(new->dev);
+
+		rt->fl = ort->fl;
+
+		rt->idev = ort->idev;
+		if (rt->idev)
+			in_dev_hold(rt->idev);
+		rt->rt_flags = ort->rt_flags;
+		rt->rt_type = ort->rt_type;
+		rt->rt_dst = ort->rt_dst;
+		rt->rt_src = ort->rt_src;
+		rt->rt_iif = ort->rt_iif;
+		rt->rt_gateway = ort->rt_gateway;
+		rt->rt_spec_dst = ort->rt_spec_dst;
+		rt->peer = ort->peer;
+		if (rt->peer)
+			atomic_inc(&rt->peer->refcnt);
+
+		dst_free(new);
+	}
+
+	dst_release(&(*rp)->u.dst);
+	*rp = rt;
+	return (rt ? 0 : -ENOMEM);
+}
+
 int ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags)
 {
 	int err;
@@ -2610,7 +2673,11 @@ int ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk,
 			flp->fl4_src = (*rp)->rt_src;
 		if (!flp->fl4_dst)
 			flp->fl4_dst = (*rp)->rt_dst;
-		return xfrm_lookup((struct dst_entry **)rp, flp, sk, flags);
+		err = __xfrm_lookup((struct dst_entry **)rp, flp, sk, flags);
+		if (err == -EREMOTE)
+			err = ipv4_dst_blackhole(rp, flp, sk);
+
+		return err;
 	}
 
 	return 0;
@@ -3139,6 +3206,8 @@ int __init ip_rt_init(void)
 		kmem_cache_create("ip_dst_cache", sizeof(struct rtable), 0,
 				  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL, NULL);
 
+	ipv4_dst_blackhole_ops.kmem_cachep = ipv4_dst_ops.kmem_cachep;
+
 	rt_hash_table = (struct rt_hash_bucket *)
 		alloc_large_system_hash("IP route cache",
 					sizeof(struct rt_hash_bucket),
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 7641b27..38cb25b 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -1501,6 +1501,8 @@ void tcp_enter_loss(struct sock *sk, int how)
 	tcp_set_ca_state(sk, TCP_CA_Loss);
 	tp->high_seq = tp->snd_nxt;
 	TCP_ECN_queue_cwr(tp);
+	/* Abort FRTO algorithm if one is in progress */
+	tp->frto_counter = 0;
 
 	clear_all_retrans_hints(tp);
 }
@@ -2608,6 +2610,7 @@ static void tcp_conservative_spur_to_response(struct tcp_sock *tp)
 {
 	tp->snd_cwnd = min(tp->snd_cwnd, tp->snd_ssthresh);
 	tp->snd_cwnd_cnt = 0;
+	TCP_ECN_queue_cwr(tp);
 	tcp_moderate_cwnd(tp);
 }
 
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index c7ea248..329de67 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -2154,15 +2154,6 @@ static void addrconf_dev_config(struct net_device *dev)
 
 	ASSERT_RTNL();
 
-	if ((dev->type != ARPHRD_ETHER) &&
-	    (dev->type != ARPHRD_FDDI) &&
-	    (dev->type != ARPHRD_IEEE802_TR) &&
-	    (dev->type != ARPHRD_ARCNET) &&
-	    (dev->type != ARPHRD_INFINIBAND)) {
-		/* Alas, we support only Ethernet autoconfiguration. */
-		return;
-	}
-
 	idev = addrconf_add_dev(dev);
 	if (idev == NULL)
 		return;
@@ -2250,13 +2241,33 @@ static void addrconf_ip6_tnl_config(struct net_device *dev)
 	ip6_tnl_add_linklocal(idev);
 }
 
+static int ipv6_hwtype(struct net_device *dev)
+{
+	if ((dev->type == ARPHRD_ETHER) ||
+	    (dev->type == ARPHRD_LOOPBACK) ||
+	    (dev->type == ARPHRD_SIT) ||
+	    (dev->type == ARPHRD_TUNNEL6) ||
+	    (dev->type == ARPHRD_FDDI) ||
+	    (dev->type == ARPHRD_IEEE802_TR) ||
+	    (dev->type == ARPHRD_ARCNET) ||
+	    (dev->type == ARPHRD_INFINIBAND))
+		return 1;
+
+	return 0;
+}
+
 static int addrconf_notify(struct notifier_block *this, unsigned long event,
 			   void * data)
 {
 	struct net_device *dev = (struct net_device *) data;
-	struct inet6_dev *idev = __in6_dev_get(dev);
+	struct inet6_dev *idev;
 	int run_pending = 0;
 
+	if (!ipv6_hwtype(dev))
+		return NOTIFY_OK;
+
+	idev = __in6_dev_get(dev);
+
 	switch(event) {
 	case NETDEV_REGISTER:
 		if (!idev) {
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 403eee6..b1fe7ac 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -177,8 +177,12 @@ ipv4_connected:
 	if (final_p)
 		ipv6_addr_copy(&fl.fl6_dst, final_p);
 
-	if ((err = xfrm_lookup(&dst, &fl, sk, 1)) < 0)
-		goto out;
+	if ((err = __xfrm_lookup(&dst, &fl, sk, 1)) < 0) {
+		if (err == -EREMOTE)
+			err = ip6_dst_blackhole(sk, &dst, &fl);
+		if (err < 0)
+			goto out;
+	}
 
 	/* source address lookup done in ip6_dst_lookup */
 
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index 009a104..a58459a 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -818,8 +818,12 @@ static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
 	if (final_p)
 		ipv6_addr_copy(&fl.fl6_dst, final_p);
 
-	if ((err = xfrm_lookup(&dst, &fl, sk, 1)) < 0)
-		goto out;
+	if ((err = __xfrm_lookup(&dst, &fl, sk, 1)) < 0) {
+		if (err == -EREMOTE)
+			err = ip6_dst_blackhole(sk, &dst, &fl);
+		if (err < 0)
+			goto out;
+	}
 
 	if (hlimit < 0) {
 		if (ipv6_addr_is_multicast(&fl.fl6_dst))
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index b46ad53..1324b06 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -119,6 +119,19 @@ static struct dst_ops ip6_dst_ops = {
 	.entry_size		=	sizeof(struct rt6_info),
 };
 
+static void ip6_rt_blackhole_update_pmtu(struct dst_entry *dst, u32 mtu)
+{
+}
+
+static struct dst_ops ip6_dst_blackhole_ops = {
+	.family			=	AF_INET6,
+	.protocol		=	__constant_htons(ETH_P_IPV6),
+	.destroy		=	ip6_dst_destroy,
+	.check			=	ip6_dst_check,
+	.update_pmtu		=	ip6_rt_blackhole_update_pmtu,
+	.entry_size		=	sizeof(struct rt6_info),
+};
+
 struct rt6_info ip6_null_entry = {
 	.u = {
 		.dst = {
@@ -833,6 +846,54 @@ struct dst_entry * ip6_route_output(struct sock *sk, struct flowi *fl)
 
 EXPORT_SYMBOL(ip6_route_output);
 
+static int ip6_blackhole_output(struct sk_buff *skb)
+{
+	kfree_skb(skb);
+	return 0;
+}
+
+int ip6_dst_blackhole(struct sock *sk, struct dst_entry **dstp, struct flowi *fl)
+{
+	struct rt6_info *ort = (struct rt6_info *) *dstp;
+	struct rt6_info *rt = (struct rt6_info *)
+		dst_alloc(&ip6_dst_blackhole_ops);
+	struct dst_entry *new = NULL;
+
+	if (rt) {
+		new = &rt->u.dst;
+
+		atomic_set(&new->__refcnt, 1);
+		new->__use = 1;
+		new->input = ip6_blackhole_output;
+		new->output = ip6_blackhole_output;
+
+		memcpy(new->metrics, ort->u.dst.metrics, RTAX_MAX*sizeof(u32));
+		new->dev = ort->u.dst.dev;
+		if (new->dev)
+			dev_hold(new->dev);
+		rt->rt6i_idev = ort->rt6i_idev;
+		if (rt->rt6i_idev)
+			in6_dev_hold(rt->rt6i_idev);
+		rt->rt6i_expires = 0;
+
+		ipv6_addr_copy(&rt->rt6i_gateway, &ort->rt6i_gateway);
+		rt->rt6i_flags = ort->rt6i_flags & ~RTF_EXPIRES;
+		rt->rt6i_metric = 0;
+
+		memcpy(&rt->rt6i_dst, &ort->rt6i_dst, sizeof(struct rt6key));
+#ifdef CONFIG_IPV6_SUBTREES
+		memcpy(&rt->rt6i_src, &ort->rt6i_src, sizeof(struct rt6key));
+#endif
+
+		dst_free(new);
+	}
+
+	dst_release(*dstp);
+	*dstp = new;
+	return (new ? 0 : -ENOMEM);
+}
+EXPORT_SYMBOL_GPL(ip6_dst_blackhole);
+
 /*
  *	Destination cache support functions
  */
@@ -2495,6 +2556,8 @@ void __init ip6_route_init(void)
 	ip6_dst_ops.kmem_cachep =
 		kmem_cache_create("ip6_dst_cache", sizeof(struct rt6_info), 0,
 				  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL, NULL);
+	ip6_dst_blackhole_ops.kmem_cachep = ip6_dst_ops.kmem_cachep;
+
 	fib6_init();
 #ifdef 	CONFIG_PROC_FS
 	p = proc_net_create("ipv6_route", 0, rt6_proc_info);
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index e2f25ea..4f06a51 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -265,8 +265,12 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
 	if (final_p)
 		ipv6_addr_copy(&fl.fl6_dst, final_p);
 
-	if ((err = xfrm_lookup(&dst, &fl, sk, 1)) < 0)
-		goto failure;
+	if ((err = __xfrm_lookup(&dst, &fl, sk, 1)) < 0) {
+		if (err == -EREMOTE)
+			err = ip6_dst_blackhole(sk, &dst, &fl);
+		if (err < 0)
+			goto failure;
+	}
 
 	if (saddr == NULL) {
 		saddr = &fl.fl6_src;
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index a7ae59c..d1fbddd 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -767,8 +767,12 @@ do_udp_sendmsg:
 	if (final_p)
 		ipv6_addr_copy(&fl.fl6_dst, final_p);
 
-	if ((err = xfrm_lookup(&dst, &fl, sk, 1)) < 0)
-		goto out;
+	if ((err = __xfrm_lookup(&dst, &fl, sk, 1)) < 0) {
+		if (err == -EREMOTE)
+			err = ip6_dst_blackhole(sk, &dst, &fl);
+		if (err < 0)
+			goto out;
+	}
 
 	if (hlimit < 0) {
 		if (ipv6_addr_is_multicast(&fl.fl6_dst))
diff --git a/net/key/af_key.c b/net/key/af_key.c
index a994441..d302dda 100644
--- a/net/key/af_key.c
+++ b/net/key/af_key.c
@@ -1448,8 +1448,6 @@ static int pfkey_add(struct sock *sk, struct sk_buff *skb, struct sadb_msg *hdr,
 	int err;
 	struct km_event c;
 
-	xfrm_probe_algs();
-
 	x = pfkey_msg2xfrm_state(hdr, ext_hdrs);
 	if (IS_ERR(x))
 		return PTR_ERR(x);
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index e8b5c2d..483e927 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -298,7 +298,6 @@ static void
 destroy_conntrack(struct nf_conntrack *nfct)
 {
 	struct nf_conn *ct = (struct nf_conn *)nfct;
-	struct nf_conn_help *help = nfct_help(ct);
 	struct nf_conntrack_l4proto *l4proto;
 	typeof(nf_conntrack_destroyed) destroyed;
 
@@ -309,9 +308,6 @@ destroy_conntrack(struct nf_conntrack *nfct)
 	nf_conntrack_event(IPCT_DESTROY, ct);
 	set_bit(IPS_DYING_BIT, &ct->status);
 
-	if (help && help->helper && help->helper->destroy)
-		help->helper->destroy(ct);
-
 	/* To make sure we don't get any weird locking issues here:
 	 * destroy_conntrack() MUST NOT be called with a write lock
 	 * to nf_conntrack_lock!!! -HW */
@@ -353,6 +349,10 @@ destroy_conntrack(struct nf_conntrack *nfct)
 static void death_by_timeout(unsigned long ul_conntrack)
 {
 	struct nf_conn *ct = (void *)ul_conntrack;
+	struct nf_conn_help *help = nfct_help(ct);
+
+	if (help && help->helper && help->helper->destroy)
+		help->helper->destroy(ct);
 
 	write_lock_bh(&nf_conntrack_lock);
 	/* Inside lock so preempt is disabled on module removal path.
diff --git a/net/netfilter/nf_conntrack_ftp.c b/net/netfilter/nf_conntrack_ftp.c
index a186799..82db2aa 100644
--- a/net/netfilter/nf_conntrack_ftp.c
+++ b/net/netfilter/nf_conntrack_ftp.c
@@ -48,8 +48,7 @@ unsigned int (*nf_nat_ftp_hook)(struct sk_buff **pskb,
 				enum nf_ct_ftp_type type,
 				unsigned int matchoff,
 				unsigned int matchlen,
-				struct nf_conntrack_expect *exp,
-				u32 *seq);
+				struct nf_conntrack_expect *exp);
 EXPORT_SYMBOL_GPL(nf_nat_ftp_hook);
 
 #if 0
@@ -335,15 +334,17 @@ static void update_nl_seq(u32 nl_seq, struct nf_ct_ftp_master *info, int dir,
 		if (info->seq_aft_nl[dir][i] == nl_seq)
 			return;
 
-		if (oldest == info->seq_aft_nl_num[dir]
-		    || before(info->seq_aft_nl[dir][i], oldest))
+		if (oldest == info->seq_aft_nl_num[dir] ||
+		    before(info->seq_aft_nl[dir][i],
+			   info->seq_aft_nl[dir][oldest]))
 			oldest = i;
 	}
 
 	if (info->seq_aft_nl_num[dir] < NUM_SEQ_TO_REMEMBER) {
 		info->seq_aft_nl[dir][info->seq_aft_nl_num[dir]++] = nl_seq;
 		nf_conntrack_event_cache(IPCT_HELPINFO_VOLATILE, skb);
-	} else if (oldest != NUM_SEQ_TO_REMEMBER) {
+	} else if (oldest != NUM_SEQ_TO_REMEMBER &&
+		   after(nl_seq, info->seq_aft_nl[dir][oldest])) {
 		info->seq_aft_nl[dir][oldest] = nl_seq;
 		nf_conntrack_event_cache(IPCT_HELPINFO_VOLATILE, skb);
 	}
@@ -519,7 +520,7 @@ static int help(struct sk_buff **pskb,
 	nf_nat_ftp = rcu_dereference(nf_nat_ftp_hook);
 	if (nf_nat_ftp && ct->status & IPS_NAT_MASK)
 		ret = nf_nat_ftp(pskb, ctinfo, search[dir][i].ftptype,
-				 matchoff, matchlen, exp, &seq);
+				 matchoff, matchlen, exp);
 	else {
 		/* Can't expect this?  Best to drop packet now. */
 		if (nf_conntrack_expect_related(exp) != 0)
diff --git a/net/netfilter/nf_conntrack_h323_main.c b/net/netfilter/nf_conntrack_h323_main.c
index b284db7..a1b95ac 100644
--- a/net/netfilter/nf_conntrack_h323_main.c
+++ b/net/netfilter/nf_conntrack_h323_main.c
@@ -520,6 +520,16 @@ static int process_olca(struct sk_buff **pskb, struct nf_conn *ct,
 		}
 	}
 
+	if ((olca->options & eOpenLogicalChannelAck_separateStack) &&
+		olca->separateStack.networkAddress.choice ==
+		eNetworkAccessParameters_networkAddress_localAreaAddress) {
+		ret = expect_t120(pskb, ct, ctinfo, data, dataoff,
+				  &olca->separateStack.networkAddress.
+				  localAreaAddress);
+		if (ret < 0)
+			return -1;
+	}
+
 	return 0;
 }
 
@@ -640,7 +650,7 @@ int get_h225_addr(struct nf_conn *ct, unsigned char *data,
 	case eTransportAddress_ip6Address:
 		if (family != AF_INET6)
 			return 0;
-		p = data + taddr->ip6Address.ip6;
+		p = data + taddr->ip6Address.ip;
 		len = 16;
 		break;
 	default:
@@ -977,30 +987,6 @@ static int process_alerting(struct sk_buff **pskb, struct nf_conn *ct,
 }
 
 /****************************************************************************/
-static int process_information(struct sk_buff **pskb,
-			       struct nf_conn *ct,
-			       enum ip_conntrack_info ctinfo,
-			       unsigned char **data, int dataoff,
-			       Information_UUIE *info)
-{
-	int ret;
-	int i;
-
-	DEBUGP("nf_ct_q931: Information\n");
-
-	if (info->options & eInformation_UUIE_fastStart) {
-		for (i = 0; i < info->fastStart.count; i++) {
-			ret = process_olc(pskb, ct, ctinfo, data, dataoff,
-					  &info->fastStart.item[i]);
-			if (ret < 0)
-				return -1;
-		}
-	}
-
-	return 0;
-}
-
-/****************************************************************************/
 static int process_facility(struct sk_buff **pskb, struct nf_conn *ct,
 			    enum ip_conntrack_info ctinfo,
 			    unsigned char **data, int dataoff,
@@ -1096,11 +1082,6 @@ static int process_q931(struct sk_buff **pskb, struct nf_conn *ct,
 		ret = process_alerting(pskb, ct, ctinfo, data, dataoff,
 				       &pdu->h323_message_body.alerting);
 		break;
-	case eH323_UU_PDU_h323_message_body_information:
-		ret = process_information(pskb, ct, ctinfo, data, dataoff,
-					  &pdu->h323_message_body.
-					  information);
-		break;
 	case eH323_UU_PDU_h323_message_body_facility:
 		ret = process_facility(pskb, ct, ctinfo, data, dataoff,
 				       &pdu->h323_message_body.facility);
diff --git a/net/netfilter/nf_conntrack_h323_types.c b/net/netfilter/nf_conntrack_h323_types.c
index 4c6f8b3..3a21fdf 100644
--- a/net/netfilter/nf_conntrack_h323_types.c
+++ b/net/netfilter/nf_conntrack_h323_types.c
@@ -1,4 +1,4 @@
-/* Generated by Jing Min Zhao's ASN.1 parser, Apr 20 2006
+/* Generated by Jing Min Zhao's ASN.1 parser, May 16 2007
  *
  * Copyright (c) 2006 Jing Min Zhao <zhaojingmin@users.sourceforge.net>
  *
@@ -37,7 +37,7 @@ static field_t _TransportAddress_ipxAddress[] = {	/* SEQUENCE */
 
 static field_t _TransportAddress_ip6Address[] = {	/* SEQUENCE */
 	{FNAME("ip") OCTSTR, FIXD, 16, 0, DECODE,
-	 offsetof(TransportAddress_ip6Address, ip6), NULL},
+	 offsetof(TransportAddress_ip6Address, ip), NULL},
 	{FNAME("port") INT, WORD, 0, 0, SKIP, 0, NULL},
 };
 
@@ -67,7 +67,8 @@ static field_t _TransportAddress[] = {	/* CHOICE */
 	{FNAME("ipxAddress") SEQ, 0, 3, 3, SKIP, 0,
 	 _TransportAddress_ipxAddress},
 	{FNAME("ip6Address") SEQ, 0, 2, 2, DECODE | EXT,
-	offsetof(TransportAddress, ip6Address), _TransportAddress_ip6Address},
+	 offsetof(TransportAddress, ip6Address),
+	 _TransportAddress_ip6Address},
 	{FNAME("netBios") OCTSTR, FIXD, 16, 0, SKIP, 0, NULL},
 	{FNAME("nsap") OCTSTR, 5, 1, 0, SKIP, 0, NULL},
 	{FNAME("nonStandardAddress") SEQ, 0, 2, 2, SKIP, 0,
@@ -638,7 +639,8 @@ static field_t _UnicastAddress_iPXAddress[] = {	/* SEQUENCE */
 };
 
 static field_t _UnicastAddress_iP6Address[] = {	/* SEQUENCE */
-	{FNAME("network") OCTSTR, FIXD, 16, 0, SKIP, 0, NULL},
+	{FNAME("network") OCTSTR, FIXD, 16, 0, DECODE,
+	 offsetof(UnicastAddress_iP6Address, network), NULL},
 	{FNAME("tsapIdentifier") INT, WORD, 0, 0, SKIP, 0, NULL},
 };
 
@@ -665,8 +667,8 @@ static field_t _UnicastAddress[] = {	/* CHOICE */
 	 offsetof(UnicastAddress, iPAddress), _UnicastAddress_iPAddress},
 	{FNAME("iPXAddress") SEQ, 0, 3, 3, SKIP | EXT, 0,
 	 _UnicastAddress_iPXAddress},
-	{FNAME("iP6Address") SEQ, 0, 2, 2, SKIP | EXT, 0,
-	 _UnicastAddress_iP6Address},
+	{FNAME("iP6Address") SEQ, 0, 2, 2, DECODE | EXT,
+	 offsetof(UnicastAddress, iP6Address), _UnicastAddress_iP6Address},
 	{FNAME("netBios") OCTSTR, FIXD, 16, 0, SKIP, 0, NULL},
 	{FNAME("iPSourceRouteAddress") SEQ, 0, 4, 4, SKIP | EXT, 0,
 	 _UnicastAddress_iPSourceRouteAddress},
@@ -984,19 +986,12 @@ static field_t _Alerting_UUIE[] = {	/* SEQUENCE */
 	{FNAME("featureSet") SEQ, 3, 4, 4, SKIP | EXT | OPT, 0, NULL},
 };
 
-static field_t _Information_UUIE_fastStart[] = {	/* SEQUENCE OF */
-	{FNAME("item") SEQ, 1, 3, 5, DECODE | OPEN | EXT,
-	 sizeof(OpenLogicalChannel), _OpenLogicalChannel}
-	,
-};
-
 static field_t _Information_UUIE[] = {	/* SEQUENCE */
 	{FNAME("protocolIdentifier") OID, BYTE, 0, 0, SKIP, 0, NULL},
 	{FNAME("callIdentifier") SEQ, 0, 1, 1, SKIP | EXT, 0, NULL},
 	{FNAME("tokens") SEQOF, SEMI, 0, 0, SKIP | OPT, 0, NULL},
 	{FNAME("cryptoTokens") SEQOF, SEMI, 0, 0, SKIP | OPT, 0, NULL},
-	{FNAME("fastStart") SEQOF, SEMI, 0, 30, DECODE | OPT,
-	 offsetof(Information_UUIE, fastStart), _Information_UUIE_fastStart},
+	{FNAME("fastStart") SEQOF, SEMI, 0, 30, SKIP | OPT, 0, NULL},
 	{FNAME("fastConnectRefused") NUL, FIXD, 0, 0, SKIP | OPT, 0, NULL},
 	{FNAME("circuitInfo") SEQ, 3, 3, 3, SKIP | EXT | OPT, 0, NULL},
 };
@@ -1343,9 +1338,7 @@ static field_t _H323_UU_PDU_h323_message_body[] = {	/* CHOICE */
 	 offsetof(H323_UU_PDU_h323_message_body, connect), _Connect_UUIE},
 	{FNAME("alerting") SEQ, 1, 3, 17, DECODE | EXT,
 	 offsetof(H323_UU_PDU_h323_message_body, alerting), _Alerting_UUIE},
-	{FNAME("information") SEQ, 0, 1, 7, DECODE | EXT,
-	 offsetof(H323_UU_PDU_h323_message_body, information),
-	 _Information_UUIE},
+	{FNAME("information") SEQ, 0, 1, 7, SKIP | EXT, 0, _Information_UUIE},
 	{FNAME("releaseComplete") SEQ, 1, 2, 11, SKIP | EXT, 0,
 	 _ReleaseComplete_UUIE},
 	{FNAME("facility") SEQ, 3, 5, 21, DECODE | EXT,
@@ -1430,7 +1423,9 @@ static field_t _OpenLogicalChannelAck[] = {	/* SEQUENCE */
 	 DECODE | EXT | OPT, offsetof(OpenLogicalChannelAck,
 				      reverseLogicalChannelParameters),
 	 _OpenLogicalChannelAck_reverseLogicalChannelParameters},
-	{FNAME("separateStack") SEQ, 2, 4, 5, SKIP | EXT | OPT, 0, NULL},
+	{FNAME("separateStack") SEQ, 2, 4, 5, DECODE | EXT | OPT,
+	 offsetof(OpenLogicalChannelAck, separateStack),
+	 _NetworkAccessParameters},
 	{FNAME("forwardMultiplexAckParameters") CHOICE, 0, 1, 1,
 	 DECODE | EXT | OPT, offsetof(OpenLogicalChannelAck,
 				      forwardMultiplexAckParameters),
diff --git a/net/rfkill/rfkill.c b/net/rfkill/rfkill.c
index a973603..f3986d4 100644
--- a/net/rfkill/rfkill.c
+++ b/net/rfkill/rfkill.c
@@ -296,7 +296,7 @@ struct rfkill *rfkill_allocate(struct device *parent, enum rfkill_type type)
 	struct device *dev;
 
 	rfkill = kzalloc(sizeof(struct rfkill), GFP_KERNEL);
-	if (rfkill)
+	if (!rfkill)
 		return NULL;
 
 	mutex_init(&rfkill->mutex);
diff --git a/net/rxrpc/Kconfig b/net/rxrpc/Kconfig
index 91b3d52..e662f1d 100644
--- a/net/rxrpc/Kconfig
+++ b/net/rxrpc/Kconfig
@@ -4,7 +4,7 @@
 
 config AF_RXRPC
 	tristate "RxRPC session sockets"
-	depends on EXPERIMENTAL
+	depends on INET && EXPERIMENTAL
 	select KEYS
 	help
 	  Say Y or M here to include support for RxRPC session sockets (just
diff --git a/net/rxrpc/ar-call.c b/net/rxrpc/ar-call.c
index 4d92d88..3c04b00 100644
--- a/net/rxrpc/ar-call.c
+++ b/net/rxrpc/ar-call.c
@@ -15,6 +15,25 @@
 #include <net/af_rxrpc.h>
 #include "ar-internal.h"
 
+const char *rxrpc_call_states[] = {
+	[RXRPC_CALL_CLIENT_SEND_REQUEST]	= "ClSndReq",
+	[RXRPC_CALL_CLIENT_AWAIT_REPLY]		= "ClAwtRpl",
+	[RXRPC_CALL_CLIENT_RECV_REPLY]		= "ClRcvRpl",
+	[RXRPC_CALL_CLIENT_FINAL_ACK]		= "ClFnlACK",
+	[RXRPC_CALL_SERVER_SECURING]		= "SvSecure",
+	[RXRPC_CALL_SERVER_ACCEPTING]		= "SvAccept",
+	[RXRPC_CALL_SERVER_RECV_REQUEST]	= "SvRcvReq",
+	[RXRPC_CALL_SERVER_ACK_REQUEST]		= "SvAckReq",
+	[RXRPC_CALL_SERVER_SEND_REPLY]		= "SvSndRpl",
+	[RXRPC_CALL_SERVER_AWAIT_ACK]		= "SvAwtACK",
+	[RXRPC_CALL_COMPLETE]			= "Complete",
+	[RXRPC_CALL_SERVER_BUSY]		= "SvBusy  ",
+	[RXRPC_CALL_REMOTELY_ABORTED]		= "RmtAbort",
+	[RXRPC_CALL_LOCALLY_ABORTED]		= "LocAbort",
+	[RXRPC_CALL_NETWORK_ERROR]		= "NetError",
+	[RXRPC_CALL_DEAD]			= "Dead    ",
+};
+
 struct kmem_cache *rxrpc_call_jar;
 LIST_HEAD(rxrpc_calls);
 DEFINE_RWLOCK(rxrpc_call_lock);
diff --git a/net/rxrpc/ar-proc.c b/net/rxrpc/ar-proc.c
index 58f4b4e..1c0be0e 100644
--- a/net/rxrpc/ar-proc.c
+++ b/net/rxrpc/ar-proc.c
@@ -25,25 +25,6 @@ static const char *rxrpc_conn_states[] = {
 	[RXRPC_CONN_NETWORK_ERROR]	= "NetError",
 };
 
-const char *rxrpc_call_states[] = {
-	[RXRPC_CALL_CLIENT_SEND_REQUEST]	= "ClSndReq",
-	[RXRPC_CALL_CLIENT_AWAIT_REPLY]		= "ClAwtRpl",
-	[RXRPC_CALL_CLIENT_RECV_REPLY]		= "ClRcvRpl",
-	[RXRPC_CALL_CLIENT_FINAL_ACK]		= "ClFnlACK",
-	[RXRPC_CALL_SERVER_SECURING]		= "SvSecure",
-	[RXRPC_CALL_SERVER_ACCEPTING]		= "SvAccept",
-	[RXRPC_CALL_SERVER_RECV_REQUEST]	= "SvRcvReq",
-	[RXRPC_CALL_SERVER_ACK_REQUEST]		= "SvAckReq",
-	[RXRPC_CALL_SERVER_SEND_REPLY]		= "SvSndRpl",
-	[RXRPC_CALL_SERVER_AWAIT_ACK]		= "SvAwtACK",
-	[RXRPC_CALL_COMPLETE]			= "Complete",
-	[RXRPC_CALL_SERVER_BUSY]		= "SvBusy  ",
-	[RXRPC_CALL_REMOTELY_ABORTED]		= "RmtAbort",
-	[RXRPC_CALL_LOCALLY_ABORTED]		= "LocAbort",
-	[RXRPC_CALL_NETWORK_ERROR]		= "NetError",
-	[RXRPC_CALL_DEAD]			= "Dead    ",
-};
-
 /*
  * generate a list of extant and dead calls in /proc/net/rxrpc_calls
  */
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index f28bb2d..cbefe22 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -169,8 +169,8 @@ requeue:
 		else
 			q->ops->requeue(skb, q);
 		netif_schedule(dev);
-		return 0;
 	}
+	return 0;
 
 out:
 	BUG_ON((int) q->q.qlen < 0);
diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c
index 99bcec8..035788c 100644
--- a/net/sched/sch_htb.c
+++ b/net/sched/sch_htb.c
@@ -976,8 +976,9 @@ static struct sk_buff *htb_dequeue(struct Qdisc *sch)
 
 		if (q->now >= q->near_ev_cache[level]) {
 			event = htb_do_events(q, level);
-			q->near_ev_cache[level] = event ? event :
-							  PSCHED_TICKS_PER_SEC;
+			if (!event)
+				event = q->now + PSCHED_TICKS_PER_SEC;
+			q->near_ev_cache[level] = event;
 		} else
 			event = q->near_ev_cache[level];
 
diff --git a/net/sctp/Kconfig b/net/sctp/Kconfig
index 9cba49e..8210f54 100644
--- a/net/sctp/Kconfig
+++ b/net/sctp/Kconfig
@@ -2,11 +2,9 @@
 # SCTP configuration
 #
 
-menu "SCTP Configuration (EXPERIMENTAL)"
-	depends on INET && EXPERIMENTAL
-
-config IP_SCTP
+menuconfig IP_SCTP
 	tristate "The SCTP Protocol (EXPERIMENTAL)"
+	depends on INET && EXPERIMENTAL
 	depends on IPV6 || IPV6=n
 	select CRYPTO if SCTP_HMAC_SHA1 || SCTP_HMAC_MD5
 	select CRYPTO_HMAC if SCTP_HMAC_SHA1 || SCTP_HMAC_MD5
@@ -36,9 +34,10 @@ config IP_SCTP
 
 	  If in doubt, say N.
 
+if IP_SCTP
+
 config SCTP_DBG_MSG
 	bool "SCTP: Debug messages"
-	depends on IP_SCTP
 	help
 	  If you say Y, this will enable verbose debugging messages. 
 
@@ -47,7 +46,6 @@ config SCTP_DBG_MSG
 
 config SCTP_DBG_OBJCNT
 	bool "SCTP: Debug object counts"
-	depends on IP_SCTP
 	help
 	  If you say Y, this will enable debugging support for counting the 
 	  type of objects that are currently allocated.  This is useful for 
@@ -59,7 +57,6 @@ config SCTP_DBG_OBJCNT
 
 choice
 	prompt "SCTP: Cookie HMAC Algorithm"
-	depends on IP_SCTP
 	default SCTP_HMAC_MD5
 	help
 	  HMAC algorithm to be used during association initialization.  It
@@ -86,4 +83,5 @@ config SCTP_HMAC_MD5
 	  advised to use either HMAC-MD5 or HMAC-SHA1.
 
 endchoice
-endmenu
+
+endif # IP_SCTP
diff --git a/net/tipc/Kconfig b/net/tipc/Kconfig
index f9e367d..3b30d11 100644
--- a/net/tipc/Kconfig
+++ b/net/tipc/Kconfig
@@ -2,11 +2,9 @@
 # TIPC configuration
 #
 
-menu "TIPC Configuration (EXPERIMENTAL)"
-	depends on INET && EXPERIMENTAL
-
-config TIPC
+menuconfig TIPC
 	tristate "The TIPC Protocol (EXPERIMENTAL)"
+	depends on INET && EXPERIMENTAL
 	---help---
 	  The Transparent Inter Process Communication (TIPC) protocol is
 	  specially designed for intra cluster communication. This protocol
@@ -22,9 +20,10 @@ config TIPC
 
 	  If in doubt, say N.
 
+if TIPC
+
 config TIPC_ADVANCED
 	bool "TIPC: Advanced configuration"
-	depends on TIPC
 	default n
 	help
 	  Saying Y here will open some advanced configuration
@@ -33,7 +32,7 @@ config TIPC_ADVANCED
 
 config TIPC_ZONES
 	int "Maximum number of zones in network"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
 	default "3"
 	help
 	 Max number of zones inside TIPC network. Max supported value 
@@ -44,7 +43,7 @@ config TIPC_ZONES
 
 config TIPC_CLUSTERS
 	int "Maximum number of clusters in a zone"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
 	default "1"
 	help
           ***Only 1 (one cluster in a zone) is supported by current code.
@@ -59,7 +58,7 @@ config TIPC_CLUSTERS
 
 config TIPC_NODES
 	int "Maximum number of nodes in cluster"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
 	default "255"
 	help
 	  Maximum number of nodes inside a TIPC cluster. Maximum 
@@ -70,7 +69,7 @@ config TIPC_NODES
 
 config TIPC_SLAVE_NODES
 	int "Maximum number of slave nodes in cluster"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
 	default "0"
 	help
           ***This capability is not supported by current code.***
@@ -83,7 +82,7 @@ config TIPC_SLAVE_NODES
 
 config TIPC_PORTS
 	int "Maximum number of ports in a node"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
 	default "8191"
 	help
 	  Maximum number of ports within a node. Maximum 
@@ -94,7 +93,7 @@ config TIPC_PORTS
 
 config TIPC_LOG
 	int "Size of log buffer"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
 	default 0
 	help
  	  Size (in bytes) of TIPC's internal log buffer, which records the
@@ -106,7 +105,6 @@ config TIPC_LOG
 
 config TIPC_DEBUG
 	bool "Enable debugging support"
-	depends on TIPC
 	default n
 	help
  	  This will enable debugging of TIPC.
@@ -114,4 +112,4 @@ config TIPC_DEBUG
 	  Only say Y here if you are having trouble with TIPC.  It will
 	  enable the display of detailed information about what is going on.
 
-endmenu
+endif # TIPC
diff --git a/net/tipc/eth_media.c b/net/tipc/eth_media.c
index 0ee6ded..77d2d9c 100644
--- a/net/tipc/eth_media.c
+++ b/net/tipc/eth_media.c
@@ -120,18 +120,20 @@ static int recv_msg(struct sk_buff *buf, struct net_device *dev,
 
 static int enable_bearer(struct tipc_bearer *tb_ptr)
 {
-	struct net_device *dev, *pdev;
+	struct net_device *dev = NULL;
+	struct net_device *pdev = NULL;
 	struct eth_bearer *eb_ptr = &eth_bearers[0];
 	struct eth_bearer *stop = &eth_bearers[MAX_ETH_BEARERS];
 	char *driver_name = strchr((const char *)tb_ptr->name, ':') + 1;
 
 	/* Find device with specified name */
-	dev = NULL;
-	for_each_netdev(pdev)
-		if (!strncmp(dev->name, driver_name, IFNAMSIZ)) {
+
+	for_each_netdev(pdev){
+		if (!strncmp(pdev->name, driver_name, IFNAMSIZ)) {
 			dev = pdev;
 			break;
 		}
+	}
 	if (!dev)
 		return -ENODEV;
 
diff --git a/net/xfrm/xfrm_algo.c b/net/xfrm/xfrm_algo.c
index 6249a94..5ced62c 100644
--- a/net/xfrm/xfrm_algo.c
+++ b/net/xfrm/xfrm_algo.c
@@ -347,67 +347,44 @@ static inline int calg_entries(void)
 	return ARRAY_SIZE(calg_list);
 }
 
-/* Todo: generic iterators */
-struct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id)
-{
-	int i;
-
-	for (i = 0; i < aalg_entries(); i++) {
-		if (aalg_list[i].desc.sadb_alg_id == alg_id) {
-			if (aalg_list[i].available)
-				return &aalg_list[i];
-			else
-				break;
-		}
-	}
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(xfrm_aalg_get_byid);
-
-struct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id)
-{
-	int i;
+struct xfrm_algo_list {
+	struct xfrm_algo_desc *algs;
+	int entries;
+	u32 type;
+	u32 mask;
+};
 
-	for (i = 0; i < ealg_entries(); i++) {
-		if (ealg_list[i].desc.sadb_alg_id == alg_id) {
-			if (ealg_list[i].available)
-				return &ealg_list[i];
-			else
-				break;
-		}
-	}
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(xfrm_ealg_get_byid);
+static const struct xfrm_algo_list xfrm_aalg_list = {
+	.algs = aalg_list,
+	.entries = ARRAY_SIZE(aalg_list),
+	.type = CRYPTO_ALG_TYPE_HASH,
+	.mask = CRYPTO_ALG_TYPE_HASH_MASK | CRYPTO_ALG_ASYNC,
+};
 
-struct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id)
-{
-	int i;
+static const struct xfrm_algo_list xfrm_ealg_list = {
+	.algs = ealg_list,
+	.entries = ARRAY_SIZE(ealg_list),
+	.type = CRYPTO_ALG_TYPE_BLKCIPHER,
+	.mask = CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC,
+};
 
-	for (i = 0; i < calg_entries(); i++) {
-		if (calg_list[i].desc.sadb_alg_id == alg_id) {
-			if (calg_list[i].available)
-				return &calg_list[i];
-			else
-				break;
-		}
-	}
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(xfrm_calg_get_byid);
+static const struct xfrm_algo_list xfrm_calg_list = {
+	.algs = calg_list,
+	.entries = ARRAY_SIZE(calg_list),
+	.type = CRYPTO_ALG_TYPE_COMPRESS,
+	.mask = CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC,
+};
 
-static struct xfrm_algo_desc *xfrm_get_byname(struct xfrm_algo_desc *list,
-					      int entries, u32 type, u32 mask,
-					      char *name, int probe)
+static struct xfrm_algo_desc *xfrm_find_algo(
+	const struct xfrm_algo_list *algo_list,
+	int match(const struct xfrm_algo_desc *entry, const void *data),
+	const void *data, int probe)
 {
+	struct xfrm_algo_desc *list = algo_list->algs;
 	int i, status;
 
-	if (!name)
-		return NULL;
-
-	for (i = 0; i < entries; i++) {
-		if (strcmp(name, list[i].name) &&
-		    (!list[i].compat || strcmp(name, list[i].compat)))
+	for (i = 0; i < algo_list->entries; i++) {
+		if (!match(list + i, data))
 			continue;
 
 		if (list[i].available)
@@ -416,8 +393,8 @@ static struct xfrm_algo_desc *xfrm_get_byname(struct xfrm_algo_desc *list,
 		if (!probe)
 			break;
 
-		status = crypto_has_alg(list[i].name, type,
-					mask | CRYPTO_ALG_ASYNC);
+		status = crypto_has_alg(list[i].name, algo_list->type,
+					algo_list->mask);
 		if (!status)
 			break;
 
@@ -427,27 +404,60 @@ static struct xfrm_algo_desc *xfrm_get_byname(struct xfrm_algo_desc *list,
 	return NULL;
 }
 
+static int xfrm_alg_id_match(const struct xfrm_algo_desc *entry,
+			     const void *data)
+{
+	return entry->desc.sadb_alg_id == (unsigned long)data;
+}
+
+struct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id)
+{
+	return xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_id_match,
+			      (void *)(unsigned long)alg_id, 1);
+}
+EXPORT_SYMBOL_GPL(xfrm_aalg_get_byid);
+
+struct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id)
+{
+	return xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_id_match,
+			      (void *)(unsigned long)alg_id, 1);
+}
+EXPORT_SYMBOL_GPL(xfrm_ealg_get_byid);
+
+struct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id)
+{
+	return xfrm_find_algo(&xfrm_calg_list, xfrm_alg_id_match,
+			      (void *)(unsigned long)alg_id, 1);
+}
+EXPORT_SYMBOL_GPL(xfrm_calg_get_byid);
+
+static int xfrm_alg_name_match(const struct xfrm_algo_desc *entry,
+			       const void *data)
+{
+	const char *name = data;
+
+	return name && (!strcmp(name, entry->name) ||
+			(entry->compat && !strcmp(name, entry->compat)));
+}
+
 struct xfrm_algo_desc *xfrm_aalg_get_byname(char *name, int probe)
 {
-	return xfrm_get_byname(aalg_list, aalg_entries(),
-			       CRYPTO_ALG_TYPE_HASH, CRYPTO_ALG_TYPE_HASH_MASK,
-			       name, probe);
+	return xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_name_match, name,
+			      probe);
 }
 EXPORT_SYMBOL_GPL(xfrm_aalg_get_byname);
 
 struct xfrm_algo_desc *xfrm_ealg_get_byname(char *name, int probe)
 {
-	return xfrm_get_byname(ealg_list, ealg_entries(),
-			       CRYPTO_ALG_TYPE_BLKCIPHER, CRYPTO_ALG_TYPE_MASK,
-			       name, probe);
+	return xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_name_match, name,
+			      probe);
 }
 EXPORT_SYMBOL_GPL(xfrm_ealg_get_byname);
 
 struct xfrm_algo_desc *xfrm_calg_get_byname(char *name, int probe)
 {
-	return xfrm_get_byname(calg_list, calg_entries(),
-			       CRYPTO_ALG_TYPE_COMPRESS, CRYPTO_ALG_TYPE_MASK,
-			       name, probe);
+	return xfrm_find_algo(&xfrm_calg_list, xfrm_alg_name_match, name,
+			      probe);
 }
 EXPORT_SYMBOL_GPL(xfrm_calg_get_byname);
 
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index d0882e5..b8bab89 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -29,6 +29,8 @@
 
 #include "xfrm_hash.h"
 
+int sysctl_xfrm_larval_drop;
+
 DEFINE_MUTEX(xfrm_cfg_mutex);
 EXPORT_SYMBOL(xfrm_cfg_mutex);
 
@@ -1390,8 +1392,8 @@ static int stale_bundle(struct dst_entry *dst);
  * At the moment we eat a raw IP route. Mostly to speed up lookups
  * on interfaces with disabled IPsec.
  */
-int xfrm_lookup(struct dst_entry **dst_p, struct flowi *fl,
-		struct sock *sk, int flags)
+int __xfrm_lookup(struct dst_entry **dst_p, struct flowi *fl,
+		  struct sock *sk, int flags)
 {
 	struct xfrm_policy *policy;
 	struct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];
@@ -1509,6 +1511,13 @@ restart:
 
 		if (unlikely(nx<0)) {
 			err = nx;
+			if (err == -EAGAIN && sysctl_xfrm_larval_drop) {
+				/* EREMOTE tells the caller to generate
+				 * a one-shot blackhole route.
+				 */
+				xfrm_pol_put(policy);
+				return -EREMOTE;
+			}
 			if (err == -EAGAIN && flags) {
 				DECLARE_WAITQUEUE(wait, current);
 
@@ -1598,6 +1607,21 @@ error:
 	*dst_p = NULL;
 	return err;
 }
+EXPORT_SYMBOL(__xfrm_lookup);
+
+int xfrm_lookup(struct dst_entry **dst_p, struct flowi *fl,
+		struct sock *sk, int flags)
+{
+	int err = __xfrm_lookup(dst_p, fl, sk, flags);
+
+	if (err == -EREMOTE) {
+		dst_release(*dst_p);
+		*dst_p = NULL;
+		err = -EAGAIN;
+	}
+
+	return err;
+}
 EXPORT_SYMBOL(xfrm_lookup);
 
 static inline int
diff --git a/scripts/Makefile.headersinst b/scripts/Makefile.headersinst
index f7b6705..8cd6301 100644
--- a/scripts/Makefile.headersinst
+++ b/scripts/Makefile.headersinst
@@ -144,7 +144,7 @@ $(check-y) : $(INSTALL_HDR_PATH)/$(_dst)/.check.%.h : $(INSTALL_HDR_PATH)/$(_dst
 	$(call cmd,check)
 
 # Other dependencies for $(check-y)
--include /dev/null $(check-y)
+include /dev/null $(wildcard $(check-y))
 
 # ... but leave $(check-y) as .PHONY for now until those deps are actually correct.
 .PHONY: $(check-y)
diff --git a/scripts/kconfig/lxdialog/check-lxdialog.sh b/scripts/kconfig/lxdialog/check-lxdialog.sh
index 120d624..cdca738 100644
--- a/scripts/kconfig/lxdialog/check-lxdialog.sh
+++ b/scripts/kconfig/lxdialog/check-lxdialog.sh
@@ -4,21 +4,15 @@
 # What library to link
 ldflags()
 {
-	$cc -print-file-name=libncursesw.so | grep -q /
-	if [ $? -eq 0 ]; then
-		echo '-lncursesw'
-		exit
-	fi
-	$cc -print-file-name=libncurses.so | grep -q /
-	if [ $? -eq 0 ]; then
-		echo '-lncurses'
-		exit
-	fi
-	$cc -print-file-name=libcurses.so | grep -q /
-	if [ $? -eq 0 ]; then
-		echo '-lcurses'
-		exit
-	fi
+	for ext in so a dylib ; do
+		for lib in ncursesw ncurses curses ; do
+			$cc -print-file-name=lib${lib}.${ext} | grep -q /
+			if [ $? -eq 0 ]; then
+				echo "-l${lib}"
+				exit
+			fi
+		done
+	done
 	exit 1
 }
 
diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c
index ed1244d..f646381 100644
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@ -353,11 +353,16 @@ static int do_pcmcia_entry(const char *filename,
 
 static int do_of_entry (const char *filename, struct of_device_id *of, char *alias)
 {
+    int len;
     char *tmp;
-    sprintf (alias, "of:N%sT%sC%s",
+    len = sprintf (alias, "of:N%sT%s",
                     of->name[0] ? of->name : "*",
-                    of->type[0] ? of->type : "*",
-                    of->compatible[0] ? of->compatible : "*");
+                    of->type[0] ? of->type : "*");
+
+    if (of->compatible[0])
+        sprintf (&alias[len], "%sC%s",
+                     of->type[0] ? "*" : "",
+                     of->compatible);
 
     /* Replace all whitespace with underscores */
     for (tmp = alias; tmp && *tmp; tmp++)
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 113dc77..8e5610d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -582,6 +582,12 @@ static int strrcmp(const char *s, const char *sub)
 
 /**
  * Whitelist to allow certain references to pass with no warning.
+ *
+ * Pattern 0:
+ *   Do not warn if funtion/data are marked with __init_refok/__initdata_refok.
+ *   The pattern is identified by:
+ *   fromsec = .text.init.refok | .data.init.refok
+ *
  * Pattern 1:
  *   If a module parameter is declared __initdata and permissions=0
  *   then this is legal despite the warning generated.
@@ -619,14 +625,6 @@ static int strrcmp(const char *s, const char *sub)
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
- * Pattern 6:
- *   During the early init phase we have references from .init.text to
- *   .text we have an intended section mismatch - do not warn about it.
- *   See kernel_init() in init/main.c
- *   tosec   = .init.text
- *   fromsec = .text
- *   atsym = kernel_init
- *
  * Pattern 7:
  *  Logos used in drivers/video/logo reside in __initdata but the
  *  funtion that references them are EXPORT_SYMBOL() so cannot be
@@ -642,16 +640,11 @@ static int strrcmp(const char *s, const char *sub)
  *  tosec   = .init.text
  *  fromsec  = .paravirtprobe
  *
- * Pattern 9:
- *  Some of functions are common code between boot time and hotplug
- *  time. The bootmem allocater is called only boot time in its
- *  functions. So it's ok to reference.
- *  tosec    = .init.text
- *
  * Pattern 10:
- *  ia64 has machvec table for each platform. It is mixture of function
- *  pointer of .init.text and .text.
- *  fromsec  = .machvec
+ *  ia64 has machvec table for each platform and
+ *  powerpc has a machine desc table for each platform.
+ *  It is mixture of function pointers of .init.text and .text.
+ *  fromsec  = .machvec | .machine.desc
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -678,11 +671,10 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		NULL
 	};
 
-	const char *pat4sym[] = {
-		"sparse_index_alloc",
-		"zone_wait_table_init",
-		NULL
-	};
+	/* Check for pattern 0 */
+	if ((strcmp(fromsec, ".text.init.refok") == 0) ||
+	    (strcmp(fromsec, ".data.init.refok") == 0))
+		return 1;
 
 	/* Check for pattern 1 */
 	if (strcmp(tosec, ".init.data") != 0)
@@ -725,12 +717,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		if (strcmp(refsymname, *s) == 0)
 			return 1;
 
-	/* Check for pattern 6 */
-	if ((strcmp(tosec, ".init.text") == 0) &&
-	    (strcmp(fromsec, ".text") == 0) &&
-	    (strcmp(refsymname, "kernel_init") == 0))
-		return 1;
-
 	/* Check for pattern 7 */
 	if ((strcmp(tosec, ".init.data") == 0) &&
 	    (strncmp(fromsec, ".text", strlen(".text")) == 0) &&
@@ -742,15 +728,9 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	    (strcmp(fromsec, ".paravirtprobe") == 0))
 		return 1;
 
-	/* Check for pattern 9 */
-	if ((strcmp(tosec, ".init.text") == 0) &&
-	    (strcmp(fromsec, ".text") == 0))
-		for (s = pat4sym; *s; s++)
-			if (strcmp(atsym, *s) == 0)
-				return 1;
-
 	/* Check for pattern 10 */
-	if (strcmp(fromsec, ".machvec") == 0)
+	if ((strcmp(fromsec, ".machvec") == 0) ||
+	    (strcmp(fromsec, ".machine.desc") == 0))
 		return 1;
 
 	return 0;
@@ -884,30 +864,34 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 			     elf->strtab + before->st_name, refsymname))
 		return;
 
+	/* fromsec whitelist - without a valid 'before'
+	 * powerpc has a GOT table in .got2 section */
+	if (strcmp(fromsec, ".got2") == 0)
+		return;
+
 	if (before && after) {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
-		     "between '%s' (at offset 0x%llx) and '%s'\n",
-		     modname, secname, refsymname, fromsec,
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
+		     "(between '%s' and '%s')\n",
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname,
 		     elf->strtab + before->st_name,
-		     (long long)r.r_offset,
 		     elf->strtab + after->st_name);
 	} else if (before) {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
-		     "after '%s' (at offset 0x%llx)\n",
-		     modname, secname, refsymname, fromsec,
-		     elf->strtab + before->st_name,
-		     (long long)r.r_offset);
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
+		     "(after '%s')\n",
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname,
+		     elf->strtab + before->st_name);
 	} else if (after) {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
 		     "before '%s' (at offset -0x%llx)\n",
-		     modname, secname, refsymname, fromsec,
-		     elf->strtab + after->st_name,
-		     (long long)r.r_offset);
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname,
+		     elf->strtab + after->st_name);
 	} else {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
-		     "(offset 0x%llx)\n",
-		     modname, secname, fromsec, refsymname,
-		     (long long)r.r_offset);
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s\n",
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname);
 	}
 }
 
diff --git a/scripts/mod/sumversion.c b/scripts/mod/sumversion.c
index 6873d5a..d9cc690 100644
--- a/scripts/mod/sumversion.c
+++ b/scripts/mod/sumversion.c
@@ -7,6 +7,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <string.h>
+#include <limits.h>
 #include "modpost.h"
 
 /*
diff --git a/scripts/package/buildtar b/scripts/package/buildtar
index 88b5281..aa0ccdb 100644
--- a/scripts/package/buildtar
+++ b/scripts/package/buildtar
@@ -69,8 +69,8 @@ cp -v -- "${objtree}/vmlinux" "${tmpdir}/boot/vmlinux-${KERNELRELEASE}"
 # Install arch-specific kernel image(s)
 #
 case "${ARCH}" in
-	i386)
-		[ -f "${objtree}/arch/i386/boot/bzImage" ] && cp -v -- "${objtree}/arch/i386/boot/bzImage" "${tmpdir}/boot/vmlinuz-${KERNELRELEASE}"
+	i386|x86_64)
+		[ -f "${objtree}/arch/$ARCH/boot/bzImage" ] && cp -v -- "${objtree}/arch/$ARCH/boot/bzImage" "${tmpdir}/boot/vmlinuz-${KERNELRELEASE}"
 		;;
 	alpha)
 		[ -f "${objtree}/arch/alpha/boot/vmlinux.gz" ] && cp -v -- "${objtree}/arch/alpha/boot/vmlinux.gz" "${tmpdir}/boot/vmlinuz-${KERNELRELEASE}"
diff --git a/sound/sound_firmware.c b/sound/sound_firmware.c
index 3304344..96deaef 100644
--- a/sound/sound_firmware.c
+++ b/sound/sound_firmware.c
@@ -3,6 +3,7 @@
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 #include <asm/uaccess.h>
 #include "oss/sound_firmware.h"
 
