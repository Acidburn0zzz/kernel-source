From: Linus Torvalds <torvalds@osdl.org>
Subject: Linux 2.6.15-rc5-git3
Patch-mainline: 2.6.15-rc5-git3
Acked-by: olh@suse.de

diff -purN linux-2.6.15-rc5-git3/MAINTAINERS linux-2.6.15-rc5-git5/MAINTAINERS
--- linux-2.6.15-rc5-git3/MAINTAINERS	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/MAINTAINERS	2005-12-15 14:43:16.683116741 +0100
@@ -1284,8 +1284,8 @@ T:	git kernel.org:/pub/scm/linux/kernel/
 S:	Supported
 
 INPUT (KEYBOARD, MOUSE, JOYSTICK) DRIVERS
-P:	Vojtech Pavlik
-M:	vojtech@suse.cz
+P:	Dmitry Torokhov
+M:	dtor_core@ameritech.net
 L:	linux-input@atrey.karlin.mff.cuni.cz
 L:	linux-joystick@atrey.karlin.mff.cuni.cz
 T:	git kernel.org:/pub/scm/linux/kernel/git/dtor/input.git
diff -purN linux-2.6.15-rc5-git3/Makefile linux-2.6.15-rc5-git5/Makefile
--- linux-2.6.15-rc5-git3/Makefile	2005-12-15 14:43:10.171075149 +0100
+++ linux-2.6.15-rc5-git5/Makefile	2005-12-15 14:43:16.685116428 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 15
-EXTRAVERSION = -rc5-git3
+EXTRAVERSION = -rc5-git5
 NAME=Affluent Albatross
 
 # *DOCUMENTATION*
diff -purN linux-2.6.15-rc5-git3/arch/arm/kernel/module.c linux-2.6.15-rc5-git5/arch/arm/kernel/module.c
--- linux-2.6.15-rc5-git3/arch/arm/kernel/module.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/arch/arm/kernel/module.c	2005-12-15 14:43:16.686116271 +0100
@@ -101,6 +101,8 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
 			break;
 
 		case R_ARM_PC24:
+		case R_ARM_CALL:
+		case R_ARM_JUMP24:
 			offset = (*(u32 *)loc & 0x00ffffff) << 2;
 			if (offset & 0x02000000)
 				offset -= 0x04000000;
diff -purN linux-2.6.15-rc5-git3/arch/arm/mach-pxa/pm.c linux-2.6.15-rc5-git5/arch/arm/mach-pxa/pm.c
--- linux-2.6.15-rc5-git3/arch/arm/mach-pxa/pm.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/arch/arm/mach-pxa/pm.c	2005-12-15 14:43:16.689115801 +0100
@@ -155,19 +155,20 @@ int pxa_pm_enter(suspend_state_t state)
 	PSPR = 0;
 
 	/* restore registers */
+	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
+	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
 	RESTORE(GAFR0_L); RESTORE(GAFR0_U);
 	RESTORE(GAFR1_L); RESTORE(GAFR1_U);
 	RESTORE(GAFR2_L); RESTORE(GAFR2_U);
-	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
-	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
 	RESTORE(GRER0); RESTORE(GRER1); RESTORE(GRER2);
 	RESTORE(GFER0); RESTORE(GFER1); RESTORE(GFER2);
 	RESTORE(PGSR0); RESTORE(PGSR1); RESTORE(PGSR2);
 
 #ifdef CONFIG_PXA27x
 	RESTORE(MDREFR);
-	RESTORE(GAFR3_L); RESTORE(GAFR3_U); RESTORE_GPLEVEL(3);
-	RESTORE(GPDR3); RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
+	RESTORE_GPLEVEL(3); RESTORE(GPDR3);
+	RESTORE(GAFR3_L); RESTORE(GAFR3_U);
+	RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
 	RESTORE(PWER); RESTORE(PCFR); RESTORE(PRER);
 	RESTORE(PFER); RESTORE(PKWR);
 #endif
diff -purN linux-2.6.15-rc5-git3/arch/ia64/kernel/process.c linux-2.6.15-rc5-git5/arch/ia64/kernel/process.c
--- linux-2.6.15-rc5-git3/arch/ia64/kernel/process.c	2005-12-15 14:43:10.200070603 +0100
+++ linux-2.6.15-rc5-git5/arch/ia64/kernel/process.c	2005-12-15 14:43:16.717111412 +0100
@@ -721,11 +721,13 @@ flush_thread (void)
 	/* drop floating-point and debug-register state if it exists: */
 	current->thread.flags &= ~(IA64_THREAD_FPH_VALID | IA64_THREAD_DBG_VALID);
 	ia64_drop_fpu(current);
+#ifdef CONFIG_IA32_SUPPORT
 	if (IS_IA32_PROCESS(ia64_task_regs(current))) {
 		ia32_drop_partial_page_list(current);
 		current->thread.task_size = IA32_PAGE_OFFSET;
 		set_fs(USER_DS);
 	}
+#endif
 }
 
 /*
diff -purN linux-2.6.15-rc5-git3/drivers/ide/Kconfig linux-2.6.15-rc5-git5/drivers/ide/Kconfig
--- linux-2.6.15-rc5-git3/drivers/ide/Kconfig	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/Kconfig	2005-12-15 14:43:16.794099341 +0100
@@ -807,14 +807,6 @@ config BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
        depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
 endchoice
 
-config BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
-        bool "Enable burstable Mode on DbDMA"
-        default false
-        depends BLK_DEV_IDE_AU1XXX
-        help
-          This option enable the burstable Flag on DbDMA controller
-          (cf. "AMD Alchemy 'Au1200' Processor Data Book - PRELIMINARY").
-
 config BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
        int "Maximum transfer size (KB) per request (up to 128)"
        default "128"
@@ -940,7 +932,7 @@ config BLK_DEV_Q40IDE
 
 config BLK_DEV_MPC8xx_IDE
 	bool "MPC8xx IDE support"
-	depends on 8xx
+	depends on 8xx && IDE=y && BLK_DEV_IDE=y
 	help
 	  This option provides support for IDE on Motorola MPC8xx Systems.
 	  Please see 'Type of MPC8xx IDE interface' for details.
diff -purN linux-2.6.15-rc5-git3/drivers/ide/ide-cd.c linux-2.6.15-rc5-git5/drivers/ide/ide-cd.c
--- linux-2.6.15-rc5-git3/drivers/ide/ide-cd.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/ide-cd.c	2005-12-15 14:43:16.800098401 +0100
@@ -1292,7 +1292,6 @@ static ide_startstop_t cdrom_start_seek 
 	struct cdrom_info *info = drive->driver_data;
 
 	info->dma = 0;
-	info->cmd = 0;
 	info->start_seek = jiffies;
 	return cdrom_start_packet_command(drive, 0, cdrom_start_seek_continuation);
 }
@@ -1344,8 +1343,6 @@ static ide_startstop_t cdrom_start_read 
 	    (rq->nr_sectors & (sectors_per_frame - 1)))
 		info->dma = 0;
 
-	info->cmd = READ;
-
 	/* Start sending the read request to the drive. */
 	return cdrom_start_packet_command(drive, 32768, cdrom_start_read_continuation);
 }
@@ -1484,7 +1481,6 @@ static ide_startstop_t cdrom_do_packet_c
 	struct cdrom_info *info = drive->driver_data;
 
 	info->dma = 0;
-	info->cmd = 0;
 	rq->flags &= ~REQ_FAILED;
 	len = rq->data_len;
 
@@ -1891,7 +1887,6 @@ static ide_startstop_t cdrom_start_write
 	/* use dma, if possible. we don't need to check more, since we
 	 * know that the transfer is always (at least!) frame aligned */
 	info->dma = drive->using_dma ? 1 : 0;
-	info->cmd = WRITE;
 
 	info->devinfo.media_written = 1;
 
@@ -1916,7 +1911,6 @@ static ide_startstop_t cdrom_do_block_pc
 	rq->flags |= REQ_QUIET;
 
 	info->dma = 0;
-	info->cmd = 0;
 
 	/*
 	 * sg request
@@ -1925,7 +1919,6 @@ static ide_startstop_t cdrom_do_block_pc
 		int mask = drive->queue->dma_alignment;
 		unsigned long addr = (unsigned long) page_address(bio_page(rq->bio));
 
-		info->cmd = rq_data_dir(rq);
 		info->dma = drive->using_dma;
 
 		/*
diff -purN linux-2.6.15-rc5-git3/drivers/ide/ide-cd.h linux-2.6.15-rc5-git5/drivers/ide/ide-cd.h
--- linux-2.6.15-rc5-git3/drivers/ide/ide-cd.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/ide-cd.h	2005-12-15 14:43:16.801098244 +0100
@@ -480,7 +480,6 @@ struct cdrom_info {
 
 	struct request request_sense_request;
 	int dma;
-	int cmd;
 	unsigned long last_block;
 	unsigned long start_seek;
 	/* Buffer to hold mechanism status and changer slot table. */
diff -purN linux-2.6.15-rc5-git3/drivers/ide/ide-disk.c linux-2.6.15-rc5-git5/drivers/ide/ide-disk.c
--- linux-2.6.15-rc5-git3/drivers/ide/ide-disk.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/ide-disk.c	2005-12-15 14:43:16.804097774 +0100
@@ -1034,12 +1034,12 @@ static int ide_disk_remove(struct device
 	struct ide_disk_obj *idkp = drive->driver_data;
 	struct gendisk *g = idkp->disk;
 
-	ide_cacheflush_p(drive);
-
 	ide_unregister_subdriver(drive, idkp->driver);
 
 	del_gendisk(g);
 
+	ide_cacheflush_p(drive);
+
 	ide_disk_put(idkp);
 
 	return 0;
diff -purN linux-2.6.15-rc5-git3/drivers/ide/ide-dma.c linux-2.6.15-rc5-git5/drivers/ide/ide-dma.c
--- linux-2.6.15-rc5-git3/drivers/ide/ide-dma.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/ide-dma.c	2005-12-15 14:43:16.806097460 +0100
@@ -90,11 +90,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-struct drive_list_entry {
-	const char *id_model;
-	const char *id_firmware;
-};
-
 static const struct drive_list_entry drive_whitelist [] = {
 
 	{ "Micropolis 2112A"	,       "ALL"		},
@@ -139,7 +134,7 @@ static const struct drive_list_entry dri
 };
 
 /**
- *	in_drive_list	-	look for drive in black/white list
+ *	ide_in_drive_list	-	look for drive in black/white list
  *	@id: drive identifier
  *	@drive_table: list to inspect
  *
@@ -147,7 +142,7 @@ static const struct drive_list_entry dri
  *	Returns 1 if the drive is found in the table.
  */
 
-static int in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
+int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
 {
 	for ( ; drive_table->id_model ; drive_table++)
 		if ((!strcmp(drive_table->id_model, id->model)) &&
@@ -157,6 +152,8 @@ static int in_drive_list(struct hd_drive
 	return 0;
 }
 
+EXPORT_SYMBOL_GPL(ide_in_drive_list);
+
 /**
  *	ide_dma_intr	-	IDE DMA interrupt handler
  *	@drive: the drive the interrupt is for
@@ -663,7 +660,7 @@ int __ide_dma_bad_drive (ide_drive_t *dr
 {
 	struct hd_driveid *id = drive->id;
 
-	int blacklist = in_drive_list(id, drive_blacklist);
+	int blacklist = ide_in_drive_list(id, drive_blacklist);
 	if (blacklist) {
 		printk(KERN_WARNING "%s: Disabling (U)DMA for %s (blacklisted)\n",
 				    drive->name, id->model);
@@ -677,7 +674,7 @@ EXPORT_SYMBOL(__ide_dma_bad_drive);
 int __ide_dma_good_drive (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
-	return in_drive_list(id, drive_whitelist);
+	return ide_in_drive_list(id, drive_whitelist);
 }
 
 EXPORT_SYMBOL(__ide_dma_good_drive);
diff -purN linux-2.6.15-rc5-git3/drivers/ide/mips/Makefile linux-2.6.15-rc5-git5/drivers/ide/mips/Makefile
--- linux-2.6.15-rc5-git3/drivers/ide/mips/Makefile	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/mips/Makefile	2005-12-15 14:43:16.807097304 +0100
@@ -1 +1,4 @@
 obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
+obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
+
+EXTRA_CFLAGS    := -Idrivers/ide
diff -purN linux-2.6.15-rc5-git3/drivers/ide/mips/au1xxx-ide.c linux-2.6.15-rc5-git5/drivers/ide/mips/au1xxx-ide.c
--- linux-2.6.15-rc5-git3/drivers/ide/mips/au1xxx-ide.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/mips/au1xxx-ide.c	2005-12-15 14:43:16.827094169 +0100
@@ -31,865 +31,638 @@
  */
 #undef REALLY_SLOW_IO           /* most systems can safely undef this */
 
-#include <linux/config.h>       /* for CONFIG_BLK_DEV_IDEPCI */
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
-#include <linux/ioport.h>
-#include <linux/hdreg.h>
+#include <linux/platform_device.h>
+
 #include <linux/init.h>
 #include <linux/ide.h>
 #include <linux/sysdev.h>
 
 #include <linux/dma-mapping.h>
 
+#include "ide-timing.h"
+
 #include <asm/io.h>
 #include <asm/mach-au1x00/au1xxx.h>
 #include <asm/mach-au1x00/au1xxx_dbdma.h>
 
-#if CONFIG_PM
-#include <asm/mach-au1x00/au1xxx_pm.h>
-#endif
-
 #include <asm/mach-au1x00/au1xxx_ide.h>
 
 #define DRV_NAME	"au1200-ide"
 #define DRV_VERSION	"1.0"
-#define DRV_AUTHOR	"AMD PCS / Pete Popov <ppopov@embeddedalley.com>"
-#define DRV_DESC	"Au1200 IDE"
-
-static _auide_hwif auide_hwif;
-static spinlock_t ide_tune_drive_spin_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t ide_tune_chipset_spin_lock = SPIN_LOCK_UNLOCKED;
-static int dbdma_init_done = 0;
+#define DRV_AUTHOR	"Enrico Walther <enrico.walther@amd.com> / Pete Popov <ppopov@embeddedalley.com>"
 
-/*
- * local I/O functions
- */
-u8 auide_inb(unsigned long port)
-{
-        return (au_readb(port));
-}
+/* enable the burstmode in the dbdma */
+#define IDE_AU1XXX_BURSTMODE	1
 
-u16 auide_inw(unsigned long port)
-{
-        return (au_readw(port));
-}
-
-u32 auide_inl(unsigned long port)
-{
-        return (au_readl(port));
-}
+static _auide_hwif auide_hwif;
+static int dbdma_init_done;
 
-void auide_insw(unsigned long port, void *addr, u32 count)
-{
 #if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
 
-        _auide_hwif *ahwif = &auide_hwif;
-        chan_tab_t *ctp;
-        au1x_ddma_desc_t *dp;
-
-        if(!put_dest_flags(ahwif->rx_chan, (void*)addr, count << 1,
-				DDMA_FLAGS_NOIE)) {
-                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
-                return;
-        }
-        ctp = *((chan_tab_t **)ahwif->rx_chan);
-        dp = ctp->cur_ptr;
-        while (dp->dscr_cmd0 & DSCR_CMD0_V)
-                ;
-        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
-#else
-        while (count--)
-        {
-                *(u16 *)addr = au_readw(port);
-                addr +=2 ;
-        }
-#endif
-}
-
-void auide_insl(unsigned long port, void *addr, u32 count)
-{
-        while (count--)
-        {
-                *(u32 *)addr = au_readl(port);
-                /* NOTE: For IDE interfaces over PCMCIA,
-                 * 32-bit access does not work
-                 */
-                addr += 4;
-        }
-}
-
-void auide_outb(u8 addr, unsigned long port)
-{
-        return (au_writeb(addr, port));
-}
-
-void auide_outbsync(ide_drive_t *drive, u8 addr, unsigned long port)
-{
-        return (au_writeb(addr, port));
-}
-
-void auide_outw(u16 addr, unsigned long port)
-{
-        return (au_writew(addr, port));
-}
-
-void auide_outl(u32 addr, unsigned long port)
+void auide_insw(unsigned long port, void *addr, u32 count)
 {
-        return (au_writel(addr, port));
+	_auide_hwif *ahwif = &auide_hwif;
+	chan_tab_t *ctp;
+	au1x_ddma_desc_t *dp;
+
+	if(!put_dest_flags(ahwif->rx_chan, (void*)addr, count << 1, 
+			   DDMA_FLAGS_NOIE)) {
+		printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	ctp = *((chan_tab_t **)ahwif->rx_chan);
+	dp = ctp->cur_ptr;
+	while (dp->dscr_cmd0 & DSCR_CMD0_V)
+		;
+	ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
 }
 
 void auide_outsw(unsigned long port, void *addr, u32 count)
 {
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
-        _auide_hwif *ahwif = &auide_hwif;
-        chan_tab_t *ctp;
-        au1x_ddma_desc_t *dp;
-
-        if(!put_source_flags(ahwif->tx_chan, (void*)addr,
-                                          count << 1, DDMA_FLAGS_NOIE)) {
-                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
-                return;
-        }
-        ctp = *((chan_tab_t **)ahwif->tx_chan);
-        dp = ctp->cur_ptr;
-        while (dp->dscr_cmd0 & DSCR_CMD0_V)
-                ;
-        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
-#else
-        while (count--)
-        {
-                au_writew(*(u16 *)addr, port);
-                addr += 2;
-        }
-#endif
+	_auide_hwif *ahwif = &auide_hwif;
+	chan_tab_t *ctp;
+	au1x_ddma_desc_t *dp;
+
+	if(!put_source_flags(ahwif->tx_chan, (void*)addr,
+			     count << 1, DDMA_FLAGS_NOIE)) {
+		printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+		return;
+	}
+	ctp = *((chan_tab_t **)ahwif->tx_chan);
+	dp = ctp->cur_ptr;
+	while (dp->dscr_cmd0 & DSCR_CMD0_V)
+		;
+	ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
 }
 
-void auide_outsl(unsigned long port, void *addr, u32 count)
-{
-        while (count--)
-        {
-                au_writel(*(u32 *)addr, port);
-                /* NOTE: For IDE interfaces over PCMCIA,
-                 * 32-bit access does not work
-                 */
-                addr += 4;
-        }
-}
+#endif
 
 static void auide_tune_drive(ide_drive_t *drive, byte pio)
 {
-        int mem_sttime;
-        int mem_stcfg;
-        unsigned long flags;
-        u8 speed;
-
-        /* get the best pio mode for the drive */
-        pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
-
-        printk("%s: setting Au1XXX IDE to PIO mode%d\n",
-                drive->name, pio);
-
-        spin_lock_irqsave(&ide_tune_drive_spin_lock, flags);
-
-        mem_sttime = 0;
-        mem_stcfg  = au_readl(MEM_STCFG2);
-
-        /* set pio mode! */
-        switch(pio) {
-                case 0:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO0_TWCS
-                                     | SBC_IDE_PIO0_TCSH
-                                     | SBC_IDE_PIO0_TCSOFF
-                                     | SBC_IDE_PIO0_TWP
-                                     | SBC_IDE_PIO0_TCSW
-                                     | SBC_IDE_PIO0_TPM
-                                     | SBC_IDE_PIO0_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO0_TCSOE | SBC_IDE_PIO0_TOECS;
-
-                        au_writel(mem_sttime,MEM_STTIME2);
-                        au_writel(mem_stcfg,MEM_STCFG2);
-                        break;
-
-                case 1:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO1_TWCS
-                                     | SBC_IDE_PIO1_TCSH
-                                     | SBC_IDE_PIO1_TCSOFF
-                                     | SBC_IDE_PIO1_TWP
-                                     | SBC_IDE_PIO1_TCSW
-                                     | SBC_IDE_PIO1_TPM
-                                     | SBC_IDE_PIO1_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO1_TCSOE | SBC_IDE_PIO1_TOECS;
-                        break;
-
-                case 2:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO2_TWCS
-                                     | SBC_IDE_PIO2_TCSH
-                                     | SBC_IDE_PIO2_TCSOFF
-                                     | SBC_IDE_PIO2_TWP
-                                     | SBC_IDE_PIO2_TCSW
-                                     | SBC_IDE_PIO2_TPM
-                                     | SBC_IDE_PIO2_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO2_TCSOE | SBC_IDE_PIO2_TOECS;
-                        break;
-
-                case 3:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO3_TWCS
-                                     | SBC_IDE_PIO3_TCSH
-                                     | SBC_IDE_PIO3_TCSOFF
-                                     | SBC_IDE_PIO3_TWP
-                                     | SBC_IDE_PIO3_TCSW
-                                     | SBC_IDE_PIO3_TPM
-                                     | SBC_IDE_PIO3_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO3_TCSOE | SBC_IDE_PIO3_TOECS;
-
-                        break;
-
-                case 4:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_PIO4_TWCS
-                                     | SBC_IDE_PIO4_TCSH
-                                     | SBC_IDE_PIO4_TCSOFF
-                                     | SBC_IDE_PIO4_TWP
-                                     | SBC_IDE_PIO4_TCSW
-                                     | SBC_IDE_PIO4_TPM
-                                     | SBC_IDE_PIO4_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_PIO4_TCSOE | SBC_IDE_PIO4_TOECS;
-                        break;
-        }
-
-        au_writel(mem_sttime,MEM_STTIME2);
-        au_writel(mem_stcfg,MEM_STCFG2);
+	int mem_sttime;
+	int mem_stcfg;
+	u8 speed;
+
+	/* get the best pio mode for the drive */
+	pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+
+	printk(KERN_INFO "%s: setting Au1XXX IDE to PIO mode%d\n",
+	       drive->name, pio);
+
+	mem_sttime = 0;
+	mem_stcfg  = au_readl(MEM_STCFG2);
+
+	/* set pio mode! */
+	switch(pio) {
+	case 0:
+		mem_sttime = SBC_IDE_TIMING(PIO0);
+
+		/* set configuration for RCS2# */
+		mem_stcfg |= TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO0_TCSOE | SBC_IDE_PIO0_TOECS;
+		break;
+
+	case 1:
+		mem_sttime = SBC_IDE_TIMING(PIO1);
+
+		/* set configuration for RCS2# */
+		mem_stcfg |= TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO1_TCSOE | SBC_IDE_PIO1_TOECS;
+		break;
+
+	case 2:
+		mem_sttime = SBC_IDE_TIMING(PIO2);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO2_TCSOE | SBC_IDE_PIO2_TOECS;
+		break;
+
+	case 3:
+		mem_sttime = SBC_IDE_TIMING(PIO3);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO3_TCSOE | SBC_IDE_PIO3_TOECS;
+
+		break;
+
+	case 4:
+		mem_sttime = SBC_IDE_TIMING(PIO4);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_PIO4_TCSOE | SBC_IDE_PIO4_TOECS;
+		break;
+	}
 
-        spin_unlock_irqrestore(&ide_tune_drive_spin_lock, flags);
+	au_writel(mem_sttime,MEM_STTIME2);
+	au_writel(mem_stcfg,MEM_STCFG2);
 
-        speed = pio + XFER_PIO_0;
-        ide_config_drive_speed(drive, speed);
+	speed = pio + XFER_PIO_0;
+	ide_config_drive_speed(drive, speed);
 }
 
 static int auide_tune_chipset (ide_drive_t *drive, u8 speed)
 {
-        u8 mode = 0;
-        int mem_sttime;
-        int mem_stcfg;
-        unsigned long flags;
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        struct hd_driveid *id = drive->id;
+	int mem_sttime;
+	int mem_stcfg;
+	unsigned long mode;
 
-        /*
-         * Now see what the current drive is capable of,
-         * selecting UDMA only if the mate said it was ok.
-         */
-        if (id && (id->capability & 1) && drive->autodma &&
-            !__ide_dma_bad_drive(drive)) {
-                if (!mode && (id->field_valid & 2) && (id->dma_mword & 7)) {
-                        if      (id->dma_mword & 4)
-                                mode = XFER_MW_DMA_2;
-                        else if (id->dma_mword & 2)
-                                mode = XFER_MW_DMA_1;
-                        else if (id->dma_mword & 1)
-                                mode = XFER_MW_DMA_0;
-                }
-        }
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	if (ide_use_dma(drive))
+		mode = ide_dma_speed(drive, 0);
 #endif
 
-        spin_lock_irqsave(&ide_tune_chipset_spin_lock, flags);
+	mem_sttime = 0;
+	mem_stcfg  = au_readl(MEM_STCFG2);
 
-        mem_sttime = 0;
-        mem_stcfg  = au_readl(MEM_STCFG2);
-
-        switch(speed) {
-                case XFER_PIO_4:
-                case XFER_PIO_3:
-                case XFER_PIO_2:
-                case XFER_PIO_1:
-                case XFER_PIO_0:
-                        auide_tune_drive(drive, (speed - XFER_PIO_0));
-                        break;
+	if (speed >= XFER_PIO_0 && speed <= XFER_PIO_4) {
+		auide_tune_drive(drive, speed - XFER_PIO_0);
+		return 0;
+	}
+	      
+	switch(speed) {
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-                case XFER_MW_DMA_2:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_MDMA2_TWCS
-                                     | SBC_IDE_MDMA2_TCSH
-                                     | SBC_IDE_MDMA2_TCSOFF
-                                     | SBC_IDE_MDMA2_TWP
-                                     | SBC_IDE_MDMA2_TCSW
-                                     | SBC_IDE_MDMA2_TPM
-                                     | SBC_IDE_MDMA2_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_MDMA2_TCSOE | SBC_IDE_MDMA2_TOECS;
-
-                        mode = XFER_MW_DMA_2;
-                        break;
-                case XFER_MW_DMA_1:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_MDMA1_TWCS
-                                     | SBC_IDE_MDMA1_TCSH
-                                     | SBC_IDE_MDMA1_TCSOFF
-                                     | SBC_IDE_MDMA1_TWP
-                                     | SBC_IDE_MDMA1_TCSW
-                                     | SBC_IDE_MDMA1_TPM
-                                     | SBC_IDE_MDMA1_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg &= ~TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_MDMA1_TCSOE | SBC_IDE_MDMA1_TOECS;
-
-                        mode = XFER_MW_DMA_1;
-                        break;
-                case XFER_MW_DMA_0:
-                        /* set timing parameters for RCS2# */
-                        mem_sttime =   SBC_IDE_MDMA0_TWCS
-                                     | SBC_IDE_MDMA0_TCSH
-                                     | SBC_IDE_MDMA0_TCSOFF
-                                     | SBC_IDE_MDMA0_TWP
-                                     | SBC_IDE_MDMA0_TCSW
-                                     | SBC_IDE_MDMA0_TPM
-                                     | SBC_IDE_MDMA0_TA;
-                        /* set configuration for RCS2# */
-                        mem_stcfg |= TS_MASK;
-                        mem_stcfg &= ~TCSOE_MASK;
-                        mem_stcfg &= ~TOECS_MASK;
-                        mem_stcfg |= SBC_IDE_MDMA0_TCSOE | SBC_IDE_MDMA0_TOECS;
-
-                        mode = XFER_MW_DMA_0;
-                        break;
-#endif
-                default:
-                        return 1;
-        }
-
-        /*
-         * Tell the drive to switch to the new mode; abort on failure.
-         */
-        if (!mode || ide_config_drive_speed(drive, mode))
-        {
-                return 1;       /* failure */
-        }
+	case XFER_MW_DMA_2:
+		mem_sttime = SBC_IDE_TIMING(MDMA2);
 
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_MDMA2_TCSOE | SBC_IDE_MDMA2_TOECS;
+
+		mode = XFER_MW_DMA_2;
+		break;
+	case XFER_MW_DMA_1:
+		mem_sttime = SBC_IDE_TIMING(MDMA1);
+
+		/* set configuration for RCS2# */
+		mem_stcfg &= ~TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_MDMA1_TCSOE | SBC_IDE_MDMA1_TOECS;
+
+		mode = XFER_MW_DMA_1;
+		break;
+	case XFER_MW_DMA_0:
+		mem_sttime = SBC_IDE_TIMING(MDMA0);
+
+		/* set configuration for RCS2# */
+		mem_stcfg |= TS_MASK;
+		mem_stcfg &= ~TCSOE_MASK;
+		mem_stcfg &= ~TOECS_MASK;
+		mem_stcfg |= SBC_IDE_MDMA0_TCSOE | SBC_IDE_MDMA0_TOECS;
 
-        au_writel(mem_sttime,MEM_STTIME2);
-        au_writel(mem_stcfg,MEM_STCFG2);
+		mode = XFER_MW_DMA_0;
+		break;
+#endif
+	default:
+		return 1;
+	}
+	
+	if (ide_config_drive_speed(drive, mode))
+		return 1;
 
-        spin_unlock_irqrestore(&ide_tune_chipset_spin_lock, flags);
+	au_writel(mem_sttime,MEM_STTIME2);
+	au_writel(mem_stcfg,MEM_STCFG2);
 
-        return 0;
+	return 0;
 }
 
 /*
  * Multi-Word DMA + DbDMA functions
  */
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
 
-static int in_drive_list(struct hd_driveid *id,
-                         const struct drive_list_entry *drive_table)
-{
-        for ( ; drive_table->id_model ; drive_table++){
-                if ((!strcmp(drive_table->id_model, id->model)) &&
-                        ((strstr(drive_table->id_firmware, id->fw_rev)) ||
-                        (!strcmp(drive_table->id_firmware, "ALL")))
-                )
-                        return 1;
-        }
-        return 0;
-}
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
 
 static int auide_build_sglist(ide_drive_t *drive,  struct request *rq)
 {
-        ide_hwif_t *hwif = drive->hwif;
-        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
-        struct scatterlist *sg = hwif->sg_table;
-
-        ide_map_sg(drive, rq);
-
-        if (rq_data_dir(rq) == READ)
-                hwif->sg_dma_direction = DMA_FROM_DEVICE;
-        else
-                hwif->sg_dma_direction = DMA_TO_DEVICE;
+	ide_hwif_t *hwif = drive->hwif;
+	_auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+	struct scatterlist *sg = hwif->sg_table;
+
+	ide_map_sg(drive, rq);
+
+	if (rq_data_dir(rq) == READ)
+		hwif->sg_dma_direction = DMA_FROM_DEVICE;
+	else
+		hwif->sg_dma_direction = DMA_TO_DEVICE;
 
-        return dma_map_sg(ahwif->dev, sg, hwif->sg_nents,
-                          hwif->sg_dma_direction);
+	return dma_map_sg(ahwif->dev, sg, hwif->sg_nents,
+			  hwif->sg_dma_direction);
 }
 
 static int auide_build_dmatable(ide_drive_t *drive)
 {
-        int i, iswrite, count = 0;
-        ide_hwif_t *hwif = HWIF(drive);
+	int i, iswrite, count = 0;
+	ide_hwif_t *hwif = HWIF(drive);
 
-        struct request *rq = HWGROUP(drive)->rq;
+	struct request *rq = HWGROUP(drive)->rq;
 
-        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
-        struct scatterlist *sg;
+	_auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+	struct scatterlist *sg;
 
-        iswrite = (rq_data_dir(rq) == WRITE);
-        /* Save for interrupt context */
-        ahwif->drive = drive;
-
-        /* Build sglist */
-        hwif->sg_nents = i = auide_build_sglist(drive, rq);
-
-        if (!i)
-                return 0;
-
-        /* fill the descriptors */
-        sg = hwif->sg_table;
-        while (i && sg_dma_len(sg)) {
-                u32 cur_addr;
-                u32 cur_len;
-
-                cur_addr = sg_dma_address(sg);
-                cur_len = sg_dma_len(sg);
-
-                while (cur_len) {
-                        u32 flags = DDMA_FLAGS_NOIE;
-                        unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
-
-                        if (++count >= PRD_ENTRIES) {
-                                printk(KERN_WARNING "%s: DMA table too small\n",
-                                drive->name);
-                                goto use_pio_instead;
-                        }
-
-                        /* Lets enable intr for the last descriptor only */
-                        if (1==i)
-                                flags = DDMA_FLAGS_IE;
-                        else
-                                flags = DDMA_FLAGS_NOIE;
-
-                        if (iswrite) {
-				if(!put_source_flags(ahwif->tx_chan,
-						(void*)(page_address(sg->page)
-							+ sg->offset),
-						tc, flags)) {
-					printk(KERN_ERR "%s failed %d\n",
-							__FUNCTION__, __LINE__);
+	iswrite = (rq_data_dir(rq) == WRITE);
+	/* Save for interrupt context */
+	ahwif->drive = drive;
+
+	/* Build sglist */
+	hwif->sg_nents = i = auide_build_sglist(drive, rq);
+
+	if (!i)
+		return 0;
+
+	/* fill the descriptors */
+	sg = hwif->sg_table;
+	while (i && sg_dma_len(sg)) {
+		u32 cur_addr;
+		u32 cur_len;
+
+		cur_addr = sg_dma_address(sg);
+		cur_len = sg_dma_len(sg);
+
+		while (cur_len) {
+			u32 flags = DDMA_FLAGS_NOIE;
+			unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
+
+			if (++count >= PRD_ENTRIES) {
+				printk(KERN_WARNING "%s: DMA table too small\n",
+				       drive->name);
+				goto use_pio_instead;
+			}
+
+			/* Lets enable intr for the last descriptor only */
+			if (1==i)
+				flags = DDMA_FLAGS_IE;
+			else
+				flags = DDMA_FLAGS_NOIE;
+
+			if (iswrite) {
+				if(!put_source_flags(ahwif->tx_chan, 
+						     (void*)(page_address(sg->page) 
+							     + sg->offset), 
+						     tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+					       __FUNCTION__, __LINE__);
 				}
-                        } else
+			} else 
 			{
-				if(!put_dest_flags(ahwif->rx_chan,
-						(void*)(page_address(sg->page)
-							+ sg->offset),
-						tc, flags)) {
-					printk(KERN_ERR "%s failed %d\n",
-							__FUNCTION__, __LINE__);
+				if(!put_dest_flags(ahwif->rx_chan, 
+						   (void*)(page_address(sg->page) 
+							   + sg->offset), 
+						   tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+					       __FUNCTION__, __LINE__);
 				}
-                        }
+			}
+
+			cur_addr += tc;
+			cur_len -= tc;
+		}
+		sg++;
+		i--;
+	}
 
-                        cur_addr += tc;
-                        cur_len -= tc;
-                }
-                sg++;
-                i--;
-        }
-
-        if (count)
-                return 1;
-
-use_pio_instead:
-        dma_unmap_sg(ahwif->dev,
-                     hwif->sg_table,
-                     hwif->sg_nents,
-                     hwif->sg_dma_direction);
+	if (count)
+		return 1;
 
-        return 0; /* revert to PIO for this request */
+ use_pio_instead:
+	dma_unmap_sg(ahwif->dev,
+		     hwif->sg_table,
+		     hwif->sg_nents,
+		     hwif->sg_dma_direction);
+
+	return 0; /* revert to PIO for this request */
 }
 
 static int auide_dma_end(ide_drive_t *drive)
 {
-        ide_hwif_t *hwif = HWIF(drive);
-        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+	ide_hwif_t *hwif = HWIF(drive);
+	_auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
 
-        if (hwif->sg_nents) {
-                dma_unmap_sg(ahwif->dev, hwif->sg_table, hwif->sg_nents,
-                             hwif->sg_dma_direction);
-                hwif->sg_nents = 0;
-        }
+	if (hwif->sg_nents) {
+		dma_unmap_sg(ahwif->dev, hwif->sg_table, hwif->sg_nents,
+			     hwif->sg_dma_direction);
+		hwif->sg_nents = 0;
+	}
 
-        return 0;
+	return 0;
 }
 
 static void auide_dma_start(ide_drive_t *drive )
 {
-//      printk("%s\n", __FUNCTION__);
 }
 
-ide_startstop_t auide_dma_intr(ide_drive_t *drive)
-{
-        //printk("%s\n", __FUNCTION__);
-
-        u8 stat = 0, dma_stat = 0;
-
-        dma_stat = HWIF(drive)->ide_dma_end(drive);
-        stat = HWIF(drive)->INB(IDE_STATUS_REG);        /* get drive status */
-        if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
-                if (!dma_stat) {
-                        struct request *rq = HWGROUP(drive)->rq;
-
-                        ide_end_request(drive, 1, rq->nr_sectors);
-                        return ide_stopped;
-                }
-                printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n",
-                                 drive->name, dma_stat);
-        }
-        return ide_error(drive, "dma_intr", stat);
-}
 
 static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
-        //printk("%s\n", __FUNCTION__);
-
-        /* issue cmd to drive */
-        ide_execute_command(drive, command, &auide_dma_intr,
-                            (2*WAIT_CMD), NULL);
+	/* issue cmd to drive */
+	ide_execute_command(drive, command, &ide_dma_intr,
+			    (2*WAIT_CMD), NULL);
 }
 
 static int auide_dma_setup(ide_drive_t *drive)
-{
-//      printk("%s\n", __FUNCTION__);
-
-        if (drive->media != ide_disk)
-                return 1;
-
-        if (!auide_build_dmatable(drive))
-                        /* try PIO instead of DMA */
-                        return 1;
+{       	
+	struct request *rq = HWGROUP(drive)->rq;
 
-        drive->waiting_for_dma = 1;
+	if (!auide_build_dmatable(drive)) {
+		ide_map_sg(drive, rq);
+		return 1;
+	}
 
-        return 0;
+	drive->waiting_for_dma = 1;
+	return 0;
 }
 
 static int auide_dma_check(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
+	u8 speed;
 
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        if( !dbdma_init_done ){
-                auide_hwif.white_list = in_drive_list(drive->id,
-                                                      dma_white_list);
-                auide_hwif.black_list = in_drive_list(drive->id,
-                                                      dma_black_list);
-                auide_hwif.drive = drive;
-                auide_ddma_init(&auide_hwif);
-                dbdma_init_done = 1;
-        }
+
+	if( dbdma_init_done == 0 ){
+		auide_hwif.white_list = ide_in_drive_list(drive->id,
+							  dma_white_list);
+		auide_hwif.black_list = ide_in_drive_list(drive->id,
+							  dma_black_list);
+		auide_hwif.drive = drive;
+		auide_ddma_init(&auide_hwif);
+		dbdma_init_done = 1;
+	}
 #endif
 
-        /* Is the drive in our DMA black list? */
-        if ( auide_hwif.black_list ) {
-                drive->using_dma = 0;
-                printk("%s found in dma_blacklist[]! Disabling DMA.\n",
-                drive->id->model);
-        }
-        else
-                drive->using_dma = 1;
+	/* Is the drive in our DMA black list? */
+
+	if ( auide_hwif.black_list ) {
+		drive->using_dma = 0;
+
+		/* Borrowed the warning message from ide-dma.c */
+
+		printk(KERN_WARNING "%s: Disabling DMA for %s (blacklisted)\n",
+		       drive->name, drive->id->model);	       
+	}
+	else
+		drive->using_dma = 1;
+
+	speed = ide_find_best_mode(drive, XFER_PIO | XFER_MWDMA);
+	
+	if (drive->autodma && (speed & XFER_MODE) != XFER_PIO)
+		return HWIF(drive)->ide_dma_on(drive);
 
-        return HWIF(drive)->ide_dma_host_on(drive);
+	return HWIF(drive)->ide_dma_off_quietly(drive);
 }
 
 static int auide_dma_test_irq(ide_drive_t *drive)
-{
-//      printk("%s\n", __FUNCTION__);
-
-        if (!drive->waiting_for_dma)
-                printk(KERN_WARNING "%s: ide_dma_test_irq \
+{	
+	if (drive->waiting_for_dma == 0)
+		printk(KERN_WARNING "%s: ide_dma_test_irq \
                                      called while not waiting\n", drive->name);
 
-        /* If dbdma didn't execute the STOP command yet, the
-         * active bit is still set
+	/* If dbdma didn't execute the STOP command yet, the
+	 * active bit is still set
 	 */
-        drive->waiting_for_dma++;
-        if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
-                printk(KERN_WARNING "%s: timeout waiting for ddma to \
+	drive->waiting_for_dma++;
+	if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
+		printk(KERN_WARNING "%s: timeout waiting for ddma to \
                                      complete\n", drive->name);
-                return 1;
-        }
-        udelay(10);
-        return 0;
+		return 1;
+	}
+	udelay(10);
+	return 0;
 }
 
 static int auide_dma_host_on(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        return 0;
+	return 0;
 }
 
 static int auide_dma_on(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        drive->using_dma = 1;
-        return auide_dma_host_on(drive);
+	drive->using_dma = 1;
+	return auide_dma_host_on(drive);
 }
 
 
 static int auide_dma_host_off(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        return 0;
+	return 0;
 }
 
 static int auide_dma_off_quietly(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-        drive->using_dma = 0;
-        return auide_dma_host_off(drive);
+	drive->using_dma = 0;
+	return auide_dma_host_off(drive);
 }
 
 static int auide_dma_lostirq(ide_drive_t *drive)
 {
-//      printk("%s\n", __FUNCTION__);
-
-        printk(KERN_ERR "%s: IRQ lost\n", drive->name);
-        return 0;
+	printk(KERN_ERR "%s: IRQ lost\n", drive->name);
+	return 0;
 }
 
 static void auide_ddma_tx_callback(int irq, void *param, struct pt_regs *regs)
 {
-//      printk("%s\n", __FUNCTION__);
-
-        _auide_hwif *ahwif = (_auide_hwif*)param;
-        ahwif->drive->waiting_for_dma = 0;
-        return;
+	_auide_hwif *ahwif = (_auide_hwif*)param;
+	ahwif->drive->waiting_for_dma = 0;
 }
 
 static void auide_ddma_rx_callback(int irq, void *param, struct pt_regs *regs)
 {
-//      printk("%s\n", __FUNCTION__);
+	_auide_hwif *ahwif = (_auide_hwif*)param;
+	ahwif->drive->waiting_for_dma = 0;
+}
 
-        _auide_hwif *ahwif = (_auide_hwif*)param;
-        ahwif->drive->waiting_for_dma = 0;
-        return;
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+
+static void auide_init_dbdma_dev(dbdev_tab_t *dev, u32 dev_id, u32 tsize, u32 devwidth, u32 flags)
+{
+	dev->dev_id          = dev_id;
+	dev->dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+	dev->dev_intlevel    = 0;
+	dev->dev_intpolarity = 0;
+	dev->dev_tsize       = tsize;
+	dev->dev_devwidth    = devwidth;
+	dev->dev_flags       = flags;
 }
+  
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
 
 static int auide_dma_timeout(ide_drive_t *drive)
 {
 //      printk("%s\n", __FUNCTION__);
 
-        printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
+	printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
 
-        if (HWIF(drive)->ide_dma_test_irq(drive))
-                return 0;
+	if (HWIF(drive)->ide_dma_test_irq(drive))
+		return 0;
 
-        return HWIF(drive)->ide_dma_end(drive);
+	return HWIF(drive)->ide_dma_end(drive);
 }
-#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+					
 
+static int auide_ddma_init(_auide_hwif *auide) {
+	
+	dbdev_tab_t source_dev_tab, target_dev_tab;
+	u32 dev_id, tsize, devwidth, flags;
+	ide_hwif_t *hwif = auide->hwif;
 
-static int auide_ddma_init( _auide_hwif *auide )
-{
-//      printk("%s\n", __FUNCTION__);
+	dev_id   = AU1XXX_ATA_DDMA_REQ;
 
-        dbdev_tab_t source_dev_tab;
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        dbdev_tab_t target_dev_tab;
-        ide_hwif_t *hwif = auide->hwif;
-        char warning_output [2][80];
-        int i;
-#endif
-
-        /* Add our custom device to DDMA device table */
-        /* Create our new device entries in the table */
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        source_dev_tab.dev_id = AU1XXX_ATA_DDMA_REQ;
+	if (auide->white_list || auide->black_list) {
+		tsize    = 8;
+		devwidth = 32;
+	}
+	else { 
+		tsize    = 1;
+		devwidth = 16;
+		
+		printk(KERN_ERR "au1xxx-ide: %s is not on ide driver whitelist.\n",auide_hwif.drive->id->model);
+		printk(KERN_ERR "            please read 'Documentation/mips/AU1xxx_IDE.README'");
+	}
 
-        if( auide->white_list || auide->black_list ){
-                source_dev_tab.dev_tsize       = 8;
-                source_dev_tab.dev_devwidth    = 32;
-                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                source_dev_tab.dev_intlevel    = 0;
-                source_dev_tab.dev_intpolarity = 0;
-
-                /* init device table for target - static bus controller - */
-                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
-                target_dev_tab.dev_tsize       = 8;
-                target_dev_tab.dev_devwidth    = 32;
-                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                target_dev_tab.dev_intlevel    = 0;
-                target_dev_tab.dev_intpolarity = 0;
-                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
-        }
-        else{
-                source_dev_tab.dev_tsize       = 1;
-                source_dev_tab.dev_devwidth    = 16;
-                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                source_dev_tab.dev_intlevel    = 0;
-                source_dev_tab.dev_intpolarity = 0;
-
-                /* init device table for target - static bus controller - */
-                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
-                target_dev_tab.dev_tsize       = 1;
-                target_dev_tab.dev_devwidth    = 16;
-                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-                target_dev_tab.dev_intlevel    = 0;
-                target_dev_tab.dev_intpolarity = 0;
-                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
-
-                sprintf(&warning_output[0][0],
-                        "%s is not on ide driver white list.",
-                        auide_hwif.drive->id->model);
-                for ( i=strlen(&warning_output[0][0]) ; i<76; i++ ){
-                        sprintf(&warning_output[0][i]," ");
-                }
-
-                sprintf(&warning_output[1][0],
-                "To add %s please read 'Documentation/mips/AU1xxx_IDE.README'.",
-                        auide_hwif.drive->id->model);
-                for ( i=strlen(&warning_output[1][0]) ; i<76; i++ ){
-                        sprintf(&warning_output[1][i]," ");
-                }
-
-                printk("\n****************************************");
-                printk("****************************************\n");
-                printk("* %s *\n",&warning_output[0][0]);
-                printk("* Switch to safe MWDMA Mode!            ");
-                printk("                                       *\n");
-                printk("* %s *\n",&warning_output[1][0]);
-                printk("****************************************");
-                printk("****************************************\n\n");
-        }
+#ifdef IDE_AU1XXX_BURSTMODE 
+	flags = DEV_FLAGS_SYNC | DEV_FLAGS_BURSTABLE;
 #else
-        source_dev_tab.dev_id = DSCR_CMD0_ALWAYS;
-        source_dev_tab.dev_tsize       = 8;
-        source_dev_tab.dev_devwidth    = 32;
-        source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
-        source_dev_tab.dev_intlevel    = 0;
-        source_dev_tab.dev_intpolarity = 0;
+	flags = DEV_FLAGS_SYNC;
 #endif
 
-#if CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
-        /* set flags for tx channel */
-        source_dev_tab.dev_flags =  DEV_FLAGS_OUT
-                                  | DEV_FLAGS_SYNC
-                                  | DEV_FLAGS_BURSTABLE;
-        auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
-        /* set flags for rx channel */
-        source_dev_tab.dev_flags =  DEV_FLAGS_IN
-                                  | DEV_FLAGS_SYNC
-                                  | DEV_FLAGS_BURSTABLE;
-        auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+	/* setup dev_tab for tx channel */
+	auide_init_dbdma_dev( &source_dev_tab,
+			      dev_id,
+			      tsize, devwidth, DEV_FLAGS_OUT | flags);
+ 	auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+
+	auide_init_dbdma_dev( &source_dev_tab,
+			      dev_id,
+			      tsize, devwidth, DEV_FLAGS_IN | flags);
+ 	auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+	
+	/* We also need to add a target device for the DMA */
+	auide_init_dbdma_dev( &target_dev_tab,
+			      (u32)DSCR_CMD0_ALWAYS,
+			      tsize, devwidth, DEV_FLAGS_ANYUSE);
+	auide->target_dev_id = au1xxx_ddma_add_device(&target_dev_tab);	
+ 
+	/* Get a channel for TX */
+	auide->tx_chan = au1xxx_dbdma_chan_alloc(auide->target_dev_id,
+						 auide->tx_dev_id,
+						 auide_ddma_tx_callback,
+						 (void*)auide);
+ 
+	/* Get a channel for RX */
+	auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+						 auide->target_dev_id,
+						 auide_ddma_rx_callback,
+						 (void*)auide);
+
+	auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,
+							     NUM_DESCRIPTORS);
+	auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,
+							     NUM_DESCRIPTORS);
+ 
+	hwif->dmatable_cpu = dma_alloc_coherent(auide->dev,
+						PRD_ENTRIES * PRD_BYTES,        /* 1 Page */
+						&hwif->dmatable_dma, GFP_KERNEL);
+	
+	au1xxx_dbdma_start( auide->tx_chan );
+	au1xxx_dbdma_start( auide->rx_chan );
+ 
+	return 0;
+} 
 #else
-        /* set flags for tx channel */
-        source_dev_tab.dev_flags = DEV_FLAGS_OUT | DEV_FLAGS_SYNC;
-        auide->tx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
-        /* set flags for rx channel */
-        source_dev_tab.dev_flags = DEV_FLAGS_IN | DEV_FLAGS_SYNC;
-        auide->rx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
-#endif
-
-#if  defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-
-        auide->target_dev_id           = au1xxx_ddma_add_device(&target_dev_tab);
+ 
+static int auide_ddma_init( _auide_hwif *auide )
+{
+	dbdev_tab_t source_dev_tab;
+	int flags;
 
-        /* Get a channel for TX */
-        auide->tx_chan = au1xxx_dbdma_chan_alloc(auide->target_dev_id,
-                                                 auide->tx_dev_id,
-                                                 auide_ddma_tx_callback,
-                                                 (void*)auide);
-        /* Get a channel for RX */
-        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
-                                                 auide->target_dev_id,
-                                                 auide_ddma_rx_callback,
-                                                 (void*)auide);
-#else   /* CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA */
-        /*
-         * Note: if call back is not enabled, update ctp->cur_ptr manually
-         */
-        auide->tx_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,
-                                                 auide->tx_dev_id,
-                                                 NULL,
-                                                 (void*)auide);
-        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
-                                                 DSCR_CMD0_ALWAYS,
-                                                 NULL,
-                                                 (void*)auide);
+#ifdef IDE_AU1XXX_BURSTMODE 
+	flags = DEV_FLAGS_SYNC | DEV_FLAGS_BURSTABLE;
+#else
+	flags = DEV_FLAGS_SYNC;
 #endif
-        auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,
-                                                             NUM_DESCRIPTORS);
-        auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,
-                                                             NUM_DESCRIPTORS);
 
-#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        hwif->dmatable_cpu = dma_alloc_coherent(auide->dev,
-                                                PRD_ENTRIES * PRD_BYTES,        /* 1 Page */
-                                                &hwif->dmatable_dma, GFP_KERNEL);
-
-        auide->sg_table = kmalloc(sizeof(struct scatterlist) * PRD_ENTRIES,
-                                GFP_KERNEL|GFP_DMA);
-        if (auide->sg_table == NULL) {
-                return -ENOMEM;
-        }
-#endif
-        au1xxx_dbdma_start( auide->tx_chan );
-        au1xxx_dbdma_start( auide->rx_chan );
-        return 0;
+	/* setup dev_tab for tx channel */
+	auide_init_dbdma_dev( &source_dev_tab,
+			      (u32)DSCR_CMD0_ALWAYS,
+			      8, 32, DEV_FLAGS_OUT | flags);
+ 	auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+
+	auide_init_dbdma_dev( &source_dev_tab,
+			      (u32)DSCR_CMD0_ALWAYS,
+			      8, 32, DEV_FLAGS_IN | flags);
+ 	auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+	
+	/* Get a channel for TX */
+	auide->tx_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,
+						 auide->tx_dev_id,
+						 NULL,
+						 (void*)auide);
+ 
+	/* Get a channel for RX */
+	auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+						 DSCR_CMD0_ALWAYS,
+						 NULL,
+						 (void*)auide);
+ 
+	auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,
+							     NUM_DESCRIPTORS);
+	auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,
+							     NUM_DESCRIPTORS);
+ 
+	au1xxx_dbdma_start( auide->tx_chan );
+	au1xxx_dbdma_start( auide->rx_chan );
+ 	
+	return 0;
 }
+#endif
 
 static void auide_setup_ports(hw_regs_t *hw, _auide_hwif *ahwif)
 {
-        int i;
-#define ide_ioreg_t unsigned long
-        ide_ioreg_t *ata_regs = hw->io_ports;
-
-	/* fixme */
-        for (i = 0; i < IDE_CONTROL_OFFSET; i++) {
-                *ata_regs++ = (ide_ioreg_t) ahwif->regbase
-                            + (ide_ioreg_t)(i << AU1XXX_ATA_REG_OFFSET);
-        }
-
-        /* set the Alternative Status register */
-        *ata_regs = (ide_ioreg_t) ahwif->regbase
-                  + (ide_ioreg_t)(14 << AU1XXX_ATA_REG_OFFSET);
+	int i;
+	unsigned long *ata_regs = hw->io_ports;
+
+	/* FIXME? */
+	for (i = 0; i < IDE_CONTROL_OFFSET; i++) {
+		*ata_regs++ = ahwif->regbase + (i << AU1XXX_ATA_REG_OFFSET);
+	}
+
+	/* set the Alternative Status register */
+	*ata_regs = ahwif->regbase + (14 << AU1XXX_ATA_REG_OFFSET);
 }
 
 static int au_ide_probe(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-        _auide_hwif *ahwif = &auide_hwif;
-        ide_hwif_t *hwif;
+	_auide_hwif *ahwif = &auide_hwif;
+	ide_hwif_t *hwif;
 	struct resource *res;
 	int ret = 0;
 
 #if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
-        char *mode = "MWDMA2";
+	char *mode = "MWDMA2";
 #elif defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
-        char *mode = "PIO+DDMA(offload)";
+	char *mode = "PIO+DDMA(offload)";
 #endif
 
-        memset(&auide_hwif, 0, sizeof(_auide_hwif));
-        auide_hwif.dev                  = 0;
+	memset(&auide_hwif, 0, sizeof(_auide_hwif));
+	auide_hwif.dev                  = 0;
 
 	ahwif->dev = dev;
 	ahwif->irq = platform_get_irq(pdev, 0);
@@ -902,11 +675,11 @@ static int au_ide_probe(struct device *d
 		goto out;
 	}
 
-        if (!request_mem_region (res->start, res->end-res->start, pdev->name)) {
+	if (!request_mem_region (res->start, res->end-res->start, pdev->name)) {
 		pr_debug("%s: request_mem_region failed\n", DRV_NAME);
-                ret =  -EBUSY;
+		ret =  -EBUSY;
 		goto out;
-        }
+	}
 
 	ahwif->regbase = (u32)ioremap(res->start, res->end-res->start);
 	if (ahwif->regbase == 0) {
@@ -914,130 +687,92 @@ static int au_ide_probe(struct device *d
 		goto out;
 	}
 
-        hwif                            = &ide_hwifs[pdev->id];
+	/* FIXME:  This might possibly break PCMCIA IDE devices */
+
+	hwif                            = &ide_hwifs[pdev->id];
 	hw_regs_t *hw 			= &hwif->hw;
-        hwif->irq = hw->irq             = ahwif->irq;
-        hwif->chipset                   = ide_au1xxx;
+	hwif->irq = hw->irq             = ahwif->irq;
+	hwif->chipset                   = ide_au1xxx;
 
-        auide_setup_ports(hw, ahwif);
+	auide_setup_ports(hw, ahwif);
 	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
 
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
-        hwif->rqsize = CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ;
-        hwif->rqsize                    = ((hwif->rqsize > AU1XXX_ATA_RQSIZE)
-                                        || (hwif->rqsize < 32)) ? AU1XXX_ATA_RQSIZE : hwif->rqsize;
-#else /* if kernel config is not set */
-        hwif->rqsize                    = AU1XXX_ATA_RQSIZE;
-#endif
-
-        hwif->ultra_mask                = 0x0;  /* Disable Ultra DMA */
+	hwif->ultra_mask                = 0x0;  /* Disable Ultra DMA */
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        hwif->mwdma_mask                = 0x07; /* Multimode-2 DMA  */
-        hwif->swdma_mask                = 0x07;
+	hwif->mwdma_mask                = 0x07; /* Multimode-2 DMA  */
+	hwif->swdma_mask                = 0x00;
 #else
-        hwif->mwdma_mask                = 0x0;
-        hwif->swdma_mask                = 0x0;
+	hwif->mwdma_mask                = 0x0;
+	hwif->swdma_mask                = 0x0;
 #endif
-        //hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
-        hwif->noprobe = 0;
-        hwif->drives[0].unmask          = 1;
-        hwif->drives[1].unmask          = 1;
-
-        /* hold should be on in all cases */
-        hwif->hold                      = 1;
-        hwif->mmio                      = 2;
-
-        /* set up local I/O function entry points */
-        hwif->INB                       = auide_inb;
-        hwif->INW                       = auide_inw;
-        hwif->INL                       = auide_inl;
-        hwif->INSW                      = auide_insw;
-        hwif->INSL                      = auide_insl;
-        hwif->OUTB                      = auide_outb;
-        hwif->OUTBSYNC                  = auide_outbsync;
-        hwif->OUTW                      = auide_outw;
-        hwif->OUTL                      = auide_outl;
-        hwif->OUTSW                     = auide_outsw;
-        hwif->OUTSL                     = auide_outsl;
 
-        hwif->tuneproc                  = &auide_tune_drive;
-        hwif->speedproc                 = &auide_tune_chipset;
+	hwif->noprobe = 0;
+	hwif->drives[0].unmask          = 1;
+	hwif->drives[1].unmask          = 1;
 
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        hwif->ide_dma_off_quietly       = &auide_dma_off_quietly;
-        hwif->ide_dma_timeout           = &auide_dma_timeout;
+	/* hold should be on in all cases */
+	hwif->hold                      = 1;
+	hwif->mmio                      = 2;
 
-        hwif->ide_dma_check             = &auide_dma_check;
-        hwif->dma_exec_cmd              = &auide_dma_exec_cmd;
-        hwif->dma_start                 = &auide_dma_start;
-        hwif->ide_dma_end               = &auide_dma_end;
-        hwif->dma_setup                 = &auide_dma_setup;
-        hwif->ide_dma_test_irq          = &auide_dma_test_irq;
-        hwif->ide_dma_host_off          = &auide_dma_host_off;
-        hwif->ide_dma_host_on           = &auide_dma_host_on;
-        hwif->ide_dma_lostirq           = &auide_dma_lostirq;
-        hwif->ide_dma_on                = &auide_dma_on;
-
-        hwif->autodma                   = 1;
-        hwif->drives[0].autodma         = hwif->autodma;
-        hwif->drives[1].autodma         = hwif->autodma;
-        hwif->atapi_dma                 = 1;
-        hwif->drives[0].using_dma       = 1;
-        hwif->drives[1].using_dma       = 1;
-#else /* !CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
-        hwif->autodma                   = 0;
-        hwif->channel                   = 0;
-        hwif->hold                      = 1;
-        hwif->select_data               = 0;    /* no chipset-specific code */
-        hwif->config_data               = 0;    /* no chipset-specific code */
-
-        hwif->drives[0].autodma         = 0;
-        hwif->drives[0].drive_data      = 0;    /* no drive data */
-        hwif->drives[0].using_dma       = 0;
-        hwif->drives[0].waiting_for_dma = 0;
-        hwif->drives[0].autotune        = 1;    /* 1=autotune, 2=noautotune, 0=default */
-        /* secondary hdd not supported */
-        hwif->drives[1].autodma         = 0;
-
-        hwif->drives[1].drive_data      = 0;
-        hwif->drives[1].using_dma       = 0;
-        hwif->drives[1].waiting_for_dma = 0;
-        hwif->drives[1].autotune        = 2;   /* 1=autotune, 2=noautotune, 0=default */
-#endif
-        hwif->drives[0].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
-        hwif->drives[1].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
+	/* If the user has selected DDMA assisted copies,
+	   then set up a few local I/O function entry points 
+	*/
 
-        /*Register Driver with PM Framework*/
-#ifdef CONFIG_PM
-        auide_hwif.pm.lock    = SPIN_LOCK_UNLOCKED;
-        auide_hwif.pm.stopped = 0;
-
-        auide_hwif.pm.dev = new_au1xxx_power_device( "ide",
-                                                &au1200ide_pm_callback,
-                                                NULL);
-        if ( auide_hwif.pm.dev == NULL )
-                printk(KERN_INFO "Unable to create a power management \
-                                device entry for the au1200-IDE.\n");
-        else
-                printk(KERN_INFO "Power management device entry for the \
-                                au1200-IDE loaded.\n");
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA	
+	hwif->INSW                      = auide_insw;
+	hwif->OUTSW                     = auide_outsw;
 #endif
 
-        auide_hwif.hwif                 = hwif;
-        hwif->hwif_data                 = &auide_hwif;
+	hwif->tuneproc                  = &auide_tune_drive;
+	hwif->speedproc                 = &auide_tune_chipset;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	hwif->ide_dma_off_quietly       = &auide_dma_off_quietly;
+	hwif->ide_dma_timeout           = &auide_dma_timeout;
+
+	hwif->ide_dma_check             = &auide_dma_check;
+	hwif->dma_exec_cmd              = &auide_dma_exec_cmd;
+	hwif->dma_start                 = &auide_dma_start;
+	hwif->ide_dma_end               = &auide_dma_end;
+	hwif->dma_setup                 = &auide_dma_setup;
+	hwif->ide_dma_test_irq          = &auide_dma_test_irq;
+	hwif->ide_dma_host_off          = &auide_dma_host_off;
+	hwif->ide_dma_host_on           = &auide_dma_host_on;
+	hwif->ide_dma_lostirq           = &auide_dma_lostirq;
+	hwif->ide_dma_on                = &auide_dma_on;
+
+	hwif->autodma                   = 1;
+	hwif->drives[0].autodma         = hwif->autodma;
+	hwif->drives[1].autodma         = hwif->autodma;
+	hwif->atapi_dma                 = 1;
 
-#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA
-        auide_ddma_init(&auide_hwif);
-        dbdma_init_done = 1;
+#else /* !CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+	hwif->autodma                   = 0;
+	hwif->channel                   = 0;
+	hwif->hold                      = 1;
+	hwif->select_data               = 0;    /* no chipset-specific code */
+	hwif->config_data               = 0;    /* no chipset-specific code */
+
+	hwif->drives[0].autodma         = 0;
+	hwif->drives[0].autotune        = 1;    /* 1=autotune, 2=noautotune, 0=default */
+#endif
+	hwif->drives[0].no_io_32bit     = 1;   
+
+	auide_hwif.hwif                 = hwif;
+	hwif->hwif_data                 = &auide_hwif;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA           
+	auide_ddma_init(&auide_hwif);
+	dbdma_init_done = 1;
 #endif
 
 	probe_hwif_init(hwif);
 	dev_set_drvdata(dev, hwif);
 
-        printk(KERN_INFO "Au1xxx IDE(builtin) configured for %s\n", mode );
+	printk(KERN_INFO "Au1xxx IDE(builtin) configured for %s\n", mode );
 
-out:
-        return ret;
+ out:
+	return ret;
 }
 
 static int au_ide_remove(struct device *dev)
@@ -1045,7 +780,7 @@ static int au_ide_remove(struct device *
 	struct platform_device *pdev = to_platform_device(dev);
 	struct resource *res;
 	ide_hwif_t *hwif = dev_get_drvdata(dev);
-        _auide_hwif *ahwif = &auide_hwif;
+	_auide_hwif *ahwif = &auide_hwif;
 
 	ide_unregister(hwif - ide_hwifs);
 
@@ -1069,180 +804,11 @@ static int __init au_ide_init(void)
 	return driver_register(&au1200_ide_driver);
 }
 
-static void __init au_ide_exit(void)
+static void __exit au_ide_exit(void)
 {
 	driver_unregister(&au1200_ide_driver);
 }
 
-#ifdef CONFIG_PM
-int au1200ide_pm_callback( au1xxx_power_dev_t *dev,\
-                        au1xxx_request_t request, void *data) {
-
-        unsigned int d, err = 0;
-        unsigned long flags;
-
-        spin_lock_irqsave(auide_hwif.pm.lock, flags);
-
-        switch (request){
-                case AU1XXX_PM_SLEEP:
-                        err = au1xxxide_pm_sleep(dev);
-                        break;
-                case AU1XXX_PM_WAKEUP:
-                        d = *((unsigned int*)data);
-                        if ( d > 0 && d <= 99) {
-                                err = au1xxxide_pm_standby(dev);
-                        }
-                        else {
-                                err = au1xxxide_pm_resume(dev);
-                        }
-                        break;
-                case AU1XXX_PM_GETSTATUS:
-                        err = au1xxxide_pm_getstatus(dev);
-                        break;
-                case AU1XXX_PM_ACCESS:
-                        err = au1xxxide_pm_access(dev);
-                        break;
-                case AU1XXX_PM_IDLE:
-                        err = au1xxxide_pm_idle(dev);
-                        break;
-                case AU1XXX_PM_CLEANUP:
-                        err = au1xxxide_pm_cleanup(dev);
-                        break;
-                default:
-                        err = -1;
-                        break;
-        }
-
-        spin_unlock_irqrestore(auide_hwif.pm.lock, flags);
-
-        return err;
-}
-
-static int au1xxxide_pm_standby( au1xxx_power_dev_t *dev ) {
-        return 0;
-}
-
-static int au1xxxide_pm_sleep( au1xxx_power_dev_t *dev ) {
-
-        int retval;
-        ide_hwif_t *hwif = auide_hwif.hwif;
-        struct request rq;
-        struct request_pm_state rqpm;
-        ide_task_t args;
-
-        if(auide_hwif.pm.stopped)
-                return -1;
-
-        /*
-         * wait until hard disc is ready
-         */
-        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
-                printk("Wait for drive sleep timeout!\n");
-                retval = -1;
-        }
-
-        /*
-         * sequenz to tell the high level ide driver that pm is resuming
-         */
-        memset(&rq, 0, sizeof(rq));
-        memset(&rqpm, 0, sizeof(rqpm));
-        memset(&args, 0, sizeof(args));
-        rq.flags = REQ_PM_SUSPEND;
-        rq.special = &args;
-        rq.pm = &rqpm;
-        rqpm.pm_step = ide_pm_state_start_suspend;
-        rqpm.pm_state = PMSG_SUSPEND;
-
-        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_wait);
-
-        if (wait_for_ready (&hwif->drives[0], 35000)) {
-                printk("Wait for drive sleep timeout!\n");
-                retval = -1;
-        }
-
-        /*
-         * stop dbdma channels
-         */
-        au1xxx_dbdma_reset(auide_hwif.tx_chan);
-        au1xxx_dbdma_reset(auide_hwif.rx_chan);
-
-        auide_hwif.pm.stopped = 1;
-
-        return retval;
-}
-
-static int au1xxxide_pm_resume( au1xxx_power_dev_t *dev ) {
-
-        int retval;
-        ide_hwif_t *hwif = auide_hwif.hwif;
-        struct request rq;
-        struct request_pm_state rqpm;
-        ide_task_t args;
-
-        if(!auide_hwif.pm.stopped)
-                return -1;
-
-        /*
-         * start dbdma channels
-         */
-        au1xxx_dbdma_start(auide_hwif.tx_chan);
-        au1xxx_dbdma_start(auide_hwif.rx_chan);
-
-        /*
-         * wait until hard disc is ready
-         */
-        if (wait_for_ready ( &hwif->drives[0], 35000)) {
-                printk("Wait for drive wake up timeout!\n");
-                retval = -1;
-        }
-
-        /*
-         * sequenz to tell the high level ide driver that pm is resuming
-         */
-        memset(&rq, 0, sizeof(rq));
-        memset(&rqpm, 0, sizeof(rqpm));
-        memset(&args, 0, sizeof(args));
-        rq.flags = REQ_PM_RESUME;
-        rq.special = &args;
-        rq.pm = &rqpm;
-        rqpm.pm_step = ide_pm_state_start_resume;
-        rqpm.pm_state = PMSG_ON;
-
-        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_head_wait);
-
-        /*
-        * wait for hard disc
-        */
-        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
-                printk("Wait for drive wake up timeout!\n");
-                retval = -1;
-        }
-
-        auide_hwif.pm.stopped = 0;
-
-        return retval;
-}
-
-static int au1xxxide_pm_getstatus( au1xxx_power_dev_t *dev ) {
-        return dev->cur_state;
-}
-
-static int au1xxxide_pm_access( au1xxx_power_dev_t *dev ) {
-        if (dev->cur_state != AWAKE_STATE)
-                return 0;
-        else
-                return -1;
-}
-
-static int au1xxxide_pm_idle( au1xxx_power_dev_t *dev ) {
-        return 0;
-}
-
-static int au1xxxide_pm_cleanup( au1xxx_power_dev_t *dev ) {
-        return 0;
-}
-#endif /* CONFIG_PM */
-
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("AU1200 IDE driver");
 
diff -purN linux-2.6.15-rc5-git3/drivers/ide/pci/sgiioc4.c linux-2.6.15-rc5-git5/drivers/ide/pci/sgiioc4.c
--- linux-2.6.15-rc5-git3/drivers/ide/pci/sgiioc4.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/pci/sgiioc4.c	2005-12-15 14:43:16.829093855 +0100
@@ -622,12 +622,18 @@ sgiioc4_ide_setup_pci_device(struct pci_
 	ide_hwif_t *hwif;
 	int h;
 
+	/*
+	 * Find an empty HWIF; if none available, return -ENOMEM.
+	 */
 	for (h = 0; h < MAX_HWIFS; ++h) {
 		hwif = &ide_hwifs[h];
-		/* Find an empty HWIF */
 		if (hwif->chipset == ide_unknown)
 			break;
 	}
+	if (h == MAX_HWIFS) {
+		printk(KERN_ERR "%s: too many IDE interfaces, no room in table\n", d->name);
+		return -ENOMEM;
+	}
 
 	/*  Get the CmdBlk and CtrlBlk Base Registers */
 	base = pci_resource_start(dev, 0) + IOC4_CMD_OFFSET;
diff -purN linux-2.6.15-rc5-git3/drivers/ide/pci/via82cxxx.c linux-2.6.15-rc5-git5/drivers/ide/pci/via82cxxx.c
--- linux-2.6.15-rc5-git3/drivers/ide/pci/via82cxxx.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/ide/pci/via82cxxx.c	2005-12-15 14:43:16.830093698 +0100
@@ -80,6 +80,7 @@ static struct via_isa_bridge {
 	u16 flags;
 } via_isa_bridges[] = {
 	{ "vt6410",	PCI_DEVICE_ID_VIA_6410,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
+	{ "vt8251",	PCI_DEVICE_ID_VIA_8251,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8237",	PCI_DEVICE_ID_VIA_8237,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8235",	PCI_DEVICE_ID_VIA_8235,     0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
 	{ "vt8233a",	PCI_DEVICE_ID_VIA_8233A,    0x00, 0x2f, VIA_UDMA_133 | VIA_BAD_AST },
diff -purN linux-2.6.15-rc5-git3/drivers/input/mouse/alps.c linux-2.6.15-rc5-git5/drivers/input/mouse/alps.c
--- linux-2.6.15-rc5-git3/drivers/input/mouse/alps.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/input/mouse/alps.c	2005-12-15 14:43:16.831093542 +0100
@@ -42,7 +42,7 @@ static struct alps_model_info alps_model
 	{ { 0x53, 0x02, 0x14 },	0xf8, 0xf8, 0 },
 	{ { 0x63, 0x02, 0x0a },	0xf8, 0xf8, 0 },
 	{ { 0x63, 0x02, 0x14 },	0xf8, 0xf8, 0 },
-	{ { 0x63, 0x02, 0x28 },	0xf8, 0xf8, 0 },
+	{ { 0x63, 0x02, 0x28 },	0xf8, 0xf8, ALPS_FW_BK_2 },		/* Fujitsu Siemens S6010 */
 	{ { 0x63, 0x02, 0x3c },	0x8f, 0x8f, ALPS_WHEEL },		/* Toshiba Satellite S2400-103 */
 	{ { 0x63, 0x02, 0x50 },	0xef, 0xef, ALPS_FW_BK_1 },		/* NEC Versa L320 */
 	{ { 0x63, 0x02, 0x64 },	0xf8, 0xf8, 0 },
diff -purN linux-2.6.15-rc5-git3/drivers/mmc/mmc.c linux-2.6.15-rc5-git5/drivers/mmc/mmc.c
--- linux-2.6.15-rc5-git3/drivers/mmc/mmc.c	2005-12-15 14:43:10.530151190 +0100
+++ linux-2.6.15-rc5-git5/drivers/mmc/mmc.c	2005-12-15 14:43:17.091052785 +0100
@@ -679,7 +679,15 @@ static void mmc_idle_cards(struct mmc_ho
 }
 
 /*
- * Apply power to the MMC stack.
+ * Apply power to the MMC stack.  This is a two-stage process.
+ * First, we enable power to the card without the clock running.
+ * We then wait a bit for the power to stabilise.  Finally,
+ * enable the bus drivers and clock to the card.
+ *
+ * We must _NOT_ enable the clock prior to power stablising.
+ *
+ * If a host does all the power sequencing itself, ignore the
+ * initial MMC_POWER_UP stage.
  */
 static void mmc_power_up(struct mmc_host *host)
 {
diff -purN linux-2.6.15-rc5-git3/drivers/net/skge.c linux-2.6.15-rc5-git5/drivers/net/skge.c
--- linux-2.6.15-rc5-git3/drivers/net/skge.c	2005-12-15 14:43:10.550148055 +0100
+++ linux-2.6.15-rc5-git5/drivers/net/skge.c	2005-12-15 14:43:17.110049807 +0100
@@ -2280,7 +2280,7 @@ static int skge_xmit_frame(struct sk_buf
  	}
 
 	if (unlikely(skge->tx_avail < skb_shinfo(skb)->nr_frags +1)) {
-		if (!netif_stopped(dev)) {
+		if (!netif_queue_stopped(dev)) {
 			netif_stop_queue(dev);
 
 			printk(KERN_WARNING PFX "%s: ring full when queue awake!\n",
diff -purN linux-2.6.15-rc5-git3/drivers/net/tg3.c linux-2.6.15-rc5-git5/drivers/net/tg3.c
--- linux-2.6.15-rc5-git3/drivers/net/tg3.c	2005-12-15 14:43:10.566145547 +0100
+++ linux-2.6.15-rc5-git5/drivers/net/tg3.c	2005-12-15 14:43:17.128046985 +0100
@@ -68,8 +68,8 @@
 
 #define DRV_MODULE_NAME		"tg3"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"3.44"
-#define DRV_MODULE_RELDATE	"Dec 6, 2005"
+#define DRV_MODULE_VERSION	"3.45"
+#define DRV_MODULE_RELDATE	"Dec 13, 2005"
 
 #define TG3_DEF_MAC_MODE	0
 #define TG3_DEF_RX_MODE		0
@@ -1025,7 +1025,9 @@ static void tg3_frob_aux_power(struct tg
 
 
 	if ((tp->tg3_flags & TG3_FLAG_WOL_ENABLE) != 0 ||
-	    (tp_peer->tg3_flags & TG3_FLAG_WOL_ENABLE) != 0) {
+	    (tp->tg3_flags & TG3_FLAG_ENABLE_ASF) != 0 ||
+	    (tp_peer->tg3_flags & TG3_FLAG_WOL_ENABLE) != 0 ||
+	    (tp_peer->tg3_flags & TG3_FLAG_ENABLE_ASF) != 0) {
 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 ||
 		    GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701) {
 			tw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |
@@ -1105,6 +1107,8 @@ static int tg3_setup_phy(struct tg3 *, i
 
 static void tg3_write_sig_post_reset(struct tg3 *, int);
 static int tg3_halt_cpu(struct tg3 *, u32);
+static int tg3_nvram_lock(struct tg3 *);
+static void tg3_nvram_unlock(struct tg3 *);
 
 static int tg3_set_power_state(struct tg3 *tp, int state)
 {
@@ -1179,6 +1183,21 @@ static int tg3_set_power_state(struct tg
 		tg3_setup_phy(tp, 0);
 	}
 
+	if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+		int i;
+		u32 val;
+
+		for (i = 0; i < 200; i++) {
+			tg3_read_mem(tp, NIC_SRAM_FW_ASF_STATUS_MBOX, &val);
+			if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+				break;
+			msleep(1);
+		}
+	}
+	tg3_write_mem(tp, NIC_SRAM_WOL_MBOX, WOL_SIGNATURE |
+					     WOL_DRV_STATE_SHUTDOWN |
+					     WOL_DRV_WOL | WOL_SET_MAGIC_PKT);
+
 	pci_read_config_word(tp->pdev, pm + PCI_PM_PMC, &power_caps);
 
 	if (tp->tg3_flags & TG3_FLAG_WOL_ENABLE) {
@@ -1268,6 +1287,17 @@ static int tg3_set_power_state(struct tg
 		}
 	}
 
+	if (!(tp->tg3_flags & TG3_FLAG_WOL_ENABLE) &&
+	    !(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+		/* Turn off the PHY */
+		if (!(tp->tg3_flags2 & TG3_FLG2_PHY_SERDES)) {
+			tg3_writephy(tp, MII_TG3_EXT_CTRL,
+				     MII_TG3_EXT_CTRL_FORCE_LED_OFF);
+			tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x01b2);
+			tg3_writephy(tp, MII_BMCR, BMCR_PDOWN);
+		}
+	}
+
 	tg3_frob_aux_power(tp);
 
 	/* Workaround for unstable PLL clock */
@@ -1277,8 +1307,12 @@ static int tg3_set_power_state(struct tg
 
 		val &= ~((1 << 16) | (1 << 4) | (1 << 2) | (1 << 1) | 1);
 		tw32(0x7d00, val);
-		if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF))
+		if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+			tg3_nvram_lock(tp);
 			tg3_halt_cpu(tp, RX_CPU_BASE);
+			tw32_f(NVRAM_SWARB, SWARB_REQ_CLR0);
+			tg3_nvram_unlock(tp);
+		}
 	}
 
 	/* Finally, set the new power state. */
@@ -1812,7 +1846,7 @@ static int tg3_setup_copper_phy(struct t
 		}
 	}
 relink:
-	if (current_link_up == 0) {
+	if (current_link_up == 0 || tp->link_config.phy_is_low_power) {
 		u32 tmp;
 
 		tg3_phy_copper_begin(tp);
@@ -8533,6 +8567,7 @@ static void __devinit tg3_nvram_init(str
 	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) {
 		tp->tg3_flags |= TG3_FLAG_NVRAM;
 
+		tg3_nvram_lock(tp);
 		tg3_enable_nvram_access(tp);
 
 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5752)
@@ -8543,6 +8578,7 @@ static void __devinit tg3_nvram_init(str
 		tg3_get_nvram_size(tp);
 
 		tg3_disable_nvram_access(tp);
+		tg3_nvram_unlock(tp);
 
 	} else {
 		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
@@ -8640,10 +8676,10 @@ static int tg3_nvram_read(struct tg3 *tp
 	if (ret == 0)
 		*val = swab32(tr32(NVRAM_RDDATA));
 
-	tg3_nvram_unlock(tp);
-
 	tg3_disable_nvram_access(tp);
 
+	tg3_nvram_unlock(tp);
+
 	return ret;
 }
 
@@ -8728,6 +8764,10 @@ static int tg3_nvram_write_block_unbuffe
 
 		offset = offset + (pagesize - page_off);
 
+		/* Nvram lock released by tg3_nvram_read() above,
+		 * so need to get it again.
+		 */
+		tg3_nvram_lock(tp);
 		tg3_enable_nvram_access(tp);
 
 		/*
@@ -10437,8 +10477,13 @@ static struct pci_dev * __devinit tg3_fi
 			break;
 		pci_dev_put(peer);
 	}
-	if (!peer || peer == tp->pdev)
-		BUG();
+	/* 5704 can be configured in single-port mode, set peer to
+	 * tp->pdev in that case.
+	 */
+	if (!peer) {
+		peer = tp->pdev;
+		return peer;
+	}
 
 	/*
 	 * We don't need to keep the refcount elevated; there's no way
@@ -10820,12 +10865,14 @@ static int tg3_suspend(struct pci_dev *p
 
 	tg3_full_lock(tp, 0);
 	tg3_halt(tp, RESET_KIND_SHUTDOWN, 1);
+	tp->tg3_flags &= ~TG3_FLAG_INIT_COMPLETE;
 	tg3_full_unlock(tp);
 
 	err = tg3_set_power_state(tp, pci_choose_state(pdev, state));
 	if (err) {
 		tg3_full_lock(tp, 0);
 
+		tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
 		tg3_init_hw(tp);
 
 		tp->timer.expires = jiffies + tp->timer_offset;
@@ -10859,6 +10906,7 @@ static int tg3_resume(struct pci_dev *pd
 
 	tg3_full_lock(tp, 0);
 
+	tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
 	tg3_init_hw(tp);
 
 	tp->timer.expires = jiffies + tp->timer_offset;
diff -purN linux-2.6.15-rc5-git3/drivers/net/tg3.h linux-2.6.15-rc5-git5/drivers/net/tg3.h
--- linux-2.6.15-rc5-git3/drivers/net/tg3.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/net/tg3.h	2005-12-15 14:43:17.133046201 +0100
@@ -1529,6 +1529,12 @@
 #define NIC_SRAM_MAC_ADDR_HIGH_MBOX	0x00000c14
 #define NIC_SRAM_MAC_ADDR_LOW_MBOX	0x00000c18
 
+#define NIC_SRAM_WOL_MBOX		0x00000d30
+#define  WOL_SIGNATURE			 0x474c0000
+#define  WOL_DRV_STATE_SHUTDOWN		 0x00000001
+#define  WOL_DRV_WOL			 0x00000002
+#define  WOL_SET_MAGIC_PKT		 0x00000004
+
 #define NIC_SRAM_DATA_CFG_2		0x00000d38
 
 #define  SHASTA_EXT_LED_MODE_MASK	 0x00018000
@@ -1565,6 +1571,7 @@
 #define MII_TG3_EXT_CTRL		0x10 /* Extended control register */
 #define  MII_TG3_EXT_CTRL_FIFO_ELASTIC	0x0001
 #define  MII_TG3_EXT_CTRL_LNK3_LED_MODE	0x0002
+#define  MII_TG3_EXT_CTRL_FORCE_LED_OFF	0x0008
 #define  MII_TG3_EXT_CTRL_TBI		0x8000
 
 #define MII_TG3_EXT_STAT		0x11 /* Extended status register */
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/ibmvscsi/ibmvscsi.h linux-2.6.15-rc5-git5/drivers/scsi/ibmvscsi/ibmvscsi.h
--- linux-2.6.15-rc5-git3/drivers/scsi/ibmvscsi/ibmvscsi.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/ibmvscsi/ibmvscsi.h	2005-12-15 14:43:17.134046045 +0100
@@ -100,7 +100,7 @@ int ibmvscsi_init_crq_queue(struct crq_q
 void ibmvscsi_release_crq_queue(struct crq_queue *queue,
 				struct ibmvscsi_host_data *hostdata,
 				int max_requests);
-void ibmvscsi_reset_crq_queue(struct crq_queue *queue,
+int ibmvscsi_reset_crq_queue(struct crq_queue *queue,
 			      struct ibmvscsi_host_data *hostdata);
 
 void ibmvscsi_handle_crq(struct viosrp_crq *crq,
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/ibmvscsi/iseries_vscsi.c linux-2.6.15-rc5-git5/drivers/scsi/ibmvscsi/iseries_vscsi.c
--- linux-2.6.15-rc5-git3/drivers/scsi/ibmvscsi/iseries_vscsi.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/ibmvscsi/iseries_vscsi.c	2005-12-15 14:43:17.135045888 +0100
@@ -117,9 +117,10 @@ void ibmvscsi_release_crq_queue(struct c
  *
  * no-op for iSeries
  */
-void ibmvscsi_reset_crq_queue(struct crq_queue *queue,
+int ibmvscsi_reset_crq_queue(struct crq_queue *queue,
 			      struct ibmvscsi_host_data *hostdata)
 {
+	return 0;
 }
 
 /**
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/ibmvscsi/rpa_vscsi.c linux-2.6.15-rc5-git5/drivers/scsi/ibmvscsi/rpa_vscsi.c
--- linux-2.6.15-rc5-git3/drivers/scsi/ibmvscsi/rpa_vscsi.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/ibmvscsi/rpa_vscsi.c	2005-12-15 14:43:17.137045574 +0100
@@ -230,6 +230,11 @@ int ibmvscsi_init_crq_queue(struct crq_q
 	rc = plpar_hcall_norets(H_REG_CRQ,
 				vdev->unit_address,
 				queue->msg_token, PAGE_SIZE);
+	if (rc == H_Resource) 
+		/* maybe kexecing and resource is busy. try a reset */
+		rc = ibmvscsi_reset_crq_queue(queue,
+					      hostdata);
+
 	if (rc == 2) {
 		/* Adapter is good, but other end is not ready */
 		printk(KERN_WARNING "ibmvscsi: Partner adapter not ready\n");
@@ -281,7 +286,7 @@ int ibmvscsi_init_crq_queue(struct crq_q
  * @hostdata:	ibmvscsi_host_data of host
  *
  */
-void ibmvscsi_reset_crq_queue(struct crq_queue *queue,
+int ibmvscsi_reset_crq_queue(struct crq_queue *queue,
 			      struct ibmvscsi_host_data *hostdata)
 {
 	int rc;
@@ -309,4 +314,5 @@ void ibmvscsi_reset_crq_queue(struct crq
 		printk(KERN_WARNING
 		       "ibmvscsi: couldn't register crq--rc 0x%x\n", rc);
 	}
+	return rc;
 }
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/libata-scsi.c linux-2.6.15-rc5-git5/drivers/scsi/libata-scsi.c
--- linux-2.6.15-rc5-git3/drivers/scsi/libata-scsi.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/libata-scsi.c	2005-12-15 14:43:17.147044007 +0100
@@ -2173,9 +2173,12 @@ ata_scsi_find_dev(struct ata_port *ap, c
 	if (unlikely(!ata_dev_present(dev)))
 		return NULL;
 
-	if (!atapi_enabled) {
-		if (unlikely(dev->class == ATA_DEV_ATAPI))
+	if (!atapi_enabled || (ap->flags & ATA_FLAG_NO_ATAPI)) {
+		if (unlikely(dev->class == ATA_DEV_ATAPI)) {
+			printk(KERN_WARNING "ata%u(%u): WARNING: ATAPI is %s, device ignored.\n",
+			       ap->id, dev->devno, atapi_enabled ? "not supported with this driver" : "disabled");
 			return NULL;
+		}
 	}
 
 	return dev;
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/megaraid.c linux-2.6.15-rc5-git5/drivers/scsi/megaraid.c
--- linux-2.6.15-rc5-git3/drivers/scsi/megaraid.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/megaraid.c	2005-12-15 14:43:17.154042909 +0100
@@ -664,7 +664,7 @@ mega_build_cmd(adapter_t *adapter, Scsi_
 					sg->offset;
 			} else
 				buf = cmd->request_buffer;
-			memset(cmd->request_buffer, 0, cmd->cmnd[4]);
+			memset(buf, 0, cmd->cmnd[4]);
 			if (cmd->use_sg) {
 				struct scatterlist *sg;
 
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/qla2xxx/qla_def.h linux-2.6.15-rc5-git5/drivers/scsi/qla2xxx/qla_def.h
--- linux-2.6.15-rc5-git3/drivers/scsi/qla2xxx/qla_def.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/qla2xxx/qla_def.h	2005-12-15 14:43:17.158042282 +0100
@@ -2476,17 +2476,9 @@ typedef struct scsi_qla_host {
  */
 #define LOOP_TRANSITION(ha) \
 	(test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) || \
-	 test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
-
-#define LOOP_NOT_READY(ha) \
-	((test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) || \
-	  test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags) || \
-	  test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags) || \
-	  test_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags)) || \
+	 test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags) || \
 	 atomic_read(&ha->loop_state) == LOOP_DOWN)
 
-#define LOOP_RDY(ha)	(!LOOP_NOT_READY(ha))
-
 #define TGT_Q(ha, t) (ha->otgt[t])
 
 #define to_qla_host(x)		((scsi_qla_host_t *) (x)->hostdata)
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/qla2xxx/qla_init.c linux-2.6.15-rc5-git5/drivers/scsi/qla2xxx/qla_init.c
--- linux-2.6.15-rc5-git3/drivers/scsi/qla2xxx/qla_init.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/qla2xxx/qla_init.c	2005-12-15 14:43:17.164041342 +0100
@@ -1259,7 +1259,7 @@ qla2x00_configure_hba(scsi_qla_host_t *h
 	rval = qla2x00_get_adapter_id(ha,
 	    &loop_id, &al_pa, &area, &domain, &topo);
 	if (rval != QLA_SUCCESS) {
-		if (LOOP_NOT_READY(ha) || atomic_read(&ha->loop_down_timer) ||
+		if (LOOP_TRANSITION(ha) || atomic_read(&ha->loop_down_timer) ||
 		    (rval == QLA_COMMAND_ERROR && loop_id == 0x7)) {
 			DEBUG2(printk("%s(%ld) Loop is in a transition state\n",
 			    __func__, ha->host_no));
@@ -1796,7 +1796,7 @@ qla2x00_configure_loop(scsi_qla_host_t *
 	}
 
 	if (rval == QLA_SUCCESS && test_bit(RSCN_UPDATE, &flags)) {
-		if (LOOP_NOT_READY(ha)) {
+		if (LOOP_TRANSITION(ha)) {
 			rval = QLA_FUNCTION_FAILED;
 		} else {
 			rval = qla2x00_configure_fabric(ha);
@@ -2369,7 +2369,7 @@ qla2x00_find_all_fabric_devs(scsi_qla_ho
 		if (qla2x00_is_reserved_id(ha, loop_id))
 			continue;
 
-		if (atomic_read(&ha->loop_down_timer) || LOOP_NOT_READY(ha))
+		if (atomic_read(&ha->loop_down_timer) || LOOP_TRANSITION(ha))
 			break;
 
 		if (swl != NULL) {
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/qla2xxx/qla_isr.c linux-2.6.15-rc5-git5/drivers/scsi/qla2xxx/qla_isr.c
--- linux-2.6.15-rc5-git3/drivers/scsi/qla2xxx/qla_isr.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/qla2xxx/qla_isr.c	2005-12-15 14:43:17.167040872 +0100
@@ -909,6 +909,21 @@ qla2x00_status_entry(scsi_qla_host_t *ha
 			resid = resid_len;
 			cp->resid = resid;
 			CMD_RESID_LEN(cp) = resid;
+
+			if (!lscsi_status &&
+			    ((unsigned)(cp->request_bufflen - resid) <
+			     cp->underflow)) {
+				qla_printk(KERN_INFO, ha,
+				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
+				    "detected (%x of %x bytes)...returning "
+				    "error status.\n", ha->host_no,
+				    cp->device->channel, cp->device->id,
+				    cp->device->lun, resid,
+				    cp->request_bufflen);
+
+				cp->result = DID_ERROR << 16;
+				break;
+			}
 		}
 		cp->result = DID_OK << 16 | lscsi_status;
 
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/sata_mv.c linux-2.6.15-rc5-git5/drivers/scsi/sata_mv.c
--- linux-2.6.15-rc5-git3/drivers/scsi/sata_mv.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/sata_mv.c	2005-12-15 14:43:17.170040401 +0100
@@ -86,7 +86,8 @@ enum {
 	MV_FLAG_DUAL_HC		= (1 << 30),  /* two SATA Host Controllers */
 	MV_FLAG_IRQ_COALESCE	= (1 << 29),  /* IRQ coalescing capability */
 	MV_COMMON_FLAGS		= (ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				   ATA_FLAG_SATA_RESET | ATA_FLAG_MMIO),
+				   ATA_FLAG_SATA_RESET | ATA_FLAG_MMIO |
+				   ATA_FLAG_NO_ATAPI),
 	MV_6XXX_FLAGS		= MV_FLAG_IRQ_COALESCE,
 
 	CRQB_FLAG_READ		= (1 << 0),
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/sata_promise.c linux-2.6.15-rc5-git5/drivers/scsi/sata_promise.c
--- linux-2.6.15-rc5-git3/drivers/scsi/sata_promise.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/sata_promise.c	2005-12-15 14:43:17.172040088 +0100
@@ -70,6 +70,9 @@ enum {
 	PDC_HAS_PATA		= (1 << 1), /* PDC20375 has PATA */
 
 	PDC_RESET		= (1 << 11), /* HDMA reset */
+
+	PDC_COMMON_FLAGS	= ATA_FLAG_NO_LEGACY | ATA_FLAG_SRST |
+				  ATA_FLAG_MMIO | ATA_FLAG_NO_ATAPI,
 };
 
 
@@ -162,8 +165,7 @@ static struct ata_port_info pdc_port_inf
 	/* board_2037x */
 	{
 		.sht		= &pdc_ata_sht,
-		.host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				  ATA_FLAG_SRST | ATA_FLAG_MMIO,
+		.host_flags	= PDC_COMMON_FLAGS | ATA_FLAG_SATA,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
@@ -173,8 +175,7 @@ static struct ata_port_info pdc_port_inf
 	/* board_20319 */
 	{
 		.sht		= &pdc_ata_sht,
-		.host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				  ATA_FLAG_SRST | ATA_FLAG_MMIO,
+		.host_flags	= PDC_COMMON_FLAGS | ATA_FLAG_SATA,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
@@ -184,8 +185,7 @@ static struct ata_port_info pdc_port_inf
 	/* board_20619 */
 	{
 		.sht		= &pdc_ata_sht,
-		.host_flags	= ATA_FLAG_NO_LEGACY | ATA_FLAG_SRST |
-				  ATA_FLAG_MMIO | ATA_FLAG_SLAVE_POSS,
+		.host_flags	= PDC_COMMON_FLAGS | ATA_FLAG_SLAVE_POSS,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/sata_sx4.c linux-2.6.15-rc5-git5/drivers/scsi/sata_sx4.c
--- linux-2.6.15-rc5-git3/drivers/scsi/sata_sx4.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/sata_sx4.c	2005-12-15 14:43:17.175039618 +0100
@@ -220,7 +220,8 @@ static struct ata_port_info pdc_port_inf
 	{
 		.sht		= &pdc_sata_sht,
 		.host_flags	= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				  ATA_FLAG_SRST | ATA_FLAG_MMIO,
+				  ATA_FLAG_SRST | ATA_FLAG_MMIO |
+				  ATA_FLAG_NO_ATAPI,
 		.pio_mask	= 0x1f, /* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
 		.udma_mask	= 0x7f, /* udma0-6 ; FIXME */
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/scsi_error.c linux-2.6.15-rc5-git5/drivers/scsi/scsi_error.c
--- linux-2.6.15-rc5-git3/drivers/scsi/scsi_error.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/scsi_error.c	2005-12-15 14:43:17.178039147 +0100
@@ -422,10 +422,15 @@ static int scsi_eh_completed_normally(st
  **/
 static void scsi_eh_done(struct scsi_cmnd *scmd)
 {
+	struct completion     *eh_action;
+
 	SCSI_LOG_ERROR_RECOVERY(3,
 		printk("%s scmd: %p result: %x\n",
 			__FUNCTION__, scmd, scmd->result));
-	complete(scmd->device->host->eh_action);
+
+	eh_action = scmd->device->host->eh_action;
+	if (eh_action)
+		complete(eh_action);
 }
 
 /**
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/scsi_lib.c linux-2.6.15-rc5-git5/drivers/scsi/scsi_lib.c
--- linux-2.6.15-rc5-git3/drivers/scsi/scsi_lib.c	2005-12-15 14:43:10.577143823 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/scsi_lib.c	2005-12-15 14:43:17.182038520 +0100
@@ -1085,6 +1085,26 @@ static void scsi_generic_done(struct scs
 	scsi_io_completion(cmd, cmd->result == 0 ? cmd->bufflen : 0, 0);
 }
 
+void scsi_setup_blk_pc_cmnd(struct scsi_cmnd *cmd, int retries)
+{
+	struct request *req = cmd->request;
+
+	BUG_ON(sizeof(req->cmd) > sizeof(cmd->cmnd));
+	memcpy(cmd->cmnd, req->cmd, sizeof(cmd->cmnd));
+	cmd->cmd_len = req->cmd_len;
+	if (!req->data_len)
+		cmd->sc_data_direction = DMA_NONE;
+	else if (rq_data_dir(req) == WRITE)
+		cmd->sc_data_direction = DMA_TO_DEVICE;
+	else
+		cmd->sc_data_direction = DMA_FROM_DEVICE;
+	
+	cmd->transfersize = req->data_len;
+	cmd->allowed = retries;
+	cmd->timeout_per_command = req->timeout;
+}
+EXPORT_SYMBOL_GPL(scsi_setup_blk_pc_cmnd);
+
 static int scsi_prep_fn(struct request_queue *q, struct request *req)
 {
 	struct scsi_device *sdev = q->queuedata;
@@ -1220,18 +1240,7 @@ static int scsi_prep_fn(struct request_q
 				goto kill;
 			}
 		} else {
-			memcpy(cmd->cmnd, req->cmd, sizeof(cmd->cmnd));
-			cmd->cmd_len = req->cmd_len;
-			if (rq_data_dir(req) == WRITE)
-				cmd->sc_data_direction = DMA_TO_DEVICE;
-			else if (req->data_len)
-				cmd->sc_data_direction = DMA_FROM_DEVICE;
-			else
-				cmd->sc_data_direction = DMA_NONE;
-			
-			cmd->transfersize = req->data_len;
-			cmd->allowed = 3;
-			cmd->timeout_per_command = req->timeout;
+			scsi_setup_blk_pc_cmnd(cmd, 3);
 			cmd->done = scsi_generic_done;
 		}
 	}
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/sd.c linux-2.6.15-rc5-git5/drivers/scsi/sd.c
--- linux-2.6.15-rc5-git3/drivers/scsi/sd.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/sd.c	2005-12-15 14:43:17.188037580 +0100
@@ -245,24 +245,10 @@ static int sd_init_command(struct scsi_c
 	 * SG_IO from block layer already setup, just copy cdb basically
 	 */
 	if (blk_pc_request(rq)) {
-		if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
-			return 0;
-
-		memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
-		SCpnt->cmd_len = rq->cmd_len;
-		if (rq_data_dir(rq) == WRITE)
-			SCpnt->sc_data_direction = DMA_TO_DEVICE;
-		else if (rq->data_len)
-			SCpnt->sc_data_direction = DMA_FROM_DEVICE;
-		else
-			SCpnt->sc_data_direction = DMA_NONE;
-
-		this_count = rq->data_len;
+		scsi_setup_blk_pc_cmnd(SCpnt, SD_PASSTHROUGH_RETRIES);
 		if (rq->timeout)
 			timeout = rq->timeout;
 
-		SCpnt->transfersize = rq->data_len;
-		SCpnt->allowed = SD_PASSTHROUGH_RETRIES;
 		goto queue;
 	}
 
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/sr.c linux-2.6.15-rc5-git5/drivers/scsi/sr.c
--- linux-2.6.15-rc5-git3/drivers/scsi/sr.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/sr.c	2005-12-15 14:43:17.190037266 +0100
@@ -320,25 +320,11 @@ static int sr_init_command(struct scsi_c
 	 * these are already setup, just copy cdb basically
 	 */
 	if (SCpnt->request->flags & REQ_BLOCK_PC) {
-		struct request *rq = SCpnt->request;
+		scsi_setup_blk_pc_cmnd(SCpnt, MAX_RETRIES);
 
-		if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
-			return 0;
-
-		memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
-		SCpnt->cmd_len = rq->cmd_len;
-		if (!rq->data_len)
-			SCpnt->sc_data_direction = DMA_NONE;
-		else if (rq_data_dir(rq) == WRITE)
-			SCpnt->sc_data_direction = DMA_TO_DEVICE;
-		else
-			SCpnt->sc_data_direction = DMA_FROM_DEVICE;
-
-		this_count = rq->data_len;
-		if (rq->timeout)
-			timeout = rq->timeout;
+		if (SCpnt->timeout_per_command)
+			timeout = SCpnt->timeout_per_command;
 
-		SCpnt->transfersize = rq->data_len;
 		goto queue;
 	}
 
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/st.c linux-2.6.15-rc5-git5/drivers/scsi/st.c
--- linux-2.6.15-rc5-git3/drivers/scsi/st.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/st.c	2005-12-15 14:43:17.197036169 +0100
@@ -4194,27 +4194,10 @@ static void st_intr(struct scsi_cmnd *SC
  */
 static int st_init_command(struct scsi_cmnd *SCpnt)
 {
-	struct request *rq;
-
 	if (!(SCpnt->request->flags & REQ_BLOCK_PC))
 		return 0;
 
-	rq = SCpnt->request;
-	if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
-		return 0;
-
-	memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
-	SCpnt->cmd_len = rq->cmd_len;
-
-	if (rq_data_dir(rq) == WRITE)
-		SCpnt->sc_data_direction = DMA_TO_DEVICE;
-	else if (rq->data_len)
-		SCpnt->sc_data_direction = DMA_FROM_DEVICE;
-	else
-		SCpnt->sc_data_direction = DMA_NONE;
-
-	SCpnt->timeout_per_command = rq->timeout;
-	SCpnt->transfersize = rq->data_len;
+	scsi_setup_blk_pc_cmnd(SCpnt, 0);
 	SCpnt->done = st_intr;
 	return 1;
 }
diff -purN linux-2.6.15-rc5-git3/drivers/scsi/sym53c8xx_2/sym_hipd.c linux-2.6.15-rc5-git5/drivers/scsi/sym53c8xx_2/sym_hipd.c
--- linux-2.6.15-rc5-git3/drivers/scsi/sym53c8xx_2/sym_hipd.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/scsi/sym53c8xx_2/sym_hipd.c	2005-12-15 14:43:17.205034915 +0100
@@ -1405,7 +1405,6 @@ static void sym_check_goals(struct sym_h
 		goal->iu = 0;
 		goal->dt = 0;
 		goal->qas = 0;
-		goal->period = 0;
 		goal->offset = 0;
 		return;
 	}
@@ -1465,7 +1464,8 @@ static int sym_prepare_nego(struct sym_h
 	 * Many devices implement PPR in a buggy way, so only use it if we
 	 * really want to.
 	 */
-	if (goal->iu || goal->dt || goal->qas || (goal->period < 0xa)) {
+	if (goal->offset &&
+	    (goal->iu || goal->dt || goal->qas || (goal->period < 0xa))) {
 		nego = NS_PPR;
 	} else if (spi_width(starget) != goal->width) {
 		nego = NS_WIDE;
diff -purN linux-2.6.15-rc5-git3/drivers/usb/input/hid-core.c linux-2.6.15-rc5-git5/drivers/usb/input/hid-core.c
--- linux-2.6.15-rc5-git3/drivers/usb/input/hid-core.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/usb/input/hid-core.c	2005-12-15 14:43:17.212033818 +0100
@@ -893,8 +893,10 @@ static int hid_input_report(int type, st
 
 	size = ((report->size - 1) >> 3) + 1;
 
-	if (len < size)
+	if (len < size) {
 		dbg("report %d is too short, (%d < %d)", report->id, len, size);
+		memset(data + len, 0, size - len);
+	}
 
 	if (hid->claimed & HID_CLAIMED_HIDDEV)
 		hiddev_report_event(hid, report);
diff -purN linux-2.6.15-rc5-git3/drivers/video/pxafb.c linux-2.6.15-rc5-git5/drivers/video/pxafb.c
--- linux-2.6.15-rc5-git3/drivers/video/pxafb.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/drivers/video/pxafb.c	2005-12-15 14:43:17.237163217 +0100
@@ -1396,7 +1396,8 @@ static struct platform_driver pxafb_driv
 int __devinit pxafb_setup(char *options)
 {
 # ifdef CONFIG_FB_PXA_PARAMETERS
-	strlcpy(g_options, options, sizeof(g_options));
+	if (options)
+		strlcpy(g_options, options, sizeof(g_options));
 # endif
 	return 0;
 }
diff -purN linux-2.6.15-rc5-git3/fs/reiserfs/inode.c linux-2.6.15-rc5-git5/fs/reiserfs/inode.c
--- linux-2.6.15-rc5-git3/fs/reiserfs/inode.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/fs/reiserfs/inode.c	2005-12-15 14:43:17.246161806 +0100
@@ -32,6 +32,7 @@ void reiserfs_delete_inode(struct inode 
 	    JOURNAL_PER_BALANCE_CNT * 2 +
 	    2 * REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb);
 	struct reiserfs_transaction_handle th;
+	int err;
 
 	truncate_inode_pages(&inode->i_data, 0);
 
@@ -49,15 +50,13 @@ void reiserfs_delete_inode(struct inode 
 		}
 		reiserfs_update_inode_transaction(inode);
 
-		if (reiserfs_delete_object(&th, inode)) {
-			up(&inode->i_sem);
-			goto out;
-		}
+		err = reiserfs_delete_object(&th, inode);
 
 		/* Do quota update inside a transaction for journaled quotas. We must do that
 		 * after delete_object so that quota updates go into the same transaction as
 		 * stat data deletion */
-		DQUOT_FREE_INODE(inode);
+		if (!err) 
+			DQUOT_FREE_INODE(inode);
 
 		if (journal_end(&th, inode->i_sb, jbegin_count)) {
 			up(&inode->i_sem);
@@ -66,6 +65,12 @@ void reiserfs_delete_inode(struct inode 
 
 		up(&inode->i_sem);
 
+		/* check return value from reiserfs_delete_object after
+		 * ending the transaction
+		 */
+		if (err)
+		    goto out;
+
 		/* all items of file are deleted, so we can remove "save" link */
 		remove_save_link(inode, 0 /* not truncate */ );	/* we can't do anything
 								 * about an error here */
@@ -2099,6 +2104,7 @@ int reiserfs_truncate_file(struct inode 
 	struct page *page = NULL;
 	int error;
 	struct buffer_head *bh = NULL;
+	int err2;
 
 	reiserfs_write_lock(p_s_inode->i_sb);
 
@@ -2136,14 +2142,18 @@ int reiserfs_truncate_file(struct inode 
 		   transaction of truncating gets committed - on reboot the file
 		   either appears truncated properly or not truncated at all */
 		add_save_link(&th, p_s_inode, 1);
-	error = reiserfs_do_truncate(&th, p_s_inode, page, update_timestamps);
-	if (error)
-		goto out;
+	err2 = reiserfs_do_truncate(&th, p_s_inode, page, update_timestamps);
 	error =
 	    journal_end(&th, p_s_inode->i_sb, JOURNAL_PER_BALANCE_CNT * 2 + 1);
 	if (error)
 		goto out;
 
+	/* check reiserfs_do_truncate after ending the transaction */
+	if (err2) {
+		error = err2;
+  		goto out;
+	}
+	
 	if (update_timestamps) {
 		error = remove_save_link(p_s_inode, 1 /* truncate */ );
 		if (error)
diff -purN linux-2.6.15-rc5-git3/fs/reiserfs/journal.c linux-2.6.15-rc5-git5/fs/reiserfs/journal.c
--- linux-2.6.15-rc5-git3/fs/reiserfs/journal.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/fs/reiserfs/journal.c	2005-12-15 14:43:17.253160709 +0100
@@ -1039,6 +1039,10 @@ static int flush_commit_list(struct supe
 	}
 	atomic_dec(&journal->j_async_throttle);
 
+	/* We're skipping the commit if there's an error */
+	if (retval || reiserfs_is_journal_aborted(journal))
+		barrier = 0;
+
 	/* wait on everything written so far before writing the commit
 	 * if we are in barrier mode, send the commit down now
 	 */
@@ -1077,10 +1081,16 @@ static int flush_commit_list(struct supe
 	BUG_ON(atomic_read(&(jl->j_commit_left)) != 1);
 
 	if (!barrier) {
-		if (buffer_dirty(jl->j_commit_bh))
-			BUG();
-		mark_buffer_dirty(jl->j_commit_bh);
-		sync_dirty_buffer(jl->j_commit_bh);
+		/* If there was a write error in the journal - we can't commit
+		 * this transaction - it will be invalid and, if successful,
+		 * will just end up propogating the write error out to
+		 * the file system. */
+		if (likely(!retval && !reiserfs_is_journal_aborted (journal))) {
+			if (buffer_dirty(jl->j_commit_bh))
+				BUG();
+			mark_buffer_dirty(jl->j_commit_bh) ;
+			sync_dirty_buffer(jl->j_commit_bh) ;
+		}
 	} else
 		wait_on_buffer(jl->j_commit_bh);
 
diff -purN linux-2.6.15-rc5-git3/include/asm-arm/elf.h linux-2.6.15-rc5-git5/include/asm-arm/elf.h
--- linux-2.6.15-rc5-git3/include/asm-arm/elf.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/include/asm-arm/elf.h	2005-12-15 14:43:17.256160238 +0100
@@ -22,6 +22,8 @@ typedef unsigned long elf_freg_t[3];
 #define R_ARM_NONE	0
 #define R_ARM_PC24	1
 #define R_ARM_ABS32	2
+#define R_ARM_CALL	28
+#define R_ARM_JUMP24	29
 
 #define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))
 typedef elf_greg_t elf_gregset_t[ELF_NGREG];
diff -purN linux-2.6.15-rc5-git3/include/asm-ia64/sal.h linux-2.6.15-rc5-git5/include/asm-ia64/sal.h
--- linux-2.6.15-rc5-git3/include/asm-ia64/sal.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/include/asm-ia64/sal.h	2005-12-15 14:43:17.262159298 +0100
@@ -320,7 +320,8 @@ typedef struct sal_log_timestamp {
 typedef struct sal_log_record_header {
 	u64 id;				/* Unique monotonically increasing ID */
 	sal_log_revision_t revision;	/* Major and Minor revision of header */
-	u16 severity;			/* Error Severity */
+	u8 severity;			/* Error Severity */
+	u8 validation_bits;		/* 0: platform_guid, 1: !timestamp */
 	u32 len;			/* Length of this error log in bytes */
 	sal_log_timestamp_t timestamp;	/* Timestamp */
 	efi_guid_t platform_guid;	/* Unique OEM Platform ID */
diff -purN linux-2.6.15-rc5-git3/include/asm-mips/mach-au1x00/au1xxx_ide.h linux-2.6.15-rc5-git5/include/asm-mips/mach-au1x00/au1xxx_ide.h
--- linux-2.6.15-rc5-git3/include/asm-mips/mach-au1x00/au1xxx_ide.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/include/asm-mips/mach-au1x00/au1xxx_ide.h	2005-12-15 14:43:17.266158671 +0100
@@ -74,9 +74,6 @@ typedef struct
         u8                      white_list, black_list;
         struct dbdma_cmd        *dma_table_cpu;
         dma_addr_t              dma_table_dma;
-        struct scatterlist      *sg_table;
-        int                     sg_nents;
-        int                     sg_dma_direction;
 #endif
         struct device           *dev;
 	int			irq;
@@ -87,11 +84,6 @@ typedef struct
 } _auide_hwif;
 
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-struct drive_list_entry {
-        const char * id_model;
-        const char * id_firmware;
-};
-
 /* HD white list */
 static const struct drive_list_entry dma_white_list [] = {
 /*
@@ -167,13 +159,9 @@ int __init auide_probe(void);
  * Multi-Word DMA + DbDMA functions
  */
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-
-        static int in_drive_list(struct hd_driveid *id,
-                                 const struct drive_list_entry *drive_table);
         static int auide_build_sglist(ide_drive_t *drive,  struct request *rq);
         static int auide_build_dmatable(ide_drive_t *drive);
         static int auide_dma_end(ide_drive_t *drive);
-        static void auide_dma_start(ide_drive_t *drive );
         ide_startstop_t auide_dma_intr (ide_drive_t *drive);
         static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command);
         static int auide_dma_setup(ide_drive_t *drive);
@@ -188,8 +176,6 @@ int __init auide_probe(void);
         static void auide_ddma_rx_callback(int irq, void *param,
                                            struct pt_regs *regs);
         static int auide_dma_off_quietly(ide_drive_t *drive);
-        static int auide_dma_timeout(ide_drive_t *drive);
-
 #endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
 
 /*******************************************************************************
@@ -299,3 +285,11 @@ int __init auide_probe(void);
 #define SBC_IDE_MDMA2_TPM     (0x00<<6)
 #define SBC_IDE_MDMA2_TA      (0x12<<0)
 
+#define SBC_IDE_TIMING(mode) \
+         SBC_IDE_##mode##_TWCS | \
+         SBC_IDE_##mode##_TCSH | \
+         SBC_IDE_##mode##_TCSOFF | \
+         SBC_IDE_##mode##_TWP | \
+         SBC_IDE_##mode##_TCSW | \
+         SBC_IDE_##mode##_TPM | \
+         SBC_IDE_##mode##_TA
diff -purN linux-2.6.15-rc5-git3/include/linux/ide.h linux-2.6.15-rc5-git5/include/linux/ide.h
--- linux-2.6.15-rc5-git3/include/linux/ide.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/include/linux/ide.h	2005-12-15 14:43:17.284155849 +0100
@@ -23,17 +23,6 @@
 #include <asm/io.h>
 #include <asm/semaphore.h>
 
-/*
- * This is the multiple IDE interface driver, as evolved from hd.c.
- * It supports up to four IDE interfaces, on one or more IRQs (usually 14 & 15).
- * There can be up to two drives per interface, as per the ATA-2 spec.
- *
- * Primary i/f:    ide0: major=3;  (hda)         minor=0; (hdb)         minor=64
- * Secondary i/f:  ide1: major=22; (hdc or hd1a) minor=0; (hdd or hd1b) minor=64
- * Tertiary i/f:   ide2: major=33; (hde)         minor=0; (hdf)         minor=64
- * Quaternary i/f: ide3: major=34; (hdg)         minor=0; (hdh)         minor=64
- */
-
 /******************************************************************************
  * IDE driver configuration options (play with these as desired):
  *
@@ -193,11 +182,6 @@ typedef unsigned char	byte;	/* used ever
 #define WAIT_CMD	(10*HZ)	/* 10sec  - maximum wait for an IRQ to happen */
 #define WAIT_MIN_SLEEP	(2*HZ/100)	/* 20msec - minimum sleep time */
 
-#define HOST(hwif,chipset)					\
-{								\
-	return ((hwif)->chipset == chipset) ? 1 : 0;		\
-}
-
 /*
  * Check for an interrupt and acknowledge the interrupt status
  */
@@ -391,45 +375,6 @@ typedef union {
 } ata_nsector_t, ata_data_t, atapi_bcount_t, ata_index_t;
 
 /*
- * ATA-IDE Error Register
- *
- * mark		: Bad address mark
- * tzero	: Couldn't find track 0
- * abrt		: Aborted Command
- * mcr		: Media Change Request
- * id		: ID field not found
- * mce		: Media Change Event
- * ecc		: Uncorrectable ECC error
- * bdd		: dual meaing
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned mark		:1;
-		unsigned tzero		:1;
-		unsigned abrt		:1;
-		unsigned mcr		:1;
-		unsigned id		:1;
-		unsigned mce		:1;
-		unsigned ecc		:1;
-		unsigned bdd		:1;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned bdd		:1;
-		unsigned ecc		:1;
-		unsigned mce		:1;
-		unsigned id		:1;
-		unsigned mcr		:1;
-		unsigned abrt		:1;
-		unsigned tzero		:1;
-		unsigned mark		:1;
-#else
-#error "Please fix <asm/byteorder.h>"
-#endif
-	} b;
-} ata_error_t;
-
-/*
  * ATA-IDE Select Register, aka Device-Head
  *
  * head		: always zeros here
@@ -504,39 +449,6 @@ typedef union {
 } ata_status_t, atapi_status_t;
 
 /*
- * ATA-IDE Control Register
- *
- * bit0		: Should be set to zero
- * nIEN		: device INTRQ to host
- * SRST		: host soft reset bit
- * bit3		: ATA-2 thingy, Should be set to 1
- * reserved456	: Reserved
- * HOB		: 48-bit address ordering, High Ordered Bit
- */
-typedef union {
-	unsigned all			: 8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned bit0		: 1;
-		unsigned nIEN		: 1;
-		unsigned SRST		: 1;
-		unsigned bit3		: 1;
-		unsigned reserved456	: 3;
-		unsigned HOB		: 1;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned HOB		: 1;
-		unsigned reserved456	: 3;
-		unsigned bit3		: 1;
-		unsigned SRST		: 1;
-		unsigned nIEN		: 1;
-		unsigned bit0		: 1;
-#else
-#error "Please fix <asm/byteorder.h>"
-#endif
-	} b;
-} ata_control_t;
-
-/*
  * ATAPI Feature Register
  *
  * dma		: Using DMA or PIO
@@ -618,39 +530,6 @@ typedef union {
 } atapi_error_t;
 
 /*
- * ATAPI floppy Drive Select Register
- *
- * sam_lun	: Logical unit number
- * reserved3	: Reserved
- * drv		: The responding drive will be drive 0 (0) or drive 1 (1)
- * one5		: Should be set to 1
- * reserved6	: Reserved
- * one7		: Should be set to 1
- */
-typedef union {
-	unsigned all			:8;
-	struct {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-		unsigned sam_lun	:3;
-		unsigned reserved3	:1;
-		unsigned drv		:1;
-		unsigned one5		:1;
-		unsigned reserved6	:1;
-		unsigned one7		:1;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-		unsigned one7		:1;
-		unsigned reserved6	:1;
-		unsigned one5		:1;
-		unsigned drv		:1;
-		unsigned reserved3	:1;
-		unsigned sam_lun	:3;
-#else
-#error "Please fix <asm/byteorder.h>"
-#endif
-	} b;
-} atapi_select_t;
-
-/*
  * Status returned from various ide_ functions
  */
 typedef enum {
@@ -1101,10 +980,7 @@ typedef struct ide_driver_s {
 	int		(*end_request)(ide_drive_t *, int, int);
 	ide_startstop_t	(*error)(ide_drive_t *, struct request *rq, u8, u8);
 	ide_startstop_t	(*abort)(ide_drive_t *, struct request *rq);
-	int		(*ioctl)(ide_drive_t *, struct inode *, struct file *, unsigned int, unsigned long);
 	ide_proc_entry_t	*proc;
-	void		(*ata_prebuilder)(ide_drive_t *);
-	void		(*atapi_prebuilder)(ide_drive_t *);
 	struct device_driver	gen_driver;
 } ide_driver_t;
 
@@ -1298,7 +1174,6 @@ extern int ide_spin_wait_hwgroup(ide_dri
 extern void ide_timer_expiry(unsigned long);
 extern irqreturn_t ide_intr(int irq, void *dev_id, struct pt_regs *regs);
 extern void do_ide_request(request_queue_t *);
-extern void ide_init_subdrivers(void);
 
 void ide_init_disk(struct gendisk *, ide_drive_t *);
 
@@ -1371,6 +1246,12 @@ void ide_init_sg_cmd(ide_drive_t *, stru
 #define GOOD_DMA_DRIVE		1
 
 #ifdef CONFIG_BLK_DEV_IDEDMA
+struct drive_list_entry {
+	const char *id_model;
+	const char *id_firmware;
+};
+
+int ide_in_drive_list(struct hd_driveid *, const struct drive_list_entry *);
 int __ide_dma_bad_drive(ide_drive_t *);
 int __ide_dma_good_drive(ide_drive_t *);
 int ide_use_dma(ide_drive_t *);
diff -purN linux-2.6.15-rc5-git3/include/linux/libata.h linux-2.6.15-rc5-git5/include/linux/libata.h
--- linux-2.6.15-rc5-git3/include/linux/libata.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/include/linux/libata.h	2005-12-15 14:43:17.288155222 +0100
@@ -122,6 +122,7 @@ enum {
 	ATA_FLAG_NOINTR		= (1 << 9), /* FIXME: Remove this once
 					     * proper HSM is in place. */
 	ATA_FLAG_DEBUGMSG	= (1 << 10),
+	ATA_FLAG_NO_ATAPI	= (1 << 11), /* No ATAPI support */
 
 	ATA_QCFLAG_ACTIVE	= (1 << 1), /* cmd not yet ack'd to scsi lyer */
 	ATA_QCFLAG_SG		= (1 << 3), /* have s/g table? */
diff -purN linux-2.6.15-rc5-git3/include/linux/pci_ids.h linux-2.6.15-rc5-git5/include/linux/pci_ids.h
--- linux-2.6.15-rc5-git3/include/linux/pci_ids.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/include/linux/pci_ids.h	2005-12-15 14:43:17.297153811 +0100
@@ -1244,6 +1244,7 @@
 #define PCI_DEVICE_ID_VIA_8378_0	0x3205
 #define PCI_DEVICE_ID_VIA_8783_0	0x3208
 #define PCI_DEVICE_ID_VIA_8237		0x3227
+#define PCI_DEVICE_ID_VIA_8251		0x3287
 #define PCI_DEVICE_ID_VIA_3296_0	0x0296
 #define PCI_DEVICE_ID_VIA_8231		0x8231
 #define PCI_DEVICE_ID_VIA_8231_4	0x8235
diff -purN linux-2.6.15-rc5-git3/include/scsi/scsi_cmnd.h linux-2.6.15-rc5-git5/include/scsi/scsi_cmnd.h
--- linux-2.6.15-rc5-git3/include/scsi/scsi_cmnd.h	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/include/scsi/scsi_cmnd.h	2005-12-15 14:43:17.306152401 +0100
@@ -151,5 +151,6 @@ extern struct scsi_cmnd *scsi_get_comman
 extern void scsi_put_command(struct scsi_cmnd *);
 extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
 extern void scsi_finish_command(struct scsi_cmnd *cmd);
+extern void scsi_setup_blk_pc_cmnd(struct scsi_cmnd *cmd, int retries);
 
 #endif /* _SCSI_SCSI_CMND_H */
diff -purN linux-2.6.15-rc5-git3/init/Kconfig linux-2.6.15-rc5-git5/init/Kconfig
--- linux-2.6.15-rc5-git3/init/Kconfig	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/init/Kconfig	2005-12-15 14:43:17.307152244 +0100
@@ -206,7 +206,7 @@ config HOTPLUG
 	  outside the kernel tree does. Such modules require Y here.
 
 config KOBJECT_UEVENT
-	bool "Kernel Userspace Events"
+	bool "Kernel Userspace Events" if EMBEDDED
 	depends on NET
 	default y
 	help
@@ -256,6 +256,20 @@ config CPUSETS
 
 source "usr/Kconfig"
 
+config CC_OPTIMIZE_FOR_SIZE
+	bool "Optimize for size (Look out for broken compilers!)"
+	default y
+	depends on ARM || H8300 || EXPERIMENTAL
+	depends on !SPARC64
+	help
+	  Enabling this option will pass "-Os" instead of "-O2" to gcc
+	  resulting in a smaller kernel.
+
+	  WARNING: some versions of gcc may generate incorrect code with this
+	  option.  If problems are observed, a gcc upgrade may be needed.
+
+	  If unsure, say N.
+
 menuconfig EMBEDDED
 	bool "Configure standard kernel features (for small systems)"
 	help
@@ -338,18 +352,6 @@ config EPOLL
 	  Disabling this option will cause the kernel to be built without
 	  support for epoll family of system calls.
 
-config CC_OPTIMIZE_FOR_SIZE
-	bool "Optimize for size" if EMBEDDED
-	default y if ARM || H8300
-	help
-	  Enabling this option will pass "-Os" instead of "-O2" to gcc
-	  resulting in a smaller kernel.
-
-	  WARNING: some versions of gcc may generate incorrect code with this
-	  option.  If problems are observed, a gcc upgrade may be needed.
-
-	  If unsure, say N.
-
 config SHMEM
 	bool "Use full shmem filesystem" if EMBEDDED
 	default y
diff -purN linux-2.6.15-rc5-git3/mm/memory_hotplug.c linux-2.6.15-rc5-git5/mm/memory_hotplug.c
--- linux-2.6.15-rc5-git3/mm/memory_hotplug.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/mm/memory_hotplug.c	2005-12-15 14:43:17.326149265 +0100
@@ -104,7 +104,7 @@ static void grow_pgdat_span(struct pglis
 		pgdat->node_start_pfn = start_pfn;
 
 	if (end_pfn > old_pgdat_end_pfn)
-		pgdat->node_spanned_pages = end_pfn - pgdat->node_spanned_pages;
+		pgdat->node_spanned_pages = end_pfn - pgdat->node_start_pfn;
 }
 
 int online_pages(unsigned long pfn, unsigned long nr_pages)
diff -purN linux-2.6.15-rc5-git3/net/8021q/vlan_dev.c linux-2.6.15-rc5-git5/net/8021q/vlan_dev.c
--- linux-2.6.15-rc5-git3/net/8021q/vlan_dev.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/net/8021q/vlan_dev.c	2005-12-15 14:43:17.328148952 +0100
@@ -165,6 +165,9 @@ int vlan_skb_recv(struct sk_buff *skb, s
 
 	skb_pull(skb, VLAN_HLEN); /* take off the VLAN header (4 bytes currently) */
 
+	/* Need to correct hardware checksum */
+	skb_postpull_rcsum(skb, vhdr, VLAN_HLEN);
+
 	/* Ok, lets check to make sure the device (dev) we
 	 * came in on is what this VLAN is attached to.
 	 */
diff -purN linux-2.6.15-rc5-git3/net/ipv4/ip_gre.c linux-2.6.15-rc5-git5/net/ipv4/ip_gre.c
--- linux-2.6.15-rc5-git3/net/ipv4/ip_gre.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/net/ipv4/ip_gre.c	2005-12-15 14:43:17.344146444 +0100
@@ -618,7 +618,7 @@ static int ipgre_rcv(struct sk_buff *skb
 
 		skb->mac.raw = skb->nh.raw;
 		skb->nh.raw = __pskb_pull(skb, offset);
-		skb_postpull_rcsum(skb, skb->mac.raw, offset);
+		skb_postpull_rcsum(skb, skb->h.raw, offset);
 		memset(&(IPCB(skb)->opt), 0, sizeof(struct ip_options));
 		skb->pkt_type = PACKET_HOST;
 #ifdef CONFIG_NET_IPGRE_BROADCAST
diff -purN linux-2.6.15-rc5-git3/net/ipv6/addrconf.c linux-2.6.15-rc5-git5/net/ipv6/addrconf.c
--- linux-2.6.15-rc5-git3/net/ipv6/addrconf.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/net/ipv6/addrconf.c	2005-12-15 14:43:17.369142525 +0100
@@ -379,8 +379,8 @@ static struct inet6_dev * ipv6_add_dev(s
 		    dev->type == ARPHRD_NONE ||
 		    dev->type == ARPHRD_SIT) {
 			printk(KERN_INFO
-				"Disabled Privacy Extensions on device %p(%s)\n",
-				dev, dev->name);
+			       "%s: Disabled Privacy Extensions\n",
+			       dev->name);
 			ndev->cnf.use_tempaddr = -1;
 		} else {
 			in6_dev_hold(ndev);
diff -purN linux-2.6.15-rc5-git3/net/sched/act_api.c linux-2.6.15-rc5-git5/net/sched/act_api.c
--- linux-2.6.15-rc5-git3/net/sched/act_api.c	2005-12-04 06:10:42.000000000 +0100
+++ linux-2.6.15-rc5-git5/net/sched/act_api.c	2005-12-15 14:43:17.386139860 +0100
@@ -34,7 +34,7 @@
 #include <net/sch_generic.h>
 #include <net/act_api.h>
 
-#if 1 /* control */
+#if 0 /* control */
 #define DPRINTK(format, args...) printk(KERN_DEBUG format, ##args)
 #else
 #define DPRINTK(format, args...)
