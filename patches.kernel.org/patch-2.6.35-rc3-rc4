From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 2.6.35-rc4
Patch-mainline: 2.6.35-rc4

 This patch contains the differences between 2.6.35-rc3 and -rc4.

Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 Documentation/kernel-parameters.txt                |    4 
 Documentation/watchdog/watchdog-parameters.txt     |    5 
 MAINTAINERS                                        |   52 +-
 Makefile                                           |   74 ---
 arch/alpha/include/asm/bitops.h                    |    2 
 arch/alpha/kernel/Makefile                         |   20 -
 arch/alpha/kernel/ns87312.c                        |   38 -
 arch/alpha/kernel/pc873xx.c                        |   88 ++++
 arch/alpha/kernel/pc873xx.h                        |   35 +
 arch/alpha/kernel/pci-sysfs.c                      |    3 
 arch/alpha/kernel/sys_sio.c                        |   23 +
 arch/arm/Kconfig                                   |    3 
 arch/arm/include/asm/mach/udc_pxa2xx.h             |    4 
 arch/arm/include/asm/processor.h                   |    4 
 arch/arm/kernel/perf_event.c                       |    2 
 arch/arm/mach-mx3/mach-mx31lilly.c                 |   33 +
 arch/arm/mach-omap2/board-omap3stalker.c           |    4 
 arch/arm/mach-omap2/clock44xx_data.c               |    2 
 arch/arm/mach-omap2/omap_hwmod.c                   |    9 
 arch/arm/mach-omap2/pm34xx.c                       |    4 
 arch/arm/mach-omap2/usb-ehci.c                     |    2 
 arch/arm/mach-pxa/mioa701.c                        |    2 
 arch/arm/mach-pxa/z2.c                             |   26 -
 arch/arm/mach-realview/Kconfig                     |    2 
 arch/arm/mach-realview/include/mach/barriers.h     |    8 
 arch/arm/mach-realview/realview_eb.c               |    3 
 arch/arm/mach-realview/realview_pb1176.c           |    3 
 arch/arm/mach-realview/realview_pb11mp.c           |    3 
 arch/arm/mach-realview/realview_pba8.c             |    3 
 arch/arm/mach-realview/realview_pbx.c              |    3 
 arch/arm/mach-vexpress/ct-ca9x4.c                  |    4 
 arch/arm/mm/Kconfig                                |   21 +
 arch/arm/mm/cache-v6.S                             |   18 
 arch/arm/mm/dma-mapping.c                          |   18 
 arch/arm/plat-omap/dmtimer.c                       |    6 
 arch/arm/plat-omap/gpio.c                          |    1 
 arch/arm/plat-omap/iovmm.c                         |    4 
 arch/arm/plat-pxa/Makefile                         |    3 
 arch/ia64/mm/tlb.c                                 |    2 
 arch/powerpc/Kconfig.debug                         |    7 
 arch/powerpc/boot/Makefile                         |    2 
 arch/powerpc/boot/addRamDisk.c                     |  311 ----------------
 arch/powerpc/boot/dts/lite5200.dts                 |   28 +
 arch/powerpc/boot/dts/lite5200b.dts                |    5 
 arch/powerpc/configs/40x/acadia_defconfig          |    3 
 arch/powerpc/configs/40x/ep405_defconfig           |    3 
 arch/powerpc/configs/40x/hcu4_defconfig            |    3 
 arch/powerpc/configs/40x/kilauea_defconfig         |    3 
 arch/powerpc/configs/40x/makalu_defconfig          |    3 
 arch/powerpc/configs/40x/virtex_defconfig          |    3 
 arch/powerpc/configs/40x/walnut_defconfig          |    3 
 arch/powerpc/configs/44x/arches_defconfig          |    3 
 arch/powerpc/configs/44x/bamboo_defconfig          |    3 
 arch/powerpc/configs/44x/canyonlands_defconfig     |    3 
 arch/powerpc/configs/44x/ebony_defconfig           |    3 
 arch/powerpc/configs/44x/eiger_defconfig           |    3 
 arch/powerpc/configs/44x/katmai_defconfig          |    3 
 arch/powerpc/configs/44x/rainier_defconfig         |    3 
 arch/powerpc/configs/44x/redwood_defconfig         |    3 
 arch/powerpc/configs/44x/sam440ep_defconfig        |    3 
 arch/powerpc/configs/44x/sequoia_defconfig         |    3 
 arch/powerpc/configs/44x/taishan_defconfig         |    3 
 arch/powerpc/configs/44x/virtex5_defconfig         |    3 
 arch/powerpc/configs/52xx/cm5200_defconfig         |    3 
 arch/powerpc/configs/52xx/lite5200b_defconfig      |    3 
 arch/powerpc/configs/52xx/motionpro_defconfig      |    3 
 arch/powerpc/configs/52xx/pcm030_defconfig         |    3 
 arch/powerpc/configs/52xx/tqm5200_defconfig        |    3 
 arch/powerpc/configs/86xx/gef_ppc9a_defconfig      |    3 
 arch/powerpc/configs/86xx/gef_sbc310_defconfig     |    3 
 arch/powerpc/configs/86xx/gef_sbc610_defconfig     |    3 
 arch/powerpc/configs/86xx/mpc8610_hpcd_defconfig   |    3 
 arch/powerpc/configs/86xx/mpc8641_hpcn_defconfig   |    3 
 arch/powerpc/configs/86xx/sbc8641d_defconfig       |    3 
 arch/powerpc/configs/adder875_defconfig            |    3 
 arch/powerpc/configs/amigaone_defconfig            |    3 
 arch/powerpc/configs/c2k_defconfig                 |    3 
 arch/powerpc/configs/cell_defconfig                |    3 
 arch/powerpc/configs/celleb_defconfig              |    3 
 arch/powerpc/configs/chrp32_defconfig              |    3 
 arch/powerpc/configs/ep8248e_defconfig             |    3 
 arch/powerpc/configs/ep88xc_defconfig              |    3 
 arch/powerpc/configs/g5_defconfig                  |    3 
 arch/powerpc/configs/gamecube_defconfig            |    3 
 arch/powerpc/configs/holly_defconfig               |    1 
 arch/powerpc/configs/iseries_defconfig             |    3 
 arch/powerpc/configs/linkstation_defconfig         |    3 
 arch/powerpc/configs/maple_defconfig               |    3 
 arch/powerpc/configs/mgcoge_defconfig              |    3 
 arch/powerpc/configs/mgsuvd_defconfig              |    3 
 arch/powerpc/configs/mpc512x_defconfig             |    3 
 arch/powerpc/configs/mpc5200_defconfig             |    3 
 arch/powerpc/configs/mpc7448_hpc2_defconfig        |    3 
 arch/powerpc/configs/pasemi_defconfig              |    3 
 arch/powerpc/configs/pmac32_defconfig              |    3 
 arch/powerpc/configs/ppc40x_defconfig              |    3 
 arch/powerpc/configs/ppc44x_defconfig              |    3 
 arch/powerpc/configs/ppc64_defconfig               |    3 
 arch/powerpc/configs/ppc64e_defconfig              |    3 
 arch/powerpc/configs/pq2fads_defconfig             |    3 
 arch/powerpc/configs/prpmc2800_defconfig           |    3 
 arch/powerpc/configs/pseries_defconfig             |    3 
 arch/powerpc/configs/storcenter_defconfig          |    3 
 arch/powerpc/configs/wii_defconfig                 |    3 
 arch/powerpc/include/asm/irq.h                     |    6 
 arch/powerpc/include/asm/kdump.h                   |   11 
 arch/powerpc/kernel/irq.c                          |   12 
 arch/powerpc/kernel/machine_kexec_64.c             |   18 
 arch/powerpc/kernel/misc_32.S                      |    2 
 arch/powerpc/kernel/misc_64.S                      |    2 
 arch/powerpc/kernel/process.c                      |    5 
 arch/powerpc/kernel/rtas_flash.c                   |   39 +-
 arch/powerpc/kernel/setup_32.c                     |    4 
 arch/powerpc/kernel/setup_64.c                     |    4 
 arch/powerpc/mm/pgtable_32.c                       |    4 
 arch/powerpc/platforms/52xx/mpc52xx_pm.c           |   11 
 arch/powerpc/sysdev/mpic.c                         |    2 
 arch/sh/boards/mach-ecovec24/setup.c               |    1 
 arch/sh/drivers/pci/pci.c                          |    2 
 arch/sh/mm/pmb.c                                   |    2 
 arch/um/include/asm/arch_hweight.h                 |    6 
 arch/um/os-Linux/mem.c                             |    1 
 arch/x86/boot/video-vga.c                          |    3 
 arch/x86/include/asm/io_apic.h                     |    4 
 arch/x86/include/asm/percpu.h                      |    2 
 arch/x86/include/asm/pgtable_32_types.h            |    2 
 arch/x86/include/asm/system.h                      |    2 
 arch/x86/kernel/acpi/boot.c                        |    8 
 arch/x86/kernel/apic/io_apic.c                     |   12 
 arch/x86/kernel/cpu/perf_event_amd.c               |    4 
 arch/x86/kernel/cpu/perf_event_intel.c             |    1 
 arch/x86/kernel/e820.c                             |    2 
 arch/x86/kernel/mpparse.c                          |    2 
 arch/x86/kernel/pci-calgary_64.c                   |   15 
 arch/x86/kernel/reboot.c                           |    8 
 arch/x86/kernel/sfi.c                              |    2 
 arch/x86/kernel/traps.c                            |   11 
 arch/x86/mm/pat.c                                  |    2 
 arch/x86/mm/pat_rbtree.c                           |    1 
 block/blk-core.c                                   |    9 
 block/cfq-iosched.c                                |   67 +--
 block/cfq.h                                        |  115 +++++
 drivers/acpi/acpi_pad.c                            |   36 +
 drivers/acpi/acpica/acconfig.h                     |    4 
 drivers/acpi/acpica/acevents.h                     |    4 
 drivers/acpi/acpica/acglobal.h                     |    8 
 drivers/acpi/acpica/achware.h                      |    6 
 drivers/acpi/acpica/evgpe.c                        |  115 -----
 drivers/acpi/acpica/evgpeblk.c                     |   14 
 drivers/acpi/acpica/evxface.c                      |    7 
 drivers/acpi/acpica/evxfevnt.c                     |   59 ++-
 drivers/acpi/acpica/exsystem.c                     |    8 
 drivers/acpi/acpica/hwgpe.c                        |   94 +++-
 drivers/acpi/acpica/hwvalid.c                      |   12 
 drivers/acpi/acpica/nsinit.c                       |    9 
 drivers/acpi/apei/apei-base.c                      |    1 
 drivers/acpi/apei/erst.c                           |    2 
 drivers/acpi/atomicio.c                            |    1 
 drivers/acpi/blacklist.c                           |    8 
 drivers/acpi/button.c                              |    4 
 drivers/acpi/fan.c                                 |    3 
 drivers/acpi/processor_driver.c                    |    5 
 drivers/acpi/sleep.c                               |   34 -
 drivers/acpi/system.c                              |    6 
 drivers/acpi/wakeup.c                              |   20 -
 drivers/ata/ahci.c                                 |   10 
 drivers/ata/ata_generic.c                          |   30 +
 drivers/ata/libahci.c                              |    5 
 drivers/block/cciss_scsi.c                         |    1 
 drivers/block/cpqarray.c                           |    6 
 drivers/block/drbd/drbd_main.c                     |    2 
 drivers/block/drbd/drbd_nl.c                       |    6 
 drivers/char/agp/generic.c                         |    6 
 drivers/char/ipmi/ipmi_si_intf.c                   |   23 -
 drivers/char/sysrq.c                               |    8 
 drivers/char/tpm/tpm.h                             |    1 
 drivers/clocksource/sh_cmt.c                       |    2 
 drivers/cpuidle/governors/menu.c                   |    4 
 drivers/dma/ppc4xx/adma.c                          |    4 
 drivers/edac/amd64_edac.c                          |   24 -
 drivers/edac/i7core_edac.c                         |   53 ++
 drivers/gpio/Kconfig                               |    2 
 drivers/gpio/Makefile                              |    6 
 drivers/gpu/drm/drm_fb_helper.c                    |   19 
 drivers/gpu/drm/i915/dvo_tfp410.c                  |    2 
 drivers/gpu/drm/i915/i915_debugfs.c                |    2 
 drivers/gpu/drm/i915/i915_dma.c                    |    8 
 drivers/gpu/drm/i915/i915_drv.h                    |    3 
 drivers/gpu/drm/i915/i915_gem.c                    |    2 
 drivers/gpu/drm/i915/i915_irq.c                    |   76 ++-
 drivers/gpu/drm/i915/i915_reg.h                    |    5 
 drivers/gpu/drm/i915/intel_crt.c                   |    6 
 drivers/gpu/drm/i915/intel_display.c               |   60 ++-
 drivers/gpu/drm/i915/intel_dp.c                    |   27 +
 drivers/gpu/drm/i915/intel_drv.h                   |    1 
 drivers/gpu/drm/i915/intel_lvds.c                  |    4 
 drivers/gpu/drm/i915/intel_ringbuffer.c            |   10 
 drivers/gpu/drm/radeon/atombios_crtc.c             |    2 
 drivers/gpu/drm/radeon/evergreen.c                 |   35 +
 drivers/gpu/drm/radeon/evergreen_cs.c              |    4 
 drivers/gpu/drm/radeon/evergreend.h                |    3 
 drivers/gpu/drm/radeon/r100.c                      |   81 ++--
 drivers/gpu/drm/radeon/r200.c                      |    5 
 drivers/gpu/drm/radeon/r300.c                      |    5 
 drivers/gpu/drm/radeon/r600.c                      |   17 
 drivers/gpu/drm/radeon/radeon.h                    |    4 
 drivers/gpu/drm/radeon/radeon_asic.c               |    7 
 drivers/gpu/drm/radeon/radeon_bios.c               |    4 
 drivers/gpu/drm/radeon/radeon_combios.c            |   49 ++
 drivers/gpu/drm/radeon/radeon_cursor.c             |    2 
 drivers/gpu/drm/radeon/radeon_device.c             |    7 
 drivers/gpu/drm/radeon/radeon_encoders.c           |    4 
 drivers/gpu/drm/radeon/radeon_legacy_encoders.c    |   22 -
 drivers/gpu/drm/radeon/radeon_mode.h               |    1 
 drivers/gpu/drm/radeon/radeon_pm.c                 |   41 +-
 drivers/gpu/drm/radeon/reg_srcs/evergreen          |   10 
 drivers/gpu/drm/radeon/rs690.c                     |   41 +-
 drivers/gpu/drm/radeon/rv770.c                     |    2 
 drivers/gpu/drm/ttm/ttm_page_alloc.c               |    2 
 drivers/hwmon/i5k_amb.c                            |    6 
 drivers/hwmon/k10temp.c                            |   14 
 drivers/hwmon/k8temp.c                             |    2 
 drivers/input/keyboard/Kconfig                     |    2 
 drivers/input/misc/pcf8574_keypad.c                |    2 
 drivers/input/serio/Kconfig                        |    2 
 drivers/input/tablet/wacom_wac.c                   |    9 
 drivers/input/touchscreen/ad7877.c                 |    7 
 drivers/isdn/gigaset/asyncdata.c                   |   44 --
 drivers/isdn/gigaset/capi.c                        |  405 ++++++++++++++-------
 drivers/isdn/gigaset/common.c                      |   36 -
 drivers/isdn/gigaset/ev-layer.c                    |    4 
 drivers/isdn/gigaset/gigaset.h                     |   38 +
 drivers/isdn/gigaset/i4l.c                         |   21 +
 drivers/isdn/gigaset/isocdata.c                    |   72 +--
 drivers/isdn/hysdn/hysdn_net.c                     |    3 
 drivers/md/md.c                                    |   38 +
 drivers/md/md.h                                    |    3 
 drivers/md/raid0.c                                 |   21 -
 drivers/md/raid0.h                                 |    3 
 drivers/md/raid10.c                                |   46 --
 drivers/md/raid10.h                                |    5 
 drivers/md/raid5.c                                 |  150 ++++++-
 drivers/net/Kconfig                                |    2 
 drivers/net/bnx2.c                                 |   11 
 drivers/net/cnic.c                                 |   55 +-
 drivers/net/cpmac.c                                |    3 
 drivers/net/e1000/e1000_main.c                     |   17 
 drivers/net/ehea/ehea.h                            |    2 
 drivers/net/ehea/ehea_main.c                       |    9 
 drivers/net/enic/vnic_dev.c                        |    2 
 drivers/net/gianfar.c                              |   25 +
 drivers/net/ixgbe/ixgbe_ethtool.c                  |   37 -
 drivers/net/ixgbe/ixgbe_main.c                     |    4 
 drivers/net/ixgbe/ixgbe_phy.c                      |    2 
 drivers/net/lib82596.c                             |    2 
 drivers/net/mipsnet.c                              |    2 
 drivers/net/netxen/netxen_nic_ctx.c                |    3 
 drivers/net/netxen/netxen_nic_hw.c                 |    4 
 drivers/net/netxen/netxen_nic_init.c               |   13 
 drivers/net/pcmcia/pcnet_cs.c                      |    1 
 drivers/net/pcmcia/smc91c92_cs.c                   |   18 
 drivers/net/phy/lxt.c                              |    1 
 drivers/net/sky2.c                                 |   19 
 drivers/net/tulip/de2104x.c                        |    5 
 drivers/net/ucc_geth.c                             |    2 
 drivers/net/usb/hso.c                              |    1 
 drivers/net/vxge/vxge-main.c                       |   29 +
 drivers/net/wireless/ath/ath5k/attach.c            |    1 
 drivers/net/wireless/hostap/hostap_cs.c            |   15 
 drivers/net/wireless/hostap/hostap_hw.c            |   13 
 drivers/net/wireless/hostap/hostap_wlan.h          |    2 
 drivers/net/wireless/iwlwifi/iwl-agn-tx.c          |    5 
 drivers/net/wireless/iwlwifi/iwl-agn.c             |    8 
 drivers/net/wireless/iwlwifi/iwl-scan.c            |    1 
 drivers/net/wireless/iwlwifi/iwl-sta.c             |    4 
 drivers/net/wireless/iwlwifi/iwl3945-base.c        |    9 
 drivers/net/wireless/libertas_tf/main.c            |    2 
 drivers/net/wireless/p54/p54pci.c                  |    2 
 drivers/pci/intel-iommu.c                          |   14 
 drivers/pci/pci.c                                  |    1 
 drivers/pci/pcie/pme/pcie_pme.c                    |   19 
 drivers/power/z2_battery.c                         |   12 
 drivers/rtc/rtc-davinci.c                          |    1 
 drivers/rtc/rtc-ds1307.c                           |    4 
 drivers/serial/cpm_uart/cpm_uart_core.c            |  143 ++++---
 drivers/serial/serial_cs.c                         |    1 
 drivers/staging/batman-adv/bat_sysfs.c             |   24 -
 drivers/staging/batman-adv/device.c                |    2 
 drivers/staging/comedi/drivers/adl_pci9111.c       |    9 
 drivers/staging/comedi/drivers/cb_pcidda.c         |    3 
 drivers/staging/hv/channel_mgmt.c                  |   41 +-
 drivers/staging/hv/hv_utils.c                      |   28 +
 drivers/staging/hv/vmbus.h                         |    2 
 drivers/staging/hv/vmbus_drv.c                     |    3 
 drivers/staging/mrst-touchscreen/intel-mid-touch.c |    2 
 drivers/staging/rt2860/usb_main_dev.c              |    1 
 drivers/staging/rtl8187se/r8180_core.c             |    2 
 drivers/staging/rtl8192su/r8192U_core.c            |   43 +-
 drivers/staging/rtl8192u/r8192U_core.c             |    2 
 drivers/staging/tm6000/tm6000-alsa.c               |    1 
 drivers/staging/tm6000/tm6000-cards.c              |    1 
 drivers/staging/tm6000/tm6000-core.c               |    1 
 drivers/staging/tm6000/tm6000-dvb.c                |    1 
 drivers/staging/usbip/usbip_common.c               |   46 +-
 drivers/staging/wlags49_h2/wl_enc.c                |    1 
 drivers/staging/wlags49_h2/wl_sysfs.h              |    4 
 drivers/usb/core/driver.c                          |   13 
 drivers/usb/core/message.c                         |    7 
 drivers/usb/gadget/f_eem.c                         |    3 
 drivers/usb/gadget/f_mass_storage.c                |  196 +++-------
 drivers/usb/gadget/g_ffs.c                         |   11 
 drivers/usb/gadget/printer.c                       |   32 -
 drivers/usb/gadget/s3c2410_udc.c                   |    6 
 drivers/usb/gadget/u_serial.c                      |   16 
 drivers/usb/host/ehci-mxc.c                        |   13 
 drivers/usb/host/isp1362-hcd.c                     |   15 
 drivers/usb/host/r8a66597-hcd.c                    |    2 
 drivers/usb/host/xhci-ring.c                       |   62 ++-
 drivers/usb/musb/musb_core.c                       |   13 
 drivers/usb/musb/musb_core.h                       |    6 
 drivers/usb/musb/musbhsdma.c                       |   13 
 drivers/usb/otg/ulpi.c                             |   15 
 drivers/usb/serial/ftdi_sio.c                      |    1 
 drivers/usb/serial/ftdi_sio_ids.h                  |    7 
 drivers/usb/serial/qcserial.c                      |    3 
 drivers/video/geode/gxfb_core.c                    |   20 -
 drivers/video/geode/lxfb_core.c                    |   18 
 drivers/video/nuc900fb.c                           |    2 
 drivers/video/omap/lcdc.c                          |   14 
 drivers/video/omap/rfbi.c                          |    5 
 drivers/virtio/virtio_pci.c                        |    3 
 drivers/virtio/virtio_ring.c                       |    2 
 drivers/watchdog/at32ap700x_wdt.c                  |   16 
 drivers/watchdog/imx2_wdt.c                        |    1 
 fs/binfmt_flat.c                                   |    6 
 fs/cifs/cifsfs.c                                   |   16 
 fs/cifs/cifsproto.h                                |    1 
 fs/cifs/dir.c                                      |   76 ++-
 fs/cifs/file.c                                     |  100 +----
 fs/cifs/inode.c                                    |    4 
 fs/cifs/sess.c                                     |   10 
 fs/dcache.c                                        |    2 
 fs/ext2/acl.c                                      |    1 
 fs/ext3/acl.c                                      |    1 
 fs/fcntl.c                                         |    6 
 fs/fs-writeback.c                                  |  254 +++++--------
 fs/nfs/client.c                                    |  122 ++----
 fs/nfs/getroot.c                                   |    2 
 fs/nfs/nfs4xdr.c                                   |    4 
 fs/nfs/super.c                                     |   22 -
 fs/ocfs2/reservations.c                            |    1 
 fs/proc/proc_devtree.c                             |    3 
 fs/proc/task_nommu.c                               |   20 -
 fs/super.c                                         |    6 
 fs/sysv/ialloc.c                                   |    6 
 fs/ubifs/budget.c                                  |    2 
 fs/xfs/linux-2.6/xfs_export.c                      |   11 
 fs/xfs/linux-2.6/xfs_ioctl.c                       |    7 
 fs/xfs/linux-2.6/xfs_ioctl32.c                     |   15 
 fs/xfs/quota/xfs_qm.c                              |   18 
 fs/xfs/quota/xfs_qm_syscalls.c                     |   27 -
 fs/xfs/xfs_dfrag.c                                 |    5 
 fs/xfs/xfs_ialloc.c                                |  142 ++++---
 fs/xfs/xfs_iget.c                                  |   10 
 fs/xfs/xfs_inode.c                                 |    5 
 fs/xfs/xfs_inode.h                                 |    6 
 fs/xfs/xfs_itable.c                                |  285 ++------------
 fs/xfs/xfs_itable.h                                |   17 
 fs/xfs/xfs_log_recover.c                           |    2 
 fs/xfs/xfs_mount.c                                 |    2 
 fs/xfs/xfs_rtalloc.c                               |    4 
 fs/xfs/xfs_trans_inode.c                           |    2 
 fs/xfs/xfs_vnodeops.c                              |    2 
 include/acpi/acexcep.h                             |    2 
 include/acpi/acpixf.h                              |    1 
 include/acpi/actypes.h                             |    3 
 include/linux/agp_backend.h                        |    1 
 include/linux/backing-dev.h                        |    4 
 include/linux/cgroup.h                             |   20 -
 include/linux/compiler-gcc.h                       |   10 
 include/linux/compiler-gcc4.h                      |    4 
 include/linux/drbd.h                               |    2 
 include/linux/dynamic_debug.h                      |    4 
 include/linux/fb.h                                 |    4 
 include/linux/list.h                               |   15 
 include/linux/pci_ids.h                            |    1 
 include/linux/sched.h                              |    2 
 include/linux/suspend.h                            |   26 -
 include/linux/tracepoint.h                         |    1 
 include/net/snmp.h                                 |    2 
 init/main.c                                        |   16 
 kernel/futex.c                                     |   17 
 kernel/irq/manage.c                                |    3 
 kernel/kexec.c                                     |    7 
 kernel/module.c                                    |   23 -
 kernel/power/Kconfig                               |    9 
 kernel/power/Makefile                              |    2 
 kernel/power/hibernate_nvs.c                       |  136 -------
 kernel/power/nvs.c                                 |  136 +++++++
 kernel/power/suspend.c                             |    6 
 kernel/sched.c                                     |  137 +++----
 kernel/sched_fair.c                                |    2 
 kernel/time/tick-sched.c                           |   21 -
 kernel/trace/trace_event_perf.c                    |    4 
 lib/dynamic_debug.c                                |    2 
 lib/genalloc.c                                     |    1 
 lib/idr.c                                          |    4 
 mm/memcontrol.c                                    |    4 
 mm/mempolicy.c                                     |    9 
 mm/page-writeback.c                                |    5 
 mm/percpu.c                                        |   36 +
 net/bluetooth/bnep/netdev.c                        |    2 
 net/bridge/br_fdb.c                                |    6 
 net/bridge/br_forward.c                            |    4 
 net/core/skbuff.c                                  |    2 
 net/ipv4/ip_output.c                               |    9 
 net/ipv6/ndisc.c                                   |    2 
 net/mac80211/work.c                                |    2 
 net/netfilter/ipvs/ip_vs_conn.c                    |    4 
 net/sched/sch_teql.c                               |    1 
 net/sunrpc/xprtsock.c                              |   38 +
 net/xfrm/xfrm_policy.c                             |    3 
 scripts/mod/modpost.c                              |    2 
 scripts/package/Makefile                           |    2 
 scripts/setlocalversion                            |  183 ++++++---
 security/keys/keyctl.c                             |    4 
 sound/pci/asihpi/hpi6205.c                         |   22 -
 sound/pci/hda/patch_realtek.c                      |   35 -
 sound/soc/davinci/davinci-mcasp.c                  |    2 
 sound/soc/fsl/mpc5200_dma.h                        |    2 
 sound/usb/clock.c                                  |   12 
 sound/usb/endpoint.c                               |    1 
 sound/usb/format.c                                 |  104 ++++-
 sound/usb/helper.h                                 |    4 
 sound/usb/mixer.c                                  |   19 
 tools/perf/builtin-record.c                        |    2 
 tools/perf/util/event.c                            |    4 
 tools/perf/util/newt.c                             |   15 
 tools/perf/util/session.c                          |   11 
 tools/perf/util/session.h                          |    2 
 tools/perf/util/thread.c                           |   11 
 tools/perf/util/thread.h                           |    5 
 442 files changed, 4046 insertions(+), 3269 deletions(-)

diff -urN linux-2.6.35-rc3/Documentation/kernel-parameters.txt linux-2.6.35-rc4/Documentation/kernel-parameters.txt
--- linux-2.6.35-rc3/Documentation/kernel-parameters.txt	2010-07-05 05:34:21.331805415 +0000
+++ linux-2.6.35-rc4/Documentation/kernel-parameters.txt	2010-07-05 05:34:26.729868023 +0000
@@ -2048,7 +2048,9 @@
 			WARNING: Forcing ASPM on may cause system lockups.
 
 	pcie_pme=	[PCIE,PM] Native PCIe PME signaling options:
-		off	Do not use native PCIe PME signaling.
+			Format: {auto|force}[,nomsi]
+		auto	Use native PCIe PME signaling if the BIOS allows the
+			kernel to control PCIe config registers of root ports.
 		force	Use native PCIe PME signaling even if the BIOS refuses
 			to allow the kernel to control the relevant PCIe config
 			registers.
diff -urN linux-2.6.35-rc3/Documentation/watchdog/watchdog-parameters.txt linux-2.6.35-rc4/Documentation/watchdog/watchdog-parameters.txt
--- linux-2.6.35-rc3/Documentation/watchdog/watchdog-parameters.txt	2010-07-05 05:34:21.345805770 +0000
+++ linux-2.6.35-rc4/Documentation/watchdog/watchdog-parameters.txt	2010-07-05 05:34:26.743868105 +0000
@@ -125,6 +125,11 @@
 nowayout: Watchdog cannot be stopped once started
 	(default=kernel config parameter)
 -------------------------------------------------
+imx2_wdt:
+timeout: Watchdog timeout in seconds (default 60 s)
+nowayout: Watchdog cannot be stopped once started
+	(default=kernel config parameter)
+-------------------------------------------------
 indydog:
 nowayout: Watchdog cannot be stopped once started
 	(default=kernel config parameter)
diff -urN linux-2.6.35-rc3/MAINTAINERS linux-2.6.35-rc4/MAINTAINERS
--- linux-2.6.35-rc3/MAINTAINERS	2010-07-05 05:34:21.346805543 +0000
+++ linux-2.6.35-rc4/MAINTAINERS	2010-07-05 05:34:26.744868101 +0000
@@ -896,11 +896,13 @@
 
 ARM/SAMSUNG ARM ARCHITECTURES
 M:	Ben Dooks <ben-linux@fluff.org>
+M:	Kukjin Kim <kgene.kim@samsung.com>
 L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
 W:	http://www.fluff.org/ben/linux/
 S:	Maintained
-F:	arch/arm/plat-s3c/
+F:	arch/arm/plat-samsung/
 F:	arch/arm/plat-s3c24xx/
+F:	arch/arm/plat-s5p/
 
 ARM/S3C2410 ARM ARCHITECTURE
 M:	Ben Dooks <ben-linux@fluff.org>
@@ -1148,7 +1150,7 @@
 F:	drivers/mmc/host/atmel-mci-regs.h
 
 ATMEL AT91 / AT32 SERIAL DRIVER
-M:	Haavard Skinnemoen <hskinnemoen@atmel.com>
+M:	Nicolas Ferre <nicolas.ferre@atmel.com>
 S:	Supported
 F:	drivers/serial/atmel_serial.c
 
@@ -1160,18 +1162,18 @@
 F:	include/video/atmel_lcdc.h
 
 ATMEL MACB ETHERNET DRIVER
-M:	Haavard Skinnemoen <hskinnemoen@atmel.com>
+M:	Nicolas Ferre <nicolas.ferre@atmel.com>
 S:	Supported
 F:	drivers/net/macb.*
 
 ATMEL SPI DRIVER
-M:	Haavard Skinnemoen <hskinnemoen@atmel.com>
+M:	Nicolas Ferre <nicolas.ferre@atmel.com>
 S:	Supported
 F:	drivers/spi/atmel_spi.*
 
 ATMEL USBA UDC DRIVER
-M:	Haavard Skinnemoen <hskinnemoen@atmel.com>
-L:	kernel@avr32linux.org
+M:	Nicolas Ferre <nicolas.ferre@atmel.com>
+L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
 W:	http://avr32linux.org/twiki/bin/view/Main/AtmelUsbDeviceDriver
 S:	Supported
 F:	drivers/usb/gadget/atmel_usba_udc.*
@@ -1581,7 +1583,7 @@
 
 COMMON INTERNET FILE SYSTEM (CIFS)
 M:	Steve French <sfrench@samba.org>
-L:	linux-cifs-client@lists.samba.org (moderated for non-subscribers)
+L:	linux-cifs@vger.kernel.org
 L:	samba-technical@lists.samba.org (moderated for non-subscribers)
 W:	http://linux-cifs.samba.org/
 Q:	http://patchwork.ozlabs.org/project/linux-cifs-client/list/
@@ -2109,11 +2111,18 @@
 
 EDAC-I5400
 M:	Mauro Carvalho Chehab <mchehab@redhat.com>
-L:	bluesmoke-devel@lists.sourceforge.net (moderated for non-subscribers)
+L:	linux-edac@vger.kernel.org
 W:	bluesmoke.sourceforge.net
 S:	Maintained
 F:	drivers/edac/i5400_edac.c
 
+EDAC-I7CORE
+M:	Mauro Carvalho Chehab <mchehab@redhat.com>
+L:	linux-edac@vger.kernel.org
+W:	bluesmoke.sourceforge.net
+S:	Maintained
+F:	drivers/edac/i7core_edac.c linux/edac_mce.h drivers/edac/edac_mce.c
+
 EDAC-I82975X
 M:	Ranganathan Desikan <ravi@jetztechnologies.com>
 M:	"Arvind R." <arvind@jetztechnologies.com>
@@ -2887,6 +2896,13 @@
 S:	Maintained
 F:	drivers/input/
 
+INPUT MULTITOUCH (MT) PROTOCOL
+M:	Henrik Rydberg <rydberg@euromail.se>
+L:	linux-input@vger.kernel.org
+S:	Maintained
+F:	Documentation/input/multi-touch-protocol.txt
+K:	\b(ABS|SYN)_MT_
+
 INTEL IDLE DRIVER
 M:	Len Brown <lenb@kernel.org>
 L:	linux-pm@lists.linux-foundation.org
@@ -2978,20 +2994,14 @@
 F:	drivers/net/ixgbe/
 
 INTEL PRO/WIRELESS 2100 NETWORK CONNECTION SUPPORT
-M:	Reinette Chatre <reinette.chatre@intel.com>
-M:	Intel Linux Wireless <ilw@linux.intel.com>
 L:	linux-wireless@vger.kernel.org
-W:	http://ipw2100.sourceforge.net
-S:	Odd Fixes
+S:	Orphan
 F:	Documentation/networking/README.ipw2100
 F:	drivers/net/wireless/ipw2x00/ipw2100.*
 
 INTEL PRO/WIRELESS 2915ABG NETWORK CONNECTION SUPPORT
-M:	Reinette Chatre <reinette.chatre@intel.com>
-M:	Intel Linux Wireless <ilw@linux.intel.com>
 L:	linux-wireless@vger.kernel.org
-W:	http://ipw2200.sourceforge.net
-S:	Odd Fixes
+S:	Orphan
 F:	Documentation/networking/README.ipw2200
 F:	drivers/net/wireless/ipw2x00/ipw2200.*
 
@@ -3379,7 +3389,7 @@
 M:	Ananth N Mavinakayanahalli <ananth@in.ibm.com>
 M:	Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
 M:	"David S. Miller" <davem@davemloft.net>
-M:	Masami Hiramatsu <mhiramat@redhat.com>
+M:	Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
 S:	Maintained
 F:	Documentation/kprobes.txt
 F:	include/linux/kprobes.h
@@ -4212,6 +4222,7 @@
 M:	Grant Likely <grant.likely@secretlab.ca>
 L:	devicetree-discuss@lists.ozlabs.org
 W:	http://fdt.secretlab.ca
+T:	git git://git.secretlab.ca/git/linux-2.6.git
 S:	Maintained
 F:	drivers/of
 F:	include/linux/of*.h
@@ -4626,6 +4637,12 @@
 L:	rtc-linux@googlegroups.com
 S:	Maintained
 
+QLOGIC QLA1280 SCSI DRIVER
+M:	Michael Reed <mdr@sgi.com>
+L:	linux-scsi@vger.kernel.org
+S:	Maintained
+F:	drivers/scsi/qla1280.[ch]
+
 QLOGIC QLA2XXX FC-SCSI DRIVER
 M:	Andrew Vasquez <andrew.vasquez@qlogic.com>
 M:	linux-driver@qlogic.com
@@ -5384,6 +5401,7 @@
 M:	Grant Likely <grant.likely@secretlab.ca>
 L:	spi-devel-general@lists.sourceforge.net
 Q:	http://patchwork.kernel.org/project/spi-devel-general/list/
+T:	git git://git.secretlab.ca/git/linux-2.6.git
 S:	Maintained
 F:	Documentation/spi/
 F:	drivers/spi/
diff -urN linux-2.6.35-rc3/Makefile linux-2.6.35-rc4/Makefile
--- linux-2.6.35-rc3/Makefile	2010-07-05 05:34:21.346805543 +0000
+++ linux-2.6.35-rc4/Makefile	2010-07-05 05:34:26.745868052 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 35
-EXTRAVERSION = -rc3
+EXTRAVERSION = -rc4
 NAME = Sheep on Meth
 
 # *DOCUMENTATION*
@@ -883,80 +883,10 @@
 $(vmlinux-dirs): prepare scripts
 	$(Q)$(MAKE) $(build)=$@
 
-# Build the kernel release string
-#
-# The KERNELRELEASE value built here is stored in the file
-# include/config/kernel.release, and is used when executing several
-# make targets, such as "make install" or "make modules_install."
-#
-# The eventual kernel release string consists of the following fields,
-# shown in a hierarchical format to show how smaller parts are concatenated
-# to form the larger and final value, with values coming from places like
-# the Makefile, kernel config options, make command line options and/or
-# SCM tag information.
-#
-#	$(KERNELVERSION)
-#	  $(VERSION)			eg, 2
-#	  $(PATCHLEVEL)			eg, 6
-#	  $(SUBLEVEL)			eg, 18
-#	  $(EXTRAVERSION)		eg, -rc6
-#	$(localver-full)
-#	  $(localver)
-#	    localversion*		(files without backups, containing '~')
-#	    $(CONFIG_LOCALVERSION)	(from kernel config setting)
-#	  $(LOCALVERSION)		(from make command line, if provided)
-#	  $(localver-extra)
-#	    $(scm-identifier)		(unique SCM tag, if one exists)
-#	      ./scripts/setlocalversion	(only with CONFIG_LOCALVERSION_AUTO)
-#	      .scmversion		(only with CONFIG_LOCALVERSION_AUTO)
-#	    +				(only without CONFIG_LOCALVERSION_AUTO
-#					 and without LOCALVERSION= and
-#					 repository is at non-tagged commit)
-#
-# For kernels without CONFIG_LOCALVERSION_AUTO compiled from an SCM that has
-# been revised beyond a tagged commit, `+' is appended to the version string
-# when not overridden by using "make LOCALVERSION=".  This indicates that the
-# kernel is not a vanilla release version and has been modified.
-
-pattern = ".*/localversion[^~]*"
-string  = $(shell cat /dev/null \
-	   `find $(objtree) $(srctree) -maxdepth 1 -regex $(pattern) | sort -u`)
-
-localver = $(subst $(space),, $(string) \
-			      $(patsubst "%",%,$(CONFIG_LOCALVERSION)))
-
-# scripts/setlocalversion is called to create a unique identifier if the source
-# is managed by a known SCM and the repository has been revised since the last
-# tagged (release) commit.  The format of the identifier is determined by the
-# SCM's implementation.
-#
-# .scmversion is used when generating rpm packages so we do not loose
-# the version information from the SCM when we do the build of the kernel
-# from the copied source
-ifeq ($(wildcard .scmversion),)
-        scm-identifier = $(shell $(CONFIG_SHELL) \
-                         $(srctree)/scripts/setlocalversion $(srctree))
-else
-        scm-identifier = $(shell cat .scmversion 2> /dev/null)
-endif
-
-ifdef CONFIG_LOCALVERSION_AUTO
-	localver-extra = $(scm-identifier)
-else
-	ifneq ($(scm-identifier),)
-		ifeq ($(LOCALVERSION),)
-			localver-extra = +
-		endif
-	endif
-endif
-
-localver-full = $(localver)$(LOCALVERSION)$(localver-extra)
-
 # Store (new) KERNELRELASE string in include/config/kernel.release
-kernelrelease = $(KERNELVERSION)$(localver-full)
 include/config/kernel.release: include/config/auto.conf FORCE
 	$(Q)rm -f $@
-	$(Q)echo $(kernelrelease) > $@
+	$(Q)echo "$(KERNELVERSION)$$($(CONFIG_SHELL) scripts/setlocalversion $(srctree))" > $@
 
 
 # Things we need to do before we recursively start building the kernel
diff -urN linux-2.6.35-rc3/arch/alpha/include/asm/bitops.h linux-2.6.35-rc4/arch/alpha/include/asm/bitops.h
--- linux-2.6.35-rc3/arch/alpha/include/asm/bitops.h	2010-07-05 05:34:21.347805586 +0000
+++ linux-2.6.35-rc4/arch/alpha/include/asm/bitops.h	2010-07-05 05:34:26.745868052 +0000
@@ -410,7 +410,7 @@
 	return __kernel_ctpop(w);
 }
 
-static inline unsigned int __arch_weight32(unsigned int w)
+static inline unsigned int __arch_hweight32(unsigned int w)
 {
 	return __arch_hweight64(w);
 }
diff -urN linux-2.6.35-rc3/arch/alpha/kernel/Makefile linux-2.6.35-rc4/arch/alpha/kernel/Makefile
--- linux-2.6.35-rc3/arch/alpha/kernel/Makefile	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/alpha/kernel/Makefile	2010-07-05 05:34:26.746868070 +0000
@@ -35,7 +35,7 @@
 
 obj-y	 += irq_pyxis.o irq_i8259.o irq_srm.o
 obj-y	 += err_ev6.o
-obj-y	 += es1888.o smc37c669.o smc37c93x.o ns87312.o gct.o
+obj-y	 += es1888.o smc37c669.o smc37c93x.o pc873xx.o gct.o
 obj-y    += srmcons.o
 
 else
@@ -63,11 +63,11 @@
 # Board support
 obj-$(CONFIG_ALPHA_ALCOR)	+= sys_alcor.o irq_i8259.o irq_srm.o
 obj-$(CONFIG_ALPHA_CABRIOLET)	+= sys_cabriolet.o irq_i8259.o irq_srm.o \
-				   ns87312.o
+				   pc873xx.o
 obj-$(CONFIG_ALPHA_EB164)	+= sys_cabriolet.o irq_i8259.o irq_srm.o \
-				   ns87312.o
+				   pc873xx.o
 obj-$(CONFIG_ALPHA_EB66P)	+= sys_cabriolet.o irq_i8259.o irq_srm.o \
-				   ns87312.o
+				   pc873xx.o
 obj-$(CONFIG_ALPHA_LX164)	+= sys_cabriolet.o irq_i8259.o irq_srm.o \
 				   smc37c93x.o
 obj-$(CONFIG_ALPHA_PC164)	+= sys_cabriolet.o irq_i8259.o irq_srm.o \
@@ -90,14 +90,14 @@
 obj-$(CONFIG_ALPHA_RX164)	+= sys_rx164.o irq_i8259.o
 obj-$(CONFIG_ALPHA_SABLE)	+= sys_sable.o
 obj-$(CONFIG_ALPHA_LYNX)	+= sys_sable.o
-obj-$(CONFIG_ALPHA_BOOK1)	+= sys_sio.o irq_i8259.o irq_srm.o ns87312.o
-obj-$(CONFIG_ALPHA_AVANTI)	+= sys_sio.o irq_i8259.o irq_srm.o ns87312.o
-obj-$(CONFIG_ALPHA_NONAME)	+= sys_sio.o irq_i8259.o irq_srm.o ns87312.o
-obj-$(CONFIG_ALPHA_P2K)		+= sys_sio.o irq_i8259.o irq_srm.o ns87312.o
-obj-$(CONFIG_ALPHA_XL)		+= sys_sio.o irq_i8259.o irq_srm.o ns87312.o
+obj-$(CONFIG_ALPHA_BOOK1)	+= sys_sio.o irq_i8259.o irq_srm.o pc873xx.o
+obj-$(CONFIG_ALPHA_AVANTI)	+= sys_sio.o irq_i8259.o irq_srm.o pc873xx.o
+obj-$(CONFIG_ALPHA_NONAME)	+= sys_sio.o irq_i8259.o irq_srm.o pc873xx.o
+obj-$(CONFIG_ALPHA_P2K)		+= sys_sio.o irq_i8259.o irq_srm.o pc873xx.o
+obj-$(CONFIG_ALPHA_XL)		+= sys_sio.o irq_i8259.o irq_srm.o pc873xx.o
 obj-$(CONFIG_ALPHA_SX164)	+= sys_sx164.o irq_pyxis.o irq_i8259.o \
 				   irq_srm.o smc37c669.o
-obj-$(CONFIG_ALPHA_TAKARA)	+= sys_takara.o irq_i8259.o ns87312.o
+obj-$(CONFIG_ALPHA_TAKARA)	+= sys_takara.o irq_i8259.o pc873xx.o
 obj-$(CONFIG_ALPHA_WILDFIRE)	+= sys_wildfire.o irq_i8259.o
 
 # Error support
diff -urN linux-2.6.35-rc3/arch/alpha/kernel/ns87312.c linux-2.6.35-rc4/arch/alpha/kernel/ns87312.c
--- linux-2.6.35-rc3/arch/alpha/kernel/ns87312.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/alpha/kernel/ns87312.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,38 +0,0 @@
-/*
- *	linux/arch/alpha/kernel/ns87312.c
- */
-
-#include <linux/init.h>
-#include <asm/io.h>
-#include "proto.h"
-
-
-/*
- * The SRM console *disables* the IDE interface, this code ensures it's
- * enabled.
- *
- * This code bangs on a control register of the 87312 Super I/O chip
- * that implements parallel port/serial ports/IDE/FDI.  Depending on
- * the motherboard, the Super I/O chip can be configured through a
- * pair of registers that are located either at I/O ports 0x26e/0x26f
- * or 0x398/0x399.  Unfortunately, autodetecting which base address is
- * in use works only once (right after a reset).  The Super I/O chip
- * has the additional quirk that configuration register data must be
- * written twice (I believe this is a safety feature to prevent
- * accidental modification---fun, isn't it?).
- */
-
-void __init
-ns87312_enable_ide(long ide_base)
-{
-	int data;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	outb(0, ide_base);		/* set the index register for reg #0 */
-	data = inb(ide_base+1);		/* read the current contents */
-	outb(0, ide_base);		/* set the index register for reg #0 */
-	outb(data | 0x40, ide_base+1);	/* turn on IDE */
-	outb(data | 0x40, ide_base+1);	/* turn on IDE, really! */
-	local_irq_restore(flags);
-}
diff -urN linux-2.6.35-rc3/arch/alpha/kernel/pc873xx.c linux-2.6.35-rc4/arch/alpha/kernel/pc873xx.c
--- linux-2.6.35-rc3/arch/alpha/kernel/pc873xx.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.35-rc4/arch/alpha/kernel/pc873xx.c	2010-07-05 05:34:26.747806627 +0000
@@ -0,0 +1,88 @@
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+#include "pc873xx.h"
+
+static unsigned pc873xx_probelist[] = {0x398, 0x26e, 0};
+
+static char *pc873xx_names[] = {
+	"PC87303", "PC87306", "PC87312", "PC87332", "PC87334"
+};
+
+static unsigned int base, model;
+
+
+unsigned int __init pc873xx_get_base()
+{
+	return base;
+}
+
+char *__init pc873xx_get_model()
+{
+	return pc873xx_names[model];
+}
+
+static unsigned char __init pc873xx_read(unsigned int base, int reg)
+{
+	outb(reg, base);
+	return inb(base + 1);
+}
+
+static void __init pc873xx_write(unsigned int base, int reg, unsigned char data)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	outb(reg, base);
+	outb(data, base + 1);
+	outb(data, base + 1);		/* Must be written twice */
+	local_irq_restore(flags);
+}
+
+int __init pc873xx_probe(void)
+{
+	int val, index = 0;
+
+	while ((base = pc873xx_probelist[index++])) {
+
+		if (request_region(base, 2, "Super IO PC873xx") == NULL)
+			continue;
+
+		val = pc873xx_read(base, REG_SID);
+		if ((val & 0xf0) == 0x10) {
+			model = PC87332;
+			break;
+		} else if ((val & 0xf8) == 0x70) {
+			model = PC87306;
+			break;
+		} else if ((val & 0xf8) == 0x50) {
+			model = PC87334;
+			break;
+		} else if ((val & 0xf8) == 0x40) {
+			model = PC87303;
+			break;
+		}
+
+		release_region(base, 2);
+	}
+
+	return (base == 0) ? -1 : 1;
+}
+
+void __init pc873xx_enable_epp19(void)
+{
+	unsigned char data;
+
+	printk(KERN_INFO "PC873xx enabling EPP v1.9\n");
+	data = pc873xx_read(base, REG_PCR);
+	pc873xx_write(base, REG_PCR, (data & 0xFC) | 0x02);
+}
+
+void __init pc873xx_enable_ide(void)
+{
+	unsigned char data;
+
+	printk(KERN_INFO "PC873xx enabling IDE interrupt\n");
+	data = pc873xx_read(base, REG_FER);
+	pc873xx_write(base, REG_FER, data | 0x40);
+}
diff -urN linux-2.6.35-rc3/arch/alpha/kernel/pc873xx.h linux-2.6.35-rc4/arch/alpha/kernel/pc873xx.h
--- linux-2.6.35-rc3/arch/alpha/kernel/pc873xx.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.35-rc4/arch/alpha/kernel/pc873xx.h	2010-07-05 05:34:26.747806627 +0000
@@ -0,0 +1,35 @@
+
+#ifndef _PC873xx_H_
+#define _PC873xx_H_
+
+/*
+ * Control Register Values
+ */
+#define REG_FER	0x00
+#define REG_FAR	0x01
+#define REG_PTR	0x02
+#define REG_FCR	0x03
+#define REG_PCR	0x04
+#define REG_KRR	0x05
+#define REG_PMC	0x06
+#define REG_TUP	0x07
+#define REG_SID	0x08
+#define REG_ASC	0x09
+#define REG_IRC	0x0e
+
+/*
+ * Model numbers
+ */
+#define PC87303	0
+#define PC87306	1
+#define PC87312	2
+#define PC87332	3
+#define PC87334	4
+
+int pc873xx_probe(void);
+unsigned int pc873xx_get_base(void);
+char *pc873xx_get_model(void);
+void pc873xx_enable_epp19(void);
+void pc873xx_enable_ide(void);
+
+#endif
diff -urN linux-2.6.35-rc3/arch/alpha/kernel/pci-sysfs.c linux-2.6.35-rc4/arch/alpha/kernel/pci-sysfs.c
--- linux-2.6.35-rc3/arch/alpha/kernel/pci-sysfs.c	2010-07-05 05:34:21.347805586 +0000
+++ linux-2.6.35-rc4/arch/alpha/kernel/pci-sysfs.c	2010-07-05 05:34:26.747806627 +0000
@@ -53,7 +53,6 @@
 
 /**
  * pci_mmap_resource - map a PCI resource into user memory space
- * @filp: open sysfs file
  * @kobj: kobject for mapping
  * @attr: struct bin_attribute for the file being mapped
  * @vma: struct vm_area_struct passed into the mmap
@@ -61,7 +60,7 @@
  *
  * Use the bus mapping routines to map a PCI resource into userspace.
  */
-static int pci_mmap_resource(struct file *filp, struct kobject *kobj,
+static int pci_mmap_resource(struct kobject *kobj,
 			     struct bin_attribute *attr,
 			     struct vm_area_struct *vma, int sparse)
 {
diff -urN linux-2.6.35-rc3/arch/alpha/kernel/sys_sio.c linux-2.6.35-rc4/arch/alpha/kernel/sys_sio.c
--- linux-2.6.35-rc3/arch/alpha/kernel/sys_sio.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/alpha/kernel/sys_sio.c	2010-07-05 05:34:26.747806627 +0000
@@ -34,6 +34,7 @@
 #include "irq_impl.h"
 #include "pci_impl.h"
 #include "machvec_impl.h"
+#include "pc873xx.h"
 
 #if defined(ALPHA_RESTORE_SRM_SETUP)
 /* Save LCA configuration data as the console had it set up.  */
@@ -208,7 +209,27 @@
 	common_init_pci();
 	sio_pci_route();
 	sio_fixup_irq_levels(sio_collect_irq_levels());
-	ns87312_enable_ide(0x26e);
+
+	if (pc873xx_probe() == -1) {
+		printk(KERN_ERR "Probing for PC873xx Super IO chip failed.\n");
+	} else {
+		printk(KERN_INFO "Found %s Super IO chip at 0x%x\n",
+			pc873xx_get_model(), pc873xx_get_base());
+
+		/* Enabling things in the Super IO chip doesn't actually
+		 * configure and enable things, the legacy drivers still
+		 * need to do the actual configuration and enabling.
+		 * This only unblocks them.
+		 */
+
+#if !defined(CONFIG_ALPHA_AVANTI)
+		/* Don't bother on the Avanti family.
+		 * None of them had on-board IDE.
+		 */
+		pc873xx_enable_ide();
+#endif
+		pc873xx_enable_epp19();
+	}
 }
 
 static inline void __init
diff -urN linux-2.6.35-rc3/arch/arm/Kconfig linux-2.6.35-rc4/arch/arm/Kconfig
--- linux-2.6.35-rc3/arch/arm/Kconfig	2010-07-05 05:34:21.348805594 +0000
+++ linux-2.6.35-rc4/arch/arm/Kconfig	2010-07-05 05:34:26.748805615 +0000
@@ -955,7 +955,8 @@
 	default y
 
 config CPU_HAS_PMU
-	depends on CPU_V6 || CPU_V7 || XSCALE_PMU
+	depends on (CPU_V6 || CPU_V7 || XSCALE_PMU) && \
+		   (!ARCH_OMAP3 || OMAP3_EMU)
 	default y
 	bool
 
diff -urN linux-2.6.35-rc3/arch/arm/include/asm/mach/udc_pxa2xx.h linux-2.6.35-rc4/arch/arm/include/asm/mach/udc_pxa2xx.h
--- linux-2.6.35-rc3/arch/arm/include/asm/mach/udc_pxa2xx.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/arm/include/asm/mach/udc_pxa2xx.h	2010-07-05 05:34:26.763806143 +0000
@@ -21,8 +21,8 @@
 	 * here.  Note that sometimes the signals go through inverters...
 	 */
 	bool	gpio_vbus_inverted;
-	u16	gpio_vbus;			/* high == vbus present */
+	int	gpio_vbus;			/* high == vbus present */
 	bool	gpio_pullup_inverted;
-	u16	gpio_pullup;			/* high == pullup activated */
+	int	gpio_pullup;			/* high == pullup activated */
 };
 
diff -urN linux-2.6.35-rc3/arch/arm/include/asm/processor.h linux-2.6.35-rc4/arch/arm/include/asm/processor.h
--- linux-2.6.35-rc3/arch/arm/include/asm/processor.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/arm/include/asm/processor.h	2010-07-05 05:34:26.764805305 +0000
@@ -91,7 +91,11 @@
 
 unsigned long get_wchan(struct task_struct *p);
 
+#if __LINUX_ARM_ARCH__ == 6
+#define cpu_relax()			smp_mb()
+#else
 #define cpu_relax()			barrier()
+#endif
 
 /*
  * Create a new kernel thread
diff -urN linux-2.6.35-rc3/arch/arm/kernel/perf_event.c linux-2.6.35-rc4/arch/arm/kernel/perf_event.c
--- linux-2.6.35-rc3/arch/arm/kernel/perf_event.c	2010-07-05 05:34:21.365805504 +0000
+++ linux-2.6.35-rc4/arch/arm/kernel/perf_event.c	2010-07-05 05:34:26.765810236 +0000
@@ -201,7 +201,7 @@
 {
 	int shift = 64 - 32;
 	s64 prev_raw_count, new_raw_count;
-	s64 delta;
+	u64 delta;
 
 again:
 	prev_raw_count = atomic64_read(&hwc->prev_count);
diff -urN linux-2.6.35-rc3/arch/arm/mach-mx3/mach-mx31lilly.c linux-2.6.35-rc4/arch/arm/mach-mx3/mach-mx31lilly.c
--- linux-2.6.35-rc3/arch/arm/mach-mx3/mach-mx31lilly.c	2010-07-05 05:34:21.393806510 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-mx3/mach-mx31lilly.c	2010-07-05 05:34:26.794868089 +0000
@@ -115,6 +115,8 @@
 
 /* USB */
 
+#if defined(CONFIG_USB_ULPI)
+
 #define USB_PAD_CFG (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST | PAD_CTL_HYS_CMOS | \
 			PAD_CTL_ODE_CMOS | PAD_CTL_100K_PU)
 
@@ -244,10 +246,20 @@
 	.flags	= MXC_EHCI_POWER_PINS_ENABLED,
 };
 
-static struct platform_device *devices[] __initdata = {
-	&smsc91x_device,
-	&physmap_flash_device,
-};
+static void lilly1131_usb_init(void)
+{
+	usbotg_pdata.otg = otg_ulpi_create(&mxc_ulpi_access_ops,
+				USB_OTG_DRV_VBUS | USB_OTG_DRV_VBUS_EXT);
+	usbh2_pdata.otg = otg_ulpi_create(&mxc_ulpi_access_ops,
+				USB_OTG_DRV_VBUS | USB_OTG_DRV_VBUS_EXT);
+
+	mxc_register_device(&mxc_usbh1, &usbh1_pdata);
+	mxc_register_device(&mxc_usbh2, &usbh2_pdata);
+}
+
+#else
+static inline void lilly1131_usb_init(void) {}
+#endif /* CONFIG_USB_ULPI */
 
 /* SPI */
 
@@ -279,6 +291,11 @@
 	.platform_data	= &mc13783_pdata,
 };
 
+static struct platform_device *devices[] __initdata = {
+	&smsc91x_device,
+	&physmap_flash_device,
+};
+
 static int mx31lilly_baseboard;
 core_param(mx31lilly_baseboard, mx31lilly_baseboard, int, 0444);
 
@@ -321,13 +338,7 @@
 	platform_add_devices(devices, ARRAY_SIZE(devices));
 
 	/* USB */
-	usbotg_pdata.otg = otg_ulpi_create(&mxc_ulpi_access_ops,
-				USB_OTG_DRV_VBUS | USB_OTG_DRV_VBUS_EXT);
-	usbh2_pdata.otg = otg_ulpi_create(&mxc_ulpi_access_ops,
-				USB_OTG_DRV_VBUS | USB_OTG_DRV_VBUS_EXT);
-
-	mxc_register_device(&mxc_usbh1, &usbh1_pdata);
-	mxc_register_device(&mxc_usbh2, &usbh2_pdata);
+	lilly1131_usb_init();
 }
 
 static void __init mx31lilly_timer_init(void)
diff -urN linux-2.6.35-rc3/arch/arm/mach-omap2/board-omap3stalker.c linux-2.6.35-rc4/arch/arm/mach-omap2/board-omap3stalker.c
--- linux-2.6.35-rc3/arch/arm/mach-omap2/board-omap3stalker.c	2010-07-05 05:34:21.402806108 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-omap2/board-omap3stalker.c	2010-07-05 05:34:26.803805351 +0000
@@ -538,9 +538,7 @@
 		printk(KERN_ERR "can't get ads7846 pen down GPIO\n");
 
 	gpio_direction_input(OMAP3_STALKER_TS_GPIO);
-
-	omap_set_gpio_debounce(OMAP3_STALKER_TS_GPIO, 1);
-	omap_set_gpio_debounce_time(OMAP3_STALKER_TS_GPIO, 0xa);
+	gpio_set_debounce(OMAP3_STALKER_TS_GPIO, 310);
 }
 
 static int ads7846_get_pendown_state(void)
diff -urN linux-2.6.35-rc3/arch/arm/mach-omap2/clock44xx_data.c linux-2.6.35-rc4/arch/arm/mach-omap2/clock44xx_data.c
--- linux-2.6.35-rc3/arch/arm/mach-omap2/clock44xx_data.c	2010-07-05 05:34:21.408805894 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-omap2/clock44xx_data.c	2010-07-05 05:34:26.809868092 +0000
@@ -1369,6 +1369,7 @@
 	.ops		= &clkops_omap2_dflt,
 	.enable_reg	= OMAP4430_CM_MEMIF_EMIF_1_CLKCTRL,
 	.enable_bit	= OMAP4430_MODULEMODE_HWCTRL,
+	.flags		= ENABLE_ON_INIT,
 	.clkdm_name	= "l3_emif_clkdm",
 	.parent		= &ddrphy_ck,
 	.recalc		= &followparent_recalc,
@@ -1379,6 +1380,7 @@
 	.ops		= &clkops_omap2_dflt,
 	.enable_reg	= OMAP4430_CM_MEMIF_EMIF_2_CLKCTRL,
 	.enable_bit	= OMAP4430_MODULEMODE_HWCTRL,
+	.flags		= ENABLE_ON_INIT,
 	.clkdm_name	= "l3_emif_clkdm",
 	.parent		= &ddrphy_ck,
 	.recalc		= &followparent_recalc,
diff -urN linux-2.6.35-rc3/arch/arm/mach-omap2/omap_hwmod.c linux-2.6.35-rc4/arch/arm/mach-omap2/omap_hwmod.c
--- linux-2.6.35-rc3/arch/arm/mach-omap2/omap_hwmod.c	2010-07-05 05:34:21.415806729 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-omap2/omap_hwmod.c	2010-07-05 05:34:26.816868088 +0000
@@ -409,10 +409,11 @@
 		return 0;
 
 	oh->_clk = omap_clk_get_by_name(oh->main_clk);
-	if (!oh->_clk)
+	if (!oh->_clk) {
 		pr_warning("omap_hwmod: %s: cannot clk_get main_clk %s\n",
 			   oh->name, oh->main_clk);
 		return -EINVAL;
+	}
 
 	if (!oh->_clk->clkdm)
 		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",
@@ -444,10 +445,11 @@
 			continue;
 
 		c = omap_clk_get_by_name(os->clk);
-		if (!c)
+		if (!c) {
 			pr_warning("omap_hwmod: %s: cannot clk_get interface_clk %s\n",
 				   oh->name, os->clk);
 			ret = -EINVAL;
+		}
 		os->_clk = c;
 	}
 
@@ -470,10 +472,11 @@
 
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
 		c = omap_clk_get_by_name(oc->clk);
-		if (!c)
+		if (!c) {
 			pr_warning("omap_hwmod: %s: cannot clk_get opt_clk %s\n",
 				   oh->name, oc->clk);
 			ret = -EINVAL;
+		}
 		oc->_clk = c;
 	}
 
diff -urN linux-2.6.35-rc3/arch/arm/mach-omap2/pm34xx.c linux-2.6.35-rc4/arch/arm/mach-omap2/pm34xx.c
--- linux-2.6.35-rc3/arch/arm/mach-omap2/pm34xx.c	2010-07-05 05:34:21.417806167 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-omap2/pm34xx.c	2010-07-05 05:34:26.818868050 +0000
@@ -99,7 +99,7 @@
 		/* Do a readback to assure write has been done */
 		prm_read_mod_reg(WKUP_MOD, PM_WKEN);
 
-		while (!(prm_read_mod_reg(WKUP_MOD, PM_WKST) &
+		while (!(prm_read_mod_reg(WKUP_MOD, PM_WKEN) &
 			 OMAP3430_ST_IO_CHAIN_MASK)) {
 			timeout++;
 			if (timeout > 1000) {
@@ -108,7 +108,7 @@
 				return;
 			}
 			prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
-					     WKUP_MOD, PM_WKST);
+					     WKUP_MOD, PM_WKEN);
 		}
 	}
 }
diff -urN linux-2.6.35-rc3/arch/arm/mach-omap2/usb-ehci.c linux-2.6.35-rc4/arch/arm/mach-omap2/usb-ehci.c
--- linux-2.6.35-rc3/arch/arm/mach-omap2/usb-ehci.c	2010-07-05 05:34:21.421805809 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-omap2/usb-ehci.c	2010-07-05 05:34:26.822805494 +0000
@@ -20,6 +20,8 @@
 #include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/dma-mapping.h>
+
 #include <asm/io.h>
 #include <plat/mux.h>
 
diff -urN linux-2.6.35-rc3/arch/arm/mach-pxa/mioa701.c linux-2.6.35-rc4/arch/arm/mach-pxa/mioa701.c
--- linux-2.6.35-rc3/arch/arm/mach-pxa/mioa701.c	2010-07-05 05:34:21.428806366 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-pxa/mioa701.c	2010-07-05 05:34:26.828868078 +0000
@@ -697,7 +697,7 @@
 };
 
 /* Board I2C devices. */
-static struct i2c_board_info __initdata mioa701_i2c_devices[] = {
+static struct i2c_board_info mioa701_i2c_devices[] = {
 	{
 		I2C_BOARD_INFO("mt9m111", 0x5d),
 	},
diff -urN linux-2.6.35-rc3/arch/arm/mach-pxa/z2.c linux-2.6.35-rc4/arch/arm/mach-pxa/z2.c
--- linux-2.6.35-rc3/arch/arm/mach-pxa/z2.c	2010-07-05 05:34:21.433805992 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-pxa/z2.c	2010-07-05 05:34:26.833868063 +0000
@@ -3,8 +3,9 @@
  *
  *  Support for the Zipit Z2 Handheld device.
  *
- *  Author: 	Ken McGuire
- *  Created:	Jan 25, 2009
+ *  Copyright (C) 2009-2010 Marek Vasut <marek.vasut@gmail.com>
+ *
+ *  Based on research and code by: Ken McGuire
  *  Based on mainstone.c as modified for the Zipit Z2.
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -157,21 +158,14 @@
 	{
 		.name	= "U-Boot Bootloader",
 		.offset	= 0x0,
-		.size	= 0x20000,
-	},
-	{
-		.name	= "Linux Kernel",
-		.offset	= 0x20000,
-		.size	= 0x220000,
-	},
-	{
-		.name	= "Filesystem",
-		.offset	= 0x240000,
-		.size	= 0x5b0000,
-	},
-	{
+		.size	= 0x40000,
+	}, {
 		.name	= "U-Boot Environment",
-		.offset	= 0x7f0000,
+		.offset	= 0x40000,
+		.size	= 0x60000,
+	}, {
+		.name	= "Flash",
+		.offset	= 0x60000,
 		.size	= MTDPART_SIZ_FULL,
 	},
 };
diff -urN linux-2.6.35-rc3/arch/arm/mach-realview/Kconfig linux-2.6.35-rc4/arch/arm/mach-realview/Kconfig
--- linux-2.6.35-rc3/arch/arm/mach-realview/Kconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-realview/Kconfig	2010-07-05 05:34:26.834868050 +0000
@@ -18,6 +18,7 @@
 	bool "Support ARM11MPCore tile"
 	depends on MACH_REALVIEW_EB
 	select CPU_V6
+	select ARCH_HAS_BARRIERS if SMP
 	help
 	  Enable support for the ARM11MPCore tile on the Realview platform.
 
@@ -35,6 +36,7 @@
 	select CPU_V6
 	select ARM_GIC
 	select HAVE_PATA_PLATFORM
+	select ARCH_HAS_BARRIERS if SMP
 	help
 	  Include support for the ARM(R) RealView MPCore Platform Baseboard.
 	  PB11MPCore is a platform with an on-board ARM11MPCore and has
diff -urN linux-2.6.35-rc3/arch/arm/mach-realview/include/mach/barriers.h linux-2.6.35-rc4/arch/arm/mach-realview/include/mach/barriers.h
--- linux-2.6.35-rc3/arch/arm/mach-realview/include/mach/barriers.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-realview/include/mach/barriers.h	2010-07-05 05:34:26.835868081 +0000
@@ -0,0 +1,8 @@
+/*
+ * Barriers redefined for RealView ARM11MPCore platforms with L220 cache
+ * controller to work around hardware errata causing the outer_sync()
+ * operation to deadlock the system.
+ */
+#define mb()		dsb()
+#define rmb()		dmb()
+#define wmb()		mb()
diff -urN linux-2.6.35-rc3/arch/arm/mach-realview/realview_eb.c linux-2.6.35-rc4/arch/arm/mach-realview/realview_eb.c
--- linux-2.6.35-rc3/arch/arm/mach-realview/realview_eb.c	2010-07-05 05:34:21.435806442 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-realview/realview_eb.c	2010-07-05 05:34:26.836868109 +0000
@@ -32,6 +32,7 @@
 #include <asm/leds.h>
 #include <asm/mach-types.h>
 #include <asm/pmu.h>
+#include <asm/pgtable.h>
 #include <asm/hardware/gic.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/localtimer.h>
@@ -457,7 +458,7 @@
 
 MACHINE_START(REALVIEW_EB, "ARM-RealView EB")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
-	.phys_io	= REALVIEW_EB_UART0_BASE,
+	.phys_io	= REALVIEW_EB_UART0_BASE & SECTION_MASK,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_EB_UART0_BASE) >> 18) & 0xfffc,
 	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.fixup		= realview_fixup,
diff -urN linux-2.6.35-rc3/arch/arm/mach-realview/realview_pb1176.c linux-2.6.35-rc4/arch/arm/mach-realview/realview_pb1176.c
--- linux-2.6.35-rc3/arch/arm/mach-realview/realview_pb1176.c	2010-07-05 05:34:21.435806442 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-realview/realview_pb1176.c	2010-07-05 05:34:26.836868109 +0000
@@ -32,6 +32,7 @@
 #include <asm/leds.h>
 #include <asm/mach-types.h>
 #include <asm/pmu.h>
+#include <asm/pgtable.h>
 #include <asm/hardware/gic.h>
 #include <asm/hardware/cache-l2x0.h>
 
@@ -351,7 +352,7 @@
 
 MACHINE_START(REALVIEW_PB1176, "ARM-RealView PB1176")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
-	.phys_io	= REALVIEW_PB1176_UART0_BASE,
+	.phys_io	= REALVIEW_PB1176_UART0_BASE & SECTION_MASK,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PB1176_UART0_BASE) >> 18) & 0xfffc,
 	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.fixup		= realview_pb1176_fixup,
diff -urN linux-2.6.35-rc3/arch/arm/mach-realview/realview_pb11mp.c linux-2.6.35-rc4/arch/arm/mach-realview/realview_pb11mp.c
--- linux-2.6.35-rc3/arch/arm/mach-realview/realview_pb11mp.c	2010-07-05 05:34:21.436806139 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-realview/realview_pb11mp.c	2010-07-05 05:34:26.836868109 +0000
@@ -32,6 +32,7 @@
 #include <asm/leds.h>
 #include <asm/mach-types.h>
 #include <asm/pmu.h>
+#include <asm/pgtable.h>
 #include <asm/hardware/gic.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/localtimer.h>
@@ -373,7 +374,7 @@
 
 MACHINE_START(REALVIEW_PB11MP, "ARM-RealView PB11MPCore")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
-	.phys_io	= REALVIEW_PB11MP_UART0_BASE,
+	.phys_io	= REALVIEW_PB11MP_UART0_BASE & SECTION_MASK,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PB11MP_UART0_BASE) >> 18) & 0xfffc,
 	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.fixup		= realview_fixup,
diff -urN linux-2.6.35-rc3/arch/arm/mach-realview/realview_pba8.c linux-2.6.35-rc4/arch/arm/mach-realview/realview_pba8.c
--- linux-2.6.35-rc3/arch/arm/mach-realview/realview_pba8.c	2010-07-05 05:34:21.436806139 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-realview/realview_pba8.c	2010-07-05 05:34:26.836868109 +0000
@@ -31,6 +31,7 @@
 #include <asm/leds.h>
 #include <asm/mach-types.h>
 #include <asm/pmu.h>
+#include <asm/pgtable.h>
 #include <asm/hardware/gic.h>
 
 #include <asm/mach/arch.h>
@@ -323,7 +324,7 @@
 
 MACHINE_START(REALVIEW_PBA8, "ARM-RealView PB-A8")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
-	.phys_io	= REALVIEW_PBA8_UART0_BASE,
+	.phys_io	= REALVIEW_PBA8_UART0_BASE & SECTION_MASK,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PBA8_UART0_BASE) >> 18) & 0xfffc,
 	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.fixup		= realview_fixup,
diff -urN linux-2.6.35-rc3/arch/arm/mach-realview/realview_pbx.c linux-2.6.35-rc4/arch/arm/mach-realview/realview_pbx.c
--- linux-2.6.35-rc3/arch/arm/mach-realview/realview_pbx.c	2010-07-05 05:34:21.436806139 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-realview/realview_pbx.c	2010-07-05 05:34:26.837868030 +0000
@@ -31,6 +31,7 @@
 #include <asm/mach-types.h>
 #include <asm/pmu.h>
 #include <asm/smp_twd.h>
+#include <asm/pgtable.h>
 #include <asm/hardware/gic.h>
 #include <asm/hardware/cache-l2x0.h>
 
@@ -409,7 +410,7 @@
 
 MACHINE_START(REALVIEW_PBX, "ARM-RealView PBX")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
-	.phys_io	= REALVIEW_PBX_UART0_BASE,
+	.phys_io	= REALVIEW_PBX_UART0_BASE & SECTION_MASK,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PBX_UART0_BASE) >> 18) & 0xfffc,
 	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.fixup		= realview_pbx_fixup,
diff -urN linux-2.6.35-rc3/arch/arm/mach-vexpress/ct-ca9x4.c linux-2.6.35-rc4/arch/arm/mach-vexpress/ct-ca9x4.c
--- linux-2.6.35-rc3/arch/arm/mach-vexpress/ct-ca9x4.c	2010-07-05 05:34:21.478805993 +0000
+++ linux-2.6.35-rc4/arch/arm/mach-vexpress/ct-ca9x4.c	2010-07-05 05:34:26.880868076 +0000
@@ -2,6 +2,7 @@
  * Versatile Express Core Tile Cortex A9x4 Support
  */
 #include <linux/init.h>
+#include <linux/gfp.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
@@ -9,6 +10,7 @@
 #include <linux/amba/clcd.h>
 
 #include <asm/clkdev.h>
+#include <asm/pgtable.h>
 #include <asm/hardware/arm_timer.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/hardware/gic.h>
@@ -235,7 +237,7 @@
 }
 
 MACHINE_START(VEXPRESS, "ARM-Versatile Express CA9x4")
-	.phys_io	= V2M_UART0,
+	.phys_io	= V2M_UART0 & SECTION_MASK,
 	.io_pg_offst	= (__MMIO_P2V(V2M_UART0) >> 18) & 0xfffc,
 	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.map_io		= ct_ca9x4_map_io,
diff -urN linux-2.6.35-rc3/arch/arm/mm/Kconfig linux-2.6.35-rc4/arch/arm/mm/Kconfig
--- linux-2.6.35-rc3/arch/arm/mm/Kconfig	2010-07-05 05:34:21.481805947 +0000
+++ linux-2.6.35-rc4/arch/arm/mm/Kconfig	2010-07-05 05:34:26.883868073 +0000
@@ -735,6 +735,25 @@
 	  Forget about fast user space cmpxchg support.
 	  It is just not possible.
 
+config DMA_CACHE_RWFO
+	bool "Enable read/write for ownership DMA cache maintenance"
+	depends on CPU_V6 && SMP
+	default y
+	help
+	  The Snoop Control Unit on ARM11MPCore does not detect the
+	  cache maintenance operations and the dma_{map,unmap}_area()
+	  functions may leave stale cache entries on other CPUs. By
+	  enabling this option, Read or Write For Ownership in the ARMv6
+	  DMA cache maintenance functions is performed. These LDR/STR
+	  instructions change the cache line state to shared or modified
+	  so that the cache operation has the desired effect.
+
+	  Note that the workaround is only valid on processors that do
+	  not perform speculative loads into the D-cache. For such
+	  processors, if cache maintenance operations are not broadcast
+	  in hardware, other workarounds are needed (e.g. cache
+	  maintenance broadcasting in software via FIQ).
+
 config OUTER_CACHE
 	bool
 
@@ -794,6 +813,8 @@
 
 config ARM_DMA_MEM_BUFFERABLE
 	bool "Use non-cacheable memory for DMA" if CPU_V6 && !CPU_V7
+	depends on !(MACH_REALVIEW_PB1176 || REALVIEW_EB_ARM11MP || \
+		     MACH_REALVIEW_PB11MP)
 	default y if CPU_V6 || CPU_V7
 	help
 	  Historically, the kernel has used strongly ordered mappings to
diff -urN linux-2.6.35-rc3/arch/arm/mm/cache-v6.S linux-2.6.35-rc4/arch/arm/mm/cache-v6.S
--- linux-2.6.35-rc3/arch/arm/mm/cache-v6.S	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/arm/mm/cache-v6.S	2010-07-05 05:34:26.885805477 +0000
@@ -211,8 +211,9 @@
 	mcrne	p15, 0, r1, c7, c15, 1		@ clean & invalidate unified line
 #endif
 1:
-#ifdef CONFIG_SMP
-	str	r0, [r0]			@ write for ownership
+#ifdef CONFIG_DMA_CACHE_RWFO
+	ldr	r2, [r0]			@ read for ownership
+	str	r2, [r0]			@ write for ownership
 #endif
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D line
@@ -234,7 +235,7 @@
 v6_dma_clean_range:
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
-#ifdef CONFIG_SMP
+#ifdef CONFIG_DMA_CACHE_RWFO
 	ldr	r2, [r0]			@ read for ownership
 #endif
 #ifdef HARVARD_CACHE
@@ -257,7 +258,7 @@
 ENTRY(v6_dma_flush_range)
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
-#ifdef CONFIG_SMP
+#ifdef CONFIG_DMA_CACHE_RWFO
 	ldr	r2, [r0]			@ read for ownership
 	str	r2, [r0]			@ write for ownership
 #endif
@@ -283,9 +284,13 @@
 	add	r1, r1, r0
 	teq	r2, #DMA_FROM_DEVICE
 	beq	v6_dma_inv_range
+#ifndef CONFIG_DMA_CACHE_RWFO
+	b	v6_dma_clean_range
+#else
 	teq	r2, #DMA_TO_DEVICE
 	beq	v6_dma_clean_range
 	b	v6_dma_flush_range
+#endif
 ENDPROC(v6_dma_map_area)
 
 /*
@@ -295,6 +300,11 @@
  *	- dir	- DMA direction
  */
 ENTRY(v6_dma_unmap_area)
+#ifndef CONFIG_DMA_CACHE_RWFO
+	add	r1, r1, r0
+	teq	r2, #DMA_TO_DEVICE
+	bne	v6_dma_inv_range
+#endif
 	mov	pc, lr
 ENDPROC(v6_dma_unmap_area)
 
diff -urN linux-2.6.35-rc3/arch/arm/mm/dma-mapping.c linux-2.6.35-rc4/arch/arm/mm/dma-mapping.c
--- linux-2.6.35-rc3/arch/arm/mm/dma-mapping.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/arm/mm/dma-mapping.c	2010-07-05 05:34:26.886806077 +0000
@@ -24,15 +24,6 @@
 #include <asm/tlbflush.h>
 #include <asm/sizes.h>
 
-/* Sanity check size */
-#if (CONSISTENT_DMA_SIZE % SZ_2M)
-#error "CONSISTENT_DMA_SIZE must be multiple of 2MiB"
-#endif
-
-#define CONSISTENT_OFFSET(x)	(((unsigned long)(x) - CONSISTENT_BASE) >> PAGE_SHIFT)
-#define CONSISTENT_PTE_INDEX(x) (((unsigned long)(x) - CONSISTENT_BASE) >> PGDIR_SHIFT)
-#define NUM_CONSISTENT_PTES (CONSISTENT_DMA_SIZE >> PGDIR_SHIFT)
-
 static u64 get_coherent_dma_mask(struct device *dev)
 {
 	u64 mask = ISA_DMA_THRESHOLD;
@@ -123,6 +114,15 @@
 }
 
 #ifdef CONFIG_MMU
+/* Sanity check size */
+#if (CONSISTENT_DMA_SIZE % SZ_2M)
+#error "CONSISTENT_DMA_SIZE must be multiple of 2MiB"
+#endif
+
+#define CONSISTENT_OFFSET(x)	(((unsigned long)(x) - CONSISTENT_BASE) >> PAGE_SHIFT)
+#define CONSISTENT_PTE_INDEX(x) (((unsigned long)(x) - CONSISTENT_BASE) >> PGDIR_SHIFT)
+#define NUM_CONSISTENT_PTES (CONSISTENT_DMA_SIZE >> PGDIR_SHIFT)
+
 /*
  * These are the page tables (2MB each) covering uncached, DMA consistent allocations
  */
diff -urN linux-2.6.35-rc3/arch/arm/plat-omap/dmtimer.c linux-2.6.35-rc4/arch/arm/plat-omap/dmtimer.c
--- linux-2.6.35-rc3/arch/arm/plat-omap/dmtimer.c	2010-07-05 05:34:21.493806031 +0000
+++ linux-2.6.35-rc4/arch/arm/plat-omap/dmtimer.c	2010-07-05 05:34:26.896868075 +0000
@@ -541,11 +541,11 @@
 		  * timer is stopped
 		  */
 		udelay(3500000 / clk_get_rate(timer->fclk) + 1);
-		/* Ack possibly pending interrupt */
-		omap_dm_timer_write_reg(timer, OMAP_TIMER_STAT_REG,
-				OMAP_TIMER_INT_OVERFLOW);
 #endif
 	}
+	/* Ack possibly pending interrupt */
+	omap_dm_timer_write_reg(timer, OMAP_TIMER_STAT_REG,
+			OMAP_TIMER_INT_OVERFLOW);
 }
 EXPORT_SYMBOL_GPL(omap_dm_timer_stop);
 
diff -urN linux-2.6.35-rc3/arch/arm/plat-omap/gpio.c linux-2.6.35-rc4/arch/arm/plat-omap/gpio.c
--- linux-2.6.35-rc3/arch/arm/plat-omap/gpio.c	2010-07-05 05:34:21.494806052 +0000
+++ linux-2.6.35-rc4/arch/arm/plat-omap/gpio.c	2010-07-05 05:34:26.897868038 +0000
@@ -673,6 +673,7 @@
 		if (cpu_is_omap34xx() || cpu_is_omap44xx())
 			clk_disable(bank->dbck);
 	}
+	bank->dbck_enable_mask = val;
 
 	__raw_writel(val, reg);
 }
diff -urN linux-2.6.35-rc3/arch/arm/plat-omap/iovmm.c linux-2.6.35-rc4/arch/arm/plat-omap/iovmm.c
--- linux-2.6.35-rc3/arch/arm/plat-omap/iovmm.c	2010-07-05 05:34:21.497806051 +0000
+++ linux-2.6.35-rc4/arch/arm/plat-omap/iovmm.c	2010-07-05 05:34:26.901868067 +0000
@@ -140,8 +140,10 @@
 		return ERR_PTR(-ENOMEM);
 
 	err = sg_alloc_table(sgt, nr_entries, GFP_KERNEL);
-	if (err)
+	if (err) {
+		kfree(sgt);
 		return ERR_PTR(err);
+	}
 
 	pr_debug("%s: sgt:%p(%d entries)\n", __func__, sgt, nr_entries);
 
diff -urN linux-2.6.35-rc3/arch/arm/plat-pxa/Makefile linux-2.6.35-rc4/arch/arm/plat-pxa/Makefile
--- linux-2.6.35-rc3/arch/arm/plat-pxa/Makefile	2010-07-05 05:34:21.498805909 +0000
+++ linux-2.6.35-rc4/arch/arm/plat-pxa/Makefile	2010-07-05 05:34:26.902868067 +0000
@@ -2,8 +2,9 @@
 # Makefile for code common across different PXA processor families
 #
 
-obj-y	:= dma.o pmu.o
+obj-y	:= dma.o
 
+obj-$(CONFIG_ARCH_PXA)		+= pmu.o
 obj-$(CONFIG_GENERIC_GPIO)	+= gpio.o
 obj-$(CONFIG_PXA3xx)		+= mfp.o
 obj-$(CONFIG_ARCH_MMP)		+= mfp.o
diff -urN linux-2.6.35-rc3/arch/ia64/mm/tlb.c linux-2.6.35-rc4/arch/ia64/mm/tlb.c
--- linux-2.6.35-rc3/arch/ia64/mm/tlb.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/ia64/mm/tlb.c	2010-07-05 05:34:26.949868058 +0000
@@ -121,7 +121,7 @@
 	ia64_invala();
 
 	for (;;) {
-		asm volatile ("ld4.c.nc %0=[%1]" : "=r"(serve) : "r"(&ss->serve) : "memory");
+		asm volatile ("ld8.c.nc %0=[%1]" : "=r"(serve) : "r"(&ss->serve) : "memory");
 		if (time_before(t, serve))
 			return;
 		cpu_relax();
diff -urN linux-2.6.35-rc3/arch/powerpc/Kconfig.debug linux-2.6.35-rc4/arch/powerpc/Kconfig.debug
--- linux-2.6.35-rc3/arch/powerpc/Kconfig.debug	2010-07-05 05:34:21.570805546 +0000
+++ linux-2.6.35-rc4/arch/powerpc/Kconfig.debug	2010-07-05 05:34:26.973868097 +0000
@@ -135,13 +135,6 @@
 	depends on KGDB || XMON
 	default y
 
-config IRQSTACKS
-	bool "Use separate kernel stacks when processing interrupts"
-	help
-	  If you say Y here the kernel will use separate kernel stacks
-	  for handling hard and soft interrupts.  This can help avoid
-	  overflowing the process kernel stacks.
-
 config VIRQ_DEBUG
 	bool "Expose hardware/virtual IRQ mapping via debugfs"
 	depends on DEBUG_FS
diff -urN linux-2.6.35-rc3/arch/powerpc/boot/Makefile linux-2.6.35-rc4/arch/powerpc/boot/Makefile
--- linux-2.6.35-rc3/arch/powerpc/boot/Makefile	2010-07-05 05:34:21.571805513 +0000
+++ linux-2.6.35-rc4/arch/powerpc/boot/Makefile	2010-07-05 05:34:26.974868060 +0000
@@ -141,7 +141,7 @@
 $(obj)/wrapper.a: $(obj-wlib) FORCE
 	$(call if_changed,bootar)
 
-hostprogs-y	:= addnote addRamDisk hack-coff mktree
+hostprogs-y	:= addnote hack-coff mktree
 
 targets		+= $(patsubst $(obj)/%,%,$(obj-boot) wrapper.a)
 extra-y		:= $(obj)/wrapper.a $(obj-plat) $(obj)/empty.o \
diff -urN linux-2.6.35-rc3/arch/powerpc/boot/addRamDisk.c linux-2.6.35-rc4/arch/powerpc/boot/addRamDisk.c
--- linux-2.6.35-rc3/arch/powerpc/boot/addRamDisk.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/boot/addRamDisk.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,311 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <netinet/in.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <string.h>
-#include <elf.h>
-
-#define ElfHeaderSize  (64 * 1024)
-#define ElfPages  (ElfHeaderSize / 4096)
-#define KERNELBASE (0xc000000000000000)
-#define _ALIGN_UP(addr,size)	(((addr)+((size)-1))&(~((size)-1)))
-
-struct addr_range {
-	unsigned long long addr;
-	unsigned long memsize;
-	unsigned long offset;
-};
-
-static int check_elf64(void *p, int size, struct addr_range *r)
-{
-	Elf64_Ehdr *elf64 = p;
-	Elf64_Phdr *elf64ph;
-
-	if (elf64->e_ident[EI_MAG0] != ELFMAG0 ||
-	    elf64->e_ident[EI_MAG1] != ELFMAG1 ||
-	    elf64->e_ident[EI_MAG2] != ELFMAG2 ||
-	    elf64->e_ident[EI_MAG3] != ELFMAG3 ||
-	    elf64->e_ident[EI_CLASS] != ELFCLASS64 ||
-	    elf64->e_ident[EI_DATA] != ELFDATA2MSB ||
-	    elf64->e_type != ET_EXEC || elf64->e_machine != EM_PPC64)
-		return 0;
-
-	if ((elf64->e_phoff + sizeof(Elf64_Phdr)) > size)
-		return 0;
-
-	elf64ph = (Elf64_Phdr *) ((unsigned long)elf64 +
-				  (unsigned long)elf64->e_phoff);
-
-	r->memsize = (unsigned long)elf64ph->p_memsz;
-	r->offset = (unsigned long)elf64ph->p_offset;
-	r->addr = (unsigned long long)elf64ph->p_vaddr;
-
-#ifdef DEBUG
-	printf("PPC64 ELF file, ph:\n");
-	printf("p_type   0x%08x\n", elf64ph->p_type);
-	printf("p_flags  0x%08x\n", elf64ph->p_flags);
-	printf("p_offset 0x%016llx\n", elf64ph->p_offset);
-	printf("p_vaddr  0x%016llx\n", elf64ph->p_vaddr);
-	printf("p_paddr  0x%016llx\n", elf64ph->p_paddr);
-	printf("p_filesz 0x%016llx\n", elf64ph->p_filesz);
-	printf("p_memsz  0x%016llx\n", elf64ph->p_memsz);
-	printf("p_align  0x%016llx\n", elf64ph->p_align);
-	printf("... skipping 0x%08lx bytes of ELF header\n",
-	       (unsigned long)elf64ph->p_offset);
-#endif
-
-	return 64;
-}
-static void get4k(FILE *file, char *buf )
-{
-	unsigned j;
-	unsigned num = fread(buf, 1, 4096, file);
-	for ( j=num; j<4096; ++j )
-		buf[j] = 0;
-}
-
-static void put4k(FILE *file, char *buf )
-{
-	fwrite(buf, 1, 4096, file);
-}
-
-static void death(const char *msg, FILE *fdesc, const char *fname)
-{
-	fprintf(stderr, msg);
-	fclose(fdesc);
-	unlink(fname);
-	exit(1);
-}
-
-int main(int argc, char **argv)
-{
-	char inbuf[4096];
-	struct addr_range vmlinux;
-	FILE *ramDisk;
-	FILE *inputVmlinux;
-	FILE *outputVmlinux;
-
-	char *rd_name, *lx_name, *out_name;
-
-	size_t i;
-	unsigned long ramFileLen;
-	unsigned long ramLen;
-	unsigned long roundR;
-	unsigned long offset_end;
-
-	unsigned long kernelLen;
-	unsigned long actualKernelLen;
-	unsigned long round;
-	unsigned long roundedKernelLen;
-	unsigned long ramStartOffs;
-	unsigned long ramPages;
-	unsigned long roundedKernelPages;
-	unsigned long hvReleaseData;
-	u_int32_t eyeCatcher = 0xc8a5d9c4;
-	unsigned long naca;
-	unsigned long xRamDisk;
-	unsigned long xRamDiskSize;
-	long padPages;
-  
-  
-	if (argc < 2) {
-		fprintf(stderr, "Name of RAM disk file missing.\n");
-		exit(1);
-	}
-	rd_name = argv[1];
-
-	if (argc < 3) {
-		fprintf(stderr, "Name of vmlinux file missing.\n");
-		exit(1);
-	}
-	lx_name = argv[2];
-
-	if (argc < 4) {
-		fprintf(stderr, "Name of vmlinux output file missing.\n");
-		exit(1);
-	}
-	out_name = argv[3];
-
-
-	ramDisk = fopen(rd_name, "r");
-	if ( ! ramDisk ) {
-		fprintf(stderr, "RAM disk file \"%s\" failed to open.\n", rd_name);
-		exit(1);
-	}
-
-	inputVmlinux = fopen(lx_name, "r");
-	if ( ! inputVmlinux ) {
-		fprintf(stderr, "vmlinux file \"%s\" failed to open.\n", lx_name);
-		exit(1);
-	}
-  
-	outputVmlinux = fopen(out_name, "w+");
-	if ( ! outputVmlinux ) {
-		fprintf(stderr, "output vmlinux file \"%s\" failed to open.\n", out_name);
-		exit(1);
-	}
-
-	i = fread(inbuf, 1, sizeof(inbuf), inputVmlinux);
-	if (i != sizeof(inbuf)) {
-		fprintf(stderr, "can not read vmlinux file %s: %u\n", lx_name, i);
-		exit(1);
-	}
-
-	i = check_elf64(inbuf, sizeof(inbuf), &vmlinux);
-	if (i == 0) {
-		fprintf(stderr, "You must have a linux kernel specified as argv[2]\n");
-		exit(1);
-	}
-
-	/* Input Vmlinux file */
-	fseek(inputVmlinux, 0, SEEK_END);
-	kernelLen = ftell(inputVmlinux);
-	fseek(inputVmlinux, 0, SEEK_SET);
-	printf("kernel file size = %lu\n", kernelLen);
-
-	actualKernelLen = kernelLen - ElfHeaderSize;
-
-	printf("actual kernel length (minus ELF header) = %lu\n", actualKernelLen);
-
-	round = actualKernelLen % 4096;
-	roundedKernelLen = actualKernelLen;
-	if ( round )
-		roundedKernelLen += (4096 - round);
-	printf("Vmlinux length rounded up to a 4k multiple = %ld/0x%lx \n", roundedKernelLen, roundedKernelLen);
-	roundedKernelPages = roundedKernelLen / 4096;
-	printf("Vmlinux pages to copy = %ld/0x%lx \n", roundedKernelPages, roundedKernelPages);
-
-	offset_end = _ALIGN_UP(vmlinux.memsize, 4096);
-	/* calc how many pages we need to insert between the vmlinux and the start of the ram disk */
-	padPages = offset_end/4096 - roundedKernelPages;
-
-	/* Check and see if the vmlinux is already larger than _end in System.map */
-	if (padPages < 0) {
-		/* vmlinux is larger than _end - adjust the offset to the start of the embedded ram disk */ 
-		offset_end = roundedKernelLen;
-		printf("vmlinux is larger than _end indicates it needs to be - offset_end = %lx \n", offset_end);
-		padPages = 0;
-		printf("will insert %lx pages between the vmlinux and the start of the ram disk \n", padPages);
-	}
-	else {
-		/* _end is larger than vmlinux - use the offset to _end that we calculated from the system map */
-		printf("vmlinux is smaller than _end indicates is needed - offset_end = %lx \n", offset_end);
-		printf("will insert %lx pages between the vmlinux and the start of the ram disk \n", padPages);
-	}
-
-
-
-	/* Input Ram Disk file */
-	// Set the offset that the ram disk will be started at.
-	ramStartOffs = offset_end;  /* determined from the input vmlinux file and the system map */
-	printf("Ram Disk will start at offset = 0x%lx \n", ramStartOffs);
-  
-	fseek(ramDisk, 0, SEEK_END);
-	ramFileLen = ftell(ramDisk);
-	fseek(ramDisk, 0, SEEK_SET);
-	printf("%s file size = %ld/0x%lx \n", rd_name, ramFileLen, ramFileLen);
-
-	ramLen = ramFileLen;
-
-	roundR = 4096 - (ramLen % 4096);
-	if ( roundR ) {
-		printf("Rounding RAM disk file up to a multiple of 4096, adding %ld/0x%lx \n", roundR, roundR);
-		ramLen += roundR;
-	}
-
-	printf("Rounded RAM disk size is %ld/0x%lx \n", ramLen, ramLen);
-	ramPages = ramLen / 4096;
-	printf("RAM disk pages to copy = %ld/0x%lx\n", ramPages, ramPages);
-
-
-
-  // Copy 64K ELF header
-	for (i=0; i<(ElfPages); ++i) {
-		get4k( inputVmlinux, inbuf );
-		put4k( outputVmlinux, inbuf );
-	}
-
-	/* Copy the vmlinux (as full pages). */
-	fseek(inputVmlinux, ElfHeaderSize, SEEK_SET);
-	for ( i=0; i<roundedKernelPages; ++i ) {
-		get4k( inputVmlinux, inbuf );
-		put4k( outputVmlinux, inbuf );
-	}
-  
-	/* Insert pad pages (if appropriate) that are needed between */
-	/* | the end of the vmlinux and the ram disk. */
-	for (i=0; i<padPages; ++i) {
-		memset(inbuf, 0, 4096);
-		put4k(outputVmlinux, inbuf);
-	}
-
-	/* Copy the ram disk (as full pages). */
-	for ( i=0; i<ramPages; ++i ) {
-		get4k( ramDisk, inbuf );
-		put4k( outputVmlinux, inbuf );
-	}
-
-	/* Close the input files */
-	fclose(ramDisk);
-	fclose(inputVmlinux);
-	/* And flush the written output file */
-	fflush(outputVmlinux);
-
-
-
-	/* Fixup the new vmlinux to contain the ram disk starting offset (xRamDisk) and the ram disk size (xRamDiskSize) */
-	/* fseek to the hvReleaseData pointer */
-	fseek(outputVmlinux, ElfHeaderSize + 0x24, SEEK_SET);
-	if (fread(&hvReleaseData, 4, 1, outputVmlinux) != 1) {
-		death("Could not read hvReleaseData pointer\n", outputVmlinux, out_name);
-	}
-	hvReleaseData = ntohl(hvReleaseData); /* Convert to native int */
-	printf("hvReleaseData is at %08lx\n", hvReleaseData);
-
-	/* fseek to the hvReleaseData */
-	fseek(outputVmlinux, ElfHeaderSize + hvReleaseData, SEEK_SET);
-	if (fread(inbuf, 0x40, 1, outputVmlinux) != 1) {
-		death("Could not read hvReleaseData\n", outputVmlinux, out_name);
-	}
-	/* Check hvReleaseData sanity */
-	if (memcmp(inbuf, &eyeCatcher, 4) != 0) {
-		death("hvReleaseData is invalid\n", outputVmlinux, out_name);
-	}
-	/* Get the naca pointer */
-	naca = ntohl(*((u_int32_t*) &inbuf[0x0C])) - KERNELBASE;
-	printf("Naca is at offset 0x%lx \n", naca);
-
-	/* fseek to the naca */
-	fseek(outputVmlinux, ElfHeaderSize + naca, SEEK_SET);
-	if (fread(inbuf, 0x18, 1, outputVmlinux) != 1) {
-		death("Could not read naca\n", outputVmlinux, out_name);
-	}
-	xRamDisk = ntohl(*((u_int32_t *) &inbuf[0x0c]));
-	xRamDiskSize = ntohl(*((u_int32_t *) &inbuf[0x14]));
-	/* Make sure a RAM disk isn't already present */
-	if ((xRamDisk != 0) || (xRamDiskSize != 0)) {
-		death("RAM disk is already attached to this kernel\n", outputVmlinux, out_name);
-	}
-	/* Fill in the values */
-	*((u_int32_t *) &inbuf[0x0c]) = htonl(ramStartOffs);
-	*((u_int32_t *) &inbuf[0x14]) = htonl(ramPages);
-
-	/* Write out the new naca */
-	fflush(outputVmlinux);
-	fseek(outputVmlinux, ElfHeaderSize + naca, SEEK_SET);
-	if (fwrite(inbuf, 0x18, 1, outputVmlinux) != 1) {
-		death("Could not write naca\n", outputVmlinux, out_name);
-	}
-	printf("Ram Disk of 0x%lx pages is attached to the kernel at offset 0x%08lx\n",
-	       ramPages, ramStartOffs);
-
-	/* Done */
-	fclose(outputVmlinux);
-	/* Set permission to executable */
-	chmod(out_name, S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH);
-
-	return 0;
-}
-
diff -urN linux-2.6.35-rc3/arch/powerpc/boot/dts/lite5200.dts linux-2.6.35-rc4/arch/powerpc/boot/dts/lite5200.dts
--- linux-2.6.35-rc3/arch/powerpc/boot/dts/lite5200.dts	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/boot/dts/lite5200.dts	2010-07-05 05:34:26.975868096 +0000
@@ -134,12 +134,16 @@
 			compatible = "fsl,mpc5200-gpio";
 			reg = <0xb00 0x40>;
 			interrupts = <1 7 0>;
+			gpio-controller;
+			#gpio-cells = <2>;
 		};
 
 		gpio@c00 {
 			compatible = "fsl,mpc5200-gpio-wkup";
 			reg = <0xc00 0x40>;
 			interrupts = <1 8 0 0 3 0>;
+			gpio-controller;
+			#gpio-cells = <2>;
 		};
 
 		spi@f00 {
@@ -230,8 +234,8 @@
 			reg = <0x3000 0x400>;	// fec range, since we need to setup fec interrupts
 			interrupts = <2 5 0>;	// these are for "mii command finished", not link changes & co.
 
-			phy0: ethernet-phy@1 {
-				reg = <1>;
+			phy0: ethernet-phy@0 {
+				reg = <0>;
 			};
 		};
 
@@ -255,7 +259,13 @@
 			compatible = "fsl,mpc5200-i2c","fsl-i2c";
 			reg = <0x3d40 0x40>;
 			interrupts = <2 16 0>;
+
+			eeprom@50 {
+				compatible = "atmel,24c02";
+				reg = <0x50>;
+			};
 		};
+
 		sram@8000 {
 			compatible = "fsl,mpc5200-sram";
 			reg = <0x8000 0x4000>;
@@ -281,4 +291,18 @@
 			  0x02000000 0 0xa0000000 0xa0000000 0 0x10000000
 			  0x01000000 0 0x00000000 0xb0000000 0 0x01000000>;
 	};
+
+	localbus {
+		compatible = "fsl,mpc5200-lpb","simple-bus";
+		#address-cells = <2>;
+		#size-cells = <1>;
+
+		ranges = <0 0 0xff000000 0x01000000>;
+
+		flash@0,0 {
+			compatible = "amd,am29lv652d", "cfi-flash";
+			reg = <0 0 0x01000000>;
+			bank-width = <1>;
+		};
+	};
 };
diff -urN linux-2.6.35-rc3/arch/powerpc/boot/dts/lite5200b.dts linux-2.6.35-rc4/arch/powerpc/boot/dts/lite5200b.dts
--- linux-2.6.35-rc3/arch/powerpc/boot/dts/lite5200b.dts	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/boot/dts/lite5200b.dts	2010-07-05 05:34:26.975868096 +0000
@@ -259,6 +259,11 @@
 			compatible = "fsl,mpc5200b-i2c","fsl,mpc5200-i2c","fsl-i2c";
 			reg = <0x3d40 0x40>;
 			interrupts = <2 16 0>;
+
+			eeprom@50 {
+				compatible = "atmel,24c02";
+				reg = <0x50>;
+			};
 		};
 
 		sram@8000 {
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/40x/acadia_defconfig linux-2.6.35-rc4/arch/powerpc/configs/40x/acadia_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/40x/acadia_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/40x/acadia_defconfig	2010-07-05 05:34:26.977868075 +0000
@@ -98,8 +98,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/40x/ep405_defconfig linux-2.6.35-rc4/arch/powerpc/configs/40x/ep405_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/40x/ep405_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/40x/ep405_defconfig	2010-07-05 05:34:26.978868047 +0000
@@ -98,8 +98,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/40x/hcu4_defconfig linux-2.6.35-rc4/arch/powerpc/configs/40x/hcu4_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/40x/hcu4_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/40x/hcu4_defconfig	2010-07-05 05:34:26.978868047 +0000
@@ -98,8 +98,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/40x/kilauea_defconfig linux-2.6.35-rc4/arch/powerpc/configs/40x/kilauea_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/40x/kilauea_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/40x/kilauea_defconfig	2010-07-05 05:34:26.978868047 +0000
@@ -98,8 +98,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/40x/makalu_defconfig linux-2.6.35-rc4/arch/powerpc/configs/40x/makalu_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/40x/makalu_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/40x/makalu_defconfig	2010-07-05 05:34:26.978868047 +0000
@@ -98,8 +98,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/40x/virtex_defconfig linux-2.6.35-rc4/arch/powerpc/configs/40x/virtex_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/40x/virtex_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/40x/virtex_defconfig	2010-07-05 05:34:26.978868047 +0000
@@ -77,8 +77,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/40x/walnut_defconfig linux-2.6.35-rc4/arch/powerpc/configs/40x/walnut_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/40x/walnut_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/40x/walnut_defconfig	2010-07-05 05:34:26.979868074 +0000
@@ -98,8 +98,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/arches_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/arches_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/arches_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/arches_defconfig	2010-07-05 05:34:26.979868074 +0000
@@ -98,8 +98,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/bamboo_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/bamboo_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/bamboo_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/bamboo_defconfig	2010-07-05 05:34:26.979868074 +0000
@@ -102,8 +102,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/canyonlands_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/canyonlands_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/canyonlands_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/canyonlands_defconfig	2010-07-05 05:34:26.979868074 +0000
@@ -98,8 +98,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/ebony_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/ebony_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/ebony_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/ebony_defconfig	2010-07-05 05:34:26.979868074 +0000
@@ -101,8 +101,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/eiger_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/eiger_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/eiger_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/eiger_defconfig	2010-07-05 05:34:26.979868074 +0000
@@ -98,8 +98,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/katmai_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/katmai_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/katmai_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/katmai_defconfig	2010-07-05 05:34:26.981868065 +0000
@@ -97,8 +97,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/rainier_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/rainier_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/rainier_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/rainier_defconfig	2010-07-05 05:34:26.981868065 +0000
@@ -101,8 +101,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/redwood_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/redwood_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/redwood_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/redwood_defconfig	2010-07-05 05:34:26.981868065 +0000
@@ -98,8 +98,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/sam440ep_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/sam440ep_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/sam440ep_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/sam440ep_defconfig	2010-07-05 05:34:26.981868065 +0000
@@ -103,8 +103,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/sequoia_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/sequoia_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/sequoia_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/sequoia_defconfig	2010-07-05 05:34:26.982868037 +0000
@@ -102,8 +102,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/taishan_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/taishan_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/taishan_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/taishan_defconfig	2010-07-05 05:34:26.982868037 +0000
@@ -101,8 +101,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/44x/virtex5_defconfig linux-2.6.35-rc4/arch/powerpc/configs/44x/virtex5_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/44x/virtex5_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/44x/virtex5_defconfig	2010-07-05 05:34:26.982868037 +0000
@@ -80,8 +80,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/52xx/cm5200_defconfig linux-2.6.35-rc4/arch/powerpc/configs/52xx/cm5200_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/52xx/cm5200_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/52xx/cm5200_defconfig	2010-07-05 05:34:26.982868037 +0000
@@ -95,8 +95,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/52xx/lite5200b_defconfig linux-2.6.35-rc4/arch/powerpc/configs/52xx/lite5200b_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/52xx/lite5200b_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/52xx/lite5200b_defconfig	2010-07-05 05:34:26.982868037 +0000
@@ -96,8 +96,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/52xx/motionpro_defconfig linux-2.6.35-rc4/arch/powerpc/configs/52xx/motionpro_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/52xx/motionpro_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/52xx/motionpro_defconfig	2010-07-05 05:34:26.983868058 +0000
@@ -95,8 +95,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/52xx/pcm030_defconfig linux-2.6.35-rc4/arch/powerpc/configs/52xx/pcm030_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/52xx/pcm030_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/52xx/pcm030_defconfig	2010-07-05 05:34:26.983868058 +0000
@@ -98,8 +98,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 # CONFIG_BLK_DEV_INITRD is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/52xx/tqm5200_defconfig linux-2.6.35-rc4/arch/powerpc/configs/52xx/tqm5200_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/52xx/tqm5200_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/52xx/tqm5200_defconfig	2010-07-05 05:34:26.983868058 +0000
@@ -95,8 +95,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/86xx/gef_ppc9a_defconfig linux-2.6.35-rc4/arch/powerpc/configs/86xx/gef_ppc9a_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/86xx/gef_ppc9a_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/86xx/gef_ppc9a_defconfig	2010-07-05 05:34:26.983868058 +0000
@@ -103,8 +103,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_RELAY=y
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/86xx/gef_sbc310_defconfig linux-2.6.35-rc4/arch/powerpc/configs/86xx/gef_sbc310_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/86xx/gef_sbc310_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/86xx/gef_sbc310_defconfig	2010-07-05 05:34:26.983868058 +0000
@@ -103,8 +103,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_RELAY=y
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/86xx/gef_sbc610_defconfig linux-2.6.35-rc4/arch/powerpc/configs/86xx/gef_sbc610_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/86xx/gef_sbc610_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/86xx/gef_sbc610_defconfig	2010-07-05 05:34:26.984868148 +0000
@@ -103,8 +103,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_RELAY=y
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/86xx/mpc8610_hpcd_defconfig linux-2.6.35-rc4/arch/powerpc/configs/86xx/mpc8610_hpcd_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/86xx/mpc8610_hpcd_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/86xx/mpc8610_hpcd_defconfig	2010-07-05 05:34:26.984868148 +0000
@@ -98,8 +98,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/86xx/mpc8641_hpcn_defconfig linux-2.6.35-rc4/arch/powerpc/configs/86xx/mpc8641_hpcn_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/86xx/mpc8641_hpcn_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/86xx/mpc8641_hpcn_defconfig	2010-07-05 05:34:26.984868148 +0000
@@ -103,8 +103,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/86xx/sbc8641d_defconfig linux-2.6.35-rc4/arch/powerpc/configs/86xx/sbc8641d_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/86xx/sbc8641d_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/86xx/sbc8641d_defconfig	2010-07-05 05:34:26.984868148 +0000
@@ -102,8 +102,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_RELAY=y
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/adder875_defconfig linux-2.6.35-rc4/arch/powerpc/configs/adder875_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/adder875_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/adder875_defconfig	2010-07-05 05:34:26.985868181 +0000
@@ -92,8 +92,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 # CONFIG_BLK_DEV_INITRD is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/amigaone_defconfig linux-2.6.35-rc4/arch/powerpc/configs/amigaone_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/amigaone_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/amigaone_defconfig	2010-07-05 05:34:26.985868181 +0000
@@ -87,8 +87,7 @@
 CONFIG_LOG_BUF_SHIFT=15
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/c2k_defconfig linux-2.6.35-rc4/arch/powerpc/configs/c2k_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/c2k_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/c2k_defconfig	2010-07-05 05:34:26.985868181 +0000
@@ -102,8 +102,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/cell_defconfig linux-2.6.35-rc4/arch/powerpc/configs/cell_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/cell_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/cell_defconfig	2010-07-05 05:34:26.985868181 +0000
@@ -83,8 +83,7 @@
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUP_CPUACCT is not set
 # CONFIG_RESOURCE_COUNTERS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_PROC_PID_CPUSET=y
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/celleb_defconfig linux-2.6.35-rc4/arch/powerpc/configs/celleb_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/celleb_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/celleb_defconfig	2010-07-05 05:34:26.985868181 +0000
@@ -78,8 +78,7 @@
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_USER_SCHED is not set
 # CONFIG_CGROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/chrp32_defconfig linux-2.6.35-rc4/arch/powerpc/configs/chrp32_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/chrp32_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/chrp32_defconfig	2010-07-05 05:34:26.986868063 +0000
@@ -77,8 +77,7 @@
 CONFIG_LOG_BUF_SHIFT=15
 # CONFIG_CGROUPS is not set
 # CONFIG_GROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/ep8248e_defconfig linux-2.6.35-rc4/arch/powerpc/configs/ep8248e_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/ep8248e_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/ep8248e_defconfig	2010-07-05 05:34:26.986868063 +0000
@@ -96,8 +96,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 # CONFIG_BLK_DEV_INITRD is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/ep88xc_defconfig linux-2.6.35-rc4/arch/powerpc/configs/ep88xc_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/ep88xc_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/ep88xc_defconfig	2010-07-05 05:34:26.986868063 +0000
@@ -91,8 +91,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 # CONFIG_BLK_DEV_INITRD is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/g5_defconfig linux-2.6.35-rc4/arch/powerpc/configs/g5_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/g5_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/g5_defconfig	2010-07-05 05:34:26.986868063 +0000
@@ -82,8 +82,7 @@
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_CGROUPS is not set
 # CONFIG_GROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/gamecube_defconfig linux-2.6.35-rc4/arch/powerpc/configs/gamecube_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/gamecube_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/gamecube_defconfig	2010-07-05 05:34:26.987868057 +0000
@@ -101,8 +101,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/holly_defconfig linux-2.6.35-rc4/arch/powerpc/configs/holly_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/holly_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/holly_defconfig	2010-07-05 05:34:26.987868057 +0000
@@ -73,7 +73,6 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
 # CONFIG_FAIR_GROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
 # CONFIG_RELAY is not set
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/iseries_defconfig linux-2.6.35-rc4/arch/powerpc/configs/iseries_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/iseries_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/iseries_defconfig	2010-07-05 05:34:26.987868057 +0000
@@ -81,8 +81,7 @@
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_CGROUPS is not set
 # CONFIG_GROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/linkstation_defconfig linux-2.6.35-rc4/arch/powerpc/configs/linkstation_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/linkstation_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/linkstation_defconfig	2010-07-05 05:34:26.987868057 +0000
@@ -97,8 +97,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/maple_defconfig linux-2.6.35-rc4/arch/powerpc/configs/maple_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/maple_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/maple_defconfig	2010-07-05 05:34:26.987868057 +0000
@@ -78,8 +78,7 @@
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_CGROUPS is not set
 # CONFIG_GROUP_SCHED is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/mgcoge_defconfig linux-2.6.35-rc4/arch/powerpc/configs/mgcoge_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/mgcoge_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/mgcoge_defconfig	2010-07-05 05:34:26.988868060 +0000
@@ -96,8 +96,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/mgsuvd_defconfig linux-2.6.35-rc4/arch/powerpc/configs/mgsuvd_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/mgsuvd_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/mgsuvd_defconfig	2010-07-05 05:34:26.988868060 +0000
@@ -90,8 +90,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/mpc512x_defconfig linux-2.6.35-rc4/arch/powerpc/configs/mpc512x_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/mpc512x_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/mpc512x_defconfig	2010-07-05 05:34:26.988868060 +0000
@@ -97,8 +97,7 @@
 CONFIG_LOG_BUF_SHIFT=16
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/mpc5200_defconfig linux-2.6.35-rc4/arch/powerpc/configs/mpc5200_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/mpc5200_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/mpc5200_defconfig	2010-07-05 05:34:26.988868060 +0000
@@ -97,8 +97,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/mpc7448_hpc2_defconfig linux-2.6.35-rc4/arch/powerpc/configs/mpc7448_hpc2_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/mpc7448_hpc2_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/mpc7448_hpc2_defconfig	2010-07-05 05:34:26.988868060 +0000
@@ -95,8 +95,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/pasemi_defconfig linux-2.6.35-rc4/arch/powerpc/configs/pasemi_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/pasemi_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/pasemi_defconfig	2010-07-05 05:34:26.989868057 +0000
@@ -98,8 +98,7 @@
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/pmac32_defconfig linux-2.6.35-rc4/arch/powerpc/configs/pmac32_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/pmac32_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/pmac32_defconfig	2010-07-05 05:34:26.989868057 +0000
@@ -93,8 +93,7 @@
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/ppc40x_defconfig linux-2.6.35-rc4/arch/powerpc/configs/ppc40x_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/ppc40x_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/ppc40x_defconfig	2010-07-05 05:34:26.989868057 +0000
@@ -99,8 +99,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/ppc44x_defconfig linux-2.6.35-rc4/arch/powerpc/configs/ppc44x_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/ppc44x_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/ppc44x_defconfig	2010-07-05 05:34:26.989868057 +0000
@@ -103,8 +103,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/ppc64_defconfig linux-2.6.35-rc4/arch/powerpc/configs/ppc64_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/ppc64_defconfig	2010-07-05 05:34:21.574805506 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/ppc64_defconfig	2010-07-05 05:34:26.990868068 +0000
@@ -93,8 +93,7 @@
 # CONFIG_GROUP_SCHED is not set
 # CONFIG_CGROUP_CPUACCT is not set
 # CONFIG_RESOURCE_COUNTERS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_PROC_PID_CPUSET=y
 CONFIG_RELAY=y
 CONFIG_NAMESPACES=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/ppc64e_defconfig linux-2.6.35-rc4/arch/powerpc/configs/ppc64e_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/ppc64e_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/ppc64e_defconfig	2010-07-05 05:34:26.990868068 +0000
@@ -107,8 +107,7 @@
 CONFIG_PROC_PID_CPUSET=y
 # CONFIG_CGROUP_CPUACCT is not set
 # CONFIG_RESOURCE_COUNTERS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_RELAY=y
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/pq2fads_defconfig linux-2.6.35-rc4/arch/powerpc/configs/pq2fads_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/pq2fads_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/pq2fads_defconfig	2010-07-05 05:34:26.990868068 +0000
@@ -96,8 +96,7 @@
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/prpmc2800_defconfig linux-2.6.35-rc4/arch/powerpc/configs/prpmc2800_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/prpmc2800_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/prpmc2800_defconfig	2010-07-05 05:34:26.990868068 +0000
@@ -98,8 +98,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
 # CONFIG_UTS_NS is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/pseries_defconfig linux-2.6.35-rc4/arch/powerpc/configs/pseries_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/pseries_defconfig	2010-07-05 05:34:21.575805464 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/pseries_defconfig	2010-07-05 05:34:26.991868110 +0000
@@ -92,8 +92,7 @@
 # CONFIG_GROUP_SCHED is not set
 CONFIG_CGROUP_CPUACCT=y
 # CONFIG_RESOURCE_COUNTERS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_PROC_PID_CPUSET=y
 CONFIG_RELAY=y
 CONFIG_NAMESPACES=y
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/storcenter_defconfig linux-2.6.35-rc4/arch/powerpc/configs/storcenter_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/storcenter_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/storcenter_defconfig	2010-07-05 05:34:26.991868110 +0000
@@ -95,8 +95,7 @@
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
 # CONFIG_NAMESPACES is not set
 # CONFIG_BLK_DEV_INITRD is not set
diff -urN linux-2.6.35-rc3/arch/powerpc/configs/wii_defconfig linux-2.6.35-rc4/arch/powerpc/configs/wii_defconfig
--- linux-2.6.35-rc3/arch/powerpc/configs/wii_defconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/configs/wii_defconfig	2010-07-05 05:34:26.991868110 +0000
@@ -102,8 +102,7 @@
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
 # CONFIG_CGROUPS is not set
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 CONFIG_RELAY=y
 # CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
diff -urN linux-2.6.35-rc3/arch/powerpc/include/asm/irq.h linux-2.6.35-rc4/arch/powerpc/include/asm/irq.h
--- linux-2.6.35-rc3/arch/powerpc/include/asm/irq.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/include/asm/irq.h	2010-07-05 05:34:26.992868053 +0000
@@ -358,7 +358,6 @@
 #define exc_lvl_ctx_init()
 #endif
 
-#ifdef CONFIG_IRQSTACKS
 /*
  * Per-cpu stacks for handling hard and soft interrupts.
  */
@@ -369,11 +368,6 @@
 extern void call_do_softirq(struct thread_info *tp);
 extern int call_handle_irq(int irq, void *p1,
 			   struct thread_info *tp, void *func);
-#else
-#define irq_ctx_init()
-
-#endif /* CONFIG_IRQSTACKS */
-
 extern void do_IRQ(struct pt_regs *regs);
 
 #endif /* _ASM_IRQ_H */
diff -urN linux-2.6.35-rc3/arch/powerpc/include/asm/kdump.h linux-2.6.35-rc4/arch/powerpc/include/asm/kdump.h
--- linux-2.6.35-rc3/arch/powerpc/include/asm/kdump.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/include/asm/kdump.h	2010-07-05 05:34:26.992868053 +0000
@@ -3,8 +3,17 @@
 
 #include <asm/page.h>
 
-/* Kdump kernel runs at 32 MB, change at your peril. */
+/*
+ * If CONFIG_RELOCATABLE is enabled we can place the kdump kernel anywhere.
+ * To keep enough space in the RMO for the first stage kernel on 64bit, we
+ * place it at 64MB. If CONFIG_RELOCATABLE is not enabled we must place
+ * the second stage at 32MB.
+ */
+#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC64)
+#define KDUMP_KERNELBASE	0x4000000
+#else
 #define KDUMP_KERNELBASE	0x2000000
+#endif
 
 /* How many bytes to reserve at zero for kdump. The reserve limit should
  * be greater or equal to the trampoline's end address.
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/irq.c linux-2.6.35-rc4/arch/powerpc/kernel/irq.c
--- linux-2.6.35-rc3/arch/powerpc/kernel/irq.c	2010-07-05 05:34:21.583805629 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/irq.c	2010-07-05 05:34:27.000868093 +0000
@@ -317,7 +317,6 @@
 }
 #endif
 
-#ifdef CONFIG_IRQSTACKS
 static inline void handle_one_irq(unsigned int irq)
 {
 	struct thread_info *curtp, *irqtp;
@@ -358,12 +357,6 @@
 	if (irqtp->flags)
 		set_bits(irqtp->flags, &curtp->flags);
 }
-#else
-static inline void handle_one_irq(unsigned int irq)
-{
-	generic_handle_irq(irq);
-}
-#endif
 
 static inline void check_stack_overflow(void)
 {
@@ -455,7 +448,6 @@
 }
 #endif
 
-#ifdef CONFIG_IRQSTACKS
 struct thread_info *softirq_ctx[NR_CPUS] __read_mostly;
 struct thread_info *hardirq_ctx[NR_CPUS] __read_mostly;
 
@@ -492,10 +484,6 @@
 	irqtp->task = NULL;
 }
 
-#else
-#define do_softirq_onstack()	__do_softirq()
-#endif /* CONFIG_IRQSTACKS */
-
 void do_softirq(void)
 {
 	unsigned long flags;
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/machine_kexec_64.c linux-2.6.35-rc4/arch/powerpc/kernel/machine_kexec_64.c
--- linux-2.6.35-rc3/arch/powerpc/kernel/machine_kexec_64.c	2010-07-05 05:34:21.584805500 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/machine_kexec_64.c	2010-07-05 05:34:27.001868095 +0000
@@ -182,28 +182,12 @@
 
 	my_cpu = get_cpu();
 	/* Make sure each CPU has atleast made it to the state we need */
-	for (i=0; i < NR_CPUS; i++) {
+	for_each_online_cpu(i) {
 		if (i == my_cpu)
 			continue;
 
 		while (paca[i].kexec_state < wait_state) {
 			barrier();
-			if (!cpu_possible(i)) {
-				printk("kexec: cpu %d hw_cpu_id %d is not"
-						" possible, ignoring\n",
-						i, paca[i].hw_cpu_id);
-				break;
-			}
-			if (!cpu_online(i)) {
-				/* Fixme: this can be spinning in
-				 * pSeries_secondary_wait with a paca
-				 * waiting for it to go online.
-				 */
-				printk("kexec: cpu %d hw_cpu_id %d is not"
-						" online, ignoring\n",
-						i, paca[i].hw_cpu_id);
-				break;
-			}
 			if (i != notified) {
 				printk( "kexec: waiting for cpu %d (physical"
 						" %d) to enter %i state\n",
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/misc_32.S linux-2.6.35-rc4/arch/powerpc/kernel/misc_32.S
--- linux-2.6.35-rc3/arch/powerpc/kernel/misc_32.S	2010-07-05 05:34:21.584805500 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/misc_32.S	2010-07-05 05:34:27.001868095 +0000
@@ -33,7 +33,6 @@
 
 	.text
 
-#ifdef CONFIG_IRQSTACKS
 _GLOBAL(call_do_softirq)
 	mflr	r0
 	stw	r0,4(r1)
@@ -56,7 +55,6 @@
 	lwz	r0,4(r1)
 	mtlr	r0
 	blr
-#endif /* CONFIG_IRQSTACKS */
 
 /*
  * This returns the high 64 bits of the product of two 64-bit numbers.
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/misc_64.S linux-2.6.35-rc4/arch/powerpc/kernel/misc_64.S
--- linux-2.6.35-rc3/arch/powerpc/kernel/misc_64.S	2010-07-05 05:34:21.584805500 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/misc_64.S	2010-07-05 05:34:27.001868095 +0000
@@ -28,7 +28,6 @@
 
 	.text
 
-#ifdef CONFIG_IRQSTACKS
 _GLOBAL(call_do_softirq)
 	mflr	r0
 	std	r0,16(r1)
@@ -52,7 +51,6 @@
 	ld	r0,16(r1)
 	mtlr	r0
 	blr
-#endif /* CONFIG_IRQSTACKS */
 
 	.section	".toc","aw"
 PPC64_CACHES:
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/process.c linux-2.6.35-rc4/arch/powerpc/kernel/process.c
--- linux-2.6.35-rc3/arch/powerpc/kernel/process.c	2010-07-05 05:34:21.586805566 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/process.c	2010-07-05 05:34:27.003868059 +0000
@@ -1005,7 +1005,6 @@
 	return error;
 }
 
-#ifdef CONFIG_IRQSTACKS
 static inline int valid_irq_stack(unsigned long sp, struct task_struct *p,
 				  unsigned long nbytes)
 {
@@ -1030,10 +1029,6 @@
 	return 0;
 }
 
-#else
-#define valid_irq_stack(sp, p, nb)	0
-#endif /* CONFIG_IRQSTACKS */
-
 int validate_sp(unsigned long sp, struct task_struct *p,
 		       unsigned long nbytes)
 {
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/rtas_flash.c linux-2.6.35-rc4/arch/powerpc/kernel/rtas_flash.c
--- linux-2.6.35-rc3/arch/powerpc/kernel/rtas_flash.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/rtas_flash.c	2010-07-05 05:34:27.003868059 +0000
@@ -94,12 +94,8 @@
 	struct flash_block_list *next;
 	struct flash_block blocks[FLASH_BLOCKS_PER_NODE];
 };
-struct flash_block_list_header { /* just the header of flash_block_list */
-	unsigned long num_blocks;
-	struct flash_block_list *next;
-};
 
-static struct flash_block_list_header rtas_firmware_flash_list = {0, NULL};
+static struct flash_block_list *rtas_firmware_flash_list;
 
 /* Use slab cache to guarantee 4k alignment */
 static struct kmem_cache *flash_block_cache = NULL;
@@ -108,13 +104,14 @@
 
 /* Local copy of the flash block list.
  * We only allow one open of the flash proc file and create this
- * list as we go.  This list will be put in the
- * rtas_firmware_flash_list var once it is fully read.
+ * list as we go.  The rtas_firmware_flash_list varable will be
+ * set once the data is fully read.
  *
  * For convenience as we build the list we use virtual addrs,
  * we do not fill in the version number, and the length field
  * is treated as the number of entries currently in the block
- * (i.e. not a byte count).  This is all fixed on release.
+ * (i.e. not a byte count).  This is all fixed when calling 
+ * the flash routine.
  */
 
 /* Status int must be first member of struct */
@@ -201,16 +198,16 @@
 	if (uf->flist) {    
 		/* File was opened in write mode for a new flash attempt */
 		/* Clear saved list */
-		if (rtas_firmware_flash_list.next) {
-			free_flash_list(rtas_firmware_flash_list.next);
-			rtas_firmware_flash_list.next = NULL;
+		if (rtas_firmware_flash_list) {
+			free_flash_list(rtas_firmware_flash_list);
+			rtas_firmware_flash_list = NULL;
 		}
 
 		if (uf->status != FLASH_AUTH)  
 			uf->status = flash_list_valid(uf->flist);
 
 		if (uf->status == FLASH_IMG_READY) 
-			rtas_firmware_flash_list.next = uf->flist;
+			rtas_firmware_flash_list = uf->flist;
 		else
 			free_flash_list(uf->flist);
 
@@ -593,7 +590,7 @@
 	unsigned long rtas_block_list;
 	int i, status, update_token;
 
-	if (rtas_firmware_flash_list.next == NULL)
+	if (rtas_firmware_flash_list == NULL)
 		return;		/* nothing to do */
 
 	if (reboot_type != SYS_RESTART) {
@@ -610,20 +607,25 @@
 		return;
 	}
 
-	/* NOTE: the "first" block list is a global var with no data
-	 * blocks in the kernel data segment.  We do this because
-	 * we want to ensure this block_list addr is under 4GB.
+	/*
+	 * NOTE: the "first" block must be under 4GB, so we create
+	 * an entry with no data blocks in the reserved buffer in
+	 * the kernel data segment.
 	 */
-	rtas_firmware_flash_list.num_blocks = 0;
-	flist = (struct flash_block_list *)&rtas_firmware_flash_list;
+	spin_lock(&rtas_data_buf_lock);
+	flist = (struct flash_block_list *)&rtas_data_buf[0];
+	flist->num_blocks = 0;
+	flist->next = rtas_firmware_flash_list;
 	rtas_block_list = virt_to_abs(flist);
 	if (rtas_block_list >= 4UL*1024*1024*1024) {
 		printk(KERN_ALERT "FLASH: kernel bug...flash list header addr above 4GB\n");
+		spin_unlock(&rtas_data_buf_lock);
 		return;
 	}
 
 	printk(KERN_ALERT "FLASH: preparing saved firmware image for flash\n");
 	/* Update the block_list in place. */
+	rtas_firmware_flash_list = NULL; /* too hard to backout on error */
 	image_size = 0;
 	for (f = flist; f; f = next) {
 		/* Translate data addrs to absolute */
@@ -664,6 +666,7 @@
 		printk(KERN_ALERT "FLASH: unknown flash return code %d\n", status);
 		break;
 	}
+	spin_unlock(&rtas_data_buf_lock);
 }
 
 static void remove_flash_pde(struct proc_dir_entry *dp)
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/setup_32.c linux-2.6.35-rc4/arch/powerpc/kernel/setup_32.c
--- linux-2.6.35-rc3/arch/powerpc/kernel/setup_32.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/setup_32.c	2010-07-05 05:34:27.004868101 +0000
@@ -241,7 +241,6 @@
 
 arch_initcall(ppc_init);
 
-#ifdef CONFIG_IRQSTACKS
 static void __init irqstack_early_init(void)
 {
 	unsigned int i;
@@ -255,9 +254,6 @@
 			__va(lmb_alloc(THREAD_SIZE, THREAD_SIZE));
 	}
 }
-#else
-#define irqstack_early_init()
-#endif
 
 #if defined(CONFIG_BOOKE) || defined(CONFIG_40x)
 static void __init exc_lvl_early_init(void)
diff -urN linux-2.6.35-rc3/arch/powerpc/kernel/setup_64.c linux-2.6.35-rc4/arch/powerpc/kernel/setup_64.c
--- linux-2.6.35-rc3/arch/powerpc/kernel/setup_64.c	2010-07-05 05:34:21.587805454 +0000
+++ linux-2.6.35-rc4/arch/powerpc/kernel/setup_64.c	2010-07-05 05:34:27.004868101 +0000
@@ -432,7 +432,6 @@
 	return 1UL << SID_SHIFT;
 }
 
-#ifdef CONFIG_IRQSTACKS
 static void __init irqstack_early_init(void)
 {
 	u64 limit = slb0_limit();
@@ -451,9 +450,6 @@
 					    THREAD_SIZE, limit));
 	}
 }
-#else
-#define irqstack_early_init()
-#endif
 
 #ifdef CONFIG_PPC_BOOK3E
 static void __init exc_lvl_early_init(void)
diff -urN linux-2.6.35-rc3/arch/powerpc/mm/pgtable_32.c linux-2.6.35-rc4/arch/powerpc/mm/pgtable_32.c
--- linux-2.6.35-rc3/arch/powerpc/mm/pgtable_32.c	2010-07-05 05:34:21.596805461 +0000
+++ linux-2.6.35-rc4/arch/powerpc/mm/pgtable_32.c	2010-07-05 05:34:27.013868107 +0000
@@ -115,11 +115,7 @@
 {
 	struct page *ptepage;
 
-#ifdef CONFIG_HIGHPTE
-	gfp_t flags = GFP_KERNEL | __GFP_HIGHMEM | __GFP_REPEAT | __GFP_ZERO;
-#else
 	gfp_t flags = GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO;
-#endif
 
 	ptepage = alloc_pages(flags, 0);
 	if (!ptepage)
diff -urN linux-2.6.35-rc3/arch/powerpc/platforms/52xx/mpc52xx_pm.c linux-2.6.35-rc4/arch/powerpc/platforms/52xx/mpc52xx_pm.c
--- linux-2.6.35-rc3/arch/powerpc/platforms/52xx/mpc52xx_pm.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/powerpc/platforms/52xx/mpc52xx_pm.c	2010-07-05 05:34:27.014868107 +0000
@@ -64,10 +64,19 @@
 		{ .type = "builtin", .compatible = "mpc5200", }, /* efika */
 		{}
 	};
+	struct resource res;
 
 	/* map the whole register space */
 	np = of_find_matching_node(NULL, immr_ids);
-	mbar = of_iomap(np, 0);
+
+	if (of_address_to_resource(np, 0, &res)) {
+		pr_err("mpc52xx_pm_prepare(): could not get IMMR address\n");
+		of_node_put(np);
+		return -ENOSYS;
+	}
+
+	mbar = ioremap(res.start, 0xc000); /* we should map whole region including SRAM */
+
 	of_node_put(np);
 	if (!mbar) {
 		pr_err("mpc52xx_pm_prepare(): could not map registers\n");
diff -urN linux-2.6.35-rc3/arch/powerpc/sysdev/mpic.c linux-2.6.35-rc4/arch/powerpc/sysdev/mpic.c
--- linux-2.6.35-rc3/arch/powerpc/sysdev/mpic.c	2010-07-05 05:34:21.605805840 +0000
+++ linux-2.6.35-rc4/arch/powerpc/sysdev/mpic.c	2010-07-05 05:34:27.023868261 +0000
@@ -1666,7 +1666,7 @@
 			       mpic->save_data[i].dest);
 
 #ifdef CONFIG_MPIC_U3_HT_IRQS
-	{
+	if (mpic->fixups) {
 		struct mpic_irq_fixup *fixup = &mpic->fixups[i];
 
 		if (fixup->base) {
diff -urN linux-2.6.35-rc3/arch/sh/boards/mach-ecovec24/setup.c linux-2.6.35-rc4/arch/sh/boards/mach-ecovec24/setup.c
--- linux-2.6.35-rc3/arch/sh/boards/mach-ecovec24/setup.c	2010-07-05 05:34:21.616805504 +0000
+++ linux-2.6.35-rc4/arch/sh/boards/mach-ecovec24/setup.c	2010-07-05 05:34:27.034868072 +0000
@@ -25,7 +25,6 @@
 #include <linux/spi/spi.h>
 #include <linux/spi/sh_msiof.h>
 #include <linux/spi/mmc_spi.h>
-#include <linux/mmc/host.h>
 #include <linux/input.h>
 #include <linux/input/sh_keysc.h>
 #include <video/sh_mobile_lcdc.h>
diff -urN linux-2.6.35-rc3/arch/sh/drivers/pci/pci.c linux-2.6.35-rc4/arch/sh/drivers/pci/pci.c
--- linux-2.6.35-rc3/arch/sh/drivers/pci/pci.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/sh/drivers/pci/pci.c	2010-07-05 05:34:27.053805344 +0000
@@ -139,8 +139,6 @@
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		if (!dev->resource[i].start)
 			continue;
-		if (dev->resource[i].flags & IORESOURCE_PCI_FIXED)
-			continue;
 		if (dev->resource[i].flags & IORESOURCE_IO)
 			offset = hose->io_offset;
 		else if (dev->resource[i].flags & IORESOURCE_MEM)
diff -urN linux-2.6.35-rc3/arch/sh/mm/pmb.c linux-2.6.35-rc4/arch/sh/mm/pmb.c
--- linux-2.6.35-rc3/arch/sh/mm/pmb.c	2010-07-05 05:34:21.651806197 +0000
+++ linux-2.6.35-rc4/arch/sh/mm/pmb.c	2010-07-05 05:34:27.069868072 +0000
@@ -770,7 +770,7 @@
 		spin_unlock_irqrestore(&pmbe->lock, flags);
 	}
 
-	read_lock(&pmb_rwlock);
+	read_unlock(&pmb_rwlock);
 }
 #endif
 
diff -urN linux-2.6.35-rc3/arch/um/include/asm/arch_hweight.h linux-2.6.35-rc4/arch/um/include/asm/arch_hweight.h
--- linux-2.6.35-rc3/arch/um/include/asm/arch_hweight.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.35-rc4/arch/um/include/asm/arch_hweight.h	2010-07-05 05:34:27.076868067 +0000
@@ -0,0 +1,6 @@
+#ifndef _ASM_UM_HWEIGHT_H
+#define _ASM_UM_HWEIGHT_H
+
+#include <asm-generic/bitops/arch_hweight.h>
+
+#endif
diff -urN linux-2.6.35-rc3/arch/um/os-Linux/mem.c linux-2.6.35-rc4/arch/um/os-Linux/mem.c
--- linux-2.6.35-rc3/arch/um/os-Linux/mem.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/um/os-Linux/mem.c	2010-07-05 05:34:27.077868067 +0000
@@ -10,6 +10,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <string.h>
+#include <sys/stat.h>
 #include <sys/mman.h>
 #include <sys/param.h>
 #include "init.h"
diff -urN linux-2.6.35-rc3/arch/x86/boot/video-vga.c linux-2.6.35-rc4/arch/x86/boot/video-vga.c
--- linux-2.6.35-rc3/arch/x86/boot/video-vga.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/x86/boot/video-vga.c	2010-07-05 05:34:27.078868091 +0000
@@ -41,13 +41,12 @@
 static u8 vga_set_basic_mode(void)
 {
 	struct biosregs ireg, oreg;
-	u16 ax;
 	u8 mode;
 
 	initregs(&ireg);
 
 	/* Query current mode */
-	ax = 0x0f00;
+	ireg.ax = 0x0f00;
 	intcall(0x10, &ireg, &oreg);
 	mode = oreg.al;
 
diff -urN linux-2.6.35-rc3/arch/x86/include/asm/io_apic.h linux-2.6.35-rc4/arch/x86/include/asm/io_apic.h
--- linux-2.6.35-rc3/arch/x86/include/asm/io_apic.h	2010-07-05 05:34:21.664805929 +0000
+++ linux-2.6.35-rc4/arch/x86/include/asm/io_apic.h	2010-07-05 05:34:27.083868098 +0000
@@ -183,7 +183,7 @@
 	u32 gsi_end;
 };
 extern struct mp_ioapic_gsi  mp_gsi_routing[];
-extern u32 gsi_end;
+extern u32 gsi_top;
 int mp_find_ioapic(u32 gsi);
 int mp_find_ioapic_pin(int ioapic, u32 gsi);
 void __init mp_register_ioapic(int id, u32 address, u32 gsi_base);
@@ -197,7 +197,7 @@
 static inline void ioapic_init_mappings(void)	{ }
 static inline void ioapic_insert_resources(void) { }
 static inline void probe_nr_irqs_gsi(void)	{ }
-#define gsi_end (NR_IRQS_LEGACY - 1)
+#define gsi_top (NR_IRQS_LEGACY)
 static inline int mp_find_ioapic(u32 gsi) { return 0; }
 
 struct io_apic_irq_attr;
diff -urN linux-2.6.35-rc3/arch/x86/include/asm/percpu.h linux-2.6.35-rc4/arch/x86/include/asm/percpu.h
--- linux-2.6.35-rc3/arch/x86/include/asm/percpu.h	2010-07-05 05:34:21.666805506 +0000
+++ linux-2.6.35-rc4/arch/x86/include/asm/percpu.h	2010-07-05 05:34:27.085868110 +0000
@@ -77,6 +77,7 @@
 	if (0) {					\
 		pto_T__ pto_tmp__;			\
 		pto_tmp__ = (val);			\
+		(void)pto_tmp__;			\
 	}						\
 	switch (sizeof(var)) {				\
 	case 1:						\
@@ -115,6 +116,7 @@
 	if (0) {							\
 		pao_T__ pao_tmp__;					\
 		pao_tmp__ = (val);					\
+		(void)pao_tmp__;					\
 	}								\
 	switch (sizeof(var)) {						\
 	case 1:								\
diff -urN linux-2.6.35-rc3/arch/x86/include/asm/pgtable_32_types.h linux-2.6.35-rc4/arch/x86/include/asm/pgtable_32_types.h
--- linux-2.6.35-rc3/arch/x86/include/asm/pgtable_32_types.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/x86/include/asm/pgtable_32_types.h	2010-07-05 05:34:27.085868110 +0000
@@ -26,7 +26,7 @@
  */
 #define VMALLOC_OFFSET	(8 * 1024 * 1024)
 
-#ifndef __ASSEMBLER__
+#ifndef __ASSEMBLY__
 extern bool __vmalloc_start_set; /* set once high_memory is set */
 #endif
 
diff -urN linux-2.6.35-rc3/arch/x86/include/asm/system.h linux-2.6.35-rc4/arch/x86/include/asm/system.h
--- linux-2.6.35-rc3/arch/x86/include/asm/system.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/x86/include/asm/system.h	2010-07-05 05:34:27.087868070 +0000
@@ -451,7 +451,7 @@
  *
  * (Could use an alternative three way for this if there was one.)
  */
-static inline void rdtsc_barrier(void)
+static __always_inline void rdtsc_barrier(void)
 {
 	alternative(ASM_NOP3, "mfence", X86_FEATURE_MFENCE_RDTSC);
 	alternative(ASM_NOP3, "lfence", X86_FEATURE_LFENCE_RDTSC);
diff -urN linux-2.6.35-rc3/arch/x86/kernel/acpi/boot.c linux-2.6.35-rc4/arch/x86/kernel/acpi/boot.c
--- linux-2.6.35-rc3/arch/x86/kernel/acpi/boot.c	2010-07-05 05:34:21.670805877 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/acpi/boot.c	2010-07-05 05:34:27.089805554 +0000
@@ -118,7 +118,7 @@
 	if (gsi >= NR_IRQS_LEGACY)
 		irq = gsi;
 	else
-		irq = gsi_end + 1 + gsi;
+		irq = gsi_top + gsi;
 
 	return irq;
 }
@@ -129,10 +129,10 @@
 
 	if (irq < NR_IRQS_LEGACY)
 		gsi = isa_irq_to_gsi[irq];
-	else if (irq <= gsi_end)
+	else if (irq < gsi_top)
 		gsi = irq;
-	else if (irq <= (gsi_end + NR_IRQS_LEGACY))
-		gsi = irq - gsi_end;
+	else if (irq < (gsi_top + NR_IRQS_LEGACY))
+		gsi = irq - gsi_top;
 	else
 		gsi = 0xffffffff;
 
diff -urN linux-2.6.35-rc3/arch/x86/kernel/apic/io_apic.c linux-2.6.35-rc4/arch/x86/kernel/apic/io_apic.c
--- linux-2.6.35-rc3/arch/x86/kernel/apic/io_apic.c	2010-07-05 05:34:21.673805517 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/apic/io_apic.c	2010-07-05 05:34:27.091805688 +0000
@@ -89,8 +89,8 @@
 /* IO APIC gsi routing info */
 struct mp_ioapic_gsi  mp_gsi_routing[MAX_IO_APICS];
 
-/* The last gsi number used */
-u32 gsi_end;
+/* The one past the highest gsi number used */
+u32 gsi_top;
 
 /* MP IRQ source entries */
 struct mpc_intsrc mp_irqs[MAX_IRQ_SOURCES];
@@ -1035,7 +1035,7 @@
 		if (gsi >= NR_IRQS_LEGACY)
 			irq = gsi;
 		else
-			irq = gsi_end + 1 + gsi;
+			irq = gsi_top + gsi;
 	}
 
 #ifdef CONFIG_X86_32
@@ -3853,7 +3853,7 @@
 {
 	int nr;
 
-	nr = gsi_end + 1 + NR_IRQS_LEGACY;
+	nr = gsi_top + NR_IRQS_LEGACY;
 	if (nr > nr_irqs_gsi)
 		nr_irqs_gsi = nr;
 
@@ -4294,8 +4294,8 @@
 	 */
 	nr_ioapic_registers[idx] = entries;
 
-	if (mp_gsi_routing[idx].gsi_end > gsi_end)
-		gsi_end = mp_gsi_routing[idx].gsi_end;
+	if (mp_gsi_routing[idx].gsi_end >= gsi_top)
+		gsi_top = mp_gsi_routing[idx].gsi_end + 1;
 
 	printk(KERN_INFO "IOAPIC[%d]: apic_id %d, version %d, address 0x%x, "
 	       "GSI %d-%d\n", idx, mp_ioapics[idx].apicid,
diff -urN linux-2.6.35-rc3/arch/x86/kernel/cpu/perf_event_amd.c linux-2.6.35-rc4/arch/x86/kernel/cpu/perf_event_amd.c
--- linux-2.6.35-rc3/arch/x86/kernel/cpu/perf_event_amd.c	2010-07-05 05:34:21.677805546 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/cpu/perf_event_amd.c	2010-07-05 05:34:27.096868086 +0000
@@ -102,8 +102,8 @@
   [PERF_COUNT_HW_INSTRUCTIONS]		= 0x00c0,
   [PERF_COUNT_HW_CACHE_REFERENCES]	= 0x0080,
   [PERF_COUNT_HW_CACHE_MISSES]		= 0x0081,
-  [PERF_COUNT_HW_BRANCH_INSTRUCTIONS]	= 0x00c4,
-  [PERF_COUNT_HW_BRANCH_MISSES]		= 0x00c5,
+  [PERF_COUNT_HW_BRANCH_INSTRUCTIONS]	= 0x00c2,
+  [PERF_COUNT_HW_BRANCH_MISSES]		= 0x00c3,
 };
 
 static u64 amd_pmu_event_map(int hw_event)
diff -urN linux-2.6.35-rc3/arch/x86/kernel/cpu/perf_event_intel.c linux-2.6.35-rc4/arch/x86/kernel/cpu/perf_event_intel.c
--- linux-2.6.35-rc3/arch/x86/kernel/cpu/perf_event_intel.c	2010-07-05 05:34:21.677805546 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/cpu/perf_event_intel.c	2010-07-05 05:34:27.096868086 +0000
@@ -72,6 +72,7 @@
 	INTEL_EVENT_CONSTRAINT(0x51, 0x3), /* L1D */
 	INTEL_EVENT_CONSTRAINT(0x60, 0x1), /* OFFCORE_REQUESTS_OUTSTANDING */
 	INTEL_EVENT_CONSTRAINT(0x63, 0x3), /* CACHE_LOCK_CYCLES */
+	INTEL_EVENT_CONSTRAINT(0xb3, 0x1), /* SNOOPQ_REQUEST_OUTSTANDING */
 	EVENT_CONSTRAINT_END
 };
 
diff -urN linux-2.6.35-rc3/arch/x86/kernel/e820.c linux-2.6.35-rc4/arch/x86/kernel/e820.c
--- linux-2.6.35-rc3/arch/x86/kernel/e820.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/e820.c	2010-07-05 05:34:27.099868058 +0000
@@ -729,7 +729,7 @@
 		struct e820entry *ei = &e820.map[i];
 
 		if (ei->type == E820_NVS)
-			hibernate_nvs_register(ei->addr, ei->size);
+			suspend_nvs_register(ei->addr, ei->size);
 	}
 
 	return 0;
diff -urN linux-2.6.35-rc3/arch/x86/kernel/mpparse.c linux-2.6.35-rc4/arch/x86/kernel/mpparse.c
--- linux-2.6.35-rc3/arch/x86/kernel/mpparse.c	2010-07-05 05:34:21.683805480 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/mpparse.c	2010-07-05 05:34:27.102868069 +0000
@@ -123,7 +123,7 @@
 	printk(KERN_INFO "I/O APIC #%d Version %d at 0x%X.\n",
 	       m->apicid, m->apicver, m->apicaddr);
 
-	mp_register_ioapic(m->apicid, m->apicaddr, gsi_end + 1);
+	mp_register_ioapic(m->apicid, m->apicaddr, gsi_top);
 }
 
 static void print_MP_intsrc_info(struct mpc_intsrc *m)
diff -urN linux-2.6.35-rc3/arch/x86/kernel/pci-calgary_64.c linux-2.6.35-rc4/arch/x86/kernel/pci-calgary_64.c
--- linux-2.6.35-rc3/arch/x86/kernel/pci-calgary_64.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/pci-calgary_64.c	2010-07-05 05:34:27.102868069 +0000
@@ -103,11 +103,16 @@
 #define PMR_SOFTSTOPFAULT	0x40000000
 #define PMR_HARDSTOP		0x20000000
 
-#define MAX_NUM_OF_PHBS		8 /* how many PHBs in total? */
-#define MAX_NUM_CHASSIS		8 /* max number of chassis */
-/* MAX_PHB_BUS_NUM is the maximal possible dev->bus->number */
-#define MAX_PHB_BUS_NUM		(MAX_NUM_OF_PHBS * MAX_NUM_CHASSIS * 2)
-#define PHBS_PER_CALGARY	4
+/*
+ * The maximum PHB bus number.
+ * x3950M2 (rare): 8 chassis, 48 PHBs per chassis = 384
+ * x3950M2: 4 chassis, 48 PHBs per chassis        = 192
+ * x3950 (PCIE): 8 chassis, 32 PHBs per chassis   = 256
+ * x3950 (PCIX): 8 chassis, 16 PHBs per chassis   = 128
+ */
+#define MAX_PHB_BUS_NUM		384
+
+#define PHBS_PER_CALGARY	  4
 
 /* register offsets in Calgary's internal register space */
 static const unsigned long tar_offsets[] = {
diff -urN linux-2.6.35-rc3/arch/x86/kernel/reboot.c linux-2.6.35-rc4/arch/x86/kernel/reboot.c
--- linux-2.6.35-rc3/arch/x86/kernel/reboot.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/reboot.c	2010-07-05 05:34:27.104868078 +0000
@@ -228,6 +228,14 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "Precision WorkStation T5400"),
 		},
 	},
+	{	/* Handle problems with rebooting on Dell T7400's */
+		.callback = set_bios_reboot,
+		.ident = "Dell Precision T7400",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Precision WorkStation T7400"),
+		},
+	},
 	{	/* Handle problems with rebooting on HP laptops */
 		.callback = set_bios_reboot,
 		.ident = "HP Compaq Laptop",
diff -urN linux-2.6.35-rc3/arch/x86/kernel/sfi.c linux-2.6.35-rc4/arch/x86/kernel/sfi.c
--- linux-2.6.35-rc3/arch/x86/kernel/sfi.c	2010-07-05 05:34:21.685805553 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/sfi.c	2010-07-05 05:34:27.104868078 +0000
@@ -93,7 +93,7 @@
 	pentry = (struct sfi_apic_table_entry *)sb->pentry;
 
 	for (i = 0; i < num; i++) {
-		mp_register_ioapic(i, pentry->phys_addr, gsi_end + 1);
+		mp_register_ioapic(i, pentry->phys_addr, gsi_top);
 		pentry++;
 	}
 
diff -urN linux-2.6.35-rc3/arch/x86/kernel/traps.c linux-2.6.35-rc4/arch/x86/kernel/traps.c
--- linux-2.6.35-rc3/arch/x86/kernel/traps.c	2010-07-05 05:34:21.687805644 +0000
+++ linux-2.6.35-rc4/arch/x86/kernel/traps.c	2010-07-05 05:34:27.106868122 +0000
@@ -526,6 +526,7 @@
 dotraplinkage void __kprobes do_debug(struct pt_regs *regs, long error_code)
 {
 	struct task_struct *tsk = current;
+	int user_icebp = 0;
 	unsigned long dr6;
 	int si_code;
 
@@ -534,6 +535,14 @@
 	/* Filter out all the reserved bits which are preset to 1 */
 	dr6 &= ~DR6_RESERVED;
 
+	/*
+	 * If dr6 has no reason to give us about the origin of this trap,
+	 * then it's very likely the result of an icebp/int01 trap.
+	 * User wants a sigtrap for that.
+	 */
+	if (!dr6 && user_mode(regs))
+		user_icebp = 1;
+
 	/* Catch kmemcheck conditions first of all! */
 	if ((dr6 & DR_STEP) && kmemcheck_trap(regs))
 		return;
@@ -575,7 +584,7 @@
 		regs->flags &= ~X86_EFLAGS_TF;
 	}
 	si_code = get_si_code(tsk->thread.debugreg6);
-	if (tsk->thread.debugreg6 & (DR_STEP | DR_TRAP_BITS))
+	if (tsk->thread.debugreg6 & (DR_STEP | DR_TRAP_BITS) || user_icebp)
 		send_sigtrap(tsk, regs, error_code, si_code);
 	preempt_conditional_cli(regs);
 
diff -urN linux-2.6.35-rc3/arch/x86/mm/pat.c linux-2.6.35-rc4/arch/x86/mm/pat.c
--- linux-2.6.35-rc3/arch/x86/mm/pat.c	2010-07-05 05:34:21.696805686 +0000
+++ linux-2.6.35-rc4/arch/x86/mm/pat.c	2010-07-05 05:34:27.116805334 +0000
@@ -302,7 +302,7 @@
 		return -EINVAL;
 	}
 
-	new  = kmalloc(sizeof(struct memtype), GFP_KERNEL);
+	new  = kzalloc(sizeof(struct memtype), GFP_KERNEL);
 	if (!new)
 		return -ENOMEM;
 
diff -urN linux-2.6.35-rc3/arch/x86/mm/pat_rbtree.c linux-2.6.35-rc4/arch/x86/mm/pat_rbtree.c
--- linux-2.6.35-rc3/arch/x86/mm/pat_rbtree.c	2010-07-05 05:34:21.696805686 +0000
+++ linux-2.6.35-rc4/arch/x86/mm/pat_rbtree.c	2010-07-05 05:34:27.116805334 +0000
@@ -226,6 +226,7 @@
 		if (ret_type)
 			new->type = *ret_type;
 
+		new->subtree_max_end = new->end;
 		memtype_rb_insert(&memtype_rbroot, new);
 	}
 	return err;
diff -urN linux-2.6.35-rc3/block/blk-core.c linux-2.6.35-rc4/block/blk-core.c
--- linux-2.6.35-rc3/block/blk-core.c	2010-07-05 05:34:21.702805744 +0000
+++ linux-2.6.35-rc4/block/blk-core.c	2010-07-05 05:34:27.122868049 +0000
@@ -1149,13 +1149,10 @@
 	else
 		req->cmd_flags |= bio->bi_rw & REQ_FAILFAST_MASK;
 
-	if (unlikely(bio_rw_flagged(bio, BIO_RW_DISCARD))) {
+	if (bio_rw_flagged(bio, BIO_RW_DISCARD))
 		req->cmd_flags |= REQ_DISCARD;
-		if (bio_rw_flagged(bio, BIO_RW_BARRIER))
-			req->cmd_flags |= REQ_SOFTBARRIER;
-	} else if (unlikely(bio_rw_flagged(bio, BIO_RW_BARRIER)))
+	if (bio_rw_flagged(bio, BIO_RW_BARRIER))
 		req->cmd_flags |= REQ_HARDBARRIER;
-
 	if (bio_rw_flagged(bio, BIO_RW_SYNCIO))
 		req->cmd_flags |= REQ_RW_SYNC;
 	if (bio_rw_flagged(bio, BIO_RW_META))
@@ -1586,7 +1583,7 @@
 	 * If it's a regular read/write or a barrier with data attached,
 	 * go through the normal accounting stuff before submission.
 	 */
-	if (bio_has_data(bio)) {
+	if (bio_has_data(bio) && !(rw & (1 << BIO_RW_DISCARD))) {
 		if (rw & WRITE) {
 			count_vm_events(PGPGOUT, count);
 		} else {
diff -urN linux-2.6.35-rc3/block/cfq-iosched.c linux-2.6.35-rc4/block/cfq-iosched.c
--- linux-2.6.35-rc3/block/cfq-iosched.c	2010-07-05 05:34:21.703805554 +0000
+++ linux-2.6.35-rc4/block/cfq-iosched.c	2010-07-05 05:34:27.123868070 +0000
@@ -14,7 +14,7 @@
 #include <linux/rbtree.h>
 #include <linux/ioprio.h>
 #include <linux/blktrace_api.h>
-#include "blk-cgroup.h"
+#include "cfq.h"
 
 /*
  * tunables
@@ -879,7 +879,7 @@
 	if (!RB_EMPTY_NODE(&cfqg->rb_node))
 		cfq_rb_erase(&cfqg->rb_node, st);
 	cfqg->saved_workload_slice = 0;
-	blkiocg_update_dequeue_stats(&cfqg->blkg, 1);
+	cfq_blkiocg_update_dequeue_stats(&cfqg->blkg, 1);
 }
 
 static inline unsigned int cfq_cfqq_slice_usage(struct cfq_queue *cfqq)
@@ -939,8 +939,8 @@
 
 	cfq_log_cfqg(cfqd, cfqg, "served: vt=%llu min_vt=%llu", cfqg->vdisktime,
 					st->min_vdisktime);
-	blkiocg_update_timeslice_used(&cfqg->blkg, used_sl);
-	blkiocg_set_start_empty_time(&cfqg->blkg);
+	cfq_blkiocg_update_timeslice_used(&cfqg->blkg, used_sl);
+	cfq_blkiocg_set_start_empty_time(&cfqg->blkg);
 }
 
 #ifdef CONFIG_CFQ_GROUP_IOSCHED
@@ -995,7 +995,7 @@
 
 	/* Add group onto cgroup list */
 	sscanf(dev_name(bdi->dev), "%u:%u", &major, &minor);
-	blkiocg_add_blkio_group(blkcg, &cfqg->blkg, (void *)cfqd,
+	cfq_blkiocg_add_blkio_group(blkcg, &cfqg->blkg, (void *)cfqd,
 					MKDEV(major, minor));
 	cfqg->weight = blkcg_get_weight(blkcg, cfqg->blkg.dev);
 
@@ -1079,7 +1079,7 @@
 		 * it from cgroup list, then it will take care of destroying
 		 * cfqg also.
 		 */
-		if (!blkiocg_del_blkio_group(&cfqg->blkg))
+		if (!cfq_blkiocg_del_blkio_group(&cfqg->blkg))
 			cfq_destroy_cfqg(cfqd, cfqg);
 	}
 }
@@ -1421,10 +1421,10 @@
 {
 	elv_rb_del(&cfqq->sort_list, rq);
 	cfqq->queued[rq_is_sync(rq)]--;
-	blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg, rq_data_dir(rq),
-						rq_is_sync(rq));
+	cfq_blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg,
+					rq_data_dir(rq), rq_is_sync(rq));
 	cfq_add_rq_rb(rq);
-	blkiocg_update_io_add_stats(&(RQ_CFQG(rq))->blkg,
+	cfq_blkiocg_update_io_add_stats(&(RQ_CFQG(rq))->blkg,
 			&cfqq->cfqd->serving_group->blkg, rq_data_dir(rq),
 			rq_is_sync(rq));
 }
@@ -1482,8 +1482,8 @@
 	cfq_del_rq_rb(rq);
 
 	cfqq->cfqd->rq_queued--;
-	blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg, rq_data_dir(rq),
-						rq_is_sync(rq));
+	cfq_blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg,
+					rq_data_dir(rq), rq_is_sync(rq));
 	if (rq_is_meta(rq)) {
 		WARN_ON(!cfqq->meta_pending);
 		cfqq->meta_pending--;
@@ -1518,8 +1518,8 @@
 static void cfq_bio_merged(struct request_queue *q, struct request *req,
 				struct bio *bio)
 {
-	blkiocg_update_io_merged_stats(&(RQ_CFQG(req))->blkg, bio_data_dir(bio),
-					cfq_bio_sync(bio));
+	cfq_blkiocg_update_io_merged_stats(&(RQ_CFQG(req))->blkg,
+					bio_data_dir(bio), cfq_bio_sync(bio));
 }
 
 static void
@@ -1539,8 +1539,8 @@
 	if (cfqq->next_rq == next)
 		cfqq->next_rq = rq;
 	cfq_remove_request(next);
-	blkiocg_update_io_merged_stats(&(RQ_CFQG(rq))->blkg, rq_data_dir(next),
-					rq_is_sync(next));
+	cfq_blkiocg_update_io_merged_stats(&(RQ_CFQG(rq))->blkg,
+					rq_data_dir(next), rq_is_sync(next));
 }
 
 static int cfq_allow_merge(struct request_queue *q, struct request *rq,
@@ -1571,7 +1571,7 @@
 static inline void cfq_del_timer(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 {
 	del_timer(&cfqd->idle_slice_timer);
-	blkiocg_update_idle_time_stats(&cfqq->cfqg->blkg);
+	cfq_blkiocg_update_idle_time_stats(&cfqq->cfqg->blkg);
 }
 
 static void __cfq_set_active_queue(struct cfq_data *cfqd,
@@ -1580,7 +1580,7 @@
 	if (cfqq) {
 		cfq_log_cfqq(cfqd, cfqq, "set_active wl_prio:%d wl_type:%d",
 				cfqd->serving_prio, cfqd->serving_type);
-		blkiocg_update_avg_queue_size_stats(&cfqq->cfqg->blkg);
+		cfq_blkiocg_update_avg_queue_size_stats(&cfqq->cfqg->blkg);
 		cfqq->slice_start = 0;
 		cfqq->dispatch_start = jiffies;
 		cfqq->allocated_slice = 0;
@@ -1911,7 +1911,7 @@
 	sl = cfqd->cfq_slice_idle;
 
 	mod_timer(&cfqd->idle_slice_timer, jiffies + sl);
-	blkiocg_update_set_idle_time_stats(&cfqq->cfqg->blkg);
+	cfq_blkiocg_update_set_idle_time_stats(&cfqq->cfqg->blkg);
 	cfq_log_cfqq(cfqd, cfqq, "arm_idle: %lu", sl);
 }
 
@@ -1931,7 +1931,7 @@
 	elv_dispatch_sort(q, rq);
 
 	cfqd->rq_in_flight[cfq_cfqq_sync(cfqq)]++;
-	blkiocg_update_dispatch_stats(&cfqq->cfqg->blkg, blk_rq_bytes(rq),
+	cfq_blkiocg_update_dispatch_stats(&cfqq->cfqg->blkg, blk_rq_bytes(rq),
 					rq_data_dir(rq), rq_is_sync(rq));
 }
 
@@ -1986,6 +1986,15 @@
 	int process_refs, new_process_refs;
 	struct cfq_queue *__cfqq;
 
+	/*
+	 * If there are no process references on the new_cfqq, then it is
+	 * unsafe to follow the ->new_cfqq chain as other cfqq's in the
+	 * chain may have dropped their last reference (not just their
+	 * last process reference).
+	 */
+	if (!cfqq_process_refs(new_cfqq))
+		return;
+
 	/* Avoid a circular list and skip interim queue merges */
 	while ((__cfqq = new_cfqq->new_cfqq)) {
 		if (__cfqq == cfqq)
@@ -1994,17 +2003,17 @@
 	}
 
 	process_refs = cfqq_process_refs(cfqq);
+	new_process_refs = cfqq_process_refs(new_cfqq);
 	/*
 	 * If the process for the cfqq has gone away, there is no
 	 * sense in merging the queues.
 	 */
-	if (process_refs == 0)
+	if (process_refs == 0 || new_process_refs == 0)
 		return;
 
 	/*
 	 * Merge in the direction of the lesser amount of work.
 	 */
-	new_process_refs = cfqq_process_refs(new_cfqq);
 	if (new_process_refs >= process_refs) {
 		cfqq->new_cfqq = new_cfqq;
 		atomic_add(process_refs, &new_cfqq->ref);
@@ -3248,7 +3257,7 @@
 				cfq_clear_cfqq_wait_request(cfqq);
 				__blk_run_queue(cfqd->queue);
 			} else {
-				blkiocg_update_idle_time_stats(
+				cfq_blkiocg_update_idle_time_stats(
 						&cfqq->cfqg->blkg);
 				cfq_mark_cfqq_must_dispatch(cfqq);
 			}
@@ -3276,7 +3285,7 @@
 	rq_set_fifo_time(rq, jiffies + cfqd->cfq_fifo_expire[rq_is_sync(rq)]);
 	list_add_tail(&rq->queuelist, &cfqq->fifo);
 	cfq_add_rq_rb(rq);
-	blkiocg_update_io_add_stats(&(RQ_CFQG(rq))->blkg,
+	cfq_blkiocg_update_io_add_stats(&(RQ_CFQG(rq))->blkg,
 			&cfqd->serving_group->blkg, rq_data_dir(rq),
 			rq_is_sync(rq));
 	cfq_rq_enqueued(cfqd, cfqq, rq);
@@ -3364,9 +3373,9 @@
 	WARN_ON(!cfqq->dispatched);
 	cfqd->rq_in_driver--;
 	cfqq->dispatched--;
-	blkiocg_update_completion_stats(&cfqq->cfqg->blkg, rq_start_time_ns(rq),
-			rq_io_start_time_ns(rq), rq_data_dir(rq),
-			rq_is_sync(rq));
+	cfq_blkiocg_update_completion_stats(&cfqq->cfqg->blkg,
+			rq_start_time_ns(rq), rq_io_start_time_ns(rq),
+			rq_data_dir(rq), rq_is_sync(rq));
 
 	cfqd->rq_in_flight[cfq_cfqq_sync(cfqq)]--;
 
@@ -3730,7 +3739,7 @@
 
 	cfq_put_async_queues(cfqd);
 	cfq_release_cfq_groups(cfqd);
-	blkiocg_del_blkio_group(&cfqd->root_group.blkg);
+	cfq_blkiocg_del_blkio_group(&cfqd->root_group.blkg);
 
 	spin_unlock_irq(q->queue_lock);
 
@@ -3798,8 +3807,8 @@
 	 */
 	atomic_set(&cfqg->ref, 1);
 	rcu_read_lock();
-	blkiocg_add_blkio_group(&blkio_root_cgroup, &cfqg->blkg, (void *)cfqd,
-					0);
+	cfq_blkiocg_add_blkio_group(&blkio_root_cgroup, &cfqg->blkg,
+					(void *)cfqd, 0);
 	rcu_read_unlock();
 #endif
 	/*
diff -urN linux-2.6.35-rc3/block/cfq.h linux-2.6.35-rc4/block/cfq.h
--- linux-2.6.35-rc3/block/cfq.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.35-rc4/block/cfq.h	2010-07-05 05:34:27.123868070 +0000
@@ -0,0 +1,115 @@
+#ifndef _CFQ_H
+#define _CFQ_H
+#include "blk-cgroup.h"
+
+#ifdef CONFIG_CFQ_GROUP_IOSCHED
+static inline void cfq_blkiocg_update_io_add_stats(struct blkio_group *blkg,
+	struct blkio_group *curr_blkg, bool direction, bool sync)
+{
+	blkiocg_update_io_add_stats(blkg, curr_blkg, direction, sync);
+}
+
+static inline void cfq_blkiocg_update_dequeue_stats(struct blkio_group *blkg,
+			unsigned long dequeue)
+{
+	blkiocg_update_dequeue_stats(blkg, dequeue);
+}
+
+static inline void cfq_blkiocg_update_timeslice_used(struct blkio_group *blkg,
+			unsigned long time)
+{
+	blkiocg_update_timeslice_used(blkg, time);
+}
+
+static inline void cfq_blkiocg_set_start_empty_time(struct blkio_group *blkg)
+{
+	blkiocg_set_start_empty_time(blkg);
+}
+
+static inline void cfq_blkiocg_update_io_remove_stats(struct blkio_group *blkg,
+				bool direction, bool sync)
+{
+	blkiocg_update_io_remove_stats(blkg, direction, sync);
+}
+
+static inline void cfq_blkiocg_update_io_merged_stats(struct blkio_group *blkg,
+		bool direction, bool sync)
+{
+	blkiocg_update_io_merged_stats(blkg, direction, sync);
+}
+
+static inline void cfq_blkiocg_update_idle_time_stats(struct blkio_group *blkg)
+{
+	blkiocg_update_idle_time_stats(blkg);
+}
+
+static inline void
+cfq_blkiocg_update_avg_queue_size_stats(struct blkio_group *blkg)
+{
+	blkiocg_update_avg_queue_size_stats(blkg);
+}
+
+static inline void
+cfq_blkiocg_update_set_idle_time_stats(struct blkio_group *blkg)
+{
+	blkiocg_update_set_idle_time_stats(blkg);
+}
+
+static inline void cfq_blkiocg_update_dispatch_stats(struct blkio_group *blkg,
+				uint64_t bytes, bool direction, bool sync)
+{
+	blkiocg_update_dispatch_stats(blkg, bytes, direction, sync);
+}
+
+static inline void cfq_blkiocg_update_completion_stats(struct blkio_group *blkg, uint64_t start_time, uint64_t io_start_time, bool direction, bool sync)
+{
+	blkiocg_update_completion_stats(blkg, start_time, io_start_time,
+				direction, sync);
+}
+
+static inline void cfq_blkiocg_add_blkio_group(struct blkio_cgroup *blkcg,
+			struct blkio_group *blkg, void *key, dev_t dev) {
+	blkiocg_add_blkio_group(blkcg, blkg, key, dev);
+}
+
+static inline int cfq_blkiocg_del_blkio_group(struct blkio_group *blkg)
+{
+	return blkiocg_del_blkio_group(blkg);
+}
+
+#else /* CFQ_GROUP_IOSCHED */
+static inline void cfq_blkiocg_update_io_add_stats(struct blkio_group *blkg,
+	struct blkio_group *curr_blkg, bool direction, bool sync) {}
+
+static inline void cfq_blkiocg_update_dequeue_stats(struct blkio_group *blkg,
+			unsigned long dequeue) {}
+
+static inline void cfq_blkiocg_update_timeslice_used(struct blkio_group *blkg,
+			unsigned long time) {}
+static inline void cfq_blkiocg_set_start_empty_time(struct blkio_group *blkg) {}
+static inline void cfq_blkiocg_update_io_remove_stats(struct blkio_group *blkg,
+				bool direction, bool sync) {}
+static inline void cfq_blkiocg_update_io_merged_stats(struct blkio_group *blkg,
+		bool direction, bool sync) {}
+static inline void cfq_blkiocg_update_idle_time_stats(struct blkio_group *blkg)
+{
+}
+static inline void
+cfq_blkiocg_update_avg_queue_size_stats(struct blkio_group *blkg) {}
+
+static inline void
+cfq_blkiocg_update_set_idle_time_stats(struct blkio_group *blkg) {}
+
+static inline void cfq_blkiocg_update_dispatch_stats(struct blkio_group *blkg,
+				uint64_t bytes, bool direction, bool sync) {}
+static inline void cfq_blkiocg_update_completion_stats(struct blkio_group *blkg, uint64_t start_time, uint64_t io_start_time, bool direction, bool sync) {}
+
+static inline void cfq_blkiocg_add_blkio_group(struct blkio_cgroup *blkcg,
+			struct blkio_group *blkg, void *key, dev_t dev) {}
+static inline int cfq_blkiocg_del_blkio_group(struct blkio_group *blkg)
+{
+	return 0;
+}
+
+#endif /* CFQ_GROUP_IOSCHED */
+#endif
diff -urN linux-2.6.35-rc3/drivers/acpi/acpi_pad.c linux-2.6.35-rc4/drivers/acpi/acpi_pad.c
--- linux-2.6.35-rc3/drivers/acpi/acpi_pad.c	2010-07-05 05:34:21.707805526 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpi_pad.c	2010-07-05 05:34:27.128868105 +0000
@@ -46,6 +46,8 @@
 
 static unsigned char tsc_detected_unstable;
 static unsigned char tsc_marked_unstable;
+static unsigned char lapic_detected_unstable;
+static unsigned char lapic_marked_unstable;
 
 static void power_saving_mwait_init(void)
 {
@@ -75,9 +77,6 @@
 	power_saving_mwait_eax = (highest_cstate << MWAIT_SUBSTATE_SIZE) |
 		(highest_subcstate - 1);
 
-	for_each_online_cpu(i)
-		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ON, &i);
-
 #if defined(CONFIG_GENERIC_TIME) && defined(CONFIG_X86)
 	switch (boot_cpu_data.x86_vendor) {
 	case X86_VENDOR_AMD:
@@ -86,13 +85,15 @@
 		 * AMD Fam10h TSC will tick in all
 		 * C/P/S0/S1 states when this bit is set.
 		 */
-		if (boot_cpu_has(X86_FEATURE_NONSTOP_TSC))
-			return;
-
-		/*FALL THROUGH*/
+		if (!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))
+			tsc_detected_unstable = 1;
+		if (!boot_cpu_has(X86_FEATURE_ARAT))
+			lapic_detected_unstable = 1;
+		break;
 	default:
-		/* TSC could halt in idle */
+		/* TSC & LAPIC could halt in idle */
 		tsc_detected_unstable = 1;
+		lapic_detected_unstable = 1;
 	}
 #endif
 }
@@ -180,10 +181,20 @@
 				mark_tsc_unstable("TSC halts in idle");
 				tsc_marked_unstable = 1;
 			}
+			if (lapic_detected_unstable && !lapic_marked_unstable) {
+				int i;
+				/* LAPIC could halt in idle, so notify users */
+				for_each_online_cpu(i)
+					clockevents_notify(
+						CLOCK_EVT_NOTIFY_BROADCAST_ON,
+						&i);
+				lapic_marked_unstable = 1;
+			}
 			local_irq_disable();
 			cpu = smp_processor_id();
-			clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
-				&cpu);
+			if (lapic_marked_unstable)
+				clockevents_notify(
+					CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);
 			stop_critical_timings();
 
 			__monitor((void *)&current_thread_info()->flags, 0, 0);
@@ -192,8 +203,9 @@
 				__mwait(power_saving_mwait_eax, 1);
 
 			start_critical_timings();
-			clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
-				&cpu);
+			if (lapic_marked_unstable)
+				clockevents_notify(
+					CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);
 			local_irq_enable();
 
 			if (jiffies > expire_time) {
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/acconfig.h linux-2.6.35-rc4/drivers/acpi/acpica/acconfig.h
--- linux-2.6.35-rc3/drivers/acpi/acpica/acconfig.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/acconfig.h	2010-07-05 05:34:27.128868105 +0000
@@ -119,6 +119,10 @@
 
 #define ACPI_MAX_LOOP_ITERATIONS        0xFFFF
 
+/* Maximum sleep allowed via Sleep() operator */
+
+#define ACPI_MAX_SLEEP                  20000	/* Two seconds */
+
 /******************************************************************************
  *
  * ACPI Specification constants (Do not change unless the specification changes)
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/acevents.h linux-2.6.35-rc4/drivers/acpi/acpica/acevents.h
--- linux-2.6.35-rc3/drivers/acpi/acpica/acevents.h	2010-07-05 05:34:21.708805450 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/acevents.h	2010-07-05 05:34:27.128868105 +0000
@@ -80,10 +80,6 @@
 acpi_status
 acpi_ev_update_gpe_enable_masks(struct acpi_gpe_event_info *gpe_event_info);
 
-acpi_status acpi_ev_enable_gpe(struct acpi_gpe_event_info *gpe_event_info);
-
-acpi_status acpi_ev_disable_gpe(struct acpi_gpe_event_info *gpe_event_info);
-
 struct acpi_gpe_event_info *acpi_ev_get_gpe_event_info(acpi_handle gpe_device,
 						       u32 gpe_number);
 
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/acglobal.h linux-2.6.35-rc4/drivers/acpi/acpica/acglobal.h
--- linux-2.6.35-rc3/drivers/acpi/acpica/acglobal.h	2010-07-05 05:34:21.708805450 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/acglobal.h	2010-07-05 05:34:27.128868105 +0000
@@ -125,6 +125,14 @@
  */
 u8 ACPI_INIT_GLOBAL(acpi_gbl_copy_dsdt_locally, FALSE);
 
+/*
+ * Optionally truncate I/O addresses to 16 bits. Provides compatibility
+ * with other ACPI implementations. NOTE: During ACPICA initialization,
+ * this value is set to TRUE if any Windows OSI strings have been
+ * requested by the BIOS.
+ */
+u8 ACPI_INIT_GLOBAL(acpi_gbl_truncate_io_addresses, FALSE);
+
 /* acpi_gbl_FADT is a local copy of the FADT, converted to a common format. */
 
 struct acpi_table_fadt acpi_gbl_FADT;
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/achware.h linux-2.6.35-rc4/drivers/acpi/acpica/achware.h
--- linux-2.6.35-rc3/drivers/acpi/acpica/achware.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/achware.h	2010-07-05 05:34:27.128868105 +0000
@@ -90,7 +90,11 @@
 /*
  * hwgpe - GPE support
  */
-acpi_status acpi_hw_low_disable_gpe(struct acpi_gpe_event_info *gpe_event_info);
+u32 acpi_hw_gpe_register_bit(struct acpi_gpe_event_info *gpe_event_info,
+			     struct acpi_gpe_register_info *gpe_register_info);
+
+acpi_status
+acpi_hw_low_set_gpe(struct acpi_gpe_event_info *gpe_event_info, u8 action);
 
 acpi_status
 acpi_hw_write_gpe_enable_reg(struct acpi_gpe_event_info *gpe_event_info);
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/evgpe.c linux-2.6.35-rc4/drivers/acpi/acpica/evgpe.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/evgpe.c	2010-07-05 05:34:21.710805481 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/evgpe.c	2010-07-05 05:34:27.131868080 +0000
@@ -69,7 +69,7 @@
 acpi_ev_update_gpe_enable_masks(struct acpi_gpe_event_info *gpe_event_info)
 {
 	struct acpi_gpe_register_info *gpe_register_info;
-	u8 register_bit;
+	u32 register_bit;
 
 	ACPI_FUNCTION_TRACE(ev_update_gpe_enable_masks);
 
@@ -78,9 +78,8 @@
 		return_ACPI_STATUS(AE_NOT_EXIST);
 	}
 
-	register_bit = (u8)
-	    (1 <<
-	     (gpe_event_info->gpe_number - gpe_register_info->base_gpe_number));
+	register_bit = acpi_hw_gpe_register_bit(gpe_event_info,
+						gpe_register_info);
 
 	/* Clear the wake/run bits up front */
 
@@ -100,106 +99,6 @@
 	return_ACPI_STATUS(AE_OK);
 }
 
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_enable_gpe
- *
- * PARAMETERS:  gpe_event_info          - GPE to enable
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Hardware-enable a GPE. Always enables the GPE, regardless
- *              of type or number of references.
- *
- * Note: The GPE lock should be already acquired when this function is called.
- *
- ******************************************************************************/
-
-acpi_status acpi_ev_enable_gpe(struct acpi_gpe_event_info *gpe_event_info)
-{
-	acpi_status status;
-
-
-	ACPI_FUNCTION_TRACE(ev_enable_gpe);
-
-
-	/*
-	 * We will only allow a GPE to be enabled if it has either an
-	 * associated method (_Lxx/_Exx) or a handler. Otherwise, the
-	 * GPE will be immediately disabled by acpi_ev_gpe_dispatch the
-	 * first time it fires.
-	 */
-	if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK)) {
-		return_ACPI_STATUS(AE_NO_HANDLER);
-	}
-
-	/* Ensure the HW enable masks are current */
-
-	status = acpi_ev_update_gpe_enable_masks(gpe_event_info);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/* Clear the GPE (of stale events) */
-
-	status = acpi_hw_clear_gpe(gpe_event_info);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/* Enable the requested GPE */
-
-	status = acpi_hw_write_gpe_enable_reg(gpe_event_info);
-	return_ACPI_STATUS(status);
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ev_disable_gpe
- *
- * PARAMETERS:  gpe_event_info          - GPE to disable
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Hardware-disable a GPE. Always disables the requested GPE,
- *              regardless of the type or number of references.
- *
- * Note: The GPE lock should be already acquired when this function is called.
- *
- ******************************************************************************/
-
-acpi_status acpi_ev_disable_gpe(struct acpi_gpe_event_info *gpe_event_info)
-{
-	acpi_status status;
-
-	ACPI_FUNCTION_TRACE(ev_disable_gpe);
-
-
-	/*
-	 * Note: Always disable the GPE, even if we think that that it is already
-	 * disabled. It is possible that the AML or some other code has enabled
-	 * the GPE behind our back.
-	 */
-
-	/* Ensure the HW enable masks are current */
-
-	status = acpi_ev_update_gpe_enable_masks(gpe_event_info);
-	if (ACPI_FAILURE(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	/*
-	 * Always H/W disable this GPE, even if we don't know the GPE type.
-	 * Simply clear the enable bit for this particular GPE, but do not
-	 * write out the current GPE enable mask since this may inadvertently
-	 * enable GPEs too early. An example is a rogue GPE that has arrived
-	 * during ACPICA initialization - possibly because AML or other code
-	 * has enabled the GPE.
-	 */
-	status = acpi_hw_low_disable_gpe(gpe_event_info);
-	return_ACPI_STATUS(status);
-}
-
 
 /*******************************************************************************
  *
@@ -451,10 +350,6 @@
 		return_VOID;
 	}
 
-	/* Update the GPE register masks for return to enabled state */
-
-	(void)acpi_ev_update_gpe_enable_masks(gpe_event_info);
-
 	/*
 	 * Take a snapshot of the GPE info for this level - we copy the info to
 	 * prevent a race condition with remove_handler/remove_block.
@@ -607,7 +502,7 @@
 		 * Disable the GPE, so it doesn't keep firing before the method has a
 		 * chance to run (it runs asynchronously with interrupts enabled).
 		 */
-		status = acpi_ev_disable_gpe(gpe_event_info);
+		status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);
 		if (ACPI_FAILURE(status)) {
 			ACPI_EXCEPTION((AE_INFO, status,
 					"Unable to disable GPE[0x%2X]",
@@ -644,7 +539,7 @@
 		 * Disable the GPE. The GPE will remain disabled a handler
 		 * is installed or ACPICA is restarted.
 		 */
-		status = acpi_ev_disable_gpe(gpe_event_info);
+		status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);
 		if (ACPI_FAILURE(status)) {
 			ACPI_EXCEPTION((AE_INFO, status,
 					"Unable to disable GPE[0x%2X]",
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/evgpeblk.c linux-2.6.35-rc4/drivers/acpi/acpica/evgpeblk.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/evgpeblk.c	2010-07-05 05:34:21.710805481 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/evgpeblk.c	2010-07-05 05:34:27.131868080 +0000
@@ -500,6 +500,19 @@
 
 			gpe_index = (i * ACPI_GPE_REGISTER_WIDTH) + j;
 			gpe_event_info = &gpe_block->event_info[gpe_index];
+			gpe_number = gpe_index + gpe_block->block_base_number;
+
+			/*
+			 * If the GPE has already been enabled for runtime
+			 * signaling, make sure it remains enabled, but do not
+			 * increment its reference counter.
+			 */
+			if (gpe_event_info->runtime_count) {
+				acpi_set_gpe(gpe_device, gpe_number,
+						ACPI_GPE_ENABLE);
+				gpe_enabled_count++;
+				continue;
+			}
 
 			if (gpe_event_info->flags & ACPI_GPE_CAN_WAKE) {
 				wake_gpe_count++;
@@ -516,7 +529,6 @@
 
 			/* Enable this GPE */
 
-			gpe_number = gpe_index + gpe_block->block_base_number;
 			status = acpi_enable_gpe(gpe_device, gpe_number,
 						 ACPI_GPE_TYPE_RUNTIME);
 			if (ACPI_FAILURE(status)) {
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/evxface.c linux-2.6.35-rc4/drivers/acpi/acpica/evxface.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/evxface.c	2010-07-05 05:34:21.711808243 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/evxface.c	2010-07-05 05:34:27.132868062 +0000
@@ -719,13 +719,6 @@
 	handler->context = context;
 	handler->method_node = gpe_event_info->dispatch.method_node;
 
-	/* Disable the GPE before installing the handler */
-
-	status = acpi_ev_disable_gpe(gpe_event_info);
-	if (ACPI_FAILURE (status)) {
-		goto unlock_and_exit;
-	}
-
 	/* Install the handler */
 
 	flags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/evxfevnt.c linux-2.6.35-rc4/drivers/acpi/acpica/evxfevnt.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/evxfevnt.c	2010-07-05 05:34:21.712805461 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/evxfevnt.c	2010-07-05 05:34:27.133868085 +0000
@@ -210,6 +210,44 @@
 
 /*******************************************************************************
  *
+ * FUNCTION:    acpi_clear_and_enable_gpe
+ *
+ * PARAMETERS:  gpe_event_info  - GPE to enable
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Clear the given GPE from stale events and enable it.
+ *
+ ******************************************************************************/
+static acpi_status
+acpi_clear_and_enable_gpe(struct acpi_gpe_event_info *gpe_event_info)
+{
+	acpi_status status;
+
+	/*
+	 * We will only allow a GPE to be enabled if it has either an
+	 * associated method (_Lxx/_Exx) or a handler. Otherwise, the
+	 * GPE will be immediately disabled by acpi_ev_gpe_dispatch the
+	 * first time it fires.
+	 */
+	if (!(gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK)) {
+		return_ACPI_STATUS(AE_NO_HANDLER);
+	}
+
+	/* Clear the GPE (of stale events) */
+	status = acpi_hw_clear_gpe(gpe_event_info);
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	/* Enable the requested GPE */
+	status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_ENABLE);
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
  * FUNCTION:    acpi_set_gpe
  *
  * PARAMETERS:  gpe_device      - Parent GPE Device. NULL for GPE0/GPE1
@@ -249,11 +287,11 @@
 
 	switch (action) {
 	case ACPI_GPE_ENABLE:
-		status = acpi_ev_enable_gpe(gpe_event_info);
+		status = acpi_clear_and_enable_gpe(gpe_event_info);
 		break;
 
 	case ACPI_GPE_DISABLE:
-		status = acpi_ev_disable_gpe(gpe_event_info);
+		status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_DISABLE);
 		break;
 
 	default:
@@ -316,7 +354,11 @@
 
 		gpe_event_info->runtime_count++;
 		if (gpe_event_info->runtime_count == 1) {
-			status = acpi_ev_enable_gpe(gpe_event_info);
+			status = acpi_ev_update_gpe_enable_masks(gpe_event_info);
+			if (ACPI_SUCCESS(status)) {
+				status = acpi_clear_and_enable_gpe(gpe_event_info);
+			}
+
 			if (ACPI_FAILURE(status)) {
 				gpe_event_info->runtime_count--;
 				goto unlock_and_exit;
@@ -343,7 +385,7 @@
 		 */
 		gpe_event_info->wakeup_count++;
 		if (gpe_event_info->wakeup_count == 1) {
-			(void)acpi_ev_update_gpe_enable_masks(gpe_event_info);
+			status = acpi_ev_update_gpe_enable_masks(gpe_event_info);
 		}
 	}
 
@@ -403,7 +445,12 @@
 
 		gpe_event_info->runtime_count--;
 		if (!gpe_event_info->runtime_count) {
-			status = acpi_ev_disable_gpe(gpe_event_info);
+			status = acpi_ev_update_gpe_enable_masks(gpe_event_info);
+			if (ACPI_SUCCESS(status)) {
+				status = acpi_hw_low_set_gpe(gpe_event_info,
+							     ACPI_GPE_DISABLE);
+			}
+
 			if (ACPI_FAILURE(status)) {
 				gpe_event_info->runtime_count++;
 				goto unlock_and_exit;
@@ -424,7 +471,7 @@
 
 		gpe_event_info->wakeup_count--;
 		if (!gpe_event_info->wakeup_count) {
-			(void)acpi_ev_update_gpe_enable_masks(gpe_event_info);
+			status = acpi_ev_update_gpe_enable_masks(gpe_event_info);
 		}
 	}
 
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/exsystem.c linux-2.6.35-rc4/drivers/acpi/acpica/exsystem.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/exsystem.c	2010-07-05 05:34:21.715805746 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/exsystem.c	2010-07-05 05:34:27.136868061 +0000
@@ -201,6 +201,14 @@
 
 	acpi_ex_relinquish_interpreter();
 
+	/*
+	 * For compatibility with other ACPI implementations and to prevent
+	 * accidental deep sleeps, limit the sleep time to something reasonable.
+	 */
+	if (how_long > ACPI_MAX_SLEEP) {
+		how_long = ACPI_MAX_SLEEP;
+	}
+
 	acpi_os_sleep(how_long);
 
 	/* And now we must get the interpreter again */
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/hwgpe.c linux-2.6.35-rc4/drivers/acpi/acpica/hwgpe.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/hwgpe.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/hwgpe.c	2010-07-05 05:34:27.136868061 +0000
@@ -57,21 +57,47 @@
 
 /******************************************************************************
  *
- * FUNCTION:	acpi_hw_low_disable_gpe
+ * FUNCTION:	acpi_hw_gpe_register_bit
+ *
+ * PARAMETERS:	gpe_event_info	    - Info block for the GPE
+ *		gpe_register_info   - Info block for the GPE register
+ *
+ * RETURN:	Status
+ *
+ * DESCRIPTION:	Compute GPE enable mask with one bit corresponding to the given
+ *		GPE set.
+ *
+ ******************************************************************************/
+
+u32 acpi_hw_gpe_register_bit(struct acpi_gpe_event_info *gpe_event_info,
+			     struct acpi_gpe_register_info *gpe_register_info)
+{
+	return (u32)1 << (gpe_event_info->gpe_number -
+				gpe_register_info->base_gpe_number);
+}
+
+/******************************************************************************
+ *
+ * FUNCTION:	acpi_hw_low_set_gpe
  *
  * PARAMETERS:	gpe_event_info	    - Info block for the GPE to be disabled
+ *		action		    - Enable or disable
  *
  * RETURN:	Status
  *
- * DESCRIPTION: Disable a single GPE in the enable register.
+ * DESCRIPTION: Enable or disable a single GPE in its enable register.
  *
  ******************************************************************************/
 
-acpi_status acpi_hw_low_disable_gpe(struct acpi_gpe_event_info *gpe_event_info)
+acpi_status
+acpi_hw_low_set_gpe(struct acpi_gpe_event_info *gpe_event_info, u8 action)
 {
 	struct acpi_gpe_register_info *gpe_register_info;
 	acpi_status status;
 	u32 enable_mask;
+	u32 register_bit;
+
+	ACPI_FUNCTION_ENTRY();
 
 	/* Get the info block for the entire GPE register */
 
@@ -87,11 +113,27 @@
 		return (status);
 	}
 
-	/* Clear just the bit that corresponds to this GPE */
+	/* Set ot clear just the bit that corresponds to this GPE */
+
+	register_bit = acpi_hw_gpe_register_bit(gpe_event_info,
+						gpe_register_info);
+	switch (action) {
+	case ACPI_GPE_COND_ENABLE:
+		if (!(register_bit & gpe_register_info->enable_for_run))
+			return (AE_BAD_PARAMETER);
+
+	case ACPI_GPE_ENABLE:
+		ACPI_SET_BIT(enable_mask, register_bit);
+		break;
+
+	case ACPI_GPE_DISABLE:
+		ACPI_CLEAR_BIT(enable_mask, register_bit);
+		break;
 
-	ACPI_CLEAR_BIT(enable_mask, ((u32)1 <<
-				     (gpe_event_info->gpe_number -
-				      gpe_register_info->base_gpe_number)));
+	default:
+		ACPI_ERROR((AE_INFO, "Invalid action\n"));
+		return (AE_BAD_PARAMETER);
+	}
 
 	/* Write the updated enable mask */
 
@@ -116,23 +158,11 @@
 acpi_status
 acpi_hw_write_gpe_enable_reg(struct acpi_gpe_event_info * gpe_event_info)
 {
-	struct acpi_gpe_register_info *gpe_register_info;
 	acpi_status status;
 
 	ACPI_FUNCTION_ENTRY();
 
-	/* Get the info block for the entire GPE register */
-
-	gpe_register_info = gpe_event_info->register_info;
-	if (!gpe_register_info) {
-		return (AE_NOT_EXIST);
-	}
-
-	/* Write the entire GPE (runtime) enable register */
-
-	status = acpi_hw_write(gpe_register_info->enable_for_run,
-			       &gpe_register_info->enable_address);
-
+	status = acpi_hw_low_set_gpe(gpe_event_info, ACPI_GPE_COND_ENABLE);
 	return (status);
 }
 
@@ -150,21 +180,28 @@
 
 acpi_status acpi_hw_clear_gpe(struct acpi_gpe_event_info * gpe_event_info)
 {
+	struct acpi_gpe_register_info *gpe_register_info;
 	acpi_status status;
-	u8 register_bit;
+	u32 register_bit;
 
 	ACPI_FUNCTION_ENTRY();
 
-	register_bit = (u8)(1 <<
-			    (gpe_event_info->gpe_number -
-			     gpe_event_info->register_info->base_gpe_number));
+	/* Get the info block for the entire GPE register */
+
+	gpe_register_info = gpe_event_info->register_info;
+	if (!gpe_register_info) {
+		return (AE_NOT_EXIST);
+	}
+
+	register_bit = acpi_hw_gpe_register_bit(gpe_event_info,
+						gpe_register_info);
 
 	/*
 	 * Write a one to the appropriate bit in the status register to
 	 * clear this GPE.
 	 */
 	status = acpi_hw_write(register_bit,
-			       &gpe_event_info->register_info->status_address);
+			       &gpe_register_info->status_address);
 
 	return (status);
 }
@@ -187,7 +224,7 @@
 		       acpi_event_status * event_status)
 {
 	u32 in_byte;
-	u8 register_bit;
+	u32 register_bit;
 	struct acpi_gpe_register_info *gpe_register_info;
 	acpi_status status;
 	acpi_event_status local_event_status = 0;
@@ -204,9 +241,8 @@
 
 	/* Get the register bitmask for this GPE */
 
-	register_bit = (u8)(1 <<
-			    (gpe_event_info->gpe_number -
-			     gpe_event_info->register_info->base_gpe_number));
+	register_bit = acpi_hw_gpe_register_bit(gpe_event_info,
+						gpe_register_info);
 
 	/* GPE currently enabled? (enabled for runtime?) */
 
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/hwvalid.c linux-2.6.35-rc4/drivers/acpi/acpica/hwvalid.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/hwvalid.c	2010-07-05 05:34:21.715805746 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/hwvalid.c	2010-07-05 05:34:27.137868057 +0000
@@ -222,6 +222,12 @@
 	u32 one_byte;
 	u32 i;
 
+	/* Truncate address to 16 bits if requested */
+
+	if (acpi_gbl_truncate_io_addresses) {
+		address &= ACPI_UINT16_MAX;
+	}
+
 	/* Validate the entire request and perform the I/O */
 
 	status = acpi_hw_validate_io_request(address, width);
@@ -279,6 +285,12 @@
 	acpi_status status;
 	u32 i;
 
+	/* Truncate address to 16 bits if requested */
+
+	if (acpi_gbl_truncate_io_addresses) {
+		address &= ACPI_UINT16_MAX;
+	}
+
 	/* Validate the entire request and perform the I/O */
 
 	status = acpi_hw_validate_io_request(address, width);
diff -urN linux-2.6.35-rc3/drivers/acpi/acpica/nsinit.c linux-2.6.35-rc4/drivers/acpi/acpica/nsinit.c
--- linux-2.6.35-rc3/drivers/acpi/acpica/nsinit.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/acpica/nsinit.c	2010-07-05 05:34:27.137868057 +0000
@@ -193,6 +193,15 @@
 					acpi_ns_init_one_device, NULL, &info,
 					NULL);
 
+	/*
+	 * Any _OSI requests should be completed by now. If the BIOS has
+	 * requested any Windows OSI strings, we will always truncate
+	 * I/O addresses to 16 bits -- for Windows compatibility.
+	 */
+	if (acpi_gbl_osi_data >= ACPI_OSI_WIN_2000) {
+		acpi_gbl_truncate_io_addresses = TRUE;
+	}
+
 	ACPI_FREE(info.evaluate_info);
 	if (ACPI_FAILURE(status)) {
 		goto error_exit;
diff -urN linux-2.6.35-rc3/drivers/acpi/apei/apei-base.c linux-2.6.35-rc4/drivers/acpi/apei/apei-base.c
--- linux-2.6.35-rc3/drivers/acpi/apei/apei-base.c	2010-07-05 05:34:21.720805699 +0000
+++ linux-2.6.35-rc4/drivers/acpi/apei/apei-base.c	2010-07-05 05:34:27.141868092 +0000
@@ -34,6 +34,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/acpi.h>
+#include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/kref.h>
 #include <linux/rculist.h>
diff -urN linux-2.6.35-rc3/drivers/acpi/apei/erst.c linux-2.6.35-rc4/drivers/acpi/apei/erst.c
--- linux-2.6.35-rc3/drivers/acpi/apei/erst.c	2010-07-05 05:34:21.721805575 +0000
+++ linux-2.6.35-rc4/drivers/acpi/apei/erst.c	2010-07-05 05:34:27.142868059 +0000
@@ -781,7 +781,7 @@
 	status = acpi_get_table(ACPI_SIG_ERST, 0,
 				(struct acpi_table_header **)&erst_tab);
 	if (status == AE_NOT_FOUND) {
-		pr_err(ERST_PFX "Table is not found!\n");
+		pr_info(ERST_PFX "Table is not found!\n");
 		goto err;
 	} else if (ACPI_FAILURE(status)) {
 		const char *msg = acpi_format_exception(status);
diff -urN linux-2.6.35-rc3/drivers/acpi/atomicio.c linux-2.6.35-rc4/drivers/acpi/atomicio.c
--- linux-2.6.35-rc3/drivers/acpi/atomicio.c	2010-07-05 05:34:21.722805526 +0000
+++ linux-2.6.35-rc4/drivers/acpi/atomicio.c	2010-07-05 05:34:27.143868080 +0000
@@ -31,6 +31,7 @@
 #include <linux/kref.h>
 #include <linux/rculist.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 #include <acpi/atomicio.h>
 
 #define ACPI_PFX "ACPI: "
diff -urN linux-2.6.35-rc3/drivers/acpi/blacklist.c linux-2.6.35-rc4/drivers/acpi/blacklist.c
--- linux-2.6.35-rc3/drivers/acpi/blacklist.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/blacklist.c	2010-07-05 05:34:27.143868080 +0000
@@ -218,6 +218,14 @@
 		},
 	},
 	{
+	.callback = dmi_disable_osi_vista,
+	.ident = "VGN-NS50B_L",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NS50B_L"),
+		},
+	},
+	{
 	.callback = dmi_disable_osi_win7,
 	.ident = "ASUS K50IJ",
 	.matches = {
diff -urN linux-2.6.35-rc3/drivers/acpi/button.c linux-2.6.35-rc4/drivers/acpi/button.c
--- linux-2.6.35-rc3/drivers/acpi/button.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/button.c	2010-07-05 05:34:27.143868080 +0000
@@ -425,7 +425,7 @@
 		/* Button's GPE is run-wake GPE */
 		acpi_enable_gpe(device->wakeup.gpe_device,
 				device->wakeup.gpe_number,
-				ACPI_GPE_TYPE_WAKE_RUN);
+				ACPI_GPE_TYPE_RUNTIME);
 		device->wakeup.run_wake_count++;
 		device->wakeup.state.enabled = 1;
 	}
@@ -449,7 +449,7 @@
 	if (device->wakeup.flags.valid) {
 		acpi_disable_gpe(device->wakeup.gpe_device,
 				device->wakeup.gpe_number,
-				ACPI_GPE_TYPE_WAKE_RUN);
+				ACPI_GPE_TYPE_RUNTIME);
 		device->wakeup.run_wake_count--;
 		device->wakeup.state.enabled = 0;
 	}
diff -urN linux-2.6.35-rc3/drivers/acpi/fan.c linux-2.6.35-rc4/drivers/acpi/fan.c
--- linux-2.6.35-rc3/drivers/acpi/fan.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/fan.c	2010-07-05 05:34:27.144868232 +0000
@@ -347,7 +347,6 @@
 {
 	int result = 0;
 
-
 #ifdef CONFIG_ACPI_PROCFS
 	acpi_fan_dir = proc_mkdir(ACPI_FAN_CLASS, acpi_root_dir);
 	if (!acpi_fan_dir)
@@ -356,7 +355,9 @@
 
 	result = acpi_bus_register_driver(&acpi_fan_driver);
 	if (result < 0) {
+#ifdef CONFIG_ACPI_PROCFS
 		remove_proc_entry(ACPI_FAN_CLASS, acpi_root_dir);
+#endif
 		return -ENODEV;
 	}
 
diff -urN linux-2.6.35-rc3/drivers/acpi/processor_driver.c linux-2.6.35-rc4/drivers/acpi/processor_driver.c
--- linux-2.6.35-rc3/drivers/acpi/processor_driver.c	2010-07-05 05:34:21.724805677 +0000
+++ linux-2.6.35-rc4/drivers/acpi/processor_driver.c	2010-07-05 05:34:27.146868082 +0000
@@ -581,6 +581,11 @@
 		return 0;
 	}
 
+#ifdef CONFIG_SMP
+	if (pr->id >= setup_max_cpus && pr->id != 0)
+		return 0;
+#endif
+
 	BUG_ON((pr->id >= nr_cpu_ids) || (pr->id < 0));
 
 	/*
diff -urN linux-2.6.35-rc3/drivers/acpi/sleep.c linux-2.6.35-rc4/drivers/acpi/sleep.c
--- linux-2.6.35-rc3/drivers/acpi/sleep.c	2010-07-05 05:34:21.725805520 +0000
+++ linux-2.6.35-rc4/drivers/acpi/sleep.c	2010-07-05 05:34:27.147805326 +0000
@@ -114,6 +114,8 @@
 {
 	int error = acpi_sleep_prepare(acpi_target_sleep_state);
 
+	suspend_nvs_save();
+
 	if (error)
 		acpi_target_sleep_state = ACPI_STATE_S0;
 	return error;
@@ -143,6 +145,9 @@
 {
 	u32 acpi_state = acpi_target_sleep_state;
 
+	suspend_nvs_free();
+	acpi_ec_unblock_transactions();
+
 	if (acpi_state == ACPI_STATE_S0)
 		return;
 
@@ -192,6 +197,11 @@
 	u32 acpi_state = acpi_suspend_states[pm_state];
 	int error = 0;
 
+	error = suspend_nvs_alloc();
+
+	if (error)
+		return error;
+
 	if (sleep_states[acpi_state]) {
 		acpi_target_sleep_state = acpi_state;
 		acpi_sleep_tts_switch(acpi_target_sleep_state);
@@ -269,12 +279,13 @@
 	if (acpi_state == ACPI_STATE_S3)
 		acpi_restore_state_mem();
 
+	suspend_nvs_restore();
+
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
 static void acpi_suspend_finish(void)
 {
-	acpi_ec_unblock_transactions();
 	acpi_pm_finish();
 }
 
@@ -404,7 +415,7 @@
 {
 	int error;
 
-	error = s4_no_nvs ? 0 : hibernate_nvs_alloc();
+	error = s4_no_nvs ? 0 : suspend_nvs_alloc();
 	if (!error) {
 		acpi_target_sleep_state = ACPI_STATE_S4;
 		acpi_sleep_tts_switch(acpi_target_sleep_state);
@@ -418,7 +429,7 @@
 	int error = acpi_pm_prepare();
 
 	if (!error)
-		hibernate_nvs_save();
+		suspend_nvs_save();
 
 	return error;
 }
@@ -441,13 +452,6 @@
 	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
 }
 
-static void acpi_hibernation_finish(void)
-{
-	hibernate_nvs_free();
-	acpi_ec_unblock_transactions();
-	acpi_pm_finish();
-}
-
 static void acpi_hibernation_leave(void)
 {
 	/*
@@ -464,7 +468,7 @@
 		panic("ACPI S4 hardware signature mismatch");
 	}
 	/* Restore the NVS memory area */
-	hibernate_nvs_restore();
+	suspend_nvs_restore();
 	/* Allow EC transactions to happen. */
 	acpi_ec_unblock_transactions_early();
 }
@@ -479,7 +483,7 @@
 	.begin = acpi_hibernation_begin,
 	.end = acpi_pm_end,
 	.pre_snapshot = acpi_hibernation_pre_snapshot,
-	.finish = acpi_hibernation_finish,
+	.finish = acpi_pm_finish,
 	.prepare = acpi_pm_prepare,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,
@@ -507,7 +511,7 @@
 
 	if (!error) {
 		if (!s4_no_nvs)
-			error = hibernate_nvs_alloc();
+			error = suspend_nvs_alloc();
 		if (!error)
 			acpi_target_sleep_state = ACPI_STATE_S4;
 	}
@@ -517,7 +521,7 @@
 static int acpi_hibernation_pre_snapshot_old(void)
 {
 	acpi_pm_freeze();
-	hibernate_nvs_save();
+	suspend_nvs_save();
 	return 0;
 }
 
@@ -529,8 +533,8 @@
 	.begin = acpi_hibernation_begin_old,
 	.end = acpi_pm_end,
 	.pre_snapshot = acpi_hibernation_pre_snapshot_old,
-	.finish = acpi_hibernation_finish,
 	.prepare = acpi_pm_freeze,
+	.finish = acpi_pm_finish,
 	.enter = acpi_hibernation_enter,
 	.leave = acpi_hibernation_leave,
 	.pre_restore = acpi_pm_freeze,
diff -urN linux-2.6.35-rc3/drivers/acpi/system.c linux-2.6.35-rc4/drivers/acpi/system.c
--- linux-2.6.35-rc3/drivers/acpi/system.c	2010-07-05 05:34:21.725805520 +0000
+++ linux-2.6.35-rc4/drivers/acpi/system.c	2010-07-05 05:34:27.147805326 +0000
@@ -388,10 +388,12 @@
 	if (index < num_gpes) {
 		if (!strcmp(buf, "disable\n") &&
 				(status & ACPI_EVENT_FLAG_ENABLED))
-			result = acpi_set_gpe(handle, index, ACPI_GPE_DISABLE);
+			result = acpi_disable_gpe(handle, index,
+						ACPI_GPE_TYPE_RUNTIME);
 		else if (!strcmp(buf, "enable\n") &&
 				!(status & ACPI_EVENT_FLAG_ENABLED))
-			result = acpi_set_gpe(handle, index, ACPI_GPE_ENABLE);
+			result = acpi_enable_gpe(handle, index,
+						ACPI_GPE_TYPE_RUNTIME);
 		else if (!strcmp(buf, "clear\n") &&
 				(status & ACPI_EVENT_FLAG_SET))
 			result = acpi_clear_gpe(handle, index);
diff -urN linux-2.6.35-rc3/drivers/acpi/wakeup.c linux-2.6.35-rc4/drivers/acpi/wakeup.c
--- linux-2.6.35-rc3/drivers/acpi/wakeup.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/acpi/wakeup.c	2010-07-05 05:34:27.148805568 +0000
@@ -64,16 +64,13 @@
 		struct acpi_device *dev =
 			container_of(node, struct acpi_device, wakeup_list);
 
-		if (!dev->wakeup.flags.valid)
-			continue;
-
-		if ((!dev->wakeup.state.enabled && !dev->wakeup.prepare_count)
+		if (!dev->wakeup.flags.valid || !dev->wakeup.state.enabled
 		    || sleep_state > (u32) dev->wakeup.sleep_state)
 			continue;
 
 		/* The wake-up power should have been enabled already. */
-		acpi_set_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number,
-				ACPI_GPE_ENABLE);
+		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number,
+				ACPI_GPE_TYPE_WAKE);
 	}
 }
 
@@ -96,6 +93,8 @@
 		    || (sleep_state > (u32) dev->wakeup.sleep_state))
 			continue;
 
+		acpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number,
+				ACPI_GPE_TYPE_WAKE);
 		acpi_disable_wakeup_device_power(dev);
 	}
 }
@@ -109,13 +108,8 @@
 		struct acpi_device *dev = container_of(node,
 						       struct acpi_device,
 						       wakeup_list);
-		/* In case user doesn't load button driver */
-		if (!dev->wakeup.flags.always_enabled ||
-		    dev->wakeup.state.enabled)
-			continue;
- 		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number,
- 				ACPI_GPE_TYPE_WAKE);
-		dev->wakeup.state.enabled = 1;
+		if (dev->wakeup.flags.always_enabled)
+			dev->wakeup.state.enabled = 1;
 	}
 	mutex_unlock(&acpi_device_lock);
 	return 0;
diff -urN linux-2.6.35-rc3/drivers/ata/ahci.c linux-2.6.35-rc4/drivers/ata/ahci.c
--- linux-2.6.35-rc3/drivers/ata/ahci.c	2010-07-05 05:34:21.728805391 +0000
+++ linux-2.6.35-rc4/drivers/ata/ahci.c	2010-07-05 05:34:27.150868096 +0000
@@ -1053,6 +1053,16 @@
 	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)
 		return -ENODEV;
 
+	/*
+	 * For some reason, MCP89 on MacBook 7,1 doesn't work with
+	 * ahci, use ata_generic instead.
+	 */
+	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA &&
+	    pdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA &&
+	    pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&
+	    pdev->subsystem_device == 0xcb89)
+		return -ENODEV;
+
 	/* Promise's PDC42819 is a SAS/SATA controller that has an AHCI mode.
 	 * At the moment, we can only use the AHCI mode. Let the users know
 	 * that for SAS drives they're out of luck.
diff -urN linux-2.6.35-rc3/drivers/ata/ata_generic.c linux-2.6.35-rc4/drivers/ata/ata_generic.c
--- linux-2.6.35-rc3/drivers/ata/ata_generic.c	2010-07-05 05:34:21.728805391 +0000
+++ linux-2.6.35-rc4/drivers/ata/ata_generic.c	2010-07-05 05:34:27.150868096 +0000
@@ -32,6 +32,11 @@
  *	A generic parallel ATA driver using libata
  */
 
+enum {
+	ATA_GEN_CLASS_MATCH		= (1 << 0),
+	ATA_GEN_FORCE_DMA		= (1 << 1),
+};
+
 /**
  *	generic_set_mode	-	mode setting
  *	@link: link to set up
@@ -46,13 +51,17 @@
 static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 {
 	struct ata_port *ap = link->ap;
+	const struct pci_device_id *id = ap->host->private_data;
 	int dma_enabled = 0;
 	struct ata_device *dev;
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
-	/* Bits 5 and 6 indicate if DMA is active on master/slave */
-	if (ap->ioaddr.bmdma_addr)
+	if (id->driver_data & ATA_GEN_FORCE_DMA) {
+		dma_enabled = 0xff;
+	} else if (ap->ioaddr.bmdma_addr) {
+		/* Bits 5 and 6 indicate if DMA is active on master/slave */
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	}
 
 	if (pdev->vendor == PCI_VENDOR_ID_CENATEK)
 		dma_enabled = 0xFF;
@@ -126,7 +135,7 @@
 	const struct ata_port_info *ppi[] = { &info, NULL };
 
 	/* Don't use the generic entry unless instructed to do so */
-	if (id->driver_data == 1 && all_generic_ide == 0)
+	if ((id->driver_data & ATA_GEN_CLASS_MATCH) && all_generic_ide == 0)
 		return -ENODEV;
 
 	/* Devices that need care */
@@ -155,7 +164,7 @@
 			return rc;
 		pcim_pin_device(dev);
 	}
-	return ata_pci_bmdma_init_one(dev, ppi, &generic_sht, NULL, 0);
+	return ata_pci_bmdma_init_one(dev, ppi, &generic_sht, (void *)id, 0);
 }
 
 static struct pci_device_id ata_generic[] = {
@@ -167,7 +176,15 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_HINT,   PCI_DEVICE_ID_HINT_VXPROII_IDE), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA,    PCI_DEVICE_ID_VIA_82C561), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE),
+	  .driver_data = ATA_GEN_FORCE_DMA },
+	/*
+	 * For some reason, MCP89 on MacBook 7,1 doesn't work with
+	 * ahci, use ata_generic instead.
+	 */
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA,
+	  PCI_VENDOR_ID_APPLE, 0xcb89,
+	  .driver_data = ATA_GEN_FORCE_DMA },
 #if !defined(CONFIG_PATA_TOSHIBA) && !defined(CONFIG_PATA_TOSHIBA_MODULE)
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },
@@ -175,7 +192,8 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_5),  },
 #endif	
 	/* Must come last. If you add entries adjust this table appropriately */
-	{ PCI_ANY_ID,		PCI_ANY_ID,			   PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL, 1},
+	{ PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL),
+	  .driver_data = ATA_GEN_CLASS_MATCH },
 	{ 0, },
 };
 
diff -urN linux-2.6.35-rc3/drivers/ata/libahci.c linux-2.6.35-rc4/drivers/ata/libahci.c
--- linux-2.6.35-rc3/drivers/ata/libahci.c	2010-07-05 05:34:21.730805482 +0000
+++ linux-2.6.35-rc4/drivers/ata/libahci.c	2010-07-05 05:34:27.152868065 +0000
@@ -324,6 +324,7 @@
 	struct ahci_host_priv *hpriv = ap->host->private_data;
 	void __iomem *mmio = hpriv->mmio;
 	void __iomem *em_mmio = mmio + hpriv->em_loc;
+	const unsigned char *msg_buf = buf;
 	u32 em_ctl, msg;
 	unsigned long flags;
 	int i;
@@ -343,8 +344,8 @@
 	}
 
 	for (i = 0; i < size; i += 4) {
-		msg = buf[i] | buf[i + 1] << 8 |
-		      buf[i + 2] << 16 | buf[i + 3] << 24;
+		msg = msg_buf[i] | msg_buf[i + 1] << 8 |
+		      msg_buf[i + 2] << 16 | msg_buf[i + 3] << 24;
 		writel(msg, em_mmio + i);
 	}
 
diff -urN linux-2.6.35-rc3/drivers/block/cciss_scsi.c linux-2.6.35-rc4/drivers/block/cciss_scsi.c
--- linux-2.6.35-rc3/drivers/block/cciss_scsi.c	2010-07-05 05:34:21.750805628 +0000
+++ linux-2.6.35-rc4/drivers/block/cciss_scsi.c	2010-07-05 05:34:27.172868043 +0000
@@ -861,6 +861,7 @@
 	sh->n_io_port = 0;	// I don't think we use these two...
 	sh->this_id = SELF_SCSI_ID;  
 	sh->sg_tablesize = hba[ctlr]->maxsgentries;
+	sh->max_cmd_len = MAX_COMMAND_SIZE;
 
 	((struct cciss_scsi_adapter_data_t *) 
 		hba[ctlr]->scsi_ctlr)->scsi_host = sh;
diff -urN linux-2.6.35-rc3/drivers/block/cpqarray.c linux-2.6.35-rc4/drivers/block/cpqarray.c
--- linux-2.6.35-rc3/drivers/block/cpqarray.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/block/cpqarray.c	2010-07-05 05:34:27.172868043 +0000
@@ -386,7 +386,7 @@
 }
 
 /* pdev is NULL for eisa */
-static int __init cpqarray_register_ctlr( int i, struct pci_dev *pdev)
+static int __devinit cpqarray_register_ctlr( int i, struct pci_dev *pdev)
 {
 	struct request_queue *q;
 	int j;
@@ -503,7 +503,7 @@
 	return -1;
 }
 
-static int __init cpqarray_init_one( struct pci_dev *pdev,
+static int __devinit cpqarray_init_one( struct pci_dev *pdev,
 	const struct pci_device_id *ent)
 {
 	int i;
@@ -740,7 +740,7 @@
 /*
  * Find an EISA controller's signature.  Set up an hba if we find it.
  */
-static int __init cpqarray_eisa_detect(void)
+static int __devinit cpqarray_eisa_detect(void)
 {
 	int i=0, j;
 	__u32 board_id;
diff -urN linux-2.6.35-rc3/drivers/block/drbd/drbd_main.c linux-2.6.35-rc4/drivers/block/drbd/drbd_main.c
--- linux-2.6.35-rc3/drivers/block/drbd/drbd_main.c	2010-07-05 05:34:21.751805573 +0000
+++ linux-2.6.35-rc4/drivers/block/drbd/drbd_main.c	2010-07-05 05:34:27.174868056 +0000
@@ -1236,8 +1236,6 @@
 	/* Last part of the attaching process ... */
 	if (ns.conn >= C_CONNECTED &&
 	    os.disk == D_ATTACHING && ns.disk == D_NEGOTIATING) {
-		kfree(mdev->p_uuid); /* We expect to receive up-to-date UUIDs soon. */
-		mdev->p_uuid = NULL; /* ...to not use the old ones in the mean time */
 		drbd_send_sizes(mdev, 0, 0);  /* to start sync... */
 		drbd_send_uuids(mdev);
 		drbd_send_state(mdev);
diff -urN linux-2.6.35-rc3/drivers/block/drbd/drbd_nl.c linux-2.6.35-rc4/drivers/block/drbd/drbd_nl.c
--- linux-2.6.35-rc3/drivers/block/drbd/drbd_nl.c	2010-07-05 05:34:21.752805596 +0000
+++ linux-2.6.35-rc4/drivers/block/drbd/drbd_nl.c	2010-07-05 05:34:27.174868056 +0000
@@ -1114,6 +1114,12 @@
 		mdev->new_state_tmp.i = ns.i;
 		ns.i = os.i;
 		ns.disk = D_NEGOTIATING;
+
+		/* We expect to receive up-to-date UUIDs soon.
+		   To avoid a race in receive_state, free p_uuid while
+		   holding req_lock. I.e. atomic with the state change */
+		kfree(mdev->p_uuid);
+		mdev->p_uuid = NULL;
 	}
 
 	rv = _drbd_set_state(mdev, ns, CS_VERBOSE, NULL);
diff -urN linux-2.6.35-rc3/drivers/char/agp/generic.c linux-2.6.35-rc4/drivers/char/agp/generic.c
--- linux-2.6.35-rc3/drivers/char/agp/generic.c	2010-07-05 05:34:21.758805497 +0000
+++ linux-2.6.35-rc4/drivers/char/agp/generic.c	2010-07-05 05:34:27.181868064 +0000
@@ -97,20 +97,18 @@
 void agp_alloc_page_array(size_t size, struct agp_memory *mem)
 {
 	mem->pages = NULL;
-	mem->vmalloc_flag = false;
 
 	if (size <= 2*PAGE_SIZE)
-		mem->pages = kmalloc(size, GFP_KERNEL | __GFP_NORETRY);
+		mem->pages = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);
 	if (mem->pages == NULL) {
 		mem->pages = vmalloc(size);
-		mem->vmalloc_flag = true;
 	}
 }
 EXPORT_SYMBOL(agp_alloc_page_array);
 
 void agp_free_page_array(struct agp_memory *mem)
 {
-	if (mem->vmalloc_flag) {
+	if (is_vmalloc_addr(mem->pages)) {
 		vfree(mem->pages);
 	} else {
 		kfree(mem->pages);
diff -urN linux-2.6.35-rc3/drivers/char/ipmi/ipmi_si_intf.c linux-2.6.35-rc4/drivers/char/ipmi/ipmi_si_intf.c
--- linux-2.6.35-rc3/drivers/char/ipmi/ipmi_si_intf.c	2010-07-05 05:34:21.765805898 +0000
+++ linux-2.6.35-rc4/drivers/char/ipmi/ipmi_si_intf.c	2010-07-05 05:34:27.188868081 +0000
@@ -302,6 +302,12 @@
 
 static int force_kipmid[SI_MAX_PARMS];
 static int num_force_kipmid;
+#ifdef CONFIG_PCI
+static int pci_registered;
+#endif
+#ifdef CONFIG_PPC_OF
+static int of_registered;
+#endif
 
 static unsigned int kipmid_max_busy_us[SI_MAX_PARMS];
 static int num_max_busy_us;
@@ -1018,7 +1024,7 @@
 		else if (smi_result == SI_SM_IDLE)
 			schedule_timeout_interruptible(100);
 		else
-			schedule_timeout_interruptible(0);
+			schedule_timeout_interruptible(1);
 	}
 	return 0;
 }
@@ -3314,6 +3320,8 @@
 	rv = pci_register_driver(&ipmi_pci_driver);
 	if (rv)
 		printk(KERN_ERR PFX "Unable to register PCI driver: %d\n", rv);
+	else
+		pci_registered = 1;
 #endif
 
 #ifdef CONFIG_ACPI
@@ -3330,6 +3338,7 @@
 
 #ifdef CONFIG_PPC_OF
 	of_register_platform_driver(&ipmi_of_platform_driver);
+	of_registered = 1;
 #endif
 
 	/* We prefer devices with interrupts, but in the case of a machine
@@ -3383,11 +3392,13 @@
 	if (unload_when_empty && list_empty(&smi_infos)) {
 		mutex_unlock(&smi_infos_lock);
 #ifdef CONFIG_PCI
-		pci_unregister_driver(&ipmi_pci_driver);
+		if (pci_registered)
+			pci_unregister_driver(&ipmi_pci_driver);
 #endif
 
 #ifdef CONFIG_PPC_OF
-		of_unregister_platform_driver(&ipmi_of_platform_driver);
+		if (of_registered)
+			of_unregister_platform_driver(&ipmi_of_platform_driver);
 #endif
 		driver_unregister(&ipmi_driver.driver);
 		printk(KERN_WARNING PFX
@@ -3478,14 +3489,16 @@
 		return;
 
 #ifdef CONFIG_PCI
-	pci_unregister_driver(&ipmi_pci_driver);
+	if (pci_registered)
+		pci_unregister_driver(&ipmi_pci_driver);
 #endif
 #ifdef CONFIG_ACPI
 	pnp_unregister_driver(&ipmi_pnp_driver);
 #endif
 
 #ifdef CONFIG_PPC_OF
-	of_unregister_platform_driver(&ipmi_of_platform_driver);
+	if (of_registered)
+		of_unregister_platform_driver(&ipmi_of_platform_driver);
 #endif
 
 	mutex_lock(&smi_infos_lock);
diff -urN linux-2.6.35-rc3/drivers/char/sysrq.c linux-2.6.35-rc4/drivers/char/sysrq.c
--- linux-2.6.35-rc3/drivers/char/sysrq.c	2010-07-05 05:34:21.771805589 +0000
+++ linux-2.6.35-rc4/drivers/char/sysrq.c	2010-07-05 05:34:27.194868063 +0000
@@ -580,8 +580,12 @@
 	case KEY_RIGHTALT:
 		if (value)
 			sysrq_alt = code;
-		else if (sysrq_down && code == sysrq_alt_use)
-			sysrq_down = false;
+		else {
+			if (sysrq_down && code == sysrq_alt_use)
+				sysrq_down = false;
+
+			sysrq_alt = 0;
+		}
 		break;
 
 	case KEY_SYSRQ:
diff -urN linux-2.6.35-rc3/drivers/char/tpm/tpm.h linux-2.6.35-rc4/drivers/char/tpm/tpm.h
--- linux-2.6.35-rc3/drivers/char/tpm/tpm.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/char/tpm/tpm.h	2010-07-05 05:34:27.194868063 +0000
@@ -224,6 +224,7 @@
 	u8	algorithm[4];
 	u8	encscheme[2];
 	u8	sigscheme[2];
+	__be32	paramsize;
 	u8	parameters[12]; /*assuming RSA*/
 	__be32	keysize;
 	u8	modulus[256];
diff -urN linux-2.6.35-rc3/drivers/clocksource/sh_cmt.c linux-2.6.35-rc4/drivers/clocksource/sh_cmt.c
--- linux-2.6.35-rc3/drivers/clocksource/sh_cmt.c	2010-07-05 05:34:21.774805478 +0000
+++ linux-2.6.35-rc4/drivers/clocksource/sh_cmt.c	2010-07-05 05:34:27.197868393 +0000
@@ -449,7 +449,7 @@
 	clk_disable(p->clk);
 
 	/* TODO: calculate good shift from rate and counter bit width */
-	cs->shift = 10;
+	cs->shift = 0;
 	cs->mult = clocksource_hz2mult(p->rate, cs->shift);
 
 	dev_info(&p->pdev->dev, "used as clock source\n");
diff -urN linux-2.6.35-rc3/drivers/cpuidle/governors/menu.c linux-2.6.35-rc4/drivers/cpuidle/governors/menu.c
--- linux-2.6.35-rc3/drivers/cpuidle/governors/menu.c	2010-07-05 05:34:21.776805836 +0000
+++ linux-2.6.35-rc4/drivers/cpuidle/governors/menu.c	2010-07-05 05:34:27.199868070 +0000
@@ -143,7 +143,7 @@
 	 * This allows us to calculate
 	 * E(duration)|iowait
 	 */
-	if (nr_iowait_cpu())
+	if (nr_iowait_cpu(smp_processor_id()))
 		bucket = BUCKETS/2;
 
 	if (duration < 10)
@@ -175,7 +175,7 @@
 	mult += 2 * get_loadavg();
 
 	/* for IO wait tasks (per cpu!) we add 5x each */
-	mult += 10 * nr_iowait_cpu();
+	mult += 10 * nr_iowait_cpu(smp_processor_id());
 
 	return mult;
 }
diff -urN linux-2.6.35-rc3/drivers/dma/ppc4xx/adma.c linux-2.6.35-rc4/drivers/dma/ppc4xx/adma.c
--- linux-2.6.35-rc3/drivers/dma/ppc4xx/adma.c	2010-07-05 05:34:21.785805582 +0000
+++ linux-2.6.35-rc4/drivers/dma/ppc4xx/adma.c	2010-07-05 05:34:27.209868061 +0000
@@ -4257,10 +4257,12 @@
 				     struct ppc440spe_adma_chan *chan,
 				     int *initcode)
 {
+	struct of_device *ofdev;
 	struct device_node *np;
 	int ret;
 
-	np = container_of(adev->dev, struct of_device, dev)->node;
+	ofdev = container_of(adev->dev, struct of_device, dev);
+	np = ofdev->dev.of_node;
 	if (adev->id != PPC440SPE_XOR_ID) {
 		adev->err_irq = irq_of_parse_and_map(np, 1);
 		if (adev->err_irq == NO_IRQ) {
diff -urN linux-2.6.35-rc3/drivers/edac/amd64_edac.c linux-2.6.35-rc4/drivers/edac/amd64_edac.c
--- linux-2.6.35-rc3/drivers/edac/amd64_edac.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/edac/amd64_edac.c	2010-07-05 05:34:27.212868058 +0000
@@ -1958,20 +1958,20 @@
 	u32 value = 0;
 	int err_sym = 0;
 
-	amd64_read_pci_cfg(pvt->misc_f3_ctl, 0x180, &value);
+	if (boot_cpu_data.x86 == 0x10) {
 
-	/* F3x180[EccSymbolSize]=1, x8 symbols */
-	if (boot_cpu_data.x86 == 0x10 &&
-	    boot_cpu_data.x86_model > 7 &&
-	    value & BIT(25)) {
-		err_sym = decode_syndrome(syndrome, x8_vectors,
-					  ARRAY_SIZE(x8_vectors), 8);
-		return map_err_sym_to_channel(err_sym, 8);
-	} else {
-		err_sym = decode_syndrome(syndrome, x4_vectors,
-					  ARRAY_SIZE(x4_vectors), 4);
-		return map_err_sym_to_channel(err_sym, 4);
+		amd64_read_pci_cfg(pvt->misc_f3_ctl, 0x180, &value);
+
+		/* F3x180[EccSymbolSize]=1 => x8 symbols */
+		if (boot_cpu_data.x86_model > 7 &&
+		    value & BIT(25)) {
+			err_sym = decode_syndrome(syndrome, x8_vectors,
+						  ARRAY_SIZE(x8_vectors), 8);
+			return map_err_sym_to_channel(err_sym, 8);
+		}
 	}
+	err_sym = decode_syndrome(syndrome, x4_vectors, ARRAY_SIZE(x4_vectors), 4);
+	return map_err_sym_to_channel(err_sym, 4);
 }
 
 /*
diff -urN linux-2.6.35-rc3/drivers/edac/i7core_edac.c linux-2.6.35-rc4/drivers/edac/i7core_edac.c
--- linux-2.6.35-rc3/drivers/edac/i7core_edac.c	2010-07-05 05:34:21.791805564 +0000
+++ linux-2.6.35-rc4/drivers/edac/i7core_edac.c	2010-07-05 05:34:27.215868088 +0000
@@ -1233,10 +1233,28 @@
 			for (i = 0; i < MAX_SOCKET_BUSES; i++)
 				pcibios_scan_specific_bus(255-i);
 		}
+		pci_dev_put(pdev);
 		table++;
 	}
 }
 
+static unsigned i7core_pci_lastbus(void)
+{
+	int last_bus = 0, bus;
+	struct pci_bus *b = NULL;
+
+	while ((b = pci_find_next_bus(b)) != NULL) {
+		bus = b->number;
+		debugf0("Found bus %d\n", bus);
+		if (bus > last_bus)
+			last_bus = bus;
+	}
+
+	debugf0("Last bus %d\n", last_bus);
+
+	return last_bus;
+}
+
 /*
  *	i7core_get_devices	Find and perform 'get' operation on the MCH's
  *			device/functions we want to reference for this driver
@@ -1244,7 +1262,8 @@
  *			Need to 'get' device 16 func 1 and func 2
  */
 int i7core_get_onedevice(struct pci_dev **prev, int devno,
-			 struct pci_id_descr *dev_descr, unsigned n_devs)
+			 struct pci_id_descr *dev_descr, unsigned n_devs,
+			 unsigned last_bus)
 {
 	struct i7core_dev *i7core_dev;
 
@@ -1291,10 +1310,7 @@
 	}
 	bus = pdev->bus->number;
 
-	if (bus == 0x3f)
-		socket = 0;
-	else
-		socket = 255 - bus;
+	socket = last_bus - bus;
 
 	i7core_dev = get_i7core_dev(socket);
 	if (!i7core_dev) {
@@ -1358,17 +1374,21 @@
 
 static int i7core_get_devices(struct pci_id_table *table)
 {
-	int i, rc;
+	int i, rc, last_bus;
 	struct pci_dev *pdev = NULL;
 	struct pci_id_descr *dev_descr;
 
+	last_bus = i7core_pci_lastbus();
+
 	while (table && table->descr) {
 		dev_descr = table->descr;
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
 			do {
-				rc = i7core_get_onedevice(&pdev, i, &dev_descr[i],
-							  table->n_devs);
+				rc = i7core_get_onedevice(&pdev, i,
+							  &dev_descr[i],
+							  table->n_devs,
+							  last_bus);
 				if (rc < 0) {
 					if (i == 0) {
 						i = table->n_devs;
@@ -1927,21 +1947,26 @@
  *		0 for FOUND a device
  *		< 0 for error code
  */
+
+static int probed = 0;
+
 static int __devinit i7core_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *id)
 {
-	int dev_idx = id->driver_data;
 	int rc;
 	struct i7core_dev *i7core_dev;
 
+	/* get the pci devices we want to reserve for our use */
+	mutex_lock(&i7core_edac_lock);
+
 	/*
 	 * All memory controllers are allocated at the first pass.
 	 */
-	if (unlikely(dev_idx >= 1))
+	if (unlikely(probed >= 1)) {
+		mutex_unlock(&i7core_edac_lock);
 		return -EINVAL;
-
-	/* get the pci devices we want to reserve for our use */
-	mutex_lock(&i7core_edac_lock);
+	}
+	probed++;
 
 	rc = i7core_get_devices(pci_dev_table);
 	if (unlikely(rc < 0))
@@ -2013,6 +2038,8 @@
 				      i7core_dev->socket);
 		}
 	}
+	probed--;
+
 	mutex_unlock(&i7core_edac_lock);
 }
 
diff -urN linux-2.6.35-rc3/drivers/gpio/Kconfig linux-2.6.35-rc4/drivers/gpio/Kconfig
--- linux-2.6.35-rc3/drivers/gpio/Kconfig	2010-07-05 05:34:21.794805459 +0000
+++ linux-2.6.35-rc4/drivers/gpio/Kconfig	2010-07-05 05:34:27.218868055 +0000
@@ -1,5 +1,5 @@
 #
-# GPIO infrastructure and expanders
+# platform-neutral GPIO infrastructure and expanders
 #
 
 config ARCH_WANT_OPTIONAL_GPIOLIB
diff -urN linux-2.6.35-rc3/drivers/gpio/Makefile linux-2.6.35-rc4/drivers/gpio/Makefile
--- linux-2.6.35-rc3/drivers/gpio/Makefile	2010-07-05 05:34:21.794805459 +0000
+++ linux-2.6.35-rc4/drivers/gpio/Makefile	2010-07-05 05:34:27.218868055 +0000
@@ -1,4 +1,8 @@
-# gpio support: dedicated expander chips, etc
+# generic gpio support: dedicated expander chips, etc
+#
+# NOTE: platform-specific GPIO drivers don't belong in the
+# drivers/gpio directory; put them with other platform setup
+# code, IRQ controllers, board init, etc.
 
 ccflags-$(CONFIG_DEBUG_GPIO)	+= -DDEBUG
 
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/drm_fb_helper.c linux-2.6.35-rc4/drivers/gpu/drm/drm_fb_helper.c
--- linux-2.6.35-rc3/drivers/gpu/drm/drm_fb_helper.c	2010-07-05 05:34:21.799805538 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/drm_fb_helper.c	2010-07-05 05:34:27.223868059 +0000
@@ -146,7 +146,7 @@
 				cvt = 1;
 			break;
 		case 'R':
-			if (!cvt)
+			if (cvt)
 				rb = 1;
 			break;
 		case 'm':
@@ -1024,11 +1024,18 @@
 	}
 
 create_mode:
-	mode = drm_cvt_mode(fb_helper_conn->connector->dev, cmdline_mode->xres,
-			    cmdline_mode->yres,
-			    cmdline_mode->refresh_specified ? cmdline_mode->refresh : 60,
-			    cmdline_mode->rb, cmdline_mode->interlace,
-			    cmdline_mode->margins);
+	if (cmdline_mode->cvt)
+		mode = drm_cvt_mode(fb_helper_conn->connector->dev,
+				    cmdline_mode->xres, cmdline_mode->yres,
+				    cmdline_mode->refresh_specified ? cmdline_mode->refresh : 60,
+				    cmdline_mode->rb, cmdline_mode->interlace,
+				    cmdline_mode->margins);
+	else
+		mode = drm_gtf_mode(fb_helper_conn->connector->dev,
+				    cmdline_mode->xres, cmdline_mode->yres,
+				    cmdline_mode->refresh_specified ? cmdline_mode->refresh : 60,
+				    cmdline_mode->interlace,
+				    cmdline_mode->margins);
 	drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
 	list_add(&mode->head, &fb_helper_conn->connector->modes);
 	return mode;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/dvo_tfp410.c linux-2.6.35-rc4/drivers/gpu/drm/i915/dvo_tfp410.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/dvo_tfp410.c	2010-07-05 05:34:21.800805468 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/dvo_tfp410.c	2010-07-05 05:34:27.224868067 +0000
@@ -208,7 +208,7 @@
 	uint8_t ctl2;
 
 	if (tfp410_readb(dvo, TFP410_CTL_2, &ctl2)) {
-		if (ctl2 & TFP410_CTL_2_HTPLG)
+		if (ctl2 & TFP410_CTL_2_RSEN)
 			ret = connector_status_connected;
 		else
 			ret = connector_status_disconnected;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_debugfs.c linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_debugfs.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_debugfs.c	2010-07-05 05:34:21.801805800 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_debugfs.c	2010-07-05 05:34:27.225868060 +0000
@@ -620,7 +620,7 @@
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	bool sr_enabled = false;
 
-	if (IS_I965G(dev) || IS_I945G(dev) || IS_I945GM(dev))
+	if (IS_I965GM(dev) || IS_I945G(dev) || IS_I945GM(dev))
 		sr_enabled = I915_READ(FW_BLC_SELF) & FW_BLC_SELF_EN;
 	else if (IS_I915GM(dev))
 		sr_enabled = I915_READ(INSTPM) & INSTPM_SELF_EN;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_dma.c linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_dma.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_dma.c	2010-07-05 05:34:21.802805592 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_dma.c	2010-07-05 05:34:27.226868047 +0000
@@ -128,9 +128,11 @@
 	if (dev->irq_enabled)
 		drm_irq_uninstall(dev);
 
+	mutex_lock(&dev->struct_mutex);
 	intel_cleanup_ring_buffer(dev, &dev_priv->render_ring);
 	if (HAS_BSD(dev))
 		intel_cleanup_ring_buffer(dev, &dev_priv->bsd_ring);
+	mutex_unlock(&dev->struct_mutex);
 
 	/* Clear the HWS virtual address at teardown */
 	if (I915_NEED_GFX_HWS(dev))
@@ -1229,7 +1231,7 @@
 static void i915_setup_compression(struct drm_device *dev, int size)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct drm_mm_node *compressed_fb, *compressed_llb;
+	struct drm_mm_node *compressed_fb, *uninitialized_var(compressed_llb);
 	unsigned long cfb_base;
 	unsigned long ll_base = 0;
 
@@ -1410,6 +1412,10 @@
 	if (ret)
 		goto cleanup_vga_client;
 
+	/* IIR "flip pending" bit means done if this bit is set */
+	if (IS_GEN3(dev) && (I915_READ(ECOSKPD) & ECO_FLIP_DONE))
+		dev_priv->flip_pending_is_done = true;
+
 	intel_modeset_init(dev);
 
 	ret = drm_irq_install(dev);
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_drv.h linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_drv.h
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_drv.h	2010-07-05 05:34:21.802805592 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_drv.h	2010-07-05 05:34:27.226868047 +0000
@@ -596,6 +596,7 @@
 	struct drm_crtc *plane_to_crtc_mapping[2];
 	struct drm_crtc *pipe_to_crtc_mapping[2];
 	wait_queue_head_t pending_flip_queue;
+	bool flip_pending_is_done;
 
 	/* Reclocking support */
 	bool render_reclock_avail;
@@ -1076,7 +1077,7 @@
 	drm_i915_private_t *dev_priv = dev->dev_private;                \
 	if (I915_VERBOSE)						\
 		DRM_DEBUG("   BEGIN_LP_RING %x\n", (int)(n));		\
-	intel_ring_begin(dev, &dev_priv->render_ring, 4*(n));		\
+	intel_ring_begin(dev, &dev_priv->render_ring, (n));		\
 } while (0)
 
 
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_gem.c linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_gem.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_gem.c	2010-07-05 05:34:21.804805491 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_gem.c	2010-07-05 05:34:27.228868060 +0000
@@ -2239,7 +2239,7 @@
 	mapping = inode->i_mapping;
 	for (i = 0; i < page_count; i++) {
 		page = read_cache_page_gfp(mapping, i,
-					   mapping_gfp_mask (mapping) |
+					   GFP_HIGHUSER |
 					   __GFP_COLD |
 					   gfpmask);
 		if (IS_ERR(page))
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_irq.c linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_irq.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_irq.c	2010-07-05 05:34:21.805805580 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_irq.c	2010-07-05 05:34:27.229809347 +0000
@@ -940,22 +940,30 @@
 		if (HAS_BSD(dev) && (iir & I915_BSD_USER_INTERRUPT))
 			DRM_WAKEUP(&dev_priv->bsd_ring.irq_queue);
 
-		if (iir & I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT)
+		if (iir & I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT) {
 			intel_prepare_page_flip(dev, 0);
+			if (dev_priv->flip_pending_is_done)
+				intel_finish_page_flip_plane(dev, 0);
+		}
 
-		if (iir & I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT)
+		if (iir & I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT) {
 			intel_prepare_page_flip(dev, 1);
+			if (dev_priv->flip_pending_is_done)
+				intel_finish_page_flip_plane(dev, 1);
+		}
 
 		if (pipea_stats & vblank_status) {
 			vblank++;
 			drm_handle_vblank(dev, 0);
-			intel_finish_page_flip(dev, 0);
+			if (!dev_priv->flip_pending_is_done)
+				intel_finish_page_flip(dev, 0);
 		}
 
 		if (pipeb_stats & vblank_status) {
 			vblank++;
 			drm_handle_vblank(dev, 1);
-			intel_finish_page_flip(dev, 1);
+			if (!dev_priv->flip_pending_is_done)
+				intel_finish_page_flip(dev, 1);
 		}
 
 		if ((pipea_stats & I915_LEGACY_BLC_EVENT_STATUS) ||
@@ -1387,29 +1395,10 @@
 	dev_priv->pipestat[1] = 0;
 
 	if (I915_HAS_HOTPLUG(dev)) {
-		u32 hotplug_en = I915_READ(PORT_HOTPLUG_EN);
-
-		/* Note HDMI and DP share bits */
-		if (dev_priv->hotplug_supported_mask & HDMIB_HOTPLUG_INT_STATUS)
-			hotplug_en |= HDMIB_HOTPLUG_INT_EN;
-		if (dev_priv->hotplug_supported_mask & HDMIC_HOTPLUG_INT_STATUS)
-			hotplug_en |= HDMIC_HOTPLUG_INT_EN;
-		if (dev_priv->hotplug_supported_mask & HDMID_HOTPLUG_INT_STATUS)
-			hotplug_en |= HDMID_HOTPLUG_INT_EN;
-		if (dev_priv->hotplug_supported_mask & SDVOC_HOTPLUG_INT_STATUS)
-			hotplug_en |= SDVOC_HOTPLUG_INT_EN;
-		if (dev_priv->hotplug_supported_mask & SDVOB_HOTPLUG_INT_STATUS)
-			hotplug_en |= SDVOB_HOTPLUG_INT_EN;
-		if (dev_priv->hotplug_supported_mask & CRT_HOTPLUG_INT_STATUS)
-			hotplug_en |= CRT_HOTPLUG_INT_EN;
-		/* Ignore TV since it's buggy */
-
-		I915_WRITE(PORT_HOTPLUG_EN, hotplug_en);
-
 		/* Enable in IER... */
 		enable_mask |= I915_DISPLAY_PORT_INTERRUPT;
 		/* and unmask in IMR */
-		i915_enable_irq(dev_priv, I915_DISPLAY_PORT_INTERRUPT);
+		dev_priv->irq_mask_reg &= ~I915_DISPLAY_PORT_INTERRUPT;
 	}
 
 	/*
@@ -1427,16 +1416,41 @@
 	}
 	I915_WRITE(EMR, error_mask);
 
-	/* Disable pipe interrupt enables, clear pending pipe status */
-	I915_WRITE(PIPEASTAT, I915_READ(PIPEASTAT) & 0x8000ffff);
-	I915_WRITE(PIPEBSTAT, I915_READ(PIPEBSTAT) & 0x8000ffff);
-	/* Clear pending interrupt status */
-	I915_WRITE(IIR, I915_READ(IIR));
-
-	I915_WRITE(IER, enable_mask);
 	I915_WRITE(IMR, dev_priv->irq_mask_reg);
+	I915_WRITE(IER, enable_mask);
 	(void) I915_READ(IER);
 
+	if (I915_HAS_HOTPLUG(dev)) {
+		u32 hotplug_en = I915_READ(PORT_HOTPLUG_EN);
+
+		/* Note HDMI and DP share bits */
+		if (dev_priv->hotplug_supported_mask & HDMIB_HOTPLUG_INT_STATUS)
+			hotplug_en |= HDMIB_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & HDMIC_HOTPLUG_INT_STATUS)
+			hotplug_en |= HDMIC_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & HDMID_HOTPLUG_INT_STATUS)
+			hotplug_en |= HDMID_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & SDVOC_HOTPLUG_INT_STATUS)
+			hotplug_en |= SDVOC_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & SDVOB_HOTPLUG_INT_STATUS)
+			hotplug_en |= SDVOB_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & CRT_HOTPLUG_INT_STATUS) {
+			hotplug_en |= CRT_HOTPLUG_INT_EN;
+
+			/* Programming the CRT detection parameters tends
+			   to generate a spurious hotplug event about three
+			   seconds later.  So just do it once.
+			*/
+			if (IS_G4X(dev))
+				hotplug_en |= CRT_HOTPLUG_ACTIVATION_PERIOD_64;
+			hotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;
+		}
+
+		/* Ignore TV since it's buggy */
+
+		I915_WRITE(PORT_HOTPLUG_EN, hotplug_en);
+	}
+
 	opregion_enable_asle(dev);
 
 	return 0;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_reg.h linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_reg.h
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/i915_reg.h	2010-07-05 05:34:21.805805580 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/i915_reg.h	2010-07-05 05:34:27.229809347 +0000
@@ -178,6 +178,7 @@
 #define   MI_OVERLAY_OFF	(0x2<<21)
 #define MI_LOAD_SCAN_LINES_INCL MI_INSTR(0x12, 0)
 #define MI_DISPLAY_FLIP		MI_INSTR(0x14, 2)
+#define MI_DISPLAY_FLIP_I915	MI_INSTR(0x14, 1)
 #define   MI_DISPLAY_FLIP_PLANE(n) ((n) << 20)
 #define MI_STORE_DWORD_IMM	MI_INSTR(0x20, 1)
 #define   MI_MEM_VIRTUAL	(1 << 22) /* 965+ only */
@@ -368,6 +369,9 @@
 #define   CM0_RC_OP_FLUSH_DISABLE (1<<0)
 #define BB_ADDR		0x02140 /* 8 bytes */
 #define GFX_FLSH_CNTL	0x02170 /* 915+ only */
+#define ECOSKPD		0x021d0
+#define   ECO_GATING_CX_ONLY	(1<<3)
+#define   ECO_FLIP_DONE		(1<<0)
 
 /* GEN6 interrupt control */
 #define GEN6_RENDER_HWSTAM	0x2098
@@ -1130,7 +1134,6 @@
 #define CRT_HOTPLUG_DETECT_DELAY_2G		(1 << 4)
 #define CRT_HOTPLUG_DETECT_VOLTAGE_325MV	(0 << 2)
 #define CRT_HOTPLUG_DETECT_VOLTAGE_475MV	(1 << 2)
-#define CRT_HOTPLUG_MASK			(0x3fc) /* Bits 9-2 */
 
 #define PORT_HOTPLUG_STAT	0x61114
 #define   HDMIB_HOTPLUG_INT_STATUS		(1 << 29)
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_crt.c linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_crt.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_crt.c	2010-07-05 05:34:21.806805648 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_crt.c	2010-07-05 05:34:27.230805692 +0000
@@ -234,14 +234,8 @@
 	else
 		tries = 1;
 	hotplug_en = orig = I915_READ(PORT_HOTPLUG_EN);
-	hotplug_en &= CRT_HOTPLUG_MASK;
 	hotplug_en |= CRT_HOTPLUG_FORCE_DETECT;
 
-	if (IS_G4X(dev))
-		hotplug_en |= CRT_HOTPLUG_ACTIVATION_PERIOD_64;
-
-	hotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;
-
 	for (i = 0; i < tries ; i++) {
 		unsigned long timeout;
 		/* turn on the FORCE_DETECT */
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_display.c linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_display.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_display.c	2010-07-05 05:34:21.808805619 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_display.c	2010-07-05 05:34:27.232817300 +0000
@@ -2970,11 +2970,13 @@
 		if (srwm < 0)
 			srwm = 1;
 		srwm &= 0x3f;
-		I915_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN);
+		if (IS_I965GM(dev))
+			I915_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN);
 	} else {
 		/* Turn off self refresh if both pipes are enabled */
-		I915_WRITE(FW_BLC_SELF, I915_READ(FW_BLC_SELF)
-					& ~FW_BLC_SELF_EN);
+		if (IS_I965GM(dev))
+			I915_WRITE(FW_BLC_SELF, I915_READ(FW_BLC_SELF)
+				   & ~FW_BLC_SELF_EN);
 	}
 
 	DRM_DEBUG_KMS("Setting FIFO watermarks - A: 8, B: 8, C: 8, SR %d\n",
@@ -4483,6 +4485,7 @@
 	struct drm_device *dev = dev_priv->dev;
 	struct drm_crtc *crtc;
 	struct intel_crtc *intel_crtc;
+	int enabled = 0;
 
 	if (!i915_powersave)
 		return;
@@ -4491,21 +4494,22 @@
 
 	i915_update_gfx_val(dev_priv);
 
-	if (IS_I945G(dev) || IS_I945GM(dev)) {
-		DRM_DEBUG_DRIVER("enable memory self refresh on 945\n");
-		I915_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN_MASK | FW_BLC_SELF_EN);
-	}
-
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 		/* Skip inactive CRTCs */
 		if (!crtc->fb)
 			continue;
 
+		enabled++;
 		intel_crtc = to_intel_crtc(crtc);
 		if (!intel_crtc->busy)
 			intel_decrease_pllclock(crtc);
 	}
 
+	if ((enabled == 1) && (IS_I945G(dev) || IS_I945GM(dev))) {
+		DRM_DEBUG_DRIVER("enable memory self refresh on 945\n");
+		I915_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN_MASK | FW_BLC_SELF_EN);
+	}
+
 	mutex_unlock(&dev->struct_mutex);
 }
 
@@ -4601,10 +4605,10 @@
 	kfree(work);
 }
 
-void intel_finish_page_flip(struct drm_device *dev, int pipe)
+static void do_intel_finish_page_flip(struct drm_device *dev,
+				      struct drm_crtc *crtc)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
-	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 	struct intel_unpin_work *work;
 	struct drm_i915_gem_object *obj_priv;
@@ -4648,6 +4652,22 @@
 	schedule_work(&work->work);
 }
 
+void intel_finish_page_flip(struct drm_device *dev, int pipe)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
+
+	do_intel_finish_page_flip(dev, crtc);
+}
+
+void intel_finish_page_flip_plane(struct drm_device *dev, int plane)
+{
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	struct drm_crtc *crtc = dev_priv->plane_to_crtc_mapping[plane];
+
+	do_intel_finish_page_flip(dev, crtc);
+}
+
 void intel_prepare_page_flip(struct drm_device *dev, int plane)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
@@ -4678,6 +4698,7 @@
 	unsigned long flags;
 	int pipesrc_reg = (intel_crtc->pipe == 0) ? PIPEASRC : PIPEBSRC;
 	int ret, pipesrc;
+	u32 flip_mask;
 
 	work = kzalloc(sizeof *work, GFP_KERNEL);
 	if (work == NULL)
@@ -4731,15 +4752,28 @@
 	atomic_inc(&obj_priv->pending_flip);
 	work->pending_flip_obj = obj;
 
+	if (intel_crtc->plane)
+		flip_mask = I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT;
+	else
+		flip_mask = I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT;
+
+	/* Wait for any previous flip to finish */
+	if (IS_GEN3(dev))
+		while (I915_READ(ISR) & flip_mask)
+			;
+
 	BEGIN_LP_RING(4);
-	OUT_RING(MI_DISPLAY_FLIP |
-		 MI_DISPLAY_FLIP_PLANE(intel_crtc->plane));
-	OUT_RING(fb->pitch);
 	if (IS_I965G(dev)) {
+		OUT_RING(MI_DISPLAY_FLIP |
+			 MI_DISPLAY_FLIP_PLANE(intel_crtc->plane));
+		OUT_RING(fb->pitch);
 		OUT_RING(obj_priv->gtt_offset | obj_priv->tiling_mode);
 		pipesrc = I915_READ(pipesrc_reg); 
 		OUT_RING(pipesrc & 0x0fff0fff);
 	} else {
+		OUT_RING(MI_DISPLAY_FLIP_I915 |
+			 MI_DISPLAY_FLIP_PLANE(intel_crtc->plane));
+		OUT_RING(fb->pitch);
 		OUT_RING(obj_priv->gtt_offset);
 		OUT_RING(MI_NOOP);
 	}
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_dp.c linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_dp.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_dp.c	2010-07-05 05:34:21.808805619 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_dp.c	2010-07-05 05:34:27.233805140 +0000
@@ -136,6 +136,12 @@
 }
 
 static int
+intel_dp_max_data_rate(int max_link_clock, int max_lanes)
+{
+	return (max_link_clock * max_lanes * 8) / 10;
+}
+
+static int
 intel_dp_mode_valid(struct drm_connector *connector,
 		    struct drm_display_mode *mode)
 {
@@ -144,8 +150,11 @@
 	int max_link_clock = intel_dp_link_clock(intel_dp_max_link_bw(intel_encoder));
 	int max_lanes = intel_dp_max_lane_count(intel_encoder);
 
-	if (intel_dp_link_required(connector->dev, intel_encoder, mode->clock)
-			> max_link_clock * max_lanes)
+	/* only refuse the mode on non eDP since we have seen some wierd eDP panels
+	   which are outside spec tolerances but somehow work by magic */
+	if (!IS_eDP(intel_encoder) &&
+	    (intel_dp_link_required(connector->dev, intel_encoder, mode->clock)
+	     > intel_dp_max_data_rate(max_link_clock, max_lanes)))
 		return MODE_CLOCK_HIGH;
 
 	if (mode->clock < 10000)
@@ -506,7 +515,7 @@
 
 	for (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {
 		for (clock = 0; clock <= max_clock; clock++) {
-			int link_avail = intel_dp_link_clock(bws[clock]) * lane_count;
+			int link_avail = intel_dp_max_data_rate(intel_dp_link_clock(bws[clock]), lane_count);
 
 			if (intel_dp_link_required(encoder->dev, intel_encoder, mode->clock)
 					<= link_avail) {
@@ -521,6 +530,18 @@
 			}
 		}
 	}
+
+	if (IS_eDP(intel_encoder)) {
+		/* okay we failed just pick the highest */
+		dp_priv->lane_count = max_lane_count;
+		dp_priv->link_bw = bws[max_clock];
+		adjusted_mode->clock = intel_dp_link_clock(dp_priv->link_bw);
+		DRM_DEBUG_KMS("Force picking display port link bw %02x lane "
+			      "count %d clock %d\n",
+			      dp_priv->link_bw, dp_priv->lane_count,
+			      adjusted_mode->clock);
+		return true;
+	}
 	return false;
 }
 
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_drv.h linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_drv.h
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_drv.h	2010-07-05 05:34:21.809805438 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_drv.h	2010-07-05 05:34:27.233805140 +0000
@@ -224,6 +224,7 @@
 
 extern void intel_prepare_page_flip(struct drm_device *dev, int plane);
 extern void intel_finish_page_flip(struct drm_device *dev, int pipe);
+extern void intel_finish_page_flip_plane(struct drm_device *dev, int plane);
 
 extern void intel_setup_overlay(struct drm_device *dev);
 extern void intel_cleanup_overlay(struct drm_device *dev);
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_lvds.c linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_lvds.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_lvds.c	2010-07-05 05:34:21.810805575 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_lvds.c	2010-07-05 05:34:27.234805394 +0000
@@ -983,8 +983,8 @@
 
 	drm_connector_attach_property(&intel_connector->base,
 				      dev->mode_config.scaling_mode_property,
-				      DRM_MODE_SCALE_FULLSCREEN);
-	lvds_priv->fitting_mode = DRM_MODE_SCALE_FULLSCREEN;
+				      DRM_MODE_SCALE_ASPECT);
+	lvds_priv->fitting_mode = DRM_MODE_SCALE_ASPECT;
 	/*
 	 * LVDS discovery:
 	 * 1) check for EDID on DDC
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_ringbuffer.c linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_ringbuffer.c
--- linux-2.6.35-rc3/drivers/gpu/drm/i915/intel_ringbuffer.c	2010-07-05 05:34:21.810805575 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/i915/intel_ringbuffer.c	2010-07-05 05:34:27.235868119 +0000
@@ -94,7 +94,7 @@
 #if WATCH_EXEC
 		DRM_INFO("%s: queue flush %08x to ring\n", __func__, cmd);
 #endif
-		intel_ring_begin(dev, ring, 8);
+		intel_ring_begin(dev, ring, 2);
 		intel_ring_emit(dev, ring, cmd);
 		intel_ring_emit(dev, ring, MI_NOOP);
 		intel_ring_advance(dev, ring);
@@ -358,7 +358,7 @@
 		u32     invalidate_domains,
 		u32     flush_domains)
 {
-	intel_ring_begin(dev, ring, 8);
+	intel_ring_begin(dev, ring, 2);
 	intel_ring_emit(dev, ring, MI_FLUSH);
 	intel_ring_emit(dev, ring, MI_NOOP);
 	intel_ring_advance(dev, ring);
@@ -687,6 +687,7 @@
 		*virt++ = MI_NOOP;
 
 	ring->tail = 0;
+	ring->space = ring->head - 8;
 
 	return 0;
 }
@@ -721,8 +722,9 @@
 }
 
 void intel_ring_begin(struct drm_device *dev,
-		struct intel_ring_buffer *ring, int n)
+		struct intel_ring_buffer *ring, int num_dwords)
 {
+	int n = 4*num_dwords;
 	if (unlikely(ring->tail + n > ring->size))
 		intel_wrap_ring_buffer(dev, ring);
 	if (unlikely(ring->space < n))
@@ -752,7 +754,7 @@
 {
 	unsigned int *virt = ring->virtual_start + ring->tail;
 	BUG_ON((len&~(4-1)) != 0);
-	intel_ring_begin(dev, ring, len);
+	intel_ring_begin(dev, ring, len/4);
 	memcpy(virt, data, len);
 	ring->tail += len;
 	ring->tail &= ring->size - 1;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/atombios_crtc.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/atombios_crtc.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/atombios_crtc.c	2010-07-05 05:34:21.821805853 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/atombios_crtc.c	2010-07-05 05:34:27.245868098 +0000
@@ -498,7 +498,7 @@
 		if ((rdev->family == CHIP_RS600) ||
 		    (rdev->family == CHIP_RS690) ||
 		    (rdev->family == CHIP_RS740))
-			pll->flags |= (RADEON_PLL_USE_FRAC_FB_DIV |
+			pll->flags |= (/*RADEON_PLL_USE_FRAC_FB_DIV |*/
 				       RADEON_PLL_PREFER_CLOSEST_LOWER);
 
 		if (ASIC_IS_DCE32(rdev) && mode->clock > 200000)	/* range limits??? */
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/evergreen.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/evergreen.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/evergreen.c	2010-07-05 05:34:21.822805531 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/evergreen.c	2010-07-05 05:34:27.246868259 +0000
@@ -607,7 +607,7 @@
 	WREG32(MC_VM_FB_LOCATION, tmp);
 	WREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));
 	WREG32(HDP_NONSURFACE_INFO, (2 << 7));
-	WREG32(HDP_NONSURFACE_SIZE, (rdev->mc.mc_vram_size - 1) | 0x3FF);
+	WREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);
 	if (rdev->flags & RADEON_IS_AGP) {
 		WREG32(MC_VM_AGP_TOP, rdev->mc.gtt_end >> 16);
 		WREG32(MC_VM_AGP_BOT, rdev->mc.gtt_start >> 16);
@@ -1222,11 +1222,11 @@
 		ps_thread_count = 128;
 
 	sq_thread_resource_mgmt = NUM_PS_THREADS(ps_thread_count);
-	sq_thread_resource_mgmt |= NUM_VS_THREADS(((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8;
-	sq_thread_resource_mgmt |= NUM_GS_THREADS(((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8;
-	sq_thread_resource_mgmt |= NUM_ES_THREADS(((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8;
-	sq_thread_resource_mgmt_2 = NUM_HS_THREADS(((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8;
-	sq_thread_resource_mgmt_2 |= NUM_LS_THREADS(((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8;
+	sq_thread_resource_mgmt |= NUM_VS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);
+	sq_thread_resource_mgmt |= NUM_GS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);
+	sq_thread_resource_mgmt |= NUM_ES_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);
+	sq_thread_resource_mgmt_2 = NUM_HS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);
+	sq_thread_resource_mgmt_2 |= NUM_LS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);
 
 	sq_stack_resource_mgmt_1 = NUM_PS_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);
 	sq_stack_resource_mgmt_1 |= NUM_VS_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);
@@ -1260,6 +1260,9 @@
 	WREG32(VGT_GS_VERTEX_REUSE, 16);
 	WREG32(PA_SC_LINE_STIPPLE_STATE, 0);
 
+	WREG32(VGT_VERTEX_REUSE_BLOCK_CNTL, 14);
+	WREG32(VGT_OUT_DEALLOC_CNTL, 16);
+
 	WREG32(CB_PERF_CTR0_SEL_0, 0);
 	WREG32(CB_PERF_CTR0_SEL_1, 0);
 	WREG32(CB_PERF_CTR1_SEL_0, 0);
@@ -1269,6 +1272,26 @@
 	WREG32(CB_PERF_CTR3_SEL_0, 0);
 	WREG32(CB_PERF_CTR3_SEL_1, 0);
 
+	/* clear render buffer base addresses */
+	WREG32(CB_COLOR0_BASE, 0);
+	WREG32(CB_COLOR1_BASE, 0);
+	WREG32(CB_COLOR2_BASE, 0);
+	WREG32(CB_COLOR3_BASE, 0);
+	WREG32(CB_COLOR4_BASE, 0);
+	WREG32(CB_COLOR5_BASE, 0);
+	WREG32(CB_COLOR6_BASE, 0);
+	WREG32(CB_COLOR7_BASE, 0);
+	WREG32(CB_COLOR8_BASE, 0);
+	WREG32(CB_COLOR9_BASE, 0);
+	WREG32(CB_COLOR10_BASE, 0);
+	WREG32(CB_COLOR11_BASE, 0);
+
+	/* set the shader const cache sizes to 0 */
+	for (i = SQ_ALU_CONST_BUFFER_SIZE_PS_0; i < 0x28200; i += 4)
+		WREG32(i, 0);
+	for (i = SQ_ALU_CONST_BUFFER_SIZE_HS_0; i < 0x29000; i += 4)
+		WREG32(i, 0);
+
 	hdp_host_path_cntl = RREG32(HDP_HOST_PATH_CNTL);
 	WREG32(HDP_HOST_PATH_CNTL, hdp_host_path_cntl);
 
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/evergreen_cs.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/evergreen_cs.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/evergreen_cs.c	2010-07-05 05:34:21.822805531 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/evergreen_cs.c	2010-07-05 05:34:27.246868259 +0000
@@ -1197,7 +1197,7 @@
 					DRM_ERROR("bad SET_RESOURCE (tex)\n");
 					return -EINVAL;
 				}
-				ib[idx+1+(i*8)+3] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);
+				ib[idx+1+(i*8)+2] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);
 				if (reloc->lobj.tiling_flags & RADEON_TILING_MACRO)
 					ib[idx+1+(i*8)+1] |= TEX_ARRAY_MODE(ARRAY_2D_TILED_THIN1);
 				else if (reloc->lobj.tiling_flags & RADEON_TILING_MICRO)
@@ -1209,7 +1209,7 @@
 					DRM_ERROR("bad SET_RESOURCE (tex)\n");
 					return -EINVAL;
 				}
-				ib[idx+1+(i*8)+4] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);
+				ib[idx+1+(i*8)+3] += (u32)((reloc->lobj.gpu_offset >> 8) & 0xffffffff);
 				mipmap = reloc->robj;
 				r = evergreen_check_texture_resource(p,  idx+1+(i*8),
 						texture, mipmap);
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/evergreend.h linux-2.6.35-rc4/drivers/gpu/drm/radeon/evergreend.h
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/evergreend.h	2010-07-05 05:34:21.823805631 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/evergreend.h	2010-07-05 05:34:27.247868054 +0000
@@ -713,6 +713,9 @@
 #define SQ_GSVS_RING_OFFSET_2				0x28930
 #define SQ_GSVS_RING_OFFSET_3				0x28934
 
+#define SQ_ALU_CONST_BUFFER_SIZE_PS_0			0x28140
+#define SQ_ALU_CONST_BUFFER_SIZE_HS_0			0x28f80
+
 #define SQ_ALU_CONST_CACHE_PS_0				0x28940
 #define SQ_ALU_CONST_CACHE_PS_1				0x28944
 #define SQ_ALU_CONST_CACHE_PS_2				0x28948
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/r100.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/r100.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/r100.c	2010-07-05 05:34:21.824805494 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/r100.c	2010-07-05 05:34:27.248872784 +0000
@@ -1628,6 +1628,7 @@
 		case RADEON_TXFORMAT_RGB332:
 		case RADEON_TXFORMAT_Y8:
 			track->textures[i].cpp = 1;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case RADEON_TXFORMAT_AI88:
 		case RADEON_TXFORMAT_ARGB1555:
@@ -1639,12 +1640,14 @@
 		case RADEON_TXFORMAT_LDUDV655:
 		case RADEON_TXFORMAT_DUDV88:
 			track->textures[i].cpp = 2;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case RADEON_TXFORMAT_ARGB8888:
 		case RADEON_TXFORMAT_RGBA8888:
 		case RADEON_TXFORMAT_SHADOW32:
 		case RADEON_TXFORMAT_LDUDUV8888:
 			track->textures[i].cpp = 4;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case RADEON_TXFORMAT_DXT1:
 			track->textures[i].cpp = 1;
@@ -2604,12 +2607,6 @@
 	int surf_index = reg * 16;
 	int flags = 0;
 
-	/* r100/r200 divide by 16 */
-	if (rdev->family < CHIP_R300)
-		flags = pitch / 16;
-	else
-		flags = pitch / 8;
-
 	if (rdev->family <= CHIP_RS200) {
 		if ((tiling_flags & (RADEON_TILING_MACRO|RADEON_TILING_MICRO))
 				 == (RADEON_TILING_MACRO|RADEON_TILING_MICRO))
@@ -2633,6 +2630,20 @@
 	if (tiling_flags & RADEON_TILING_SWAP_32BIT)
 		flags |= RADEON_SURF_AP0_SWP_32BPP | RADEON_SURF_AP1_SWP_32BPP;
 
+	/* when we aren't tiling the pitch seems to needs to be furtherdivided down. - tested on power5 + rn50 server */
+	if (tiling_flags & (RADEON_TILING_SWAP_16BIT | RADEON_TILING_SWAP_32BIT)) {
+		if (!(tiling_flags & (RADEON_TILING_MACRO | RADEON_TILING_MICRO)))
+			if (ASIC_IS_RN50(rdev))
+				pitch /= 16;
+	}
+
+	/* r100/r200 divide by 16 */
+	if (rdev->family < CHIP_R300)
+		flags |= pitch / 16;
+	else
+		flags |= pitch / 8;
+
+
 	DRM_DEBUG("writing surface %d %d %x %x\n", reg, flags, offset, offset+obj_size-1);
 	WREG32(RADEON_SURFACE0_INFO + surf_index, flags);
 	WREG32(RADEON_SURFACE0_LOWER_BOUND + surf_index, offset);
@@ -3147,33 +3158,6 @@
 	DRM_ERROR("compress format            %d\n", t->compress_format);
 }
 
-static int r100_cs_track_cube(struct radeon_device *rdev,
-			      struct r100_cs_track *track, unsigned idx)
-{
-	unsigned face, w, h;
-	struct radeon_bo *cube_robj;
-	unsigned long size;
-
-	for (face = 0; face < 5; face++) {
-		cube_robj = track->textures[idx].cube_info[face].robj;
-		w = track->textures[idx].cube_info[face].width;
-		h = track->textures[idx].cube_info[face].height;
-
-		size = w * h;
-		size *= track->textures[idx].cpp;
-
-		size += track->textures[idx].cube_info[face].offset;
-
-		if (size > radeon_bo_size(cube_robj)) {
-			DRM_ERROR("Cube texture offset greater than object size %lu %lu\n",
-				  size, radeon_bo_size(cube_robj));
-			r100_cs_track_texture_print(&track->textures[idx]);
-			return -1;
-		}
-	}
-	return 0;
-}
-
 static int r100_track_compress_size(int compress_format, int w, int h)
 {
 	int block_width, block_height, block_bytes;
@@ -3204,6 +3188,37 @@
 	return sz;
 }
 
+static int r100_cs_track_cube(struct radeon_device *rdev,
+			      struct r100_cs_track *track, unsigned idx)
+{
+	unsigned face, w, h;
+	struct radeon_bo *cube_robj;
+	unsigned long size;
+	unsigned compress_format = track->textures[idx].compress_format;
+
+	for (face = 0; face < 5; face++) {
+		cube_robj = track->textures[idx].cube_info[face].robj;
+		w = track->textures[idx].cube_info[face].width;
+		h = track->textures[idx].cube_info[face].height;
+
+		if (compress_format) {
+			size = r100_track_compress_size(compress_format, w, h);
+		} else
+			size = w * h;
+		size *= track->textures[idx].cpp;
+
+		size += track->textures[idx].cube_info[face].offset;
+
+		if (size > radeon_bo_size(cube_robj)) {
+			DRM_ERROR("Cube texture offset greater than object size %lu %lu\n",
+				  size, radeon_bo_size(cube_robj));
+			r100_cs_track_texture_print(&track->textures[idx]);
+			return -1;
+		}
+	}
+	return 0;
+}
+
 static int r100_cs_track_texture_check(struct radeon_device *rdev,
 				       struct r100_cs_track *track)
 {
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/r200.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/r200.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/r200.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/r200.c	2010-07-05 05:34:27.249868073 +0000
@@ -415,6 +415,8 @@
 		/* 2D, 3D, CUBE */
 		switch (tmp) {
 		case 0:
+		case 3:
+		case 4:
 		case 5:
 		case 6:
 		case 7:
@@ -450,6 +452,7 @@
 		case R200_TXFORMAT_RGB332:
 		case R200_TXFORMAT_Y8:
 			track->textures[i].cpp = 1;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R200_TXFORMAT_AI88:
 		case R200_TXFORMAT_ARGB1555:
@@ -461,6 +464,7 @@
 		case R200_TXFORMAT_DVDU88:
 		case R200_TXFORMAT_AVYU4444:
 			track->textures[i].cpp = 2;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R200_TXFORMAT_ARGB8888:
 		case R200_TXFORMAT_RGBA8888:
@@ -468,6 +472,7 @@
 		case R200_TXFORMAT_BGR111110:
 		case R200_TXFORMAT_LDVDU8888:
 			track->textures[i].cpp = 4;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R200_TXFORMAT_DXT1:
 			track->textures[i].cpp = 1;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/r300.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/r300.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/r300.c	2010-07-05 05:34:21.825807074 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/r300.c	2010-07-05 05:34:27.249868073 +0000
@@ -881,6 +881,7 @@
 		case R300_TX_FORMAT_Y4X4:
 		case R300_TX_FORMAT_Z3Y3X2:
 			track->textures[i].cpp = 1;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R300_TX_FORMAT_X16:
 		case R300_TX_FORMAT_Y8X8:
@@ -892,6 +893,7 @@
 		case R300_TX_FORMAT_B8G8_B8G8:
 		case R300_TX_FORMAT_G8R8_G8B8:
 			track->textures[i].cpp = 2;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R300_TX_FORMAT_Y16X16:
 		case R300_TX_FORMAT_Z11Y11X10:
@@ -902,14 +904,17 @@
 		case R300_TX_FORMAT_FL_I32:
 		case 0x1e:
 			track->textures[i].cpp = 4;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R300_TX_FORMAT_W16Z16Y16X16:
 		case R300_TX_FORMAT_FL_R16G16B16A16:
 		case R300_TX_FORMAT_FL_I32A32:
 			track->textures[i].cpp = 8;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R300_TX_FORMAT_FL_R32G32B32A32:
 			track->textures[i].cpp = 16;
+			track->textures[i].compress_format = R100_TRACK_COMP_NONE;
 			break;
 		case R300_TX_FORMAT_DXT1:
 			track->textures[i].cpp = 1;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/r600.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/r600.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/r600.c	2010-07-05 05:34:21.826805470 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/r600.c	2010-07-05 05:34:27.251868155 +0000
@@ -130,9 +130,14 @@
 							break;
 						}
 					}
-				} else
-					rdev->pm.requested_power_state_index =
-						rdev->pm.current_power_state_index - 1;
+				} else {
+					if (rdev->pm.current_power_state_index == 0)
+						rdev->pm.requested_power_state_index =
+							rdev->pm.num_power_states - 1;
+					else
+						rdev->pm.requested_power_state_index =
+							rdev->pm.current_power_state_index - 1;
+				}
 			}
 			rdev->pm.requested_clock_mode_index = 0;
 			/* don't use the power state if crtcs are active and no display flag is set */
@@ -1097,7 +1102,7 @@
 	WREG32(MC_VM_FB_LOCATION, tmp);
 	WREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));
 	WREG32(HDP_NONSURFACE_INFO, (2 << 7));
-	WREG32(HDP_NONSURFACE_SIZE, rdev->mc.mc_vram_size | 0x3FF);
+	WREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);
 	if (rdev->flags & RADEON_IS_AGP) {
 		WREG32(MC_VM_AGP_TOP, rdev->mc.gtt_end >> 22);
 		WREG32(MC_VM_AGP_BOT, rdev->mc.gtt_start >> 22);
@@ -1219,8 +1224,10 @@
 	rdev->mc.visible_vram_size = rdev->mc.aper_size;
 	r600_vram_gtt_location(rdev, &rdev->mc);
 
-	if (rdev->flags & RADEON_IS_IGP)
+	if (rdev->flags & RADEON_IS_IGP) {
+		rs690_pm_info(rdev);
 		rdev->mc.igp_sideport_enabled = radeon_atombios_sideport_present(rdev);
+	}
 	radeon_update_bandwidth_info(rdev);
 	return 0;
 }
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon.h linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon.h
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon.h	2010-07-05 05:34:21.828805671 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon.h	2010-07-05 05:34:27.252868091 +0000
@@ -177,6 +177,7 @@
 void radeon_combios_get_power_modes(struct radeon_device *rdev);
 void radeon_atombios_get_power_modes(struct radeon_device *rdev);
 void radeon_atom_set_voltage(struct radeon_device *rdev, u16 level);
+void rs690_pm_info(struct radeon_device *rdev);
 
 /*
  * Fences.
@@ -619,7 +620,8 @@
 	DYNPM_STATE_DISABLED,
 	DYNPM_STATE_MINIMUM,
 	DYNPM_STATE_PAUSED,
-	DYNPM_STATE_ACTIVE
+	DYNPM_STATE_ACTIVE,
+	DYNPM_STATE_SUSPENDED,
 };
 enum radeon_dynpm_action {
 	DYNPM_ACTION_NONE,
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_asic.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_asic.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_asic.c	2010-07-05 05:34:21.828805671 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_asic.c	2010-07-05 05:34:27.253868093 +0000
@@ -780,6 +780,13 @@
 	case CHIP_R423:
 	case CHIP_RV410:
 		rdev->asic = &r420_asic;
+		/* handle macs */
+		if (rdev->bios == NULL) {
+			rdev->asic->get_engine_clock = &radeon_legacy_get_engine_clock;
+			rdev->asic->set_engine_clock = &radeon_legacy_set_engine_clock;
+			rdev->asic->get_memory_clock = &radeon_legacy_get_memory_clock;
+			rdev->asic->set_memory_clock = NULL;
+		}
 		break;
 	case CHIP_RS400:
 	case CHIP_RS480:
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_bios.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_bios.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_bios.c	2010-07-05 05:34:21.829805588 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_bios.c	2010-07-05 05:34:27.254868197 +0000
@@ -48,6 +48,10 @@
 	resource_size_t vram_base;
 	resource_size_t size = 256 * 1024; /* ??? */
 
+	if (!(rdev->flags & RADEON_IS_IGP))
+		if (!radeon_card_posted(rdev))
+			return false;
+
 	rdev->bios = NULL;
 	vram_base = drm_get_resource_start(rdev->ddev, 0);
 	bios = ioremap(vram_base, size);
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_combios.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_combios.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_combios.c	2010-07-05 05:34:21.830805553 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_combios.c	2010-07-05 05:34:27.254868197 +0000
@@ -1411,6 +1411,11 @@
 			rdev->mode_info.connector_table = CT_IMAC_G5_ISIGHT;
 		} else
 #endif /* CONFIG_PPC_PMAC */
+#ifdef CONFIG_PPC64
+		if (ASIC_IS_RN50(rdev))
+			rdev->mode_info.connector_table = CT_RN50_POWER;
+		else
+#endif
 			rdev->mode_info.connector_table = CT_GENERIC;
 	}
 
@@ -1853,6 +1858,33 @@
 					    CONNECTOR_OBJECT_ID_SVIDEO,
 					    &hpd);
 		break;
+	case CT_RN50_POWER:
+		DRM_INFO("Connector Table: %d (rn50-power)\n",
+			 rdev->mode_info.connector_table);
+		/* VGA - primary dac */
+		ddc_i2c = combios_setup_i2c_bus(rdev, RADEON_GPIO_VGA_DDC);
+		hpd.hpd = RADEON_HPD_NONE;
+		radeon_add_legacy_encoder(dev,
+					  radeon_get_encoder_id(dev,
+								ATOM_DEVICE_CRT1_SUPPORT,
+								1),
+					  ATOM_DEVICE_CRT1_SUPPORT);
+		radeon_add_legacy_connector(dev, 0, ATOM_DEVICE_CRT1_SUPPORT,
+					    DRM_MODE_CONNECTOR_VGA, &ddc_i2c,
+					    CONNECTOR_OBJECT_ID_VGA,
+					    &hpd);
+		ddc_i2c = combios_setup_i2c_bus(rdev, RADEON_GPIO_CRT2_DDC);
+		hpd.hpd = RADEON_HPD_NONE;
+		radeon_add_legacy_encoder(dev,
+					  radeon_get_encoder_id(dev,
+								ATOM_DEVICE_CRT2_SUPPORT,
+								2),
+					  ATOM_DEVICE_CRT2_SUPPORT);
+		radeon_add_legacy_connector(dev, 1, ATOM_DEVICE_CRT2_SUPPORT,
+					    DRM_MODE_CONNECTOR_VGA, &ddc_i2c,
+					    CONNECTOR_OBJECT_ID_VGA,
+					    &hpd);
+		break;
 	default:
 		DRM_INFO("Connector table: %d (invalid)\n",
 			 rdev->mode_info.connector_table);
@@ -1906,15 +1938,6 @@
 			return false;
 	}
 
-	/* Some RV100 cards with 2 VGA ports show up with DVI+VGA */
-	if (dev->pdev->device == 0x5159 &&
-	    dev->pdev->subsystem_vendor == 0x1002 &&
-	    dev->pdev->subsystem_device == 0x013a) {
-		if (*legacy_connector == CONNECTOR_DVI_I_LEGACY)
-			*legacy_connector = CONNECTOR_CRT_LEGACY;
-
-	}
-
 	/* X300 card with extra non-existent DVI port */
 	if (dev->pdev->device == 0x5B60 &&
 	    dev->pdev->subsystem_vendor == 0x17af &&
@@ -3019,6 +3042,14 @@
 		combios_write_ram_size(dev);
 	}
 
+	/* quirk for rs4xx HP nx6125 laptop to make it resume
+	 * - it hangs on resume inside the dynclk 1 table.
+	 */
+	if (rdev->family == CHIP_RS480 &&
+	    rdev->pdev->subsystem_vendor == 0x103c &&
+	    rdev->pdev->subsystem_device == 0x308b)
+		return;
+
 	/* DYN CLK 1 */
 	table = combios_get_table_offset(dev, COMBIOS_DYN_CLK_1_TABLE);
 	if (table)
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_cursor.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_cursor.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_cursor.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_cursor.c	2010-07-05 05:34:27.255868067 +0000
@@ -194,7 +194,7 @@
 fail:
 	drm_gem_object_unreference_unlocked(obj);
 
-	return 0;
+	return ret;
 }
 
 int radeon_crtc_cursor_move(struct drm_crtc *crtc,
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_device.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_device.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_device.c	2010-07-05 05:34:21.830805553 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_device.c	2010-07-05 05:34:27.255868067 +0000
@@ -779,6 +779,7 @@
 
 int radeon_resume_kms(struct drm_device *dev)
 {
+	struct drm_connector *connector;
 	struct radeon_device *rdev = dev->dev_private;
 
 	if (rdev->powered_down)
@@ -797,6 +798,12 @@
 	radeon_resume(rdev);
 	radeon_pm_resume(rdev);
 	radeon_restore_bios_scratch_regs(rdev);
+
+	/* turn on display hw */
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
+	}
+
 	radeon_fbdev_set_suspend(rdev, 0);
 	release_console_sem();
 
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_encoders.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_encoders.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_encoders.c	2010-07-05 05:34:21.831805573 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_encoders.c	2010-07-05 05:34:27.256868060 +0000
@@ -1072,6 +1072,8 @@
 	if (is_dig) {
 		switch (mode) {
 		case DRM_MODE_DPMS_ON:
+			if (!ASIC_IS_DCE4(rdev))
+				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE_OUTPUT, 0, 0);
 			if (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_DP) {
 				struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 
@@ -1079,8 +1081,6 @@
 				if (ASIC_IS_DCE4(rdev))
 					atombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_ON);
 			}
-			if (!ASIC_IS_DCE4(rdev))
-				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE_OUTPUT, 0, 0);
 			break;
 		case DRM_MODE_DPMS_STANDBY:
 		case DRM_MODE_DPMS_SUSPEND:
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_legacy_encoders.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_legacy_encoders.c	2010-07-05 05:34:21.833805932 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_legacy_encoders.c	2010-07-05 05:34:27.258868514 +0000
@@ -928,16 +928,14 @@
 	if (ASIC_IS_R300(rdev)) {
 		gpiopad_a = RREG32(RADEON_GPIOPAD_A) | 1;
 		disp_output_cntl = RREG32(RADEON_DISP_OUTPUT_CNTL);
-	}
-
-	if (rdev->family == CHIP_R200 || ASIC_IS_R300(rdev))
-		disp_tv_out_cntl = RREG32(RADEON_DISP_TV_OUT_CNTL);
-	else
+	} else if (rdev->family != CHIP_R200)
 		disp_hw_debug = RREG32(RADEON_DISP_HW_DEBUG);
-
-	if (rdev->family == CHIP_R200)
+	else if (rdev->family == CHIP_R200)
 		fp2_gen_cntl = RREG32(RADEON_FP2_GEN_CNTL);
 
+	if (rdev->family >= CHIP_R200)
+		disp_tv_out_cntl = RREG32(RADEON_DISP_TV_OUT_CNTL);
+
 	if (is_tv) {
 		uint32_t dac_cntl;
 
@@ -1002,15 +1000,13 @@
 	if (ASIC_IS_R300(rdev)) {
 		WREG32_P(RADEON_GPIOPAD_A, gpiopad_a, ~1);
 		WREG32(RADEON_DISP_OUTPUT_CNTL, disp_output_cntl);
-	}
+	} else if (rdev->family != CHIP_R200)
+		WREG32(RADEON_DISP_HW_DEBUG, disp_hw_debug);
+	else if (rdev->family == CHIP_R200)
+		WREG32(RADEON_FP2_GEN_CNTL, fp2_gen_cntl);
 
 	if (rdev->family >= CHIP_R200)
 		WREG32(RADEON_DISP_TV_OUT_CNTL, disp_tv_out_cntl);
-	else
-		WREG32(RADEON_DISP_HW_DEBUG, disp_hw_debug);
-
-	if (rdev->family == CHIP_R200)
-		WREG32(RADEON_FP2_GEN_CNTL, fp2_gen_cntl);
 
 	if (is_tv)
 		radeon_legacy_tv_mode_set(encoder, mode, adjusted_mode);
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_mode.h linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_mode.h
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_mode.h	2010-07-05 05:34:21.834805684 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_mode.h	2010-07-05 05:34:27.258868514 +0000
@@ -206,6 +206,7 @@
 	CT_MINI_INTERNAL,
 	CT_IMAC_G5_ISIGHT,
 	CT_EMAC,
+	CT_RN50_POWER,
 };
 
 enum radeon_dvo_chip {
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_pm.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_pm.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/radeon_pm.c	2010-07-05 05:34:21.835805482 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/radeon_pm.c	2010-07-05 05:34:27.259868120 +0000
@@ -397,13 +397,20 @@
 		rdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;
 		mutex_unlock(&rdev->pm.mutex);
 	} else if (strncmp("profile", buf, strlen("profile")) == 0) {
+		bool flush_wq = false;
+
 		mutex_lock(&rdev->pm.mutex);
-		rdev->pm.pm_method = PM_METHOD_PROFILE;
+		if (rdev->pm.pm_method == PM_METHOD_DYNPM) {
+			cancel_delayed_work(&rdev->pm.dynpm_idle_work);
+			flush_wq = true;
+		}
 		/* disable dynpm */
 		rdev->pm.dynpm_state = DYNPM_STATE_DISABLED;
 		rdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;
-		cancel_delayed_work(&rdev->pm.dynpm_idle_work);
+		rdev->pm.pm_method = PM_METHOD_PROFILE;
 		mutex_unlock(&rdev->pm.mutex);
+		if (flush_wq)
+			flush_workqueue(rdev->wq);
 	} else {
 		DRM_ERROR("invalid power method!\n");
 		goto fail;
@@ -418,9 +425,18 @@
 
 void radeon_pm_suspend(struct radeon_device *rdev)
 {
+	bool flush_wq = false;
+
 	mutex_lock(&rdev->pm.mutex);
-	cancel_delayed_work(&rdev->pm.dynpm_idle_work);
+	if (rdev->pm.pm_method == PM_METHOD_DYNPM) {
+		cancel_delayed_work(&rdev->pm.dynpm_idle_work);
+		if (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE)
+			rdev->pm.dynpm_state = DYNPM_STATE_SUSPENDED;
+		flush_wq = true;
+	}
 	mutex_unlock(&rdev->pm.mutex);
+	if (flush_wq)
+		flush_workqueue(rdev->wq);
 }
 
 void radeon_pm_resume(struct radeon_device *rdev)
@@ -432,6 +448,12 @@
 	rdev->pm.current_sclk = rdev->clock.default_sclk;
 	rdev->pm.current_mclk = rdev->clock.default_mclk;
 	rdev->pm.current_vddc = rdev->pm.power_state[rdev->pm.default_power_state_index].clock_info[0].voltage.voltage;
+	if (rdev->pm.pm_method == PM_METHOD_DYNPM
+	    && rdev->pm.dynpm_state == DYNPM_STATE_SUSPENDED) {
+		rdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;
+		queue_delayed_work(rdev->wq, &rdev->pm.dynpm_idle_work,
+					msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
+	}
 	mutex_unlock(&rdev->pm.mutex);
 	radeon_pm_compute_clocks(rdev);
 }
@@ -486,6 +508,8 @@
 void radeon_pm_fini(struct radeon_device *rdev)
 {
 	if (rdev->pm.num_power_states > 1) {
+		bool flush_wq = false;
+
 		mutex_lock(&rdev->pm.mutex);
 		if (rdev->pm.pm_method == PM_METHOD_PROFILE) {
 			rdev->pm.profile = PM_PROFILE_DEFAULT;
@@ -493,13 +517,16 @@
 			radeon_pm_set_clocks(rdev);
 		} else if (rdev->pm.pm_method == PM_METHOD_DYNPM) {
 			/* cancel work */
-			cancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);
+			cancel_delayed_work(&rdev->pm.dynpm_idle_work);
+			flush_wq = true;
 			/* reset default clocks */
 			rdev->pm.dynpm_state = DYNPM_STATE_DISABLED;
 			rdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;
 			radeon_pm_set_clocks(rdev);
 		}
 		mutex_unlock(&rdev->pm.mutex);
+		if (flush_wq)
+			flush_workqueue(rdev->wq);
 
 		device_remove_file(rdev->dev, &dev_attr_power_profile);
 		device_remove_file(rdev->dev, &dev_attr_power_method);
@@ -720,12 +747,12 @@
 			radeon_pm_get_dynpm_state(rdev);
 			radeon_pm_set_clocks(rdev);
 		}
+
+		queue_delayed_work(rdev->wq, &rdev->pm.dynpm_idle_work,
+					msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
 	}
 	mutex_unlock(&rdev->pm.mutex);
 	ttm_bo_unlock_delayed_workqueue(&rdev->mman.bdev, resched);
-
-	queue_delayed_work(rdev->wq, &rdev->pm.dynpm_idle_work,
-					msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
 }
 
 /*
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/reg_srcs/evergreen linux-2.6.35-rc4/drivers/gpu/drm/radeon/reg_srcs/evergreen
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/reg_srcs/evergreen	2010-07-05 05:34:21.837805766 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/reg_srcs/evergreen	2010-07-05 05:34:27.261868058 +0000
@@ -80,8 +80,8 @@
 0x00028010 DB_RENDER_OVERRIDE2
 0x00028028 DB_STENCIL_CLEAR
 0x0002802C DB_DEPTH_CLEAR
-0x00028034 PA_SC_SCREEN_SCISSOR_BR
 0x00028030 PA_SC_SCREEN_SCISSOR_TL
+0x00028034 PA_SC_SCREEN_SCISSOR_BR
 0x0002805C DB_DEPTH_SLICE
 0x00028140 SQ_ALU_CONST_BUFFER_SIZE_PS_0
 0x00028144 SQ_ALU_CONST_BUFFER_SIZE_PS_1
@@ -460,8 +460,8 @@
 0x00028844 SQ_PGM_RESOURCES_PS
 0x00028848 SQ_PGM_RESOURCES_2_PS
 0x0002884C SQ_PGM_EXPORTS_PS
-0x0002885C SQ_PGM_RESOURCES_VS
-0x00028860 SQ_PGM_RESOURCES_2_VS
+0x00028860 SQ_PGM_RESOURCES_VS
+0x00028864 SQ_PGM_RESOURCES_2_VS
 0x00028878 SQ_PGM_RESOURCES_GS
 0x0002887C SQ_PGM_RESOURCES_2_GS
 0x00028890 SQ_PGM_RESOURCES_ES
@@ -469,8 +469,8 @@
 0x000288A8 SQ_PGM_RESOURCES_FS
 0x000288BC SQ_PGM_RESOURCES_HS
 0x000288C0 SQ_PGM_RESOURCES_2_HS
-0x000288D0 SQ_PGM_RESOURCES_LS
-0x000288D4 SQ_PGM_RESOURCES_2_LS
+0x000288D4 SQ_PGM_RESOURCES_LS
+0x000288D8 SQ_PGM_RESOURCES_2_LS
 0x000288E8 SQ_LDS_ALLOC
 0x000288EC SQ_LDS_ALLOC_PS
 0x000288F0 SQ_VTX_SEMANTIC_CLEAR
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/rs690.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/rs690.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/rs690.c	2010-07-05 05:34:21.838805636 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/rs690.c	2010-07-05 05:34:27.263868050 +0000
@@ -79,7 +79,13 @@
 			tmp.full = dfixed_const(100);
 			rdev->pm.igp_sideport_mclk.full = dfixed_const(info->info.ulBootUpMemoryClock);
 			rdev->pm.igp_sideport_mclk.full = dfixed_div(rdev->pm.igp_sideport_mclk, tmp);
-			rdev->pm.igp_system_mclk.full = dfixed_const(le16_to_cpu(info->info.usK8MemoryClock));
+			if (info->info.usK8MemoryClock)
+				rdev->pm.igp_system_mclk.full = dfixed_const(le16_to_cpu(info->info.usK8MemoryClock));
+			else if (rdev->clock.default_mclk) {
+				rdev->pm.igp_system_mclk.full = dfixed_const(rdev->clock.default_mclk);
+				rdev->pm.igp_system_mclk.full = dfixed_div(rdev->pm.igp_system_mclk, tmp);
+			} else
+				rdev->pm.igp_system_mclk.full = dfixed_const(400);
 			rdev->pm.igp_ht_link_clk.full = dfixed_const(le16_to_cpu(info->info.usFSBClock));
 			rdev->pm.igp_ht_link_width.full = dfixed_const(info->info.ucHTLinkWidth);
 			break;
@@ -87,34 +93,31 @@
 			tmp.full = dfixed_const(100);
 			rdev->pm.igp_sideport_mclk.full = dfixed_const(info->info_v2.ulBootUpSidePortClock);
 			rdev->pm.igp_sideport_mclk.full = dfixed_div(rdev->pm.igp_sideport_mclk, tmp);
-			rdev->pm.igp_system_mclk.full = dfixed_const(info->info_v2.ulBootUpUMAClock);
+			if (info->info_v2.ulBootUpUMAClock)
+				rdev->pm.igp_system_mclk.full = dfixed_const(info->info_v2.ulBootUpUMAClock);
+			else if (rdev->clock.default_mclk)
+				rdev->pm.igp_system_mclk.full = dfixed_const(rdev->clock.default_mclk);
+			else
+				rdev->pm.igp_system_mclk.full = dfixed_const(66700);
 			rdev->pm.igp_system_mclk.full = dfixed_div(rdev->pm.igp_system_mclk, tmp);
 			rdev->pm.igp_ht_link_clk.full = dfixed_const(info->info_v2.ulHTLinkFreq);
 			rdev->pm.igp_ht_link_clk.full = dfixed_div(rdev->pm.igp_ht_link_clk, tmp);
 			rdev->pm.igp_ht_link_width.full = dfixed_const(le16_to_cpu(info->info_v2.usMinHTLinkWidth));
 			break;
 		default:
-			tmp.full = dfixed_const(100);
 			/* We assume the slower possible clock ie worst case */
-			/* DDR 333Mhz */
-			rdev->pm.igp_sideport_mclk.full = dfixed_const(333);
-			/* FIXME: system clock ? */
-			rdev->pm.igp_system_mclk.full = dfixed_const(100);
-			rdev->pm.igp_system_mclk.full = dfixed_div(rdev->pm.igp_system_mclk, tmp);
-			rdev->pm.igp_ht_link_clk.full = dfixed_const(200);
+			rdev->pm.igp_sideport_mclk.full = dfixed_const(200);
+			rdev->pm.igp_system_mclk.full = dfixed_const(200);
+			rdev->pm.igp_ht_link_clk.full = dfixed_const(1000);
 			rdev->pm.igp_ht_link_width.full = dfixed_const(8);
 			DRM_ERROR("No integrated system info for your GPU, using safe default\n");
 			break;
 		}
 	} else {
-		tmp.full = dfixed_const(100);
 		/* We assume the slower possible clock ie worst case */
-		/* DDR 333Mhz */
-		rdev->pm.igp_sideport_mclk.full = dfixed_const(333);
-		/* FIXME: system clock ? */
-		rdev->pm.igp_system_mclk.full = dfixed_const(100);
-		rdev->pm.igp_system_mclk.full = dfixed_div(rdev->pm.igp_system_mclk, tmp);
-		rdev->pm.igp_ht_link_clk.full = dfixed_const(200);
+		rdev->pm.igp_sideport_mclk.full = dfixed_const(200);
+		rdev->pm.igp_system_mclk.full = dfixed_const(200);
+		rdev->pm.igp_ht_link_clk.full = dfixed_const(1000);
 		rdev->pm.igp_ht_link_width.full = dfixed_const(8);
 		DRM_ERROR("No integrated system info for your GPU, using safe default\n");
 	}
@@ -228,10 +231,6 @@
 	fixed20_12 a, b, c;
 	fixed20_12 pclk, request_fifo_depth, tolerable_latency, estimated_width;
 	fixed20_12 consumption_time, line_time, chunk_time, read_delay_latency;
-	/* FIXME: detect IGP with sideport memory, i don't think there is any
-	 * such product available
-	 */
-	bool sideport = false;
 
 	if (!crtc->base.enabled) {
 		/* FIXME: wouldn't it better to set priority mark to maximum */
@@ -300,7 +299,7 @@
 
 	/* Maximun bandwidth is the minimun bandwidth of all component */
 	rdev->pm.max_bandwidth = rdev->pm.core_bandwidth;
-	if (sideport) {
+	if (rdev->mc.igp_sideport_enabled) {
 		if (rdev->pm.max_bandwidth.full > rdev->pm.sideport_bandwidth.full &&
 			rdev->pm.sideport_bandwidth.full)
 			rdev->pm.max_bandwidth = rdev->pm.sideport_bandwidth;
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/radeon/rv770.c linux-2.6.35-rc4/drivers/gpu/drm/radeon/rv770.c
--- linux-2.6.35-rc3/drivers/gpu/drm/radeon/rv770.c	2010-07-05 05:34:21.839805493 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/radeon/rv770.c	2010-07-05 05:34:27.264868082 +0000
@@ -224,7 +224,7 @@
 	WREG32(MC_VM_FB_LOCATION, tmp);
 	WREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));
 	WREG32(HDP_NONSURFACE_INFO, (2 << 7));
-	WREG32(HDP_NONSURFACE_SIZE, (rdev->mc.mc_vram_size - 1) | 0x3FF);
+	WREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);
 	if (rdev->flags & RADEON_IS_AGP) {
 		WREG32(MC_VM_AGP_TOP, rdev->mc.gtt_end >> 16);
 		WREG32(MC_VM_AGP_BOT, rdev->mc.gtt_start >> 16);
diff -urN linux-2.6.35-rc3/drivers/gpu/drm/ttm/ttm_page_alloc.c linux-2.6.35-rc4/drivers/gpu/drm/ttm/ttm_page_alloc.c
--- linux-2.6.35-rc3/drivers/gpu/drm/ttm/ttm_page_alloc.c	2010-07-05 05:34:21.841805496 +0000
+++ linux-2.6.35-rc4/drivers/gpu/drm/ttm/ttm_page_alloc.c	2010-07-05 05:34:27.265868090 +0000
@@ -667,7 +667,7 @@
 {
 	struct ttm_page_pool *pool = ttm_get_pool(flags, cstate);
 	struct page *p = NULL;
-	int gfp_flags = 0;
+	int gfp_flags = GFP_USER;
 	int r;
 
 	/* set zero flag for page allocation if required */
diff -urN linux-2.6.35-rc3/drivers/hwmon/i5k_amb.c linux-2.6.35-rc4/drivers/hwmon/i5k_amb.c
--- linux-2.6.35-rc3/drivers/hwmon/i5k_amb.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/hwmon/i5k_amb.c	2010-07-05 05:34:27.280868073 +0000
@@ -289,6 +289,7 @@
 			iattr->s_attr.dev_attr.attr.mode = S_IRUGO;
 			iattr->s_attr.dev_attr.show = show_label;
 			iattr->s_attr.index = k;
+			sysfs_attr_init(&iattr->s_attr.dev_attr.attr);
 			res = device_create_file(&pdev->dev,
 						 &iattr->s_attr.dev_attr);
 			if (res)
@@ -303,6 +304,7 @@
 			iattr->s_attr.dev_attr.attr.mode = S_IRUGO;
 			iattr->s_attr.dev_attr.show = show_amb_temp;
 			iattr->s_attr.index = k;
+			sysfs_attr_init(&iattr->s_attr.dev_attr.attr);
 			res = device_create_file(&pdev->dev,
 						 &iattr->s_attr.dev_attr);
 			if (res)
@@ -318,6 +320,7 @@
 			iattr->s_attr.dev_attr.show = show_amb_min;
 			iattr->s_attr.dev_attr.store = store_amb_min;
 			iattr->s_attr.index = k;
+			sysfs_attr_init(&iattr->s_attr.dev_attr.attr);
 			res = device_create_file(&pdev->dev,
 						 &iattr->s_attr.dev_attr);
 			if (res)
@@ -333,6 +336,7 @@
 			iattr->s_attr.dev_attr.show = show_amb_mid;
 			iattr->s_attr.dev_attr.store = store_amb_mid;
 			iattr->s_attr.index = k;
+			sysfs_attr_init(&iattr->s_attr.dev_attr.attr);
 			res = device_create_file(&pdev->dev,
 						 &iattr->s_attr.dev_attr);
 			if (res)
@@ -348,6 +352,7 @@
 			iattr->s_attr.dev_attr.show = show_amb_max;
 			iattr->s_attr.dev_attr.store = store_amb_max;
 			iattr->s_attr.index = k;
+			sysfs_attr_init(&iattr->s_attr.dev_attr.attr);
 			res = device_create_file(&pdev->dev,
 						 &iattr->s_attr.dev_attr);
 			if (res)
@@ -362,6 +367,7 @@
 			iattr->s_attr.dev_attr.attr.mode = S_IRUGO;
 			iattr->s_attr.dev_attr.show = show_amb_alarm;
 			iattr->s_attr.index = k;
+			sysfs_attr_init(&iattr->s_attr.dev_attr.attr);
 			res = device_create_file(&pdev->dev,
 						 &iattr->s_attr.dev_attr);
 			if (res)
diff -urN linux-2.6.35-rc3/drivers/hwmon/k10temp.c linux-2.6.35-rc4/drivers/hwmon/k10temp.c
--- linux-2.6.35-rc3/drivers/hwmon/k10temp.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/hwmon/k10temp.c	2010-07-05 05:34:27.280868073 +0000
@@ -112,11 +112,21 @@
 	if (pkg_type != CPUID_PKGTYPE_AM2R2_AM3)
 		return false;
 
-	/* Differentiate between AM2+ (bad) and AM3 (good) */
+	/* DDR3 memory implies socket AM3, which is good */
 	pci_bus_read_config_dword(pdev->bus,
 				  PCI_DEVFN(PCI_SLOT(pdev->devfn), 2),
 				  REG_DCT0_CONFIG_HIGH, &reg_dram_cfg);
-	return !(reg_dram_cfg & DDR3_MODE);
+	if (reg_dram_cfg & DDR3_MODE)
+		return false;
+
+	/*
+	 * Unfortunately it is possible to run a socket AM3 CPU with DDR2
+	 * memory. We blacklist all the cores which do exist in socket AM2+
+	 * format. It still isn't perfect, as RB-C2 cores exist in both AM2+
+	 * and AM3 formats, but that's the best we can do.
+	 */
+	return boot_cpu_data.x86_model < 4 ||
+	       (boot_cpu_data.x86_model == 4 && boot_cpu_data.x86_mask <= 2);
 }
 
 static int __devinit k10temp_probe(struct pci_dev *pdev,
diff -urN linux-2.6.35-rc3/drivers/hwmon/k8temp.c linux-2.6.35-rc4/drivers/hwmon/k8temp.c
--- linux-2.6.35-rc3/drivers/hwmon/k8temp.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/hwmon/k8temp.c	2010-07-05 05:34:27.280868073 +0000
@@ -120,7 +120,7 @@
 	int temp;
 	struct k8temp_data *data = k8temp_update_device(dev);
 
-	if (data->swap_core_select)
+	if (data->swap_core_select && (data->sensorsp & SEL_CORE))
 		core = core ? 0 : 1;
 
 	temp = TEMP_FROM_REG(data->temp[core][place]) + data->temp_offset;
diff -urN linux-2.6.35-rc3/drivers/input/keyboard/Kconfig linux-2.6.35-rc4/drivers/input/keyboard/Kconfig
--- linux-2.6.35-rc3/drivers/input/keyboard/Kconfig	2010-07-05 05:34:21.946868647 +0000
+++ linux-2.6.35-rc4/drivers/input/keyboard/Kconfig	2010-07-05 05:34:27.344868069 +0000
@@ -69,7 +69,7 @@
 	  module will be called atakbd.
 
 config KEYBOARD_ATKBD
-	tristate "AT keyboard" if EMBEDDED || !X86
+	tristate "AT keyboard" if EMBEDDED || !X86 || X86_MRST
 	default y
 	select SERIO
 	select SERIO_LIBPS2
diff -urN linux-2.6.35-rc3/drivers/input/misc/pcf8574_keypad.c linux-2.6.35-rc4/drivers/input/misc/pcf8574_keypad.c
--- linux-2.6.35-rc3/drivers/input/misc/pcf8574_keypad.c	2010-07-05 05:34:21.953868477 +0000
+++ linux-2.6.35-rc4/drivers/input/misc/pcf8574_keypad.c	2010-07-05 05:34:27.349805316 +0000
@@ -69,7 +69,7 @@
 	unsigned char nextstate = read_state(lp);
 
 	if (lp->laststate != nextstate) {
-		int key_down = nextstate <= ARRAY_SIZE(lp->btncode);
+		int key_down = nextstate < ARRAY_SIZE(lp->btncode);
 		unsigned short keycode = key_down ?
 			lp->btncode[nextstate] : lp->btncode[lp->laststate];
 
diff -urN linux-2.6.35-rc3/drivers/input/serio/Kconfig linux-2.6.35-rc4/drivers/input/serio/Kconfig
--- linux-2.6.35-rc3/drivers/input/serio/Kconfig	2010-07-05 05:34:21.958805729 +0000
+++ linux-2.6.35-rc4/drivers/input/serio/Kconfig	2010-07-05 05:34:27.352868025 +0000
@@ -22,7 +22,7 @@
 	tristate "i8042 PC Keyboard controller" if EMBEDDED || !X86
 	default y
 	depends on !PARISC && (!ARM || ARCH_SHARK || FOOTBRIDGE_HOST) && \
-		   (!SUPERH || SH_CAYMAN) && !M68K && !BLACKFIN
+		   (!SUPERH || SH_CAYMAN) && !M68K && !BLACKFIN && !X86_MRST
 	help
 	  i8042 is the chip over which the standard AT keyboard and PS/2
 	  mouse are connected to the computer. If you use these devices,
diff -urN linux-2.6.35-rc3/drivers/input/tablet/wacom_wac.c linux-2.6.35-rc4/drivers/input/tablet/wacom_wac.c
--- linux-2.6.35-rc3/drivers/input/tablet/wacom_wac.c	2010-07-05 05:34:21.963868346 +0000
+++ linux-2.6.35-rc4/drivers/input/tablet/wacom_wac.c	2010-07-05 05:34:27.355868050 +0000
@@ -284,12 +284,13 @@
 			(data[4] << 20) + (data[5] << 12) +
 			(data[6] << 4) + (data[7] >> 4);
 
-		wacom->id[idx] = (data[2] << 4) | (data[3] >> 4);
+		wacom->id[idx] = (data[2] << 4) | (data[3] >> 4) |
+			((data[7] & 0x0f) << 20) | ((data[8] & 0xf0) << 12);
 
-		switch (wacom->id[idx]) {
+		switch (wacom->id[idx] & 0xfffff) {
 		case 0x812: /* Inking pen */
 		case 0x801: /* Intuos3 Inking pen */
-		case 0x20802: /* Intuos4 Classic Pen */
+		case 0x20802: /* Intuos4 Inking Pen */
 		case 0x012:
 			wacom->tool[idx] = BTN_TOOL_PENCIL;
 			break;
@@ -513,7 +514,7 @@
 			input_report_abs(input, ABS_RX, ((data[1] & 0x1f) << 8) | data[2]);
 			input_report_abs(input, ABS_RY, ((data[3] & 0x1f) << 8) | data[4]);
 
-			if ((data[5] & 0x1f) | (data[6] & 0x1f) | (data[1] & 0x1f) |
+			if ((data[5] & 0x1f) | data[6] | (data[1] & 0x1f) |
 				data[2] | (data[3] & 0x1f) | data[4] | data[8] |
 				(data[7] & 0x01)) {
 				input_report_key(input, wacom->tool[1], 1);
diff -urN linux-2.6.35-rc3/drivers/input/touchscreen/ad7877.c linux-2.6.35-rc4/drivers/input/touchscreen/ad7877.c
--- linux-2.6.35-rc3/drivers/input/touchscreen/ad7877.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/input/touchscreen/ad7877.c	2010-07-05 05:34:27.356868055 +0000
@@ -679,6 +679,13 @@
 		return -EINVAL;
 	}
 
+	spi->bits_per_word = 16;
+	err = spi_setup(spi);
+	if (err) {
+		dev_dbg(&spi->dev, "spi master doesn't support 16 bits/word\n");
+		return err;
+	}
+
 	ts = kzalloc(sizeof(struct ad7877), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!ts || !input_dev) {
diff -urN linux-2.6.35-rc3/drivers/isdn/gigaset/asyncdata.c linux-2.6.35-rc4/drivers/isdn/gigaset/asyncdata.c
--- linux-2.6.35-rc3/drivers/isdn/gigaset/asyncdata.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/isdn/gigaset/asyncdata.c	2010-07-05 05:34:27.359873011 +0000
@@ -126,26 +126,6 @@
 	return numbytes;
 }
 
-/* set up next receive skb for data mode
- */
-static void new_rcv_skb(struct bc_state *bcs)
-{
-	struct cardstate *cs = bcs->cs;
-	unsigned short hw_hdr_len = cs->hw_hdr_len;
-
-	if (bcs->ignore) {
-		bcs->skb = NULL;
-		return;
-	}
-
-	bcs->skb = dev_alloc_skb(SBUFSIZE + hw_hdr_len);
-	if (bcs->skb == NULL) {
-		dev_warn(cs->dev, "could not allocate new skb\n");
-		return;
-	}
-	skb_reserve(bcs->skb, hw_hdr_len);
-}
-
 /* process a block of received bytes in HDLC data mode
  * (mstate != MS_LOCKED && !(inputstate & INS_command) && proto2 == L2_HDLC)
  * Collect HDLC frames, undoing byte stuffing and watching for DLE escapes.
@@ -159,8 +139,8 @@
 	struct cardstate *cs = inbuf->cs;
 	struct bc_state *bcs = cs->bcs;
 	int inputstate = bcs->inputstate;
-	__u16 fcs = bcs->fcs;
-	struct sk_buff *skb = bcs->skb;
+	__u16 fcs = bcs->rx_fcs;
+	struct sk_buff *skb = bcs->rx_skb;
 	unsigned char *src = inbuf->data + inbuf->head;
 	unsigned procbytes = 0;
 	unsigned char c;
@@ -245,8 +225,7 @@
 
 				/* prepare reception of next frame */
 				inputstate &= ~INS_have_data;
-				new_rcv_skb(bcs);
-				skb = bcs->skb;
+				skb = gigaset_new_rx_skb(bcs);
 			} else {
 				/* empty frame (7E 7E) */
 #ifdef CONFIG_GIGASET_DEBUG
@@ -255,8 +234,7 @@
 				if (!skb) {
 					/* skipped (?) */
 					gigaset_isdn_rcv_err(bcs);
-					new_rcv_skb(bcs);
-					skb = bcs->skb;
+					skb = gigaset_new_rx_skb(bcs);
 				}
 			}
 
@@ -279,11 +257,11 @@
 #endif
 		inputstate |= INS_have_data;
 		if (skb) {
-			if (skb->len == SBUFSIZE) {
+			if (skb->len >= bcs->rx_bufsize) {
 				dev_warn(cs->dev, "received packet too long\n");
 				dev_kfree_skb_any(skb);
 				/* skip remainder of packet */
-				bcs->skb = skb = NULL;
+				bcs->rx_skb = skb = NULL;
 			} else {
 				*__skb_put(skb, 1) = c;
 				fcs = crc_ccitt_byte(fcs, c);
@@ -292,7 +270,7 @@
 	}
 
 	bcs->inputstate = inputstate;
-	bcs->fcs = fcs;
+	bcs->rx_fcs = fcs;
 	return procbytes;
 }
 
@@ -308,18 +286,18 @@
 	struct cardstate *cs = inbuf->cs;
 	struct bc_state *bcs = cs->bcs;
 	int inputstate = bcs->inputstate;
-	struct sk_buff *skb = bcs->skb;
+	struct sk_buff *skb = bcs->rx_skb;
 	unsigned char *src = inbuf->data + inbuf->head;
 	unsigned procbytes = 0;
 	unsigned char c;
 
 	if (!skb) {
 		/* skip this block */
-		new_rcv_skb(bcs);
+		gigaset_new_rx_skb(bcs);
 		return numbytes;
 	}
 
-	while (procbytes < numbytes && skb->len < SBUFSIZE) {
+	while (procbytes < numbytes && skb->len < bcs->rx_bufsize) {
 		c = *src++;
 		procbytes++;
 
@@ -343,7 +321,7 @@
 	if (inputstate & INS_have_data) {
 		gigaset_skb_rcvd(bcs, skb);
 		inputstate &= ~INS_have_data;
-		new_rcv_skb(bcs);
+		gigaset_new_rx_skb(bcs);
 	}
 
 	bcs->inputstate = inputstate;
diff -urN linux-2.6.35-rc3/drivers/isdn/gigaset/capi.c linux-2.6.35-rc4/drivers/isdn/gigaset/capi.c
--- linux-2.6.35-rc3/drivers/isdn/gigaset/capi.c	2010-07-05 05:34:21.968868585 +0000
+++ linux-2.6.35-rc4/drivers/isdn/gigaset/capi.c	2010-07-05 05:34:27.360868105 +0000
@@ -70,7 +70,7 @@
 #define MAX_NUMBER_DIGITS 20
 #define MAX_FMT_IE_LEN 20
 
-/* values for gigaset_capi_appl.connected */
+/* values for bcs->apconnstate */
 #define APCONN_NONE	0	/* inactive/listening */
 #define APCONN_SETUP	1	/* connecting */
 #define APCONN_ACTIVE	2	/* B channel up */
@@ -80,10 +80,10 @@
 	struct list_head ctrlist;
 	struct gigaset_capi_appl *bcnext;
 	u16 id;
+	struct capi_register_params rp;
 	u16 nextMessageNumber;
 	u32 listenInfoMask;
 	u32 listenCIPmask;
-	int connected;
 };
 
 /* CAPI specific controller data structure */
@@ -319,6 +319,39 @@
 	return result;
 }
 
+/*
+ * emit DATA_B3_CONF message
+ */
+static void send_data_b3_conf(struct cardstate *cs, struct capi_ctr *ctr,
+			      u16 appl, u16 msgid, int channel,
+			      u16 handle, u16 info)
+{
+	struct sk_buff *cskb;
+	u8 *msg;
+
+	cskb = alloc_skb(CAPI_DATA_B3_CONF_LEN, GFP_ATOMIC);
+	if (!cskb) {
+		dev_err(cs->dev, "%s: out of memory\n", __func__);
+		return;
+	}
+	/* frequent message, avoid _cmsg overhead */
+	msg = __skb_put(cskb, CAPI_DATA_B3_CONF_LEN);
+	CAPIMSG_SETLEN(msg, CAPI_DATA_B3_CONF_LEN);
+	CAPIMSG_SETAPPID(msg, appl);
+	CAPIMSG_SETCOMMAND(msg, CAPI_DATA_B3);
+	CAPIMSG_SETSUBCOMMAND(msg,  CAPI_CONF);
+	CAPIMSG_SETMSGID(msg, msgid);
+	CAPIMSG_SETCONTROLLER(msg, ctr->cnr);
+	CAPIMSG_SETPLCI_PART(msg, channel);
+	CAPIMSG_SETNCCI_PART(msg, 1);
+	CAPIMSG_SETHANDLE_CONF(msg, handle);
+	CAPIMSG_SETINFO_CONF(msg, info);
+
+	/* emit message */
+	dump_rawmsg(DEBUG_MCMD, __func__, msg);
+	capi_ctr_handle_message(ctr, appl, cskb);
+}
+
 
 /*
  * driver interface functions
@@ -339,7 +372,6 @@
 	struct gigaset_capi_ctr *iif = cs->iif;
 	struct gigaset_capi_appl *ap = bcs->ap;
 	unsigned char *req = skb_mac_header(dskb);
-	struct sk_buff *cskb;
 	u16 flags;
 
 	/* update statistics */
@@ -351,39 +383,22 @@
 	}
 
 	/* don't send further B3 messages if disconnected */
-	if (ap->connected < APCONN_ACTIVE) {
+	if (bcs->apconnstate < APCONN_ACTIVE) {
 		gig_dbg(DEBUG_LLDATA, "disconnected, discarding ack");
 		return;
 	}
 
-	/* ToDo: honor unset "delivery confirmation" bit */
+	/*
+	 * send DATA_B3_CONF if "delivery confirmation" bit was set in request;
+	 * otherwise it has already been sent by do_data_b3_req()
+	 */
 	flags = CAPIMSG_FLAGS(req);
-
-	/* build DATA_B3_CONF message */
-	cskb = alloc_skb(CAPI_DATA_B3_CONF_LEN, GFP_ATOMIC);
-	if (!cskb) {
-		dev_err(cs->dev, "%s: out of memory\n", __func__);
-		return;
-	}
-	/* frequent message, avoid _cmsg overhead */
-	CAPIMSG_SETLEN(cskb->data, CAPI_DATA_B3_CONF_LEN);
-	CAPIMSG_SETAPPID(cskb->data, ap->id);
-	CAPIMSG_SETCOMMAND(cskb->data, CAPI_DATA_B3);
-	CAPIMSG_SETSUBCOMMAND(cskb->data,  CAPI_CONF);
-	CAPIMSG_SETMSGID(cskb->data, CAPIMSG_MSGID(req));
-	CAPIMSG_SETCONTROLLER(cskb->data, iif->ctr.cnr);
-	CAPIMSG_SETPLCI_PART(cskb->data, bcs->channel + 1);
-	CAPIMSG_SETNCCI_PART(cskb->data, 1);
-	CAPIMSG_SETHANDLE_CONF(cskb->data, CAPIMSG_HANDLE_REQ(req));
-	if (flags & ~CAPI_FLAGS_DELIVERY_CONFIRMATION)
-		CAPIMSG_SETINFO_CONF(cskb->data,
-				     CapiFlagsNotSupportedByProtocol);
-	else
-		CAPIMSG_SETINFO_CONF(cskb->data, CAPI_NOERROR);
-
-	/* emit message */
-	dump_rawmsg(DEBUG_LLDATA, "DATA_B3_CONF", cskb->data);
-	capi_ctr_handle_message(&iif->ctr, ap->id, cskb);
+	if (flags & CAPI_FLAGS_DELIVERY_CONFIRMATION)
+		send_data_b3_conf(cs, &iif->ctr, ap->id, CAPIMSG_MSGID(req),
+				  bcs->channel + 1, CAPIMSG_HANDLE_REQ(req),
+				  (flags & ~CAPI_FLAGS_DELIVERY_CONFIRMATION) ?
+					CapiFlagsNotSupportedByProtocol :
+					CAPI_NOERROR);
 }
 EXPORT_SYMBOL_GPL(gigaset_skb_sent);
 
@@ -412,7 +427,7 @@
 	}
 
 	/* don't send further B3 messages if disconnected */
-	if (ap->connected < APCONN_ACTIVE) {
+	if (bcs->apconnstate < APCONN_ACTIVE) {
 		gig_dbg(DEBUG_LLDATA, "disconnected, discarding data");
 		dev_kfree_skb_any(skb);
 		return;
@@ -484,6 +499,7 @@
 	u32 actCIPmask;
 	struct sk_buff *skb;
 	unsigned int msgsize;
+	unsigned long flags;
 	int i;
 
 	/*
@@ -608,7 +624,14 @@
 		format_ie(iif->hcmsg.CalledPartyNumber));
 
 	/* scan application list for matching listeners */
-	bcs->ap = NULL;
+	spin_lock_irqsave(&bcs->aplock, flags);
+	if (bcs->ap != NULL || bcs->apconnstate != APCONN_NONE) {
+		dev_warn(cs->dev, "%s: channel not properly cleared (%p/%d)\n",
+			 __func__, bcs->ap, bcs->apconnstate);
+		bcs->ap = NULL;
+		bcs->apconnstate = APCONN_NONE;
+	}
+	spin_unlock_irqrestore(&bcs->aplock, flags);
 	actCIPmask = 1 | (1 << iif->hcmsg.CIPValue);
 	list_for_each_entry(ap, &iif->appls, ctrlist)
 		if (actCIPmask & ap->listenCIPmask) {
@@ -626,10 +649,12 @@
 			dump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);
 
 			/* add to listeners on this B channel, update state */
+			spin_lock_irqsave(&bcs->aplock, flags);
 			ap->bcnext = bcs->ap;
 			bcs->ap = ap;
 			bcs->chstate |= CHS_NOTIFY_LL;
-			ap->connected = APCONN_SETUP;
+			bcs->apconnstate = APCONN_SETUP;
+			spin_unlock_irqrestore(&bcs->aplock, flags);
 
 			/* emit message */
 			capi_ctr_handle_message(&iif->ctr, ap->id, skb);
@@ -654,7 +679,7 @@
 	struct gigaset_capi_ctr *iif = cs->iif;
 	struct sk_buff *skb;
 
-	if (ap->connected == APCONN_NONE)
+	if (bcs->apconnstate == APCONN_NONE)
 		return;
 
 	capi_cmsg_header(&iif->hcmsg, ap->id, CAPI_DISCONNECT, CAPI_IND,
@@ -668,7 +693,6 @@
 	}
 	capi_cmsg2message(&iif->hcmsg, __skb_put(skb, CAPI_DISCONNECT_IND_LEN));
 	dump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);
-	ap->connected = APCONN_NONE;
 	capi_ctr_handle_message(&iif->ctr, ap->id, skb);
 }
 
@@ -685,9 +709,9 @@
 	struct sk_buff *skb;
 
 	/* nothing to do if no logical connection active */
-	if (ap->connected < APCONN_ACTIVE)
+	if (bcs->apconnstate < APCONN_ACTIVE)
 		return;
-	ap->connected = APCONN_SETUP;
+	bcs->apconnstate = APCONN_SETUP;
 
 	capi_cmsg_header(&iif->hcmsg, ap->id, CAPI_DISCONNECT_B3, CAPI_IND,
 			 ap->nextMessageNumber++,
@@ -714,14 +738,25 @@
 {
 	struct cardstate *cs = bcs->cs;
 	struct gigaset_capi_ctr *iif = cs->iif;
-	struct gigaset_capi_appl *ap = bcs->ap;
+	struct gigaset_capi_appl *ap;
 	struct sk_buff *skb;
 	unsigned int msgsize;
+	unsigned long flags;
 
+	spin_lock_irqsave(&bcs->aplock, flags);
+	ap = bcs->ap;
 	if (!ap) {
+		spin_unlock_irqrestore(&bcs->aplock, flags);
 		dev_err(cs->dev, "%s: no application\n", __func__);
 		return;
 	}
+	if (bcs->apconnstate == APCONN_NONE) {
+		spin_unlock_irqrestore(&bcs->aplock, flags);
+		dev_warn(cs->dev, "%s: application %u not connected\n",
+			 __func__, ap->id);
+		return;
+	}
+	spin_unlock_irqrestore(&bcs->aplock, flags);
 	while (ap->bcnext) {
 		/* this should never happen */
 		dev_warn(cs->dev, "%s: dropping extra application %u\n",
@@ -730,11 +765,6 @@
 				    CapiCallGivenToOtherApplication);
 		ap->bcnext = ap->bcnext->bcnext;
 	}
-	if (ap->connected == APCONN_NONE) {
-		dev_warn(cs->dev, "%s: application %u not connected\n",
-			 __func__, ap->id);
-		return;
-	}
 
 	/* prepare CONNECT_ACTIVE_IND message
 	 * Note: LLC not supported by device
@@ -772,17 +802,24 @@
 void gigaset_isdn_hupD(struct bc_state *bcs)
 {
 	struct gigaset_capi_appl *ap;
+	unsigned long flags;
 
 	/*
 	 * ToDo: pass on reason code reported by device
 	 * (requires ev-layer state machine extension to collect
 	 * ZCAU device reply)
 	 */
-	for (ap = bcs->ap; ap != NULL; ap = ap->bcnext) {
+	spin_lock_irqsave(&bcs->aplock, flags);
+	while (bcs->ap != NULL) {
+		ap = bcs->ap;
+		bcs->ap = ap->bcnext;
+		spin_unlock_irqrestore(&bcs->aplock, flags);
 		send_disconnect_b3_ind(bcs, ap);
 		send_disconnect_ind(bcs, ap, 0);
+		spin_lock_irqsave(&bcs->aplock, flags);
 	}
-	bcs->ap = NULL;
+	bcs->apconnstate = APCONN_NONE;
+	spin_unlock_irqrestore(&bcs->aplock, flags);
 }
 
 /**
@@ -796,24 +833,21 @@
 {
 	struct cardstate *cs = bcs->cs;
 	struct gigaset_capi_ctr *iif = cs->iif;
-	struct gigaset_capi_appl *ap = bcs->ap;
+	struct gigaset_capi_appl *ap;
 	struct sk_buff *skb;
+	unsigned long flags;
 	unsigned int msgsize;
 	u8 command;
 
+	spin_lock_irqsave(&bcs->aplock, flags);
+	ap = bcs->ap;
 	if (!ap) {
+		spin_unlock_irqrestore(&bcs->aplock, flags);
 		dev_err(cs->dev, "%s: no application\n", __func__);
 		return;
 	}
-	while (ap->bcnext) {
-		/* this should never happen */
-		dev_warn(cs->dev, "%s: dropping extra application %u\n",
-			 __func__, ap->bcnext->id);
-		send_disconnect_ind(bcs, ap->bcnext,
-				    CapiCallGivenToOtherApplication);
-		ap->bcnext = ap->bcnext->bcnext;
-	}
-	if (!ap->connected) {
+	if (!bcs->apconnstate) {
+		spin_unlock_irqrestore(&bcs->aplock, flags);
 		dev_warn(cs->dev, "%s: application %u not connected\n",
 			 __func__, ap->id);
 		return;
@@ -825,13 +859,26 @@
 	 * CONNECT_B3_ACTIVE_IND in reply to CONNECT_B3_RESP
 	 * Parameters in both cases always: NCCI = 1, NCPI empty
 	 */
-	if (ap->connected >= APCONN_ACTIVE) {
+	if (bcs->apconnstate >= APCONN_ACTIVE) {
 		command = CAPI_CONNECT_B3_ACTIVE;
 		msgsize = CAPI_CONNECT_B3_ACTIVE_IND_BASELEN;
 	} else {
 		command = CAPI_CONNECT_B3;
 		msgsize = CAPI_CONNECT_B3_IND_BASELEN;
 	}
+	bcs->apconnstate = APCONN_ACTIVE;
+
+	spin_unlock_irqrestore(&bcs->aplock, flags);
+
+	while (ap->bcnext) {
+		/* this should never happen */
+		dev_warn(cs->dev, "%s: dropping extra application %u\n",
+			 __func__, ap->bcnext->id);
+		send_disconnect_ind(bcs, ap->bcnext,
+				    CapiCallGivenToOtherApplication);
+		ap->bcnext = ap->bcnext->bcnext;
+	}
+
 	capi_cmsg_header(&iif->hcmsg, ap->id, command, CAPI_IND,
 			 ap->nextMessageNumber++,
 			 iif->ctr.cnr | ((bcs->channel + 1) << 8) | (1 << 16));
@@ -842,7 +889,6 @@
 	}
 	capi_cmsg2message(&iif->hcmsg, __skb_put(skb, msgsize));
 	dump_cmsg(DEBUG_CMD, __func__, &iif->hcmsg);
-	ap->connected = APCONN_ACTIVE;
 	capi_ctr_handle_message(&iif->ctr, ap->id, skb);
 }
 
@@ -945,8 +991,64 @@
 		return;
 	}
 	ap->id = appl;
+	ap->rp = *rp;
 
 	list_add(&ap->ctrlist, &iif->appls);
+	dev_info(cs->dev, "application %u registered\n", ap->id);
+}
+
+/*
+ * remove CAPI application from channel
+ * helper function to keep indentation levels down and stay in 80 columns
+ */
+
+static inline void remove_appl_from_channel(struct bc_state *bcs,
+					    struct gigaset_capi_appl *ap)
+{
+	struct cardstate *cs = bcs->cs;
+	struct gigaset_capi_appl *bcap;
+	unsigned long flags;
+	int prevconnstate;
+
+	spin_lock_irqsave(&bcs->aplock, flags);
+	bcap = bcs->ap;
+	if (bcap == NULL) {
+		spin_unlock_irqrestore(&bcs->aplock, flags);
+		return;
+	}
+
+	/* check first application on channel */
+	if (bcap == ap) {
+		bcs->ap = ap->bcnext;
+		if (bcs->ap != NULL) {
+			spin_unlock_irqrestore(&bcs->aplock, flags);
+			return;
+		}
+
+		/* none left, clear channel state */
+		prevconnstate = bcs->apconnstate;
+		bcs->apconnstate = APCONN_NONE;
+		spin_unlock_irqrestore(&bcs->aplock, flags);
+
+		if (prevconnstate == APCONN_ACTIVE) {
+			dev_notice(cs->dev, "%s: hanging up channel %u\n",
+				   __func__, bcs->channel);
+			gigaset_add_event(cs, &bcs->at_state,
+					  EV_HUP, NULL, 0, NULL);
+			gigaset_schedule_event(cs);
+		}
+		return;
+	}
+
+	/* check remaining list */
+	do {
+		if (bcap->bcnext == ap) {
+			bcap->bcnext = bcap->bcnext->bcnext;
+			return;
+		}
+		bcap = bcap->bcnext;
+	} while (bcap != NULL);
+	spin_unlock_irqrestore(&bcs->aplock, flags);
 }
 
 /*
@@ -958,19 +1060,19 @@
 		= container_of(ctr, struct gigaset_capi_ctr, ctr);
 	struct cardstate *cs = iif->ctr.driverdata;
 	struct gigaset_capi_appl *ap, *tmp;
+	unsigned ch;
 
 	list_for_each_entry_safe(ap, tmp, &iif->appls, ctrlist)
 		if (ap->id == appl) {
-			if (ap->connected != APCONN_NONE) {
-				dev_err(cs->dev,
-					"%s: application %u still connected\n",
-					__func__, ap->id);
-				/* ToDo: clear active connection */
-			}
+			/* remove from any channels */
+			for (ch = 0; ch < cs->channels; ch++)
+				remove_appl_from_channel(&cs->bcs[ch], ap);
+
+			/* remove from registration list */
 			list_del(&ap->ctrlist);
 			kfree(ap);
+			dev_info(cs->dev, "application %u released\n", appl);
 		}
-
 }
 
 /*
@@ -1149,7 +1251,8 @@
 	char **commands;
 	char *s;
 	u8 *pp;
-	int i, l;
+	unsigned long flags;
+	int i, l, lbc, lhlc;
 	u16 info;
 
 	/* decode message */
@@ -1164,8 +1267,18 @@
 		send_conf(iif, ap, skb, CapiNoPlciAvailable);
 		return;
 	}
+	spin_lock_irqsave(&bcs->aplock, flags);
+	if (bcs->ap != NULL || bcs->apconnstate != APCONN_NONE)
+		dev_warn(cs->dev, "%s: channel not properly cleared (%p/%d)\n",
+			 __func__, bcs->ap, bcs->apconnstate);
 	ap->bcnext = NULL;
 	bcs->ap = ap;
+	bcs->apconnstate = APCONN_SETUP;
+	spin_unlock_irqrestore(&bcs->aplock, flags);
+
+	bcs->rx_bufsize = ap->rp.datablklen;
+	dev_kfree_skb(bcs->rx_skb);
+	gigaset_new_rx_skb(bcs);
 	cmsg->adr.adrPLCI |= (bcs->channel + 1) << 8;
 
 	/* build command table */
@@ -1273,42 +1386,59 @@
 		goto error;
 	}
 
-	/* check/encode parameter: BC */
-	if (cmsg->BC && cmsg->BC[0]) {
-		/* explicit BC overrides CIP */
-		l = 2*cmsg->BC[0] + 7;
+	/*
+	 * check/encode parameters: BC & HLC
+	 * must be encoded together as device doesn't accept HLC separately
+	 * explicit parameters override values derived from CIP
+	 */
+
+	/* determine lengths */
+	if (cmsg->BC && cmsg->BC[0])		/* BC specified explicitly */
+		lbc = 2*cmsg->BC[0];
+	else if (cip2bchlc[cmsg->CIPValue].bc)	/* BC derived from CIP */
+		lbc = strlen(cip2bchlc[cmsg->CIPValue].bc);
+	else					/* no BC */
+		lbc = 0;
+	if (cmsg->HLC && cmsg->HLC[0])		/* HLC specified explicitly */
+		lhlc = 2*cmsg->HLC[0];
+	else if (cip2bchlc[cmsg->CIPValue].hlc)	/* HLC derived from CIP */
+		lhlc = strlen(cip2bchlc[cmsg->CIPValue].hlc);
+	else					/* no HLC */
+		lhlc = 0;
+
+	if (lbc) {
+		/* have BC: allocate and assemble command string */
+		l = lbc + 7;		/* "^SBC=" + value + "\r" + null byte */
+		if (lhlc)
+			l += lhlc + 7;	/* ";^SHLC=" + value */
 		commands[AT_BC] = kmalloc(l, GFP_KERNEL);
 		if (!commands[AT_BC])
 			goto oom;
 		strcpy(commands[AT_BC], "^SBC=");
-		decode_ie(cmsg->BC, commands[AT_BC]+5);
+		if (cmsg->BC && cmsg->BC[0])	/* BC specified explicitly */
+			decode_ie(cmsg->BC, commands[AT_BC] + 5);
+		else				/* BC derived from CIP */
+			strcpy(commands[AT_BC] + 5,
+			       cip2bchlc[cmsg->CIPValue].bc);
+		if (lhlc) {
+			strcpy(commands[AT_BC] + lbc + 5, ";^SHLC=");
+			if (cmsg->HLC && cmsg->HLC[0])
+				/* HLC specified explicitly */
+				decode_ie(cmsg->HLC,
+					  commands[AT_BC] + lbc + 12);
+			else	/* HLC derived from CIP */
+				strcpy(commands[AT_BC] + lbc + 12,
+				       cip2bchlc[cmsg->CIPValue].hlc);
+		}
 		strcpy(commands[AT_BC] + l - 2, "\r");
-	} else if (cip2bchlc[cmsg->CIPValue].bc) {
-		l = strlen(cip2bchlc[cmsg->CIPValue].bc) + 7;
-		commands[AT_BC] = kmalloc(l, GFP_KERNEL);
-		if (!commands[AT_BC])
-			goto oom;
-		snprintf(commands[AT_BC], l, "^SBC=%s\r",
-			 cip2bchlc[cmsg->CIPValue].bc);
-	}
-
-	/* check/encode parameter: HLC */
-	if (cmsg->HLC && cmsg->HLC[0]) {
-		/* explicit HLC overrides CIP */
-		l = 2*cmsg->HLC[0] + 7;
-		commands[AT_HLC] = kmalloc(l, GFP_KERNEL);
-		if (!commands[AT_HLC])
-			goto oom;
-		strcpy(commands[AT_HLC], "^SHLC=");
-		decode_ie(cmsg->HLC, commands[AT_HLC]+5);
-		strcpy(commands[AT_HLC] + l - 2, "\r");
-	} else if (cip2bchlc[cmsg->CIPValue].hlc) {
-		l = strlen(cip2bchlc[cmsg->CIPValue].hlc) + 7;
-		commands[AT_HLC] = kmalloc(l, GFP_KERNEL);
-		if (!commands[AT_HLC])
-			goto oom;
-		snprintf(commands[AT_HLC], l, "^SHLC=%s\r",
-			 cip2bchlc[cmsg->CIPValue].hlc);
+	} else {
+		/* no BC */
+		if (lhlc) {
+			dev_notice(cs->dev, "%s: cannot set HLC without BC\n",
+				   "CONNECT_REQ");
+			info = CapiIllMessageParmCoding; /* ? */
+			goto error;
+		}
 	}
 
 	/* check/encode parameter: B Protocol */
@@ -1322,13 +1452,13 @@
 			bcs->proto2 = L2_HDLC;
 			break;
 		case 1:
-			bcs->proto2 = L2_BITSYNC;
+			bcs->proto2 = L2_VOICE;
 			break;
 		default:
 			dev_warn(cs->dev,
 			    "B1 Protocol %u unsupported, using Transparent\n",
 				 cmsg->B1protocol);
-			bcs->proto2 = L2_BITSYNC;
+			bcs->proto2 = L2_VOICE;
 		}
 		if (cmsg->B2protocol != 1)
 			dev_warn(cs->dev,
@@ -1382,7 +1512,6 @@
 		goto error;
 	}
 	gigaset_schedule_event(cs);
-	ap->connected = APCONN_SETUP;
 	send_conf(iif, ap, skb, CapiSuccess);
 	return;
 
@@ -1410,6 +1539,7 @@
 	_cmsg *cmsg = &iif->acmsg;
 	struct bc_state *bcs;
 	struct gigaset_capi_appl *oap;
+	unsigned long flags;
 	int channel;
 
 	/* decode message */
@@ -1429,12 +1559,24 @@
 	switch (cmsg->Reject) {
 	case 0:		/* Accept */
 		/* drop all competing applications, keep only this one */
-		for (oap = bcs->ap; oap != NULL; oap = oap->bcnext)
-			if (oap != ap)
+		spin_lock_irqsave(&bcs->aplock, flags);
+		while (bcs->ap != NULL) {
+			oap = bcs->ap;
+			bcs->ap = oap->bcnext;
+			if (oap != ap) {
+				spin_unlock_irqrestore(&bcs->aplock, flags);
 				send_disconnect_ind(bcs, oap,
 					CapiCallGivenToOtherApplication);
+				spin_lock_irqsave(&bcs->aplock, flags);
+			}
+		}
 		ap->bcnext = NULL;
 		bcs->ap = ap;
+		spin_unlock_irqrestore(&bcs->aplock, flags);
+
+		bcs->rx_bufsize = ap->rp.datablklen;
+		dev_kfree_skb(bcs->rx_skb);
+		gigaset_new_rx_skb(bcs);
 		bcs->chstate |= CHS_NOTIFY_LL;
 
 		/* check/encode B channel protocol */
@@ -1448,13 +1590,13 @@
 				bcs->proto2 = L2_HDLC;
 				break;
 			case 1:
-				bcs->proto2 = L2_BITSYNC;
+				bcs->proto2 = L2_VOICE;
 				break;
 			default:
 				dev_warn(cs->dev,
 			"B1 Protocol %u unsupported, using Transparent\n",
 					 cmsg->B1protocol);
-				bcs->proto2 = L2_BITSYNC;
+				bcs->proto2 = L2_VOICE;
 			}
 			if (cmsg->B2protocol != 1)
 				dev_warn(cs->dev,
@@ -1502,31 +1644,45 @@
 		send_disconnect_ind(bcs, ap, 0);
 
 		/* remove it from the list of listening apps */
+		spin_lock_irqsave(&bcs->aplock, flags);
 		if (bcs->ap == ap) {
 			bcs->ap = ap->bcnext;
-			if (bcs->ap == NULL)
+			if (bcs->ap == NULL) {
 				/* last one: stop ev-layer hupD notifications */
+				bcs->apconnstate = APCONN_NONE;
 				bcs->chstate &= ~CHS_NOTIFY_LL;
+			}
+			spin_unlock_irqrestore(&bcs->aplock, flags);
 			return;
 		}
 		for (oap = bcs->ap; oap != NULL; oap = oap->bcnext) {
 			if (oap->bcnext == ap) {
 				oap->bcnext = oap->bcnext->bcnext;
+				spin_unlock_irqrestore(&bcs->aplock, flags);
 				return;
 			}
 		}
+		spin_unlock_irqrestore(&bcs->aplock, flags);
 		dev_err(cs->dev, "%s: application %u not found\n",
 			__func__, ap->id);
 		return;
 
 	default:		/* Reject */
 		/* drop all competing applications, keep only this one */
-		for (oap = bcs->ap; oap != NULL; oap = oap->bcnext)
-			if (oap != ap)
+		spin_lock_irqsave(&bcs->aplock, flags);
+		while (bcs->ap != NULL) {
+			oap = bcs->ap;
+			bcs->ap = oap->bcnext;
+			if (oap != ap) {
+				spin_unlock_irqrestore(&bcs->aplock, flags);
 				send_disconnect_ind(bcs, oap,
 					CapiCallGivenToOtherApplication);
+				spin_lock_irqsave(&bcs->aplock, flags);
+			}
+		}
 		ap->bcnext = NULL;
 		bcs->ap = ap;
+		spin_unlock_irqrestore(&bcs->aplock, flags);
 
 		/* reject call - will trigger DISCONNECT_IND for this app */
 		dev_info(cs->dev, "%s: Reject=%x\n",
@@ -1549,6 +1705,7 @@
 {
 	struct cardstate *cs = iif->ctr.driverdata;
 	_cmsg *cmsg = &iif->acmsg;
+	struct bc_state *bcs;
 	int channel;
 
 	/* decode message */
@@ -1563,9 +1720,10 @@
 		send_conf(iif, ap, skb, CapiIllContrPlciNcci);
 		return;
 	}
+	bcs = &cs->bcs[channel-1];
 
 	/* mark logical connection active */
-	ap->connected = APCONN_ACTIVE;
+	bcs->apconnstate = APCONN_ACTIVE;
 
 	/* build NCCI: always 1 (one B3 connection only) */
 	cmsg->adr.adrNCCI |= 1 << 16;
@@ -1611,7 +1769,7 @@
 
 	if (cmsg->Reject) {
 		/* Reject: clear B3 connect received flag */
-		ap->connected = APCONN_SETUP;
+		bcs->apconnstate = APCONN_SETUP;
 
 		/* trigger hangup, causing eventual DISCONNECT_IND */
 		if (!gigaset_add_event(cs, &bcs->at_state,
@@ -1683,11 +1841,11 @@
 	}
 
 	/* skip if DISCONNECT_IND already sent */
-	if (!ap->connected)
+	if (!bcs->apconnstate)
 		return;
 
 	/* check for active logical connection */
-	if (ap->connected >= APCONN_ACTIVE) {
+	if (bcs->apconnstate >= APCONN_ACTIVE) {
 		/*
 		 * emit DISCONNECT_B3_IND with cause 0x3301
 		 * use separate cmsg structure, as the content of iif->acmsg
@@ -1736,6 +1894,7 @@
 {
 	struct cardstate *cs = iif->ctr.driverdata;
 	_cmsg *cmsg = &iif->acmsg;
+	struct bc_state *bcs;
 	int channel;
 
 	/* decode message */
@@ -1751,17 +1910,17 @@
 		send_conf(iif, ap, skb, CapiIllContrPlciNcci);
 		return;
 	}
+	bcs = &cs->bcs[channel-1];
 
 	/* reject if logical connection not active */
-	if (ap->connected < APCONN_ACTIVE) {
+	if (bcs->apconnstate < APCONN_ACTIVE) {
 		send_conf(iif, ap, skb,
 			  CapiMessageNotSupportedInCurrentState);
 		return;
 	}
 
 	/* trigger hangup, causing eventual DISCONNECT_B3_IND */
-	if (!gigaset_add_event(cs, &cs->bcs[channel-1].at_state,
-			       EV_HUP, NULL, 0, NULL)) {
+	if (!gigaset_add_event(cs, &bcs->at_state, EV_HUP, NULL, 0, NULL)) {
 		send_conf(iif, ap, skb, CAPI_MSGOSRESOURCEERR);
 		return;
 	}
@@ -1782,11 +1941,14 @@
 			   struct sk_buff *skb)
 {
 	struct cardstate *cs = iif->ctr.driverdata;
+	struct bc_state *bcs;
 	int channel = CAPIMSG_PLCI_PART(skb->data);
 	u16 ncci = CAPIMSG_NCCI_PART(skb->data);
 	u16 msglen = CAPIMSG_LEN(skb->data);
 	u16 datalen = CAPIMSG_DATALEN(skb->data);
 	u16 flags = CAPIMSG_FLAGS(skb->data);
+	u16 msgid = CAPIMSG_MSGID(skb->data);
+	u16 handle = CAPIMSG_HANDLE_REQ(skb->data);
 
 	/* frequent message, avoid _cmsg overhead */
 	dump_rawmsg(DEBUG_LLDATA, "DATA_B3_REQ", skb->data);
@@ -1802,6 +1964,7 @@
 		send_conf(iif, ap, skb, CapiIllContrPlciNcci);
 		return;
 	}
+	bcs = &cs->bcs[channel-1];
 	if (msglen != CAPI_DATA_B3_REQ_LEN && msglen != CAPI_DATA_B3_REQ_LEN64)
 		dev_notice(cs->dev, "%s: unexpected length %d\n",
 			   "DATA_B3_REQ", msglen);
@@ -1821,7 +1984,7 @@
 	}
 
 	/* reject if logical connection not active */
-	if (ap->connected < APCONN_ACTIVE) {
+	if (bcs->apconnstate < APCONN_ACTIVE) {
 		send_conf(iif, ap, skb, CapiMessageNotSupportedInCurrentState);
 		return;
 	}
@@ -1832,17 +1995,19 @@
 	skb_pull(skb, msglen);
 
 	/* pass to device-specific module */
-	if (cs->ops->send_skb(&cs->bcs[channel-1], skb) < 0) {
+	if (cs->ops->send_skb(bcs, skb) < 0) {
 		send_conf(iif, ap, skb, CAPI_MSGOSRESOURCEERR);
 		return;
 	}
 
-	/* DATA_B3_CONF reply will be sent by gigaset_skb_sent() */
-
 	/*
-	 * ToDo: honor unset "delivery confirmation" bit
-	 * (send DATA_B3_CONF immediately?)
+	 * DATA_B3_CONF will be sent by gigaset_skb_sent() only if "delivery
+	 * confirmation" bit is set; otherwise we have to send it now
 	 */
+	if (!(flags & CAPI_FLAGS_DELIVERY_CONFIRMATION))
+		send_data_b3_conf(cs, &iif->ctr, ap->id, msgid, channel, handle,
+				  flags ? CapiFlagsNotSupportedByProtocol
+					: CAPI_NOERROR);
 }
 
 /*
diff -urN linux-2.6.35-rc3/drivers/isdn/gigaset/common.c linux-2.6.35-rc4/drivers/isdn/gigaset/common.c
--- linux-2.6.35-rc3/drivers/isdn/gigaset/common.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/isdn/gigaset/common.c	2010-07-05 05:34:27.360868105 +0000
@@ -399,8 +399,8 @@
 	gig_dbg(DEBUG_INIT, "clearing bcs[%d]->at_state", bcs->channel);
 	clear_at_state(&bcs->at_state);
 	gig_dbg(DEBUG_INIT, "freeing bcs[%d]->skb", bcs->channel);
-	dev_kfree_skb(bcs->skb);
-	bcs->skb = NULL;
+	dev_kfree_skb(bcs->rx_skb);
+	bcs->rx_skb = NULL;
 
 	for (i = 0; i < AT_NUM; ++i) {
 		kfree(bcs->commands[i]);
@@ -634,19 +634,10 @@
 	bcs->emptycount = 0;
 #endif
 
-	gig_dbg(DEBUG_INIT, "allocating bcs[%d]->skb", channel);
-	bcs->fcs = PPP_INITFCS;
+	bcs->rx_bufsize = 0;
+	bcs->rx_skb = NULL;
+	bcs->rx_fcs = PPP_INITFCS;
 	bcs->inputstate = 0;
-	if (cs->ignoreframes) {
-		bcs->skb = NULL;
-	} else {
-		bcs->skb = dev_alloc_skb(SBUFSIZE + cs->hw_hdr_len);
-		if (bcs->skb != NULL)
-			skb_reserve(bcs->skb, cs->hw_hdr_len);
-		else
-			pr_err("out of memory\n");
-	}
-
 	bcs->channel = channel;
 	bcs->cs = cs;
 
@@ -658,16 +649,15 @@
 	for (i = 0; i < AT_NUM; ++i)
 		bcs->commands[i] = NULL;
 
+	spin_lock_init(&bcs->aplock);
+	bcs->ap = NULL;
+	bcs->apconnstate = 0;
+
 	gig_dbg(DEBUG_INIT, "  setting up bcs[%d]->hw", channel);
 	if (cs->ops->initbcshw(bcs))
 		return bcs;
 
 	gig_dbg(DEBUG_INIT, "  failed");
-
-	gig_dbg(DEBUG_INIT, "  freeing bcs[%d]->skb", channel);
-	dev_kfree_skb(bcs->skb);
-	bcs->skb = NULL;
-
 	return NULL;
 }
 
@@ -839,14 +829,12 @@
 	bcs->emptycount = 0;
 #endif
 
-	bcs->fcs = PPP_INITFCS;
+	bcs->rx_fcs = PPP_INITFCS;
 	bcs->chstate = 0;
 
 	bcs->ignore = cs->ignoreframes;
-	if (bcs->ignore) {
-		dev_kfree_skb(bcs->skb);
-		bcs->skb = NULL;
-	}
+	dev_kfree_skb(bcs->rx_skb);
+	bcs->rx_skb = NULL;
 
 	cs->ops->reinitbcshw(bcs);
 }
diff -urN linux-2.6.35-rc3/drivers/isdn/gigaset/ev-layer.c linux-2.6.35-rc4/drivers/isdn/gigaset/ev-layer.c
--- linux-2.6.35-rc3/drivers/isdn/gigaset/ev-layer.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/isdn/gigaset/ev-layer.c	2010-07-05 05:34:27.360868105 +0000
@@ -282,9 +282,7 @@
 /* dial */
 {EV_DIAL,	 -1,  -1, -1,			 -1, -1, {ACT_DIAL} },
 {RSP_INIT,	  0,   0, SEQ_DIAL,		601,  5, {ACT_CMD+AT_BC} },
-{RSP_OK,	601, 601, -1,			602,  5, {ACT_CMD+AT_HLC} },
-{RSP_NULL,	602, 602, -1,			603,  5, {ACT_CMD+AT_PROTO} },
-{RSP_OK,	602, 602, -1,			603,  5, {ACT_CMD+AT_PROTO} },
+{RSP_OK,	601, 601, -1,			603,  5, {ACT_CMD+AT_PROTO} },
 {RSP_OK,	603, 603, -1,			604,  5, {ACT_CMD+AT_TYPE} },
 {RSP_OK,	604, 604, -1,			605,  5, {ACT_CMD+AT_MSN} },
 {RSP_NULL,	605, 605, -1,			606,  5, {ACT_CMD+AT_CLIP} },
diff -urN linux-2.6.35-rc3/drivers/isdn/gigaset/gigaset.h linux-2.6.35-rc4/drivers/isdn/gigaset/gigaset.h
--- linux-2.6.35-rc3/drivers/isdn/gigaset/gigaset.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/isdn/gigaset/gigaset.h	2010-07-05 05:34:27.361868097 +0000
@@ -45,10 +45,6 @@
 #define MAX_EVENTS 64		/* size of event queue */
 
 #define RBUFSIZE 8192
-#define SBUFSIZE 4096		/* sk_buff payload size */
-
-#define TRANSBUFSIZE 768	/* bytes per skb for transparent receive */
-#define MAX_BUF_SIZE (SBUFSIZE - 2)	/* Max. size of a data packet from LL */
 
 /* compile time options */
 #define GIG_MAJOR 0
@@ -190,10 +186,9 @@
 #define AT_BC		3
 #define AT_PROTO	4
 #define AT_TYPE		5
-#define AT_HLC		6
-#define AT_CLIP		7
+#define AT_CLIP		6
 /* total number */
-#define AT_NUM		8
+#define AT_NUM		7
 
 /* variables in struct at_state_t */
 #define VAR_ZSAU	0
@@ -380,8 +375,10 @@
 
 	struct at_state_t at_state;
 
-	__u16 fcs;
-	struct sk_buff *skb;
+	/* receive buffer */
+	unsigned rx_bufsize;		/* max size accepted by application */
+	struct sk_buff *rx_skb;
+	__u16 rx_fcs;
 	int inputstate;			/* see INS_XXXX */
 
 	int channel;
@@ -406,7 +403,9 @@
 		struct bas_bc_state *bas;	/* usb hardware driver (base) */
 	} hw;
 
-	void *ap;			/* LL application structure */
+	void *ap;			/* associated LL application */
+	int apconnstate;		/* LL application connection state */
+	spinlock_t aplock;
 };
 
 struct cardstate {
@@ -801,8 +800,23 @@
 	gigaset_schedule_event(bcs->cs);
 }
 
-/* handling routines for sk_buff */
-/* ============================= */
+/* set up next receive skb for data mode */
+static inline struct sk_buff *gigaset_new_rx_skb(struct bc_state *bcs)
+{
+	struct cardstate *cs = bcs->cs;
+	unsigned short hw_hdr_len = cs->hw_hdr_len;
+
+	if (bcs->ignore) {
+		bcs->rx_skb = NULL;
+	} else {
+		bcs->rx_skb = dev_alloc_skb(bcs->rx_bufsize + hw_hdr_len);
+		if (bcs->rx_skb == NULL)
+			dev_warn(cs->dev, "could not allocate skb\n");
+		else
+			skb_reserve(bcs->rx_skb, hw_hdr_len);
+	}
+	return bcs->rx_skb;
+}
 
 /* append received bytes to inbuf */
 int gigaset_fill_inbuf(struct inbuf_t *inbuf, const unsigned char *src,
diff -urN linux-2.6.35-rc3/drivers/isdn/gigaset/i4l.c linux-2.6.35-rc4/drivers/isdn/gigaset/i4l.c
--- linux-2.6.35-rc3/drivers/isdn/gigaset/i4l.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/isdn/gigaset/i4l.c	2010-07-05 05:34:27.361868097 +0000
@@ -16,7 +16,10 @@
 #include "gigaset.h"
 #include <linux/isdnif.h>
 
+#define SBUFSIZE	4096	/* sk_buff payload size */
+#define TRANSBUFSIZE	768	/* bytes per skb for transparent receive */
 #define HW_HDR_LEN	2	/* Header size used to store ack info */
+#define MAX_BUF_SIZE	(SBUFSIZE - HW_HDR_LEN)	/* max data packet from LL */
 
 /* == Handling of I4L IO =====================================================*/
 
@@ -231,6 +234,15 @@
 			dev_err(cs->dev, "ISDN_CMD_DIAL: channel not free\n");
 			return -EBUSY;
 		}
+		switch (bcs->proto2) {
+		case L2_HDLC:
+			bcs->rx_bufsize = SBUFSIZE;
+			break;
+		default:			/* assume transparent */
+			bcs->rx_bufsize = TRANSBUFSIZE;
+		}
+		dev_kfree_skb(bcs->rx_skb);
+		gigaset_new_rx_skb(bcs);
 
 		commands = kzalloc(AT_NUM*(sizeof *commands), GFP_ATOMIC);
 		if (!commands) {
@@ -314,6 +326,15 @@
 			return -EINVAL;
 		}
 		bcs = cs->bcs + ch;
+		switch (bcs->proto2) {
+		case L2_HDLC:
+			bcs->rx_bufsize = SBUFSIZE;
+			break;
+		default:			/* assume transparent */
+			bcs->rx_bufsize = TRANSBUFSIZE;
+		}
+		dev_kfree_skb(bcs->rx_skb);
+		gigaset_new_rx_skb(bcs);
 		if (!gigaset_add_event(cs, &bcs->at_state,
 				       EV_ACCEPT, NULL, 0, NULL))
 			return -ENOMEM;
diff -urN linux-2.6.35-rc3/drivers/isdn/gigaset/isocdata.c linux-2.6.35-rc4/drivers/isdn/gigaset/isocdata.c
--- linux-2.6.35-rc3/drivers/isdn/gigaset/isocdata.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/isdn/gigaset/isocdata.c	2010-07-05 05:34:27.361868097 +0000
@@ -500,19 +500,18 @@
  */
 static inline void hdlc_putbyte(unsigned char c, struct bc_state *bcs)
 {
-	bcs->fcs = crc_ccitt_byte(bcs->fcs, c);
-	if (unlikely(bcs->skb == NULL)) {
+	bcs->rx_fcs = crc_ccitt_byte(bcs->rx_fcs, c);
+	if (bcs->rx_skb == NULL)
 		/* skipping */
 		return;
-	}
-	if (unlikely(bcs->skb->len == SBUFSIZE)) {
+	if (bcs->rx_skb->len >= bcs->rx_bufsize) {
 		dev_warn(bcs->cs->dev, "received oversized packet discarded\n");
 		bcs->hw.bas->giants++;
-		dev_kfree_skb_any(bcs->skb);
-		bcs->skb = NULL;
+		dev_kfree_skb_any(bcs->rx_skb);
+		bcs->rx_skb = NULL;
 		return;
 	}
-	*__skb_put(bcs->skb, 1) = c;
+	*__skb_put(bcs->rx_skb, 1) = c;
 }
 
 /* hdlc_flush
@@ -521,18 +520,13 @@
 static inline void hdlc_flush(struct bc_state *bcs)
 {
 	/* clear skb or allocate new if not skipping */
-	if (likely(bcs->skb != NULL))
-		skb_trim(bcs->skb, 0);
-	else if (!bcs->ignore) {
-		bcs->skb = dev_alloc_skb(SBUFSIZE + bcs->cs->hw_hdr_len);
-		if (bcs->skb)
-			skb_reserve(bcs->skb, bcs->cs->hw_hdr_len);
-		else
-			dev_err(bcs->cs->dev, "could not allocate skb\n");
-	}
+	if (bcs->rx_skb != NULL)
+		skb_trim(bcs->rx_skb, 0);
+	else
+		gigaset_new_rx_skb(bcs);
 
 	/* reset packet state */
-	bcs->fcs = PPP_INITFCS;
+	bcs->rx_fcs = PPP_INITFCS;
 }
 
 /* hdlc_done
@@ -549,7 +543,7 @@
 		hdlc_flush(bcs);
 		return;
 	}
-	procskb = bcs->skb;
+	procskb = bcs->rx_skb;
 	if (procskb == NULL) {
 		/* previous error */
 		gig_dbg(DEBUG_ISO, "%s: skb=NULL", __func__);
@@ -560,8 +554,8 @@
 		bcs->hw.bas->runts++;
 		dev_kfree_skb_any(procskb);
 		gigaset_isdn_rcv_err(bcs);
-	} else if (bcs->fcs != PPP_GOODFCS) {
-		dev_notice(cs->dev, "frame check error (0x%04x)\n", bcs->fcs);
+	} else if (bcs->rx_fcs != PPP_GOODFCS) {
+		dev_notice(cs->dev, "frame check error\n");
 		bcs->hw.bas->fcserrs++;
 		dev_kfree_skb_any(procskb);
 		gigaset_isdn_rcv_err(bcs);
@@ -574,13 +568,8 @@
 		bcs->hw.bas->goodbytes += len;
 		gigaset_skb_rcvd(bcs, procskb);
 	}
-
-	bcs->skb = dev_alloc_skb(SBUFSIZE + cs->hw_hdr_len);
-	if (bcs->skb)
-		skb_reserve(bcs->skb, cs->hw_hdr_len);
-	else
-		dev_err(cs->dev, "could not allocate skb\n");
-	bcs->fcs = PPP_INITFCS;
+	gigaset_new_rx_skb(bcs);
+	bcs->rx_fcs = PPP_INITFCS;
 }
 
 /* hdlc_frag
@@ -597,8 +586,8 @@
 	dev_notice(bcs->cs->dev, "received partial byte (%d bits)\n", inbits);
 	bcs->hw.bas->alignerrs++;
 	gigaset_isdn_rcv_err(bcs);
-	__skb_trim(bcs->skb, 0);
-	bcs->fcs = PPP_INITFCS;
+	__skb_trim(bcs->rx_skb, 0);
+	bcs->rx_fcs = PPP_INITFCS;
 }
 
 /* bit counts lookup table for HDLC bit unstuffing
@@ -847,7 +836,6 @@
 static inline void trans_receive(unsigned char *src, unsigned count,
 				 struct bc_state *bcs)
 {
-	struct cardstate *cs = bcs->cs;
 	struct sk_buff *skb;
 	int dobytes;
 	unsigned char *dst;
@@ -857,17 +845,11 @@
 		hdlc_flush(bcs);
 		return;
 	}
-	skb = bcs->skb;
-	if (unlikely(skb == NULL)) {
-		bcs->skb = skb = dev_alloc_skb(SBUFSIZE + cs->hw_hdr_len);
-		if (!skb) {
-			dev_err(cs->dev, "could not allocate skb\n");
-			return;
-		}
-		skb_reserve(skb, cs->hw_hdr_len);
-	}
+	skb = bcs->rx_skb;
+	if (skb == NULL)
+		skb = gigaset_new_rx_skb(bcs);
 	bcs->hw.bas->goodbytes += skb->len;
-	dobytes = TRANSBUFSIZE - skb->len;
+	dobytes = bcs->rx_bufsize - skb->len;
 	while (count > 0) {
 		dst = skb_put(skb, count < dobytes ? count : dobytes);
 		while (count > 0 && dobytes > 0) {
@@ -879,14 +861,10 @@
 			dump_bytes(DEBUG_STREAM_DUMP,
 				   "rcv data", skb->data, skb->len);
 			gigaset_skb_rcvd(bcs, skb);
-			bcs->skb = skb =
-				dev_alloc_skb(SBUFSIZE + cs->hw_hdr_len);
-			if (!skb) {
-				dev_err(cs->dev, "could not allocate skb\n");
+			skb = gigaset_new_rx_skb(bcs);
+			if (skb == NULL)
 				return;
-			}
-			skb_reserve(skb, cs->hw_hdr_len);
-			dobytes = TRANSBUFSIZE;
+			dobytes = bcs->rx_bufsize;
 		}
 	}
 }
diff -urN linux-2.6.35-rc3/drivers/isdn/hysdn/hysdn_net.c linux-2.6.35-rc4/drivers/isdn/hysdn/hysdn_net.c
--- linux-2.6.35-rc3/drivers/isdn/hysdn/hysdn_net.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/isdn/hysdn/hysdn_net.c	2010-07-05 05:34:27.364868089 +0000
@@ -187,12 +187,13 @@
 hysdn_rx_netpkt(hysdn_card * card, unsigned char *buf, unsigned short len)
 {
 	struct net_local *lp = card->netif;
-	struct net_device *dev = lp->dev;
+	struct net_device *dev;
 	struct sk_buff *skb;
 
 	if (!lp)
 		return;		/* non existing device */
 
+	dev = lp->dev;
 	dev->stats.rx_bytes += len;
 
 	skb = dev_alloc_skb(len);
diff -urN linux-2.6.35-rc3/drivers/md/md.c linux-2.6.35-rc4/drivers/md/md.c
--- linux-2.6.35-rc3/drivers/md/md.c	2010-07-05 05:34:21.982868389 +0000
+++ linux-2.6.35-rc4/drivers/md/md.c	2010-07-05 05:34:27.371868057 +0000
@@ -2087,6 +2087,7 @@
 	/* First make sure individual recovery_offsets are correct */
 	list_for_each_entry(rdev, &mddev->disks, same_set) {
 		if (rdev->raid_disk >= 0 &&
+		    mddev->delta_disks >= 0 &&
 		    !test_bit(In_sync, &rdev->flags) &&
 		    mddev->curr_resync_completed > rdev->recovery_offset)
 				rdev->recovery_offset = mddev->curr_resync_completed;
@@ -3001,6 +3002,9 @@
 		return -EINVAL;
 	}
 
+	list_for_each_entry(rdev, &mddev->disks, same_set)
+		rdev->new_raid_disk = rdev->raid_disk;
+
 	/* ->takeover must set new_* and/or delta_disks
 	 * if it succeeds, and may set them when it fails.
 	 */
@@ -3051,13 +3055,35 @@
 		mddev->safemode = 0;
 	}
 
-	module_put(mddev->pers->owner);
-	/* Invalidate devices that are now superfluous */
-	list_for_each_entry(rdev, &mddev->disks, same_set)
-		if (rdev->raid_disk >= mddev->raid_disks) {
-			rdev->raid_disk = -1;
+	list_for_each_entry(rdev, &mddev->disks, same_set) {
+		char nm[20];
+		if (rdev->raid_disk < 0)
+			continue;
+		if (rdev->new_raid_disk > mddev->raid_disks)
+			rdev->new_raid_disk = -1;
+		if (rdev->new_raid_disk == rdev->raid_disk)
+			continue;
+		sprintf(nm, "rd%d", rdev->raid_disk);
+		sysfs_remove_link(&mddev->kobj, nm);
+	}
+	list_for_each_entry(rdev, &mddev->disks, same_set) {
+		if (rdev->raid_disk < 0)
+			continue;
+		if (rdev->new_raid_disk == rdev->raid_disk)
+			continue;
+		rdev->raid_disk = rdev->new_raid_disk;
+		if (rdev->raid_disk < 0)
 			clear_bit(In_sync, &rdev->flags);
+		else {
+			char nm[20];
+			sprintf(nm, "rd%d", rdev->raid_disk);
+			if(sysfs_create_link(&mddev->kobj, &rdev->kobj, nm))
+				printk("md: cannot register %s for %s after level change\n",
+				       nm, mdname(mddev));
 		}
+	}
+
+	module_put(mddev->pers->owner);
 	mddev->pers = pers;
 	mddev->private = priv;
 	strlcpy(mddev->clevel, pers->name, sizeof(mddev->clevel));
@@ -5895,6 +5921,7 @@
 	atomic_inc(&mddev->openers);
 	mutex_unlock(&mddev->open_mutex);
 
+	check_disk_size_change(mddev->gendisk, bdev);
  out:
 	return err;
 }
@@ -6846,6 +6873,7 @@
 			rcu_read_lock();
 			list_for_each_entry_rcu(rdev, &mddev->disks, same_set)
 				if (rdev->raid_disk >= 0 &&
+				    mddev->delta_disks >= 0 &&
 				    !test_bit(Faulty, &rdev->flags) &&
 				    !test_bit(In_sync, &rdev->flags) &&
 				    rdev->recovery_offset < mddev->curr_resync)
diff -urN linux-2.6.35-rc3/drivers/md/md.h linux-2.6.35-rc4/drivers/md/md.h
--- linux-2.6.35-rc3/drivers/md/md.h	2010-07-05 05:34:21.982868389 +0000
+++ linux-2.6.35-rc4/drivers/md/md.h	2010-07-05 05:34:27.371868057 +0000
@@ -78,6 +78,9 @@
 
 	int desc_nr;			/* descriptor index in the superblock */
 	int raid_disk;			/* role of device in array */
+	int new_raid_disk;		/* role that the device will have in
+					 * the array after a level-change completes.
+					 */
 	int saved_raid_disk;		/* role that device used to have in the
 					 * array and could again if we did a partial
 					 * resync from the bitmap
diff -urN linux-2.6.35-rc3/drivers/md/raid0.c linux-2.6.35-rc4/drivers/md/raid0.c
--- linux-2.6.35-rc3/drivers/md/raid0.c	2010-07-05 05:34:21.983868641 +0000
+++ linux-2.6.35-rc4/drivers/md/raid0.c	2010-07-05 05:34:27.371868057 +0000
@@ -173,9 +173,11 @@
 	list_for_each_entry(rdev1, &mddev->disks, same_set) {
 		int j = rdev1->raid_disk;
 
-		if (mddev->level == 10)
+		if (mddev->level == 10) {
 			/* taking over a raid10-n2 array */
 			j /= 2;
+			rdev1->new_raid_disk = j;
+		}
 
 		if (j < 0 || j >= mddev->raid_disks) {
 			printk(KERN_ERR "md/raid0:%s: bad disk number %d - "
@@ -361,12 +363,6 @@
 		mddev->private = conf;
 	}
 	conf = mddev->private;
-	if (conf->scale_raid_disks) {
-		int i;
-		for (i=0; i < conf->strip_zone[0].nb_dev; i++)
-			conf->devlist[i]->raid_disk /= conf->scale_raid_disks;
-		/* FIXME update sysfs rd links */
-	}
 
 	/* calculate array device size */
 	md_set_array_sectors(mddev, raid0_size(mddev, 0, 0));
@@ -573,7 +569,7 @@
 	return;
 }
 
-static void *raid0_takeover_raid5(mddev_t *mddev)
+static void *raid0_takeover_raid45(mddev_t *mddev)
 {
 	mdk_rdev_t *rdev;
 	raid0_conf_t *priv_conf;
@@ -596,6 +592,7 @@
 
 	/* Set new parameters */
 	mddev->new_level = 0;
+	mddev->new_layout = 0;
 	mddev->new_chunk_sectors = mddev->chunk_sectors;
 	mddev->raid_disks--;
 	mddev->delta_disks = -1;
@@ -635,6 +632,7 @@
 
 	/* Set new parameters */
 	mddev->new_level = 0;
+	mddev->new_layout = 0;
 	mddev->new_chunk_sectors = mddev->chunk_sectors;
 	mddev->delta_disks = - mddev->raid_disks / 2;
 	mddev->raid_disks += mddev->delta_disks;
@@ -643,19 +641,22 @@
 	mddev->recovery_cp = MaxSector;
 
 	create_strip_zones(mddev, &priv_conf);
-	priv_conf->scale_raid_disks = 2;
 	return priv_conf;
 }
 
 static void *raid0_takeover(mddev_t *mddev)
 {
 	/* raid0 can take over:
+	 *  raid4 - if all data disks are active.
 	 *  raid5 - providing it is Raid4 layout and one disk is faulty
 	 *  raid10 - assuming we have all necessary active disks
 	 */
+	if (mddev->level == 4)
+		return raid0_takeover_raid45(mddev);
+
 	if (mddev->level == 5) {
 		if (mddev->layout == ALGORITHM_PARITY_N)
-			return raid0_takeover_raid5(mddev);
+			return raid0_takeover_raid45(mddev);
 
 		printk(KERN_ERR "md/raid0:%s: Raid can only takeover Raid5 with layout: %d\n",
 		       mdname(mddev), ALGORITHM_PARITY_N);
diff -urN linux-2.6.35-rc3/drivers/md/raid0.h linux-2.6.35-rc4/drivers/md/raid0.h
--- linux-2.6.35-rc3/drivers/md/raid0.h	2010-07-05 05:34:21.983868641 +0000
+++ linux-2.6.35-rc4/drivers/md/raid0.h	2010-05-16 21:17:36.000000000 +0000
@@ -13,9 +13,6 @@
 	struct strip_zone *strip_zone;
 	mdk_rdev_t **devlist; /* lists of rdevs, pointed to by strip_zone->dev */
 	int nr_strip_zones;
-	int scale_raid_disks; /* divide rdev->raid_disks by this in run()
-			       * to handle conversion from raid10
-			       */
 };
 
 typedef struct raid0_private_data raid0_conf_t;
diff -urN linux-2.6.35-rc3/drivers/md/raid10.c linux-2.6.35-rc4/drivers/md/raid10.c
--- linux-2.6.35-rc3/drivers/md/raid10.c	2010-07-05 05:34:21.985868454 +0000
+++ linux-2.6.35-rc4/drivers/md/raid10.c	2010-07-05 05:34:27.373868059 +0000
@@ -1482,14 +1482,14 @@
 	int sectors = r10_bio->sectors;
 	mdk_rdev_t*rdev;
 	int max_read_errors = atomic_read(&mddev->max_corr_read_errors);
+	int d = r10_bio->devs[r10_bio->read_slot].devnum;
 
 	rcu_read_lock();
-	{
-		int d = r10_bio->devs[r10_bio->read_slot].devnum;
+	rdev = rcu_dereference(conf->mirrors[d].rdev);
+	if (rdev) { /* If rdev is not NULL */
 		char b[BDEVNAME_SIZE];
 		int cur_read_error_count = 0;
 
-		rdev = rcu_dereference(conf->mirrors[d].rdev);
 		bdevname(rdev->bdev, b);
 
 		if (test_bit(Faulty, &rdev->flags)) {
@@ -1530,7 +1530,7 @@
 
 		rcu_read_lock();
 		do {
-			int d = r10_bio->devs[sl].devnum;
+			d = r10_bio->devs[sl].devnum;
 			rdev = rcu_dereference(conf->mirrors[d].rdev);
 			if (rdev &&
 			    test_bit(In_sync, &rdev->flags)) {
@@ -1564,7 +1564,7 @@
 		rcu_read_lock();
 		while (sl != r10_bio->read_slot) {
 			char b[BDEVNAME_SIZE];
-			int d;
+
 			if (sl==0)
 				sl = conf->copies;
 			sl--;
@@ -1601,7 +1601,7 @@
 		}
 		sl = start;
 		while (sl != r10_bio->read_slot) {
-			int d;
+
 			if (sl==0)
 				sl = conf->copies;
 			sl--;
@@ -2161,22 +2161,22 @@
 	sector_t stride, size;
 	int err = -EINVAL;
 
-	if (mddev->chunk_sectors < (PAGE_SIZE >> 9) ||
-	    !is_power_of_2(mddev->chunk_sectors)) {
+	if (mddev->new_chunk_sectors < (PAGE_SIZE >> 9) ||
+	    !is_power_of_2(mddev->new_chunk_sectors)) {
 		printk(KERN_ERR "md/raid10:%s: chunk size must be "
 		       "at least PAGE_SIZE(%ld) and be a power of 2.\n",
 		       mdname(mddev), PAGE_SIZE);
 		goto out;
 	}
 
-	nc = mddev->layout & 255;
-	fc = (mddev->layout >> 8) & 255;
-	fo = mddev->layout & (1<<16);
+	nc = mddev->new_layout & 255;
+	fc = (mddev->new_layout >> 8) & 255;
+	fo = mddev->new_layout & (1<<16);
 
 	if ((nc*fc) <2 || (nc*fc) > mddev->raid_disks ||
-	    (mddev->layout >> 17)) {
+	    (mddev->new_layout >> 17)) {
 		printk(KERN_ERR "md/raid10:%s: unsupported raid10 layout: 0x%8x\n",
-		       mdname(mddev), mddev->layout);
+		       mdname(mddev), mddev->new_layout);
 		goto out;
 	}
 
@@ -2241,7 +2241,6 @@
 	if (!conf->thread)
 		goto out;
 
-	conf->scale_disks = 0;
 	conf->mddev = mddev;
 	return conf;
 
@@ -2300,11 +2299,6 @@
 		if (disk_idx >= conf->raid_disks
 		    || disk_idx < 0)
 			continue;
-		if (conf->scale_disks) {
-			disk_idx *= conf->scale_disks;
-			rdev->raid_disk = disk_idx;
-			/* MOVE 'rd%d' link !! */
-		}
 		disk = conf->mirrors + disk_idx;
 
 		disk->rdev = rdev;
@@ -2435,26 +2429,22 @@
 		return ERR_PTR(-EINVAL);
 	}
 
-	/* Update slot numbers to obtain
-	 * degraded raid10 with missing mirrors
-	 */
-	list_for_each_entry(rdev, &mddev->disks, same_set) {
-		rdev->raid_disk *= 2;
-	}
-
 	/* Set new parameters */
 	mddev->new_level = 10;
 	/* new layout: far_copies = 1, near_copies = 2 */
 	mddev->new_layout = (1<<8) + 2;
 	mddev->new_chunk_sectors = mddev->chunk_sectors;
 	mddev->delta_disks = mddev->raid_disks;
-	mddev->degraded = mddev->raid_disks;
 	mddev->raid_disks *= 2;
 	/* make sure it will be not marked as dirty */
 	mddev->recovery_cp = MaxSector;
 
 	conf = setup_conf(mddev);
-	conf->scale_disks = 2;
+	if (!IS_ERR(conf))
+		list_for_each_entry(rdev, &mddev->disks, same_set)
+			if (rdev->raid_disk >= 0)
+				rdev->new_raid_disk = rdev->raid_disk * 2;
+		
 	return conf;
 }
 
diff -urN linux-2.6.35-rc3/drivers/md/raid10.h linux-2.6.35-rc4/drivers/md/raid10.h
--- linux-2.6.35-rc3/drivers/md/raid10.h	2010-07-05 05:34:21.985868454 +0000
+++ linux-2.6.35-rc4/drivers/md/raid10.h	2010-07-05 05:34:27.373868059 +0000
@@ -38,11 +38,6 @@
 	int chunk_shift; /* shift from chunks to sectors */
 	sector_t chunk_mask;
 
-	int			scale_disks;  /* When starting array, multiply
-					       * each ->raid_disk by this.
-					       * Need for raid0->raid10 migration
-					       */
-
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
 	struct bio_list		pending_bio_list;
diff -urN linux-2.6.35-rc3/drivers/md/raid5.c linux-2.6.35-rc4/drivers/md/raid5.c
--- linux-2.6.35-rc3/drivers/md/raid5.c	2010-07-05 05:34:21.987805686 +0000
+++ linux-2.6.35-rc4/drivers/md/raid5.c	2010-07-05 05:34:27.374868080 +0000
@@ -277,12 +277,13 @@
 	return sh;
 }
 
-static void shrink_buffers(struct stripe_head *sh, int num)
+static void shrink_buffers(struct stripe_head *sh)
 {
 	struct page *p;
 	int i;
+	int num = sh->raid_conf->pool_size;
 
-	for (i=0; i<num ; i++) {
+	for (i = 0; i < num ; i++) {
 		p = sh->dev[i].page;
 		if (!p)
 			continue;
@@ -291,11 +292,12 @@
 	}
 }
 
-static int grow_buffers(struct stripe_head *sh, int num)
+static int grow_buffers(struct stripe_head *sh)
 {
 	int i;
+	int num = sh->raid_conf->pool_size;
 
-	for (i=0; i<num; i++) {
+	for (i = 0; i < num; i++) {
 		struct page *page;
 
 		if (!(page = alloc_page(GFP_KERNEL))) {
@@ -364,6 +366,73 @@
 	return NULL;
 }
 
+/*
+ * Need to check if array has failed when deciding whether to:
+ *  - start an array
+ *  - remove non-faulty devices
+ *  - add a spare
+ *  - allow a reshape
+ * This determination is simple when no reshape is happening.
+ * However if there is a reshape, we need to carefully check
+ * both the before and after sections.
+ * This is because some failed devices may only affect one
+ * of the two sections, and some non-in_sync devices may
+ * be insync in the section most affected by failed devices.
+ */
+static int has_failed(raid5_conf_t *conf)
+{
+	int degraded;
+	int i;
+	if (conf->mddev->reshape_position == MaxSector)
+		return conf->mddev->degraded > conf->max_degraded;
+
+	rcu_read_lock();
+	degraded = 0;
+	for (i = 0; i < conf->previous_raid_disks; i++) {
+		mdk_rdev_t *rdev = rcu_dereference(conf->disks[i].rdev);
+		if (!rdev || test_bit(Faulty, &rdev->flags))
+			degraded++;
+		else if (test_bit(In_sync, &rdev->flags))
+			;
+		else
+			/* not in-sync or faulty.
+			 * If the reshape increases the number of devices,
+			 * this is being recovered by the reshape, so
+			 * this 'previous' section is not in_sync.
+			 * If the number of devices is being reduced however,
+			 * the device can only be part of the array if
+			 * we are reverting a reshape, so this section will
+			 * be in-sync.
+			 */
+			if (conf->raid_disks >= conf->previous_raid_disks)
+				degraded++;
+	}
+	rcu_read_unlock();
+	if (degraded > conf->max_degraded)
+		return 1;
+	rcu_read_lock();
+	degraded = 0;
+	for (i = 0; i < conf->raid_disks; i++) {
+		mdk_rdev_t *rdev = rcu_dereference(conf->disks[i].rdev);
+		if (!rdev || test_bit(Faulty, &rdev->flags))
+			degraded++;
+		else if (test_bit(In_sync, &rdev->flags))
+			;
+		else
+			/* not in-sync or faulty.
+			 * If reshape increases the number of devices, this
+			 * section has already been recovered, else it
+			 * almost certainly hasn't.
+			 */
+			if (conf->raid_disks <= conf->previous_raid_disks)
+				degraded++;
+	}
+	rcu_read_unlock();
+	if (degraded > conf->max_degraded)
+		return 1;
+	return 0;
+}
+
 static void unplug_slaves(mddev_t *mddev);
 static void raid5_unplug_device(struct request_queue *q);
 
@@ -1240,19 +1309,18 @@
 static int grow_one_stripe(raid5_conf_t *conf)
 {
 	struct stripe_head *sh;
-	int disks = max(conf->raid_disks, conf->previous_raid_disks);
 	sh = kmem_cache_alloc(conf->slab_cache, GFP_KERNEL);
 	if (!sh)
 		return 0;
-	memset(sh, 0, sizeof(*sh) + (disks-1)*sizeof(struct r5dev));
+	memset(sh, 0, sizeof(*sh) + (conf->pool_size-1)*sizeof(struct r5dev));
 	sh->raid_conf = conf;
 	spin_lock_init(&sh->lock);
 	#ifdef CONFIG_MULTICORE_RAID456
 	init_waitqueue_head(&sh->ops.wait_for_ops);
 	#endif
 
-	if (grow_buffers(sh, disks)) {
-		shrink_buffers(sh, disks);
+	if (grow_buffers(sh)) {
+		shrink_buffers(sh);
 		kmem_cache_free(conf->slab_cache, sh);
 		return 0;
 	}
@@ -1468,7 +1536,7 @@
 	if (!sh)
 		return 0;
 	BUG_ON(atomic_read(&sh->count));
-	shrink_buffers(sh, conf->pool_size);
+	shrink_buffers(sh);
 	kmem_cache_free(conf->slab_cache, sh);
 	atomic_dec(&conf->active_stripes);
 	return 1;
@@ -2963,7 +3031,6 @@
 		mdk_rdev_t *rdev;
 
 		dev = &sh->dev[i];
-		clear_bit(R5_Insync, &dev->flags);
 
 		pr_debug("check %d: state 0x%lx toread %p read %p write %p "
 			"written %p\n",	i, dev->flags, dev->toread, dev->read,
@@ -3000,17 +3067,27 @@
 			blocked_rdev = rdev;
 			atomic_inc(&rdev->nr_pending);
 		}
-		if (!rdev || !test_bit(In_sync, &rdev->flags)) {
+		clear_bit(R5_Insync, &dev->flags);
+		if (!rdev)
+			/* Not in-sync */;
+		else if (test_bit(In_sync, &rdev->flags))
+			set_bit(R5_Insync, &dev->flags);
+		else {
+			/* could be in-sync depending on recovery/reshape status */
+			if (sh->sector + STRIPE_SECTORS <= rdev->recovery_offset)
+				set_bit(R5_Insync, &dev->flags);
+		}
+		if (!test_bit(R5_Insync, &dev->flags)) {
 			/* The ReadError flag will just be confusing now */
 			clear_bit(R5_ReadError, &dev->flags);
 			clear_bit(R5_ReWrite, &dev->flags);
 		}
-		if (!rdev || !test_bit(In_sync, &rdev->flags)
-		    || test_bit(R5_ReadError, &dev->flags)) {
+		if (test_bit(R5_ReadError, &dev->flags))
+			clear_bit(R5_Insync, &dev->flags);
+		if (!test_bit(R5_Insync, &dev->flags)) {
 			s.failed++;
 			s.failed_num = i;
-		} else
-			set_bit(R5_Insync, &dev->flags);
+		}
 	}
 	rcu_read_unlock();
 
@@ -3244,7 +3321,6 @@
 	for (i=disks; i--; ) {
 		mdk_rdev_t *rdev;
 		dev = &sh->dev[i];
-		clear_bit(R5_Insync, &dev->flags);
 
 		pr_debug("check %d: state 0x%lx read %p write %p written %p\n",
 			i, dev->flags, dev->toread, dev->towrite, dev->written);
@@ -3282,18 +3358,28 @@
 			blocked_rdev = rdev;
 			atomic_inc(&rdev->nr_pending);
 		}
-		if (!rdev || !test_bit(In_sync, &rdev->flags)) {
+		clear_bit(R5_Insync, &dev->flags);
+		if (!rdev)
+			/* Not in-sync */;
+		else if (test_bit(In_sync, &rdev->flags))
+			set_bit(R5_Insync, &dev->flags);
+		else {
+			/* in sync if before recovery_offset */
+			if (sh->sector + STRIPE_SECTORS <= rdev->recovery_offset)
+				set_bit(R5_Insync, &dev->flags);
+		}
+		if (!test_bit(R5_Insync, &dev->flags)) {
 			/* The ReadError flag will just be confusing now */
 			clear_bit(R5_ReadError, &dev->flags);
 			clear_bit(R5_ReWrite, &dev->flags);
 		}
-		if (!rdev || !test_bit(In_sync, &rdev->flags)
-		    || test_bit(R5_ReadError, &dev->flags)) {
+		if (test_bit(R5_ReadError, &dev->flags))
+			clear_bit(R5_Insync, &dev->flags);
+		if (!test_bit(R5_Insync, &dev->flags)) {
 			if (s.failed < 2)
 				r6s.failed_num[s.failed] = i;
 			s.failed++;
-		} else
-			set_bit(R5_Insync, &dev->flags);
+		}
 	}
 	rcu_read_unlock();
 
@@ -4971,8 +5057,10 @@
 	list_for_each_entry(rdev, &mddev->disks, same_set) {
 		if (rdev->raid_disk < 0)
 			continue;
-		if (test_bit(In_sync, &rdev->flags))
+		if (test_bit(In_sync, &rdev->flags)) {
 			working_disks++;
+			continue;
+		}
 		/* This disc is not fully in-sync.  However if it
 		 * just stored parity (beyond the recovery_offset),
 		 * when we don't need to be concerned about the
@@ -5005,7 +5093,7 @@
 	mddev->degraded = (max(conf->raid_disks, conf->previous_raid_disks)
 			   - working_disks);
 
-	if (mddev->degraded > conf->max_degraded) {
+	if (has_failed(conf)) {
 		printk(KERN_ERR "md/raid:%s: not enough operational devices"
 			" (%d/%d failed)\n",
 			mdname(mddev), mddev->degraded, conf->raid_disks);
@@ -5207,6 +5295,7 @@
 	for (i = 0; i < conf->raid_disks; i++) {
 		tmp = conf->disks + i;
 		if (tmp->rdev
+		    && tmp->rdev->recovery_offset == MaxSector
 		    && !test_bit(Faulty, &tmp->rdev->flags)
 		    && !test_and_set_bit(In_sync, &tmp->rdev->flags)) {
 			unsigned long flags;
@@ -5242,7 +5331,7 @@
 		 * isn't possible.
 		 */
 		if (!test_bit(Faulty, &rdev->flags) &&
-		    mddev->degraded <= conf->max_degraded &&
+		    !has_failed(conf) &&
 		    number < conf->raid_disks) {
 			err = -EBUSY;
 			goto abort;
@@ -5270,7 +5359,7 @@
 	int first = 0;
 	int last = conf->raid_disks - 1;
 
-	if (mddev->degraded > conf->max_degraded)
+	if (has_failed(conf))
 		/* no point adding a device */
 		return -EINVAL;
 
@@ -5362,7 +5451,7 @@
 	if (mddev->bitmap)
 		/* Cannot grow a bitmap yet */
 		return -EBUSY;
-	if (mddev->degraded > conf->max_degraded)
+	if (has_failed(conf))
 		return -EINVAL;
 	if (mddev->delta_disks < 0) {
 		/* We might be able to shrink, but the devices must
@@ -5437,8 +5526,13 @@
 
 	/* Add some new drives, as many as will fit.
 	 * We know there are enough to make the newly sized array work.
+	 * Don't add devices if we are reducing the number of
+	 * devices in the array.  This is because it is not possible
+	 * to correctly record the "partially reconstructed" state of
+	 * such devices during the reshape and confusion could result.
 	 */
-	list_for_each_entry(rdev, &mddev->disks, same_set)
+	if (mddev->delta_disks >= 0)
+	    list_for_each_entry(rdev, &mddev->disks, same_set)
 		if (rdev->raid_disk < 0 &&
 		    !test_bit(Faulty, &rdev->flags)) {
 			if (raid5_add_disk(mddev, rdev) == 0) {
@@ -5460,7 +5554,7 @@
 		}
 
 	/* When a reshape changes the number of devices, ->degraded
-	 * is measured against the large of the pre and post number of
+	 * is measured against the larger of the pre and post number of
 	 * devices.*/
 	if (mddev->delta_disks > 0) {
 		spin_lock_irqsave(&conf->device_lock, flags);
diff -urN linux-2.6.35-rc3/drivers/net/Kconfig linux-2.6.35-rc4/drivers/net/Kconfig
--- linux-2.6.35-rc3/drivers/net/Kconfig	2010-07-05 05:34:22.148810537 +0000
+++ linux-2.6.35-rc4/drivers/net/Kconfig	2010-07-05 05:34:27.512868080 +0000
@@ -2754,6 +2754,7 @@
 config NETXEN_NIC
 	tristate "NetXen Multi port (1/10) Gigabit Ethernet NIC"
 	depends on PCI
+	select FW_LOADER
 	help
 	  This enables the support for NetXen's Gigabit Ethernet card.
 
@@ -2819,6 +2820,7 @@
 config QLCNIC
 	tristate "QLOGIC QLCNIC 1/10Gb Converged Ethernet NIC Support"
 	depends on PCI
+	select FW_LOADER
 	help
 	  This driver supports QLogic QLE8240 and QLE8242 Converged Ethernet
 	  devices.
diff -urN linux-2.6.35-rc3/drivers/net/bnx2.c linux-2.6.35-rc4/drivers/net/bnx2.c
--- linux-2.6.35-rc3/drivers/net/bnx2.c	2010-07-05 05:34:22.160805572 +0000
+++ linux-2.6.35-rc4/drivers/net/bnx2.c	2010-07-05 05:34:27.524807607 +0000
@@ -3073,7 +3073,6 @@
 	u16 hw_cons, sw_cons, sw_ring_cons, sw_prod, sw_ring_prod;
 	struct l2_fhdr *rx_hdr;
 	int rx_pkt = 0, pg_ring_used = 0;
-	struct pci_dev *pdev = bp->pdev;
 
 	hw_cons = bnx2_get_hw_rx_cons(bnapi);
 	sw_cons = rxr->rx_cons;
@@ -3099,12 +3098,10 @@
 		skb = rx_buf->skb;
 		prefetchw(skb);
 
-		if (!get_dma_ops(&pdev->dev)->sync_single_for_cpu) {
-			next_rx_buf =
-				&rxr->rx_buf_ring[
-					RX_RING_IDX(NEXT_RX_BD(sw_cons))];
-			prefetch(next_rx_buf->desc);
-		}
+		next_rx_buf =
+			&rxr->rx_buf_ring[RX_RING_IDX(NEXT_RX_BD(sw_cons))];
+		prefetch(next_rx_buf->desc);
+
 		rx_buf->skb = NULL;
 
 		dma_addr = dma_unmap_addr(rx_buf, mapping);
diff -urN linux-2.6.35-rc3/drivers/net/cnic.c linux-2.6.35-rc4/drivers/net/cnic.c
--- linux-2.6.35-rc3/drivers/net/cnic.c	2010-07-05 05:34:22.175868180 +0000
+++ linux-2.6.35-rc4/drivers/net/cnic.c	2010-07-05 05:34:27.538868058 +0000
@@ -3919,8 +3919,9 @@
 		HC_INDEX_DEF_C_ETH_ISCSI_CQ_CONS;
 	context->cstorm_st_context.status_block_id = BNX2X_DEF_SB_ID;
 
-	context->xstorm_st_context.statistics_data = (cli |
-				XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE);
+	if (cli < MAX_X_STAT_COUNTER_ID)
+		context->xstorm_st_context.statistics_data = cli |
+				XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE;
 
 	context->xstorm_ag_context.cdu_reserved =
 		CDU_RSRVD_VALUE_TYPE_A(BNX2X_HW_CID(BNX2X_ISCSI_L2_CID, func),
@@ -3928,10 +3929,12 @@
 					ETH_CONNECTION_TYPE);
 
 	/* reset xstorm per client statistics */
-	val = BAR_XSTRORM_INTMEM +
-	      XSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-	for (i = 0; i < sizeof(struct xstorm_per_client_stats) / 4; i++)
-		CNIC_WR(dev, val + i * 4, 0);
+	if (cli < MAX_X_STAT_COUNTER_ID) {
+		val = BAR_XSTRORM_INTMEM +
+		      XSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
+		for (i = 0; i < sizeof(struct xstorm_per_client_stats) / 4; i++)
+			CNIC_WR(dev, val + i * 4, 0);
+	}
 
 	cp->tx_cons_ptr =
 		&cp->bnx2x_def_status_blk->c_def_status_block.index_values[
@@ -3978,9 +3981,11 @@
 						BNX2X_ISCSI_RX_SB_INDEX_NUM;
 	context->ustorm_st_context.common.clientId = cli;
 	context->ustorm_st_context.common.status_block_id = BNX2X_DEF_SB_ID;
-	context->ustorm_st_context.common.flags =
-		USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS;
-	context->ustorm_st_context.common.statistics_counter_id = cli;
+	if (cli < MAX_U_STAT_COUNTER_ID) {
+		context->ustorm_st_context.common.flags =
+			USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS;
+		context->ustorm_st_context.common.statistics_counter_id = cli;
+	}
 	context->ustorm_st_context.common.mc_alignment_log_size = 0;
 	context->ustorm_st_context.common.bd_buff_size =
 						cp->l2_single_buf_size;
@@ -4011,10 +4016,13 @@
 
 	/* client tstorm info */
 	tstorm_client.mtu = cp->l2_single_buf_size - 14;
-	tstorm_client.config_flags =
-			(TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE |
-			TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE);
-	tstorm_client.statistics_counter_id = cli;
+	tstorm_client.config_flags = TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE;
+
+	if (cli < MAX_T_STAT_COUNTER_ID) {
+		tstorm_client.config_flags |=
+				TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE;
+		tstorm_client.statistics_counter_id = cli;
+	}
 
 	CNIC_WR(dev, BAR_TSTRORM_INTMEM +
 		   TSTORM_CLIENT_CONFIG_OFFSET(port, cli),
@@ -4024,16 +4032,21 @@
 		   ((u32 *)&tstorm_client)[1]);
 
 	/* reset tstorm per client statistics */
-	val = BAR_TSTRORM_INTMEM +
-	      TSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-	for (i = 0; i < sizeof(struct tstorm_per_client_stats) / 4; i++)
-		CNIC_WR(dev, val + i * 4, 0);
+	if (cli < MAX_T_STAT_COUNTER_ID) {
+
+		val = BAR_TSTRORM_INTMEM +
+		      TSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
+		for (i = 0; i < sizeof(struct tstorm_per_client_stats) / 4; i++)
+			CNIC_WR(dev, val + i * 4, 0);
+	}
 
 	/* reset ustorm per client statistics */
-	val = BAR_USTRORM_INTMEM +
-	      USTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-	for (i = 0; i < sizeof(struct ustorm_per_client_stats) / 4; i++)
-		CNIC_WR(dev, val + i * 4, 0);
+	if (cli < MAX_U_STAT_COUNTER_ID) {
+		val = BAR_USTRORM_INTMEM +
+		      USTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
+		for (i = 0; i < sizeof(struct ustorm_per_client_stats) / 4; i++)
+			CNIC_WR(dev, val + i * 4, 0);
+	}
 
 	cp->rx_cons_ptr =
 		&cp->bnx2x_def_status_blk->u_def_status_block.index_values[
diff -urN linux-2.6.35-rc3/drivers/net/cpmac.c linux-2.6.35-rc4/drivers/net/cpmac.c
--- linux-2.6.35-rc3/drivers/net/cpmac.c	2010-07-05 05:34:22.175868180 +0000
+++ linux-2.6.35-rc4/drivers/net/cpmac.c	2010-07-05 05:34:27.539868088 +0000
@@ -1181,7 +1181,8 @@
 		if (netif_msg_drv(priv))
 			printk(KERN_ERR "%s: Could not attach to PHY\n",
 			       dev->name);
-		return PTR_ERR(priv->phy);
+		rc = PTR_ERR(priv->phy);
+		goto fail;
 	}
 
 	if ((rc = register_netdev(dev))) {
diff -urN linux-2.6.35-rc3/drivers/net/e1000/e1000_main.c linux-2.6.35-rc4/drivers/net/e1000/e1000_main.c
--- linux-2.6.35-rc3/drivers/net/e1000/e1000_main.c	2010-07-05 05:34:22.186806535 +0000
+++ linux-2.6.35-rc4/drivers/net/e1000/e1000_main.c	2010-07-05 05:34:27.549868052 +0000
@@ -1047,15 +1047,14 @@
 		goto err_register;
 
 	/* print bus type/speed/width info */
-	e_info("(PCI%s:%s:%s) ",
-		((hw->bus_type == e1000_bus_type_pcix) ? "-X" : ""),
-		((hw->bus_speed == e1000_bus_speed_133) ? "133MHz" :
-		 (hw->bus_speed == e1000_bus_speed_120) ? "120MHz" :
-		 (hw->bus_speed == e1000_bus_speed_100) ? "100MHz" :
-		 (hw->bus_speed == e1000_bus_speed_66) ? "66MHz" : "33MHz"),
-		((hw->bus_width == e1000_bus_width_64) ? "64-bit" : "32-bit"));
-
-	e_info("%pM\n", netdev->dev_addr);
+	e_info("(PCI%s:%dMHz:%d-bit) %pM\n",
+	       ((hw->bus_type == e1000_bus_type_pcix) ? "-X" : ""),
+	       ((hw->bus_speed == e1000_bus_speed_133) ? 133 :
+		(hw->bus_speed == e1000_bus_speed_120) ? 120 :
+		(hw->bus_speed == e1000_bus_speed_100) ? 100 :
+		(hw->bus_speed == e1000_bus_speed_66) ? 66 : 33),
+	       ((hw->bus_width == e1000_bus_width_64) ? 64 : 32),
+	       netdev->dev_addr);
 
 	/* carrier off reporting is important to ethtool even BEFORE open */
 	netif_carrier_off(netdev);
diff -urN linux-2.6.35-rc3/drivers/net/ehea/ehea.h linux-2.6.35-rc4/drivers/net/ehea/ehea.h
--- linux-2.6.35-rc3/drivers/net/ehea/ehea.h	2010-07-05 05:34:22.192805264 +0000
+++ linux-2.6.35-rc4/drivers/net/ehea/ehea.h	2010-07-05 05:34:27.556868095 +0000
@@ -40,7 +40,7 @@
 #include <asm/io.h>
 
 #define DRV_NAME	"ehea"
-#define DRV_VERSION	"EHEA_0103"
+#define DRV_VERSION	"EHEA_0105"
 
 /* eHEA capability flags */
 #define DLPAR_PORT_ADD_REM 1
diff -urN linux-2.6.35-rc3/drivers/net/ehea/ehea_main.c linux-2.6.35-rc4/drivers/net/ehea/ehea_main.c
--- linux-2.6.35-rc3/drivers/net/ehea/ehea_main.c	2010-07-05 05:34:22.193805479 +0000
+++ linux-2.6.35-rc4/drivers/net/ehea/ehea_main.c	2010-07-05 05:34:27.556868095 +0000
@@ -867,6 +867,7 @@
 		ehea_reset_cq_ep(pr->send_cq);
 		ehea_reset_cq_n1(pr->recv_cq);
 		ehea_reset_cq_n1(pr->send_cq);
+		rmb();
 		cqe = ehea_poll_rq1(pr->qp, &wqe_index);
 		cqe_skb = ehea_poll_cq(pr->send_cq);
 
@@ -2859,6 +2860,7 @@
 		container_of(work, struct ehea_port, reset_task);
 	struct net_device *dev = port->netdev;
 
+	mutex_lock(&dlpar_mem_lock);
 	port->resets++;
 	mutex_lock(&port->port_lock);
 	netif_stop_queue(dev);
@@ -2881,6 +2883,7 @@
 	netif_wake_queue(dev);
 out:
 	mutex_unlock(&port->port_lock);
+	mutex_unlock(&dlpar_mem_lock);
 }
 
 static void ehea_rereg_mrs(struct work_struct *work)
@@ -3542,10 +3545,7 @@
 	int ret = NOTIFY_BAD;
 	struct memory_notify *arg = data;
 
-	if (!mutex_trylock(&dlpar_mem_lock)) {
-		ehea_info("ehea_mem_notifier must not be called parallelized");
-		goto out;
-	}
+	mutex_lock(&dlpar_mem_lock);
 
 	switch (action) {
 	case MEM_CANCEL_OFFLINE:
@@ -3574,7 +3574,6 @@
 
 out_unlock:
 	mutex_unlock(&dlpar_mem_lock);
-out:
 	return ret;
 }
 
diff -urN linux-2.6.35-rc3/drivers/net/enic/vnic_dev.c linux-2.6.35-rc4/drivers/net/enic/vnic_dev.c
--- linux-2.6.35-rc3/drivers/net/enic/vnic_dev.c	2010-07-05 05:34:22.195868167 +0000
+++ linux-2.6.35-rc4/drivers/net/enic/vnic_dev.c	2010-07-05 05:34:27.558805246 +0000
@@ -709,7 +709,7 @@
 {
 	u64 a0, a1 = len;
 	int wait = 1000;
-	u64 prov_pa;
+	dma_addr_t prov_pa;
 	void *prov_buf;
 	int ret;
 
diff -urN linux-2.6.35-rc3/drivers/net/gianfar.c linux-2.6.35-rc4/drivers/net/gianfar.c
--- linux-2.6.35-rc3/drivers/net/gianfar.c	2010-07-05 05:34:22.201868092 +0000
+++ linux-2.6.35-rc4/drivers/net/gianfar.c	2010-07-05 05:34:27.564868543 +0000
@@ -381,10 +381,14 @@
 	/* Insert receive time stamps into padding alignment bytes */
 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER) {
 		rctrl &= ~RCTRL_PAL_MASK;
-		rctrl |= RCTRL_PRSDEP_INIT | RCTRL_TS_ENABLE | RCTRL_PADDING(8);
+		rctrl |= RCTRL_PADDING(8);
 		priv->padding = 8;
 	}
 
+	/* Enable HW time stamping if requested from user space */
+	if (priv->hwts_rx_en)
+		rctrl |= RCTRL_PRSDEP_INIT | RCTRL_TS_ENABLE;
+
 	/* keep vlan related bits if it's enabled */
 	if (priv->vlgrp) {
 		rctrl |= RCTRL_VLEX | RCTRL_PRSDEP_INIT;
@@ -747,7 +751,8 @@
 			FSL_GIANFAR_DEV_HAS_CSUM |
 			FSL_GIANFAR_DEV_HAS_VLAN |
 			FSL_GIANFAR_DEV_HAS_MAGIC_PACKET |
-			FSL_GIANFAR_DEV_HAS_EXTENDED_HASH;
+			FSL_GIANFAR_DEV_HAS_EXTENDED_HASH |
+			FSL_GIANFAR_DEV_HAS_TIMER;
 
 	ctype = of_get_property(np, "phy-connection-type", NULL);
 
@@ -805,12 +810,20 @@
 
 	switch (config.rx_filter) {
 	case HWTSTAMP_FILTER_NONE:
-		priv->hwts_rx_en = 0;
+		if (priv->hwts_rx_en) {
+			stop_gfar(netdev);
+			priv->hwts_rx_en = 0;
+			startup_gfar(netdev);
+		}
 		break;
 	default:
 		if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER))
 			return -ERANGE;
-		priv->hwts_rx_en = 1;
+		if (!priv->hwts_rx_en) {
+			stop_gfar(netdev);
+			priv->hwts_rx_en = 1;
+			startup_gfar(netdev);
+		}
 		config.rx_filter = HWTSTAMP_FILTER_ALL;
 		break;
 	}
@@ -2642,6 +2655,10 @@
 		dma_unmap_single(&priv->ofdev->dev, bdp->bufPtr,
 				priv->rx_buffer_size, DMA_FROM_DEVICE);
 
+		if (unlikely(!(bdp->status & RXBD_ERR) &&
+				bdp->length > priv->rx_buffer_size))
+			bdp->status = RXBD_LARGE;
+
 		/* We drop the frame if we failed to allocate a new buffer */
 		if (unlikely(!newskb || !(bdp->status & RXBD_LAST) ||
 				 bdp->status & RXBD_ERR)) {
diff -urN linux-2.6.35-rc3/drivers/net/ixgbe/ixgbe_ethtool.c linux-2.6.35-rc4/drivers/net/ixgbe/ixgbe_ethtool.c
--- linux-2.6.35-rc3/drivers/net/ixgbe/ixgbe_ethtool.c	2010-07-05 05:34:22.219868122 +0000
+++ linux-2.6.35-rc4/drivers/net/ixgbe/ixgbe_ethtool.c	2010-07-05 05:34:27.582868101 +0000
@@ -2077,25 +2077,6 @@
 	return 0;
 }
 
-/*
- * this function must be called before setting the new value of
- * rx_itr_setting
- */
-static bool ixgbe_reenable_rsc(struct ixgbe_adapter *adapter,
-                               struct ethtool_coalesce *ec)
-{
-	/* check the old value and enable RSC if necessary */
-	if ((adapter->rx_itr_setting == 0) &&
-	    (adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE)) {
-		adapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;
-		adapter->netdev->features |= NETIF_F_LRO;
-		DPRINTK(PROBE, INFO, "rx-usecs set to %d, re-enabling RSC\n",
-		        ec->rx_coalesce_usecs);
-		return true;
-	}
-	return false;
-}
-
 static int ixgbe_set_coalesce(struct net_device *netdev,
                               struct ethtool_coalesce *ec)
 {
@@ -2124,9 +2105,6 @@
 		    (1000000/ec->rx_coalesce_usecs < IXGBE_MIN_INT_RATE))
 			return -EINVAL;
 
-		/* check the old value and enable RSC if necessary */
-		need_reset = ixgbe_reenable_rsc(adapter, ec);
-
 		/* store the value in ints/second */
 		adapter->rx_eitr_param = 1000000/ec->rx_coalesce_usecs;
 
@@ -2135,9 +2113,6 @@
 		/* clear the lower bit as its used for dynamic state */
 		adapter->rx_itr_setting &= ~1;
 	} else if (ec->rx_coalesce_usecs == 1) {
-		/* check the old value and enable RSC if necessary */
-		need_reset = ixgbe_reenable_rsc(adapter, ec);
-
 		/* 1 means dynamic mode */
 		adapter->rx_eitr_param = 20000;
 		adapter->rx_itr_setting = 1;
@@ -2157,10 +2132,11 @@
 		 */
 		if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
 			adapter->flags2 &= ~IXGBE_FLAG2_RSC_ENABLED;
-			netdev->features &= ~NETIF_F_LRO;
-			DPRINTK(PROBE, INFO,
-			        "rx-usecs set to 0, disabling RSC\n");
-
+			if (netdev->features & NETIF_F_LRO) {
+				netdev->features &= ~NETIF_F_LRO;
+				DPRINTK(PROBE, INFO, "rx-usecs set to 0, "
+					"disabling LRO/RSC\n");
+			}
 			need_reset = true;
 		}
 	}
@@ -2255,6 +2231,9 @@
 			}
 		} else if (!adapter->rx_itr_setting) {
 			netdev->features &= ~ETH_FLAG_LRO;
+			if (data & ETH_FLAG_LRO)
+				DPRINTK(PROBE, INFO, "rx-usecs set to 0, "
+					"LRO/RSC cannot be enabled.\n");
 		}
 	}
 
diff -urN linux-2.6.35-rc3/drivers/net/ixgbe/ixgbe_main.c linux-2.6.35-rc4/drivers/net/ixgbe/ixgbe_main.c
--- linux-2.6.35-rc3/drivers/net/ixgbe/ixgbe_main.c	2010-07-05 05:34:22.221867844 +0000
+++ linux-2.6.35-rc4/drivers/net/ixgbe/ixgbe_main.c	2010-07-05 05:34:27.583868046 +0000
@@ -5282,6 +5282,10 @@
 	u32 i, missed_rx = 0, mpc, bprc, lxon, lxoff, xon_off_tot;
 	u64 non_eop_descs = 0, restart_queue = 0;
 
+	if (test_bit(__IXGBE_DOWN, &adapter->state) ||
+	    test_bit(__IXGBE_RESETTING, &adapter->state))
+		return;
+
 	if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
 		u64 rsc_count = 0;
 		u64 rsc_flush = 0;
diff -urN linux-2.6.35-rc3/drivers/net/ixgbe/ixgbe_phy.c linux-2.6.35-rc4/drivers/net/ixgbe/ixgbe_phy.c
--- linux-2.6.35-rc3/drivers/net/ixgbe/ixgbe_phy.c	2010-07-05 05:34:22.221867844 +0000
+++ linux-2.6.35-rc4/drivers/net/ixgbe/ixgbe_phy.c	2010-07-05 05:34:27.584813402 +0000
@@ -575,6 +575,8 @@
 		 * 4    SFP_DA_CORE1 - 82599-specific
 		 * 5    SFP_SR/LR_CORE0 - 82599-specific
 		 * 6    SFP_SR/LR_CORE1 - 82599-specific
+		 * 7    SFP_act_lmt_DA_CORE0 - 82599-specific
+		 * 8    SFP_act_lmt_DA_CORE1 - 82599-specific
 		 */
 		if (hw->mac.type == ixgbe_mac_82598EB) {
 			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
diff -urN linux-2.6.35-rc3/drivers/net/lib82596.c linux-2.6.35-rc4/drivers/net/lib82596.c
--- linux-2.6.35-rc3/drivers/net/lib82596.c	2010-07-05 05:34:22.226806739 +0000
+++ linux-2.6.35-rc4/drivers/net/lib82596.c	2010-07-05 05:34:27.589868081 +0000
@@ -1343,7 +1343,7 @@
 	DEB(DEB_MULTI,
 	    printk(KERN_DEBUG
 		   "%s: set multicast list, %d entries, promisc %s, allmulti %s\n",
-		   dev->name, dev->mc_count,
+		   dev->name, netdev_mc_count(dev),
 		   dev->flags & IFF_PROMISC ? "ON" : "OFF",
 		   dev->flags & IFF_ALLMULTI ? "ON" : "OFF"));
 
diff -urN linux-2.6.35-rc3/drivers/net/mipsnet.c linux-2.6.35-rc4/drivers/net/mipsnet.c
--- linux-2.6.35-rc3/drivers/net/mipsnet.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/net/mipsnet.c	2010-07-05 05:34:27.592868029 +0000
@@ -247,7 +247,7 @@
 	.ndo_set_mac_address	= eth_mac_addr,
 };
 
-static int __init mipsnet_probe(struct platform_device *dev)
+static int __devinit mipsnet_probe(struct platform_device *dev)
 {
 	struct net_device *netdev;
 	int err;
diff -urN linux-2.6.35-rc3/drivers/net/netxen/netxen_nic_ctx.c linux-2.6.35-rc4/drivers/net/netxen/netxen_nic_ctx.c
--- linux-2.6.35-rc3/drivers/net/netxen/netxen_nic_ctx.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/net/netxen/netxen_nic_ctx.c	2010-07-05 05:34:27.596868037 +0000
@@ -629,7 +629,8 @@
 	if (addr == NULL) {
 		dev_err(&pdev->dev, "%s: failed to allocate tx desc ring\n",
 				netdev->name);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto err_out_free;
 	}
 
 	tx_ring->desc_head = (struct cmd_desc_type0 *)addr;
diff -urN linux-2.6.35-rc3/drivers/net/netxen/netxen_nic_hw.c linux-2.6.35-rc4/drivers/net/netxen/netxen_nic_hw.c
--- linux-2.6.35-rc3/drivers/net/netxen/netxen_nic_hw.c	2010-07-05 05:34:22.234868090 +0000
+++ linux-2.6.35-rc4/drivers/net/netxen/netxen_nic_hw.c	2010-07-05 05:34:27.597868064 +0000
@@ -1159,9 +1159,6 @@
 
 	window = CRB_HI(off);
 
-	if (adapter->ahw.crb_win == window)
-		return;
-
 	writel(window, addr);
 	if (readl(addr) != window) {
 		if (printk_ratelimit())
@@ -1169,7 +1166,6 @@
 				"failed to set CRB window to %d off 0x%lx\n",
 				window, off);
 	}
-	adapter->ahw.crb_win = window;
 }
 
 static void __iomem *
diff -urN linux-2.6.35-rc3/drivers/net/netxen/netxen_nic_init.c linux-2.6.35-rc4/drivers/net/netxen/netxen_nic_init.c
--- linux-2.6.35-rc3/drivers/net/netxen/netxen_nic_init.c	2010-07-05 05:34:22.234868090 +0000
+++ linux-2.6.35-rc4/drivers/net/netxen/netxen_nic_init.c	2010-07-05 05:34:27.597868064 +0000
@@ -218,7 +218,7 @@
 	if (cmd_buf_arr == NULL) {
 		dev_err(&pdev->dev, "%s: failed to allocate cmd buffer ring\n",
 		       netdev->name);
-		return -ENOMEM;
+		goto err_out;
 	}
 	memset(cmd_buf_arr, 0, TX_BUFF_RINGSIZE(tx_ring));
 	tx_ring->cmd_buf_arr = cmd_buf_arr;
@@ -230,7 +230,7 @@
 	if (rds_ring == NULL) {
 		dev_err(&pdev->dev, "%s: failed to allocate rds ring struct\n",
 		       netdev->name);
-		return -ENOMEM;
+		goto err_out;
 	}
 	recv_ctx->rds_rings = rds_ring;
 
@@ -1805,9 +1805,10 @@
 	netxen_ctx_msg msg = 0;
 	struct list_head *head;
 
+	spin_lock(&rds_ring->lock);
+
 	producer = rds_ring->producer;
 
-	spin_lock(&rds_ring->lock);
 	head = &rds_ring->free_list;
 	while (!list_empty(head)) {
 
@@ -1829,7 +1830,6 @@
 
 		producer = get_next_index(producer, rds_ring->num_desc);
 	}
-	spin_unlock(&rds_ring->lock);
 
 	if (count) {
 		rds_ring->producer = producer;
@@ -1853,6 +1853,8 @@
 					NETXEN_RCV_PRODUCER_OFFSET), msg);
 		}
 	}
+
+	spin_unlock(&rds_ring->lock);
 }
 
 static void
@@ -1864,10 +1866,11 @@
 	int producer, count = 0;
 	struct list_head *head;
 
-	producer = rds_ring->producer;
 	if (!spin_trylock(&rds_ring->lock))
 		return;
 
+	producer = rds_ring->producer;
+
 	head = &rds_ring->free_list;
 	while (!list_empty(head)) {
 
diff -urN linux-2.6.35-rc3/drivers/net/pcmcia/pcnet_cs.c linux-2.6.35-rc4/drivers/net/pcmcia/pcnet_cs.c
--- linux-2.6.35-rc3/drivers/net/pcmcia/pcnet_cs.c	2010-07-05 05:34:22.240868144 +0000
+++ linux-2.6.35-rc4/drivers/net/pcmcia/pcnet_cs.c	2010-07-05 05:34:27.604868056 +0000
@@ -1727,6 +1727,7 @@
 	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, "Psion Dacom", "Gold Card V34 Ethernet", 0xf5f025c2, 0x338e8155, "cis/PCMLM28.cis"),
 	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, "Psion Dacom", "Gold Card V34 Ethernet GSM", 0xf5f025c2, 0x4ae85d35, "cis/PCMLM28.cis"),
 	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, "LINKSYS", "PCMLM28", 0xf7cb0b07, 0x66881874, "cis/PCMLM28.cis"),
+	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(0, "TOSHIBA", "Modem/LAN Card", 0xb4585a1a, 0x53f922f8, "cis/PCMLM28.cis"),
 	PCMCIA_MFC_DEVICE_CIS_PROD_ID12(0, "DAYNA COMMUNICATIONS", "LAN AND MODEM MULTIFUNCTION", 0x8fdf8f89, 0xdd5ed9e8, "cis/DP83903.cis"),
 	PCMCIA_MFC_DEVICE_CIS_PROD_ID4(0, "NSC MF LAN/Modem", 0x58fc6056, "cis/DP83903.cis"),
 	PCMCIA_MFC_DEVICE_CIS_MANF_CARD(0, 0x0175, 0x0000, "cis/DP83903.cis"),
diff -urN linux-2.6.35-rc3/drivers/net/pcmcia/smc91c92_cs.c linux-2.6.35-rc4/drivers/net/pcmcia/smc91c92_cs.c
--- linux-2.6.35-rc3/drivers/net/pcmcia/smc91c92_cs.c	2010-07-05 05:34:22.241868005 +0000
+++ linux-2.6.35-rc4/drivers/net/pcmcia/smc91c92_cs.c	2010-07-05 05:34:27.604868056 +0000
@@ -1505,12 +1505,20 @@
 	writeb(cor & ~COR_IREQ_ENA, smc->base + MOT_LAN + CISREG_COR);
 	writeb(cor, smc->base + MOT_LAN + CISREG_COR);
     }
-#ifdef DOES_NOT_WORK
-    if (smc->base != NULL) { /* Megahertz MFC's */
-	readb(smc->base+MEGAHERTZ_ISR);
-	readb(smc->base+MEGAHERTZ_ISR);
+
+    if ((smc->base != NULL) &&  /* Megahertz MFC's */
+	(smc->manfid == MANFID_MEGAHERTZ) &&
+	(smc->cardid == PRODID_MEGAHERTZ_EM3288)) {
+
+	u_char tmp;
+	tmp = readb(smc->base+MEGAHERTZ_ISR);
+	tmp = readb(smc->base+MEGAHERTZ_ISR);
+
+	/* Retrigger interrupt if needed */
+	writeb(tmp, smc->base + MEGAHERTZ_ISR);
+	writeb(tmp, smc->base + MEGAHERTZ_ISR);
     }
-#endif
+
     spin_unlock(&smc->lock);
     return IRQ_RETVAL(handled);
 }
diff -urN linux-2.6.35-rc3/drivers/net/phy/lxt.c linux-2.6.35-rc4/drivers/net/phy/lxt.c
--- linux-2.6.35-rc3/drivers/net/phy/lxt.c	2010-07-05 05:34:22.242868091 +0000
+++ linux-2.6.35-rc4/drivers/net/phy/lxt.c	2010-07-05 05:34:27.606868068 +0000
@@ -226,6 +226,7 @@
 static struct mdio_device_id lxt_tbl[] = {
 	{ 0x78100000, 0xfffffff0 },
 	{ 0x001378e0, 0xfffffff0 },
+	{ 0x00137a10, 0xfffffff0 },
 	{ }
 };
 
diff -urN linux-2.6.35-rc3/drivers/net/sky2.c linux-2.6.35-rc4/drivers/net/sky2.c
--- linux-2.6.35-rc3/drivers/net/sky2.c	2010-07-05 05:34:22.264867994 +0000
+++ linux-2.6.35-rc4/drivers/net/sky2.c	2010-07-05 05:34:27.628868041 +0000
@@ -717,11 +717,24 @@
 	sky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 }
 
+/* Enable Rx/Tx */
+static void sky2_enable_rx_tx(struct sky2_port *sky2)
+{
+	struct sky2_hw *hw = sky2->hw;
+	unsigned port = sky2->port;
+	u16 reg;
+
+	reg = gma_read16(hw, port, GM_GP_CTRL);
+	reg |= GM_GPCR_RX_ENA | GM_GPCR_TX_ENA;
+	gma_write16(hw, port, GM_GP_CTRL, reg);
+}
+
 /* Force a renegotiation */
 static void sky2_phy_reinit(struct sky2_port *sky2)
 {
 	spin_lock_bh(&sky2->phy_lock);
 	sky2_phy_init(sky2->hw, sky2->port);
+	sky2_enable_rx_tx(sky2);
 	spin_unlock_bh(&sky2->phy_lock);
 }
 
@@ -2040,7 +2053,6 @@
 {
 	struct sky2_hw *hw = sky2->hw;
 	unsigned port = sky2->port;
-	u16 reg;
 	static const char *fc_name[] = {
 		[FC_NONE]	= "none",
 		[FC_TX]		= "tx",
@@ -2048,10 +2060,7 @@
 		[FC_BOTH]	= "both",
 	};
 
-	/* enable Rx/Tx */
-	reg = gma_read16(hw, port, GM_GP_CTRL);
-	reg |= GM_GPCR_RX_ENA | GM_GPCR_TX_ENA;
-	gma_write16(hw, port, GM_GP_CTRL, reg);
+	sky2_enable_rx_tx(sky2);
 
 	gm_phy_write(hw, port, PHY_MARV_INT_MASK, PHY_M_DEF_MSK);
 
diff -urN linux-2.6.35-rc3/drivers/net/tulip/de2104x.c linux-2.6.35-rc4/drivers/net/tulip/de2104x.c
--- linux-2.6.35-rc3/drivers/net/tulip/de2104x.c	2010-07-05 05:34:22.283868069 +0000
+++ linux-2.6.35-rc4/drivers/net/tulip/de2104x.c	2010-07-05 05:34:27.647868033 +0000
@@ -367,8 +367,8 @@
 static u16 t21041_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };
 
 
-#define dr32(reg)		readl(de->regs + (reg))
-#define dw32(reg,val)		writel((val), de->regs + (reg))
+#define dr32(reg)	ioread32(de->regs + (reg))
+#define dw32(reg, val)	iowrite32((val), de->regs + (reg))
 
 
 static void de_rx_err_acct (struct de_private *de, unsigned rx_tail,
@@ -1706,6 +1706,7 @@
 		int value, boguscnt = 100000;
 		do {
 			value = dr32(ROMCmd);
+			rmb();
 		} while (value < 0 && --boguscnt > 0);
 		de->dev->dev_addr[i] = value;
 		udelay(1);
diff -urN linux-2.6.35-rc3/drivers/net/ucc_geth.c linux-2.6.35-rc4/drivers/net/ucc_geth.c
--- linux-2.6.35-rc3/drivers/net/ucc_geth.c	2010-07-05 05:34:22.287805549 +0000
+++ linux-2.6.35-rc4/drivers/net/ucc_geth.c	2010-07-05 05:34:27.651868065 +0000
@@ -3215,6 +3215,8 @@
 					   __func__, __LINE__, (u32) skb);
 			if (skb) {
 				skb->data = skb->head + NET_SKB_PAD;
+				skb->len = 0;
+				skb_reset_tail_pointer(skb);
 				__skb_queue_head(&ugeth->rx_recycle, skb);
 			}
 
diff -urN linux-2.6.35-rc3/drivers/net/usb/hso.c linux-2.6.35-rc4/drivers/net/usb/hso.c
--- linux-2.6.35-rc3/drivers/net/usb/hso.c	2010-07-05 05:34:22.288805344 +0000
+++ linux-2.6.35-rc4/drivers/net/usb/hso.c	2010-07-05 05:34:27.652868044 +0000
@@ -1334,7 +1334,6 @@
 	/* check for port already opened, if not set the termios */
 	serial->open_count++;
 	if (serial->open_count == 1) {
-		tty->low_latency = 1;
 		serial->rx_state = RX_IDLE;
 		/* Force default termio settings */
 		_hso_serial_set_termios(tty, NULL);
diff -urN linux-2.6.35-rc3/drivers/net/vxge/vxge-main.c linux-2.6.35-rc4/drivers/net/vxge/vxge-main.c
--- linux-2.6.35-rc3/drivers/net/vxge/vxge-main.c	2010-07-05 05:34:22.294805488 +0000
+++ linux-2.6.35-rc4/drivers/net/vxge/vxge-main.c	2010-07-05 05:34:27.658806510 +0000
@@ -2262,7 +2262,8 @@
 		vxge_debug_init(VXGE_ERR,
 			"%s: memory allocation failed",
 			VXGE_DRIVER_NAME);
-		return  -ENOMEM;
+		ret = -ENOMEM;
+		goto alloc_entries_failed;
 	}
 
 	vdev->vxge_entries =
@@ -2271,8 +2272,8 @@
 	if (!vdev->vxge_entries) {
 		vxge_debug_init(VXGE_ERR, "%s: memory allocation failed",
 			VXGE_DRIVER_NAME);
-		kfree(vdev->entries);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto alloc_vxge_entries_failed;
 	}
 
 	for (i = 0, j = 0; i < vdev->no_of_vpath; i++) {
@@ -2303,22 +2304,32 @@
 		vxge_debug_init(VXGE_ERR,
 			"%s: MSI-X enable failed for %d vectors, ret: %d",
 			VXGE_DRIVER_NAME, vdev->intr_cnt, ret);
+		if ((max_config_vpath != VXGE_USE_DEFAULT) || (ret < 3)) {
+			ret = -ENODEV;
+			goto enable_msix_failed;
+		}
+
 		kfree(vdev->entries);
 		kfree(vdev->vxge_entries);
 		vdev->entries = NULL;
 		vdev->vxge_entries = NULL;
-
-		if ((max_config_vpath != VXGE_USE_DEFAULT) || (ret < 3))
-			return -ENODEV;
 		/* Try with less no of vector by reducing no of vpaths count */
 		temp = (ret - 1)/2;
 		vxge_close_vpaths(vdev, temp);
 		vdev->no_of_vpath = temp;
 		goto start;
-	} else if (ret < 0)
-		return -ENODEV;
-
+	} else if (ret < 0) {
+		ret = -ENODEV;
+		goto enable_msix_failed;
+	}
 	return 0;
+
+enable_msix_failed:
+	kfree(vdev->vxge_entries);
+alloc_vxge_entries_failed:
+	kfree(vdev->entries);
+alloc_entries_failed:
+	return ret;
 }
 
 static int vxge_enable_msix(struct vxgedev *vdev)
diff -urN linux-2.6.35-rc3/drivers/net/wireless/ath/ath5k/attach.c linux-2.6.35-rc4/drivers/net/wireless/ath/ath5k/attach.c
--- linux-2.6.35-rc3/drivers/net/wireless/ath/ath5k/attach.c	2010-07-05 05:34:22.306805671 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/ath/ath5k/attach.c	2010-07-05 05:34:27.670805458 +0000
@@ -126,6 +126,7 @@
 	ah->ah_ant_mode = AR5K_ANTMODE_DEFAULT;
 	ah->ah_noise_floor = -95;	/* until first NF calibration is run */
 	sc->ani_state.ani_mode = ATH5K_ANI_MODE_AUTO;
+	ah->ah_current_channel = &sc->channels[0];
 
 	/*
 	 * Find the mac version
diff -urN linux-2.6.35-rc3/drivers/net/wireless/hostap/hostap_cs.c linux-2.6.35-rc4/drivers/net/wireless/hostap/hostap_cs.c
--- linux-2.6.35-rc3/drivers/net/wireless/hostap/hostap_cs.c	2010-07-05 05:34:22.349868110 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/hostap/hostap_cs.c	2010-07-05 05:34:27.713868022 +0000
@@ -594,6 +594,7 @@
 	local_info_t *local;
 	int ret = 1;
 	struct hostap_cs_priv *hw_priv;
+	unsigned long flags;
 
 	PDEBUG(DEBUG_FLOW, "prism2_config()\n");
 
@@ -625,9 +626,15 @@
 	local->hw_priv = hw_priv;
 	hw_priv->link = link;
 
+	/*
+	 * Make sure the IRQ handler cannot proceed until at least
+	 * dev->base_addr is initialized.
+	 */
+	spin_lock_irqsave(&local->irq_init_lock, flags);
+
 	ret = pcmcia_request_irq(link, prism2_interrupt);
 	if (ret)
-		goto failed;
+		goto failed_unlock;
 
 	/*
 	 * This actually configures the PCMCIA socket -- setting up
@@ -636,11 +643,13 @@
 	 */
 	ret = pcmcia_request_configuration(link, &link->conf);
 	if (ret)
-		goto failed;
+		goto failed_unlock;
 
 	dev->irq = link->irq;
 	dev->base_addr = link->io.BasePort1;
 
+	spin_unlock_irqrestore(&local->irq_init_lock, flags);
+
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x: ",
 	       dev_info, link->conf.ConfigIndex);
@@ -667,6 +676,8 @@
 
 	return ret;
 
+ failed_unlock:
+	 spin_unlock_irqrestore(&local->irq_init_lock, flags);
  failed:
 	kfree(hw_priv);
 	prism2_release((u_long)link);
diff -urN linux-2.6.35-rc3/drivers/net/wireless/hostap/hostap_hw.c linux-2.6.35-rc4/drivers/net/wireless/hostap/hostap_hw.c
--- linux-2.6.35-rc3/drivers/net/wireless/hostap/hostap_hw.c	2010-07-05 05:34:22.350868175 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/hostap/hostap_hw.c	2010-07-05 05:34:27.713868022 +0000
@@ -2621,6 +2621,18 @@
 	iface = netdev_priv(dev);
 	local = iface->local;
 
+	/* Detect early interrupt before driver is fully configued */
+	spin_lock(&local->irq_init_lock);
+	if (!dev->base_addr) {
+		if (net_ratelimit()) {
+			printk(KERN_DEBUG "%s: Interrupt, but dev not configured\n",
+			       dev->name);
+		}
+		spin_unlock(&local->irq_init_lock);
+		return IRQ_HANDLED;
+	}
+	spin_unlock(&local->irq_init_lock);
+
 	prism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INTERRUPT, 0, 0);
 
 	if (local->func->card_present && !local->func->card_present(local)) {
@@ -3138,6 +3150,7 @@
 	spin_lock_init(&local->cmdlock);
 	spin_lock_init(&local->baplock);
 	spin_lock_init(&local->lock);
+	spin_lock_init(&local->irq_init_lock);
 	mutex_init(&local->rid_bap_mtx);
 
 	if (card_idx < 0 || card_idx >= MAX_PARM_DEVICES)
diff -urN linux-2.6.35-rc3/drivers/net/wireless/hostap/hostap_wlan.h linux-2.6.35-rc4/drivers/net/wireless/hostap/hostap_wlan.h
--- linux-2.6.35-rc3/drivers/net/wireless/hostap/hostap_wlan.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/hostap/hostap_wlan.h	2010-07-05 05:34:27.714868051 +0000
@@ -654,7 +654,7 @@
 	rwlock_t iface_lock; /* hostap_interfaces read lock; use write lock
 			      * when removing entries from the list.
 			      * TX and RX paths can use read lock. */
-	spinlock_t cmdlock, baplock, lock;
+	spinlock_t cmdlock, baplock, lock, irq_init_lock;
 	struct mutex rid_bap_mtx;
 	u16 infofid; /* MAC buffer id for info frame */
 	/* txfid, intransmitfid, next_txtid, and next_alloc are protected by
diff -urN linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-agn-tx.c linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
--- linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-agn-tx.c	2010-07-05 05:34:22.362868031 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-agn-tx.c	2010-07-05 05:34:27.726868042 +0000
@@ -1299,6 +1299,11 @@
 	sta_id = ba_resp->sta_id;
 	tid = ba_resp->tid;
 	agg = &priv->stations[sta_id].tid[tid].agg;
+	if (unlikely(agg->txq_id != scd_flow)) {
+		IWL_ERR(priv, "BA scd_flow %d does not match txq_id %d\n",
+			scd_flow, agg->txq_id);
+		return;
+	}
 
 	/* Find index just before block-ack window */
 	index = iwl_queue_dec_wrap(ba_resp_scd_ssn & 0xff, txq->q.n_bd);
diff -urN linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-agn.c linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-agn.c
--- linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-agn.c	2010-07-05 05:34:22.364867902 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-agn.c	2010-07-05 05:34:27.728806499 +0000
@@ -3391,10 +3391,12 @@
 	int ret;
 	u8 sta_id;
 
-	sta_priv->common.sta_id = IWL_INVALID_STATION;
-
 	IWL_DEBUG_INFO(priv, "received request to add station %pM\n",
 			sta->addr);
+	mutex_lock(&priv->mutex);
+	IWL_DEBUG_INFO(priv, "proceeding to add station %pM\n",
+			sta->addr);
+	sta_priv->common.sta_id = IWL_INVALID_STATION;
 
 	atomic_set(&sta_priv->pending_frames, 0);
 	if (vif->type == NL80211_IFTYPE_AP)
@@ -3406,6 +3408,7 @@
 		IWL_ERR(priv, "Unable to add station %pM (%d)\n",
 			sta->addr, ret);
 		/* Should we return success if return code is EEXIST ? */
+		mutex_unlock(&priv->mutex);
 		return ret;
 	}
 
@@ -3415,6 +3418,7 @@
 	IWL_DEBUG_INFO(priv, "Initializing rate scaling for station %pM\n",
 		       sta->addr);
 	iwl_rs_rate_init(priv, sta, sta_id);
+	mutex_unlock(&priv->mutex);
 
 	return 0;
 }
diff -urN linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-scan.c linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-scan.c
--- linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-scan.c	2010-07-05 05:34:22.371867982 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-scan.c	2010-07-05 05:34:27.735868046 +0000
@@ -491,6 +491,7 @@
 
 	mutex_lock(&priv->mutex);
 
+	cancel_delayed_work_sync(&priv->scan_check);
 	set_bit(STATUS_SCAN_ABORTING, &priv->status);
 	iwl_send_scan_abort(priv);
 
diff -urN linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-sta.c linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-sta.c
--- linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl-sta.c	2010-07-05 05:34:22.371867982 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl-sta.c	2010-07-05 05:34:27.735868046 +0000
@@ -1373,10 +1373,14 @@
 
 	IWL_DEBUG_INFO(priv, "received request to remove station %pM\n",
 			sta->addr);
+	mutex_lock(&priv->mutex);
+	IWL_DEBUG_INFO(priv, "proceeding to remove station %pM\n",
+			sta->addr);
 	ret = iwl_remove_station(priv, sta_common->sta_id, sta->addr);
 	if (ret)
 		IWL_ERR(priv, "Error removing station %pM\n",
 			sta->addr);
+	mutex_unlock(&priv->mutex);
 	return ret;
 }
 EXPORT_SYMBOL(iwl_mac_sta_remove);
diff -urN linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl3945-base.c linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl3945-base.c
--- linux-2.6.35-rc3/drivers/net/wireless/iwlwifi/iwl3945-base.c	2010-07-05 05:34:22.374867978 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/iwlwifi/iwl3945-base.c	2010-07-05 05:34:27.738806775 +0000
@@ -3437,10 +3437,13 @@
 	bool is_ap = vif->type == NL80211_IFTYPE_STATION;
 	u8 sta_id;
 
-	sta_priv->common.sta_id = IWL_INVALID_STATION;
-
 	IWL_DEBUG_INFO(priv, "received request to add station %pM\n",
 			sta->addr);
+	mutex_lock(&priv->mutex);
+	IWL_DEBUG_INFO(priv, "proceeding to add station %pM\n",
+			sta->addr);
+	sta_priv->common.sta_id = IWL_INVALID_STATION;
+
 
 	ret = iwl_add_station_common(priv, sta->addr, is_ap, &sta->ht_cap,
 				     &sta_id);
@@ -3448,6 +3451,7 @@
 		IWL_ERR(priv, "Unable to add station %pM (%d)\n",
 			sta->addr, ret);
 		/* Should we return success if return code is EEXIST ? */
+		mutex_unlock(&priv->mutex);
 		return ret;
 	}
 
@@ -3457,6 +3461,7 @@
 	IWL_DEBUG_INFO(priv, "Initializing rate scaling for station %pM\n",
 		       sta->addr);
 	iwl3945_rs_rate_init(priv, sta, sta_id);
+	mutex_unlock(&priv->mutex);
 
 	return 0;
 }
diff -urN linux-2.6.35-rc3/drivers/net/wireless/libertas_tf/main.c linux-2.6.35-rc4/drivers/net/wireless/libertas_tf/main.c
--- linux-2.6.35-rc3/drivers/net/wireless/libertas_tf/main.c	2010-07-05 05:34:22.380868127 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/libertas_tf/main.c	2010-07-05 05:34:27.745868030 +0000
@@ -549,7 +549,7 @@
 
 	prxpd = (struct rxpd *) skb->data;
 
-	stats.flag = 0;
+	memset(&stats, 0, sizeof(stats));
 	if (!(prxpd->status & cpu_to_le16(MRVDRV_RXPD_STATUS_OK)))
 		stats.flag |= RX_FLAG_FAILED_FCS_CRC;
 	stats.freq = priv->cur_freq;
diff -urN linux-2.6.35-rc3/drivers/net/wireless/p54/p54pci.c linux-2.6.35-rc4/drivers/net/wireless/p54/p54pci.c
--- linux-2.6.35-rc3/drivers/net/wireless/p54/p54pci.c	2010-07-05 05:34:22.387868135 +0000
+++ linux-2.6.35-rc4/drivers/net/wireless/p54/p54pci.c	2010-07-05 05:34:27.752868029 +0000
@@ -41,6 +41,8 @@
 	{ PCI_DEVICE(0x1260, 0x3877) },
 	/* Intersil PRISM Javelin/Xbow Wireless LAN adapter */
 	{ PCI_DEVICE(0x1260, 0x3886) },
+	/* Intersil PRISM Xbow Wireless LAN adapter (Symbol AP-300) */
+	{ PCI_DEVICE(0x1260, 0xffff) },
 	{ },
 };
 
diff -urN linux-2.6.35-rc3/drivers/pci/intel-iommu.c linux-2.6.35-rc4/drivers/pci/intel-iommu.c
--- linux-2.6.35-rc3/drivers/pci/intel-iommu.c	2010-07-05 05:34:22.411868717 +0000
+++ linux-2.6.35-rc4/drivers/pci/intel-iommu.c	2010-07-05 05:34:27.776868078 +0000
@@ -340,7 +340,7 @@
 int dmar_disabled = 1;
 #endif /*CONFIG_DMAR_DEFAULT_ON*/
 
-static int __initdata dmar_map_gfx = 1;
+static int dmar_map_gfx = 1;
 static int dmar_forcedac;
 static int intel_iommu_strict;
 
@@ -1874,14 +1874,15 @@
 			}
 		}
 		if (found) {
+			spin_unlock_irqrestore(&device_domain_lock, flags);
 			free_devinfo_mem(info);
 			domain_exit(domain);
 			domain = found;
 		} else {
 			list_add(&info->link, &domain->devices);
 			list_add(&info->global, &device_domain_list);
+			spin_unlock_irqrestore(&device_domain_lock, flags);
 		}
-		spin_unlock_irqrestore(&device_domain_lock, flags);
 	}
 
 found_domain:
@@ -3603,7 +3604,8 @@
 		pte = dmar_domain->pgd;
 		if (dma_pte_present(pte)) {
 			free_pgtable_page(dmar_domain->pgd);
-			dmar_domain->pgd = (struct dma_pte *)dma_pte_addr(pte);
+			dmar_domain->pgd = (struct dma_pte *)
+				phys_to_virt(dma_pte_addr(pte));
 		}
 		dmar_domain->agaw--;
 	}
@@ -3719,6 +3721,12 @@
 	 */
 	printk(KERN_INFO "DMAR: Forcing write-buffer flush capability\n");
 	rwbf_quirk = 1;
+
+	/* https://bugzilla.redhat.com/show_bug.cgi?id=538163 */
+	if (dev->revision == 0x07) {
+		printk(KERN_INFO "DMAR: Disabling IOMMU for graphics on this chipset\n");
+		dmar_map_gfx = 0;
+	}
 }
 
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2a40, quirk_iommu_rwbf);
diff -urN linux-2.6.35-rc3/drivers/pci/pci.c linux-2.6.35-rc4/drivers/pci/pci.c
--- linux-2.6.35-rc3/drivers/pci/pci.c	2010-07-05 05:34:22.412868179 +0000
+++ linux-2.6.35-rc4/drivers/pci/pci.c	2010-07-05 05:34:27.777868044 +0000
@@ -2292,6 +2292,7 @@
 		pci_write_config_word(dev, pos + PCI_MSIX_FLAGS, control);
 	}
 }
+EXPORT_SYMBOL_GPL(pci_msi_off);
 
 #ifndef HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_SIZE
 int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
diff -urN linux-2.6.35-rc3/drivers/pci/pcie/pme/pcie_pme.c linux-2.6.35-rc4/drivers/pci/pcie/pme/pcie_pme.c
--- linux-2.6.35-rc3/drivers/pci/pcie/pme/pcie_pme.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/pci/pcie/pme/pcie_pme.c	2010-07-05 05:34:27.779868903 +0000
@@ -34,7 +34,7 @@
  * being registered.  Consequently, the interrupt-based PCIe PME signaling will
  * not be used by any PCIe root ports in that case.
  */
-static bool pcie_pme_disabled;
+static bool pcie_pme_disabled = true;
 
 /*
  * The PCI Express Base Specification 2.0, Section 6.1.8, states the following:
@@ -64,12 +64,19 @@
 
 static int __init pcie_pme_setup(char *str)
 {
-	if (!strcmp(str, "off"))
-		pcie_pme_disabled = true;
-	else if (!strcmp(str, "force"))
+	if (!strncmp(str, "auto", 4))
+		pcie_pme_disabled = false;
+	else if (!strncmp(str, "force", 5))
 		pcie_pme_force_enable = true;
-	else if (!strcmp(str, "nomsi"))
-		pcie_pme_msi_disabled = true;
+
+	str = strchr(str, ',');
+	if (str) {
+		str++;
+		str += strspn(str, " \t");
+		if (*str && !strcmp(str, "nomsi"))
+			pcie_pme_msi_disabled = true;
+	}
+
 	return 1;
 }
 __setup("pcie_pme=", pcie_pme_setup);
diff -urN linux-2.6.35-rc3/drivers/power/z2_battery.c linux-2.6.35-rc4/drivers/power/z2_battery.c
--- linux-2.6.35-rc3/drivers/power/z2_battery.c	2010-07-05 05:34:22.424868236 +0000
+++ linux-2.6.35-rc4/drivers/power/z2_battery.c	2010-07-05 05:34:27.789868113 +0000
@@ -9,19 +9,13 @@
  *
  */
 
-#include <linux/init.h>
-#include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/power_supply.h>
-#include <linux/i2c.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
 #include <linux/gpio.h>
+#include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <asm/irq.h>
-#include <asm/mach/irq.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
 #include <linux/z2_battery.h>
 
 #define	Z2_DEFAULT_NAME	"Z2"
diff -urN linux-2.6.35-rc3/drivers/rtc/rtc-davinci.c linux-2.6.35-rc4/drivers/rtc/rtc-davinci.c
--- linux-2.6.35-rc3/drivers/rtc/rtc-davinci.c	2010-07-05 05:34:22.430807879 +0000
+++ linux-2.6.35-rc4/drivers/rtc/rtc-davinci.c	2010-07-05 05:34:27.795868050 +0000
@@ -29,6 +29,7 @@
 #include <linux/bcd.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 
 /*
  * The DaVinci RTC is a simple RTC with the following
diff -urN linux-2.6.35-rc3/drivers/rtc/rtc-ds1307.c linux-2.6.35-rc4/drivers/rtc/rtc-ds1307.c
--- linux-2.6.35-rc3/drivers/rtc/rtc-ds1307.c	2010-07-05 05:34:22.431868132 +0000
+++ linux-2.6.35-rc4/drivers/rtc/rtc-ds1307.c	2010-07-05 05:34:27.796868028 +0000
@@ -777,7 +777,7 @@
 
 read_rtc:
 	/* read RTC registers */
-	tmp = ds1307->read_block_data(ds1307->client, 0, 8, buf);
+	tmp = ds1307->read_block_data(ds1307->client, ds1307->offset, 8, buf);
 	if (tmp != 8) {
 		pr_debug("read error %d\n", tmp);
 		err = -EIO;
@@ -862,7 +862,7 @@
 		if (ds1307->regs[DS1307_REG_HOUR] & DS1307_BIT_PM)
 			tmp += 12;
 		i2c_smbus_write_byte_data(client,
-				DS1307_REG_HOUR,
+				ds1307->offset + DS1307_REG_HOUR,
 				bin2bcd(tmp));
 	}
 
diff -urN linux-2.6.35-rc3/drivers/serial/cpm_uart/cpm_uart_core.c linux-2.6.35-rc4/drivers/serial/cpm_uart/cpm_uart_core.c
--- linux-2.6.35-rc3/drivers/serial/cpm_uart/cpm_uart_core.c	2010-07-05 05:34:22.509868037 +0000
+++ linux-2.6.35-rc4/drivers/serial/cpm_uart/cpm_uart_core.c	2010-07-05 05:34:27.873868083 +0000
@@ -930,6 +930,83 @@
 	}
 }
 
+#if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_CPM_CONSOLE)
+/*
+ * Write a string to the serial port
+ * Note that this is called with interrupts already disabled
+ */
+static void cpm_uart_early_write(struct uart_cpm_port *pinfo,
+		const char *string, u_int count)
+{
+	unsigned int i;
+	cbd_t __iomem *bdp, *bdbase;
+	unsigned char *cpm_outp_addr;
+
+	/* Get the address of the host memory buffer.
+	 */
+	bdp = pinfo->tx_cur;
+	bdbase = pinfo->tx_bd_base;
+
+	/*
+	 * Now, do each character.  This is not as bad as it looks
+	 * since this is a holding FIFO and not a transmitting FIFO.
+	 * We could add the complexity of filling the entire transmit
+	 * buffer, but we would just wait longer between accesses......
+	 */
+	for (i = 0; i < count; i++, string++) {
+		/* Wait for transmitter fifo to empty.
+		 * Ready indicates output is ready, and xmt is doing
+		 * that, not that it is ready for us to send.
+		 */
+		while ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)
+			;
+
+		/* Send the character out.
+		 * If the buffer address is in the CPM DPRAM, don't
+		 * convert it.
+		 */
+		cpm_outp_addr = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr),
+					pinfo);
+		*cpm_outp_addr = *string;
+
+		out_be16(&bdp->cbd_datlen, 1);
+		setbits16(&bdp->cbd_sc, BD_SC_READY);
+
+		if (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)
+			bdp = bdbase;
+		else
+			bdp++;
+
+		/* if a LF, also do CR... */
+		if (*string == 10) {
+			while ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)
+				;
+
+			cpm_outp_addr = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr),
+						pinfo);
+			*cpm_outp_addr = 13;
+
+			out_be16(&bdp->cbd_datlen, 1);
+			setbits16(&bdp->cbd_sc, BD_SC_READY);
+
+			if (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)
+				bdp = bdbase;
+			else
+				bdp++;
+		}
+	}
+
+	/*
+	 * Finally, Wait for transmitter & holding register to empty
+	 *  and restore the IER
+	 */
+	while ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)
+		;
+
+	pinfo->tx_cur = bdp;
+}
+#endif
+
 #ifdef CONFIG_CONSOLE_POLL
 /* Serial polling routines for writing and reading from the uart while
  * in an interrupt or debug context.
@@ -999,7 +1076,7 @@
 	static char ch[2];
 
 	ch[0] = (char)c;
-	cpm_uart_early_write(pinfo->port.line, ch, 1);
+	cpm_uart_early_write(pinfo, ch, 1);
 }
 #endif /* CONFIG_CONSOLE_POLL */
 
@@ -1130,9 +1207,6 @@
 				   u_int count)
 {
 	struct uart_cpm_port *pinfo = &cpm_uart_ports[co->index];
-	unsigned int i;
-	cbd_t __iomem *bdp, *bdbase;
-	unsigned char *cp;
 	unsigned long flags;
 	int nolock = oops_in_progress;
 
@@ -1142,66 +1216,7 @@
 		spin_lock_irqsave(&pinfo->port.lock, flags);
 	}
 
-	/* Get the address of the host memory buffer.
-	 */
-	bdp = pinfo->tx_cur;
-	bdbase = pinfo->tx_bd_base;
-
-	/*
-	 * Now, do each character.  This is not as bad as it looks
-	 * since this is a holding FIFO and not a transmitting FIFO.
-	 * We could add the complexity of filling the entire transmit
-	 * buffer, but we would just wait longer between accesses......
-	 */
-	for (i = 0; i < count; i++, s++) {
-		/* Wait for transmitter fifo to empty.
-		 * Ready indicates output is ready, and xmt is doing
-		 * that, not that it is ready for us to send.
-		 */
-		while ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)
-			;
-
-		/* Send the character out.
-		 * If the buffer address is in the CPM DPRAM, don't
-		 * convert it.
-		 */
-		cp = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);
-		*cp = *s;
-
-		out_be16(&bdp->cbd_datlen, 1);
-		setbits16(&bdp->cbd_sc, BD_SC_READY);
-
-		if (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)
-			bdp = bdbase;
-		else
-			bdp++;
-
-		/* if a LF, also do CR... */
-		if (*s == 10) {
-			while ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)
-				;
-
-			cp = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);
-			*cp = 13;
-
-			out_be16(&bdp->cbd_datlen, 1);
-			setbits16(&bdp->cbd_sc, BD_SC_READY);
-
-			if (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)
-				bdp = bdbase;
-			else
-				bdp++;
-		}
-	}
-
-	/*
-	 * Finally, Wait for transmitter & holding register to empty
-	 *  and restore the IER
-	 */
-	while ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)
-		;
-
-	pinfo->tx_cur = bdp;
+	cpm_uart_early_write(pinfo, s, count);
 
 	if (unlikely(nolock)) {
 		local_irq_restore(flags);
diff -urN linux-2.6.35-rc3/drivers/serial/serial_cs.c linux-2.6.35-rc4/drivers/serial/serial_cs.c
--- linux-2.6.35-rc3/drivers/serial/serial_cs.c	2010-07-05 05:34:22.511868085 +0000
+++ linux-2.6.35-rc4/drivers/serial/serial_cs.c	2010-07-05 05:34:27.875868090 +0000
@@ -821,6 +821,7 @@
 	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(1, "Psion Dacom", "Gold Card V34 Ethernet", 0xf5f025c2, 0x338e8155, "cis/PCMLM28.cis"),
 	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(1, "Psion Dacom", "Gold Card V34 Ethernet GSM", 0xf5f025c2, 0x4ae85d35, "cis/PCMLM28.cis"),
 	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(1, "LINKSYS", "PCMLM28", 0xf7cb0b07, 0x66881874, "cis/PCMLM28.cis"),
+	PCMCIA_PFC_DEVICE_CIS_PROD_ID12(1, "TOSHIBA", "Modem/LAN Card", 0xb4585a1a, 0x53f922f8, "cis/PCMLM28.cis"),
 	PCMCIA_MFC_DEVICE_CIS_PROD_ID12(1, "DAYNA COMMUNICATIONS", "LAN AND MODEM MULTIFUNCTION", 0x8fdf8f89, 0xdd5ed9e8, "cis/DP83903.cis"),
 	PCMCIA_MFC_DEVICE_CIS_PROD_ID4(1, "NSC MF LAN/Modem", 0x58fc6056, "cis/DP83903.cis"),
 	PCMCIA_MFC_DEVICE_CIS_MANF_CARD(1, 0x0101, 0x0556, "cis/3CCFEM556.cis"),
diff -urN linux-2.6.35-rc3/drivers/staging/batman-adv/bat_sysfs.c linux-2.6.35-rc4/drivers/staging/batman-adv/bat_sysfs.c
--- linux-2.6.35-rc3/drivers/staging/batman-adv/bat_sysfs.c	2010-07-05 05:34:22.524805580 +0000
+++ linux-2.6.35-rc4/drivers/staging/batman-adv/bat_sysfs.c	2010-07-05 05:34:27.888868044 +0000
@@ -225,9 +225,9 @@
 	NULL,
 };
 
-static ssize_t transtable_local_read(struct kobject *kobj,
-			       struct bin_attribute *bin_attr,
-			       char *buff, loff_t off, size_t count)
+static ssize_t transtable_local_read(struct file *filp, struct kobject *kobj,
+				  struct bin_attribute *bin_attr,
+				  char *buff, loff_t off, size_t count)
 {
 	struct device *dev = to_dev(kobj->parent);
 	struct net_device *net_dev = to_net_dev(dev);
@@ -235,9 +235,9 @@
 	return hna_local_fill_buffer_text(net_dev, buff, count, off);
 }
 
-static ssize_t transtable_global_read(struct kobject *kobj,
-			       struct bin_attribute *bin_attr,
-			       char *buff, loff_t off, size_t count)
+static ssize_t transtable_global_read(struct file *filp, struct kobject *kobj,
+				  struct bin_attribute *bin_attr,
+				  char *buff, loff_t off, size_t count)
 {
 	struct device *dev = to_dev(kobj->parent);
 	struct net_device *net_dev = to_net_dev(dev);
@@ -245,9 +245,9 @@
 	return hna_global_fill_buffer_text(net_dev, buff, count, off);
 }
 
-static ssize_t originators_read(struct kobject *kobj,
-			       struct bin_attribute *bin_attr,
-			       char *buff, loff_t off, size_t count)
+static ssize_t originators_read(struct file *filp, struct kobject *kobj,
+				  struct bin_attribute *bin_attr,
+				  char *buff, loff_t off, size_t count)
 {
 	struct device *dev = to_dev(kobj->parent);
 	struct net_device *net_dev = to_net_dev(dev);
@@ -255,9 +255,9 @@
 	return orig_fill_buffer_text(net_dev, buff, count, off);
 }
 
-static ssize_t vis_data_read(struct kobject *kobj,
-			     struct bin_attribute *bin_attr,
-			     char *buff, loff_t off, size_t count)
+static ssize_t vis_data_read(struct file *filp, struct kobject *kobj,
+				  struct bin_attribute *bin_attr,
+				  char *buff, loff_t off, size_t count)
 {
 	struct device *dev = to_dev(kobj->parent);
 	struct net_device *net_dev = to_net_dev(dev);
diff -urN linux-2.6.35-rc3/drivers/staging/batman-adv/device.c linux-2.6.35-rc4/drivers/staging/batman-adv/device.c
--- linux-2.6.35-rc3/drivers/staging/batman-adv/device.c	2010-07-05 05:34:22.525868630 +0000
+++ linux-2.6.35-rc4/drivers/staging/batman-adv/device.c	2010-07-05 05:34:27.889868020 +0000
@@ -196,7 +196,7 @@
 	kfree(device_packet);
 
 	if (error)
-		return error;
+		return -EFAULT;
 
 	return sizeof(struct icmp_packet);
 }
diff -urN linux-2.6.35-rc3/drivers/staging/comedi/drivers/adl_pci9111.c linux-2.6.35-rc4/drivers/staging/comedi/drivers/adl_pci9111.c
--- linux-2.6.35-rc3/drivers/staging/comedi/drivers/adl_pci9111.c	2010-07-05 05:34:22.538868096 +0000
+++ linux-2.6.35-rc4/drivers/staging/comedi/drivers/adl_pci9111.c	2010-07-05 05:34:27.901868101 +0000
@@ -824,9 +824,12 @@
 		plx9050_interrupt_control(dev_private->lcr_io_base, true, true,
 					  false, true, true);
 
-		dev_private->scan_delay =
-		    (async_cmd->scan_begin_arg / (async_cmd->convert_arg *
-						  async_cmd->chanlist_len)) - 1;
+		if (async_cmd->scan_begin_src == TRIG_TIMER) {
+			dev_private->scan_delay =
+				(async_cmd->scan_begin_arg /
+				 (async_cmd->convert_arg *
+				  async_cmd->chanlist_len)) - 1;
+		}
 
 		break;
 
diff -urN linux-2.6.35-rc3/drivers/staging/comedi/drivers/cb_pcidda.c linux-2.6.35-rc4/drivers/staging/comedi/drivers/cb_pcidda.c
--- linux-2.6.35-rc3/drivers/staging/comedi/drivers/cb_pcidda.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/staging/comedi/drivers/cb_pcidda.c	2010-07-05 05:34:27.907868048 +0000
@@ -52,7 +52,6 @@
 #include "8255.h"
 
 #define PCI_VENDOR_ID_CB	0x1307	/*  PCI vendor number of ComputerBoards */
-#define N_BOARDS	10	/*  Number of boards in cb_pcidda_boards */
 #define EEPROM_SIZE	128	/*  number of entries in eeprom */
 #define MAX_AO_CHANNELS 8	/*  maximum number of ao channels for supported boards */
 
@@ -307,7 +306,7 @@
 					continue;
 				}
 			}
-			for (index = 0; index < N_BOARDS; index++) {
+			for (index = 0; index < ARRAY_SIZE(cb_pcidda_boards); index++) {
 				if (cb_pcidda_boards[index].device_id ==
 				    pcidev->device) {
 					goto found;
diff -urN linux-2.6.35-rc3/drivers/staging/hv/channel_mgmt.c linux-2.6.35-rc4/drivers/staging/hv/channel_mgmt.c
--- linux-2.6.35-rc3/drivers/staging/hv/channel_mgmt.c	2010-07-05 05:34:22.594868147 +0000
+++ linux-2.6.35-rc4/drivers/staging/hv/channel_mgmt.c	2010-07-05 05:34:27.958868050 +0000
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/completion.h>
 #include "osd.h"
 #include "logging.h"
 #include "vmbus_private.h"
@@ -293,6 +294,25 @@
 			      Channel);
 }
 
+
+DECLARE_COMPLETION(hv_channel_ready);
+
+/*
+ * Count initialized channels, and ensure all channels are ready when hv_vmbus
+ * module loading completes.
+ */
+static void count_hv_channel(void)
+{
+	static int counter;
+	unsigned long flags;
+
+	spin_lock_irqsave(&gVmbusConnection.channel_lock, flags);
+	if (++counter == MAX_MSG_TYPES)
+		complete(&hv_channel_ready);
+	spin_unlock_irqrestore(&gVmbusConnection.channel_lock, flags);
+}
+
+
 /*
  * VmbusChannelProcessOffer - Process the offer by creating a channel/device
  * associated with this offer
@@ -373,22 +393,21 @@
 		 * can cleanup properly
 		 */
 		newChannel->State = CHANNEL_OPEN_STATE;
-		cnt = 0;
 
-		while (cnt != MAX_MSG_TYPES) {
+		/* Open IC channels */
+		for (cnt = 0; cnt < MAX_MSG_TYPES; cnt++) {
 			if (memcmp(&newChannel->OfferMsg.Offer.InterfaceType,
 				   &hv_cb_utils[cnt].data,
-				   sizeof(struct hv_guid)) == 0) {
+				   sizeof(struct hv_guid)) == 0 &&
+				VmbusChannelOpen(newChannel, 2 * PAGE_SIZE,
+						 2 * PAGE_SIZE, NULL, 0,
+						 hv_cb_utils[cnt].callback,
+						 newChannel) == 0) {
+				hv_cb_utils[cnt].channel = newChannel;
 				DPRINT_INFO(VMBUS, "%s",
-					    hv_cb_utils[cnt].log_msg);
-
-				if (VmbusChannelOpen(newChannel, 2 * PAGE_SIZE,
-						    2 * PAGE_SIZE, NULL, 0,
-						    hv_cb_utils[cnt].callback,
-						    newChannel) == 0)
-					hv_cb_utils[cnt].channel = newChannel;
+						hv_cb_utils[cnt].log_msg);
+				count_hv_channel();
 			}
-			cnt++;
 		}
 	}
 	DPRINT_EXIT(VMBUS);
diff -urN linux-2.6.35-rc3/drivers/staging/hv/hv_utils.c linux-2.6.35-rc4/drivers/staging/hv/hv_utils.c
--- linux-2.6.35-rc3/drivers/staging/hv/hv_utils.c	2010-07-05 05:34:22.595868012 +0000
+++ linux-2.6.35-rc4/drivers/staging/hv/hv_utils.c	2010-07-05 05:34:27.959868041 +0000
@@ -24,6 +24,8 @@
 #include <linux/slab.h>
 #include <linux/sysctl.h>
 #include <linux/reboot.h>
+#include <linux/dmi.h>
+#include <linux/pci.h>
 
 #include "logging.h"
 #include "osd.h"
@@ -251,10 +253,36 @@
 	DPRINT_EXIT(VMBUS);
 }
 
+static const struct pci_device_id __initconst
+hv_utils_pci_table[] __maybe_unused = {
+	{ PCI_DEVICE(0x1414, 0x5353) }, /* Hyper-V emulated VGA controller */
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, hv_utils_pci_table);
+
+
+static const struct dmi_system_id __initconst
+hv_utils_dmi_table[] __maybe_unused  = {
+	{
+		.ident = "Hyper-V",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Virtual Machine"),
+			DMI_MATCH(DMI_BOARD_NAME, "Virtual Machine"),
+		},
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(dmi, hv_utils_dmi_table);
+
+
 static int __init init_hyperv_utils(void)
 {
 	printk(KERN_INFO "Registering HyperV Utility Driver\n");
 
+	if (!dmi_check_system(hv_utils_dmi_table))
+		return -ENODEV;
+
 	hv_cb_utils[HV_SHUTDOWN_MSG].channel->OnChannelCallback =
 		&shutdown_onchannelcallback;
 	hv_cb_utils[HV_SHUTDOWN_MSG].callback = &shutdown_onchannelcallback;
diff -urN linux-2.6.35-rc3/drivers/staging/hv/vmbus.h linux-2.6.35-rc4/drivers/staging/hv/vmbus.h
--- linux-2.6.35-rc3/drivers/staging/hv/vmbus.h	2010-07-05 05:34:22.599867900 +0000
+++ linux-2.6.35-rc4/drivers/staging/hv/vmbus.h	2010-07-05 05:34:27.963870362 +0000
@@ -74,4 +74,6 @@
 void vmbus_child_driver_unregister(struct driver_context *driver_ctx);
 void vmbus_get_interface(struct vmbus_channel_interface *interface);
 
+extern struct completion hv_channel_ready;
+
 #endif /* _VMBUS_H_ */
diff -urN linux-2.6.35-rc3/drivers/staging/hv/vmbus_drv.c linux-2.6.35-rc4/drivers/staging/hv/vmbus_drv.c
--- linux-2.6.35-rc3/drivers/staging/hv/vmbus_drv.c	2010-07-05 05:34:22.599867900 +0000
+++ linux-2.6.35-rc4/drivers/staging/hv/vmbus_drv.c	2010-07-05 05:34:27.964868046 +0000
@@ -27,6 +27,7 @@
 #include <linux/pci.h>
 #include <linux/dmi.h>
 #include <linux/slab.h>
+#include <linux/completion.h>
 #include "version_info.h"
 #include "osd.h"
 #include "logging.h"
@@ -356,6 +357,8 @@
 
 	vmbus_drv_obj->GetChannelOffers();
 
+	wait_for_completion(&hv_channel_ready);
+
 cleanup:
 	DPRINT_EXIT(VMBUS_DRV);
 
diff -urN linux-2.6.35-rc3/drivers/staging/mrst-touchscreen/intel-mid-touch.c linux-2.6.35-rc4/drivers/staging/mrst-touchscreen/intel-mid-touch.c
--- linux-2.6.35-rc3/drivers/staging/mrst-touchscreen/intel-mid-touch.c	2010-07-05 05:34:22.615868325 +0000
+++ linux-2.6.35-rc4/drivers/staging/mrst-touchscreen/intel-mid-touch.c	2010-07-05 05:34:27.978868087 +0000
@@ -817,9 +817,9 @@
 	free_irq(mrstouchdevp->irq, mrstouchdevp);
 	input_unregister_device(mrstouchdevp->input);
 	input_free_device(mrstouchdevp->input);
-	kfree(mrstouchdevp);
 	if (mrstouchdevp->pendet_thrd)
 		kthread_stop(mrstouchdevp->pendet_thrd);
+	kfree(mrstouchdevp);
 	return 0;
 }
 
diff -urN linux-2.6.35-rc3/drivers/staging/rt2860/usb_main_dev.c linux-2.6.35-rc4/drivers/staging/rt2860/usb_main_dev.c
--- linux-2.6.35-rc3/drivers/staging/rt2860/usb_main_dev.c	2010-07-05 05:34:22.657807574 +0000
+++ linux-2.6.35-rc4/drivers/staging/rt2860/usb_main_dev.c	2010-07-05 05:34:28.021868055 +0000
@@ -77,6 +77,7 @@
 	{USB_DEVICE(0x083A, 0x7522)},	/* Arcadyan */
 	{USB_DEVICE(0x0CDE, 0x0022)},	/* ZCOM */
 	{USB_DEVICE(0x0586, 0x3416)},	/* Zyxel */
+	{USB_DEVICE(0x0586, 0x341a)},	/* Zyxel NWD-270N */
 	{USB_DEVICE(0x0CDE, 0x0025)},	/* Zyxel */
 	{USB_DEVICE(0x1740, 0x9701)},	/* EnGenius */
 	{USB_DEVICE(0x1740, 0x9702)},	/* EnGenius */
diff -urN linux-2.6.35-rc3/drivers/staging/rtl8187se/r8180_core.c linux-2.6.35-rc4/drivers/staging/rtl8187se/r8180_core.c
--- linux-2.6.35-rc3/drivers/staging/rtl8187se/r8180_core.c	2010-07-05 05:34:22.662867971 +0000
+++ linux-2.6.35-rc4/drivers/staging/rtl8187se/r8180_core.c	2010-07-05 05:34:28.026868092 +0000
@@ -66,8 +66,6 @@
 static int hwwep = 0;
 static int channels = 0x3fff;
 
-#define eqMacAddr(a, b)		(((a)[0] == (b)[0] && (a)[1] == (b)[1] && (a)[2] == (b)[2] && (a)[3] == (b)[3] && (a)[4] == (b)[4] && (a)[5] == (b)[5]) ? 1 : 0)
-#define cpMacAddr(des, src)		((des)[0] = (src)[0], (des)[1] = (src)[1], (des)[2] = (src)[2], (des)[3] = (src)[3], (des)[4] = (src)[4], (des)[5] = (src)[5])
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(pci, rtl8180_pci_id_tbl);
 MODULE_AUTHOR("Andrea Merello <andreamrl@tiscali.it>");
diff -urN linux-2.6.35-rc3/drivers/staging/rtl8192su/r8192U_core.c linux-2.6.35-rc4/drivers/staging/rtl8192su/r8192U_core.c
--- linux-2.6.35-rc3/drivers/staging/rtl8192su/r8192U_core.c	2010-07-05 05:34:22.675868161 +0000
+++ linux-2.6.35-rc4/drivers/staging/rtl8192su/r8192U_core.c	2010-07-05 05:34:28.039868203 +0000
@@ -112,28 +112,29 @@
 #define CAM_CONTENT_COUNT 8
 
 static const struct usb_device_id rtl8192_usb_id_tbl[] = {
-	/* Realtek */
-	{USB_DEVICE(0x0bda, 0x8171)},
-	{USB_DEVICE(0x0bda, 0x8192)},
-	{USB_DEVICE(0x0bda, 0x8709)},
-	/* Corega */
-	{USB_DEVICE(0x07aa, 0x0043)},
-	/* Belkin */
-	{USB_DEVICE(0x050d, 0x805E)},
-	{USB_DEVICE(0x050d, 0x815F)}, /* Belkin F5D8053 v6 */
-	/* Sitecom */
-	{USB_DEVICE(0x0df6, 0x0031)},
-	{USB_DEVICE(0x0df6, 0x004b)},	/* WL-349 */
-	/* EnGenius */
-	{USB_DEVICE(0x1740, 0x9201)},
-	/* Dlink */
-	{USB_DEVICE(0x2001, 0x3301)},
-	/* Zinwell */
-	{USB_DEVICE(0x5a57, 0x0290)},
-	/* Guillemot */
-	{USB_DEVICE(0x06f8, 0xe031)},
-	//92SU
+	{USB_DEVICE(0x0bda, 0x8171)}, /* Realtek */
 	{USB_DEVICE(0x0bda, 0x8172)},
+	{USB_DEVICE(0x0bda, 0x8173)},
+	{USB_DEVICE(0x0bda, 0x8174)},
+	{USB_DEVICE(0x0bda, 0x8712)},
+	{USB_DEVICE(0x0bda, 0x8713)},
+	{USB_DEVICE(0x07aa, 0x0047)},
+	{USB_DEVICE(0x07d1, 0x3303)},
+	{USB_DEVICE(0x07d1, 0x3302)},
+	{USB_DEVICE(0x07d1, 0x3300)},
+	{USB_DEVICE(0x1740, 0x9603)},
+	{USB_DEVICE(0x1740, 0x9605)},
+	{USB_DEVICE(0x050d, 0x815F)},
+	{USB_DEVICE(0x06f8, 0xe031)},
+	{USB_DEVICE(0x7392, 0x7611)},
+	{USB_DEVICE(0x7392, 0x7612)},
+	{USB_DEVICE(0x7392, 0x7622)},
+	{USB_DEVICE(0x0DF6, 0x0045)},
+	{USB_DEVICE(0x0E66, 0x0015)},
+	{USB_DEVICE(0x0E66, 0x0016)},
+	{USB_DEVICE(0x0b05, 0x1786)},
+	/* these are not in the official list */
+	{USB_DEVICE(0x0df6, 0x004b)}, /* WL-349 */
 	{}
 };
 
diff -urN linux-2.6.35-rc3/drivers/staging/rtl8192u/r8192U_core.c linux-2.6.35-rc4/drivers/staging/rtl8192u/r8192U_core.c
--- linux-2.6.35-rc3/drivers/staging/rtl8192u/r8192U_core.c	2010-07-05 05:34:22.680868054 +0000
+++ linux-2.6.35-rc4/drivers/staging/rtl8192u/r8192U_core.c	2010-07-05 05:34:28.044868058 +0000
@@ -121,6 +121,8 @@
 	{USB_DEVICE(0x2001, 0x3301)},
 	/* Zinwell */
 	{USB_DEVICE(0x5a57, 0x0290)},
+	/* LG */
+	{USB_DEVICE(0x043e, 0x7a01)},
 	{}
 };
 
diff -urN linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-alsa.c linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-alsa.c
--- linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-alsa.c	2010-07-05 05:34:22.687868555 +0000
+++ linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-alsa.c	2010-07-05 05:34:28.051868077 +0000
@@ -15,6 +15,7 @@
 #include <linux/device.h>
 #include <linux/interrupt.h>
 #include <linux/usb.h>
+#include <linux/slab.h>
 
 #include <asm/delay.h>
 #include <sound/core.h>
diff -urN linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-cards.c linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-cards.c
--- linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-cards.c	2010-07-05 05:34:22.688868281 +0000
+++ linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-cards.c	2010-07-05 05:34:28.052868041 +0000
@@ -24,6 +24,7 @@
 #include <linux/i2c.h>
 #include <linux/usb.h>
 #include <linux/version.h>
+#include <linux/slab.h>
 #include <media/v4l2-common.h>
 #include <media/tuner.h>
 #include <media/tvaudio.h>
diff -urN linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-core.c linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-core.c
--- linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-core.c	2010-07-05 05:34:22.688868281 +0000
+++ linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-core.c	2010-07-05 05:34:28.052868041 +0000
@@ -22,6 +22,7 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/i2c.h>
 #include "tm6000.h"
diff -urN linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-dvb.c linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-dvb.c
--- linux-2.6.35-rc3/drivers/staging/tm6000/tm6000-dvb.c	2010-07-05 05:34:22.688868281 +0000
+++ linux-2.6.35-rc4/drivers/staging/tm6000/tm6000-dvb.c	2010-07-05 05:34:28.052868041 +0000
@@ -18,6 +18,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 
 #include "tm6000.h"
diff -urN linux-2.6.35-rc3/drivers/staging/usbip/usbip_common.c linux-2.6.35-rc4/drivers/staging/usbip/usbip_common.c
--- linux-2.6.35-rc3/drivers/staging/usbip/usbip_common.c	2010-07-05 05:34:22.691868581 +0000
+++ linux-2.6.35-rc4/drivers/staging/usbip/usbip_common.c	2010-07-05 05:34:28.055868052 +0000
@@ -378,47 +378,67 @@
 	complete_and_exit(&ut->thread_done, 0);
 }
 
+static void stop_rx_thread(struct usbip_device *ud)
+{
+	if (ud->tcp_rx.thread != NULL) {
+		send_sig(SIGKILL, ud->tcp_rx.thread, 1);
+		wait_for_completion(&ud->tcp_rx.thread_done);
+		usbip_udbg("rx_thread for ud %p has finished\n", ud);
+	}
+}
+
+static void stop_tx_thread(struct usbip_device *ud)
+{
+	if (ud->tcp_tx.thread != NULL) {
+		send_sig(SIGKILL, ud->tcp_tx.thread, 1);
+		wait_for_completion(&ud->tcp_tx.thread_done);
+		usbip_udbg("tx_thread for ud %p has finished\n", ud);
+	}
+}
+
 int usbip_start_threads(struct usbip_device *ud)
 {
 	/*
 	 * threads are invoked per one device (per one connection).
 	 */
 	struct task_struct *th;
+	int err = 0;
 
 	th = kthread_run(usbip_thread, (void *)&ud->tcp_rx, "usbip");
 	if (IS_ERR(th)) {
 		printk(KERN_WARNING
 			"Unable to start control thread\n");
-		return PTR_ERR(th);
+		err = PTR_ERR(th);
+		goto ust_exit;
 	}
+
 	th = kthread_run(usbip_thread, (void *)&ud->tcp_tx, "usbip");
 	if (IS_ERR(th)) {
 		printk(KERN_WARNING
 			"Unable to start control thread\n");
-		return PTR_ERR(th);
+		err = PTR_ERR(th);
+		goto tx_thread_err;
 	}
 
 	/* confirm threads are starting */
 	wait_for_completion(&ud->tcp_rx.thread_done);
 	wait_for_completion(&ud->tcp_tx.thread_done);
+
 	return 0;
+
+tx_thread_err:
+	stop_rx_thread(ud);
+
+ust_exit:
+	return err;
 }
 EXPORT_SYMBOL_GPL(usbip_start_threads);
 
 void usbip_stop_threads(struct usbip_device *ud)
 {
 	/* kill threads related to this sdev, if v.c. exists */
-	if (ud->tcp_rx.thread != NULL) {
-		send_sig(SIGKILL, ud->tcp_rx.thread, 1);
-		wait_for_completion(&ud->tcp_rx.thread_done);
-		usbip_udbg("rx_thread for ud %p has finished\n", ud);
-	}
-
-	if (ud->tcp_tx.thread != NULL) {
-		send_sig(SIGKILL, ud->tcp_tx.thread, 1);
-		wait_for_completion(&ud->tcp_tx.thread_done);
-		usbip_udbg("tx_thread for ud %p has finished\n", ud);
-	}
+	stop_rx_thread(ud);
+	stop_tx_thread(ud);
 }
 EXPORT_SYMBOL_GPL(usbip_stop_threads);
 
diff -urN linux-2.6.35-rc3/drivers/staging/wlags49_h2/wl_enc.c linux-2.6.35-rc4/drivers/staging/wlags49_h2/wl_enc.c
--- linux-2.6.35-rc3/drivers/staging/wlags49_h2/wl_enc.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/staging/wlags49_h2/wl_enc.c	2010-07-05 05:34:28.110868029 +0000
@@ -62,6 +62,7 @@
 /*******************************************************************************
  *  include files
  ******************************************************************************/
+#include <linux/string.h>
 #include <wl_version.h>
 
 #include <debug.h>
diff -urN linux-2.6.35-rc3/drivers/staging/wlags49_h2/wl_sysfs.h linux-2.6.35-rc4/drivers/staging/wlags49_h2/wl_sysfs.h
--- linux-2.6.35-rc3/drivers/staging/wlags49_h2/wl_sysfs.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/staging/wlags49_h2/wl_sysfs.h	2010-07-05 05:34:28.113868076 +0000
@@ -2,6 +2,6 @@
 extern void register_wlags_sysfs(struct net_device *);
 extern void unregister_wlags_sysfs(struct net_device *);
 #else
-static void register_wlags_sysfs(struct net_device *) { return; };
-static void unregister_wlags_sysfs(struct net_device *) { return; };
+static inline void register_wlags_sysfs(struct net_device *net) { }
+static inline void unregister_wlags_sysfs(struct net_device *net) { }
 #endif
diff -urN linux-2.6.35-rc3/drivers/usb/core/driver.c linux-2.6.35-rc4/drivers/usb/core/driver.c
--- linux-2.6.35-rc3/drivers/usb/core/driver.c	2010-07-05 05:34:22.773868108 +0000
+++ linux-2.6.35-rc4/drivers/usb/core/driver.c	2010-07-05 05:34:28.136868061 +0000
@@ -1272,8 +1272,7 @@
 
 static void choose_wakeup(struct usb_device *udev, pm_message_t msg)
 {
-	int			w, i;
-	struct usb_interface	*intf;
+	int	w;
 
 	/* Remote wakeup is needed only when we actually go to sleep.
 	 * For things like FREEZE and QUIESCE, if the device is already
@@ -1285,16 +1284,10 @@
 		return;
 	}
 
-	/* If remote wakeup is permitted, see whether any interface drivers
+	/* Enable remote wakeup if it is allowed, even if no interface drivers
 	 * actually want it.
 	 */
-	w = 0;
-	if (device_may_wakeup(&udev->dev) && udev->actconfig) {
-		for (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {
-			intf = udev->actconfig->interface[i];
-			w |= intf->needs_remote_wakeup;
-		}
-	}
+	w = device_may_wakeup(&udev->dev);
 
 	/* If the device is autosuspended with the wrong wakeup setting,
 	 * autoresume now so the setting can be changed.
diff -urN linux-2.6.35-rc3/drivers/usb/core/message.c linux-2.6.35-rc4/drivers/usb/core/message.c
--- linux-2.6.35-rc3/drivers/usb/core/message.c	2010-07-05 05:34:22.776868312 +0000
+++ linux-2.6.35-rc4/drivers/usb/core/message.c	2010-07-05 05:34:28.139805523 +0000
@@ -416,8 +416,11 @@
 			/* A length of zero means transfer the whole sg list */
 			len = length;
 			if (len == 0) {
-				for_each_sg(sg, sg, nents, i)
-					len += sg->length;
+				struct scatterlist	*sg2;
+				int			j;
+
+				for_each_sg(sg, sg2, nents, j)
+					len += sg2->length;
 			}
 		} else {
 			/*
diff -urN linux-2.6.35-rc3/drivers/usb/gadget/f_eem.c linux-2.6.35-rc4/drivers/usb/gadget/f_eem.c
--- linux-2.6.35-rc3/drivers/usb/gadget/f_eem.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/usb/gadget/f_eem.c	2010-07-05 05:34:28.144868068 +0000
@@ -469,8 +469,7 @@
 				crc = get_unaligned_le32(skb->data + len
 							- ETH_FCS_LEN);
 				crc2 = ~crc32_le(~0,
-						skb->data,
-						skb->len - ETH_FCS_LEN);
+						skb->data, len - ETH_FCS_LEN);
 			} else {
 				crc = get_unaligned_be32(skb->data + len
 							- ETH_FCS_LEN);
diff -urN linux-2.6.35-rc3/drivers/usb/gadget/f_mass_storage.c linux-2.6.35-rc4/drivers/usb/gadget/f_mass_storage.c
--- linux-2.6.35-rc3/drivers/usb/gadget/f_mass_storage.c	2010-07-05 05:34:22.781805347 +0000
+++ linux-2.6.35-rc4/drivers/usb/gadget/f_mass_storage.c	2010-07-05 05:34:28.146868073 +0000
@@ -321,8 +321,8 @@
 /* Data shared by all the FSG instances. */
 struct fsg_common {
 	struct usb_gadget	*gadget;
-	struct fsg_dev		*fsg;
-	struct fsg_dev		*prev_fsg;
+	struct fsg_dev		*fsg, *new_fsg;
+	wait_queue_head_t	fsg_wait;
 
 	/* filesem protects: backing files in use */
 	struct rw_semaphore	filesem;
@@ -351,7 +351,6 @@
 	enum fsg_state		state;		/* For exception handling */
 	unsigned int		exception_req_tag;
 
-	u8			config, new_config;
 	enum data_direction	data_dir;
 	u32			data_size;
 	u32			data_size_from_cmnd;
@@ -595,7 +594,7 @@
 	u16			w_value = le16_to_cpu(ctrl->wValue);
 	u16			w_length = le16_to_cpu(ctrl->wLength);
 
-	if (!fsg->common->config)
+	if (!fsg_is_set(fsg->common))
 		return -EOPNOTSUPP;
 
 	switch (ctrl->bRequest) {
@@ -2303,24 +2302,20 @@
 	return -ENOMEM;
 }
 
-/*
- * Reset interface setting and re-init endpoint state (toggle etc).
- * Call with altsetting < 0 to disable the interface.  The only other
- * available altsetting is 0, which enables the interface.
- */
-static int do_set_interface(struct fsg_common *common, int altsetting)
+/* Reset interface setting and re-init endpoint state (toggle etc). */
+static int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)
 {
-	int	rc = 0;
-	int	i;
-	const struct usb_endpoint_descriptor	*d;
+	const struct usb_endpoint_descriptor *d;
+	struct fsg_dev *fsg;
+	int i, rc = 0;
 
 	if (common->running)
 		DBG(common, "reset interface\n");
 
 reset:
 	/* Deallocate the requests */
-	if (common->prev_fsg) {
-		struct fsg_dev *fsg = common->prev_fsg;
+	if (common->fsg) {
+		fsg = common->fsg;
 
 		for (i = 0; i < FSG_NUM_BUFFERS; ++i) {
 			struct fsg_buffhd *bh = &common->buffhds[i];
@@ -2345,88 +2340,53 @@
 			fsg->bulk_out_enabled = 0;
 		}
 
-		common->prev_fsg = 0;
+		common->fsg = NULL;
+		wake_up(&common->fsg_wait);
 	}
 
 	common->running = 0;
-	if (altsetting < 0 || rc != 0)
+	if (!new_fsg || rc)
 		return rc;
 
-	DBG(common, "set interface %d\n", altsetting);
+	common->fsg = new_fsg;
+	fsg = common->fsg;
+
+	/* Enable the endpoints */
+	d = fsg_ep_desc(common->gadget,
+			&fsg_fs_bulk_in_desc, &fsg_hs_bulk_in_desc);
+	rc = enable_endpoint(common, fsg->bulk_in, d);
+	if (rc)
+		goto reset;
+	fsg->bulk_in_enabled = 1;
+
+	d = fsg_ep_desc(common->gadget,
+			&fsg_fs_bulk_out_desc, &fsg_hs_bulk_out_desc);
+	rc = enable_endpoint(common, fsg->bulk_out, d);
+	if (rc)
+		goto reset;
+	fsg->bulk_out_enabled = 1;
+	common->bulk_out_maxpacket = le16_to_cpu(d->wMaxPacketSize);
+	clear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
+
+	/* Allocate the requests */
+	for (i = 0; i < FSG_NUM_BUFFERS; ++i) {
+		struct fsg_buffhd	*bh = &common->buffhds[i];
 
-	if (fsg_is_set(common)) {
-		struct fsg_dev *fsg = common->fsg;
-		common->prev_fsg = common->fsg;
-
-		/* Enable the endpoints */
-		d = fsg_ep_desc(common->gadget,
-				&fsg_fs_bulk_in_desc, &fsg_hs_bulk_in_desc);
-		rc = enable_endpoint(common, fsg->bulk_in, d);
+		rc = alloc_request(common, fsg->bulk_in, &bh->inreq);
 		if (rc)
 			goto reset;
-		fsg->bulk_in_enabled = 1;
-
-		d = fsg_ep_desc(common->gadget,
-				&fsg_fs_bulk_out_desc, &fsg_hs_bulk_out_desc);
-		rc = enable_endpoint(common, fsg->bulk_out, d);
+		rc = alloc_request(common, fsg->bulk_out, &bh->outreq);
 		if (rc)
 			goto reset;
-		fsg->bulk_out_enabled = 1;
-		common->bulk_out_maxpacket = le16_to_cpu(d->wMaxPacketSize);
-		clear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
-
-		/* Allocate the requests */
-		for (i = 0; i < FSG_NUM_BUFFERS; ++i) {
-			struct fsg_buffhd	*bh = &common->buffhds[i];
-
-			rc = alloc_request(common, fsg->bulk_in, &bh->inreq);
-			if (rc)
-				goto reset;
-			rc = alloc_request(common, fsg->bulk_out, &bh->outreq);
-			if (rc)
-				goto reset;
-			bh->inreq->buf = bh->outreq->buf = bh->buf;
-			bh->inreq->context = bh->outreq->context = bh;
-			bh->inreq->complete = bulk_in_complete;
-			bh->outreq->complete = bulk_out_complete;
-		}
-
-		common->running = 1;
-		for (i = 0; i < common->nluns; ++i)
-			common->luns[i].unit_attention_data = SS_RESET_OCCURRED;
-		return rc;
-	} else {
-		return -EIO;
-	}
-}
-
-
-/*
- * Change our operational configuration.  This code must agree with the code
- * that returns config descriptors, and with interface altsetting code.
- *
- * It's also responsible for power management interactions.  Some
- * configurations might not work with our current power sources.
- * For now we just assume the gadget is always self-powered.
- */
-static int do_set_config(struct fsg_common *common, u8 new_config)
-{
-	int	rc = 0;
-
-	/* Disable the single interface */
-	if (common->config != 0) {
-		DBG(common, "reset config\n");
-		common->config = 0;
-		rc = do_set_interface(common, -1);
+		bh->inreq->buf = bh->outreq->buf = bh->buf;
+		bh->inreq->context = bh->outreq->context = bh;
+		bh->inreq->complete = bulk_in_complete;
+		bh->outreq->complete = bulk_out_complete;
 	}
 
-	/* Enable the interface */
-	if (new_config != 0) {
-		common->config = new_config;
-		rc = do_set_interface(common, 0);
-		if (rc != 0)
-			common->config = 0;	/* Reset on errors */
-	}
+	common->running = 1;
+	for (i = 0; i < common->nluns; ++i)
+		common->luns[i].unit_attention_data = SS_RESET_OCCURRED;
 	return rc;
 }
 
@@ -2437,9 +2397,7 @@
 static int fsg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 {
 	struct fsg_dev *fsg = fsg_from_func(f);
-	fsg->common->prev_fsg = fsg->common->fsg;
-	fsg->common->fsg = fsg;
-	fsg->common->new_config = 1;
+	fsg->common->new_fsg = fsg;
 	raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);
 	return 0;
 }
@@ -2447,9 +2405,7 @@
 static void fsg_disable(struct usb_function *f)
 {
 	struct fsg_dev *fsg = fsg_from_func(f);
-	fsg->common->prev_fsg = fsg->common->fsg;
-	fsg->common->fsg = fsg;
-	fsg->common->new_config = 0;
+	fsg->common->new_fsg = NULL;
 	raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);
 }
 
@@ -2459,19 +2415,17 @@
 static void handle_exception(struct fsg_common *common)
 {
 	siginfo_t		info;
-	int			sig;
 	int			i;
 	struct fsg_buffhd	*bh;
 	enum fsg_state		old_state;
-	u8			new_config;
 	struct fsg_lun		*curlun;
 	unsigned int		exception_req_tag;
-	int			rc;
 
 	/* Clear the existing signals.  Anything but SIGUSR1 is converted
 	 * into a high-priority EXIT exception. */
 	for (;;) {
-		sig = dequeue_signal_lock(current, &current->blocked, &info);
+		int sig =
+			dequeue_signal_lock(current, &current->blocked, &info);
 		if (!sig)
 			break;
 		if (sig != SIGUSR1) {
@@ -2482,7 +2436,7 @@
 	}
 
 	/* Cancel all the pending transfers */
-	if (fsg_is_set(common)) {
+	if (likely(common->fsg)) {
 		for (i = 0; i < FSG_NUM_BUFFERS; ++i) {
 			bh = &common->buffhds[i];
 			if (bh->inreq_busy)
@@ -2523,7 +2477,6 @@
 	common->next_buffhd_to_fill = &common->buffhds[0];
 	common->next_buffhd_to_drain = &common->buffhds[0];
 	exception_req_tag = common->exception_req_tag;
-	new_config = common->new_config;
 	old_state = common->state;
 
 	if (old_state == FSG_STATE_ABORT_BULK_OUT)
@@ -2573,12 +2526,12 @@
 		break;
 
 	case FSG_STATE_CONFIG_CHANGE:
-		rc = do_set_config(common, new_config);
+		do_set_interface(common, common->new_fsg);
 		break;
 
 	case FSG_STATE_EXIT:
 	case FSG_STATE_TERMINATED:
-		do_set_config(common, 0);		/* Free resources */
+		do_set_interface(common, NULL);		/* Free resources */
 		spin_lock_irq(&common->lock);
 		common->state = FSG_STATE_TERMINATED;	/* Stop the thread */
 		spin_unlock_irq(&common->lock);
@@ -2863,6 +2816,7 @@
 		goto error_release;
 	}
 	init_completion(&common->thread_notifier);
+	init_waitqueue_head(&common->fsg_wait);
 #undef OR
 
 
@@ -2957,9 +2911,17 @@
 static void fsg_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct fsg_dev		*fsg = fsg_from_func(f);
+	struct fsg_common	*common = fsg->common;
 
 	DBG(fsg, "unbind\n");
-	fsg_common_put(fsg->common);
+	if (fsg->common->fsg == fsg) {
+		fsg->common->new_fsg = NULL;
+		raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);
+		/* FIXME: make interruptible or killable somehow? */
+		wait_event(common->fsg_wait, common->fsg != fsg);
+	}
+
+	fsg_common_put(common);
 	usb_free_descriptors(fsg->function.descriptors);
 	usb_free_descriptors(fsg->function.hs_descriptors);
 	kfree(fsg);
@@ -2970,7 +2932,6 @@
 {
 	struct fsg_dev		*fsg = fsg_from_func(f);
 	struct usb_gadget	*gadget = c->cdev->gadget;
-	int			rc;
 	int			i;
 	struct usb_ep		*ep;
 
@@ -2996,6 +2957,11 @@
 	ep->driver_data = fsg->common;	/* claim the endpoint */
 	fsg->bulk_out = ep;
 
+	/* Copy descriptors */
+	f->descriptors = usb_copy_descriptors(fsg_fs_function);
+	if (unlikely(!f->descriptors))
+		return -ENOMEM;
+
 	if (gadget_is_dualspeed(gadget)) {
 		/* Assume endpoint addresses are the same for both speeds */
 		fsg_hs_bulk_in_desc.bEndpointAddress =
@@ -3003,16 +2969,17 @@
 		fsg_hs_bulk_out_desc.bEndpointAddress =
 			fsg_fs_bulk_out_desc.bEndpointAddress;
 		f->hs_descriptors = usb_copy_descriptors(fsg_hs_function);
-		if (unlikely(!f->hs_descriptors))
+		if (unlikely(!f->hs_descriptors)) {
+			usb_free_descriptors(f->descriptors);
 			return -ENOMEM;
+		}
 	}
 
 	return 0;
 
 autoconf_fail:
 	ERROR(fsg, "unable to autoconfigure all endpoints\n");
-	rc = -ENOTSUPP;
-	return rc;
+	return -ENOTSUPP;
 }
 
 
@@ -3036,11 +3003,6 @@
 
 	fsg->function.name        = FSG_DRIVER_DESC;
 	fsg->function.strings     = fsg_strings_array;
-	fsg->function.descriptors = usb_copy_descriptors(fsg_fs_function);
-	if (unlikely(!fsg->function.descriptors)) {
-		rc = -ENOMEM;
-		goto error_free_fsg;
-	}
 	fsg->function.bind        = fsg_bind;
 	fsg->function.unbind      = fsg_unbind;
 	fsg->function.setup       = fsg_setup;
@@ -3056,19 +3018,9 @@
 
 	rc = usb_add_function(c, &fsg->function);
 	if (unlikely(rc))
-		goto error_free_all;
-
-	fsg_common_get(fsg->common);
-	return 0;
-
-error_free_all:
-	usb_free_descriptors(fsg->function.descriptors);
-	/* fsg_bind() might have copied those; or maybe not? who cares
-	 * -- free it just in case. */
-	usb_free_descriptors(fsg->function.hs_descriptors);
-error_free_fsg:
-	kfree(fsg);
-
+		kfree(fsg);
+	else
+		fsg_common_get(fsg->common);
 	return rc;
 }
 
diff -urN linux-2.6.35-rc3/drivers/usb/gadget/g_ffs.c linux-2.6.35-rc4/drivers/usb/gadget/g_ffs.c
--- linux-2.6.35-rc3/drivers/usb/gadget/g_ffs.c	2010-07-05 05:34:22.784805029 +0000
+++ linux-2.6.35-rc4/drivers/usb/gadget/g_ffs.c	2010-07-05 05:34:28.148868049 +0000
@@ -392,6 +392,17 @@
 	if (unlikely(ret < 0))
 		return ret;
 
+	/* After previous do_configs there may be some invalid
+	 * pointers in c->interface array.  This happens every time
+	 * a user space function with fewer interfaces than a user
+	 * space function that was run before the new one is run.  The
+	 * compasit's set_config() assumes that if there is no more
+	 * then MAX_CONFIG_INTERFACES interfaces in a configuration
+	 * then there is a NULL pointer after the last interface in
+	 * c->interface array.  We need to make sure this is true. */
+	if (c->next_interface_id < ARRAY_SIZE(c->interface))
+		c->interface[c->next_interface_id] = NULL;
+
 	return 0;
 }
 
diff -urN linux-2.6.35-rc3/drivers/usb/gadget/printer.c linux-2.6.35-rc4/drivers/usb/gadget/printer.c
--- linux-2.6.35-rc3/drivers/usb/gadget/printer.c	2010-07-05 05:34:22.784805029 +0000
+++ linux-2.6.35-rc4/drivers/usb/gadget/printer.c	2010-07-05 05:34:28.149868061 +0000
@@ -82,7 +82,7 @@
 struct printer_dev {
 	spinlock_t		lock;		/* lock this structure */
 	/* lock buffer lists during read/write calls */
-	spinlock_t		lock_printer_io;
+	struct mutex		lock_printer_io;
 	struct usb_gadget	*gadget;
 	struct usb_request	*req;		/* for control responses */
 	u8			config;
@@ -567,7 +567,7 @@
 
 	DBG(dev, "printer_read trying to read %d bytes\n", (int)len);
 
-	spin_lock(&dev->lock_printer_io);
+	mutex_lock(&dev->lock_printer_io);
 	spin_lock_irqsave(&dev->lock, flags);
 
 	/* We will use this flag later to check if a printer reset happened
@@ -601,7 +601,7 @@
 		 * call or not.
 		 */
 		if (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {
-			spin_unlock(&dev->lock_printer_io);
+			mutex_unlock(&dev->lock_printer_io);
 			return -EAGAIN;
 		}
 
@@ -648,7 +648,7 @@
 		if (dev->reset_printer) {
 			list_add(&current_rx_req->list, &dev->rx_reqs);
 			spin_unlock_irqrestore(&dev->lock, flags);
-			spin_unlock(&dev->lock_printer_io);
+			mutex_unlock(&dev->lock_printer_io);
 			return -EAGAIN;
 		}
 
@@ -673,7 +673,7 @@
 	dev->current_rx_buf = current_rx_buf;
 
 	spin_unlock_irqrestore(&dev->lock, flags);
-	spin_unlock(&dev->lock_printer_io);
+	mutex_unlock(&dev->lock_printer_io);
 
 	DBG(dev, "printer_read returned %d bytes\n", (int)bytes_copied);
 
@@ -697,7 +697,7 @@
 	if (len == 0)
 		return -EINVAL;
 
-	spin_lock(&dev->lock_printer_io);
+	mutex_lock(&dev->lock_printer_io);
 	spin_lock_irqsave(&dev->lock, flags);
 
 	/* Check if a printer reset happens while we have interrupts on */
@@ -713,7 +713,7 @@
 		 * a NON-Blocking call or not.
 		 */
 		if (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {
-			spin_unlock(&dev->lock_printer_io);
+			mutex_unlock(&dev->lock_printer_io);
 			return -EAGAIN;
 		}
 
@@ -752,7 +752,7 @@
 
 		if (copy_from_user(req->buf, buf, size)) {
 			list_add(&req->list, &dev->tx_reqs);
-			spin_unlock(&dev->lock_printer_io);
+			mutex_unlock(&dev->lock_printer_io);
 			return bytes_copied;
 		}
 
@@ -766,14 +766,14 @@
 		if (dev->reset_printer) {
 			list_add(&req->list, &dev->tx_reqs);
 			spin_unlock_irqrestore(&dev->lock, flags);
-			spin_unlock(&dev->lock_printer_io);
+			mutex_unlock(&dev->lock_printer_io);
 			return -EAGAIN;
 		}
 
 		if (usb_ep_queue(dev->in_ep, req, GFP_ATOMIC)) {
 			list_add(&req->list, &dev->tx_reqs);
 			spin_unlock_irqrestore(&dev->lock, flags);
-			spin_unlock(&dev->lock_printer_io);
+			mutex_unlock(&dev->lock_printer_io);
 			return -EAGAIN;
 		}
 
@@ -782,7 +782,7 @@
 	}
 
 	spin_unlock_irqrestore(&dev->lock, flags);
-	spin_unlock(&dev->lock_printer_io);
+	mutex_unlock(&dev->lock_printer_io);
 
 	DBG(dev, "printer_write sent %d bytes\n", (int)bytes_copied);
 
@@ -820,11 +820,11 @@
 	unsigned long		flags;
 	int			status = 0;
 
-	spin_lock(&dev->lock_printer_io);
+	mutex_lock(&dev->lock_printer_io);
 	spin_lock_irqsave(&dev->lock, flags);
 	setup_rx_reqs(dev);
 	spin_unlock_irqrestore(&dev->lock, flags);
-	spin_unlock(&dev->lock_printer_io);
+	mutex_unlock(&dev->lock_printer_io);
 
 	poll_wait(fd, &dev->rx_wait, wait);
 	poll_wait(fd, &dev->tx_wait, wait);
@@ -1461,7 +1461,7 @@
 	}
 
 	spin_lock_init(&dev->lock);
-	spin_lock_init(&dev->lock_printer_io);
+	mutex_init(&dev->lock_printer_io);
 	INIT_LIST_HEAD(&dev->tx_reqs);
 	INIT_LIST_HEAD(&dev->tx_reqs_active);
 	INIT_LIST_HEAD(&dev->rx_reqs);
@@ -1594,7 +1594,7 @@
 {
 	int status;
 
-	spin_lock(&usb_printer_gadget.lock_printer_io);
+	mutex_lock(&usb_printer_gadget.lock_printer_io);
 	class_destroy(usb_gadget_class);
 	unregister_chrdev_region(g_printer_devno, 2);
 
@@ -1602,6 +1602,6 @@
 	if (status)
 		ERROR(dev, "usb_gadget_unregister_driver %x\n", status);
 
-	spin_unlock(&usb_printer_gadget.lock_printer_io);
+	mutex_unlock(&usb_printer_gadget.lock_printer_io);
 }
 module_exit(cleanup);
diff -urN linux-2.6.35-rc3/drivers/usb/gadget/s3c2410_udc.c linux-2.6.35-rc4/drivers/usb/gadget/s3c2410_udc.c
--- linux-2.6.35-rc3/drivers/usb/gadget/s3c2410_udc.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/usb/gadget/s3c2410_udc.c	2010-07-05 05:34:28.150868093 +0000
@@ -1700,9 +1700,13 @@
 	if (!driver || driver != udc->driver || !driver->unbind)
 		return -EINVAL;
 
-	dprintk(DEBUG_NORMAL,"usb_gadget_register_driver() '%s'\n",
+	dprintk(DEBUG_NORMAL, "usb_gadget_unregister_driver() '%s'\n",
 		driver->driver.name);
 
+	/* report disconnect */
+	if (driver->disconnect)
+		driver->disconnect(&udc->gadget);
+
 	driver->unbind(&udc->gadget);
 
 	device_del(&udc->gadget.dev);
diff -urN linux-2.6.35-rc3/drivers/usb/gadget/u_serial.c linux-2.6.35-rc4/drivers/usb/gadget/u_serial.c
--- linux-2.6.35-rc3/drivers/usb/gadget/u_serial.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/usb/gadget/u_serial.c	2010-07-05 05:34:28.150868093 +0000
@@ -536,17 +536,11 @@
 		list_move(&req->list, &port->read_pool);
 	}
 
-	/* Push from tty to ldisc; this is immediate with low_latency, and
-	 * may trigger callbacks to this driver ... so drop the spinlock.
+	/* Push from tty to ldisc; without low_latency set this is handled by
+	 * a workqueue, so we won't get callbacks and can hold port_lock
 	 */
 	if (tty && do_push) {
-		spin_unlock_irq(&port->port_lock);
 		tty_flip_buffer_push(tty);
-		wake_up_interruptible(&tty->read_wait);
-		spin_lock_irq(&port->port_lock);
-
-		/* tty may have been closed */
-		tty = port->port_tty;
 	}
 
 
@@ -784,11 +778,6 @@
 	port->open_count = 1;
 	port->openclose = false;
 
-	/* low_latency means ldiscs work in tasklet context, without
-	 * needing a workqueue schedule ... easier to keep up.
-	 */
-	tty->low_latency = 1;
-
 	/* if connected, start the I/O stream */
 	if (port->port_usb) {
 		struct gserial	*gser = port->port_usb;
@@ -1195,6 +1184,7 @@
 	n_ports = 0;
 
 	tty_unregister_driver(gs_tty_driver);
+	put_tty_driver(gs_tty_driver);
 	gs_tty_driver = NULL;
 
 	pr_debug("%s: cleaned up ttyGS* support\n", __func__);
diff -urN linux-2.6.35-rc3/drivers/usb/host/ehci-mxc.c linux-2.6.35-rc4/drivers/usb/host/ehci-mxc.c
--- linux-2.6.35-rc3/drivers/usb/host/ehci-mxc.c	2010-07-05 05:34:22.788868078 +0000
+++ linux-2.6.35-rc4/drivers/usb/host/ehci-mxc.c	2010-07-05 05:34:28.153868060 +0000
@@ -207,10 +207,17 @@
 	/* Initialize the transceiver */
 	if (pdata->otg) {
 		pdata->otg->io_priv = hcd->regs + ULPI_VIEWPORT_OFFSET;
-		if (otg_init(pdata->otg) != 0)
-			dev_err(dev, "unable to init transceiver\n");
-		else if (otg_set_vbus(pdata->otg, 1) != 0)
+		ret = otg_init(pdata->otg);
+		if (ret) {
+			dev_err(dev, "unable to init transceiver, probably missing\n");
+			ret = -ENODEV;
+			goto err_add;
+		}
+		ret = otg_set_vbus(pdata->otg, 1);
+		if (ret) {
 			dev_err(dev, "unable to enable vbus on transceiver\n");
+			goto err_add;
+		}
 	}
 
 	priv->hcd = hcd;
diff -urN linux-2.6.35-rc3/drivers/usb/host/isp1362-hcd.c linux-2.6.35-rc4/drivers/usb/host/isp1362-hcd.c
--- linux-2.6.35-rc3/drivers/usb/host/isp1362-hcd.c	2010-07-05 05:34:22.791868312 +0000
+++ linux-2.6.35-rc4/drivers/usb/host/isp1362-hcd.c	2010-07-05 05:34:28.156868011 +0000
@@ -2224,12 +2224,9 @@
 
 /*-------------------------------------------------------------------------*/
 
-static void isp1362_sw_reset(struct isp1362_hcd *isp1362_hcd)
+static void __isp1362_sw_reset(struct isp1362_hcd *isp1362_hcd)
 {
 	int tmp = 20;
-	unsigned long flags;
-
-	spin_lock_irqsave(&isp1362_hcd->lock, flags);
 
 	isp1362_write_reg16(isp1362_hcd, HCSWRES, HCSWRES_MAGIC);
 	isp1362_write_reg32(isp1362_hcd, HCCMDSTAT, OHCI_HCR);
@@ -2240,6 +2237,14 @@
 	}
 	if (!tmp)
 		pr_err("Software reset timeout\n");
+}
+
+static void isp1362_sw_reset(struct isp1362_hcd *isp1362_hcd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&isp1362_hcd->lock, flags);
+	__isp1362_sw_reset(isp1362_hcd);
 	spin_unlock_irqrestore(&isp1362_hcd->lock, flags);
 }
 
@@ -2418,7 +2423,7 @@
 	if (isp1362_hcd->board && isp1362_hcd->board->reset)
 		isp1362_hcd->board->reset(hcd->self.controller, 1);
 	else
-		isp1362_sw_reset(isp1362_hcd);
+		__isp1362_sw_reset(isp1362_hcd);
 
 	if (isp1362_hcd->board && isp1362_hcd->board->clock)
 		isp1362_hcd->board->clock(hcd->self.controller, 0);
diff -urN linux-2.6.35-rc3/drivers/usb/host/r8a66597-hcd.c linux-2.6.35-rc4/drivers/usb/host/r8a66597-hcd.c
--- linux-2.6.35-rc3/drivers/usb/host/r8a66597-hcd.c	2010-07-05 05:34:22.793868289 +0000
+++ linux-2.6.35-rc4/drivers/usb/host/r8a66597-hcd.c	2010-07-05 05:34:28.158868046 +0000
@@ -1065,7 +1065,7 @@
 	else if (speed == LSMODE)
 		rh->port |= USB_PORT_STAT_LOW_SPEED;
 
-	rh->port &= USB_PORT_STAT_RESET;
+	rh->port &= ~USB_PORT_STAT_RESET;
 	rh->port |= USB_PORT_STAT_ENABLE;
 }
 
diff -urN linux-2.6.35-rc3/drivers/usb/host/xhci-ring.c linux-2.6.35-rc4/drivers/usb/host/xhci-ring.c
--- linux-2.6.35-rc3/drivers/usb/host/xhci-ring.c	2010-07-05 05:34:22.797868126 +0000
+++ linux-2.6.35-rc4/drivers/usb/host/xhci-ring.c	2010-07-05 05:34:28.161868016 +0000
@@ -182,8 +182,12 @@
  * set, but other sections talk about dealing with the chain bit set.  This was
  * fixed in the 0.96 specification errata, but we have to assume that all 0.95
  * xHCI hardware can't handle the chain bit being cleared on a link TRB.
+ *
+ * @more_trbs_coming:	Will you enqueue more TRBs before calling
+ *			prepare_transfer()?
  */
-static void inc_enq(struct xhci_hcd *xhci, struct xhci_ring *ring, bool consumer)
+static void inc_enq(struct xhci_hcd *xhci, struct xhci_ring *ring,
+		bool consumer, bool more_trbs_coming)
 {
 	u32 chain;
 	union xhci_trb *next;
@@ -199,15 +203,28 @@
 	while (last_trb(xhci, ring, ring->enq_seg, next)) {
 		if (!consumer) {
 			if (ring != xhci->event_ring) {
-				if (chain) {
-					next->link.control |= TRB_CHAIN;
-
-					/* Give this link TRB to the hardware */
-					wmb();
-					next->link.control ^= TRB_CYCLE;
-				} else {
+				/*
+				 * If the caller doesn't plan on enqueueing more
+				 * TDs before ringing the doorbell, then we
+				 * don't want to give the link TRB to the
+				 * hardware just yet.  We'll give the link TRB
+				 * back in prepare_ring() just before we enqueue
+				 * the TD at the top of the ring.
+				 */
+				if (!chain && !more_trbs_coming)
 					break;
+
+				/* If we're not dealing with 0.95 hardware,
+				 * carry over the chain bit of the previous TRB
+				 * (which may mean the chain bit is cleared).
+				 */
+				if (!xhci_link_trb_quirk(xhci)) {
+					next->link.control &= ~TRB_CHAIN;
+					next->link.control |= chain;
 				}
+				/* Give this link TRB to the hardware */
+				wmb();
+				next->link.control ^= TRB_CYCLE;
 			}
 			/* Toggle the cycle bit after the last ring segment. */
 			if (last_trb_on_last_seg(xhci, ring, ring->enq_seg, next)) {
@@ -1707,9 +1724,12 @@
 /*
  * Generic function for queueing a TRB on a ring.
  * The caller must have checked to make sure there's room on the ring.
+ *
+ * @more_trbs_coming:	Will you enqueue more TRBs before calling
+ *			prepare_transfer()?
  */
 static void queue_trb(struct xhci_hcd *xhci, struct xhci_ring *ring,
-		bool consumer,
+		bool consumer, bool more_trbs_coming,
 		u32 field1, u32 field2, u32 field3, u32 field4)
 {
 	struct xhci_generic_trb *trb;
@@ -1719,7 +1739,7 @@
 	trb->field[1] = field2;
 	trb->field[2] = field3;
 	trb->field[3] = field4;
-	inc_enq(xhci, ring, consumer);
+	inc_enq(xhci, ring, consumer, more_trbs_coming);
 }
 
 /*
@@ -1988,6 +2008,7 @@
 	int trb_buff_len, this_sg_len, running_total;
 	bool first_trb;
 	u64 addr;
+	bool more_trbs_coming;
 
 	struct xhci_generic_trb *start_trb;
 	int start_cycle;
@@ -2073,7 +2094,11 @@
 		length_field = TRB_LEN(trb_buff_len) |
 			remainder |
 			TRB_INTR_TARGET(0);
-		queue_trb(xhci, ep_ring, false,
+		if (num_trbs > 1)
+			more_trbs_coming = true;
+		else
+			more_trbs_coming = false;
+		queue_trb(xhci, ep_ring, false, more_trbs_coming,
 				lower_32_bits(addr),
 				upper_32_bits(addr),
 				length_field,
@@ -2124,6 +2149,7 @@
 	int num_trbs;
 	struct xhci_generic_trb *start_trb;
 	bool first_trb;
+	bool more_trbs_coming;
 	int start_cycle;
 	u32 field, length_field;
 
@@ -2212,7 +2238,11 @@
 		length_field = TRB_LEN(trb_buff_len) |
 			remainder |
 			TRB_INTR_TARGET(0);
-		queue_trb(xhci, ep_ring, false,
+		if (num_trbs > 1)
+			more_trbs_coming = true;
+		else
+			more_trbs_coming = false;
+		queue_trb(xhci, ep_ring, false, more_trbs_coming,
 				lower_32_bits(addr),
 				upper_32_bits(addr),
 				length_field,
@@ -2291,7 +2321,7 @@
 	/* Queue setup TRB - see section 6.4.1.2.1 */
 	/* FIXME better way to translate setup_packet into two u32 fields? */
 	setup = (struct usb_ctrlrequest *) urb->setup_packet;
-	queue_trb(xhci, ep_ring, false,
+	queue_trb(xhci, ep_ring, false, true,
 			/* FIXME endianness is probably going to bite my ass here. */
 			setup->bRequestType | setup->bRequest << 8 | setup->wValue << 16,
 			setup->wIndex | setup->wLength << 16,
@@ -2307,7 +2337,7 @@
 	if (urb->transfer_buffer_length > 0) {
 		if (setup->bRequestType & USB_DIR_IN)
 			field |= TRB_DIR_IN;
-		queue_trb(xhci, ep_ring, false,
+		queue_trb(xhci, ep_ring, false, true,
 				lower_32_bits(urb->transfer_dma),
 				upper_32_bits(urb->transfer_dma),
 				length_field,
@@ -2324,7 +2354,7 @@
 		field = 0;
 	else
 		field = TRB_DIR_IN;
-	queue_trb(xhci, ep_ring, false,
+	queue_trb(xhci, ep_ring, false, false,
 			0,
 			0,
 			TRB_INTR_TARGET(0),
@@ -2361,7 +2391,7 @@
 					"unfailable commands failed.\n");
 		return -ENOMEM;
 	}
-	queue_trb(xhci, xhci->cmd_ring, false, field1, field2, field3,
+	queue_trb(xhci, xhci->cmd_ring, false, false, field1, field2, field3,
 			field4 | xhci->cmd_ring->cycle_state);
 	return 0;
 }
diff -urN linux-2.6.35-rc3/drivers/usb/musb/musb_core.c linux-2.6.35-rc4/drivers/usb/musb/musb_core.c
--- linux-2.6.35-rc3/drivers/usb/musb/musb_core.c	2010-07-05 05:34:22.802869210 +0000
+++ linux-2.6.35-rc4/drivers/usb/musb/musb_core.c	2010-07-05 05:34:28.166868062 +0000
@@ -219,8 +219,8 @@
 	return 0;
 }
 #else
-#define musb_ulpi_read(a, b)		NULL
-#define musb_ulpi_write(a, b, c)	NULL
+#define musb_ulpi_read		NULL
+#define musb_ulpi_write		NULL
 #endif
 
 static struct otg_io_access_ops musb_ulpi_access = {
@@ -451,10 +451,6 @@
  * @param power
  */
 
-#define STAGE0_MASK (MUSB_INTR_RESUME | MUSB_INTR_SESSREQ \
-		| MUSB_INTR_VBUSERROR | MUSB_INTR_CONNECT \
-		| MUSB_INTR_RESET)
-
 static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,
 				u8 devctl, u8 power)
 {
@@ -642,7 +638,7 @@
 		handled = IRQ_HANDLED;
 	}
 
-
+#endif
 	if (int_usb & MUSB_INTR_SUSPEND) {
 		DBG(1, "SUSPEND (%s) devctl %02x power %02x\n",
 				otg_state_string(musb), devctl, power);
@@ -705,6 +701,7 @@
 		}
 	}
 
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	if (int_usb & MUSB_INTR_CONNECT) {
 		struct usb_hcd *hcd = musb_to_hcd(musb);
 		void __iomem *mbase = musb->mregs;
@@ -1597,7 +1594,7 @@
 	/* the core can interrupt us for multiple reasons; docs have
 	 * a generic interrupt flowchart to follow
 	 */
-	if (musb->int_usb & STAGE0_MASK)
+	if (musb->int_usb)
 		retval |= musb_stage0_irq(musb, musb->int_usb,
 				devctl, power);
 
diff -urN linux-2.6.35-rc3/drivers/usb/musb/musb_core.h linux-2.6.35-rc4/drivers/usb/musb/musb_core.h
--- linux-2.6.35-rc3/drivers/usb/musb/musb_core.h	2010-07-05 05:34:22.802869210 +0000
+++ linux-2.6.35-rc4/drivers/usb/musb/musb_core.h	2010-07-05 05:34:28.166868062 +0000
@@ -470,7 +470,8 @@
 
 struct musb_context_registers {
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+    defined(CONFIG_ARCH_OMAP4)
 	u32 otg_sysconfig, otg_forcestandby;
 #endif
 	u8 power;
@@ -484,7 +485,8 @@
 	struct musb_csr_regs index_regs[MUSB_C_NUM_EPS];
 };
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3) || \
+    defined(CONFIG_ARCH_OMAP4)
 extern void musb_platform_save_context(struct musb *musb,
 		struct musb_context_registers *musb_context);
 extern void musb_platform_restore_context(struct musb *musb,
diff -urN linux-2.6.35-rc3/drivers/usb/musb/musbhsdma.c linux-2.6.35-rc4/drivers/usb/musb/musbhsdma.c
--- linux-2.6.35-rc3/drivers/usb/musb/musbhsdma.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/usb/musb/musbhsdma.c	2010-07-05 05:34:28.167868043 +0000
@@ -132,18 +132,9 @@
 	if (mode) {
 		csr |= 1 << MUSB_HSDMA_MODE1_SHIFT;
 		BUG_ON(len < packet_sz);
-
-		if (packet_sz >= 64) {
-			csr |= MUSB_HSDMA_BURSTMODE_INCR16
-					<< MUSB_HSDMA_BURSTMODE_SHIFT;
-		} else if (packet_sz >= 32) {
-			csr |= MUSB_HSDMA_BURSTMODE_INCR8
-					<< MUSB_HSDMA_BURSTMODE_SHIFT;
-		} else if (packet_sz >= 16) {
-			csr |= MUSB_HSDMA_BURSTMODE_INCR4
-					<< MUSB_HSDMA_BURSTMODE_SHIFT;
-		}
 	}
+	csr |= MUSB_HSDMA_BURSTMODE_INCR16
+				<< MUSB_HSDMA_BURSTMODE_SHIFT;
 
 	csr |= (musb_channel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
 		| (1 << MUSB_HSDMA_ENABLE_SHIFT)
diff -urN linux-2.6.35-rc3/drivers/usb/otg/ulpi.c linux-2.6.35-rc4/drivers/usb/otg/ulpi.c
--- linux-2.6.35-rc3/drivers/usb/otg/ulpi.c	2010-07-05 05:34:22.803868067 +0000
+++ linux-2.6.35-rc4/drivers/usb/otg/ulpi.c	2010-07-05 05:34:28.168868096 +0000
@@ -59,12 +59,17 @@
 
 static int ulpi_init(struct otg_transceiver *otg)
 {
-	int i, vid, pid;
+	int i, vid, pid, ret;
+	u32 ulpi_id = 0;
 
-	vid = (otg_io_read(otg, ULPI_VENDOR_ID_HIGH) << 8) |
-	       otg_io_read(otg, ULPI_VENDOR_ID_LOW);
-	pid = (otg_io_read(otg, ULPI_PRODUCT_ID_HIGH) << 8) |
-	       otg_io_read(otg, ULPI_PRODUCT_ID_LOW);
+	for (i = 0; i < 4; i++) {
+		ret = otg_io_read(otg, ULPI_PRODUCT_ID_HIGH - i);
+		if (ret < 0)
+			return ret;
+		ulpi_id = (ulpi_id << 8) | ret;
+	}
+	vid = ulpi_id & 0xffff;
+	pid = ulpi_id >> 16;
 
 	pr_info("ULPI transceiver vendor/product ID 0x%04x/0x%04x\n", vid, pid);
 
diff -urN linux-2.6.35-rc3/drivers/usb/serial/ftdi_sio.c linux-2.6.35-rc4/drivers/usb/serial/ftdi_sio.c
--- linux-2.6.35-rc3/drivers/usb/serial/ftdi_sio.c	2010-07-05 05:34:22.807868042 +0000
+++ linux-2.6.35-rc4/drivers/usb/serial/ftdi_sio.c	2010-07-05 05:34:28.172868044 +0000
@@ -653,7 +653,6 @@
 	{ USB_DEVICE(EVOLUTION_VID, EVOLUTION_ER1_PID) },
 	{ USB_DEVICE(EVOLUTION_VID, EVO_HYBRID_PID) },
 	{ USB_DEVICE(EVOLUTION_VID, EVO_RCM4_PID) },
-	{ USB_DEVICE(CONTEC_VID, CONTEC_COM1USBH_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ARTEMIS_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ATIK_ATK16_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ATIK_ATK16C_PID) },
diff -urN linux-2.6.35-rc3/drivers/usb/serial/ftdi_sio_ids.h linux-2.6.35-rc4/drivers/usb/serial/ftdi_sio_ids.h
--- linux-2.6.35-rc3/drivers/usb/serial/ftdi_sio_ids.h	2010-07-05 05:34:22.808869238 +0000
+++ linux-2.6.35-rc4/drivers/usb/serial/ftdi_sio_ids.h	2010-07-05 05:34:28.173868058 +0000
@@ -501,13 +501,6 @@
 #define CONTEC_COM1USBH_PID	0x8311	/* COM-1(USB)H */
 
 /*
- * Contec products (http://www.contec.com)
- * Submitted by Daniel Sangorrin
- */
-#define CONTEC_VID		0x06CE	/* Vendor ID */
-#define CONTEC_COM1USBH_PID	0x8311	/* COM-1(USB)H */
-
-/*
  * Definitions for B&B Electronics products.
  */
 #define BANDB_VID		0x0856	/* B&B Electronics Vendor ID */
diff -urN linux-2.6.35-rc3/drivers/usb/serial/qcserial.c linux-2.6.35-rc4/drivers/usb/serial/qcserial.c
--- linux-2.6.35-rc3/drivers/usb/serial/qcserial.c	2010-07-05 05:34:22.817868050 +0000
+++ linux-2.6.35-rc4/drivers/usb/serial/qcserial.c	2010-07-05 05:34:28.181868053 +0000
@@ -139,6 +139,7 @@
 					"Could not set interface, error %d\n",
 					retval);
 				retval = -ENODEV;
+				kfree(data);
 			}
 			return retval;
 		}
@@ -155,6 +156,7 @@
 					"Could not set interface, error %d\n",
 					retval);
 				retval = -ENODEV;
+				kfree(data);
 			}
 			return retval;
 		}
@@ -163,6 +165,7 @@
 	default:
 		dev_err(&serial->dev->dev,
 			"unknown number of interfaces: %d\n", nintf);
+		kfree(data);
 		return -ENODEV;
 	}
 
diff -urN linux-2.6.35-rc3/drivers/video/geode/gxfb_core.c linux-2.6.35-rc4/drivers/video/geode/gxfb_core.c
--- linux-2.6.35-rc3/drivers/video/geode/gxfb_core.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/video/geode/gxfb_core.c	2010-07-05 05:34:28.195868031 +0000
@@ -40,7 +40,7 @@
 static int vt_switch;
 
 /* Modes relevant to the GX (taken from modedb.c) */
-static struct fb_videomode gx_modedb[] __initdata = {
+static struct fb_videomode gx_modedb[] __devinitdata = {
 	/* 640x480-60 VESA */
 	{ NULL, 60, 640, 480, 39682,  48, 16, 33, 10, 96, 2,
 	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
@@ -110,14 +110,15 @@
 #ifdef CONFIG_OLPC
 #include <asm/olpc.h>
 
-static struct fb_videomode gx_dcon_modedb[] __initdata = {
+static struct fb_videomode gx_dcon_modedb[] __devinitdata = {
 	/* The only mode the DCON has is 1200x900 */
 	{ NULL, 50, 1200, 900, 17460, 24, 8, 4, 5, 8, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 	  FB_VMODE_NONINTERLACED, 0 }
 };
 
-static void __init get_modedb(struct fb_videomode **modedb, unsigned int *size)
+static void __devinit get_modedb(struct fb_videomode **modedb,
+		unsigned int *size)
 {
 	if (olpc_has_dcon()) {
 		*modedb = (struct fb_videomode *) gx_dcon_modedb;
@@ -129,7 +130,8 @@
 }
 
 #else
-static void __init get_modedb(struct fb_videomode **modedb, unsigned int *size)
+static void __devinit get_modedb(struct fb_videomode **modedb,
+		unsigned int *size)
 {
 	*modedb = (struct fb_videomode *) gx_modedb;
 	*size = ARRAY_SIZE(gx_modedb);
@@ -226,7 +228,8 @@
 	return gx_blank_display(info, blank_mode);
 }
 
-static int __init gxfb_map_video_memory(struct fb_info *info, struct pci_dev *dev)
+static int __devinit gxfb_map_video_memory(struct fb_info *info,
+		struct pci_dev *dev)
 {
 	struct gxfb_par *par = info->par;
 	int ret;
@@ -290,7 +293,7 @@
 	.fb_imageblit	= cfb_imageblit,
 };
 
-static struct fb_info * __init gxfb_init_fbinfo(struct device *dev)
+static struct fb_info *__devinit gxfb_init_fbinfo(struct device *dev)
 {
 	struct gxfb_par *par;
 	struct fb_info *info;
@@ -371,7 +374,8 @@
 }
 #endif
 
-static int __init gxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int __devinit gxfb_probe(struct pci_dev *pdev,
+		const struct pci_device_id *id)
 {
 	struct gxfb_par *par;
 	struct fb_info *info;
@@ -451,7 +455,7 @@
 	return ret;
 }
 
-static void gxfb_remove(struct pci_dev *pdev)
+static void __devexit gxfb_remove(struct pci_dev *pdev)
 {
 	struct fb_info *info = pci_get_drvdata(pdev);
 	struct gxfb_par *par = info->par;
diff -urN linux-2.6.35-rc3/drivers/video/geode/lxfb_core.c linux-2.6.35-rc4/drivers/video/geode/lxfb_core.c
--- linux-2.6.35-rc3/drivers/video/geode/lxfb_core.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/video/geode/lxfb_core.c	2010-07-05 05:34:28.195868031 +0000
@@ -35,7 +35,7 @@
  * we try to make it something sane - 640x480-60 is sane
  */
 
-static struct fb_videomode geode_modedb[] __initdata = {
+static struct fb_videomode geode_modedb[] __devinitdata = {
 	/* 640x480-60 */
 	{ NULL, 60, 640, 480, 39682, 48, 8, 25, 2, 88, 2,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
@@ -219,14 +219,15 @@
 #ifdef CONFIG_OLPC
 #include <asm/olpc.h>
 
-static struct fb_videomode olpc_dcon_modedb[] __initdata = {
+static struct fb_videomode olpc_dcon_modedb[] __devinitdata = {
 	/* The only mode the DCON has is 1200x900 */
 	{ NULL, 50, 1200, 900, 17460, 24, 8, 4, 5, 8, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 	  FB_VMODE_NONINTERLACED, 0 }
 };
 
-static void __init get_modedb(struct fb_videomode **modedb, unsigned int *size)
+static void __devinit get_modedb(struct fb_videomode **modedb,
+		unsigned int *size)
 {
 	if (olpc_has_dcon()) {
 		*modedb = (struct fb_videomode *) olpc_dcon_modedb;
@@ -238,7 +239,8 @@
 }
 
 #else
-static void __init get_modedb(struct fb_videomode **modedb, unsigned int *size)
+static void __devinit get_modedb(struct fb_videomode **modedb,
+		unsigned int *size)
 {
 	*modedb = (struct fb_videomode *) geode_modedb;
 	*size = ARRAY_SIZE(geode_modedb);
@@ -334,7 +336,7 @@
 }
 
 
-static int __init lxfb_map_video_memory(struct fb_info *info,
+static int __devinit lxfb_map_video_memory(struct fb_info *info,
 					struct pci_dev *dev)
 {
 	struct lxfb_par *par = info->par;
@@ -412,7 +414,7 @@
 	.fb_imageblit	= cfb_imageblit,
 };
 
-static struct fb_info * __init lxfb_init_fbinfo(struct device *dev)
+static struct fb_info * __devinit lxfb_init_fbinfo(struct device *dev)
 {
 	struct lxfb_par *par;
 	struct fb_info *info;
@@ -496,7 +498,7 @@
 #define lxfb_resume NULL
 #endif
 
-static int __init lxfb_probe(struct pci_dev *pdev,
+static int __devinit lxfb_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *id)
 {
 	struct lxfb_par *par;
@@ -588,7 +590,7 @@
 	return ret;
 }
 
-static void lxfb_remove(struct pci_dev *pdev)
+static void __devexit lxfb_remove(struct pci_dev *pdev)
 {
 	struct fb_info *info = pci_get_drvdata(pdev);
 	struct lxfb_par *par = info->par;
diff -urN linux-2.6.35-rc3/drivers/video/nuc900fb.c linux-2.6.35-rc4/drivers/video/nuc900fb.c
--- linux-2.6.35-rc3/drivers/video/nuc900fb.c	2010-07-05 05:34:22.830867980 +0000
+++ linux-2.6.35-rc4/drivers/video/nuc900fb.c	2010-07-05 05:34:28.196868033 +0000
@@ -596,8 +596,6 @@
 		goto release_regs;
 	}
 
-	nuc900_driver_clksrc_div(&pdev->dev, "ext", 0x2);
-
 	fbi->clk = clk_get(&pdev->dev, NULL);
 	if (!fbi->clk || IS_ERR(fbi->clk)) {
 		printk(KERN_ERR "nuc900-lcd:failed to get lcd clock source\n");
diff -urN linux-2.6.35-rc3/drivers/video/omap/lcdc.c linux-2.6.35-rc4/drivers/video/omap/lcdc.c
--- linux-2.6.35-rc3/drivers/video/omap/lcdc.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/video/omap/lcdc.c	2010-07-05 05:34:28.197868092 +0000
@@ -572,22 +572,12 @@
 /* PM code called only in internal controller mode */
 static void omap_lcdc_suspend(void)
 {
-	if (lcdc.update_mode == OMAPFB_AUTO_UPDATE) {
-		disable_controller();
-		omap_stop_lcd_dma();
-	}
+	omap_lcdc_set_update_mode(OMAPFB_UPDATE_DISABLED);
 }
 
 static void omap_lcdc_resume(void)
 {
-	if (lcdc.update_mode == OMAPFB_AUTO_UPDATE) {
-		setup_regs();
-		load_palette();
-		setup_lcd_dma();
-		set_load_mode(OMAP_LCDC_LOAD_FRAME);
-		enable_irqs(OMAP_LCDC_IRQ_DONE);
-		enable_controller();
-	}
+	omap_lcdc_set_update_mode(OMAPFB_AUTO_UPDATE);
 }
 
 static void omap_lcdc_get_caps(int plane, struct omapfb_caps *caps)
diff -urN linux-2.6.35-rc3/drivers/video/omap/rfbi.c linux-2.6.35-rc4/drivers/video/omap/rfbi.c
--- linux-2.6.35-rc3/drivers/video/omap/rfbi.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/video/omap/rfbi.c	2010-07-05 05:34:28.197868092 +0000
@@ -26,6 +26,7 @@
 #include <linux/interrupt.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/platform_device.h>
 
 #include "omapfb.h"
 #include "dispc.h"
@@ -83,13 +84,13 @@
 
 static int rfbi_get_clocks(void)
 {
-	rfbi.dss_ick = clk_get(&dispc.fbdev->dssdev->dev, "ick");
+	rfbi.dss_ick = clk_get(&rfbi.fbdev->dssdev->dev, "ick");
 	if (IS_ERR(rfbi.dss_ick)) {
 		dev_err(rfbi.fbdev->dev, "can't get ick\n");
 		return PTR_ERR(rfbi.dss_ick);
 	}
 
-	rfbi.dss1_fck = clk_get(&dispc.fbdev->dssdev->dev, "dss1_fck");
+	rfbi.dss1_fck = clk_get(&rfbi.fbdev->dssdev->dev, "dss1_fck");
 	if (IS_ERR(rfbi.dss1_fck)) {
 		dev_err(rfbi.fbdev->dev, "can't get dss1_fck\n");
 		clk_put(rfbi.dss_ick);
diff -urN linux-2.6.35-rc3/drivers/virtio/virtio_pci.c linux-2.6.35-rc4/drivers/virtio/virtio_pci.c
--- linux-2.6.35-rc3/drivers/virtio/virtio_pci.c	2010-07-05 05:34:22.842868140 +0000
+++ linux-2.6.35-rc4/drivers/virtio/virtio_pci.c	2010-07-05 05:34:28.209868038 +0000
@@ -636,6 +636,9 @@
 	INIT_LIST_HEAD(&vp_dev->virtqueues);
 	spin_lock_init(&vp_dev->lock);
 
+	/* Disable MSI/MSIX to bring device to a known good state. */
+	pci_msi_off(pci_dev);
+
 	/* enable the device */
 	err = pci_enable_device(pci_dev);
 	if (err)
diff -urN linux-2.6.35-rc3/drivers/virtio/virtio_ring.c linux-2.6.35-rc4/drivers/virtio/virtio_ring.c
--- linux-2.6.35-rc3/drivers/virtio/virtio_ring.c	2010-07-05 05:34:22.842868140 +0000
+++ linux-2.6.35-rc4/drivers/virtio/virtio_ring.c	2010-07-05 05:34:28.209868038 +0000
@@ -119,7 +119,7 @@
 
 	desc = kmalloc((out + in) * sizeof(struct vring_desc), gfp);
 	if (!desc)
-		return vq->vring.num;
+		return -ENOMEM;
 
 	/* Transfer entries from the sg list into the indirect page */
 	for (i = 0; i < out; i++) {
diff -urN linux-2.6.35-rc3/drivers/watchdog/at32ap700x_wdt.c linux-2.6.35-rc4/drivers/watchdog/at32ap700x_wdt.c
--- linux-2.6.35-rc3/drivers/watchdog/at32ap700x_wdt.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/drivers/watchdog/at32ap700x_wdt.c	2010-07-05 05:34:28.210868067 +0000
@@ -346,9 +346,13 @@
 	} else {
 		wdt->users = 0;
 	}
-	wdt->miscdev.minor = WATCHDOG_MINOR;
-	wdt->miscdev.name = "watchdog";
-	wdt->miscdev.fops = &at32_wdt_fops;
+
+	wdt->miscdev.minor	= WATCHDOG_MINOR;
+	wdt->miscdev.name	= "watchdog";
+	wdt->miscdev.fops	= &at32_wdt_fops;
+	wdt->miscdev.parent	= &pdev->dev;
+
+	platform_set_drvdata(pdev, wdt);
 
 	if (at32_wdt_settimeout(timeout)) {
 		at32_wdt_settimeout(TIMEOUT_DEFAULT);
@@ -360,17 +364,17 @@
 	ret = misc_register(&wdt->miscdev);
 	if (ret) {
 		dev_dbg(&pdev->dev, "failed to register wdt miscdev\n");
-		goto err_iounmap;
+		goto err_register;
 	}
 
-	platform_set_drvdata(pdev, wdt);
-	wdt->miscdev.parent = &pdev->dev;
 	dev_info(&pdev->dev,
 		"AT32AP700X WDT at 0x%p, timeout %d sec (nowayout=%d)\n",
 		wdt->regs, wdt->timeout, nowayout);
 
 	return 0;
 
+err_register:
+	platform_set_drvdata(pdev, NULL);
 err_iounmap:
 	iounmap(wdt->regs);
 err_free:
diff -urN linux-2.6.35-rc3/drivers/watchdog/imx2_wdt.c linux-2.6.35-rc4/drivers/watchdog/imx2_wdt.c
--- linux-2.6.35-rc3/drivers/watchdog/imx2_wdt.c	2010-07-05 05:34:22.844868029 +0000
+++ linux-2.6.35-rc4/drivers/watchdog/imx2_wdt.c	2010-07-05 05:34:28.211868057 +0000
@@ -330,7 +330,6 @@
 }
 
 static struct platform_driver imx2_wdt_driver = {
-	.probe		= imx2_wdt_probe,
 	.remove		= __exit_p(imx2_wdt_remove),
 	.shutdown	= imx2_wdt_shutdown,
 	.driver		= {
diff -urN linux-2.6.35-rc3/fs/binfmt_flat.c linux-2.6.35-rc4/fs/binfmt_flat.c
--- linux-2.6.35-rc3/fs/binfmt_flat.c	2010-07-05 05:34:22.859805568 +0000
+++ linux-2.6.35-rc4/fs/binfmt_flat.c	2010-07-05 05:34:28.225868092 +0000
@@ -68,11 +68,7 @@
  * Here we can be a bit looser than the data sections since this
  * needs to only meet arch ABI requirements.
  */
-#ifdef ARCH_SLAB_MINALIGN
-#define FLAT_STACK_ALIGN	(ARCH_SLAB_MINALIGN)
-#else
-#define FLAT_STACK_ALIGN	(sizeof(void *))
-#endif
+#define FLAT_STACK_ALIGN	max_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)
 
 #define RELOC_FAILED 0xff00ff01		/* Relocation incorrect somewhere */
 #define UNLOADED_LIB 0x7ff000ff		/* Placeholder for unused library */
diff -urN linux-2.6.35-rc3/fs/cifs/cifsfs.c linux-2.6.35-rc4/fs/cifs/cifsfs.c
--- linux-2.6.35-rc3/fs/cifs/cifsfs.c	2010-07-05 05:34:22.883868168 +0000
+++ linux-2.6.35-rc4/fs/cifs/cifsfs.c	2010-07-05 05:34:28.249868089 +0000
@@ -473,14 +473,24 @@
 	return 0;
 }
 
+void cifs_drop_inode(struct inode *inode)
+{
+	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
+
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
+		return generic_drop_inode(inode);
+
+	return generic_delete_inode(inode);
+}
+
 static const struct super_operations cifs_super_ops = {
 	.put_super = cifs_put_super,
 	.statfs = cifs_statfs,
 	.alloc_inode = cifs_alloc_inode,
 	.destroy_inode = cifs_destroy_inode,
-/*	.drop_inode	    = generic_delete_inode,
-	.delete_inode	= cifs_delete_inode,  */  /* Do not need above two
-	functions unless later we add lazy close of inodes or unless the
+	.drop_inode	= cifs_drop_inode,
+/*	.delete_inode	= cifs_delete_inode,  */  /* Do not need above
+	function unless later we add lazy close of inodes or unless the
 	kernel forgets to call us with the same number of releases (closes)
 	as opens */
 	.show_options = cifs_show_options,
diff -urN linux-2.6.35-rc3/fs/cifs/cifsproto.h linux-2.6.35-rc4/fs/cifs/cifsproto.h
--- linux-2.6.35-rc3/fs/cifs/cifsproto.h	2010-07-05 05:34:22.883868168 +0000
+++ linux-2.6.35-rc4/fs/cifs/cifsproto.h	2010-07-05 05:34:28.249868089 +0000
@@ -106,7 +106,6 @@
 				__u16 fileHandle, struct file *file,
 				struct vfsmount *mnt, unsigned int oflags);
 extern int cifs_posix_open(char *full_path, struct inode **pinode,
-				struct vfsmount *mnt,
 				struct super_block *sb,
 				int mode, int oflags,
 				__u32 *poplock, __u16 *pnetfid, int xid);
diff -urN linux-2.6.35-rc3/fs/cifs/dir.c linux-2.6.35-rc4/fs/cifs/dir.c
--- linux-2.6.35-rc3/fs/cifs/dir.c	2010-07-05 05:34:22.887867989 +0000
+++ linux-2.6.35-rc4/fs/cifs/dir.c	2010-07-05 05:34:28.253868115 +0000
@@ -25,6 +25,7 @@
 #include <linux/slab.h>
 #include <linux/namei.h>
 #include <linux/mount.h>
+#include <linux/file.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #include "cifsglob.h"
@@ -184,12 +185,13 @@
 	}
 	write_unlock(&GlobalSMBSeslock);
 
+	file->private_data = pCifsFile;
+
 	return pCifsFile;
 }
 
 int cifs_posix_open(char *full_path, struct inode **pinode,
-			struct vfsmount *mnt, struct super_block *sb,
-			int mode, int oflags,
+			struct super_block *sb, int mode, int oflags,
 			__u32 *poplock, __u16 *pnetfid, int xid)
 {
 	int rc;
@@ -258,19 +260,6 @@
 		cifs_fattr_to_inode(*pinode, &fattr);
 	}
 
-	/*
-	 * cifs_fill_filedata() takes care of setting cifsFileInfo pointer to
-	 * file->private_data.
-	 */
-	if (mnt) {
-		struct cifsFileInfo *pfile_info;
-
-		pfile_info = cifs_new_fileinfo(*pinode, *pnetfid, NULL, mnt,
-					       oflags);
-		if (pfile_info == NULL)
-			rc = -ENOMEM;
-	}
-
 posix_open_ret:
 	kfree(presp_data);
 	return rc;
@@ -298,7 +287,6 @@
 	int create_options = CREATE_NOT_DIR;
 	__u32 oplock = 0;
 	int oflags;
-	bool posix_create = false;
 	/*
 	 * BB below access is probably too much for mknod to request
 	 *    but we have to do query and setpathinfo so requesting
@@ -339,7 +327,6 @@
 	    (CIFS_UNIX_POSIX_PATH_OPS_CAP &
 			le64_to_cpu(tcon->fsUnixInfo.Capability))) {
 		rc = cifs_posix_open(full_path, &newinode,
-			nd ? nd->path.mnt : NULL,
 			inode->i_sb, mode, oflags, &oplock, &fileHandle, xid);
 		/* EIO could indicate that (posix open) operation is not
 		   supported, despite what server claimed in capability
@@ -347,7 +334,6 @@
 		   handled in posix open */
 
 		if (rc == 0) {
-			posix_create = true;
 			if (newinode == NULL) /* query inode info */
 				goto cifs_create_get_file_info;
 			else /* success, no need to query */
@@ -478,21 +464,28 @@
 	else
 		cFYI(1, "Create worked, get_inode_info failed rc = %d", rc);
 
-	/* nfsd case - nfs srv does not set nd */
-	if ((nd == NULL) || (!(nd->flags & LOOKUP_OPEN))) {
-		/* mknod case - do not leave file open */
-		CIFSSMBClose(xid, tcon, fileHandle);
-	} else if (!(posix_create) && (newinode)) {
+	if (newinode && nd && (nd->flags & LOOKUP_OPEN)) {
 		struct cifsFileInfo *pfile_info;
-		/*
-		 * cifs_fill_filedata() takes care of setting cifsFileInfo
-		 * pointer to file->private_data.
-		 */
-		pfile_info = cifs_new_fileinfo(newinode, fileHandle, NULL,
+		struct file *filp;
+
+		filp = lookup_instantiate_filp(nd, direntry, generic_file_open);
+		if (IS_ERR(filp)) {
+			rc = PTR_ERR(filp);
+			CIFSSMBClose(xid, tcon, fileHandle);
+			goto cifs_create_out;
+		}
+
+		pfile_info = cifs_new_fileinfo(newinode, fileHandle, filp,
 					       nd->path.mnt, oflags);
-		if (pfile_info == NULL)
+		if (pfile_info == NULL) {
+			fput(filp);
+			CIFSSMBClose(xid, tcon, fileHandle);
 			rc = -ENOMEM;
+		}
+	} else {
+		CIFSSMBClose(xid, tcon, fileHandle);
 	}
+
 cifs_create_out:
 	kfree(buf);
 	kfree(full_path);
@@ -636,6 +629,7 @@
 	bool posix_open = false;
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *pTcon;
+	struct cifsFileInfo *cfile;
 	struct inode *newInode = NULL;
 	char *full_path = NULL;
 	struct file *filp;
@@ -703,7 +697,7 @@
 		if (nd && !(nd->flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY)) &&
 		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
 		     (nd->intent.open.flags & O_CREAT)) {
-			rc = cifs_posix_open(full_path, &newInode, nd->path.mnt,
+			rc = cifs_posix_open(full_path, &newInode,
 					parent_dir_inode->i_sb,
 					nd->intent.open.create_mode,
 					nd->intent.open.flags, &oplock,
@@ -733,8 +727,25 @@
 		else
 			direntry->d_op = &cifs_dentry_ops;
 		d_add(direntry, newInode);
-		if (posix_open)
-			filp = lookup_instantiate_filp(nd, direntry, NULL);
+		if (posix_open) {
+			filp = lookup_instantiate_filp(nd, direntry,
+						       generic_file_open);
+			if (IS_ERR(filp)) {
+				rc = PTR_ERR(filp);
+				CIFSSMBClose(xid, pTcon, fileHandle);
+				goto lookup_out;
+			}
+
+			cfile = cifs_new_fileinfo(newInode, fileHandle, filp,
+						  nd->path.mnt,
+						  nd->intent.open.flags);
+			if (cfile == NULL) {
+				fput(filp);
+				CIFSSMBClose(xid, pTcon, fileHandle);
+				rc = -ENOMEM;
+				goto lookup_out;
+			}
+		}
 		/* since paths are not looked up by component - the parent
 		   directories are presumed to be good here */
 		renew_parental_timestamps(direntry);
@@ -755,6 +766,7 @@
 		is a common return code */
 	}
 
+lookup_out:
 	kfree(full_path);
 	FreeXid(xid);
 	return ERR_PTR(rc);
diff -urN linux-2.6.35-rc3/fs/cifs/file.c linux-2.6.35-rc4/fs/cifs/file.c
--- linux-2.6.35-rc3/fs/cifs/file.c	2010-07-05 05:34:22.888868163 +0000
+++ linux-2.6.35-rc4/fs/cifs/file.c	2010-07-05 05:34:28.254868138 +0000
@@ -162,44 +162,12 @@
 	return 0;
 }
 
-static struct cifsFileInfo *
-cifs_fill_filedata(struct file *file)
-{
-	struct list_head *tmp;
-	struct cifsFileInfo *pCifsFile = NULL;
-	struct cifsInodeInfo *pCifsInode = NULL;
-
-	/* search inode for this file and fill in file->private_data */
-	pCifsInode = CIFS_I(file->f_path.dentry->d_inode);
-	read_lock(&GlobalSMBSeslock);
-	list_for_each(tmp, &pCifsInode->openFileList) {
-		pCifsFile = list_entry(tmp, struct cifsFileInfo, flist);
-		if ((pCifsFile->pfile == NULL) &&
-		    (pCifsFile->pid == current->tgid)) {
-			/* mode set in cifs_create */
-
-			/* needed for writepage */
-			pCifsFile->pfile = file;
-			file->private_data = pCifsFile;
-			break;
-		}
-	}
-	read_unlock(&GlobalSMBSeslock);
-
-	if (file->private_data != NULL) {
-		return pCifsFile;
-	} else if ((file->f_flags & O_CREAT) && (file->f_flags & O_EXCL))
-			cERROR(1, "could not find file instance for "
-				   "new file %p", file);
-	return NULL;
-}
-
 /* all arguments to this function must be checked for validity in caller */
-static inline int cifs_open_inode_helper(struct inode *inode, struct file *file,
-	struct cifsInodeInfo *pCifsInode, struct cifsFileInfo *pCifsFile,
+static inline int cifs_open_inode_helper(struct inode *inode,
 	struct cifsTconInfo *pTcon, int *oplock, FILE_ALL_INFO *buf,
 	char *full_path, int xid)
 {
+	struct cifsInodeInfo *pCifsInode = CIFS_I(inode);
 	struct timespec temp;
 	int rc;
 
@@ -213,36 +181,35 @@
 	/* if not oplocked, invalidate inode pages if mtime or file
 	   size changed */
 	temp = cifs_NTtimeToUnix(buf->LastWriteTime);
-	if (timespec_equal(&file->f_path.dentry->d_inode->i_mtime, &temp) &&
-			   (file->f_path.dentry->d_inode->i_size ==
+	if (timespec_equal(&inode->i_mtime, &temp) &&
+			   (inode->i_size ==
 			    (loff_t)le64_to_cpu(buf->EndOfFile))) {
 		cFYI(1, "inode unchanged on server");
 	} else {
-		if (file->f_path.dentry->d_inode->i_mapping) {
+		if (inode->i_mapping) {
 			/* BB no need to lock inode until after invalidate
 			since namei code should already have it locked? */
-			rc = filemap_write_and_wait(file->f_path.dentry->d_inode->i_mapping);
+			rc = filemap_write_and_wait(inode->i_mapping);
 			if (rc != 0)
-				CIFS_I(file->f_path.dentry->d_inode)->write_behind_rc = rc;
+				pCifsInode->write_behind_rc = rc;
 		}
 		cFYI(1, "invalidating remote inode since open detected it "
 			 "changed");
-		invalidate_remote_inode(file->f_path.dentry->d_inode);
+		invalidate_remote_inode(inode);
 	}
 
 client_can_cache:
 	if (pTcon->unix_ext)
-		rc = cifs_get_inode_info_unix(&file->f_path.dentry->d_inode,
-			full_path, inode->i_sb, xid);
+		rc = cifs_get_inode_info_unix(&inode, full_path, inode->i_sb,
+					      xid);
 	else
-		rc = cifs_get_inode_info(&file->f_path.dentry->d_inode,
-			full_path, buf, inode->i_sb, xid, NULL);
+		rc = cifs_get_inode_info(&inode, full_path, buf, inode->i_sb,
+					 xid, NULL);
 
 	if ((*oplock & 0xF) == OPLOCK_EXCLUSIVE) {
 		pCifsInode->clientCanCacheAll = true;
 		pCifsInode->clientCanCacheRead = true;
-		cFYI(1, "Exclusive Oplock granted on inode %p",
-			 file->f_path.dentry->d_inode);
+		cFYI(1, "Exclusive Oplock granted on inode %p", inode);
 	} else if ((*oplock & 0xF) == OPLOCK_READ)
 		pCifsInode->clientCanCacheRead = true;
 
@@ -256,7 +223,7 @@
 	__u32 oplock;
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *tcon;
-	struct cifsFileInfo *pCifsFile;
+	struct cifsFileInfo *pCifsFile = NULL;
 	struct cifsInodeInfo *pCifsInode;
 	char *full_path = NULL;
 	int desiredAccess;
@@ -270,12 +237,6 @@
 	tcon = cifs_sb->tcon;
 
 	pCifsInode = CIFS_I(file->f_path.dentry->d_inode);
-	pCifsFile = cifs_fill_filedata(file);
-	if (pCifsFile) {
-		rc = 0;
-		FreeXid(xid);
-		return rc;
-	}
 
 	full_path = build_path_from_dentry(file->f_path.dentry);
 	if (full_path == NULL) {
@@ -299,8 +260,7 @@
 		int oflags = (int) cifs_posix_convert_flags(file->f_flags);
 		oflags |= SMB_O_CREAT;
 		/* can not refresh inode info since size could be stale */
-		rc = cifs_posix_open(full_path, &inode, file->f_path.mnt,
-				inode->i_sb,
+		rc = cifs_posix_open(full_path, &inode, inode->i_sb,
 				cifs_sb->mnt_file_mode /* ignored */,
 				oflags, &oplock, &netfid, xid);
 		if (rc == 0) {
@@ -308,9 +268,20 @@
 			/* no need for special case handling of setting mode
 			   on read only files needed here */
 
-			pCifsFile = cifs_fill_filedata(file);
-			cifs_posix_open_inode_helper(inode, file, pCifsInode,
-						     oplock, netfid);
+			rc = cifs_posix_open_inode_helper(inode, file,
+					pCifsInode, oplock, netfid);
+			if (rc != 0) {
+				CIFSSMBClose(xid, tcon, netfid);
+				goto out;
+			}
+
+			pCifsFile = cifs_new_fileinfo(inode, netfid, file,
+							file->f_path.mnt,
+							oflags);
+			if (pCifsFile == NULL) {
+				CIFSSMBClose(xid, tcon, netfid);
+				rc = -ENOMEM;
+			}
 			goto out;
 		} else if ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {
 			if (tcon->ses->serverNOS)
@@ -391,17 +362,17 @@
 		goto out;
 	}
 
+	rc = cifs_open_inode_helper(inode, tcon, &oplock, buf, full_path, xid);
+	if (rc != 0)
+		goto out;
+
 	pCifsFile = cifs_new_fileinfo(inode, netfid, file, file->f_path.mnt,
 					file->f_flags);
-	file->private_data = pCifsFile;
-	if (file->private_data == NULL) {
+	if (pCifsFile == NULL) {
 		rc = -ENOMEM;
 		goto out;
 	}
 
-	rc = cifs_open_inode_helper(inode, file, pCifsInode, pCifsFile, tcon,
-				    &oplock, buf, full_path, xid);
-
 	if (oplock & CIFS_CREATE_ACTION) {
 		/* time to set mode which we can not set earlier due to
 		   problems creating new read-only files */
@@ -513,8 +484,7 @@
 			le64_to_cpu(tcon->fsUnixInfo.Capability))) {
 		int oflags = (int) cifs_posix_convert_flags(file->f_flags);
 		/* can not refresh inode info since size could be stale */
-		rc = cifs_posix_open(full_path, NULL, file->f_path.mnt,
-				inode->i_sb,
+		rc = cifs_posix_open(full_path, NULL, inode->i_sb,
 				cifs_sb->mnt_file_mode /* ignored */,
 				oflags, &oplock, &netfid, xid);
 		if (rc == 0) {
diff -urN linux-2.6.35-rc3/fs/cifs/inode.c linux-2.6.35-rc4/fs/cifs/inode.c
--- linux-2.6.35-rc3/fs/cifs/inode.c	2010-07-05 05:34:22.888868163 +0000
+++ linux-2.6.35-rc4/fs/cifs/inode.c	2010-07-05 05:34:28.254868138 +0000
@@ -1401,6 +1401,10 @@
 	if (rc == 0 || rc != -ETXTBSY)
 		return rc;
 
+	/* open-file renames don't work across directories */
+	if (to_dentry->d_parent != from_dentry->d_parent)
+		return rc;
+
 	/* open the file to be renamed -- we need DELETE perms */
 	rc = CIFSSMBOpen(xid, pTcon, fromPath, FILE_OPEN, DELETE,
 			 CREATE_NOT_DIR, &srcfid, &oplock, NULL,
diff -urN linux-2.6.35-rc3/fs/cifs/sess.c linux-2.6.35-rc4/fs/cifs/sess.c
--- linux-2.6.35-rc3/fs/cifs/sess.c	2010-07-05 05:34:22.890868258 +0000
+++ linux-2.6.35-rc4/fs/cifs/sess.c	2010-07-05 05:34:28.256868079 +0000
@@ -730,15 +730,7 @@
 
 		/* calculate session key */
 		setup_ntlmv2_rsp(ses, v2_sess_key, nls_cp);
-		if (first_time) /* should this be moved into common code
-				   with similar ntlmv2 path? */
-		/*   cifs_calculate_ntlmv2_mac_key(ses->server->mac_signing_key,
-				response BB FIXME, v2_sess_key); */
-
-		/* copy session key */
-
-	/*	memcpy(bcc_ptr, (char *)ntlm_session_key,LM2_SESS_KEY_SIZE);
-		bcc_ptr += LM2_SESS_KEY_SIZE; */
+		/* FIXME: calculate MAC key */
 		memcpy(bcc_ptr, (char *)v2_sess_key,
 		       sizeof(struct ntlmv2_resp));
 		bcc_ptr += sizeof(struct ntlmv2_resp);
diff -urN linux-2.6.35-rc3/fs/dcache.c linux-2.6.35-rc4/fs/dcache.c
--- linux-2.6.35-rc3/fs/dcache.c	2010-07-05 05:34:22.892868147 +0000
+++ linux-2.6.35-rc4/fs/dcache.c	2010-07-05 05:34:28.258868110 +0000
@@ -590,6 +590,8 @@
 			up_read(&sb->s_umount);
 		}
 		spin_lock(&sb_lock);
+		/* lock was dropped, must reset next */
+		list_safe_reset_next(sb, n, s_list);
 		count -= pruned;
 		__put_super(sb);
 		/* more work left to do? */
diff -urN linux-2.6.35-rc3/fs/ext2/acl.c linux-2.6.35-rc4/fs/ext2/acl.c
--- linux-2.6.35-rc3/fs/ext2/acl.c	2010-07-05 05:34:22.896868050 +0000
+++ linux-2.6.35-rc4/fs/ext2/acl.c	2010-07-05 05:34:28.262868070 +0000
@@ -200,6 +200,7 @@
 					return error;
 				else {
 					inode->i_mode = mode;
+					inode->i_ctime = CURRENT_TIME_SEC;
 					mark_inode_dirty(inode);
 					if (error == 0)
 						acl = NULL;
diff -urN linux-2.6.35-rc3/fs/ext3/acl.c linux-2.6.35-rc4/fs/ext3/acl.c
--- linux-2.6.35-rc3/fs/ext3/acl.c	2010-07-05 05:34:22.898805155 +0000
+++ linux-2.6.35-rc4/fs/ext3/acl.c	2010-07-05 05:34:28.264868060 +0000
@@ -205,6 +205,7 @@
 					return error;
 				else {
 					inode->i_mode = mode;
+					inode->i_ctime = CURRENT_TIME_SEC;
 					ext3_mark_inode_dirty(handle, inode);
 					if (error == 0)
 						acl = NULL;
diff -urN linux-2.6.35-rc3/fs/fcntl.c linux-2.6.35-rc4/fs/fcntl.c
--- linux-2.6.35-rc3/fs/fcntl.c	2010-07-05 05:34:22.910868097 +0000
+++ linux-2.6.35-rc4/fs/fcntl.c	2010-07-05 05:34:28.276868093 +0000
@@ -733,12 +733,14 @@
 {
 	while (fa) {
 		struct fown_struct *fown;
+		unsigned long flags;
+
 		if (fa->magic != FASYNC_MAGIC) {
 			printk(KERN_ERR "kill_fasync: bad magic number in "
 			       "fasync_struct!\n");
 			return;
 		}
-		spin_lock(&fa->fa_lock);
+		spin_lock_irqsave(&fa->fa_lock, flags);
 		if (fa->fa_file) {
 			fown = &fa->fa_file->f_owner;
 			/* Don't send SIGURG to processes which have not set a
@@ -747,7 +749,7 @@
 			if (!(sig == SIGURG && fown->signum == 0))
 				send_sigio(fown, fa->fa_fd, band);
 		}
-		spin_unlock(&fa->fa_lock);
+		spin_unlock_irqrestore(&fa->fa_lock, flags);
 		fa = rcu_dereference(fa->fa_next);
 	}
 }
diff -urN linux-2.6.35-rc3/fs/fs-writeback.c linux-2.6.35-rc4/fs/fs-writeback.c
--- linux-2.6.35-rc3/fs/fs-writeback.c	2010-07-05 05:34:22.910868097 +0000
+++ linux-2.6.35-rc4/fs/fs-writeback.c	2010-07-05 05:34:28.277868452 +0000
@@ -63,24 +63,16 @@
 };
 
 enum {
-	WS_USED_B = 0,
-	WS_ONSTACK_B,
+	WS_INPROGRESS = 0,
+	WS_ONSTACK,
 };
 
-#define WS_USED (1 << WS_USED_B)
-#define WS_ONSTACK (1 << WS_ONSTACK_B)
-
-static inline bool bdi_work_on_stack(struct bdi_work *work)
-{
-	return test_bit(WS_ONSTACK_B, &work->state);
-}
-
 static inline void bdi_work_init(struct bdi_work *work,
 				 struct wb_writeback_args *args)
 {
 	INIT_RCU_HEAD(&work->rcu_head);
 	work->args = *args;
-	work->state = WS_USED;
+	__set_bit(WS_INPROGRESS, &work->state);
 }
 
 /**
@@ -95,43 +87,16 @@
 	return !list_empty(&bdi->work_list);
 }
 
-static void bdi_work_clear(struct bdi_work *work)
-{
-	clear_bit(WS_USED_B, &work->state);
-	smp_mb__after_clear_bit();
-	/*
-	 * work can have disappeared at this point. bit waitq functions
-	 * should be able to tolerate this, provided bdi_sched_wait does
-	 * not dereference it's pointer argument.
-	*/
-	wake_up_bit(&work->state, WS_USED_B);
-}
-
 static void bdi_work_free(struct rcu_head *head)
 {
 	struct bdi_work *work = container_of(head, struct bdi_work, rcu_head);
 
-	if (!bdi_work_on_stack(work))
-		kfree(work);
-	else
-		bdi_work_clear(work);
-}
-
-static void wb_work_complete(struct bdi_work *work)
-{
-	const enum writeback_sync_modes sync_mode = work->args.sync_mode;
-	int onstack = bdi_work_on_stack(work);
+	clear_bit(WS_INPROGRESS, &work->state);
+	smp_mb__after_clear_bit();
+	wake_up_bit(&work->state, WS_INPROGRESS);
 
-	/*
-	 * For allocated work, we can clear the done/seen bit right here.
-	 * For on-stack work, we need to postpone both the clear and free
-	 * to after the RCU grace period, since the stack could be invalidated
-	 * as soon as bdi_work_clear() has done the wakeup.
-	 */
-	if (!onstack)
-		bdi_work_clear(work);
-	if (sync_mode == WB_SYNC_NONE || onstack)
-		call_rcu(&work->rcu_head, bdi_work_free);
+	if (!test_bit(WS_ONSTACK, &work->state))
+		kfree(work);
 }
 
 static void wb_clear_pending(struct bdi_writeback *wb, struct bdi_work *work)
@@ -147,7 +112,7 @@
 		list_del_rcu(&work->list);
 		spin_unlock(&bdi->wb_lock);
 
-		wb_work_complete(work);
+		call_rcu(&work->rcu_head, bdi_work_free);
 	}
 }
 
@@ -185,9 +150,9 @@
  * Used for on-stack allocated work items. The caller needs to wait until
  * the wb threads have acked the work before it's safe to continue.
  */
-static void bdi_wait_on_work_clear(struct bdi_work *work)
+static void bdi_wait_on_work_done(struct bdi_work *work)
 {
-	wait_on_bit(&work->state, WS_USED_B, bdi_sched_wait,
+	wait_on_bit(&work->state, WS_INPROGRESS, bdi_sched_wait,
 		    TASK_UNINTERRUPTIBLE);
 }
 
@@ -213,37 +178,28 @@
 }
 
 /**
- * bdi_sync_writeback - start and wait for writeback
- * @bdi: the backing device to write from
+ * bdi_queue_work_onstack - start and wait for writeback
  * @sb: write inodes from this super_block
  *
  * Description:
- *   This does WB_SYNC_ALL data integrity writeback and waits for the
- *   IO to complete. Callers must hold the sb s_umount semaphore for
+ *   This function initiates writeback and waits for the operation to
+ *   complete. Callers must hold the sb s_umount semaphore for
  *   reading, to avoid having the super disappear before we are done.
  */
-static void bdi_sync_writeback(struct backing_dev_info *bdi,
-			       struct super_block *sb)
+static void bdi_queue_work_onstack(struct wb_writeback_args *args)
 {
-	struct wb_writeback_args args = {
-		.sb		= sb,
-		.sync_mode	= WB_SYNC_ALL,
-		.nr_pages	= LONG_MAX,
-		.range_cyclic	= 0,
-	};
 	struct bdi_work work;
 
-	bdi_work_init(&work, &args);
-	work.state |= WS_ONSTACK;
+	bdi_work_init(&work, args);
+	__set_bit(WS_ONSTACK, &work.state);
 
-	bdi_queue_work(bdi, &work);
-	bdi_wait_on_work_clear(&work);
+	bdi_queue_work(args->sb->s_bdi, &work);
+	bdi_wait_on_work_done(&work);
 }
 
 /**
  * bdi_start_writeback - start writeback
  * @bdi: the backing device to write from
- * @sb: write inodes from this super_block
  * @nr_pages: the number of pages to write
  *
  * Description:
@@ -252,25 +208,34 @@
  *   completion. Caller need not hold sb s_umount semaphore.
  *
  */
-void bdi_start_writeback(struct backing_dev_info *bdi, struct super_block *sb,
-			 long nr_pages)
+void bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages)
 {
 	struct wb_writeback_args args = {
-		.sb		= sb,
 		.sync_mode	= WB_SYNC_NONE,
 		.nr_pages	= nr_pages,
 		.range_cyclic	= 1,
 	};
 
-	/*
-	 * We treat @nr_pages=0 as the special case to do background writeback,
-	 * ie. to sync pages until the background dirty threshold is reached.
-	 */
-	if (!nr_pages) {
-		args.nr_pages = LONG_MAX;
-		args.for_background = 1;
-	}
+	bdi_alloc_queue_work(bdi, &args);
+}
 
+/**
+ * bdi_start_background_writeback - start background writeback
+ * @bdi: the backing device to write from
+ *
+ * Description:
+ *   This does WB_SYNC_NONE background writeback. The IO is only
+ *   started when this function returns, we make no guarentees on
+ *   completion. Caller need not hold sb s_umount semaphore.
+ */
+void bdi_start_background_writeback(struct backing_dev_info *bdi)
+{
+	struct wb_writeback_args args = {
+		.sync_mode	= WB_SYNC_NONE,
+		.nr_pages	= LONG_MAX,
+		.for_background = 1,
+		.range_cyclic	= 1,
+	};
 	bdi_alloc_queue_work(bdi, &args);
 }
 
@@ -561,48 +526,30 @@
 	return ret;
 }
 
-static void unpin_sb_for_writeback(struct super_block *sb)
-{
-	up_read(&sb->s_umount);
-	put_super(sb);
-}
-
-enum sb_pin_state {
-	SB_PINNED,
-	SB_NOT_PINNED,
-	SB_PIN_FAILED
-};
-
 /*
- * For WB_SYNC_NONE writeback, the caller does not have the sb pinned
+ * For background writeback the caller does not have the sb pinned
  * before calling writeback. So make sure that we do pin it, so it doesn't
  * go away while we are writing inodes from it.
  */
-static enum sb_pin_state pin_sb_for_writeback(struct writeback_control *wbc,
-					      struct super_block *sb)
+static bool pin_sb_for_writeback(struct super_block *sb)
 {
-	/*
-	 * Caller must already hold the ref for this
-	 */
-	if (wbc->sync_mode == WB_SYNC_ALL) {
-		WARN_ON(!rwsem_is_locked(&sb->s_umount));
-		return SB_NOT_PINNED;
-	}
 	spin_lock(&sb_lock);
+	if (list_empty(&sb->s_instances)) {
+		spin_unlock(&sb_lock);
+		return false;
+	}
+
 	sb->s_count++;
+	spin_unlock(&sb_lock);
+
 	if (down_read_trylock(&sb->s_umount)) {
-		if (sb->s_root) {
-			spin_unlock(&sb_lock);
-			return SB_PINNED;
-		}
-		/*
-		 * umounted, drop rwsem again and fall through to failure
-		 */
+		if (sb->s_root)
+			return true;
 		up_read(&sb->s_umount);
 	}
-	sb->s_count--;
-	spin_unlock(&sb_lock);
-	return SB_PIN_FAILED;
+
+	put_super(sb);
+	return false;
 }
 
 /*
@@ -681,24 +628,31 @@
 		struct inode *inode = list_entry(wb->b_io.prev,
 						 struct inode, i_list);
 		struct super_block *sb = inode->i_sb;
-		enum sb_pin_state state;
 
-		if (wbc->sb && sb != wbc->sb) {
-			/* super block given and doesn't
-			   match, skip this inode */
-			redirty_tail(inode);
-			continue;
-		}
-		state = pin_sb_for_writeback(wbc, sb);
+		if (wbc->sb) {
+			/*
+			 * We are requested to write out inodes for a specific
+			 * superblock.  This means we already have s_umount
+			 * taken by the caller which also waits for us to
+			 * complete the writeout.
+			 */
+			if (sb != wbc->sb) {
+				redirty_tail(inode);
+				continue;
+			}
 
-		if (state == SB_PIN_FAILED) {
-			requeue_io(inode);
-			continue;
+			WARN_ON(!rwsem_is_locked(&sb->s_umount));
+
+			ret = writeback_sb_inodes(sb, wb, wbc);
+		} else {
+			if (!pin_sb_for_writeback(sb)) {
+				requeue_io(inode);
+				continue;
+			}
+			ret = writeback_sb_inodes(sb, wb, wbc);
+			drop_super(sb);
 		}
-		ret = writeback_sb_inodes(sb, wb, wbc);
 
-		if (state == SB_PINNED)
-			unpin_sb_for_writeback(sb);
 		if (ret)
 			break;
 	}
@@ -911,7 +865,7 @@
 		 * If this isn't a data integrity operation, just notify
 		 * that we have seen this work and we are now starting it.
 		 */
-		if (args.sync_mode == WB_SYNC_NONE)
+		if (!test_bit(WS_ONSTACK, &work->state))
 			wb_clear_pending(wb, work);
 
 		wrote += wb_writeback(wb, &args);
@@ -920,7 +874,7 @@
 		 * This is a data integrity writeback, so only do the
 		 * notification when we have completed the work.
 		 */
-		if (args.sync_mode == WB_SYNC_ALL)
+		if (test_bit(WS_ONSTACK, &work->state))
 			wb_clear_pending(wb, work);
 	}
 
@@ -978,42 +932,32 @@
 }
 
 /*
- * Schedule writeback for all backing devices. This does WB_SYNC_NONE
- * writeback, for integrity writeback see bdi_sync_writeback().
+ * Start writeback of `nr_pages' pages.  If `nr_pages' is zero, write back
+ * the whole world.
  */
-static void bdi_writeback_all(struct super_block *sb, long nr_pages)
+void wakeup_flusher_threads(long nr_pages)
 {
+	struct backing_dev_info *bdi;
 	struct wb_writeback_args args = {
-		.sb		= sb,
-		.nr_pages	= nr_pages,
 		.sync_mode	= WB_SYNC_NONE,
 	};
-	struct backing_dev_info *bdi;
 
-	rcu_read_lock();
+	if (nr_pages) {
+		args.nr_pages = nr_pages;
+	} else {
+		args.nr_pages = global_page_state(NR_FILE_DIRTY) +
+				global_page_state(NR_UNSTABLE_NFS);
+	}
 
+	rcu_read_lock();
 	list_for_each_entry_rcu(bdi, &bdi_list, bdi_list) {
 		if (!bdi_has_dirty_io(bdi))
 			continue;
-
 		bdi_alloc_queue_work(bdi, &args);
 	}
-
 	rcu_read_unlock();
 }
 
-/*
- * Start writeback of `nr_pages' pages.  If `nr_pages' is zero, write back
- * the whole world.
- */
-void wakeup_flusher_threads(long nr_pages)
-{
-	if (nr_pages == 0)
-		nr_pages = global_page_state(NR_FILE_DIRTY) +
-				global_page_state(NR_UNSTABLE_NFS);
-	bdi_writeback_all(NULL, nr_pages);
-}
-
 static noinline void block_dump___mark_inode_dirty(struct inode *inode)
 {
 	if (inode->i_ino || strcmp(inode->i_sb->s_id, "bdev")) {
@@ -1218,12 +1162,17 @@
 {
 	unsigned long nr_dirty = global_page_state(NR_FILE_DIRTY);
 	unsigned long nr_unstable = global_page_state(NR_UNSTABLE_NFS);
-	long nr_to_write;
+	struct wb_writeback_args args = {
+		.sb		= sb,
+		.sync_mode	= WB_SYNC_NONE,
+	};
+
+	WARN_ON(!rwsem_is_locked(&sb->s_umount));
 
-	nr_to_write = nr_dirty + nr_unstable +
+	args.nr_pages = nr_dirty + nr_unstable +
 			(inodes_stat.nr_inodes - inodes_stat.nr_unused);
 
-	bdi_start_writeback(sb->s_bdi, sb, nr_to_write);
+	bdi_queue_work_onstack(&args);
 }
 EXPORT_SYMBOL(writeback_inodes_sb);
 
@@ -1237,7 +1186,9 @@
 int writeback_inodes_sb_if_idle(struct super_block *sb)
 {
 	if (!writeback_in_progress(sb->s_bdi)) {
+		down_read(&sb->s_umount);
 		writeback_inodes_sb(sb);
+		up_read(&sb->s_umount);
 		return 1;
 	} else
 		return 0;
@@ -1253,7 +1204,16 @@
  */
 void sync_inodes_sb(struct super_block *sb)
 {
-	bdi_sync_writeback(sb->s_bdi, sb);
+	struct wb_writeback_args args = {
+		.sb		= sb,
+		.sync_mode	= WB_SYNC_ALL,
+		.nr_pages	= LONG_MAX,
+		.range_cyclic	= 0,
+	};
+
+	WARN_ON(!rwsem_is_locked(&sb->s_umount));
+
+	bdi_queue_work_onstack(&args);
 	wait_sb_inodes(sb);
 }
 EXPORT_SYMBOL(sync_inodes_sb);
diff -urN linux-2.6.35-rc3/fs/nfs/client.c linux-2.6.35-rc4/fs/nfs/client.c
--- linux-2.6.35-rc3/fs/nfs/client.c	2010-07-05 05:34:22.928868074 +0000
+++ linux-2.6.35-rc4/fs/nfs/client.c	2010-07-05 05:34:28.295805417 +0000
@@ -1286,6 +1286,55 @@
 #endif /* CONFIG_NFS_V4_1 */
 }
 
+static int nfs4_server_common_setup(struct nfs_server *server,
+		struct nfs_fh *mntfh)
+{
+	struct nfs_fattr *fattr;
+	int error;
+
+	BUG_ON(!server->nfs_client);
+	BUG_ON(!server->nfs_client->rpc_ops);
+	BUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);
+
+	fattr = nfs_alloc_fattr();
+	if (fattr == NULL)
+		return -ENOMEM;
+
+	/* We must ensure the session is initialised first */
+	error = nfs4_init_session(server);
+	if (error < 0)
+		goto out;
+
+	/* Probe the root fh to retrieve its FSID and filehandle */
+	error = nfs4_get_rootfh(server, mntfh);
+	if (error < 0)
+		goto out;
+
+	dprintk("Server FSID: %llx:%llx\n",
+			(unsigned long long) server->fsid.major,
+			(unsigned long long) server->fsid.minor);
+	dprintk("Mount FH: %d\n", mntfh->size);
+
+	nfs4_session_set_rwsize(server);
+
+	error = nfs_probe_fsinfo(server, mntfh, fattr);
+	if (error < 0)
+		goto out;
+
+	if (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)
+		server->namelen = NFS4_MAXNAMLEN;
+
+	spin_lock(&nfs_client_lock);
+	list_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);
+	list_add_tail(&server->master_link, &nfs_volume_list);
+	spin_unlock(&nfs_client_lock);
+
+	server->mount_time = jiffies;
+out:
+	nfs_free_fattr(fattr);
+	return error;
+}
+
 /*
  * Create a version 4 volume record
  */
@@ -1346,7 +1395,6 @@
 struct nfs_server *nfs4_create_server(const struct nfs_parsed_mount_data *data,
 				      struct nfs_fh *mntfh)
 {
-	struct nfs_fattr *fattr;
 	struct nfs_server *server;
 	int error;
 
@@ -1356,55 +1404,19 @@
 	if (!server)
 		return ERR_PTR(-ENOMEM);
 
-	error = -ENOMEM;
-	fattr = nfs_alloc_fattr();
-	if (fattr == NULL)
-		goto error;
-
 	/* set up the general RPC client */
 	error = nfs4_init_server(server, data);
 	if (error < 0)
 		goto error;
 
-	BUG_ON(!server->nfs_client);
-	BUG_ON(!server->nfs_client->rpc_ops);
-	BUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);
-
-	error = nfs4_init_session(server);
-	if (error < 0)
-		goto error;
-
-	/* Probe the root fh to retrieve its FSID */
-	error = nfs4_get_rootfh(server, mntfh);
-	if (error < 0)
-		goto error;
-
-	dprintk("Server FSID: %llx:%llx\n",
-		(unsigned long long) server->fsid.major,
-		(unsigned long long) server->fsid.minor);
-	dprintk("Mount FH: %d\n", mntfh->size);
-
-	nfs4_session_set_rwsize(server);
-
-	error = nfs_probe_fsinfo(server, mntfh, fattr);
+	error = nfs4_server_common_setup(server, mntfh);
 	if (error < 0)
 		goto error;
 
-	if (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)
-		server->namelen = NFS4_MAXNAMLEN;
-
-	spin_lock(&nfs_client_lock);
-	list_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);
-	list_add_tail(&server->master_link, &nfs_volume_list);
-	spin_unlock(&nfs_client_lock);
-
-	server->mount_time = jiffies;
 	dprintk("<-- nfs4_create_server() = %p\n", server);
-	nfs_free_fattr(fattr);
 	return server;
 
 error:
-	nfs_free_fattr(fattr);
 	nfs_free_server(server);
 	dprintk("<-- nfs4_create_server() = error %d\n", error);
 	return ERR_PTR(error);
@@ -1418,7 +1430,6 @@
 {
 	struct nfs_client *parent_client;
 	struct nfs_server *server, *parent_server;
-	struct nfs_fattr *fattr;
 	int error;
 
 	dprintk("--> nfs4_create_referral_server()\n");
@@ -1427,11 +1438,6 @@
 	if (!server)
 		return ERR_PTR(-ENOMEM);
 
-	error = -ENOMEM;
-	fattr = nfs_alloc_fattr();
-	if (fattr == NULL)
-		goto error;
-
 	parent_server = NFS_SB(data->sb);
 	parent_client = parent_server->nfs_client;
 
@@ -1456,40 +1462,14 @@
 	if (error < 0)
 		goto error;
 
-	BUG_ON(!server->nfs_client);
-	BUG_ON(!server->nfs_client->rpc_ops);
-	BUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);
-
-	/* Probe the root fh to retrieve its FSID and filehandle */
-	error = nfs4_get_rootfh(server, mntfh);
-	if (error < 0)
-		goto error;
-
-	/* probe the filesystem info for this server filesystem */
-	error = nfs_probe_fsinfo(server, mntfh, fattr);
+	error = nfs4_server_common_setup(server, mntfh);
 	if (error < 0)
 		goto error;
 
-	if (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)
-		server->namelen = NFS4_MAXNAMLEN;
-
-	dprintk("Referral FSID: %llx:%llx\n",
-		(unsigned long long) server->fsid.major,
-		(unsigned long long) server->fsid.minor);
-
-	spin_lock(&nfs_client_lock);
-	list_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);
-	list_add_tail(&server->master_link, &nfs_volume_list);
-	spin_unlock(&nfs_client_lock);
-
-	server->mount_time = jiffies;
-
-	nfs_free_fattr(fattr);
 	dprintk("<-- nfs_create_referral_server() = %p\n", server);
 	return server;
 
 error:
-	nfs_free_fattr(fattr);
 	nfs_free_server(server);
 	dprintk("<-- nfs4_create_referral_server() = error %d\n", error);
 	return ERR_PTR(error);
diff -urN linux-2.6.35-rc3/fs/nfs/getroot.c linux-2.6.35-rc4/fs/nfs/getroot.c
--- linux-2.6.35-rc3/fs/nfs/getroot.c	2010-07-05 05:34:22.930868272 +0000
+++ linux-2.6.35-rc4/fs/nfs/getroot.c	2010-07-05 05:34:28.296805518 +0000
@@ -146,7 +146,7 @@
 		goto out;
 	}
 
-	if (!(fsinfo.fattr->valid & NFS_ATTR_FATTR_MODE)
+	if (!(fsinfo.fattr->valid & NFS_ATTR_FATTR_TYPE)
 			|| !S_ISDIR(fsinfo.fattr->mode)) {
 		printk(KERN_ERR "nfs4_get_rootfh:"
 		       " getroot encountered non-directory\n");
diff -urN linux-2.6.35-rc3/fs/nfs/nfs4xdr.c linux-2.6.35-rc4/fs/nfs/nfs4xdr.c
--- linux-2.6.35-rc3/fs/nfs/nfs4xdr.c	2010-07-05 05:34:22.933805287 +0000
+++ linux-2.6.35-rc4/fs/nfs/nfs4xdr.c	2010-07-05 05:34:28.300868111 +0000
@@ -862,8 +862,8 @@
 		bmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;
 		*p++ = cpu_to_be32(NFS4_SET_TO_CLIENT_TIME);
 		*p++ = cpu_to_be32(0);
-		*p++ = cpu_to_be32(iap->ia_mtime.tv_sec);
-		*p++ = cpu_to_be32(iap->ia_mtime.tv_nsec);
+		*p++ = cpu_to_be32(iap->ia_atime.tv_sec);
+		*p++ = cpu_to_be32(iap->ia_atime.tv_nsec);
 	}
 	else if (iap->ia_valid & ATTR_ATIME) {
 		bmval1 |= FATTR4_WORD1_TIME_ACCESS_SET;
diff -urN linux-2.6.35-rc3/fs/nfs/super.c linux-2.6.35-rc4/fs/nfs/super.c
--- linux-2.6.35-rc3/fs/nfs/super.c	2010-07-05 05:34:22.935807273 +0000
+++ linux-2.6.35-rc4/fs/nfs/super.c	2010-07-05 05:34:28.301868116 +0000
@@ -570,6 +570,22 @@
 	nfs_show_mountd_netid(m, nfss, showdefaults);
 }
 
+#ifdef CONFIG_NFS_V4
+static void nfs_show_nfsv4_options(struct seq_file *m, struct nfs_server *nfss,
+				    int showdefaults)
+{
+	struct nfs_client *clp = nfss->nfs_client;
+
+	seq_printf(m, ",clientaddr=%s", clp->cl_ipaddr);
+	seq_printf(m, ",minorversion=%u", clp->cl_minorversion);
+}
+#else
+static void nfs_show_nfsv4_options(struct seq_file *m, struct nfs_server *nfss,
+				    int showdefaults)
+{
+}
+#endif
+
 /*
  * Describe the mount options in force on this server representation
  */
@@ -631,11 +647,9 @@
 
 	if (version != 4)
 		nfs_show_mountd_options(m, nfss, showdefaults);
+	else
+		nfs_show_nfsv4_options(m, nfss, showdefaults);
 
-#ifdef CONFIG_NFS_V4
-	if (clp->rpc_ops->version == 4)
-		seq_printf(m, ",clientaddr=%s", clp->cl_ipaddr);
-#endif
 	if (nfss->options & NFS_OPTION_FSCACHE)
 		seq_printf(m, ",fsc");
 }
diff -urN linux-2.6.35-rc3/fs/ocfs2/reservations.c linux-2.6.35-rc4/fs/ocfs2/reservations.c
--- linux-2.6.35-rc3/fs/ocfs2/reservations.c	2010-07-05 05:34:22.954868218 +0000
+++ linux-2.6.35-rc4/fs/ocfs2/reservations.c	2010-07-05 05:34:28.321868093 +0000
@@ -26,7 +26,6 @@
 
 #include <linux/fs.h>
 #include <linux/types.h>
-#include <linux/slab.h>
 #include <linux/highmem.h>
 #include <linux/bitops.h>
 #include <linux/list.h>
diff -urN linux-2.6.35-rc3/fs/proc/proc_devtree.c linux-2.6.35-rc4/fs/proc/proc_devtree.c
--- linux-2.6.35-rc3/fs/proc/proc_devtree.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/proc/proc_devtree.c	2010-07-05 05:34:28.330868075 +0000
@@ -209,6 +209,9 @@
 	for (pp = np->properties; pp != NULL; pp = pp->next) {
 		p = pp->name;
 
+		if (strchr(p, '/'))
+			continue;
+
 		if (duplicate_name(de, p))
 			p = fixup_name(np, de, p);
 
diff -urN linux-2.6.35-rc3/fs/proc/task_nommu.c linux-2.6.35-rc4/fs/proc/task_nommu.c
--- linux-2.6.35-rc3/fs/proc/task_nommu.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/proc/task_nommu.c	2010-07-05 05:34:28.330868075 +0000
@@ -122,11 +122,20 @@
 	return size;
 }
 
+static void pad_len_spaces(struct seq_file *m, int len)
+{
+	len = 25 + sizeof(void*) * 6 - len;
+	if (len < 1)
+		len = 1;
+	seq_printf(m, "%*c", len, ' ');
+}
+
 /*
  * display a single VMA to a sequenced file
  */
 static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma)
 {
+	struct mm_struct *mm = vma->vm_mm;
 	unsigned long ino = 0;
 	struct file *file;
 	dev_t dev = 0;
@@ -155,11 +164,14 @@
 		   MAJOR(dev), MINOR(dev), ino, &len);
 
 	if (file) {
-		len = 25 + sizeof(void *) * 6 - len;
-		if (len < 1)
-			len = 1;
-		seq_printf(m, "%*c", len, ' ');
+		pad_len_spaces(m, len);
 		seq_path(m, &file->f_path, "");
+	} else if (mm) {
+		if (vma->vm_start <= mm->start_stack &&
+			vma->vm_end >= mm->start_stack) {
+			pad_len_spaces(m, len);
+			seq_puts(m, "[stack]");
+		}
 	}
 
 	seq_putc(m, '\n');
diff -urN linux-2.6.35-rc3/fs/super.c linux-2.6.35-rc4/fs/super.c
--- linux-2.6.35-rc3/fs/super.c	2010-07-05 05:34:22.971868171 +0000
+++ linux-2.6.35-rc4/fs/super.c	2010-07-05 05:34:28.338868079 +0000
@@ -374,6 +374,8 @@
 			up_read(&sb->s_umount);
 
 			spin_lock(&sb_lock);
+			/* lock was dropped, must reset next */
+			list_safe_reset_next(sb, n, s_list);
 			__put_super(sb);
 		}
 	}
@@ -405,6 +407,8 @@
 		up_read(&sb->s_umount);
 
 		spin_lock(&sb_lock);
+		/* lock was dropped, must reset next */
+		list_safe_reset_next(sb, n, s_list);
 		__put_super(sb);
 	}
 	spin_unlock(&sb_lock);
@@ -585,6 +589,8 @@
 		}
 		up_write(&sb->s_umount);
 		spin_lock(&sb_lock);
+		/* lock was dropped, must reset next */
+		list_safe_reset_next(sb, n, s_list);
 		__put_super(sb);
 	}
 	spin_unlock(&sb_lock);
diff -urN linux-2.6.35-rc3/fs/sysv/ialloc.c linux-2.6.35-rc4/fs/sysv/ialloc.c
--- linux-2.6.35-rc3/fs/sysv/ialloc.c	2010-07-05 05:34:22.973868159 +0000
+++ linux-2.6.35-rc4/fs/sysv/ialloc.c	2010-07-05 05:34:28.340868166 +0000
@@ -25,6 +25,7 @@
 #include <linux/stat.h>
 #include <linux/string.h>
 #include <linux/buffer_head.h>
+#include <linux/writeback.h>
 #include "sysv.h"
 
 /* We don't trust the value of
@@ -139,6 +140,9 @@
 	struct inode *inode;
 	sysv_ino_t ino;
 	unsigned count;
+	struct writeback_control wbc = {
+		.sync_mode = WB_SYNC_NONE
+	};
 
 	inode = new_inode(sb);
 	if (!inode)
@@ -168,7 +172,7 @@
 	insert_inode_hash(inode);
 	mark_inode_dirty(inode);
 
-	sysv_write_inode(inode, 0);	/* ensure inode not allocated again */
+	sysv_write_inode(inode, &wbc);	/* ensure inode not allocated again */
 	mark_inode_dirty(inode);	/* cleared by sysv_write_inode() */
 	/* That's it. */
 	unlock_super(sb);
diff -urN linux-2.6.35-rc3/fs/ubifs/budget.c linux-2.6.35-rc4/fs/ubifs/budget.c
--- linux-2.6.35-rc3/fs/ubifs/budget.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/ubifs/budget.c	2010-07-05 05:34:28.340868166 +0000
@@ -62,7 +62,9 @@
  */
 static void shrink_liability(struct ubifs_info *c, int nr_to_write)
 {
+	down_read(&c->vfs_sb->s_umount);
 	writeback_inodes_sb(c->vfs_sb);
+	up_read(&c->vfs_sb->s_umount);
 }
 
 /**
diff -urN linux-2.6.35-rc3/fs/xfs/linux-2.6/xfs_export.c linux-2.6.35-rc4/fs/xfs/linux-2.6/xfs_export.c
--- linux-2.6.35-rc3/fs/xfs/linux-2.6/xfs_export.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/xfs/linux-2.6/xfs_export.c	2010-07-05 05:34:28.346868066 +0000
@@ -128,13 +128,12 @@
 		return ERR_PTR(-ESTALE);
 
 	/*
-	 * The XFS_IGET_BULKSTAT means that an invalid inode number is just
-	 * fine and not an indication of a corrupted filesystem.  Because
-	 * clients can send any kind of invalid file handle, e.g. after
-	 * a restore on the server we have to deal with this case gracefully.
+	 * The XFS_IGET_UNTRUSTED means that an invalid inode number is just
+	 * fine and not an indication of a corrupted filesystem as clients can
+	 * send invalid file handles and we have to handle it gracefully..
 	 */
-	error = xfs_iget(mp, NULL, ino, XFS_IGET_BULKSTAT,
-			 XFS_ILOCK_SHARED, &ip, 0);
+	error = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED,
+			 XFS_ILOCK_SHARED, &ip);
 	if (error) {
 		/*
 		 * EINVAL means the inode cluster doesn't exist anymore.
diff -urN linux-2.6.35-rc3/fs/xfs/linux-2.6/xfs_ioctl.c linux-2.6.35-rc4/fs/xfs/linux-2.6/xfs_ioctl.c
--- linux-2.6.35-rc3/fs/xfs/linux-2.6/xfs_ioctl.c	2010-07-05 05:34:22.979868088 +0000
+++ linux-2.6.35-rc4/fs/xfs/linux-2.6/xfs_ioctl.c	2010-07-05 05:34:28.347868187 +0000
@@ -679,10 +679,9 @@
 		error = xfs_bulkstat_single(mp, &inlast,
 						bulkreq.ubuffer, &done);
 	else	/* XFS_IOC_FSBULKSTAT */
-		error = xfs_bulkstat(mp, &inlast, &count,
-			(bulkstat_one_pf)xfs_bulkstat_one, NULL,
-			sizeof(xfs_bstat_t), bulkreq.ubuffer,
-			BULKSTAT_FG_QUICK, &done);
+		error = xfs_bulkstat(mp, &inlast, &count, xfs_bulkstat_one,
+				     sizeof(xfs_bstat_t), bulkreq.ubuffer,
+				     &done);
 
 	if (error)
 		return -error;
diff -urN linux-2.6.35-rc3/fs/xfs/linux-2.6/xfs_ioctl32.c linux-2.6.35-rc4/fs/xfs/linux-2.6/xfs_ioctl32.c
--- linux-2.6.35-rc3/fs/xfs/linux-2.6/xfs_ioctl32.c	2010-07-05 05:34:22.979868088 +0000
+++ linux-2.6.35-rc4/fs/xfs/linux-2.6/xfs_ioctl32.c	2010-07-05 05:34:28.347868187 +0000
@@ -237,15 +237,12 @@
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* buffer to place output in */
 	int		ubsize,		/* size of buffer */
-	void		*private_data,	/* my private data */
-	xfs_daddr_t	bno,		/* starting bno of inode cluster */
 	int		*ubused,	/* bytes used by me */
-	void		*dibuff,	/* on-disk inode buffer */
 	int		*stat)		/* BULKSTAT_RV_... */
 {
 	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
-				    xfs_bulkstat_one_fmt_compat, bno,
-				    ubused, dibuff, stat);
+				    xfs_bulkstat_one_fmt_compat,
+				    ubused, stat);
 }
 
 /* copied from xfs_ioctl.c */
@@ -298,13 +295,11 @@
 		int res;
 
 		error = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,
-				sizeof(compat_xfs_bstat_t),
-				NULL, 0, NULL, NULL, &res);
+				sizeof(compat_xfs_bstat_t), 0, &res);
 	} else if (cmd == XFS_IOC_FSBULKSTAT_32) {
 		error = xfs_bulkstat(mp, &inlast, &count,
-			xfs_bulkstat_one_compat, NULL,
-			sizeof(compat_xfs_bstat_t), bulkreq.ubuffer,
-			BULKSTAT_FG_QUICK, &done);
+			xfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),
+			bulkreq.ubuffer, &done);
 	} else
 		error = XFS_ERROR(EINVAL);
 	if (error)
diff -urN linux-2.6.35-rc3/fs/xfs/quota/xfs_qm.c linux-2.6.35-rc4/fs/xfs/quota/xfs_qm.c
--- linux-2.6.35-rc3/fs/xfs/quota/xfs_qm.c	2010-07-05 05:34:22.983805283 +0000
+++ linux-2.6.35-rc4/fs/xfs/quota/xfs_qm.c	2010-07-05 05:34:28.351868072 +0000
@@ -1632,10 +1632,7 @@
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* not used */
 	int		ubsize,		/* not used */
-	void		*private_data,	/* not used */
-	xfs_daddr_t	bno,		/* starting block of inode cluster */
 	int		*ubused,	/* not used */
-	void		*dip,		/* on-disk inode pointer (not used) */
 	int		*res)		/* result code value */
 {
 	xfs_inode_t	*ip;
@@ -1660,7 +1657,7 @@
 	 * the case in all other instances. It's OK that we do this because
 	 * quotacheck is done only at mount time.
 	 */
-	if ((error = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_EXCL, &ip, bno))) {
+	if ((error = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_EXCL, &ip))) {
 		*res = BULKSTAT_RV_NOTHING;
 		return error;
 	}
@@ -1796,12 +1793,13 @@
 		 * Iterate thru all the inodes in the file system,
 		 * adjusting the corresponding dquot counters in core.
 		 */
-		if ((error = xfs_bulkstat(mp, &lastino, &count,
-				     xfs_qm_dqusage_adjust, NULL,
-				     structsz, NULL, BULKSTAT_FG_IGET, &done)))
+		error = xfs_bulkstat(mp, &lastino, &count,
+				     xfs_qm_dqusage_adjust,
+				     structsz, NULL, &done);
+		if (error)
 			break;
 
-	} while (! done);
+	} while (!done);
 
 	/*
 	 * We've made all the changes that we need to make incore.
@@ -1889,14 +1887,14 @@
 		    mp->m_sb.sb_uquotino != NULLFSINO) {
 			ASSERT(mp->m_sb.sb_uquotino > 0);
 			if ((error = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,
-					     0, 0, &uip, 0)))
+					     0, 0, &uip)))
 				return XFS_ERROR(error);
 		}
 		if (XFS_IS_OQUOTA_ON(mp) &&
 		    mp->m_sb.sb_gquotino != NULLFSINO) {
 			ASSERT(mp->m_sb.sb_gquotino > 0);
 			if ((error = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,
-					     0, 0, &gip, 0))) {
+					     0, 0, &gip))) {
 				if (uip)
 					IRELE(uip);
 				return XFS_ERROR(error);
diff -urN linux-2.6.35-rc3/fs/xfs/quota/xfs_qm_syscalls.c linux-2.6.35-rc4/fs/xfs/quota/xfs_qm_syscalls.c
--- linux-2.6.35-rc3/fs/xfs/quota/xfs_qm_syscalls.c	2010-07-05 05:34:22.983805283 +0000
+++ linux-2.6.35-rc4/fs/xfs/quota/xfs_qm_syscalls.c	2010-07-05 05:34:28.351868072 +0000
@@ -262,7 +262,7 @@
 	}
 
 	if ((flags & XFS_DQ_USER) && mp->m_sb.sb_uquotino != NULLFSINO) {
-		error = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino, 0, 0, &qip, 0);
+		error = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino, 0, 0, &qip);
 		if (!error) {
 			error = xfs_truncate_file(mp, qip);
 			IRELE(qip);
@@ -271,7 +271,7 @@
 
 	if ((flags & (XFS_DQ_GROUP|XFS_DQ_PROJ)) &&
 	    mp->m_sb.sb_gquotino != NULLFSINO) {
-		error2 = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino, 0, 0, &qip, 0);
+		error2 = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino, 0, 0, &qip);
 		if (!error2) {
 			error2 = xfs_truncate_file(mp, qip);
 			IRELE(qip);
@@ -417,12 +417,12 @@
 	}
 	if (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {
 		if (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,
-					0, 0, &uip, 0) == 0)
+					0, 0, &uip) == 0)
 			tempuqip = B_TRUE;
 	}
 	if (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {
 		if (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,
-					0, 0, &gip, 0) == 0)
+					0, 0, &gip) == 0)
 			tempgqip = B_TRUE;
 	}
 	if (uip) {
@@ -1109,10 +1109,7 @@
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* not used */
 	int		ubsize,		/* not used */
-	void		*private_data,	/* not used */
-	xfs_daddr_t	bno,		/* starting block of inode cluster */
 	int		*ubused,	/* not used */
-	void		*dip,		/* not used */
 	int		*res)		/* bulkstat result code */
 {
 	xfs_inode_t		*ip;
@@ -1134,7 +1131,7 @@
 	ipreleased = B_FALSE;
  again:
 	lock_flags = XFS_ILOCK_SHARED;
-	if ((error = xfs_iget(mp, NULL, ino, 0, lock_flags, &ip, bno))) {
+	if ((error = xfs_iget(mp, NULL, ino, 0, lock_flags, &ip))) {
 		*res = BULKSTAT_RV_NOTHING;
 		return (error);
 	}
@@ -1205,15 +1202,15 @@
 		 * Iterate thru all the inodes in the file system,
 		 * adjusting the corresponding dquot counters
 		 */
-		if ((error = xfs_bulkstat(mp, &lastino, &count,
-				 xfs_qm_internalqcheck_adjust, NULL,
-				 0, NULL, BULKSTAT_FG_IGET, &done))) {
+		error = xfs_bulkstat(mp, &lastino, &count,
+				 xfs_qm_internalqcheck_adjust,
+				 0, NULL, &done);
+		if (error) {
+			cmn_err(CE_DEBUG, "Bulkstat returned error 0x%x", error);
 			break;
 		}
-	} while (! done);
-	if (error) {
-		cmn_err(CE_DEBUG, "Bulkstat returned error 0x%x", error);
-	}
+	} while (!done);
+
 	cmn_err(CE_DEBUG, "Checking results against system dquots");
 	for (i = 0; i < qmtest_hashmask; i++) {
 		xfs_dqtest_t	*d, *n;
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_dfrag.c linux-2.6.35-rc4/fs/xfs/xfs_dfrag.c
--- linux-2.6.35-rc3/fs/xfs/xfs_dfrag.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_dfrag.c	2010-07-05 05:34:28.354868058 +0000
@@ -69,7 +69,9 @@
 		goto out;
 	}
 
-	if (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND)) {
+	if (!(file->f_mode & FMODE_WRITE) ||
+	    !(file->f_mode & FMODE_READ) ||
+	    (file->f_flags & O_APPEND)) {
 		error = XFS_ERROR(EBADF);
 		goto out_put_file;
 	}
@@ -81,6 +83,7 @@
 	}
 
 	if (!(tmp_file->f_mode & FMODE_WRITE) ||
+	    !(tmp_file->f_mode & FMODE_READ) ||
 	    (tmp_file->f_flags & O_APPEND)) {
 		error = XFS_ERROR(EBADF);
 		goto out_put_tmp_file;
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_ialloc.c linux-2.6.35-rc4/fs/xfs/xfs_ialloc.c
--- linux-2.6.35-rc3/fs/xfs/xfs_ialloc.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_ialloc.c	2010-07-05 05:34:28.355868065 +0000
@@ -1203,6 +1203,63 @@
 	return error;
 }
 
+STATIC int
+xfs_imap_lookup(
+	struct xfs_mount	*mp,
+	struct xfs_trans	*tp,
+	xfs_agnumber_t		agno,
+	xfs_agino_t		agino,
+	xfs_agblock_t		agbno,
+	xfs_agblock_t		*chunk_agbno,
+	xfs_agblock_t		*offset_agbno,
+	int			flags)
+{
+	struct xfs_inobt_rec_incore rec;
+	struct xfs_btree_cur	*cur;
+	struct xfs_buf		*agbp;
+	xfs_agino_t		startino;
+	int			error;
+	int			i;
+
+	error = xfs_ialloc_read_agi(mp, tp, agno, &agbp);
+	if (error) {
+		xfs_fs_cmn_err(CE_ALERT, mp, "xfs_imap: "
+				"xfs_ialloc_read_agi() returned "
+				"error %d, agno %d",
+				error, agno);
+		return error;
+	}
+
+	/*
+	 * derive and lookup the exact inode record for the given agino. If the
+	 * record cannot be found, then it's an invalid inode number and we
+	 * should abort.
+	 */
+	cur = xfs_inobt_init_cursor(mp, tp, agbp, agno);
+	startino = agino & ~(XFS_IALLOC_INODES(mp) - 1);
+	error = xfs_inobt_lookup(cur, startino, XFS_LOOKUP_EQ, &i);
+	if (!error) {
+		if (i)
+			error = xfs_inobt_get_rec(cur, &rec, &i);
+		if (!error && i == 0)
+			error = EINVAL;
+	}
+
+	xfs_trans_brelse(tp, agbp);
+	xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);
+	if (error)
+		return error;
+
+	/* for untrusted inodes check it is allocated first */
+	if ((flags & XFS_IGET_UNTRUSTED) &&
+	    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))
+		return EINVAL;
+
+	*chunk_agbno = XFS_AGINO_TO_AGBNO(mp, rec.ir_startino);
+	*offset_agbno = agbno - *chunk_agbno;
+	return 0;
+}
+
 /*
  * Return the location of the inode in imap, for mapping it into a buffer.
  */
@@ -1235,8 +1292,11 @@
 	if (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||
 	    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {
 #ifdef DEBUG
-		/* no diagnostics for bulkstat, ino comes from userspace */
-		if (flags & XFS_IGET_BULKSTAT)
+		/*
+		 * Don't output diagnostic information for untrusted inodes
+		 * as they can be invalid without implying corruption.
+		 */
+		if (flags & XFS_IGET_UNTRUSTED)
 			return XFS_ERROR(EINVAL);
 		if (agno >= mp->m_sb.sb_agcount) {
 			xfs_fs_cmn_err(CE_ALERT, mp,
@@ -1263,6 +1323,23 @@
 		return XFS_ERROR(EINVAL);
 	}
 
+	blks_per_cluster = XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_blocklog;
+
+	/*
+	 * For bulkstat and handle lookups, we have an untrusted inode number
+	 * that we have to verify is valid. We cannot do this just by reading
+	 * the inode buffer as it may have been unlinked and removed leaving
+	 * inodes in stale state on disk. Hence we have to do a btree lookup
+	 * in all cases where an untrusted inode number is passed.
+	 */
+	if (flags & XFS_IGET_UNTRUSTED) {
+		error = xfs_imap_lookup(mp, tp, agno, agino, agbno,
+					&chunk_agbno, &offset_agbno, flags);
+		if (error)
+			return error;
+		goto out_map;
+	}
+
 	/*
 	 * If the inode cluster size is the same as the blocksize or
 	 * smaller we get to the buffer by simple arithmetics.
@@ -1277,24 +1354,6 @@
 		return 0;
 	}
 
-	blks_per_cluster = XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_blocklog;
-
-	/*
-	 * If we get a block number passed from bulkstat we can use it to
-	 * find the buffer easily.
-	 */
-	if (imap->im_blkno) {
-		offset = XFS_INO_TO_OFFSET(mp, ino);
-		ASSERT(offset < mp->m_sb.sb_inopblock);
-
-		cluster_agbno = xfs_daddr_to_agbno(mp, imap->im_blkno);
-		offset += (agbno - cluster_agbno) * mp->m_sb.sb_inopblock;
-
-		imap->im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);
-		imap->im_boffset = (ushort)(offset << mp->m_sb.sb_inodelog);
-		return 0;
-	}
-
 	/*
 	 * If the inode chunks are aligned then use simple maths to
 	 * find the location. Otherwise we have to do a btree
@@ -1304,50 +1363,13 @@
 		offset_agbno = agbno & mp->m_inoalign_mask;
 		chunk_agbno = agbno - offset_agbno;
 	} else {
-		xfs_btree_cur_t	*cur;	/* inode btree cursor */
-		xfs_inobt_rec_incore_t chunk_rec;
-		xfs_buf_t	*agbp;	/* agi buffer */
-		int		i;	/* temp state */
-
-		error = xfs_ialloc_read_agi(mp, tp, agno, &agbp);
-		if (error) {
-			xfs_fs_cmn_err(CE_ALERT, mp, "xfs_imap: "
-					"xfs_ialloc_read_agi() returned "
-					"error %d, agno %d",
-					error, agno);
-			return error;
-		}
-
-		cur = xfs_inobt_init_cursor(mp, tp, agbp, agno);
-		error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);
-		if (error) {
-			xfs_fs_cmn_err(CE_ALERT, mp, "xfs_imap: "
-					"xfs_inobt_lookup() failed");
-			goto error0;
-		}
-
-		error = xfs_inobt_get_rec(cur, &chunk_rec, &i);
-		if (error) {
-			xfs_fs_cmn_err(CE_ALERT, mp, "xfs_imap: "
-					"xfs_inobt_get_rec() failed");
-			goto error0;
-		}
-		if (i == 0) {
-#ifdef DEBUG
-			xfs_fs_cmn_err(CE_ALERT, mp, "xfs_imap: "
-					"xfs_inobt_get_rec() failed");
-#endif /* DEBUG */
-			error = XFS_ERROR(EINVAL);
-		}
- error0:
-		xfs_trans_brelse(tp, agbp);
-		xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);
+		error = xfs_imap_lookup(mp, tp, agno, agino, agbno,
+					&chunk_agbno, &offset_agbno, flags);
 		if (error)
 			return error;
-		chunk_agbno = XFS_AGINO_TO_AGBNO(mp, chunk_rec.ir_startino);
-		offset_agbno = agbno - chunk_agbno;
 	}
 
+out_map:
 	ASSERT(agbno >= chunk_agbno);
 	cluster_agbno = chunk_agbno +
 		((offset_agbno / blks_per_cluster) * blks_per_cluster);
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_iget.c linux-2.6.35-rc4/fs/xfs/xfs_iget.c
--- linux-2.6.35-rc3/fs/xfs/xfs_iget.c	2010-07-05 05:34:22.987867990 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_iget.c	2010-07-05 05:34:28.355868065 +0000
@@ -259,7 +259,6 @@
 	xfs_trans_t		*tp,
 	xfs_ino_t		ino,
 	struct xfs_inode	**ipp,
-	xfs_daddr_t		bno,
 	int			flags,
 	int			lock_flags)
 {
@@ -272,7 +271,7 @@
 	if (!ip)
 		return ENOMEM;
 
-	error = xfs_iread(mp, tp, ip, bno, flags);
+	error = xfs_iread(mp, tp, ip, flags);
 	if (error)
 		goto out_destroy;
 
@@ -358,8 +357,6 @@
  *        within the file system for the inode being requested.
  * lock_flags -- flags indicating how to lock the inode.  See the comment
  *		 for xfs_ilock() for a list of valid values.
- * bno -- the block number starting the buffer containing the inode,
- *	  if known (as by bulkstat), else 0.
  */
 int
 xfs_iget(
@@ -368,8 +365,7 @@
 	xfs_ino_t	ino,
 	uint		flags,
 	uint		lock_flags,
-	xfs_inode_t	**ipp,
-	xfs_daddr_t	bno)
+	xfs_inode_t	**ipp)
 {
 	xfs_inode_t	*ip;
 	int		error;
@@ -397,7 +393,7 @@
 		read_unlock(&pag->pag_ici_lock);
 		XFS_STATS_INC(xs_ig_missed);
 
-		error = xfs_iget_cache_miss(mp, pag, tp, ino, &ip, bno,
+		error = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,
 							flags, lock_flags);
 		if (error)
 			goto out_error_or_again;
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_inode.c linux-2.6.35-rc4/fs/xfs/xfs_inode.c
--- linux-2.6.35-rc3/fs/xfs/xfs_inode.c	2010-07-05 05:34:22.987867990 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_inode.c	2010-07-05 05:34:28.356868082 +0000
@@ -177,7 +177,7 @@
 		if (unlikely(XFS_TEST_ERROR(!di_ok, mp,
 						XFS_ERRTAG_ITOBP_INOTOBP,
 						XFS_RANDOM_ITOBP_INOTOBP))) {
-			if (iget_flags & XFS_IGET_BULKSTAT) {
+			if (iget_flags & XFS_IGET_UNTRUSTED) {
 				xfs_trans_brelse(tp, bp);
 				return XFS_ERROR(EINVAL);
 			}
@@ -787,7 +787,6 @@
 	xfs_mount_t	*mp,
 	xfs_trans_t	*tp,
 	xfs_inode_t	*ip,
-	xfs_daddr_t	bno,
 	uint		iget_flags)
 {
 	xfs_buf_t	*bp;
@@ -797,11 +796,9 @@
 	/*
 	 * Fill in the location information in the in-core inode.
 	 */
-	ip->i_imap.im_blkno = bno;
 	error = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);
 	if (error)
 		return error;
-	ASSERT(bno == 0 || bno == ip->i_imap.im_blkno);
 
 	/*
 	 * Get pointers to the on-disk inode and the buffer containing it.
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_inode.h linux-2.6.35-rc4/fs/xfs/xfs_inode.h
--- linux-2.6.35-rc3/fs/xfs/xfs_inode.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_inode.h	2010-07-05 05:34:28.356868082 +0000
@@ -442,7 +442,7 @@
  * xfs_iget.c prototypes.
  */
 int		xfs_iget(struct xfs_mount *, struct xfs_trans *, xfs_ino_t,
-			 uint, uint, xfs_inode_t **, xfs_daddr_t);
+			 uint, uint, xfs_inode_t **);
 void		xfs_iput(xfs_inode_t *, uint);
 void		xfs_iput_new(xfs_inode_t *, uint);
 void		xfs_ilock(xfs_inode_t *, uint);
@@ -500,7 +500,7 @@
  * Flags for xfs_iget()
  */
 #define XFS_IGET_CREATE		0x1
-#define XFS_IGET_BULKSTAT	0x2
+#define XFS_IGET_UNTRUSTED	0x2
 
 int		xfs_inotobp(struct xfs_mount *, struct xfs_trans *,
 			    xfs_ino_t, struct xfs_dinode **,
@@ -509,7 +509,7 @@
 			  struct xfs_inode *, struct xfs_dinode **,
 			  struct xfs_buf **, uint);
 int		xfs_iread(struct xfs_mount *, struct xfs_trans *,
-			  struct xfs_inode *, xfs_daddr_t, uint);
+			  struct xfs_inode *, uint);
 void		xfs_dinode_to_disk(struct xfs_dinode *,
 				   struct xfs_icdinode *);
 void		xfs_idestroy_fork(struct xfs_inode *, int);
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_itable.c linux-2.6.35-rc4/fs/xfs/xfs_itable.c
--- linux-2.6.35-rc3/fs/xfs/xfs_itable.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_itable.c	2010-07-05 05:34:28.357868092 +0000
@@ -49,24 +49,40 @@
 		 (ino == mp->m_sb.sb_uquotino || ino == mp->m_sb.sb_gquotino)));
 }
 
-STATIC int
-xfs_bulkstat_one_iget(
-	xfs_mount_t	*mp,		/* mount point for filesystem */
-	xfs_ino_t	ino,		/* inode number to get data for */
-	xfs_daddr_t	bno,		/* starting bno of inode cluster */
-	xfs_bstat_t	*buf,		/* return buffer */
-	int		*stat)		/* BULKSTAT_RV_... */
+/*
+ * Return stat information for one inode.
+ * Return 0 if ok, else errno.
+ */
+int
+xfs_bulkstat_one_int(
+	struct xfs_mount	*mp,		/* mount point for filesystem */
+	xfs_ino_t		ino,		/* inode to get data for */
+	void __user		*buffer,	/* buffer to place output in */
+	int			ubsize,		/* size of buffer */
+	bulkstat_one_fmt_pf	formatter,	/* formatter, copy to user */
+	int			*ubused,	/* bytes used by me */
+	int			*stat)		/* BULKSTAT_RV_... */
 {
-	xfs_icdinode_t	*dic;	/* dinode core info pointer */
-	xfs_inode_t	*ip;		/* incore inode pointer */
-	struct inode	*inode;
-	int		error;
+	struct xfs_icdinode	*dic;		/* dinode core info pointer */
+	struct xfs_inode	*ip;		/* incore inode pointer */
+	struct inode		*inode;
+	struct xfs_bstat	*buf;		/* return buffer */
+	int			error = 0;	/* error value */
+
+	*stat = BULKSTAT_RV_NOTHING;
+
+	if (!buffer || xfs_internal_inum(mp, ino))
+		return XFS_ERROR(EINVAL);
+
+	buf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);
+	if (!buf)
+		return XFS_ERROR(ENOMEM);
 
 	error = xfs_iget(mp, NULL, ino,
-			 XFS_IGET_BULKSTAT, XFS_ILOCK_SHARED, &ip, bno);
+			 XFS_IGET_UNTRUSTED, XFS_ILOCK_SHARED, &ip);
 	if (error) {
 		*stat = BULKSTAT_RV_NOTHING;
-		return error;
+		goto out_free;
 	}
 
 	ASSERT(ip != NULL);
@@ -127,77 +143,16 @@
 		buf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;
 		break;
 	}
-
 	xfs_iput(ip, XFS_ILOCK_SHARED);
-	return error;
-}
 
-STATIC void
-xfs_bulkstat_one_dinode(
-	xfs_mount_t	*mp,		/* mount point for filesystem */
-	xfs_ino_t	ino,		/* inode number to get data for */
-	xfs_dinode_t	*dic,		/* dinode inode pointer */
-	xfs_bstat_t	*buf)		/* return buffer */
-{
-	/*
-	 * The inode format changed when we moved the link count and
-	 * made it 32 bits long.  If this is an old format inode,
-	 * convert it in memory to look like a new one.  If it gets
-	 * flushed to disk we will convert back before flushing or
-	 * logging it.  We zero out the new projid field and the old link
-	 * count field.  We'll handle clearing the pad field (the remains
-	 * of the old uuid field) when we actually convert the inode to
-	 * the new format. We don't change the version number so that we
-	 * can distinguish this from a real new format inode.
-	 */
-	if (dic->di_version == 1) {
-		buf->bs_nlink = be16_to_cpu(dic->di_onlink);
-		buf->bs_projid = 0;
-	} else {
-		buf->bs_nlink = be32_to_cpu(dic->di_nlink);
-		buf->bs_projid = be16_to_cpu(dic->di_projid);
-	}
+	error = formatter(buffer, ubsize, ubused, buf);
 
-	buf->bs_ino = ino;
-	buf->bs_mode = be16_to_cpu(dic->di_mode);
-	buf->bs_uid = be32_to_cpu(dic->di_uid);
-	buf->bs_gid = be32_to_cpu(dic->di_gid);
-	buf->bs_size = be64_to_cpu(dic->di_size);
-	buf->bs_atime.tv_sec = be32_to_cpu(dic->di_atime.t_sec);
-	buf->bs_atime.tv_nsec = be32_to_cpu(dic->di_atime.t_nsec);
-	buf->bs_mtime.tv_sec = be32_to_cpu(dic->di_mtime.t_sec);
-	buf->bs_mtime.tv_nsec = be32_to_cpu(dic->di_mtime.t_nsec);
-	buf->bs_ctime.tv_sec = be32_to_cpu(dic->di_ctime.t_sec);
-	buf->bs_ctime.tv_nsec = be32_to_cpu(dic->di_ctime.t_nsec);
-	buf->bs_xflags = xfs_dic2xflags(dic);
-	buf->bs_extsize = be32_to_cpu(dic->di_extsize) << mp->m_sb.sb_blocklog;
-	buf->bs_extents = be32_to_cpu(dic->di_nextents);
-	buf->bs_gen = be32_to_cpu(dic->di_gen);
-	memset(buf->bs_pad, 0, sizeof(buf->bs_pad));
-	buf->bs_dmevmask = be32_to_cpu(dic->di_dmevmask);
-	buf->bs_dmstate = be16_to_cpu(dic->di_dmstate);
-	buf->bs_aextents = be16_to_cpu(dic->di_anextents);
-	buf->bs_forkoff = XFS_DFORK_BOFF(dic);
+	if (!error)
+		*stat = BULKSTAT_RV_DIDONE;
 
-	switch (dic->di_format) {
-	case XFS_DINODE_FMT_DEV:
-		buf->bs_rdev = xfs_dinode_get_rdev(dic);
-		buf->bs_blksize = BLKDEV_IOSIZE;
-		buf->bs_blocks = 0;
-		break;
-	case XFS_DINODE_FMT_LOCAL:
-	case XFS_DINODE_FMT_UUID:
-		buf->bs_rdev = 0;
-		buf->bs_blksize = mp->m_sb.sb_blocksize;
-		buf->bs_blocks = 0;
-		break;
-	case XFS_DINODE_FMT_EXTENTS:
-	case XFS_DINODE_FMT_BTREE:
-		buf->bs_rdev = 0;
-		buf->bs_blksize = mp->m_sb.sb_blocksize;
-		buf->bs_blocks = be64_to_cpu(dic->di_nblocks);
-		break;
-	}
+ out_free:
+	kmem_free(buf);
+	return error;
 }
 
 /* Return 0 on success or positive error */
@@ -217,118 +172,17 @@
 	return 0;
 }
 
-/*
- * Return stat information for one inode.
- * Return 0 if ok, else errno.
- */
-int		   	    		/* error status */
-xfs_bulkstat_one_int(
-	xfs_mount_t	*mp,		/* mount point for filesystem */
-	xfs_ino_t	ino,		/* inode number to get data for */
-	void		__user *buffer,	/* buffer to place output in */
-	int		ubsize,		/* size of buffer */
-	bulkstat_one_fmt_pf formatter,	/* formatter, copy to user */
-	xfs_daddr_t	bno,		/* starting bno of inode cluster */
-	int		*ubused,	/* bytes used by me */
-	void		*dibuff,	/* on-disk inode buffer */
-	int		*stat)		/* BULKSTAT_RV_... */
-{
-	xfs_bstat_t	*buf;		/* return buffer */
-	int		error = 0;	/* error value */
-	xfs_dinode_t	*dip;		/* dinode inode pointer */
-
-	dip = (xfs_dinode_t *)dibuff;
-	*stat = BULKSTAT_RV_NOTHING;
-
-	if (!buffer || xfs_internal_inum(mp, ino))
-		return XFS_ERROR(EINVAL);
-
-	buf = kmem_alloc(sizeof(*buf), KM_SLEEP);
-
-	if (dip == NULL) {
-		/* We're not being passed a pointer to a dinode.  This happens
-		 * if BULKSTAT_FG_IGET is selected.  Do the iget.
-		 */
-		error = xfs_bulkstat_one_iget(mp, ino, bno, buf, stat);
-		if (error)
-			goto out_free;
-	} else {
-		xfs_bulkstat_one_dinode(mp, ino, dip, buf);
-	}
-
-	error = formatter(buffer, ubsize, ubused, buf);
-	if (error)
-		goto out_free;
-
-	*stat = BULKSTAT_RV_DIDONE;
-
- out_free:
-	kmem_free(buf);
-	return error;
-}
-
 int
 xfs_bulkstat_one(
 	xfs_mount_t	*mp,		/* mount point for filesystem */
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* buffer to place output in */
 	int		ubsize,		/* size of buffer */
-	void		*private_data,	/* my private data */
-	xfs_daddr_t	bno,		/* starting bno of inode cluster */
 	int		*ubused,	/* bytes used by me */
-	void		*dibuff,	/* on-disk inode buffer */
 	int		*stat)		/* BULKSTAT_RV_... */
 {
 	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
-				    xfs_bulkstat_one_fmt, bno,
-				    ubused, dibuff, stat);
-}
-
-/*
- * Test to see whether we can use the ondisk inode directly, based
- * on the given bulkstat flags, filling in dipp accordingly.
- * Returns zero if the inode is dodgey.
- */
-STATIC int
-xfs_bulkstat_use_dinode(
-	xfs_mount_t	*mp,
-	int		flags,
-	xfs_buf_t	*bp,
-	int		clustidx,
-	xfs_dinode_t	**dipp)
-{
-	xfs_dinode_t	*dip;
-	unsigned int	aformat;
-
-	*dipp = NULL;
-	if (!bp || (flags & BULKSTAT_FG_IGET))
-		return 1;
-	dip = (xfs_dinode_t *)
-			xfs_buf_offset(bp, clustidx << mp->m_sb.sb_inodelog);
-	/*
-	 * Check the buffer containing the on-disk inode for di_mode == 0.
-	 * This is to prevent xfs_bulkstat from picking up just reclaimed
-	 * inodes that have their in-core state initialized but not flushed
-	 * to disk yet. This is a temporary hack that would require a proper
-	 * fix in the future.
-	 */
-	if (be16_to_cpu(dip->di_magic) != XFS_DINODE_MAGIC ||
-	    !XFS_DINODE_GOOD_VERSION(dip->di_version) ||
-	    !dip->di_mode)
-		return 0;
-	if (flags & BULKSTAT_FG_QUICK) {
-		*dipp = dip;
-		return 1;
-	}
-	/* BULKSTAT_FG_INLINE: if attr fork is local, or not there, use it */
-	aformat = dip->di_aformat;
-	if ((XFS_DFORK_Q(dip) == 0) ||
-	    (aformat == XFS_DINODE_FMT_LOCAL) ||
-	    (aformat == XFS_DINODE_FMT_EXTENTS && !dip->di_anextents)) {
-		*dipp = dip;
-		return 1;
-	}
-	return 1;
+				    xfs_bulkstat_one_fmt, ubused, stat);
 }
 
 #define XFS_BULKSTAT_UBLEFT(ubleft)	((ubleft) >= statstruct_size)
@@ -342,10 +196,8 @@
 	xfs_ino_t		*lastinop, /* last inode returned */
 	int			*ubcountp, /* size of buffer/count returned */
 	bulkstat_one_pf		formatter, /* func that'd fill a single buf */
-	void			*private_data,/* private data for formatter */
 	size_t			statstruct_size, /* sizeof struct filling */
 	char			__user *ubuffer, /* buffer with inode stats */
-	int			flags,	/* defined in xfs_itable.h */
 	int			*done)	/* 1 if there are more stats to get */
 {
 	xfs_agblock_t		agbno=0;/* allocation group block number */
@@ -380,14 +232,12 @@
 	int			ubelem;	/* spaces used in user's buffer */
 	int			ubused;	/* bytes used by formatter */
 	xfs_buf_t		*bp;	/* ptr to on-disk inode cluster buf */
-	xfs_dinode_t		*dip;	/* ptr into bp for specific inode */
 
 	/*
 	 * Get the last inode value, see if there's nothing to do.
 	 */
 	ino = (xfs_ino_t)*lastinop;
 	lastino = ino;
-	dip = NULL;
 	agno = XFS_INO_TO_AGNO(mp, ino);
 	agino = XFS_INO_TO_AGINO(mp, ino);
 	if (agno >= mp->m_sb.sb_agcount ||
@@ -612,37 +462,6 @@
 							irbp->ir_startino) +
 						((chunkidx & nimask) >>
 						 mp->m_sb.sb_inopblog);
-
-					if (flags & (BULKSTAT_FG_QUICK |
-						     BULKSTAT_FG_INLINE)) {
-						int offset;
-
-						ino = XFS_AGINO_TO_INO(mp, agno,
-								       agino);
-						bno = XFS_AGB_TO_DADDR(mp, agno,
-								       agbno);
-
-						/*
-						 * Get the inode cluster buffer
-						 */
-						if (bp)
-							xfs_buf_relse(bp);
-
-						error = xfs_inotobp(mp, NULL, ino, &dip,
-								    &bp, &offset,
-								    XFS_IGET_BULKSTAT);
-
-						if (!error)
-							clustidx = offset / mp->m_sb.sb_inodesize;
-						if (XFS_TEST_ERROR(error != 0,
-								   mp, XFS_ERRTAG_BULKSTAT_READ_CHUNK,
-								   XFS_RANDOM_BULKSTAT_READ_CHUNK)) {
-							bp = NULL;
-							ubleft = 0;
-							rval = error;
-							break;
-						}
-					}
 				}
 				ino = XFS_AGINO_TO_INO(mp, agno, agino);
 				bno = XFS_AGB_TO_DADDR(mp, agno, agbno);
@@ -658,35 +477,13 @@
 				 * when the chunk is used up.
 				 */
 				irbp->ir_freecount++;
-				if (!xfs_bulkstat_use_dinode(mp, flags, bp,
-							     clustidx, &dip)) {
-					lastino = ino;
-					continue;
-				}
-				/*
-				 * If we need to do an iget, cannot hold bp.
-				 * Drop it, until starting the next cluster.
-				 */
-				if ((flags & BULKSTAT_FG_INLINE) && !dip) {
-					if (bp)
-						xfs_buf_relse(bp);
-					bp = NULL;
-				}
 
 				/*
 				 * Get the inode and fill in a single buffer.
-				 * BULKSTAT_FG_QUICK uses dip to fill it in.
-				 * BULKSTAT_FG_IGET uses igets.
-				 * BULKSTAT_FG_INLINE uses dip if we have an
-				 * inline attr fork, else igets.
-				 * See: xfs_bulkstat_one & xfs_dm_bulkstat_one.
-				 * This is also used to count inodes/blks, etc
-				 * in xfs_qm_quotacheck.
 				 */
 				ubused = statstruct_size;
-				error = formatter(mp, ino, ubufp,
-						ubleft, private_data,
-						bno, &ubused, dip, &fmterror);
+				error = formatter(mp, ino, ubufp, ubleft,
+						  &ubused, &fmterror);
 				if (fmterror == BULKSTAT_RV_NOTHING) {
 					if (error && error != ENOENT &&
 						error != EINVAL) {
@@ -778,8 +575,7 @@
 	 */
 
 	ino = (xfs_ino_t)*lastinop;
-	error = xfs_bulkstat_one(mp, ino, buffer, sizeof(xfs_bstat_t),
-				 NULL, 0, NULL, NULL, &res);
+	error = xfs_bulkstat_one(mp, ino, buffer, sizeof(xfs_bstat_t), 0, &res);
 	if (error) {
 		/*
 		 * Special case way failed, do it the "long" way
@@ -788,8 +584,7 @@
 		(*lastinop)--;
 		count = 1;
 		if (xfs_bulkstat(mp, lastinop, &count, xfs_bulkstat_one,
-				NULL, sizeof(xfs_bstat_t), buffer,
-				BULKSTAT_FG_IGET, done))
+				sizeof(xfs_bstat_t), buffer, done))
 			return error;
 		if (count == 0 || (xfs_ino_t)*lastinop != ino)
 			return error == EFSCORRUPTED ?
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_itable.h linux-2.6.35-rc4/fs/xfs/xfs_itable.h
--- linux-2.6.35-rc3/fs/xfs/xfs_itable.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_itable.h	2010-07-05 05:34:28.357868092 +0000
@@ -27,10 +27,7 @@
 			       xfs_ino_t	ino,
 			       void		__user *buffer,
 			       int		ubsize,
-			       void		*private_data,
-			       xfs_daddr_t	bno,
 			       int		*ubused,
-			       void		*dip,
 			       int		*stat);
 
 /*
@@ -41,13 +38,6 @@
 #define BULKSTAT_RV_GIVEUP	2
 
 /*
- * Values for bulkstat flag argument.
- */
-#define BULKSTAT_FG_IGET	0x1	/* Go through the buffer cache */
-#define BULKSTAT_FG_QUICK	0x2	/* No iget, walk the dinode cluster */
-#define BULKSTAT_FG_INLINE	0x4	/* No iget if inline attrs */
-
-/*
  * Return stat information in bulk (by-inode) for the filesystem.
  */
 int					/* error status */
@@ -56,10 +46,8 @@
 	xfs_ino_t	*lastino,	/* last inode returned */
 	int		*count,		/* size of buffer/count returned */
 	bulkstat_one_pf formatter,	/* func that'd fill a single buf */
-	void		*private_data,	/* private data for formatter */
 	size_t		statstruct_size,/* sizeof struct that we're filling */
 	char		__user *ubuffer,/* buffer with inode stats */
-	int		flags,		/* flag to control access method */
 	int		*done);		/* 1 if there are more stats to get */
 
 int
@@ -82,9 +70,7 @@
 	void			__user *buffer,
 	int			ubsize,
 	bulkstat_one_fmt_pf	formatter,
-	xfs_daddr_t		bno,
 	int			*ubused,
-	void			*dibuff,
 	int			*stat);
 
 int
@@ -93,10 +79,7 @@
 	xfs_ino_t		ino,
 	void			__user *buffer,
 	int			ubsize,
-	void			*private_data,
-	xfs_daddr_t		bno,
 	int			*ubused,
-	void			*dibuff,
 	int			*stat);
 
 typedef int (*inumbers_fmt_pf)(
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_log_recover.c linux-2.6.35-rc4/fs/xfs/xfs_log_recover.c
--- linux-2.6.35-rc3/fs/xfs/xfs_log_recover.c	2010-07-05 05:34:22.991868058 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_log_recover.c	2010-07-05 05:34:28.360868138 +0000
@@ -3198,7 +3198,7 @@
 	int				error;
 
 	ino = XFS_AGINO_TO_INO(mp, agno, agino);
-	error = xfs_iget(mp, NULL, ino, 0, 0, &ip, 0);
+	error = xfs_iget(mp, NULL, ino, 0, 0, &ip);
 	if (error)
 		goto fail;
 
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_mount.c linux-2.6.35-rc4/fs/xfs/xfs_mount.c
--- linux-2.6.35-rc3/fs/xfs/xfs_mount.c	2010-07-05 05:34:22.991868058 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_mount.c	2010-07-05 05:34:28.360868138 +0000
@@ -1300,7 +1300,7 @@
 	 * Get and sanity-check the root inode.
 	 * Save the pointer to it in the mount structure.
 	 */
-	error = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip, 0);
+	error = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip);
 	if (error) {
 		cmn_err(CE_WARN, "XFS: failed to read root inode");
 		goto out_log_dealloc;
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_rtalloc.c linux-2.6.35-rc4/fs/xfs/xfs_rtalloc.c
--- linux-2.6.35-rc3/fs/xfs/xfs_rtalloc.c	2010-07-05 05:34:22.992867977 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_rtalloc.c	2010-07-05 05:34:28.361868079 +0000
@@ -2277,12 +2277,12 @@
 	sbp = &mp->m_sb;
 	if (sbp->sb_rbmino == NULLFSINO)
 		return 0;
-	error = xfs_iget(mp, NULL, sbp->sb_rbmino, 0, 0, &mp->m_rbmip, 0);
+	error = xfs_iget(mp, NULL, sbp->sb_rbmino, 0, 0, &mp->m_rbmip);
 	if (error)
 		return error;
 	ASSERT(mp->m_rbmip != NULL);
 	ASSERT(sbp->sb_rsumino != NULLFSINO);
-	error = xfs_iget(mp, NULL, sbp->sb_rsumino, 0, 0, &mp->m_rsumip, 0);
+	error = xfs_iget(mp, NULL, sbp->sb_rsumino, 0, 0, &mp->m_rsumip);
 	if (error) {
 		IRELE(mp->m_rbmip);
 		return error;
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_trans_inode.c linux-2.6.35-rc4/fs/xfs/xfs_trans_inode.c
--- linux-2.6.35-rc3/fs/xfs/xfs_trans_inode.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_trans_inode.c	2010-07-05 05:34:28.363868043 +0000
@@ -62,7 +62,7 @@
 {
 	int			error;
 
-	error = xfs_iget(mp, tp, ino, flags, lock_flags, ipp, 0);
+	error = xfs_iget(mp, tp, ino, flags, lock_flags, ipp);
 	if (!error && tp)
 		xfs_trans_ijoin(tp, *ipp, lock_flags);
 	return error;
diff -urN linux-2.6.35-rc3/fs/xfs/xfs_vnodeops.c linux-2.6.35-rc4/fs/xfs/xfs_vnodeops.c
--- linux-2.6.35-rc3/fs/xfs/xfs_vnodeops.c	2010-07-05 05:34:22.995868174 +0000
+++ linux-2.6.35-rc4/fs/xfs/xfs_vnodeops.c	2010-07-05 05:34:28.364868062 +0000
@@ -1269,7 +1269,7 @@
 	if (error)
 		goto out;
 
-	error = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp, 0);
+	error = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);
 	if (error)
 		goto out_free_name;
 
diff -urN linux-2.6.35-rc3/include/acpi/acexcep.h linux-2.6.35-rc4/include/acpi/acexcep.h
--- linux-2.6.35-rc3/include/acpi/acexcep.h	2010-07-05 05:34:22.995868174 +0000
+++ linux-2.6.35-rc4/include/acpi/acexcep.h	2010-07-05 05:34:28.364868062 +0000
@@ -212,7 +212,7 @@
 	"AE_NO_GLOBAL_LOCK",
 	"AE_ABORT_METHOD",
 	"AE_SAME_HANDLER",
-	"AE_WAKE_ONLY_GPE",
+	"AE_NO_HANDLER",
 	"AE_OWNER_ID_LIMIT"
 };
 
diff -urN linux-2.6.35-rc3/include/acpi/acpixf.h linux-2.6.35-rc4/include/acpi/acpixf.h
--- linux-2.6.35-rc3/include/acpi/acpixf.h	2010-07-05 05:34:22.995868174 +0000
+++ linux-2.6.35-rc4/include/acpi/acpixf.h	2010-07-05 05:34:28.365868126 +0000
@@ -69,6 +69,7 @@
 extern u32 acpi_gbl_trace_flags;
 extern u8 acpi_gbl_enable_aml_debug_object;
 extern u8 acpi_gbl_copy_dsdt_locally;
+extern u8 acpi_gbl_truncate_io_addresses;
 
 extern u32 acpi_current_gpe_count;
 extern struct acpi_table_fadt acpi_gbl_FADT;
diff -urN linux-2.6.35-rc3/include/acpi/actypes.h linux-2.6.35-rc4/include/acpi/actypes.h
--- linux-2.6.35-rc3/include/acpi/actypes.h	2010-07-05 05:34:22.996868114 +0000
+++ linux-2.6.35-rc4/include/acpi/actypes.h	2010-07-05 05:34:28.365868126 +0000
@@ -663,10 +663,11 @@
 #define ACPI_GPE_MAX                    0xFF
 #define ACPI_NUM_GPE                    256
 
-/* Actions for acpi_set_gpe */
+/* Actions for acpi_set_gpe and acpi_hw_low_set_gpe */
 
 #define ACPI_GPE_ENABLE                 0
 #define ACPI_GPE_DISABLE                1
+#define ACPI_GPE_COND_ENABLE            2
 
 /* gpe_types for acpi_enable_gpe and acpi_disable_gpe */
 
diff -urN linux-2.6.35-rc3/include/linux/agp_backend.h linux-2.6.35-rc4/include/linux/agp_backend.h
--- linux-2.6.35-rc3/include/linux/agp_backend.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/include/linux/agp_backend.h	2010-07-05 05:34:28.369868080 +0000
@@ -79,7 +79,6 @@
 	u32 physical;
 	bool is_bound;
 	bool is_flushed;
-	bool vmalloc_flag;
 	/* list of agp_memory mapped to the aperture */
 	struct list_head mapped_list;
 	/* DMA-mapped addresses */
diff -urN linux-2.6.35-rc3/include/linux/backing-dev.h linux-2.6.35-rc4/include/linux/backing-dev.h
--- linux-2.6.35-rc3/include/linux/backing-dev.h	2010-07-05 05:34:23.001868694 +0000
+++ linux-2.6.35-rc4/include/linux/backing-dev.h	2010-07-05 05:34:28.370868111 +0000
@@ -105,8 +105,8 @@
 int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev);
 void bdi_unregister(struct backing_dev_info *bdi);
 int bdi_setup_and_register(struct backing_dev_info *, char *, unsigned int);
-void bdi_start_writeback(struct backing_dev_info *bdi, struct super_block *sb,
-				long nr_pages);
+void bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages);
+void bdi_start_background_writeback(struct backing_dev_info *bdi);
 int bdi_writeback_task(struct bdi_writeback *wb);
 int bdi_has_dirty_io(struct backing_dev_info *bdi);
 void bdi_arm_supers_timer(void);
diff -urN linux-2.6.35-rc3/include/linux/cgroup.h linux-2.6.35-rc4/include/linux/cgroup.h
--- linux-2.6.35-rc3/include/linux/cgroup.h	2010-07-05 05:34:23.002868304 +0000
+++ linux-2.6.35-rc4/include/linux/cgroup.h	2010-07-05 05:34:28.372868061 +0000
@@ -525,13 +525,21 @@
 	return cgrp->subsys[subsys_id];
 }
 
-static inline struct cgroup_subsys_state *task_subsys_state(
-	struct task_struct *task, int subsys_id)
+/*
+ * function to get the cgroup_subsys_state which allows for extra
+ * rcu_dereference_check() conditions, such as locks used during the
+ * cgroup_subsys::attach() methods.
+ */
+#define task_subsys_state_check(task, subsys_id, __c)			\
+	rcu_dereference_check(task->cgroups->subsys[subsys_id],		\
+			      rcu_read_lock_held() ||			\
+			      lockdep_is_held(&task->alloc_lock) ||	\
+			      cgroup_lock_is_held() || (__c))
+
+static inline struct cgroup_subsys_state *
+task_subsys_state(struct task_struct *task, int subsys_id)
 {
-	return rcu_dereference_check(task->cgroups->subsys[subsys_id],
-				     rcu_read_lock_held() ||
-				     lockdep_is_held(&task->alloc_lock) ||
-				     cgroup_lock_is_held());
+	return task_subsys_state_check(task, subsys_id, false);
 }
 
 static inline struct cgroup* task_cgroup(struct task_struct *task,
diff -urN linux-2.6.35-rc3/include/linux/compiler-gcc.h linux-2.6.35-rc4/include/linux/compiler-gcc.h
--- linux-2.6.35-rc3/include/linux/compiler-gcc.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/include/linux/compiler-gcc.h	2010-07-05 05:34:28.372868061 +0000
@@ -58,8 +58,12 @@
  * naked functions because then mcount is called without stack and frame pointer
  * being set up and there is no chance to restore the lr register to the value
  * before mcount was called.
+ *
+ * The asm() bodies of naked functions often depend on standard calling conventions,
+ * therefore they must be noinline and noclone.  GCC 4.[56] currently fail to enforce
+ * this, so we must do so ourselves.  See GCC PR44290.
  */
-#define __naked				__attribute__((naked)) notrace
+#define __naked				__attribute__((naked)) noinline __noclone notrace
 
 #define __noreturn			__attribute__((noreturn))
 
@@ -85,3 +89,7 @@
 #define _gcc_header(x) __gcc_header(linux/compiler-gcc##x.h)
 #define gcc_header(x) _gcc_header(x)
 #include gcc_header(__GNUC__)
+
+#if !defined(__noclone)
+#define __noclone	/* not needed */
+#endif
diff -urN linux-2.6.35-rc3/include/linux/compiler-gcc4.h linux-2.6.35-rc4/include/linux/compiler-gcc4.h
--- linux-2.6.35-rc3/include/linux/compiler-gcc4.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/include/linux/compiler-gcc4.h	2010-07-05 05:34:28.372868061 +0000
@@ -48,6 +48,10 @@
  * unreleased.  Really, we need to have autoconf for the kernel.
  */
 #define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__))
+
 #endif
 
 #endif
diff -urN linux-2.6.35-rc3/include/linux/drbd.h linux-2.6.35-rc4/include/linux/drbd.h
--- linux-2.6.35-rc3/include/linux/drbd.h	2010-07-05 05:34:23.005868156 +0000
+++ linux-2.6.35-rc4/include/linux/drbd.h	2010-07-05 05:34:28.375868048 +0000
@@ -53,7 +53,7 @@
 
 
 extern const char *drbd_buildtag(void);
-#define REL_VERSION "8.3.8rc2"
+#define REL_VERSION "8.3.8"
 #define API_VERSION 88
 #define PRO_VERSION_MIN 86
 #define PRO_VERSION_MAX 94
diff -urN linux-2.6.35-rc3/include/linux/dynamic_debug.h linux-2.6.35-rc4/include/linux/dynamic_debug.h
--- linux-2.6.35-rc3/include/linux/dynamic_debug.h	2010-07-05 05:34:23.005868156 +0000
+++ linux-2.6.35-rc4/include/linux/dynamic_debug.h	2010-07-05 05:34:28.375868048 +0000
@@ -40,7 +40,7 @@
 				const char *modname);
 
 #if defined(CONFIG_DYNAMIC_DEBUG)
-extern int ddebug_remove_module(char *mod_name);
+extern int ddebug_remove_module(const char *mod_name);
 
 #define __dynamic_dbg_enabled(dd)  ({	     \
 	int __ret = 0;							     \
@@ -73,7 +73,7 @@
 
 #else
 
-static inline int ddebug_remove_module(char *mod)
+static inline int ddebug_remove_module(const char *mod)
 {
 	return 0;
 }
diff -urN linux-2.6.35-rc3/include/linux/fb.h linux-2.6.35-rc4/include/linux/fb.h
--- linux-2.6.35-rc3/include/linux/fb.h	2010-07-05 05:34:23.006868045 +0000
+++ linux-2.6.35-rc4/include/linux/fb.h	2010-07-05 05:34:28.376868052 +0000
@@ -786,8 +786,6 @@
 #define FBINFO_MISC_USEREVENT          0x10000 /* event request
 						  from userspace */
 #define FBINFO_MISC_TILEBLITTING       0x20000 /* use tile blitting */
-#define FBINFO_MISC_FIRMWARE           0x40000 /* a replaceable firmware
-						  inited framebuffer */
 
 /* A driver may set this flag to indicate that it does want a set_par to be
  * called every time when fbcon_switch is executed. The advantage is that with
@@ -801,6 +799,8 @@
  */
 #define FBINFO_MISC_ALWAYS_SETPAR   0x40000
 
+/* where the fb is a firmware driver, and can be replaced with a proper one */
+#define FBINFO_MISC_FIRMWARE        0x80000
 /*
  * Host and GPU endianness differ.
  */
diff -urN linux-2.6.35-rc3/include/linux/list.h linux-2.6.35-rc4/include/linux/list.h
--- linux-2.6.35-rc3/include/linux/list.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/include/linux/list.h	2010-07-05 05:34:28.386868158 +0000
@@ -544,6 +544,21 @@
 	     &pos->member != (head); 					\
 	     pos = n, n = list_entry(n->member.prev, typeof(*n), member))
 
+/**
+ * list_safe_reset_next - reset a stale list_for_each_entry_safe loop
+ * @pos:	the loop cursor used in the list_for_each_entry_safe loop
+ * @n:		temporary storage used in list_for_each_entry_safe
+ * @member:	the name of the list_struct within the struct.
+ *
+ * list_safe_reset_next is not safe to use in general if the list may be
+ * modified concurrently (eg. the lock is dropped in the loop body). An
+ * exception to this is if the cursor element (pos) is pinned in the list,
+ * and list_safe_reset_next is called after re-taking the lock and before
+ * completing the current iteration of the loop body.
+ */
+#define list_safe_reset_next(pos, n, member)				\
+	n = list_entry(pos->member.next, typeof(*pos), member)
+
 /*
  * Double linked lists with a single pointer list head.
  * Mostly useful for hash tables where the two pointer list head is
diff -urN linux-2.6.35-rc3/include/linux/pci_ids.h linux-2.6.35-rc4/include/linux/pci_ids.h
--- linux-2.6.35-rc3/include/linux/pci_ids.h	2010-07-05 05:34:23.026868100 +0000
+++ linux-2.6.35-rc4/include/linux/pci_ids.h	2010-07-05 05:34:28.397868056 +0000
@@ -1261,6 +1261,7 @@
 #define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP77_IDE       0x0759
 #define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_SMBUS     0x07D8
 #define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP79_SMBUS     0x0AA2
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA	    0x0D85
 
 #define PCI_VENDOR_ID_IMS		0x10e0
 #define PCI_DEVICE_ID_IMS_TT128		0x9128
diff -urN linux-2.6.35-rc3/include/linux/sched.h linux-2.6.35-rc4/include/linux/sched.h
--- linux-2.6.35-rc3/include/linux/sched.h	2010-07-05 05:34:23.031868075 +0000
+++ linux-2.6.35-rc4/include/linux/sched.h	2010-07-05 05:34:28.402806610 +0000
@@ -139,7 +139,7 @@
 extern unsigned long nr_running(void);
 extern unsigned long nr_uninterruptible(void);
 extern unsigned long nr_iowait(void);
-extern unsigned long nr_iowait_cpu(void);
+extern unsigned long nr_iowait_cpu(int cpu);
 extern unsigned long this_cpu_load(void);
 
 
diff -urN linux-2.6.35-rc3/include/linux/suspend.h linux-2.6.35-rc4/include/linux/suspend.h
--- linux-2.6.35-rc3/include/linux/suspend.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/include/linux/suspend.h	2010-07-05 05:34:28.408868056 +0000
@@ -256,22 +256,22 @@
 static inline bool system_entering_hibernation(void) { return false; }
 #endif /* CONFIG_HIBERNATION */
 
-#ifdef CONFIG_HIBERNATION_NVS
-extern int hibernate_nvs_register(unsigned long start, unsigned long size);
-extern int hibernate_nvs_alloc(void);
-extern void hibernate_nvs_free(void);
-extern void hibernate_nvs_save(void);
-extern void hibernate_nvs_restore(void);
-#else /* CONFIG_HIBERNATION_NVS */
-static inline int hibernate_nvs_register(unsigned long a, unsigned long b)
+#ifdef CONFIG_SUSPEND_NVS
+extern int suspend_nvs_register(unsigned long start, unsigned long size);
+extern int suspend_nvs_alloc(void);
+extern void suspend_nvs_free(void);
+extern void suspend_nvs_save(void);
+extern void suspend_nvs_restore(void);
+#else /* CONFIG_SUSPEND_NVS */
+static inline int suspend_nvs_register(unsigned long a, unsigned long b)
 {
 	return 0;
 }
-static inline int hibernate_nvs_alloc(void) { return 0; }
-static inline void hibernate_nvs_free(void) {}
-static inline void hibernate_nvs_save(void) {}
-static inline void hibernate_nvs_restore(void) {}
-#endif /* CONFIG_HIBERNATION_NVS */
+static inline int suspend_nvs_alloc(void) { return 0; }
+static inline void suspend_nvs_free(void) {}
+static inline void suspend_nvs_save(void) {}
+static inline void suspend_nvs_restore(void) {}
+#endif /* CONFIG_SUSPEND_NVS */
 
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);
diff -urN linux-2.6.35-rc3/include/linux/tracepoint.h linux-2.6.35-rc4/include/linux/tracepoint.h
--- linux-2.6.35-rc3/include/linux/tracepoint.h	2010-07-05 05:34:23.038806805 +0000
+++ linux-2.6.35-rc4/include/linux/tracepoint.h	2010-07-05 05:34:28.410868074 +0000
@@ -14,6 +14,7 @@
  * See the file COPYING for more details.
  */
 
+#include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/rcupdate.h>
 
diff -urN linux-2.6.35-rc3/include/net/snmp.h linux-2.6.35-rc4/include/net/snmp.h
--- linux-2.6.35-rc3/include/net/snmp.h	2010-07-05 05:34:23.054868537 +0000
+++ linux-2.6.35-rc4/include/net/snmp.h	2010-07-05 05:34:28.426868058 +0000
@@ -134,7 +134,7 @@
 #define SNMP_ADD_STATS_USER(mib, field, addend)	\
 			this_cpu_add(mib[1]->mibs[field], addend)
 #define SNMP_ADD_STATS(mib, field, addend)	\
-			this_cpu_add(mib[0]->mibs[field], addend)
+			this_cpu_add(mib[!in_softirq()]->mibs[field], addend)
 /*
  * Use "__typeof__(*mib[0]) *ptr" instead of "__typeof__(mib[0]) ptr"
  * to make @ptr a non-percpu pointer.
diff -urN linux-2.6.35-rc3/init/main.c linux-2.6.35-rc4/init/main.c
--- linux-2.6.35-rc3/init/main.c	2010-07-05 05:34:23.062868154 +0000
+++ linux-2.6.35-rc4/init/main.c	2010-07-05 05:34:28.434805501 +0000
@@ -125,7 +125,9 @@
 
 #ifdef CONFIG_SMP
 /* Setup configured maximum number of CPUs to activate */
-unsigned int __initdata setup_max_cpus = NR_CPUS;
+unsigned int setup_max_cpus = NR_CPUS;
+EXPORT_SYMBOL(setup_max_cpus);
+
 
 /*
  * Setup routine for controlling SMP activation
@@ -422,18 +424,26 @@
  * gcc-3.4 accidentally inlines this function, so use noinline.
  */
 
+static __initdata DECLARE_COMPLETION(kthreadd_done);
+
 static noinline void __init_refok rest_init(void)
 	__releases(kernel_lock)
 {
 	int pid;
 
 	rcu_scheduler_starting();
+	/*
+	 * We need to spawn init first so that it obtains pid 1, however
+	 * the init task will end up wanting to create kthreads, which, if
+	 * we schedule it before we create kthreadd, will OOPS.
+	 */
 	kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
 	numa_default_policy();
 	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
 	rcu_read_lock();
 	kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);
 	rcu_read_unlock();
+	complete(&kthreadd_done);
 	unlock_kernel();
 
 	/*
@@ -855,6 +865,10 @@
 
 static int __init kernel_init(void * unused)
 {
+	/*
+	 * Wait until kthreadd is all set-up.
+	 */
+	wait_for_completion(&kthreadd_done);
 	lock_kernel();
 
 	/*
diff -urN linux-2.6.35-rc3/kernel/futex.c linux-2.6.35-rc4/kernel/futex.c
--- linux-2.6.35-rc3/kernel/futex.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/kernel/futex.c	2010-07-05 05:34:28.443805684 +0000
@@ -429,20 +429,11 @@
 static struct task_struct * futex_find_get_task(pid_t pid)
 {
 	struct task_struct *p;
-	const struct cred *cred = current_cred(), *pcred;
 
 	rcu_read_lock();
 	p = find_task_by_vpid(pid);
-	if (!p) {
-		p = ERR_PTR(-ESRCH);
-	} else {
-		pcred = __task_cred(p);
-		if (cred->euid != pcred->euid &&
-		    cred->euid != pcred->uid)
-			p = ERR_PTR(-ESRCH);
-		else
-			get_task_struct(p);
-	}
+	if (p)
+		get_task_struct(p);
 
 	rcu_read_unlock();
 
@@ -564,8 +555,8 @@
 	if (!pid)
 		return -ESRCH;
 	p = futex_find_get_task(pid);
-	if (IS_ERR(p))
-		return PTR_ERR(p);
+	if (!p)
+		return -ESRCH;
 
 	/*
 	 * We need to look at the task state flags to figure out,
diff -urN linux-2.6.35-rc3/kernel/irq/manage.c linux-2.6.35-rc4/kernel/irq/manage.c
--- linux-2.6.35-rc3/kernel/irq/manage.c	2010-07-05 05:34:23.072817407 +0000
+++ linux-2.6.35-rc4/kernel/irq/manage.c	2010-07-05 05:34:28.444868092 +0000
@@ -456,6 +456,9 @@
 		/* note that IRQF_TRIGGER_MASK == IRQ_TYPE_SENSE_MASK */
 		desc->status &= ~(IRQ_LEVEL | IRQ_TYPE_SENSE_MASK);
 		desc->status |= flags;
+
+		if (chip != desc->chip)
+			irq_chip_set_defaults(desc->chip);
 	}
 
 	return ret;
diff -urN linux-2.6.35-rc3/kernel/kexec.c linux-2.6.35-rc4/kernel/kexec.c
--- linux-2.6.35-rc3/kernel/kexec.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/kernel/kexec.c	2010-07-05 05:34:28.444868092 +0000
@@ -1089,9 +1089,10 @@
 
 size_t crash_get_memory_size(void)
 {
-	size_t size;
+	size_t size = 0;
 	mutex_lock(&kexec_mutex);
-	size = crashk_res.end - crashk_res.start + 1;
+	if (crashk_res.end != crashk_res.start)
+		size = crashk_res.end - crashk_res.start + 1;
 	mutex_unlock(&kexec_mutex);
 	return size;
 }
@@ -1134,7 +1135,7 @@
 
 	free_reserved_phys_range(end, crashk_res.end);
 
-	if (start == end)
+	if ((start == end) && (crashk_res.parent != NULL))
 		release_resource(&crashk_res);
 	crashk_res.end = end - 1;
 
diff -urN linux-2.6.35-rc3/kernel/module.c linux-2.6.35-rc4/kernel/module.c
--- linux-2.6.35-rc3/kernel/module.c	2010-07-05 05:34:23.076868051 +0000
+++ linux-2.6.35-rc4/kernel/module.c	2010-07-05 05:34:28.447868028 +0000
@@ -2062,6 +2062,12 @@
 #endif
 }
 
+static void dynamic_debug_remove(struct _ddebug *debug)
+{
+	if (debug)
+		ddebug_remove_module(debug->modname);
+}
+
 static void *module_alloc_update_bounds(unsigned long size)
 {
 	void *ret = module_alloc(size);
@@ -2124,6 +2130,8 @@
 	void *ptr = NULL; /* Stops spurious gcc warning */
 	unsigned long symoffs, stroffs, *strmap;
 	void __percpu *percpu;
+	struct _ddebug *debug = NULL;
+	unsigned int num_debug = 0;
 
 	mm_segment_t old_fs;
 
@@ -2476,15 +2484,9 @@
 	kfree(strmap);
 	strmap = NULL;
 
-	if (!mod->taints) {
-		struct _ddebug *debug;
-		unsigned int num_debug;
-
+	if (!mod->taints)
 		debug = section_objs(hdr, sechdrs, secstrings, "__verbose",
 				     sizeof(*debug), &num_debug);
-		if (debug)
-			dynamic_debug_setup(debug, num_debug);
-	}
 
 	err = module_finalize(hdr, sechdrs, mod);
 	if (err < 0)
@@ -2526,10 +2528,13 @@
 		goto unlock;
 	}
 
+	if (debug)
+		dynamic_debug_setup(debug, num_debug);
+
 	/* Find duplicate symbols */
 	err = verify_export_symbols(mod);
 	if (err < 0)
-		goto unlock;
+		goto ddebug;
 
 	list_add_rcu(&mod->list, &modules);
 	mutex_unlock(&module_mutex);
@@ -2557,6 +2562,8 @@
 	mutex_lock(&module_mutex);
 	/* Unlink carefully: kallsyms could be walking list. */
 	list_del_rcu(&mod->list);
+ ddebug:
+	dynamic_debug_remove(debug);
  unlock:
 	mutex_unlock(&module_mutex);
 	synchronize_sched();
diff -urN linux-2.6.35-rc3/kernel/power/Kconfig linux-2.6.35-rc4/kernel/power/Kconfig
--- linux-2.6.35-rc3/kernel/power/Kconfig	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/kernel/power/Kconfig	2010-07-05 05:34:28.451868045 +0000
@@ -99,9 +99,13 @@
 	depends on PM_ADVANCED_DEBUG
 	default n
 
+config SUSPEND_NVS
+       bool
+
 config SUSPEND
 	bool "Suspend to RAM and standby"
 	depends on PM && ARCH_SUSPEND_POSSIBLE
+	select SUSPEND_NVS if HAS_IOMEM
 	default y
 	---help---
 	  Allow the system to enter sleep states in which main memory is
@@ -130,13 +134,10 @@
 
 	  Turning OFF this setting is NOT recommended! If in doubt, say Y.
 
-config HIBERNATION_NVS
-	bool
-
 config HIBERNATION
 	bool "Hibernation (aka 'suspend to disk')"
 	depends on PM && SWAP && ARCH_HIBERNATION_POSSIBLE
-	select HIBERNATION_NVS if HAS_IOMEM
+	select SUSPEND_NVS if HAS_IOMEM
 	---help---
 	  Enable the suspend to disk (STD) functionality, which is usually
 	  called "hibernation" in user interfaces.  STD checkpoints the
diff -urN linux-2.6.35-rc3/kernel/power/Makefile linux-2.6.35-rc4/kernel/power/Makefile
--- linux-2.6.35-rc3/kernel/power/Makefile	2010-07-05 05:34:23.080805486 +0000
+++ linux-2.6.35-rc4/kernel/power/Makefile	2010-07-05 05:34:28.451868045 +0000
@@ -10,6 +10,6 @@
 obj-$(CONFIG_PM_TEST_SUSPEND)	+= suspend_test.o
 obj-$(CONFIG_HIBERNATION)	+= hibernate.o snapshot.o swap.o user.o \
 				   block_io.o
-obj-$(CONFIG_HIBERNATION_NVS)	+= hibernate_nvs.o
+obj-$(CONFIG_SUSPEND_NVS)	+= nvs.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
diff -urN linux-2.6.35-rc3/kernel/power/hibernate_nvs.c linux-2.6.35-rc4/kernel/power/hibernate_nvs.c
--- linux-2.6.35-rc3/kernel/power/hibernate_nvs.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/kernel/power/hibernate_nvs.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,136 +0,0 @@
-/*
- * linux/kernel/power/hibernate_nvs.c - Routines for handling NVS memory
- *
- * Copyright (C) 2008,2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
- *
- * This file is released under the GPLv2.
- */
-
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/suspend.h>
-
-/*
- * Platforms, like ACPI, may want us to save some memory used by them during
- * hibernation and to restore the contents of this memory during the subsequent
- * resume.  The code below implements a mechanism allowing us to do that.
- */
-
-struct nvs_page {
-	unsigned long phys_start;
-	unsigned int size;
-	void *kaddr;
-	void *data;
-	struct list_head node;
-};
-
-static LIST_HEAD(nvs_list);
-
-/**
- *	hibernate_nvs_register - register platform NVS memory region to save
- *	@start - physical address of the region
- *	@size - size of the region
- *
- *	The NVS region need not be page-aligned (both ends) and we arrange
- *	things so that the data from page-aligned addresses in this region will
- *	be copied into separate RAM pages.
- */
-int hibernate_nvs_register(unsigned long start, unsigned long size)
-{
-	struct nvs_page *entry, *next;
-
-	while (size > 0) {
-		unsigned int nr_bytes;
-
-		entry = kzalloc(sizeof(struct nvs_page), GFP_KERNEL);
-		if (!entry)
-			goto Error;
-
-		list_add_tail(&entry->node, &nvs_list);
-		entry->phys_start = start;
-		nr_bytes = PAGE_SIZE - (start & ~PAGE_MASK);
-		entry->size = (size < nr_bytes) ? size : nr_bytes;
-
-		start += entry->size;
-		size -= entry->size;
-	}
-	return 0;
-
- Error:
-	list_for_each_entry_safe(entry, next, &nvs_list, node) {
-		list_del(&entry->node);
-		kfree(entry);
-	}
-	return -ENOMEM;
-}
-
-/**
- *	hibernate_nvs_free - free data pages allocated for saving NVS regions
- */
-void hibernate_nvs_free(void)
-{
-	struct nvs_page *entry;
-
-	list_for_each_entry(entry, &nvs_list, node)
-		if (entry->data) {
-			free_page((unsigned long)entry->data);
-			entry->data = NULL;
-			if (entry->kaddr) {
-				iounmap(entry->kaddr);
-				entry->kaddr = NULL;
-			}
-		}
-}
-
-/**
- *	hibernate_nvs_alloc - allocate memory necessary for saving NVS regions
- */
-int hibernate_nvs_alloc(void)
-{
-	struct nvs_page *entry;
-
-	list_for_each_entry(entry, &nvs_list, node) {
-		entry->data = (void *)__get_free_page(GFP_KERNEL);
-		if (!entry->data) {
-			hibernate_nvs_free();
-			return -ENOMEM;
-		}
-	}
-	return 0;
-}
-
-/**
- *	hibernate_nvs_save - save NVS memory regions
- */
-void hibernate_nvs_save(void)
-{
-	struct nvs_page *entry;
-
-	printk(KERN_INFO "PM: Saving platform NVS memory\n");
-
-	list_for_each_entry(entry, &nvs_list, node)
-		if (entry->data) {
-			entry->kaddr = ioremap(entry->phys_start, entry->size);
-			memcpy(entry->data, entry->kaddr, entry->size);
-		}
-}
-
-/**
- *	hibernate_nvs_restore - restore NVS memory regions
- *
- *	This function is going to be called with interrupts disabled, so it
- *	cannot iounmap the virtual addresses used to access the NVS region.
- */
-void hibernate_nvs_restore(void)
-{
-	struct nvs_page *entry;
-
-	printk(KERN_INFO "PM: Restoring platform NVS memory\n");
-
-	list_for_each_entry(entry, &nvs_list, node)
-		if (entry->data)
-			memcpy(entry->kaddr, entry->data, entry->size);
-}
diff -urN linux-2.6.35-rc3/kernel/power/nvs.c linux-2.6.35-rc4/kernel/power/nvs.c
--- linux-2.6.35-rc3/kernel/power/nvs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.35-rc4/kernel/power/nvs.c	2010-07-05 05:34:28.451868045 +0000
@@ -0,0 +1,136 @@
+/*
+ * linux/kernel/power/hibernate_nvs.c - Routines for handling NVS memory
+ *
+ * Copyright (C) 2008,2009 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
+ *
+ * This file is released under the GPLv2.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/suspend.h>
+
+/*
+ * Platforms, like ACPI, may want us to save some memory used by them during
+ * suspend and to restore the contents of this memory during the subsequent
+ * resume.  The code below implements a mechanism allowing us to do that.
+ */
+
+struct nvs_page {
+	unsigned long phys_start;
+	unsigned int size;
+	void *kaddr;
+	void *data;
+	struct list_head node;
+};
+
+static LIST_HEAD(nvs_list);
+
+/**
+ *	suspend_nvs_register - register platform NVS memory region to save
+ *	@start - physical address of the region
+ *	@size - size of the region
+ *
+ *	The NVS region need not be page-aligned (both ends) and we arrange
+ *	things so that the data from page-aligned addresses in this region will
+ *	be copied into separate RAM pages.
+ */
+int suspend_nvs_register(unsigned long start, unsigned long size)
+{
+	struct nvs_page *entry, *next;
+
+	while (size > 0) {
+		unsigned int nr_bytes;
+
+		entry = kzalloc(sizeof(struct nvs_page), GFP_KERNEL);
+		if (!entry)
+			goto Error;
+
+		list_add_tail(&entry->node, &nvs_list);
+		entry->phys_start = start;
+		nr_bytes = PAGE_SIZE - (start & ~PAGE_MASK);
+		entry->size = (size < nr_bytes) ? size : nr_bytes;
+
+		start += entry->size;
+		size -= entry->size;
+	}
+	return 0;
+
+ Error:
+	list_for_each_entry_safe(entry, next, &nvs_list, node) {
+		list_del(&entry->node);
+		kfree(entry);
+	}
+	return -ENOMEM;
+}
+
+/**
+ *	suspend_nvs_free - free data pages allocated for saving NVS regions
+ */
+void suspend_nvs_free(void)
+{
+	struct nvs_page *entry;
+
+	list_for_each_entry(entry, &nvs_list, node)
+		if (entry->data) {
+			free_page((unsigned long)entry->data);
+			entry->data = NULL;
+			if (entry->kaddr) {
+				iounmap(entry->kaddr);
+				entry->kaddr = NULL;
+			}
+		}
+}
+
+/**
+ *	suspend_nvs_alloc - allocate memory necessary for saving NVS regions
+ */
+int suspend_nvs_alloc(void)
+{
+	struct nvs_page *entry;
+
+	list_for_each_entry(entry, &nvs_list, node) {
+		entry->data = (void *)__get_free_page(GFP_KERNEL);
+		if (!entry->data) {
+			suspend_nvs_free();
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+/**
+ *	suspend_nvs_save - save NVS memory regions
+ */
+void suspend_nvs_save(void)
+{
+	struct nvs_page *entry;
+
+	printk(KERN_INFO "PM: Saving platform NVS memory\n");
+
+	list_for_each_entry(entry, &nvs_list, node)
+		if (entry->data) {
+			entry->kaddr = ioremap(entry->phys_start, entry->size);
+			memcpy(entry->data, entry->kaddr, entry->size);
+		}
+}
+
+/**
+ *	suspend_nvs_restore - restore NVS memory regions
+ *
+ *	This function is going to be called with interrupts disabled, so it
+ *	cannot iounmap the virtual addresses used to access the NVS region.
+ */
+void suspend_nvs_restore(void)
+{
+	struct nvs_page *entry;
+
+	printk(KERN_INFO "PM: Restoring platform NVS memory\n");
+
+	list_for_each_entry(entry, &nvs_list, node)
+		if (entry->data)
+			memcpy(entry->kaddr, entry->data, entry->size);
+}
diff -urN linux-2.6.35-rc3/kernel/power/suspend.c linux-2.6.35-rc4/kernel/power/suspend.c
--- linux-2.6.35-rc3/kernel/power/suspend.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/kernel/power/suspend.c	2010-07-05 05:34:28.452806408 +0000
@@ -16,6 +16,12 @@
 #include <linux/cpu.h>
 #include <linux/syscalls.h>
 #include <linux/gfp.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/suspend.h>
 
 #include "power.h"
 
diff -urN linux-2.6.35-rc3/kernel/sched.c linux-2.6.35-rc4/kernel/sched.c
--- linux-2.6.35-rc3/kernel/sched.c	2010-07-05 05:34:23.085868010 +0000
+++ linux-2.6.35-rc4/kernel/sched.c	2010-07-05 05:34:28.457868089 +0000
@@ -306,52 +306,6 @@
  */
 struct task_group init_task_group;
 
-/* return group to which a task belongs */
-static inline struct task_group *task_group(struct task_struct *p)
-{
-	struct task_group *tg;
-
-#ifdef CONFIG_CGROUP_SCHED
-	tg = container_of(task_subsys_state(p, cpu_cgroup_subsys_id),
-				struct task_group, css);
-#else
-	tg = &init_task_group;
-#endif
-	return tg;
-}
-
-/* Change a task's cfs_rq and parent entity if it moves across CPUs/groups */
-static inline void set_task_rq(struct task_struct *p, unsigned int cpu)
-{
-	/*
-	 * Strictly speaking this rcu_read_lock() is not needed since the
-	 * task_group is tied to the cgroup, which in turn can never go away
-	 * as long as there are tasks attached to it.
-	 *
-	 * However since task_group() uses task_subsys_state() which is an
-	 * rcu_dereference() user, this quiets CONFIG_PROVE_RCU.
-	 */
-	rcu_read_lock();
-#ifdef CONFIG_FAIR_GROUP_SCHED
-	p->se.cfs_rq = task_group(p)->cfs_rq[cpu];
-	p->se.parent = task_group(p)->se[cpu];
-#endif
-
-#ifdef CONFIG_RT_GROUP_SCHED
-	p->rt.rt_rq  = task_group(p)->rt_rq[cpu];
-	p->rt.parent = task_group(p)->rt_se[cpu];
-#endif
-	rcu_read_unlock();
-}
-
-#else
-
-static inline void set_task_rq(struct task_struct *p, unsigned int cpu) { }
-static inline struct task_group *task_group(struct task_struct *p)
-{
-	return NULL;
-}
-
 #endif	/* CONFIG_CGROUP_SCHED */
 
 /* CFS-related fields in a runqueue */
@@ -644,6 +598,49 @@
 #define cpu_curr(cpu)		(cpu_rq(cpu)->curr)
 #define raw_rq()		(&__raw_get_cpu_var(runqueues))
 
+#ifdef CONFIG_CGROUP_SCHED
+
+/*
+ * Return the group to which this tasks belongs.
+ *
+ * We use task_subsys_state_check() and extend the RCU verification
+ * with lockdep_is_held(&task_rq(p)->lock) because cpu_cgroup_attach()
+ * holds that lock for each task it moves into the cgroup. Therefore
+ * by holding that lock, we pin the task to the current cgroup.
+ */
+static inline struct task_group *task_group(struct task_struct *p)
+{
+	struct cgroup_subsys_state *css;
+
+	css = task_subsys_state_check(p, cpu_cgroup_subsys_id,
+			lockdep_is_held(&task_rq(p)->lock));
+	return container_of(css, struct task_group, css);
+}
+
+/* Change a task's cfs_rq and parent entity if it moves across CPUs/groups */
+static inline void set_task_rq(struct task_struct *p, unsigned int cpu)
+{
+#ifdef CONFIG_FAIR_GROUP_SCHED
+	p->se.cfs_rq = task_group(p)->cfs_rq[cpu];
+	p->se.parent = task_group(p)->se[cpu];
+#endif
+
+#ifdef CONFIG_RT_GROUP_SCHED
+	p->rt.rt_rq  = task_group(p)->rt_rq[cpu];
+	p->rt.parent = task_group(p)->rt_se[cpu];
+#endif
+}
+
+#else /* CONFIG_CGROUP_SCHED */
+
+static inline void set_task_rq(struct task_struct *p, unsigned int cpu) { }
+static inline struct task_group *task_group(struct task_struct *p)
+{
+	return NULL;
+}
+
+#endif /* CONFIG_CGROUP_SCHED */
+
 inline void update_rq_clock(struct rq *rq)
 {
 	if (!rq->skip_clock_update)
@@ -1257,6 +1254,12 @@
 	s64 period = sched_avg_period();
 
 	while ((s64)(rq->clock - rq->age_stamp) > period) {
+		/*
+		 * Inline assembly required to prevent the compiler
+		 * optimising this loop into a divmod call.
+		 * See __iter_div_u64_rem() for another example of this.
+		 */
+		asm("" : "+rm" (rq->age_stamp));
 		rq->age_stamp += period;
 		rq->rt_avg /= 2;
 	}
@@ -1660,9 +1663,6 @@
 
 static void update_h_load(long cpu)
 {
-	if (root_task_group_empty())
-		return;
-
 	walk_tg_tree(tg_load_down, tg_nop, (void *)cpu);
 }
 
@@ -2494,7 +2494,16 @@
 	if (p->sched_class->task_fork)
 		p->sched_class->task_fork(p);
 
+	/*
+	 * The child is not yet in the pid-hash so no cgroup attach races,
+	 * and the cgroup is pinned to this child due to cgroup_fork()
+	 * is ran before sched_fork().
+	 *
+	 * Silence PROVE_RCU.
+	 */
+	rcu_read_lock();
 	set_task_cpu(p, cpu);
+	rcu_read_unlock();
 
 #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
 	if (likely(sched_info_on()))
@@ -2864,9 +2873,9 @@
 	return sum;
 }
 
-unsigned long nr_iowait_cpu(void)
+unsigned long nr_iowait_cpu(int cpu)
 {
-	struct rq *this = this_rq();
+	struct rq *this = cpu_rq(cpu);
 	return atomic_read(&this->nr_iowait);
 }
 
@@ -4465,16 +4474,6 @@
 	}
 
 	if (user) {
-#ifdef CONFIG_RT_GROUP_SCHED
-		/*
-		 * Do not allow realtime tasks into groups that have no runtime
-		 * assigned.
-		 */
-		if (rt_bandwidth_enabled() && rt_policy(policy) &&
-				task_group(p)->rt_bandwidth.rt_runtime == 0)
-			return -EPERM;
-#endif
-
 		retval = security_task_setscheduler(p, policy, param);
 		if (retval)
 			return retval;
@@ -4490,6 +4489,22 @@
 	 * runqueue lock must be held.
 	 */
 	rq = __task_rq_lock(p);
+
+#ifdef CONFIG_RT_GROUP_SCHED
+	if (user) {
+		/*
+		 * Do not allow realtime tasks into groups that have no runtime
+		 * assigned.
+		 */
+		if (rt_bandwidth_enabled() && rt_policy(policy) &&
+				task_group(p)->rt_bandwidth.rt_runtime == 0) {
+			__task_rq_unlock(rq);
+			raw_spin_unlock_irqrestore(&p->pi_lock, flags);
+			return -EPERM;
+		}
+	}
+#endif
+
 	/* recheck policy now with rq lock held */
 	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {
 		policy = oldpolicy = -1;
diff -urN linux-2.6.35-rc3/kernel/sched_fair.c linux-2.6.35-rc4/kernel/sched_fair.c
--- linux-2.6.35-rc3/kernel/sched_fair.c	2010-07-05 05:34:23.087868177 +0000
+++ linux-2.6.35-rc4/kernel/sched_fair.c	2010-07-05 05:34:28.458868043 +0000
@@ -1240,6 +1240,7 @@
 	 * effect of the currently running task from the load
 	 * of the current CPU:
 	 */
+	rcu_read_lock();
 	if (sync) {
 		tg = task_group(current);
 		weight = current->se.load.weight;
@@ -1275,6 +1276,7 @@
 		balanced = this_eff_load <= prev_eff_load;
 	} else
 		balanced = true;
+	rcu_read_unlock();
 
 	/*
 	 * If the currently running task will sleep within
diff -urN linux-2.6.35-rc3/kernel/time/tick-sched.c linux-2.6.35-rc4/kernel/time/tick-sched.c
--- linux-2.6.35-rc3/kernel/time/tick-sched.c	2010-07-05 05:34:23.090805546 +0000
+++ linux-2.6.35-rc4/kernel/time/tick-sched.c	2010-07-05 05:34:28.462806579 +0000
@@ -154,14 +154,14 @@
  * Updates the per cpu time idle statistics counters
  */
 static void
-update_ts_time_stats(struct tick_sched *ts, ktime_t now, u64 *last_update_time)
+update_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)
 {
 	ktime_t delta;
 
 	if (ts->idle_active) {
 		delta = ktime_sub(now, ts->idle_entrytime);
 		ts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);
-		if (nr_iowait_cpu() > 0)
+		if (nr_iowait_cpu(cpu) > 0)
 			ts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);
 		ts->idle_entrytime = now;
 	}
@@ -175,19 +175,19 @@
 {
 	struct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);
 
-	update_ts_time_stats(ts, now, NULL);
+	update_ts_time_stats(cpu, ts, now, NULL);
 	ts->idle_active = 0;
 
 	sched_clock_idle_wakeup_event(0);
 }
 
-static ktime_t tick_nohz_start_idle(struct tick_sched *ts)
+static ktime_t tick_nohz_start_idle(int cpu, struct tick_sched *ts)
 {
 	ktime_t now;
 
 	now = ktime_get();
 
-	update_ts_time_stats(ts, now, NULL);
+	update_ts_time_stats(cpu, ts, now, NULL);
 
 	ts->idle_entrytime = now;
 	ts->idle_active = 1;
@@ -216,7 +216,7 @@
 	if (!tick_nohz_enabled)
 		return -1;
 
-	update_ts_time_stats(ts, ktime_get(), last_update_time);
+	update_ts_time_stats(cpu, ts, ktime_get(), last_update_time);
 
 	return ktime_to_us(ts->idle_sleeptime);
 }
@@ -242,7 +242,7 @@
 	if (!tick_nohz_enabled)
 		return -1;
 
-	update_ts_time_stats(ts, ktime_get(), last_update_time);
+	update_ts_time_stats(cpu, ts, ktime_get(), last_update_time);
 
 	return ktime_to_us(ts->iowait_sleeptime);
 }
@@ -284,7 +284,7 @@
 	 */
 	ts->inidle = 1;
 
-	now = tick_nohz_start_idle(ts);
+	now = tick_nohz_start_idle(cpu, ts);
 
 	/*
 	 * If this cpu is offline and it is the one which updates
@@ -315,9 +315,6 @@
 		goto end;
 	}
 
-	if (nohz_ratelimit(cpu))
-		goto end;
-
 	ts->idle_calls++;
 	/* Read jiffies and the time when jiffies were updated last */
 	do {
@@ -328,7 +325,7 @@
 	} while (read_seqretry(&xtime_lock, seq));
 
 	if (rcu_needs_cpu(cpu) || printk_needs_cpu(cpu) ||
-	    arch_needs_cpu(cpu)) {
+	    arch_needs_cpu(cpu) || nohz_ratelimit(cpu)) {
 		next_jiffies = last_jiffies + 1;
 		delta_jiffies = 1;
 	} else {
diff -urN linux-2.6.35-rc3/kernel/trace/trace_event_perf.c linux-2.6.35-rc4/kernel/trace/trace_event_perf.c
--- linux-2.6.35-rc3/kernel/trace/trace_event_perf.c	2010-07-05 05:34:23.095867959 +0000
+++ linux-2.6.35-rc4/kernel/trace/trace_event_perf.c	2010-07-05 05:34:28.466868050 +0000
@@ -96,7 +96,9 @@
 	mutex_lock(&event_mutex);
 	list_for_each_entry(tp_event, &ftrace_events, list) {
 		if (tp_event->event.type == event_id &&
-		    tp_event->class && tp_event->class->perf_probe &&
+		    tp_event->class &&
+		    (tp_event->class->perf_probe ||
+		     tp_event->class->reg) &&
 		    try_module_get(tp_event->mod)) {
 			ret = perf_trace_event_init(tp_event, p_event);
 			break;
diff -urN linux-2.6.35-rc3/lib/dynamic_debug.c linux-2.6.35-rc4/lib/dynamic_debug.c
--- linux-2.6.35-rc3/lib/dynamic_debug.c	2010-07-05 05:34:23.101868138 +0000
+++ linux-2.6.35-rc4/lib/dynamic_debug.c	2010-07-05 05:34:28.473805595 +0000
@@ -692,7 +692,7 @@
  * Called in response to a module being unloaded.  Removes
  * any ddebug_table's which point at the module.
  */
-int ddebug_remove_module(char *mod_name)
+int ddebug_remove_module(const char *mod_name)
 {
 	struct ddebug_table *dt, *nextdt;
 	int ret = -ENOENT;
diff -urN linux-2.6.35-rc3/lib/genalloc.c linux-2.6.35-rc4/lib/genalloc.c
--- linux-2.6.35-rc3/lib/genalloc.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/lib/genalloc.c	2010-07-05 05:34:28.473805595 +0000
@@ -128,7 +128,6 @@
 		chunk = list_entry(_chunk, struct gen_pool_chunk, next_chunk);
 
 		end_bit = (chunk->end_addr - chunk->start_addr) >> order;
-		end_bit -= nbits + 1;
 
 		spin_lock_irqsave(&chunk->lock, flags);
 		start_bit = bitmap_find_next_zero_area(chunk->bits, end_bit, 0,
diff -urN linux-2.6.35-rc3/lib/idr.c linux-2.6.35-rc4/lib/idr.c
--- linux-2.6.35-rc3/lib/idr.c	2010-07-05 05:34:23.102869553 +0000
+++ linux-2.6.35-rc4/lib/idr.c	2010-07-05 05:34:28.474805553 +0000
@@ -602,7 +602,7 @@
 	/* find first ent */
 	n = idp->layers * IDR_BITS;
 	max = 1 << n;
-	p = rcu_dereference(idp->top);
+	p = rcu_dereference_raw(idp->top);
 	if (!p)
 		return NULL;
 
@@ -610,7 +610,7 @@
 		while (n > 0 && p) {
 			n -= IDR_BITS;
 			*paa++ = p;
-			p = rcu_dereference(p->ary[(id >> n) & IDR_MASK]);
+			p = rcu_dereference_raw(p->ary[(id >> n) & IDR_MASK]);
 		}
 
 		if (p) {
diff -urN linux-2.6.35-rc3/mm/memcontrol.c linux-2.6.35-rc4/mm/memcontrol.c
--- linux-2.6.35-rc3/mm/memcontrol.c	2010-07-05 05:34:23.106868160 +0000
+++ linux-2.6.35-rc4/mm/memcontrol.c	2010-07-05 05:34:28.478805507 +0000
@@ -1370,7 +1370,7 @@
 
 static void memcg_oom_recover(struct mem_cgroup *mem)
 {
-	if (mem->oom_kill_disable && atomic_read(&mem->oom_lock))
+	if (atomic_read(&mem->oom_lock))
 		memcg_wakeup_oom(mem);
 }
 
@@ -3781,6 +3781,8 @@
 		return -EINVAL;
 	}
 	mem->oom_kill_disable = val;
+	if (!val)
+		memcg_oom_recover(mem);
 	cgroup_unlock();
 	return 0;
 }
diff -urN linux-2.6.35-rc3/mm/mempolicy.c linux-2.6.35-rc4/mm/mempolicy.c
--- linux-2.6.35-rc3/mm/mempolicy.c	2010-07-05 05:34:23.108806778 +0000
+++ linux-2.6.35-rc4/mm/mempolicy.c	2010-07-05 05:34:28.480868266 +0000
@@ -2094,7 +2094,7 @@
 		NODEMASK_SCRATCH(scratch);
 
 		if (!scratch)
-			return;
+			goto put_mpol;
 		/* contextualize the tmpfs mount point mempolicy */
 		new = mpol_new(mpol->mode, mpol->flags, &mpol->w.user_nodemask);
 		if (IS_ERR(new))
@@ -2103,19 +2103,20 @@
 		task_lock(current);
 		ret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);
 		task_unlock(current);
-		mpol_put(mpol);	/* drop our ref on sb mpol */
 		if (ret)
-			goto put_free;
+			goto put_new;
 
 		/* Create pseudo-vma that contains just the policy */
 		memset(&pvma, 0, sizeof(struct vm_area_struct));
 		pvma.vm_end = TASK_SIZE;	/* policy covers entire file */
 		mpol_set_shared_policy(sp, &pvma, new); /* adds ref */
 
-put_free:
+put_new:
 		mpol_put(new);			/* drop initial ref */
 free_scratch:
 		NODEMASK_SCRATCH_FREE(scratch);
+put_mpol:
+		mpol_put(mpol);	/* drop our incoming ref on sb mpol */
 	}
 }
 
diff -urN linux-2.6.35-rc3/mm/page-writeback.c linux-2.6.35-rc4/mm/page-writeback.c
--- linux-2.6.35-rc3/mm/page-writeback.c	2010-07-05 05:34:23.109805454 +0000
+++ linux-2.6.35-rc4/mm/page-writeback.c	2010-07-05 05:34:28.481868070 +0000
@@ -597,7 +597,7 @@
 	    (!laptop_mode && ((global_page_state(NR_FILE_DIRTY)
 			       + global_page_state(NR_UNSTABLE_NFS))
 					  > background_thresh)))
-		bdi_start_writeback(bdi, NULL, 0);
+		bdi_start_background_writeback(bdi);
 }
 
 void set_page_dirty_balance(struct page *page, int page_mkwrite)
@@ -705,9 +705,8 @@
 	 * We want to write everything out, not just down to the dirty
 	 * threshold
 	 */
-
 	if (bdi_has_dirty_io(&q->backing_dev_info))
-		bdi_start_writeback(&q->backing_dev_info, NULL, nr_pages);
+		bdi_start_writeback(&q->backing_dev_info, nr_pages);
 }
 
 /*
diff -urN linux-2.6.35-rc3/mm/percpu.c linux-2.6.35-rc4/mm/percpu.c
--- linux-2.6.35-rc3/mm/percpu.c	2010-07-05 05:34:23.111868075 +0000
+++ linux-2.6.35-rc4/mm/percpu.c	2010-07-05 05:34:28.483805506 +0000
@@ -229,8 +229,8 @@
 	return pcpu_unit_map[cpu] * pcpu_unit_pages + page_idx;
 }
 
-static unsigned long __maybe_unused pcpu_chunk_addr(struct pcpu_chunk *chunk,
-						unsigned int cpu, int page_idx)
+static unsigned long pcpu_chunk_addr(struct pcpu_chunk *chunk,
+				     unsigned int cpu, int page_idx)
 {
 	return (unsigned long)chunk->base_addr + pcpu_unit_offsets[cpu] +
 		(page_idx << PAGE_SHIFT);
@@ -978,7 +978,32 @@
  */
 phys_addr_t per_cpu_ptr_to_phys(void *addr)
 {
-	if (pcpu_addr_in_first_chunk(addr)) {
+	void __percpu *base = __addr_to_pcpu_ptr(pcpu_base_addr);
+	bool in_first_chunk = false;
+	unsigned long first_start, first_end;
+	unsigned int cpu;
+
+	/*
+	 * The following test on first_start/end isn't strictly
+	 * necessary but will speed up lookups of addresses which
+	 * aren't in the first chunk.
+	 */
+	first_start = pcpu_chunk_addr(pcpu_first_chunk, pcpu_first_unit_cpu, 0);
+	first_end = pcpu_chunk_addr(pcpu_first_chunk, pcpu_last_unit_cpu,
+				    pcpu_unit_pages);
+	if ((unsigned long)addr >= first_start &&
+	    (unsigned long)addr < first_end) {
+		for_each_possible_cpu(cpu) {
+			void *start = per_cpu_ptr(base, cpu);
+
+			if (addr >= start && addr < start + pcpu_unit_size) {
+				in_first_chunk = true;
+				break;
+			}
+		}
+	}
+
+	if (in_first_chunk) {
 		if ((unsigned long)addr < VMALLOC_START ||
 		    (unsigned long)addr >= VMALLOC_END)
 			return __pa(addr);
@@ -1086,7 +1111,7 @@
 	static int group_map[NR_CPUS] __initdata;
 	static int group_cnt[NR_CPUS] __initdata;
 	const size_t static_size = __per_cpu_end - __per_cpu_start;
-	int group_cnt_max = 0, nr_groups = 1, nr_units = 0;
+	int nr_groups = 1, nr_units = 0;
 	size_t size_sum, min_unit_size, alloc_size;
 	int upa, max_upa, uninitialized_var(best_upa);	/* units_per_alloc */
 	int last_allocs, group, unit;
@@ -1096,7 +1121,7 @@
 
 	/* this function may be called multiple times */
 	memset(group_map, 0, sizeof(group_map));
-	memset(group_cnt, 0, sizeof(group_map));
+	memset(group_cnt, 0, sizeof(group_cnt));
 
 	/*
 	 * Determine min_unit_size, alloc_size and max_upa such that
@@ -1130,7 +1155,6 @@
 		}
 		group_map[cpu] = group;
 		group_cnt[group]++;
-		group_cnt_max = max(group_cnt_max, group_cnt[group]);
 	}
 
 	/*
diff -urN linux-2.6.35-rc3/net/bluetooth/bnep/netdev.c linux-2.6.35-rc4/net/bluetooth/bnep/netdev.c
--- linux-2.6.35-rc3/net/bluetooth/bnep/netdev.c	2010-07-05 05:34:23.120868175 +0000
+++ linux-2.6.35-rc4/net/bluetooth/bnep/netdev.c	2010-07-05 05:34:28.491868089 +0000
@@ -104,6 +104,8 @@
 				break;
 			memcpy(__skb_put(skb, ETH_ALEN), ha->addr, ETH_ALEN);
 			memcpy(__skb_put(skb, ETH_ALEN), ha->addr, ETH_ALEN);
+
+			i++;
 		}
 		r->len = htons(skb->len - len);
 	}
diff -urN linux-2.6.35-rc3/net/bridge/br_fdb.c linux-2.6.35-rc4/net/bridge/br_fdb.c
--- linux-2.6.35-rc3/net/bridge/br_fdb.c	2010-07-05 05:34:23.124868054 +0000
+++ linux-2.6.35-rc4/net/bridge/br_fdb.c	2010-07-05 05:34:28.495868022 +0000
@@ -128,7 +128,7 @@
 {
 	struct net_bridge *br = (struct net_bridge *)_data;
 	unsigned long delay = hold_time(br);
-	unsigned long next_timer = jiffies + br->forward_delay;
+	unsigned long next_timer = jiffies + br->ageing_time;
 	int i;
 
 	spin_lock_bh(&br->hash_lock);
@@ -149,9 +149,7 @@
 	}
 	spin_unlock_bh(&br->hash_lock);
 
-	/* Add HZ/4 to ensure we round the jiffies upwards to be after the next
-	 * timer, otherwise we might round down and will have no-op run. */
-	mod_timer(&br->gc_timer, round_jiffies(next_timer + HZ/4));
+	mod_timer(&br->gc_timer, round_jiffies_up(next_timer));
 }
 
 /* Completely flush all dynamic entries in forwarding database.*/
diff -urN linux-2.6.35-rc3/net/bridge/br_forward.c linux-2.6.35-rc4/net/bridge/br_forward.c
--- linux-2.6.35-rc3/net/bridge/br_forward.c	2010-07-05 05:34:23.124868054 +0000
+++ linux-2.6.35-rc4/net/bridge/br_forward.c	2010-07-05 05:34:28.495868022 +0000
@@ -140,10 +140,10 @@
 			 void (*__packet_hook)(const struct net_bridge_port *p,
 					       struct sk_buff *skb))
 {
+	struct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;
+
 	skb = skb_clone(skb, GFP_ATOMIC);
 	if (!skb) {
-		struct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;
-
 		dev->stats.tx_dropped++;
 		return -ENOMEM;
 	}
diff -urN linux-2.6.35-rc3/net/core/skbuff.c linux-2.6.35-rc4/net/core/skbuff.c
--- linux-2.6.35-rc3/net/core/skbuff.c	2010-07-05 05:34:23.139805522 +0000
+++ linux-2.6.35-rc4/net/core/skbuff.c	2010-07-05 05:34:28.511868051 +0000
@@ -532,6 +532,7 @@
 	new->ip_summed		= old->ip_summed;
 	skb_copy_queue_mapping(new, old);
 	new->priority		= old->priority;
+	new->deliver_no_wcard	= old->deliver_no_wcard;
 #if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
 	new->ipvs_property	= old->ipvs_property;
 #endif
@@ -569,7 +570,6 @@
 	C(len);
 	C(data_len);
 	C(mac_len);
-	C(rxhash);
 	n->hdr_len = skb->nohdr ? skb_headroom(skb) : skb->hdr_len;
 	n->cloned = 1;
 	n->nohdr = 0;
diff -urN linux-2.6.35-rc3/net/ipv4/ip_output.c linux-2.6.35-rc4/net/ipv4/ip_output.c
--- linux-2.6.35-rc3/net/ipv4/ip_output.c	2010-07-05 05:34:23.147805715 +0000
+++ linux-2.6.35-rc4/net/ipv4/ip_output.c	2010-07-05 05:34:28.518868058 +0000
@@ -873,8 +873,10 @@
 	    !exthdrlen)
 		csummode = CHECKSUM_PARTIAL;
 
+	skb = skb_peek_tail(&sk->sk_write_queue);
+
 	inet->cork.length += length;
-	if (((length> mtu) || !skb_queue_empty(&sk->sk_write_queue)) &&
+	if (((length > mtu) || (skb && skb_is_gso(skb))) &&
 	    (sk->sk_protocol == IPPROTO_UDP) &&
 	    (rt->u.dst.dev->features & NETIF_F_UFO)) {
 		err = ip_ufo_append_data(sk, getfrag, from, length, hh_len,
@@ -892,7 +894,7 @@
 	 * adding appropriate IP header.
 	 */
 
-	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)
+	if (!skb)
 		goto alloc_new_skb;
 
 	while (length > 0) {
@@ -1121,7 +1123,8 @@
 		return -EINVAL;
 
 	inet->cork.length += size;
-	if ((sk->sk_protocol == IPPROTO_UDP) &&
+	if ((size + skb->len > mtu) &&
+	    (sk->sk_protocol == IPPROTO_UDP) &&
 	    (rt->u.dst.dev->features & NETIF_F_UFO)) {
 		skb_shinfo(skb)->gso_size = mtu - fragheaderlen;
 		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
diff -urN linux-2.6.35-rc3/net/ipv6/ndisc.c linux-2.6.35-rc4/net/ipv6/ndisc.c
--- linux-2.6.35-rc3/net/ipv6/ndisc.c	2010-07-05 05:34:23.164868013 +0000
+++ linux-2.6.35-rc4/net/ipv6/ndisc.c	2010-07-05 05:34:28.534868045 +0000
@@ -586,6 +586,7 @@
 		src_addr = solicited_addr;
 		if (ifp->flags & IFA_F_OPTIMISTIC)
 			override = 0;
+		inc_opt |= ifp->idev->cnf.force_tllao;
 		in6_ifa_put(ifp);
 	} else {
 		if (ipv6_dev_get_saddr(dev_net(dev), dev, daddr,
@@ -599,7 +600,6 @@
 	icmp6h.icmp6_solicited = solicited;
 	icmp6h.icmp6_override = override;
 
-	inc_opt |= ifp->idev->cnf.force_tllao;
 	__ndisc_send(dev, neigh, daddr, src_addr,
 		     &icmp6h, solicited_addr,
 		     inc_opt ? ND_OPT_TARGET_LL_ADDR : 0);
diff -urN linux-2.6.35-rc3/net/mac80211/work.c linux-2.6.35-rc4/net/mac80211/work.c
--- linux-2.6.35-rc3/net/mac80211/work.c	2010-07-05 05:34:23.181868119 +0000
+++ linux-2.6.35-rc4/net/mac80211/work.c	2010-07-05 05:34:28.552806856 +0000
@@ -715,7 +715,7 @@
 	struct ieee80211_rx_status *rx_status;
 	struct ieee80211_mgmt *mgmt;
 	struct ieee80211_work *wk;
-	enum work_action rma;
+	enum work_action rma = WORK_ACT_NONE;
 	u16 fc;
 
 	rx_status = (struct ieee80211_rx_status *) skb->cb;
diff -urN linux-2.6.35-rc3/net/netfilter/ipvs/ip_vs_conn.c linux-2.6.35-rc4/net/netfilter/ipvs/ip_vs_conn.c
--- linux-2.6.35-rc3/net/netfilter/ipvs/ip_vs_conn.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/net/netfilter/ipvs/ip_vs_conn.c	2010-07-05 05:34:28.553805623 +0000
@@ -162,6 +162,7 @@
 	hash = ip_vs_conn_hashkey(cp->af, cp->protocol, &cp->caddr, cp->cport);
 
 	ct_write_lock(hash);
+	spin_lock(&cp->lock);
 
 	if (!(cp->flags & IP_VS_CONN_F_HASHED)) {
 		list_add(&cp->c_list, &ip_vs_conn_tab[hash]);
@@ -174,6 +175,7 @@
 		ret = 0;
 	}
 
+	spin_unlock(&cp->lock);
 	ct_write_unlock(hash);
 
 	return ret;
@@ -193,6 +195,7 @@
 	hash = ip_vs_conn_hashkey(cp->af, cp->protocol, &cp->caddr, cp->cport);
 
 	ct_write_lock(hash);
+	spin_lock(&cp->lock);
 
 	if (cp->flags & IP_VS_CONN_F_HASHED) {
 		list_del(&cp->c_list);
@@ -202,6 +205,7 @@
 	} else
 		ret = 0;
 
+	spin_unlock(&cp->lock);
 	ct_write_unlock(hash);
 
 	return ret;
diff -urN linux-2.6.35-rc3/net/sched/sch_teql.c linux-2.6.35-rc4/net/sched/sch_teql.c
--- linux-2.6.35-rc3/net/sched/sch_teql.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/net/sched/sch_teql.c	2010-07-05 05:34:28.573805576 +0000
@@ -449,6 +449,7 @@
 	dev->tx_queue_len	= 100;
 	dev->flags		= IFF_NOARP;
 	dev->hard_header_len	= LL_MAX_HEADER;
+	dev->priv_flags		&= ~IFF_XMIT_DST_RELEASE;
 }
 
 static LIST_HEAD(master_dev_list);
diff -urN linux-2.6.35-rc3/net/sunrpc/xprtsock.c linux-2.6.35-rc4/net/sunrpc/xprtsock.c
--- linux-2.6.35-rc3/net/sunrpc/xprtsock.c	2010-07-05 05:34:23.213868054 +0000
+++ linux-2.6.35-rc4/net/sunrpc/xprtsock.c	2010-07-05 05:34:28.584808435 +0000
@@ -210,7 +210,8 @@
 	 * State of TCP reply receive
 	 */
 	__be32			tcp_fraghdr,
-				tcp_xid;
+				tcp_xid,
+				tcp_calldir;
 
 	u32			tcp_offset,
 				tcp_reclen;
@@ -927,7 +928,7 @@
 {
 	size_t len, used;
 	u32 offset;
-	__be32	calldir;
+	char *p;
 
 	/*
 	 * We want transport->tcp_offset to be 8 at the end of this routine
@@ -936,26 +937,33 @@
 	 * transport->tcp_offset is 4 (after having already read the xid).
 	 */
 	offset = transport->tcp_offset - sizeof(transport->tcp_xid);
-	len = sizeof(calldir) - offset;
+	len = sizeof(transport->tcp_calldir) - offset;
 	dprintk("RPC:       reading CALL/REPLY flag (%Zu bytes)\n", len);
-	used = xdr_skb_read_bits(desc, &calldir, len);
+	p = ((char *) &transport->tcp_calldir) + offset;
+	used = xdr_skb_read_bits(desc, p, len);
 	transport->tcp_offset += used;
 	if (used != len)
 		return;
 	transport->tcp_flags &= ~TCP_RCV_READ_CALLDIR;
-	transport->tcp_flags |= TCP_RCV_COPY_CALLDIR;
-	transport->tcp_flags |= TCP_RCV_COPY_DATA;
 	/*
 	 * We don't yet have the XDR buffer, so we will write the calldir
 	 * out after we get the buffer from the 'struct rpc_rqst'
 	 */
-	if (ntohl(calldir) == RPC_REPLY)
+	switch (ntohl(transport->tcp_calldir)) {
+	case RPC_REPLY:
+		transport->tcp_flags |= TCP_RCV_COPY_CALLDIR;
+		transport->tcp_flags |= TCP_RCV_COPY_DATA;
 		transport->tcp_flags |= TCP_RPC_REPLY;
-	else
+		break;
+	case RPC_CALL:
+		transport->tcp_flags |= TCP_RCV_COPY_CALLDIR;
+		transport->tcp_flags |= TCP_RCV_COPY_DATA;
 		transport->tcp_flags &= ~TCP_RPC_REPLY;
-	dprintk("RPC:       reading %s CALL/REPLY flag %08x\n",
-			(transport->tcp_flags & TCP_RPC_REPLY) ?
-				"reply for" : "request with", calldir);
+		break;
+	default:
+		dprintk("RPC:       invalid request message type\n");
+		xprt_force_disconnect(&transport->xprt);
+	}
 	xs_tcp_check_fraghdr(transport);
 }
 
@@ -975,12 +983,10 @@
 		/*
 		 * Save the RPC direction in the XDR buffer
 		 */
-		__be32	calldir = transport->tcp_flags & TCP_RPC_REPLY ?
-					htonl(RPC_REPLY) : 0;
-
 		memcpy(rcvbuf->head[0].iov_base + transport->tcp_copied,
-			&calldir, sizeof(calldir));
-		transport->tcp_copied += sizeof(calldir);
+			&transport->tcp_calldir,
+			sizeof(transport->tcp_calldir));
+		transport->tcp_copied += sizeof(transport->tcp_calldir);
 		transport->tcp_flags &= ~TCP_RCV_COPY_CALLDIR;
 	}
 
diff -urN linux-2.6.35-rc3/net/xfrm/xfrm_policy.c linux-2.6.35-rc4/net/xfrm/xfrm_policy.c
--- linux-2.6.35-rc3/net/xfrm/xfrm_policy.c	2010-07-05 05:34:23.224806176 +0000
+++ linux-2.6.35-rc4/net/xfrm/xfrm_policy.c	2010-07-05 05:34:28.595868080 +0000
@@ -2300,7 +2300,8 @@
 			return 0;
 		if (xdst->xfrm_genid != dst->xfrm->genid)
 			return 0;
-		if (xdst->policy_genid != atomic_read(&xdst->pols[0]->genid))
+		if (xdst->num_pols > 0 &&
+		    xdst->policy_genid != atomic_read(&xdst->pols[0]->genid))
 			return 0;
 
 		if (strict && fl &&
diff -urN linux-2.6.35-rc3/scripts/mod/modpost.c linux-2.6.35-rc4/scripts/mod/modpost.c
--- linux-2.6.35-rc3/scripts/mod/modpost.c	2010-07-05 05:34:23.232868144 +0000
+++ linux-2.6.35-rc4/scripts/mod/modpost.c	2010-07-05 05:34:28.603805499 +0000
@@ -1342,7 +1342,7 @@
 	int section = sechdr->sh_info;
 
 	return (void *)elf->hdr + sechdrs[section].sh_offset +
-		(r->r_offset - sechdrs[section].sh_addr);
+		r->r_offset - sechdrs[section].sh_addr;
 }
 
 static int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
diff -urN linux-2.6.35-rc3/scripts/package/Makefile linux-2.6.35-rc4/scripts/package/Makefile
--- linux-2.6.35-rc3/scripts/package/Makefile	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/scripts/package/Makefile	2010-07-05 05:34:28.603805499 +0000
@@ -44,7 +44,7 @@
 	fi
 	$(MAKE) clean
 	$(PREV) ln -sf $(srctree) $(KERNELPATH)
-	$(CONFIG_SHELL) $(srctree)/scripts/setlocalversion > $(objtree)/.scmversion
+	$(CONFIG_SHELL) $(srctree)/scripts/setlocalversion --scm-only > $(objtree)/.scmversion
 	$(PREV) tar -cz $(RCS_TAR_IGNORE) -f $(KERNELPATH).tar.gz $(KERNELPATH)/.
 	$(PREV) rm $(KERNELPATH)
 	rm -f $(objtree)/.scmversion
diff -urN linux-2.6.35-rc3/scripts/setlocalversion linux-2.6.35-rc4/scripts/setlocalversion
--- linux-2.6.35-rc3/scripts/setlocalversion	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/scripts/setlocalversion	2010-07-05 05:34:28.604805555 +0000
@@ -10,73 +10,158 @@
 #
 
 usage() {
-	echo "Usage: $0 [srctree]" >&2
+	echo "Usage: $0 [--scm-only] [srctree]" >&2
 	exit 1
 }
 
-cd "${1:-.}" || usage
+scm_only=false
+srctree=.
+if test "$1" = "--scm-only"; then
+	scm_only=true
+	shift
+fi
+if test $# -gt 0; then
+	srctree=$1
+	shift
+fi
+if test $# -gt 0 -o ! -d "$srctree"; then
+	usage
+fi
 
-# Check for git and a git repo.
-if head=`git rev-parse --verify --short HEAD 2>/dev/null`; then
+scm_version()
+{
+	local short=false
+
+	cd "$srctree"
+	if test -e .scmversion; then
+		cat "$_"
+		return
+	fi
+	if test "$1" = "--short"; then
+		short=true
+	fi
+
+	# Check for git and a git repo.
+	if head=`git rev-parse --verify --short HEAD 2>/dev/null`; then
 
-	# If we are at a tagged commit (like "v2.6.30-rc6"), we ignore it,
-	# because this version is defined in the top level Makefile.
-	if [ -z "`git describe --exact-match 2>/dev/null`" ]; then
-
-		# If we are past a tagged commit (like "v2.6.30-rc5-302-g72357d5"),
-		# we pretty print it.
-		if atag="`git describe 2>/dev/null`"; then
-			echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'
-
-		# If we don't have a tag at all we print -g{commitish}.
-		else
-			printf '%s%s' -g $head
+		# If we are at a tagged commit (like "v2.6.30-rc6"), we ignore
+		# it, because this version is defined in the top level Makefile.
+		if [ -z "`git describe --exact-match 2>/dev/null`" ]; then
+
+			# If only the short version is requested, don't bother
+			# running further git commands
+			if $short; then
+				echo "+"
+				return
+			fi
+			# If we are past a tagged commit (like
+			# "v2.6.30-rc5-302-g72357d5"), we pretty print it.
+			if atag="`git describe 2>/dev/null`"; then
+				echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'
+
+			# If we don't have a tag at all we print -g{commitish}.
+			else
+				printf '%s%s' -g $head
+			fi
 		fi
+
+		# Is this git on svn?
+		if git config --get svn-remote.svn.url >/dev/null; then
+			printf -- '-svn%s' "`git svn find-rev $head`"
+		fi
+
+		# Update index only on r/w media
+		[ -w . ] && git update-index --refresh --unmerged > /dev/null
+
+		# Check for uncommitted changes
+		if git diff-index --name-only HEAD | grep -v "^scripts/package" \
+		    | read dummy; then
+			printf '%s' -dirty
+		fi
+
+		# All done with git
+		return
 	fi
 
-	# Is this git on svn?
-	if git config --get svn-remote.svn.url >/dev/null; then
-	        printf -- '-svn%s' "`git svn find-rev $head`"
+	# Check for mercurial and a mercurial repo.
+	if hgid=`hg id 2>/dev/null`; then
+		tag=`printf '%s' "$hgid" | cut -d' ' -f2`
+
+		# Do we have an untagged version?
+		if [ -z "$tag" -o "$tag" = tip ]; then
+			id=`printf '%s' "$hgid" | sed 's/[+ ].*//'`
+			printf '%s%s' -hg "$id"
+		fi
+
+		# Are there uncommitted changes?
+		# These are represented by + after the changeset id.
+		case "$hgid" in
+			*+|*+\ *) printf '%s' -dirty ;;
+		esac
+
+		# All done with mercurial
+		return
 	fi
 
-	# Update index only on r/w media
-	[ -w . ] && git update-index --refresh --unmerged > /dev/null
+	# Check for svn and a svn repo.
+	if rev=`svn info 2>/dev/null | grep '^Last Changed Rev'`; then
+		rev=`echo $rev | awk '{print $NF}'`
+		printf -- '-svn%s' "$rev"
 
-	# Check for uncommitted changes
-	if git diff-index --name-only HEAD | grep -v "^scripts/package" \
-	    | read dummy; then
-		printf '%s' -dirty
+		# All done with svn
+		return
 	fi
+}
+
+collect_files()
+{
+	local file res
+
+	for file; do
+		case "$file" in
+		*\~*)
+			continue
+			;;
+		esac
+		if test -e "$file"; then
+			res="$res$(cat "$file")"
+		fi
+	done
+	echo "$res"
+}
 
-	# All done with git
+if $scm_only; then
+	scm_version
 	exit
 fi
 
-# Check for mercurial and a mercurial repo.
-if hgid=`hg id 2>/dev/null`; then
-	tag=`printf '%s' "$hgid" | cut -d' ' -f2`
-
-	# Do we have an untagged version?
-	if [ -z "$tag" -o "$tag" = tip ]; then
-		id=`printf '%s' "$hgid" | sed 's/[+ ].*//'`
-		printf '%s%s' -hg "$id"
-	fi
-
-	# Are there uncommitted changes?
-	# These are represented by + after the changeset id.
-	case "$hgid" in
-		*+|*+\ *) printf '%s' -dirty ;;
-	esac
+if test -e include/config/auto.conf; then
+	source "$_"
+else
+	echo "Error: kernelrelease not valid - run 'make prepare' to update it"
+	exit 1
+fi
 
-	# All done with mercurial
-	exit
+# localversion* files in the build and source directory
+res="$(collect_files localversion*)"
+if test ! "$srctree" -ef .; then
+	res="$res$(collect_files "$srctree"/localversion*)"
 fi
 
-# Check for svn and a svn repo.
-if rev=`svn info 2>/dev/null | grep '^Last Changed Rev'`; then
-	rev=`echo $rev | awk '{print $NF}'`
-	printf -- '-svn%s' "$rev"
+# CONFIG_LOCALVERSION and LOCALVERSION (if set)
+res="${res}${CONFIG_LOCALVERSION}${LOCALVERSION}"
 
-	# All done with svn
-	exit
+# scm version string if not at a tagged commit
+if test "$CONFIG_LOCALVERSION_AUTO" = "y"; then
+	# full scm version string
+	res="$res$(scm_version)"
+else
+	# apped a plus sign if the repository is not in a clean tagged
+	# state and  LOCALVERSION= is not specified
+	if test "${LOCALVERSION+set}" != "set"; then
+		scm=$(scm_version --short)
+		res="$res${scm:++}"
+	fi
 fi
+
+echo "$res"
diff -urN linux-2.6.35-rc3/security/keys/keyctl.c linux-2.6.35-rc4/security/keys/keyctl.c
--- linux-2.6.35-rc3/security/keys/keyctl.c	2010-07-05 05:34:23.236868068 +0000
+++ linux-2.6.35-rc4/security/keys/keyctl.c	2010-07-05 05:34:28.606868077 +0000
@@ -33,7 +33,7 @@
 	ret = strncpy_from_user(type, _type, len);
 
 	if (ret < 0)
-		return -EFAULT;
+		return ret;
 
 	if (ret == 0 || ret >= len)
 		return -EINVAL;
@@ -1080,7 +1080,7 @@
 	return old_setting;
 error:
 	abort_creds(new);
-	return -EINVAL;
+	return ret;
 
 } /* end keyctl_set_reqkey_keyring() */
 
diff -urN linux-2.6.35-rc3/sound/pci/asihpi/hpi6205.c linux-2.6.35-rc4/sound/pci/asihpi/hpi6205.c
--- linux-2.6.35-rc3/sound/pci/asihpi/hpi6205.c	2010-07-05 05:34:23.255868004 +0000
+++ linux-2.6.35-rc4/sound/pci/asihpi/hpi6205.c	2010-07-05 05:34:28.625868108 +0000
@@ -941,11 +941,11 @@
 
 }
 
-static long outstream_get_space_available(struct hpi_hostbuffer_status
+static u32 outstream_get_space_available(struct hpi_hostbuffer_status
 	*status)
 {
-	return status->size_in_bytes - ((long)(status->host_index) -
-		(long)(status->dSP_index));
+	return status->size_in_bytes - (status->host_index -
+		status->dSP_index);
 }
 
 static void outstream_write(struct hpi_adapter_obj *pao,
@@ -954,7 +954,7 @@
 	struct hpi_hw_obj *phw = pao->priv;
 	struct bus_master_interface *interface = phw->p_interface_buffer;
 	struct hpi_hostbuffer_status *status;
-	long space_available;
+	u32 space_available;
 
 	if (!phw->outstream_host_buffer_size[phm->obj_index]) {
 		/* there  is no BBM buffer, write via message */
@@ -1007,7 +1007,7 @@
 	}
 
 	space_available = outstream_get_space_available(status);
-	if (space_available < (long)phm->u.d.u.data.data_size) {
+	if (space_available < phm->u.d.u.data.data_size) {
 		phr->error = HPI_ERROR_INVALID_DATASIZE;
 		return;
 	}
@@ -1018,7 +1018,7 @@
 		&& hpios_locked_mem_valid(&phw->outstream_host_buffers[phm->
 				obj_index])) {
 		u8 *p_bbm_data;
-		long l_first_write;
+		u32 l_first_write;
 		u8 *p_app_data = (u8 *)phm->u.d.u.data.pb_data;
 
 		if (hpios_locked_mem_get_virt_addr(&phw->
@@ -1248,9 +1248,9 @@
 	hw_message(pao, phm, phr);
 }
 
-static long instream_get_bytes_available(struct hpi_hostbuffer_status *status)
+static u32 instream_get_bytes_available(struct hpi_hostbuffer_status *status)
 {
-	return (long)(status->dSP_index) - (long)(status->host_index);
+	return status->dSP_index - status->host_index;
 }
 
 static void instream_read(struct hpi_adapter_obj *pao,
@@ -1259,9 +1259,9 @@
 	struct hpi_hw_obj *phw = pao->priv;
 	struct bus_master_interface *interface = phw->p_interface_buffer;
 	struct hpi_hostbuffer_status *status;
-	long data_available;
+	u32 data_available;
 	u8 *p_bbm_data;
-	long l_first_read;
+	u32 l_first_read;
 	u8 *p_app_data = (u8 *)phm->u.d.u.data.pb_data;
 
 	if (!phw->instream_host_buffer_size[phm->obj_index]) {
@@ -1272,7 +1272,7 @@
 
 	status = &interface->instream_host_buffer_status[phm->obj_index];
 	data_available = instream_get_bytes_available(status);
-	if (data_available < (long)phm->u.d.u.data.data_size) {
+	if (data_available < phm->u.d.u.data.data_size) {
 		phr->error = HPI_ERROR_INVALID_DATASIZE;
 		return;
 	}
diff -urN linux-2.6.35-rc3/sound/pci/hda/patch_realtek.c linux-2.6.35-rc4/sound/pci/hda/patch_realtek.c
--- linux-2.6.35-rc3/sound/pci/hda/patch_realtek.c	2010-07-05 05:34:23.269805454 +0000
+++ linux-2.6.35-rc4/sound/pci/hda/patch_realtek.c	2010-07-05 05:34:28.639868074 +0000
@@ -2619,16 +2619,18 @@
 	}
 
 	/* assign Capture Source enums to NID */
-	kctl = snd_hda_find_mixer_ctl(codec, "Capture Source");
-	if (!kctl)
-		kctl = snd_hda_find_mixer_ctl(codec, "Input Source");
-	for (i = 0; kctl && i < kctl->count; i++) {
-		hda_nid_t *nids = spec->capsrc_nids;
-		if (!nids)
-			nids = spec->adc_nids;
-		err = snd_hda_add_nid(codec, kctl, i, nids[i]);
-		if (err < 0)
-			return err;
+	if (spec->capsrc_nids || spec->adc_nids) {
+		kctl = snd_hda_find_mixer_ctl(codec, "Capture Source");
+		if (!kctl)
+			kctl = snd_hda_find_mixer_ctl(codec, "Input Source");
+		for (i = 0; kctl && i < kctl->count; i++) {
+			hda_nid_t *nids = spec->capsrc_nids;
+			if (!nids)
+				nids = spec->adc_nids;
+			err = snd_hda_add_nid(codec, kctl, i, nids[i]);
+			if (err < 0)
+				return err;
+		}
 	}
 	if (spec->cap_mixer) {
 		const char *kname = kctl ? kctl->id.name : NULL;
@@ -6948,7 +6950,7 @@
 	.num_items = 3,
 	.items = {
 		{ "Mic", 0x1 },
-		{ "Line", 0x2 },
+		{ "Line", 0x7 },
 		{ "CD", 0x4 },
 	},
 };
@@ -7469,8 +7471,8 @@
 	HDA_BIND_MUTE   ("LFE Playback Switch", 0x0e, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0f, 0x00, HDA_OUTPUT),
 	HDA_BIND_MUTE   ("Headphone Playback Switch", 0x0f, 0x02, HDA_INPUT),
-	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
-	HDA_CODEC_MUTE  ("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x07, HDA_INPUT),
+	HDA_CODEC_MUTE  ("Line Playback Switch", 0x0b, 0x07, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x01, HDA_INPUT),
 	HDA_CODEC_MUTE  ("Mic Playback Switch", 0x0b, 0x01, HDA_INPUT),
 	HDA_CODEC_VOLUME("Line Boost", 0x15, 0x00, HDA_INPUT),
@@ -7853,10 +7855,9 @@
 	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
 	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
 
-	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
-	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(3)},
-	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(2)},
-	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(4)},
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0x1)},
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0x7)},
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0x4)},
 	{ }
 };
 
diff -urN linux-2.6.35-rc3/sound/soc/davinci/davinci-mcasp.c linux-2.6.35-rc4/sound/soc/davinci/davinci-mcasp.c
--- linux-2.6.35-rc3/sound/soc/davinci/davinci-mcasp.c	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/sound/soc/davinci/davinci-mcasp.c	2010-07-05 05:34:28.659868069 +0000
@@ -612,7 +612,6 @@
 								NUMDMA_MASK);
 		mcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,
 				((dev->txnumevt * tx_ser) << 8), NUMEVT_MASK);
-		mcasp_set_bits(dev->base + DAVINCI_MCASP_WFIFOCTL, FIFO_ENABLE);
 	}
 
 	if (dev->rxnumevt && stream == SNDRV_PCM_STREAM_CAPTURE) {
@@ -623,7 +622,6 @@
 								NUMDMA_MASK);
 		mcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,
 				((dev->rxnumevt * rx_ser) << 8), NUMEVT_MASK);
-		mcasp_set_bits(dev->base + DAVINCI_MCASP_RFIFOCTL, FIFO_ENABLE);
 	}
 }
 
diff -urN linux-2.6.35-rc3/sound/soc/fsl/mpc5200_dma.h linux-2.6.35-rc4/sound/soc/fsl/mpc5200_dma.h
--- linux-2.6.35-rc3/sound/soc/fsl/mpc5200_dma.h	2010-05-16 21:17:36.000000000 +0000
+++ linux-2.6.35-rc4/sound/soc/fsl/mpc5200_dma.h	2010-07-05 05:34:28.660868069 +0000
@@ -73,7 +73,7 @@
 };
 
 /* Utility for retrieving psc_dma_stream structure from a substream */
-inline struct psc_dma_stream *
+static inline struct psc_dma_stream *
 to_psc_dma_stream(struct snd_pcm_substream *substream, struct psc_dma *psc_dma)
 {
 	if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)
diff -urN linux-2.6.35-rc3/sound/usb/clock.c linux-2.6.35-rc4/sound/usb/clock.c
--- linux-2.6.35-rc3/sound/usb/clock.c	2010-07-05 05:34:23.301868107 +0000
+++ linux-2.6.35-rc4/sound/usb/clock.c	2010-07-05 05:34:28.670868105 +0000
@@ -103,7 +103,8 @@
 	ret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0),
 			      UAC2_CS_CUR,
 			      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,
-			      UAC2_CX_CLOCK_SELECTOR << 8, selector_id << 8,
+			      UAC2_CX_CLOCK_SELECTOR << 8,
+			      snd_usb_ctrl_intf(chip) | (selector_id << 8),
 			      &buf, sizeof(buf), 1000);
 
 	if (ret < 0)
@@ -120,7 +121,8 @@
 
 	err = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_CUR,
 			      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,
-			      UAC2_CS_CONTROL_CLOCK_VALID << 8, source_id << 8,
+			      UAC2_CS_CONTROL_CLOCK_VALID << 8,
+			      snd_usb_ctrl_intf(chip) | (source_id << 8),
 			      &data, sizeof(data), 1000);
 
 	if (err < 0) {
@@ -269,7 +271,8 @@
 	data[3] = rate >> 24;
 	if ((err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC2_CS_CUR,
 				   USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				   UAC2_CS_CONTROL_SAM_FREQ << 8, clock << 8,
+				   UAC2_CS_CONTROL_SAM_FREQ << 8,
+				   snd_usb_ctrl_intf(chip) | (clock << 8),
 				   data, sizeof(data), 1000)) < 0) {
 		snd_printk(KERN_ERR "%d:%d:%d: cannot set freq %d (v2)\n",
 			   dev->devnum, iface, fmt->altsetting, rate);
@@ -278,7 +281,8 @@
 
 	if ((err = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_CUR,
 				   USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,
-				   UAC2_CS_CONTROL_SAM_FREQ << 8, clock << 8,
+				   UAC2_CS_CONTROL_SAM_FREQ << 8,
+				   snd_usb_ctrl_intf(chip) | (clock << 8),
 				   data, sizeof(data), 1000)) < 0) {
 		snd_printk(KERN_WARNING "%d:%d:%d: cannot get freq (v2)\n",
 			   dev->devnum, iface, fmt->altsetting);
diff -urN linux-2.6.35-rc3/sound/usb/endpoint.c linux-2.6.35-rc4/sound/usb/endpoint.c
--- linux-2.6.35-rc3/sound/usb/endpoint.c	2010-07-05 05:34:23.301868107 +0000
+++ linux-2.6.35-rc4/sound/usb/endpoint.c	2010-07-05 05:34:28.671868230 +0000
@@ -427,6 +427,7 @@
 		if (snd_usb_parse_audio_format(chip, fp, format, fmt, stream, alts) < 0) {
 			kfree(fp->rate_table);
 			kfree(fp);
+			fp = NULL;
 			continue;
 		}
 
diff -urN linux-2.6.35-rc3/sound/usb/format.c linux-2.6.35-rc4/sound/usb/format.c
--- linux-2.6.35-rc3/sound/usb/format.c	2010-07-05 05:34:23.302868109 +0000
+++ linux-2.6.35-rc4/sound/usb/format.c	2010-07-05 05:34:28.671868230 +0000
@@ -206,6 +206,60 @@
 }
 
 /*
+ * Helper function to walk the array of sample rate triplets reported by
+ * the device. The problem is that we need to parse whole array first to
+ * get to know how many sample rates we have to expect.
+ * Then fp->rate_table can be allocated and filled.
+ */
+static int parse_uac2_sample_rate_range(struct audioformat *fp, int nr_triplets,
+					const unsigned char *data)
+{
+	int i, nr_rates = 0;
+
+	fp->rates = fp->rate_min = fp->rate_max = 0;
+
+	for (i = 0; i < nr_triplets; i++) {
+		int min = combine_quad(&data[2 + 12 * i]);
+		int max = combine_quad(&data[6 + 12 * i]);
+		int res = combine_quad(&data[10 + 12 * i]);
+		int rate;
+
+		if ((max < 0) || (min < 0) || (res < 0) || (max < min))
+			continue;
+
+		/*
+		 * for ranges with res == 1, we announce a continuous sample
+		 * rate range, and this function should return 0 for no further
+		 * parsing.
+		 */
+		if (res == 1) {
+			fp->rate_min = min;
+			fp->rate_max = max;
+			fp->rates = SNDRV_PCM_RATE_CONTINUOUS;
+			return 0;
+		}
+
+		for (rate = min; rate <= max; rate += res) {
+			if (fp->rate_table)
+				fp->rate_table[nr_rates] = rate;
+			if (!fp->rate_min || rate < fp->rate_min)
+				fp->rate_min = rate;
+			if (!fp->rate_max || rate > fp->rate_max)
+				fp->rate_max = rate;
+			fp->rates |= snd_pcm_rate_to_rate_bit(rate);
+
+			nr_rates++;
+
+			/* avoid endless loop */
+			if (res == 0)
+				break;
+		}
+	}
+
+	return nr_rates;
+}
+
+/*
  * parse the format descriptor and stores the possible sample rates
  * on the audioformat table (audio class v2).
  */
@@ -215,13 +269,20 @@
 {
 	struct usb_device *dev = chip->dev;
 	unsigned char tmp[2], *data;
-	int i, nr_rates, data_size, ret = 0;
+	int nr_triplets, data_size, ret = 0;
 	int clock = snd_usb_clock_find_source(chip, chip->ctrl_intf, fp->clock);
 
+	if (clock < 0) {
+		snd_printk(KERN_ERR "%s(): unable to find clock source (clock %d)\n",
+				__func__, clock);
+		goto err;
+	}
+
 	/* get the number of sample rates first by only fetching 2 bytes */
 	ret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_RANGE,
 			      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,
-			      UAC2_CS_CONTROL_SAM_FREQ << 8, clock << 8,
+			      UAC2_CS_CONTROL_SAM_FREQ << 8,
+			      snd_usb_ctrl_intf(chip) | (clock << 8),
 			      tmp, sizeof(tmp), 1000);
 
 	if (ret < 0) {
@@ -230,8 +291,8 @@
 		goto err;
 	}
 
-	nr_rates = (tmp[1] << 8) | tmp[0];
-	data_size = 2 + 12 * nr_rates;
+	nr_triplets = (tmp[1] << 8) | tmp[0];
+	data_size = 2 + 12 * nr_triplets;
 	data = kzalloc(data_size, GFP_KERNEL);
 	if (!data) {
 		ret = -ENOMEM;
@@ -241,7 +302,8 @@
 	/* now get the full information */
 	ret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_RANGE,
 			      USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,
-			      UAC2_CS_CONTROL_SAM_FREQ << 8, clock << 8,
+			      UAC2_CS_CONTROL_SAM_FREQ << 8,
+			      snd_usb_ctrl_intf(chip) | (clock << 8),
 			      data, data_size, 1000);
 
 	if (ret < 0) {
@@ -251,26 +313,28 @@
 		goto err_free;
 	}
 
-	fp->rate_table = kmalloc(sizeof(int) * nr_rates, GFP_KERNEL);
+	/* Call the triplet parser, and make sure fp->rate_table is NULL.
+	 * We just use the return value to know how many sample rates we
+	 * will have to deal with. */
+	kfree(fp->rate_table);
+	fp->rate_table = NULL;
+	fp->nr_rates = parse_uac2_sample_rate_range(fp, nr_triplets, data);
+
+	if (fp->nr_rates == 0) {
+		/* SNDRV_PCM_RATE_CONTINUOUS */
+		ret = 0;
+		goto err_free;
+	}
+
+	fp->rate_table = kmalloc(sizeof(int) * fp->nr_rates, GFP_KERNEL);
 	if (!fp->rate_table) {
 		ret = -ENOMEM;
 		goto err_free;
 	}
 
-	fp->nr_rates = 0;
-	fp->rate_min = fp->rate_max = 0;
-
-	for (i = 0; i < nr_rates; i++) {
-		int rate = combine_quad(&data[2 + 12 * i]);
-
-		fp->rate_table[fp->nr_rates] = rate;
-		if (!fp->rate_min || rate < fp->rate_min)
-			fp->rate_min = rate;
-		if (!fp->rate_max || rate > fp->rate_max)
-			fp->rate_max = rate;
-		fp->rates |= snd_pcm_rate_to_rate_bit(rate);
-		fp->nr_rates++;
-	}
+	/* Call the triplet parser again, but this time, fp->rate_table is
+	 * allocated, so the rates will be stored */
+	parse_uac2_sample_rate_range(fp, nr_triplets, data);
 
 err_free:
 	kfree(data);
diff -urN linux-2.6.35-rc3/sound/usb/helper.h linux-2.6.35-rc4/sound/usb/helper.h
--- linux-2.6.35-rc3/sound/usb/helper.h	2010-07-05 05:34:23.302868109 +0000
+++ linux-2.6.35-rc4/sound/usb/helper.h	2010-07-05 05:34:28.671868230 +0000
@@ -28,5 +28,9 @@
 #define snd_usb_get_speed(dev) ((dev)->speed)
 #endif
 
+static inline int snd_usb_ctrl_intf(struct snd_usb_audio *chip)
+{
+	return get_iface_desc(chip->ctrl_intf)->bInterfaceNumber;
+}
 
 #endif /* __USBAUDIO_HELPER_H */
diff -urN linux-2.6.35-rc3/sound/usb/mixer.c linux-2.6.35-rc4/sound/usb/mixer.c
--- linux-2.6.35-rc3/sound/usb/mixer.c	2010-07-05 05:34:23.305815676 +0000
+++ linux-2.6.35-rc4/sound/usb/mixer.c	2010-07-05 05:34:28.674868062 +0000
@@ -297,20 +297,27 @@
 
 static int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request, int validx, int *value_ret)
 {
-	unsigned char buf[14]; /* enough space for one range of 4 bytes */
+	unsigned char buf[2 + 3*sizeof(__u16)]; /* enough space for one range */
 	unsigned char *val;
-	int ret;
+	int ret, size;
 	__u8 bRequest;
 
-	bRequest = (request == UAC_GET_CUR) ?
-		UAC2_CS_CUR : UAC2_CS_RANGE;
+	if (request == UAC_GET_CUR) {
+		bRequest = UAC2_CS_CUR;
+		size = sizeof(__u16);
+	} else {
+		bRequest = UAC2_CS_RANGE;
+		size = sizeof(buf);
+	}
+
+	memset(buf, 0, sizeof(buf));
 
 	ret = snd_usb_ctl_msg(cval->mixer->chip->dev,
 			      usb_rcvctrlpipe(cval->mixer->chip->dev, 0),
 			      bRequest,
 			      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,
 			      validx, cval->mixer->ctrlif | (cval->id << 8),
-			      buf, sizeof(buf), 1000);
+			      buf, size, 1000);
 
 	if (ret < 0) {
 		snd_printk(KERN_ERR "cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\n",
@@ -318,6 +325,8 @@
 		return ret;
 	}
 
+	/* FIXME: how should we handle multiple triplets here? */
+
 	switch (request) {
 	case UAC_GET_CUR:
 		val = buf;
diff -urN linux-2.6.35-rc3/tools/perf/builtin-record.c linux-2.6.35-rc4/tools/perf/builtin-record.c
--- linux-2.6.35-rc3/tools/perf/builtin-record.c	2010-07-05 05:34:23.320805629 +0000
+++ linux-2.6.35-rc4/tools/perf/builtin-record.c	2010-07-05 05:34:28.690868062 +0000
@@ -193,7 +193,7 @@
 
 static void sig_atexit(void)
 {
-	if (child_pid != -1)
+	if (child_pid > 0)
 		kill(child_pid, SIGTERM);
 
 	if (signr == -1)
diff -urN linux-2.6.35-rc3/tools/perf/util/event.c linux-2.6.35-rc4/tools/perf/util/event.c
--- linux-2.6.35-rc3/tools/perf/util/event.c	2010-07-05 05:34:23.328806919 +0000
+++ linux-2.6.35-rc4/tools/perf/util/event.c	2010-07-05 05:34:28.699868098 +0000
@@ -538,8 +538,10 @@
 	dump_printf("(%d:%d):(%d:%d)\n", self->fork.pid, self->fork.tid,
 		    self->fork.ppid, self->fork.ptid);
 
-	if (self->header.type == PERF_RECORD_EXIT)
+	if (self->header.type == PERF_RECORD_EXIT) {
+		perf_session__remove_thread(session, thread);
 		return 0;
+	}
 
 	if (thread == NULL || parent == NULL ||
 	    thread__fork(thread, parent) < 0) {
diff -urN linux-2.6.35-rc3/tools/perf/util/newt.c linux-2.6.35-rc4/tools/perf/util/newt.c
--- linux-2.6.35-rc3/tools/perf/util/newt.c	2010-07-05 05:34:23.331868221 +0000
+++ linux-2.6.35-rc4/tools/perf/util/newt.c	2010-07-05 05:34:28.702805957 +0000
@@ -43,6 +43,9 @@
 
 	if (self != NULL) {
 		int cols;
+
+		if (use_browser <= 0)	
+			return self;
 		newtGetScreenSize(&cols, NULL);
 		cols -= 4;
 		newtCenteredWindow(cols, 1, title);
@@ -67,14 +70,22 @@
 
 void ui_progress__update(struct ui_progress *self, u64 curr)
 {
+	/*
+	 * FIXME: We should have a per UI backend way of showing progress,
+	 * stdio will just show a percentage as NN%, etc.
+	 */
+	if (use_browser <= 0)
+		return;
 	newtScaleSet(self->scale, curr);
 	newtRefresh();
 }
 
 void ui_progress__delete(struct ui_progress *self)
 {
-	newtFormDestroy(self->form);
-	newtPopWindow();
+	if (use_browser > 0) {
+		newtFormDestroy(self->form);
+		newtPopWindow();
+	}
 	free(self);
 }
 
diff -urN linux-2.6.35-rc3/tools/perf/util/session.c linux-2.6.35-rc4/tools/perf/util/session.c
--- linux-2.6.35-rc3/tools/perf/util/session.c	2010-07-05 05:34:23.336868158 +0000
+++ linux-2.6.35-rc4/tools/perf/util/session.c	2010-07-05 05:34:28.707868060 +0000
@@ -90,6 +90,7 @@
 
 	memcpy(self->filename, filename, len);
 	self->threads = RB_ROOT;
+	INIT_LIST_HEAD(&self->dead_threads);
 	self->hists_tree = RB_ROOT;
 	self->last_match = NULL;
 	self->mmap_window = 32;
@@ -131,6 +132,16 @@
 	free(self);
 }
 
+void perf_session__remove_thread(struct perf_session *self, struct thread *th)
+{
+	rb_erase(&th->rb_node, &self->threads);
+	/*
+	 * We may have references to this thread, for instance in some hist_entry
+	 * instances, so just move them to a separate list.
+	 */
+	list_add_tail(&th->node, &self->dead_threads);
+}
+
 static bool symbol__match_parent_regex(struct symbol *sym)
 {
 	if (sym->name && !regexec(&parent_regex, sym->name, 0, NULL, 0))
diff -urN linux-2.6.35-rc3/tools/perf/util/session.h linux-2.6.35-rc4/tools/perf/util/session.h
--- linux-2.6.35-rc3/tools/perf/util/session.h	2010-07-05 05:34:23.336868158 +0000
+++ linux-2.6.35-rc4/tools/perf/util/session.h	2010-07-05 05:34:28.707868060 +0000
@@ -26,6 +26,7 @@
 	unsigned long		size;
 	unsigned long		mmap_window;
 	struct rb_root		threads;
+	struct list_head	dead_threads;
 	struct thread		*last_match;
 	struct machine		host_machine;
 	struct rb_root		machines;
@@ -99,6 +100,7 @@
 
 int do_read(int fd, void *buf, size_t size);
 void perf_session__update_sample_type(struct perf_session *self);
+void perf_session__remove_thread(struct perf_session *self, struct thread *th);
 
 static inline
 struct machine *perf_session__find_host_machine(struct perf_session *self)
diff -urN linux-2.6.35-rc3/tools/perf/util/thread.c linux-2.6.35-rc4/tools/perf/util/thread.c
--- linux-2.6.35-rc3/tools/perf/util/thread.c	2010-07-05 05:34:23.338806719 +0000
+++ linux-2.6.35-rc4/tools/perf/util/thread.c	2010-07-05 05:34:28.709868082 +0000
@@ -7,6 +7,15 @@
 #include "util.h"
 #include "debug.h"
 
+/* Skip "." and ".." directories */
+static int filter(const struct dirent *dir)
+{
+	if (dir->d_name[0] == '.')
+		return 0;
+	else
+		return 1;
+}
+
 int find_all_tid(int pid, pid_t ** all_tid)
 {
 	char name[256];
@@ -16,7 +25,7 @@
 	int i;
 
 	sprintf(name, "/proc/%d/task", pid);
-	items = scandir(name, &namelist, NULL, NULL);
+	items = scandir(name, &namelist, filter, NULL);
 	if (items <= 0)
                 return -ENOENT;
 	*all_tid = malloc(sizeof(pid_t) * items);
diff -urN linux-2.6.35-rc3/tools/perf/util/thread.h linux-2.6.35-rc4/tools/perf/util/thread.h
--- linux-2.6.35-rc3/tools/perf/util/thread.h	2010-07-05 05:34:23.338806719 +0000
+++ linux-2.6.35-rc4/tools/perf/util/thread.h	2010-07-05 05:34:28.709868082 +0000
@@ -6,7 +6,10 @@
 #include "symbol.h"
 
 struct thread {
-	struct rb_node		rb_node;
+	union {
+		struct rb_node	 rb_node;
+		struct list_head node;
+	};
 	struct map_groups	mg;
 	pid_t			pid;
 	char			shortname[3];
