From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] kernel: Update to 2.6.24-rc5-git7
Patch-mainline: 2.6.24-rc5-git7

 This patch contains the differences between 2.6.24-rc5-git6 and -git7.

 The corresponding git commit id is: fbdcf18df73758b2e187ab94678b30cd5f6ff9f9.

Acked-by: Jeff Mahoney <jeffm@suse.com>

---

 Makefile                            |    2 +-
 arch/ia64/hp/common/sba_iommu.c     |    3 ++-
 arch/ia64/ia32/binfmt_elf32.c       |   34 +++++++++++++++-------------------
 arch/ia64/kernel/head.S             |    1 +
 arch/ia64/kernel/irq_ia64.c         |    4 ++--
 arch/ia64/kernel/mca.c              |   33 +++++++++++++++++++++++++++++++++
 arch/ia64/kernel/process.c          |    7 +++++--
 arch/ia64/kernel/signal.c           |   10 +---------
 arch/ia64/kernel/uncached.c         |    2 +-
 arch/ia64/mm/tlb.c                  |   18 +++++++++++++++---
 arch/ia64/sn/kernel/bte.c           |    4 ++--
 arch/ia64/sn/kernel/bte_error.c     |    8 ++++++--
 arch/ia64/sn/pci/tioce_provider.c   |    2 +-
 arch/x86/kernel/apic_32.c           |    2 +-
 arch/x86/kernel/process_32.c        |    2 +-
 arch/x86/kernel/setup_32.c          |    2 +-
 arch/x86/kernel/smpboot_32.c        |    6 +++---
 arch/x86/kernel/smpboot_64.c        |    2 +-
 drivers/ata/pata_hpt37x.c           |    2 +-
 drivers/scsi/dpt_i2o.c              |    3 +--
 drivers/scsi/initio.c               |    2 ++
 drivers/scsi/st.c                   |    1 +
 drivers/scsi/sym53c8xx_2/sym_glue.c |    2 +-
 drivers/scsi/sym53c8xx_2/sym_hipd.c |    2 +-
 drivers/video/ps3fb.c               |   28 ++++++++++++++++++++--------
 include/asm-ia64/bitops.h           |   17 ++++++++++++++---
 include/asm-ia64/gcc_intrin.h       |    5 +++++
 include/asm-ia64/hw_irq.h           |    2 +-
 include/asm-ia64/intel_intrin.h     |    3 +++
 include/asm-ia64/sn/bte.h           |   31 ++++++++++++++++++++++++++++++-
 include/asm-ia64/sn/xp.h            |   27 +++++++++++++++++++++++++--
 include/asm-ia64/sn/xpc.h           |    8 +++++++-
 include/asm-ia64/tlbflush.h         |    6 +++++-
 mm/filemap.c                        |   12 ++++++++++++
 34 files changed, 221 insertions(+), 72 deletions(-)

--- a/arch/ia64/hp/common/sba_iommu.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/ia64/hp/common/sba_iommu.c	2007-12-20 14:19:21.000000000 -0500
@@ -2034,7 +2034,8 @@ sba_init(void)
 	if (!ia64_platform_is("hpzx1") && !ia64_platform_is("hpzx1_swiotlb"))
 		return 0;
 
-#if defined(CONFIG_IA64_GENERIC) && defined(CONFIG_CRASH_DUMP)
+#if defined(CONFIG_IA64_GENERIC) && defined(CONFIG_CRASH_DUMP) && \
+        defined(CONFIG_PROC_FS)
 	/* If we are booting a kdump kernel, the sba_iommu will
 	 * cause devices that were not shutdown properly to MCA
 	 * as soon as they are turned back on.  Our only option for
--- a/arch/ia64/ia32/binfmt_elf32.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/ia64/ia32/binfmt_elf32.c	2007-12-20 14:19:21.000000000 -0500
@@ -52,33 +52,29 @@ extern struct page *ia32_shared_page[];
 extern unsigned long *ia32_gdt;
 extern struct page *ia32_gate_page;
 
-struct page *
-ia32_install_shared_page (struct vm_area_struct *vma, unsigned long address, int *type)
+int
+ia32_install_shared_page (struct vm_area_struct *vma, struct vm_fault *vmf)
 {
-	struct page *pg = ia32_shared_page[smp_processor_id()];
-	get_page(pg);
-	if (type)
-		*type = VM_FAULT_MINOR;
-	return pg;
-}
-
-struct page *
-ia32_install_gate_page (struct vm_area_struct *vma, unsigned long address, int *type)
-{
-	struct page *pg = ia32_gate_page;
-	get_page(pg);
-	if (type)
-		*type = VM_FAULT_MINOR;
-	return pg;
+	vmf->page = ia32_shared_page[smp_processor_id()];
+	get_page(vmf->page);
+	return 0;
+}
+
+int
+ia32_install_gate_page (struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	vmf->page = ia32_gate_page;
+	get_page(vmf->page);
+	return 0;
 }
 
 
 static struct vm_operations_struct ia32_shared_page_vm_ops = {
-	.nopage = ia32_install_shared_page
+	.fault = ia32_install_shared_page
 };
 
 static struct vm_operations_struct ia32_gate_page_vm_ops = {
-	.nopage = ia32_install_gate_page
+	.fault = ia32_install_gate_page
 };
 
 void
--- a/arch/ia64/kernel/head.S	2007-10-10 17:43:37.000000000 -0400
+++ b/arch/ia64/kernel/head.S	2007-12-20 14:19:21.000000000 -0500
@@ -1176,6 +1176,7 @@ tlb_purge_done:
 	RESTORE_REG(cr.dcr, r25, r17);;
 	RESTORE_REG(cr.iva, r25, r17);;
 	RESTORE_REG(cr.pta, r25, r17);;
+	srlz.d;;	// required not to violate RAW dependency
 	RESTORE_REG(cr.itv, r25, r17);;
 	RESTORE_REG(cr.pmv, r25, r17);;
 	RESTORE_REG(cr.cmcv, r25, r17);;
--- a/arch/ia64/kernel/irq_ia64.c	2007-10-10 17:43:37.000000000 -0400
+++ b/arch/ia64/kernel/irq_ia64.c	2007-12-20 14:19:21.000000000 -0500
@@ -200,7 +200,7 @@ assign_irq_vector (int irq)
 {
 	unsigned long flags;
 	int vector, cpu;
-	cpumask_t domain;
+	cpumask_t domain = CPU_MASK_NONE;
 
 	vector = -ENOSPC;
 
@@ -340,7 +340,7 @@ int create_irq(void)
 {
 	unsigned long flags;
 	int irq, vector, cpu;
-	cpumask_t domain;
+	cpumask_t domain = CPU_MASK_NONE;
 
 	irq = vector = -ENOSPC;
 	spin_lock_irqsave(&vector_lock, flags);
--- a/arch/ia64/kernel/mca.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/ia64/kernel/mca.c	2007-12-20 14:19:21.000000000 -0500
@@ -75,6 +75,7 @@
 #include <linux/workqueue.h>
 #include <linux/cpumask.h>
 #include <linux/kdebug.h>
+#include <linux/cpu.h>
 
 #include <asm/delay.h>
 #include <asm/machvec.h>
@@ -1813,6 +1814,36 @@ ia64_mca_cpu_init(void *cpu_data)
 							      PAGE_KERNEL));
 }
 
+static void __cpuinit ia64_mca_cmc_vector_adjust(void *dummy)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (!cmc_polling_enabled)
+		ia64_mca_cmc_vector_enable(NULL);
+	local_irq_restore(flags);
+}
+
+static int __cpuinit mca_cpu_callback(struct notifier_block *nfb,
+				      unsigned long action,
+				      void *hcpu)
+{
+	int hotcpu = (unsigned long) hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+	case CPU_ONLINE_FROZEN:
+		smp_call_function_single(hotcpu, ia64_mca_cmc_vector_adjust,
+					 NULL, 1, 0);
+		break;
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block mca_cpu_notifier __cpuinitdata = {
+	.notifier_call = mca_cpu_callback
+};
+
 /*
  * ia64_mca_init
  *
@@ -1996,6 +2027,8 @@ ia64_mca_late_init(void)
 	if (!mca_init)
 		return 0;
 
+	register_hotcpu_notifier(&mca_cpu_notifier);
+
 	/* Setup the CMCI/P vector and handler */
 	init_timer(&cmc_poll_timer);
 	cmc_poll_timer.function = ia64_mca_cmc_poll;
--- a/arch/ia64/kernel/process.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/ia64/kernel/process.c	2007-12-20 14:19:21.000000000 -0500
@@ -27,6 +27,7 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/kdebug.h>
+#include <linux/utsname.h>
 
 #include <asm/cpu.h>
 #include <asm/delay.h>
@@ -107,8 +108,9 @@ show_regs (struct pt_regs *regs)
 	print_modules();
 	printk("\nPid: %d, CPU %d, comm: %20s\n", task_pid_nr(current),
 			smp_processor_id(), current->comm);
-	printk("psr : %016lx ifs : %016lx ip  : [<%016lx>]    %s\n",
-	       regs->cr_ipsr, regs->cr_ifs, ip, print_tainted());
+	printk("psr : %016lx ifs : %016lx ip  : [<%016lx>]    %s (%s)\n",
+	       regs->cr_ipsr, regs->cr_ifs, ip, print_tainted(),
+	       init_utsname()->release);
 	print_symbol("ip is at %s\n", ip);
 	printk("unat: %016lx pfs : %016lx rsc : %016lx\n",
 	       regs->ar_unat, regs->ar_pfs, regs->ar_rsc);
@@ -737,6 +739,7 @@ flush_thread (void)
 		ia32_drop_ia64_partial_page_list(current);
 		current->thread.task_size = IA32_PAGE_OFFSET;
 		set_fs(USER_DS);
+		memset(current->thread.tls_array, 0, sizeof(current->thread.tls_array));
 	}
 #endif
 }
--- a/arch/ia64/kernel/signal.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/ia64/kernel/signal.c	2007-12-20 14:19:21.000000000 -0500
@@ -280,15 +280,7 @@ setup_sigcontext (struct sigcontext __us
 	err |= __copy_to_user(&sc->sc_gr[15], &scr->pt.r15, 8);		/* r15 */
 	err |= __put_user(scr->pt.cr_iip + ia64_psr(&scr->pt)->ri, &sc->sc_ip);
 
-	if (flags & IA64_SC_FLAG_IN_SYSCALL) {
-		/* Clear scratch registers if the signal interrupted a system call. */
-		err |= __put_user(0, &sc->sc_ar_ccv);				/* ar.ccv */
-		err |= __put_user(0, &sc->sc_br[7]);				/* b7 */
-		err |= __put_user(0, &sc->sc_gr[14]);				/* r14 */
-		err |= __clear_user(&sc->sc_ar25, 2*8);			/* ar.csd & ar.ssd */
-		err |= __clear_user(&sc->sc_gr[2], 2*8);			/* r2-r3 */
-		err |= __clear_user(&sc->sc_gr[16], 16*8);			/* r16-r31 */
-	} else {
+	if (!(flags & IA64_SC_FLAG_IN_SYSCALL)) {
 		/* Copy scratch regs to sigcontext if the signal didn't interrupt a syscall. */
 		err |= __put_user(scr->pt.ar_ccv, &sc->sc_ar_ccv);		/* ar.ccv */
 		err |= __put_user(scr->pt.b7, &sc->sc_br[7]);			/* b7 */
--- a/arch/ia64/kernel/uncached.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/ia64/kernel/uncached.c	2007-12-20 14:19:21.000000000 -0500
@@ -118,7 +118,7 @@ static int uncached_add_chunk(struct unc
 	for (i = 0; i < (IA64_GRANULE_SIZE / PAGE_SIZE); i++)
 		SetPageUncached(&page[i]);
 
-	flush_tlb_kernel_range(uc_addr, uc_adddr + IA64_GRANULE_SIZE);
+	flush_tlb_kernel_range(uc_addr, uc_addr + IA64_GRANULE_SIZE);
 
 	status = ia64_pal_prefetch_visibility(PAL_VISIBILITY_PHYSICAL);
 	if (status == PAL_VISIBILITY_OK_REMOTE_NEEDED) {
--- a/arch/ia64/mm/tlb.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/ia64/mm/tlb.c	2007-12-20 14:19:21.000000000 -0500
@@ -10,6 +10,7 @@
  *              IPI based ptc implementation and A-step IPI implementation.
  * Rohit Seth <rohit.seth@intel.com>
  * Ken Chen <kenneth.w.chen@intel.com>
+ * Christophe de Dinechin <ddd@hp.com>: Avoid ptc.e on memory allocation
  */
 #include <linux/module.h>
 #include <linux/init.h>
@@ -89,9 +90,16 @@ ia64_global_tlb_purge (struct mm_struct 
 {
 	static DEFINE_SPINLOCK(ptcg_lock);
 
-	if (mm != current->active_mm || !current->mm) {
-		flush_tlb_all();
-		return;
+	struct mm_struct *active_mm = current->active_mm;
+
+	if (mm != active_mm) {
+		/* Restore region IDs for mm */
+		if (mm && active_mm) {
+			activate_context(mm);
+		} else {
+			flush_tlb_all();
+			return;
+		}
 	}
 
 	/* HW requires global serialization of ptc.ga.  */
@@ -107,6 +115,10 @@ ia64_global_tlb_purge (struct mm_struct 
 		} while (start < end);
 	}
 	spin_unlock(&ptcg_lock);
+
+        if (mm != active_mm) {
+                activate_context(active_mm);
+        }
 }
 
 void
--- a/arch/ia64/sn/kernel/bte.c	2007-07-08 19:32:17.000000000 -0400
+++ b/arch/ia64/sn/kernel/bte.c	2007-12-20 14:19:21.000000000 -0500
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (c) 2000-2006 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2007 Silicon Graphics, Inc.  All Rights Reserved.
  */
 
 #include <linux/module.h>
@@ -227,7 +227,7 @@ retry_bteop:
 		     BTE_LNSTAT_LOAD(bte), *bte->most_rcnt_na));
 
 	if (transfer_stat & IBLS_ERROR) {
-		bte_status = transfer_stat & ~IBLS_ERROR;
+		bte_status = BTE_GET_ERROR_STATUS(transfer_stat);
 	} else {
 		bte_status = BTE_SUCCESS;
 	}
--- a/arch/ia64/sn/kernel/bte_error.c	2007-07-08 19:32:17.000000000 -0400
+++ b/arch/ia64/sn/kernel/bte_error.c	2007-12-20 14:19:21.000000000 -0500
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (c) 2000-2005 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2007 Silicon Graphics, Inc.  All Rights Reserved.
  */
 
 #include <linux/types.h>
@@ -148,7 +148,11 @@ int shub2_bte_error_handler(unsigned lon
 	for (i = 0; i < BTES_PER_NODE; i++) {
 		bte = &err_nodepda->bte_if[i];
 		status = BTE_LNSTAT_LOAD(bte);
-		if ((status & IBLS_ERROR) || !(status & IBLS_BUSY))
+		if (status & IBLS_ERROR) {
+			bte->bh_error = BTE_SHUB2_ERROR(status);
+			continue;
+		}
+		if (!(status & IBLS_BUSY))
 			continue;
 		mod_timer(recovery_timer, jiffies + (HZ * 5));
 		BTE_PRINTK(("eh:%p:%d Marked Giving up\n", err_nodepda,
--- a/arch/ia64/sn/pci/tioce_provider.c	2007-10-10 17:43:37.000000000 -0400
+++ b/arch/ia64/sn/pci/tioce_provider.c	2007-12-20 14:19:21.000000000 -0500
@@ -41,7 +41,7 @@
  *	} else
  *		do desired mmr access
  *
- * According to hw, we can use reads instead of writes to the above addres
+ * According to hw, we can use reads instead of writes to the above address
  *
  * Note this WAR can only to be used for accessing internal MMR's in the
  * TIOCE Coretalk Address Range 0x0 - 0x07ff_ffff.  This includes the
--- a/arch/x86/kernel/apic_32.c	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/x86/kernel/apic_32.c	2007-12-20 14:19:21.000000000 -0500
@@ -849,7 +849,7 @@ void __init init_bsp_APIC(void)
 /**
  * setup_local_APIC - setup the local APIC
  */
-void __devinit setup_local_APIC(void)
+void __cpuinit setup_local_APIC(void)
 {
 	unsigned long oldvalue, value, maxlvt, integrated;
 	int i, j;
--- a/arch/x86/kernel/process_32.c	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/x86/kernel/process_32.c	2007-12-20 14:19:21.000000000 -0500
@@ -261,7 +261,7 @@ static void mwait_idle(void)
 	mwait_idle_with_hints(0, 0);
 }
 
-void __devinit select_idle_routine(const struct cpuinfo_x86 *c)
+void __cpuinit select_idle_routine(const struct cpuinfo_x86 *c)
 {
 	if (cpu_has(c, X86_FEATURE_MWAIT)) {
 		printk("monitor/mwait feature present.\n");
--- a/arch/x86/kernel/setup_32.c	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/x86/kernel/setup_32.c	2007-12-20 14:19:21.000000000 -0500
@@ -67,7 +67,7 @@
    address, and must not be in the .bss segment! */
 unsigned long init_pg_tables_end __initdata = ~0UL;
 
-int disable_pse __devinitdata = 0;
+int disable_pse __cpuinitdata = 0;
 
 /*
  * Machine setup..
--- a/arch/x86/kernel/smpboot_32.c	2007-12-17 16:34:07.000000000 -0500
+++ b/arch/x86/kernel/smpboot_32.c	2007-12-20 14:19:21.000000000 -0500
@@ -60,7 +60,7 @@
 #include <asm/mtrr.h>
 
 /* Set if we find a B stepping CPU */
-static int __devinitdata smp_b_stepping;
+static int __cpuinitdata smp_b_stepping;
 
 /* Number of siblings per CPU package */
 int smp_num_siblings = 1;
@@ -745,8 +745,8 @@ static inline int alloc_cpu_id(void)
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
-static struct task_struct * __devinitdata cpu_idle_tasks[NR_CPUS];
-static inline struct task_struct * alloc_idle_task(int cpu)
+static struct task_struct * __cpuinitdata cpu_idle_tasks[NR_CPUS];
+static inline struct task_struct * __cpuinit alloc_idle_task(int cpu)
 {
 	struct task_struct *idle;
 
--- a/arch/x86/kernel/smpboot_64.c	2007-12-17 16:34:07.000000000 -0500
+++ b/arch/x86/kernel/smpboot_64.c	2007-12-20 14:19:21.000000000 -0500
@@ -141,8 +141,8 @@ static void __cpuinit smp_store_cpu_info
 	struct cpuinfo_x86 *c = &cpu_data(id);
 
 	*c = boot_cpu_data;
-	c->cpu_index = id;
 	identify_cpu(c);
+	c->cpu_index = id;
 	print_cpu_info(c);
 }
 
--- a/drivers/ata/pata_hpt37x.c	2007-12-17 16:34:07.000000000 -0500
+++ b/drivers/ata/pata_hpt37x.c	2007-12-20 14:19:21.000000000 -0500
@@ -375,7 +375,7 @@ static int hpt374_pre_reset(struct ata_l
 	pci_write_config_word(pdev, mcrbase + 2, mcr3 | 0x8000);
 	pci_read_config_byte(pdev, 0x5A, &ata66);
 	/* Reset TCBLID/FCBLID to output */
-	pci_write_config_word(pdev, 0x52, mcr3);
+	pci_write_config_word(pdev, mcrbase + 2, mcr3);
 
 	if (ata66 & (2 >> ap->port_no))
 		ap->cbl = ATA_CBL_PATA40;
--- a/drivers/scsi/dpt_i2o.c	2007-12-17 16:34:11.000000000 -0500
+++ b/drivers/scsi/dpt_i2o.c	2007-12-20 14:19:21.000000000 -0500
@@ -906,8 +906,7 @@ static int adpt_install_hba(struct scsi_
 	}
 
 	pci_set_master(pDev);
-	if (pci_set_dma_mask(pDev, DMA_64BIT_MASK) &&
-	    pci_set_dma_mask(pDev, DMA_32BIT_MASK))
+	if (pci_set_dma_mask(pDev, DMA_32BIT_MASK))
 		return -EINVAL;
 
 	base_addr0_phys = pci_resource_start(pDev,0);
--- a/drivers/scsi/initio.c	2007-12-17 16:34:11.000000000 -0500
+++ b/drivers/scsi/initio.c	2007-12-20 14:19:21.000000000 -0500
@@ -2616,6 +2616,7 @@ static void initio_build_scb(struct init
 		scsi_for_each_sg(cmnd, sglist, cblk->sglen, i) {
 			sg->data = cpu_to_le32((u32)sg_dma_address(sglist));
 			total_len += sg->len = cpu_to_le32((u32)sg_dma_len(sglist));
+			++sg;
 		}
 
 		cblk->buflen = (scsi_bufflen(cmnd) > total_len) ?
@@ -2867,6 +2868,7 @@ static int initio_probe_one(struct pci_d
 	}
 	host = (struct initio_host *)shost->hostdata;
 	memset(host, 0, sizeof(struct initio_host));
+	host->addr = pci_resource_start(pdev, 0);
 
 	if (!request_region(host->addr, 256, "i91u")) {
 		printk(KERN_WARNING "initio: I/O port range 0x%x is busy.\n", host->addr);
--- a/drivers/scsi/st.c	2007-12-17 16:34:14.000000000 -0500
+++ b/drivers/scsi/st.c	2007-12-20 14:19:21.000000000 -0500
@@ -3611,6 +3611,7 @@ static struct st_buffer *
 
 	tb->dma = need_dma;
 	tb->buffer_size = got;
+	sg_init_table(tb->sg, max_sg);
 
 	return tb;
 }
--- a/drivers/scsi/sym53c8xx_2/sym_glue.c	2007-12-17 16:34:14.000000000 -0500
+++ b/drivers/scsi/sym53c8xx_2/sym_glue.c	2007-12-20 14:19:21.000000000 -0500
@@ -1243,7 +1243,7 @@ static void sym_free_resources(struct sy
 	 *  Free O/S specific resources.
 	 */
 	if (pdev->irq)
-		free_irq(pdev->irq, np);
+		free_irq(pdev->irq, np->s.host);
 	if (np->s.ioaddr)
 		pci_iounmap(pdev, np->s.ioaddr);
 	if (np->s.ramaddr)
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.c	2007-12-17 16:34:14.000000000 -0500
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.c	2007-12-20 14:19:21.000000000 -0500
@@ -2791,7 +2791,7 @@ irqreturn_t sym_interrupt(struct Scsi_Ho
 	istat = INB(np, nc_istat);
 	if (istat & INTF) {
 		OUTB(np, nc_istat, (istat & SIGP) | INTF | np->istat_sem);
-		istat = INB(np, nc_istat);		/* DUMMY READ */
+		istat |= INB(np, nc_istat);		/* DUMMY READ */
 		if (DEBUG_FLAGS & DEBUG_TINY) printf ("F ");
 		sym_wakeup_done(np);
 	}
--- a/drivers/video/ps3fb.c	2007-12-17 16:34:15.000000000 -0500
+++ b/drivers/video/ps3fb.c	2007-12-20 14:19:21.000000000 -0500
@@ -51,7 +51,8 @@
 #define L1GPU_DISPLAY_SYNC_HSYNC		1
 #define L1GPU_DISPLAY_SYNC_VSYNC		2
 
-#define GPU_CMD_BUF_SIZE			(64 * 1024)
+#define GPU_CMD_BUF_SIZE			(2 * 1024 * 1024)
+#define GPU_FB_START				(64 * 1024)
 #define GPU_IOIF				(0x0d000000UL)
 #define GPU_ALIGN_UP(x)				_ALIGN_UP((x), 64)
 #define GPU_MAX_LINE_LENGTH			(65536 - 64)
@@ -406,6 +407,7 @@ static void ps3fb_sync_image(struct devi
 	if (src_line_length != dst_line_length)
 		line_length |= (u64)src_line_length << 32;
 
+	src_offset += GPU_FB_START;
 	status = lv1_gpu_context_attribute(ps3fb.context_handle,
 					   L1GPU_CONTEXT_ATTRIBUTE_FB_BLIT,
 					   dst_offset, GPU_IOIF + src_offset,
@@ -976,9 +978,8 @@ static int ps3fb_xdr_settings(u64 xdr_lp
 
 	status = lv1_gpu_context_attribute(ps3fb.context_handle,
 					   L1GPU_CONTEXT_ATTRIBUTE_FB_SETUP,
-					   xdr_lpar + ps3fb.xdr_size,
-					   GPU_CMD_BUF_SIZE,
-					   GPU_IOIF + ps3fb.xdr_size, 0);
+					   xdr_lpar, GPU_CMD_BUF_SIZE,
+					   GPU_IOIF, 0);
 	if (status) {
 		dev_err(dev,
 			"%s: lv1_gpu_context_attribute FB_SETUP failed: %d\n",
@@ -1061,6 +1062,11 @@ static int __devinit ps3fb_probe(struct 
 	struct task_struct *task;
 	unsigned long max_ps3fb_size;
 
+	if (ps3fb_videomemory.size < GPU_CMD_BUF_SIZE) {
+		dev_err(&dev->core, "%s: Not enough video memory\n", __func__);
+		return -ENOMEM;
+	}
+
 	status = ps3_open_hv_device(dev);
 	if (status) {
 		dev_err(&dev->core, "%s: ps3_open_hv_device failed\n",
@@ -1131,8 +1137,14 @@ static int __devinit ps3fb_probe(struct 
 	/* Clear memory to prevent kernel info leakage into userspace */
 	memset(ps3fb.xdr_ea, 0, ps3fb_videomemory.size);
 
-	/* The GPU command buffer is at the end of video memory */
-	ps3fb.xdr_size = ps3fb_videomemory.size - GPU_CMD_BUF_SIZE;
+	/*
+	 * The GPU command buffer is at the start of video memory
+	 * As we don't use the full command buffer, we can put the actual
+	 * frame buffer at offset GPU_FB_START and save some precious XDR
+	 * memory
+	 */
+	ps3fb.xdr_ea += GPU_FB_START;
+	ps3fb.xdr_size = ps3fb_videomemory.size - GPU_FB_START;
 
 	retval = ps3fb_xdr_settings(xdr_lpar, &dev->core);
 	if (retval)
@@ -1200,7 +1212,7 @@ err_fb_dealloc:
 err_framebuffer_release:
 	framebuffer_release(info);
 err_free_irq:
-	free_irq(ps3fb.irq_no, dev);
+	free_irq(ps3fb.irq_no, &dev->core);
 	ps3_irq_plug_destroy(ps3fb.irq_no);
 err_iounmap_dinfo:
 	iounmap((u8 __iomem *)ps3fb.dinfo);
@@ -1235,7 +1247,7 @@ static int ps3fb_shutdown(struct ps3_sys
 		kthread_stop(task);
 	}
 	if (ps3fb.irq_no) {
-		free_irq(ps3fb.irq_no, dev);
+		free_irq(ps3fb.irq_no, &dev->core);
 		ps3_irq_plug_destroy(ps3fb.irq_no);
 	}
 	iounmap((u8 __iomem *)ps3fb.dinfo);
--- a/include/asm-ia64/bitops.h	2007-12-17 16:34:20.000000000 -0500
+++ b/include/asm-ia64/bitops.h	2007-12-20 14:19:21.000000000 -0500
@@ -124,10 +124,21 @@ clear_bit_unlock (int nr, volatile void 
 /**
  * __clear_bit_unlock - Non-atomically clear a bit with release
  *
- * This is like clear_bit_unlock, but the implementation may use a non-atomic
- * store (this one uses an atomic, however).
+ * This is like clear_bit_unlock, but the implementation uses a store
+ * with release semantics. See also __raw_spin_unlock().
  */
-#define __clear_bit_unlock clear_bit_unlock
+static __inline__ void
+__clear_bit_unlock(int nr, volatile void *addr)
+{
+	__u32 mask, new;
+	volatile __u32 *m;
+
+	m = (volatile __u32 *)addr + (nr >> 5);
+	mask = ~(1 << (nr & 31));
+	new = *m & mask;
+	barrier();
+	ia64_st4_rel_nta(m, new);
+}
 
 /**
  * __clear_bit - Clears a bit in memory (non-atomic version)
--- a/include/asm-ia64/gcc_intrin.h	2007-07-08 19:32:17.000000000 -0400
+++ b/include/asm-ia64/gcc_intrin.h	2007-12-20 14:19:21.000000000 -0500
@@ -191,6 +191,11 @@ register unsigned long ia64_r13 asm ("r1
 	asm volatile ("ldf.fill %0=[%1]" :"=f"(__f__): "r"(x));	\
 })
 
+#define ia64_st4_rel_nta(m, val)					\
+({									\
+	asm volatile ("st4.rel.nta [%0] = %1\n\t" :: "r"(m), "r"(val));	\
+})
+
 #define ia64_stfs(x, regnum)						\
 ({									\
 	register double __f__ asm ("f"#regnum);				\
--- a/include/asm-ia64/hw_irq.h	2007-10-10 17:43:48.000000000 -0400
+++ b/include/asm-ia64/hw_irq.h	2007-12-20 14:19:21.000000000 -0500
@@ -63,7 +63,7 @@ extern int ia64_last_device_vector;
 #define IA64_NUM_DEVICE_VECTORS		(IA64_LAST_DEVICE_VECTOR - IA64_FIRST_DEVICE_VECTOR + 1)
 
 #define IA64_MCA_RENDEZ_VECTOR		0xe8	/* MCA rendez interrupt */
-#define IA64_PERFMON_VECTOR		0xee	/* performanc monitor interrupt vector */
+#define IA64_PERFMON_VECTOR		0xee	/* performance monitor interrupt vector */
 #define IA64_TIMER_VECTOR		0xef	/* use highest-prio group 15 interrupt for timer */
 #define	IA64_MCA_WAKEUP_VECTOR		0xf0	/* MCA wakeup (must be >MCA_RENDEZ_VECTOR) */
 #define IA64_IPI_LOCAL_TLB_FLUSH	0xfc	/* SMP flush local TLB */
--- a/include/asm-ia64/intel_intrin.h	2007-07-08 19:32:17.000000000 -0400
+++ b/include/asm-ia64/intel_intrin.h	2007-12-20 14:19:21.000000000 -0500
@@ -110,6 +110,9 @@
 #define ia64_st4_rel		__st4_rel
 #define ia64_st8_rel		__st8_rel
 
+/* FIXME: need st4.rel.nta intrinsic */
+#define ia64_st4_rel_nta	__st4_rel
+
 #define ia64_ld1_acq		__ld1_acq
 #define ia64_ld2_acq		__ld2_acq
 #define ia64_ld4_acq		__ld4_acq
--- a/include/asm-ia64/sn/bte.h	2007-07-08 19:32:17.000000000 -0400
+++ b/include/asm-ia64/sn/bte.h	2007-12-20 14:19:21.000000000 -0500
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (c) 2000-2006 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2007 Silicon Graphics, Inc.  All Rights Reserved.
  */
 
 
@@ -150,6 +150,35 @@ typedef enum {
 	BTEFAIL_NOTAVAIL,	/* BTE not available */
 } bte_result_t;
 
+#define BTEFAIL_SH2_RESP_SHORT	0x1	/* bit 000001 */
+#define BTEFAIL_SH2_RESP_LONG	0x2	/* bit 000010 */
+#define BTEFAIL_SH2_RESP_DSP	0x4	/* bit 000100 */
+#define BTEFAIL_SH2_RESP_ACCESS	0x8	/* bit 001000 */
+#define BTEFAIL_SH2_CRB_TO	0x10	/* bit 010000 */
+#define BTEFAIL_SH2_NACK_LIMIT	0x20	/* bit 100000 */
+#define BTEFAIL_SH2_ALL		0x3F	/* bit 111111 */
+
+#define	BTE_ERR_BITS	0x3FUL
+#define	BTE_ERR_SHIFT	36
+#define BTE_ERR_MASK	(BTE_ERR_BITS << BTE_ERR_SHIFT)
+
+#define BTE_ERROR_RETRY(value)						\
+	(is_shub2() ? (value != BTEFAIL_SH2_CRB_TO)			\
+		: (value != BTEFAIL_TOUT))
+
+/*
+ * On shub1 BTE_ERR_MASK will always be false, so no need for is_shub2()
+ */
+#define BTE_SHUB2_ERROR(_status)					\
+	((_status & BTE_ERR_MASK) 					\
+	   ? (((_status >> BTE_ERR_SHIFT) & BTE_ERR_BITS) | IBLS_ERROR) \
+	   : _status)
+
+#define BTE_GET_ERROR_STATUS(_status)					\
+	(BTE_SHUB2_ERROR(_status) & ~IBLS_ERROR)
+
+#define BTE_VALID_SH2_ERROR(value)					\
+	((value >= BTEFAIL_SH2_RESP_SHORT) && (value <= BTEFAIL_SH2_ALL))
 
 /*
  * Structure defining a bte.  An instance of this
--- a/include/asm-ia64/sn/xpc.h	2007-07-08 19:32:17.000000000 -0400
+++ b/include/asm-ia64/sn/xpc.h	2007-12-20 14:19:21.000000000 -0500
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (c) 2004-2006 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2004-2007 Silicon Graphics, Inc.  All Rights Reserved.
  */
 
 
@@ -1211,6 +1211,12 @@ xpc_IPI_init(int index)
 static inline enum xpc_retval
 xpc_map_bte_errors(bte_result_t error)
 {
+	if (is_shub2()) {
+		if (BTE_VALID_SH2_ERROR(error))
+			return xpcBteSh2Start + error;
+		else
+			return xpcBteUnmappedError;
+	}
 	switch (error) {
 	case BTE_SUCCESS:	return xpcSuccess;
 	case BTEFAIL_DIR:	return xpcBteDirectoryError;
--- a/include/asm-ia64/sn/xp.h	2007-07-08 19:32:17.000000000 -0400
+++ b/include/asm-ia64/sn/xp.h	2007-12-20 14:19:21.000000000 -0500
@@ -86,7 +86,7 @@ xp_bte_copy(u64 src, u64 vdst, u64 len, 
 	BUG_ON(REGION_NUMBER(vdst) != RGN_KERNEL);
 
 	ret = bte_copy(src, pdst, len, mode, notification);
-	if (ret != BTE_SUCCESS) {
+	if ((ret != BTE_SUCCESS) && BTE_ERROR_RETRY(ret)) {
 		if (!in_interrupt()) {
 			cond_resched();
 		}
@@ -244,7 +244,30 @@ enum xpc_retval {
 
 	xpcDisconnected,	/* 51: channel disconnected (closed) */
 
-	xpcUnknownReason	/* 52: unknown reason -- must be last in list */
+	xpcBteSh2Start,		/* 52: BTE CRB timeout */
+
+				/* 53: 0x1 BTE Error Response Short */
+	xpcBteSh2RspShort = xpcBteSh2Start + BTEFAIL_SH2_RESP_SHORT,
+
+				/* 54: 0x2 BTE Error Response Long */
+	xpcBteSh2RspLong = xpcBteSh2Start + BTEFAIL_SH2_RESP_LONG,
+
+				/* 56: 0x4 BTE Error Response DSB */
+	xpcBteSh2RspDSB = xpcBteSh2Start + BTEFAIL_SH2_RESP_DSP,
+
+				/* 60: 0x8 BTE Error Response Access */
+	xpcBteSh2RspAccess = xpcBteSh2Start + BTEFAIL_SH2_RESP_ACCESS,
+
+				/* 68: 0x10 BTE Error CRB timeout */
+	xpcBteSh2CRBTO = xpcBteSh2Start + BTEFAIL_SH2_CRB_TO,
+
+				/* 84: 0x20 BTE Error NACK limit */
+	xpcBteSh2NACKLimit = xpcBteSh2Start + BTEFAIL_SH2_NACK_LIMIT,
+
+				/* 115: BTE end */
+	xpcBteSh2End = xpcBteSh2Start + BTEFAIL_SH2_ALL,
+
+	xpcUnknownReason	/* 116: unknown reason -- must be last in list */
 };
 
 
--- a/include/asm-ia64/tlbflush.h	2007-12-17 16:34:20.000000000 -0500
+++ b/include/asm-ia64/tlbflush.h	2007-12-20 14:19:21.000000000 -0500
@@ -92,6 +92,10 @@ void smp_local_flush_tlb(void);
 #define smp_local_flush_tlb()
 #endif
 
-#define flush_tlb_kernel_range(start, end)	flush_tlb_all()	/* XXX fix me */
+static inline void flush_tlb_kernel_range(unsigned long start,
+					  unsigned long end)
+{
+	flush_tlb_all();	/* XXX fix me */
+}
 
 #endif /* _ASM_IA64_TLBFLUSH_H */
--- a/Makefile	2007-12-19 14:41:26.000000000 -0500
+++ b/Makefile	2007-12-20 14:19:21.000000000 -0500
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 24
-EXTRAVERSION = -rc5-git6
+EXTRAVERSION = -rc5-git7
 NAME = Arr Matey! A Hairy Bilge Rat!
 
 # *DOCUMENTATION*
--- a/mm/filemap.c	2007-12-17 16:34:21.000000000 -0500
+++ b/mm/filemap.c	2007-12-20 14:19:21.000000000 -0500
@@ -124,6 +124,18 @@ void __remove_from_page_cache(struct pag
 	mapping->nrpages--;
 	__dec_zone_page_state(page, NR_FILE_PAGES);
 	BUG_ON(page_mapped(page));
+
+	/*
+	 * Some filesystems seem to re-dirty the page even after
+	 * the VM has canceled the dirty bit (eg ext3 journaling).
+	 *
+	 * Fix it up by doing a final dirty accounting check after
+	 * having removed the page entirely.
+	 */
+	if (PageDirty(page) && mapping_cap_account_dirty(mapping)) {
+		dec_zone_page_state(page, NR_FILE_DIRTY);
+		dec_bdi_stat(mapping->backing_dev_info, BDI_RECLAIMABLE);
+	}
 }
 
 void remove_from_page_cache(struct page *page)
