 .mailmap                               |    2 
 Documentation/x86_64/boot-options.txt  |    4 -
 MAINTAINERS                            |   39 +++++--------
 Makefile                               |    2 
 arch/i386/kernel/alternative.c         |   21 -------
 arch/i386/kernel/nmi.c                 |    8 +-
 arch/x86_64/kernel/pci-gart.c          |    6 +-
 arch/x86_64/mm/pageattr.c              |    2 
 drivers/acpi/thermal.c                 |    3 -
 drivers/block/paride/pcd.c             |    2 
 drivers/block/paride/pf.c              |    2 
 drivers/char/mxser.c                   |   48 +++++------------
 drivers/char/mxser_new.c               |   45 +++++-----------
 drivers/hwmon/w83627ehf.c              |   14 ++---
 drivers/net/depca.c                    |    3 -
 drivers/net/hamradio/baycom_ser_fdx.c  |    6 +-
 drivers/net/ppp_async.c                |    4 -
 drivers/net/sis900.c                   |   44 +++++++--------
 drivers/net/sunhme.c                   |    2 
 drivers/net/sunlance.c                 |    4 -
 drivers/net/sunqe.c                    |    4 +
 drivers/net/wireless/zd1211rw/zd_usb.c |    1 
 drivers/pci/probe.c                    |   45 ++++------------
 drivers/sbus/char/vfc_dev.c            |    3 -
 drivers/serial/8250.c                  |    8 +-
 drivers/serial/icom.c                  |    9 +--
 drivers/serial/icom.h                  |    1 
 drivers/usb/net/pegasus.c              |   17 ++++--
 drivers/usb/net/pegasus.h              |    3 -
 drivers/video/Kconfig                  |    2 
 fs/9p/vfs_inode.c                      |    2 
 fs/reiserfs/xattr.c                    |   92 ++++++++-------------------------
 include/linux/taskstats.h              |   13 ++--
 kernel/sysctl.c                        |    2 
 mm/migrate.c                           |   15 +++++
 mm/oom_kill.c                          |    4 +
 36 files changed, 195 insertions(+), 287 deletions(-)
diff -purN linux-2.6.21-rc7-git5/.mailmap linux-2.6.21-rc7-git7/.mailmap
--- linux-2.6.21-rc7-git5/.mailmap	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/.mailmap	2007-04-24 23:27:20.224043818 +0200
@@ -67,6 +67,8 @@ Koushik <raghavendra.koushik@neterion.co
 Leonid I Ananiev <leonid.i.ananiev@intel.com>
 Linas Vepstas <linas@austin.ibm.com>
 Matthieu CASTET <castet.matthieu@free.fr>
+Michael Buesch <mb@bu3sch.de>
+Michael Buesch <mbuesch@freenet.de>
 Michel DÃ¤nzer <michel@tungstengraphics.com>
 Mitesh shah <mshah@teja.com>
 Morten Welinder <terra@gnome.org>
diff -purN linux-2.6.21-rc7-git5/Documentation/x86_64/boot-options.txt linux-2.6.21-rc7-git7/Documentation/x86_64/boot-options.txt
--- linux-2.6.21-rc7-git5/Documentation/x86_64/boot-options.txt	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/Documentation/x86_64/boot-options.txt	2007-04-24 23:27:20.224043818 +0200
@@ -293,7 +293,3 @@ Debugging
 			stuck (default)
 
 Miscellaneous
-
-  noreplacement  Don't replace instructions with more appropriate ones
-		 for the CPU. This may be useful on asymmetric MP systems
-		 where some CPUs have less capabilities than others.
diff -purN linux-2.6.21-rc7-git5/MAINTAINERS linux-2.6.21-rc7-git7/MAINTAINERS
--- linux-2.6.21-rc7-git5/MAINTAINERS	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/MAINTAINERS	2007-04-24 23:27:20.224043818 +0200
@@ -1318,7 +1318,7 @@ S:	Maintained
 ETHERNET BRIDGE
 P:	Stephen Hemminger
 M:	shemminger@linux-foundation.org
-L:	bridge@lists.osdl.org
+L:	bridge@lists.linux-foundation.org
 W:	http://bridge.sourceforge.net/
 S:	Maintained
 
@@ -1355,6 +1355,11 @@ M:	kevin.curtis@farsite.co.uk
 W:	http://www.farsite.co.uk/
 S:	Supported
 
+FAULT INJECTION SUPPORT
+P:	Akinobu Mita
+M:	akinobu.mita@gmail.com
+S:	Supported
+
 FRAMEBUFFER LAYER
 P:	Antonino Daplas
 M:	adaplas@gmail.com
@@ -1690,7 +1695,7 @@ S:	Maintained
 
 IEEE 1394 SUBSYSTEM
 P:	Ben Collins
-M:	bcollins@debian.org
+M:	ben.collins@ubuntu.com
 P:	Stefan Richter
 M:	stefanr@s5r6.in-berlin.de
 L:	linux1394-devel@lists.sourceforge.net
@@ -1698,25 +1703,11 @@ W:	http://www.linux1394.org/
 T:	git kernel.org:/pub/scm/linux/kernel/git/ieee1394/linux1394-2.6.git
 S:	Maintained
 
-IEEE 1394 IPV4 DRIVER (eth1394)
-P:	Stefan Richter
-M:	stefanr@s5r6.in-berlin.de
-L:	linux1394-devel@lists.sourceforge.net
-S:	Odd Fixes
-
-IEEE 1394 PCILYNX DRIVER
-P:	Jody McIntyre
-M:	scjody@modernduck.com
-P:	Stefan Richter
-M:	stefanr@s5r6.in-berlin.de
-L:	linux1394-devel@lists.sourceforge.net
-S:	Odd Fixes
-
-IEEE 1394 RAW I/O DRIVER
-P:	Ben Collins
-M:	bcollins@debian.org
+IEEE 1394 RAW I/O DRIVER (raw1394)
 P:	Dan Dennedy
 M:	dan@dennedy.org
+P:	Stefan Richter
+M:	stefanr@s5r6.in-berlin.de
 L:	linux1394-devel@lists.sourceforge.net
 S:	Maintained
 
@@ -1951,7 +1942,7 @@ P:	Vivek Goyal
 M:	vgoyal@in.ibm.com
 P:	Haren Myneni
 M:	hbabu@us.ibm.com
-L:	fastboot@lists.osdl.org
+L:	fastboot@lists.linux-foundation.org
 L:	linux-kernel@vger.kernel.org
 W:	http://lse.sourceforge.net/kdump/
 S:	Maintained
@@ -1978,7 +1969,7 @@ S:	Maintained 
 
 KERNEL JANITORS
 P:	Several
-L:	kernel-janitors@lists.osdl.org
+L:	kernel-janitors@lists.linux-foundation.org
 W:	http://www.kerneljanitors.org/
 S:	Maintained
 
@@ -2001,7 +1992,7 @@ P:	Eric Biederman
 M:	ebiederm@xmission.com
 W:	http://www.xmission.com/~ebiederm/files/kexec/
 L:	linux-kernel@vger.kernel.org
-L:	fastboot@lists.osdl.org
+L:	fastboot@lists.linux-foundation.org
 S:	Maintained
 
 KPROBES
@@ -2339,7 +2330,7 @@ S:	Maintained
 NETEM NETWORK EMULATOR
 P:	Stephen Hemminger
 M:	shemminger@linux-foundation.org
-L:	netem@lists.osdl.org
+L:	netem@lists.linux-foundation.org
 S:	Maintained
 
 NETFILTER/IPTABLES/IPCHAINS
@@ -3068,7 +3059,7 @@ S:	Supported
 SOFTWARE SUSPEND:
 P:	Pavel Machek
 M:	pavel@suse.cz
-L:	linux-pm@lists.osdl.org
+L:	linux-pm@lists.linux-foundation.org
 S:	Maintained
 
 SONIC NETWORK DRIVER
diff -purN linux-2.6.21-rc7-git5/Makefile linux-2.6.21-rc7-git7/Makefile
--- linux-2.6.21-rc7-git5/Makefile	2007-04-24 23:25:43.773860593 +0200
+++ linux-2.6.21-rc7-git7/Makefile	2007-04-24 23:27:20.234043837 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 21
-EXTRAVERSION = -rc7-git5
+EXTRAVERSION = -rc7-git7
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff -purN linux-2.6.21-rc7-git5/arch/i386/kernel/alternative.c linux-2.6.21-rc7-git7/arch/i386/kernel/alternative.c
--- linux-2.6.21-rc7-git5/arch/i386/kernel/alternative.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/arch/i386/kernel/alternative.c	2007-04-24 23:27:20.234043837 +0200
@@ -5,15 +5,9 @@
 #include <asm/alternative.h>
 #include <asm/sections.h>
 
-static int no_replacement    = 0;
 static int smp_alt_once      = 0;
 static int debug_alternative = 0;
 
-static int __init noreplacement_setup(char *s)
-{
-	no_replacement = 1;
-	return 1;
-}
 static int __init bootonly(char *str)
 {
 	smp_alt_once = 1;
@@ -25,7 +19,6 @@ static int __init debug_alt(char *str)
 	return 1;
 }
 
-__setup("noreplacement", noreplacement_setup);
 __setup("smp-alt-boot", bootonly);
 __setup("debug-alternative", debug_alt);
 
@@ -252,9 +245,6 @@ void alternatives_smp_module_add(struct 
 	struct smp_alt_module *smp;
 	unsigned long flags;
 
-	if (no_replacement)
-		return;
-
 	if (smp_alt_once) {
 		if (boot_cpu_has(X86_FEATURE_UP))
 			alternatives_smp_unlock(locks, locks_end,
@@ -289,7 +279,7 @@ void alternatives_smp_module_del(struct 
 	struct smp_alt_module *item;
 	unsigned long flags;
 
-	if (no_replacement || smp_alt_once)
+	if (smp_alt_once)
 		return;
 
 	spin_lock_irqsave(&smp_alt, flags);
@@ -320,7 +310,7 @@ void alternatives_smp_switch(int smp)
 	return;
 #endif
 
-	if (no_replacement || smp_alt_once)
+	if (smp_alt_once)
 		return;
 	BUG_ON(!smp && (num_online_cpus() > 1));
 
@@ -386,13 +376,6 @@ extern struct paravirt_patch __start_par
 void __init alternative_instructions(void)
 {
 	unsigned long flags;
-	if (no_replacement) {
-		printk(KERN_INFO "(SMP-)alternatives turned off\n");
-		free_init_pages("SMP alternatives",
-				(unsigned long)__smp_alt_begin,
-				(unsigned long)__smp_alt_end);
-		return;
-	}
 
 	local_irq_save(flags);
 	apply_alternatives(__alt_instructions, __alt_instructions_end);
diff -purN linux-2.6.21-rc7-git5/arch/i386/kernel/nmi.c linux-2.6.21-rc7-git7/arch/i386/kernel/nmi.c
--- linux-2.6.21-rc7-git5/arch/i386/kernel/nmi.c	2007-04-24 23:25:43.783860612 +0200
+++ linux-2.6.21-rc7-git7/arch/i386/kernel/nmi.c	2007-04-24 23:27:20.234043837 +0200
@@ -126,7 +126,7 @@ int avail_to_resrv_perfctr_nmi_bit(unsig
 	int cpu;
 	BUG_ON(counter > NMI_MAX_COUNTER_BITS);
 	for_each_possible_cpu (cpu) {
-		if (test_bit(counter, &per_cpu(perfctr_nmi_owner, cpu)))
+		if (test_bit(counter, &per_cpu(perfctr_nmi_owner, cpu)[0]))
 			return 0;
 	}
 	return 1;
@@ -142,7 +142,7 @@ int avail_to_resrv_perfctr_nmi(unsigned 
 	BUG_ON(counter > NMI_MAX_COUNTER_BITS);
 
 	for_each_possible_cpu (cpu) {
-		if (test_bit(counter, &per_cpu(perfctr_nmi_owner, cpu)))
+		if (test_bit(counter, &per_cpu(perfctr_nmi_owner, cpu)[0]))
 			return 0;
 	}
 	return 1;
@@ -157,7 +157,7 @@ static int __reserve_perfctr_nmi(int cpu
 	counter = nmi_perfctr_msr_to_bit(msr);
 	BUG_ON(counter > NMI_MAX_COUNTER_BITS);
 
-	if (!test_and_set_bit(counter, &per_cpu(perfctr_nmi_owner, cpu)))
+	if (!test_and_set_bit(counter, &per_cpu(perfctr_nmi_owner, cpu)[0]))
 		return 1;
 	return 0;
 }
@@ -171,7 +171,7 @@ static void __release_perfctr_nmi(int cp
 	counter = nmi_perfctr_msr_to_bit(msr);
 	BUG_ON(counter > NMI_MAX_COUNTER_BITS);
 
-	clear_bit(counter, &per_cpu(perfctr_nmi_owner, cpu));
+	clear_bit(counter, &per_cpu(perfctr_nmi_owner, cpu)[0]);
 }
 
 int reserve_perfctr_nmi(unsigned int msr)
diff -purN linux-2.6.21-rc7-git5/arch/x86_64/kernel/pci-gart.c linux-2.6.21-rc7-git7/arch/x86_64/kernel/pci-gart.c
--- linux-2.6.21-rc7-git5/arch/x86_64/kernel/pci-gart.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/arch/x86_64/kernel/pci-gart.c	2007-04-24 23:27:20.244043856 +0200
@@ -519,7 +519,11 @@ static __init int init_k8_gatt(struct ag
 	gatt_size = (aper_size >> PAGE_SHIFT) * sizeof(u32); 
 	gatt = (void *)__get_free_pages(GFP_KERNEL, get_order(gatt_size)); 
 	if (!gatt) 
-		panic("Cannot allocate GATT table"); 
+		panic("Cannot allocate GATT table");
+	if (change_page_attr_addr((unsigned long)gatt, gatt_size >> PAGE_SHIFT, PAGE_KERNEL_NOCACHE))
+		panic("Could not set GART PTEs to uncacheable pages");
+	global_flush_tlb();
+
 	memset(gatt, 0, gatt_size); 
 	agp_gatt_table = gatt;
 
diff -purN linux-2.6.21-rc7-git5/arch/x86_64/mm/pageattr.c linux-2.6.21-rc7-git7/arch/x86_64/mm/pageattr.c
--- linux-2.6.21-rc7-git5/arch/x86_64/mm/pageattr.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/arch/x86_64/mm/pageattr.c	2007-04-24 23:27:20.244043856 +0200
@@ -81,8 +81,8 @@ static void flush_kernel_map(void *arg)
 		void *adr = page_address(pg);
 		if (cpu_has_clflush)
 			cache_flush_page(adr);
-		__flush_tlb_one(adr);
 	}
+	__flush_tlb_all();
 }
 
 static inline void flush_map(struct list_head *l)
diff -purN linux-2.6.21-rc7-git5/drivers/acpi/thermal.c linux-2.6.21-rc7-git7/drivers/acpi/thermal.c
--- linux-2.6.21-rc7-git5/drivers/acpi/thermal.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/acpi/thermal.c	2007-04-24 23:27:20.244043856 +0200
@@ -758,7 +758,8 @@ static void acpi_thermal_check(void *dat
 			del_timer(&(tz->timer));
 	} else {
 		if (timer_pending(&(tz->timer)))
-			mod_timer(&(tz->timer), (HZ * sleep_time) / 1000);
+			mod_timer(&(tz->timer),
+					jiffies + (HZ * sleep_time) / 1000);
 		else {
 			tz->timer.data = (unsigned long)tz;
 			tz->timer.function = acpi_thermal_run;
diff -purN linux-2.6.21-rc7-git5/drivers/block/paride/pcd.c linux-2.6.21-rc7-git7/drivers/block/paride/pcd.c
--- linux-2.6.21-rc7-git5/drivers/block/paride/pcd.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/block/paride/pcd.c	2007-04-24 23:27:20.254043875 +0200
@@ -140,7 +140,7 @@ enum {D_PRT, D_PRO, D_UNI, D_MOD, D_SLV,
 #include <linux/blkdev.h>
 #include <asm/uaccess.h>
 
-static spinlock_t pcd_lock;
+static DEFINE_SPINLOCK(pcd_lock);
 
 module_param(verbose, bool, 0644);
 module_param(major, int, 0);
diff -purN linux-2.6.21-rc7-git5/drivers/block/paride/pf.c linux-2.6.21-rc7-git7/drivers/block/paride/pf.c
--- linux-2.6.21-rc7-git5/drivers/block/paride/pf.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/block/paride/pf.c	2007-04-24 23:27:20.254043875 +0200
@@ -154,7 +154,7 @@ enum {D_PRT, D_PRO, D_UNI, D_MOD, D_SLV,
 #include <linux/blkpg.h>
 #include <asm/uaccess.h>
 
-static spinlock_t pf_spin_lock;
+static DEFINE_SPINLOCK(pf_spin_lock);
 
 module_param(verbose, bool, 0644);
 module_param(major, int, 0);
diff -purN linux-2.6.21-rc7-git5/drivers/char/mxser.c linux-2.6.21-rc7-git7/drivers/char/mxser.c
--- linux-2.6.21-rc7-git5/drivers/char/mxser.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/char/mxser.c	2007-04-24 23:27:20.254043875 +0200
@@ -1338,43 +1338,23 @@ static int mxser_ioctl(struct tty_struct
 		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
 		 * Caller should use TIOCGICOUNT to see which one it was
 		 */
-	case TIOCMIWAIT: {
-			DECLARE_WAITQUEUE(wait, current);
-			int ret;
+	case TIOCMIWAIT:
+		spin_lock_irqsave(&info->slock, flags);
+		cnow = info->icount;	/* note the counters on entry */
+		spin_unlock_irqrestore(&info->slock, flags);
+
+		wait_event_interruptible(info->delta_msr_wait, ({
+			cprev = cnow;
 			spin_lock_irqsave(&info->slock, flags);
-			cprev = info->icount;	/* note the counters on entry */
+			cnow = info->icount;	/* atomic copy */
 			spin_unlock_irqrestore(&info->slock, flags);
 
-			add_wait_queue(&info->delta_msr_wait, &wait);
-			while (1) {
-				spin_lock_irqsave(&info->slock, flags);
-				cnow = info->icount;	/* atomic copy */
-				spin_unlock_irqrestore(&info->slock, flags);
-
-				set_current_state(TASK_INTERRUPTIBLE);
-				if (((arg & TIOCM_RNG) &&
-						(cnow.rng != cprev.rng)) ||
-						((arg & TIOCM_DSR) &&
-						(cnow.dsr != cprev.dsr)) ||
-						((arg & TIOCM_CD) &&
-						(cnow.dcd != cprev.dcd)) ||
-						((arg & TIOCM_CTS) &&
-						(cnow.cts != cprev.cts))) {
-					ret = 0;
-					break;
-				}
-				/* see if a signal did it */
-				if (signal_pending(current)) {
-					ret = -ERESTARTSYS;
-					break;
-				}
-				cprev = cnow;
-			}
-			current->state = TASK_RUNNING;
-			remove_wait_queue(&info->delta_msr_wait, &wait);
-			break;
-		}
-		/* NOTREACHED */
+			((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+			((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+			((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+			((arg & TIOCM_CTS) && (cnow.cts != cprev.cts));
+		}));
+		break;
 		/*
 		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
 		 * Return: write counters to the user passed counter struct
diff -purN linux-2.6.21-rc7-git5/drivers/char/mxser_new.c linux-2.6.21-rc7-git7/drivers/char/mxser_new.c
--- linux-2.6.21-rc7-git5/drivers/char/mxser_new.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/char/mxser_new.c	2007-04-24 23:27:20.254043875 +0200
@@ -1758,43 +1758,23 @@ static int mxser_ioctl(struct tty_struct
 		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
 		 * Caller should use TIOCGICOUNT to see which one it was
 		 */
-	case TIOCMIWAIT: {
-		DECLARE_WAITQUEUE(wait, current);
-		int ret;
+	case TIOCMIWAIT:
 		spin_lock_irqsave(&info->slock, flags);
-		cprev = info->icount;	/* note the counters on entry */
+		cnow = info->icount;	/* note the counters on entry */
 		spin_unlock_irqrestore(&info->slock, flags);
 
-		add_wait_queue(&info->delta_msr_wait, &wait);
-		while (1) {
+		wait_event_interruptible(info->delta_msr_wait, ({
+			cprev = cnow;
 			spin_lock_irqsave(&info->slock, flags);
 			cnow = info->icount;	/* atomic copy */
 			spin_unlock_irqrestore(&info->slock, flags);
 
-			set_current_state(TASK_INTERRUPTIBLE);
-			if (((arg & TIOCM_RNG) &&
-					(cnow.rng != cprev.rng)) ||
-					((arg & TIOCM_DSR) &&
-					(cnow.dsr != cprev.dsr)) ||
-					((arg & TIOCM_CD) &&
-					(cnow.dcd != cprev.dcd)) ||
-					((arg & TIOCM_CTS) &&
-					(cnow.cts != cprev.cts))) {
-				ret = 0;
-				break;
-			}
-			/* see if a signal did it */
-			if (signal_pending(current)) {
-				ret = -ERESTARTSYS;
-				break;
-			}
-			cprev = cnow;
-		}
-		current->state = TASK_RUNNING;
-		remove_wait_queue(&info->delta_msr_wait, &wait);
+			((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+			((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+			((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+			((arg & TIOCM_CTS) && (cnow.cts != cprev.cts));
+		}));
 		break;
-	}
-	/* NOTREACHED */
 	/*
 	 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
 	 * Return: write counters to the user passed counter struct
@@ -2230,7 +2210,14 @@ end_intr:
 	port->mon_data.rxcnt += cnt;
 	port->mon_data.up_rxcnt += cnt;
 
+	/*
+	 * We are called from an interrupt context with &port->slock
+	 * being held. Drop it temporarily in order to prevent
+	 * recursive locking.
+	 */
+	spin_unlock(&port->slock);
 	tty_flip_buffer_push(tty);
+	spin_lock(&port->slock);
 }
 
 static void mxser_transmit_chars(struct mxser_port *port)
diff -purN linux-2.6.21-rc7-git5/drivers/hwmon/w83627ehf.c linux-2.6.21-rc7-git7/drivers/hwmon/w83627ehf.c
--- linux-2.6.21-rc7-git5/drivers/hwmon/w83627ehf.c	2007-04-24 23:25:43.793860631 +0200
+++ linux-2.6.21-rc7-git7/drivers/hwmon/w83627ehf.c	2007-04-24 23:27:20.254043875 +0200
@@ -121,9 +121,9 @@ superio_exit(void)
  * ISA constants
  */
 
-#define REGION_ALIGNMENT	~7
-#define REGION_OFFSET		5
-#define REGION_LENGTH		2
+#define IOREGION_ALIGNMENT	~7
+#define IOREGION_OFFSET		5
+#define IOREGION_LENGTH		2
 #define ADDR_REG_OFFSET		5
 #define DATA_REG_OFFSET		6
 
@@ -1194,7 +1194,7 @@ static int w83627ehf_detect(struct i2c_a
 	u8 fan4pin, fan5pin;
 	int i, err = 0;
 
-	if (!request_region(address + REGION_OFFSET, REGION_LENGTH,
+	if (!request_region(address + IOREGION_OFFSET, IOREGION_LENGTH,
 	                    w83627ehf_driver.driver.name)) {
 		err = -EBUSY;
 		goto exit;
@@ -1322,7 +1322,7 @@ exit_remove:
 exit_free:
 	kfree(data);
 exit_release:
-	release_region(address + REGION_OFFSET, REGION_LENGTH);
+	release_region(address + IOREGION_OFFSET, IOREGION_LENGTH);
 exit:
 	return err;
 }
@@ -1337,7 +1337,7 @@ static int w83627ehf_detach_client(struc
 
 	if ((err = i2c_detach_client(client)))
 		return err;
-	release_region(client->addr + REGION_OFFSET, REGION_LENGTH);
+	release_region(client->addr + IOREGION_OFFSET, IOREGION_LENGTH);
 	kfree(data);
 
 	return 0;
@@ -1380,7 +1380,7 @@ static int __init w83627ehf_find(int sio
 	superio_select(W83627EHF_LD_HWM);
 	val = (superio_inb(SIO_REG_ADDR) << 8)
 	    | superio_inb(SIO_REG_ADDR + 1);
-	*addr = val & REGION_ALIGNMENT;
+	*addr = val & IOREGION_ALIGNMENT;
 	if (*addr == 0) {
 		superio_exit();
 		return -ENODEV;
diff -purN linux-2.6.21-rc7-git5/drivers/net/depca.c linux-2.6.21-rc7-git7/drivers/net/depca.c
--- linux-2.6.21-rc7-git5/drivers/net/depca.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/depca.c	2007-04-24 23:27:20.264043894 +0200
@@ -1491,8 +1491,9 @@ static void __init depca_platform_probe 
 		depca_io_ports[i].device = pldev;
 
 		if (platform_device_add(pldev)) {
-			platform_device_put(pldev);
 			depca_io_ports[i].device = NULL;
+			pldev->dev.platform_data = NULL;
+			platform_device_put(pldev);
 			continue;
 		}
 
diff -purN linux-2.6.21-rc7-git5/drivers/net/hamradio/baycom_ser_fdx.c linux-2.6.21-rc7-git7/drivers/net/hamradio/baycom_ser_fdx.c
--- linux-2.6.21-rc7-git5/drivers/net/hamradio/baycom_ser_fdx.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/hamradio/baycom_ser_fdx.c	2007-04-24 23:27:20.274043913 +0200
@@ -75,12 +75,14 @@
 #include <linux/ioport.h>
 #include <linux/string.h>
 #include <linux/init.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
 #include <linux/hdlcdrv.h>
 #include <linux/baycom.h>
 #include <linux/jiffies.h>
 
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
 /* --------------------------------------------------------------------- */
 
 #define BAYCOM_DEBUG
diff -purN linux-2.6.21-rc7-git5/drivers/net/ppp_async.c linux-2.6.21-rc7-git7/drivers/net/ppp_async.c
--- linux-2.6.21-rc7-git5/drivers/net/ppp_async.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/ppp_async.c	2007-04-24 23:27:20.274043913 +0200
@@ -802,9 +802,9 @@ process_input_packet(struct asyncppp *ap
 
 	/* check for address/control and protocol compression */
 	p = skb->data;
-	if (p[0] == PPP_ALLSTATIONS && p[1] == PPP_UI) {
+	if (p[0] == PPP_ALLSTATIONS) {
 		/* chop off address/control */
-		if (skb->len < 3)
+		if (p[1] != PPP_UI || skb->len < 3)
 			goto err;
 		p = skb_pull(skb, 2);
 	}
diff -purN linux-2.6.21-rc7-git5/drivers/net/sis900.c linux-2.6.21-rc7-git7/drivers/net/sis900.c
--- linux-2.6.21-rc7-git5/drivers/net/sis900.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/sis900.c	2007-04-24 23:27:20.274043913 +0200
@@ -1755,6 +1755,24 @@ static int sis900_rx(struct net_device *
 		} else {
 			struct sk_buff * skb;
 
+			pci_unmap_single(sis_priv->pci_dev,
+				sis_priv->rx_ring[entry].bufptr, RX_BUF_SIZE,
+				PCI_DMA_FROMDEVICE);
+
+			/* refill the Rx buffer, what if there is not enought
+			 * memory for new socket buffer ?? */
+			if ((skb = dev_alloc_skb(RX_BUF_SIZE)) == NULL) {
+				/*
+				 * Not enough memory to refill the buffer
+				 * so we need to recycle the old one so
+				 * as to avoid creating a memory hole
+				 * in the rx ring
+				 */
+				skb = sis_priv->rx_skbuff[entry];
+				sis_priv->stats.rx_dropped++;
+				goto refill_rx_ring;
+			}	
+
 			/* This situation should never happen, but due to
 			   some unknow bugs, it is possible that
 			   we are working on NULL sk_buff :-( */
@@ -1768,9 +1786,6 @@ static int sis900_rx(struct net_device *
 				break;
 			}
 
-			pci_unmap_single(sis_priv->pci_dev,
-				sis_priv->rx_ring[entry].bufptr, RX_BUF_SIZE,
-				PCI_DMA_FROMDEVICE);
 			/* give the socket buffer to upper layers */
 			skb = sis_priv->rx_skbuff[entry];
 			skb_put(skb, rx_size);
@@ -1783,33 +1798,14 @@ static int sis900_rx(struct net_device *
 			net_dev->last_rx = jiffies;
 			sis_priv->stats.rx_bytes += rx_size;
 			sis_priv->stats.rx_packets++;
-
-			/* refill the Rx buffer, what if there is not enought
-			 * memory for new socket buffer ?? */
-			if ((skb = dev_alloc_skb(RX_BUF_SIZE)) == NULL) {
-				/* not enough memory for skbuff, this makes a
-				 * "hole" on the buffer ring, it is not clear
-				 * how the hardware will react to this kind
-				 * of degenerated buffer */
-				if (netif_msg_rx_status(sis_priv))
-					printk(KERN_INFO "%s: Memory squeeze,"
-						"deferring packet.\n",
-						net_dev->name);
-				sis_priv->rx_skbuff[entry] = NULL;
-				/* reset buffer descriptor state */
-				sis_priv->rx_ring[entry].cmdsts = 0;
-				sis_priv->rx_ring[entry].bufptr = 0;
-				sis_priv->stats.rx_dropped++;
-				sis_priv->cur_rx++;
-				break;
-			}
+			sis_priv->dirty_rx++;
+refill_rx_ring:
 			skb->dev = net_dev;
 			sis_priv->rx_skbuff[entry] = skb;
 			sis_priv->rx_ring[entry].cmdsts = RX_BUF_SIZE;
                 	sis_priv->rx_ring[entry].bufptr =
 				pci_map_single(sis_priv->pci_dev, skb->data,
 					RX_BUF_SIZE, PCI_DMA_FROMDEVICE);
-			sis_priv->dirty_rx++;
 		}
 		sis_priv->cur_rx++;
 		entry = sis_priv->cur_rx % NUM_RX_DESC;
diff -purN linux-2.6.21-rc7-git5/drivers/net/sunhme.c linux-2.6.21-rc7-git7/drivers/net/sunhme.c
--- linux-2.6.21-rc7-git5/drivers/net/sunhme.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/sunhme.c	2007-04-24 23:27:20.284043932 +0200
@@ -3314,7 +3314,7 @@ static int __devexit hme_sbus_remove(str
 	struct happy_meal *hp = dev_get_drvdata(&dev->dev);
 	struct net_device *net_dev = hp->dev;
 
-	unregister_netdevice(net_dev);
+	unregister_netdev(net_dev);
 
 	/* XXX qfe parent interrupt... */
 
diff -purN linux-2.6.21-rc7-git5/drivers/net/sunlance.c linux-2.6.21-rc7-git7/drivers/net/sunlance.c
--- linux-2.6.21-rc7-git5/drivers/net/sunlance.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/sunlance.c	2007-04-24 23:27:20.284043932 +0200
@@ -1550,7 +1550,7 @@ static int __exit sunlance_sun4_remove(v
 	struct lance_private *lp = dev_get_drvdata(&sun4_sdev.ofdev.dev);
 	struct net_device *net_dev = lp->dev;
 
-	unregister_netdevice(net_dev);
+	unregister_netdev(net_dev);
 
 	lance_free_hwresources(lp);
 
@@ -1590,7 +1590,7 @@ static int __devexit sunlance_sbus_remov
 	struct lance_private *lp = dev_get_drvdata(&dev->dev);
 	struct net_device *net_dev = lp->dev;
 
-	unregister_netdevice(net_dev);
+	unregister_netdev(net_dev);
 
 	lance_free_hwresources(lp);
 
diff -purN linux-2.6.21-rc7-git5/drivers/net/sunqe.c linux-2.6.21-rc7-git7/drivers/net/sunqe.c
--- linux-2.6.21-rc7-git5/drivers/net/sunqe.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/sunqe.c	2007-04-24 23:27:20.284043932 +0200
@@ -845,6 +845,8 @@ static int __init qec_ether_init(struct 
 	if (!dev)
 		return -ENOMEM;
 
+	memcpy(dev->dev_addr, idprom->id_ethaddr, 6);
+
 	qe = netdev_priv(dev);
 
 	i = of_getintprop_default(sdev->ofdev.node, "channel#", -1);
@@ -960,7 +962,7 @@ static int __devexit qec_sbus_remove(str
 	struct sunqe *qp = dev_get_drvdata(&dev->dev);
 	struct net_device *net_dev = qp->dev;
 
-	unregister_netdevice(net_dev);
+	unregister_netdev(net_dev);
 
 	sbus_iounmap(qp->qcregs, CREG_REG_SIZE);
 	sbus_iounmap(qp->mregs, MREGS_REG_SIZE);
diff -purN linux-2.6.21-rc7-git5/drivers/net/wireless/zd1211rw/zd_usb.c linux-2.6.21-rc7-git7/drivers/net/wireless/zd1211rw/zd_usb.c
--- linux-2.6.21-rc7-git5/drivers/net/wireless/zd1211rw/zd_usb.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/net/wireless/zd1211rw/zd_usb.c	2007-04-24 23:27:20.284043932 +0200
@@ -62,6 +62,7 @@ static struct usb_device_id usb_ids[] = 
 	{ USB_DEVICE(0x0471, 0x1236), .driver_info = DEVICE_ZD1211B },
 	{ USB_DEVICE(0x13b1, 0x0024), .driver_info = DEVICE_ZD1211B },
 	{ USB_DEVICE(0x0586, 0x340f), .driver_info = DEVICE_ZD1211B },
+	{ USB_DEVICE(0x0baf, 0x0121), .driver_info = DEVICE_ZD1211B },
 	/* "Driverless" devices that need ejecting */
 	{ USB_DEVICE(0x0ace, 0x2011), .driver_info = DEVICE_INSTALLER },
 	{}
diff -purN linux-2.6.21-rc7-git5/drivers/pci/probe.c linux-2.6.21-rc7-git7/drivers/pci/probe.c
--- linux-2.6.21-rc7-git5/drivers/pci/probe.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/pci/probe.c	2007-04-24 23:27:20.284043932 +0200
@@ -682,34 +682,7 @@ static void pci_read_irq(struct pci_dev 
 	dev->irq = irq;
 }
 
-static void change_legacy_io_resource(struct pci_dev * dev, unsigned index,
-                                      unsigned start, unsigned end)
-{
-	unsigned base = start & PCI_BASE_ADDRESS_IO_MASK;
-	unsigned len = (end | ~PCI_BASE_ADDRESS_IO_MASK) - base + 1;
-
-	/*
-	 * Some X versions get confused when the BARs reported through
-	 * /sys or /proc differ from those seen in config space, thus
-	 * try to update the config space values, too.
-	 */
-	if (!(pci_resource_flags(dev, index) & IORESOURCE_IO))
-		printk(KERN_WARNING "%s: cannot adjust BAR%u (not I/O)\n",
-		       pci_name(dev), index);
-	else if (pci_resource_len(dev, index) != len)
-		printk(KERN_WARNING "%s: cannot adjust BAR%u (size %04X)\n",
-		       pci_name(dev), index, (unsigned)pci_resource_len(dev, index));
-	else {
-		printk(KERN_INFO "%s: trying to change BAR%u from %04X to %04X\n",
-		       pci_name(dev), index,
-		       (unsigned)pci_resource_start(dev, index), base);
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0 + index * 4, base);
-	}
-	pci_resource_start(dev, index) = start;
-	pci_resource_end(dev, index)   = end;
-	pci_resource_flags(dev, index) =
-		IORESOURCE_IO | IORESOURCE_PCI_FIXED | PCI_BASE_ADDRESS_SPACE_IO;
-}
+#define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 /**
  * pci_setup_device - fill in class and map information of a device
@@ -762,12 +735,20 @@ static int pci_setup_device(struct pci_d
 			u8 progif;
 			pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
 			if ((progif & 1) == 0) {
-				change_legacy_io_resource(dev, 0, 0x1F0, 0x1F7);
-				change_legacy_io_resource(dev, 1, 0x3F6, 0x3F6);
+				dev->resource[0].start = 0x1F0;
+				dev->resource[0].end = 0x1F7;
+				dev->resource[0].flags = LEGACY_IO_RESOURCE;
+				dev->resource[1].start = 0x3F6;
+				dev->resource[1].end = 0x3F6;
+				dev->resource[1].flags = LEGACY_IO_RESOURCE;
 			}
 			if ((progif & 4) == 0) {
-				change_legacy_io_resource(dev, 2, 0x170, 0x177);
-				change_legacy_io_resource(dev, 3, 0x376, 0x376);
+				dev->resource[2].start = 0x170;
+				dev->resource[2].end = 0x177;
+				dev->resource[2].flags = LEGACY_IO_RESOURCE;
+				dev->resource[3].start = 0x376;
+				dev->resource[3].end = 0x376;
+				dev->resource[3].flags = LEGACY_IO_RESOURCE;
 			}
 		}
 		break;
diff -purN linux-2.6.21-rc7-git5/drivers/sbus/char/vfc_dev.c linux-2.6.21-rc7-git7/drivers/sbus/char/vfc_dev.c
--- linux-2.6.21-rc7-git5/drivers/sbus/char/vfc_dev.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/sbus/char/vfc_dev.c	2007-04-24 23:27:20.284043932 +0200
@@ -259,11 +259,10 @@ static int vfc_debug(struct vfc_dev *dev
 		if (copy_from_user(&inout, argp, sizeof(inout)))
 			return -EFAULT;
 
-		buffer = kmalloc(inout.len, GFP_KERNEL);
+		buffer = kzalloc(inout.len, GFP_KERNEL);
 		if (buffer == NULL)
 			return -ENOMEM;
 
-		memset(buffer,0,inout.len);
 		vfc_lock_device(dev);
 		inout.ret=
 			vfc_i2c_recvbuf(dev,inout.addr & 0xff
diff -purN linux-2.6.21-rc7-git5/drivers/serial/8250.c linux-2.6.21-rc7-git7/drivers/serial/8250.c
--- linux-2.6.21-rc7-git5/drivers/serial/8250.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/serial/8250.c	2007-04-24 23:27:20.284043932 +0200
@@ -1310,7 +1310,8 @@ static unsigned int check_modem_status(s
 {
 	unsigned int status = serial_in(up, UART_MSR);
 
-	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI) {
+	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
+	    up->port.info != NULL) {
 		if (status & UART_MSR_TERI)
 			up->port.icount.rng++;
 		if (status & UART_MSR_DDSR)
@@ -1333,8 +1334,9 @@ static inline void
 serial8250_handle_port(struct uart_8250_port *up)
 {
 	unsigned int status;
+	unsigned long flags;
 
-	spin_lock(&up->port.lock);
+	spin_lock_irqsave(&up->port.lock, flags);
 
 	status = serial_inp(up, UART_LSR);
 
@@ -1346,7 +1348,7 @@ serial8250_handle_port(struct uart_8250_
 	if (status & UART_LSR_THRE)
 		transmit_chars(up);
 
-	spin_unlock(&up->port.lock);
+	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
 /*
diff -purN linux-2.6.21-rc7-git5/drivers/serial/icom.c linux-2.6.21-rc7-git7/drivers/serial/icom.c
--- linux-2.6.21-rc7-git5/drivers/serial/icom.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/serial/icom.c	2007-04-24 23:27:20.294043951 +0200
@@ -164,7 +164,7 @@ static void free_port_memory(struct icom
 	}
 }
 
-static int __init get_port_memory(struct icom_port *icom_port)
+static int __devinit get_port_memory(struct icom_port *icom_port)
 {
 	int index;
 	unsigned long stgAddr;
@@ -1380,7 +1380,7 @@ static void icom_port_active(struct icom
 			    0x8024 + 2 - 2 * (icom_port->port - 2);
 	}
 }
-static int __init icom_load_ports(struct icom_adapter *icom_adapter)
+static int __devinit icom_load_ports(struct icom_adapter *icom_adapter)
 {
 	struct icom_port *icom_port;
 	int port_num;
@@ -1473,7 +1473,7 @@ static void icom_remove_adapter(struct i
 		}
 	}
 
-	free_irq(icom_adapter->irq_number, (void *) icom_adapter);
+	free_irq(icom_adapter->pci_dev->irq, (void *) icom_adapter);
 	iounmap(icom_adapter->base_addr);
 	icom_free_adapter(icom_adapter);
 	pci_release_regions(icom_adapter->pci_dev);
@@ -1539,7 +1539,6 @@ static int __devinit icom_probe(struct p
 	}
 
 	 icom_adapter->base_addr_pci = pci_resource_start(dev, 0);
-	 icom_adapter->irq_number = dev->irq;
 	 icom_adapter->pci_dev = dev;
 	 icom_adapter->version = ent->driver_data;
 	 icom_adapter->subsystem_id = ent->subdevice;
@@ -1570,7 +1569,7 @@ static int __devinit icom_probe(struct p
 		icom_port = &icom_adapter->port_info[index];
 
 		if (icom_port->status == ICOM_PORT_ACTIVE) {
-			icom_port->uart_port.irq = icom_port->adapter->irq_number;
+			icom_port->uart_port.irq = icom_port->adapter->pci_dev->irq;
 			icom_port->uart_port.type = PORT_ICOM;
 			icom_port->uart_port.iotype = UPIO_MEM;
 			icom_port->uart_port.membase =
diff -purN linux-2.6.21-rc7-git5/drivers/serial/icom.h linux-2.6.21-rc7-git7/drivers/serial/icom.h
--- linux-2.6.21-rc7-git5/drivers/serial/icom.h	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/serial/icom.h	2007-04-24 23:27:20.294043951 +0200
@@ -258,7 +258,6 @@ struct icom_port {
 struct icom_adapter {
 	void __iomem * base_addr;
 	unsigned long base_addr_pci;
-	unsigned char irq_number;
 	struct pci_dev *pci_dev;
 	struct icom_port port_info[4];
 	int index;
diff -purN linux-2.6.21-rc7-git5/drivers/usb/net/pegasus.c linux-2.6.21-rc7-git7/drivers/usb/net/pegasus.c
--- linux-2.6.21-rc7-git5/drivers/usb/net/pegasus.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/usb/net/pegasus.c	2007-04-24 23:27:20.294043951 +0200
@@ -316,6 +316,7 @@ static int update_eth_regs_async(pegasus
 	return ret;
 }
 
+/* Returns 0 on success, error on failure */
 static int read_mii_word(pegasus_t * pegasus, __u8 phy, __u8 indx, __u16 * regd)
 {
 	int i;
@@ -847,10 +848,16 @@ static void intr_callback(struct urb *ur
 		 * d[0].NO_CARRIER kicks in only with failed TX.
 		 * ... so monitoring with MII may be safest.
 		 */
-		if (d[0] & NO_CARRIER)
-			netif_carrier_off(net);	
-		else
-			netif_carrier_on(net);
+		if (pegasus->features & TRUST_LINK_STATUS) {
+			if (d[5] & LINK_STATUS)
+				netif_carrier_on(net);
+			else
+				netif_carrier_off(net);
+		} else {
+			/* Never set carrier _on_ based on ! NO_CARRIER */
+			if (d[0] & NO_CARRIER)
+				netif_carrier_off(net);	
+		}
 
 		/* bytes 3-4 == rx_lostpkt, reg 2E/2F */
 		pegasus->stats.rx_missed_errors += ((d[3] & 0x7f) << 8) | d[4];
@@ -950,7 +957,7 @@ static void set_carrier(struct net_devic
 	pegasus_t *pegasus = netdev_priv(net);
 	u16 tmp;
 
-	if (!read_mii_word(pegasus, pegasus->phy, MII_BMSR, &tmp))
+	if (read_mii_word(pegasus, pegasus->phy, MII_BMSR, &tmp))
 		return;
 
 	if (tmp & BMSR_LSTATUS)
diff -purN linux-2.6.21-rc7-git5/drivers/usb/net/pegasus.h linux-2.6.21-rc7-git7/drivers/usb/net/pegasus.h
--- linux-2.6.21-rc7-git5/drivers/usb/net/pegasus.h	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/usb/net/pegasus.h	2007-04-24 23:27:20.294043951 +0200
@@ -11,6 +11,7 @@
 
 #define	PEGASUS_II		0x80000000
 #define	HAS_HOME_PNA		0x40000000
+#define	TRUST_LINK_STATUS	0x20000000
 
 #define	PEGASUS_MTU		1536
 #define	RX_SKBS			4
@@ -203,7 +204,7 @@ PEGASUS_DEV( "AEI USB Fast Ethernet Adap
 PEGASUS_DEV( "Allied Telesyn Int. AT-USB100", VENDOR_ALLIEDTEL, 0xb100,
 		DEFAULT_GPIO_RESET | PEGASUS_II )
 PEGASUS_DEV( "Belkin F5D5050 USB Ethernet", VENDOR_BELKIN, 0x0121,
-		DEFAULT_GPIO_RESET | PEGASUS_II )
+		DEFAULT_GPIO_RESET | PEGASUS_II | TRUST_LINK_STATUS )
 PEGASUS_DEV( "Billionton USB-100", VENDOR_BILLIONTON, 0x0986,
 		DEFAULT_GPIO_RESET )
 PEGASUS_DEV( "Billionton USBLP-100", VENDOR_BILLIONTON, 0x0987,
diff -purN linux-2.6.21-rc7-git5/drivers/video/Kconfig linux-2.6.21-rc7-git7/drivers/video/Kconfig
--- linux-2.6.21-rc7-git5/drivers/video/Kconfig	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/drivers/video/Kconfig	2007-04-24 23:27:20.294043951 +0200
@@ -139,7 +139,7 @@ config FB_TILEBLITTING
 	 This is particularly important to one driver, matroxfb.  If
 	 unsure, say N.
 
-comment "Frambuffer hardware drivers"
+comment "Frame buffer hardware drivers"
 	depends on FB
 
 config FB_CIRRUS
diff -purN linux-2.6.21-rc7-git5/fs/9p/vfs_inode.c linux-2.6.21-rc7-git7/fs/9p/vfs_inode.c
--- linux-2.6.21-rc7-git5/fs/9p/vfs_inode.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/fs/9p/vfs_inode.c	2007-04-24 23:27:20.294043951 +0200
@@ -415,7 +415,7 @@ static int v9fs_remove(struct inode *dir
 	file_inode = file->d_inode;
 	sb = file_inode->i_sb;
 	v9ses = v9fs_inode2v9ses(file_inode);
-	v9fid = v9fs_fid_lookup(file);
+	v9fid = v9fs_fid_clone(file);
 	if(IS_ERR(v9fid))
 		return PTR_ERR(v9fid);
 
diff -purN linux-2.6.21-rc7-git5/fs/reiserfs/xattr.c linux-2.6.21-rc7-git7/fs/reiserfs/xattr.c
--- linux-2.6.21-rc7-git5/fs/reiserfs/xattr.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/fs/reiserfs/xattr.c	2007-04-24 23:27:20.294043951 +0200
@@ -54,82 +54,48 @@
 static struct reiserfs_xattr_handler *find_xattr_handler_prefix(const char
 								*prefix);
 
-static struct dentry *create_xa_root(struct super_block *sb)
+/* Returns the dentry referring to the root of the extended attribute
+ * directory tree. If it has already been retrieved, it is used. If it
+ * hasn't been created and the flags indicate creation is allowed, we
+ * attempt to create it. On error, we return a pointer-encoded error.
+ */
+static struct dentry *get_xa_root(struct super_block *sb, int flags)
 {
 	struct dentry *privroot = dget(REISERFS_SB(sb)->priv_root);
 	struct dentry *xaroot;
 
 	/* This needs to be created at mount-time */
 	if (!privroot)
-		return ERR_PTR(-EOPNOTSUPP);
+		return ERR_PTR(-ENODATA);
 
-	xaroot = lookup_one_len(XAROOT_NAME, privroot, strlen(XAROOT_NAME));
-	if (IS_ERR(xaroot)) {
+	mutex_lock(&privroot->d_inode->i_mutex);
+	if (REISERFS_SB(sb)->xattr_root) {
+		xaroot = dget(REISERFS_SB(sb)->xattr_root);
 		goto out;
-	} else if (!xaroot->d_inode) {
-		int err;
-		mutex_lock(&privroot->d_inode->i_mutex);
-		err =
-		    privroot->d_inode->i_op->mkdir(privroot->d_inode, xaroot,
-						   0700);
-		mutex_unlock(&privroot->d_inode->i_mutex);
-
-		if (err) {
-			dput(xaroot);
-			dput(privroot);
-			return ERR_PTR(err);
-		}
-		REISERFS_SB(sb)->xattr_root = dget(xaroot);
 	}
 
-      out:
-	dput(privroot);
-	return xaroot;
-}
-
-/* This will return a dentry, or error, refering to the xa root directory.
- * If the xa root doesn't exist yet, the dentry will be returned without
- * an associated inode. This dentry can be used with ->mkdir to create
- * the xa directory. */
-static struct dentry *__get_xa_root(struct super_block *s)
-{
-	struct dentry *privroot = dget(REISERFS_SB(s)->priv_root);
-	struct dentry *xaroot = NULL;
-
-	if (IS_ERR(privroot) || !privroot)
-		return privroot;
-
 	xaroot = lookup_one_len(XAROOT_NAME, privroot, strlen(XAROOT_NAME));
 	if (IS_ERR(xaroot)) {
 		goto out;
 	} else if (!xaroot->d_inode) {
-		dput(xaroot);
-		xaroot = NULL;
-		goto out;
+		int err = -ENODATA;
+		if (flags == 0 || flags & XATTR_CREATE)
+			err = privroot->d_inode->i_op->mkdir(privroot->d_inode,
+			                                     xaroot, 0700);
+		if (err) {
+			dput(xaroot);
+			xaroot = ERR_PTR(err);
+			goto out;
+		}
 	}
-
-	REISERFS_SB(s)->xattr_root = dget(xaroot);
+	REISERFS_SB(sb)->xattr_root = dget(xaroot);
 
       out:
+	mutex_unlock(&privroot->d_inode->i_mutex);
 	dput(privroot);
 	return xaroot;
 }
 
-/* Returns the dentry (or NULL) referring to the root of the extended
- * attribute directory tree. If it has already been retrieved, it is used.
- * Otherwise, we attempt to retrieve it from disk. It may also return
- * a pointer-encoded error.
- */
-static inline struct dentry *get_xa_root(struct super_block *s)
-{
-	struct dentry *dentry = dget(REISERFS_SB(s)->xattr_root);
-
-	if (!dentry)
-		dentry = __get_xa_root(s);
-
-	return dentry;
-}
-
 /* Opens the directory corresponding to the inode's extended attribute store.
  * If flags allow, the tree to the directory may be created. If creation is
  * prohibited, -ENODATA is returned. */
@@ -138,21 +104,11 @@ static struct dentry *open_xa_dir(const 
 	struct dentry *xaroot, *xadir;
 	char namebuf[17];
 
-	xaroot = get_xa_root(inode->i_sb);
-	if (IS_ERR(xaroot)) {
+	xaroot = get_xa_root(inode->i_sb, flags);
+	if (IS_ERR(xaroot))
 		return xaroot;
-	} else if (!xaroot) {
-		if (flags == 0 || flags & XATTR_CREATE) {
-			xaroot = create_xa_root(inode->i_sb);
-			if (IS_ERR(xaroot))
-				return xaroot;
-		}
-		if (!xaroot)
-			return ERR_PTR(-ENODATA);
-	}
 
 	/* ok, we have xaroot open */
-
 	snprintf(namebuf, sizeof(namebuf), "%X.%X",
 		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
 		 inode->i_generation);
@@ -821,7 +777,7 @@ int reiserfs_delete_xattrs(struct inode 
 
 	/* Leftovers besides . and .. -- that's not good. */
 	if (dir->d_inode->i_nlink <= 2) {
-		root = get_xa_root(inode->i_sb);
+		root = get_xa_root(inode->i_sb, XATTR_REPLACE);
 		reiserfs_write_lock_xattrs(inode->i_sb);
 		err = vfs_rmdir(root->d_inode, dir);
 		reiserfs_write_unlock_xattrs(inode->i_sb);
diff -purN linux-2.6.21-rc7-git5/include/linux/taskstats.h linux-2.6.21-rc7-git7/include/linux/taskstats.h
--- linux-2.6.21-rc7-git5/include/linux/taskstats.h	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/include/linux/taskstats.h	2007-04-24 23:27:20.304043970 +0200
@@ -31,7 +31,7 @@
  */
 
 
-#define TASKSTATS_VERSION	3
+#define TASKSTATS_VERSION	4
 #define TS_COMM_LEN		32	/* should be >= TASK_COMM_LEN
 					 * in linux/sched.h */
 
@@ -66,7 +66,7 @@ struct taskstats {
 	/* Delay waiting for cpu, while runnable
 	 * count, delay_total NOT updated atomically
 	 */
-	__u64	cpu_count;
+	__u64	cpu_count __attribute__((aligned(8)));
 	__u64	cpu_delay_total;
 
 	/* Following four fields atomically updated using task->delays->lock */
@@ -101,14 +101,17 @@ struct taskstats {
 
 	/* Basic Accounting Fields start */
 	char	ac_comm[TS_COMM_LEN];	/* Command name */
-	__u8	ac_sched;		/* Scheduling discipline */
+	__u8	ac_sched __attribute__((aligned(8)));
+					/* Scheduling discipline */
 	__u8	ac_pad[3];
-	__u32	ac_uid;			/* User ID */
+	__u32	ac_uid __attribute__((aligned(8)));
+					/* User ID */
 	__u32	ac_gid;			/* Group ID */
 	__u32	ac_pid;			/* Process ID */
 	__u32	ac_ppid;		/* Parent process ID */
 	__u32	ac_btime;		/* Begin time [sec since 1970] */
-	__u64	ac_etime;		/* Elapsed time [usec] */
+	__u64	ac_etime __attribute__((aligned(8)));
+					/* Elapsed time [usec] */
 	__u64	ac_utime;		/* User CPU time [usec] */
 	__u64	ac_stime;		/* SYstem CPU time [usec] */
 	__u64	ac_minflt;		/* Minor Page Fault Count */
diff -purN linux-2.6.21-rc7-git5/kernel/sysctl.c linux-2.6.21-rc7-git7/kernel/sysctl.c
--- linux-2.6.21-rc7-git5/kernel/sysctl.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/kernel/sysctl.c	2007-04-24 23:27:20.304043970 +0200
@@ -1676,7 +1676,7 @@ static int proc_dointvec_taint(ctl_table
 {
 	int op;
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (write && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	op = OP_OR;
diff -purN linux-2.6.21-rc7-git5/mm/migrate.c linux-2.6.21-rc7-git7/mm/migrate.c
--- linux-2.6.21-rc7-git5/mm/migrate.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/mm/migrate.c	2007-04-24 23:27:20.304043970 +0200
@@ -297,7 +297,7 @@ static int migrate_page_move_mapping(str
 	void **pslot;
 
 	if (!mapping) {
-		/* Anonymous page */
+		/* Anonymous page without mapping */
 		if (page_count(page) != 1)
 			return -EAGAIN;
 		return 0;
@@ -333,6 +333,19 @@ static int migrate_page_move_mapping(str
 	 */
 	__put_page(page);
 
+	/*
+	 * If moved to a different zone then also account
+	 * the page for that zone. Other VM counters will be
+	 * taken care of when we establish references to the
+	 * new page and drop references to the old page.
+	 *
+	 * Note that anonymous pages are accounted for
+	 * via NR_FILE_PAGES and NR_ANON_PAGES if they
+	 * are mapped to swap space.
+	 */
+	__dec_zone_page_state(page, NR_FILE_PAGES);
+	__inc_zone_page_state(newpage, NR_FILE_PAGES);
+
 	write_unlock_irq(&mapping->tree_lock);
 
 	return 0;
diff -purN linux-2.6.21-rc7-git5/mm/oom_kill.c linux-2.6.21-rc7-git7/mm/oom_kill.c
--- linux-2.6.21-rc7-git5/mm/oom_kill.c	2007-04-16 01:50:57.000000000 +0200
+++ linux-2.6.21-rc7-git7/mm/oom_kill.c	2007-04-24 23:27:20.304043970 +0200
@@ -176,6 +176,8 @@ static inline int constrained_alloc(stru
 	struct zone **z;
 	nodemask_t nodes;
 	int node;
+
+	nodes_clear(nodes);
 	/* node has memory ? */
 	for_each_online_node(node)
 		if (NODE_DATA(node)->node_present_pages)
@@ -333,7 +335,7 @@ static int oom_kill_task(struct task_str
 	 */
 	do_each_thread(g, q) {
 		if (q->mm == mm && q->tgid != p->tgid)
-			force_sig(SIGKILL, p);
+			force_sig(SIGKILL, q);
 	} while_each_thread(g, q);
 
 	return 0;
