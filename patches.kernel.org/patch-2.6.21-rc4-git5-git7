 Documentation/crypto/api-intro.txt              |    2 
 Documentation/kernel-parameters.txt             |    8 +
 Documentation/sysrq.txt                         |    2 
 MAINTAINERS                                     |    5 -
 Makefile                                        |    2 
 arch/i386/kernel/apic.c                         |   55 ++++++++++++
 arch/i386/kernel/i8253.c                        |   10 ++
 arch/ia64/Kconfig                               |    1 
 arch/ia64/kernel/crash.c                        |    2 
 arch/ia64/kernel/setup.c                        |   22 +++--
 arch/ia64/mm/contig.c                           |   30 +-----
 arch/ia64/mm/discontig.c                        |    4 
 arch/ia64/mm/init.c                             |   16 +++
 arch/ia64/sn/kernel/setup.c                     |    6 -
 arch/powerpc/kernel/process.c                   |    9 +-
 arch/powerpc/platforms/pseries/hvCall.S         |   41 +++++++++
 arch/powerpc/platforms/pseries/lpar.c           |    2 
 arch/powerpc/platforms/pseries/plpar_wrappers.h |   16 +++
 crypto/scatterwalk.c                            |    4 
 crypto/tcrypt.c                                 |    2 
 drivers/acpi/events/evmisc.c                    |    8 +
 drivers/acpi/events/evregion.c                  |   15 ++-
 drivers/acpi/events/evxface.c                   |    6 -
 drivers/acpi/executer/excreate.c                |    5 -
 drivers/acpi/executer/exsystem.c                |   30 +++++-
 drivers/acpi/executer/exutils.c                 |  104 ++++--------------------
 drivers/acpi/hardware/hwsleep.c                 |    5 +
 drivers/acpi/ibm_acpi.c                         |   19 +++-
 drivers/acpi/namespace/nseval.c                 |   11 ++
 drivers/acpi/namespace/nsinit.c                 |    7 +
 drivers/acpi/namespace/nsxfeval.c               |   11 +-
 drivers/acpi/processor_idle.c                   |   38 ++++++--
 drivers/acpi/tables.c                           |   57 ++++++++++++-
 drivers/i2c/busses/i2c-amd8111.c                |    3 
 drivers/i2c/busses/i2c-i801.c                   |   25 +++++
 drivers/i2c/chips/ds1374.c                      |    4 
 drivers/infiniband/hw/cxgb3/iwch_provider.c     |    5 -
 drivers/infiniband/hw/ehca/ehca_irq.c           |    8 +
 drivers/infiniband/hw/ipath/ipath_fs.c          |   16 +++
 drivers/infiniband/ulp/ipoib/ipoib_cm.c         |    4 
 drivers/infiniband/ulp/ipoib/ipoib_ib.c         |    4 
 drivers/infiniband/ulp/ipoib/ipoib_main.c       |    4 
 drivers/infiniband/ulp/ipoib/ipoib_multicast.c  |    6 -
 drivers/net/irda/irda-usb.c                     |    2 
 drivers/video/s3fb.c                            |    3 
 fs/cifs/CHANGES                                 |    6 +
 fs/cifs/cifspdu.h                               |    8 +
 fs/cifs/inode.c                                 |   21 ++++
 fs/cifs/readdir.c                               |    4 
 fs/xfs/linux-2.6/xfs_buf.c                      |    4 
 include/acpi/acinterp.h                         |    6 -
 include/acpi/actypes.h                          |    2 
 include/asm-ia64/meminit.h                      |    1 
 include/asm-powerpc/hvcall.h                    |   14 +++
 include/linux/bootmem.h                         |    2 
 include/linux/lockdep.h                         |    2 
 include/net/sctp/structs.h                      |    1 
 include/net/sctp/ulpqueue.h                     |    1 
 kernel/lockdep.c                                |    8 +
 kernel/power/disk.c                             |    8 -
 kernel/power/user.c                             |    9 +-
 mm/nommu.c                                      |   28 ++++++
 net/bluetooth/hidp/core.c                       |    2 
 net/bridge/br_fdb.c                             |    4 
 net/bridge/br_netfilter.c                       |    2 
 net/core/fib_rules.c                            |    2 
 net/core/sock.c                                 |    2 
 net/ipv4/netfilter/ip_nat_standalone.c          |   15 ++-
 net/ipv4/netfilter/nf_nat_standalone.c          |   14 +--
 net/ipv6/addrconf.c                             |    6 -
 net/ipv6/route.c                                |    4 
 net/ipv6/xfrm6_tunnel.c                         |    4 
 net/irda/irnet/irnet.h                          |    2 
 net/irda/irnet/irnet_irda.c                     |   34 +++++--
 net/irda/irttp.c                                |    1 
 net/netfilter/Kconfig                           |    1 
 net/sched/cls_route.c                           |    2 
 net/sctp/associola.c                            |   15 +++
 net/sctp/sm_statefuns.c                         |   20 ++++
 net/sctp/transport.c                            |   32 +++++++
 net/sctp/ulpqueue.c                             |    2 
 net/x25/x25_forward.c                           |   86 ++++++++++---------
 net/xfrm/xfrm_policy.c                          |    2 
 net/xfrm/xfrm_user.c                            |    2 
 84 files changed, 720 insertions(+), 298 deletions(-)
diff -purN linux-2.6.21-rc4-git5/Documentation/crypto/api-intro.txt linux-2.6.21-rc4-git7/Documentation/crypto/api-intro.txt
--- linux-2.6.21-rc4-git5/Documentation/crypto/api-intro.txt	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/Documentation/crypto/api-intro.txt	2007-03-23 08:42:08.177058442 +0100
@@ -60,7 +60,7 @@ Here's an example of how to use the API:
 	desc.tfm = tfm;
 	desc.flags = 0;
 	
-	if (crypto_hash_digest(&desc, &sg, 2, result))
+	if (crypto_hash_digest(&desc, sg, 2, result))
 		fail();
 	
 	crypto_free_hash(tfm);
diff -purN linux-2.6.21-rc4-git5/Documentation/kernel-parameters.txt linux-2.6.21-rc4-git7/Documentation/kernel-parameters.txt
--- linux-2.6.21-rc4-git5/Documentation/kernel-parameters.txt	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/Documentation/kernel-parameters.txt	2007-03-23 08:42:08.187058389 +0100
@@ -138,6 +138,12 @@ and is between 256 and 4096 characters. 
 
 			See also Documentation/pm.txt, pci=noacpi
 
+	acpi_apic_instance=	[ACPI, IOAPIC]
+			Format: <int>
+			2: use 2nd APIC table, if available
+			1,0: use 1st APIC table
+			default: 2
+
 	acpi_sleep=	[HW,ACPI] Sleep options
 			Format: { s3_bios, s3_mode }
 			See Documentation/power/video.txt
@@ -1117,6 +1123,8 @@ and is between 256 and 4096 characters. 
 
 	nolapic		[IA-32,APIC] Do not enable or use the local APIC.
 
+	nolapic_timer	[IA-32,APIC] Do not use the local APIC timer.
+
 	noltlbs		[PPC] Do not use large page/tlb entries for kernel
 			lowmem mapping on PPC40x.
 
diff -purN linux-2.6.21-rc4-git5/Documentation/sysrq.txt linux-2.6.21-rc4-git7/Documentation/sysrq.txt
--- linux-2.6.21-rc4-git5/Documentation/sysrq.txt	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/Documentation/sysrq.txt	2007-03-23 08:42:08.187058389 +0100
@@ -93,6 +93,8 @@ On all -  write a character to /proc/sys
 
 'p'     - Will dump the current registers and flags to your console.
 
+'q'     - Will dump a list of all running timers.
+
 'r'     - Turns off keyboard raw mode and sets it to XLATE.
 
 's'     - Will attempt to sync all mounted filesystems.
diff -purN linux-2.6.21-rc4-git5/MAINTAINERS linux-2.6.21-rc4-git7/MAINTAINERS
--- linux-2.6.21-rc4-git5/MAINTAINERS	2007-03-23 08:42:01.147095400 +0100
+++ linux-2.6.21-rc4-git7/MAINTAINERS	2007-03-23 08:42:08.197058337 +0100
@@ -3066,11 +3066,10 @@ L:	netdev@vger.kernel.org
 S:	Maintained
 
 SONY VAIO CONTROL DEVICE DRIVER
-P:	Stelian Pop
-M:	stelian@popies.net
 P:	Mattia Dongili
 M:	malattia@linux.it
-W:	http://popies.net/sonypi/
+L:	linux-acpi@vger.kernel.org
+W:	http://www.linux.it/~malattia/wiki/index.php/Sony_drivers
 S:	Maintained
 
 SOUND
diff -purN linux-2.6.21-rc4-git5/Makefile linux-2.6.21-rc4-git7/Makefile
--- linux-2.6.21-rc4-git5/Makefile	2007-03-23 08:42:01.147095400 +0100
+++ linux-2.6.21-rc4-git7/Makefile	2007-03-23 08:42:08.197058337 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 21
-EXTRAVERSION = -rc4-git5
+EXTRAVERSION = -rc4-git7
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff -purN linux-2.6.21-rc4-git5/arch/i386/kernel/apic.c linux-2.6.21-rc4-git7/arch/i386/kernel/apic.c
--- linux-2.6.21-rc4-git5/arch/i386/kernel/apic.c	2007-03-23 08:42:01.167095294 +0100
+++ linux-2.6.21-rc4-git7/arch/i386/kernel/apic.c	2007-03-23 08:42:08.217058232 +0100
@@ -28,6 +28,7 @@
 #include <linux/clockchips.h>
 #include <linux/acpi_pmtmr.h>
 #include <linux/module.h>
+#include <linux/dmi.h>
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
@@ -61,6 +62,8 @@ static int enable_local_apic __initdata 
 
 /* Local APIC timer verification ok */
 static int local_apic_timer_verify_ok;
+/* Disable local APIC timer from the kernel commandline or via dmi quirk */
+static int local_apic_timer_disabled;
 
 /*
  * Debug level, exported for io_apic.c
@@ -266,6 +269,32 @@ static void __devinit setup_APIC_timer(v
 }
 
 /*
+ * Detect systems with known broken BIOS implementations
+ */
+static int __init lapic_check_broken_bios(struct dmi_system_id *d)
+{
+	printk(KERN_NOTICE "%s detected: disabling lapic timer.\n",
+		       d->ident);
+	local_apic_timer_disabled = 1;
+	return 0;
+}
+
+static struct dmi_system_id __initdata broken_bios_dmi_table[] = {
+	{
+		/*
+		 * BIOS exports only C1 state, but uses deeper power
+		 * modes behind the kernels back.
+		 */
+		  .callback = lapic_check_broken_bios,
+		  .ident = "HP nx6325",
+		  .matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq nx6325"),
+		  },
+	 },
+	 {}
+};
+
+/*
  * In this functions we calibrate APIC bus clocks to the external timer.
  *
  * We want to do the calibration only once since we want to have local timer
@@ -340,6 +369,22 @@ void __init setup_boot_APIC_clock(void)
 	long delta, deltapm;
 	int pm_referenced = 0;
 
+	/* Detect know broken systems */
+	dmi_check_system(broken_bios_dmi_table);
+
+	/*
+	 * The local apic timer can be disabled via the kernel
+	 * commandline or from the dmi quirk above. Register the lapic
+	 * timer as a dummy clock event source on SMP systems, so the
+	 * broadcast mechanism is used. On UP systems simply ignore it.
+	 */
+	if (local_apic_timer_disabled) {
+		/* No broadcast on UP ! */
+		if (num_possible_cpus() > 1)
+			setup_APIC_timer();
+		return;
+	}
+
 	apic_printk(APIC_VERBOSE, "Using local APIC timer interrupts.\n"
 		    "calibrating APIC timer ...\n");
 
@@ -461,7 +506,8 @@ void __init setup_boot_APIC_clock(void)
 			apic_printk(APIC_VERBOSE, "... jiffies result ok\n");
 		else
 			local_apic_timer_verify_ok = 0;
-	}
+	} else
+		local_irq_enable();
 
 	if (!local_apic_timer_verify_ok) {
 		printk(KERN_WARNING
@@ -1179,6 +1225,13 @@ static int __init parse_nolapic(char *ar
 }
 early_param("nolapic", parse_nolapic);
 
+static int __init parse_disable_lapic_timer(char *arg)
+{
+	local_apic_timer_disabled = 1;
+	return 0;
+}
+early_param("nolapic_timer", parse_disable_lapic_timer);
+
 static int __init apic_set_verbosity(char *str)
 {
 	if (strcmp("debug", str) == 0)
diff -purN linux-2.6.21-rc4-git5/arch/i386/kernel/i8253.c linux-2.6.21-rc4-git7/arch/i386/kernel/i8253.c
--- linux-2.6.21-rc4-git5/arch/i386/kernel/i8253.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/i386/kernel/i8253.c	2007-03-23 08:42:08.217058232 +0100
@@ -47,9 +47,17 @@ static void init_pit_timer(enum clock_ev
 		outb(LATCH >> 8 , PIT_CH0);	/* MSB */
 		break;
 
-	case CLOCK_EVT_MODE_ONESHOT:
+	/*
+	 * Avoid unnecessary state transitions, as it confuses
+	 * Geode / Cyrix based boxen.
+	 */
 	case CLOCK_EVT_MODE_SHUTDOWN:
+		if (evt->mode == CLOCK_EVT_MODE_UNUSED)
+			break;
 	case CLOCK_EVT_MODE_UNUSED:
+		if (evt->mode == CLOCK_EVT_MODE_SHUTDOWN)
+			break;
+	case CLOCK_EVT_MODE_ONESHOT:
 		/* One shot setup */
 		outb_p(0x38, PIT_MODE);
 		udelay(10);
diff -purN linux-2.6.21-rc4-git5/arch/ia64/Kconfig linux-2.6.21-rc4-git7/arch/ia64/Kconfig
--- linux-2.6.21-rc4-git5/arch/ia64/Kconfig	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/ia64/Kconfig	2007-03-23 08:42:08.217058232 +0100
@@ -13,6 +13,7 @@ config IA64
 	bool
 	select PCI if (!IA64_HP_SIM)
 	select ACPI if (!IA64_HP_SIM)
+	select PM if (!IA64_HP_SIM)
 	default y
 	help
 	  The Itanium Processor Family is Intel's 64-bit successor to
diff -purN linux-2.6.21-rc4-git5/arch/ia64/kernel/crash.c linux-2.6.21-rc4-git7/arch/ia64/kernel/crash.c
--- linux-2.6.21-rc4-git5/arch/ia64/kernel/crash.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/ia64/kernel/crash.c	2007-03-23 08:42:08.217058232 +0100
@@ -164,7 +164,7 @@ kdump_init_notifier(struct notifier_bloc
 
 	nd = (struct ia64_mca_notify_die *)args->err;
 	/* Reason code 1 means machine check rendezous*/
-	if ((val == DIE_INIT_MONARCH_ENTER || DIE_INIT_SLAVE_ENTER) &&
+	if ((val == DIE_INIT_MONARCH_ENTER || val == DIE_INIT_SLAVE_ENTER) &&
 		 nd->sos->rv_rc == 1)
 		return NOTIFY_DONE;
 
diff -purN linux-2.6.21-rc4-git5/arch/ia64/kernel/setup.c linux-2.6.21-rc4-git7/arch/ia64/kernel/setup.c
--- linux-2.6.21-rc4-git5/arch/ia64/kernel/setup.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/ia64/kernel/setup.c	2007-03-23 08:42:08.227058179 +0100
@@ -692,12 +692,15 @@ struct seq_operations cpuinfo_op = {
 	.show =		show_cpuinfo
 };
 
-static char brandname[128];
+#define MAX_BRANDS	8
+static char brandname[MAX_BRANDS][128];
 
 static char * __cpuinit
 get_model_name(__u8 family, __u8 model)
 {
+	static int overflow;
 	char brand[128];
+	int i;
 
 	memcpy(brand, "Unknown", 8);
 	if (ia64_pal_get_brand_info(brand)) {
@@ -709,12 +712,17 @@ get_model_name(__u8 family, __u8 model)
 			case 2: memcpy(brand, "Madison up to 9M cache", 23); break;
 		}
 	}
-	if (brandname[0] == '\0')
-		return strcpy(brandname, brand);
-	else if (strcmp(brandname, brand) == 0)
-		return brandname;
-	else
-		return kstrdup(brand, GFP_KERNEL);
+	for (i = 0; i < MAX_BRANDS; i++)
+		if (strcmp(brandname[i], brand) == 0)
+			return brandname[i];
+	for (i = 0; i < MAX_BRANDS; i++)
+		if (brandname[i][0] == '\0')
+			return strcpy(brandname[i], brand);
+	if (overflow++ == 0)
+		printk(KERN_ERR
+		       "%s: Table overflow. Some processor model information will be missing\n",
+		       __FUNCTION__);
+	return "Unknown";
 }
 
 static void __cpuinit
diff -purN linux-2.6.21-rc4-git5/arch/ia64/mm/contig.c linux-2.6.21-rc4-git7/arch/ia64/mm/contig.c
--- linux-2.6.21-rc4-git5/arch/ia64/mm/contig.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/ia64/mm/contig.c	2007-03-23 08:42:08.227058179 +0100
@@ -97,26 +97,6 @@ void show_mem(void)
 unsigned long bootmap_start;
 
 /**
- * find_max_pfn - adjust the maximum page number callback
- * @start: start of range
- * @end: end of range
- * @arg: address of pointer to global max_pfn variable
- *
- * Passed as a callback function to efi_memmap_walk() to determine the highest
- * available page frame number in the system.
- */
-int
-find_max_pfn (unsigned long start, unsigned long end, void *arg)
-{
-	unsigned long *max_pfnp = arg, pfn;
-
-	pfn = (PAGE_ALIGN(end - 1) - PAGE_OFFSET) >> PAGE_SHIFT;
-	if (pfn > *max_pfnp)
-		*max_pfnp = pfn;
-	return 0;
-}
-
-/**
  * find_bootmap_location - callback to find a memory area for the bootmap
  * @start: start of region
  * @end: end of region
@@ -177,9 +157,10 @@ find_memory (void)
 	reserve_memory();
 
 	/* first find highest page frame number */
-	max_pfn = 0;
-	efi_memmap_walk(find_max_pfn, &max_pfn);
-
+	min_low_pfn = ~0UL;
+	max_low_pfn = 0;
+	efi_memmap_walk(find_max_min_low_pfn, NULL);
+	max_pfn = max_low_pfn;
 	/* how many bytes to cover all the pages */
 	bootmap_size = bootmem_bootmap_pages(max_pfn) << PAGE_SHIFT;
 
@@ -189,7 +170,8 @@ find_memory (void)
 	if (bootmap_start == ~0UL)
 		panic("Cannot find %ld bytes for bootmap\n", bootmap_size);
 
-	bootmap_size = init_bootmem(bootmap_start >> PAGE_SHIFT, max_pfn);
+	bootmap_size = init_bootmem_node(NODE_DATA(0),
+			(bootmap_start >> PAGE_SHIFT), 0, max_pfn);
 
 	/* Free all available memory, then mark bootmem-map as being in use. */
 	efi_memmap_walk(filter_rsvd_memory, free_bootmem);
diff -purN linux-2.6.21-rc4-git5/arch/ia64/mm/discontig.c linux-2.6.21-rc4-git7/arch/ia64/mm/discontig.c
--- linux-2.6.21-rc4-git5/arch/ia64/mm/discontig.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/ia64/mm/discontig.c	2007-03-23 08:42:08.227058179 +0100
@@ -88,9 +88,6 @@ static int __init build_node_maps(unsign
 		bdp->node_low_pfn = max(epfn, bdp->node_low_pfn);
 	}
 
-	min_low_pfn = min(min_low_pfn, bdp->node_boot_start>>PAGE_SHIFT);
-	max_low_pfn = max(max_low_pfn, bdp->node_low_pfn);
-
 	return 0;
 }
 
@@ -438,6 +435,7 @@ void __init find_memory(void)
 	/* These actually end up getting called by call_pernode_memory() */
 	efi_memmap_walk(filter_rsvd_memory, build_node_maps);
 	efi_memmap_walk(filter_rsvd_memory, find_pernode_space);
+	efi_memmap_walk(find_max_min_low_pfn, NULL);
 
 	for_each_online_node(node)
 		if (mem_data[node].bootmem_data.node_low_pfn) {
diff -purN linux-2.6.21-rc4-git5/arch/ia64/mm/init.c linux-2.6.21-rc4-git7/arch/ia64/mm/init.c
--- linux-2.6.21-rc4-git5/arch/ia64/mm/init.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/ia64/mm/init.c	2007-03-23 08:42:08.227058179 +0100
@@ -648,6 +648,22 @@ count_reserved_pages (u64 start, u64 end
 	return 0;
 }
 
+int
+find_max_min_low_pfn (unsigned long start, unsigned long end, void *arg)
+{
+	unsigned long pfn_start, pfn_end;
+#ifdef CONFIG_FLATMEM
+	pfn_start = (PAGE_ALIGN(__pa(start))) >> PAGE_SHIFT;
+	pfn_end = (PAGE_ALIGN(__pa(end - 1))) >> PAGE_SHIFT;
+#else
+	pfn_start = GRANULEROUNDDOWN(__pa(start)) >> PAGE_SHIFT;
+	pfn_end = GRANULEROUNDUP(__pa(end - 1)) >> PAGE_SHIFT;
+#endif
+	min_low_pfn = min(min_low_pfn, pfn_start);
+	max_low_pfn = max(max_low_pfn, pfn_end);
+	return 0;
+}
+
 /*
  * Boot command-line option "nolwsys" can be used to disable the use of any light-weight
  * system call handler.  When this option is in effect, all fsyscalls will end up bubbling
diff -purN linux-2.6.21-rc4-git5/arch/ia64/sn/kernel/setup.c linux-2.6.21-rc4-git7/arch/ia64/sn/kernel/setup.c
--- linux-2.6.21-rc4-git5/arch/ia64/sn/kernel/setup.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/ia64/sn/kernel/setup.c	2007-03-23 08:42:08.227058179 +0100
@@ -348,8 +348,7 @@ sn_scan_pcdp(void)
 			continue;	/* not PCI interconnect */
 
 		if (if_pci.translation & PCDP_PCI_TRANS_IOPORT)
-			vga_console_iobase =
-				if_pci.ioport_tra | __IA64_UNCACHED_OFFSET;
+			vga_console_iobase = if_pci.ioport_tra;
 
 		if (if_pci.translation & PCDP_PCI_TRANS_MMIO)
 			vga_console_membase =
@@ -429,7 +428,8 @@ void __init sn_setup(char **cmdline_p)
 	 * 	bus containing the VGA console.
 	 */
 	if (vga_console_iobase) {
-		io_space[0].mmio_base = vga_console_iobase;
+		io_space[0].mmio_base =
+			(unsigned long) ioremap(vga_console_iobase, 0);
 		io_space[0].sparse = 0;
 	}
 
diff -purN linux-2.6.21-rc4-git5/arch/powerpc/kernel/process.c linux-2.6.21-rc4-git7/arch/powerpc/kernel/process.c
--- linux-2.6.21-rc4-git5/arch/powerpc/kernel/process.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/powerpc/kernel/process.c	2007-03-23 08:42:08.277057916 +0100
@@ -465,8 +465,13 @@ void flush_thread(void)
 #ifdef CONFIG_PPC64
 	struct thread_info *t = current_thread_info();
 
-	if (t->flags & _TIF_ABI_PENDING)
-		t->flags ^= (_TIF_ABI_PENDING | _TIF_32BIT);
+	if (test_ti_thread_flag(t, TIF_ABI_PENDING)) {
+		clear_ti_thread_flag(t, TIF_ABI_PENDING);
+		if (test_ti_thread_flag(t, TIF_32BIT))
+			clear_ti_thread_flag(t, TIF_32BIT);
+		else
+			set_ti_thread_flag(t, TIF_32BIT);
+	}
 #endif
 
 	discard_lazy_cpu_state();
diff -purN linux-2.6.21-rc4-git5/arch/powerpc/platforms/pseries/hvCall.S linux-2.6.21-rc4-git7/arch/powerpc/platforms/pseries/hvCall.S
--- linux-2.6.21-rc4-git5/arch/powerpc/platforms/pseries/hvCall.S	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/powerpc/platforms/pseries/hvCall.S	2007-03-23 08:42:08.277057916 +0100
@@ -30,9 +30,14 @@ END_FTR_SECTION_IFSET(CPU_FTR_PURR);
 	
 /*
  * postcall is performed immediately before function return which
- * allows liberal use of volatile registers.
+ * allows liberal use of volatile registers.  We branch around this
+ * in early init (eg when populating the MMU hashtable) by using an
+ * unconditional cpu feature.
  */
 #define HCALL_INST_POSTCALL					\
+BEGIN_FTR_SECTION;						\
+	b	1f;						\
+END_FTR_SECTION(0, 1);						\
 	ld	r4,STK_PARM(r3)(r1);	/* validate opcode */	\
 	cmpldi	cr7,r4,MAX_HCALL_OPCODE;			\
 	bgt-	cr7,1f;						\
@@ -123,6 +128,40 @@ _GLOBAL(plpar_hcall)
 
 	blr				/* return r3 = status */
 
+/*
+ * plpar_hcall_raw can be called in real mode. kexec/kdump need some
+ * hypervisor calls to be executed in real mode. So plpar_hcall_raw
+ * does not access the per cpu hypervisor call statistics variables,
+ * since these variables may not be present in the RMO region.
+ */
+_GLOBAL(plpar_hcall_raw)
+	HMT_MEDIUM
+
+	mfcr	r0
+	stw	r0,8(r1)
+
+	std     r4,STK_PARM(r4)(r1)     /* Save ret buffer */
+
+	mr	r4,r5
+	mr	r5,r6
+	mr	r6,r7
+	mr	r7,r8
+	mr	r8,r9
+	mr	r9,r10
+
+	HVSC				/* invoke the hypervisor */
+
+	ld	r12,STK_PARM(r4)(r1)
+	std	r4,  0(r12)
+	std	r5,  8(r12)
+	std	r6, 16(r12)
+	std	r7, 24(r12)
+
+	lwz	r0,8(r1)
+	mtcrf	0xff,r0
+
+	blr				/* return r3 = status */
+
 _GLOBAL(plpar_hcall9)
 	HMT_MEDIUM
 
diff -purN linux-2.6.21-rc4-git5/arch/powerpc/platforms/pseries/lpar.c linux-2.6.21-rc4-git7/arch/powerpc/platforms/pseries/lpar.c
--- linux-2.6.21-rc4-git5/arch/powerpc/platforms/pseries/lpar.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/powerpc/platforms/pseries/lpar.c	2007-03-23 08:42:08.277057916 +0100
@@ -378,7 +378,7 @@ static void pSeries_lpar_hptab_clear(voi
 
 	/* TODO: Use bulk call */
 	for (i = 0; i < hpte_count; i++)
-		plpar_pte_remove(0, i, 0, &dummy1, &dummy2);
+		plpar_pte_remove_raw(0, i, 0, &dummy1, &dummy2);
 }
 
 /*
diff -purN linux-2.6.21-rc4-git5/arch/powerpc/platforms/pseries/plpar_wrappers.h linux-2.6.21-rc4-git7/arch/powerpc/platforms/pseries/plpar_wrappers.h
--- linux-2.6.21-rc4-git5/arch/powerpc/platforms/pseries/plpar_wrappers.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/arch/powerpc/platforms/pseries/plpar_wrappers.h	2007-03-23 08:42:08.277057916 +0100
@@ -78,6 +78,22 @@ static inline long plpar_pte_remove(unsi
 	return rc;
 }
 
+/* plpar_pte_remove_raw can be called in real mode. It calls plpar_hcall_raw */
+static inline long plpar_pte_remove_raw(unsigned long flags, unsigned long ptex,
+		unsigned long avpn, unsigned long *old_pteh_ret,
+		unsigned long *old_ptel_ret)
+{
+	long rc;
+	unsigned long retbuf[PLPAR_HCALL_BUFSIZE];
+
+	rc = plpar_hcall_raw(H_REMOVE, retbuf, flags, ptex, avpn);
+
+	*old_pteh_ret = retbuf[0];
+	*old_ptel_ret = retbuf[1];
+
+	return rc;
+}
+
 static inline long plpar_pte_read(unsigned long flags, unsigned long ptex,
 		unsigned long *old_pteh_ret, unsigned long *old_ptel_ret)
 {
diff -purN linux-2.6.21-rc4-git5/crypto/scatterwalk.c linux-2.6.21-rc4-git7/crypto/scatterwalk.c
--- linux-2.6.21-rc4-git5/crypto/scatterwalk.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/crypto/scatterwalk.c	2007-03-23 08:42:08.327057653 +0100
@@ -91,6 +91,8 @@ void scatterwalk_copychunks(void *buf, s
 		memcpy_dir(buf, vaddr, len_this_page, out);
 		scatterwalk_unmap(vaddr, out);
 
+		scatterwalk_advance(walk, nbytes);
+
 		if (nbytes == len_this_page)
 			break;
 
@@ -99,7 +101,5 @@ void scatterwalk_copychunks(void *buf, s
 
 		scatterwalk_pagedone(walk, out, 1);
 	}
-
-	scatterwalk_advance(walk, nbytes);
 }
 EXPORT_SYMBOL_GPL(scatterwalk_copychunks);
diff -purN linux-2.6.21-rc4-git5/crypto/tcrypt.c linux-2.6.21-rc4-git7/crypto/tcrypt.c
--- linux-2.6.21-rc4-git5/crypto/tcrypt.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/crypto/tcrypt.c	2007-03-23 08:42:08.327057653 +0100
@@ -768,7 +768,7 @@ static void test_deflate(void)
 	tv = (void *)tvmem;
 
 	tfm = crypto_alloc_comp("deflate", 0, CRYPTO_ALG_ASYNC);
-	if (tfm == NULL) {
+	if (IS_ERR(tfm)) {
 		printk("failed to load transform for deflate\n");
 		return;
 	}
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/events/evmisc.c linux-2.6.21-rc4-git7/drivers/acpi/events/evmisc.c
--- linux-2.6.21-rc4-git5/drivers/acpi/events/evmisc.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/events/evmisc.c	2007-03-23 08:42:08.327057653 +0100
@@ -196,11 +196,15 @@ acpi_ev_queue_notify_request(struct acpi
 		notify_info->notify.value = (u16) notify_value;
 		notify_info->notify.handler_obj = handler_obj;
 
-		acpi_ex_relinquish_interpreter();
+		acpi_ex_exit_interpreter();
 
 		acpi_ev_notify_dispatch(notify_info);
 
-		acpi_ex_reacquire_interpreter();
+		status = acpi_ex_enter_interpreter();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
 	}
 
 	if (!handler_obj) {
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/events/evregion.c linux-2.6.21-rc4-git7/drivers/acpi/events/evregion.c
--- linux-2.6.21-rc4-git5/drivers/acpi/events/evregion.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/events/evregion.c	2007-03-23 08:42:08.337057601 +0100
@@ -291,6 +291,7 @@ acpi_ev_address_space_dispatch(union acp
 			       u32 bit_width, acpi_integer * value)
 {
 	acpi_status status;
+	acpi_status status2;
 	acpi_adr_space_handler handler;
 	acpi_adr_space_setup region_setup;
 	union acpi_operand_object *handler_desc;
@@ -344,7 +345,7 @@ acpi_ev_address_space_dispatch(union acp
 		 * setup will potentially execute control methods
 		 * (e.g., _REG method for this region)
 		 */
-		acpi_ex_relinquish_interpreter();
+		acpi_ex_exit_interpreter();
 
 		status = region_setup(region_obj, ACPI_REGION_ACTIVATE,
 				      handler_desc->address_space.context,
@@ -352,7 +353,10 @@ acpi_ev_address_space_dispatch(union acp
 
 		/* Re-enter the interpreter */
 
-		acpi_ex_reacquire_interpreter();
+		status2 = acpi_ex_enter_interpreter();
+		if (ACPI_FAILURE(status2)) {
+			return_ACPI_STATUS(status2);
+		}
 
 		/* Check for failure of the Region Setup */
 
@@ -405,7 +409,7 @@ acpi_ev_address_space_dispatch(union acp
 		 * exit the interpreter because the handler *might* block -- we don't
 		 * know what it will do, so we can't hold the lock on the intepreter.
 		 */
-		acpi_ex_relinquish_interpreter();
+		acpi_ex_exit_interpreter();
 	}
 
 	/* Call the handler */
@@ -426,7 +430,10 @@ acpi_ev_address_space_dispatch(union acp
 		 * We just returned from a non-default handler, we must re-enter the
 		 * interpreter
 		 */
-		acpi_ex_reacquire_interpreter();
+		status2 = acpi_ex_enter_interpreter();
+		if (ACPI_FAILURE(status2)) {
+			return_ACPI_STATUS(status2);
+		}
 	}
 
 	return_ACPI_STATUS(status);
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/events/evxface.c linux-2.6.21-rc4-git7/drivers/acpi/events/evxface.c
--- linux-2.6.21-rc4-git5/drivers/acpi/events/evxface.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/events/evxface.c	2007-03-23 08:42:08.337057601 +0100
@@ -768,9 +768,11 @@ acpi_status acpi_acquire_global_lock(u16
 		return (AE_BAD_PARAMETER);
 	}
 
-	/* Must lock interpreter to prevent race conditions */
+	status = acpi_ex_enter_interpreter();
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
 
-	acpi_ex_enter_interpreter();
 	status = acpi_ev_acquire_global_lock(timeout);
 	acpi_ex_exit_interpreter();
 
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/executer/excreate.c linux-2.6.21-rc4-git7/drivers/acpi/executer/excreate.c
--- linux-2.6.21-rc4-git5/drivers/acpi/executer/excreate.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/executer/excreate.c	2007-03-23 08:42:08.337057601 +0100
@@ -583,7 +583,10 @@ acpi_ex_create_method(u8 * aml_start,
 	 * Get the sync_level. If method is serialized, a mutex will be
 	 * created for this method when it is parsed.
 	 */
-	if (method_flags & AML_METHOD_SERIALIZED) {
+	if (acpi_gbl_all_methods_serialized) {
+		obj_desc->method.sync_level = 0;
+		obj_desc->method.method_flags |= AML_METHOD_SERIALIZED;
+	} else if (method_flags & AML_METHOD_SERIALIZED) {
 		/*
 		 * ACPI 1.0: sync_level = 0
 		 * ACPI 2.0: sync_level = sync_level in method declaration
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/executer/exsystem.c linux-2.6.21-rc4-git7/drivers/acpi/executer/exsystem.c
--- linux-2.6.21-rc4-git5/drivers/acpi/executer/exsystem.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/executer/exsystem.c	2007-03-23 08:42:08.337057601 +0100
@@ -66,6 +66,7 @@ ACPI_MODULE_NAME("exsystem")
 acpi_status acpi_ex_system_wait_semaphore(acpi_semaphore semaphore, u16 timeout)
 {
 	acpi_status status;
+	acpi_status status2;
 
 	ACPI_FUNCTION_TRACE(ex_system_wait_semaphore);
 
@@ -78,7 +79,7 @@ acpi_status acpi_ex_system_wait_semaphor
 
 		/* We must wait, so unlock the interpreter */
 
-		acpi_ex_relinquish_interpreter();
+		acpi_ex_exit_interpreter();
 
 		status = acpi_os_wait_semaphore(semaphore, 1, timeout);
 
@@ -88,7 +89,13 @@ acpi_status acpi_ex_system_wait_semaphor
 
 		/* Reacquire the interpreter */
 
-		acpi_ex_reacquire_interpreter();
+		status2 = acpi_ex_enter_interpreter();
+		if (ACPI_FAILURE(status2)) {
+
+			/* Report fatal error, could not acquire interpreter */
+
+			return_ACPI_STATUS(status2);
+		}
 	}
 
 	return_ACPI_STATUS(status);
@@ -112,6 +119,7 @@ acpi_status acpi_ex_system_wait_semaphor
 acpi_status acpi_ex_system_wait_mutex(acpi_mutex mutex, u16 timeout)
 {
 	acpi_status status;
+	acpi_status status2;
 
 	ACPI_FUNCTION_TRACE(ex_system_wait_mutex);
 
@@ -124,7 +132,7 @@ acpi_status acpi_ex_system_wait_mutex(ac
 
 		/* We must wait, so unlock the interpreter */
 
-		acpi_ex_relinquish_interpreter();
+		acpi_ex_exit_interpreter();
 
 		status = acpi_os_acquire_mutex(mutex, timeout);
 
@@ -134,7 +142,13 @@ acpi_status acpi_ex_system_wait_mutex(ac
 
 		/* Reacquire the interpreter */
 
-		acpi_ex_reacquire_interpreter();
+		status2 = acpi_ex_enter_interpreter();
+		if (ACPI_FAILURE(status2)) {
+
+			/* Report fatal error, could not acquire interpreter */
+
+			return_ACPI_STATUS(status2);
+		}
 	}
 
 	return_ACPI_STATUS(status);
@@ -195,18 +209,20 @@ acpi_status acpi_ex_system_do_stall(u32 
 
 acpi_status acpi_ex_system_do_suspend(acpi_integer how_long)
 {
+	acpi_status status;
+
 	ACPI_FUNCTION_ENTRY();
 
 	/* Since this thread will sleep, we must release the interpreter */
 
-	acpi_ex_relinquish_interpreter();
+	acpi_ex_exit_interpreter();
 
 	acpi_os_sleep(how_long);
 
 	/* And now we must get the interpreter again */
 
-	acpi_ex_reacquire_interpreter();
-	return (AE_OK);
+	status = acpi_ex_enter_interpreter();
+	return (status);
 }
 
 /*******************************************************************************
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/executer/exutils.c linux-2.6.21-rc4-git7/drivers/acpi/executer/exutils.c
--- linux-2.6.21-rc4-git5/drivers/acpi/executer/exutils.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/executer/exutils.c	2007-03-23 08:42:08.337057601 +0100
@@ -76,15 +76,14 @@ static u32 acpi_ex_digits_needed(acpi_in
  *
  * PARAMETERS:  None
  *
- * RETURN:      None
+ * RETURN:      Status
  *
- * DESCRIPTION: Enter the interpreter execution region. Failure to enter
- *              the interpreter region is a fatal system error. Used in
- *              conjunction with exit_interpreter.
+ * DESCRIPTION: Enter the interpreter execution region.  Failure to enter
+ *              the interpreter region is a fatal system error
  *
  ******************************************************************************/
 
-void acpi_ex_enter_interpreter(void)
+acpi_status acpi_ex_enter_interpreter(void)
 {
 	acpi_status status;
 
@@ -92,42 +91,10 @@ void acpi_ex_enter_interpreter(void)
 
 	status = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);
 	if (ACPI_FAILURE(status)) {
-		ACPI_ERROR((AE_INFO,
-			    "Could not acquire AML Interpreter mutex"));
+		ACPI_ERROR((AE_INFO, "Could not acquire interpreter mutex"));
 	}
 
-	return_VOID;
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ex_reacquire_interpreter
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Reacquire the interpreter execution region from within the
- *              interpreter code. Failure to enter the interpreter region is a
- *              fatal system error. Used in  conjuction with
- *              relinquish_interpreter
- *
- ******************************************************************************/
-
-void acpi_ex_reacquire_interpreter(void)
-{
-	ACPI_FUNCTION_TRACE(ex_reacquire_interpreter);
-
-	/*
-	 * If the global serialized flag is set, do not release the interpreter,
-	 * since it was not actually released by acpi_ex_relinquish_interpreter.
-	 * This forces the interpreter to be single threaded.
-	 */
-	if (!acpi_gbl_all_methods_serialized) {
-		acpi_ex_enter_interpreter();
-	}
-
-	return_VOID;
+	return_ACPI_STATUS(status);
 }
 
 /*******************************************************************************
@@ -138,9 +105,17 @@ void acpi_ex_reacquire_interpreter(void)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Exit the interpreter execution region. This is the top level
- *              routine used to exit the interpreter when all processing has
- *              been completed.
+ * DESCRIPTION: Exit the interpreter execution region
+ *
+ * Cases where the interpreter is unlocked:
+ *      1) Completion of the execution of a control method
+ *      2) Method blocked on a Sleep() AML opcode
+ *      3) Method blocked on an Acquire() AML opcode
+ *      4) Method blocked on a Wait() AML opcode
+ *      5) Method blocked to acquire the global lock
+ *      6) Method blocked to execute a serialized control method that is
+ *          already executing
+ *      7) About to invoke a user-installed opregion handler
  *
  ******************************************************************************/
 
@@ -152,46 +127,7 @@ void acpi_ex_exit_interpreter(void)
 
 	status = acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);
 	if (ACPI_FAILURE(status)) {
-		ACPI_ERROR((AE_INFO,
-			    "Could not release AML Interpreter mutex"));
-	}
-
-	return_VOID;
-}
-
-/*******************************************************************************
- *
- * FUNCTION:    acpi_ex_relinquish_interpreter
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Exit the interpreter execution region, from within the
- *              interpreter - before attempting an operation that will possibly
- *              block the running thread.
- *
- * Cases where the interpreter is unlocked internally
- *      1) Method to be blocked on a Sleep() AML opcode
- *      2) Method to be blocked on an Acquire() AML opcode
- *      3) Method to be blocked on a Wait() AML opcode
- *      4) Method to be blocked to acquire the global lock
- *      5) Method to be blocked waiting to execute a serialized control method
- *          that is currently executing
- *      6) About to invoke a user-installed opregion handler
- *
- ******************************************************************************/
-
-void acpi_ex_relinquish_interpreter(void)
-{
-	ACPI_FUNCTION_TRACE(ex_relinquish_interpreter);
-
-	/*
-	 * If the global serialized flag is set, do not release the interpreter.
-	 * This forces the interpreter to be single threaded.
-	 */
-	if (!acpi_gbl_all_methods_serialized) {
-		acpi_ex_exit_interpreter();
+		ACPI_ERROR((AE_INFO, "Could not release interpreter mutex"));
 	}
 
 	return_VOID;
@@ -205,8 +141,8 @@ void acpi_ex_relinquish_interpreter(void
  *
  * RETURN:      none
  *
- * DESCRIPTION: Truncate an ACPI Integer to 32 bits if the execution mode is
- *              32-bit, as determined by the revision of the DSDT.
+ * DESCRIPTION: Truncate a number to 32-bits if the currently executing method
+ *              belongs to a 32-bit ACPI table.
  *
  ******************************************************************************/
 
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/hardware/hwsleep.c linux-2.6.21-rc4-git7/drivers/acpi/hardware/hwsleep.c
--- linux-2.6.21-rc4-git5/drivers/acpi/hardware/hwsleep.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/hardware/hwsleep.c	2007-03-23 08:42:08.347057548 +0100
@@ -300,6 +300,11 @@ acpi_status asmlinkage acpi_enter_sleep_
 	/*
 	 * 2) Enable all wakeup GPEs
 	 */
+	status = acpi_hw_disable_all_gpes();
+	if (ACPI_FAILURE(status)) {
+		return_ACPI_STATUS(status);
+	}
+
 	acpi_gbl_system_awake_and_running = FALSE;
 
 	status = acpi_hw_enable_all_wakeup_gpes();
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/ibm_acpi.c linux-2.6.21-rc4-git7/drivers/acpi/ibm_acpi.c
--- linux-2.6.21-rc4-git5/drivers/acpi/ibm_acpi.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/ibm_acpi.c	2007-03-23 08:42:08.347057548 +0100
@@ -2507,7 +2507,7 @@ static int __init setup_notify(struct ib
 	ret = acpi_bus_get_device(*ibm->handle, &ibm->device);
 	if (ret < 0) {
 		printk(IBM_ERR "%s device not present\n", ibm->name);
-		return 0;
+		return -ENODEV;
 	}
 
 	acpi_driver_data(ibm->device) = ibm;
@@ -2516,8 +2516,13 @@ static int __init setup_notify(struct ib
 	status = acpi_install_notify_handler(*ibm->handle, ibm->type,
 					     dispatch_notify, ibm);
 	if (ACPI_FAILURE(status)) {
-		printk(IBM_ERR "acpi_install_notify_handler(%s) failed: %d\n",
-		       ibm->name, status);
+		if (status == AE_ALREADY_EXISTS) {
+			printk(IBM_NOTICE "another device driver is already handling %s events\n",
+				ibm->name);
+		} else {
+			printk(IBM_ERR "acpi_install_notify_handler(%s) failed: %d\n",
+				ibm->name, status);
+		}
 		return -ENODEV;
 	}
 	ibm->notify_installed = 1;
@@ -2553,6 +2558,8 @@ static int __init register_driver(struct
 	return ret;
 }
 
+static void ibm_exit(struct ibm_struct *ibm);
+
 static int __init ibm_init(struct ibm_struct *ibm)
 {
 	int ret;
@@ -2594,6 +2601,12 @@ static int __init ibm_init(struct ibm_st
 
 	if (ibm->notify) {
 		ret = setup_notify(ibm);
+		if (ret == -ENODEV) {
+			printk(IBM_NOTICE "disabling subdriver %s\n",
+				ibm->name);
+			ibm_exit(ibm);
+			return 0;
+		}
 		if (ret < 0)
 			return ret;
 	}
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/namespace/nseval.c linux-2.6.21-rc4-git7/drivers/acpi/namespace/nseval.c
--- linux-2.6.21-rc4-git5/drivers/acpi/namespace/nseval.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/namespace/nseval.c	2007-03-23 08:42:08.347057548 +0100
@@ -154,7 +154,11 @@ acpi_status acpi_ns_evaluate(struct acpi
 		 * Execute the method via the interpreter. The interpreter is locked
 		 * here before calling into the AML parser
 		 */
-		acpi_ex_enter_interpreter();
+		status = acpi_ex_enter_interpreter();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
+
 		status = acpi_ps_execute_method(info);
 		acpi_ex_exit_interpreter();
 	} else {
@@ -178,7 +182,10 @@ acpi_status acpi_ns_evaluate(struct acpi
 		 * resolution, we must lock it because we could access an opregion.
 		 * The opregion access code assumes that the interpreter is locked.
 		 */
-		acpi_ex_enter_interpreter();
+		status = acpi_ex_enter_interpreter();
+		if (ACPI_FAILURE(status)) {
+			return_ACPI_STATUS(status);
+		}
 
 		/* Function has a strange interface */
 
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/namespace/nsinit.c linux-2.6.21-rc4-git7/drivers/acpi/namespace/nsinit.c
--- linux-2.6.21-rc4-git5/drivers/acpi/namespace/nsinit.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/namespace/nsinit.c	2007-03-23 08:42:08.347057548 +0100
@@ -214,7 +214,7 @@ acpi_ns_init_one_object(acpi_handle obj_
 			u32 level, void *context, void **return_value)
 {
 	acpi_object_type type;
-	acpi_status status = AE_OK;
+	acpi_status status;
 	struct acpi_init_walk_info *info =
 	    (struct acpi_init_walk_info *)context;
 	struct acpi_namespace_node *node =
@@ -268,7 +268,10 @@ acpi_ns_init_one_object(acpi_handle obj_
 	/*
 	 * Must lock the interpreter before executing AML code
 	 */
-	acpi_ex_enter_interpreter();
+	status = acpi_ex_enter_interpreter();
+	if (ACPI_FAILURE(status)) {
+		return (status);
+	}
 
 	/*
 	 * Each of these types can contain executable AML code within the
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/namespace/nsxfeval.c linux-2.6.21-rc4-git7/drivers/acpi/namespace/nsxfeval.c
--- linux-2.6.21-rc4-git5/drivers/acpi/namespace/nsxfeval.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/namespace/nsxfeval.c	2007-03-23 08:42:08.357057496 +0100
@@ -170,6 +170,7 @@ acpi_evaluate_object(acpi_handle handle,
 		     struct acpi_buffer *return_buffer)
 {
 	acpi_status status;
+	acpi_status status2;
 	struct acpi_evaluate_info *info;
 	acpi_size buffer_space_needed;
 	u32 i;
@@ -328,12 +329,14 @@ acpi_evaluate_object(acpi_handle handle,
 		 * Delete the internal return object. NOTE: Interpreter must be
 		 * locked to avoid race condition.
 		 */
-		acpi_ex_enter_interpreter();
+		status2 = acpi_ex_enter_interpreter();
+		if (ACPI_SUCCESS(status2)) {
 
-		/* Remove one reference on the return object (should delete it) */
+			/* Remove one reference on the return object (should delete it) */
 
-		acpi_ut_remove_reference(info->return_object);
-		acpi_ex_exit_interpreter();
+			acpi_ut_remove_reference(info->return_object);
+			acpi_ex_exit_interpreter();
+		}
 	}
 
       cleanup:
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/processor_idle.c linux-2.6.21-rc4-git7/drivers/acpi/processor_idle.c
--- linux-2.6.21-rc4-git5/drivers/acpi/processor_idle.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/processor_idle.c	2007-03-23 08:42:08.357057496 +0100
@@ -89,6 +89,12 @@ module_param(nocst, uint, 0000);
 static unsigned int bm_history __read_mostly =
     (HZ >= 800 ? 0xFFFFFFFF : ((1U << (HZ / 25)) - 1));
 module_param(bm_history, uint, 0644);
+
+static unsigned use_ipi = 2;
+module_param(use_ipi, uint, 0644);
+MODULE_PARM_DESC(use_ipi, "IPI (vs. LAPIC) irqs for not waking up from C2/C3"
+		 " machines. 0=apic, 1=ipi, 2=auto\n");
+
 /* --------------------------------------------------------------------------
                                 Power Management
    -------------------------------------------------------------------------- */
@@ -260,9 +266,8 @@ static void acpi_cstate_enter(struct acp
 
 /*
  * Some BIOS implementations switch to C3 in the published C2 state.
- * This seems to be a common problem on AMD boxen, but other vendors
- * are affected too. We pick the most conservative approach: we assume
- * that the local APIC stops in both C2 and C3.
+ * This seems to be a common problem on AMD boxen and Intel Dothan/Banias
+ * Pentium M machines.
  */
 static void acpi_timer_check_state(int state, struct acpi_processor *pr,
 				   struct acpi_processor_cx *cx)
@@ -276,8 +281,17 @@ static void acpi_timer_check_state(int s
 	if (pwr->timer_broadcast_on_state < state)
 		return;
 
-	if (cx->type >= ACPI_STATE_C2)
-		pr->power.timer_broadcast_on_state = state;
+	if (cx->type >= ACPI_STATE_C2) {
+		if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD)
+			pr->power.timer_broadcast_on_state = state;
+		else if ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&
+			  boot_cpu_data.x86 == 6) &&
+			 (boot_cpu_data.x86_model == 13 ||
+			  boot_cpu_data.x86_model == 9))
+		{
+			pr->power.timer_broadcast_on_state = state;
+		}
+	}
 }
 
 static void acpi_propagate_timer_broadcast(struct acpi_processor *pr)
@@ -292,10 +306,16 @@ static void acpi_propagate_timer_broadca
 #else
 	cpumask_t mask = cpumask_of_cpu(pr->id);
 
-	if (pr->power.timer_broadcast_on_state < INT_MAX)
+	if (use_ipi == 0)
 		on_each_cpu(switch_APIC_timer_to_ipi, &mask, 1, 1);
-	else
+	else if (use_ipi == 1)
 		on_each_cpu(switch_ipi_to_APIC_timer, &mask, 1, 1);
+	else {
+		if (pr->power.timer_broadcast_on_state < INT_MAX)
+			on_each_cpu(switch_APIC_timer_to_ipi, &mask, 1, 1);
+		else
+			on_each_cpu(switch_ipi_to_APIC_timer, &mask, 1, 1);
+	}
 #endif
 }
 
@@ -1013,13 +1033,13 @@ static int acpi_processor_power_verify(s
 
 		case ACPI_STATE_C2:
 			acpi_processor_power_verify_c2(cx);
-			if (cx->valid)
+			if (cx->valid && use_ipi != 0 && use_ipi != 1)
 				acpi_timer_check_state(i, pr, cx);
 			break;
 
 		case ACPI_STATE_C3:
 			acpi_processor_power_verify_c3(pr, cx);
-			if (cx->valid)
+			if (cx->valid && use_ipi != 0 && use_ipi != 1)
 				acpi_timer_check_state(i, pr, cx);
 			break;
 		}
diff -purN linux-2.6.21-rc4-git5/drivers/acpi/tables.c linux-2.6.21-rc4-git7/drivers/acpi/tables.c
--- linux-2.6.21-rc4-git5/drivers/acpi/tables.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/acpi/tables.c	2007-03-23 08:42:08.357057496 +0100
@@ -42,7 +42,9 @@ static char *mps_inti_flags_trigger[] = 
 
 static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
-void acpi_table_print_madt_entry(struct acpi_subtable_header * header)
+static int acpi_apic_instance __initdata = 2;
+
+void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 {
 	if (!header)
 		return;
@@ -183,8 +185,10 @@ acpi_table_parse_entries(char *id,
 	if (!handler)
 		return -EINVAL;
 
-	/* Locate the table (if exists). There should only be one. */
-	acpi_get_table(id, 0, &table_header);
+	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
+		acpi_get_table(id, acpi_apic_instance, &table_header);
+	else
+		acpi_get_table(id, 0, &table_header);
 
 	if (!table_header) {
 		printk(KERN_WARNING PREFIX "%4.4s not present\n", id);
@@ -237,10 +241,15 @@ acpi_table_parse_madt(enum acpi_madt_typ
 int __init acpi_table_parse(char *id, acpi_table_handler handler)
 {
 	struct acpi_table_header *table = NULL;
+
 	if (!handler)
 		return -EINVAL;
 
-	acpi_get_table(id, 0, &table);
+	if (strncmp(id, ACPI_SIG_MADT, 4) == 0)
+		acpi_get_table(id, acpi_apic_instance, &table);
+	else
+		acpi_get_table(id, 0, &table);
+
 	if (table) {
 		handler(table);
 		return 0;
@@ -248,6 +257,31 @@ int __init acpi_table_parse(char *id, ac
 		return 1;
 }
 
+/* 
+ * The BIOS is supposed to supply a single APIC/MADT,
+ * but some report two.  Provide a knob to use either.
+ * (don't you wish instance 0 and 1 were not the same?)
+ */
+static void __init check_multiple_madt(void)
+{
+	struct acpi_table_header *table = NULL;
+
+	acpi_get_table(ACPI_SIG_MADT, 2, &table);
+	if (table) {
+		printk(KERN_WARNING PREFIX
+		       "BIOS bug: multiple APIC/MADT found,"
+		       " using %d\n", acpi_apic_instance);
+		printk(KERN_WARNING PREFIX
+		       "If \"acpi_apic_instance=%d\" works better, "
+		       "notify linux-acpi@vger.kernel.org\n",
+		       acpi_apic_instance ? 0 : 2);
+
+	} else
+		acpi_apic_instance = 0;
+
+	return;
+}
+
 /*
  * acpi_table_init()
  *
@@ -257,9 +291,22 @@ int __init acpi_table_parse(char *id, ac
  * result: sdt_entry[] is initialized
  */
 
-
 int __init acpi_table_init(void)
 {
 	acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);
+	check_multiple_madt();
+	return 0;
+}
+
+static int __init acpi_parse_apic_instance(char *str)
+{
+
+	acpi_apic_instance = simple_strtoul(str, NULL, 0);
+
+	printk(KERN_NOTICE PREFIX "Shall use APIC/MADT table %d\n",
+	       acpi_apic_instance);
+
 	return 0;
 }
+
+early_param("acpi_apic_instance", acpi_parse_apic_instance);
diff -purN linux-2.6.21-rc4-git5/drivers/i2c/busses/i2c-amd8111.c linux-2.6.21-rc4-git7/drivers/i2c/busses/i2c-amd8111.c
--- linux-2.6.21-rc4-git5/drivers/i2c/busses/i2c-amd8111.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/i2c/busses/i2c-amd8111.c	2007-03-23 08:42:08.397057285 +0100
@@ -254,7 +254,8 @@ static s32 amd8111_access(struct i2c_ada
 			break;
 
 		case I2C_SMBUS_BLOCK_PROC_CALL:
-			len = min_t(u8, data->block[0], 31);
+			len = min_t(u8, data->block[0],
+				    I2C_SMBUS_BLOCK_MAX - 1);
 			amd_ec_write(smbus, AMD_SMB_CMD, command);
 			amd_ec_write(smbus, AMD_SMB_BCNT, len);
 			for (i = 0; i < len; i++)
diff -purN linux-2.6.21-rc4-git5/drivers/i2c/busses/i2c-i801.c linux-2.6.21-rc4-git7/drivers/i2c/busses/i2c-i801.c
--- linux-2.6.21-rc4-git5/drivers/i2c/busses/i2c-i801.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/i2c/busses/i2c-i801.c	2007-03-23 08:42:08.397057285 +0100
@@ -97,6 +97,7 @@ static int i801_block_transaction(union 
 				  int command, int hwpec);
 
 static unsigned long i801_smba;
+static unsigned char i801_original_hstcfg;
 static struct pci_driver i801_driver;
 static struct pci_dev *I801_dev;
 static int isich4;
@@ -510,6 +511,7 @@ static int __devinit i801_probe(struct p
 	}
 
 	pci_read_config_byte(I801_dev, SMBHSTCFG, &temp);
+	i801_original_hstcfg = temp;
 	temp &= ~SMBHSTCFG_I2C_EN;	/* SMBus timing */
 	if (!(temp & SMBHSTCFG_HST_EN)) {
 		dev_info(&dev->dev, "Enabling SMBus device\n");
@@ -543,6 +545,7 @@ exit:
 static void __devexit i801_remove(struct pci_dev *dev)
 {
 	i2c_del_adapter(&i801_adapter);
+	pci_write_config_byte(I801_dev, SMBHSTCFG, i801_original_hstcfg);
 	pci_release_region(dev, SMBBAR);
 	/*
 	 * do not call pci_disable_device(dev) since it can cause hard hangs on
@@ -550,11 +553,33 @@ static void __devexit i801_remove(struct
 	 */
 }
 
+#ifdef CONFIG_PM
+static int i801_suspend(struct pci_dev *dev, pm_message_t mesg)
+{
+	pci_save_state(dev);
+	pci_write_config_byte(dev, SMBHSTCFG, i801_original_hstcfg);
+	pci_set_power_state(dev, pci_choose_state(dev, mesg));
+	return 0;
+}
+
+static int i801_resume(struct pci_dev *dev)
+{
+	pci_set_power_state(dev, PCI_D0);
+	pci_restore_state(dev);
+	return pci_enable_device(dev);
+}
+#else
+#define i801_suspend NULL
+#define i801_resume NULL
+#endif
+
 static struct pci_driver i801_driver = {
 	.name		= "i801_smbus",
 	.id_table	= i801_ids,
 	.probe		= i801_probe,
 	.remove		= __devexit_p(i801_remove),
+	.suspend	= i801_suspend,
+	.resume		= i801_resume,
 };
 
 static int __init i2c_i801_init(void)
diff -purN linux-2.6.21-rc4-git5/drivers/i2c/chips/ds1374.c linux-2.6.21-rc4-git7/drivers/i2c/chips/ds1374.c
--- linux-2.6.21-rc4-git5/drivers/i2c/chips/ds1374.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/i2c/chips/ds1374.c	2007-03-23 08:42:08.397057285 +0100
@@ -207,6 +207,10 @@ static int ds1374_probe(struct i2c_adapt
 	client->driver = &ds1374_driver;
 
 	ds1374_workqueue = create_singlethread_workqueue("ds1374");
+	if (!ds1374_workqueue) {
+		kfree(client);
+		return -ENOMEM;	/* most expected reason */
+	}
 
 	if ((rc = i2c_attach_client(client)) != 0) {
 		kfree(client);
diff -purN linux-2.6.21-rc4-git5/drivers/infiniband/hw/cxgb3/iwch_provider.c linux-2.6.21-rc4-git7/drivers/infiniband/hw/cxgb3/iwch_provider.c
--- linux-2.6.21-rc4-git5/drivers/infiniband/hw/cxgb3/iwch_provider.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/infiniband/hw/cxgb3/iwch_provider.c	2007-03-23 08:42:08.437057075 +0100
@@ -545,11 +545,14 @@ static int iwch_reregister_phys_mem(stru
 		php = to_iwch_pd(pd);
 	if (mr_rereg_mask & IB_MR_REREG_ACCESS)
 		mh.attr.perms = iwch_ib_to_tpt_access(acc);
-	if (mr_rereg_mask & IB_MR_REREG_TRANS)
+	if (mr_rereg_mask & IB_MR_REREG_TRANS) {
 		ret = build_phys_page_list(buffer_list, num_phys_buf,
 					   iova_start,
 					   &total_size, &npages,
 					   &shift, &page_list);
+		if (ret)
+			return ret;
+	}
 
 	ret = iwch_reregister_mem(rhp, php, &mh, shift, page_list, npages);
 	kfree(page_list);
diff -purN linux-2.6.21-rc4-git5/drivers/infiniband/hw/ehca/ehca_irq.c linux-2.6.21-rc4-git7/drivers/infiniband/hw/ehca/ehca_irq.c
--- linux-2.6.21-rc4-git5/drivers/infiniband/hw/ehca/ehca_irq.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/infiniband/hw/ehca/ehca_irq.c	2007-03-23 08:42:08.447057022 +0100
@@ -66,7 +66,9 @@
 static void queue_comp_task(struct ehca_cq *__cq);
 
 static struct ehca_comp_pool* pool;
+#ifdef CONFIG_HOTPLUG_CPU
 static struct notifier_block comp_pool_callback_nb;
+#endif
 
 static inline void comp_event_callback(struct ehca_cq *cq)
 {
@@ -733,6 +735,7 @@ static void take_over_work(struct ehca_c
 
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
 static int comp_pool_callback(struct notifier_block *nfb,
 			      unsigned long action,
 			      void *hcpu)
@@ -775,6 +778,7 @@ static int comp_pool_callback(struct not
 
 	return NOTIFY_OK;
 }
+#endif
 
 int ehca_create_comp_pool(void)
 {
@@ -805,9 +809,11 @@ int ehca_create_comp_pool(void)
 		}
 	}
 
+#ifdef CONFIG_HOTPLUG_CPU
 	comp_pool_callback_nb.notifier_call = comp_pool_callback;
 	comp_pool_callback_nb.priority =0;
 	register_cpu_notifier(&comp_pool_callback_nb);
+#endif
 
 	printk(KERN_INFO "eHCA scaling code enabled\n");
 
@@ -821,7 +827,9 @@ void ehca_destroy_comp_pool(void)
 	if (!ehca_scaling_code)
 		return;
 
+#ifdef CONFIG_HOTPLUG_CPU
 	unregister_cpu_notifier(&comp_pool_callback_nb);
+#endif
 
 	for (i = 0; i < NR_CPUS; i++) {
 		if (cpu_online(i))
diff -purN linux-2.6.21-rc4-git5/drivers/infiniband/hw/ipath/ipath_fs.c linux-2.6.21-rc4-git7/drivers/infiniband/hw/ipath/ipath_fs.c
--- linux-2.6.21-rc4-git5/drivers/infiniband/hw/ipath/ipath_fs.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/infiniband/hw/ipath/ipath_fs.c	2007-03-23 08:42:08.447057022 +0100
@@ -451,12 +451,18 @@ bail:
 	return ret;
 }
 
-static void remove_file(struct dentry *parent, char *name)
+static int remove_file(struct dentry *parent, char *name)
 {
 	struct dentry *tmp;
+	int ret;
 
 	tmp = lookup_one_len(name, parent, strlen(name));
 
+	if (IS_ERR(tmp)) {
+		ret = PTR_ERR(tmp);
+		goto bail;
+	}
+
 	spin_lock(&dcache_lock);
 	spin_lock(&tmp->d_lock);
 	if (!(d_unhashed(tmp) && tmp->d_inode)) {
@@ -469,6 +475,14 @@ static void remove_file(struct dentry *p
 		spin_unlock(&tmp->d_lock);
 		spin_unlock(&dcache_lock);
 	}
+
+	ret = 0;
+bail:
+	/*
+	 * We don't expect clients to care about the return value, but
+	 * it's there if they need it.
+	 */
+	return ret;
 }
 
 static int remove_device_files(struct super_block *sb,
diff -purN linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_cm.c linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_cm.c
--- linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_cm.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_cm.c	2007-03-23 08:42:08.447057022 +0100
@@ -452,7 +452,7 @@ void ipoib_cm_send(struct net_device *de
 			   skb->len, tx->mtu);
 		++priv->stats.tx_dropped;
 		++priv->stats.tx_errors;
-		ipoib_cm_skb_too_long(dev, skb, tx->mtu - INFINIBAND_ALEN);
+		ipoib_cm_skb_too_long(dev, skb, tx->mtu - IPOIB_ENCAP_LEN);
 		return;
 	}
 
@@ -1095,7 +1095,7 @@ static void ipoib_cm_stale_task(struct w
 		/* List if sorted by LRU, start from tail,
 		 * stop when we see a recently used entry */
 		p = list_entry(priv->cm.passive_ids.prev, typeof(*p), list);
-		if (time_after_eq(jiffies, p->jiffies + IPOIB_CM_RX_TIMEOUT))
+		if (time_before_eq(jiffies, p->jiffies + IPOIB_CM_RX_TIMEOUT))
 			break;
 		list_del_init(&p->list);
 		spin_unlock_irqrestore(&priv->lock, flags);
diff -purN linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_ib.c linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_ib.c
--- linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_ib.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_ib.c	2007-03-23 08:42:08.447057022 +0100
@@ -328,9 +328,9 @@ void ipoib_send(struct net_device *dev, 
 	struct ipoib_tx_buf *tx_req;
 	u64 addr;
 
-	if (unlikely(skb->len > priv->mcast_mtu + INFINIBAND_ALEN)) {
+	if (unlikely(skb->len > priv->mcast_mtu + IPOIB_ENCAP_LEN)) {
 		ipoib_warn(priv, "packet len %d (> %d) too long to send, dropping\n",
-			   skb->len, priv->mcast_mtu + INFINIBAND_ALEN);
+			   skb->len, priv->mcast_mtu + IPOIB_ENCAP_LEN);
 		++priv->stats.tx_dropped;
 		++priv->stats.tx_errors;
 		ipoib_cm_skb_too_long(dev, skb, priv->mcast_mtu);
diff -purN linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_main.c linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_main.c
--- linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_main.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_main.c	2007-03-23 08:42:08.457056970 +0100
@@ -380,7 +380,7 @@ static void path_rec_completion(int stat
 	struct net_device *dev = path->dev;
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct ipoib_ah *ah = NULL;
-	struct ipoib_neigh *neigh;
+	struct ipoib_neigh *neigh, *tn;
 	struct sk_buff_head skqueue;
 	struct sk_buff *skb;
 	unsigned long flags;
@@ -418,7 +418,7 @@ static void path_rec_completion(int stat
 		while ((skb = __skb_dequeue(&path->queue)))
 			__skb_queue_tail(&skqueue, skb);
 
-		list_for_each_entry(neigh, &path->neigh_list, list) {
+		list_for_each_entry_safe(neigh, tn, &path->neigh_list, list) {
 			kref_get(&path->ah->ref);
 			neigh->ah = path->ah;
 			memcpy(&neigh->dgid.raw, &path->pathrec.dgid.raw,
diff -purN linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_multicast.c linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
--- linux-2.6.21-rc4-git5/drivers/infiniband/ulp/ipoib/ipoib_multicast.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/infiniband/ulp/ipoib/ipoib_multicast.c	2007-03-23 08:42:08.457056970 +0100
@@ -644,6 +644,9 @@ static int ipoib_mcast_leave(struct net_
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	int ret = 0;
 
+	if (test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))
+		ib_sa_free_multicast(mcast->mc);
+
 	if (test_and_clear_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {
 		ipoib_dbg_mcast(priv, "leaving MGID " IPOIB_GID_FMT "\n",
 				IPOIB_GID_ARG(mcast->mcmember.mgid));
@@ -655,9 +658,6 @@ static int ipoib_mcast_leave(struct net_
 			ipoib_warn(priv, "ipoib_mcast_detach failed (result = %d)\n", ret);
 	}
 
-	if (test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))
-		ib_sa_free_multicast(mcast->mc);
-
 	return 0;
 }
 
diff -purN linux-2.6.21-rc4-git5/drivers/net/irda/irda-usb.c linux-2.6.21-rc4-git7/drivers/net/irda/irda-usb.c
--- linux-2.6.21-rc4-git5/drivers/net/irda/irda-usb.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/net/irda/irda-usb.c	2007-03-23 08:42:08.467056917 +0100
@@ -1057,6 +1057,8 @@ static int stir421x_fw_upload(struct ird
 
 		if (ret < 0)
 			break;
+
+		mdelay(10);
 	}
 
 	kfree(patch_block);
diff -purN linux-2.6.21-rc4-git5/drivers/video/s3fb.c linux-2.6.21-rc4-git7/drivers/video/s3fb.c
--- linux-2.6.21-rc4-git5/drivers/video/s3fb.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/drivers/video/s3fb.c	2007-03-23 08:42:08.517056654 +0100
@@ -1000,11 +1000,12 @@ err_enable_device:
 static void __devexit s3_pci_remove(struct pci_dev *dev)
 {
 	struct fb_info *info = pci_get_drvdata(dev);
-	struct s3fb_info *par = info->par;
 
 	if (info) {
 
 #ifdef CONFIG_MTRR
+		struct s3fb_info *par = info->par;
+
 		if (par->mtrr_reg >= 0) {
 			mtrr_del(par->mtrr_reg, 0, 0);
 			par->mtrr_reg = -1;
diff -purN linux-2.6.21-rc4-git5/fs/cifs/CHANGES linux-2.6.21-rc4-git7/fs/cifs/CHANGES
--- linux-2.6.21-rc4-git5/fs/cifs/CHANGES	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/fs/cifs/CHANGES	2007-03-23 08:42:08.527056602 +0100
@@ -4,6 +4,12 @@ Fix mtime bouncing around from local ide
 Fix hang (in i_size_read) when simultaneous size update of same remote file
 on smp system corrupts sequence number. Do not reread unnecessarily partial page
 (which we are about to overwrite anyway) when writing out file opened rw.
+When DOS attribute of file on non-Unix server's file changes on the server side
+from read-only back to read-write, reflect this change in default file mode
+(we had been leaving a file's mode read-only until the inode were reloaded).
+Allow setting of attribute back to ATTR_NORMAL (removing readonly dos attribute
+when archive dos attribute not set and we are changing mode back to writeable
+on server which does not support the Unix Extensions).
 
 Version 1.47
 ------------
diff -purN linux-2.6.21-rc4-git5/fs/cifs/cifspdu.h linux-2.6.21-rc4-git7/fs/cifs/cifspdu.h
--- linux-2.6.21-rc4-git5/fs/cifs/cifspdu.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/fs/cifs/cifspdu.h	2007-03-23 08:42:08.527056602 +0100
@@ -1887,7 +1887,13 @@ typedef struct {
 						      calls including posix open
 						      and posix unlink */ 
 #ifdef CONFIG_CIFS_POSIX
-#define CIFS_UNIX_CAP_MASK              0x0000003b
+/* Can not set pathnames cap yet until we send new posix create SMB since
+   otherwise server can treat such handles opened with older ntcreatex
+   (by a new client which knows how to send posix path ops)
+   as non-posix handles (can affect write behavior with byte range locks.
+   We can add back in POSIX_PATH_OPS cap when Posix Create/Mkdir finished */
+/* #define CIFS_UNIX_CAP_MASK              0x0000003b */
+#define CIFS_UNIX_CAP_MASK              0x0000001b 
 #else 
 #define CIFS_UNIX_CAP_MASK              0x00000013
 #endif /* CONFIG_CIFS_POSIX */
diff -purN linux-2.6.21-rc4-git5/fs/cifs/inode.c linux-2.6.21-rc4-git7/fs/cifs/inode.c
--- linux-2.6.21-rc4-git5/fs/cifs/inode.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/fs/cifs/inode.c	2007-03-23 08:42:08.537056549 +0100
@@ -494,6 +494,12 @@ int cifs_get_inode_info(struct inode **p
 			   mode e.g. 555 */
 			if (cifsInfo->cifsAttrs & ATTR_READONLY)
 				inode->i_mode &= ~(S_IWUGO);
+			else if ((inode->i_mode & S_IWUGO) == 0)
+				/* the ATTR_READONLY flag may have been	*/
+				/* changed on server -- set any w bits	*/
+				/* allowed by mnt_file_mode		*/
+				inode->i_mode |= (S_IWUGO &
+						  cifs_sb->mnt_file_mode);
 		/* BB add code here -
 		   validate if device or weird share or device type? */
 		}
@@ -1190,6 +1196,7 @@ int cifs_setattr(struct dentry *direntry
 	struct cifsFileInfo *open_file = NULL;
 	FILE_BASIC_INFO time_buf;
 	int set_time = FALSE;
+	int set_dosattr = FALSE;
 	__u64 mode = 0xFFFFFFFFFFFFFFFFULL;
 	__u64 uid = 0xFFFFFFFFFFFFFFFFULL;
 	__u64 gid = 0xFFFFFFFFFFFFFFFFULL;
@@ -1326,15 +1333,23 @@ int cifs_setattr(struct dentry *direntry
 	else if (attrs->ia_valid & ATTR_MODE) {
 		rc = 0;
 		if ((mode & S_IWUGO) == 0) /* not writeable */ {
-			if ((cifsInode->cifsAttrs & ATTR_READONLY) == 0)
+			if ((cifsInode->cifsAttrs & ATTR_READONLY) == 0) {
+				set_dosattr = TRUE;
 				time_buf.Attributes =
 					cpu_to_le32(cifsInode->cifsAttrs |
 						    ATTR_READONLY);
+			}
 		} else if ((mode & S_IWUGO) == S_IWUGO) {
-			if (cifsInode->cifsAttrs & ATTR_READONLY)
+			if (cifsInode->cifsAttrs & ATTR_READONLY) {
+				set_dosattr = TRUE;
 				time_buf.Attributes =
 					cpu_to_le32(cifsInode->cifsAttrs &
 						    (~ATTR_READONLY));
+				/* Windows ignores set to zero */
+				if(time_buf.Attributes == 0)
+					time_buf.Attributes |= 
+						cpu_to_le32(ATTR_NORMAL);
+			}
 		}
 		/* BB to be implemented -
 		   via Windows security descriptors or streams */
@@ -1372,7 +1387,7 @@ int cifs_setattr(struct dentry *direntry
 	} else
 		time_buf.ChangeTime = 0;
 
-	if (set_time || time_buf.Attributes) {
+	if (set_time || set_dosattr) {
 		time_buf.CreationTime = 0;	/* do not change */
 		/* In the future we should experiment - try setting timestamps
 		   via Handle (SetFileInfo) instead of by path */
diff -purN linux-2.6.21-rc4-git5/fs/cifs/readdir.c linux-2.6.21-rc4-git7/fs/cifs/readdir.c
--- linux-2.6.21-rc4-git5/fs/cifs/readdir.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/fs/cifs/readdir.c	2007-03-23 08:42:08.537056549 +0100
@@ -219,6 +219,10 @@ static void fill_in_inode(struct inode *
 		tmp_inode->i_mode |= S_IFREG;
 		if (attr & ATTR_READONLY)
 			tmp_inode->i_mode &= ~(S_IWUGO);
+		else if ((tmp_inode->i_mode & S_IWUGO) == 0)
+			/* the ATTR_READONLY flag may have been changed on   */
+		   	/* server -- set any w bits allowed by mnt_file_mode */
+			tmp_inode->i_mode |= (S_IWUGO & cifs_sb->mnt_file_mode);
 	} /* could add code here - to validate if device or weird share type? */
 
 	/* can not fill in nlink here as in qpathinfo version and Unx search */
diff -purN linux-2.6.21-rc4-git5/fs/xfs/linux-2.6/xfs_buf.c linux-2.6.21-rc4-git7/fs/xfs/linux-2.6/xfs_buf.c
--- linux-2.6.21-rc4-git5/fs/xfs/linux-2.6/xfs_buf.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/fs/xfs/linux-2.6/xfs_buf.c	2007-03-23 08:42:08.567056392 +0100
@@ -1829,11 +1829,11 @@ xfs_buf_init(void)
 	if (!xfs_buf_zone)
 		goto out_free_trace_buf;
 
-	xfslogd_workqueue = create_freezeable_workqueue("xfslogd");
+	xfslogd_workqueue = create_workqueue("xfslogd");
 	if (!xfslogd_workqueue)
 		goto out_free_buf_zone;
 
-	xfsdatad_workqueue = create_freezeable_workqueue("xfsdatad");
+	xfsdatad_workqueue = create_workqueue("xfsdatad");
 	if (!xfsdatad_workqueue)
 		goto out_destroy_xfslogd_workqueue;
 
diff -purN linux-2.6.21-rc4-git5/include/acpi/acinterp.h linux-2.6.21-rc4-git7/include/acpi/acinterp.h
--- linux-2.6.21-rc4-git5/include/acpi/acinterp.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/acpi/acinterp.h	2007-03-23 08:42:08.567056392 +0100
@@ -446,14 +446,10 @@ acpi_ex_copy_integer_to_buffer_field(uni
 /*
  * exutils - interpreter/scanner utilities
  */
-void acpi_ex_enter_interpreter(void);
+acpi_status acpi_ex_enter_interpreter(void);
 
 void acpi_ex_exit_interpreter(void);
 
-void acpi_ex_reacquire_interpreter(void);
-
-void acpi_ex_relinquish_interpreter(void);
-
 void acpi_ex_truncate_for32bit_table(union acpi_operand_object *obj_desc);
 
 u8 acpi_ex_acquire_global_lock(u32 rule);
diff -purN linux-2.6.21-rc4-git5/include/acpi/actypes.h linux-2.6.21-rc4-git7/include/acpi/actypes.h
--- linux-2.6.21-rc4-git5/include/acpi/actypes.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/acpi/actypes.h	2007-03-23 08:42:08.567056392 +0100
@@ -344,7 +344,7 @@ typedef u32 acpi_integer;
 
 /* 64-bit integers */
 
-typedef u64 acpi_integer;
+typedef unsigned long long              acpi_integer;
 #define ACPI_INTEGER_MAX                ACPI_UINT64_MAX
 #define ACPI_INTEGER_BIT_SIZE           64
 #define ACPI_MAX_DECIMAL_DIGITS         20	/* 2^64 = 18,446,744,073,709,551,616 */
diff -purN linux-2.6.21-rc4-git5/include/asm-ia64/meminit.h linux-2.6.21-rc4-git7/include/asm-ia64/meminit.h
--- linux-2.6.21-rc4-git5/include/asm-ia64/meminit.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/asm-ia64/meminit.h	2007-03-23 08:42:08.577056339 +0100
@@ -36,6 +36,7 @@ extern void reserve_memory (void);
 extern void find_initrd (void);
 extern int filter_rsvd_memory (unsigned long start, unsigned long end, void *arg);
 extern void efi_memmap_init(unsigned long *, unsigned long *);
+extern int find_max_min_low_pfn (unsigned long , unsigned long, void *);
 
 extern unsigned long vmcore_find_descriptor_size(unsigned long address);
 extern int reserve_elfcorehdr(unsigned long *start, unsigned long *end);
diff -purN linux-2.6.21-rc4-git5/include/asm-powerpc/hvcall.h linux-2.6.21-rc4-git7/include/asm-powerpc/hvcall.h
--- linux-2.6.21-rc4-git5/include/asm-powerpc/hvcall.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/asm-powerpc/hvcall.h	2007-03-23 08:42:08.597056234 +0100
@@ -237,6 +237,20 @@ long plpar_hcall_norets(unsigned long op
 long plpar_hcall(unsigned long opcode, unsigned long *retbuf, ...);
 
 /**
+ * plpar_hcall_raw: - Make a hypervisor call without calculating hcall stats
+ * @opcode: The hypervisor call to make.
+ * @retbuf: Buffer to store up to 4 return arguments in.
+ *
+ * This call supports up to 6 arguments and 4 return arguments. Use
+ * PLPAR_HCALL_BUFSIZE to size the return argument buffer.
+ *
+ * Used when phyp interface needs to be called in real mode. Similar to
+ * plpar_hcall, but plpar_hcall_raw works in real mode and does not
+ * calculate hypervisor call statistics.
+ */
+long plpar_hcall_raw(unsigned long opcode, unsigned long *retbuf, ...);
+
+/**
  * plpar_hcall9: - Make a pseries hypervisor call with up to 9 return arguments
  * @opcode: The hypervisor call to make.
  * @retbuf: Buffer to store up to 9 return arguments in.
diff -purN linux-2.6.21-rc4-git5/include/linux/bootmem.h linux-2.6.21-rc4-git7/include/linux/bootmem.h
--- linux-2.6.21-rc4-git5/include/linux/bootmem.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/linux/bootmem.h	2007-03-23 08:42:08.607056181 +0100
@@ -108,7 +108,7 @@ static inline void *alloc_remap(int nid,
 #endif /* CONFIG_HAVE_ARCH_ALLOC_REMAP */
 
 extern unsigned long __meminitdata nr_kernel_pages;
-extern unsigned long nr_all_pages;
+extern unsigned long __meminitdata nr_all_pages;
 
 extern void *alloc_large_system_hash(const char *tablename,
 				     unsigned long bucketsize,
diff -purN linux-2.6.21-rc4-git5/include/linux/lockdep.h linux-2.6.21-rc4-git7/include/linux/lockdep.h
--- linux-2.6.21-rc4-git5/include/linux/lockdep.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/linux/lockdep.h	2007-03-23 08:42:08.607056181 +0100
@@ -245,7 +245,7 @@ extern void lock_release(struct lockdep_
 
 # define INIT_LOCKDEP				.lockdep_recursion = 0,
 
-#define lockdep_depth(tsk)	((tsk)->lockdep_depth)
+#define lockdep_depth(tsk)	(debug_locks ? (tsk)->lockdep_depth : 0)
 
 #else /* !LOCKDEP */
 
diff -purN linux-2.6.21-rc4-git5/include/net/sctp/structs.h linux-2.6.21-rc4-git7/include/net/sctp/structs.h
--- linux-2.6.21-rc4-git5/include/net/sctp/structs.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/net/sctp/structs.h	2007-03-23 08:42:08.617056129 +0100
@@ -1002,6 +1002,7 @@ void sctp_transport_update_rto(struct sc
 void sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);
 void sctp_transport_lower_cwnd(struct sctp_transport *, sctp_lower_cwnd_t);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
+void sctp_transport_reset(struct sctp_transport *);
 
 
 /* This is the structure we use to queue packets as they come into
diff -purN linux-2.6.21-rc4-git5/include/net/sctp/ulpqueue.h linux-2.6.21-rc4-git7/include/net/sctp/ulpqueue.h
--- linux-2.6.21-rc4-git5/include/net/sctp/ulpqueue.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/include/net/sctp/ulpqueue.h	2007-03-23 08:42:08.617056129 +0100
@@ -59,6 +59,7 @@ struct sctp_ulpq {
 /* Prototypes. */
 struct sctp_ulpq *sctp_ulpq_init(struct sctp_ulpq *,
 				 struct sctp_association *);
+void sctp_ulpq_flush(struct sctp_ulpq *ulpq);
 void sctp_ulpq_free(struct sctp_ulpq *);
 
 /* Add a new DATA chunk for processing. */
diff -purN linux-2.6.21-rc4-git5/kernel/lockdep.c linux-2.6.21-rc4-git7/kernel/lockdep.c
--- linux-2.6.21-rc4-git5/kernel/lockdep.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/kernel/lockdep.c	2007-03-23 08:42:08.627056076 +0100
@@ -2742,6 +2742,10 @@ void debug_show_all_locks(void)
 	int count = 10;
 	int unlock = 1;
 
+	if (unlikely(!debug_locks)) {
+		printk("INFO: lockdep is turned off.\n");
+		return;
+	}
 	printk("\nShowing all locks held in the system:\n");
 
 	/*
@@ -2785,6 +2789,10 @@ EXPORT_SYMBOL_GPL(debug_show_all_locks);
 
 void debug_show_held_locks(struct task_struct *task)
 {
+	if (unlikely(!debug_locks)) {
+		printk("INFO: lockdep is turned off.\n");
+		return;
+	}
 	lockdep_print_held_locks(task);
 }
 
diff -purN linux-2.6.21-rc4-git5/kernel/power/disk.c linux-2.6.21-rc4-git7/kernel/power/disk.c
--- linux-2.6.21-rc4-git5/kernel/power/disk.c	2007-03-23 08:42:01.487093612 +0100
+++ linux-2.6.21-rc4-git7/kernel/power/disk.c	2007-03-23 08:42:08.637056024 +0100
@@ -241,18 +241,11 @@ static int software_resume(void)
 		goto Done;
 	}
 
-	error = platform_prepare();
-	if (error) {
-		swsusp_free();
-		goto Thaw;
-	}
-
 	pr_debug("PM: Reading swsusp image.\n");
 
 	error = swsusp_read();
 	if (error) {
 		swsusp_free();
-		platform_finish();
 		goto Thaw;
 	}
 
@@ -270,7 +263,6 @@ static int software_resume(void)
 	enable_nonboot_cpus();
  Free:
 	swsusp_free();
-	platform_finish();
 	device_resume();
 	resume_console();
  Thaw:
diff -purN linux-2.6.21-rc4-git5/kernel/power/user.c linux-2.6.21-rc4-git7/kernel/power/user.c
--- linux-2.6.21-rc4-git5/kernel/power/user.c	2007-03-23 08:42:01.487093612 +0100
+++ linux-2.6.21-rc4-git7/kernel/power/user.c	2007-03-23 08:42:08.637056024 +0100
@@ -368,9 +368,12 @@ static int snapshot_ioctl(struct inode *
 		if (error) {
 			printk(KERN_ERR "Failed to suspend some devices.\n");
 		} else {
-			/* Enter S3, system is already frozen */
-			suspend_enter(PM_SUSPEND_MEM);
-
+			error = disable_nonboot_cpus();
+			if (!error) {
+				/* Enter S3, system is already frozen */
+				suspend_enter(PM_SUSPEND_MEM);
+				enable_nonboot_cpus();
+			}
 			/* Wake up devices */
 			device_resume();
 		}
diff -purN linux-2.6.21-rc4-git5/mm/nommu.c linux-2.6.21-rc4-git7/mm/nommu.c
--- linux-2.6.21-rc4-git5/mm/nommu.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/mm/nommu.c	2007-03-23 08:42:08.647055971 +0100
@@ -826,6 +826,11 @@ unsigned long do_mmap_pgoff(struct file 
 		unsigned long pglen = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;
 		unsigned long vmpglen;
 
+		/* suppress VMA sharing for shared regions */
+		if (vm_flags & VM_SHARED &&
+		    capabilities & BDI_CAP_MAP_DIRECT)
+			goto dont_share_VMAs;
+
 		for (rb = rb_first(&nommu_vma_tree); rb; rb = rb_next(rb)) {
 			vma = rb_entry(rb, struct vm_area_struct, vm_rb);
 
@@ -859,6 +864,7 @@ unsigned long do_mmap_pgoff(struct file 
 			goto shared;
 		}
 
+	dont_share_VMAs:
 		vma = NULL;
 
 		/* obtain the address at which to make a shared mapping
@@ -1193,6 +1199,28 @@ void unmap_mapping_range(struct address_
 EXPORT_SYMBOL(unmap_mapping_range);
 
 /*
+ * ask for an unmapped area at which to create a mapping on a file
+ */
+unsigned long get_unmapped_area(struct file *file, unsigned long addr,
+				unsigned long len, unsigned long pgoff,
+				unsigned long flags)
+{
+	unsigned long (*get_area)(struct file *, unsigned long, unsigned long,
+				  unsigned long, unsigned long);
+
+	get_area = current->mm->get_unmapped_area;
+	if (file && file->f_op && file->f_op->get_unmapped_area)
+		get_area = file->f_op->get_unmapped_area;
+
+	if (!get_area)
+		return -ENOSYS;
+
+	return get_area(file, addr, len, pgoff, flags);
+}
+
+EXPORT_SYMBOL(get_unmapped_area);
+
+/*
  * Check that a process has enough memory to allocate a new virtual
  * mapping. 0 means there is enough memory for the allocation to
  * succeed and -ENOMEM implies there is not.
diff -purN linux-2.6.21-rc4-git5/net/bluetooth/hidp/core.c linux-2.6.21-rc4-git7/net/bluetooth/hidp/core.c
--- linux-2.6.21-rc4-git5/net/bluetooth/hidp/core.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/bluetooth/hidp/core.c	2007-03-23 08:42:08.657055918 +0100
@@ -319,7 +319,7 @@ static int __hidp_send_ctrl_message(stru
 	return 0;
 }
 
-static int inline hidp_send_ctrl_message(struct hidp_session *session,
+static inline int hidp_send_ctrl_message(struct hidp_session *session,
 			unsigned char hdr, unsigned char *data, int size)
 {
 	int err;
diff -purN linux-2.6.21-rc4-git5/net/bridge/br_fdb.c linux-2.6.21-rc4-git7/net/bridge/br_fdb.c
--- linux-2.6.21-rc4-git5/net/bridge/br_fdb.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/bridge/br_fdb.c	2007-03-23 08:42:08.657055918 +0100
@@ -197,8 +197,8 @@ struct net_bridge_fdb_entry *br_fdb_get(
 
 	rcu_read_lock();
 	fdb = __br_fdb_get(br, addr);
-	if (fdb)
-		atomic_inc(&fdb->use_count);
+	if (fdb && !atomic_inc_not_zero(&fdb->use_count))
+		fdb = NULL;
 	rcu_read_unlock();
 	return fdb;
 }
diff -purN linux-2.6.21-rc4-git5/net/bridge/br_netfilter.c linux-2.6.21-rc4-git7/net/bridge/br_netfilter.c
--- linux-2.6.21-rc4-git5/net/bridge/br_netfilter.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/bridge/br_netfilter.c	2007-03-23 08:42:08.657055918 +0100
@@ -61,7 +61,7 @@ static int brnf_filter_vlan_tagged __rea
 #define brnf_filter_vlan_tagged 1
 #endif
 
-static __be16 inline vlan_proto(const struct sk_buff *skb)
+static inline __be16 vlan_proto(const struct sk_buff *skb)
 {
 	return vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
 }
diff -purN linux-2.6.21-rc4-git5/net/core/fib_rules.c linux-2.6.21-rc4-git7/net/core/fib_rules.c
--- linux-2.6.21-rc4-git5/net/core/fib_rules.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/core/fib_rules.c	2007-03-23 08:42:08.657055918 +0100
@@ -374,7 +374,7 @@ int fib_rules_dump(struct sk_buff *skb, 
 		return -EAFNOSUPPORT;
 
 	rcu_read_lock();
-	list_for_each_entry(rule, ops->rules_list, list) {
+	list_for_each_entry_rcu(rule, ops->rules_list, list) {
 		if (idx < cb->args[0])
 			goto skip;
 
diff -purN linux-2.6.21-rc4-git5/net/core/sock.c linux-2.6.21-rc4-git7/net/core/sock.c
--- linux-2.6.21-rc4-git5/net/core/sock.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/core/sock.c	2007-03-23 08:42:08.667055866 +0100
@@ -808,7 +808,7 @@ lenout:
  *
  * (We also register the sk_lock with the lock validator.)
  */
-static void inline sock_lock_init(struct sock *sk)
+static inline void sock_lock_init(struct sock *sk)
 {
 	sock_lock_init_class_and_name(sk,
 			af_family_slock_key_strings[sk->sk_family],
diff -purN linux-2.6.21-rc4-git5/net/ipv4/netfilter/ip_nat_standalone.c linux-2.6.21-rc4-git7/net/ipv4/netfilter/ip_nat_standalone.c
--- linux-2.6.21-rc4-git5/net/ipv4/netfilter/ip_nat_standalone.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/ipv4/netfilter/ip_nat_standalone.c	2007-03-23 08:42:08.667055866 +0100
@@ -253,14 +253,17 @@ ip_nat_local_fn(unsigned int hooknum,
 		enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
 
 		if (ct->tuplehash[dir].tuple.dst.ip !=
-		    ct->tuplehash[!dir].tuple.src.ip
-#ifdef CONFIG_XFRM
-		    || ct->tuplehash[dir].tuple.dst.u.all !=
-		       ct->tuplehash[!dir].tuple.src.u.all
-#endif
-		    )
+		    ct->tuplehash[!dir].tuple.src.ip) {
 			if (ip_route_me_harder(pskb, RTN_UNSPEC))
 				ret = NF_DROP;
+		}
+#ifdef CONFIG_XFRM
+		else if (ct->tuplehash[dir].tuple.dst.u.all !=
+			 ct->tuplehash[!dir].tuple.src.u.all)
+			if (ip_xfrm_me_harder(pskb))
+				ret = NF_DROP;
+#endif
+
 	}
 	return ret;
 }
diff -purN linux-2.6.21-rc4-git5/net/ipv4/netfilter/nf_nat_standalone.c linux-2.6.21-rc4-git7/net/ipv4/netfilter/nf_nat_standalone.c
--- linux-2.6.21-rc4-git5/net/ipv4/netfilter/nf_nat_standalone.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/ipv4/netfilter/nf_nat_standalone.c	2007-03-23 08:42:08.667055866 +0100
@@ -245,14 +245,16 @@ nf_nat_local_fn(unsigned int hooknum,
 		enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
 
 		if (ct->tuplehash[dir].tuple.dst.u3.ip !=
-		    ct->tuplehash[!dir].tuple.src.u3.ip
-#ifdef CONFIG_XFRM
-		    || ct->tuplehash[dir].tuple.dst.u.all !=
-		       ct->tuplehash[!dir].tuple.src.u.all
-#endif
-		    )
+		    ct->tuplehash[!dir].tuple.src.u3.ip) {
 			if (ip_route_me_harder(pskb, RTN_UNSPEC))
 				ret = NF_DROP;
+		}
+#ifdef CONFIG_XFRM
+		else if (ct->tuplehash[dir].tuple.dst.u.all !=
+			 ct->tuplehash[!dir].tuple.src.u.all)
+			if (ip_xfrm_me_harder(pskb))
+				ret = NF_DROP;
+#endif
 	}
 	return ret;
 }
diff -purN linux-2.6.21-rc4-git5/net/ipv6/addrconf.c linux-2.6.21-rc4-git7/net/ipv6/addrconf.c
--- linux-2.6.21-rc4-git5/net/ipv6/addrconf.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/ipv6/addrconf.c	2007-03-23 08:42:08.677055813 +0100
@@ -804,7 +804,7 @@ struct ipv6_saddr_score {
 #define IPV6_SADDR_SCORE_LABEL		0x0020
 #define IPV6_SADDR_SCORE_PRIVACY	0x0040
 
-static int inline ipv6_saddr_preferred(int type)
+static inline int ipv6_saddr_preferred(int type)
 {
 	if (type & (IPV6_ADDR_MAPPED|IPV6_ADDR_COMPATv4|
 		    IPV6_ADDR_LOOPBACK|IPV6_ADDR_RESERVED))
@@ -813,7 +813,7 @@ static int inline ipv6_saddr_preferred(i
 }
 
 /* static matching label */
-static int inline ipv6_saddr_label(const struct in6_addr *addr, int type)
+static inline int ipv6_saddr_label(const struct in6_addr *addr, int type)
 {
  /*
   * 	prefix (longest match)	label
@@ -3318,7 +3318,7 @@ errout:
 		rtnl_set_sk_err(RTNLGRP_IPV6_IFADDR, err);
 }
 
-static void inline ipv6_store_devconf(struct ipv6_devconf *cnf,
+static inline void ipv6_store_devconf(struct ipv6_devconf *cnf,
 				__s32 *array, int bytes)
 {
 	BUG_ON(bytes < (DEVCONF_MAX * 4));
diff -purN linux-2.6.21-rc4-git5/net/ipv6/route.c linux-2.6.21-rc4-git7/net/ipv6/route.c
--- linux-2.6.21-rc4-git5/net/ipv6/route.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/ipv6/route.c	2007-03-23 08:42:08.687055761 +0100
@@ -308,7 +308,7 @@ static inline void rt6_probe(struct rt6_
 /*
  * Default Router Selection (RFC 2461 6.3.6)
  */
-static int inline rt6_check_dev(struct rt6_info *rt, int oif)
+static inline int rt6_check_dev(struct rt6_info *rt, int oif)
 {
 	struct net_device *dev = rt->rt6i_dev;
 	int ret = 0;
@@ -328,7 +328,7 @@ static int inline rt6_check_dev(struct r
 	return ret;
 }
 
-static int inline rt6_check_neigh(struct rt6_info *rt)
+static inline int rt6_check_neigh(struct rt6_info *rt)
 {
 	struct neighbour *neigh = rt->rt6i_nexthop;
 	int m = 0;
diff -purN linux-2.6.21-rc4-git5/net/ipv6/xfrm6_tunnel.c linux-2.6.21-rc4-git7/net/ipv6/xfrm6_tunnel.c
--- linux-2.6.21-rc4-git5/net/ipv6/xfrm6_tunnel.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/ipv6/xfrm6_tunnel.c	2007-03-23 08:42:08.687055761 +0100
@@ -58,7 +58,7 @@ static struct kmem_cache *xfrm6_tunnel_s
 static struct hlist_head xfrm6_tunnel_spi_byaddr[XFRM6_TUNNEL_SPI_BYADDR_HSIZE];
 static struct hlist_head xfrm6_tunnel_spi_byspi[XFRM6_TUNNEL_SPI_BYSPI_HSIZE];
 
-static unsigned inline xfrm6_tunnel_spi_hash_byaddr(xfrm_address_t *addr)
+static inline unsigned xfrm6_tunnel_spi_hash_byaddr(xfrm_address_t *addr)
 {
 	unsigned h;
 
@@ -70,7 +70,7 @@ static unsigned inline xfrm6_tunnel_spi_
 	return h;
 }
 
-static unsigned inline xfrm6_tunnel_spi_hash_byspi(u32 spi)
+static inline unsigned xfrm6_tunnel_spi_hash_byspi(u32 spi)
 {
 	return spi % XFRM6_TUNNEL_SPI_BYSPI_HSIZE;
 }
diff -purN linux-2.6.21-rc4-git5/net/irda/irnet/irnet.h linux-2.6.21-rc4-git7/net/irda/irnet/irnet.h
--- linux-2.6.21-rc4-git5/net/irda/irnet/irnet.h	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/irda/irnet/irnet.h	2007-03-23 08:42:08.687055761 +0100
@@ -419,7 +419,7 @@ typedef struct irnet_socket
   u32			raccm;		/* to please pppd - dummy) */
   unsigned int		flags;		/* PPP flags (compression, ...) */
   unsigned int		rbits;		/* Unused receive flags ??? */
-
+  struct work_struct disconnect_work;   /* Process context disconnection */
   /* ------------------------ IrTTP part ------------------------ */
   /* We create a pseudo "socket" over the IrDA tranport */
   unsigned long		ttp_open;	/* Set when IrTTP is ready */
diff -purN linux-2.6.21-rc4-git5/net/irda/irnet/irnet_irda.c linux-2.6.21-rc4-git7/net/irda/irnet/irnet_irda.c
--- linux-2.6.21-rc4-git5/net/irda/irnet/irnet_irda.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/irda/irnet/irnet_irda.c	2007-03-23 08:42:08.697055708 +0100
@@ -10,6 +10,27 @@
 
 #include "irnet_irda.h"		/* Private header */
 
+/*
+ * PPP disconnect work: we need to make sure we're in
+ * process context when calling ppp_unregister_channel().
+ */
+static void irnet_ppp_disconnect(struct work_struct *work)
+{
+	irnet_socket * self =
+		container_of(work, irnet_socket, disconnect_work);
+
+	if (self == NULL)
+		return;
+	/*
+	 * If we were connected, cleanup & close the PPP
+	 * channel, which will kill pppd (hangup) and the rest.
+	 */
+	if (self->ppp_open && !self->ttp_open && !self->ttp_connect) {
+		ppp_unregister_channel(&self->chan);
+		self->ppp_open = 0;
+	}
+}
+
 /************************* CONTROL CHANNEL *************************/
 /*
  * When ppp is not active, /dev/irnet act as a control channel.
@@ -499,6 +520,8 @@ irda_irnet_create(irnet_socket *	self)
 #endif /* DISCOVERY_NOMASK */
   self->tx_flow = FLOW_START;	/* Flow control from IrTTP */
 
+  INIT_WORK(&self->disconnect_work, irnet_ppp_disconnect);
+
   DEXIT(IRDA_SOCK_TRACE, "\n");
   return(0);
 }
@@ -1134,15 +1157,8 @@ irnet_disconnect_indication(void *	insta
     {
       if(test_open)
 	{
-#ifdef MISSING_PPP_API
-	  /* ppp_unregister_channel() wants a user context, which we
-	   * are guaranteed to NOT have here. What are we supposed
-	   * to do here ? Jean II */
-	  /* If we were connected, cleanup & close the PPP channel,
-	   * which will kill pppd (hangup) and the rest */
-	  ppp_unregister_channel(&self->chan);
-	  self->ppp_open = 0;
-#endif
+	  /* ppp_unregister_channel() wants a user context. */
+	  schedule_work(&self->disconnect_work);
 	}
       else
 	{
diff -purN linux-2.6.21-rc4-git5/net/irda/irttp.c linux-2.6.21-rc4-git7/net/irda/irttp.c
--- linux-2.6.21-rc4-git5/net/irda/irttp.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/irda/irttp.c	2007-03-23 08:42:08.697055708 +0100
@@ -1455,6 +1455,7 @@ struct tsap_cb *irttp_dup(struct tsap_cb
 
 	/* Not everything should be copied */
 	new->notify.instance = instance;
+	spin_lock_init(&new->lock);
 	init_timer(&new->todo_timer);
 
 	skb_queue_head_init(&new->rx_queue);
diff -purN linux-2.6.21-rc4-git5/net/netfilter/Kconfig linux-2.6.21-rc4-git7/net/netfilter/Kconfig
--- linux-2.6.21-rc4-git5/net/netfilter/Kconfig	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/netfilter/Kconfig	2007-03-23 08:42:08.697055708 +0100
@@ -275,6 +275,7 @@ config NF_CT_NETLINK
 	tristate 'Connection tracking netlink interface (EXPERIMENTAL)'
 	depends on EXPERIMENTAL && NF_CONNTRACK && NETFILTER_NETLINK
 	depends on NF_CONNTRACK!=y || NETFILTER_NETLINK!=m
+	depends on NF_NAT=n || NF_NAT
 	help
 	  This option enables support for a netlink-based userspace interface
 
diff -purN linux-2.6.21-rc4-git5/net/sched/cls_route.c linux-2.6.21-rc4-git7/net/sched/cls_route.c
--- linux-2.6.21-rc4-git5/net/sched/cls_route.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/sched/cls_route.c	2007-03-23 08:42:08.697055708 +0100
@@ -93,7 +93,7 @@ void route4_reset_fastmap(struct net_dev
 	spin_unlock_bh(&dev->queue_lock);
 }
 
-static void __inline__
+static inline void
 route4_set_fastmap(struct route4_head *head, u32 id, int iif,
 		   struct route4_filter *f)
 {
diff -purN linux-2.6.21-rc4-git5/net/sctp/associola.c linux-2.6.21-rc4-git7/net/sctp/associola.c
--- linux-2.6.21-rc4-git5/net/sctp/associola.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/sctp/associola.c	2007-03-23 08:42:08.697055708 +0100
@@ -1046,6 +1046,9 @@ void sctp_assoc_update(struct sctp_assoc
 		trans = list_entry(pos, struct sctp_transport, transports);
 		if (!sctp_assoc_lookup_paddr(new, &trans->ipaddr))
 			sctp_assoc_del_peer(asoc, &trans->ipaddr);
+
+		if (asoc->state >= SCTP_STATE_ESTABLISHED)
+			sctp_transport_reset(trans);
 	}
 
 	/* If the case is A (association restart), use
@@ -1063,6 +1066,18 @@ void sctp_assoc_update(struct sctp_assoc
 		 */
 		sctp_ssnmap_clear(asoc->ssnmap);
 
+		/* Flush the ULP reassembly and ordered queue.
+		 * Any data there will now be stale and will
+		 * cause problems.
+		 */
+		sctp_ulpq_flush(&asoc->ulpq);
+
+		/* reset the overall association error count so
+		 * that the restarted association doesn't get torn
+		 * down on the next retransmission timer.
+		 */
+		asoc->overall_error_count = 0;
+
 	} else {
 		/* Add any peer addresses from the new association. */
 		list_for_each(pos, &new->peer.transport_addr_list) {
diff -purN linux-2.6.21-rc4-git5/net/sctp/sm_statefuns.c linux-2.6.21-rc4-git7/net/sctp/sm_statefuns.c
--- linux-2.6.21-rc4-git5/net/sctp/sm_statefuns.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/sctp/sm_statefuns.c	2007-03-23 08:42:08.707055656 +0100
@@ -4342,8 +4342,24 @@ sctp_disposition_t sctp_sf_do_prm_reques
 					void *arg,
 					sctp_cmd_seq_t *commands)
 {
-	return sctp_sf_heartbeat(ep, asoc, type, (struct sctp_transport *)arg,
-				 commands);
+	if (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,
+				      (struct sctp_transport *)arg, commands))
+		return SCTP_DISPOSITION_NOMEM;
+
+	/*
+	 * RFC 2960 (bis), section 8.3
+	 *
+	 *    D) Request an on-demand HEARTBEAT on a specific destination
+	 *    transport address of a given association.
+	 *
+	 *    The endpoint should increment the respective error  counter of
+	 *    the destination transport address each time a HEARTBEAT is sent
+	 *    to that address and not acknowledged within one RTO.
+	 *
+	 */
+	sctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_RESET,
+			SCTP_TRANSPORT(arg));
+	return SCTP_DISPOSITION_CONSUME;
 }
 
 /*
diff -purN linux-2.6.21-rc4-git5/net/sctp/transport.c linux-2.6.21-rc4-git7/net/sctp/transport.c
--- linux-2.6.21-rc4-git5/net/sctp/transport.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/sctp/transport.c	2007-03-23 08:42:08.717055603 +0100
@@ -526,3 +526,35 @@ unsigned long sctp_transport_timeout(str
 	timeout += jiffies;
 	return timeout;
 }
+
+/* Reset transport variables to their initial values */
+void sctp_transport_reset(struct sctp_transport *t)
+{
+	struct sctp_association *asoc = t->asoc;
+
+	/* RFC 2960 (bis), Section 5.2.4
+	 * All the congestion control parameters (e.g., cwnd, ssthresh)
+	 * related to this peer MUST be reset to their initial values
+	 * (see Section 6.2.1)
+	 */
+	t->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));
+	t->ssthresh = asoc->peer.i.a_rwnd;
+	t->rto = asoc->rto_initial;
+	t->rtt = 0;
+	t->srtt = 0;
+	t->rttvar = 0;
+
+	/* Reset these additional varibles so that we have a clean
+	 * slate.
+	 */
+	t->partial_bytes_acked = 0;
+	t->flight_size = 0;
+	t->error_count = 0;
+	t->rto_pending = 0;
+
+	/* Initialize the state information for SFR-CACC */
+	t->cacc.changeover_active = 0;
+	t->cacc.cycling_changeover = 0;
+	t->cacc.next_tsn_at_change = 0;
+	t->cacc.cacc_saw_newack = 0;
+}
diff -purN linux-2.6.21-rc4-git5/net/sctp/ulpqueue.c linux-2.6.21-rc4-git7/net/sctp/ulpqueue.c
--- linux-2.6.21-rc4-git5/net/sctp/ulpqueue.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/sctp/ulpqueue.c	2007-03-23 08:42:08.717055603 +0100
@@ -73,7 +73,7 @@ struct sctp_ulpq *sctp_ulpq_init(struct 
 
 
 /* Flush the reassembly and ordering queues.  */
-static void sctp_ulpq_flush(struct sctp_ulpq *ulpq)
+void sctp_ulpq_flush(struct sctp_ulpq *ulpq)
 {
 	struct sk_buff *skb;
 	struct sctp_ulpevent *event;
diff -purN linux-2.6.21-rc4-git5/net/x25/x25_forward.c linux-2.6.21-rc4-git7/net/x25/x25_forward.c
--- linux-2.6.21-rc4-git5/net/x25/x25_forward.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/x25/x25_forward.c	2007-03-23 08:42:08.717055603 +0100
@@ -26,64 +26,66 @@ int x25_forward_call(struct x25_address 
 	short same_lci = 0;
 	int rc = 0;
 
-	if ((rt = x25_get_route(dest_addr)) != NULL) {
+	if ((rt = x25_get_route(dest_addr)) == NULL)
+		goto out_no_route;
 
-		if ((neigh_new = x25_get_neigh(rt->dev)) == NULL) {
-			/* This shouldnt happen, if it occurs somehow
-			 * do something sensible
-			 */
-			goto out_put_route;
-		}
-
-		/* Avoid a loop. This is the normal exit path for a
-		 * system with only one x.25 iface and default route
+	if ((neigh_new = x25_get_neigh(rt->dev)) == NULL) {
+		/* This shouldnt happen, if it occurs somehow
+		 * do something sensible
 		 */
-		if (rt->dev == from->dev) {
-			goto out_put_nb;
-		}
+		goto out_put_route;
+	}
 
-		/* Remote end sending a call request on an already
-		 * established LCI? It shouldnt happen, just in case..
-		 */
-		read_lock_bh(&x25_forward_list_lock);
-		list_for_each(entry, &x25_forward_list) {
-			x25_frwd = list_entry(entry, struct x25_forward, node);
-			if (x25_frwd->lci == lci) {
-				printk(KERN_WARNING "X.25: call request for lci which is already registered!, transmitting but not registering new pair\n");
-				same_lci = 1;
-			}
-		}
-		read_unlock_bh(&x25_forward_list_lock);
+	/* Avoid a loop. This is the normal exit path for a
+	 * system with only one x.25 iface and default route
+	 */
+	if (rt->dev == from->dev) {
+		goto out_put_nb;
+	}
 
-		/* Save the forwarding details for future traffic */
-		if (!same_lci){
-			if ((new_frwd = kmalloc(sizeof(struct x25_forward),
-							GFP_ATOMIC)) == NULL){
-				rc = -ENOMEM;
-				goto out_put_nb;
-			}
-			new_frwd->lci = lci;
-			new_frwd->dev1 = rt->dev;
-			new_frwd->dev2 = from->dev;
-			write_lock_bh(&x25_forward_list_lock);
-			list_add(&new_frwd->node, &x25_forward_list);
-			write_unlock_bh(&x25_forward_list_lock);
+	/* Remote end sending a call request on an already
+	 * established LCI? It shouldnt happen, just in case..
+	 */
+	read_lock_bh(&x25_forward_list_lock);
+	list_for_each(entry, &x25_forward_list) {
+		x25_frwd = list_entry(entry, struct x25_forward, node);
+		if (x25_frwd->lci == lci) {
+			printk(KERN_WARNING "X.25: call request for lci which is already registered!, transmitting but not registering new pair\n");
+			same_lci = 1;
 		}
+	}
+	read_unlock_bh(&x25_forward_list_lock);
 
-		/* Forward the call request */
-		if ( (skbn = skb_clone(skb, GFP_ATOMIC)) == NULL){
+	/* Save the forwarding details for future traffic */
+	if (!same_lci){
+		if ((new_frwd = kmalloc(sizeof(struct x25_forward),
+						GFP_ATOMIC)) == NULL){
+			rc = -ENOMEM;
 			goto out_put_nb;
 		}
-		x25_transmit_link(skbn, neigh_new);
-		rc = 1;
+		new_frwd->lci = lci;
+		new_frwd->dev1 = rt->dev;
+		new_frwd->dev2 = from->dev;
+		write_lock_bh(&x25_forward_list_lock);
+		list_add(&new_frwd->node, &x25_forward_list);
+		write_unlock_bh(&x25_forward_list_lock);
 	}
 
+	/* Forward the call request */
+	if ( (skbn = skb_clone(skb, GFP_ATOMIC)) == NULL){
+		goto out_put_nb;
+	}
+	x25_transmit_link(skbn, neigh_new);
+	rc = 1;
+
 
 out_put_nb:
 	x25_neigh_put(neigh_new);
 
 out_put_route:
 	x25_route_put(rt);
+
+out_no_route:
 	return rc;
 }
 
diff -purN linux-2.6.21-rc4-git5/net/xfrm/xfrm_policy.c linux-2.6.21-rc4-git7/net/xfrm/xfrm_policy.c
--- linux-2.6.21-rc4-git5/net/xfrm/xfrm_policy.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/xfrm/xfrm_policy.c	2007-03-23 08:42:08.717055603 +0100
@@ -2089,7 +2089,7 @@ void xfrm_audit_log(uid_t auid, u32 sid,
 					sizeof(struct in6_addr));
 			}
 			audit_log_format(audit_buf,
-					 " src=" NIP6_FMT "dst=" NIP6_FMT,
+					 " src=" NIP6_FMT " dst=" NIP6_FMT,
 					 NIP6(saddr6), NIP6(daddr6));
 		}
 		break;
diff -purN linux-2.6.21-rc4-git5/net/xfrm/xfrm_user.c linux-2.6.21-rc4-git7/net/xfrm/xfrm_user.c
--- linux-2.6.21-rc4-git5/net/xfrm/xfrm_user.c	2007-03-16 01:20:01.000000000 +0100
+++ linux-2.6.21-rc4-git7/net/xfrm/xfrm_user.c	2007-03-23 08:42:08.727055550 +0100
@@ -2025,7 +2025,7 @@ nlmsg_failure:
 	return -1;
 }
 
-static int inline xfrm_sa_len(struct xfrm_state *x)
+static inline int xfrm_sa_len(struct xfrm_state *x)
 {
 	int l = 0;
 	if (x->aalg)
