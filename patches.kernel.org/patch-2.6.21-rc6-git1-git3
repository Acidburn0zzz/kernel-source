 Makefile                          |    2 -
 arch/i386/kernel/io_apic.c        |    2 -
 arch/i386/kernel/vmi.c            |   23 ++++++++++++++++++++-
 arch/i386/mm/highmem.c            |    2 +
 arch/x86_64/kernel/early-quirks.c |    2 -
 drivers/char/agp/intel-agp.c      |   14 +++++++++++-
 drivers/pcmcia/omap_cf.c          |   41 +++++++++++++++++++++++---------------
 fs/fuse/dir.c                     |    5 ++--
 fs/fuse/fuse_i.h                  |    5 ++++
 fs/fuse/inode.c                   |    2 +
 include/asm-generic/pgtable.h     |    2 +
 include/asm-i386/paravirt.h       |    3 ++
 12 files changed, 79 insertions(+), 24 deletions(-)
diff -purN linux-2.6.21-rc6-git1/Makefile linux-2.6.21-rc6-git3/Makefile
--- linux-2.6.21-rc6-git1/Makefile	2007-04-10 19:30:23.519305902 +0200
+++ linux-2.6.21-rc6-git3/Makefile	2007-04-10 19:30:32.169321780 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 21
-EXTRAVERSION = -rc6-git1
+EXTRAVERSION = -rc6-git3
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff -purN linux-2.6.21-rc6-git1/arch/i386/kernel/io_apic.c linux-2.6.21-rc6-git3/arch/i386/kernel/io_apic.c
--- linux-2.6.21-rc6-git1/arch/i386/kernel/io_apic.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/arch/i386/kernel/io_apic.c	2007-04-10 19:30:32.169321780 +0200
@@ -736,7 +736,7 @@ failed:
 	return 0;
 }
 
-int __init irqbalance_disable(char *str)
+int __devinit irqbalance_disable(char *str)
 {
 	irqbalance_disabled = 1;
 	return 1;
diff -purN linux-2.6.21-rc6-git1/arch/i386/kernel/vmi.c linux-2.6.21-rc6-git3/arch/i386/kernel/vmi.c
--- linux-2.6.21-rc6-git1/arch/i386/kernel/vmi.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/arch/i386/kernel/vmi.c	2007-04-10 19:30:32.169321780 +0200
@@ -69,6 +69,7 @@ struct {
 	void (*flush_tlb)(int);
 	void (*set_initial_ap_state)(int, int);
 	void (*halt)(void);
+  	void (*set_lazy_mode)(int mode);
 } vmi_ops;
 
 /* XXX move this to alternative.h */
@@ -574,6 +575,26 @@ vmi_startup_ipi_hook(int phys_apicid, un
 }
 #endif
 
+static void vmi_set_lazy_mode(int mode)
+{
+	static DEFINE_PER_CPU(int, lazy_mode);
+
+	if (!vmi_ops.set_lazy_mode)
+		return;
+
+	/* Modes should never nest or overlap */
+	BUG_ON(__get_cpu_var(lazy_mode) && !(mode == PARAVIRT_LAZY_NONE ||
+					     mode == PARAVIRT_LAZY_FLUSH));
+
+	if (mode == PARAVIRT_LAZY_FLUSH) {
+		vmi_ops.set_lazy_mode(0);
+		vmi_ops.set_lazy_mode(__get_cpu_var(lazy_mode));
+	} else {
+		vmi_ops.set_lazy_mode(mode);
+		__get_cpu_var(lazy_mode) = mode;
+	}
+}
+
 static inline int __init check_vmi_rom(struct vrom_header *rom)
 {
 	struct pci_header *pci;
@@ -804,7 +825,7 @@ static inline int __init activate_vmi(vo
 	para_wrap(load_esp0, vmi_load_esp0, set_kernel_stack, UpdateKernelStack);
 	para_fill(set_iopl_mask, SetIOPLMask);
 	para_fill(io_delay, IODelay);
-	para_fill(set_lazy_mode, SetLazyMode);
+	para_wrap(set_lazy_mode, vmi_set_lazy_mode, set_lazy_mode, SetLazyMode);
 
 	/* user and kernel flush are just handled with different flags to FlushTLB */
 	para_wrap(flush_tlb_user, vmi_flush_tlb_user, flush_tlb, FlushTLB);
diff -purN linux-2.6.21-rc6-git1/arch/i386/mm/highmem.c linux-2.6.21-rc6-git3/arch/i386/mm/highmem.c
--- linux-2.6.21-rc6-git1/arch/i386/mm/highmem.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/arch/i386/mm/highmem.c	2007-04-10 19:30:32.169321780 +0200
@@ -42,6 +42,7 @@ void *kmap_atomic(struct page *page, enu
 
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
 	set_pte(kmap_pte-idx, mk_pte(page, kmap_prot));
+	arch_flush_lazy_mmu_mode();
 
 	return (void*) vaddr;
 }
@@ -82,6 +83,7 @@ void *kmap_atomic_pfn(unsigned long pfn,
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
 	set_pte(kmap_pte-idx, pfn_pte(pfn, kmap_prot));
+	arch_flush_lazy_mmu_mode();
 
 	return (void*) vaddr;
 }
diff -purN linux-2.6.21-rc6-git1/arch/x86_64/kernel/early-quirks.c linux-2.6.21-rc6-git3/arch/x86_64/kernel/early-quirks.c
--- linux-2.6.21-rc6-git1/arch/x86_64/kernel/early-quirks.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/arch/x86_64/kernel/early-quirks.c	2007-04-10 19:30:32.169321780 +0200
@@ -88,7 +88,7 @@ struct chipset {
 	void (*f)(void);
 };
 
-static struct __initdata chipset early_qrk[] = {
+static struct chipset early_qrk[] __initdata = {
 	{ PCI_VENDOR_ID_NVIDIA, nvidia_bugs },
 	{ PCI_VENDOR_ID_VIA, via_bugs },
 	{ PCI_VENDOR_ID_ATI, ati_bugs },
diff -purN linux-2.6.21-rc6-git1/drivers/char/agp/intel-agp.c linux-2.6.21-rc6-git3/drivers/char/agp/intel-agp.c
--- linux-2.6.21-rc6-git1/drivers/char/agp/intel-agp.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/drivers/char/agp/intel-agp.c	2007-04-10 19:30:32.179321799 +0200
@@ -18,11 +18,14 @@
 #define PCI_DEVICE_ID_INTEL_82965Q_IG       0x2992
 #define PCI_DEVICE_ID_INTEL_82965G_HB       0x29A0
 #define PCI_DEVICE_ID_INTEL_82965G_IG       0x29A2
+#define PCI_DEVICE_ID_INTEL_82965GM_HB      0x2A00
+#define PCI_DEVICE_ID_INTEL_82965GM_IG      0x2A02
 
 #define IS_I965 (agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82946GZ_HB || \
                  agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965G_1_HB || \
                  agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965Q_HB || \
-                 agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965G_HB)
+                 agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965G_HB || \
+                 agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965GM_HB)
 
 
 extern int agp_memory_reserved;
@@ -1921,7 +1924,13 @@ static int __devinit agp_intel_probe(str
 			bridge->driver = &intel_845_driver;
 		name = "965G";
 		break;
-
+	case PCI_DEVICE_ID_INTEL_82965GM_HB:
+		if (find_i830(PCI_DEVICE_ID_INTEL_82965GM_IG))
+			bridge->driver = &intel_i965_driver;
+		else
+			bridge->driver = &intel_845_driver;
+		name = "965GM";
+		break;
 	case PCI_DEVICE_ID_INTEL_7505_0:
 		bridge->driver = &intel_7505_driver;
 		name = "E7505";
@@ -2080,6 +2089,7 @@ static struct pci_device_id agp_intel_pc
 	ID(PCI_DEVICE_ID_INTEL_82965G_1_HB),
 	ID(PCI_DEVICE_ID_INTEL_82965Q_HB),
 	ID(PCI_DEVICE_ID_INTEL_82965G_HB),
+	ID(PCI_DEVICE_ID_INTEL_82965GM_HB),
 	{ }
 };
 
diff -purN linux-2.6.21-rc6-git1/drivers/pcmcia/omap_cf.c linux-2.6.21-rc6-git3/drivers/pcmcia/omap_cf.c
--- linux-2.6.21-rc6-git1/drivers/pcmcia/omap_cf.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/drivers/pcmcia/omap_cf.c	2007-04-10 19:30:32.179321799 +0200
@@ -202,15 +202,14 @@ static struct pccard_operations omap_cf_
  * "what chipselect is used".  Boards could want more.
  */
 
-static int __devinit omap_cf_probe(struct device *dev)
+static int __init omap_cf_probe(struct platform_device *pdev)
 {
 	unsigned		seg;
 	struct omap_cf_socket	*cf;
-	struct platform_device	*pdev = to_platform_device(dev);
 	int			irq;
 	int			status;
 
-	seg = (int) dev->platform_data;
+	seg = (int) pdev->dev.platform_data;
 	if (seg == 0 || seg > 3)
 		return -ENODEV;
 
@@ -227,7 +226,7 @@ static int __devinit omap_cf_probe(struc
 	cf->timer.data = (unsigned long) cf;
 
 	cf->pdev = pdev;
-	dev_set_drvdata(dev, cf);
+	platform_set_drvdata(pdev, cf);
 
 	/* this primarily just shuts up irq handling noise */
 	status = request_irq(irq, omap_cf_irq, IRQF_SHARED,
@@ -291,7 +290,7 @@ static int __devinit omap_cf_probe(struc
 		omap_cf_present() ? "present" : "(not present)");
 
 	cf->socket.owner = THIS_MODULE;
-	cf->socket.dev.parent = dev;
+	cf->socket.dev.parent = &pdev->dev;
 	cf->socket.ops = &omap_cf_ops;
 	cf->socket.resource_ops = &pccard_static_ops;
 	cf->socket.features = SS_CAP_PCCARD | SS_CAP_STATIC_MAP
@@ -318,9 +317,9 @@ fail0:
 	return status;
 }
 
-static int __devexit omap_cf_remove(struct device *dev)
+static int __exit omap_cf_remove(struct platform_device *pdev)
 {
-	struct omap_cf_socket *cf = dev_get_drvdata(dev);
+	struct omap_cf_socket *cf = platform_get_drvdata(pdev);
 
 	cf->active = 0;
 	pcmcia_unregister_socket(&cf->socket);
@@ -332,26 +331,36 @@ static int __devexit omap_cf_remove(stru
 	return 0;
 }
 
-static struct device_driver omap_cf_driver = {
-	.name		= (char *) driver_name,
-	.bus		= &platform_bus_type,
-	.probe		= omap_cf_probe,
-	.remove		= __devexit_p(omap_cf_remove),
-	.suspend	= pcmcia_socket_dev_suspend,
-	.resume		= pcmcia_socket_dev_resume,
+static int omap_cf_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return pcmcia_socket_dev_suspend(&pdev->dev, mesg);
+}
+
+static int omap_cf_resume(struct platform_device *pdev)
+{
+	return pcmcia_socket_dev_resume(&pdev->dev);
+}
+
+static struct platform_driver omap_cf_driver = {
+	.driver = {
+		.name	= (char *) driver_name,
+	},
+	.remove		= __exit_p(omap_cf_remove),
+	.suspend	= omap_cf_suspend,
+	.resume		= omap_cf_resume,
 };
 
 static int __init omap_cf_init(void)
 {
 	if (cpu_is_omap16xx())
-		return driver_register(&omap_cf_driver);
+		return platform_driver_probe(&omap_cf_driver, omap_cf_probe);
 	return -ENODEV;
 }
 
 static void __exit omap_cf_exit(void)
 {
 	if (cpu_is_omap16xx())
-		driver_unregister(&omap_cf_driver);
+		platform_driver_unregister(&omap_cf_driver);
 }
 
 module_init(omap_cf_init);
diff -purN linux-2.6.21-rc6-git1/fs/fuse/dir.c linux-2.6.21-rc6-git3/fs/fuse/dir.c
--- linux-2.6.21-rc6-git1/fs/fuse/dir.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/fs/fuse/dir.c	2007-04-10 19:30:32.179321799 +0200
@@ -195,7 +195,7 @@ static struct dentry_operations fuse_den
 	.d_revalidate	= fuse_dentry_revalidate,
 };
 
-static int valid_mode(int m)
+int fuse_valid_type(int m)
 {
 	return S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||
 		S_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);
@@ -248,7 +248,8 @@ static struct dentry *fuse_lookup(struct
 	fuse_put_request(fc, req);
 	/* Zero nodeid is same as -ENOENT, but with valid timeout */
 	if (!err && outarg.nodeid &&
-	    (invalid_nodeid(outarg.nodeid) || !valid_mode(outarg.attr.mode)))
+	    (invalid_nodeid(outarg.nodeid) ||
+	     !fuse_valid_type(outarg.attr.mode)))
 		err = -EIO;
 	if (!err && outarg.nodeid) {
 		inode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,
diff -purN linux-2.6.21-rc6-git1/fs/fuse/fuse_i.h linux-2.6.21-rc6-git3/fs/fuse/fuse_i.h
--- linux-2.6.21-rc6-git1/fs/fuse/fuse_i.h	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/fs/fuse/fuse_i.h	2007-04-10 19:30:32.179321799 +0200
@@ -552,3 +552,8 @@ int fuse_ctl_add_conn(struct fuse_conn *
  * Remove connection from control filesystem
  */
 void fuse_ctl_remove_conn(struct fuse_conn *fc);
+
+/**
+ * Is file type valid?
+ */
+int fuse_valid_type(int m);
diff -purN linux-2.6.21-rc6-git1/fs/fuse/inode.c linux-2.6.21-rc6-git3/fs/fuse/inode.c
--- linux-2.6.21-rc6-git1/fs/fuse/inode.c	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/fs/fuse/inode.c	2007-04-10 19:30:32.179321799 +0200
@@ -330,6 +330,8 @@ static int parse_fuse_opt(char *opt, str
 		case OPT_ROOTMODE:
 			if (match_octal(&args[0], &value))
 				return 0;
+			if (!fuse_valid_type(value))
+				return 0;
 			d->rootmode = value;
 			d->rootmode_present = 1;
 			break;
diff -purN linux-2.6.21-rc6-git1/include/asm-generic/pgtable.h linux-2.6.21-rc6-git3/include/asm-generic/pgtable.h
--- linux-2.6.21-rc6-git1/include/asm-generic/pgtable.h	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/include/asm-generic/pgtable.h	2007-04-10 19:30:32.179321799 +0200
@@ -180,6 +180,7 @@ static inline void ptep_set_wrprotect(st
 #ifndef __HAVE_ARCH_ENTER_LAZY_MMU_MODE
 #define arch_enter_lazy_mmu_mode()	do {} while (0)
 #define arch_leave_lazy_mmu_mode()	do {} while (0)
+#define arch_flush_lazy_mmu_mode()	do {} while (0)
 #endif
 
 /*
@@ -193,6 +194,7 @@ static inline void ptep_set_wrprotect(st
 #ifndef __HAVE_ARCH_ENTER_LAZY_CPU_MODE
 #define arch_enter_lazy_cpu_mode()	do {} while (0)
 #define arch_leave_lazy_cpu_mode()	do {} while (0)
+#define arch_flush_lazy_cpu_mode()	do {} while (0)
 #endif
 
 /*
diff -purN linux-2.6.21-rc6-git1/include/asm-i386/paravirt.h linux-2.6.21-rc6-git3/include/asm-i386/paravirt.h
--- linux-2.6.21-rc6-git1/include/asm-i386/paravirt.h	2007-04-06 04:36:56.000000000 +0200
+++ linux-2.6.21-rc6-git3/include/asm-i386/paravirt.h	2007-04-10 19:30:32.179321799 +0200
@@ -421,14 +421,17 @@ static inline void pmd_clear(pmd_t *pmdp
 #define PARAVIRT_LAZY_NONE 0
 #define PARAVIRT_LAZY_MMU  1
 #define PARAVIRT_LAZY_CPU  2
+#define PARAVIRT_LAZY_FLUSH 3
 
 #define  __HAVE_ARCH_ENTER_LAZY_CPU_MODE
 #define arch_enter_lazy_cpu_mode() paravirt_ops.set_lazy_mode(PARAVIRT_LAZY_CPU)
 #define arch_leave_lazy_cpu_mode() paravirt_ops.set_lazy_mode(PARAVIRT_LAZY_NONE)
+#define arch_flush_lazy_cpu_mode() paravirt_ops.set_lazy_mode(PARAVIRT_LAZY_FLUSH)
 
 #define  __HAVE_ARCH_ENTER_LAZY_MMU_MODE
 #define arch_enter_lazy_mmu_mode() paravirt_ops.set_lazy_mode(PARAVIRT_LAZY_MMU)
 #define arch_leave_lazy_mmu_mode() paravirt_ops.set_lazy_mode(PARAVIRT_LAZY_NONE)
+#define arch_flush_lazy_mmu_mode() paravirt_ops.set_lazy_mode(PARAVIRT_LAZY_FLUSH)
 
 /* These all sit in the .parainstructions section to tell us what to patch. */
 struct paravirt_patch {
