From: Jeff Mahoney <jeffm@suse.com>
Subject: Update to 2.6.21-rc6-git4
Patch-mainline: 2.6.21-rc6-git4

 Update to 2.6.21-rc6-git4:

 - FRV: Update the FRV arch MAINTAINER record to get a hit on
   "grep -i frv"
 - Input: ucb1400 - set up driver's name to show in sysfs
 - ide: add "optical" to sysfs "media" attribute
 - ide: ugly messages trying to open CD drive with no media present
 - ide: correctly prevent IDE timer expiry function to run if request
   was already handled
 - ipt_CLUSTERIP: fix oops in checkentry function
 - IPoIB/cm: Fix DMA direction typo
 - intel_agp: fix G965 GTT size detect
 - tcp: slow_start_after_idle should influence cwnd validation too
 - sc92031: Fix priv->lock context
 - cls_tcindex: fix compatibility breakage
 - ieee1394: change deprecation status of dv1394
 - hid: Do not discard truncated input reports

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---

 Documentation/ABI/obsolete/dv1394          |    9 ++++++
 Documentation/feature-removal-schedule.txt |   11 -------
 MAINTAINERS                                |    2 -
 Makefile                                   |    2 -
 arch/ia64/kernel/msi_ia64.c                |    4 +-
 arch/ia64/kernel/setup.c                   |    2 -
 arch/ia64/sn/kernel/bte_error.c            |    6 ++--
 arch/ia64/sn/pci/pcibr/pcibr_dma.c         |    8 ++++-
 drivers/char/agp/intel-agp.c               |    3 --
 drivers/hid/hid-core.c                     |    2 -
 drivers/ide/ide-cd.c                       |    9 ++++++
 drivers/ide/ide-io.c                       |    6 +++-
 drivers/ide/ide-iops.c                     |    2 +
 drivers/ide/ide.c                          |    2 +
 drivers/ieee1394/Kconfig                   |    6 ++--
 drivers/ieee1394/dv1394.c                  |    4 +-
 drivers/infiniband/ulp/ipoib/ipoib_cm.c    |    2 -
 drivers/infiniband/ulp/iser/iscsi_iser.h   |    1 
 drivers/infiniband/ulp/iser/iser_verbs.c   |   40 +++++++++++------------------
 drivers/input/touchscreen/ucb1400_ts.c     |    1 
 drivers/net/sc92031.c                      |   20 +++++++-------
 include/asm-ia64/sn/pcibr_provider.h       |    5 ++-
 include/linux/ide.h                        |    2 +
 net/ipv4/netfilter/ipt_CLUSTERIP.c         |    2 -
 net/ipv4/tcp_output.c                      |    3 +-
 net/sched/cls_tcindex.c                    |    4 +-
 26 files changed, 85 insertions(+), 73 deletions(-)

diff -ruNp linux-2.6.21-rc6-git3/arch/ia64/kernel/msi_ia64.c linux-2.6.21-rc6-git4/arch/ia64/kernel/msi_ia64.c
--- linux-2.6.21-rc6-git3/arch/ia64/kernel/msi_ia64.c	2007-04-11 09:18:03.000000000 -0400
+++ linux-2.6.21-rc6-git4/arch/ia64/kernel/msi_ia64.c	2007-04-11 09:18:52.000000000 -0400
@@ -76,7 +76,7 @@ int ia64_setup_msi_irq(struct pci_dev *p
 
 	set_irq_msi(irq, desc);
 	dest_phys_id = cpu_physical_id(first_cpu(cpu_online_map));
-	vector = irq;
+	vector = irq_to_vector(irq);
 
 	msg.address_hi = 0;
 	msg.address_lo =
@@ -110,7 +110,7 @@ static void ia64_ack_msi_irq(unsigned in
 
 static int ia64_msi_retrigger_irq(unsigned int irq)
 {
-	unsigned int vector = irq;
+	unsigned int vector = irq_to_vector(irq);
 	ia64_resend_irq(vector);
 
 	return 1;
diff -ruNp linux-2.6.21-rc6-git3/arch/ia64/kernel/setup.c linux-2.6.21-rc6-git4/arch/ia64/kernel/setup.c
--- linux-2.6.21-rc6-git3/arch/ia64/kernel/setup.c	2007-04-11 09:17:41.000000000 -0400
+++ linux-2.6.21-rc6-git4/arch/ia64/kernel/setup.c	2007-04-11 09:18:52.000000000 -0400
@@ -640,7 +640,7 @@ show_cpuinfo (struct seq_file *m, void *
 		   "features   : %s\n"
 		   "cpu number : %lu\n"
 		   "cpu regs   : %u\n"
-		   "cpu MHz    : %lu.%06lu\n"
+		   "cpu MHz    : %lu.%03lu\n"
 		   "itc MHz    : %lu.%06lu\n"
 		   "BogoMIPS   : %lu.%02lu\n",
 		   cpunum, c->vendor, c->family, c->model,
diff -ruNp linux-2.6.21-rc6-git3/arch/ia64/sn/kernel/bte_error.c linux-2.6.21-rc6-git4/arch/ia64/sn/kernel/bte_error.c
--- linux-2.6.21-rc6-git3/arch/ia64/sn/kernel/bte_error.c	2006-04-05 04:45:42.000000000 -0400
+++ linux-2.6.21-rc6-git4/arch/ia64/sn/kernel/bte_error.c	2007-04-11 09:18:52.000000000 -0400
@@ -78,7 +78,7 @@ int shub1_bte_error_handler(unsigned lon
 		 * There are errors which still need to be cleaned up by
 		 * hubiio_crb_error_handler
 		 */
-		mod_timer(recovery_timer, HZ * 5);
+		mod_timer(recovery_timer, jiffies + (HZ * 5));
 		BTE_PRINTK(("eh:%p:%d Marked Giving up\n", err_nodepda,
 			    smp_processor_id()));
 		return 1;
@@ -95,7 +95,7 @@ int shub1_bte_error_handler(unsigned lon
 			icrbd.ii_icrb0_d_regval =
 			    REMOTE_HUB_L(nasid, IIO_ICRB_D(i));
 			if (icrbd.d_bteop) {
-				mod_timer(recovery_timer, HZ * 5);
+				mod_timer(recovery_timer, jiffies + (HZ * 5));
 				BTE_PRINTK(("eh:%p:%d Valid %d, Giving up\n",
 					    err_nodepda, smp_processor_id(),
 					    i));
@@ -150,7 +150,7 @@ int shub2_bte_error_handler(unsigned lon
 		status = BTE_LNSTAT_LOAD(bte);
 		if ((status & IBLS_ERROR) || !(status & IBLS_BUSY))
 			continue;
-		mod_timer(recovery_timer, HZ * 5);
+		mod_timer(recovery_timer, jiffies + (HZ * 5));
 		BTE_PRINTK(("eh:%p:%d Marked Giving up\n", err_nodepda,
 			    smp_processor_id()));
 		return 1;
diff -ruNp linux-2.6.21-rc6-git3/arch/ia64/sn/pci/pcibr/pcibr_dma.c linux-2.6.21-rc6-git4/arch/ia64/sn/pci/pcibr/pcibr_dma.c
--- linux-2.6.21-rc6-git3/arch/ia64/sn/pci/pcibr/pcibr_dma.c	2007-03-09 17:08:44.000000000 -0500
+++ linux-2.6.21-rc6-git4/arch/ia64/sn/pci/pcibr/pcibr_dma.c	2007-04-11 09:18:52.000000000 -0400
@@ -96,10 +96,14 @@ pcibr_dmamap_ate32(struct pcidev_info *i
 	}
 
 	/*
-	 * If we're mapping for MSI, set the MSI bit in the ATE
+	 * If we're mapping for MSI, set the MSI bit in the ATE.  If it's a
+	 * TIOCP based pci bus, we also need to set the PIO bit in the ATE.
 	 */
-	if (dma_flags & SN_DMA_MSI)
+	if (dma_flags & SN_DMA_MSI) {
 		ate |= PCI32_ATE_MSI;
+		if (IS_TIOCP_SOFT(pcibus_info))
+			ate |= PCI32_ATE_PIO;
+	}
 
 	ate_write(pcibus_info, ate_index, ate_count, ate);
 
diff -ruNp linux-2.6.21-rc6-git3/Documentation/ABI/obsolete/dv1394 linux-2.6.21-rc6-git4/Documentation/ABI/obsolete/dv1394
--- linux-2.6.21-rc6-git3/Documentation/ABI/obsolete/dv1394	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.21-rc6-git4/Documentation/ABI/obsolete/dv1394	2007-04-11 09:18:52.000000000 -0400
@@ -0,0 +1,9 @@
+What:		dv1394 (a.k.a. "OHCI-DV I/O support" for FireWire)
+Contact:	linux1394-devel@lists.sourceforge.net
+Description:
+	New application development should use raw1394 + userspace libraries
+	instead, notably libiec61883 which is functionally equivalent.
+
+Users:
+	ffmpeg/libavformat (used by a variety of media players)
+	dvgrab v1.x (replaced by dvgrab2 on top of raw1394 and resp. libraries)
diff -ruNp linux-2.6.21-rc6-git3/Documentation/feature-removal-schedule.txt linux-2.6.21-rc6-git4/Documentation/feature-removal-schedule.txt
--- linux-2.6.21-rc6-git3/Documentation/feature-removal-schedule.txt	2007-04-11 09:15:18.000000000 -0400
+++ linux-2.6.21-rc6-git4/Documentation/feature-removal-schedule.txt	2007-04-11 09:18:52.000000000 -0400
@@ -39,17 +39,6 @@ Who:	Dan Dennedy <dan@dennedy.org>, Stef
 
 ---------------------------
 
-What:	dv1394 driver (CONFIG_IEEE1394_DV1394)
-When:	June 2007
-Why:	Replaced by raw1394 + userspace libraries, notably libiec61883.  This
-	shift of application support has been indicated on www.linux1394.org
-	and developers' mailinglists for quite some time.  Major applications
-	have been converted, with the exception of ffmpeg and hence xine.
-	Piped output of dvgrab2 is a partial equivalent to dv1394.
-Who:	Dan Dennedy <dan@dennedy.org>, Stefan Richter <stefanr@s5r6.in-berlin.de>
-
----------------------------
-
 What:	Video4Linux API 1 ioctls and video_decoder.h from Video devices.
 When:	December 2006
 Why:	V4L1 AP1 was replaced by V4L2 API. during migration from 2.4 to 2.6
diff -ruNp linux-2.6.21-rc6-git3/drivers/char/agp/intel-agp.c linux-2.6.21-rc6-git4/drivers/char/agp/intel-agp.c
--- linux-2.6.21-rc6-git3/drivers/char/agp/intel-agp.c	2007-04-11 09:18:40.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/char/agp/intel-agp.c	2007-04-11 09:18:52.000000000 -0400
@@ -431,9 +431,8 @@ static void intel_i830_init_gtt_entries(
 
 	if (IS_I965) {
 		u32 pgetbl_ctl;
+		pgetbl_ctl = readl(intel_i830_private.registers+I810_PGETBL_CTL);
 
-		pci_read_config_dword(agp_bridge->dev, I810_PGETBL_CTL,
-				      &pgetbl_ctl);
 		/* The 965 has a field telling us the size of the GTT,
 		 * which may be larger than what is necessary to map the
 		 * aperture.
diff -ruNp linux-2.6.21-rc6-git3/drivers/hid/hid-core.c linux-2.6.21-rc6-git4/drivers/hid/hid-core.c
--- linux-2.6.21-rc6-git3/drivers/hid/hid-core.c	2007-04-11 09:15:28.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/hid/hid-core.c	2007-04-11 09:18:52.000000000 -0400
@@ -969,7 +969,7 @@ int hid_input_report(struct hid_device *
 
 	if (size < rsize) {
 		dbg("report %d is too short, (%d < %d)", report->id, size, rsize);
-		return -1;
+		memset(data + size, 0, rsize - size);
 	}
 
 	if ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)
diff -ruNp linux-2.6.21-rc6-git3/drivers/ide/ide.c linux-2.6.21-rc6-git4/drivers/ide/ide.c
--- linux-2.6.21-rc6-git3/drivers/ide/ide.c	2007-04-11 09:18:03.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/ide/ide.c	2007-04-11 09:18:52.000000000 -0400
@@ -1962,6 +1962,8 @@ static char *media_string(ide_drive_t *d
 		return "tape";
 	case ide_floppy:
 		return "floppy";
+	case ide_optical:
+		return "optical";
 	default:
 		return "UNKNOWN";
 	}
diff -ruNp linux-2.6.21-rc6-git3/drivers/ide/ide-cd.c linux-2.6.21-rc6-git4/drivers/ide/ide-cd.c
--- linux-2.6.21-rc6-git3/drivers/ide/ide-cd.c	2007-04-11 09:15:28.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/ide/ide-cd.c	2007-04-11 09:18:52.000000000 -0400
@@ -735,6 +735,15 @@ static int cdrom_decode_status(ide_drive
 			cdrom_saw_media_change (drive);
 			/*printk("%s: media changed\n",drive->name);*/
 			return 0;
+ 		} else if ((sense_key == ILLEGAL_REQUEST) &&
+ 			   (rq->cmd[0] == GPCMD_START_STOP_UNIT)) {
+ 			/*
+ 			 * Don't print error message for this condition--
+ 			 * SFF8090i indicates that 5/24/00 is the correct
+ 			 * response to a request to close the tray if the
+ 			 * drive doesn't have that capability.
+ 			 * cdrom_log_sense() knows this!
+ 			 */
 		} else if (!(rq->cmd_flags & REQ_QUIET)) {
 			/* Otherwise, print an error. */
 			ide_dump_status(drive, "packet command error", stat);
diff -ruNp linux-2.6.21-rc6-git3/drivers/ide/ide-io.c linux-2.6.21-rc6-git4/drivers/ide/ide-io.c
--- linux-2.6.21-rc6-git3/drivers/ide/ide-io.c	2007-04-11 09:18:03.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/ide/ide-io.c	2007-04-11 09:18:52.000000000 -0400
@@ -1226,6 +1226,7 @@ static void ide_do_request (ide_hwgroup_
 #endif
 				/* so that ide_timer_expiry knows what to do */
 				hwgroup->sleeping = 1;
+				hwgroup->req_gen_timer = hwgroup->req_gen;
 				mod_timer(&hwgroup->timer, sleep);
 				/* we purposely leave hwgroup->busy==1
 				 * while sleeping */
@@ -1411,7 +1412,8 @@ void ide_timer_expiry (unsigned long dat
 
 	spin_lock_irqsave(&ide_lock, flags);
 
-	if ((handler = hwgroup->handler) == NULL) {
+	if (((handler = hwgroup->handler) == NULL) ||
+	    (hwgroup->req_gen != hwgroup->req_gen_timer)) {
 		/*
 		 * Either a marginal timeout occurred
 		 * (got the interrupt just as timer expired),
@@ -1439,6 +1441,7 @@ void ide_timer_expiry (unsigned long dat
 				if ((wait = expiry(drive)) > 0) {
 					/* reset timer */
 					hwgroup->timer.expires  = jiffies + wait;
+					hwgroup->req_gen_timer = hwgroup->req_gen;
 					add_timer(&hwgroup->timer);
 					spin_unlock_irqrestore(&ide_lock, flags);
 					return;
@@ -1653,6 +1656,7 @@ irqreturn_t ide_intr (int irq, void *dev
 		printk(KERN_ERR "%s: ide_intr: hwgroup->busy was 0 ??\n", drive->name);
 	}
 	hwgroup->handler = NULL;
+	hwgroup->req_gen++;
 	del_timer(&hwgroup->timer);
 	spin_unlock(&ide_lock);
 
diff -ruNp linux-2.6.21-rc6-git3/drivers/ide/ide-iops.c linux-2.6.21-rc6-git4/drivers/ide/ide-iops.c
--- linux-2.6.21-rc6-git3/drivers/ide/ide-iops.c	2007-04-11 09:18:03.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/ide/ide-iops.c	2007-04-11 09:18:52.000000000 -0400
@@ -889,6 +889,7 @@ static void __ide_set_handler (ide_drive
 	hwgroup->handler	= handler;
 	hwgroup->expiry		= expiry;
 	hwgroup->timer.expires	= jiffies + timeout;
+	hwgroup->req_gen_timer = hwgroup->req_gen;
 	add_timer(&hwgroup->timer);
 }
 
@@ -929,6 +930,7 @@ void ide_execute_command(ide_drive_t *dr
 	hwgroup->handler	= handler;
 	hwgroup->expiry		= expiry;
 	hwgroup->timer.expires	= jiffies + timeout;
+	hwgroup->req_gen_timer = hwgroup->req_gen;
 	add_timer(&hwgroup->timer);
 	hwif->OUTBSYNC(drive, cmd, IDE_COMMAND_REG);
 	/* Drive takes 400nS to respond, we must avoid the IRQ being
diff -ruNp linux-2.6.21-rc6-git3/drivers/ieee1394/dv1394.c linux-2.6.21-rc6-git4/drivers/ieee1394/dv1394.c
--- linux-2.6.21-rc6-git3/drivers/ieee1394/dv1394.c	2007-04-11 09:15:29.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/ieee1394/dv1394.c	2007-04-11 09:18:52.000000000 -0400
@@ -2564,8 +2564,8 @@ static int __init dv1394_init_module(voi
 	int ret;
 
 	printk(KERN_WARNING
-	       "WARNING: The dv1394 driver is unsupported and will be removed "
-	       "from Linux soon. Use raw1394 instead.\n");
+	       "NOTE: The dv1394 driver is unsupported and may be removed in a "
+	       "future Linux release. Use raw1394 instead.\n");
 
 	cdev_init(&dv1394_cdev, &dv1394_fops);
 	dv1394_cdev.owner = THIS_MODULE;
diff -ruNp linux-2.6.21-rc6-git3/drivers/ieee1394/Kconfig linux-2.6.21-rc6-git4/drivers/ieee1394/Kconfig
--- linux-2.6.21-rc6-git3/drivers/ieee1394/Kconfig	2007-04-11 09:15:29.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/ieee1394/Kconfig	2007-04-11 09:18:52.000000000 -0400
@@ -138,9 +138,9 @@ config IEEE1394_DV1394
 	tristate "OHCI-DV I/O support (deprecated)"
 	depends on IEEE1394 && IEEE1394_OHCI1394
 	help
-	  The dv1394 driver will be removed from Linux in a future release.
-	  Its functionality is now provided by raw1394 together with libraries
-	  such as libiec61883.
+	  The dv1394 driver is unsupported and may be removed from Linux in a
+	  future release.  Its functionality is now provided by raw1394 together
+	  with libraries such as libiec61883.
 
 config IEEE1394_RAWIO
 	tristate "Raw IEEE1394 I/O support"
diff -ruNp linux-2.6.21-rc6-git3/drivers/infiniband/ulp/ipoib/ipoib_cm.c linux-2.6.21-rc6-git4/drivers/infiniband/ulp/ipoib/ipoib_cm.c
--- linux-2.6.21-rc6-git3/drivers/infiniband/ulp/ipoib/ipoib_cm.c	2007-04-11 09:17:41.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/infiniband/ulp/ipoib/ipoib_cm.c	2007-04-11 09:18:52.000000000 -0400
@@ -131,7 +131,7 @@ static struct sk_buff *ipoib_cm_alloc_rx
 		skb_fill_page_desc(skb, i, page, 0, PAGE_SIZE);
 
 		mapping[i + 1] = ib_dma_map_page(priv->ca, skb_shinfo(skb)->frags[i].page,
-						 0, PAGE_SIZE, DMA_TO_DEVICE);
+						 0, PAGE_SIZE, DMA_FROM_DEVICE);
 		if (unlikely(ib_dma_mapping_error(priv->ca, mapping[i + 1])))
 			goto partial_error;
 	}
diff -ruNp linux-2.6.21-rc6-git3/drivers/infiniband/ulp/iser/iscsi_iser.h linux-2.6.21-rc6-git4/drivers/infiniband/ulp/iser/iscsi_iser.h
--- linux-2.6.21-rc6-git3/drivers/infiniband/ulp/iser/iscsi_iser.h	2007-03-09 17:10:46.000000000 -0500
+++ linux-2.6.21-rc6-git4/drivers/infiniband/ulp/iser/iscsi_iser.h	2007-04-11 09:18:52.000000000 -0400
@@ -245,7 +245,6 @@ struct iser_conn {
 	wait_queue_head_t	     wait;          /* waitq for conn/disconn  */
 	atomic_t                     post_recv_buf_count; /* posted rx count   */
 	atomic_t                     post_send_buf_count; /* posted tx count   */
-	struct work_struct           comperror_work; /* conn term sleepable ctx*/
 	char 			     name[ISER_OBJECT_NAME_SIZE];
 	struct iser_page_vec         *page_vec;     /* represents SG to fmr maps*
 						     * maps serialized as tx is*/
diff -ruNp linux-2.6.21-rc6-git3/drivers/infiniband/ulp/iser/iser_verbs.c linux-2.6.21-rc6-git4/drivers/infiniband/ulp/iser/iser_verbs.c
--- linux-2.6.21-rc6-git3/drivers/infiniband/ulp/iser/iser_verbs.c	2007-03-09 17:10:46.000000000 -0500
+++ linux-2.6.21-rc6-git4/drivers/infiniband/ulp/iser/iser_verbs.c	2007-04-11 09:18:52.000000000 -0400
@@ -48,7 +48,6 @@
 
 static void iser_cq_tasklet_fn(unsigned long data);
 static void iser_cq_callback(struct ib_cq *cq, void *cq_context);
-static void iser_comp_error_worker(struct work_struct *work);
 
 static void iser_cq_event_callback(struct ib_event *cause, void *context)
 {
@@ -480,7 +479,6 @@ int iser_conn_init(struct iser_conn **ib
 	init_waitqueue_head(&ib_conn->wait);
 	atomic_set(&ib_conn->post_recv_buf_count, 0);
 	atomic_set(&ib_conn->post_send_buf_count, 0);
-	INIT_WORK(&ib_conn->comperror_work, iser_comp_error_worker);
 	INIT_LIST_HEAD(&ib_conn->conn_list);
 	spin_lock_init(&ib_conn->lock);
 
@@ -753,26 +751,6 @@ int iser_post_send(struct iser_desc *tx_
 	return ret_val;
 }
 
-static void iser_comp_error_worker(struct work_struct *work)
-{
-	struct iser_conn *ib_conn =
-		container_of(work, struct iser_conn, comperror_work);
-
-	/* getting here when the state is UP means that the conn is being *
-	 * terminated asynchronously from the iSCSI layer's perspective.  */
-	if (iser_conn_state_comp_exch(ib_conn, ISER_CONN_UP,
-				      ISER_CONN_TERMINATING))
-		iscsi_conn_failure(ib_conn->iser_conn->iscsi_conn,
-					ISCSI_ERR_CONN_FAILED);
-
-	/* complete the termination process if disconnect event was delivered *
-	 * note there are no more non completed posts to the QP               */
-	if (ib_conn->disc_evt_flag) {
-		ib_conn->state = ISER_CONN_DOWN;
-		wake_up_interruptible(&ib_conn->wait);
-	}
-}
-
 static void iser_handle_comp_error(struct iser_desc *desc)
 {
 	struct iser_dto  *dto     = &desc->dto;
@@ -791,8 +769,22 @@ static void iser_handle_comp_error(struc
 	}
 
 	if (atomic_read(&ib_conn->post_recv_buf_count) == 0 &&
-	    atomic_read(&ib_conn->post_send_buf_count) == 0)
-		schedule_work(&ib_conn->comperror_work);
+	    atomic_read(&ib_conn->post_send_buf_count) == 0) {
+		/* getting here when the state is UP means that the conn is *
+		 * being terminated asynchronously from the iSCSI layer's   *
+		 * perspective.                                             */
+		if (iser_conn_state_comp_exch(ib_conn, ISER_CONN_UP,
+		    ISER_CONN_TERMINATING))
+			iscsi_conn_failure(ib_conn->iser_conn->iscsi_conn,
+					   ISCSI_ERR_CONN_FAILED);
+
+		/* complete the termination process if disconnect event was delivered *
+		 * note there are no more non completed posts to the QP               */
+		if (ib_conn->disc_evt_flag) {
+			ib_conn->state = ISER_CONN_DOWN;
+			wake_up_interruptible(&ib_conn->wait);
+		}
+	}
 }
 
 static void iser_cq_tasklet_fn(unsigned long data)
diff -ruNp linux-2.6.21-rc6-git3/drivers/input/touchscreen/ucb1400_ts.c linux-2.6.21-rc6-git4/drivers/input/touchscreen/ucb1400_ts.c
--- linux-2.6.21-rc6-git3/drivers/input/touchscreen/ucb1400_ts.c	2007-04-11 09:15:29.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/input/touchscreen/ucb1400_ts.c	2007-04-11 09:18:52.000000000 -0400
@@ -553,6 +553,7 @@ static int ucb1400_ts_remove(struct devi
 }
 
 static struct device_driver ucb1400_ts_driver = {
+	.name		= "ucb1400_ts",
 	.owner		= THIS_MODULE,
 	.bus		= &ac97_bus_type,
 	.probe		= ucb1400_ts_probe,
diff -ruNp linux-2.6.21-rc6-git3/drivers/net/sc92031.c linux-2.6.21-rc6-git4/drivers/net/sc92031.c
--- linux-2.6.21-rc6-git3/drivers/net/sc92031.c	2007-04-11 09:15:34.000000000 -0400
+++ linux-2.6.21-rc6-git4/drivers/net/sc92031.c	2007-04-11 09:18:52.000000000 -0400
@@ -964,7 +964,7 @@ static int sc92031_start_xmit(struct sk_
 		goto out;
 	}
 
-	spin_lock_bh(&priv->lock);
+	spin_lock(&priv->lock);
 
 	if (unlikely(!netif_carrier_ok(dev))) {
 		err = -ENOLINK;
@@ -1005,7 +1005,7 @@ static int sc92031_start_xmit(struct sk_
 		netif_stop_queue(dev);
 
 out_unlock:
-	spin_unlock_bh(&priv->lock);
+	spin_unlock(&priv->lock);
 
 out:
 	dev_kfree_skb(skb);
@@ -1042,12 +1042,12 @@ static int sc92031_open(struct net_devic
 	priv->pm_config = 0;
 
 	/* Interrupts already disabled by sc92031_stop or sc92031_probe */
-	spin_lock(&priv->lock);
+	spin_lock_bh(&priv->lock);
 
 	_sc92031_reset(dev);
 	mmiowb();
 
-	spin_unlock(&priv->lock);
+	spin_unlock_bh(&priv->lock);
 	sc92031_enable_interrupts(dev);
 
 	if (netif_carrier_ok(dev))
@@ -1077,13 +1077,13 @@ static int sc92031_stop(struct net_devic
 	/* Disable interrupts, stop Tx and Rx. */
 	sc92031_disable_interrupts(dev);
 
-	spin_lock(&priv->lock);
+	spin_lock_bh(&priv->lock);
 
 	_sc92031_disable_tx_rx(dev);
 	_sc92031_tx_clear(dev);
 	mmiowb();
 
-	spin_unlock(&priv->lock);
+	spin_unlock_bh(&priv->lock);
 
 	free_irq(pdev->irq, dev);
 	pci_free_consistent(pdev, TX_BUF_TOT_LEN, priv->tx_bufs,
@@ -1539,13 +1539,13 @@ static int sc92031_suspend(struct pci_de
 	/* Disable interrupts, stop Tx and Rx. */
 	sc92031_disable_interrupts(dev);
 
-	spin_lock(&priv->lock);
+	spin_lock_bh(&priv->lock);
 
 	_sc92031_disable_tx_rx(dev);
 	_sc92031_tx_clear(dev);
 	mmiowb();
 
-	spin_unlock(&priv->lock);
+	spin_unlock_bh(&priv->lock);
 
 out:
 	pci_set_power_state(pdev, pci_choose_state(pdev, state));
@@ -1565,12 +1565,12 @@ static int sc92031_resume(struct pci_dev
 		goto out;
 
 	/* Interrupts already disabled by sc92031_suspend */
-	spin_lock(&priv->lock);
+	spin_lock_bh(&priv->lock);
 
 	_sc92031_reset(dev);
 	mmiowb();
 
-	spin_unlock(&priv->lock);
+	spin_unlock_bh(&priv->lock);
 	sc92031_enable_interrupts(dev);
 
 	netif_device_attach(dev);
diff -ruNp linux-2.6.21-rc6-git3/include/asm-ia64/sn/pcibr_provider.h linux-2.6.21-rc6-git4/include/asm-ia64/sn/pcibr_provider.h
--- linux-2.6.21-rc6-git3/include/asm-ia64/sn/pcibr_provider.h	2007-04-11 09:15:46.000000000 -0400
+++ linux-2.6.21-rc6-git4/include/asm-ia64/sn/pcibr_provider.h	2007-04-11 09:18:52.000000000 -0400
@@ -21,6 +21,7 @@
 #define IS_PCI_BRIDGE_ASIC(asic) (asic == PCIIO_ASIC_TYPE_PIC || \
                 asic == PCIIO_ASIC_TYPE_TIOCP)
 #define IS_PIC_SOFT(ps)     (ps->pbi_bridge_type == PCIBR_BRIDGETYPE_PIC)
+#define IS_TIOCP_SOFT(ps)   (ps->pbi_bridge_type == PCIBR_BRIDGETYPE_TIOCP)
 
 
 /*
@@ -53,8 +54,8 @@
  * Bridge PMU Address Transaltion Entry Attibutes
  */
 #define PCI32_ATE_V                     (0x1 << 0)
-#define PCI32_ATE_CO                    (0x1 << 1)
-#define PCI32_ATE_PREC                  (0x1 << 2)
+#define PCI32_ATE_CO                    (0x1 << 1)	/* PIC ASIC ONLY */
+#define PCI32_ATE_PIO                   (0x1 << 1)	/* TIOCP ASIC ONLY */
 #define PCI32_ATE_MSI                   (0x1 << 2)
 #define PCI32_ATE_PREF                  (0x1 << 3)
 #define PCI32_ATE_BAR                   (0x1 << 4)
diff -ruNp linux-2.6.21-rc6-git3/include/linux/ide.h linux-2.6.21-rc6-git4/include/linux/ide.h
--- linux-2.6.21-rc6-git3/include/linux/ide.h	2007-04-11 09:18:03.000000000 -0400
+++ linux-2.6.21-rc6-git4/include/linux/ide.h	2007-04-11 09:18:52.000000000 -0400
@@ -861,6 +861,8 @@ typedef struct hwgroup_s {
 	int (*expiry)(ide_drive_t *);
 		/* ide_system_bus_speed */
 	int pio_clock;
+	int req_gen;
+	int req_gen_timer;
 
 	unsigned char cmd_buf[4];
 } ide_hwgroup_t;
diff -ruNp linux-2.6.21-rc6-git3/MAINTAINERS linux-2.6.21-rc6-git4/MAINTAINERS
--- linux-2.6.21-rc6-git3/MAINTAINERS	2007-04-11 09:18:03.000000000 -0400
+++ linux-2.6.21-rc6-git4/MAINTAINERS	2007-04-11 09:18:52.000000000 -0400
@@ -1404,7 +1404,7 @@ M:	hch@infradead.org
 W:	ftp://ftp.openlinux.org/pub/people/hch/vxfs
 S:	Maintained
 
-FUJITSU FR-V PORT
+FUJITSU FR-V (FRV) PORT
 P:	David Howells
 M:	dhowells@redhat.com
 S:	Maintained
diff -ruNp linux-2.6.21-rc6-git3/Makefile linux-2.6.21-rc6-git4/Makefile
--- linux-2.6.21-rc6-git3/Makefile	2007-04-11 09:18:40.000000000 -0400
+++ linux-2.6.21-rc6-git4/Makefile	2007-04-11 09:18:52.000000000 -0400
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 21
-EXTRAVERSION = -rc6-git3
+EXTRAVERSION = -rc6-git4
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff -ruNp linux-2.6.21-rc6-git3/net/ipv4/netfilter/ipt_CLUSTERIP.c linux-2.6.21-rc6-git4/net/ipv4/netfilter/ipt_CLUSTERIP.c
--- linux-2.6.21-rc6-git3/net/ipv4/netfilter/ipt_CLUSTERIP.c	2007-04-11 09:16:02.000000000 -0400
+++ linux-2.6.21-rc6-git4/net/ipv4/netfilter/ipt_CLUSTERIP.c	2007-04-11 09:18:52.000000000 -0400
@@ -411,12 +411,10 @@ checkentry(const char *tablename,
 				       "has invalid config pointer!\n");
 				return 0;
 			}
-			clusterip_config_entry_get(cipinfo->config);
 		} else {
 			/* Case B: This is a new rule referring to an existing
 			 * clusterip config. */
 			cipinfo->config = config;
-			clusterip_config_entry_get(cipinfo->config);
 		}
 	} else {
 		/* Case C: This is a completely new clusterip config */
diff -ruNp linux-2.6.21-rc6-git3/net/ipv4/tcp_output.c linux-2.6.21-rc6-git4/net/ipv4/tcp_output.c
--- linux-2.6.21-rc6-git3/net/ipv4/tcp_output.c	2007-04-11 09:18:03.000000000 -0400
+++ linux-2.6.21-rc6-git4/net/ipv4/tcp_output.c	2007-04-11 09:18:52.000000000 -0400
@@ -943,7 +943,8 @@ static void tcp_cwnd_validate(struct soc
 		if (tp->packets_out > tp->snd_cwnd_used)
 			tp->snd_cwnd_used = tp->packets_out;
 
-		if ((s32)(tcp_time_stamp - tp->snd_cwnd_stamp) >= inet_csk(sk)->icsk_rto)
+		if (sysctl_tcp_slow_start_after_idle &&
+		    (s32)(tcp_time_stamp - tp->snd_cwnd_stamp) >= inet_csk(sk)->icsk_rto)
 			tcp_cwnd_application_limited(sk);
 	}
 }
diff -ruNp linux-2.6.21-rc6-git3/net/sched/cls_tcindex.c linux-2.6.21-rc6-git4/net/sched/cls_tcindex.c
--- linux-2.6.21-rc6-git3/net/sched/cls_tcindex.c	2007-04-11 09:16:18.000000000 -0400
+++ linux-2.6.21-rc6-git4/net/sched/cls_tcindex.c	2007-04-11 09:18:52.000000000 -0400
@@ -245,9 +245,9 @@ tcindex_set_parms(struct tcf_proto *tp, 
 	}
 
 	if (tb[TCA_TCINDEX_SHIFT-1]) {
-		if (RTA_PAYLOAD(tb[TCA_TCINDEX_SHIFT-1]) < sizeof(u16))
+		if (RTA_PAYLOAD(tb[TCA_TCINDEX_SHIFT-1]) < sizeof(int))
 			goto errout;
-		cp.shift = *(u16 *) RTA_DATA(tb[TCA_TCINDEX_SHIFT-1]);
+		cp.shift = *(int *) RTA_DATA(tb[TCA_TCINDEX_SHIFT-1]);
 	}
 
 	err = -EBUSY;
