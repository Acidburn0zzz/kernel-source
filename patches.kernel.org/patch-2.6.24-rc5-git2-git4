From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] kernel: Update to 2.6.24-rc5-git4
Patch-mainline: 2.6.24-rc5-git4

 This patch contains the differences between 2.6.24-rc5-git2 and -git4.

 The corresponding git commit id is: ea9e7b5569a538123dc4d60ba36b9170ca8e8830.

Acked-by: Jeff Mahoney <jeffm@suse.com>

---

 Documentation/i2c/summary                   |   45 ---
 Documentation/nfsroot.txt                   |   12 
 Makefile                                    |    2 
 arch/arm/Kconfig                            |    8 
 arch/arm/boot/compressed/head.S             |    2 
 arch/arm/common/it8152.c                    |   10 
 arch/arm/mach-ixp4xx/common.c               |   10 
 arch/arm/mach-pxa/cm-x270-pci.c             |   18 -
 arch/mips/au1000/Kconfig                    |    9 
 arch/mips/au1000/common/pci.c               |    8 
 arch/mips/au1000/common/setup.c             |    9 
 arch/mips/cobalt/time.c                     |   21 +
 arch/mips/kernel/process.c                  |    3 
 arch/mips/kernel/time.c                     |    4 
 arch/mips/kernel/traps.c                    |    6 
 arch/mips/mips-boards/generic/memory.c      |    2 
 arch/mips/pci/pci.c                         |    2 
 arch/powerpc/configs/mpc8272_ads_defconfig  |    6 
 arch/powerpc/configs/pq2fads_defconfig      |    6 
 arch/powerpc/configs/ps3_defconfig          |    2 
 arch/powerpc/kernel/ppc_ksyms.c             |   12 
 arch/powerpc/math-emu/op-2.h                |    3 
 arch/powerpc/platforms/iseries/lpevents.c   |   17 +
 arch/powerpc/platforms/ps3/Kconfig          |    2 
 arch/powerpc/sysdev/cpm2_common.c           |    3 
 arch/sparc64/kernel/entry.S                 |   12 
 arch/sparc64/kernel/smp.c                   |   19 -
 arch/sparc64/mm/init.c                      |   29 +-
 drivers/acpi/battery.c                      |    2 
 drivers/acpi/numa.c                         |    4 
 drivers/acpi/pci_bind.c                     |    3 
 drivers/acpi/sbs.c                          |   27 -
 drivers/acpi/sbshc.c                        |   17 -
 drivers/acpi/sbshc.h                        |    6 
 drivers/acpi/video.c                        |    4 
 drivers/atm/fore200e.c                      |    3 
 drivers/char/ipmi/ipmi_watchdog.c           |    2 
 drivers/i2c/busses/i2c-davinci.c            |    4 
 drivers/i2c/busses/i2c-gpio.c               |    1 
 drivers/i2c/busses/i2c-omap.c               |    6 
 drivers/i2c/chips/isp1301_omap.c            |    2 
 drivers/infiniband/hw/ehca/ehca_classes.h   |    1 
 drivers/infiniband/hw/ehca/ehca_main.c      |   15 -
 drivers/infiniband/hw/ehca/ehca_qp.c        |    4 
 drivers/infiniband/hw/ehca/hcp_if.c         |   27 -
 drivers/infiniband/hw/ehca/hipz_hw.h        |    1 
 drivers/media/Makefile                      |    2 
 drivers/media/dvb/frontends/s5h1409.c       |   11 
 drivers/media/video/bt866.c                 |    1 
 drivers/media/video/saa7134/saa7134-cards.c |    1 
 drivers/media/video/videobuf-core.c         |   18 +
 drivers/misc/thinkpad_acpi.c                |    4 
 drivers/net/fs_enet/mac-scc.c               |    2 
 drivers/net/irda/irda-usb.c                 |    5 
 drivers/net/irda/mcs7780.c                  |    2 
 drivers/net/irda/stir4200.c                 |   10 
 drivers/net/wan/syncppp.c                   |   35 +-
 drivers/sbus/char/cpwatchdog.c              |    2 
 drivers/serial/suncore.c                    |   33 +-
 drivers/serial/suncore.h                    |    3 
 drivers/serial/sunhv.c                      |   14 
 drivers/serial/sunsab.c                     |   16 -
 drivers/serial/sunsu.c                      |   16 -
 drivers/serial/sunzilog.c                   |   41 +-
 drivers/watchdog/Kconfig                    |   23 +
 drivers/watchdog/Makefile                   |    2 
 drivers/watchdog/at32ap700x_wdt.c           |   69 ++++
 drivers/watchdog/bfin_wdt.c                 |    2 
 drivers/watchdog/it8712f_wdt.c              |  400 ++++++++++++++++++++++++++++
 drivers/watchdog/sbc7240_wdt.c              |  324 ++++++++++++++++++++++
 drivers/watchdog/w83697hf_wdt.c             |    4 
 include/asm-arm/arch-pxa/pxa-regs.h         |    1 
 include/asm-mips/mach-au1x00/au1000.h       |    9 
 include/asm-powerpc/commproc.h              |    3 
 include/asm-s390/pgtable.h                  |    8 
 include/asm-sparc/unistd.h                  |    9 
 include/asm-sparc64/hypervisor.h            |    4 
 include/linux/netfilter_bridge.h            |    3 
 net/ax25/ax25_subr.c                        |    2 
 net/bridge/br_device.c                      |    3 
 net/ipv4/ipconfig.c                         |   20 -
 net/ipv4/netfilter/ip_tables.c              |   57 ---
 net/ipv4/tcp_input.c                        |    2 
 net/ipv6/ipv6_sockglue.c                    |   12 
 net/irda/irlmp.c                            |    1 
 net/irda/parameters.c                       |    6 
 net/netfilter/nf_conntrack_netlink.c        |    4 
 net/netfilter/x_tables.c                    |    8 
 net/netfilter/xt_hashlimit.c                |    2 
 net/sctp/ulpqueue.c                         |   33 ++
 net/tipc/socket.c                           |    2 
 net/xfrm/xfrm_state.c                       |   10 
 scripts/mkmakefile                          |    2 
 sound/arm/pxa2xx-ac97.c                     |    4 
 sound/soc/pxa/pxa2xx-ac97.c                 |    4 
 95 files changed, 1261 insertions(+), 399 deletions(-)

--- a/arch/arm/boot/compressed/head.S	2007-10-10 17:43:36.000000000 -0400
+++ b/arch/arm/boot/compressed/head.S	2007-12-17 16:34:57.000000000 -0500
@@ -31,7 +31,7 @@
 		.macro	loadsp, rb
 		.endm
 		.macro	writeb, ch, rb
-		mcr	p14, 0, \ch, c0, c1, 0
+		mcr	p14, 0, \ch, c1, c0, 0
 		.endm
 #endif
 
--- a/arch/arm/common/it8152.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/arm/common/it8152.c	2007-12-17 16:34:57.000000000 -0500
@@ -70,8 +70,6 @@ static inline void it8152_irq(int irq)
 {
 	struct irq_desc *desc;
 
-	printk(KERN_DEBUG "===> %s: irq=%d\n", __FUNCTION__, irq);
-
 	desc = irq_desc + irq;
 	desc_handle_irq(irq, desc);
 }
@@ -106,8 +104,6 @@ void it8152_irq_demux(unsigned int irq, 
        int bits_pd, bits_lp, bits_ld;
        int i;
 
-       printk(KERN_DEBUG "=> %s: irq = %d\n", __FUNCTION__, irq);
-
        while (1) {
 	       /* Read all */
 	       bits_pd = __raw_readl(IT8152_INTC_PDCNIRR);
@@ -293,8 +289,7 @@ int dma_needs_bounce(struct device *dev,
  */
 int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 {
-	printk(KERN_DEBUG "%s: %s %llx\n",
-	       __FUNCTION__, dev->dev.bus_id, mask);
+	dev_dbg(&dev->dev, "%s: %llx\n", __FUNCTION__, mask);
 	if (mask >= PHYS_OFFSET + SZ_64M - 1)
 		return 0;
 
@@ -304,8 +299,7 @@ int pci_set_dma_mask(struct pci_dev *dev
 int
 pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 {
-	printk(KERN_DEBUG "%s: %s %llx\n",
-	       __FUNCTION__, dev->dev.bus_id, mask);
+	dev_dbg(&dev->dev, "%s: %llx\n", __FUNCTION__, mask);
 	if (mask >= PHYS_OFFSET + SZ_64M - 1)
 		return 0;
 
--- a/arch/arm/Kconfig	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/arm/Kconfig	2007-12-17 16:34:57.000000000 -0500
@@ -537,7 +537,7 @@ config ISA_DMA_API
 	bool
 
 config PCI
-	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695
+	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
 	  bus system, i.e. the way the CPU talks to the other stuff inside
@@ -558,6 +558,12 @@ config PCI_HOST_VIA82C505
 	depends on PCI && ARCH_SHARK
 	default y
 
+config PCI_HOST_ITE8152
+	bool
+	depends on PCI && MACH_ARMCORE
+	default y
+	select DMABOUNCE
+
 source "drivers/pci/Kconfig"
 
 source "drivers/pcmcia/Kconfig"
--- a/arch/arm/mach-ixp4xx/common.c	2007-10-10 17:43:36.000000000 -0400
+++ b/arch/arm/mach-ixp4xx/common.c	2007-12-17 16:34:57.000000000 -0500
@@ -442,7 +442,8 @@ static int ixp4xx_set_next_event(unsigne
 static void ixp4xx_set_mode(enum clock_event_mode mode,
 			    struct clock_event_device *evt)
 {
-	unsigned long opts, osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
+	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
+	unsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
@@ -455,12 +456,15 @@ static void ixp4xx_set_mode(enum clock_e
 		opts = IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT;
 		break;
 	case CLOCK_EVT_MODE_SHUTDOWN:
+		opts &= ~IXP4XX_OST_ENABLE;
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		opts |= IXP4XX_OST_ENABLE;
+		break;
 	case CLOCK_EVT_MODE_UNUSED:
 	default:
 		osrt = opts = 0;
 		break;
-	case CLOCK_EVT_MODE_RESUME:
-		break;
 	}
 
 	*IXP4XX_OSRT1 = osrt | opts;
--- a/arch/arm/mach-pxa/cm-x270-pci.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/arm/mach-pxa/cm-x270-pci.c	2007-12-17 16:34:57.000000000 -0500
@@ -40,7 +40,7 @@ void __init cmx270_pci_adjust_zones(int 
 {
 	unsigned int sz = SZ_64M >> PAGE_SHIFT;
 
-	printk(KERN_INFO "Adjusting zones for CM-x270\n");
+	pr_info("Adjusting zones for CM-x270\n");
 
 	/*
 	 * Only adjust if > 64M on current system
@@ -104,8 +104,7 @@ static int __init cmx270_pci_map_irq(str
 {
 	int irq;
 
-	printk(KERN_DEBUG "===> %s: %s slot=%x, pin=%x\n", __FUNCTION__,
-	       pci_name(dev), slot, pin);
+	dev_dbg(&dev->dev, "%s: slot=%x, pin=%x\n", __FUNCTION__, slot, pin);
 
 	irq = it8152_pci_map_irq(dev, slot, pin);
 	if (irq)
@@ -141,14 +140,13 @@ static int __init cmx270_pci_map_irq(str
 	return(0);
 }
 
-static struct pci_bus * __init
-cmx270_pci_scan_bus(int nr, struct pci_sys_data *sys)
+static void cmx270_pci_preinit(void)
 {
-	printk(KERN_INFO "Initializing CM-X270 PCI subsystem\n");
+	pr_info("Initializing CM-X270 PCI subsystem\n");
 
 	__raw_writel(0x800, IT8152_PCI_CFG_ADDR);
 	if (__raw_readl(IT8152_PCI_CFG_DATA) == 0x81521283) {
-		printk(KERN_INFO "PCI Bridge found.\n");
+		pr_info("PCI Bridge found.\n");
 
 		/* set PCI I/O base at 0 */
 		writel(0x848, IT8152_PCI_CFG_ADDR);
@@ -163,7 +161,7 @@ cmx270_pci_scan_bus(int nr, struct pci_s
 		/* CardBus Controller on ATXbase baseboard */
 		writel(0x4000, IT8152_PCI_CFG_ADDR);
 		if (readl(IT8152_PCI_CFG_DATA) == 0xAC51104C) {
-			printk(KERN_INFO "CardBus Bridge found.\n");
+			pr_info("CardBus Bridge found.\n");
 
 			/* Configure socket 0 */
 			writel(0x408C, IT8152_PCI_CFG_ADDR);
@@ -196,7 +194,6 @@ cmx270_pci_scan_bus(int nr, struct pci_s
 			writel(0xb0000000, IT8152_PCI_CFG_DATA);
 		}
 	}
-	return it8152_pci_scan_bus(nr, sys);
 }
 
 static struct hw_pci cmx270_pci __initdata = {
@@ -204,7 +201,8 @@ static struct hw_pci cmx270_pci __initda
 	.map_irq	= cmx270_pci_map_irq,
 	.nr_controllers	= 1,
 	.setup		= it8152_pci_setup,
-	.scan		= cmx270_pci_scan_bus,
+	.scan		= it8152_pci_scan_bus,
+	.preinit	= cmx270_pci_preinit,
 };
 
 static int __init cmx270_init_pci(void)
--- a/arch/mips/au1000/common/pci.c	2007-10-10 17:43:37.000000000 -0400
+++ b/arch/mips/au1000/common/pci.c	2007-12-17 16:34:57.000000000 -0500
@@ -39,15 +39,15 @@
 
 /* TBD */
 static struct resource pci_io_resource = {
-	.start	= (resource_size_t)PCI_IO_START,
-	.end	= (resource_size_t)PCI_IO_END,
+	.start	= PCI_IO_START,
+	.end	= PCI_IO_END,
 	.name	= "PCI IO space",
 	.flags	= IORESOURCE_IO
 };
 
 static struct resource pci_mem_resource = {
-	.start	= (resource_size_t)PCI_MEM_START,
-	.end	= (resource_size_t)PCI_MEM_END,
+	.start	= PCI_MEM_START,
+	.end	= PCI_MEM_END,
 	.name	= "PCI memory space",
 	.flags	= IORESOURCE_MEM
 };
--- a/arch/mips/au1000/common/setup.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/mips/au1000/common/setup.c	2007-12-17 16:34:57.000000000 -0500
@@ -137,12 +137,11 @@ phys_t __fixup_bigphys_addr(phys_t phys_
 
 #ifdef CONFIG_PCI
 	{
-		u32 start, end;
+		u32 start = (u32)Au1500_PCI_MEM_START;
+		u32 end   = (u32)Au1500_PCI_MEM_END;
 
-		start = (u32)Au1500_PCI_MEM_START;
-		end = (u32)Au1500_PCI_MEM_END;
-		/* check for pci memory window */
-		if ((phys_addr >= start) && ((phys_addr + size) < end))
+		/* Check for PCI memory window */
+		if (phys_addr >= start && (phys_addr + size - 1) <= end)
 			return (phys_t)
 			       ((phys_addr - start) + Au1500_PCI_MEM_START);
 	}
--- a/arch/mips/au1000/Kconfig	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/mips/au1000/Kconfig	2007-12-17 16:34:57.000000000 -0500
@@ -7,7 +7,6 @@ config MIPS_MTX1
 	bool "4G Systems MTX-1 board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
 	select SOC_AU1500
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
@@ -22,7 +21,6 @@ config MIPS_DB1000
 	select SOC_AU1000
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_DB1100
@@ -44,7 +42,6 @@ config MIPS_DB1500
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
@@ -54,7 +51,6 @@ config MIPS_DB1550
 	select HW_HAS_PCI
 	select DMA_NONCOHERENT
 	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_MIRAGE
@@ -68,7 +64,6 @@ config MIPS_PB1000
 	select SOC_AU1000
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
 	select SWAP_IO_SPACE
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
@@ -77,7 +72,6 @@ config MIPS_PB1100
 	select SOC_AU1100
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
 	select SWAP_IO_SPACE
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
@@ -86,7 +80,6 @@ config MIPS_PB1200
 	select SOC_AU1200
 	select DMA_NONCOHERENT
 	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_PB1500
@@ -94,7 +87,6 @@ config MIPS_PB1500
 	select SOC_AU1500
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_PB1550
@@ -103,7 +95,6 @@ config MIPS_PB1550
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_XXS1500
--- a/arch/mips/cobalt/time.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/mips/cobalt/time.c	2007-12-17 16:34:57.000000000 -0500
@@ -27,9 +27,28 @@
 
 void __init plat_time_init(void)
 {
+	u32 start, end;
+	int i = HZ / 10;
+
 	setup_pit_timer();
 
 	gt641xx_set_base_clock(GT641XX_BASE_CLOCK);
 
-	mips_timer_state = gt641xx_timer0_state;
+	/*
+	 * MIPS counter frequency is measured during a 100msec interval
+	 * using GT64111 timer0.
+	 */
+	while (!gt641xx_timer0_state())
+		;
+
+	start = read_c0_count();
+
+	while (i--)
+		while (!gt641xx_timer0_state())
+			;
+
+	end = read_c0_count();
+
+	mips_hpt_frequency = (end - start) * 10;
+	printk(KERN_INFO "MIPS counter frequency %dHz\n", mips_hpt_frequency);
 }
--- a/arch/mips/kernel/process.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/mips/kernel/process.c	2007-12-17 16:34:57.000000000 -0500
@@ -77,9 +77,8 @@ void start_thread(struct pt_regs * regs,
 	unsigned long status;
 
 	/* New thread loses kernel privileges. */
-	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|KU_MASK);
+	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|ST0_FR|KU_MASK);
 #ifdef CONFIG_64BIT
-	status &= ~ST0_FR;
 	status |= test_thread_flag(TIF_32BIT_REGS) ? 0 : ST0_FR;
 #endif
 	status |= KU_USER;
--- a/arch/mips/kernel/time.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/mips/kernel/time.c	2007-12-17 16:34:57.000000000 -0500
@@ -109,10 +109,6 @@ void __cpuinit clockevent_set_clock(stru
 	cd->mult = (u32) temp;
 }
 
-void __init __weak plat_time_init(void)
-{
-}
-
 /*
  * This function exists in order to cause an error due to a duplicate
  * definition if platform code should have its own implementation.  The hook
--- a/arch/mips/kernel/traps.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/mips/kernel/traps.c	2007-12-17 16:34:57.000000000 -0500
@@ -1317,12 +1317,12 @@ void __init per_cpu_trap_init(void)
 #endif
 	if (current_cpu_data.isa_level == MIPS_CPU_ISA_IV)
 		status_set |= ST0_XX;
+	if (cpu_has_dsp)
+		status_set |= ST0_MX;
+
 	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
-	if (cpu_has_dsp)
-		set_c0_status(ST0_MX);
-
 #ifdef CONFIG_CPU_MIPSR2
 	if (cpu_has_mips_r2) {
 		unsigned int enable = 0x0000000f;
--- a/arch/mips/mips-boards/generic/memory.c	2007-12-17 16:34:05.000000000 -0500
+++ b/arch/mips/mips-boards/generic/memory.c	2007-12-17 16:34:57.000000000 -0500
@@ -169,6 +169,7 @@ void __init prom_meminit(void)
 
 void __init prom_free_prom_memory(void)
 {
+#if 0 /* for now ...  */
 	unsigned long addr;
 	int i;
 
@@ -180,4 +181,5 @@ void __init prom_free_prom_memory(void)
 		free_init_pages("prom memory",
 				addr, addr + boot_mem_map.map[i].size);
 	}
+#endif
 }
--- a/arch/mips/pci/pci.c	2007-10-10 17:43:37.000000000 -0400
+++ b/arch/mips/pci/pci.c	2007-12-17 16:34:57.000000000 -0500
@@ -242,6 +242,8 @@ static void pcibios_fixup_device_resourc
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		if (!dev->resource[i].start)
 			continue;
+		if (dev->resource[i].flags & IORESOURCE_PCI_FIXED)
+			continue;
 		if (dev->resource[i].flags & IORESOURCE_IO)
 			offset = hose->io_offset;
 		else if (dev->resource[i].flags & IORESOURCE_MEM)
--- a/arch/powerpc/configs/mpc8272_ads_defconfig	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/powerpc/configs/mpc8272_ads_defconfig	2007-12-17 16:34:57.000000000 -0500
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.24-rc4
-# Thu Dec  6 16:48:30 2007
+# Linux kernel version: 2.6.24-rc5
+# Thu Dec 13 22:40:57 2007
 #
 # CONFIG_PPC64 is not set
 
@@ -491,7 +491,7 @@ CONFIG_MII=y
 CONFIG_FS_ENET=y
 # CONFIG_FS_ENET_HAS_SCC is not set
 CONFIG_FS_ENET_HAS_FCC=y
-# CONFIG_FS_ENET_MDIO_FCC is not set
+CONFIG_FS_ENET_MDIO_FCC=y
 CONFIG_NETDEV_1000=y
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
--- a/arch/powerpc/configs/pq2fads_defconfig	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/powerpc/configs/pq2fads_defconfig	2007-12-17 16:34:57.000000000 -0500
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.24-rc4
-# Thu Dec  6 16:49:09 2007
+# Linux kernel version: 2.6.24-rc5
+# Thu Dec 13 22:39:18 2007
 #
 # CONFIG_PPC64 is not set
 
@@ -548,7 +548,7 @@ CONFIG_MII=y
 CONFIG_FS_ENET=y
 # CONFIG_FS_ENET_HAS_SCC is not set
 CONFIG_FS_ENET_HAS_FCC=y
-# CONFIG_FS_ENET_MDIO_FCC is not set
+CONFIG_FS_ENET_MDIO_FCC=y
 CONFIG_NETDEV_1000=y
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
--- a/arch/powerpc/configs/ps3_defconfig	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/powerpc/configs/ps3_defconfig	2007-12-17 16:34:57.000000000 -0500
@@ -157,7 +157,7 @@ CONFIG_PS3_HTAB_SIZE=20
 CONFIG_PS3_USE_LPAR_ADDR=y
 CONFIG_PS3_VUART=y
 CONFIG_PS3_PS3AV=y
-CONFIG_PS3_SYS_MANAGER=m
+CONFIG_PS3_SYS_MANAGER=y
 CONFIG_PS3_STORAGE=y
 CONFIG_PS3_DISK=y
 CONFIG_PS3_ROM=y
--- a/arch/powerpc/kernel/ppc_ksyms.c	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/powerpc/kernel/ppc_ksyms.c	2007-12-17 16:34:57.000000000 -0500
@@ -45,10 +45,6 @@
 #include <asm/signal.h>
 #include <asm/dcr.h>
 
-#ifdef  CONFIG_8xx
-#include <asm/commproc.h>
-#endif
-
 #ifdef CONFIG_PPC64
 EXPORT_SYMBOL(local_irq_restore);
 #endif
@@ -172,14 +168,6 @@ EXPORT_SYMBOL(console_drivers);
 EXPORT_SYMBOL(cacheable_memcpy);
 #endif
 
-#ifdef  CONFIG_8xx
-EXPORT_SYMBOL(cpm_install_handler);
-EXPORT_SYMBOL(cpm_free_handler);
-#endif /* CONFIG_8xx */
-#if defined(CONFIG_8xx)
-EXPORT_SYMBOL(__res);
-#endif
-
 #ifdef CONFIG_PPC32
 EXPORT_SYMBOL(next_mmu_context);
 EXPORT_SYMBOL(set_context);
--- a/arch/powerpc/math-emu/op-2.h	2007-07-08 19:32:17.000000000 -0400
+++ b/arch/powerpc/math-emu/op-2.h	2007-12-17 16:34:57.000000000 -0500
@@ -59,7 +59,8 @@
     else								\
       {									\
 	X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE) |			\
-	          (((X##_f1 << (sz - (N))) | X##_f0) != 0));		\
+	          (((X##_f1 << (2 * _FP_W_TYPE_SIZE - (N))) |		\
+		   X##_f0) != 0));					\
 	X##_f1 = 0;							\
       }									\
   } while (0)
--- a/arch/powerpc/platforms/iseries/lpevents.c	2007-10-10 17:43:37.000000000 -0400
+++ b/arch/powerpc/platforms/iseries/lpevents.c	2007-12-17 16:34:57.000000000 -0500
@@ -121,6 +121,7 @@ void process_hvlpevents(void)
 {
 	struct HvLpEvent * event;
 
+ restart:
 	/* If we have recursed, just return */
 	if (!spin_trylock(&hvlpevent_queue.hq_lock))
 		return;
@@ -146,8 +147,20 @@ void process_hvlpevents(void)
 			if (event->xType < HvLpEvent_Type_NumTypes &&
 					lpEventHandler[event->xType])
 				lpEventHandler[event->xType](event);
-			else
-				printk(KERN_INFO "Unexpected Lp Event type=%d\n", event->xType );
+			else {
+				u8 type = event->xType;
+
+				/*
+				 * Don't printk in the spinlock as printk
+				 * may require ack events form the HV to send
+				 * any characters there.
+				 */
+				hvlpevent_clear_valid(event);
+				spin_unlock(&hvlpevent_queue.hq_lock);
+				printk(KERN_INFO
+					"Unexpected Lp Event type=%d\n", type);
+				goto restart;
+			}
 
 			hvlpevent_clear_valid(event);
 		} else if (hvlpevent_queue.hq_overflow_pending)
--- a/arch/powerpc/platforms/ps3/Kconfig	2007-10-10 17:43:37.000000000 -0400
+++ b/arch/powerpc/platforms/ps3/Kconfig	2007-12-17 16:34:57.000000000 -0500
@@ -91,7 +91,7 @@ config PS3_SYS_MANAGER
 	depends on PPC_PS3
 	tristate "PS3 System Manager driver" if PS3_ADVANCED
 	select PS3_VUART
-	default m
+	default y
 	help
 	  Include support for the PS3 System Manager.
 
--- a/arch/powerpc/sysdev/cpm2_common.c	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/powerpc/sysdev/cpm2_common.c	2007-12-17 16:34:57.000000000 -0500
@@ -61,8 +61,7 @@ cpm2_map_t __iomem *cpm2_immr;
 					   of space for CPM as it is larger
 					   than on PQ2 */
 
-void
-cpm2_reset(void)
+void __init cpm2_reset(void)
 {
 #ifdef CONFIG_PPC_85xx
 	cpm2_immr = ioremap(CPM_MAP_ADDR, CPM_MAP_SIZE);
--- a/arch/sparc64/kernel/entry.S	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/sparc64/kernel/entry.S	2007-12-17 16:34:57.000000000 -0500
@@ -2593,3 +2593,15 @@ sun4v_mmustat_info:
 	retl
 	 nop
 	.size	sun4v_mmustat_info, .-sun4v_mmustat_info
+
+	.globl	sun4v_mmu_demap_all
+	.type	sun4v_mmu_demap_all,#function
+sun4v_mmu_demap_all:
+	clr	%o0
+	clr	%o1
+	mov	HV_MMU_ALL, %o2
+	mov	HV_FAST_MMU_DEMAP_ALL, %o5
+	ta	HV_FAST_TRAP
+	retl
+	 nop
+	.size	sun4v_mmu_demap_all, .-sun4v_mmu_demap_all
--- a/arch/sparc64/kernel/smp.c	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/sparc64/kernel/smp.c	2007-12-17 16:34:57.000000000 -0500
@@ -476,7 +476,7 @@ static inline void spitfire_xcall_delive
  */
 static void cheetah_xcall_deliver(u64 data0, u64 data1, u64 data2, cpumask_t mask)
 {
-	u64 pstate, ver;
+	u64 pstate, ver, busy_mask;
 	int nack_busy_id, is_jbus, need_more;
 
 	if (cpus_empty(mask))
@@ -508,14 +508,20 @@ retry:
 			       "i" (ASI_INTR_W));
 
 	nack_busy_id = 0;
+	busy_mask = 0;
 	{
 		int i;
 
 		for_each_cpu_mask(i, mask) {
 			u64 target = (i << 14) | 0x70;
 
-			if (!is_jbus)
+			if (is_jbus) {
+				busy_mask |= (0x1UL << (i * 2));
+			} else {
 				target |= (nack_busy_id << 24);
+				busy_mask |= (0x1UL <<
+					      (nack_busy_id * 2));
+			}
 			__asm__ __volatile__(
 				"stxa	%%g0, [%0] %1\n\t"
 				"membar	#Sync\n\t"
@@ -531,15 +537,16 @@ retry:
 
 	/* Now, poll for completion. */
 	{
-		u64 dispatch_stat;
+		u64 dispatch_stat, nack_mask;
 		long stuck;
 
 		stuck = 100000 * nack_busy_id;
+		nack_mask = busy_mask << 1;
 		do {
 			__asm__ __volatile__("ldxa	[%%g0] %1, %0"
 					     : "=r" (dispatch_stat)
 					     : "i" (ASI_INTR_DISPATCH_STAT));
-			if (dispatch_stat == 0UL) {
+			if (!(dispatch_stat & (busy_mask | nack_mask))) {
 				__asm__ __volatile__("wrpr %0, 0x0, %%pstate"
 						     : : "r" (pstate));
 				if (unlikely(need_more)) {
@@ -556,12 +563,12 @@ retry:
 			}
 			if (!--stuck)
 				break;
-		} while (dispatch_stat & 0x5555555555555555UL);
+		} while (dispatch_stat & busy_mask);
 
 		__asm__ __volatile__("wrpr %0, 0x0, %%pstate"
 				     : : "r" (pstate));
 
-		if ((dispatch_stat & ~(0x5555555555555555UL)) == 0) {
+		if (dispatch_stat & busy_mask) {
 			/* Busy bits will not clear, continue instead
 			 * of freezing up on this cpu.
 			 */
--- a/arch/sparc64/mm/init.c	2007-12-17 16:34:06.000000000 -0500
+++ b/arch/sparc64/mm/init.c	2007-12-17 16:34:57.000000000 -0500
@@ -1133,14 +1133,9 @@ static void __init mark_kpte_bitmap(unsi
 	}
 }
 
-static void __init kernel_physical_mapping_init(void)
+static void __init init_kpte_bitmap(void)
 {
 	unsigned long i;
-#ifdef CONFIG_DEBUG_PAGEALLOC
-	unsigned long mem_alloced = 0UL;
-#endif
-
-	read_obp_memory("reg", &pall[0], &pall_ents);
 
 	for (i = 0; i < pall_ents; i++) {
 		unsigned long phys_start, phys_end;
@@ -1149,14 +1144,24 @@ static void __init kernel_physical_mappi
 		phys_end = phys_start + pall[i].reg_size;
 
 		mark_kpte_bitmap(phys_start, phys_end);
+	}
+}
 
+static void __init kernel_physical_mapping_init(void)
+{
 #ifdef CONFIG_DEBUG_PAGEALLOC
+	unsigned long i, mem_alloced = 0UL;
+
+	for (i = 0; i < pall_ents; i++) {
+		unsigned long phys_start, phys_end;
+
+		phys_start = pall[i].phys_addr;
+		phys_end = phys_start + pall[i].reg_size;
+
 		mem_alloced += kernel_map_range(phys_start, phys_end,
 						PAGE_KERNEL);
-#endif
 	}
 
-#ifdef CONFIG_DEBUG_PAGEALLOC
 	printk("Allocated %ld bytes for kernel page tables.\n",
 	       mem_alloced);
 
@@ -1398,6 +1403,10 @@ void __init paging_init(void)
 	
 	inherit_prom_mappings();
 	
+	read_obp_memory("reg", &pall[0], &pall_ents);
+
+	init_kpte_bitmap();
+
 	/* Ok, we can use our TLB miss and window trap handlers safely.  */
 	setup_tba();
 
@@ -1904,7 +1913,9 @@ void __flush_tlb_all(void)
 			     "wrpr	%0, %1, %%pstate"
 			     : "=r" (pstate)
 			     : "i" (PSTATE_IE));
-	if (tlb_type == spitfire) {
+	if (tlb_type == hypervisor) {
+		sun4v_mmu_demap_all();
+	} else if (tlb_type == spitfire) {
 		for (i = 0; i < 64; i++) {
 			/* Spitfire Errata #32 workaround */
 			/* NOTE: Always runs on spitfire, so no
--- a/Documentation/i2c/summary	2007-10-10 17:43:36.000000000 -0400
+++ b/Documentation/i2c/summary	2007-12-17 16:34:57.000000000 -0500
@@ -1,5 +1,3 @@
-This is an explanation of what i2c is, and what is supported in this package.
-
 I2C and SMBus
 =============
 
@@ -33,52 +31,17 @@ When we talk about I2C, we use the follo
             Client
 
 An Algorithm driver contains general code that can be used for a whole class
-of I2C adapters. Each specific adapter driver depends on one algorithm
-driver.
+of I2C adapters. Each specific adapter driver either depends on one algorithm
+driver, or includes its own implementation.
 
 A Driver driver (yes, this sounds ridiculous, sorry) contains the general
 code to access some type of device. Each detected device gets its own
 data in the Client structure. Usually, Driver and Client are more closely
 integrated than Algorithm and Adapter.
 
-For a given configuration, you will need a driver for your I2C bus (usually
-a separate Adapter and Algorithm driver), and drivers for your I2C devices
-(usually one driver for each device). There are no I2C device drivers
-in this package. See the lm_sensors project http://www.lm-sensors.nu
-for device drivers.
+For a given configuration, you will need a driver for your I2C bus, and
+drivers for your I2C devices (usually one driver for each device).
 
 At this time, Linux only operates I2C (or SMBus) in master mode; you can't
 use these APIs to make a Linux system behave as a slave/device, either to
 speak a custom protocol or to emulate some other device.
-
-
-Included Bus Drivers
-====================
-Note that only stable drivers are patched into the kernel by 'mkpatch'.
-
-
-Base modules
-------------
-
-i2c-core: The basic I2C code, including the /proc/bus/i2c* interface
-i2c-dev:  The /dev/i2c-* interface
-i2c-proc: The /proc/sys/dev/sensors interface for device (client) drivers
-
-Algorithm drivers
------------------
-
-i2c-algo-bit:    A bit-banging algorithm
-i2c-algo-pcf:    A PCF 8584 style algorithm
-i2c-algo-ibm_ocp: An algorithm for the I2C device in IBM 4xx processors (NOT BUILT BY DEFAULT)
-
-Adapter drivers
----------------
-
-i2c-elektor:     Elektor ISA card (uses i2c-algo-pcf)
-i2c-elv:         ELV parallel port adapter (uses i2c-algo-bit)
-i2c-pcf-epp:     PCF8584 on a EPP parallel port (uses i2c-algo-pcf) (NOT mkpatched)
-i2c-philips-par: Philips style parallel port adapter (uses i2c-algo-bit)
-i2c-adap-ibm_ocp: IBM 4xx processor I2C device (uses i2c-algo-ibm_ocp) (NOT BUILT BY DEFAULT)
-i2c-pport:       Primitive parallel port adapter (uses i2c-algo-bit)
-i2c-velleman:    Velleman K8000 parallel port adapter (uses i2c-algo-bit)
-
--- a/Documentation/nfsroot.txt	2007-07-08 19:32:17.000000000 -0400
+++ b/Documentation/nfsroot.txt	2007-12-17 16:34:57.000000000 -0500
@@ -92,8 +92,14 @@ ip=<client-ip>:<server-ip>:<gw-ip>:<netm
   autoconfiguration.
 
   The <autoconf> parameter can appear alone as the value to the `ip'
-  parameter (without all the ':' characters before) in which case auto-
-  configuration is used.
+  parameter (without all the ':' characters before).  If the value is
+  "ip=off" or "ip=none", no autoconfiguration will take place, otherwise
+  autoconfiguration will take place.  The most common way to use this
+  is "ip=dhcp".
+
+  Note that "ip=off" is not the same thing as "ip=::::::off", because in
+  the latter autoconfiguration will take place if any of DHCP, BOOTP or RARP
+  are compiled in the kernel.
 
   <client-ip>	IP address of the client.
 
@@ -142,7 +148,7 @@ ip=<client-ip>:<server-ip>:<gw-ip>:<netm
 		into the kernel will be used, regardless of the value of
 		this option.
 
-                  off or none: don't use autoconfiguration (default)
+                  off or none: don't use autoconfiguration
 		  on or any:   use any protocol available in the kernel
 		  dhcp:        use DHCP
 		  bootp:       use BOOTP
--- a/drivers/acpi/battery.c	2007-12-17 16:34:07.000000000 -0500
+++ b/drivers/acpi/battery.c	2007-12-17 16:34:57.000000000 -0500
@@ -125,7 +125,7 @@ static int acpi_battery_technology(struc
 		return POWER_SUPPLY_TECHNOLOGY_NiMH;
 	if (!strcasecmp("LION", battery->type))
 		return POWER_SUPPLY_TECHNOLOGY_LION;
-	if (!strcasecmp("LI-ION", battery->type))
+	if (!strncasecmp("LI-ION", battery->type, 6))
 		return POWER_SUPPLY_TECHNOLOGY_LION;
 	if (!strcasecmp("LiP", battery->type))
 		return POWER_SUPPLY_TECHNOLOGY_LIPO;
--- a/drivers/acpi/numa.c	2007-10-10 17:43:38.000000000 -0400
+++ b/drivers/acpi/numa.c	2007-12-17 16:34:57.000000000 -0500
@@ -38,9 +38,9 @@ ACPI_MODULE_NAME("numa");
 static nodemask_t nodes_found_map = NODE_MASK_NONE;
 
 /* maps to convert between proximity domain and logical node ID */
-static int __cpuinitdata pxm_to_node_map[MAX_PXM_DOMAINS]
+static int pxm_to_node_map[MAX_PXM_DOMAINS]
 				= { [0 ... MAX_PXM_DOMAINS - 1] = NID_INVAL };
-static int __cpuinitdata node_to_pxm_map[MAX_NUMNODES]
+static int node_to_pxm_map[MAX_NUMNODES]
 				= { [0 ... MAX_NUMNODES - 1] = PXM_INVAL };
 
 int pxm_to_node(int pxm)
--- a/drivers/acpi/pci_bind.c	2007-07-08 19:32:17.000000000 -0400
+++ b/drivers/acpi/pci_bind.c	2007-12-17 16:34:57.000000000 -0500
@@ -294,9 +294,6 @@ int acpi_pci_unbind(struct acpi_device *
 	    acpi_get_data(device->handle, acpi_pci_data_handler,
 			  (void **)&data);
 	if (ACPI_FAILURE(status)) {
-		ACPI_EXCEPTION((AE_INFO, status,
-				"Unable to get data from device %s",
-				acpi_device_bid(device)));
 		result = -ENODEV;
 		goto end;
 	}
--- a/drivers/acpi/sbs.c	2007-12-17 16:34:07.000000000 -0500
+++ b/drivers/acpi/sbs.c	2007-12-17 16:34:57.000000000 -0500
@@ -54,12 +54,6 @@
 #define ACPI_BATTERY_DIR_NAME		"BAT%i"
 #define ACPI_AC_DIR_NAME		"AC0"
 
-enum acpi_sbs_device_addr {
-	ACPI_SBS_CHARGER = 0x9,
-	ACPI_SBS_MANAGER = 0xa,
-	ACPI_SBS_BATTERY = 0xb,
-};
-
 #define ACPI_SBS_NOTIFY_STATUS		0x80
 #define ACPI_SBS_NOTIFY_INFO		0x81
 
@@ -539,7 +533,7 @@ static struct proc_dir_entry *acpi_batte
 
 static inline char *acpi_battery_units(struct acpi_battery *battery)
 {
-	return acpi_battery_mode(battery) ? " mWh" : " mAh";
+	return acpi_battery_mode(battery) ? " mW" : " mA";
 }
 
 
@@ -556,10 +550,10 @@ static int acpi_battery_read_info(struct
 	if (!battery->present)
 		goto end;
 
-	seq_printf(seq, "design capacity:         %i%s\n",
+	seq_printf(seq, "design capacity:         %i%sh\n",
 		   battery->design_capacity * acpi_battery_scale(battery),
 		   acpi_battery_units(battery));
-	seq_printf(seq, "last full capacity:      %i%s\n",
+	seq_printf(seq, "last full capacity:      %i%sh\n",
 		   battery->full_charge_capacity * acpi_battery_scale(battery),
 		   acpi_battery_units(battery));
 	seq_printf(seq, "battery technology:      rechargeable\n");
@@ -590,7 +584,7 @@ static int acpi_battery_read_state(struc
 {
 	struct acpi_battery *battery = seq->private;
 	struct acpi_sbs *sbs = battery->sbs;
-	int result = 0;
+	int rate;
 
 	mutex_lock(&sbs->lock);
 	seq_printf(seq, "present:                 %s\n",
@@ -604,9 +598,12 @@ static int acpi_battery_read_state(struc
 	seq_printf(seq, "charging state:          %s\n",
 		   (battery->current_now < 0) ? "discharging" :
 		   ((battery->current_now > 0) ? "charging" : "charged"));
-	seq_printf(seq, "present rate:            %d mA\n",
-		   abs(battery->current_now) * acpi_battery_ipscale(battery));
-	seq_printf(seq, "remaining capacity:      %i%s\n",
+	rate = abs(battery->current_now) * acpi_battery_ipscale(battery);
+	rate *= (acpi_battery_mode(battery))?(battery->voltage_now *
+			acpi_battery_vscale(battery)/1000):1;
+	seq_printf(seq, "present rate:            %d%s\n", rate,
+		   acpi_battery_units(battery));
+	seq_printf(seq, "remaining capacity:      %i%sh\n",
 		   battery->capacity_now * acpi_battery_scale(battery),
 		   acpi_battery_units(battery));
 	seq_printf(seq, "present voltage:         %i mV\n",
@@ -614,7 +611,7 @@ static int acpi_battery_read_state(struc
 
       end:
 	mutex_unlock(&sbs->lock);
-	return result;
+	return 0;
 }
 
 static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
@@ -638,7 +635,7 @@ static int acpi_battery_read_alarm(struc
 	acpi_battery_get_alarm(battery);
 	seq_printf(seq, "alarm:                   ");
 	if (battery->alarm_capacity)
-		seq_printf(seq, "%i%s\n",
+		seq_printf(seq, "%i%sh\n",
 			   battery->alarm_capacity *
 			   acpi_battery_scale(battery),
 			   acpi_battery_units(battery));
--- a/drivers/acpi/sbshc.c	2007-12-17 16:34:07.000000000 -0500
+++ b/drivers/acpi/sbshc.c	2007-12-17 16:34:57.000000000 -0500
@@ -202,10 +202,9 @@ int acpi_smbus_unregister_callback(struc
 
 EXPORT_SYMBOL_GPL(acpi_smbus_unregister_callback);
 
-static void acpi_smbus_callback(void *context)
+static inline void acpi_smbus_callback(void *context)
 {
 	struct acpi_smb_hc *hc = context;
-
 	if (hc->callback)
 		hc->callback(hc->context);
 }
@@ -214,6 +213,7 @@ static int smbus_alarm(void *context)
 {
 	struct acpi_smb_hc *hc = context;
 	union acpi_smb_status status;
+	u8 address;
 	if (smb_hc_read(hc, ACPI_SMB_STATUS, &status.raw))
 		return 0;
 	/* Check if it is only a completion notify */
@@ -222,9 +222,18 @@ static int smbus_alarm(void *context)
 	if (!status.fields.alarm)
 		return 0;
 	mutex_lock(&hc->lock);
+	smb_hc_read(hc, ACPI_SMB_ALARM_ADDRESS, &address);
+	status.fields.alarm = 0;
 	smb_hc_write(hc, ACPI_SMB_STATUS, status.raw);
-	if (hc->callback)
-		acpi_os_execute(OSL_GPE_HANDLER, acpi_smbus_callback, hc);
+	/* We are only interested in events coming from known devices */
+	switch (address >> 1) {
+		case ACPI_SBS_CHARGER:
+		case ACPI_SBS_MANAGER:
+		case ACPI_SBS_BATTERY:
+			acpi_os_execute(OSL_GPE_HANDLER,
+					acpi_smbus_callback, hc);
+		default:;
+	}
 	mutex_unlock(&hc->lock);
 	return 0;
 }
--- a/drivers/acpi/sbshc.h	2007-12-17 16:34:07.000000000 -0500
+++ b/drivers/acpi/sbshc.h	2007-12-17 16:34:57.000000000 -0500
@@ -16,6 +16,12 @@ enum acpi_smb_protocol {
 
 static const u8 SMBUS_PEC = 0x80;
 
+enum acpi_sbs_device_addr {
+	ACPI_SBS_CHARGER = 0x9,
+	ACPI_SBS_MANAGER = 0xa,
+	ACPI_SBS_BATTERY = 0xb,
+};
+
 typedef void (*smbus_alarm_callback)(void *context);
 
 extern int acpi_smbus_read(struct acpi_smb_hc *hc, u8 protocol, u8 address,
--- a/drivers/acpi/video.c	2007-12-17 16:34:07.000000000 -0500
+++ b/drivers/acpi/video.c	2007-12-17 16:34:57.000000000 -0500
@@ -577,7 +577,7 @@ static void acpi_video_device_find_cap(s
 	struct acpi_video_device_brightness *br = NULL;
 
 
-	memset(&device->cap, 0, 4);
+	memset(&device->cap, 0, sizeof(device->cap));
 
 	if (ACPI_SUCCESS(acpi_get_handle(device->dev->handle, "_ADR", &h_dummy1))) {
 		device->cap._ADR = 1;
@@ -697,7 +697,7 @@ static void acpi_video_bus_find_cap(stru
 {
 	acpi_handle h_dummy1;
 
-	memset(&video->cap, 0, 4);
+	memset(&video->cap, 0, sizeof(video->cap));
 	if (ACPI_SUCCESS(acpi_get_handle(video->device->handle, "_DOS", &h_dummy1))) {
 		video->cap._DOS = 1;
 	}
--- a/drivers/atm/fore200e.c	2007-10-10 17:43:38.000000000 -0400
+++ b/drivers/atm/fore200e.c	2007-12-17 16:34:57.000000000 -0500
@@ -2689,7 +2689,7 @@ fore200e_init(struct fore200e* fore200e)
     return 0;
 }
 
-
+#ifdef CONFIG_ATM_FORE200E_PCA
 static int __devinit
 fore200e_pca_detect(struct pci_dev *pci_dev, const struct pci_device_id *pci_ent)
 {
@@ -2756,7 +2756,6 @@ static void __devexit fore200e_pca_remov
 }
 
 
-#ifdef CONFIG_ATM_FORE200E_PCA
 static struct pci_device_id fore200e_pca_tbl[] = {
     { PCI_VENDOR_ID_FORE, PCI_DEVICE_ID_FORE_PCA200E, PCI_ANY_ID, PCI_ANY_ID,
       0, 0, (unsigned long) &fore200e_bus[0] },
--- a/drivers/char/ipmi/ipmi_watchdog.c	2007-12-17 16:34:07.000000000 -0500
+++ b/drivers/char/ipmi/ipmi_watchdog.c	2007-12-17 16:34:57.000000000 -0500
@@ -669,6 +669,7 @@ static int ipmi_ioctl(struct inode *inod
 		return 0;
 
 	case WDIOC_SET_PRETIMEOUT:
+	case WDIOC_SETPRETIMEOUT:
 		i = copy_from_user(&val, argp, sizeof(int));
 		if (i)
 			return -EFAULT;
@@ -676,6 +677,7 @@ static int ipmi_ioctl(struct inode *inod
 		return ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);
 
 	case WDIOC_GET_PRETIMEOUT:
+	case WDIOC_GETPRETIMEOUT:
 		i = copy_to_user(argp, &pretimeout, sizeof(pretimeout));
 		if (i)
 			return -EFAULT;
--- a/drivers/i2c/busses/i2c-davinci.c	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/i2c/busses/i2c-davinci.c	2007-12-17 16:34:57.000000000 -0500
@@ -404,7 +404,7 @@ static irqreturn_t i2c_davinci_isr(int t
 						      DAVINCI_I2C_STR_REG,
 						      w);
 			} else
-				dev_err(dev->dev, "RDR IRQ while no"
+				dev_err(dev->dev, "RDR IRQ while no "
 					"data requested\n");
 			break;
 
@@ -423,7 +423,7 @@ static irqreturn_t i2c_davinci_isr(int t
 						      DAVINCI_I2C_IMR_REG,
 						      w);
 			} else
-				dev_err(dev->dev, "TDR IRQ while no data to"
+				dev_err(dev->dev, "TDR IRQ while no data to "
 					"send\n");
 			break;
 
--- a/drivers/i2c/busses/i2c-gpio.c	2007-10-10 17:43:39.000000000 -0400
+++ b/drivers/i2c/busses/i2c-gpio.c	2007-12-17 16:34:57.000000000 -0500
@@ -140,6 +140,7 @@ static int __init i2c_gpio_probe(struct 
 	adap->owner = THIS_MODULE;
 	snprintf(adap->name, sizeof(adap->name), "i2c-gpio%d", pdev->id);
 	adap->algo_data = bit_data;
+	adap->class = I2C_CLASS_HWMON;
 	adap->dev.parent = &pdev->dev;
 
 	/*
--- a/drivers/i2c/busses/i2c-omap.c	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/i2c/busses/i2c-omap.c	2007-12-17 16:34:57.000000000 -0500
@@ -203,7 +203,7 @@ static int omap_i2c_init(struct omap_i2c
 		while (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &
 			 OMAP_I2C_SYSS_RDONE)) {
 			if (time_after(jiffies, timeout)) {
-				dev_warn(dev->dev, "timeout waiting"
+				dev_warn(dev->dev, "timeout waiting "
 						"for controller reset\n");
 				return -ETIMEDOUT;
 			}
@@ -483,7 +483,7 @@ omap_i2c_isr(int this_irq, void *dev_id)
 					dev->buf_len--;
 				}
 			} else
-				dev_err(dev->dev, "RRDY IRQ while no data"
+				dev_err(dev->dev, "RRDY IRQ while no data "
 						"requested\n");
 			omap_i2c_ack_stat(dev, OMAP_I2C_STAT_RRDY);
 			continue;
@@ -498,7 +498,7 @@ omap_i2c_isr(int this_irq, void *dev_id)
 					dev->buf_len--;
 				}
 			} else
-				dev_err(dev->dev, "XRDY IRQ while no"
+				dev_err(dev->dev, "XRDY IRQ while no "
 					"data to send\n");
 			omap_i2c_write_reg(dev, OMAP_I2C_DATA_REG, w);
 			omap_i2c_ack_stat(dev, OMAP_I2C_STAT_XRDY);
--- a/drivers/i2c/chips/isp1301_omap.c	2007-10-10 17:43:39.000000000 -0400
+++ b/drivers/i2c/chips/isp1301_omap.c	2007-12-17 16:34:57.000000000 -0500
@@ -26,7 +26,7 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/usb/ch9.h>
-#include <linux/usb_gadget.h>
+#include <linux/usb/gadget.h>
 #include <linux/usb.h>
 #include <linux/usb/otg.h>
 #include <linux/i2c.h>
--- a/drivers/infiniband/hw/ehca/ehca_classes.h	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/infiniband/hw/ehca/ehca_classes.h	2007-12-17 16:34:57.000000000 -0500
@@ -322,6 +322,7 @@ extern int ehca_static_rate;
 extern int ehca_port_act_time;
 extern int ehca_use_hp_mr;
 extern int ehca_scaling_code;
+extern int ehca_lock_hcalls;
 
 struct ipzu_queue_resp {
 	u32 qe_size;      /* queue entry size */
--- a/drivers/infiniband/hw/ehca/ehca_main.c	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/infiniband/hw/ehca/ehca_main.c	2007-12-17 16:34:57.000000000 -0500
@@ -43,13 +43,14 @@
 #ifdef CONFIG_PPC_64K_PAGES
 #include <linux/slab.h>
 #endif
+
 #include "ehca_classes.h"
 #include "ehca_iverbs.h"
 #include "ehca_mrmw.h"
 #include "ehca_tools.h"
 #include "hcp_if.h"
 
-#define HCAD_VERSION "0024"
+#define HCAD_VERSION "0025"
 
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Christoph Raisch <raisch@de.ibm.com>");
@@ -66,6 +67,7 @@ int ehca_poll_all_eqs  = 1;
 int ehca_static_rate   = -1;
 int ehca_scaling_code  = 0;
 int ehca_mr_largepage  = 1;
+int ehca_lock_hcalls   = -1;
 
 module_param_named(open_aqp1,     ehca_open_aqp1,     int, S_IRUGO);
 module_param_named(debug_level,   ehca_debug_level,   int, S_IRUGO);
@@ -77,6 +79,7 @@ module_param_named(poll_all_eqs,  ehca_p
 module_param_named(static_rate,   ehca_static_rate,   int, S_IRUGO);
 module_param_named(scaling_code,  ehca_scaling_code,  int, S_IRUGO);
 module_param_named(mr_largepage,  ehca_mr_largepage,  int, S_IRUGO);
+module_param_named(lock_hcalls,   ehca_lock_hcalls,   bool, S_IRUGO);
 
 MODULE_PARM_DESC(open_aqp1,
 		 "AQP1 on startup (0: no (default), 1: yes)");
@@ -102,6 +105,9 @@ MODULE_PARM_DESC(scaling_code,
 MODULE_PARM_DESC(mr_largepage,
 		 "use large page for MR (0: use PAGE_SIZE (default), "
 		 "1: use large page depending on MR size");
+MODULE_PARM_DESC(lock_hcalls,
+		 "serialize all hCalls made by the driver "
+		 "(default: autodetect)");
 
 DEFINE_RWLOCK(ehca_qp_idr_lock);
 DEFINE_RWLOCK(ehca_cq_idr_lock);
@@ -258,6 +264,7 @@ static struct cap_descr {
 	{ HCA_CAP_UD_LL_QP, "HCA_CAP_UD_LL_QP" },
 	{ HCA_CAP_RESIZE_MR, "HCA_CAP_RESIZE_MR" },
 	{ HCA_CAP_MINI_QP, "HCA_CAP_MINI_QP" },
+	{ HCA_CAP_H_ALLOC_RES_SYNC, "HCA_CAP_H_ALLOC_RES_SYNC" },
 };
 
 static int ehca_sense_attributes(struct ehca_shca *shca)
@@ -333,6 +340,12 @@ static int ehca_sense_attributes(struct 
 		if (EHCA_BMASK_GET(hca_cap_descr[i].mask, shca->hca_cap))
 			ehca_gen_dbg("   %s", hca_cap_descr[i].descr);
 
+	/* Autodetect hCall locking -- the "H_ALLOC_RESOURCE synced" flag is
+	 * a firmware property, so it's valid across all adapters
+	 */
+	if (ehca_lock_hcalls == -1)
+		ehca_lock_hcalls = !(shca->hca_cap & HCA_CAP_H_ALLOC_RES_SYNC);
+
 	/* translate supported MR page sizes; always support 4K */
 	shca->hca_cap_mr_pgsize = EHCA_PAGESIZE;
 	if (ehca_mr_largepage) { /* support extra sizes only if enabled */
--- a/drivers/infiniband/hw/ehca/ehca_qp.c	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/infiniband/hw/ehca/ehca_qp.c	2007-12-17 16:34:57.000000000 -0500
@@ -838,7 +838,7 @@ struct ib_srq *ehca_create_srq(struct ib
 
 	/* copy back return values */
 	srq_init_attr->attr.max_wr = qp_init_attr.cap.max_recv_wr;
-	srq_init_attr->attr.max_sge = qp_init_attr.cap.max_recv_sge;
+	srq_init_attr->attr.max_sge = 3;
 
 	/* drive SRQ into RTR state */
 	mqpcb = ehca_alloc_fw_ctrlblock(GFP_KERNEL);
@@ -1750,7 +1750,7 @@ int ehca_query_srq(struct ib_srq *srq, s
 	}
 
 	srq_attr->max_wr = qpcb->max_nr_outst_recv_wr - 1;
-	srq_attr->max_sge = qpcb->actual_nr_sges_in_rq_wqe;
+	srq_attr->max_sge = 3;
 	srq_attr->srq_limit = EHCA_BMASK_GET(
 		MQPCB_CURR_SRQ_LIMIT, qpcb->curr_srq_limit);
 
--- a/drivers/infiniband/hw/ehca/hcp_if.c	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/infiniband/hw/ehca/hcp_if.c	2007-12-17 16:34:57.000000000 -0500
@@ -120,26 +120,21 @@ static long ehca_plpar_hcall_norets(unsi
 				    unsigned long arg7)
 {
 	long ret;
-	int i, sleep_msecs, do_lock;
-	unsigned long flags;
+	int i, sleep_msecs;
+	unsigned long flags = 0;
 
 	ehca_gen_dbg("opcode=%lx " HCALL7_REGS_FORMAT,
 		     opcode, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
 
-	/* lock H_FREE_RESOURCE(MR) against itself and H_ALLOC_RESOURCE(MR) */
-	if ((opcode == H_FREE_RESOURCE) && (arg7 == 5)) {
-		arg7 = 0; /* better not upset firmware */
-		do_lock = 1;
-	}
-
 	for (i = 0; i < 5; i++) {
-		if (do_lock)
+		/* serialize hCalls to work around firmware issue */
+		if (ehca_lock_hcalls)
 			spin_lock_irqsave(&hcall_lock, flags);
 
 		ret = plpar_hcall_norets(opcode, arg1, arg2, arg3, arg4,
 					 arg5, arg6, arg7);
 
-		if (do_lock)
+		if (ehca_lock_hcalls)
 			spin_unlock_irqrestore(&hcall_lock, flags);
 
 		if (H_IS_LONG_BUSY(ret)) {
@@ -174,24 +169,22 @@ static long ehca_plpar_hcall9(unsigned l
 			      unsigned long arg9)
 {
 	long ret;
-	int i, sleep_msecs, do_lock;
+	int i, sleep_msecs;
 	unsigned long flags = 0;
 
 	ehca_gen_dbg("INPUT -- opcode=%lx " HCALL9_REGS_FORMAT, opcode,
 		     arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
 
-	/* lock H_ALLOC_RESOURCE(MR) against itself and H_FREE_RESOURCE(MR) */
-	do_lock = ((opcode == H_ALLOC_RESOURCE) && (arg2 == 5));
-
 	for (i = 0; i < 5; i++) {
-		if (do_lock)
+		/* serialize hCalls to work around firmware issue */
+		if (ehca_lock_hcalls)
 			spin_lock_irqsave(&hcall_lock, flags);
 
 		ret = plpar_hcall9(opcode, outs,
 				   arg1, arg2, arg3, arg4, arg5,
 				   arg6, arg7, arg8, arg9);
 
-		if (do_lock)
+		if (ehca_lock_hcalls)
 			spin_unlock_irqrestore(&hcall_lock, flags);
 
 		if (H_IS_LONG_BUSY(ret)) {
@@ -821,7 +814,7 @@ u64 hipz_h_free_resource_mr(const struct
 	return ehca_plpar_hcall_norets(H_FREE_RESOURCE,
 				       adapter_handle.handle,    /* r4 */
 				       mr->ipz_mr_handle.handle, /* r5 */
-				       0, 0, 0, 0, 5);
+				       0, 0, 0, 0, 0);
 }
 
 u64 hipz_h_reregister_pmr(const struct ipz_adapter_handle adapter_handle,
--- a/drivers/infiniband/hw/ehca/hipz_hw.h	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/infiniband/hw/ehca/hipz_hw.h	2007-12-17 16:34:57.000000000 -0500
@@ -378,6 +378,7 @@ struct hipz_query_hca {
 #define HCA_CAP_UD_LL_QP              EHCA_BMASK_IBM(16, 16)
 #define HCA_CAP_RESIZE_MR             EHCA_BMASK_IBM(17, 17)
 #define HCA_CAP_MINI_QP               EHCA_BMASK_IBM(18, 18)
+#define HCA_CAP_H_ALLOC_RES_SYNC      EHCA_BMASK_IBM(19, 19)
 
 /* query port response block */
 struct hipz_query_port {
--- a/drivers/media/dvb/frontends/s5h1409.c	2007-12-17 16:34:08.000000000 -0500
+++ b/drivers/media/dvb/frontends/s5h1409.c	2007-12-17 16:34:57.000000000 -0500
@@ -107,7 +107,7 @@ static struct vsb_snr_tab {
 	u16	val;
 	u16	data;
 } vsb_snr_tab[] = {
-	{ 1023, 770, },
+	{  924, 300, },
 	{  923, 300, },
 	{  918, 295, },
 	{  915, 290, },
@@ -154,6 +154,7 @@ static struct qam64_snr_tab {
 	u16	val;
 	u16	data;
 } qam64_snr_tab[] = {
+	{    1,   0, },
 	{   12, 300, },
 	{   15, 290, },
 	{   18, 280, },
@@ -217,6 +218,7 @@ static struct qam64_snr_tab {
 	{   95, 202, },
 	{   96, 201, },
 	{  104, 200, },
+	{  255,   0, },
 };
 
 /* QAM256 SNR lookup table */
@@ -224,6 +226,7 @@ static struct qam256_snr_tab {
 	u16	val;
 	u16	data;
 } qam256_snr_tab[] = {
+	{    1,   0, },
 	{   12, 400, },
 	{   13, 390, },
 	{   15, 380, },
@@ -292,6 +295,7 @@ static struct qam256_snr_tab {
 	{  105, 262, },
 	{  106, 261, },
 	{  110, 260, },
+	{  255,   0, },
 };
 
 /* 8 bit registers, 16 bit values */
@@ -670,14 +674,15 @@ static int s5h1409_read_snr(struct dvb_f
 	u16 reg;
 	dprintk("%s()\n", __FUNCTION__);
 
-	reg = s5h1409_readreg(state, 0xf1) & 0x1ff;
-
 	switch(state->current_modulation) {
 	case QAM_64:
+		reg = s5h1409_readreg(state, 0xf0) & 0xff;
 		return s5h1409_qam64_lookup_snr(fe, snr, reg);
 	case QAM_256:
+		reg = s5h1409_readreg(state, 0xf0) & 0xff;
 		return s5h1409_qam256_lookup_snr(fe, snr, reg);
 	case VSB_8:
+		reg = s5h1409_readreg(state, 0xf1) & 0x3ff;
 		return s5h1409_vsb_lookup_snr(fe, snr, reg);
 	default:
 		break;
--- a/drivers/media/Makefile	2007-07-08 19:32:17.000000000 -0400
+++ b/drivers/media/Makefile	2007-12-17 16:34:57.000000000 -0500
@@ -3,6 +3,6 @@
 #
 
 obj-y := common/
-obj-$(CONFIG_VIDEO_DEV) += video/
+obj-y += video/
 obj-$(CONFIG_VIDEO_DEV) += radio/
 obj-$(CONFIG_DVB_CORE)  += dvb/
--- a/drivers/media/video/bt866.c	2007-10-10 17:43:39.000000000 -0400
+++ b/drivers/media/video/bt866.c	2007-12-17 16:34:57.000000000 -0500
@@ -300,7 +300,6 @@ static struct i2c_client bt866_client_tm
 	.addr = 0,
 	.adapter = NULL,
 	.driver = &i2c_driver_bt866,
-	.usage_count = 0
 };
 
 static int bt866_found_proc(struct i2c_adapter *adapter,
--- a/drivers/media/video/saa7134/saa7134-cards.c	2007-12-17 16:34:45.000000000 -0500
+++ b/drivers/media/video/saa7134/saa7134-cards.c	2007-12-17 16:34:57.000000000 -0500
@@ -3221,6 +3221,7 @@ struct saa7134_board saa7134_boards[] = 
 		.radio_type     = UNSET,
 		.tuner_addr     = ADDR_UNSET,
 		.radio_addr     = ADDR_UNSET,
+		.tuner_config   = 1,
 		.mpeg           = SAA7134_MPEG_DVB,
 		.inputs         = {{
 			.name = name_tv,
--- a/drivers/media/video/videobuf-core.c	2007-12-17 16:34:45.000000000 -0500
+++ b/drivers/media/video/videobuf-core.c	2007-12-17 16:34:57.000000000 -0500
@@ -806,7 +806,7 @@ ssize_t videobuf_read_one(struct videobu
 }
 
 /* Locking: Caller holds q->lock */
-int videobuf_read_start(struct videobuf_queue *q)
+int __videobuf_read_start(struct videobuf_queue *q)
 {
 	enum v4l2_field field;
 	unsigned long flags=0;
@@ -862,6 +862,17 @@ static void __videobuf_read_stop(struct 
 	
 }
 
+int videobuf_read_start(struct videobuf_queue *q)
+{
+	int rc;
+
+	mutex_lock(&q->lock);
+	rc = __videobuf_read_start(q);
+	mutex_unlock(&q->lock);
+
+	return rc;
+}
+
 void videobuf_read_stop(struct videobuf_queue *q)
 {
 	mutex_lock(&q->lock);
@@ -898,7 +909,7 @@ ssize_t videobuf_read_stream(struct vide
 	if (q->streaming)
 		goto done;
 	if (!q->reading) {
-		retval = videobuf_read_start(q);
+		retval = __videobuf_read_start(q);
 		if (retval < 0)
 			goto done;
 	}
@@ -971,7 +982,7 @@ unsigned int videobuf_poll_stream(struct
 					 struct videobuf_buffer, stream);
 	} else {
 		if (!q->reading)
-			videobuf_read_start(q);
+			__videobuf_read_start(q);
 		if (!q->reading) {
 			rc = POLLERR;
 		} else if (NULL == q->read_buf) {
@@ -1058,6 +1069,7 @@ EXPORT_SYMBOL_GPL(videobuf_dqbuf);
 EXPORT_SYMBOL_GPL(videobuf_streamon);
 EXPORT_SYMBOL_GPL(videobuf_streamoff);
 
+EXPORT_SYMBOL_GPL(videobuf_read_start);
 EXPORT_SYMBOL_GPL(videobuf_read_stop);
 EXPORT_SYMBOL_GPL(videobuf_stop);
 EXPORT_SYMBOL_GPL(videobuf_read_stream);
--- a/drivers/misc/thinkpad_acpi.c	2007-12-17 16:34:09.000000000 -0500
+++ b/drivers/misc/thinkpad_acpi.c	2007-12-17 16:34:57.000000000 -0500
@@ -987,9 +987,9 @@ static int __init hotkey_init(struct ibm
 		KEY_UNKNOWN,	/* 0x0C: FN+BACKSPACE */
 		KEY_UNKNOWN,	/* 0x0D: FN+INSERT */
 		KEY_UNKNOWN,	/* 0x0E: FN+DELETE */
-		KEY_BRIGHTNESSUP,	/* 0x0F: FN+HOME (brightness up) */
+		KEY_RESERVED,	/* 0x0F: FN+HOME (brightness up) */
 		/* Scan codes 0x10 to 0x1F: Extended ACPI HKEY hot keys */
-		KEY_BRIGHTNESSDOWN,	/* 0x10: FN+END (brightness down) */
+		KEY_RESERVED,	/* 0x10: FN+END (brightness down) */
 		KEY_RESERVED,	/* 0x11: FN+PGUP (thinklight toggle) */
 		KEY_UNKNOWN,	/* 0x12: FN+PGDOWN */
 		KEY_ZOOM,	/* 0x13: FN+SPACE (zoom) */
--- a/drivers/net/fs_enet/mac-scc.c	2007-12-17 16:34:09.000000000 -0500
+++ b/drivers/net/fs_enet/mac-scc.c	2007-12-17 16:34:58.000000000 -0500
@@ -158,7 +158,7 @@ static int setup_data(struct net_device 
 {
 	struct fs_enet_private *fep = netdev_priv(dev);
 
-#ifdef CONFIG_PPC_CPM_NEW_BINDING
+#ifndef CONFIG_PPC_CPM_NEW_BINDING
 	struct fs_platform_info *fpi = fep->fpi;
 
 	fep->scc.idx = fs_get_scc_index(fpi->fs_no);
--- a/drivers/net/irda/irda-usb.c	2007-12-17 16:34:09.000000000 -0500
+++ b/drivers/net/irda/irda-usb.c	2007-12-17 16:34:58.000000000 -0500
@@ -1168,6 +1168,7 @@ static int stir421x_patch_device(struct 
 static int irda_usb_net_open(struct net_device *netdev)
 {
 	struct irda_usb_cb *self;
+	unsigned long flags;
 	char	hwname[16];
 	int i;
 	
@@ -1177,13 +1178,16 @@ static int irda_usb_net_open(struct net_
 	self = (struct irda_usb_cb *) netdev->priv;
 	IRDA_ASSERT(self != NULL, return -1;);
 
+	spin_lock_irqsave(&self->lock, flags);
 	/* Can only open the device if it's there */
 	if(!self->present) {
+		spin_unlock_irqrestore(&self->lock, flags);
 		IRDA_WARNING("%s(), device not present!\n", __FUNCTION__);
 		return -1;
 	}
 
 	if(self->needspatch) {
+		spin_unlock_irqrestore(&self->lock, flags);
 		IRDA_WARNING("%s(), device needs patch\n", __FUNCTION__) ;
 		return -EIO ;
 	}
@@ -1198,6 +1202,7 @@ static int irda_usb_net_open(struct net_
 	/* To do *before* submitting Rx urbs and starting net Tx queue
 	 * Jean II */
 	self->netopen = 1;
+	spin_unlock_irqrestore(&self->lock, flags);
 
 	/* 
 	 * Now that everything should be initialized properly,
--- a/drivers/net/irda/mcs7780.c	2007-12-17 16:34:09.000000000 -0500
+++ b/drivers/net/irda/mcs7780.c	2007-12-17 16:34:58.000000000 -0500
@@ -677,6 +677,8 @@ static int mcs_net_close(struct net_devi
 	/* Stop transmit processing */
 	netif_stop_queue(netdev);
 
+	kfree_skb(mcs->rx_buff.skb);
+
 	/* kill and free the receive and transmit URBs */
 	usb_kill_urb(mcs->rx_urb);
 	usb_free_urb(mcs->rx_urb);
--- a/drivers/net/irda/stir4200.c	2007-12-17 16:34:09.000000000 -0500
+++ b/drivers/net/irda/stir4200.c	2007-12-17 16:34:58.000000000 -0500
@@ -142,9 +142,6 @@ enum StirCtrl2Mask {
 };
 
 enum StirFifoCtlMask {
-	FIFOCTL_EOF = 0x80,
-	FIFOCTL_UNDER = 0x40,
-	FIFOCTL_OVER = 0x20,
 	FIFOCTL_DIR = 0x10,
 	FIFOCTL_CLR = 0x08,
 	FIFOCTL_EMPTY = 0x04,
@@ -594,9 +591,10 @@ static int fifo_txwait(struct stir_cb *s
 {
 	int err;
 	unsigned long count, status;
+	unsigned long prev_count = 0x1fff;
 
 	/* Read FIFO status and count */
-	for(;;) {
+	for (;; prev_count = count) {
 		err = read_reg(stir, REG_FIFOCTL, stir->fifo_status, 
 				   FIFO_REGS_SIZE);
 		if (unlikely(err != FIFO_REGS_SIZE)) {
@@ -629,6 +627,10 @@ static int fifo_txwait(struct stir_cb *s
 		if (space >= 0 && STIR_FIFO_SIZE - 4 > space + count)
 			return 0;
 
+		/* queue confused */
+		if (prev_count < count)
+			break;
+
 		/* estimate transfer time for remaining chars */
 		msleep((count * 8000) / stir->speed);
 	}
--- a/drivers/net/wan/syncppp.c	2007-12-17 16:34:10.000000000 -0500
+++ b/drivers/net/wan/syncppp.c	2007-12-17 16:34:58.000000000 -0500
@@ -107,24 +107,24 @@
 struct ppp_header {
 	u8 address;
 	u8 control;
-	u16 protocol;
+	__be16 protocol;
 };
 #define PPP_HEADER_LEN          sizeof (struct ppp_header)
 
 struct lcp_header {
 	u8 type;
 	u8 ident;
-	u16 len;
+	__be16 len;
 };
 #define LCP_HEADER_LEN          sizeof (struct lcp_header)
 
 struct cisco_packet {
-	u32 type;
-	u32 par1;
-	u32 par2;
-	u16 rel;
-	u16 time0;
-	u16 time1;
+	__be32 type;
+	__be32 par1;
+	__be32 par2;
+	__be16 rel;
+	__be16 time0;
+	__be16 time1;
 };
 #define CISCO_PACKET_LEN 18
 #define CISCO_BIG_PACKET_LEN 20
@@ -139,7 +139,7 @@ static struct sk_buff_head tx_queue;
 static void sppp_keepalive (unsigned long dummy);
 static void sppp_cp_send (struct sppp *sp, u16 proto, u8 type,
 	u8 ident, u16 len, void *data);
-static void sppp_cisco_send (struct sppp *sp, int type, long par1, long par2);
+static void sppp_cisco_send (struct sppp *sp, int type, u32 par1, u32 par2);
 static void sppp_lcp_input (struct sppp *sp, struct sk_buff *m);
 static void sppp_cisco_input (struct sppp *sp, struct sk_buff *m);
 static void sppp_ipcp_input (struct sppp *sp, struct sk_buff *m);
@@ -447,7 +447,7 @@ static void sppp_keepalive (unsigned lon
 			sppp_cisco_send (sp, CISCO_KEEPALIVE_REQ, ++sp->pp_seq,
 				sp->pp_rseq);
 		else if (sp->lcp.state == LCP_STATE_OPENED) {
-			long nmagic = htonl (sp->lcp.magic);
+			__be32 nmagic = htonl (sp->lcp.magic);
 			sp->lcp.echoid = ++sp->pp_seq;
 			sppp_cp_send (sp, PPP_LCP, LCP_ECHO_REQ,
 				sp->lcp.echoid, 4, &nmagic);
@@ -667,7 +667,7 @@ badreq:
 					dev->name, len);
 			break;
 		}
-		if (ntohl (*(long*)(h+1)) == sp->lcp.magic) {
+		if (ntohl (*(__be32*)(h+1)) == sp->lcp.magic) {
 			/* Line loopback mode detected. */
 			printk (KERN_WARNING "%s: loopback\n", dev->name);
 			if_down (dev);
@@ -680,7 +680,7 @@ badreq:
 			sppp_lcp_open (sp);
 			break;
 		}
-		*(long*)(h+1) = htonl (sp->lcp.magic);
+		*(__be32 *)(h+1) = htonl (sp->lcp.magic);
 		sppp_cp_send (sp, PPP_LCP, LCP_ECHO_REPLY, h->ident, len-4, h+1);
 		break;
 	case LCP_ECHO_REPLY:
@@ -692,7 +692,7 @@ badreq:
 					dev->name, len);
 			break;
 		}
-		if (ntohl (*(long*)(h+1)) != sp->lcp.magic)
+		if (ntohl(*(__be32 *)(h+1)) != sp->lcp.magic)
 		sp->pp_alivecnt = 0;
 		break;
 	}
@@ -765,7 +765,7 @@ static void sppp_cisco_input (struct spp
 		{
 		struct in_device *in_dev;
 		struct in_ifaddr *ifa;
-		__be32 addr = 0, mask = ~0; /* FIXME: is the mask correct? */
+		__be32 addr = 0, mask = htonl(~0U); /* FIXME: is the mask correct? */
 #ifdef CONFIG_INET
 		rcu_read_lock();
 		if ((in_dev = __in_dev_get_rcu(dev)) != NULL)
@@ -782,8 +782,7 @@ static void sppp_cisco_input (struct spp
 		}
 		rcu_read_unlock();
 #endif		
-		/* I hope both addr and mask are in the net order */
-		sppp_cisco_send (sp, CISCO_ADDR_REPLY, addr, mask);
+		sppp_cisco_send (sp, CISCO_ADDR_REPLY, ntohl(addr), ntohl(mask));
 		break;
 		}
 	}
@@ -844,7 +843,7 @@ static void sppp_cp_send (struct sppp *s
  * Send Cisco keepalive packet.
  */
 
-static void sppp_cisco_send (struct sppp *sp, int type, long par1, long par2)
+static void sppp_cisco_send (struct sppp *sp, int type, u32 par1, u32 par2)
 {
 	struct ppp_header *h;
 	struct cisco_packet *ch;
@@ -868,7 +867,7 @@ static void sppp_cisco_send (struct sppp
 	ch->type = htonl (type);
 	ch->par1 = htonl (par1);
 	ch->par2 = htonl (par2);
-	ch->rel = -1;
+	ch->rel = htons(0xffff);
 	ch->time0 = htons ((u16) (t >> 16));
 	ch->time1 = htons ((u16) t);
 
--- a/drivers/sbus/char/cpwatchdog.c	2007-10-10 17:43:45.000000000 -0400
+++ b/drivers/sbus/char/cpwatchdog.c	2007-12-17 16:34:58.000000000 -0500
@@ -154,7 +154,7 @@ struct wd_device {
 };
 
 static struct wd_device wd_dev = { 
-		0, SPIN_LOCK_UNLOCKED, 0, 0, 0, 0,
+		0, __SPIN_LOCK_UNLOCKED(wd_dev.lock), 0, 0, 0, 0,
 };
 
 static struct timer_list wd_timer;
--- a/drivers/serial/suncore.c	2007-10-10 17:43:45.000000000 -0400
+++ b/drivers/serial/suncore.c	2007-12-17 16:34:58.000000000 -0500
@@ -23,11 +23,36 @@
 
 #include "suncore.h"
 
-int sunserial_current_minor = 64;
+static int sunserial_current_minor = 64;
 
-EXPORT_SYMBOL(sunserial_current_minor);
+int sunserial_register_minors(struct uart_driver *drv, int count)
+{
+	int err = 0;
 
-int sunserial_console_match(struct console *con, struct device_node *dp,
+	drv->minor = sunserial_current_minor;
+	drv->nr += count;
+	/* Register the driver on the first call */
+	if (drv->nr == count)
+		err = uart_register_driver(drv);
+	if (err == 0) {
+		sunserial_current_minor += count;
+		drv->tty_driver->name_base = drv->minor - 64;
+	}
+	return err;
+}
+EXPORT_SYMBOL(sunserial_register_minors);
+
+void sunserial_unregister_minors(struct uart_driver *drv, int count)
+{
+	drv->nr -= count;
+	sunserial_current_minor -= count;
+
+	if (drv->nr == 0)
+		uart_unregister_driver(drv);
+}
+EXPORT_SYMBOL(sunserial_unregister_minors);
+
+int __init sunserial_console_match(struct console *con, struct device_node *dp,
 			    struct uart_driver *drv, int line)
 {
 	int off;
@@ -133,8 +158,6 @@ sunserial_console_termios(struct console
 	con->cflag = cflag;
 }
 
-EXPORT_SYMBOL(sunserial_console_termios);
-
 /* Sun serial MOUSE auto baud rate detection.  */
 static struct mouse_baud_cflag {
 	int baud;
--- a/drivers/serial/suncore.h	2007-10-10 17:43:45.000000000 -0400
+++ b/drivers/serial/suncore.h	2007-12-17 16:34:58.000000000 -0500
@@ -22,7 +22,8 @@
 extern unsigned int suncore_mouse_baud_cflag_next(unsigned int, int *);
 extern int suncore_mouse_baud_detection(unsigned char, int);
 
-extern int sunserial_current_minor;
+extern int sunserial_register_minors(struct uart_driver *, int);
+extern void sunserial_unregister_minors(struct uart_driver *, int);
 
 extern int sunserial_console_match(struct console *, struct device_node *,
 				   struct uart_driver *, int);
--- a/drivers/serial/sunhv.c	2007-10-10 17:43:45.000000000 -0400
+++ b/drivers/serial/sunhv.c	2007-12-17 16:34:58.000000000 -0500
@@ -562,16 +562,10 @@ static int __devinit hv_probe(struct of_
 
 	port->dev = &op->dev;
 
-	sunhv_reg.minor = sunserial_current_minor;
-	sunhv_reg.nr = 1;
-
-	err = uart_register_driver(&sunhv_reg);
+	err = sunserial_register_minors(&sunhv_reg, 1);
 	if (err)
 		goto out_free_con_read_page;
 
-	sunhv_reg.tty_driver->name_base = sunhv_reg.minor - 64;
-	sunserial_current_minor += 1;
-
 	sunserial_console_match(&sunhv_console, op->node,
 				&sunhv_reg, port->line);
 
@@ -591,8 +585,7 @@ out_remove_port:
 	uart_remove_one_port(&sunhv_reg, port);
 
 out_unregister_driver:
-	sunserial_current_minor -= 1;
-	uart_unregister_driver(&sunhv_reg);
+	sunserial_unregister_minors(&sunhv_reg, 1);
 
 out_free_con_read_page:
 	kfree(con_read_page);
@@ -614,8 +607,7 @@ static int __devexit hv_remove(struct of
 
 	uart_remove_one_port(&sunhv_reg, port);
 
-	sunserial_current_minor -= 1;
-	uart_unregister_driver(&sunhv_reg);
+	sunserial_unregister_minors(&sunhv_reg, 1);
 
 	kfree(port);
 	sunhv_port = NULL;
--- a/drivers/serial/sunsab.c	2007-10-10 17:43:45.000000000 -0400
+++ b/drivers/serial/sunsab.c	2007-12-17 16:34:58.000000000 -0500
@@ -832,7 +832,6 @@ static struct uart_driver sunsab_reg = {
 };
 
 static struct uart_sunsab_port *sunsab_ports;
-static int num_channels;
 
 #ifdef CONFIG_SERIAL_SUNSAB_CONSOLE
 
@@ -1102,8 +1101,8 @@ static int __init sunsab_init(void)
 {
 	struct device_node *dp;
 	int err;
+	int num_channels = 0;
 
-	num_channels = 0;
 	for_each_node_by_name(dp, "se")
 		num_channels += 2;
 	for_each_node_by_name(dp, "serial") {
@@ -1117,20 +1116,14 @@ static int __init sunsab_init(void)
 		if (!sunsab_ports)
 			return -ENOMEM;
 
-		sunsab_reg.minor = sunserial_current_minor;
-		sunsab_reg.nr = num_channels;
 		sunsab_reg.cons = SUNSAB_CONSOLE();
-
-		err = uart_register_driver(&sunsab_reg);
+		err = sunserial_register_minors(&sunsab_reg, num_channels);
 		if (err) {
 			kfree(sunsab_ports);
 			sunsab_ports = NULL;
 
 			return err;
 		}
-
-		sunsab_reg.tty_driver->name_base = sunsab_reg.minor - 64;
-		sunserial_current_minor += num_channels;
 	}
 
 	return of_register_driver(&sab_driver, &of_bus_type);
@@ -1139,9 +1132,8 @@ static int __init sunsab_init(void)
 static void __exit sunsab_exit(void)
 {
 	of_unregister_driver(&sab_driver);
-	if (num_channels) {
-		sunserial_current_minor -= num_channels;
-		uart_unregister_driver(&sunsab_reg);
+	if (sunsab_reg.nr) {
+		sunserial_unregister_minors(&sunsab_reg, sunsab_reg.nr);
 	}
 
 	kfree(sunsab_ports);
--- a/drivers/serial/sunsu.c	2007-10-10 17:43:45.000000000 -0400
+++ b/drivers/serial/sunsu.c	2007-12-17 16:34:58.000000000 -0500
@@ -1528,14 +1528,12 @@ static struct of_platform_driver su_driv
 	.remove		= __devexit_p(su_remove),
 };
 
-static int num_uart;
-
 static int __init sunsu_init(void)
 {
 	struct device_node *dp;
 	int err;
+	int num_uart = 0;
 
-	num_uart = 0;
 	for_each_node_by_name(dp, "su") {
 		if (su_get_type(dp) == SU_PORT_PORT)
 			num_uart++;
@@ -1552,26 +1550,22 @@ static int __init sunsu_init(void)
 	}
 
 	if (num_uart) {
-		sunsu_reg.minor = sunserial_current_minor;
-		sunsu_reg.nr = num_uart;
-		err = uart_register_driver(&sunsu_reg);
+		err = sunserial_register_minors(&sunsu_reg, num_uart);
 		if (err)
 			return err;
-		sunsu_reg.tty_driver->name_base = sunsu_reg.minor - 64;
-		sunserial_current_minor += num_uart;
 	}
 
 	err = of_register_driver(&su_driver, &of_bus_type);
 	if (err && num_uart)
-		uart_unregister_driver(&sunsu_reg);
+		sunserial_unregister_minors(&sunsu_reg, num_uart);
 
 	return err;
 }
 
 static void __exit sunsu_exit(void)
 {
-	if (num_uart)
-		uart_unregister_driver(&sunsu_reg);
+	if (sunsu_reg.nr)
+		sunserial_unregister_minors(&sunsu_reg, sunsu_reg.nr);
 }
 
 module_init(sunsu_init);
--- a/drivers/serial/sunzilog.c	2007-10-10 17:43:45.000000000 -0400
+++ b/drivers/serial/sunzilog.c	2007-12-17 16:34:58.000000000 -0500
@@ -63,10 +63,6 @@
 	readb(&((__channel)->control))
 #endif
 
-static int num_sunzilog;
-#define NUM_SUNZILOG	num_sunzilog
-#define NUM_CHANNELS	(NUM_SUNZILOG * 2)
-
 #define ZS_CLOCK		4915200 /* Zilog input clock rate. */
 #define ZS_CLOCK_DIVISOR	16      /* Divisor this driver uses. */
 
@@ -1031,18 +1027,19 @@ static struct uart_driver sunzilog_reg =
 	.major		=	TTY_MAJOR,
 };
 
-static int __init sunzilog_alloc_tables(void)
+static int __init sunzilog_alloc_tables(int num_sunzilog)
 {
 	struct uart_sunzilog_port *up;
 	unsigned long size;
+	int num_channels = num_sunzilog * 2;
 	int i;
 
-	size = NUM_CHANNELS * sizeof(struct uart_sunzilog_port);
+	size = num_channels * sizeof(struct uart_sunzilog_port);
 	sunzilog_port_table = kzalloc(size, GFP_KERNEL);
 	if (!sunzilog_port_table)
 		return -ENOMEM;
 
-	for (i = 0; i < NUM_CHANNELS; i++) {
+	for (i = 0; i < num_channels; i++) {
 		up = &sunzilog_port_table[i];
 
 		spin_lock_init(&up->port.lock);
@@ -1050,13 +1047,13 @@ static int __init sunzilog_alloc_tables(
 		if (i == 0)
 			sunzilog_irq_chain = up;
 
-		if (i < NUM_CHANNELS - 1)
+		if (i < num_channels - 1)
 			up->next = up + 1;
 		else
 			up->next = NULL;
 	}
 
-	size = NUM_SUNZILOG * sizeof(struct zilog_layout __iomem *);
+	size = num_sunzilog * sizeof(struct zilog_layout __iomem *);
 	sunzilog_chip_regs = kzalloc(size, GFP_KERNEL);
 	if (!sunzilog_chip_regs) {
 		kfree(sunzilog_port_table);
@@ -1496,34 +1493,28 @@ static int __init sunzilog_init(void)
 	struct device_node *dp;
 	int err, uart_count;
 	int num_keybms;
+	int num_sunzilog = 0;
 
-	NUM_SUNZILOG = 0;
 	num_keybms = 0;
 	for_each_node_by_name(dp, "zs") {
-		NUM_SUNZILOG++;
+		num_sunzilog++;
 		if (of_find_property(dp, "keyboard", NULL))
 			num_keybms++;
 	}
 
 	uart_count = 0;
-	if (NUM_SUNZILOG) {
+	if (num_sunzilog) {
 		int uart_count;
 
-		err = sunzilog_alloc_tables();
+		err = sunzilog_alloc_tables(num_sunzilog);
 		if (err)
 			goto out;
 
-		uart_count = (NUM_SUNZILOG * 2) - (2 * num_keybms);
+		uart_count = (num_sunzilog * 2) - (2 * num_keybms);
 
-		sunzilog_reg.nr = uart_count;
-		sunzilog_reg.minor = sunserial_current_minor;
-		err = uart_register_driver(&sunzilog_reg);
+		err = sunserial_register_minors(&sunzilog_reg, uart_count);
 		if (err)
 			goto out_free_tables;
-
-		sunzilog_reg.tty_driver->name_base = sunzilog_reg.minor - 64;
-
-		sunserial_current_minor += uart_count;
 	}
 
 	err = of_register_driver(&zs_driver, &of_bus_type);
@@ -1557,8 +1548,8 @@ out_unregister_driver:
 	of_unregister_driver(&zs_driver);
 
 out_unregister_uart:
-	if (NUM_SUNZILOG) {
-		uart_unregister_driver(&sunzilog_reg);
+	if (num_sunzilog) {
+		sunserial_unregister_minors(&sunzilog_reg, num_sunzilog);
 		sunzilog_reg.cons = NULL;
 	}
 
@@ -1590,8 +1581,8 @@ static void __exit sunzilog_exit(void)
 		zilog_irq = -1;
 	}
 
-	if (NUM_SUNZILOG) {
-		uart_unregister_driver(&sunzilog_reg);
+	if (sunzilog_reg.nr) {
+		sunserial_unregister_minors(&sunzilog_reg, sunzilog_reg.nr);
 		sunzilog_free_tables();
 	}
 }
--- a/drivers/watchdog/at32ap700x_wdt.c	2007-12-17 16:34:15.000000000 -0500
+++ b/drivers/watchdog/at32ap700x_wdt.c	2007-12-17 16:34:58.000000000 -0500
@@ -6,6 +6,19 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ *
+ * Errata: WDT Clear is blocked after WDT Reset
+ *
+ * A watchdog timer event will, after reset, block writes to the WDT_CLEAR
+ * register, preventing the program to clear the next Watchdog Timer Reset.
+ *
+ * If you still want to use the WDT after a WDT reset a small code can be
+ * insterted at the startup checking the AVR32_PM.rcause register for WDT reset
+ * and use a GPIO pin to reset the system. This method requires that one of the
+ * GPIO pins are available and connected externally to the RESET_N pin. After
+ * the GPIO pin has pulled down the reset line the GPIO will be reset and leave
+ * the pin tristated with pullup.
  */
 
 #include <linux/init.h>
@@ -44,6 +57,13 @@ MODULE_PARM_DESC(nowayout, "Watchdog can
 
 #define WDT_CLR			0x04
 
+#define WDT_RCAUSE		0x10
+#define WDT_RCAUSE_POR		   0
+#define WDT_RCAUSE_EXT		   2
+#define WDT_RCAUSE_WDT		   3
+#define WDT_RCAUSE_JTAG		   4
+#define WDT_RCAUSE_SERP		   5
+
 #define WDT_BIT(name)		(1 << WDT_##name)
 #define WDT_BF(name, value)	((value) << WDT_##name)
 
@@ -56,6 +76,7 @@ struct wdt_at32ap700x {
 	void __iomem		*regs;
 	spinlock_t		io_lock;
 	int			timeout;
+	int			boot_status;
 	unsigned long		users;
 	struct miscdevice	miscdev;
 };
@@ -126,7 +147,7 @@ static int at32_wdt_close(struct inode *
 		at32_wdt_stop();
 	} else {
 		dev_dbg(wdt->miscdev.parent,
-			"Unexpected close, not stopping watchdog!\n");
+			"unexpected close, not stopping watchdog!\n");
 		at32_wdt_pat();
 	}
 	clear_bit(1, &wdt->users);
@@ -154,6 +175,33 @@ static int at32_wdt_settimeout(int time)
 	return 0;
 }
 
+/*
+ * Get the watchdog status.
+ */
+static int at32_wdt_get_status(void)
+{
+	int rcause;
+	int status = 0;
+
+	rcause = wdt_readl(wdt, RCAUSE);
+
+	switch (rcause) {
+	case WDT_BIT(RCAUSE_EXT):
+		status = WDIOF_EXTERN1;
+		break;
+	case WDT_BIT(RCAUSE_WDT):
+		status = WDIOF_CARDRESET;
+		break;
+	case WDT_BIT(RCAUSE_POR):  /* fall through */
+	case WDT_BIT(RCAUSE_JTAG): /* fall through */
+	case WDT_BIT(RCAUSE_SERP): /* fall through */
+	default:
+		break;
+	}
+
+	return status;
+}
+
 static struct watchdog_info at32_wdt_info = {
 	.identity	= "at32ap700x watchdog",
 	.options	= WDIOF_SETTIMEOUT |
@@ -194,10 +242,12 @@ static int at32_wdt_ioctl(struct inode *
 	case WDIOC_GETTIMEOUT:
 		ret = put_user(wdt->timeout, p);
 		break;
-	case WDIOC_GETSTATUS: /* fall through */
-	case WDIOC_GETBOOTSTATUS:
+	case WDIOC_GETSTATUS:
 		ret = put_user(0, p);
 		break;
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(wdt->boot_status, p);
+		break;
 	case WDIOC_SETOPTIONS:
 		ret = get_user(time, p);
 		if (ret)
@@ -282,8 +332,19 @@ static int __init at32_wdt_probe(struct 
 		dev_dbg(&pdev->dev, "could not map I/O memory\n");
 		goto err_free;
 	}
+
 	spin_lock_init(&wdt->io_lock);
-	wdt->users = 0;
+	wdt->boot_status = at32_wdt_get_status();
+
+	/* Work-around for watchdog silicon errata. */
+	if (wdt->boot_status & WDIOF_CARDRESET) {
+		dev_info(&pdev->dev, "CPU must be reset with external "
+				"reset or POR due to silicon errata.\n");
+		ret = -EIO;
+		goto err_iounmap;
+	} else {
+		wdt->users = 0;
+	}
 	wdt->miscdev.minor = WATCHDOG_MINOR;
 	wdt->miscdev.name = "watchdog";
 	wdt->miscdev.fops = &at32_wdt_fops;
--- a/drivers/watchdog/bfin_wdt.c	2007-12-17 16:34:15.000000000 -0500
+++ b/drivers/watchdog/bfin_wdt.c	2007-12-17 16:34:58.000000000 -0500
@@ -71,7 +71,7 @@ static int nowayout = WATCHDOG_NOWAYOUT;
 static struct watchdog_info bfin_wdt_info;
 static unsigned long open_check;
 static char expect_close;
-static spinlock_t bfin_wdt_spinlock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(bfin_wdt_spinlock);
 
 /**
  *	bfin_wdt_keepalive - Keep the Userspace Watchdog Alive
--- a/drivers/watchdog/it8712f_wdt.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/watchdog/it8712f_wdt.c	2007-12-17 16:34:58.000000000 -0500
@@ -0,0 +1,400 @@
+/*
+ *	IT8712F "Smart Guardian" Watchdog support
+ *
+ *	Copyright (c) 2006-2007 Jorge Boncompte - DTI2 <jorge@dti2.net>
+ *
+ *	Based on info and code taken from:
+ *
+ *	drivers/char/watchdog/scx200_wdt.c
+ *	drivers/hwmon/it87.c
+ *	IT8712F EC-LPC I/O Preliminary Specification 0.9.2.pdf
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of the
+ *	License, or (at your option) any later version.
+ *
+ *	The author(s) of this software shall not be held liable for damages
+ *	of any nature resulting due to the use of this software. This
+ *	software is provided AS-IS with no warranties.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#define NAME "it8712f_wdt"
+
+MODULE_AUTHOR("Jorge Boncompte - DTI2 <jorge@dti2.net>");
+MODULE_DESCRIPTION("IT8712F Watchdog Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+
+static int margin = 60;		/* in seconds */
+module_param(margin, int, 0);
+MODULE_PARM_DESC(margin, "Watchdog margin in seconds");
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Disable watchdog shutdown on close");
+
+static struct semaphore it8712f_wdt_sem;
+static unsigned expect_close;
+static spinlock_t io_lock;
+
+/* Dog Food address - We use the game port address */
+static unsigned short address;
+
+#define	REG		0x2e	/* The register to read/write */
+#define	VAL		0x2f	/* The value to read/write */
+
+#define	LDN		0x07	/* Register: Logical device select */
+#define	DEVID		0x20	/* Register: Device ID */
+#define	DEVREV		0x22	/* Register: Device Revision */
+#define ACT_REG		0x30	/* LDN Register: Activation */
+#define BASE_REG	0x60	/* LDN Register: Base address */
+
+#define IT8712F_DEVID	0x8712
+
+#define LDN_GPIO	0x07	/* GPIO and Watch Dog Timer */
+#define LDN_GAME 	0x09	/* Game Port */
+
+#define WDT_CONTROL	0x71	/* WDT Register: Control */
+#define WDT_CONFIG	0x72	/* WDT Register: Configuration */
+#define WDT_TIMEOUT	0x73	/* WDT Register: Timeout Value */
+
+#define WDT_RESET_GAME	0x10
+#define WDT_RESET_KBD	0x20
+#define WDT_RESET_MOUSE	0x40
+#define WDT_RESET_CIR	0x80
+
+#define WDT_UNIT_SEC	0x80	/* If 0 in MINUTES */
+
+#define WDT_OUT_PWROK	0x10
+#define WDT_OUT_KRST	0x40
+
+static int
+superio_inb(int reg)
+{
+	outb(reg, REG);
+	return inb(VAL);
+}
+
+static void
+superio_outb(int val, int reg)
+{
+	outb(reg, REG);
+	outb(val, VAL);
+}
+
+static int
+superio_inw(int reg)
+{
+	int val;
+	outb(reg++, REG);
+	val = inb(VAL) << 8;
+	outb(reg, REG);
+	val |= inb(VAL);
+	return val;
+}
+
+static inline void
+superio_select(int ldn)
+{
+	outb(LDN, REG);
+	outb(ldn, VAL);
+}
+
+static inline void
+superio_enter(void)
+{
+	spin_lock(&io_lock);
+	outb(0x87, REG);
+	outb(0x01, REG);
+	outb(0x55, REG);
+	outb(0x55, REG);
+}
+
+static inline void
+superio_exit(void)
+{
+	outb(0x02, REG);
+	outb(0x02, VAL);
+	spin_unlock(&io_lock);
+}
+
+static inline void
+it8712f_wdt_ping(void)
+{
+	inb(address);
+}
+
+static void
+it8712f_wdt_update_margin(void)
+{
+	int config = WDT_OUT_KRST | WDT_OUT_PWROK;
+
+	printk(KERN_INFO NAME ": timer margin %d seconds\n", margin);
+
+	/* The timeout register only has 8bits wide */
+	if (margin < 256)
+		config |= WDT_UNIT_SEC;	/* else UNIT are MINUTES */
+	superio_outb(config, WDT_CONFIG);
+
+	superio_outb((margin > 255) ? (margin / 60) : margin, WDT_TIMEOUT);
+}
+
+static void
+it8712f_wdt_enable(void)
+{
+	printk(KERN_DEBUG NAME ": enabling watchdog timer\n");
+	superio_enter();
+	superio_select(LDN_GPIO);
+
+	superio_outb(WDT_RESET_GAME, WDT_CONTROL);
+
+	it8712f_wdt_update_margin();
+
+	superio_exit();
+
+	it8712f_wdt_ping();
+}
+
+static void
+it8712f_wdt_disable(void)
+{
+	printk(KERN_DEBUG NAME ": disabling watchdog timer\n");
+
+	superio_enter();
+	superio_select(LDN_GPIO);
+
+	superio_outb(0, WDT_CONFIG);
+	superio_outb(0, WDT_CONTROL);
+	superio_outb(0, WDT_TIMEOUT);
+
+	superio_exit();
+}
+
+static int
+it8712f_wdt_notify(struct notifier_block *this,
+		    unsigned long code, void *unused)
+{
+	if (code == SYS_HALT || code == SYS_POWER_OFF)
+		if (!nowayout)
+			it8712f_wdt_disable();
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block it8712f_wdt_notifier = {
+	.notifier_call = it8712f_wdt_notify,
+};
+
+static ssize_t
+it8712f_wdt_write(struct file *file, const char __user *data,
+	size_t len, loff_t *ppos)
+{
+	/* check for a magic close character */
+	if (len) {
+		size_t i;
+
+		it8712f_wdt_ping();
+
+		expect_close = 0;
+		for (i = 0; i < len; ++i) {
+			char c;
+			if (get_user(c, data+i))
+				return -EFAULT;
+			if (c == 'V')
+				expect_close = 42;
+		}
+	}
+
+	return len;
+}
+
+static int
+it8712f_wdt_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	static struct watchdog_info ident = {
+		.identity = "IT8712F Watchdog",
+		.firmware_version = 1,
+		.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	};
+	int new_margin;
+
+	switch (cmd) {
+	default:
+		return -ENOTTY;
+	case WDIOC_GETSUPPORT:
+		if (copy_to_user(argp, &ident, sizeof(ident)))
+			return -EFAULT;
+		return 0;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+	case WDIOC_KEEPALIVE:
+		it8712f_wdt_ping();
+		return 0;
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_margin, p))
+			return -EFAULT;
+		if (new_margin < 1)
+			return -EINVAL;
+		margin = new_margin;
+		superio_enter();
+		superio_select(LDN_GPIO);
+
+		it8712f_wdt_update_margin();
+
+		superio_exit();
+		it8712f_wdt_ping();
+	case WDIOC_GETTIMEOUT:
+		if (put_user(margin, p))
+			return -EFAULT;
+		return 0;
+	}
+}
+
+static int
+it8712f_wdt_open(struct inode *inode, struct file *file)
+{
+	/* only allow one at a time */
+	if (down_trylock(&it8712f_wdt_sem))
+		return -EBUSY;
+	it8712f_wdt_enable();
+
+	return nonseekable_open(inode, file);
+}
+
+static int
+it8712f_wdt_release(struct inode *inode, struct file *file)
+{
+	if (expect_close != 42) {
+		printk(KERN_WARNING NAME
+			": watchdog device closed unexpectedly, will not"
+			" disable the watchdog timer\n");
+	} else if (!nowayout) {
+		it8712f_wdt_disable();
+	}
+	expect_close = 0;
+	up(&it8712f_wdt_sem);
+
+	return 0;
+}
+
+static struct file_operations it8712f_wdt_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.write = it8712f_wdt_write,
+	.ioctl = it8712f_wdt_ioctl,
+	.open = it8712f_wdt_open,
+	.release = it8712f_wdt_release,
+};
+
+static struct miscdevice it8712f_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &it8712f_wdt_fops,
+};
+
+static int __init
+it8712f_wdt_find(unsigned short *address)
+{
+	int err = -ENODEV;
+	int chip_type;
+
+	superio_enter();
+	chip_type = superio_inw(DEVID);
+	if (chip_type != IT8712F_DEVID)
+		goto exit;
+
+	superio_select(LDN_GAME);
+	superio_outb(1, ACT_REG);
+	if (!(superio_inb(ACT_REG) & 0x01)) {
+		printk(KERN_ERR NAME ": Device not activated, skipping\n");
+		goto exit;
+	}
+
+	*address = superio_inw(BASE_REG);
+	if (*address == 0) {
+		printk(KERN_ERR NAME ": Base address not set, skipping\n");
+		goto exit;
+	}
+
+	err = 0;
+	printk(KERN_DEBUG NAME ": Found IT%04xF chip revision %d - "
+		"using DogFood address 0x%x\n",
+		chip_type, superio_inb(DEVREV) & 0x0f, *address);
+
+exit:
+	superio_exit();
+	return err;
+}
+
+static int __init
+it8712f_wdt_init(void)
+{
+	int err = 0;
+
+	spin_lock_init(&io_lock);
+
+	if (it8712f_wdt_find(&address))
+		return -ENODEV;
+
+	if (!request_region(address, 1, "IT8712F Watchdog")) {
+		printk(KERN_WARNING NAME ": watchdog I/O region busy\n");
+		return -EBUSY;
+	}
+
+	it8712f_wdt_disable();
+
+	sema_init(&it8712f_wdt_sem, 1);
+
+	err = register_reboot_notifier(&it8712f_wdt_notifier);
+	if (err) {
+		printk(KERN_ERR NAME ": unable to register reboot notifier\n");
+		goto out;
+	}
+
+	err = misc_register(&it8712f_wdt_miscdev);
+	if (err) {
+		printk(KERN_ERR NAME
+			": cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, err);
+		goto reboot_out;
+	}
+
+	return 0;
+
+
+reboot_out:
+	unregister_reboot_notifier(&it8712f_wdt_notifier);
+out:
+	release_region(address, 1);
+	return err;
+}
+
+static void __exit
+it8712f_wdt_exit(void)
+{
+	misc_deregister(&it8712f_wdt_miscdev);
+	unregister_reboot_notifier(&it8712f_wdt_notifier);
+	release_region(address, 1);
+}
+
+module_init(it8712f_wdt_init);
+module_exit(it8712f_wdt_exit);
--- a/drivers/watchdog/Kconfig	2007-12-17 16:34:15.000000000 -0500
+++ b/drivers/watchdog/Kconfig	2007-12-17 16:34:58.000000000 -0500
@@ -392,6 +392,16 @@ config ITCO_VENDOR_SUPPORT
 	  devices. At this moment we only have additional support for some
 	  SuperMicro Inc. motherboards.
 
+config IT8712F_WDT
+	tristate "IT8712F (Smart Guardian) Watchdog Timer"
+	depends on X86
+	---help---
+	  This is the driver for the built-in watchdog timer on the IT8712F
+	  Super I/0 chipset used on many motherboards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called it8712f_wdt.
+
 config SC1200_WDT
 	tristate "National Semiconductor PC87307/PC97307 (ala SC1200) Watchdog"
 	depends on X86
@@ -456,6 +466,19 @@ config SBC8360_WDT
 
 	  Most people will say N.
 
+config SBC7240_WDT
+	tristate "SBC Nano 7240 Watchdog Timer"
+	depends on X86_32
+	---help---
+	  This is the driver for the hardware watchdog found on the IEI
+	  single board computers EPIC Nano 7240 (and likely others). This
+	  watchdog simply watches your kernel to make sure it doesn't freeze,
+	  and if it does, it reboots your computer after a certain amount of
+	  time.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sbc7240_wdt.
+
 config CPU5_WDT
 	tristate "SMA CPU5 Watchdog"
 	depends on X86
--- a/drivers/watchdog/Makefile	2007-12-17 16:34:15.000000000 -0500
+++ b/drivers/watchdog/Makefile	2007-12-17 16:34:58.000000000 -0500
@@ -66,11 +66,13 @@ obj-$(CONFIG_IBMASR) += ibmasr.o
 obj-$(CONFIG_WAFER_WDT) += wafer5823wdt.o
 obj-$(CONFIG_I6300ESB_WDT) += i6300esb.o
 obj-$(CONFIG_ITCO_WDT) += iTCO_wdt.o iTCO_vendor_support.o
+obj-$(CONFIG_IT8712F_WDT) += it8712f_wdt.o
 obj-$(CONFIG_SC1200_WDT) += sc1200wdt.o
 obj-$(CONFIG_SCx200_WDT) += scx200_wdt.o
 obj-$(CONFIG_PC87413_WDT) += pc87413_wdt.o
 obj-$(CONFIG_60XX_WDT) += sbc60xxwdt.o
 obj-$(CONFIG_SBC8360_WDT) += sbc8360.o
+obj-$(CONFIG_SBC7240_WDT) += sbc7240_wdt.o
 obj-$(CONFIG_CPU5_WDT) += cpu5wdt.o
 obj-$(CONFIG_SMSC37B787_WDT) += smsc37b787_wdt.o
 obj-$(CONFIG_W83627HF_WDT) += w83627hf_wdt.o
--- a/drivers/watchdog/sbc7240_wdt.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/watchdog/sbc7240_wdt.c	2007-12-17 16:34:58.000000000 -0500
@@ -0,0 +1,324 @@
+/*
+ *	NANO7240 SBC Watchdog device driver
+ *
+ *	Based on w83877f.c by Scott Jennings,
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2 as
+ *	published by the Free Software Foundation;
+ *
+ *	Software distributed under the License is distributed on an "AS IS"
+ *	basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *	implied. See the License for the specific language governing
+ *	rights and limitations under the License.
+ *
+ *	(c) Copyright 2007  Gilles GIGAN <gilles.gigan@jcu.edu.au>
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/miscdevice.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+#include <asm/atomic.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#define SBC7240_PREFIX "sbc7240_wdt: "
+
+#define SBC7240_ENABLE_PORT		0x443
+#define SBC7240_DISABLE_PORT		0x043
+#define SBC7240_SET_TIMEOUT_PORT	SBC7240_ENABLE_PORT
+#define SBC7240_MAGIC_CHAR		'V'
+
+#define SBC7240_TIMEOUT		30
+#define SBC7240_MAX_TIMEOUT		255
+static int timeout = SBC7240_TIMEOUT;	/* in seconds */
+module_param(timeout, int, 0);
+MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds. (1<=timeout<="
+		 __MODULE_STRING(SBC7240_MAX_TIMEOUT) ", default="
+		 __MODULE_STRING(SBC7240_TIMEOUT) ")");
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Disable watchdog when closing device file");
+
+#define SBC7240_OPEN_STATUS_BIT		0
+#define SBC7240_ENABLED_STATUS_BIT	1
+#define SBC7240_EXPECT_CLOSE_STATUS_BIT	2
+static unsigned long wdt_status;
+
+/*
+ * Utility routines
+ */
+
+static void wdt_disable(void)
+{
+	/* disable the watchdog */
+	if (test_and_clear_bit(SBC7240_ENABLED_STATUS_BIT, &wdt_status)) {
+		inb_p(SBC7240_DISABLE_PORT);
+		printk(KERN_INFO SBC7240_PREFIX
+		       "Watchdog timer is now disabled.\n");
+	}
+}
+
+static void wdt_enable(void)
+{
+	/* enable the watchdog */
+	if (!test_and_set_bit(SBC7240_ENABLED_STATUS_BIT, &wdt_status)) {
+		inb_p(SBC7240_ENABLE_PORT);
+		printk(KERN_INFO SBC7240_PREFIX
+		       "Watchdog timer is now enabled.\n");
+	}
+}
+
+static int wdt_set_timeout(int t)
+{
+	if (t < 1 || t > SBC7240_MAX_TIMEOUT) {
+		printk(KERN_ERR SBC7240_PREFIX
+		       "timeout value must be 1<=x<=%d\n",
+		       SBC7240_MAX_TIMEOUT);
+		return -1;
+	}
+	/* set the timeout */
+	outb_p((unsigned)t, SBC7240_SET_TIMEOUT_PORT);
+	timeout = t;
+	printk(KERN_INFO SBC7240_PREFIX "timeout set to %d seconds\n", t);
+	return 0;
+}
+
+/* Whack the dog */
+static inline void wdt_keepalive(void)
+{
+	if (test_bit(SBC7240_ENABLED_STATUS_BIT, &wdt_status))
+		inb_p(SBC7240_ENABLE_PORT);
+}
+
+/*
+ * /dev/watchdog handling
+ */
+static ssize_t fop_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	size_t i;
+	char c;
+
+	if (count) {
+		if (!nowayout) {
+			clear_bit(SBC7240_EXPECT_CLOSE_STATUS_BIT,
+				&wdt_status);
+
+			/* is there a magic char ? */
+			for (i = 0; i != count; i++) {
+				if (get_user(c, buf + i))
+					return -EFAULT;
+				if (c == SBC7240_MAGIC_CHAR) {
+					set_bit(SBC7240_EXPECT_CLOSE_STATUS_BIT,
+						&wdt_status);
+					break;
+				}
+			}
+		}
+
+		wdt_keepalive();
+	}
+
+	return count;
+}
+
+static int fop_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(SBC7240_OPEN_STATUS_BIT, &wdt_status))
+		return -EBUSY;
+
+	wdt_enable();
+
+	return nonseekable_open(inode, file);
+}
+
+static int fop_close(struct inode *inode, struct file *file)
+{
+	if (test_and_clear_bit(SBC7240_EXPECT_CLOSE_STATUS_BIT, &wdt_status)
+	    || !nowayout) {
+		wdt_disable();
+	} else {
+		printk(KERN_CRIT SBC7240_PREFIX
+		       "Unexpected close, not stopping watchdog!\n");
+		wdt_keepalive();
+	}
+
+	clear_bit(SBC7240_OPEN_STATUS_BIT, &wdt_status);
+	return 0;
+}
+
+static struct watchdog_info ident = {
+	.options = WDIOF_KEEPALIVEPING|
+		   WDIOF_SETTIMEOUT|
+		   WDIOF_MAGICCLOSE,
+	.firmware_version = 1,
+	.identity = "SBC7240",
+};
+
+
+static int fop_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user
+			((void __user *)arg, &ident, sizeof(ident))
+			 ? -EFAULT : 0;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, (int __user *)arg);
+	case WDIOC_KEEPALIVE:
+		wdt_keepalive();
+		return 0;
+	case WDIOC_SETOPTIONS:{
+			int options;
+			int retval = -EINVAL;
+
+			if (get_user(options, (int __user *)arg))
+				return -EFAULT;
+
+			if (options & WDIOS_DISABLECARD) {
+				wdt_disable();
+				retval = 0;
+			}
+
+			if (options & WDIOS_ENABLECARD) {
+				wdt_enable();
+				retval = 0;
+			}
+
+			return retval;
+		}
+	case WDIOC_SETTIMEOUT:{
+			int new_timeout;
+
+			if (get_user(new_timeout, (int __user *)arg))
+				return -EFAULT;
+
+			if (wdt_set_timeout(new_timeout))
+				return -EINVAL;
+
+			/* Fall through */
+		}
+	case WDIOC_GETTIMEOUT:
+		return put_user(timeout, (int __user *)arg);
+	default:
+		return -ENOTTY;
+	}
+}
+
+static const struct file_operations wdt_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.write = fop_write,
+	.open = fop_open,
+	.release = fop_close,
+	.ioctl = fop_ioctl,
+};
+
+static struct miscdevice wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &wdt_fops,
+};
+
+/*
+ *	Notifier for system down
+ */
+
+static int wdt_notify_sys(struct notifier_block *this, unsigned long code,
+			  void *unused)
+{
+	if (code == SYS_DOWN || code == SYS_HALT)
+		wdt_disable();
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block wdt_notifier = {
+	.notifier_call = wdt_notify_sys,
+};
+
+static void __exit sbc7240_wdt_unload(void)
+{
+	printk(KERN_INFO SBC7240_PREFIX "Removing watchdog\n");
+	misc_deregister(&wdt_miscdev);
+
+	unregister_reboot_notifier(&wdt_notifier);
+	release_region(SBC7240_ENABLE_PORT, 1);
+}
+
+static int __init sbc7240_wdt_init(void)
+{
+	int rc = -EBUSY;
+
+	if (!request_region(SBC7240_ENABLE_PORT, 1, "SBC7240 WDT")) {
+		printk(KERN_ERR SBC7240_PREFIX
+		       "I/O address 0x%04x already in use\n",
+		       SBC7240_ENABLE_PORT);
+		rc = -EIO;
+		goto err_out;
+	}
+
+	/* The IO port 0x043 used to disable the watchdog
+	 * is already claimed by the system timer, so we
+	 * cant request_region() it ...*/
+
+	if (timeout < 1 || timeout > SBC7240_MAX_TIMEOUT) {
+		timeout = SBC7240_TIMEOUT;
+		printk(KERN_INFO SBC7240_PREFIX
+		       "timeout value must be 1<=x<=%d, using %d\n",
+		       SBC7240_MAX_TIMEOUT, timeout);
+	}
+	wdt_set_timeout(timeout);
+	wdt_disable();
+
+	rc = register_reboot_notifier(&wdt_notifier);
+	if (rc) {
+		printk(KERN_ERR SBC7240_PREFIX
+		       "cannot register reboot notifier (err=%d)\n", rc);
+		goto err_out_region;
+	}
+
+	rc = misc_register(&wdt_miscdev);
+	if (rc) {
+		printk(KERN_ERR SBC7240_PREFIX
+		       "cannot register miscdev on minor=%d (err=%d)\n",
+		       wdt_miscdev.minor, rc);
+		goto err_out_reboot_notifier;
+	}
+
+	printk(KERN_INFO SBC7240_PREFIX
+	       "Watchdog driver for SBC7240 initialised (nowayout=%d)\n",
+	       nowayout);
+
+	return 0;
+
+err_out_reboot_notifier:
+	unregister_reboot_notifier(&wdt_notifier);
+err_out_region:
+	release_region(SBC7240_ENABLE_PORT, 1);
+err_out:
+	return rc;
+}
+
+module_init(sbc7240_wdt_init);
+module_exit(sbc7240_wdt_unload);
+
+MODULE_AUTHOR("Gilles Gigan");
+MODULE_DESCRIPTION("Watchdog device driver for single board"
+		   " computers EPIC Nano 7240 from iEi");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+
--- a/drivers/watchdog/w83697hf_wdt.c	2007-12-17 16:34:15.000000000 -0500
+++ b/drivers/watchdog/w83697hf_wdt.c	2007-12-17 16:34:58.000000000 -0500
@@ -382,8 +382,10 @@ wdt_init(void)
 		/* we will autodetect the W83697HF/HG watchdog */
 		for (i = 0; ((!found) && (w83697hf_ioports[i] != 0)); i++) {
 			wdt_io = w83697hf_ioports[i];
-			if (!w83697hf_check_wdt())
+			if (!w83697hf_check_wdt()) {
 				found++;
+				break;
+			}
 		}
 	} else {
 		if (!w83697hf_check_wdt())
--- a/include/asm-arm/arch-pxa/pxa-regs.h	2007-12-17 16:34:20.000000000 -0500
+++ b/include/asm-arm/arch-pxa/pxa-regs.h	2007-12-17 16:34:58.000000000 -0500
@@ -1784,6 +1784,7 @@
 #define CCCR_M_MASK	0x0060		/* Memory Frequency to Run Mode Frequency Multiplier */
 #define CCCR_L_MASK	0x001f		/* Crystal Frequency to Memory Frequency Multiplier */
 
+#define CKEN_AC97CONF   (31)    /* AC97 Controller Configuration */
 #define CKEN_CAMERA	(24)	/* Camera Interface Clock Enable */
 #define CKEN_SSP1	(23)	/* SSP1 Unit Clock Enable */
 #define CKEN_MEMC	(22)	/* Memory Controller Clock Enable */
--- a/include/asm-mips/mach-au1x00/au1000.h	2007-12-17 16:34:20.000000000 -0500
+++ b/include/asm-mips/mach-au1x00/au1000.h	2007-12-17 16:34:58.000000000 -0500
@@ -1680,10 +1680,11 @@ enum soc_au1200_ints {
 #define Au1500_PCI_MEM_START      0x440000000ULL
 #define Au1500_PCI_MEM_END        0x44FFFFFFFULL
 
-#define PCI_IO_START    (Au1500_PCI_IO_START + 0x1000)
-#define PCI_IO_END      (Au1500_PCI_IO_END)
-#define PCI_MEM_START   (Au1500_PCI_MEM_START)
-#define PCI_MEM_END     (Au1500_PCI_MEM_END)
+#define PCI_IO_START	0x00001000
+#define PCI_IO_END	0x000FFFFF
+#define PCI_MEM_START	0x40000000
+#define PCI_MEM_END	0x4FFFFFFF
+
 #define PCI_FIRST_DEVFN (0<<3)
 #define PCI_LAST_DEVFN  (19<<3)
 
--- a/include/asm-powerpc/commproc.h	2007-12-17 16:34:20.000000000 -0500
+++ b/include/asm-powerpc/commproc.h	2007-12-17 16:34:58.000000000 -0500
@@ -698,9 +698,6 @@ typedef struct risc_timer_pram {
 #define CICR_IEN		((uint)0x00000080)	/* Int. enable */
 #define CICR_SPS		((uint)0x00000001)	/* SCC Spread */
 
-extern void cpm_install_handler(int vec, void (*handler)(void *), void *dev_id);
-extern void cpm_free_handler(int vec);
-
 #define IMAP_ADDR		(get_immrbase())
 
 #define CPM_PIN_INPUT     0
--- a/include/asm-s390/pgtable.h	2007-12-17 16:34:20.000000000 -0500
+++ b/include/asm-s390/pgtable.h	2007-12-17 16:34:58.000000000 -0500
@@ -453,12 +453,12 @@ static inline int pgd_bad(pgd_t pgd)	 { 
 
 static inline int pud_present(pud_t pud)
 {
-	return pud_val(pud) & _REGION_ENTRY_ORIGIN;
+	return (pud_val(pud) & _REGION_ENTRY_ORIGIN) != 0UL;
 }
 
 static inline int pud_none(pud_t pud)
 {
-	return pud_val(pud) & _REGION_ENTRY_INV;
+	return (pud_val(pud) & _REGION_ENTRY_INV) != 0UL;
 }
 
 static inline int pud_bad(pud_t pud)
@@ -471,12 +471,12 @@ static inline int pud_bad(pud_t pud)
 
 static inline int pmd_present(pmd_t pmd)
 {
-	return pmd_val(pmd) & _SEGMENT_ENTRY_ORIGIN;
+	return (pmd_val(pmd) & _SEGMENT_ENTRY_ORIGIN) != 0UL;
 }
 
 static inline int pmd_none(pmd_t pmd)
 {
-	return pmd_val(pmd) & _SEGMENT_ENTRY_INV;
+	return (pmd_val(pmd) & _SEGMENT_ENTRY_INV) != 0UL;
 }
 
 static inline int pmd_bad(pmd_t pmd)
--- a/include/asm-sparc/unistd.h	2007-10-10 17:43:49.000000000 -0400
+++ b/include/asm-sparc/unistd.h	2007-12-17 16:34:58.000000000 -0500
@@ -333,6 +333,15 @@
 
 #define NR_SYSCALLS		315
 
+/* Sparc 32-bit only has the "setresuid32", "getresuid32" variants,
+ * it never had the plain ones and there is no value to adding those
+ * old versions into the syscall table.
+ */
+#define __IGNORE_setresuid
+#define __IGNORE_getresuid
+#define __IGNORE_setresgid
+#define __IGNORE_getresgid
+
 #ifdef __KERNEL__
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
--- a/include/asm-sparc64/hypervisor.h	2007-10-10 17:43:49.000000000 -0400
+++ b/include/asm-sparc64/hypervisor.h	2007-12-17 16:34:58.000000000 -0500
@@ -709,6 +709,10 @@ extern unsigned long sun4v_mmu_tsb_ctx0(
  */
 #define HV_FAST_MMU_DEMAP_ALL		0x24
 
+#ifndef __ASSEMBLY__
+extern void sun4v_mmu_demap_all(void);
+#endif
+
 /* mmu_map_perm_addr()
  * TRAP:	HV_FAST_TRAP
  * FUNCTION:	HV_FAST_MMU_MAP_PERM_ADDR
--- a/include/linux/netfilter_bridge.h	2007-07-08 19:32:17.000000000 -0400
+++ b/include/linux/netfilter_bridge.h	2007-12-17 16:34:58.000000000 -0500
@@ -50,7 +50,8 @@ enum nf_br_hook_priorities {
 extern int nf_bridge_copy_header(struct sk_buff *skb);
 static inline int nf_bridge_maybe_copy_header(struct sk_buff *skb)
 {
-	if (skb->nf_bridge)
+	if (skb->nf_bridge &&
+	    skb->nf_bridge->mask & (BRNF_BRIDGED | BRNF_BRIDGED_DNAT))
 		return nf_bridge_copy_header(skb);
   	return 0;
 }
--- a/Makefile	2007-12-17 16:34:45.000000000 -0500
+++ b/Makefile	2007-12-17 16:34:57.000000000 -0500
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 24
-EXTRAVERSION = -rc5-git2
+EXTRAVERSION = -rc5-git4
 NAME = Arr Matey! A Hairy Bilge Rat!
 
 # *DOCUMENTATION*
--- a/net/ax25/ax25_subr.c	2007-07-08 19:32:17.000000000 -0400
+++ b/net/ax25/ax25_subr.c	2007-12-17 16:34:58.000000000 -0500
@@ -279,6 +279,7 @@ void ax25_disconnect(ax25_cb *ax25, int 
 	ax25_link_failed(ax25, reason);
 
 	if (ax25->sk != NULL) {
+		local_bh_disable();
 		bh_lock_sock(ax25->sk);
 		ax25->sk->sk_state     = TCP_CLOSE;
 		ax25->sk->sk_err       = reason;
@@ -288,5 +289,6 @@ void ax25_disconnect(ax25_cb *ax25, int 
 			sock_set_flag(ax25->sk, SOCK_DEAD);
 		}
 		bh_unlock_sock(ax25->sk);
+		local_bh_enable();
 	}
 }
--- a/net/bridge/br_device.c	2007-12-17 16:34:21.000000000 -0500
+++ b/net/bridge/br_device.c	2007-12-17 16:34:58.000000000 -0500
@@ -157,8 +157,7 @@ static struct ethtool_ops br_ethtool_ops
 
 void br_dev_setup(struct net_device *dev)
 {
-	memset(dev->dev_addr, 0, ETH_ALEN);
-
+	random_ether_addr(dev->dev_addr);
 	ether_setup(dev);
 
 	dev->do_ioctl = br_dev_ioctl;
--- a/net/ipv4/ipconfig.c	2007-12-17 16:34:21.000000000 -0500
+++ b/net/ipv4/ipconfig.c	2007-12-17 16:34:58.000000000 -0500
@@ -1396,25 +1396,7 @@ late_initcall(ip_auto_config);
 
 /*
  *  Decode any IP configuration options in the "ip=" or "nfsaddrs=" kernel
- *  command line parameter. It consists of option fields separated by colons in
- *  the following order:
- *
- *  <client-ip>:<server-ip>:<gw-ip>:<netmask>:<host name>:<device>:<PROTO>
- *
- *  Any of the fields can be empty which means to use a default value:
- *	<client-ip>	- address given by BOOTP or RARP
- *	<server-ip>	- address of host returning BOOTP or RARP packet
- *	<gw-ip>		- none, or the address returned by BOOTP
- *	<netmask>	- automatically determined from <client-ip>, or the
- *			  one returned by BOOTP
- *	<host name>	- <client-ip> in ASCII notation, or the name returned
- *			  by BOOTP
- *	<device>	- use all available devices
- *	<PROTO>:
- *	   off|none	    - don't do autoconfig at all (DEFAULT)
- *	   on|any           - use any configured protocol
- *	   dhcp|bootp|rarp  - use only the specified protocol
- *	   both             - use both BOOTP and RARP (not DHCP)
+ *  command line parameter.  See Documentation/nfsroot.txt.
  */
 static int __init ic_proto_name(char *name)
 {
--- a/net/ipv4/netfilter/ip_tables.c	2007-12-17 16:34:21.000000000 -0500
+++ b/net/ipv4/netfilter/ip_tables.c	2007-12-17 16:34:58.000000000 -0500
@@ -1492,8 +1492,10 @@ static inline int compat_copy_match_to_u
 	return xt_compat_match_to_user(m, dstptr, size);
 }
 
-static int compat_copy_entry_to_user(struct ipt_entry *e,
-		void __user **dstptr, compat_uint_t *size)
+static int
+compat_copy_entry_to_user(struct ipt_entry *e, void __user **dstptr,
+			  compat_uint_t *size, struct xt_counters *counters,
+			  unsigned int *i)
 {
 	struct ipt_entry_target *t;
 	struct compat_ipt_entry __user *ce;
@@ -1507,6 +1509,9 @@ static int compat_copy_entry_to_user(str
 	if (copy_to_user(ce, e, sizeof(struct ipt_entry)))
 		goto out;
 
+	if (copy_to_user(&ce->counters, &counters[*i], sizeof(counters[*i])))
+		goto out;
+
 	*dstptr += sizeof(struct compat_ipt_entry);
 	ret = IPT_MATCH_ITERATE(e, compat_copy_match_to_user, dstptr, size);
 	target_offset = e->target_offset - (origsize - *size);
@@ -1522,6 +1527,8 @@ static int compat_copy_entry_to_user(str
 		goto out;
 	if (put_user(next_offset, &ce->next_offset))
 		goto out;
+
+	(*i)++;
 	return 0;
 out:
 	return ret;
@@ -1937,14 +1944,13 @@ struct compat_ipt_get_entries
 static int compat_copy_entries_to_user(unsigned int total_size,
 		     struct xt_table *table, void __user *userptr)
 {
-	unsigned int off, num;
-	struct compat_ipt_entry e;
 	struct xt_counters *counters;
 	struct xt_table_info *private = table->private;
 	void __user *pos;
 	unsigned int size;
 	int ret = 0;
 	void *loc_cpu_entry;
+	unsigned int i = 0;
 
 	counters = alloc_counters(table);
 	if (IS_ERR(counters))
@@ -1958,48 +1964,9 @@ static int compat_copy_entries_to_user(u
 	pos = userptr;
 	size = total_size;
 	ret = IPT_ENTRY_ITERATE(loc_cpu_entry, total_size,
-			compat_copy_entry_to_user, &pos, &size);
-	if (ret)
-		goto free_counters;
+				compat_copy_entry_to_user,
+				&pos, &size, counters, &i);
 
-	/* ... then go back and fix counters and names */
-	for (off = 0, num = 0; off < size; off += e.next_offset, num++) {
-		unsigned int i;
-		struct ipt_entry_match m;
-		struct ipt_entry_target t;
-
-		ret = -EFAULT;
-		if (copy_from_user(&e, userptr + off,
-					sizeof(struct compat_ipt_entry)))
-			goto free_counters;
-		if (copy_to_user(userptr + off +
-			offsetof(struct compat_ipt_entry, counters),
-			 &counters[num], sizeof(counters[num])))
-			goto free_counters;
-
-		for (i = sizeof(struct compat_ipt_entry);
-				i < e.target_offset; i += m.u.match_size) {
-			if (copy_from_user(&m, userptr + off + i,
-					sizeof(struct ipt_entry_match)))
-				goto free_counters;
-			if (copy_to_user(userptr + off + i +
-				offsetof(struct ipt_entry_match, u.user.name),
-				m.u.kernel.match->name,
-				strlen(m.u.kernel.match->name) + 1))
-				goto free_counters;
-		}
-
-		if (copy_from_user(&t, userptr + off + e.target_offset,
-					sizeof(struct ipt_entry_target)))
-			goto free_counters;
-		if (copy_to_user(userptr + off + e.target_offset +
-			offsetof(struct ipt_entry_target, u.user.name),
-			t.u.kernel.target->name,
-			strlen(t.u.kernel.target->name) + 1))
-			goto free_counters;
-	}
-	ret = 0;
-free_counters:
 	vfree(counters);
 	return ret;
 }
--- a/net/ipv4/tcp_input.c	2007-12-17 16:34:21.000000000 -0500
+++ b/net/ipv4/tcp_input.c	2007-12-17 16:34:58.000000000 -0500
@@ -923,7 +923,7 @@ static void tcp_init_metrics(struct sock
 	}
 	if (dst_metric(dst, RTAX_RTTVAR) > tp->mdev) {
 		tp->mdev = dst_metric(dst, RTAX_RTTVAR);
-		tp->mdev_max = tp->rttvar = max(tp->mdev, TCP_RTO_MIN);
+		tp->mdev_max = tp->rttvar = max(tp->mdev, tcp_rto_min(sk));
 	}
 	tcp_set_rto(sk);
 	tcp_bound_rto(sk);
--- a/net/ipv6/ipv6_sockglue.c	2007-12-17 16:34:21.000000000 -0500
+++ b/net/ipv6/ipv6_sockglue.c	2007-12-17 16:34:58.000000000 -0500
@@ -1046,7 +1046,7 @@ static int do_ipv6_getsockopt(struct soc
 		break;
 
 	default:
-		return -EINVAL;
+		return -ENOPROTOOPT;
 	}
 	len = min_t(unsigned int, sizeof(int), len);
 	if(put_user(len, optlen))
@@ -1069,9 +1069,8 @@ int ipv6_getsockopt(struct sock *sk, int
 
 	err = do_ipv6_getsockopt(sk, level, optname, optval, optlen);
 #ifdef CONFIG_NETFILTER
-	/* we need to exclude all possible EINVALs except default case */
-	if (err == -EINVAL && optname != IPV6_ADDRFORM &&
-			optname != MCAST_MSFILTER) {
+	/* we need to exclude all possible ENOPROTOOPTs except default case */
+	if (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {
 		int len;
 
 		if (get_user(len, optlen))
@@ -1108,9 +1107,8 @@ int compat_ipv6_getsockopt(struct sock *
 
 	err = do_ipv6_getsockopt(sk, level, optname, optval, optlen);
 #ifdef CONFIG_NETFILTER
-	/* we need to exclude all possible EINVALs except default case */
-	if (err == -EINVAL && optname != IPV6_ADDRFORM &&
-			optname != MCAST_MSFILTER) {
+	/* we need to exclude all possible ENOPROTOOPTs except default case */
+	if (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {
 		int len;
 
 		if (get_user(len, optlen))
--- a/net/irda/irlmp.c	2007-12-17 16:34:21.000000000 -0500
+++ b/net/irda/irlmp.c	2007-12-17 16:34:58.000000000 -0500
@@ -353,6 +353,7 @@ void irlmp_unregister_link(__u32 saddr)
 		/* Final cleanup */
 		del_timer(&link->idle_timer);
 		link->magic = 0;
+		hashbin_delete(link->lsaps, (FREE_FUNC) __irlmp_close_lsap);
 		kfree(link);
 	}
 }
--- a/net/irda/parameters.c	2007-07-08 19:32:17.000000000 -0400
+++ b/net/irda/parameters.c	2007-12-17 16:34:58.000000000 -0500
@@ -463,7 +463,7 @@ int irda_param_insert(void *self, __u8 p
 	int n = 0;
 
 	IRDA_ASSERT(buf != NULL, return ret;);
-	IRDA_ASSERT(info != 0, return ret;);
+	IRDA_ASSERT(info != NULL, return ret;);
 
 	pi_minor = pi & info->pi_mask;
 	pi_major = pi >> info->pi_major_offset;
@@ -517,7 +517,7 @@ static int irda_param_extract(void *self
 	int n = 0;
 
 	IRDA_ASSERT(buf != NULL, return ret;);
-	IRDA_ASSERT(info != 0, return ret;);
+	IRDA_ASSERT(info != NULL, return ret;);
 
 	pi_minor = buf[n] & info->pi_mask;
 	pi_major = buf[n] >> info->pi_major_offset;
@@ -570,7 +570,7 @@ int irda_param_extract_all(void *self, _
 	int n = 0;
 
 	IRDA_ASSERT(buf != NULL, return ret;);
-	IRDA_ASSERT(info != 0, return ret;);
+	IRDA_ASSERT(info != NULL, return ret;);
 
 	/*
 	 * Parse all parameters. Each parameter must be at least two bytes
--- a/net/netfilter/nf_conntrack_netlink.c	2007-12-17 16:34:22.000000000 -0500
+++ b/net/netfilter/nf_conntrack_netlink.c	2007-12-17 16:34:58.000000000 -0500
@@ -1024,8 +1024,10 @@ ctnetlink_create_conntrack(struct nlattr
 	}
 
 	/* setup master conntrack: this is a confirmed expectation */
-	if (master_ct)
+	if (master_ct) {
+		__set_bit(IPS_EXPECTED_BIT, &ct->status);
 		ct->master = master_ct;
+	}
 
 	add_timer(&ct->timeout);
 	nf_conntrack_hash_insert(ct);
--- a/net/netfilter/x_tables.c	2007-12-17 16:34:22.000000000 -0500
+++ b/net/netfilter/x_tables.c	2007-12-17 16:34:58.000000000 -0500
@@ -377,7 +377,9 @@ int xt_compat_match_to_user(struct xt_en
 	u_int16_t msize = m->u.user.match_size - off;
 
 	if (copy_to_user(cm, m, sizeof(*cm)) ||
-	    put_user(msize, &cm->u.user.match_size))
+	    put_user(msize, &cm->u.user.match_size) ||
+	    copy_to_user(cm->u.user.name, m->u.kernel.match->name,
+			 strlen(m->u.kernel.match->name) + 1))
 		return -EFAULT;
 
 	if (match->compat_to_user) {
@@ -468,7 +470,9 @@ int xt_compat_target_to_user(struct xt_e
 	u_int16_t tsize = t->u.user.target_size - off;
 
 	if (copy_to_user(ct, t, sizeof(*ct)) ||
-	    put_user(tsize, &ct->u.user.target_size))
+	    put_user(tsize, &ct->u.user.target_size) ||
+	    copy_to_user(ct->u.user.name, t->u.kernel.target->name,
+			 strlen(t->u.kernel.target->name) + 1))
 		return -EFAULT;
 
 	if (target->compat_to_user) {
--- a/net/netfilter/xt_hashlimit.c	2007-12-17 16:34:22.000000000 -0500
+++ b/net/netfilter/xt_hashlimit.c	2007-12-17 16:34:58.000000000 -0500
@@ -240,7 +240,7 @@ static bool select_all(const struct xt_h
 static bool select_gc(const struct xt_hashlimit_htable *ht,
 		      const struct dsthash_ent *he)
 {
-	return jiffies >= he->expires;
+	return time_after_eq(jiffies, he->expires);
 }
 
 static void htable_selective_cleanup(struct xt_hashlimit_htable *ht,
--- a/net/sctp/ulpqueue.c	2007-12-17 16:34:22.000000000 -0500
+++ b/net/sctp/ulpqueue.c	2007-12-17 16:34:58.000000000 -0500
@@ -53,6 +53,7 @@ static struct sctp_ulpevent * sctp_ulpq_
 					      struct sctp_ulpevent *);
 static struct sctp_ulpevent * sctp_ulpq_order(struct sctp_ulpq *,
 					      struct sctp_ulpevent *);
+static void sctp_ulpq_reasm_drain(struct sctp_ulpq *ulpq);
 
 /* 1st Level Abstractions */
 
@@ -190,6 +191,7 @@ static void sctp_ulpq_set_pd(struct sctp
 static int sctp_ulpq_clear_pd(struct sctp_ulpq *ulpq)
 {
 	ulpq->pd_mode = 0;
+	sctp_ulpq_reasm_drain(ulpq);
 	return sctp_clear_pd(ulpq->asoc->base.sk, ulpq->asoc);
 }
 
@@ -699,6 +701,37 @@ void sctp_ulpq_reasm_flushtsn(struct sct
 	}
 }
 
+/*
+ * Drain the reassembly queue.  If we just cleared parted delivery, it
+ * is possible that the reassembly queue will contain already reassembled
+ * messages.  Retrieve any such messages and give them to the user.
+ */
+static void sctp_ulpq_reasm_drain(struct sctp_ulpq *ulpq)
+{
+	struct sctp_ulpevent *event = NULL;
+	struct sk_buff_head temp;
+
+	if (skb_queue_empty(&ulpq->reasm))
+		return;
+
+	while ((event = sctp_ulpq_retrieve_reassembled(ulpq)) != NULL) {
+		/* Do ordering if needed.  */
+		if ((event) && (event->msg_flags & MSG_EOR)){
+			skb_queue_head_init(&temp);
+			__skb_queue_tail(&temp, sctp_event2skb(event));
+
+			event = sctp_ulpq_order(ulpq, event);
+		}
+
+		/* Send event to the ULP.  'event' is the
+		 * sctp_ulpevent for  very first SKB on the  temp' list.
+		 */
+		if (event)
+			sctp_ulpq_tail_event(ulpq, event);
+	}
+}
+
+
 /* Helper function to gather skbs that have possibly become
  * ordered by an an incoming chunk.
  */
--- a/net/tipc/socket.c	2007-12-17 16:34:22.000000000 -0500
+++ b/net/tipc/socket.c	2007-12-17 16:34:58.000000000 -0500
@@ -253,7 +253,7 @@ static int release(struct socket *sock)
 	dbg("sock_delete: %x\n",tsock);
 	if (!tsock)
 		return 0;
-	down_interruptible(&tsock->sem);
+	down(&tsock->sem);
 	if (!sock->sk) {
 		up(&tsock->sem);
 		return 0;
--- a/net/xfrm/xfrm_state.c	2007-12-17 16:34:22.000000000 -0500
+++ b/net/xfrm/xfrm_state.c	2007-12-17 16:34:58.000000000 -0500
@@ -2028,6 +2028,7 @@ void
 xfrm_audit_state_add(struct xfrm_state *x, int result, u32 auid, u32 sid)
 {
 	struct audit_buffer *audit_buf;
+	u32 spi;
 	extern int audit_enabled;
 
 	if (audit_enabled == 0)
@@ -2037,8 +2038,8 @@ xfrm_audit_state_add(struct xfrm_state *
 		return;
 	audit_log_format(audit_buf, " op=SAD-add res=%u",result);
 	xfrm_audit_common_stateinfo(x, audit_buf);
-	audit_log_format(audit_buf, " spi=%lu(0x%lx)",
-			 (unsigned long)x->id.spi, (unsigned long)x->id.spi);
+	spi = ntohl(x->id.spi);
+	audit_log_format(audit_buf, " spi=%u(0x%x)", spi, spi);
 	audit_log_end(audit_buf);
 }
 EXPORT_SYMBOL_GPL(xfrm_audit_state_add);
@@ -2047,6 +2048,7 @@ void
 xfrm_audit_state_delete(struct xfrm_state *x, int result, u32 auid, u32 sid)
 {
 	struct audit_buffer *audit_buf;
+	u32 spi;
 	extern int audit_enabled;
 
 	if (audit_enabled == 0)
@@ -2056,8 +2058,8 @@ xfrm_audit_state_delete(struct xfrm_stat
 		return;
 	audit_log_format(audit_buf, " op=SAD-delete res=%u",result);
 	xfrm_audit_common_stateinfo(x, audit_buf);
-	audit_log_format(audit_buf, " spi=%lu(0x%lx)",
-			 (unsigned long)x->id.spi, (unsigned long)x->id.spi);
+	spi = ntohl(x->id.spi);
+	audit_log_format(audit_buf, " spi=%u(0x%x)", spi, spi);
 	audit_log_end(audit_buf);
 }
 EXPORT_SYMBOL_GPL(xfrm_audit_state_delete);
--- a/scripts/mkmakefile	2007-12-17 16:34:22.000000000 -0500
+++ b/scripts/mkmakefile	2007-12-17 16:34:58.000000000 -0500
@@ -13,7 +13,7 @@
 test ! -r $2/Makefile -o -O $2/Makefile || exit 0
 # Only overwrite automatically generated Makefiles
 # (so we do not overwrite kernel Makefile)
-if ! grep -q Automatically $2/Makefile
+if test -e $2/Makefile && ! grep -q Automatically $2/Makefile
 then
 	exit 0
 fi
--- a/sound/arm/pxa2xx-ac97.c	2007-07-08 19:32:17.000000000 -0400
+++ b/sound/arm/pxa2xx-ac97.c	2007-12-17 16:34:58.000000000 -0500
@@ -113,9 +113,9 @@ static void pxa2xx_ac97_reset(struct snd
 	gsr_bits = 0;
 #ifdef CONFIG_PXA27x
 	/* PXA27x Developers Manual section 13.5.2.2.1 */
-	pxa_set_cken(1 << 31, 1);
+	pxa_set_cken(CKEN_AC97CONF, 1);
 	udelay(5);
-	pxa_set_cken(1 << 31, 0);
+	pxa_set_cken(CKEN_AC97CONF, 0);
 	GCR = GCR_COLD_RST;
 	udelay(50);
 #else
--- a/sound/soc/pxa/pxa2xx-ac97.c	2007-10-10 17:43:50.000000000 -0400
+++ b/sound/soc/pxa/pxa2xx-ac97.c	2007-12-17 16:34:58.000000000 -0500
@@ -160,9 +160,9 @@ static void pxa2xx_ac97_cold_reset(struc
 	gsr_bits = 0;
 #ifdef CONFIG_PXA27x
 	/* PXA27x Developers Manual section 13.5.2.2.1 */
-	pxa_set_cken(31, 1);
+	pxa_set_cken(CKEN_AC97CONF, 1);
 	udelay(5);
-	pxa_set_cken(31, 0);
+	pxa_set_cken(CKEN_AC97CONF, 0);
 	GCR = GCR_COLD_RST;
 	udelay(50);
 #else
