From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] kmalloc: Return NULL instead of link failure

 The SLAB kmalloc with a constant value isn't consistent with the other
 implementations, because it bails out with __you_cannot_kmalloc_that_much
 rather than returning NULL and properly allowing the caller to fall back
 to vmalloc or take other action. This doesn't happen with a non-constant
 value or with SLOB or SLUB.

 Starting with 2.6.28, I've been seeing build failures on s390x. This is
 due to init_section_page_cgroup trying to allocate 2.5MB when the max
 size for a kmalloc on s390x is 2MB.

 It's failing because the value is constant. The workarounds at the call
 size are ugly and the caller shouldn't have to change behavior depending
 on what the backend of the API is.

 So, this patch eliminates the link failure and returns NULL like the
 other implementations.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 include/linux/slab_def.h |   10 ++--------
 1 file changed, 2 insertions(+), 8 deletions(-)

--- a/include/linux/slab_def.h
+++ b/include/linux/slab_def.h
@@ -43,10 +43,7 @@ static inline void *kmalloc(size_t size,
 			i++;
 #include <linux/kmalloc_sizes.h>
 #undef CACHE
-		{
-			extern void __you_cannot_kmalloc_that_much(void);
-			__you_cannot_kmalloc_that_much();
-		}
+		return NULL;
 found:
 #ifdef CONFIG_ZONE_DMA
 		if (flags & GFP_DMA)
@@ -77,10 +74,7 @@ static inline void *kmalloc_node(size_t
 			i++;
 #include <linux/kmalloc_sizes.h>
 #undef CACHE
-		{
-			extern void __you_cannot_kmalloc_that_much(void);
-			__you_cannot_kmalloc_that_much();
-		}
+		return NULL;
 found:
 #ifdef CONFIG_ZONE_DMA
 		if (flags & GFP_DMA)
