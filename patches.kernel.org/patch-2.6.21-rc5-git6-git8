 Documentation/kernel-parameters.txt      |    2 -
 Makefile                                 |    2 -
 arch/arm/kernel/dma.c                    |    1 
 arch/arm/mach-at91/at91sam9260_devices.c |    8 +++----
 crypto/scatterwalk.c                     |   10 ++++++---
 drivers/acpi/tables.c                    |    2 -
 drivers/ata/libata-core.c                |    2 +
 drivers/base/driver.c                    |    9 +++++++-
 drivers/net/irda/pxaficp_ir.c            |   30 ++++++++++++++++++++++-----
 include/asm-arm/arch-ixp4xx/io.h         |   17 ---------------
 include/asm-arm/system.h                 |   34 ++++++++++++++++---------------
 include/asm-arm/unistd.h                 |    2 -
 include/asm-um/common.lds.S              |    2 -
 scripts/basic/fixdep.c                   |   10 ++++++---
 14 files changed, 77 insertions(+), 54 deletions(-)
diff -purN linux-2.6.21-rc5-git6/Documentation/kernel-parameters.txt linux-2.6.21-rc5-git8/Documentation/kernel-parameters.txt
--- linux-2.6.21-rc5-git6/Documentation/kernel-parameters.txt	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/Documentation/kernel-parameters.txt	2007-04-02 10:27:46.925726224 +0200
@@ -142,7 +142,7 @@ and is between 256 and 4096 characters. 
 			Format: <int>
 			2: use 2nd APIC table, if available
 			1,0: use 1st APIC table
-			default: 2
+			default: 0
 
 	acpi_sleep=	[HW,ACPI] Sleep options
 			Format: { s3_bios, s3_mode }
diff -purN linux-2.6.21-rc5-git6/Makefile linux-2.6.21-rc5-git8/Makefile
--- linux-2.6.21-rc5-git6/Makefile	2007-04-02 10:27:41.255715990 +0200
+++ linux-2.6.21-rc5-git8/Makefile	2007-04-02 10:27:46.925726224 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 21
-EXTRAVERSION = -rc5-git6
+EXTRAVERSION = -rc5-git8
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff -purN linux-2.6.21-rc5-git6/arch/arm/kernel/dma.c linux-2.6.21-rc5-git8/arch/arm/kernel/dma.c
--- linux-2.6.21-rc5-git6/arch/arm/kernel/dma.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/arch/arm/kernel/dma.c	2007-04-02 10:27:46.925726224 +0200
@@ -228,6 +228,7 @@ int dma_channel_active(dmach_t channel)
 {
 	return dma_chan[channel].active;
 }
+EXPORT_SYMBOL(dma_channel_active);
 
 void set_dma_page(dmach_t channel, char pagenr)
 {
diff -purN linux-2.6.21-rc5-git6/arch/arm/mach-at91/at91sam9260_devices.c linux-2.6.21-rc5-git8/arch/arm/mach-at91/at91sam9260_devices.c
--- linux-2.6.21-rc5-git6/arch/arm/mach-at91/at91sam9260_devices.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/arch/arm/mach-at91/at91sam9260_devices.c	2007-04-02 10:27:46.925726224 +0200
@@ -320,16 +320,16 @@ void __init at91_add_device_nand(struct 
 	at91_sys_write(AT91_SMC_SETUP(3), AT91_SMC_NWESETUP_(0) | AT91_SMC_NCS_WRSETUP_(0)
 			| AT91_SMC_NRDSETUP_(0) | AT91_SMC_NCS_RDSETUP_(0));
 
-	at91_sys_write(AT91_SMC_PULSE(3), AT91_SMC_NWEPULSE_(2) | AT91_SMC_NCS_WRPULSE_(5)
-			| AT91_SMC_NRDPULSE_(2) | AT91_SMC_NCS_RDPULSE_(5));
+	at91_sys_write(AT91_SMC_PULSE(3), AT91_SMC_NWEPULSE_(3) | AT91_SMC_NCS_WRPULSE_(3)
+			| AT91_SMC_NRDPULSE_(3) | AT91_SMC_NCS_RDPULSE_(3));
 
-	at91_sys_write(AT91_SMC_CYCLE(3), AT91_SMC_NWECYCLE_(7) | AT91_SMC_NRDCYCLE_(7));
+	at91_sys_write(AT91_SMC_CYCLE(3), AT91_SMC_NWECYCLE_(5) | AT91_SMC_NRDCYCLE_(5));
 
 	if (data->bus_width_16)
 		mode = AT91_SMC_DBW_16;
 	else
 		mode = AT91_SMC_DBW_8;
-	at91_sys_write(AT91_SMC_MODE(3), mode | AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE | AT91_SMC_TDF_(1));
+	at91_sys_write(AT91_SMC_MODE(3), mode | AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE | AT91_SMC_TDF_(2));
 
 	/* enable pin */
 	if (data->enable_pin)
diff -purN linux-2.6.21-rc5-git6/crypto/scatterwalk.c linux-2.6.21-rc5-git8/crypto/scatterwalk.c
--- linux-2.6.21-rc5-git6/crypto/scatterwalk.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/crypto/scatterwalk.c	2007-04-02 10:27:46.945726260 +0200
@@ -59,8 +59,12 @@ EXPORT_SYMBOL_GPL(scatterwalk_map);
 static void scatterwalk_pagedone(struct scatter_walk *walk, int out,
 				 unsigned int more)
 {
-	if (out)
-		flush_dcache_page(scatterwalk_page(walk));
+	if (out) {
+		struct page *page;
+
+		page = walk->sg->page + ((walk->offset - 1) >> PAGE_SHIFT);
+		flush_dcache_page(page);
+	}
 
 	if (more) {
 		walk->offset += PAGE_SIZE - 1;
@@ -91,7 +95,7 @@ void scatterwalk_copychunks(void *buf, s
 		memcpy_dir(buf, vaddr, len_this_page, out);
 		scatterwalk_unmap(vaddr, out);
 
-		scatterwalk_advance(walk, nbytes);
+		scatterwalk_advance(walk, len_this_page);
 
 		if (nbytes == len_this_page)
 			break;
diff -purN linux-2.6.21-rc5-git6/drivers/acpi/tables.c linux-2.6.21-rc5-git8/drivers/acpi/tables.c
--- linux-2.6.21-rc5-git6/drivers/acpi/tables.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/drivers/acpi/tables.c	2007-04-02 10:27:46.945726260 +0200
@@ -42,7 +42,7 @@ static char *mps_inti_flags_trigger[] = 
 
 static struct acpi_table_desc initial_tables[ACPI_MAX_TABLES] __initdata;
 
-static int acpi_apic_instance __initdata = 2;
+static int acpi_apic_instance __initdata;
 
 void acpi_table_print_madt_entry(struct acpi_subtable_header *header)
 {
diff -purN linux-2.6.21-rc5-git6/drivers/ata/libata-core.c linux-2.6.21-rc5-git8/drivers/ata/libata-core.c
--- linux-2.6.21-rc5-git6/drivers/ata/libata-core.c	2007-04-02 10:27:41.285716044 +0200
+++ linux-2.6.21-rc5-git8/drivers/ata/libata-core.c	2007-04-02 10:27:46.945726260 +0200
@@ -3361,6 +3361,8 @@ static const struct ata_blacklist_entry 
 	{ "FUJITSU MHT2060BH",	NULL,		ATA_HORKAGE_NONCQ },
 	/* NCQ is broken */
 	{ "Maxtor 6L250S0",     "BANC1G10",     ATA_HORKAGE_NONCQ },
+	/* NCQ hard hangs device under heavier load, needs hard power cycle */
+	{ "Maxtor 6B250S0",	"BANC1B70",	ATA_HORKAGE_NONCQ },
 
 	/* Devices with NCQ limits */
 
diff -purN linux-2.6.21-rc5-git6/drivers/base/driver.c linux-2.6.21-rc5-git8/drivers/base/driver.c
--- linux-2.6.21-rc5-git6/drivers/base/driver.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/drivers/base/driver.c	2007-04-02 10:27:46.955726278 +0200
@@ -183,7 +183,14 @@ int driver_register(struct device_driver
 void driver_unregister(struct device_driver * drv)
 {
 	bus_remove_driver(drv);
-	wait_for_completion(&drv->unloaded);
+	/*
+	 * If the driver is a module, we are probably in
+	 * the module unload path, and we want to wait
+	 * for everything to unload before we can actually
+	 * finish the unload.
+	 */
+	if (drv->owner)
+		wait_for_completion(&drv->unloaded);
 }
 
 /**
diff -purN linux-2.6.21-rc5-git6/drivers/net/irda/pxaficp_ir.c linux-2.6.21-rc5-git8/drivers/net/irda/pxaficp_ir.c
--- linux-2.6.21-rc5-git6/drivers/net/irda/pxaficp_ir.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/drivers/net/irda/pxaficp_ir.c	2007-04-02 10:27:46.995726351 +0200
@@ -321,15 +321,22 @@ static void pxa_irda_fir_dma_tx_irq(int 
 		pxa_irda_set_speed(si, si->newspeed);
 		si->newspeed = 0;
 	} else {
+		int i = 64;
+
 		ICCR0 = 0;
 		pxa_irda_fir_dma_rx_start(si);
+		while ((ICSR1 & ICSR1_RNE) && i--)
+			(void)ICDR;
 		ICCR0 = ICCR0_ITR | ICCR0_RXE;
+
+		if (i < 0)
+			printk(KERN_ERR "pxa_ir: cannot clear Rx FIFO!\n");
 	}
 	netif_wake_queue(dev);
 }
 
 /* EIF(Error in FIFO/End in Frame) handler for FIR */
-static void pxa_irda_fir_irq_eif(struct pxa_irda *si, struct net_device *dev)
+static void pxa_irda_fir_irq_eif(struct pxa_irda *si, struct net_device *dev, int icsr0)
 {
 	unsigned int len, stat, data;
 
@@ -350,7 +357,7 @@ static void pxa_irda_fir_irq_eif(struct 
 			}
 			if (stat & ICSR1_ROR) {
 				printk(KERN_DEBUG "pxa_ir: fir receive overrun\n");
-				si->stats.rx_frame_errors++;
+				si->stats.rx_over_errors++;
 			}
 		} else	{
 			si->dma_rx_buff[len++] = data;
@@ -362,7 +369,15 @@ static void pxa_irda_fir_irq_eif(struct 
 
 	if (stat & ICSR1_EOF) {
 		/* end of frame. */
-		struct sk_buff *skb = alloc_skb(len+1,GFP_ATOMIC);
+		struct sk_buff *skb;
+
+		if (icsr0 & ICSR0_FRE) {
+			printk(KERN_ERR "pxa_ir: dropping erroneous frame\n");
+			si->stats.rx_dropped++;
+			return;
+		}
+
+		skb = alloc_skb(len+1,GFP_ATOMIC);
 		if (!skb)  {
 			printk(KERN_ERR "pxa_ir: fir out of memory for receive skb\n");
 			si->stats.rx_dropped++;
@@ -392,7 +407,7 @@ static irqreturn_t pxa_irda_fir_irq(int 
 {
 	struct net_device *dev = dev_id;
 	struct pxa_irda *si = netdev_priv(dev);
-	int icsr0;
+	int icsr0, i = 64;
 
 	/* stop RX DMA */
 	DCSR(si->rxdma) &= ~DCSR_RUN;
@@ -412,13 +427,18 @@ static irqreturn_t pxa_irda_fir_irq(int 
 
 	if (icsr0 & ICSR0_EIF) {
 		/* An error in FIFO occured, or there is a end of frame */
-		pxa_irda_fir_irq_eif(si, dev);
+		pxa_irda_fir_irq_eif(si, dev, icsr0);
 	}
 
 	ICCR0 = 0;
 	pxa_irda_fir_dma_rx_start(si);
+	while ((ICSR1 & ICSR1_RNE) && i--)
+		(void)ICDR;
 	ICCR0 = ICCR0_ITR | ICCR0_RXE;
 
+	if (i < 0)
+		printk(KERN_ERR "pxa_ir: cannot clear Rx FIFO!\n");
+
 	return IRQ_HANDLED;
 }
 
diff -purN linux-2.6.21-rc5-git6/include/asm-arm/arch-ixp4xx/io.h linux-2.6.21-rc5-git8/include/asm-arm/arch-ixp4xx/io.h
--- linux-2.6.21-rc5-git6/include/asm-arm/arch-ixp4xx/io.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/include/asm-arm/arch-ixp4xx/io.h	2007-04-02 10:27:47.045726441 +0200
@@ -238,23 +238,6 @@ __ixp4xx_readsl(const volatile void __io
 #define memcpy_fromio(a,c,l)		_memcpy_fromio((a),(c),(l))
 #define memcpy_toio(c,a,l)		_memcpy_toio((c),(a),(l))
 
-static inline int
-check_signature(const unsigned char __iomem *bus_addr, const unsigned char *signature,
-		int length)
-{
-	int retval = 0;
-	do {
-		if (readb(bus_addr) != *signature)
-			goto out;
-		bus_addr++;
-		signature++;
-		length--;
-	} while (length);
-	retval = 1;
-out:
-	return retval;
-}
-
 #endif
 
 #ifndef CONFIG_PCI
diff -purN linux-2.6.21-rc5-git6/include/asm-arm/system.h linux-2.6.21-rc5-git8/include/asm-arm/system.h
--- linux-2.6.21-rc5-git6/include/asm-arm/system.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/include/asm-arm/system.h	2007-04-02 10:27:47.045726441 +0200
@@ -3,6 +3,7 @@
 
 #ifdef __KERNEL__
 
+#include <asm/memory.h>
 
 #define CPU_ARCH_UNKNOWN	0
 #define CPU_ARCH_ARMv3		1
@@ -154,7 +155,7 @@ extern unsigned int user_debug;
 #define vectors_high()	(0)
 #endif
 
-#if __LINUX_ARM_ARCH__ >= 6
+#if defined(CONFIG_CPU_XSC3) || __LINUX_ARM_ARCH__ >= 6
 #define isb() __asm__ __volatile__ ("mcr p15, 0, %0, c7, c5, 4" \
 				    : : "r" (0) : "memory")
 #define dsb() __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" \
@@ -168,22 +169,23 @@ extern unsigned int user_debug;
 #define dmb() __asm__ __volatile__ ("" : : : "memory")
 #endif
 
-#define mb()			barrier()
-#define rmb()			barrier()
-#define wmb()			barrier()
-#define read_barrier_depends()	do { } while(0)
-
-#ifdef CONFIG_SMP
-#define smp_mb()		dmb()
-#define smp_rmb()		dmb()
-#define smp_wmb()		dmb()
-#define smp_read_barrier_depends()	read_barrier_depends()
+#ifndef CONFIG_SMP
+#define mb()	do { if (arch_is_coherent()) dmb(); else barrier(); } while (0)
+#define rmb()	do { if (arch_is_coherent()) dmb(); else barrier(); } while (0)
+#define wmb()	do { if (arch_is_coherent()) dmb(); else barrier(); } while (0)
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
 #else
-#define smp_mb()		barrier()
-#define smp_rmb()		barrier()
-#define smp_wmb()		barrier()
-#define smp_read_barrier_depends()	read_barrier_depends()
-#endif /* CONFIG_SMP */
+#define mb()		dmb()
+#define rmb()		dmb()
+#define wmb()		dmb()
+#define smp_mb()	dmb()
+#define smp_rmb()	dmb()
+#define smp_wmb()	dmb()
+#endif
+#define read_barrier_depends()		do { } while(0)
+#define smp_read_barrier_depends()	do { } while(0)
 
 #define set_mb(var, value)	do { var = value; smp_mb(); } while (0)
 #define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");
diff -purN linux-2.6.21-rc5-git6/include/asm-arm/unistd.h linux-2.6.21-rc5-git8/include/asm-arm/unistd.h
--- linux-2.6.21-rc5-git6/include/asm-arm/unistd.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/include/asm-arm/unistd.h	2007-04-02 10:27:47.045726441 +0200
@@ -372,7 +372,7 @@
 #define __NR_move_pages			(__NR_SYSCALL_BASE+344)
 #define __NR_getcpu			(__NR_SYSCALL_BASE+345)
 					/* 346 for epoll_pwait */
-#define __NR_sys_kexec_load		(__NR_SYSCALL_BASE+347)
+#define __NR_kexec_load			(__NR_SYSCALL_BASE+347)
 
 /*
  * The following SWIs are ARM private.
diff -purN linux-2.6.21-rc5-git6/include/asm-um/common.lds.S linux-2.6.21-rc5-git8/include/asm-um/common.lds.S
--- linux-2.6.21-rc5-git6/include/asm-um/common.lds.S	2007-04-02 10:27:41.385716225 +0200
+++ linux-2.6.21-rc5-git8/include/asm-um/common.lds.S	2007-04-02 10:27:47.055726459 +0200
@@ -15,7 +15,7 @@
   PROVIDE (_unprotected_end = .);
 
   . = ALIGN(4096);
-  .note : { *(note.*) }
+  .note : { *(.note.*) }
   __start___ex_table = .;
   __ex_table : { *(__ex_table) }
   __stop___ex_table = .;
diff -purN linux-2.6.21-rc5-git6/scripts/basic/fixdep.c linux-2.6.21-rc5-git8/scripts/basic/fixdep.c
--- linux-2.6.21-rc5-git6/scripts/basic/fixdep.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git8/scripts/basic/fixdep.c	2007-04-02 10:27:47.095726531 +0200
@@ -28,9 +28,11 @@
  * the dependency on linux/autoconf.h by a dependency on every config
  * option which is mentioned in any of the listed prequisites.
  *
- * To be exact, split-include populates a tree in include/config/,
- * e.g. include/config/his/driver.h, which contains the #define/#undef
- * for the CONFIG_HIS_DRIVER option.
+ * kconfig populates a tree in include/config/ with an empty file
+ * for each config symbol and when the configuration is updated
+ * the files representing changed config options are touched
+ * which then let make pick up the changes and the files that use
+ * the config symbols are rebuilt.
  *
  * So if the user changes his CONFIG_HIS_DRIVER option, only the objects
  * which depend on "include/linux/config/his/driver.h" will be rebuilt,
@@ -245,6 +247,8 @@ void parse_config_file(char *map, size_t
 		continue;
 
 	found:
+		if (!memcmp(q - 7, "_MODULE", 7))
+			q -= 7;
 		use_config(p+7, q-p-7);
 	}
 }
