From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] time: add workaround for timespec_add_ns() issuing __udivdi3
Patch-mainline: No idea, it's contentious whose problem the bug is

 This patch avoids an optimization introduced in gcc 4.3 where it will
 take a loop of subtractions and turn them into a division. Since the
 kernel doesn't support long long division by adding a __udivdi3, we
 can't use this optimization.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 include/linux/compiler-gcc4.h |    7 +++++++
 include/linux/compiler.h      |    8 ++++++++
 include/linux/time.h          |    1 +
 3 files changed, 16 insertions(+)

--- a/include/linux/compiler-gcc4.h	2007-12-02 12:32:35.000000000 -0500
+++ b/include/linux/compiler-gcc4.h	2007-12-02 12:35:15.000000000 -0500
@@ -41,5 +41,12 @@
    a special section, but I don't see any sense in this right now in
    the kernel context */
 #define __cold			__attribute__((__cold__))
+#endif
 
+#if __GNUC__ == 4 && __GNUC_MINOR__ >= 3
+/* gcc >= 4.3 may choose to replace loops explicitly formed to avoid division
+ * with division. When these are 64-bit divisions on 32-bit systems, a call
+ * to the unimplmented __udivdi3 libgcc function will be issued, causing
+ * a link error. This macro avoids issuing the call. */
+#define avoid_division(x)	asm("" : "r+" ((x)))
 #endif
--- a/include/linux/compiler.h	2007-12-02 12:21:16.000000000 -0500
+++ b/include/linux/compiler.h	2007-12-02 12:34:36.000000000 -0500
@@ -175,4 +175,12 @@ extern void __chk_io_ptr(const volatile 
 #define __cold
 #endif
 
+/* GCC >= 4.3 may choose to replace loops explicitly formed to avoid division
+ * with division. When these are 64-bit divisions on 32-bit systems, a call
+ * to the unimplmented __udivdi3 libgcc function will be issued, causing
+ * a link error. */
+#ifndef avoid_division
+# define avoid_division(x) do {} while(0)
+#endif
+
 #endif /* __LINUX_COMPILER_H */
--- a/include/linux/time.h	2007-12-02 12:21:16.000000000 -0500
+++ b/include/linux/time.h	2007-12-02 12:31:31.000000000 -0500
@@ -171,6 +171,7 @@ extern struct timeval ns_to_timeval(cons
  */
 static inline void timespec_add_ns(struct timespec *a, u64 ns)
 {
+	avoid_division(ns);
 	ns += a->tv_nsec;
 	while(unlikely(ns >= NSEC_PER_SEC)) {
 		ns -= NSEC_PER_SEC;
