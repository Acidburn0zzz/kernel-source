 MAINTAINERS                              |   17 +++
 Makefile                                 |    2 
 arch/i386/kernel/hpet.c                  |   68 +++++++++++++++
 arch/ia64/kernel/msi_ia64.c              |    2 
 arch/ia64/kernel/smpboot.c               |   17 +++
 arch/ia64/mm/init.c                      |    2 
 arch/ia64/pci/pci.c                      |    1 
 arch/mips/Kconfig                        |    2 
 arch/mips/gt64120/momenco_ocelot/prom.c  |    1 
 arch/mips/gt64120/momenco_ocelot/setup.c |    2 
 arch/mips/kernel/entry.S                 |    6 +
 arch/mips/kernel/genex.S                 |   31 +++++++
 arch/mips/kernel/smtc.c                  |   65 ++++++++++++---
 arch/mips/mm/fault.c                     |    6 -
 arch/mips/pci/pci-ev64120.c              |    1 
 arch/mips/sibyte/bcm1480/irq.c           |    4 
 arch/powerpc/sysdev/qe_lib/qe.c          |    6 -
 arch/um/drivers/chan_kern.c              |   12 +-
 arch/um/drivers/mconsole_kern.c          |    3 
 arch/um/drivers/ubd_kern.c               |   13 +--
 arch/um/include/mconsole.h               |    2 
 arch/um/kernel/mem.c                     |    3 
 arch/um/sys-i386/ldt.c                   |    3 
 arch/x86_64/kernel/i8259.c               |    6 -
 drivers/char/Kconfig                     |   33 +++++++
 drivers/isdn/gigaset/bas-gigaset.c       |    4 
 drivers/isdn/gigaset/common.c            |    6 -
 drivers/isdn/gigaset/ev-layer.c          |    4 
 drivers/isdn/gigaset/isocdata.c          |    4 
 drivers/isdn/gigaset/ser-gigaset.c       |    2 
 drivers/isdn/gigaset/usb-gigaset.c       |    4 
 drivers/net/atl1/atl1_main.c             |   10 ++
 drivers/net/bnx2.c                       |    8 -
 drivers/net/ifb.c                        |   35 +++-----
 drivers/net/netxen/netxen_nic_init.c     |    3 
 drivers/net/sis190.c                     |    1 
 fs/hostfs/hostfs_kern.c                  |   25 ++---
 fs/splice.c                              |   25 +++--
 include/asm-mips/irqflags.h              |   55 +++++-------
 include/asm-mips/marvell.h               |    1 
 include/asm-mips/smtc_ipi.h              |   16 +++
 include/asm-powerpc/immap_qe.h           |    3 
 include/asm-um/pgtable-2level.h          |    8 -
 include/asm-x86_64/hw_irq.h              |    2 
 include/linux/skbuff.h                   |    5 -
 include/net/pkt_cls.h                    |    7 +
 kernel/exit.c                            |    2 
 mm/filemap_xip.c                         |   48 ++++++++---
 mm/madvise.c                             |   19 +++-
 mm/shmem.c                               |  132 +++++++++++++++++++++++--------
 net/bluetooth/hidp/core.c                |   23 +++++
 net/core/dev.c                           |    8 -
 net/core/skbuff.c                        |    2 
 net/sched/act_mirred.c                   |    2 
 54 files changed, 563 insertions(+), 209 deletions(-)
diff -purN linux-2.6.21-rc5-git4/MAINTAINERS linux-2.6.21-rc5-git6/MAINTAINERS
--- linux-2.6.21-rc5-git4/MAINTAINERS	2007-03-30 21:19:43.424414411 +0200
+++ linux-2.6.21-rc5-git6/MAINTAINERS	2007-03-30 21:20:24.274486217 +0200
@@ -198,10 +198,25 @@ L:	linux-sound@vger.kernel.org
 W:	http://www.stud.uni-karlsruhe.de/~uh1b/
 S:	Maintained
 
+IPS SCSI RAID DRIVER
+P:	Adaptec OEM Raid Solutions
+M:	aacraid@adaptec.com
+L:	linux-scsi@vger.kernel.org
+W:	http://www.adaptec.com/
+S:	Maintained
+
+DPT_I2O SCSI RAID DRIVER
+P:	Adaptec OEM Raid Solutions
+M:	aacraid@adaptec.com
+L:	linux-scsi@vger.kernel.org
+W:	http://www.adaptec.com/
+S:	Maintained
+
 AACRAID SCSI RAID DRIVER
 P:	Adaptec OEM Raid Solutions
+M:	aacraid@adaptec.com
 L:	linux-scsi@vger.kernel.org
-W:	http://linux.dell.com/storage.shtml
+W:	http://www.adaptec.com/
 S:	Supported
 
 ACPI
diff -purN linux-2.6.21-rc5-git4/Makefile linux-2.6.21-rc5-git6/Makefile
--- linux-2.6.21-rc5-git4/Makefile	2007-03-30 21:19:43.424414411 +0200
+++ linux-2.6.21-rc5-git6/Makefile	2007-03-30 21:20:24.274486217 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 21
-EXTRAVERSION = -rc5-git4
+EXTRAVERSION = -rc5-git6
 NAME = Nocturnal Monster Puppy
 
 # *DOCUMENTATION*
diff -purN linux-2.6.21-rc5-git4/arch/i386/kernel/hpet.c linux-2.6.21-rc5-git6/arch/i386/kernel/hpet.c
--- linux-2.6.21-rc5-git4/arch/i386/kernel/hpet.c	2007-03-30 21:19:43.424414411 +0200
+++ linux-2.6.21-rc5-git6/arch/i386/kernel/hpet.c	2007-03-30 21:20:24.284486235 +0200
@@ -3,6 +3,8 @@
 #include <linux/errno.h>
 #include <linux/hpet.h>
 #include <linux/init.h>
+#include <linux/sysdev.h>
+#include <linux/pm.h>
 
 #include <asm/hpet.h>
 #include <asm/io.h>
@@ -307,6 +309,7 @@ int __init hpet_enable(void)
 out_nohpet:
 	iounmap(hpet_virt_address);
 	hpet_virt_address = NULL;
+	boot_hpet_disable = 1;
 	return 0;
 }
 
@@ -521,3 +524,68 @@ irqreturn_t hpet_rtc_interrupt(int irq, 
 	return IRQ_HANDLED;
 }
 #endif
+
+
+/*
+ * Suspend/resume part
+ */
+
+#ifdef CONFIG_PM
+
+static int hpet_suspend(struct sys_device *sys_device, pm_message_t state)
+{
+	unsigned long cfg = hpet_readl(HPET_CFG);
+
+	cfg &= ~(HPET_CFG_ENABLE|HPET_CFG_LEGACY);
+	hpet_writel(cfg, HPET_CFG);
+
+	return 0;
+}
+
+static int hpet_resume(struct sys_device *sys_device)
+{
+	unsigned int id;
+
+	hpet_start_counter();
+
+	id = hpet_readl(HPET_ID);
+
+	if (id & HPET_ID_LEGSUP)
+		hpet_enable_int();
+
+	return 0;
+}
+
+static struct sysdev_class hpet_class = {
+	set_kset_name("hpet"),
+	.suspend	= hpet_suspend,
+	.resume		= hpet_resume,
+};
+
+static struct sys_device hpet_device = {
+	.id		= 0,
+	.cls		= &hpet_class,
+};
+
+
+static __init int hpet_register_sysfs(void)
+{
+	int err;
+
+	if (!is_hpet_capable())
+		return 0;
+
+	err = sysdev_class_register(&hpet_class);
+
+	if (!err) {
+		err = sysdev_register(&hpet_device);
+		if (err)
+			sysdev_class_unregister(&hpet_class);
+	}
+
+	return err;
+}
+
+device_initcall(hpet_register_sysfs);
+
+#endif
diff -purN linux-2.6.21-rc5-git4/arch/ia64/kernel/msi_ia64.c linux-2.6.21-rc5-git6/arch/ia64/kernel/msi_ia64.c
--- linux-2.6.21-rc5-git4/arch/ia64/kernel/msi_ia64.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/ia64/kernel/msi_ia64.c	2007-03-30 21:20:24.284486235 +0200
@@ -68,7 +68,7 @@ int ia64_setup_msi_irq(struct pci_dev *p
 {
 	struct msi_msg	msg;
 	unsigned long	dest_phys_id;
-	unsigned int	irq, vector;
+	int	irq, vector;
 
 	irq = create_irq();
 	if (irq < 0)
diff -purN linux-2.6.21-rc5-git4/arch/ia64/kernel/smpboot.c linux-2.6.21-rc5-git6/arch/ia64/kernel/smpboot.c
--- linux-2.6.21-rc5-git4/arch/ia64/kernel/smpboot.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/ia64/kernel/smpboot.c	2007-03-30 21:20:24.284486235 +0200
@@ -375,6 +375,7 @@ static void __devinit
 smp_callin (void)
 {
 	int cpuid, phys_id, itc_master;
+	struct cpuinfo_ia64 *last_cpuinfo, *this_cpuinfo;
 	extern void ia64_init_itm(void);
 	extern volatile int time_keeper_id;
 
@@ -424,7 +425,21 @@ smp_callin (void)
 	 * Get our bogomips.
 	 */
 	ia64_init_itm();
-	calibrate_delay();
+
+	/*
+	 * Delay calibration can be skipped if new processor is identical to the
+	 * previous processor.
+	 */
+	last_cpuinfo = cpu_data(cpuid - 1);
+	this_cpuinfo = local_cpu_data;
+	if (last_cpuinfo->itc_freq != this_cpuinfo->itc_freq ||
+	    last_cpuinfo->proc_freq != this_cpuinfo->proc_freq ||
+	    last_cpuinfo->features != this_cpuinfo->features ||
+	    last_cpuinfo->revision != this_cpuinfo->revision ||
+	    last_cpuinfo->family != this_cpuinfo->family ||
+	    last_cpuinfo->archrev != this_cpuinfo->archrev ||
+	    last_cpuinfo->model != this_cpuinfo->model)
+		calibrate_delay();
 	local_cpu_data->loops_per_jiffy = loops_per_jiffy;
 
 #ifdef CONFIG_IA32_SUPPORT
diff -purN linux-2.6.21-rc5-git4/arch/ia64/mm/init.c linux-2.6.21-rc5-git6/arch/ia64/mm/init.c
--- linux-2.6.21-rc5-git4/arch/ia64/mm/init.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/ia64/mm/init.c	2007-03-30 21:20:24.284486235 +0200
@@ -155,7 +155,7 @@ ia64_set_rbs_bot (void)
 
 	if (stack_size > MAX_USER_STACK_SIZE)
 		stack_size = MAX_USER_STACK_SIZE;
-	current->thread.rbs_bot = STACK_TOP - stack_size;
+	current->thread.rbs_bot = PAGE_ALIGN(current->mm->start_stack - stack_size);
 }
 
 /*
diff -purN linux-2.6.21-rc5-git4/arch/ia64/pci/pci.c linux-2.6.21-rc5-git6/arch/ia64/pci/pci.c
--- linux-2.6.21-rc5-git4/arch/ia64/pci/pci.c	2007-03-30 21:19:43.424414411 +0200
+++ linux-2.6.21-rc5-git6/arch/ia64/pci/pci.c	2007-03-30 21:20:24.284486235 +0200
@@ -568,7 +568,6 @@ pcibios_disable_device (struct pci_dev *
 	BUG_ON(atomic_read(&dev->enable_cnt));
 	if (!dev->msi_enabled)
 		acpi_pci_irq_disable(dev);
-	return 0;
 }
 
 void
diff -purN linux-2.6.21-rc5-git4/arch/mips/Kconfig linux-2.6.21-rc5-git6/arch/mips/Kconfig
--- linux-2.6.21-rc5-git4/arch/mips/Kconfig	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/Kconfig	2007-03-30 21:20:24.284486235 +0200
@@ -1606,7 +1606,7 @@ config MIPS_MT_FPAFF
 
 config MIPS_MT_SMTC_INSTANT_REPLAY
 	bool "Low-latency Dispatch of Deferred SMTC IPIs"
-	depends on MIPS_MT_SMTC
+	depends on MIPS_MT_SMTC && !PREEMPT
 	default y
 	help
 	  SMTC pseudo-interrupts between TCs are deferred and queued
diff -purN linux-2.6.21-rc5-git4/arch/mips/gt64120/momenco_ocelot/prom.c linux-2.6.21-rc5-git6/arch/mips/gt64120/momenco_ocelot/prom.c
--- linux-2.6.21-rc5-git4/arch/mips/gt64120/momenco_ocelot/prom.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/gt64120/momenco_ocelot/prom.c	2007-03-30 21:20:24.284486235 +0200
@@ -32,7 +32,6 @@ void __init prom_init(void)
 	char **arg = (char **) fw_arg1;
 	char **env = (char **) fw_arg2;
 	struct callvectors *cv = (struct callvectors *) fw_arg3;
-	uint32_t tmp;
 	int i;
 
 	/* save the PROM vectors for debugging use */
diff -purN linux-2.6.21-rc5-git4/arch/mips/gt64120/momenco_ocelot/setup.c linux-2.6.21-rc5-git6/arch/mips/gt64120/momenco_ocelot/setup.c
--- linux-2.6.21-rc5-git4/arch/mips/gt64120/momenco_ocelot/setup.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/gt64120/momenco_ocelot/setup.c	2007-03-30 21:20:24.284486235 +0200
@@ -79,7 +79,7 @@ static char reset_reason;
 static void __init setup_l3cache(unsigned long size);
 
 /* setup code for a handoff from a version 1 PMON 2000 PROM */
-void PMON_v1_setup()
+static void PMON_v1_setup(void)
 {
 	/* A wired TLB entry for the GT64120A and the serial port. The
 	   GT64120A is going to be hit on every IRQ anyway - there's
diff -purN linux-2.6.21-rc5-git4/arch/mips/kernel/entry.S linux-2.6.21-rc5-git6/arch/mips/kernel/entry.S
--- linux-2.6.21-rc5-git4/arch/mips/kernel/entry.S	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/kernel/entry.S	2007-03-30 21:20:24.284486235 +0200
@@ -121,7 +121,11 @@ FEXPORT(restore_partial)		# restore part
 	SAVE_AT
 	SAVE_TEMP
 	LONG_L	v0, PT_STATUS(sp)
-	and	v0, 1
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+	and	v0, ST0_IEP
+#else
+	and	v0, ST0_IE
+#endif
 	beqz	v0, 1f
 	jal	trace_hardirqs_on
 	b	2f
diff -purN linux-2.6.21-rc5-git4/arch/mips/kernel/genex.S linux-2.6.21-rc5-git6/arch/mips/kernel/genex.S
--- linux-2.6.21-rc5-git4/arch/mips/kernel/genex.S	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/kernel/genex.S	2007-03-30 21:20:24.284486235 +0200
@@ -128,6 +128,37 @@ handle_vcei:
 
 	.align  5
 NESTED(handle_int, PT_SIZE, sp)
+#ifdef CONFIG_TRACE_IRQFLAGS
+	/*
+	 * Check to see if the interrupted code has just disabled
+	 * interrupts and ignore this interrupt for now if so.
+	 *
+	 * local_irq_disable() disables interrupts and then calls
+	 * trace_hardirqs_off() to track the state. If an interrupt is taken
+	 * after interrupts are disabled but before the state is updated
+	 * it will appear to restore_all that it is incorrectly returning with
+	 * interrupts disabled
+	 */
+	.set	push
+	.set	noat
+	mfc0	k0, CP0_STATUS
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+	and	k0, ST0_IEP
+	bnez	k0, 1f
+
+	mfc0	k0, EP0_EPC
+	.set	noreorder
+	j	k0
+	rfe
+#else
+	and	k0, ST0_IE
+	bnez	k0, 1f
+
+	eret
+#endif
+1:
+	.set pop
+#endif
 	SAVE_ALL
 	CLI
 	TRACE_IRQS_OFF
diff -purN linux-2.6.21-rc5-git4/arch/mips/kernel/smtc.c linux-2.6.21-rc5-git6/arch/mips/kernel/smtc.c
--- linux-2.6.21-rc5-git4/arch/mips/kernel/smtc.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/kernel/smtc.c	2007-03-30 21:20:24.284486235 +0200
@@ -4,6 +4,7 @@
 #include <linux/sched.h>
 #include <linux/cpumask.h>
 #include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
 #include <linux/module.h>
 
 #include <asm/cpu.h>
@@ -14,6 +15,7 @@
 #include <asm/hazards.h>
 #include <asm/mmu_context.h>
 #include <asm/smp.h>
+#include <asm/mips-boards/maltaint.h>
 #include <asm/mipsregs.h>
 #include <asm/cacheflush.h>
 #include <asm/time.h>
@@ -75,7 +77,7 @@ static struct smtc_ipi_q freeIPIq;
 
 void ipi_decode(struct smtc_ipi *);
 static void post_direct_ipi(int cpu, struct smtc_ipi *pipi);
-static void setup_cross_vpe_interrupts(void);
+static void setup_cross_vpe_interrupts(unsigned int nvpe);
 void init_smtc_stats(void);
 
 /* Global SMTC Status */
@@ -168,7 +170,10 @@ __setup("tintq=", tintq);
 
 int imstuckcount[2][8];
 /* vpemask represents IM/IE bits of per-VPE Status registers, low-to-high */
-int vpemask[2][8] = {{0,1,1,0,0,0,0,1},{0,1,0,0,0,0,0,1}};
+int vpemask[2][8] = {
+	{0, 0, 1, 0, 0, 0, 0, 1},
+	{0, 0, 0, 0, 0, 0, 0, 1}
+};
 int tcnoprog[NR_CPUS];
 static atomic_t idle_hook_initialized = {0};
 static int clock_hang_reported[NR_CPUS];
@@ -501,8 +506,7 @@ void mipsmt_prepare_cpus(void)
 
 	/* If we have multiple VPEs running, set up the cross-VPE interrupt */
 
-	if (nvpe > 1)
-		setup_cross_vpe_interrupts();
+	setup_cross_vpe_interrupts(nvpe);
 
 	/* Set up queue of free IPI "messages". */
 	nipi = NR_CPUS * IPIBUF_PER_CPU;
@@ -607,7 +611,12 @@ void smtc_cpus_done(void)
 int setup_irq_smtc(unsigned int irq, struct irqaction * new,
 			unsigned long hwmask)
 {
+	unsigned int vpe = current_cpu_data.vpe_id;
+
 	irq_hwmask[irq] = hwmask;
+#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
+	vpemask[vpe][irq - MIPSCPU_INT_BASE] = 1;
+#endif
 
 	return setup_irq(irq, new);
 }
@@ -812,12 +821,15 @@ void ipi_decode(struct smtc_ipi *pipi)
 	smtc_ipi_nq(&freeIPIq, pipi);
 	switch (type_copy) {
 	case SMTC_CLOCK_TICK:
+		irq_enter();
+		kstat_this_cpu.irqs[MIPSCPU_INT_BASE + MIPSCPU_INT_CPUCTR]++;
 		/* Invoke Clock "Interrupt" */
 		ipi_timer_latch[dest_copy] = 0;
 #ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
 		clock_hang_reported[dest_copy] = 0;
 #endif /* CONFIG_SMTC_IDLE_HOOK_DEBUG */
 		local_timer_interrupt(0, NULL);
+		irq_exit();
 		break;
 	case LINUX_SMP_IPI:
 		switch ((int)arg_copy) {
@@ -965,8 +977,11 @@ static void ipi_irq_dispatch(void)
 
 static struct irqaction irq_ipi;
 
-static void setup_cross_vpe_interrupts(void)
+static void setup_cross_vpe_interrupts(unsigned int nvpe)
 {
+	if (nvpe < 1)
+		return;
+
 	if (!cpu_has_vint)
 		panic("SMTC Kernel requires Vectored Interupt support");
 
@@ -984,10 +999,17 @@ static void setup_cross_vpe_interrupts(v
 
 /*
  * SMTC-specific hacks invoked from elsewhere in the kernel.
+ *
+ * smtc_ipi_replay is called from raw_local_irq_restore which is only ever
+ * called with interrupts disabled.  We do rely on interrupts being disabled
+ * here because using spin_lock_irqsave()/spin_unlock_irqrestore() would
+ * result in a recursive call to raw_local_irq_restore().
  */
 
-void smtc_ipi_replay(void)
+static void __smtc_ipi_replay(void)
 {
+	unsigned int cpu = smp_processor_id();
+
 	/*
 	 * To the extent that we've ever turned interrupts off,
 	 * we may have accumulated deferred IPIs.  This is subtle.
@@ -1002,17 +1024,30 @@ void smtc_ipi_replay(void)
 	 * is clear, and we'll handle it as a real pseudo-interrupt
 	 * and not a pseudo-pseudo interrupt.
 	 */
-	if (IPIQ[smp_processor_id()].depth > 0) {
-		struct smtc_ipi *pipi;
-		extern void self_ipi(struct smtc_ipi *);
+	if (IPIQ[cpu].depth > 0) {
+		while (1) {
+			struct smtc_ipi_q *q = &IPIQ[cpu];
+			struct smtc_ipi *pipi;
+			extern void self_ipi(struct smtc_ipi *);
+
+			spin_lock(&q->lock);
+			pipi = __smtc_ipi_dq(q);
+			spin_unlock(&q->lock);
+			if (!pipi)
+				break;
 
-		while ((pipi = smtc_ipi_dq(&IPIQ[smp_processor_id()]))) {
 			self_ipi(pipi);
-			smtc_cpu_stats[smp_processor_id()].selfipis++;
+			smtc_cpu_stats[cpu].selfipis++;
 		}
 	}
 }
 
+void smtc_ipi_replay(void)
+{
+	raw_local_irq_disable();
+	__smtc_ipi_replay();
+}
+
 EXPORT_SYMBOL(smtc_ipi_replay);
 
 void smtc_idle_loop_hook(void)
@@ -1117,7 +1152,13 @@ void smtc_idle_loop_hook(void)
 	 * is in use, there should never be any.
 	 */
 #ifndef CONFIG_MIPS_MT_SMTC_INSTANT_REPLAY
-	smtc_ipi_replay();
+	{
+		unsigned long flags;
+
+		local_irq_save(flags);
+		__smtc_ipi_replay();
+		local_irq_restore(flags);
+	}
 #endif /* CONFIG_MIPS_MT_SMTC_INSTANT_REPLAY */
 }
 
diff -purN linux-2.6.21-rc5-git4/arch/mips/mm/fault.c linux-2.6.21-rc5-git6/arch/mips/mm/fault.c
--- linux-2.6.21-rc5-git4/arch/mips/mm/fault.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/mm/fault.c	2007-03-30 21:20:24.284486235 +0200
@@ -42,7 +42,7 @@ asmlinkage void do_page_fault(struct pt_
 	siginfo_t info;
 
 #if 0
-	printk("Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\n", smp_processor_id(),
+	printk("Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\n", raw_smp_processor_id(),
 	       current->comm, current->pid, field, address, write,
 	       field, regs->cp0_epc);
 #endif
@@ -165,7 +165,7 @@ no_context:
 
 	printk(KERN_ALERT "CPU %d Unable to handle kernel paging request at "
 	       "virtual address %0*lx, epc == %0*lx, ra == %0*lx\n",
-	       smp_processor_id(), field, address, field, regs->cp0_epc,
+	       raw_smp_processor_id(), field, address, field, regs->cp0_epc,
 	       field,  regs->regs[31]);
 	die("Oops", regs);
 
@@ -228,7 +228,7 @@ vmalloc_fault:
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 
-		pgd = (pgd_t *) pgd_current[smp_processor_id()] + offset;
+		pgd = (pgd_t *) pgd_current[raw_smp_processor_id()] + offset;
 		pgd_k = init_mm.pgd + offset;
 
 		if (!pgd_present(*pgd_k))
diff -purN linux-2.6.21-rc5-git4/arch/mips/pci/pci-ev64120.c linux-2.6.21-rc5-git6/arch/mips/pci/pci-ev64120.c
--- linux-2.6.21-rc5-git4/arch/mips/pci/pci-ev64120.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/pci/pci-ev64120.c	2007-03-30 21:20:24.284486235 +0200
@@ -1,4 +1,5 @@
 #include <linux/pci.h>
+#include <asm/irq.h>
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
diff -purN linux-2.6.21-rc5-git4/arch/mips/sibyte/bcm1480/irq.c linux-2.6.21-rc5-git6/arch/mips/sibyte/bcm1480/irq.c
--- linux-2.6.21-rc5-git4/arch/mips/sibyte/bcm1480/irq.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/mips/sibyte/bcm1480/irq.c	2007-03-30 21:20:24.284486235 +0200
@@ -141,11 +141,11 @@ static void bcm1480_set_affinity(unsigne
 	unsigned long flags;
 	unsigned int irq_dirty;
 
-	i = first_cpu(mask);
-	if (next_cpu(i, mask) <= NR_CPUS) {
+	if (cpus_weight(mask) != 1) {
 		printk("attempted to set irq affinity for irq %d to multiple CPUs\n", irq);
 		return;
 	}
+	i = first_cpu(mask);
 
 	/* Convert logical CPU to physical CPU */
 	cpu = cpu_logical_map(i);
diff -purN linux-2.6.21-rc5-git4/arch/powerpc/sysdev/qe_lib/qe.c linux-2.6.21-rc5-git6/arch/powerpc/sysdev/qe_lib/qe.c
--- linux-2.6.21-rc5-git4/arch/powerpc/sysdev/qe_lib/qe.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/powerpc/sysdev/qe_lib/qe.c	2007-03-30 21:20:24.284486235 +0200
@@ -251,13 +251,13 @@ static int qe_sdma_init(void)
 
 	/* allocate 2 internal temporary buffers (512 bytes size each) for
 	 * the SDMA */
-	sdma_buf_offset = qe_muram_alloc(512 * 2, 64);
+ 	sdma_buf_offset = qe_muram_alloc(512 * 2, 4096);
 	if (IS_MURAM_ERR(sdma_buf_offset))
 		return -ENOMEM;
 
 	out_be32(&sdma->sdebcr, sdma_buf_offset & QE_SDEBCR_BA_MASK);
-	out_be32(&sdma->sdmr, (QE_SDMR_GLB_1_MSK | (0x1 >>
-					QE_SDMR_CEN_SHIFT)));
+ 	out_be32(&sdma->sdmr, (QE_SDMR_GLB_1_MSK |
+ 					(0x1 << QE_SDMR_CEN_SHIFT)));
 
 	return 0;
 }
diff -purN linux-2.6.21-rc5-git4/arch/um/drivers/chan_kern.c linux-2.6.21-rc5-git6/arch/um/drivers/chan_kern.c
--- linux-2.6.21-rc5-git4/arch/um/drivers/chan_kern.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/um/drivers/chan_kern.c	2007-03-30 21:20:24.294486253 +0200
@@ -236,11 +236,11 @@ void free_irqs(void)
 	struct chan *chan;
 	LIST_HEAD(list);
 	struct list_head *ele;
+	unsigned long flags;
 
-	spin_lock_irq(&irqs_to_free_lock);
+	spin_lock_irqsave(&irqs_to_free_lock, flags);
 	list_splice_init(&irqs_to_free, &list);
-	INIT_LIST_HEAD(&irqs_to_free);
-	spin_unlock_irq(&irqs_to_free_lock);
+	spin_unlock_irqrestore(&irqs_to_free_lock, flags);
 
 	list_for_each(ele, &list){
 		chan = list_entry(ele, struct chan, free_list);
@@ -255,13 +255,15 @@ void free_irqs(void)
 
 static void close_one_chan(struct chan *chan, int delay_free_irq)
 {
+	unsigned long flags;
+
 	if(!chan->opened)
 		return;
 
 	if(delay_free_irq){
-		spin_lock_irq(&irqs_to_free_lock);
+		spin_lock_irqsave(&irqs_to_free_lock, flags);
 		list_add(&chan->free_list, &irqs_to_free);
-		spin_unlock_irq(&irqs_to_free_lock);
+		spin_unlock_irqrestore(&irqs_to_free_lock, flags);
 	}
 	else {
 		if(chan->input)
diff -purN linux-2.6.21-rc5-git4/arch/um/drivers/mconsole_kern.c linux-2.6.21-rc5-git6/arch/um/drivers/mconsole_kern.c
--- linux-2.6.21-rc5-git4/arch/um/drivers/mconsole_kern.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/um/drivers/mconsole_kern.c	2007-03-30 21:20:24.294486253 +0200
@@ -615,6 +615,9 @@ void mconsole_remove(struct mc_request *
 	err_msg = NULL;
 	err = (*dev->remove)(n, &err_msg);
 	switch(err){
+	case 0:
+		err_msg = "";
+		break;
 	case -ENODEV:
 		if(err_msg == NULL)
 			err_msg = "Device doesn't exist";
diff -purN linux-2.6.21-rc5-git4/arch/um/drivers/ubd_kern.c linux-2.6.21-rc5-git6/arch/um/drivers/ubd_kern.c
--- linux-2.6.21-rc5-git4/arch/um/drivers/ubd_kern.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/um/drivers/ubd_kern.c	2007-03-30 21:20:24.294486253 +0200
@@ -109,10 +109,6 @@ static inline void ubd_set_bit(__u64 bit
 
 static DEFINE_MUTEX(ubd_lock);
 
-/* XXX - this made sense in 2.4 days, now it's only used as a boolean, and
- * probably it doesn't make sense even for that. */
-static int do_ubd;
-
 static int ubd_open(struct inode * inode, struct file * filp);
 static int ubd_release(struct inode * inode, struct file * file);
 static int ubd_ioctl(struct inode * inode, struct file * file,
@@ -169,6 +165,7 @@ struct ubd {
 	struct platform_device pdev;
 	struct request_queue *queue;
 	spinlock_t lock;
+	int active;
 };
 
 #define DEFAULT_COW { \
@@ -190,6 +187,7 @@ struct ubd {
 	.shared =		0, \
         .cow =			DEFAULT_COW, \
 	.lock =			SPIN_LOCK_UNLOCKED,	\
+	.active =		0, \
 }
 
 /* Protected by ubd_lock */
@@ -507,7 +505,6 @@ static void ubd_handler(void)
 	struct ubd *dev;
 	int n;
 
-	do_ubd = 0;
 	n = os_read_file(thread_fd, &req, sizeof(req));
 	if(n != sizeof(req)){
 		printk(KERN_ERR "Pid %d - spurious interrupt in ubd_handler, "
@@ -517,6 +514,7 @@ static void ubd_handler(void)
 
 	rq = req.req;
 	dev = rq->rq_disk->private_data;
+	dev->active = 0;
 
 	ubd_finish(rq, req.error);
 	reactivate_fd(thread_fd, UBD_IRQ);
@@ -1081,11 +1079,12 @@ static void do_ubd_request(request_queue
 		}
 	}
 	else {
-		if(do_ubd || (req = elv_next_request(q)) == NULL)
+		struct ubd *dev = q->queuedata;
+		if(dev->active || (req = elv_next_request(q)) == NULL)
 			return;
 		err = prepare_request(req, &io_req);
 		if(!err){
-			do_ubd = 1;
+			dev->active = 1;
 			n = os_write_file(thread_fd, (char *) &io_req,
 					 sizeof(io_req));
 			if(n != sizeof(io_req))
diff -purN linux-2.6.21-rc5-git4/arch/um/include/mconsole.h linux-2.6.21-rc5-git6/arch/um/include/mconsole.h
--- linux-2.6.21-rc5-git4/arch/um/include/mconsole.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/um/include/mconsole.h	2007-03-30 21:20:24.294486253 +0200
@@ -12,6 +12,8 @@
 #define u32 uint32_t
 #endif
 
+#include "sysdep/ptrace.h"
+
 #define MCONSOLE_MAGIC (0xcafebabe)
 #define MCONSOLE_MAX_DATA (512)
 #define MCONSOLE_VERSION 2
diff -purN linux-2.6.21-rc5-git4/arch/um/kernel/mem.c linux-2.6.21-rc5-git6/arch/um/kernel/mem.c
--- linux-2.6.21-rc5-git4/arch/um/kernel/mem.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/um/kernel/mem.c	2007-03-30 21:20:24.294486253 +0200
@@ -64,8 +64,6 @@ static void setup_highmem(unsigned long 
 
 void mem_init(void)
 {
-	max_low_pfn = (high_physmem - uml_physmem) >> PAGE_SHIFT;
-
 	/* clear the zero-page */
 	memset((void *) empty_zero_page, 0, PAGE_SIZE);
 
@@ -80,6 +78,7 @@ void mem_init(void)
 
 	/* this will put all low memory onto the freelists */
 	totalram_pages = free_all_bootmem();
+	max_low_pfn = totalram_pages;
 #ifdef CONFIG_HIGHMEM
 	totalhigh_pages = highmem >> PAGE_SHIFT;
 	totalram_pages += totalhigh_pages;
diff -purN linux-2.6.21-rc5-git4/arch/um/sys-i386/ldt.c linux-2.6.21-rc5-git6/arch/um/sys-i386/ldt.c
--- linux-2.6.21-rc5-git4/arch/um/sys-i386/ldt.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/um/sys-i386/ldt.c	2007-03-30 21:20:24.294486253 +0200
@@ -394,7 +394,8 @@ static short * host_ldt_entries = NULL;
 static void ldt_get_host_info(void)
 {
 	long ret;
-	struct ldt_entry * ldt, *tmp;
+	struct ldt_entry * ldt;
+	short *tmp;
 	int i, size, k, order;
 
 	spin_lock(&host_ldt_lock);
diff -purN linux-2.6.21-rc5-git4/arch/x86_64/kernel/i8259.c linux-2.6.21-rc5-git6/arch/x86_64/kernel/i8259.c
--- linux-2.6.21-rc5-git4/arch/x86_64/kernel/i8259.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/arch/x86_64/kernel/i8259.c	2007-03-30 21:20:24.294486253 +0200
@@ -45,7 +45,7 @@
 
 /*
  * ISA PIC or low IO-APIC triggered (INTA-cycle or APIC) interrupts:
- * (these are usually mapped to vectors 0x20-0x2f)
+ * (these are usually mapped to vectors 0x30-0x3f)
  */
 
 /*
@@ -299,7 +299,7 @@ void init_8259A(int auto_eoi)
 	 * outb_p - this has to work on a wide range of PC hardware.
 	 */
 	outb_p(0x11, 0x20);	/* ICW1: select 8259A-1 init */
-	outb_p(IRQ0_VECTOR, 0x21);	/* ICW2: 8259A-1 IR0-7 mapped to 0x20-0x27 */
+	outb_p(IRQ0_VECTOR, 0x21);	/* ICW2: 8259A-1 IR0-7 mapped to 0x30-0x37 */
 	outb_p(0x04, 0x21);	/* 8259A-1 (the master) has a slave on IR2 */
 	if (auto_eoi)
 		outb_p(0x03, 0x21);	/* master does Auto EOI */
@@ -307,7 +307,7 @@ void init_8259A(int auto_eoi)
 		outb_p(0x01, 0x21);	/* master expects normal EOI */
 
 	outb_p(0x11, 0xA0);	/* ICW1: select 8259A-2 init */
-	outb_p(IRQ8_VECTOR, 0xA1);	/* ICW2: 8259A-2 IR0-7 mapped to 0x28-0x2f */
+	outb_p(IRQ8_VECTOR, 0xA1);	/* ICW2: 8259A-2 IR0-7 mapped to 0x38-0x3f */
 	outb_p(0x02, 0xA1);	/* 8259A-2 is a slave on master's IR2 */
 	outb_p(0x01, 0xA1);	/* (slave's support for AEOI in flat mode
 				    is to be investigated) */
diff -purN linux-2.6.21-rc5-git4/drivers/char/Kconfig linux-2.6.21-rc5-git6/drivers/char/Kconfig
--- linux-2.6.21-rc5-git4/drivers/char/Kconfig	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/char/Kconfig	2007-03-30 21:20:24.304486270 +0200
@@ -386,6 +386,39 @@ config AU1000_SERIAL_CONSOLE
 	  If you have an Alchemy AU1000 processor (MIPS based) and you want
 	  to use a console on a serial port, say Y.  Otherwise, say N.
 
+config SERIAL_DEC
+	bool "DECstation serial support"
+	depends on MACH_DECSTATION
+	default y
+	help
+	  This selects whether you want to be asked about drivers for
+	  DECstation serial ports.
+
+	  Note that the answer to this question won't directly affect the
+	  kernel: saying N will just cause the configurator to skip all
+	  the questions about DECstation serial ports.
+
+config SERIAL_DEC_CONSOLE
+	bool "Support for console on a DECstation serial port"
+	depends on SERIAL_DEC
+	default y
+	help
+	  If you say Y here, it will be possible to use a serial port as the
+	  system console (the system console is the device which receives all
+	  kernel messages and warnings and which allows logins in single user
+	  mode).  Note that the firmware uses ttyS0 as the serial console on
+	  the Maxine and ttyS2 on the others.
+
+	  If unsure, say Y.
+
+config ZS
+	bool "Z85C30 Serial Support"
+	depends on SERIAL_DEC
+	default y
+	help
+	  Documentation on the Zilog 85C350 serial communications controller
+	  is downloadable at <http://www.zilog.com/pdfs/serial/z85c30.pdf>
+
 config A2232
 	tristate "Commodore A2232 serial support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && ZORRO && BROKEN_ON_SMP
diff -purN linux-2.6.21-rc5-git4/drivers/isdn/gigaset/bas-gigaset.c linux-2.6.21-rc5-git6/drivers/isdn/gigaset/bas-gigaset.c
--- linux-2.6.21-rc5-git4/drivers/isdn/gigaset/bas-gigaset.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/isdn/gigaset/bas-gigaset.c	2007-03-30 21:20:24.324486305 +0200
@@ -54,7 +54,7 @@ MODULE_PARM_DESC(cidmode, "Call-ID mode"
 #define USB_SX353_PRODUCT_ID    0x0022
 
 /* table of devices that work with this driver */
-static struct usb_device_id gigaset_table [] = {
+static const struct usb_device_id gigaset_table [] = {
 	{ USB_DEVICE(USB_GIGA_VENDOR_ID, USB_3070_PRODUCT_ID) },
 	{ USB_DEVICE(USB_GIGA_VENDOR_ID, USB_3075_PRODUCT_ID) },
 	{ USB_DEVICE(USB_GIGA_VENDOR_ID, USB_SX303_PRODUCT_ID) },
@@ -2305,7 +2305,7 @@ static void gigaset_disconnect(struct us
 	gigaset_unassign(cs);
 }
 
-static struct gigaset_ops gigops = {
+static const struct gigaset_ops gigops = {
 	gigaset_write_cmd,
 	gigaset_write_room,
 	gigaset_chars_in_buffer,
diff -purN linux-2.6.21-rc5-git4/drivers/isdn/gigaset/common.c linux-2.6.21-rc5-git6/drivers/isdn/gigaset/common.c
--- linux-2.6.21-rc5-git4/drivers/isdn/gigaset/common.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/isdn/gigaset/common.c	2007-03-30 21:20:24.324486305 +0200
@@ -944,8 +944,8 @@ static DEFINE_SPINLOCK(driver_lock);
 struct cardstate *gigaset_get_cs_by_id(int id)
 {
 	unsigned long flags;
-	static struct cardstate *ret = NULL;
-	static struct cardstate *cs;
+	struct cardstate *ret = NULL;
+	struct cardstate *cs;
 	struct gigaset_driver *drv;
 	unsigned i;
 
@@ -999,7 +999,7 @@ void gigaset_debugdrivers(void)
 static struct cardstate *gigaset_get_cs_by_minor(unsigned minor)
 {
 	unsigned long flags;
-	static struct cardstate *ret = NULL;
+	struct cardstate *ret = NULL;
 	struct gigaset_driver *drv;
 	unsigned index;
 
diff -purN linux-2.6.21-rc5-git4/drivers/isdn/gigaset/ev-layer.c linux-2.6.21-rc5-git6/drivers/isdn/gigaset/ev-layer.c
--- linux-2.6.21-rc5-git4/drivers/isdn/gigaset/ev-layer.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/isdn/gigaset/ev-layer.c	2007-03-30 21:20:24.324486305 +0200
@@ -409,7 +409,7 @@ static struct reply_t tab_cid[] = /* no 
 };
 #endif
 
-static struct resp_type_t resp_type[]=
+static const struct resp_type_t resp_type[] =
 {
 	/*{"",		RSP_EMPTY,	RT_NOTHING},*/
 	{"OK",		RSP_OK,		RT_NOTHING},
@@ -511,7 +511,7 @@ void gigaset_handle_modem_response(struc
 	unsigned char *argv[MAX_REC_PARAMS + 1];
 	int params;
 	int i, j;
-	struct resp_type_t *rt;
+	const struct resp_type_t *rt;
 	int curarg;
 	unsigned long flags;
 	unsigned next, tail, head;
diff -purN linux-2.6.21-rc5-git4/drivers/isdn/gigaset/isocdata.c linux-2.6.21-rc5-git6/drivers/isdn/gigaset/isocdata.c
--- linux-2.6.21-rc5-git4/drivers/isdn/gigaset/isocdata.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/isdn/gigaset/isocdata.c	2007-03-30 21:20:24.324486305 +0200
@@ -274,7 +274,7 @@ static inline void dump_bytes(enum debug
  *        bit 12..10 = number of trailing '1' bits in result
  *        bit 14..13 = number of bits added by stuffing
  */
-static u16 stufftab[5 * 256] = {
+static const u16 stufftab[5 * 256] = {
 // previous 1s = 0:
  0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
  0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x201f,
@@ -629,7 +629,7 @@ static inline void hdlc_frag(struct bc_s
  *		     (replacing 8 by 7 to make it fit; the algorithm won't care)
  *        bit 7 set if there are 5 or more "interior" consecutive '1' bits
  */
-static unsigned char bitcounts[256] = {
+static const unsigned char bitcounts[256] = {
   0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
   0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
   0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
diff -purN linux-2.6.21-rc5-git4/drivers/isdn/gigaset/ser-gigaset.c linux-2.6.21-rc5-git6/drivers/isdn/gigaset/ser-gigaset.c
--- linux-2.6.21-rc5-git4/drivers/isdn/gigaset/ser-gigaset.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/isdn/gigaset/ser-gigaset.c	2007-03-30 21:20:24.324486305 +0200
@@ -459,7 +459,7 @@ static int gigaset_set_line_ctrl(struct 
 	return -EINVAL;
 }
 
-static struct gigaset_ops ops = {
+static const struct gigaset_ops ops = {
 	gigaset_write_cmd,
 	gigaset_write_room,
 	gigaset_chars_in_buffer,
diff -purN linux-2.6.21-rc5-git4/drivers/isdn/gigaset/usb-gigaset.c linux-2.6.21-rc5-git6/drivers/isdn/gigaset/usb-gigaset.c
--- linux-2.6.21-rc5-git4/drivers/isdn/gigaset/usb-gigaset.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/isdn/gigaset/usb-gigaset.c	2007-03-30 21:20:24.334486323 +0200
@@ -50,7 +50,7 @@ MODULE_PARM_DESC(cidmode, "Call-ID mode"
 #define USB_M105_PRODUCT_ID	0x0009
 
 /* table of devices that work with this driver */
-static struct usb_device_id gigaset_table [] = {
+static const struct usb_device_id gigaset_table [] = {
 	{ USB_DEVICE(USB_M105_VENDOR_ID, USB_M105_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
@@ -860,7 +860,7 @@ static void gigaset_disconnect(struct us
 	gigaset_unassign(cs);
 }
 
-static struct gigaset_ops ops = {
+static const struct gigaset_ops ops = {
 	gigaset_write_cmd,
 	gigaset_write_room,
 	gigaset_chars_in_buffer,
diff -purN linux-2.6.21-rc5-git4/drivers/net/atl1/atl1_main.c linux-2.6.21-rc5-git6/drivers/net/atl1/atl1_main.c
--- linux-2.6.21-rc5-git4/drivers/net/atl1/atl1_main.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/net/atl1/atl1_main.c	2007-03-30 21:20:24.354486358 +0200
@@ -2320,6 +2320,16 @@ static void __devexit atl1_remove(struct
 		return;
 
 	adapter = netdev_priv(netdev);
+
+	/* Some atl1 boards lack persistent storage for their MAC, and get it
+	 * from the BIOS during POST.  If we've been messing with the MAC
+	 * address, we need to save the permanent one.
+	 */
+	if (memcmp(adapter->hw.mac_addr, adapter->hw.perm_mac_addr, ETH_ALEN)) {
+		memcpy(adapter->hw.mac_addr, adapter->hw.perm_mac_addr, ETH_ALEN);
+		atl1_set_mac_addr(&adapter->hw);
+	}
+
 	iowrite16(0, adapter->hw.hw_addr + REG_GPHY_ENABLE);
 	unregister_netdev(netdev);
 	pci_iounmap(pdev, adapter->hw.hw_addr);
diff -purN linux-2.6.21-rc5-git4/drivers/net/bnx2.c linux-2.6.21-rc5-git6/drivers/net/bnx2.c
--- linux-2.6.21-rc5-git4/drivers/net/bnx2.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/net/bnx2.c	2007-03-30 21:20:24.354486358 +0200
@@ -54,8 +54,8 @@
 
 #define DRV_MODULE_NAME		"bnx2"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"1.5.5"
-#define DRV_MODULE_RELDATE	"February 1, 2007"
+#define DRV_MODULE_VERSION	"1.5.6"
+#define DRV_MODULE_RELDATE	"March 28, 2007"
 
 #define RUN_AT(x) (jiffies + (x))
 
@@ -2033,8 +2033,8 @@ bnx2_has_work(struct bnx2 *bp)
 	    (sblk->status_tx_quick_consumer_index0 != bp->hw_tx_cons))
 		return 1;
 
-	if (((sblk->status_attn_bits & STATUS_ATTN_BITS_LINK_STATE) != 0) !=
-	    bp->link_up)
+	if ((sblk->status_attn_bits & STATUS_ATTN_BITS_LINK_STATE) !=
+	    (sblk->status_attn_bits_ack & STATUS_ATTN_BITS_LINK_STATE))
 		return 1;
 
 	return 0;
diff -purN linux-2.6.21-rc5-git4/drivers/net/ifb.c linux-2.6.21-rc5-git6/drivers/net/ifb.c
--- linux-2.6.21-rc5-git4/drivers/net/ifb.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/net/ifb.c	2007-03-30 21:20:24.354486358 +0200
@@ -96,17 +96,24 @@ static void ri_tasklet(unsigned long dev
 		skb->tc_verd = SET_TC_NCLS(skb->tc_verd);
 		stats->tx_packets++;
 		stats->tx_bytes +=skb->len;
+
+		skb->dev = __dev_get_by_index(skb->iif);
+		if (!skb->dev) {
+			dev_kfree_skb(skb);
+			stats->tx_dropped++;
+			break;
+		}
+		skb->iif = _dev->ifindex;
+
 		if (from & AT_EGRESS) {
 			dp->st_rx_frm_egr++;
 			dev_queue_xmit(skb);
 		} else if (from & AT_INGRESS) {
-
 			dp->st_rx_frm_ing++;
+			skb_pull(skb, skb->dev->hard_header_len);
 			netif_rx(skb);
-		} else {
-			dev_kfree_skb(skb);
-			stats->tx_dropped++;
-		}
+		} else
+			BUG();
 	}
 
 	if (netif_tx_trylock(_dev)) {
@@ -157,26 +164,10 @@ static int ifb_xmit(struct sk_buff *skb,
 	stats->rx_packets++;
 	stats->rx_bytes+=skb->len;
 
-	if (!from || !skb->input_dev) {
-dropped:
+	if (!(from & (AT_INGRESS|AT_EGRESS)) || !skb->iif) {
 		dev_kfree_skb(skb);
 		stats->rx_dropped++;
 		return ret;
-	} else {
-		/*
-		 * note we could be going
-		 * ingress -> egress or
-		 * egress -> ingress
-		*/
-		skb->dev = skb->input_dev;
-		skb->input_dev = dev;
-		if (from & AT_INGRESS) {
-			skb_pull(skb, skb->dev->hard_header_len);
-		} else {
-			if (!(from & AT_EGRESS)) {
-				goto dropped;
-			}
-		}
 	}
 
 	if (skb_queue_len(&dp->rq) >= dev->tx_queue_len) {
diff -purN linux-2.6.21-rc5-git4/drivers/net/netxen/netxen_nic_init.c linux-2.6.21-rc5-git6/drivers/net/netxen/netxen_nic_init.c
--- linux-2.6.21-rc5-git4/drivers/net/netxen/netxen_nic_init.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/net/netxen/netxen_nic_init.c	2007-03-30 21:20:24.364486376 +0200
@@ -438,6 +438,7 @@ do_rom_fast_read_words(struct netxen_ada
 
 	for (addridx = addr; addridx < (addr + size); addridx += 4) {
 		ret = do_rom_fast_read(adapter, addridx, (int *)bytes);
+		*(int *)bytes = cpu_to_le32(*(int *)bytes);
 		if (ret != 0)
 			break;
 		bytes += 4;
@@ -497,7 +498,7 @@ static inline int do_rom_fast_write_word
 		int timeout = 0;
 		int data;
 
-		data = *(u32*)bytes;
+		data = le32_to_cpu((*(u32*)bytes));
 
 		ret = do_rom_fast_write(adapter, addridx, data);
 		if (ret < 0)
diff -purN linux-2.6.21-rc5-git4/drivers/net/sis190.c linux-2.6.21-rc5-git6/drivers/net/sis190.c
--- linux-2.6.21-rc5-git4/drivers/net/sis190.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/drivers/net/sis190.c	2007-03-30 21:20:24.364486376 +0200
@@ -324,6 +324,7 @@ static struct mii_chip_info {
 	u32 feature;
 } mii_chip_table[] = {
 	{ "Broadcom PHY BCM5461", { 0x0020, 0x60c0 }, LAN, F_PHY_BCM5461 },
+	{ "Broadcom PHY AC131",   { 0x0143, 0xbc70 }, LAN, 0 },
 	{ "Agere PHY ET1101B",    { 0x0282, 0xf010 }, LAN, 0 },
 	{ "Marvell PHY 88E1111",  { 0x0141, 0x0cc0 }, LAN, F_PHY_88E1111 },
 	{ "Realtek PHY RTL8201",  { 0x0000, 0x8200 }, LAN, 0 },
diff -purN linux-2.6.21-rc5-git4/fs/hostfs/hostfs_kern.c linux-2.6.21-rc5-git6/fs/hostfs/hostfs_kern.c
--- linux-2.6.21-rc5-git4/fs/hostfs/hostfs_kern.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/fs/hostfs/hostfs_kern.c	2007-03-30 21:20:24.404486446 +0200
@@ -20,7 +20,6 @@
 #include "hostfs.h"
 #include "kern_util.h"
 #include "kern.h"
-#include "user_util.h"
 #include "init.h"
 
 struct hostfs_inode_info {
@@ -939,7 +938,7 @@ static const struct address_space_operat
 static int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)
 {
 	struct inode *root_inode;
-	char *name, *data = d;
+	char *host_root_path, *req_root = d;
 	int err;
 
 	sb->s_blocksize = 1024;
@@ -948,16 +947,16 @@ static int hostfs_fill_sb_common(struct 
 	sb->s_op = &hostfs_sbops;
 
 	/* NULL is printed as <NULL> by sprintf: avoid that. */
-	if (data == NULL)
-		data = "";
+	if (req_root == NULL)
+		req_root = "";
 
 	err = -ENOMEM;
-	name = kmalloc(strlen(root_ino) + 1
-			+ strlen(data) + 1, GFP_KERNEL);
-	if(name == NULL)
+	host_root_path = kmalloc(strlen(root_ino) + 1
+				 + strlen(req_root) + 1, GFP_KERNEL);
+	if(host_root_path == NULL)
 		goto out;
 
-	sprintf(name, "%s/%s", root_ino, data);
+	sprintf(host_root_path, "%s/%s", root_ino, req_root);
 
 	root_inode = iget(sb, 0);
 	if(root_inode == NULL)
@@ -967,10 +966,10 @@ static int hostfs_fill_sb_common(struct 
 	if(err)
 		goto out_put;
 
-	HOSTFS_I(root_inode)->host_filename = name;
-	/* Avoid that in the error path, iput(root_inode) frees again name through
-	 * hostfs_destroy_inode! */
-	name = NULL;
+	HOSTFS_I(root_inode)->host_filename = host_root_path;
+	/* Avoid that in the error path, iput(root_inode) frees again
+	 * host_root_path through hostfs_destroy_inode! */
+	host_root_path = NULL;
 
 	err = -ENOMEM;
 	sb->s_root = d_alloc_root(root_inode);
@@ -990,7 +989,7 @@ static int hostfs_fill_sb_common(struct 
  out_put:
         iput(root_inode);
  out_free:
-	kfree(name);
+	kfree(host_root_path);
  out:
 	return(err);
 }
diff -purN linux-2.6.21-rc5-git4/fs/splice.c linux-2.6.21-rc5-git6/fs/splice.c
--- linux-2.6.21-rc5-git4/fs/splice.c	2007-03-30 21:19:43.534414604 +0200
+++ linux-2.6.21-rc5-git6/fs/splice.c	2007-03-30 21:20:24.414486464 +0200
@@ -627,18 +627,25 @@ find_page:
 	}
 
 	ret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);
-	if (!ret) {
+	if (ret) {
+		if (ret == AOP_TRUNCATED_PAGE) {
+			page_cache_release(page);
+			goto find_page;
+		}
+		if (ret < 0)
+			goto out;
 		/*
-		 * Return the number of bytes written and mark page as
-		 * accessed, we are now done!
+		 * Partial write has happened, so 'ret' already initialized by
+		 * number of bytes written, Where is nothing we have to do here.
 		 */
+	} else
 		ret = this_len;
-		mark_page_accessed(page);
-		balance_dirty_pages_ratelimited(mapping);
-	} else if (ret == AOP_TRUNCATED_PAGE) {
-		page_cache_release(page);
-		goto find_page;
-	}
+	/*
+	 * Return the number of bytes written and mark page as
+	 * accessed, we are now done!
+	 */
+	mark_page_accessed(page);
+	balance_dirty_pages_ratelimited(mapping);
 out:
 	page_cache_release(page);
 	unlock_page(page);
diff -purN linux-2.6.21-rc5-git4/include/asm-mips/irqflags.h linux-2.6.21-rc5-git6/include/asm-mips/irqflags.h
--- linux-2.6.21-rc5-git4/include/asm-mips/irqflags.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/asm-mips/irqflags.h	2007-03-30 21:20:24.414486464 +0200
@@ -13,29 +13,9 @@
 
 #ifndef __ASSEMBLY__
 
+#include <linux/compiler.h>
 #include <asm/hazards.h>
 
-/*
- * CONFIG_MIPS_MT_SMTC_INSTANT_REPLAY does prompt replay of deferred IPIs,
- * at the cost of branch and call overhead on each local_irq_restore()
- */
-
-#ifdef CONFIG_MIPS_MT_SMTC_INSTANT_REPLAY
-
-extern void smtc_ipi_replay(void);
-
-#define irq_restore_epilog(flags)				\
-do {								\
-	if (!(flags & 0x0400))					\
-		smtc_ipi_replay();				\
-} while (0)
-
-#else
-
-#define irq_restore_epilog(ignore) do { } while (0)
-
-#endif /* CONFIG_MIPS_MT_SMTC_INSTANT_REPLAY */
-
 __asm__ (
 	"	.macro	raw_local_irq_enable				\n"
 	"	.set	push						\n"
@@ -205,17 +185,28 @@ __asm__ (
 	"	.set	pop						\n"
 	"	.endm							\n");
 
-#define raw_local_irq_restore(flags)					\
-do {									\
-	unsigned long __tmp1;						\
-									\
-	__asm__ __volatile__(						\
-		"raw_local_irq_restore\t%0"				\
-		: "=r" (__tmp1)						\
-		: "0" (flags)						\
-		: "memory");						\
-	irq_restore_epilog(flags);					\
-} while(0)
+extern void smtc_ipi_replay(void);
+
+static inline void raw_local_irq_restore(unsigned long flags)
+{
+	unsigned long __tmp1;
+
+#ifdef CONFIG_MIPS_MT_SMTC_INSTANT_REPLAY
+	/*
+	 * CONFIG_MIPS_MT_SMTC_INSTANT_REPLAY does prompt replay of deferred
+	 * IPIs, at the cost of branch and call overhead on each
+	 * local_irq_restore()
+	 */
+	if (unlikely(!(flags & 0x0400)))
+		smtc_ipi_replay();
+#endif
+
+	__asm__ __volatile__(
+		"raw_local_irq_restore\t%0"
+		: "=r" (__tmp1)
+		: "0" (flags)
+		: "memory");
+}
 
 static inline int raw_irqs_disabled_flags(unsigned long flags)
 {
diff -purN linux-2.6.21-rc5-git4/include/asm-mips/marvell.h linux-2.6.21-rc5-git6/include/asm-mips/marvell.h
--- linux-2.6.21-rc5-git4/include/asm-mips/marvell.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/asm-mips/marvell.h	2007-03-30 21:20:24.414486464 +0200
@@ -54,5 +54,6 @@ struct mv_pci_controller {
 };
 
 extern void ll_mv64340_irq(void);
+extern void mv64340_irq_init(unsigned int base);
 
 #endif	/* __ASM_MIPS_MARVELL_H */
diff -purN linux-2.6.21-rc5-git4/include/asm-mips/smtc_ipi.h linux-2.6.21-rc5-git6/include/asm-mips/smtc_ipi.h
--- linux-2.6.21-rc5-git4/include/asm-mips/smtc_ipi.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/asm-mips/smtc_ipi.h	2007-03-30 21:20:24.414486464 +0200
@@ -65,12 +65,10 @@ static inline void smtc_ipi_nq(struct sm
 	spin_unlock_irqrestore(&q->lock, flags);
 }
 
-static inline struct smtc_ipi *smtc_ipi_dq(struct smtc_ipi_q *q)
+static inline struct smtc_ipi *__smtc_ipi_dq(struct smtc_ipi_q *q)
 {
 	struct smtc_ipi *p;
-	long flags;
 
-	spin_lock_irqsave(&q->lock, flags);
 	if (q->head == NULL)
 		p = NULL;
 	else {
@@ -81,7 +79,19 @@ static inline struct smtc_ipi *smtc_ipi_
 		if (q->head == NULL)
 			q->tail = NULL;
 	}
+
+	return p;
+}
+
+static inline struct smtc_ipi *smtc_ipi_dq(struct smtc_ipi_q *q)
+{
+	unsigned long flags;
+	struct smtc_ipi *p;
+
+	spin_lock_irqsave(&q->lock, flags);
+	p = __smtc_ipi_dq(q);
 	spin_unlock_irqrestore(&q->lock, flags);
+
 	return p;
 }
 
diff -purN linux-2.6.21-rc5-git4/include/asm-powerpc/immap_qe.h linux-2.6.21-rc5-git6/include/asm-powerpc/immap_qe.h
--- linux-2.6.21-rc5-git4/include/asm-powerpc/immap_qe.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/asm-powerpc/immap_qe.h	2007-03-30 21:20:24.414486464 +0200
@@ -258,8 +258,9 @@ struct ucc_slow {
 	u8	uccs;		/* UCCx status register */
 	u8	res3[0x24];
 	__be16	utpt;
+	u8	res4[0x52];
 	u8	guemr;		/* UCC general extended mode register */
-	u8	res4[0x200 - 0x091];
+	u8	res5[0x200 - 0x091];
 } __attribute__ ((packed));
 
 /* QE UCC Fast */
diff -purN linux-2.6.21-rc5-git4/include/asm-um/pgtable-2level.h linux-2.6.21-rc5-git6/include/asm-um/pgtable-2level.h
--- linux-2.6.21-rc5-git4/include/asm-um/pgtable-2level.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/asm-um/pgtable-2level.h	2007-03-30 21:20:24.424486481 +0200
@@ -45,12 +45,12 @@ static inline void pgd_mkuptodate(pgd_t 
 	((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
 
 /*
- * Bits 0 through 3 are taken
+ * Bits 0 through 4 are taken
  */
-#define PTE_FILE_MAX_BITS	28
+#define PTE_FILE_MAX_BITS	27
 
-#define pte_to_pgoff(pte) (pte_val(pte) >> 4)
+#define pte_to_pgoff(pte) (pte_val(pte) >> 5)
 
-#define pgoff_to_pte(off) ((pte_t) { ((off) << 4) + _PAGE_FILE })
+#define pgoff_to_pte(off) ((pte_t) { ((off) << 5) + _PAGE_FILE })
 
 #endif
diff -purN linux-2.6.21-rc5-git4/include/asm-x86_64/hw_irq.h linux-2.6.21-rc5-git6/include/asm-x86_64/hw_irq.h
--- linux-2.6.21-rc5-git4/include/asm-x86_64/hw_irq.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/asm-x86_64/hw_irq.h	2007-03-30 21:20:24.424486481 +0200
@@ -38,7 +38,7 @@
 #define IRQ_MOVE_CLEANUP_VECTOR	FIRST_EXTERNAL_VECTOR
  
 /*
- * Vectors 0x20-0x2f are used for ISA interrupts.
+ * Vectors 0x30-0x3f are used for ISA interrupts.
  */
 #define IRQ0_VECTOR		FIRST_EXTERNAL_VECTOR + 0x10
 #define IRQ1_VECTOR		IRQ0_VECTOR + 1
diff -purN linux-2.6.21-rc5-git4/include/linux/skbuff.h linux-2.6.21-rc5-git6/include/linux/skbuff.h
--- linux-2.6.21-rc5-git4/include/linux/skbuff.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/linux/skbuff.h	2007-03-30 21:20:24.424486481 +0200
@@ -188,7 +188,7 @@ enum {
  *	@sk: Socket we are owned by
  *	@tstamp: Time we arrived
  *	@dev: Device we arrived on/are leaving by
- *	@input_dev: Device we arrived on
+ *	@iif: ifindex of device we arrived on
  *	@h: Transport layer header
  *	@nh: Network layer header
  *	@mac: Link layer header
@@ -235,7 +235,8 @@ struct sk_buff {
 	struct sock		*sk;
 	struct skb_timeval	tstamp;
 	struct net_device	*dev;
-	struct net_device	*input_dev;
+	int			iif;
+	/* 4 byte hole on 64 bit*/
 
 	union {
 		struct tcphdr	*th;
diff -purN linux-2.6.21-rc5-git4/include/net/pkt_cls.h linux-2.6.21-rc5-git6/include/net/pkt_cls.h
--- linux-2.6.21-rc5-git4/include/net/pkt_cls.h	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/include/net/pkt_cls.h	2007-03-30 21:20:24.434486499 +0200
@@ -352,10 +352,13 @@ tcf_change_indev(struct tcf_proto *tp, c
 static inline int
 tcf_match_indev(struct sk_buff *skb, char *indev)
 {
+	struct net_device *dev;
+
 	if (indev[0]) {
-		if  (!skb->input_dev)
+		if  (!skb->iif)
 			return 0;
-		if (strcmp(indev, skb->input_dev->name))
+		dev = __dev_get_by_index(skb->iif);
+		if (!dev || strcmp(indev, dev->name))
 			return 0;
 	}
 
diff -purN linux-2.6.21-rc5-git4/kernel/exit.c linux-2.6.21-rc5-git6/kernel/exit.c
--- linux-2.6.21-rc5-git4/kernel/exit.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/kernel/exit.c	2007-03-30 21:20:24.434486499 +0200
@@ -790,7 +790,7 @@ static void exit_notify(struct task_stru
 	
 	pgrp = task_pgrp(tsk);
 	if ((task_pgrp(t) != pgrp) &&
-	    (task_session(t) != task_session(tsk)) &&
+	    (task_session(t) == task_session(tsk)) &&
 	    will_become_orphaned_pgrp(pgrp, tsk) &&
 	    has_stopped_jobs(pgrp)) {
 		__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);
diff -purN linux-2.6.21-rc5-git4/mm/filemap_xip.c linux-2.6.21-rc5-git6/mm/filemap_xip.c
--- linux-2.6.21-rc5-git4/mm/filemap_xip.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/mm/filemap_xip.c	2007-03-30 21:20:24.434486499 +0200
@@ -17,6 +17,29 @@
 #include "filemap.h"
 
 /*
+ * We do use our own empty page to avoid interference with other users
+ * of ZERO_PAGE(), such as /dev/zero
+ */
+static struct page *__xip_sparse_page;
+
+static struct page *xip_sparse_page(void)
+{
+	if (!__xip_sparse_page) {
+		unsigned long zeroes = get_zeroed_page(GFP_HIGHUSER);
+		if (zeroes) {
+			static DEFINE_SPINLOCK(xip_alloc_lock);
+			spin_lock(&xip_alloc_lock);
+			if (!__xip_sparse_page)
+				__xip_sparse_page = virt_to_page(zeroes);
+			else
+				free_page(zeroes);
+			spin_unlock(&xip_alloc_lock);
+		}
+	}
+	return __xip_sparse_page;
+}
+
+/*
  * This is a file read routine for execute in place files, and uses
  * the mapping->a_ops->get_xip_page() function for the actual low-level
  * stuff.
@@ -162,7 +185,7 @@ EXPORT_SYMBOL_GPL(xip_file_sendfile);
  * xip_write
  *
  * This function walks all vmas of the address_space and unmaps the
- * ZERO_PAGE when found at pgoff. Should it go in rmap.c?
+ * __xip_sparse_page when found at pgoff.
  */
 static void
 __xip_unmap (struct address_space * mapping,
@@ -177,13 +200,16 @@ __xip_unmap (struct address_space * mapp
 	spinlock_t *ptl;
 	struct page *page;
 
+	page = __xip_sparse_page;
+	if (!page)
+		return;
+
 	spin_lock(&mapping->i_mmap_lock);
 	vma_prio_tree_foreach(vma, &iter, &mapping->i_mmap, pgoff, pgoff) {
 		mm = vma->vm_mm;
 		address = vma->vm_start +
 			((pgoff - vma->vm_pgoff) << PAGE_SHIFT);
 		BUG_ON(address < vma->vm_start || address >= vma->vm_end);
-		page = ZERO_PAGE(0);
 		pte = page_check_address(page, mm, address, &ptl);
 		if (pte) {
 			/* Nuke the page table entry. */
@@ -222,16 +248,14 @@ xip_file_nopage(struct vm_area_struct * 
 		+ area->vm_pgoff;
 
 	size = (i_size_read(inode) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-	if (pgoff >= size) {
-		return NULL;
-	}
+	if (pgoff >= size)
+		return NOPAGE_SIGBUS;
 
 	page = mapping->a_ops->get_xip_page(mapping, pgoff*(PAGE_SIZE/512), 0);
-	if (!IS_ERR(page)) {
+	if (!IS_ERR(page))
 		goto out;
-	}
 	if (PTR_ERR(page) != -ENODATA)
-		return NULL;
+		return NOPAGE_SIGBUS;
 
 	/* sparse block */
 	if ((area->vm_flags & (VM_WRITE | VM_MAYWRITE)) &&
@@ -241,12 +265,14 @@ xip_file_nopage(struct vm_area_struct * 
 		page = mapping->a_ops->get_xip_page (mapping,
 			pgoff*(PAGE_SIZE/512), 1);
 		if (IS_ERR(page))
-			return NULL;
+			return NOPAGE_SIGBUS;
 		/* unmap page at pgoff from all other vmas */
 		__xip_unmap(mapping, pgoff);
 	} else {
-		/* not shared and writable, use ZERO_PAGE() */
-		page = ZERO_PAGE(0);
+		/* not shared and writable, use xip_sparse_page() */
+		page = xip_sparse_page();
+		if (!page)
+			return NOPAGE_OOM;
 	}
 
 out:
diff -purN linux-2.6.21-rc5-git4/mm/madvise.c linux-2.6.21-rc5-git6/mm/madvise.c
--- linux-2.6.21-rc5-git4/mm/madvise.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/mm/madvise.c	2007-03-30 21:20:24.434486499 +0200
@@ -159,9 +159,10 @@ static long madvise_remove(struct vm_are
 				unsigned long start, unsigned long end)
 {
 	struct address_space *mapping;
-        loff_t offset, endoff;
+	loff_t offset, endoff;
+	int error;
 
-	*prev = vma;
+	*prev = NULL;	/* tell sys_madvise we drop mmap_sem */
 
 	if (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))
 		return -EINVAL;
@@ -180,7 +181,12 @@ static long madvise_remove(struct vm_are
 			+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);
 	endoff = (loff_t)(end - vma->vm_start - 1)
 			+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);
-	return  vmtruncate_range(mapping->host, offset, endoff);
+
+	/* vmtruncate_range needs to take i_mutex and i_alloc_sem */
+	up_write(&current->mm->mmap_sem);
+	error = vmtruncate_range(mapping->host, offset, endoff);
+	down_write(&current->mm->mmap_sem);
+	return error;
 }
 
 static long
@@ -315,12 +321,15 @@ asmlinkage long sys_madvise(unsigned lon
 		if (error)
 			goto out;
 		start = tmp;
-		if (start < prev->vm_end)
+		if (prev && start < prev->vm_end)
 			start = prev->vm_end;
 		error = unmapped_error;
 		if (start >= end)
 			goto out;
-		vma = prev->vm_next;
+		if (prev)
+			vma = prev->vm_next;
+		else	/* madvise_remove dropped mmap_sem */
+			vma = find_vma(current->mm, start);
 	}
 out:
 	up_write(&current->mm->mmap_sem);
diff -purN linux-2.6.21-rc5-git4/mm/shmem.c linux-2.6.21-rc5-git6/mm/shmem.c
--- linux-2.6.21-rc5-git4/mm/shmem.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/mm/shmem.c	2007-03-30 21:20:24.434486499 +0200
@@ -402,26 +402,38 @@ static swp_entry_t *shmem_swp_alloc(stru
 /*
  * shmem_free_swp - free some swap entries in a directory
  *
- * @dir:   pointer to the directory
- * @edir:  pointer after last entry of the directory
+ * @dir:        pointer to the directory
+ * @edir:       pointer after last entry of the directory
+ * @punch_lock: pointer to spinlock when needed for the holepunch case
  */
-static int shmem_free_swp(swp_entry_t *dir, swp_entry_t *edir)
+static int shmem_free_swp(swp_entry_t *dir, swp_entry_t *edir,
+						spinlock_t *punch_lock)
 {
+	spinlock_t *punch_unlock = NULL;
 	swp_entry_t *ptr;
 	int freed = 0;
 
 	for (ptr = dir; ptr < edir; ptr++) {
 		if (ptr->val) {
+			if (unlikely(punch_lock)) {
+				punch_unlock = punch_lock;
+				punch_lock = NULL;
+				spin_lock(punch_unlock);
+				if (!ptr->val)
+					continue;
+			}
 			free_swap_and_cache(*ptr);
 			*ptr = (swp_entry_t){0};
 			freed++;
 		}
 	}
+	if (punch_unlock)
+		spin_unlock(punch_unlock);
 	return freed;
 }
 
-static int shmem_map_and_free_swp(struct page *subdir,
-		int offset, int limit, struct page ***dir)
+static int shmem_map_and_free_swp(struct page *subdir, int offset,
+		int limit, struct page ***dir, spinlock_t *punch_lock)
 {
 	swp_entry_t *ptr;
 	int freed = 0;
@@ -431,7 +443,8 @@ static int shmem_map_and_free_swp(struct
 		int size = limit - offset;
 		if (size > LATENCY_LIMIT)
 			size = LATENCY_LIMIT;
-		freed += shmem_free_swp(ptr+offset, ptr+offset+size);
+		freed += shmem_free_swp(ptr+offset, ptr+offset+size,
+							punch_lock);
 		if (need_resched()) {
 			shmem_swp_unmap(ptr);
 			if (*dir) {
@@ -481,7 +494,10 @@ static void shmem_truncate_range(struct 
 	long nr_swaps_freed = 0;
 	int offset;
 	int freed;
-	int punch_hole = 0;
+	int punch_hole;
+	spinlock_t *needs_lock;
+	spinlock_t *punch_lock;
+	unsigned long upper_limit;
 
 	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
 	idx = (start + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
@@ -492,11 +508,20 @@ static void shmem_truncate_range(struct 
 	info->flags |= SHMEM_TRUNCATE;
 	if (likely(end == (loff_t) -1)) {
 		limit = info->next_index;
+		upper_limit = SHMEM_MAX_INDEX;
 		info->next_index = idx;
+		needs_lock = NULL;
+		punch_hole = 0;
 	} else {
-		limit = (end + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
-		if (limit > info->next_index)
-			limit = info->next_index;
+		if (end + 1 >= inode->i_size) {	/* we may free a little more */
+			limit = (inode->i_size + PAGE_CACHE_SIZE - 1) >>
+							PAGE_CACHE_SHIFT;
+			upper_limit = SHMEM_MAX_INDEX;
+		} else {
+			limit = (end + 1) >> PAGE_CACHE_SHIFT;
+			upper_limit = limit;
+		}
+		needs_lock = &info->lock;
 		punch_hole = 1;
 	}
 
@@ -513,17 +538,30 @@ static void shmem_truncate_range(struct 
 		size = limit;
 		if (size > SHMEM_NR_DIRECT)
 			size = SHMEM_NR_DIRECT;
-		nr_swaps_freed = shmem_free_swp(ptr+idx, ptr+size);
+		nr_swaps_freed = shmem_free_swp(ptr+idx, ptr+size, needs_lock);
 	}
 
 	/*
 	 * If there are no indirect blocks or we are punching a hole
 	 * below indirect blocks, nothing to be done.
 	 */
-	if (!topdir || (punch_hole && (limit <= SHMEM_NR_DIRECT)))
+	if (!topdir || limit <= SHMEM_NR_DIRECT)
 		goto done2;
 
-	BUG_ON(limit <= SHMEM_NR_DIRECT);
+	/*
+	 * The truncation case has already dropped info->lock, and we're safe
+	 * because i_size and next_index have already been lowered, preventing
+	 * access beyond.  But in the punch_hole case, we still need to take
+	 * the lock when updating the swap directory, because there might be
+	 * racing accesses by shmem_getpage(SGP_CACHE), shmem_unuse_inode or
+	 * shmem_writepage.  However, whenever we find we can remove a whole
+	 * directory page (not at the misaligned start or end of the range),
+	 * we first NULLify its pointer in the level above, and then have no
+	 * need to take the lock when updating its contents: needs_lock and
+	 * punch_lock (either pointing to info->lock or NULL) manage this.
+	 */
+
+	upper_limit -= SHMEM_NR_DIRECT;
 	limit -= SHMEM_NR_DIRECT;
 	idx = (idx > SHMEM_NR_DIRECT)? (idx - SHMEM_NR_DIRECT): 0;
 	offset = idx % ENTRIES_PER_PAGE;
@@ -543,8 +581,14 @@ static void shmem_truncate_range(struct 
 		if (*dir) {
 			diroff = ((idx - ENTRIES_PER_PAGEPAGE/2) %
 				ENTRIES_PER_PAGEPAGE) / ENTRIES_PER_PAGE;
-			if (!diroff && !offset) {
-				*dir = NULL;
+			if (!diroff && !offset && upper_limit >= stage) {
+				if (needs_lock) {
+					spin_lock(needs_lock);
+					*dir = NULL;
+					spin_unlock(needs_lock);
+					needs_lock = NULL;
+				} else
+					*dir = NULL;
 				nr_pages_to_free++;
 				list_add(&middir->lru, &pages_to_free);
 			}
@@ -570,39 +614,55 @@ static void shmem_truncate_range(struct 
 			}
 			stage = idx + ENTRIES_PER_PAGEPAGE;
 			middir = *dir;
-			*dir = NULL;
-			nr_pages_to_free++;
-			list_add(&middir->lru, &pages_to_free);
+			if (punch_hole)
+				needs_lock = &info->lock;
+			if (upper_limit >= stage) {
+				if (needs_lock) {
+					spin_lock(needs_lock);
+					*dir = NULL;
+					spin_unlock(needs_lock);
+					needs_lock = NULL;
+				} else
+					*dir = NULL;
+				nr_pages_to_free++;
+				list_add(&middir->lru, &pages_to_free);
+			}
 			shmem_dir_unmap(dir);
 			cond_resched();
 			dir = shmem_dir_map(middir);
 			diroff = 0;
 		}
+		punch_lock = needs_lock;
 		subdir = dir[diroff];
-		if (subdir && page_private(subdir)) {
+		if (subdir && !offset && upper_limit-idx >= ENTRIES_PER_PAGE) {
+			if (needs_lock) {
+				spin_lock(needs_lock);
+				dir[diroff] = NULL;
+				spin_unlock(needs_lock);
+				punch_lock = NULL;
+			} else
+				dir[diroff] = NULL;
+			nr_pages_to_free++;
+			list_add(&subdir->lru, &pages_to_free);
+		}
+		if (subdir && page_private(subdir) /* has swap entries */) {
 			size = limit - idx;
 			if (size > ENTRIES_PER_PAGE)
 				size = ENTRIES_PER_PAGE;
 			freed = shmem_map_and_free_swp(subdir,
-						offset, size, &dir);
+					offset, size, &dir, punch_lock);
 			if (!dir)
 				dir = shmem_dir_map(middir);
 			nr_swaps_freed += freed;
-			if (offset)
+			if (offset || punch_lock) {
 				spin_lock(&info->lock);
-			set_page_private(subdir, page_private(subdir) - freed);
-			if (offset)
+				set_page_private(subdir,
+					page_private(subdir) - freed);
 				spin_unlock(&info->lock);
-			if (!punch_hole)
-				BUG_ON(page_private(subdir) > offset);
-		}
-		if (offset)
-			offset = 0;
-		else if (subdir && !page_private(subdir)) {
-			dir[diroff] = NULL;
-			nr_pages_to_free++;
-			list_add(&subdir->lru, &pages_to_free);
+			} else
+				BUG_ON(page_private(subdir) != freed);
 		}
+		offset = 0;
 	}
 done1:
 	shmem_dir_unmap(dir);
@@ -614,8 +674,16 @@ done2:
 		 * generic_delete_inode did it, before we lowered next_index.
 		 * Also, though shmem_getpage checks i_size before adding to
 		 * cache, no recheck after: so fix the narrow window there too.
+		 *
+		 * Recalling truncate_inode_pages_range and unmap_mapping_range
+		 * every time for punch_hole (which never got a chance to clear
+		 * SHMEM_PAGEIN at the start of vmtruncate_range) is expensive,
+		 * yet hardly ever necessary: try to optimize them out later.
 		 */
 		truncate_inode_pages_range(inode->i_mapping, start, end);
+		if (punch_hole)
+			unmap_mapping_range(inode->i_mapping, start,
+							end - start, 1);
 	}
 
 	spin_lock(&info->lock);
diff -purN linux-2.6.21-rc5-git4/net/bluetooth/hidp/core.c linux-2.6.21-rc5-git6/net/bluetooth/hidp/core.c
--- linux-2.6.21-rc5-git4/net/bluetooth/hidp/core.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/net/bluetooth/hidp/core.c	2007-03-30 21:20:24.444486516 +0200
@@ -679,6 +679,27 @@ static void hidp_close(struct hid_device
 {
 }
 
+static const struct {
+	__u16 idVendor;
+	__u16 idProduct;
+	unsigned quirks;
+} hidp_blacklist[] = {
+	/* Apple wireless Mighty Mouse */
+	{ 0x05ac, 0x030c, HID_QUIRK_MIGHTYMOUSE | HID_QUIRK_INVERT_HWHEEL },
+
+	{ }	/* Terminating entry */
+};
+
+static void hidp_setup_quirks(struct hid_device *hid)
+{
+	unsigned int n;
+
+	for (n = 0; hidp_blacklist[n].idVendor; n++)
+		if (hidp_blacklist[n].idVendor == le16_to_cpu(hid->vendor) &&
+				hidp_blacklist[n].idProduct == le16_to_cpu(hid->product))
+			hid->quirks = hidp_blacklist[n].quirks;
+}
+
 static inline void hidp_setup_hid(struct hidp_session *session, struct hidp_connadd_req *req)
 {
 	struct hid_device *hid = session->hid;
@@ -708,6 +729,8 @@ static inline void hidp_setup_hid(struct
 
 	hid->hidinput_input_event = hidp_hidinput_event;
 
+	hidp_setup_quirks(hid);
+
 	list_for_each_entry(report, &hid->report_enum[HID_INPUT_REPORT].report_list, list)
 		hidp_send_report(session, report);
 
diff -purN linux-2.6.21-rc5-git4/net/core/dev.c linux-2.6.21-rc5-git6/net/core/dev.c
--- linux-2.6.21-rc5-git4/net/core/dev.c	2007-03-30 21:19:43.544414621 +0200
+++ linux-2.6.21-rc5-git6/net/core/dev.c	2007-03-30 21:20:24.444486516 +0200
@@ -1741,8 +1741,8 @@ static int ing_filter(struct sk_buff *sk
 	if (dev->qdisc_ingress) {
 		__u32 ttl = (__u32) G_TC_RTTL(skb->tc_verd);
 		if (MAX_RED_LOOP < ttl++) {
-			printk(KERN_WARNING "Redir loop detected Dropping packet (%s->%s)\n",
-				skb->input_dev->name, skb->dev->name);
+			printk(KERN_WARNING "Redir loop detected Dropping packet (%d->%d)\n",
+				skb->iif, skb->dev->ifindex);
 			return TC_ACT_SHOT;
 		}
 
@@ -1775,8 +1775,8 @@ int netif_receive_skb(struct sk_buff *sk
 	if (!skb->tstamp.off_sec)
 		net_timestamp(skb);
 
-	if (!skb->input_dev)
-		skb->input_dev = skb->dev;
+	if (!skb->iif)
+		skb->iif = skb->dev->ifindex;
 
 	orig_dev = skb_bond(skb);
 
diff -purN linux-2.6.21-rc5-git4/net/core/skbuff.c linux-2.6.21-rc5-git6/net/core/skbuff.c
--- linux-2.6.21-rc5-git4/net/core/skbuff.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/net/core/skbuff.c	2007-03-30 21:20:24.444486516 +0200
@@ -496,7 +496,7 @@ struct sk_buff *skb_clone(struct sk_buff
 	n->tc_verd = SET_TC_VERD(skb->tc_verd,0);
 	n->tc_verd = CLR_TC_OK2MUNGE(n->tc_verd);
 	n->tc_verd = CLR_TC_MUNGED(n->tc_verd);
-	C(input_dev);
+	C(iif);
 #endif
 	skb_copy_secmark(n, skb);
 #endif
diff -purN linux-2.6.21-rc5-git4/net/sched/act_mirred.c linux-2.6.21-rc5-git6/net/sched/act_mirred.c
--- linux-2.6.21-rc5-git4/net/sched/act_mirred.c	2007-03-26 00:56:23.000000000 +0200
+++ linux-2.6.21-rc5-git6/net/sched/act_mirred.c	2007-03-30 21:20:24.464486552 +0200
@@ -198,7 +198,7 @@ bad_mirred:
 		skb2->tc_verd = SET_TC_FROM(skb2->tc_verd, at);
 
 	skb2->dev = dev;
-	skb2->input_dev = skb->dev;
+	skb2->iif = skb->dev->ifindex;
 	dev_queue_xmit(skb2);
 	spin_unlock(&m->tcf_lock);
 	return m->tcf_action;
